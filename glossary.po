# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2021
# Osamu NAKAMURA, 2021
# Yusuke Miyazaki <miyazaki.dev@gmail.com>, 2021
# mollinaca, 2021
# 菊池 健志, 2023
# Arihiro TAKASE, 2023
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2023
# TENMYO Masakazu, 2024
# Taichi Haradaguchi, 2024
# 石井 明久, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-20 06:40+0000\n"
"PO-Revision-Date: 2021-06-28 00:47+0000\n"
"Last-Translator: 石井 明久, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../glossary.rst:5
msgid "Glossary"
msgstr "用語集"

#: ../../glossary.rst:10
msgid "``>>>``"
msgstr "``>>>``"

#: ../../glossary.rst:12
msgid ""
"The default Python prompt of the :term:`interactive` shell.  Often seen for "
"code examples which can be executed interactively in the interpreter."
msgstr ""
"対話型 (:term:`interactive`) シェルにおけるデフォルトの Python プロンプトで"
"す。インタープリターで対話的に実行されるコード例でよく見られます。"

#: ../../glossary.rst:15
msgid "``...``"
msgstr "``...``"

#: ../../glossary.rst:17
msgid "Can refer to:"
msgstr "次のものが考えられます:"

#: ../../glossary.rst:19
msgid ""
"The default Python prompt of the :term:`interactive` shell when entering the "
"code for an indented code block, when within a pair of matching left and "
"right delimiters (parentheses, square brackets, curly braces or triple "
"quotes), or after specifying a decorator."
msgstr ""
"対話型 (:term:`interactive`) シェルにおいて、インデントされたコードブロック、"
"対応する左右の区切り文字の組 (丸括弧、角括弧、波括弧、三重引用符) の内側、デ"
"コレーターの後に、コードを入力する際に表示されるデフォルトの Python プロンプ"
"トです。"

#: ../../glossary.rst:24
msgid "The :const:`Ellipsis` built-in constant."
msgstr "組み込みの定数 :const:`Ellipsis` 。"

#: ../../glossary.rst:25
msgid "abstract base class"
msgstr "abstract base class"

#: ../../glossary.rst:27
msgid ""
"Abstract base classes complement :term:`duck-typing` by providing a way to "
"define interfaces when other techniques like :func:`hasattr` would be clumsy "
"or subtly wrong (for example with :ref:`magic methods <special-lookup>`).  "
"ABCs introduce virtual subclasses, which are classes that don't inherit from "
"a class but are still recognized by :func:`isinstance` and :func:"
"`issubclass`; see the :mod:`abc` module documentation.  Python comes with "
"many built-in ABCs for data structures (in the :mod:`collections.abc` "
"module), numbers (in the :mod:`numbers` module), streams (in the :mod:`io` "
"module), import finders and loaders (in the :mod:`importlib.abc` module).  "
"You can create your own ABCs with the :mod:`abc` module."
msgstr ""
"(抽象基底クラス) 抽象基底クラスは :term:`duck-typing` を補完するもので、 :"
"func:`hasattr` などの別のテクニックでは不恰好であったり微妙に誤る (例えば :"
"ref:`magic methods <special-lookup>` の場合) 場合にインターフェースを定義する"
"方法を提供します。ABC は仮想 (virtual) サブクラスを導入します。これは親クラス"
"から継承しませんが、それでも :func:`isinstance` や :func:`issubclass` に認識"
"されます; :mod:`abc` モジュールのドキュメントを参照してください。Python に"
"は、多くの組み込み ABC が同梱されています。その対象は、(:mod:`collections."
"abc` モジュールで) データ構造、(:mod:`numbers` モジュールで) 数、(:mod:`io` "
"モジュールで) ストリーム、(:mod:`importlib.abc` モジュールで) インポートファ"
"インダ及びローダーです。 :mod:`abc` モジュールを利用して独自の ABC を作成でき"
"ます。"

#: ../../glossary.rst:38
msgid "annotation"
msgstr "annotation"

#: ../../glossary.rst:40
msgid ""
"A label associated with a variable, a class attribute or a function "
"parameter or return value, used by convention as a :term:`type hint`."
msgstr ""
"(アノテーション) 変数、クラス属性、関数のパラメータや返り値に関係するラベルで"
"す。\n"
"慣例により :term:`type hint` として使われています。"

#: ../../glossary.rst:44
msgid ""
"Annotations of local variables cannot be accessed at runtime, but "
"annotations of global variables, class attributes, and functions are stored "
"in the :attr:`__annotations__` special attribute of modules, classes, and "
"functions, respectively."
msgstr ""
"ローカル変数のアノテーションは実行時にはアクセスできませんが、グローバル変"
"数、クラス属性、関数のアノテーションはそれぞれモジュール、クラス、関数の :"
"attr:`__annotations__` 特殊属性に保持されています。"

#: ../../glossary.rst:50
msgid ""
"See :term:`variable annotation`, :term:`function annotation`, :pep:`484` "
"and :pep:`526`, which describe this functionality. Also see :ref:"
"`annotations-howto` for best practices on working with annotations."
msgstr ""
"機能の説明がある :term:`variable annotation`, :term:`function annotation`, :"
"pep:`484`, :pep:`526` を参照してください。また、アノテーションを利用するベス"
"トプラクティスとして :ref:`annotations-howto` も参照してください。"

#: ../../glossary.rst:54
msgid "argument"
msgstr "引数 (argument)"

#: ../../glossary.rst:56
msgid ""
"A value passed to a :term:`function` (or :term:`method`) when calling the "
"function.  There are two kinds of argument:"
msgstr ""
"(実引数) 関数を呼び出す際に、 :term:`関数<function>` (または :term:`メソッド "
"<method>`) に渡す値です。実引数には２種類あります:"

#: ../../glossary.rst:59
msgid ""
":dfn:`keyword argument`: an argument preceded by an identifier (e.g. "
"``name=``) in a function call or passed as a value in a dictionary preceded "
"by ``**``.  For example, ``3`` and ``5`` are both keyword arguments in the "
"following calls to :func:`complex`::"
msgstr ""
":dfn:`キーワード引数`: 関数呼び出しの際に引数の前に識別子がついたもの (例: "
"``name=``) や、 ``**`` に続けた辞書の中の値として渡された引数。例えば、次の :"
"func:`complex` の呼び出しでは、 ``3`` と ``5`` がキーワード引数です::"

#: ../../glossary.rst:67
msgid ""
":dfn:`positional argument`: an argument that is not a keyword argument. "
"Positional arguments can appear at the beginning of an argument list and/or "
"be passed as elements of an :term:`iterable` preceded by ``*``. For example, "
"``3`` and ``5`` are both positional arguments in the following calls::"
msgstr ""
":dfn:`位置引数`: キーワード引数以外の引数。位置引数は引数リストの先頭に書くこ"
"とができ、また ``*`` に続けた :term:`iterable` の要素として渡すことができま"
"す。例えば、次の例では ``3`` と ``5`` は両方共位置引数です::"

#: ../../glossary.rst:76
msgid ""
"Arguments are assigned to the named local variables in a function body. See "
"the :ref:`calls` section for the rules governing this assignment. "
"Syntactically, any expression can be used to represent an argument; the "
"evaluated value is assigned to the local variable."
msgstr ""
"実引数は関数の実体において名前付きのローカル変数に割り当てられます。割り当て"
"を行う規則については :ref:`calls` を参照してください。シンタックスにおいて実"
"引数を表すためにあらゆる式を使うことが出来ます。評価された値はローカル変数に"
"割り当てられます。"

#: ../../glossary.rst:81
msgid ""
"See also the :term:`parameter` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"and :pep:`362`."
msgstr ""
":term:`仮引数<parameter>` 、FAQ の :ref:`実引数と仮引数の違いは何ですか? "
"<faq-argument-vs-parameter>` 、:pep:`362` を参照してください。"

#: ../../glossary.rst:84
msgid "asynchronous context manager"
msgstr "asynchronous context manager"

#: ../../glossary.rst:86
msgid ""
"An object which controls the environment seen in an :keyword:`async with` "
"statement by defining :meth:`~object.__aenter__` and :meth:`~object."
"__aexit__` methods.  Introduced by :pep:`492`."
msgstr ""
"(非同期コンテキストマネージャ)\n"
":meth:`~object.__aenter__` と :meth:`~object.__aexit__` メソッドを定義するこ"
"とで :keyword:`async with` 文内の環境を管理するオブジェクトです。  :pep:"
"`492` で導入されました。"

#: ../../glossary.rst:89
msgid "asynchronous generator"
msgstr "asynchronous generator"

#: ../../glossary.rst:91
msgid ""
"A function which returns an :term:`asynchronous generator iterator`.  It "
"looks like a coroutine function defined with :keyword:`async def` except "
"that it contains :keyword:`yield` expressions for producing a series of "
"values usable in an :keyword:`async for` loop."
msgstr ""
"(非同期ジェネレータ)\n"
":term:`asynchronous generator iterator` を返す関数です。\n"
":keyword:`async def` で定義されたコルーチン関数に似ていますが、 :keyword:"
"`yield` 式を持つ点で異なります。\n"
":keyword:`yield` 式は :keyword:`async for` ループで使用できる値の並びを生成す"
"るのに使用されます。"

#: ../../glossary.rst:96
msgid ""
"Usually refers to an asynchronous generator function, but may refer to an "
"*asynchronous generator iterator* in some contexts.  In cases where the "
"intended meaning isn't clear, using the full terms avoids ambiguity."
msgstr ""
"通常は非同期ジェネレータ関数を指しますが、文脈によっては *非同期ジェネレータ"
"イテレータ* を指す場合があります。\n"
"意図された意味が明らかでない場合、 明瞭化のために完全な単語を使用します。"

#: ../../glossary.rst:100
msgid ""
"An asynchronous generator function may contain :keyword:`await` expressions "
"as well as :keyword:`async for`, and :keyword:`async with` statements."
msgstr ""
"非同期ジェネレータ関数には、 :keyword:`async for` 文や :keyword:`async with` "
"文だけでなく :keyword:`await` 式もあることがあります。"

#: ../../glossary.rst:103
msgid "asynchronous generator iterator"
msgstr "asynchronous generator iterator"

#: ../../glossary.rst:105
msgid "An object created by a :term:`asynchronous generator` function."
msgstr ""
"(非同期ジェネレータイテレータ)\n"
":term:`asynchronous generator` 関数で生成されるオブジェクトです。"

#: ../../glossary.rst:107
msgid ""
"This is an :term:`asynchronous iterator` which when called using the :meth:"
"`~object.__anext__` method returns an awaitable object which will execute "
"the body of the asynchronous generator function until the next :keyword:"
"`yield` expression."
msgstr ""
"これは :term:`asynchronous iterator` で、 :meth:`~object.__anext__` メソッド"
"を使って呼ばれると awaitable オブジェクトを返します。  この awaitable オブ"
"ジェクトは、次の :keyword:`yield` 式まで非同期ジェネレータ関数の本体を実行し"
"ます。"

#: ../../glossary.rst:112
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"location execution state (including local variables and pending try-"
"statements).  When the *asynchronous generator iterator* effectively resumes "
"with another awaitable returned by :meth:`~object.__anext__`, it picks up "
"where it left off.  See :pep:`492` and :pep:`525`."
msgstr ""
"各 :keyword:`yield` では一時的に処理を中断し、その場の実行状態 (ローカル変数"
"や保留中の try 文を含む) を記憶します。  *非同期ジェネレータイテレータ* が :"
"meth:`~object.__anext__` で返された他の awaitable で実際に再開する時には、そ"
"の中断箇所が選ばれます。  :pep:`492` および :pep:`525` を参照してください。"

#: ../../glossary.rst:117
msgid "asynchronous iterable"
msgstr "asynchronous iterable"

#: ../../glossary.rst:119
msgid ""
"An object, that can be used in an :keyword:`async for` statement. Must "
"return an :term:`asynchronous iterator` from its :meth:`~object.__aiter__` "
"method.  Introduced by :pep:`492`."
msgstr ""
"(非同期イテラブル)\n"
":keyword:`async for` 文の中で使用できるオブジェクトです。  自身の :meth:"
"`~object.__aiter__` メソッドから :term:`asynchronous iterator` を返さなければ"
"なりません。  :pep:`492` で導入されました。"

#: ../../glossary.rst:122
msgid "asynchronous iterator"
msgstr "asynchronous iterator"

#: ../../glossary.rst:124
msgid ""
"An object that implements the :meth:`~object.__aiter__` and :meth:`~object."
"__anext__` methods.  :meth:`~object.__anext__` must return an :term:"
"`awaitable` object. :keyword:`async for` resolves the awaitables returned by "
"an asynchronous iterator's :meth:`~object.__anext__` method until it raises "
"a :exc:`StopAsyncIteration` exception.  Introduced by :pep:`492`."
msgstr ""
"(非同期イテレータ)\n"
":meth:`~object.__aiter__` と :meth:`~object.__anext__` メソッドを実装したオブ"
"ジェクトです。  :meth:`~object.__anext__` は :term:`awaitable` オブジェクトを"
"返さなければなりません。  :keyword:`async for` は :exc:`StopAsyncIteration` "
"例外を送出するまで、非同期イテレータの :meth:`~object.__anext__` メソッドが返"
"す awaitable を解決します。  :pep:`492` で導入されました。"

#: ../../glossary.rst:129
msgid "attribute"
msgstr "属性"

#: ../../glossary.rst:131
msgid ""
"A value associated with an object which is usually referenced by name using "
"dotted expressions. For example, if an object *o* has an attribute *a* it "
"would be referenced as *o.a*."
msgstr ""
"(属性) オブジェクトに関連付けられ、ドット表記式によって名前で通常参照される値"
"です。例えば、オブジェクト *o* が属性 *a* を持っているとき、その属性は *o.a* "
"で参照されます。"

#: ../../glossary.rst:136
msgid ""
"It is possible to give an object an attribute whose name is not an "
"identifier as defined by :ref:`identifiers`, for example using :func:"
"`setattr`, if the object allows it. Such an attribute will not be accessible "
"using a dotted expression, and would instead need to be retrieved with :func:"
"`getattr`."
msgstr ""
"オブジェクトには、 :ref:`identifiers` で定義される識別子ではない名前の属性を"
"与えることができます。たとえば :func:`setattr` を使い、オブジェクトがそれを許"
"可している場合に行えます。このような属性はドット表記式ではアクセスできず、代"
"わりに :func:`getattr` を使って取る必要があります。"

#: ../../glossary.rst:141
msgid "awaitable"
msgstr "awaitable"

#: ../../glossary.rst:143
msgid ""
"An object that can be used in an :keyword:`await` expression.  Can be a :"
"term:`coroutine` or an object with an :meth:`~object.__await__` method. See "
"also :pep:`492`."
msgstr ""
"(待機可能)\n"
":keyword:`await` 式で使用することが出来るオブジェクトです。  :term:"
"`coroutine` か、 :meth:`~object.__await__` メソッドがあるオブジェクトです。 :"
"pep:`492` を参照してください。"

#: ../../glossary.rst:146
msgid "BDFL"
msgstr "BDFL"

#: ../../glossary.rst:148
msgid ""
"Benevolent Dictator For Life, a.k.a. `Guido van Rossum <https://gvanrossum."
"github.io/>`_, Python's creator."
msgstr ""
"慈悲深き終身独裁者 (Benevolent Dictator For Life) の略です。Python の作者、"
"`Guido van Rossum <https://gvanrossum.github.io/>`_ のことです。"

#: ../../glossary.rst:150
msgid "binary file"
msgstr "binary file"

#: ../../glossary.rst:152
msgid ""
"A :term:`file object` able to read and write :term:`bytes-like objects "
"<bytes-like object>`. Examples of binary files are files opened in binary "
"mode (``'rb'``, ``'wb'`` or ``'rb+'``), :data:`sys.stdin.buffer <sys."
"stdin>`, :data:`sys.stdout.buffer <sys.stdout>`, and instances of :class:`io."
"BytesIO` and :class:`gzip.GzipFile`."
msgstr ""
"(バイナリファイル)\n"
":term:`bytes-like オブジェクト <bytes-like object>` の読み込みおよび書き込み"
"ができる :term:`ファイルオブジェクト <file object>` です。\n"
"バイナリファイルの例は、バイナリモード (``'rb'``, ``'wb'`` or ``'rb+'``) で開"
"かれたファイル、:data:`sys.stdin.buffer <sys.stdin>`、:data:`sys.stdout."
"buffer <sys.stdout>`、 :class:`io.BytesIO` や :class:`gzip.GzipFile`. のイン"
"スタンスです。"

#: ../../glossary.rst:159
msgid ""
"See also :term:`text file` for a file object able to read and write :class:"
"`str` objects."
msgstr ""
":class:`str` オブジェクトの読み書きができるファイルオブジェクトについては、 :"
"term:`text file` も参照してください。"

#: ../../glossary.rst:161
msgid "borrowed reference"
msgstr ""

#: ../../glossary.rst:163
msgid ""
"In Python's C API, a borrowed reference is a reference to an object, where "
"the code using the object does not own the reference. It becomes a dangling "
"pointer if the object is destroyed. For example, a garbage collection can "
"remove the last :term:`strong reference` to the object and so destroy it."
msgstr ""

#: ../../glossary.rst:169
msgid ""
"Calling :c:func:`Py_INCREF` on the :term:`borrowed reference` is recommended "
"to convert it to a :term:`strong reference` in-place, except when the object "
"cannot be destroyed before the last usage of the borrowed reference. The :c:"
"func:`Py_NewRef` function can be used to create a new :term:`strong "
"reference`."
msgstr ""

#: ../../glossary.rst:174
msgid "bytes-like object"
msgstr "bytes-like object"

#: ../../glossary.rst:176
msgid ""
"An object that supports the :ref:`bufferobjects` and can export a C-:term:"
"`contiguous` buffer. This includes all :class:`bytes`, :class:`bytearray`, "
"and :class:`array.array` objects, as well as many common :class:`memoryview` "
"objects.  Bytes-like objects can be used for various operations that work "
"with binary data; these include compression, saving to a binary file, and "
"sending over a socket."
msgstr ""
":ref:`bufferobjects` をサポートしていて、 C 言語の意味で :term:`連続した "
"<contiguous>` バッファーを提供可能なオブジェクト。\n"
":class:`bytes`, :class:`bytearray`, :class:`array.array` や、多くの一般的な :"
"class:`memoryview` オブジェクトがこれに当たります。\n"
"bytes-like オブジェクトは、データ圧縮、バイナリファイルへの保存、ソケットを経"
"由した送信など、バイナリデータを要求するいろいろな操作に利用することができま"
"す。"

#: ../../glossary.rst:183
msgid ""
"Some operations need the binary data to be mutable.  The documentation often "
"refers to these as \"read-write bytes-like objects\".  Example mutable "
"buffer objects include :class:`bytearray` and a :class:`memoryview` of a :"
"class:`bytearray`. Other operations require the binary data to be stored in "
"immutable objects (\"read-only bytes-like objects\"); examples of these "
"include :class:`bytes` and a :class:`memoryview` of a :class:`bytes` object."
msgstr ""
"幾つかの操作ではバイナリデータを変更する必要があります。\n"
"その操作のドキュメントではよく \"読み書き可能な bytes-like オブジェクト\" に"
"言及しています。\n"
"変更可能なバッファーオブジェクトには、 :class:`bytearray` と :class:"
"`bytearray` の :class:`memoryview` などが含まれます。\n"
"また、他の幾つかの操作では不変なオブジェクト内のバイナリデータ (\"読み出し専"
"用の bytes-like オブジェクト\") を必要します。それには :class:`bytes` と :"
"class:`bytes` の :class:`memoryview` オブジェクトが含まれます。"

#: ../../glossary.rst:191
msgid "bytecode"
msgstr "bytecode"

#: ../../glossary.rst:193
msgid ""
"Python source code is compiled into bytecode, the internal representation of "
"a Python program in the CPython interpreter.  The bytecode is also cached in "
"``.pyc`` files so that executing the same file is faster the second time "
"(recompilation from source to bytecode can be avoided).  This \"intermediate "
"language\" is said to run on a :term:`virtual machine` that executes the "
"machine code corresponding to each bytecode. Do note that bytecodes are not "
"expected to work between different Python virtual machines, nor to be stable "
"between Python releases."
msgstr ""
"(バイトコード) Python のソースコードは、 Python プログラムの CPython インタプ"
"リタの内部表現であるバイトコードへとコンパイルされます。\n"
"バイトコードは ``.pyc`` ファイルにキャッシュされ、同じファイルが二度目に実行"
"されるときはより高速になります (ソースコードからバイトコードへの再度のコンパ"
"イルは回避されます)。\n"
"この \"中間言語 (intermediate language)\" は、各々のバイトコードに対応する機"
"械語を実行する :term:`仮想マシン <virtual machine>` で動作するといえます。\n"
"重要な注意として、バイトコードは異なる Python 仮想マシン間で動作することや、"
"Python リリース間で安定であることは期待されていません。"

#: ../../glossary.rst:203
msgid ""
"A list of bytecode instructions can be found in the documentation for :ref:"
"`the dis module <bytecodes>`."
msgstr ""
"バイトコードの命令一覧は :ref:`dis モジュール <bytecodes>` にあります。"

#: ../../glossary.rst:205
msgid "callable"
msgstr "callable"

#: ../../glossary.rst:207
msgid ""
"A callable is an object that can be called, possibly with a set of arguments "
"(see :term:`argument`), with the following syntax::"
msgstr ""

#: ../../glossary.rst:212
msgid ""
"A :term:`function`, and by extension a :term:`method`, is a callable. An "
"instance of a class that implements the :meth:`~object.__call__` method is "
"also a callable."
msgstr ""

#: ../../glossary.rst:215
msgid "callback"
msgstr "callback"

#: ../../glossary.rst:217
msgid ""
"A subroutine function which is passed as an argument to be executed at some "
"point in the future."
msgstr "(コールバック) 将来のある時点で実行されるために引数として渡される関数"

#: ../../glossary.rst:219
msgid "class"
msgstr "クラス"

#: ../../glossary.rst:221
msgid ""
"A template for creating user-defined objects. Class definitions normally "
"contain method definitions which operate on instances of the class."
msgstr ""
"(クラス) ユーザー定義オブジェクトを作成するためのテンプレートです。クラス定義"
"は普通、そのクラスのインスタンス上の操作をするメソッドの定義を含みます。"

#: ../../glossary.rst:224
msgid "class variable"
msgstr "class variable"

#: ../../glossary.rst:226
msgid ""
"A variable defined in a class and intended to be modified only at class "
"level (i.e., not in an instance of the class)."
msgstr ""
"(クラス変数) クラス上に定義され、クラスレベルで (つまり、クラスのインスタンス"
"上ではなしに) 変更されることを目的としている変数です。"

#: ../../glossary.rst:228
msgid "complex number"
msgstr "complex number"

#: ../../glossary.rst:230
msgid ""
"An extension of the familiar real number system in which all numbers are "
"expressed as a sum of a real part and an imaginary part.  Imaginary numbers "
"are real multiples of the imaginary unit (the square root of ``-1``), often "
"written ``i`` in mathematics or ``j`` in engineering.  Python has built-in "
"support for complex numbers, which are written with this latter notation; "
"the imaginary part is written with a ``j`` suffix, e.g., ``3+1j``.  To get "
"access to complex equivalents of the :mod:`math` module, use :mod:`cmath`.  "
"Use of complex numbers is a fairly advanced mathematical feature.  If you're "
"not aware of a need for them, it's almost certain you can safely ignore them."
msgstr ""
"(複素数) よく知られている実数系を拡張したもので、すべての数は実部と虚部の和と"
"して表されます。虚数は虚数単位 (``-1`` の平方根) に実数を掛けたもので、一般に"
"数学では ``i`` と書かれ、工学では ``j`` と書かれます。Python は複素数に組み込"
"みで対応し、後者の表記を取っています。虚部は末尾に ``j`` をつけて書きます。例"
"えば ``3+1j`` です。 :mod:`math` モジュールの複素数版を利用するには、 :mod:"
"`cmath` を使います。複素数の使用はかなり高度な数学の機能です。必要性を感じな"
"ければ、ほぼ間違いなく無視してしまってよいでしょう。"

#: ../../glossary.rst:240
msgid "context manager"
msgstr "context manager"

#: ../../glossary.rst:242
msgid ""
"An object which controls the environment seen in a :keyword:`with` statement "
"by defining :meth:`~object.__enter__` and :meth:`~object.__exit__` methods. "
"See :pep:`343`."
msgstr ""

#: ../../glossary.rst:245
msgid "context variable"
msgstr "context variable"

#: ../../glossary.rst:247
msgid ""
"A variable which can have different values depending on its context. This is "
"similar to Thread-Local Storage in which each execution thread may have a "
"different value for a variable. However, with context variables, there may "
"be several contexts in one execution thread and the main usage for context "
"variables is to keep track of variables in concurrent asynchronous tasks. "
"See :mod:`contextvars`."
msgstr ""
"(コンテキスト変数) コンテキストに依存して異なる値を持つ変数。\n"
"これは、ある変数の値が各々の実行スレッドで異なり得るスレッドローカルストレー"
"ジに似ています。\n"
"しかしコンテキスト変数では、 1 つの実行スレッドにいくつかのコンテキストがあり"
"得、コンテキスト変数の主な用途は並列な非同期タスクの変数の追跡です。\n"
":mod:`contextvars` を参照してください。"

#: ../../glossary.rst:254
msgid "contiguous"
msgstr "contiguous"

#: ../../glossary.rst:258
msgid ""
"A buffer is considered contiguous exactly if it is either *C-contiguous* or "
"*Fortran contiguous*.  Zero-dimensional buffers are C and Fortran "
"contiguous.  In one-dimensional arrays, the items must be laid out in memory "
"next to each other, in order of increasing indexes starting from zero.  In "
"multidimensional C-contiguous arrays, the last index varies the fastest when "
"visiting items in order of memory address.  However, in Fortran contiguous "
"arrays, the first index varies the fastest."
msgstr ""
"(隣接、連続) バッファが厳密に *C-連続* または *Fortran 連続* である場合に、そ"
"のバッファは連続しているとみなせます。\n"
"ゼロ次元バッファは C 連続であり Fortran 連続です。\n"
"一次元の配列では、その要素は必ずメモリ上で隣接するように配置され、添字がゼロ"
"から始まり増えていく順序で並びます。\n"
"多次元の C-連続な配列では、メモリアドレス順に要素を巡る際には最後の添え字が最"
"初に変わるのに対し、 Fortran 連続な配列では最初の添え字が最初に動きます。"

#: ../../glossary.rst:266
msgid "coroutine"
msgstr "コルーチン"

#: ../../glossary.rst:268
msgid ""
"Coroutines are a more generalized form of subroutines. Subroutines are "
"entered at one point and exited at another point.  Coroutines can be "
"entered, exited, and resumed at many different points.  They can be "
"implemented with the :keyword:`async def` statement.  See also :pep:`492`."
msgstr ""
"(コルーチン) コルーチンはサブルーチンのより一般的な形式です。\n"
"サブルーチンには決められた地点から入り、別の決められた地点から出ます。\n"
"コルーチンには多くの様々な地点から入る、出る、再開することができます。\n"
"コルーチンは :keyword:`async def` 文で実装できます。\n"
":pep:`492` を参照してください。"

#: ../../glossary.rst:273
msgid "coroutine function"
msgstr "coroutine function"

#: ../../glossary.rst:275
msgid ""
"A function which returns a :term:`coroutine` object.  A coroutine function "
"may be defined with the :keyword:`async def` statement, and may contain :"
"keyword:`await`, :keyword:`async for`, and :keyword:`async with` keywords.  "
"These were introduced by :pep:`492`."
msgstr ""
"(コルーチン関数)\n"
":term:`coroutine` オブジェクトを返す関数です。\n"
"コルーチン関数は :keyword:`async def` 文で実装され、:keyword:`await`、:"
"keyword:`async for`、 および :keyword:`async with` キーワードを持つことが出来"
"ます。\n"
"これらは :pep:`492` で導入されました。"

#: ../../glossary.rst:280
msgid "CPython"
msgstr "CPython"

#: ../../glossary.rst:282
msgid ""
"The canonical implementation of the Python programming language, as "
"distributed on `python.org <https://www.python.org>`_.  The term \"CPython\" "
"is used when necessary to distinguish this implementation from others such "
"as Jython or IronPython."
msgstr ""
"`python.org <https://www.python.org>`_ で配布されている、Python プログラミン"
"グ言語の標準的な実装です。\"CPython\" という単語は、この実装を Jython や "
"IronPython といった他の実装と区別する必要が有る場合に利用されます。"

#: ../../glossary.rst:286
msgid "decorator"
msgstr "decorator"

#: ../../glossary.rst:288
msgid ""
"A function returning another function, usually applied as a function "
"transformation using the ``@wrapper`` syntax.  Common examples for "
"decorators are :func:`classmethod` and :func:`staticmethod`."
msgstr ""
"(デコレータ) 別の関数を返す関数で、通常、 ``@wrapper`` 構文で関数変換として適"
"用されます。デコレータの一般的な利用例は、 :func:`classmethod` と :func:"
"`staticmethod` です。"

#: ../../glossary.rst:292
msgid ""
"The decorator syntax is merely syntactic sugar, the following two function "
"definitions are semantically equivalent::"
msgstr ""
"デコレータの文法はシンタックスシュガーです。次の2つの関数定義は意味的に同じも"
"のです::"

#: ../../glossary.rst:303
msgid ""
"The same concept exists for classes, but is less commonly used there.  See "
"the documentation for :ref:`function definitions <function>` and :ref:`class "
"definitions <class>` for more about decorators."
msgstr ""
"同じ概念がクラスにも存在しますが、あまり使われません。デコレータについて詳し"
"くは、 :ref:`関数定義 <function>` および :ref:`クラス定義 <class>` のドキュメ"
"ントを参照してください。"

#: ../../glossary.rst:306
msgid "descriptor"
msgstr "descriptor"

#: ../../glossary.rst:308
msgid ""
"Any object which defines the methods :meth:`~object.__get__`, :meth:`~object."
"__set__`, or :meth:`~object.__delete__`. When a class attribute is a "
"descriptor, its special binding behavior is triggered upon attribute "
"lookup.  Normally, using *a.b* to get, set or delete an attribute looks up "
"the object named *b* in the class dictionary for *a*, but if *b* is a "
"descriptor, the respective descriptor method gets called.  Understanding "
"descriptors is a key to a deep understanding of Python because they are the "
"basis for many features including functions, methods, properties, class "
"methods, static methods, and reference to super classes."
msgstr ""

#: ../../glossary.rst:319
msgid ""
"For more information about descriptors' methods, see :ref:`descriptors` or "
"the :ref:`Descriptor How To Guide <descriptorhowto>`."
msgstr ""
"デスクリプタのメソッドに関しての詳細は、 :ref:`descriptors` や :ref:"
"`Descriptor How To Guide <descriptorhowto>` を参照してください。"

#: ../../glossary.rst:321
msgid "dictionary"
msgstr "dictionary"

#: ../../glossary.rst:323
msgid ""
"An associative array, where arbitrary keys are mapped to values.  The keys "
"can be any object with :meth:`~object.__hash__` and :meth:`~object.__eq__` "
"methods. Called a hash in Perl."
msgstr ""

#: ../../glossary.rst:327
msgid "dictionary comprehension"
msgstr "dictionary comprehension"

#: ../../glossary.rst:329
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a dictionary with the results. ``results = {n: n ** 2 for n in "
"range(10)}`` generates a dictionary containing key ``n`` mapped to value ``n "
"** 2``. See :ref:`comprehensions`."
msgstr ""
"(辞書内包表記) iterable 内の全てあるいは一部の要素を処理して、その結果からな"
"る辞書を返すコンパクトな書き方です。 ``results = {n: n ** 2 for n in "
"range(10)}`` とすると、キー ``n`` を値 ``n ** 2`` に対応付ける辞書を生成しま"
"す。 :ref:`comprehensions` を参照してください。"

#: ../../glossary.rst:333
msgid "dictionary view"
msgstr "dictionary view"

#: ../../glossary.rst:335
msgid ""
"The objects returned from :meth:`dict.keys`, :meth:`dict.values`, and :meth:"
"`dict.items` are called dictionary views. They provide a dynamic view on the "
"dictionary’s entries, which means that when the dictionary changes, the view "
"reflects these changes. To force the dictionary view to become a full list "
"use ``list(dictview)``.  See :ref:`dict-views`."
msgstr ""
"(辞書ビュー)\n"
":meth:`dict.keys`、:meth:`dict.values`、:meth:`dict.items` が返すオブジェクト"
"です。\n"
"辞書の項目の動的なビューを提供します。\n"
"すなわち、辞書が変更されるとビューはそれを反映します。\n"
"辞書ビューを強制的に完全なリストにするには ``list(dictview)`` を使用してくだ"
"さい。 \n"
":ref:`dict-views` を参照してください。"

#: ../../glossary.rst:341
msgid "docstring"
msgstr "docstring"

#: ../../glossary.rst:343
msgid ""
"A string literal which appears as the first expression in a class, function "
"or module.  While ignored when the suite is executed, it is recognized by "
"the compiler and put into the :attr:`!__doc__` attribute of the enclosing "
"class, function or module.  Since it is available via introspection, it is "
"the canonical place for documentation of the object."
msgstr ""

#: ../../glossary.rst:349
msgid "duck-typing"
msgstr "duck-typing"

#: ../../glossary.rst:351
msgid ""
"A programming style which does not look at an object's type to determine if "
"it has the right interface; instead, the method or attribute is simply "
"called or used (\"If it looks like a duck and quacks like a duck, it must be "
"a duck.\")  By emphasizing interfaces rather than specific types, well-"
"designed code improves its flexibility by allowing polymorphic "
"substitution.  Duck-typing avoids tests using :func:`type` or :func:"
"`isinstance`.  (Note, however, that duck-typing can be complemented with :"
"term:`abstract base classes <abstract base class>`.)  Instead, it typically "
"employs :func:`hasattr` tests or :term:`EAFP` programming."
msgstr ""
"あるオブジェクトが正しいインターフェースを持っているかを決定するのにオブジェ"
"クトの型を見ないプログラミングスタイルです。代わりに、単純にオブジェクトのメ"
"ソッドや属性が呼ばれたり使われたりします。（「アヒルのように見えて、アヒルの"
"ように鳴けば、それはアヒルである。」）インターフェースを型より重視すること"
"で、上手くデザインされたコードは、ポリモーフィックな代替を許して柔軟性を向上"
"させます。ダックタイピングは :func:`type` や :func:`isinstance` による判定を"
"避けます。 (ただし、ダックタイピングを :term:`抽象基底クラス <abstract base "
"class>` で補完することもできます。) その代わり、典型的に :func:`hasattr` 判定"
"や :term:`EAFP` プログラミングを利用します。"

#: ../../glossary.rst:360
msgid "EAFP"
msgstr "EAFP"

#: ../../glossary.rst:362
msgid ""
"Easier to ask for forgiveness than permission.  This common Python coding "
"style assumes the existence of valid keys or attributes and catches "
"exceptions if the assumption proves false.  This clean and fast style is "
"characterized by the presence of many :keyword:`try` and :keyword:`except` "
"statements.  The technique contrasts with the :term:`LBYL` style common to "
"many other languages such as C."
msgstr ""
"「認可をとるより許しを請う方が容易  (easier to ask for forgiveness than "
"permission、マーフィーの法則)」の略です。この Python で広く使われているコー"
"ディングスタイルでは、通常は有効なキーや属性が存在するものと仮定し、その仮定"
"が誤っていた場合に例外を捕捉します。この簡潔で手早く書けるコーディングスタイ"
"ルには、 :keyword:`try` 文および :keyword:`except` 文がたくさんあるのが特徴で"
"す。このテクニックは、C のような言語でよく使われている :term:`LBYL` スタイル"
"と対照的なものです。"

#: ../../glossary.rst:368
msgid "expression"
msgstr "expression"

#: ../../glossary.rst:370
msgid ""
"A piece of syntax which can be evaluated to some value.  In other words, an "
"expression is an accumulation of expression elements like literals, names, "
"attribute access, operators or function calls which all return a value.  In "
"contrast to many other languages, not all language constructs are "
"expressions.  There are also :term:`statement`\\s which cannot be used as "
"expressions, such as :keyword:`while`.  Assignments are also statements, not "
"expressions."
msgstr ""
"(式) 何かの値と評価される、一まとまりの構文 (a piece of syntax) です。言い換"
"えると、式とはリテラル、名前、属性アクセス、演算子や関数呼び出しなど、値を返"
"す式の要素の積み重ねです。他の多くの言語と違い、Python では言語の全ての構成要"
"素が式というわけではありません。 :keyword:`while` のように、式としては使えな"
"い :term:`文 <statement>` もあります。代入も式ではなく文です。"

#: ../../glossary.rst:377
msgid "extension module"
msgstr "extension module"

#: ../../glossary.rst:379
msgid ""
"A module written in C or C++, using Python's C API to interact with the core "
"and with user code."
msgstr ""
"(拡張モジュール) C や C++ で書かれたモジュールで、Python の C API を利用して "
"Python コアやユーザーコードとやりとりします。"

#: ../../glossary.rst:381
msgid "f-string"
msgstr "f-string"

#: ../../glossary.rst:383
msgid ""
"String literals prefixed with ``'f'`` or ``'F'`` are commonly called \"f-"
"strings\" which is short for :ref:`formatted string literals <f-strings>`.  "
"See also :pep:`498`."
msgstr ""
"``'f'`` や ``'F'`` が先頭に付いた文字列リテラルは \"f-string\" と呼ばれ、これ"
"は :ref:`フォーマット済み文字列リテラル <f-strings>` の短縮形の名称です。\n"
":pep:`498` も参照してください。"

#: ../../glossary.rst:386
msgid "file object"
msgstr "file object"

#: ../../glossary.rst:388
msgid ""
"An object exposing a file-oriented API (with methods such as :meth:`!read` "
"or :meth:`!write`) to an underlying resource.  Depending on the way it was "
"created, a file object can mediate access to a real on-disk file or to "
"another type of storage or communication device (for example standard input/"
"output, in-memory buffers, sockets, pipes, etc.).  File objects are also "
"called :dfn:`file-like objects` or :dfn:`streams`."
msgstr ""

#: ../../glossary.rst:396
msgid ""
"There are actually three categories of file objects: raw :term:`binary files "
"<binary file>`, buffered :term:`binary files <binary file>` and :term:`text "
"files <text file>`. Their interfaces are defined in the :mod:`io` module.  "
"The canonical way to create a file object is by using the :func:`open` "
"function."
msgstr ""
"ファイルオブジェクトには実際には 3 種類あります: 生の :term:`バイナリーファイ"
"ル <binary file>`、バッファされた :term:`バイナリーファイル <binary file>`、"
"そして :term:`テキストファイル<text file>` です。インターフェイスは :mod:"
"`io` モジュールで定義されています。ファイルオブジェクトを作る標準的な方法は :"
"func:`open` 関数を使うことです。"

#: ../../glossary.rst:401
msgid "file-like object"
msgstr "file-like object"

#: ../../glossary.rst:403
msgid "A synonym for :term:`file object`."
msgstr ":term:`file object` と同義です。"

#: ../../glossary.rst:404
msgid "filesystem encoding and error handler"
msgstr ""

#: ../../glossary.rst:406
msgid ""
"Encoding and error handler used by Python to decode bytes from the operating "
"system and encode Unicode to the operating system."
msgstr ""

#: ../../glossary.rst:409
msgid ""
"The filesystem encoding must guarantee to successfully decode all bytes "
"below 128. If the file system encoding fails to provide this guarantee, API "
"functions can raise :exc:`UnicodeError`."
msgstr ""
"ファイルシステムのエンコーディングでは、すべてが 128 バイト以下に正常にデコー"
"ドされることが保証されなくてはなりません。ファイルシステムのエンコーディング"
"でこれが保証されなかった場合は、API 関数が :exc:`UnicodeError` を送出すること"
"があります。"

#: ../../glossary.rst:413
msgid ""
"The :func:`sys.getfilesystemencoding` and :func:`sys."
"getfilesystemencodeerrors` functions can be used to get the filesystem "
"encoding and error handler."
msgstr ""

#: ../../glossary.rst:417
msgid ""
"The :term:`filesystem encoding and error handler` are configured at Python "
"startup by the :c:func:`PyConfig_Read` function: see :c:member:`~PyConfig."
"filesystem_encoding` and :c:member:`~PyConfig.filesystem_errors` members of :"
"c:type:`PyConfig`."
msgstr ""

#: ../../glossary.rst:422
msgid "See also the :term:`locale encoding`."
msgstr ""

#: ../../glossary.rst:423
msgid "finder"
msgstr "finder"

#: ../../glossary.rst:425
msgid ""
"An object that tries to find the :term:`loader` for a module that is being "
"imported."
msgstr ""
"(ファインダ)\n"
"インポートされているモジュールの :term:`loader` の発見を試行するオブジェクト"
"です。"

#: ../../glossary.rst:428
msgid ""
"There are two types of finder: :term:`meta path finders <meta path finder>` "
"for use with :data:`sys.meta_path`, and :term:`path entry finders <path "
"entry finder>` for use with :data:`sys.path_hooks`."
msgstr ""

#: ../../glossary.rst:432
msgid "See :ref:`importsystem` and :mod:`importlib` for much more detail."
msgstr ""

#: ../../glossary.rst:433
msgid "floor division"
msgstr "floor division"

#: ../../glossary.rst:435
msgid ""
"Mathematical division that rounds down to nearest integer.  The floor "
"division operator is ``//``.  For example, the expression ``11 // 4`` "
"evaluates to ``2`` in contrast to the ``2.75`` returned by float true "
"division.  Note that ``(-11) // 4`` is ``-3`` because that is ``-2.75`` "
"rounded *downward*. See :pep:`238`."
msgstr ""
"(切り捨て除算) 一番近い整数に切り捨てる数学的除算。\n"
"切り捨て除算演算子は ``//`` です。\n"
"例えば、 ``11 // 4`` は ``2`` になり、それとは対称に浮動小数点数の真の除算で"
"は ``2.75`` が 返ってきます。\n"
"``(-11) // 4`` は ``-2.75`` を *小さい方に* 丸める (訳注: 負の無限大への丸め"
"を行う) ので ``-3`` になることに注意してください。\n"
":pep:`238` を参照してください。"

#: ../../glossary.rst:440
msgid "free threading"
msgstr ""

#: ../../glossary.rst:442
msgid ""
"A threading model where multiple threads can run Python bytecode "
"simultaneously within the same interpreter.  This is in contrast to the :"
"term:`global interpreter lock` which allows only one thread to execute "
"Python bytecode at a time.  See :pep:`703`."
msgstr ""

#: ../../glossary.rst:446
msgid "function"
msgstr "関数"

#: ../../glossary.rst:448
msgid ""
"A series of statements which returns some value to a caller. It can also be "
"passed zero or more :term:`arguments <argument>` which may be used in the "
"execution of the body. See also :term:`parameter`, :term:`method`, and the :"
"ref:`function` section."
msgstr ""
"(関数) 呼び出し側に値を返す一連の文のことです。関数には0以上の :term:`実引数 "
"<argument>` を渡すことが出来ます。実体の実行時に引数を使用することが出来ま"
"す。 :term:`仮引数 <parameter>`、:term:`メソッド <method>`、:ref:`function` "
"を参照してください。"

#: ../../glossary.rst:452
msgid "function annotation"
msgstr "function annotation"

#: ../../glossary.rst:454
msgid "An :term:`annotation` of a function parameter or return value."
msgstr ""
"(関数アノテーション) 関数のパラメータや返り値の :term:`annotation` です。"

#: ../../glossary.rst:456
msgid ""
"Function annotations are usually used for :term:`type hints <type hint>`: "
"for example, this function is expected to take two :class:`int` arguments "
"and is also expected to have an :class:`int` return value::"
msgstr ""
"関数アノテーションは、通常は :term:`型ヒント <type hint>` のために使われま"
"す: 例えば、この関数は 2 つの :class:`int` 型の引数を取ると期待され、また :"
"class:`int` 型の返り値を持つと期待されています。"

#: ../../glossary.rst:464
msgid "Function annotation syntax is explained in section :ref:`function`."
msgstr "関数アノテーションの文法は :ref:`function` の節で解説されています。"

#: ../../glossary.rst:466
msgid ""
"See :term:`variable annotation` and :pep:`484`, which describe this "
"functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"機能の説明がある :term:`variable annotation`, :pep:`484`,を参照してください。"
"また、アノテーションを利用するベストプラクティスとして :ref:`annotations-"
"howto` も参照してください。"

#: ../../glossary.rst:470
msgid "__future__"
msgstr "__future__"

#: ../../glossary.rst:472
msgid ""
"A :ref:`future statement <future>`, ``from __future__ import <feature>``, "
"directs the compiler to compile the current module using syntax or semantics "
"that will become standard in a future release of Python. The :mod:"
"`__future__` module documents the possible values of *feature*.  By "
"importing this module and evaluating its variables, you can see when a new "
"feature was first added to the language and when it will (or did) become the "
"default::"
msgstr ""
"``from __future__ import <feature>`` という :ref:`future 文 <future>` は、コ"
"ンパイラーに将来の Python リリースで標準となる構文や意味を使用して現在のモ"
"ジュールをコンパイルするよう指示します。 :mod:`__future__` モジュールでは、 "
"*feature* のとりうる値をドキュメント化しています。このモジュールをインポート"
"し、その変数を評価することで、新機能が最初に言語に追加されたのはいつかや、い"
"つデフォルトになるか (またはなったか) を見ることができます::"

#: ../../glossary.rst:483
msgid "garbage collection"
msgstr "garbage collection"

#: ../../glossary.rst:485
msgid ""
"The process of freeing memory when it is not used anymore.  Python performs "
"garbage collection via reference counting and a cyclic garbage collector "
"that is able to detect and break reference cycles.  The garbage collector "
"can be controlled using the :mod:`gc` module."
msgstr ""
"(ガベージコレクション) これ以降使われることのないメモリを解放する処理です。\n"
"Pythonは、参照カウントと、循環参照を検出し破壊する循環ガベージコレクタを使っ"
"てガベージコレクションを行います。\n"
"ガベージコレクタは :mod:`gc` モジュールを使って操作できます。"

#: ../../glossary.rst:490 ../../glossary.rst:491
msgid "generator"
msgstr "ジェネレータ"

#: ../../glossary.rst:493
msgid ""
"A function which returns a :term:`generator iterator`.  It looks like a "
"normal function except that it contains :keyword:`yield` expressions for "
"producing a series of values usable in a for-loop or that can be retrieved "
"one at a time with the :func:`next` function."
msgstr ""
"(ジェネレータ)\n"
":term:`generator iterator` を返す関数です。\n"
"通常の関数に似ていますが、 :keyword:`yield` 式を持つ点で異なります。\n"
":keyword:`yield` 式は、 for ループで使用できたり、:func:`next` 関数で値を 1 "
"つずつ取り出したりできる、値の並びを生成するのに使用されます。"

#: ../../glossary.rst:498
msgid ""
"Usually refers to a generator function, but may refer to a *generator "
"iterator* in some contexts.  In cases where the intended meaning isn't "
"clear, using the full terms avoids ambiguity."
msgstr ""
"通常はジェネレータ関数を指しますが、文脈によっては *ジェネレータイテレータ* "
"を指す場合があります。\n"
"意図された意味が明らかでない場合、 明瞭化のために完全な単語を使用します。"

#: ../../glossary.rst:501
msgid "generator iterator"
msgstr "generator iterator"

#: ../../glossary.rst:503
msgid "An object created by a :term:`generator` function."
msgstr ""
"(ジェネレータイテレータ)\n"
":term:`generator` 関数で生成されるオブジェクトです。"

#: ../../glossary.rst:505
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"location execution state (including local variables and pending try-"
"statements).  When the *generator iterator* resumes, it picks up where it "
"left off (in contrast to functions which start fresh on every invocation)."
msgstr ""
":keyword:`yield` のたびに局所実行状態 (局所変数や未処理の try 文などを含む) "
"を記憶して、処理は一時的に中断されます。\n"
"*ジェネレータイテレータ* が再開されると、中断した位置を取得します (通常の関数"
"が実行のたびに新しい状態から開始するのと対照的です)。"

#: ../../glossary.rst:511 ../../glossary.rst:512
msgid "generator expression"
msgstr "generator expression"

#: ../../glossary.rst:514
msgid ""
"An :term:`expression` that returns an :term:`iterator`.  It looks like a "
"normal expression followed by a :keyword:`!for` clause defining a loop "
"variable, range, and an optional :keyword:`!if` clause.  The combined "
"expression generates values for an enclosing function::"
msgstr ""

#: ../../glossary.rst:521
msgid "generic function"
msgstr "generic function"

#: ../../glossary.rst:523
msgid ""
"A function composed of multiple functions implementing the same operation "
"for different types. Which implementation should be used during a call is "
"determined by the dispatch algorithm."
msgstr ""
"(ジェネリック関数) 異なる型に対し同じ操作をする関数群から構成される関数です。"
"呼び出し時にどの実装を用いるかはディスパッチアルゴリズムにより決定されます。"

#: ../../glossary.rst:527
msgid ""
"See also the :term:`single dispatch` glossary entry, the :func:`functools."
"singledispatch` decorator, and :pep:`443`."
msgstr ""
":term:`single dispatch`、:func:`functools.singledispatch` デコレータ、:pep:"
"`443` を参照してください。"

#: ../../glossary.rst:529
msgid "generic type"
msgstr ""

#: ../../glossary.rst:531
msgid ""
"A :term:`type` that can be parameterized; typically a :ref:`container "
"class<sequence-types>` such as :class:`list` or :class:`dict`. Used for :"
"term:`type hints <type hint>` and :term:`annotations <annotation>`."
msgstr ""

#: ../../glossary.rst:536
msgid ""
"For more details, see :ref:`generic alias types<types-genericalias>`, :pep:"
"`483`, :pep:`484`, :pep:`585`, and the :mod:`typing` module."
msgstr ""

#: ../../glossary.rst:538
msgid "GIL"
msgstr "GIL"

#: ../../glossary.rst:540
msgid "See :term:`global interpreter lock`."
msgstr ":term:`global interpreter lock` を参照してください。"

#: ../../glossary.rst:541
msgid "global interpreter lock"
msgstr "global interpreter lock"

#: ../../glossary.rst:543
msgid ""
"The mechanism used by the :term:`CPython` interpreter to assure that only "
"one thread executes Python :term:`bytecode` at a time. This simplifies the "
"CPython implementation by making the object model (including critical built-"
"in types such as :class:`dict`) implicitly safe against concurrent access.  "
"Locking the entire interpreter makes it easier for the interpreter to be "
"multi-threaded, at the expense of much of the parallelism afforded by multi-"
"processor machines."
msgstr ""
"(グローバルインタプリタロック) :term:`CPython` インタプリタが利用している、一"
"度に Python の :term:`バイトコード <bytecode>` を実行するスレッドは一つだけで"
"あることを保証する仕組みです。これにより (:class:`dict` などの重要な組み込み"
"型を含む) オブジェクトモデルが同時アクセスに対して暗黙的に安全になるので、 "
"CPython の実装がシンプルになります。インタプリタ全体をロックすることで、マル"
"チプロセッサマシンが生じる並列化のコストと引き換えに、インタプリタを簡単にマ"
"ルチスレッド化できるようになります。"

#: ../../glossary.rst:552
msgid ""
"However, some extension modules, either standard or third-party, are "
"designed so as to release the GIL when doing computationally intensive tasks "
"such as compression or hashing.  Also, the GIL is always released when doing "
"I/O."
msgstr ""
"ただし、標準あるいは外部のいくつかの拡張モジュールは、圧縮やハッシュ計算など"
"の計算の重い処理をするときに GIL を解除するように設計されています。また、I/O "
"処理をする場合 GIL は常に解除されます。"

#: ../../glossary.rst:557
msgid ""
"As of Python 3.13, the GIL can be disabled using the :option:`--disable-gil` "
"build configuration. After building Python with this option, code must be "
"run with :option:`-X gil 0 <-X>` or after setting the :envvar:`PYTHON_GIL=0 "
"<PYTHON_GIL>` environment variable. This feature enables improved "
"performance for multi-threaded applications and makes it easier to use multi-"
"core CPUs efficiently. For more details, see :pep:`703`."
msgstr ""

#: ../../glossary.rst:563
msgid "hash-based pyc"
msgstr "hash-based pyc"

#: ../../glossary.rst:565
msgid ""
"A bytecode cache file that uses the hash rather than the last-modified time "
"of the corresponding source file to determine its validity. See :ref:`pyc-"
"invalidation`."
msgstr ""
"(ハッシュベース pyc ファイル) 正当性を判別するために、対応するソースファイル"
"の最終更新時刻ではなくハッシュ値を使用するバイトコードのキャッシュファイルで"
"す。:ref:`pyc-invalidation` を参照してください。"

#: ../../glossary.rst:568
msgid "hashable"
msgstr "hashable"

#: ../../glossary.rst:570
msgid ""
"An object is *hashable* if it has a hash value which never changes during "
"its lifetime (it needs a :meth:`~object.__hash__` method), and can be "
"compared to other objects (it needs an :meth:`~object.__eq__` method). "
"Hashable objects which compare equal must have the same hash value."
msgstr ""

#: ../../glossary.rst:576
msgid ""
"Hashability makes an object usable as a dictionary key and a set member, "
"because these data structures use the hash value internally."
msgstr ""
"ハッシュ可能なオブジェクトは辞書のキーや集合のメンバーとして使えます。辞書や"
"集合のデータ構造は内部でハッシュ値を使っているからです。"

#: ../../glossary.rst:579
msgid ""
"Most of Python's immutable built-in objects are hashable; mutable containers "
"(such as lists or dictionaries) are not; immutable containers (such as "
"tuples and frozensets) are only hashable if their elements are hashable.  "
"Objects which are instances of user-defined classes are hashable by "
"default.  They all compare unequal (except with themselves), and their hash "
"value is derived from their :func:`id`."
msgstr ""
"Python のイミュータブルな組み込みオブジェクトは、ほとんどがハッシュ可能です。"
"(リストや辞書のような) ミュータブルなコンテナはハッシュ不可能です。(タプルや "
"frozenset のような) イミュータブルなコンテナは、要素がハッシュ可能であるとき"
"のみハッシュ可能です。\n"
"ユーザー定義のクラスのインスタンスであるようなオブジェクトはデフォルトでハッ"
"シュ可能です。\n"
"それらは全て (自身を除いて) 比較結果は非等価であり、ハッシュ値は :func:`id` "
"より得られます。"

#: ../../glossary.rst:586
msgid "IDLE"
msgstr "IDLE"

#: ../../glossary.rst:588
msgid ""
"An Integrated Development and Learning Environment for Python. :ref:`idle` "
"is a basic editor and interpreter environment which ships with the standard "
"distribution of Python."
msgstr ""
"Python の統合開発環境 (Integrated DeveLopment Environment)及び学習環境 "
"(Learning Environment) です。:ref:`idle` は Python の標準的な配布に同梱されて"
"いる基本的な機能のエディタとインタプリタ環境です。"

#: ../../glossary.rst:591
msgid "immortal"
msgstr "永続オブジェクト (immortal)"

#: ../../glossary.rst:593
msgid ""
"If an object is immortal, its reference count is never modified, and "
"therefore it is never deallocated."
msgstr ""
"永続オブジェクトの場合、参照カウントが変更されることはなく、そのため割り当て"
"が解除されることもありません。"

#: ../../glossary.rst:596
msgid ""
"Built-in strings and singletons are immortal objects. For example, :const:"
"`True` and :const:`None` singletons are immmortal."
msgstr ""
"組み込みの文字列とシングルトンは、永続オブジェクトです。例えば、 :const:"
"`True` や :const:`None` シングルトンは永続です。"

#: ../../glossary.rst:599
msgid ""
"See `PEP 683 – Immortal Objects, Using a Fixed Refcount <https://peps.python."
"org/pep-0683/>`_ for more information."
msgstr ""
"詳細は `PEP 683 – Immortal Objects, Using a Fixed Refcount <https://peps."
"python.org/pep-0683/>`_ を参照してください。"

#: ../../glossary.rst:601
msgid "immutable"
msgstr "immutable"

#: ../../glossary.rst:603
msgid ""
"An object with a fixed value.  Immutable objects include numbers, strings "
"and tuples.  Such an object cannot be altered.  A new object has to be "
"created if a different value has to be stored.  They play an important role "
"in places where a constant hash value is needed, for example as a key in a "
"dictionary."
msgstr ""
"(イミュータブル) 固定の値を持ったオブジェクトです。イミュータブルなオブジェク"
"トには、数値、文字列、およびタプルなどがあります。これらのオブジェクトは値を"
"変えられません。別の値を記憶させる際には、新たなオブジェクトを作成しなければ"
"なりません。イミュータブルなオブジェクトは、固定のハッシュ値が必要となる状況"
"で重要な役割を果たします。辞書のキーがその例です。"

#: ../../glossary.rst:608
msgid "import path"
msgstr "import path"

#: ../../glossary.rst:610
msgid ""
"A list of locations (or :term:`path entries <path entry>`) that are searched "
"by the :term:`path based finder` for modules to import. During import, this "
"list of locations usually comes from :data:`sys.path`, but for subpackages "
"it may also come from the parent package's ``__path__`` attribute."
msgstr ""
":term:`path based finder` が import するモジュールを検索する場所 (または :"
"term:`path entry`) のリスト。 import 中、このリストは通常 :data:`sys.path` か"
"ら来ますが、サブパッケージの場合は親パッケージの ``__path__`` 属性からも来ま"
"す。"

#: ../../glossary.rst:615
msgid "importing"
msgstr "importing"

#: ../../glossary.rst:617
msgid ""
"The process by which Python code in one module is made available to Python "
"code in another module."
msgstr ""
"あるモジュールの Python コードが別のモジュールの Python コードで使えるように"
"する処理です。"

#: ../../glossary.rst:619
msgid "importer"
msgstr "importer"

#: ../../glossary.rst:621
msgid ""
"An object that both finds and loads a module; both a :term:`finder` and :"
"term:`loader` object."
msgstr ""
"モジュールを探してロードするオブジェクト。 :term:`finder` と :term:`loader` "
"のどちらでもあるオブジェクト。"

#: ../../glossary.rst:623
msgid "interactive"
msgstr "interactive"

#: ../../glossary.rst:625
msgid ""
"Python has an interactive interpreter which means you can enter statements "
"and expressions at the interpreter prompt, immediately execute them and see "
"their results.  Just launch ``python`` with no arguments (possibly by "
"selecting it from your computer's main menu). It is a very powerful way to "
"test out new ideas or inspect modules and packages (remember ``help(x)``). "
"For more on interactive mode, see :ref:`tut-interac`."
msgstr ""

#: ../../glossary.rst:632
msgid "interpreted"
msgstr "interpreted"

#: ../../glossary.rst:634
msgid ""
"Python is an interpreted language, as opposed to a compiled one, though the "
"distinction can be blurry because of the presence of the bytecode compiler.  "
"This means that source files can be run directly without explicitly creating "
"an executable which is then run. Interpreted languages typically have a "
"shorter development/debug cycle than compiled ones, though their programs "
"generally also run more slowly.  See also :term:`interactive`."
msgstr ""
"Python はインタプリタ形式の言語であり、コンパイラ言語の対極に位置します。 (バ"
"イトコードコンパイラがあるために、この区別は曖昧ですが。) ここでのインタプリ"
"タ言語とは、ソースコードのファイルを、まず実行可能形式にしてから実行させると"
"いった操作なしに、直接実行できることを意味します。インタプリタ形式の言語は通"
"常、コンパイラ形式の言語よりも開発／デバッグのサイクルは短いものの、プログラ"
"ムの実行は一般に遅いです。 :term:`対話的 <interactive>` も参照してください。"

#: ../../glossary.rst:641
msgid "interpreter shutdown"
msgstr "interpreter shutdown"

#: ../../glossary.rst:643
msgid ""
"When asked to shut down, the Python interpreter enters a special phase where "
"it gradually releases all allocated resources, such as modules and various "
"critical internal structures.  It also makes several calls to the :term:"
"`garbage collector <garbage collection>`. This can trigger the execution of "
"code in user-defined destructors or weakref callbacks. Code executed during "
"the shutdown phase can encounter various exceptions as the resources it "
"relies on may not function anymore (common examples are library modules or "
"the warnings machinery)."
msgstr ""
"Python インタープリターはシャットダウンを要請された時に、モジュールやすべての"
"クリティカルな内部構造をなどの、すべての確保したリソースを段階的に開放する、"
"特別なフェーズに入ります。\n"
"このフェーズは :term:`ガベージコレクタ <garbage collection>` を複数回呼び出し"
"ます。\n"
"これによりユーザー定義のデストラクターや weakref コールバックが呼び出されるこ"
"とがあります。\n"
"シャットダウンフェーズ中に実行されるコードは、それが依存するリソースがすでに"
"機能しない(よくある例はライブラリーモジュールや warning 機構です) ために様々"
"な例外に直面します。"

#: ../../glossary.rst:652
msgid ""
"The main reason for interpreter shutdown is that the ``__main__`` module or "
"the script being run has finished executing."
msgstr ""
"インタープリタがシャットダウンする主な理由は ``__main__`` モジュールや実行さ"
"れていたスクリプトの実行が終了したことです。"

#: ../../glossary.rst:654
msgid "iterable"
msgstr "iterable"

#: ../../glossary.rst:656
msgid ""
"An object capable of returning its members one at a time. Examples of "
"iterables include all sequence types (such as :class:`list`, :class:`str`, "
"and :class:`tuple`) and some non-sequence types like :class:`dict`, :term:"
"`file objects <file object>`, and objects of any classes you define with an :"
"meth:`~iterator.__iter__` method or with a :meth:`~object.__getitem__` "
"method that implements :term:`sequence` semantics."
msgstr ""

#: ../../glossary.rst:664
msgid ""
"Iterables can be used in a :keyword:`for` loop and in many other places "
"where a sequence is needed (:func:`zip`, :func:`map`, ...).  When an "
"iterable object is passed as an argument to the built-in function :func:"
"`iter`, it returns an iterator for the object.  This iterator is good for "
"one pass over the set of values.  When using iterables, it is usually not "
"necessary to call :func:`iter` or deal with iterator objects yourself.  The :"
"keyword:`for` statement does that automatically for you, creating a "
"temporary unnamed variable to hold the iterator for the duration of the "
"loop.  See also :term:`iterator`, :term:`sequence`, and :term:`generator`."
msgstr ""

#: ../../glossary.rst:674
msgid "iterator"
msgstr "iterator"

#: ../../glossary.rst:676
msgid ""
"An object representing a stream of data.  Repeated calls to the iterator's :"
"meth:`~iterator.__next__` method (or passing it to the built-in function :"
"func:`next`) return successive items in the stream.  When no more data are "
"available a :exc:`StopIteration` exception is raised instead.  At this "
"point, the iterator object is exhausted and any further calls to its :meth:`!"
"__next__` method just raise :exc:`StopIteration` again.  Iterators are "
"required to have an :meth:`~iterator.__iter__` method that returns the "
"iterator object itself so every iterator is also iterable and may be used in "
"most places where other iterables are accepted.  One notable exception is "
"code which attempts multiple iteration passes.  A container object (such as "
"a :class:`list`) produces a fresh new iterator each time you pass it to the :"
"func:`iter` function or use it in a :keyword:`for` loop.  Attempting this "
"with an iterator will just return the same exhausted iterator object used in "
"the previous iteration pass, making it appear like an empty container."
msgstr ""
"データの流れを表現するオブジェクトです。イテレータの :meth:`~iterator."
"__next__` メソッドを繰り返し呼び出す (または組み込み関数 :func:`next` に渡"
"す) と、流れの中の要素を一つずつ返します。データがなくなると、代わりに :exc:"
"`StopIteration` 例外を送出します。その時点で、イテレータオブジェクトは尽きて"
"おり、それ以降は :meth:`!__next__` を何度呼んでも :exc:`StopIteration` を送出"
"します。イテレータは、そのイテレータオブジェクト自体を返す :meth:`~iterator."
"__iter__` メソッドを実装しなければならないので、イテレータは他の iterable を"
"受理するほとんどの場所で利用できます。はっきりとした例外は複数の反復を行うよ"
"うなコードです。 (:class:`list` のような) コンテナオブジェクトは、自身を :"
"func:`iter` 関数にオブジェクトに渡したり :keyword:`for` ループ内で使うたび"
"に、新たな未使用のイテレータを生成します。これをイテレータで行おうとすると、"
"前回のイテレーションで使用済みの同じイテレータオブジェクトを単純に返すため、"
"空のコンテナのようになってしまします。"

#: ../../glossary.rst:691
msgid "More information can be found in :ref:`typeiter`."
msgstr "詳細な情報は :ref:`typeiter` にあります。"

#: ../../glossary.rst:695
msgid ""
"CPython does not consistently apply the requirement that an iterator define :"
"meth:`~iterator.__iter__`. And also please note that the free-threading "
"CPython does not guarantee the thread-safety of iterator operations."
msgstr ""

#: ../../glossary.rst:700
msgid "key function"
msgstr "key function"

#: ../../glossary.rst:702
msgid ""
"A key function or collation function is a callable that returns a value used "
"for sorting or ordering.  For example, :func:`locale.strxfrm` is used to "
"produce a sort key that is aware of locale specific sort conventions."
msgstr ""
"(キー関数) キー関数、あるいは照合関数とは、ソートや順序比較のための値を返す呼"
"び出し可能オブジェクト(callable)です。例えば、 :func:`locale.strxfrm` をキー"
"関数に使えば、ロケール依存のソートの慣習にのっとったソートキーを返します。"

#: ../../glossary.rst:707
msgid ""
"A number of tools in Python accept key functions to control how elements are "
"ordered or grouped.  They include :func:`min`, :func:`max`, :func:`sorted`, :"
"meth:`list.sort`, :func:`heapq.merge`, :func:`heapq.nsmallest`, :func:`heapq."
"nlargest`, and :func:`itertools.groupby`."
msgstr ""
"Python の多くのツールはキー関数を受け取り要素の並び順やグループ化を管理しま"
"す。\n"
":func:`min`, :func:`max`, :func:`sorted`, :meth:`list.sort`, :func:`heapq."
"merge`, :func:`heapq.nsmallest`, :func:`heapq.nlargest`, :func:`itertools."
"groupby` 等があります。"

#: ../../glossary.rst:713
msgid ""
"There are several ways to create a key function.  For example. the :meth:"
"`str.lower` method can serve as a key function for case insensitive sorts.  "
"Alternatively, a key function can be built from a :keyword:`lambda` "
"expression such as ``lambda r: (r[0], r[2])``.  Also, :func:`operator."
"attrgetter`, :func:`operator.itemgetter`, and :func:`operator.methodcaller` "
"are three key function constructors.  See the :ref:`Sorting HOW TO "
"<sortinghowto>` for examples of how to create and use key functions."
msgstr ""
"キー関数を作る方法はいくつかあります。\n"
"例えば :meth:`str.lower` メソッドを大文字小文字を区別しないソートを行うキー関"
"数として使うことが出来ます。\n"
"あるいは、``lambda r: (r[0], r[2])`` のような :keyword:`lambda` 式からキー関"
"数を作ることができます。\n"
"また、:func:`operator.attrgetter`, :func:`operator.itemgetter`, :func:"
"`operator.methodcaller` の  3 つのキー関数コンストラクタがあります。\n"
"キー関数の作り方と使い方の例は :ref:`Sorting HOW TO <sortinghowto>` を参照し"
"てください。"

#: ../../glossary.rst:720
msgid "keyword argument"
msgstr "keyword argument"

#: ../../glossary.rst:722 ../../glossary.rst:1021
msgid "See :term:`argument`."
msgstr ":term:`実引数 <argument>` を参照してください。"

#: ../../glossary.rst:723
msgid "lambda"
msgstr "lambda"

#: ../../glossary.rst:725
msgid ""
"An anonymous inline function consisting of a single :term:`expression` which "
"is evaluated when the function is called.  The syntax to create a lambda "
"function is ``lambda [parameters]: expression``"
msgstr ""
"(ラムダ) 無名のインライン関数で、関数が呼び出されたときに評価される 1 つの :"
"term:`式 <expression>` を含みます。ラムダ関数を作る構文は ``lambda "
"[parameters]: expression`` です。"

#: ../../glossary.rst:728
msgid "LBYL"
msgstr "LBYL"

#: ../../glossary.rst:730
msgid ""
"Look before you leap.  This coding style explicitly tests for pre-conditions "
"before making calls or lookups.  This style contrasts with the :term:`EAFP` "
"approach and is characterized by the presence of many :keyword:`if` "
"statements."
msgstr ""
"「ころばぬ先の杖 (look before you leap)」 の略です。このコーディングスタイル"
"では、呼び出しや検索を行う前に、明示的に前提条件 (pre-condition) 判定を行いま"
"す。 :term:`EAFP` アプローチと対照的で、 :keyword:`if` 文がたくさん使われるの"
"が特徴的です。"

#: ../../glossary.rst:735
msgid ""
"In a multi-threaded environment, the LBYL approach can risk introducing a "
"race condition between \"the looking\" and \"the leaping\".  For example, "
"the code, ``if key in mapping: return mapping[key]`` can fail if another "
"thread removes *key* from *mapping* after the test, but before the lookup. "
"This issue can be solved with locks or by using the EAFP approach."
msgstr ""
"マルチスレッド化された環境では、LBYL アプローチは \"見る\" 過程と \"飛ぶ\" 過"
"程の競合状態を引き起こすリスクがあります。例えば、``if key in mapping: "
"return mapping[key]`` というコードは、判定の後、別のスレッドが探索の前に "
"*mapping* から *key* を取り除くと失敗します。この問題は、ロックするか EAFP ア"
"プローチを使うことで解決できます。"

#: ../../glossary.rst:740
msgid "list"
msgstr "list"

#: ../../glossary.rst:742
msgid ""
"A built-in Python :term:`sequence`.  Despite its name it is more akin to an "
"array in other languages than to a linked list since access to elements is "
"*O*\\ (1)."
msgstr ""

#: ../../glossary.rst:745
msgid "list comprehension"
msgstr "list comprehension"

#: ../../glossary.rst:747
msgid ""
"A compact way to process all or part of the elements in a sequence and "
"return a list with the results.  ``result = ['{:#04x}'.format(x) for x in "
"range(256) if x % 2 == 0]`` generates a list of strings containing even hex "
"numbers (0x..) in the range from 0 to 255. The :keyword:`if` clause is "
"optional.  If omitted, all elements in ``range(256)`` are processed."
msgstr ""
"(リスト内包表記) シーケンス中の全てあるいは一部の要素を処理して、その結果から"
"なるリストを返す、コンパクトな方法です。 ``result = ['{:#04x}'.format(x) for "
"x in range(256) if x % 2 == 0]`` とすると、 0 から 255 までの偶数を 16進数表"
"記 (0x..) した文字列からなるリストを生成します。 :keyword:`if` 節はオプション"
"です。 :keyword:`if` 節がない場合、 ``range(256)`` の全ての要素が処理されま"
"す。"

#: ../../glossary.rst:753
msgid "loader"
msgstr "loader"

#: ../../glossary.rst:755
msgid ""
"An object that loads a module. It must define a method named :meth:"
"`load_module`. A loader is typically returned by a :term:`finder`. See :pep:"
"`302` for details and :class:`importlib.abc.Loader` for an :term:`abstract "
"base class`."
msgstr ""
"モジュールをロードするオブジェクト。 :meth:`load_module` という名前のメソッド"
"を定義していなければなりません。ローダーは一般的に :term:`finder` から返され"
"ます。詳細は :pep:`302` を、 :term:`abstract base class` については :class:"
"`importlib.abc.Loader` を参照してください。"

#: ../../glossary.rst:759
msgid "locale encoding"
msgstr "ロケールエンコーディング"

#: ../../glossary.rst:761
msgid ""
"On Unix, it is the encoding of the LC_CTYPE locale. It can be set with :func:"
"`locale.setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>`."
msgstr ""

#: ../../glossary.rst:764
msgid "On Windows, it is the ANSI code page (ex: ``\"cp1252\"``)."
msgstr ""

#: ../../glossary.rst:766
msgid ""
"On Android and VxWorks, Python uses ``\"utf-8\"`` as the locale encoding."
msgstr ""

#: ../../glossary.rst:768
msgid ":func:`locale.getencoding` can be used to get the locale encoding."
msgstr ""

#: ../../glossary.rst:770
msgid "See also the :term:`filesystem encoding and error handler`."
msgstr ""

#: ../../glossary.rst:771
msgid "magic method"
msgstr "magic method"

#: ../../glossary.rst:775
msgid "An informal synonym for :term:`special method`."
msgstr ":term:`special method` のくだけた同義語です。"

#: ../../glossary.rst:776
msgid "mapping"
msgstr "mapping"

#: ../../glossary.rst:778
msgid ""
"A container object that supports arbitrary key lookups and implements the "
"methods specified in the :class:`collections.abc.Mapping` or :class:"
"`collections.abc.MutableMapping` :ref:`abstract base classes <collections-"
"abstract-base-classes>`.  Examples include :class:`dict`, :class:"
"`collections.defaultdict`, :class:`collections.OrderedDict` and :class:"
"`collections.Counter`."
msgstr ""
"(マッピング) 任意のキー探索をサポートしていて、 :class:`collections.abc."
"Mapping` か :class:`collections.abc.MutableMapping` の :ref:`抽象基底クラス "
"<collections-abstract-base-classes>` で指定されたメソッドを実装しているコンテ"
"ナオブジェクトです。例えば、 :class:`dict`, :class:`collections."
"defaultdict`, :class:`collections.OrderedDict`, :class:`collections.Counter` "
"などです。"

#: ../../glossary.rst:784
msgid "meta path finder"
msgstr "meta path finder"

#: ../../glossary.rst:786
msgid ""
"A :term:`finder` returned by a search of :data:`sys.meta_path`.  Meta path "
"finders are related to, but different from :term:`path entry finders <path "
"entry finder>`."
msgstr ""
":data:`sys.meta_path` を検索して得られた :term:`finder`.\n"
"meta path finder は :term:`path entry finder` と関係はありますが、別物です。"

#: ../../glossary.rst:790
msgid ""
"See :class:`importlib.abc.MetaPathFinder` for the methods that meta path "
"finders implement."
msgstr ""
"meta path finder が実装するメソッドについては :class:`importlib.abc."
"MetaPathFinder` を参照してください。"

#: ../../glossary.rst:792
msgid "metaclass"
msgstr "metaclass"

#: ../../glossary.rst:794
msgid ""
"The class of a class.  Class definitions create a class name, a class "
"dictionary, and a list of base classes.  The metaclass is responsible for "
"taking those three arguments and creating the class.  Most object oriented "
"programming languages provide a default implementation.  What makes Python "
"special is that it is possible to create custom metaclasses.  Most users "
"never need this tool, but when the need arises, metaclasses can provide "
"powerful, elegant solutions.  They have been used for logging attribute "
"access, adding thread-safety, tracking object creation, implementing "
"singletons, and many other tasks."
msgstr ""
"(メタクラス) クラスのクラスです。クラス定義は、クラス名、クラスの辞書と、基底"
"クラスのリストを作ります。メタクラスは、それら 3 つを引数として受け取り、クラ"
"スを作る責任を負います。ほとんどのオブジェクト指向言語は(訳注:メタクラスの)デ"
"フォルトの実装を提供しています。Python が特別なのはカスタムのメタクラスを作成"
"できる点です。ほとんどのユーザーに取って、メタクラスは全く必要のないもので"
"す。しかし、一部の場面では、メタクラスは強力でエレガントな方法を提供します。"
"たとえば属性アクセスのログを取ったり、スレッドセーフ性を追加したり、オブジェ"
"クトの生成を追跡したり、シングルトンを実装するなど、多くの場面で利用されま"
"す。"

#: ../../glossary.rst:804
msgid "More information can be found in :ref:`metaclasses`."
msgstr "詳細は :ref:`metaclasses` を参照してください。"

#: ../../glossary.rst:773 ../../glossary.rst:805 ../../glossary.rst:1170
msgid "method"
msgstr "メソッド"

#: ../../glossary.rst:807
msgid ""
"A function which is defined inside a class body.  If called as an attribute "
"of an instance of that class, the method will get the instance object as its "
"first :term:`argument` (which is usually called ``self``). See :term:"
"`function` and :term:`nested scope`."
msgstr ""
"(メソッド) クラス本体の中で定義された関数。そのクラスのインスタンスの属性とし"
"て呼び出された場合、メソッドはインスタンスオブジェクトを第一 :term:`引数 "
"<argument>` として受け取ります (この第一引数は通常 ``self`` と呼ばれます)。 :"
"term:`関数 <function>` と :term:`ネストされたスコープ <nested scope>` も参照"
"してください。"

#: ../../glossary.rst:811
msgid "method resolution order"
msgstr "method resolution order"

#: ../../glossary.rst:813
msgid ""
"Method Resolution Order is the order in which base classes are searched for "
"a member during lookup. See :ref:`python_2.3_mro` for details of the "
"algorithm used by the Python interpreter since the 2.3 release."
msgstr ""

#: ../../glossary.rst:816
msgid "module"
msgstr "module"

#: ../../glossary.rst:818
msgid ""
"An object that serves as an organizational unit of Python code.  Modules "
"have a namespace containing arbitrary Python objects.  Modules are loaded "
"into Python by the process of :term:`importing`."
msgstr ""
"(モジュール) Python コードの組織単位としてはたらくオブジェクトです。モジュー"
"ルは任意の Python オブジェクトを含む名前空間を持ちます。モジュールは :term:"
"`importing` の処理によって Python に読み込まれます。"

#: ../../glossary.rst:822
msgid "See also :term:`package`."
msgstr ":term:`パッケージ <package>` を参照してください。"

#: ../../glossary.rst:823
msgid "module spec"
msgstr "module spec"

#: ../../glossary.rst:825
msgid ""
"A namespace containing the import-related information used to load a module. "
"An instance of :class:`importlib.machinery.ModuleSpec`."
msgstr ""
"モジュールをロードするのに使われるインポート関連の情報を含む名前空間です。\n"
":class:`importlib.machinery.ModuleSpec` のインスタンスです。"

#: ../../glossary.rst:827
msgid "MRO"
msgstr "MRO"

#: ../../glossary.rst:829
msgid "See :term:`method resolution order`."
msgstr ":term:`method resolution order` を参照してください。"

#: ../../glossary.rst:830
msgid "mutable"
msgstr "mutable"

#: ../../glossary.rst:832
msgid ""
"Mutable objects can change their value but keep their :func:`id`.  See also :"
"term:`immutable`."
msgstr ""
"(ミュータブル) ミュータブルなオブジェクトは、 :func:`id` を変えることなく値を"
"変更できます。 :term:`イミュータブル <immutable>`) も参照してください。"

#: ../../glossary.rst:834
msgid "named tuple"
msgstr "named tuple"

#: ../../glossary.rst:836
msgid ""
"The term \"named tuple\" applies to any type or class that inherits from "
"tuple and whose indexable elements are also accessible using named "
"attributes.  The type or class may have other features as well."
msgstr ""
"\"名前付きタプル\" という用語は、タプルを継承していて、インデックスが付く要素"
"に対し属性を使ってのアクセスもできる任意の型やクラスに応用されています。\n"
"その型やクラスは他の機能も持っていることもあります。"

#: ../../glossary.rst:840
msgid ""
"Several built-in types are named tuples, including the values returned by :"
"func:`time.localtime` and :func:`os.stat`.  Another example is :data:`sys."
"float_info`::"
msgstr ""
":func:`time.localtime` や :func:`os.stat` の返り値を含むいくつかの組み込み型"
"は名前付きタプルです。\n"
"他の例は :data:`sys.float_info` です::"

#: ../../glossary.rst:851
msgid ""
"Some named tuples are built-in types (such as the above examples). "
"Alternatively, a named tuple can be created from a regular class definition "
"that inherits from :class:`tuple` and that defines named fields.  Such a "
"class can be written by hand, or it can be created by inheriting :class:"
"`typing.NamedTuple`, or with the factory function :func:`collections."
"namedtuple`.  The latter techniques also add some extra methods that may not "
"be found in hand-written or built-in named tuples."
msgstr ""

#: ../../glossary.rst:859
msgid "namespace"
msgstr "namespace"

#: ../../glossary.rst:861
msgid ""
"The place where a variable is stored.  Namespaces are implemented as "
"dictionaries.  There are the local, global and built-in namespaces as well "
"as nested namespaces in objects (in methods).  Namespaces support modularity "
"by preventing naming conflicts.  For instance, the functions :func:`builtins."
"open <.open>` and :func:`os.open` are distinguished by their namespaces.  "
"Namespaces also aid readability and maintainability by making it clear which "
"module implements a function.  For instance, writing :func:`random.seed` or :"
"func:`itertools.islice` makes it clear that those functions are implemented "
"by the :mod:`random` and :mod:`itertools` modules, respectively."
msgstr ""
"(名前空間) 変数が格納される場所です。名前空間は辞書として実装されます。名前空"
"間にはオブジェクトの (メソッドの) 入れ子になったものだけでなく、局所的なも"
"の、大域的なもの、そして組み込みのものがあります。名前空間は名前の衝突を防ぐ"
"ことによってモジュール性をサポートする。例えば関数 :func:`builtins.open <."
"open>` と :func:`os.open` は名前空間で区別されています。また、どのモジュール"
"が関数を実装しているか明示することによって名前空間は可読性と保守性を支援しま"
"す。例えば、:func:`random.seed` や :func:`itertools.islice` と書くと、それぞ"
"れモジュール :mod:`random` や :mod:`itertools` で実装されていることが明らかで"
"す。"

#: ../../glossary.rst:871
msgid "namespace package"
msgstr "namespace package"

#: ../../glossary.rst:873
msgid ""
"A :pep:`420` :term:`package` which serves only as a container for "
"subpackages.  Namespace packages may have no physical representation, and "
"specifically are not like a :term:`regular package` because they have no "
"``__init__.py`` file."
msgstr ""
"(名前空間パッケージ) サブパッケージのコンテナとしてのみ提供される :pep:`420` "
"で定義された :term:`package`  です。名前空間パッケージは物理的な表現を持たな"
"いことができ、 ``__init__.py`` ファイルを持たないため、 :term:`regular "
"package` とは異なります。"

#: ../../glossary.rst:878
msgid "See also :term:`module`."
msgstr ":term:`module` を参照してください。"

#: ../../glossary.rst:879
msgid "nested scope"
msgstr "nested scope"

#: ../../glossary.rst:881
msgid ""
"The ability to refer to a variable in an enclosing definition.  For "
"instance, a function defined inside another function can refer to variables "
"in the outer function.  Note that nested scopes by default work only for "
"reference and not for assignment.  Local variables both read and write in "
"the innermost scope.  Likewise, global variables read and write to the "
"global namespace.  The :keyword:`nonlocal` allows writing to outer scopes."
msgstr ""
"(ネストされたスコープ) 外側で定義されている変数を参照する機能です。例えば、あ"
"る関数が別の関数の中で定義されている場合、内側の関数は外側の関数中の変数を参"
"照できます。ネストされたスコープはデフォルトでは変数の参照だけができ、変数の"
"代入はできないので注意してください。ローカル変数は、最も内側のスコープで変数"
"を読み書きします。同様に、グローバル変数を使うとグローバル名前空間の値を読み"
"書きします。 :keyword:`nonlocal` で外側の変数に書き込めます。"

#: ../../glossary.rst:888
msgid "new-style class"
msgstr "new-style class"

#: ../../glossary.rst:890
msgid ""
"Old name for the flavor of classes now used for all class objects.  In "
"earlier Python versions, only new-style classes could use Python's newer, "
"versatile features like :attr:`~object.__slots__`, descriptors, properties, :"
"meth:`~object.__getattribute__`, class methods, and static methods."
msgstr ""

#: ../../glossary.rst:895
msgid "object"
msgstr "object"

#: ../../glossary.rst:897
msgid ""
"Any data with state (attributes or value) and defined behavior (methods).  "
"Also the ultimate base class of any :term:`new-style class`."
msgstr ""
"(オブジェクト) 状態 (属性や値) と定義された振る舞い (メソッド) をもつ全ての"
"データ。もしくは、全ての :term:`新スタイルクラス <new-style class>` の究極の"
"基底クラスのこと。"

#: ../../glossary.rst:900
msgid "optimized scope"
msgstr ""

#: ../../glossary.rst:902
msgid ""
"A scope where target local variable names are reliably known to the compiler "
"when the code is compiled, allowing optimization of read and write access to "
"these names. The local namespaces for functions, generators, coroutines, "
"comprehensions, and generator expressions are optimized in this fashion. "
"Note: most interpreter optimizations are applied to all scopes, only those "
"relying on a known set of local and nonlocal variable names are restricted "
"to optimized scopes."
msgstr ""

#: ../../glossary.rst:909
msgid "package"
msgstr "package"

#: ../../glossary.rst:911
msgid ""
"A Python :term:`module` which can contain submodules or recursively, "
"subpackages.  Technically, a package is a Python module with a ``__path__`` "
"attribute."
msgstr ""
"(パッケージ) サブモジュールや再帰的にサブパッケージを含むことの出来る :term:"
"`module` のことです。専門的には、パッケージは ``__path__`` 属性を持つ Python "
"オブジェクトです。"

#: ../../glossary.rst:915
msgid "See also :term:`regular package` and :term:`namespace package`."
msgstr ""
":term:`regular package` と :term:`namespace package` を参照してください。"

#: ../../glossary.rst:916
msgid "parameter"
msgstr "parameter"

#: ../../glossary.rst:918
msgid ""
"A named entity in a :term:`function` (or method) definition that specifies "
"an :term:`argument` (or in some cases, arguments) that the function can "
"accept.  There are five kinds of parameter:"
msgstr ""
"(仮引数) 名前付の実体で :term:`関数<function>` (や :term:`メソッド"
"<method>` ) の定義において関数が受ける :term:`実引数<argument>` を指定しま"
"す。仮引数には5種類あります:"

#: ../../glossary.rst:922
msgid ""
":dfn:`positional-or-keyword`: specifies an argument that can be passed "
"either :term:`positionally <argument>` or as a :term:`keyword argument "
"<argument>`.  This is the default kind of parameter, for example *foo* and "
"*bar* in the following::"
msgstr ""
":dfn:`位置またはキーワード`: :term:`位置 <argument>` であるいは :term:`キー"
"ワード引数 <argument>` として渡すことができる引数を指定します。\n"
"これはたとえば以下の *foo* や *bar* のように、デフォルトの仮引数の種類です::"

#: ../../glossary.rst:931
msgid ""
":dfn:`positional-only`: specifies an argument that can be supplied only by "
"position. Positional-only parameters can be defined by including a ``/`` "
"character in the parameter list of the function definition after them, for "
"example *posonly1* and *posonly2* in the following::"
msgstr ""
"位置専用: 位置によってのみ与えられる引数を指定します。位置専用の引数は 関数定"
"義の引数のリストの中でそれらの後ろに ``/`` を含めることで定義できます。例えば"
"下記の   *posonly1* と *posonly2* は位置専用引数になります:: "

#: ../../glossary.rst:940
msgid ""
":dfn:`keyword-only`: specifies an argument that can be supplied only by "
"keyword.  Keyword-only parameters can be defined by including a single var-"
"positional parameter or bare ``*`` in the parameter list of the function "
"definition before them, for example *kw_only1* and *kw_only2* in the "
"following::"
msgstr ""
":dfn:`キーワード専用`: キーワードによってのみ与えられる引数を指定します。キー"
"ワード専用の引数を定義できる場所は、例えば以下の *kw_only1* や *kw_only2* の"
"ように、関数定義の仮引数リストに含めた可変長位置引数または裸の ``*`` の後で"
"す::"

#: ../../glossary.rst:948
msgid ""
":dfn:`var-positional`: specifies that an arbitrary sequence of positional "
"arguments can be provided (in addition to any positional arguments already "
"accepted by other parameters).  Such a parameter can be defined by "
"prepending the parameter name with ``*``, for example *args* in the "
"following::"
msgstr ""
":dfn:`可変長位置`: (他の仮引数で既に受けられた任意の位置引数に加えて) 任意の"
"個数の位置引数が与えられることを指定します。このような仮引数は、以下の "
"*args* のように仮引数名の前に ``*`` をつけることで定義できます::"

#: ../../glossary.rst:956
msgid ""
":dfn:`var-keyword`: specifies that arbitrarily many keyword arguments can be "
"provided (in addition to any keyword arguments already accepted by other "
"parameters).  Such a parameter can be defined by prepending the parameter "
"name with ``**``, for example *kwargs* in the example above."
msgstr ""
":dfn:`可変長キーワード`: (他の仮引数で既に受けられた任意のキーワード引数に加"
"えて) 任意の個数のキーワード引数が与えられることを指定します。このような仮引"
"数は、上の例の *kwargs* のように仮引数名の前に ``**`` をつけることで定義でき"
"ます。"

#: ../../glossary.rst:962
msgid ""
"Parameters can specify both optional and required arguments, as well as "
"default values for some optional arguments."
msgstr ""
"仮引数はオプションと必須の引数のどちらも指定でき、オプションの引数にはデフォ"
"ルト値も指定できます。"

#: ../../glossary.rst:965
msgid ""
"See also the :term:`argument` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"the :class:`inspect.Parameter` class, the :ref:`function` section, and :pep:"
"`362`."
msgstr ""
":term:`仮引数 <parameter>` 、FAQ の :ref:`実引数と仮引数の違いは何ですか? "
"<faq-argument-vs-parameter>` 、:class:`inspect.Parameter`  クラス、 :ref:"
"`function` セクション、:pep:`362` を参照してください。"

#: ../../glossary.rst:969
msgid "path entry"
msgstr "path entry"

#: ../../glossary.rst:971
msgid ""
"A single location on the :term:`import path` which the :term:`path based "
"finder` consults to find modules for importing."
msgstr ""
":term:`path based finder` が import するモジュールを探す :term:`import path` "
"上の1つの場所です。"

#: ../../glossary.rst:973
msgid "path entry finder"
msgstr "path entry finder"

#: ../../glossary.rst:975
msgid ""
"A :term:`finder` returned by a callable on :data:`sys.path_hooks` (i.e. a :"
"term:`path entry hook`) which knows how to locate modules given a :term:"
"`path entry`."
msgstr ""
":data:`sys.path_hooks` にある callable (つまり :term:`path entry hook`) が返"
"した :term:`finder` です。与えられた :term:`path entry` にあるモジュールを見"
"つける方法を知っています。"

#: ../../glossary.rst:979
msgid ""
"See :class:`importlib.abc.PathEntryFinder` for the methods that path entry "
"finders implement."
msgstr ""
"パスエントリーファインダが実装するメソッドについては :class:`importlib.abc."
"PathEntryFinder` を参照してください。"

#: ../../glossary.rst:981
msgid "path entry hook"
msgstr "path entry hook"

#: ../../glossary.rst:983
msgid ""
"A callable on the :data:`sys.path_hooks` list which returns a :term:`path "
"entry finder` if it knows how to find modules on a specific :term:`path "
"entry`."
msgstr ""

#: ../../glossary.rst:986
msgid "path based finder"
msgstr "path based finder"

#: ../../glossary.rst:988
msgid ""
"One of the default :term:`meta path finders <meta path finder>` which "
"searches an :term:`import path` for modules."
msgstr ""
"デフォルトの :term:`meta path finder` の1つは、モジュールの :term:`import "
"path` を検索します。"

#: ../../glossary.rst:990
msgid "path-like object"
msgstr "path-like object"

#: ../../glossary.rst:992
msgid ""
"An object representing a file system path. A path-like object is either a :"
"class:`str` or :class:`bytes` object representing a path, or an object "
"implementing the :class:`os.PathLike` protocol. An object that supports the :"
"class:`os.PathLike` protocol can be converted to a :class:`str` or :class:"
"`bytes` file system path by calling the :func:`os.fspath` function; :func:"
"`os.fsdecode` and :func:`os.fsencode` can be used to guarantee a :class:"
"`str` or :class:`bytes` result instead, respectively. Introduced by :pep:"
"`519`."
msgstr ""
"(path-like オブジェクト) ファイルシステムパスを表します。\n"
"path-like オブジェクトは、パスを表す :class:`str` オブジェクトや :class:"
"`bytes` オブジェクト、または :class:`os.PathLike` プロトコルを実装したオブ"
"ジェクトのどれかです。\n"
":class:`os.PathLike` プロトコルをサポートしているオブジェクトは :func:`os."
"fspath` を呼び出すことで :class:`str` または :class:`bytes` のファイルシステ"
"ムパスに変換できます。 :func:`os.fsdecode` と :func:`os.fsencode` はそれぞ"
"れ :class:`str` あるいは :class:`bytes` になるのを保証するのに使えます。\n"
":pep:`519` で導入されました。"

#: ../../glossary.rst:1000
msgid "PEP"
msgstr "PEP"

#: ../../glossary.rst:1002
msgid ""
"Python Enhancement Proposal. A PEP is a design document providing "
"information to the Python community, or describing a new feature for Python "
"or its processes or environment. PEPs should provide a concise technical "
"specification and a rationale for proposed features."
msgstr ""
"Python Enhancement Proposal。PEP は、Python コミュニティに対して情報を提供す"
"る、あるいは Python の新機能やその過程や環境について記述する設計文書です。\n"
"PEP は、機能についての簡潔な技術的仕様と提案する機能の論拠 (理論) を伝えるべ"
"きです。"

#: ../../glossary.rst:1008
msgid ""
"PEPs are intended to be the primary mechanisms for proposing major new "
"features, for collecting community input on an issue, and for documenting "
"the design decisions that have gone into Python. The PEP author is "
"responsible for building consensus within the community and documenting "
"dissenting opinions."
msgstr ""
"PEP は、新機能の提案にかかる、コミュニティによる問題提起の集積と Python にな"
"される設計決断の文書化のための最上位の機構となることを意図しています。PEP の"
"著者にはコミュニティ内の合意形成を行うこと、反対意見を文書化することの責務が"
"あります。"

#: ../../glossary.rst:1014
msgid "See :pep:`1`."
msgstr ":pep:`1` を参照してください。"

#: ../../glossary.rst:1015
msgid "portion"
msgstr "portion"

#: ../../glossary.rst:1017
msgid ""
"A set of files in a single directory (possibly stored in a zip file) that "
"contribute to a namespace package, as defined in :pep:`420`."
msgstr ""
":pep:`420` で定義されている、namespace package に属する、複数のファイルが "
"(zipファイルに格納されている場合もある) 1つのディレクトリに格納されたもの。"

#: ../../glossary.rst:1019
msgid "positional argument"
msgstr "位置引数 (positional argument)"

#: ../../glossary.rst:1022
msgid "provisional API"
msgstr "provisional API"

#: ../../glossary.rst:1024
msgid ""
"A provisional API is one which has been deliberately excluded from the "
"standard library's backwards compatibility guarantees.  While major changes "
"to such interfaces are not expected, as long as they are marked provisional, "
"backwards incompatible changes (up to and including removal of the "
"interface) may occur if deemed necessary by core developers.  Such changes "
"will not be made gratuitously -- they will occur only if serious fundamental "
"flaws are uncovered that were missed prior to the inclusion of the API."
msgstr ""
"(暫定 API) 標準ライブラリの後方互換性保証から計画的に除外されたものです。その"
"ようなインターフェースへの大きな変更は、暫定であるとされている間は期待されて"
"いませんが、コア開発者によって必要とみなされれば、後方非互換な変更 (インター"
"フェースの削除まで含まれる) が行われえます。このような変更はむやみに行われる"
"ものではありません -- これは API を組み込む前には見落とされていた重大な欠陥が"
"露呈したときにのみ行われます。"

#: ../../glossary.rst:1033
msgid ""
"Even for provisional APIs, backwards incompatible changes are seen as a "
"\"solution of last resort\" - every attempt will still be made to find a "
"backwards compatible resolution to any identified problems."
msgstr ""
"暫定 API についても、後方互換性のない変更は「最終手段」とみなされています。問"
"題点が判明した場合でも後方互換な解決策を探すべきです。"

#: ../../glossary.rst:1037
msgid ""
"This process allows the standard library to continue to evolve over time, "
"without locking in problematic design errors for extended periods of time.  "
"See :pep:`411` for more details."
msgstr ""
"このプロセスにより、標準ライブラリは問題となるデザインエラーに長い間閉じ込め"
"られることなく、時代を超えて進化を続けられます。詳細は :pep:`411` を参照して"
"ください。"

#: ../../glossary.rst:1040
msgid "provisional package"
msgstr "provisional package"

#: ../../glossary.rst:1042
msgid "See :term:`provisional API`."
msgstr ":term:`provisional API` を参照してください。"

#: ../../glossary.rst:1043
msgid "Python 3000"
msgstr "Python 3000"

#: ../../glossary.rst:1045
msgid ""
"Nickname for the Python 3.x release line (coined long ago when the release "
"of version 3 was something in the distant future.)  This is also abbreviated "
"\"Py3k\"."
msgstr ""
"Python 3.x リリースラインのニックネームです。(Python 3 が遠い将来の話だった頃"
"に作られた言葉です。) \"Py3k\" と略されることもあります。"

#: ../../glossary.rst:1048
msgid "Pythonic"
msgstr "Pythonic"

#: ../../glossary.rst:1050
msgid ""
"An idea or piece of code which closely follows the most common idioms of the "
"Python language, rather than implementing code using concepts common to "
"other languages.  For example, a common idiom in Python is to loop over all "
"elements of an iterable using a :keyword:`for` statement.  Many other "
"languages don't have this type of construct, so people unfamiliar with "
"Python sometimes use a numerical counter instead::"
msgstr ""
"他の言語で一般的な考え方で書かれたコードではなく、Python の特に一般的なイディ"
"オムに従った考え方やコード片。例えば、Python の一般的なイディオムでは :"
"keyword:`for` 文を使ってイテラブルのすべての要素に渡ってループします。他の多"
"くの言語にはこの仕組みはないので、Python に慣れていない人は代わりに数値のカウ"
"ンターを使うかもしれません::"

#: ../../glossary.rst:1060
msgid "As opposed to the cleaner, Pythonic method::"
msgstr "これに対し、きれいな Pythonic な方法は::"

#: ../../glossary.rst:1064
msgid "qualified name"
msgstr "qualified name"

#: ../../glossary.rst:1066
msgid ""
"A dotted name showing the \"path\" from a module's global scope to a class, "
"function or method defined in that module, as defined in :pep:`3155`.  For "
"top-level functions and classes, the qualified name is the same as the "
"object's name::"
msgstr ""
"(修飾名) モジュールのグローバルスコープから、そのモジュールで定義されたクラ"
"ス、関数、メソッドへの、 \"パス\" を表すドット名表記です。 :pep:`3155` で定義"
"されています。トップレベルの関数やクラスでは、修飾名はオブジェクトの名前と同"
"じです::"

#: ../../glossary.rst:1083
msgid ""
"When used to refer to modules, the *fully qualified name* means the entire "
"dotted path to the module, including any parent packages, e.g. ``email.mime."
"text``::"
msgstr ""
"モジュールへの参照で使われると、*完全修飾名 (fully qualified name)* はすべて"
"の親パッケージを含む全体のドット名表記、例えば ``email.mime.text`` を意味しま"
"す::"

#: ../../glossary.rst:1090
msgid "reference count"
msgstr "reference count"

#: ../../glossary.rst:1092
msgid ""
"The number of references to an object.  When the reference count of an "
"object drops to zero, it is deallocated.  Some objects are :term:`immortal` "
"and have reference counts that are never modified, and therefore the objects "
"are never deallocated.  Reference counting is generally not visible to "
"Python code, but it is a key element of the :term:`CPython` implementation.  "
"Programmers can call the :func:`sys.getrefcount` function to return the "
"reference count for a particular object."
msgstr ""

#: ../../glossary.rst:1100
msgid "regular package"
msgstr "regular package"

#: ../../glossary.rst:1102
msgid ""
"A traditional :term:`package`, such as a directory containing an ``__init__."
"py`` file."
msgstr ""
"伝統的な、 ``__init__.py`` ファイルを含むディレクトリとしての :term:"
"`package`。"

#: ../../glossary.rst:1105
msgid "See also :term:`namespace package`."
msgstr ":term:`namespace package` を参照してください。"

#: ../../glossary.rst:1106
msgid "REPL"
msgstr ""

#: ../../glossary.rst:1108
msgid ""
"An acronym for the \"read–eval–print loop\", another name for the :term:"
"`interactive` interpreter shell."
msgstr ""

#: ../../glossary.rst:1110
msgid "__slots__"
msgstr "__slots__"

#: ../../glossary.rst:1112
msgid ""
"A declaration inside a class that saves memory by pre-declaring space for "
"instance attributes and eliminating instance dictionaries.  Though popular, "
"the technique is somewhat tricky to get right and is best reserved for rare "
"cases where there are large numbers of instances in a memory-critical "
"application."
msgstr ""
"クラス内での宣言で、インスタンス属性の領域をあらかじめ定義しておき、インスタ"
"ンス辞書を排除することで、メモリを節約します。これはよく使われるテクニックで"
"すが、正しく扱うには少しトリッキーなので、稀なケース、例えばメモリが死活問題"
"となるアプリケーションでインスタンスが大量に存在する、といったときを除き、使"
"わないのがベストです。"

#: ../../glossary.rst:1117
msgid "sequence"
msgstr "sequence"

#: ../../glossary.rst:1119
msgid ""
"An :term:`iterable` which supports efficient element access using integer "
"indices via the :meth:`~object.__getitem__` special method and defines a :"
"meth:`~object.__len__` method that returns the length of the sequence. Some "
"built-in sequence types are :class:`list`, :class:`str`, :class:`tuple`, "
"and :class:`bytes`. Note that :class:`dict` also supports :meth:`~object."
"__getitem__` and :meth:`!__len__`, but is considered a mapping rather than a "
"sequence because the lookups use arbitrary :term:`immutable` keys rather "
"than integers."
msgstr ""

#: ../../glossary.rst:1128
msgid ""
"The :class:`collections.abc.Sequence` abstract base class defines a much "
"richer interface that goes beyond just :meth:`~object.__getitem__` and :meth:"
"`~object.__len__`, adding :meth:`!count`, :meth:`!index`, :meth:`~object."
"__contains__`, and :meth:`~object.__reversed__`. Types that implement this "
"expanded interface can be registered explicitly using :func:`~abc.ABCMeta."
"register`. For more documentation on sequence methods generally, see :ref:"
"`Common Sequence Operations <typesseq-common>`."
msgstr ""

#: ../../glossary.rst:1137
msgid "set comprehension"
msgstr ""

#: ../../glossary.rst:1139
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a set with the results. ``results = {c for c in 'abracadabra' if c "
"not in 'abc'}`` generates the set of strings ``{'r', 'd'}``.  See :ref:"
"`comprehensions`."
msgstr ""
"(集合内包表記) iterable 内の全てあるいは一部の要素を処理して、その結果からな"
"る集合を返すコンパクトな書き方です。 ``results = {c for c in 'abracadabra' "
"if c not in 'abc'}`` とすると、``{'r', 'd'}`` という文字列の辞書を生成しま"
"す。 :ref:`comprehensions` を参照してください。"

#: ../../glossary.rst:1143
msgid "single dispatch"
msgstr "single dispatch"

#: ../../glossary.rst:1145
msgid ""
"A form of :term:`generic function` dispatch where the implementation is "
"chosen based on the type of a single argument."
msgstr ""
":term:`generic function` の一種で実装は一つの引数の型により選択されます。"

#: ../../glossary.rst:1147
msgid "slice"
msgstr "slice"

#: ../../glossary.rst:1149
msgid ""
"An object usually containing a portion of a :term:`sequence`.  A slice is "
"created using the subscript notation, ``[]`` with colons between numbers "
"when several are given, such as in ``variable_name[1:3:5]``.  The bracket "
"(subscript) notation uses :class:`slice` objects internally."
msgstr ""
"(スライス) 一般に :term:`シーケンス <sequence>` の一部を含むオブジェクト。ス"
"ライスは、添字表記 ``[]`` で与えられた複数の数の間にコロンを書くことで作られ"
"ます。例えば、 ``variable_name[1:3:5]`` です。角括弧 (添字) 記号は :class:"
"`slice` オブジェクトを内部で利用しています。"

#: ../../glossary.rst:1153
msgid "soft deprecated"
msgstr ""

#: ../../glossary.rst:1155
msgid ""
"A soft deprecation can be used when using an API which should no longer be "
"used to write new code, but it remains safe to continue using it in existing "
"code. The API remains documented and tested, but will not be developed "
"further (no enhancement)."
msgstr ""

#: ../../glossary.rst:1160
msgid ""
"The main difference between a \"soft\" and a (regular) \"hard\" deprecation "
"is that the soft deprecation does not imply scheduling the removal of the "
"deprecated API."
msgstr ""

#: ../../glossary.rst:1164
msgid "Another difference is that a soft deprecation does not issue a warning."
msgstr ""

#: ../../glossary.rst:1166
msgid ""
"See `PEP 387: Soft Deprecation <https://peps.python.org/pep-0387/#soft-"
"deprecation>`_."
msgstr ""

#: ../../glossary.rst:1168
msgid "special method"
msgstr "special method"

#: ../../glossary.rst:1172
msgid ""
"A method that is called implicitly by Python to execute a certain operation "
"on a type, such as addition.  Such methods have names starting and ending "
"with double underscores.  Special methods are documented in :ref:"
"`specialnames`."
msgstr ""
"(特殊メソッド) ある型に特定の操作、例えば加算をするために Python から暗黙に呼"
"び出されるメソッド。この種類のメソッドは、メソッド名の最初と最後にアンダース"
"コア 2 つがついています。特殊メソッドについては :ref:`specialnames` で解説さ"
"れています。"

#: ../../glossary.rst:1176
msgid "statement"
msgstr "statement"

#: ../../glossary.rst:1178
msgid ""
"A statement is part of a suite (a \"block\" of code).  A statement is either "
"an :term:`expression` or one of several constructs with a keyword, such as :"
"keyword:`if`, :keyword:`while` or :keyword:`for`."
msgstr ""
"(文) 文はスイート (コードの\"ブロック\") に不可欠な要素です。文は :term:`式 "
"<expression>` かキーワードから構成されるもののどちらかです。後者には :"
"keyword:`if`、:keyword:`while`、:keyword:`for` があります。"

#: ../../glossary.rst:1181
msgid "static type checker"
msgstr ""

#: ../../glossary.rst:1183
msgid ""
"An external tool that reads Python code and analyzes it, looking for issues "
"such as incorrect types. See also :term:`type hints <type hint>` and the :"
"mod:`typing` module."
msgstr ""

#: ../../glossary.rst:1186
msgid "strong reference"
msgstr ""

#: ../../glossary.rst:1188
msgid ""
"In Python's C API, a strong reference is a reference to an object which is "
"owned by the code holding the reference.  The strong reference is taken by "
"calling :c:func:`Py_INCREF` when the reference is created and released with :"
"c:func:`Py_DECREF` when the reference is deleted."
msgstr ""

#: ../../glossary.rst:1194
msgid ""
"The :c:func:`Py_NewRef` function can be used to create a strong reference to "
"an object. Usually, the :c:func:`Py_DECREF` function must be called on the "
"strong reference before exiting the scope of the strong reference, to avoid "
"leaking one reference."
msgstr ""

#: ../../glossary.rst:1199
msgid "See also :term:`borrowed reference`."
msgstr ""

#: ../../glossary.rst:1200
msgid "text encoding"
msgstr "text encoding"

#: ../../glossary.rst:1202
msgid ""
"A string in Python is a sequence of Unicode code points (in range "
"``U+0000``--``U+10FFFF``). To store or transfer a string, it needs to be "
"serialized as a sequence of bytes."
msgstr ""

#: ../../glossary.rst:1206
msgid ""
"Serializing a string into a sequence of bytes is known as \"encoding\", and "
"recreating the string from the sequence of bytes is known as \"decoding\"."
msgstr ""

#: ../../glossary.rst:1209
msgid ""
"There are a variety of different text serialization :ref:`codecs <standard-"
"encodings>`, which are collectively referred to as \"text encodings\"."
msgstr ""

#: ../../glossary.rst:1212
msgid "text file"
msgstr "text file"

#: ../../glossary.rst:1214
msgid ""
"A :term:`file object` able to read and write :class:`str` objects. Often, a "
"text file actually accesses a byte-oriented datastream and handles the :term:"
"`text encoding` automatically. Examples of text files are files opened in "
"text mode (``'r'`` or ``'w'``), :data:`sys.stdin`, :data:`sys.stdout`, and "
"instances of :class:`io.StringIO`."
msgstr ""
"(テキストファイル) :class:`str` オブジェクトを読み書きできる :term:`file "
"object` です。\n"
"しばしば、テキストファイルは実際にバイト指向のデータストリームにアクセス"
"し、 :term:`テキストエンコーディング <text encoding>` を自動的に行います。\n"
"テキストファイルの例は、 :data:`sys.stdin`, :data:`sys.stdout`, :class:`io."
"StringIO` インスタンスなどをテキストモード (``'r'`` or ``'w'``) で開いたファ"
"イルです。"

#: ../../glossary.rst:1221
msgid ""
"See also :term:`binary file` for a file object able to read and write :term:"
"`bytes-like objects <bytes-like object>`."
msgstr ""
":term:`bytes-like オブジェクト <bytes-like object>` を読み書きできるファイル"
"オブジェクトについては、 :term:`バイナリファイル <binary file>` も参照してく"
"ださい。"

#: ../../glossary.rst:1223
msgid "triple-quoted string"
msgstr "triple-quoted string"

#: ../../glossary.rst:1225
msgid ""
"A string which is bound by three instances of either a quotation mark (\") "
"or an apostrophe (').  While they don't provide any functionality not "
"available with single-quoted strings, they are useful for a number of "
"reasons.  They allow you to include unescaped single and double quotes "
"within a string and they can span multiple lines without the use of the "
"continuation character, making them especially useful when writing "
"docstrings."
msgstr ""
"(三重クォート文字列) 3つの連続したクォート記号(\")かアポストロフィー(')で囲ま"
"れた文字列。通常の(一重)クォート文字列に比べて表現できる文字列に違いはありま"
"せんが、幾つかの理由で有用です。1つか2つの連続したクォート記号をエスケープ無"
"しに書くことができますし、行継続文字(\\\\)を使わなくても複数行にまたがること"
"ができるので、ドキュメンテーション文字列を書く時に特に便利です。"

#: ../../glossary.rst:1232
msgid "type"
msgstr "type"

#: ../../glossary.rst:1234
msgid ""
"The type of a Python object determines what kind of object it is; every "
"object has a type.  An object's type is accessible as its :attr:`~instance."
"__class__` attribute or can be retrieved with ``type(obj)``."
msgstr ""
"(型) Python オブジェクトの型はオブジェクトがどのようなものかを決めます。あら"
"ゆるオブジェクトは型を持っています。オブジェクトの型は :attr:`~instance."
"__class__` 属性でアクセスしたり、``type(obj)`` で取得したり出来ます。"

#: ../../glossary.rst:1238
msgid "type alias"
msgstr "type alias"

#: ../../glossary.rst:1240
msgid "A synonym for a type, created by assigning the type to an identifier."
msgstr "(型エイリアス) 型の別名で、型を識別子に代入して作成します。"

#: ../../glossary.rst:1242
msgid ""
"Type aliases are useful for simplifying :term:`type hints <type hint>`. For "
"example::"
msgstr ""
"型エイリアスは :term:`型ヒント <type hint>` を単純化するのに有用です。例え"
"ば::"

#: ../../glossary.rst:1249
msgid "could be made more readable like this::"
msgstr "これは次のようにより読みやすくできます::"

#: ../../glossary.rst:1256 ../../glossary.rst:1270
msgid "See :mod:`typing` and :pep:`484`, which describe this functionality."
msgstr "機能の説明がある :mod:`typing` と :pep:`484` を参照してください。"

#: ../../glossary.rst:1257
msgid "type hint"
msgstr "type hint"

#: ../../glossary.rst:1259
msgid ""
"An :term:`annotation` that specifies the expected type for a variable, a "
"class attribute, or a function parameter or return value."
msgstr ""
"(型ヒント) 変数、クラス属性、関数のパラメータや返り値の期待される型を指定す"
"る :term:`annotation` です。"

#: ../../glossary.rst:1262
msgid ""
"Type hints are optional and are not enforced by Python but they are useful "
"to :term:`static type checkers <static type checker>`. They can also aid "
"IDEs with code completion and refactoring."
msgstr ""

#: ../../glossary.rst:1266
msgid ""
"Type hints of global variables, class attributes, and functions, but not "
"local variables, can be accessed using :func:`typing.get_type_hints`."
msgstr ""
"グローバル変数、クラス属性、関数で、ローカル変数でないものの型ヒントは :func:"
"`typing.get_type_hints` で取得できます。"

#: ../../glossary.rst:1271
msgid "universal newlines"
msgstr "universal newlines"

#: ../../glossary.rst:1273
msgid ""
"A manner of interpreting text streams in which all of the following are "
"recognized as ending a line: the Unix end-of-line convention ``'\\n'``, the "
"Windows convention ``'\\r\\n'``, and the old Macintosh convention "
"``'\\r'``.  See :pep:`278` and :pep:`3116`, as well as :func:`bytes."
"splitlines` for an additional use."
msgstr ""
"テキストストリームの解釈法の一つで、以下のすべてを行末と認識します: Unix の行"
"末規定 ``'\\n'``、Windows の規定 ``'\\r\\n'``、古い Macintosh の規定 "
"``'\\r'``。利用法について詳しくは、 :pep:`278` と :pep:`3116` 、さらに :func:"
"`bytes.splitlines` も参照してください。"

#: ../../glossary.rst:1278
msgid "variable annotation"
msgstr "variable annotation"

#: ../../glossary.rst:1280
msgid "An :term:`annotation` of a variable or a class attribute."
msgstr "(変数アノテーション) 変数あるいはクラス属性の :term:`annotation` 。"

#: ../../glossary.rst:1282
msgid ""
"When annotating a variable or a class attribute, assignment is optional::"
msgstr "変数あるいはクラス属性に注釈を付けたときは、代入部分は任意です::"

#: ../../glossary.rst:1287
msgid ""
"Variable annotations are usually used for :term:`type hints <type hint>`: "
"for example this variable is expected to take :class:`int` values::"
msgstr ""
"変数アノテーションは通常は :term:`型ヒント<type hint>` のために使われます: 例"
"えば、この変数は :class:`int` の値を取ることを期待されています::"

#: ../../glossary.rst:1293
msgid "Variable annotation syntax is explained in section :ref:`annassign`."
msgstr ""
"変数アノテーションの構文については :ref:`annassign` 節で解説しています。"

#: ../../glossary.rst:1295
msgid ""
"See :term:`function annotation`, :pep:`484` and :pep:`526`, which describe "
"this functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"機能の説明がある :term:`function annotation`,  :pep:`484` , :pep:`526` を参照"
"してください。また、アノテーションを利用するベストプラクティスとして :ref:"
"`annotations-howto` も参照してください。"

#: ../../glossary.rst:1299
msgid "virtual environment"
msgstr "virtual environment"

#: ../../glossary.rst:1301
msgid ""
"A cooperatively isolated runtime environment that allows Python users and "
"applications to install and upgrade Python distribution packages without "
"interfering with the behaviour of other Python applications running on the "
"same system."
msgstr ""
"(仮想環境) 協調的に切り離された実行環境です。これにより Python ユーザとアプリ"
"ケーションは同じシステム上で動いている他の Python アプリケーションの挙動に干"
"渉することなく Python パッケージのインストールと更新を行うことができます。"

#: ../../glossary.rst:1306
msgid "See also :mod:`venv`."
msgstr ":mod:`venv` を参照してください。"

#: ../../glossary.rst:1307
msgid "virtual machine"
msgstr "virtual machine"

#: ../../glossary.rst:1309
msgid ""
"A computer defined entirely in software.  Python's virtual machine executes "
"the :term:`bytecode` emitted by the bytecode compiler."
msgstr ""
"(仮想マシン) 完全にソフトウェアにより定義されたコンピュータ。 Python の仮想マ"
"シンは、バイトコードコンパイラが出力した :term:`バイトコード <bytecode>` を実"
"行します。"

#: ../../glossary.rst:1311
msgid "Zen of Python"
msgstr "Zen of Python"

#: ../../glossary.rst:1313
msgid ""
"Listing of Python design principles and philosophies that are helpful in "
"understanding and using the language.  The listing can be found by typing "
"\"``import this``\" at the interactive prompt."
msgstr ""
"(Pythonの悟り) Python を理解し利用する上での導きとなる、Python の設計原則と哲"
"学をリストにしたものです。対話プロンプトで \"``import this``\" とするとこのリ"
"ストを読めます。"

#: ../../glossary.rst:256
msgid "C-contiguous"
msgstr ""

#: ../../glossary.rst:256
msgid "Fortran contiguous"
msgstr ""

#: ../../glossary.rst:773
msgid "magic"
msgstr ""

#: ../../glossary.rst:1170
msgid "special"
msgstr "特殊"
