# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2017
# tomoğŸ§, 2017
# Arihiro TAKASE, 2017
# Naoki INADA <songofacandy@gmail.com>, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2017
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-30 05:56+0900\n"
"PO-Revision-Date: 2017-02-16 23:40+0000\n"
"Last-Translator: ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../tutorial/floatingpoint.rst:9
msgid "Floating Point Arithmetic:  Issues and Limitations"
msgstr "æµ®å‹•å°æ•°ç‚¹æ¼”ç®—ã€ãã®å•é¡Œã¨åˆ¶é™"

#: ../../tutorial/floatingpoint.rst:14
msgid ""
"Floating-point numbers are represented in computer hardware as base 2 "
"(binary) fractions.  For example, the decimal fraction ::"
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã¯ã€è¨ˆç®—æ©Ÿãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã®ä¸­ã§ã¯ã€åŸºæ•°ã‚’ 2 ã¨ã™ã‚‹ (2é€²æ³•ã®) åˆ†æ•°ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€å°æ•° ::"

#: ../../tutorial/floatingpoint.rst:19
msgid ""
"has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction ::"
msgstr "ã¯ã€ 1/10 + 2/100 + 5/1000 ã¨ã„ã†å€¤ã‚’æŒã¡ã¾ã™ãŒã€ã“ã‚Œã¨åŒæ§˜ã«ã€2 é€²æ³•ã®åˆ†æ•° ::"

#: ../../tutorial/floatingpoint.rst:23
msgid ""
"has value 0/2 + 0/4 + 1/8.  These two fractions have identical values, the "
"only real difference being that the first is written in base 10 fractional "
"notation, and the second in base 2."
msgstr ""
"ã¯ 0/2 + 0/4 + 1/8 ã¨ã„ã†å€¤ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰äºŒã¤ã®åˆ†æ•°ã¯åŒã˜å€¤ã‚’æŒã£ã¦ã„ã¾ã™ãŒã€ãŸã ä¸€ã¤ã€æœ€åˆã®åˆ†æ•°ã¯åŸºæ•° 10 "
"ã§è¨˜è¿°ã•ã‚Œã¦ãŠã‚Šã€äºŒç•ªç›®ã®åˆ†æ•°ã¯åŸºæ•° 2 ã§è¨˜è¿°ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒé•ã„ã¾ã™ã€‚"

#: ../../tutorial/floatingpoint.rst:27
msgid ""
"Unfortunately, most decimal fractions cannot be represented exactly as "
"binary fractions.  A consequence is that, in general, the decimal floating-"
"point numbers you enter are only approximated by the binary floating-point "
"numbers actually stored in the machine."
msgstr ""
"æ®‹å¿µãªã“ã¨ã«ã€ã»ã¨ã‚“ã©ã®å°æ•°ã¯ 2 é€²æ³•ã®åˆ†æ•°ã¨ã—ã¦æ­£ç¢ºã«è¡¨ã‚ã™ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ãã®çµæœã€ä¸€èˆ¬ã«ã€å…¥åŠ›ã—ãŸ 10 é€²ã®æµ®å‹•å°æ•°ç‚¹æ•°ã¯ã€ 2 "
"é€²æ³•ã®æµ®å‹•å°æ•°ç‚¹æ•°ã§è¿‘ä¼¼ã•ã‚ŒãŸå¾Œã€å®Ÿéš›ã«ãƒã‚·ãƒ³ã«è¨˜æ†¶ã•ã‚Œã¾ã™ã€‚"

#: ../../tutorial/floatingpoint.rst:32
msgid ""
"The problem is easier to understand at first in base 10.  Consider the "
"fraction 1/3.  You can approximate that as a base 10 fraction::"
msgstr ""
"æœ€åˆã¯åŸºæ•° 10 ã‚’ä½¿ã†ã¨å•é¡Œã‚’ç°¡å˜ã«ç†è§£ã§ãã¾ã™ã€‚åˆ†æ•° 1/3 ã‚’è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†ã€‚åˆ†æ•° 1/3 ã¯ã€åŸºæ•° 10 "
"ã®åˆ†æ•°ã¨ã—ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ã«è¿‘ä¼¼ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/floatingpoint.rst:37 ../../tutorial/floatingpoint.rst:41
msgid "or, better, ::"
msgstr "ã•ã‚‰ã«æ­£ç¢ºãªè¿‘ä¼¼ã¯ã€ ::"

#: ../../tutorial/floatingpoint.rst:45
msgid ""
"and so on.  No matter how many digits you're willing to write down, the "
"result will never be exactly 1/3, but will be an increasingly better "
"approximation of 1/3."
msgstr ""
"ã¨ãªã‚Šã€ä»¥å¾ŒåŒæ§˜ã§ã™ã€‚ä½•å€‹æ¡æ•°ã‚’å¢—ã‚„ã—ã¦æ›¸ã“ã†ãŒã€çµæœã¯æ±ºã—ã¦å³å¯†ãª 1/3 ã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã—ã‹ã—ã€å°‘ã—ã¥ã¤æ­£ç¢ºãªè¿‘ä¼¼ã«ã¯ãªã£ã¦ã„ãã§ã—ã‚‡ã†ã€‚"

#: ../../tutorial/floatingpoint.rst:49
msgid ""
"In the same way, no matter how many base 2 digits you're willing to use, the"
" decimal value 0.1 cannot be represented exactly as a base 2 fraction.  In "
"base 2, 1/10 is the infinitely repeating fraction ::"
msgstr ""
"åŒæ§˜ã«ã€åŸºæ•°ã‚’ 2 ã¨ã—ãŸè¡¨ç¾ã§ä½•æ¡ä½¿ãŠã†ã¨ã‚‚ã€10 é€²æ•°ã® 0.1 ã¯åŸºæ•°ã‚’ 2 ã¨ã—ãŸå°æ•°ã§æ­£ç¢ºã«è¡¨ç¾ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚åŸºæ•° 2 ã§ã¯ã€1/10"
" ã¯å¾ªç’°å°æ•° (repeating fraction) ã¨ãªã‚Šã¾ã™ ::"

#: ../../tutorial/floatingpoint.rst:55
msgid ""
"Stop at any finite number of bits, and you get an approximation.  On most "
"machines today, floats are approximated using a binary fraction with the "
"numerator using the first 53 bits starting with the most significant bit and"
" with the denominator as a power of two.  In the case of 1/10, the binary "
"fraction is ``3602879701896397 / 2 ** 55`` which is close to but not exactly"
" equal to the true value of 1/10."
msgstr ""
"ã©ã“ã‹æœ‰é™ã®æ¡ã§æ­¢ã‚ã‚‹ã¨ã€è¿‘ä¼¼å€¤ã‚’å¾—ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚è¿‘å¹´ã®æ®†ã©ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã§ã¯ float å‹ã¯ã€åˆ†å­ã«æœ€ã‚‚é‡å¤§ãªãƒ“ãƒƒãƒˆã‹ã‚‰å§‹ã‚ã¦æœ€åˆã® 53 "
"ãƒ“ãƒƒãƒˆã‚’ä½¿ã„ã€åˆ†æ¯ã« 2 ã®ç´¯ä¹—ã‚’ä½¿ã£ãŸã€äºŒé€²å°æ•°ã‚’ä½¿ã£ã¦è¿‘ä¼¼ã•ã‚Œã¾ã™ã€‚1/10 ã®å ´åˆã¯ã€äºŒé€²å°æ•°ã¯ ``3602879701896397 / 2 "
"** 55`` ã¨ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€1/10 ã«è¿‘ã„ã§ã™ãŒã€å³å¯†ã«åŒã˜å€¤ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../tutorial/floatingpoint.rst:62
msgid ""
"Many users are not aware of the approximation because of the way values are "
"displayed.  Python only prints a decimal approximation to the true decimal "
"value of the binary approximation stored by the machine.  On most machines, "
"if Python were to print the true decimal value of the binary approximation "
"stored for 0.1, it would have to display ::"
msgstr ""
"å€¤ãŒè¡¨ç¤ºã•ã‚Œã‚‹æ–¹æ³•ã®ãŸã‚ã«ã€ã»ã¨ã‚“ã©ã®ãƒ¦ãƒ¼ã‚¶ã¯ã€è¿‘ä¼¼ã«æ°—ã¥ãã¾ã›ã‚“ã€‚Python "
"ã¯ãƒã‚·ãƒ³ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹äºŒé€²è¿‘ä¼¼å€¤ã®10é€²å°æ•°ã§ã®è¿‘ä¼¼å€¤ã‚’è¡¨ç¤ºã™ã‚‹ã®ã§ã€æ ¼ç´ã•ã‚Œã¦ã„ã‚‹å€¤ãŒå…ƒã®10é€²å°æ•°ã®è¿‘ä¼¼å€¤ã§ã—ã‹ç„¡ã„ã“ã¨ã‚’å¿˜ã‚ŒãŒã¡ã§ã™ã€‚ã»ã¨ã‚“ã©ã®ãƒã‚·ãƒ³ã§ã€ã‚‚ã—"
" Python ãŒ2é€²æ•°ã§è¿‘ä¼¼ã•ã‚ŒãŸ 0.1 ã®è¿‘ä¼¼å€¤ã‚’ãã®ã¾ã¾10é€²æ•°ã§è¡¨ç¤ºã—ã¦ã„ãŸã‚‰ã€ãã®çµæœã¯æ¬¡ã®ã‚ˆã†ã«ãªã£ãŸã§ã—ã‚‡ã† ::"

#: ../../tutorial/floatingpoint.rst:71
msgid ""
"That is more digits than most people find useful, so Python keeps the number"
" of digits manageable by displaying a rounded value instead ::"
msgstr ""
"ã“ã‚Œã¯ã€ã»ã¨ã‚“ã©ã®äººãŒå¿…è¦ã¨æ„Ÿã˜ã‚‹ã‚ˆã‚Šã‚‚å¤šã™ãã‚‹æ¡æ•°ã§ã™ã€‚ãªã®ã§ã€Python ã¯ä¸¸ã‚ãŸå€¤ã‚’è¡¨ç¤ºã™ã‚‹ã“ã¨ã§ã€æ¡æ•°ã‚’æ‰±ã„ã‚„ã™ã„ç¯„å›²ã«ã¨ã©ã‚ã¾ã™ ::"

#: ../../tutorial/floatingpoint.rst:77
msgid ""
"Just remember, even though the printed result looks like the exact value of "
"1/10, the actual stored value is the nearest representable binary fraction."
msgstr ""
"è¡¨ç¤ºã•ã‚ŒãŸçµæœãŒæ­£ç¢ºã« 1/10 "
"ã§ã‚ã‚‹ã‚ˆã†ã«è¦‹ãˆãŸã¨ã—ã¦ã‚‚ã€å®Ÿéš›ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹å€¤ã¯æœ€ã‚‚è¿‘ãè¡¨ç¾ã§ãã‚‹äºŒé€²å°æ•°ã§ã‚ã‚‹ã¨ã„ã†ã“ã¨ã ã‘ã¯è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/floatingpoint.rst:80
msgid ""
"Interestingly, there are many different decimal numbers that share the same "
"nearest approximate binary fraction.  For example, the numbers ``0.1`` and "
"``0.10000000000000001`` and "
"``0.1000000000000000055511151231257827021181583404541015625`` are all "
"approximated by ``3602879701896397 / 2 ** 55``.  Since all of these decimal "
"values share the same approximation, any one of them could be displayed "
"while still preserving the invariant ``eval(repr(x)) == x``."
msgstr ""
"å¹¾ã¤ã‹ã®ç•°ãªã‚‹10é€²æ•°ã®å€¤ãŒã€åŒã˜2é€²æœ‰ç†æ•°ã®è¿‘ä¼¼å€¤ã‚’å…±æœ‰ã—ã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€``0.1`` ã¨ ``0.10000000000000001`` ã¨ "
"``0.1000000000000000055511151231257827021181583404541015625`` ã¯ã©ã‚Œã‚‚ "
"``3602879701896397 / 2 ** 55`` ã«è¿‘ä¼¼ã•ã‚Œã¾ã™ã€‚åŒã˜è¿‘ä¼¼å€¤ã‚’å…±æœ‰ã—ã¦ã„ã‚‹ã®ã§ã€ã©ã®10é€²æ•°ã®å€¤ã‚‚ "
"``eval(repr(x)) == x`` ã¨ã„ã†æ¡ä»¶ã‚’æº€ãŸã—ãŸã¾ã¾åŒã˜ã‚ˆã†ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚"

#: ../../tutorial/floatingpoint.rst:88
msgid ""
"Historically, the Python prompt and built-in :func:`repr` function would "
"choose the one with 17 significant digits, ``0.10000000000000001``.   "
"Starting with Python 3.1, Python (on most systems) is now able to choose the"
" shortest of these and simply display ``0.1``."
msgstr ""
"æ˜”ã® Python ã¯ã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã¨ :func:`repr` ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•°ã¯ 17 æ¡ã®æœ‰åŠ¹æ•°å­—ã‚’æŒã¤ "
"``0.10000000000000001`` ã®ã‚ˆã†ãª10é€²æ•°ã®å€¤ã‚’é¸ã‚“ã§è¡¨ç¤ºã—ã¦ã„ã¾ã—ãŸã€‚ Python 3.1 ã‹ã‚‰ã¯ã€ã»ã¨ã‚“ã©ã®å ´é¢ã§ "
"``0.1`` ã®ã‚ˆã†ãªæœ€ã‚‚çŸ­ã„æ¡æ•°ã®10é€²æ•°ã®å€¤ã‚’é¸ã¶ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../tutorial/floatingpoint.rst:93
msgid ""
"Note that this is in the very nature of binary floating-point: this is not a"
" bug in Python, and it is not a bug in your code either.  You'll see the "
"same kind of thing in all languages that support your hardware's floating-"
"point arithmetic (although some languages may not *display* the difference "
"by default, or in all output modes)."
msgstr ""
"ã“ã®å‹•ä½œã¯2é€²æ•°ã®æµ®å‹•å°æ•°ç‚¹ã«ã¨ã£ã¦ã¯ã”ãè‡ªç„¶ãªã‚‚ã®ã§ã™ã€‚ã“ã‚Œã¯ Python "
"ã®ãƒã‚°ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã—ã€ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã®ãƒã‚°ã§ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã®æµ®å‹•å°æ•°ç‚¹æ¼”ç®—ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹å…¨ã¦ã®è¨€èªã§åŒã˜ç¨®é¡ã®å•é¡Œã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™"
" (ã„ãã¤ã‹ã®è¨€èªã§ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã€ã‚ã‚‹ã„ã¯ã©ã®å‡ºåŠ›ãƒ¢ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ã‚‚ã€ã“ã®å·®ã‚’ **è¡¨ç¤º** ã—ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒ)ã€‚"

#: ../../tutorial/floatingpoint.rst:99
msgid ""
"For more pleasant output, you may wish to use string formatting to produce a"
" limited number of significant digits::"
msgstr "ã‚ˆã‚Šã‚ˆã„å‡ºåŠ›ã®ãŸã‚ã«ã€æ–‡å­—åˆ—ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’åˆ©ç”¨ã—ã¦æœ‰åŠ¹æ¡æ•°ã‚’åˆ¶é™ã—ãŸ10é€²æ•°è¡¨ç¾ã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/floatingpoint.rst:111
msgid ""
"It's important to realize that this is, in a real sense, an illusion: you're"
" simply rounding the *display* of the true machine value."
msgstr "ã“ã‚ŒãŒã€å®Ÿéš›ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ä¸Šã®å€¤ã® *è¡¨ç¤º* ã‚’ä¸¸ã‚ã¦ã„ã‚‹ã ã‘ã®ã€ã„ã‚ã°éŒ¯è¦šã ã¨ã„ã†ã“ã¨ã‚’èªè­˜ã—ã¦ãŠã„ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/floatingpoint.rst:114
msgid ""
"One illusion may beget another.  For example, since 0.1 is not exactly 1/10,"
" summing three values of 0.1 may not yield exactly 0.3, either::"
msgstr ""
"ã‚‚ã†ä¸€ã¤ã®éŒ¯è¦šã‚’ç´¹ä»‹ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€0.1 ãŒæ­£ç¢ºã«ã¯ 1/10 ã§ã¯ãªã„ãŸã‚ã«ã€ãã‚Œã‚’3å›è¶³ã—ãŸå€¤ã‚‚ã¾ãŸæ­£ç¢ºã«ã¯ 0.3 ã§ã¯ã‚ã‚Šã¾ã›ã‚“::"

#: ../../tutorial/floatingpoint.rst:120
msgid ""
"Also, since the 0.1 cannot get any closer to the exact value of 1/10 and 0.3"
" cannot get any closer to the exact value of 3/10, then pre-rounding with "
":func:`round` function cannot help::"
msgstr ""
"0.1 ã¯ã“ã‚Œä»¥ä¸Š 1/10 ã«è¿‘ããªã‚‹ã“ã¨ãŒã§ããªã„å€¤ã§ã€ 0.3 ã‚‚ã¾ãŸ 3/10 ã«ä¸€ç•ªè¿‘ã„å€¤ãªã®ã§ã€ :func:`round` "
"é–¢æ•°ã‚’ä½¿ã£ã¦è¨ˆç®—å‰ã«ä¸¸ã‚ã‚’è¡Œãªã£ã¦ã‚‚æ„å‘³ãŒã‚ã‚Šã¾ã›ã‚“::"

#: ../../tutorial/floatingpoint.rst:127
msgid ""
"Though the numbers cannot be made closer to their intended exact values, the"
" :func:`round` function can be useful for post-rounding so that results with"
" inexact values become comparable to one another::"
msgstr ""
"æ•°å­—ãŒæ­£ç¢ºãªå€¤ã«æœ€ã‚‚è¿‘ã„å€¤ã«ãªã£ã¦ã„ã‚‹ã¨ã¯ã„ãˆã€ :func:`round` "
"é–¢æ•°ã‚’ä½¿ã£ã¦è¨ˆç®—å¾Œã®å€¤ã‚’ä¸¸ã‚ã‚‹ã“ã¨ã§ã€ä¸æ­£ç¢ºãªä»£ã‚ã‚Šã«ä»–ã®å€¤ã¨æ¯”è¼ƒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹äº‹ãŒã‚ã‚Šã¾ã™::"

#: ../../tutorial/floatingpoint.rst:134
msgid ""
"Binary floating-point arithmetic holds many surprises like this.  The "
"problem with \"0.1\" is explained in precise detail below, in the "
"\"Representation Error\" section.  See `The Perils of Floating Point "
"<http://www.lahey.com/float.htm>`_ for a more complete account of other "
"common surprises."
msgstr ""
"2 é€²ã®æµ®å‹•å°æ•°ç‚¹æ•°ã«å¯¾ã™ã‚‹ç®—è¡“æ¼”ç®—ã¯ã€ã“ã®ã‚ˆã†ãªæ„å¤–æ€§ã‚’ãŸãã•ã‚“æŒã£ã¦ã„ã¾ã™ã€‚ \"0.1\" ã«é–¢ã™ã‚‹å•é¡Œã¯ã€ä»¥ä¸‹ã® \"è¡¨ç¾ã‚¨ãƒ©ãƒ¼\" "
"ã®ç« ã§è©³ç´°ã«èª¬æ˜ã—ã¾ã™ã€‚ 2 é€²æ³•ã®æµ®å‹•å°æ•°ç‚¹æ¼”ç®—ã«ã¨ã‚‚ãªã†ãã®ä»–ã®ã‚ˆãçŸ¥ã‚‰ã‚ŒãŸæ„å¤–ãªäº‹è±¡ã«é–¢ã—ã¦ã¯ `The Perils of Floating "
"Point <http://www.lahey.com/float.htm>`_ ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/floatingpoint.rst:139
msgid ""
"As that says near the end, \"there are no easy answers.\"  Still, don't be "
"unduly wary of floating-point!  The errors in Python float operations are "
"inherited from the floating-point hardware, and on most machines are on the "
"order of no more than 1 part in 2\\*\\*53 per operation.  That's more than "
"adequate for most tasks, but you do need to keep in mind that it's not "
"decimal arithmetic and that every float operation can suffer a new rounding "
"error."
msgstr ""
"ç©¶æ¥µçš„ã«ã„ã†ã¨ã€\"å®¹æ˜“ãªç­”ãˆã¯ã‚ã‚Šã¾ã›ã‚“\"ã€‚ã§ã™ãŒã€æµ®å‹•å°æ•°ç‚¹æ•°ã®ã“ã¨ã‚’éåº¦ã«è­¦æˆ’ã—ãªã„ã§ãã ã•ã„ï¼ Python ã® float "
"å‹æ“ä½œã«ãŠã‘ã‚‹ã‚¨ãƒ©ãƒ¼ã¯æµ®å‹•å°æ•°ç‚¹å‡¦ç†ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‹ã‚‰å—ã‘ã¤ã„ãŸã‚‚ã®ã§ã‚ã‚Šã€ã»ã¨ã‚“ã©ã®ãƒã‚·ãƒ³ä¸Šã§ã¯ä¸€ã¤ã®æ¼”ç®—ã‚ãŸã‚Šé«˜ã€… 2\\*\\*53 åˆ†ã® 1 "
"ã§ã™ã€‚ã“ã®èª¤å·®ã¯ã»ã¨ã‚“ã©ã®ä½œæ¥­ã§å……åˆ†ä»¥ä¸Šã®ã‚‚ã®ã§ã™ãŒã€æµ®å‹•å°æ•°ç‚¹æ¼”ç®—ã¯ 10 "
"é€²ã®æ¼”ç®—ã§ã¯ãªãã€æµ®å‹•å°æ•°ç‚¹ã®æ¼”ç®—ã‚’æ–°ãŸã«è¡Œã†ã¨ã€æ–°ãŸãªä¸¸ã‚èª¤å·®ã®å½±éŸ¿ã‚’å—ã‘ã‚‹ã“ã¨ã‚’å¿ƒã«ã¨ã©ã‚ã¦ãŠã„ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/floatingpoint.rst:146
msgid ""
"While pathological cases do exist, for most casual use of floating-point "
"arithmetic you'll see the result you expect in the end if you simply round "
"the display of your final results to the number of decimal digits you "
"expect. :func:`str` usually suffices, and for finer control see the "
":meth:`str.format` method's format specifiers in :ref:`formatstrings`."
msgstr ""
"ç•°å¸¸ãªã‚±ãƒ¼ã‚¹ãŒå­˜åœ¨ã™ã‚‹ä¸€æ–¹ã§ã€æ™®æ®µã®æµ®å‹•å°æ•°ç‚¹æ¼”ç®—ã®åˆ©ç”¨ã§ã¯ã€å˜ã«æœ€çµ‚çš„ãªçµæœã®å€¤ã‚’å¿…è¦ãª 10 "
"é€²ã®æ¡æ•°ã«ä¸¸ã‚ã¦è¡¨ç¤ºã™ã‚‹ã®ãªã‚‰ã€æœ€çµ‚çš„ã«ã¯æœŸå¾…é€šã‚Šã®çµæœã‚’å¾—ã‚‹ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚ãŸã„ã¦ã¯ :func:`str` "
"ã§ååˆ†ã§ã™ãŒã€ãã‚ç´°ã‹ãªåˆ¶å¾¡ã‚’ã—ãŸã‘ã‚Œã°ã€ :ref:`formatstrings` ã«ã‚ã‚‹ :meth:`str.format` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆä»•æ§˜ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/floatingpoint.rst:152
msgid ""
"For use cases which require exact decimal representation, try using the "
":mod:`decimal` module which implements decimal arithmetic suitable for "
"accounting applications and high-precision applications."
msgstr ""
"æ­£ç¢ºãª10é€²æ•°è¡¨ç¾ãŒå¿…è¦ã¨ãªã‚‹ã‚ˆã†ãªå ´åˆã«ã¯ã€ :mod:`decimal` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆ©ç”¨ã—ã¦ã¿ã¦ãã ã•ã„ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ä¼šè¨ˆã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚„é«˜ç²¾åº¦ã®è¨ˆç®—ãŒæ±‚ã‚ã‚‰ã‚Œã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«é©ã—ãŸã€10é€²æ•°ã®è¨ˆç®—ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/floatingpoint.rst:156
msgid ""
"Another form of exact arithmetic is supported by the :mod:`fractions` module"
" which implements arithmetic based on rational numbers (so the numbers like "
"1/3 can be represented exactly)."
msgstr ""
"åˆ¥ã®æ­£ç¢ºãªè¨ˆç®—æ–¹æ³•ã¨ã—ã¦ã€ :mod:`fractions` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæœ‰ç†æ•°ã«åŸºã¥ãè¨ˆç®—ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ (1/3 "
"ã®ã‚ˆã†ãªæ•°ã‚’æ­£ç¢ºã«è¡¨ã™ã“ã¨ãŒã§ãã¾ã™)ã€‚"

#: ../../tutorial/floatingpoint.rst:160
msgid ""
"If you are a heavy user of floating point operations you should take a look "
"at the Numerical Python package and many other packages for mathematical and"
" statistical operations supplied by the SciPy project. See "
"<https://scipy.org>."
msgstr ""
"ã‚ãªãŸãŒæµ®å‹•å°æ•°ç‚¹æ¼”ç®—ã®ãƒ˜ãƒ“ãƒ¼ãƒ¦ãƒ¼ã‚¶ãƒ¼ãªã‚‰ã€SciPy ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒæä¾›ã—ã¦ã„ã‚‹ Numerical Python "
"ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚„ãã®ä»–ã®æ•°å­¦ç”¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’èª¿ã¹ã¦ã¿ã‚‹ã¹ãã§ã™ã€‚ <https://scipy.org> ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/floatingpoint.rst:164
msgid ""
"Python provides tools that may help on those rare occasions when you really "
"*do* want to know the exact value of a float.  The "
":meth:`float.as_integer_ratio` method expresses the value of a float as a "
"fraction::"
msgstr ""
"Python ã¯ *æœ¬å½“ã«* float ã®æ­£ç¢ºãªå€¤ãŒå¿…è¦ãªãƒ¬ã‚¢ã‚±ãƒ¼ã‚¹ã«å¯¾å¿œã™ã‚‹ãŸã‚ã®ãƒ„ãƒ¼ãƒ«ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ "
":meth:`float.as_integer_ratio` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ float ã®å€¤ã‚’æœ‰ç†æ•°ã¨ã—ã¦è¡¨ç¾ã—ã¾ã™::"

#: ../../tutorial/floatingpoint.rst:173
msgid ""
"Since the ratio is exact, it can be used to losslessly recreate the original"
" value::"
msgstr "ã“ã®åˆ†æ•°ã¯æ­£ç¢ºãªã®ã§ã€å…ƒã®å€¤ã‚’å®Œå…¨ã«å¾©å…ƒã™ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/floatingpoint.rst:179
msgid ""
"The :meth:`float.hex` method expresses a float in hexadecimal (base 16), "
"again giving the exact value stored by your computer::"
msgstr ""
":meth:`float.hex` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ float ã®å€¤ã‚’16é€²æ•°ã§è¡¨ç¾ã—ã¾ã™ã€‚ã“ã®å€¤ã‚‚ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ãŒæŒã£ã¦ã„ã‚‹æ­£ç¢ºãªå€¤ã‚’è¡¨ç¾ã§ãã¾ã™::"

#: ../../tutorial/floatingpoint.rst:185
msgid ""
"This precise hexadecimal representation can be used to reconstruct the float"
" value exactly::"
msgstr "ã“ã®æ­£ç¢ºãª16é€²æ•°è¡¨ç¾ã¯ã‚‚ã¨ã® float å€¤ã‚’æ­£ç¢ºã«å¾©å…ƒã™ã‚‹ãŸã‚ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/floatingpoint.rst:191
msgid ""
"Since the representation is exact, it is useful for reliably porting values "
"across different versions of Python (platform independence) and exchanging "
"data with other languages that support the same format (such as Java and "
"C99)."
msgstr ""
"ã“ã®16é€²æ•°è¡¨ç¾ã¯æ­£ç¢ºãªã®ã§ã€å€¤ã‚’ (ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ã‚‚ä¾å­˜ã›ãš) ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ç•°ãªã‚‹Python "
"é–“ã§ã‚„ã‚Šå–ã‚Šã—ãŸã‚Šã€ä»–ã®ã“ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ãŸè¨€èª (Java ã‚„ C99 ãªã©) ã¨æ­£ç¢ºã«ã‚„ã‚Šå–ã‚Šã™ã‚‹ã®ã«åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../tutorial/floatingpoint.rst:195
msgid ""
"Another helpful tool is the :func:`math.fsum` function which helps mitigate "
"loss-of-precision during summation.  It tracks \"lost digits\" as values are"
" added onto a running total.  That can make a difference in overall accuracy"
" so that the errors do not accumulate to the point where they affect the "
"final total:"
msgstr ""
"åˆ¥ã®ä¾¿åˆ©ãªãƒ„ãƒ¼ãƒ«ã¨ã—ã¦ã€åˆè¨ˆå‡¦ç†ã«ãŠã‘ã‚‹ç²¾åº¦ã®ãƒ­ã‚¹ã‚’ç·©å’Œã—ã¦ãã‚Œã‚‹ :func:`math.fsum` "
"é–¢æ•°ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®é–¢æ•°ã¯å€¤ã‚’åˆè¨ˆå€¤ã«è¶³ã—è¾¼ã¿ãªãŒã‚‰ã€ \"å¤±ã‚ã‚ŒãŸæ¡\" "
"ã‚’ç®¡ç†ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€èª¤å·®ãŒæœ€çµ‚çš„ãªåˆè¨ˆå€¤ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹ã¾ã§è“„ç©ã•ã‚Œãªããªã‚Šã€çµæœãŒæ”¹å–„ã•ã‚Œã¾ã™:"

#: ../../tutorial/floatingpoint.rst:209
msgid "Representation Error"
msgstr "è¡¨ç¾ã‚¨ãƒ©ãƒ¼"

#: ../../tutorial/floatingpoint.rst:211
msgid ""
"This section explains the \"0.1\" example in detail, and shows how you can "
"perform an exact analysis of cases like this yourself.  Basic familiarity "
"with binary floating-point representation is assumed."
msgstr ""
"ã“ã®ç« ã§ã¯ã€\"0.1\" ã®ä¾‹ã«ã¤ã„ã¦è©³ç´°ã«èª¬æ˜ã—ã€ã“ã®ã‚ˆã†ãªã‚±ãƒ¼ã‚¹ã«å¯¾ã—ã¦ã©ã®ã‚ˆã†ã«ã™ã‚Œã°æ­£ç¢ºãªåˆ†æã‚’è‡ªåˆ†ã§è¡Œãˆã‚‹ã‹ã‚’ç¤ºã—ã¾ã™ã€‚ã“ã“ã§ã¯ã€ 2 "
"é€²æ³•è¡¨ç¾ã®æµ®å‹•å°æ•°ç‚¹æ•°ã«ã¤ã„ã¦ã®åŸºç¤çš„ãªçŸ¥è­˜ãŒã‚ã‚‹ã‚‚ã®ã¨ã—ã¦è©±ã‚’é€²ã‚ã¾ã™ã€‚"

#: ../../tutorial/floatingpoint.rst:215
msgid ""
":dfn:`Representation error` refers to the fact that some (most, actually) "
"decimal fractions cannot be represented exactly as binary (base 2) "
"fractions. This is the chief reason why Python (or Perl, C, C++, Java, "
"Fortran, and many others) often won't display the exact decimal number you "
"expect."
msgstr ""
"è¡¨ç¾ã‚¨ãƒ©ãƒ¼(:dfn:`Representation error`)ã¯ã€ã„ãã¤ã‹ã® (å®Ÿéš›ã«ã¯ã»ã¨ã‚“ã©ã®) 10 é€²ã®å°æ•°ãŒ 2 é€²æ³• (åŸºæ•° "
"2)ã®åˆ†æ•°ã¨ã—ã¦è¡¨ç¾ã§ããªã„ã¨ã„ã†äº‹å®Ÿã«é–¢ä¿‚ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯ Python (ã‚ã‚‹ã„ã¯ Perl, C, C++, Java, Fortran. "
"ãŠã‚ˆã³ãã®ä»–å¤šã) ãŒæœŸå¾…é€šã‚Šã®æ­£ç¢ºãª 10 é€²æ•°ã‚’è¡¨ç¤ºã§ããªã„ä¸»è¦ãªç†ç”±ã§ã™ã€‚"

#: ../../tutorial/floatingpoint.rst:220
msgid ""
"Why is that?  1/10 is not exactly representable as a binary fraction. Almost"
" all machines today (November 2000) use IEEE-754 floating point arithmetic, "
"and almost all platforms map Python floats to IEEE-754 \"double precision\"."
"  754 doubles contain 53 bits of precision, so on input the computer strives"
" to convert 0.1 to the closest fraction it can of the form *J*/2**\\ *N* "
"where *J* is an integer containing exactly 53 bits.  Rewriting ::"
msgstr ""
"ãªãœã“ã†ãªã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ 1/10 ã¯ 2 é€²æ³•ã®å°æ•°ã§å³å¯†ã«è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ä»Šæ—¥ (2000å¹´11æœˆ) ã®ãƒã‚·ãƒ³ã¯ã€ã»ã¨ã‚“ã©ã™ã¹ã¦ "
"IEEE-754 æµ®å‹•å°æ•°ç‚¹æ¼”ç®—ã‚’ä½¿ç”¨ã—ã¦ãŠã‚Šã€ã»ã¨ã‚“ã©ã™ã¹ã¦ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ Python ã®æµ®å‹•å°æ•°ç‚¹ã‚’ IEEE-754 ã«ãŠã‘ã‚‹ "
"\"å€ç²¾åº¦(double precision)\" ã«å¯¾å¿œä»˜ã‘ã¾ã™ã€‚754 ã® double ã«ã¯ 53 "
"ãƒ“ãƒƒãƒˆã®ç²¾åº¦ã‚’æŒã¤æ•°ãŒå…¥ã‚‹ã®ã§ã€è¨ˆç®—æ©Ÿã«å…¥åŠ›ã‚’è¡ŒãŠã†ã¨ã™ã‚‹ã¨ã€å¯èƒ½ãªé™ã‚Š 0.1 ã‚’æœ€ã‚‚è¿‘ã„å€¤ã®åˆ†æ•°ã«å¤‰æ›ã—ã€*J*/2**\\ *N* "
"ã®å½¢å¼ã«ã—ã‚ˆã†ã¨åŠªåŠ›ã—ã¾ã™ã€‚*J* ã¯ã¡ã‚‡ã†ã© 53 ãƒ“ãƒƒãƒˆã®ç²¾åº¦ã®æ•´æ•°ã§ã™ ::"

#: ../../tutorial/floatingpoint.rst:229
msgid "as ::"
msgstr "ã‚’æ›¸ãç›´ã™ã¨ ::"

#: ../../tutorial/floatingpoint.rst:233
msgid ""
"and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< "
"2**53``), the best value for *N* is 56::"
msgstr ""
"ã¨ãªã‚Šã¾ã™ã€‚ *J* ã¯å³å¯†ã« 53 ãƒ“ãƒƒãƒˆã®ç²¾åº¦ã‚’æŒã£ã¦ã„ã‚‹ (``>= 2**52`` ã ãŒ ``< 2**53`` ) ã“ã¨ã‚’æ€ã„å‡ºã™ã¨ã€ *N*"
" ã¨ã—ã¦æœ€é©ãªå€¤ã¯ 56 ã«ãªã‚Šã¾ã™::"

#: ../../tutorial/floatingpoint.rst:239
msgid ""
"That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits."
"  The best possible value for *J* is then that quotient rounded::"
msgstr ""
"ã™ãªã‚ã¡ã€56 ã¯ *J* ã‚’ã¡ã‚‡ã†ã© 53 ãƒ“ãƒƒãƒˆã®ç²¾åº¦ã®ã¾ã¾ã«ä¿ã¤ *N* ã®å”¯ä¸€ã®å€¤ã§ã™ã€‚*J* ã®å–ã‚Šãˆã‚‹å€¤ã¯ãã®å•†ã‚’ä¸¸ã‚ãŸã‚‚ã®ã§ã™::"

#: ../../tutorial/floatingpoint.rst:246
msgid ""
"Since the remainder is more than half of 10, the best approximation is "
"obtained by rounding up::"
msgstr "å‰°ä½™ãŒ 10 ã®åŠåˆ†ä»¥ä¸Šãªã®ã§ã€æœ€è‰¯ã®è¿‘ä¼¼ã¯åˆ‡ã‚Šä¸Šã’ã¦ä¸¸ã‚ãŸã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/floatingpoint.rst:252
msgid ""
"Therefore the best possible approximation to 1/10 in 754 double precision "
"is::"
msgstr "å¾“ã£ã¦ã€754 å€ç²¾åº¦ã«ãŠã‘ã‚‹ 1/10 ã®å–ã‚Šãˆã‚‹æœ€è‰¯ã®è¿‘ä¼¼ã¯::"

#: ../../tutorial/floatingpoint.rst:256
msgid ""
"Dividing both the numerator and denominator by two reduces the fraction to::"
msgstr "åˆ†å­ã¨åˆ†æ¯ã‚’2ã§å‰²ã£ã¦åˆ†æ•°ã‚’å°ã•ãã—ã¾ã™::"

#: ../../tutorial/floatingpoint.rst:260
msgid ""
"Note that since we rounded up, this is actually a little bit larger than "
"1/10; if we had not rounded up, the quotient would have been a little bit "
"smaller than 1/10.  But in no case can it be *exactly* 1/10!"
msgstr ""
"ä¸¸ã‚ãŸã¨ãã«åˆ‡ã‚Šä¸Šã’ãŸã®ã§ã€ã“ã®å€¤ã¯å®Ÿéš›ã«ã¯ 1/10 ã‚ˆã‚Šå°‘ã—å¤§ãã„ã“ã¨ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚\n"
"ã‚‚ã—åˆ‡ã‚Šæ¨ã¦ã‚’ã—ãŸå ´åˆã¯ã€å•†ã¯ 1/10 ã‚ˆã‚Šã‚‚ã‚ãšã‹ã«å°ã•ããªã‚Šã¾ã™ã€‚ã©ã¡ã‚‰ã«ã—ã‚ *å³å¯†ãª* 1/10 ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼"

#: ../../tutorial/floatingpoint.rst:264
msgid ""
"So the computer never \"sees\" 1/10:  what it sees is the exact fraction "
"given above, the best 754 double approximation it can get::"
msgstr ""
"ã¤ã¾ã‚Šã€è¨ˆç®—æ©Ÿã¯ 1/10 ã‚’ \"ç†è§£ã™ã‚‹\" ã“ã¨ã¯æ±ºã—ã¦ã‚ã‚Šã¾ã›ã‚“ã€‚è¨ˆç®—æ©ŸãŒç†è§£ã§ãã‚‹ã®ã¯ã€ä¸Šè¨˜ã®ã‚ˆã†ãªå³å¯†ãªåˆ†æ•°ã§ã‚ã‚Šã€ 754 "
"ã®å€ç²¾åº¦æµ®å‹•å°æ•°ç‚¹æ•°ã§å¾—ã‚‰ã‚Œã‚‹ã‚‚ã£ã¨ã‚‚ã‚ˆã„è¿‘ä¼¼ã¯ä»¥ä¸‹ã«ãªã‚Šã¾ã™::"

#: ../../tutorial/floatingpoint.rst:270
msgid ""
"If we multiply that fraction by 10\\*\\*55, we can see the value out to 55 "
"decimal digits::"
msgstr "ã“ã®åˆ†æ•°ã« 10\\*\\*55 ã‚’æ›ã‘ã‚Œã°ã€55 æ¡ã®åé€²æ•°ã®å€¤ã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/floatingpoint.rst:276
msgid ""
"meaning that the exact number stored in the computer is equal to the decimal"
" value 0.1000000000000000055511151231257827021181583404541015625. Instead of"
" displaying the full decimal value, many languages (including older versions"
" of Python), round the result to 17 significant digits::"
msgstr ""
"ã“ã‚Œã¯ã€è¨ˆç®—æ©ŸãŒè¨˜æ†¶ã—ã¦ã„ã‚‹æ­£ç¢ºãªæ•°å€¤ãŒã€10 é€²æ•°å€¤ "
"0.1000000000000000055511151231257827021181583404541015625 "
"ã«ã»ã¼ç­‰ã—ã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚å¤šãã®è¨€èª (å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã‚’å«ã‚€) ã§ã¯ã€å®Œå…¨ãª 10 é€²å€¤ã‚’è¡¨ç¤ºã™ã‚‹ã®ã§ã¯ãªãã€çµæœã‚’æœ‰åŠ¹æ•°å­— 17 "
"æ¡ã«ä¸¸ã‚ã¾ã™::"

#: ../../tutorial/floatingpoint.rst:284
msgid ""
"The :mod:`fractions` and :mod:`decimal` modules make these calculations "
"easy::"
msgstr ":mod:`fractions` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ :mod:`decimal` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã†ã¨ã“ã‚Œã‚‰ã®è¨ˆç®—ã‚’ç°¡å˜ã«è¡Œãˆã¾ã™::"
