# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト)
# This file is distributed under the same license as the Python package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: 2017-09-22 17:57+0000\n"
"Last-Translator: 秘湯 <xwhhsprings@gmail.com>\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../tutorial/floatingpoint.rst:5
msgid "Floating Point Arithmetic:  Issues and Limitations"
msgstr "浮動小数点演算、その問題と制限"

#: ../../tutorial/floatingpoint.rst:10
msgid ""
"Floating-point numbers are represented in computer hardware as base 2 "
"(binary) fractions.  For example, the decimal fraction ::"
msgstr "浮動小数点数は、計算機ハードウェアの中では、基数を 2 とする (2進法の) 分数として表現されています。例えば、小数 ::"

#: ../../tutorial/floatingpoint.rst:15
msgid ""
"has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction ::"
msgstr "は、 1/10 + 2/100 + 5/1000 という値を持ちますが、これと同様に、2 進法の分数 ::"

#: ../../tutorial/floatingpoint.rst:19
msgid ""
"has value 0/2 + 0/4 + 1/8.  These two fractions have identical values, the "
"only real difference being that the first is written in base 10 fractional "
"notation, and the second in base 2."
msgstr "は 0/2 + 0/4 + 1/8 という値になります。これら二つの分数は同じ値を持っていますが、ただ一つ、最初の分数は基数 10 で記述されており、二番目の分数は基数 2 で記述されていることが違います。"

#: ../../tutorial/floatingpoint.rst:23
msgid ""
"Unfortunately, most decimal fractions cannot be represented exactly as "
"binary fractions.  A consequence is that, in general, the decimal floating-"
"point numbers you enter are only approximated by the binary floating-point "
"numbers actually stored in the machine."
msgstr "残念なことに、ほとんどの小数は 2 進法の分数として正確に表わすことができません。その結果、一般に、入力した 10 進の浮動小数点数は、 2 進法の浮動小数点数で近似された後、実際にマシンに記憶されます。"

#: ../../tutorial/floatingpoint.rst:28
msgid ""
"The problem is easier to understand at first in base 10.  Consider the "
"fraction 1/3.  You can approximate that as a base 10 fraction::"
msgstr "最初は基数 10 を使うと問題を簡単に理解できます。分数 1/3 を考えてみましょう。分数 1/3 は、基数 10 の分数として、以下のように近似することができます::"

#: ../../tutorial/floatingpoint.rst:33 ../../tutorial/floatingpoint.rst:37
msgid "or, better, ::"
msgstr "さらに正確な近似は、 ::"

#: ../../tutorial/floatingpoint.rst:41
msgid ""
"and so on.  No matter how many digits you're willing to write down, the "
"result will never be exactly 1/3, but will be an increasingly better "
"approximation of 1/3."
msgstr "となり、以後同様です。何個桁数を増やして書こうが、結果は決して厳密な 1/3 にはなりません。しかし、少しづつ正確な近似にはなっていくでしょう。"

#: ../../tutorial/floatingpoint.rst:45
msgid ""
"In the same way, no matter how many base 2 digits you're willing to use, the"
" decimal value 0.1 cannot be represented exactly as a base 2 fraction.  In "
"base 2, 1/10 is the infinitely repeating fraction ::"
msgstr "同様に、基数を 2 とした表現で何桁使おうとも、10 進数の 0.1 は基数を 2 とした小数で正確に表現することはできません。基数 2 では、1/10 は循環小数 (repeating fraction) となります ::"

#: ../../tutorial/floatingpoint.rst:51
msgid "Stop at any finite number of bits, and you get an approximation."
msgstr "どこか有限の桁で止めると、近似値を得ることになります。"

#: ../../tutorial/floatingpoint.rst:53
msgid ""
"On a typical machine running Python, there are 53 bits of precision "
"available for a Python float, so the value stored internally when you enter "
"the decimal number ``0.1`` is the binary fraction ::"
msgstr "Python を実行する典型的なコンピュータでは、 Python の float 型は 53bit の精度を持っています。この場合、10進数で ``0.1`` と書いたときに内部では次のような2進の小数が格納されます。 ::"

#: ../../tutorial/floatingpoint.rst:59
msgid "which is close to, but not exactly equal to, 1/10."
msgstr "これは、 1/10 に近いですが、厳密に同じ値ではありません。"

#: ../../tutorial/floatingpoint.rst:61
msgid ""
"It's easy to forget that the stored value is an approximation to the "
"original decimal fraction, because of the way that floats are displayed at "
"the interpreter prompt.  Python only prints a decimal approximation to the "
"true decimal value of the binary approximation stored by the machine.  If "
"Python were to print the true decimal value of the binary approximation "
"stored for 0.1, it would have to display ::"
msgstr "Python は格納されている値の10進小数での近似値を表示するので、格納されている値が元の10進小数の近似値でしか無いことを忘れがちです。もし Python が2進数で近似された 0.1 の近似値をそのまま10進数で表示していたら、その結果は次のようになったでしょう。 ::"

#: ../../tutorial/floatingpoint.rst:71
msgid ""
"That is more digits than most people find useful, so Python keeps the number"
" of digits manageable by displaying a rounded value instead ::"
msgstr "これは、ほとんどの人が必要と感じるよりも多すぎる桁数です。なので、Python は丸めた値を表示することで、桁数を扱いやすい範囲にとどめます ::"

#: ../../tutorial/floatingpoint.rst:77
msgid ""
"It's important to realize that this is, in a real sense, an illusion: the "
"value in the machine is not exactly 1/10, you're simply rounding the "
"*display* of the true machine value.  This fact becomes apparent as soon as "
"you try to do arithmetic with these values ::"
msgstr "現実には、上の表示は錯覚であると気づくのは重要なことです。マシン内の値は厳密に 1/10 ではなく、単に真のマシン内の *表示される値* を丸めているだけなのです。このことは、これらの値に対して演算を行うとすぐに顕在化します。 ::"

#: ../../tutorial/floatingpoint.rst:85
msgid ""
"Note that this is in the very nature of binary floating-point: this is not a"
" bug in Python, and it is not a bug in your code either.  You'll see the "
"same kind of thing in all languages that support your hardware's floating-"
"point arithmetic (although some languages may not *display* the difference "
"by default, or in all output modes)."
msgstr "この動作は2進数の浮動小数点にとってはごく自然なものです。これは Python のバグではありませんし、あなたのコードのバグでもありません。ハードウェアの浮動小数点演算をサポートしている全ての言語で同じ種類の問題を見つけることができます (いくつかの言語ではデフォルトの、あるいはどの出力モードを選んでも、この差を **表示** しないかもしれませんが)。"

#: ../../tutorial/floatingpoint.rst:91
msgid ""
"Other surprises follow from this one.  For example, if you try to round the "
"value 2.675 to two decimal places, you get this ::"
msgstr "他にも期待と異なるかもしれない場合があります。例えば、 2.675 という値を小数点以下2桁で丸めようとすると、次のような結果になります。"

#: ../../tutorial/floatingpoint.rst:97
msgid ""
"The documentation for the built-in :func:`round` function says that it "
"rounds to the nearest value, rounding ties away from zero.  Since the "
"decimal fraction 2.675 is exactly halfway between 2.67 and 2.68, you might "
"expect the result here to be (a binary approximation to) 2.68.  It's not, "
"because when the decimal string ``2.675`` is converted to a binary floating-"
"point number, it's again replaced with a binary approximation, whose exact "
"value is ::"
msgstr "組み込み関数 :func:`round` のドキュメントには、もっとも近い値に丸め、中央値の場合は 0 から遠い方に丸めると書かれています。10進数の 2.675 は 2.67 と 2.68 のちょうど真ん中なので、結果として 2.68 (の2進数による近似値) を期待するかもしれません。しかし、 10進数の ``2.675`` は2進数の近似値に変換され、その正確な値は次のようになります。 ::"

#: ../../tutorial/floatingpoint.rst:106
msgid ""
"Since this approximation is slightly closer to 2.67 than to 2.68, it's "
"rounded down."
msgstr "この近似値は 2.68 よりすこし 2.67 に近いので、 2.67 に丸められます。"

#: ../../tutorial/floatingpoint.rst:109
msgid ""
"If you're in a situation where you care which way your decimal halfway-cases"
" are rounded, you should consider using the :mod:`decimal` module. "
"Incidentally, the :mod:`decimal` module also provides a nice way to \"see\" "
"the exact value that's stored in any particular Python float ::"
msgstr "10 進数で中央値になる値がどちらに丸められるかを制御しないといけない場合は、 :mod:`decimal` モジュールを使うことを検討するべきです。ちなみに、 :mod:`decimal` モジュールは Python の float 値に格納された正確な値を見るためにも利用できます。"

#: ../../tutorial/floatingpoint.rst:118
msgid ""
"Another consequence is that since 0.1 is not exactly 1/10, summing ten "
"values of 0.1 may not yield exactly 1.0, either::"
msgstr "別の重要な例として、 0.1 が正確には 1/10 でないために、 0.1 を10回足しても正確には 1.0 にならないというものがあります。"

#: ../../tutorial/floatingpoint.rst:128
msgid ""
"Binary floating-point arithmetic holds many surprises like this.  The "
"problem with \"0.1\" is explained in precise detail below, in the "
"\"Representation Error\" section.  See `The Perils of Floating Point "
"<http://www.lahey.com/float.htm>`_ for a more complete account of other "
"common surprises."
msgstr "2 進の浮動小数点数に対する算術演算は、このような意外性をたくさん持っています。 \"0.1\" に関する問題は、以下の \"表現エラー\" の章で詳細に説明します。 2 進法の浮動小数点演算にともなうその他のよく知られた意外な事象に関しては `The Perils of Floating Point <http://www.lahey.com/float.htm>`_ を参照してください。"

#: ../../tutorial/floatingpoint.rst:133
msgid ""
"As that says near the end, \"there are no easy answers.\"  Still, don't be "
"unduly wary of floating-point!  The errors in Python float operations are "
"inherited from the floating-point hardware, and on most machines are on the "
"order of no more than 1 part in 2\\*\\*53 per operation.  That's more than "
"adequate for most tasks, but you do need to keep in mind that it's not "
"decimal arithmetic, and that every float operation can suffer a new rounding"
" error."
msgstr "究極的にいうと、\"容易な答えはありません\"。ですが、浮動小数点数のことを過度に警戒しないでください！ Python の float 型操作におけるエラーは浮動小数点処理ハードウェアから受けついたものであり、ほとんどのマシン上では一つの演算あたり高々 2\\*\\*53 分の 1 です。この誤差はほとんどの作業で充分以上のものですが、浮動小数点演算は 10 進の演算ではなく、浮動小数点の演算を新たに行うと、新たな丸め誤差の影響を受けることを心にとどめておいてください。"

#: ../../tutorial/floatingpoint.rst:140
msgid ""
"While pathological cases do exist, for most casual use of floating-point "
"arithmetic you'll see the result you expect in the end if you simply round "
"the display of your final results to the number of decimal digits you "
"expect.  For fine control over how a float is displayed see the "
":meth:`str.format` method's format specifiers in :ref:`formatstrings`."
msgstr "異常なケースが存在する一方で、普段の浮動小数点演算の利用では、単に最終的な結果の値を必要な 10 進の桁数に丸めて表示するのなら、最終的には期待通りの結果を得ることになるでしょう。 float の表示についてきめ細かな制御をしたければ、 :ref:`formatstrings` にある :meth:`str.format` メソッドのフォーマット仕様を参照してください。"

#: ../../tutorial/floatingpoint.rst:150
msgid "Representation Error"
msgstr "表現エラー"

#: ../../tutorial/floatingpoint.rst:152
msgid ""
"This section explains the \"0.1\" example in detail, and shows how you can "
"perform an exact analysis of cases like this yourself.  Basic familiarity "
"with binary floating-point representation is assumed."
msgstr "この章では、\"0.1\" の例について詳細に説明し、このようなケースに対してどのようにすれば正確な分析を自分で行えるかを示します。ここでは、 2 進法表現の浮動小数点数についての基礎的な知識があるものとして話を進めます。"

#: ../../tutorial/floatingpoint.rst:156
msgid ""
":dfn:`Representation error` refers to the fact that some (most, actually) "
"decimal fractions cannot be represented exactly as binary (base 2) "
"fractions. This is the chief reason why Python (or Perl, C, C++, Java, "
"Fortran, and many others) often won't display the exact decimal number you "
"expect::"
msgstr "表現エラー(:dfn:`Representation error`)は、いくつかの (実際にはほとんどの) 10 進の小数が 2 進法 (基数 2 )の分数として表現できないという事実に関係しています。これは Python (あるいは Perl、 C、 C++、Japa、Fortran 、およびその他多く) が期待通りの正確な 10 進数を表示できない主要な理由です。"

#: ../../tutorial/floatingpoint.rst:164
msgid ""
"Why is that?  1/10 and 2/10 are not exactly representable as a binary "
"fraction. Almost all machines today (July 2010) use IEEE-754 floating point "
"arithmetic, and almost all platforms map Python floats to IEEE-754 \"double "
"precision\".  754 doubles contain 53 bits of precision, so on input the "
"computer strives to convert 0.1 to the closest fraction it can of the form "
"*J*/2**\\ *N* where *J* is an integer containing exactly 53 bits.  Rewriting"
" ::"
msgstr "なぜこうなるのでしょうか？ 1/10 と 2/10 は 2 進法の小数で厳密に表現することができません。今日 (2010年7月) のマシンは、ほとんどすべて IEEE-754 浮動小数点演算を使用しており、ほとんどすべてのプラットフォームでは Python の浮動小数点を IEEE-754 における \"倍精度(double precision)\" に対応付けます。754 の double には 53 ビットの精度を持つ数が入るので、計算機に入力を行おうとすると、可能な限り 0.1 を最も近い値の分数に変換し、 *J*/2**\\ *N* の形式にしようと努力します。 *J* はちょうど 53 ビットの精度の整数です。"

#: ../../tutorial/floatingpoint.rst:173
msgid "as ::"
msgstr "を書き直すと ::"

#: ../../tutorial/floatingpoint.rst:177
msgid ""
"and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< "
"2**53``), the best value for *N* is 56::"
msgstr "となります。 *J* は厳密に 53 ビットの精度を持っている (``>= 2**52`` だが ``< 2**53`` ) ことを思い出すと、 *N* として最適な値は 56 になります::"

#: ../../tutorial/floatingpoint.rst:187
msgid ""
"That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits. "
"The best possible value for *J* is then that quotient rounded::"
msgstr "すなわち、56 は *J* をちょうど 53 ビットの精度のままに保つ *N* の唯一の値です。 *J* の取りえる値はその商を丸めたものです。"

#: ../../tutorial/floatingpoint.rst:194
msgid ""
"Since the remainder is more than half of 10, the best approximation is "
"obtained by rounding up::"
msgstr "残りは 10 の半分以上なので、最良の近似は丸め値を一つ増やした (round up) ものになります::"

#: ../../tutorial/floatingpoint.rst:200
msgid ""
"Therefore the best possible approximation to 1/10 in 754 double precision is"
" that over 2\\*\\*56, or ::"
msgstr "従って、754 倍精度における 1/10 の取りえる最良の近似は 2\\*\\*56 以上の値、もしくは"

#: ../../tutorial/floatingpoint.rst:205
msgid ""
"Note that since we rounded up, this is actually a little bit larger than "
"1/10; if we had not rounded up, the quotient would have been a little bit "
"smaller than 1/10.  But in no case can it be *exactly* 1/10!"
msgstr "となります。丸め値を 1 増やしたので、この値は実際には 1/10 より少し小さいことに注意してください; 丸め値を 1 増やさない場合、商は 1/10 よりもわずかに小さくなります。しかし、どちらにしろ *厳密に* 1/10 ではありません！"

#: ../../tutorial/floatingpoint.rst:209
msgid ""
"So the computer never \"sees\" 1/10:  what it sees is the exact fraction "
"given above, the best 754 double approximation it can get::"
msgstr "つまり、計算機は 1/10 を \"理解する\" ことは決してありません。計算機が理解できるのは、上記のような厳密な分数であり、 754 の倍精度浮動小数点数で得られるもっともよい近似は以下になります::"

#: ../../tutorial/floatingpoint.rst:215
msgid ""
"If we multiply that fraction by 10\\*\\*30, we can see the (truncated) value"
" of its 30 most significant decimal digits::"
msgstr "この分数に 10\\*\\*30 を掛ければ、有効数字 30 桁の十進数の (切り詰められた) 値を見ることができます。"

#: ../../tutorial/floatingpoint.rst:221
msgid ""
"meaning that the exact number stored in the computer is approximately equal "
"to the decimal value 0.100000000000000005551115123125.  In versions prior to"
" Python 2.7 and Python 3.1, Python rounded this value to 17 significant "
"digits, giving '0.10000000000000001'.  In current versions, Python displays "
"a value based on the shortest decimal fraction that rounds correctly back to"
" the true binary value, resulting simply in '0.1'."
msgstr "これは、計算機が記憶している正確な数値が、10 進数値 0.100000000000000005551115123125 にほぼ等しいということです。 Python 2.7 と Python 3.1 より前のバージョンでは、 Python はこの値を小数点以下 17桁に丸めて '0.10000000000000001' になっていました。現在のバージョンの Python は、元の2進数に正確に戻すことのできる最小の桁数の小数を表示するので、結果は '0.1' になります。"
