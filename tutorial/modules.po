# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-30 14:59+0000\n"
"PO-Revision-Date: 2022-11-05 17:23+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../tutorial/modules.rst:5
msgid "Modules"
msgstr "モジュール"

#: ../../tutorial/modules.rst:7
msgid ""
"If you quit from the Python interpreter and enter it again, the definitions "
"you have made (functions and variables) are lost. Therefore, if you want to "
"write a somewhat longer program, you are better off using a text editor to "
"prepare the input for the interpreter and running it with that file as input "
"instead.  This is known as creating a *script*.  As your program gets "
"longer, you may want to split it into several files for easier maintenance.  "
"You may also want to use a handy function that you've written in several "
"programs without copying its definition into each program."
msgstr ""
"Python インタプリタを終了させ、再び起動すると、これまでに行ってきた定義 (関数"
"や変数) は失われています。ですから、より長いプログラムを書きたいなら、テキス"
"トエディタを使ってインタプリタへの入力を用意しておき、手作業の代わりにファイ"
"ルを入力に使って動作させるとよいでしょう。この作業を *スクリプト (script)* の"
"作成と言います。プログラムが長くなるにつれ、メンテナンスを楽にするために、ス"
"クリプトをいくつかのファイルに分割したくなるかもしれません。また、いくつかの"
"プログラムで書いてきた便利な関数について、その定義をコピーすることなく個々の"
"プログラムで使いたいと思うかもしれません。"

#: ../../tutorial/modules.rst:16
msgid ""
"To support this, Python has a way to put definitions in a file and use them "
"in a script or in an interactive instance of the interpreter. Such a file is "
"called a *module*; definitions from a module can be *imported* into other "
"modules or into the *main* module (the collection of variables that you have "
"access to in a script executed at the top level and in calculator mode)."
msgstr ""
"こういった要求をサポートするために、Python では定義をファイルに書いておき、ス"
"クリプトの中やインタプリタの対話インスタンス上で使う方法があります。このファ"
"イルを *モジュール (module)* と呼びます。モジュールにある定義は、他のモジュー"
"ルや *main* モジュール (実行のトップレベルや電卓モードでアクセスできる変数の"
"集まりを指します) に *import* (取り込み) することができます。"

#: ../../tutorial/modules.rst:22
msgid ""
"A module is a file containing Python definitions and statements.  The file "
"name is the module name with the suffix :file:`.py` appended.  Within a "
"module, the module's name (as a string) is available as the value of the "
"global variable ``__name__``.  For instance, use your favorite text editor "
"to create a file called :file:`fibo.py` in the current directory with the "
"following contents::"
msgstr ""
"モジュールは Python の定義や文が入ったファイルです。ファイル名はモジュール名"
"に接尾語 :file:`.py` がついたものになります。モジュールの中では、(文字列の) "
"モジュール名をグローバル変数 ``__name__`` で取得できます。例えば、お気に入り"
"のテキストエディタを使って、現在のディレクトリに以下の内容のファイル :file:"
"`fibo.py` を作成してみましょう::"

#: ../../tutorial/modules.rst:45
msgid ""
"Now enter the Python interpreter and import this module with the following "
"command::"
msgstr ""
"次に Python インタプリタに入り、モジュールを以下のコマンドで import しましょ"
"う::"

#: ../../tutorial/modules.rst:50
msgid ""
"This does not add the names of the functions defined in ``fibo``  directly "
"to the current :term:`namespace` (see :ref:`tut-scopes` for more details); "
"it only adds the module name ``fibo`` there. Using the module name you can "
"access the functions::"
msgstr ""
"この操作では、``fibo`` で定義された関数の名前を直接現在の :term:`namespace` "
"(詳細は :ref:`tut-scopes` を参照してください)に追加することはありません。単に"
"モジュール名 ``fibo`` だけを名前空間に追加します。関数にはモジュール名を使っ"
"てアクセスします::"

#: ../../tutorial/modules.rst:62
msgid ""
"If you intend to use a function often you can assign it to a local name::"
msgstr "関数を度々使うのなら、ローカルな名前に代入できます::"

#: ../../tutorial/modules.rst:72
msgid "More on Modules"
msgstr "モジュールについてもうすこし"

#: ../../tutorial/modules.rst:74
msgid ""
"A module can contain executable statements as well as function definitions. "
"These statements are intended to initialize the module. They are executed "
"only the *first* time the module name is encountered in an import statement. "
"[#]_ (They are also run if the file is executed as a script.)"
msgstr ""
"モジュールには、関数定義に加えて実行文を入れることができます。これらの実行文"
"はモジュールを初期化するためのものです。これらの実行文は、インポート文の中で "
"*最初に* モジュール名が見つかったときにだけ実行されます。[#]_ (ファイルがスク"
"リプトとして実行される場合も実行されます。)"

#: ../../tutorial/modules.rst:79
msgid ""
"Each module has its own private namespace, which is used as the global "
"namespace by all functions defined in the module. Thus, the author of a "
"module can use global variables in the module without worrying about "
"accidental clashes with a user's global variables. On the other hand, if you "
"know what you are doing you can touch a module's global variables with the "
"same notation used to refer to its functions, ``modname.itemname``."
msgstr ""
"各々のモジュールは、自分のプライベートな名前空間を持っていて、モジュールで定"
"義されている関数はこのテーブルをグローバルな名前空間として使います。したがっ"
"て、モジュールの作者は、ユーザのグローバル変数と偶然的な衝突が起こる心配をせ"
"ずに、グローバルな変数をモジュールで使うことができます。一方、自分が行ってい"
"る操作をきちんと理解していれば、モジュール内の関数を参照するのと同じ表記法 "
"``modname.itemname`` で、モジュールのグローバル変数をいじることもできます。"

#: ../../tutorial/modules.rst:86
msgid ""
"Modules can import other modules.  It is customary but not required to place "
"all :keyword:`import` statements at the beginning of a module (or script, "
"for that matter).  The imported module names, if placed at the top level of "
"a module (outside any functions or classes), are added to the module's "
"global namespace."
msgstr ""
"モジュールは他のモジュールをインポートできます。 :keyword:`import` 文はモ"
"ジュール（さらに言えばスクリプトでも）の先頭に置きますが、これは慣習であって"
"必須ではありません。インポートされたモジュール名は、モジュールのトップレベル"
"（関数やクラスの外）に書いてあれば、モジュールのグローバルな名前空間に置かれ"
"ます。"

#: ../../tutorial/modules.rst:91
msgid ""
"There is a variant of the :keyword:`import` statement that imports names "
"from a module directly into the importing module's namespace.  For example::"
msgstr ""
":keyword:`import` 文には、あるモジュール内の名前を、import を実行しているモ"
"ジュールの名前空間内に直接取り込むという変型があります。例えば::"

#: ../../tutorial/modules.rst:98
msgid ""
"This does not introduce the module name from which the imports are taken in "
"the local namespace (so in the example, ``fibo`` is not defined)."
msgstr ""
"この操作は、import の対象となるモジュール名をローカルな名前空間内に取り入れる"
"ことはありません (従って上の例では、 ``fibo`` は定義されません)。"

#: ../../tutorial/modules.rst:101
msgid "There is even a variant to import all names that a module defines::"
msgstr "モジュールで定義されている名前を全て import するという変型もあります::"

#: ../../tutorial/modules.rst:107
msgid ""
"This imports all names except those beginning with an underscore (``_``). In "
"most cases Python programmers do not use this facility since it introduces "
"an unknown set of names into the interpreter, possibly hiding some things "
"you have already defined."
msgstr ""
"この書き方ではアンダースコア (``_``) で始まるものを除いてすべての名前をイン"
"ポートします。殆どの場面で、Python プログラマーはこの書き方を使いません。未知"
"の名前がインタープリターに読み込まれ、定義済みの名前を上書きしてしまう可能性"
"があるからです。"

#: ../../tutorial/modules.rst:112
msgid ""
"Note that in general the practice of importing ``*`` from a module or "
"package is frowned upon, since it often causes poorly readable code. "
"However, it is okay to use it to save typing in interactive sessions."
msgstr ""
"一般的には、モジュールやパッケージから ``*`` を import するというやり方には賛"
"同できません。というのは、この操作を行うとしばしば可読性に乏しいコードになる"
"からです。しかし、対話セッションでキータイプの量を減らすために使うのは構わな"
"いでしょう。"

#: ../../tutorial/modules.rst:116
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"モジュール名の後に :keyword:`!as` が続いていた場合は、 :keyword:`!as` の後ろ"
"の名前を直接、インポートされたモジュールが束縛します。"

#: ../../tutorial/modules.rst:125
msgid ""
"This is effectively importing the module in the same way that ``import "
"fibo`` will do, with the only difference of it being available as ``fib``."
msgstr ""
"これは実質的には ``import fibo`` と同じ方法でモジュールをインポートしていて、"
"唯一の違いはインポートしたモジュールが ``fib`` という名前で取り扱えるように"
"なっていることです。"

#: ../../tutorial/modules.rst:128
msgid ""
"It can also be used when utilising :keyword:`from` with similar effects::"
msgstr ""
"このインポート方法は :keyword:`from` が付いていても使え、同じ効果が得られま"
"す::"

#: ../../tutorial/modules.rst:137
msgid ""
"For efficiency reasons, each module is only imported once per interpreter "
"session.  Therefore, if you change your modules, you must restart the "
"interpreter -- or, if it's just one module you want to test interactively, "
"use :func:`importlib.reload`, e.g. ``import importlib; importlib."
"reload(modulename)``."
msgstr ""
"実行効率上の理由で、各モジュールはインタープリタの 1 セッションごとに 1 回だ"
"け import されます。従って、モジュールを修正した場合には、インタープリタを再"
"起動させなければなりません -- もしくは、その場で手直ししてテストしたいモ"
"ジュールが 1 つだった場合には、例えば ``import importlib; importlib."
"reload(modulename)`` のように :func:`importlib.reload` を使ってください。"

#: ../../tutorial/modules.rst:147
msgid "Executing modules as scripts"
msgstr "モジュールをスクリプトとして実行する"

#: ../../tutorial/modules.rst:149
msgid "When you run a Python module with ::"
msgstr "Python モジュールを ::"

#: ../../tutorial/modules.rst:153
msgid ""
"the code in the module will be executed, just as if you imported it, but "
"with the ``__name__`` set to ``\"__main__\"``.  That means that by adding "
"this code at the end of your module::"
msgstr ""
"と実行すると、``__name__`` に ``__main__`` が設定されている点を除いて import "
"したときと同じようにモジュール内のコードが実行されます。つまりモジュールの末"
"尾に::"

#: ../../tutorial/modules.rst:161
msgid ""
"you can make the file usable as a script as well as an importable module, "
"because the code that parses the command line only runs if the module is "
"executed as the \"main\" file:"
msgstr ""
"このコードを追加することで、このファイルが import できるモジュールであると同"
"時にスクリプトとしても使えるようになります。なぜならモジュールが \"main\" "
"ファイルとして起動されたときだけ、コマンドラインを解釈するコードが実行される"
"からです:"

#: ../../tutorial/modules.rst:170
msgid "If the module is imported, the code is not run::"
msgstr "モジュールが import された場合は、そのコードは実行されません::"

#: ../../tutorial/modules.rst:175
msgid ""
"This is often used either to provide a convenient user interface to a "
"module, or for testing purposes (running the module as a script executes a "
"test suite)."
msgstr ""
"この方法はモジュールに便利なユーザインターフェースを提供したり、テストのため"
"に (スクリプトをモジュールとして起動しテストスイートを実行して) 使われます。"

#: ../../tutorial/modules.rst:182
msgid "The Module Search Path"
msgstr "モジュール検索パス"

#: ../../tutorial/modules.rst:186
msgid ""
"When a module named :mod:`spam` is imported, the interpreter first searches "
"for a built-in module with that name. These module names are listed in :data:"
"`sys.builtin_module_names`. If not found, it then searches for a file named :"
"file:`spam.py` in a list of directories given by the variable :data:`sys."
"path`.  :data:`sys.path` is initialized from these locations:"
msgstr ""
":mod:`spam` という名前のモジュールをインポートするとき、インタープリターはま"
"ずその名前の組み込みモジュールを探します。モジュール名の一覧は :data:`sys."
"builtin_module_names` にあります。見つからなかった場合は、 :file:`spam.py` と"
"いう名前のファイルを :data:`sys.path` にあるディレクトリのリストから探しま"
"す。 :data:`sys.path` は以下の場所に初期化されます:"

#: ../../tutorial/modules.rst:192
msgid ""
"The directory containing the input script (or the current directory when no "
"file is specified)."
msgstr ""
"入力されたスクリプトのあるディレクトリ (あるいはファイルが指定されなかったと"
"きはカレントディレクトリ)。"

#: ../../tutorial/modules.rst:194
msgid ""
":envvar:`PYTHONPATH` (a list of directory names, with the same syntax as the "
"shell variable :envvar:`PATH`)."
msgstr ""
":envvar:`PYTHONPATH` (ディレクトリ名のリスト。シェル変数の :envvar:`PATH` と"
"同じ構文)。"

#: ../../tutorial/modules.rst:196
msgid ""
"The installation-dependent default (by convention including a ``site-"
"packages`` directory, handled by the :mod:`site` module)."
msgstr ""
"インストール方法に依存したデフォルト（慣例として ``site-packages`` ディレクト"
"リーが含まれ、:mod:`site` モジュールによって処理される）。"

#: ../../tutorial/modules.rst:200
msgid ""
"On file systems which support symlinks, the directory containing the input "
"script is calculated after the symlink is followed. In other words the "
"directory containing the symlink is **not** added to the module search path."
msgstr ""
"シンボリックリンクをサポートするファイルシステム上では、入力されたスクリプト"
"のあるディレクトリはシンボリックリンクをたどった後に計算されます。言い換える"
"とシンボリックリンクを含むディレクトリはモジュール検索パスに追加 **されません"
"**。"

#: ../../tutorial/modules.rst:204
msgid ""
"After initialization, Python programs can modify :data:`sys.path`.  The "
"directory containing the script being run is placed at the beginning of the "
"search path, ahead of the standard library path. This means that scripts in "
"that directory will be loaded instead of modules of the same name in the "
"library directory. This is an error unless the replacement is intended.  See "
"section :ref:`tut-standardmodules` for more information."
msgstr ""
"初期化された後、 Python プログラムは :data:`sys.path` を修正することができま"
"す。スクリプトファイルを含むディレクトリが検索パスの先頭、標準ライブラリパス"
"よりも前に追加されます。なので、ライブラリのディレクトリにあるファイルより"
"も、そのディレクトリにある同じ名前のスクリプトが優先してインポートされます。"
"これは、標準ライブラリを意図して置き換えているのでない限りは間違いのもとで"
"す。より詳しい情報は :ref:`tut-standardmodules` を参照してください。"

#: ../../tutorial/modules.rst:215
msgid "\"Compiled\" Python files"
msgstr "\"コンパイル\" された Python ファイル"

#: ../../tutorial/modules.rst:217
msgid ""
"To speed up loading modules, Python caches the compiled version of each "
"module in the ``__pycache__`` directory under the name :file:`module."
"{version}.pyc`, where the version encodes the format of the compiled file; "
"it generally contains the Python version number.  For example, in CPython "
"release 3.3 the compiled version of spam.py would be cached as ``__pycache__/"
"spam.cpython-33.pyc``.  This naming convention allows compiled modules from "
"different releases and different versions of Python to coexist."
msgstr ""
"モジュールの読み込みを高速化するため、Python はコンパイル済みの各モジュール"
"を ``__pycache__`` ディレクトリの :file:`module.{version}.pyc` ファイルとして"
"キャッシュします。ここで version はコンパイルされたファイルのフォーマットを表"
"すもので、一般的には Python のバージョン番号です。例えば、CPython のリリース "
"3.3 の、コンパイル済みの spam.py は ``__pycache__/spam.cpython-33.pyc`` とし"
"てキャッシュされるでしょう。この命名の慣習により、Python の異なる複数のリリー"
"スやバージョンのコンパイル済みモジュールが共存できます。"

#: ../../tutorial/modules.rst:225
msgid ""
"Python checks the modification date of the source against the compiled "
"version to see if it's out of date and needs to be recompiled.  This is a "
"completely automatic process.  Also, the compiled modules are platform-"
"independent, so the same library can be shared among systems with different "
"architectures."
msgstr ""
"Python はソースの変更日時をコンパイル済みのものと比較し、コンパイル済みのもの"
"が最新でなくなり再コンパイルが必要になっていないかを確認します。これは完全に"
"自動で処理されます。また、コンパイル済みモジュールはプラットフォーム非依存な"
"ため、アーキテクチャの異なるシステム間で同一のライブラリを共有することもでき"
"ます。"

#: ../../tutorial/modules.rst:230
msgid ""
"Python does not check the cache in two circumstances.  First, it always "
"recompiles and does not store the result for the module that's loaded "
"directly from the command line.  Second, it does not check the cache if "
"there is no source module.  To support a non-source (compiled only) "
"distribution, the compiled module must be in the source directory, and there "
"must not be a source module."
msgstr ""
"Python は2つの場合にキャッシュのチェックを行いません。ひとつは、コマンドライ"
"ンから直接モジュールが読み込まれた場合で、常に再コンパイルされ、結果を保存す"
"ることはありません。2つめは、ソース・モジュールのない場合で、キャッシュの確認"
"を行いません。ソースのない (コンパイル済みのもののみの) 配布をサポートするに"
"は、コンパイル済みモジュールはソース・ディレクトリになくてはならず、ソース・"
"ディレクトリにソース・モジュールがあってはいけません。"

#: ../../tutorial/modules.rst:237
msgid "Some tips for experts:"
msgstr "エキスパート向けのTips:"

#: ../../tutorial/modules.rst:239
msgid ""
"You can use the :option:`-O` or :option:`-OO` switches on the Python command "
"to reduce the size of a compiled module.  The ``-O`` switch removes assert "
"statements, the ``-OO`` switch removes both assert statements and __doc__ "
"strings.  Since some programs may rely on having these available, you should "
"only use this option if you know what you're doing.  \"Optimized\" modules "
"have an ``opt-`` tag and are usually smaller.  Future releases may change "
"the effects of optimization."
msgstr ""
"コンパイル済みモジュールのサイズを小さくするために、Python コマンドに :"
"option:`-O` または :option:`-OO` スイッチを使うことができます。``-O`` スイッ"
"チは assert ステートメントを除去し、``-OO`` スイッチは assert ステートメント"
"と __doc__ 文字列を除去します。いくつかのプログラムはこれらの除去されるものに"
"依存している可能性があるため、自分が何をしているかを理解しているときに限って"
"これらのオプションを使うべきです。\"最適化\" されたモジュールは ``opt-`` タグ"
"を持ち、通常のコンパイル済みモジュールよりサイズが小さくなります。将来のリ"
"リースでは最適化の影響が変わる可能性があります。"

#: ../../tutorial/modules.rst:247
msgid ""
"A program doesn't run any faster when it is read from a ``.pyc`` file than "
"when it is read from a ``.py`` file; the only thing that's faster about ``."
"pyc`` files is the speed with which they are loaded."
msgstr ""
"``.pyc`` ファイルや ``.pyo`` ファイルから読み出されたとしても、プログラムは "
"``.py`` ファイルから読み出されたときより何ら高速に動作するわけではありませ"
"ん。``.pyc`` ファイルで高速化されるのは、読み込みにかかる時間だけです。"

#: ../../tutorial/modules.rst:251
msgid ""
"The module :mod:`compileall` can create .pyc files for all modules in a "
"directory."
msgstr ""
":mod:`compileall` モジュールを使ってディレクトリ内の全てのモジュールに対し"
"て .pyc ファイルを作ることができます。"

#: ../../tutorial/modules.rst:254
msgid ""
"There is more detail on this process, including a flow chart of the "
"decisions, in :pep:`3147`."
msgstr ""
"この処理に関する詳細は、判定のフローチャートを含めて、:pep:`3147` に記載され"
"ています。"

#: ../../tutorial/modules.rst:261
msgid "Standard Modules"
msgstr "標準モジュール"

#: ../../tutorial/modules.rst:265
msgid ""
"Python comes with a library of standard modules, described in a separate "
"document, the Python Library Reference (\"Library Reference\" hereafter).  "
"Some modules are built into the interpreter; these provide access to "
"operations that are not part of the core of the language but are "
"nevertheless built in, either for efficiency or to provide access to "
"operating system primitives such as system calls.  The set of such modules "
"is a configuration option which also depends on the underlying platform.  "
"For example, the :mod:`winreg` module is only provided on Windows systems. "
"One particular module deserves some attention: :mod:`sys`, which is built "
"into every Python interpreter.  The variables ``sys.ps1`` and ``sys.ps2`` "
"define the strings used as primary and secondary prompts::"
msgstr ""
"Python は標準モジュールライブラリを同梱していて、別の Python ライブラリリファ"
"レンスというドキュメントで解説しています。幾つかのモジュールは言語のコアには"
"アクセスしないものの、効率や、システムコールなどOSの機能を利用するために、イ"
"ンタープリター内部にビルトインされています。そういったモジュールセットはまた"
"プラットフォームに依存した構成オプションです。例えば、 :mod:`winreg` モジュー"
"ルは Windows システムでのみ提供されています。 1つ注目に値するモジュールとし"
"て、 :mod:`sys` モジュールは、全ての Python インタープリターにビルトインされ"
"ています。 ``sys.ps1`` と ``sys.ps2`` という変数は一次プロンプトと二次プロン"
"プトに表示する文字列を定義しています::"

#: ../../tutorial/modules.rst:288
msgid ""
"These two variables are only defined if the interpreter is in interactive "
"mode."
msgstr ""
"これらの二つの変数は、インタプリタが対話モードにあるときだけ定義されていま"
"す。"

#: ../../tutorial/modules.rst:290
msgid ""
"The variable ``sys.path`` is a list of strings that determines the "
"interpreter's search path for modules. It is initialized to a default path "
"taken from the environment variable :envvar:`PYTHONPATH`, or from a built-in "
"default if :envvar:`PYTHONPATH` is not set.  You can modify it using "
"standard list operations::"
msgstr ""
"変数 ``sys.path`` は文字列からなるリストで、インタプリタがモジュールを検索す"
"るときのパスを決定します。 ``sys.path`` は環境変数 :envvar:`PYTHONPATH` から"
"得たデフォルトパスに、 :envvar:`PYTHONPATH` が設定されていなければ組み込みの"
"デフォルト値に設定されます。標準的なリスト操作で変更することができます::"

#: ../../tutorial/modules.rst:303
msgid "The :func:`dir` Function"
msgstr ":func:`dir` 関数"

#: ../../tutorial/modules.rst:305
msgid ""
"The built-in function :func:`dir` is used to find out which names a module "
"defines.  It returns a sorted list of strings::"
msgstr ""
"組込み関数 :func:`dir` は、あるモジュールがどんな名前を定義しているか調べるた"
"めに使われます。 :func:`dir` はソートされた文字列のリストを返します::"

#: ../../tutorial/modules.rst:334
msgid ""
"Without arguments, :func:`dir` lists the names you have defined currently::"
msgstr "引数がなければ、 :func:`dir` は現在定義している名前を列挙します::"

#: ../../tutorial/modules.rst:342
msgid ""
"Note that it lists all types of names: variables, modules, functions, etc."
msgstr ""
"変数、モジュール、関数、その他の、すべての種類の名前をリストすることに注意し"
"てください。"

#: ../../tutorial/modules.rst:346
msgid ""
":func:`dir` does not list the names of built-in functions and variables.  If "
"you want a list of those, they are defined in the standard module :mod:"
"`builtins`::"
msgstr ""
":func:`dir` は、組込みの関数や変数の名前はリストしません。これらの名前からな"
"るリストが必要なら、標準モジュール :mod:`builtins` で定義されています::"

#: ../../tutorial/modules.rst:385
msgid "Packages"
msgstr "パッケージ"

#: ../../tutorial/modules.rst:387
msgid ""
"Packages are a way of structuring Python's module namespace by using "
"\"dotted module names\".  For example, the module name :mod:`A.B` designates "
"a submodule named ``B`` in a package named ``A``.  Just like the use of "
"modules saves the authors of different modules from having to worry about "
"each other's global variable names, the use of dotted module names saves the "
"authors of multi-module packages like NumPy or Pillow from having to worry "
"about each other's module names."
msgstr ""
"パッケージ (package) は、Python のモジュール名前空間を \"ドット付きモジュール"
"名\" を使って構造化する手段です。例えば、モジュール名 :mod:`A.B` は、 ``A`` "
"というパッケージのサブモジュール ``B`` を表します。ちょうど、モジュールを利用"
"すると、別々のモジュールの著者が互いのグローバル変数名について心配しなくても"
"済むようになるのと同じように、ドット付きモジュール名を利用すると、 NumPy や "
"Pillow のように複数モジュールからなるパッケージの著者が、互いのモジュール名に"
"ついて心配しなくても済むようになります。"

#: ../../tutorial/modules.rst:395
msgid ""
"Suppose you want to design a collection of modules (a \"package\") for the "
"uniform handling of sound files and sound data.  There are many different "
"sound file formats (usually recognized by their extension, for example: :"
"file:`.wav`, :file:`.aiff`, :file:`.au`), so you may need to create and "
"maintain a growing collection of modules for the conversion between the "
"various file formats. There are also many different operations you might "
"want to perform on sound data (such as mixing, adding echo, applying an "
"equalizer function, creating an artificial stereo effect), so in addition "
"you will be writing a never-ending stream of modules to perform these "
"operations.  Here's a possible structure for your package (expressed in "
"terms of a hierarchical filesystem):"
msgstr ""
"音声ファイルや音声データを一様に扱うためのモジュールのコレクション (\"パッ"
"ケージ\") を設計したいと仮定しましょう。 音声ファイルには多くの異なった形式が"
"ある (通常は拡張子、 例えば :file:`.wav`, :file:`.aiff`, :file:`.au` などで認"
"識されます) ので、増え続ける様々なファイル形式を相互変換するモジュールを、 作"
"成したりメンテナンスしたりする必要があるかもしれません。 また、 音声データに"
"対して実行したい様々な独自の操作 (ミキシング、 エコーの追加、 イコライザ関数"
"の適用、 人工的なステレオ効果の作成など) があるかもしれません。 そうなると、 "
"こうした操作を実行するモジュールを果てしなく書くことになるでしょう。 以下に "
"(階層的なファイルシステムで表現した) パッケージの構造案を示します:"

#: ../../tutorial/modules.rst:432
msgid ""
"When importing the package, Python searches through the directories on ``sys."
"path`` looking for the package subdirectory."
msgstr ""
"パッケージを import する際、 Python は ``sys.path`` 上のディレクトリを検索し"
"て、トップレベルのパッケージの入ったサブディレクトリを探します。"

#: ../../tutorial/modules.rst:435
msgid ""
"The :file:`__init__.py` files are required to make Python treat directories "
"containing the file as packages.  This prevents directories with a common "
"name, such as ``string``, unintentionally hiding valid modules that occur "
"later on the module search path. In the simplest case, :file:`__init__.py` "
"can just be an empty file, but it can also execute initialization code for "
"the package or set the ``__all__`` variable, described later."
msgstr ""
"ファイルを含むディレクトリをパッケージとしてPython に扱わせるには、ファイル :"
"file:`__init__.py` が必要です。\n"
"これにより、 ``string`` のようなよくある名前のディレクトリにより、モジュール"
"検索パスの後の方で見つかる正しいモジュールが意図せず隠蔽されてしまうのを防ぐ"
"ためです。\n"
"最も簡単なケースでは :file:`__init__.py` はただの空ファイルで構いませんが、 :"
"file:`__init__.py` ではパッケージのための初期化コードを実行したり、後述の "
"``__all__`` 変数を設定してもかまいません。"

#: ../../tutorial/modules.rst:442
msgid ""
"Users of the package can import individual modules from the package, for "
"example::"
msgstr ""
"パッケージのユーザは、個々のモジュールをパッケージから import することができ"
"ます。例えば::"

#: ../../tutorial/modules.rst:447
msgid ""
"This loads the submodule :mod:`sound.effects.echo`.  It must be referenced "
"with its full name. ::"
msgstr ""
"この操作はサブモジュール :mod:`sound.effects.echo` をロードします。このモ"
"ジュールは、以下のように完全な名前で参照しなければなりません。 ::"

#: ../../tutorial/modules.rst:452
msgid "An alternative way of importing the submodule is::"
msgstr "サブモジュールを import するもう一つの方法を示します::"

#: ../../tutorial/modules.rst:456
msgid ""
"This also loads the submodule :mod:`echo`, and makes it available without "
"its package prefix, so it can be used as follows::"
msgstr ""
"これもサブモジュール :mod:`echo` をロードし、 :mod:`echo` をパッケージ名を表"
"す接頭辞なしで利用できるようにします。従って以下のように用いることができま"
"す::"

#: ../../tutorial/modules.rst:461
msgid ""
"Yet another variation is to import the desired function or variable "
"directly::"
msgstr ""
"さらにもう一つのバリエーションとして、必要な関数や変数を直接 import する方法"
"があります::"

#: ../../tutorial/modules.rst:465
msgid ""
"Again, this loads the submodule :mod:`echo`, but this makes its function :"
"func:`echofilter` directly available::"
msgstr ""
"この操作も同様にサブモジュール :mod:`echo` をロードしますが、 :func:"
"`echofilter` を直接利用できるようにします::"

#: ../../tutorial/modules.rst:470
msgid ""
"Note that when using ``from package import item``, the item can be either a "
"submodule (or subpackage) of the package, or some  other name defined in the "
"package, like a function, class or variable.  The ``import`` statement first "
"tests whether the item is defined in the package; if not, it assumes it is a "
"module and attempts to load it.  If it fails to find it, an :exc:"
"`ImportError` exception is raised."
msgstr ""
"``from package import item`` を使う場合、 *item* はパッケージ *package* のサ"
"ブモジュール (またはサブパッケージ) でもかまいませんし、関数やクラス、変数の"
"ような、 *package* で定義されている別の名前でもかまわないことに注意してくださ"
"い。 ``import`` 文はまず、 *item* がパッケージ内で定義されているかどうか調べ"
"ます。定義されていなければ、 *item* はモジュール名であると仮定して、モジュー"
"ルをロードしようと試みます。もしモジュールが見つからなければ、 :exc:"
"`ImportError` が送出されます。"

#: ../../tutorial/modules.rst:477
msgid ""
"Contrarily, when using syntax like ``import item.subitem.subsubitem``, each "
"item except for the last must be a package; the last item can be a module or "
"a package but can't be a class or function or variable defined in the "
"previous item."
msgstr ""
"反対に、 ``import item.subitem.subsubitem`` のような構文を使った場合、最後の "
"``subsubitem`` を除く各要素はパッケージでなければなりません。最後の要素はモ"
"ジュールかパッケージにできますが、一つ前の要素で定義されているクラスや関数や"
"変数にはできません。"

#: ../../tutorial/modules.rst:486
msgid "Importing \\* From a Package"
msgstr "パッケージから \\* を import する"

#: ../../tutorial/modules.rst:490
msgid ""
"Now what happens when the user writes ``from sound.effects import *``?  "
"Ideally, one would hope that this somehow goes out to the filesystem, finds "
"which submodules are present in the package, and imports them all.  This "
"could take a long time and importing sub-modules might have unwanted side-"
"effects that should only happen when the sub-module is explicitly imported."
msgstr ""
"それでは、ユーザが ``from sound.effects import *`` と書いたら、どうなるので"
"しょうか？理想的には、何らかの方法でファイルシステムが調べられ、そのパッケー"
"ジにどんなサブモジュールがあるかを調べ上げ、全てを import する、という処理を"
"望むことでしょう。これには長い時間がかかってしまうこともありますし、あるサブ"
"モジュールを import することで、そのモジュールが明示的に import されたときの"
"み発生して欲しい副作用が起きてしまうかもしれません。"

#: ../../tutorial/modules.rst:496
msgid ""
"The only solution is for the package author to provide an explicit index of "
"the package.  The :keyword:`import` statement uses the following convention: "
"if a package's :file:`__init__.py` code defines a list named ``__all__``, it "
"is taken to be the list of module names that should be imported when ``from "
"package import *`` is encountered.  It is up to the package author to keep "
"this list up-to-date when a new version of the package is released.  Package "
"authors may also decide not to support it, if they don't see a use for "
"importing \\* from their package.  For example, the file :file:`sound/"
"effects/__init__.py` could contain the following code::"
msgstr ""
"唯一の解決策は、パッケージの作者にパッケージの索引を明示的に提供させる という"
"ものです。 :keyword:`import` 文の使う規約は、パッケージの :file:`__init__."
"py` コードに ``__all__`` という名前のリストが定義されていれば、 ``from "
"package import *`` が現れたときに import すべきモジュール名のリストとして使"
"う、というものです。 パッケージの新バージョンがリリースされるときにリストを最"
"新の状態に更新するのは パッケージの作者の責任となります。 自分のパッケージか"
"ら \\* を import するという使い方が考えられないならば、 パッケージの作者はこ"
"の使い方をサポートしないことにしてもかまいません。 例えば、ファイル :file:"
"`sound/effects/__init__.py` には、次のような コードを入れてもよいかもしれませ"
"ん::"

#: ../../tutorial/modules.rst:508
msgid ""
"This would mean that ``from sound.effects import *`` would import the three "
"named submodules of the :mod:`sound.effects` package."
msgstr ""
"この例では、 ``from sound.effects import *`` とすると、 :mod:`sound.effects` "
"パッケージから指定された 3つのサブモジュールが import されることになってい"
"る、ということを意味します。"

#: ../../tutorial/modules.rst:511
msgid ""
"If ``__all__`` is not defined, the statement ``from sound.effects import *`` "
"does *not* import all submodules from the package :mod:`sound.effects` into "
"the current namespace; it only ensures that the package :mod:`sound.effects` "
"has been imported (possibly running any initialization code in :file:"
"`__init__.py`) and then imports whatever names are defined in the package.  "
"This includes any names defined (and submodules explicitly loaded) by :file:"
"`__init__.py`.  It also includes any submodules of the package that were "
"explicitly loaded by previous :keyword:`import` statements.  Consider this "
"code::"
msgstr ""
"もしも ``__all__`` が定義されていなければ、実行文 ``from sound.effects "
"import *`` は、パッケージ :mod:`sound.effects` の全てのサブモジュールを現在の"
"名前空間の中へ import *しません* 。この文は単に(場合によっては初期化コード :"
"file:`__init__.py` を実行して) パッケージ :mod:`sound.effects` が import され"
"たということを確認し、そのパッケージで定義されている名前を全て import するだ"
"けです。 import される名前には、 :file:`__init__.py` で定義された名前 (と、明"
"示的にロードされたサブモジュール) が含まれます。パッケージのサブモジュール"
"で、以前の :keyword:`import` 文で明示的にロードされたものも含みます。以下の"
"コードを考えてください::"

#: ../../tutorial/modules.rst:524
msgid ""
"In this example, the :mod:`echo` and :mod:`surround` modules are imported in "
"the current namespace because they are defined in the :mod:`sound.effects` "
"package when the ``from...import`` statement is executed.  (This also works "
"when ``__all__`` is defined.)"
msgstr ""
"上の例では、 :mod:`echo` と :mod:`surround` モジュールが現在の名前空間に "
"import されます。これらのモジュールは ``from...import`` 文が実行された際に :"
"mod:`sound.effects` 内で定義されているからです。 (この機構は ``__all__`` が定"
"義されているときにも働きます。)"

#: ../../tutorial/modules.rst:529
msgid ""
"Although certain modules are designed to export only names that follow "
"certain patterns when you use ``import *``, it is still considered bad "
"practice in production code."
msgstr ""
"特定のモジュールでは ``import *`` を使ったときに、特定のパターンに従った名前"
"のみを公開 (export) するように設計されてはいますが、それでもやはり製品のコー"
"ドでは良いことではないと考えます。"

#: ../../tutorial/modules.rst:533
msgid ""
"Remember, there is nothing wrong with using ``from package import "
"specific_submodule``!  In fact, this is the recommended notation unless the "
"importing module needs to use submodules with the same name from different "
"packages."
msgstr ""
"``from package import specific_submodule`` を使っても何も問題はないことに留意"
"してください！実際この表記法は、import を行うモジュールが他のパッケージと同じ"
"名前を持つサブモジュールを使わなければならない場合を除いて推奨される方式で"
"す。"

#: ../../tutorial/modules.rst:542
msgid "Intra-package References"
msgstr "パッケージ内参照"

#: ../../tutorial/modules.rst:544
msgid ""
"When packages are structured into subpackages (as with the :mod:`sound` "
"package in the example), you can use absolute imports to refer to submodules "
"of siblings packages.  For example, if the module :mod:`sound.filters."
"vocoder` needs to use the :mod:`echo` module in the :mod:`sound.effects` "
"package, it can use ``from sound.effects import echo``."
msgstr ""
"パッケージが (前述の例の :mod:`sound` パッケージのように) サブパッケージの集"
"まりに構造化されている場合、絶対 import を使って兄弟関係にあるパッケージを参"
"照できます。例えば、モジュール :mod:`sound.filters.vocoder` で :mod:`sound."
"effects` パッケージの :mod:`echo` モジュールを使いたいとすると、 ``from "
"sound.effects import echo`` を使うことができます。"

#: ../../tutorial/modules.rst:550
msgid ""
"You can also write relative imports, with the ``from module import name`` "
"form of import statement.  These imports use leading dots to indicate the "
"current and parent packages involved in the relative import.  From the :mod:"
"`surround` module for example, you might use::"
msgstr ""
"また、明示的な相対importを ``from module import name`` の形式の import 文で利"
"用できます。この明示的な相対 import では、先頭のドットで現在および親パッケー"
"ジを指定します。 :mod:`surround` モジュールの例では、以下のように記述できま"
"す::"

#: ../../tutorial/modules.rst:559
msgid ""
"Note that relative imports are based on the name of the current module.  "
"Since the name of the main module is always ``\"__main__\"``, modules "
"intended for use as the main module of a Python application must always use "
"absolute imports."
msgstr ""
"相対 import は現在のモジュール名をベースにすることに注意してください。メイン"
"モジュールの名前は常に ``\"__main__\"`` なので、Python アプリケーションのメイ"
"ンモジュールとして利用されることを意図しているモジュールでは絶対 import を利"
"用するべきです。"

#: ../../tutorial/modules.rst:565
msgid "Packages in Multiple Directories"
msgstr "複数ディレクトリ中のパッケージ"

#: ../../tutorial/modules.rst:567
msgid ""
"Packages support one more special attribute, :attr:`__path__`.  This is "
"initialized to be a list containing the name of the directory holding the "
"package's :file:`__init__.py` before the code in that file is executed.  "
"This variable can be modified; doing so affects future searches for modules "
"and subpackages contained in the package."
msgstr ""
"パッケージはもう一つ特別な属性として :attr:`__path__` をサポートしています。"
"この属性は、パッケージの :file:`__init__.py` 中のコードが実行されるよりも前"
"に、 :file:`__init__.py` の収められているディレクトリ名の入ったリストになるよ"
"う初期化されます。この変数は変更することができます。変更を加えると、以降その"
"パッケージに入っているモジュールやサブパッケージの検索に影響します。"

#: ../../tutorial/modules.rst:573
msgid ""
"While this feature is not often needed, it can be used to extend the set of "
"modules found in a package."
msgstr ""
"この機能はほとんど必要にはならないのですが、パッケージ内存在するモジュール群"
"を拡張するために使うことができます。"

#: ../../tutorial/modules.rst:578
msgid "Footnotes"
msgstr "脚注"

#: ../../tutorial/modules.rst:579
msgid ""
"In fact function definitions are also 'statements' that are 'executed'; the "
"execution of a module-level function definition adds the function name to "
"the module's global namespace."
msgstr ""
"実際には、関数定義も '実行' される '文' です。モジュールレベルの関数定義を実"
"行すると、関数名はモジュールのグローバルな名前空間に追加されます。"
