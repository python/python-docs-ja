# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-05 15:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "ãƒ‡ãƒ¼ã‚¿æ§‹é€ "

#: ../../tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr "ã“ã®ç« ã§ã¯ã€ã™ã§ã«å­¦ã‚“ã ã“ã¨ã«ã¤ã„ã¦ã‚ˆã‚Šè©³ã—ãèª¬æ˜ã™ã‚‹ã¨ã¨ã‚‚ã«ã€ã„ãã¤ã‹æ–°ã—ã„ã“ã¨ã‚’è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:13
msgid "More on Lists"
msgstr "ãƒªã‚¹ãƒˆå‹ã«ã¤ã„ã¦ã‚‚ã†å°‘ã—"

#: ../../tutorial/datastructures.rst:15
msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr "ãƒªã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿å‹ã«ã¯ã€ä»–ã«ã‚‚ã„ãã¤ã‹ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚ãƒªã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™:"

#: ../../tutorial/datastructures.rst:22
msgid ""
"Add an item to the end of the list.  Equivalent to ``a[len(a):] = [x]``."
msgstr "ãƒªã‚¹ãƒˆã®æœ«å°¾ã«è¦ç´ ã‚’ä¸€ã¤è¿½åŠ ã—ã¾ã™ã€‚``a[len(a):] = [x]`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../tutorial/datastructures.rst:28
msgid ""
"Extend the list by appending all the items from the iterable.  Equivalent to"
" ``a[len(a):] = iterable``."
msgstr "ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã®ã™ã¹ã¦ã®è¦ç´ ã‚’å¯¾è±¡ã®ãƒªã‚¹ãƒˆã«è¿½åŠ ã—ã€ãƒªã‚¹ãƒˆã‚’æ‹¡å¼µã—ã¾ã™ã€‚``a[len(a):] = iterable`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../tutorial/datastructures.rst:35
msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"æŒ‡å®šã—ãŸä½ç½®ã«è¦ç´ ã‚’æŒ¿å…¥ã—ã¾ã™ã€‚ç¬¬ 1 å¼•æ•°ã¯ã€ãƒªã‚¹ãƒˆã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã§ã€ãã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã‚’æŒã¤è¦ç´ ã®ç›´å‰ã«æŒ¿å…¥ãŒè¡Œã‚ã‚Œã¾ã™ã€‚å¾“ã£ã¦ã€ "
"``a.insert(0, x)`` ã¯ãƒªã‚¹ãƒˆã®å…ˆé ­ã«æŒ¿å…¥ã‚’è¡Œã„ã¾ã™ã€‚ã¾ãŸ ``a.insert(len(a), x)`` ã¯ "
"``a.append(x)`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../tutorial/datastructures.rst:43
msgid ""
"Remove the first item from the list whose value is *x*.  It is an error if "
"there is no such item."
msgstr "ãƒªã‚¹ãƒˆä¸­ã§ã€å€¤ *x* ã‚’æŒã¤æœ€åˆã®è¦ç´ ã‚’å‰Šé™¤ã—ã¾ã™ã€‚è©²å½“ã™ã‚‹é …ç›®ãŒãªã‘ã‚Œã°ã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:50
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list.  (The square brackets around the *i* in the method signature denote "
"that the parameter is optional, not that you should type square brackets at "
"that position.  You will see this notation frequently in the Python Library "
"Reference.)"
msgstr ""
"ãƒªã‚¹ãƒˆä¸­ã®æŒ‡å®šã•ã‚ŒãŸä½ç½®ã«ã‚ã‚‹è¦ç´ ã‚’ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤ã—ã¦ã€ãã®è¦ç´ ã‚’è¿”ã—ã¾ã™ã€‚ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ãŒæŒ‡å®šã•ã‚Œãªã‘ã‚Œã°ã€ ``a.pop()`` "
"ã¯ãƒªã‚¹ãƒˆã®æœ«å°¾ã®è¦ç´ ã‚’å‰Šé™¤ã—ã¦è¿”ã—ã¾ã™ã€‚ã“ã®å ´åˆã‚‚è¦ç´ ã¯å‰Šé™¤ã•ã‚Œã¾ã™ã€‚ (ãƒ¡ã‚½ãƒƒãƒ‰ã®ç”¨æ³• (signature) ã§ *i* "
"ã®ä¸¡å´ã«ã‚ã‚‹è§’æ‹¬å¼§ã¯ã€ã“ã®å¼•æ•°ãŒã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã‚ã‚‹ã“ã¨ã‚’è¡¨ã—ã¦ã„ã‚‹ã ã‘ãªã®ã§ã€è§’æ‹¬å¼§ã‚’å…¥åŠ›ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®è¡¨è¨˜æ³•ã¯ Python Library"
" Reference ã®ä¸­ã§é »ç¹ã«è¦‹ã‚‹ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚)"

#: ../../tutorial/datastructures.rst:60
msgid "Remove all items from the list.  Equivalent to ``del a[:]``."
msgstr "ãƒªã‚¹ãƒˆä¸­ã®å…¨ã¦ã®è¦ç´ ã‚’å‰Šé™¤ã—ã¾ã™ã€‚``del a[:]`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../tutorial/datastructures.rst:66
msgid ""
"Return zero-based index in the list of the first item whose value is *x*. "
"Raises a :exc:`ValueError` if there is no such item."
msgstr ""
"ãƒªã‚¹ãƒˆä¸­ã§ã€å€¤ *x* ã‚’æŒã¤æœ€åˆã®è¦ç´ ã®ä½ç½®ã‚’ã‚¼ãƒ­ã‹ã‚‰å§‹ã¾ã‚‹æ·»å­—ã§è¿”ã—ã¾ã™ã€‚ è©²å½“ã™ã‚‹è¦ç´ ãŒãªã‘ã‚Œã°ã€:exc:`ValueError` "
"ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:69
msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the"
" list.  The returned index is computed relative to the beginning of the full"
" sequence rather than the *start* argument."
msgstr ""
"ä»»æ„ã®å¼•æ•°ã§ã‚ã‚‹ *start* ã¨ *end* ã¯ã‚¹ãƒ©ã‚¤ã‚¹è¨˜æ³•ã¨ã—ã¦è§£é‡ˆã•ã‚Œã€ãƒªã‚¹ãƒˆã®æ¢ç´¢ç¯„å›²ã‚’æŒ‡å®šã§ãã¾ã™ã€‚è¿”ã•ã‚Œã‚‹æ·»å­—ã¯ã€*start* "
"å¼•æ•°ã‹ã‚‰ã®ç›¸å¯¾ä½ç½®ã§ã¯ãªãã€ãƒªã‚¹ãƒˆå…¨ä½“ã®å…ˆé ­ã‹ã‚‰ã®ä½ç½®ã«ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:78
msgid "Return the number of times *x* appears in the list."
msgstr "ãƒªã‚¹ãƒˆã§ã® *x* ã®å‡ºç¾å›æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:84
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"ãƒªã‚¹ãƒˆã®é …ç›®ã‚’ã€ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹æ¼”ç®— (in placeã€å…ƒã®ãƒ‡ãƒ¼ã‚¿ã‚’æ¼”ç®—çµæœã§ç½®ãæ›ãˆã‚‹ã‚„ã‚Šã‹ãŸ) "
"ã§ã‚½ãƒ¼ãƒˆã—ã¾ã™ã€‚å¼•æ•°ã¯ã‚½ãƒ¼ãƒˆæ–¹æ³•ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã«ä½¿ãˆã¾ã™ã€‚ :func:`sorted` ã®èª¬æ˜ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/datastructures.rst:91
msgid "Reverse the elements of the list in place."
msgstr "ãƒªã‚¹ãƒˆã®è¦ç´ ã‚’ã€ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹æ¼”ç®—ã§é€†é †ã«ã—ã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:97
msgid "Return a shallow copy of the list.  Equivalent to ``a[:]``."
msgstr "ãƒªã‚¹ãƒˆã®æµ…ã„ (shallow) ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚``a[:]`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../tutorial/datastructures.rst:100
msgid "An example that uses most of the list methods::"
msgstr "ä»¥ä¸‹ã«ãƒªã‚¹ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã»ã¼å…¨ã¦ä½¿ã£ãŸä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../tutorial/datastructures.rst:123
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [1]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"``insert``, ``remove``, ``sort`` "
"ãªã©ã®ãƒªã‚¹ãƒˆã‚’æ“ä½œã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã®æˆ»ã‚Šå€¤ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ãªã„ã“ã¨ã«æ°—ãŒä»˜ã„ãŸã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ ``None`` ã‚’è¿”ã—ã¦ã„ã¾ã™ã€‚[1]_ "
"ã“ã‚Œã¯ Python ã®å¤‰æ›´å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ å…¨ã¦ã«ã¤ã„ã¦ã®è¨­è¨ˆä¸Šã®åŸå‰‡ã¨ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:132
msgid "Using Lists as Stacks"
msgstr "ãƒªã‚¹ãƒˆã‚’ã‚¹ã‚¿ãƒƒã‚¯ã¨ã—ã¦ä½¿ã†"

#: ../../tutorial/datastructures.rst:137
msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`append`.  To retrieve an "
"item from the top of the stack, use :meth:`pop` without an explicit index.  "
"For example::"
msgstr ""
"ãƒªã‚¹ãƒˆå‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ãŠã‹ã’ã§ã€ç°¡å˜ã«ãƒªã‚¹ãƒˆã‚’ã‚¹ã‚¿ãƒƒã‚¯ã¨ã—ã¦ä½¿ãˆã¾ã™ã€‚ã‚¹ã‚¿ãƒƒã‚¯ã§ã¯ã€æœ€å¾Œã«è¿½åŠ ã•ã‚ŒãŸè¦ç´ ãŒæœ€åˆã«å–ã‚Šå‡ºã•ã‚Œã¾ã™ (\"last-in, "
"first-out\")ã€‚ã‚¹ã‚¿ãƒƒã‚¯ã®ä¸€ç•ªä¸Šã«è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ã«ã¯ :meth:`append` ã‚’ä½¿ã„ã¾ã™ã€‚ã‚¹ã‚¿ãƒƒã‚¯ã®ä¸€ç•ªä¸Šã‹ã‚‰è¦ç´ ã‚’å–ã‚Šå‡ºã™ã«ã¯ "
":meth:`pop` ã‚’ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã‚’æŒ‡å®šã›ãšã«ä½¿ã„ã¾ã™ã€‚ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../tutorial/datastructures.rst:162
msgid "Using Lists as Queues"
msgstr "ãƒªã‚¹ãƒˆã‚’ã‚­ãƒ¥ãƒ¼ã¨ã—ã¦ä½¿ã†"

#: ../../tutorial/datastructures.rst:166
msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are"
" not efficient for this purpose.  While appends and pops from the end of "
"list are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"ãƒªã‚¹ãƒˆã‚’ã‚­ãƒ¥ãƒ¼ (queue) ã¨ã—ã¦ä½¿ã†ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚ã“ã®å ´åˆã€æœ€åˆã«è¿½åŠ ã—ãŸè¦ç´ ã‚’æœ€åˆã«å–ã‚Šå‡ºã—ã¾ã™ (\"first-in, first-"
"out\")ã€‚ã—ã‹ã—ã€ãƒªã‚¹ãƒˆã§ã¯åŠ¹ç‡çš„ã«ã“ã®ç›®çš„ã‚’é”æˆã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã›ã‚“ã€‚è¿½åŠ ï¼ˆappendï¼‰ã‚„å–ã‚Šå‡ºã—ï¼ˆpopï¼‰ã‚’ãƒªã‚¹ãƒˆã®æœ«å°¾ã«å¯¾ã—ã¦è¡Œã†ã¨é€Ÿã„ã®ã§ã™ãŒã€æŒ¿å…¥ï¼ˆinsertï¼‰ã‚„å–ã‚Šå‡ºã—ï¼ˆpopï¼‰ã‚’ãƒªã‚¹ãƒˆã®å…ˆé ­ã«å¯¾ã—ã¦è¡Œã†ã¨é…ããªã£ã¦ã—ã¾ã„ã¾ã™ï¼ˆä»–ã®è¦ç´ ã‚’ã²ã¨ã¤ãšã¤ãšã‚‰ã™å¿…è¦ãŒã‚ã‚‹ã‹ã‚‰ã§ã™ï¼‰ã€‚"

#: ../../tutorial/datastructures.rst:172
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"ã‚­ãƒ¥ãƒ¼ã®å®Ÿè£…ã«ã¯ã€ :class:`collections.deque` "
"ã‚’ä½¿ã†ã¨è‰¯ã„ã§ã—ã‚‡ã†ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯è‰¯ãè¨­è¨ˆã•ã‚Œã¦ã„ã¦ã€é«˜é€Ÿãªè¿½åŠ ï¼ˆappendï¼‰ã¨å–ã‚Šå‡ºã—ï¼ˆpopï¼‰ã‚’ä¸¡ç«¯ã«å¯¾ã—ã¦å®Ÿç¾ã—ã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../tutorial/datastructures.rst:190
msgid "List Comprehensions"
msgstr "ãƒªã‚¹ãƒˆã®å†…åŒ…è¡¨è¨˜"

#: ../../tutorial/datastructures.rst:192
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã¯ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆã™ã‚‹ç°¡æ½”ãªæ‰‹æ®µã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ä¸»ãªåˆ©ç”¨å ´é¢ã¯ã€ã‚ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚„ iterable (ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) "
"ã®ãã‚Œãã‚Œã®è¦ç´ ã«å¯¾ã—ã¦ã‚ã‚‹æ“ä½œã‚’è¡Œã£ãŸçµæœã‚’è¦ç´ ã«ã—ãŸãƒªã‚¹ãƒˆã‚’ä½œã£ãŸã‚Šã€ã‚ã‚‹æ¡ä»¶ã‚’æº€ãŸã™è¦ç´ ã ã‘ã‹ã‚‰ãªã‚‹éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../tutorial/datastructures.rst:197
msgid "For example, assume we want to create a list of squares, like::"
msgstr "ä¾‹ãˆã°ã€æ¬¡ã®ã‚ˆã†ãªå¹³æ–¹ã®ãƒªã‚¹ãƒˆã‚’ä½œã‚ŠãŸã„ã¨ã—ã¾ã™::"

#: ../../tutorial/datastructures.rst:206
msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"ã“ã‚Œã¯ãƒ«ãƒ¼ãƒ—ãŒçµ‚äº†ã—ãŸå¾Œã«ã‚‚å­˜åœ¨ã™ã‚‹ ``x`` ã¨ã„ã†åå‰ã®å¤‰æ•°ã‚’ä½œã‚‹ (ã¾ãŸã¯ä¸Šæ›¸ãã™ã‚‹) "
"ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦å¹³æ–¹ã®ãƒªã‚¹ãƒˆã‚’ã„ã‹ãªã‚‹å‰¯ä½œç”¨ã‚‚ãªãè¨ˆç®—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/datastructures.rst:212
msgid "or, equivalently::"
msgstr "ã‚‚ã—ãã¯ã€ä»¥ä¸‹ã§ã‚‚åŒã˜ã§ã™::"

#: ../../tutorial/datastructures.rst:216
msgid "which is more concise and readable."
msgstr "ã“ã‚Œã¯ã‚ˆã‚Šç°¡æ½”ã§èª­ã¿ã‚„ã™ã„ã§ã™ã€‚"

#: ../../tutorial/datastructures.rst:218
msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`for` clause, then zero or more :keyword:`for` or "
":keyword:`if` clauses.  The result will be a new list resulting from "
"evaluating the expression in the context of the :keyword:`for` and "
":keyword:`if` clauses which follow it. For example, this listcomp combines "
"the elements of two lists if they are not equal::"
msgstr ""
"ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã¯ã€æ‹¬å¼§ã®ä¸­ã® å¼ã€ :keyword:`for` å¥ã€ãã—ã¦0å€‹ä»¥ä¸Šã® :keyword:`for` ã‹ :keyword:`if` "
"å¥ã§æ§‹æˆã•ã‚Œã¾ã™ã€‚ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã®å®Ÿè¡Œçµæœã¯ã€ :keyword:`for` ã¨ :keyword:`if` "
"å¥ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä¸­ã§å¼ã‚’è©•ä¾¡ã—ãŸçµæœã‹ã‚‰ãªã‚‹æ–°ã—ã„ãƒªã‚¹ãƒˆã§ã™ã€‚ä¾‹ãˆã°ã€æ¬¡ã®ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã¯2ã¤ã®ãƒªã‚¹ãƒˆã®è¦ç´ ã‹ã‚‰ã€é•ã†ã‚‚ã®åŒå£«ã‚’ãƒšã‚¢ã«ã—ã¾ã™::"

#: ../../tutorial/datastructures.rst:228
msgid "and it's equivalent to::"
msgstr "ã“ã‚Œã¯æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¨ç­‰ä¾¡ã§ã™::"

#: ../../tutorial/datastructures.rst:239
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the"
" same in both these snippets."
msgstr ":keyword:`for` ã¨ :keyword:`if` æ–‡ãŒä¸¡æ–¹ã®ã‚³ãƒ¼ãƒ‰ã§åŒã˜é †åºã«ãªã£ã¦ã„ã‚‹ã“ã¨ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/datastructures.rst:242
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr "å¼ãŒã‚¿ãƒ—ãƒ«ã®å ´åˆ (ä¾‹: ä¸Šã®ä¾‹ã§å¼ãŒ ``(x, y)`` ã®å ´åˆ) ã¯ã€ã‚¿ãƒ—ãƒ«ã«å††æ‹¬å¼§ãŒå¿…è¦ã§ã™ã€‚ ::"

#: ../../tutorial/datastructures.rst:273
msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr "ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã®å¼ã«ã¯ã€è¤‡é›‘ãªå¼ã‚„é–¢æ•°å‘¼ã³å‡ºã—ã®ãƒã‚¹ãƒˆãŒã§ãã¾ã™::"

#: ../../tutorial/datastructures.rst:280
msgid "Nested List Comprehensions"
msgstr "ãƒã‚¹ãƒˆã—ãŸãƒªã‚¹ãƒˆã®å†…åŒ…è¡¨è¨˜"

#: ../../tutorial/datastructures.rst:282
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr "ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ä¸­ã®æœ€åˆã®å¼ã¯ä»»æ„ã®å¼ãªã®ã§ã€ãã“ã«ä»–ã®ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã‚’æ›¸ãã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:285
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr "æ¬¡ã®ã€é•·ã•4ã®ãƒªã‚¹ãƒˆ3ã¤ã‹ã‚‰ãªã‚‹ã€3x4 ã® matrix ã«ã¤ã„ã¦è€ƒãˆã¾ã™::"

#: ../../tutorial/datastructures.rst:294
msgid "The following list comprehension will transpose rows and columns::"
msgstr "æ¬¡ã®ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã¯ã€matrix ã®è¡Œã¨åˆ—ã‚’å…¥ã‚Œæ›¿ãˆã¾ã™::"

#: ../../tutorial/datastructures.rst:299
msgid ""
"As we saw in the previous section, the nested listcomp is evaluated in the "
"context of the :keyword:`for` that follows it, so this example is equivalent"
" to::"
msgstr ""
"å‰ã®ç¯€ã§è¦‹ãŸã‚ˆã†ã«ã€ãƒã‚¹ãƒˆã—ãŸãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã¯ã€ç¶šã :keyword:`for` "
"ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä¸­ã§è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ãªã®ã§ã€ã“ã®ä¾‹ã¯æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¨ç­‰ä¾¡ã§ã™::"

#: ../../tutorial/datastructures.rst:310
msgid "which, in turn, is the same as::"
msgstr "ã“ã‚Œã‚’ã‚‚ã†ä¸€åº¦å¤‰æ›ã™ã‚‹ã¨ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¨ç­‰ä¾¡ã«ãªã‚Šã¾ã™::"

#: ../../tutorial/datastructures.rst:323
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use "
"case::"
msgstr "å®Ÿéš›ã«ã¯è¤‡é›‘ãªæµã‚Œã®å¼ã‚ˆã‚Šã‚‚çµ„ã¿è¾¼ã¿é–¢æ•°ã‚’ä½¿ã†æ–¹ãŒè‰¯ã„ã§ã™ã€‚ã“ã®å ´åˆ :func:`zip` é–¢æ•°ãŒè‰¯ã„ä»•äº‹ã‚’ã—ã¦ãã‚Œã‚‹ã§ã—ã‚‡ã†::"

#: ../../tutorial/datastructures.rst:329
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr "ã“ã®è¡Œã«ã‚ã‚‹ã‚¢ã‚¹ã‚¿ãƒªã‚¹ã‚¯ã®è©³ç´°ã«ã¤ã„ã¦ã¯ :ref:`tut-unpacking-arguments` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/datastructures.rst:334
msgid "The :keyword:`del` statement"
msgstr ":keyword:`del` æ–‡"

#: ../../tutorial/datastructures.rst:336
msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`pop` "
"method which returns a value.  The :keyword:`del` statement can also be used"
" to remove slices from a list or clear the entire list (which we did earlier"
" by assignment of an empty list to the slice).  For example::"
msgstr ""
"ãƒªã‚¹ãƒˆã‹ã‚‰è¦ç´ ã‚’å‰Šé™¤ã™ã‚‹éš›ã€å€¤ã‚’æŒ‡å®šã™ã‚‹ä»£ã‚ã‚Šã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æŒ‡å®šã™ã‚‹æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚ãã‚ŒãŒ :keyword:`del` æ–‡ã§ã™ã€‚ã“ã‚Œã¯ "
":meth:`pop` ãƒ¡ã‚½ãƒƒãƒ‰ã¨é•ã„ã€å€¤ã‚’è¿”ã—ã¾ã›ã‚“ã€‚ :keyword:`del` "
"æ–‡ã¯ãƒªã‚¹ãƒˆã‹ã‚‰ã‚¹ãƒ©ã‚¤ã‚¹ã‚’é™¤å»ã—ãŸã‚Šã€ãƒªã‚¹ãƒˆå…¨ä½“ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™(ä»¥å‰ã¯ã‚¹ãƒ©ã‚¤ã‚¹ã«ç©ºã®ãƒªã‚¹ãƒˆã‚’ä»£å…¥ã—ã¦è¡Œã£ã¦ã„ã¾ã—ãŸ)ã€‚ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../tutorial/datastructures.rst:353
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ":keyword:`del` ã¯å¤‰æ•°å…¨ä½“ã®å‰Šé™¤ã«ã‚‚ä½¿ãˆã¾ã™::"

#: ../../tutorial/datastructures.rst:357
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"ã“ã®æ–‡ã®å¾Œã§åå‰ ``a`` ã‚’å‚ç…§ã™ã‚‹ã¨ã€(åˆ¥ã®å€¤ã‚’ ``a`` ã«ä»£å…¥ã™ã‚‹ã¾ã§) ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚ :keyword:`del` "
"ã®åˆ¥ã®ç”¨é€”ã«ã¤ã„ã¦ã¯ã¾ãŸå¾Œã§å–ã‚Šä¸Šã’ã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:364
msgid "Tuples and Sequences"
msgstr "ã‚¿ãƒ—ãƒ«ã¨ã‚·ãƒ¼ã‚±ãƒ³ã‚¹"

#: ../../tutorial/datastructures.rst:366
msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types (see"
" :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type:"
" the *tuple*."
msgstr ""
"ãƒªã‚¹ãƒˆã‚„æ–‡å­—åˆ—ã«ã¯ã€ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã‚„ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ä½¿ã£ãŸæ¼”ç®—ã®ã‚ˆã†ã«ã€æ•°å¤šãã®å…±é€šã®æ€§è³ªãŒã‚ã‚‹ã“ã¨ã‚’è¦‹ã¦ãã¾ã—ãŸã€‚ã“ã‚Œã‚‰ã¯ *ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ (sequence)*"
" ãƒ‡ãƒ¼ã‚¿å‹ (:ref:`typesseq` ã‚’å‚ç…§) ã®äºŒã¤ã®ä¾‹ã§ã™ã€‚ Python "
"ã¯ã¾ã é€²æ­©ã®éç¨‹ã«ã‚ã‚‹è¨€èªãªã®ã§ã€ä»–ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãƒ‡ãƒ¼ã‚¿å‹ãŒè¿½åŠ ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚æ¨™æº–ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã¯ã‚‚ã†ä¸€ã¤ã‚ã‚Šã¾ã™: *ã‚¿ãƒ—ãƒ« (tuple)* "
"å‹ã§ã™ã€‚"

#: ../../tutorial/datastructures.rst:372
msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr "ã‚¿ãƒ—ãƒ«ã¯ã‚³ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸã„ãã¤ã‹ã®å€¤ã‹ã‚‰ãªã‚Šã¾ã™ã€‚ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ãã¾ã™::"

#: ../../tutorial/datastructures.rst:394
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if"
" the tuple is part of a larger expression).  It is not possible to assign to"
" the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"ã”è¦§ã®ã¨ãŠã‚Šã€ã‚¿ãƒ—ãƒ«ã®è¡¨ç¤ºã«ã¯å¸¸ã«ä¸¸æ‹¬å¼§ãŒã¤ã„ã¦ã„ã¦ã€ã‚¿ãƒ—ãƒ«ã®ãƒã‚¹ãƒˆãŒæ­£ã—ãè§£é‡ˆã•ã‚Œã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã‚’æ›¸ãã¨ãã¯å¿…ãšã—ã‚‚ä¸¸æ‹¬å¼§ã§å›²ã¾ãªãã¦ã‚‚ã„ã„ã§ã™ãŒã€(ã‚¿ãƒ—ãƒ«ãŒå¤§ããªå¼ã®ä¸€éƒ¨ã ã£ãŸå ´åˆã¯)"
" ä¸¸æ‹¬å¼§ãŒå¿…è¦ãªå ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã®è¦ç´ ã‚’ä»£å…¥ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ã‚¿ãƒ—ãƒ«ã«ãƒªã‚¹ãƒˆã®ã‚ˆã†ãªå¤‰æ›´å¯èƒ½å‹ã‚’å«ã‚ã‚‹ã“ã¨ã¯ã§ãã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:401
msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are "
":term:`mutable`, and their elements are usually homogeneous and are accessed"
" by iterating over the list."
msgstr ""
"ã‚¿ãƒ—ãƒ«ã¯ãƒªã‚¹ãƒˆã¨ä¼¼ã¦ã„ã¾ã™ãŒã€ãŸã„ã¦ã„ç•°ãªã‚‹å ´é¢ã¨ç•°ãªã‚‹ç›®çš„ã§åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã¯ä¸å¤‰å‹ (:term:`immutable`) "
"ã§ã€è¤‡æ•°ã®å‹ã®è¦ç´ ã‹ã‚‰ãªã‚‹ã“ã¨ã‚‚ã‚ã‚Šã€è¦ç´ ã¯ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯(ã“ã®ç¯€ã®å¾ŒåŠã«å‡ºã¦ãã¾ã™)æ“ä½œã‚„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ (ã‚ã‚‹ã„ã¯ :func:`namedtuples "
"<collections.namedtuple>` ã®å ´åˆã¯å±æ€§)ã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚ä¸€æ–¹ã€ãƒªã‚¹ãƒˆã¯å¤‰æ›´å¯èƒ½ "
"(:term:`mutable`) ã§ã€è¦ç´ ã¯ãŸã„ã¦ã„åŒã˜å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚Šã€ãŸã„ã¦ã„ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã«ã‚ˆã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:409
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the"
" syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"å•é¡Œã¯ 0 å€‹ã¾ãŸã¯ 1 "
"å€‹ã®é …ç›®ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã®æ§‹ç¯‰ã§ã™ã€‚ã“ã‚Œã‚‰ã®æ“ä½œã‚’è¡Œã†ãŸã‚ã€æ§‹æ–‡ã«ã¯ç‰¹åˆ¥ãªç´°å·¥ãŒã•ã‚Œã¦ã„ã¾ã™ã€‚ç©ºã®ã‚¿ãƒ—ãƒ«ã¯ç©ºã®ä¸¸æ‹¬å¼§ãƒšã‚¢ã§æ§‹ç¯‰ã§ãã¾ã™ã€‚ä¸€ã¤ã®è¦ç´ ã‚’æŒã¤ã‚¿ãƒ—ãƒ«ã¯ã€å€¤ã®å¾Œã‚ã«ã‚³ãƒ³ãƒã‚’ç¶šã‘ã‚‹"
" (å˜ä¸€ã®å€¤ã‚’ä¸¸æ‹¬å¼§ã§å›²ã‚€ã ã‘ã§ã¯ä¸ååˆ†ã§ã™) ã“ã¨ã§æ§‹ç¯‰ã§ãã¾ã™ã€‚ç¾ã—ãã¯ãªã„ã‘ã‚Œã©ã‚‚ã€åŠ¹æœçš„ã§ã™ã€‚ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../tutorial/datastructures.rst:424
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"æ–‡ ``t = 12345, 54321, 'hello!'`` ã¯ *ã‚¿ãƒ—ãƒ«ã®ãƒ‘ãƒƒã‚¯ (tuple packing)* ã®ä¾‹ã§ã™ã€‚å€¤ "
"``12345``, ``54321``, ``'hello!'`` ãŒä¸€ã¤ã®ã‚¿ãƒ—ãƒ«ã«ãƒ‘ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚é€†ã®æ¼”ç®—ã‚‚å¯èƒ½ã§ã™::"

#: ../../tutorial/datastructures.rst:430
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any"
" sequence on the right-hand side.  Sequence unpacking requires that there "
"are as many variables on the left side of the equals sign as there are "
"elements in the sequence.  Note that multiple assignment is really just a "
"combination of tuple packing and sequence unpacking."
msgstr ""
"ã“ã®æ“ä½œã¯ã€*ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ (sequence unpacking)* "
"ã¨ã§ã‚‚å‘¼ã¶ã¹ãã‚‚ã®ã§ã€å³è¾ºã«ã¯å…¨ã¦ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ã§ã¯ã€ç­‰å·ã®å·¦è¾ºã«åˆ—æŒ™ã•ã‚Œã¦ã„ã‚‹å¤‰æ•°ãŒã€å³è¾ºã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã¨åŒã˜æ•°ã ã‘ã‚ã‚‹ã“ã¨ãŒè¦æ±‚ã•ã‚Œã¾ã™ã€‚è¤‡æ•°åŒæ™‚ã®ä»£å…¥ãŒå®Ÿã¯ã‚¿ãƒ—ãƒ«ã®ãƒ‘ãƒƒã‚¯ã¨ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ã‚’çµ„ã¿åˆã‚ã›ãŸã‚‚ã®ã«éããªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/datastructures.rst:440
msgid "Sets"
msgstr "é›†åˆå‹"

#: ../../tutorial/datastructures.rst:442
msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""
"Python ã«ã¯ã€ *é›†åˆ (set)* ã‚’æ‰±ã†ãŸã‚ã®ãƒ‡ãƒ¼ã‚¿å‹ã‚‚ã‚ã‚Šã¾ã™ã€‚é›†åˆã¨ã¯ã€é‡è¤‡ã™ã‚‹è¦ç´ ã‚’ã‚‚ãŸãªã„ã€é †åºã¥ã‘ã‚‰ã‚Œã¦ã„ãªã„è¦ç´ ã®é›†ã¾ã‚Šã§ã™ã€‚ "
"Set ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€å’Œ (union)ã€ç© (intersection)ã€å·® (difference)ã€å¯¾ç§°å·® (symmetric "
"difference)ã¨ã„ã£ãŸæ•°å­¦çš„ãªæ¼”ç®—ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:447
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"ä¸­æ‹¬å¼§ã€ã¾ãŸã¯ :func:`set` é–¢æ•°ã¯ set ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ³¨: ç©ºé›†åˆã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ã¯ ``set()`` "
"ã‚’ä½¿ç”¨ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ (``{}`` ã§ã¯ãªã)ã€‚å¾Œè€…ã¯ç©ºã®è¾æ›¸ã‚’ä½œæˆã—ã¾ã™ã€‚è¾æ›¸ã¯æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§è­°è«–ã™ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã™ã€‚"

#: ../../tutorial/datastructures.rst:451
msgid "Here is a brief demonstration::"
msgstr "ç°¡å˜ãªãƒ‡ãƒ¢ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç¤ºã—ã¾ã™::"

#: ../../tutorial/datastructures.rst:476
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ":ref:`ãƒªã‚¹ãƒˆå†…åŒ… <tut-listcomps>` ã¨åŒæ§˜ã«ã€ set å†…åŒ…ã‚‚ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™::"

#: ../../tutorial/datastructures.rst:487
msgid "Dictionaries"
msgstr "è¾æ›¸å‹ (dictionary)"

#: ../../tutorial/datastructures.rst:489
msgid ""
"Another useful data type built into Python is the *dictionary* (see "
":ref:`typesmapping`). Dictionaries are sometimes found in other languages as"
" \"associative memories\" or \"associative arrays\".  Unlike sequences, "
"which are indexed by a range of numbers, dictionaries are indexed by *keys*,"
" which can be any immutable type; strings and numbers can always be keys.  "
"Tuples can be used as keys if they contain only strings, numbers, or tuples;"
" if a tuple contains any mutable object either directly or indirectly, it "
"cannot be used as a key. You can't use lists as keys, since lists can be "
"modified in place using index assignments, slice assignments, or methods "
"like :meth:`append` and :meth:`extend`."
msgstr ""
"ã‚‚ã†ä¸€ã¤ã€æœ‰ç”¨ãªå‹ãŒ Python ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã™ã€‚ãã‚Œã¯ *è¾æ›¸ (dictionary)* (:ref:`typesmapping` "
"ã‚’å‚ç…§)ã§ã™ã€‚è¾æ›¸ã¯ä»–ã®è¨€èªã«ã‚‚ \"é€£æƒ³è¨˜æ†¶ (associated memory)\" ã‚„ \"é€£æƒ³é…åˆ— (associative array)\""
" ã¨ã„ã†åå‰ã§å­˜åœ¨ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã‚ã‚‹ç¯„å›²ã®æ•°ã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹åŒ–ã•ã‚Œã¦ã„ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ç•°ãªã‚Šã€è¾æ›¸ã¯ *ã‚­ãƒ¼ (key)* "
"ã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ã‚­ãƒ¼ã¯ä½•ã‚‰ã‹ã®å¤‰æ›´ä¸èƒ½ãªå‹ã«ãªã‚Šã¾ã™ã€‚æ–‡å­—åˆ—ã€æ•°å€¤ã¯å¸¸ã«ã‚­ãƒ¼ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã¯ã€æ–‡å­—åˆ—ã€æ•°å€¤ã€ãã®ä»–ã®ã‚¿ãƒ—ãƒ«ã®ã¿ã‚’å«ã‚€å ´åˆã¯ã‚­ãƒ¼ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ç›´æ¥ã€ã‚ã‚‹ã„ã¯é–“æ¥çš„ã«å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã¯ã‚­ãƒ¼ã«ã§ãã¾ã›ã‚“ã€‚ãƒªã‚¹ãƒˆã‚’ã‚­ãƒ¼ã¨ã—ã¦ä½¿ã†ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€ãƒªã‚¹ãƒˆã«ã‚¹ãƒ©ã‚¤ã‚¹ã‚„ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹æŒ‡å®šã®ä»£å…¥ã‚’è¡Œã£ãŸã‚Šã€"
" :meth:`append` ã‚„ :meth:`extend` ã®ã‚ˆã†ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã¨ã€ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã§å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ãŸã‚ã§ã™ã€‚"

#: ../../tutorial/datastructures.rst:500
msgid ""
"It is best to think of a dictionary as an unordered set of *key: value* "
"pairs, with the requirement that the keys are unique (within one "
"dictionary). A pair of braces creates an empty dictionary: ``{}``. Placing a"
" comma-separated list of key:value pairs within the braces adds initial "
"key:value pairs to the dictionary; this is also the way dictionaries are "
"written on output."
msgstr ""
"è¾æ›¸ã¯é †åºä»˜ã‘ã®ã•ã‚Œã¦ã„ãªã„ *ã‚­ãƒ¼(key): å€¤(value)* ã®ãƒšã‚¢ã®é›†åˆã§ã‚ã‚Šã€ã‚­ãƒ¼ãŒ "
"(è¾æ›¸ã®ä¸­ã§)ä¸€æ„ã§ã‘ã‚Œã°ãªã‚‰ãªã„ã€ã¨è€ƒãˆã‚‹ã¨ã‚ˆã„ã§ã—ã‚‡ã†ã€‚æ³¢æ‹¬å¼§ (brace) ã®ãƒšã‚¢: ``{}`` ã¯ç©ºã®è¾æ›¸ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸ "
"key: value ã®ãƒšã‚¢ã‚’æ³¢æ‹¬å¼§ãƒšã‚¢ã®é–“ã«å…¥ã‚Œã‚‹ã¨ã€è¾æ›¸ã®åˆæœŸå€¤ã¨ãªã‚‹ key: value ãŒè¿½åŠ ã•ã‚Œã¾ã™; "
"ã“ã®è¡¨ç¾æ–¹æ³•ã¯å‡ºåŠ›æ™‚ã«è¾æ›¸ãŒæ›¸ãå‡ºã•ã‚Œã‚‹ã®ã¨åŒã˜æ–¹æ³•ã§ã™ã€‚"

#: ../../tutorial/datastructures.rst:506
msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a "
"key:value pair with ``del``. If you store using a key that is already in "
"use, the old value associated with that key is forgotten.  It is an error to"
" extract a value using a non-existent key."
msgstr ""
"è¾æ›¸ã§ã®ä¸»ãªæ“ä½œã¯ã€ã‚ã‚‹å€¤ã‚’ä½•ã‚‰ã‹ã®ã‚­ãƒ¼ã‚’ä»˜ã‘ã¦è¨˜æ†¶ã™ã‚‹ã“ã¨ã¨ã€ã‚­ãƒ¼ã‚’æŒ‡å®šã—ã¦å€¤ã‚’å–ã‚Šå‡ºã™ã“ã¨ã§ã™ã€‚ ``del`` ã§ key: value "
"ã®ãƒšã‚¢ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã™ã§ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ã‚­ãƒ¼ã‚’ä½¿ã£ã¦å€¤ã‚’è¨˜æ†¶ã™ã‚‹ã¨ã€ä»¥å‰ãã®ã‚­ãƒ¼ã«é–¢é€£ã¥ã‘ã‚‰ã‚Œã¦ã„ãŸå€¤ã¯å¿˜ã‚Œå»ã‚‰ã‚Œã¦ã—ã¾ã„ã¾ã™ã€‚å­˜åœ¨ã—ãªã„ã‚­ãƒ¼ã‚’ä½¿ã£ã¦å€¤ã‚’å–ã‚Šå‡ºãã†ã¨ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:512
msgid ""
"Performing ``list(d.keys())`` on a dictionary returns a list of all the keys"
" used in the dictionary, in arbitrary order (if you want it sorted, just use"
" ``sorted(d.keys())`` instead). [2]_  To check whether a single key is in "
"the dictionary, use the :keyword:`in` keyword."
msgstr ""
"è¾æ›¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã« ``list(d.keys())`` ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€è¾æ›¸ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹å…¨ã¦ã®ã‚­ãƒ¼ã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã‚’é©å½“ãªé †ç•ªã§è¿”ã—ã¾ã™ "
"(ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸãƒªã‚¹ãƒˆãŒæ¬²ã—ã„å ´åˆã¯ã€ä»£ã‚ã‚Šã« ``sorted(d.keys())`` ã‚’ä½¿ã£ã¦ãã ã•ã„)ã€‚ [2]_  "
"ã‚ã‚‹å˜ä¸€ã®ã‚­ãƒ¼ãŒè¾æ›¸ã«ã‚ã‚‹ã‹ã©ã†ã‹èª¿ã¹ã‚‹ã«ã¯ã€ :keyword:`in` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:517
msgid "Here is a small example using a dictionary::"
msgstr "ä»¥ä¸‹ã«ã€è¾æ›¸ã‚’ä½¿ã£ãŸç°¡å˜ãªä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../tutorial/datastructures.rst:538
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ":func:`dict` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€ã‚­ãƒ¼ã¨å€¤ã®ãƒšã‚¢ã®ã‚¿ãƒ—ãƒ«ã‚’å«ã‚€ãƒªã‚¹ãƒˆã‹ã‚‰è¾æ›¸ã‚’ç”Ÿæˆã—ã¾ã™::"

#: ../../tutorial/datastructures.rst:544
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr "ã•ã‚‰ã«ã€è¾æ›¸å†…åŒ…è¡¨ç¾ã‚’ä½¿ã£ã¦ã€ä»»æ„ã®ã‚­ãƒ¼ã¨å€¤ã®ãƒšã‚¢ã‹ã‚‰è¾æ›¸ã‚’ä½œã‚Œã¾ã™::"

#: ../../tutorial/datastructures.rst:550
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr "ã‚­ãƒ¼ãŒå˜ç´”ãªæ–‡å­—åˆ—ã®å ´åˆã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ä½¿ã£ã¦å®šç¾©ã™ã‚‹æ–¹ãŒå˜ç´”ãªå ´åˆã‚‚ã‚ã‚Šã¾ã™::"

#: ../../tutorial/datastructures.rst:560
msgid "Looping Techniques"
msgstr "ãƒ«ãƒ¼ãƒ—ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯"

#: ../../tutorial/datastructures.rst:562
msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`items` method. ::"
msgstr "è¾æ›¸ã«å¯¾ã—ã¦ãƒ«ãƒ¼ãƒ—ã‚’è¡Œã†éš›ã€ :meth:`items` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã¨ã€ã‚­ãƒ¼ã¨ãã‚Œã«å¯¾å¿œã™ã‚‹å€¤ã‚’åŒæ™‚ã«å–ã‚Šå‡ºã›ã¾ã™ã€‚ ::"

#: ../../tutorial/datastructures.rst:572
msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ã‚ãŸã‚‹ãƒ«ãƒ¼ãƒ—ã‚’è¡Œã†éš›ã€ :func:`enumerate` é–¢æ•°ã‚’ä½¿ã†ã¨ã€è¦ç´ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨è¦ç´ ã‚’åŒæ™‚ã«å–ã‚Šå‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚ ::"

#: ../../tutorial/datastructures.rst:582
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"äºŒã¤ã¾ãŸã¯ãã‚Œä»¥ä¸Šã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã‚’åŒæ™‚ã«ãƒ«ãƒ¼ãƒ—ã™ã‚‹ãŸã‚ã«ã€é–¢æ•° :func:`zip` ã‚’ä½¿ã£ã¦å„è¦ç´ ã‚’ã²ã¨çµ„ã¿ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ ::"

#: ../../tutorial/datastructures.rst:594
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’é€†æ–¹å‘ã«æ¸¡ã£ã¦ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã«ã¯ã€ã¾ãšã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ç¯„å›²ã‚’é †æ–¹å‘ã«æŒ‡å®šã—ã€æ¬¡ã„ã§é–¢æ•° :func:`reversed` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ ::"

#: ../../tutorial/datastructures.rst:606
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸé †åºã§ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã«ã¯ã€ :func:`sorted` "
"é–¢æ•°ã‚’ä½¿ã„ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯å…ƒã®é…åˆ—ã‚’å¤‰æ›´ã›ãšã€ã‚½ãƒ¼ãƒˆæ¸ˆã¿ã®æ–°ãŸãªé…åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ ::"

#: ../../tutorial/datastructures.rst:618
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"ã¨ãã©ããƒ«ãƒ¼ãƒ—å†…ã§ãƒªã‚¹ãƒˆã‚’å¤‰æ›´ã—ãŸã„èª˜æƒ‘ã«é§†ã‚‰ã‚Œã‚‹ã§ã—ã‚‡ã†ãŒã€ä»£ã‚ã‚Šã«æ–°ã—ã„ãƒªã‚¹ãƒˆã‚’ä½œã£ã¦ã—ã¾ã†ã»ã†ãŒã‚ˆã‚Šç°¡å˜ã§å®‰å…¨ãªã“ã¨ãŒã€ã¾ã¾ã‚ã‚Šã¾ã™ ::"

#: ../../tutorial/datastructures.rst:635
msgid "More on Conditions"
msgstr "æ¡ä»¶ã«ã¤ã„ã¦ã‚‚ã†å°‘ã—"

#: ../../tutorial/datastructures.rst:637
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr "``while`` ã‚„ ``if`` æ–‡ã§ä½¿ã£ãŸæ¡ä»¶ (condition) ã«ã¯ã€å€¤ã®æ¯”è¼ƒã ã‘ã§ãªãã€ä»–ã®æ¼”ç®—å­ã‚‚ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:640
msgid ""
"The comparison operators ``in`` and ``not in`` check whether a value occurs "
"(does not occur) in a sequence.  The operators ``is`` and ``is not`` compare"
" whether two objects are really the same object; this only matters for "
"mutable objects like lists.  All comparison operators have the same "
"priority, which is lower than that of all numerical operators."
msgstr ""
"æ¯”è¼ƒæ¼”ç®—å­ ``in`` ãŠã‚ˆã³ ``not in`` ã¯ã€ã‚ã‚‹å€¤ãŒã‚ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ä¸­ã«å­˜åœ¨ã™ã‚‹ã‹ (ã¾ãŸã¯å­˜åœ¨ã—ãªã„ã‹) ã©ã†ã‹ã‚’èª¿ã¹ã¾ã™ã€‚æ¼”ç®—å­ "
"``is`` ãŠã‚ˆã³ ``is not`` "
"ã¯ã€äºŒã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå®Ÿéš›ã«åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’èª¿ã¹ã¾ã™ã€‚ã“ã®æ¯”è¼ƒã¯ã€ãƒªã‚¹ãƒˆã®ã‚ˆã†ãªå¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã ã‘æ„å‘³ãŒã‚ã‚Šã¾ã™ã€‚å…¨ã¦ã®æ¯”è¼ƒæ¼”ç®—å­ã¯åŒã˜å„ªå…ˆé †ä½ã‚’æŒã£ã¦ãŠã‚Šã€ã¨ã‚‚ã«æ•°å€¤æ¼”ç®—å­ã‚ˆã‚Šã‚‚ä½ã„å„ªå…ˆé †ä½ã¨ãªã‚Šã¾ã™ã€‚(è¨³æ³¨:"
" ``is`` ã¯ã€ ``is None`` "
"ã®ã‚ˆã†ã«ã€ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã®å¤‰æ›´ä¸èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã®æ¯”è¼ƒã«ç”¨ã„ã‚‹å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚(ã€Œå¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã ã‘æ„å‘³ãŒã‚ã‚Šã¾ã™ã€ã®éƒ¨åˆ†ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã‚’ "
"Doc-SIG ã«ææ¡ˆä¸­ã€‚))"

#: ../../tutorial/datastructures.rst:646
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a``"
" is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"æ¯”è¼ƒã¯é€£çµã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ ``a < b == c`` ã¯ã€ ``a`` ãŒ ``b`` ã‚ˆã‚Šå°ã•ãã€ã‹ã¤ ``b`` ã¨ ``c`` "
"ãŒç­‰ã—ã„ã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:649
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"ãƒ–ãƒ¼ãƒ«æ¼”ç®—å­ ``and`` ã‚„ ``or`` ã§æ¯”è¼ƒæ¼”ç®—ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãã—ã¦ã€æ¯”è¼ƒæ¼”ç®— (ã‚ã‚‹ã„ã¯ä½•ã‚‰ã‹ã®ãƒ–ãƒ¼ãƒ«å¼) ã®çµæœã®å¦å®šã¯ "
"``not`` ã§ã¨ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®æ¼”ç®—å­ã¯å…¨ã¦ã€æ¯”è¼ƒæ¼”ç®—å­ã‚ˆã‚Šã‚‚ä½ã„å„ªå…ˆé †ä½ã«ãªã£ã¦ã„ã¾ã™ã€‚ ``A and not B or C`` ã¨ ``(A "
"and (not B)) or C`` ãŒç­‰ä¾¡ã«ãªã‚‹ã‚ˆã†ã«ã€ãƒ–ãƒ¼ãƒ«æ¼”ç®—å­ã®ä¸­ã§ã€ ``not`` ã®å„ªå…ˆé †ä½ãŒæœ€ã‚‚é«˜ãã€ ``or`` "
"ãŒæœ€ã‚‚ä½ããªã£ã¦ã„ã¾ã™ã€‚ã‚‚ã¡ã‚ã‚“ã€ä¸¸æ‹¬å¼§ã‚’ä½¿ãˆã°æœ›ã¿ã®çµ„ã¿åˆã‚ã›ã‚’è¡¨ç¾ã§ãã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:656
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C``"
" are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"ãƒ–ãƒ¼ãƒ«æ¼”ç®—å­ ``and`` ã¨ ``or`` ã¯ã€ã„ã‚ã‚†ã‚‹ *çŸ­çµ¡ (short-circuit)* "
"æ¼”ç®—å­ã§ã™ã€‚ã“ã‚Œã‚‰ã®æ¼”ç®—å­ã®å¼•æ•°ã¯å·¦ã‹ã‚‰å³ã¸ã¨é †ã«è©•ä¾¡ã•ã‚Œã€çµæœãŒç¢ºå®šã—ãŸæ™‚ç‚¹ã§è©•ä¾¡ã‚’æ­¢ã‚ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``A`` ã¨ ``C`` ã¯çœŸã§ ``B``"
" ãŒå½ã®ã¨ãã€ ``A and B and C`` ã¯å¼ ``C`` "
"ã‚’è©•ä¾¡ã—ã¾ã›ã‚“ã€‚ä¸€èˆ¬ã«ã€çŸ­çµ¡æ¼”ç®—å­ã®æˆ»ã‚Šå€¤ã‚’ãƒ–ãƒ¼ãƒ«å€¤ã§ã¯ãªãã¦ä¸€èˆ¬çš„ãªå€¤ã¨ã—ã¦ç”¨ã„ã‚‹ã¨ã€å€¤ã¯æœ€å¾Œã«è©•ä¾¡ã•ã‚ŒãŸå¼•æ•°ã«ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:663
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr "æ¯”è¼ƒã‚„ä»–ã®ãƒ–ãƒ¼ãƒ«å¼ã®çµæœã‚’å¤‰æ•°ã«ä»£å…¥ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ ::"

#: ../../tutorial/datastructures.rst:671
msgid ""
"Note that in Python, unlike C, assignment cannot occur inside expressions. C"
" programmers may grumble about this, but it avoids a common class of "
"problems encountered in C programs: typing ``=`` in an expression when "
"``==`` was intended."
msgstr ""
"Python ã§ã¯ã€C è¨€èªã¨é•ã£ã¦ã€å¼ã®å†…éƒ¨ã§ä»£å…¥ã‚’è¡Œãˆãªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ C è¨€èªã®ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ä¸æº€ã«æ€ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ã“ã®ä»•æ§˜ã¯ã€ C"
" è¨€èªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§é­é‡ã™ã‚‹ã€å¼ã®ä¸­ã§ ``==`` ã®ã¤ã‚‚ã‚Šã§ ``=`` ã¨ã‚¿ã‚¤ãƒ—ã—ã¦ã—ã¾ã†ã¨ã„ã£ãŸã‚ã‚Šãµã‚ŒãŸå•é¡Œã‚’å›é¿ã—ã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:680
msgid "Comparing Sequences and Other Types"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ãã®ä»–ã®å‹ã®æ¯”è¼ƒ"

#: ../../tutorial/datastructures.rst:682
msgid ""
"Sequence objects may be compared to other objects with the same sequence "
"type. The comparison uses *lexicographical* ordering: first the first two "
"items are compared, and if they differ this determines the outcome of the "
"comparison; if they are equal, the next two items are compared, and so on, "
"until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters.  Some examples of comparisons between sequences"
" of the same type::"
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯åŒã˜ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã®ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨æ¯”è¼ƒã§ãã¾ã™ã€‚æ¯”è¼ƒã«ã¯ *è¾æ›¸çš„ãª (lexicographical)* "
"é †åºãŒç”¨ã„ã‚‰ã‚Œã¾ã™ã€‚ã¾ãšã€æœ€åˆã®äºŒã¤ã®è¦ç´ ã‚’æ¯”è¼ƒã—ã€ãã®å€¤ãŒç­‰ã—ããªã‘ã‚Œã°ãã®æ™‚ç‚¹ã§æ¯”è¼ƒçµæœãŒæ±ºã¾ã‚Šã¾ã™ã€‚ç­‰ã—ã‘ã‚Œã°æ¬¡ã®äºŒã¤ã®è¦ç´ ã‚’æ¯”è¼ƒã—ã€ä»¥é™ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®è¦ç´ ãŒå°½ãã‚‹ã¾ã§ç¶šã‘ã¾ã™ã€‚æ¯”è¼ƒã—ã‚ˆã†ã¨ã™ã‚‹äºŒã¤ã®è¦ç´ ãŒã„ãšã‚Œã‚‚åŒã˜ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã§ã‚ã‚Œã°ã€ãã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹é–“ã§ã®è¾æ›¸æ¯”è¼ƒã‚’å†å¸°çš„ã«è¡Œã„ã¾ã™ã€‚äºŒã¤ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å…¨ã¦ã®è¦ç´ ã®æ¯”è¼ƒçµæœãŒç­‰ã—ããªã‚Œã°ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ç­‰ã—ã„ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚ç‰‡æ–¹ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒã‚‚ã†ä¸€æ–¹ã®å…ˆé ­éƒ¨åˆ†ã«ã‚ãŸã‚‹éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãªã‚‰ã°ã€çŸ­ã„æ–¹ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒå°ã•ã„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚æ–‡å­—åˆ—ã«å¯¾ã™ã‚‹è¾æ›¸çš„ãªé †åºã¥ã‘ã«ã¯ã€å€‹ã€…ã®æ–‡å­—ã‚’ä¸¦ã¹ã‚‹ã®ã«"
" Unicode ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®æ•°ã‚’ç”¨ã„ã¾ã™ã€‚ä»¥ä¸‹ã«ã€åŒã˜å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒã¤ã‚·ãƒ¼ã‚±ãƒ³ã‚¹é–“ã§ã®æ¯”è¼ƒã‚’è¡Œã£ãŸä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../tutorial/datastructures.rst:702
msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example,"
" mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"é•ã†å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåŒå£«ã‚’ ``<`` ã‚„ ``>`` "
"ã§æ¯”è¼ƒã™ã‚‹ã“ã¨ã‚‚ã€ãã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒé©åˆ‡ãªæ¯”è¼ƒãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¦ã„ã‚‹ã®ã§ã‚ã‚Œã°è¨±å¯ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ç•°ãªã‚‹æ•°å€¤å‹åŒå£«ã®æ¯”è¼ƒã§ã¯ã€ãã®æ•°å€¤ã«ã‚ˆã£ã¦æ¯”è¼ƒãŒè¡Œã‚ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€"
" 0 ã¨ 0.0 ã¯ç­‰ä¾¡ã§ã™ã€‚ä¸€æ–¹ã€é©åˆ‡ãªæ¯”è¼ƒé †åºãŒãªã„å ´åˆã¯ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã¯ :exc:`TypeError` ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:710
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../tutorial/datastructures.rst:711
msgid ""
"Other languages may return the mutated object, which allows method chaining,"
" such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"ä»–ã®è¨€èªã§ã¯å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¦ã€``d->insert(\"a\")->remove(\"b\")->sort();`` "
"ã®ã‚ˆã†ãªãƒ¡ã‚½ãƒƒãƒ‰ãƒã‚§ã‚¤ãƒ³ã‚’è¨±ã—ã¦ã„ã‚‹å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../tutorial/datastructures.rst:714
msgid ""
"Calling ``d.keys()`` will return a :dfn:`dictionary view` object.  It "
"supports operations like membership test and iteration, but its contents are"
" not independent of the original dictionary -- it is only a *view*."
msgstr ""
"``d.keys()`` ã¯è¾æ›¸ãƒ“ãƒ¥ãƒ¼ (:dfn:`dictionary view`) "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ãƒ“ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ¡ãƒ³ãƒãƒ¼ã‹ã©ã†ã‹ã®ãƒ†ã‚¹ãƒˆ (è¨³æ³¨: `in` ã®äº‹) "
"ã¨ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ãŒã€ãã®è¦ç´ ã¯å…ƒã®è¾æ›¸ã¨ç‹¬ç«‹ã—ã¦ã„ã¾ã›ã‚“ã€‚ -- ã“ã‚Œã¯ãŸã ã® *view* ã§ã™ã€‚"
