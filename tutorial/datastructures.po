# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# tomo, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "データ構造"

#: ../../tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"この章では、すでに学んだことについてより詳しく説明するとともに、いくつか新し"
"いことを追加します。"

#: ../../tutorial/datastructures.rst:14
msgid "More on Lists"
msgstr "リスト型についてもう少し"

#: ../../tutorial/datastructures.rst:16
msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr ""
"リストデータ型には、他にもいくつかメソッドがあります。リストオブジェクトのす"
"べてのメソッドを以下に示します:"

#: ../../tutorial/datastructures.rst:23
msgid "Add an item to the end of the list; equivalent to ``a[len(a):] = [x]``."
msgstr "リストの末尾に要素を一つ追加します。 ``a[len(a):] = [x]`` と等価です。"

#: ../../tutorial/datastructures.rst:29
msgid ""
"Extend the list by appending all the items in the given list; equivalent to "
"``a[len(a):] = L``."
msgstr ""
"指定したリスト中のすべての要素を対象のリストに追加し、リストを拡張します。 "
"``a[len(a):] = L`` と等価です。"

#: ../../tutorial/datastructures.rst:36
msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"指定した位置に要素を挿入します。第 1 引数は、リストのインデクスで、そのインデ"
"クスを持つ要素の直前に挿入が行われます。従って、 ``a.insert(0, x)`` はリスト"
"の先頭に挿入を行います。また ``a.insert(len(a), x)`` は ``a.append(x)`` と等"
"価です。"

#: ../../tutorial/datastructures.rst:44
msgid ""
"Remove the first item from the list whose value is *x*. It is an error if "
"there is no such item."
msgstr ""
"リスト中で、値 *x* を持つ最初の要素を削除します。該当する項目がなければエラー"
"となります。"

#: ../../tutorial/datastructures.rst:51
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list.  (The square brackets around the *i* in the method signature denote "
"that the parameter is optional, not that you should type square brackets at "
"that position.  You will see this notation frequently in the Python Library "
"Reference.)"
msgstr ""
"リスト中の指定された位置にある要素をリストから削除して、その要素を返します。"
"インデクスが指定されなければ、 ``a.pop()`` はリストの末尾の要素を削除して返し"
"ます。この場合も要素は削除されます。 (メソッドの用法 (signature) で *i* の両"
"側にある角括弧は、この引数がオプションであることを表しているだけなので、角括"
"弧を入力する必要はありません。この表記法は Python Library Reference の中で頻"
"繁に見ることになるでしょう。)"

#: ../../tutorial/datastructures.rst:61
msgid ""
"Return the index in the list of the first item whose value is *x*. It is an "
"error if there is no such item."
msgstr ""
"リスト中で、値 *x* を持つ最初の要素のインデクスを返します。該当する項目がなけ"
"ればエラーとなります。"

#: ../../tutorial/datastructures.rst:68
msgid "Return the number of times *x* appears in the list."
msgstr "リストでの *x* の出現回数を返します。"

#: ../../tutorial/datastructures.rst:74
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"リストの項目を、インプレース演算 (in place、元のデータを演算結果で置き換える"
"やりかた) でソートします。引数はソート方法のカスタマイズに使えます。 :func:"
"`sorted` の説明を参照してください。"

#: ../../tutorial/datastructures.rst:81
msgid "Reverse the elements of the list, in place."
msgstr "リストの要素を、インプレース演算で逆順にします。"

#: ../../tutorial/datastructures.rst:83
msgid "An example that uses most of the list methods::"
msgstr "以下にリストのメソッドをほぼ全て使った例を示します::"

#: ../../tutorial/datastructures.rst:108
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``.  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"``insert``, ``remove``, ``sort`` などのリストを操作するメソッドの戻り値が表示"
"されていないことに気が付いたかもしれません。これらのメソッドは ``None`` を返"
"しています。これは Python の変更可能なデータ構造全てについての設計上の原則と"
"なっています。"

#: ../../tutorial/datastructures.rst:117
msgid "Using Lists as Stacks"
msgstr "リストをスタックとして使う"

#: ../../tutorial/datastructures.rst:122
msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`append`.  To retrieve an "
"item from the top of the stack, use :meth:`pop` without an explicit index.  "
"For example::"
msgstr ""
"リスト型のメソッドのおかげで、簡単にリストをスタックとして使えます。スタック"
"では、最後に追加された要素が最初に取り出されます (\"last-in, first-out\")。ス"
"タックの一番上に要素を追加するには :meth:`append` を使います。スタックの一番"
"上から要素を取り出すには :meth:`pop` をインデクスを指定せずに使います。例えば"
"以下のようにします::"

#: ../../tutorial/datastructures.rst:147
msgid "Using Lists as Queues"
msgstr "リストをキューとして使う"

#: ../../tutorial/datastructures.rst:151
msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are "
"not efficient for this purpose.  While appends and pops from the end of list "
"are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"リストをキュー (queue) として使うことも可能です。この場合、最初に追加した要素"
"を最初に取り出します (\"first-in, first-out\")。しかし、リストでは効率的にこ"
"の目的を達成することが出来ません。追加（append）や取り出し（pop）をリストの末"
"尾に対しておこなうと速いのですが、挿入（insert）や取り出し（pop）をリストの先"
"頭に対しておこなうと遅くなってしまいます（他の要素をひとつずつずらす必要があ"
"るからです）。"

#: ../../tutorial/datastructures.rst:157
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"キューの実装には、 :class:`collections.deque` を使うと良いでしょう。このクラ"
"スは良く設計されていて、高速な追加（append）と取り出し（pop）を両端に対して実"
"現しています。例えば以下のようにします::"

#: ../../tutorial/datastructures.rst:175
msgid "Functional Programming Tools"
msgstr "関数型プログラミング用ツール"

#: ../../tutorial/datastructures.rst:177
msgid ""
"There are three built-in functions that are very useful when used with "
"lists: :func:`filter`, :func:`map`, and :func:`reduce`."
msgstr ""
"組み込み関数には、リストに対して使うと非常に便利なものが三つあります。 :func:"
"`filter`, :func:`map`, :func:`reduce` です。"

#: ../../tutorial/datastructures.rst:180
msgid ""
"``filter(function, sequence)`` returns a sequence consisting of those items "
"from the sequence for which ``function(item)`` is true. If *sequence* is a :"
"class:`str`, :class:`unicode` or :class:`tuple`, the result will be of the "
"same type; otherwise, it is always a :class:`list`.  For example, to compute "
"a sequence of numbers divisible by 3 or 5::"
msgstr ""
"``filter(function, sequence)`` は、シーケンス *sequence* 中の要素 *item* か"
"ら、 ``function(item)`` が真となるような要素からなるシーケンスを返します。も"
"し *sequence* が :class:`str` か :class:`unicode` か :class:`tuple` なら、返"
"り値も同じ型になります。そうでなければ :class:`list` になります。例えば、次の"
"コードは 3 または 5 で割り切れる数のリストを作ります::"

#: ../../tutorial/datastructures.rst:191
msgid ""
"``map(function, sequence)`` calls ``function(item)`` for each of the "
"sequence's items and returns a list of the return values.  For example, to "
"compute some cubes::"
msgstr ""
"``map(function, sequence)`` は、シーケンス *sequence* の各要素 *item* に対し"
"て ``function(item)`` を呼び出し、その戻り値からなるリストを返します。例え"
"ば、三乗された値の列を計算するには以下のようにします。"

#: ../../tutorial/datastructures.rst:200
msgid ""
"More than one sequence may be passed; the function must then have as many "
"arguments as there are sequences and is called with the corresponding item "
"from each sequence (or ``None`` if some sequence is shorter than another).  "
"For example::"
msgstr ""
"複数のシーケンスを渡すこともできます。その場合、第一引数の関数はシーケンスの"
"数と等しい数の引数を受け取る必要があり、各シーケンスの値が渡されます。 (幾つ"
"かのシーケンスが他のシーケンスよりも短かった場合は、その場所には ``None`` が"
"渡されます。) 例です。"

#: ../../tutorial/datastructures.rst:211
msgid ""
"``reduce(function, sequence)`` returns a single value constructed by calling "
"the binary function *function* on the first two items of the sequence, then "
"on the result and the next item, and so on.  For example, to compute the sum "
"of the numbers 1 through 10::"
msgstr ""
"``reduce(function, sequence)`` は単一の値を返します。この値は 2 つの引数をと"
"る関数 *function* をシーケンス *sequence* の最初の二つの要素を引数として呼び"
"出し、次にその結果とシーケンスの次の要素を引数にとり、以降これを繰り返してい"
"きます。例えば、 1 から 10 までの数の総和を計算するには以下のようにします。"

#: ../../tutorial/datastructures.rst:221
msgid ""
"If there's only one item in the sequence, its value is returned; if the "
"sequence is empty, an exception is raised."
msgstr ""
"シーケンス中にただ一つしか要素がなければ、その値自体が返されます。シーケンス"
"が空なら、例外が送出されます。"

#: ../../tutorial/datastructures.rst:224
msgid ""
"A third argument can be passed to indicate the starting value.  In this case "
"the starting value is returned for an empty sequence, and the function is "
"first applied to the starting value and the first sequence item, then to the "
"result and the next item, and so on.  For example, ::"
msgstr ""
"3 つめの引数をわたして、初期値を指定することもできます。この場合、空のシーケ"
"ンスを渡すと初期値が返されます。それ以外の場合には、まず初期値とシーケンス中"
"の最初の要素に対して関数が適用され、次いでその結果とシーケンスの次の要素に対"
"して適用され、以降これが繰り返されます。例えば以下のようになります。"

#: ../../tutorial/datastructures.rst:238
msgid ""
"Don't use this example's definition of :func:`sum`: since summing numbers is "
"such a common need, a built-in function ``sum(sequence)`` is already "
"provided, and works exactly like this."
msgstr ""
"実際には、上の例のように :func:`sum` を定義しないでください。数値の合計は広く"
"必要とされている操作なので、すでに組み込み関数 ``sum(sequence)`` が提供されて"
"おり、上の例と全く同様に動作します。"

#: ../../tutorial/datastructures.rst:245
msgid "List Comprehensions"
msgstr "リストの内包表記"

#: ../../tutorial/datastructures.rst:247
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"リスト内包表記はリストを生成する簡潔な手段を提供しています。主な利用場面は、"
"あるシーケンスや iterable (イテレート可能オブジェクト) のそれぞれの要素に対し"
"てある操作を行った結果を要素にしたリストを作ったり、ある条件を満たす要素だけ"
"からなる部分シーケンスを作成することです。"

#: ../../tutorial/datastructures.rst:252
msgid "For example, assume we want to create a list of squares, like::"
msgstr "例えば、次のような平方のリストを作りたいとします::"

#: ../../tutorial/datastructures.rst:261
msgid "We can obtain the same result with::"
msgstr "同じリストを次のように作れます::"

#: ../../tutorial/datastructures.rst:265
msgid ""
"This is also equivalent to ``squares = map(lambda x: x**2, range(10))``, but "
"it's more concise and readable."
msgstr ""
"これは ``squares = map(lambda x: x**2, range(10))`` とも等価ですが、より簡潔"
"で読みやすいです。"

#: ../../tutorial/datastructures.rst:268
msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`for` clause, then zero or more :keyword:`for` or :keyword:"
"`if` clauses.  The result will be a new list resulting from evaluating the "
"expression in the context of the :keyword:`for` and :keyword:`if` clauses "
"which follow it. For example, this listcomp combines the elements of two "
"lists if they are not equal::"
msgstr ""
"リスト内包表記は、括弧の中の 式、 :keyword:`for` 句、そして0個以上の :"
"keyword:`for` か :keyword:`if` 句で構成されます。リスト内包表記の実行結果"
"は、 :keyword:`for` と :keyword:`if` 句のコンテキスト中で式を評価した結果から"
"なる新しいリストです。例えば、次のリスト内包表記は2つのリストの要素から、違う"
"もの同士をペアにします::"

#: ../../tutorial/datastructures.rst:278
msgid "and it's equivalent to:"
msgstr "これは次のコードと等価です::"

#: ../../tutorial/datastructures.rst:289
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the "
"same in both these snippets."
msgstr ""
":keyword:`for` と :keyword:`if` 文が両方のコードで同じ順序になっていることに"
"注目してください。"

#: ../../tutorial/datastructures.rst:292
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr ""
"式がタプルの場合 (例: 上の例で式が ``(x, y)`` の場合) は、タプルに円括弧が必"
"要です。 ::"

#: ../../tutorial/datastructures.rst:323
msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr "リスト内包表記の式には、複雑な式や関数呼び出しのネストができます::"

#: ../../tutorial/datastructures.rst:331
msgid "Nested List Comprehensions"
msgstr "ネストしたリストの内包表記"

#: ../../tutorial/datastructures.rst:333
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"リスト内包表記中の最初の式は任意の式なので、そこに他のリスト内包表記を書くこ"
"ともできます。"

#: ../../tutorial/datastructures.rst:336
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr "次の、長さ4のリスト3つからなる、3x4 の matrix について考えます::"

#: ../../tutorial/datastructures.rst:345
msgid "The following list comprehension will transpose rows and columns::"
msgstr "次のリスト内包表記は、matrix の行と列を入れ替えます::"

#: ../../tutorial/datastructures.rst:350
msgid ""
"As we saw in the previous section, the nested listcomp is evaluated in the "
"context of the :keyword:`for` that follows it, so this example is equivalent "
"to::"
msgstr ""
"前の節で見たように、ネストしたリスト内包表記は、続く :keyword:`for` のコンテ"
"キストの中で評価されます。なので、この例は次のコードと等価です::"

#: ../../tutorial/datastructures.rst:361
msgid "which, in turn, is the same as::"
msgstr "これをもう一度変換すると、次のコードと等価になります::"

#: ../../tutorial/datastructures.rst:375
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use case::"
msgstr ""
"実際には複雑な流れの式よりも組み込み関数を使う方が良いです。この場合 :func:"
"`zip` 関数が良い仕事をしてくれるでしょう::"

#: ../../tutorial/datastructures.rst:381
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""
"この行にあるアスタリスクの詳細については :ref:`tut-unpacking-arguments` を参"
"照してください。"

#: ../../tutorial/datastructures.rst:386
msgid "The :keyword:`del` statement"
msgstr ":keyword:`del` 文"

#: ../../tutorial/datastructures.rst:388
msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`pop` "
"method which returns a value.  The :keyword:`del` statement can also be used "
"to remove slices from a list or clear the entire list (which we did earlier "
"by assignment of an empty list to the slice).  For example::"
msgstr ""
"リストから要素を削除する際、値を指定する代わりにインデックスを指定する方法が"
"あります。それが :keyword:`del` 文です。これは :meth:`pop` メソッドと違い、値"
"を返しません。 :keyword:`del` 文はリストからスライスを除去したり、リスト全体"
"を削除することもできます(以前はスライスに空のリストを代入して行っていまし"
"た)。例えば以下のようにします::"

#: ../../tutorial/datastructures.rst:405
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ":keyword:`del` は変数全体の削除にも使えます::"

#: ../../tutorial/datastructures.rst:409
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"この文の後で名前 ``a`` を参照すると、(別の値を ``a`` に代入するまで) エラーに"
"なります。 :keyword:`del` の別の用途についてはまた後で取り上げます。"

#: ../../tutorial/datastructures.rst:416
msgid "Tuples and Sequences"
msgstr "タプルとシーケンス"

#: ../../tutorial/datastructures.rst:418
msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types "
"(see :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type: "
"the *tuple*."
msgstr ""
"リストや文字列には、インデクスやスライスを使った演算のように、数多くの共通の"
"性質があることを見てきました。これらは *シーケンス (sequence)* データ型 (:"
"ref:`typesseq` を参照) の二つの例です。 Python はまだ進歩の過程にある言語なの"
"で、他のシーケンスデータ型が追加されるかもしれません。標準のシーケンス型はも"
"う一つあります: *タプル (tuple)* 型です。"

#: ../../tutorial/datastructures.rst:424
msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr ""
"タプルはコンマで区切られたいくつかの値からなります。例えば以下のように書きま"
"す::"

#: ../../tutorial/datastructures.rst:446
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if "
"the tuple is part of a larger expression).  It is not possible to assign to "
"the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"ご覧のとおり、タプルの表示には常に丸括弧がついていて、タプルのネストが正しく"
"解釈されるようになっています。タプルを書くときは必ずしも丸括弧で囲まなくても"
"いいですが、(タプルが大きな式の一部だった場合は) 丸括弧が必要な場合もありま"
"す。タプルの要素を代入することはできません。しかし、タプルにリストのような変"
"更可能型を含めることはできます。"

#: ../../tutorial/datastructures.rst:453
msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are :term:"
"`mutable`, and their elements are usually homogeneous and are accessed by "
"iterating over the list."
msgstr ""
"タプルはリストと似ていますが、たいてい異なる場面と異なる目的で利用されます。"
"タプルは不変型 (:term:`immutable`) で、複数の型の要素からなることもあり、要素"
"はアンパック(この節の後半に出てきます)操作やインデックス (あるいは :func:"
"`namedtuples <collections.namedtuple>` の場合は属性)でアクセスすることが多い"
"です。一方、リストは変更可能 (:term:`mutable`) で、要素はたいてい同じ型のオブ"
"ジェクトであり、たいていイテレートによってアクセスします。"

#: ../../tutorial/datastructures.rst:461
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the "
"syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"問題は 0 個または 1 個の項目からなるタプルの構築です。これらの操作を行うた"
"め、構文には特別な細工がされています。空のタプルは空の丸括弧ペアで構築できま"
"す。一つの要素を持つタプルは、値の後ろにコンマを続ける (単一の値を丸括弧で囲"
"むだけでは不十分です) ことで構築できます。美しくはないけれども、効果的です。"
"例えば以下のようにします::"

#: ../../tutorial/datastructures.rst:476
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"文 ``t = 12345, 54321, 'hello!'`` は *タプルのパック (tuple packing)* の例で"
"す。値 ``12345``, ``54321``, ``'hello!'`` が一つのタプルにパックされます。逆"
"の演算も可能です::"

#: ../../tutorial/datastructures.rst:482
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any "
"sequence on the right-hand side.  Sequence unpacking requires the list of "
"variables on the left to have the same number of elements as the length of "
"the sequence.  Note that multiple assignment is really just a combination of "
"tuple packing and sequence unpacking."
msgstr ""
"この操作は、 *シーケンスのアンパック (sequence unpacking)* とでも呼ぶべきもの"
"で、右辺には全てのシーケンス型を使うことができます。シーケンスのアンパックで"
"は、左辺に列挙されている変数が、右辺のシーケンスの長さと同じであることが要求"
"されます。複数同時の代入が実はタプルのパックとシーケンスのアンパックを組み合"
"わせたものに過ぎないことに注意してください。"

#: ../../tutorial/datastructures.rst:492
msgid "Sets"
msgstr "集合型"

#: ../../tutorial/datastructures.rst:494
msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""
"Python には、 *集合 (set)* を扱うためのデータ型もあります。集合とは、重複する"
"要素をもたない、順序づけられていない要素の集まりです。 Set オブジェクトは、結"
"合 (union)、交差 (intersection)、差分 (difference)、対称差 (symmetric "
"difference)といった数学的な演算もサポートしています。"

#: ../../tutorial/datastructures.rst:499
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"中括弧、または :func:`set` 関数は set を生成するために使用することができま"
"す。注: 空集合を作成するためには ``set()`` を使用しなければなりません (``{}"
"`` ではなく)。後者は空の辞書を作成します。辞書は次のセクションで議論するデー"
"タ構造です。"

#: ../../tutorial/datastructures.rst:503
msgid "Here is a brief demonstration::"
msgstr "簡単なデモンストレーションを示します::"

#: ../../tutorial/datastructures.rst:529
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ""
":ref:`リスト内包 <tut-listcomps>` と同様に、 set 内包もサポートされています::"

#: ../../tutorial/datastructures.rst:540
msgid "Dictionaries"
msgstr "辞書"

#: ../../tutorial/datastructures.rst:542
msgid ""
"Another useful data type built into Python is the *dictionary* (see :ref:"
"`typesmapping`). Dictionaries are sometimes found in other languages as "
"\"associative memories\" or \"associative arrays\".  Unlike sequences, which "
"are indexed by a range of numbers, dictionaries are indexed by *keys*, which "
"can be any immutable type; strings and numbers can always be keys.  Tuples "
"can be used as keys if they contain only strings, numbers, or tuples; if a "
"tuple contains any mutable object either directly or indirectly, it cannot "
"be used as a key. You can't use lists as keys, since lists can be modified "
"in place using index assignments, slice assignments, or methods like :meth:"
"`append` and :meth:`extend`."
msgstr ""
"もう一つ、有用な型が Python に組み込まれています。それは *辞書 (dictionary)* "
"(:ref:`typesmapping` を参照)です。辞書は他の言語にも \"連想記憶 (associated "
"memory)\" や \"連想配列 (associative array)\" という名前で存在することがあり"
"ます。ある範囲の数でインデクス化されているシーケンスと異なり、辞書は *キー "
"(key)* でインデクス化されています。このキーは何らかの変更不能な型になります。"
"文字列、数値は常にキーにすることができます。タプルは、文字列、数値、その他の"
"タプルのみを含む場合はキーにすることができます。直接、あるいは間接的に変更可"
"能なオブジェクトを含むタプルはキーにできません。リストをキーとして使うことは"
"できません。これは、リストにスライスやインデクス指定の代入を行ったり、 :meth:"
"`append` や :meth:`extend` のようなメソッドを使うと、インプレースで変更するこ"
"とができるためです。"

#: ../../tutorial/datastructures.rst:553
msgid ""
"It is best to think of a dictionary as an unordered set of *key: value* "
"pairs, with the requirement that the keys are unique (within one "
"dictionary). A pair of braces creates an empty dictionary: ``{}``. Placing a "
"comma-separated list of key:value pairs within the braces adds initial key:"
"value pairs to the dictionary; this is also the way dictionaries are written "
"on output."
msgstr ""
"辞書は順序付けのされていない *キー(key): 値(value)* のペアの集合であり、キー"
"が (辞書の中で)一意でければならない、と考えるとよいでしょう。波括弧 (brace) "
"のペア: ``{}`` は空の辞書を生成します。カンマで区切られた key: value のペアを"
"波括弧ペアの間に入れると、辞書の初期値となる key: value が追加されます; この"
"表現方法は出力時に辞書が書き出されるのと同じ方法です。"

#: ../../tutorial/datastructures.rst:559
msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a key:"
"value pair with ``del``. If you store using a key that is already in use, "
"the old value associated with that key is forgotten.  It is an error to "
"extract a value using a non-existent key."
msgstr ""
"辞書での主な操作は、ある値を何らかのキーを付けて記憶することと、キーを指定し"
"て値を取り出すことです。 ``del`` で key: value のペアを削除することもできま"
"す。すでに使われているキーを使って値を記憶すると、以前そのキーに関連づけられ"
"ていた値は忘れ去られてしまいます。存在しないキーを使って値を取り出そうとする"
"とエラーになります。"

#: ../../tutorial/datastructures.rst:565
msgid ""
"The :meth:`keys` method of a dictionary object returns a list of all the "
"keys used in the dictionary, in arbitrary order (if you want it sorted, just "
"apply the :func:`sorted` function to it).  To check whether a single key is "
"in the dictionary, use the :keyword:`in` keyword."
msgstr ""
"辞書オブジェクトの :meth:`keys` メソッドは、辞書で使われている全てのキーから"
"なるリストを適当な順番で返します (ソートされたリストが欲しい場合は、このキー"
"のリストに :meth:`sorted` を使ってください)。ある単一のキーが辞書にあるかどう"
"か調べるには、 :keyword:`in` キーワードを使います。"

#: ../../tutorial/datastructures.rst:570
msgid "Here is a small example using a dictionary::"
msgstr "以下に、辞書を使った簡単な例を示します::"

#: ../../tutorial/datastructures.rst:587
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ""
":func:`dict` コンストラクタは、キーと値のペアのタプルを含むリストから辞書を生"
"成します::"

#: ../../tutorial/datastructures.rst:593
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr "さらに、辞書内包表現を使って、任意のキーと値のペアから辞書を作れます::"

#: ../../tutorial/datastructures.rst:599
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""
"キーが単純な文字列の場合、キーワード引数を使って定義する方が単純な場合もあり"
"ます::"

#: ../../tutorial/datastructures.rst:609
msgid "Looping Techniques"
msgstr "ループのテクニック"

#: ../../tutorial/datastructures.rst:611
msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"シーケンスにわたるループを行う際、 :func:`enumerate` 関数を使うと、要素のイン"
"デックスと要素を同時に取り出すことができます。 ::"

#: ../../tutorial/datastructures.rst:621
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"二つまたはそれ以上のシーケンス型を同時にループするために、関数 :func:`zip` を"
"使って各要素をひと組みにすることができます。 ::"

#: ../../tutorial/datastructures.rst:633
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"シーケンスを逆方向に渡ってループするには、まずシーケンスの範囲を順方向に指定"
"し、次いで関数 :func:`reversed` を呼び出します。 ::"

#: ../../tutorial/datastructures.rst:645
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"シーケンスをソートされた順序でループするには、 :func:`sorted` 関数を使いま"
"す。この関数は元の配列を変更せず、ソート済みの新たな配列を返します。 ::"

#: ../../tutorial/datastructures.rst:657
msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`iteritems` method. ::"
msgstr ""
"辞書に対してループを行う際、 :meth:`iteritems` メソッドを使うと、キーとそれに"
"対応する値を同時に取り出せます。 ::"

#: ../../tutorial/datastructures.rst:667
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"ときどきループ内でリストを変更したい誘惑に駆られるでしょうが、代わりに新しい"
"リストを作ってしまうほうがより簡単で安全なことが、ままあります ::"

#: ../../tutorial/datastructures.rst:684
msgid "More on Conditions"
msgstr "条件についてもう少し"

#: ../../tutorial/datastructures.rst:686
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"``while`` や ``if`` 文で使った条件 (condition) には、値の比較だけでなく、他の"
"演算子も使うことができます。"

#: ../../tutorial/datastructures.rst:689
msgid ""
"The comparison operators ``in`` and ``not in`` check whether a value occurs "
"(does not occur) in a sequence.  The operators ``is`` and ``is not`` compare "
"whether two objects are really the same object; this only matters for "
"mutable objects like lists.  All comparison operators have the same "
"priority, which is lower than that of all numerical operators."
msgstr ""
"比較演算子 ``in`` および ``not in`` は、ある値があるシーケンス中に存在するか "
"(または存在しないか) どうかを調べます。演算子 ``is`` および ``is not`` は、二"
"つのオブジェクトが実際に同じオブジェクトであるかどうかを調べます。この比較"
"は、リストのような変更可能なオブジェクトにだけ意味があります。全ての比較演算"
"子は同じ優先順位を持っており、ともに数値演算子よりも低い優先順位となります。"
"(訳注: ``is`` は、 ``is None`` のように、シングルトンの変更不能オブジェクトと"
"の比較に用いる場合もあります。(「変更可能なオブジェクトにだけ意味があります」"
"の部分を削除することを Doc-SIG に提案中。))"

#: ../../tutorial/datastructures.rst:695
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` "
"is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"比較は連結させることができます。例えば、 ``a < b == c`` は、 ``a`` が ``b`` "
"より小さく、かつ ``b`` と ``c`` が等しいかどうかをテストします。"

#: ../../tutorial/datastructures.rst:698
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"ブール演算子 ``and`` や ``or`` で比較演算を組み合わせることができます。そし"
"て、比較演算 (あるいは何らかのブール式) の結果の否定は ``not`` でとれます。こ"
"れらの演算子は全て、比較演算子よりも低い優先順位になっています。 ``A and not "
"B or C`` と ``(A and (not B)) or C`` が等価になるように、ブール演算子の中"
"で、 ``not`` の優先順位が最も高く、 ``or`` が最も低くなっています。もちろん、"
"丸括弧を使えば望みの組み合わせを表現できます。"

#: ../../tutorial/datastructures.rst:705
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C`` "
"are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"ブール演算子 ``and`` と ``or`` は、いわゆる *短絡 (short-circuit)* 演算子で"
"す。これらの演算子の引数は左から右へと順に評価され、結果が確定した時点で評価"
"を止めます。例えば、 ``A`` と ``C`` は真で ``B`` が偽のとき、 ``A and B and "
"C`` は式 ``C`` を評価しません。一般に、短絡演算子の戻り値をブール値ではなくて"
"一般的な値として用いると、値は最後に評価された引数になります。"

#: ../../tutorial/datastructures.rst:712
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr "比較や他のブール式の結果を変数に代入することもできます。例えば、 ::"

#: ../../tutorial/datastructures.rst:720
msgid ""
"Note that in Python, unlike C, assignment cannot occur inside expressions. C "
"programmers may grumble about this, but it avoids a common class of problems "
"encountered in C programs: typing ``=`` in an expression when ``==`` was "
"intended."
msgstr ""
"Python では、C 言語と違って、式の内部で代入を行えないので注意してください。 "
"C 言語のプログラマは不満に思うかもしれませんが、この仕様は、 C 言語プログラム"
"で遭遇する、式の中で ``==`` のつもりで ``=`` とタイプしてしまうといったありふ"
"れた問題を回避します。"

#: ../../tutorial/datastructures.rst:729
msgid "Comparing Sequences and Other Types"
msgstr "シーケンスとその他の型の比較"

#: ../../tutorial/datastructures.rst:731
msgid ""
"Sequence objects may be compared to other objects with the same sequence "
"type. The comparison uses *lexicographical* ordering: first the first two "
"items are compared, and if they differ this determines the outcome of the "
"comparison; if they are equal, the next two items are compared, and so on, "
"until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the ASCII ordering for individual "
"characters.  Some examples of comparisons between sequences of the same "
"type::"
msgstr ""
"シーケンスオブジェクトは同じシーケンス型の他のオブジェクトと比較できます。比"
"較には *辞書的な (lexicographical)* 順序が用いられます。まず、最初の二つの要"
"素を比較し、その値が等しくなければその時点で比較結果が決まります。等しければ"
"次の二つの要素を比較し、以降シーケンスの要素が尽きるまで続けます。比較しよう"
"とする二つの要素がいずれも同じシーケンス型であれば、そのシーケンス間での辞書"
"比較を再帰的に行います。二つのシーケンスの全ての要素の比較結果が等しくなれ"
"ば、シーケンスは等しいとみなされます。片方のシーケンスがもう一方の先頭部分に"
"あたる部分シーケンスならば、短い方のシーケンスが小さいシーケンスとみなされま"
"す。文字列に対する辞書的な順序づけには、個々の文字ごとに ASCII 順序を用いま"
"す。以下に、同じ型のオブジェクトを持つシーケンス間での比較を行った例を示しま"
"す。"

#: ../../tutorial/datastructures.rst:751
msgid ""
"Note that comparing objects of different types is legal.  The outcome is "
"deterministic but arbitrary: the types are ordered by their name. Thus, a "
"list is always smaller than a string, a string is always smaller than a "
"tuple, etc. [#]_ Mixed numeric types are compared according to their numeric "
"value, so 0 equals 0.0, etc."
msgstr ""
"違う型のオブジェクト間の比較は認められていることに注意してください。比較結果"
"は決定性がありますが、その決め方は、型は型の名前で順番づけられる、という恣意"
"的なものです。従って、リスト (list) 型は常に文字列 (string) 型よりも小さく、"
"文字列型は常にタプル (tuple) よりも小さい、といった具合になります。 [#]_ 型混"
"合の数値の比較は、数値そのものに従って比較されるので、例えば 0 は 0.0 と等し"
"い、という結果になります。"

#: ../../tutorial/datastructures.rst:759
msgid "Footnotes"
msgstr "注記"

#: ../../tutorial/datastructures.rst:760
msgid ""
"The rules for comparing objects of different types should not be relied "
"upon; they may change in a future version of the language."
msgstr ""
"異なる型のオブジェクトを比較するための規則を今後にわたって当てにしてはなりま"
"せん。 Python 言語の将来のバージョンでは変更されるかもしれません。"
