# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-05 15:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../tutorial/errors.rst:5
msgid "Errors and Exceptions"
msgstr "ã‚¨ãƒ©ãƒ¼ã¨ä¾‹å¤–"

#: ../../tutorial/errors.rst:7
msgid ""
"Until now error messages haven't been more than mentioned, but if you have "
"tried out the examples you have probably seen some.  There are (at least) "
"two distinguishable kinds of errors: *syntax errors* and *exceptions*."
msgstr ""
"ã“ã‚Œã¾ã§ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¤ã„ã¦ã¯ç°¡å˜ã«è§¦ã‚Œã‚‹ã ã‘ã§ã—ãŸãŒã€ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ä¸­ã®ä¾‹ã‚’è‡ªåˆ†ã§è©¦ã—ã¦ã„ãŸã‚‰ã€å®Ÿéš›ã«ã„ãã¤ã‹ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¦‹ã¦ã„ã‚‹ã“ã¨ã§ã—ã‚‡ã†ã€‚ã‚¨ãƒ©ãƒ¼ã«ã¯"
" (å°‘ãªãã¨ã‚‚) äºŒã¤ã®ã¯ã£ãã‚Šç•°ãªã‚‹ç¨®é¡ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã¯ *æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ (syntax error)* ã¨ *ä¾‹å¤– (exception)* ã§ã™ã€‚"

#: ../../tutorial/errors.rst:15
msgid "Syntax Errors"
msgstr "æ§‹æ–‡ã‚¨ãƒ©ãƒ¼"

#: ../../tutorial/errors.rst:17
msgid ""
"Syntax errors, also known as parsing errors, are perhaps the most common "
"kind of complaint you get while you are still learning Python::"
msgstr ""
"æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã¯æ§‹æ–‡è§£æã‚¨ãƒ©ãƒ¼ (parsing error) ã¨ã—ã¦ã‚‚çŸ¥ã‚‰ã‚Œã¦ãŠã‚Šã€Python ã‚’å‹‰å¼·ã—ã¦ã„ã‚‹é–“ã«æœ€ã‚‚ã‚ˆãé­é‡ã™ã‚‹å•é¡Œã®ä¸€ã¤ã§ã—ã‚‡ã†::"

#: ../../tutorial/errors.rst:26
msgid ""
"The parser repeats the offending line and displays a little 'arrow' pointing"
" at the earliest point in the line where the error was detected.  The error "
"is caused by (or at least detected at) the token *preceding* the arrow: in "
"the example, the error is detected at the function :func:`print`, since a "
"colon (``':'``) is missing before it.  File name and line number are printed"
" so you know where to look in case the input came from a script."
msgstr ""
"ãƒ‘ãƒ¼ã‚µã¯é•åã®èµ·ãã¦ã„ã‚‹è¡Œã‚’è¡¨ç¤ºã—ã€å°ã•ãªã€ŒçŸ¢å°ã€ã‚’è¡¨ç¤ºã—ã¦ã€è¡Œä¸­ã§ã‚¨ãƒ©ãƒ¼ãŒæ¤œå‡ºã•ã‚ŒãŸæœ€åˆã®ä½ç½®ã‚’ç¤ºã—ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ã¯çŸ¢å°ã® *ç›´å‰ã®* "
"ãƒˆãƒ¼ã‚¯ãƒ³ã§ã²ãèµ·ã“ã•ã‚Œã¦ã„ã¾ã™ (ã¾ãŸã¯ã€å°‘ãªãã¨ã‚‚ãã“ã§æ¤œå‡ºã•ã‚Œã¦ã„ã¾ã™)ã€‚ä¸Šè¨˜ã®ä¾‹ã§ã¯ã€ã‚¨ãƒ©ãƒ¼ã¯é–¢æ•° :func:`print` "
"ã§æ¤œå‡ºã•ã‚Œã¦ã„ã¾ã™ã€‚ã‚³ãƒ­ãƒ³ (``':'``) "
"ãŒãã®å‰ã«ç„¡ã„ã‹ã‚‰ã§ã™ã€‚å…¥åŠ›ãŒã‚¹ã‚¯ãƒªãƒ—ãƒˆã‹ã‚‰æ¥ã¦ã„ã‚‹å ´åˆã¯ã€ã©ã“ã‚’è¦‹ã‚Œã°ã‚ˆã„ã‹åˆ†ã‹ã‚‹ã‚ˆã†ã«ãƒ•ã‚¡ã‚¤ãƒ«åã¨è¡Œç•ªå·ãŒå‡ºåŠ›ã•ã‚Œã¾ã™ã€‚"

#: ../../tutorial/errors.rst:37
msgid "Exceptions"
msgstr "ä¾‹å¤–"

#: ../../tutorial/errors.rst:39
msgid ""
"Even if a statement or expression is syntactically correct, it may cause an "
"error when an attempt is made to execute it. Errors detected during "
"execution are called *exceptions* and are not unconditionally fatal: you "
"will soon learn how to handle them in Python programs.  Most exceptions are "
"not handled by programs, however, and result in error messages as shown "
"here::"
msgstr ""
"ãŸã¨ãˆæ–‡ã‚„å¼ãŒæ§‹æ–‡çš„ã«æ­£ã—ãã¦ã‚‚ã€å®Ÿè¡Œã—ã‚ˆã†ã¨ã—ãŸã¨ãã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚å®Ÿè¡Œä¸­ã«æ¤œå‡ºã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ã¯ *ä¾‹å¤– (exception)* "
"ã¨å‘¼ã°ã‚Œã€å¸¸ã«è‡´å‘½çš„ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã‹ã‚‰ã€Python "
"ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ä¾‹å¤–ã‚’ã©ã®ã‚ˆã†ã«æ‰±ã†ã‹ã‚’å­¦ã‚“ã§ã„ãã¾ã™ã€‚ã»ã¨ã‚“ã©ã®ä¾‹å¤–ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§å‡¦ç†ã•ã‚Œãšã€ä»¥ä¸‹ã«ç¤ºã•ã‚Œã‚‹ã‚ˆã†ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ãªã‚Šã¾ã™::"

#: ../../tutorial/errors.rst:58
msgid ""
"The last line of the error message indicates what happened. Exceptions come "
"in different types, and the type is printed as part of the message: the "
"types in the example are :exc:`ZeroDivisionError`, :exc:`NameError` and "
":exc:`TypeError`. The string printed as the exception type is the name of "
"the built-in exception that occurred.  This is true for all built-in "
"exceptions, but need not be true for user-defined exceptions (although it is"
" a useful convention). Standard exception names are built-in identifiers "
"(not reserved keywords)."
msgstr ""
"ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æœ€çµ‚è¡Œã¯ä½•ãŒèµ·ã“ã£ãŸã‹ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ä¾‹å¤–ã¯æ§˜ã€…ãªå‹ (type) "
"ã§èµ·ã“ã‚Šã€ãã®å‹ãŒã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ä¸€éƒ¨ã¨ã—ã¦å‡ºåŠ›ã•ã‚Œã¾ã™ã€‚ä¸Šã®ä¾‹ã§ã®å‹ã¯ :exc:`ZeroDivisionError`, "
":exc:`NameError`, :exc:`TypeError` "
"ã§ã™ã€‚ä¾‹å¤–å‹ã¨ã—ã¦å‡ºåŠ›ã•ã‚Œã‚‹æ–‡å­—åˆ—ã¯ã€ç™ºç”Ÿã—ãŸä¾‹å¤–ã®çµ„ã¿è¾¼ã¿åã§ã™ã€‚ã“ã‚Œã¯å…¨ã¦ã®çµ„ã¿è¾¼ã¿ä¾‹å¤–ã«ã¤ã„ã¦æˆã‚Šç«‹ã¡ã¾ã™ãŒã€ãƒ¦ãƒ¼ã‚¶å®šç¾©ã®ä¾‹å¤–ã§ã¯ "
"(æˆã‚Šç«‹ã¤ã‚ˆã†ã«ã™ã‚‹ã®ã¯æœ‰æ„ç¾©ãªæ…£ç¿’ã§ã™ãŒ) å¿…ãšã—ã‚‚æˆã‚Šç«‹ã¡ã¾ã›ã‚“ã€‚æ¨™æº–ä¾‹å¤–ã®åå‰ã¯çµ„ã¿è¾¼ã¿ã®è­˜åˆ¥å­ã§ã™ (äºˆç´„èªã§ã¯ã‚ã‚Šã¾ã›ã‚“)ã€‚"

#: ../../tutorial/errors.rst:66
msgid ""
"The rest of the line provides detail based on the type of exception and what"
" caused it."
msgstr "æ®‹ã‚Šã®è¡Œã¯ä¾‹å¤–ã®è©³ç´°ã§ã€ãã®ä¾‹å¤–ã®å‹ã¨ä½•ãŒèµ·ããŸã‹ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../tutorial/errors.rst:69
msgid ""
"The preceding part of the error message shows the context where the "
"exception happened, in the form of a stack traceback. In general it contains"
" a stack traceback listing source lines; however, it will not display lines "
"read from standard input."
msgstr ""
"ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å…ˆé ­éƒ¨åˆ†ã§ã¯ã€ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸå®Ÿè¡Œã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ (context) ã‚’ã€ã‚¹ã‚¿ãƒƒã‚¯ã®ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ (stack traceback) "
"ã®å½¢å¼ã§ç¤ºã—ã¦ã„ã¾ã™ã€‚ä¸€èˆ¬ã«ã¯ã€ã“ã®éƒ¨åˆ†ã«ã¯ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰è¡Œã‚’ãƒªã‚¹ãƒˆã—ãŸãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€æ¨™æº–å…¥åŠ›ã‹ã‚‰èª­ã¿å–ã‚‰ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã¯è¡¨ç¤ºã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../tutorial/errors.rst:74
msgid ""
":ref:`bltin-exceptions` lists the built-in exceptions and their meanings."
msgstr ":ref:`bltin-exceptions` ã«ã¯ã€çµ„ã¿è¾¼ã¿ä¾‹å¤–ã¨ãã®æ„å‘³ãŒãƒªã‚¹ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/errors.rst:80
msgid "Handling Exceptions"
msgstr "ä¾‹å¤–ã‚’å‡¦ç†ã™ã‚‹"

#: ../../tutorial/errors.rst:82
msgid ""
"It is possible to write programs that handle selected exceptions. Look at "
"the following example, which asks the user for input until a valid integer "
"has been entered, but allows the user to interrupt the program (using "
":kbd:`Control-C` or whatever the operating system supports); note that a "
"user-generated interruption is signalled by raising the "
":exc:`KeyboardInterrupt` exception. ::"
msgstr ""
"ä¾‹å¤–ã‚’é¸åˆ¥ã—ã¦å‡¦ç†ã™ã‚‹ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚ä»¥ä¸‹ã®ä¾‹ã‚’è¦‹ã¦ãã ã•ã„ã€‚ã“ã®ä¾‹ã§ã¯ã€æœ‰åŠ¹ãªæ–‡å­—åˆ—ãŒå…¥åŠ›ã•ã‚Œã‚‹ã¾ã§ãƒ¦ãƒ¼ã‚¶ã«å…¥åŠ›ã‚’ä¿ƒã—ã¾ã™ãŒã€ãƒ¦ãƒ¼ã‚¶ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«"
" (:kbd:`Control-C` ã‹ã€ã¾ãŸã¯ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ãŒã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ä½•ã‚‰ã‹ã®ã‚­ãƒ¼ã‚’ä½¿ã£ã¦) "
"å‰²ã‚Šè¾¼ã¿ã‚’ã‹ã‘ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä¸­æ–­ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãŒç”Ÿæˆã—ãŸå‰²ã‚Šè¾¼ã¿ã¯ã€ :exc:`KeyboardInterrupt` "
"ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã‚‹ã“ã¨ã§é€šçŸ¥ã•ã‚Œã‚‹ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ ::"

#: ../../tutorial/errors.rst:96
msgid "The :keyword:`try` statement works as follows."
msgstr ":keyword:`try` æ–‡ã¯ä¸‹è¨˜ã®ã‚ˆã†ã«å‹•ä½œã—ã¾ã™ã€‚"

#: ../../tutorial/errors.rst:98
msgid ""
"First, the *try clause* (the statement(s) between the :keyword:`try` and "
":keyword:`except` keywords) is executed."
msgstr ""
"ã¾ãšã€ *try ç¯€ (try clause)* (ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ :keyword:`try` ã¨ :keyword:`except` ã®é–“ã®æ–‡) "
"ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../tutorial/errors.rst:101
msgid ""
"If no exception occurs, the *except clause* is skipped and execution of the "
":keyword:`try` statement is finished."
msgstr "ä½•ã‚‚ä¾‹å¤–ãŒç™ºç”Ÿã—ãªã‘ã‚Œã°ã€ *except ç¯€* ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ :keyword:`try` æ–‡ã®å®Ÿè¡Œã‚’çµ‚ãˆã¾ã™ã€‚"

#: ../../tutorial/errors.rst:104
msgid ""
"If an exception occurs during execution of the try clause, the rest of the "
"clause is skipped.  Then if its type matches the exception named after the "
":keyword:`except` keyword, the except clause is executed, and then execution"
" continues after the :keyword:`try` statement."
msgstr ""
"try ç¯€å†…ã®å®Ÿè¡Œä¸­ã«ä¾‹å¤–ãŒç™ºç”Ÿã™ã‚‹ã¨ã€ãã®ç¯€ã®æ®‹ã‚Šã¯é£›ã°ã•ã‚Œã¾ã™ã€‚æ¬¡ã«ã€ä¾‹å¤–å‹ãŒ :keyword:`except` "
"ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®å¾Œã«æŒ‡å®šã•ã‚Œã¦ã„ã‚‹ä¾‹å¤–ã«ä¸€è‡´ã™ã‚‹å ´åˆã€except ç¯€ãŒå®Ÿè¡Œã•ã‚ŒãŸå¾Œã€ :keyword:`try` æ–‡ã®å¾Œã‚ã¸å®Ÿè¡ŒãŒç¶™ç¶šã•ã‚Œã¾ã™ã€‚"

#: ../../tutorial/errors.rst:109
msgid ""
"If an exception occurs which does not match the exception named in the "
"except clause, it is passed on to outer :keyword:`try` statements; if no "
"handler is found, it is an *unhandled exception* and execution stops with a "
"message as shown above."
msgstr ""
"ã‚‚ã—ã‚‚ except ç¯€ã§æŒ‡å®šã•ã‚ŒãŸä¾‹å¤–ã¨ä¸€è‡´ã—ãªã„ä¾‹å¤–ãŒç™ºç”Ÿã™ã‚‹ã¨ã€ãã®ä¾‹å¤–ã¯ :keyword:`try` "
"æ–‡ã®å¤–å´ã«æ¸¡ã•ã‚Œã¾ã™ã€‚ä¾‹å¤–ã«å¯¾ã™ã‚‹ãƒãƒ³ãƒ‰ãƒ© (handlerã€å‡¦ç†éƒ¨) ãŒã©ã“ã«ã‚‚ãªã‘ã‚Œã°ã€ *å‡¦ç†ã•ã‚Œãªã„ä¾‹å¤– (unhandled "
"exception)* ã¨ãªã‚Šã€ä¸Šè¨˜ã«ç¤ºã—ãŸã‚ˆã†ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡ºã—ã¦å®Ÿè¡Œã‚’åœæ­¢ã—ã¾ã™ã€‚"

#: ../../tutorial/errors.rst:114
msgid ""
"A :keyword:`try` statement may have more than one except clause, to specify "
"handlers for different exceptions.  At most one handler will be executed. "
"Handlers only handle exceptions that occur in the corresponding try clause, "
"not in other handlers of the same :keyword:`try` statement.  An except "
"clause may name multiple exceptions as a parenthesized tuple, for example::"
msgstr ""
"ä¸€ã¤ã® :keyword:`try` æ–‡ã«è¤‡æ•°ã® except "
"ç¯€ã‚’è¨­ã‘ã¦ã€ã•ã¾ã–ã¾ãªä¾‹å¤–ã«å¯¾ã™ã‚‹ãƒãƒ³ãƒ‰ãƒ©ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚åŒæ™‚ã«ä¸€ã¤ä»¥ä¸Šã®ãƒãƒ³ãƒ‰ãƒ©ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒãƒ³ãƒ‰ãƒ©ã¯å¯¾å¿œã™ã‚‹ try "
"ç¯€å†…ã§ç™ºç”Ÿã—ãŸä¾‹å¤–ã ã‘ã‚’å‡¦ç†ã—ã€åŒã˜ :keyword:`try` æ–‡å†…ã®åˆ¥ã®ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã§èµ·ããŸä¾‹å¤–ã¯å‡¦ç†ã—ã¾ã›ã‚“ã€‚ except "
"ç¯€ã«ã¯è¤‡æ•°ã®ä¾‹å¤–ã‚’ä¸¸æ‹¬å¼§ã§å›²ã£ãŸã‚¿ãƒ—ãƒ«ã«ã—ã¦æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../tutorial/errors.rst:123
msgid ""
"A class in an :keyword:`except` clause is compatible with an exception if it"
" is the same class or a base class thereof (but not the other way around ---"
" an except clause listing a derived class is not compatible with a base "
"class).  For example, the following code will print B, C, D in that order::"
msgstr ""
":keyword:`except` ç¯€ã®ã‚¯ãƒ©ã‚¹ã¯ã€ä¾‹å¤–ã¨åŒã˜ã‚¯ãƒ©ã‚¹ã‹åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã¨ãã«äº’æ› (compatible)ã¨ãªã‚Šã¾ã™ã€‚ "
"(é€†æ–¹å‘ã§ã¯æˆã‚Šç«‹ã¡ã¾ã›ã‚“ --- æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã®ä¾‹å¤–ãŒãƒªã‚¹ãƒˆã•ã‚Œã¦ã„ã‚‹ except ç¯€ã¯åŸºåº•ã‚¯ãƒ©ã‚¹ã®ä¾‹å¤–ã¨äº’æ›ã§ã¯ã‚ã‚Šã¾ã›ã‚“)ã€‚ä¾‹ãˆã°ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã€"
" B, C, D ã‚’é †åºé€šã‚Šã«å‡ºåŠ›ã—ã¾ã™::"

#: ../../tutorial/errors.rst:147
msgid ""
"Note that if the except clauses were reversed (with ``except B`` first), it "
"would have printed B, B, B --- the first matching except clause is "
"triggered."
msgstr ""
"except ç¯€ãŒé€†ã«ä¸¦ã‚“ã§ã„ãŸå ´åˆ (``except B`` ãŒæœ€åˆã«ãã‚‹å ´åˆ)ã€ B, B, B ã¨å‡ºåŠ›ã•ã‚Œã‚‹ã¯ãšã ã£ãŸã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ "
"--- æœ€åˆã«ä¸€è‡´ã—ãŸ except ç¯€ãŒé§†å‹•ã•ã‚Œã‚‹ã®ã§ã™ã€‚"

#: ../../tutorial/errors.rst:150
msgid ""
"The last except clause may omit the exception name(s), to serve as a "
"wildcard. Use this with extreme caution, since it is easy to mask a real "
"programming error in this way!  It can also be used to print an error "
"message and then re-raise the exception (allowing a caller to handle the "
"exception as well)::"
msgstr ""
"æœ€å¾Œã® except ç¯€ã§ã¯ä¾‹å¤–åã‚’çœã„ã¦ã€ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ (wildcardã€ç·ç§°è¨˜å·) ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ã® except "
"ç¯€ã¯éå¸¸ã«æ³¨æ„ã—ã¦ä½¿ã£ã¦ãã ã•ã„ã€‚ã¨ã„ã†ã®ã¯ã€ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ã¯é€šå¸¸ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚¨ãƒ©ãƒ¼ã‚’ãŸã‚„ã™ãéš ã—ã¦ã—ã¾ã†ã‹ã‚‰ã§ã™ï¼ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ã® except "
"ç¯€ã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡ºåŠ›ã—ãŸå¾Œã«ä¾‹å¤–ã‚’å†é€å‡ºã™ã‚‹ (é–¢æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—å´ãŒåŒæ§˜ã«ã—ã¦ä¾‹å¤–ã‚’å‡¦ç†ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹) ç”¨é€”ã«ã‚‚ä½¿ãˆã¾ã™::"

#: ../../tutorial/errors.rst:169
msgid ""
"The :keyword:`try` ... :keyword:`except` statement has an optional *else "
"clause*, which, when present, must follow all except clauses.  It is useful "
"for code that must be executed if the try clause does not raise an "
"exception.  For example::"
msgstr ""
":keyword:`try` ... :keyword:`except` æ–‡ã«ã¯ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ *else ç¯€ (else clause)* "
"ã‚’è¨­ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ :keyword:`else` ç¯€ã‚’è¨­ã‘ã‚‹å ´åˆã€å…¨ã¦ã® :keyword:`except` "
"ç¯€ã‚ˆã‚Šã‚‚å¾Œã‚ã«ç½®ã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ :keyword:`else` ç¯€ã¯ try "
"ç¯€ã§å…¨ãä¾‹å¤–ãŒé€å‡ºã•ã‚Œãªã‹ã£ãŸã¨ãã«å®Ÿè¡Œã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã®ã«å½¹ç«‹ã¡ã¾ã™ã€‚ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../tutorial/errors.rst:183
msgid ""
"The use of the :keyword:`else` clause is better than adding additional code "
"to the :keyword:`try` clause because it avoids accidentally catching an "
"exception that wasn't raised by the code being protected by the "
":keyword:`try` ... :keyword:`except` statement."
msgstr ""
"è¿½åŠ ã®ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã™ã‚‹ã®ã¯ :keyword:`try` ç¯€ã®å¾Œã‚ã‚ˆã‚Šã‚‚ :keyword:`else` ç¯€ã®æ–¹ãŒã‚ˆã„ã§ã—ã‚‡ã†ã€‚ãªãœãªã‚‰ã€ãã†ã™ã‚‹ã“ã¨ã§"
" :keyword:`try` ... :keyword:`except` "
"æ–‡ã§ä¿è­·ã—ãŸã„ã‚³ãƒ¼ãƒ‰ã‹ã‚‰é€å‡ºã•ã‚ŒãŸã‚‚ã®ä»¥å¤–ã®ä¾‹å¤–ã‚’å¶ç„¶ã«æ•æ‰ã—ã¦ã—ã¾ã†ã¨ã„ã†äº‹æ…‹ã‚’é¿ã‘ã‚‰ã‚Œã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../tutorial/errors.rst:188
msgid ""
"When an exception occurs, it may have an associated value, also known as the"
" exception's *argument*. The presence and type of the argument depend on the"
" exception type."
msgstr ""
"ä¾‹å¤–ãŒç™ºç”Ÿã™ã‚‹ã¨ãã€ä¾‹å¤–ã¯é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸå€¤ã‚’æŒã¤ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®å€¤ã¯ä¾‹å¤–ã® *å¼•æ•° (argument)* "
"ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚å¼•æ•°ã®æœ‰ç„¡ãŠã‚ˆã³å¼•æ•°ã®å‹ã¯ã€ä¾‹å¤–ã®å‹ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../tutorial/errors.rst:192
msgid ""
"The except clause may specify a variable after the exception name.  The "
"variable is bound to an exception instance with the arguments stored in "
"``instance.args``.  For convenience, the exception instance defines "
":meth:`__str__` so the arguments can be printed directly without having to "
"reference ``.args``.  One may also instantiate an exception first before "
"raising it and add any attributes to it as desired. ::"
msgstr ""
"except ç¯€ã§ã¯ã€ä¾‹å¤–åã®å¾Œã«å¤‰æ•°ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®å¤‰æ•°ã¯ä¾‹å¤–ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«çµã³ä»˜ã‘ã‚‰ã‚Œã¦ãŠã‚Šã€ ``instance.args`` "
"ã«ä¾‹å¤–ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆæ™‚ã®å¼•æ•°ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚ä¾‹å¤–ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã¯ :meth:`__str__` ãŒå®šç¾©ã•ã‚Œã¦ãŠã‚Šã€ ``.args`` "
"ã‚’å‚ç…§ã—ãªãã¦ã‚‚å¼•æ•°ã‚’ç›´æ¥å°å­—ã§ãã‚‹ã‚ˆã†ã«åˆ©ä¾¿æ€§ãŒå›³ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚å¿…è¦ãªã‚‰ã€ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹å‰ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã—ã¦ã€ä»»æ„ã®å±æ€§ã‚’è¿½åŠ ã§ãã¾ã™ã€‚ ::"

#: ../../tutorial/errors.rst:216
msgid ""
"If an exception has arguments, they are printed as the last part ('detail') "
"of the message for unhandled exceptions."
msgstr "ä¾‹å¤–ãŒå¼•æ•°ã‚’æŒã£ã¦ã„ã‚Œã°ã€ãã‚Œã‚‰ã¯å‡¦ç†ã•ã‚Œãªã„ä¾‹å¤–ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æœ€å¾Œã®éƒ¨åˆ† (ã€Œè©³ç´°èª¬æ˜ã€) ã«å‡ºåŠ›ã•ã‚Œã¾ã™ã€‚"

#: ../../tutorial/errors.rst:219
msgid ""
"Exception handlers don't just handle exceptions if they occur immediately in"
" the try clause, but also if they occur inside functions that are called "
"(even indirectly) in the try clause. For example::"
msgstr ""
"ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã¯ã€try ç¯€ã®ç›´æ¥å†…å´ã§ç™ºç”Ÿã—ãŸä¾‹å¤–ã‚’å‡¦ç†ã™ã‚‹ã ã‘ã§ã¯ãªãã€ãã® try ç¯€ã‹ã‚‰ (ãŸã¨ãˆé–“æ¥çš„ã«ã§ã‚‚) "
"å‘¼ã³å‡ºã•ã‚ŒãŸé–¢æ•°ã®å†…éƒ¨ã§ç™ºç”Ÿã—ãŸä¾‹å¤–ã‚‚å‡¦ç†ã—ã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../tutorial/errors.rst:237
msgid "Raising Exceptions"
msgstr "ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹"

#: ../../tutorial/errors.rst:239
msgid ""
"The :keyword:`raise` statement allows the programmer to force a specified "
"exception to occur. For example::"
msgstr ":keyword:`raise` æ–‡ã‚’ä½¿ã£ã¦ã€ç‰¹å®šã®ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../tutorial/errors.rst:247
msgid ""
"The sole argument to :keyword:`raise` indicates the exception to be raised. "
"This must be either an exception instance or an exception class (a class "
"that derives from :class:`Exception`).  If an exception class is passed, it "
"will be implicitly instantiated by calling its constructor with no "
"arguments::"
msgstr ""
":keyword:`raise` ã®å”¯ä¸€ã®å¼•æ•°ã¯é€å‡ºã•ã‚Œã‚‹ä¾‹å¤–ã‚’æŒ‡ã—ç¤ºã—ã¾ã™ã€‚\n"
"ã“ã‚Œã¯ä¾‹å¤–ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ä¾‹å¤–ã‚¯ãƒ©ã‚¹ (:class:`Exception` ã‚’ç¶™æ‰¿ã—ãŸã‚¯ãƒ©ã‚¹) ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"ä¾‹å¤–ã‚¯ãƒ©ã‚¹ãŒæ¸¡ã•ã‚ŒãŸå ´åˆã¯ã€å¼•æ•°ç„¡ã—ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã³å‡ºã•ã‚Œã€æš—é»™çš„ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚Œã¾ã™::"

#: ../../tutorial/errors.rst:254
msgid ""
"If you need to determine whether an exception was raised but don't intend to"
" handle it, a simpler form of the :keyword:`raise` statement allows you to "
"re-raise the exception::"
msgstr ""
"ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ãŸã„ã ã‘ã§ã€ãã®ä¾‹å¤–ã‚’å‡¦ç†ã™ã‚‹ã¤ã‚‚ã‚ŠãŒãªã‘ã‚Œã°ã€å˜ç´”ãªå½¢å¼ã® :keyword:`raise` "
"æ–‡ã‚’ä½¿ã£ã¦ä¾‹å¤–ã‚’å†é€å‡ºã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/errors.rst:273
msgid "User-defined Exceptions"
msgstr "ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ä¾‹å¤–"

#: ../../tutorial/errors.rst:275
msgid ""
"Programs may name their own exceptions by creating a new exception class "
"(see :ref:`tut-classes` for more about Python classes).  Exceptions should "
"typically be derived from the :exc:`Exception` class, either directly or "
"indirectly."
msgstr ""
"ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸Šã§æ–°ã—ã„ä¾‹å¤–ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã™ã‚‹ã“ã¨ã§ã€ç‹¬è‡ªã®ä¾‹å¤–ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ (Python ã®ã‚¯ãƒ©ã‚¹ã«ã¤ã„ã¦ã¯ :ref:`tut-"
"classes` å‚ç…§)ã€‚ä¾‹å¤–ã¯ã€å…¸å‹çš„ã« :exc:`Exception` ã‚¯ãƒ©ã‚¹ã‹ã‚‰ã€ç›´æ¥ã¾ãŸã¯é–“æ¥çš„ã«æ´¾ç”Ÿã—ãŸã‚‚ã®ã§ã™ã€‚"

#: ../../tutorial/errors.rst:279
msgid ""
"Exception classes can be defined which do anything any other class can do, "
"but are usually kept simple, often only offering a number of attributes that"
" allow information about the error to be extracted by handlers for the "
"exception.  When creating a module that can raise several distinct errors, a"
" common practice is to create a base class for exceptions defined by that "
"module, and subclass that to create specific exception classes for different"
" error conditions::"
msgstr ""
"ä¾‹å¤–ã‚¯ãƒ©ã‚¹ã§ã¯ã€æ™®é€šã®ã‚¯ãƒ©ã‚¹ãŒã§ãã‚‹ã“ã¨ãªã‚‰ä½•ã§ã‚‚å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€é€šå¸¸ã¯å˜ç´”ãªã‚‚ã®ã«ã—ã¦ãŠãã¾ã™ã€‚å¤§æŠµã¯ã€ã„ãã¤ã‹ã®å±æ€§ã ã‘ã‚’æä¾›ã—ã€ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸã¨ãã«ãƒãƒ³ãƒ‰ãƒ©ãŒã‚¨ãƒ©ãƒ¼ã«é–¢ã™ã‚‹æƒ…å ±ã‚’å–ã‚Šå‡ºã›ã‚‹ã‚ˆã†ã«ã™ã‚‹ç¨‹åº¦ã«ã¨ã©ã‚ã¾ã™ã€‚è¤‡æ•°ã®åˆ¥å€‹ã®ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ã‚ˆã†ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆã™ã‚‹éš›ã«ã¯ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ä¾‹å¤–ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã™ã‚‹ã®ãŒä¸€èˆ¬çš„ãªãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã§ã™::"

#: ../../tutorial/errors.rst:317
msgid ""
"Most exceptions are defined with names that end in \"Error,\" similar to the"
" naming of the standard exceptions."
msgstr "ã»ã¨ã‚“ã©ã®ä¾‹å¤–ã¯ã€æ¨™æº–ã®ä¾‹å¤–ã®åå‰ä»˜ã‘ã¨åŒæ§˜ã«ã€ \"Error\" ã§çµ‚ã‚ã‚‹åå‰ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/errors.rst:320
msgid ""
"Many standard modules define their own exceptions to report errors that may "
"occur in functions they define.  More information on classes is presented in"
" chapter :ref:`tut-classes`."
msgstr ""
"å¤šãã®æ¨™æº–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹é–¢æ•°å†…ã§ç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ã‚¨ãƒ©ãƒ¼ã‚’å ±å‘Šã•ã›ã‚‹ãŸã‚ã«ã€ç‹¬è‡ªã®ä¾‹å¤–ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã«ã¤ã„ã¦ã®è©³ç´°ãªæƒ…å ±ã¯"
" :ref:`tut-classes` ç« ã§æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/errors.rst:328
msgid "Defining Clean-up Actions"
msgstr "ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‹•ä½œã‚’å®šç¾©ã™ã‚‹"

#: ../../tutorial/errors.rst:330
msgid ""
"The :keyword:`try` statement has another optional clause which is intended "
"to define clean-up actions that must be executed under all circumstances.  "
"For example::"
msgstr ""
":keyword:`try` "
"æ–‡ã«ã¯ã‚‚ã†ä¸€ã¤ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ç¯€ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ç¯€ã¯ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‹•ä½œã‚’å®šç¾©ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã€ã©ã‚“ãªçŠ¶æ³ã§ã‚‚å¿…ãšå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../tutorial/errors.rst:344
msgid ""
"A *finally clause* is always executed before leaving the :keyword:`try` "
"statement, whether an exception has occurred or not. When an exception has "
"occurred in the :keyword:`try` clause and has not been handled by an "
":keyword:`except` clause (or it has occurred in an :keyword:`except` or "
":keyword:`else` clause), it is re-raised after the :keyword:`finally` clause"
" has been executed.  The :keyword:`finally` clause is also executed \"on the"
" way out\" when any other clause of the :keyword:`try` statement is left via"
" a :keyword:`break`, :keyword:`continue` or :keyword:`return` statement.  A "
"more complicated example::"
msgstr ""
"*finally ç¯€ (finally clause)* ã¯ã€ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸã‹ã©ã†ã‹ã«é–¢ã‚ã‚‰ãšã€ :keyword:`try` "
"æ–‡ã‚’æŠœã‘ã‚‹å‰ã«å¸¸ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ :keyword:`try` ç¯€ã®ä¸­ã§ä¾‹å¤–ãŒç™ºç”Ÿã—ã¦ã€ :keyword:`except` "
"ç¯€ã§å‡¦ç†ã•ã‚Œã¦ã„ãªã„å ´åˆã€ã¾ãŸã¯ :keyword:`except` ç¯€ã‹ :keyword:`else` ç¯€ã§ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã€ "
":keyword:`finally` ç¯€ã‚’å®Ÿè¡Œã—ãŸå¾Œã€ãã®ä¾‹å¤–ã‚’å†é€å‡ºã—ã¾ã™ã€‚ :keyword:`finally` ç¯€ã¯ã¾ãŸã€ "
":keyword:`try` ç¯€ã‹ã‚‰ :keyword:`break` æ–‡ã‚„ :keyword:`continue` æ–‡ã€ "
":keyword:`return` æ–‡çµŒç”±ã§æŠœã‘ã‚‹éš›ã«ã‚‚ã€ \"æŠœã‘ã‚‹é€”ä¸­ã§\" å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã‚ˆã‚Šè¤‡é›‘ãªä¾‹ã§ã™::"

#: ../../tutorial/errors.rst:377
msgid ""
"As you can see, the :keyword:`finally` clause is executed in any event.  The"
" :exc:`TypeError` raised by dividing two strings is not handled by the "
":keyword:`except` clause and therefore re-raised after the "
":keyword:`finally` clause has been executed."
msgstr ""
"è¦‹ã¦ã‚ã‹ã‚‹ã¨ãŠã‚Šã€ :keyword:`finally` ç¯€ã¯ã©ã®å ´åˆã«ã‚‚å®Ÿè¡Œã•ã‚Œã¦ã„ã¾ã™ã€‚æ–‡å­—åˆ—ã‚’å‰²ã‚Šç®—ã™ã‚‹ã“ã¨ã§ç™ºç”Ÿã—ãŸ "
":exc:`TypeError` ã¯ :keyword:`except` ç¯€ã§å‡¦ç†ã•ã‚Œã¦ã„ãªã„ã®ã§ã€ :keyword:`finally` "
"ç¯€å®Ÿè¡Œå¾Œã«å†åº¦é€å‡ºã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/errors.rst:382
msgid ""
"In real world applications, the :keyword:`finally` clause is useful for "
"releasing external resources (such as files or network connections), "
"regardless of whether the use of the resource was successful."
msgstr ""
"å®Ÿä¸–ç•Œã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€ :keyword:`finally` "
"ç¯€ã¯(ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šãªã©ã®)å¤–éƒ¨ãƒªã‚½ãƒ¼ã‚¹ã‚’ã€åˆ©ç”¨ãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ã«ã‹ã‹ã‚ã‚‰ãšè§£æ”¾ã™ã‚‹ãŸã‚ã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../tutorial/errors.rst:390
msgid "Predefined Clean-up Actions"
msgstr "å®šç¾©æ¸ˆã¿ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†"

#: ../../tutorial/errors.rst:392
msgid ""
"Some objects define standard clean-up actions to be undertaken when the "
"object is no longer needed, regardless of whether or not the operation using"
" the object succeeded or failed. Look at the following example, which tries "
"to open a file and print its contents to the screen. ::"
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãªã‹ã«ã¯ã€ãã®åˆ©ç”¨ã®æˆå¦ã«ã‹ã‹ã‚ã‚‰ãšã€ä¸è¦ã«ãªã£ãŸéš›ã«å®Ÿè¡Œã•ã‚Œã‚‹æ¨™æº–çš„ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚ªãƒ¼ãƒ—ãƒ³ã—ã¦å†…å®¹ã‚’ç”»é¢ã«è¡¨ç¤ºã™ã‚‹ä¾‹ã‚’ã¿ã¦ãã ã•ã„ã€‚"
" ::"

#: ../../tutorial/errors.rst:400
msgid ""
"The problem with this code is that it leaves the file open for an "
"indeterminate amount of time after this part of the code has finished "
"executing. This is not an issue in simple scripts, but can be a problem for "
"larger applications. The :keyword:`with` statement allows objects like files"
" to be used in a way that ensures they are always cleaned up promptly and "
"correctly. ::"
msgstr ""
"ã“ã®ã‚³ãƒ¼ãƒ‰ã®å•é¡Œç‚¹ã¯ã€ã‚³ãƒ¼ãƒ‰ã®å®Ÿè¡ŒãŒçµ‚ã‚ã£ãŸå¾Œã«ä¸å®šã®æ™‚é–“ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã„ãŸã¾ã¾ã§ã„ã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã¯å˜ç´”ãªã‚¹ã‚¯ãƒªãƒ—ãƒˆã§ã¯å•é¡Œã«ãªã‚Šã¾ã›ã‚“ãŒã€å¤§ããªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯å•é¡Œã«ãªã‚Šãˆã¾ã™ã€‚"
" :keyword:`with` æ–‡ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¸¸ã«ã€å³åº§ã«æ­£ã—ãã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã•ã‚Œã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¾ã™ã€‚ ::"

#: ../../tutorial/errors.rst:410
msgid ""
"After the statement is executed, the file *f* is always closed, even if a "
"problem was encountered while processing the lines. Objects which, like "
"files, provide predefined clean-up actions will indicate this in their "
"documentation."
msgstr ""
"ã“ã®æ–‡ãŒå®Ÿè¡Œã•ã‚ŒãŸã‚ã¨ã§ã€ãŸã¨ãˆè¡Œã®å‡¦ç†ä¸­ã«å•é¡ŒãŒã‚ã£ãŸã¨ã—ã¦ã‚‚ã€ãƒ•ã‚¡ã‚¤ãƒ« *f* ã¯å¸¸ã« close "
"ã•ã‚Œã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãªã©ã®ã€å®šç¾©æ¸ˆã¿ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã¯ã€ãã‚Œãã‚Œã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ç¤ºã•ã‚Œã¾ã™ã€‚"
