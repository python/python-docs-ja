# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-26 13:59+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../tutorial/classes.rst:5
msgid "Classes"
msgstr "ã‚¯ãƒ©ã‚¹"

#: ../../tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã¯ãƒ‡ãƒ¼ã‚¿ã¨æ©Ÿèƒ½ã‚’çµ„ã¿åˆã‚ã›ã‚‹æ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚\n"
"æ–°è¦ã«ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã™ã‚‹ã“ã¨ã§ã€æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® *å‹* ã‚’ä½œæˆã—ã€ãã®å‹ã‚’æŒã¤æ–°ã—ã„ *ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹* ãŒä½œã‚Œã¾ã™ã€‚\n"
"ã‚¯ãƒ©ã‚¹ã®ãã‚Œãã‚Œã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯è‡ªèº«ã®çŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹å±æ€§ã‚’æŒã¦ã¾ã™ã€‚\n"
"ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ãã®çŠ¶æ…‹ã‚’å¤‰æ›´ã™ã‚‹ãŸã‚ã® (ãã®ã‚¯ãƒ©ã‚¹ãŒå®šç¾©ã™ã‚‹) ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚æŒã¦ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"Python ã¯ã€ä»–ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¨æ¯”è¼ƒã—ã¦ã€æœ€å°é™ã®æ§‹æ–‡ã¨æ„å‘³ä»˜ã‘ã‚’ä½¿ã£ã¦ã‚¯ãƒ©ã‚¹ã‚’è¨€èªã«è¿½åŠ ã—ã¦ã„ã¾ã™ã€‚Python ã®ã‚¯ãƒ©ã‚¹ã¯ã€C++ ã¨ "
"Modula-3 ã®ã‚¯ãƒ©ã‚¹ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’æ··ãœãŸã‚‚ã®ã§ã™ã€‚Python "
"ã®ã‚¯ãƒ©ã‚¹æ©Ÿæ§‹ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®æ¨™æº–çš„ãªæ©Ÿèƒ½ã‚’å…¨ã¦æä¾›ã—ã¦ã„ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã®ç¶™æ‰¿ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã¯ã€è¤‡æ•°ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’æŒã¤ã“ã¨ãŒã§ãã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã§åŸºåº•ã‚¯ãƒ©ã‚¹ã®ä»»æ„ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’åŒã˜åå‰ã§å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ä»»æ„ã®ç¨®é¡ã¨æ•°ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨åŒã˜ãã€ã‚¯ãƒ©ã‚¹æ©Ÿæ§‹ã‚‚"
" Python ã®å‹•çš„ãªæ€§è³ªã«å¾“ã†ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã¯å®Ÿè¡Œæ™‚ã«ç”Ÿæˆã•ã‚Œã€ç”Ÿæˆå¾Œã«å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are"
" *virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"C++ ã®ç”¨èªã§è¨€ãˆã°ã€é€šå¸¸ã®ã‚¯ãƒ©ã‚¹ãƒ¡ãƒ³ãƒ (ãƒ‡ãƒ¼ã‚¿ãƒ¡ãƒ³ãƒã‚‚å«ã‚€) ã¯ (:ref:`tut-private` ã«æ›¸ã‹ã‚Œã¦ã„ã‚‹ä¾‹å¤–ã‚’é™¤ã„ã¦) "
"*public* ã§ã‚ã‚Šã€ãƒ¡ãƒ³ãƒé–¢æ•°ã¯ã™ã¹ã¦ *ä»®æƒ³é–¢æ•°(virtual)* ã§ã™ã€‚ Modula-3 "
"ã«ã‚ã‚‹ã‚ˆã†ãªã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ãƒ³ãƒã‚’ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰å‚ç…§ã™ã‚‹ãŸã‚ã®çŸ­ç¸®ã—ãŸè¨˜æ³•ã¯ä½¿ãˆã¾ã›ã‚“: "
"ãƒ¡ã‚½ãƒƒãƒ‰é–¢æ•°ã®å®£è¨€ã§ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã‚’è¡¨ã™ç¬¬ä¸€å¼•æ•°ã‚’æ˜ç¤ºã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ç¬¬ä¸€å¼•æ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—ã®éš›ã«æš—é»™ã®å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã¾ã™ã€‚"
" Smalltalk ã«ä¼¼ã¦ã€ã‚¯ãƒ©ã‚¹ã¯ãã‚Œè‡ªä½“ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ãã®ãŸã‚ã€ import ã‚„åå‰å¤‰æ›´ã¨ã„ã£ãŸæ“ä½œãŒå¯èƒ½ã§ã™ã€‚ C++ ã‚„ "
"Modula-3 ã¨é•ã£ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯çµ„è¾¼ã¿å‹ã‚’åŸºåº•ã‚¯ãƒ©ã‚¹ã«ã—ã¦æ‹¡å¼µã‚’è¡Œãˆã¾ã™ã€‚ã¾ãŸã€C++ ã¨ã¯åŒã˜ã§ Modula-3 "
"ã¨ã¯é•ã†ç‚¹ã¨ã—ã¦ã€ç‰¹åˆ¥ãªæ§‹æ–‡ã‚’ä¼´ã†ã»ã¨ã‚“ã©ã®çµ„ã¿è¾¼ã¿æ¼”ç®—å­ (ç®—è¡“æ¼”ç®—å­ (arithmetic operator) ã‚„æ·»å­—è¡¨è¨˜) "
"ã¯ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ä½¿ã†ãŸã‚ã«å†å®šç¾©ã§ãã¾ã™ã€‚"

#: ../../tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make"
" occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(ã‚¯ãƒ©ã‚¹ã«é–¢ã—ã¦æ™®éçš„ãªç”¨èªå®šç¾©ãŒãªã„ã®ã§ã€ Smalltalk ã¨ C++ ã®ç”¨èªã‚’å ´åˆã«å¿œã˜ã¦ä½¿ã£ã¦ã„ãã“ã¨ã«ã—ã¾ã™ã€‚ C++ ã‚ˆã‚Šã‚‚ "
"Modula-3 ã®æ–¹ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã®æ„å‘³è«–ãŒ Python ã«è¿‘ã„ã®ã§ã€ Modula-3 ã®ç”¨èªã‚’ä½¿ã„ãŸã„ã®ã§ã™ãŒã€ã»ã¨ã‚“ã©ã®èª­è€…ã¯ "
"Modula-3 ã«ã¤ã„ã¦ã—ã‚‰ãªã„ã§ã—ã‚‡ã†ã‹ã‚‰ã€‚)"

#: ../../tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "åå‰ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦"

#: ../../tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯å€‹ä½“æ€§ãŒã‚ã‚Šã€åŒä¸€ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«(è¤‡æ•°ã®ã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰) "
"è¤‡æ•°ã®åå‰ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã¯ä»–ã®è¨€èªã§ã¯åˆ¥åã¥ã‘(alias) ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ Python "
"ã‚’ä¸€è¦‹ã—ãŸã ã‘ã§ã¯ã€åˆ¥åã¥ã‘ã®é‡è¦æ€§ã¯åˆ†ã‹ã‚‰ãªã„ã“ã¨ãŒå¤šãã€å¤‰æ›´ä¸èƒ½ãªåŸºæœ¬å‹ "
"(æ•°å€¤ã€æ–‡å­—åˆ—ã€ã‚¿ãƒ—ãƒ«)ã‚’æ‰±ã†ã¨ãã«ã¯ç„¡è¦–ã—ã¦å·®ã—æ”¯ãˆã‚ã‚Šã¾ã›ã‚“ã€‚ã—ã‹ã—ãªãŒã‚‰ã€åˆ¥åä»˜ã‘ã¯ã€ãƒªã‚¹ãƒˆã‚„è¾æ›¸ã‚„ä»–ã®å¤šãã®å‹ãªã©ã€å¤‰æ›´å¯èƒ½ãªå‹ã‚’æ‰±ã† "
"Python "
"ã‚³ãƒ¼ãƒ‰ä¸Šã§é©šãã¹ãåŠ¹æœãŒã‚ã‚Šã¾ã™ã€‚åˆ¥åä»˜ã‘ã¯ã„ãã¤ã‹ã®ç‚¹ã§ãƒã‚¤ãƒ³ã‚¿ã®ã‚ˆã†ã«æŒ¯èˆã„ã€ã“ã®ã“ã¨ã¯é€šå¸¸ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«åˆ©ã™ã‚‹ã‚ˆã†ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å—ã‘æ¸¡ã—ã¯ã€å®Ÿè£…ä¸Šã¯ãƒã‚¤ãƒ³ã‚¿ãŒæ¸¡ã•ã‚Œã‚‹ã ã‘ãªã®ã§ã‚³ã‚¹ãƒˆã®ä½ã„æ“ä½œã«ãªã‚Šã¾ã™ã€‚ã¾ãŸã€é–¢æ•°ãŒã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚ŒãŸã¨ãã€é–¢æ•°ã®å‘¼ã³å‡ºã—å´ã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å¤‰æ›´ã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™"
" --- ã“ã‚Œã«ã‚ˆã‚Šã€ Pascal ã«ã‚ã‚‹ã‚ˆã†ãªäºŒã¤ã®å¼•æ•°æ¸¡ã—æ©Ÿæ§‹ã‚’ã‚‚ã¤å¿…è¦ã‚’ãªãã—ã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "Python ã®ã‚¹ã‚³ãƒ¼ãƒ—ã¨åå‰ç©ºé–“"

#: ../../tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã‚’ç´¹ä»‹ã™ã‚‹å‰ã«ã€Python "
"ã®ã‚¹ã‚³ãƒ¼ãƒ—ã®ãƒ«ãƒ¼ãƒ«ã«ã¤ã„ã¦ã‚ã‚‹ã“ã¨ã‚’è©±ã—ã¦ãŠã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¹å®šç¾©ã¯å·§ã¿ãªãƒˆãƒªãƒƒã‚¯ã‚’åå‰ç©ºé–“ã«æ–½ã™ã®ã§ã€ä½•ãŒèµ·ã“ã£ã¦ã„ã‚‹ã®ã‹ã‚’å®Œå…¨ã«ç†è§£ã™ã‚‹ã«ã¯ã€ã‚¹ã‚³ãƒ¼ãƒ—ã¨åå‰ç©ºé–“ãŒã©ã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹ã‹ã‚’ç†è§£ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã¡ãªã¿ã«ã€ã“ã®å•é¡Œã«é–¢ã™ã‚‹çŸ¥è­˜ã¯å…¨ã¦ã®"
" Python ãƒ—ãƒ­ã‚°ãƒ©ãƒã«ã¨ã£ã¦æœ‰ç”¨ã§ã™ã€‚"

#: ../../tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "ã¾ãšå®šç¾©ã‹ã‚‰å§‹ã‚ã¾ã—ã‚‡ã†ã€‚"

#: ../../tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense"
" the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"*åå‰ç©ºé–“ (namespace)* ã¨ã¯ã€åå‰ã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¯¾å¿œä»˜ã‘ (mapping) ã§ã™ã€‚ã»ã¨ã‚“ã©ã®åå‰ç©ºé–“ã¯ã€ç¾çŠ¶ã§ã¯ Python "
"ã®è¾æ›¸ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ãŒã€ãã®ã“ã¨ã¯é€šå¸¸ã¯ (ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä»¥å¤–ã§ã¯) "
"ç›®ç«‹ã¤ã“ã¨ã¯ãªã„ã—ã€å°†æ¥ã¯å¤‰æ›´ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚åå‰ç©ºé–“ã®ä¾‹ã«ã¯ã€çµ„è¾¼ã¿åã®é›†åˆ (:func:`abs` "
"ç­‰ã®é–¢æ•°ã‚„çµ„è¾¼ã¿ä¾‹å¤–å)ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ã€é–¢æ•°ã‚’å‘¼ã³å‡ºã—ãŸã¨ãã®ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ãŒã‚ã‚Šã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§ã‹ã‚‰ãªã‚‹é›†åˆã‚‚ã¾ãŸã€ã‚ã‚‹æ„å‘³ã§ã¯åå‰ç©ºé–“ã§ã™ã€‚åå‰ç©ºé–“ã«ã¤ã„ã¦çŸ¥ã£ã¦ãŠãã¹ãé‡è¦ãªã“ã¨ã¯ã€ç•°ãªã£ãŸåå‰ç©ºé–“ã«ã‚ã‚‹åå‰ã®é–“ã«ã¯å…¨ãé–¢ä¿‚ãŒãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚ä¾‹ãˆã°ã€äºŒã¤ã®åˆ¥ã€…ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¸¡æ–¹ã§é–¢æ•°"
" ``maximize`` ã¨ã„ã†é–¢æ•°ã‚’å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã€å®šç¾©è‡ªä½“ã¯æ··åŒã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ --- "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ¦ãƒ¼ã‚¶ã¯åå‰ã®å‰ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’ã¤ã‘ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is"
" a module object and ``funcname`` is an attribute of it.  In this case there"
" happens to be a straightforward mapping between the module's attributes and"
" the global names defined in the module: they share the same namespace!  "
"[#]_"
msgstr ""
"ã¨ã“ã‚ã§ã€ *å±æ€§* ã¨ã„ã†è¨€è‘‰ã¯ã€ãƒ‰ãƒƒãƒˆã«ç¶šãåå‰ã™ã¹ã¦ã«å¯¾ã—ã¦ä½¿ã£ã¦ã„ã¾ã™ --- ä¾‹ãˆã°å¼ ``z.real`` ã§ã€ ``real`` "
"ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ``z`` ã®å±æ€§ã§ã™ã€‚å³å¯†ã«ã„ãˆã°ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã®åå‰ã«å¯¾ã™ã‚‹å‚ç…§ã¯å±æ€§ã®å‚ç…§ã§ã™ã€‚å¼ ``modname.funcname`` "
"ã§ã¯ã€ ``modname`` ã¯ã‚ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ ``funcname`` "
"ã¯ãã®å±æ€§ã§ã™ã€‚ã“ã®å ´åˆã«ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å±æ€§ã¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¸­ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«åã®é–“ã«ã¯ã€ç›´æ¥çš„ãªå¯¾å¿œä»˜ã‘ãŒã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®åå‰ã¯åŒã˜åå‰ç©ºé–“ã‚’å…±æœ‰ã—ã¦ã„ã‚‹ã®ã§ã™ï¼"
" [#]_"

#: ../../tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`the_answer` from the object named by "
"``modname``."
msgstr ""
"å±æ€§ã¯èª­å–ã‚Šå°‚ç”¨ã«ã‚‚ã€æ›¸è¾¼ã¿å¯èƒ½ã«ã‚‚ã§ãã¾ã™ã€‚æ›¸è¾¼ã¿å¯èƒ½ã§ã‚ã‚Œã°ã€å±æ€§ã«ä»£å…¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å±æ€§ã¯æ›¸è¾¼ã¿å¯èƒ½ã§ã€ "
"``modname.the_answer = 42`` ã¨æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚æ›¸è¾¼ã¿å¯èƒ½ãªå±æ€§ã¯ã€ :keyword:`del` "
"æ–‡ã§å‰Šé™¤ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ ``del modname.the_answer`` ã¯ã€ ``modname`` "
"ã§æŒ‡å®šã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å±æ€§ :attr:`the_answer` ã‚’é™¤å»ã—ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called "
":mod:`__main__`, so they have their own global namespace.  (The built-in "
"names actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"åå‰ç©ºé–“ã¯æ§˜ã€…ãªæ™‚ç‚¹ã§ä½œæˆã•ã‚Œã€ãã®å¯¿å‘½ã‚‚æ§˜ã€…ã§ã™ã€‚çµ„ã¿è¾¼ã¿ã®åå‰ãŒå…¥ã£ãŸåå‰ç©ºé–“ã¯ Python "
"ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒèµ·å‹•ã™ã‚‹ã¨ãã«ä½œæˆã•ã‚Œã€æ±ºã—ã¦å‰Šé™¤ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ç©ºé–“ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©ãŒèª­ã¿è¾¼ã¾ã‚ŒãŸã¨ãã«ä½œæˆã•ã‚Œã¾ã™ã€‚é€šå¸¸ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒçµ‚äº†ã™ã‚‹ã¾ã§æ®‹ã‚Šã¾ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã§å®Ÿè¡Œã•ã‚ŒãŸæ–‡ã¯ã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿å‡ºã•ã‚ŒãŸã‚‚ã®ã§ã‚‚å¯¾è©±çš„ã«èª­ã¿å‡ºã•ã‚ŒãŸã‚‚ã®ã§ã‚‚ã€"
" :mod:`__main__` ã¨ã„ã†åå‰ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¸€éƒ¨åˆ†ã§ã‚ã‚‹ã¨ã¿ãªã•ã‚Œã‚‹ã®ã§ã€ç‹¬è‡ªã®åå‰ç©ºé–“ã‚’æŒã¤ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ "
"(çµ„ã¿è¾¼ã¿ã®åå‰ã¯å®Ÿéš›ã«ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã«å­˜åœ¨ã—ã¾ã™ã€‚ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :mod:`builtins` ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™ã€‚)"

#: ../../tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to"
" describe what actually happens.)  Of course, recursive invocations each "
"have their own local namespace."
msgstr ""
"é–¢æ•°ã®ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ç©ºé–“ã¯ã€é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã«ä½œæˆã•ã‚Œã€é–¢æ•°ã‹ã‚‰æˆ»ã£ãŸã¨ãã‚„ã€é–¢æ•°å†…ã§ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã€ã‹ã¤é–¢æ•°å†…ã§å‡¦ç†ã•ã‚Œãªã‹ã£ãŸå ´åˆã«å‰Šé™¤ã•ã‚Œã¾ã™ã€‚"
" (å®Ÿéš›ã«ã¯ã€å¿˜ã‚Œã‚‰ã‚Œã‚‹ã€ã¨è¨€ã£ãŸã»ã†ãŒèµ·ãã¦ã„ã‚‹ã“ã¨ã‚’ã‚ˆãè¡¨ã—ã¦ã„ã¾ã™ã€‚) "
"ã‚‚ã¡ã‚ã‚“ã€å†å¸°å‘¼å‡ºã—ã®ã¨ãã«ã¯ã€å„ã€…ã®å‘¼ã³å‡ºã—ã§å„è‡ªã®ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ç©ºé–“ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified"
" reference to a name attempts to find the name in the namespace."
msgstr ""
"*ã‚¹ã‚³ãƒ¼ãƒ— (scope)* ã¨ã¯ã€ã‚ã‚‹åå‰ç©ºé–“ãŒç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ãªã€ Python ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒ†ã‚­ã‚¹ãƒˆä¸Šã®é ˜åŸŸã§ã™ã€‚ \"ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½\""
" ã¨ã¯ã€ä¿®é£¾ãªã—ã« (è¨³æ³¨: ``spam.egg`` ã§ã¯ãªãå˜ã« ``egg`` ã®ã‚ˆã†ã«) "
"åå‰ã‚’å‚ç…§ã—ãŸéš›ã«ã€ãã®åå‰ç©ºé–“ã‹ã‚‰åå‰ã‚’è¦‹ã¤ã‘ã‚ˆã†ã¨è©¦ã¿ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any"
" time during execution, there are at least three nested scopes whose "
"namespaces are directly accessible:"
msgstr ""
"ã‚¹ã‚³ãƒ¼ãƒ—ã¯é™çš„ã«æ±ºå®šã•ã‚Œã¾ã™ãŒã€å‹•çš„ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚å®Ÿè¡Œä¸­ã¯ã„ã¤ã§ã‚‚ã€ç›´æ¥åå‰ç©ºé–“ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã€å°‘ãªãã¨ã‚‚ä¸‰ã¤ã®å…¥ã‚Œå­ã«ãªã£ãŸã‚¹ã‚³ãƒ¼ãƒ—ãŒã‚ã‚Šã¾ã™:"

#: ../../tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr "æœ€åˆã«æ¢ã•ã‚Œã‚‹ã€æœ€ã‚‚å†…å´ã®ã‚¹ã‚³ãƒ¼ãƒ—ã¯ã€ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ã‚’æŒã£ã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contains non-local, but also non-global names"
msgstr "å¤–å´ã®(enclosing)é–¢æ•°ã®ã‚¹ã‚³ãƒ¼ãƒ—ã¯ã€è¿‘ã„ã»ã†ã‹ã‚‰é †ã«æ¢ã•ã‚Œã€ãƒ­ãƒ¼ã‚«ãƒ«ã§ã‚‚ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§ã‚‚ãªã„åå‰ã‚’æŒã£ã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr "æ¬¡ã®ã‚¹ã‚³ãƒ¼ãƒ—ã¯ã€ç¾åœ¨ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ã‚’æŒã£ã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr "ä¸€ç•ªå¤–å´ã®(æœ€å¾Œã«æ¤œç´¢ã•ã‚Œã‚‹)ã‚¹ã‚³ãƒ¼ãƒ—ã¯ãƒ“ãƒ«ãƒˆã‚¤ãƒ³åã‚’æŒã£ã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the middle scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the "
":keyword:`nonlocal` statement can be used; if not declared nonlocal, those "
"variables are read-only (an attempt to write to such a variable will simply "
"create a *new* local variable in the innermost scope, leaving the "
"identically named outer variable unchanged)."
msgstr ""
"åå‰ãŒ global "
"ã¨å®£è¨€ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®åå‰ã«å¯¾ã™ã‚‹å‚ç…§ã‚„ä»£å…¥ã¯å…¨ã¦ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ã®å…¥ã£ãŸä¸­é–“ã®ã‚¹ã‚³ãƒ¼ãƒ—ã«å¯¾ã—ã¦ç›´æ¥è¡Œã‚ã‚Œã¾ã™ã€‚æœ€å†…ã‚¹ã‚³ãƒ¼ãƒ—ã®å¤–å´ã«ã‚ã‚‹å¤‰æ•°ã«å†æŸç¸›ã™ã‚‹ã«ã¯ã€"
" :keyword:`nonlocal` æ–‡ãŒä½¿ãˆã¾ã™ã€‚nonlocal ã¨å®£è¨€ã•ã‚Œãªã‹ã£ãŸå¤‰æ•°ã¯ã€å…¨ã¦èª­ã¿å‡ºã—å°‚ç”¨ã¨ãªã‚Šã¾ã™ "
"(ãã®ã‚ˆã†ãªå¤‰æ•°ã«å¯¾ã™ã‚‹æ›¸ãè¾¼ã¿ã¯ã€å˜ã« *æ–°ã—ã„* ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã‚’ã‚‚ã£ã¨ã‚‚å†…å´ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§ä½œæˆã—ã€å¤–éƒ¨ã®ã‚¹ã‚³ãƒ¼ãƒ—ã®å€¤ã¯å¤‰åŒ–ã—ã¾ã›ã‚“)ã€‚"

#: ../../tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"é€šå¸¸ã€ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã¯ (ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ†ã‚­ã‚¹ãƒˆä¸Šã®) "
"ç¾åœ¨ã®é–¢æ•°ã®ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ã‚’å‚ç…§ã—ã¾ã™ã€‚é–¢æ•°ã®å¤–å´ã§ã¯ã€ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ç©ºé–“ã¨åŒã˜åå‰ç©ºé–“ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ã‚’å‚ç…§ã—ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹å®šç¾©ã§ã¯ã€ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®ä¸­ã«ã‚‚ã†ä¸€ã¤åå‰ç©ºé–“ãŒç½®ã‹ã‚Œã¾ã™ã€‚"

#: ../../tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution,"
" at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"ã‚¹ã‚³ãƒ¼ãƒ—ã¯ãƒ†ã‚­ã‚¹ãƒˆä¸Šã§æ±ºå®šã•ã‚Œã¦ã„ã‚‹ã¨ç†è§£ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§å®šç¾©ã•ã‚Œã‚‹é–¢æ•°ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¹ã‚³ãƒ¼ãƒ—ã¯ã€é–¢æ•°ãŒã©ã“ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã¦ã‚‚ã€ã©ã‚“ãªåˆ¥åã‚’ã¤ã‘ã¦å‘¼ã³å‡ºã•ã‚Œã¦ã‚‚ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ã«ãªã‚Šã¾ã™ã€‚åå¯¾ã«ã€å®Ÿéš›ã®åå‰ã®æ¤œç´¢ã¯å®Ÿè¡Œæ™‚ã«å‹•çš„ã«è¡Œã‚ã‚Œã¾ã™"
" --- ã¨ã¯ã„ãˆã€è¨€èªã®å®šç¾©ã¯ã€\"ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«\" æ™‚ã®é™çš„ãªåå‰è§£æ±ºã®æ–¹å‘ã«é€²åŒ–ã—ã¦ã„ã‚‹ã®ã§ã€å‹•çš„ãªåå‰è§£æ±ºã«é ¼ã£ã¦ã¯ã„ã‘ã¾ã›ã‚“ï¼ "
"(äº‹å®Ÿã€ãƒ­ãƒ¼ã‚«ãƒ«ãªå¤‰æ•°ã¯æ—¢ã«é™çš„ã«æ±ºå®šã•ã‚Œã¦ã„ã¾ã™ã€‚)"

#: ../../tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` statement is in"
" effect -- assignments to names always go into the innermost scope.  "
"Assignments do not copy data --- they just bind names to objects.  The same "
"is true for deletions: the statement ``del x`` removes the binding of ``x`` "
"from the namespace referenced by the local scope.  In fact, all operations "
"that introduce new names use the local scope: in particular, "
":keyword:`import` statements and function definitions bind the module or "
"function name in the local scope."
msgstr ""
"Python ç‰¹æœ‰ã®ç™–ã¨ã—ã¦ã€ä»£å…¥ã‚’è¡Œã†ã¨ -- ã©ã® :keyword:`global` æ–‡ã‚‚æœ‰åŠ¹ã§ãªã„å ´åˆã¯ -- "
"åå‰ãŒã„ã¤ã‚‚æœ€ã‚‚å†…å´ã®ã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã‚‹ã¨ã„ã†ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ä»£å…¥ã¯ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ”ãƒ¼ã‚’è¡Œã„ã¾ã›ã‚“ --- å˜ã«åå‰ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«çµã³ã¤ã‘ã‚‹ (bind) "
"ã ã‘ã§ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‰Šé™¤ã§ã‚‚åŒã˜ã§ã™: ``del x`` ã¯ã€ ``x`` "
"ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ãŒå‚ç…§ã—ã¦ã„ã‚‹åå‰ç©ºé–“ã‹ã‚‰å‰Šé™¤ã—ã¾ã™ã€‚å®Ÿéš›ã€æ–°ãŸãªåå‰ã‚’å°å…¥ã™ã‚‹æ“ä½œã¯å…¨ã¦ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã‚’ç”¨ã„ã¾ã™ã€‚ã¨ã‚Šã‚ã‘ã€ "
":keyword:`import` æ–‡ã‚„é–¢æ•°å®šç¾©ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„é–¢æ•°ã®åå‰ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«çµã³ä»˜ã‘ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the "
":keyword:`nonlocal` statement indicates that particular variables live in an"
" enclosing scope and should be rebound there."
msgstr ""
":keyword:`global` æ–‡ã‚’ä½¿ã†ã¨ã€ç‰¹å®šã®å¤‰æ•°ãŒã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«å­˜åœ¨ã—ã€ãã“ã§å†æŸç¸›ã•ã‚Œã‚‹ã“ã¨ã‚’æŒ‡ç¤ºã§ãã¾ã™ã€‚ "
":keyword:`nonlocal` æ–‡ã¯ã€ç‰¹å®šã®å¤‰æ•°ãŒå¤–å´ã®ã‚¹ã‚³ãƒ¼ãƒ—ã«å­˜åœ¨ã—ã€ãã“ã§å†æŸç¸›ã•ã‚Œã‚‹ã“ã¨ã‚’æŒ‡ç¤ºã—ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "ã‚¹ã‚³ãƒ¼ãƒ—ã¨åå‰ç©ºé–“ã®ä¾‹"

#: ../../tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"ç•°ãªã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ã¨åå‰ç©ºé–“ãŒã©ã®ã‚ˆã†ã«å‚ç…§ã•ã‚Œã‚‹ã‹ã€ã¾ãŸ :keyword:`global` ãŠã‚ˆã³ :keyword:`nonlocal` "
"ãŒå¤‰æ•°ã®æŸç¸›ã«ã©ã†å½±éŸ¿ã™ã‚‹ã‹ã€ã“ã®ä¾‹ã§å®Ÿæ¼”ã—ã¾ã™::"

#: ../../tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "ã“ã®ã‚³ãƒ¼ãƒ‰ä¾‹ã®å‡ºåŠ›ã¯:"

#: ../../tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"ã“ã®ã¨ãŠã‚Šã€(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®) *ãƒ­ãƒ¼ã‚«ãƒ«ãª* ä»£å…¥ã¯ *scope_test* ä¸Šã® *spam* ã¸ã®æŸç¸›ã‚’å¤‰æ›´ã—ã¾ã›ã‚“ã§ã—ãŸã€‚ "
":keyword:`nonlocal` ä»£å…¥ã¯ *scope_test* ä¸Šã® *spam* ã¸ã®æŸç¸›ã‚’å¤‰æ›´ã—ã€ :keyword:`global` "
"ä»£å…¥ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®æŸç¸›ã‚’å¤‰æ›´ã—ã¾ã—ãŸã€‚"

#: ../../tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the "
":keyword:`global` assignment."
msgstr "ã¾ãŸã“ã“ã‹ã‚‰ã€ :keyword:`global` ä»£å…¥ã®å‰ã«ã¯ *spam* ã«ä½•ã‚‚æŸç¸›ã•ã‚Œã¦ã„ãªã‹ã£ãŸã“ã¨ã‚‚åˆ†ã‹ã‚Šã¾ã™ã€‚"

#: ../../tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "ã‚¯ãƒ©ã‚¹åˆè¦‹"

#: ../../tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr "ã‚¯ãƒ©ã‚¹ã§ã¯ã€æ–°ã—ã„æ§‹æ–‡ã‚’å°‘ã—ã¨ã€ä¸‰ã¤ã®æ–°ãŸãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã€ãã—ã¦æ–°ãŸãªæ„å‘³ä»˜ã‘ã‚’ã„ãã¤ã‹å–ã‚Šå…¥ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "ã‚¯ãƒ©ã‚¹å®šç¾©ã®æ§‹æ–‡"

#: ../../tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "ã‚¯ãƒ©ã‚¹å®šç¾©ã®æœ€ã‚‚å˜ç´”ãªå½¢å¼ã¯ã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"é–¢æ•°å®šç¾© (:keyword:`def` æ–‡) ã¨åŒæ§˜ã€ã‚¯ãƒ©ã‚¹å®šç¾©ãŒåŠ¹æœã‚’ã‚‚ã¤ã«ã¯ã¾ãšå®Ÿè¡Œã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ (ã‚¯ãƒ©ã‚¹å®šç¾©ã‚’ "
":keyword:`if` æ–‡ã®åˆ†å²å…ˆã‚„é–¢æ•°å†…éƒ¨ã«ç½®ãã“ã¨ã‚‚ã€è€ƒãˆæ–¹ã¨ã—ã¦ã¯ã‚ã‚Šãˆã¾ã™ã€‚)"

#: ../../tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful"
" --- we'll come back to this later.  The function definitions inside a class"
" normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"å®Ÿéš›ã«ã¯ã€ã‚¯ãƒ©ã‚¹å®šç¾©ã®å†…å´ã«ã‚ã‚‹æ–‡ã¯ã€é€šå¸¸ã¯é–¢æ•°å®šç¾©ã«ãªã‚Šã¾ã™ãŒã€ä»–ã®æ–‡ã‚’æ›¸ãã“ã¨ã‚‚ã§ãã€ãã‚ŒãŒå½¹ã«ç«‹ã¤ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ --- "
"ã“ã‚Œã«ã¤ã„ã¦ã¯å¾Œã§è¿°ã¹ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹å†…ã®é–¢æ•°å®šç¾©ã¯é€šå¸¸ã€ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—è¦ç´„ã§æ±ºã‚ã‚‰ã‚ŒãŸç‹¬ç‰¹ã®å½¢å¼ã®å¼•æ•°ãƒªã‚¹ãƒˆã‚’æŒã¡ã¾ã™ --- "
"ã“ã‚Œã«ã¤ã„ã¦ã‚‚å¾Œã§è¿°ã¹ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new"
" function here."
msgstr ""
"ã‚¯ãƒ©ã‚¹å®šç¾©ã«å…¥ã‚‹ã¨ã€æ–°ãŸãªåå‰ç©ºé–“ãŒä½œæˆã•ã‚Œã€ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ç©ºé–“ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ --- "
"å¾“ã£ã¦ã€ãƒ­ãƒ¼ã‚«ãƒ«ãªå¤‰æ•°ã«å¯¾ã™ã‚‹å…¨ã¦ã®ä»£å…¥ã¯ã“ã®æ–°ãŸãªåå‰ç©ºé–“ã«å…¥ã‚Šã¾ã™ã€‚ç‰¹ã«ã€é–¢æ•°å®šç¾©ã‚’è¡Œã†ã¨ã€æ–°ãŸãªé–¢æ•°ã®åå‰ã¯ã“ã®åå‰ç©ºé–“ã«çµã³ä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the"
" next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header "
"(:class:`ClassName` in the example)."
msgstr ""
"ã‚¯ãƒ©ã‚¹å®šç¾©ã‹ã‚‰æ™®é€šã« (å®šç¾©ã®çµ‚ç«¯ã«åˆ°é”ã—ã¦) æŠœã‘ã‚‹ã¨ã€ *ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (class object)* "
"ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€åŸºæœ¬çš„ã«ã¯ã‚¯ãƒ©ã‚¹å®šç¾©ã§ä½œæˆã•ã‚ŒãŸåå‰ç©ºé–“ã®å†…å®¹ã‚’ãã‚‹ã‚€ãƒ©ãƒƒãƒ‘ (wrapper) "
"ã§ã™ã€‚ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã¯æ¬¡ã®ç¯€ã§è©³ã—ãå­¦ã¶ã“ã¨ã«ã—ã¾ã™ã€‚ (ã‚¯ãƒ©ã‚¹å®šç¾©ã«å…¥ã‚‹å‰ã«æœ‰åŠ¹ã ã£ãŸ) "
"å…ƒã®ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ãŒå¾©å¸°ã—ã€ç”Ÿæˆã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¾©å¸°ã—ãŸãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«ã‚¯ãƒ©ã‚¹å®šç¾©ã®ãƒ˜ãƒƒãƒ€ã§æŒ‡å®šã—ãŸåå‰ (ä¸Šã®ä¾‹ã§ã¯ "
":class:`ClassName`) ã§çµã³ä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../tutorial/classes.rst:259
msgid "Class Objects"
msgstr "ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr "ã‚¯ãƒ©ã‚¹ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ï¼’ç¨®é¡ã®æ¼”ç®—ã€å±æ€§å‚ç…§ã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names"
" that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"*å±æ€§å‚ç…§ (attribute reference)* ã¯ã€Python ã«ãŠã‘ã‚‹ã™ã¹ã¦ã®å±æ€§å‚ç…§ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹æ¨™æº–çš„ãªæ§‹æ–‡ã€ "
"``obj.name`` "
"ã‚’ä½¿ã„ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã•ã‚ŒãŸéš›ã«ã‚¯ãƒ©ã‚¹ã®åå‰ç©ºé–“ã«ã‚ã£ãŸåå‰ã™ã¹ã¦ãŒæœ‰åŠ¹ãªå±æ€§åã§ã™ã€‚å¾“ã£ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚¯ãƒ©ã‚¹å®šç¾©ã§ã¯::"

#: ../../tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"``MyClass.i`` ã¨ ``MyClass.f`` "
"ã¯å¦¥å½“ãªå±æ€§å‚ç…§ã§ã‚ã‚Šã€ãã‚Œãã‚Œæ•´æ•°ã¨é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹å±æ€§ã«ä»£å…¥ã‚’è¡Œã†ã“ã¨ã‚‚ã§ãã¾ã™ã€‚å¾“ã£ã¦ã€ ``MyClass.i`` "
"ã®å€¤ã‚’ä»£å…¥ã—ã¦å¤‰æ›´ã§ãã¾ã™ã€‚ :attr:`__doc__` ã‚‚æœ‰åŠ¹ãªå±æ€§ã§ã€ãã®ã‚¯ãƒ©ã‚¹ã«å±ã—ã¦ã„ã‚‹ docstringã€ã“ã®å ´åˆã¯ ``\"A "
"simple example class\"`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class."
" For example (assuming the above class)::"
msgstr ""
"ã‚¯ãƒ©ã‚¹ã® *ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ– (instantiation)* "
"ã«ã¯é–¢æ•°ã®ã‚ˆã†ãªè¡¨è¨˜æ³•ã‚’ä½¿ã„ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã“ã¨ã‚’ã€å˜ã«ã‚¯ãƒ©ã‚¹ã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™å¼•æ•°ãŒãªã„é–¢æ•°ã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã„ã¾ã™ã€‚ä¾‹ãˆã° "
"(ä¸Šè¨˜ã®ã‚¯ãƒ©ã‚¹ã§ã„ãˆã°)::"

#: ../../tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr "ã¯ã€ã‚¯ãƒ©ã‚¹ã®æ–°ã—ã„ *ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ (instance)* ã‚’ç”Ÿæˆã—ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•° ``x`` ã¸ä»£å…¥ã—ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named "
":meth:`__init__`, like this::"
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆæ“ä½œ (ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® \"å‘¼å‡ºã—\") "
"ã‚’è¡Œã†ã¨ã€ç©ºã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚å¤šãã®ã‚¯ãƒ©ã‚¹ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹éš›ã«ã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã•ã‚ŒãŸç‰¹å®šã®åˆæœŸçŠ¶æ…‹ã«ãªã£ã¦ã»ã—ã„ã¨æœ›ã‚“ã§ã„ã¾ã™ã€‚ãã®ãŸã‚ã«ã€ã‚¯ãƒ©ã‚¹ã«ã¯"
" :meth:`__init__` ã¨ã„ã†åå‰ã®ç‰¹åˆ¥ãªãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`__init__` method, class instantiation "
"automatically invokes :meth:`__init__` for the newly-created class instance."
"  So in this example, a new, initialized instance can be obtained by::"
msgstr ""
"ã‚¯ãƒ©ã‚¹ãŒ :meth:`__init__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã‚‹å ´åˆã€ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ã¨ã€æ–°ã—ãç”Ÿæˆã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã—ã¦è‡ªå‹•çš„ã« :meth:`__init__` "
"ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚å¾“ã£ã¦ã€ã“ã®ä¾‹ã§ã¯ã€æ–°ãŸãªåˆæœŸæ¸ˆã¿ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ¬¡ã®ã‚ˆã†ã«ã—ã¦å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`__init__` method may have arguments for greater "
"flexibility.  In that case, arguments given to the class instantiation "
"operator are passed on to :meth:`__init__`.  For example, ::"
msgstr ""
"ã‚‚ã¡ã‚ã‚“ã€ã‚ˆã‚Šå¤§ããªæŸ”è»Ÿæ€§ã‚’æŒãŸã›ã‚‹ãŸã‚ã«ã€ :meth:`__init__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã«è¤‡æ•°ã®å¼•æ•°ã‚’ã‚‚ãŸã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãã®å ´åˆã€æ¬¡ã®ä¾‹ã®ã‚ˆã†ã«ã€ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆæ“ä½œã«æ¸¡ã•ã‚ŒãŸå¼•æ•°ã¯ :meth:`__init__` "
"ã«æ¸¡ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ::"

#: ../../tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by"
" instance objects are attribute references.  There are two kinds of valid "
"attribute names, data attributes and methods."
msgstr ""
"ã¨ã“ã‚ã§ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã†ã¨ä½•ãŒã§ãã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç†è§£ã§ãã‚‹å”¯ä¸€ã®æ“ä½œã¯ã€å±æ€§ã®å‚ç…§ã§ã™ã€‚æœ‰åŠ¹ãªå±æ€§ã®åå‰ã«ã¯äºŒç¨®é¡(ãƒ‡ãƒ¼ã‚¿å±æ€§ãŠã‚ˆã³ãƒ¡ã‚½ãƒƒãƒ‰)ã‚ã‚Šã¾ã™ã€‚"

#: ../../tutorial/classes.rst:328
msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"*ãƒ‡ãƒ¼ã‚¿å±æ€§ (data attribute)* ã¯ã€ã“ã‚Œã¯ Smalltalk ã® \"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°\" ã‚„ C++ã® \"ãƒ‡ãƒ¼ã‚¿ãƒ¡ãƒ³ãƒ\" "
"ã«ç›¸å½“ã—ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿å±æ€§ã‚’å®£è¨€ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ­ãƒ¼ã‚«ãƒ«ãªå¤‰æ•°ã¨åŒæ§˜ã«ã€ã“ã‚Œã‚‰ã®å±æ€§ã¯æœ€åˆã«ä»£å…¥ã•ã‚ŒãŸæ™‚ç‚¹ã§æ¹§ãå‡ºã¦ãã¾ã™ã€‚ä¾‹ãˆã°ã€ä¸Šã§ç”Ÿæˆã—ãŸ "
":class:`MyClass` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ ``x`` ã«å¯¾ã—ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€å€¤ ``16`` ã‚’å°å­—ã—ã€ ``x`` "
"ã®ç—•è·¡ã¯æ®‹ã‚Šã¾ã›ã‚“::"

#: ../../tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object.  (In Python, the term method is not "
"unique to class instances: other object types can have methods as well.  For"
" example, list objects have methods called append, insert, remove, sort, and"
" so on. However, in the following discussion, we'll use the term method "
"exclusively to mean methods of class instance objects, unless explicitly "
"stated otherwise.)"
msgstr ""
"ã‚‚ã†ã²ã¨ã¤ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã¯ *ãƒ¡ã‚½ãƒƒãƒ‰ (method)* ã§ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã« \"å±ã—ã¦ã„ã‚‹\" é–¢æ•°ã®ã“ã¨ã§ã™ã€‚(Python "
"ã§ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã„ã†ç”¨èªã¯ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã ã‘ã®ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã«ã‚‚ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒªã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€ "
"append, insert, remove, sort "
"ãªã©ã¨ã„ã£ãŸãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚ã¨ã¯ã„ãˆã€ä»¥ä¸‹ã§ã¯ç‰¹ã«æ˜è¨˜ã—ãªã„é™ã‚Šã€ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã ã‘ã‚’æ„å‘³ã™ã‚‹ã‚‚ã®ã¨ã—ã¦ä½¿ã†ã“ã¨ã«ã—ã¾ã™ã€‚)"

#: ../../tutorial/classes.rst:349
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§æœ‰åŠ¹ãªãƒ¡ã‚½ãƒƒãƒ‰åã¯ã€ãã®ã‚¯ãƒ©ã‚¹ã«ã‚ˆã‚Šã¾ã™ã€‚å®šç¾©ã«ã‚ˆã‚Šã€ã‚¯ãƒ©ã‚¹ã®å…¨ã¦ã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹å±æ€§ãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¦¥å½“ãªãƒ¡ã‚½ãƒƒãƒ‰åã«æ±ºã¾ã‚Šã¾ã™ã€‚å¾“ã£ã¦ã€ä¾‹ã§ã¯ã€``MyClass.f``"
" ã¯é–¢æ•°ãªã®ã§ã€``x.f`` ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã®å‚ç…§ã¨ã—ã¦æœ‰åŠ¹ã§ã™ã€‚ã—ã‹ã—ã€``MyClass.i`` ã¯é–¢æ•°ã§ã¯ãªã„ã®ã§ã€``x.i`` "
"ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã®å‚ç…§ã¨ã—ã¦æœ‰åŠ¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚``x.f`` ã¯ ``MyClass.f`` ã¨åŒã˜ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ --- "
"é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãªãã€*ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (method object)* ã§ã™ã€‚"

#: ../../tutorial/classes.rst:360
msgid "Method Objects"
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../tutorial/classes.rst:362
msgid "Usually, a method is called right after it is bound::"
msgstr "æ™®é€šã€ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒã‚¤ãƒ³ãƒ‰ã•ã‚ŒãŸç›´å¾Œã«å‘¼ã³å‡ºã•ã‚Œã¾ã™::"

#: ../../tutorial/classes.rst:366
msgid ""
"In the :class:`MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
":class:`MyClass` ã®ä¾‹ã§ã¯ã€ä¸Šã®ã‚³ãƒ¼ãƒ‰ã¯æ–‡å­—åˆ— ``'hello world'`` "
"ã‚’è¿”ã™ã§ã—ã‚‡ã†ã€‚ã—ã‹ã—ãªãŒã‚‰ã€å¿…ãšã—ã‚‚ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãã®å ´ã§å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚‰ãªã„ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ ``x.f`` "
"ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚Šã€ã©ã“ã‹ã«è¨˜æ†¶ã—ã¦ãŠã„ã¦å¾Œã§å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯::"

#: ../../tutorial/classes.rst:374
msgid "will continue to print ``hello world`` until the end of time."
msgstr "``hello world`` ã‚’æ™‚ãŒçµ‚ã‚ã‚‹ã¾ã§å°å­—ã—ç¶šã‘ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../tutorial/classes.rst:376
msgid ""
"What exactly happens when a method is called?  You may have noticed that "
"``x.f()`` was called without an argument above, even though the function "
"definition for :meth:`f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an"
" argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ãã«ã¯å®Ÿéš›ã«ã¯ä½•ãŒèµ·ãã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ :meth:`f` ã®é–¢æ•°å®šç¾©ã§ã¯å¼•æ•°ã‚’ä¸€ã¤æŒ‡å®šã—ã¦ã„ãŸã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€ä¸Šã®ä¾‹ã§ã¯ "
"``x.f()`` ãŒå¼•æ•°ãªã—ã§å‘¼ã³å‡ºã•ã‚Œã¦ã„ã¾ã™ã€‚å¼•æ•°ã¯ã©ã†ãªã£ãŸã®ã§ã—ã‚‡ã†ã‹ï¼ŸãŸã—ã‹ã€å¼•æ•°ãŒå¿…è¦ãªé–¢æ•°ã‚’å¼•æ•°ç„¡ã—ã§å‘¼ã³å‡ºã™ã¨ã€ Python "
"ãŒä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ã¯ãšã§ã™ --- ãŸã¨ãˆãã®å¼•æ•°ãŒå®Ÿéš›ã«ã¯ä½¿ã‚ã‚Œãªãã¦ã‚‚â€¦ã€‚"

#: ../../tutorial/classes.rst:382
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the function."
"  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments"
" is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"ã‚‚ã†ç­”ã¯æƒ³åƒã§ãã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã­:\n"
"ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¤ã„ã¦ç‰¹åˆ¥ãªã“ã¨ã¨ã—ã¦ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒé–¢æ•°ã®ç¬¬1å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã¾ã™ã€‚\n"
"ä¾‹ã§ã¯ã€ ``x.f()`` ã¨ã„ã†å‘¼ã³å‡ºã—ã¯ã€ ``MyClass.f(x)`` ã¨å³å¯†ã«ç­‰ä¾¡ãªã‚‚ã®ã§ã™ã€‚\n"
"ä¸€èˆ¬ã«ã€ *n* å€‹ã®å¼•æ•°ãƒªã‚¹ãƒˆã‚‚ã£ãŸãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼å‡ºã—ã¯ã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æœ€åˆã®å¼•æ•°ã®å‰ã«æŒ¿å…¥ã—ãŸå¼•æ•°ãƒªã‚¹ãƒˆã§ã€ãƒ¡ã‚½ãƒƒãƒ‰ã«å¯¾å¿œã™ã‚‹é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../tutorial/classes.rst:389
msgid ""
"If you still don't understand how methods work, a look at the implementation"
" can perhaps clarify matters.  When a non-data attribute of an instance is "
"referenced, the instance's class is searched.  If the name denotes a valid "
"class attribute that is a function object, a method object is created by "
"packing (pointers to) the instance object and the function object just found"
" together in an abstract object: this is the method object.  When the method"
" object is called with an argument list, a new argument list is constructed "
"from the instance object and the argument list, and the function object is "
"called with this new argument list."
msgstr ""

#: ../../tutorial/classes.rst:403
msgid "Class and Instance Variables"
msgstr "ã‚¯ãƒ©ã‚¹ã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°"

#: ../../tutorial/classes.rst:405
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"ä¸€èˆ¬çš„ã«ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã¯ãã‚Œãã‚Œã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã¤ã„ã¦å›ºæœ‰ã®ãƒ‡ãƒ¼ã‚¿ã®ãŸã‚ã®ã‚‚ã®ã§ã€ã‚¯ãƒ©ã‚¹å¤‰æ•°ã¯ãã®ã‚¯ãƒ©ã‚¹ã®ã™ã¹ã¦ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã‚ˆã£ã¦å…±æœ‰ã•ã‚Œã‚‹å±æ€§ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã®ãŸã‚ã®ã‚‚ã®ã§ã™::"

#: ../../tutorial/classes.rst:427
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
":ref:`tut-object` ã§è­°è«–ã—ãŸã‚ˆã†ã«ã€å…±æœ‰ãƒ‡ãƒ¼ã‚¿ã¯ãƒªã‚¹ãƒˆã‚„è¾æ›¸ã®ã‚ˆã†ãª :term:`mutable` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒé–¢ä¸ã™ã‚‹ã¨é©šãã¹ãåŠ¹æœã‚’æŒã¡å¾—ã¾ã™ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã® *tricks* "
"ãƒªã‚¹ãƒˆã¯ã‚¯ãƒ©ã‚¹å¤‰æ•°ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€ãªãœãªã‚‰ãŸã£ãŸä¸€ã¤ã®ãƒªã‚¹ãƒˆãŒã™ã¹ã¦ã® *Dog* "
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã‚ˆã£ã¦å…±æœ‰ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šå¾—ã‚‹ã‹ã‚‰ã§ã™::"

#: ../../tutorial/classes.rst:450
msgid "Correct design of the class should use an instance variable instead::"
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã®æ­£ã—ã„è¨­è¨ˆã§ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‚’ä»£ã‚ã‚Šã«ä½¿ç”¨ã™ã‚‹ã¹ãã§ã™::"

#: ../../tutorial/classes.rst:474
msgid "Random Remarks"
msgstr "ã„ã‚ã„ã‚ãªæ³¨æ„ç‚¹"

#: ../../tutorial/classes.rst:478
msgid ""
"Data attributes override method attributes with the same name; to avoid "
"accidental name conflicts, which may cause hard-to-find bugs in large "
"programs, it is wise to use some kind of convention that minimizes the "
"chance of conflicts.  Possible conventions include capitalizing method "
"names, prefixing data attribute names with a small unique string (perhaps "
"just an underscore), or using verbs for methods and nouns for data "
"attributes."
msgstr ""
"ãƒ‡ãƒ¼ã‚¿å±æ€§ã¯åŒã˜åå‰ã®ãƒ¡ã‚½ãƒƒãƒ‰å±æ€§ã‚’ä¸Šæ›¸ãã—ã¦ã—ã¾ã„ã¾ã™ã€‚å¤§è¦æ¨¡ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¿ã¤ã‘ã«ãã„ãƒã‚°ã‚’å¼•ãèµ·ã“ã™ã“ã¨ãŒã‚ã‚‹ã“ã®å¶ç„¶çš„ãªåå‰ã®è¡çªã‚’é¿ã‘ã‚‹ã«ã¯ã€è¡çªã®å¯èƒ½æ€§ã‚’æœ€å°é™ã«ã™ã‚‹ã‚ˆã†ãªè¦ç´„ã‚’ä½¿ã†ã®ãŒè³¢æ˜ã§ã™ã€‚å¯èƒ½ãªè¦ç´„ã¨ã—ã¦ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰åã‚’å¤§æ–‡å­—ã§å§‹ã‚ã‚‹ã€ãƒ‡ãƒ¼ã‚¿å±æ€§åã®å…ˆé ­ã«çŸ­ã„ä¸€æ„ãªæ–‡å­—åˆ—"
" (ã‚ã‚‹ã„ã¯ãŸã ã®ä¸‹ç·š) ã‚’ã¤ã‘ã‚‹ã€ã¾ãŸãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯å‹•è©ã€ãƒ‡ãƒ¼ã‚¿å±æ€§ã«ã¯åè©ã‚’ç”¨ã„ã‚‹ã€ãªã©ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../tutorial/classes.rst:485
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide"
" implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"ãƒ‡ãƒ¼ã‚¿å±æ€§ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰å‚ç…§ã§ãã‚‹ã¨åŒæ™‚ã«ã€é€šå¸¸ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¦ãƒ¼ã‚¶ (\"ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ\") "
"ã‹ã‚‰ã‚‚å‚ç…§ã§ãã¾ã™ã€‚è¨€ã„æ›ãˆã‚‹ã¨ã€ã‚¯ãƒ©ã‚¹ã¯ç´”ç²‹ãªæŠ½è±¡ãƒ‡ãƒ¼ã‚¿å‹ã¨ã—ã¦ä½¿ã†ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚å®Ÿéš›ã€ Python "
"ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿éš è”½ã‚’è£œå¼·ã™ã‚‹ãŸã‚ã®æ©Ÿæ§‹ã¯ãªã«ã‚‚ã‚ã‚Šã¾ã›ã‚“ --- ãƒ‡ãƒ¼ã‚¿ã®éš è”½ã¯ã™ã¹ã¦è¦ç´„ã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚ (é€†ã«ã€C è¨€èªã§æ›¸ã‹ã‚ŒãŸ Python "
"ã®å®Ÿè£…ã§ã¯å®Ÿè£…ã®è©³ç´°ã‚’å®Œå…¨ã«éš è”½ã—ã€å¿…è¦ã«å¿œã˜ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’åˆ¶å¾¡ã§ãã¾ã™ã€‚ã“ã®æ©Ÿæ§‹ã¯ C è¨€èªã§æ›¸ã‹ã‚ŒãŸ Python "
"æ‹¡å¼µã§ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚)"

#: ../../tutorial/classes.rst:493
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object"
" without affecting the validity of the methods, as long as name conflicts "
"are avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ãƒ‡ãƒ¼ã‚¿å±æ€§ã‚’æ³¨æ„æ·±ãæ‰±ã†ã¹ãã§ã™ --- "
"ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ãŒç¶­æŒã—ã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿å±æ€§ã®ä¸å¤‰å¼ã‚’è¸ã¿ã«ã˜ã‚Šã€å°ç„¡ã—ã«ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã€åå‰ã®è¡çªãŒå›é¿ã•ã‚Œã¦ã„ã‚‹é™ã‚Šã€ãƒ¡ã‚½ãƒƒãƒ‰ã®æœ‰åŠ¹æ€§ã«å½±éŸ¿ã‚’åŠã¼ã™ã“ã¨ãªãã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ç‹¬è‡ªã®å±æ€§ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„"
" --- ã“ã“ã§ã‚‚ã€åå‰ä»˜ã‘ã®è¦ç´„ã¯é ­ç—›ã®ç¨®ã‚’ç„¡ãã—ã¦ãã‚Œã¾ã™ã€‚"

#: ../../tutorial/classes.rst:499
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of"
" methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸­ã‹ã‚‰ã€ãƒ‡ãƒ¼ã‚¿å±æ€§ã‚’ (ã¾ãŸã¯åˆ¥ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ï¼) "
"å‚ç…§ã™ã‚‹ãŸã‚ã®çŸ­ç¸®ã•ã‚ŒãŸè¨˜æ³•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ç§ã¯ã€ã“ã®ä»•æ§˜ãŒãƒ¡ã‚½ãƒƒãƒ‰ã®å¯èª­æ€§ã‚’é«˜ã‚ã¦ã„ã‚‹ã¨æ„Ÿã˜ã¦ã„ã¾ã™ã€‚ã‚ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’çœºã‚ã¦ã„ã‚‹ã¨ãã«ãƒ­ãƒ¼ã‚«ãƒ«ãªå¤‰æ•°ã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‚’ã¯ã£ãã‚ŠåŒºåˆ¥ã§ãã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../tutorial/classes.rst:504
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable"
" that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"ã‚ˆãã€ãƒ¡ã‚½ãƒƒãƒ‰ã®æœ€åˆã®å¼•æ•°ã‚’ ``self`` ã¨å‘¼ã³ã¾ã™ã€‚ã“ã®åå‰ä»˜ã‘ã¯å˜ãªã‚‹æ…£ç¿’ã§ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ ``self`` ã¨ã„ã†åå‰ã¯ã€ Python "
"ã§ã¯ä½•ã‚‰ç‰¹æ®Šãªæ„å‘³ã‚’æŒã¡ã¾ã›ã‚“ã€‚ã¨ã¯ã„ãˆã€ã“ã®æ…£è¡Œã«å¾“ã‚ãªã„ã¨ã€ã‚³ãƒ¼ãƒ‰ã¯ä»–ã® Python ãƒ—ãƒ­ã‚°ãƒ©ãƒã«ã¨ã£ã¦ã‚„ã‚„èª­ã¿ã«ãã„ã‚‚ã®ã¨ãªã‚Šã¾ã™ã€‚ã¾ãŸã€ "
"*ã‚¯ãƒ©ã‚¹ãƒ–ãƒ©ã‚¦ã‚¶ (class browser)* ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã“ã®æ…£è¡Œã‚’ã‚ã¦ã«ã—ã¦æ›¸ã‹ã‚Œã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../tutorial/classes.rst:510
msgid ""
"Any function object that is a class attribute defines a method for instances"
" of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a"
" local variable in the class is also ok.  For example::"
msgstr ""
"ã‚¯ãƒ©ã‚¹å±æ€§ã§ã‚ã‚‹é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã„ãšã‚Œã‚‚ã€ãã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚é–¢æ•°å®šç¾©ã¯ã€ãƒ†ã‚­ã‚¹ãƒˆä¸Šã§ã‚¯ãƒ©ã‚¹å®šç¾©ã®ä¸­ã«å…¥ã£ã¦ã„ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒ©ã‚¹ã®ãƒ­ãƒ¼ã‚«ãƒ«ãªå¤‰æ•°ã®ä¸­ã«ä»£å…¥ã™ã‚‹ã®ã‚‚"
" OK ã§ã™ã€‚ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../tutorial/classes.rst:527
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`C` that refer"
" to function objects, and consequently they are all methods of instances of "
":class:`C` --- ``h`` being exactly equivalent to ``g``.  Note that this "
"practice usually only serves to confuse the reader of a program."
msgstr ""
"ã“ã‚Œã§ã€ ``f`` ã€ ``g`` ã€ãŠã‚ˆã³ ``h`` ã¯ã€ã™ã¹ã¦ :class:`C` "
"ã®å±æ€§ã§ã‚ã‚Šé–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã—ã¦ã„ã¾ã™ã€‚å¾“ã£ã¦ã€ã“ã‚Œã‚‰å…¨ã¦ã¯ã€ :class:`C` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨ãªã‚Šã¾ã™ --- ``h`` ã¯ "
"``g`` ã¨å…¨ãç­‰ä¾¡ã§ã™ã€‚ã“ã‚Œã‚’å®Ÿè·µã—ã¦ã‚‚ã€å¤§æŠµã¯å˜ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®èª­è€…ã«æ··ä¹±ã‚’ã‚‚ãŸã‚‰ã™ã ã‘ãªã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/classes.rst:532
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ ``self`` å¼•æ•°ã®ãƒ¡ã‚½ãƒƒãƒ‰å±æ€§ã‚’ä½¿ã£ã¦ã€ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/classes.rst:546
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some"
" good reasons why a method would want to reference its own class."
msgstr ""
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€é€šå¸¸ã®é–¢æ•°ã¨åŒã˜ã‚ˆã†ã«ã—ã¦ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ã‚’å‚ç…§ã—ã¾ã™ã€‚ã‚ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã«é–¢ã™ã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã¯ã€ãã®å®šç¾©ã‚’å«ã‚€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ã€‚(ã‚¯ãƒ©ã‚¹ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¹ã‚³ãƒ¼ãƒ—ã¨ã—ã¦ç”¨ã„ã‚‰ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚)"
" "
"ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã†è‰¯ã„ç†ç”±ã¯ã»ã¨ã‚“ã©ã‚ã‚Šã¾ã›ã‚“ãŒã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¹ã‚³ãƒ¼ãƒ—ã‚’ä½¿ã†ã¹ãå ´é¢ã¯å¤šã€…ã‚ã‚Šã¾ã™ã€‚ä¸€ã¤æŒ™ã’ã‚‹ã¨ã€ãƒ¡ã‚½ãƒƒãƒ‰å†…ã‹ã‚‰ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¹ã‚³ãƒ¼ãƒ—ã«"
" import "
"ã•ã‚ŒãŸé–¢æ•°ã‚„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸­ã§å®šç¾©ã•ã‚ŒãŸé–¢æ•°ã‚„ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚é€šå¸¸ã€ãƒ¡ã‚½ãƒƒãƒ‰ã®å…¥ã£ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹è‡ªä½“ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¹ã‚³ãƒ¼ãƒ—å†…ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚æ¬¡ã®ç¯€ã§ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ãŒè‡ªåˆ†ã®ã‚¯ãƒ©ã‚¹ã‚’å‚ç…§ã™ã‚‹ç†ç”±ã¨ã—ã¦æ­£å½“ãªã‚‚ã®ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚"

#: ../../tutorial/classes.rst:556
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"å€‹ã€…ã®å€¤ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã®ã§ã€ *ã‚¯ãƒ©ã‚¹* (*å‹* ã¨ã‚‚è¨€ã„ã¾ã™) ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ãã‚Œã¯ ``object.__class__`` "
"ã«ä¿æŒã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../tutorial/classes.rst:563
msgid "Inheritance"
msgstr "ç¶™æ‰¿"

#: ../../tutorial/classes.rst:565
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"è¨€ã†ã¾ã§ã‚‚ãªãã€ç¶™æ‰¿ã®æ¦‚å¿µã‚’ã‚µãƒãƒ¼ãƒˆã—ãªã„è¨€èªæ©Ÿèƒ½ã¯ \"ã‚¯ãƒ©ã‚¹\" ã¨å‘¼ã¶ã«å€¤ã—ã¾ã›ã‚“ã€‚æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ (derived class) "
"ã‚’å®šç¾©ã™ã‚‹æ§‹æ–‡ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../tutorial/classes.rst:576
msgid ""
"The name :class:`BaseClassName` must be defined in a scope containing the "
"derived class definition.  In place of a base class name, other arbitrary "
"expressions are also allowed.  This can be useful, for example, when the "
"base class is defined in another module::"
msgstr ""
"åŸºåº•ã‚¯ãƒ©ã‚¹ (base class) ã®åå‰ :class:`BaseClassName` "
"ã¯ã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹å®šç¾©ã®å…¥ã£ã¦ã„ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ã§å®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚åŸºåº•ã‚¯ãƒ©ã‚¹åã®ã‹ã‚ã‚Šã«ä»»æ„ã®å¼ã‚’å…¥ã‚Œã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã“ã‚Œã¯æ¬¡ã®ä¾‹ã®ã‚ˆã†ã«ã€åŸºåº•ã‚¯ãƒ©ã‚¹ãŒåˆ¥ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã¨ãã«ä¾¿åˆ©ãªã“ã¨ãŒã‚ã‚Šã¾ã™::"

#: ../../tutorial/classes.rst:583
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is"
" not found in the class, the search proceeds to look in the base class.  "
"This rule is applied recursively if the base class itself is derived from "
"some other class."
msgstr ""
"æ´¾ç”Ÿã‚¯ãƒ©ã‚¹å®šç¾©ã®å®Ÿè¡Œã¯ã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®å ´åˆã¨åŒã˜ã‚ˆã†ã«é€²ã‚ã‚‰ã‚Œã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ§‹ç¯‰ã•ã‚Œã‚‹æ™‚ã€åŸºåº•ã‚¯ãƒ©ã‚¹ãŒè¨˜æ†¶ã•ã‚Œã¾ã™ã€‚è¨˜æ†¶ã•ã‚ŒãŸåŸºåº•ã‚¯ãƒ©ã‚¹ã¯ã€å±æ€§å‚ç…§ã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚è¦æ±‚ã•ã‚ŒãŸå±æ€§ãŒã‚¯ãƒ©ã‚¹ã«è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã€åŸºåº•ã‚¯ãƒ©ã‚¹ã«æ¤œç´¢ãŒé€²ã¿ã¾ã™ã€‚ã“ã®è¦å‰‡ã¯ã€åŸºåº•ã‚¯ãƒ©ã‚¹ãŒä»–ã®ä½•ã‚‰ã‹ã®ã‚¯ãƒ©ã‚¹ã‹ã‚‰æ´¾ç”Ÿã—ãŸã‚‚ã®ã§ã‚ã£ãŸå ´åˆã€å†å¸°çš„ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../tutorial/classes.rst:589
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã§ã¯ã€ç‰¹åˆ¥ãªã“ã¨ã¯ä½•ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚ ``DerivedClassName()`` "
"ã¯ã‚¯ãƒ©ã‚¹ã®æ–°ãŸãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã®å‚ç…§ã¯æ¬¡ã®ã‚ˆã†ã«ã—ã¦è§£æ±ºã•ã‚Œã¾ã™ã€‚ã¾ãšå¯¾å¿œã™ã‚‹ã‚¯ãƒ©ã‚¹å±æ€§ãŒæ¤œç´¢ã•ã‚Œã¾ã™ã€‚æ¤œç´¢ã¯ã€å¿…è¦ã«å¿œã˜ã€åŸºåº•ã‚¯ãƒ©ã‚¹é€£é–ã‚’ä¸‹ã£ã¦è¡Œã‚ã‚Œã€æ¤œç´¢ã®çµæœã¨ã—ã¦ä½•ã‚‰ã‹ã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚‚ãŸã‚‰ã•ã‚ŒãŸå ´åˆã€ãƒ¡ã‚½ãƒƒãƒ‰å‚ç…§ã¯æœ‰åŠ¹ãªã‚‚ã®ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/classes.rst:595
msgid ""
"Derived classes may override methods of their base classes.  Because methods"
" have no special privileges when calling other methods of the same object, a"
" method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã¯åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¸Šæ›¸ã (override) "
"ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã¯åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åˆ¥ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™éš›ã«ä½•ã‚‰ç‰¹æ®Šãªæ¨©é™ã‚’æŒã¡ã¾ã›ã‚“ã€‚ã“ã®ãŸã‚ã€ã‚ã‚‹åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã€åŒã˜åŸºåº•ã‚¯ãƒ©ã‚¹ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚‚ã†ä¸€ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—ã‚’è¡Œã£ã¦ã„ã‚‹å ´åˆã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã§ä¸Šæ›¸ãã•ã‚ŒãŸä½•ã‚‰ã‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"
" (C++ ãƒ—ãƒ­ã‚°ãƒ©ãƒã¸:  Python ã§ã¯ã€ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯äº‹å®Ÿä¸Š ``virtual`` ã§ã™ã€‚)"

#: ../../tutorial/classes.rst:601
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call "
"``BaseClassName.methodname(self, arguments)``.  This is occasionally useful "
"to clients as well.  (Note that this only works if the base class is "
"accessible as ``BaseClassName`` in the global scope.)"
msgstr ""
"æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã§ä¸Šæ›¸ãã—ã¦ã„ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®åŒåã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç½®ãæ›ãˆã‚‹ã®ã§ã¯ãªãã€æ‹¡å¼µã—ãŸã„ã®ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç›´æ¥å‘¼ã³å‡ºã™ç°¡å˜ãªæ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚å˜ã«"
" ``BaseClassName.methodname(self, arguments)`` "
"ã‚’å‘¼ã³å‡ºã™ã ã‘ã§ã™ã€‚ã“ã®ä»•æ§˜ã¯ã€å ´åˆã«ã‚ˆã£ã¦ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã‚‚å½¹ã«ç«‹ã¡ã¾ã™ã€‚ (ã“ã®å‘¼ã³å‡ºã—æ–¹ãŒå‹•ä½œã™ã‚‹ã®ã¯ã€åŸºåº•ã‚¯ãƒ©ã‚¹ãŒã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã® "
"``BaseClassName`` ã¨ã„ã†åå‰ã§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã¨ãã ã‘ã§ã™ã€‚)"

#: ../../tutorial/classes.rst:608
msgid "Python has two built-in functions that work with inheritance:"
msgstr "Python ã«ã¯ç¶™æ‰¿ã«é–¢ä¿‚ã™ã‚‹ 2 ã¤ã®çµ„ã¿è¾¼ã¿é–¢æ•°ãŒã‚ã‚Šã¾ã™:"

#: ../../tutorial/classes.rst:610
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)``"
" will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
":func:`isinstance` ã‚’ä½¿ã†ã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å‹ãŒèª¿ã¹ã‚‰ã‚Œã¾ã™ã€‚ ``isinstance(obj, int)`` ã¯ "
"``obj.__class__`` ãŒ :class:`int` ã‚„ :class:`int` ã®æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã®å ´åˆã«é™ã‚Š ``True`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/classes.rst:614
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)``"
" is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
":func:`issubclass` ã‚’ä½¿ã†ã¨ã‚¯ãƒ©ã‚¹ã®ç¶™æ‰¿é–¢ä¿‚ãŒèª¿ã¹ã‚‰ã‚Œã¾ã™ã€‚ :class:`bool` ã¯ :class:`int` "
"ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãªã®ã§ ``issubclass(bool, int)`` ã¯ ``True`` ã§ã™ã€‚ã—ã‹ã—ã€ :class:`float` ã¯ "
":class:`int` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã¯ãªã„ã®ã§ ``issubclass(float, int)`` ã¯ ``False`` ã§ã™ã€‚"

#: ../../tutorial/classes.rst:624
msgid "Multiple Inheritance"
msgstr "å¤šé‡ç¶™æ‰¿"

#: ../../tutorial/classes.rst:626
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"Python ã§ã¯ã€å¤šé‡ç¶™æ‰¿ (multiple inheritance) "
"ã®å½¢å¼ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚è¤‡æ•°ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’ã‚‚ã¤ã‚¯ãƒ©ã‚¹å®šç¾©ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../tutorial/classes.rst:636
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`DerivedClassName`, "
"it is searched for in :class:`Base1`, then (recursively) in the base classes"
" of :class:`Base1`, and if it was not found there, it was searched for in "
":class:`Base2`, and so on."
msgstr ""
"ã»ã¨ã‚“ã©ã®ã‚·ãƒ³ãƒ—ãƒ«ãªå¤šé‡ç¶™æ‰¿ã«ãŠã„ã¦ã€è¦ªã‚¯ãƒ©ã‚¹ã‹ã‚‰ç¶™æ‰¿ã•ã‚Œã‚‹å±æ€§ã®æ¤œç´¢ã¯ã€æ·±ã•å„ªå…ˆã§ã€å·¦ã‹ã‚‰å³ã«ã€ãã—ã¦ç¶™æ‰¿ã®éšå±¤ã®ä¸­ã§åŒã˜ã‚¯ãƒ©ã‚¹ãŒè¤‡æ•°å‡ºã¦ãã‚‹ï¼ˆè¨³æ³¨:"
" ãƒ€ã‚¤ã‚¢ãƒ¢ãƒ³ãƒ‰ç¶™æ‰¿ã¨å‘¼ã°ã‚Œã¾ã™ï¼‰å ´åˆã«ï¼’åº¦æ¢ç´¢ã‚’ã—ãªã„ã€ã¨è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãªã®ã§ã€ :class:`DerivedClassName` "
"ã«ã‚ã‚‹å±æ€§ãŒå­˜åœ¨ã—ãªã„å ´åˆã€ã¾ãš :class:`Base1` ã‹ã‚‰æ¤œç´¢ã•ã‚Œã€ãã—ã¦ï¼ˆå†å¸°çš„ã«ï¼‰ :class:`Base1` "
"ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã‹ã‚‰æ¤œç´¢ã•ã‚Œã€ãã‚Œã§ã‚‚è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã¯ :class:`Base2` ã‹ã‚‰æ¤œç´¢ã•ã‚Œã‚‹ã€ã¨ã„ã£ãŸå…·åˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/classes.rst:643
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"å®Ÿéš›ã«ã¯ã€ãã‚Œã‚ˆã‚Šã‚‚ã†å°‘ã—ã ã‘è¤‡é›‘ã§ã™ã€‚å”èª¿çš„ãª :func:`super` "
"ã®å‘¼ã³å‡ºã—ã®ãŸã‚ã«ãƒ¡ã‚½ãƒƒãƒ‰ã®è§£æ±ºé †åºã¯å‹•çš„ã«å¤‰æ›´ã•ã‚Œã¾ã™ã€‚ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ä»–ã®å¤šé‡ç¶™æ‰¿ã®ã‚ã‚‹è¨€èªã§ call-next-method "
"ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ãŠã‚Šã€å˜ä¸€ç¶™æ‰¿ã—ã‹ãªã„è¨€èªã® super å‘¼ã³å‡ºã—ã‚ˆã‚Šã‚‚å¼·åŠ›ã§ã™ã€‚"

#: ../../tutorial/classes.rst:649
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see "
"https://www.python.org/download/releases/2.3/mro/."
msgstr ""
"å¤šé‡ç¶™æ‰¿ã®å…¨ã¦ã®å ´åˆã« 1 ã¤ã‹ãã‚Œä»¥ä¸Šã®ãƒ€ã‚¤ãƒ¤ãƒ¢ãƒ³ãƒ‰ç¶™æ‰¿ (å°‘ãªãã¨ã‚‚ 1 ã¤ã®ç¥–å…ˆã‚¯ãƒ©ã‚¹ã«å¯¾ã—æœ€ã‚‚ä¸‹ã®ã‚¯ãƒ©ã‚¹ã‹ã‚‰åˆ°é”ã™ã‚‹çµŒè·¯ãŒè¤‡æ•°ã‚ã‚‹çŠ¶æ…‹) "
"ãŒã‚ã‚‹ã®ã§ã€å‹•çš„é †åºä»˜ã‘ãŒå¿…è¦ã§ã™ã€‚ä¾‹ãˆã°ã€å…¨ã¦ã®æ–°å½¢å¼ã®ã‚¯ãƒ©ã‚¹ã¯ :class:`object` ã‚’ç¶™æ‰¿ã—ã¦ã„ã‚‹ã®ã§ã€ã©ã®å¤šé‡ç¶™æ‰¿ã§ã‚‚ "
":class:`object` "
"ã¸åˆ°é”ã™ã‚‹ãŸã‚ã®é“ã¯è¤‡æ•°å­˜åœ¨ã—ã¾ã™ã€‚åŸºåº•ã‚¯ãƒ©ã‚¹ãŒè¤‡æ•°å›ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€å‹•çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§æ¤œç´¢é †åºã‚’ç›´åˆ—åŒ–ã—ã€å„ã‚¯ãƒ©ã‚¹ã§æŒ‡å®šã•ã‚Œã¦ã„ã‚‹ç¥–å…ˆã‚¯ãƒ©ã‚¹ã©ã†ã—ã®å·¦ã‹ã‚‰å³ã¸ã®é †åºã¯å´©ã•ãšã€å„ç¥–å…ˆã‚¯ãƒ©ã‚¹ã‚’ä¸€åº¦ã ã‘å‘¼ã³å‡ºã—ã€ã‹ã¤ä¸€æ§˜ã«ãªã‚‹"
" (ã¤ã¾ã‚Šç¥–å…ˆã‚¯ãƒ©ã‚¹ã®é †åºã«å½±éŸ¿ã‚’ä¸ãˆãšã«ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã§ãã‚‹) "
"ã‚ˆã†ã«ã—ã¾ã™ã€‚ã¾ã¨ã‚ã‚‹ã¨ã€ã“ã‚Œã‚‰ã®ç‰¹å¾´ã®ãŠã‹ã’ã§ä¿¡é ¼æ€§ã¨æ‹¡å¼µæ€§ã®ã‚ã‚‹å¤šé‡ç¶™æ‰¿ã—ãŸã‚¯ãƒ©ã‚¹ã‚’è¨­è¨ˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã™ã€‚ã•ã‚‰ã«è©³ç´°ã‚’çŸ¥ã‚ŠãŸã‘ã‚Œã°ã€ "
"https://www.python.org/download/releases/2.3/mro/ ã‚’è¦‹ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/classes.rst:666
msgid "Private Variables"
msgstr "ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆå¤‰æ•°"

#: ../../tutorial/classes.rst:668
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an"
" object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸­ã‹ã‚‰ã—ã‹ã‚¢ã‚¯ã‚»ã‚¹å‡ºæ¥ãªã„ \"ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ\" ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã¯ã€ Python ã«ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ã»ã¨ã‚“ã©ã® Python "
"ã‚³ãƒ¼ãƒ‰ãŒå¾“ã£ã¦ã„ã‚‹æ…£ç¿’ãŒã‚ã‚Šã¾ã™ã€‚ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã§å§‹ã¾ã‚‹åå‰ (ä¾‹ãˆã° ``_spam``) ã¯ã€ (é–¢æ•°ã§ã‚ã‚Œãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚ã‚Œãƒ‡ãƒ¼ã‚¿ãƒ¡ãƒ³ãƒã§ã‚ã‚Œ) é "
"public ãªAPIã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã¯ã€äºˆå‘Šãªãå¤‰æ›´ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„å®Ÿè£…ã®è©³ç´°ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ã¹ãã§ã™ã€‚"

#: ../../tutorial/classes.rst:675
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) stripped."
"  This mangling is done without regard to the syntactic position of the "
"identifier, as long as it occurs within the definition of a class."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã®ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ãƒ³ãƒã«ã¤ã„ã¦é©åˆ‡ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹(ç‰¹ã«ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®šç¾©ã•ã‚ŒãŸåå‰ã¨ã®è¡çªã‚’é¿ã‘ã‚‹å ´åˆ)ãŒã‚ã‚‹ã®ã§ã€åå‰ãƒãƒ³ã‚°ãƒªãƒ³ã‚° "
"(:dfn:`name mangling`) ã¨å‘¼ã°ã‚Œã‚‹ã€é™å®šã•ã‚ŒãŸã‚µãƒãƒ¼ãƒˆæ©Ÿæ§‹ãŒã‚ã‚Šã¾ã™ã€‚ ``__spam`` "
"(å…ˆé ­ã«äºŒå€‹ä»¥ä¸Šã®ä¸‹ç·šæ–‡å­—ã€æœ«å°¾ã«ä¸€å€‹ä»¥ä¸‹ã®ä¸‹ç·šæ–‡å­—) ã¨ã„ã†å½¢å¼ã®è­˜åˆ¥å­ã¯ã€ ``_classname__spam`` "
"ã¸ã¨ãƒ†ã‚­ã‚¹ãƒˆç½®æ›ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ã“ã“ã§ ``classname`` "
"ã¯ã€ç¾åœ¨ã®ã‚¯ãƒ©ã‚¹åã‹ã‚‰å…ˆé ­ã®ä¸‹ç·šæ–‡å­—ã‚’ã¯ãã¨ã£ãŸåå‰ã«ãªã‚Šã¾ã™ã€‚ã“ã®ã‚ˆã†ãªé›£å·åŒ– (mangle) "
"ã¯ã€è­˜åˆ¥å­ã®æ–‡æ³•çš„ãªä½ç½®ã«ã‹ã‹ã‚ã‚‰ãšè¡Œã‚ã‚Œã‚‹ã®ã§ã€ã‚¯ãƒ©ã‚¹å®šç¾©å†…ã«ç¾ã‚ŒãŸè­˜åˆ¥å­å…¨ã¦ã«å¯¾ã—ã¦å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../tutorial/classes.rst:684
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr "åå‰ãƒãƒ³ã‚°ãƒªãƒ³ã‚°ã¯ã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒå†…éƒ¨ã®ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—ã‚’å£Šã•ãšã«ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã®ã«ä¾¿åˆ©ã§ã™ã€‚ä¾‹ãˆã°::"

#: ../../tutorial/classes.rst:706
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered private."
"  This can even be useful in special circumstances, such as in the debugger."
msgstr ""
"é›£å·åŒ–ã®è¦å‰‡ã¯ä¸»ã«ä¸æ…®ã®äº‹æ•…ã‚’é˜²ããŸã‚ã®ã‚‚ã®ã ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„; "
"ç¢ºä¿¡çŠ¯çš„ãªæ–¹æ³•ã§ã€ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã¨ã•ã‚Œã¦ã„ã‚‹å¤‰æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã‚Šå¤‰æ›´ã™ã‚‹ã“ã¨ã¯ä¾ç„¶ã¨ã—ã¦å¯èƒ½ãªã®ã§ã™ã€‚ãƒ‡ãƒãƒƒã‚¬ã®ã‚ˆã†ãªç‰¹æ®ŠãªçŠ¶æ³ã§ã¯ã€ã“ã®ä»•æ§˜ã¯ä¾¿åˆ©ã§ã™ã‚‰ã‚ã‚Šã¾ã™ã€‚"

#: ../../tutorial/classes.rst:710
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"``exec()`` ã‚„ ``eval()`` ã¸æ¸¡ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã§ã¯ã€å‘¼å‡ºã—å…ƒã®ã‚¯ãƒ©ã‚¹åã‚’ç¾åœ¨ã®ã‚¯ãƒ©ã‚¹ã¨è¦‹ãªã•ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã®ä»•æ§˜ã¯ "
"``global`` æ–‡ã®åŠ¹æœã¨ä¼¼ã¦ãŠã‚Šã€ãã®åŠ¹æœã‚‚ã¾ãŸåŒæ§˜ã«ã€ãƒã‚¤ãƒˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã«åˆ¶é™ã•ã‚Œã¦ã„ã¾ã™ã€‚åŒã˜åˆ¶ç´„ãŒ ``getattr()`` "
"ã¨ ``setattr()`` ã¨ ``delattr()`` ã«ã‚‚é©ç”¨ã•ã‚Œã¾ã™ã€‚ã¾ãŸã€``__dict__`` ã‚’ç›´æ¥å‚ç…§ã™ã‚‹ã¨ãã«ã‚‚é©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../tutorial/classes.rst:721
msgid "Odds and Ends"
msgstr "æ®‹ã‚Šã®ã¯ã—ã°ã—"

#: ../../tutorial/classes.rst:723
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items.  An empty class "
"definition will do nicely::"
msgstr ""
"Pascal ã® \"ãƒ¬ã‚³ãƒ¼ãƒ‰ (record)\" ã‚„ã€C è¨€èªã® \"æ§‹é€ ä½“ (struct)\" "
"ã®ã‚ˆã†ãªã€åå‰ã¤ãã®ãƒ‡ãƒ¼ã‚¿è¦ç´ ã‚’ä¸€ã¾ã¨ã‚ã«ã™ã‚‹ãƒ‡ãƒ¼ã‚¿å‹ãŒã‚ã‚‹ã¨ä¾¿åˆ©ãªã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ç©ºã®ã‚¯ãƒ©ã‚¹å®šç¾©ã‚’ä½¿ã†ã¨ã†ã¾ãã§ãã¾ã™::"

#: ../../tutorial/classes.rst:737
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type instead."
"  For instance, if you have a function that formats some data from a file "
"object, you can define a class with methods :meth:`read` and "
":meth:`!readline` that get the data from a string buffer instead, and pass "
"it as an argument."
msgstr ""
"ã‚ã‚‹ç‰¹å®šã®æŠ½è±¡ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¦æ±‚ã™ã‚‹ Python "
"ã‚³ãƒ¼ãƒ‰ã®æ–­ç‰‡ã«ã€ãã®ãƒ‡ãƒ¼ã‚¿å‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹ã‚¯ãƒ©ã‚¹ã‚’ä»£ã‚ã‚Šã«æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ä½•ã‚‰ã‹ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰ã™ã‚‹é–¢æ•°ãŒã‚ã‚‹å ´åˆã€"
" :meth:`read` ã¨ :meth:`!readline` "
"ã‚’æŒã¤ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã¦ã€ãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ãªãæ–‡å­—åˆ—ãƒãƒƒãƒ•ã‚¡ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹ã‚ˆã†ã«ã—ã¦ãŠãã€å¼•æ•°ã¨ã—ã¦æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../tutorial/classes.rst:748
msgid ""
"Instance method objects have attributes, too: ``m.__self__`` is the instance"
" object with the method :meth:`m`, and ``m.__func__`` is the function object"
" corresponding to the method."
msgstr ""
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚‚å±æ€§ãŒã‚ã‚Šã¾ã™ã€‚ ``m.__self__`` ã¯ãƒ¡ã‚½ãƒƒãƒ‰ :meth:`m` "
"ã®å±ã—ã¦ã„ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ ``m.__func__`` ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã«å¯¾å¿œã™ã‚‹é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../tutorial/classes.rst:756
msgid "Iterators"
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ (iterator)"

#: ../../tutorial/classes.rst:758
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"ã™ã§ã«æ°—ã¥ã„ã¦ã„ã‚‹ã§ã—ã‚‡ã†ãŒã€ :keyword:`for` æ–‡ã‚’ä½¿ã†ã¨ã»ã¨ã‚“ã©ã®ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ãŸã£ã¦ãƒ«ãƒ¼ãƒ—ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/classes.rst:772
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the "
":keyword:`for` statement calls :func:`iter` on the container object.  The "
"function returns an iterator object that defines the method "
":meth:`~iterator.__next__` which accesses elements in the container one at a"
" time.  When there are no more elements, :meth:`~iterator.__next__` raises a"
" :exc:`StopIteration` exception which tells the :keyword:`for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the "
":func:`next` built-in function; this example shows how it all works::"
msgstr ""
"ã“ã†ã„ã†è¦ç´ ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ–¹æ³•ã¯æ˜ç¢ºã§ç°¡æ½”ã§ä½¿ã„æ˜“ã„ã‚‚ã®ã§ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®æ´»ç”¨ã¯ Python ã¸åºƒãè¡Œãæ¸¡ã‚Šã€çµ±ä¸€æ„Ÿã‚’æŒãŸã›ã¦ã„ã¾ã™ã€‚è£ã§ã¯ "
":keyword:`for` æ–‡ã¯ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ :func:`iter` "
"é–¢æ•°ã‚’å‘¼ã‚“ã§ã„ã¾ã™ã€‚é–¢æ•°ã¯ã€ã‚³ãƒ³ãƒ†ãƒŠã®ä¸­ã®è¦ç´ ã«1ã¤ãšã¤ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ :meth:`~iterator.__next__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œä»¥ä¸Šè¦ç´ ãŒç„¡ã„å ´åˆã¯ã€ :meth:`~iterator.__next__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ "
":exc:`StopIteration` ä¾‹å¤–ã‚’é€å‡ºã—ã€ãã®é€šçŸ¥ã‚’å—ã‘ :keyword:`for` ãƒ«ãƒ¼ãƒ—ã¯çµ‚äº†ã—ã¾ã™ã€‚çµ„ã¿è¾¼ã¿ã® "
":func:`next` é–¢æ•°ã‚’ä½¿ã£ã¦ :meth:`~iterator.__next__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç›´æ¥å‘¼ã¶ã“ã¨ã‚‚ã§ãã¾ã™; "
"ã“ã®ä¾‹ã¯é–¢æ•°ãŒã©ã†åƒãã®ã‹ã‚’ç¤ºã—ã¦ã„ã¾ã™::"

#: ../../tutorial/classes.rst:797
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`__iter__` method which "
"returns an object with a :meth:`~iterator.__next__` method.  If the class "
"defines :meth:`__next__`, then :meth:`__iter__` can just return ``self``::"
msgstr ""
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®è£ã«ã‚ã‚‹ä»•çµ„ã¿ã‚’è¦³å¯Ÿã—ã¦ã„ã‚Œã°ã€è‡ªä½œã®ã‚¯ãƒ©ã‚¹ã«ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦ã®æŒ¯èˆã„ã‚’è¿½åŠ ã™ã‚‹ã®ã¯ç°¡å˜ã§ã™ã€‚ "
":meth:`~iterator.__next__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ :meth:`__iter__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã™ã‚‹ã®ã§ã™ã€‚ã‚¯ãƒ©ã‚¹ãŒ :meth:`__next__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã‚‹å ´åˆã€ :meth:`__iter__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å˜ã« "
"``self`` ã‚’è¿”ã™ã“ã¨ã‚‚å¯èƒ½ã§ã™::"

#: ../../tutorial/classes.rst:834
msgid "Generators"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ (generator)"

#: ../../tutorial/classes.rst:836
msgid ""
":term:`Generator`\\s are a simple and powerful tool for creating iterators."
"  They are written like regular functions but use the :keyword:`yield` "
"statement whenever they want to return data.  Each time :func:`next` is "
"called on it, the generator resumes where it left off (it remembers all the "
"data values and which statement was last executed).  An example shows that "
"generators can be trivially easy to create::"
msgstr ""
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿(:term:`generator`)ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã™ã‚‹ãŸã‚ã®ç°¡æ½”ã§å¼·åŠ›ãªãƒ„ãƒ¼ãƒ«ã§ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯é€šå¸¸ã®é–¢æ•°ã®ã‚ˆã†ã«æ›¸ã‹ã‚Œã¾ã™ãŒã€ä½•ã‚‰ã‹ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™ã¨ãã«ã¯"
" :keyword:`yield` æ–‡ã‚’ä½¿ã„ã¾ã™ã€‚ãã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã«å¯¾ã—ã¦ :func:`next` "
"ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ãŸã³ã«ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯ä»¥å‰ã«ä¸­æ–­ã—ãŸå‡¦ç†ã‚’å†é–‹ã—ã¾ã™ "
"(ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯ã€å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿å€¤ã¨æœ€å¾Œã«ã©ã®æ–‡ãŒå®Ÿè¡Œã•ã‚ŒãŸã‹ã‚’è¨˜æ†¶ã—ã¦ã„ã¾ã™)ã€‚ä»¥ä¸‹ã®ä¾‹ã‚’è¦‹ã‚Œã°ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒã¨ã¦ã‚‚ç°¡å˜ã«ä½œæˆã§ãã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™::"

#: ../../tutorial/classes.rst:857
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`__iter__` and :meth:`~generator.__next__` methods"
" are created automatically."
msgstr ""
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã§ã§ãã‚‹ã“ã¨ã¯ã€å‰ã®ç¯€ã§è§£èª¬ã—ãŸã‚¯ãƒ©ã‚¹ã‚’ä½¿ã£ãŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã§ã‚‚å®Ÿç¾ã§ãã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®å®šç¾©ãŒã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã«ãªã‚‹ã®ã¯ "
":meth:`__iter__` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ :meth:`~generator.__next__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒè‡ªå‹•ã§ä½œæˆã•ã‚Œã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../tutorial/classes.rst:862
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like "
"``self.index`` and ``self.data``."
msgstr ""
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®ã‚‚ã†ä¸€ã¤ã®é‡è¦ãªæ©Ÿèƒ½ã¯ã€å‘¼ã³å‡ºã—ã”ã¨ã«ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã¨å®Ÿè¡ŒçŠ¶æ…‹ãŒè‡ªå‹•çš„ã«ä¿å­˜ã•ã‚Œã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ ``self.index``"
" ã‚„ ``self.data`` ã¨ã„ã£ãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‚’ä½¿ã£ãŸã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚ˆã‚Šã‚‚ç°¡å˜ã«é–¢æ•°ã‚’æ›¸ãã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/classes.rst:867
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è‡ªå‹•ç”Ÿæˆã—ãŸã‚Šãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡ŒçŠ¶æ…‹ã‚’è‡ªå‹•ä¿å­˜ã™ã‚‹ã»ã‹ã«ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯çµ‚äº†æ™‚ã«è‡ªå‹•çš„ã« :exc:`StopIteration` "
"ã‚’é€å‡ºã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®æ©Ÿèƒ½ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã¨ã€é€šå¸¸ã®é–¢æ•°ã‚’æ›¸ãã®ã¨åŒã˜åŠ´åŠ›ã§ã€ç°¡å˜ã«ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ç”Ÿæˆã§ãã¾ã™ã€‚"

#: ../../tutorial/classes.rst:876
msgid "Generator Expressions"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼"

#: ../../tutorial/classes.rst:878
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax"
" similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more"
" compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"å˜ç´”ãªã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãªã‚‰å¼ã¨ã—ã¦ç°¡æ½”ã«ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ãã¾ã™ã€‚\n"
"ãã®å¼ã¯ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã«ä¼¼ãŸæ§‹æ–‡ã‚’ä½¿ã„ã¾ã™ãŒã€è§’æ‹¬å¼§ã§ã¯ãªãä¸¸æ‹¬å¼§ã§å›²ã„ã¾ã™ã€‚\n"
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã¯ã€é–¢æ•°ã®ä¸­ã§ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚’ã™ãã«ä½¿ã„ãŸã„ã‚ˆã†ãªçŠ¶æ³ã®ãŸã‚ã«ç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚\n"
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã¯å®Œå…¨ãªã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®å®šç¾©ã‚ˆã‚Šã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã§ã™ãŒã€ã¡ã‚‡ã£ã¨èé€šã®åŠ¹ã‹ãªã„ã¨ã“ã‚ãŒã‚ã‚Šã¾ã™ã€‚\n"
"åŒã˜å†…å®¹ã‚’è¿”ã™ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã‚ˆã‚Šã¯ãƒ¡ãƒ¢ãƒªã«å„ªã—ã„ã“ã¨ãŒå¤šã„ã¨ã„ã†åˆ©ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../tutorial/classes.rst:885
msgid "Examples::"
msgstr "ä¾‹::"

#: ../../tutorial/classes.rst:909
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../tutorial/classes.rst:910
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name :attr:`~object.__dict__` is an "
"attribute but not a global name. Obviously, using this violates the "
"abstraction of namespace implementation, and should be restricted to things "
"like post-mortem debuggers."
msgstr ""
"ä¾‹å¤–ãŒä¸€ã¤ã‚ã‚Šã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€ç§˜å¯†ã®èª­å–ã‚Šå°‚ç”¨ã®å±æ€§ :attr:`~object.__dict__` "
"ãŒã‚ã‚Šã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹è¾æ›¸ã‚’è¿”ã—ã¾ã™; :attr:`~object.__dict__` "
"ã¨ã„ã†åå‰ã¯å±æ€§ã§ã™ãŒã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®å±æ€§ã‚’åˆ©ç”¨ã™ã‚‹ã¨åå‰ç©ºé–“ã®å®Ÿè£…ã«å¯¾ã™ã‚‹æŠ½è±¡åŒ–ã‚’ä¾µã™ã“ã¨ã«ãªã‚‹ã®ã§ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ¤œæ­»ã™ã‚‹ãƒ‡ãƒãƒƒã‚¬ã®ã‚ˆã†ãªç”¨é€”ã«é™ã‚‹ã¹ãã§ã™ã€‚"
