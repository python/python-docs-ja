# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-26 13:08+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../tutorial/controlflow.rst:5
msgid "More Control Flow Tools"
msgstr "ãã®ä»–ã®åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ãƒ„ãƒ¼ãƒ«"

#: ../../tutorial/controlflow.rst:7
msgid ""
"Besides the :keyword:`while` statement just introduced, Python knows the "
"usual control flow statements known from other languages, with some twists."
msgstr ""
"å…ˆã»ã©ç´¹ä»‹ã—ãŸ :keyword:`while` æ–‡ã®ä»–ã«ã‚‚ã€ Python "
"ã¯ä»–ã®è¨€èªã§ãŠãªã˜ã¿ã®åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼æ–‡ã‚’å‚™ãˆã¦ã„ã¾ã™ãŒã€ã“ã‚Œã‚‰ã«ã¯å¤šå°‘ã²ã­ã‚Šã‚’åŠ ãˆã¦ã‚ã‚Šã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:14
msgid ":keyword:`if` Statements"
msgstr ":keyword:`if` æ–‡"

#: ../../tutorial/controlflow.rst:16
msgid ""
"Perhaps the most well-known statement type is the :keyword:`if` statement.  "
"For example::"
msgstr "ãŠãã‚‰ãæœ€ã‚‚ãŠãªã˜ã¿ã®æ–‡å‹ã¯ :keyword:`if` æ–‡ã§ã—ã‚‡ã†ã€‚ä¾‹ãˆã°::"

#: ../../tutorial/controlflow.rst:33
msgid ""
"There can be zero or more :keyword:`elif` parts, and the :keyword:`else` "
"part is optional.  The keyword ':keyword:`elif`' is short for 'else if', and"
" is useful to avoid excessive indentation.  An  :keyword:`if` ... "
":keyword:`elif` ... :keyword:`elif` ... sequence is a substitute for the "
"``switch`` or ``case`` statements found in other languages."
msgstr ""
"ã‚¼ãƒ­å€‹ä»¥ä¸Šã® :keyword:`elif` éƒ¨ã‚’ä½¿ã†ã“ã¨ãŒã§ãã€ :keyword:`else` éƒ¨ã‚’ä»˜ã‘ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ "
"':keyword:`elif`' ã¯ 'else if' ã‚’çŸ­ãã—ãŸã‚‚ã®ã§ã€éå‰°ãªã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’é¿ã‘ã‚‹ã®ã«å½¹ç«‹ã¡ã¾ã™ã€‚ä¸€é€£ã® :keyword:`if`"
" ... :keyword:`elif` ... :keyword:`elif` ...  ã¯ã€ä»–ã®è¨€èªã«ãŠã‘ã‚‹ ``switch`` æ–‡ã‚„ "
"``case`` æ–‡ã®ä»£ç”¨ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:43
msgid ":keyword:`for` Statements"
msgstr ":keyword:`for` æ–‡"

#: ../../tutorial/controlflow.rst:48
msgid ""
"The :keyword:`for` statement in Python differs a bit from what you may be "
"used to in C or Pascal.  Rather than always iterating over an arithmetic "
"progression of numbers (like in Pascal), or giving the user the ability to "
"define both the iteration step and halting condition (as C), Python's "
":keyword:`for` statement iterates over the items of any sequence (a list or "
"a string), in the order that they appear in the sequence.  For example (no "
"pun intended):"
msgstr ""
"Python ã® :keyword:`for` æ–‡ã¯ã€èª­è€…ãŒ C è¨€èªã‚„ Pascal è¨€èªã§ä½¿ã„ãªã‚Œã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ :keyword:`for` "
"æ–‡ã¨ã¯å°‘ã—é•ã„ã¾ã™ã€‚ (Pascal ã®ã‚ˆã†ã«) å¸¸ã«ç®—è¡“å‹ã®æ•°åˆ—ã«ã‚ãŸã‚‹åå¾©ã‚’è¡Œã£ãŸã‚Šã€ (C ã®ã‚ˆã†ã«) "
"ç¹°è¿”ã—ã‚¹ãƒ†ãƒƒãƒ—ã¨åœæ­¢æ¡ä»¶ã‚’ä¸¡æ–¹ã¨ã‚‚ãƒ¦ãƒ¼ã‚¶ãŒå®šç¾©ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã®ã¨ã¯é•ã„ã€Python ã® :keyword:`for` æ–‡ã¯ã€ä»»æ„ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ "
"(ãƒªã‚¹ãƒˆã¾ãŸã¯æ–‡å­—åˆ—) ã«ã‚ãŸã£ã¦åå¾©ã‚’è¡Œã„ã¾ã™ã€‚åå¾©ã®é †ç•ªã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ä¸­ã«è¦ç´ ãŒç¾ã‚Œã‚‹é †ç•ªã§ã™ã€‚ä¾‹ãˆã°:"

#: ../../tutorial/controlflow.rst:69
msgid ""
"If you need to modify the sequence you are iterating over while inside the "
"loop (for example to duplicate selected items), it is recommended that you "
"first make a copy.  Iterating over a sequence does not implicitly make a "
"copy.  The slice notation makes this especially convenient::"
msgstr ""
"ãƒ«ãƒ¼ãƒ—å†…éƒ¨ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ä¿®æ­£ã™ã‚‹å¿…è¦ãŒã‚ã‚Œã° "
"(ä¾‹ãˆã°é¸æŠã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’è¤‡è£½ã™ã‚‹ãŸã‚ã«)ã€æœ€åˆã«ã‚³ãƒ”ãƒ¼ã‚’ä½œã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«å¯¾ã™ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯æš—é»™ã«ã‚³ãƒ”ãƒ¼ã‚’ä½œã‚Šã¾ã›ã‚“ã€‚ã‚¹ãƒ©ã‚¤ã‚¹è¨˜æ³•ã¯ã“ã‚Œã‚’ç‰¹ã«ä¾¿åˆ©ã«ã—ã¾ã™::"

#: ../../tutorial/controlflow.rst:81
msgid ""
"With ``for w in words:``, the example would attempt to create an infinite "
"list, inserting ``defenestrate`` over and over again."
msgstr ""
"``for w in words:`` ã‚’ä½¿ã£ãŸå ´åˆã¯ã€ã“ã®ä¾‹ã¯ ``defenestrate`` "
"ã‚’ä½•åº¦ã‚‚ç¹°ã‚Šè¿”ã—æŒ¿å…¥ã™ã‚‹ã“ã¨ã§ã€ç„¡é™ãƒªã‚¹ãƒˆã‚’ä½œæˆã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:88
msgid "The :func:`range` Function"
msgstr ":func:`range` é–¢æ•°"

#: ../../tutorial/controlflow.rst:90
msgid ""
"If you do need to iterate over a sequence of numbers, the built-in function "
":func:`range` comes in handy.  It generates arithmetic progressions::"
msgstr "æ•°åˆ—ã«ã‚ãŸã£ã¦åå¾©ã‚’è¡Œã†å¿…è¦ãŒã‚ã‚‹å ´åˆã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`range`  ãŒä¾¿åˆ©ã§ã™ã€‚ã“ã®é–¢æ•°ã¯ç®—è¡“å‹ã®æ•°åˆ—ã‚’ç”Ÿæˆã—ã¾ã™::"

#: ../../tutorial/controlflow.rst:102
msgid ""
"The given end point is never part of the generated sequence; ``range(10)`` "
"generates 10 values, the legal indices for items of a sequence of length 10."
"  It is possible to let the range start at another number, or to specify a "
"different increment (even negative; sometimes this is called the 'step')::"
msgstr ""
"æŒ‡å®šã—ãŸçµ‚ç«¯å€¤ã¯ç”Ÿæˆã•ã‚Œã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ã¯å…¥ã‚Šã¾ã›ã‚“ã€‚``range(10)`` ã¯ 10 å€‹ã®å€¤ã‚’ç”Ÿæˆã—ã€é•·ã• 10 "
"ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ãŠã‘ã‚‹å„é …ç›®ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã¨ãªã‚Šã¾ã™ã€‚range ã‚’åˆ¥ã®æ•°ã‹ã‚‰é–‹å§‹ã—ãŸã‚Šã€ä»–ã®å¢—åŠ é‡ (è² ã§ã‚‚; å¢—åŠ é‡ã¯æ™‚ã« 'ã‚¹ãƒ†ãƒƒãƒ—(step)' "
"ã¨å‘¼ã°ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™) ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™::"

#: ../../tutorial/controlflow.rst:116
msgid ""
"To iterate over the indices of a sequence, you can combine :func:`range` and"
" :func:`len` as follows::"
msgstr ""
"ã‚ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ã‚ãŸã£ã¦ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã§åå¾©ã‚’è¡Œã†ã«ã¯ã€ :func:`range` ã¨ :func:`len` ã‚’æ¬¡ã®ã‚ˆã†ã«çµ„ã¿åˆã‚ã›ã‚‰ã‚Œã¾ã™::"

#: ../../tutorial/controlflow.rst:129
msgid ""
"In most such cases, however, it is convenient to use the :func:`enumerate` "
"function, see :ref:`tut-loopidioms`."
msgstr ""
"ã—ã‹ã—ã€å¤šãã®å ´åˆã¯ :func:`enumerate` é–¢æ•°ã‚’ä½¿ã†æ–¹ãŒä¾¿åˆ©ã§ã™ã€‚ :ref:`tut-loopidioms` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/controlflow.rst:132
msgid "A strange thing happens if you just print a range::"
msgstr "range ã‚’ç›´æ¥å‡ºåŠ›ã™ã‚‹ã¨å¤‰ãªã“ã¨ã«ãªã‚Šã¾ã™::"

#: ../../tutorial/controlflow.rst:137
msgid ""
"In many ways the object returned by :func:`range` behaves as if it is a "
"list, but in fact it isn't. It is an object which returns the successive "
"items of the desired sequence when you iterate over it, but it doesn't "
"really make the list, thus saving space."
msgstr ""
":func:`range` "
"ãŒè¿”ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã„ã‚ã„ã‚ãªç‚¹ã§ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã„ã¾ã™ãŒã€æœ¬å½“ã¯ãƒªã‚¹ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã—ãŸæ™‚ã«æœ›ã‚“ã æ•°åˆ—ã®é€£ç¶šã—ãŸè¦ç´ ã‚’è¿”ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã—ã‹ã—å®Ÿéš›ã«ãƒªã‚¹ãƒˆã‚’ä½œã‚‹ã‚ã‘ã§ã¯ãªã„ã®ã§ã€ã‚¹ãƒšãƒ¼ã‚¹ã®ç¯€ç´„ã«ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:142
msgid ""
"We say such an object is *iterable*, that is, suitable as a target for "
"functions and constructs that expect something from which they can obtain "
"successive items until the supply is exhausted. We have seen that the "
":keyword:`for` statement is such an *iterator*. The function :func:`list` is"
" another; it creates lists from iterables::"
msgstr ""
"ã“ã®ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ *ã‚¤ãƒ†ãƒ©ãƒ–ãƒ« (iterable)* "
"ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã¯é–¢æ•°ã‚„ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦ã€ã‚ã‚‹ã ã‘ã®é …ç›®ã‚’é€æ¬¡ä¸ãˆã‚‹ã®ã«é©ã—ã¦ã„ã¾ã™ã€‚ :keyword:`for` æ–‡ãŒãã®ã‚ˆã†ãª"
" *ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿* ã§ã‚ã‚‹ã“ã¨ã¯ã™ã§ã«è¦‹ã¦ãã¾ã—ãŸã€‚é–¢æ•° :func:`list` ã‚‚ã¾ãŸä¸€ã¤ã®ä¾‹ã§ã™ã€‚ã“ã‚Œã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‹ã‚‰ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆã—ã¾ã™::"

#: ../../tutorial/controlflow.rst:152
msgid ""
"Later we will see more functions that return iterables and take iterables as"
" argument."
msgstr "å¾Œã»ã©ã€ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’è¿”ã—ãŸã‚Šã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’å¼•æ•°ã¨ã—ã¦å–ã‚‹é–¢æ•°ã‚’ã‚‚ã£ã¨è¦‹ã¦ã„ãã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:158
msgid ""
":keyword:`break` and :keyword:`continue` Statements, and :keyword:`else` "
"Clauses on Loops"
msgstr ":keyword:`break` æ–‡ã¨ :keyword:`continue` æ–‡ã¨ãƒ«ãƒ¼ãƒ—ã® :keyword:`else` ç¯€"

#: ../../tutorial/controlflow.rst:160
msgid ""
"The :keyword:`break` statement, like in C, breaks out of the innermost "
"enclosing :keyword:`for` or :keyword:`while` loop."
msgstr ""
":keyword:`break` æ–‡ã¯ã€C è¨€èªã¨åŒã˜ãã€æœ€ã‚‚å†…å´ã® :keyword:`for` ã¾ãŸã¯ :keyword:`while` "
"ãƒ«ãƒ¼ãƒ—ã‚’ä¸­æ–­ã—ã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:163
msgid ""
"Loop statements may have an ``else`` clause; it is executed when the loop "
"terminates through exhaustion of the list (with :keyword:`for`) or when the "
"condition becomes false (with :keyword:`while`), but not when the loop is "
"terminated by a :keyword:`break` statement.  This is exemplified by the "
"following loop, which searches for prime numbers::"
msgstr ""
"ãƒ«ãƒ¼ãƒ—æ–‡ã¯ ``else`` ç¯€ã‚’æŒã¤ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€ (:keyword:`for` ã§) "
"åå¾©å‡¦ç†å¯¾è±¡ã®ãƒªã‚¹ãƒˆã‚’ä½¿ã„åˆ‡ã£ã¦ãƒ«ãƒ¼ãƒ—ãŒçµ‚äº†ã—ãŸã¨ãã€ã¾ãŸã¯ (:keyword:`while` ã§) æ¡ä»¶ãŒå½ã«ãªã£ãŸã¨ãã«å®Ÿè¡Œã•ã‚Œã¾ã™ãŒã€ "
":keyword:`break` æ–‡ã§ãƒ«ãƒ¼ãƒ—ãŒçµ‚äº†ã—ãŸã¨ãã¯å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã€‚ã“ã®å‹•ä½œã‚’ã€ç´ æ•°ã‚’æ¢ã™ä¸‹è¨˜ã®ãƒ«ãƒ¼ãƒ—ã‚’ä¾‹ã«ã¨ã£ã¦ç¤ºã—ã¾ã™::"

#: ../../tutorial/controlflow.rst:187
msgid ""
"(Yes, this is the correct code.  Look closely: the ``else`` clause belongs "
"to the :keyword:`for` loop, **not** the :keyword:`if` statement.)"
msgstr ""
"(ãã†ã€ã“ã‚Œã¯æ­£ã—ã„ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚ã‚ˆãè¦‹ã¦ãã ã•ã„: ``else`` ç¯€ã¯ :keyword:`if` æ–‡ **ã§ã¯ãªã** ã€ "
":keyword:`for` ãƒ«ãƒ¼ãƒ—ã«å±ã—ã¦ã„ã¾ã™ã€‚)"

#: ../../tutorial/controlflow.rst:190
msgid ""
"When used with a loop, the ``else`` clause has more in common with the "
"``else`` clause of a :keyword:`try` statement than it does that of "
":keyword:`if` statements: a :keyword:`try` statement's ``else`` clause runs "
"when no exception occurs, and a loop's ``else`` clause runs when no "
"``break`` occurs. For more on the :keyword:`try` statement and exceptions, "
"see :ref:`tut-handling`."
msgstr ""
"ãƒ«ãƒ¼ãƒ—ã® ``else`` å¥ã¯ã€ :keyword:`if` æ–‡ã® ``else`` ã‚ˆã‚Šã‚‚ :keyword:`try` æ–‡ã® ``else`` "
"ã«ä¼¼ã¦ã„ã¾ã™ã€‚ :keyword:`try` æ–‡ã® ``else`` å¥ã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ãªã‹ã£ãŸæ™‚ã«å®Ÿè¡Œã•ã‚Œã€ãƒ«ãƒ¼ãƒ—ã® ``else`` å¥ã¯ "
"``break`` ã•ã‚Œãªã‹ã£ãŸå ´åˆã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ :keyword:`try` æ–‡ã¨ä¾‹å¤–ã«ã¤ã„ã¦ã®è©³ç´°ã¯ :ref:`tut-handling` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/controlflow.rst:197
msgid ""
"The :keyword:`continue` statement, also borrowed from C, continues with the "
"next iteration of the loop::"
msgstr ":keyword:`continue` æ–‡ã‚‚ C è¨€èªã‹ã‚‰å€Ÿã‚Šã¦ããŸã‚‚ã®ã§ã€ãƒ«ãƒ¼ãƒ—ã®æ¬¡ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™::"

#: ../../tutorial/controlflow.rst:217
msgid ":keyword:`pass` Statements"
msgstr ":keyword:`pass` æ–‡"

#: ../../tutorial/controlflow.rst:219
msgid ""
"The :keyword:`pass` statement does nothing. It can be used when a statement "
"is required syntactically but the program requires no action. For example::"
msgstr ""
":keyword:`pass` æ–‡ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚ :keyword:`pass` "
"ã¯ã€æ–‡ã‚’æ›¸ãã“ã¨ãŒæ§‹æ–‡ä¸Šè¦æ±‚ã•ã‚Œã¦ã„ã‚‹ãŒã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸Šä½•ã®å‹•ä½œã‚‚ã™ã‚‹å¿…è¦ãŒãªã„æ™‚ã«ä½¿ã‚ã‚Œã¾ã™::"

#: ../../tutorial/controlflow.rst:226
msgid "This is commonly used for creating minimal classes::"
msgstr "ã“ã‚Œã¯æœ€å°ã®ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‹ã¨ãã«ã‚ˆãä½¿ã‚ã‚Œã‚‹æ–¹æ³•ã§ã™::"

#: ../../tutorial/controlflow.rst:232
msgid ""
"Another place :keyword:`pass` can be used is as a place-holder for a "
"function or conditional body when you are working on new code, allowing you "
"to keep thinking at a more abstract level.  The :keyword:`pass` is silently "
"ignored::"
msgstr ""
":keyword:`pass` "
"ãŒä½¿ã‚ã‚Œã‚‹ã‚‚ã†1ã¤ã®å ´æ‰€ã¯ã€æ–°ã—ã„ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ã„ã‚‹æ™‚ã®é–¢æ•°ã‚„æ¡ä»¶æ–‡ã®ä¸­èº«ã§ã™ã€‚ã“ã†ã™ã‚‹ã“ã¨ã§ã€å…·ä½“çš„ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã‹ãªã„ã§æŠ½è±¡çš„ãªãƒ¬ãƒ™ãƒ«ã§è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"
" :keyword:`pass` ã¯ä½•ã‚‚ã™ã‚‹ã“ã¨ãªãç„¡è¦–ã•ã‚Œã¾ã™::"

#: ../../tutorial/controlflow.rst:243
msgid "Defining Functions"
msgstr "é–¢æ•°ã‚’å®šç¾©ã™ã‚‹"

#: ../../tutorial/controlflow.rst:245
msgid ""
"We can create a function that writes the Fibonacci series to an arbitrary "
"boundary::"
msgstr "ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ— (Fibonacci series) ã‚’ä»»æ„ã®ä¸Šé™å€¤ã¾ã§æ›¸ãå‡ºã™ã‚ˆã†ãªé–¢æ•°ã‚’ä½œæˆã§ãã¾ã™::"

#: ../../tutorial/controlflow.rst:265
msgid ""
"The keyword :keyword:`def` introduces a function *definition*.  It must be "
"followed by the function name and the parenthesized list of formal "
"parameters. The statements that form the body of the function start at the "
"next line, and must be indented."
msgstr ""
":keyword:`def` ã¯é–¢æ•°ã® *å®šç¾© (definition)* ã‚’å°ãã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§ã™ã€‚ :keyword:`def` "
"ã®å¾Œã«ã¯ã€é–¢æ•°åã¨ä»®å¼•æ•°ã‚’ä¸¸æ‹¬å¼§ã§å›²ã‚“ã ãƒªã‚¹ãƒˆã‚’ç¶šã‘ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚é–¢æ•°ã®å®Ÿä½“ã‚’æ§‹æˆã™ã‚‹å®Ÿè¡Œæ–‡ã¯æ¬¡ã®è¡Œã‹ã‚‰å§‹ã‚ã€ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../tutorial/controlflow.rst:270
msgid ""
"The first statement of the function body can optionally be a string literal;"
" this string literal is the function's documentation string, or "
":dfn:`docstring`. (More about docstrings can be found in the section :ref"
":`tut-docstrings`.) There are tools which use docstrings to automatically "
"produce online or printed documentation, or to let the user interactively "
"browse through code; it's good practice to include docstrings in code that "
"you write, so make a habit of it."
msgstr ""
"é–¢æ•°ã®æœ¬ä½“ã®è¨˜è¿°ã™ã‚‹æ–‡ã®æœ€åˆã®è¡Œã¯æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ãã®å ´åˆã€ã“ã®æ–‡å­—åˆ—ã¯é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ— "
"(documentation string)ã€ã¾ãŸã¯ :dfn:`docstring` ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ (docstring ã«ã¤ã„ã¦ã¯ :ref"
":`tut-docstrings` ã§ã•ã‚‰ã«æ‰±ã£ã¦ã„ã¾ã™ã€‚) "
"ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã‚’ä½¿ã£ãŸãƒ„ãƒ¼ãƒ«ã«ã¯ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ–‡æ›¸ã‚„å°åˆ·æ–‡æ›¸ã‚’è‡ªå‹•çš„ã«ç”Ÿæˆã—ãŸã‚Šã€ãƒ¦ãƒ¼ã‚¶ãŒå¯¾è©±çš„ã«ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ç›´æ¥é–²è¦§ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚è‡ªåˆ†ãŒæ›¸ãã‚³ãƒ¼ãƒ‰ã«ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã‚’å…¥ã‚Œã‚‹ã®ã¯ã‚ˆã„ç¿’æ…£ã§ã™ã€‚æ›¸ãç™–ã‚’ã¤ã‘ã¦ãã ã•ã„ã€‚"

#: ../../tutorial/controlflow.rst:277
msgid ""
"The *execution* of a function introduces a new symbol table used for the "
"local variables of the function.  More precisely, all variable assignments "
"in a function store the value in the local symbol table; whereas variable "
"references first look in the local symbol table, then in the local symbol "
"tables of enclosing functions, then in the global symbol table, and finally "
"in the table of built-in names. Thus, global variables cannot be directly "
"assigned a value within a function (unless named in a :keyword:`global` "
"statement), although they may be referenced."
msgstr ""
"é–¢æ•°ã‚’ *å®Ÿè¡Œ (execution)* ã™ã‚‹ã¨ãã€é–¢æ•°ã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹æ–°ãŸãªã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ« (symbol table) "
"ãŒç”¨æ„ã•ã‚Œã¾ã™ã€‚ã‚‚ã£ã¨æ­£ç¢ºã«ã„ã†ã¨ã€é–¢æ•°å†…ã§å¤‰æ•°ã¸ã®ä»£å…¥ã‚’è¡Œã†ã¨ã€ãã®å€¤ã¯ã™ã¹ã¦ã“ã®ãƒ­ãƒ¼ã‚«ãƒ«ãªã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¨˜æ†¶ã•ã‚Œã¾ã™ã€‚ä¸€æ–¹ã€å¤‰æ•°ã®å‚ç…§ã‚’è¡Œã†ã¨ã€ã¾ãšãƒ­ãƒ¼ã‚«ãƒ«ãªã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ãŒæ¤œç´¢ã•ã‚Œã€æ¬¡ã«ã•ã‚‰ã«å¤–å´ã®é–¢æ•°ã®ãƒ­ãƒ¼ã‚«ãƒ«ãªã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ¤œç´¢ã—ã€ãã®å¾Œã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’èª¿ã¹ã€æœ€å¾Œã«çµ„ã¿è¾¼ã¿ã®åå‰ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’èª¿ã¹ã¾ã™ã€‚å¾“ã£ã¦ã€é–¢æ•°ã®ä¸­ã§ã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªå¤‰æ•°ã‚’å‚ç…§ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã™ãŒã€ç›´æ¥å€¤ã‚’ä»£å…¥ã™ã‚‹ã“ã¨ã¯"
" (:keyword:`global` æ–‡ã§åå‰ã‚’æŒ™ã’ã¦ãŠã‹ãªã„é™ã‚Š)ã§ãã¾ã›ã‚“ã€‚"

#: ../../tutorial/controlflow.rst:286
msgid ""
"The actual parameters (arguments) to a function call are introduced in the "
"local symbol table of the called function when it is called; thus, arguments"
" are passed using *call by value* (where the *value* is always an object "
"*reference*, not the value of the object). [#]_ When a function calls "
"another function, a new local symbol table is created for that call."
msgstr ""
"é–¢æ•°ã‚’å‘¼ã³å‡ºã™éš›ã®å®Ÿéš›ã®å¼•æ•° (å®Ÿå¼•æ•°) ã¯ã€é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ãã«é–¢æ•°ã®ãƒ­ãƒ¼ã‚«ãƒ«ãªã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«å†…ã«å–ã‚Šè¾¼ã¾ã‚Œã¾ã™ã€‚ãã†ã™ã‚‹ã“ã¨ã§ã€å¼•æ•°ã¯ "
"*å€¤æ¸¡ã— (call by value)* ã§é–¢æ•°ã«æ¸¡ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ (ã“ã“ã§ã® *å€¤ (value)* ã¨ã¯å¸¸ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã® "
"*å‚ç…§(reference)* ã‚’ã„ã„ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ãã®ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“) "
"[#]_ã€‚ã‚ã‚‹é–¢æ•°ãŒã»ã‹ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã¨ãã«ã¯ã€æ–°ãŸãªå‘¼ã³å‡ºã—ã®ãŸã‚ã«ãƒ­ãƒ¼ã‚«ãƒ«ãªã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ãŒæ–°ãŸã«ä½œæˆã•ã‚Œã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:292
msgid ""
"A function definition introduces the function name in the current symbol "
"table. The value of the function name has a type that is recognized by the "
"interpreter as a user-defined function.  This value can be assigned to "
"another name which can then also be used as a function.  This serves as a "
"general renaming mechanism::"
msgstr ""
"é–¢æ•°ã®å®šç¾©ã‚’è¡Œã†ã¨ã€é–¢æ•°åã¯ç¾åœ¨ã®ã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«å†…ã«å–ã‚Šå…¥ã‚Œã‚‰ã‚Œã¾ã™ã€‚é–¢æ•°åã®å€¤ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‹ã‚‰ã¯ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•° (user-defined "
"function) "
"ã¨ã—ã¦èªè­˜ã•ã‚Œã‚‹å‹ã‚’æŒã¡ã¾ã™ã€‚ã“ã®å€¤ã¯åˆ¥ã®åå‰ã«ä»£å…¥ã—ã¦ã€å¾Œã«ãã®åå‰ã‚’é–¢æ•°ã¨ã—ã¦ä½¿ã†ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã“ã‚Œã¯ä¸€èˆ¬çš„ãªåå‰å¤‰æ›´ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã¨ã—ã¦åƒãã¾ã™::"

#: ../../tutorial/controlflow.rst:304
msgid ""
"Coming from other languages, you might object that ``fib`` is not a function"
" but a procedure since it doesn't return a value.  In fact, even functions "
"without a :keyword:`return` statement do return a value, albeit a rather "
"boring one.  This value is called ``None`` (it's a built-in name).  Writing "
"the value ``None`` is normally suppressed by the interpreter if it would be "
"the only value written. You can see it if you really want to using "
":func:`print`::"
msgstr ""
"ä»–ã®è¨€èªå‡ºèº«ã®äººã‹ã‚‰ã¯ã€ ``fib`` ã¯å€¤ã‚’è¿”ã•ãªã„ã®ã§é–¢æ•°ã§ã¯ãªãæ‰‹ç¶šã (procedure) "
"ã ã¨ç•°è«–ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã­ã€‚æŠ€è¡“çš„ã«è¨€ãˆã°ã€å®Ÿéš›ã«ã¯ :keyword:`return` "
"æ–‡ã‚’æŒãŸãªã„é–¢æ•°ã‚‚ã‚„ã‚„ã¤ã¾ã‚‰ãªã„å€¤ã§ã™ãŒå€¤ã‚’è¿”ã—ã¦ã„ã¾ã™ã€‚ã“ã®å€¤ã¯ ``None`` ã¨å‘¼ã°ã‚Œã¾ã™ (ã“ã‚Œã¯çµ„ã¿è¾¼ã¿ã®åå‰ã§ã™)ã€‚ ``None`` "
"ã ã‘ã‚’æ›¸ãå‡ºãã†ã¨ã™ã‚‹ã¨ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯é€šå¸¸å‡ºåŠ›ã‚’æŠ‘åˆ¶ã—ã¾ã™ã€‚æœ¬å½“ã«å‡ºåŠ›ã—ãŸã„ã®ãªã‚‰ã€ä»¥ä¸‹ã®ã‚ˆã†ã« :func:`print` "
"ã‚’ä½¿ã†ã¨è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/controlflow.rst:315
msgid ""
"It is simple to write a function that returns a list of the numbers of the "
"Fibonacci series, instead of printing it::"
msgstr "ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã®æ•°ã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã‚’å‡ºåŠ›ã™ã‚‹ä»£ã‚ã‚Šã«ã€å€¤ã‚’è¿”ã™ã‚ˆã†ãªé–¢æ•°ã‚’æ›¸ãã®ã¯ç°¡å˜ã§ã™::"

#: ../../tutorial/controlflow.rst:331
msgid "This example, as usual, demonstrates some new Python features:"
msgstr "ã“ã®ä¾‹ã¯ Python ã®æ–°ã—ã„æ©Ÿèƒ½ã‚’ç¤ºã—ã¦ã„ã¾ã™:"

#: ../../tutorial/controlflow.rst:333
msgid ""
"The :keyword:`return` statement returns with a value from a function. "
":keyword:`return` without an expression argument returns ``None``. Falling "
"off the end of a function also returns ``None``."
msgstr ""
":keyword:`return` æ–‡ã§ã¯ã€é–¢æ•°ã‹ã‚‰ä¸€ã¤å€¤ã‚’è¿”ã—ã¾ã™ã€‚ :keyword:`return` ã®å¼•æ•°ã¨ãªã‚‹å¼ãŒãªã„å ´åˆã€ ``None``"
" ãŒè¿”ã‚Šã¾ã™ã€‚é–¢æ•°ãŒçµ‚äº†ã—ãŸã¨ãã«ã‚‚ ``None`` ãŒè¿”ã‚Šã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:337
msgid ""
"The statement ``result.append(a)`` calls a *method* of the list object "
"``result``.  A method is a function that 'belongs' to an object and is named"
" ``obj.methodname``, where ``obj`` is some object (this may be an "
"expression), and ``methodname`` is the name of a method that is defined by "
"the object's type. Different types define different methods.  Methods of "
"different types may have the same name without causing ambiguity.  (It is "
"possible to define your own object types and methods, using *classes*, see "
":ref:`tut-classes`) The method :meth:`append` shown in the example is "
"defined for list objects; it adds a new element at the end of the list.  In "
"this example it is equivalent to ``result = result + [a]``, but more "
"efficient."
msgstr ""
"æ–‡ ``result.append(a)`` ã§ã¯ã€ãƒªã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ``result`` ã® *ãƒ¡ã‚½ãƒƒãƒ‰ (method)* "
"ã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã« 'å±ã—ã¦ã„ã‚‹' é–¢æ•°ã®ã“ã¨ã§ã€ ``obj`` ã‚’ä½•ã‚‰ã‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (å¼ã§ã‚ã£ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“)ã€ "
"``methodname`` ã‚’ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰åã¨ã™ã‚‹ã¨ã€ ``obj.methodname`` "
"ã¨æ›¸ãè¡¨ã•ã‚Œã¾ã™ã€‚ç•°ãªã‚‹å‹ã¯ç•°ãªã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ç•°ãªã‚‹å‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§åŒã˜åå‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã“ã¨ãŒã§ãã€ã‚ã„ã¾ã„ã•ã‚’ç”Ÿã˜ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"
" (*ã‚¯ãƒ©ã‚¹ (class)* ã‚’ä½¿ã†ã“ã¨ã§ã€è‡ªå‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ :ref:`tut-classes` å‚ç…§) "
"ä¾‹ã§ç¤ºã•ã‚Œã¦ã„ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ :meth:`append` ã¯ã€ãƒªã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™; "
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒªã‚¹ãƒˆã®æœ«å°¾ã«æ–°ãŸãªè¦ç´ ã‚’è¿½åŠ ã—ã¾ã™ã€‚ã“ã®ä¾‹ã§ã® :meth:`append` ã¯ ``result = result + [a]`` "
"ã¨ç­‰ä¾¡ã§ã™ãŒã€ã‚ˆã‚ŠåŠ¹ç‡çš„ã§ã™ã€‚"

#: ../../tutorial/controlflow.rst:352
msgid "More on Defining Functions"
msgstr "é–¢æ•°å®šç¾©ã«ã¤ã„ã¦ã‚‚ã†å°‘ã—"

#: ../../tutorial/controlflow.rst:354
msgid ""
"It is also possible to define functions with a variable number of arguments."
" There are three forms, which can be combined."
msgstr "å¯å¤‰å€‹ã®å¼•æ•°ã‚’ä¼´ã†é–¢æ•°ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚å¼•æ•°ã®å®šç¾©æ–¹æ³•ã«ã¯ 3 ã¤ã®å½¢å¼ãŒã‚ã‚Šã€ãã‚Œã‚‰ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:361
msgid "Default Argument Values"
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å¼•æ•°å€¤"

#: ../../tutorial/controlflow.rst:363
msgid ""
"The most useful form is to specify a default value for one or more "
"arguments. This creates a function that can be called with fewer arguments "
"than it is defined to allow.  For example::"
msgstr ""
"ã‚‚ã£ã¨ã‚‚ä¾¿åˆ©ãªã®ã¯ã€ä¸€ã¤ä»¥ä¸Šã®å¼•æ•°ã«å¯¾ã—ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å€¤ã‚’æŒ‡å®šã™ã‚‹å½¢å¼ã§ã™ã€‚ã“ã®å½¢å¼ã‚’ä½¿ã†ã¨ã€å®šç¾©ã•ã‚Œã¦ã„ã‚‹å¼•æ•°ã‚ˆã‚Šå°‘ãªã„å€‹æ•°ã®å¼•æ•°ã§å‘¼ã³å‡ºã›ã‚‹é–¢æ•°ã‚’ä½œæˆã—ã¾ã™::"

#: ../../tutorial/controlflow.rst:379
msgid "This function can be called in several ways:"
msgstr "ã“ã®é–¢æ•°ã¯ã„ãã¤ã‹ã®æ–¹æ³•ã§å‘¼ã³å‡ºã›ã¾ã™:"

#: ../../tutorial/controlflow.rst:381
msgid ""
"giving only the mandatory argument: ``ask_ok('Do you really want to "
"quit?')``"
msgstr "å¿…é ˆã®å¼•æ•°ã®ã¿ä¸ãˆã‚‹: ``ask_ok('Do you really want to quit?')``"

#: ../../tutorial/controlflow.rst:383
msgid ""
"giving one of the optional arguments: ``ask_ok('OK to overwrite the file?', "
"2)``"
msgstr "ä¸€ã¤ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•°ã‚’ä¸ãˆã‚‹: ``ask_ok('OK to overwrite the file?', 2)``"

#: ../../tutorial/controlflow.rst:385
msgid ""
"or even giving all arguments: ``ask_ok('OK to overwrite the file?', 2, 'Come"
" on, only yes or no!')``"
msgstr ""
"å…¨ã¦ã®å¼•æ•°ã‚’ä¸ãˆã‚‹: ``ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or "
"no!')``"

#: ../../tutorial/controlflow.rst:388
msgid ""
"This example also introduces the :keyword:`in` keyword. This tests whether "
"or not a sequence contains a certain value."
msgstr ""
"ã“ã®ä¾‹ã§ã¯ :keyword:`in` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒå°å…¥ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒç‰¹å®šã®å€¤ã‚’å«ã‚“ã§ã„ã‚‹ã‹ã©ã†ã‹èª¿ã¹ã‚‹ã®ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:391
msgid ""
"The default values are evaluated at the point of function definition in the "
"*defining* scope, so that ::"
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ã€é–¢æ•°ãŒå®šç¾©ã•ã‚ŒãŸæ™‚ç‚¹ã§ã€é–¢æ•°ã‚’ *å®šç¾©ã—ã¦ã„ã‚‹* å´ã®ã‚¹ã‚³ãƒ¼ãƒ— (scope) ã§è©•ä¾¡ã•ã‚Œã‚‹ã®ã§ ::"

#: ../../tutorial/controlflow.rst:402
msgid "will print ``5``."
msgstr "ã¯ ``5`` ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:404
msgid ""
"**Important warning:**  The default value is evaluated only once. This makes"
" a difference when the default is a mutable object such as a list, "
"dictionary, or instances of most classes.  For example, the following "
"function accumulates the arguments passed to it on subsequent calls::"
msgstr ""
"**é‡è¦ãªè­¦å‘Š:**  ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ 1 "
"åº¦ã ã‘ã—ã‹è©•ä¾¡ã•ã‚Œã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒãƒªã‚¹ãƒˆã‚„è¾æ›¸ã®ã‚ˆã†ãªå¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ™‚ã«ã¯ãã®å½±éŸ¿ãŒã§ã¾ã™ã€‚ä¾‹ãˆã°ä»¥ä¸‹ã®é–¢æ•°ã¯ã€å¾Œã«ç¶šãé–¢æ•°å‘¼ã³å‡ºã—ã§é–¢æ•°ã«æ¸¡ã•ã‚Œã¦ã„ã‚‹å¼•æ•°ã‚’ç´¯ç©ã—ã¾ã™::"

#: ../../tutorial/controlflow.rst:417
msgid "This will print ::"
msgstr "ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã€ä»¥ä¸‹ã‚’å‡ºåŠ›ã—ã¾ã™ ::"

#: ../../tutorial/controlflow.rst:423
msgid ""
"If you don't want the default to be shared between subsequent calls, you can"
" write the function like this instead::"
msgstr "å¾Œç¶šã®é–¢æ•°å‘¼ã³å‡ºã—ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’å…±æœ‰ã—ãŸããªã‘ã‚Œã°ã€ä»£ã‚ã‚Šã«ä»¥ä¸‹ã®ã‚ˆã†ã«é–¢æ•°ã‚’æ›¸ãã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/controlflow.rst:436
msgid "Keyword Arguments"
msgstr "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°"

#: ../../tutorial/controlflow.rst:438
msgid ""
"Functions can also be called using :term:`keyword arguments <keyword "
"argument>` of the form ``kwarg=value``.  For instance, the following "
"function::"
msgstr ""
"é–¢æ•°ã‚’ ``kwarg=value`` ã¨ã„ã†å½¢å¼ã® :term:`ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•° <Keyword argument>` "
"ã‚’ä½¿ã£ã¦å‘¼ã³å‡ºã™ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ã®é–¢æ•°::"

#: ../../tutorial/controlflow.rst:447
msgid ""
"accepts one required argument (``voltage``) and three optional arguments "
"(``state``, ``action``, and ``type``).  This function can be called in any "
"of the following ways::"
msgstr ""
"ã¯ã€å¿…é ˆå¼•æ•° (``voltage``) ã¨ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° (``state``ã€``action``ã€``type``) "
"ã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ä»¥ä¸‹ã®ã„ãšã‚Œã‹ã®æ–¹æ³•ã§å‘¼ã³å‡ºã›ã¾ã™::"

#: ../../tutorial/controlflow.rst:458
msgid "but all the following calls would be invalid::"
msgstr "ãŒã€ä»¥ä¸‹ã®å‘¼ã³å‡ºã—ã¯ä¸é©åˆ‡ã§ã™::"

#: ../../tutorial/controlflow.rst:465
msgid ""
"In a function call, keyword arguments must follow positional arguments. All "
"the keyword arguments passed must match one of the arguments accepted by the"
" function (e.g. ``actor`` is not a valid argument for the ``parrot`` "
"function), and their order is not important.  This also includes non-"
"optional arguments (e.g. ``parrot(voltage=1000)`` is valid too). No argument"
" may receive a value more than once. Here's an example that fails due to "
"this restriction::"
msgstr ""
"é–¢æ•°ã®å‘¼ã³å‡ºã—ã«ãŠã„ã¦ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¯ä½ç½®å¼•æ•°ã®å¾Œã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æ¸¡ã•ã‚Œã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¯å…¨ã¦ã€é–¢æ•°ã§å—ã‘ä»˜ã‘ã‚‰ã‚Œã‚‹å¼•æ•°ã®ã„ãšã‚Œã‹ã«å¯¾å¿œã—ã¦ã„ãªã‘ã‚Œã°ãªã‚‰ãš"
" (ä¾‹ãˆã°ã€``actor`` ã¯ã“ã® ``parrot`` "
"é–¢æ•°ã®å¼•æ•°ã¨ã—ã¦é©åˆ‡ã§ã¯ã‚ã‚Šã¾ã›ã‚“)ã€é †åºã¯é‡è¦ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ãªã„å¼•æ•°ã§ã‚‚åŒæ§˜ã§ã™ "
"(ä¾‹ãˆã°ã€``parrot(voltage=1000)`` ã‚‚é©åˆ‡ã§ã™)ã€‚ã„ã‹ãªã‚‹å¼•æ•°ã‚‚å€¤ã‚’è¤‡æ•°å›ã¯å—ã‘å–ã‚Œã¾ã›ã‚“ã€‚ã“ã®åˆ¶é™ã«ã‚ˆã‚Šå¤±æ•—ã™ã‚‹ä¾‹ã¯::"

#: ../../tutorial/controlflow.rst:481
msgid ""
"When a final formal parameter of the form ``**name`` is present, it receives"
" a dictionary (see :ref:`typesmapping`) containing all keyword arguments "
"except for those corresponding to a formal parameter.  This may be combined "
"with a formal parameter of the form ``*name`` (described in the next "
"subsection) which receives a tuple containing the positional arguments "
"beyond the formal parameter list.  (``*name`` must occur before ``**name``.)"
" For example, if we define a function like this::"
msgstr ""
"ä»®å¼•æ•°ã®æœ€å¾Œã« ``**name`` ã®å½¢å¼ã®ã‚‚ã®ãŒã‚ã‚‹ã¨ã€ãã‚Œã¾ã§ã®ä»®å¼•æ•°ã«å¯¾å¿œã—ãŸã‚‚ã®ã‚’é™¤ãã™ã¹ã¦ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ãŒå…¥ã£ãŸè¾æ›¸ "
"(:ref:`typesmapping` ã‚’å‚ç…§) ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ ``**name`` ã¯ ``*name`` "
"ã®å½¢å¼ã‚’ã¨ã‚‹ã€ä»®å¼•æ•°ã®ãƒªã‚¹ãƒˆã‚’è¶…ãˆãŸä½ç½®å¼•æ•°ã®å…¥ã£ãŸã‚¿ãƒ—ãƒ«ã‚’å—ã‘å–ã‚‹å¼•æ•° (æ¬¡ã®ç¯€ã§è¿°ã¹ã¾ã™) ã¨çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ (``*name`` ã¯"
" ``**name`` ã‚ˆã‚Šå‰ã«ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“)ã€‚ä¾‹ãˆã°ã€ã‚ã‚‹é–¢æ•°ã®å®šç¾©ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«ã™ã‚‹ã¨::"

#: ../../tutorial/controlflow.rst:498
msgid "It could be called like this::"
msgstr "å‘¼ã³å‡ºã—ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Š::"

#: ../../tutorial/controlflow.rst:506
msgid "and of course it would print:"
msgstr "ã‚‚ã¡ã‚ã‚“ä»¥ä¸‹ã®ã‚ˆã†ã«å‡ºåŠ›ã•ã‚Œã¾ã™:"

#: ../../tutorial/controlflow.rst:519
msgid ""
"Note that the order in which the keyword arguments are printed is guaranteed"
" to match the order in which they were provided in the function call."
msgstr "ãªãŠã€è¤‡æ•°ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ä¸ãˆãŸå ´åˆã«ã€ãã‚Œã‚‰ãŒå‡ºåŠ›ã•ã‚Œã‚‹é †åºã¯ã€é–¢æ•°å‘¼ã³å‡ºã—ã§ä¸ãˆã‚‰ã‚ŒãŸé †åºã¨åŒã˜ã«ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:526
msgid "Arbitrary Argument Lists"
msgstr "ä»»æ„å¼•æ•°ãƒªã‚¹ãƒˆ"

#: ../../tutorial/controlflow.rst:531
msgid ""
"Finally, the least frequently used option is to specify that a function can "
"be called with an arbitrary number of arguments.  These arguments will be "
"wrapped up in a tuple (see :ref:`tut-tuples`).  Before the variable number "
"of arguments, zero or more normal arguments may occur. ::"
msgstr ""
"æœ€å¾Œã«ã€æœ€ã‚‚ä½¿ã†ã“ã¨ã®å°‘ãªã„é¸æŠè‚¢ã¨ã—ã¦ã€é–¢æ•°ãŒä»»æ„ã®å€‹æ•°ã®å¼•æ•°ã§å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†æŒ‡å®šã™ã‚‹æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®å¼•æ•°ã¯ã‚¿ãƒ—ãƒ« (:ref:`tut-"
"tuples` ã‚’å‚ç…§) ã«æ ¼ç´ã•ã‚Œã¾ã™ã€‚å¯å¤‰å€‹ã®å¼•æ•°ã®å‰ã«ã€ã‚¼ãƒ­å€‹ã‹ãã‚Œä»¥ä¸Šã®å¼•æ•°ãŒã‚ã£ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ ::"

#: ../../tutorial/controlflow.rst:540
msgid ""
"Normally, these ``variadic`` arguments will be last in the list of formal "
"parameters, because they scoop up all remaining input arguments that are "
"passed to the function. Any formal parameters which occur after the "
"``*args`` parameter are 'keyword-only' arguments, meaning that they can only"
" be used as keywords rather than positional arguments. ::"
msgstr ""
"é€šå¸¸ã“ã®ã‚ˆã†ãª ``å¯å¤‰`` å¼•æ•°ã¯ã€é–¢æ•°ã«æ¸¡ã•ã‚Œã‚‹å…¥åŠ›å¼•æ•°ã®æ®‹ã‚Šã‚’å…¨ã¦æ¬ã„å–ã‚‹ãŸã‚ã«ã€ä»®å¼•æ•°ãƒªã‚¹ãƒˆã®æœ€å¾Œã«ç½®ã‹ã‚Œã¾ã™ã€‚``*args`` "
"å¼•æ•°ã®å¾Œã«ã‚ã‚‹ä»®å¼•æ•°ã¯ 'ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å°‚ç”¨' å¼•æ•°ã§ã€ä½ç½®å¼•æ•°ã§ã¯ãªãã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ã—ã¦ã®ã¿ä½¿ãˆã¾ã™ã€‚ ::"

#: ../../tutorial/controlflow.rst:557
msgid "Unpacking Argument Lists"
msgstr "å¼•æ•°ãƒªã‚¹ãƒˆã®ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯"

#: ../../tutorial/controlflow.rst:559
msgid ""
"The reverse situation occurs when the arguments are already in a list or "
"tuple but need to be unpacked for a function call requiring separate "
"positional arguments.  For instance, the built-in :func:`range` function "
"expects separate *start* and *stop* arguments.  If they are not available "
"separately, write the function call with the  ``*``\\ -operator to unpack "
"the arguments out of a list or tuple::"
msgstr ""
"å¼•æ•°ãŒã™ã§ã«ãƒªã‚¹ãƒˆã‚„ã‚¿ãƒ—ãƒ«ã«ãªã£ã¦ã„ã¦ã€å€‹åˆ¥ãªä½ç½®å¼•æ•°ã‚’è¦æ±‚ã™ã‚‹é–¢æ•°å‘¼ã³å‡ºã—ã«æ¸¡ã™ãŸã‚ã«ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã«ã¯ã€é€†ã®çŠ¶æ³ãŒèµ·ã“ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€çµ„ã¿è¾¼ã¿é–¢æ•°"
" :func:`range` ã¯å¼•æ•° *start* ã¨ *stop* ã‚’åˆ¥ã«ä¸ãˆã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å€‹åˆ¥ã«å¼•æ•°ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ããªã„å ´åˆã€é–¢æ•°å‘¼ã³å‡ºã—ã‚’"
" ``*`` æ¼”ç®—å­ã‚’ä½¿ã£ã¦æ›¸ãã€ãƒªã‚¹ãƒˆã‚„ã‚¿ãƒ—ãƒ«ã‹ã‚‰å¼•æ•°ã‚’ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ã—ã¾ã™::"

#: ../../tutorial/controlflow.rst:575
msgid ""
"In the same fashion, dictionaries can deliver keyword arguments with the "
"``**``\\ -operator::"
msgstr "åŒã˜ã‚„ã‚Šã‹ãŸã§ã€``**`` ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ã£ã¦è¾æ›¸ã§ã‚‚ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/controlflow.rst:591
msgid "Lambda Expressions"
msgstr "ãƒ©ãƒ ãƒ€å¼"

#: ../../tutorial/controlflow.rst:593
msgid ""
"Small anonymous functions can be created with the :keyword:`lambda` keyword."
" This function returns the sum of its two arguments: ``lambda a, b: a+b``. "
"Lambda functions can be used wherever function objects are required.  They "
"are syntactically restricted to a single expression.  Semantically, they are"
" just syntactic sugar for a normal function definition.  Like nested "
"function definitions, lambda functions can reference variables from the "
"containing scope::"
msgstr ""
"ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ :keyword:`lambda` ã‚’ä½¿ã†ã¨ã€åå‰ã®ãªã„å°ã•ãªé–¢æ•°ã‚’ç”Ÿæˆã§ãã¾ã™ã€‚ä¾‹ãˆã° ``lambda a, b: a+b`` "
"ã¯ã€äºŒã¤ã®å¼•æ•°ã®å’Œã‚’è¿”ã™é–¢æ•°ã§ã™ã€‚ãƒ©ãƒ ãƒ€å¼ã®é–¢æ•°ã¯ã€é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹å ´æ‰€ã«ãªã‚‰ã©ã“ã§ã‚‚ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ©ãƒ ãƒ€å¼ã¯ã€æ§‹æ–‡ä¸Šå˜ä¸€ã®å¼ã«åˆ¶é™ã•ã‚Œã¦ã„ã¾ã™ã€‚æ„å‘³ä»˜ã‘çš„ã«ã¯ã€ãƒ©ãƒ ãƒ€å½¢å¼ã¯å˜ã«é€šå¸¸ã®é–¢æ•°å®šç¾©ã«æ§‹æ–‡çš„ãªç³–è¡£ã‚’ã‹ã¶ã›ãŸã‚‚ã®ã«éãã¾ã›ã‚“ã€‚å…¥ã‚Œå­æ§‹é€ ã«ãªã£ãŸé–¢æ•°å®šç¾©ã¨åŒæ§˜ã€ãƒ©ãƒ ãƒ€å¼ã‚‚ãã‚Œã‚’å–ã‚Šå›²ã‚€ã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å¤‰æ•°ã‚’å‚ç…§ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../tutorial/controlflow.rst:610
msgid ""
"The above example uses a lambda expression to return a function.  Another "
"use is to pass a small function as an argument::"
msgstr "ä¸Šè¨˜ã®ä¾‹ã¯ã€é–¢æ•°ã‚’è¿”ã™ã¨ã“ã‚ã§ãƒ©ãƒ ãƒ€å¼ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚ã‚‚ã†1ã¤ã®ä¾‹ã§ã¯ã€ã¡ã‚‡ã£ã¨ã—ãŸé–¢æ•°ã‚’å¼•æ•°ã¨ã—ã¦æ¸¡ã™ã®ã«ä½¿ã£ã¦ã„ã¾ã™::"

#: ../../tutorial/controlflow.rst:622
msgid "Documentation Strings"
msgstr "ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—"

#: ../../tutorial/controlflow.rst:629
msgid ""
"Here are some conventions about the content and formatting of documentation "
"strings."
msgstr "ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã«ã¤ã„ã¦ã¯ã€ãã®å†…å®¹ã¨æ›¸å¼ã«é–¢ã™ã‚‹æ…£ç¿’ã‚’ã„ãã¤ã‹æŒ™ã’ã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:632
msgid ""
"The first line should always be a short, concise summary of the object's "
"purpose.  For brevity, it should not explicitly state the object's name or "
"type, since these are available by other means (except if the name happens "
"to be a verb describing a function's operation).  This line should begin "
"with a capital letter and end with a period."
msgstr ""
"æœ€åˆã®è¡Œã¯ã€å¸¸ã«å¯¾è±¡ç‰©ã®ç›®çš„ã‚’çŸ­ãç°¡æ½”ã«ã¾ã¨ã‚ãŸã‚‚ã®ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ç°¡æ½”ã«æ›¸ããŸã‚ã«ã€å¯¾è±¡ç‰©ã®åå‰ã‚„å‹ã‚’æ˜ç¤ºã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚åå‰ã‚„å‹ã¯ä»–ã®æ–¹æ³•ã§ã‚‚å¾—ã‚‰ã‚Œã‚‹ã‹ã‚‰ã§ã™"
" (åå‰ãŒãŸã¾ãŸã¾é–¢æ•°ã®æ¼”ç®—å†…å®¹ã‚’è¨˜è¿°ã™ã‚‹å‹•è©ã§ã‚ã‚‹å ´åˆã¯ä¾‹å¤–ã§ã™)ã€‚æœ€åˆã®è¡Œã¯å¤§æ–‡å­—ã§å§‹ã¾ã‚Šã€ãƒ”ãƒªã‚ªãƒ‰ã§çµ‚ã‚ã£ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../tutorial/controlflow.rst:638
msgid ""
"If there are more lines in the documentation string, the second line should "
"be blank, visually separating the summary from the rest of the description."
"  The following lines should be one or more paragraphs describing the "
"object's calling conventions, its side effects, etc."
msgstr ""
"ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ä¸­ã«ã•ã‚‰ã«è¨˜è¿°ã™ã¹ãè¡ŒãŒã‚ã‚‹å ´åˆã€äºŒè¡Œç›®ã¯ç©ºè¡Œã«ã—ã€ã¾ã¨ã‚ã®è¡Œã¨æ®‹ã‚Šã®è¨˜è¿°éƒ¨åˆ†ã‚’è¦–è¦šçš„ã«åˆ†é›¢ã—ã¾ã™ã€‚ã¤ã¥ãè¡Œã¯ä¸€ã¤ã¾ãŸã¯ãã‚Œä»¥ä¸Šã®æ®µè½ã§ã€å¯¾è±¡ç‰©ã®å‘¼ã³å‡ºã—è¦ç´„ã‚„å‰¯ä½œç”¨ã«ã¤ã„ã¦è¨˜è¿°ã—ã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:643
msgid ""
"The Python parser does not strip indentation from multi-line string literals"
" in Python, so tools that process documentation have to strip indentation if"
" desired.  This is done using the following convention. The first non-blank "
"line *after* the first line of the string determines the amount of "
"indentation for the entire documentation string.  (We can't use the first "
"line since it is generally adjacent to the string's opening quotes so its "
"indentation is not apparent in the string literal.)  Whitespace "
"\"equivalent\" to this indentation is then stripped from the start of all "
"lines of the string.  Lines that are indented less should not occur, but if "
"they occur all their leading whitespace should be stripped.  Equivalence of "
"whitespace should be tested after expansion of tabs (to 8 spaces, normally)."
msgstr ""
"Python ã®ãƒ‘ãƒ¼ã‚¶ã¯è¤‡æ•°è¡Œã«ã‚ãŸã‚‹ Python "
"æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’å‰¥ãå–ã‚‰ãªã„ã®ã§ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‡¦ç†ã™ã‚‹ãƒ„ãƒ¼ãƒ«ã§ã¯å¿…è¦ã«å¿œã˜ã¦ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’å‰¥ãå–ã‚‰ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®å‡¦ç†ã¯ä»¥ä¸‹ã®è¦ç´„ã«å¾“ã£ã¦è¡Œã„ã¾ã™ã€‚æœ€åˆã®è¡Œã®"
" *å¾Œã«ã‚ã‚‹* "
"ç©ºè¡Œã§ãªã„æœ€åˆã®è¡ŒãŒã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå…¨ä½“ã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã®é‡ã‚’æ±ºã‚ã¾ã™ã€‚(æœ€åˆã®è¡Œã¯é€šå¸¸ã€æ–‡å­—åˆ—ã‚’é–‹å§‹ã™ã‚‹ã‚¯ã‚ªãƒ¼ãƒˆã«éš£ã‚Šåˆã£ã¦ã„ã‚‹ã®ã§ã€ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãŒæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ä¸­ã«ç¾ã‚Œãªã„ãŸã‚ã§ã™ã€‚)"
" ã“ã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆé‡ã¨ \"ç­‰ä¾¡ãª\" "
"ç©ºç™½ãŒã€æ–‡å­—åˆ—ã®ã™ã¹ã¦ã®è¡Œé ­ã‹ã‚‰å‰¥ãå–ã‚‰ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã®é‡ãŒå°‘ãªã„è¡Œã‚’æ›¸ã„ã¦ã¯ãªã‚‰ãªã„ã®ã§ã™ãŒã€ã‚‚ã—ãã†ã„ã†è¡ŒãŒã‚ã‚‹ã¨ã€å…ˆé ­ã®ç©ºç™½ã™ã¹ã¦ãŒå‰¥ãå–ã‚‰ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã®ç©ºç™½ã®å¤§ãã•ãŒç­‰ã—ã„ã‹ã©ã†ã‹ã¯ã€ã‚¿ãƒ–æ–‡å­—ã‚’"
" (é€šå¸¸ã¯ 8 æ–‡å­—ã®ã‚¹ãƒšãƒ¼ã‚¹ã¨ã—ã¦) å±•é–‹ã—ãŸå¾Œã«èª¿ã¹ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:655
msgid "Here is an example of a multi-line docstring::"
msgstr "ä»¥ä¸‹ã«è¤‡æ•°è¡Œã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã®ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../tutorial/controlflow.rst:673
msgid "Function Annotations"
msgstr "é–¢æ•°ã®ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³"

#: ../../tutorial/controlflow.rst:680
msgid ""
":ref:`Function annotations <function>` are completely optional metadata "
"information about the types used by user-defined functions (see :pep:`3107` "
"and :pep:`484` for more information)."
msgstr ""
":ref:`é–¢æ•°ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ <function>` ã¯ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã§ä½¿ç”¨ã•ã‚Œã‚‹å‹ã«ã¤ã„ã¦ã®å®Œå…¨ã«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æƒ…å ±ã§ã™ (è©³ç´°ã¯ "
":pep:`3107` ã¨ :pep:`484` ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../tutorial/controlflow.rst:684
msgid ""
"Annotations are stored in the :attr:`__annotations__` attribute of the "
"function as a dictionary and have no effect on any other part of the "
"function.  Parameter annotations are defined by a colon after the parameter "
"name, followed by an expression evaluating to the value of the annotation.  "
"Return annotations are defined by a literal ``->``, followed by an "
"expression, between the parameter list and the colon denoting the end of the"
" :keyword:`def` statement.  The following example has a positional argument,"
" a keyword argument, and the return value annotated::"
msgstr ""
"ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯é–¢æ•°ã® :attr:`__annotations__` "
"å±æ€§ã«è¾æ›¸ã¨ã—ã¦æ ¼ç´ã•ã‚Œã€é–¢æ•°ã®ä»–ã®éƒ¨åˆ†ã«ã¯ä½•ã‚‚å½±éŸ¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åã®å¾Œã«ã‚³ãƒ­ãƒ³ã‚’ç¶šã‘ã‚‹ã“ã¨ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚Œã€ãã®å¾Œã«ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®å€¤ã¨ã—ã¦è©•ä¾¡ã•ã‚Œã‚‹å¼ãŒç½®ã‹ã‚Œã¾ã™ã€‚æˆ»ã‚Šå€¤ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆã¨"
" :keyword:`def` ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã®çµ‚ã‚ã‚Šã‚’è¡¨ã™ã‚³ãƒ­ãƒ³ã®é–“ã«ç½®ã‹ã‚ŒãŸãƒªãƒ†ãƒ©ãƒ« ``->`` "
"ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚Œã€ãã®å¾Œã«å¼ãŒç¶šãã¾ã™ã€‚æ¬¡ã®ä¾‹ã¯ä½ç½®å¼•æ•°ã¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã€ãã—ã¦æˆ»ã‚Šå€¤ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æŒã£ã¦ã„ã¾ã™::"

#: ../../tutorial/controlflow.rst:706
msgid "Intermezzo: Coding Style"
msgstr "é–“å¥æ›²: ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚¿ã‚¤ãƒ«"

#: ../../tutorial/controlflow.rst:711
msgid ""
"Now that you are about to write longer, more complex pieces of Python, it is"
" a good time to talk about *coding style*.  Most languages can be written "
"(or more concise, *formatted*) in different styles; some are more readable "
"than others. Making it easy for others to read your code is always a good "
"idea, and adopting a nice coding style helps tremendously for that."
msgstr ""
"ã“ã‚Œã‹ã‚‰ã‚ˆã‚Šé•·ãã‚ˆã‚Šè¤‡é›‘ãª Python ã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ã„ãã®ã§ã€ãã‚ãã‚ *ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚¿ã‚¤ãƒ«* "
"ã«ã¤ã„ã¦èªã£ã¦ã‚‚è‰¯ã„é ƒã§ã™ã€‚ã»ã¨ã‚“ã©ã®è¨€èªã¯æ§˜ã€…ãªã‚¹ã‚¿ã‚¤ãƒ«ã§æ›¸ã‘ (ã‚‚ã£ã¨ç°¡æ½”ã«è¨€ãˆã° "
"*ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã*)ã€ã‚¹ã‚¿ã‚¤ãƒ«ã«ã‚ˆã£ã¦èª­ã¿æ˜“ã•ãŒç•°ãªã‚Šã¾ã™ã€‚ä»–äººã«ã¨ã£ã¦èª­ã¿æ˜“ã„ã‚³ãƒ¼ãƒ‰ã«ã—ã‚ˆã†ã¨ã™ã‚‹ã®ã¯ã©ã‚“ãªã¨ãã§ã‚‚è‰¯ã„è€ƒãˆã§ã‚ã‚Šã€è‰¯ã„ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ¡ç”¨ã™ã‚‹ã“ã¨ãŒéå¸¸ã«å¼·åŠ›ãªåŠ©ã‘ã«ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:717
msgid ""
"For Python, :pep:`8` has emerged as the style guide that most projects "
"adhere to; it promotes a very readable and eye-pleasing coding style.  Every"
" Python developer should read it at some point; here are the most important "
"points extracted for you:"
msgstr ""
"Python ã«ã¯ã€ã»ã¨ã‚“ã©ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒå®ˆã£ã¦ã„ã‚‹ã‚¹ã‚¿ã‚¤ãƒ«ã‚¬ã‚¤ãƒ‰ã¨ã—ã¦ :pep:`8` "
"ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã¯éå¸¸ã«èª­ã¿æ˜“ãç›®ã«å„ªã—ã„ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ¨å¥¨ã—ã¦ã„ã¾ã™ã€‚å…¨ã¦ã® Python "
"é–‹ç™ºè€…ã¯ã‚ã‚‹æ™‚ç‚¹ã§ãã‚Œã‚’èª­ã‚€ã¹ãã§ã™ã€‚ã“ã“ã«æœ€ã‚‚é‡è¦ãªç‚¹ã‚’æŠœãå‡ºã—ã¦ãŠãã¾ã™:"

#: ../../tutorial/controlflow.rst:722
msgid "Use 4-space indentation, and no tabs."
msgstr "ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã«ã¯ç©ºç™½ 4 ã¤ã‚’ä½¿ã„ã€ã‚¿ãƒ–ã¯ä½¿ã‚ãªã„ã“ã¨ã€‚"

#: ../../tutorial/controlflow.rst:724
msgid ""
"4 spaces are a good compromise between small indentation (allows greater "
"nesting depth) and large indentation (easier to read).  Tabs introduce "
"confusion, and are best left out."
msgstr ""
"ç©ºç™½ 4 ã¤ã¯ (æ·±ããƒã‚¹ãƒˆã§ãã‚‹) å°ã•ã„ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã¨ (èª­ã¿æ˜“ã„) "
"å¤§ãã„ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã®ã¡ã‚‡ã†ã©ä¸­é–“ã«å½“ãŸã‚Šã¾ã™ã€‚ã‚¿ãƒ–ã¯æ··ä¹±ã•ã›ã‚‹ã®ã§ã€ä½¿ã‚ãšã«ãŠãã®ãŒè‰¯ã„ã§ã™ã€‚"

#: ../../tutorial/controlflow.rst:728
msgid "Wrap lines so that they don't exceed 79 characters."
msgstr "ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®å¹…ãŒ 79 æ–‡å­—ã‚’è¶Šãˆãªã„ã‚ˆã†ã«è¡Œã‚’æŠ˜ã‚Šè¿”ã™ã“ã¨ã€‚"

#: ../../tutorial/controlflow.rst:730
msgid ""
"This helps users with small displays and makes it possible to have several "
"code files side-by-side on larger displays."
msgstr ""
"ã“ã†ã™ã‚‹ã“ã¨ã§å°ã•ã„ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ã‚’ä½¿ã£ã¦ã„ã‚‹ãƒ¦ãƒ¼ã‚¶ã‚‚èª­ã¿æ˜“ããªã‚Šã€å¤§ããªãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ã§ã¯ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸¦ã¹ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:733
msgid ""
"Use blank lines to separate functions and classes, and larger blocks of code"
" inside functions."
msgstr "é–¢æ•°ã‚„ã‚¯ãƒ©ã‚¹ã‚„é–¢æ•°å†…ã®å¤§ãã‚ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®åŒºåˆ‡ã‚Šã«ç©ºè¡Œã‚’ä½¿ã†ã“ã¨ã€‚"

#: ../../tutorial/controlflow.rst:736
msgid "When possible, put comments on a line of their own."
msgstr "å¯èƒ½ãªã‚‰ã€ã‚³ãƒ¡ãƒ³ãƒˆã¯è¡Œã«ç‹¬ç«‹ã§æ›¸ãã“ã¨ã€‚"

#: ../../tutorial/controlflow.rst:738
msgid "Use docstrings."
msgstr "docstring ã‚’ä½¿ã†ã“ã¨ã€‚"

#: ../../tutorial/controlflow.rst:740
msgid ""
"Use spaces around operators and after commas, but not directly inside "
"bracketing constructs: ``a = f(1, 2) + g(3, 4)``."
msgstr "æ¼”ç®—å­ã®å‰å¾Œã¨ã‚³ãƒ³ãƒã®å¾Œã«ã¯ç©ºç™½ã‚’å…¥ã‚Œã€æ‹¬å¼§é¡ã®ã™ãå†…å´ã«ã¯ç©ºç™½ã‚’å…¥ã‚Œãªã„ã“ã¨: ``a = f(1, 2) + g(3, 4)``ã€‚"

#: ../../tutorial/controlflow.rst:743
msgid ""
"Name your classes and functions consistently; the convention is to use "
"``CamelCase`` for classes and ``lower_case_with_underscores`` for functions "
"and methods.  Always use ``self`` as the name for the first method argument "
"(see :ref:`tut-firstclasses` for more on classes and methods)."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã‚„é–¢æ•°ã«ä¸€è²«æ€§ã®ã‚ã‚‹åå‰ã‚’ä»˜ã‘ã‚‹ã“ã¨ã€‚æ…£ç¿’ã§ã¯ ``CamelCase`` ã‚’ã‚¯ãƒ©ã‚¹åã«ä½¿ã„ã€ "
"``lower_case_with_underscores`` ã‚’é–¢æ•°åã‚„ãƒ¡ã‚½ãƒƒãƒ‰åã«ä½¿ã„ã¾ã™ã€‚å¸¸ã« ``self`` ã‚’ãƒ¡ã‚½ãƒƒãƒ‰ã®ç¬¬ 1 å¼•æ•°ã®åå‰ "
"(ã‚¯ãƒ©ã‚¹ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¤ã„ã¦ã¯ :ref:`tut-firstclasses` ã‚’è¦‹ã‚ˆ) ã¨ã—ã¦ä½¿ã†ã“ã¨ã€‚"

#: ../../tutorial/controlflow.rst:748
msgid ""
"Don't use fancy encodings if your code is meant to be used in international "
"environments.  Python's default, UTF-8, or even plain ASCII work best in any"
" case."
msgstr ""
"ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã‚’ä¸–ç•Œä¸­ã§ä½¿ã£ã¦ã‚‚ã‚‰ã†ã¤ã‚‚ã‚Šãªã‚‰ã€é¢¨å¤‰ã‚Šãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ä½¿ã‚ãªã„ã“ã¨ã€‚ã©ã‚“ãªå ´åˆã§ã‚‚ã€Python ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ UTF-8 "
"ã¾ãŸã¯ãƒ—ãƒ¬ãƒ¼ãƒ³ ASCII ãŒæœ€ã‚‚ä¸Šæ‰‹ãã„ãã¾ã™ã€‚"

#: ../../tutorial/controlflow.rst:752
msgid ""
"Likewise, don't use non-ASCII characters in identifiers if there is only the"
" slightest chance people speaking a different language will read or maintain"
" the code."
msgstr ""
"åŒæ§˜ã«ã€ã»ã‚“ã®å°‘ã—ã§ã‚‚ä»–ã®è¨€èªã‚’è©±ã™äººãŒã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚“ã ã‚Šãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã‚ã‚Œã°ã€é ASCII æ–‡å­—ã‚‚è­˜åˆ¥å­ã«ä½¿ã†ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../tutorial/controlflow.rst:758
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../tutorial/controlflow.rst:759
msgid ""
"Actually, *call by object reference* would be a better description, since if"
" a mutable object is passed, the caller will see any changes the callee "
"makes to it (items inserted into a list)."
msgstr ""
"å®Ÿéš›ã«ã¯ã€*ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§æ¸¡ã— (call by object reference)* "
"ã¨æ›¸ã‘ã°ã‚ˆã„ã®ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã¨ã„ã†ã®ã¯ã€å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ¸¡ã•ã‚Œã‚‹ã¨ã€é–¢æ•°ã®å‘¼ã³å‡ºã—å´ã¯ã€å‘¼ã³å‡ºã•ã‚ŒãŸå´ã®é–¢æ•°ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¡Œã£ãŸã©ã‚“ãªå¤‰æ›´ "
"(ä¾‹ãˆã°ãƒªã‚¹ãƒˆã«æŒ¿å…¥ã•ã‚ŒãŸè¦ç´ ) ã«ã‚‚å‡ºãã‚ã™ã“ã¨ã«ãªã‚‹ã‹ã‚‰ã§ã™ã€‚"
