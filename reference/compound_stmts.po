# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Masato HASHIMOTO <cabezon.hashimoto@gmail.com>, 2017
# Inada Naoki <songofacandy@gmail.com>, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2017
# E. Kawashima, 2017
# Arihiro TAKASE, 2017
# tomo, 2019
# Naoki Nakamura <agent@sohzoh.com>, 2020
# mollinaca, 2020
# Osamu NAKAMURA, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-09 05:58+0000\n"
"PO-Revision-Date: 2017-02-16 23:38+0000\n"
"Last-Translator: Osamu NAKAMURA, 2021\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "複合文 (compound statement)"

#: ../../reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"複合文には、他の文 (のグループ) が入ります; "
"複合文は、中に入っている他の文の実行の制御に何らかのやり方で影響を及ぼします。一般的には、複合文は複数行にまたがって書かれますが、全部の文を一行に連ねた単純な書き方もあります。"

#: ../../reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the "
":keyword:`with` statement allows the execution of initialization and "
"finalization code around a block of code.  Function and class definitions "
"are also syntactically compound statements."
msgstr ""
":keyword:`if` 、 :keyword:`while` 、および :keyword:`for` 文は、伝統的な制御フロー構成を実現します。 "
":keyword:`try` は例外処理および/または一連の文に対するクリーンアップコードを指定します。それに対して、 :keyword:`with` "
"文はコードのかたまりの前後でコードの初期化と終了処理を実行できるようにします。関数とクラス定義もまた、構文的には複合文です。"

#: ../../reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be"
" clear to which :keyword:`if` clause a following :keyword:`else` clause "
"would belong::"
msgstr ""
"複合文は、一つ以上の '節 (clause)' からなります。節は、ヘッダと 'スイート (suite)' "
"からなります。一つの複合文を成す各節のヘッダは、全て同じインデントレベルに置かれます。各節のヘッダは一意に識別するキーワードで始まり、コロンで終わります。スイートは、節によって制御される文の集まりです。スイートは、ヘッダがある行のコロンの後にセミコロンで区切って置かれた一つ以上の単純文、または、ヘッダに続く行で一つ多くインデントされた文の集まりです。後者の形式のスイートに限り、さらに複合文をネストできます;"
" 以下の文は、 :keyword:`else` 節がどちらの :keyword:`if` 節に属するかがはっきりしないなどの理由から不正になります::"

#: ../../reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"また、このコンテキスト中では、セミコロンによる結合はコロンより強いです。従って、以下の例では、 :func:`print` "
"の呼び出しはは全て実行されるか、全く実行されないかのどちらかです::"

#: ../../reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "まとめると、以下のようになります:"

#: ../../reference/compound_stmts.rst:68
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested "
":keyword:`if` statements to be indented)."
msgstr ""
"なお、文は常に ``NEWLINE`` か、その後に ``DEDENT`` "
"が続いたもので終了します。また、オプションの継続節は必ず、文を開始できない予約語で始まるので、曖昧さは存在しません。 (Python では、 "
"'ぶら下がり (dangling) :keyword:`else`' 問題は、ネストされた :keyword:`if` "
"文をインデントさせることで解決されます)。"

#: ../../reference/compound_stmts.rst:74
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr "以下の節における文法規則の記述方式は、明確さのために、各節を別々の行に書くようにしています。"

#: ../../reference/compound_stmts.rst:83
msgid "The :keyword:`!if` statement"
msgstr ":keyword:`!if` 文"

#: ../../reference/compound_stmts.rst:91
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ":keyword:`if` 文は、条件分岐を実行するために使われます:"

#: ../../reference/compound_stmts.rst:98
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
":keyword:`if` 文は、式を一つ一つ評価してゆき、真になるまで続けて、真になった節のスイートだけを選択します (真: true と偽: "
"false の定義については、 :ref:`booleans` 節を参照してください); 次に、選択したスイートを実行します (そして、 "
":keyword:`if` 文の他の部分は、実行や評価をされません)。全ての式が偽になった場合、 :keyword:`else` "
"節があれば、そのスイートが実行されます。"

#: ../../reference/compound_stmts.rst:108
msgid "The :keyword:`!while` statement"
msgstr ":keyword:`!while` 文"

#: ../../reference/compound_stmts.rst:116
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ":keyword:`while` 文は、式の値が真である間、実行を繰り返すために使われます:"

#: ../../reference/compound_stmts.rst:123
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested)"
" the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
":keyword:`while` 文は式を繰り返し真偽評価し、真であれば最初のスイートを実行します。式が偽であれば "
"(最初から偽になっていることもありえます)、 :keyword:`!else` 節がある場合にはそれを実行し、ループを終了します。"

#: ../../reference/compound_stmts.rst:132
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop"
" without executing the :keyword:`!else` clause's suite.  A "
":keyword:`continue` statement executed in the first suite skips the rest of "
"the suite and goes back to testing the expression."
msgstr ""
"最初のスイート内で :keyword:`break` 文が実行されると、 :keyword:`!else` "
"節のスイートを実行することなくループを終了します。 :keyword:`continue` "
"文が最初のスイート内で実行されると、スイート内にある残りの文の実行をスキップして、式の真偽評価に戻ります。"

#: ../../reference/compound_stmts.rst:141
msgid "The :keyword:`!for` statement"
msgstr ":keyword:`!for` 文"

#: ../../reference/compound_stmts.rst:152
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
":keyword:`for` 文は、シーケンス (文字列、タプルまたはリスト) や、その他の反復可能なオブジェクト (iterable object) "
"内の要素に渡って反復処理を行うために使われます:"

#: ../../reference/compound_stmts.rst:159
msgid ""
"The expression list is evaluated once; it should yield an iterable object.  "
"An iterator is created for the result of the ``expression_list``.  The suite"
" is then executed once for each item provided by the iterator, in the order "
"returned by the iterator.  Each item in turn is assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and then "
"the suite is executed.  When the items are exhausted (which is immediately "
"when the sequence is empty or an iterator raises a :exc:`StopIteration` "
"exception), the suite in the :keyword:`!else` clause, if present, is "
"executed, and the loop terminates."
msgstr ""
"式リストは一度だけ評価されます。その結果はイテラブルオブジェクトにならなければなりません。\n"
"``expression_list`` の結果に対するイテレータが生成されます。\n"
"その後、イテレータが与えるそれぞれの要素に対して、イテレータから返された順に一度づつ、スイートが実行されます。\n"
"それぞれの要素は標準の代入規則 (:ref:`assignment` を参照してください) で target_list に代入され、その後、スイートが実行されます。\n"
"全ての要素を使い切ったとき (シーケンスが空であったり、イテレータが :exc:`StopIteration` 例外を送出したときは、即座に)、 :keyword:`!else` 節があればそれが実行され、ループは終了します。"

#: ../../reference/compound_stmts.rst:172
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop"
" without executing the :keyword:`!else` clause's suite.  A "
":keyword:`continue` statement executed in the first suite skips the rest of "
"the suite and continues with the next item, or with the :keyword:`!else` "
"clause if there is no next item."
msgstr ""
"最初のスイートの中で :keyword:`break` 文が実行されると、 :keyword:`!else` 節のスイートを実行することなくループを終了します。\n"
":keyword:`continue` 文が最初のスイート内で実行されると、スイート内にある残りの文の実行をスキップして、次の要素の処理に移るか、これ以上次の要素が無い場合は :keyword:`!else` 節の処理に移ります。"

#: ../../reference/compound_stmts.rst:178
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"for ループはターゲットリスト内の変数への代入を行います。\n"
"これにより、for ループ内も含めて、それ以前の全ての代入は上書きされます::"

#: ../../reference/compound_stmts.rst:192
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in function :func:`range` returns an iterator of "
"integers suitable to emulate the effect of Pascal's ``for i := a to b do``; "
"e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``."
msgstr ""
"ループが終了してもターゲットリスト内の名前は削除されませんが、イテラブルが空の場合には、ループでの代入は全く行われません。ヒント: 組み込み関数 "
":func:`range` は、 Pascal の ``for i := a to b do`` "
"の効果をエミュレートするのに適した、整数のイテレータを返します; すなわち、 ``list(range(3))`` はリスト ``[0, 1, 2]``"
" を返します。"

#: ../../reference/compound_stmts.rst:204
msgid ""
"There is a subtlety when the sequence is being modified by the loop (this "
"can only occur for mutable sequences, e.g. lists).  An internal counter is "
"used to keep track of which item is used next, and this is incremented on "
"each iteration.  When this counter has reached the length of the sequence "
"the loop terminates.  This means that if the suite deletes the current (or a"
" previous) item from the sequence, the next item will be skipped (since it "
"gets the index of the current item which has already been treated).  "
"Likewise, if the suite inserts an item in the sequence before the current "
"item, the current item will be treated again the next time through the loop."
" This can lead to nasty bugs that can be avoided by making a temporary copy "
"using a slice of the whole sequence, e.g., ::"
msgstr ""
"ループ中でのシーケンスの変更には微妙な問題があります (これはミュータブルなシーケンスのみ、例えばリストで起こり得ます)。\n"
"どの要素が次に使われるかを追跡するために、内部的なカウンタが使われており、このカウンタは反復のたびに加算されます。\n"
"このカウンタがシーケンスの長さに達すると、ループは終了します。\n"
"このことから、スイートの中でシーケンスから現在の (または以前の) 要素を除去すると、(次の要素の位置が、既に処理済みの現在の要素のインデックスになるために) 次の要素が飛ばされることになります。\n"
"同様に、スイートの中でシーケンス中の現在の要素以前に要素を挿入すると、現在の要素がループの次の週で再度扱われることになります。\n"
"こうした仕様は、厄介なバグにつながります。\n"
"これは、シーケンス全体のスライスを使って一時的なコピーを作ることで避けられます。\n"
"例えば次のようにします::"

#: ../../reference/compound_stmts.rst:225
msgid "The :keyword:`!try` statement"
msgstr ":keyword:`!try` 文"

#: ../../reference/compound_stmts.rst:235
msgid ""
"The :keyword:`try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ":keyword:`try` 文は、ひとまとめの文に対して、例外処理および/またはクリーンアップコードを指定します:"

#: ../../reference/compound_stmts.rst:248
msgid ""
"The :keyword:`except` clause(s) specify one or more exception handlers. When"
" no exception occurs in the :keyword:`try` clause, no exception handler is "
"executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started.  This search inspects the except "
"clauses in turn until one is found that matches the exception.  An "
"expression-less except clause, if present, must be last; it matches any "
"exception.  For an except clause with an expression, that expression is "
"evaluated, and the clause matches the exception if the resulting object is "
"\"compatible\" with the exception.  An object is compatible with an "
"exception if it is the class or a base class of the exception object, or a "
"tuple containing an item that is the class or a base class of the exception "
"object."
msgstr ""

#: ../../reference/compound_stmts.rst:260
msgid ""
"If no except clause matches the exception, the search for an exception "
"handler continues in the surrounding code and on the invocation stack.  [#]_"
msgstr ""
"例外がどの :keyword:`except` 節にも合致しなかった場合、現在のコードを囲うさらに外側、そして呼び出しスタックへと検索を続けます。 "
"[#]_"

#: ../../reference/compound_stmts.rst:263
msgid ""
"If the evaluation of an expression in the header of an except clause raises "
"an exception, the original search for a handler is canceled and a search "
"starts for the new exception in the surrounding code and on the call stack "
"(it is treated as if the entire :keyword:`try` statement raised the "
"exception)."
msgstr ""
":keyword:`except` "
"節のヘッダにある式を値評価するときに例外が発生すると、元々のハンドラ検索はキャンセルされ、新たな例外に対する例外ハンドラの検索を現在の "
":keyword:`except` 節の外側のコードや呼び出しスタックに対して行います (:keyword:`try` "
"文全体が例外を発行したかのように扱われます)。"

#: ../../reference/compound_stmts.rst:270
msgid ""
"When a matching except clause is found, the exception is assigned to the "
"target specified after the :keyword:`!as` keyword in that except clause, if "
"present, and the except clause's suite is executed.  All except clauses must"
" have an executable block.  When the end of this block is reached, execution"
" continues normally after the entire try statement.  (This means that if two"
" nested handlers exist for the same exception, and the exception occurs in "
"the try clause of the inner handler, the outer handler will not handle the "
"exception.)"
msgstr ""
"対応する except 節が見つかると、except 節のスイートが実行されます。その際、 :keyword:`!as` "
"キーワードが存在すれば、その後で指定されているターゲットに例外が代入されます。全ての :keyword:`except` "
"節は実行可能なブロックを持っていなければなりません。このブロックの末尾に到達すると、通常は :keyword:`try` "
"文全体の直後から実行を継続します。(このことは、ネストされた二つの例外ハンドラが同じ例外に対して存在し、内側のハンドラ内の :keyword:`try`"
" 節で例外が発生した場合、外側のハンドラはその例外を処理しないことを意味します。)"

#: ../../reference/compound_stmts.rst:278
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the except clause.  This is as if ::"
msgstr ""
"例外が ``as target`` を使って代入されたとき、それは except 節の終わりに消去されます。これはちょうど、以下のコード::"

#: ../../reference/compound_stmts.rst:284
msgid "was translated to ::"
msgstr "が、以下のコードに翻訳されたかのようなものです::"

#: ../../reference/compound_stmts.rst:292
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the except clause.  Exceptions are cleared because with "
"the traceback attached to them, they form a reference cycle with the stack "
"frame, keeping all locals in that frame alive until the next garbage "
"collection occurs."
msgstr ""
"よって、例外を except "
"節以降で参照できるようにするためには、別の名前に代入されなければなりません。例外が削除されるのは、トレースバックが付与されると、そのスタックフレームと循環参照を形作り、次のガベージ収集までそのフレーム内のすべての局所変数を生存させてしまうからです。"

#: ../../reference/compound_stmts.rst:301
msgid ""
"Before an except clause's suite is executed, details about the exception are"
" stored in the :mod:`sys` module and can be accessed via "
":func:`sys.exc_info`. :func:`sys.exc_info` returns a 3-tuple consisting of "
"the exception class, the exception instance and a traceback object (see "
"section :ref:`types`) identifying the point in the program where the "
"exception occurred.  :func:`sys.exc_info` values are restored to their "
"previous values (before the call) when returning from a function that "
"handled an exception."
msgstr ""
":keyword:`except` 節のスイートが実行される前に、例外に関する詳細が :mod:`sys` モジュールに保存され、 "
":func:`sys.exc_info` からアクセスできます。 :func:`sys.exc_info` "
"は、例外クラス、例外インスタンス、そして例外が発生したプログラム上の位置を識別するトレースバックオブジェクト (:ref:`types` "
"を参照してください) の 3 要素からなるタプルを返します。 :func:`sys.exc_info` の値は、例外を処理した関数から戻るときに、以前 "
"(関数呼び出し前) の値に戻されます。"

#: ../../reference/compound_stmts.rst:315
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:`return`,"
" :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding "
":keyword:`except` clauses."
msgstr ""
"オプションの :keyword:`!else` 節は、コントロールフローが :keyword:`try` スイートを抜け、例外が送出されず、 :keyword:`return` 文、 :keyword:`continue` 文、 :keyword:`break` 文のいずれもが実行されなかった場合に実行されます。\n"
":keyword:`!else` 節で起きた例外は、手前にある :keyword:`except` 節では処理されません。"

#: ../../reference/compound_stmts.rst:323
msgid ""
"If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The "
":keyword:`try` clause is executed, including any :keyword:`except` and "
":keyword:`!else` clauses.  If an exception occurs in any of the clauses and "
"is not handled, the exception is temporarily saved. The :keyword:`!finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`!finally` clause.  If the :keyword:`!finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`!finally` clause executes a "
":keyword:`return`, :keyword:`break` or :keyword:`continue` statement, the "
"saved exception is discarded::"
msgstr ""
":keyword:`finally` 節がある場合は、 '後始末' の対処を指定します。まず :keyword:`except` 節や "
":keyword:`else` 節を含め、 :keyword:`try` "
"節が実行されます。それらの節の中で例外が起き、その例外が処理されていない場合には、例外は一時的に保存されます。次に :keyword:`finally`"
" 節が実行されます。保存された例外があった場合は、 :keyword:`finally` 節の末尾で再送出されます。 "
":keyword:`finally` 節で別の例外が送出される場合は、保存されていた例外は新しい例外のコンテキストとして設定されます。 "
":keyword:`finally` 節で :keyword:`return` 文あるいは :keyword:`break` "
"文を実行した場合は、保存された例外は破棄されます::"

#: ../../reference/compound_stmts.rst:342
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`finally` clause."
msgstr ":keyword:`finally` 節を実行している間は、プログラムからは例外情報は利用できません。"

#: ../../reference/compound_stmts.rst:350
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ "
":keyword:`!finally` statement, the :keyword:`finally` clause is also "
"executed 'on the way out.'"
msgstr ""
":keyword:`try`...\\ :keyword:`finally` 文の :keyword:`try` スイート内で "
":keyword:`return` 、 :keyword:`break` 、または :keyword:`continue` 文が実行された場合、 "
":keyword:`finally` 節も、この文を '抜け出る途中に' 実行されます。"

#: ../../reference/compound_stmts.rst:354
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`finally` clause always executes, a "
":keyword:`!return` statement executed in the :keyword:`!finally` clause will"
" always be the last one executed::"
msgstr ""
"関数の返り値は最後に実行された :keyword:`return` 文によって決まります。\n"
":keyword:`finally` 節は必ず実行されるため、:keyword:`!finally` 節で実行された :keyword:`!return` 文は常に最後に実行されることになります::"

#: ../../reference/compound_stmts.rst:368
msgid ""
"Additional information on exceptions can be found in section "
":ref:`exceptions`, and information on using the :keyword:`raise` statement "
"to generate exceptions may be found in section :ref:`raise`."
msgstr ""
"例外に関するその他の情報は :ref:`exceptions` 節にあります。また、 :keyword:`raise` "
"文の使用による例外の生成に関する情報は、 :ref:`raise` 節にあります。"

#: ../../reference/compound_stmts.rst:372
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the "
":keyword:`finally` clause due to a problem with the implementation."
msgstr ""
"Python3.8 以前では、実装上の問題により :keyword:`finally` 節での :keyword:`continue` 文は不正でした。"

#: ../../reference/compound_stmts.rst:381
msgid "The :keyword:`!with` statement"
msgstr ":keyword:`!with` 文"

#: ../../reference/compound_stmts.rst:390
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ "
":keyword:`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
":keyword:`with` 文は、ブロックの実行を、コンテキストマネージャによって定義されたメソッドでラップするために使われます (:ref"
":`context-managers` セクションを参照してください)。これにより、よくある :keyword:`try`...\\ "
":keyword:`except`...\\ :keyword:`finally` 利用パターンをカプセル化して便利に再利用することができます。"

#: ../../reference/compound_stmts.rst:399
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as"
" follows:"
msgstr "一つの \"要素\" を持つ :keyword:`with` 文の実行は以下のように進行します:"

#: ../../reference/compound_stmts.rst:401
msgid ""
"The context expression (the expression given in the :token:`with_item`) is "
"evaluated to obtain a context manager."
msgstr "コンテキスト式 (:token:`with_item` で与えられた式) を評価することで、コンテキストマネージャを取得します。"

#: ../../reference/compound_stmts.rst:404
msgid "The context manager's :meth:`__enter__` is loaded for later use."
msgstr "コンテキストマネージャの :meth:`__enter__` メソッドが、後で使うためにロードされます。"

#: ../../reference/compound_stmts.rst:406
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr "コンテキストマネージャの :meth:`__exit__` メソッドが、後で使うためにロードされます。"

#: ../../reference/compound_stmts.rst:408
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr "コンテキストマネージャの :meth:`__enter__` メソッドが呼ばれます。"

#: ../../reference/compound_stmts.rst:410
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr ":keyword:`with` 文にターゲットが含まれていたら、それに :meth:`__enter__` からの戻り値が代入されます。"

#: ../../reference/compound_stmts.rst:415
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be."
" See step 6 below."
msgstr ""
":keyword:`with` 文は、 :meth:`__enter__` メソッドがエラーなく終了した場合には :meth:`__exit__` "
"が常に呼ばれることを保証します。ですので、もしターゲットリストへの代入中にエラーが発生した場合には、これはそのスイートの中で発生したエラーと同じように扱われます。以下のステップ"
" 6 を参照してください。"

#: ../../reference/compound_stmts.rst:421
msgid "The suite is executed."
msgstr "スイートが実行されます。"

#: ../../reference/compound_stmts.rst:423
msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""
"コンテキストマネージャの :meth:`__exit__` "
"メソッドが呼ばれます。スイートが例外によって終了されたのなら、その例外の型、値、トレースバックが :meth:`__exit__` "
"に引数として渡されます。そうでなければ、 3 つの :const:`None` 引数が与えられます。"

#: ../../reference/compound_stmts.rst:428
msgid ""
"If the suite was exited due to an exception, and the return value from the "
":meth:`__exit__` method was false, the exception is reraised.  If the return"
" value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""
"スイートが例外により終了され、 :meth:`__exit__` "
"メソッドからの戻り値が偽（false）ならば、例外が再送出されます。この戻り値が真（true）ならば例外は抑制され、実行は "
":keyword:`with` 文の次の文から続きます。"

#: ../../reference/compound_stmts.rst:433
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal"
" location for the kind of exit that was taken."
msgstr ""
"もしそのスイートが例外でない何らかの理由で終了した場合、その :meth:`__exit__` "
"からの戻り値は無視されて、実行は発生した終了の種類に応じた通常の位置から継続します。"

#: ../../reference/compound_stmts.rst:437
#: ../../reference/compound_stmts.rst:815
#: ../../reference/compound_stmts.rst:856
msgid "The following code::"
msgstr "以下のコード::"

#: ../../reference/compound_stmts.rst:442
#: ../../reference/compound_stmts.rst:467
#: ../../reference/compound_stmts.rst:861
msgid "is semantically equivalent to::"
msgstr "これは次と等価です::"

#: ../../reference/compound_stmts.rst:461
msgid ""
"With more than one item, the context managers are processed as if multiple "
":keyword:`with` statements were nested::"
msgstr "複数の要素があるとき、コンテキストマネージャは複数の :keyword:`with` 文がネストされたかのように進行します::"

#: ../../reference/compound_stmts.rst:473
msgid "Support for multiple context expressions."
msgstr "複数のコンテキスト式をサポートしました。"

#: ../../reference/compound_stmts.rst:479
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" ステートメント"

#: ../../reference/compound_stmts.rst:479
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python の :keyword:`with` 文の仕様、背景、および例が記載されています。"

#: ../../reference/compound_stmts.rst:490
msgid "Function definitions"
msgstr "関数定義"

#: ../../reference/compound_stmts.rst:505
msgid ""
"A function definition defines a user-defined function object (see section "
":ref:`types`):"
msgstr "関数定義は、ユーザ定義関数オブジェクトを定義します (:ref:`types` 節参照):"

#: ../../reference/compound_stmts.rst:524
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper"
" around the executable code for the function).  This function object "
"contains a reference to the current global namespace as the global namespace"
" to be used when the function is called."
msgstr ""
"関数定義は実行可能な文です。関数定義を実行すると、現在のローカルな名前空間内で関数名を関数オブジェクト (関数の実行可能コードをくるむラッパー) "
"に束縛します。この関数オブジェクトには、関数が呼び出された際に使われるグローバルな名前空間として、現在のグローバルな名前空間への参照が入っています。"

#: ../../reference/compound_stmts.rst:530
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr "関数定義は関数本体を実行しません; 関数本体は関数が呼び出された時にのみ実行されます。 [#]_"

#: ../../reference/compound_stmts.rst:536
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"関数定義は一つ以上の :term:`デコレータ <decorator>` "
"式でラップできます。デコレータ式は関数を定義するとき、関数定義の入っているスコープで評価されます。その結果は、関数オブジェクトを唯一の引数にとる呼び出し可能オブジェクトでなければなりません。関数オブジェクトの代わりに、返された値が関数名に束縛されます。複数のデコレータはネストして適用されます。例えば、以下のようなコード::"

#: ../../reference/compound_stmts.rst:547
#: ../../reference/compound_stmts.rst:724
msgid "is roughly equivalent to ::"
msgstr "は、だいたい次と等価です ::"

#: ../../reference/compound_stmts.rst:552
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr "ただし、前者のコードでは元々の関数を ``func`` という名前へ一時的に束縛することはない、というところを除きます。"

#: ../../reference/compound_stmts.rst:554
msgid ""
"Functions may be decorated with any valid :token:`assignment_expression`. "
"Previously, the grammar was much more restrictive; see :pep:`614` for "
"details."
msgstr ""

#: ../../reference/compound_stmts.rst:564
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter "
"values.\"  For a parameter with a default value, the corresponding "
":term:`argument` may be omitted from a call, in which case the parameter's "
"default value is substituted.  If a parameter has a default value, all "
"following parameters up until the \"``*``\" must also have a default value "
"--- this is a syntactic restriction that is not expressed by the grammar."
msgstr ""
"1 つ以上の :term:`仮引数 <parameter>` が *parameter* ``=`` *expression* "
"の形を取っているとき、関数は \"デフォルト引数値\" を持つと言います。デフォルト値を持つ仮引数では、呼び出し時にそれに対応する :term:`実引数"
" <argument>` は省略でき、その場合は仮引数のデフォルト値が使われます。ある引数がデフォルト値を持っている場合、それ以降 \"``*``\" "
"が出てくるまでの引数は全てデフォルト値を持っていなければなりません -- これは文法定義では表現されていない構文的制限です。"

#: ../../reference/compound_stmts.rst:572
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter is a mutable object, such as a list or a"
" dictionary: if the function modifies the object (e.g. by appending an item "
"to a list), the default value is in effect modified.  This is generally not "
"what was intended.  A way around this is to use ``None`` as the default, and"
" explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**デフォルト引数値は関数定義が実行されるときに左から右へ評価されます。** "
"これは、デフォルト引数の式は関数が定義されるときにただ一度だけ評価され、同じ \"計算済みの\" "
"値が呼び出しのたびに使用されることを意味します。この仕様を理解しておくことは特に、デフォルト引数値がリストや辞書のようなミュータブルなオブジェクトであるときに重要です:"
" 関数がこのオブジェクトを変更 (例えばリストに要素を追加) "
"すると、このデフォルト値が変更の影響を受けてしまします。一般には、これは意図しない動作です。このような動作を避けるには、デフォルト値として "
"``None`` を使い、この値を関数本体の中で明示的にテストします。例えば以下のようにします::"

#: ../../reference/compound_stmts.rst:593
msgid ""
"Function call semantics are described in more detail in section "
":ref:`calls`. A function call always assigns values to all parameters "
"mentioned in the parameter list, either from positional arguments, from "
"keyword arguments, or from default values.  If the form \"``*identifier``\" "
"is present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed by keyword arguments.  Parameters before "
"\"``/``\" are positional-only parameters and may only be passed by "
"positional arguments."
msgstr ""

#: ../../reference/compound_stmts.rst:605
msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-only "
"parameters. See :pep:`570` for details."
msgstr ""

#: ../../reference/compound_stmts.rst:614
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``.  "
"Functions may have \"return\" annotation of the form \"``-> expression``\" "
"after the parameter list.  These annotations can be any valid Python "
"expression.  The presence of annotations does not change the semantics of a "
"function.  The annotation values are available as values of a dictionary "
"keyed by the parameters' names in the :attr:`__annotations__` attribute of "
"the function object.  If the ``annotations`` import from :mod:`__future__` "
"is used, annotations are preserved as strings at runtime which enables "
"postponed evaluation.  Otherwise, they are evaluated when the function "
"definition is executed.  In this case annotations may be evaluated in a "
"different order than they appear in the source code."
msgstr ""
"引数には、引数名に続けて \"``: expression``\" 形式の :term:`アノテーション <function annotation>` を付けられます。\n"
"``*identifier`` や ``**identifier`` の形式でも、すべての引数にはアノテーションをつけられます。\n"
"関数には、引数リストの後に \"``-> expression``\" 形式の \"return\" アノテーションをつけられます。これらのアノテーションは、任意の有効な Python の式が使えます。\n"
"アノテーションがあっても、関数の意味論は変わりません。\n"
"アノテーションの値は、関数オブジェクトの :attr:`__annotations__` 属性の、引数名をキーとする値として得られます。\n"
":mod:`__future__` の ``annotations`` インポートを使った場合は、アノテーションは実行時には文字列として保持され、これにより評価の遅延が可能になっています。\n"
"そうでない場合は、アノテーションは関数定義が実行されたときに評価されます。\n"
"このケースでは、アノテーションはソースコードに現れたのとは違う順序で評価されることがあります。"

#: ../../reference/compound_stmts.rst:629
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The "
"\":keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"式を即時に使用するために、無名関数 (名前に束縛されていない関数) を作成することもできます。\n"
"これは :ref:`lambda` の節で解説されているラムダ式を使います。\n"
"ラムダ式は簡略化された関数定義の簡略表現に過ぎないことに注意してください;  \":keyword:`def`\" 文で定義された関数もラムダ式で作成された関数のように、引数として渡せたり、他の名前に割り当てることができます。\n"
"複数の式とアノテーションが実行できるので、 \":keyword:`!def`\" 形式の方がより強力です。"

#: ../../reference/compound_stmts.rst:637
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def."
"  See section :ref:`naming` for details."
msgstr ""
"**プログラマへのメモ:** 関数は第一級オブジェクトです。関数定義内で実行された \"``def``\" "
"文は、返り値や引数として渡せるローカル関数を定義します。ネストした関数内で使われる自由変数は、 def "
"を含んでいる関数のローカル変数にアクセスできます。詳細は :ref:`naming` 節を参照してください。"

#: ../../reference/compound_stmts.rst:646
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - Function Annotations"

#: ../../reference/compound_stmts.rst:646
msgid "The original specification for function annotations."
msgstr "関数アノテーションの元の仕様書。"

#: ../../reference/compound_stmts.rst:649
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - 型ヒント"

#: ../../reference/compound_stmts.rst:649
msgid "Definition of a standard meaning for annotations: type hints."
msgstr "アノテーションの標準的な意味付けである型ヒントの定義。"

#: ../../reference/compound_stmts.rst:653
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Syntax for Variable Annotations"

#: ../../reference/compound_stmts.rst:652
msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables"
msgstr "クラス変数とインスタンス変数を含む変数に型ヒントが宣言できる機能"

#: ../../reference/compound_stmts.rst:656
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - アノテーションの遅延評価"

#: ../../reference/compound_stmts.rst:656
msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr "実行時にアノテーションを貪欲評価するのではなく文字列形式で保持することによる、アノテーションにおける前方参照のサポート"

#: ../../reference/compound_stmts.rst:663
msgid "Class definitions"
msgstr "クラス定義"

#: ../../reference/compound_stmts.rst:678
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr "クラス定義は、クラスオブジェクトを定義します (:ref:`types` 節参照):"

#: ../../reference/compound_stmts.rst:685
msgid ""
"A class definition is an executable statement.  The inheritance list usually"
" gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"クラス定義は実行可能な文です。継承リストは通常、基底クラスリストを与えます (より高度な使い方は、 :ref:`metaclasses` "
"を参照してください)。ですから、リストのそれぞれの要素の評価はサブクラス化しても良いクラスであるべきです。継承リストのないクラスは、デフォルトで、基底クラス"
" :class:`object` を継承するので::"

#: ../../reference/compound_stmts.rst:694
msgid "is equivalent to ::"
msgstr "は、以下と同等です ::"

#: ../../reference/compound_stmts.rst:699
msgid ""
"The class's suite is then executed in a new execution frame (see "
":ref:`naming`), using a newly created local namespace and the original "
"global namespace. (Usually, the suite contains mostly function definitions.)"
"  When the class's suite finishes execution, its execution frame is "
"discarded but its local namespace is saved. [#]_ A class object is then "
"created using the inheritance list for the base classes and the saved local "
"namespace for the attribute dictionary.  The class name is bound to this "
"class object in the original local namespace."
msgstr ""
"次にクラスのスイートが、新たな実行フレーム (:ref:`naming` を参照してください) "
"内で、新たに作られたローカル名前空間と元々のグローバル名前空間を使って実行されます "
"(通常、このスイートには主に関数定義が含まれます)。クラスのスイートが実行し終えると、実行フレームは破棄されますが、ローカルな名前空間は保存されます。[#]_"
" "
"次に、継承リストを基底クラスに、保存されたローカル名前空間を属性値辞書に、それぞれ使ってクラスオブジェクトが生成されます。最後に、もとのローカル名前空間において、クラス名がこのクラスオブジェクトに束縛されます。"

#: ../../reference/compound_stmts.rst:708
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's ``__dict__``.  Note that this is reliable only right after "
"the class is created and only for classes that were defined using the "
"definition syntax."
msgstr ""
"クラス本体で属性が定義された順序は新しいクラスの ``__dict__`` に保持されます。\n"
"この性質が期待できるのは、クラスが作られた直後かつ定義構文を使って定義されたクラスであるときのみです。"

#: ../../reference/compound_stmts.rst:713
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr "クラス作成は、 :ref:`メタクラス <metaclasses>` を利用して大幅にカスタマイズできます。"

#: ../../reference/compound_stmts.rst:718
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr "関数をデコレートするのと同じように、クラスもデコレートすることが出来ます、 ::"

#: ../../reference/compound_stmts.rst:729
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr "デコレータ式の評価規則は関数デコレータと同じです。結果はクラス名に束縛されます。"

#: ../../reference/compound_stmts.rst:732
msgid ""
"Classes may be decorated with any valid :token:`assignment_expression`. "
"Previously, the grammar was much more restrictive; see :pep:`614` for "
"details."
msgstr ""

#: ../../reference/compound_stmts.rst:737
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in"
" a method with ``self.name = value``.  Both class and instance attributes "
"are accessible through the notation \"``self.name``\", and an instance "
"attribute hides a class attribute with the same name when accessed in this "
"way.  Class attributes can be used as defaults for instance attributes, but "
"using mutable values there can lead to unexpected results.  "
":ref:`Descriptors <descriptors>` can be used to create instance variables "
"with different implementation details."
msgstr ""
"**プログラマのための注釈:** クラス定義内で定義された変数はクラス属性であり、全てのインスタンス間で共有されます。インスタンス属性は、メソッドの中で"
" ``self.name = value`` とすることで設定できます。クラス属性もインスタンス属性も \"``self.name``\" "
"表記でアクセスでき、この表記でアクセスしたとき、インスタンス属性は同名のクラス属性を隠蔽します。クラス属性は、インスタンス属性のデフォルト値として使えますが、そこにミュータブルな値を使うと予期せぬ結果につながります。"
" :ref:`記述子 <descriptors>` を使うと、詳細な実装が異なるインスタンス変数を作成できます。"

#: ../../reference/compound_stmts.rst:752
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaclasses in Python 3000"

#: ../../reference/compound_stmts.rst:750
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr "メタクラスの宣言を現在の文法と、メタクラス付きのクラスがどのように構築されるかの意味論を変更した提案"

#: ../../reference/compound_stmts.rst:755
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - クラスデコレータ"

#: ../../reference/compound_stmts.rst:755
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr ""
"クラスデコレータを追加した提案。\n"
"関数デコレータとメソッドデコレータは :pep:`318` で導入されました。"

#: ../../reference/compound_stmts.rst:762
msgid "Coroutines"
msgstr "コルーチン"

#: ../../reference/compound_stmts.rst:770
msgid "Coroutine function definition"
msgstr "コルーチン関数定義"

#: ../../reference/compound_stmts.rst:780
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`).  Inside the body of a coroutine function, ``await``"
" and ``async`` identifiers become reserved keywords; :keyword:`await` "
"expressions, :keyword:`async for` and :keyword:`async with` can only be used"
" in coroutine function bodies."
msgstr ""
"Python で実行しているコルーチンは多くの時点で一時停止と再開ができます (:term:`コルーチン <coroutine>` を参照してください)。\n"
"コルーチン関数の本体では、 ``await`` 識別子と ``async`` 識別子は予約語になります; :keyword:`await` 式である :keyword:`async for` と :keyword:`async with` はコルーチン関数の本体でしか使えません。"

#: ../../reference/compound_stmts.rst:786
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
" ``await`` や ``async`` キーワードがなくても、``async def`` 構文で定義された関数は常にコルーチン関数です。"

#: ../../reference/compound_stmts.rst:789
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr "コルーチン関数の本体の中で ``yield from`` 式を使用すると :exc:`SyntaxError` になります。"

#: ../../reference/compound_stmts.rst:792
msgid "An example of a coroutine function::"
msgstr "コルーチン関数の例::"

#: ../../reference/compound_stmts.rst:803
msgid "The :keyword:`!async for` statement"
msgstr ":keyword:`!async for` 文"

#: ../../reference/compound_stmts.rst:808
msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""

#: ../../reference/compound_stmts.rst:812
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterables."
msgstr ""

#: ../../reference/compound_stmts.rst:822
msgid "Is semantically equivalent to::"
msgstr "は意味論的に以下と等価です::"

#: ../../reference/compound_stmts.rst:838
msgid "See also :meth:`__aiter__` and :meth:`__anext__` for details."
msgstr "詳細は :meth:`__aiter__` や :meth:`__anext__` を参照してください。"

#: ../../reference/compound_stmts.rst:840
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr "コルーチン関数の本体の外で ``async for`` 文を使用すると :exc:`SyntaxError` になります。"

#: ../../reference/compound_stmts.rst:848
msgid "The :keyword:`!async with` statement"
msgstr ":keyword:`!async with` 文"

#: ../../reference/compound_stmts.rst:853
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is"
" able to suspend execution in its *enter* and *exit* methods."
msgstr ""
":term:`asynchronous context manager` は、 *enter* メソッドと *exit* "
"メソッド内部で実行を一時停止できる :term:`context manager` です。"

#: ../../reference/compound_stmts.rst:880
msgid "See also :meth:`__aenter__` and :meth:`__aexit__` for details."
msgstr "詳細は :meth:`__aenter__` や :meth:`__aexit__` を参照してください。"

#: ../../reference/compound_stmts.rst:882
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr "コルーチン関数の本体の外で ``async with`` 文を使用すると :exc:`SyntaxError` になります。"

#: ../../reference/compound_stmts.rst:888
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - async 構文および await 構文付きのコルーチン"

#: ../../reference/compound_stmts.rst:888
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and"
" added supporting syntax."
msgstr "コルーチンを Python のまともな独り立ちした概念にし、サポートする構文を追加した提案。"

#: ../../reference/compound_stmts.rst:893
msgid "Footnotes"
msgstr "脚注"

#: ../../reference/compound_stmts.rst:894
msgid ""
"The exception is propagated to the invocation stack unless there is a "
":keyword:`finally` clause which happens to raise another exception. That new"
" exception causes the old one to be lost."
msgstr ""
"例外は、別の例外を送出するような :keyword:`finally` "
"節が無い場合にのみ呼び出しスタックへ伝わります。新しい例外によって、古い例外は失われます。"

#: ../../reference/compound_stmts.rst:898
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""
"関数の本体の最初の文として現われる文字列リテラルは、その関数の ``__doc__`` 属性に変換され、その関数の "
":term:`ドキュメンテーション文字列 <docstring>` になります。"

#: ../../reference/compound_stmts.rst:902
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's "
":term:`docstring`."
msgstr ""
"クラスの本体の最初の文として現われる文字列リテラルは、その名前空間の ``__doc__`` 要素となり、そのクラスの "
":term:`ドキュメンテーション文字列 <docstring>` になります。"
