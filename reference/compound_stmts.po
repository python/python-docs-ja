# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2021
# Osamu NAKAMURA, 2021
# Yusuke Miyazaki <miyazaki.dev@gmail.com>, 2021
# 菊池 健志, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-24 14:15+0000\n"
"PO-Revision-Date: 2021-06-28 01:19+0000\n"
"Last-Translator: 菊池 健志, 2023\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "複合文 (compound statement)"

#: ../../reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"複合文には、他の文 (のグループ) が入ります; 複合文は、中に入っている他の文の"
"実行の制御に何らかのやり方で影響を及ぼします。一般的には、複合文は複数行にま"
"たがって書かれますが、全部の文を一行に連ねた単純な書き方もあります。"

#: ../../reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""
":keyword:`if` 、 :keyword:`while` 、および :keyword:`for` 文は、伝統的な制御"
"フロー構成を実現します。 :keyword:`try` は例外処理および/または一連の文に対す"
"るクリーンアップコードを指定します。それに対して、 :keyword:`with` 文はコード"
"のかたまりの前後でコードの初期化と終了処理を実行できるようにします。関数とク"
"ラス定義もまた、構文的には複合文です。"

#: ../../reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""
"複合文は、一つ以上の '節 (clause)' からなります。節は、ヘッダと 'スイート "
"(suite)' からなります。一つの複合文を成す各節のヘッダは、全て同じインデントレ"
"ベルに置かれます。各節のヘッダは一意に識別するキーワードで始まり、コロンで終"
"わります。スイートは、節によって制御される文の集まりです。スイートは、ヘッダ"
"がある行のコロンの後にセミコロンで区切って置かれた一つ以上の単純文、または、"
"ヘッダに続く行で一つ多くインデントされた文の集まりです。後者の形式のスイート"
"に限り、さらに複合文をネストできます; 以下の文は、 :keyword:`else` 節がどちら"
"の :keyword:`if` 節に属するかがはっきりしないなどの理由から不正になります::"

#: ../../reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"また、このコンテキスト中では、セミコロンによる結合はコロンより強いです。従っ"
"て、以下の例では、 :func:`print` の呼び出しはは全て実行されるか、全く実行され"
"ないかのどちらかです::"

#: ../../reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "まとめると、以下のようになります:"

#: ../../reference/compound_stmts.rst:69
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""
"なお、文は常に ``NEWLINE`` か、その後に ``DEDENT`` が続いたもので終了します。"
"また、オプションの継続節は必ず、文を開始できない予約語で始まるので、曖昧さは"
"存在しません。 (Python では、 'ぶら下がり (dangling) :keyword:`else`' 問題"
"は、ネストされた :keyword:`if` 文をインデントさせることで解決されます)。"

#: ../../reference/compound_stmts.rst:75
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""
"以下の節における文法規則の記述方式は、明確さのために、各節を別々の行に書くよ"
"うにしています。"

#: ../../reference/compound_stmts.rst:84
msgid "The :keyword:`!if` statement"
msgstr ":keyword:`!if` 文"

#: ../../reference/compound_stmts.rst:92
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ":keyword:`if` 文は、条件分岐を実行するために使われます:"

#: ../../reference/compound_stmts.rst:99
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
":keyword:`if` 文は、式を一つ一つ評価してゆき、真になるまで続けて、真になった"
"節のスイートだけを選択します (真: true と偽: false の定義については、 :ref:"
"`booleans` 節を参照してください); 次に、選択したスイートを実行します (そし"
"て、 :keyword:`if` 文の他の部分は、実行や評価をされません)。全ての式が偽に"
"なった場合、 :keyword:`else` 節があれば、そのスイートが実行されます。"

#: ../../reference/compound_stmts.rst:109
msgid "The :keyword:`!while` statement"
msgstr ":keyword:`!while` 文"

#: ../../reference/compound_stmts.rst:117
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""
":keyword:`while` 文は、式の値が真である間、実行を繰り返すために使われます:"

#: ../../reference/compound_stmts.rst:124
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
":keyword:`while` 文は式を繰り返し真偽評価し、真であれば最初のスイートを実行し"
"ます。式が偽であれば (最初から偽になっていることもありえます)、 :keyword:`!"
"else` 節がある場合にはそれを実行し、ループを終了します。"

#: ../../reference/compound_stmts.rst:133
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and goes back to testing the expression."
msgstr ""
"最初のスイート内で :keyword:`break` 文が実行されると、 :keyword:`!else` 節の"
"スイートを実行することなくループを終了します。 :keyword:`continue` 文が最初の"
"スイート内で実行されると、スイート内にある残りの文の実行をスキップして、式の"
"真偽評価に戻ります。"

#: ../../reference/compound_stmts.rst:142
msgid "The :keyword:`!for` statement"
msgstr ":keyword:`!for` 文"

#: ../../reference/compound_stmts.rst:153
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
":keyword:`for` 文は、シーケンス (文字列、タプルまたはリスト) や、その他の反復"
"可能なオブジェクト (iterable object) 内の要素に渡って反復処理を行うために使わ"
"れます:"

#: ../../reference/compound_stmts.rst:160
msgid ""
"The ``starred_list`` expression is evaluated once; it should yield an :term:"
"`iterable` object.  An :term:`iterator` is created for that iterable. The "
"first item provided by the iterator is then assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and the "
"suite is executed.  This repeats for each item provided by the iterator.  "
"When the iterator is exhausted, the suite in the :keyword:`!else` clause, if "
"present, is executed, and the loop terminates."
msgstr ""

#: ../../reference/compound_stmts.rst:173
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and continues with the next item, or with the :keyword:`!else` clause if "
"there is no next item."
msgstr ""
"最初のスイートの中で :keyword:`break` 文が実行されると、 :keyword:`!else` 節"
"のスイートを実行することなくループを終了します。\n"
":keyword:`continue` 文が最初のスイート内で実行されると、スイート内にある残り"
"の文の実行をスキップして、次の要素の処理に移るか、これ以上次の要素が無い場合"
"は :keyword:`!else` 節の処理に移ります。"

#: ../../reference/compound_stmts.rst:179
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"for ループはターゲットリスト内の変数への代入を行います。\n"
"これにより、for ループ内も含めて、それ以前の全ての代入は上書きされます::"

#: ../../reference/compound_stmts.rst:193
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in type :func:`range` represents immutable arithmetic "
"sequences of integers. For instance, iterating ``range(3)`` successively "
"yields 0, 1, and then 2."
msgstr ""
"ループが終了してもターゲットリスト内の名前は削除されませんが、イテラブルが空"
"の場合には、ループでの代入は全く行われません。ヒント: 組み込み型 :func:"
"`range` は、 整数の不変算術列を表します。例えば、 ``range(3)`` を反復すると"
"0、1そして2の順に結果を返します。"

#: ../../reference/compound_stmts.rst:198
msgid "Starred elements are now allowed in the expression list."
msgstr ""

#: ../../reference/compound_stmts.rst:205
msgid "The :keyword:`!try` statement"
msgstr ":keyword:`!try` 文"

#: ../../reference/compound_stmts.rst:215
msgid ""
"The :keyword:`!try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""
":keyword:`!try` 文は、ひとまとめの文に対して、例外処理および/またはクリーン"
"アップコードを指定します:"

#: ../../reference/compound_stmts.rst:231
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""
"例外に関するその他の情報は :ref:`exceptions` 節にあります。また、 :keyword:"
"`raise` 文の使用による例外の生成に関する情報は、 :ref:`raise` 節にあります。"

#: ../../reference/compound_stmts.rst:239
msgid ":keyword:`!except` clause"
msgstr ""

#: ../../reference/compound_stmts.rst:241
msgid ""
"The :keyword:`!except` clause(s) specify one or more exception handlers. "
"When no exception occurs in the :keyword:`try` clause, no exception handler "
"is executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started. This search inspects the :keyword:`!"
"except` clauses in turn until one is found that matches the exception. An "
"expression-less :keyword:`!except` clause, if present, must be last; it "
"matches any exception. For an :keyword:`!except` clause with an expression, "
"that expression is evaluated, and the clause matches the exception if the "
"resulting object is \"compatible\" with the exception.  An object is "
"compatible with an exception if the object is the class or a :term:`non-"
"virtual base class <abstract base class>` of the exception object, or a "
"tuple containing an item that is the class or a non-virtual base class of "
"the exception object."
msgstr ""
":keyword:`!except` 節は一つ以上の例外ハンドラを指定します。 :keyword:`try` 節"
"内で例外が起きなければ、どの例外ハンドラも実行されません。 :keyword:`!try` ス"
"イート内で例外が発生すると、例外ハンドラの検索が開始されます。この検索では、:"
"keyword:`!except` 節を逐次、発生した例外に対応するまで調べます。式を伴わな"
"い :keyword:`!except` 節を使うなら、最後に書かなければならず、これは全ての例"
"外に対応します。式を伴う :keyword:`!except` 節に対しては、その式が評価され、"
"結果のオブジェクトが例外と \"互換である (compatible)\" 場合にその節が対応しま"
"す。ある例外に対してオブジェクトが互換であるのは、そのオブジェクトが例外オブ"
"ジェクトのクラスかその :term:`非仮想基底クラス <abstract base class>` の場"
"合、または例外オブジェクトのクラスかその非仮想基底クラスの要素が入ったタプル"
"である場合です。"

#: ../../reference/compound_stmts.rst:256
msgid ""
"If no :keyword:`!except` clause matches the exception, the search for an "
"exception handler continues in the surrounding code and on the invocation "
"stack.  [#]_"
msgstr ""
"例外がどの :keyword:`!except` 節にも合致しなかった場合、現在のコードを囲うさ"
"らに外側、そして呼び出しスタックへと検索を続けます。 [#]_"

#: ../../reference/compound_stmts.rst:260
msgid ""
"If the evaluation of an expression in the header of an :keyword:`!except` "
"clause raises an exception, the original search for a handler is canceled "
"and a search starts for the new exception in the surrounding code and on the "
"call stack (it is treated as if the entire :keyword:`try` statement raised "
"the exception)."
msgstr ""
":keyword:`!except` 節のヘッダにある式を値評価するときに例外が発生すると、元々"
"のハンドラ検索はキャンセルされ、新たな例外に対する例外ハンドラの検索を現在"
"の :keyword:`except` 節の外側のコードや呼び出しスタックに対して行います (:"
"keyword:`try` 文全体が例外を発行したかのように扱われます)。"

#: ../../reference/compound_stmts.rst:268
msgid ""
"When a matching :keyword:`!except` clause is found, the exception is "
"assigned to the target specified after the :keyword:`!as` keyword in that :"
"keyword:`!except` clause, if present, and the :keyword:`!except` clause's "
"suite is executed. All :keyword:`!except` clauses must have an executable "
"block. When the end of this block is reached, execution continues normally "
"after the entire :keyword:`try` statement. (This means that if two nested "
"handlers exist for the same exception, and the exception occurs in the :"
"keyword:`!try` clause of the inner handler, the outer handler will not "
"handle the exception.)"
msgstr ""
"対応する :keyword:`!except` 節が見つかると、:keyword:`!except` 節のスイートが"
"実行されます。その際、 :keyword:`!as` キーワードが :keyword:`!except` 節に存"
"在すれば、その後で指定されているターゲットに例外が代入されます。全ての :"
"keyword:`!except` 節は実行可能なブロックを持っていなければなりません。このブ"
"ロックの末尾に到達すると、通常は :keyword:`try` 文全体の直後から実行を継続し"
"ます。(このことは、ネストされた二つの例外ハンドラが同じ例外に対して存在し、内"
"側のハンドラ内の :keyword:`!try` 節で例外が発生した場合、外側のハンドラはその"
"例外を処理しないことを意味します。)"

#: ../../reference/compound_stmts.rst:279
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the :keyword:`!except` clause.  This is as if ::"
msgstr ""
"例外が ``as target`` を使って代入されたとき、それは :keyword:`!except` 節の終"
"わりに消去されます。これはちょうど、以下のコード::"

#: ../../reference/compound_stmts.rst:285
msgid "was translated to ::"
msgstr "が、以下のコードに翻訳されたかのようなものです::"

#: ../../reference/compound_stmts.rst:293
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the :keyword:`!except` clause. Exceptions are cleared "
"because with the traceback attached to them, they form a reference cycle "
"with the stack frame, keeping all locals in that frame alive until the next "
"garbage collection occurs."
msgstr ""
"よって、例外を :keyword:`!except` 節以降で参照できるようにするためには、別の"
"名前に代入されなければなりません。例外が削除されるのは、トレースバックが付与"
"されると、そのスタックフレームと循環参照を形作り、次のガベージ収集までそのフ"
"レーム内のすべての局所変数を生存させてしまうからです。"

#: ../../reference/compound_stmts.rst:303
msgid ""
"Before an :keyword:`!except` clause's suite is executed, the exception is "
"stored in the :mod:`sys` module, where it can be accessed from within the "
"body of the :keyword:`!except` clause by calling :func:`sys.exception`. When "
"leaving an exception handler, the exception stored in the :mod:`sys` module "
"is reset to its previous value::"
msgstr ""

#: ../../reference/compound_stmts.rst:334
msgid ":keyword:`!except*` clause"
msgstr ""

#: ../../reference/compound_stmts.rst:336
msgid ""
"The :keyword:`!except*` clause(s) are used for handling :exc:"
"`ExceptionGroup`\\s. The exception type for matching is interpreted as in "
"the case of :keyword:`except`, but in the case of exception groups we can "
"have partial matches when the type matches some of the exceptions in the "
"group. This means that multiple :keyword:`!except*` clauses can execute, "
"each handling part of the exception group. Each clause executes at most once "
"and handles an exception group of all matching exceptions.  Each exception "
"in the group is handled by at most one :keyword:`!except*` clause, the first "
"that matches it. ::"
msgstr ""

#: ../../reference/compound_stmts.rst:364
msgid ""
"Any remaining exceptions that were not handled by any :keyword:`!except*` "
"clause are re-raised at the end, combined into an exception group along with "
"all exceptions that were raised from within :keyword:`!except*` clauses."
msgstr ""

#: ../../reference/compound_stmts.rst:368
msgid ""
"If the raised exception is not an exception group and its type matches one "
"of the :keyword:`!except*` clauses, it is caught and wrapped by an exception "
"group with an empty message string. ::"
msgstr ""

#: ../../reference/compound_stmts.rst:379
msgid ""
"An :keyword:`!except*` clause must have a matching type, and this type "
"cannot be a subclass of :exc:`BaseExceptionGroup`. It is not possible to "
"mix :keyword:`except` and :keyword:`!except*` in the same :keyword:`try`. :"
"keyword:`break`, :keyword:`continue` and :keyword:`return` cannot appear in "
"an :keyword:`!except*` clause."
msgstr ""

#: ../../reference/compound_stmts.rst:396
msgid ":keyword:`!else` clause"
msgstr ""

#: ../../reference/compound_stmts.rst:398
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:"
"`return`, :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding :"
"keyword:`except` clauses."
msgstr ""
"オプションの :keyword:`!else` 節は、コントロールフローが :keyword:`try` ス"
"イートを抜け、例外が送出されず、 :keyword:`return` 文、 :keyword:`continue` "
"文、 :keyword:`break` 文のいずれもが実行されなかった場合に実行されます。\n"
":keyword:`!else` 節で起きた例外は、手前にある :keyword:`except` 節では処理さ"
"れません。"

#: ../../reference/compound_stmts.rst:410
msgid ":keyword:`!finally` clause"
msgstr ""

#: ../../reference/compound_stmts.rst:412
msgid ""
"If :keyword:`!finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`else` clauses.  If an exception occurs in any of the clauses and is "
"not handled, the exception is temporarily saved. The :keyword:`!finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`!finally` clause.  If the :keyword:`!finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`!finally` clause executes a :keyword:"
"`return`, :keyword:`break` or :keyword:`continue` statement, the saved "
"exception is discarded::"
msgstr ""
":keyword:`!finally` 節がある場合は、 '後始末' の対処を指定します。まず :"
"keyword:`except` 節や :keyword:`else` 節を含め、 :keyword:`try` 節が実行され"
"ます。それらの節の中で例外が起き、その例外が処理されていない場合には、例外は"
"一時的に保存されます。次に :keyword:`!finally` 節が実行されます。保存された例"
"外があった場合は、 :keyword:`!finally` 節の末尾で再送出されます。 :keyword:`!"
"finally` 節で別の例外が送出される場合は、保存されていた例外は新しい例外のコン"
"テキストとして設定されます。 :keyword:`!finally` 節で :keyword:`return` "
"文、 :keyword:`break` 文あるいは :keyword:`continue` 文を実行した場合は、保存"
"された例外は破棄されます::"

#: ../../reference/compound_stmts.rst:431
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`!finally` clause."
msgstr ""
":keyword:`!finally` 節を実行している間は、プログラムからは例外情報は利用でき"
"ません。"

#: ../../reference/compound_stmts.rst:439
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ :keyword:`!"
"finally` statement, the :keyword:`!finally` clause is also executed 'on the "
"way out.'"
msgstr ""
":keyword:`try`...\\ :keyword:`!finally` 文の :keyword:`try` スイート内で :"
"keyword:`return` 、 :keyword:`break` 、または :keyword:`continue` 文が実行さ"
"れた場合、 :keyword:`!finally` 節も、この文を '抜け出る途中に' 実行されます。"

#: ../../reference/compound_stmts.rst:443
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`!finally` clause always executes, "
"a :keyword:`!return` statement executed in the :keyword:`!finally` clause "
"will always be the last one executed::"
msgstr ""
"関数の返り値は最後に実行された :keyword:`return` 文によって決まります。\n"
":keyword:`!finally` 節は必ず実行されるため、:keyword:`!finally` 節で実行され"
"た :keyword:`!return` 文は常に最後に実行されることになります::"

#: ../../reference/compound_stmts.rst:457
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the :"
"keyword:`!finally` clause due to a problem with the implementation."
msgstr ""
"Python3.8 以前では、実装上の問題により :keyword:`!finally` 節での :keyword:"
"`continue` 文は不正でした。"

#: ../../reference/compound_stmts.rst:466
msgid "The :keyword:`!with` statement"
msgstr ":keyword:`!with` 文"

#: ../../reference/compound_stmts.rst:475
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
":keyword:`with` 文は、ブロックの実行を、コンテキストマネージャによって定義さ"
"れたメソッドでラップするために使われます (:ref:`context-managers` セクション"
"を参照してください)。これにより、よくある :keyword:`try`...\\ :keyword:"
"`except`...\\ :keyword:`finally` 利用パターンをカプセル化して便利に再利用する"
"ことができます。"

#: ../../reference/compound_stmts.rst:485
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""
"一つの \"要素\" を持つ :keyword:`with` 文の実行は以下のように進行します:"

#: ../../reference/compound_stmts.rst:487
msgid ""
"The context expression (the expression given in the :token:`~python-grammar:"
"with_item`) is evaluated to obtain a context manager."
msgstr ""
"コンテキスト式 (:token:`~python-grammar:with_item` で与えられた式) を評価する"
"ことで、コンテキストマネージャを取得します。"

#: ../../reference/compound_stmts.rst:490
msgid "The context manager's :meth:`__enter__` is loaded for later use."
msgstr ""
"コンテキストマネージャの :meth:`__enter__` メソッドが、後で使うためにロードさ"
"れます。"

#: ../../reference/compound_stmts.rst:492
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr ""
"コンテキストマネージャの :meth:`__exit__` メソッドが、後で使うためにロードさ"
"れます。"

#: ../../reference/compound_stmts.rst:494
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr "コンテキストマネージャの :meth:`__enter__` メソッドが呼ばれます。"

#: ../../reference/compound_stmts.rst:496
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr ""
":keyword:`with` 文にターゲットが含まれていたら、それに :meth:`__enter__` から"
"の戻り値が代入されます。"

#: ../../reference/compound_stmts.rst:501
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be. "
"See step 7 below."
msgstr ""
":keyword:`with` 文は、 :meth:`__enter__` メソッドがエラーなく終了した場合に"
"は :meth:`__exit__` が常に呼ばれることを保証します。ですので、もしターゲット"
"リストへの代入中にエラーが発生した場合には、これはそのスイートの中で発生した"
"エラーと同じように扱われます。以下のステップ 7 を参照してください。"

#: ../../reference/compound_stmts.rst:507
msgid "The suite is executed."
msgstr "スイートが実行されます。"

#: ../../reference/compound_stmts.rst:509
msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""
"コンテキストマネージャの :meth:`__exit__` メソッドが呼ばれます。スイートが例"
"外によって終了されたのなら、その例外の型、値、トレースバックが :meth:"
"`__exit__` に引数として渡されます。そうでなければ、 3 つの :const:`None` 引数"
"が与えられます。"

#: ../../reference/compound_stmts.rst:514
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`__exit__` method was false, the exception is reraised.  If the return "
"value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""
"スイートが例外により終了され、 :meth:`__exit__` メソッドからの戻り値が偽"
"（false）ならば、例外が再送出されます。この戻り値が真（true）ならば例外は抑制"
"され、実行は :keyword:`with` 文の次の文から続きます。"

#: ../../reference/compound_stmts.rst:519
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal "
"location for the kind of exit that was taken."
msgstr ""
"もしそのスイートが例外でない何らかの理由で終了した場合、その :meth:"
"`__exit__` からの戻り値は無視されて、実行は発生した終了の種類に応じた通常の位"
"置から継続します。"

#: ../../reference/compound_stmts.rst:523
#: ../../reference/compound_stmts.rst:1514
#: ../../reference/compound_stmts.rst:1555
msgid "The following code::"
msgstr "以下のコード::"

#: ../../reference/compound_stmts.rst:528
#: ../../reference/compound_stmts.rst:553
#: ../../reference/compound_stmts.rst:1560
msgid "is semantically equivalent to::"
msgstr "これは次と等価です::"

#: ../../reference/compound_stmts.rst:547
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""
"複数の要素があるとき、コンテキストマネージャは複数の :keyword:`with` 文がネス"
"トされたかのように進行します::"

#: ../../reference/compound_stmts.rst:559
msgid ""
"You can also write multi-item context managers in multiple lines if the "
"items are surrounded by parentheses. For example::"
msgstr ""

#: ../../reference/compound_stmts.rst:568
msgid "Support for multiple context expressions."
msgstr "複数のコンテキスト式をサポートしました。"

#: ../../reference/compound_stmts.rst:571
msgid ""
"Support for using grouping parentheses to break the statement in multiple "
"lines."
msgstr ""

#: ../../reference/compound_stmts.rst:577
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" ステートメント"

#: ../../reference/compound_stmts.rst:577
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python の :keyword:`with` 文の仕様、背景、および例が記載されています。"

#: ../../reference/compound_stmts.rst:583
msgid "The :keyword:`!match` statement"
msgstr ":keyword:`!match` 文"

#: ../../reference/compound_stmts.rst:597
msgid "The match statement is used for pattern matching.  Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:606
msgid ""
"This section uses single quotes to denote :ref:`soft keywords <soft-"
"keywords>`."
msgstr ""

#: ../../reference/compound_stmts.rst:609
msgid ""
"Pattern matching takes a pattern as input (following ``case``) and a subject "
"value (following ``match``).  The pattern (which may contain subpatterns) is "
"matched against the subject value.  The outcomes are:"
msgstr ""

#: ../../reference/compound_stmts.rst:613
msgid "A match success or failure (also termed a pattern success or failure)."
msgstr ""

#: ../../reference/compound_stmts.rst:615
msgid ""
"Possible binding of matched values to a name.  The prerequisites for this "
"are further discussed below."
msgstr ""

#: ../../reference/compound_stmts.rst:618
msgid ""
"The ``match`` and ``case`` keywords are :ref:`soft keywords <soft-keywords>`."
msgstr ""

#: ../../reference/compound_stmts.rst:622
#: ../../reference/compound_stmts.rst:1177
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- 構造的パターンマッチ: 仕様"

#: ../../reference/compound_stmts.rst:623
#: ../../reference/compound_stmts.rst:1178
msgid ":pep:`636` -- Structural Pattern Matching: Tutorial"
msgstr ":pep:`636` -- 構造的パターンマッチ: チュートリアル"

#: ../../reference/compound_stmts.rst:627
msgid "Overview"
msgstr "概要"

#: ../../reference/compound_stmts.rst:629
msgid "Here's an overview of the logical flow of a match statement:"
msgstr ""

#: ../../reference/compound_stmts.rst:632
msgid ""
"The subject expression ``subject_expr`` is evaluated and a resulting subject "
"value obtained. If the subject expression contains a comma, a tuple is "
"constructed using :ref:`the standard rules <typesseq-tuple>`."
msgstr ""

#: ../../reference/compound_stmts.rst:636
msgid ""
"Each pattern in a ``case_block`` is attempted to match with the subject "
"value. The specific rules for success or failure are described below. The "
"match attempt can also bind some or all of the standalone names within the "
"pattern. The precise pattern binding rules vary per pattern type and are "
"specified below.  **Name bindings made during a successful pattern match "
"outlive the executed block and can be used after the match statement**."
msgstr ""

#: ../../reference/compound_stmts.rst:645
msgid ""
"During failed pattern matches, some subpatterns may succeed.  Do not rely on "
"bindings being made for a failed match.  Conversely, do not rely on "
"variables remaining unchanged after a failed match.  The exact behavior is "
"dependent on implementation and may vary.  This is an intentional decision "
"made to allow different implementations to add optimizations."
msgstr ""

#: ../../reference/compound_stmts.rst:652
msgid ""
"If the pattern succeeds, the corresponding guard (if present) is evaluated. "
"In this case all name bindings are guaranteed to have happened."
msgstr ""

#: ../../reference/compound_stmts.rst:655
msgid ""
"If the guard evaluates as true or is missing, the ``block`` inside "
"``case_block`` is executed."
msgstr ""

#: ../../reference/compound_stmts.rst:658
msgid "Otherwise, the next ``case_block`` is attempted as described above."
msgstr ""

#: ../../reference/compound_stmts.rst:660
msgid "If there are no further case blocks, the match statement is completed."
msgstr ""

#: ../../reference/compound_stmts.rst:664
msgid ""
"Users should generally never rely on a pattern being evaluated.  Depending "
"on implementation, the interpreter may cache values or use other "
"optimizations which skip repeated evaluations."
msgstr ""

#: ../../reference/compound_stmts.rst:668
msgid "A sample match statement::"
msgstr ""

#: ../../reference/compound_stmts.rst:684
msgid ""
"In this case, ``if flag`` is a guard.  Read more about that in the next "
"section."
msgstr ""

#: ../../reference/compound_stmts.rst:687
msgid "Guards"
msgstr ""

#: ../../reference/compound_stmts.rst:694
msgid ""
"A ``guard`` (which is part of the ``case``) must succeed for code inside the "
"``case`` block to execute.  It takes the form: :keyword:`if` followed by an "
"expression."
msgstr ""

#: ../../reference/compound_stmts.rst:699
msgid "The logical flow of a ``case`` block with a ``guard`` follows:"
msgstr ""

#: ../../reference/compound_stmts.rst:701
msgid ""
"Check that the pattern in the ``case`` block succeeded.  If the pattern "
"failed, the ``guard`` is not evaluated and the next ``case`` block is "
"checked."
msgstr ""

#: ../../reference/compound_stmts.rst:705
msgid "If the pattern succeeded, evaluate the ``guard``."
msgstr ""

#: ../../reference/compound_stmts.rst:707
msgid ""
"If the ``guard`` condition evaluates as true, the case block is selected."
msgstr ""

#: ../../reference/compound_stmts.rst:710
msgid ""
"If the ``guard`` condition evaluates as false, the case block is not "
"selected."
msgstr ""

#: ../../reference/compound_stmts.rst:713
msgid ""
"If the ``guard`` raises an exception during evaluation, the exception "
"bubbles up."
msgstr ""

#: ../../reference/compound_stmts.rst:716
msgid ""
"Guards are allowed to have side effects as they are expressions.  Guard "
"evaluation must proceed from the first to the last case block, one at a "
"time, skipping case blocks whose pattern(s) don't all succeed. (I.e., guard "
"evaluation must happen in order.) Guard evaluation must stop once a case "
"block is selected."
msgstr ""

#: ../../reference/compound_stmts.rst:726
msgid "Irrefutable Case Blocks"
msgstr ""

#: ../../reference/compound_stmts.rst:730
msgid ""
"An irrefutable case block is a match-all case block.  A match statement may "
"have at most one irrefutable case block, and it must be last."
msgstr ""

#: ../../reference/compound_stmts.rst:733
msgid ""
"A case block is considered irrefutable if it has no guard and its pattern is "
"irrefutable.  A pattern is considered irrefutable if we can prove from its "
"syntax alone that it will always succeed.  Only the following patterns are "
"irrefutable:"
msgstr ""

#: ../../reference/compound_stmts.rst:738
msgid ":ref:`as-patterns` whose left-hand side is irrefutable"
msgstr ""

#: ../../reference/compound_stmts.rst:740
msgid ":ref:`or-patterns` containing at least one irrefutable pattern"
msgstr ""

#: ../../reference/compound_stmts.rst:742
msgid ":ref:`capture-patterns`"
msgstr ""

#: ../../reference/compound_stmts.rst:744
msgid ":ref:`wildcard-patterns`"
msgstr ""

#: ../../reference/compound_stmts.rst:746
msgid "parenthesized irrefutable patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:750
msgid "Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:757
msgid "This section uses grammar notations beyond standard EBNF:"
msgstr ""

#: ../../reference/compound_stmts.rst:759
msgid "the notation ``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``"
msgstr ""

#: ../../reference/compound_stmts.rst:761
msgid "the notation ``!RULE`` is shorthand for a negative lookahead assertion"
msgstr ""

#: ../../reference/compound_stmts.rst:764
msgid "The top-level syntax for ``patterns`` is:"
msgstr ""

#: ../../reference/compound_stmts.rst:778
msgid ""
"The descriptions below will include a description \"in simple terms\" of "
"what a pattern does for illustration purposes (credits to Raymond Hettinger "
"for a document that inspired most of the descriptions). Note that these "
"descriptions are purely for illustration purposes and **may not** reflect "
"the underlying implementation.  Furthermore, they do not cover all valid "
"forms."
msgstr ""

#: ../../reference/compound_stmts.rst:788
msgid "OR Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:790
msgid ""
"An OR pattern is two or more patterns separated by vertical bars ``|``.  "
"Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:796
msgid ""
"Only the final subpattern may be :ref:`irrefutable <irrefutable_case>`, and "
"each subpattern must bind the same set of names to avoid ambiguity."
msgstr ""

#: ../../reference/compound_stmts.rst:799
msgid ""
"An OR pattern matches each of its subpatterns in turn to the subject value, "
"until one succeeds.  The OR pattern is then considered successful.  "
"Otherwise, if none of the subpatterns succeed, the OR pattern fails."
msgstr ""

#: ../../reference/compound_stmts.rst:803
msgid ""
"In simple terms, ``P1 | P2 | ...`` will try to match ``P1``, if it fails it "
"will try to match ``P2``, succeeding immediately if any succeeds, failing "
"otherwise."
msgstr ""

#: ../../reference/compound_stmts.rst:809
msgid "AS Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:811
msgid ""
"An AS pattern matches an OR pattern on the left of the :keyword:`as` keyword "
"against a subject.  Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:817
msgid ""
"If the OR pattern fails, the AS pattern fails.  Otherwise, the AS pattern "
"binds the subject to the name on the right of the as keyword and succeeds. "
"``capture_pattern`` cannot be a a ``_``."
msgstr ""

#: ../../reference/compound_stmts.rst:821
msgid ""
"In simple terms ``P as NAME`` will match with ``P``, and on success it will "
"set ``NAME = <subject>``."
msgstr ""

#: ../../reference/compound_stmts.rst:828
msgid "Literal Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:830
msgid ""
"A literal pattern corresponds to most :ref:`literals <literals>` in Python.  "
"Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:843
msgid ""
"The rule ``strings`` and the token ``NUMBER`` are defined in the :doc:"
"`standard Python grammar <./grammar>`.  Triple-quoted strings are "
"supported.  Raw strings and byte strings are supported.  :ref:`f-strings` "
"are not supported."
msgstr ""

#: ../../reference/compound_stmts.rst:848
msgid ""
"The forms ``signed_number '+' NUMBER`` and ``signed_number '-' NUMBER`` are "
"for expressing :ref:`complex numbers <imaginary>`; they require a real "
"number on the left and an imaginary number on the right. E.g. ``3 + 4j``."
msgstr ""

#: ../../reference/compound_stmts.rst:852
msgid ""
"In simple terms, ``LITERAL`` will succeed only if ``<subject> == LITERAL``. "
"For the singletons ``None``, ``True`` and ``False``, the :keyword:`is` "
"operator is used."
msgstr ""

#: ../../reference/compound_stmts.rst:858
msgid "Capture Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:860
msgid "A capture pattern binds the subject value to a name. Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:866
msgid ""
"A single underscore ``_`` is not a capture pattern (this is what ``!'_'`` "
"expresses). It is instead treated as a :token:`~python-grammar:"
"wildcard_pattern`."
msgstr ""

#: ../../reference/compound_stmts.rst:870
msgid ""
"In a given pattern, a given name can only be bound once.  E.g. ``case x, "
"x: ...`` is invalid while ``case [x] | x: ...`` is allowed."
msgstr ""

#: ../../reference/compound_stmts.rst:873
msgid ""
"Capture patterns always succeed.  The binding follows scoping rules "
"established by the assignment expression operator in :pep:`572`; the name "
"becomes a local variable in the closest containing function scope unless "
"there's an applicable :keyword:`global` or :keyword:`nonlocal` statement."
msgstr ""

#: ../../reference/compound_stmts.rst:878
msgid ""
"In simple terms ``NAME`` will always succeed and it will set ``NAME = "
"<subject>``."
msgstr ""

#: ../../reference/compound_stmts.rst:883
msgid "Wildcard Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:885
msgid ""
"A wildcard pattern always succeeds (matches anything) and binds no name.  "
"Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:891
msgid ""
"``_`` is a :ref:`soft keyword <soft-keywords>` within any pattern, but only "
"within patterns.  It is an identifier, as usual, even within ``match`` "
"subject expressions, ``guard``\\ s, and ``case`` blocks."
msgstr ""

#: ../../reference/compound_stmts.rst:895
msgid "In simple terms, ``_`` will always succeed."
msgstr ""

#: ../../reference/compound_stmts.rst:900
msgid "Value Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:902
msgid "A value pattern represents a named value in Python. Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:910
msgid ""
"The dotted name in the pattern is looked up using standard Python :ref:`name "
"resolution rules <resolve_names>`.  The pattern succeeds if the value found "
"compares equal to the subject value (using the ``==`` equality operator)."
msgstr ""

#: ../../reference/compound_stmts.rst:915
msgid ""
"In simple terms ``NAME1.NAME2`` will succeed only if ``<subject> == NAME1."
"NAME2``"
msgstr ""

#: ../../reference/compound_stmts.rst:919
msgid ""
"If the same value occurs multiple times in the same match statement, the "
"interpreter may cache the first value found and reuse it rather than repeat "
"the same lookup.  This cache is strictly tied to a given execution of a "
"given match statement."
msgstr ""

#: ../../reference/compound_stmts.rst:927
msgid "Group Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:929
msgid ""
"A group pattern allows users to add parentheses around patterns to emphasize "
"the intended grouping.  Otherwise, it has no additional syntax. Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:936
msgid "In simple terms ``(P)`` has the same effect as ``P``."
msgstr ""

#: ../../reference/compound_stmts.rst:941
msgid "Sequence Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:943
msgid ""
"A sequence pattern contains several subpatterns to be matched against "
"sequence elements. The syntax is similar to the unpacking of a list or tuple."
msgstr ""

#: ../../reference/compound_stmts.rst:954
msgid ""
"There is no difference if parentheses  or square brackets are used for "
"sequence patterns (i.e. ``(...)`` vs ``[...]`` )."
msgstr ""

#: ../../reference/compound_stmts.rst:958
msgid ""
"A single pattern enclosed in parentheses without a trailing comma (e.g. ``(3 "
"| 4)``) is a :ref:`group pattern <group-patterns>`. While a single pattern "
"enclosed in square brackets (e.g. ``[3 | 4]``) is still a sequence pattern."
msgstr ""

#: ../../reference/compound_stmts.rst:963
msgid ""
"At most one star subpattern may be in a sequence pattern.  The star "
"subpattern may occur in any position. If no star subpattern is present, the "
"sequence pattern is a fixed-length sequence pattern; otherwise it is a "
"variable-length sequence pattern."
msgstr ""

#: ../../reference/compound_stmts.rst:968
msgid ""
"The following is the logical flow for matching a sequence pattern against a "
"subject value:"
msgstr ""

#: ../../reference/compound_stmts.rst:971
msgid ""
"If the subject value is not a sequence [#]_, the sequence pattern fails."
msgstr ""

#: ../../reference/compound_stmts.rst:974
msgid ""
"If the subject value is an instance of ``str``, ``bytes`` or ``bytearray`` "
"the sequence pattern fails."
msgstr ""

#: ../../reference/compound_stmts.rst:977
msgid ""
"The subsequent steps depend on whether the sequence pattern is fixed or "
"variable-length."
msgstr ""

#: ../../reference/compound_stmts.rst:980
msgid "If the sequence pattern is fixed-length:"
msgstr ""

#: ../../reference/compound_stmts.rst:982
msgid ""
"If the length of the subject sequence is not equal to the number of "
"subpatterns, the sequence pattern fails"
msgstr ""

#: ../../reference/compound_stmts.rst:985
msgid ""
"Subpatterns in the sequence pattern are matched to their corresponding items "
"in the subject sequence from left to right.  Matching stops as soon as a "
"subpattern fails.  If all subpatterns succeed in matching their "
"corresponding item, the sequence pattern succeeds."
msgstr ""

#: ../../reference/compound_stmts.rst:990
msgid "Otherwise, if the sequence pattern is variable-length:"
msgstr ""

#: ../../reference/compound_stmts.rst:992
msgid ""
"If the length of the subject sequence is less than the number of non-star "
"subpatterns, the sequence pattern fails."
msgstr ""

#: ../../reference/compound_stmts.rst:995
msgid ""
"The leading non-star subpatterns are matched to their corresponding items as "
"for fixed-length sequences."
msgstr ""

#: ../../reference/compound_stmts.rst:998
msgid ""
"If the previous step succeeds, the star subpattern matches a list formed of "
"the remaining subject items, excluding the remaining items corresponding to "
"non-star subpatterns following the star subpattern."
msgstr ""

#: ../../reference/compound_stmts.rst:1002
msgid ""
"Remaining non-star subpatterns are matched to their corresponding subject "
"items, as for a fixed-length sequence."
msgstr ""

#: ../../reference/compound_stmts.rst:1005
msgid ""
"The length of the subject sequence is obtained via :func:`len` (i.e. via "
"the :meth:`__len__` protocol).  This length may be cached by the interpreter "
"in a similar manner as :ref:`value patterns <value-patterns>`."
msgstr ""

#: ../../reference/compound_stmts.rst:1011
msgid ""
"In simple terms ``[P1, P2, P3,`` ... ``, P<N>]`` matches only if all the "
"following happens:"
msgstr ""

#: ../../reference/compound_stmts.rst:1014
msgid "check ``<subject>`` is a sequence"
msgstr ""

#: ../../reference/compound_stmts.rst:1015
msgid "``len(subject) == <N>``"
msgstr ""

#: ../../reference/compound_stmts.rst:1016
msgid ""
"``P1`` matches ``<subject>[0]`` (note that this match can also bind names)"
msgstr ""

#: ../../reference/compound_stmts.rst:1017
msgid ""
"``P2`` matches ``<subject>[1]`` (note that this match can also bind names)"
msgstr ""

#: ../../reference/compound_stmts.rst:1018
msgid "... and so on for the corresponding pattern/element."
msgstr ""

#: ../../reference/compound_stmts.rst:1023
msgid "Mapping Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:1025
msgid ""
"A mapping pattern contains one or more key-value patterns.  The syntax is "
"similar to the construction of a dictionary. Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:1036
msgid ""
"At most one double star pattern may be in a mapping pattern.  The double "
"star pattern must be the last subpattern in the mapping pattern."
msgstr ""

#: ../../reference/compound_stmts.rst:1039
msgid ""
"Duplicate keys in mapping patterns are disallowed. Duplicate literal keys "
"will raise a :exc:`SyntaxError`. Two keys that otherwise have the same value "
"will raise a :exc:`ValueError` at runtime."
msgstr ""

#: ../../reference/compound_stmts.rst:1043
msgid ""
"The following is the logical flow for matching a mapping pattern against a "
"subject value:"
msgstr ""

#: ../../reference/compound_stmts.rst:1046
msgid "If the subject value is not a mapping [#]_,the mapping pattern fails."
msgstr ""

#: ../../reference/compound_stmts.rst:1048
msgid ""
"If every key given in the mapping pattern is present in the subject mapping, "
"and the pattern for each key matches the corresponding item of the subject "
"mapping, the mapping pattern succeeds."
msgstr ""

#: ../../reference/compound_stmts.rst:1052
msgid ""
"If duplicate keys are detected in the mapping pattern, the pattern is "
"considered invalid. A :exc:`SyntaxError` is raised for duplicate literal "
"values; or a :exc:`ValueError` for named keys of the same value."
msgstr ""

#: ../../reference/compound_stmts.rst:1056
msgid ""
"Key-value pairs are matched using the two-argument form of the mapping "
"subject's ``get()`` method.  Matched key-value pairs must already be present "
"in the mapping, and not created on-the-fly via :meth:`__missing__` or :meth:"
"`__getitem__`."
msgstr ""

#: ../../reference/compound_stmts.rst:1061
msgid ""
"In simple terms ``{KEY1: P1, KEY2: P2, ... }`` matches only if all the "
"following happens:"
msgstr ""

#: ../../reference/compound_stmts.rst:1064
msgid "check ``<subject>`` is a mapping"
msgstr ""

#: ../../reference/compound_stmts.rst:1065
msgid "``KEY1 in <subject>``"
msgstr ""

#: ../../reference/compound_stmts.rst:1066
msgid "``P1`` matches ``<subject>[KEY1]``"
msgstr ""

#: ../../reference/compound_stmts.rst:1067
msgid "... and so on for the corresponding KEY/pattern pair."
msgstr ""

#: ../../reference/compound_stmts.rst:1073
msgid "Class Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:1075
msgid ""
"A class pattern represents a class and its positional and keyword arguments "
"(if any).  Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:1086
msgid "The same keyword should not be repeated in class patterns."
msgstr ""

#: ../../reference/compound_stmts.rst:1088
msgid ""
"The following is the logical flow for matching a class pattern against a "
"subject value:"
msgstr ""

#: ../../reference/compound_stmts.rst:1091
msgid ""
"If ``name_or_attr`` is not an instance of the builtin :class:`type` , raise :"
"exc:`TypeError`."
msgstr ""

#: ../../reference/compound_stmts.rst:1094
msgid ""
"If the subject value is not an instance of ``name_or_attr`` (tested via :"
"func:`isinstance`), the class pattern fails."
msgstr ""

#: ../../reference/compound_stmts.rst:1097
msgid ""
"If no pattern arguments are present, the pattern succeeds.  Otherwise, the "
"subsequent steps depend on whether keyword or positional argument patterns "
"are present."
msgstr ""

#: ../../reference/compound_stmts.rst:1101
msgid ""
"For a number of built-in types (specified below), a single positional "
"subpattern is accepted which will match the entire subject; for these types "
"keyword patterns also work as for other types."
msgstr ""

#: ../../reference/compound_stmts.rst:1105
msgid ""
"If only keyword patterns are present, they are processed as follows, one by "
"one:"
msgstr ""

#: ../../reference/compound_stmts.rst:1108
msgid "I. The keyword is looked up as an attribute on the subject."
msgstr ""

#: ../../reference/compound_stmts.rst:1110
msgid ""
"If this raises an exception other than :exc:`AttributeError`, the exception "
"bubbles up."
msgstr ""

#: ../../reference/compound_stmts.rst:1113
msgid "If this raises :exc:`AttributeError`, the class pattern has failed."
msgstr ""

#: ../../reference/compound_stmts.rst:1115
msgid ""
"Else, the subpattern associated with the keyword pattern is matched against "
"the subject's attribute value.  If this fails, the class pattern fails; if "
"this succeeds, the match proceeds to the next keyword."
msgstr ""

#: ../../reference/compound_stmts.rst:1120
msgid "II. If all keyword patterns succeed, the class pattern succeeds."
msgstr ""

#: ../../reference/compound_stmts.rst:1122
msgid ""
"If any positional patterns are present, they are converted to keyword "
"patterns using the :data:`~object.__match_args__` attribute on the class "
"``name_or_attr`` before matching:"
msgstr ""

#: ../../reference/compound_stmts.rst:1126
msgid ""
"I. The equivalent of ``getattr(cls, \"__match_args__\", ())`` is called."
msgstr ""

#: ../../reference/compound_stmts.rst:1128
msgid "If this raises an exception, the exception bubbles up."
msgstr ""

#: ../../reference/compound_stmts.rst:1130
msgid ""
"If the returned value is not a tuple, the conversion fails and :exc:"
"`TypeError` is raised."
msgstr ""

#: ../../reference/compound_stmts.rst:1133
msgid ""
"If there are more positional patterns than ``len(cls.__match_args__)``, :exc:"
"`TypeError` is raised."
msgstr ""

#: ../../reference/compound_stmts.rst:1136
msgid ""
"Otherwise, positional pattern ``i`` is converted to a keyword pattern using "
"``__match_args__[i]`` as the keyword.  ``__match_args__[i]`` must be a "
"string; if not :exc:`TypeError` is raised."
msgstr ""

#: ../../reference/compound_stmts.rst:1140
msgid "If there are duplicate keywords, :exc:`TypeError` is raised."
msgstr ""

#: ../../reference/compound_stmts.rst:1142
msgid ":ref:`class-pattern-matching`"
msgstr ""

#: ../../reference/compound_stmts.rst:1145
msgid ""
"II. Once all positional patterns have been converted to keyword patterns,"
msgstr ""

#: ../../reference/compound_stmts.rst:1145
msgid "the match proceeds as if there were only keyword patterns."
msgstr ""

#: ../../reference/compound_stmts.rst:1147
msgid ""
"For the following built-in types the handling of positional subpatterns is "
"different:"
msgstr ""

#: ../../reference/compound_stmts.rst:1150
msgid ":class:`bool`"
msgstr ":class:`bool`"

#: ../../reference/compound_stmts.rst:1151
msgid ":class:`bytearray`"
msgstr ""

#: ../../reference/compound_stmts.rst:1152
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../reference/compound_stmts.rst:1153
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../../reference/compound_stmts.rst:1154
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../reference/compound_stmts.rst:1155
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../../reference/compound_stmts.rst:1156
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../reference/compound_stmts.rst:1157
#: ../../reference/compound_stmts.rst:1608
msgid ":class:`list`"
msgstr ":class:`list`"

#: ../../reference/compound_stmts.rst:1158
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../../reference/compound_stmts.rst:1159
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../reference/compound_stmts.rst:1160
#: ../../reference/compound_stmts.rst:1611
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../../reference/compound_stmts.rst:1162
msgid ""
"These classes accept a single positional argument, and the pattern there is "
"matched against the whole object rather than an attribute. For example "
"``int(0|1)`` matches the value ``0``, but not the value ``0.0``."
msgstr ""

#: ../../reference/compound_stmts.rst:1166
msgid ""
"In simple terms ``CLS(P1, attr=P2)`` matches only if the following happens:"
msgstr ""

#: ../../reference/compound_stmts.rst:1168
msgid "``isinstance(<subject>, CLS)``"
msgstr ""

#: ../../reference/compound_stmts.rst:1169
msgid "convert ``P1`` to a keyword pattern using ``CLS.__match_args__``"
msgstr ""

#: ../../reference/compound_stmts.rst:1171
msgid "For each keyword argument ``attr=P2``:"
msgstr ""

#: ../../reference/compound_stmts.rst:1171
msgid "``hasattr(<subject>, \"attr\")``"
msgstr ""

#: ../../reference/compound_stmts.rst:1172
msgid "``P2`` matches ``<subject>.attr``"
msgstr ""

#: ../../reference/compound_stmts.rst:1173
msgid "... and so on for the corresponding keyword argument/pattern pair."
msgstr ""

#: ../../reference/compound_stmts.rst:1188
msgid "Function definitions"
msgstr "関数定義"

#: ../../reference/compound_stmts.rst:1203
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""
"関数定義は、ユーザ定義関数オブジェクトを定義します (:ref:`types` 節参照):"

#: ../../reference/compound_stmts.rst:1222
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"関数定義は実行可能な文です。関数定義を実行すると、現在のローカルな名前空間内"
"で関数名を関数オブジェクト (関数の実行可能コードをくるむラッパー) に束縛しま"
"す。この関数オブジェクトには、関数が呼び出された際に使われるグローバルな名前"
"空間として、現在のグローバルな名前空間への参照が入っています。"

#: ../../reference/compound_stmts.rst:1228
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""
"関数定義は関数本体を実行しません; 関数本体は関数が呼び出された時にのみ実行さ"
"れます。 [#]_"

#: ../../reference/compound_stmts.rst:1234
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"関数定義は一つ以上の :term:`デコレータ <decorator>` 式でラップできます。デコ"
"レータ式は関数を定義するとき、関数定義の入っているスコープで評価されます。そ"
"の結果は、関数オブジェクトを唯一の引数にとる呼び出し可能オブジェクトでなけれ"
"ばなりません。関数オブジェクトの代わりに、返された値が関数名に束縛されます。"
"複数のデコレータはネストして適用されます。例えば、以下のようなコード::"

#: ../../reference/compound_stmts.rst:1245
#: ../../reference/compound_stmts.rst:1422
msgid "is roughly equivalent to ::"
msgstr "は、だいたい次と等価です ::"

#: ../../reference/compound_stmts.rst:1250
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr ""
"ただし、前者のコードでは元々の関数を ``func`` という名前へ一時的に束縛するこ"
"とはない、というところを除きます。"

#: ../../reference/compound_stmts.rst:1252
msgid ""
"Functions may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""

#: ../../reference/compound_stmts.rst:1262
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""
"1 つ以上の :term:`仮引数 <parameter>` が *parameter* ``=`` *expression* の形"
"を取っているとき、関数は \"デフォルト引数値\" を持つと言います。デフォルト値"
"を持つ仮引数では、呼び出し時にそれに対応する :term:`実引数 <argument>` は省略"
"でき、その場合は仮引数のデフォルト値が使われます。ある引数がデフォルト値を"
"持っている場合、それ以降 \"``*``\" が出てくるまでの引数は全てデフォルト値を"
"持っていなければなりません -- これは文法定義では表現されていない構文的制限で"
"す。"

#: ../../reference/compound_stmts.rst:1270
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter value is a mutable object, such as a "
"list or a dictionary: if the function modifies the object (e.g. by appending "
"an item to a list), the default parameter value is in effect modified.  This "
"is generally not what was intended.  A way around this is to use ``None`` as "
"the default, and explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**デフォルト引数値は関数定義が実行されるときに左から右へ評価されます。** これ"
"は、デフォルト引数の式は関数が定義されるときにただ一度だけ評価され、同じ \"計"
"算済みの\" 値が呼び出しのたびに使用されることを意味します。この仕様を理解して"
"おくことは特に、デフォルト引数値がリストや辞書のようなミュータブルなオブジェ"
"クトであるときに重要です: 関数がこのオブジェクトを変更 (例えばリストに要素を"
"追加) すると、このデフォルト引数値が変更の影響を受けてしまします。一般には、"
"これは意図しない動作です。このような動作を避けるには、デフォルト値として "
"``None`` を使い、この値を関数本体の中で明示的にテストします。例えば以下のよう"
"にします::"

#: ../../reference/compound_stmts.rst:1291
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from positional arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed by keyword arguments.  Parameters before "
"\"``/``\" are positional-only parameters and may only be passed by "
"positional arguments."
msgstr ""
"関数呼び出しの意味付けに関する詳細は、 :ref:`calls` 節で述べられています。\n"
"関数呼び出しを行うと、パラメタリストに記述された全てのパラメタに、位置引数、"
"キーワード引数、デフォルト値のいずれかから値が代入されます。\n"
"\"``*identifier``\" 形式が存在すれば、余ったすべての位置引数を受け取ったタプ"
"ルに初期化されます。\n"
"このデフォルト値は空のタプルです。\n"
"\"``**identifier``\" 形式が存在すれば、余ったすべてのキーワード引数を受け取っ"
"た順序付きのマッピングオブジェクトに初期化されます。\n"
"このデフォルト値は同じ型の空のマッピングオブジェクトです。\n"
"\"``*``\" や \"``*identifier``\" の後のパラメタはキーワード専用パラメータで、"
"キーワード引数によってのみ渡されます。\n"
"\"``/``\" の前のパラメタは位置専用パラメータで、位置引数によってのみ渡されま"
"す。"

#: ../../reference/compound_stmts.rst:1303
msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-only "
"parameters. See :pep:`570` for details."
msgstr ""

#: ../../reference/compound_stmts.rst:1312
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``.  "
"Functions may have \"return\" annotation of the form \"``-> expression``\" "
"after the parameter list.  These annotations can be any valid Python "
"expression.  The presence of annotations does not change the semantics of a "
"function.  The annotation values are available as values of a dictionary "
"keyed by the parameters' names in the :attr:`__annotations__` attribute of "
"the function object.  If the ``annotations`` import from :mod:`__future__` "
"is used, annotations are preserved as strings at runtime which enables "
"postponed evaluation.  Otherwise, they are evaluated when the function "
"definition is executed.  In this case annotations may be evaluated in a "
"different order than they appear in the source code."
msgstr ""
"引数には、引数名に続けて \"``: expression``\" 形式の :term:`アノテーション "
"<function annotation>` を付けられます。\n"
"``*identifier`` や ``**identifier`` の形式でも、すべての引数にはアノテーショ"
"ンをつけられます。\n"
"関数には、引数リストの後に \"``-> expression``\" 形式の \"return\" アノテー"
"ションをつけられます。これらのアノテーションは、任意の有効な Python の式が使"
"えます。\n"
"アノテーションがあっても、関数の意味論は変わりません。\n"
"アノテーションの値は、関数オブジェクトの :attr:`__annotations__` 属性の、引数"
"名をキーとする値として得られます。\n"
":mod:`__future__` の ``annotations`` インポートを使った場合は、アノテーション"
"は実行時には文字列として保持され、これにより評価の遅延が可能になっていま"
"す。\n"
"そうでない場合は、アノテーションは関数定義が実行されたときに評価されます。\n"
"このケースでは、アノテーションはソースコードに現れたのとは違う順序で評価され"
"ることがあります。"

#: ../../reference/compound_stmts.rst:1327
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"式を即時に使用するために、無名関数 (名前に束縛されていない関数) を作成するこ"
"ともできます。\n"
"これは :ref:`lambda` の節で解説されているラムダ式を使います。\n"
"ラムダ式は簡略化された関数定義の簡略表現に過ぎないことに注意してください;  "
"\":keyword:`def`\" 文で定義された関数もラムダ式で作成された関数のように、引数"
"として渡せたり、他の名前に割り当てることができます。\n"
"複数の式とアノテーションが実行できるので、 \":keyword:`!def`\" 形式の方がより"
"強力です。"

#: ../../reference/compound_stmts.rst:1335
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""
"**プログラマへのメモ:** 関数は第一級オブジェクトです。関数定義内で実行された "
"\"``def``\" 文は、返り値や引数として渡せるローカル関数を定義します。ネストし"
"た関数内で使われる自由変数は、 def を含んでいる関数のローカル変数にアクセスで"
"きます。詳細は :ref:`naming` 節を参照してください。"

#: ../../reference/compound_stmts.rst:1344
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - Function Annotations"

#: ../../reference/compound_stmts.rst:1344
msgid "The original specification for function annotations."
msgstr "関数アノテーションの元の仕様書。"

#: ../../reference/compound_stmts.rst:1347
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - 型ヒント"

#: ../../reference/compound_stmts.rst:1347
msgid "Definition of a standard meaning for annotations: type hints."
msgstr "アノテーションの標準的な意味付けである型ヒントの定義。"

#: ../../reference/compound_stmts.rst:1351
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Syntax for Variable Annotations"

#: ../../reference/compound_stmts.rst:1350
msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables"
msgstr "クラス変数とインスタンス変数を含む変数に型ヒントが宣言できる機能"

#: ../../reference/compound_stmts.rst:1354
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - アノテーションの遅延評価"

#: ../../reference/compound_stmts.rst:1354
msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr ""
"実行時にアノテーションを貪欲評価するのではなく文字列形式で保持することによ"
"る、アノテーションにおける前方参照のサポート"

#: ../../reference/compound_stmts.rst:1361
msgid "Class definitions"
msgstr "クラス定義"

#: ../../reference/compound_stmts.rst:1376
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr "クラス定義は、クラスオブジェクトを定義します (:ref:`types` 節参照):"

#: ../../reference/compound_stmts.rst:1383
msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"クラス定義は実行可能な文です。継承リストは通常、基底クラスリストを与えます "
"(より高度な使い方は、 :ref:`metaclasses` を参照してください)。ですから、リス"
"トのそれぞれの要素の評価はサブクラス化しても良いクラスであるべきです。継承リ"
"ストのないクラスは、デフォルトで、基底クラス :class:`object` を継承するので::"

#: ../../reference/compound_stmts.rst:1392
msgid "is equivalent to ::"
msgstr "は、以下と同等です ::"

#: ../../reference/compound_stmts.rst:1397
msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""
"次にクラスのスイートが、新たな実行フレーム (:ref:`naming` を参照してくださ"
"い) 内で、新たに作られたローカル名前空間と元々のグローバル名前空間を使って実"
"行されます (通常、このスイートには主に関数定義が含まれます)。クラスのスイート"
"が実行し終えると、実行フレームは破棄されますが、ローカルな名前空間は保存され"
"ます。[#]_ 次に、継承リストを基底クラスに、保存されたローカル名前空間を属性値"
"辞書に、それぞれ使ってクラスオブジェクトが生成されます。最後に、もとのローカ"
"ル名前空間において、クラス名がこのクラスオブジェクトに束縛されます。"

#: ../../reference/compound_stmts.rst:1406
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's ``__dict__``.  Note that this is reliable only right after "
"the class is created and only for classes that were defined using the "
"definition syntax."
msgstr ""
"クラス本体で属性が定義された順序は新しいクラスの ``__dict__`` に保持されま"
"す。\n"
"この性質が期待できるのは、クラスが作られた直後かつ定義構文を使って定義された"
"クラスであるときのみです。"

#: ../../reference/compound_stmts.rst:1411
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""
"クラス作成は、 :ref:`メタクラス <metaclasses>` を利用して大幅にカスタマイズで"
"きます。"

#: ../../reference/compound_stmts.rst:1416
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr ""
"関数をデコレートするのと同じように、クラスもデコレートすることが出来ます、 ::"

#: ../../reference/compound_stmts.rst:1427
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr ""
"デコレータ式の評価規則は関数デコレータと同じです。結果はクラス名に束縛されま"
"す。"

#: ../../reference/compound_stmts.rst:1430
msgid ""
"Classes may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""

#: ../../reference/compound_stmts.rst:1435
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""
"**プログラマのための注釈:** クラス定義内で定義された変数はクラス属性であり、"
"全てのインスタンス間で共有されます。インスタンス属性は、メソッドの中で "
"``self.name = value`` とすることで設定できます。クラス属性もインスタンス属性"
"も \"``self.name``\" 表記でアクセスでき、この表記でアクセスしたとき、インスタ"
"ンス属性は同名のクラス属性を隠蔽します。クラス属性は、インスタンス属性のデ"
"フォルト値として使えますが、そこにミュータブルな値を使うと予期せぬ結果につな"
"がります。 :ref:`記述子 <descriptors>` を使うと、詳細な実装が異なるインスタン"
"ス変数を作成できます。"

#: ../../reference/compound_stmts.rst:1450
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaclasses in Python 3000"

#: ../../reference/compound_stmts.rst:1448
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr ""
"メタクラスの宣言を現在の文法と、メタクラス付きのクラスがどのように構築される"
"かの意味論を変更した提案"

#: ../../reference/compound_stmts.rst:1453
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - クラスデコレータ"

#: ../../reference/compound_stmts.rst:1453
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr ""
"クラスデコレータを追加した提案。\n"
"関数デコレータとメソッドデコレータは :pep:`318` で導入されました。"

#: ../../reference/compound_stmts.rst:1460
msgid "Coroutines"
msgstr "コルーチン"

#: ../../reference/compound_stmts.rst:1468
msgid "Coroutine function definition"
msgstr "コルーチン関数定義"

#: ../../reference/compound_stmts.rst:1478
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`). :keyword:`await` expressions, :keyword:`async for` "
"and :keyword:`async with` can only be used in the body of a coroutine "
"function."
msgstr ""
"Python で実行しているコルーチンは多くの時点で一時停止と再開ができます (:term:"
"`coroutine` を参照)。\n"
":keyword:`await` 式である :keyword:`async for` と :keyword:`async with` はコ"
"ルーチン関数の本体でしか使えません。"

#: ../../reference/compound_stmts.rst:1482
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
" ``await`` や ``async`` キーワードがなくても、``async def`` 構文で定義された"
"関数は常にコルーチン関数です。"

#: ../../reference/compound_stmts.rst:1485
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr ""
"コルーチン関数の本体の中で ``yield from`` 式を使用すると :exc:`SyntaxError` "
"になります。"

#: ../../reference/compound_stmts.rst:1488
msgid "An example of a coroutine function::"
msgstr "コルーチン関数の例::"

#: ../../reference/compound_stmts.rst:1494
msgid ""
"``await`` and ``async`` are now keywords; previously they were only treated "
"as such inside the body of a coroutine function."
msgstr ""

#: ../../reference/compound_stmts.rst:1502
msgid "The :keyword:`!async for` statement"
msgstr ":keyword:`!async for` 文"

#: ../../reference/compound_stmts.rst:1507
msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
":term:`asynchronous iterable` は、その ``__anext__`` メソッドで非同期なコード"
"を実行可能な、:term:`asynchronous iterator` を直接返す ``__aiter__`` メソッド"
"を提供しています。　"

#: ../../reference/compound_stmts.rst:1511
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterables."
msgstr ""
"``async for`` 文によって非同期なイテラブルを簡単にイテレーションすることがで"
"きます。"

#: ../../reference/compound_stmts.rst:1521
msgid "Is semantically equivalent to::"
msgstr "は意味論的に以下と等価です::"

#: ../../reference/compound_stmts.rst:1537
msgid ""
"See also :meth:`~object.__aiter__` and :meth:`~object.__anext__` for details."
msgstr ""
"詳細は :meth:`~object.__aiter__` や :meth:`~object.__anext__` を参照してくだ"
"さい。"

#: ../../reference/compound_stmts.rst:1539
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr ""
"コルーチン関数の本体の外で ``async for`` 文を使用すると :exc:`SyntaxError` に"
"なります。"

#: ../../reference/compound_stmts.rst:1547
msgid "The :keyword:`!async with` statement"
msgstr ":keyword:`!async with` 文"

#: ../../reference/compound_stmts.rst:1552
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is "
"able to suspend execution in its *enter* and *exit* methods."
msgstr ""
":term:`asynchronous context manager` は、 *enter* メソッドと *exit* メソッド"
"内部で実行を一時停止できる :term:`context manager` です。"

#: ../../reference/compound_stmts.rst:1579
msgid ""
"See also :meth:`~object.__aenter__` and :meth:`~object.__aexit__` for "
"details."
msgstr ""
"詳細は :meth:`~object.__aenter__` や :meth:`~object.__aexit__` を参照してくだ"
"さい。"

#: ../../reference/compound_stmts.rst:1581
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr ""
"コルーチン関数の本体の外で ``async with`` 文を使用すると :exc:`SyntaxError` "
"になります。"

#: ../../reference/compound_stmts.rst:1587
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - async 構文および await 構文付きのコルーチン"

#: ../../reference/compound_stmts.rst:1587
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and "
"added supporting syntax."
msgstr ""
"コルーチンを Python のまともな独り立ちした概念にし、サポートする構文を追加し"
"た提案。"

#: ../../reference/compound_stmts.rst:1592
msgid "Footnotes"
msgstr "脚注"

#: ../../reference/compound_stmts.rst:1593
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""
"例外は、別の例外を送出するような :keyword:`finally` 節が無い場合にのみ呼び出"
"しスタックへ伝わります。新しい例外によって、古い例外は失われます。"

#: ../../reference/compound_stmts.rst:1597
msgid "In pattern matching, a sequence is defined as one of the following:"
msgstr ""

#: ../../reference/compound_stmts.rst:1599
msgid "a class that inherits from :class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence` を継承したクラス。"

#: ../../reference/compound_stmts.rst:1600
msgid ""
"a Python class that has been registered as :class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence` として登録されたPythonクラス。"

#: ../../reference/compound_stmts.rst:1601
msgid ""
"a builtin class that has its (CPython) :data:`Py_TPFLAGS_SEQUENCE` bit set"
msgstr ""

#: ../../reference/compound_stmts.rst:1602
#: ../../reference/compound_stmts.rst:1621
msgid "a class that inherits from any of the above"
msgstr ""

#: ../../reference/compound_stmts.rst:1604
msgid "The following standard library classes are sequences:"
msgstr ""

#: ../../reference/compound_stmts.rst:1606
msgid ":class:`array.array`"
msgstr ":class:`array.array`"

#: ../../reference/compound_stmts.rst:1607
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../../reference/compound_stmts.rst:1609
msgid ":class:`memoryview`"
msgstr ":class:`memoryview`"

#: ../../reference/compound_stmts.rst:1610
msgid ":class:`range`"
msgstr ":class:`range`"

#: ../../reference/compound_stmts.rst:1613
msgid ""
"Subject values of type ``str``, ``bytes``, and ``bytearray`` do not match "
"sequence patterns."
msgstr ""

#: ../../reference/compound_stmts.rst:1616
msgid "In pattern matching, a mapping is defined as one of the following:"
msgstr ""

#: ../../reference/compound_stmts.rst:1618
msgid "a class that inherits from :class:`collections.abc.Mapping`"
msgstr ""

#: ../../reference/compound_stmts.rst:1619
msgid ""
"a Python class that has been registered as :class:`collections.abc.Mapping`"
msgstr ""

#: ../../reference/compound_stmts.rst:1620
msgid ""
"a builtin class that has its (CPython) :data:`Py_TPFLAGS_MAPPING` bit set"
msgstr ""

#: ../../reference/compound_stmts.rst:1623
msgid ""
"The standard library classes :class:`dict` and :class:`types."
"MappingProxyType` are mappings."
msgstr ""

#: ../../reference/compound_stmts.rst:1626
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""
"関数の本体の最初の文として現われる文字列リテラルは、その関数の ``__doc__`` 属"
"性に変換され、その関数の :term:`ドキュメンテーション文字列 <docstring>` にな"
"ります。"

#: ../../reference/compound_stmts.rst:1630
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's :"
"term:`docstring`."
msgstr ""
"クラスの本体の最初の文として現われる文字列リテラルは、その名前空間の "
"``__doc__`` 要素となり、そのクラスの :term:`ドキュメンテーション文字列 "
"<docstring>` になります。"
