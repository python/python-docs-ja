# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-29 14:57+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "è¤‡åˆæ–‡ (compound statement)"

#: ../../reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"è¤‡åˆæ–‡ã«ã¯ã€ä»–ã®æ–‡ (ã®ã‚°ãƒ«ãƒ¼ãƒ—) ãŒå…¥ã‚Šã¾ã™; "
"è¤‡åˆæ–‡ã¯ã€ä¸­ã«å…¥ã£ã¦ã„ã‚‹ä»–ã®æ–‡ã®å®Ÿè¡Œã®åˆ¶å¾¡ã«ä½•ã‚‰ã‹ã®ã‚„ã‚Šæ–¹ã§å½±éŸ¿ã‚’åŠã¼ã—ã¾ã™ã€‚ä¸€èˆ¬çš„ã«ã¯ã€è¤‡åˆæ–‡ã¯è¤‡æ•°è¡Œã«ã¾ãŸãŒã£ã¦æ›¸ã‹ã‚Œã¾ã™ãŒã€å…¨éƒ¨ã®æ–‡ã‚’ä¸€è¡Œã«é€£ã­ãŸå˜ç´”ãªæ›¸ãæ–¹ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the "
":keyword:`with` statement allows the execution of initialization and "
"finalization code around a block of code.  Function and class definitions "
"are also syntactically compound statements."
msgstr ""
":keyword:`if` ã€ :keyword:`while` ã€ãŠã‚ˆã³ :keyword:`for` æ–‡ã¯ã€ä¼çµ±çš„ãªåˆ¶å¾¡ãƒ•ãƒ­ãƒ¼æ§‹æˆã‚’å®Ÿç¾ã—ã¾ã™ã€‚ "
":keyword:`try` ã¯ä¾‹å¤–å‡¦ç†ãŠã‚ˆã³/ã¾ãŸã¯ä¸€é€£ã®æ–‡ã«å¯¾ã™ã‚‹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚³ãƒ¼ãƒ‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚ãã‚Œã«å¯¾ã—ã¦ã€ :keyword:`with` "
"æ–‡ã¯ã‚³ãƒ¼ãƒ‰ã®ã‹ãŸã¾ã‚Šã®å‰å¾Œã§ã‚³ãƒ¼ãƒ‰ã®åˆæœŸåŒ–ã¨çµ‚äº†å‡¦ç†ã‚’å®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚é–¢æ•°ã¨ã‚¯ãƒ©ã‚¹å®šç¾©ã‚‚ã¾ãŸã€æ§‹æ–‡çš„ã«ã¯è¤‡åˆæ–‡ã§ã™ã€‚"

#: ../../reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be"
" clear to which :keyword:`if` clause a following :keyword:`else` clause "
"would belong::"
msgstr ""
"è¤‡åˆæ–‡ã¯ã€ä¸€ã¤ä»¥ä¸Šã® 'ç¯€ (clause)' ã‹ã‚‰ãªã‚Šã¾ã™ã€‚ç¯€ã¯ã€ãƒ˜ãƒƒãƒ€ã¨ 'ã‚¹ã‚¤ãƒ¼ãƒˆ (suite)' "
"ã‹ã‚‰ãªã‚Šã¾ã™ã€‚ä¸€ã¤ã®è¤‡åˆæ–‡ã‚’æˆã™å„ç¯€ã®ãƒ˜ãƒƒãƒ€ã¯ã€å…¨ã¦åŒã˜ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãƒ¬ãƒ™ãƒ«ã«ç½®ã‹ã‚Œã¾ã™ã€‚å„ç¯€ã®ãƒ˜ãƒƒãƒ€ã¯ä¸€æ„ã«è­˜åˆ¥ã™ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§å§‹ã¾ã‚Šã€ã‚³ãƒ­ãƒ³ã§çµ‚ã‚ã‚Šã¾ã™ã€‚ã‚¹ã‚¤ãƒ¼ãƒˆã¯ã€ç¯€ã«ã‚ˆã£ã¦åˆ¶å¾¡ã•ã‚Œã‚‹æ–‡ã®é›†ã¾ã‚Šã§ã™ã€‚ã‚¹ã‚¤ãƒ¼ãƒˆã¯ã€ãƒ˜ãƒƒãƒ€ãŒã‚ã‚‹è¡Œã®ã‚³ãƒ­ãƒ³ã®å¾Œã«ã‚»ãƒŸã‚³ãƒ­ãƒ³ã§åŒºåˆ‡ã£ã¦ç½®ã‹ã‚ŒãŸä¸€ã¤ä»¥ä¸Šã®å˜ç´”æ–‡ã€ã¾ãŸã¯ã€ãƒ˜ãƒƒãƒ€ã«ç¶šãè¡Œã§ä¸€ã¤å¤šãã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã•ã‚ŒãŸæ–‡ã®é›†ã¾ã‚Šã§ã™ã€‚å¾Œè€…ã®å½¢å¼ã®ã‚¹ã‚¤ãƒ¼ãƒˆã«é™ã‚Šã€ã•ã‚‰ã«è¤‡åˆæ–‡ã‚’ãƒã‚¹ãƒˆã§ãã¾ã™;"
" ä»¥ä¸‹ã®æ–‡ã¯ã€ :keyword:`else` ç¯€ãŒã©ã¡ã‚‰ã® :keyword:`if` ç¯€ã«å±ã™ã‚‹ã‹ãŒã¯ã£ãã‚Šã—ãªã„ãªã©ã®ç†ç”±ã‹ã‚‰ä¸æ­£ã«ãªã‚Šã¾ã™::"

#: ../../reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"ã¾ãŸã€ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä¸­ã§ã¯ã€ã‚»ãƒŸã‚³ãƒ­ãƒ³ã«ã‚ˆã‚‹çµåˆã¯ã‚³ãƒ­ãƒ³ã‚ˆã‚Šå¼·ã„ã§ã™ã€‚å¾“ã£ã¦ã€ä»¥ä¸‹ã®ä¾‹ã§ã¯ã€ :func:`print` "
"ã®å‘¼ã³å‡ºã—ã¯ã¯å…¨ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã‹ã€å…¨ãå®Ÿè¡Œã•ã‚Œãªã„ã‹ã®ã©ã¡ã‚‰ã‹ã§ã™::"

#: ../../reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "ã¾ã¨ã‚ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™:"

#: ../../reference/compound_stmts.rst:67
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested "
":keyword:`if` statements to be indented)."
msgstr ""
"ãªãŠã€æ–‡ã¯å¸¸ã« ``NEWLINE`` ã‹ã€ãã®å¾Œã« ``DEDENT`` "
"ãŒç¶šã„ãŸã‚‚ã®ã§çµ‚äº†ã—ã¾ã™ã€‚ã¾ãŸã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ç¶™ç¶šç¯€ã¯å¿…ãšã€æ–‡ã‚’é–‹å§‹ã§ããªã„äºˆç´„èªã§å§‹ã¾ã‚‹ã®ã§ã€æ›–æ˜§ã•ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚ (Python ã§ã¯ã€ "
"'ã¶ã‚‰ä¸‹ãŒã‚Š (dangling) :keyword:`else`' å•é¡Œã¯ã€ãƒã‚¹ãƒˆã•ã‚ŒãŸ :keyword:`if` "
"æ–‡ã‚’ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã•ã›ã‚‹ã“ã¨ã§è§£æ±ºã•ã‚Œã¾ã™)ã€‚"

#: ../../reference/compound_stmts.rst:73
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr "ä»¥ä¸‹ã®ç¯€ã«ãŠã‘ã‚‹æ–‡æ³•è¦å‰‡ã®è¨˜è¿°æ–¹å¼ã¯ã€æ˜ç¢ºã•ã®ãŸã‚ã«ã€å„ç¯€ã‚’åˆ¥ã€…ã®è¡Œã«æ›¸ãã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:82
msgid "The :keyword:`if` statement"
msgstr ":keyword:`if` æ–‡"

#: ../../reference/compound_stmts.rst:90
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ":keyword:`if` æ–‡ã¯ã€æ¡ä»¶åˆ†å²ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™:"

#: ../../reference/compound_stmts.rst:97
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
":keyword:`if` æ–‡ã¯ã€å¼ã‚’ä¸€ã¤ä¸€ã¤è©•ä¾¡ã—ã¦ã‚†ãã€çœŸã«ãªã‚‹ã¾ã§ç¶šã‘ã¦ã€çœŸã«ãªã£ãŸç¯€ã®ã‚¹ã‚¤ãƒ¼ãƒˆã ã‘ã‚’é¸æŠã—ã¾ã™ (çœŸ: true ã¨å½: "
"false ã®å®šç¾©ã«ã¤ã„ã¦ã¯ã€ :ref:`booleans` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„); æ¬¡ã«ã€é¸æŠã—ãŸã‚¹ã‚¤ãƒ¼ãƒˆã‚’å®Ÿè¡Œã—ã¾ã™ (ãã—ã¦ã€ "
":keyword:`if` æ–‡ã®ä»–ã®éƒ¨åˆ†ã¯ã€å®Ÿè¡Œã‚„è©•ä¾¡ã‚’ã•ã‚Œã¾ã›ã‚“)ã€‚å…¨ã¦ã®å¼ãŒå½ã«ãªã£ãŸå ´åˆã€ :keyword:`else` "
"ç¯€ãŒã‚ã‚Œã°ã€ãã®ã‚¹ã‚¤ãƒ¼ãƒˆãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:107
msgid "The :keyword:`while` statement"
msgstr ":keyword:`while` æ–‡"

#: ../../reference/compound_stmts.rst:116
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ":keyword:`while` æ–‡ã¯ã€å¼ã®å€¤ãŒçœŸã§ã‚ã‚‹é–“ã€å®Ÿè¡Œã‚’ç¹°ã‚Šè¿”ã™ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™:"

#: ../../reference/compound_stmts.rst:123
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested)"
" the suite of the :keyword:`else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
":keyword:`while` æ–‡ã¯å¼ã‚’ç¹°ã‚Šè¿”ã—çœŸå½è©•ä¾¡ã—ã€çœŸã§ã‚ã‚Œã°æœ€åˆã®ã‚¹ã‚¤ãƒ¼ãƒˆã‚’å®Ÿè¡Œã—ã¾ã™ã€‚å¼ãŒå½ã§ã‚ã‚Œã° "
"(æœ€åˆã‹ã‚‰å½ã«ãªã£ã¦ã„ã‚‹ã“ã¨ã‚‚ã‚ã‚Šãˆã¾ã™)ã€ :keyword:`else` ç¯€ãŒã‚ã‚‹å ´åˆã«ã¯ãã‚Œã‚’å®Ÿè¡Œã—ã€ãƒ«ãƒ¼ãƒ—ã‚’çµ‚äº†ã—ã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:132
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop"
" without executing the :keyword:`else` clause's suite.  A "
":keyword:`continue` statement executed in the first suite skips the rest of "
"the suite and goes back to testing the expression."
msgstr ""
"æœ€åˆã®ã‚¹ã‚¤ãƒ¼ãƒˆå†…ã§ :keyword:`break` æ–‡ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ã€ :keyword:`else` "
"ç¯€ã®ã‚¹ã‚¤ãƒ¼ãƒˆã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ãªããƒ«ãƒ¼ãƒ—ã‚’çµ‚äº†ã—ã¾ã™ã€‚ :keyword:`continue` "
"æ–‡ãŒæœ€åˆã®ã‚¹ã‚¤ãƒ¼ãƒˆå†…ã§å®Ÿè¡Œã•ã‚Œã‚‹ã¨ã€ã‚¹ã‚¤ãƒ¼ãƒˆå†…ã«ã‚ã‚‹æ®‹ã‚Šã®æ–‡ã®å®Ÿè¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ã€å¼ã®çœŸå½è©•ä¾¡ã«æˆ»ã‚Šã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:141
msgid "The :keyword:`for` statement"
msgstr ":keyword:`for` æ–‡"

#: ../../reference/compound_stmts.rst:155
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
":keyword:`for` æ–‡ã¯ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ (æ–‡å­—åˆ—ã€ã‚¿ãƒ—ãƒ«ã¾ãŸã¯ãƒªã‚¹ãƒˆ) ã‚„ã€ãã®ä»–ã®åå¾©å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (iterable object) "
"å†…ã®è¦ç´ ã«æ¸¡ã£ã¦åå¾©å‡¦ç†ã‚’è¡Œã†ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™:"

#: ../../reference/compound_stmts.rst:162
msgid ""
"The expression list is evaluated once; it should yield an iterable object.  "
"An iterator is created for the result of the ``expression_list``.  The suite"
" is then executed once for each item provided by the iterator, in the order "
"returned by the iterator.  Each item in turn is assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and then "
"the suite is executed.  When the items are exhausted (which is immediately "
"when the sequence is empty or an iterator raises a :exc:`StopIteration` "
"exception), the suite in the :keyword:`else` clause, if present, is "
"executed, and the loop terminates."
msgstr ""
"å¼ãƒªã‚¹ãƒˆã¯ä¸€åº¦ã ã‘è©•ä¾¡ã•ã‚Œã€ã“ã‚Œã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¸ãˆãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ ``expression_list`` "
"ã®çµæœã«å¯¾ã™ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚ãã®å¾Œã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒä¸ãˆã‚‹ãã‚Œãã‚Œã®è¦ç´ ã«å¯¾ã—ã¦ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã«è¿”ã•ã‚ŒãŸé †ã«ä¸€åº¦ã¥ã¤ã€ã‚¹ã‚¤ãƒ¼ãƒˆãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ãã‚Œãã‚Œã®è¦ç´ ã¯é€šå¸¸ã®ä»£å…¥è¦å‰‡ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆã«ä»£å…¥ã•ã‚Œã€ãã®å¾Œã‚¹ã‚¤ãƒ¼ãƒˆãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"
" (ä»£å…¥è¦å‰‡ã¯ :ref:`assignment` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚) å…¨ã¦ã®è¦ç´ ã‚’ä½¿ã„åˆ‡ã£ãŸã¨ã (ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒç©ºã§ã‚ã£ãŸã‚Šã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒ "
":exc:`StopIteration` ä¾‹å¤–ã‚’é€å‡ºã—ãŸãªã‚‰ã€å³åº§ã«)ã€ :keyword:`else` ç¯€ãŒã‚ã‚Œã°ãã‚ŒãŒå®Ÿè¡Œã•ã‚Œã€ãƒ«ãƒ¼ãƒ—ã¯çµ‚äº†ã—ã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:175
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop"
" without executing the :keyword:`else` clause's suite.  A "
":keyword:`continue` statement executed in the first suite skips the rest of "
"the suite and continues with the next item, or with the :keyword:`else` "
"clause if there is no next item."
msgstr ""
"æœ€åˆã®ã‚¹ã‚¤ãƒ¼ãƒˆå†…ã§ :keyword:`break` æ–‡ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ã€ :keyword:`else` "
"ç¯€ã®ã‚¹ã‚¤ãƒ¼ãƒˆã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ãªããƒ«ãƒ¼ãƒ—ã‚’çµ‚äº†ã—ã¾ã™ã€‚ :keyword:`continue` "
"æ–‡ãŒæœ€åˆã®ã‚¹ã‚¤ãƒ¼ãƒˆå†…ã§å®Ÿè¡Œã•ã‚Œã‚‹ã¨ã€ã‚¹ã‚¤ãƒ¼ãƒˆå†…ã«ã‚ã‚‹æ®‹ã‚Šã®æ–‡ã®å®Ÿè¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ã€æ¬¡ã®è¦ç´ ã®å‡¦ç†ã«ç§»ã‚‹ã‹ã€ã“ã‚Œä»¥ä¸Šæ¬¡ã®è¦ç´ ãŒç„¡ã„å ´åˆã¯ "
":keyword:`else` ç¯€ã®å‡¦ç†ã«ç§»ã‚Šã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:181
msgid ""
"The for-loop makes assignments to the variables(s) in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"for ãƒ«ãƒ¼ãƒ—ã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆå†…ã®å¤‰æ•°ã¸ã®ä»£å…¥ã‚’è¡Œã„ã¾ã™ã€‚\n"
"ã“ã‚Œã«ã‚ˆã‚Šã€for ãƒ«ãƒ¼ãƒ—å†…ã®ã‚¹ã‚¤ãƒ¼ãƒˆã‚‚å«ã‚ã€ãã‚Œä»¥å‰ã®å…¨ã¦ã®ä»£å…¥ã¯ä¸Šæ›¸ãã•ã‚Œã¾ã™::"

#: ../../reference/compound_stmts.rst:195
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in function :func:`range` returns an iterator of "
"integers suitable to emulate the effect of Pascal's ``for i := a to b do``; "
"e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``."
msgstr ""
"ãƒ«ãƒ¼ãƒ—ãŒçµ‚äº†ã—ã¦ã‚‚ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆå†…ã®åå‰ã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“ãŒã€ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ãŒç©ºã®å ´åˆã«ã¯ã€ãƒ«ãƒ¼ãƒ—ã§ã®ä»£å…¥ã¯å…¨ãè¡Œã‚ã‚Œã¾ã›ã‚“ã€‚ãƒ’ãƒ³ãƒˆ: çµ„ã¿è¾¼ã¿é–¢æ•° "
":func:`range` ã¯ã€ Pascal ã® ``for i := a to b do`` "
"ã®åŠ¹æœã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã®ã«é©ã—ãŸã€æ•´æ•°ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™; ã™ãªã‚ã¡ã€ ``list(range(3))`` ã¯ãƒªã‚¹ãƒˆ ``[0, 1, 2]``"
" ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:207
msgid ""
"There is a subtlety when the sequence is being modified by the loop (this "
"can only occur for mutable sequences, e.g. lists).  An internal counter is "
"used to keep track of which item is used next, and this is incremented on "
"each iteration.  When this counter has reached the length of the sequence "
"the loop terminates.  This means that if the suite deletes the current (or a"
" previous) item from the sequence, the next item will be skipped (since it "
"gets the index of the current item which has already been treated).  "
"Likewise, if the suite inserts an item in the sequence before the current "
"item, the current item will be treated again the next time through the loop."
" This can lead to nasty bugs that can be avoided by making a temporary copy "
"using a slice of the whole sequence, e.g., ::"
msgstr ""

#: ../../reference/compound_stmts.rst:228
msgid "The :keyword:`try` statement"
msgstr ":keyword:`try` æ–‡"

#: ../../reference/compound_stmts.rst:238
msgid ""
"The :keyword:`try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ":keyword:`try` æ–‡ã¯ã€ã²ã¨ã¾ã¨ã‚ã®æ–‡ã«å¯¾ã—ã¦ã€ä¾‹å¤–å‡¦ç†ãŠã‚ˆã³/ã¾ãŸã¯ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚³ãƒ¼ãƒ‰ã‚’æŒ‡å®šã—ã¾ã™:"

#: ../../reference/compound_stmts.rst:251
msgid ""
"The :keyword:`except` clause(s) specify one or more exception handlers. When"
" no exception occurs in the :keyword:`try` clause, no exception handler is "
"executed. When an exception occurs in the :keyword:`try` suite, a search for"
" an exception handler is started.  This search inspects the except clauses "
"in turn until one is found that matches the exception.  An expression-less "
"except clause, if present, must be last; it matches any exception.  For an "
"except clause with an expression, that expression is evaluated, and the "
"clause matches the exception if the resulting object is \"compatible\" with "
"the exception.  An object is compatible with an exception if it is the class"
" or a base class of the exception object or a tuple containing an item "
"compatible with the exception."
msgstr ""
":keyword:`except` ç¯€ã¯ä¸€ã¤ä»¥ä¸Šã®ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã‚’æŒ‡å®šã—ã¾ã™ã€‚ :keyword:`try` "
"ç¯€å†…ã§ä¾‹å¤–ãŒèµ·ããªã‘ã‚Œã°ã€ã©ã®ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã‚‚å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã€‚ :keyword:`try` "
"ã‚¹ã‚¤ãƒ¼ãƒˆå†…ã§ä¾‹å¤–ãŒç™ºç”Ÿã™ã‚‹ã¨ã€ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã®æ¤œç´¢ãŒé–‹å§‹ã•ã‚Œã¾ã™ã€‚ã“ã®æ¤œç´¢ã§ã¯ã€ :keyword:`except`  "
"ç¯€ã‚’é€æ¬¡ã€ç™ºç”Ÿã—ãŸä¾‹å¤–ã«å¯¾å¿œã™ã‚‹ã¾ã§èª¿ã¹ã¾ã™ã€‚å¼ã‚’ä¼´ã‚ãªã„ :keyword:`except` "
"ç¯€ã‚’ä½¿ã†ãªã‚‰ã€æœ€å¾Œã«æ›¸ã‹ãªã‘ã‚Œã°ãªã‚‰ãšã€ã“ã‚Œã¯å…¨ã¦ã®ä¾‹å¤–ã«å¯¾å¿œã—ã¾ã™ã€‚å¼ã‚’ä¼´ã† :keyword:`except` "
"ç¯€ã«å¯¾ã—ã¦ã¯ã€ãã®å¼ãŒè©•ä¾¡ã•ã‚Œã€çµæœã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä¾‹å¤–ã¨ \"äº’æ›ã§ã‚ã‚‹ (compatible)\" "
"å ´åˆã«ãã®ç¯€ãŒå¯¾å¿œã—ã¾ã™ã€‚ã‚ã‚‹ä¾‹å¤–ã«å¯¾ã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒäº’æ›ã§ã‚ã‚‹ã®ã¯ã€ãã‚ŒãŒä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¯ãƒ©ã‚¹ã‹ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã®å ´åˆã€ã¾ãŸã¯ä¾‹å¤–ã¨äº’æ›ã§ã‚ã‚‹è¦ç´ ãŒå…¥ã£ãŸã‚¿ãƒ—ãƒ«ã§ã‚ã‚‹å ´åˆã§ã™ã€‚"

#: ../../reference/compound_stmts.rst:262
msgid ""
"If no except clause matches the exception, the search for an exception "
"handler continues in the surrounding code and on the invocation stack.  [#]_"
msgstr ""
"ä¾‹å¤–ãŒã©ã® :keyword:`except` ç¯€ã«ã‚‚åˆè‡´ã—ãªã‹ã£ãŸå ´åˆã€ç¾åœ¨ã®ã‚³ãƒ¼ãƒ‰ã‚’å›²ã†ã•ã‚‰ã«å¤–å´ã€ãã—ã¦å‘¼ã³å‡ºã—ã‚¹ã‚¿ãƒƒã‚¯ã¸ã¨æ¤œç´¢ã‚’ç¶šã‘ã¾ã™ã€‚ "
"[#]_"

#: ../../reference/compound_stmts.rst:265
msgid ""
"If the evaluation of an expression in the header of an except clause raises "
"an exception, the original search for a handler is canceled and a search "
"starts for the new exception in the surrounding code and on the call stack "
"(it is treated as if the entire :keyword:`try` statement raised the "
"exception)."
msgstr ""
":keyword:`except` "
"ç¯€ã®ãƒ˜ãƒƒãƒ€ã«ã‚ã‚‹å¼ã‚’å€¤è©•ä¾¡ã™ã‚‹ã¨ãã«ä¾‹å¤–ãŒç™ºç”Ÿã™ã‚‹ã¨ã€å…ƒã€…ã®ãƒãƒ³ãƒ‰ãƒ©æ¤œç´¢ã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã€æ–°ãŸãªä¾‹å¤–ã«å¯¾ã™ã‚‹ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã®æ¤œç´¢ã‚’ç¾åœ¨ã® "
":keyword:`except` ç¯€ã®å¤–å´ã®ã‚³ãƒ¼ãƒ‰ã‚„å‘¼ã³å‡ºã—ã‚¹ã‚¿ãƒƒã‚¯ã«å¯¾ã—ã¦è¡Œã„ã¾ã™ (:keyword:`try` "
"æ–‡å…¨ä½“ãŒä¾‹å¤–ã‚’ç™ºè¡Œã—ãŸã‹ã®ã‚ˆã†ã«æ‰±ã‚ã‚Œã¾ã™)ã€‚"

#: ../../reference/compound_stmts.rst:272
msgid ""
"When a matching except clause is found, the exception is assigned to the "
"target specified after the :keyword:`as` keyword in that except clause, if "
"present, and the except clause's suite is executed.  All except clauses must"
" have an executable block.  When the end of this block is reached, execution"
" continues normally after the entire try statement.  (This means that if two"
" nested handlers exist for the same exception, and the exception occurs in "
"the try clause of the inner handler, the outer handler will not handle the "
"exception.)"
msgstr ""
"å¯¾å¿œã™ã‚‹ except ç¯€ãŒè¦‹ã¤ã‹ã‚‹ã¨ã€except ç¯€ã®ã‚¹ã‚¤ãƒ¼ãƒˆãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ãã®éš›ã€ :keyword:`as` "
"ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒå­˜åœ¨ã™ã‚Œã°ã€ãã®å¾Œã§æŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ä¾‹å¤–ãŒä»£å…¥ã•ã‚Œã¾ã™ã€‚å…¨ã¦ã® :keyword:`except` "
"ç¯€ã¯å®Ÿè¡Œå¯èƒ½ãªãƒ–ãƒ­ãƒƒã‚¯ã‚’æŒã£ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã®æœ«å°¾ã«åˆ°é”ã™ã‚‹ã¨ã€é€šå¸¸ã¯ :keyword:`try` "
"æ–‡å…¨ä½“ã®ç›´å¾Œã‹ã‚‰å®Ÿè¡Œã‚’ç¶™ç¶šã—ã¾ã™ã€‚(ã“ã®ã“ã¨ã¯ã€ãƒã‚¹ãƒˆã•ã‚ŒãŸäºŒã¤ã®ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ãŒåŒã˜ä¾‹å¤–ã«å¯¾ã—ã¦å­˜åœ¨ã—ã€å†…å´ã®ãƒãƒ³ãƒ‰ãƒ©å†…ã® :keyword:`try`"
" ç¯€ã§ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸå ´åˆã€å¤–å´ã®ãƒãƒ³ãƒ‰ãƒ©ã¯ãã®ä¾‹å¤–ã‚’å‡¦ç†ã—ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚)"

#: ../../reference/compound_stmts.rst:280
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the except clause.  This is as if ::"
msgstr ""
"ä¾‹å¤–ãŒ ``as target`` ã‚’ä½¿ã£ã¦ä»£å…¥ã•ã‚ŒãŸã¨ãã€ãã‚Œã¯ except ç¯€ã®çµ‚ã‚ã‚Šã«æ¶ˆå»ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã¡ã‚‡ã†ã©ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰::"

#: ../../reference/compound_stmts.rst:286
msgid "was translated to ::"
msgstr "ãŒã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã«ç¿»è¨³ã•ã‚ŒãŸã‹ã®ã‚ˆã†ãªã‚‚ã®ã§ã™::"

#: ../../reference/compound_stmts.rst:294
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the except clause.  Exceptions are cleared because with "
"the traceback attached to them, they form a reference cycle with the stack "
"frame, keeping all locals in that frame alive until the next garbage "
"collection occurs."
msgstr ""
"ã‚ˆã£ã¦ã€ä¾‹å¤–ã‚’ except "
"ç¯€ä»¥é™ã§å‚ç…§ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã¯ã€åˆ¥ã®åå‰ã«ä»£å…¥ã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹å¤–ãŒå‰Šé™¤ã•ã‚Œã‚‹ã®ã¯ã€ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ãŒä»˜ä¸ã•ã‚Œã‚‹ã¨ã€ãã®ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã¨å¾ªç’°å‚ç…§ã‚’å½¢ä½œã‚Šã€æ¬¡ã®ã‚¬ãƒ™ãƒ¼ã‚¸åé›†ã¾ã§ãã®ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã®ã™ã¹ã¦ã®å±€æ‰€å¤‰æ•°ã‚’ç”Ÿå­˜ã•ã›ã¦ã—ã¾ã†ã‹ã‚‰ã§ã™ã€‚"

#: ../../reference/compound_stmts.rst:303
msgid ""
"Before an except clause's suite is executed, details about the exception are"
" stored in the :mod:`sys` module and can be accessed via "
":func:`sys.exc_info`. :func:`sys.exc_info` returns a 3-tuple consisting of "
"the exception class, the exception instance and a traceback object (see "
"section :ref:`types`) identifying the point in the program where the "
"exception occurred.  :func:`sys.exc_info` values are restored to their "
"previous values (before the call) when returning from a function that "
"handled an exception."
msgstr ""
":keyword:`except` ç¯€ã®ã‚¹ã‚¤ãƒ¼ãƒˆãŒå®Ÿè¡Œã•ã‚Œã‚‹å‰ã«ã€ä¾‹å¤–ã«é–¢ã™ã‚‹è©³ç´°ãŒ :mod:`sys` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ä¿å­˜ã•ã‚Œã€ "
":func:`sys.exc_info` ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚ :func:`sys.exc_info` "
"ã¯ã€ä¾‹å¤–ã‚¯ãƒ©ã‚¹ã€ä¾‹å¤–ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€ãã—ã¦ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸Šã®ä½ç½®ã‚’è­˜åˆ¥ã™ã‚‹ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (:ref:`types` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„) ã® 3 è¦ç´ ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ :func:`sys.exc_info` ã®å€¤ã¯ã€ä¾‹å¤–ã‚’å‡¦ç†ã—ãŸé–¢æ•°ã‹ã‚‰æˆ»ã‚‹ã¨ãã«ã€ä»¥å‰ "
"(é–¢æ•°å‘¼ã³å‡ºã—å‰) ã®å€¤ã«æˆ»ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:317
msgid ""
"The optional :keyword:`else` clause is executed if and when control flows "
"off the end of the :keyword:`try` clause. [#]_ Exceptions in the "
":keyword:`else` clause are not handled by the preceding :keyword:`except` "
"clauses."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® :keyword:`else` ç¯€ã¯ã€å®Ÿè¡Œã®åˆ¶å¾¡ãŒ :keyword:`try` ç¯€ã®æœ«å°¾ã«åˆ°é”ã—ãŸå ´åˆã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ [#]_ "
":keyword:`else` ç¯€å†…ã§èµ·ããŸä¾‹å¤–ã¯ã€ :keyword:`else` ç¯€ã«å…ˆè¡Œã™ã‚‹ :keyword:`except` "
"ç¯€ã§å‡¦ç†ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/compound_stmts.rst:323
msgid ""
"If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The "
":keyword:`try` clause is executed, including any :keyword:`except` and "
":keyword:`else` clauses.  If an exception occurs in any of the clauses and "
"is not handled, the exception is temporarily saved. The :keyword:`finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`finally` clause.  If the :keyword:`finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`finally` clause executes a :keyword:`return`"
" or :keyword:`break` statement, the saved exception is discarded::"
msgstr ""
":keyword:`finally` ç¯€ãŒã‚ã‚‹å ´åˆã¯ã€ 'å¾Œå§‹æœ« (cleanup)' ã®å¯¾å‡¦ã‚’æŒ‡å®šã—ã¾ã™ã€‚ã¾ãš :keyword:`except` "
"ç¯€ã‚„ :keyword:`else` ç¯€ã‚’å«ã‚ã€ :keyword:`try` "
"ç¯€ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ãã‚Œã‚‰ã®ç¯€ã®ä¸­ã§ä¾‹å¤–ãŒèµ·ãã€èª°ã‚‚å¯¾å‡¦ã—ã¦ã„ãªã„å ´åˆã¯ã€ä¾‹å¤–ã¯ä¸€æ™‚çš„ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚æ¬¡ã« :keyword:`finally` "
"ç¯€ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ä¿å­˜ã•ã‚ŒãŸä¾‹å¤–ãŒã‚ã£ãŸå ´åˆã¯ã€ :keyword:`finally` ç¯€ã®æœ«å°¾ã§å†é€å‡ºã•ã‚Œã¾ã™ã€‚ :keyword:`finally`"
" ç¯€ã§åˆ¥ã®ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã‚‹å ´åˆã¯ã€ä¿å­˜ã•ã‚Œã¦ã„ãŸä¾‹å¤–ã¯æ–°ã—ã„ä¾‹å¤–ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦è¨­å®šã•ã‚Œã¾ã™ã€‚ :keyword:`finally` ç¯€ã§ "
":keyword:`return` æ–‡ã‚ã‚‹ã„ã¯ :keyword:`break` æ–‡ã‚’å®Ÿè¡Œã—ãŸå ´åˆã¯ã€ä¿å­˜ã•ã‚ŒãŸä¾‹å¤–ã¯ç ´æ£„ã•ã‚Œã¾ã™::"

#: ../../reference/compound_stmts.rst:342
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`finally` clause."
msgstr ":keyword:`finally` ç¯€ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹é–“ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰ã¯ä¾‹å¤–æƒ…å ±ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../reference/compound_stmts.rst:350
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`try`...\\ "
":keyword:`finally` statement, the :keyword:`finally` clause is also executed"
" 'on the way out.' A :keyword:`continue` statement is illegal in the "
":keyword:`finally` clause. (The reason is a problem with the current "
"implementation --- this restriction may be lifted in the future)."
msgstr ""
":keyword:`try`...\\ :keyword:`finally` æ–‡ã® :keyword:`try` ã‚¹ã‚¤ãƒ¼ãƒˆå†…ã§ "
":keyword:`return` ã€ :keyword:`break` ã€ã¾ãŸã¯ :keyword:`continue` æ–‡ãŒå®Ÿè¡Œã•ã‚ŒãŸå ´åˆã€ "
":keyword:`finally` ç¯€ã‚‚ 'æŠœã‘å‡ºã‚‹é€”ä¸­ã« (on the way out)' å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ :keyword:`finally` "
"ç¯€ã§ã® :keyword:`continue` æ–‡ã®ä½¿ç”¨ã¯ä¸æ­£ã§ã™ã€‚ (ç†ç”±ã¯ç¾åœ¨ã®å®Ÿè£…ä¸Šã®å•é¡Œã§ã™ -- ã“ã®åˆ¶é™ã¯å°†æ¥è§£æ¶ˆã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“)ã€‚"

#: ../../reference/compound_stmts.rst:357
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`finally` clause always executes, a "
":keyword:`return` statement executed in the :keyword:`finally` clause will "
"always be the last one executed::"
msgstr ""
"é–¢æ•°ã®è¿”ã‚Šå€¤ã¯æœ€å¾Œã«å®Ÿè¡Œã•ã‚ŒãŸ :keyword:`return` æ–‡ã«ã‚ˆã£ã¦æ±ºã¾ã‚Šã¾ã™ã€‚\n"
":keyword:`finally` ç¯€ã¯å¿…ãšå®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã€:keyword:`finally` ç¯€ã§å®Ÿè¡Œã•ã‚ŒãŸ :keyword:`return` æ–‡ã¯å¸¸ã«æœ€å¾Œã«å®Ÿè¡Œã•ã‚Œã¾ã™::"

#: ../../reference/compound_stmts.rst:371
msgid ""
"Additional information on exceptions can be found in section "
":ref:`exceptions`, and information on using the :keyword:`raise` statement "
"to generate exceptions may be found in section :ref:`raise`."
msgstr ""
"ä¾‹å¤–ã«é–¢ã™ã‚‹ãã®ä»–ã®æƒ…å ±ã¯ :ref:`exceptions` ç¯€ã«ã‚ã‚Šã¾ã™ã€‚ã¾ãŸã€ :keyword:`raise` "
"æ–‡ã®ä½¿ç”¨ã«ã‚ˆã‚‹ä¾‹å¤–ã®ç”Ÿæˆã«é–¢ã™ã‚‹æƒ…å ±ã¯ã€ :ref:`raise` ç¯€ã«ã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:380
msgid "The :keyword:`with` statement"
msgstr ":keyword:`with` æ–‡"

#: ../../reference/compound_stmts.rst:389
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ "
":keyword:`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
":keyword:`with` æ–‡ã¯ã€ãƒ–ãƒ­ãƒƒã‚¯ã®å®Ÿè¡Œã‚’ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã§ãƒ©ãƒƒãƒ—ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ (:ref"
":`context-managers` ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚ˆãã‚ã‚‹ :keyword:`try`...\\ "
":keyword:`except`...\\ :keyword:`finally` åˆ©ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã‚«ãƒ—ã‚»ãƒ«åŒ–ã—ã¦ä¾¿åˆ©ã«å†åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:398
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as"
" follows:"
msgstr "ä¸€ã¤ã® \"è¦ç´ \" ã‚’æŒã¤ :keyword:`with` æ–‡ã®å®Ÿè¡Œã¯ä»¥ä¸‹ã®ã‚ˆã†ã«é€²è¡Œã—ã¾ã™:"

#: ../../reference/compound_stmts.rst:400
msgid ""
"The context expression (the expression given in the :token:`with_item`) is "
"evaluated to obtain a context manager."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå¼ (:token:`with_item` ã§ä¸ãˆã‚‰ã‚ŒãŸå¼) ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’å–å¾—ã—ã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:403
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã® :meth:`__exit__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã€å¾Œã§ä½¿ã†ãŸã‚ã«ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:405
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã® :meth:`__enter__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:407
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr ":keyword:`with` æ–‡ã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒå«ã¾ã‚Œã¦ã„ãŸã‚‰ã€ãã‚Œã« :meth:`__enter__` ã‹ã‚‰ã®æˆ»ã‚Šå€¤ãŒä»£å…¥ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:412
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be."
" See step 6 below."
msgstr ""
":keyword:`with` æ–‡ã¯ã€ :meth:`__enter__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚¨ãƒ©ãƒ¼ãªãçµ‚äº†ã—ãŸå ´åˆã«ã¯ :meth:`__exit__` "
"ãŒå¸¸ã«å‘¼ã°ã‚Œã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¾ã™ã€‚ã§ã™ã®ã§ã€ã‚‚ã—ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆã¸ã®ä»£å…¥ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«ã¯ã€ã“ã‚Œã¯ãã®ã‚¹ã‚¤ãƒ¼ãƒˆã®ä¸­ã§ç™ºç”Ÿã—ãŸã‚¨ãƒ©ãƒ¼ã¨åŒã˜ã‚ˆã†ã«æ‰±ã‚ã‚Œã¾ã™ã€‚ä»¥ä¸‹ã®ã‚¹ãƒ†ãƒƒãƒ—"
" 6 ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/compound_stmts.rst:418
msgid "The suite is executed."
msgstr "ã‚¹ã‚¤ãƒ¼ãƒˆãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:420
msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""
"ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã® :meth:`__exit__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã¾ã™ã€‚ã‚¹ã‚¤ãƒ¼ãƒˆãŒä¾‹å¤–ã«ã‚ˆã£ã¦çµ‚äº†ã•ã‚ŒãŸã®ãªã‚‰ã€ãã®ä¾‹å¤–ã®å‹ã€å€¤ã€ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ãŒ :meth:`__exit__` "
"ã«å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ 3 ã¤ã® :const:`None` å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:425
msgid ""
"If the suite was exited due to an exception, and the return value from the "
":meth:`__exit__` method was false, the exception is reraised.  If the return"
" value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""
"ã‚¹ã‚¤ãƒ¼ãƒˆãŒä¾‹å¤–ã«ã‚ˆã‚Šçµ‚äº†ã•ã‚Œã€ :meth:`__exit__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰ã®æˆ»ã‚Šå€¤ãŒå½ï¼ˆfalseï¼‰ãªã‚‰ã°ã€ä¾‹å¤–ãŒå†é€å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®æˆ»ã‚Šå€¤ãŒçœŸï¼ˆtrueï¼‰ãªã‚‰ã°ä¾‹å¤–ã¯æŠ‘åˆ¶ã•ã‚Œã€å®Ÿè¡Œã¯ "
":keyword:`with` æ–‡ã®æ¬¡ã®æ–‡ã‹ã‚‰ç¶šãã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:430
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal"
" location for the kind of exit that was taken."
msgstr ""
"ã‚‚ã—ãã®ã‚¹ã‚¤ãƒ¼ãƒˆãŒä¾‹å¤–ã§ãªã„ä½•ã‚‰ã‹ã®ç†ç”±ã§çµ‚äº†ã—ãŸå ´åˆã€ãã® :meth:`__exit__` "
"ã‹ã‚‰ã®æˆ»ã‚Šå€¤ã¯ç„¡è¦–ã•ã‚Œã¦ã€å®Ÿè¡Œã¯ç™ºç”Ÿã—ãŸçµ‚äº†ã®ç¨®é¡ã«å¿œã˜ãŸé€šå¸¸ã®ä½ç½®ã‹ã‚‰ç¶™ç¶šã—ã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:434
msgid ""
"With more than one item, the context managers are processed as if multiple "
":keyword:`with` statements were nested::"
msgstr "è¤‡æ•°ã®è¦ç´ ãŒã‚ã‚‹ã¨ãã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¯è¤‡æ•°ã® :keyword:`with` æ–‡ãŒãƒã‚¹ãƒˆã•ã‚ŒãŸã‹ã®ã‚ˆã†ã«é€²è¡Œã—ã¾ã™::"

#: ../../reference/compound_stmts.rst:440
#: ../../reference/compound_stmts.rst:642
msgid "is equivalent to ::"
msgstr "ã¯ã€ä»¥ä¸‹ã¨åŒç­‰ã§ã™ ::"

#: ../../reference/compound_stmts.rst:446
msgid "Support for multiple context expressions."
msgstr "è¤‡æ•°ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå¼ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚"

#: ../../reference/compound_stmts.rst:452
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆ"

#: ../../reference/compound_stmts.rst:452
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python ã® :keyword:`with` æ–‡ã®ä»•æ§˜ã€èƒŒæ™¯ã€ãŠã‚ˆã³ä¾‹ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:463
msgid "Function definitions"
msgstr "é–¢æ•°å®šç¾©"

#: ../../reference/compound_stmts.rst:478
msgid ""
"A function definition defines a user-defined function object (see section "
":ref:`types`):"
msgstr "é–¢æ•°å®šç¾©ã¯ã€ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®šç¾©ã—ã¾ã™ (:ref:`types` ç¯€å‚ç…§):"

#: ../../reference/compound_stmts.rst:496
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper"
" around the executable code for the function).  This function object "
"contains a reference to the current global namespace as the global namespace"
" to be used when the function is called."
msgstr ""
"é–¢æ•°å®šç¾©ã¯å®Ÿè¡Œå¯èƒ½ãªæ–‡ã§ã™ã€‚é–¢æ•°å®šç¾©ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ç¾åœ¨ã®ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ç©ºé–“å†…ã§é–¢æ•°åã‚’é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (é–¢æ•°ã®å®Ÿè¡Œå¯èƒ½ã‚³ãƒ¼ãƒ‰ã‚’ãã‚‹ã‚€ãƒ©ãƒƒãƒ‘) "
"ã«æŸç¸›ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚ŒãŸéš›ã«ä½¿ã‚ã‚Œã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ç©ºé–“ã¨ã—ã¦ã€ç¾åœ¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ç©ºé–“ã¸ã®å‚ç…§ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:502
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr "é–¢æ•°å®šç¾©ã¯é–¢æ•°æœ¬ä½“ã‚’å®Ÿè¡Œã—ã¾ã›ã‚“; é–¢æ•°æœ¬ä½“ã¯é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚ŒãŸæ™‚ã«ã®ã¿å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ [#]_"

#: ../../reference/compound_stmts.rst:508
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"é–¢æ•°å®šç¾©ã¯ä¸€ã¤ä»¥ä¸Šã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ (:term:`decorator`) "
"å¼ã§ãƒ©ãƒƒãƒ—ã§ãã¾ã™ã€‚ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿å¼ã¯é–¢æ•°ã‚’å®šç¾©ã™ã‚‹ã¨ãã€é–¢æ•°å®šç¾©ã®å…¥ã£ã¦ã„ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ã§è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ãã®çµæœã¯ã€é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å”¯ä¸€ã®å¼•æ•°ã«ã¨ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»£ã‚ã‚Šã«ã€è¿”ã•ã‚ŒãŸå€¤ãŒé–¢æ•°åã«æŸç¸›ã•ã‚Œã¾ã™ã€‚è¤‡æ•°ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¯ãƒã‚¹ãƒˆã—ã¦é©ç”¨ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰::"

#: ../../reference/compound_stmts.rst:519
#: ../../reference/compound_stmts.rst:672
msgid "is roughly equivalent to ::"
msgstr "ã¯ã€ã ã„ãŸã„æ¬¡ã¨ç­‰ä¾¡ã§ã™ ::"

#: ../../reference/compound_stmts.rst:524
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr "ãŸã ã—ã€å‰è€…ã®ã‚³ãƒ¼ãƒ‰ã§ã¯å…ƒã€…ã®é–¢æ•°ã‚’ ``func`` ã¨ã„ã†åå‰ã¸ä¸€æ™‚çš„ã«æŸç¸›ã™ã‚‹ã“ã¨ã¯ãªã„ã€ã¨ã„ã†ã¨ã“ã‚ã‚’é™¤ãã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:531
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter "
"values.\"  For a parameter with a default value, the corresponding "
":term:`argument` may be omitted from a call, in which case the parameter's "
"default value is substituted.  If a parameter has a default value, all "
"following parameters up until the \"``*``\" must also have a default value "
"--- this is a syntactic restriction that is not expressed by the grammar."
msgstr ""
"1 ã¤ä»¥ä¸Šã® :term:`ä»®å¼•æ•° <parameter>` ãŒ *parameter* ``=`` *expression* "
"ã®å½¢ã‚’å–ã£ã¦ã„ã‚‹ã¨ãã€é–¢æ•°ã¯ \"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°å€¤\" ã‚’æŒã¤ã¨è¨€ã„ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒã¤ä»®å¼•æ•°ã§ã¯ã€å‘¼ã³å‡ºã—æ™‚ã«ãã‚Œã«å¯¾å¿œã™ã‚‹å®Ÿå¼•æ•° "
"(:term:`argument`) ã¯çœç•¥ã§ãã€ãã®å ´åˆã¯ä»®å¼•æ•°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ã‚ã‚‹å¼•æ•°ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã€ãã‚Œä»¥é™ "
"\"``*``\" ãŒå‡ºã¦ãã‚‹ã¾ã§ã®å¼•æ•°ã¯å…¨ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒã£ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ -- ã“ã‚Œã¯æ–‡æ³•å®šç¾©ã§ã¯è¡¨ç¾ã•ã‚Œã¦ã„ãªã„æ§‹æ–‡çš„åˆ¶é™ã§ã™ã€‚"

#: ../../reference/compound_stmts.rst:539
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter is a mutable object, such as a list or a"
" dictionary: if the function modifies the object (e.g. by appending an item "
"to a list), the default value is in effect modified.  This is generally not "
"what was intended.  A way around this is to use ``None`` as the default, and"
" explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°å€¤ã¯é–¢æ•°å®šç¾©ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ãã«å·¦ã‹ã‚‰å³ã¸è©•ä¾¡ã•ã‚Œã¾ã™ã€‚** "
"ã“ã‚Œã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°ã®å¼ã¯é–¢æ•°ãŒå®šç¾©ã•ã‚Œã‚‹ã¨ãã«ãŸã ä¸€åº¦ã ã‘è©•ä¾¡ã•ã‚Œã€åŒã˜ \"è¨ˆç®—æ¸ˆã¿ã®\" "
"å€¤ãŒå‘¼ã³å‡ºã—ã®ãŸã³ã«ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ã“ã®ä»•æ§˜ã‚’ç†è§£ã—ã¦ãŠãã“ã¨ã¯ç‰¹ã«ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°å€¤ãŒãƒªã‚¹ãƒˆã‚„è¾æ›¸ã®ã‚ˆã†ãªãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã¨ãã«é‡è¦ã§ã™:"
" é–¢æ•°ãŒã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¤‰æ›´ (ä¾‹ãˆã°ãƒªã‚¹ãƒˆã«è¦ç´ ã‚’è¿½åŠ ) "
"ã™ã‚‹ã¨ã€ã“ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒå¤‰æ›´ã®å½±éŸ¿ã‚’å—ã‘ã¦ã—ã¾ã—ã¾ã™ã€‚ä¸€èˆ¬ã«ã¯ã€ã“ã‚Œã¯æ„å›³ã—ãªã„å‹•ä½œã§ã™ã€‚ã“ã®ã‚ˆã†ãªå‹•ä½œã‚’é¿ã‘ã‚‹ã«ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ã—ã¦ "
"``None`` ã‚’ä½¿ã„ã€ã“ã®å€¤ã‚’é–¢æ•°æœ¬ä½“ã®ä¸­ã§æ˜ç¤ºçš„ã«ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../reference/compound_stmts.rst:559
msgid ""
"Function call semantics are described in more detail in section "
":ref:`calls`. A function call always assigns values to all parameters "
"mentioned in the parameter list, either from position arguments, from "
"keyword arguments, or from default values.  If the form \"``*identifier``\" "
"is present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed used keyword arguments."
msgstr ""
"é–¢æ•°å‘¼ã³å‡ºã—ã®æ„å‘³ä»˜ã‘ã«é–¢ã™ã‚‹è©³ç´°ã¯ã€ :ref:`calls` ç¯€ã§è¿°ã¹ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚\n"
"é–¢æ•°å‘¼ã³å‡ºã—ã‚’è¡Œã†ã¨ã€ãƒ‘ãƒ©ãƒ¡ã‚¿ãƒªã‚¹ãƒˆã«è¨˜è¿°ã•ã‚ŒãŸå…¨ã¦ã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã«ã€å›ºå®šå¼•æ•°ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®ã„ãšã‚Œã‹ã‹ã‚‰å€¤ãŒä»£å…¥ã•ã‚Œã¾ã™ã€‚\n"
"\"``*identifier``\" å½¢å¼ãŒå­˜åœ¨ã™ã‚Œã°ã€ä½™ã£ãŸã™ã¹ã¦ã®å›ºå®šå¼•æ•°ã‚’å—ã‘å–ã£ãŸã‚¿ãƒ—ãƒ«ã«åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚\n"
"ã“ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ç©ºã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚\n"
"\"``**identifier``\" å½¢å¼ãŒå­˜åœ¨ã™ã‚Œã°ã€ä½™ã£ãŸã™ã¹ã¦ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’å—ã‘å–ã£ãŸé †åºä»˜ãã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚\n"
"ã“ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯åŒã˜å‹ã®ç©ºã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚\n"
"\"``*``\" ã‚„ \"``*identifier``\" ã®å¾Œã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å°‚ç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ä½¿ã£ã¦ã®ã¿æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:575
msgid ""
"Parameters may have annotations of the form \"``: expression``\" following "
"the parameter name.  Any parameter may have an annotation even those of the "
"form ``*identifier`` or ``**identifier``.  Functions may have \"return\" "
"annotation of the form \"``-> expression``\" after the parameter list.  "
"These annotations can be any valid Python expression and are evaluated when "
"the function definition is executed.  Annotations may be evaluated in a "
"different order than they appear in the source code.  The presence of "
"annotations does not change the semantics of a function.  The annotation "
"values are available as values of a dictionary keyed by the parameters' "
"names in the :attr:`__annotations__` attribute of the function object."
msgstr ""
"å¼•æ•°ã«ã¯ã€å¼•æ•°åã«ç¶šã‘ã¦ \"``: expression``\" å½¢å¼ã®ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚``*identifier`` ã‚„ "
"``**identifier`` ã®å½¢å¼ã§ã‚‚ã€ã™ã¹ã¦ã®å¼•æ•°ã«ã¯ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã¤ã‘ã‚‰ã‚Œã¾ã™ã€‚é–¢æ•°ã«ã¯ã€å¼•æ•°ãƒªã‚¹ãƒˆã®å¾Œã« \"``-> "
"expression``\" å½¢å¼ã® \"return\" ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã¤ã‘ã‚‰ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ä»»æ„ã®æœ‰åŠ¹ãª Python "
"ã®å¼ã«ã§ãã€é–¢æ•°å®šç¾©ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ãã«è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã«ã‚ã‚‹ã¨ãã¨ã¯åˆ¥ã®é †åºã§è©•ä¾¡ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã£ã¦ã‚‚ã€é–¢æ•°ã®æ„å‘³ã¥ã‘ã¯å¤‰ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®å€¤ã¯ã€é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®"
" :attr:`__annotations__` å±æ€§ã®ã€å¼•æ•°åã‚’ã‚­ãƒ¼ã¨ã™ã‚‹å€¤ã¨ã—ã¦åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:588
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The "
"\":keyword:`def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"å¼ã‚’å³æ™‚ã«ä½¿ç”¨ã™ã‚‹ãŸã‚ã«ã€ç„¡åé–¢æ•° (åå‰ã«æŸç¸›ã•ã‚Œã¦ã„ãªã„é–¢æ•°) ã‚’ä½œæˆã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã“ã‚Œã¯ :ref:`lambda` "
"ã®ç¯€ã§è§£èª¬ã•ã‚Œã¦ã„ã‚‹ãƒ©ãƒ ãƒ€å¼ã‚’ä½¿ã„ã¾ã™ã€‚ãƒ©ãƒ ãƒ€å¼ã¯ç°¡ç•¥åŒ–ã•ã‚ŒãŸé–¢æ•°å®šç¾©ã®çœç•¥è¡¨ç¾ã«éããªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„;  "
"\":keyword:`def`\" "
"æ–‡ã§å®šç¾©ã•ã‚ŒãŸé–¢æ•°ã‚‚ãƒ©ãƒ ãƒ€å¼ã§ä½œæˆã•ã‚ŒãŸé–¢æ•°ã®ã‚ˆã†ã«ã€å¼•æ•°ã¨ã—ã¦æ¸¡ã›ãŸã‚Šã€ä»–ã®åå‰ã«å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚è¤‡æ•°ã®å¼ã¨ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Ÿè¡Œã§ãã‚‹ã®ã§ã€"
" \":keyword:`def`\" å½¢å¼ã®æ–¹ãŒã‚ˆã‚Šå¼·åŠ›ã§ã™ã€‚"

#: ../../reference/compound_stmts.rst:596
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def."
"  See section :ref:`naming` for details."
msgstr ""
"**ãƒ—ãƒ­ã‚°ãƒ©ãƒã¸ã®ãƒ¡ãƒ¢:** é–¢æ•°ã¯ç¬¬ä¸€ç´šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚é–¢æ•°å®šç¾©å†…ã§å®Ÿè¡Œã•ã‚ŒãŸ \"``def``\" "
"æ–‡ã¯ã€è¿”ã‚Šå€¤ã‚„å¼•æ•°ã¨ã—ã¦æ¸¡ã›ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«é–¢æ•°ã‚’å®šç¾©ã—ã¾ã™ã€‚ãƒã‚¹ãƒˆã—ãŸé–¢æ•°å†…ã§ä½¿ã‚ã‚Œã‚‹è‡ªç”±å¤‰æ•°ã¯ã€ def "
"ã‚’å«ã‚“ã§ã„ã‚‹é–¢æ•°ã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚è©³ç´°ã¯ :ref:`naming` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/compound_stmts.rst:604
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - Function Annotations"

#: ../../reference/compound_stmts.rst:605
msgid "The original specification for function annotations."
msgstr "é–¢æ•°ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®å…ƒã®ä»•æ§˜æ›¸ã€‚"

#: ../../reference/compound_stmts.rst:611
msgid "Class definitions"
msgstr "ã‚¯ãƒ©ã‚¹å®šç¾©"

#: ../../reference/compound_stmts.rst:626
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr "ã‚¯ãƒ©ã‚¹å®šç¾©ã¯ã€ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®šç¾©ã—ã¾ã™ (:ref:`types` ç¯€å‚ç…§):"

#: ../../reference/compound_stmts.rst:633
msgid ""
"A class definition is an executable statement.  The inheritance list usually"
" gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"ã‚¯ãƒ©ã‚¹å®šç¾©ã¯å®Ÿè¡Œå¯èƒ½ãªæ–‡ã§ã™ã€‚ç¶™æ‰¿ãƒªã‚¹ãƒˆã¯é€šå¸¸ã€åŸºåº•ã‚¯ãƒ©ã‚¹ãƒªã‚¹ãƒˆã‚’ä¸ãˆã¾ã™ (ã‚ˆã‚Šé«˜åº¦ãªä½¿ã„æ–¹ã¯ã€ :ref:`metaclasses` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚ã§ã™ã‹ã‚‰ã€ãƒªã‚¹ãƒˆã®ãã‚Œãã‚Œã®è¦ç´ ã®è©•ä¾¡ã¯ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã—ã¦ã‚‚è‰¯ã„ã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ã¹ãã§ã™ã€‚ç¶™æ‰¿ãƒªã‚¹ãƒˆã®ãªã„ã‚¯ãƒ©ã‚¹ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã€åŸºåº•ã‚¯ãƒ©ã‚¹"
" :class:`object` ã‚’ç¶™æ‰¿ã™ã‚‹ã®ã§::"

#: ../../reference/compound_stmts.rst:647
msgid ""
"The class's suite is then executed in a new execution frame (see "
":ref:`naming`), using a newly created local namespace and the original "
"global namespace. (Usually, the suite contains mostly function definitions.)"
"  When the class's suite finishes execution, its execution frame is "
"discarded but its local namespace is saved. [#]_ A class object is then "
"created using the inheritance list for the base classes and the saved local "
"namespace for the attribute dictionary.  The class name is bound to this "
"class object in the original local namespace."
msgstr ""
"æ¬¡ã«ã‚¯ãƒ©ã‚¹ã®ã‚¹ã‚¤ãƒ¼ãƒˆãŒã€æ–°ãŸãªå®Ÿè¡Œãƒ•ãƒ¬ãƒ¼ãƒ  (:ref:`naming` ã‚’å‚ç…§ã—ã¦ãã ã•ã„) "
"å†…ã§ã€æ–°ãŸã«ä½œã‚‰ã‚ŒãŸãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“ã¨å…ƒã€…ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«åå‰ç©ºé–“ã‚’ä½¿ã£ã¦å®Ÿè¡Œã•ã‚Œã¾ã™ "
"(é€šå¸¸ã€ã“ã®ã‚¹ã‚¤ãƒ¼ãƒˆã«ã¯ä¸»ã«é–¢æ•°å®šç¾©ãŒå«ã¾ã‚Œã¾ã™)ã€‚ã‚¯ãƒ©ã‚¹ã®ã‚¹ã‚¤ãƒ¼ãƒˆãŒå®Ÿè¡Œã—çµ‚ãˆã‚‹ã¨ã€å®Ÿè¡Œãƒ•ãƒ¬ãƒ¼ãƒ ã¯ç ´æ£„ã•ã‚Œã¾ã™ãŒã€ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ç©ºé–“ã¯ä¿å­˜ã•ã‚Œã¾ã™ã€‚[#]_"
" "
"æ¬¡ã«ã€ç¶™æ‰¿ãƒªã‚¹ãƒˆã‚’åŸºåº•ã‚¯ãƒ©ã‚¹ã«ã€ä¿å­˜ã•ã‚ŒãŸãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“ã‚’å±æ€§å€¤è¾æ›¸ã«ã€ãã‚Œãã‚Œä½¿ã£ã¦ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚æœ€å¾Œã«ã€ã‚‚ã¨ã®ãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“ã«ãŠã„ã¦ã€ã‚¯ãƒ©ã‚¹åãŒã“ã®ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æŸç¸›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:656
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's ``__dict__``.  Note that this is reliable only right after "
"the class is created and only for classes that were defined using the "
"definition syntax."
msgstr ""
"ã‚¯ãƒ©ã‚¹æœ¬ä½“ã§å±æ€§ãŒå®šç¾©ã•ã‚ŒãŸé †åºã¯æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã® ``__dict__`` ã«ä¿æŒã•ã‚Œã¾ã™ã€‚\n"
"ã“ã®æ€§è³ªãŒæœŸå¾…ã§ãã‚‹ã®ã¯ã€ã‚¯ãƒ©ã‚¹ãŒä½œã‚‰ã‚ŒãŸç›´å¾Œã‹ã¤å®šç¾©æ§‹æ–‡ã‚’ä½¿ã£ã¦å®šç¾©ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ã¨ãã®ã¿ã§ã™ã€‚"

#: ../../reference/compound_stmts.rst:661
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr "ã‚¯ãƒ©ã‚¹ä½œæˆã¯ã€ :ref:`ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ <metaclasses>` ã‚’åˆ©ç”¨ã—ã¦å¤§å¹…ã«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:666
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr "é–¢æ•°ã‚’ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã®ã¨åŒã˜ã‚ˆã†ã«ã€ã‚¯ãƒ©ã‚¹ã‚‚ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€ ::"

#: ../../reference/compound_stmts.rst:677
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr "ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿å¼ã®è©•ä¾¡è¦å‰‡ã¯é–¢æ•°ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¨åŒã˜ã§ã™ã€‚çµæœã¯ã‚¯ãƒ©ã‚¹åã«æŸç¸›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:680
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in"
" a method with ``self.name = value``.  Both class and instance attributes "
"are accessible through the notation \"``self.name``\", and an instance "
"attribute hides a class attribute with the same name when accessed in this "
"way.  Class attributes can be used as defaults for instance attributes, but "
"using mutable values there can lead to unexpected results.  "
":ref:`Descriptors <descriptors>` can be used to create instance variables "
"with different implementation details."
msgstr ""
"**ãƒ—ãƒ­ã‚°ãƒ©ãƒã®ãŸã‚ã®æ³¨é‡ˆ:** ã‚¯ãƒ©ã‚¹å®šç¾©å†…ã§å®šç¾©ã•ã‚ŒãŸå¤‰æ•°ã¯ã‚¯ãƒ©ã‚¹å±æ€§ã§ã‚ã‚Šã€å…¨ã¦ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹é–“ã§å…±æœ‰ã•ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸­ã§"
" ``self.name = value`` ã¨ã™ã‚‹ã“ã¨ã§è¨­å®šã§ãã¾ã™ã€‚ã‚¯ãƒ©ã‚¹å±æ€§ã‚‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã‚‚ \"``self.name``\" "
"è¡¨è¨˜ã§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã€ã“ã®è¡¨è¨˜ã§ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã¨ãã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã¯åŒåã®ã‚¯ãƒ©ã‚¹å±æ€§ã‚’éš è”½ã—ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹å±æ€§ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ã—ã¦ä½¿ãˆã¾ã™ãŒã€ãã“ã«ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªå€¤ã‚’ä½¿ã†ã¨äºˆæœŸã›ã¬çµæœã«ã¤ãªãŒã‚Šã¾ã™ã€‚"
" :ref:`è¨˜è¿°å­ <descriptors>` ã‚’ä½¿ã†ã¨ã€è©³ç´°ãªå®Ÿè£…ãŒç•°ãªã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‚’ä½œæˆã§ãã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:695
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaclasses in Python 3000"

#: ../../reference/compound_stmts.rst:693
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr ""

#: ../../reference/compound_stmts.rst:698
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - ã‚¯ãƒ©ã‚¹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿"

#: ../../reference/compound_stmts.rst:698
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr ""

#: ../../reference/compound_stmts.rst:703
msgid "Coroutines"
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³"

#: ../../reference/compound_stmts.rst:711
msgid "Coroutine function definition"
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³é–¢æ•°å®šç¾©"

#: ../../reference/compound_stmts.rst:721
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`).  In the body of a coroutine, any ``await`` and "
"``async`` identifiers become reserved keywords; :keyword:`await` "
"expressions, :keyword:`async for` and :keyword:`async with` can only be used"
" in coroutine bodies."
msgstr ""
"Python ã§å®Ÿè¡Œã—ã¦ã„ã‚‹ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯å¤šãã®æ™‚ç‚¹ã§ä¸€æ™‚åœæ­¢ã¨å†é–‹ãŒã§ãã¾ã™ (:term:`coroutine` ã‚’å‚ç…§)ã€‚\n"
"ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®æœ¬ä½“ã§ã¯ã€ ``await`` è­˜åˆ¥å­ã¨ ``async`` è­˜åˆ¥å­ã¯ã©ã‚Œã‚‚äºˆç´„èªã«ãªã‚Šã¾ã™;\n"
":keyword:`await` å¼ã§ã‚ã‚‹ :keyword:`async for` ã¨ :keyword:`async with` ã¯ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®æœ¬ä½“ã§ã—ã‹ä½¿ãˆã¾ã›ã‚“ã€‚"

#: ../../reference/compound_stmts.rst:727
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
" ``await`` ã‚„ ``async`` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒãªãã¦ã‚‚ã€``async def`` æ§‹æ–‡ã§å®šç¾©ã•ã‚ŒãŸé–¢æ•°ã¯å¸¸ã«ã‚³ãƒ«ãƒ¼ãƒãƒ³é–¢æ•°ã§ã™ã€‚"

#: ../../reference/compound_stmts.rst:730
msgid ""
"It is a :exc:`SyntaxError` to use ``yield from`` expressions in ``async "
"def`` coroutines."
msgstr ""
"``async def`` ã‚³ãƒ«ãƒ¼ãƒãƒ³å†…ã§ ``yield from`` å¼ã‚’ä½¿ç”¨ã™ã‚‹ã¨ :exc:`SyntaxError` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:733
msgid "An example of a coroutine function::"
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³é–¢æ•°ã®ä¾‹::"

#: ../../reference/compound_stmts.rst:744
msgid "The :keyword:`async for` statement"
msgstr ":keyword:`async for` æ–‡"

#: ../../reference/compound_stmts.rst:749
msgid ""
"An :term:`asynchronous iterable` is able to call asynchronous code in its "
"*iter* implementation, and :term:`asynchronous iterator` can call "
"asynchronous code in its *next* method."
msgstr ""
":term:`asynchronous iterable` ã® *iter* ã®å®Ÿè£…ã‹ã‚‰ã¯éåŒæœŸã®ã‚³ãƒ¼ãƒ‰ãŒå‘¼ã¹ã€ :term:`asynchronous"
" iterator` ã® *next* ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰ã‚‚éåŒæœŸã®ã‚³ãƒ¼ãƒ‰ãŒå‘¼ã¹ã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:753
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterators."
msgstr "``async for`` æ–‡ã«ã‚ˆã£ã¦éåŒæœŸãªã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ç°¡å˜ã«ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:756
#: ../../reference/compound_stmts.rst:796
msgid "The following code::"
msgstr "ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰::"

#: ../../reference/compound_stmts.rst:763
#: ../../reference/compound_stmts.rst:801
msgid "Is semantically equivalent to::"
msgstr "ã¯æ„å‘³è«–çš„ã«ä»¥ä¸‹ã¨ç­‰ä¾¡ã§ã™::"

#: ../../reference/compound_stmts.rst:778
msgid "See also :meth:`__aiter__` and :meth:`__anext__` for details."
msgstr "è©³ç´°ã¯ :meth:`__aiter__` ã‚„ :meth:`__anext__` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/compound_stmts.rst:780
msgid ""
"It is a :exc:`SyntaxError` to use ``async for`` statement outside of an "
":keyword:`async def` function."
msgstr ""
":keyword:`async def` é–¢æ•°å¤–ã§ ``async for`` æ–‡ã‚’ä½¿ç”¨ã™ã‚‹ã¨ :exc:`SyntaxError` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:788
msgid "The :keyword:`async with` statement"
msgstr ":keyword:`async with` æ–‡"

#: ../../reference/compound_stmts.rst:793
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is"
" able to suspend execution in its *enter* and *exit* methods."
msgstr ""
":term:`asynchronous context manager` ã¯ã€ *enter* ãƒ¡ã‚½ãƒƒãƒ‰ã¨ *exit* "
"ãƒ¡ã‚½ãƒƒãƒ‰å†…éƒ¨ã§å®Ÿè¡Œã‚’ä¸€æ™‚åœæ­¢ã§ãã‚‹ :term:`context manager` ã§ã™ã€‚"

#: ../../reference/compound_stmts.rst:816
msgid "See also :meth:`__aenter__` and :meth:`__aexit__` for details."
msgstr "è©³ç´°ã¯ :meth:`__aenter__` ã‚„ :meth:`__aexit__` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/compound_stmts.rst:818
msgid ""
"It is a :exc:`SyntaxError` to use ``async with`` statement outside of an "
":keyword:`async def` function."
msgstr ""
":keyword:`async def` é–¢æ•°å¤–ã§ ``async with`` æ–‡ã‚’ä½¿ç”¨ã™ã‚‹ã¨ :exc:`SyntaxError` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:824
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - async æ§‹æ–‡ãŠã‚ˆã³ await æ§‹æ–‡ä»˜ãã®ã‚³ãƒ«ãƒ¼ãƒãƒ³"

#: ../../reference/compound_stmts.rst:824
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and"
" added supporting syntax."
msgstr ""

#: ../../reference/compound_stmts.rst:829
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../reference/compound_stmts.rst:830
msgid ""
"The exception is propagated to the invocation stack unless there is a "
":keyword:`finally` clause which happens to raise another exception. That new"
" exception causes the old one to be lost."
msgstr ""
"ä¾‹å¤–ã¯ã€åˆ¥ã®ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ã‚ˆã†ãª :keyword:`finally` "
"ç¯€ãŒç„¡ã„å ´åˆã«ã®ã¿å‘¼ã³å‡ºã—ã‚¹ã‚¿ãƒƒã‚¯ã¸ä¼ã‚ã‚Šã¾ã™ã€‚æ–°ã—ã„ä¾‹å¤–ã«ã‚ˆã£ã¦ã€å¤ã„ä¾‹å¤–ã¯å¤±ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:834
msgid ""
"Currently, control \"flows off the end\" except in the case of an exception "
"or the execution of a :keyword:`return`, :keyword:`continue`, or "
":keyword:`break` statement."
msgstr ""
"ç¾åœ¨ã€åˆ¶å¾¡ãŒ \"æœ«å°¾ã«åˆ°é”ã™ã‚‹\" ã®ã¯ã€ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸã‚Šã€ :keyword:`return`, :keyword:`continue`, ã¾ãŸã¯ "
":keyword:`break` æ–‡ãŒå®Ÿè¡Œã•ã‚Œã‚‹å ´åˆã‚’é™¤ãã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:838
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""
"é–¢æ•°ã®æœ¬ä½“ã®æœ€åˆã®æ–‡ã¨ã—ã¦ç¾ã‚ã‚Œã‚‹æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¯ã€ãã®é–¢æ•°ã® ``__doc__`` "
"å±æ€§ã«å¤‰æ›ã•ã‚Œã€ãã®é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—(:term:`docstring`) ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/compound_stmts.rst:842
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's "
":term:`docstring`."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã®æœ¬ä½“ã®æœ€åˆã®æ–‡ã¨ã—ã¦ç¾ã‚ã‚Œã‚‹æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¯ã€ãã®åå‰ç©ºé–“ã® ``__doc__`` "
"è¦ç´ ã¨ãªã‚Šã€ãã®ã‚¯ãƒ©ã‚¹ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—(:term:`docstring`)ã«ãªã‚Šã¾ã™ã€‚"
