# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017-2018
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2015-2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-06 15:07+0900\n"
"PO-Revision-Date: 2018-05-19 22:52+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr "ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«"

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€å€¤ã€ãŠã‚ˆã³å‹"

#: ../../reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer,\" code is also represented by objects.)"
msgstr "Python ã«ãŠã‘ã‚‹ :dfn:`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (object)` ã¨ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½è±¡çš„ã«è¡¨ã—ãŸã‚‚ã®ã§ã™ã€‚Python ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã‘ã‚‹ãƒ‡ãƒ¼ã‚¿ã¯å…¨ã¦ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé–“ã®é–¢ä¿‚ã¨ã—ã¦è¡¨ã•ã‚Œã¾ã™ã€‚(ã‚ã‚‹æ„å‘³ã§ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚³ãƒ¼ãƒ‰ã‚‚ã¾ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¡¨ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ãƒ•ã‚©ãƒ³ãƒ»ãƒã‚¤ãƒãƒ³: Von Neumann ã® \"ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨˜æ†¶æ–¹å¼ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿: stored program computer\" ã®ãƒ¢ãƒ‡ãƒ«ã«é©åˆã—ã¾ã™ã€‚)"

#: ../../reference/datamodel.rst:32
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The ':keyword:`is`' operator compares the identity of "
"two objects; the :func:`id` function returns an integer representing its "
"identity (currently implemented as its address). An object's :dfn:`type` is "
"also unchangeable. [#]_ An object's type determines the operations that the "
"object supports (e.g., \"does it have a length?\") and also defines the "
"possible values for objects of that type.  The :func:`type` function returns"
" an object's type (which is an object itself).  The *value* of some objects "
"can change.  Objects whose value can change are said to be *mutable*; "
"objects whose value is unchangeable once they are created are called "
"*immutable*. (The value of an immutable container object that contains a "
"reference to a mutable object can change when the latter's value is changed;"
" however the container is still considered immutable, because the collection"
" of objects it contains cannot be changed.  So, immutability is not strictly"
" the same as having an unchangeable value, it is more subtle.) An object's "
"mutability is determined by its type; for instance, numbers, strings and "
"tuples are immutable, while dictionaries and lists are mutable."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£å€¤ (identity) ã€å‹ (type) ã€ãã—ã¦å€¤ (value) ã‚’æŒã¡ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä¸€åº¦ç”Ÿæˆã•ã‚Œã‚‹ã¨ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® *ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£å€¤* ã¯æ±ºã—ã¦å¤‰åŒ–ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã›ã‚“; ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£å€¤ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ãƒ¢ãƒªä¸Šã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨è€ƒãˆã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚æ¼”ç®—å­ ':keyword:`is`' ã¯ã€äºŒã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé–“ã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£å€¤ã‚’æ¯”è¼ƒã—ã¾ã™; é–¢æ•° :func:`id` ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£å€¤ã‚’è¡¨ã™æ•´æ•° (ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ãƒ¢ãƒªä¸Šã®ã‚¢ãƒ‰ãƒ¬ã‚¹) ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :dfn:`å‹` ã‚‚ã¾ãŸå¤‰ã‚ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ [#]_ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã¯ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚µãƒãƒ¼ãƒˆã™ã‚‹æ“ä½œ (\"é•·ã•ã‚’æŒã£ã¦ã„ã‚‹ã‹ï¼Ÿ\" ãªã©) ã‚’æ±ºå®šã—ã€ãã®å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå–ã‚Šã†ã‚‹å€¤ã«ã¤ã„ã¦å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ :func:`type` é–¢æ•°ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ (å‹è‡ªä½“ã‚‚ä¸€ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™) ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã£ã¦ã¯ã€ *å€¤ (value)* ã‚’å¤‰ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å€¤ã‚’å¤‰ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ *å¤‰æ›´å¯èƒ½ (mutable)* ã§ã‚ã‚‹ã¨ã„ã„ã¾ã™; å€¤ã‚’ä¸€åº¦è¨­å®šã™ã‚‹ã¨ã€ãã®å¾Œã¯å¤‰ãˆã‚‹ã“ã¨ãŒã§ããªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ *å¤‰æ›´ä¸èƒ½ (immutable)* ã§ã‚ã‚‹ã¨å‘¼ã³ã¾ã™ã€‚ (å¤‰æ›´ä¸èƒ½ãªã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’å«ã‚“ã§ã„ã‚‹å ´åˆã€ãã®å€¤ã¯å¾Œè€…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¤‰æ›´ã«ã‚ˆã£ã¦å¤‰ã‚ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™; ãã®å ´åˆã§ã‚‚ã€ã‚³ãƒ³ãƒ†ãƒŠã®å«ã‚“ã§ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é›†ã¾ã‚Šã¯å¤‰ã‚ã‚‰ãªã„ãŸã‚ã€ã‚³ãƒ³ãƒ†ãƒŠã¯å¤‰æ›´ä¸èƒ½ã¨è€ƒãˆã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€å¤‰æ›´ä¸èƒ½æ€§ (immutability) ã¯ã€å³å¯†ã«ã¯å¤‰æ›´ã§ããªã„å€¤ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ã¨ã¯é•ã„ã€ã‚‚ã£ã¨å¾®å¦™ãªæ¦‚å¿µã§ã™ã€‚) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¤‰æ›´å¯èƒ½æ€§ã¯å‹ã§æ±ºå®šã•ã‚Œã¾ã™; ä¾‹ãˆã°ã€æ•°å€¤ã€æ–‡å­—åˆ—ã€ãŠã‚ˆã³ã‚¿ãƒ—ãƒ«ã¯å¤‰æ›´ä¸èƒ½ã§ã‚ã‚Šã€è¾æ›¸ã‚„ãƒªã‚¹ãƒˆã¯å¤‰æ›´å¯èƒ½ã§ã™ã€‚"

#: ../../reference/datamodel.rst:55
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ˜ç¤ºçš„ã«ç ´å£Šã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“; ã—ã‹ã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åˆ°é”ä¸èƒ½ (unreachable) ã«ãªã‚‹ã¨ã€ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ (garbage-collection) ã«ã‚ˆã£ã¦å‡¦ç†ã•ã‚Œã¾ã™ã€‚å®Ÿè£…ã§ã¯ã€ã”ã¿åé›†ã‚’é…ã‚‰ã›ãŸã‚Šã€å…¨ãè¡Œã‚ãªã„ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ --- åˆ°é”å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã”ã¿åé›†å‡¦ç†ã—ã¦ã—ã¾ã‚ãªã„ã‹ãã‚Šã€ã©ã†å®Ÿè£…ã™ã‚‹ã‹ã¯å®Ÿè£…å“è³ªã®å•é¡Œã§ã™ã€‚"

#: ../../reference/datamodel.rst:63
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (ex: "
"always close files)."
msgstr "ç¾åœ¨ã® CPython å®Ÿè£…ã§ã¯å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ(reference-counting) æ–¹å¼ã‚’ä½¿ã£ã¦ãŠã‚Šã€(ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨ã—ã¦) å¾ªç’°å‚ç…§ã‚’è¡Œã£ã¦ã„ã‚‹ã”ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é…å»¶æ¤œå‡ºã—ã¾ã™ã€‚ã“ã®å®Ÿè£…ã§ã¯ã»ã¨ã‚“ã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆ°é”ä¸èƒ½ã«ãªã‚‹ã¨åŒæ™‚ã«å‡¦ç†ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€å¾ªç’°å‚ç…§ã‚’å«ã‚€ã”ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åé›†ãŒç¢ºå®Ÿã«è¡Œã‚ã‚Œã‚‹ã‚ˆã†ä¿è¨¼ã—ã¦ã„ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å¾ªç’°å‚ç…§ã‚’æŒã¤ã”ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåé›†ã®åˆ¶å¾¡ã«ã¤ã„ã¦ã¯ã€ :mod:`gc` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ CPythonä»¥å¤–ã®å®Ÿè£…ã¯åˆ¥ã®æ–¹å¼ã‚’ä½¿ã£ã¦ãŠã‚Šã€CPythonã‚‚å°†æ¥ã¯åˆ¥ã®æ–¹å¼ã‚’ä½¿ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒåˆ°é”ä¸èƒ½ã«ãªã£ãŸã¨ãã«å³åº§ã«çµ‚äº†å‡¦ç†ã•ã‚Œã‚‹ã“ã¨ã«é ¼ã‚‰ãªã„ã§ãã ã•ã„ (ä¾‹ãˆã°ã€ãƒ•ã‚¡ã‚¤ãƒ«ã¯å¿…ãšé–‰ã˜ã¦ãã ã•ã„)ã€‚"

#: ../../reference/datamodel.rst:72
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a ':keyword:`try`...\\ :keyword:`except`' "
"statement may keep objects alive."
msgstr "å®Ÿè£…ã®ãƒˆãƒ¬ãƒ¼ã‚¹æ©Ÿèƒ½ã‚„ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ã‚’ä½¿ãˆã°ã€é€šå¸¸ã¯åé›†ã•ã‚Œã¦ã—ã¾ã†ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿã‹ã—ã¦ãŠãã“ã¨ãŒã‚ã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã¾ãŸã€ ':keyword:`try`...\\ :keyword:`except`' æ–‡ã‚’ä½¿ã£ã¦ä¾‹å¤–ã‚’æ•æ‰ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã¨ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿã‹ã—ã¦ãŠãã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:77
msgid ""
"Some objects contain references to \"external\" resources such as open files"
" or windows.  It is understood that these resources are freed when the "
"object is garbage-collected, but since garbage collection is not guaranteed "
"to happen, such objects also provide an explicit way to release the external"
" resource, usually a :meth:`close` method. Programs are strongly recommended"
" to explicitly close such objects.  The ':keyword:`try`...\\ "
":keyword:`finally`' statement provides a convenient way to do this."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã£ã¦ã¯ã€é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚„ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã¨ã„ã£ãŸã€ \"å¤–éƒ¨ (external) ã®\" ãƒªã‚½ãƒ¼ã‚¹ã«å¯¾ã™ã‚‹å‚ç…§ã‚’è¡Œã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒªã‚½ãƒ¼ã‚¹ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã”ã¿åé›†ã•ã‚ŒãŸéš›ã«è§£æ”¾ã•ã‚Œã‚‹ã‚‚ã®ã¨ç†è§£ã•ã‚Œã¦ã„ã¾ã™ãŒã€ã”ã¿åé›†ãŒè¡Œã‚ã‚Œã‚‹ä¿è¨¼ã¯ãªã„ã®ã§ã€ã“ã†ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯å¤–éƒ¨ãƒªã‚½ãƒ¼ã‚¹ã‚’æ˜ç¤ºçš„ã«è§£æ”¾ã™ã‚‹æ–¹æ³•ã€å¤§æŠµã¯ :meth:`close` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ã“ã†ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ˜ç¤ºçš„ã« close ã™ã‚‹ã‚ˆã†å¼·ãå¥¨ã‚ã¾ã™ã€‚æ“ä½œã‚’ã™ã‚‹éš›ã«ã¯ã€':keyword:`try`...\\ :keyword:`finally`' æ–‡ã‚’ä½¿ã†ã¨ä¾¿åˆ©ã§ã™ã€‚"

#: ../../reference/datamodel.rst:87
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk"
" about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr "ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ã‚’ã‚‚ã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ã‚ã‚Šã¾ã™; ã“ã‚Œã‚‰ã¯ *ã‚³ãƒ³ãƒ†ãƒŠ (container)* ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¾‹ã¨ã—ã¦ã€ã‚¿ãƒ—ãƒ«ã€ãƒªã‚¹ãƒˆã€ãŠã‚ˆã³è¾æ›¸ãŒæŒ™ã’ã‚‰ã‚Œã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§è‡ªä½“ãŒã‚³ãƒ³ãƒ†ãƒŠã®å€¤ã®ä¸€éƒ¨ã§ã™ã€‚ã»ã¨ã‚“ã©ã®å ´åˆã€ã‚³ãƒ³ãƒ†ãƒŠã®å€¤ã¨ã„ã†ã¨ã€ã‚³ãƒ³ãƒ†ãƒŠã«å…¥ã£ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã®ã“ã¨ã‚’æŒ‡ã—ã€ãã‚Œã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã§ã¯ã‚ã‚Šã¾ã›ã‚“; ã—ã‹ã—ãªãŒã‚‰ã€ã‚³ãƒ³ãƒ†ãƒŠã®å¤‰æ›´å¯èƒ½æ€§ã«ã¤ã„ã¦è¿°ã¹ã‚‹å ´åˆã€ä»Šã¾ã•ã«ã‚³ãƒ³ãƒ†ãƒŠã«å…¥ã£ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ã“ã¨ã‚’æŒ‡ã—ã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ (ã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ã«) å¤‰æ›´ä¸èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’å«ã‚€å ´åˆã€ãã®å€¤ãŒå¤‰åŒ–ã™ã‚‹ã®ã¯å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚ã€ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:96
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer"
" to the same object with the value one, depending on the implementation, but"
" after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two "
"different, unique, newly created empty lists. (Note that ``c = d = []`` "
"assigns the same object to both ``c`` and ``d``.)"
msgstr "å‹ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹•ä½œã®ã»ã¨ã‚“ã©å…¨ã¦ã«å½±éŸ¿ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãŒé‡è¦ã‹ã©ã†ã‹ã§ã•ãˆã€ã‚ã‚‹æ„å‘³ã§ã¯å‹ã«å·¦å³ã•ã‚Œã¾ã™: å¤‰æ›´ä¸èƒ½ãªå‹ã§ã¯ã€æ–°ãŸãªå€¤ã‚’è¨ˆç®—ã™ã‚‹ã‚ˆã†ãªæ“ä½œã‚’è¡Œã†ã¨ã€å®Ÿéš›ã«ã¯åŒã˜å‹ã¨å€¤ã‚’æŒã£ãŸæ—¢å­˜ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’è¿”ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ãŒã€å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãã®ã‚ˆã†ãªå‹•ä½œã¯èµ·ã“ã‚Šãˆã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ ``a = 1; b = 1`` ã¨ã™ã‚‹ã¨ã€ ``a`` ã¨ ``b`` ã¯å€¤ 1 ã‚’æŒã¤åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã™ã‚‹ã¨ãã‚‚ã‚ã‚‹ã—ã€ãã†ã§ãªã„ã¨ãã‚‚ã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯å®Ÿè£…ã«ä¾å­˜ã—ã¾ã™ã€‚ã—ã‹ã—ã€ ``c = []; d = []`` ã¨ã™ã‚‹ã¨ã€ ``c`` ã¨ ``d`` ã¯ãã‚Œãã‚ŒäºŒã¤ã®ç•°ãªã£ãŸã€äº’ã„ã«ä¸€æ„ãªã€æ–°ãŸã«ä½œæˆã•ã‚ŒãŸç©ºã®ãƒªã‚¹ãƒˆã‚’å‚ç…§ã™ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã¾ã™ã€‚ (``c = d = []`` ã¨ã™ã‚‹ã¨ã€ ``c`` ã¨ ``d`` ã®ä¸¡æ–¹ã«åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»£å…¥ã—ã¾ã™)"

#: ../../reference/datamodel.rst:110
msgid "The standard type hierarchy"
msgstr "æ¨™æº–å‹ã®éšå±¤"

#: ../../reference/datamodel.rst:119
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the"
" type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.)."
msgstr "ä»¥ä¸‹ã¯ Python ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹å‹ã®ãƒªã‚¹ãƒˆã§ã™ã€‚(Cã€Javaã€ã¾ãŸã¯å®Ÿè£…ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ãã®ä»–ã®è¨€èªã§æ›¸ã‹ã‚ŒãŸ) æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ãã®ä»–ã«æ–°ãŸãªå‹ã‚’å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å°†æ¥ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã§ã¯ã€å‹ã®éšå±¤ã«æ–°ãŸãªå‹ (æ•´æ•°ã‚’ä½¿ã£ã¦åŠ¹ç‡çš„ã«è¨˜æ†¶ã•ã‚Œã‚‹æœ‰ç†æ•°å‹ã€ãªã©) ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:129
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation"
" and are not intended for general use.  Their definition may change in the "
"future."
msgstr "ä»¥ä¸‹ã«èª¬æ˜ã™ã‚‹å‹ã®ã„ãã¤ã‹ã«ã¯ã€'ç‰¹æ®Šå±æ€§ (special attribute)' ã¨é¡Œã•ã‚ŒãŸæ®µè½ãŒé€£ã­ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å±æ€§ã¯å®Ÿè£…ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ‰‹æ®µã‚’æä¾›ã™ã‚‹ã‚‚ã®ã§ã€ä¸€èˆ¬çš„ãªç”¨é€”ã«åˆ©ç”¨ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ç‰¹æ®Šå±æ€§ã®å®šç¾©ã¯å°†æ¥å¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:139
msgid "None"
msgstr "None"

#: ../../reference/datamodel.rst:136
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from"
" functions that don't explicitly return anything. Its truth value is false."
msgstr "ã“ã®å‹ã«ã¯å˜ä¸€ã®å€¤ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®å€¤ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãŸã ä¸€ã¤ã—ã‹å­˜åœ¨ã—ã¾ã›ã‚“ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿å ``None`` ã§ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€æ§˜ã€…ãªçŠ¶æ³ã§å€¤ãŒå­˜åœ¨ã—ãªã„ã“ã¨ã‚’ã—ã‚ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€æ˜ç¤ºçš„ã«å€¤ã‚’è¿”ã•ãªã„é–¢æ•°ã¯ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ ``None`` ã®çœŸå€¤ (truth value) ã¯å½ (false) ã§ã™ã€‚"

#: ../../reference/datamodel.rst:149
msgid "NotImplemented"
msgstr "NotImplemented"

#: ../../reference/datamodel.rst:144
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods may return this value if they do"
" not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  Its truth value is true."
msgstr "ã“ã®å‹ã«ã¯å˜ä¸€ã®å€¤ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®å€¤ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãŸã ä¸€ã¤ã—ã‹å­˜åœ¨ã—ã¾ã›ã‚“ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿å ``NotImplemented`` ã§ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã¾ã™ã€‚æ•°å€¤æ¼”ç®—ã«é–¢ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚„æ‹¡å¼µæ¯”è¼ƒ (rich comparison) ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€è¢«æ¼”ç®—å­ãŒè©²å½“ã™ã‚‹æ¼”ç®—ã‚’è¡Œã†ãŸã‚ã®å®Ÿè£…ã‚’ã‚‚ãŸãªã„å ´åˆã€ã“ã®å€¤ã‚’è¿”ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚(æ¼”ç®—å­ã«ã‚ˆã£ã¦ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒé–¢é€£ã®ã‚ã‚‹æ¼”ç®—ã‚’è©¦ã—ãŸã‚Šã€ä»–ã®ä»£æ›¿æ“ä½œã‚’è¡Œã„ã¾ã™ã€‚) çœŸå€¤ã¯çœŸ (true) ã§ã™ã€‚"

#: ../../reference/datamodel.rst:157
msgid "Ellipsis"
msgstr "Ellipsis"

#: ../../reference/datamodel.rst:154
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``Ellipsis``. It is used "
"to indicate the presence of the ``...`` syntax in a slice.  Its truth value "
"is true."
msgstr "ã“ã®å‹ã«ã¯å˜ä¸€ã®å€¤ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®å€¤ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãŸã ä¸€ã¤ã—ã‹å­˜åœ¨ã—ã¾ã›ã‚“ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿å ``Ellipsis`` ã§ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã¾ã™ã€‚ã‚¹ãƒ©ã‚¤ã‚¹å†…ã« ``...`` æ§‹æ–‡ãŒã‚ã‚‹å ´åˆã«ä½¿ã‚ã‚Œã¾ã™ã€‚çœŸå€¤ã¯çœŸ (true)ã§ã™ã€‚"

#: ../../reference/datamodel.rst:249
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../../reference/datamodel.rst:162
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable;"
" once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr "æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã«ã‚ˆã£ã¦ä½œæˆã•ã‚ŒãŸã‚Šã€ç®—è¡“æ¼”ç®—ã‚„çµ„ã¿è¾¼ã¿ã®ç®—è¡“é–¢æ•°ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚æ•°å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤‰æ›´ä¸èƒ½ã§ã™; ä¸€åº¦å€¤ãŒç”Ÿæˆã•ã‚Œã‚‹ã¨ã€äºŒåº¦ã¨å¤‰æ›´ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚Python ã®æ•°å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã„ã†ã¾ã§ã‚‚ãªãæ•°å­¦ã§è¨€ã†ã¨ã“ã‚ã®æ•°å€¤ã¨å¼·ãé–¢ä¿‚ã—ã¦ã„ã¾ã™ãŒã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿å†…ã§æ•°å€¤ã‚’è¡¨ç¾ã™ã‚‹éš›ã«ä¼´ã†åˆ¶é™ã‚’å—ã‘ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:168
msgid ""
"Python distinguishes between integers, floating point numbers, and complex "
"numbers:"
msgstr "Python ã¯æ•´æ•°ã€æµ®å‹•å°æ•°ç‚¹æ•°ã€è¤‡ç´ æ•°ã®é–“ã§åŒºåˆ¥ã‚’è¡Œã£ã¦ã„ã¾ã™:"

#: ../../reference/datamodel.rst:224
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral` (æ•´æ•°)"

#: ../../reference/datamodel.rst:174
msgid ""
"These represent elements from the mathematical set of integers (positive and"
" negative)."
msgstr "æ•´æ•°å‹ã¯ã€æ•´æ•°(æ­£ã®æ•°ãŠã‚ˆã³è² ã®æ•°)ã‚’è¡¨ã™æ•°å­¦çš„é›†åˆå†…ã«ãŠã‘ã‚‹è¦ç´ ã‚’è¡¨ç¾ã™ã‚‹å‹ã§ã™ã€‚"

#: ../../reference/datamodel.rst:177
msgid "There are three types of integers:"
msgstr "ä»¥ä¸‹ã«ä¸‰ã¤ã®æ•´æ•°å‹ã‚’ç¤ºã—ã¾ã™:"

#: ../../reference/datamodel.rst:192
msgid "Plain integers"
msgstr "(é€šå¸¸ã®) æ•´æ•°å‹ (plain integer)"

#: ../../reference/datamodel.rst:184
msgid ""
"These represent numbers in the range -2147483648 through 2147483647. (The "
"range may be larger on machines with a larger natural word size, but not "
"smaller.)  When the result of an operation would fall outside this range, "
"the result is normally returned as a long integer (in some cases, the "
"exception :exc:`OverflowError` is raised instead).  For the purpose of shift"
" and mask operations, integers are assumed to have a binary, 2's complement "
"notation using 32 or more bits, and hiding no bits from the user (i.e., all "
"4294967296 different bit patterns correspond to different values)."
msgstr "-2147483648 ã‹ã‚‰ 2147483647 ã¾ã§ã®æ•´æ•°ã‚’è¡¨ç¾ã—ã¾ã™ (åŸºæœ¬ãƒ¯ãƒ¼ãƒ‰ã‚µã‚¤ã‚º: natural word size ãŒã‚ˆã‚Šå¤§ããªãƒã‚·ãƒ³ã§ã¯ã‚ˆã‚Šå¤§ããªå®šç¾©åŸŸã«ãªã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚ã‚ˆã‚Šå°ã•ããªã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚) æ¼”ç®—ã®çµæœãŒå®šç¾©åŸŸã‚’è¶…ãˆãŸå€¤ã«ãªã£ãŸå ´åˆã€çµæœã¯é€šå¸¸é•·æ•´æ•°ã§è¿”ã•ã‚Œã¾ã™ (å ´åˆã«ã‚ˆã£ã¦ã¯ã€ :exc:`OverflowError` ãŒé€å‡ºã•ã‚Œã¾ã™) ã€‚ã‚·ãƒ•ãƒˆæ¼”ç®—ã‚„ãƒã‚¹ã‚¯æ¼”ç®—ã®ãŸã‚ã«ã€æ•´æ•°ã¯ 32 ãƒ“ãƒƒãƒˆä»¥ä¸Šã® 2 ã®è£œæ•°ã§è¡¨ã•ã‚ŒãŸãƒã‚¤ãƒŠãƒªè¡¨ç¾ã‚’æŒã¤ (ã™ãªã‚ã¡ã€4294967296 ã®ç•°ãªã£ãŸãƒ“ãƒƒãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³å…¨ã¦ãŒç•°ãªã‚‹å€¤ã‚’æŒã¤) ã¨ä»®å®šã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:201
msgid "Long integers"
msgstr "é•·æ•´æ•°å‹ (long integer)"

#: ../../reference/datamodel.rst:197
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr "é•·æ•´æ•°ã¯ç„¡é™ã®å®šç¾©åŸŸã‚’æŒã¡ã€åˆ©ç”¨å¯èƒ½ãª (ä»®æƒ³) ãƒ¡ãƒ¢ãƒªã‚µã‚¤ã‚ºã®åˆ¶é™ã®ã¿ã‚’ã†ã‘ã¾ã™ã€‚é•·æ•´æ•°ã¯ã‚·ãƒ•ãƒˆæ¼”ç®—ã‚„ãƒã‚¹ã‚¯æ¼”ç®—ã®ãŸã‚ã«ãƒã‚¤ãƒŠãƒªè¡¨ç¾ã‚’ã‚‚ã¤ã‚‚ã®ã¨ä»®å®šã•ã‚Œã¾ã™ã€‚è² ã®æ•°ã¯ç¬¦å·ãƒ“ãƒƒãƒˆãŒå·¦ã«ç„¡é™ã«å»¶ã³ã¦ã„ã‚‹ã‚ˆã†ãªéŒ¯è¦šã‚’ä¸ãˆã‚‹ 2 ã®è£œæ•°è¡¨ç¾ã®å¤‰å‹ã§è¡¨ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:214
msgid "Booleans"
msgstr "ãƒ–ãƒ¼ãƒ«å‹ (boolean)"

#: ../../reference/datamodel.rst:209
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects."
" The Boolean type is a subtype of plain integers, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception"
" being that when converted to a string, the strings ``\"False\"`` or "
"``\"True\"`` are returned, respectively."
msgstr "çœŸå½å€¤ã® False ã¨ True ã‚’è¡¨ã—ã¾ã™ã€‚``False`` ã¨ ``True`` ã‚’è¡¨ã™ 2 ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ãŒãƒ–ãƒ¼ãƒ«å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ãƒ–ãƒ¼ãƒ«å‹ã¯æ•´æ•°å‹ã®éƒ¨åˆ†å‹ã§ã‚ã‚Šã€ã»ã¨ã‚“ã©ã®çŠ¶æ³ã§ãã‚Œãã‚Œ 0 ã¨ 1 ã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã„ã¾ã™ãŒã€ä¾‹å¤–ã¨ã—ã¦æ–‡å­—åˆ—ã«å¤‰æ›ã•ã‚ŒãŸã¨ãã¯ãã‚Œãã‚Œ ``\"False\"`` ãŠã‚ˆã³ ``\"True\"`` ã¨ã„ã†æ–‡å­—åˆ—ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:218
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers and the least surprises when switching between the plain and long "
"integer domains.  Any operation, if it yields a result in the plain integer "
"domain, will yield the same result in the long integer domain or when using "
"mixed operands.  The switch between domains is transparent to the "
"programmer."
msgstr "æ•´æ•°è¡¨ç¾ã«é–¢ã™ã‚‹è¦å‰‡ã¯ã€ã‚·ãƒ•ãƒˆæ¼”ç®—ã‚„ãƒã‚¹ã‚¯æ¼”ç®—ã«ãŠã„ã¦ã€è² ã®æ•´æ•°ã‚‚å«ã‚ã¦æœ€ã‚‚æœ‰æ„ç¾©ãªè§£é‡ˆãŒã§ãã‚‹ã‚ˆã†ã«ã€ã‹ã¤é€šå¸¸ã®æ•´æ•°ã¨é•·æ•´æ•°ã¨ã®é–“ã§å®šç¾©åŸŸã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹éš›ã«ã§ãã‚‹ã ã‘æ··ä¹±ã—ãªã„ã‚ˆã†ã«æ±ºã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ã™ã¹ã¦ã®æ¼”ç®—ã§ã€æ¼”ç®—çµæœãŒã‚ªãƒ¼ãƒãƒ•ãƒ­ãƒ¼ã‚’èµ·ã“ã•ãšã«æ•´æ•°ã®å®šç¾©åŸŸã®å€¤ã«ãªã‚‹å ´åˆã¯ã€é•·æ•´æ•°ã‚’ä½¿ã£ãŸå ´åˆã§ã‚‚ã€è¢«æ¼”ç®—å­ã«æ•´æ•°ã¨é•·æ•´æ•°ã‚’æ··åˆã—ãŸå ´åˆã§ã‚‚åŒã˜çµæœã«ãªã‚Šã¾ã™ã€‚å®šç¾©åŸŸã®åˆ‡ã‚Šæ›¿ãˆã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒã«å¯¾ã—ã¦é€éçš„ã«(æ„è­˜ã•ã›ã‚‹ã“ã¨ãªã)è¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:239
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`) (å®Ÿæ•°)"

#: ../../reference/datamodel.rst:233
msgid ""
"These represent machine-level double precision floating point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does"
" not support single-precision floating point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to"
" complicate the language with two kinds of floating point numbers."
msgstr "ã“ã®å‹ã¯è¨ˆç®—æ©Ÿãƒ¬ãƒ™ãƒ«ã®å€ç²¾åº¦æµ®å‹•å°æ•°ç‚¹æ•°ã‚’è¡¨ç¾ã—ã¾ã™ã€‚è¡¨ç¾å¯èƒ½ãªå€¤ã®ç¯„å›²ã‚„ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®æ‰±ã„ã¯è¨ˆç®—æ©Ÿã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ï¼ˆãŠã‚ˆã³ã€Cã‚„Javaã«ã‚ˆã‚‹å®Ÿè£…ï¼‰ã«å¾“ã„ã¾ã™ã€‚Pythonã¯å˜ç²¾åº¦æµ®å‹•å°æ•°ç‚¹æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚ä¸€èˆ¬çš„ã«å˜ç²¾åº¦æµ®å‹•å°æ•°ç‚¹æ•°ã‚’ä½¿ã†ç†ç”±ã¯ãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼ã¨ãƒ¡ãƒ¢ãƒªã®ä½¿ç”¨ã‚’ç¯€ç´„ã™ã‚‹ãŸã‚ã¨èª¬æ˜ã•ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€ã“ã†ã—ãŸç¯€ç´„ã¯Pythonã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ‰±ã†éš›ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã«æ¯”ã¹ã‚Œã°å¾®ã€…ãŸã‚‹ã‚‚ã®ã§ã™ã€‚ã¾ãŸã€2ç¨®é¡ã®æµ®å‹•å°æ•°ç‚¹æ•°å‹ã‚’æŒã¤ã“ã¨ã§è¤‡é›‘ã«ãªã‚‹ç†ç”±ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:249
msgid ":class:`numbers.Complex`"
msgstr ":class:`numbers.Complex` (è¤‡ç´ æ•°)"

#: ../../reference/datamodel.rst:246
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating point numbers.  The same caveats apply as for floating point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr "ã“ã®å‹ã¯ã€è¨ˆç®—æ©Ÿãƒ¬ãƒ™ãƒ«ã§å€ç²¾åº¦ã¨ã•ã‚Œã¦ã„ã‚‹æµ®å‹•å°æ•°ç‚¹ã‚’ 2 ã¤ä¸€çµ„ã«ã—ã¦è¤‡ç´ æ•°ã‚’è¡¨ç¾ã—ã¾ã™ã€‚æµ®å‹•å°æ•°ç‚¹ã«ã¤ã„ã¦è¿°ã¹ãŸã®ã¨åŒã˜æ€§è³ªãŒå½“ã¦ã¯ã¾ã‚Šã¾ã™ã€‚è¤‡ç´ æ•° ``z`` ã®å®Ÿæ•°éƒ¨ãŠã‚ˆã³è™šæ•°éƒ¨ã¯ã€ãã‚Œãã‚Œèª­ã¿å‡ºã—å°‚ç”¨å±æ€§ ``z.real`` ãŠã‚ˆã³ ``z.imag`` ã§å–ã‚Šå‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:386
msgid "Sequences"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ (sequence)"

#: ../../reference/datamodel.rst:259
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr "ã“ã®å‹ã¯ã€æœ‰é™ã®é †åºé›†åˆ (ordered set) ã‚’è¡¨ç¾ã—ã¾ã™ã€‚è¦ç´ ã¯éè² ã®æ•´æ•°ã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚çµ„ã¿è¾¼ã¿é–¢æ•° :func:`len` ã‚’ä½¿ã†ã¨ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®è¦ç´ æ•°ã‚’è¿”ã—ã¾ã™ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒ *n* ã®å ´åˆã€ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã¯ 0, 1, ..., *n* -1 ã‹ã‚‰ãªã‚‹é›†åˆã§ã™ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *a* ã®è¦ç´  *i* ã¯ ``a[i]`` ã§é¸æŠã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:266
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type.  This implies that the index set is renumbered "
"so that it starts at 0."
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã‚¹ãƒ©ã‚¤ã‚¹æ“ä½œ (slice) ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™: ``a[i:j]`` ã¨ã™ã‚‹ã¨ã€ *i* ``<=`` *k* ``<`` *j* ã§ã‚ã‚‹ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ *k* ã‚’ã‚‚ã¤å…¨ã¦ã®è¦ç´ ã‚’é¸æŠã—ã¾ã™ã€‚å¼è¡¨ç¾ã¨ã—ã¦ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ç”¨ã„ãŸå ´åˆã€ã‚¹ãƒ©ã‚¤ã‚¹ã¯åŒã˜å‹ã‚’ã‚‚ã¤æ–°ãŸãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚æ–°ãŸãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å†…ã§ã¯ã€ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹é›†åˆãŒ 0 ã‹ã‚‰å§‹ã¾ã‚‹ã‚ˆã†ã«ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã®å€¤ã‚’æŒ¯ã‚ŠãªãŠã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:273
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ã‚ˆã£ã¦ã¯ã€ç¬¬ä¸‰ã® \"ã‚¹ãƒ†ãƒƒãƒ— (step)\" ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’æŒã¤ \"æ‹¡å¼µã‚¹ãƒ©ã‚¤ã‚¹ (extended slice)\" ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™: ``a[i:j:k]`` ã¯ã€ ``x = i + n*k``, *n* ``>=`` ``0`` ã‹ã¤ *i* ``<=`` *x* ``<`` *j* ã§ã‚ã‚‹ã‚ˆã†ãªã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ *x* ã‚’æŒã¤ã‚ˆã†ãª *a* å…¨ã¦ã®è¦ç´ ã‚’é¸æŠã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:277
msgid "Sequences are distinguished according to their mutability:"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€å¤‰æ›´å¯èƒ½ãªã‚‚ã®ã‹ã€ãã†ã§ãªã„ã‹ã§åŒºåˆ¥ã•ã‚Œã¦ã„ã¾ã™:"

#: ../../reference/datamodel.rst:352
msgid "Immutable sequences"
msgstr "å¤‰æ›´ä¸èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ (immutable sequence)"

#: ../../reference/datamodel.rst:284
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may"
" be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr "å¤‰æ›´ä¸èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ä¸€åº¦ç”Ÿæˆã•ã‚Œã‚‹ã¨ãã®å€¤ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ (ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ãŒå…¥ã£ã¦ã„ã‚‹å ´åˆã€å‚ç…§ã•ã‚Œã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚ã‚ˆãã€ãã®å€¤ã¯å¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™; ã—ã‹ã—ã€å¤‰æ›´ä¸èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç›´æ¥å‚ç…§ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é›†åˆè‡ªä½“ã¯ã€å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚)"

#: ../../reference/datamodel.rst:289
msgid "The following types are immutable sequences:"
msgstr "ä»¥ä¸‹ã®å‹ã¯å¤‰æ›´ä¸èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã§ã™:"

#: ../../reference/datamodel.rst:319
msgid "Strings"
msgstr "æ–‡å­—åˆ—å‹ (string)"

#: ../../reference/datamodel.rst:300
msgid ""
"The items of a string are characters.  There is no separate character type; "
"a character is represented by a string of one item. Characters represent (at"
" least) 8-bit bytes.  The built-in functions :func:`chr` and :func:`ord` "
"convert between characters and nonnegative integers representing the byte "
"values.  Bytes with the values 0--127 usually represent the corresponding "
"ASCII values, but the interpretation of values is up to the program.  The "
"string data type is also used to represent arrays of bytes, e.g., to hold "
"data read from a file."
msgstr "æ–‡å­—åˆ—ã®å„è¦ç´ ã¯æ–‡å­— (character) ã§ã™ã€‚æ–‡å­—å‹ (character type) ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚å˜ä¸€ã®æ–‡å­—ã¯ã€è¦ç´ ãŒä¸€ã¤ã ã‘ã®æ–‡å­—åˆ—ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¾ã™ã€‚å„æ–‡å­—ã¯(å°‘ãªãã¨ã‚‚)8-bit ã® 1 byte ã‚’è¡¨ç¾ã—ã¾ã™ã€‚çµ„ã¿è¾¼ã¿é–¢æ•° :func:`chr` ãŠã‚ˆã³ :func:`ord` ã‚’ä½¿ã†ã¨ã€æ–‡å­—ã¨éè² ã®æ•´æ•°ã§è¡¨ã•ã‚ŒãŸãƒã‚¤ãƒˆå€¤ã®é–“ã§å¤‰æ›ã‚’è¡Œãˆã¾ã™ã€‚0--127 ã®å€¤ã‚’æŒã¤ãƒã‚¤ãƒˆå€¤ã¯ã€é€šå¸¸åŒã˜ ASCII å€¤ã‚’ã‚‚ã¤æ–‡å­—ã‚’è¡¨ç¾ã—ã¦ã„ã¾ã™ãŒã€å€¤ã‚’ã©ã†è§£é‡ˆã™ã‚‹ã‹ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã‚†ã ã­ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚æ–‡å­—åˆ—ãƒ‡ãƒ¼ã‚¿å‹ã¯ã¾ãŸã€ä¾‹ãˆã°ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿å‡ºã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’è¨˜æ†¶ã™ã‚‹ã¨ã„ã£ãŸç”¨é€”ã§ã€ãƒã‚¤ãƒˆå€¤ã®ã‚¢ãƒ¬ã‚¤ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ç”¨ã„ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:316
msgid ""
"(On systems whose native character set is not ASCII, strings may use EBCDIC "
"in their internal representation, provided the functions :func:`chr` and "
":func:`ord` implement a mapping between ASCII and EBCDIC, and string "
"comparison preserves the ASCII order. Or perhaps someone can propose a "
"better rule?)"
msgstr "(ãƒã‚¤ãƒ†ã‚£ãƒ–ã®æ–‡å­—ã‚»ãƒƒãƒˆãŒ ASCIIã§ãªã„ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ :func:`chr` ã‚„ :func:`ord` ãŒ ASCII ã¨ EBCDIC ã¨ã®é–“ã§å¯¾å¿œä»˜ã‘ã‚’è¡Œã£ã¦ãŠã‚Šã€æ–‡å­—åˆ—é–“ã®æ¯”è¼ƒã§ ASCII é †ãŒå®ˆã‚‰ã‚Œã‚‹é™ã‚Šã€æ–‡å­—åˆ—ã®å†…éƒ¨è¡¨ç¾ã¨ã—ã¦ EBCDIC ã‚’ä½¿ã£ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚èª°ã‹ä»–ã«ã‚‚ã£ã¨ã¾ã—ãªãƒ«ãƒ¼ãƒ«ã‚’ãŠæŒã¡ã§ã™ã‹?)"

#: ../../reference/datamodel.rst:340
msgid "Unicode"
msgstr "Unicode æ–‡å­—åˆ—å‹"

#: ../../reference/datamodel.rst:331
msgid ""
"The items of a Unicode object are Unicode code units.  A Unicode code unit "
"is represented by a Unicode object of one item and can hold either a 16-bit "
"or 32-bit value representing a Unicode ordinal (the maximum value for the "
"ordinal is given in ``sys.maxunicode``, and depends on how Python is "
"configured at compile time).  Surrogate pairs may be present in the Unicode "
"object, and will be reported as two separate items.  The built-in functions "
":func:`unichr` and :func:`ord` convert between code units and nonnegative "
"integers representing the Unicode ordinals as defined in the Unicode "
"Standard 3.0. Conversion from and to other encodings are possible through "
"the Unicode method :meth:`encode` and the built-in function :func:`unicode`."
msgstr "Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å„è¦ç´ ã¯ Unicode ã‚³ãƒ¼ãƒ‰å˜ä½ã§ã™ã€‚ Unicode ã‚³ãƒ¼ãƒ‰å˜ä½ã¨ã¯ã€å˜ä¸€ã® Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€Unicode åºæ•°ã‚’è¡¨ç¾ã™ã‚‹ 16-bit ã¾ãŸã¯ 32-bit ã®å€¤ã‚’ä¿æŒã§ãã‚‹ã‚‚ã®ã§ã™ (ã“ã®åºæ•°ã®æœ€å¤§å€¤ã¯ ``sys.maxunicode`` ã§ä¸ãˆã‚‰ã‚Œã¦ãŠã‚Šã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã« Python ãŒã©ã†è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ã«ä¾å­˜ã—ã¾ã™)ã€‚ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå†…ã«ã‚µãƒ­ã‚²ãƒ¼ãƒˆãƒšã‚¢ (surrogate pair) ãŒã‚ã£ã¦ã‚‚ã‚ˆãã€Python ã¯ã‚µãƒ­ã‚²ãƒ¼ãƒˆãƒšã‚¢ã‚’äºŒã¤ã®åˆ¥ã€…ã® Unicode è¦ç´ ã¨ã—ã¦å ±å‘Šã—ã¾ã™ã€‚çµ„ã¿è¾¼ã¿é–¢æ•° :func:`unichr` ãŠã‚ˆã³ :func:`ord` ã¯ã€ã‚³ãƒ¼ãƒ‰å˜ä½ã¨éè² ã®æ•´æ•°ã§è¡¨ã•ã‚ŒãŸ Unicode æ¨™æº– 3.0 ã§å®šç¾©ã•ã‚ŒãŸ Unicode åºæ•°ã¨ã®é–“ã§å¤‰æ›ã‚’è¡Œã„ã¾ã™ã€‚ä»–ã®æ–‡å­—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰å½¢å¼ã¨ã®ç›¸äº’å¤‰æ›ã¯ã€ Unicode ãƒ¡ã‚½ãƒƒãƒ‰ :meth:`encode` ãŠã‚ˆã³çµ„ã¿è¾¼ã¿é–¢æ•° :func:`unicode` ã§è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:352
msgid "Tuples"
msgstr "ã‚¿ãƒ—ãƒ«å‹ (tuple)"

#: ../../reference/datamodel.rst:348
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr "ã‚¿ãƒ—ãƒ«ã®è¦ç´ ã¯ä»»æ„ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚äºŒã¤ä»¥ä¸Šã®è¦ç´ ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã¯ã€å€‹ã€…ã®è¦ç´ ã‚’è¡¨ç¾ã™ã‚‹å¼ã‚’ã‚«ãƒ³ãƒã§åŒºåˆ‡ã£ã¦æ§‹æˆã—ã¾ã™ã€‚å˜ä¸€ã®è¦ç´ ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ« (å˜é›†åˆ 'singleton') ã‚’ä½œã‚‹ã«ã¯ã€è¦ç´ ã‚’è¡¨ç¾ã™ã‚‹å¼ã®ç›´å¾Œã«ã‚«ãƒ³ãƒã‚’ã¤ã‘ã¾ã™ (å˜ä¸€ã®å¼ã ã‘ã§ã¯ã‚¿ãƒ—ãƒ«ã‚’å½¢æˆã—ã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€å¼ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã™ã‚‹ã®ã«ä¸¸æ‹¬å¼§ã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã‹ã‚‰ã§ã™)ã€‚è¦ç´ ã®å…¨ããªã„ä¸¸æ‹¬å¼§ã®å¯¾ã‚’ä½œã‚‹ã¨ç©ºã®ã‚¿ãƒ—ãƒ«ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:386
msgid "Mutable sequences"
msgstr "å¤‰æ›´å¯èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ (mutable sequence)"

#: ../../reference/datamodel.rst:362
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and "
":keyword:`del` (delete) statements."
msgstr "å¤‰æ›´å¯èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€ä½œæˆã—ãŸå¾Œã§å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å¤‰æ›´å¯èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã¯ã€æ·»å­—è¡¨è¨˜ã‚„ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã‚’ä½¿ã£ã¦æŒ‡å®šã•ã‚ŒãŸè¦ç´ ã«ä»£å…¥ã‚’è¡Œã†ã“ã¨ãŒã§ãã€ :keyword:`del` (delete) æ–‡ã‚’ä½¿ã£ã¦è¦ç´ ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:366
msgid "There are currently two intrinsic mutable sequence types:"
msgstr "Python ã«æœ€åˆã‹ã‚‰çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹å¤‰æ›´å¯èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã¯ã€ä»Šã®ã¨ã“ã‚äºŒã¤ã§ã™:"

#: ../../reference/datamodel.rst:373
msgid "Lists"
msgstr "ãƒªã‚¹ãƒˆå‹ (list)"

#: ../../reference/datamodel.rst:371
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that"
" there are no special cases needed to form lists of length 0 or 1.)"
msgstr "ãƒªã‚¹ãƒˆã®è¦ç´ ã¯ä»»æ„ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã§ãã¾ã™ã€‚ãƒªã‚¹ãƒˆã¯ã€è§’æ‹¬å¼§ã®ä¸­ã«ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸå¼ã‚’ä¸¦ã¹ã¦ä½œã‚Šã¾ã™ã€‚ (é•·ã•ãŒ 0 ã‚„ 1 ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ä½œã‚‹ãŸã‚ã«ç‰¹æ®Šãªå ´åˆåˆ†ã‘ã¯å¿…è¦ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚)"

#: ../../reference/datamodel.rst:381
msgid "Byte Arrays"
msgstr "ãƒã‚¤ãƒˆé…åˆ—"

#: ../../reference/datamodel.rst:378
msgid ""
"A bytearray object is a mutable array. They are created by the built-in "
":func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable bytes objects."
msgstr "bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤‰æ›´å¯èƒ½ãªé…åˆ—ã§ã™ã€‚çµ„ã¿è¾¼ã¿ã® :func:`bytearray` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã¾ã™ã€‚å¤‰æ›´å¯èƒ½ãªã“ã¨ã‚’é™¤ã‘ã° (ã¤ã¾ã‚Šãƒãƒƒã‚·ãƒ¥åŒ–ã§ããªã„)ã€ byte array ã¯å¤‰æ›´ä¸èƒ½ãª bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒã˜ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¨æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:385
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type."
msgstr "æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`array` ã§ã¯ã€åˆ¥ã®å¤‰æ›´å¯èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:420
msgid "Set types"
msgstr "é›†åˆå‹"

#: ../../reference/datamodel.rst:393
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated"
" over, and the built-in function :func:`len` returns the number of items in "
"a set. Common uses for sets are fast membership testing, removing duplicates"
" from a sequence, and computing mathematical operations such as "
"intersection, union, difference, and symmetric difference."
msgstr "é›†åˆå‹ã¯ã€é †åºã®ãªã„ã€ãƒ¦ãƒ‹ãƒ¼ã‚¯ã§ä¸å¤‰ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æœ‰é™é›†åˆã‚’è¡¨ç¾ã—ã¾ã™ã€‚ãã®ãŸã‚ã€(é…åˆ—ã®)æ·»å­—ã‚’ä½¿ã£ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚¢ã‚¯ã‚»ã‚¹ã¯ã§ãã¾ã›ã‚“ã€‚ãŸã ã—ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã¯å¯èƒ½ã§ã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`len` ã¯é›†åˆã®è¦ç´ æ•°ã‚’è¿”ã—ã¾ã™ã€‚é›†åˆå‹ã®ä¸€èˆ¬çš„ãªä½¿ã„æ–¹ã¯ã€é›†åˆã«å±ã—ã¦ã„ã‚‹ã‹ã®é«˜é€Ÿãªãƒ†ã‚¹ãƒˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‹ã‚‰ã®é‡è¤‡ã®æ’é™¤ã€å…±é€šé›†åˆãƒ»å’Œé›†åˆãƒ»å·®ãƒ»å¯¾ç§°å·®ã¨ã„ã£ãŸæ•°å­¦çš„ãªæ¼”ç®—ã®è¨ˆç®—ã§ã™ã€‚"

#: ../../reference/datamodel.rst:400
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two"
" numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr "é›†åˆã®è¦ç´ ã«ã¯ã€è¾æ›¸ã®ã‚­ãƒ¼ã¨åŒã˜æ™®éæ€§ã«é–¢ã™ã‚‹ãƒ«ãƒ¼ãƒ«ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚æ•°å€¤å‹ã¯é€šå¸¸ã®æ•°å€¤æ¯”è¼ƒã®ãƒ«ãƒ¼ãƒ«ã«å¾“ã†ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã‚‚ã—2ã¤ã®æ•°å€¤ã®æ¯”è¼ƒçµæœãŒåŒå€¤ã§ã‚ã‚‹(ä¾‹ãˆã°ã€ ``1`` ã¨ ``1.0``)ãªã‚‰ã€ãã®ã†ã¡ã®1ã¤ã®ã¿ã‚’é›†åˆã«å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:405
msgid "There are currently two intrinsic set types:"
msgstr "ç¾åœ¨ã€2ã¤ã®çµ„ã¿è¾¼ã¿é›†åˆå‹ãŒã‚ã‚Šã¾ã™:"

#: ../../reference/datamodel.rst:412
msgid "Sets"
msgstr "é›†åˆå‹"

#: ../../reference/datamodel.rst:410
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as "
":meth:`~set.add`."
msgstr "å¯å¤‰ãªé›†åˆå‹ã§ã™ã€‚çµ„ã¿è¾¼ã¿ã® :func:`set` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ä½œæˆã•ã‚Œã€å¾Œã‹ã‚‰ :meth:`~set.add` ãªã©ã®ã„ãã¤ã‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§æ›´æ–°ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:420
msgid "Frozen sets"
msgstr "Frozen set å‹"

#: ../../reference/datamodel.rst:417
msgid ""
"These represent an immutable set.  They are created by the built-in "
":func:`frozenset` constructor.  As a frozenset is immutable and "
":term:`hashable`, it can be used again as an element of another set, or as a"
" dictionary key."
msgstr "ä¸å¤‰ãªé›†åˆå‹ã§ã™ã€‚çµ„ã¿è¾¼ã¿ã® :func:`frozenset` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã¾ã™ã€‚ frozenset ã¯ä¸å¤‰ã§ãƒãƒƒã‚·ãƒ¥å¯èƒ½(:term:`hashable`)ãªã®ã§ã€åˆ¥ã®é›†åˆå‹ã®è¦ç´ ã«ãªã£ãŸã‚Šã€è¾æ›¸ã®ã‚­ãƒ¼ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:457
msgid "Mappings"
msgstr "ãƒãƒƒãƒ—å‹ (mapping)"

#: ../../reference/datamodel.rst:428
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr "ä»»æ„ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹é›†åˆã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹åŒ–ã•ã‚ŒãŸã€æœ‰é™ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãªã‚‹é›†åˆã‚’è¡¨ç¾ã—ã¾ã™ã€‚æ·»å­—è¡¨è¨˜ ``a[k]`` ã¯ã€ ``k`` ã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹æŒ‡å®šã•ã‚ŒãŸè¦ç´ ã‚’ ``a`` ã‹ã‚‰é¸æŠã—ã¾ã™; é¸æŠã•ã‚ŒãŸè¦ç´ ã¯å¼ã®ä¸­ã§ä½¿ã†ã“ã¨ãŒã§ãã€ä»£å…¥ã‚„ :keyword:`del` æ–‡ã®å¯¾è±¡ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚çµ„ã¿è¾¼ã¿é–¢æ•° :func:`len` ã¯ã€ãƒãƒƒãƒ—å†…ã®è¦ç´ æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:434
msgid "There is currently a single intrinsic mapping type:"
msgstr "Python ã«æœ€åˆã‹ã‚‰çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ãƒãƒƒãƒ—å‹ã¯ã€ä»Šã®ã¨ã“ã‚ä¸€ã¤ã ã‘ã§ã™:"

#: ../../reference/datamodel.rst:457
msgid "Dictionaries"
msgstr "è¾æ›¸å‹ (dictionary)"

#: ../../reference/datamodel.rst:439
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr "ã»ã¨ã‚“ã©ã©ã‚“ãªå€¤ã§ã‚‚ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã¨ã—ã¦ä½¿ãˆã‚‹ã‚ˆã†ãªã€æœ‰é™å€‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãªã‚‹é›†åˆã‚’è¡¨ã—ã¾ã™ã€‚ã‚­ãƒ¼å€¤ (key) ã¨ã—ã¦ä½¿ãˆãªã„å€¤ã¯ã€ãƒªã‚¹ãƒˆã‚„è¾æ›¸ã‚’å«ã‚€å€¤ã‚„ã€ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã§ã¯ãªãå€¤ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ¯”è¼ƒã•ã‚Œã‚‹ã€ãã®ä»–ã®å¤‰æ›´å¯èƒ½ãªå‹ã§ã™ã€‚ã“ã‚Œã¯ã€è¾æ›¸å‹ã‚’åŠ¹ç‡çš„ã«å®Ÿè£…ã™ã‚‹ä¸Šã§ã€ã‚­ãƒ¼ã®ãƒãƒƒã‚·ãƒ¥å€¤ãŒä¸€å®šã§ã‚ã‚‹ã“ã¨ãŒå¿…è¦ã ã‹ã‚‰ã§ã™ã€‚æ•°å€¤å‹ã‚’ã‚­ãƒ¼ã«ä½¿ã†å ´åˆã€ã‚­ãƒ¼å€¤ã¯é€šå¸¸ã®æ•°å€¤æ¯”è¼ƒã«ãŠã‘ã‚‹è¦å‰‡ã«å¾“ã„ã¾ã™: äºŒã¤ã®å€¤ãŒç­‰ã—ããªã‚‹å ´åˆ (ä¾‹ãˆã° ``1`` ã¨ ``1.0``)ã€äº’ã„ã«åŒã˜è¾æ›¸ã®ã‚¨ãƒ³ãƒˆãƒªã‚’è¡¨ã™ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã¨ã—ã¦ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:448
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation (see"
" section :ref:`dict`)."
msgstr "è¾æ›¸ã¯å¤‰æ›´å¯èƒ½ãªå‹ã§ã™; è¾æ›¸ã¯ ``{...}`` è¡¨è¨˜ã§ç”Ÿæˆã—ã¾ã™ (:ref:`dict` ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../reference/datamodel.rst:456
msgid ""
"The extension modules :mod:`dbm`, :mod:`gdbm`, and :mod:`bsddb` provide "
"additional examples of mapping types."
msgstr "æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`dbm` ã€ :mod:`gdbm` ã€ãŠã‚ˆã³ :mod:`bsddb` ã§ã¯ã€åˆ¥ã®ãƒãƒƒãƒ—å‹ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:727
msgid "Callable types"
msgstr "å‘¼ã³å‡ºã—å¯èƒ½å‹ (callable type)"

#: ../../reference/datamodel.rst:466
msgid ""
"These are the types to which the function call operation (see section "
":ref:`calls`) can be applied:"
msgstr "é–¢æ•°å‘¼ã³å‡ºã—æ“ä½œ (:ref:`calls` å‚ç…§) ã‚’è¡Œã†ã“ã¨ãŒã§ãã‚‹å‹ã§ã™:"

#: ../../reference/datamodel.rst:560
msgid "User-defined functions"
msgstr "ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•° (user-defined function)"

#: ../../reference/datamodel.rst:475
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr "ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€é–¢æ•°å®šç¾©ã‚’è¡Œã†ã“ã¨ã§ç”Ÿæˆã•ã‚Œã¾ã™ (:ref:`function` å‚ç…§)ã€‚é–¢æ•°ã¯ã€ä»®å¼•æ•° (formal parameter) ãƒªã‚¹ãƒˆã¨åŒã˜æ•°ã®è¦ç´ ãŒå…¥ã£ãŸå¼•æ•°ãƒªã‚¹ãƒˆã¨ã¨ã‚‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:480
msgid "Special attributes:"
msgstr "ç‰¹æ®Šå±æ€§:"

#: ../../reference/datamodel.rst:503
msgid "Attribute"
msgstr "å±æ€§"

#: ../../reference/datamodel.rst:503
msgid "Meaning"
msgstr "æ„å‘³"

#: ../../reference/datamodel.rst:505
msgid ":attr:`__doc__` :attr:`func_doc`"
msgstr ":attr:`__doc__` :attr:`func_doc`"

#: ../../reference/datamodel.rst:505
msgid "The function's documentation string, or ``None`` if unavailable."
msgstr "é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã§ã™ã€‚ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:505 ../../reference/datamodel.rst:509
#: ../../reference/datamodel.rst:513 ../../reference/datamodel.rst:517
#: ../../reference/datamodel.rst:523 ../../reference/datamodel.rst:533
msgid "Writable"
msgstr "æ›¸ãè¾¼ã¿å¯èƒ½"

#: ../../reference/datamodel.rst:509
msgid ":attr:`~definition.\\ __name__` :attr:`func_name`"
msgstr ":attr:`~definition.\\ __name__` :attr:`func_name`"

#: ../../reference/datamodel.rst:509
msgid "The function's name"
msgstr "é–¢æ•°ã®åå‰ã§ã™"

#: ../../reference/datamodel.rst:513
msgid ":attr:`__module__`"
msgstr ":attr:`__module__`"

#: ../../reference/datamodel.rst:513
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr "é–¢æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã§ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:517
msgid ":attr:`__defaults__` :attr:`func_defaults`"
msgstr ":attr:`__defaults__` :attr:`func_defaults`"

#: ../../reference/datamodel.rst:517
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒã¤å¼•æ•°ã«å¯¾ã™ã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒåã‚ã‚‰ã‚ŒãŸã‚¿ãƒ—ãƒ«ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒã¤å¼•æ•°ãŒãªã„å ´åˆã«ã¯ ``None`` ã«ãªã‚Šã¾ã™"

#: ../../reference/datamodel.rst:523
msgid ":attr:`__code__` :attr:`func_code`"
msgstr ":attr:`__code__` :attr:`func_code`"

#: ../../reference/datamodel.rst:523
msgid "The code object representing the compiled function body."
msgstr "ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸé–¢æ•°æœ¬ä½“ã‚’è¡¨ç¾ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../reference/datamodel.rst:526
msgid ":attr:`__globals__` :attr:`func_globals`"
msgstr ":attr:`__globals__` :attr:`func_globals`"

#: ../../reference/datamodel.rst:526
msgid ""
"A reference to the dictionary that holds the function's global variables ---"
" the global namespace of the module in which the function was defined."
msgstr "é–¢æ•°ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®å…¥ã£ãŸè¾æ›¸ (ã¸ã®å‚ç…§) ã§ã™ --- ã“ã®è¾æ›¸ã¯ã€é–¢æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ç©ºé–“ã‚’æ±ºå®šã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:526 ../../reference/datamodel.rst:537
msgid "Read-only"
msgstr "èª­ã¿è¾¼ã¿å°‚ç”¨"

#: ../../reference/datamodel.rst:533
msgid ":attr:`~object.\\ __dict__` :attr:`func_dict`"
msgstr ":attr:`~object.\\ __dict__` :attr:`func_dict`"

#: ../../reference/datamodel.rst:533
msgid "The namespace supporting arbitrary function attributes."
msgstr "ä»»æ„ã®é–¢æ•°å±æ€§ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã®åå‰ç©ºé–“ãŒåã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:537
msgid ":attr:`__closure__` :attr:`func_closure`"
msgstr ":attr:`__closure__` :attr:`func_closure`"

#: ../../reference/datamodel.rst:537
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's free "
"variables."
msgstr "``None`` ã¾ãŸã¯é–¢æ•°ã®å€‹ã€…ã®è‡ªç”±å¤‰æ•° (å¼•æ•°ä»¥å¤–ã®å¤‰æ•°) ã«å¯¾ã—ã¦å€¤ã‚’çµã³ä»˜ã‘ã¦ã„ã‚‹ã‚»ãƒ« (cell) ç¾¤ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:542
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the assigned "
"value."
msgstr "ã€Œæ›¸ãè¾¼ã¿å¯èƒ½ã€ã¨ãƒ©ãƒ™ãƒ«ã•ã‚Œã¦ã„ã‚‹å±æ€§ã®ã»ã¨ã‚“ã©ã¯ã€ä»£å…¥ã•ã‚ŒãŸå€¤ã®å‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:544
msgid "``func_name`` is now writable."
msgstr "``func_name`` ã¯æ›¸ãè¾¼ã¿å¯èƒ½ã«ãªã‚Šã¾ã—ãŸ."

#: ../../reference/datamodel.rst:547
msgid ""
"The double-underscore attributes ``__closure__``, ``__code__``, "
"``__defaults__``, and ``__globals__`` were introduced as aliases for the "
"corresponding ``func_*`` attributes for forwards compatibility with Python "
"3."
msgstr "Python 3 ã¨ã®å‰æ–¹äº’æ›ã®ãŸã‚ã«ã€ãƒ€ãƒ–ãƒ«ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã®å±æ€§ ``__closure__``, ``__code__``, ``__defaults__``, ``__globals__`` ãŒå¯¾å¿œã™ã‚‹ ``func_*`` ã¸ã®åˆ¥åã¨ã—ã¦å°å…¥ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../reference/datamodel.rst:553
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes. *Note that "
"the current implementation only supports function attributes on user-defined"
" functions. Function attributes on built-in functions may be supported in "
"the future.*"
msgstr "é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã¾ãŸã€ä»»æ„ã®å±æ€§ã‚’è¨­å®šã—ãŸã‚Šå–å¾—ã—ãŸã‚Šã§ãã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã¯ã€ä¾‹ãˆã°é–¢æ•°ã«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä»˜ä¸ã—ãŸã„å ´åˆãªã©ã«ä½¿ãˆã¾ã™ã€‚é–¢æ•°ã® get ã‚„ set ã«ã¯ã€é€šå¸¸ã®ãƒ‰ãƒƒãƒˆè¡¨è¨˜ã‚’ä½¿ã„ã¾ã™ã€‚ *ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€ãƒ¦ãƒ¼ã‚¶å®šç¾©ã®é–¢æ•°ã§ã®ã¿å±æ€§ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã®ã§æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚çµ„ã¿è¾¼ã¿é–¢æ•°ã®å±æ€§ã¯å°†æ¥ã‚µãƒãƒ¼ãƒˆã™ã‚‹äºˆå®šã§ã™ã€‚*"

#: ../../reference/datamodel.rst:559
msgid ""
"Additional information about a function's definition can be retrieved from "
"its code object; see the description of internal types below."
msgstr "é–¢æ•°å®šç¾©ã«é–¢ã™ã‚‹ãã®ä»–ã®æƒ…å ±ã¯ã€é–¢æ•°ã®ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å¾—ã‚‰ã‚Œã¾ã™; å¾Œè¿°ã®å†…éƒ¨å‹ (internal type) ã«é–¢ã™ã‚‹èª¬æ˜ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:658
msgid "User-defined methods"
msgstr "ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ (user-defined method)"

#: ../../reference/datamodel.rst:568
msgid ""
"A user-defined method object combines a class, a class instance (or "
"``None``) and any callable object (normally a user-defined function)."
msgstr "ãƒ¦ãƒ¼ã‚¶å®šç¾©ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚¯ãƒ©ã‚¹ã‚„ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ (ã‚ã‚‹ã„ã¯ ``None``) ã‚’ä»»æ„ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (é€šå¸¸ã¯ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°) ã¨çµåˆã— (combine) ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:571
msgid ""
"Special read-only attributes: :attr:`im_self` is the class instance object, "
":attr:`im_func` is the function object; :attr:`im_class` is the class of "
":attr:`im_self` for bound methods or the class that asked for the method for"
" unbound methods; :attr:`__doc__` is the method's documentation (same as "
"``im_func.__doc__``); :attr:`~definition.__name__` is the method name (same "
"as ``im_func.__name__``); :attr:`__module__` is the name of the module the "
"method was defined in, or ``None`` if unavailable."
msgstr "èª­ã¿å‡ºã—å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`im_self` ã¯ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ :attr:`im_func` ã¯é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™; :attr:`im_class` ã¯çµåˆãƒ¡ã‚½ãƒƒãƒ‰ (bound method) ã«ãŠã„ã¦ :attr:`im_self` ãŒå±ã—ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã‹ã€ã‚ã‚‹ã„ã¯éçµåˆãƒ¡ã‚½ãƒƒãƒ‰ (unbound method) ã«ãŠã„ã¦ã€è¦æ±‚ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã§ã™; :attr:`__doc__` ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ— (``im_func.__doc__`` ã¨åŒã˜) ã§ã™; :attr:`~definition.__name__` ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã®åå‰ (``im_func.__name__`` ã¨åŒã˜) ã§ã™; :attr:`__module__` ã¯ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã«ãªã‚‹ã‹ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:579
msgid ":attr:`im_self` used to refer to the class that defined the method."
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã‚’å‚ç…§ã™ã‚‹ãŸã‚ã« :attr:`im_self` ãŒä½¿ã‚ã‚Œã¦ã„ã¾ã—ãŸ."

#: ../../reference/datamodel.rst:582
msgid ""
"For Python 3 forward-compatibility, :attr:`im_func` is also available as "
":attr:`__func__`, and :attr:`im_self` as :attr:`__self__`."
msgstr "Python 3 ã¨ã®å‰æ–¹äº’æ›æ€§ã®ãŸã‚ã«ã€ :attr:`im_func` ã®ä»£ã‚ã‚Šã« :attr:`__func__` ã‚‚ã€ :attr:`im_self` ã®ä»£ã‚ã‚Šã« :attr:`__self__` ã‚‚ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:593
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ã¾ãŸã€æ ¹åº•ã«ã‚ã‚‹é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»»æ„ã®é–¢æ•°å±æ€§ã« (å€¤ã®è¨­å®šã¯ã§ãã¾ã›ã‚“ãŒ) ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:596
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined function object, an unbound user-defined method object, or a class "
"method object. When the attribute is a user-defined method object, a new "
"method object is only created if the class from which it is being retrieved "
"is the same as, or a derived class of, the class stored in the original "
"method object; otherwise, the original method object is used as it is."
msgstr "ã‚¯ãƒ©ã‚¹ã®å±æ€§ã‚’ (ãŠãã‚‰ãã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä»‹ã—ã¦) å–å¾—ã™ã‚‹éš›ã«ã¯ã€ãã®å±æ€§ãŒãƒ¦ãƒ¼ã‚¶å®šç¾©ã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€éçµåˆ (unbound) ã®ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã‚ã‚‹ã„ã¯ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚Œã°ã€ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚å±æ€§ãŒãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€å±æ€§ã‚’å–å¾—ã™ã‚‹å¯¾è±¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå±ã™ã‚‹ã‚¯ãƒ©ã‚¹ãŒã‚‚ã¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã¨åŒã˜ã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ã‹ã€ã¾ãŸã¯ãã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Œã°ã€æ–°ãŸãªãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã ã‘ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€ã‚‚ã¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãã®ã¾ã¾ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:609
msgid ""
"When a user-defined method object is created by retrieving a user-defined "
"function object from a class, its :attr:`im_self` attribute is ``None`` and "
"the method object is said to be unbound. When one is created by retrieving a"
" user-defined function object from a class via one of its instances, its "
":attr:`im_self` attribute is the instance, and the method object is said to "
"be bound. In either case, the new method's :attr:`im_class` attribute is the"
" class from which the retrieval takes place, and its :attr:`im_func` "
"attribute is the original function object."
msgstr "ã‚¯ãƒ©ã‚¹ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã™ã‚‹æ–¹æ³•ã§ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹ã¨ã€ :attr:`im_self` å±æ€§ã¯ ``None`` ã«ãªã‚Šã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯éçµåˆ (unbound) ã§ã‚ã‚‹ã¨ã„ã„ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã™ã‚‹æ–¹æ³•ã§ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹ã¨ã€ :attr:`im_self` å±æ€§ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚Šã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµåˆ (bound) ã§ã‚ã‚‹ã¨ã„ã„ã¾ã™ã€‚ã©ã¡ã‚‰ã®å ´åˆã‚‚ã€æ–°ãŸãªãƒ¡ã‚½ãƒƒãƒ‰ã® :attr:`im_class` å±æ€§ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã®å–å¾—ãŒè¡Œã‚ã‚ŒãŸã‚¯ãƒ©ã‚¹ã«ãªã‚Šã€ :attr:`im_func` å±æ€§ã¯ã‚‚ã¨ã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:620
msgid ""
"When a user-defined method object is created by retrieving another method "
"object from a class or instance, the behaviour is the same as for a function"
" object, except that the :attr:`im_func` attribute of the new instance is "
"not the original method object but its :attr:`im_func` attribute."
msgstr "ã‚¯ãƒ©ã‚¹ã‚„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰ä»–ã®ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã™ã‚‹æ–¹æ³•ã§ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ãŸå ´åˆã€ãã®å‹•ä½œã¯é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã¨åŒæ§˜ã§ã™ãŒã€æ–°ãŸãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® :attr:`im_func` å±æ€§ã¯ã‚‚ã¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§ã§ã¯ãªãã€æ–°ãŸãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:630
msgid ""
"When a user-defined method object is created by retrieving a class method "
"object from a class or instance, its :attr:`im_self` attribute is the class "
"itself, and its :attr:`im_func` attribute is the function object underlying "
"the class method."
msgstr "ã‚¯ãƒ©ã‚¹ã‚„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã™ã‚‹æ–¹æ³•ã§ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ãŸå ´åˆã€ :attr:`im_self` å±æ€§ã¯ã‚¯ãƒ©ã‚¹è‡ªä½“ã¨ãªã‚Šã€ :attr:`im_func` å±æ€§ã¯ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã®æ ¹åº•ã«ã‚ã‚‹é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:634
msgid ""
"When an unbound user-defined method object is called, the underlying "
"function (:attr:`im_func`) is called, with the restriction that the first "
"argument must be an instance of the proper class (:attr:`im_class`) or of a "
"derived class thereof."
msgstr "éçµåˆãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‘¼ã³å‡ºã—ã®éš›ã«ã¯ã€æ ¹åº•ã«ã‚ã‚‹é–¢æ•° (:attr:`im_func`) ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®ã¨ãã€æœ€åˆã®å¼•æ•°ã¯é©åˆ‡ãªã‚¯ãƒ©ã‚¹ (:attr:`im_class`) ã¾ãŸã¯ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ã„ã†åˆ¶é™ãŒèª²ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:639
msgid ""
"When a bound user-defined method object is called, the underlying function "
"(:attr:`im_func`) is called, inserting the class instance (:attr:`im_self`) "
"in front of the argument list.  For instance, when :class:`C` is a class "
"which contains a definition for a function :meth:`f`, and ``x`` is an "
"instance of :class:`C`, calling ``x.f(1)`` is equivalent to calling ``C.f(x,"
" 1)``."
msgstr "çµåˆãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‘¼ã³å‡ºã—ã®éš›ã«ã¯ã€æ ¹åº•ã«ã‚ã‚‹é–¢æ•° (:attr:`im_func`) ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®ã¨ãã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ (:attr:`im_self`) ãŒå¼•æ•°ã®å…ˆé ­ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€é–¢æ•° :meth:`f` ã®å®šç¾©ãŒå…¥ã£ãŸã‚¯ãƒ©ã‚¹ã‚’ :class:`C` ã¨ã—ã€ ``x`` ã‚’ :class:`C` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã™ã‚‹ã¨ã€ ``x.f(1)`` ã®å‘¼ã³å‡ºã—ã¯ ``C.f(x, 1)`` ã¨åŒã˜ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:645
msgid ""
"When a user-defined method object is derived from a class method object, the"
" \"class instance\" stored in :attr:`im_self` will actually be the class "
"itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to "
"calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr "ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰æ´¾ç”Ÿã—ãŸéš›ã€ :attr:`im_self` ã«è¨˜æ†¶ã•ã‚Œã¦ã„ã‚‹ \"ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹\" ã¯ã‚¯ãƒ©ã‚¹è‡ªä½“ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€ ``x.f(1)`` ã‚„ ``C.f(1)`` ã®å‘¼ã³å‡ºã—ãŒæ ¹åº•ã«ã‚ã‚‹é–¢æ•°ã‚’ ``f`` ã¨ã—ãŸã¨ãã®å‘¼ã³å‡ºã— ``f(C,1)`` ã¨ç­‰ä¾¡ã«ãªã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã§ã™ã€‚"

#: ../../reference/datamodel.rst:650
msgid ""
"Note that the transformation from function object to (unbound or bound) "
"method object happens each time the attribute is retrieved from the class or"
" instance. In some cases, a fruitful optimization is to assign the attribute"
" to a local variable and call that local variable. Also notice that this "
"transformation only happens for user-defined functions; other callable "
"objects (and all non-callable objects) are retrieved without transformation."
"  It is also important to note that user-defined functions which are "
"attributes of a class instance are not converted to bound methods; this "
"*only* happens when the function is an attribute of the class."
msgstr "é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ (çµåˆã¾ãŸã¯éçµåˆã®) ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¤‰æ›ã¯ã€ã‚¯ãƒ©ã‚¹ã‚„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰å±æ€§ã‚’å–ã‚Šå‡ºã™ãŸã³ã«è¡Œã‚ã‚Œã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚å ´åˆã«ã‚ˆã£ã¦ã¯ã€å±æ€§ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ãªå¤‰æ•°ã«ä»£å…¥ã—ã¦ãŠãã€ãã®å¤‰æ•°ã‚’ä½¿ã£ã¦é–¢æ•°å‘¼ã³å‡ºã—ã‚’è¡Œã†ã¨åŠ¹æœçš„ãªæœ€é©åŒ–ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸã€ä¸Šè¨˜ã®å¤‰æ›ã¯ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã«å¯¾ã—ã¦ã®ã¿èµ·ã“ã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„; ãã®ä»–ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ãŠã‚ˆã³å‘¼ã³å‡ºã—å¯èƒ½ã§ãªã„å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) ã¯ã€å¤‰æ›ã‚’å—ã‘ãšã«å–ã‚Šå‡ºã•ã‚Œã¾ã™ã€‚ãã‚Œã‹ã‚‰ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ã«ãªã£ã¦ã„ã‚‹ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã¯ã€çµåˆãƒ¡ã‚½ãƒƒãƒ‰ã«å¤‰æ›ã§ããªã„ã¨çŸ¥ã£ã¦ãŠãã“ã¨ã‚‚é‡è¦ã§ã™; çµåˆãƒ¡ã‚½ãƒƒãƒ‰ã¸ã®å¤‰æ›ãŒè¡Œã‚ã‚Œã‚‹ã®ã¯ã€é–¢æ•°ãŒã‚¯ãƒ©ã‚¹ã®ä¸€å±æ€§ã§ã‚ã‚‹å ´åˆ *ã ã‘* ã§ã™ã€‚"

#: ../../reference/datamodel.rst:674
msgid "Generator functions"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•° (generator function)"

#: ../../reference/datamodel.rst:665
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section "
":ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an iterator object which can be used to execute the "
"body of the function:  calling the iterator's :meth:`~iterator.next` method "
"will cause the function to execute until it provides a value using the "
":keyword:`yield` statement.  When the function executes a :keyword:`return` "
"statement or falls off the end, a :exc:`StopIteration` exception is raised "
"and the iterator will have reached the end of the set of values to be "
"returned."
msgstr ":keyword:`yield` æ–‡ (:ref:`yield` ã®ç¯€ã‚’å‚ç…§) ã‚’ä½¿ã†é–¢æ•°ã‚‚ã—ãã¯ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :dfn:`ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°` ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ãã®ã‚ˆã†ãªé–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã¯å¸¸ã«ã€é–¢æ•°ã®æœ¬ä½“ã‚’å®Ÿè¡Œã™ã‚‹ã®ã«ä½¿ãˆã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™: ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã® :meth:`~iterator.next` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¨ã€ :keyword:`yield` æ–‡ã‚’ä½¿ã£ã¦å€¤ãŒæä¾›ã•ã‚Œã‚‹ã¾ã§é–¢æ•°ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚é–¢æ•°ã® :keyword:`return` æ–‡ã‚’å®Ÿè¡Œã™ã‚‹ã‹çµ‚ç«¯ã«é”ã—ãŸã¨ãã¯ã€ :exc:`StopIteration` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒè¿”ã™ã¹ãå€¤ã®æœ€å¾Œã¾ã§åˆ°é”ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:689
msgid "Built-in functions"
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•° (built-in function)"

#: ../../reference/datamodel.rst:682
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: :attr:`__doc__` "
"is the function's documentation string, or ``None`` if unavailable; "
":attr:`~definition.__name__` is the function's name; :attr:`__self__` is set"
" to ``None`` (but see the next item); :attr:`__module__` is the name of the "
"module the function was defined in or ``None`` if unavailable."
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯Cé–¢æ•°ã¸ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã§ã™ã€‚\nçµ„ã¿è¾¼ã¿é–¢æ•°ã®ä¾‹ã¯ :func:`len` ã‚„ :func:`math.sin` (:mod:`math` ã¯æ¨™æº–ã®çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«) ã§ã™ã€‚\nå¼•æ•°ã®æ•°ã‚„å‹ã¯ C é–¢æ•°ã§æ±ºå®šã•ã‚Œã¦ã„ã¾ã™ã€‚\nèª­ã¿å‡ºã—å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`__doc__` ã¯é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã§ã™ã€‚\nãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™;\n:attr:`~definition.__name__` ã¯é–¢æ•°ã®åå‰ã§ã™;\n:attr:`__self__` ã¯ ``None`` ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã™ (çµ„ã¿è¾¼ã¿ãƒ¡ã‚½ãƒƒãƒ‰ã®ç¯€ã‚‚å‚ç…§ã—ã¦ãã ã•ã„);\n:attr:`__module__` ã¯ã€é–¢æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã§ã™ã€‚\nãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:701
msgid "Built-in methods"
msgstr "çµ„ã¿è¾¼ã¿ãƒ¡ã‚½ãƒƒãƒ‰ (built-in method)"

#: ../../reference/datamodel.rst:697
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra argument."
"  An example of a built-in method is ``alist.append()``, assuming *alist* is"
" a list object. In this case, the special read-only attribute "
":attr:`__self__` is set to the object denoted by *alist*."
msgstr "å®Ÿéš›ã«ã¯çµ„ã¿è¾¼ã¿é–¢æ•°ã‚’åˆ¥ã®å½¢ã§éš è”½ã—ãŸã‚‚ã®ã§ã€ã“ã¡ã‚‰ã®å ´åˆã«ã¯ C é–¢æ•°ã«æ¸¡ã•ã‚Œã‚‹ä½•ã‚‰ã‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’éæ˜ç¤ºçš„ãªå¤–éƒ¨å¼•æ•°ã¨ã—ã¦æŒã£ã¦ã„ã¾ã™ã€‚çµ„ã¿è¾¼ã¿ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¾‹ã¯ã€ *alist* ã‚’ãƒªã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ãŸã¨ãã® ``alist.append()`` ã§ã™ã€‚ã“ã®å ´åˆã«ã¯ã€èª­ã¿å‡ºã—å°‚ç”¨ã®å±æ€§ :attr:`__self__` ã¯ *alist* ã§è¡¨ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:708
msgid "Class Types"
msgstr "ã‚¯ãƒ©ã‚¹å‹ (class type)"

#: ../../reference/datamodel.rst:704
msgid ""
"Class types, or \"new-style classes,\" are callable.  These objects normally"
" act as factories for new instances of themselves, but variations are "
"possible for class types that override :meth:`__new__`.  The arguments of "
"the call are passed to :meth:`__new__` and, in the typical case, to "
":meth:`__init__` to initialize the new instance."
msgstr "ã‚¯ãƒ©ã‚¹å‹ã€ã‚ã‚‹ã„ã¯ \"æ–°ã—ã„ã‚¯ãƒ©ã‚¹å‹ (new-style class)\" ã‚„å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã‚¯ãƒ©ã‚¹å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é€šå¸¸ã€ãã®ã‚¯ãƒ©ã‚¹ã®æ–°ãŸãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹éš›ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªã‚¯ãƒ©ã‚¹ã¨ã—ã¦æŒ¯èˆã„ã¾ã™ãŒã€ :meth:`__new__` ã‚’ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã—ã¦ã€ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æŒãŸã›ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚å‘¼ã³å‡ºã—ã®éš›ã«ä½¿ã‚ã‚ŒãŸå¼•æ•°ã¯ :meth:`__new__` ã«æ¸¡ã•ã‚Œã€ã•ã‚‰ã«å…¸å‹çš„ãªå ´åˆã§ã¯æ–°ãŸãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’åˆæœŸåŒ–ã™ã‚‹ãŸã‚ã« :meth:`__init__` ã«æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:722
msgid "Classic Classes"
msgstr "æ—§ã‚¯ãƒ©ã‚¹å‹ (classic class)"

#: ../../reference/datamodel.rst:718
msgid ""
"Class objects are described below.  When a class object is called, a new "
"class instance (also described below) is created and returned.  This implies"
" a call to the class's :meth:`__init__` method if it has one.  Any arguments"
" are passed on to the :meth:`__init__` method.  If there is no "
":meth:`__init__` method, the class must be called without arguments."
msgstr "(æ—§) ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¾Œã§è©³ã—ãèª¬æ˜ã—ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ã€æ–°ãŸã«ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ (å¾Œè¿°) ãŒç”Ÿæˆã•ã‚Œã€è¿”ã•ã‚Œã¾ã™ã€‚ã“ã®æ“ä½œã«ã¯ã€ã‚¯ãƒ©ã‚¹ã® :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã— (å®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆ) ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚å‘¼ã³å‡ºã—ã®éš›ã«ä½¿ã‚ã‚ŒãŸå¼•æ•°ã¯ã€ã™ã¹ã¦ :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã•ã‚Œã¾ã™ã€‚ :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒãªã„å ´åˆã€ã‚¯ãƒ©ã‚¹ã¯å¼•æ•°ãªã—ã§å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:727 ../../reference/datamodel.rst:879
msgid "Class instances"
msgstr "ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ (class instance)"

#: ../../reference/datamodel.rst:725
msgid ""
"Class instances are described below.  Class instances are callable only when"
" the class has a :meth:`__call__` method; ``x(arguments)`` is a shorthand "
"for ``x.__call__(arguments)``."
msgstr "ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯å¾Œã§è©³ã—ãèª¬æ˜ã—ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã‚¯ãƒ©ã‚¹ãŒ :meth:`__call__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã«ã®ã¿å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™; ``x(arguments)`` ã¨ã™ã‚‹ã¨ã€ ``x.__call__(arguments)`` å‘¼ã³å‡ºã—ã‚’çŸ­ãæ›¸ã‘ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:770
msgid "Modules"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (module)"

#: ../../reference/datamodel.rst:734
msgid ""
"Modules are imported by the :keyword:`import` statement (see section "
":ref:`import`). A module object has a namespace implemented by a dictionary "
"object (this is the dictionary referenced by the func_globals attribute of "
"functions defined in the module).  Attribute references are translated to "
"lookups in this dictionary, e.g., ``m.x`` is equivalent to "
"``m.__dict__[\"x\"]``. A module object does not contain the code object used"
" to initialize the module (since it isn't needed once the initialization is "
"done)."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :keyword:`import` æ–‡ã§ import ã—ã¾ã™ (:ref:`import` å‚ç…§)ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€è¾æ›¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹é–¢æ•°ãŒ func_globals å±æ€§ã§å‚ç…§ã—ã¦ã„ã‚‹è¾æ›¸ã§ã™) ã§å®Ÿè£…ã•ã‚ŒãŸåå‰ç©ºé–“ã‚’æŒã£ã¦ã„ã¾ã™ã€‚å±æ€§ã¸ã®å‚ç…§ã¯ã€ã“ã®è¾æ›¸ã«å¯¾ã™ã‚‹æ¤œç´¢ (lookup) ã«ç¿»è¨³ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ``m.x`` ã¯ ``m.__dict__[\"x\"]`` ã¨åŒã˜ã§ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å…¥ã£ã¦ã„ã¾ã›ã‚“ (ä¸€åº¦åˆæœŸåŒ–ãŒçµ‚ã‚ã‚Œã°ã‚‚ã†å¿…è¦ãªã„ã‹ã‚‰ã§ã™)ã€‚"

#: ../../reference/datamodel.rst:743
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr "å±æ€§ã®ä»£å…¥ã‚’è¡Œã†ã¨ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“è¾æ›¸ã®å†…å®¹ã‚’æ›´æ–°ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``m.x = 1`` ã¯ ``m.__dict__[\"x\"] = 1`` ã¨åŒã˜ã§ã™ã€‚"

#: ../../reference/datamodel.rst:748
msgid ""
"Special read-only attribute: :attr:`~object.__dict__` is the module's "
"namespace as a dictionary object."
msgstr "èª­ã¿å‡ºã—å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`~object.__dict__` ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ã§ã€è¾æ›¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../reference/datamodel.rst:753
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary"
" will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr "CPython ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¾æ›¸ã‚’å‰Šé™¤ã™ã‚‹æ–¹æ³•ã«ã‚ˆã‚Šã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¾æ›¸ãŒç”ŸããŸå‚ç…§ã‚’æŒã£ã¦ã„ãŸã¨ã—ã¦ã‚‚ãã®è¾æ›¸ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å¤–ã‚ŒãŸæ™‚ã«å‰Šé™¤ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚’é¿ã‘ã‚‹ã«ã¯ã€è¾æ›¸ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã‹ã€è¾æ›¸ã‚’ç›´æ¥ä½¿ã£ã¦ã„ã‚‹é–“ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä¿æŒã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:764
msgid ""
"Predefined (writable) attributes: :attr:`__name__` is the module's name; "
":attr:`__doc__` is the module's documentation string, or ``None`` if "
"unavailable; :attr:`__file__` is the pathname of the file from which the "
"module was loaded, if it was loaded from a file. The :attr:`__file__` "
"attribute is not present for C modules that are statically linked into the "
"interpreter; for extension modules loaded dynamically from a shared library,"
" it is the pathname of the shared library file."
msgstr "å®šç¾©æ¸ˆã¿ã® (æ›¸ãè¾¼ã¿å¯èƒ½ãª) å±æ€§: :attr:`__name__` ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã§ã™; :attr:`__doc__` ã¯é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã§ã™ã€‚ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™; ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå ´åˆã€ :attr:`__file__` ã¯ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹åã§ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«é™çš„ã«ãƒªãƒ³ã‚¯ã•ã‚Œã¦ã„ã‚‹ C ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å ´åˆã€ :attr:`__file__` å±æ€§ã¯ã‚ã‚Šã¾ã›ã‚“; å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‹ã‚‰å‹•çš„ã«ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸæ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å ´åˆã€ã“ã®å±æ€§ã¯å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹åã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:833
msgid "Classes"
msgstr "ã‚¯ãƒ©ã‚¹"

#: ../../reference/datamodel.rst:773
msgid ""
"Both class types (new-style classes) and class objects (old-style/classic "
"classes) are typically created by class definitions (see section "
":ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, "
"e.g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although for new-style"
" classes in particular there are a number of hooks which allow for other "
"means of locating attributes). When the attribute name is not found there, "
"the attribute search continues in the base classes.  For old-style classes, "
"the search is depth-first, left-to-right in the order of occurrence in the "
"base class list. New-style classes use the more complex C3 method resolution"
" order which behaves correctly even in the presence of 'diamond' inheritance"
" structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by new-style classes "
"can be found in the documentation accompanying the 2.3 release at "
"https://www.python.org/download/releases/2.3/mro/."
msgstr "2 ç¨®é¡ã®ã‚¯ãƒ©ã‚¹ã€ type (æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹) ã¨ class object (æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹) ã®ä¸¡æ–¹ã¨ã‚‚ã€é€šå¸¸ã¯ã‚¯ãƒ©ã‚¹å®šç¾© (:ref:`class` å‚ç…§) ã§ç”Ÿæˆã•ã‚Œã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã¯è¾æ›¸ã§å®Ÿè£…ã•ã‚ŒãŸåå‰ç©ºé–“ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹å±æ€§ã¸ã®å‚ç…§ã¯ã€ã“ã®è¾æ›¸ã«å¯¾ã™ã‚‹æ¤œç´¢ (lookup) ã«ç¿»è¨³ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ``C.x`` ã¯ ``C.__dict__[\"x\"]`` ã¨åŒã˜ã§ã™ã€‚(ãŸã ã—ã€ç‰¹ã«æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã«ãŠã„ã¦ã€å±æ€§å‚ç…§ã®æ„å‘³ã‚’å¤‰ãˆã‚‰ã‚Œã‚‹å¹¾ã¤ã‹ã®ãƒ•ãƒƒã‚¯ãŒã‚ã‚Šã¾ã™)ã€‚å±æ€§ãŒã“ã®æ¤œç´¢ã§è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ç¾åœ¨ã®ã‚¯ãƒ©ã‚¹ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã¸ã¨æ¤œç´¢ã‚’ç¶šã‘ã¾ã™ã€‚æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã®å ´åˆã€æ¤œç´¢ã¯æ·±ã•å„ªå…ˆ (depth-first)ã€ã‹ã¤åŸºåº•ã‚¯ãƒ©ã‚¹ã®æŒ™ã’ã‚‰ã‚Œã¦ã„ã‚‹ãƒªã‚¹ãƒˆä¸­ã®å·¦ã‹ã‚‰å³ (left-to-right) ã®é †ç•ªã§è¡Œã‚ã‚Œã¾ã™ã€‚æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã¯ã€ã‚ˆã‚Šè¤‡é›‘ãªã€C3ãƒ¡ã‚½ãƒƒãƒ‰è§£æ±ºé †åº(MRO=method resolution order) ã‚’åˆ©ç”¨ã—ã¦ã„ã¦ã€è¤‡æ•°ã®ç¶™æ‰¿ãƒ‘ã‚¹ãŒå…±é€šã®ç¥–å…ˆã«ãŸã©ã‚Šç€ãã€Œãƒ€ã‚¤ã‚¢ãƒ¢ãƒ³ãƒ‰ç¶™æ‰¿ã€ãŒã‚ã£ã¦ã‚‚æ­£ã—ãå‹•ä½œã—ã¾ã™ã€‚ C3 MRO ã«ã¤ã„ã¦ã®ã‚ˆã‚Šè©³ç´°ãªæƒ…å ±ã¯ã€2.3ãƒªãƒªãƒ¼ã‚¹ã«ä»˜å±ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚ã‚Šã¾ã™ã€‚ (https://www.python.org/download/releases/2.3/mro/)"

#: ../../reference/datamodel.rst:800
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield a "
"user-defined function object or an unbound user-defined method object whose "
"associated class is either :class:`C` or one of its base classes, it is "
"transformed into an unbound user-defined method object whose "
":attr:`im_class` attribute is :class:`C`. When it would yield a class method"
" object, it is transformed into a bound user-defined method object whose "
":attr:`im_self` attribute is :class:`C`.  When it would yield a static "
"method object, it is transformed into the object wrapped by the static "
"method object. See section :ref:`descriptors` for another way in which "
"attributes retrieved from a class may differ from those actually contained "
"in its :attr:`~object.__dict__` (note that only new-style classes support "
"descriptors)."
msgstr "ã‚¯ãƒ©ã‚¹ (:class:`C` ã¨ã—ã¾ã™) ã¸ã®å±æ€§å‚ç…§ã§ã€è¦æ±‚ã—ã¦ã„ã‚‹å±æ€§ãŒãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„ã€ :class:`C` ã‚„ãã®åŸºåº•ã‚¯ãƒ©ã‚¹ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹éçµåˆã®ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹å ´åˆã€ :attr:`im_class` å±æ€§ãŒ :class:`C` ã§ã‚ã‚‹ã‚ˆã†ãªéçµåˆãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚è¦æ±‚ã—ã¦ã„ã‚‹å±æ€§ãŒã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€ãã® :attr:`im_self` å±æ€§ãŒ :class:`C` ã§ã‚ã‚‹ã‚ˆã†ãªãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚è¦æ±‚ã—ã¦ã„ã‚‹å±æ€§ãŒé™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã‹ã‚‰å–ã‚Šå‡ºã—ãŸå±æ€§ã¨å®Ÿéš›ã« :attr:`~object.__dict__` ã«å…¥ã£ã¦ã„ã‚‹ã‚‚ã®ãŒç•°ãªã‚‹ã‚ˆã†ãªä»–ã®å ´åˆã«ã¤ã„ã¦ã¯ã€ :ref:`descriptors` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ (æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã ã‘ãŒãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„)ã€‚"

#: ../../reference/datamodel.rst:814
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr "ã‚¯ãƒ©ã‚¹å±æ€§ã‚’ä»£å…¥ã™ã‚‹ã¨ã€ãã®ã‚¯ãƒ©ã‚¹ã®è¾æ›¸ã ã‘ãŒæ›´æ–°ã•ã‚Œã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®è¾æ›¸ã¯æ›´æ–°ã—ã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:819
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr "ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‘¼ã³å‡ºã™ (ä¸Šè¨˜ã‚’å‚ç…§) ã¨ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ (ä¸‹è¨˜ã‚’å‚ç…§)ã€‚"

#: ../../reference/datamodel.rst:828
msgid ""
"Special attributes: :attr:`~definition.__name__` is the class name; "
":attr:`__module__` is the module name in which the class was defined; "
":attr:`~object.__dict__` is the dictionary containing the class's namespace;"
" :attr:`~class.__bases__` is a tuple (possibly empty or a singleton) "
"containing the base classes, in the order of their occurrence in the base "
"class list; :attr:`__doc__` is the class's documentation string, or ``None``"
" if undefined."
msgstr "ç‰¹æ®Šå±æ€§: :attr:`~definition.__name__` ã¯ã‚¯ãƒ©ã‚¹åã§ã™;\n:attr:`__module__` ã¯ã‚¯ãƒ©ã‚¹ãŒå®šç¾©ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã§ã™;\n:attr:`~object.__dict__` ã¯ã‚¯ãƒ©ã‚¹ãŒæŒã¤åå‰ç©ºé–“ãŒå…¥ã£ãŸè¾æ›¸ã§ã™;\n:attr:`~class.__bases__` ã¯åŸºåº•ã‚¯ãƒ©ã‚¹ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ« (ç©ºã‚‚ã—ãã¯è¦ç´ ãŒ 1 ã¤ã—ã‹ãªã„ã“ã¨ã‚‚ã‚ã‚Šã¾ã™) ã§ã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒªã‚¹ãƒˆã«è¡¨ã‚Œã‚‹é †åºã§ä¸¦ã‚“ã§ã„ã¾ã™;\n:attr:`__doc__` ã¯ã‚¯ãƒ©ã‚¹ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ–‡å­—åˆ—ã§ã€æœªå®šç¾©ã®å ´åˆã¯ None ã§ã™ã€‚"

#: ../../reference/datamodel.rst:842
msgid ""
"A class instance is created by calling a class object (see above). A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object or an unbound user-defined method "
"object whose associated class is the class (call it :class:`C`) of the "
"instance for which the attribute reference was initiated or one of its "
"bases, it is transformed into a bound user-defined method object whose "
":attr:`im_class` attribute is :class:`C` and whose :attr:`im_self` attribute"
" is the instance. Static method and class method objects are also "
"transformed, as if they had been retrieved from class :class:`C`; see above "
"under \"Classes\". See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`. If no class"
" attribute is found, and the object's class has a :meth:`__getattr__` "
"method, that is called to satisfy the lookup."
msgstr "ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ä¸Šè¨˜å‚ç…§) ã‚’å‘¼ã³å‡ºã—ã¦ç”Ÿæˆã—ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯è¾æ›¸ã§å®Ÿè£…ã•ã‚ŒãŸåå‰ç©ºé–“ã‚’æŒã£ã¦ãŠã‚Šã€å±æ€§å‚ç…§ã®æ™‚ã«ã¯ã“ã®è¾æ›¸ãŒæœ€åˆã«æ¤œç´¢ã•ã‚Œã¾ã™ã€‚è¾æ›¸å†…ã«å±æ€§ãŒè¦‹ã¤ã‹ã‚‰ãšã€ã‹ã¤ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¯ãƒ©ã‚¹ã«è©²å½“ã™ã‚‹å±æ€§åãŒã‚ã‚‹å ´åˆã€æ¤œç´¢ã¯ã‚¯ãƒ©ã‚¹å±æ€§ã«ã¾ã§åºƒã’ã‚‰ã‚Œã¾ã™ã€‚è¦‹ã¤ã‹ã£ãŸã‚¯ãƒ©ã‚¹å±æ€§ãŒãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¯ãƒ©ã‚¹ (:class:`C` ã¨ã—ã¾ã™) ã‚„ãã®åŸºåº•ã‚¯ãƒ©ã‚¹ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹éçµåˆã®ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€ :attr:`im_class` å±æ€§ãŒ :class:`C` ã§ :attr:`im_self` å±æ€§ãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã£ã¦ã„ã‚‹çµåˆãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚„ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ã¾ãŸã€ :class:`C` ã‹ã‚‰å–ã‚Šå‡ºã—ãŸå ´åˆã¨åŒæ§˜ã«å¤‰æ›ã•ã‚Œã¾ã™; ä¸Šè¨˜ã® \"ã‚¯ãƒ©ã‚¹\" ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ã‚¯ãƒ©ã‚¹ã‹ã‚‰å–ã‚Šå‡ºã—ãŸå±æ€§ã¨å®Ÿéš›ã« :attr:`~object.__dict__` ã«å…¥ã£ã¦ã„ã‚‹ã‚‚ã®ãŒç•°ãªã‚‹ã‚ˆã†ãªä»–ã®å ´åˆã«ã¤ã„ã¦ã¯ã€ :ref:`descriptors` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ã‚¯ãƒ©ã‚¹å±æ€§ãŒè¦‹ã¤ã‹ã‚‰ãšã€ã‹ã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¯ãƒ©ã‚¹ãŒ :meth:`__getattr__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦å±æ€§åã®æ¤œç´¢ã‚’å……è¶³ã•ã›ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:861
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`__setattr__` or "
":meth:`__delattr__` method, this is called instead of updating the instance "
"dictionary directly."
msgstr "å±æ€§ã®ä»£å…¥ã‚„å‰Šé™¤ã‚’è¡Œã†ã¨ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è¾æ›¸ã‚’æ›´æ–°ã—ã¾ã™ãŒã€ã‚¯ãƒ©ã‚¹ã®è¾æ›¸ã‚’æ›´æ–°ã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¹ã§ :meth:`__setattr__` ã‚„ :meth:`__delattr__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ç›´æ¥ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è¾æ›¸ã‚’æ›´æ–°ã™ã‚‹ä»£ã‚ã‚Šã«ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:871
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr "ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ã‚ã‚‹ç‰¹å®šã®åå‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã€æ•°å€¤å‹ã‚„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã€ã‚ã‚‹ã„ã¯ãƒãƒƒãƒ—å‹ã®ã‚ˆã†ã«æŒ¯èˆã†ã“ã¨ãŒã§ãã¾ã™ã€‚ :ref:`specialnames` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:878
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary; "
":attr:`~instance.__class__` is the instance's class."
msgstr "ç‰¹æ®Šå±æ€§: :attr:`~object.__dict__` ã¯å±æ€§ã®è¾æ›¸ã§ã™; :attr:`~instance.__class__` ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../reference/datamodel.rst:902
msgid "Files"
msgstr "ãƒ•ã‚¡ã‚¤ãƒ« (file)"

#: ../../reference/datamodel.rst:895
msgid ""
"A file object represents an open file.  File objects are created by the "
":func:`open` built-in function, and also by :func:`os.popen`, "
":func:`os.fdopen`, and the :meth:`makefile` method of socket objects (and "
"perhaps by other functions or methods provided by extension modules).  The "
"objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized to "
"file objects corresponding to the interpreter's standard input, output and "
"error streams.  See :ref:`bltin-file-objects` for complete documentation of "
"file objects."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¡¨ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿é–¢æ•° :func:`open` ã‚„ã€ :func:`os.popen`, :func:`os.fdopen`, ãŠã‚ˆã³ socke ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`makefile` ãƒ¡ã‚½ãƒƒãƒ‰ (ãã®ä»–ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§æä¾›ã•ã‚Œã¦ã„ã‚‹é–¢æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰) ã§ç”Ÿæˆã•ã‚Œã¾ã™ã€‚ ``sys.stdin``, ``sys.stdout`` ãŠã‚ˆã³ ``sys.stderr`` ã¨ã„ã£ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®æ¨™æº–å…¥åŠ›ã€æ¨™æº–å‡ºåŠ›ã€ãŠã‚ˆã³æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾å¿œã™ã‚‹ã‚ˆã†åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«é–¢ã™ã‚‹å®Œå…¨ãªè¨˜è¿°ã«ã¤ã„ã¦ã¯ã€ :ref:`bltin-file-objects` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1110
msgid "Internal types"
msgstr "å†…éƒ¨å‹ (internal type)"

#: ../../reference/datamodel.rst:909
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr "ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒå†…éƒ¨çš„ã«ä½¿ã£ã¦ã„ã‚‹ã„ãã¤ã‹ã®å‹ã¯ã€ãƒ¦ãƒ¼ã‚¶ã«å…¬é–‹ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å®šç¾©ã¯å°†æ¥ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯å¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ãŒã€ã“ã“ã§ã¯è¨˜è¿°ã®å®Œå…¨æ€§ã®ãŸã‚ã«è§¦ã‚Œã¦ãŠãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:977
msgid "Code objects"
msgstr "ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../reference/datamodel.rst:916
msgid ""
"Code objects represent *byte-compiled* executable Python code, or "
":term:`bytecode`. The difference between a code object and a function object"
" is that the function object contains an explicit reference to the "
"function's globals (the module in which it was defined), while a code object"
" contains no context; also the default argument values are stored in the "
"function object, not in the code object (because they represent values "
"calculated at run-time).  Unlike function objects, code objects are "
"immutable and contain no references (directly or indirectly) to mutable "
"objects."
msgstr "ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ *ãƒã‚¤ãƒˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸ (byte-compiled)* å®Ÿè¡Œå¯èƒ½ãª Python ã‚³ãƒ¼ãƒ‰ã€åˆ¥åãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰(:term:`bytecode`) ã‚’è¡¨ç¾ã—ã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é•ã„ã¯ã€é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒé–¢æ•°ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° (é–¢æ•°ã‚’å®šç¾©ã—ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«) ã«å¯¾ã—ã¦æ˜ç¤ºçš„ãªå‚ç…§ã‚’æŒã£ã¦ã„ã‚‹ã®ã«å¯¾ã—ã€ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒãªã„ã¨ã„ã†ã“ã¨ã§ã™; ã¾ãŸã€é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°å€¤ã‚’è¨˜æ†¶ã§ãã¾ã™ãŒã€ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã§ãã¾ã›ã‚“ (å®Ÿè¡Œæ™‚ã«è¨ˆç®—ã•ã‚Œã‚‹å€¤ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚)ã€‚é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨é•ã„ã€ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤‰æ›´ä¸å¯èƒ½ã§ã€å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’ (ç›´æ¥ã€é–“æ¥ã«é–¢ã‚ã‚‰ãš) å«ã¿ã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:941
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; "
":attr:`co_argcount` is the number of positional arguments (including "
"arguments with default values); :attr:`co_nlocals` is the number of local "
"variables used by the function (including arguments); :attr:`co_varnames` is"
" a tuple containing the names of the local variables (starting with the "
"argument names); :attr:`co_cellvars` is a tuple containing the names of "
"local variables that are referenced by nested functions; :attr:`co_freevars`"
" is a tuple containing the names of free variables; :attr:`co_code` is a "
"string representing the sequence of bytecode instructions; :attr:`co_consts`"
" is a tuple containing the literals used by the bytecode; :attr:`co_names` "
"is a tuple containing the names used by the bytecode; :attr:`co_filename` is"
" the filename from which the code was compiled; :attr:`co_firstlineno` is "
"the first line number of the function; :attr:`co_lnotab` is a string "
"encoding the mapping from bytecode offsets to line numbers (for details see "
"the source code of the interpreter); :attr:`co_stacksize` is the required "
"stack size (including local variables); :attr:`co_flags` is an integer "
"encoding a number of flags for the interpreter."
msgstr "èª­ã¿å‡ºã—å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`co_name` ã¯é–¢æ•°åã‚’è¡¨ã—ã¾ã™; :attr:`co_argcount` ã¯å›ºå®šå¼•æ•° (positional argument) ã®æ•°ã§ã™; :attr:`co_nlocals` ã¯é–¢æ•°ãŒä½¿ã† (å¼•æ•°ã‚’å«ã‚ãŸ) ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®æ•°ã§ã™; :attr:`co_varnames` ã¯ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°åã®å…¥ã£ãŸã‚¿ãƒ—ãƒ«ã§ã™ (å¼•æ•°åã‹ã‚‰å§‹ã¾ã£ã¦ã„ã¾ã™); :attr:`co_cellvars` ã¯ãƒã‚¹ãƒˆã•ã‚ŒãŸé–¢æ•°ã§å‚ç…§ã•ã‚Œã¦ã„ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®åå‰ãŒå…¥ã£ãŸã‚¿ãƒ—ãƒ«ã§ã™; :attr:`co_freevars` ã¯è‡ªç”±å¤‰æ•°ã®åå‰ãŒå…¥ã£ãŸã‚¿ãƒ—ãƒ«ã§ã™ã€‚ :attr:`co_code` ã¯ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰åˆ—ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹æ–‡å­—åˆ—ã§ã™; :attr:`co_consts` ã¯ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ãƒªãƒ†ãƒ©ãƒ«ã®å…¥ã£ãŸã‚¿ãƒ—ãƒ«ã§ã™; :attr:`co_names` ã¯ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹åå‰ã®å…¥ã£ãŸã‚¿ãƒ—ãƒ«ã§ã™; :attr:`co_filename` ã¯ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒè¡Œã‚ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«åã§ã™; :attr:`co_firstlineno` ã¯é–¢æ•°ã®æœ€åˆã®è¡Œç•ªå·ã§ã™; :attr:`co_lnotab` ã¯ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã‚ªãƒ•ã‚»ãƒƒãƒˆã‹ã‚‰è¡Œç•ªå·ã¸ã®å¯¾å¿œä»˜ã‘ã‚’ã‚³ãƒ¼ãƒ‰åŒ–ã—ãŸæ–‡å­—åˆ—ã§ã™ (è©³ç´°ã«ã¤ã„ã¦ã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å‚ç…§ã—ã¦ãã ã•ã„); :attr:`co_stacksize` ã¯é–¢æ•°ã§ (ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®åˆ†ã‚‚å«ã‚ã¦) å¿…è¦ãªã‚¹ã‚¿ãƒƒã‚¯ã‚µã‚¤ã‚ºã§ã™; :attr:`co_flags` ã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ç”¨ã®æ§˜ã€…ãªãƒ•ãƒ©ã‚°ã‚’ã‚³ãƒ¼ãƒ‰åŒ–ã—ãŸæ•´æ•°ã§ã™ã€‚"

#: ../../reference/datamodel.rst:960
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is "
"set if the function uses the ``*arguments`` syntax to accept an arbitrary "
"number of positional arguments; bit ``0x08`` is set if the function uses the"
" ``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` "
"is set if the function is a generator."
msgstr "ä»¥ä¸‹ã®ãƒ•ãƒ©ã‚°ãƒ“ãƒƒãƒˆãŒ :attr:`co_flags` ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™: ``0x04`` ãƒ“ãƒƒãƒˆã¯ã€é–¢æ•°ãŒ ``*arguments`` æ§‹æ–‡ã‚’ä½¿ã£ã¦ä»»æ„ã®æ•°ã®å›ºå®šå¼•æ•°ã‚’å—ç†ã§ãã‚‹å ´åˆã«ç«‹ã¦ã‚‰ã‚Œã¾ã™; ``0x08`` ãƒ“ãƒƒãƒˆã¯ã€é–¢æ•°ãŒ ``**keywords`` æ§‹æ–‡ã‚’ä½¿ã£ã¦ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’å—ç†ã§ãã‚‹å ´åˆã«ç«‹ã¦ã‚‰ã‚Œã¾ã™; ``0x20`` ãƒ“ãƒƒãƒˆã¯ã€é–¢æ•°ãŒã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã§ã‚ã‚‹å ´åˆã«ç«‹ã¦ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:966
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`co_flags` to indicate whether a code object was compiled with"
" a particular feature enabled: bit ``0x2000`` is set if the function was "
"compiled with future division enabled; bits ``0x10`` and ``0x1000`` were "
"used in earlier versions of Python."
msgstr "å°†æ¥æ©Ÿèƒ½ (future feature) å®£è¨€ (``from __future__ import division``) ã‚‚ã¾ãŸã€ :attr:`co_flags` ã®ãƒ“ãƒƒãƒˆã‚’ç«‹ã¦ã‚‹ã“ã¨ã§ã€ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç‰¹å®šã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹ã«ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™: ``0x2000`` ãƒ“ãƒƒãƒˆã¯ã€é–¢æ•°ãŒå°†æ¥æ©Ÿèƒ½ã‚’æœ‰åŠ¹ã«ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ç«‹ã¦ã‚‰ã‚Œã¾ã™; ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã§ã¯ã€ ``0x10`` ãŠã‚ˆã³ ``0x1000`` ãƒ“ãƒƒãƒˆãŒä½¿ã‚ã‚Œã¦ã„ã¾ã—ãŸã€‚"

#: ../../reference/datamodel.rst:972
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ":attr:`co_flags` ã®ãã®ä»–ã®ãƒ“ãƒƒãƒˆã¯å°†æ¥ã«å†…éƒ¨çš„ã«åˆ©ç”¨ã™ã‚‹ãŸã‚ã«äºˆç´„ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:976
msgid ""
"If a code object represents a function, the first item in :attr:`co_consts` "
"is the documentation string of the function, or ``None`` if undefined."
msgstr "ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒé–¢æ•°ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹å ´åˆã€ :attr:`co_consts` ã®æœ€åˆã®è¦ç´ ã¯é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã«ãªã‚Šã¾ã™ã€‚ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã«ã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1019
msgid "Frame objects"
msgstr "ãƒ•ãƒ¬ãƒ¼ãƒ  (frame) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../reference/datamodel.rst:984
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below)."
msgstr "ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å®Ÿè¡Œãƒ•ãƒ¬ãƒ¼ãƒ  (execution frame) ã‚’è¡¨ã—ã¾ã™ã€‚å®Ÿè¡Œãƒ•ãƒ¬ãƒ¼ãƒ ã¯ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå†…ã«å‡ºç¾ã—ã¾ã™ (ä¸‹è¨˜å‚ç…§)ã€‚"

#: ../../reference/datamodel.rst:996
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack frame "
"(towards the caller), or ``None`` if this is the bottom stack frame; "
":attr:`f_code` is the code object being executed in this frame; "
":attr:`f_locals` is the dictionary used to look up local variables; "
":attr:`f_globals` is used for global variables; :attr:`f_builtins` is used "
"for built-in (intrinsic) names; :attr:`f_restricted` is a flag indicating "
"whether the function is executing in restricted execution mode; "
":attr:`f_lasti` gives the precise instruction (this is an index into the "
"bytecode string of the code object)."
msgstr "èª­ã¿å‡ºã—å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`f_back` ã¯ (å‘¼ã³å‡ºã—å´ã«ã¨ã£ã¦ã®) ä»¥å‰ã®ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã§ã™ã€‚å‘¼ã³å‡ºã—å´ãŒã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã®æœ€ä¸‹æ®µã§ã‚ã‚‹å ´åˆã«ã¯ ``None`` ã§ã™; :attr:`f_code` ã¯ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§å®Ÿè¡Œã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™; :attr:`f_locals` ã¯ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã‚’æ¤œç´¢ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹è¾æ›¸ã§ã™; :attr:`f_globals` ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ç”¨ã§ã™; :attr:`f_builtins` ã¯çµ„ã¿è¾¼ã¿ã® (Python å›ºæœ‰ã®) åå‰ã§ã™; :attr:`f_restricted` ã¯ã€é–¢æ•°ãŒåˆ¶é™ã¤ãå®Ÿè¡Œ (restricted execution) ãƒ¢ãƒ¼ãƒ‰ã§å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™ãƒ•ãƒ©ã‚°ã§ã™; :attr:`f_lasti` ã¯å³å¯†ãªå‘½ä»¤ã‚³ãƒ¼ãƒ‰ (ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸­ã®ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—ã¸ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹) ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1012
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a function"
" called at the start of each source code line (this is used by the "
"debugger); :attr:`f_exc_type`, :attr:`f_exc_value`, :attr:`f_exc_traceback` "
"represent the last exception raised in the parent frame provided another "
"exception was ever raised in the current frame (in all other cases they are "
"``None``); :attr:`f_lineno` is the current line number of the frame --- "
"writing to this from within a trace function jumps to the given line (only "
"for the bottom-most frame).  A debugger can implement a Jump command (aka "
"Set Next Statement) by writing to f_lineno."
msgstr "æ›¸ãè¾¼ã¿å¯èƒ½ãªç‰¹æ®Šå±æ€§: :attr:`f_trace` ãŒ ``None`` ã§ãªã„å ´åˆã€å„ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰è¡Œã®å…ˆé ­ã§å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°ã«ãªã‚Šã¾ã™; :attr:`f_exc_type`, :attr:`f_exc_value`, :attr:`f_exc_traceback` ã¯ã€ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãŒä»¥å‰ã«å¼•ãèµ·ã“ã—ãŸä¾‹å¤–ãŒæä¾›ã™ã‚‹è¦ªãƒ•ãƒ¬ãƒ¼ãƒ å†…ã§ã‚‚ã£ã¨ã‚‚æœ€è¿‘æ•æ‰ã•ã‚ŒãŸä¾‹å¤–ã‚’è¡¨ã—ã¾ã™ (ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€ã“ã‚Œã‚‰ã¯ ``None`` ã«ãªã‚Šã¾ã™); :attr:`f_lineno` ã¯ãƒ•ãƒ¬ãƒ¼ãƒ ä¸­ã«ãŠã‘ã‚‹ç¾åœ¨ã®è¡Œç•ªå·ã§ã™ --- ãƒˆãƒ¬ãƒ¼ã‚¹é–¢æ•° (trace function) å´ã§ã“ã®å€¤ã«æ›¸ãè¾¼ã¿ã‚’è¡Œã†ã¨ã€æŒ‡å®šã—ãŸè¡Œã«ã‚¸ãƒ£ãƒ³ãƒ—ã—ã¾ã™ (æœ€ä¸‹æ®µã®å®Ÿè¡Œãƒ•ãƒ¬ãƒ¼ãƒ ã«ã„ã‚‹ã¨ãã®ã¿) ã€‚ãƒ‡ãƒãƒƒã‚¬ã§ã¯ã€ f_fileno ã‚’æ›¸ãè¾¼ã‚€ã“ã¨ã§ã€ã‚¸ãƒ£ãƒ³ãƒ—å‘½ä»¤ (Set Next Statement å‘½ä»¤ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™) ã‚’å®Ÿè£…ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1061
msgid "Traceback objects"
msgstr "ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ (traceback) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../reference/datamodel.rst:1034
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is created when an exception occurs.  When the search for an "
"exception handler unwinds the execution stack, at each unwound level a "
"traceback object is inserted in front of the current traceback.  When an "
"exception handler is entered, the stack trace is made available to the "
"program. (See section :ref:`try`.) It is accessible as "
"``sys.exc_traceback``, and also as the third item of the tuple returned by "
"``sys.exc_info()``.  The latter is the preferred interface, since it works "
"correctly when the program is using multiple threads. When the program "
"contains no suitable handler, the stack trace is written (nicely formatted) "
"to the standard error stream; if the interpreter is interactive, it is also "
"made available to the user as ``sys.last_traceback``."
msgstr "ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¾‹å¤–ã®ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’è¡¨ç¾ã—ã¾ã™ã€‚ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸéš›ã«ç”Ÿæˆã•ã‚Œã¾ã™ã€‚ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã‚’æ¤œç´¢ã—ã¦å®Ÿè¡Œã‚¹ã‚¿ãƒƒã‚¯ã‚’æˆ»ã£ã¦ã„ãéš›ã€æˆ»ã£ãŸãƒ¬ãƒ™ãƒ«æ¯ã«ã€ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç¾åœ¨ã®ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã®å‰ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã«å…¥ã‚‹ã¨ã€ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ å´ã§åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ (:ref:`try` ã‚’å‚ç…§)ã€‚ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã¯ ``sys.exc_traceback`` ã¨ã—ã¦å¾—ã‚‹ã“ã¨ãŒã§ãã€ ``sys.exc_info()`` ãŒè¿”ã™ã‚¿ãƒ—ãƒ«ã®ä¸‰ç•ªç›®ã®è¦ç´ ã¨ã—ã¦ã‚‚å¾—ã‚‰ã‚Œã¾ã™. ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¨ã—ã¦ã¯å¾Œè€…ã®æ–¹ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ãŒã€ã“ã‚Œã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ã„ã‚‹å ´åˆã«æ­£ã—ãå‹•ä½œã™ã‚‹ã‹ã‚‰ã§ã™ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«é©åˆ‡ãªãƒãƒ³ãƒ‰ãƒ©ãŒãªã„å ´åˆã€ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã¯ (ã†ã¾ãæ›¸å¼åŒ–ã•ã‚Œã¦) æ¨™æº–ã‚¨ãƒ©ãƒ¼ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«æ›¸ãå‡ºã•ã‚Œã¾ã™; ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒå¯¾è©±çš„ã«å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹å ´åˆã€ ``sys.last_traceback`` ã¨ã—ã¦å¾—ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1054
msgid ""
"Special read-only attributes: :attr:`tb_next` is the next level in the stack"
" trace (towards the frame where the exception occurred), or ``None`` if "
"there is no next level; :attr:`tb_frame` points to the execution frame of "
"the current level; :attr:`tb_lineno` gives the line number where the "
"exception occurred; :attr:`tb_lasti` indicates the precise instruction.  The"
" line number and last instruction in the traceback may differ from the line "
"number of its frame object if the exception occurred in a :keyword:`try` "
"statement with no matching except clause or with a finally clause."
msgstr "èª­ã¿å‡ºã—å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`tb_next` ã¯ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹å†…ã® (ä¾‹å¤–ã®ç™ºç”Ÿã—ã¦ã„ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã«å‘ã‹ã£ã¦) æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã§ã™ã€‚æ¬¡ã®ãƒ¬ãƒ™ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã«ã¯ ``None`` ã«ãªã‚Šã¾ã™; :attr:`tb_frame` ã¯ç¾åœ¨ã®ãƒ¬ãƒ™ãƒ«ã«ãŠã‘ã‚‹å®Ÿè¡Œãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æŒ‡ã—ã¾ã™; :attr:`tb_lineno` ã¯ä¾‹å¤–ã®ç™ºç”Ÿã—ãŸè¡Œç•ªå·ã§ã™; :attr:`tb_lasti` ã¯å³å¯†ãªå‘½ä»¤ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯å†…ã®è¡Œç•ªå·ã‚„æœ€å¾Œã«å®Ÿè¡Œã•ã‚ŒãŸå‘½ä»¤ã¯ã€ :keyword:`try` æ–‡å†…ã§ä¾‹å¤–ãŒç™ºç”Ÿã—ã€ã‹ã¤å¯¾å¿œã™ã‚‹ :keyword:`except` ç¯€ã‚„ :keyword:`finally` ç¯€ãŒãªã„å ´åˆã«ã¯ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå†…ã®è¡Œç•ªå·ã¨ã¯ç•°ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1092
msgid "Slice objects"
msgstr "ã‚¹ãƒ©ã‚¤ã‚¹ (slice) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../reference/datamodel.rst:1066
msgid ""
"Slice objects are used to represent slices when *extended slice syntax* is "
"used. This is a slice using two colons, or multiple slices or ellipses "
"separated by commas, e.g., ``a[i:j:step]``, ``a[i:j, k:l]``, or ``a[..., "
"i:j]``.  They are also created by the built-in :func:`slice` function."
msgstr "ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ *æ‹¡å¼µã‚¹ãƒ©ã‚¤ã‚¹æ§‹æ–‡ (extended slice syntax)* ãŒä½¿ã‚ã‚ŒãŸéš›ã«ã‚¹ãƒ©ã‚¤ã‚¹ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚æ‹¡å¼µã‚¹ãƒ©ã‚¤ã‚¹æ§‹æ–‡ã¨ã¯ã€äºŒã¤ã®ã‚³ãƒ­ãƒ³ã‚„ã€ã‚³ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸè¤‡æ•°ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚„çœç•¥ç¬¦å· (ellipse) ã‚’ä½¿ã£ãŸã‚¹ãƒ©ã‚¤ã‚¹ã§ã€ä¾‹ãˆã° ``a[i:j:step]`` ã€ ``a[i:j, k:l]`` ã€ã‚ã‚‹ã„ã¯ ``a[..., i:j]`` ã§ã™ã€‚ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿é–¢æ•° :func:`slice` ã§ç”Ÿæˆã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1076
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; "
":attr:`~slice.stop` is the upper bound; :attr:`~slice.step` is the step "
"value; each is ``None`` if omitted.  These attributes can have any type."
msgstr "èª­ã¿è¾¼ã¿å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`~slice.start` ã¯ä¸‹é™ã§ã™; :attr:`~slice.stop` ã¯ä¸Šé™ã§ã™; :attr:`~slice.step` ã¯ã‚¹ãƒ†ãƒƒãƒ—ã®å€¤ã§ã™; ãã‚Œãã‚Œçœç•¥ã•ã‚ŒãŸå ´åˆã¯ ``None`` ã¨ãªã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å±æ€§ã¯ä»»æ„ã®å‹ã‚’æŒã¦ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1080
msgid "Slice objects support one method:"
msgstr "ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¸€ã¤ã‚µãƒãƒ¼ãƒˆã—ã¾ã™:"

#: ../../reference/datamodel.rst:1085
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the extended slice that the slice object would describe if"
" applied to a sequence of *length* items.  It returns a tuple of three "
"integers; respectively these are the *start* and *stop* indices and the "
"*step* or stride length of the slice. Missing or out-of-bounds indices are "
"handled in a manner consistent with regular slices."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å˜ä¸€ã®æ•´æ•°å¼•æ•° *length* ã‚’å–ã‚Šã€ *length* å€‹ã®è¦ç´ ã‹ã‚‰ãªã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«é©ç”¨ã—ãŸéš›ã«ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰æä¾›ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€æ‹¡å¼µã‚¹ãƒ©ã‚¤ã‚¹ã«é–¢ã™ã‚‹æƒ…å ±ã‚’è¨ˆç®—ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä¸‰ã¤ã®æ•´æ•°ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™; ãã‚Œãã‚Œ *start* ãŠã‚ˆã³ *stop* ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã¨ã€ *step* ã¾ãŸã¯ã‚¹ãƒ©ã‚¤ã‚¹é–“ã®å¹…ã«å¯¾å¿œã—ã¾ã™ã€‚ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å€¤ãŒãªã„ã‹ã€ç¯„å›²å¤–ã®å€¤ã§ã‚ã‚‹å ´åˆã€é€šå¸¸ã®ã‚¹ãƒ©ã‚¤ã‚¹ã«å¯¾ã—ã¦ä¸€è²«æ€§ã®ã‚ã‚‹ã‚„ã‚Šã‹ãŸã§æ‰±ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1102
msgid "Static method objects"
msgstr "é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ (static method) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../reference/datamodel.rst:1095
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are not themselves "
"callable, although the objects they wrap usually are. Static method objects "
"are created by the built-in :func:`staticmethod` constructor."
msgstr "é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä¸Šã§èª¬æ˜ã—ãŸã‚ˆã†ãªé–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¤‰æ›ã‚’é˜»æ­¢ã™ã‚‹ãŸã‚ã®æ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»–ã®ä½•ã‚‰ã‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€é€šå¸¸ã¯ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åŒ…ã‚€ãƒ©ãƒƒãƒ‘ã§ã™ã€‚é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚¯ãƒ©ã‚¹ã‚„ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰å–å¾—ã™ã‚‹ã¨ã€å®Ÿéš›ã«è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã€ãã‚Œä»¥ä¸Šã¯å¤‰æ›ã®å¯¾è±¡ã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é€šå¸¸å‘¼ã³å‡ºã—å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ©ãƒƒãƒ—ã—ã¾ã™ãŒã€é™çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã¯å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚é™çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ :func:`staticmethod` ã§ç”Ÿæˆã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1110
msgid "Class method objects"
msgstr "ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../reference/datamodel.rst:1105
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such"
" retrieval is described above, under \"User-defined methods\". Class method "
"objects are created by the built-in :func:`classmethod` constructor."
msgstr "ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ä¼¼ã¦ã€åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åŒ…ã‚€ãƒ©ãƒƒãƒ‘ã§ã‚ã‚Šã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒ©ã‚¹ã‚„ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰å–ã‚Šå‡ºã™æ–¹æ³•ã‚’ä»£æ›¿ã—ã¾ã™ã€‚ã“ã®ã‚ˆã†ã«ã—ã¦å–å¾—ã—ãŸã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹•ä½œã«ã¤ã„ã¦ã¯ã€ä¸Šã® \"ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ (user-defined method)\" ã§èª¬æ˜ã•ã‚Œã¦ã„ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ :func:`classmethod` ã§ç”Ÿæˆã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1115
msgid "New-style and classic classes"
msgstr "æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã¨æ—§ã‚¹ã‚¿ã‚¤ãƒ«"

#: ../../reference/datamodel.rst:1117
msgid ""
"Classes and instances come in two flavors: old-style (or classic) and new-"
"style."
msgstr "ã‚¯ãƒ©ã‚¹ã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯å¥½ã¿ã«åˆã‚ã›ã¦2ç¨®é¡ã®æ–¹æ³•ã§è¨˜è¿°ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™: æ—§ã‚¹ã‚¿ã‚¤ãƒ«(ã‚‚ã—ãã¯ã‚¯ãƒ©ã‚·ãƒƒã‚¯ã‚¹ã‚¿ã‚¤ãƒ«)ã¨æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1119
msgid ""
"Up to Python 2.1 the concept of ``class`` was unrelated to the concept of "
"``type``, and old-style classes were the only flavor available.  For an old-"
"style class, the statement ``x.__class__`` provides the class of *x*, but "
"``type(x)`` is always ``<type 'instance'>``.  This reflects the fact that "
"all old-style instances, independent of their class, are implemented with a "
"single built-in type, called ``instance``."
msgstr "Python 2.1 ã¾ã§ã¯ã€ ``class`` ã®æ¦‚å¿µã¯ ``type`` ã®æ¦‚å¿µã¨ã¯ç„¡é–¢ä¿‚ã§ã€ã¾ãŸã€æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ãŒå”¯ä¸€ã®ã‚‚ã®ã§ã—ãŸã€‚æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã§ã¯ã€ ``x.__class__`` ã¯ *x* ã®ã‚¯ãƒ©ã‚¹ã‚’æä¾›ã¯ã—ã¾ã™ãŒã€ ``type(x)`` ã¯å¸¸ã« ``<type 'instance'>`` ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€ã™ã¹ã¦ã®æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã€ãã‚Œã‚‰ã®ã‚¯ãƒ©ã‚¹ã¨ã¯ç‹¬ç«‹ã®ã€ ``instance`` ã¨å‘¼ã°ã‚Œã‚‹ä¸€ã¤ã®å†…è”µå‹ã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã¨ã„ã†ã“ã¨ã‚’åæ˜ ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1126
msgid ""
"New-style classes were introduced in Python 2.2 to unify the concepts of "
"``class`` and ``type``.  A new-style class is simply a user-defined type, no"
" more, no less.  If *x* is an instance of a new-style class, then "
"``type(x)`` is typically the same as ``x.__class__`` (although this is not "
"guaranteed -- a new-style class instance is permitted to override the value "
"returned for ``x.__class__``)."
msgstr "æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚¯ãƒ©ã‚¹ã¯ã€ã€€``class`` ã¨ ``type`` ã®æ¦‚å¿µã‚’çµ±ä¸€ã™ã‚‹ãŸã‚ã« Python 2.2 ã§å°å…¥ã•ã‚Œã¾ã—ãŸã€‚æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚¯ãƒ©ã‚¹ã¯ãƒ¦ãƒ¼ã‚¶å®šç¾©å‹ãã®ã‚‚ã®ã§ã€ãã‚Œä»¥ä¸Šã§ã‚‚ä»¥ä¸‹ã§ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—ã€ *x* ãŒæ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã£ãŸå ´åˆã€ ``type(x)`` ã¯ ``x.__class__`` ã¨åŒã˜ã«ãªã‚Šã¾ã™ã€‚ (ãŸã ã—ã€ã“ã‚Œã¯ä¿è¨¼ã•ã‚Œã¦ã„ã‚‹å‹•ä½œã§ã¯ã‚ã‚Šã¾ã›ã‚“ -- æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ ``x.__class__`` ã§è¿”ã‚‹å€¤ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚)"

#: ../../reference/datamodel.rst:1133
msgid ""
"The major motivation for introducing new-style classes is to provide a "
"unified object model with a full meta-model.  It also has a number of "
"practical benefits, like the ability to subclass most built-in types, or the"
" introduction of \"descriptors\", which enable computed properties."
msgstr "æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã‚’å°å…¥ã™ã‚‹ä¸€ç•ªã®ç†ç”±ã¯ã€ãƒ¡ã‚¿ãƒ¢ãƒ‡ãƒ«ã‚’ç”¨ã„ãŸçµ±ä¸€çš„ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ¢ãƒ‡ãƒ«ã‚’æä¾›ã™ã‚‹ã“ã¨ã«ã‚ã‚Šã¾ã™ã€‚ã¾ãŸã€ã»ã¨ã‚“ã©ã®çµ„ã¿è¾¼ã¿å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒä½œæˆã§ãã‚‹ã€å±æ€§ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®\"ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿\"ã®å°å…¥ã§ãã‚‹ç­‰ã®åˆ©ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1138
msgid ""
"For compatibility reasons, classes are still old-style by default.  New-"
"style classes are created by specifying another new-style class (i.e. a "
"type) as a parent class, or the \"top-level type\" :class:`object` if no "
"other parent is needed.  The behaviour of new-style classes differs from "
"that of old-style classes in a number of important details in addition to "
"what :func:`type` returns.  Some of these changes are fundamental to the new"
" object model, like the way special methods are invoked.  Others are "
"\"fixes\" that could not be implemented before for compatibility concerns, "
"like the method resolution order in case of multiple inheritance."
msgstr "äº’æ›æ€§ã®ãŸã‚ã«ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã‚¯ãƒ©ã‚¹ã¯æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã«ãªã‚Šã¾ã™ã€‚æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚¯ãƒ©ã‚¹ã¯ã€ä»–ã®æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ (ã™ãªã‚ã¡å‹)ã‚’è¦ªã‚¯ãƒ©ã‚¹ã¨ã—ã¦å®šç¾©ã™ã‚‹ã€ã‚‚ã—ãã¯ã€ä»–ã®è¦ªã‚¯ãƒ©ã‚¹ãŒå¿…è¦ãªã„å ´åˆã« \"æœ€ä¸Šä½å‹\" :class:`object` ã‚’ç¶™æ‰¿ã™ã‚‹ã“ã¨ã§ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã®å‹•ä½œã¯æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã®å‹•ä½œã¨ã¯ã€ :func:`type` ãŒä½•ã‚’è¿”ã™ã‹ã¨ã„ã£ãŸã“ã¨ã‚’ã¯ã˜ã‚ã€ä½•ç‚¹ã‹é‡è¦ãªéƒ¨åˆ†ãŒç•°ãªã‚Šã¾ã™ã€‚ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ãªã©ã€ã“ã‚Œã‚‰ã®å¤‰æ›´ã¯æ–°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ¢ãƒ‡ãƒ«ã®åŸºç›¤ã¨ãªã£ã¦ã„ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®éƒ¨åˆ†ã¯ã€å¤šé‡ç¶™æ‰¿æ™‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®è§£æ±ºé †ãªã©ã®ã‚ˆã†ã«ã€äº’æ›æ€§ã®å•é¡Œã§ä»¥å‰ã¯å®Ÿè£…ãŒä¸å¯èƒ½ã§ã‚ã£ãŸ\"ä¿®æ­£\"ãŒæ–°ã‚¯ãƒ©ã‚¹ã«å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1148
msgid ""
"While this manual aims to provide comprehensive coverage of Python's class "
"mechanics, it may still be lacking in some areas when it comes to its "
"coverage of new-style classes. Please see "
"https://www.python.org/doc/newstyle/ for sources of additional information."
msgstr "ã“ã®ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã¯ Python ã®ã‚¯ãƒ©ã‚¹ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã«é–¢ã™ã‚‹ç·åˆçš„ãªæƒ…å ±ã‚’æä¾›ã—ã‚ˆã†ã¨ã—ã¦ã„ã¾ã™ãŒã€æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã«ã¤ã„ã¦ã¯ã€ã¾ã è¶³ã‚Šãªã„éƒ¨åˆ†ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚ˆã‚Šè©³ç´°ãªæƒ…å ±ã‚’å¾—ãŸã„å ´åˆã¯ã€ `<https://www.python.org/doc/newstyle/>`_ ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1158
msgid ""
"Old-style classes are removed in Python 3, leaving only new-style classes."
msgstr "Python 3 ã§ã¯æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ãŒå‰Šé™¤ã•ã‚Œã¦ã€æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ãŒå”¯ä¸€ã®ã‚¯ãƒ©ã‚¹ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../reference/datamodel.rst:1164
msgid "Special method names"
msgstr "ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰å"

#: ../../reference/datamodel.rst:1170
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named "
":meth:`__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` "
"is roughly equivalent to ``x.__getitem__(i)`` for old-style classes and "
"``type(x).__getitem__(x, i)`` for new-style classes.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or "
":exc:`TypeError`)."
msgstr "ç‰¹æ®Šãªåå‰ã‚’ã‚‚ã£ãŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§ã€ç‰¹æ®Šãªæ§‹æ–‡ (ç®—è¡“æ¼”ç®—ã‚„æ·»ãˆå­—è¡¨è¨˜ã€ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã®ã‚ˆã†ãª) ç‰¹å®šã®æ¼”ç®—ã‚’ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€å€‹ã€…ã®ã‚¯ãƒ©ã‚¹ãŒ Python è¨€èªã§æä¾›ã•ã‚Œã¦ã„ã‚‹æ¼”ç®—å­ã«å¯¾å¿œã—ãŸç‹¬è‡ªã®æŒ¯ã‚‹èˆã„ã‚’ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®ã€æ¼”ç®—å­ã®ã‚ªãƒ¼ãƒãƒ­ãƒ¼ãƒ‰ (:dfn:`operator overloading`) ã«å¯¾ã™ã‚‹ Python ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã™ã€‚ä¾‹ãˆã°ã€ã‚ã‚‹ã‚¯ãƒ©ã‚¹ãŒ :meth:`__getitem__` ã¨ã„ã†åå‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ãŠã‚Šã€ ``x`` ãŒã“ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹ã¨ã™ã‚‹ã¨ã€ ``x[i]`` ã¯æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã®å ´åˆ ``x.__getitem__(i)`` ã¨ã€æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã®å ´åˆ ``type(x).__getitem__(x, i)`` ã¨ã»ã¼ç­‰ä¾¡ã«ãªã‚Šã¾ã™ã€‚ç‰¹ã«æ³¨é‡ˆã®ãªã„é™ã‚Šã€é©åˆ‡ãªãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã«ã“ã®ã‚ˆã†ãªæ¼”ç®—ã‚’è¡ŒãŠã†ã¨ã™ã‚‹ã¨ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ (ç™ºç”Ÿã™ã‚‹ä¾‹å¤–ã¯ãŸã„ã¦ã„ã€ :exc:`AttributeError` ã‹ :exc:`TypeError` ã§ã™ã€‚)"

#: ../../reference/datamodel.rst:1181
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for"
" the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make sense."
"  (One example of this is the :class:`~xml.dom.NodeList` interface in the "
"W3C's Document Object Model.)"
msgstr "çµ„ã¿è¾¼ã¿å‹ã‚’æ¨¡å€£ã™ã‚‹ã‚¯ãƒ©ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ã¨ãã¯ã€çœŸä¼¼ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¨ã£ã¦æ„å‘³ãŒã‚ã‚‹ç¯„å›²ã«å®Ÿè£…ã‚’ã¨ã©ã‚ã‚‹ã®ãŒé‡è¦ã§ã™ã€‚ä¾‹ãˆã°ã€ã‚ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯å€‹ã€…ã®è¦ç´ ã®å–å¾—ã¯ãã¡ã‚“ã¨å‹•ãã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ã‚¹ãƒ©ã‚¤ã‚¹ã®å±•é–‹ãŒæ„å‘³ã‚’ç‚ºã•ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ (W3C ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ¢ãƒ‡ãƒ«ã«ã‚ã‚‹ :class:`~xml.dom.NodeList` ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒãã®ä¸€ä¾‹ã§ã™ã€‚)"

#: ../../reference/datamodel.rst:1192
msgid "Basic customization"
msgstr "åŸºæœ¬çš„ãªã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º"

#: ../../reference/datamodel.rst:1198
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static"
" method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr "ã‚¯ãƒ©ã‚¹ *cls* ã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ :meth:`__new__` ã¯é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã§ (ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ç‰¹åˆ¥æ‰±ã„ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€æ˜ç¤ºçš„ã«é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã¨å®£è¨€ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“)ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ã‚ˆã†è¦æ±‚ã•ã‚Œã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã‚’ç¬¬ä¸€å¼•æ•°ã«ã¨ã‚Šã¾ã™ã€‚æ®‹ã‚Šã®å¼•æ•°ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å¼ (ã‚¯ãƒ©ã‚¹ã®å‘¼ã³å‡ºã—æ–‡) ã«æ¸¡ã•ã‚Œã¾ã™ã€‚ :meth:`__new__` ã®æˆ»ã‚Šå€¤ã¯æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ (é€šå¸¸ã¯ *cls* ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹) ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1205
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super(currentclass, "
"cls).__new__(cls[, ...])`` with appropriate arguments and then modifying the"
" newly-created instance as necessary before returning it."
msgstr "å…¸å‹çš„ãªå®Ÿè£…ã§ã¯ã€ã‚¯ãƒ©ã‚¹ã®æ–°ãŸãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ã¨ãã«ã¯ ``super(currentclass, cls).__new__(cls[, ...])`` ã«é©åˆ‡ãªå¼•æ•°ã‚’æŒ‡å®šã—ã¦ã‚¹ãƒ¼ãƒ‘ã‚¯ãƒ©ã‚¹ã® :meth:`__new__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã€æ–°ãŸã«ç”Ÿæˆã•ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¿…è¦ãªå¤‰æ›´ã‚’åŠ ãˆã¦ã‹ã‚‰è¿”ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1210
msgid ""
"If :meth:`__new__` returns an instance of *cls*, then the new instance's "
":meth:`__init__` method will be invoked like ``__init__(self[, ...])``, "
"where *self* is the new instance and the remaining arguments are the same as"
" were passed to :meth:`__new__`."
msgstr ":meth:`__new__` ãŒ *cls* ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ãŸå ´åˆã€ ``__init__(self[, ...])`` ã®ã‚ˆã†ã«ã—ã¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® :meth:`__init__` ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®ã¨ãã€ *self* ã¯æ–°ãŸã«ç”Ÿæˆã•ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã€æ®‹ã‚Šã®å¼•æ•°ã¯ :meth:`__new__` ã«æ¸¡ã•ã‚ŒãŸå¼•æ•°ã¨åŒã˜ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1215
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ":meth:`__new__` ãŒ *cls* ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã•ãªã„å ´åˆã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å‘¼ã³å‡ºã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1218
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ":meth:`__new__` ã®ä¸»ãªç›®çš„ã¯ã€å¤‰æ›´ä¸èƒ½ãªå‹ (int, str, tuple ãªã©) ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã“ã¨ã«ã‚ã‚Šã¾ã™ã€‚ã¾ãŸã€ã‚¯ãƒ©ã‚¹ç”Ÿæˆã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ãŸã‚ã«ã€ã‚«ã‚¹ã‚¿ãƒ ã®ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã§ã‚ˆãã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1227
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the"
" derived class's :meth:`__init__` method, if any, must explicitly call it to"
" ensure proper initialization of the base class part of the instance; for "
"example: ``BaseClass.__init__(self, [args...])``."
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ (:meth:`__new__` ã«ã‚ˆã£ã¦) ç”Ÿæˆã•ã‚ŒãŸå¾Œã€ãã‚ŒãŒå‘¼ã³å‡ºã—å…ƒã«è¿”ã•ã‚Œã‚‹å‰ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚å¼•æ•°ã¯ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å¼ã«æ¸¡ã—ãŸã‚‚ã®ã§ã™ã€‚åŸºåº•ã‚¯ãƒ©ã‚¹ã¨ãã®æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ãŒã¨ã‚‚ã« :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤å ´åˆã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã® :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯åŸºåº•ã‚¯ãƒ©ã‚¹ã® :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ˜ç¤ºçš„ã«å‘¼ã³å‡ºã—ã¦ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®åŸºåº•ã‚¯ãƒ©ã‚¹éƒ¨åˆ†ãŒé©åˆ‡ã«åˆæœŸåŒ–ã•ã‚Œã‚‹ã“ã¨ä¿è¨¼ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ ``BaseClass.__init__(self, [args...])`` ã€‚"

#: ../../reference/datamodel.rst:1234
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customise "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ":meth:`__new__` ã¨ :meth:`__init__` ã¯å…±åŒã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹æˆã™ã‚‹ (:meth:`__new__` ãŒä½œæˆã—ã€ :meth:`__init__` ãŒãã‚Œã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹) ã®ã§ã€ :meth:`__init__` ãŒé ``None`` å€¤ã‚’è¿”ã™ã“ã¨ãŒã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“; ã•ã‚‚ãªã‘ã‚Œã°ã€å®Ÿè¡Œæ™‚ã« :exc:`TypeError` ãŒé€å‡ºã•ã‚Œã‚‹åŸå› ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1246
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"destructor.  If a base class has a :meth:`__del__` method, the derived "
"class's :meth:`__del__` method, if any, must explicitly call it to ensure "
"proper deletion of the base class part of the instance.  Note that it is "
"possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  It "
"may then be called at a later time when this new reference is deleted.  It "
"is not guaranteed that :meth:`__del__` methods are called for objects that "
"still exist when the interpreter exits."
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒæ¶ˆæ»…ã•ã›ã‚‰ã‚Œã‚‹éš›ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ (destructor)  ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚åŸºåº•ã‚¯ãƒ©ã‚¹ã¨ãã®æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ãŒã¨ã‚‚ã« :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤å ´åˆã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã® :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯åŸºåº•ã‚¯ãƒ©ã‚¹ã® :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ˜ç¤ºçš„ã«å‘¼ã³å‡ºã—ã¦ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®åŸºåº•ã‚¯ãƒ©ã‚¹éƒ¨åˆ†ãŒé©åˆ‡ã«æ¶ˆæ»…å‡¦ç†ã•ã‚Œã‚‹ã“ã¨ä¿è¨¼ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã™ã‚‹æ–°ãŸãªå‚ç…§ã‚’ä½œã‚‹ã“ã¨ã§ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ¶ˆæ»…ã‚’é…ã‚‰ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ (ã¨ã¯ã„ãˆã€æ¨å¥¨ã—ã¾ã›ã‚“ï¼)ã€‚ã“ã®ã‚ˆã†ã«ã™ã‚‹ã¨ã€æ–°ãŸã«ä½œæˆã•ã‚ŒãŸå‚ç…§ãŒãã®å¾Œå‰Šé™¤ã•ã‚ŒãŸéš›ã«ã‚‚ã†ä¸€åº¦ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒçµ‚äº†ã™ã‚‹éš›ã«æ®‹ã£ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã€ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ä¿è¨¼ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1258
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero.  Some common situations that may "
"prevent the reference count of an object from going to zero include: "
"circular references between objects (e.g., a doubly-linked list or a tree "
"data structure with parent and child pointers); a reference to the object on"
" the stack frame of a function that caught an exception (the traceback "
"stored in ``sys.exc_traceback`` keeps the stack frame alive); or a reference"
" to the object on the stack frame that raised an unhandled exception in "
"interactive mode (the traceback stored in ``sys.last_traceback`` keeps the "
"stack frame alive).  The first situation can only be remedied by explicitly "
"breaking the cycles; the latter two situations can be resolved by storing "
"``None`` in ``sys.exc_traceback`` or ``sys.last_traceback``.  Circular "
"references which are garbage are detected when the option cycle detector is "
"enabled (it's on by default), but can only be cleaned up if there are no "
"Python-level :meth:`__del__` methods involved. Refer to the documentation "
"for the :mod:`gc` module for more information about how :meth:`__del__` "
"methods are handled by the cycle detector, particularly the description of "
"the ``garbage`` value."
msgstr "``del x`` ã¯ç›´æ¥ ``x.__del__()`` ã‚’å‘¼ã³å‡ºã—ã¾ã›ã‚“ --- å‰è€…ã¯ ``x`` ã¸ã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ (reference count) ã‚’ 1 ã¤æ¸›ã‚‰ã—ã€å¾Œè€…ã¯ ``x`` ã¸ã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«ãªã£ãŸéš›ã«ã®ã¿å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«ãªã‚‹ã®ã‚’å¦¨ã’ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ã‚ˆãã‚ã‚‹çŠ¶æ³ã«ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ãŒã‚ã‚Šã¾ã™: è¤‡æ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé–“ã«ãŠã‘ã‚‹å¾ªç’°å‚ç…§ (äºŒé‡ãƒªãƒ³ã‚¯ãƒªã‚¹ãƒˆã‚„ã€è¦ªã¨å­ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’æŒã¤ãƒ„ãƒªãƒ¼ãƒ‡ãƒ¼ã‚¿æ§‹é€ ); ä¾‹å¤–ã‚’æ•æ‰ã—ãŸé–¢æ•°ã«ãŠã‘ã‚‹ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ä¸Šã«ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ (``sys.exc_traceback`` ã«è¨˜æ†¶ã•ã‚Œã¦ã„ã‚‹ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ãŒã€ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç”Ÿãå»¶ã³ã•ã›ã¾ã™); ã¾ãŸã¯ã€å¯¾è©±ãƒ¢ãƒ¼ãƒ‰ã§ãƒãƒ³ãƒ‰ãƒ«ã•ã‚Œãªã‹ã£ãŸä¾‹å¤–ã‚’é€å‡ºã—ãŸã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ä¸Šã«ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ (``sys.last_traceback`` ã«è¨˜æ†¶ã•ã‚Œã¦ã„ã‚‹ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ãŒã€ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç”Ÿãå»¶ã³ã•ã›ã¾ã™); æœ€åˆã®çŠ¶æ³ã«ã¤ã„ã¦ã¯ã€æ˜ç¤ºçš„ã«å¾ªç’°å‚ç…§ã‚’å£Šã™ã—ã‹è§£æ±ºç­–ã¯ã‚ã‚Šã¾ã›ã‚“; å¾Œè€…ã®äºŒã¤ã®çŠ¶æ³ã¯ã€ ``None`` ã‚’ ``sys.exc_traceback`` ã‚„ ``sys.last_traceback`` ã«å…¥ã‚Œã‚‹ã“ã¨ã§è§£æ±ºã§ãã¾ã™ã€‚ã”ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒ–ã—ãŸå¾ªç’°å‚ç…§ã¯ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¾ªç’°å‚ç…§æ¤œå‡ºæ©Ÿæ§‹ (cycle detector) ãŒæœ‰åŠ¹ã«ã•ã‚Œã¦ã„ã‚‹å ´åˆ (ã“ã‚Œã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¨­å®šã§ã™) ã«ã¯æ¤œå‡ºã•ã‚Œã¾ã™ãŒã€æ¤œå‡ºã•ã‚ŒãŸå¾ªç’°å‚ç…§ã‚’æ¶ˆå»ã™ã‚‹ã®ã¯ Python ãƒ¬ãƒ™ãƒ«ã§ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã ã‘ã§ã™ã€‚ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¾ªç’°å‚ç…§æ¤œå‡ºæ©Ÿæ§‹ã§ã©ã®ã‚ˆã†ã«æ‰±ã‚ã‚Œã‚‹ã‹ã€ã¨ã‚Šã‚ã‘ ``garbage`` å€¤ã®è¨˜è¿°ã«é–¢ã—ã¦ã¯ã€ :mod:`gc` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1280
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  Also, when :meth:`__del__` is"
" invoked in response to a module being deleted (e.g., when execution of the "
"program is done), other globals referenced by the :meth:`__del__` method may"
" already have been deleted or in the process of being torn down (e.g. the "
"import machinery shutting down).  For this reason, :meth:`__del__` methods "
"should do the absolute minimum needed to maintain external invariants.  "
"Starting with version 1.5, Python guarantees that globals whose name begins "
"with a single underscore are deleted from their module before other globals "
"are deleted; if no other references to such globals exist, this may help in "
"assuring that imported modules are still available at the time when the "
":meth:`__del__` method is called."
msgstr ":meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ãŒèµ·ãã‚‹ã®ã¯ä¸å®‰å®šãªçŠ¶æ³ä¸‹ãªã®ã§ã€ :meth:`__del__` ã®å®Ÿè¡Œä¸­ã«ç™ºç”Ÿã—ãŸä¾‹å¤–ã¯ç„¡è¦–ã•ã‚Œã€ä»£ã‚ã‚Šã« ``sys.stderr`` ã«è­¦å‘ŠãŒå‡ºåŠ›ã•ã‚Œã¾ã™ã€‚ã¾ãŸã€ (ä¾‹ãˆã°ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡Œçµ‚äº†ã«ã‚ˆã‚‹) ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å‰Šé™¤ã«ä¼´ã£ã¦ :meth:`__del__` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹éš›ã«ã¯ã€ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‚ç…§ã—ã¦ã„ã‚‹ä»–ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¯ã™ã§ã«å‰Šé™¤ã•ã‚Œã¦ã„ãŸã‚Šã€å‰Šé™¤ä¸­(ä¾‹ãˆã°ã€importæ©Ÿæ§‹ã®ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ä¸­)ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã®ç†ç”±ã‹ã‚‰ã€ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯å¤–éƒ¨ã®ä¸å¤‰é–¢ä¿‚ã‚’ç¶­æŒã™ã‚‹ä¸Šã§çµ¶å¯¾æœ€ä½é™å¿…è¦ãªã“ã¨ã ã‘ã‚’ã™ã¹ãã§ã™ã€‚ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 1.5 ã‹ã‚‰ã¯ã€å˜ä¸€ã®ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã§å§‹ã¾ã‚‹ã‚ˆã†ãªã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¯ã€ä»–ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãŒå‰Šé™¤ã•ã‚Œã‚‹å‰ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰å‰Šé™¤ã•ã‚Œã‚‹ã‚ˆã†ã« Python å´ã§ä¿è¨¼ã—ã¦ã„ã¾ã™; ã“ã‚Œã‚‰ã®ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ä»˜ãã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¯ã€ :meth:`__del__` ãŒå‘¼ã³å‡ºã•ã‚ŒãŸéš›ã«ã€import ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã¾ã æ®‹ã£ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹ä¸Šã§å½¹ã«ç«‹ã¡ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1295
msgid "See also the :option:`-R` command-line option."
msgstr ":option:`-R` ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚‚å‚ç…§ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1302
msgid ""
"Called by the :func:`repr` built-in function and by string conversions "
"(reverse quotes) to compute the \"official\" string representation of an "
"object.  If at all possible, this should look like a valid Python expression"
" that could be used to recreate an object with the same value (given an "
"appropriate environment).  If this is not possible, a string of the form "
"``<...some useful description...>`` should be returned.  The return value "
"must be a string object. If a class defines :meth:`__repr__` but not "
":meth:`__str__`, then :meth:`__repr__` is also used when an \"informal\" "
"string representation of instances of that class is required."
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•° :func:`repr` ã‚„ã€æ–‡å­—åˆ—ã¸ã®å¤‰æ› (é€†ã‚¯ã‚ªãƒ¼ãƒˆè¡¨è¨˜: reverse quote) ã®éš›ã«å‘¼ã³å‡ºã•ã‚Œã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã™ \"å…¬å¼ã® (official)\" æ–‡å­—åˆ—ã‚’è¨ˆç®—ã—ã¾ã™ã€‚å¯èƒ½ãªå ´åˆã«ã¯ã€ã“ã®å€¤ã¯åŒã˜å€¤ã‚’æŒã£ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ (é©åˆ‡ãªç’°å¢ƒã§) å†ç”Ÿæˆã™ã‚‹ãŸã‚ã«ä½¿ãˆã‚‹ã‚ˆã†ãªæœ‰åŠ¹ãª Python å¼ã«ä¼¼ã›ã‚‹ã¹ãã§ã™ã€‚ãã‚ŒãŒä¸å¯èƒ½ãªã‚‰ã€ ``<...some useful description...>`` å½¢å¼ã®æ–‡å­—åˆ—ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚æˆ»ã‚Šå€¤ã¯æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¹ãŒ :meth:`__repr__` ã‚’å®šç¾©ã—ã¦ã„ã‚‹ãŒ :meth:`__str__` ã‚’å®šç¾©ã—ã¦ã„ãªã„å ´åˆã€ãã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã™ã‚‹ \"éå…¬å¼ã® (informal)\" æ–‡å­—åˆ—è¡¨ç¾ãŒå¿…è¦ãªã¨ãã«ã‚‚ :meth:`__repr__` ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1318
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr "ã“ã®é–¢æ•°ã¯ãƒ‡ãƒãƒƒã‚°ã®éš›ã«ã‚ˆãç”¨ã„ã‚‰ã‚Œã‚‹ã®ã§ã€ãŸãã•ã‚“ã®æƒ…å ±ã‚’å«ã¿ã€ã‚ã„ã¾ã„ã§ãªã„ã‚ˆã†ãªè¡¨è¨˜ã«ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1328
msgid ""
"Called by the :func:`str` built-in function and by the :keyword:`print` "
"statement to compute the \"informal\" string representation of an object.  "
"This differs from :meth:`__repr__` in that it does not have to be a valid "
"Python expression: a more convenient or concise representation may be used "
"instead. The return value must be a string object."
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•° :func:`str` ãŠã‚ˆã³ :keyword:`print` æ–‡ã«ã‚ˆã£ã¦å‘¼ã³å‡ºã•ã‚Œã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã™ \"éå…¬å¼ã®\" æ–‡å­—åˆ—ã‚’è¨ˆç®—ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æœ‰åŠ¹ãª Python å¼ã‚’è¿”ã•ãªãã¦ã‚‚è‰¯ã„ã¨ã„ã†ç‚¹ã§ã€ :meth:`__repr__` ã¨ç•°ãªã‚Šã¾ã™: ãã®ä»£ã‚ã‚Šã€ã‚ˆã‚Šä¾¿åˆ©ã§åˆ†ã‹ã‚Šã‚„ã™ã„è¡¨ç¾ã‚’è¿”ã™ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚æˆ»ã‚Šå€¤ã¯æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1347
msgid ""
"These are the so-called \"rich comparison\" methods, and are called for "
"comparison operators in preference to :meth:`__cmp__` below. The "
"correspondence between operator symbols and method names is as follows: "
"``x<y`` calls ``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` "
"calls ``x.__eq__(y)``, ``x!=y`` and ``x<>y`` call ``x.__ne__(y)``, ``x>y`` "
"calls ``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr "ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ \"æ‹¡å¼µæ¯”è¼ƒ (rich comparison)\" ãƒ¡ã‚½ãƒƒãƒ‰ã¨å‘¼ã°ã‚Œã€ä¸‹è¨˜ã® :meth:`__cmp__` ã«å„ªå…ˆã—ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚æ¼”ç®—å­ã‚·ãƒ³ãƒœãƒ«ã¨ãƒ¡ã‚½ãƒƒãƒ‰åã®å¯¾å¿œã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™: ``x<y`` ã¯ ``x.__lt__(y)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™; ``x<=y`` ã¯ ``x.__le__(y)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™; ``x==y`` ã¯ ``x.__eq__(y)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™; ``x!=y`` ãŠã‚ˆã³ ``x<>y`` ã¯ ``x.__ne__(y)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™; ``x>y`` ã¯ ``x.__gt__(y)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™; ``x>=y`` ã¯ ``x.__ge__(y)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1354
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if it "
"does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison."
" However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr "æ‹¡å¼µæ¯”è¼ƒãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸå¼•æ•°ã®ãƒšã‚¢ã«å¯¾ã™ã‚‹æ“ä½œã‚’å®Ÿè£…ã—ã¦ã„ãªã„ã¨ãã«ã€ ``NotImplemented`` ã¨ã„ã†ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚’è¿”ã™ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚æ…£ä¾‹ã¨ã—ã¦ã€æ­£å¸¸ã«æ¯”è¼ƒãŒè¡Œã‚ã‚ŒãŸã¨ãã«ã¯ ``False`` ã‹ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ã—ã‹ã—ã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä»»æ„ã®å€¤ã‚’è¿”ã™ã“ã¨ãŒã§ãã‚‹ã®ã§ã€æ¯”è¼ƒæ¼”ç®—å­ãŒãƒ–ãƒ¼ãƒ«å€¤ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ(ãŸã¨ãˆã°ã€ ``if`` æ–‡ã®æ¡ä»¶éƒ¨åˆ†)ã§ä½¿ã‚ã‚ŒãŸå ´åˆã€ Python ã¯ãã®å€¤ã«å¯¾ã—ã¦ :func:`bool` ã‚’å‘¼ã³å‡ºã—ã¦çµæœã®çœŸå½ã‚’åˆ¤æ–­ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1361
msgid ""
"There are no implied relationships among the comparison operators. The truth"
" of ``x==y`` does not imply that ``x!=y`` is false.  Accordingly, when "
"defining :meth:`__eq__`, one should also define :meth:`__ne__` so that the "
"operators will behave as expected.  See the paragraph on :meth:`__hash__` "
"for some important notes on creating :term:`hashable` objects which support "
"custom comparison operations and are usable as dictionary keys."
msgstr "æ¯”è¼ƒæ¼”ç®—å­é–“ã«ã¯ã€æš—é»™çš„ãªè«–ç†é–¢ä¿‚ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã™ãªã‚ã¡ã€ ``x==y`` ãŒçœŸã§ã‚ã‚‹å ´åˆã€æš—é»™ã®ã†ã¡ã« ``x!=y`` ãŒå½ã«ãªã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å¾“ã£ã¦ã€ :meth:`__eq__` ã‚’å®Ÿè£…ã™ã‚‹éš›ã€æ¼”ç®—å­ãŒæœŸå¾…é€šã‚Šã«å‹•ä½œã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã« :meth:`__ne__` ã‚‚å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã‚«ã‚¹ã‚¿ãƒ ã®æ¯”è¼ƒæ¼”ç®—ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¦ã€è¾æ›¸ã®ã‚­ãƒ¼ã«ä½¿ã†ã“ã¨ãŒã§ãã‚‹ãƒãƒƒã‚·ãƒ¥å¯èƒ½(:term:`hashable`) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚‹ã¨ãã®é‡è¦ãªæ³¨æ„ç‚¹ã«ã¤ã„ã¦ã€ :meth:`__hash__` ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå†…ã«æ›¸ã‹ã‚Œã¦ã„ã‚‹ã®ã§å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1368
msgid ""
"There are no swapped-argument versions of these methods (to be used when the"
" left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, "
":meth:`__le__` and :meth:`__ge__` are each other's reflection, and "
":meth:`__eq__` and :meth:`__ne__` are their own reflection."
msgstr "ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯ã€(å·¦å¼•æ•°ãŒæ¼”ç®—ã‚’ã‚µãƒãƒ¼ãƒˆã—ãªã„ãŒã€å³å¼•æ•°ã¯ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã«ç”¨ã„ã‚‰ã‚Œã‚‹ã‚ˆã†ãª) é¡åƒã¨ãªã‚‹ (å¼•æ•°ã‚’å…¥ã‚Œæ›¿ãˆãŸ) ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯å­˜åœ¨ã—ã¾ã›ã‚“; ã‚€ã—ã‚ã€ :meth:`__lt__` ã¨ :meth:`__gt__` ã¯äº’ã„ã«é¡åƒã§ã‚ã‚Šã€ :meth:`__le__` ã¨ :meth:`__ge__` ã€ãŠã‚ˆã³ :meth:`__eq__` ã¨ :meth:`__ne__` ã¯ãã‚Œãã‚Œäº’ã„ã«é¡åƒã§ã™ã€‚"

#: ../../reference/datamodel.rst:1374
msgid "Arguments to rich comparison methods are never coerced."
msgstr "æ‹¡å¼µæ¯”è¼ƒãƒ¡ã‚½ãƒƒãƒ‰ã®å¼•æ•°ã«ã¯å‹å¼·åˆ¶ (coerce) ãŒèµ·ã“ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1376
msgid ""
"To automatically generate ordering operations from a single root operation, "
"see :func:`functools.total_ordering`."
msgstr "å˜ä¸€ã®åŸºæœ¬æ¼”ç®—ã‹ã‚‰é †åºä»˜ã‘ã™ã‚‹ãŸã‚ã®æ¼”ç®—ã‚’è‡ªå‹•çš„ã«ç”Ÿæˆã—ãŸã„å ´åˆã«ã¯ã€ :func:`functools.total_ordering` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1385
msgid ""
"Called by comparison operations if rich comparison (see above) is not "
"defined.  Should return a negative integer if ``self < other``, zero if "
"``self == other``, a positive integer if ``self > other``.  If no "
":meth:`__cmp__`, :meth:`__eq__` or :meth:`__ne__` operation is defined, "
"class instances are compared by object identity (\"address\").  See also the"
" description of :meth:`__hash__` for some important notes on creating "
":term:`hashable` objects which support custom comparison operations and are "
"usable as dictionary keys. (Note: the restriction that exceptions are not "
"propagated by :meth:`__cmp__` has been removed since Python 1.5.)"
msgstr "æ‹¡å¼µæ¯”è¼ƒ (ä¸Šå‚ç…§) ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€æ¯”è¼ƒæ¼”ç®—ã«ã‚ˆã£ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ ``self < other`` ã§ã‚ã‚‹å ´åˆã«ã¯è² ã®å€¤ã€ ``self == other`` ãªã‚‰ã°ã‚¼ãƒ­ã€ ``self > other`` ã§ã‚ã‚Œã°æ­£ã®å€¤ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æ¼”ç®— :meth:`__cmp__` ã€ :meth:`__eq__` ãŠã‚ˆã³ :meth:`__ne__` ãŒã„ãšã‚Œã‚‚å®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£(\"ã‚¢ãƒ‰ãƒ¬ã‚¹\") ã§æ¯”è¼ƒã•ã‚Œã¾ã™ã€‚è‡ªä½œã®æ¯”è¼ƒæ¼”ç®—ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„ã€è¾æ›¸ã®ã‚­ãƒ¼ã¨ã—ã¦ä½¿ãˆã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹ã«ã¯ã€ :meth:`__hash__` ã«é–¢ã™ã‚‹è¨˜è¿°ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ (æ³¨æ„: :meth:`__cmp__` ãŒä¾‹å¤–ã‚’ä¼æ’­ã—ãªã„ã¨ã„ã†åˆ¶é™ã¯ Python 1.5 ã‹ã‚‰é™¤å»ã•ã‚Œã¾ã—ãŸã€‚)"

#: ../../reference/datamodel.rst:1398
msgid "No longer supported."
msgstr "ã‚‚ã¯ã‚„ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“."

#: ../../reference/datamodel.rst:1408
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and "
":class:`dict`.  :meth:`__hash__` should return an integer.  The only "
"required property is that objects which compare equal have the same hash "
"value; it is advised to mix together the hash values of the components of "
"the object that also play a part in comparison of objects by packing them "
"into a tuple and hashing the tuple. Example::"
msgstr "çµ„ã¿è¾¼ã¿ã® :func:`hash` é–¢æ•°ã‚„ã€ :class:`set`, :class:`frozenset`, :class:`dict` ã®ã‚ˆã†ãªãƒãƒƒã‚·ãƒ¥ã‚’ä½¿ã£ãŸã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹ã®è¦ç´ ã«å¯¾ã™ã‚‹æ“ä½œã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n:meth:`__hash__` ã¯æ•´æ•°ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\nã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«å¿…è¦ãªæ€§è³ªã¯ã€æ¯”è¼ƒçµæœãŒç­‰ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯åŒã˜ãƒãƒƒã‚·ãƒ¥å€¤ã‚’æŒã¤ã¨ã„ã†ã“ã¨ã§ã™;\nã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¯”è¼ƒã™ã‚‹ã¨ãã§ã‚‚åˆ©ç”¨ã•ã‚Œã‚‹è¦ç´ ã‚’ã‚¿ãƒ—ãƒ«ã«è©°ã‚ã¦ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ã§ã€ãã‚Œãã‚Œã®è¦ç´ ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’æ··åˆã™ã‚‹ã“ã¨ã‚’ãŠã™ã™ã‚ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1419
msgid ""
"If a class does not define a :meth:`__cmp__` or :meth:`__eq__` method it "
"should not define a :meth:`__hash__` operation either; if it defines "
":meth:`__cmp__` or :meth:`__eq__` but not :meth:`__hash__`, its instances "
"will not be usable in hashed collections.  If a class defines mutable "
"objects and implements a :meth:`__cmp__` or :meth:`__eq__` method, it should"
" not implement :meth:`__hash__`, since hashable collection implementations "
"require that an object's hash value is immutable (if the object's hash value"
" changes, it will be in the wrong hash bucket)."
msgstr "ã‚¯ãƒ©ã‚¹ãŒ :meth:`__cmp__` ã‚„ :meth:`__eq__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ãªã„å ´åˆã€ :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚å®šç¾©ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“; ã‚¯ãƒ©ã‚¹ãŒ :meth:`__cmp__` ã¾ãŸã¯ :meth:`__eq__` ã‚’å®šç¾©ã—ã¦ã„ã‚‹ãŒã€ :meth:`__hash__` ã‚’å®šç¾©ã—ã¦ã„ãªã„å ´åˆã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¾æ›¸ã®ã‚­ãƒ¼ã¨ã—ã¦ä½¿ã†ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¹ãŒå¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®šç¾©ã—ã¦ãŠã‚Šã€ :meth:`__cmp__` ã¾ãŸã¯ :meth:`__eq__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹å ´åˆã€ :meth:`__hash__` ã‚’å®šç¾©ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€è¾æ›¸ã®å®Ÿè£…ã«ãŠã„ã¦ãƒãƒƒã‚·ãƒ¥å€¤ãŒå¤‰æ›´ä¸èƒ½ã§ã‚ã‚‹ã“ã¨ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã§ã™ (ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒƒã‚·ãƒ¥å€¤ãŒå¤‰åŒ–ã™ã‚‹ã¨ã€ã‚­ãƒ¼ãŒèª¤ã£ãŸãƒãƒƒã‚·ãƒ¥ãƒã‚±ãƒ„ (hash bucket) ã«å…¥ã£ã¦ã„ã‚‹ã“ã¨ã«ãªã£ã¦ã—ã¾ã„ã¾ã™)ã€‚"

#: ../../reference/datamodel.rst:1428
msgid ""
"User-defined classes have :meth:`__cmp__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) and"
" ``x.__hash__()`` returns a result derived from ``id(x)``."
msgstr "ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ã‚¯ãƒ©ã‚¹ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ :meth:`__cmp__` ã¨ :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã¯ã€åŒä¸€ä»¥å¤–ã®ã™ã¹ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦æ¯”è¼ƒçµæœãŒå½ã«ãªã‚Šã€ ``x.__hash__()`` ã¯ ``id(x)`` ã‹ã‚‰å¾—ã‚‰ã‚Œã‚‹çµæœã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1432
msgid ""
"Classes which inherit a :meth:`__hash__` method from a parent class but "
"change the meaning of :meth:`__cmp__` or :meth:`__eq__` such that the hash "
"value returned is no longer appropriate (e.g. by switching to a value-based "
"concept of equality instead of the default identity based equality) can "
"explicitly flag themselves as being unhashable by setting ``__hash__ = "
"None`` in the class definition. Doing so means that not only will instances "
"of the class raise an appropriate :exc:`TypeError` when a program attempts "
"to retrieve their hash value, but they will also be correctly identified as "
"unhashable when checking ``isinstance(obj, collections.Hashable)`` (unlike "
"classes which define their own :meth:`__hash__` to explicitly raise "
":exc:`TypeError`)."
msgstr "è¦ªã‚¯ãƒ©ã‚¹ã‹ã‚‰ :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç¶™æ‰¿ã—ã¦ã€ :meth:`__cmp__` ã‹ :meth:`__eq__` ã®æ„å‘³ã‚’å¤‰æ›´ã—ã¦ã„ã‚‹(ä¾‹ãˆã°ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®åŒä¸€æ€§ãƒ™ãƒ¼ã‚¹ã®åŒå€¤é–¢ä¿‚ã‹ã‚‰å€¤ãƒ™ãƒ¼ã‚¹ã®åŒå€¤é–¢ä¿‚ã«å¤‰æ›´ã™ã‚‹) ã‚¯ãƒ©ã‚¹ã®ãƒãƒƒã‚·ãƒ¥å€¤ã¯å¦¥å½“ã§ã¯ãªããªã‚‹ã®ã§ã€ ``__hash__ = None`` ã‚’ã‚¯ãƒ©ã‚¹å®šç¾©ã«æ›¸ãäº‹ã§ã€æ˜ç¤ºçš„ã«ãƒãƒƒã‚·ãƒ¥ä¸å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’å®£è¨€ã§ãã¾ã™ã€‚ã“ã†ã™ã‚‹ã¨ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒãã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’å–å¾—ã—ã‚ˆã†ã¨ã—ãŸã¨ãã«é©åˆ‡ãª :exc:`TypeError` ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ã‚ˆã†ã«ãªã‚‹ã ã‘ã§ãªãã€ (:exc:`TypeError` ã‚’ç™ºç”Ÿã•ã›ã‚‹ :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚¯ãƒ©ã‚¹ã¨é•ã£ã¦) ``isinstance(obj, collections.Hashable)`` ã‚’ãƒã‚§ãƒƒã‚¯ã—ãŸã¨ãã«ã€ãƒãƒƒã‚·ãƒ¥ä¸å¯èƒ½ã¨åˆ¤å®šã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1444
msgid ""
":meth:`__hash__` may now also return a long integer object; the 32-bit "
"integer is then derived from the hash of that object."
msgstr ":meth:`__hash__` ã¯ç¾åœ¨ã§ã¯é•·æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚è¿”ã›ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ 32ãƒ“ãƒƒãƒˆæ•´æ•°ã¯ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒƒã‚·ãƒ¥ã‹ã‚‰å°å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1448
msgid ""
":attr:`__hash__` may now be set to :const:`None` to explicitly flag "
"instances of a class as unhashable."
msgstr "ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒãƒãƒƒã‚·ãƒ¥ä¸å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’æ˜ç¤ºçš„ã«å®£è¨€ã™ã‚‹ãŸã‚ã«ã€ :attr:`__hash__` ã« :const:`None` ã‚’è¨­å®šã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../reference/datamodel.rst:1457
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``, or their integer "
"equivalents ``0`` or ``1``.  When this method is not defined, "
":meth:`__len__` is called, if it is defined, and the object is considered "
"true if its result is nonzero. If a class defines neither :meth:`__len__` "
"nor :meth:`__nonzero__`, all its instances are considered true."
msgstr "çœŸå€¤ãƒ†ã‚¹ãƒˆã‚„çµ„ã¿è¾¼ã¿æ¼”ç®— ``bool()`` ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™; ``False`` ã¾ãŸã¯ ``True`` ã‹ã€ç­‰ä¾¡ãªæ•´æ•°å€¤ ``0`` ã¾ãŸã¯ ``1`` ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ :meth:`__len__` ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚Œã°å‘¼ã³å‡ºã•ã‚Œã€ãã®çµæœãŒ nonzero ã§ã‚ã‚Œã°çœŸã«ãªã‚Šã¾ã™ã€‚ :meth:`__len__` ã¨ :meth:`__nonzero__` ã®ã©ã¡ã‚‰ã‚‚ã‚¯ãƒ©ã‚¹ã§å®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ãã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã™ã¹ã¦çœŸã®å€¤ã‚’æŒã¤ã‚‚ã®ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1469
msgid ""
"Called to implement :func:`unicode` built-in; should return a Unicode "
"object. When this method is not defined, string conversion is attempted, and"
" the result of string conversion is converted to Unicode using the system "
"default encoding."
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•° :func:`unicode` ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€æ–‡å­—åˆ—ã¸ã®å¤‰æ›ãŒè©¦ã¿ã‚‰ã‚Œã€ãã®çµæœãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ–‡å­—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’ç”¨ã„ã¦ Unicode ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1477
msgid "Customizing attribute access"
msgstr "å±æ€§å€¤ã‚¢ã‚¯ã‚»ã‚¹ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹"

#: ../../reference/datamodel.rst:1479
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr "ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ã®å±æ€§å€¤ã‚¢ã‚¯ã‚»ã‚¹ ( å±æ€§å€¤ã®ä½¿ç”¨ã€å±æ€§å€¤ã¸ã®ä»£å…¥ã€ ``x.name`` ã®å‰Šé™¤) ã®æ„å‘³ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1485
msgid ""
"Called when an attribute lookup has not found the attribute in the usual "
"places (i.e. it is not an instance attribute nor is it found in the class "
"tree for ``self``).  ``name`` is the attribute name. This method should "
"return the (computed) attribute value or raise an :exc:`AttributeError` "
"exception."
msgstr "å±æ€§å€¤ã®æ¤œç´¢ã‚’è¡Œã£ãŸçµæœã€é€šå¸¸ã®å ´æ‰€ã«å±æ€§å€¤ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ (ã™ãªã‚ã¡ã€ ``self`` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã§ãªãã€ã‹ã¤ã‚¯ãƒ©ã‚¹ãƒ„ãƒªãƒ¼ã«ã‚‚è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ) ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚``name`` ã¯å±æ€§åã§ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ (è¨ˆç®—ã•ã‚ŒãŸ) å±æ€§å€¤ã‚’è¿”ã™ã‹ã€ :exc:`AttributeError` ä¾‹å¤–ã‚’é€å‡ºã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1492
msgid ""
"Note that if the attribute is found through the normal mechanism, "
":meth:`__getattr__` is not called.  (This is an intentional asymmetry "
"between :meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can fake total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control in new-style classes."
msgstr "é€šå¸¸ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’ä»‹ã—ã¦å±æ€§å€¤ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã€ :meth:`__getattr__` ã¯å‘¼ã³å‡ºã•ã‚Œãªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚(ã“ã‚Œã¯ã€ :meth:`__getattr__` ã¨ :meth:`__setattr__` ã®é–“ã«æ„å›³çš„ã«å°å…¥ã•ã‚ŒãŸéå¯¾ç§°æ€§ã§ã™ã€‚) ã“ã‚Œã¯ã€åŠ¹ç‡æ€§ã®ãŸã‚ã¨ã€ã“ã†ã—ãªã‘ã‚Œã° :meth:`__getattr__` ãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä»–ã®å±æ€§å€¤ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ–¹æ³•ãŒãªããªã‚‹ãŸã‚ã§ã™ã€‚å°‘ãªãã¨ã‚‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã«å¯¾ã—ã¦ã¯ã€å€¤ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§å€¤è¾æ›¸ã«æŒ¿å…¥ã—ãªã„ã‚ˆã†ã«ã—ã¦ (ä»£ã‚ã‚Šã«ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æŒ¿å…¥ã™ã‚‹ã“ã¨ã§) å±æ€§å€¤ãŒå®Œå…¨ã«åˆ¶å¾¡ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«è¦‹ã›ã‹ã‘ã‚‰ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã§å®Ÿéš›ã«å®Œå…¨ãªåˆ¶å¾¡ã‚’è¡Œã†æ–¹æ³•ã¯ã€ä»¥ä¸‹ã® :meth:`__getattribute__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1505
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of"
" the normal mechanism (i.e. store the value in the instance dictionary).  "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr "å±æ€§å€¤ã¸ã®ä»£å…¥ãŒè©¦ã¿ã‚‰ã‚ŒãŸéš›ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯é€šå¸¸ã®ä»£å…¥ãƒ¡ã‚«ãƒ‹ã‚ºãƒ  (ã™ãªã‚ã¡ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è¾æ›¸ã¸ã®å€¤ã®ä»£å…¥) ã®ä»£ã‚ã‚Šã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ *name* ã¯å±æ€§åã§ã€ *value* ã¯ãã®å±æ€§ã«ä»£å…¥ã™ã‚‹å€¤ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1511
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"not simply execute ``self.name = value`` --- this would cause a recursive "
"call to itself.  Instead, it should insert the value in the dictionary of "
"instance attributes, e.g., ``self.__dict__[name] = value``.  For new-style "
"classes, rather than accessing the instance dictionary, it should call the "
"base class method with the same name, for example, "
"``object.__setattr__(self, name, value)``."
msgstr ":meth:`__setattr__` ã®ä¸­ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§å€¤ã¸ã®ä»£å…¥ãŒå¿…è¦ãªå ´åˆã€å˜ã« ``self.name = value`` ã¨ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ --- ã“ã®ã‚ˆã†ã«ã™ã‚‹ã¨ã€è‡ªåˆ†è‡ªèº«ã«å¯¾ã™ã‚‹å†å¸°å‘¼ã³å‡ºã—ãŒãŠãã¦ã—ã¾ã„ã¾ã™ã€‚ãã®ä»£ã‚ã‚Šã«ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã®è¾æ›¸ã«å€¤ã‚’æŒ¿å…¥ã—ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°ã€ ``self.__dict__[name] = value`` ã¨ã—ã¾ã™ã€‚æ–°ã—ã„å½¢å¼ã®ã‚¯ãƒ©ã‚¹ã§ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è¾æ›¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ã§ã¯ãªãã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’åŒã˜å±æ€§åã§å‘¼ã³å‡ºã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``object.__setattr__(self, name, value)`` ã¨ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1522
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ":meth:`__setattr__` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ä»£å…¥ã§ã¯ãªãå€¤ã®å‰Šé™¤ã‚’è¡Œã„ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ã®ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¨ã£ã¦ ``del obj.name`` ãŒæ„å‘³ãŒã‚ã‚‹å ´åˆã ã‘ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1529
msgid "More attribute access for new-style classes"
msgstr "æ–°ã—ã„å½¢å¼ã®ã‚¯ãƒ©ã‚¹ã®ãŸã‚ã®åˆ¥ã®å±æ€§ã‚¢ã‚¯ã‚»ã‚¹"

#: ../../reference/datamodel.rst:1531
msgid "The following methods only apply to new-style classes."
msgstr "ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ–°ã—ã„å½¢å¼ã®ã‚¯ãƒ©ã‚¹ (new-style class) ã®ã¿ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1536
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be"
" called unless :meth:`__getattribute__` either calls it explicitly or raises"
" an :exc:`AttributeError`. This method should return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception. In order to "
"avoid infinite recursion in this method, its implementation should always "
"call the base class method with the same name to access any attributes it "
"needs, for example, ``object.__getattribute__(self, name)``."
msgstr "ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã™ã‚‹å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€ç„¡æ¡ä»¶ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ãŒ :meth:`__getattr__` ã‚‚å®šç¾©ã—ã¦ã„ã‚‹å ´åˆã€ :meth:`__getattr__` ã¯ã€ :meth:`__getattribute__` ã§æ˜ç¤ºçš„ã«å‘¼ã³å‡ºã™ã‹ã€ :exc:`AttributeError` ä¾‹å¤–ã‚’é€å‡ºã—ãªã„é™ã‚Šå‘¼ã°ã‚Œã¾ã›ã‚“ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ (è¨ˆç®—ã•ã‚ŒãŸ) å±æ€§å€¤ã‚’è¿”ã™ã‹ã€ :exc:`AttributeError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå†å¸°çš„ã«éš›é™ãªãå‘¼ã³å‡ºã•ã‚Œã¦ã—ã¾ã†ã®ã‚’é˜²ããŸã‚ã€å®Ÿè£…ã®éš›ã«ã¯å¸¸ã«ã€å¿…è¦ãªå±æ€§å…¨ã¦ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã§ã€ä¾‹ãˆã° ``object.__getattribute__(self, name)`` ã®ã‚ˆã†ã«åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’åŒã˜å±æ€§åã‚’ä½¿ã£ã¦å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1547
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. See"
" :ref:`new-style-special-lookup`."
msgstr "ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•°ã‚„è¨€èªæ§‹æ–‡ã«ã‚ˆã‚Šæš—é»™çš„ã«ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ãŒæ¤œç´¢ã•ã‚Œã‚‹ã¨ãã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ã¯ãƒã‚¤ãƒ‘ã‚¹ã•ã‚Œã‚‹ã§ã—ã‚‡ã†ã€‚ :ref:`new-style-special-lookup` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1555
msgid "Implementing Descriptors"
msgstr "ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ (descriptor) ã®å®Ÿè£…"

#: ../../reference/datamodel.rst:1557
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the"
" descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property in"
" the owner class' :attr:`~object.__dict__`."
msgstr "ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚¯ãƒ©ã‚¹ (ã„ã‚ã‚†ã‚‹ *ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿(descriptor)* ã‚¯ãƒ©ã‚¹) ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã€ *ã‚ªãƒ¼ãƒŠãƒ¼ (owner)* ã‚¯ãƒ©ã‚¹ã«å­˜åœ¨ã™ã‚‹ã¨ãã«ã®ã¿é©ç”¨ã•ã‚Œã¾ã™ (ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€ã‚ªãƒ¼ãƒŠãƒ¼ã®ã‚¯ãƒ©ã‚¹è¾æ›¸ã‹ã€ãã®è¦ªã®ã„ãšã‚Œã‹ã®ã‚¯ãƒ©ã‚¹è¾æ›¸ã«ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“)ã€‚\nä»¥ä¸‹ã®ä¾‹ã§ã¯ã€\"å±æ€§\" ã¨ã¯ã€åå‰ãŒã‚ªãƒ¼ãƒŠãƒ¼ã‚¯ãƒ©ã‚¹ã® :attr:`~object.__dict__` ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ (porperty) ã®ã‚­ãƒ¼ã§ã‚ã‚‹ã‚ˆã†ãªå±æ€§ã‚’æŒ‡ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1567
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). *owner* is always "
"the owner class, while *instance* is the instance that the attribute was "
"accessed through, or ``None`` when the attribute is accessed through the "
"*owner*.  This method should return the (computed) attribute value or raise "
"an :exc:`AttributeError` exception."
msgstr "ã‚ªãƒ¼ãƒŠã‚¯ãƒ©ã‚¹ã®å±æ€§ã‚’å–å¾—ã™ã‚‹ (ã‚¯ãƒ©ã‚¹å±æ€§ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹) éš›ã‚„ã€ã‚ªãƒ¼ãƒŠã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ã‚’å–å¾—ã™ã‚‹ (ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹) å ´åˆã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ *owner* ã¯å¸¸ã«ã‚ªãƒ¼ãƒŠã‚¯ãƒ©ã‚¹ã§ã™ã€‚ä¸€æ–¹ã€ *instance* ã¯å±æ€§ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ä»²ä»‹ã™ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹å±æ€§ãŒ *owner* ã‚’ä»‹ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ (è¨ˆç®—ã•ã‚ŒãŸ) å±æ€§å€¤ã‚’è¿”ã™ã‹ã€ :exc:`AttributeError` ä¾‹å¤–ã‚’é€å‡ºã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1577
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr "ã‚ªãƒ¼ãƒŠã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ *instance* ä¸Šã®å±æ€§ã‚’æ–°ãŸãªå€¤ *value* ã«è¨­å®šã™ã‚‹éš›ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1583
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr "ã‚ªãƒ¼ãƒŠã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ *instance* ä¸Šã®å±æ€§ã‚’å‰Šé™¤ã™ã‚‹éš›ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1589
msgid "Invoking Descriptors"
msgstr "ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å‘¼ã³å‡ºã—"

#: ../../reference/datamodel.rst:1591
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`__get__`, :meth:`__set__`, and :meth:`__delete__`. If any "
"of those methods are defined for an object, it is said to be a descriptor."
msgstr "ä¸€èˆ¬ã«ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨ã¯ã€ç‰¹æ®Šãª \"æŸç¸›ã«é–¢ã™ã‚‹å‹•ä½œ (binding behaviour)\" ã‚’ã‚‚ã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå±æ€§ã®ã“ã¨ã§ã™ã€‚ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ« (descriptor protocol) ã®ãƒ¡ã‚½ãƒƒãƒ‰: :meth:`__get__`, :meth:`__set__`, ãŠã‚ˆã³ :meth:`__delete__` ã‚’ä½¿ã£ã¦ã€å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã‚’ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã—ã¦ã„ã‚‹ã‚‚ã®ã§ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ã„ãšã‚Œã‹ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã§ã‚ã‚‹ã¨ã„ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1596
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and"
" continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr "å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¾æ›¸ã‹ã‚‰å€¤ã‚’å–ã‚Šå‡ºã—ãŸã‚Šã€å€¤ã‚’è¨­å®šã—ãŸã‚Šã€å‰Šé™¤ã—ãŸã‚Šã™ã‚‹ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚ä¾‹ãˆã°ã€ ``a.x`` ã«ã‚ˆã‚‹å±æ€§ã®æ¤œç´¢ã§ã¯ã€ã¾ãš ``a.__dict__['x']`` ã€æ¬¡ã« ``type(a).__dict__['x']`` ã€ãã—ã¦ ``type(a)`` ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã§ãªã„ã‚‚ã®ã«ç¶šãã€ã¨ã„ã£ãŸå…·åˆã«é€£é–ãŒèµ·ã“ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1601
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called.  "
"Note that descriptors are only invoked for new style objects or classes "
"(ones that subclass :class:`object()` or :class:`type()`)."
msgstr "ã—ã‹ã—ãªãŒã‚‰ã€æ¤œç´¢å¯¾è±¡ã¨ãªã‚‹å€¤ãŒã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ã®ã„ãšã‚Œã‹ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§å€¤ã§ã‚ã‚‹å ´åˆã€Python ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œã‚’ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã—ã¦ã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ã®æ–¹ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚å‰å¾Œã™ã‚‹å‘¼ã³å‡ºã—é€£é–ã®ä¸­ã®ã©ã“ã§ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã‹ã¯ã€ã©ã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹ã¨ã€ã©ã†ã‚„ã£ã¦ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã‚‹ã‹ã«ä¾å­˜ã—ã¾ã™ã€‚ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯æ–°ã—ã„å½¢å¼ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„ã‚¯ãƒ©ã‚¹ (:class:`object()` ã‚„ :class:`type()` ã‚’ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã—ãŸã‚‚ã®) ã ã‘ã«å¯¾ã—ã¦å‘¼ã³å‡ºã•ã‚Œã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1608
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr "ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿å‘¼ã³å‡ºã—ã®åŸºç‚¹ã¨ãªã‚‹ã®ã¯ã€å±æ€§åã¸ã®æŸç¸› (binding) ã€ã™ãªã‚ã¡ ``a.x`` ã§ã™ã€‚å¼•æ•°ãŒã©ã®ã‚ˆã†ã«ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã«çµåˆã•ã‚Œã‚‹ã‹ã¯ ``a`` ã«ä¾å­˜ã—ã¾ã™:"

#: ../../reference/datamodel.rst:1613
msgid "Direct Call"
msgstr "ç›´æ¥å‘¼ã³å‡ºã— (Direct Call)"

#: ../../reference/datamodel.rst:1612
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr "æœ€ã‚‚å˜ç´”ã§ã€ã‹ã¤ã‚ã£ãŸã«ä½¿ã‚ã‚Œãªã„å‘¼ã³å‡ºã—æ“ä½œã¯ã€ã‚³ãƒ¼ãƒ‰ä¸­ã§ç›´æ¥ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—: ``x.__get__(a)`` ã‚’è¡Œã†ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1617
msgid "Instance Binding"
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æŸç¸› (Instance Binding)"

#: ../../reference/datamodel.rst:1616
msgid ""
"If binding to a new-style object instance, ``a.x`` is transformed into the "
"call: ``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr "æ–°ã—ã„å½¢å¼ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã™ã‚‹æŸç¸›ã§ã¯ã€ ``a.x`` ã¯å‘¼ã³å‡ºã—: ``type(a).__dict__['x'].__get__(a, type(a))`` ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1621
msgid "Class Binding"
msgstr "ã‚¯ãƒ©ã‚¹æŸç¸› (Class Binding)"

#: ../../reference/datamodel.rst:1620
msgid ""
"If binding to a new-style class, ``A.x`` is transformed into the call: "
"``A.__dict__['x'].__get__(None, A)``."
msgstr "æ–°ã—ã„å½¢å¼ã®ã‚¯ãƒ©ã‚¹ã«å¯¾ã™ã‚‹æŸç¸›ã§ã¯ã€ ``A.x`` ã¯å‘¼ã³å‡ºã—: ``A.__dict__['x'].__get__(None, A)`` ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1627
msgid "Super Binding"
msgstr "super æŸç¸› (Super Binding)"

#: ../../reference/datamodel.rst:1624
msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, "
"obj).m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately preceding ``B`` and then invokes the descriptor with the call: "
"``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr "``a`` ãŒ :class:`super` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹å ´åˆã€æŸç¸› ``super(B, obj).m()`` ã‚’è¡Œã†ã¨ã¾ãš ``A`` ã€ç¶šã„ã¦ ``B`` ã«å¯¾ã—ã¦ ``obj.__class_.__mro__`` ã‚’æ¤œç´¢ã—ã€æ¬¡ã«å‘¼ã³å‡ºã—: ``A.__dict__['m'].__get__(obj, obj.__class__)`` ã§ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1629
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"the which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  If "
"it does not define :meth:`__get__`, then accessing the attribute will return"
" the descriptor object itself unless there is a value in the object's "
"instance dictionary.  If the descriptor defines :meth:`__set__` and/or "
":meth:`__delete__`, it is a data descriptor; if it defines neither, it is a "
"non-data descriptor.  Normally, data descriptors define both :meth:`__get__`"
" and :meth:`__set__`, while non-data descriptors have just the "
":meth:`__get__` method.  Data descriptors with :meth:`__set__` and "
":meth:`__get__` defined always override a redefinition in an instance "
"dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æŸç¸›ã§ã¯ã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿å‘¼ã³å‡ºã—ã®å„ªå…ˆé †ä½ã¯ã©ã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹ã«ä¾å­˜ã—ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€ :meth:`__get__` ã¨ :meth:`__set__` ã€ :meth:`__delete__` ã®ä»»æ„ã®çµ„åˆã›ã‚’å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ :meth:`__get__` ãŒå®šç¾©ã•ã‚Œãªã„å ´åˆã«ã¯ã€ãã®å±æ€§ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è¾æ›¸ã«ãã®å€¤ãŒã‚ã‚‹å ´åˆã‚’é™¤ã‘ã°ã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªèº«ãŒè¿”ã£ã¦ãã¾ã™ã€‚ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãŒ :meth:`__set__` ã¨ :meth:`__delete__` ã¾ãŸã¯ãã®ã©ã¡ã‚‰ã‹ã‚’å®šç¾©ã—ã¦ã„ã‚Œã°ã€ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨ãªã‚Šã¾ã™; ã‚‚ã—ä¸¡æ–¹ã¨ã‚‚å®šç¾©ã—ãªã‘ã‚Œã°ã€éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã§ã™ã€‚é€šå¸¸ã€ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã§ã¯ã€ :meth:`__get__` ã¨ :meth:`__set__` ã‚’å®šç¾©ã—ã€ä¸€æ–¹ã€éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã«ã¯ :meth:`__get__` ãƒ¡ã‚½ãƒƒãƒ‰ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ :meth:`__set__` ã¨ :meth:`__get__` ã‚’å®šç¾©ã—ãŸãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è¾æ›¸å†…ã§å±æ€§å€¤ãŒå†å®šç¾©ã•ã‚Œã¦ã‚‚ã€å¸¸ã«ã“ã®å€¤ã‚’ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã—ã¾ã™ã€‚å¯¾ç…§çš„ã«ã€éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å ´åˆã«ã¯ã€å±æ€§å€¤ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å´ã§ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1642
msgid ""
"Python methods (including :func:`staticmethod` and :func:`classmethod`) are "
"implemented as non-data descriptors.  Accordingly, instances can redefine "
"and override methods.  This allows individual instances to acquire behaviors"
" that differ from other instances of the same class."
msgstr "(:func:`staticmethod` ã‚„ :func:`classmethod` ã‚’å«ã‚€) Python ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚ãã®çµæœã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å†å®šç¾©ã—ãŸã‚Šã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã§ãã¾ã™ã€‚ã“ã®ã“ã¨ã«ã‚ˆã‚Šã€å€‹ã€…ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒåŒã˜ã‚¯ãƒ©ã‚¹ã®ä»–ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨äº’ã„ã«ç•°ãªã‚‹å‹•ä½œã‚’ç²å¾—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1647
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ":func:`property` é–¢æ•°ã¯ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚å¾“ã£ã¦ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã‚ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å‹•ä½œã‚’ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1654
msgid "__slots__"
msgstr "__slots__"

#: ../../reference/datamodel.rst:1656
msgid ""
"By default, instances of both old and new-style classes have a dictionary "
"for attribute storage.  This wastes space for objects having very few "
"instance variables.  The space consumption can become acute when creating "
"large numbers of instances."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€æ–°æ—§ã©ã¡ã‚‰ã®ã‚¯ãƒ©ã‚¹ã‚‚ã€å±æ€§ã®è¨˜æ†¶é ˜åŸŸã¨ã—ã¦ä½¿ã†ãŸã‚ã®è¾æ›¸ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã“ã®ä»•æ§˜ã¯ã€ã»ã¨ã‚“ã©ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‚’æŒãŸãªã„ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã«ã¯è¨˜æ†¶é ˜åŸŸã®ç„¡é§„é£ã„ã«ãªã‚Šã¾ã™ã€‚è¨˜æ†¶é ˜åŸŸã®æ¶ˆè²»é‡ã¯ã€å¤§é‡ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹éš›ã«ã¯æ·±åˆ»ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1661
msgid ""
"The default can be overridden by defining *__slots__* in a new-style class "
"definition.  The *__slots__* declaration takes a sequence of instance "
"variables and reserves just enough space in each instance to hold a value "
"for each variable.  Space is saved because *__dict__* is not created for "
"each instance."
msgstr "ã“ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¨­å®šã¯ã€æ–°ãŸãªå½¢å¼ã®ã‚¯ãƒ©ã‚¹å®šç¾©ã«ãŠã„ã¦ *__slots__* ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã§ãã¾ã™ã€‚ *__slots_* å®£è¨€ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚å„ã€…ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä¸Šã«ã¯ã€å„å¤‰æ•°ã®å€¤ã‚’è¨˜æ†¶ã™ã‚‹ã®ã«ã¡ã‚‡ã†ã©å¿…è¦ãªé‡ã ã‘ã®è¨˜æ†¶é ˜åŸŸã‚’ç¢ºä¿ã—ã¾ã™ã€‚å„ã€…ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã—ã¦ *__dict__* ãŒç”Ÿæˆã•ã‚Œã‚‹ã“ã¨ãŒãªã„ã®ã§ã€è¨˜æ†¶é ˜åŸŸãŒç¯€ç´„ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1669
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  If defined in a new-style "
"class, *__slots__* reserves space for the declared variables and prevents "
"the automatic creation of *__dict__* and *__weakref__* for each instance."
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹å¤‰æ•°ã«ã¯ã€æ–‡å­—åˆ—ã€åå¾©å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã‚ã‚‹ã„ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒç”¨ã„ã‚‹å¤‰æ•°åã‚’è¡¨ã™æ–‡å­—åˆ—ã‹ã‚‰ãªã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ä»£å…¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®å¤‰æ•°ãŒæ–°ã—ã„å½¢å¼ã®ã‚¯ãƒ©ã‚¹ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ *__slots__* ã¯ã€å„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã—ã¦å®£è¨€ã•ã‚ŒãŸå¤‰æ•°ã«å¿…è¦ãªè¨˜æ†¶é ˜åŸŸã‚’ç¢ºä¿ã—ã€ *__dict__* ã¨ *__weakref__* ãŒè‡ªå‹•çš„ã«ç”Ÿæˆã•ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1676
msgid "Notes on using *__slots__*"
msgstr "*__slots__* ã‚’åˆ©ç”¨ã™ã‚‹éš›ã®æ³¨æ„"

#: ../../reference/datamodel.rst:1678
msgid ""
"When inheriting from a class without *__slots__*, the *__dict__* attribute "
"of that class will always be accessible, so a *__slots__* definition in the "
"subclass is meaningless."
msgstr "*__slots__* ã‚’æŒãŸãªã„ã‚¯ãƒ©ã‚¹ã‹ã‚‰ç¶™æ‰¿ã™ã‚‹å ´åˆã€ *__dict__* å±æ€§ã¯å¸¸ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã®ã§ã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ *__slots__* ã‚’å®šç¾©ã—ã¦ã‚‚æ„å‘³ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1682
msgid ""
"Without a *__dict__* variable, instances cannot be assigned new variables "
"not listed in the *__slots__* definition.  Attempts to assign to an unlisted"
" variable name raises :exc:`AttributeError`. If dynamic assignment of new "
"variables is desired, then add ``'__dict__'`` to the sequence of strings in "
"the *__slots__* declaration."
msgstr "*__dict__* å¤‰æ•°ãŒãªã„å ´åˆã€ *__slots__* ã«åˆ—æŒ™ã•ã‚Œã¦ã„ãªã„æ–°ãŸãªå¤‰æ•°ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ä»£å…¥ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚åˆ—æŒ™ã•ã‚Œã¦ã„ãªã„å¤‰æ•°åã‚’ä½¿ã£ã¦ä»£å…¥ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã€ :exc:`AttributeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚æ–°ãŸãªå¤‰æ•°ã‚’å‹•çš„ã«ä»£å…¥ã—ãŸã„ã®ãªã‚‰ã€ *__slots__* ã‚’å®£è¨€ã™ã‚‹éš›ã« ``'__dict__'`` ã‚’å¤‰æ•°åã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«è¿½åŠ ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1688
msgid ""
"Previously, adding ``'__dict__'`` to the *__slots__* declaration would not "
"enable the assignment of new attributes not specifically listed in the "
"sequence of instance variable names."
msgstr "ã“ã‚Œã¾ã§ã¯ã€ ``'__dict__'`` ã‚’ *__slots__* å®£è¨€ã«è¿½åŠ ã—ã¦ã‚‚ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°åã¨ã—ã¦ä»–ã«ãƒªã‚¹ãƒˆã•ã‚Œã¦ã„ãªã„æ–°ãŸãªå±æ€§ã®ä»£å…¥ã¯ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"

#: ../../reference/datamodel.rst:1693
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support weak references to its instances. If weak "
"reference support is needed, then add ``'__weakref__'`` to the sequence of "
"strings in the *__slots__* declaration."
msgstr "*__slots__* ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã®å„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã« *__weakref__* å¤‰æ•°ãŒãªã„å ´åˆã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã™ã‚‹å¼±å‚ç…§ (weak reference) ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã›ã‚“ã€‚å¼±å‚ç…§ã®ã‚µãƒãƒ¼ãƒˆãŒå¿…è¦ãªã‚‰ã€ *__slots__* ã‚’å®£è¨€ã™ã‚‹éš›ã« ``'__weakref__'`` ã‚’å¤‰æ•°åã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«è¿½åŠ ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1698
msgid ""
"Previously, adding ``'__weakref__'`` to the *__slots__* declaration would "
"not enable support for weak references."
msgstr "ã“ã‚Œã¾ã§ã¯ã€ ``'__weakref__'`` ã‚’ *__slots__* å®£è¨€ã«è¿½åŠ ã—ã¦ã‚‚ã€å¼±å‚ç…§ã®ã‚µãƒãƒ¼ãƒˆã‚’æœ‰åŠ¹ã«ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"

#: ../../reference/datamodel.rst:1702
msgid ""
"*__slots__* are implemented at the class level by creating descriptors "
"(:ref:`descriptors`) for each variable name.  As a result, class attributes "
"cannot be used to set default values for instance variables defined by "
"*__slots__*; otherwise, the class attribute would overwrite the descriptor "
"assignment."
msgstr "*__slots__* ã¯ã€ã‚¯ãƒ©ã‚¹ã®ãƒ¬ãƒ™ãƒ«ã§å„å¤‰æ•°ã«å¯¾ã™ã‚‹ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ (:ref:`descriptors` ã‚’å‚ç…§) ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã¾ã™ã€‚ãã®çµæœã€ *__slots__* ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ã‚¯ãƒ©ã‚¹å±æ€§ã‚’ä½¿ã£ã¦è¨­å®šã§ããªããªã£ã¦ã„ã¾ã™; ãã†ã—ãªã„ã¨ã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã«ã‚ˆã‚‹ä»£å…¥ã‚’ã‚¯ãƒ©ã‚¹å±æ€§ãŒä¸Šæ›¸ãã—ã¦ã—ã¾ã†ã‹ã‚‰ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1708
msgid ""
"The action of a *__slots__* declaration is limited to the class where it is "
"defined.  As a result, subclasses will have a *__dict__* unless they also "
"define *__slots__* (which must only contain names of any *additional* "
"slots)."
msgstr "*__slots__* å®£è¨€ãŒå‹•ä½œã™ã‚‹ã®ã¯ã€å®šç¾©ãŒè¡Œã‚ã‚ŒãŸã‚¯ãƒ©ã‚¹ã ã‘ã«é™ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ãã®çµæœã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã¯ã€ *__slots__* ã‚’å®šç¾©ã—ãªã„é™ã‚Š *__dict__* ã‚’æŒã¤ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1712
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr "ã‚ã‚‹ã‚¯ãƒ©ã‚¹ã§ã€åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã§ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¹ãƒ­ãƒƒãƒˆã‚’å®šç¾©ã—ãŸå ´åˆã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚¹ãƒ­ãƒƒãƒˆã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã¯ (ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’åŸºåº•ã‚¯ãƒ©ã‚¹ã‹ã‚‰ç›´æ¥å–å¾—ã—ãªã„é™ã‚Š) ã‚¢ã‚¯ã‚»ã‚¹ã§ããªããªã‚Šã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®è¶£æ„ãŒä¸å®šã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚å°†æ¥ã¯ã€ã“ã®å•é¡Œã‚’é¿ã‘ã‚‹ãŸã‚ã«ä½•ã‚‰ã‹ã®ãƒã‚§ãƒƒã‚¯ãŒè¿½åŠ ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1717
msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-"
"length\" built-in types such as :class:`long`, :class:`str` and "
":class:`tuple`."
msgstr "ç©ºã§ãªã„ *__slots__* ã¯ã€ :class:`long` ã€ :class:`str` ã€ãŠã‚ˆã³ :class:`tuple` ã¨ã„ã£ãŸã€\"å¯å¤‰é•· (variable-length)\" ã®çµ„ã¿è¾¼ã¿å‹ã‹ã‚‰æ´¾ç”Ÿã—ãŸã‚¯ãƒ©ã‚¹ã§ã¯å‹•ä½œã—ã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1720
msgid ""
"Any non-string iterable may be assigned to *__slots__*. Mappings may also be"
" used; however, in the future, special meaning may be assigned to the values"
" corresponding to each key."
msgstr "*__slots__* ã«ã¯ã€æ–‡å­—åˆ—ã§ãªã„åå¾©å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»£å…¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚è¾æ›¸å‹ã‚‚ä½¿ã†ã“ã¨ãŒã§ãã¾ã™; ã—ã‹ã—å°†æ¥ã€è¾æ›¸ã®å„ã‚­ãƒ¼ã«ç›¸å½“ã™ã‚‹å€¤ã«ä½•ã‚‰ã‹ã®ç‰¹æ®Šãªæ„å‘³ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1724
msgid ""
"*__class__* assignment works only if both classes have the same *__slots__*."
msgstr "*__class__* ã¸ã®ä»£å…¥ã¯ã€ä¸¡æ–¹ã®ã‚¯ãƒ©ã‚¹ãŒåŒã˜ *__slots__* ã‚’æŒã£ã¦ã„ã‚‹ã¨ãã®ã¿å‹•ä½œã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1726
msgid ""
"Previously, *__class__* assignment raised an error if either new or old "
"class had *__slots__*."
msgstr "ä»¥å‰ã¯ã€æ–°æ—§ã©ã¡ã‚‰ã‹ã®ã‚¯ãƒ©ã‚¹ãŒ *__slots__* ã‚’æŒã£ã¦ã„ãŸã‚‰ *__class__* ã¸ã®ä»£å…¥ã¯ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã—ã¦ã„ã¾ã—ãŸã€‚"

#: ../../reference/datamodel.rst:1734
msgid "Customizing class creation"
msgstr "ã‚¯ãƒ©ã‚¹ç”Ÿæˆã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹"

#: ../../reference/datamodel.rst:1736
msgid ""
"By default, new-style classes are constructed using :func:`type`. A class "
"definition is read into a separate namespace and the value of class name is "
"bound to the result of ``type(name, bases, dict)``."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã¯ :func:`type` ã‚’ä½¿ã£ã¦æ§‹ç¯‰ã•ã‚Œã¾ã™ã€‚ã‚¯ãƒ©ã‚¹å®šç¾©ãŒåˆ¥ã®åå‰ç©ºé–“ã«èª­ã¿è¾¼ã¾ã‚Œã€ã‚¯ãƒ©ã‚¹åã¯ ``type(name, bases, dict)`` ã®çµæœã«çµåˆã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1740
msgid ""
"When the class definition is read, if *__metaclass__* is defined then the "
"callable assigned to it will be called instead of :func:`type`. This allows "
"classes or functions to be written which monitor or alter the class creation"
" process:"
msgstr "ã‚¯ãƒ©ã‚¹å®šç¾©ãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹éš›ã€ *__metaclass__* ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚Œã°ã€ :func:`type` ã®ä»£ã‚ã‚Šã« *__metaclass__* ãŒæŒ‡ã—ã¦ã„ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã£ã¦ã€"

#: ../../reference/datamodel.rst:1745
msgid "Modifying the class dictionary prior to the class being created."
msgstr "ã‚¯ãƒ©ã‚¹ãŒç”Ÿæˆã•ã‚Œã‚‹å‰ã«ã‚¯ãƒ©ã‚¹è¾æ›¸ã‚’å¤‰æ›´ã™ã‚‹"

#: ../../reference/datamodel.rst:1747
msgid ""
"Returning an instance of another class -- essentially performing the role of"
" a factory function."
msgstr "ä»–ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™ -- æœ¬è³ªçš„ã«ã¯ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã®å½¹å‰²ã‚’æœãŸã™"

#: ../../reference/datamodel.rst:1750
msgid ""
"These steps will have to be performed in the metaclass's :meth:`__new__` "
"method -- :meth:`type.__new__` can then be called from this method to create"
" a class with different properties.  This example adds a new element to the "
"class dictionary before creating the class::"
msgstr "ã“ã‚Œã‚‰ã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ã€ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã® :meth:`__new__` ãƒ¡ã‚½ãƒƒãƒ‰ã§å®Ÿè¡Œã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ -- ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰ä»–ã®å±æ€§ã‚’æŒã£ãŸã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‹ã«ã¯ã€ :meth:`type.__new__` ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚æ¬¡ã®ä¾‹ã§ã¯ã‚¯ãƒ©ã‚¹ã‚’ç”Ÿæˆã™ã‚‹å‰ã«æ–°ã—ã„è¦ç´ ã‚’ã‚¯ãƒ©ã‚¹è¾æ›¸ã«è¿½åŠ ã—ã¦ã„ã¾ã™ã€‚ ::"

#: ../../reference/datamodel.rst:1760
msgid ""
"You can of course also override other class methods (or add new methods); "
"for example defining a custom :meth:`__call__` method in the metaclass "
"allows custom behavior when the class is called, e.g. not always creating a "
"new instance."
msgstr "ã‚‚ã¡ã‚ã‚“ã€ä»–ã®ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹(ã¾ãŸã¯æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã™ã‚‹)ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚«ã‚¹ã‚¿ãƒ ã® :meth:`__call__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã«å®šç¾©ã—ã¦ã€æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å¸¸ã«ã¯é€ ã‚‰ãªã„ã¨ã„ã£ãŸã‚«ã‚¹ã‚¿ãƒ ã®å‹•ä½œã‚’å®Ÿè£…ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1767
msgid ""
"This variable can be any callable accepting arguments for ``name``, "
"``bases``, and ``dict``.  Upon class creation, the callable is used instead "
"of the built-in :func:`type`."
msgstr "ã“ã®å¤‰æ•°ã¯ ``name`` ã€ ``bases`` ã€ãŠã‚ˆã³ ``dict`` ã‚’å¼•æ•°ã¨ã—ã¦å–ã‚‹ã‚ˆã†ãªä»»æ„ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã§ãã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ç”Ÿæˆã®éš›ã€çµ„ã¿è¾¼ã¿ã® :func:`type` ã®ä»£ã‚ã‚Šã«ã€æŒ‡å®šã•ã‚ŒãŸå‘¼ã³å‡ºã—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1773
msgid ""
"The appropriate metaclass is determined by the following precedence rules:"
msgstr "ä»¥ä¸‹ã«å„ªå…ˆé †ã§ä¸¦ã‚“ã è¦å‰‡ã«ã‚ˆã£ã¦ã€é©åˆ‡ãªãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ãŒæ±ºå®šã•ã‚Œã¾ã™:"

#: ../../reference/datamodel.rst:1775
msgid "If ``dict['__metaclass__']`` exists, it is used."
msgstr "``dict['__metaclass__']`` ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1777
msgid ""
"Otherwise, if there is at least one base class, its metaclass is used (this "
"looks for a *__class__* attribute first and if not found, uses its type)."
msgstr "ãã‚Œä»¥å¤–ã®å ´åˆã§ã€æœ€ä½ã§ã‚‚ä¸€ã¤åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’æŒã£ã¦ã„ã‚‹ãªã‚‰ã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ (*__class__* å±æ€§ã‚’æ¢ã—ã€ãªã‘ã‚Œã°åŸºåº•ã‚¯ãƒ©ã‚¹ã®å‹) ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1780
msgid ""
"Otherwise, if a global variable named __metaclass__ exists, it is used."
msgstr "ãã‚Œä»¥å¤–ã®å ´åˆã§ã€__metaclass__ ã¨ã„ã†åå‰ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãŒã‚ã‚Œã°ã€ãã‚Œã‚’ã¤ã‹ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1782
msgid "Otherwise, the old-style, classic metaclass (types.ClassType) is used."
msgstr "ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã®ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ (types.ClassType) ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1784
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored including logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr "ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã¯é™ã‚Šãªã„æ½œåœ¨çš„åˆ©ç”¨ä¾¡å€¤ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¾ã§è©¦ã•ã‚Œã¦ããŸã‚¢ã‚¤ãƒ‡ã‚¢ã«ã¯ã€ãƒ­ã‚°è¨˜éŒ²ã€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã®ãƒã‚§ãƒƒã‚¯ã€è‡ªå‹•ãƒ‡ãƒªã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã€è‡ªå‹•ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ç”Ÿæˆã€ãƒ—ãƒ­ã‚­ã‚·ã€ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã€ãã—ã¦è‡ªå‹•ãƒªã‚½ãƒ¼ã‚¹ãƒ­ãƒƒã‚¯ï¼åŒæœŸã¨ã„ã£ãŸã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1791
msgid "Customizing instance and subclass checks"
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã¨ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãƒã‚§ãƒƒã‚¯"

#: ../../reference/datamodel.rst:1795
msgid ""
"The following methods are used to override the default behavior of the "
":func:`isinstance` and :func:`issubclass` built-in functions."
msgstr "ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯çµ„ã¿è¾¼ã¿é–¢æ•° :func:`isinstance` ã¨ :func:`issubclass` ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œã‚’ä¸Šæ›¸ãã™ã‚‹ã®ã«åˆ©ç”¨ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1798
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr "ç‰¹ã«ã€ :class:`abc.ABCMeta` ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã¯ã€æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ (ABCs) ã‚’\"ä»®æƒ³åŸºåº•ã‚¯ãƒ©ã‚¹ (virtual base classes)\" ã¨ã—ã¦ã€ä»–ã® ABC ã‚’å«ã‚€ã€ä»»æ„ã®ã‚¯ãƒ©ã‚¹ã‚„ (çµ„ã¿è¾¼ã¿å‹ã‚’å«ã‚€) å‹ã«è¿½åŠ ã™ã‚‹ãŸã‚ã«ã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1805
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr "*instance* ãŒ (ç›´æ¥ã€ã¾ãŸã¯é–“æ¥çš„ã«) *class* ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨è€ƒãˆã‚‰ã‚Œã‚‹å ´åˆã« true ã‚’è¿”ã—ã¾ã™ã€‚å®šç¾©ã•ã‚Œã¦ã„ã‚Œã°ã€ ``isinstance(instance, class)`` ã®å®Ÿè£…ã®ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1812
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass,"
" class)``."
msgstr "*subclass* ãŒ (ç›´æ¥ã€ã¾ãŸã¯é–“æ¥çš„ã«) *class* ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã¨è€ƒãˆã‚‰ã‚Œã‚‹å ´åˆã« true ã‚’è¿”ã—ã¾ã™ã€‚å®šç¾©ã•ã‚Œã¦ã„ã‚Œã°ã€ ``issubclass(subclass, class)`` ã®å®Ÿè£…ã®ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1817
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr "ãªãŠã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚¯ãƒ©ã‚¹ã®å‹ (ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹) ä¸Šã§æ¤œç´¢ã•ã‚Œã¾ã™ã€‚å®Ÿéš›ã®ã‚¯ãƒ©ã‚¹ã«ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦å®šç¾©ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãã‚Œè‡ªä½“ãŒã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ã“ã®å ´åˆã«ã®ã¿ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã®æ¤œç´¢ã¨ä¸€è²«ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1828
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã®å°å…¥"

#: ../../reference/datamodel.rst:1825
msgid ""
"Includes the specification for customizing :func:`isinstance` and "
":func:`issubclass` behavior through :meth:`~class.__instancecheck__` and "
":meth:`~class.__subclasscheck__`, with motivation for this functionality in "
"the context of adding Abstract Base Classes (see the :mod:`abc` module) to "
"the language."
msgstr "æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ (:mod:`abc` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§) ã‚’è¨€èªã«è¿½åŠ ã™ã‚‹æ–‡è„ˆã«ãŠã„ã¦ã®å‹•æ©Ÿã‹ã‚‰ã€ :meth:`~class.__instancecheck__` ã¨ :meth:`~class.__subclasscheck__` ã‚’é€šã—ã¦ã€ :func:`isinstance` ã¨ :func:`issubclass` ã«ç‹¬è‡ªã®å‹•ä½œã‚’ã•ã›ã‚‹ãŸã‚ã®ä»•æ§˜ã®è¨˜è¿°ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1835
msgid "Emulating callable objects"
msgstr "å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹"

#: ../../reference/datamodel.rst:1842
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, arg2, "
"...)``."
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒé–¢æ•°ã¨ã—ã¦ \"å‘¼ã°ã‚ŒãŸ\" éš›ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™; ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ ``x(arg1, arg2, ...)`` ã¯ ``x.__call__(arg1, arg2, ...)`` ã‚’çŸ­ãæ›¸ã„ãŸã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1849
msgid "Emulating container types"
msgstr "ã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹"

#: ../../reference/datamodel.rst:1851
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are sequences (such as lists or tuples) or mappings (like"
" dictionaries), but can represent other containers as well.  The first set "
"of methods is used either to emulate a sequence or to emulate a mapping; the"
" difference is that for a sequence, the allowable keys should be the "
"integers *k* for which ``0 <= k < N`` where *N* is the length of the "
"sequence, or slice objects, which define a range of items. (For backwards "
"compatibility, the method :meth:`__getslice__` (see below) can also be "
"defined to handle simple, but not extended slices.) It is also recommended "
"that mappings provide the methods :meth:`keys`, :meth:`values`, "
":meth:`items`, :meth:`has_key`, :meth:`get`, :meth:`clear`, "
":meth:`setdefault`, :meth:`iterkeys`, :meth:`itervalues`, :meth:`iteritems`,"
" :meth:`pop`, :meth:`popitem`, :meth:`!copy`, and :meth:`update` behaving "
"similar to those for Python's standard dictionary objects.  The "
":mod:`UserDict` module provides a :class:`DictMixin` class to help create "
"those methods from a base set of :meth:`__getitem__`, :meth:`__setitem__`, "
":meth:`__delitem__`, and :meth:`keys`. Mutable sequences should provide "
"methods :meth:`append`, :meth:`count`, :meth:`index`, :meth:`extend`, "
":meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:`reverse` and "
":meth:`sort`, like Python standard list objects.  Finally, sequence types "
"should implement addition (meaning concatenation) and multiplication "
"(meaning repetition) by defining the methods :meth:`__add__`, "
":meth:`__radd__`, :meth:`__iadd__`, :meth:`__mul__`, :meth:`__rmul__` and "
":meth:`__imul__` described below; they should not define :meth:`__coerce__` "
"or other numerical operators.  It is recommended that both mappings and "
"sequences implement the :meth:`__contains__` method to allow efficient use "
"of the ``in`` operator; for mappings, ``in`` should be equivalent of "
":meth:`has_key`; for sequences, it should search through the values.  It is "
"further recommended that both mappings and sequences implement the "
":meth:`__iter__` method to allow efficient iteration through the container; "
"for mappings, :meth:`__iter__` should be the same as :meth:`iterkeys`; for "
"sequences, it should iterate through the values."
msgstr "ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã€ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚³ãƒ³ãƒ†ãƒŠã¯é€šå¸¸ã€(ãƒªã‚¹ãƒˆã‚„ã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãª) ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚„ã€(è¾æ›¸ã®ã‚ˆã†ãª) ãƒãƒƒãƒ—å‹ã‚’æŒ‡ã—ã¾ã™ãŒã€ä»–ã®ã‚³ãƒ³ãƒ†ãƒŠã‚‚åŒã˜ã‚ˆã†ã«è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æœ€åˆã®ä¸€é€£ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ãŸã‚Šã€ãƒãƒƒãƒ—å‹ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™; ãã®é•ã„ã¨ã—ã¦ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å ´åˆã«ã¯ã€ã‚­ãƒ¼ã¨ã—ã¦è¨±ã•ã‚Œã¦ã„ã‚‹ã®ãŒã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒ *N* ã§ã‚ã‚‹ã¨ãã® ``0 <= k < N`` ãªã‚‹æ•´æ•° *k* ã‹ã€ã‚ã‚‹ã„ã¯è¦ç´ ã®ç¯„å›²ã‚’è¡¨ã™ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚ (å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã€ :meth:`__getslice__` (ä»¥ä¸‹å‚ç…§) ã‚’å®šç¾©ã—ã¦ã€æ‹¡å¼µã•ã‚Œã¦ã„ãªã„å˜ç´”ãªã‚¹ãƒ©ã‚¤ã‚¹ã‚’æ‰±ã†ã‚ˆã†ã«ã‚‚ã§ãã¾ã™ã€‚)å¤‰æ›´å¯èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã¯ã€Python ã®æ¨™æº–ãƒªã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚ˆã†ã«ã€ãƒ¡ã‚½ãƒƒãƒ‰ :meth:`append`, :meth:`count`, :meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:`reverse`,ãŠã‚ˆã³ :meth:`sort` ã‚’æä¾›ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ—å‹ã§ã‚‚ã€Python ã®æ¨™æº–è¾æ›¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚ˆã†ã«ã€ :meth:`keys`, :meth:`values`, :meth:`items`, :meth:`has_key`, :meth:`get`, :meth:`clear`, :meth:`setdefault`, :meth:`iterkeys`, :meth:`itervalues`, :meth:`iteritems`, :meth:`pop`, :meth:`popitem`, :meth:`!copy`,ãŠã‚ˆã³ :meth:`update` ã¨ã„ã£ãŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒãƒƒãƒ—å‹ã§æä¾›ã™ã‚‹ã‚ˆã†æ¨å¥¨ã—ã¦ã„ã¾ã™ã€‚ :mod:`UserDict` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ :meth:`__getitem__`, :meth:`__setitem__`, :meth:`__delitem__`,ãŠã‚ˆã³ :meth:`keys` ã¨ã„ã£ãŸåŸºæœ¬ã‚»ãƒƒãƒˆã‹ã‚‰ä½œæˆã™ã‚‹ä¸Šã§å½¹ã«ç«‹ã¤ :class:`DictMixin` ã‚¯ãƒ©ã‚¹ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚æœ€å¾Œã«ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã§ã¯ä»¥ä¸‹ã«è¿°ã¹ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ç¾¤ :meth:`__add__`, :meth:`__radd__`, :meth:`__iadd__`, :meth:`__mul__`, :meth:`__rmul__`,ãŠã‚ˆã³ :meth:`__imul__` ã‚’å®šç¾©ã—ã¦ã€ (ã‚·ãƒ¼ã‚±ãƒ³ã‚¹é–“ã®çµåˆã‚’æ„å‘³ã™ã‚‹) åŠ ç®—æ“ä½œã¨ (è¦ç´ ã®ç¹°ã‚Šè¿”ã—ã‚’æ„å‘³ã™ã‚‹) ä¹—ç®—æ“ä½œã‚’å®Ÿè£…ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; :meth:`__coerce__` ã‚„ã€ãã®ä»–ã®æ•°å€¤æ¼”ç®—å­ã‚’å®šç¾©ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ—ã§ã‚‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã‚‚ã€ ``in`` æ¼”ç®—å­ãŒæœ‰åŠ¹åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã« :meth:`__contains__` ãƒ¡ã‚½ãƒƒãƒ‰ã®å®šç¾©ã‚’æ¨å¥¨ã—ã¾ã™; ãƒãƒƒãƒ—å‹ã§ã¯ã€ ``in`` ã¯ :meth:`has_key` ã¨ç­‰ä¾¡ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã¯ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å†…ã®å€¤ã«ã‚ãŸã£ã¦æ¤œç´¢ã‚’è¡Œã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã•ã‚‰ã«ã€ãƒãƒƒãƒ—ã§ã‚‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã‚‚ã€ã‚³ãƒ³ãƒ†ãƒŠå†…ã«ã‚ãŸã‚‹åå¾©æ“ä½œãŒã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã€ :meth:`__iter__` ã‚’å®Ÿè£…ã™ã‚‹ã‚ˆã†å‹§ã‚ã¾ã™; ãƒãƒƒãƒ—å‹ã®å ´åˆã€ :meth:`__iter__` ã¯ :meth:`iterkeys` ã¨ç­‰ä¾¡ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å ´åˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å†…ã®å€¤ã«ã‚ãŸã£ã¦åå¾©æ“ä½œã‚’è¡Œã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1889
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`__nonzero__` method and whose :meth:`__len__` method returns"
" zero is considered to be false in a Boolean context."
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•° :func:`len` ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é•·ã•ã‚’ ``>=`` 0 ã§ã‚ã‚‹æ•´æ•°ã§è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã¾ãŸã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ :meth:`__nonzero__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ãŠã‚‰ãšã€ :meth:`__len__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚¼ãƒ­ã‚’è¿”ã™å ´åˆã«ã¯ã€ãƒ–ãƒ¼ãƒ«æ¼”ç®—ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã¯å½ã§ã‚ã‚‹ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1896
msgid ""
"In CPython, the length is required to be at most :attr:`sys.maxsize`. If the"
" length is larger than :attr:`!sys.maxsize` some features (such as "
":func:`len`) may raise :exc:`OverflowError`.  To prevent raising "
":exc:`!OverflowError` by truth value testing, an object must define a "
":meth:`__nonzero__` method."
msgstr "CPython ã§ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é•·ã•ã¯æœ€å¤§ã§ã‚‚ :attr:`sys.maxsize` ã§ã‚ã‚‹ã“ã¨ãŒè¦æ±‚ã•ã‚Œã¾ã™ã€‚\né•·ã•ãŒ :attr:`!sys.maxsize` ã‚’è¶Šãˆã‚‹å ´åˆã€(:func:`len` ã®ã‚ˆã†ãª) ã„ãã¤ã‹ã®æ©Ÿèƒ½ã¯ :exc:`OverflowError` ã‚’é€å‡ºã™ã‚‹ã§ã—ã‚‡ã†ã€‚\nçœŸå½å€¤ã¨ã—ã¦ã®åˆ¤å®šã§ :exc:`!OverflowError` ã‚’é€å‡ºã—ãªã„ã‚ˆã†ã«ã™ã‚‹ã«ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ meth:`__nonzero__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1907
msgid ""
"Called to implement evaluation of ``self[key]``. For sequence types, the "
"accepted keys should be integers and slice objects.  Note that the special "
"interpretation of negative indexes (if the class wishes to emulate a "
"sequence type) is up to the :meth:`__getitem__` method. If *key* is of an "
"inappropriate type, :exc:`TypeError` may be raised; if of a value outside "
"the set of indexes for the sequence (after any special interpretation of "
"negative values), :exc:`IndexError` should be raised. For mapping types, if "
"*key* is missing (not in the container), :exc:`KeyError` should be raised."
msgstr "``self[key]`` ã®å€¤è©•ä¾¡ (evaluation) ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å ´åˆã€ã‚­ãƒ¼ã¨ã—ã¦æ•´æ•°ã¨ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ç†ã§ããªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ (ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹å ´åˆ) è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã®è§£é‡ˆã¯ :meth:`__getitem__` ãƒ¡ã‚½ãƒƒãƒ‰æ¬¡ç¬¬ã¨ãªã‚Šã¾ã™ã€‚ *key* ãŒä¸é©åˆ‡ãªå‹ã§ã‚ã£ãŸå ´åˆã€ :exc:`TypeError` ã‚’é€å‡ºã—ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“; (è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å€¤ã«å¯¾ã—ã¦ä½•ã‚‰ã‹ã®è§£é‡ˆã‚’è¡Œã£ãŸä¸Šã§) *key* ãŒã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹é›†åˆå¤–ã®å€¤ã§ã‚ã‚‹å ´åˆã€ :exc:`IndexError` ã‚’é€å‡ºã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ—å‹ã®å ´åˆã¯ã€ *key* ã«èª¤ã‚ŠãŒã‚ã‚‹å ´åˆï¼ˆã‚³ãƒ³ãƒ†ãƒŠã«å«ã¾ã‚Œã¦ã„ãªã„å ´åˆï¼‰ã€ :exc:`KeyError` ã‚’é€å‡ºã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1918
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ":keyword:`for` ãƒ«ãƒ¼ãƒ—ã§ã¯ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®çµ‚ç«¯ã‚’æ­£ã—ãæ¤œå‡ºã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€ä¸æ­£ãªã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã«å¯¾ã—ã¦ :exc:`IndexError` ãŒé€å‡ºã•ã‚Œã‚‹ã‚‚ã®ã¨æœŸå¾…ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1924
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the "
"objects support changes to the values for keys, or if new keys can be added,"
" or for sequences if elements can be replaced.  The same exceptions should "
"be raised for improper *key* values as for the :meth:`__getitem__` method."
msgstr "``self[key]`` ã«å¯¾ã™ã‚‹ä»£å…¥ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ :meth:`__getitem__` ã¨åŒã˜æ³¨æ„äº‹é …ãŒã‚ã¦ã¯ã¾ã‚Šã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã§ãã‚‹ã®ã¯ã€ã‚ã‚‹ã‚­ãƒ¼ã«å¯¾ã™ã‚‹å€¤ã®å¤‰æ›´ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ã€æ–°ãŸãªã‚­ãƒ¼ã‚’è¿½åŠ ã§ãã‚‹ã‚ˆã†ãªãƒãƒƒãƒ—ã®å ´åˆã¨ã€ã‚ã‚‹è¦ç´ ã‚’ç½®ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å ´åˆã ã‘ã§ã™ã€‚ä¸æ­£ãª *key* ã«å¯¾ã—ã¦ã¯ã€ :meth:`__getitem__` ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒæ§˜ã®ä¾‹å¤–ã®é€å‡ºã‚’è¡Œã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1933
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the "
"objects support removal of keys, or for sequences if elements can be removed"
" from the sequence.  The same exceptions should be raised for improper *key*"
" values as for the :meth:`__getitem__` method."
msgstr "``self[key]`` ã®å‰Šé™¤ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ :meth:`__getitem__` ã¨åŒã˜æ³¨æ„äº‹é …ãŒã‚ã¦ã¯ã¾ã‚Šã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã§ãã‚‹ã®ã¯ã€ã‚­ãƒ¼ã®å‰Šé™¤ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãƒãƒƒãƒ—ã®å ´åˆã¨ã€è¦ç´ ã‚’å‰Šé™¤ã§ãã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å ´åˆã ã‘ã§ã™ã€‚ä¸æ­£ãª *key* ã«å¯¾ã—ã¦ã¯ã€ :meth:`__getitem__` ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒæ§˜ã®ä¾‹å¤–ã®é€å‡ºã‚’è¡Œã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1942
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]``"
" for dict subclasses when key is not in the dictionary."
msgstr "``self[key]`` ã®å®Ÿè£…ã«ãŠã„ã¦è¾æ›¸å†…ã«ã‚­ãƒ¼ãŒå­˜åœ¨ã—ãªã‹ã£ãŸå ´åˆã«ã€ dict ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ãŸã‚ã« :class:`dict`\\ .\\ :meth:`__getitem__` ã«ã‚ˆã£ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1948
msgid ""
"This method is called when an iterator is required for a container. This "
"method should return a new iterator object that can iterate over all the "
"objects in the container.  For mappings, it should iterate over the keys of "
"the container, and should also be made available as the method "
":meth:`iterkeys`."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚³ãƒ³ãƒ†ãƒŠã«å¯¾ã—ã¦ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒè¦æ±‚ã•ã‚ŒãŸéš›ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚³ãƒ³ãƒ†ãƒŠå†…ã®å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ãŸã‚‹åå¾©å‡¦ç†ãŒã§ãã‚‹ã‚ˆã†ãªã€æ–°ãŸãªã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ—ã®å ´åˆã€ã‚³ãƒ³ãƒ†ãƒŠå†…ã®ã‚­ãƒ¼ã«æ¸¡ã‚‹åå¾©å‡¦ç†ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ã‹ã¤ :meth:`iterkeys` ã«ã‚ˆã£ã¦åˆ©ç”¨ã§ããªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1953
msgid ""
"Iterator objects also need to implement this method; they are required to "
"return themselves.  For more information on iterator objects, see "
":ref:`typeiter`."
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™; ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®å ´åˆã€è‡ªåˆ†è‡ªèº«ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«é–¢ã™ã‚‹ã‚ˆã‚Šè©³ç´°ãªæƒ…å ±ã¯ã€ :ref:`typeiter` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1959
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ":func:`reversed` çµ„ã¿è¾¼ã¿é–¢æ•°ãŒé€†æ–¹å‘ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€(å­˜åœ¨ã™ã‚Œã°)å‘¼ã³å‡ºã—ã¾ã™ã€‚ã‚³ãƒ³ãƒ†ãƒŠå†…ã®å…¨è¦ç´ ã‚’é€†é †ã«ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã€æ–°ã—ã„ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã™ã¹ãã§ã™ã€‚"

#: ../../reference/datamodel.rst:1963
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and "
":meth:`__getitem__`).  Objects that support the sequence protocol should "
"only provide :meth:`__reversed__` if they can provide an implementation that"
" is more efficient than the one provided by :func:`reversed`."
msgstr ":meth:`__reversed__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ :func:`reversed` çµ„è¾¼ã¿é–¢æ•°ã¯ sequence ãƒ—ãƒ­ãƒˆã‚³ãƒ« (:meth:`__len__` ã¨ :meth:`__getitem__`) ã‚’ä½¿ã£ãŸæ–¹æ³•ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ã€‚ sequence ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ :func:`reversed` ã‚ˆã‚Šã‚‚åŠ¹ç‡ã®ã„ã„å®Ÿè£…ã‚’æä¾›ã§ãã‚‹å ´åˆã«ã®ã¿ :meth:`__reversed__` ã‚’å®šç¾©ã™ã‚‹ã¹ãã§ã™ã€‚"

#: ../../reference/datamodel.rst:1972
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a sequence.  However, container"
" objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be a sequence."
msgstr "ãƒ¡ãƒ³ãƒã‚·ãƒƒãƒ—ãƒ†ã‚¹ãƒˆæ¼”ç®—å­ (:keyword:`in` ãŠã‚ˆã³ :keyword:`not in`) ã¯é€šå¸¸ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«æ¸¡ã‚‹åå¾©å‡¦ç†ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ä»¥ä¸‹ã®ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã€ã‚ˆã‚ŠåŠ¹ç‡çš„ãªå®Ÿè£…ã‚’è¡Œã£ãŸã‚Šã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ãªãã¦ã‚‚ã‚ˆã„ã‚ˆã†ã«ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1979
msgid ""
"Called to implement membership test operators.  Should return true if *item*"
" is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr "ãƒ¡ãƒ³ãƒã‚·ãƒƒãƒ—ãƒ†ã‚¹ãƒˆæ¼”ç®—ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ *item* ãŒ *self* å†…ã«å­˜åœ¨ã™ã‚‹å ´åˆã«ã¯çœŸã‚’ã€ãã†ã§ãªã„å ´åˆã«ã¯å½ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€å€¤ã‚„ã‚­ãƒ¼ã¨å€¤ã®çµ„ã§ã¯ãªãã€ã‚­ãƒ¼ã«å¯¾ã™ã‚‹ãƒ¡ãƒ³ãƒã‚·ãƒƒãƒ—ãƒ†ã‚¹ãƒˆã‚’è€ƒãˆãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1983
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ":meth:`__contains__` ã‚’å®šç¾©ã—ãªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã¯ã€ãƒ¡ãƒ³ãƒã‚·ãƒƒãƒ—ãƒ†ã‚¹ãƒˆã¯ã¾ãšã€ :meth:`__iter__` ã‚’ä½¿ã£ãŸåå¾©ã‚’è©¦ã¿ã¾ã™ã€æ¬¡ã«å¤ã„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹åå¾©ãƒ—ãƒ­ãƒˆã‚³ãƒ« :meth:`__getitem__` ã‚’ä½¿ã„ã¾ã™ã€ :ref:`è¨€èªãƒ¬ãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã®ã“ã®ç¯€ <membership-test-details>` ã‚’å‚ç…§ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1992
msgid "Additional methods for emulation of sequence types"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½¿ã‚ã‚Œã‚‹ãã®ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../reference/datamodel.rst:1994
msgid ""
"The following optional methods can be defined to further emulate sequence "
"objects.  Immutable sequences methods should at most only define "
":meth:`__getslice__`; mutable sequences might define all three methods."
msgstr "ä»¥ä¸‹ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨ãªã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚ˆã‚Šé«˜åº¦ã«ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§ãã¾ã™ã€‚å¤‰æ›´ä¸èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ã€ :meth:`__getslice__` ãŒå®šç¾©ã§ãã‚‹ã ã‘ã§ã™; å¤‰æ›´å¯èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã¯ä¸‰ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰å…¨ã¦ã‚’å®šç¾©ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2001
msgid ""
"Support slice objects as parameters to the :meth:`__getitem__` method. "
"(However, built-in types in CPython currently still implement "
":meth:`__getslice__`.  Therefore, you have to override it in derived classes"
" when implementing slicing.)"
msgstr "ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :meth:`__getitem__` ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã¨ã—ã¦ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ (ã—ã‹ã—ã€ç¾åœ¨ã® CPython ã¯ã„ã¾ã ã« :meth:`__getslice__` ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚ãªã®ã§ã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã§ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å®Ÿè£…ã™ã‚‹å ´åˆã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚)"

#: ../../reference/datamodel.rst:2007
msgid ""
"Called to implement evaluation of ``self[i:j]``. The returned object should "
"be of the same type as *self*.  Note that missing *i* or *j* in the slice "
"expression are replaced by zero or :attr:`sys.maxsize`, respectively.  If "
"negative indexes are used in the slice, the length of the sequence is added "
"to that index. If the instance does not implement the :meth:`__len__` "
"method, an :exc:`AttributeError` is raised. No guarantee is made that "
"indexes adjusted this way are not still negative.  Indexes which are greater"
" than the length of the sequence are not modified. If no "
":meth:`__getslice__` is found, a slice object is created instead, and passed"
" to :meth:`__getitem__` instead."
msgstr "``self[i:j]`` ã®å€¤è©•ä¾¡ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ *self* ã¨åŒã˜å‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã§ *i* ã‚„ *j* ãŒãªã„å ´åˆã«ã¯ã€ãã‚Œãã‚Œã‚¼ãƒ­ã‚„ :attr:`sys.maxsize` ã«ç½®ãæ›ãˆã‚‰ã‚Œã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã‚¹ãƒ©ã‚¤ã‚¹ã«è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ãŒç”¨ã„ã‚‰ã‚ŒãŸå ´åˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å€¤ã«åŠ ç®—ã•ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ :meth:`__len__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã„ãªã„å ´åˆã«ã¯ã€ :exc:`AttributeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®è¨ˆç®—ã®çµæœã€ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å€¤ãŒè² ã§ãªããªã‚‹ã¨ã„ã†ä¿è¨¼ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã‚ˆã‚Šã‚‚å¤§ããªã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å€¤ã¯ä¿®æ­£ã•ã‚Œã¾ã›ã‚“ã€‚ :meth:`__getslice__` ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ä»£ã‚ã‚Šã«ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã•ã‚Œã¦ :meth:`__getitem__` ã«æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2020
msgid ""
"Called to implement assignment to ``self[i:j]``. Same notes for *i* and *j* "
"as for :meth:`__getslice__`."
msgstr "``self[i:j]`` ã¸ã®ä»£å…¥ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ *i* ãŠã‚ˆã³ *j* ã«é–¢ã—ã¦ã¯ã€ :meth:`__getslice__` ã¨åŒã˜æ³¨é‡ˆãŒã‚ã¦ã¯ã¾ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2023
msgid ""
"This method is deprecated. If no :meth:`__setslice__` is found, or for "
"extended slicing of the form ``self[i:j:k]``, a slice object is created, and"
" passed to :meth:`__setitem__`, instead of :meth:`__setslice__` being "
"called."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ’¤å»ƒã•ã‚Œã¦ã„ã¾ã™ã€‚ :meth:`__setslice__` ãŒãªã„ã‹ã€ ``self[i:j:k]`` å½¢å¼ã®æ‹¡å¼µã‚¹ãƒ©ã‚¤ã‚¹ã®å ´åˆã«ã¯ã€ :meth:`__setslice__` ãŒå‘¼ã°ã‚Œã‚‹ä»£ã‚ã‚Šã«ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã•ã‚Œã€ :meth:`__setitem__` ã«æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2030
msgid ""
"Called to implement deletion of ``self[i:j]``. Same notes for *i* and *j* as"
" for :meth:`__getslice__`. This method is deprecated. If no "
":meth:`__delslice__` is found, or for extended slicing of the form "
"``self[i:j:k]``, a slice object is created, and passed to "
":meth:`__delitem__`, instead of :meth:`__delslice__` being called."
msgstr "``self[i:j]`` ã®å‰Šé™¤ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ *i* ãŠã‚ˆã³ *j* ã«é–¢ã—ã¦ã¯ã€ :meth:`__getslice__` ã¨åŒã˜æ³¨é‡ˆãŒã‚ã¦ã¯ã¾ã‚Šã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ’¤å»ƒã•ã‚Œã¦ã„ã¾ã™ã€‚ :meth:`__delslice__` ãŒãªã„ã‹ã€ ``self[i:j:k]`` å½¢å¼ã®æ‹¡å¼µã‚¹ãƒ©ã‚¤ã‚¹ã®å ´åˆã«ã¯ã€ :meth:`__delslice__` ãŒå‘¼ã°ã‚Œã‚‹ä»£ã‚ã‚Šã«ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã•ã‚Œã€ :meth:`__delitem__` ã«æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2036
msgid ""
"Notice that these methods are only invoked when a single slice with a single"
" colon is used, and the slice method is available.  For slice operations "
"involving extended slice notation, or in absence of the slice methods, "
":meth:`__getitem__`, :meth:`__setitem__` or :meth:`__delitem__` is called "
"with a slice object as argument."
msgstr "ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å˜ä¸€ã®ã‚³ãƒ­ãƒ³ã‚’ä½¿ã£ãŸå˜ä¸€ã®ã‚¹ãƒ©ã‚¤ã‚¹ã§ã€ã‹ã¤ã‚¹ãƒ©ã‚¤ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ãŒåˆ©ç”¨ã§ãã‚‹ã¨ãã«ã ã‘å‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚æ‹¡å¼µã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã‚’å«ã‚“ã§ã„ã‚‹ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã‚„ã€ã‚¹ãƒ©ã‚¤ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ãŒãªã„å ´åˆã€ :meth:`__getitem__` ã€ :meth:`__setitem__` ã€ã‚ã‚‹ã„ã¯ :meth:`__delitem__` ãŒã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼•æ•°ã¨ã—ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2042
msgid ""
"The following example demonstrate how to make your program or module "
"compatible with earlier versions of Python (assuming that methods "
":meth:`__getitem__`, :meth:`__setitem__` and :meth:`__delitem__` support "
"slice objects as arguments)::"
msgstr "ä»¥ä¸‹ã®ä¾‹ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã«å¯¾ã—ã¦äº’æ›æ€§ã‚’æŒãŸã›ã‚‹æ–¹æ³•ã‚’ç¤ºã—ãŸã‚‚ã®ã§ã™ (:meth:`__getitem__` ã€ :meth:`__setitem__` ã€ãŠã‚ˆã³ :meth:`__delitem__` ã¯å¼•æ•°ã¨ã—ã¦ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚‚ã®ã¨ä»®å®šã—ã¾ã™)::"

#: ../../reference/datamodel.rst:2067
msgid ""
"Note the calls to :func:`max`; these are necessary because of the handling "
"of negative indices before the :meth:`__\\*slice__` methods are called.  "
"When negative indexes are used, the :meth:`__\\*item__` methods receive them"
" as provided, but the :meth:`__\\*slice__` methods get a \"cooked\" form of "
"the index values.  For each negative index value, the length of the sequence"
" is added to the index before calling the method (which may still result in "
"a negative index); this is the customary handling of negative indexes by the"
" built-in sequence types, and the :meth:`__\\*item__` methods are expected "
"to do this as well.  However, since they should already be doing that, "
"negative indexes cannot be passed in; they must be constrained to the bounds"
" of the sequence before being passed to the :meth:`__\\*item__` methods. "
"Calling ``max(0, i)`` conveniently returns the proper value."
msgstr ":func:`max` ã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„; ã“ã®å‘¼ã³å‡ºã— :meth:`__\\*slice__` ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã•ã‚Œã‚‹å‰ã«ã€è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å€¤ã‚’å‡¦ç†ã—ã¦ãŠããŸã‚ã«å¿…è¦ã§ã™ã€‚è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å€¤ãŒä½¿ã‚ã‚ŒãŸå ´åˆã€ :meth:`__\\*item__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä¸ãˆã‚‰ã‚ŒãŸå€¤ã‚’ãã®ã¾ã¾ä½¿ã„ã¾ã™ãŒã€ :meth:`__\\*slice__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ \"èª¿ç†æ¸ˆã¿ã® (cooked)\" å½¢å¼ã«ãªã£ãŸã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å€¤ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å€¤ãŒä½¿ã‚ã‚Œã‚‹ã¨ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™å‰ã«ã€å¸¸ã«ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã‚’ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å€¤ã«åŠ ç®—ã—ã¾ã™ (åŠ ç®—ã—ã¦ã‚‚ã¾ã è² ã®å€¤ã¨ãªã£ã¦ã„ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“); ã“ã‚Œã¯ã€çµ„ã¿è¾¼ã¿ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã«ãŠã‘ã‚‹æ…£ç¿’çš„ãªè² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å‡¦ç†æ–¹æ³•ã§ã€ :meth:`__\\*item__` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚‚åŒæ§˜ã®å‡¦ç†ã‚’è¡Œã†ã‚ˆã†æœŸå¾…ã—ã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€ã“ã“ã§ã¯ã™ã§ã«è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å€¤ã®å‡¦ç†ã‚’è¡Œã£ã¦ã„ã‚‹ã®ã§ã€è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã‚’æ¸¡ã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“; ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å€¤ã¯ã€ :meth:`__\\*item__` ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã•ã‚Œã‚‹å‰ã«ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹é›†åˆã®å¢ƒç•Œã«åˆ¶é™ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ ``max(0, i)`` ã‚’å‘¼ã³å‡ºã›ã°ã€é©åˆ‡ãªå€¤ã‚’è¿”ã™ã®ã§ä¾¿åˆ©ã§ã™ã€‚"

#: ../../reference/datamodel.rst:2084
msgid "Emulating numeric types"
msgstr "æ•°å€¤å‹ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹"

#: ../../reference/datamodel.rst:2086
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of"
" number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr "ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã€æ•°å€¤å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ç‰¹å®šã®ç¨®é¡ã®æ•°å€¤å‹ã§ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã‚ˆã†ãªæ¼”ç®—ã«å¯¾å¿œã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ (éæ•´æ•°ã®æ•°å€¤ã«å¯¾ã™ã‚‹ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—ãªã©) ã¯ã€æœªå®šç¾©ã®ã¾ã¾ã«ã—ã¦ãŠã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2110
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, "
"``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to evaluate the "
"expression ``x + y``, where *x* is an instance of a class that has an "
":meth:`__add__` method, ``x.__add__(y)`` is called.  The :meth:`__divmod__` "
"method should be the equivalent to using :meth:`__floordiv__` and "
":meth:`__mod__`; it should not be related to :meth:`__truediv__` (described "
"below).  Note that :meth:`__pow__` should be defined to accept an optional "
"third argument if the ternary version of the built-in :func:`pow` function "
"is to be supported."
msgstr "ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€äºŒé …ç®—è¡“æ¼”ç®— (``+``, ``-``, ``*``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€å¼ ``x + y`` ã®å ´åˆã€ *x* ãŒ :meth:`__add__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚‚ã¤ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚Œã°ã€ ``x.__add__(y)`` ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ :meth:`__divmod__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ :meth:`__floordiv__` ã¨ :meth:`__mod__` ã‚’ä½¿ã£ãŸå ´åˆã¨ç­‰ä¾¡ã«ãªã‚‰ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; :meth:`__truediv__` (ä¸‹è¨˜å‚ç…§) ã¨é–¢é€£ã¥ã‘ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚çµ„ã¿è¾¼ã¿ã®ä¸‰é …æ¼”ç®—å­ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®é–¢æ•° :func:`pow` ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã«ã¯ã€ :meth:`__pow__` ã¯ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨ãªã‚‹ç¬¬ä¸‰ã®å¼•æ•°ã‚’å—ã‘å–ã‚Œãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2120
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr "ã“ã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒæ¸¡ã•ã‚ŒãŸå¼•ãæ•°ã«å¯¾ã™ã‚‹æ“ä½œã‚’æä¾›ã—ã¦ã„ãªã„å ´åˆã«ã¯ã€ ``NotImplemented`` ã‚’é€å‡ºã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2127
msgid ""
"The division operator (``/``) is implemented by these methods.  The "
":meth:`__truediv__` method is used when ``__future__.division`` is in "
"effect, otherwise :meth:`__div__` is used.  If only one of these two methods"
" is defined, the object will not support division in the alternate context; "
":exc:`TypeError` will be raised instead."
msgstr "é™¤ç®—æ¼”ç®— (``/``) ã¯ã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§å®Ÿç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚ :meth:`__truediv__` ã¯ã€ ``__future__.division`` ãŒæœ‰åŠ¹ã§ã‚ã‚‹ã¨ãã«ä½¿ã‚ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ :meth:`__div__` ãŒä½¿ã‚ã‚Œã¾ã™sã€‚äºŒã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ã†ã¡ä¸€æ–¹ã—ã‹å®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»–æ–¹ã®æ¼”ç®—ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ãªããªã‚Šã¾ã™; ã“ã®ã¨ãã€ :exc:`TypeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2153
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``/``, ``%``, :func:`divmod`, :func:`pow`, ``**``, "
"``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) operands.  "
"These functions are only called if the left operand does not support the "
"corresponding operation and the operands are of different types. [#]_ For "
"instance, to evaluate the expression ``x - y``, where *y* is an instance of "
"a class that has an :meth:`__rsub__` method, ``y.__rsub__(x)`` is called if "
"``x.__sub__(y)`` returns *NotImplemented*."
msgstr "ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯äºŒé …ç®—è¡“æ¼”ç®— (``+``, ``-``, ``*``, ``/``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) ã‚’å®Ÿç¾ã—ã¾ã™ãŒã€ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—ãŒè¡Œã‚ã‚Œã‚‹è¢«æ¼”ç®—å­ãŒé€†è»¢ã—ã¦ (reflected, swapped: å…¥ã‚Œæ›¿ãˆã‚‰ã‚Œã¦) ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ã€å·¦å´ã®è¢«æ¼”ç®—å­ãŒå¯¾å¿œã™ã‚‹æ¼”ç®—ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ãŠã‚‰ãšã‹ã¤ä¸¡è€…ã®æ¼”ç®—å­ãŒç•°ãªã‚‹å ´åˆã«ã®ã¿å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ [#]_ ä¾‹ãˆã°ã€ ``x - y`` ã®å¼ã‚’è©•ä¾¡ã™ã‚‹å ´åˆã€ *y* ãŒ :meth:`__rsub__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã£ã¦ã€ã—ã‹ã‚‚ ``x.__sub__(y)`` ãŒ *NotImplemented* ã‚’è¿”ã™å ´åˆã«ã¯ã€ ``y.__rsub__(x)`` ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2164
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr "ãŸã ã—ã€ä¸‰é …æ¼”ç®—å­ :func:`pow` ãŒ :meth:`__rpow__` ã‚’å‘¼ã¶ã“ã¨ã¯ãªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ (å‹å¼·åˆ¶ã®è¦å‰‡ãŒéå¸¸ã«é›£è§£ã«ãªã‚‹ã‹ã‚‰ã§ã™)ã€‚"

#: ../../reference/datamodel.rst:2169
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides the reflected method for the operation, this method "
"will be called before the left operand's non-reflected method.  This "
"behavior allows subclasses to override their ancestors' operations."
msgstr "å³å´ã®è¢«æ¼”ç®—å­ã®å‹ãŒå·¦å´ã®è¢«æ¼”ç®—å­ã®å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€ã“ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã«å¯¾ã™ã‚‹é€†è»¢ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯ã€å·¦å´ã®è¢«æ¼”ç®—å­ã®éé€†è»¢ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã‚‹å‰ã«ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã¾ã™ã€‚ã“ã®æŒ¯ã‚‹èˆã„ã«ã‚ˆã‚Šã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒè¦ªã®æ“ä½œã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2189
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``,"
" ``&=``, ``^=``, ``|=``).  These methods should attempt to do the operation "
"in-place (modifying *self*) and return the result (which could be, but does "
"not have to be, *self*).  If a specific method is not defined, the augmented"
" assignment falls back to the normal methods.  For instance, to execute the "
"statement ``x += y``, where *x* is an instance of a class that has an "
":meth:`__iadd__` method, ``x.__iadd__(y)`` is called.  If *x* is an instance"
" of a class that does not define a :meth:`__iadd__` method, ``x.__add__(y)``"
" and ``y.__radd__(x)`` are considered, as with the evaluation of ``x + y``."
msgstr "ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ç´¯ç®—ç®—è¡“ä»£å…¥ (augmented arithmetic assignments, ``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``) ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æ¼”ç®—ã‚’ãã®å ´ã§(*self* ã‚’å¤‰æ›´ã™ã‚‹å½¢ã§) è¡Œã†ã‚ˆã†è©¦ã¿ã€ãã®çµæœ(å¤‰æ›´ã•ã‚ŒãŸ *self* ã¾ãŸã¯ãã®ä»£ã‚ã‚Šã®ã‚‚ã®)ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ç‰¹å®šã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ãã®ç´¯ç®—ç®—è¡“æ¼”ç®—ã¯é€šå¸¸ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ä»£ç”¨ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ``x += y`` ã‚’è©•ä¾¡ã™ã‚‹éš›ã€ *x* ãŒ :meth:`__iadd__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚Œã°ã€ ``x.__iadd__(y)`` ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚é€†ã«ã€ *x* ãŒ :meth:`__iadd` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒãŸãªã„ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚Œã°ã€ ``x + y`` ã®è©•ä¾¡ã¨åŒã˜ã‚ˆã†ã« ``x.__add__(y)`` ãŠã‚ˆã³ ``y.__radd__(x)`` ã‚’è€ƒæ…®ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2208
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, "
":func:`abs` and ``~``)."
msgstr "å˜é …ç®—è¡“æ¼”ç®— (``-``, ``+``, :func:`abs` ãŠã‚ˆã³ ``~``) ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2223
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int`, "
":func:`long`, and :func:`float`.  Should return a value of the appropriate "
"type."
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•° :func:`complex`, :func:`int`, :func:`long`, ãŠã‚ˆã³ :func:`float` ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚é©åˆ‡ãªå‹ã®å€¤ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2234
msgid ""
"Called to implement the built-in functions :func:`oct` and :func:`hex`.  "
"Should return a string value."
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•° :func:`oct` ãŠã‚ˆã³ :func:`hex` ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚æ–‡å­—åˆ—å‹ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2240
msgid ""
"Called to implement :func:`operator.index`.  Also called whenever Python "
"needs an integer object (such as in slicing).  Must return an integer (int "
"or long)."
msgstr ":func:`operator.index` ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã¾ãŸã€ï¼ˆã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ï¼‰ã®ã‚ˆã†ã« Python ãŒæ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¿…è¦ã¨ã™ã‚‹å ´åˆã«ã¯ä½•å‡¦ã§ã‚‚å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚æ•´æ•°ï¼ˆint ã‚‚ã—ãã¯ longï¼‰ã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2248
msgid ""
"Called to implement \"mixed-mode\" numeric arithmetic.  Should either return"
" a 2-tuple containing *self* and *other* converted to a common numeric type,"
" or ``None`` if conversion is impossible.  When the common type would be the"
" type of ``other``, it is sufficient to return ``None``, since the "
"interpreter will also ask the other object to attempt a coercion (but "
"sometimes, if the implementation of the other type cannot be changed, it is "
"useful to do the conversion to the other type here).  A return value of "
"``NotImplemented`` is equivalent to returning ``None``."
msgstr "\"å‹æ··åˆãƒ¢ãƒ¼ãƒ‰ (mixed-mode)\" ã§ã®æ•°å€¤é–“ã®ç®—è¡“æ¼”ç®—ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ *self* ã¨ *other* ã‚’å…±é€šã®æ•°å€¤å‹ã«å¤‰æ›ã—ã¦ã€ 2 è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã«ã—ã¦è¿”ã™ã‹ã€ä¸å¯èƒ½ãªå ´åˆã«ã¯ ``None`` ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å…±é€šã®å‹ãŒ ``other`` ã®å‹ã«ãªã‚‹å ´åˆã€ ``None`` ã‚’è¿”ã™ã ã‘ã§ååˆ†ã§ã™ã€‚ã“ã®å ´åˆã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã‚‚ã†ä¸€æ–¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’èª¿ã¹ã¦å‹å¼·åˆ¶ã‚’è¡ŒãŠã†ã¨ã™ã‚‹ã‹ã‚‰ã§ã™ (ã¨ã¯ã„ãˆã€ã‚‚ã†ä¸€æ–¹ã®å€¤ã®å‹ãŒå®Ÿè£…ä¸Šå¤‰æ›´ã§ããªã„å ´åˆã«ã¯ã€ã“ã“ã§ *self* ã‚’ *other* ã®å‹ã«å¤‰æ›ã—ã¦ãŠã„ãŸæ–¹ãŒä¾¿åˆ©ã§ã™)ã€‚æˆ»ã‚Šå€¤ã« ``NotImplemented`` ã‚’ä½¿ã†ã®ã¯ã€ ``None`` ã‚’è¿”ã™ã®ã¨åŒã˜ã§ã™ã€‚"

#: ../../reference/datamodel.rst:2261
msgid "Coercion rules"
msgstr "å‹å¼·åˆ¶è¦å‰‡ (coercion rule)"

#: ../../reference/datamodel.rst:2263
msgid ""
"This section used to document the rules for coercion.  As the language has "
"evolved, the coercion rules have become hard to document precisely; "
"documenting what one version of one particular implementation does is "
"undesirable.  Instead, here are some informal guidelines regarding coercion."
"  In Python 3, coercion will not be supported."
msgstr "æœ¬ç¯€ã§ã¯ã€å‹å¼·åˆ¶ (coercion) ã«é–¢ã™ã‚‹è¦å‰‡ã«ã¤ã„ã¦è¨˜è¿°ã—ã¾ã™ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨€èªãŒé€²åŒ–ã™ã‚‹ã«ã¤ã‚Œã€å‹å¼·åˆ¶è¦å‰‡ã«ã¤ã„ã¦æ­£ç¢ºã«è¨˜è¿°ã™ã‚‹ã®ã¯é›£ã—ããªã£ã¦ã‚†ãã¾ã™; å¾“ã£ã¦ã€ã‚ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã‚ã‚‹å®Ÿè£…ã«ã¤ã„ã¦è¨˜è¿°ã™ã‚‹ã®ã¯æœ›ã¾ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚ãã®ä»£ã‚ã‚Šã«ã€å‹å¼·åˆ¶ã«é–¢ã™ã‚‹éå…¬å¼çš„ãªã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’ç¤ºã—ã¦ãŠãã¾ã™ã€‚ Python 3 ã‹ã‚‰ã¯ã€å‹å¼·åˆ¶ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œãªããªã‚‹äºˆå®šã§ã™ã€‚"

#: ../../reference/datamodel.rst:2271
msgid ""
"If the left operand of a % operator is a string or Unicode object, no "
"coercion takes place and the string formatting operation is invoked instead."
msgstr "% æ¼”ç®—å­ã®å·¦è¢«æ¼”ç®—å­ãŒæ–‡å­—åˆ—ã‹ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€å‹å¼·åˆ¶ã¯èµ·ããšã€æ–‡å­—åˆ—ã¨ã—ã¦ã®æ›¸å¼åŒ–æ“ä½œãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2276
msgid ""
"It is no longer recommended to define a coercion operation. Mixed-mode "
"operations on types that don't define coercion pass the original arguments "
"to the operation."
msgstr "å‹å¼·åˆ¶æ¼”ç®—ã®å®šç¾©ã¯ã‚‚ã¯ã‚„æ¨å¥¨ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚å‹å¼·åˆ¶ã‚’å®šç¾©ã—ã¦ã„ãªã„æ··åˆå‹ (mixed-mode) æ¼”ç®—ã¯ã€ã‚‚ã¨ã®å¼•æ•°ã‚’ãã®ã¾ã¾æ¼”ç®—æ“ä½œã«æ¸¡ã™ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2282
msgid ""
"New-style classes (those derived from :class:`object`) never invoke the "
":meth:`__coerce__` method in response to a binary operator; the only time "
":meth:`__coerce__` is invoked is when the built-in function :func:`coerce` "
"is called."
msgstr "æ–°ã—ã„å½¢å¼ã®ã‚¯ãƒ©ã‚¹ (:class:`object` ã‹ã‚‰æ´¾ç”Ÿã—ãŸã‚‚ã®) ãŒã€äºŒé …æ¼”ç®—å­ã«å¯¾ã—ã¦ :meth:`__coerce__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚; :meth:`__coerce__` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã®ã¯ã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`coerce` ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã ã‘ã§ã™ã€‚"

#: ../../reference/datamodel.rst:2289
msgid ""
"For most intents and purposes, an operator that returns ``NotImplemented`` "
"is treated the same as one that is not implemented at all."
msgstr "äº‹å®Ÿä¸Šã€ ``NotImplemented`` ã‚’è¿”ã™æ¼”ç®—å­ã¯ã€å…¨ãå®Ÿè£…ã•ã‚Œã¦ã„ãªã„ã‚‚ã®ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2294
msgid ""
"Below, :meth:`__op__` and :meth:`__rop__` are used to signify the generic "
"method names corresponding to an operator; :meth:`__iop__` is used for the "
"corresponding in-place operator.  For example, for the operator '``+``', "
":meth:`__add__` and :meth:`__radd__` are used for the left and right variant"
" of the binary operator, and :meth:`__iadd__` for the in-place variant."
msgstr "ä»¥ä¸‹ã®èª¬æ˜ã§ã¯ã€ :meth:`__op__` ãŠã‚ˆã³ :meth:`__rop__` ã¯ã€æ¼”ç®—å­ã«ç›¸å½“ã™ã‚‹ä¸€èˆ¬çš„ãªãƒ¡ã‚½ãƒƒãƒ‰åã‚’è¡¨ã™ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™; :meth:`__iop__` ã¯ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹æ¼”ç®—å­ã‚’è¡¨ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€æ¼”ç®—å­ '``+``' ã®å ´åˆã€ :meth:`__add__` ãŠã‚ˆã³ :meth:`__radd__` ãŒãã‚Œãã‚Œå·¦å³ã®è¢«æ¼”ç®—å­ç”¨ã®äºŒé …æ¼”ç®—å­ã¨ã—ã¦ä½¿ã‚ã‚Œã€ :meth:`__iadd__` ãŒã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹æ¼”ç®—ç”¨ã®æ¼”ç®—å­ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹ã€ã¨ã„ã£ãŸå…·åˆã§ã™ã€‚"

#: ../../reference/datamodel.rst:2302
msgid ""
"For objects *x* and *y*, first ``x.__op__(y)`` is tried.  If this is not "
"implemented or returns ``NotImplemented``, ``y.__rop__(x)`` is tried.  If "
"this is also not implemented or returns ``NotImplemented``, a "
":exc:`TypeError` exception is raised.  But see the following exception:"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *x* ãŠã‚ˆã³ *y* ã«å¯¾ã—ã¦ã€ã¾ãš ``x.__op__(y)`` ãŒè©¦ã•ã‚Œã¾ã™ã€‚ã“ã®æ¼”ç®—ãŒå®Ÿè£…ã•ã‚Œã¦ã„ãªã„ã‹ã€ ``NotImplemented`` ã‚’è¿”ã™å ´åˆã€æ¬¡ã« ``y.__rop__(x)`` ãŒè©¦ã•ã‚Œã¾ã™ã€‚ã“ã®æ¼”ç®—ã‚‚å®Ÿè£…ã•ã‚Œã¦ã„ãªã„ã‹ã€ ``NotImplemented`` ã‚’è¿”ã™ãªã‚‰ã€ :exc:`TypeError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ãŸã ã—ã€ä»¥ä¸‹ã®ä¾‹å¤–ãŒã‚ã‚‹ã®ã§å‚ç…§ã—ã¦ãã ã•ã„:"

#: ../../reference/datamodel.rst:2309
msgid ""
"Exception to the previous item: if the left operand is an instance of a "
"built-in type or a new-style class, and the right operand is an instance of "
"a proper subclass of that type or class and overrides the base's "
":meth:`__rop__` method, the right operand's :meth:`__rop__` method is tried "
"*before* the left operand's :meth:`__op__` method."
msgstr "å‰é …ã«å¯¾ã™ã‚‹ä¾‹å¤–: å·¦è¢«æ¼”ç®—å­ãŒçµ„ã¿è¾¼ã¿å‹ã‚„æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚Šã€ã‹ã¤å³è¢«æ¼”ç®—å­ãŒå·¦è¢«æ¼”ç®—å­ã¨åŒã˜ã‚¯ãƒ©ã‚¹ã‹é©åˆ‡ãªã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚Šã€ã•ã‚‰ã«è¦ªã‚¯ãƒ©ã‚¹ã® :meth:`__rop__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã—ã¦ã„ã‚‹å ´åˆã€å·¦è¢«æ¼”ç®—å­ã® :meth:`__op__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è©¦ã™ *å‰ã«* å³è¢«æ¼”ç®—å­ã® :meth:`__rop__` ãŒè©¦ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2315
msgid ""
"This is done so that a subclass can completely override binary operators. "
"Otherwise, the left operand's :meth:`__op__` method would always accept the "
"right operand: when an instance of a given class is expected, an instance of"
" a subclass of that class is always acceptable."
msgstr "ã“ã‚Œã¯ã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹å´ã§äºŒé …æ¼”ç®—å­ã‚’å®Œå…¨ã«ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã§ã™ã€‚ãã†ã—ãªã‘ã‚Œã°ã€å¸¸ã«å·¦è¢«æ¼”ç®—å­ã® :meth:`__op__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå³è¢«æ¼”ç®—å­ã‚’å—ç†ã—ã¦ã—ã¾ã„ã¾ã™: ã‚ã‚‹ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒè¢«æ¼”ç®—å­ã«ãªã‚‹ã¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚‚ã¾ãŸå—ç†å¯èƒ½ã ã‹ã‚‰ã§ã™ã€‚"

#: ../../reference/datamodel.rst:2322
msgid ""
"When either operand type defines a coercion, this coercion is called before "
"that type's :meth:`__op__` or :meth:`__rop__` method is called, but no "
"sooner.  If the coercion returns an object of a different type for the "
"operand whose coercion is invoked, part of the process is redone using the "
"new object."
msgstr "åŒæ–¹ã®è¢«æ¼”ç®—å­ãŒå‹å¼·åˆ¶ã‚’å®šç¾©ã—ã¦ã„ã‚‹å ´åˆã€å‹å¼·åˆ¶ã¯è¢«æ¼”ç®—å­ã®å‹ã® :meth:`__op__` ã‚„ :meth:`__rop__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹å‰ã«å‘¼ã³å‡ºã•ã‚Œã€ãã‚Œã‚ˆã‚Šæ—©ããªã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å‹å¼·åˆ¶ã®çµæœã€å‹å¼·åˆ¶ã‚’è¡Œã†ã“ã¨ã«ãªã£ãŸã„ãšã‚Œã®è¢«æ¼”ç®—å­ã¨ã‚‚ç•°ãªã‚‹å‹ãŒè¿”ã•ã‚ŒãŸå ´åˆã€è¿”ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ–°ãŸãªå‹ã‚’ä½¿ã£ã¦ã€ã“ã®éç¨‹ãŒéƒ¨åˆ†çš„ã«å†åº¦è¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2329
msgid ""
"When an in-place operator (like '``+=``') is used, if the left operand "
"implements :meth:`__iop__`, it is invoked without any coercion.  When the "
"operation falls back to :meth:`__op__` and/or :meth:`__rop__`, the normal "
"coercion rules apply."
msgstr "('``+=``' ã®ã‚ˆã†ãª) ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹å‹ã®æ¼”ç®—å­ã‚’ç”¨ã„ã‚‹éš›ã€å·¦è¢«æ¼”ç®—å­ãŒ :meth:`__iop__` ã‚’å®Ÿè£…ã—ã¦ã„ã‚Œã°ã€ :meth:`__iop__` ãŒå‘¼ã³å‡ºã•ã‚Œã€å‹å¼·åˆ¶ã¯ä¸€åˆ‡è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚æ¼”ç®—ãŒ :meth:`__op__` ã‹ã¤/ã¾ãŸã¯ :meth:`__rop__` ã«å¸°ç€ã—ãŸå ´åˆã€é€šå¸¸ã®å‹å¼·åˆ¶è¦å‰‡ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2336
msgid ""
"In ``x + y``, if *x* is a sequence that implements sequence concatenation, "
"sequence concatenation is invoked."
msgstr "``x + y`` ã«ãŠã„ã¦ã€ *x* ãŒçµåˆ (concatenation) æ¼”ç®—ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã‚ã‚Œã°ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®çµåˆãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2341
msgid ""
"In ``x * y``, if one operand is a sequence that implements sequence "
"repetition, and the other is an integer (:class:`int` or :class:`long`), "
"sequence repetition is invoked."
msgstr "``x * y`` ã«ãŠã„ã¦ã€ä¸€æ–¹ã®æ¼”ç®—å­ãŒç¹°ã‚Šè¿”ã— (repeat) æ¼”ç®—ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã‚ã‚Šã€ã‹ã¤ä»–æ–¹ãŒæ•´æ•° (:class:`int` ã¾ãŸã¯ :class:`long`) ã§ã‚ã‚‹å ´åˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ç¹°ã‚Šè¿”ã—ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2347
msgid ""
"Rich comparisons (implemented by methods :meth:`__eq__` and so on) never use"
" coercion.  Three-way comparison (implemented by :meth:`__cmp__`) does use "
"coercion under the same conditions as other binary operations use it."
msgstr "(:meth:`__eq__` ãªã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹) æ‹¡å¼µæ¯”è¼ƒã¯ã€æ±ºã—ã¦å‹å¼·åˆ¶ã‚’è¡Œã„ã¾ã›ã‚“ã€‚(:meth:`__cmp__` ã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹) ä¸‰å€¤æ¯”è¼ƒ (three-way comparison) ã¯ã€ä»–ã®äºŒé …æ¼”ç®—å­ã§è¡Œã‚ã‚Œã¦ã„ã‚‹ã®ã¨åŒã˜æ¡ä»¶ã§å‹å¼·åˆ¶ã‚’å—ã‘ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2353
msgid ""
"In the current implementation, the built-in numeric types :class:`int`, "
":class:`long`, :class:`float`, and :class:`complex` do not use coercion. All"
" these types implement a :meth:`__coerce__` method, for use by the built-in "
":func:`coerce` function."
msgstr "ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€çµ„ã¿è¾¼ã¿æ•°å€¤å‹ :class:`int`, :class:`long`, :class:`float` ãŠã‚ˆã³ :class:`complex` ã¯å‹å¼·åˆ¶ã‚’è¡Œã„ã¾ã›ã‚“; ã“ã‚Œã‚‰ã®å‹ã¯å…¨ã¦ã€é–¢æ•° :func:`coerce` ã‹ã‚‰åˆ©ç”¨ã™ã‚‹ãŸã‚ã® :meth:`__coerce__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2360
msgid ""
"The complex type no longer makes implicit calls to the :meth:`__coerce__` "
"method for mixed-type binary arithmetic operations."
msgstr "è¤‡ç´ æ•°å‹ã¯ã€å‹æ··åˆã®äºŒé …ç®—è¡“æ¼”ç®—ã« :meth:`__coerce__` ã‚’æš—ç¤ºçš„ã«å‘¼ã³å‡ºã•ãªããªã‚Šã¾ã—ãŸã€‚"

#: ../../reference/datamodel.rst:2367
msgid "With Statement Context Managers"
msgstr "withæ–‡ã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£"

#: ../../reference/datamodel.rst:2371
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be"
" established when executing a :keyword:`with` statement. The context manager"
" handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£(:dfn:`context manager`) ã¨ã¯ã€ :keyword:`with` æ–‡ã®å®Ÿè¡Œæ™‚ã«ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å®šç¾©ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¯ã€ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«å¿…è¦ãªå…¥ã‚Šå£ãŠã‚ˆã³å‡ºå£ã®å‡¦ç†ã‚’æ‰±ã„ã¾ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¯é€šå¸¸ã€ :keyword:`with` æ–‡ï¼ˆ :ref:`with` ã®ç« ã‚’å‚ç…§ï¼‰ã«ã‚ˆã‚Šèµ·å‹•ã•ã‚Œã¾ã™ãŒã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç›´æ¥å‘¼ã³å‡ºã™ã“ã¨ã§èµ·å‹•ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2382
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®ä»£è¡¨çš„ãªä½¿ã„æ–¹ã¨ã—ã¦ã¯ã€æ§˜ã€…ãªã‚°ãƒ­ãƒ¼ãƒãƒ«æƒ…å ±ã®ä¿å­˜ãŠã‚ˆã³æ›´æ–°ã€ãƒªã‚½ãƒ¼ã‚¹ã®ãƒ­ãƒƒã‚¯ã¨ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚ªãƒ¼ãƒ—ãƒ³ã¨ã‚¯ãƒ­ãƒ¼ã‚ºãªã©ãŒæŒ™ã’ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2385
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã«ã¤ã„ã¦ã®ã•ã‚‰ãªã‚‹æƒ…å ±ã«ã¤ã„ã¦ã¯ã€ :ref:`typecontextmanager` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:2390
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in"
" the :keyword:`as` clause of the statement, if any."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®ã®å…¥ã‚Šå£ã§å®Ÿè¡Œã•ã‚Œã‚‹å‡¦ç†ã§ã™ã€‚ :keyword:`with` æ–‡ã¯ã€æ–‡ã® :keyword:`as` ç¯€ã§è¦å®šã•ã‚ŒãŸå€¤ã‚’è¿”ã™ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2397
msgid ""
"Exit the runtime context related to this object. The parameters describe the"
" exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®å‡ºå£ã§å®Ÿè¡Œã•ã‚Œã‚‹å‡¦ç†ã§ã™ã€‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒçµ‚äº†ã—ãŸåŸå› ã¨ãªã£ãŸä¾‹å¤–ã«ã¤ã„ã¦èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒä¾‹å¤–ã‚’é€å‡ºã›ãšçµ‚äº†ã—ãŸå ´åˆã¯ã€å…¨ã¦ã®å¼•ãæ•°ã« :const:`None` ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2401
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception"
" (i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr "ã‚‚ã—ã€ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã€ã‹ã¤ãƒ¡ã‚½ãƒƒãƒ‰ãŒä¾‹å¤–ã‚’æŠ‘åˆ¶ã—ãŸã„å ´åˆï¼ˆã™ãªã‚ã¡ã€ä¾‹å¤–ãŒä¼æ’­ã•ã‚Œã‚‹ã®ã‚’é˜²ããŸã„å ´åˆï¼‰ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ True ã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®çµ‚äº†å¾Œã€ä¾‹å¤–ã¯é€šå¸¸é€šã‚Šä¼æ’­ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2405
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ":meth:`__exit__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å—ã‘å–ã£ãŸä¾‹å¤–ã‚’å†åº¦é€å‡ºã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€å‘¼ã³å‡ºã—å´ã®è²¬ä»»ã§ãŠã“ãªã£ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:2412
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆ"

#: ../../reference/datamodel.rst:2412
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python ã® :keyword:`with` æ–‡ã®ä»•æ§˜ã€èƒŒæ™¯ã€ãŠã‚ˆã³ä¾‹ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2419
msgid "Special method lookup for old-style classes"
msgstr "æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã®ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰æ¤œç´¢"

#: ../../reference/datamodel.rst:2421
msgid ""
"For old-style classes, special methods are always looked up in exactly the "
"same way as any other method or attribute. This is the case regardless of "
"whether the method is being looked up explicitly as in ``x.__getitem__(i)`` "
"or implicitly as in ``x[i]``."
msgstr "æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã«ãŠã„ã¦ã€ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã¯å¸¸ã«ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚„å±æ€§ã¨åŒã˜æ–¹æ³•ã§æ¤œç´¢ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ãŒ ``x.__getitem__(i)`` ã®ã‚ˆã†ã«æ˜ç¤ºçš„ã«æ¤œç´¢ã•ã‚ŒãŸæ™‚ã‚‚ã€ ``x[i]`` ã®ã‚ˆã†ã«æš—é»™çš„ã«æ¤œç´¢ã•ã‚ŒãŸæ™‚ã‚‚åŒã˜ã§ã™ã€‚"

#: ../../reference/datamodel.rst:2426
msgid ""
"This behaviour means that special methods may exhibit different behaviour "
"for different instances of a single old-style class if the appropriate "
"special attributes are set differently::"
msgstr "ã“ã‚Œã«ã‚ˆã‚Šã€1ã¤ã®æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã®ç•°ãªã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã€ãã‚Œãã‚Œåˆ¥ã®é©åˆ‡ãªç‰¹æ®Šå±æ€§ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã€ç•°ãªã‚‹å‹•ä½œã‚’ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ ::"

#: ../../reference/datamodel.rst:2446
msgid "Special method lookup for new-style classes"
msgstr "æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã®ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰æ¤œç´¢"

#: ../../reference/datamodel.rst:2448
msgid ""
"For new-style classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception (unlike the equivalent example with old-"
"style classes)::"
msgstr "æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã§ã¯ã€ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã®æš—é»™çš„ãªå‘¼ã³å‡ºã—ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è¾æ›¸ã§ã¯ãªãã€ type ã®è¾æ›¸ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã¨ãã«ã®ã¿æ­£ã—ãå‹•ä½œã™ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚ã“ã®å‹•ä½œã¯ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ãŒ(æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã®åŒç­‰ãªä¾‹ã¨ç•°ãªã‚Š)ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹ç†ç”±ã§ã™ã€‚ ::"

#: ../../reference/datamodel.rst:2463
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`__hash__` and :meth:`__repr__` that are implemented by all "
"objects, including type objects. If the implicit lookup of these methods "
"used the conventional lookup process, they would fail when invoked on the "
"type object itself::"
msgstr "ã“ã®å‹•ä½œã®èƒŒæ™¯ã¨ãªã‚‹ç†ç”±ã¯ã€ :meth:`__hash__` ã¨ :meth:`__repr__` ã¨ã„ã£ãŸ type ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å«ã‚€ã™ã¹ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®æš—é»™ã®æ¤œç´¢ãŒé€šå¸¸ã®æ¤œç´¢ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½¿ã£ãŸå ´åˆã€ type ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã«å¯¾ã—ã¦å®Ÿè¡Œã•ã‚ŒãŸã¨ãã«å¤±æ•—ã—ã¦ã—ã¾ã„ã¾ã™::"

#: ../../reference/datamodel.rst:2476
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is"
" sometimes referred to as 'metaclass confusion', and is avoided by bypassing"
" the instance when looking up special methods::"
msgstr "ã‚¯ãƒ©ã‚¹ã®éçµåˆãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã“ã®ã‚ˆã†ã«ã—ã¦å®Ÿè¡Œã—ã‚ˆã†ã¨ã™ã‚‹ã“ã¨ã¯ã€'metaclass confusion' ã¨å‘¼ã°ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Šã€ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ¤œç´¢ã™ã‚‹ã¨ãã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ãƒã‚¤ãƒ‘ã‚¹ã™ã‚‹ã“ã¨ã§å›é¿ã•ã‚Œã¾ã™::"

#: ../../reference/datamodel.rst:2485
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the "
":meth:`__getattribute__` method even of the object's metaclass::"
msgstr "æ­£ç¢ºæ€§ã®ãŸã‚ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ã®ã«åŠ ãˆã¦ã€ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰æ¤œç´¢ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã‚’å«ã‚ã¦ã€ :meth:`__getattribute__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ãƒã‚¤ãƒ‘ã‚¹ã—ã¾ã™::"

#: ../../reference/datamodel.rst:2512
msgid ""
"Bypassing the :meth:`__getattribute__` machinery in this fashion provides "
"significant scope for speed optimisations within the interpreter, at the "
"cost of some flexibility in the handling of special methods (the special "
"method *must* be set on the class object itself in order to be consistently "
"invoked by the interpreter)."
msgstr "ã“ã®ã‚ˆã†ã« :meth:`__getattribute__` æ©Ÿæ§‹ã‚’ãƒã‚¤ãƒ‘ã‚¹ã™ã‚‹ã“ã¨ã§ã€ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã®æ‰±ã„ã«é–¢ã™ã‚‹ã‚ã‚‹ç¨‹åº¦ã®è‡ªç”±åº¦ã¨å¼•ãæ›ãˆã« (ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‹ã‚‰ä¸€è²«ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã«ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¨­å®š *ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„*)ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã‚’é«˜é€ŸåŒ–ã™ã‚‹ãŸã‚ã®å¤§ããªä½™åœ°ãŒæ‰‹ã«å…¥ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2520
msgid "Footnotes"
msgstr "æ³¨è¨˜"

#: ../../reference/datamodel.rst:2521
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr "ç‰¹å®šã®æ¡ä»¶ãŒæº€ãŸã•ã‚ŒãŸå ´åˆã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® type ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒ *ã§ãã¾ã™* ã€‚ã“ã‚Œã¯ã€æ­£ã—ãæ‰±ã‚ã‚Œãªã‹ã£ãŸå ´åˆã«ã¨ã¦ã‚‚å¥‡å¦™ãªå‹•ä½œã‚’å¼•ãèµ·ã“ã™ã®ã§ã€ä¸€èˆ¬çš„ã«ã¯è‰¯ã„è€ƒãˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2525
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method (such as :meth:`__add__`) fails the operation is not supported, which"
" is why the reflected method is not called."
msgstr "åŒã˜å‹ã®æ“ä½œã«å¯¾ã—ã¦ã¯ã€(:meth:`__add__` ã®ã‚ˆã†ãª)é€†è»¢ã§ããªã„ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¤±æ•—ã—ãŸæ™‚ã¨åŒã˜ã‚ˆã†ãªæƒ³å®šã®ã‚‚ã¨å‡¦ç†ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€é€†è»¢ã—ãŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ããªã„ã‹ã‚‰ã§ã™ã€‚"
