# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Osamu NAKAMURA, 2021
# 渋川よしき <yoshiki@shibu.jp>, 2021
# mollinaca, 2022
# 秘湯 <xwhhsprings@gmail.com>, 2023
# Masato HASHIMOTO <cabezon.hashimoto@gmail.com>, 2023
# Arihiro TAKASE, 2023
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2023
# souma987, 2023
# tomo, 2023
# Takanori Suzuki <takanori@takanory.net>, 2024
# 石井明久, 2024
# Takeshi Nakazato, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-06 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:19+0000\n"
"Last-Translator: Takeshi Nakazato, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr "データモデル"

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "オブジェクト、値、および型"

#: ../../reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer\", code is also represented by objects.)"
msgstr ""
"Python における :dfn:`オブジェクト (object)` とは、データを抽象的に表したもの"
"です。Python プログラムにおけるデータは全て、オブジェクトまたはオブジェクト間"
"の関係として表されます。(ある意味では、プログラムコードもまたオブジェクトとし"
"て表されます。これはフォン・ノイマン: Von Neumann の \"プログラム記憶方式コン"
"ピュータ: stored program computer\" のモデルに適合します。)"

#: ../../reference/datamodel.rst:35
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The :keyword:`is` operator compares the identity of two "
"objects; the :func:`id` function returns an integer representing its "
"identity."
msgstr ""
"すべてのオブジェクトは、同一性 (identity)、型、値をもっています。 *同一性* は"
"生成されたあとは変更されません。これはオブジェクトのアドレスのようなものだと"
"考えられるかもしれません。 :keyword:`is` 演算子は2つのオブジェクトの同一性を"
"比較します。 :func:`id` 関数は同一性を表す整数を返します。"

#: ../../reference/datamodel.rst:42
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr ""
"CPython では、``id(x)`` は ``x`` が格納されているメモリ上のアドレスを返しま"
"す。"

#: ../../reference/datamodel.rst:44
msgid ""
"An object's type determines the operations that the object supports (e.g., "
"\"does it have a length?\") and also defines the possible values for objects "
"of that type.  The :func:`type` function returns an object's type (which is "
"an object itself).  Like its identity, an object's :dfn:`type` is also "
"unchangeable. [#]_"
msgstr ""
"オブジェクトの型はオブジェクトがサポートする操作 (例: :func:`len` をサポート"
"するか) と、オブジェクトが取りうる値を決定します。 :func:`type` 関数はオブ"
"ジェクトの型 (型自体もオブジェクトです) を返します。同一性と同じく、オブジェ"
"クトの型(:dfn:`type`) も変更不可能です。 [#]_"

#: ../../reference/datamodel.rst:50
msgid ""
"The *value* of some objects can change.  Objects whose value can change are "
"said to be *mutable*; objects whose value is unchangeable once they are "
"created are called *immutable*. (The value of an immutable container object "
"that contains a reference to a mutable object can change when the latter's "
"value is changed; however the container is still considered immutable, "
"because the collection of objects it contains cannot be changed.  So, "
"immutability is not strictly the same as having an unchangeable value, it is "
"more subtle.) An object's mutability is determined by its type; for "
"instance, numbers, strings and tuples are immutable, while dictionaries and "
"lists are mutable."
msgstr ""
"オブジェクトによっては *値* を変更することが可能です。値を変更できるオブジェ"
"クトのことを *mutable* と呼びます。生成後に値を変更できないオブジェクトのこと"
"を *immutable* と呼びます。(mutable なオブジェクトへの参照を格納している "
"immutableなコンテナオブジェクトの値は、その格納しているオブジェクトの値が変化"
"した時に変化しますが、コンテナがどのオブジェクトを格納しているのかが変化しな"
"いのであれば immutable だと考えることができます。したがって、immutable かどう"
"かは値が変更可能かどうかと完全に一致するわけではありません) オブジェクトが "
"mutable かどうかはその型によって決まります。例えば、数値型、文字列型とタプル"
"型のインスタンスは immutable で、dict や list は mutable です。"

#: ../../reference/datamodel.rst:65
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""
"オブジェクトを明示的に破壊することはできません; しかし、オブジェクトに到達不"
"能 (unreachable) になると、ガベージコレクション (garbage-collection) によって"
"処理されるかもしれません。ガベージコレクションを遅らせたり、全く行わない実装"
"も許されています --- 到達可能なオブジェクトを処理してしまわないかぎり、ガベー"
"ジコレクションをどう実装するかは実装品質の問題です。"

#: ../../reference/datamodel.rst:73
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (so you "
"should always close files explicitly)."
msgstr ""
"現在の CPython 実装では参照カウント (reference-counting) 方式を使っており、"
"(オプションとして) 循環参照を行っているガベージオブジェクトを遅延検出します。"
"この実装ではほとんどのオブジェクトを到達不能になると同時に処理することができ"
"ますが、循環参照を含むガベージオブジェクトの収集が確実に行われるよう保証して"
"いるわけではありません。循環参照を持つガベージオブジェクト収集の制御について"
"は、 :mod:`gc` モジュールを参照してください。 CPython以外の実装は別の方式を"
"使っており、CPythonも将来は別の方式を使うかもしれません。オブジェクトが到達不"
"能になったときに即座に終了処理されることに頼らないでください (ですからファイ"
"ルは必ず明示的に閉じてください)。"

#: ../../reference/datamodel.rst:82
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a :keyword:`try`...\\ :keyword:`except` statement "
"may keep objects alive."
msgstr ""

#: ../../reference/datamodel.rst:87
msgid ""
"Some objects contain references to \"external\" resources such as open files "
"or windows.  It is understood that these resources are freed when the object "
"is garbage-collected, but since garbage collection is not guaranteed to "
"happen, such objects also provide an explicit way to release the external "
"resource, usually a :meth:`!close` method. Programs are strongly recommended "
"to explicitly close such objects.  The :keyword:`try`...\\ :keyword:"
"`finally` statement and the :keyword:`with` statement provide convenient "
"ways to do this."
msgstr ""

#: ../../reference/datamodel.rst:97
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk "
"about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"他のオブジェクトに対する参照をもつオブジェクトもあります; これらは *コンテナ "
"(container)* と呼ばれます。コンテナオブジェクトの例として、タプル、リスト、お"
"よび辞書が挙げられます。オブジェクトへの参照自体がコンテナの値の一部です。ほ"
"とんどの場合、コンテナの値というと、コンテナに入っているオブジェクトの値のこ"
"とを指し、それらオブジェクトのアイデンティティではありません; しかしながら、"
"コンテナの変更可能性について述べる場合、今まさにコンテナに入っているオブジェ"
"クトのアイデンティティのことを指します。したがって、 (タプルのように) 変更不"
"能なオブジェクトが変更可能なオブジェクトへの参照を含む場合、その値が変化する"
"のは変更可能なオブジェクトが変更された時、ということになります。"

#: ../../reference/datamodel.rst:106
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed. For example, after ``a = 1; b = 1``, *a* and *b* may or may not "
"refer to the same object with the value one, depending on the "
"implementation. This is because :class:`int` is an immutable type, so the "
"reference to ``1`` can be reused. This behaviour depends on the "
"implementation used, so should not be relied upon, but is something to be "
"aware of when making use of object identity tests. However, after ``c = []; "
"d = []``, *c* and *d* are guaranteed to refer to two different, unique, "
"newly created empty lists. (Note that ``e = f = []`` assigns the *same* "
"object to both *e* and *f*.)"
msgstr ""

#: ../../reference/datamodel.rst:124
msgid "The standard type hierarchy"
msgstr "標準型の階層"

#: ../../reference/datamodel.rst:133
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the "
"type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.), although such additions will often be provided via the "
"standard library instead."
msgstr ""
"以下は Python に組み込まれている型のリストです。(実装によって、C、Java、また"
"はその他の言語で書かれた) 拡張モジュールで、その他の型が定義されていることが"
"あります。新たな型 (有理数や、整数を効率的に記憶する配列、など) の追加は、た"
"いてい標準ライブラリを通して提供されますが、将来のバージョンの Python では、"
"型の階層構造にこのような追加がなされるかもしれません。"

#: ../../reference/datamodel.rst:144
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation "
"and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""
"以下に説明する型のいくつかには、 '特殊属性 (special attribute)' を列挙した段"
"落があります。これらの属性は実装へのアクセス手段を提供するもので、一般的な用"
"途に利用するためのものではありません。特殊属性の定義は将来変更される可能性が"
"あります。"

#: ../../reference/datamodel.rst:150 ../../reference/datamodel.rst:152
msgid "None"
msgstr "None"

#: ../../reference/datamodel.rst:154
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from "
"functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在"
"しません。このオブジェクトは組み込み名 ``None`` でアクセスされます。このオブ"
"ジェクトは、様々な状況で値が存在しないことをしめします。例えば、明示的に値を"
"返さない関数は ``None`` を返します。 ``None`` の真値 (truth value) は偽 "
"(false) です。"

#: ../../reference/datamodel.rst:161 ../../reference/datamodel.rst:163
msgid "NotImplemented"
msgstr "NotImplemented"

#: ../../reference/datamodel.rst:165
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name :data:`NotImplemented`. "
"Numeric methods and rich comparison methods should return this value if they "
"do not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  It should not be evaluated in a boolean context."
msgstr ""

#: ../../reference/datamodel.rst:172
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr ""
"詳細は :ref:`implementing-the-arithmetic-operations` を参照してください。"

#: ../../reference/datamodel.rst:176
msgid ""
"Evaluating :data:`NotImplemented` in a boolean context is deprecated. While "
"it currently evaluates as true, it will emit a :exc:`DeprecationWarning`. It "
"will raise a :exc:`TypeError` in a future version of Python."
msgstr ""

#: ../../reference/datamodel.rst:183 ../../reference/datamodel.rst:184
msgid "Ellipsis"
msgstr "Ellipsis"

#: ../../reference/datamodel.rst:188
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""
"この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在"
"しません。このオブジェクトはリテラル ``...`` またはPythonで決められている名"
"前 ``Ellipsis`` でアクセスされます。真理値は真 (true)です。"

#: ../../reference/datamodel.rst:194
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../../reference/datamodel.rst:198
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable; "
"once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""
"数値リテラルによって作成されたり、算術演算や組み込みの算術関数によって返され"
"るオブジェクトです。数値オブジェクトは変更不能です; 一度値が生成されると、二"
"度と変更されることはありません。Python の数値オブジェクトはいうまでもなく数学"
"で言うところの数値と強く関係していますが、コンピュータ内で数値を表現する際に"
"伴う制限を受けています。"

#: ../../reference/datamodel.rst:204
msgid ""
"The string representations of the numeric classes, computed by :meth:"
"`~object.__repr__` and :meth:`~object.__str__`, have the following "
"properties:"
msgstr ""
":meth:`~object.__repr__`  と :meth:`~object.__str__` から計算された数値クラス"
"の文字列表現には次のような特性があります:"

#: ../../reference/datamodel.rst:208
msgid ""
"They are valid numeric literals which, when passed to their class "
"constructor, produce an object having the value of the original numeric."
msgstr ""
"その文字列は、クラスコンストラクタに渡したときに、元の数値の値を持つオブジェ"
"クトを生成する有効な数値リテラルです。"

#: ../../reference/datamodel.rst:212
msgid "The representation is in base 10, when possible."
msgstr "できるなら、10を底として表現されます。"

#: ../../reference/datamodel.rst:214
msgid ""
"Leading zeros, possibly excepting a single zero before a decimal point, are "
"not shown."
msgstr "小数点の前にある 1 つのゼロを除いて、上に連なるゼロは表示されません。"

#: ../../reference/datamodel.rst:217
msgid ""
"Trailing zeros, possibly excepting a single zero after a decimal point, are "
"not shown."
msgstr "小数点の後にある 1 つのゼロを除いて、下に連なるゼロは表示されません。"

#: ../../reference/datamodel.rst:220
msgid "A sign is shown only when the number is negative."
msgstr "符号は数値が負数のときのみ表示されます。"

#: ../../reference/datamodel.rst:222
msgid ""
"Python distinguishes between integers, floating-point numbers, and complex "
"numbers:"
msgstr ""

#: ../../reference/datamodel.rst:227
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral` (整数)"

#: ../../reference/datamodel.rst:231
msgid ""
"These represent elements from the mathematical set of integers (positive and "
"negative)."
msgstr ""
"整数型は、整数(正の数および負の数)を表す数学的集合内における要素を表現する型"
"です。"

#: ../../reference/datamodel.rst:237
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers."
msgstr ""
"整数表現に関する規則は、負の整数を含むシフト演算やマスク演算において、最も有"
"意義な解釈ができるように意図されています。"

#: ../../reference/datamodel.rst:240
msgid "There are two types of integers:"
msgstr "整数には 2 種類あります:"

#: ../../reference/datamodel.rst:242
msgid "Integers (:class:`int`)"
msgstr "整数 (:class:`int`)"

#: ../../reference/datamodel.rst:243
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""
"無制限の範囲の数を表現しますが、利用可能な (仮想) メモリサイズの制限のみを受"
"けます。シフト演算やマスク演算のために2進数表現を持つと想定されます。負の数は"
"符号ビットが左に無限に延びているような錯覚を与える 2 の補数表現の変型で表され"
"ます。"

#: ../../reference/datamodel.rst:249
msgid "Booleans (:class:`bool`)"
msgstr "ブール値 (:class:`bool`)"

#: ../../reference/datamodel.rst:255
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects. "
"The Boolean type is a subtype of the integer type, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception "
"being that when converted to a string, the strings ``\"False\"`` or "
"``\"True\"`` are returned, respectively."
msgstr ""
"真偽値の False と True を表します。``False`` と ``True`` を表す 2 つのオブ"
"ジェクトのみがブール値オブジェクトです。ブール型は整数型の派生型であり、ほと"
"んどの状況でそれぞれ 0 と 1 のように振る舞いますが、例外として文字列に変換さ"
"れたときはそれぞれ ``\"False\"`` および ``\"True\"`` という文字列が返されま"
"す。"

#: ../../reference/datamodel.rst:263
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`) (実数)"

#: ../../reference/datamodel.rst:271
msgid ""
"These represent machine-level double precision floating-point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does "
"not support single-precision floating-point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to "
"complicate the language with two kinds of floating-point numbers."
msgstr ""

#: ../../reference/datamodel.rst:281
msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ":class:`numbers.Complex` (:class:`complex`)"

#: ../../reference/datamodel.rst:287
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating-point numbers.  The same caveats apply as for floating-point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""

#: ../../reference/datamodel.rst:294
msgid "Sequences"
msgstr "シーケンス型 (sequence)"

#: ../../reference/datamodel.rst:303
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``. Some "
"sequences, including built-in sequences, interpret negative subscripts by "
"adding the sequence length. For example, ``a[-2]`` equals ``a[n-2]``, the "
"second to last item of sequence a with length ``n``."
msgstr ""

#: ../../reference/datamodel.rst:313
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type. The comment above about negative indexes also "
"applies to negative slice positions."
msgstr ""

#: ../../reference/datamodel.rst:318
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"シーケンスによっては、第三の \"ステップ (step)\" パラメタを持つ \"拡張スライ"
"ス (extended slice)\" もサポートしています: ``a[i:j:k]`` は、 ``x = i + "
"n*k``, *n* ``>=`` ``0`` かつ *i* ``<=`` *x* ``<`` *j* であるようなインデクス "
"*x* を持つような *a* 全ての要素を選択します。"

#: ../../reference/datamodel.rst:322
msgid "Sequences are distinguished according to their mutability:"
msgstr "シーケンスは、変更可能なものか、そうでないかで区別されています:"

#: ../../reference/datamodel.rst:326
msgid "Immutable sequences"
msgstr "変更不能なシーケンス (immutable sequence)"

#: ../../reference/datamodel.rst:332
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may "
"be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""
"変更不能なシーケンス型のオブジェクトは、一度生成されるとその値を変更すること"
"ができません。 (オブジェクトに他のオブジェクトへの参照が入っている場合、参照"
"されているオブジェクトは変更可能なオブジェクトでもよく、その値は変更される可"
"能性があります; しかし、変更不能なオブジェクトが直接参照しているオブジェクト"
"の集合自体は、変更することができません。)"

#: ../../reference/datamodel.rst:337
msgid "The following types are immutable sequences:"
msgstr "以下の型は変更不能なシーケンス型です:"

#: ../../reference/datamodel.rst:342
msgid "Strings"
msgstr "文字列型 (string)"

#: ../../reference/datamodel.rst:350
msgid ""
"A string is a sequence of values that represent Unicode code points. All the "
"code points in the range ``U+0000 - U+10FFFF`` can be represented in a "
"string.  Python doesn't have a :c:expr:`char` type; instead, every code "
"point in the string is represented as a string object with length ``1``.  "
"The built-in function :func:`ord` converts a code point from its string form "
"to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an integer "
"in the range ``0 - 10FFFF`` to the corresponding length ``1`` string "
"object. :meth:`str.encode` can be used to convert a :class:`str` to :class:"
"`bytes` using the given text encoding, and :meth:`bytes.decode` can be used "
"to achieve the opposite."
msgstr ""
"文字列はUnicodeコードポイントを表現する値の配列です。文字列中のどのコードポイ"
"ントも ``U+0000 - U+10FFFF`` の範囲で表現されることができます。Pythonは :c:"
"expr:`char` 型を持ちません。代わりに、文字列中のどのコードポイントも長さ "
"''1'' の文字列オブジェクトとして表現することができます。組み込み関数 :func:"
"`ord` は文字列形式を ``U+0000 - U+10FFFF`` の範囲の整数に変換します。また、組"
"み込み関数 :func:`chr` は ``0 - 10FFFF`` の範囲の整数を対応する長さ ``1`` の"
"文字列に変換します。:meth:`str.encode` はテキストエンコーディングを使うこと"
"で :class:`str` を :class:`bytes` に変換するために使うことができます。また、:"
"meth:`bytes.decode` によりその逆が実行することができます。"

#: ../../reference/datamodel.rst:362
msgid "Tuples"
msgstr "タプル型 (tuple)"

#: ../../reference/datamodel.rst:368
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""
"タプルの要素は任意の Python オブジェクトです。二つ以上の要素からなるタプル"
"は、個々の要素を表現する式をカンマで区切って構成します。単一の要素からなるタ"
"プル (単集合 'singleton') を作るには、要素を表現する式の直後にカンマをつけま"
"す (単一の式だけではタプルを形成しません。これは、式をグループ化するのに丸括"
"弧を使えるようにしなければならないからです)。要素の全くない丸括弧の対を作ると"
"空のタプルになります。"

#: ../../reference/datamodel.rst:375
msgid "Bytes"
msgstr "bytes"

#: ../../reference/datamodel.rst:378
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes` constructor can be used to create "
"bytes objects.  Also, bytes objects can be decoded to strings via the :meth:"
"`~bytes.decode` method."
msgstr ""

#: ../../reference/datamodel.rst:386
msgid "Mutable sequences"
msgstr "変更可能なシーケンス型 (mutable sequence)"

#: ../../reference/datamodel.rst:395
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and :keyword:"
"`del` (delete) statements."
msgstr ""
"変更可能なシーケンスは、作成した後で変更することができます。変更可能なシーケ"
"ンスでは、添字表記やスライス表記を使って指定された要素に代入を行うことがで"
"き、 :keyword:`del` (delete) 文を使って要素を削除することができます。"

#: ../../reference/datamodel.rst:403
msgid ""
"The :mod:`collections` and :mod:`array` module provide additional examples "
"of mutable sequence types."
msgstr ""

#: ../../reference/datamodel.rst:406
msgid "There are currently two intrinsic mutable sequence types:"
msgstr ""
"Python に最初から組み込まれている変更可能なシーケンス型は、今のところ二つで"
"す:"

#: ../../reference/datamodel.rst:408
msgid "Lists"
msgstr "リスト型 (list)"

#: ../../reference/datamodel.rst:411
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that "
"there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"リストの要素は任意の Python オブジェクトにできます。リストは、角括弧の中にカ"
"ンマで区切られた式を並べて作ります。 (長さが 0 や 1 のシーケンスを作るために"
"特殊な場合分けは必要ないことに注意してください。)"

#: ../../reference/datamodel.rst:415
msgid "Byte Arrays"
msgstr "バイト配列"

#: ../../reference/datamodel.rst:418
msgid ""
"A bytearray object is a mutable array. They are created by the built-in :"
"func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"bytearray オブジェクトは変更可能な配列です。組み込みの :func:`bytearray` コン"
"ストラクタによって作成されます。変更可能なことを除けば (つまりハッシュ化でき"
"ない)、 byte array は変更不能な :class:`bytes` オブジェクトと同じインター"
"フェースと機能を提供します。"

#: ../../reference/datamodel.rst:425
msgid "Set types"
msgstr "集合型"

#: ../../reference/datamodel.rst:431
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated "
"over, and the built-in function :func:`len` returns the number of items in a "
"set. Common uses for sets are fast membership testing, removing duplicates "
"from a sequence, and computing mathematical operations such as intersection, "
"union, difference, and symmetric difference."
msgstr ""
"集合型は、順序のない、ユニークで不変なオブジェクトの有限集合を表現します。そ"
"のため、(配列の)添字を使ったインデックスアクセスはできません。ただし、イテ"
"レートは可能で、組み込み関数 :func:`len` は集合の要素数を返します。集合型の一"
"般的な使い方は、集合に属しているかの高速なテスト、シーケンスからの重複の排"
"除、共通集合・和集合・差・対称差といった数学的な演算の計算です。"

#: ../../reference/datamodel.rst:438
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""
"集合の要素には、辞書のキーと同じ普遍性に関するルールが適用されます。数値型は"
"通常の数値比較のルールに従うことに注意してください。もし2つの数値の比較結果が"
"同値である(例えば、 ``1`` と ``1.0``)なら、そのうちの1つのみを集合に含めるこ"
"とができます。"

#: ../../reference/datamodel.rst:443
msgid "There are currently two intrinsic set types:"
msgstr "現在、2つの組み込み集合型があります:"

#: ../../reference/datamodel.rst:446
msgid "Sets"
msgstr "集合型"

#: ../../reference/datamodel.rst:449
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as :meth:"
"`~set.add`."
msgstr ""
"可変な集合型です。組み込みの :func:`set` コンストラクタで作成され、後から :"
"meth:`~set.add` などのいくつかのメソッドで更新できます。"

#: ../../reference/datamodel.rst:454
msgid "Frozen sets"
msgstr "Frozen set 型"

#: ../../reference/datamodel.rst:457
msgid ""
"These represent an immutable set.  They are created by the built-in :func:"
"`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, "
"it can be used again as an element of another set, or as a dictionary key."
msgstr ""
"不変な集合型です。組み込みの :func:`frozenset` コンストラクタによって作成され"
"ます。 frozenset は不変で :term:`ハッシュ可能 <hashable>` なので、別の集合型"
"の要素になったり、辞書のキーにすることができます。"

#: ../../reference/datamodel.rst:464
msgid "Mappings"
msgstr "マッピング型 (mapping)"

#: ../../reference/datamodel.rst:471
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""
"任意のインデクス集合でインデクス化された、オブジェクトからなる有限の集合を表"
"現します。添字表記 ``a[k]`` は、 ``k`` でインデクス指定された要素を ``a`` か"
"ら選択します; 選択された要素は式の中で使うことができ、代入や :keyword:`del` "
"文の対象にすることができます。組み込み関数 :func:`len` は、マッピング内の要素"
"数を返します。"

#: ../../reference/datamodel.rst:477
msgid "There is currently a single intrinsic mapping type:"
msgstr ""
"Python に最初から組み込まれているマッピング型は、今のところ一つだけです:"

#: ../../reference/datamodel.rst:481
msgid "Dictionaries"
msgstr "辞書型 (dictionary)"

#: ../../reference/datamodel.rst:485
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""
"ほぼ任意の値でインデクスされたオブジェクトからなる有限の集合を表します。\n"
"キー (key) として使えない値の唯一の型は、リストや辞書、そしてオブジェクトの同"
"一性でなく値で比較されるその他の変更可能な型です。\n"
"これは、辞書型を効率的に実装する上で、キーのハッシュ値が不変である必要がある"
"ためです。\n"
"数値型をキーに使う場合、キー値は通常の数値比較における規則に従います: 二つの"
"値が等しくなる場合 (例えば ``1`` と ``1.0``)、互いに同じ辞書のエントリを表す"
"インデクスとして使うことができます。"

#: ../../reference/datamodel.rst:494
msgid ""
"Dictionaries preserve insertion order, meaning that keys will be produced in "
"the same order they were added sequentially over the dictionary. Replacing "
"an existing key does not change the order, however removing a key and re-"
"inserting it will add it to the end instead of keeping its old place."
msgstr ""
"辞書は挿入の順序を保持します。つまり、キーは辞書に追加された順番に生成されて"
"いきます。既存のキーを置き換えても、キーの順序は変わりません。キーを削除した"
"のちに再挿入すると、元の場所ではなく辞書の最後に追加されます。"

#: ../../reference/datamodel.rst:499
msgid ""
"Dictionaries are mutable; they can be created by the ``{}`` notation (see "
"section :ref:`dict`)."
msgstr ""

#: ../../reference/datamodel.rst:506
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional "
"examples of mapping types, as does the :mod:`collections` module."
msgstr ""
"拡張モジュール :mod:`dbm.ndbm` 、 :mod:`dbm.gnu` は、 :mod:`collections` モ"
"ジュールのように、別のマッピング型の例を提供しています。"

#: ../../reference/datamodel.rst:510
msgid ""
"Dictionaries did not preserve insertion order in versions of Python before "
"3.6. In CPython 3.6, insertion order was preserved, but it was considered an "
"implementation detail at that time rather than a language guarantee."
msgstr ""
"Pythonのバージョン3.6では、辞書は挿入順序を保持しませんでした。CPython 3.6で"
"は挿入順序は保持されましたが、それは策定された言語の仕様というより、その当時"
"の実装の細部とみなされていました。"

#: ../../reference/datamodel.rst:517
msgid "Callable types"
msgstr "呼び出し可能型 (callable type)"

#: ../../reference/datamodel.rst:525
msgid ""
"These are the types to which the function call operation (see section :ref:"
"`calls`) can be applied:"
msgstr "関数呼び出し操作 (:ref:`calls` 参照) を行うことができる型です:"

#: ../../reference/datamodel.rst:532
msgid "User-defined functions"
msgstr "ユーザ定義関数 (user-defined function)"

#: ../../reference/datamodel.rst:539
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""
"ユーザ定義関数オブジェクトは、関数定義を行うことで生成されます (:ref:"
"`function` 参照)。関数は、仮引数 (formal parameter) リストと同じ数の要素が"
"入った引数リストとともに呼び出されます。"

#: ../../reference/datamodel.rst:545 ../../reference/datamodel.rst:1133
#: ../../reference/datamodel.rst:1330
msgid "Special read-only attributes"
msgstr ""

#: ../../reference/datamodel.rst:555 ../../reference/datamodel.rst:589
msgid "Attribute"
msgstr "属性"

#: ../../reference/datamodel.rst:556 ../../reference/datamodel.rst:590
msgid "Meaning"
msgstr "意味"

#: ../../reference/datamodel.rst:559
msgid ""
"A reference to the :class:`dictionary <dict>` that holds the function's :ref:"
"`global variables <naming>` -- the global namespace of the module in which "
"the function was defined."
msgstr ""

#: ../../reference/datamodel.rst:564
msgid ""
"``None`` or a :class:`tuple` of cells that contain bindings for the "
"function's free variables."
msgstr ""

#: ../../reference/datamodel.rst:567
msgid ""
"A cell object has the attribute ``cell_contents``. This can be used to get "
"the value of the cell, as well as set the value."
msgstr ""
"セルオブジェクトは属性 ``cell_contents`` を持っています。\n"
"これはセルの値を設定するのに加えて、セルの値を得るのにも使えます。"

#: ../../reference/datamodel.rst:571 ../../reference/datamodel.rst:1372
msgid "Special writable attributes"
msgstr ""

#: ../../reference/datamodel.rst:584
msgid "Most of these attributes check the type of the assigned value:"
msgstr ""

#: ../../reference/datamodel.rst:593
msgid ""
"The function's documentation string, or ``None`` if unavailable. Not "
"inherited by subclasses."
msgstr ""

#: ../../reference/datamodel.rst:597
msgid ""
"The function's name. See also: :attr:`__name__ attributes <definition."
"__name__>`."
msgstr ""

#: ../../reference/datamodel.rst:601
msgid ""
"The function's :term:`qualified name`. See also: :attr:`__qualname__ "
"attributes <definition.__qualname__>`."
msgstr ""

#: ../../reference/datamodel.rst:607
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""
"関数が定義されているモジュールの名前です。モジュール名がない場合は ``None`` "
"になります。"

#: ../../reference/datamodel.rst:611
msgid ""
"A :class:`tuple` containing default :term:`parameter` values for those "
"parameters that have defaults, or ``None`` if no parameters have a default "
"value."
msgstr ""

#: ../../reference/datamodel.rst:616
msgid ""
"The :ref:`code object <code-objects>` representing the compiled function "
"body."
msgstr ""

#: ../../reference/datamodel.rst:620
msgid ""
"The namespace supporting arbitrary function attributes. See also: :attr:"
"`__dict__ attributes <object.__dict__>`."
msgstr ""

#: ../../reference/datamodel.rst:624
msgid ""
"A :class:`dictionary <dict>` containing annotations of :term:`parameters "
"<parameter>`. The keys of the dictionary are the parameter names, and "
"``'return'`` for the return annotation, if provided. See also: :ref:"
"`annotations-howto`."
msgstr ""

#: ../../reference/datamodel.rst:631
msgid ""
"A :class:`dictionary <dict>` containing defaults for keyword-only :term:"
"`parameters <parameter>`."
msgstr ""

#: ../../reference/datamodel.rst:635
msgid ""
"A :class:`tuple` containing the :ref:`type parameters <type-params>` of a :"
"ref:`generic function <generic-functions>`."
msgstr ""

#: ../../reference/datamodel.rst:640
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes."
msgstr ""

#: ../../reference/datamodel.rst:646
msgid ""
"CPython's current implementation only supports function attributes on user-"
"defined functions. Function attributes on :ref:`built-in functions <builtin-"
"functions>` may be supported in the future."
msgstr ""

#: ../../reference/datamodel.rst:651
msgid ""
"Additional information about a function's definition can be retrieved from "
"its :ref:`code object <code-objects>` (accessible via the :attr:`~function."
"__code__` attribute)."
msgstr ""

#: ../../reference/datamodel.rst:659
msgid "Instance methods"
msgstr "インスタンスメソッド"

#: ../../reference/datamodel.rst:666
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr ""
"インスタンスメソッドオブジェクトは、クラス、クラスインスタンスと任意の呼び出"
"し可能オブジェクト (通常はユーザ定義関数) を結びつけます。"

#: ../../reference/datamodel.rst:676 ../../reference/datamodel.rst:1468
msgid "Special read-only attributes:"
msgstr ""

#: ../../reference/datamodel.rst:681
msgid ""
"Refers to the class instance object to which the method is :ref:`bound "
"<method-binding>`"
msgstr ""

#: ../../reference/datamodel.rst:685
msgid "Refers to the original :ref:`function object <user-defined-funcs>`"
msgstr ""

#: ../../reference/datamodel.rst:688
msgid ""
"The method's documentation (same as :attr:`method.__func__.__doc__ <function."
"__doc__>`). A :class:`string <str>` if the original function had a "
"docstring, else ``None``."
msgstr ""

#: ../../reference/datamodel.rst:694
msgid ""
"The name of the method (same as :attr:`method.__func__.__name__ <function."
"__name__>`)"
msgstr ""

#: ../../reference/datamodel.rst:698
msgid ""
"The name of the module the method was defined in, or ``None`` if unavailable."
msgstr ""

#: ../../reference/datamodel.rst:701
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying :ref:`function object <user-defined-funcs>`."
msgstr ""

#: ../../reference/datamodel.rst:704
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined :ref:`function object <user-defined-funcs>` or a :class:"
"`classmethod` object."
msgstr ""

#: ../../reference/datamodel.rst:711
msgid ""
"When an instance method object is created by retrieving a user-defined :ref:"
"`function object <user-defined-funcs>` from a class via one of its "
"instances, its :attr:`~method.__self__` attribute is the instance, and the "
"method object is said to be *bound*.  The new method's :attr:`~method."
"__func__` attribute is the original function object."
msgstr ""

#: ../../reference/datamodel.rst:717
msgid ""
"When an instance method object is created by retrieving a :class:"
"`classmethod` object from a class or instance, its :attr:`~method.__self__` "
"attribute is the class itself, and its :attr:`~method.__func__` attribute is "
"the function object underlying the class method."
msgstr ""

#: ../../reference/datamodel.rst:722
msgid ""
"When an instance method object is called, the underlying function (:attr:"
"`~method.__func__`) is called, inserting the class instance (:attr:`~method."
"__self__`) in front of the argument list.  For instance, when :class:`!C` is "
"a class which contains a definition for a function :meth:`!f`, and ``x`` is "
"an instance of :class:`!C`, calling ``x.f(1)`` is equivalent to calling ``C."
"f(x, 1)``."
msgstr ""

#: ../../reference/datamodel.rst:729
msgid ""
"When an instance method object is derived from a :class:`classmethod` "
"object, the \"class instance\" stored in :attr:`~method.__self__` will "
"actually be the class itself, so that calling either ``x.f(1)`` or ``C."
"f(1)`` is equivalent to calling ``f(C,1)`` where ``f`` is the underlying "
"function."
msgstr ""

#: ../../reference/datamodel.rst:734
msgid ""
"It is important to note that user-defined functions which are attributes of "
"a class instance are not converted to bound methods; this *only* happens "
"when the function is an attribute of the class."
msgstr ""

#: ../../reference/datamodel.rst:741
msgid "Generator functions"
msgstr "ジェネレータ関数 (generator function)"

#: ../../reference/datamodel.rst:747
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section :"
"ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an :term:`iterator` object which can be used to "
"execute the body of the function:  calling the iterator's :meth:`iterator."
"__next__` method will cause the function to execute until it provides a "
"value using the :keyword:`!yield` statement.  When the function executes a :"
"keyword:`return` statement or falls off the end, a :exc:`StopIteration` "
"exception is raised and the iterator will have reached the end of the set of "
"values to be returned."
msgstr ""
":keyword:`yield` 文 (:ref:`yield` の節を参照) を使う関数もしくはメソッドは :"
"dfn:`ジェネレータ関数` と呼ばれます。\n"
"そのような関数が呼び出されたときは常に、関数の本体を実行するのに使える :term:"
"`イテレータ <iterator>` オブジェクトを返します:\n"
"イテレータの :meth:`iterator.__next__` メソッドを呼び出すと、 :keyword:`!"
"yield` 文を使って値が提供されるまで関数を実行します。\n"
"関数の :keyword:`return` 文を実行するか終端に達したときは、 :exc:"
"`StopIteration` 例外が送出され、イテレータが返すべき値の最後まで到達していま"
"す。"

#: ../../reference/datamodel.rst:759
msgid "Coroutine functions"
msgstr "コルーチン関数 (coroutine function)"

#: ../../reference/datamodel.rst:764
msgid ""
"A function or method which is defined using :keyword:`async def` is called "
"a :dfn:`coroutine function`.  Such a function, when called, returns a :term:"
"`coroutine` object.  It may contain :keyword:`await` expressions, as well "
"as :keyword:`async with` and :keyword:`async for` statements. See also the :"
"ref:`coroutine-objects` section."
msgstr ""
":keyword:`async def` を使用して定義された関数やメソッドを :dfn:`コルーチン関"
"数 (coroutine function)` と呼びます。 \n"
"呼び出された時、そのような関数は :term:`coroutine` オブジェクトを返します。\n"
"コルーチン関数は :keyword:`async with` や :keyword:`async for` 文だけでなく :"
"keyword:`await` 式を持つことが出来ます。\n"
":ref:`coroutine-objects` を参照してください。"

#: ../../reference/datamodel.rst:772
msgid "Asynchronous generator functions"
msgstr "非同期ジェネレータ関数 (asynchronous generator function)"

#: ../../reference/datamodel.rst:778
msgid ""
"A function or method which is defined using :keyword:`async def` and which "
"uses the :keyword:`yield` statement is called a :dfn:`asynchronous generator "
"function`.  Such a function, when called, returns an :term:`asynchronous "
"iterator` object which can be used in an :keyword:`async for` statement to "
"execute the body of the function."
msgstr ""
":keyword:`async def` を使って定義され、 :keyword:`yield` 文を使用している関数"
"やメソッドを :dfn:`asynchronous generator function` と呼びます。\n"
"そのような関数は、呼び出されたとき、:term:`非同期イテレータ <asynchronous "
"iterator>` オブジェクトを返します。\n"
"このオブジェクトは :keyword:`async for` 文で関数の本体を実行するのに使えま"
"す。"

#: ../../reference/datamodel.rst:784
msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__ <object."
"__anext__>` method will return an :term:`awaitable` which when awaited will "
"execute until it provides a value using the :keyword:`yield` expression.  "
"When the function executes an empty :keyword:`return` statement or falls off "
"the end, a :exc:`StopAsyncIteration` exception is raised and the "
"asynchronous iterator will have reached the end of the set of values to be "
"yielded."
msgstr ""
"非同期イテレータの :meth:`aiterator.__anext__ <object.__anext__>` メソッドを"
"呼び出すと、他の処理が待たされているときに、 :keyword:`yield` 式を使い値を提"
"供するところまで処理を進める :term:`awaitable` を返します。\n"
"その関数が空の :keyword:`return` 文を実行する、もしくは処理の終わりに到達した"
"ときは、 :exc:`StopAsyncIteration` 例外が送出され、非同期イテレータは出力すべ"
"き値の最後に到達したことになります。"

#: ../../reference/datamodel.rst:797
msgid "Built-in functions"
msgstr "組み込み関数 (built-in function)"

#: ../../reference/datamodel.rst:804
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes:"
msgstr ""

#: ../../reference/datamodel.rst:809
msgid ""
":attr:`!__doc__` is the function's documentation string, or ``None`` if "
"unavailable. See :attr:`function.__doc__`."
msgstr ""

#: ../../reference/datamodel.rst:811
msgid ""
":attr:`!__name__` is the function's name. See :attr:`function.__name__`."
msgstr ""

#: ../../reference/datamodel.rst:812
msgid ":attr:`!__self__` is set to ``None`` (but see the next item)."
msgstr ""

#: ../../reference/datamodel.rst:813
msgid ""
":attr:`!__module__` is the name of the module the function was defined in or "
"``None`` if unavailable. See :attr:`function.__module__`."
msgstr ""

#: ../../reference/datamodel.rst:821
msgid "Built-in methods"
msgstr "組み込みメソッド (built-in method)"

#: ../../reference/datamodel.rst:828
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, assuming "
"*alist* is a list object. In this case, the special read-only attribute :"
"attr:`!__self__` is set to the object denoted by *alist*. (The attribute has "
"the same semantics as it does with :attr:`other instance methods <method."
"__self__>`.)"
msgstr ""

#: ../../reference/datamodel.rst:837
msgid "Classes"
msgstr "クラス"

#: ../../reference/datamodel.rst:839
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that "
"override :meth:`~object.__new__`.  The arguments of the call are passed to :"
"meth:`!__new__` and, in the typical case, to :meth:`~object.__init__` to "
"initialize the new instance."
msgstr ""

#: ../../reference/datamodel.rst:847
msgid "Class Instances"
msgstr "クラスのインスタンス"

#: ../../reference/datamodel.rst:849
msgid ""
"Instances of arbitrary classes can be made callable by defining a :meth:"
"`~object.__call__` method in their class."
msgstr ""
"任意のクラスのインスタンスは、クラスで :meth:`~object.__call__` メソッドを定"
"義することで呼び出し可能になります。"

#: ../../reference/datamodel.rst:854
msgid "Modules"
msgstr "モジュール"

#: ../../reference/datamodel.rst:860
msgid ""
"Modules are a basic organizational unit of Python code, and are created by "
"the :ref:`import system <importsystem>` as invoked either by the :keyword:"
"`import` statement, or by calling functions such as :func:`importlib."
"import_module` and built-in :func:`__import__`.  A module object has a "
"namespace implemented by a :class:`dictionary <dict>` object (this is the "
"dictionary referenced by the :attr:`~function.__globals__` attribute of "
"functions defined in the module).  Attribute references are translated to "
"lookups in this dictionary, e.g., ``m.x`` is equivalent to ``m."
"__dict__[\"x\"]``. A module object does not contain the code object used to "
"initialize the module (since it isn't needed once the initialization is "
"done)."
msgstr ""

#: ../../reference/datamodel.rst:873
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"属性の代入を行うと、モジュールの名前空間辞書の内容を更新します。例えば、 ``m."
"x = 1`` は ``m.__dict__[\"x\"] = 1`` と同じです。"

#: ../../reference/datamodel.rst:883
msgid "Predefined (writable) attributes:"
msgstr "定義済みの (書き込み可能な) 属性:"

#: ../../reference/datamodel.rst:885
msgid ":attr:`__name__`"
msgstr ":attr:`__name__`"

#: ../../reference/datamodel.rst:886
msgid "The module's name."
msgstr "モジュールの名前。"

#: ../../reference/datamodel.rst:888 ../../reference/datamodel.rst:988
msgid ":attr:`__doc__`"
msgstr ":attr:`__doc__`"

#: ../../reference/datamodel.rst:889
msgid "The module's documentation string, or ``None`` if unavailable."
msgstr ""
"モジュールのドキュメントで、文字列か、もし利用できない場合は ``None`` です。"

#: ../../reference/datamodel.rst:892
msgid ":attr:`__file__`"
msgstr ":attr:`__file__`"

#: ../../reference/datamodel.rst:893
msgid ""
"The pathname of the file from which the module was loaded, if it was loaded "
"from a file. The :attr:`__file__` attribute may be missing for certain types "
"of modules, such as C modules that are statically linked into the "
"interpreter.  For extension modules loaded dynamically from a shared "
"library, it's the pathname of the shared library file."
msgstr ""
"ロードされたモジュールファイルのパス名です。インタプリタに静的にリンクされて"
"いる C モジュールのような特定の種類のモジュールでは、 :attr:`__file__` 属性は"
"存在しないかもしれません。共有ライブラリから動的にロードされた拡張モジュール"
"の場合、この属性は 共有ライブラリファイルのパス名になります。"

#: ../../reference/datamodel.rst:901 ../../reference/datamodel.rst:991
msgid ":attr:`__annotations__`"
msgstr ":attr:`__annotations__`"

#: ../../reference/datamodel.rst:902
msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during module body execution.  For best practices on working with :"
"attr:`__annotations__`, please see :ref:`annotations-howto`."
msgstr ""
"モジュールの本体の実行中に収集した :term:`変数アノテーション <variable "
"annotation>` を格納する辞書です。 :attr:`__annotations__` を利用するベストプ"
"ラクティスについては、 :ref:`アノテーションのHOWTO <annotations-howto>` を参"
"照してください。"

#: ../../reference/datamodel.rst:909
msgid ""
"Special read-only attribute: :attr:`~object.__dict__` is the module's "
"namespace as a dictionary object."
msgstr ""
"読み出し専用の特殊属性: :attr:`~object.__dict__` はモジュールの名前空間で、辞"
"書オブジェクトです。"

#: ../../reference/datamodel.rst:914
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary "
"will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""
"CPython がモジュール辞書を削除する方法により、モジュール辞書が生きた参照を"
"持っていたとしてもその辞書はモジュールがスコープから外れた時に削除されます。"
"これを避けるには、辞書をコピーするか、辞書を直接使っている間モジュールを保持"
"してください。"

#: ../../reference/datamodel.rst:921
msgid "Custom classes"
msgstr "カスタムクラス型"

#: ../../reference/datamodel.rst:923
msgid ""
"Custom class types are typically created by class definitions (see section :"
"ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, e."
"g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although there are a "
"number of hooks which allow for other means of locating attributes). When "
"the attribute name is not found there, the attribute search continues in the "
"base classes. This search of the base classes uses the C3 method resolution "
"order which behaves correctly even in the presence of 'diamond' inheritance "
"structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by Python can be "
"found at :ref:`python_2.3_mro`."
msgstr ""

#: ../../reference/datamodel.rst:944
msgid ""
"When a class attribute reference (for class :class:`!C`, say) would yield a "
"class method object, it is transformed into an instance method object whose :"
"attr:`~method.__self__` attribute is :class:`!C`. When it would yield a :"
"class:`staticmethod` object, it is transformed into the object wrapped by "
"the static method object. See section :ref:`descriptors` for another way in "
"which attributes retrieved from a class may differ from those actually "
"contained in its :attr:`~object.__dict__`."
msgstr ""

#: ../../reference/datamodel.rst:955
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""
"クラス属性を代入すると、そのクラスの辞書だけが更新され、基底クラスの辞書は更"
"新しません。"

#: ../../reference/datamodel.rst:960
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""
"クラスオブジェクトを呼び出す (上記を参照) と、クラスインスタンスを生成します "
"(下記を参照)。"

#: ../../reference/datamodel.rst:973
msgid "Special attributes:"
msgstr "特殊属性:"

#: ../../reference/datamodel.rst:975
msgid ":attr:`~definition.__name__`"
msgstr ":attr:`~definition.__name__`"

#: ../../reference/datamodel.rst:976
msgid "The class name."
msgstr "クラス名。"

#: ../../reference/datamodel.rst:978
msgid ":attr:`__module__`"
msgstr ":attr:`__module__`"

#: ../../reference/datamodel.rst:979
msgid "The name of the module in which the class was defined."
msgstr "クラスが定義されているモジュールの名前。"

#: ../../reference/datamodel.rst:981
msgid ":attr:`~object.__dict__`"
msgstr ":attr:`~object.__dict__`"

#: ../../reference/datamodel.rst:982
msgid "The dictionary containing the class's namespace."
msgstr "クラスの名前空間を格納している辞書。"

#: ../../reference/datamodel.rst:984
msgid ":attr:`~class.__bases__`"
msgstr ":attr:`~class.__bases__`"

#: ../../reference/datamodel.rst:985
msgid ""
"A tuple containing the base classes, in the order of their occurrence in the "
"base class list."
msgstr "ベースクラスリストに現れる順序でベースクラスを格納しているタプル。"

#: ../../reference/datamodel.rst:989
msgid "The class's documentation string, or ``None`` if undefined."
msgstr "クラスのドキュメントで、文字列か、もし未定義の場合は ``None`` です。"

#: ../../reference/datamodel.rst:992
msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during class body execution.  For best practices on working with :"
"attr:`__annotations__`, please see :ref:`annotations-howto`."
msgstr ""
"クラスの本体の実行中に収集した :term:`変数アノテーション <variable "
"annotation>` を格納する辞書です。 :attr:`__annotations__` を利用するベストプ"
"ラクティスについては、 :ref:`アノテーションのHOWTO <annotations-howto>` を参"
"照してください。"

#: ../../reference/datamodel.rst:998
msgid ":attr:`__type_params__`"
msgstr ""

#: ../../reference/datamodel.rst:999
msgid ""
"A tuple containing the :ref:`type parameters <type-params>` of a :ref:"
"`generic class <generic-classes>`."
msgstr ""

#: ../../reference/datamodel.rst:1002
msgid ":attr:`~class.__static_attributes__`"
msgstr ""

#: ../../reference/datamodel.rst:1003
msgid ""
"A tuple containing names of attributes of this class which are assigned "
"through ``self.X`` from any function in its body."
msgstr ""

#: ../../reference/datamodel.rst:1006
msgid ":attr:`__firstlineno__`"
msgstr ""

#: ../../reference/datamodel.rst:1007
msgid ""
"The line number of the first line of the class definition, including "
"decorators."
msgstr ""

#: ../../reference/datamodel.rst:1011
msgid "Class instances"
msgstr "クラスインスタンス (class instance)"

#: ../../reference/datamodel.rst:1019
msgid ""
"A class instance is created by calling a class object (see above).  A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object, it is transformed into an instance "
"method object whose :attr:`~method.__self__` attribute is the instance.  "
"Static method and class method objects are also transformed; see above under "
"\"Classes\".  See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`.  If no "
"class attribute is found, and the object's class has a :meth:`~object."
"__getattr__` method, that is called to satisfy the lookup."
msgstr ""

#: ../../reference/datamodel.rst:1035
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`~object.__setattr__` or :"
"meth:`~object.__delattr__` method, this is called instead of updating the "
"instance dictionary directly."
msgstr ""
"属性の代入や削除を行うと、インスタンスの辞書を更新しますが、クラスの辞書を更"
"新することはありません。クラスで :meth:`~object.__setattr__` や :meth:"
"`~object.__delattr__` メソッドが定義されている場合、直接インスタンスの辞書を"
"更新する代わりにこれらのメソッドが呼び出されます。"

#: ../../reference/datamodel.rst:1045
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""
"クラスインスタンスは、ある特定の名前のメソッドを持っている場合、数値型やシー"
"ケンス型、あるいはマップ型のように振舞うことができます。 :ref:`specialnames` "
"を参照してください。"

#: ../../reference/datamodel.rst:1052
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary; :"
"attr:`~instance.__class__` is the instance's class."
msgstr ""
"特殊属性: :attr:`~object.__dict__` は属性の辞書です; :attr:`~instance."
"__class__` はインスタンスのクラスです。"

#: ../../reference/datamodel.rst:1057
msgid "I/O objects (also known as file objects)"
msgstr "I/O オブジェクト (ファイルオブジェクトの別名)"

#: ../../reference/datamodel.rst:1072
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and "
"also :func:`os.popen`, :func:`os.fdopen`, and the :meth:`~socket.socket."
"makefile` method of socket objects (and perhaps by other functions or "
"methods provided by extension modules)."
msgstr ""
":term:`file object` は開かれたファイルを表します。ファイルオブジェクトを作る"
"ための様々なショートカットがあります: :func:`open` 組み込み関数、 :func:`os."
"popen` 、 :func:`os.fdopen` 、ソケットオブジェクトの :meth:`~socket.socket."
"makefile` メソッド (あるいは拡張モジュールから提供される他の関数やメソッ"
"ド) 。"

#: ../../reference/datamodel.rst:1078
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized "
"to file objects corresponding to the interpreter's standard input, output "
"and error streams; they are all open in text mode and therefore follow the "
"interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""
"オブジェクト ``sys.stdin`` 、 ``sys.stdout`` および ``sys.stderr`` は、インタ"
"プリタの標準入力、標準出力、および標準エラー出力ストリームに対応するファイル"
"オブジェクトに初期化されます。これらはすべてテキストモードで開かれ、 :class:"
"`io.TextIOBase` 抽象クラスによって定義されたインターフェースに従います。"

#: ../../reference/datamodel.rst:1086
msgid "Internal types"
msgstr "内部型 (internal type)"

#: ../../reference/datamodel.rst:1092
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""
"インタプリタが内部的に使っているいくつかの型は、ユーザに公開されています。こ"
"れらの定義は将来のインタプリタのバージョンでは変更される可能性がありますが、"
"ここでは記述の完全性のために触れておきます。"

#: ../../reference/datamodel.rst:1100
msgid "Code objects"
msgstr "コードオブジェクト"

#: ../../reference/datamodel.rst:1104
msgid ""
"Code objects represent *byte-compiled* executable Python code, or :term:"
"`bytecode`. The difference between a code object and a function object is "
"that the function object contains an explicit reference to the function's "
"globals (the module in which it was defined), while a code object contains "
"no context; also the default argument values are stored in the function "
"object, not in the code object (because they represent values calculated at "
"run-time).  Unlike function objects, code objects are immutable and contain "
"no references (directly or indirectly) to mutable objects."
msgstr ""
"コードオブジェクトは *バイトコンパイルされた (byte-compiled)* 実行可能な "
"Python コード、別名 :term:`バイトコード <bytecode>` を表現します。コードオブ"
"ジェクトと関数オブジェクトの違いは、関数オブジェクトが関数のグローバル変数 "
"(関数を定義しているモジュールのグローバル) に対して明示的な参照を持っているの"
"に対し、コードオブジェクトにはコンテキストがないということです; また、関数オ"
"ブジェクトではデフォルト引数値を記憶できますが、コードオブジェクトではできま"
"せん (実行時に計算される値を表現するため)。関数オブジェクトと違い、コードオブ"
"ジェクトは変更不可能で、変更可能なオブジェクトへの参照を (直接、間接に関わら"
"ず) 含みません。"

#: ../../reference/datamodel.rst:1138
msgid "The function name"
msgstr ""

#: ../../reference/datamodel.rst:1141
msgid "The fully qualified function name"
msgstr ""

#: ../../reference/datamodel.rst:1146
msgid ""
"The total number of positional :term:`parameters <parameter>` (including "
"positional-only parameters and parameters with default values) that the "
"function has"
msgstr ""

#: ../../reference/datamodel.rst:1151
msgid ""
"The number of positional-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""

#: ../../reference/datamodel.rst:1155
msgid ""
"The number of keyword-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""

#: ../../reference/datamodel.rst:1159
msgid ""
"The number of :ref:`local variables <naming>` used by the function "
"(including parameters)"
msgstr ""

#: ../../reference/datamodel.rst:1163
msgid ""
"A :class:`tuple` containing the names of the local variables in the function "
"(starting with the parameter names)"
msgstr ""

#: ../../reference/datamodel.rst:1167
msgid ""
"A :class:`tuple` containing the names of :ref:`local variables <naming>` "
"that are referenced by nested functions inside the function"
msgstr ""

#: ../../reference/datamodel.rst:1171
msgid "A :class:`tuple` containing the names of free variables in the function"
msgstr ""

#: ../../reference/datamodel.rst:1174
msgid ""
"A string representing the sequence of :term:`bytecode` instructions in the "
"function"
msgstr ""

#: ../../reference/datamodel.rst:1178
msgid ""
"A :class:`tuple` containing the literals used by the :term:`bytecode` in the "
"function"
msgstr ""

#: ../../reference/datamodel.rst:1182
msgid ""
"A :class:`tuple` containing the names used by the :term:`bytecode` in the "
"function"
msgstr ""

#: ../../reference/datamodel.rst:1186
msgid "The name of the file from which the code was compiled"
msgstr ""

#: ../../reference/datamodel.rst:1189
msgid "The line number of the first line of the function"
msgstr ""

#: ../../reference/datamodel.rst:1192
msgid ""
"A string encoding the mapping from :term:`bytecode` offsets to line numbers. "
"For details, see the source code of the interpreter."
msgstr ""

#: ../../reference/datamodel.rst:1195
msgid ""
"This attribute of code objects is deprecated, and may be removed in Python "
"3.14."
msgstr ""

#: ../../reference/datamodel.rst:1200
msgid "The required stack size of the code object"
msgstr ""

#: ../../reference/datamodel.rst:1203
msgid ""
"An :class:`integer <int>` encoding a number of flags for the interpreter."
msgstr ""

#: ../../reference/datamodel.rst:1208
msgid ""
"The following flag bits are defined for :attr:`~codeobject.co_flags`: bit "
"``0x04`` is set if the function uses the ``*arguments`` syntax to accept an "
"arbitrary number of positional arguments; bit ``0x08`` is set if the "
"function uses the ``**keywords`` syntax to accept arbitrary keyword "
"arguments; bit ``0x20`` is set if the function is a generator. See :ref:"
"`inspect-module-co-flags` for details on the semantics of each flags that "
"might be present."
msgstr ""

#: ../../reference/datamodel.rst:1216
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`~codeobject.co_flags` to indicate whether a code object was "
"compiled with a particular feature enabled: bit ``0x2000`` is set if the "
"function was compiled with future division enabled; bits ``0x10`` and "
"``0x1000`` were used in earlier versions of Python."
msgstr ""

#: ../../reference/datamodel.rst:1222
msgid ""
"Other bits in :attr:`~codeobject.co_flags` are reserved for internal use."
msgstr ""

#: ../../reference/datamodel.rst:1226
msgid ""
"If a code object represents a function, the first item in :attr:`~codeobject."
"co_consts` is the documentation string of the function, or ``None`` if "
"undefined."
msgstr ""

#: ../../reference/datamodel.rst:1231
msgid "Methods on code objects"
msgstr ""

#: ../../reference/datamodel.rst:1235
msgid ""
"Returns an iterable over the source code positions of each :term:`bytecode` "
"instruction in the code object."
msgstr ""

#: ../../reference/datamodel.rst:1238
msgid ""
"The iterator returns :class:`tuple`\\s containing the ``(start_line, "
"end_line, start_column, end_column)``. The *i-th* tuple corresponds to the "
"position of the source code that compiled to the *i-th* code unit. Column "
"information is 0-indexed utf-8 byte offsets on the given source line."
msgstr ""

#: ../../reference/datamodel.rst:1244
msgid ""
"This positional information can be missing. A non-exhaustive lists of cases "
"where this may happen:"
msgstr ""

#: ../../reference/datamodel.rst:1247
msgid "Running the interpreter with :option:`-X` ``no_debug_ranges``."
msgstr ""

#: ../../reference/datamodel.rst:1248
msgid ""
"Loading a pyc file compiled while using :option:`-X` ``no_debug_ranges``."
msgstr ""

#: ../../reference/datamodel.rst:1249
msgid "Position tuples corresponding to artificial instructions."
msgstr ""

#: ../../reference/datamodel.rst:1250
msgid ""
"Line and column numbers that can't be represented due to implementation "
"specific limitations."
msgstr ""

#: ../../reference/datamodel.rst:1253
msgid ""
"When this occurs, some or all of the tuple elements can be :const:`None`."
msgstr ""

#: ../../reference/datamodel.rst:1259
msgid ""
"This feature requires storing column positions in code objects which may "
"result in a small increase of disk usage of compiled Python files or "
"interpreter memory usage. To avoid storing the extra information and/or "
"deactivate printing the extra traceback information, the :option:`-X` "
"``no_debug_ranges`` command line flag or the :envvar:`PYTHONNODEBUGRANGES` "
"environment variable can be used."
msgstr ""

#: ../../reference/datamodel.rst:1268
msgid ""
"Returns an iterator that yields information about successive ranges of :term:"
"`bytecode`\\s. Each item yielded is a ``(start, end, lineno)`` :class:"
"`tuple`:"
msgstr ""

#: ../../reference/datamodel.rst:1272
msgid ""
"``start`` (an :class:`int`) represents the offset (inclusive) of the start "
"of the :term:`bytecode` range"
msgstr ""

#: ../../reference/datamodel.rst:1274
msgid ""
"``end`` (an :class:`int`) represents the offset (exclusive) of the end of "
"the :term:`bytecode` range"
msgstr ""

#: ../../reference/datamodel.rst:1276
msgid ""
"``lineno`` is an :class:`int` representing the line number of the :term:"
"`bytecode` range, or ``None`` if the bytecodes in the given range have no "
"line number"
msgstr ""

#: ../../reference/datamodel.rst:1280
msgid "The items yielded will have the following properties:"
msgstr ""

#: ../../reference/datamodel.rst:1282
msgid "The first range yielded will have a ``start`` of 0."
msgstr ""

#: ../../reference/datamodel.rst:1283
msgid ""
"The ``(start, end)`` ranges will be non-decreasing and consecutive. That is, "
"for any pair of :class:`tuple`\\s, the ``start`` of the second will be equal "
"to the ``end`` of the first."
msgstr ""

#: ../../reference/datamodel.rst:1286
msgid "No range will be backwards: ``end >= start`` for all triples."
msgstr ""

#: ../../reference/datamodel.rst:1287
msgid ""
"The last :class:`tuple` yielded will have ``end`` equal to the size of the :"
"term:`bytecode`."
msgstr ""

#: ../../reference/datamodel.rst:1290
msgid ""
"Zero-width ranges, where ``start == end``, are allowed. Zero-width ranges "
"are used for lines that are present in the source code, but have been "
"eliminated by the :term:`bytecode` compiler."
msgstr ""

#: ../../reference/datamodel.rst:1298
msgid ":pep:`626` - Precise line numbers for debugging and other tools."
msgstr ""

#: ../../reference/datamodel.rst:1299
msgid "The PEP that introduced the :meth:`!co_lines` method."
msgstr ""

#: ../../reference/datamodel.rst:1303
msgid ""
"Return a copy of the code object with new values for the specified fields."
msgstr ""

#: ../../reference/datamodel.rst:1305
msgid ""
"Code objects are also supported by the generic function :func:`copy.replace`."
msgstr ""

#: ../../reference/datamodel.rst:1313
msgid "Frame objects"
msgstr "フレーム (frame) オブジェクト"

#: ../../reference/datamodel.rst:1317
msgid ""
"Frame objects represent execution frames.  They may occur in :ref:`traceback "
"objects <traceback-objects>`, and are also passed to registered trace "
"functions."
msgstr ""

#: ../../reference/datamodel.rst:1335
msgid ""
"Points to the previous stack frame (towards the caller), or ``None`` if this "
"is the bottom stack frame"
msgstr ""

#: ../../reference/datamodel.rst:1339
msgid ""
"The :ref:`code object <code-objects>` being executed in this frame. "
"Accessing this attribute raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"f_code\"``."
msgstr ""

#: ../../reference/datamodel.rst:1344
msgid ""
"The mapping used by the frame to look up :ref:`local variables <naming>`. If "
"the frame refers to an :term:`optimized scope`, this may return a write-"
"through proxy object."
msgstr ""

#: ../../reference/datamodel.rst:1349
msgid "Return a proxy for optimized scopes."
msgstr ""

#: ../../reference/datamodel.rst:1353
msgid ""
"The dictionary used by the frame to look up :ref:`global variables <naming>`"
msgstr ""

#: ../../reference/datamodel.rst:1357
msgid ""
"The dictionary used by the frame to look up :ref:`built-in (intrinsic) names "
"<naming>`"
msgstr ""

#: ../../reference/datamodel.rst:1361
msgid ""
"The \"precise instruction\" of the frame object (this is an index into the :"
"term:`bytecode` string of the :ref:`code object <code-objects>`)"
msgstr ""

#: ../../reference/datamodel.rst:1377
msgid ""
"If not ``None``, this is a function called for various events during code "
"execution (this is used by debuggers). Normally an event is triggered for "
"each new source line (see :attr:`~frame.f_trace_lines`)."
msgstr ""

#: ../../reference/datamodel.rst:1382
msgid ""
"Set this attribute to :const:`False` to disable triggering a tracing event "
"for each source line."
msgstr ""

#: ../../reference/datamodel.rst:1386
msgid ""
"Set this attribute to :const:`True` to allow per-opcode events to be "
"requested. Note that this may lead to undefined interpreter behaviour if "
"exceptions raised by the trace function escape to the function being traced."
msgstr ""

#: ../../reference/datamodel.rst:1392
msgid ""
"The current line number of the frame -- writing to this from within a trace "
"function jumps to the given line (only for the bottom-most frame).  A "
"debugger can implement a Jump command (aka Set Next Statement) by writing to "
"this attribute."
msgstr ""

#: ../../reference/datamodel.rst:1398
msgid "Frame object methods"
msgstr ""

#: ../../reference/datamodel.rst:1400
msgid "Frame objects support one method:"
msgstr "フレームオブジェクトはメソッドを一つサポートします:"

#: ../../reference/datamodel.rst:1404
msgid ""
"This method clears all references to :ref:`local variables <naming>` held by "
"the frame.  Also, if the frame belonged to a :term:`generator`, the "
"generator is finalized.  This helps break reference cycles involving frame "
"objects (for example when catching an :ref:`exception <bltin-exceptions>` "
"and storing its :ref:`traceback <traceback-objects>` for later use)."
msgstr ""

#: ../../reference/datamodel.rst:1410
msgid ""
":exc:`RuntimeError` is raised if the frame is currently executing or "
"suspended."
msgstr ""

#: ../../reference/datamodel.rst:1415
msgid ""
"Attempting to clear a suspended frame raises :exc:`RuntimeError` (as has "
"always been the case for executing frames)."
msgstr ""

#: ../../reference/datamodel.rst:1423
msgid "Traceback objects"
msgstr "トレースバック (traceback) オブジェクト"

#: ../../reference/datamodel.rst:1436
msgid ""
"Traceback objects represent the stack trace of an :ref:`exception <tut-"
"errors>`. A traceback object is implicitly created when an exception occurs, "
"and may also be explicitly created by calling :class:`types.TracebackType`."
msgstr ""

#: ../../reference/datamodel.rst:1441
msgid "Traceback objects can now be explicitly instantiated from Python code."
msgstr ""

#: ../../reference/datamodel.rst:1444
msgid ""
"For implicitly created tracebacks, when the search for an exception handler "
"unwinds the execution stack, at each unwound level a traceback object is "
"inserted in front of the current traceback.  When an exception handler is "
"entered, the stack trace is made available to the program. (See section :ref:"
"`try`.) It is accessible as the third item of the tuple returned by :func:"
"`sys.exc_info`, and as the :attr:`~BaseException.__traceback__` attribute of "
"the caught exception."
msgstr ""

#: ../../reference/datamodel.rst:1453
msgid ""
"When the program contains no suitable handler, the stack trace is written "
"(nicely formatted) to the standard error stream; if the interpreter is "
"interactive, it is also made available to the user as :data:`sys."
"last_traceback`."
msgstr ""

#: ../../reference/datamodel.rst:1458
msgid ""
"For explicitly created tracebacks, it is up to the creator of the traceback "
"to determine how the :attr:`~traceback.tb_next` attributes should be linked "
"to form a full stack trace."
msgstr ""

#: ../../reference/datamodel.rst:1473
msgid ""
"Points to the execution :ref:`frame <frame-objects>` of the current level."
msgstr ""

#: ../../reference/datamodel.rst:1476
msgid ""
"Accessing this attribute raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"tb_frame\"``."
msgstr ""

#: ../../reference/datamodel.rst:1481
msgid "Gives the line number where the exception occurred"
msgstr ""

#: ../../reference/datamodel.rst:1484
msgid "Indicates the \"precise instruction\"."
msgstr ""

#: ../../reference/datamodel.rst:1486
msgid ""
"The line number and last instruction in the traceback may differ from the "
"line number of its :ref:`frame object <frame-objects>` if the exception "
"occurred in a :keyword:`try` statement with no matching except clause or "
"with a :keyword:`finally` clause."
msgstr ""

#: ../../reference/datamodel.rst:1497
msgid ""
"The special writable attribute :attr:`!tb_next` is the next level in the "
"stack trace (towards the frame where the exception occurred), or ``None`` if "
"there is no next level."
msgstr ""

#: ../../reference/datamodel.rst:1501
msgid "This attribute is now writable"
msgstr ""

#: ../../reference/datamodel.rst:1506
msgid "Slice objects"
msgstr "スライス (slice) オブジェクト"

#: ../../reference/datamodel.rst:1510
msgid ""
"Slice objects are used to represent slices for :meth:`~object.__getitem__` "
"methods.  They are also created by the built-in :func:`slice` function."
msgstr ""
"スライスオブジェクトは、 :meth:`~object.__getitem__` メソッドのためのスライス"
"を表すのに使われます。スライスオブジェクトは組み込みの :func:`slice` 関数でも"
"生成されます。"

#: ../../reference/datamodel.rst:1519
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; :attr:"
"`~slice.stop` is the upper bound; :attr:`~slice.step` is the step value; "
"each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"読み出し専用の特殊属性: :attr:`~slice.start` は下限です; :attr:`~slice.stop` "
"は上限です; :attr:`~slice.step` はステップの値です; それぞれ省略された場合は "
"``None`` となっています。これらの属性は任意の型を持てます。"

#: ../../reference/datamodel.rst:1523
msgid "Slice objects support one method:"
msgstr "スライスオブジェクトはメソッドを一つサポートします:"

#: ../../reference/datamodel.rst:1527
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if applied "
"to a sequence of *length* items.  It returns a tuple of three integers; "
"respectively these are the *start* and *stop* indices and the *step* or "
"stride length of the slice. Missing or out-of-bounds indices are handled in "
"a manner consistent with regular slices."
msgstr ""
"このメソッドは単一の整数引数 *length* を取り、スライスオブジェクトが "
"*length* 要素のシーケンスに適用されたときに表現する、スライスに関する情報を計"
"算します。このメソッドは 3 つの整数からなるタプルを返します; それぞれ "
"*start* および *stop* のインデックスと、*step* すなわちスライスのまたぎ幅で"
"す。インデックス値がないか、範囲外の値であれば、通常のスライスと変わらないや"
"りかたで扱われます。"

#: ../../reference/datamodel.rst:1536
msgid "Static method objects"
msgstr "静的メソッド (static method) オブジェクト"

#: ../../reference/datamodel.rst:1538
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are also callable. Static "
"method objects are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"静的メソッドは、上で説明したような関数オブジェクトからメソッドオブジェクトへ"
"の変換を阻止するための方法を提供します。静的メソッドオブジェクトは他の何らか"
"のオブジェクト、通常はユーザ定義メソッドオブジェクトを包むラッパです。静的メ"
"ソッドをクラスやクラスインスタンスから取得すると、実際に返されるオブジェクト"
"はラップされたオブジェクトになり、それ以上は変換の対象にはなりません。静的メ"
"ソッドオブジェクトは通常呼び出し可能なオブジェクトをラップしますが、静的オブ"
"ジェクト自体は呼び出し可能です。静的オブジェクトは組み込みコンストラクタ :"
"func:`staticmethod` で生成されます。"

#: ../../reference/datamodel.rst:1548
msgid "Class method objects"
msgstr "クラスメソッドオブジェクト"

#: ../../reference/datamodel.rst:1550
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such "
"retrieval is described above, under :ref:`\"instance methods\" <instance-"
"methods>`. Class method objects are created by the built-in :func:"
"`classmethod` constructor."
msgstr ""

#: ../../reference/datamodel.rst:1560
msgid "Special method names"
msgstr "特殊メソッド名"

#: ../../reference/datamodel.rst:1566
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named :meth:"
"`~object.__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` "
"is roughly equivalent to ``type(x).__getitem__(x, i)``.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or :exc:"
"`TypeError`)."
msgstr ""
"クラスは、特殊な名前のメソッドを定義して、特殊な構文 (算術演算や添え字表記、"
"スライス表記など) による特定の演算を実装できます。これは、Python の演算子オー"
"バロード (:dfn:`operator overloading`) へのアプローチです。これにより、クラス"
"は言語の演算子に対する独自の振る舞いを定義できます。例えば、あるクラスが :"
"meth:`~object.__getitem__` という名前のメソッドを定義しており、 ``x`` がこの"
"クラスのインスタンスであるとすると、 ``x[i]`` は ``type(x).__getitem__(x, "
"i)`` とほぼ等価です。特に注釈のない限り、適切なメソッドが定義されていないと"
"き、このような演算を試みると例外 (たいていは :exc:`AttributeError` か :exc:"
"`TypeError`) が送出されます。"

#: ../../reference/datamodel.rst:1577
msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets :meth:`~object."
"__iter__` to ``None``, the class is not iterable, so calling :func:`iter` on "
"its instances will raise a :exc:`TypeError` (without falling back to :meth:"
"`~object.__getitem__`). [#]_"
msgstr ""
"特殊メソッドに ``None`` を設定することは、それに対応する演算が利用できないこ"
"とを意味します。\n"
"例えば、クラスの :meth:`~object.__iter__` を ``None`` に設定した場合、そのク"
"ラスはイテラブルにはならず、そのインスタンスに対し :func:`iter` を呼び出すと "
"(:meth:`~object.__getitem__` に処理が戻されずに) :exc:`TypeError` を送出しま"
"す。 [#]_"

#: ../../reference/datamodel.rst:1583
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for "
"the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make "
"sense.  (One example of this is the :class:`~xml.dom.NodeList` interface in "
"the W3C's Document Object Model.)"
msgstr ""
"組み込み型をエミュレートするクラスを実装するときは、模範とされるオブジェクト"
"にとって意味がある範囲に実装をとどめるのが重要です。例えば、あるシーケンスは"
"個々の要素の取得はきちんと動くかもしれませんが、スライスの展開が意味をなさな"
"いかもしれません。 (W3C のドキュメントオブジェクトモデルにある :class:`~xml."
"dom.NodeList` インターフェースがその一例です。)"

#: ../../reference/datamodel.rst:1594
msgid "Basic customization"
msgstr "基本的なカスタマイズ"

#: ../../reference/datamodel.rst:1600
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static "
"method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""
"クラス *cls* の新しいインスタンスを作るために呼び出されます。 :meth:"
"`__new__` は静的メソッドで (このメソッドは特別扱いされているので、明示的に静"
"的メソッドと宣言する必要はありません)、インスタンスを生成するよう要求されてい"
"るクラスを第一引数にとります。残りの引数はオブジェクトのコンストラクタの式 "
"(クラスの呼び出し文) に渡されます。 :meth:`__new__` の戻り値は新しいオブジェ"
"クトのインスタンス (通常は *cls* のインスタンス) でなければなりません。"

#: ../../reference/datamodel.rst:1607
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super().__new__(cls[, ...])`` "
"with appropriate arguments and then modifying the newly created instance as "
"necessary before returning it."
msgstr ""
"典型的な実装では、クラスの新たなインスタンスを生成するときには ``super()."
"__new__(cls[, ...])`` に適切な引数を指定してスーパクラスの :meth:`__new__` メ"
"ソッドを呼び出し、新たに生成されたインスタンスに必要な変更を加えてから返しま"
"す。"

#: ../../reference/datamodel.rst:1612
msgid ""
"If :meth:`__new__` is invoked during object construction and it returns an "
"instance of *cls*, then the new instance’s :meth:`__init__` method will be "
"invoked like ``__init__(self[, ...])``, where *self* is the new instance and "
"the remaining arguments are the same as were passed to the object "
"constructor."
msgstr ""
"もし :meth:`__new__` が オブジェクトの作成中に呼び出され、*cls* のインスタン"
"スを返した場合には、 ``__init__(self[, ...])`` のようにして新しいインスタンス"
"の :meth:`__init__` が呼び出されます。このとき、 *self* は新たに生成されたイ"
"ンスタンスで、残りの引数はオブジェクトコンストラクタに渡された引数と同じにな"
"ります。"

#: ../../reference/datamodel.rst:1617
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
":meth:`__new__` が *cls* のインスタンスを返さない場合、インスタンスの :meth:"
"`__init__` メソッドは呼び出されません。"

#: ../../reference/datamodel.rst:1620
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` の主な目的は、変更不能な型 (int, str, tuple など) のサブクラ"
"スでインスタンス生成をカスタマイズすることにあります。また、クラス生成をカス"
"タマイズするために、カスタムのメタクラスでよくオーバーライドされます。"

#: ../../reference/datamodel.rst:1629
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the "
"derived class's :meth:`__init__` method, if any, must explicitly call it to "
"ensure proper initialization of the base class part of the instance; for "
"example: ``super().__init__([args...])``."
msgstr ""
"インスタンスが (:meth:`__new__` によって) 生成された後、それが呼び出し元に返"
"される前に呼び出されます。引数はクラスのコンストラクタ式に渡したものです。基"
"底クラスとその派生クラスがともに :meth:`__init__` メソッドを持つ場合、派生ク"
"ラスの :meth:`__init__` メソッドは基底クラスの :meth:`__init__` メソッドを明"
"示的に呼び出して、インスタンスの基底クラス部分が適切に初期化されること保証し"
"なければなりません。例えば、 ``super().__init__([args...])`` 。"

#: ../../reference/datamodel.rst:1636
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customize "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""
":meth:`__new__` と :meth:`__init__` は連携してオブジェクトを構成する (:meth:"
"`__new__` が作成し、 :meth:`__init__` がそれをカスタマイズする) ので、 :meth:"
"`__init__` から非 ``None`` 値を返してはいけません; そうしてしまうと、実行時"
"に :exc:`TypeError` が送出されてしまいます。"

#: ../../reference/datamodel.rst:1649
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"finalizer or (improperly) a destructor.  If a base class has a :meth:"
"`__del__` method, the derived class's :meth:`__del__` method, if any, must "
"explicitly call it to ensure proper deletion of the base class part of the "
"instance."
msgstr ""
"インスタンスが破棄されるときに呼び出されます。\n"
"これはファイナライザや (適切ではありませんが) デストラクタとも呼ばれます。\n"
"基底クラスが :meth:`__del__` メソッドを持っている場合は、派生クラスの :meth:"
"`__del__` メソッドは何であれ、基底クラスの :meth:`__del__`  メソッドを明示的"
"に呼び出して、インスタンスの基底クラス部分をきちんと確実に削除しなければなり"
"ません。"

#: ../../reference/datamodel.rst:1655
msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  "
"This is called object *resurrection*.  It is implementation-dependent "
"whether :meth:`__del__` is called a second time when a resurrected object is "
"about to be destroyed; the current :term:`CPython` implementation only calls "
"it once."
msgstr ""
":meth:`__del__` メソッドが破棄しようとしているインスタンスへの新しい参照を作"
"り、破棄を送らせることは (推奨されないものの) 可能です。\n"
"これはオブジェクトの *復活* と呼ばれます。\n"
"復活したオブジェクトが再度破棄される直前に :meth:`__del__` が呼び出されるかど"
"うかは実装依存です;\n"
"現在の :term:`CPython` の実装では最初の一回しか呼び出されません。"

#: ../../reference/datamodel.rst:1662
msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits. :class:`weakref.finalize` "
"provides a straightforward way to register a cleanup function to be called "
"when an object is garbage collected."
msgstr ""

#: ../../reference/datamodel.rst:1669
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero."
msgstr ""
"``del x`` は直接 ``x.__del__()`` を呼び出しません --- 前者は ``x`` の参照カウ"
"ントを 1 つ減らし、後者は ``x`` の参照カウントが 0 まで落ちたときのみ呼び出さ"
"れます。"

#: ../../reference/datamodel.rst:1674
msgid ""
"It is possible for a reference cycle to prevent the reference count of an "
"object from going to zero.  In this case, the cycle will be later detected "
"and deleted by the :term:`cyclic garbage collector <garbage collection>`.  A "
"common cause of reference cycles is when an exception has been caught in a "
"local variable.  The frame's locals then reference the exception, which "
"references its own traceback, which references the locals of all frames "
"caught in the traceback."
msgstr ""

#: ../../reference/datamodel.rst:1684
msgid "Documentation for the :mod:`gc` module."
msgstr ":mod:`gc` モジュールのドキュメント。"

#: ../../reference/datamodel.rst:1688
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""
"メソッド :meth:`__del__` は不安定な状況で呼び出されるため、実行中に発生した例"
"外は無視され、代わりに ``sys.stderr`` に警告が表示されます。特に:"

#: ../../reference/datamodel.rst:1692
msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the resource "
"may already be taken by the code that gets interrupted to execute :meth:"
"`__del__`."
msgstr ""
":meth:`__del__` は、任意のコードが実行されているときに、任意のスレッドから呼"
"び出せます。\n"
":meth:`__del__` で、ロックを取ったり、ブロックするリソースを呼び出したりする"
"必要がある場合、 :meth:`__del__` の実行により中断されたコードにより、そのリ"
"ソースが既に取得されていて、デッドロックが起きるかもしれません。"

#: ../../reference/datamodel.rst:1698
msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python guarantees "
"that globals whose name begins with a single underscore are deleted from "
"their module before other globals are deleted; if no other references to "
"such globals exist, this may help in assuring that imported modules are "
"still available at the time when the :meth:`__del__` method is called."
msgstr ""
":meth:`__del__` は、インタプリタのシャットダウン中に実行できます。\n"
"従って、(他のモジュールも含めた) アクセスする必要があるグローバル変数はすでに"
"削除されているか、 ``None`` に設定されているかもしれません。\n"
"Python は、単一のアンダースコアで始まる名前のグローバルオブジェクトは、他のグ"
"ローバル変数が削除される前にモジュールから削除されることを保証します; そのよ"
"うなグローバル変数への他からの参照が存在しない場合、:meth:`__del__` メソッド"
"が呼ばれた時点で、インポートされたモジュールがまだ利用可能であることを保証す"
"るのに役立つかもしれません。"

#: ../../reference/datamodel.rst:1713
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look "
"like a valid Python expression that could be used to recreate an object with "
"the same value (given an appropriate environment).  If this is not possible, "
"a string of the form ``<...some useful description...>`` should be returned. "
"The return value must be a string object. If a class defines :meth:"
"`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used when "
"an \"informal\" string representation of instances of that class is required."
msgstr ""
":func:`repr` 組み込み関数によって呼び出され、オブジェクトを表す「公式の "
"(official)」文字列を計算します。可能なら、これは (適切な環境が与えられれば) "
"同じ値のオブジェクトを再生成するのに使える、有効な Python 式のようなものであ"
"るべきです。できないなら、 ``<...some useful description...>`` 形式の文字列が"
"返されるべきです。戻り値は文字列オブジェクトでなければなりません。クラスが :"
"meth:`__repr__` を定義していて :meth:`__str__` は定義していなければ、そのクラ"
"スのインスタンスの「非公式の (informal)」文字列表現が要求されたときにも :"
"meth:`__repr__` が使われます。"

#: ../../reference/datamodel.rst:1722
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr ""
"この関数はデバッグの際によく用いられるので、たくさんの情報を含み、あいまいで"
"ないような表記にすることが重要です。"

#: ../../reference/datamodel.rst:1733
msgid ""
"Called by :func:`str(object) <str>` and the built-in functions :func:"
"`format` and :func:`print` to compute the \"informal\" or nicely printable "
"string representation of an object.  The return value must be a :ref:`string "
"<textseq>` object."
msgstr ""
"オブジェクトの「非公式の (informal)」あるいは表示に適した文字列表現を計算する"
"ために、 :func:`str(object) <str>` と組み込み関数 :func:`format`, :func:"
"`print` によって呼ばれます。戻り値は :ref:`string <textseq>` オブジェクトでな"
"ければなりません。"

#: ../../reference/datamodel.rst:1738
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more "
"convenient or concise representation can be used."
msgstr ""
":meth:`__str__` が有効な Python 表現を返すことが期待されないという点で、この"
"メソッドは :meth:`object.__repr__` とは異なります: より便利な、または簡潔な表"
"現を使用することができます。"

#: ../../reference/datamodel.rst:1742
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""
"組み込み型 :class:`object` によって定義されたデフォルト実装は、 :meth:"
"`object.__repr__` を呼び出します。"

#: ../../reference/datamodel.rst:1752
msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string representation "
"of an object. This should return a :class:`bytes` object."
msgstr ""
":ref:`bytes <func-bytes>` によって呼び出され、オブジェクトのバイト文字列表現"
"を計算します。これは :class:`bytes` オブジェクトを返すべきです。"

#: ../../reference/datamodel.rst:1763
msgid ""
"Called by the :func:`format` built-in function, and by extension, evaluation "
"of :ref:`formatted string literals <f-strings>` and the :meth:`str.format` "
"method, to produce a \"formatted\" string representation of an object. The "
"*format_spec* argument is a string that contains a description of the "
"formatting options desired. The interpretation of the *format_spec* argument "
"is up to the type implementing :meth:`__format__`, however most classes will "
"either delegate formatting to one of the built-in types, or use a similar "
"formatting option syntax."
msgstr ""
":func:`format` 組み込み関数、さらには :ref:`フォーマット済み文字列リテラル "
"<f-strings>` の評価、 :meth:`str.format` メソッドによって呼び出され、オブジェ"
"クトの \"フォーマット化された (formatted)\" 文字列表現を作ります。 "
"*format_spec* 引数は、 必要なフォーマット化オプションの記述を含む文字列で"
"す。 *format_spec* 引数の解釈は、 :meth:`__format__` を実装する型によります"
"が、 ほとんどのクラスは組み込み型のいずれかにフォーマット化を委譲したり、 同"
"じようなフォーマット化オプション構文を使います。"

#: ../../reference/datamodel.rst:1773
msgid ""
"See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr ""
"標準のフォーマット構文の解説は、 :ref:`formatspec` を参照してください。"

#: ../../reference/datamodel.rst:1775
msgid "The return value must be a string object."
msgstr "戻り値は文字列オブジェクトでなければなりません。"

#: ../../reference/datamodel.rst:1777
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""
"空でない文字列が渡された場合 ``object`` 自身の __format__ メソッドは :exc:"
"`TypeError` を送出します。"

#: ../../reference/datamodel.rst:1781
msgid ""
"``object.__format__(x, '')`` is now equivalent to ``str(x)`` rather than "
"``format(str(x), '')``."
msgstr ""
"``object.__format__(x, '')`` は ``format(str(x), '')`` ではなく ``str(x)`` と"
"等価になりました。"

#: ../../reference/datamodel.rst:1797
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls ``x."
"__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, "
"``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls ``x.__gt__(y)``, and ``x>=y`` "
"calls ``x.__ge__(y)``."
msgstr ""
"これらはいわゆる \"拡張比較 (rich comparison)\" メソッドです。演算子シンボル"
"とメソッド名の対応は以下の通りです: ``x<y`` は ``x.__lt__(y)`` を呼び出しま"
"す; ``x<=y`` は ``x.__le__(y)`` を呼び出します; ``x==y`` は ``x.__eq__(y)`` "
"を呼び出します; ``x!=y`` は ``x.__ne__(y)`` を呼び出します; ``x>y`` は ``x."
"__gt__(y)`` を呼び出します; ``x>=y`` は ``x.__ge__(y)`` を呼び出します。"

#: ../../reference/datamodel.rst:1803
msgid ""
"A rich comparison method may return the singleton :data:`NotImplemented` if "
"it does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison. "
"However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""

#: ../../reference/datamodel.rst:1810
msgid ""
"By default, ``object`` implements :meth:`__eq__` by using ``is``, returning :"
"data:`NotImplemented` in the case of a false comparison: ``True if x is y "
"else NotImplemented``. For :meth:`__ne__`, by default it delegates to :meth:"
"`__eq__` and inverts the result unless it is :data:`!NotImplemented`.  There "
"are no other implied relationships among the comparison operators or default "
"implementations; for example, the truth of ``(x<y or x==y)`` does not imply "
"``x<=y``. To automatically generate ordering operations from a single root "
"operation, see :func:`functools.total_ordering`."
msgstr ""

#: ../../reference/datamodel.rst:1819
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on creating :"
"term:`hashable` objects which support custom comparison operations and are "
"usable as dictionary keys."
msgstr ""
"カスタムの比較演算をサポートしていて、辞書のキーに使うことができる :term:`"
"ハッシュ可能 <hashable>` オブジェクトを作るときの重要な注意点について、 :"
"meth:`__hash__` のドキュメント内に書かれているので参照してください。"

#: ../../reference/datamodel.rst:1823
msgid ""
"There are no swapped-argument versions of these methods (to be used when the "
"left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:"
"`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` "
"and :meth:`__ne__` are their own reflection. If the operands are of "
"different types, and the right operand's type is a direct or indirect "
"subclass of the left operand's type, the reflected method of the right "
"operand has priority, otherwise the left operand's method has priority.  "
"Virtual subclassing is not considered."
msgstr ""

#: ../../reference/datamodel.rst:1834
msgid ""
"When no appropriate method returns any value other than :data:"
"`NotImplemented`, the ``==`` and ``!=`` operators will fall back to ``is`` "
"and ``is not``, respectively."
msgstr ""

#: ../../reference/datamodel.rst:1843
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and :class:"
"`dict`.  The ``__hash__()`` method should return an integer. The only "
"required property is that objects which compare equal have the same hash "
"value; it is advised to mix together the hash values of the components of "
"the object that also play a part in comparison of objects by packing them "
"into a tuple and hashing the tuple. Example::"
msgstr ""
"組み込みの :func:`hash` 関数や、 :class:`set`, :class:`frozenset`, :class:"
"`dict` のようなハッシュを使ったコレクション型の要素に対する操作から呼び出され"
"ます。\n"
"``__hash__()`` メソッドは整数を返さなければなりません。\n"
"このメソッドに必要な性質は、比較結果が等しいオブジェクトは同じハッシュ値を持"
"つということです;\n"
"オブジェクトを比較するときでも利用される要素をタプルに詰めてハッシュ値を計算"
"することで、それぞれの要素のハッシュ値を混合することをおすすめします。"

#: ../../reference/datamodel.rst:1851
msgid ""
"def __hash__(self):\n"
"    return hash((self.name, self.nick, self.color))"
msgstr ""

#: ../../reference/datamodel.rst:1856
msgid ""
":func:`hash` truncates the value returned from an object's custom :meth:"
"`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is typically "
"8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an object's   :"
"meth:`__hash__` must interoperate on builds of different bit sizes, be sure "
"to check the width on all supported builds.  An easy way to do this is with "
"``python -c \"import sys; print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` はオブジェクト独自の :meth:`__hash__`  メソッドが返す値を :c:"
"type:`Py_ssize_t` のサイズに切り詰めます。\n"
"これは 64-bit でビルドされていると 8 バイトで、 32-bit でビルドされていると "
"4 バイトです。\n"
"オブジェクトの :meth:`__hash__` が異なる bit サイズのビルドでも可搬性が必要で"
"ある場合は、必ず全てのサポートするビルドの bit 幅をチェックしてください。\n"
"そうする簡単な方法は ``python -c \"import sys; print(sys.hash_info."
"width)\"`` を実行することです。"

#: ../../reference/datamodel.rst:1864
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define a :"
"meth:`__hash__` operation either; if it defines :meth:`__eq__` but not :meth:"
"`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an :meth:"
"`__eq__` method, it should not implement :meth:`__hash__`, since the "
"implementation of :term:`hashable` collections requires that a key's hash "
"value is immutable (if the object's hash value changes, it will be in the "
"wrong hash bucket)."
msgstr ""
"クラスが :meth:`__eq__` メソッドを定義していないなら、 :meth:`__hash__` メ"
"ソッドも定義してはなりません; クラスが :meth:`__eq__` を定義していても :meth:"
"`__hash__` を定義していないなら、そのインスタンスはハッシュ可能コレクションの"
"要素として使えません。クラスがミュータブルなオブジェクトを定義しており、 :"
"meth:`__eq__` メソッドを実装しているなら、 :meth:`__hash__` を定義してはなり"
"ません。これは、:term:`ハッシュ可能 <hashable>` コレクションの実装において"
"キーのハッシュ値がイミュータブルであることが要求されているからです (オブジェ"
"クトのハッシュ値が変化すると、誤ったハッシュバケツ: hash bucket に入ってしま"
"います)。"

#: ../../reference/datamodel.rst:1873
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) and "
"``x.__hash__()`` returns an appropriate value such that ``x == y`` implies "
"both that ``x is y`` and ``hash(x) == hash(y)``."
msgstr ""
"ユーザー定義クラスはデフォルトで :meth:`__eq__` と :meth:`__hash__` メソッド"
"を持っています。 このとき、(同一でない) すべてのオブジェクトは比較して異な"
"り、 ``x.__hash__()`` は ``x == y`` が ``x is y`` と ``hash(x) == hash(y)`` "
"の両方を意味するような適切な値を返します。"

#: ../../reference/datamodel.rst:1878
msgid ""
"A class that overrides :meth:`__eq__` and does not define :meth:`__hash__` "
"will have its :meth:`__hash__` implicitly set to ``None``.  When the :meth:"
"`__hash__` method of a class is ``None``, instances of the class will raise "
"an appropriate :exc:`TypeError` when a program attempts to retrieve their "
"hash value, and will also be correctly identified as unhashable when "
"checking ``isinstance(obj, collections.abc.Hashable)``."
msgstr ""
":meth:`__eq__` をオーバーライドしていて :meth:`__hash__` を定義していないクラ"
"スでは、 :meth:`__hash__` は暗黙的に ``None`` に設定されます。\n"
"クラスの :meth:`__hash__` メソッドが ``None`` の場合、そのクラスのインスタン"
"スのハッシュ値を取得しようとすると適切な :exc:`TypeError` が送出され、 "
"``isinstance(obj, collections.abc.Hashable)`` でチェックするとハッシュ不能な"
"ものとして正しく認識されます。"

#: ../../reference/datamodel.rst:1885
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the implementation "
"of :meth:`__hash__` from a parent class, the interpreter must be told this "
"explicitly by setting ``__hash__ = <ParentClass>.__hash__``."
msgstr ""
":meth:`__eq__` をオーバーライドしたクラスが親クラスからの :meth:`__hash__` "
"の 実装を保持したいなら、明示的に ``__hash__ = <ParentClass>.__hash__`` を設"
"定することで、それをインタプリタに伝えなければなりません。"

#: ../../reference/datamodel.rst:1889
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A "
"class which defines its own :meth:`__hash__` that explicitly raises a :exc:"
"`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.abc.Hashable)`` call."
msgstr ""
":meth:`__eq__` をオーバーライドしていないクラスがハッシュサポートを抑制したい"
"場合、クラス定義に ``__hash__ = None`` を含めてください。クラス自身で明示的"
"に :exc:`TypeError` を送出する :meth:`__hash__` を定義すると、 "
"``isinstance(obj, collections.abc.Hashable)`` 呼び出しで誤ってハッシュ可能と"
"識別されるでしょう。"

#: ../../reference/datamodel.rst:1898
msgid ""
"By default, the :meth:`__hash__` values of str and bytes objects are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""
"デフォルトでは、文字列とバイト列の :meth:`__hash__` 値は予測不可能なランダム"
"値で \"ソルト\" されます。 ハッシュ値は単独の Python プロセス内では定数であり"
"続けますが、Python を繰り返し起動する毎に、予測できなくなります。"

#: ../../reference/datamodel.rst:1903
msgid ""
"This is intended to provide protection against a denial-of-service caused by "
"carefully chosen inputs that exploit the worst case performance of a dict "
"insertion, *O*\\ (*n*\\ :sup:`2`) complexity.  See http://ocert.org/"
"advisories/ocert-2011-003.html for details."
msgstr ""

#: ../../reference/datamodel.rst:1908
msgid ""
"Changing hash values affects the iteration order of sets. Python has never "
"made guarantees about this ordering (and it typically varies between 32-bit "
"and 64-bit builds)."
msgstr ""
"ハッシュ値の変更は、集合のイテレーション順序に影響します。Python はこの順序付"
"けを保証していません (そして通常 32-bit と 64-bit の間でも異なります)。"

#: ../../reference/datamodel.rst:1912
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr ":envvar:`PYTHONHASHSEED` も参照してください。"

#: ../../reference/datamodel.rst:1914
msgid "Hash randomization is enabled by default."
msgstr "ハッシュのランダム化がデフォルトで有効になりました。"

#: ../../reference/datamodel.rst:1922
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not "
"defined, :meth:`~object.__len__` is called, if it is defined, and the object "
"is considered true if its result is nonzero.  If a class defines neither :"
"meth:`!__len__` nor :meth:`!__bool__`, all its instances are considered true."
msgstr ""

#: ../../reference/datamodel.rst:1933
msgid "Customizing attribute access"
msgstr "属性値アクセスをカスタマイズする"

#: ../../reference/datamodel.rst:1935
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""
"以下のメソッドを定義して、クラスインスタンスへの属性アクセス ( ``x.name`` の"
"使用、 ``x.name`` への代入、 ``x.name`` の削除) の意味をカスタマイズすること"
"ができます。"

#: ../../reference/datamodel.rst:1943
msgid ""
"Called when the default attribute access fails with an :exc:`AttributeError` "
"(either :meth:`__getattribute__` raises an :exc:`AttributeError` because "
"*name* is not an instance attribute or an attribute in the class tree for "
"``self``; or :meth:`__get__` of a *name* property raises :exc:"
"`AttributeError`).  This method should either return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception."
msgstr ""
"デフォルトの属性アクセスが :exc:`AttributeError` で失敗したとき (*name* がイ"
"ンスタンスの属性または ``self`` のクラスツリーの属性でないために :meth:"
"`__getattribute__` が :exc:`AttributeError` を送出したか、 *name* プロパティ"
"の :meth:`__get__` が :exc:`AttributeError` を送出したとき) に呼び出されま"
"す。\n"
"このメソッドは (計算された) 属性値を返すか、 :exc:`AttributeError` 例外を送出"
"しなければなりません。"

#: ../../reference/datamodel.rst:1950
msgid ""
"Note that if the attribute is found through the normal mechanism, :meth:"
"`__getattr__` is not called.  (This is an intentional asymmetry between :"
"meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can take total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control over attribute access."
msgstr ""

#: ../../reference/datamodel.rst:1963
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be "
"called unless :meth:`__getattribute__` either calls it explicitly or raises "
"an :exc:`AttributeError`. This method should return the (computed) attribute "
"value or raise an :exc:`AttributeError` exception. In order to avoid "
"infinite recursion in this method, its implementation should always call the "
"base class method with the same name to access any attributes it needs, for "
"example, ``object.__getattribute__(self, name)``."
msgstr ""
"クラスのインスタンスに対する属性アクセスを実装するために、無条件に呼び出され"
"ます。クラスが :meth:`__getattr__` も定義している場合、 :meth:`__getattr__` "
"は、 :meth:`__getattribute__` で明示的に呼び出すか、 :exc:`AttributeError` 例"
"外を送出しない限り呼ばれません。このメソッドは (計算された) 属性値を返す"
"か、 :exc:`AttributeError` 例外を送出します。このメソッドが再帰的に際限なく呼"
"び出されてしまうのを防ぐため、実装の際には常に、必要な属性全てへのアクセス"
"で、例えば ``object.__getattribute__(self, name)`` のように基底クラスのメソッ"
"ドを同じ属性名を使って呼び出さなければなりません。"

#: ../../reference/datamodel.rst:1974
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or :ref:`built-in "
"functions <builtin-functions>`. See :ref:`special-lookup`."
msgstr ""

#: ../../reference/datamodel.rst:1979 ../../reference/datamodel.rst:1981
msgid ""
"For certain sensitive attribute accesses, raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"セキュリティに関わるような ``obj`` と ``name`` を渡しての ``object."
"__getattr__`` を使った属性アクセスは :ref:`監査イベント <auditing>` を送出し"
"ます。"

#: ../../reference/datamodel.rst:1988
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of "
"the normal mechanism (i.e. store the value in the instance dictionary). "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""
"属性の代入が試みられた際に呼び出されます。これは通常の代入の過程 (すなわち、"
"インスタンス辞書への値の代入) の代わりに呼び出されます。*name* は属性名で、"
"*value* はその属性に代入する値です。"

#: ../../reference/datamodel.rst:1992
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"call the base class method with the same name, for example, ``object."
"__setattr__(self, name, value)``."
msgstr ""
":meth:`__setattr__` の中でインスタンス属性への代入が必要なら、基底クラスのこ"
"れと同じ名前のメソッドを呼び出さなければなりません。例えば、 ``object."
"__setattr__(self, name, value)`` とします。"

#: ../../reference/datamodel.rst:1996 ../../reference/datamodel.rst:1998
msgid ""
"For certain sensitive attribute assignments, raises an :ref:`auditing event "
"<auditing>` ``object.__setattr__`` with arguments ``obj``, ``name``, "
"``value``."
msgstr ""
"セキュリティに関わるような ``obj`` と ``name`` と ``value`` を渡しての "
"``object.__setattr__`` を使った属性のアサインは :ref:`監査イベント "
"<auditing>` を送出します。"

#: ../../reference/datamodel.rst:2005
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""
":meth:`__setattr__` に似ていますが、代入ではなく値の削除を行います。このメ"
"ソッドを実装するのは、オブジェクトにとって ``del obj.name`` が意味がある場合"
"だけにしなければなりません。"

#: ../../reference/datamodel.rst:2008 ../../reference/datamodel.rst:2010
msgid ""
"For certain sensitive attribute deletions, raises an :ref:`auditing event "
"<auditing>` ``object.__delattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"セキュリティに関わるような ``obj`` と ``name`` を渡しての ``object."
"__getattr__`` を使った属性の削除は :ref:`監査イベント <auditing>` を送出しま"
"す。"

#: ../../reference/datamodel.rst:2017
msgid ""
"Called when :func:`dir` is called on the object. An iterable must be "
"returned. :func:`dir` converts the returned iterable to a list and sorts it."
msgstr ""

#: ../../reference/datamodel.rst:2022
msgid "Customizing module attribute access"
msgstr "モジュールの属性値アクセスをカスタマイズする"

#: ../../reference/datamodel.rst:2029
msgid ""
"Special names ``__getattr__`` and ``__dir__`` can be also used to customize "
"access to module attributes. The ``__getattr__`` function at the module "
"level should accept one argument which is the name of an attribute and "
"return the computed value or raise an :exc:`AttributeError`. If an attribute "
"is not found on a module object through the normal lookup, i.e. :meth:"
"`object.__getattribute__`, then ``__getattr__`` is searched in the module "
"``__dict__`` before raising an :exc:`AttributeError`. If found, it is called "
"with the attribute name and the result is returned."
msgstr ""
"特殊な名前の ``__getattr__`` と ``__dir__`` も、モジュール属性へのアクセスを"
"カスタマイズするのに使えます。\n"
"モジュールレベルの ``__getattr__`` 関数は属性名である 1 引数を受け取り、計算"
"した値を返すか :exc:`AttributeError` を送出します。\n"
"属性がモジュールオブジェクトから、通常の検索、つまり :meth:`object."
"__getattribute__` で見付からなかった場合は、 :exc:`AttributeError` を送出する"
"前に、モジュールの ``__dict__`` から ``__getattr__`` が検索されます。\n"
"見付かった場合は、その属性名で呼び出され、結果が返されます。"

#: ../../reference/datamodel.rst:2038
msgid ""
"The ``__dir__`` function should accept no arguments, and return an iterable "
"of strings that represents the names accessible on module. If present, this "
"function overrides the standard :func:`dir` search on a module."
msgstr ""

#: ../../reference/datamodel.rst:2042
msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of a "
"module object to a subclass of :class:`types.ModuleType`. For example::"
msgstr ""
"より細かい粒度でのモジュールの動作 (属性やプロパティの設定など) のカスタマイ"
"ズのために、モジュールオブジェクトの ``__class__`` 属性に :class:`types."
"ModuleType` のサブクラスが設定できます。\n"
"例えば次のようになります::"

#: ../../reference/datamodel.rst:2046
msgid ""
"import sys\n"
"from types import ModuleType\n"
"\n"
"class VerboseModule(ModuleType):\n"
"    def __repr__(self):\n"
"        return f'Verbose {self.__name__}'\n"
"\n"
"    def __setattr__(self, attr, value):\n"
"        print(f'Setting {attr}...')\n"
"        super().__setattr__(attr, value)\n"
"\n"
"sys.modules[__name__].__class__ = VerboseModule"
msgstr ""

#: ../../reference/datamodel.rst:2060
msgid ""
"Defining module ``__getattr__`` and setting module ``__class__`` only affect "
"lookups made using the attribute access syntax -- directly accessing the "
"module globals (whether by code within the module, or via a reference to the "
"module's globals dictionary) is unaffected."
msgstr ""
"モジュールの ``__getattr__`` を定義したり ``__class__`` を設定したりしても、"
"影響があるのは属性アクセスの構文が使われる検索だけです -- モジュールの "
"globals への直接アクセスは (モジュール内のコードからとモジュールの globals の"
"どちらでも) 影響を受けません。"

#: ../../reference/datamodel.rst:2065
msgid "``__class__`` module attribute is now writable."
msgstr "モジュールの属性 ``__class__`` が書き込み可能になりました。"

#: ../../reference/datamodel.rst:2068
msgid "``__getattr__`` and ``__dir__`` module attributes."
msgstr "``__getattr__`` モジュール属性と ``__dir__`` モジュール属性。"

#: ../../reference/datamodel.rst:2073
msgid ":pep:`562` - Module __getattr__ and __dir__"
msgstr ":pep:`562` - モジュールの __getattr__ と __dir__"

#: ../../reference/datamodel.rst:2074
msgid "Describes the ``__getattr__`` and ``__dir__`` functions on modules."
msgstr "モジュールの ``__getattr__`` 関数および ``__dir__`` 関数の説明。"

#: ../../reference/datamodel.rst:2080
msgid "Implementing Descriptors"
msgstr "デスクリプタ (descriptor) の実装"

#: ../../reference/datamodel.rst:2082
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the "
"descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property in "
"the owner class' :attr:`~object.__dict__`."
msgstr ""
"以下のメソッドは、このメソッドを持つクラス (いわゆる *デスクリプタ"
"(descriptor)* クラス) のインスタンスが、 *オーナー (owner)* クラスに存在する"
"ときにのみ適用されます (デスクリプタは、オーナーのクラス辞書か、その親のいず"
"れかのクラス辞書になければなりません)。\n"
"以下の例では、\"属性\" とは、名前がオーナークラスの :attr:`~object.__dict__` "
"のプロパティ (porperty) のキーであるような属性を指します。"

#: ../../reference/datamodel.rst:2092
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). The optional "
"*owner* argument is the owner class, while *instance* is the instance that "
"the attribute was accessed through, or ``None`` when the attribute is "
"accessed through the *owner*."
msgstr ""
"オーナークラス（クラス属性アクセスの場合）や、クラスのインスタンス（インスタ"
"ンス属性アクセスの場合）の属性取得時に呼び出されます。 *instance*  を通じて属"
"性をアクセスする時に、オプションの *owner* 引数はオーナークラスです。 "
"*owner* を通じて属性アクセスするときは ``None`` です。"

#: ../../reference/datamodel.rst:2098
msgid ""
"This method should return the computed attribute value or raise an :exc:"
"`AttributeError` exception."
msgstr ""
"このメソッドは、算出された属性値を返すか、 :exc:`AttributeError` 例外を送出し"
"ます。"

#: ../../reference/datamodel.rst:2101
msgid ""
":PEP:`252` specifies that :meth:`__get__` is callable with one or two "
"arguments.  Python's own built-in descriptors support this specification; "
"however, it is likely that some third-party tools have descriptors that "
"require both arguments.  Python's own :meth:`__getattribute__` "
"implementation always passes in both arguments whether they are required or "
"not."
msgstr ""
":PEP:`252` は :meth:`__get__` は1つや2つの引数を持つ呼び出し可能オブジェクト"
"であると定義しています。Pythonの組み込みのデスクリプタはこの仕様をサポートし"
"ていますが、サードパーティ製のツールの中には両方の引数を必要とするものもあり"
"ます。Pythonの :meth:`__getattribute__` 実装は必要かどうかに関わらず、両方の"
"引数を常に渡します。"

#: ../../reference/datamodel.rst:2110
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr ""
"オーナークラスのインスタンス *instance* 上の属性を新たな値 *value* に設定する"
"際に呼び出されます。"

#: ../../reference/datamodel.rst:2113
msgid ""
"Note, adding :meth:`__set__` or :meth:`__delete__` changes the kind of "
"descriptor to a \"data descriptor\".  See :ref:`descriptor-invocation` for "
"more details."
msgstr ""
":meth:`__set__` あるいは :meth:`__delete__` を追加すると、デスクリプタは"
"「データデスクリプタ」に変わります。詳細は :ref:`descriptor-invocation` を参"
"照してください。"

#: ../../reference/datamodel.rst:2119
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""
"オーナークラスのインスタンス *instance* 上の属性を削除する際に呼び出されま"
"す。"

#: ../../reference/datamodel.rst:2121
msgid ""
"Instances of descriptors may also have the :attr:`!__objclass__` attribute "
"present:"
msgstr ""

#: ../../reference/datamodel.rst:2126
msgid ""
"The attribute :attr:`!__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting this "
"appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given "
"type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods that "
"are implemented in C)."
msgstr ""

#: ../../reference/datamodel.rst:2137
msgid "Invoking Descriptors"
msgstr "デスクリプタの呼び出し"

#: ../../reference/datamodel.rst:2139
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`~object.__get__`, :meth:`~object.__set__`, and :meth:"
"`~object.__delete__`. If any of those methods are defined for an object, it "
"is said to be a descriptor."
msgstr ""
"一般にデスクリプタとは、特殊な \"束縛に関する動作 (binding behaviour)\" をも"
"つオブジェクト属性のことです。デスクリプタは、デスクリプタプロトコル "
"(descriptor protocol) のメソッド: :meth:`~object.__get__`, :meth:`~object."
"__set__`, および :meth:`~object.__delete__` を使って、属性アクセスをオーバー"
"ライドしているものです。これらのメソッドのいずれかがオブジェクトに対して定義"
"されている場合、オブジェクトはデスクリプタであるといいます。"

#: ../../reference/datamodel.rst:2145
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"属性アクセスのデフォルトの動作は、オブジェクトの辞書から値を取り出したり、値"
"を設定したり、削除したりするというものです。例えば、 ``a.x`` による属性の検索"
"では、まず ``a.__dict__['x']`` 、次に ``type(a).__dict__['x']`` 、そして "
"``type(a)`` の基底クラスでメタクラスでないものに続く、といった具合に連鎖が起"
"こります。"

#: ../../reference/datamodel.rst:2150
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called."
msgstr ""
"しかし、検索対象の値が、デスクリプタメソッドのいずれかを定義しているオブジェ"
"クトであれば、Python はデフォルトの動作をオーバーライドして、代わりにデスクリ"
"プタメソッドを呼び出します。先述の連鎖の中のどこでデスクリプタメソッドが呼び"
"出されるかは、どのデスクリプタメソッドが定義されていて、どのように呼び出され"
"たかに依存します。"

#: ../../reference/datamodel.rst:2155
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""
"デスクリプタ呼び出しの基点となるのは、属性名への束縛 (binding) 、すなわち "
"``a.x`` です。引数がどのようにデスクリプタに結合されるかは ``a`` に依存しま"
"す:"

#: ../../reference/datamodel.rst:2158
msgid "Direct Call"
msgstr "直接呼び出し (Direct Call)"

#: ../../reference/datamodel.rst:2159
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""
"最も単純で、かつめったに使われない呼び出し操作は、コード中で直接デスクリプタ"
"メソッドの呼び出し: ``x.__get__(a)`` を行うというものです。"

#: ../../reference/datamodel.rst:2162
msgid "Instance Binding"
msgstr "インスタンス束縛 (Instance Binding)"

#: ../../reference/datamodel.rst:2163
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"オブジェクトインスタンスへ束縛すると、``a.x`` は呼び出し ``type(a)."
"__dict__['x'].__get__(a, type(a))`` に変換されます。"

#: ../../reference/datamodel.rst:2166
msgid "Class Binding"
msgstr "クラス束縛 (Class Binding)"

#: ../../reference/datamodel.rst:2167
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: ``A."
"__dict__['x'].__get__(None, A)``."
msgstr ""
"クラスへ束縛すると、``A.x`` は呼び出し ``A.__dict__['x'].__get__(None, A)`` "
"に変換されます。"

#: ../../reference/datamodel.rst:2170
msgid "Super Binding"
msgstr "super 束縛 (Super Binding)"

#: ../../reference/datamodel.rst:2171
msgid ""
"A dotted lookup such as ``super(A, a).x`` searches ``a.__class__.__mro__`` "
"for a base class ``B`` following ``A`` and then returns ``B.__dict__['x']."
"__get__(a, A)``.  If not a descriptor, ``x`` is returned unchanged."
msgstr ""
"``super(A, a).x`` のようなドットを使ったルックアップは ``a.__class__."
"__mro__`` を探索して、 ``A`` の前のクラス ``B`` をまず探し、 ``B."
"__dict__['x'].__get__(a, A)`` を返します。もしデスクリプタでなければ ``x`` を"
"変更せずに返します。"

#: ../../reference/datamodel.rst:2208
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`~object.__get__`, :meth:`~object.__set__` and :meth:"
"`~object.__delete__`.  If it does not define :meth:`!__get__`, then "
"accessing the attribute will return the descriptor object itself unless "
"there is a value in the object's instance dictionary.  If the descriptor "
"defines :meth:`!__set__` and/or :meth:`!__delete__`, it is a data "
"descriptor; if it defines neither, it is a non-data descriptor.  Normally, "
"data descriptors define both :meth:`!__get__` and :meth:`!__set__`, while "
"non-data descriptors have just the :meth:`!__get__` method.  Data "
"descriptors with :meth:`!__get__` and :meth:`!__set__` (and/or :meth:`!"
"__delete__`) defined always override a redefinition in an instance "
"dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr ""

#: ../../reference/datamodel.rst:2223
msgid ""
"Python methods (including those decorated with :func:`@staticmethod "
"<staticmethod>` and :func:`@classmethod <classmethod>`) are implemented as "
"non-data descriptors.  Accordingly, instances can redefine and override "
"methods.  This allows individual instances to acquire behaviors that differ "
"from other instances of the same class."
msgstr ""
"(:func:`@staticmethod <staticmethod>` や :func:`@classmethod <classmethod>` "
"を含む) Python メソッドは、非データデスクリプタとして実装されています。その結"
"果、インスタンスではメソッドを再定義したりオーバーライドできます。このことに"
"より、個々のインスタンスが同じクラスの他のインスタンスと互いに異なる動作を獲"
"得することができます。"

#: ../../reference/datamodel.rst:2229
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
":func:`property` 関数はデータデスクリプタとして実装されています。従って、イン"
"スタンスはあるプロパティの動作をオーバーライドすることができません。"

#: ../../reference/datamodel.rst:2236
msgid "__slots__"
msgstr "__slots__"

#: ../../reference/datamodel.rst:2238
msgid ""
"*__slots__* allow us to explicitly declare data members (like properties) "
"and deny the creation of :attr:`~object.__dict__` and *__weakref__* (unless "
"explicitly declared in *__slots__* or available in a parent.)"
msgstr ""
"*__slots__* を使うと、(プロパティのように) データメンバを明示的に宣言し、 (明"
"示的に *__slots__* で宣言しているか親クラスに存在しているかでない限り) :attr:"
"`~object.__dict__` や *__weakref__* を作成しないようにできます。"

#: ../../reference/datamodel.rst:2242
msgid ""
"The space saved over using :attr:`~object.__dict__` can be significant. "
"Attribute lookup speed can be significantly improved as well."
msgstr ""
":attr:`~object.__dict__` を使うのに比べて、節約できるメモリ空間はかなり大きい"
"です。\n"
"属性探索のスピードもかなり向上できます。"

#: ../../reference/datamodel.rst:2247
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves space "
"for the declared variables and prevents the automatic creation of :attr:"
"`~object.__dict__` and *__weakref__* for each instance."
msgstr ""
"このクラス変数には、インスタンスが用いる変数名を表す、文字列、イテラブル、ま"
"たは文字列のシーケンスを代入できます。*__slots__* は、各インスタンスに対して"
"宣言された変数に必要な記憶領域を確保し、:attr:`~object.__dict__` と "
"*__weakref__* が自動的に生成されないようにします。"

#: ../../reference/datamodel.rst:2256
msgid "Notes on using *__slots__*:"
msgstr ""

#: ../../reference/datamodel.rst:2258
msgid ""
"When inheriting from a class without *__slots__*, the :attr:`~object."
"__dict__` and *__weakref__* attribute of the instances will always be "
"accessible."
msgstr ""
"*__slots__* を持たないクラスから継承するとき、インスタンスの :attr:`~object."
"__dict__` 属性と *__weakref__* 属性は常に利用可能です。"

#: ../../reference/datamodel.rst:2262
msgid ""
"Without a :attr:`~object.__dict__` variable, instances cannot be assigned "
"new variables not listed in the *__slots__* definition.  Attempts to assign "
"to an unlisted variable name raises :exc:`AttributeError`. If dynamic "
"assignment of new variables is desired, then add ``'__dict__'`` to the "
"sequence of strings in the *__slots__* declaration."
msgstr ""
":attr:`~object.__dict__` 変数がない場合、 *__slots__* に列挙されていない新た"
"な変数をインスタンスに代入することはできません。列挙されていない変数名を使っ"
"て代入しようとした場合、 :exc:`AttributeError` が送出されます。新たな変数を動"
"的に代入したいのなら、 *__slots__* を宣言する際に ``'__dict__'`` を変数名の"
"シーケンスに追加してください。"

#: ../../reference/datamodel.rst:2269
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support :mod:`weak references <weakref>` to its "
"instances. If weak reference support is needed, then add ``'__weakref__'`` "
"to the sequence of strings in the *__slots__* declaration."
msgstr ""
"*__slots__* を定義しているクラスの各インスタンスに *__weakref__* 変数がない場"
"合、インスタンスに対する弱参照 (:mod:`weak references <weakref>`) はサポート"
"されません。弱参照のサポートが必要なら、 *__slots__* を宣言する際に "
"``'__weakref__'`` を変数名のシーケンスに追加してください。"

#: ../../reference/datamodel.rst:2275
msgid ""
"*__slots__* are implemented at the class level by creating :ref:`descriptors "
"<descriptors>` for each variable name.  As a result, class attributes cannot "
"be used to set default values for instance variables defined by *__slots__*; "
"otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""
"*__slots__* は、クラスのレベルで各変数に対する :ref:`デスクリプタ "
"<descriptors>` を使って実装されます。その結果、 *__slots__* に定義されている"
"インスタンス変数のデフォルト値はクラス属性を使って設定できなくなっています; "
"そうしないと、デスクリプタによる代入をクラス属性が上書きしてしまうからです。"

#: ../../reference/datamodel.rst:2281
msgid ""
"The action of a *__slots__* declaration is not limited to the class where it "
"is defined.  *__slots__* declared in parents are available in child classes. "
"However, child subclasses will get a :attr:`~object.__dict__` and "
"*__weakref__* unless they also define *__slots__* (which should only contain "
"names of any *additional* slots)."
msgstr ""
"*__slots__* の宣言の作用は、それが定義されたクラスだけには留まりません。\n"
"親クラスで宣言された *__slots__* は子クラスでも利用可能です。\n"
"ただし、子クラスは、自身も *__slots__* (ここには *追加の* スロットの名前のみ"
"含めるべき) を定義しない限り :attr:`~object.__dict__` や *__weakref__* を持ち"
"ます。"

#: ../../reference/datamodel.rst:2287
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""
"あるクラスで、基底クラスですでに定義されているスロットを定義した場合、基底ク"
"ラスのスロットで定義されているインスタンス変数は (デスクリプタを基底クラスか"
"ら直接取得しない限り) アクセスできなくなります。これにより、プログラムの趣意"
"が不定になってしまいます。将来は、この問題を避けるために何らかのチェックが追"
"加されるかもしれません。"

#: ../../reference/datamodel.rst:2292
msgid ""
":exc:`TypeError` will be raised if nonempty *__slots__* are defined for a "
"class derived from a :c:member:`\"variable-length\" built-in type "
"<PyTypeObject.tp_itemsize>` such as :class:`int`, :class:`bytes`, and :class:"
"`tuple`."
msgstr ""

#: ../../reference/datamodel.rst:2297
msgid "Any non-string :term:`iterable` may be assigned to *__slots__*."
msgstr ""

#: ../../reference/datamodel.rst:2299
msgid ""
"If a :class:`dictionary <dict>` is used to assign *__slots__*, the "
"dictionary keys will be used as the slot names. The values of the dictionary "
"can be used to provide per-attribute docstrings that will be recognised by :"
"func:`inspect.getdoc` and displayed in the output of :func:`help`."
msgstr ""

#: ../../reference/datamodel.rst:2304
msgid ""
":attr:`~instance.__class__` assignment works only if both classes have the "
"same *__slots__*."
msgstr ""
":attr:`~instance.__class__` への代入は、両方のクラスが同じ *__slots__* を持っ"
"ているときのみ動作します。"

#: ../../reference/datamodel.rst:2307
msgid ""
":ref:`Multiple inheritance <tut-multiple>` with multiple slotted parent "
"classes can be used, but only one parent is allowed to have attributes "
"created by slots (the other bases must have empty slot layouts) - violations "
"raise :exc:`TypeError`."
msgstr ""
"複数のスロットを持つ親クラスを使った :ref:`多重継承 <tut-multiple>` はできま"
"すが、スロットで作成された属性を持つ親クラスは 1 つに限られます (他の基底クラ"
"スのスロットは空でなければなりません) - それに違反すると :exc:`TypeError` が"
"送出されます。"

#: ../../reference/datamodel.rst:2313
msgid ""
"If an :term:`iterator` is used for *__slots__* then a :term:`descriptor` is "
"created for each of the iterator's values. However, the *__slots__* "
"attribute will be an empty iterator."
msgstr ""
"もし *__slots__* に対して :term:`イテレータ <iterator>` を使用すると、イテ"
"レータの値ごとに :term:`デスクリプタ <descriptor>` が作られます。しかし、 "
"*__slots__* 属性は空のイテレータとなります。"

#: ../../reference/datamodel.rst:2321
msgid "Customizing class creation"
msgstr "クラス生成をカスタマイズする"

#: ../../reference/datamodel.rst:2323
msgid ""
"Whenever a class inherits from another class, :meth:`~object."
"__init_subclass__` is called on the parent class. This way, it is possible "
"to write classes which change the behavior of subclasses. This is closely "
"related to class decorators, but where class decorators only affect the "
"specific class they're applied to, ``__init_subclass__`` solely applies to "
"future subclasses of the class defining the method."
msgstr ""
"クラスが他のクラスを継承するときに必ず、親クラスの :meth:`~object."
"__init_subclass__` が呼び出されます。これを利用すると、サブクラスの挙動を変更"
"するクラスを書くことができます。これは、クラスデコレータととても良く似ていま"
"すが、クラスデコレータが、それが適用された特定のクラスにのみに影響するのに対"
"して、 ``__init_subclass__`` は、もっぱら、このメソッドを定義したクラスの将来"
"のサブクラスに適用されます。"

#: ../../reference/datamodel.rst:2332
msgid ""
"This method is called whenever the containing class is subclassed. *cls* is "
"then the new subclass. If defined as a normal instance method, this method "
"is implicitly converted to a class method."
msgstr ""
"このメソッドは、それが定義されたクラスが継承された際に必ず呼び出されます。"
"*cls* は新しいサブクラスです。もし、このメソッドがインスタンスメソッドとして"
"定義されると、暗黙的にクラスメソッドに変換されます。"

#: ../../reference/datamodel.rst:2336
msgid ""
"Keyword arguments which are given to a new class are passed to the parent "
"class's ``__init_subclass__``. For compatibility with other classes using "
"``__init_subclass__``, one should take out the needed keyword arguments and "
"pass the others over to the base class, as in::"
msgstr ""

#: ../../reference/datamodel.rst:2342
msgid ""
"class Philosopher:\n"
"    def __init_subclass__(cls, /, default_name, **kwargs):\n"
"        super().__init_subclass__(**kwargs)\n"
"        cls.default_name = default_name\n"
"\n"
"class AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\n"
"    pass"
msgstr ""

#: ../../reference/datamodel.rst:2350
msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but "
"raises an error if it is called with any arguments."
msgstr ""
"``object.__init_subclass__`` のデフォルト実装は何も行いませんが、何らかの引数"
"とともに呼び出された場合は、エラーを送出します。"

#: ../../reference/datamodel.rst:2355
msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. The "
"actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""
"メタクラスのヒント ``metaclass`` は残りの型機構によって消費され、 "
"``__init_subclass__`` 実装に渡されることはありません。\n"
"実際のメタクラス (明示的なヒントではなく) は、 ``type(cls)`` としてアクセスで"
"きます。"

#: ../../reference/datamodel.rst:2363
msgid ""
"When a class is created, :meth:`type.__new__` scans the class variables and "
"makes callbacks to those with a :meth:`~object.__set_name__` hook."
msgstr ""

#: ../../reference/datamodel.rst:2368
msgid ""
"Automatically called at the time the owning class *owner* is created. The "
"object has been assigned to *name* in that class::"
msgstr ""
"オーナーとなるクラス *owner* が作成された時点で自動的に呼び出されます。\n"
"オブジェクトはそのクラスの *name* に割り当てられます。"

#: ../../reference/datamodel.rst:2371
msgid ""
"class A:\n"
"    x = C()  # Automatically calls: x.__set_name__(A, 'x')"
msgstr ""

#: ../../reference/datamodel.rst:2374
msgid ""
"If the class variable is assigned after the class is created, :meth:"
"`__set_name__` will not be called automatically. If needed, :meth:"
"`__set_name__` can be called directly::"
msgstr ""

#: ../../reference/datamodel.rst:2378
msgid ""
"class A:\n"
"   pass\n"
"\n"
"c = C()\n"
"A.x = c                  # The hook is not called\n"
"c.__set_name__(A, 'x')   # Manually invoke the hook"
msgstr ""

#: ../../reference/datamodel.rst:2385
msgid "See :ref:`class-object-creation` for more details."
msgstr "詳細は :ref:`class-object-creation` を参照してください。"

#: ../../reference/datamodel.rst:2393
msgid "Metaclasses"
msgstr "メタクラス"

#: ../../reference/datamodel.rst:2400
msgid ""
"By default, classes are constructed using :func:`type`. The class body is "
"executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"デフォルトでは、クラスは :func:`type` を使って構築されます。 クラス本体は新し"
"い名前空間で実行され、クラス名が ``type(name, bases, namespace)`` の結果に"
"ローカルに束縛されます。"

#: ../../reference/datamodel.rst:2404
msgid ""
"The class creation process can be customized by passing the ``metaclass`` "
"keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"クラス生成プロセスはカスタマイズできます。\n"
"そのためにはクラス定義行で ``metaclass`` キーワード引数を渡すか、そのような引"
"数を定義行に含む既存のクラスを継承します。\n"
"次の例で ``MyClass`` と ``MySubclass`` は両方とも ``Meta`` のインスタンスで"
"す::"

#: ../../reference/datamodel.rst:2409
msgid ""
"class Meta(type):\n"
"    pass\n"
"\n"
"class MyClass(metaclass=Meta):\n"
"    pass\n"
"\n"
"class MySubclass(MyClass):\n"
"    pass"
msgstr ""

#: ../../reference/datamodel.rst:2418
msgid ""
"Any other keyword arguments that are specified in the class definition are "
"passed through to all metaclass operations described below."
msgstr ""
"クラス定義の中で指定された他のキーワード引数は、後述するすべてのメタクラス操"
"作に渡されます。"

#: ../../reference/datamodel.rst:2421
msgid "When a class definition is executed, the following steps occur:"
msgstr "クラス定義が実行される際に、以下のステップが生じます:"

#: ../../reference/datamodel.rst:2423
msgid "MRO entries are resolved;"
msgstr "MRO エントリの解決が行われる;"

#: ../../reference/datamodel.rst:2424
msgid "the appropriate metaclass is determined;"
msgstr "適切なメタクラスが決定される;"

#: ../../reference/datamodel.rst:2425
msgid "the class namespace is prepared;"
msgstr "クラスの名前空間が準備される;"

#: ../../reference/datamodel.rst:2426
msgid "the class body is executed;"
msgstr "クラスの本体が実行される;"

#: ../../reference/datamodel.rst:2427
msgid "the class object is created."
msgstr "クラスオブジェクトが作られる。"

#: ../../reference/datamodel.rst:2431
msgid "Resolving MRO entries"
msgstr "MRO エントリの解決"

#: ../../reference/datamodel.rst:2435
msgid ""
"If a base that appears in a class definition is not an instance of :class:"
"`type`, then an :meth:`!__mro_entries__` method is searched on the base. If "
"an :meth:`!__mro_entries__` method is found, the base is substituted with "
"the result of a call to :meth:`!__mro_entries__` when creating the class. "
"The method is called with the original bases tuple passed to the *bases* "
"parameter, and must return a tuple of classes that will be used instead of "
"the base. The returned tuple may be empty: in these cases, the original base "
"is ignored."
msgstr ""

#: ../../reference/datamodel.rst:2446
msgid ":func:`types.resolve_bases`"
msgstr ""

#: ../../reference/datamodel.rst:2447
msgid "Dynamically resolve bases that are not instances of :class:`type`."
msgstr ""

#: ../../reference/datamodel.rst:2449
msgid ":func:`types.get_original_bases`"
msgstr ""

#: ../../reference/datamodel.rst:2450
msgid ""
"Retrieve a class's \"original bases\" prior to modifications by :meth:"
"`~object.__mro_entries__`."
msgstr ""

#: ../../reference/datamodel.rst:2453
msgid ":pep:`560`"
msgstr ""

#: ../../reference/datamodel.rst:2454
msgid "Core support for typing module and generic types."
msgstr ""

#: ../../reference/datamodel.rst:2458
msgid "Determining the appropriate metaclass"
msgstr "適切なメタクラスの決定"

#: ../../reference/datamodel.rst:2462
msgid ""
"The appropriate metaclass for a class definition is determined as follows:"
msgstr "クラス定義に対して適切なメタクラスは、以下のように決定されます:"

#: ../../reference/datamodel.rst:2464
msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is used;"
msgstr ""
"基底も明示的なメタクラスも与えられていない場合は、 :func:`type` が使われます;"

#: ../../reference/datamodel.rst:2465
msgid ""
"if an explicit metaclass is given and it is *not* an instance of :func:"
"`type`, then it is used directly as the metaclass;"
msgstr ""
"明示的なメタクラスが与えられていて、それが :func:`type` のインスタンス *では"
"ない* 場合、それをメタクラスとして直接使います;"

#: ../../reference/datamodel.rst:2467
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or bases "
"are defined, then the most derived metaclass is used."
msgstr ""
"明示的なメタクラスとして :func:`type` のインスタンスが与えられたか、基底が定"
"義されていた場合は、最も派生した (継承関係で最も下の) メタクラスが使われま"
"す。"

#: ../../reference/datamodel.rst:2470
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all specified "
"base classes. The most derived metaclass is one which is a subtype of *all* "
"of these candidate metaclasses. If none of the candidate metaclasses meets "
"that criterion, then the class definition will fail with ``TypeError``."
msgstr ""
"最も派生的なメタクラスは、(もしあれば) 明示的に指定されたメタクラスと、指定さ"
"れたすべてのベースクラスのメタクラスから選ばれます。最も派生的なメタクラス"
"は、これらのメタクラス候補のすべてのサブタイプであるようなものです。メタクラ"
"ス候補のどれもその基準を満たさなければ、クラス定義は ``TypeError`` で失敗しま"
"す。"

#: ../../reference/datamodel.rst:2480
msgid "Preparing the class namespace"
msgstr "クラスの名前空間の準備"

#: ../../reference/datamodel.rst:2485
msgid ""
"Once the appropriate metaclass has been identified, then the class namespace "
"is prepared. If the metaclass has a ``__prepare__`` attribute, it is called "
"as ``namespace = metaclass.__prepare__(name, bases, **kwds)`` (where the "
"additional keyword arguments, if any, come from the class definition). The "
"``__prepare__`` method should be implemented as a :func:`classmethod "
"<classmethod>`. The namespace returned by ``__prepare__`` is passed in to "
"``__new__``, but when the final class object is created the namespace is "
"copied into a new ``dict``."
msgstr ""
"適切なメタクラスが指定されると、クラスの名前空間が用意されます。もしメタクラ"
"スが ``__prepare__`` 属性を持っている場合、 ``namespace = metaclass."
"__prepare__(name, bases, **kwds)`` が呼ばれます。追加のキーワード引数は、もし"
"クラス定義にあれば設定されます。 ``__prepare__`` メソッドは :func:`クラスメ"
"ソッド <classmethod>` として実装する必要があります。 ``__prepare__`` が作成し"
"て返した名前空間は ``__new__`` に渡されますが、最終的なクラスオブジェクトは新"
"しい ``dict`` にコピーして作成されます。"

#: ../../reference/datamodel.rst:2494
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class namespace "
"is initialised as an empty ordered mapping."
msgstr ""
"メタクラスに ``__prepare__`` 属性がない場合、クラスの名前空間は空の 順序付き"
"マッピングとして初期化されます。"

#: ../../reference/datamodel.rst:2499
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaclasses in Python 3000"

#: ../../reference/datamodel.rst:2500
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "``__prepare__`` 名前空間フックの導入"

#: ../../reference/datamodel.rst:2504
msgid "Executing the class body"
msgstr "クラス本体の実行"

#: ../../reference/datamodel.rst:2509
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is that "
"lexical scoping allows the class body (including any methods) to reference "
"names from the current and outer scopes when the class definition occurs "
"inside a function."
msgstr ""
"クラス本体が (大まかには) ``exec(body, globals(), namespace)`` として実行され"
"ます。通常の呼び出しと :func:`exec` の重要な違いは、クラス定義が関数内部で行"
"われる場合、レキシカルスコープによってクラス本体 (任意のメソッドを含む) が現"
"在のスコープと外側のスコープから名前を参照できるという点です。"

#: ../../reference/datamodel.rst:2515
msgid ""
"However, even when the class definition occurs inside the function, methods "
"defined inside the class still cannot see names defined at the class scope. "
"Class variables must be accessed through the first parameter of instance or "
"class methods, or through the implicit lexically scoped ``__class__`` "
"reference described in the next section."
msgstr ""
"しかし、クラス定義が関数内部で行われる時でさえ、クラス内部で定義されたメソッ"
"ドはクラススコープで定義された名前を見ることはできません。クラス変数はインス"
"タンスメソッドかクラスメソッドの最初のパラメータからアクセスするか、次の節で"
"説明する、暗黙的に静的スコープが切られている ``__class__`` 参照からアクセスし"
"なければなりません。"

#: ../../reference/datamodel.rst:2524
msgid "Creating the class object"
msgstr "クラスオブジェクトの作成"

#: ../../reference/datamodel.rst:2531
msgid ""
"Once the class namespace has been populated by executing the class body, the "
"class object is created by calling ``metaclass(name, bases, namespace, "
"**kwds)`` (the additional keywords passed here are the same as those passed "
"to ``__prepare__``)."
msgstr ""
"クラス本体の実行によってクラスの名前空間が初期化されたら、``metaclass(name, "
"bases, namespace, **kwds)`` を呼び出すことでクラスオブジェクトが作成されます "
"(ここで渡される追加のキーワードは ``__prepare__`` に渡されるものと同じです)。"

#: ../../reference/datamodel.rst:2536
msgid ""
"This class object is the one that will be referenced by the zero-argument "
"form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of :func:"
"`super` to correctly identify the class being defined based on lexical "
"scoping, while the class or instance that was used to make the current call "
"is identified based on the first argument passed to the method."
msgstr ""
"このクラスオブジェクトは、 :func:`super` の無引数形式によって参照されるもので"
"す。 ``__class__`` は、クラス本体中のメソッドが ``__class__`` または "
"``super`` のいずれかを参照している場合に、コンパイラによって作成される暗黙の"
"クロージャー参照です。これは、メソッドに渡された最初の引数に基づいて現在の呼"
"び出しを行うために使用されるクラスまたはインスタンスが識別される一方、 :func:"
"`super` の無引数形式がレキシカルスコープに基づいて定義されているクラスを正確"
"に識別することを可能にします。"

#: ../../reference/datamodel.rst:2546
msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the metaclass "
"as a ``__classcell__`` entry in the class namespace. If present, this must "
"be propagated up to the ``type.__new__`` call in order for the class to be "
"initialised correctly. Failing to do so will result in a :exc:`RuntimeError` "
"in Python 3.8."
msgstr ""
"CPython 3.6 以降では、 ``__class__`` セルは、クラス名前空間にある "
"``__classcell__`` エントリーとしてメタクラスに渡されます。\n"
"``__class__`` セルが存在していた場合は、そのクラスが正しく初期化されるため"
"に、 ``type.__new__`` の呼び出しに到達するまで上に伝搬されます。\n"
"失敗した場合は、Python 3.8 では :exc:`RuntimeError` になります。"

#: ../../reference/datamodel.rst:2552
msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customization "
"steps are invoked after creating the class object:"
msgstr ""
"デフォルトのメタクラス :class:`type` や最終的には ``type.__new__`` を呼び出す"
"メタクラスを使っているときは、クラスオブジェクトを作成した後に次のカスタム化"
"の手順が起動されます:"

#: ../../reference/datamodel.rst:2556
msgid ""
"The ``type.__new__`` method collects all of the attributes in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""
"``type.__new__`` メソッドが :meth:`~object.__set_name__` が定義されているクラ"
"スの名前空間にある全ての属性を収集します;"

#: ../../reference/datamodel.rst:2558
msgid ""
"Those ``__set_name__`` methods are called with the class being defined and "
"the assigned name of that particular attribute;"
msgstr ""
"それらの ``__set_name__`` メソッドが、そのメソッドが定義されているクラス、お"
"よびそこに属する属性に割り当てられている名前を引数として呼び出されます;"

#: ../../reference/datamodel.rst:2560
msgid ""
"The :meth:`~object.__init_subclass__` hook is called on the immediate parent "
"of the new class in its method resolution order."
msgstr ""
"新しいクラスのメソッド解決順序ですぐ上に位置する親クラスで :meth:`~object."
"__init_subclass__` フックが呼び出されます。"

#: ../../reference/datamodel.rst:2563
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is bound "
"in the local namespace as the defined class."
msgstr ""
"クラスオブジェクトが作成された後には、クラス定義に含まれているクラスデコレー"
"タ (もしあれば) にクラスオブジェクトが渡され、デコレータが返すオブジェクトが"
"ここで定義されたクラスとしてローカルの名前空間に束縛されます。"

#: ../../reference/datamodel.rst:2567
msgid ""
"When a new class is created by ``type.__new__``, the object provided as the "
"namespace parameter is copied to a new ordered mapping and the original "
"object is discarded. The new copy is wrapped in a read-only proxy, which "
"becomes the :attr:`~object.__dict__` attribute of the class object."
msgstr ""
"新しいクラスが ``type.__new__`` で生成されたときは、名前空間引数として与えら"
"れたオブジェクトは新しい順序付きのマッピングに複製され、元のオブジェクトは破"
"棄されます。\n"
"新しく複製したものは読み出し専用のプロキシでラップされ、クラスオブジェクト"
"の :attr:`~object.__dict__` 属性になります。"

#: ../../reference/datamodel.rst:2574
msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` - New super"

#: ../../reference/datamodel.rst:2575
msgid "Describes the implicit ``__class__`` closure reference"
msgstr "暗黙の ``__class__`` クロージャ参照について記述しています"

#: ../../reference/datamodel.rst:2579
msgid "Uses for metaclasses"
msgstr "メタクラスの用途"

#: ../../reference/datamodel.rst:2581
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored include enum, logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""
"メタクラスは限りない潜在的利用価値を持っています。これまで試されてきたアイデ"
"アには、列挙型、ログ記録、インターフェースのチェック、 自動デリゲーション、自"
"動プロパティ生成、プロキシ、フレームワーク、そして自動リソースロック／同期と"
"いったものがあります。"

#: ../../reference/datamodel.rst:2588
msgid "Customizing instance and subclass checks"
msgstr "インスタンスのカスタマイズとサブクラスチェック"

#: ../../reference/datamodel.rst:2590
msgid ""
"The following methods are used to override the default behavior of the :func:"
"`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"以下のメソッドは組み込み関数 :func:`isinstance` と :func:`issubclass` のデ"
"フォルトの動作を上書きするのに利用します。"

#: ../../reference/datamodel.rst:2593
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""
"特に、 :class:`abc.ABCMeta` メタクラスは、抽象基底クラス (ABCs) を\"仮想基底"
"クラス (virtual base classes)\" として、他の ABC を含む、任意のクラスや (組み"
"込み型を含む) 型に追加するために、これらのメソッドを実装しています。"

#: ../../reference/datamodel.rst:2600
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""
"*instance* が (直接、または間接的に) *class* のインスタンスと考えられる場合"
"に true を返します。定義されていれば、 ``isinstance(instance, class)`` の実装"
"のために呼び出されます。"

#: ../../reference/datamodel.rst:2607
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass, "
"class)``."
msgstr ""
"*subclass* が (直接、または間接的に) *class* のサブクラスと考えられる場合に "
"true を返します。定義されていれば、 ``issubclass(subclass, class)`` の実装の"
"ために呼び出されます。"

#: ../../reference/datamodel.rst:2612
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""
"なお、これらのメソッドは、クラスの型 (メタクラス) 上で検索されます。実際のク"
"ラスにクラスメソッドとして定義することはできません。これは、インスタンスそれ"
"自体がクラスであるこの場合にのみ、インスタンスに呼び出される特殊メソッドの検"
"索と一貫しています。"

#: ../../reference/datamodel.rst:2619
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - 抽象基底クラスの導入"

#: ../../reference/datamodel.rst:2620
msgid ""
"Includes the specification for customizing :func:`isinstance` and :func:"
"`issubclass` behavior through :meth:`~class.__instancecheck__` and :meth:"
"`~class.__subclasscheck__`, with motivation for this functionality in the "
"context of adding Abstract Base Classes (see the :mod:`abc` module) to the "
"language."
msgstr ""
"抽象基底クラス (:mod:`abc` モジュールを参照) を言語に追加する文脈においての動"
"機から、 :meth:`~class.__instancecheck__` と :meth:`~class."
"__subclasscheck__` を通して、 :func:`isinstance` と :func:`issubclass` に独自"
"の動作をさせるための仕様の記述があります。"

#: ../../reference/datamodel.rst:2628
msgid "Emulating generic types"
msgstr "ジェネリック型をエミュレートする"

#: ../../reference/datamodel.rst:2630
msgid ""
"When using :term:`type annotations<annotation>`, it is often useful to "
"*parameterize* a :term:`generic type` using Python's square-brackets "
"notation. For example, the annotation ``list[int]`` might be used to signify "
"a :class:`list` in which all the elements are of type :class:`int`."
msgstr ""

#: ../../reference/datamodel.rst:2637
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - 型ヒント"

#: ../../reference/datamodel.rst:2638
msgid "Introducing Python's framework for type annotations"
msgstr ""

#: ../../reference/datamodel.rst:2640
msgid ":ref:`Generic Alias Types<types-genericalias>`"
msgstr ""

#: ../../reference/datamodel.rst:2641
msgid "Documentation for objects representing parameterized generic classes"
msgstr ""

#: ../../reference/datamodel.rst:2643
msgid ""
":ref:`Generics`, :ref:`user-defined generics<user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""

#: ../../reference/datamodel.rst:2644
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"実行時にパラメータ設定が可能であり、かつ静的な型チェッカーが理解できるジェネ"
"リッククラスを実装する方法のドキュメントです。"

#: ../../reference/datamodel.rst:2647
msgid ""
"A class can *generally* only be parameterized if it defines the special "
"class method ``__class_getitem__()``."
msgstr ""

#: ../../reference/datamodel.rst:2652
msgid ""
"Return an object representing the specialization of a generic class by type "
"arguments found in *key*."
msgstr ""
"*key* にある型引数で特殊化されたジェネリッククラスを表すオブジェクトを返しま"
"す。"

#: ../../reference/datamodel.rst:2655
msgid ""
"When defined on a class, ``__class_getitem__()`` is automatically a class "
"method. As such, there is no need for it to be decorated with :func:"
"`@classmethod<classmethod>` when it is defined."
msgstr ""

#: ../../reference/datamodel.rst:2661
msgid "The purpose of *__class_getitem__*"
msgstr ""

#: ../../reference/datamodel.rst:2663
msgid ""
"The purpose of :meth:`~object.__class_getitem__` is to allow runtime "
"parameterization of standard-library generic classes in order to more easily "
"apply :term:`type hints<type hint>` to these classes."
msgstr ""

#: ../../reference/datamodel.rst:2667
msgid ""
"To implement custom generic classes that can be parameterized at runtime and "
"understood by static type-checkers, users should either inherit from a "
"standard library class that already implements :meth:`~object."
"__class_getitem__`, or inherit from :class:`typing.Generic`, which has its "
"own implementation of ``__class_getitem__()``."
msgstr ""

#: ../../reference/datamodel.rst:2673
msgid ""
"Custom implementations of :meth:`~object.__class_getitem__` on classes "
"defined outside of the standard library may not be understood by third-party "
"type-checkers such as mypy. Using ``__class_getitem__()`` on any class for "
"purposes other than type hinting is discouraged."
msgstr ""

#: ../../reference/datamodel.rst:2683
msgid "*__class_getitem__* versus *__getitem__*"
msgstr ""

#: ../../reference/datamodel.rst:2685
msgid ""
"Usually, the :ref:`subscription<subscriptions>` of an object using square "
"brackets will call the :meth:`~object.__getitem__` instance method defined "
"on the object's class. However, if the object being subscribed is itself a "
"class, the class method :meth:`~object.__class_getitem__` may be called "
"instead. ``__class_getitem__()`` should return a :ref:`GenericAlias<types-"
"genericalias>` object if it is properly defined."
msgstr ""

#: ../../reference/datamodel.rst:2692
msgid ""
"Presented with the :term:`expression` ``obj[x]``, the Python interpreter "
"follows something like the following process to decide whether :meth:"
"`~object.__getitem__` or :meth:`~object.__class_getitem__` should be called::"
msgstr ""

#: ../../reference/datamodel.rst:2697
msgid ""
"from inspect import isclass\n"
"\n"
"def subscribe(obj, x):\n"
"    \"\"\"Return the result of the expression 'obj[x]'\"\"\"\n"
"\n"
"    class_of_obj = type(obj)\n"
"\n"
"    # If the class of obj defines __getitem__,\n"
"    # call class_of_obj.__getitem__(obj, x)\n"
"    if hasattr(class_of_obj, '__getitem__'):\n"
"        return class_of_obj.__getitem__(obj, x)\n"
"\n"
"    # Else, if obj is a class and defines __class_getitem__,\n"
"    # call obj.__class_getitem__(x)\n"
"    elif isclass(obj) and hasattr(obj, '__class_getitem__'):\n"
"        return obj.__class_getitem__(x)\n"
"\n"
"    # Else, raise an exception\n"
"    else:\n"
"        raise TypeError(\n"
"            f\"'{class_of_obj.__name__}' object is not subscriptable\"\n"
"        )"
msgstr ""

#: ../../reference/datamodel.rst:2720
msgid ""
"In Python, all classes are themselves instances of other classes. The class "
"of a class is known as that class's :term:`metaclass`, and most classes have "
"the :class:`type` class as their metaclass. :class:`type` does not define :"
"meth:`~object.__getitem__`, meaning that expressions such as ``list[int]``, "
"``dict[str, float]`` and ``tuple[str, bytes]`` all result in :meth:`~object."
"__class_getitem__` being called::"
msgstr ""

#: ../../reference/datamodel.rst:2727
msgid ""
">>> # list has class \"type\" as its metaclass, like most classes:\n"
">>> type(list)\n"
"<class 'type'>\n"
">>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\n"
"True\n"
">>> # \"list[int]\" calls \"list.__class_getitem__(int)\"\n"
">>> list[int]\n"
"list[int]\n"
">>> # list.__class_getitem__ returns a GenericAlias object:\n"
">>> type(list[int])\n"
"<class 'types.GenericAlias'>"
msgstr ""

#: ../../reference/datamodel.rst:2739
msgid ""
"However, if a class has a custom metaclass that defines :meth:`~object."
"__getitem__`, subscribing the class may result in different behaviour. An "
"example of this can be found in the :mod:`enum` module::"
msgstr ""

#: ../../reference/datamodel.rst:2743
msgid ""
">>> from enum import Enum\n"
">>> class Menu(Enum):\n"
"...     \"\"\"A breakfast menu\"\"\"\n"
"...     SPAM = 'spam'\n"
"...     BACON = 'bacon'\n"
"...\n"
">>> # Enum classes have a custom metaclass:\n"
">>> type(Menu)\n"
"<class 'enum.EnumMeta'>\n"
">>> # EnumMeta defines __getitem__,\n"
">>> # so __class_getitem__ is not called,\n"
">>> # and the result is not a GenericAlias object:\n"
">>> Menu['SPAM']\n"
"<Menu.SPAM: 'spam'>\n"
">>> type(Menu['SPAM'])\n"
"<enum 'Menu'>"
msgstr ""

#: ../../reference/datamodel.rst:2762
msgid ":pep:`560` - Core Support for typing module and generic types"
msgstr ""
":pep:`560` - typing モジュールとジェネリック型に対する言語コアによるサポート"

#: ../../reference/datamodel.rst:2763
msgid ""
"Introducing :meth:`~object.__class_getitem__`, and outlining when a :ref:"
"`subscription<subscriptions>` results in ``__class_getitem__()`` being "
"called instead of :meth:`~object.__getitem__`"
msgstr ""

#: ../../reference/datamodel.rst:2771
msgid "Emulating callable objects"
msgstr "呼び出し可能オブジェクトをエミュレートする"

#: ../../reference/datamodel.rst:2778
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` roughly translates to ``type(x).__call__(x, "
"arg1, ...)``."
msgstr ""
"インスタンスが関数として \"呼ばれた\" 際に呼び出されます。このメソッドが定義"
"されている場合、 ``x(arg1, arg2, ...)`` は大まかには ``type(x).__call__(x, "
"arg1, ...)`` に変換されます。"

#: ../../reference/datamodel.rst:2785
msgid "Emulating container types"
msgstr "コンテナをエミュレートする"

#: ../../reference/datamodel.rst:2787
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are :term:`sequences <sequence>` (such as :class:`lists "
"<list>` or :class:`tuples <tuple>`) or :term:`mappings <mapping>` (like :"
"class:`dictionaries <dict>`), but can represent other containers as well.  "
"The first set of methods is used either to emulate a sequence or to emulate "
"a mapping; the difference is that for a sequence, the allowable keys should "
"be the integers *k* for which ``0 <= k < N`` where *N* is the length of the "
"sequence, or :class:`slice` objects, which define a range of items.  It is "
"also recommended that mappings provide the methods :meth:`!keys`, :meth:`!"
"values`, :meth:`!items`, :meth:`!get`, :meth:`!clear`, :meth:`!setdefault`, :"
"meth:`!pop`, :meth:`!popitem`, :meth:`!copy`, and :meth:`!update` behaving "
"similar to those for Python's standard :class:`dictionary <dict>` objects.  "
"The :mod:`collections.abc` module provides a :class:`~collections.abc."
"MutableMapping` :term:`abstract base class` to help create those methods "
"from a base set of :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__`, and :meth:`!keys`. Mutable "
"sequences should provide methods :meth:`!append`, :meth:`!count`, :meth:`!"
"index`, :meth:`!extend`, :meth:`!insert`, :meth:`!pop`, :meth:`!remove`, :"
"meth:`!reverse` and :meth:`!sort`, like Python standard :class:`list` "
"objects. Finally, sequence types should implement addition (meaning "
"concatenation) and multiplication (meaning repetition) by defining the "
"methods :meth:`~object.__add__`, :meth:`~object.__radd__`, :meth:`~object."
"__iadd__`, :meth:`~object.__mul__`, :meth:`~object.__rmul__` and :meth:"
"`~object.__imul__` described below; they should not define other numerical "
"operators.  It is recommended that both mappings and sequences implement "
"the :meth:`~object.__contains__` method to allow efficient use of the ``in`` "
"operator; for mappings, ``in`` should search the mapping's keys; for "
"sequences, it should search through the values.  It is further recommended "
"that both mappings and sequences implement the :meth:`~object.__iter__` "
"method to allow efficient iteration through the container; for mappings, :"
"meth:`!__iter__` should iterate through the object's keys; for sequences, it "
"should iterate through the values."
msgstr ""

#: ../../reference/datamodel.rst:2828
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`~object.__bool__` method and whose :meth:`!__len__` method "
"returns zero is considered to be false in a Boolean context."
msgstr ""

#: ../../reference/datamodel.rst:2835
msgid ""
"In CPython, the length is required to be at most :data:`sys.maxsize`. If the "
"length is larger than :data:`!sys.maxsize` some features (such as :func:"
"`len`) may raise :exc:`OverflowError`.  To prevent raising :exc:`!"
"OverflowError` by truth value testing, an object must define a :meth:"
"`~object.__bool__` method."
msgstr ""

#: ../../reference/datamodel.rst:2844
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an estimated "
"length for the object (which may be greater or less than the actual length). "
"The length must be an integer ``>=`` 0. The return value may also be :data:"
"`NotImplemented`, which is treated the same as if the ``__length_hint__`` "
"method didn't exist at all. This method is purely an optimization and is "
"never required for correctness."
msgstr ""

#: ../../reference/datamodel.rst:2858
msgid ""
"Slicing is done exclusively with the following three methods.  A call like ::"
msgstr ""
"スライシングは、以下の 3 メソッドによって排他的に行われます。次のような呼び出"
"しは ::"

#: ../../reference/datamodel.rst:2860
msgid "a[1:2] = b"
msgstr ""

#: ../../reference/datamodel.rst:2862
msgid "is translated to ::"
msgstr "次のように翻訳され ::"

#: ../../reference/datamodel.rst:2864
msgid "a[slice(1, 2, None)] = b"
msgstr ""

#: ../../reference/datamodel.rst:2866
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr "以下も同様です。存在しないスライスの要素は ``None`` で埋められます。"

#: ../../reference/datamodel.rst:2871
msgid ""
"Called to implement evaluation of ``self[key]``. For :term:`sequence` types, "
"the accepted keys should be integers. Optionally, they may support :class:"
"`slice` objects as well.  Negative index support is also optional. If *key* "
"is of an inappropriate type, :exc:`TypeError` may be raised; if *key* is a "
"value outside the set of indexes for the sequence (after any special "
"interpretation of negative values), :exc:`IndexError` should be raised. For :"
"term:`mapping` types, if *key* is missing (not in the container), :exc:"
"`KeyError` should be raised."
msgstr ""

#: ../../reference/datamodel.rst:2883
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
":keyword:`for` ループでは、シーケンスの終端を正しく検出できるようにするため"
"に、不正なインデクスに対して :exc:`IndexError` が送出されるものと期待していま"
"す。"

#: ../../reference/datamodel.rst:2888
msgid ""
"When :ref:`subscripting<subscriptions>` a *class*, the special class method :"
"meth:`~object.__class_getitem__` may be called instead of ``__getitem__()``. "
"See :ref:`classgetitem-versus-getitem` for more details."
msgstr ""

#: ../../reference/datamodel.rst:2896
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support changes to the values for keys, or if new keys can be added, or for "
"sequences if elements can be replaced.  The same exceptions should be raised "
"for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"``self[key]`` に対する代入を実装するために呼び出されます。 :meth:"
"`__getitem__` と同じ注意事項があてはまります。このメソッドを実装できるのは、"
"あるキーに対する値の変更をサポートしているか、新たなキーを追加できるような"
"マップの場合と、ある要素を置き換えることができるシーケンスの場合だけです。不"
"正な *key* に対しては、 :meth:`__getitem__` メソッドと同様の例外の送出を行わ"
"なければなりません。"

#: ../../reference/datamodel.rst:2905
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support removal of keys, or for sequences if elements can be removed from "
"the sequence.  The same exceptions should be raised for improper *key* "
"values as for the :meth:`__getitem__` method."
msgstr ""
"``self[key]`` の削除を実装するために呼び出されます。 :meth:`__getitem__` と同"
"じ注意事項があてはまります。このメソッドを実装できるのは、キーの削除をサポー"
"トしているマップの場合と、要素を削除できるシーケンスの場合だけです。不正な "
"*key* に対しては、 :meth:`__getitem__` メソッドと同様の例外の送出を行わなけれ"
"ばなりません。"

#: ../../reference/datamodel.rst:2914
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]`` "
"for dict subclasses when key is not in the dictionary."
msgstr ""
"``self[key]`` の実装において辞書内にキーが存在しなかった場合に、 dict のサブ"
"クラスのために :class:`dict`\\ .\\ :meth:`__getitem__` によって呼び出されま"
"す。"

#: ../../reference/datamodel.rst:2920
msgid ""
"This method is called when an :term:`iterator` is required for a container. "
"This method should return a new iterator object that can iterate over all "
"the objects in the container.  For mappings, it should iterate over the keys "
"of the container."
msgstr ""
"このメソッドは、コンテナに対して :term:`イテレータ <iterator>` が要求された際"
"に呼び出されます。このメソッドは、コンテナ内の全てのオブジェクトに渡って反復"
"処理できるような、新たなイテレータオブジェクトを返さなければなりません。マッ"
"ピングでは、コンテナ内のキーに渡って反復処理しなければなりません。"

#: ../../reference/datamodel.rst:2928
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""
":func:`reversed` 組み込み関数が逆方向イテレーションを実装するために、(存在す"
"れば)呼び出します。コンテナ内の全要素を逆順にイテレートする、新しいイテレータ"
"を返すべきです。"

#: ../../reference/datamodel.rst:2932
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and :"
"meth:`__getitem__`).  Objects that support the sequence protocol should only "
"provide :meth:`__reversed__` if they can provide an implementation that is "
"more efficient than the one provided by :func:`reversed`."
msgstr ""
":meth:`__reversed__` メソッドが定義されていない場合、 :func:`reversed` 組込み"
"関数は sequence プロトコル (:meth:`__len__` と :meth:`__getitem__`) を使った"
"方法にフォールバックします。 sequence プロトコルをサポートしたオブジェクト"
"は、 :func:`reversed` よりも効率のいい実装を提供できる場合にのみ :meth:"
"`__reversed__` を定義するべきです。"

#: ../../reference/datamodel.rst:2939
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a container. However, container "
"objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be iterable."
msgstr ""
"帰属テスト演算子 (:keyword:`in` および :keyword:`not in`) は通常、コンテナの"
"要素に対する反復処理のように実装されます。しかし、コンテナオブジェクトで以下"
"の特殊メソッドを定義して、より効率的な実装を行ったり、オブジェクトがイテラブ"
"ルでなくてもよいようにできます。"

#: ../../reference/datamodel.rst:2946
msgid ""
"Called to implement membership test operators.  Should return true if *item* "
"is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""
"帰属テスト演算を実装するために呼び出されます。 *item* が *self* 内に存在する"
"場合には真を、そうでない場合には偽を返さなければなりません。マップオブジェク"
"トの場合、値やキーと値の組ではなく、キーに対する帰属テストを考えなければなり"
"ません。"

#: ../../reference/datamodel.rst:2950
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""
":meth:`__contains__` を定義しないオブジェクトに対しては、メンバシップテストは"
"まず、 :meth:`__iter__` を使った反復を試みます、次に古いシーケンス反復プロト"
"コル :meth:`__getitem__` を使います、 :ref:`言語レファレンスのこの節 "
"<membership-test-details>` を参照して下さい。"

#: ../../reference/datamodel.rst:2959
msgid "Emulating numeric types"
msgstr "数値型をエミュレートする"

#: ../../reference/datamodel.rst:2961
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of "
"number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""
"以下のメソッドを定義して、数値型オブジェクトをエミュレートすることができま"
"す。特定の種類の数値型ではサポートされていないような演算に対応するメソッド "
"(非整数の数値に対するビット単位演算など) は、未定義のままにしておかなければな"
"りません。"

#: ../../reference/datamodel.rst:2987
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to "
"evaluate the expression ``x + y``, where *x* is an instance of a class that "
"has an :meth:`__add__` method, ``type(x).__add__(x, y)`` is called.  The :"
"meth:`__divmod__` method should be the equivalent to using :meth:"
"`__floordiv__` and :meth:`__mod__`; it should not be related to :meth:"
"`__truediv__`.  Note that :meth:`__pow__` should be defined to accept an "
"optional third argument if the ternary version of the built-in :func:`pow` "
"function is to be supported."
msgstr ""
"これらのメソッドを呼んで二項算術演算子 (``+``, ``-``, ``*``, ``@``, ``/``, "
"``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, "
"``^``, ``|``) を実装します。\n"
"例えば *x* が :meth:`__add__` メソッドのあるクラスのインスタンスである場合、"
"式 ``x + y`` を評価すると ``type(x).__add__(x, y)`` が呼ばれます。\n"
":meth:`__divmod__` メソッドは :meth:`__floordiv__` と :meth:`__mod__` を使用"
"するのと等価でなければなりません。\n"
":meth:`__truediv__` と関連してはなりません。\n"
"組み込みの :func:`pow` 関数の三項のものがサポートされていなければならない場"
"合、 :meth:`__pow__` はオプションの第三引数を受け取るものとして定義されなけれ"
"ばなりません。"

#: ../../reference/datamodel.rst:2998
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return :data:`NotImplemented`."
msgstr ""

#: ../../reference/datamodel.rst:3021
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) "
"operands.  These functions are only called if the left operand does not "
"support the corresponding operation [#]_ and the operands are of different "
"types. [#]_ For instance, to evaluate the expression ``x - y``, where *y* is "
"an instance of a class that has an :meth:`__rsub__` method, ``type(y)."
"__rsub__(y, x)`` is called if ``type(x).__sub__(x, y)`` returns :data:"
"`NotImplemented`."
msgstr ""

#: ../../reference/datamodel.rst:3033
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""
"ただし、三項演算子 :func:`pow` が :meth:`__rpow__` を呼ぶことはないので注意し"
"てください (型強制の規則が非常に難解になるからです)。"

#: ../../reference/datamodel.rst:3038
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides a different implementation of the reflected method "
"for the operation, this method will be called before the left operand's non-"
"reflected method. This behavior allows subclasses to override their "
"ancestors' operations."
msgstr ""
"右側の被演算子の型が左側の被演算子の型のサブクラスであり、このサブクラスであ"
"るメソッドに対する反射メソッドと異なる実装が定義されている場合には、左側の被"
"演算子の非反射メソッドが呼ばれる前に、このメソッドが呼ばれます。この振る舞い"
"により、サブクラスが親の演算をオーバーライドすることが可能になります。"

#: ../../reference/datamodel.rst:3059
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, "
"``>>=``, ``&=``, ``^=``, ``|=``).  These methods should attempt to do the "
"operation in-place (modifying *self*) and return the result (which could be, "
"but does not have to be, *self*).  If a specific method is not defined, or "
"if that method returns :data:`NotImplemented`, the augmented assignment "
"falls back to the normal methods.  For instance, if *x* is an instance of a "
"class with an :meth:`__iadd__` method, ``x += y`` is equivalent to ``x = x."
"__iadd__(y)`` . If :meth:`__iadd__` does not exist, or if ``x.__iadd__(y)`` "
"returns :data:`!NotImplemented`, ``x.__add__(y)`` and ``y.__radd__(x)`` are "
"considered, as with the evaluation of ``x + y``. In certain situations, "
"augmented assignment can result in unexpected errors (see :ref:`faq-"
"augmented-assignment-tuple-error`), but this behavior is in fact part of the "
"data model."
msgstr ""

#: ../../reference/datamodel.rst:3082
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, :func:"
"`abs` and ``~``)."
msgstr ""
"呼び出して単項算術演算 (``-``, ``+``, :func:`abs` および ``~``) を実装しま"
"す。"

#: ../../reference/datamodel.rst:3095
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` and :"
"func:`float`.  Should return a value of the appropriate type."
msgstr ""
"組み込み関数の :func:`complex`, :func:`int`, :func:`float` の実装から呼び出さ"
"れます。\n"
"適切な型の値を返さなければなりません。"

#: ../../reference/datamodel.rst:3102
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is an "
"integer type.  Must return an integer."
msgstr ""
"呼び出して :func:`operator.index` を実装します。\n"
"Python が数値オブジェクトを整数オブジェクトに損失なく変換する必要がある場合 "
"(たとえばスライシングや、組み込みの :func:`bin` 、 :func:`hex` 、 :func:"
"`oct` 関数) は常に呼び出されます。\n"
"このメソッドがあるとその数値オブジェクトが整数型であることが示唆されます。\n"
"整数を返さなければなりません。"

#: ../../reference/datamodel.rst:3108
msgid ""
"If :meth:`__int__`, :meth:`__float__` and :meth:`__complex__` are not "
"defined then corresponding built-in functions :func:`int`, :func:`float` "
"and :func:`complex` fall back to :meth:`__index__`."
msgstr ""
"もし :meth:`__int__`, :meth:`__float__`, :meth:`__complex__` が定義されていな"
"い場合、組み込み関数の :func:`int`, :func:`float`, :func:`complex` は :meth:"
"`__index__` にフォールバックします。"

#: ../../reference/datamodel.rst:3120
msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and :func:`~math.ceil`. "
"Unless *ndigits* is passed to :meth:`!__round__` all these methods should "
"return the value of the object truncated to an :class:`~numbers.Integral` "
"(typically an :class:`int`)."
msgstr ""
"組み込み関数の :func:`round` と :mod:`math` モジュール関数の :func:`~math."
"trunc`, :func:`~math.floor`, :func:`~math.ceil` の実装から呼び出されます。\n"
"*ndigits* が :meth:`!__round__` に渡されない限りは、これらの全てのメソッド"
"は :class:`~numbers.Integral` (たいていは :class:`int`) に切り詰められたオブ"
"ジェクトの値を返すべきです。"

#: ../../reference/datamodel.rst:3126
msgid ""
"The built-in function :func:`int` falls back to :meth:`__trunc__` if "
"neither :meth:`__int__` nor :meth:`__index__` is defined."
msgstr ""

#: ../../reference/datamodel.rst:3129
msgid "The delegation of :func:`int` to :meth:`__trunc__` is deprecated."
msgstr ":func:`int` の :meth:`__trunc__` への処理の委譲は非推奨になりました。"

#: ../../reference/datamodel.rst:3136
msgid "With Statement Context Managers"
msgstr "with文とコンテキストマネージャ"

#: ../../reference/datamodel.rst:3138
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be "
"established when executing a :keyword:`with` statement. The context manager "
"handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`!with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""
"コンテキストマネージャ(:dfn:`context manager`) とは、 :keyword:`with` 文の実"
"行時にランタイムコンテキストを定義するオブジェクトです。コンテキストマネー"
"ジャは、コードブロックを実行するために必要な入り口および出口の処理を扱いま"
"す。コンテキストマネージャは通常、 :keyword:`!with` 文（ :ref:`with` の章を参"
"照）により起動されますが、これらのメソッドを直接呼び出すことで起動することも"
"できます。"

#: ../../reference/datamodel.rst:3149
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""
"コンテキストマネージャの代表的な使い方としては、様々なグローバル情報の保存お"
"よび更新、リソースのロックとアンロック、ファイルのオープンとクローズなどが挙"
"げられます。"

#: ../../reference/datamodel.rst:3152
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`."
msgstr ""
"コンテキストマネージャについてのさらなる情報については、 :ref:"
"`typecontextmanager` を参照してください。"

#: ../../reference/datamodel.rst:3157
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in "
"the :keyword:`!as` clause of the statement, if any."
msgstr ""
"コンテキストマネージャのの入り口で実行される処理です。 :keyword:`with` 文は、"
"文の :keyword:`!as` 節で規定された値を返すこのメソッドを呼び出します。"

#: ../../reference/datamodel.rst:3164
msgid ""
"Exit the runtime context related to this object. The parameters describe the "
"exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""
"コンテキストマネージャの出口で実行される処理です。パラメータは、コンテキスト"
"が終了した原因となった例外について説明しています。コンテキストが例外を送出せ"
"ず終了した場合は、全ての引き数に :const:`None` が設定されます。"

#: ../../reference/datamodel.rst:3168
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception "
"(i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""
"もし、例外が送出され、かつメソッドが例外を抑制したい場合（すなわち、例外が伝"
"播されるのを防ぎたい場合）、このメソッドは True を返す必要があります。そうで"
"なければ、このメソッドの終了後、例外は通常通り伝播することになります。"

#: ../../reference/datamodel.rst:3172
msgid ""
"Note that :meth:`~object.__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""

#: ../../reference/datamodel.rst:3178
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" ステートメント"

#: ../../reference/datamodel.rst:3179
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python の :keyword:`with` 文の仕様、背景、および例が記載されています。"

#: ../../reference/datamodel.rst:3186
msgid "Customizing positional arguments in class pattern matching"
msgstr "クラスパターンマッチの位置引数のカスタマイズ"

#: ../../reference/datamodel.rst:3188
msgid ""
"When using a class name in a pattern, positional arguments in the pattern "
"are not allowed by default, i.e. ``case MyClass(x, y)`` is typically invalid "
"without special support in ``MyClass``. To be able to use that kind of "
"pattern, the class needs to define a *__match_args__* attribute."
msgstr ""
"パターンの中でクラス名を利用する場合、位置引数はデフォルトでは利用できませ"
"ん。 ``MyClass`` で特別なサポートがないと、 ``case MyClass(x, y)`` は通常無効"
"です。このようなパターンを利用するには、 *__match_args__* 属性をクラスに定義"
"する必要があります。"

#: ../../reference/datamodel.rst:3195
msgid ""
"This class variable can be assigned a tuple of strings. When this class is "
"used in a class pattern with positional arguments, each positional argument "
"will be converted into a keyword argument, using the corresponding value in "
"*__match_args__* as the keyword. The absence of this attribute is equivalent "
"to setting it to ``()``."
msgstr ""
"このクラス変数には文字列のタプルがアサイン可能です。このクラスがクラスパター"
"ンの位置引数の中で利用されると、それぞれの位置引数は対応する "
"*__match_args__* の中の値をキーワードとする、キーワード引数に変換されます。こ"
"の属性がない時は、 ``()`` が設定されているのと同義です。"

#: ../../reference/datamodel.rst:3201
msgid ""
"For example, if ``MyClass.__match_args__`` is ``(\"left\", \"center\", "
"\"right\")`` that means that ``case MyClass(x, y)`` is equivalent to ``case "
"MyClass(left=x, center=y)``. Note that the number of arguments in the "
"pattern must be smaller than or equal to the number of elements in "
"*__match_args__*; if it is larger, the pattern match attempt will raise a :"
"exc:`TypeError`."
msgstr ""
"例えば、もし ``MyClass.__match_args__`` に ``(\"left\", \"center\", "
"\"right\")`` が定義されていた場合、  ``case MyClass(x, y)`` は ``case "
"MyClass(left=x, center=y)`` と同義です。パターンの引数の数は、 "
"*__match_args__* の要素数と同等かそれ以下でなければならない点に注意してくださ"
"い。もし、多かった場合には、パターンマッチは :exc:`TypeError` を送出します。"

#: ../../reference/datamodel.rst:3211
msgid ":pep:`634` - Structural Pattern Matching"
msgstr ":pep:`634` - 構造的パターンマッチ"

#: ../../reference/datamodel.rst:3212
msgid "The specification for the Python ``match`` statement."
msgstr "``match`` 文の詳細。"

#: ../../reference/datamodel.rst:3218
msgid "Emulating buffer types"
msgstr ""

#: ../../reference/datamodel.rst:3220
msgid ""
"The :ref:`buffer protocol <bufferobjects>` provides a way for Python objects "
"to expose efficient access to a low-level memory array. This protocol is "
"implemented by builtin types such as :class:`bytes` and :class:`memoryview`, "
"and third-party libraries may define additional buffer types."
msgstr ""

#: ../../reference/datamodel.rst:3225
msgid ""
"While buffer types are usually implemented in C, it is also possible to "
"implement the protocol in Python."
msgstr ""

#: ../../reference/datamodel.rst:3230
msgid ""
"Called when a buffer is requested from *self* (for example, by the :class:"
"`memoryview` constructor). The *flags* argument is an integer representing "
"the kind of buffer requested, affecting for example whether the returned "
"buffer is read-only or writable. :class:`inspect.BufferFlags` provides a "
"convenient way to interpret the flags. The method must return a :class:"
"`memoryview` object."
msgstr ""

#: ../../reference/datamodel.rst:3239
msgid ""
"Called when a buffer is no longer needed. The *buffer* argument is a :class:"
"`memoryview` object that was previously returned by :meth:`~object."
"__buffer__`. The method must release any resources associated with the "
"buffer. This method should return ``None``. Buffer objects that do not need "
"to perform any cleanup are not required to implement this method."
msgstr ""

#: ../../reference/datamodel.rst:3250
msgid ":pep:`688` - Making the buffer protocol accessible in Python"
msgstr ""

#: ../../reference/datamodel.rst:3251
msgid ""
"Introduces the Python ``__buffer__`` and ``__release_buffer__`` methods."
msgstr ""

#: ../../reference/datamodel.rst:3253
msgid ":class:`collections.abc.Buffer`"
msgstr ""

#: ../../reference/datamodel.rst:3254
msgid "ABC for buffer types."
msgstr ""

#: ../../reference/datamodel.rst:3259
msgid "Special method lookup"
msgstr "特殊メソッド検索"

#: ../../reference/datamodel.rst:3261
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""
"カスタムクラスでは、特殊メソッドの暗黙の呼び出しは、オブジェクトのインスタン"
"ス辞書ではなく、オブジェクトの型で定義されているときにのみ正しく動作すること"
"が保証されます。この動作のため、以下のコードは例外を送出します::"

#: ../../reference/datamodel.rst:3266
msgid ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> c.__len__ = lambda: 5\n"
">>> len(c)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: object of type 'C' has no len()"
msgstr ""

#: ../../reference/datamodel.rst:3276
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`~object.__hash__` and :meth:`~object.__repr__` that are "
"implemented by all objects, including type objects. If the implicit lookup "
"of these methods used the conventional lookup process, they would fail when "
"invoked on the type object itself::"
msgstr ""
"この動作の背景となる理由は、 :meth:`~object.__hash__` と :meth:`~object."
"__repr__` といった type オブジェクトを含むすべてのオブジェクトで定義されてい"
"る特殊メソッドにあります。これらのメソッドの暗黙の検索が通常の検索プロセスを"
"使った場合、 type オブジェクト自体に対して実行されたときに失敗してしまいま"
"す::"

#: ../../reference/datamodel.rst:3283
msgid ""
">>> 1 .__hash__() == hash(1)\n"
"True\n"
">>> int.__hash__() == hash(int)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: descriptor '__hash__' of 'int' object needs an argument"
msgstr ""

#: ../../reference/datamodel.rst:3290
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is "
"sometimes referred to as 'metaclass confusion', and is avoided by bypassing "
"the instance when looking up special methods::"
msgstr ""
"クラスの非結合メソッドをこのようにして実行しようとすることは、'metaclass "
"confusion' と呼ばれることもあり、特殊メソッドを検索するときはインスタンスをバ"
"イパスすることで回避されます::"

#: ../../reference/datamodel.rst:3294
msgid ""
">>> type(1).__hash__(1) == hash(1)\n"
"True\n"
">>> type(int).__hash__(int) == hash(int)\n"
"True"
msgstr ""

#: ../../reference/datamodel.rst:3299
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the :"
"meth:`~object.__getattribute__` method even of the object's metaclass::"
msgstr ""
"正確性のためにインスタンス属性をスキップするのに加えて、特殊メソッド検索はオ"
"ブジェクトのメタクラスを含めて、 :meth:`~object.__getattribute__` メソッドも"
"バイパスします::"

#: ../../reference/datamodel.rst:3303
msgid ""
">>> class Meta(type):\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Metaclass getattribute invoked\")\n"
"...         return type.__getattribute__(*args)\n"
"...\n"
">>> class C(object, metaclass=Meta):\n"
"...     def __len__(self):\n"
"...         return 10\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Class getattribute invoked\")\n"
"...         return object.__getattribute__(*args)\n"
"...\n"
">>> c = C()\n"
">>> c.__len__()                 # Explicit lookup via instance\n"
"Class getattribute invoked\n"
"10\n"
">>> type(c).__len__(c)          # Explicit lookup via type\n"
"Metaclass getattribute invoked\n"
"10\n"
">>> len(c)                      # Implicit lookup\n"
"10"
msgstr ""

#: ../../reference/datamodel.rst:3325
msgid ""
"Bypassing the :meth:`~object.__getattribute__` machinery in this fashion "
"provides significant scope for speed optimisations within the interpreter, "
"at the cost of some flexibility in the handling of special methods (the "
"special method *must* be set on the class object itself in order to be "
"consistently invoked by the interpreter)."
msgstr ""
"このように :meth:`~object.__getattribute__` 機構をバイパスすることで、特殊メ"
"ソッドの扱いに関するある程度の自由度と引き換えに (特殊メソッドはインタプリタ"
"から一貫して実行されるためにクラスオブジェクトに設定 *しなければならない*)、"
"インタープリタを高速化するための大きな余地が手に入ります。"

#: ../../reference/datamodel.rst:3336
msgid "Coroutines"
msgstr "コルーチン"

#: ../../reference/datamodel.rst:3340
msgid "Awaitable Objects"
msgstr "待機可能オブジェクト (Awaitable Object)"

#: ../../reference/datamodel.rst:3342
msgid ""
"An :term:`awaitable` object generally implements an :meth:`~object."
"__await__` method. :term:`Coroutine objects <coroutine>` returned from :"
"keyword:`async def` functions are awaitable."
msgstr ""
":term:`awaitable` オブジェクトは一般的には :meth:`~object.__await__` メソッド"
"が実装されています。 :keyword:`async def` 関数が返す :term:`Coroutineオブジェ"
"クト <coroutine>` は待機可能です。"

#: ../../reference/datamodel.rst:3348
msgid ""
"The :term:`generator iterator` objects returned from generators decorated "
"with :func:`types.coroutine` are also awaitable, but they do not implement :"
"meth:`~object.__await__`."
msgstr ""
":func:`types.coroutine` デコレータでデコレータが付けられたジェネレータから返"
"される :term:`generator iterator` オブジェクトも待機可能ですが、 :meth:"
"`~object.__await__` は実装されていません。"

#: ../../reference/datamodel.rst:3354
msgid ""
"Must return an :term:`iterator`.  Should be used to implement :term:"
"`awaitable` objects.  For instance, :class:`asyncio.Future` implements this "
"method to be compatible with the :keyword:`await` expression."
msgstr ""
":term:`iterator` を返さなければなりません。\n"
"このメソッドは :term:`awaitable` オブジェクトを実装するのに使われるべきで"
"す。\n"
"簡単のために、 :class:`asyncio.Future` にはこのメソッドが実装され、 :keyword:"
"`await` 式と互換性を持つようになっています。"

#: ../../reference/datamodel.rst:3360
msgid ""
"The language doesn't place any restriction on the type or value of the "
"objects yielded by the iterator returned by ``__await__``, as this is "
"specific to the implementation of the asynchronous execution framework (e."
"g. :mod:`asyncio`) that will be managing the :term:`awaitable` object."
msgstr ""

#: ../../reference/datamodel.rst:3368
msgid ":pep:`492` for additional information about awaitable objects."
msgstr ""
"待機可能オブジェクトについてより詳しくは :pep:`492` を参照してください。"

#: ../../reference/datamodel.rst:3374
msgid "Coroutine Objects"
msgstr "コルーチンオブジェクト"

#: ../../reference/datamodel.rst:3376
msgid ""
":term:`Coroutine objects <coroutine>` are :term:`awaitable` objects. A "
"coroutine's execution can be controlled by calling :meth:`~object.__await__` "
"and iterating over the result.  When the coroutine has finished executing "
"and returns, the iterator raises :exc:`StopIteration`, and the exception's :"
"attr:`~StopIteration.value` attribute holds the return value.  If the "
"coroutine raises an exception, it is propagated by the iterator.  Coroutines "
"should not directly raise unhandled :exc:`StopIteration` exceptions."
msgstr ""
":term:`Coroutineオブジェクト <coroutine>` は :term:`awaitable` オブジェクトで"
"す。:meth:`~object.__await__` を呼び出し、その返り値に対し反復処理をすること"
"でコルーチンの実行を制御できます。コルーチンの実行が完了し制御を戻したとき、"
"イテレータは :exc:`StopIteration` を送出し、その例外の :attr:`~StopIteration."
"value` 属性に返り値を持たせます。コルーチンが例外を送出した場合は、イテレータ"
"により伝搬されます。コルーチンから :exc:`StopIteration` 例外を外に送出すべき"
"ではありません。"

#: ../../reference/datamodel.rst:3384
msgid ""
"Coroutines also have the methods listed below, which are analogous to those "
"of generators (see :ref:`generator-methods`).  However, unlike generators, "
"coroutines do not directly support iteration."
msgstr ""
"コルーチンには以下に挙げるメソッドもあり、これらはジェネレータのメソッドから"
"の類似です (:ref:`generator-methods` を参照してください)。\n"
"ただし、ジェネレータと違って、コルーチンは反復処理を直接はサポートしていませ"
"ん。"

#: ../../reference/datamodel.rst:3388
msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr ""
"コルーチンで2回以上待機 (await) すると :exc:`RuntimeError` となります。"

#: ../../reference/datamodel.rst:3394
msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, this "
"is equivalent to advancing the iterator returned by :meth:`~object."
"__await__`.  If *value* is not ``None``, this method delegates to the :meth:"
"`~generator.send` method of the iterator that caused the coroutine to "
"suspend.  The result (return value, :exc:`StopIteration`, or other "
"exception) is the same as when iterating over the :meth:`!__await__` return "
"value, described above."
msgstr ""

#: ../../reference/datamodel.rst:3405
msgid ""
"Raises the specified exception in the coroutine.  This method delegates to "
"the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception is "
"raised at the suspension point.  The result (return value, :exc:"
"`StopIteration`, or other exception) is the same as when iterating over the :"
"meth:`~object.__await__` return value, described above.  If the exception is "
"not caught in the coroutine, it propagates back to the caller."
msgstr ""
"コルーチンで指定された例外を送出します。\n"
"このメソッドは、イテレータにコルーチンを一時停止する :meth:`~generator."
"throw` メソッドがある場合に処理を委任します。\n"
"そうでない場合には、中断した地点から例外が送出されます。\n"
"結果 (返り値か :exc:`StopIteration` かその他の例外) は、上で解説したような :"
"meth:`~object.__await__` の返り値に対して反復処理を行ったときと同じです。\n"
"例外がコルーチンの中で捕捉されなかった場合、呼び出し元へ伝搬されます。"

#: ../../reference/datamodel.rst:3416
msgid ""
"The second signature \\(type\\[, value\\[, traceback\\]\\]\\) is deprecated "
"and may be removed in a future version of Python."
msgstr ""

#: ../../reference/datamodel.rst:3421
msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has such "
"a method.  Then it raises :exc:`GeneratorExit` at the suspension point, "
"causing the coroutine to immediately clean itself up. Finally, the coroutine "
"is marked as having finished executing, even if it was never started."
msgstr ""
"コルーチンが自分自身の後片付けをし終了します。\n"
"コルーチンが一時停止している場合は、コルーチンを一時停止させたイテレータに :"
"meth:`~generator.close` メソッドがあれば、まずはそれに処理を委任します。\n"
"そして一時停止した地点から :exc:`GeneratorExit` が送出され、ただちにコルーチ"
"ンが自分自身の後片付けを行います。\n"
"最後に、実行が開始されていなかった場合でも、コルーチンに実行が完了した印を付"
"けます。"

#: ../../reference/datamodel.rst:3429
msgid ""
"Coroutine objects are automatically closed using the above process when they "
"are about to be destroyed."
msgstr ""
"コルーチンオブジェクトが破棄されるときには、上記の手順を経て自動的に閉じられ"
"ます。"

#: ../../reference/datamodel.rst:3435
msgid "Asynchronous Iterators"
msgstr "非同期イテレータ (Asynchronous Iterator)"

#: ../../reference/datamodel.rst:3437
msgid ""
"An *asynchronous iterator* can call asynchronous code in its ``__anext__`` "
"method."
msgstr ""
"*非同期イテレータ* の ``__anext__`` メソッドからは非同期のコードが呼べます。"

#: ../../reference/datamodel.rst:3440
msgid ""
"Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr "非同期イテレータは :keyword:`async for` 文の中で使えます。"

#: ../../reference/datamodel.rst:3444
msgid "Must return an *asynchronous iterator* object."
msgstr "*非同期イテレータ* オブジェクトを返さなくてはなりません。"

#: ../../reference/datamodel.rst:3448
msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is over."
msgstr ""
"イテレータの次の値を返す *待機可能オブジェクト* を返さなければなりません。\n"
"反復処理が終了したときには :exc:`StopAsyncIteration` エラーを送出すべきです。"

#: ../../reference/datamodel.rst:3451
msgid "An example of an asynchronous iterable object::"
msgstr "非同期イテラブルオブジェクトの例::"

#: ../../reference/datamodel.rst:3453
msgid ""
"class Reader:\n"
"    async def readline(self):\n"
"        ...\n"
"\n"
"    def __aiter__(self):\n"
"        return self\n"
"\n"
"    async def __anext__(self):\n"
"        val = await self.readline()\n"
"        if val == b'':\n"
"            raise StopAsyncIteration\n"
"        return val"
msgstr ""

#: ../../reference/datamodel.rst:3468
msgid ""
"Prior to Python 3.7, :meth:`~object.__aiter__` could return an *awaitable* "
"that would resolve to an :term:`asynchronous iterator <asynchronous "
"iterator>`."
msgstr ""
"Python 3.7 より前では、 :meth:`~object.__aiter__` は :term:`非同期イテレータ "
"<asynchronous iterator>` になる *awaitable* を返せました。"

#: ../../reference/datamodel.rst:3473
msgid ""
"Starting with Python 3.7, :meth:`~object.__aiter__` must return an "
"asynchronous iterator object.  Returning anything else will result in a :exc:"
"`TypeError` error."
msgstr ""
"Python 3.7 からは、 :meth:`~object.__aiter__` は非同期イテレータオブジェクト"
"を返さなければなりません。\n"
"それ以外のものを返すと :exc:`TypeError` になります。"

#: ../../reference/datamodel.rst:3481
msgid "Asynchronous Context Managers"
msgstr "非同期コンテキストマネージャ (Asynchronous Context Manager)"

#: ../../reference/datamodel.rst:3483
msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""
"*非同期コンテキストマネージャ* は、 ``__aenter__`` メソッドと ``__aexit__`` "
"メソッド内部で実行を一時停止できる *コンテキストマネージャ* です。"

#: ../../reference/datamodel.rst:3486
msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr ""
"非同期コンテキストマネージャは :keyword:`async with` 文の中で使えます。"

#: ../../reference/datamodel.rst:3490
msgid ""
"Semantically similar to :meth:`~object.__enter__`, the only difference being "
"that it must return an *awaitable*."
msgstr ""

#: ../../reference/datamodel.rst:3495
msgid ""
"Semantically similar to :meth:`~object.__exit__`, the only difference being "
"that it must return an *awaitable*."
msgstr ""

#: ../../reference/datamodel.rst:3498
msgid "An example of an asynchronous context manager class::"
msgstr "非同期コンテキストマネージャクラスの例::"

#: ../../reference/datamodel.rst:3500
msgid ""
"class AsyncContextManager:\n"
"    async def __aenter__(self):\n"
"        await log('entering context')\n"
"\n"
"    async def __aexit__(self, exc_type, exc, tb):\n"
"        await log('exiting context')"
msgstr ""

#: ../../reference/datamodel.rst:3511
msgid "Footnotes"
msgstr "脚注"

#: ../../reference/datamodel.rst:3512
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"特定の条件が満たされた場合、オブジェクトの type を変更することが *できます"
"* 。これは、正しく扱われなかった場合にとても奇妙な動作を引き起こすので、一般"
"的には良い考えではありません。"

#: ../../reference/datamodel.rst:3516
msgid ""
"The :meth:`~object.__hash__`, :meth:`~object.__iter__`, :meth:`~object."
"__reversed__`, :meth:`~object.__contains__`, :meth:`~object."
"__class_getitem__` and :meth:`~os.PathLike.__fspath__` methods have special "
"handling for this. Others will still raise a :exc:`TypeError`, but may do so "
"by relying on the behavior that ``None`` is not callable."
msgstr ""

#: ../../reference/datamodel.rst:3523
msgid ""
"\"Does not support\" here means that the class has no such method, or the "
"method returns :data:`NotImplemented`.  Do not set the method to ``None`` if "
"you want to force fallback to the right operand's reflected method—that will "
"instead have the opposite effect of explicitly *blocking* such fallback."
msgstr ""

#: ../../reference/datamodel.rst:3529
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method -- such as :meth:`~object.__add__` -- fails then the overall "
"operation is not supported, which is why the reflected method is not called."
msgstr ""
"同じ型の被演算子については、無反転のメソッド (たとえば :meth:`~object."
"__add__`) が失敗した場合、その演算はサポートされていないとみなされます。これ"
"は、反射したメソッドが呼び出されない理由です。"

#: ../../reference/datamodel.rst:14 ../../reference/datamodel.rst:152
#: ../../reference/datamodel.rst:163 ../../reference/datamodel.rst:184
#: ../../reference/datamodel.rst:196 ../../reference/datamodel.rst:229
#: ../../reference/datamodel.rst:250 ../../reference/datamodel.rst:265
#: ../../reference/datamodel.rst:283 ../../reference/datamodel.rst:296
#: ../../reference/datamodel.rst:328 ../../reference/datamodel.rst:363
#: ../../reference/datamodel.rst:388 ../../reference/datamodel.rst:409
#: ../../reference/datamodel.rst:427 ../../reference/datamodel.rst:447
#: ../../reference/datamodel.rst:455 ../../reference/datamodel.rst:466
#: ../../reference/datamodel.rst:483 ../../reference/datamodel.rst:519
#: ../../reference/datamodel.rst:534 ../../reference/datamodel.rst:661
#: ../../reference/datamodel.rst:799 ../../reference/datamodel.rst:823
#: ../../reference/datamodel.rst:856 ../../reference/datamodel.rst:935
#: ../../reference/datamodel.rst:1013 ../../reference/datamodel.rst:1040
#: ../../reference/datamodel.rst:1102 ../../reference/datamodel.rst:1206
#: ../../reference/datamodel.rst:1315 ../../reference/datamodel.rst:1425
#: ../../reference/datamodel.rst:1839 ../../reference/datamodel.rst:2854
msgid "object"
msgstr "object"

#: ../../reference/datamodel.rst:14 ../../reference/datamodel.rst:126
msgid "data"
msgstr "データ"

#: ../../reference/datamodel.rst:23 ../../reference/datamodel.rst:296
#: ../../reference/datamodel.rst:343 ../../reference/datamodel.rst:427
#: ../../reference/datamodel.rst:466 ../../reference/datamodel.rst:799
#: ../../reference/datamodel.rst:1059 ../../reference/datamodel.rst:1508
#: ../../reference/datamodel.rst:1750 ../../reference/datamodel.rst:1755
#: ../../reference/datamodel.rst:1839 ../../reference/datamodel.rst:2395
#: ../../reference/datamodel.rst:2824 ../../reference/datamodel.rst:2982
#: ../../reference/datamodel.rst:3017 ../../reference/datamodel.rst:3031
#: ../../reference/datamodel.rst:3080 ../../reference/datamodel.rst:3090
#: ../../reference/datamodel.rst:3118
msgid "built-in function"
msgstr "組み込み関数"

#: ../../reference/datamodel.rst:23
msgid "id"
msgstr "id"

#: ../../reference/datamodel.rst:23 ../../reference/datamodel.rst:126
#: ../../reference/datamodel.rst:2395
msgid "type"
msgstr "type"

#: ../../reference/datamodel.rst:23
msgid "identity of an object"
msgstr "オブジェクトの同一性"

#: ../../reference/datamodel.rst:23
msgid "value of an object"
msgstr "オブジェクトの値"

#: ../../reference/datamodel.rst:23
msgid "type of an object"
msgstr "オブジェクトの型"

#: ../../reference/datamodel.rst:23
msgid "mutable object"
msgstr "変更可能なオブジェクト"

#: ../../reference/datamodel.rst:23
msgid "immutable object"
msgstr "変更不可能なオブジェクト"

#: ../../reference/datamodel.rst:60
msgid "garbage collection"
msgstr "garbage collection"

#: ../../reference/datamodel.rst:60
msgid "reference counting"
msgstr "参照カウント"

#: ../../reference/datamodel.rst:60
msgid "unreachable object"
msgstr "到達不能オブジェクト"

#: ../../reference/datamodel.rst:95 ../../reference/datamodel.rst:935
msgid "container"
msgstr "コンテナ"

#: ../../reference/datamodel.rst:126
msgid "hierarchy"
msgstr "階層"

#: ../../reference/datamodel.rst:126
msgid "extension"
msgstr "拡張"

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:400
#: ../../reference/datamodel.rst:401 ../../reference/datamodel.rst:502
#: ../../reference/datamodel.rst:856 ../../reference/datamodel.rst:876
#: ../../reference/datamodel.rst:1059
msgid "module"
msgstr "module"

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:265
#: ../../reference/datamodel.rst:799
msgid "C"
msgstr "C"

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:265
#: ../../reference/datamodel.rst:799
msgid "language"
msgstr "言語"

#: ../../reference/datamodel.rst:139 ../../reference/datamodel.rst:935
#: ../../reference/datamodel.rst:953 ../../reference/datamodel.rst:1013
#: ../../reference/datamodel.rst:1033
msgid "attribute"
msgstr "属性"

#: ../../reference/datamodel.rst:139
msgid "special"
msgstr "特殊"

#: ../../reference/datamodel.rst:139
msgid "generic"
msgstr "汎用"

#: ../../reference/datamodel.rst:184
msgid "..."
msgstr "..."

#: ../../reference/datamodel.rst:184
msgid "ellipsis literal"
msgstr "ellipsisリテラル"

#: ../../reference/datamodel.rst:196 ../../reference/datamodel.rst:1040
msgid "numeric"
msgstr "数値"

#: ../../reference/datamodel.rst:229 ../../reference/datamodel.rst:235
#: ../../reference/datamodel.rst:343
msgid "integer"
msgstr "整数"

#: ../../reference/datamodel.rst:235
msgid "representation"
msgstr "表現"

#: ../../reference/datamodel.rst:250
msgid "Boolean"
msgstr "Boolean"

#: ../../reference/datamodel.rst:250
msgid "False"
msgstr "False"

#: ../../reference/datamodel.rst:250
msgid "True"
msgstr "True"

#: ../../reference/datamodel.rst:265
msgid "floating-point"
msgstr "浮動小数点"

#: ../../reference/datamodel.rst:265 ../../reference/datamodel.rst:283
msgid "number"
msgstr "number"

#: ../../reference/datamodel.rst:265
msgid "Java"
msgstr "Java"

#: ../../reference/datamodel.rst:283 ../../reference/datamodel.rst:3090
msgid "complex"
msgstr "複素数"

#: ../../reference/datamodel.rst:296 ../../reference/datamodel.rst:427
#: ../../reference/datamodel.rst:466 ../../reference/datamodel.rst:2824
msgid "len"
msgstr "len"

#: ../../reference/datamodel.rst:296 ../../reference/datamodel.rst:1040
msgid "sequence"
msgstr "sequence"

#: ../../reference/datamodel.rst:296
msgid "index operation"
msgstr "インデックス操作"

#: ../../reference/datamodel.rst:296
msgid "item selection"
msgstr "要素の選択"

#: ../../reference/datamodel.rst:296 ../../reference/datamodel.rst:388
#: ../../reference/datamodel.rst:466
msgid "subscription"
msgstr "添字表記"

#: ../../reference/datamodel.rst:311 ../../reference/datamodel.rst:388
msgid "slicing"
msgstr "スライス"

#: ../../reference/datamodel.rst:328
msgid "immutable sequence"
msgstr "変更不能なシーケンス"

#: ../../reference/datamodel.rst:328
msgid "immutable"
msgstr "immutable"

#: ../../reference/datamodel.rst:339 ../../reference/datamodel.rst:1725
#: ../../reference/datamodel.rst:1755
msgid "string"
msgstr "string"

#: ../../reference/datamodel.rst:339
msgid "immutable sequences"
msgstr "immutable sequences"

#: ../../reference/datamodel.rst:343
msgid "chr"
msgstr "chr"

#: ../../reference/datamodel.rst:343
msgid "ord"
msgstr "ord"

#: ../../reference/datamodel.rst:343
msgid "character"
msgstr "文字(str型)"

#: ../../reference/datamodel.rst:343
msgid "Unicode"
msgstr "Unicode 文字列型"

#: ../../reference/datamodel.rst:363
msgid "tuple"
msgstr "tuple"

#: ../../reference/datamodel.rst:363
msgid "singleton"
msgstr "単一要素の"

#: ../../reference/datamodel.rst:363
msgid "empty"
msgstr "空の"

#: ../../reference/datamodel.rst:376 ../../reference/datamodel.rst:1750
msgid "bytes"
msgstr "bytes"

#: ../../reference/datamodel.rst:376
msgid "byte"
msgstr "バイト"

#: ../../reference/datamodel.rst:388
msgid "mutable sequence"
msgstr "変更可能なシーケンス"

#: ../../reference/datamodel.rst:388
msgid "mutable"
msgstr "mutable"

#: ../../reference/datamodel.rst:388 ../../reference/datamodel.rst:953
#: ../../reference/datamodel.rst:1033
msgid "assignment"
msgstr "代入"

#: ../../reference/datamodel.rst:388 ../../reference/datamodel.rst:856
#: ../../reference/datamodel.rst:1462 ../../reference/datamodel.rst:1644
#: ../../reference/datamodel.rst:3145
msgid "statement"
msgstr "statement"

#: ../../reference/datamodel.rst:400
msgid "array"
msgstr "array"

#: ../../reference/datamodel.rst:401
msgid "collections"
msgstr "collections"

#: ../../reference/datamodel.rst:409
msgid "list"
msgstr "list"

#: ../../reference/datamodel.rst:416
msgid "bytearray"
msgstr "bytearray"

#: ../../reference/datamodel.rst:427
msgid "set type"
msgstr "集合型"

#: ../../reference/datamodel.rst:447
msgid "set"
msgstr "集合"

#: ../../reference/datamodel.rst:455
msgid "frozenset"
msgstr "frozenset"

#: ../../reference/datamodel.rst:466 ../../reference/datamodel.rst:1040
msgid "mapping"
msgstr "mapping"

#: ../../reference/datamodel.rst:483 ../../reference/datamodel.rst:935
#: ../../reference/datamodel.rst:1839
msgid "dictionary"
msgstr "dictionary"

#: ../../reference/datamodel.rst:502
msgid "dbm.ndbm"
msgstr "dbm.ndbm"

#: ../../reference/datamodel.rst:502
msgid "dbm.gnu"
msgstr "dbm.gnu"

#: ../../reference/datamodel.rst:519
msgid "callable"
msgstr "callable"

#: ../../reference/datamodel.rst:519 ../../reference/datamodel.rst:534
#: ../../reference/datamodel.rst:743 ../../reference/datamodel.rst:761
#: ../../reference/datamodel.rst:774 ../../reference/datamodel.rst:799
msgid "function"
msgstr "関数"

#: ../../reference/datamodel.rst:519 ../../reference/datamodel.rst:935
#: ../../reference/datamodel.rst:958 ../../reference/datamodel.rst:2776
msgid "call"
msgstr "call"

#: ../../reference/datamodel.rst:519
msgid "invocation"
msgstr "関数呼び出し"

#: ../../reference/datamodel.rst:519
msgid "argument"
msgstr "引数 (argument)"

#: ../../reference/datamodel.rst:534 ../../reference/datamodel.rst:661
msgid "user-defined"
msgstr "ユーザ定義の"

#: ../../reference/datamodel.rst:534
msgid "user-defined function"
msgstr "ユーザ定義関数"

#: ../../reference/datamodel.rst:547
msgid "__closure__ (function attribute)"
msgstr "__closure__ (関数属性)"

#: ../../reference/datamodel.rst:547
msgid "__globals__ (function attribute)"
msgstr "__globals__ (関数属性)"

#: ../../reference/datamodel.rst:547
msgid "global"
msgstr "グローバル"

#: ../../reference/datamodel.rst:547 ../../reference/datamodel.rst:876
msgid "namespace"
msgstr "namespace"

#: ../../reference/datamodel.rst:573
msgid "__doc__ (function attribute)"
msgstr "__doc__ (関数属性)"

#: ../../reference/datamodel.rst:573
msgid "__name__ (function attribute)"
msgstr "__name__ (関数属性)"

#: ../../reference/datamodel.rst:573
msgid "__module__ (function attribute)"
msgstr "__module__ (関数属性)"

#: ../../reference/datamodel.rst:573
msgid "__dict__ (function attribute)"
msgstr "__dict__ (関数属性)"

#: ../../reference/datamodel.rst:573
msgid "__defaults__ (function attribute)"
msgstr "__defaults__ (関数属性)"

#: ../../reference/datamodel.rst:573
msgid "__code__ (function attribute)"
msgstr "__code__ (関数属性)"

#: ../../reference/datamodel.rst:573
msgid "__annotations__ (function attribute)"
msgstr "__annotations__ (関数属性)"

#: ../../reference/datamodel.rst:573
msgid "__kwdefaults__ (function attribute)"
msgstr "__kwdefaults__ (関数属性)"

#: ../../reference/datamodel.rst:573
msgid "__type_params__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:661 ../../reference/datamodel.rst:823
msgid "method"
msgstr "メソッド"

#: ../../reference/datamodel.rst:661
msgid "user-defined method"
msgstr "ユーザ定義メソッド"

#: ../../reference/datamodel.rst:669
msgid "__func__ (method attribute)"
msgstr "__func__ (メソッド属性)"

#: ../../reference/datamodel.rst:669
msgid "__self__ (method attribute)"
msgstr "__self__ (メソッド属性)"

#: ../../reference/datamodel.rst:669
msgid "__doc__ (method attribute)"
msgstr "__doc__ (メソッド属性)"

#: ../../reference/datamodel.rst:669
msgid "__name__ (method attribute)"
msgstr "__name__ (メソッド属性)"

#: ../../reference/datamodel.rst:669
msgid "__module__ (method attribute)"
msgstr "__module__ (メソッド属性)"

#: ../../reference/datamodel.rst:743 ../../reference/datamodel.rst:1206
msgid "generator"
msgstr "ジェネレータ"

#: ../../reference/datamodel.rst:743
msgid "iterator"
msgstr "iterator"

#: ../../reference/datamodel.rst:761 ../../reference/datamodel.rst:3332
msgid "coroutine"
msgstr "コルーチン"

#: ../../reference/datamodel.rst:774
msgid "asynchronous generator"
msgstr "asynchronous generator"

#: ../../reference/datamodel.rst:774
msgid "asynchronous iterator"
msgstr "asynchronous iterator"

#: ../../reference/datamodel.rst:823
msgid "built-in method"
msgstr "組み込みメソッド"

#: ../../reference/datamodel.rst:823
msgid "built-in"
msgstr "組み込み"

#: ../../reference/datamodel.rst:856
msgid "import"
msgstr "import"

#: ../../reference/datamodel.rst:876
msgid "__name__ (module attribute)"
msgstr "__name__ (モジュール属性)"

#: ../../reference/datamodel.rst:876
msgid "__doc__ (module attribute)"
msgstr "__doc__ (モジュール属性)"

#: ../../reference/datamodel.rst:876
msgid "__file__ (module attribute)"
msgstr "__file__ (モジュール属性)"

#: ../../reference/datamodel.rst:876
msgid "__annotations__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:907
msgid "__dict__ (module attribute)"
msgstr "__dict__ (モジュール属性)"

#: ../../reference/datamodel.rst:935 ../../reference/datamodel.rst:953
#: ../../reference/datamodel.rst:1013 ../../reference/datamodel.rst:1627
#: ../../reference/datamodel.rst:2506
msgid "class"
msgstr "クラス"

#: ../../reference/datamodel.rst:935 ../../reference/datamodel.rst:1013
#: ../../reference/datamodel.rst:1033
msgid "class instance"
msgstr "クラスインスタンス"

#: ../../reference/datamodel.rst:935 ../../reference/datamodel.rst:1013
#: ../../reference/datamodel.rst:2776
msgid "instance"
msgstr "instance"

#: ../../reference/datamodel.rst:935 ../../reference/datamodel.rst:958
msgid "class object"
msgstr "クラスオブジェクト"

#: ../../reference/datamodel.rst:962
msgid "__name__ (class attribute)"
msgstr "__name__ (クラス属性)"

#: ../../reference/datamodel.rst:962
msgid "__module__ (class attribute)"
msgstr "__module__ (クラス属性)"

#: ../../reference/datamodel.rst:962
msgid "__dict__ (class attribute)"
msgstr "__dict__ (クラス属性)"

#: ../../reference/datamodel.rst:962
msgid "__bases__ (class attribute)"
msgstr "__bases__ (クラス属性)"

#: ../../reference/datamodel.rst:962
msgid "__doc__ (class attribute)"
msgstr "__doc__ (クラス属性)"

#: ../../reference/datamodel.rst:962
msgid "__annotations__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:962
msgid "__type_params__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:962
msgid "__static_attributes__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:962
msgid "__firstlineno__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1048
msgid "__dict__ (instance attribute)"
msgstr "__dict__ (インスタンス属性)"

#: ../../reference/datamodel.rst:1048
msgid "__class__ (instance attribute)"
msgstr "__class__ (インスタンス属性)"

#: ../../reference/datamodel.rst:1059
msgid "open"
msgstr "open"

#: ../../reference/datamodel.rst:1059
msgid "io"
msgstr "io"

#: ../../reference/datamodel.rst:1059
msgid "popen() (in module os)"
msgstr "popen() (os モジュール)"

#: ../../reference/datamodel.rst:1059
msgid "makefile() (socket method)"
msgstr "makefile() (socket のメソッド)"

#: ../../reference/datamodel.rst:1059
msgid "sys.stdin"
msgstr "sys.stdin"

#: ../../reference/datamodel.rst:1059
msgid "sys.stdout"
msgstr "sys.stdout"

#: ../../reference/datamodel.rst:1059
msgid "sys.stderr"
msgstr "sys.stderr"

#: ../../reference/datamodel.rst:1059
msgid "stdio"
msgstr "stdio"

#: ../../reference/datamodel.rst:1059
msgid "stdin (in module sys)"
msgstr "stdin (sys モジュール)"

#: ../../reference/datamodel.rst:1059
msgid "stdout (in module sys)"
msgstr "stdout (sys モジュール)"

#: ../../reference/datamodel.rst:1059
msgid "stderr (in module sys)"
msgstr "stderr (sys モジュール)"

#: ../../reference/datamodel.rst:1088
msgid "internal type"
msgstr "内部型"

#: ../../reference/datamodel.rst:1088
msgid "types, internal"
msgstr "型, 内部の"

#: ../../reference/datamodel.rst:1102
msgid "bytecode"
msgstr "bytecode"

#: ../../reference/datamodel.rst:1102
msgid "code"
msgstr "コード"

#: ../../reference/datamodel.rst:1102
msgid "code object"
msgstr "コードオブジェクト"

#: ../../reference/datamodel.rst:1113
msgid "co_argcount (code object attribute)"
msgstr "co_argcount (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_posonlyargcount (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1113
msgid "co_kwonlyargcount (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1113
msgid "co_code (code object attribute)"
msgstr "co_code (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_consts (code object attribute)"
msgstr "co_consts (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_filename (code object attribute)"
msgstr "co_filename (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_firstlineno (code object attribute)"
msgstr "co_firstlineno (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_flags (code object attribute)"
msgstr "co_flags (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_lnotab (code object attribute)"
msgstr "co_lnotab (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_name (code object attribute)"
msgstr "co_name (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_names (code object attribute)"
msgstr "co_names (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_nlocals (code object attribute)"
msgstr "co_nlocals (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_stacksize (code object attribute)"
msgstr "co_stacksize (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_varnames (code object attribute)"
msgstr "co_varnames (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_cellvars (code object attribute)"
msgstr "co_cellvars (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_freevars (code object attribute)"
msgstr "co_freevars (コードオブジェクトの属性)"

#: ../../reference/datamodel.rst:1113
msgid "co_qualname (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1224
msgid "documentation string"
msgstr "ドキュメント文字列"

#: ../../reference/datamodel.rst:1315
msgid "frame"
msgstr "フレーム"

#: ../../reference/datamodel.rst:1321
msgid "f_back (frame attribute)"
msgstr "f_back (フレーム属性)"

#: ../../reference/datamodel.rst:1321
msgid "f_code (frame attribute)"
msgstr "f_code (フレーム属性)"

#: ../../reference/datamodel.rst:1321
msgid "f_globals (frame attribute)"
msgstr "f_globals (フレーム属性)"

#: ../../reference/datamodel.rst:1321
msgid "f_locals (frame attribute)"
msgstr "f_locals (フレーム属性)"

#: ../../reference/datamodel.rst:1321
msgid "f_lasti (frame attribute)"
msgstr "f_lasti (フレーム属性)"

#: ../../reference/datamodel.rst:1321
msgid "f_builtins (frame attribute)"
msgstr "f_builtins (フレーム属性)"

#: ../../reference/datamodel.rst:1365
msgid "f_trace (frame attribute)"
msgstr "f_trace (フレーム属性)"

#: ../../reference/datamodel.rst:1365
msgid "f_trace_lines (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1365
msgid "f_trace_opcodes (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1365
msgid "f_lineno (frame attribute)"
msgstr "f_lineno (フレーム属性)"

#: ../../reference/datamodel.rst:1425
msgid "traceback"
msgstr "traceback"

#: ../../reference/datamodel.rst:1425
msgid "stack"
msgstr "スタック"

#: ../../reference/datamodel.rst:1425
msgid "trace"
msgstr "トレース"

#: ../../reference/datamodel.rst:1425
msgid "exception"
msgstr "例外"

#: ../../reference/datamodel.rst:1425
msgid "handler"
msgstr "ハンドラ"

#: ../../reference/datamodel.rst:1425
msgid "execution"
msgstr "実行"

#: ../../reference/datamodel.rst:1425
msgid "exc_info (in module sys)"
msgstr "exc_info (sys モジュール)"

#: ../../reference/datamodel.rst:1425
msgid "last_traceback (in module sys)"
msgstr "last_traceback (sys モジュール)"

#: ../../reference/datamodel.rst:1425
msgid "sys.exc_info"
msgstr "sys.exc_info"

#: ../../reference/datamodel.rst:1425
msgid "sys.exception"
msgstr ""

#: ../../reference/datamodel.rst:1425
msgid "sys.last_traceback"
msgstr "sys.last_traceback"

#: ../../reference/datamodel.rst:1462
msgid "tb_frame (traceback attribute)"
msgstr "tb_frame (トレースバック属性)"

#: ../../reference/datamodel.rst:1462
msgid "tb_lineno (traceback attribute)"
msgstr "tb_lineno (トレースバック属性)"

#: ../../reference/datamodel.rst:1462
msgid "tb_lasti (traceback attribute)"
msgstr "tb_lasti (トレースバック属性)"

#: ../../reference/datamodel.rst:1462
msgid "try"
msgstr "try"

#: ../../reference/datamodel.rst:1492
msgid "tb_next (traceback attribute)"
msgstr "tb_next (トレースバック属性)"

#: ../../reference/datamodel.rst:1508 ../../reference/datamodel.rst:2854
msgid "slice"
msgstr "slice"

#: ../../reference/datamodel.rst:1514
msgid "start (slice object attribute)"
msgstr "start (スライスオブジェクトの属性)"

#: ../../reference/datamodel.rst:1514
msgid "stop (slice object attribute)"
msgstr "stop (スライスオブジェクトの属性)"

#: ../../reference/datamodel.rst:1514
msgid "step (slice object attribute)"
msgstr "step (スライスオブジェクトの属性)"

#: ../../reference/datamodel.rst:1562
msgid "operator"
msgstr "operator"

#: ../../reference/datamodel.rst:1562
msgid "overloading"
msgstr "オーバーロード"

#: ../../reference/datamodel.rst:1562
msgid "__getitem__() (mapping object method)"
msgstr "__getitem__() (マップオブジェクトのメソッド)"

#: ../../reference/datamodel.rst:1598
msgid "subclassing"
msgstr "サブクラス化"

#: ../../reference/datamodel.rst:1598
msgid "immutable types"
msgstr "変更不能な型"

#: ../../reference/datamodel.rst:1627
msgid "constructor"
msgstr "コンストラクタ"

#: ../../reference/datamodel.rst:1644
msgid "destructor"
msgstr "デストラクタ"

#: ../../reference/datamodel.rst:1644
msgid "finalizer"
msgstr ""

#: ../../reference/datamodel.rst:1644
msgid "del"
msgstr "del"

#: ../../reference/datamodel.rst:1708
msgid "repr() (built-in function)"
msgstr "repr() (組み込み関数)"

#: ../../reference/datamodel.rst:1708
msgid "__repr__() (object method)"
msgstr "__repr__() (オブジェクトメソッド)"

#: ../../reference/datamodel.rst:1725
msgid "__str__() (object method)"
msgstr "__str__() (オブジェクトメソッド)"

#: ../../reference/datamodel.rst:1725
msgid "format() (built-in function)"
msgstr "format() (組み込み関数)"

#: ../../reference/datamodel.rst:1725
msgid "print() (built-in function)"
msgstr "print() (組み込み関数)"

#: ../../reference/datamodel.rst:1755
msgid "__format__() (object method)"
msgstr "__format__() (オブジェクトメソッド)"

#: ../../reference/datamodel.rst:1755
msgid "conversion"
msgstr "変換"

#: ../../reference/datamodel.rst:1755
msgid "print"
msgstr "print"

#: ../../reference/datamodel.rst:1794
msgid "comparisons"
msgstr "比較"

#: ../../reference/datamodel.rst:1839
msgid "hash"
msgstr "hash"

#: ../../reference/datamodel.rst:1920
msgid "__len__() (mapping object method)"
msgstr "__len__() (マップオブジェクトのメソッド)"

#: ../../reference/datamodel.rst:2024
msgid "__getattr__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:2024
msgid "__dir__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:2024
msgid "__class__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:2395
msgid "metaclass"
msgstr "metaclass"

#: ../../reference/datamodel.rst:2395
msgid "= (equals)"
msgstr ""

#: ../../reference/datamodel.rst:2395
msgid "class definition"
msgstr ""

#: ../../reference/datamodel.rst:2459
msgid "metaclass hint"
msgstr ""

#: ../../reference/datamodel.rst:2482
msgid "__prepare__ (metaclass method)"
msgstr ""

#: ../../reference/datamodel.rst:2506
msgid "body"
msgstr ""

#: ../../reference/datamodel.rst:2526
msgid "__class__ (method cell)"
msgstr ""

#: ../../reference/datamodel.rst:2526
msgid "__classcell__ (class namespace entry)"
msgstr ""

#: ../../reference/datamodel.rst:2824
msgid "__bool__() (object method)"
msgstr "__bool__() (オブジェクトメソッド)"

#: ../../reference/datamodel.rst:2982 ../../reference/datamodel.rst:3017
msgid "divmod"
msgstr "divmod"

#: ../../reference/datamodel.rst:2982 ../../reference/datamodel.rst:3017
#: ../../reference/datamodel.rst:3031
msgid "pow"
msgstr "pow"

#: ../../reference/datamodel.rst:3080
msgid "abs"
msgstr "abs"

#: ../../reference/datamodel.rst:3090
msgid "int"
msgstr "int"

#: ../../reference/datamodel.rst:3090
msgid "float"
msgstr "浮動小数点数"

#: ../../reference/datamodel.rst:3118
msgid "round"
msgstr "round"

#: ../../reference/datamodel.rst:3145
msgid "with"
msgstr "with"

#: ../../reference/datamodel.rst:3145
msgid "context manager"
msgstr "context manager"
