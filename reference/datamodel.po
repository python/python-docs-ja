# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# tomo, 2017-2018
# 秘湯 <xwhhsprings@gmail.com>, 2015-2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:22+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr "データモデル"

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "オブジェクト、値、および型"

#: ../../reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer,\" code is also represented by objects.)"
msgstr ""
"Python における :dfn:`オブジェクト (object)` とは、データを抽象的に表したもの"
"です。Python プログラムにおけるデータは全て、オブジェクトまたはオブジェクト間"
"の関係として表されます。(ある意味では、プログラムコードもまたオブジェクトとし"
"て表されます。これはフォン・ノイマン: Von Neumann の \"プログラム記憶方式コン"
"ピュータ: stored program computer\" のモデルに適合します。)"

#: ../../reference/datamodel.rst:32
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The ':keyword:`is`' operator compares the identity of "
"two objects; the :func:`id` function returns an integer representing its "
"identity (currently implemented as its address). An object's :dfn:`type` is "
"also unchangeable. [#]_ An object's type determines the operations that the "
"object supports (e.g., \"does it have a length?\") and also defines the "
"possible values for objects of that type.  The :func:`type` function returns "
"an object's type (which is an object itself).  The *value* of some objects "
"can change.  Objects whose value can change are said to be *mutable*; "
"objects whose value is unchangeable once they are created are called "
"*immutable*. (The value of an immutable container object that contains a "
"reference to a mutable object can change when the latter's value is changed; "
"however the container is still considered immutable, because the collection "
"of objects it contains cannot be changed.  So, immutability is not strictly "
"the same as having an unchangeable value, it is more subtle.) An object's "
"mutability is determined by its type; for instance, numbers, strings and "
"tuples are immutable, while dictionaries and lists are mutable."
msgstr ""
"オブジェクトはアイデンティティ値 (identity) 、型 (type) 、そして値 (value) を"
"持ちます。オブジェクトが一度生成されると、そのオブジェクトの *アイデンティ"
"ティ値* は決して変化することがありません; アイデンティティ値をオブジェクトの"
"メモリ上のアドレスと考えてもかまいません。演算子 ':keyword:`is`' は、二つのオ"
"ブジェクト間のアイデンティティ値を比較します; 関数 :func:`id` は、オブジェク"
"トのアイデンティティ値を表す整数 (現在の実装ではオブジェクトのメモリ上のアド"
"レス) を返します。オブジェクトの :dfn:`型` もまた変わることがありません。 "
"[#]_ オブジェクトの型は、そのオブジェクトのサポートする操作 (\"長さを持ってい"
"るか？\" など) を決定し、その型のオブジェクトが取りうる値について定義していま"
"す。 :func:`type` 関数は、オブジェクトの型 (型自体も一つのオブジェクトです) "
"を返します。オブジェクトによっては、 *値 (value)* を変えることができます。値"
"を変えることができるオブジェクトは *変更可能 (mutable)* であるといいます; 値"
"を一度設定すると、その後は変えることができないオブジェクトは *変更不能 "
"(immutable)* であると呼びます。 (変更不能なコンテナオブジェクトが変更可能なオ"
"ブジェクトへの参照を含んでいる場合、その値は後者のオブジェクトの変更によって"
"変わる場合があります; その場合でも、コンテナの含んでいるオブジェクトの集まり"
"は変わらないため、コンテナは変更不能と考えます。したがって、変更不能性 "
"(immutability) は、厳密には変更できない値を持っていることとは違い、もっと微妙"
"な概念です。) オブジェクトの変更可能性は型で決定されます; 例えば、数値、文字"
"列、およびタプルは変更不能であり、辞書やリストは変更可能です。"

#: ../../reference/datamodel.rst:55
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""
"オブジェクトを明示的に破壊することはできません; しかし、オブジェクトに到達不"
"能 (unreachable) になると、ガベージコレクション (garbage-collection) によって"
"処理されます。実装では、ごみ収集を遅らせたり、全く行わないようにすることがで"
"きます --- 到達可能なオブジェクトをごみ収集処理してしまわないかぎり、どう実装"
"するかは実装品質の問題です。"

#: ../../reference/datamodel.rst:63
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (ex: "
"always close files)."
msgstr ""
"現在の CPython 実装では参照カウント(reference-counting) 方式を使っており、(オ"
"プションとして) 循環参照を行っているごみオブジェクトを遅延検出します。この実"
"装ではほとんどのオブジェクトを到達不能になると同時に処理することができます"
"が、循環参照を含むごみオブジェクトの収集が確実に行われるよう保証しているわけ"
"ではありません。循環参照を持つごみオブジェクト収集の制御については、 :mod:"
"`gc` モジュールを参照してください。 CPython以外の実装は別の方式を使っており、"
"CPythonも将来は別の方式を使うかもしれません。オブジェクトが到達不能になったと"
"きに即座に終了処理されることに頼らないでください (例えば、ファイルは必ず閉じ"
"てください)。"

#: ../../reference/datamodel.rst:72
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a ':keyword:`try`...\\ :keyword:`except`' "
"statement may keep objects alive."
msgstr ""
"実装のトレース機能やデバッグ機能を使えば、通常は収集されてしまうようなオブ"
"ジェクトを生かしておくことがあるので注意してください。また、 ':keyword:"
"`try`...\\ :keyword:`except`' 文を使って例外を捕捉できるようにすると、オブ"
"ジェクトを生かしておくことがあります。"

#: ../../reference/datamodel.rst:77
msgid ""
"Some objects contain references to \"external\" resources such as open files "
"or windows.  It is understood that these resources are freed when the object "
"is garbage-collected, but since garbage collection is not guaranteed to "
"happen, such objects also provide an explicit way to release the external "
"resource, usually a :meth:`close` method. Programs are strongly recommended "
"to explicitly close such objects.  The ':keyword:`try`...\\ :keyword:"
"`finally`' statement provides a convenient way to do this."
msgstr ""
"オブジェクトによっては、開かれたファイルやウィンドウといった、 \"外部 "
"(external) の\" リソースに対する参照を行っています。これらのリソースは、オブ"
"ジェクトがごみ収集された際に解放されるものと理解されていますが、ごみ収集が行"
"われる保証はないので、こうしたオブジェクトでは外部リソースを明示的に解放する"
"方法、大抵は :meth:`close` メソッドを提供しています。こうしたオブジェクトは明"
"示的に close するよう強く奨めます。操作をする際には、':keyword:`try`...\\ :"
"keyword:`finally`' 文を使うと便利です。"

#: ../../reference/datamodel.rst:87
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk "
"about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"他のオブジェクトに対する参照をもつオブジェクトもあります; これらは *コンテナ "
"(container)* と呼ばれます。コンテナオブジェクトの例として、タプル、リスト、お"
"よび辞書が挙げられます。オブジェクトへの参照自体がコンテナの値の一部です。ほ"
"とんどの場合、コンテナの値というと、コンテナに入っているオブジェクトの値のこ"
"とを指し、それらオブジェクトのアイデンティティではありません; しかしながら、"
"コンテナの変更可能性について述べる場合、今まさにコンテナに入っているオブジェ"
"クトのアイデンティティのことを指します。したがって、 (タプルのように) 変更不"
"能なオブジェクトが変更可能なオブジェクトへの参照を含む場合、その値が変化する"
"のは変更可能なオブジェクトが変更された時、ということになります。"

#: ../../reference/datamodel.rst:96
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer "
"to the same object with the value one, depending on the implementation, but "
"after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two "
"different, unique, newly created empty lists. (Note that ``c = d = []`` "
"assigns the same object to both ``c`` and ``d``.)"
msgstr ""
"型はオブジェクトの動作のほとんど全てに影響します。オブジェクトのアイデンティ"
"ティが重要かどうかでさえ、ある意味では型に左右されます: 変更不能な型では、新"
"たな値を計算するような操作を行うと、実際には同じ型と値を持った既存のオブジェ"
"クトへの参照を返すことがありますが、変更可能なオブジェクトではそのような動作"
"は起こりえません。例えば、 ``a = 1; b = 1`` とすると、 ``a`` と ``b`` は値 1 "
"を持つ同じオブジェクトを参照するときもあるし、そうでないときもあります。これ"
"は実装に依存します。しかし、 ``c = []; d = []`` とすると、 ``c`` と ``d`` は"
"それぞれ二つの異なった、互いに一意な、新たに作成された空のリストを参照するこ"
"とが保証されています。 (``c = d = []`` とすると、 ``c`` と ``d`` の両方に同じ"
"オブジェクトを代入します)"

#: ../../reference/datamodel.rst:110
msgid "The standard type hierarchy"
msgstr "標準型の階層"

#: ../../reference/datamodel.rst:119
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the "
"type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.)."
msgstr ""
"以下は Python に組み込まれている型のリストです。(C、Java、または実装に使われ"
"ているその他の言語で書かれた) 拡張モジュールでは、その他に新たな型を定義する"
"ことができます。将来のバージョンの Python では、型の階層に新たな型 (整数を"
"使って効率的に記憶される有理数型、など) を追加することができるかもしれませ"
"ん。"

#: ../../reference/datamodel.rst:129
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation "
"and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""
"以下に説明する型のいくつかには、'特殊属性 (special attribute)' と題された段落"
"が連ねられています。これらの属性は実装へのアクセス手段を提供するもので、一般"
"的な用途に利用するためのものではありません。特殊属性の定義は将来変更される可"
"能性があります。"

#: ../../reference/datamodel.rst:139
msgid "None"
msgstr "None"

#: ../../reference/datamodel.rst:136
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from "
"functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在"
"しません。このオブジェクトは組み込み名 ``None`` でアクセスされます。このオブ"
"ジェクトは、様々な状況で値が存在しないことをしめします。例えば、明示的に値を"
"返さない関数は ``None`` を返します。 ``None`` の真値 (truth value) は偽 "
"(false) です。"

#: ../../reference/datamodel.rst:149
msgid "NotImplemented"
msgstr "NotImplemented"

#: ../../reference/datamodel.rst:144
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods may return this value if they do "
"not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  Its truth value is true."
msgstr ""
"この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在"
"しません。このオブジェクトは組み込み名 ``NotImplemented`` でアクセスされま"
"す。数値演算に関するメソッドや拡張比較 (rich comparison) メソッドは、被演算子"
"が該当する演算を行うための実装をもたない場合、この値を返すことがあります。(演"
"算子によっては、インタプリタが関連のある演算を試したり、他の代替操作を行いま"
"す。) 真値は真 (true) です。"

#: ../../reference/datamodel.rst:157
msgid "Ellipsis"
msgstr "Ellipsis"

#: ../../reference/datamodel.rst:154
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``Ellipsis``. It is used "
"to indicate the presence of the ``...`` syntax in a slice.  Its truth value "
"is true."
msgstr ""
"この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在"
"しません。このオブジェクトは組み込み名 ``Ellipsis`` でアクセスされます。スラ"
"イス内に ``...`` 構文がある場合に使われます。真値は真 (true)です。"

#: ../../reference/datamodel.rst:249
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../../reference/datamodel.rst:162
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable; "
"once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""
"数値リテラルによって作成されたり、算術演算や組み込みの算術関数によって返され"
"るオブジェクトです。数値オブジェクトは変更不能です; 一度値が生成されると、二"
"度と変更されることはありません。Python の数値オブジェクトはいうまでもなく数学"
"で言うところの数値と強く関係していますが、コンピュータ内で数値を表現する際に"
"伴う制限を受けています。"

#: ../../reference/datamodel.rst:168
msgid ""
"Python distinguishes between integers, floating point numbers, and complex "
"numbers:"
msgstr "Python は整数、浮動小数点数、複素数の間で区別を行っています:"

#: ../../reference/datamodel.rst:224
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral` (整数)"

#: ../../reference/datamodel.rst:174
msgid ""
"These represent elements from the mathematical set of integers (positive and "
"negative)."
msgstr ""
"整数型は、整数(正の数および負の数)を表す数学的集合内における要素を表現する型"
"です。"

#: ../../reference/datamodel.rst:177
msgid "There are three types of integers:"
msgstr "以下に三つの整数型を示します:"

#: ../../reference/datamodel.rst:192
msgid "Plain integers"
msgstr "(通常の) 整数型 (plain integer)"

#: ../../reference/datamodel.rst:184
msgid ""
"These represent numbers in the range -2147483648 through 2147483647. (The "
"range may be larger on machines with a larger natural word size, but not "
"smaller.)  When the result of an operation would fall outside this range, "
"the result is normally returned as a long integer (in some cases, the "
"exception :exc:`OverflowError` is raised instead).  For the purpose of shift "
"and mask operations, integers are assumed to have a binary, 2's complement "
"notation using 32 or more bits, and hiding no bits from the user (i.e., all "
"4294967296 different bit patterns correspond to different values)."
msgstr ""
"-2147483648 から 2147483647 までの整数を表現します (基本ワードサイズ: "
"natural word size がより大きなマシンではより大きな定義域になることもありま"
"す。より小さくなることはありません。) 演算の結果が定義域を超えた値になった場"
"合、結果は通常長整数で返されます (場合によっては、 :exc:`OverflowError` が送"
"出されます) 。シフト演算やマスク演算のために、整数は 32 ビット以上の 2 の補数"
"で表されたバイナリ表現を持つ (すなわち、4294967296 の異なったビットパターン全"
"てが異なる値を持つ) と仮定されています。"

#: ../../reference/datamodel.rst:201
msgid "Long integers"
msgstr "長整数型 (long integer)"

#: ../../reference/datamodel.rst:197
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""
"長整数は無限の定義域を持ち、利用可能な (仮想) メモリサイズの制限のみをうけま"
"す。長整数はシフト演算やマスク演算のためにバイナリ表現をもつものと仮定されま"
"す。負の数は符号ビットが左に無限に延びているような錯覚を与える 2 の補数表現の"
"変型で表されます。"

#: ../../reference/datamodel.rst:214
msgid "Booleans"
msgstr "ブール型 (boolean)"

#: ../../reference/datamodel.rst:209
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects. "
"The Boolean type is a subtype of plain integers, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception "
"being that when converted to a string, the strings ``\"False\"`` or "
"``\"True\"`` are returned, respectively."
msgstr ""
"真偽値の False と True を表します。``False`` と ``True`` を表す 2 つのオブ"
"ジェクトのみがブール値オブジェクトです。ブール型は整数型の部分型であり、ほと"
"んどの状況でそれぞれ 0 と 1 のように振る舞いますが、例外として文字列に変換さ"
"れたときはそれぞれ ``\"False\"`` および ``\"True\"`` という文字列が返されま"
"す。"

#: ../../reference/datamodel.rst:218
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers and the least surprises when switching between the plain and long "
"integer domains.  Any operation, if it yields a result in the plain integer "
"domain, will yield the same result in the long integer domain or when using "
"mixed operands.  The switch between domains is transparent to the programmer."
msgstr ""
"整数表現に関する規則は、シフト演算やマスク演算において、負の整数も含めて最も"
"有意義な解釈ができるように、かつ通常の整数と長整数との間で定義域を切り替える"
"際にできるだけ混乱しないように決められています。すべての演算で、演算結果が"
"オーバフローを起こさずに整数の定義域の値になる場合は、長整数を使った場合で"
"も、被演算子に整数と長整数を混合した場合でも同じ結果になります。定義域の切り"
"替えはプログラマに対して透過的に(意識させることなく)行われます。"

#: ../../reference/datamodel.rst:239
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`) (実数)"

#: ../../reference/datamodel.rst:233
msgid ""
"These represent machine-level double precision floating point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does "
"not support single-precision floating point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to "
"complicate the language with two kinds of floating point numbers."
msgstr ""
"この型は計算機レベルの倍精度浮動小数点数を表現します。表現可能な値の範囲や"
"オーバーフローの扱いは計算機のアーキテクチャ（および、CやJavaによる実装）に従"
"います。Pythonは単精度浮動小数点数をサポートしません。一般的に単精度浮動小数"
"点数を使う理由はプロセッサーとメモリの使用を節約するためと説明されます。しか"
"し、こうした節約はPythonでオブジェクトを扱う際のオーバーヘッドに比べれば微々"
"たるものです。また、2種類の浮動小数点数型を持つことで複雑になる理由はありませ"
"ん。"

#: ../../reference/datamodel.rst:249
msgid ":class:`numbers.Complex`"
msgstr ":class:`numbers.Complex` (複素数)"

#: ../../reference/datamodel.rst:246
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating point numbers.  The same caveats apply as for floating point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""
"この型は、計算機レベルで倍精度とされている浮動小数点を 2 つ一組にして複素数を"
"表現します。浮動小数点について述べたのと同じ性質が当てはまります。複素数 "
"``z`` の実数部および虚数部は、それぞれ読み出し専用属性 ``z.real`` および ``z."
"imag`` で取り出すことができます。"

#: ../../reference/datamodel.rst:386
msgid "Sequences"
msgstr "シーケンス型 (sequence)"

#: ../../reference/datamodel.rst:259
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""
"この型は、有限の順序集合 (ordered set) を表現します。要素は非負の整数でインデ"
"クス化されています。組み込み関数 :func:`len` を使うと、シーケンスの要素数を返"
"します。シーケンスの長さが *n* の場合、インデクスは 0, 1, ..., *n* -1 からな"
"る集合です。シーケンス *a* の要素 *i* は ``a[i]`` で選択します。"

#: ../../reference/datamodel.rst:266
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type.  This implies that the index set is renumbered "
"so that it starts at 0."
msgstr ""
"シーケンスはスライス操作 (slice) もサポートしています: ``a[i:j]`` とすると、 "
"*i* ``<=`` *k* ``<`` *j* であるインデクス *k* をもつ全ての要素を選択します。"
"式表現としてスライスを用いた場合、スライスは同じ型をもつ新たなシーケンスを表"
"します。新たなシーケンス内では、インデクス集合が 0 から始まるようにインデクス"
"の値を振りなおします。"

#: ../../reference/datamodel.rst:273
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"シーケンスによっては、第三の \"ステップ (step)\" パラメタを持つ \"拡張スライ"
"ス (extended slice)\" もサポートしています: ``a[i:j:k]`` は、 ``x = i + "
"n*k``, *n* ``>=`` ``0`` かつ *i* ``<=`` *x* ``<`` *j* であるようなインデクス "
"*x* を持つような *a* 全ての要素を選択します。"

#: ../../reference/datamodel.rst:277
msgid "Sequences are distinguished according to their mutability:"
msgstr "シーケンスは、変更可能なものか、そうでないかで区別されています:"

#: ../../reference/datamodel.rst:352
msgid "Immutable sequences"
msgstr "変更不能なシーケンス (immutable sequence)"

#: ../../reference/datamodel.rst:284
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may "
"be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""
"変更不能なシーケンス型のオブジェクトは、一度生成されるとその値を変更すること"
"ができません。 (オブジェクトに他のオブジェクトへの参照が入っている場合、参照"
"されているオブジェクトは変更可能なオブジェクトでもよく、その値は変更される可"
"能性があります; しかし、変更不能なオブジェクトが直接参照しているオブジェクト"
"の集合自体は、変更することができません。)"

#: ../../reference/datamodel.rst:289
msgid "The following types are immutable sequences:"
msgstr "以下の型は変更不能なシーケンス型です:"

#: ../../reference/datamodel.rst:319
msgid "Strings"
msgstr "文字列型 (string)"

#: ../../reference/datamodel.rst:300
msgid ""
"The items of a string are characters.  There is no separate character type; "
"a character is represented by a string of one item. Characters represent (at "
"least) 8-bit bytes.  The built-in functions :func:`chr` and :func:`ord` "
"convert between characters and nonnegative integers representing the byte "
"values.  Bytes with the values 0--127 usually represent the corresponding "
"ASCII values, but the interpretation of values is up to the program.  The "
"string data type is also used to represent arrays of bytes, e.g., to hold "
"data read from a file."
msgstr ""
"文字列の各要素は文字 (character) です。文字型 (character type) は存在しませ"
"ん。単一の文字は、要素が一つだけの文字列として表現されます。各文字は(少なくと"
"も)8-bit の 1 byte を表現します。組み込み関数 :func:`chr` および :func:`ord` "
"を使うと、文字と非負の整数で表されたバイト値の間で変換を行えます。0--127 の値"
"を持つバイト値は、通常同じ ASCII 値をもつ文字を表現していますが、値をどう解釈"
"するかはプログラムにゆだねられています。文字列データ型はまた、例えばファイル"
"から読み出されたデータを記憶するといった用途で、バイト値のアレイを表現するた"
"めに用いられます。"

#: ../../reference/datamodel.rst:316
msgid ""
"(On systems whose native character set is not ASCII, strings may use EBCDIC "
"in their internal representation, provided the functions :func:`chr` and :"
"func:`ord` implement a mapping between ASCII and EBCDIC, and string "
"comparison preserves the ASCII order. Or perhaps someone can propose a "
"better rule?)"
msgstr ""
"(ネイティブの文字セットが ASCIIでないシステムでは、 :func:`chr` や :func:"
"`ord` が ASCII と EBCDIC との間で対応付けを行っており、文字列間の比較で "
"ASCII 順が守られる限り、文字列の内部表現として EBCDIC を使ってもかまいませ"
"ん。誰か他にもっとましなルールをお持ちですか?)"

#: ../../reference/datamodel.rst:340
msgid "Unicode"
msgstr "Unicode 文字列型"

#: ../../reference/datamodel.rst:331
msgid ""
"The items of a Unicode object are Unicode code units.  A Unicode code unit "
"is represented by a Unicode object of one item and can hold either a 16-bit "
"or 32-bit value representing a Unicode ordinal (the maximum value for the "
"ordinal is given in ``sys.maxunicode``, and depends on how Python is "
"configured at compile time).  Surrogate pairs may be present in the Unicode "
"object, and will be reported as two separate items.  The built-in functions :"
"func:`unichr` and :func:`ord` convert between code units and nonnegative "
"integers representing the Unicode ordinals as defined in the Unicode "
"Standard 3.0. Conversion from and to other encodings are possible through "
"the Unicode method :meth:`encode` and the built-in function :func:`unicode`."
msgstr ""
"Unicode オブジェクトの各要素は Unicode コード単位です。 Unicode コード単位と"
"は、単一の Unicode オブジェクトで、Unicode 序数を表現する 16-bit または 32-"
"bit の値を保持できるものです (この序数の最大値は ``sys.maxunicode`` で与えら"
"れており、コンパイル時に Python がどう設定されているかに依存します)。 "
"Unicode オブジェクト内にサロゲートペア (surrogate pair) があってもよく、"
"Python はサロゲートペアを二つの別々の Unicode 要素として報告します。組み込み"
"関数 :func:`unichr` および :func:`ord` は、コード単位と非負の整数で表された "
"Unicode 標準 3.0 で定義された Unicode 序数との間で変換を行います。他の文字エ"
"ンコード形式との相互変換は、 Unicode メソッド :meth:`encode` および組み込み関"
"数 :func:`unicode` で行うことができます。"

#: ../../reference/datamodel.rst:352
msgid "Tuples"
msgstr "タプル型 (tuple)"

#: ../../reference/datamodel.rst:348
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""
"タプルの要素は任意の Python オブジェクトです。二つ以上の要素からなるタプル"
"は、個々の要素を表現する式をカンマで区切って構成します。単一の要素からなるタ"
"プル (単集合 'singleton') を作るには、要素を表現する式の直後にカンマをつけま"
"す (単一の式だけではタプルを形成しません。これは、式をグループ化するのに丸括"
"弧を使えるようにしなければならないからです)。要素の全くない丸括弧の対を作ると"
"空のタプルになります。"

#: ../../reference/datamodel.rst:386
msgid "Mutable sequences"
msgstr "変更可能なシーケンス型 (mutable sequence)"

#: ../../reference/datamodel.rst:362
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and :keyword:"
"`del` (delete) statements."
msgstr ""
"変更可能なシーケンスは、作成した後で変更することができます。変更可能なシーケ"
"ンスでは、添字表記やスライス表記を使って指定された要素に代入を行うことがで"
"き、 :keyword:`del` (delete) 文を使って要素を削除することができます。"

#: ../../reference/datamodel.rst:366
msgid "There are currently two intrinsic mutable sequence types:"
msgstr ""
"Python に最初から組み込まれている変更可能なシーケンス型は、今のところ二つで"
"す:"

#: ../../reference/datamodel.rst:373
msgid "Lists"
msgstr "リスト型 (list)"

#: ../../reference/datamodel.rst:371
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that "
"there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"リストの要素は任意の Python オブジェクトにできます。リストは、角括弧の中にカ"
"ンマで区切られた式を並べて作ります。 (長さが 0 や 1 のシーケンスを作るために"
"特殊な場合分けは必要ないことに注意してください。)"

#: ../../reference/datamodel.rst:381
msgid "Byte Arrays"
msgstr "バイト配列"

#: ../../reference/datamodel.rst:378
msgid ""
"A bytearray object is a mutable array. They are created by the built-in :"
"func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable bytes objects."
msgstr ""
"bytearray オブジェクトは変更可能な配列です。組み込みの :func:`bytearray` コン"
"ストラクタによって作成されます。変更可能なことを除けば (つまりハッシュ化でき"
"ない)、 byte array は変更不能な bytes オブジェクトと同じインターフェースと機"
"能を提供します。"

#: ../../reference/datamodel.rst:385
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type."
msgstr ""
"拡張モジュール :mod:`array` では、別の変更可能なシーケンス型を提供していま"
"す。"

#: ../../reference/datamodel.rst:420
msgid "Set types"
msgstr "集合型"

#: ../../reference/datamodel.rst:393
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated "
"over, and the built-in function :func:`len` returns the number of items in a "
"set. Common uses for sets are fast membership testing, removing duplicates "
"from a sequence, and computing mathematical operations such as intersection, "
"union, difference, and symmetric difference."
msgstr ""
"集合型は、順序のない、ユニークで不変なオブジェクトの有限集合を表現します。そ"
"のため、(配列の)添字を使ったインデックスアクセスはできません。ただし、イテ"
"レートは可能で、組み込み関数 :func:`len` は集合の要素数を返します。集合型の一"
"般的な使い方は、集合に属しているかの高速なテスト、シーケンスからの重複の排"
"除、共通集合・和集合・差・対称差といった数学的な演算の計算です。"

#: ../../reference/datamodel.rst:400
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""
"集合の要素には、辞書のキーと同じ普遍性に関するルールが適用されます。数値型は"
"通常の数値比較のルールに従うことに注意してください。もし2つの数値の比較結果が"
"同値である(例えば、 ``1`` と ``1.0``)なら、そのうちの1つのみを集合に含めるこ"
"とができます。"

#: ../../reference/datamodel.rst:405
msgid "There are currently two intrinsic set types:"
msgstr "現在、2つの組み込み集合型があります:"

#: ../../reference/datamodel.rst:412
msgid "Sets"
msgstr "集合型"

#: ../../reference/datamodel.rst:410
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as :meth:"
"`~set.add`."
msgstr ""
"可変な集合型です。組み込みの :func:`set` コンストラクタで作成され、後から :"
"meth:`~set.add` などのいくつかのメソッドで更新できます。"

#: ../../reference/datamodel.rst:420
msgid "Frozen sets"
msgstr "Frozen set 型"

#: ../../reference/datamodel.rst:417
msgid ""
"These represent an immutable set.  They are created by the built-in :func:"
"`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, "
"it can be used again as an element of another set, or as a dictionary key."
msgstr ""
"不変な集合型です。組み込みの :func:`frozenset` コンストラクタによって作成され"
"ます。 frozenset は不変でハッシュ可能(:term:`hashable`)なので、別の集合型の要"
"素になったり、辞書のキーにすることができます。"

#: ../../reference/datamodel.rst:457
msgid "Mappings"
msgstr "マップ型 (mapping)"

#: ../../reference/datamodel.rst:428
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""
"任意のインデクス集合でインデクス化された、有限のオブジェクトからなる集合を表"
"現します。添字表記 ``a[k]`` は、 ``k`` でインデクス指定された要素を ``a`` か"
"ら選択します; 選択された要素は式の中で使うことができ、代入や :keyword:`del` "
"文の対象にすることができます。組み込み関数 :func:`len` は、マップ内の要素数を"
"返します。"

#: ../../reference/datamodel.rst:434
msgid "There is currently a single intrinsic mapping type:"
msgstr "Python に最初から組み込まれているマップ型は、今のところ一つだけです:"

#: ../../reference/datamodel.rst:457
msgid "Dictionaries"
msgstr "辞書型 (dictionary)"

#: ../../reference/datamodel.rst:439
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""
"ほとんどどんな値でもインデクスとして使えるような、有限個のオブジェクトからな"
"る集合を表します。キー値 (key) として使えない値は、リストや辞書を含む値や、ア"
"イデンティティではなく値でオブジェクトが比較される、その他の変更可能な型で"
"す。これは、辞書型を効率的に実装する上で、キーのハッシュ値が一定であることが"
"必要だからです。数値型をキーに使う場合、キー値は通常の数値比較における規則に"
"従います: 二つの値が等しくなる場合 (例えば ``1`` と ``1.0``)、互いに同じ辞書"
"のエントリを表すインデクスとして使うことができます。"

#: ../../reference/datamodel.rst:448
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation (see "
"section :ref:`dict`)."
msgstr ""
"辞書は変更可能な型です; 辞書は ``{...}`` 表記で生成します (:ref:`dict` を参照"
"してください)。"

#: ../../reference/datamodel.rst:456
msgid ""
"The extension modules :mod:`dbm`, :mod:`gdbm`, and :mod:`bsddb` provide "
"additional examples of mapping types."
msgstr ""
"拡張モジュール :mod:`dbm` 、 :mod:`gdbm` 、および :mod:`bsddb` では、別のマッ"
"プ型を提供しています。"

#: ../../reference/datamodel.rst:727
msgid "Callable types"
msgstr "呼び出し可能型 (callable type)"

#: ../../reference/datamodel.rst:466
msgid ""
"These are the types to which the function call operation (see section :ref:"
"`calls`) can be applied:"
msgstr "関数呼び出し操作 (:ref:`calls` 参照) を行うことができる型です:"

#: ../../reference/datamodel.rst:560
msgid "User-defined functions"
msgstr "ユーザ定義関数 (user-defined function)"

#: ../../reference/datamodel.rst:475
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""
"ユーザ定義関数オブジェクトは、関数定義を行うことで生成されます (:ref:"
"`function` 参照)。関数は、仮引数 (formal parameter) リストと同じ数の要素が"
"入った引数リストとともに呼び出されます。"

#: ../../reference/datamodel.rst:480
msgid "Special attributes:"
msgstr "特殊属性:"

#: ../../reference/datamodel.rst:503
msgid "Attribute"
msgstr "属性"

#: ../../reference/datamodel.rst:503
msgid "Meaning"
msgstr "意味"

#: ../../reference/datamodel.rst:505
msgid ":attr:`__doc__` :attr:`func_doc`"
msgstr ":attr:`__doc__` :attr:`func_doc`"

#: ../../reference/datamodel.rst:505
msgid "The function's documentation string, or ``None`` if unavailable."
msgstr ""
"関数のドキュメンテーション文字列です。ドキュメンテーションがない場合は "
"``None`` になります。"

#: ../../reference/datamodel.rst:505 ../../reference/datamodel.rst:509
#: ../../reference/datamodel.rst:513 ../../reference/datamodel.rst:517
#: ../../reference/datamodel.rst:523 ../../reference/datamodel.rst:533
msgid "Writable"
msgstr "書き込み可能"

#: ../../reference/datamodel.rst:509
msgid ":attr:`~definition.\\ __name__` :attr:`func_name`"
msgstr ":attr:`~definition.\\ __name__` :attr:`func_name`"

#: ../../reference/datamodel.rst:509
msgid "The function's name"
msgstr "関数の名前です"

#: ../../reference/datamodel.rst:513
msgid ":attr:`__module__`"
msgstr ":attr:`__module__`"

#: ../../reference/datamodel.rst:513
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""
"関数が定義されているモジュールの名前です。モジュール名がない場合は ``None`` "
"になります。"

#: ../../reference/datamodel.rst:517
msgid ":attr:`__defaults__` :attr:`func_defaults`"
msgstr ":attr:`__defaults__` :attr:`func_defaults`"

#: ../../reference/datamodel.rst:517
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value."
msgstr ""
"デフォルト値を持つ引数に対するデフォルト値が収められたタプルで、デフォルト値"
"を持つ引数がない場合には ``None`` になります"

#: ../../reference/datamodel.rst:523
msgid ":attr:`__code__` :attr:`func_code`"
msgstr ":attr:`__code__` :attr:`func_code`"

#: ../../reference/datamodel.rst:523
msgid "The code object representing the compiled function body."
msgstr "コンパイルされた関数本体を表現するコードオブジェクトです。"

#: ../../reference/datamodel.rst:526
msgid ":attr:`__globals__` :attr:`func_globals`"
msgstr ":attr:`__globals__` :attr:`func_globals`"

#: ../../reference/datamodel.rst:526
msgid ""
"A reference to the dictionary that holds the function's global variables --- "
"the global namespace of the module in which the function was defined."
msgstr ""
"関数のグローバル変数の入った辞書 (への参照) です --- この辞書は、関数が定義さ"
"れているモジュールのグローバルな名前空間を決定します。"

#: ../../reference/datamodel.rst:526 ../../reference/datamodel.rst:537
msgid "Read-only"
msgstr "読み込み専用"

#: ../../reference/datamodel.rst:533
msgid ":attr:`~object.\\ __dict__` :attr:`func_dict`"
msgstr ":attr:`~object.\\ __dict__` :attr:`func_dict`"

#: ../../reference/datamodel.rst:533
msgid "The namespace supporting arbitrary function attributes."
msgstr "任意の関数属性をサポートするための名前空間が収められています。"

#: ../../reference/datamodel.rst:537
msgid ":attr:`__closure__` :attr:`func_closure`"
msgstr ":attr:`__closure__` :attr:`func_closure`"

#: ../../reference/datamodel.rst:537
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's free "
"variables."
msgstr ""
"``None`` または関数の個々の自由変数 (引数以外の変数) に対して値を結び付けてい"
"るセル (cell) 群からなるタプルになります。"

#: ../../reference/datamodel.rst:542
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the assigned "
"value."
msgstr ""
"「書き込み可能」とラベルされている属性のほとんどは、代入された値の型をチェッ"
"クします。"

#: ../../reference/datamodel.rst:544
msgid "``func_name`` is now writable."
msgstr "``func_name`` は書き込み可能になりました."

#: ../../reference/datamodel.rst:547
msgid ""
"The double-underscore attributes ``__closure__``, ``__code__``, "
"``__defaults__``, and ``__globals__`` were introduced as aliases for the "
"corresponding ``func_*`` attributes for forwards compatibility with Python 3."
msgstr ""
"Python 3 との前方互換のために、ダブルアンダースコアの属性 ``__closure__``, "
"``__code__``, ``__defaults__``, ``__globals__`` が対応する ``func_*`` への別"
"名として導入されました。"

#: ../../reference/datamodel.rst:553
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes. *Note that "
"the current implementation only supports function attributes on user-defined "
"functions. Function attributes on built-in functions may be supported in the "
"future.*"
msgstr ""
"関数オブジェクトはまた、任意の属性を設定したり取得したりできます。この機能"
"は、例えば関数にメタデータを付与したい場合などに使えます。関数の get や set "
"には、通常のドット表記を使います。 *現在の実装では、ユーザ定義の関数でのみ属"
"性をサポートしているので注意して下さい。組み込み関数の属性は将来サポートする"
"予定です。*"

#: ../../reference/datamodel.rst:559
msgid ""
"Additional information about a function's definition can be retrieved from "
"its code object; see the description of internal types below."
msgstr ""
"関数定義に関するその他の情報は、関数のコードオブジェクトから得られます; 後述"
"の内部型 (internal type) に関する説明を参照してください。"

#: ../../reference/datamodel.rst:658
msgid "User-defined methods"
msgstr "ユーザ定義メソッド (user-defined method)"

#: ../../reference/datamodel.rst:568
msgid ""
"A user-defined method object combines a class, a class instance (or "
"``None``) and any callable object (normally a user-defined function)."
msgstr ""
"ユーザ定義のメソッドオブジェクトは、クラスやクラスインスタンス (あるいは "
"``None``) を任意の呼び出し可能オブジェクト (通常はユーザ定義関数) と結合し "
"(combine) ます。"

#: ../../reference/datamodel.rst:571
msgid ""
"Special read-only attributes: :attr:`im_self` is the class instance object, :"
"attr:`im_func` is the function object; :attr:`im_class` is the class of :"
"attr:`im_self` for bound methods or the class that asked for the method for "
"unbound methods; :attr:`__doc__` is the method's documentation (same as "
"``im_func.__doc__``); :attr:`~definition.__name__` is the method name (same "
"as ``im_func.__name__``); :attr:`__module__` is the name of the module the "
"method was defined in, or ``None`` if unavailable."
msgstr ""
"読み出し専用の特殊属性: :attr:`im_self` はクラスインスタンスオブジェクト"
"で、 :attr:`im_func` は関数オブジェクトです; :attr:`im_class` は結合メソッド "
"(bound method) において :attr:`im_self` が属しているクラスか、あるいは非結合"
"メソッド (unbound method) において、要求されたメソッドを定義しているクラスで"
"す; :attr:`__doc__` はメソッドのドキュメンテーション文字列 (``im_func."
"__doc__`` と同じ) です; :attr:`~definition.__name__` はメソッドの名前 "
"(``im_func.__name__`` と同じ) です; :attr:`__module__` はメソッドが定義されて"
"いるモジュールの名前になるか、モジュール名がない場合は ``None`` になります。"

#: ../../reference/datamodel.rst:579
msgid ":attr:`im_self` used to refer to the class that defined the method."
msgstr ""
"メソッドを定義しているクラスを参照するために :attr:`im_self` が使われていまし"
"た."

#: ../../reference/datamodel.rst:582
msgid ""
"For Python 3 forward-compatibility, :attr:`im_func` is also available as :"
"attr:`__func__`, and :attr:`im_self` as :attr:`__self__`."
msgstr ""
"Python 3 との前方互換性のために、 :attr:`im_func` の代わりに :attr:"
"`__func__` も、 :attr:`im_self` の代わりに :attr:`__self__` も使うことができ"
"ます。"

#: ../../reference/datamodel.rst:593
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr ""
"メソッドもまた、根底にある関数オブジェクトの任意の関数属性に (値の設定はでき"
"ませんが) アクセスできます。"

#: ../../reference/datamodel.rst:596
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined function object, an unbound user-defined method object, or a class "
"method object. When the attribute is a user-defined method object, a new "
"method object is only created if the class from which it is being retrieved "
"is the same as, or a derived class of, the class stored in the original "
"method object; otherwise, the original method object is used as it is."
msgstr ""
"クラスの属性を (おそらくクラスのインスタンスを介して) 取得する際には、その属"
"性がユーザ定義の関数オブジェクト、非結合 (unbound) のユーザ定義メソッドオブ"
"ジェクト、あるいはクラスメソッドオブジェクトであれば、ユーザ定義メソッドオブ"
"ジェクトが生成されることがあります。属性がユーザ定義メソッドオブジェクトの場"
"合、属性を取得する対象のオブジェクトが属するクラスがもとのメソッドオブジェク"
"トが定義されているクラスと同じクラスであるか、またはそのサブクラスであれば、"
"新たなメソッドオブジェクトだけが生成されます。それ以外の場合には、もとのメ"
"ソッドオブジェクトがそのまま使われます。"

#: ../../reference/datamodel.rst:609
msgid ""
"When a user-defined method object is created by retrieving a user-defined "
"function object from a class, its :attr:`im_self` attribute is ``None`` and "
"the method object is said to be unbound. When one is created by retrieving a "
"user-defined function object from a class via one of its instances, its :"
"attr:`im_self` attribute is the instance, and the method object is said to "
"be bound. In either case, the new method's :attr:`im_class` attribute is the "
"class from which the retrieval takes place, and its :attr:`im_func` "
"attribute is the original function object."
msgstr ""
"クラスからユーザ定義関数オブジェクトを取得する方法でユーザ定義メソッドオブ"
"ジェクトを生成すると、 :attr:`im_self` 属性は ``None`` になり、メソッドオブ"
"ジェクトは非結合 (unbound) であるといいます。クラスのインスタンスからユーザ定"
"義関数オブジェクトを取得する方法でユーザ定義メソッドオブジェクトを生成する"
"と、 :attr:`im_self` 属性はインスタンスになり、メソッドオブジェクトは結合 "
"(bound) であるといいます。どちらの場合も、新たなメソッドの :attr:`im_class` "
"属性は、メソッドの取得が行われたクラスになり、 :attr:`im_func` 属性はもとの関"
"数オブジェクトになります。"

#: ../../reference/datamodel.rst:620
msgid ""
"When a user-defined method object is created by retrieving another method "
"object from a class or instance, the behaviour is the same as for a function "
"object, except that the :attr:`im_func` attribute of the new instance is not "
"the original method object but its :attr:`im_func` attribute."
msgstr ""
"クラスやインスタンスから他のユーザ定義メソッドオブジェクトを取得する方法で"
"ユーザ定義メソッドオブジェクトを生成した場合、その動作は関数オブジェクトの場"
"合と同様ですが、新たなインスタンスの :attr:`im_func` 属性はもとのメソッドオブ"
"ジェクトの属性ではなく、新たなインスタンスの属性になります。"

#: ../../reference/datamodel.rst:630
msgid ""
"When a user-defined method object is created by retrieving a class method "
"object from a class or instance, its :attr:`im_self` attribute is the class "
"itself, and its :attr:`im_func` attribute is the function object underlying "
"the class method."
msgstr ""
"クラスやインスタンスからクラスメソッドオブジェクトを取得する方法でユーザ定義"
"メソッドオブジェクトを生成した場合、 :attr:`im_self` 属性はクラス自体とな"
"り、 :attr:`im_func` 属性はクラスメソッドの根底にある関数オブジェクトになりま"
"す。"

#: ../../reference/datamodel.rst:634
msgid ""
"When an unbound user-defined method object is called, the underlying "
"function (:attr:`im_func`) is called, with the restriction that the first "
"argument must be an instance of the proper class (:attr:`im_class`) or of a "
"derived class thereof."
msgstr ""
"非結合ユーザ定義メソッドオブジェクトの呼び出しの際には、根底にある関数 (:"
"attr:`im_func`) が呼び出されます。このとき、最初の引数は適切なクラス (:attr:"
"`im_class`) またはサブクラスのインスタンスでなければならないという制限が課さ"
"れています。"

#: ../../reference/datamodel.rst:639
msgid ""
"When a bound user-defined method object is called, the underlying function (:"
"attr:`im_func`) is called, inserting the class instance (:attr:`im_self`) in "
"front of the argument list.  For instance, when :class:`C` is a class which "
"contains a definition for a function :meth:`f`, and ``x`` is an instance of :"
"class:`C`, calling ``x.f(1)`` is equivalent to calling ``C.f(x, 1)``."
msgstr ""
"結合ユーザ定義メソッドオブジェクトの呼び出しの際には、根底にある関数 (:attr:"
"`im_func`) が呼び出されます。このとき、クラスインスタンス (:attr:`im_self`) "
"が引数の先頭に挿入されます。例えば、関数 :meth:`f` の定義が入ったクラスを :"
"class:`C` とし、 ``x`` を :class:`C` のインスタンスとすると、 ``x.f(1)`` の呼"
"び出しは ``C.f(x, 1)`` と同じになります。"

#: ../../reference/datamodel.rst:645
msgid ""
"When a user-defined method object is derived from a class method object, the "
"\"class instance\" stored in :attr:`im_self` will actually be the class "
"itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to "
"calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""
"ユーザ定義メソッドオブジェクトがクラスオブジェクトから派生した際、 :attr:"
"`im_self` に記憶されている \"クラスインスタンス\" はクラス自体になります。こ"
"れは、 ``x.f(1)`` や ``C.f(1)`` の呼び出しが根底にある関数を ``f`` としたとき"
"の呼び出し ``f(C,1)`` と等価になるようにするためです。"

#: ../../reference/datamodel.rst:650
msgid ""
"Note that the transformation from function object to (unbound or bound) "
"method object happens each time the attribute is retrieved from the class or "
"instance. In some cases, a fruitful optimization is to assign the attribute "
"to a local variable and call that local variable. Also notice that this "
"transformation only happens for user-defined functions; other callable "
"objects (and all non-callable objects) are retrieved without "
"transformation.  It is also important to note that user-defined functions "
"which are attributes of a class instance are not converted to bound methods; "
"this *only* happens when the function is an attribute of the class."
msgstr ""
"関数オブジェクトから (結合または非結合の) メソッドオブジェクトへの変換は、ク"
"ラスやインスタンスから属性を取り出すたびに行われるので注意してください。場合"
"によっては、属性をローカルな変数に代入しておき、その変数を使って関数呼び出し"
"を行うと効果的な最適化になります。また、上記の変換はユーザ定義関数に対しての"
"み起こるので注意してください; その他の呼び出し可能オブジェクト (および呼び出"
"し可能でない全てのオブジェクト) は、変換を受けずに取り出されます。それから、"
"クラスインスタンスの属性になっているユーザ定義関数は、結合メソッドに変換でき"
"ないと知っておくことも重要です; 結合メソッドへの変換が行われるのは、関数がク"
"ラスの一属性である場合 *だけ* です。"

#: ../../reference/datamodel.rst:674
msgid "Generator functions"
msgstr "ジェネレータ関数 (generator function)"

#: ../../reference/datamodel.rst:665
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section :"
"ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an iterator object which can be used to execute the "
"body of the function:  calling the iterator's :meth:`~iterator.next` method "
"will cause the function to execute until it provides a value using the :"
"keyword:`yield` statement.  When the function executes a :keyword:`return` "
"statement or falls off the end, a :exc:`StopIteration` exception is raised "
"and the iterator will have reached the end of the set of values to be "
"returned."
msgstr ""
":keyword:`yield` 文 (:ref:`yield` の節を参照) を使う関数もしくはメソッドは :"
"dfn:`ジェネレータ関数` と呼ばれます。そのような関数が呼び出されたときは常に、"
"関数の本体を実行するのに使えるイテレータオブジェクトを返します: イテレータ"
"の :meth:`~iterator.next` メソッドを呼び出すと、 :keyword:`yield` 文を使って"
"値が提供されるまで関数を実行します。関数の :keyword:`return` 文を実行するか終"
"端に達したときは、 :exc:`StopIteration` 例外が送出され、イテレータが返すべき"
"値の最後まで到達しています。"

#: ../../reference/datamodel.rst:689
msgid "Built-in functions"
msgstr "組み込み関数 (built-in function)"

#: ../../reference/datamodel.rst:682
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: :attr:`__doc__` "
"is the function's documentation string, or ``None`` if unavailable; :attr:"
"`~definition.__name__` is the function's name; :attr:`__self__` is set to "
"``None`` (but see the next item); :attr:`__module__` is the name of the "
"module the function was defined in or ``None`` if unavailable."
msgstr ""
"組み込み関数オブジェクトはC関数へのラッパーです。\n"
"組み込み関数の例は :func:`len` や :func:`math.sin` (:mod:`math` は標準の組み"
"込みモジュール) です。\n"
"引数の数や型は C 関数で決定されています。\n"
"読み出し専用の特殊属性: :attr:`__doc__` は関数のドキュメンテーション文字列で"
"す。\n"
"ドキュメンテーションがない場合は ``None`` になります;\n"
":attr:`~definition.__name__` は関数の名前です;\n"
":attr:`__self__` は ``None`` に設定されています (組み込みメソッドの節も参照し"
"てください);\n"
":attr:`__module__` は、関数が定義されているモジュールの名前です。\n"
"モジュール名がない場合は ``None`` になります。"

#: ../../reference/datamodel.rst:701
msgid "Built-in methods"
msgstr "組み込みメソッド (built-in method)"

#: ../../reference/datamodel.rst:697
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, assuming "
"*alist* is a list object. In this case, the special read-only attribute :"
"attr:`__self__` is set to the object denoted by *alist*."
msgstr ""
"実際には組み込み関数を別の形で隠蔽したもので、こちらの場合には C 関数に渡され"
"る何らかのオブジェクトを非明示的な外部引数として持っています。組み込みメソッ"
"ドの例は、 *alist* をリストオブジェクトとしたときの ``alist.append()`` です。"
"この場合には、読み出し専用の属性 :attr:`__self__` は *alist* で表されるオブ"
"ジェクトになります。"

#: ../../reference/datamodel.rst:708
msgid "Class Types"
msgstr "クラス型 (class type)"

#: ../../reference/datamodel.rst:704
msgid ""
"Class types, or \"new-style classes,\" are callable.  These objects normally "
"act as factories for new instances of themselves, but variations are "
"possible for class types that override :meth:`__new__`.  The arguments of "
"the call are passed to :meth:`__new__` and, in the typical case, to :meth:"
"`__init__` to initialize the new instance."
msgstr ""
"クラス型、あるいは \"新しいクラス型 (new-style class)\" や呼び出し可能オブ"
"ジェクトです。クラス型オブジェクトは通常、そのクラスの新たなインスタンスを生"
"成する際のファクトリクラスとして振舞いますが、 :meth:`__new__` をオーバライド"
"して、バリエーションを持たせることもできます。呼び出しの際に使われた引数は :"
"meth:`__new__` に渡され、さらに典型的な場合では新たなインスタンスを初期化する"
"ために :meth:`__init__` に渡されます。"

#: ../../reference/datamodel.rst:722
msgid "Classic Classes"
msgstr "旧クラス型 (classic class)"

#: ../../reference/datamodel.rst:718
msgid ""
"Class objects are described below.  When a class object is called, a new "
"class instance (also described below) is created and returned.  This implies "
"a call to the class's :meth:`__init__` method if it has one.  Any arguments "
"are passed on to the :meth:`__init__` method.  If there is no :meth:"
"`__init__` method, the class must be called without arguments."
msgstr ""
"(旧) クラスオブジェクトは後で詳しく説明します。クラスオブジェクトが呼び出され"
"ると、新たにクラスインスタンス (後述) が生成され、返されます。この操作には、"
"クラスの :meth:`__init__` メソッドの呼び出し (定義されている場合) が含まれて"
"います。呼び出しの際に使われた引数は、すべて :meth:`__init__` メソッドに渡さ"
"れます。 :meth:`__init__` メソッドがない場合、クラスは引数なしで呼び出さなけ"
"ればなりません。"

#: ../../reference/datamodel.rst:727 ../../reference/datamodel.rst:879
msgid "Class instances"
msgstr "クラスインスタンス (class instance)"

#: ../../reference/datamodel.rst:725
msgid ""
"Class instances are described below.  Class instances are callable only when "
"the class has a :meth:`__call__` method; ``x(arguments)`` is a shorthand for "
"``x.__call__(arguments)``."
msgstr ""
"クラスインスタンスは後で詳しく説明します。クラスインスタンスはクラスが :meth:"
"`__call__` メソッドを持っている場合にのみ呼び出すことができます; "
"``x(arguments)`` とすると、 ``x.__call__(arguments)`` 呼び出しを短く書けま"
"す。"

#: ../../reference/datamodel.rst:770
msgid "Modules"
msgstr "モジュール (module)"

#: ../../reference/datamodel.rst:734
msgid ""
"Modules are imported by the :keyword:`import` statement (see section :ref:"
"`import`). A module object has a namespace implemented by a dictionary "
"object (this is the dictionary referenced by the func_globals attribute of "
"functions defined in the module).  Attribute references are translated to "
"lookups in this dictionary, e.g., ``m.x`` is equivalent to ``m."
"__dict__[\"x\"]``. A module object does not contain the code object used to "
"initialize the module (since it isn't needed once the initialization is "
"done)."
msgstr ""
"モジュールは :keyword:`import` 文で import します (:ref:`import` 参照)。モ"
"ジュールオブジェクトは、辞書オブジェクト (モジュール内で定義されている関数が "
"func_globals 属性で参照している辞書です) で実装された名前空間を持っています。"
"属性への参照は、この辞書に対する検索 (lookup) に翻訳されます。例えば、 ``m."
"x`` は ``m.__dict__[\"x\"]`` と同じです。モジュールオブジェクトには、モジュー"
"ルを初期化するために使われるコードオブジェクトは入っていません (一度初期化が"
"終わればもう必要ないからです)。"

#: ../../reference/datamodel.rst:743
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"属性の代入を行うと、モジュールの名前空間辞書の内容を更新します。例えば、 ``m."
"x = 1`` は ``m.__dict__[\"x\"] = 1`` と同じです。"

#: ../../reference/datamodel.rst:748
msgid ""
"Special read-only attribute: :attr:`~object.__dict__` is the module's "
"namespace as a dictionary object."
msgstr ""
"読み出し専用の特殊属性: :attr:`~object.__dict__` はモジュールの名前空間で、辞"
"書オブジェクトです。"

#: ../../reference/datamodel.rst:753
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary "
"will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""
"CPython がモジュール辞書を削除する方法により、モジュール辞書が生きた参照を"
"持っていたとしてもその辞書はモジュールがスコープから外れた時に削除されます。"
"これを避けるには、辞書をコピーするか、辞書を直接使っている間モジュールを保持"
"してください。"

#: ../../reference/datamodel.rst:764
msgid ""
"Predefined (writable) attributes: :attr:`__name__` is the module's name; :"
"attr:`__doc__` is the module's documentation string, or ``None`` if "
"unavailable; :attr:`__file__` is the pathname of the file from which the "
"module was loaded, if it was loaded from a file. The :attr:`__file__` "
"attribute is not present for C modules that are statically linked into the "
"interpreter; for extension modules loaded dynamically from a shared library, "
"it is the pathname of the shared library file."
msgstr ""
"定義済みの (書き込み可能な) 属性: :attr:`__name__` はモジュールの名前です; :"
"attr:`__doc__` は関数のドキュメンテーション文字列です。ドキュメンテーションが"
"ない場合は ``None`` になります; モジュールがファイルからロードされた場合、 :"
"attr:`__file__` はロードされたモジュールファイルのパス名です。インタプリタに"
"静的にリンクされている C モジュールの場合、 :attr:`__file__` 属性はありませ"
"ん; 共有ライブラリから動的にロードされた拡張モジュールの場合、この属性は共有"
"ライブラリファイルのパス名になります。"

#: ../../reference/datamodel.rst:833
msgid "Classes"
msgstr "クラス"

#: ../../reference/datamodel.rst:773
msgid ""
"Both class types (new-style classes) and class objects (old-style/classic "
"classes) are typically created by class definitions (see section :ref:"
"`class`).  A class has a namespace implemented by a dictionary object. Class "
"attribute references are translated to lookups in this dictionary, e.g., ``C."
"x`` is translated to ``C.__dict__[\"x\"]`` (although for new-style classes "
"in particular there are a number of hooks which allow for other means of "
"locating attributes). When the attribute name is not found there, the "
"attribute search continues in the base classes.  For old-style classes, the "
"search is depth-first, left-to-right in the order of occurrence in the base "
"class list. New-style classes use the more complex C3 method resolution "
"order which behaves correctly even in the presence of 'diamond' inheritance "
"structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by new-style classes "
"can be found in the documentation accompanying the 2.3 release at https://"
"www.python.org/download/releases/2.3/mro/."
msgstr ""
"2 種類のクラス、 type (新スタイルクラス) と class object (旧スタイルクラス) "
"の両方とも、通常はクラス定義 (:ref:`class` 参照) で生成されます。クラスは辞書"
"で実装された名前空間を持っています。クラス属性への参照は、この辞書に対する検"
"索 (lookup) に翻訳されます。例えば、 ``C.x`` は ``C.__dict__[\"x\"]`` と同じ"
"です。(ただし、特に新スタイルクラスにおいて、属性参照の意味を変えられる幾つか"
"のフックがあります)。属性がこの検索で見つからない場合、現在のクラスの基底クラ"
"スへと検索を続けます。旧スタイルクラスの場合、検索は深さ優先 (depth-first)、"
"かつ基底クラスの挙げられているリスト中の左から右 (left-to-right) の順番で行わ"
"れます。新スタイルクラスは、より複雑な、C3メソッド解決順序(MRO=method "
"resolution order) を利用していて、複数の継承パスが共通の祖先にたどり着く「ダ"
"イアモンド継承」があっても正しく動作します。 C3 MRO についてのより詳細な情報"
"は、2.3リリースに付属するドキュメントにあります。 (https://www.python.org/"
"download/releases/2.3/mro/)"

#: ../../reference/datamodel.rst:800
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield a "
"user-defined function object or an unbound user-defined method object whose "
"associated class is either :class:`C` or one of its base classes, it is "
"transformed into an unbound user-defined method object whose :attr:"
"`im_class` attribute is :class:`C`. When it would yield a class method "
"object, it is transformed into a bound user-defined method object whose :"
"attr:`im_self` attribute is :class:`C`.  When it would yield a static method "
"object, it is transformed into the object wrapped by the static method "
"object. See section :ref:`descriptors` for another way in which attributes "
"retrieved from a class may differ from those actually contained in its :attr:"
"`~object.__dict__` (note that only new-style classes support descriptors)."
msgstr ""
"クラス (:class:`C` とします) への属性参照で、要求している属性がユーザ定義関数"
"オブジェクトや、 :class:`C` やその基底クラスに関連付けられている非結合のユー"
"ザ定義メソッドオブジェクトである場合、 :attr:`im_class` 属性が :class:`C` で"
"あるような非結合ユーザ定義メソッドオブジェクトに変換されます。要求している属"
"性がクラスメソッドオブジェクトの場合、その :attr:`im_self` 属性が :class:`C` "
"であるようなユーザ定義メソッドオブジェクトに変換されます。要求している属性が"
"静的メソッドオブジェクトの場合、静的メソッドオブジェクトでラップされたオブ"
"ジェクトに変換されます。クラスから取り出した属性と実際に :attr:`~object."
"__dict__` に入っているものが異なるような他の場合については、 :ref:"
"`descriptors` を参照してください (新スタイルクラスだけがディスクリプタをサ"
"ポートしていることに注意してください)。"

#: ../../reference/datamodel.rst:814
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""
"クラス属性を代入すると、そのクラスの辞書だけが更新され、基底クラスの辞書は更"
"新しません。"

#: ../../reference/datamodel.rst:819
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""
"クラスオブジェクトを呼び出す (上記を参照) と、クラスインスタンスを生成します "
"(下記を参照)。"

#: ../../reference/datamodel.rst:828
msgid ""
"Special attributes: :attr:`~definition.__name__` is the class name; :attr:"
"`__module__` is the module name in which the class was defined; :attr:"
"`~object.__dict__` is the dictionary containing the class's namespace; :attr:"
"`~class.__bases__` is a tuple (possibly empty or a singleton) containing the "
"base classes, in the order of their occurrence in the base class list; :attr:"
"`__doc__` is the class's documentation string, or ``None`` if undefined."
msgstr ""
"特殊属性: :attr:`~definition.__name__` はクラス名です;\n"
":attr:`__module__` はクラスが定義されたモジュール名です;\n"
":attr:`~object.__dict__` はクラスが持つ名前空間が入った辞書です;\n"
":attr:`~class.__bases__` は基底クラスからなるタプル (空もしくは要素が 1 つし"
"かないこともあります) で、基底クラスのリストに表れる順序で並んでいます;\n"
":attr:`__doc__` はクラスのドキュメント文字列で、未定義の場合は None です。"

#: ../../reference/datamodel.rst:842
msgid ""
"A class instance is created by calling a class object (see above). A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object or an unbound user-defined method "
"object whose associated class is the class (call it :class:`C`) of the "
"instance for which the attribute reference was initiated or one of its "
"bases, it is transformed into a bound user-defined method object whose :attr:"
"`im_class` attribute is :class:`C` and whose :attr:`im_self` attribute is "
"the instance. Static method and class method objects are also transformed, "
"as if they had been retrieved from class :class:`C`; see above under "
"\"Classes\". See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`. If no class "
"attribute is found, and the object's class has a :meth:`__getattr__` method, "
"that is called to satisfy the lookup."
msgstr ""
"クラスインスタンスはクラスオブジェクト (上記参照) を呼び出して生成します。ク"
"ラスインスタンスは辞書で実装された名前空間を持っており、属性参照の時にはこの"
"辞書が最初に検索されます。辞書内に属性が見つからず、かつインスタンスのクラス"
"に該当する属性名がある場合、検索はクラス属性にまで広げられます。見つかったク"
"ラス属性がユーザ定義関数オブジェクトや、インスタンスのクラス (:class:`C` とし"
"ます) やその基底クラスに関連付けられている非結合のユーザ定義メソッドオブジェ"
"クトの場合、 :attr:`im_class` 属性が :class:`C` で :attr:`im_self` 属性がイン"
"スタンスになっている結合ユーザ定義メソッドオブジェクトに変換されます。静的メ"
"ソッドやクラスメソッドオブジェクトもまた、 :class:`C` から取り出した場合と同"
"様に変換されます; 上記の \"クラス\" を参照してください。クラスから取り出した"
"属性と実際に :attr:`~object.__dict__` に入っているものが異なるような他の場合"
"については、 :ref:`descriptors` 節を参照してください。クラス属性が見つから"
"ず、かつオブジェクトのクラスが :meth:`__getattr__` メソッドを持っている場合、"
"このメソッドを呼び出して属性名の検索を充足させます。"

#: ../../reference/datamodel.rst:861
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`__setattr__` or :meth:"
"`__delattr__` method, this is called instead of updating the instance "
"dictionary directly."
msgstr ""
"属性の代入や削除を行うと、インスタンスの辞書を更新しますが、クラスの辞書を更"
"新することはありません。クラスで :meth:`__setattr__` や :meth:`__delattr__` "
"メソッドが定義されている場合、直接インスタンスの辞書を更新する代わりにこれら"
"のメソッドが呼び出されます。"

#: ../../reference/datamodel.rst:871
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""
"クラスインスタンスは、ある特定の名前のメソッドを持っている場合、数値型やシー"
"ケンス型、あるいはマップ型のように振舞うことができます。 :ref:`specialnames` "
"を参照してください。"

#: ../../reference/datamodel.rst:878
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary; :"
"attr:`~instance.__class__` is the instance's class."
msgstr ""
"特殊属性: :attr:`~object.__dict__` は属性の辞書です; :attr:`~instance."
"__class__` はインスタンスのクラスです。"

#: ../../reference/datamodel.rst:902
msgid "Files"
msgstr "ファイル (file)"

#: ../../reference/datamodel.rst:895
msgid ""
"A file object represents an open file.  File objects are created by the :"
"func:`open` built-in function, and also by :func:`os.popen`, :func:`os."
"fdopen`, and the :meth:`makefile` method of socket objects (and perhaps by "
"other functions or methods provided by extension modules).  The objects "
"``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized to file "
"objects corresponding to the interpreter's standard input, output and error "
"streams.  See :ref:`bltin-file-objects` for complete documentation of file "
"objects."
msgstr ""
"ファイルオブジェクトは開かれたファイルを表します。ファイルオブジェクトは組み"
"込み関数 :func:`open` や、 :func:`os.popen`, :func:`os.fdopen`, および socke "
"オブジェクトの :meth:`makefile` メソッド (その他の拡張モジュールで提供されて"
"いる関数やメソッド) で生成されます。 ``sys.stdin``, ``sys.stdout`` および "
"``sys.stderr`` といったオブジェクトは、インタプリタの標準入力、標準出力、およ"
"び標準エラー出力ストリームに対応するよう初期化されます。ファイルオブジェクト"
"に関する完全な記述については、 :ref:`bltin-file-objects` を参照してください。"

#: ../../reference/datamodel.rst:1110
msgid "Internal types"
msgstr "内部型 (internal type)"

#: ../../reference/datamodel.rst:909
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""
"インタプリタが内部的に使っているいくつかの型は、ユーザに公開されています。こ"
"れらの定義は将来のインタプリタのバージョンでは変更される可能性がありますが、"
"ここでは記述の完全性のために触れておきます。"

#: ../../reference/datamodel.rst:977
msgid "Code objects"
msgstr "コードオブジェクト"

#: ../../reference/datamodel.rst:916
msgid ""
"Code objects represent *byte-compiled* executable Python code, or :term:"
"`bytecode`. The difference between a code object and a function object is "
"that the function object contains an explicit reference to the function's "
"globals (the module in which it was defined), while a code object contains "
"no context; also the default argument values are stored in the function "
"object, not in the code object (because they represent values calculated at "
"run-time).  Unlike function objects, code objects are immutable and contain "
"no references (directly or indirectly) to mutable objects."
msgstr ""
"コードオブジェクトは *バイトコンパイルされた (byte-compiled)* 実行可能な "
"Python コード、別名バイトコード(:term:`bytecode`) を表現します。コードオブ"
"ジェクトと関数オブジェクトの違いは、関数オブジェクトが関数のグローバル変数 "
"(関数を定義しているモジュールのグローバル) に対して明示的な参照を持っているの"
"に対し、コードオブジェクトにはコンテキストがないということです; また、関数オ"
"ブジェクトではデフォルト引数値を記憶できますが、コードオブジェクトではできま"
"せん (実行時に計算される値を表現するため)。関数オブジェクトと違い、コードオブ"
"ジェクトは変更不可能で、変更可能なオブジェクトへの参照を (直接、間接に関わら"
"ず) 含みません。"

#: ../../reference/datamodel.rst:941
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; :attr:"
"`co_argcount` is the number of positional arguments (including arguments "
"with default values); :attr:`co_nlocals` is the number of local variables "
"used by the function (including arguments); :attr:`co_varnames` is a tuple "
"containing the names of the local variables (starting with the argument "
"names); :attr:`co_cellvars` is a tuple containing the names of local "
"variables that are referenced by nested functions; :attr:`co_freevars` is a "
"tuple containing the names of free variables; :attr:`co_code` is a string "
"representing the sequence of bytecode instructions; :attr:`co_consts` is a "
"tuple containing the literals used by the bytecode; :attr:`co_names` is a "
"tuple containing the names used by the bytecode; :attr:`co_filename` is the "
"filename from which the code was compiled; :attr:`co_firstlineno` is the "
"first line number of the function; :attr:`co_lnotab` is a string encoding "
"the mapping from bytecode offsets to line numbers (for details see the "
"source code of the interpreter); :attr:`co_stacksize` is the required stack "
"size (including local variables); :attr:`co_flags` is an integer encoding a "
"number of flags for the interpreter."
msgstr ""
"読み出し専用の特殊属性: :attr:`co_name` は関数名を表します; :attr:"
"`co_argcount` は固定引数 (positional argument) の数です; :attr:`co_nlocals` "
"は関数が使う (引数を含めた) ローカル変数の数です; :attr:`co_varnames` はロー"
"カル変数名の入ったタプルです (引数名から始まっています); :attr:`co_cellvars` "
"はネストされた関数で参照されているローカル変数の名前が入ったタプルです; :"
"attr:`co_freevars` は自由変数の名前が入ったタプルです。 :attr:`co_code` はバ"
"イトコード列を表現している文字列です; :attr:`co_consts` はバイトコードで使わ"
"れているリテラルの入ったタプルです; :attr:`co_names` はバイトコードで使われて"
"いる名前の入ったタプルです; :attr:`co_filename` はバイトコードのコンパイルが"
"行われたファイル名です; :attr:`co_firstlineno` は関数の最初の行番号です; :"
"attr:`co_lnotab` はバイトコードオフセットから行番号への対応付けをコード化した"
"文字列です (詳細についてはインタプリタのソースコードを参照してください); :"
"attr:`co_stacksize` は関数で (ローカル変数の分も含めて) 必要なスタックサイズ"
"です; :attr:`co_flags` はインタプリタ用の様々なフラグをコード化した整数です。"

#: ../../reference/datamodel.rst:960
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is "
"set if the function uses the ``*arguments`` syntax to accept an arbitrary "
"number of positional arguments; bit ``0x08`` is set if the function uses the "
"``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` is "
"set if the function is a generator."
msgstr ""
"以下のフラグビットが :attr:`co_flags` で定義されています: ``0x04`` ビットは、"
"関数が ``*arguments`` 構文を使って任意の数の固定引数を受理できる場合に立てら"
"れます; ``0x08`` ビットは、関数が ``**keywords`` 構文を使ってキーワード引数を"
"受理できる場合に立てられます; ``0x20`` ビットは、関数がジェネレータである場合"
"に立てられます。"

#: ../../reference/datamodel.rst:966
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`co_flags` to indicate whether a code object was compiled with "
"a particular feature enabled: bit ``0x2000`` is set if the function was "
"compiled with future division enabled; bits ``0x10`` and ``0x1000`` were "
"used in earlier versions of Python."
msgstr ""
"将来機能 (future feature) 宣言 (``from __future__ import division``) もま"
"た、 :attr:`co_flags` のビットを立てることで、コードオブジェクトが特定の機能"
"を有効にしてコンパイルされていることを示します: ``0x2000`` ビットは、関数が将"
"来機能を有効にしてコンパイルされている場合に立てられます; 以前のバージョンの "
"Python では、 ``0x10`` および ``0x1000`` ビットが使われていました。"

#: ../../reference/datamodel.rst:972
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ""
":attr:`co_flags` のその他のビットは将来に内部的に利用するために予約されていま"
"す。"

#: ../../reference/datamodel.rst:976
msgid ""
"If a code object represents a function, the first item in :attr:`co_consts` "
"is the documentation string of the function, or ``None`` if undefined."
msgstr ""
"コードオブジェクトが関数を表現している場合、 :attr:`co_consts` の最初の要素は"
"関数のドキュメンテーション文字列になります。ドキュメンテーション文字列が定義"
"されていない場合には ``None`` になります。"

#: ../../reference/datamodel.rst:1019
msgid "Frame objects"
msgstr "フレーム (frame) オブジェクト"

#: ../../reference/datamodel.rst:984
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below)."
msgstr ""
"フレームオブジェクトは実行フレーム (execution frame) を表します。実行フレーム"
"はトレースバックオブジェクト内に出現します (下記参照)。"

#: ../../reference/datamodel.rst:996
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack frame "
"(towards the caller), or ``None`` if this is the bottom stack frame; :attr:"
"`f_code` is the code object being executed in this frame; :attr:`f_locals` "
"is the dictionary used to look up local variables; :attr:`f_globals` is used "
"for global variables; :attr:`f_builtins` is used for built-in (intrinsic) "
"names; :attr:`f_restricted` is a flag indicating whether the function is "
"executing in restricted execution mode; :attr:`f_lasti` gives the precise "
"instruction (this is an index into the bytecode string of the code object)."
msgstr ""
"読み出し専用の特殊属性: :attr:`f_back` は (呼び出し側にとっての) 以前のスタッ"
"クフレームです。呼び出し側がスタックフレームの最下段である場合には ``None`` "
"です; :attr:`f_code` は現在のフレームで実行しようとしているコードオブジェクト"
"です; :attr:`f_locals` はローカル変数を検索するために使われる辞書です; :attr:"
"`f_globals` はグローバル変数用です; :attr:`f_builtins` は組み込みの (Python "
"固有の) 名前です; :attr:`f_restricted` は、関数が制限つき実行 (restricted "
"execution) モードで実行されているかどうかを示すフラグです; :attr:`f_lasti` は"
"厳密な命令コード (コードオブジェクト中のバイトコード文字列へのインデクス) で"
"す。"

#: ../../reference/datamodel.rst:1012
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a function "
"called at the start of each source code line (this is used by the "
"debugger); :attr:`f_exc_type`, :attr:`f_exc_value`, :attr:`f_exc_traceback` "
"represent the last exception raised in the parent frame provided another "
"exception was ever raised in the current frame (in all other cases they are "
"``None``); :attr:`f_lineno` is the current line number of the frame --- "
"writing to this from within a trace function jumps to the given line (only "
"for the bottom-most frame).  A debugger can implement a Jump command (aka "
"Set Next Statement) by writing to f_lineno."
msgstr ""
"書き込み可能な特殊属性: :attr:`f_trace` が ``None`` でない場合、各ソースコー"
"ド行の先頭で呼び出される関数になります; :attr:`f_exc_type`, :attr:"
"`f_exc_value`, :attr:`f_exc_traceback` は、現在のフレームが以前に引き起こした"
"例外が提供する親フレーム内でもっとも最近捕捉された例外を表します (それ以外の"
"場合は、これらは ``None`` になります); :attr:`f_lineno` はフレーム中における"
"現在の行番号です --- トレース関数 (trace function) 側でこの値に書き込みを行う"
"と、指定した行にジャンプします (最下段の実行フレームにいるときのみ) 。デバッ"
"ガでは、 f_fileno を書き込むことで、ジャンプ命令 (Set Next Statement 命令とも"
"呼ばれます) を実装できます。"

#: ../../reference/datamodel.rst:1061
msgid "Traceback objects"
msgstr "トレースバック (traceback) オブジェクト"

#: ../../reference/datamodel.rst:1034
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is created when an exception occurs.  When the search for an "
"exception handler unwinds the execution stack, at each unwound level a "
"traceback object is inserted in front of the current traceback.  When an "
"exception handler is entered, the stack trace is made available to the "
"program. (See section :ref:`try`.) It is accessible as ``sys."
"exc_traceback``, and also as the third item of the tuple returned by ``sys."
"exc_info()``.  The latter is the preferred interface, since it works "
"correctly when the program is using multiple threads. When the program "
"contains no suitable handler, the stack trace is written (nicely formatted) "
"to the standard error stream; if the interpreter is interactive, it is also "
"made available to the user as ``sys.last_traceback``."
msgstr ""
"トレースバックオブジェクトは例外のスタックトレースを表現します。トレースバッ"
"クオブジェクトは例外が発生した際に生成されます。例外ハンドラを検索して実行ス"
"タックを戻っていく際、戻ったレベル毎に、トレースバックオブジェクトが現在のト"
"レースバックの前に挿入されます。例外ハンドラに入ると、スタックトレースをプロ"
"グラム側で利用できるようになります (:ref:`try` を参照)。トレースバックは "
"``sys.exc_traceback`` として得ることができ、 ``sys.exc_info()`` が返すタプル"
"の三番目の要素としても得られます. インタフェースとしては後者の方が推奨されて"
"いますが、これはプログラムがマルチスレッドを使っている場合に正しく動作するか"
"らです。プログラムに適切なハンドラがない場合、スタックトレースは (うまく書式"
"化されて) 標準エラーストリームに書き出されます; インタプリタが対話的に実行さ"
"れている場合、 ``sys.last_traceback`` として得ることもできます。"

#: ../../reference/datamodel.rst:1054
msgid ""
"Special read-only attributes: :attr:`tb_next` is the next level in the stack "
"trace (towards the frame where the exception occurred), or ``None`` if there "
"is no next level; :attr:`tb_frame` points to the execution frame of the "
"current level; :attr:`tb_lineno` gives the line number where the exception "
"occurred; :attr:`tb_lasti` indicates the precise instruction.  The line "
"number and last instruction in the traceback may differ from the line number "
"of its frame object if the exception occurred in a :keyword:`try` statement "
"with no matching except clause or with a finally clause."
msgstr ""
"読み出し専用の特殊属性: :attr:`tb_next` はスタックトレース内の (例外の発生し"
"ているフレームに向かって) 次のレベルです。次のレベルが存在しない場合には "
"``None`` になります; :attr:`tb_frame` は現在のレベルにおける実行フレームを指"
"します; :attr:`tb_lineno` は例外の発生した行番号です; :attr:`tb_lasti` は厳密"
"な命令コードです。トレースバック内の行番号や最後に実行された命令は、 :"
"keyword:`try` 文内で例外が発生し、かつ対応する :keyword:`except` 節や :"
"keyword:`finally` 節がない場合には、フレームオブジェクト内の行番号とは異なる"
"かもしれません。"

#: ../../reference/datamodel.rst:1092
msgid "Slice objects"
msgstr "スライス (slice) オブジェクト"

#: ../../reference/datamodel.rst:1066
msgid ""
"Slice objects are used to represent slices when *extended slice syntax* is "
"used. This is a slice using two colons, or multiple slices or ellipses "
"separated by commas, e.g., ``a[i:j:step]``, ``a[i:j, k:l]``, or ``a[..., i:"
"j]``.  They are also created by the built-in :func:`slice` function."
msgstr ""
"スライスオブジェクトは *拡張スライス構文 (extended slice syntax)* が使われた"
"際にスライスを表現するために使われます。拡張スライス構文とは、二つのコロン"
"や、コンマで区切られた複数のスライスや省略符号 (ellipse) を使ったスライスで、"
"例えば ``a[i:j:step]`` 、 ``a[i:j, k:l]`` 、あるいは ``a[..., i:j]`` です。ス"
"ライスオブジェクトは組み込み関数 :func:`slice` で生成されます。"

#: ../../reference/datamodel.rst:1076
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; :attr:"
"`~slice.stop` is the upper bound; :attr:`~slice.step` is the step value; "
"each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"読み込み専用の特殊属性: :attr:`~slice.start` は下限です; :attr:`~slice.stop` "
"は上限です; :attr:`~slice.step` はステップの値です; それぞれ省略された場合は "
"``None`` となっています。これらの属性は任意の型を持てます。"

#: ../../reference/datamodel.rst:1080
msgid "Slice objects support one method:"
msgstr "スライスオブジェクトはメソッドを一つサポートします:"

#: ../../reference/datamodel.rst:1085
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the extended slice that the slice object would describe if "
"applied to a sequence of *length* items.  It returns a tuple of three "
"integers; respectively these are the *start* and *stop* indices and the "
"*step* or stride length of the slice. Missing or out-of-bounds indices are "
"handled in a manner consistent with regular slices."
msgstr ""
"このメソッドは単一の整数引数 *length* を取り、 *length* 個の要素からなるシー"
"ケンスに適用した際にスライスオブジェクトから提供することになる、拡張スライス"
"に関する情報を計算します。このメソッドは三つの整数からなるタプルを返します; "
"それぞれ *start* および *stop* のインデクスと、 *step* またはスライス間の幅に"
"対応します。インデクス値がないか、範囲外の値である場合、通常のスライスに対し"
"て一貫性のあるやりかたで扱われます。"

#: ../../reference/datamodel.rst:1102
msgid "Static method objects"
msgstr "静的メソッド (static method) オブジェクト"

#: ../../reference/datamodel.rst:1095
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are not themselves "
"callable, although the objects they wrap usually are. Static method objects "
"are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"静的メソッドは、上で説明したような関数オブジェクトからメソッドオブジェクトへ"
"の変換を阻止するための方法を提供します。静的メソッドオブジェクトは他の何らか"
"のオブジェクト、通常はユーザ定義メソッドオブジェクトを包むラッパです。静的メ"
"ソッドをクラスやクラスインスタンスから取得すると、実際に返されるオブジェクト"
"はラップされたオブジェクトになり、それ以上は変換の対象にはなりません。静的メ"
"ソッドオブジェクトは通常呼び出し可能なオブジェクトをラップしますが、静的オブ"
"ジェクト自体は呼び出すことができません。静的オブジェクトは組み込みコンストラ"
"クタ :func:`staticmethod` で生成されます。"

#: ../../reference/datamodel.rst:1110
msgid "Class method objects"
msgstr "クラスメソッドオブジェクト"

#: ../../reference/datamodel.rst:1105
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such "
"retrieval is described above, under \"User-defined methods\". Class method "
"objects are created by the built-in :func:`classmethod` constructor."
msgstr ""
"クラスメソッドオブジェクトは、静的メソッドオブジェクトに似て、別のオブジェク"
"トを包むラッパであり、そのオブジェクトをクラスやクラスインスタンスから取り出"
"す方法を代替します。このようにして取得したクラスメソッドオブジェクトの動作に"
"ついては、上の \"ユーザ定義メソッド (user-defined method)\" で説明されていま"
"す。クラスメソッドオブジェクトは組み込みのコンストラクタ :func:`classmethod` "
"で生成されます。"

#: ../../reference/datamodel.rst:1115
msgid "New-style and classic classes"
msgstr "新スタイルと旧スタイル"

#: ../../reference/datamodel.rst:1117
msgid ""
"Classes and instances come in two flavors: old-style (or classic) and new-"
"style."
msgstr ""
"クラスとインスタンスは好みに合わせて2種類の方法で記述することができます: 旧ス"
"タイル(もしくはクラシックスタイル)と新スタイルです。"

#: ../../reference/datamodel.rst:1119
msgid ""
"Up to Python 2.1 the concept of ``class`` was unrelated to the concept of "
"``type``, and old-style classes were the only flavor available.  For an old-"
"style class, the statement ``x.__class__`` provides the class of *x*, but "
"``type(x)`` is always ``<type 'instance'>``.  This reflects the fact that "
"all old-style instances, independent of their class, are implemented with a "
"single built-in type, called ``instance``."
msgstr ""
"Python 2.1 までは、 ``class`` の概念は ``type`` の概念とは無関係で、また、旧"
"スタイルクラスが唯一のものでした。旧スタイルクラスでは、 ``x.__class__`` は "
"*x* のクラスを提供はしますが、 ``type(x)`` は常に ``<type 'instance'>`` にな"
"ります。これは、すべての旧スタイルのインスタンスが、それらのクラスとは独立"
"の、 ``instance`` と呼ばれる一つの内蔵型として実行されるということを反映して"
"います。"

#: ../../reference/datamodel.rst:1126
msgid ""
"New-style classes were introduced in Python 2.2 to unify the concepts of "
"``class`` and ``type``.  A new-style class is simply a user-defined type, no "
"more, no less.  If *x* is an instance of a new-style class, then ``type(x)`` "
"is typically the same as ``x.__class__`` (although this is not guaranteed -- "
"a new-style class instance is permitted to override the value returned for "
"``x.__class__``)."
msgstr ""
"新スタイルのクラスは、　``class`` と ``type`` の概念を統一するために Python "
"2.2 で導入されました。新スタイルのクラスはユーザ定義型そのもので、それ以上で"
"も以下でもありません。もし、 *x* が新スタイルクラスのインスタンスであった場"
"合、 ``type(x)`` は ``x.__class__`` と同じになります。 (ただし、これは保証さ"
"れている動作ではありません -- 新スタイルクラスのインスタンスは、 ``x."
"__class__`` で返る値をオーバーライドすることができます。)"

#: ../../reference/datamodel.rst:1133
msgid ""
"The major motivation for introducing new-style classes is to provide a "
"unified object model with a full meta-model.  It also has a number of "
"practical benefits, like the ability to subclass most built-in types, or the "
"introduction of \"descriptors\", which enable computed properties."
msgstr ""
"新スタイルクラスを導入する一番の理由は、メタモデルを用いた統一的なオブジェク"
"トモデルを提供することにあります。また、ほとんどの組み込み型のサブクラスが作"
"成できる、属性を計算するための\"デスクリプタ\"の導入できる等の利点がありま"
"す。"

#: ../../reference/datamodel.rst:1138
msgid ""
"For compatibility reasons, classes are still old-style by default.  New-"
"style classes are created by specifying another new-style class (i.e. a "
"type) as a parent class, or the \"top-level type\" :class:`object` if no "
"other parent is needed.  The behaviour of new-style classes differs from "
"that of old-style classes in a number of important details in addition to "
"what :func:`type` returns.  Some of these changes are fundamental to the new "
"object model, like the way special methods are invoked.  Others are "
"\"fixes\" that could not be implemented before for compatibility concerns, "
"like the method resolution order in case of multiple inheritance."
msgstr ""
"互換性のために、デフォルトではクラスは旧スタイルになります。新スタイルのクラ"
"スは、他の新スタイルクラス (すなわち型)を親クラスとして定義する、もしくは、他"
"の親クラスが必要ない場合に \"最上位型\" :class:`object` を継承することで作成"
"することができます。新スタイルクラスの動作は旧スタイルクラスの動作とは、 :"
"func:`type` が何を返すかといったことをはじめ、何点か重要な部分が異なります。"
"特殊メソッドの呼び出しなど、これらの変更は新オブジェクトモデルの基盤となって"
"います。それ以外の部分は、多重継承時のメソッドの解決順などのように、互換性の"
"問題で以前は実装が不可能であった\"修正\"が新クラスに含まれています。"

#: ../../reference/datamodel.rst:1148
msgid ""
"While this manual aims to provide comprehensive coverage of Python's class "
"mechanics, it may still be lacking in some areas when it comes to its "
"coverage of new-style classes. Please see https://www.python.org/doc/"
"newstyle/ for sources of additional information."
msgstr ""
"このマニュアルは Python のクラスメカニズムに関する総合的な情報を提供しようと"
"していますが、新スタイルクラスについては、まだ足りない部分があるかもしれませ"
"ん。より詳細な情報を得たい場合は、 `<https://www.python.org/doc/newstyle/>`_ "
"を参照してください。"

#: ../../reference/datamodel.rst:1158
msgid ""
"Old-style classes are removed in Python 3, leaving only new-style classes."
msgstr ""
"Python 3 では旧スタイルクラスが削除されて、新スタイルクラスが唯一のクラスにな"
"りました。"

#: ../../reference/datamodel.rst:1164
msgid "Special method names"
msgstr "特殊メソッド名"

#: ../../reference/datamodel.rst:1170
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named :meth:"
"`__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` is "
"roughly equivalent to ``x.__getitem__(i)`` for old-style classes and "
"``type(x).__getitem__(x, i)`` for new-style classes.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or :exc:"
"`TypeError`)."
msgstr ""
"特殊な名前をもったメソッドを定義することで、特殊な構文 (算術演算や添え字表"
"記、スライス表記のような) 特定の演算をクラスで実装することができます。これ"
"は、個々のクラスが Python 言語で提供されている演算子に対応した独自の振る舞い"
"をできるようにするための、演算子のオーバロード (:dfn:`operator overloading`) "
"に対する Python のアプローチです。例えば、あるクラスが :meth:`__getitem__` と"
"いう名前のメソッドを定義しており、 ``x`` がこのクラスのインスタンスであるとす"
"ると、 ``x[i]`` は旧スタイルクラスの場合 ``x.__getitem__(i)`` と、新スタイル"
"クラスの場合 ``type(x).__getitem__(x, i)`` とほぼ等価になります。特に注釈のな"
"い限り、適切なメソッドが定義されていない場合にこのような演算を行おうとすると"
"例外が送出されます。 (発生する例外はたいてい、 :exc:`AttributeError` か :exc:"
"`TypeError` です。)"

#: ../../reference/datamodel.rst:1181
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for "
"the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make "
"sense.  (One example of this is the :class:`~xml.dom.NodeList` interface in "
"the W3C's Document Object Model.)"
msgstr ""
"組み込み型を模倣するクラスを実装するときは、真似されるオブジェクトにとって意"
"味がある範囲に実装をとどめるのが重要です。例えば、あるシーケンスは個々の要素"
"の取得はきちんと動くかもしれませんが、スライスの展開が意味を為さないかもしれ"
"ません。 (W3C のドキュメントオブジェクトモデルにある :class:`~xml.dom."
"NodeList` インターフェースがその一例です。)"

#: ../../reference/datamodel.rst:1192
msgid "Basic customization"
msgstr "基本的なカスタマイズ"

#: ../../reference/datamodel.rst:1198
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static "
"method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""
"クラス *cls* の新しいインスタンスを作るために呼び出されます。 :meth:"
"`__new__` は静的メソッドで (このメソッドは特別扱いされているので、明示的に静"
"的メソッドと宣言する必要はありません)、インスタンスを生成するよう要求されてい"
"るクラスを第一引数にとります。残りの引数はオブジェクトのコンストラクタの式 "
"(クラスの呼び出し文) に渡されます。 :meth:`__new__` の戻り値は新しいオブジェ"
"クトのインスタンス (通常は *cls* のインスタンス) でなければなりません。"

#: ../../reference/datamodel.rst:1205
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super(currentclass, cls)."
"__new__(cls[, ...])`` with appropriate arguments and then modifying the "
"newly-created instance as necessary before returning it."
msgstr ""
"典型的な実装では、クラスの新たなインスタンスを生成するときには "
"``super(currentclass, cls).__new__(cls[, ...])`` に適切な引数を指定してスーパ"
"クラスの :meth:`__new__` メソッドを呼び出し、新たに生成されたインスタンスに必"
"要な変更を加えてから返します。"

#: ../../reference/datamodel.rst:1210
msgid ""
"If :meth:`__new__` returns an instance of *cls*, then the new instance's :"
"meth:`__init__` method will be invoked like ``__init__(self[, ...])``, where "
"*self* is the new instance and the remaining arguments are the same as were "
"passed to :meth:`__new__`."
msgstr ""
":meth:`__new__` が *cls* のインスタンスを返した場合、 "
"``__init__(self[, ...])`` のようにしてインスタンスの :meth:`__init__` が呼び"
"出されます。このとき、 *self* は新たに生成されたインスタンスで、残りの引数"
"は :meth:`__new__` に渡された引数と同じになります。"

#: ../../reference/datamodel.rst:1215
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
":meth:`__new__` が *cls* のインスタンスを返さない場合、インスタンスの :meth:"
"`__init__` メソッドは呼び出されません。"

#: ../../reference/datamodel.rst:1218
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` の主な目的は、変更不能な型 (int, str, tuple など) のサブクラ"
"スでインスタンス生成をカスタマイズすることにあります。また、クラス生成をカス"
"タマイズするために、カスタムのメタクラスでよくオーバーライドされます。"

#: ../../reference/datamodel.rst:1227
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the "
"derived class's :meth:`__init__` method, if any, must explicitly call it to "
"ensure proper initialization of the base class part of the instance; for "
"example: ``BaseClass.__init__(self, [args...])``."
msgstr ""
"インスタンスが (:meth:`__new__` によって) 生成された後、それが呼び出し元に返"
"される前に呼び出されます。引数はクラスのコンストラクタ式に渡したものです。基"
"底クラスとその派生クラスがともに :meth:`__init__` メソッドを持つ場合、派生ク"
"ラスの :meth:`__init__` メソッドは基底クラスの :meth:`__init__` メソッドを明"
"示的に呼び出して、インスタンスの基底クラス部分が適切に初期化されること保証し"
"なければなりません。例えば、 ``BaseClass.__init__(self, [args...])`` 。"

#: ../../reference/datamodel.rst:1234
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customise "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""
":meth:`__new__` と :meth:`__init__` は共同してオブジェクトを構成する (:meth:"
"`__new__` が作成し、 :meth:`__init__` がそれをカスタマイズする) ので、 :meth:"
"`__init__` が非 ``None`` 値を返すことがあってはなりません; さもなければ、実行"
"時に :exc:`TypeError` が送出される原因になります。"

#: ../../reference/datamodel.rst:1246
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"destructor.  If a base class has a :meth:`__del__` method, the derived "
"class's :meth:`__del__` method, if any, must explicitly call it to ensure "
"proper deletion of the base class part of the instance.  Note that it is "
"possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  It "
"may then be called at a later time when this new reference is deleted.  It "
"is not guaranteed that :meth:`__del__` methods are called for objects that "
"still exist when the interpreter exits."
msgstr ""
"インスタンスが消滅させられる際に呼び出されます。このメソッドはデストラクタ "
"(destructor)  とも呼ばれます。基底クラスとその派生クラスがともに :meth:"
"`__del__` メソッドを持つ場合、派生クラスの :meth:`__del__` メソッドは基底クラ"
"スの :meth:`__del__` メソッドを明示的に呼び出して、インスタンスの基底クラス部"
"分が適切に消滅処理されること保証しなければなりません。 :meth:`__del__` メソッ"
"ドでインスタンスに対する新たな参照を作ることで、インスタンスの消滅を遅らせる"
"ことができます (とはいえ、推奨しません！)。このようにすると、新たに作成された"
"参照がその後削除された際にもう一度 :meth:`__del__` メソッドが呼び出されます。"
"インタプリタが終了する際に残っているオブジェクトに対して、 :meth:`__del__` メ"
"ソッドが呼び出される保証はありません。"

#: ../../reference/datamodel.rst:1258
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero.  Some common situations that may "
"prevent the reference count of an object from going to zero include: "
"circular references between objects (e.g., a doubly-linked list or a tree "
"data structure with parent and child pointers); a reference to the object on "
"the stack frame of a function that caught an exception (the traceback stored "
"in ``sys.exc_traceback`` keeps the stack frame alive); or a reference to the "
"object on the stack frame that raised an unhandled exception in interactive "
"mode (the traceback stored in ``sys.last_traceback`` keeps the stack frame "
"alive).  The first situation can only be remedied by explicitly breaking the "
"cycles; the latter two situations can be resolved by storing ``None`` in "
"``sys.exc_traceback`` or ``sys.last_traceback``.  Circular references which "
"are garbage are detected when the option cycle detector is enabled (it's on "
"by default), but can only be cleaned up if there are no Python-level :meth:"
"`__del__` methods involved. Refer to the documentation for the :mod:`gc` "
"module for more information about how :meth:`__del__` methods are handled by "
"the cycle detector, particularly the description of the ``garbage`` value."
msgstr ""
"``del x`` は直接 ``x.__del__()`` を呼び出しません --- 前者は ``x`` への参照カ"
"ウント (reference count) を 1 つ減らし、後者は ``x`` への参照カウントがゼロに"
"なった際にのみ呼び出されます。オブジェクトへの参照カウントがゼロになるのを妨"
"げる可能性のあるよくある状況には、以下のようなものがあります: 複数のオブジェ"
"クト間における循環参照 (二重リンクリストや、親と子へのポインタを持つツリー"
"データ構造); 例外を捕捉した関数におけるスタックフレーム上にあるオブジェクトへ"
"の参照 (``sys.exc_traceback`` に記憶されているトレースバックが、スタックフ"
"レームを生き延びさせます); または、対話モードでハンドルされなかった例外を送出"
"したスタックフレーム上にあるオブジェクトへの参照 (``sys.last_traceback`` に記"
"憶されているトレースバックが、スタックフレームを生き延びさせます); 最初の状況"
"については、明示的に循環参照を壊すしか解決策はありません; 後者の二つの状況"
"は、 ``None`` を ``sys.exc_traceback`` や ``sys.last_traceback`` に入れること"
"で解決できます。ごみオブジェクトと化した循環参照は、オプションの循環参照検出"
"機構 (cycle detector) が有効にされている場合 (これはデフォルトの設定です) に"
"は検出されますが、検出された循環参照を消去するのは Python レベルで :meth:"
"`__del__` メソッドが定義されていない場合だけです。 :meth:`__del__` メソッドが"
"循環参照検出機構でどのように扱われるか、とりわけ ``garbage`` 値の記述に関して"
"は、 :mod:`gc` モジュールのドキュメントを参照してください。"

#: ../../reference/datamodel.rst:1280
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  Also, when :meth:`__del__` is "
"invoked in response to a module being deleted (e.g., when execution of the "
"program is done), other globals referenced by the :meth:`__del__` method may "
"already have been deleted or in the process of being torn down (e.g. the "
"import machinery shutting down).  For this reason, :meth:`__del__` methods "
"should do the absolute minimum needed to maintain external invariants.  "
"Starting with version 1.5, Python guarantees that globals whose name begins "
"with a single underscore are deleted from their module before other globals "
"are deleted; if no other references to such globals exist, this may help in "
"assuring that imported modules are still available at the time when the :"
"meth:`__del__` method is called."
msgstr ""
":meth:`__del__` メソッドの呼び出しが起きるのは不安定な状況下なので、 :meth:"
"`__del__` の実行中に発生した例外は無視され、代わりに ``sys.stderr`` に警告が"
"出力されます。また、 (例えばプログラムの実行終了による) モジュールの削除に"
"伴って :meth:`__del__` が呼び出される際には、 :meth:`__del__` メソッドが参照"
"している他のグローバル変数はすでに削除されていたり、削除中(例えば、import機構"
"のシャットダウン中)かもしれません。この理由から、 :meth:`__del__` メソッドで"
"は外部の不変関係を維持する上で絶対最低限必要なことだけをすべきです。バージョ"
"ン 1.5 からは、単一のアンダースコアで始まるようなグローバル変数は、他のグロー"
"バル変数が削除される前にモジュールから削除されるように Python 側で保証してい"
"ます; これらのアンダースコア付きグローバル変数は、 :meth:`__del__` が呼び出さ"
"れた際に、import されたモジュールがまだ残っているか確認する上で役に立ちます。"

#: ../../reference/datamodel.rst:1295
msgid "See also the :option:`-R` command-line option."
msgstr ":option:`-R` コマンドラインオプションも参照して下さい。"

#: ../../reference/datamodel.rst:1302
msgid ""
"Called by the :func:`repr` built-in function and by string conversions "
"(reverse quotes) to compute the \"official\" string representation of an "
"object.  If at all possible, this should look like a valid Python expression "
"that could be used to recreate an object with the same value (given an "
"appropriate environment).  If this is not possible, a string of the form "
"``<...some useful description...>`` should be returned.  The return value "
"must be a string object. If a class defines :meth:`__repr__` but not :meth:"
"`__str__`, then :meth:`__repr__` is also used when an \"informal\" string "
"representation of instances of that class is required."
msgstr ""
"組み込み関数 :func:`repr` や、文字列への変換 (逆クオート表記: reverse quote) "
"の際に呼び出され、オブジェクトを表す \"公式の (official)\" 文字列を計算しま"
"す。可能な場合には、この値は同じ値を持ったオブジェクトを (適切な環境で) 再生"
"成するために使えるような有効な Python 式に似せるべきです。それが不可能なら、 "
"``<...some useful description...>`` 形式の文字列を返してください。戻り値は文"
"字列オブジェクトでなければなりません。クラスが :meth:`__repr__` を定義してい"
"るが :meth:`__str__` を定義していない場合、そのクラスのインスタンスに対する "
"\"非公式の (informal)\" 文字列表現が必要なときにも :meth:`__repr__` が使われ"
"ます。"

#: ../../reference/datamodel.rst:1318
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr ""
"この関数はデバッグの際によく用いられるので、たくさんの情報を含み、あいまいで"
"ないような表記にすることが重要です。"

#: ../../reference/datamodel.rst:1328
msgid ""
"Called by the :func:`str` built-in function and by the :keyword:`print` "
"statement to compute the \"informal\" string representation of an object.  "
"This differs from :meth:`__repr__` in that it does not have to be a valid "
"Python expression: a more convenient or concise representation may be used "
"instead. The return value must be a string object."
msgstr ""
"組み込み関数 :func:`str` および :keyword:`print` 文によって呼び出され、オブ"
"ジェクトを表す \"非公式の\" 文字列を計算します。このメソッドは、有効な "
"Python 式を返さなくても良いという点で、 :meth:`__repr__` と異なります: その代"
"わり、より便利で分かりやすい表現を返すようにしてください。戻り値は文字列オブ"
"ジェクトでなければなりません。"

#: ../../reference/datamodel.rst:1347
msgid ""
"These are the so-called \"rich comparison\" methods, and are called for "
"comparison operators in preference to :meth:`__cmp__` below. The "
"correspondence between operator symbols and method names is as follows: "
"``x<y`` calls ``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` "
"calls ``x.__eq__(y)``, ``x!=y`` and ``x<>y`` call ``x.__ne__(y)``, ``x>y`` "
"calls ``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr ""
"これらのメソッドは \"拡張比較 (rich comparison)\" メソッドと呼ばれ、下記の :"
"meth:`__cmp__` に優先して呼び出されます。演算子シンボルとメソッド名の対応は以"
"下の通りです: ``x<y`` は ``x.__lt__(y)`` を呼び出します; ``x<=y`` は ``x."
"__le__(y)`` を呼び出します; ``x==y`` は ``x.__eq__(y)`` を呼び出します; ``x!"
"=y`` および ``x<>y`` は ``x.__ne__(y)`` を呼び出します; ``x>y`` は ``x."
"__gt__(y)`` を呼び出します; ``x>=y`` は ``x.__ge__(y)`` を呼び出します。"

#: ../../reference/datamodel.rst:1354
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if it "
"does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison. "
"However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""
"拡張比較メソッドは、与えられた引数のペアに対する操作を実装していないときに、 "
"``NotImplemented`` というシングルトンを返すかもしれません。慣例として、正常に"
"比較が行われたときには ``False`` か ``True`` を返します。しかし、これらのメ"
"ソッドは任意の値を返すことができるので、比較演算子がブール値のコンテキスト(た"
"とえば、 ``if`` 文の条件部分)で使われた場合、 Python はその値に対して :func:"
"`bool` を呼び出して結果の真偽を判断します。"

#: ../../reference/datamodel.rst:1361
msgid ""
"There are no implied relationships among the comparison operators. The truth "
"of ``x==y`` does not imply that ``x!=y`` is false.  Accordingly, when "
"defining :meth:`__eq__`, one should also define :meth:`__ne__` so that the "
"operators will behave as expected.  See the paragraph on :meth:`__hash__` "
"for some important notes on creating :term:`hashable` objects which support "
"custom comparison operations and are usable as dictionary keys."
msgstr ""
"比較演算子間には、暗黙的な論理関係はありません。すなわち、 ``x==y`` が真であ"
"る場合、暗黙のうちに ``x!=y`` が偽になるわけではありません。従って、 :meth:"
"`__eq__` を実装する際、演算子が期待通りに動作するようにするために :meth:"
"`__ne__` も定義する必要があります。カスタムの比較演算をサポートしていて、辞書"
"のキーに使うことができるハッシュ可能(:term:`hashable`) オブジェクトを作るとき"
"の重要な注意点について、 :meth:`__hash__` のドキュメント内に書かれているので"
"参照してください。"

#: ../../reference/datamodel.rst:1368
msgid ""
"There are no swapped-argument versions of these methods (to be used when the "
"left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:"
"`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` "
"and :meth:`__ne__` are their own reflection."
msgstr ""
"これらのメソッドには、(左引数が演算をサポートしないが、右引数はサポートする場"
"合に用いられるような) 鏡像となる (引数を入れ替えた) バージョンは存在しませ"
"ん; むしろ、 :meth:`__lt__` と :meth:`__gt__` は互いに鏡像であり、 :meth:"
"`__le__` と :meth:`__ge__` 、および :meth:`__eq__` と :meth:`__ne__` はそれぞ"
"れ互いに鏡像です。"

#: ../../reference/datamodel.rst:1374
msgid "Arguments to rich comparison methods are never coerced."
msgstr "拡張比較メソッドの引数には型強制 (coerce) が起こりません。"

#: ../../reference/datamodel.rst:1376
msgid ""
"To automatically generate ordering operations from a single root operation, "
"see :func:`functools.total_ordering`."
msgstr ""
"単一の基本演算から順序付けするための演算を自動的に生成したい場合には、 :func:"
"`functools.total_ordering` を参照してください。"

#: ../../reference/datamodel.rst:1385
msgid ""
"Called by comparison operations if rich comparison (see above) is not "
"defined.  Should return a negative integer if ``self < other``, zero if "
"``self == other``, a positive integer if ``self > other``.  If no :meth:"
"`__cmp__`, :meth:`__eq__` or :meth:`__ne__` operation is defined, class "
"instances are compared by object identity (\"address\").  See also the "
"description of :meth:`__hash__` for some important notes on creating :term:"
"`hashable` objects which support custom comparison operations and are usable "
"as dictionary keys. (Note: the restriction that exceptions are not "
"propagated by :meth:`__cmp__` has been removed since Python 1.5.)"
msgstr ""
"拡張比較 (上参照) が定義されていない場合、比較演算によって呼び出されます。 "
"``self < other`` である場合には負の値、 ``self == other`` ならばゼロ、 "
"``self > other`` であれば正の値を返さなければなりません。演算 :meth:"
"`__cmp__` 、 :meth:`__eq__` および :meth:`__ne__` がいずれも定義されていない"
"場合、クラスインスタンスはオブジェクトのアイデンティティ(\"アドレス\") で比較"
"されます。自作の比較演算をサポートするオブジェクトや、辞書のキーとして使える"
"オブジェクトを生成するには、 :meth:`__hash__` に関する記述を参照してくださ"
"い。 (注意: :meth:`__cmp__` が例外を伝播しないという制限は Python 1.5 から除"
"去されました。)"

#: ../../reference/datamodel.rst:1398
msgid "No longer supported."
msgstr "もはやサポートされていません."

#: ../../reference/datamodel.rst:1408
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and :class:"
"`dict`.  :meth:`__hash__` should return an integer.  The only required "
"property is that objects which compare equal have the same hash value; it is "
"advised to mix together the hash values of the components of the object that "
"also play a part in comparison of objects by packing them into a tuple and "
"hashing the tuple. Example::"
msgstr ""
"組み込みの :func:`hash` 関数や、 :class:`set`, :class:`frozenset`, :class:"
"`dict` のようなハッシュを使ったコレクション型の要素に対する操作から呼び出され"
"ます。\n"
":meth:`__hash__` は整数を返さなければなりません。\n"
"このメソッドに必要な性質は、比較結果が等しいオブジェクトは同じハッシュ値を持"
"つということです;\n"
"オブジェクトを比較するときでも利用される要素をタプルに詰めてハッシュ値を計算"
"することで、それぞれの要素のハッシュ値を混合することをおすすめします。"

#: ../../reference/datamodel.rst:1419
msgid ""
"If a class does not define a :meth:`__cmp__` or :meth:`__eq__` method it "
"should not define a :meth:`__hash__` operation either; if it defines :meth:"
"`__cmp__` or :meth:`__eq__` but not :meth:`__hash__`, its instances will not "
"be usable in hashed collections.  If a class defines mutable objects and "
"implements a :meth:`__cmp__` or :meth:`__eq__` method, it should not "
"implement :meth:`__hash__`, since hashable collection implementations "
"require that an object's hash value is immutable (if the object's hash value "
"changes, it will be in the wrong hash bucket)."
msgstr ""
"クラスが :meth:`__cmp__` や :meth:`__eq__` メソッドを定義していない場合、 :"
"meth:`__hash__` メソッドも定義してはなりません; クラスが :meth:`__cmp__` また"
"は :meth:`__eq__` を定義しているが、 :meth:`__hash__` を定義していない場合、"
"インスタンスを辞書のキーとして使うことはできません。クラスが変更可能なオブ"
"ジェクトを定義しており、 :meth:`__cmp__` または :meth:`__eq__` メソッドを実装"
"している場合、 :meth:`__hash__` を定義してはなりません。これは、辞書の実装に"
"おいてハッシュ値が変更不能であることが要求されているからです (オブジェクトの"
"ハッシュ値が変化すると、キーが誤ったハッシュバケツ (hash bucket) に入っている"
"ことになってしまいます)。"

#: ../../reference/datamodel.rst:1428
msgid ""
"User-defined classes have :meth:`__cmp__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) and "
"``x.__hash__()`` returns a result derived from ``id(x)``."
msgstr ""
"ユーザー定義クラスはデフォルトで :meth:`__cmp__` と :meth:`__hash__` メソッド"
"を持っています。これらは、同一以外のすべてのオブジェクトに対して比較結果が偽"
"になり、 ``x.__hash__()`` は ``id(x)`` から得られる結果を返します。"

#: ../../reference/datamodel.rst:1432
msgid ""
"Classes which inherit a :meth:`__hash__` method from a parent class but "
"change the meaning of :meth:`__cmp__` or :meth:`__eq__` such that the hash "
"value returned is no longer appropriate (e.g. by switching to a value-based "
"concept of equality instead of the default identity based equality) can "
"explicitly flag themselves as being unhashable by setting ``__hash__ = "
"None`` in the class definition. Doing so means that not only will instances "
"of the class raise an appropriate :exc:`TypeError` when a program attempts "
"to retrieve their hash value, but they will also be correctly identified as "
"unhashable when checking ``isinstance(obj, collections.Hashable)`` (unlike "
"classes which define their own :meth:`__hash__` to explicitly raise :exc:"
"`TypeError`)."
msgstr ""
"親クラスから :meth:`__hash__` メソッドを継承して、 :meth:`__cmp__` か :meth:"
"`__eq__` の意味を変更している(例えば、デフォルトの同一性ベースの同値関係から"
"値ベースの同値関係に変更する) クラスのハッシュ値は妥当ではなくなるので、 "
"``__hash__ = None`` をクラス定義に書く事で、明示的にハッシュ不可能であること"
"を宣言できます。こうすると、プログラムがそのクラスのインスタンスのハッシュ値"
"を取得しようとしたときに適切な :exc:`TypeError` 例外を送出するようになるだけ"
"でなく、 (:exc:`TypeError` を発生させる :meth:`__hash__` メソッドを持つクラス"
"と違って) ``isinstance(obj, collections.Hashable)`` をチェックしたときに、"
"ハッシュ不可能と判定されるようになります。"

#: ../../reference/datamodel.rst:1444
msgid ""
":meth:`__hash__` may now also return a long integer object; the 32-bit "
"integer is then derived from the hash of that object."
msgstr ""
":meth:`__hash__` は現在では長整数オブジェクトも返せるようになりました。 32"
"ビット整数はこのオブジェクトのハッシュから導出されます。"

#: ../../reference/datamodel.rst:1448
msgid ""
":attr:`__hash__` may now be set to :const:`None` to explicitly flag "
"instances of a class as unhashable."
msgstr ""
"クラスのインスタンスがハッシュ不可能であることを明示的に宣言するために、 :"
"attr:`__hash__` に :const:`None` を設定することができるようになりました。"

#: ../../reference/datamodel.rst:1457
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``, or their integer "
"equivalents ``0`` or ``1``.  When this method is not defined, :meth:"
"`__len__` is called, if it is defined, and the object is considered true if "
"its result is nonzero. If a class defines neither :meth:`__len__` nor :meth:"
"`__nonzero__`, all its instances are considered true."
msgstr ""
"真値テストや組み込み演算 ``bool()`` を実現するために呼び出されます; "
"``False`` または ``True`` か、等価な整数値 ``0`` または ``1`` を返さなければ"
"なりません。このメソッドが定義されていない場合、 :meth:`__len__` が定義されて"
"いれば呼び出され、その結果が nonzero であれば真になります。 :meth:`__len__` "
"と :meth:`__nonzero__` のどちらもクラスで定義されていない場合、そのクラスのイ"
"ンスタンスはすべて真の値を持つものとみなされます。"

#: ../../reference/datamodel.rst:1469
msgid ""
"Called to implement :func:`unicode` built-in; should return a Unicode "
"object. When this method is not defined, string conversion is attempted, and "
"the result of string conversion is converted to Unicode using the system "
"default encoding."
msgstr ""
"組み込み関数 :func:`unicode` を実現するために呼び出されます。Unicode オブジェ"
"クトを返さなければなりません。このメソッドが定義されていなければ、文字列への"
"変換が試みられ、その結果がデフォルトの文字エンコードを用いて Unicode に変換さ"
"れます。"

#: ../../reference/datamodel.rst:1477
msgid "Customizing attribute access"
msgstr "属性値アクセスをカスタマイズする"

#: ../../reference/datamodel.rst:1479
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""
"以下のメソッドを定義して、クラスインスタンスへの属性値アクセス ( 属性値の使"
"用、属性値への代入、 ``x.name`` の削除) の意味をカスタマイズすることができま"
"す。"

#: ../../reference/datamodel.rst:1485
msgid ""
"Called when an attribute lookup has not found the attribute in the usual "
"places (i.e. it is not an instance attribute nor is it found in the class "
"tree for ``self``).  ``name`` is the attribute name. This method should "
"return the (computed) attribute value or raise an :exc:`AttributeError` "
"exception."
msgstr ""
"属性値の検索を行った結果、通常の場所に属性値が見つからなかった場合 (すなわ"
"ち、 ``self`` のインスタンス属性でなく、かつクラスツリーにも見つからなかった"
"場合) に呼び出されます。``name`` は属性名です。このメソッドは (計算された) 属"
"性値を返すか、 :exc:`AttributeError` 例外を送出しなければなりません。"

#: ../../reference/datamodel.rst:1492
msgid ""
"Note that if the attribute is found through the normal mechanism, :meth:"
"`__getattr__` is not called.  (This is an intentional asymmetry between :"
"meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can fake total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control in new-style classes."
msgstr ""
"通常のメカニズムを介して属性値が見つかった場合、 :meth:`__getattr__` は呼び出"
"されないので注意してください。(これは、 :meth:`__getattr__` と :meth:"
"`__setattr__` の間に意図的に導入された非対称性です。) これは、効率性のため"
"と、こうしなければ :meth:`__getattr__` がインスタンスの他の属性値にアクセスす"
"る方法がなくなるためです。少なくともインスタンス変数に対しては、値をインスタ"
"ンスの属性値辞書に挿入しないようにして (代わりに他のオブジェクトに挿入するこ"
"とで) 属性値が完全に制御されているように見せかけられることに注意してくださ"
"い。新スタイルクラスで実際に完全な制御を行う方法は、以下の :meth:"
"`__getattribute__` メソッドを参照してください。"

#: ../../reference/datamodel.rst:1505
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of "
"the normal mechanism (i.e. store the value in the instance dictionary).  "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""
"属性値への代入が試みられた際に呼び出されます。このメソッドは通常の代入メカニ"
"ズム (すなわち、インスタンス辞書への値の代入) の代わりに呼び出されます。 "
"*name* は属性名で、 *value* はその属性に代入する値です。"

#: ../../reference/datamodel.rst:1511
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"not simply execute ``self.name = value`` --- this would cause a recursive "
"call to itself.  Instead, it should insert the value in the dictionary of "
"instance attributes, e.g., ``self.__dict__[name] = value``.  For new-style "
"classes, rather than accessing the instance dictionary, it should call the "
"base class method with the same name, for example, ``object."
"__setattr__(self, name, value)``."
msgstr ""
":meth:`__setattr__` の中でインスタンス属性値への代入が必要な場合、単に "
"``self.name = value`` としてはなりません --- このようにすると、自分自身に対す"
"る再帰呼び出しがおきてしまいます。その代わりに、インスタンス属性の辞書に値を"
"挿入してください。例えば、 ``self.__dict__[name] = value`` とします。新しい形"
"式のクラスでは、インスタンス辞書にアクセスするのではなく、基底クラスのメソッ"
"ドを同じ属性名で呼び出します。例えば、 ``object.__setattr__(self, name, "
"value)`` とします。"

#: ../../reference/datamodel.rst:1522
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""
":meth:`__setattr__` に似ていますが、代入ではなく値の削除を行います。このメ"
"ソッドを実装するのは、オブジェクトにとって ``del obj.name`` が意味がある場合"
"だけにしなければなりません。"

#: ../../reference/datamodel.rst:1529
msgid "More attribute access for new-style classes"
msgstr "新しい形式のクラスのための別の属性アクセス"

#: ../../reference/datamodel.rst:1531
msgid "The following methods only apply to new-style classes."
msgstr ""
"以下のメソッドは新しい形式のクラス (new-style class) のみに適用されます。"

#: ../../reference/datamodel.rst:1536
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be "
"called unless :meth:`__getattribute__` either calls it explicitly or raises "
"an :exc:`AttributeError`. This method should return the (computed) attribute "
"value or raise an :exc:`AttributeError` exception. In order to avoid "
"infinite recursion in this method, its implementation should always call the "
"base class method with the same name to access any attributes it needs, for "
"example, ``object.__getattribute__(self, name)``."
msgstr ""
"クラスのインスタンスに対する属性アクセスを実装するために、無条件に呼び出され"
"ます。クラスが :meth:`__getattr__` も定義している場合、 :meth:`__getattr__` "
"は、 :meth:`__getattribute__` で明示的に呼び出すか、 :exc:`AttributeError` 例"
"外を送出しない限り呼ばれません。このメソッドは (計算された) 属性値を返す"
"か、 :exc:`AttributeError` 例外を送出します。このメソッドが再帰的に際限なく呼"
"び出されてしまうのを防ぐため、実装の際には常に、必要な属性全てへのアクセス"
"で、例えば ``object.__getattribute__(self, name)`` のように基底クラスのメソッ"
"ドを同じ属性名を使って呼び出さなければなりません。"

#: ../../reference/datamodel.rst:1547
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. "
"See :ref:`new-style-special-lookup`."
msgstr ""
"ビルトイン関数や言語構文により暗黙的に特殊メソッドが検索されるときは、このメ"
"ソッドの呼び出しはバイパスされるでしょう。 :ref:`new-style-special-lookup` を"
"参照してください。"

#: ../../reference/datamodel.rst:1555
msgid "Implementing Descriptors"
msgstr "デスクリプタ (descriptor) の実装"

#: ../../reference/datamodel.rst:1557
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the "
"descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property in "
"the owner class' :attr:`~object.__dict__`."
msgstr ""
"以下のメソッドは、このメソッドを持つクラス (いわゆる *デスクリプタ"
"(descriptor)* クラス) のインスタンスが、 *オーナー (owner)* クラスに存在する"
"ときにのみ適用されます (デスクリプタは、オーナーのクラス辞書か、その親のいず"
"れかのクラス辞書になければなりません)。\n"
"以下の例では、\"属性\" とは、名前がオーナークラスの :attr:`~object.__dict__` "
"のプロパティ (porperty) のキーであるような属性を指します。"

#: ../../reference/datamodel.rst:1567
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). *owner* is always "
"the owner class, while *instance* is the instance that the attribute was "
"accessed through, or ``None`` when the attribute is accessed through the "
"*owner*.  This method should return the (computed) attribute value or raise "
"an :exc:`AttributeError` exception."
msgstr ""
"オーナクラスの属性を取得する (クラス属性へのアクセス) 際や、オーナクラスのイ"
"ンスタンスの属性を取得する (インスタンス属性へのアクセス) 場合に呼び出されま"
"す。 *owner* は常にオーナクラスです。一方、 *instance* は属性へのアクセスを仲"
"介するインスタンスか属性が *owner* を介してアクセスされる場合は ``None`` にな"
"ります。このメソッドは (計算された) 属性値を返すか、 :exc:`AttributeError` 例"
"外を送出しなければなりません。"

#: ../../reference/datamodel.rst:1577
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr ""
"オーナクラスのインスタンス *instance* 上の属性を新たな値 *value* に設定する際"
"に呼び出されます。"

#: ../../reference/datamodel.rst:1583
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""
"オーナクラスのインスタンス *instance* 上の属性を削除する際に呼び出されます。"

#: ../../reference/datamodel.rst:1589
msgid "Invoking Descriptors"
msgstr "デスクリプタの呼び出し"

#: ../../reference/datamodel.rst:1591
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`__get__`, :meth:`__set__`, and :meth:`__delete__`. If any "
"of those methods are defined for an object, it is said to be a descriptor."
msgstr ""
"一般にデスクリプタとは、特殊な \"束縛に関する動作 (binding behaviour)\" をも"
"つオブジェクト属性のことです。デスクリプタは、デスクリプタプロトコル "
"(descriptor protocol) のメソッド: :meth:`__get__`, :meth:`__set__`, および :"
"meth:`__delete__` を使って、属性アクセスをオーバライドしているものです。これ"
"らのメソッドのいずれかがオブジェクトに対して定義されている場合、オブジェクト"
"はデスクリプタであるといいます。"

#: ../../reference/datamodel.rst:1596
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"属性アクセスのデフォルトの動作は、オブジェクトの辞書から値を取り出したり、値"
"を設定したり、削除したりするというものです。例えば、 ``a.x`` による属性の検索"
"では、まず ``a.__dict__['x']`` 、次に ``type(a).__dict__['x']`` 、そして "
"``type(a)`` の基底クラスでメタクラスでないものに続く、といった具合に連鎖が起"
"こります。"

#: ../../reference/datamodel.rst:1601
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called.  "
"Note that descriptors are only invoked for new style objects or classes "
"(ones that subclass :class:`object()` or :class:`type()`)."
msgstr ""
"しかしながら、検索対象となる値が、デスクリプタメソッドのいずれかを定義してい"
"るオブジェクトの属性値である場合、Python はデフォルトの動作をオーバライドし"
"て、デスクリプタメソッドの方を呼び出します。前後する呼び出し連鎖の中のどこで"
"デスクリプタメソッドが呼び出されるかは、どのデスクリプタメソッドが定義されて"
"いるかと、どうやってデスクリプタメソッドが呼ばれるかに依存します。デスクリプ"
"タは新しい形式のオブジェクトやクラス (:class:`object()` や :class:`type()` を"
"サブクラス化したもの) だけに対して呼び出されるので注意してください。"

#: ../../reference/datamodel.rst:1608
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""
"デスクリプタ呼び出しの基点となるのは、属性名への束縛 (binding) 、すなわち "
"``a.x`` です。引数がどのようにデスクリプタに結合されるかは ``a`` に依存しま"
"す:"

#: ../../reference/datamodel.rst:1613
msgid "Direct Call"
msgstr "直接呼び出し (Direct Call)"

#: ../../reference/datamodel.rst:1612
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""
"最も単純で、かつめったに使われない呼び出し操作は、コード中で直接デスクリプタ"
"メソッドの呼び出し: ``x.__get__(a)`` を行うというものです。"

#: ../../reference/datamodel.rst:1617
msgid "Instance Binding"
msgstr "インスタンス束縛 (Instance Binding)"

#: ../../reference/datamodel.rst:1616
msgid ""
"If binding to a new-style object instance, ``a.x`` is transformed into the "
"call: ``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"新しい形式のクラスのインスタンスに対する束縛では、 ``a.x`` は呼び出し: "
"``type(a).__dict__['x'].__get__(a, type(a))`` に変換されます。"

#: ../../reference/datamodel.rst:1621
msgid "Class Binding"
msgstr "クラス束縛 (Class Binding)"

#: ../../reference/datamodel.rst:1620
msgid ""
"If binding to a new-style class, ``A.x`` is transformed into the call: ``A."
"__dict__['x'].__get__(None, A)``."
msgstr ""
"新しい形式のクラスに対する束縛では、 ``A.x`` は呼び出し: ``A.__dict__['x']."
"__get__(None, A)`` に変換されます。"

#: ../../reference/datamodel.rst:1627
msgid "Super Binding"
msgstr "super 束縛 (Super Binding)"

#: ../../reference/datamodel.rst:1624
msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, obj)."
"m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately preceding ``B`` and then invokes the descriptor with the call: "
"``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr ""
"``a`` が :class:`super` のインスタンスである場合、束縛 ``super(B, obj).m()`` "
"を行うとまず ``A`` 、続いて ``B`` に対して ``obj.__class_.__mro__`` を検索"
"し、次に呼び出し: ``A.__dict__['m'].__get__(obj, obj.__class__)`` でデスクリ"
"プタを呼び出します。"

#: ../../reference/datamodel.rst:1629
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"the which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  If "
"it does not define :meth:`__get__`, then accessing the attribute will return "
"the descriptor object itself unless there is a value in the object's "
"instance dictionary.  If the descriptor defines :meth:`__set__` and/or :meth:"
"`__delete__`, it is a data descriptor; if it defines neither, it is a non-"
"data descriptor.  Normally, data descriptors define both :meth:`__get__` "
"and :meth:`__set__`, while non-data descriptors have just the :meth:"
"`__get__` method.  Data descriptors with :meth:`__set__` and :meth:`__get__` "
"defined always override a redefinition in an instance dictionary.  In "
"contrast, non-data descriptors can be overridden by instances."
msgstr ""
"インスタンス束縛では、デスクリプタ呼び出しの優先順位はどのデスクリプタが定義"
"されているかに依存します。データデスクリプタは、 :meth:`__get__` と :meth:"
"`__set__` 、 :meth:`__delete__` の任意の組合せを定義することができます。 :"
"meth:`__get__` が定義されない場合には、その属性にアクセスすると、そのオブジェ"
"クトのインスタンス辞書にその値がある場合を除けば、デスクリプタオブジェクト自"
"身が返ってきます。デスクリプタが :meth:`__set__` と :meth:`__delete__` または"
"そのどちらかを定義していれば、データデスクリプタとなります; もし両方とも定義"
"しなければ、非データデスクリプタです。通常、データデスクリプタでは、 :meth:"
"`__get__` と :meth:`__set__` を定義し、一方、非データデスクリプタには :meth:"
"`__get__` メソッドしかありません。 :meth:`__set__` と :meth:`__get__` を定義"
"したデータデスクリプタは、インスタンス辞書内で属性値が再定義されても、常にこ"
"の値をオーバライドします。対照的に、非データデスクリプタの場合には、属性値は"
"インスタンス側でオーバライドされます。"

#: ../../reference/datamodel.rst:1642
msgid ""
"Python methods (including :func:`staticmethod` and :func:`classmethod`) are "
"implemented as non-data descriptors.  Accordingly, instances can redefine "
"and override methods.  This allows individual instances to acquire behaviors "
"that differ from other instances of the same class."
msgstr ""
"(:func:`staticmethod` や :func:`classmethod` を含む) Python メソッドは、非"
"データデスクリプタとして実装されています。その結果、インスタンスではメソッド"
"を再定義したりオーバライドできます。このことにより、個々のインスタンスが同じ"
"クラスの他のインスタンスと互いに異なる動作を獲得することができます。"

#: ../../reference/datamodel.rst:1647
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
":func:`property` 関数はデータデスクリプタとして実装されています。従って、イン"
"スタンスはあるプロパティの動作をオーバライドすることができません。"

#: ../../reference/datamodel.rst:1654
msgid "__slots__"
msgstr "__slots__"

#: ../../reference/datamodel.rst:1656
msgid ""
"By default, instances of both old and new-style classes have a dictionary "
"for attribute storage.  This wastes space for objects having very few "
"instance variables.  The space consumption can become acute when creating "
"large numbers of instances."
msgstr ""
"デフォルトでは、新旧どちらのクラスも、属性の記憶領域として使うための辞書を"
"持っています。この仕様は、ほとんどインスタンス変数を持たないようなオブジェク"
"トの場合には記憶領域の無駄遣いになります。記憶領域の消費量は、大量のインスタ"
"ンスを生成する際には深刻です。"

#: ../../reference/datamodel.rst:1661
msgid ""
"The default can be overridden by defining *__slots__* in a new-style class "
"definition.  The *__slots__* declaration takes a sequence of instance "
"variables and reserves just enough space in each instance to hold a value "
"for each variable.  Space is saved because *__dict__* is not created for "
"each instance."
msgstr ""
"このデフォルトの設定は、新たな形式のクラス定義において *__slots__* を定義する"
"ことでオーバライドできます。 *__slots_* 宣言はインスタンス変数のシーケンスを"
"受け取ります。各々のインスタンス上には、各変数の値を記憶するのにちょうど必要"
"な量だけの記憶領域を確保します。各々のインスタンスに対して *__dict__* が生成"
"されることがないので、記憶領域が節約されます。"

#: ../../reference/datamodel.rst:1669
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  If defined in a new-style "
"class, *__slots__* reserves space for the declared variables and prevents "
"the automatic creation of *__dict__* and *__weakref__* for each instance."
msgstr ""
"このクラス変数には、文字列、反復可能オブジェクト、あるいはインスタンスが用い"
"る変数名を表す文字列からなるシーケンスを代入することができます。この変数が新"
"しい形式のクラスで定義されている場合、 *__slots__* は、各インスタンスに対して"
"宣言された変数に必要な記憶領域を確保し、 *__dict__* と *__weakref__* が自動的"
"に生成されないようにします。"

#: ../../reference/datamodel.rst:1676
msgid "Notes on using *__slots__*"
msgstr "*__slots__* を利用する際の注意"

#: ../../reference/datamodel.rst:1678
msgid ""
"When inheriting from a class without *__slots__*, the *__dict__* attribute "
"of that class will always be accessible, so a *__slots__* definition in the "
"subclass is meaningless."
msgstr ""
"*__slots__* を持たないクラスから継承する場合、 *__dict__* 属性は常にアクセス"
"可能なので、サブクラスで *__slots__* を定義しても意味がありません。"

#: ../../reference/datamodel.rst:1682
msgid ""
"Without a *__dict__* variable, instances cannot be assigned new variables "
"not listed in the *__slots__* definition.  Attempts to assign to an unlisted "
"variable name raises :exc:`AttributeError`. If dynamic assignment of new "
"variables is desired, then add ``'__dict__'`` to the sequence of strings in "
"the *__slots__* declaration."
msgstr ""
"*__dict__* 変数がない場合、 *__slots__* に列挙されていない新たな変数をインス"
"タンスに代入することはできません。列挙されていない変数名を使って代入しようと"
"した場合、 :exc:`AttributeError` が送出されます。新たな変数を動的に代入したい"
"のなら、 *__slots__* を宣言する際に ``'__dict__'`` を変数名のシーケンスに追加"
"してください。"

#: ../../reference/datamodel.rst:1688
msgid ""
"Previously, adding ``'__dict__'`` to the *__slots__* declaration would not "
"enable the assignment of new attributes not specifically listed in the "
"sequence of instance variable names."
msgstr ""
"これまでは、 ``'__dict__'`` を *__slots__* 宣言に追加しても、インスタンス変数"
"名として他にリストされていない新たな属性の代入はできませんでした。"

#: ../../reference/datamodel.rst:1693
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support weak references to its instances. If weak "
"reference support is needed, then add ``'__weakref__'`` to the sequence of "
"strings in the *__slots__* declaration."
msgstr ""
"*__slots__* を定義しているクラスの各インスタンスに *__weakref__* 変数がない場"
"合、インスタンスに対する弱参照 (weak reference) はサポートされません。弱参照"
"のサポートが必要なら、 *__slots__* を宣言する際に ``'__weakref__'`` を変数名"
"のシーケンスに追加してください。"

#: ../../reference/datamodel.rst:1698
msgid ""
"Previously, adding ``'__weakref__'`` to the *__slots__* declaration would "
"not enable support for weak references."
msgstr ""
"これまでは、 ``'__weakref__'`` を *__slots__* 宣言に追加しても、弱参照のサ"
"ポートを有効にできませんでした。"

#: ../../reference/datamodel.rst:1702
msgid ""
"*__slots__* are implemented at the class level by creating descriptors (:ref:"
"`descriptors`) for each variable name.  As a result, class attributes cannot "
"be used to set default values for instance variables defined by *__slots__*; "
"otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""
"*__slots__* は、クラスのレベルで各変数に対するデスクリプタ (:ref:"
"`descriptors` を参照) を使って実装されます。その結果、 *__slots__* に定義され"
"ているインスタンス変数のデフォルト値はクラス属性を使って設定できなくなってい"
"ます; そうしないと、デスクリプタによる代入をクラス属性が上書きしてしまうから"
"です。"

#: ../../reference/datamodel.rst:1708
msgid ""
"The action of a *__slots__* declaration is limited to the class where it is "
"defined.  As a result, subclasses will have a *__dict__* unless they also "
"define *__slots__* (which must only contain names of any *additional* slots)."
msgstr ""
"*__slots__* 宣言が動作するのは、定義が行われたクラスだけに限られています。そ"
"の結果、サブクラスでは、 *__slots__* を定義しない限り *__dict__* を持つことに"
"なります。"

#: ../../reference/datamodel.rst:1712
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""
"あるクラスで、基底クラスですでに定義されているスロットを定義した場合、基底ク"
"ラスのスロットで定義されているインスタンス変数は (デスクリプタを基底クラスか"
"ら直接取得しない限り) アクセスできなくなります。これにより、プログラムの趣意"
"が不定になってしまいます。将来は、この問題を避けるために何らかのチェックが追"
"加されるかもしれません。"

#: ../../reference/datamodel.rst:1717
msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-"
"length\" built-in types such as :class:`long`, :class:`str` and :class:"
"`tuple`."
msgstr ""
"空でない *__slots__* は、 :class:`long` 、 :class:`str` 、および :class:"
"`tuple` といった、\"可変長 (variable-length)\" の組み込み型から派生したクラス"
"では動作しません。"

#: ../../reference/datamodel.rst:1720
msgid ""
"Any non-string iterable may be assigned to *__slots__*. Mappings may also be "
"used; however, in the future, special meaning may be assigned to the values "
"corresponding to each key."
msgstr ""
"*__slots__* には、文字列でない反復可能オブジェクトを代入することができます。"
"辞書型も使うことができます; しかし将来、辞書の各キーに相当する値に何らかの特"
"殊な意味が割り当てられるかもしれません。"

#: ../../reference/datamodel.rst:1724
msgid ""
"*__class__* assignment works only if both classes have the same *__slots__*."
msgstr ""
"*__class__* への代入は、両方のクラスが同じ *__slots__* を持っているときのみ動"
"作します。"

#: ../../reference/datamodel.rst:1726
msgid ""
"Previously, *__class__* assignment raised an error if either new or old "
"class had *__slots__*."
msgstr ""
"以前は、新旧どちらかのクラスが *__slots__* を持っていたら *__class__* への代"
"入はエラーを発生していました。"

#: ../../reference/datamodel.rst:1734
msgid "Customizing class creation"
msgstr "クラス生成をカスタマイズする"

#: ../../reference/datamodel.rst:1736
msgid ""
"By default, new-style classes are constructed using :func:`type`. A class "
"definition is read into a separate namespace and the value of class name is "
"bound to the result of ``type(name, bases, dict)``."
msgstr ""
"デフォルトでは、新スタイルクラスは :func:`type` を使って構築されます。クラス"
"定義が別の名前空間に読み込まれ、クラス名は ``type(name, bases, dict)`` の結果"
"に結合されます。"

#: ../../reference/datamodel.rst:1740
msgid ""
"When the class definition is read, if *__metaclass__* is defined then the "
"callable assigned to it will be called instead of :func:`type`. This allows "
"classes or functions to be written which monitor or alter the class creation "
"process:"
msgstr ""
"クラス定義が読み込まれる際、 *__metaclass__* が定義されていれば、 :func:"
"`type` の代わりに *__metaclass__* が指している呼び出し可能オブジェクトが呼び"
"出されます。これによって、"

#: ../../reference/datamodel.rst:1745
msgid "Modifying the class dictionary prior to the class being created."
msgstr "クラスが生成される前にクラス辞書を変更する"

#: ../../reference/datamodel.rst:1747
msgid ""
"Returning an instance of another class -- essentially performing the role of "
"a factory function."
msgstr ""
"他のクラスのインスタンスを返す -- 本質的にはファクトリ関数の役割を果たす"

#: ../../reference/datamodel.rst:1750
msgid ""
"These steps will have to be performed in the metaclass's :meth:`__new__` "
"method -- :meth:`type.__new__` can then be called from this method to create "
"a class with different properties.  This example adds a new element to the "
"class dictionary before creating the class::"
msgstr ""
"これらのステップは、メタクラスの :meth:`__new__` メソッドで実行されなければな"
"りません。 -- このメソッドから他の属性を持ったクラスを作るには、 :meth:`type."
"__new__` を呼び出すことができます。次の例ではクラスを生成する前に新しい要素を"
"クラス辞書に追加しています。 ::"

#: ../../reference/datamodel.rst:1760
msgid ""
"You can of course also override other class methods (or add new methods); "
"for example defining a custom :meth:`__call__` method in the metaclass "
"allows custom behavior when the class is called, e.g. not always creating a "
"new instance."
msgstr ""
"もちろん、他のクラスメソッドをオーバーライドする(または新しいメソッドを追加す"
"る)こともできます。例えば、カスタムの :meth:`__call__` メソッドをメタクラスに"
"定義して、新しいインスタンスを常には造らないといったカスタムの動作を実装でき"
"ます。"

#: ../../reference/datamodel.rst:1767
msgid ""
"This variable can be any callable accepting arguments for ``name``, "
"``bases``, and ``dict``.  Upon class creation, the callable is used instead "
"of the built-in :func:`type`."
msgstr ""
"この変数は ``name`` 、 ``bases`` 、および ``dict`` を引数として取るような任意"
"の呼び出し可能オブジェクトにできます。クラス生成の際、組み込みの :func:"
"`type` の代わりに、指定された呼び出しオブジェクトが呼び出されます。"

#: ../../reference/datamodel.rst:1773
msgid ""
"The appropriate metaclass is determined by the following precedence rules:"
msgstr "以下に優先順で並んだ規則によって、適切なメタクラスが決定されます:"

#: ../../reference/datamodel.rst:1775
msgid "If ``dict['__metaclass__']`` exists, it is used."
msgstr "``dict['__metaclass__']`` があればそれを使います。"

#: ../../reference/datamodel.rst:1777
msgid ""
"Otherwise, if there is at least one base class, its metaclass is used (this "
"looks for a *__class__* attribute first and if not found, uses its type)."
msgstr ""
"それ以外の場合で、最低でも一つ基底クラスを持っているなら、基底クラスのメタク"
"ラス (*__class__* 属性を探し、なければ基底クラスの型) を使います。"

#: ../../reference/datamodel.rst:1780
msgid "Otherwise, if a global variable named __metaclass__ exists, it is used."
msgstr ""
"それ以外の場合で、__metaclass__ という名前のグローバル変数があれば、それをつ"
"かいます。"

#: ../../reference/datamodel.rst:1782
msgid "Otherwise, the old-style, classic metaclass (types.ClassType) is used."
msgstr ""
"それ以外の場合には、旧スタイルのメタクラス (types.ClassType) を使います。"

#: ../../reference/datamodel.rst:1784
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored including logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""
"メタクラスは限りない潜在的利用価値を持っています。これまで試されてきたアイデ"
"アには、ログ記録、インタフェースのチェック、自動デリゲーション、自動プロパ"
"ティ生成、プロキシ、フレームワーク、そして自動リソースロック／同期といったも"
"のがあります。"

#: ../../reference/datamodel.rst:1791
msgid "Customizing instance and subclass checks"
msgstr "インスタンスのカスタマイズとサブクラスチェック"

#: ../../reference/datamodel.rst:1795
msgid ""
"The following methods are used to override the default behavior of the :func:"
"`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"以下のメソッドは組み込み関数 :func:`isinstance` と :func:`issubclass` のデ"
"フォルトの動作を上書きするのに利用します。"

#: ../../reference/datamodel.rst:1798
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""
"特に、 :class:`abc.ABCMeta` メタクラスは、抽象基底クラス (ABCs) を\"仮想基底"
"クラス (virtual base classes)\" として、他の ABC を含む、任意のクラスや (組み"
"込み型を含む) 型に追加するために、これらのメソッドを実装しています。"

#: ../../reference/datamodel.rst:1805
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""
"*instance* が (直接、または間接的に) *class* のインスタンスと考えられる場合"
"に true を返します。定義されていれば、 ``isinstance(instance, class)`` の実装"
"のために呼び出されます。"

#: ../../reference/datamodel.rst:1812
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass, "
"class)``."
msgstr ""
"*subclass* が (直接、または間接的に) *class* のサブクラスと考えられる場合に "
"true を返します。定義されていれば、 ``issubclass(subclass, class)`` の実装の"
"ために呼び出されます。"

#: ../../reference/datamodel.rst:1817
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""
"なお、これらのメソッドは、クラスの型 (メタクラス) 上で検索されます。実際のク"
"ラスにクラスメソッドとして定義することはできません。これは、インスタンスそれ"
"自体がクラスであるこの場合にのみ、インスタンスに呼び出される特殊メソッドの検"
"索と一貫しています。"

#: ../../reference/datamodel.rst:1828
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - 抽象基底クラスの導入"

#: ../../reference/datamodel.rst:1825
msgid ""
"Includes the specification for customizing :func:`isinstance` and :func:"
"`issubclass` behavior through :meth:`~class.__instancecheck__` and :meth:"
"`~class.__subclasscheck__`, with motivation for this functionality in the "
"context of adding Abstract Base Classes (see the :mod:`abc` module) to the "
"language."
msgstr ""
"抽象基底クラス (:mod:`abc` モジュールを参照) を言語に追加する文脈においての動"
"機から、 :meth:`~class.__instancecheck__` と :meth:`~class."
"__subclasscheck__` を通して、 :func:`isinstance` と :func:`issubclass` に独自"
"の動作をさせるための仕様の記述があります。"

#: ../../reference/datamodel.rst:1835
msgid "Emulating callable objects"
msgstr "呼び出し可能オブジェクトをエミュレートする"

#: ../../reference/datamodel.rst:1842
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, "
"arg2, ...)``."
msgstr ""
"インスタンスが関数として \"呼ばれた\" 際に呼び出されます; このメソッドが定義"
"されている場合、 ``x(arg1, arg2, ...)`` は ``x.__call__(arg1, arg2, ...)`` を"
"短く書いたものになります。"

#: ../../reference/datamodel.rst:1849
msgid "Emulating container types"
msgstr "コンテナをエミュレートする"

#: ../../reference/datamodel.rst:1851
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are sequences (such as lists or tuples) or mappings (like "
"dictionaries), but can represent other containers as well.  The first set of "
"methods is used either to emulate a sequence or to emulate a mapping; the "
"difference is that for a sequence, the allowable keys should be the integers "
"*k* for which ``0 <= k < N`` where *N* is the length of the sequence, or "
"slice objects, which define a range of items. (For backwards compatibility, "
"the method :meth:`__getslice__` (see below) can also be defined to handle "
"simple, but not extended slices.) It is also recommended that mappings "
"provide the methods :meth:`keys`, :meth:`values`, :meth:`items`, :meth:"
"`has_key`, :meth:`get`, :meth:`clear`, :meth:`setdefault`, :meth:"
"`iterkeys`, :meth:`itervalues`, :meth:`iteritems`, :meth:`pop`, :meth:"
"`popitem`, :meth:`!copy`, and :meth:`update` behaving similar to those for "
"Python's standard dictionary objects.  The :mod:`UserDict` module provides "
"a :class:`DictMixin` class to help create those methods from a base set of :"
"meth:`__getitem__`, :meth:`__setitem__`, :meth:`__delitem__`, and :meth:"
"`keys`. Mutable sequences should provide methods :meth:`append`, :meth:"
"`count`, :meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, :meth:"
"`remove`, :meth:`reverse` and :meth:`sort`, like Python standard list "
"objects.  Finally, sequence types should implement addition (meaning "
"concatenation) and multiplication (meaning repetition) by defining the "
"methods :meth:`__add__`, :meth:`__radd__`, :meth:`__iadd__`, :meth:"
"`__mul__`, :meth:`__rmul__` and :meth:`__imul__` described below; they "
"should not define :meth:`__coerce__` or other numerical operators.  It is "
"recommended that both mappings and sequences implement the :meth:"
"`__contains__` method to allow efficient use of the ``in`` operator; for "
"mappings, ``in`` should be equivalent of :meth:`has_key`; for sequences, it "
"should search through the values.  It is further recommended that both "
"mappings and sequences implement the :meth:`__iter__` method to allow "
"efficient iteration through the container; for mappings, :meth:`__iter__` "
"should be the same as :meth:`iterkeys`; for sequences, it should iterate "
"through the values."
msgstr ""
"以下のメソッドを定義して、コンテナオブジェクトを実装することができます。コン"
"テナは通常、(リストやタプルのような) シーケンスや、(辞書のような) マップ型を"
"指しますが、他のコンテナも同じように表現することができます。最初の一連のメ"
"ソッドは、シーケンスをエミュレートしたり、マップ型をエミュレートするために使"
"われます; その違いとして、シーケンスの場合には、キーとして許されているのが、"
"シーケンスの長さが *N* であるときの ``0 <= k < N`` なる整数 *k* か、あるいは"
"要素の範囲を表すスライスオブジェクトでなければならないということです。 (後方"
"互換性のため、 :meth:`__getslice__` (以下参照) を定義して、拡張されていない単"
"純なスライスを扱うようにもできます。)変更可能なシーケンスでは、Python の標準"
"リストオブジェクトのように、メソッド :meth:`append`, :meth:`count`, :meth:"
"`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:"
"`reverse`,および :meth:`sort` を提供しなければなりません。マップ型でも、"
"Python の標準辞書オブジェクトのように、 :meth:`keys`, :meth:`values`, :meth:"
"`items`, :meth:`has_key`, :meth:`get`, :meth:`clear`, :meth:`setdefault`, :"
"meth:`iterkeys`, :meth:`itervalues`, :meth:`iteritems`, :meth:`pop`, :meth:"
"`popitem`, :meth:`!copy`,および :meth:`update` といったメソッドをマップ型で提"
"供するよう推奨しています。 :mod:`UserDict` モジュールでは、これらのメソッド"
"を :meth:`__getitem__`, :meth:`__setitem__`, :meth:`__delitem__`,および :"
"meth:`keys` といった基本セットから作成する上で役に立つ :class:`DictMixin` ク"
"ラスを提供しています。最後に、シーケンス型では以下に述べるメソッド群 :meth:"
"`__add__`, :meth:`__radd__`, :meth:`__iadd__`, :meth:`__mul__`, :meth:"
"`__rmul__`,および :meth:`__imul__` を定義して、 (シーケンス間の結合を意味す"
"る) 加算操作と (要素の繰り返しを意味する) 乗算操作を実装しなければなりませ"
"ん; :meth:`__coerce__` や、その他の数値演算子を定義してはなりません。マップで"
"もシーケンスでも、 ``in`` 演算子が有効利用できるように :meth:`__contains__` "
"メソッドの定義を推奨します; マップ型では、 ``in`` は :meth:`has_key` と等価で"
"なければなりません; シーケンスでは、シーケンス内の値にわたって検索を行わなけ"
"ればなりません。さらに、マップでもシーケンスでも、コンテナ内にわたる反復操作"
"ができるようにするため、 :meth:`__iter__` を実装するよう勧めます; マップ型の"
"場合、 :meth:`__iter__` は :meth:`iterkeys` と等価でなければなりません; シー"
"ケンスの場合、シーケンス内の値にわたって反復操作を行わなければなりません。"

#: ../../reference/datamodel.rst:1889
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`__nonzero__` method and whose :meth:`__len__` method returns "
"zero is considered to be false in a Boolean context."
msgstr ""
"組み込み関数 :func:`len` を実現するために呼び出されます。オブジェクトの長さ"
"を ``>=`` 0 である整数で返さなければなりません。また、オブジェクトが :meth:"
"`__nonzero__` メソッドを定義しておらず、 :meth:`__len__` メソッドがゼロを返す"
"場合には、ブール演算コンテキストでは偽であるとみなされます。"

#: ../../reference/datamodel.rst:1896
msgid ""
"In CPython, the length is required to be at most :attr:`sys.maxsize`. If the "
"length is larger than :attr:`!sys.maxsize` some features (such as :func:"
"`len`) may raise :exc:`OverflowError`.  To prevent raising :exc:`!"
"OverflowError` by truth value testing, an object must define a :meth:"
"`__nonzero__` method."
msgstr ""
"CPython では、オブジェクトの長さは最大でも :attr:`sys.maxsize` であることが要"
"求されます。\n"
"長さが :attr:`!sys.maxsize` を越える場合、(:func:`len` のような) いくつかの機"
"能は :exc:`OverflowError` を送出するでしょう。\n"
"真偽値としての判定で :exc:`!OverflowError` を送出しないようにするには、オブ"
"ジェクトは meth:`__nonzero__` メソッドを定義していなければなりません。"

#: ../../reference/datamodel.rst:1907
msgid ""
"Called to implement evaluation of ``self[key]``. For sequence types, the "
"accepted keys should be integers and slice objects.  Note that the special "
"interpretation of negative indexes (if the class wishes to emulate a "
"sequence type) is up to the :meth:`__getitem__` method. If *key* is of an "
"inappropriate type, :exc:`TypeError` may be raised; if of a value outside "
"the set of indexes for the sequence (after any special interpretation of "
"negative values), :exc:`IndexError` should be raised. For mapping types, if "
"*key* is missing (not in the container), :exc:`KeyError` should be raised."
msgstr ""
"``self[key]`` の値評価 (evaluation) を実現するために呼び出されます。シーケン"
"スの場合、キーとして整数とスライスオブジェクトを受理できなければなりません。 "
"(シーケンス型をエミュレートする場合) 負のインデクスの解釈は :meth:"
"`__getitem__` メソッド次第となります。 *key* が不適切な型であった場合、 :exc:"
"`TypeError` を送出してもかまいません; (負のインデクス値に対して何らかの解釈を"
"行った上で) *key* がシーケンスのインデクス集合外の値である場合、 :exc:"
"`IndexError` を送出しなければなりません。マップ型の場合は、 *key* に誤りがあ"
"る場合（コンテナに含まれていない場合）、 :exc:`KeyError` を送出しなければなり"
"ません。"

#: ../../reference/datamodel.rst:1918
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
":keyword:`for` ループでは、シーケンスの終端を正しく検出できるようにするため"
"に、不正なインデクスに対して :exc:`IndexError` が送出されるものと期待していま"
"す。"

#: ../../reference/datamodel.rst:1924
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support changes to the values for keys, or if new keys can be added, or for "
"sequences if elements can be replaced.  The same exceptions should be raised "
"for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"``self[key]`` に対する代入を実現するために呼び出されます。 :meth:"
"`__getitem__` と同じ注意事項があてはまります。このメソッドを実装できるのは、"
"あるキーに対する値の変更をサポートしているか、新たなキーを追加できるような"
"マップの場合と、ある要素を置き換えることができるシーケンスの場合だけです。不"
"正な *key* に対しては、 :meth:`__getitem__` メソッドと同様の例外の送出を行わ"
"なければなりません。"

#: ../../reference/datamodel.rst:1933
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support removal of keys, or for sequences if elements can be removed from "
"the sequence.  The same exceptions should be raised for improper *key* "
"values as for the :meth:`__getitem__` method."
msgstr ""
"``self[key]`` の削除を実現するために呼び出されます。 :meth:`__getitem__` と同"
"じ注意事項があてはまります。このメソッドを実装できるのは、キーの削除をサポー"
"トしているマップの場合と、要素を削除できるシーケンスの場合だけです。不正な "
"*key* に対しては、 :meth:`__getitem__` メソッドと同様の例外の送出を行わなけれ"
"ばなりません。"

#: ../../reference/datamodel.rst:1942
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]`` "
"for dict subclasses when key is not in the dictionary."
msgstr ""
"``self[key]`` の実装において辞書内にキーが存在しなかった場合に、 dict のサブ"
"クラスのために :class:`dict`\\ .\\ :meth:`__getitem__` によって呼び出されま"
"す。"

#: ../../reference/datamodel.rst:1948
msgid ""
"This method is called when an iterator is required for a container. This "
"method should return a new iterator object that can iterate over all the "
"objects in the container.  For mappings, it should iterate over the keys of "
"the container, and should also be made available as the method :meth:"
"`iterkeys`."
msgstr ""
"このメソッドは、コンテナに対してイテレータが要求された際に呼び出されます。こ"
"のメソッドは、コンテナ内の全てのオブジェクトにわたる反復処理ができるような、"
"新たなイテレータオブジェクトを返さなければなりません。マップの場合、コンテナ"
"内のキーに渡る反復処理でなければならず、かつ :meth:`iterkeys` によって利用で"
"きなければなりません。"

#: ../../reference/datamodel.rst:1953
msgid ""
"Iterator objects also need to implement this method; they are required to "
"return themselves.  For more information on iterator objects, see :ref:"
"`typeiter`."
msgstr ""
"イテレータオブジェクトでもこのメソッドを実装する必要があります; イテレータの"
"場合、自分自身を返さなければなりません。イテレータオブジェクトに関するより詳"
"細な情報は、 :ref:`typeiter` を参照してください。"

#: ../../reference/datamodel.rst:1959
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""
":func:`reversed` 組み込み関数が逆方向イテレーションを実装するために、(存在す"
"れば)呼び出します。コンテナ内の全要素を逆順にイテレートする、新しいイテレータ"
"を返すべきです。"

#: ../../reference/datamodel.rst:1963
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and :"
"meth:`__getitem__`).  Objects that support the sequence protocol should only "
"provide :meth:`__reversed__` if they can provide an implementation that is "
"more efficient than the one provided by :func:`reversed`."
msgstr ""
":meth:`__reversed__` メソッドが定義されていない場合、 :func:`reversed` 組込み"
"関数は sequence プロトコル (:meth:`__len__` と :meth:`__getitem__`) を使った"
"方法にフォールバックします。 sequence プロトコルをサポートしたオブジェクト"
"は、 :func:`reversed` よりも効率のいい実装を提供できる場合にのみ :meth:"
"`__reversed__` を定義するべきです。"

#: ../../reference/datamodel.rst:1972
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a sequence.  However, container "
"objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be a sequence."
msgstr ""
"メンバシップテスト演算子 (:keyword:`in` および :keyword:`not in`) は通常、"
"シーケンスに渡る反復処理を使って実装されます。しかし、コンテナオブジェクトで"
"以下の特殊メソッドを定義して、より効率的な実装を行ったり、オブジェクトがシー"
"ケンスでなくてもよいようにできます。"

#: ../../reference/datamodel.rst:1979
msgid ""
"Called to implement membership test operators.  Should return true if *item* "
"is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""
"メンバシップテスト演算を実現するために呼び出されます。 *item* が *self* 内に"
"存在する場合には真を、そうでない場合には偽を返さなければなりません。マップオ"
"ブジェクトの場合、値やキーと値の組ではなく、キーに対するメンバシップテストを"
"考えなければなりません。"

#: ../../reference/datamodel.rst:1983
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""
":meth:`__contains__` を定義しないオブジェクトに対しては、メンバシップテストは"
"まず、 :meth:`__iter__` を使った反復を試みます、次に古いシーケンス反復プロト"
"コル :meth:`__getitem__` を使います、 :ref:`言語レファレンスのこの節 "
"<membership-test-details>` を参照して下さい。"

#: ../../reference/datamodel.rst:1992
msgid "Additional methods for emulation of sequence types"
msgstr "シーケンス型エミュレーションで使われるその他のメソッド"

#: ../../reference/datamodel.rst:1994
msgid ""
"The following optional methods can be defined to further emulate sequence "
"objects.  Immutable sequences methods should at most only define :meth:"
"`__getslice__`; mutable sequences might define all three methods."
msgstr ""
"以下のオプションとなるメソッドを定義して、シーケンスオブジェクトをより高度に"
"エミュレーションできます。変更不能なシーケンスのメソッドでは、 :meth:"
"`__getslice__` が定義できるだけです; 変更可能なシーケンスでは三つのメソッド全"
"てを定義できます。"

#: ../../reference/datamodel.rst:2001
msgid ""
"Support slice objects as parameters to the :meth:`__getitem__` method. "
"(However, built-in types in CPython currently still implement :meth:"
"`__getslice__`.  Therefore, you have to override it in derived classes when "
"implementing slicing.)"
msgstr ""
"スライスオブジェクトは :meth:`__getitem__` メソッドのパラメタとしてサポートす"
"るようになりました。 (しかし、現在の CPython はいまだに :meth:`__getslice__` "
"を実装しています。なので、派生クラスでスライスを実装する場合は、このメソッド"
"をオーバーライドしなければなりません。)"

#: ../../reference/datamodel.rst:2007
msgid ""
"Called to implement evaluation of ``self[i:j]``. The returned object should "
"be of the same type as *self*.  Note that missing *i* or *j* in the slice "
"expression are replaced by zero or :attr:`sys.maxsize`, respectively.  If "
"negative indexes are used in the slice, the length of the sequence is added "
"to that index. If the instance does not implement the :meth:`__len__` "
"method, an :exc:`AttributeError` is raised. No guarantee is made that "
"indexes adjusted this way are not still negative.  Indexes which are greater "
"than the length of the sequence are not modified. If no :meth:`__getslice__` "
"is found, a slice object is created instead, and passed to :meth:"
"`__getitem__` instead."
msgstr ""
"``self[i:j]`` の値評価を実現するために呼び出されます。返されるオブジェクトは "
"*self* と同じ型でなければなりません。スライス表記で *i* や *j* がない場合に"
"は、それぞれゼロや :attr:`sys.maxsize` に置き換えられるので注意してください。"
"スライスに負のインデクスが用いられた場合、シーケンスの長さがインデクス値に加"
"算されます。インスタンスが :meth:`__len__` メソッドを実装していない場合に"
"は、 :exc:`AttributeError` が送出されます。この計算の結果、インデクス値が負で"
"なくなるという保証はありません。シーケンスの長さよりも大きなインデクス値は修"
"正されません。 :meth:`__getslice__` が定義されていない場合、代わりにスライス"
"オブジェクトが生成されて :meth:`__getitem__` に渡されます。"

#: ../../reference/datamodel.rst:2020
msgid ""
"Called to implement assignment to ``self[i:j]``. Same notes for *i* and *j* "
"as for :meth:`__getslice__`."
msgstr ""
"``self[i:j]`` への代入を実現するために呼び出されます。 *i* および *j* に関し"
"ては、 :meth:`__getslice__` と同じ注釈があてはまります。"

#: ../../reference/datamodel.rst:2023
msgid ""
"This method is deprecated. If no :meth:`__setslice__` is found, or for "
"extended slicing of the form ``self[i:j:k]``, a slice object is created, and "
"passed to :meth:`__setitem__`, instead of :meth:`__setslice__` being called."
msgstr ""
"このメソッドは撤廃されています。 :meth:`__setslice__` がないか、 ``self[i:j:"
"k]`` 形式の拡張スライスの場合には、 :meth:`__setslice__` が呼ばれる代わりにス"
"ライスオブジェクトが生成され、 :meth:`__setitem__` に渡されます。"

#: ../../reference/datamodel.rst:2030
msgid ""
"Called to implement deletion of ``self[i:j]``. Same notes for *i* and *j* as "
"for :meth:`__getslice__`. This method is deprecated. If no :meth:"
"`__delslice__` is found, or for extended slicing of the form ``self[i:j:"
"k]``, a slice object is created, and passed to :meth:`__delitem__`, instead "
"of :meth:`__delslice__` being called."
msgstr ""
"``self[i:j]`` の削除を実現するために呼び出されます。 *i* および *j* に関して"
"は、 :meth:`__getslice__` と同じ注釈があてはまります。このメソッドは撤廃され"
"ています。 :meth:`__delslice__` がないか、 ``self[i:j:k]`` 形式の拡張スライス"
"の場合には、 :meth:`__delslice__` が呼ばれる代わりにスライスオブジェクトが生"
"成され、 :meth:`__delitem__` に渡されます。"

#: ../../reference/datamodel.rst:2036
msgid ""
"Notice that these methods are only invoked when a single slice with a single "
"colon is used, and the slice method is available.  For slice operations "
"involving extended slice notation, or in absence of the slice methods, :meth:"
"`__getitem__`, :meth:`__setitem__` or :meth:`__delitem__` is called with a "
"slice object as argument."
msgstr ""
"これらのメソッドは、単一のコロンを使った単一のスライスで、かつスライスメソッ"
"ドが利用できるときにだけ呼び出されることに注意してください。拡張スライス表記"
"を含んでいるスライス表記や、スライスメソッドがない場合、 :meth:"
"`__getitem__` 、 :meth:`__setitem__` 、あるいは :meth:`__delitem__` がスライ"
"スオブジェクトを引数として呼び出されます。"

#: ../../reference/datamodel.rst:2042
msgid ""
"The following example demonstrate how to make your program or module "
"compatible with earlier versions of Python (assuming that methods :meth:"
"`__getitem__`, :meth:`__setitem__` and :meth:`__delitem__` support slice "
"objects as arguments)::"
msgstr ""
"以下の例は、プログラムやモジュールを以前のバージョンの Python に対して互換性"
"を持たせる方法を示したものです (:meth:`__getitem__` 、 :meth:`__setitem__` 、"
"および :meth:`__delitem__` は引数としてスライスオブジェクトをサポートするもの"
"と仮定します)::"

#: ../../reference/datamodel.rst:2067
msgid ""
"Note the calls to :func:`max`; these are necessary because of the handling "
"of negative indices before the :meth:`__\\*slice__` methods are called.  "
"When negative indexes are used, the :meth:`__\\*item__` methods receive them "
"as provided, but the :meth:`__\\*slice__` methods get a \"cooked\" form of "
"the index values.  For each negative index value, the length of the sequence "
"is added to the index before calling the method (which may still result in a "
"negative index); this is the customary handling of negative indexes by the "
"built-in sequence types, and the :meth:`__\\*item__` methods are expected to "
"do this as well.  However, since they should already be doing that, negative "
"indexes cannot be passed in; they must be constrained to the bounds of the "
"sequence before being passed to the :meth:`__\\*item__` methods. Calling "
"``max(0, i)`` conveniently returns the proper value."
msgstr ""
":func:`max` を呼び出していることに注意してください; この呼び出し :meth:"
"`__\\*slice__` メソッド呼び出される前に、負のインデクス値を処理しておくために"
"必要です。負のインデクス値が使われた場合、 :meth:`__\\*item__` メソッドは与え"
"られた値をそのまま使いますが、 :meth:`__\\*slice__` メソッドは \"調理済みの "
"(cooked)\" 形式になったインデクス値を受け取ります。負のインデクス値が使われる"
"と、メソッドを呼び出す前に、常にシーケンスの長さをインデクス値に加算します "
"(加算してもまだ負の値となっていてもかまいません); これは、組み込みシーケンス"
"型における慣習的な負のインデクス処理方法で、 :meth:`__\\*item__` メソッドでも"
"同様の処理を行うよう期待しています。しかし、ここではすでに負のインデクス値の"
"処理を行っているので、負のインデクスを渡すべきではありません; インデクス値"
"は、 :meth:`__\\*item__` メソッドに渡される前に、シーケンスのインデクス集合の"
"境界に制限されていなければなりません。 ``max(0, i)`` を呼び出せば、適切な値を"
"返すので便利です。"

#: ../../reference/datamodel.rst:2084
msgid "Emulating numeric types"
msgstr "数値型をエミュレーションする"

#: ../../reference/datamodel.rst:2086
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of "
"number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""
"以下のメソッドを定義して、数値型オブジェクトをエミュレートすることができま"
"す。特定の種類の数値型ではサポートされていないような演算に対応するメソッド "
"(非整数の数値に対するビット単位演算など) は、未定義のままにしておかなければな"
"りません。"

#: ../../reference/datamodel.rst:2110
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, "
"``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to evaluate the "
"expression ``x + y``, where *x* is an instance of a class that has an :meth:"
"`__add__` method, ``x.__add__(y)`` is called.  The :meth:`__divmod__` method "
"should be the equivalent to using :meth:`__floordiv__` and :meth:`__mod__`; "
"it should not be related to :meth:`__truediv__` (described below).  Note "
"that :meth:`__pow__` should be defined to accept an optional third argument "
"if the ternary version of the built-in :func:`pow` function is to be "
"supported."
msgstr ""
"これらのメソッドは、二項算術演算 (``+``, ``-``, ``*``, ``//``, ``%``, :func:"
"`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) を実現す"
"るために呼び出されます。例えば、式 ``x + y`` の場合、 *x* が :meth:`__add__` "
"メソッドをもつクラスのインスタンスであれば、 ``x.__add__(y)`` が呼び出されま"
"す。 :meth:`__divmod__` メソッドは、 :meth:`__floordiv__` と :meth:`__mod__` "
"を使った場合と等価にならなければなりません; :meth:`__truediv__` (下記参照) と"
"関連づける必要はありません。組み込みの三項演算子バージョンの関数 :func:`pow` "
"をサポートする場合には、 :meth:`__pow__` は、オプションとなる第三の引数を受け"
"取れなくてはなりません。"

#: ../../reference/datamodel.rst:2120
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr ""
"こらのメソッドが渡された引き数に対する操作を提供していない場合には、 "
"``NotImplemented`` を送出しなければなりません。"

#: ../../reference/datamodel.rst:2127
msgid ""
"The division operator (``/``) is implemented by these methods.  The :meth:"
"`__truediv__` method is used when ``__future__.division`` is in effect, "
"otherwise :meth:`__div__` is used.  If only one of these two methods is "
"defined, the object will not support division in the alternate context; :exc:"
"`TypeError` will be raised instead."
msgstr ""
"除算演算 (``/``) は、これらのメソッドで実現されています。 :meth:"
"`__truediv__` は、 ``__future__.division`` が有効であるときに使われます。それ"
"以外の場合には :meth:`__div__` が使われますs。二つのメソッドのうち一方しか定"
"義されていなければ、オブジェクトは他方の演算コンテキストをサポートしなくなり"
"ます; このとき、 :exc:`TypeError` が送出されます。"

#: ../../reference/datamodel.rst:2153
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``/``, ``%``, :func:`divmod`, :func:`pow`, ``**``, "
"``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) operands.  "
"These functions are only called if the left operand does not support the "
"corresponding operation and the operands are of different types. [#]_ For "
"instance, to evaluate the expression ``x - y``, where *y* is an instance of "
"a class that has an :meth:`__rsub__` method, ``y.__rsub__(x)`` is called if "
"``x.__sub__(y)`` returns *NotImplemented*."
msgstr ""
"これらのメソッドは二項算術演算 (``+``, ``-``, ``*``, ``/``, ``%``, :func:"
"`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) を実現し"
"ますが、メソッド呼び出しが行われる被演算子が逆転して (reflected, swapped: 入"
"れ替えられて) います。これらの関数は、左側の被演算子が対応する演算をサポート"
"しておらずかつ両者の演算子が異なる場合にのみ呼び出されます。 [#]_ 例えば、 "
"``x - y`` の式を評価する場合、 *y* が :meth:`__rsub__` メソッドを持つクラスの"
"インスタンスであって、しかも ``x.__sub__(y)`` が *NotImplemented* を返す場合"
"には、 ``y.__rsub__(x)`` が呼び出されます。"

#: ../../reference/datamodel.rst:2164
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""
"ただし、三項演算子 :func:`pow` が :meth:`__rpow__` を呼ぶことはないので注意し"
"てください (型強制の規則が非常に難解になるからです)。"

#: ../../reference/datamodel.rst:2169
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides the reflected method for the operation, this method "
"will be called before the left operand's non-reflected method.  This "
"behavior allows subclasses to override their ancestors' operations."
msgstr ""
"右側の被演算子の型が左側の被演算子の型のサブクラスであり、このサブクラスであ"
"るメソッドに対する逆転メソッドが定義されている場合には、左側の被演算子の非逆"
"転メソッドが呼ばれる前に、このメソッドが呼ばれます。この振る舞いにより、サブ"
"クラスが親の操作をオーバーライドすることが可能になります。"

#: ../../reference/datamodel.rst:2189
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``, "
"``&=``, ``^=``, ``|=``).  These methods should attempt to do the operation "
"in-place (modifying *self*) and return the result (which could be, but does "
"not have to be, *self*).  If a specific method is not defined, the augmented "
"assignment falls back to the normal methods.  For instance, to execute the "
"statement ``x += y``, where *x* is an instance of a class that has an :meth:"
"`__iadd__` method, ``x.__iadd__(y)`` is called.  If *x* is an instance of a "
"class that does not define a :meth:`__iadd__` method, ``x.__add__(y)`` and "
"``y.__radd__(x)`` are considered, as with the evaluation of ``x + y``."
msgstr ""
"これらのメソッドは、累算算術代入 (augmented arithmetic assignments, ``+=``, "
"``-=``, ``*=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``, ``&=``, "
"``^=``, ``|=``) を実現するために呼び出されます。これらのメソッドは、演算をそ"
"の場で(*self* を変更する形で) 行うよう試み、その結果(変更された *self* または"
"その代わりのもの)を返さなければなりません。特定のメソッドが定義されていない場"
"合、その累算算術演算は通常のメソッドで代用されます。例えば、 ``x += y`` を評"
"価する際、 *x* が :meth:`__iadd__` メソッドを持つクラスのインスタンスであれ"
"ば、 ``x.__iadd__(y)`` が呼び出されます。逆に、 *x* が :meth:`__iadd` メソッ"
"ドを持たないクラスのインスタンスであれば、 ``x + y`` の評価と同じように ``x."
"__add__(y)`` および ``y.__radd__(x)`` を考慮します。"

#: ../../reference/datamodel.rst:2208
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, :func:"
"`abs` and ``~``)."
msgstr ""
"単項算術演算 (``-``, ``+``, :func:`abs` および ``~``) を実現するために呼び出"
"されます。"

#: ../../reference/datamodel.rst:2223
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int`, :"
"func:`long`, and :func:`float`.  Should return a value of the appropriate "
"type."
msgstr ""
"組み込み関数 :func:`complex`, :func:`int`, :func:`long`, および :func:"
"`float` を実現するために呼び出されます。適切な型の値を返さなければなりませ"
"ん。"

#: ../../reference/datamodel.rst:2234
msgid ""
"Called to implement the built-in functions :func:`oct` and :func:`hex`.  "
"Should return a string value."
msgstr ""
"組み込み関数 :func:`oct` および :func:`hex` を実現するために呼び出されます。"
"文字列型を返さなければなりません。"

#: ../../reference/datamodel.rst:2240
msgid ""
"Called to implement :func:`operator.index`.  Also called whenever Python "
"needs an integer object (such as in slicing).  Must return an integer (int "
"or long)."
msgstr ""
":func:`operator.index` を実装するために呼び出されます。また、（スライシング）"
"のように Python が整数オブジェクトを必要とする場合には何処でも呼び出されま"
"す。整数（int もしくは long）を返す必要があります。"

#: ../../reference/datamodel.rst:2248
msgid ""
"Called to implement \"mixed-mode\" numeric arithmetic.  Should either return "
"a 2-tuple containing *self* and *other* converted to a common numeric type, "
"or ``None`` if conversion is impossible.  When the common type would be the "
"type of ``other``, it is sufficient to return ``None``, since the "
"interpreter will also ask the other object to attempt a coercion (but "
"sometimes, if the implementation of the other type cannot be changed, it is "
"useful to do the conversion to the other type here).  A return value of "
"``NotImplemented`` is equivalent to returning ``None``."
msgstr ""
"\"型混合モード (mixed-mode)\" での数値間の算術演算を実現するために呼び出され"
"ます。 *self* と *other* を共通の数値型に変換して、 2 要素のタプルにして返す"
"か、不可能な場合には ``None`` を返さなければなりません。共通の型が ``other`` "
"の型になる場合、 ``None`` を返すだけで十分です。この場合、インタプリタはもう"
"一方のオブジェクトを調べて型強制を行おうとするからです (とはいえ、もう一方の"
"値の型が実装上変更できない場合には、ここで *self* を *other* の型に変換してお"
"いた方が便利です)。戻り値に ``NotImplemented`` を使うのは、 ``None`` を返すの"
"と同じです。"

#: ../../reference/datamodel.rst:2261
msgid "Coercion rules"
msgstr "型強制規則 (coercion rule)"

#: ../../reference/datamodel.rst:2263
msgid ""
"This section used to document the rules for coercion.  As the language has "
"evolved, the coercion rules have become hard to document precisely; "
"documenting what one version of one particular implementation does is "
"undesirable.  Instead, here are some informal guidelines regarding "
"coercion.  In Python 3, coercion will not be supported."
msgstr ""
"本節では、型強制 (coercion) に関する規則について記述します。プログラム言語が"
"進化するにつれ、型強制規則について正確に記述するのは難しくなってゆきます; "
"従って、あるバージョンのある実装について記述するのは望ましくありません。その"
"代わりに、型強制に関する非公式的なガイドラインを示しておきます。 Python 3 か"
"らは、型強制がサポートされなくなる予定です。"

#: ../../reference/datamodel.rst:2271
msgid ""
"If the left operand of a % operator is a string or Unicode object, no "
"coercion takes place and the string formatting operation is invoked instead."
msgstr ""
"% 演算子の左被演算子が文字列か Unicode オブジェクトの場合、型強制は起きず、文"
"字列としての書式化操作が呼び出されます。"

#: ../../reference/datamodel.rst:2276
msgid ""
"It is no longer recommended to define a coercion operation. Mixed-mode "
"operations on types that don't define coercion pass the original arguments "
"to the operation."
msgstr ""
"型強制演算の定義はもはや推奨されていません。型強制を定義していない混合型 "
"(mixed-mode) 演算は、もとの引数をそのまま演算操作に渡すようになっています。"

#: ../../reference/datamodel.rst:2282
msgid ""
"New-style classes (those derived from :class:`object`) never invoke the :"
"meth:`__coerce__` method in response to a binary operator; the only time :"
"meth:`__coerce__` is invoked is when the built-in function :func:`coerce` is "
"called."
msgstr ""
"新しい形式のクラス (:class:`object` から派生したもの) が、二項演算子に対し"
"て :meth:`__coerce__` メソッドを呼び出すことはありません。; :meth:"
"`__coerce__` が呼び出されるのは、組み込み関数 :func:`coerce` が呼び出されたと"
"きだけです。"

#: ../../reference/datamodel.rst:2289
msgid ""
"For most intents and purposes, an operator that returns ``NotImplemented`` "
"is treated the same as one that is not implemented at all."
msgstr ""
"事実上、 ``NotImplemented`` を返す演算子は、全く実装されていないものとして扱"
"われます。"

#: ../../reference/datamodel.rst:2294
msgid ""
"Below, :meth:`__op__` and :meth:`__rop__` are used to signify the generic "
"method names corresponding to an operator; :meth:`__iop__` is used for the "
"corresponding in-place operator.  For example, for the operator '``+``', :"
"meth:`__add__` and :meth:`__radd__` are used for the left and right variant "
"of the binary operator, and :meth:`__iadd__` for the in-place variant."
msgstr ""
"以下の説明では、 :meth:`__op__` および :meth:`__rop__` は、演算子に相当する一"
"般的なメソッド名を表すために使われます; :meth:`__iop__` はインプレース演算子"
"を表します。例えば、演算子 '``+``' の場合、 :meth:`__add__` および :meth:"
"`__radd__` がそれぞれ左右の被演算子用の二項演算子として使われ、 :meth:"
"`__iadd__` がインプレース演算用の演算子として使われる、といった具合です。"

#: ../../reference/datamodel.rst:2302
msgid ""
"For objects *x* and *y*, first ``x.__op__(y)`` is tried.  If this is not "
"implemented or returns ``NotImplemented``, ``y.__rop__(x)`` is tried.  If "
"this is also not implemented or returns ``NotImplemented``, a :exc:"
"`TypeError` exception is raised.  But see the following exception:"
msgstr ""
"オブジェクト *x* および *y* に対して、まず ``x.__op__(y)`` が試されます。この"
"演算が実装されていないか、 ``NotImplemented`` を返す場合、次に ``y."
"__rop__(x)`` が試されます。この演算も実装されていないか、 ``NotImplemented`` "
"を返すなら、 :exc:`TypeError` 例外が送出されます。ただし、以下の例外があるの"
"で参照してください:"

#: ../../reference/datamodel.rst:2309
msgid ""
"Exception to the previous item: if the left operand is an instance of a "
"built-in type or a new-style class, and the right operand is an instance of "
"a proper subclass of that type or class and overrides the base's :meth:"
"`__rop__` method, the right operand's :meth:`__rop__` method is tried "
"*before* the left operand's :meth:`__op__` method."
msgstr ""
"前項に対する例外: 左被演算子が組み込み型や新スタイルクラスのインスタンスであ"
"り、かつ右被演算子が左被演算子と同じクラスか適切なサブクラスのインスタンスで"
"あり、さらに親クラスの :meth:`__rop__` メソッドをオーバライドしている場合、左"
"被演算子の :meth:`__op__` メソッドを試す *前に* 右被演算子の :meth:`__rop__` "
"が試されます。"

#: ../../reference/datamodel.rst:2315
msgid ""
"This is done so that a subclass can completely override binary operators. "
"Otherwise, the left operand's :meth:`__op__` method would always accept the "
"right operand: when an instance of a given class is expected, an instance of "
"a subclass of that class is always acceptable."
msgstr ""
"これは、サブクラス側で二項演算子を完全にオーバライドできるようにするためで"
"す。そうしなければ、常に左被演算子の :meth:`__op__` メソッドが右被演算子を受"
"理してしまいます: あるクラスのインスタンスが被演算子になるとされている場合、"
"そのサブクラスのインスタンスもまた受理可能だからです。"

#: ../../reference/datamodel.rst:2322
msgid ""
"When either operand type defines a coercion, this coercion is called before "
"that type's :meth:`__op__` or :meth:`__rop__` method is called, but no "
"sooner.  If the coercion returns an object of a different type for the "
"operand whose coercion is invoked, part of the process is redone using the "
"new object."
msgstr ""
"双方の被演算子が型強制を定義している場合、型強制は被演算子の型の :meth:"
"`__op__` や :meth:`__rop__` メソッドが呼び出される前に呼び出され、それより早"
"くなることはありません。型強制の結果、型強制を行うことになったいずれの被演算"
"子とも異なる型が返された場合、返されたオブジェクトの新たな型を使って、この過"
"程が部分的に再度行われます。"

#: ../../reference/datamodel.rst:2329
msgid ""
"When an in-place operator (like '``+=``') is used, if the left operand "
"implements :meth:`__iop__`, it is invoked without any coercion.  When the "
"operation falls back to :meth:`__op__` and/or :meth:`__rop__`, the normal "
"coercion rules apply."
msgstr ""
"('``+=``' のような) インプレース型の演算子を用いる際、左被演算子が :meth:"
"`__iop__` を実装していれば、 :meth:`__iop__` が呼び出され、型強制は一切行われ"
"ません。演算が :meth:`__op__` かつ/または :meth:`__rop__` に帰着した場合、通"
"常の型強制規則が適用されます。"

#: ../../reference/datamodel.rst:2336
msgid ""
"In ``x + y``, if *x* is a sequence that implements sequence concatenation, "
"sequence concatenation is invoked."
msgstr ""
"``x + y`` において、 *x* が結合 (concatenation) 演算を実装しているシーケンス"
"であれば、シーケンスの結合が実行されます。"

#: ../../reference/datamodel.rst:2341
msgid ""
"In ``x * y``, if one operand is a sequence that implements sequence "
"repetition, and the other is an integer (:class:`int` or :class:`long`), "
"sequence repetition is invoked."
msgstr ""
"``x * y`` において、一方の演算子が繰り返し (repeat) 演算を実装しているシーケ"
"ンスであり、かつ他方が整数 (:class:`int` または :class:`long`) である場合、"
"シーケンスの繰り返しが実行されます。"

#: ../../reference/datamodel.rst:2347
msgid ""
"Rich comparisons (implemented by methods :meth:`__eq__` and so on) never use "
"coercion.  Three-way comparison (implemented by :meth:`__cmp__`) does use "
"coercion under the same conditions as other binary operations use it."
msgstr ""
"(:meth:`__eq__` などのメソッドで実装されている) 拡張比較は、決して型強制を行"
"いません。(:meth:`__cmp__` で実装されている) 三値比較 (three-way comparison) "
"は、他の二項演算子で行われているのと同じ条件で型強制を受けます。"

#: ../../reference/datamodel.rst:2353
msgid ""
"In the current implementation, the built-in numeric types :class:`int`, :"
"class:`long`, :class:`float`, and :class:`complex` do not use coercion. All "
"these types implement a :meth:`__coerce__` method, for use by the built-in :"
"func:`coerce` function."
msgstr ""
"現在の実装では、組み込み数値型 :class:`int`, :class:`long`, :class:`float` お"
"よび :class:`complex` は型強制を行いません; これらの型は全て、関数 :func:"
"`coerce` から利用するための :meth:`__coerce__` メソッドを実装しています。"

#: ../../reference/datamodel.rst:2360
msgid ""
"The complex type no longer makes implicit calls to the :meth:`__coerce__` "
"method for mixed-type binary arithmetic operations."
msgstr ""
"複素数型は、型混合の二項算術演算に :meth:`__coerce__` を暗示的に呼び出さなく"
"なりました。"

#: ../../reference/datamodel.rst:2367
msgid "With Statement Context Managers"
msgstr "with文とコンテキストマネージャ"

#: ../../reference/datamodel.rst:2371
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be "
"established when executing a :keyword:`with` statement. The context manager "
"handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""
"コンテキストマネージャ(:dfn:`context manager`) とは、 :keyword:`with` 文の実"
"行時にランタイムコンテキストを定義するオブジェクトです。コンテキストマネー"
"ジャは、コードブロックを実行するために必要な入り口および出口の処理を扱いま"
"す。コンテキストマネージャは通常、 :keyword:`with` 文（ :ref:`with` の章を参"
"照）により起動されますが、これらのメソッドを直接呼び出すことで起動することも"
"できます。"

#: ../../reference/datamodel.rst:2382
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""
"コンテキストマネージャの代表的な使い方としては、様々なグローバル情報の保存お"
"よび更新、リソースのロックとアンロック、ファイルのオープンとクローズなどが挙"
"げられます。"

#: ../../reference/datamodel.rst:2385
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`."
msgstr ""
"コンテキストマネージャについてのさらなる情報については、 :ref:"
"`typecontextmanager` を参照してください。"

#: ../../reference/datamodel.rst:2390
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in "
"the :keyword:`as` clause of the statement, if any."
msgstr ""
"コンテキストマネージャのの入り口で実行される処理です。 :keyword:`with` 文は、"
"文の :keyword:`as` 節で規定された値を返すこのメソッドを呼び出します。"

#: ../../reference/datamodel.rst:2397
msgid ""
"Exit the runtime context related to this object. The parameters describe the "
"exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""
"コンテキストマネージャの出口で実行される処理です。パラメータは、コンテキスト"
"が終了した原因となった例外について説明しています。コンテキストが例外を送出せ"
"ず終了した場合は、全ての引き数に :const:`None` が設定されます。"

#: ../../reference/datamodel.rst:2401
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception "
"(i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""
"もし、例外が送出され、かつメソッドが例外を抑制したい場合（すなわち、例外が伝"
"播されるのを防ぎたい場合）、このメソッドは True を返す必要があります。そうで"
"なければ、このメソッドの終了後、例外は通常通り伝播することになります。"

#: ../../reference/datamodel.rst:2405
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""
":meth:`__exit__` メソッドは受け取った例外を再度送出すべきではありません。これ"
"は、呼び出し側の責任でおこなってください。"

#: ../../reference/datamodel.rst:2412
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" ステートメント"

#: ../../reference/datamodel.rst:2412
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python の :keyword:`with` 文の仕様、背景、および例が記載されています。"

#: ../../reference/datamodel.rst:2419
msgid "Special method lookup for old-style classes"
msgstr "旧スタイルクラスの特殊メソッド検索"

#: ../../reference/datamodel.rst:2421
msgid ""
"For old-style classes, special methods are always looked up in exactly the "
"same way as any other method or attribute. This is the case regardless of "
"whether the method is being looked up explicitly as in ``x.__getitem__(i)`` "
"or implicitly as in ``x[i]``."
msgstr ""
"旧スタイルクラスにおいて、特殊メソッドは常に他のメソッドや属性と同じ方法で検"
"索されます。これは、メソッドが ``x.__getitem__(i)`` のように明示的に検索され"
"た時も、 ``x[i]`` のように暗黙的に検索された時も同じです。"

#: ../../reference/datamodel.rst:2426
msgid ""
"This behaviour means that special methods may exhibit different behaviour "
"for different instances of a single old-style class if the appropriate "
"special attributes are set differently::"
msgstr ""
"これにより、1つの旧スタイルクラスの異なるインスタンスが、それぞれ別の適切な特"
"殊属性を持っている場合、異なる動作をすることになります。 ::"

#: ../../reference/datamodel.rst:2446
msgid "Special method lookup for new-style classes"
msgstr "新スタイルクラスの特殊メソッド検索"

#: ../../reference/datamodel.rst:2448
msgid ""
"For new-style classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception (unlike the equivalent example with old-"
"style classes)::"
msgstr ""
"新スタイルクラスでは、特殊メソッドの暗黙的な呼び出しは、オブジェクトインスタ"
"ンスの辞書ではなく、 type の辞書で定義されているときにのみ正しく動作すること"
"が保証されます。この動作は、以下のコードが(旧スタイルクラスの同等な例と異な"
"り)例外を発生させる理由です。 ::"

#: ../../reference/datamodel.rst:2463
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`__hash__` and :meth:`__repr__` that are implemented by all "
"objects, including type objects. If the implicit lookup of these methods "
"used the conventional lookup process, they would fail when invoked on the "
"type object itself::"
msgstr ""
"この動作の背景となる理由は、 :meth:`__hash__` と :meth:`__repr__` といった "
"type オブジェクトを含むすべてのオブジェクトで定義されている特殊メソッドにあり"
"ます。これらのメソッドの暗黙の検索が通常の検索プロセスを使った場合、 type オ"
"ブジェクト自体に対して実行されたときに失敗してしまいます::"

#: ../../reference/datamodel.rst:2476
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is "
"sometimes referred to as 'metaclass confusion', and is avoided by bypassing "
"the instance when looking up special methods::"
msgstr ""
"クラスの非結合メソッドをこのようにして実行しようとすることは、'metaclass "
"confusion' と呼ばれることもあり、特殊メソッドを検索するときはインスタンスをバ"
"イパスすることで回避されます::"

#: ../../reference/datamodel.rst:2485
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the :"
"meth:`__getattribute__` method even of the object's metaclass::"
msgstr ""
"正確性のためにインスタンス属性をスキップするのに加えて、特殊メソッド検索はオ"
"ブジェクトのメタクラスを含めて、 :meth:`__getattribute__` メソッドもバイパス"
"します::"

#: ../../reference/datamodel.rst:2512
msgid ""
"Bypassing the :meth:`__getattribute__` machinery in this fashion provides "
"significant scope for speed optimisations within the interpreter, at the "
"cost of some flexibility in the handling of special methods (the special "
"method *must* be set on the class object itself in order to be consistently "
"invoked by the interpreter)."
msgstr ""
"このように :meth:`__getattribute__` 機構をバイパスすることで、特殊メソッドの"
"扱いに関するある程度の自由度と引き換えに (特殊メソッドはインタプリタから一貫"
"して実行されるためにクラスオブジェクトに設定 *しなければならない*)、インター"
"プリタを高速化するための大きな余地が手に入ります。"

#: ../../reference/datamodel.rst:2520
msgid "Footnotes"
msgstr "注記"

#: ../../reference/datamodel.rst:2521
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"特定の条件が満たされた場合、オブジェクトの type を変更することが *できます"
"* 。これは、正しく扱われなかった場合にとても奇妙な動作を引き起こすので、一般"
"的には良い考えではありません。"

#: ../../reference/datamodel.rst:2525
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method (such as :meth:`__add__`) fails the operation is not supported, which "
"is why the reflected method is not called."
msgstr ""
"同じ型の操作に対しては、(:meth:`__add__` のような)逆転できないメソッドが失敗"
"した時と同じような想定のもと処理されます。これは、逆転したメソッドを呼び出す"
"ことができないからです。"
