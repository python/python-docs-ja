# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Masato HASHIMOTO <cabezon.hashimoto@gmail.com>, 2017
# Inada Naoki <songofacandy@gmail.com>, 2017
# Yuta Baba <dreamingwhitecat47@gmail.com>, 2017
# E. Kawashima, 2017
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2017
# Arihiro TAKASE, 2017
# Osamu NAKAMURA, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2019
# tomo, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-03-31 13:21+0000\n"
"PO-Revision-Date: 2017-02-16 23:38+0000\n"
"Last-Translator: tomo, 2020\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr "データモデル"

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "オブジェクト、値、および型"

#: ../../reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer\", code is also represented by objects.)"
msgstr ""

#: ../../reference/datamodel.rst:35
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The ':keyword:`is`' operator compares the identity of "
"two objects; the :func:`id` function returns an integer representing its "
"identity."
msgstr ""
"すべての属性は、同一性 (identity)、型、値をもっています。 *同一性* "
"は生成されたあとは変更されません。これはオブジェクトのアドレスのようなものだと考えられるかもしれません。 ':keyword:`is`' "
"演算子は2つのオブジェクトの同一性を比較します。 :func:`id` 関数は同一性を表す整数を返します。"

#: ../../reference/datamodel.rst:42
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr "CPython では、``id(x)`` は ``x`` が格納されているメモリ上のアドレスを返します。"

#: ../../reference/datamodel.rst:44
msgid ""
"An object's type determines the operations that the object supports (e.g., "
"\"does it have a length?\") and also defines the possible values for objects"
" of that type.  The :func:`type` function returns an object's type (which is"
" an object itself).  Like its identity, an object's :dfn:`type` is also "
"unchangeable. [#]_"
msgstr ""
"オブジェクトの型はオブジェクトがサポートする操作 (例: :func:`len` をサポートするか) と、オブジェクトが取りうる値を決定します。 "
":func:`type` 関数はオブジェクトの型 (型自体もオブジェクトです) を返します。同一性と同じく、オブジェクトの型(:dfn:`type`) "
"も変更不可能です。 [#]_"

#: ../../reference/datamodel.rst:50
msgid ""
"The *value* of some objects can change.  Objects whose value can change are "
"said to be *mutable*; objects whose value is unchangeable once they are "
"created are called *immutable*. (The value of an immutable container object "
"that contains a reference to a mutable object can change when the latter's "
"value is changed; however the container is still considered immutable, "
"because the collection of objects it contains cannot be changed.  So, "
"immutability is not strictly the same as having an unchangeable value, it is"
" more subtle.) An object's mutability is determined by its type; for "
"instance, numbers, strings and tuples are immutable, while dictionaries and "
"lists are mutable."
msgstr ""
"オブジェクトによっては *値* を変更することが可能です。値を変更できるオブジェクトのことを *mutable* "
"と呼びます。生成後に値を変更できないオブジェクトのことを *immutable* と呼びます。(mutable なオブジェクトへの参照を格納している "
"immutableなコンテナオブジェクトの値は、その格納しているオブジェクトの値が変化した時に変化しますが、コンテナがどのオブジェクトを格納しているのかが変化しないのであれば"
" immutable だと考えることができます。したがって、immutable かどうかは値が変更可能かどうかと完全に一致するわけではありません) "
"オブジェクトが mutable かどうかはその型によって決まります。例えば、数値型、文字列型とタプル型のインスタンスは immutable で、dict"
" や list は mutable です。"

#: ../../reference/datamodel.rst:65
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""
"オブジェクトを明示的に破壊することはできません; しかし、オブジェクトに到達不能 (unreachable) になると、ガベージコレクション "
"(garbage-collection) によって処理されます。実装では、ごみ収集を遅らせたり、全く行わないようにすることができます --- "
"到達可能なオブジェクトをごみ収集処理してしまわないかぎり、どう実装するかは実装品質の問題です。"

#: ../../reference/datamodel.rst:73
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (so you "
"should always close files explicitly)."
msgstr ""
"現在の CPython 実装では参照カウント(reference-counting) 方式を使っており、(オプションとして) "
"循環参照を行っているごみオブジェクトを遅延検出します。この実装ではほとんどのオブジェクトを到達不能になると同時に処理することができますが、循環参照を含むごみオブジェクトの収集が確実に行われるよう保証しているわけではありません。循環参照を持つごみオブジェクト収集の制御については、"
" :mod:`gc` モジュールを参照してください。 "
"CPython以外の実装は別の方式を使っており、CPythonも将来は別の方式を使うかもしれません。オブジェクトが到達不能になったときに即座に終了処理されることに頼らないでください"
" (ですからファイルは必ず明示的に閉じてください)。"

#: ../../reference/datamodel.rst:82
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a ':keyword:`try`...\\ :keyword:`except`' "
"statement may keep objects alive."
msgstr ""
"実装のトレース機能やデバッグ機能を使えば、通常は収集されてしまうようなオブジェクトを生存させることがあるので注意してください。また、 "
"':keyword:`try`...\\ :keyword:`except`' "
"文を使って例外を捕捉できるようにすると、オブジェクトを生存させることがあります。"

#: ../../reference/datamodel.rst:87
msgid ""
"Some objects contain references to \"external\" resources such as open files"
" or windows.  It is understood that these resources are freed when the "
"object is garbage-collected, but since garbage collection is not guaranteed "
"to happen, such objects also provide an explicit way to release the external"
" resource, usually a :meth:`close` method. Programs are strongly recommended"
" to explicitly close such objects.  The ':keyword:`try`...\\ "
":keyword:`finally`' statement and the ':keyword:`with`' statement provide "
"convenient ways to do this."
msgstr ""
"オブジェクトには、開かれたファイルやウィンドウといった、 \"外部 (external) の\" "
"リソースへの参照を含むものがあります。これらのリソースは、オブジェクトがごみ収集された際に解放されるものと理解されていますが、ごみ収集が行われる保証はないので、こうしたオブジェクトは外部リソースを明示的に解放する方法、大抵は"
" :meth:`close` メソッドも提供しています。こうしたオブジェクトは明示的に close "
"するよう強く奨めます。この操作をする際には、':keyword:`try`...\\ :keyword:`finally`' 文や、 "
"':keyword:`with`' 文を使うと便利です。"

#: ../../reference/datamodel.rst:97
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk"
" about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"他のオブジェクトに対する参照をもつオブジェクトもあります; これらは *コンテナ (container)* "
"と呼ばれます。コンテナオブジェクトの例として、タプル、リスト、および辞書が挙げられます。オブジェクトへの参照自体がコンテナの値の一部です。ほとんどの場合、コンテナの値というと、コンテナに入っているオブジェクトの値のことを指し、それらオブジェクトのアイデンティティではありません;"
" しかしながら、コンテナの変更可能性について述べる場合、今まさにコンテナに入っているオブジェクトのアイデンティティのことを指します。したがって、 "
"(タプルのように) "
"変更不能なオブジェクトが変更可能なオブジェクトへの参照を含む場合、その値が変化するのは変更可能なオブジェクトが変更された時、ということになります。"

#: ../../reference/datamodel.rst:106
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer"
" to the same object with the value one, depending on the implementation, but"
" after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two "
"different, unique, newly created empty lists. (Note that ``c = d = []`` "
"assigns the same object to both ``c`` and ``d``.)"
msgstr ""
"型はオブジェクトの動作のほとんど全てに影響します。オブジェクトのアイデンティティが重要かどうかでさえ、ある意味では型に左右されます: "
"変更不能な型では、新たな値を計算するような操作を行うと、実際には同じ型と値を持った既存のオブジェクトへの参照を返すことがありますが、変更可能なオブジェクトではそのような動作は起こりえません。例えば、"
" ``a = 1; b = 1`` とすると、 ``a`` と ``b`` は値 1 "
"を持つ同じオブジェクトを参照するときもあるし、そうでないときもあります。これは実装に依存します。しかし、 ``c = []; d = []`` "
"とすると、 ``c`` と ``d`` はそれぞれ二つの異なった、互いに一意な、新たに作成された空のリストを参照することが保証されています。 (``c "
"= d = []`` とすると、 ``c`` と ``d`` の両方に同じオブジェクトを代入します)"

#: ../../reference/datamodel.rst:120
msgid "The standard type hierarchy"
msgstr "標準型の階層"

#: ../../reference/datamodel.rst:129
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the"
" type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.), although such additions will often be provided via the "
"standard library instead."
msgstr ""
"以下は Python に組み込まれている型のリストです。(実装によって、C、Java、またはその他の言語で書かれた) "
"拡張モジュールで、その他の型が定義されていることがあります。新たな型 (有理数や、整数を効率的に記憶する配列、など) "
"の追加は、たいてい標準ライブラリを通して提供されますが、将来のバージョンの Python では、型の階層構造にこのような追加がなされるかもしれません。"

#: ../../reference/datamodel.rst:140
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation"
" and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""
"以下に説明する型のいくつかには、 '特殊属性 (special attribute)' "
"を列挙した段落があります。これらの属性は実装へのアクセス手段を提供するもので、一般的な用途に利用するためのものではありません。特殊属性の定義は将来変更される可能性があります。"

#: ../../reference/datamodel.rst:150
msgid "None"
msgstr "None"

#: ../../reference/datamodel.rst:147
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from"
" functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトは組み込み名 ``None`` "
"でアクセスされます。このオブジェクトは、様々な状況で値が存在しないことをしめします。例えば、明示的に値を返さない関数は ``None`` を返します。 "
"``None`` の真値 (truth value) は偽 (false) です。"

#: ../../reference/datamodel.rst:165
msgid "NotImplemented"
msgstr "NotImplemented"

#: ../../reference/datamodel.rst:155
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods should return this value if they"
" do not implement the operation for the operands provided.  (The interpreter"
" will then try the reflected operation, or some other fallback, depending on"
" the operator.)  Its truth value is true."
msgstr ""
"この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトは組み込み名 ``NotImplemented``"
" でアクセスされます。数値演算に関するメソッドや拡張比較 (rich comparison) "
"メソッドは、被演算子が該当する演算を行うための実装をもたない場合、この値を返すべきです。(演算子によっては、インタプリタが関連のある演算を試したり、他の代替操作を行います。)"
" 真値は真 (true) です。"

#: ../../reference/datamodel.rst:162
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr "詳細は :ref:`implementing-the-arithmetic-operations` を参照してください。"

#: ../../reference/datamodel.rst:174
msgid "Ellipsis"
msgstr "Ellipsis"

#: ../../reference/datamodel.rst:172
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""
"この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトはリテラル ``...`` または組み込み名 "
"``Ellipsis`` でアクセスされます。真理値は真 (true)です。"

#: ../../reference/datamodel.rst:244
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../../reference/datamodel.rst:179
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable;"
" once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""
"数値リテラルによって作成されたり、算術演算や組み込みの算術関数によって返されるオブジェクトです。数値オブジェクトは変更不能です; "
"一度値が生成されると、二度と変更されることはありません。Python "
"の数値オブジェクトはいうまでもなく数学で言うところの数値と強く関係していますが、コンピュータ内で数値を表現する際に伴う制限を受けています。"

#: ../../reference/datamodel.rst:185
msgid ""
"Python distinguishes between integers, floating point numbers, and complex "
"numbers:"
msgstr "Python は整数、浮動小数点数、複素数の間で区別を行っています:"

#: ../../reference/datamodel.rst:219
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral` (整数)"

#: ../../reference/datamodel.rst:191
msgid ""
"These represent elements from the mathematical set of integers (positive and"
" negative)."
msgstr "整数型は、整数(正の数および負の数)を表す数学的集合内における要素を表現する型です。"

#: ../../reference/datamodel.rst:194
msgid "There are two types of integers:"
msgstr "整数には 2 種類あります:"

#: ../../reference/datamodel.rst:196
msgid "Integers (:class:`int`)"
msgstr "整数 (:class:`int`)"

#: ../../reference/datamodel.rst:198
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""
"無制限の範囲の数を表現しますが、利用可能な (仮想) "
"メモリサイズの制限のみを受けます。シフト演算やマスク演算のために2進数表現を持つと想定されます。負の数は符号ビットが左に無限に延びているような錯覚を与える"
" 2 の補数表現の変型で表されます。"

#: ../../reference/datamodel.rst:214
msgid "Booleans (:class:`bool`)"
msgstr "ブール値 (:class:`bool`)"

#: ../../reference/datamodel.rst:210
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects."
" The Boolean type is a subtype of the integer type, and Boolean values "
"behave like the values 0 and 1, respectively, in almost all contexts, the "
"exception being that when converted to a string, the strings ``\"False\"`` "
"or ``\"True\"`` are returned, respectively."
msgstr ""
"真偽値の False と True を表します。``False`` と ``True`` を表す 2 "
"つのオブジェクトのみがブール値オブジェクトです。ブール型は整数型の派生型であり、ほとんどの状況でそれぞれ 0 と 1 "
"のように振る舞いますが、例外として文字列に変換されたときはそれぞれ ``\"False\"`` および ``\"True\"`` "
"という文字列が返されます。"

#: ../../reference/datamodel.rst:218
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers."
msgstr "整数表現に関する規則は、負の整数を含むシフト演算やマスク演算において、最も有意義な解釈ができるように意図されています。"

#: ../../reference/datamodel.rst:234
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`) (実数)"

#: ../../reference/datamodel.rst:228
msgid ""
"These represent machine-level double precision floating point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does"
" not support single-precision floating point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to"
" complicate the language with two kinds of floating point numbers."
msgstr ""
"この型は計算機レベルの倍精度浮動小数点数を表現します。表現可能な値の範囲やオーバーフローの扱いは計算機のアーキテクチャ（および、CやJavaによる実装）に従います。Pythonは単精度浮動小数点数をサポートしません。一般的に単精度浮動小数点数を使う理由はプロセッサーとメモリの使用を節約するためと説明されます。しかし、こうした節約はPythonでオブジェクトを扱う際のオーバーヘッドに比べれば微々たるものです。また、2種類の浮動小数点数型を持つことで複雑になる理由はありません。"

#: ../../reference/datamodel.rst:244
msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ":class:`numbers.Complex` (:class:`complex`)"

#: ../../reference/datamodel.rst:241
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating point numbers.  The same caveats apply as for floating point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""
"この型は、計算機レベルで倍精度とされている浮動小数点を 2 つ一組にして複素数を表現します。浮動小数点について述べたのと同じ性質が当てはまります。複素数"
" ``z`` の実数部および虚数部は、それぞれ読み出し専用属性 ``z.real`` および ``z.imag`` で取り出すことができます。"

#: ../../reference/datamodel.rst:361
msgid "Sequences"
msgstr "シーケンス型 (sequence)"

#: ../../reference/datamodel.rst:254
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""
"この型は、有限の順序集合 (ordered set) を表現します。要素は非負の整数でインデクス化されています。組み込み関数 :func:`len` "
"を使うと、シーケンスの要素数を返します。シーケンスの長さが *n* の場合、インデクスは 0, 1, ..., *n* -1 "
"からなる集合です。シーケンス *a* の要素 *i* は ``a[i]`` で選択します。"

#: ../../reference/datamodel.rst:261
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type.  This implies that the index set is renumbered "
"so that it starts at 0."
msgstr ""
"シーケンスはスライス操作 (slice) もサポートしています: ``a[i:j]`` とすると、 *i* ``<=`` *k* ``<`` *j* "
"であるインデクス *k* "
"をもつ全ての要素を選択します。式表現としてスライスを用いた場合、スライスは同じ型をもつ新たなシーケンスを表します。新たなシーケンス内では、インデクス集合が"
" 0 から始まるようにインデクスの値を振りなおします。"

#: ../../reference/datamodel.rst:266
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"シーケンスによっては、第三の \"ステップ (step)\" パラメタを持つ \"拡張スライス (extended slice)\" "
"もサポートしています: ``a[i:j:k]`` は、 ``x = i + n*k``, *n* ``>=`` ``0`` かつ *i* ``<=`` "
"*x* ``<`` *j* であるようなインデクス *x* を持つような *a* 全ての要素を選択します。"

#: ../../reference/datamodel.rst:270
msgid "Sequences are distinguished according to their mutability:"
msgstr "シーケンスは、変更可能なものか、そうでないかで区別されています:"

#: ../../reference/datamodel.rst:327
msgid "Immutable sequences"
msgstr "変更不能なシーケンス (immutable sequence)"

#: ../../reference/datamodel.rst:277
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may"
" be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""
"変更不能なシーケンス型のオブジェクトは、一度生成されるとその値を変更することができません。 "
"(オブジェクトに他のオブジェクトへの参照が入っている場合、参照されているオブジェクトは変更可能なオブジェクトでもよく、その値は変更される可能性があります;"
" しかし、変更不能なオブジェクトが直接参照しているオブジェクトの集合自体は、変更することができません。)"

#: ../../reference/datamodel.rst:282
msgid "The following types are immutable sequences:"
msgstr "以下の型は変更不能なシーケンス型です:"

#: ../../reference/datamodel.rst:305
msgid "Strings"
msgstr "文字列型 (string)"

#: ../../reference/datamodel.rst:295
msgid ""
"A string is a sequence of values that represent Unicode code points. All the"
" code points in the range ``U+0000 - U+10FFFF`` can be represented in a "
"string.  Python doesn't have a :c:type:`char` type; instead, every code "
"point in the string is represented as a string object with length ``1``.  "
"The built-in function :func:`ord` converts a code point from its string form"
" to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an integer "
"in the range ``0 - 10FFFF`` to the corresponding length ``1`` string object."
" :meth:`str.encode` can be used to convert a :class:`str` to :class:`bytes` "
"using the given text encoding, and :meth:`bytes.decode` can be used to "
"achieve the opposite."
msgstr ""
"文字列はUnicodeコードポイントを表現する値の配列です。文字列中のどのコードポイントも ``U+0000 - U+10FFFF`` "
"の範囲で表現されることができます。Pythonは :c:type:`char` 型を持ちません。代わりに、文字列中のどのコードポイントも長さ ''1''"
" の文字列オブジェクトとして表現することができます。組み込み関数 :func:`ord` は文字列形式を0 - "
"10FFFFの範囲の整数に変換します。また、組み込み関数 :func:`chr` は ``0 - 10FFFF`` の範囲の整数を対応する長さ "
"``1`` の文字列に変換します。:meth:`str.encode` はテキストエンコーディングを使うことで :class:`str` を "
":class:`bytes` に変換するために使うことができます。また、:meth:`bytes.decode` によりその逆が実行することができます。"

#: ../../reference/datamodel.rst:318
msgid "Tuples"
msgstr "タプル型 (tuple)"

#: ../../reference/datamodel.rst:313
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""
"タプルの要素は任意の Python "
"オブジェクトです。二つ以上の要素からなるタプルは、個々の要素を表現する式をカンマで区切って構成します。単一の要素からなるタプル (単集合 "
"'singleton') を作るには、要素を表現する式の直後にカンマをつけます "
"(単一の式だけではタプルを形成しません。これは、式をグループ化するのに丸括弧を使えるようにしなければならないからです)。要素の全くない丸括弧の対を作ると空のタプルになります。"

#: ../../reference/datamodel.rst:327
msgid "Bytes"
msgstr "bytes"

#: ../../reference/datamodel.rst:323
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes()` constructor can be used to "
"create bytes objects.  Also, bytes objects can be decoded to strings via the"
" :meth:`~bytes.decode` method."
msgstr ""
"bytes オブジェクトは不変な配列です。要素は 8-bit バイトで、 0 <= x < 256 の範囲の整数で表現されます。 (``b'abc'``"
" のような) bytes リテラルや組み込みの :func:`bytes()` コンストラクタを使って bytes オブジェクトを作成できます。また、 "
"bytes オブジェクトは :meth:`~bytes.decode` メソッドを通して文字列にデコードできます。"

#: ../../reference/datamodel.rst:361
msgid "Mutable sequences"
msgstr "変更可能なシーケンス型 (mutable sequence)"

#: ../../reference/datamodel.rst:337
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and "
":keyword:`del` (delete) statements."
msgstr ""
"変更可能なシーケンスは、作成した後で変更することができます。変更可能なシーケンスでは、添字表記やスライス表記を使って指定された要素に代入を行うことができ、"
" :keyword:`del` (delete) 文を使って要素を削除することができます。"

#: ../../reference/datamodel.rst:341
msgid "There are currently two intrinsic mutable sequence types:"
msgstr "Python に最初から組み込まれている変更可能なシーケンス型は、今のところ二つです:"

#: ../../reference/datamodel.rst:348
msgid "Lists"
msgstr "リスト型 (list)"

#: ../../reference/datamodel.rst:346
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that"
" there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"リストの要素は任意の Python オブジェクトにできます。リストは、角括弧の中にカンマで区切られた式を並べて作ります。 (長さが 0 や 1 "
"のシーケンスを作るために特殊な場合分けは必要ないことに注意してください。)"

#: ../../reference/datamodel.rst:356
msgid "Byte Arrays"
msgstr "バイト配列"

#: ../../reference/datamodel.rst:353
msgid ""
"A bytearray object is a mutable array. They are created by the built-in "
":func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"bytearray オブジェクトは変更可能な配列です。組み込みの :func:`bytearray` "
"コンストラクタによって作成されます。変更可能なことを除けば (つまりハッシュ化できない)、 byte array は変更不能な "
":class:`bytes` オブジェクトと同じインターフェースと機能を提供します。"

#: ../../reference/datamodel.rst:360
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type, as does the :mod:`collections` module."
msgstr ""
"拡張モジュール :mod:`array` や、 :mod:`collections` モジュールには、さらなるミュータブルなシーケンス型の例があります。"

#: ../../reference/datamodel.rst:395
msgid "Set types"
msgstr "集合型"

#: ../../reference/datamodel.rst:368
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated"
" over, and the built-in function :func:`len` returns the number of items in "
"a set. Common uses for sets are fast membership testing, removing duplicates"
" from a sequence, and computing mathematical operations such as "
"intersection, union, difference, and symmetric difference."
msgstr ""
"集合型は、順序のない、ユニークで不変なオブジェクトの有限集合を表現します。そのため、(配列の)添字を使ったインデックスアクセスはできません。ただし、イテレートは可能で、組み込み関数"
" :func:`len` "
"は集合の要素数を返します。集合型の一般的な使い方は、集合に属しているかの高速なテスト、シーケンスからの重複の排除、共通集合・和集合・差・対称差といった数学的な演算の計算です。"

#: ../../reference/datamodel.rst:375
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two"
" numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""
"集合の要素には、辞書のキーと同じ普遍性に関するルールが適用されます。数値型は通常の数値比較のルールに従うことに注意してください。もし2つの数値の比較結果が同値である(例えば、"
" ``1`` と ``1.0``)なら、そのうちの1つのみを集合に含めることができます。"

#: ../../reference/datamodel.rst:380
msgid "There are currently two intrinsic set types:"
msgstr "現在、2つの組み込み集合型があります:"

#: ../../reference/datamodel.rst:387
msgid "Sets"
msgstr "集合型"

#: ../../reference/datamodel.rst:385
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as "
":meth:`~set.add`."
msgstr ""
"可変な集合型です。組み込みの :func:`set` コンストラクタで作成され、後から :meth:`~set.add` "
"などのいくつかのメソッドで更新できます。"

#: ../../reference/datamodel.rst:395
msgid "Frozen sets"
msgstr "Frozen set 型"

#: ../../reference/datamodel.rst:392
msgid ""
"These represent an immutable set.  They are created by the built-in "
":func:`frozenset` constructor.  As a frozenset is immutable and "
":term:`hashable`, it can be used again as an element of another set, or as a"
" dictionary key."
msgstr ""
"不変な集合型です。組み込みの :func:`frozenset` コンストラクタによって作成されます。 frozenset は不変で "
":term:`ハッシュ可能 <hashable>` なので、別の集合型の要素になったり、辞書のキーにすることができます。"

#: ../../reference/datamodel.rst:442
msgid "Mappings"
msgstr "マッピング型 (mapping)"

#: ../../reference/datamodel.rst:403
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""
"任意のインデクス集合でインデクス化された、オブジェクトからなる有限の集合を表現します。添字表記 ``a[k]`` は、 ``k`` "
"でインデクス指定された要素を ``a`` から選択します; 選択された要素は式の中で使うことができ、代入や :keyword:`del` "
"文の対象にすることができます。組み込み関数 :func:`len` は、マッピング内の要素数を返します。"

#: ../../reference/datamodel.rst:409
msgid "There is currently a single intrinsic mapping type:"
msgstr "Python に最初から組み込まれているマッピング型は、今のところ一つだけです:"

#: ../../reference/datamodel.rst:442
msgid "Dictionaries"
msgstr "辞書型 (dictionary)"

#: ../../reference/datamodel.rst:414
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""
"ほぼ任意の値でインデクスされたオブジェクトからなる有限の集合を表します。\n"
"キー (key) として使えない値の唯一の型は、リストや辞書、そしてオブジェクトの同一性でなく値で比較されるその他の変更可能な型です。\n"
"これは、辞書型を効率的に実装する上で、キーのハッシュ値が不変である必要があるためです。\n"
"数値型をキーに使う場合、キー値は通常の数値比較における規則に従います: 二つの値が等しくなる場合 (例えば ``1`` と ``1.0``)、互いに同じ辞書のエントリを表すインデクスとして使うことができます。"

#: ../../reference/datamodel.rst:423
msgid ""
"Dictionaries preserve insertion order, meaning that keys will be produced in"
" the same order they were added sequentially over the dictionary. Replacing "
"an existing key does not change the order, however removing a key and re-"
"inserting it will add it to the end instead of keeping its old place."
msgstr ""

#: ../../reference/datamodel.rst:428
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation (see"
" section :ref:`dict`)."
msgstr "辞書は変更可能な型です; 辞書は ``{...}`` 表記で生成します (:ref:`dict` を参照してください)。"

#: ../../reference/datamodel.rst:435
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional "
"examples of mapping types, as does the :mod:`collections` module."
msgstr ""
"拡張モジュール :mod:`dbm.ndbm` 、 :mod:`dbm.gnu` は、 :mod:`collections` "
"モジュールのように、別のマッピング型の例を提供しています。"

#: ../../reference/datamodel.rst:439
msgid ""
"Dictionaries did not preserve insertion order in versions of Python before "
"3.6. In CPython 3.6, insertion order was preserved, but it was considered an"
" implementation detail at that time rather than a language guarantee."
msgstr ""

#: ../../reference/datamodel.rst:700
msgid "Callable types"
msgstr "呼び出し可能型 (callable type)"

#: ../../reference/datamodel.rst:451
msgid ""
"These are the types to which the function call operation (see section "
":ref:`calls`) can be applied:"
msgstr "関数呼び出し操作 (:ref:`calls` 参照) を行うことができる型です:"

#: ../../reference/datamodel.rst:554
msgid "User-defined functions"
msgstr "ユーザ定義関数 (user-defined function)"

#: ../../reference/datamodel.rst:460
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""
"ユーザ定義関数オブジェクトは、関数定義を行うことで生成されます (:ref:`function` 参照)。関数は、仮引数 (formal "
"parameter) リストと同じ数の要素が入った引数リストとともに呼び出されます。"

#: ../../reference/datamodel.rst:465
msgid "Special attributes:"
msgstr "特殊属性:"

#: ../../reference/datamodel.rst:483
msgid "Attribute"
msgstr "属性"

#: ../../reference/datamodel.rst:483
msgid "Meaning"
msgstr "意味"

#: ../../reference/datamodel.rst:485
msgid ":attr:`__doc__`"
msgstr ":attr:`__doc__`"

#: ../../reference/datamodel.rst:485
msgid ""
"The function's documentation string, or ``None`` if unavailable; not "
"inherited by subclasses."
msgstr "関数のドキュメンテーション文字列で、ドキュメンテーションがない場合は ``None`` になります。サブクラスに継承されません。"

#: ../../reference/datamodel.rst:485 ../../reference/datamodel.rst:490
#: ../../reference/datamodel.rst:493 ../../reference/datamodel.rst:498
#: ../../reference/datamodel.rst:502 ../../reference/datamodel.rst:508
#: ../../reference/datamodel.rst:518 ../../reference/datamodel.rst:529
#: ../../reference/datamodel.rst:536
msgid "Writable"
msgstr "書き込み可能"

#: ../../reference/datamodel.rst:490
msgid ":attr:`~definition.\\ __name__`"
msgstr ":attr:`~definition.\\ __name__`"

#: ../../reference/datamodel.rst:490
msgid "The function's name."
msgstr "関数の名前です。"

#: ../../reference/datamodel.rst:493
msgid ":attr:`~definition.\\ __qualname__`"
msgstr ":attr:`~definition.\\ __qualname__`"

#: ../../reference/datamodel.rst:493
msgid "The function's :term:`qualified name`."
msgstr "関数の :term:`qualified name` です。"

#: ../../reference/datamodel.rst:498
msgid ":attr:`__module__`"
msgstr ":attr:`__module__`"

#: ../../reference/datamodel.rst:498
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr "関数が定義されているモジュールの名前です。モジュール名がない場合は ``None`` になります。"

#: ../../reference/datamodel.rst:502
msgid ":attr:`__defaults__`"
msgstr ":attr:`__defaults__`"

#: ../../reference/datamodel.rst:502
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value."
msgstr "デフォルト値を持つ引数に対するデフォルト値が収められたタプルで、デフォルト値を持つ引数がない場合には ``None`` になります"

#: ../../reference/datamodel.rst:508
msgid ":attr:`__code__`"
msgstr ":attr:`__code__`"

#: ../../reference/datamodel.rst:508
msgid "The code object representing the compiled function body."
msgstr "コンパイルされた関数本体を表現するコードオブジェクトです。"

#: ../../reference/datamodel.rst:511
msgid ":attr:`__globals__`"
msgstr ":attr:`__globals__`"

#: ../../reference/datamodel.rst:511
msgid ""
"A reference to the dictionary that holds the function's global variables ---"
" the global namespace of the module in which the function was defined."
msgstr ""
"関数のグローバル変数の入った辞書 (への参照) です --- この辞書は、関数が定義されているモジュールのグローバルな名前空間を決定します。"

#: ../../reference/datamodel.rst:511 ../../reference/datamodel.rst:522
msgid "Read-only"
msgstr "読み出し専用"

#: ../../reference/datamodel.rst:518
msgid ":attr:`~object.__dict__`"
msgstr ":attr:`~object.__dict__`"

#: ../../reference/datamodel.rst:518
msgid "The namespace supporting arbitrary function attributes."
msgstr "任意の関数属性をサポートするための名前空間が収められています。"

#: ../../reference/datamodel.rst:522
msgid ":attr:`__closure__`"
msgstr ":attr:`__closure__`"

#: ../../reference/datamodel.rst:522
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's free "
"variables. See below for information on the ``cell_contents`` attribute."
msgstr ""
"``None`` または関数の個々の自由変数 (引数以外の変数) に対して値を束縛しているセル (cell) 群からなるタプルになります。\n"
"``cell_contents`` 属性についての情報は下を参照してください。"

#: ../../reference/datamodel.rst:529
msgid ":attr:`__annotations__`"
msgstr ":attr:`__annotations__`"

#: ../../reference/datamodel.rst:529
msgid ""
"A dict containing annotations of parameters.  The keys of the dict are the "
"parameter names, and ``'return'`` for the return annotation, if provided."
msgstr "パラメータの注釈が入った辞書です。辞書のキーはパラメータ名で、返り値の注釈がある場合は、``'return'`` がそのキーとなります。"

#: ../../reference/datamodel.rst:536
msgid ":attr:`__kwdefaults__`"
msgstr ":attr:`__kwdefaults__`"

#: ../../reference/datamodel.rst:536
msgid "A dict containing defaults for keyword-only parameters."
msgstr "キーワード専用パラメータのデフォルト値を含む辞書です。"

#: ../../reference/datamodel.rst:540
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the assigned "
"value."
msgstr "「書き込み可能」とラベルされている属性のほとんどは、代入された値の型をチェックします。"

#: ../../reference/datamodel.rst:542
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes. *Note that "
"the current implementation only supports function attributes on user-defined"
" functions. Function attributes on built-in functions may be supported in "
"the future.*"
msgstr ""
"関数オブジェクトはまた、任意の属性を設定したり取得したりできます。この機能は、例えば関数にメタデータを付与したい場合などに使えます。関数の get や "
"set には、通常のドット表記を使います。 "
"*現在の実装では、ユーザ定義の関数でのみ属性をサポートしているので注意して下さい。組み込み関数の属性は将来サポートする予定です。*"

#: ../../reference/datamodel.rst:548
msgid ""
"A cell object has the attribute ``cell_contents``. This can be used to get "
"the value of the cell, as well as set the value."
msgstr ""
"セルオブジェクトは属性 ``cell_contents`` を持っています。\n"
"これはセルの値を設定するのに加えて、セルの値を得るのにも使えます。"

#: ../../reference/datamodel.rst:551
msgid ""
"Additional information about a function's definition can be retrieved from "
"its code object; see the description of internal types below. The "
":data:`cell <types.CellType>` type can be accessed in the :mod:`types` "
"module."
msgstr ""
"関数定義に関するその他の情報は関数のコードオブジェクトから得られます。後述の内部型 (internal type) に関する説明を参照してください。\n"
":data:`cell <types.CellType>` 型には :mod:`types` モジュールからアクセスできます。"

#: ../../reference/datamodel.rst:617
msgid "Instance methods"
msgstr "インスタンスメソッド"

#: ../../reference/datamodel.rst:562
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr "インスタンスメソッドオブジェクトは、クラス、クラスインスタンスと任意の呼び出し可能オブジェクト (通常はユーザ定義関数) を結びつけます。"

#: ../../reference/datamodel.rst:572
msgid ""
"Special read-only attributes: :attr:`__self__` is the class instance object,"
" :attr:`__func__` is the function object; :attr:`__doc__` is the method's "
"documentation (same as ``__func__.__doc__``); :attr:`~definition.__name__` "
"is the method name (same as ``__func__.__name__``); :attr:`__module__` is "
"the name of the module the method was defined in, or ``None`` if "
"unavailable."
msgstr ""
"読み出し専用の特殊属性: :attr:`__self__` はクラスインスタンスオブジェクトで、 :attr:`__func__` は関数オブジェクトです;\n"
":attr:`__doc__` はメソッドのドキュメンテーション文字列 (``__func__.__doc__`` と同じ) です;\n"
":attr:`~definition.__name__` はメソッドの名前 (``__func__.__name__`` と同じ) です;\n"
":attr:`__module__` はメソッドが定義されたモジュールの名前か、モジュール名がない場合は ``None`` になります。"

#: ../../reference/datamodel.rst:578
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr "メソッドもまた、根底にある関数オブジェクトの任意の関数属性に (値の設定はできませんが) アクセスできます。"

#: ../../reference/datamodel.rst:581
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined function object or a class method object."
msgstr ""
"クラスの属性を (場合によってはそのクラスのインスタンスを介して) "
"取得するとき、その属性がユーザ定義の関数オブジェクトまたはクラスメソッドオブジェクトであれば、ユーザ定義メソッドオブジェクトが生成されることがあります。"

#: ../../reference/datamodel.rst:585
msgid ""
"When an instance method object is created by retrieving a user-defined "
"function object from a class via one of its instances, its :attr:`__self__` "
"attribute is the instance, and the method object is said to be bound.  The "
"new method's :attr:`__func__` attribute is the original function object."
msgstr ""
"クラスからインスタンスを経由してユーザ定義関数オブジェクトを取得することによってインスタンスメソッドオブジェクトが生成されたとき、 "
":attr:`__self__` 属性はそのインスタンスで、このメソッドオブジェクトは束縛されている (bound) といいます。新しいメソッドの "
":attr:`__func__` 属性はもとの関数オブジェクトです。"

#: ../../reference/datamodel.rst:591
msgid ""
"When an instance method object is created by retrieving a class method "
"object from a class or instance, its :attr:`__self__` attribute is the class"
" itself, and its :attr:`__func__` attribute is the function object "
"underlying the class method."
msgstr ""
"クラスやインスタンスからクラスメソッドオブジェクトを取得することによってインスタンスメソッドオブジェクトが生成されたとき、 "
":attr:`__self__` 属性はクラスそのもので、 :attr:`__func__` 属性はクラスメソッドの根底にある関数オブジェクトです。"

#: ../../reference/datamodel.rst:596
msgid ""
"When an instance method object is called, the underlying function "
"(:attr:`__func__`) is called, inserting the class instance "
"(:attr:`__self__`) in front of the argument list.  For instance, when "
":class:`C` is a class which contains a definition for a function :meth:`f`, "
"and ``x`` is an instance of :class:`C`, calling ``x.f(1)`` is equivalent to "
"calling ``C.f(x, 1)``."
msgstr ""
"インスタンスメソッドオブジェクトが呼び出される際、根底にある関数 (:attr:`__func__`) が呼び出されます。このとき、クラスインスタンス "
"(:attr:`__self__`) が引数リストの先頭に挿入されます。例えば、 :class:`C` を関数 :meth:`f` の定義を含むクラス、"
" ``x`` を :class:`C` のインスタンスとすると、 ``x.f(1)`` の呼び出しは ``C.f(x, 1)`` の呼び出しと同じです。"

#: ../../reference/datamodel.rst:603
msgid ""
"When an instance method object is derived from a class method object, the "
"\"class instance\" stored in :attr:`__self__` will actually be the class "
"itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to "
"calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""
"クラスメソッドオブジェクトからインスタンスメソッドオブジェクトが導出される際、 :attr:`__self__` に記憶されている "
"\"クラスインスタンス\" は実際はクラスそのものなので、 ``x.f(1)`` や ``C.f(1)`` の呼び出しは、根底にある関数を ``f`` "
"として ``f(C,1)`` の呼び出しと等価です。"

#: ../../reference/datamodel.rst:608
msgid ""
"Note that the transformation from function object to instance method object "
"happens each time the attribute is retrieved from the instance.  In some "
"cases, a fruitful optimization is to assign the attribute to a local "
"variable and call that local variable. Also notice that this transformation "
"only happens for user-defined functions; other callable objects (and all "
"non-callable objects) are retrieved without transformation.  It is also "
"important to note that user-defined functions which are attributes of a "
"class instance are not converted to bound methods; this *only* happens when "
"the function is an attribute of the class."
msgstr ""
"なお、関数オブジェクトからインスタンスメソッドオブジェクトへの変換は、インスタンスから属性が取り出されるたびに行われます。場合によっては、属性をローカル変数に代入しておき、そのローカル変数を呼び出すようにするのが効果的な最適化になります。また、上記の変換はユーザ定義関数に対してのみ行われます;"
" その他の呼び出し可能オブジェクト (および呼び出し可能でない全てのオブジェクト) "
"は、変換されずに取り出されます。それから、クラスインスタンスの属性になっているユーザ定義関数は、束縛メソッドに変換されません; "
"変換されるのは、関数がクラスの属性である場合 *だけ* です。"

#: ../../reference/datamodel.rst:632
msgid "Generator functions"
msgstr "ジェネレータ関数 (generator function)"

#: ../../reference/datamodel.rst:624
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section "
":ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an iterator object which can be used to execute the "
"body of the function:  calling the iterator's :meth:`iterator.__next__` "
"method will cause the function to execute until it provides a value using "
"the :keyword:`!yield` statement.  When the function executes a "
":keyword:`return` statement or falls off the end, a :exc:`StopIteration` "
"exception is raised and the iterator will have reached the end of the set of"
" values to be returned."
msgstr ""
":keyword:`yield` 文 (:ref:`yield` の節を参照) を使う関数もしくはメソッドは :dfn:`ジェネレータ関数` と呼ばれます。\n"
"そのような関数が呼び出されたときは常に、関数の本体を実行するのに使えるイテレータオブジェクトを返します:\n"
"イテレータの :meth:`iterator.__next__` メソッドを呼び出すと、 :keyword:`!yield` 文を使って値が提供されるまで関数を実行します。\n"
"関数の :keyword:`return` 文を実行するか終端に達したときは、 :exc:`StopIteration` 例外が送出され、イテレータが返すべき値の最後まで到達しています。"

#: ../../reference/datamodel.rst:642
msgid "Coroutine functions"
msgstr "コルーチン関数 (coroutine function)"

#: ../../reference/datamodel.rst:638
msgid ""
"A function or method which is defined using :keyword:`async def` is called a"
" :dfn:`coroutine function`.  Such a function, when called, returns a "
":term:`coroutine` object.  It may contain :keyword:`await` expressions, as "
"well as :keyword:`async with` and :keyword:`async for` statements. See also "
"the :ref:`coroutine-objects` section."
msgstr ""
":keyword:`async def` を使用して定義された関数やメソッドを :dfn:`コルーチン関数 (coroutine function)` と呼びます。 \n"
"呼び出された時、そのような関数は :term:`coroutine` オブジェクトを返します。\n"
"コルーチン関数は :keyword:`async with` や :keyword:`async for` 文だけでなく :keyword:`await` 式を持つことが出来ます。\n"
":ref:`coroutine-objects` を参照してください。"

#: ../../reference/datamodel.rst:661
msgid "Asynchronous generator functions"
msgstr "非同期ジェネレータ関数 (asynchronous generator function)"

#: ../../reference/datamodel.rst:649
msgid ""
"A function or method which is defined using :keyword:`async def` and which "
"uses the :keyword:`yield` statement is called a :dfn:`asynchronous generator"
" function`.  Such a function, when called, returns an asynchronous iterator "
"object which can be used in an :keyword:`async for` statement to execute the"
" body of the function."
msgstr ""
":keyword:`async def` を使って定義され、 :keyword:`yield` 文を使用している関数やメソッドを :dfn:`asynchronous generator function` と呼びます。\n"
"そのような関数は、呼び出されたとき、非同期イテレータオブジェクトを返します。\n"
"このオブジェクトは :keyword:`async for` 文で関数の本体を実行するのに使えます。"

#: ../../reference/datamodel.rst:655
msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__` method will "
"return an :term:`awaitable` which when awaited will execute until it "
"provides a value using the :keyword:`yield` expression.  When the function "
"executes an empty :keyword:`return` statement or falls off the end, a "
":exc:`StopAsyncIteration` exception is raised and the asynchronous iterator "
"will have reached the end of the set of values to be yielded."
msgstr ""
"非同期イテレータの :meth:`aiterator.__anext__` メソッドを呼び出すと、他の処理が待たされているときに、 :keyword:`yield` 式を使い値を提供するところまで処理を進める :term:`awaitable` を返します。\n"
"その関数が空の :keyword:`return` 文を実行する、もしくは処理の終わりに到達したときは、 :exc:`StopAsyncIteration` 例外が送出され、非同期イテレータは出力すべき値の最後に到達したことになります。"

#: ../../reference/datamodel.rst:676
msgid "Built-in functions"
msgstr "組み込み関数 (built-in function)"

#: ../../reference/datamodel.rst:669
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: :attr:`__doc__` "
"is the function's documentation string, or ``None`` if unavailable; "
":attr:`~definition.__name__` is the function's name; :attr:`__self__` is set"
" to ``None`` (but see the next item); :attr:`__module__` is the name of the "
"module the function was defined in or ``None`` if unavailable."
msgstr ""
"組み込み関数オブジェクトはC関数へのラッパーです。\n"
"組み込み関数の例は :func:`len` や :func:`math.sin` (:mod:`math` は標準の組み込みモジュール) です。\n"
"引数の数や型は C 関数で決定されています。\n"
"読み出し専用の特殊属性: :attr:`__doc__` は関数のドキュメンテーション文字列です。\n"
"ドキュメンテーションがない場合は ``None`` になります;\n"
":attr:`~definition.__name__` は関数の名前です;\n"
":attr:`__self__` は ``None`` に設定されています (組み込みメソッドの節も参照してください);\n"
":attr:`__module__` は、関数が定義されているモジュールの名前です。\n"
"モジュール名がない場合は ``None`` になります。"

#: ../../reference/datamodel.rst:688
msgid "Built-in methods"
msgstr "組み込みメソッド (built-in method)"

#: ../../reference/datamodel.rst:684
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra argument."
"  An example of a built-in method is ``alist.append()``, assuming *alist* is"
" a list object. In this case, the special read-only attribute "
":attr:`__self__` is set to the object denoted by *alist*."
msgstr ""
"実際には組み込み関数を別の形で隠蔽したもので、こちらの場合には C "
"関数に渡される何らかのオブジェクトを非明示的な外部引数として持っています。組み込みメソッドの例は、 *alist* をリストオブジェクトとしたときの "
"``alist.append()`` です。この場合には、読み出し専用の属性 :attr:`__self__` は *alist* "
"で表されるオブジェクトになります。"

#: ../../reference/datamodel.rst:695
msgid "Classes"
msgstr "クラス"

#: ../../reference/datamodel.rst:691
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that "
"override :meth:`__new__`.  The arguments of the call are passed to "
":meth:`__new__` and, in the typical case, to :meth:`__init__` to initialize "
"the new instance."
msgstr ""
"クラスは呼び出し可能です。そのオブジェクトは通常、そのクラスの新たなインスタンスのファクトリとして振舞いますが、 :meth:`__new__` "
"をオーバーライドして、バリエーションを持たせることもできます。呼び出しに使われた引数は、 :meth:`__new__` と、典型的な場合では "
":meth:`__init__` に渡され、新たなインスタンスの初期化に使われます。"

#: ../../reference/datamodel.rst:700
msgid "Class Instances"
msgstr "クラスのインスタンス"

#: ../../reference/datamodel.rst:698
msgid ""
"Instances of arbitrary classes can be made callable by defining a "
":meth:`__call__` method in their class."
msgstr "任意のクラスのインスタンスは、クラスで :meth:`__call__` メソッドを定義することで呼び出し可能になります。"

#: ../../reference/datamodel.rst:750
msgid "Modules"
msgstr "モジュール (module)"

#: ../../reference/datamodel.rst:707
msgid ""
"Modules are a basic organizational unit of Python code, and are created by "
"the :ref:`import system <importsystem>` as invoked either by the "
":keyword:`import` statement, or by calling functions such as "
":func:`importlib.import_module` and built-in :func:`__import__`.  A module "
"object has a namespace implemented by a dictionary object (this is the "
"dictionary referenced by the ``__globals__`` attribute of functions defined "
"in the module).  Attribute references are translated to lookups in this "
"dictionary, e.g., ``m.x`` is equivalent to ``m.__dict__[\"x\"]``. A module "
"object does not contain the code object used to initialize the module (since"
" it isn't needed once the initialization is done)."
msgstr ""
"モジュールは Python コードの基礎的な構成単位で、 :keyword:`import` 文あるいは "
":func:`importlib.import_module` や組み込みの :func:`__import__` "
"のような関数を呼び出すことで起動される :ref:`import system <importsystem>` "
"によって作成されます。モジュールオブジェクトは、辞書オブジェクト (これは、モジュール内で定義された関数の ``__globals__`` "
"属性から参照される辞書です) で実装された名前空間を持っています。属性の参照は、この辞書の検索に翻訳されます。例えば、 ``m.x`` は "
"``m.__dict__[\"x\"]`` と等価です。モジュールオブジェクトは、モジュールの初期化に使われるコードオブジェクトを含んでいません "
"(初期化が終わればもう必要ないからです)。"

#: ../../reference/datamodel.rst:719
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"属性の代入を行うと、モジュールの名前空間辞書の内容を更新します。例えば、 ``m.x = 1`` は ``m.__dict__[\"x\"] = 1``"
" と同じです。"

#: ../../reference/datamodel.rst:729
msgid ""
"Predefined (writable) attributes: :attr:`__name__` is the module's name; "
":attr:`__doc__` is the module's documentation string, or ``None`` if "
"unavailable; :attr:`__annotations__` (optional) is a dictionary containing "
":term:`variable annotations <variable annotation>` collected during module "
"body execution; :attr:`__file__` is the pathname of the file from which the "
"module was loaded, if it was loaded from a file. The :attr:`__file__` "
"attribute may be missing for certain types of modules, such as C modules "
"that are statically linked into the interpreter; for extension modules "
"loaded dynamically from a shared library, it is the pathname of the shared "
"library file."
msgstr ""
"定義済みの (書き込み可能な) 属性: :attr:`__name__` はモジュールの名前です;  :attr:`__doc__` "
"は関数のドキュメンテーション文字列です。ドキュメンテーションがない場合は ``None`` になります; :attr:`__annotations__`"
" (オプショナル) はモジュールの本体を実行しているときに収集した :term:`変数アノテーション <variable annotation>` "
"が入った辞書です; モジュールがファイルからロードされた場合、 :attr:`__file__` "
"はロードされたモジュールファイルのパス名です。インタプリタに静的にリンクされている C モジュールのような特定の種類のモジュールでは、 "
":attr:`__file__` 属性は存在しないかもしれません; 共有ライブラリから動的にロードされた拡張モジュールの場合、この属性は "
"共有ライブラリファイルのパス名になります。"

#: ../../reference/datamodel.rst:742
msgid ""
"Special read-only attribute: :attr:`~object.__dict__` is the module's "
"namespace as a dictionary object."
msgstr "読み出し専用の特殊属性: :attr:`~object.__dict__` はモジュールの名前空間で、辞書オブジェクトです。"

#: ../../reference/datamodel.rst:747
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary"
" will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""
"CPython "
"がモジュール辞書を削除する方法により、モジュール辞書が生きた参照を持っていたとしてもその辞書はモジュールがスコープから外れた時に削除されます。これを避けるには、辞書をコピーするか、辞書を直接使っている間モジュールを保持してください。"

#: ../../reference/datamodel.rst:809
msgid "Custom classes"
msgstr "カスタムクラス型"

#: ../../reference/datamodel.rst:753
msgid ""
"Custom class types are typically created by class definitions (see section "
":ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, "
"e.g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although there are a "
"number of hooks which allow for other means of locating attributes). When "
"the attribute name is not found there, the attribute search continues in the"
" base classes. This search of the base classes uses the C3 method resolution"
" order which behaves correctly even in the presence of 'diamond' inheritance"
" structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by Python can be "
"found in the documentation accompanying the 2.3 release at "
"https://www.python.org/download/releases/2.3/mro/."
msgstr ""
"カスタムクラス型は通常、クラス定義 (:ref:`class` 参照) "
"で生成されます。クラスは辞書オブジェクトで実装された名前空間を持っています。クラス属性の参照は、この辞書に対する探索 (lookup) "
"に翻訳されます。例えば、 ``C.x`` は ``C.__dict__[\"x\"]`` に翻訳されます "
"(ただし、属性参照の意味を変えられる幾つかのフックがあります)。属性がこの探索で見つからないとき、その基底クラスで探索が続けられます。基底クラスのこの探索は、C3"
" メソッド解決順序 (MRO=method resolution order) "
"を利用していて、複数の継承経路が共通の祖先につながる「ダイアモンド」継承構造があっても正しく動作します。 C3 MRO についてのより詳細な情報は、 "
"2.3リリースに付属するドキュメント https://www.python.org/download/releases/2.3/mro/ にあります。"

#: ../../reference/datamodel.rst:777
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield a "
"class method object, it is transformed into an instance method object whose "
":attr:`__self__` attribute is :class:`C`.  When it would yield a static "
"method object, it is transformed into the object wrapped by the static "
"method object. See section :ref:`descriptors` for another way in which "
"attributes retrieved from a class may differ from those actually contained "
"in its :attr:`~object.__dict__`."
msgstr ""
"クラス (:class:`C` とします) 属性参照がクラスメソッドオブジェクトを返そうとするときには、 そのオブジェクトは :attr:`__self__` 属性が :class:`C` であるようなインスタンスメソッドオブジェクトに変換されます。\n"
"静的メソッドオブジェクトを返そうとするときには、静的メソッドオブジェクトでラップされたオブジェクトに変換されます。\n"
":ref:`descriptors` 節を参照すると、また別の理由でクラスから取り出した属性と実際に :attr:`~object.__dict__` に保存されているものが異なることがあるのが分かります。"

#: ../../reference/datamodel.rst:787
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr "クラス属性を代入すると、そのクラスの辞書だけが更新され、基底クラスの辞書は更新しません。"

#: ../../reference/datamodel.rst:792
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr "クラスオブジェクトを呼び出す (上記を参照) と、クラスインスタンスを生成します (下記を参照)。"

#: ../../reference/datamodel.rst:802
msgid ""
"Special attributes: :attr:`~definition.__name__` is the class name; "
":attr:`__module__` is the module name in which the class was defined; "
":attr:`~object.__dict__` is the dictionary containing the class's namespace;"
" :attr:`~class.__bases__` is a tuple containing the base classes, in the "
"order of their occurrence in the base class list; :attr:`__doc__` is the "
"class's documentation string, or ``None`` if undefined; "
":attr:`__annotations__` (optional) is a dictionary containing "
":term:`variable annotations <variable annotation>` collected during class "
"body execution."
msgstr ""
"特殊属性: :attr:`~definition.__name__` はクラス名です;\n"
":attr:`__module__` はクラスが定義されたモジュール名です;\n"
":attr:`~object.__dict__` はクラスが持つ名前空間が入った辞書です;\n"
":attr:`~class.__bases__` は基底クラスからなるタプルで、基底クラスのリストに表れる順序で並んでいます;\n"
":attr:`__doc__` はクラスのドキュメント文字列で、未定義の場合は None です;\n"
":attr:`__annotations__` (オプショナル) はクラスの本体を実行しているときに収集した :term:`変数アノテーション <variable annotation>` が入った辞書です。"

#: ../../reference/datamodel.rst:852
msgid "Class instances"
msgstr "クラスインスタンス (class instance)"

#: ../../reference/datamodel.rst:818
msgid ""
"A class instance is created by calling a class object (see above).  A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object, it is transformed into an instance "
"method object whose :attr:`__self__` attribute is the instance.  Static "
"method and class method objects are also transformed; see above under "
"\"Classes\".  See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`.  If no "
"class attribute is found, and the object's class has a :meth:`__getattr__` "
"method, that is called to satisfy the lookup."
msgstr ""
"クラスインスタンスは、クラスオブジェクト (上記参照) を呼び出して生成します。\n"
"クラスインスタンスは辞書で実装された名前空間を持っており、属性参照の時にはまずこの辞書が探索されます。\n"
"ここで属性が見つからず、インスタンスのクラスにその名前の属性があるときは、続けてクラス属性を検索します。\n"
"見つかったクラス属性がユーザ定義関数オブジェクトだった場合、クラスインスタンスを :attr:`__self__` 属性とするインスタンスメソッドオブジェクトに変換します。\n"
"静的メソッドオブジェクトやクラスメソッドオブジェクトも同様に変換されます;\n"
"上記の \"クラス\" を参照してください。\n"
":ref:`descriptors` 節を参照すると、また別の理由でインスタンスを通してクラスから取り出した属性と実際に :attr:`~object.__dict__` に保存されているものが異なることがあるのが分かります。\n"
"クラス属性が見つからず、かつオブジェクトのクラスが :meth:`__getattr__` メソッドを持っている場合は、探索の義務を果たすためにこのメソッドが呼び出されます。"

#: ../../reference/datamodel.rst:834
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`__setattr__` or "
":meth:`__delattr__` method, this is called instead of updating the instance "
"dictionary directly."
msgstr ""
"属性の代入や削除を行うと、インスタンスの辞書を更新しますが、クラスの辞書を更新することはありません。クラスで :meth:`__setattr__` や"
" :meth:`__delattr__` メソッドが定義されている場合、直接インスタンスの辞書を更新する代わりにこれらのメソッドが呼び出されます。"

#: ../../reference/datamodel.rst:844
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""
"クラスインスタンスは、ある特定の名前のメソッドを持っている場合、数値型やシーケンス型、あるいはマップ型のように振舞うことができます。 "
":ref:`specialnames` を参照してください。"

#: ../../reference/datamodel.rst:851
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary; "
":attr:`~instance.__class__` is the instance's class."
msgstr ""
"特殊属性: :attr:`~object.__dict__` は属性の辞書です; :attr:`~instance.__class__` "
"はインスタンスのクラスです。"

#: ../../reference/datamodel.rst:878
msgid "I/O objects (also known as file objects)"
msgstr "I/O オブジェクト (ファイルオブジェクトの別名)"

#: ../../reference/datamodel.rst:868
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and "
"also :func:`os.popen`, :func:`os.fdopen`, and the "
":meth:`~socket.socket.makefile` method of socket objects (and perhaps by "
"other functions or methods provided by extension modules)."
msgstr ""
":term:`file object` は開かれたファイルを表します。ファイルオブジェクトを作るための様々なショートカットがあります: "
":func:`open` 組み込み関数、 :func:`os.popen` 、 :func:`os.fdopen` 、ソケットオブジェクトの "
":meth:`~socket.socket.makefile` メソッド (あるいは拡張モジュールから提供される他の関数やメソッド) 。"

#: ../../reference/datamodel.rst:874
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized"
" to file objects corresponding to the interpreter's standard input, output "
"and error streams; they are all open in text mode and therefore follow the "
"interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""
"オブジェクト ``sys.stdin`` 、 ``sys.stdout`` および ``sys.stderr`` "
"は、インタプリタの標準入力、標準出力、および標準エラー出力ストリームに対応するファイルオブジェクトに初期化されます。これらはすべてテキストモードで開かれ、"
" :class:`io.TextIOBase` 抽象クラスによって定義されたインタフェースに従います。"

#: ../../reference/datamodel.rst:1123
msgid "Internal types"
msgstr "内部型 (internal type)"

#: ../../reference/datamodel.rst:885
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""
"インタプリタが内部的に使っているいくつかの型は、ユーザに公開されています。これらの定義は将来のインタプリタのバージョンでは変更される可能性がありますが、ここでは記述の完全性のために触れておきます。"

#: ../../reference/datamodel.rst:960
msgid "Code objects"
msgstr "コードオブジェクト"

#: ../../reference/datamodel.rst:892
msgid ""
"Code objects represent *byte-compiled* executable Python code, or "
":term:`bytecode`. The difference between a code object and a function object"
" is that the function object contains an explicit reference to the "
"function's globals (the module in which it was defined), while a code object"
" contains no context; also the default argument values are stored in the "
"function object, not in the code object (because they represent values "
"calculated at run-time).  Unlike function objects, code objects are "
"immutable and contain no references (directly or indirectly) to mutable "
"objects."
msgstr ""
"コードオブジェクトは *バイトコンパイルされた (byte-compiled)* 実行可能な Python コード、別名 :term:`バイトコード "
"<bytecode>` を表現します。コードオブジェクトと関数オブジェクトの違いは、関数オブジェクトが関数のグローバル変数 "
"(関数を定義しているモジュールのグローバル) に対して明示的な参照を持っているのに対し、コードオブジェクトにはコンテキストがないということです; "
"また、関数オブジェクトではデフォルト引数値を記憶できますが、コードオブジェクトではできません "
"(実行時に計算される値を表現するため)。関数オブジェクトと違い、コードオブジェクトは変更不可能で、変更可能なオブジェクトへの参照を "
"(直接、間接に関わらず) 含みません。"

#: ../../reference/datamodel.rst:919
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; "
":attr:`co_argcount` is the total number of positional arguments (including "
"positional-only arguments and arguments with default values); "
":attr:`co_posonlyargcount` is the number of positional-only arguments "
"(including arguments with default values); :attr:`co_kwonlyargcount` is the "
"number of keyword-only arguments (including arguments with default values); "
":attr:`co_nlocals` is the number of local variables used by the function "
"(including arguments); :attr:`co_varnames` is a tuple containing the names "
"of the local variables (starting with the argument names); "
":attr:`co_cellvars` is a tuple containing the names of local variables that "
"are referenced by nested functions; :attr:`co_freevars` is a tuple "
"containing the names of free variables; :attr:`co_code` is a string "
"representing the sequence of bytecode instructions; :attr:`co_consts` is a "
"tuple containing the literals used by the bytecode; :attr:`co_names` is a "
"tuple containing the names used by the bytecode; :attr:`co_filename` is the "
"filename from which the code was compiled; :attr:`co_firstlineno` is the "
"first line number of the function; :attr:`co_lnotab` is a string encoding "
"the mapping from bytecode offsets to line numbers (for details see the "
"source code of the interpreter); :attr:`co_stacksize` is the required stack "
"size; :attr:`co_flags` is an integer encoding a number of flags for the "
"interpreter."
msgstr ""

#: ../../reference/datamodel.rst:943
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is "
"set if the function uses the ``*arguments`` syntax to accept an arbitrary "
"number of positional arguments; bit ``0x08`` is set if the function uses the"
" ``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` "
"is set if the function is a generator."
msgstr ""
"以下のフラグビットが :attr:`co_flags` で定義されています: ``0x04`` ビットは、関数が ``*arguments`` "
"構文を使って任意の数の位置引数を受理できる場合に立てられます; ``0x08`` ビットは、関数が ``**keywords`` "
"構文を使ってキーワード引数を受理できる場合に立てられます; ``0x20`` ビットは、関数がジェネレータである場合に立てられます。"

#: ../../reference/datamodel.rst:949
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`co_flags` to indicate whether a code object was compiled with"
" a particular feature enabled: bit ``0x2000`` is set if the function was "
"compiled with future division enabled; bits ``0x10`` and ``0x1000`` were "
"used in earlier versions of Python."
msgstr ""
"将来機能 (future feature) 宣言 (``from __future__ import division``) もまた、 "
":attr:`co_flags` のビットを立てることで、コードオブジェクトが特定の機能を有効にしてコンパイルされていることを示します: "
"``0x2000`` ビットは、関数が将来機能を有効にしてコンパイルされている場合に立てられます; 以前のバージョンの Python では、 "
"``0x10`` および ``0x1000`` ビットが使われていました。"

#: ../../reference/datamodel.rst:955
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ":attr:`co_flags` のその他のビットは将来に内部的に利用するために予約されています。"

#: ../../reference/datamodel.rst:959
msgid ""
"If a code object represents a function, the first item in :attr:`co_consts` "
"is the documentation string of the function, or ``None`` if undefined."
msgstr ""
"コードオブジェクトが関数を表現している場合、 :attr:`co_consts` "
"の最初の要素は関数のドキュメンテーション文字列になります。ドキュメンテーション文字列が定義されていない場合には ``None`` になります。"

#: ../../reference/datamodel.rst:1019
msgid "Frame objects"
msgstr "フレーム (frame) オブジェクト"

#: ../../reference/datamodel.rst:967
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below), and are also passed to registered trace functions."
msgstr ""
"フレームオブジェクトは実行フレーム (execution frame) を表します。\n"
"実行フレームはトレースバックオブジェクト (下記参照) 内に出現し、登録されたトレース関数に渡されます。"

#: ../../reference/datamodel.rst:978
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack frame "
"(towards the caller), or ``None`` if this is the bottom stack frame; "
":attr:`f_code` is the code object being executed in this frame; "
":attr:`f_locals` is the dictionary used to look up local variables; "
":attr:`f_globals` is used for global variables; :attr:`f_builtins` is used "
"for built-in (intrinsic) names; :attr:`f_lasti` gives the precise "
"instruction (this is an index into the bytecode string of the code object)."
msgstr ""
"読み出し専用の特殊属性: :attr:`f_back` は直前のスタックフレーム (呼び出し側の方向) で、それがスタックフレームの最下段なら "
"``None`` です; :attr:`f_code` はそのフレームで実行されているコードオブジェクトです; :attr:`f_locals` "
"はローカル変数の探索に使われる辞書です; :attr:`f_globals` はグローバル変数に使われます; :attr:`f_builtins` "
"は組み込みの (Python 固有の) 名前に使われます; :attr:`f_lasti` は厳密な命令コード "
"(コードオブジェクトのバイトコード文字列へのインデックス) です。"

#: ../../reference/datamodel.rst:992
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a function"
" called for various events during code execution (this is used by the "
"debugger). Normally an event is triggered for each new source line - this "
"can be disabled by setting :attr:`f_trace_lines` to :const:`False`."
msgstr ""
"特別な書き込み可能な属性: :attr:`f_trace` は ``None`` でない場合は、コードの実行中に様々なイベントで呼び出される関数です (デバッガが利用します)。\n"
"通常は、ソースの新しい行ごとにイベントが発行されますが、 :attr:`f_trace_lines` を :const:`False` に設定することでイベントの発行を無効化できます。"

#: ../../reference/datamodel.rst:997
msgid ""
"Implementations *may* allow per-opcode events to be requested by setting "
":attr:`f_trace_opcodes` to :const:`True`. Note that this may lead to "
"undefined interpreter behaviour if exceptions raised by the trace function "
"escape to the function being traced."
msgstr ""
"実装は :attr:`f_trace_opcodes` を :const:`True` に設定して、命令コードごとのイベントの要求を許可している *かもしれません* 。\n"
"これは、トレース関数によって送出された例外がトレースされている関数に漏れ出た場合、未定義なインタープリタの振る舞いにつながるかもしれないことに注意してください。"

#: ../../reference/datamodel.rst:1002
msgid ""
":attr:`f_lineno` is the current line number of the frame --- writing to this"
" from within a trace function jumps to the given line (only for the bottom-"
"most frame).  A debugger can implement a Jump command (aka Set Next "
"Statement) by writing to f_lineno."
msgstr ""
":attr:`f_lineno` はフレーム中における現在の行番号です --- トレース関数 (trace function) "
"側でこの値に書き込みを行うと、指定した行にジャンプします (最下段の実行フレームにいるときのみ)。デバッガでは、 f_fileno "
"を書き込むことで、ジャンプ命令 (Set Next Statement 命令とも) を実装できます。"

#: ../../reference/datamodel.rst:1007
msgid "Frame objects support one method:"
msgstr "フレームオブジェクトはメソッドを一つサポートします:"

#: ../../reference/datamodel.rst:1011
msgid ""
"This method clears all references to local variables held by the frame.  "
"Also, if the frame belonged to a generator, the generator is finalized.  "
"This helps break reference cycles involving frame objects (for example when "
"catching an exception and storing its traceback for later use)."
msgstr ""
"このメソッドはフレームが保持しているローカル変数への参照を全て削除します。\n"
"また、フレームがジェネレータに属していた場合は、ジェネレータにも終了処理が行われます。\n"
"これによってフレームオブジェクトを含んだ循環参照が解消されるようになります (例えば、例外を捕捉し、後で使うためにトレースバックを保存する場合)。"

#: ../../reference/datamodel.rst:1017
msgid ":exc:`RuntimeError` is raised if the frame is currently executing."
msgstr "フレームが現在実行中の場合 :exc:`RuntimeError` が送出されます。"

#: ../../reference/datamodel.rst:1079
msgid "Traceback objects"
msgstr "トレースバック (traceback) オブジェクト"

#: ../../reference/datamodel.rst:1034
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is implicitly created when an exception occurs, and may also be "
"explicitly created by calling :class:`types.TracebackType`."
msgstr ""
"トレースバックオブジェクトは例外のスタックトレースを表現します。\n"
"トレースバックオブジェクトは例外が起きたときに暗黙的に作成されたり、 :class:`types.TracebackType` を呼び出して明示的にも作成されたりします。"

#: ../../reference/datamodel.rst:1038
msgid ""
"For implicitly created tracebacks, when the search for an exception handler "
"unwinds the execution stack, at each unwound level a traceback object is "
"inserted in front of the current traceback.  When an exception handler is "
"entered, the stack trace is made available to the program. (See section "
":ref:`try`.) It is accessible as the third item of the tuple returned by "
"``sys.exc_info()``, and as the ``__traceback__`` attribute of the caught "
"exception."
msgstr ""
"暗黙的に作成されたトレースバックでは、例外ハンドラの検索が実行スタックを戻っていく際、戻ったレベル毎に、トレースバックオブジェクトが現在のトレースバックの前に挿入されます。\n"
"例外ハンドラに入ると、スタックトレースをプログラム側で利用できるようになります。(:ref:`try` を参照。)\n"
"トレースバックは、 ``sys.exc_info()`` が返すタプルの三番目の要素や、捕捉した例外の ``__traceback__`` 属性として得られます。"

#: ../../reference/datamodel.rst:1046
msgid ""
"When the program contains no suitable handler, the stack trace is written "
"(nicely formatted) to the standard error stream; if the interpreter is "
"interactive, it is also made available to the user as "
"``sys.last_traceback``."
msgstr ""
"プログラムに適切なハンドラがないとき、スタックトレースは (うまく書式化されて) 標準エラーストリームに書き出されます; "
"インタプリタが対話的に実行されている場合、 ``sys.last_traceback`` として得ることもできます。"

#: ../../reference/datamodel.rst:1051
msgid ""
"For explicitly created tracebacks, it is up to the creator of the traceback "
"to determine how the ``tb_next`` attributes should be linked to form a full "
"stack trace."
msgstr ""
"明示的に作成されたトレースバックでは、 ``tb_next`` "
"属性がリンクされスタックトレース全体を形成する方法の決定は、トレースバックの作成者に任されます。"

#: ../../reference/datamodel.rst:1061
msgid ""
"Special read-only attributes: :attr:`tb_frame` points to the execution frame"
" of the current level; :attr:`tb_lineno` gives the line number where the "
"exception occurred; :attr:`tb_lasti` indicates the precise instruction. The "
"line number and last instruction in the traceback may differ from the line "
"number of its frame object if the exception occurred in a :keyword:`try` "
"statement with no matching except clause or with a finally clause."
msgstr ""
"読み出し専用の特殊属性: :attr:`tb_frame` は現在のレベルにおける実行フレームを指します; :attr:`tb_lineno` "
"は例外の発生した行番号です; :attr:`tb_lasti` は厳密な命令コードです。トレースバック内の行番号や最後に実行された命令は、 "
":keyword:`try` 文内で例外が発生し、かつ対応する :keyword:`except` 節や :keyword:`finally` "
"節がない場合には、フレームオブジェクト内の行番号とは異なるかもしれません。"

#: ../../reference/datamodel.rst:1073
msgid ""
"Special writable attribute: :attr:`tb_next` is the next level in the stack "
"trace (towards the frame where the exception occurred), or ``None`` if there"
" is no next level."
msgstr ""
"書き込み可能な特殊属性: :attr:`tb_next` はスタックトレースの次のレベル (例外が発生したフレームの方向) "
"か、あるいは次のレベルが無い場合は ``None`` です。"

#: ../../reference/datamodel.rst:1077
msgid ""
"Traceback objects can now be explicitly instantiated from Python code, and "
"the ``tb_next`` attribute of existing instances can be updated."
msgstr ""
"トレースバックオブジェクトは Python コードから明示的にインスタンス化できるようになり、既存のインスタンスの ``tb_next`` "
"属性は更新できるようになりました。"

#: ../../reference/datamodel.rst:1105
msgid "Slice objects"
msgstr "スライス (slice) オブジェクト"

#: ../../reference/datamodel.rst:1084
msgid ""
"Slice objects are used to represent slices for :meth:`__getitem__` methods."
"  They are also created by the built-in :func:`slice` function."
msgstr ""
"スライスオブジェクトは、 :meth:`__getitem__` メソッドのためのスライスを表すのに使われます。スライスオブジェクトは組み込みの "
":func:`slice` 関数でも生成されます。"

#: ../../reference/datamodel.rst:1092
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; "
":attr:`~slice.stop` is the upper bound; :attr:`~slice.step` is the step "
"value; each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"読み出し専用の特殊属性: :attr:`~slice.start` は下限です; :attr:`~slice.stop` は上限です; "
":attr:`~slice.step` はステップの値です; それぞれ省略された場合は ``None`` "
"となっています。これらの属性は任意の型を持てます。"

#: ../../reference/datamodel.rst:1096
msgid "Slice objects support one method:"
msgstr "スライスオブジェクトはメソッドを一つサポートします:"

#: ../../reference/datamodel.rst:1100
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if applied "
"to a sequence of *length* items.  It returns a tuple of three integers; "
"respectively these are the *start* and *stop* indices and the *step* or "
"stride length of the slice. Missing or out-of-bounds indices are handled in "
"a manner consistent with regular slices."
msgstr ""
"このメソッドは単一の整数引数 *length* を取り、スライスオブジェクトが *length* "
"要素のシーケンスに適用されたときに表現する、スライスに関する情報を計算します。このメソッドは 3 つの整数からなるタプルを返します; それぞれ "
"*start* および *stop* のインデックスと、*step* "
"すなわちスライスのまたぎ幅です。インデックス値がないか、範囲外の値であれば、通常のスライスと変わらないやりかたで扱われます。"

#: ../../reference/datamodel.rst:1115
msgid "Static method objects"
msgstr "静的メソッド (static method) オブジェクト"

#: ../../reference/datamodel.rst:1108
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are not themselves "
"callable, although the objects they wrap usually are. Static method objects "
"are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"静的メソッドは、上で説明したような関数オブジェクトからメソッドオブジェクトへの変換を阻止するための方法を提供します。静的メソッドオブジェクトは他の何らかのオブジェクト、通常はユーザ定義メソッドオブジェクトを包むラッパです。静的メソッドをクラスやクラスインスタンスから取得すると、実際に返されるオブジェクトはラップされたオブジェクトになり、それ以上は変換の対象にはなりません。静的メソッドオブジェクトは通常呼び出し可能なオブジェクトをラップしますが、静的オブジェクト自体は呼び出すことができません。静的オブジェクトは組み込みコンストラクタ"
" :func:`staticmethod` で生成されます。"

#: ../../reference/datamodel.rst:1123
msgid "Class method objects"
msgstr "クラスメソッドオブジェクト"

#: ../../reference/datamodel.rst:1118
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such"
" retrieval is described above, under \"User-defined methods\". Class method "
"objects are created by the built-in :func:`classmethod` constructor."
msgstr ""
"クラスメソッドオブジェクトは、静的メソッドオブジェクトに似て、別のオブジェクトを包むラッパであり、そのオブジェクトをクラスやクラスインスタンスから取り出す方法を代替します。このようにして取得したクラスメソッドオブジェクトの動作については、上の"
" \"ユーザ定義メソッド (user-defined method)\" で説明されています。クラスメソッドオブジェクトは組み込みのコンストラクタ "
":func:`classmethod` で生成されます。"

#: ../../reference/datamodel.rst:1128
msgid "Special method names"
msgstr "特殊メソッド名"

#: ../../reference/datamodel.rst:1134
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named "
":meth:`__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` "
"is roughly equivalent to ``type(x).__getitem__(x, i)``.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or "
":exc:`TypeError`)."
msgstr ""
"クラスは、特殊な名前のメソッドを定義して、特殊な構文 (算術演算や添え字表記、スライス表記など) による特定の演算を実装できます。これは、Python "
"の演算子オーバロード (:dfn:`operator overloading`) "
"へのアプローチです。これにより、クラスは言語の演算子に対する独自の振る舞いを定義できます。例えば、あるクラスが :meth:`__getitem__` "
"という名前のメソッドを定義しており、 ``x`` がこのクラスのインスタンスであるとすると、 ``x[i]`` は "
"``type(x).__getitem__(x, i)`` "
"とほぼ等価です。特に注釈のない限り、適切なメソッドが定義されていないとき、このような演算を試みると例外 (たいていは "
":exc:`AttributeError` か :exc:`TypeError`) が送出されます。"

#: ../../reference/datamodel.rst:1144
msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets :meth:`__iter__` "
"to ``None``, the class is not iterable, so calling :func:`iter` on its "
"instances will raise a :exc:`TypeError` (without falling back to "
":meth:`__getitem__`). [#]_"
msgstr ""
"特殊メソッドに ``None`` を設定することは、それに対応する演算が利用できないことを意味します。\n"
"例えば、クラスの :meth:`__iter__` を ``None`` に設定した場合、そのクラスはイテラブルにはならず、そのインスタンスに対し :func:`iter` を呼び出すと (:meth:`__getitem__` に処理が戻されずに) :exc:`TypeError` を送出します。 [#]_"

#: ../../reference/datamodel.rst:1150
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for"
" the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make sense."
"  (One example of this is the :class:`~xml.dom.NodeList` interface in the "
"W3C's Document Object Model.)"
msgstr ""
"組み込み型をエミュレートするクラスを実装するときは、模範とされるオブジェクトにとって意味がある範囲に実装をとどめるのが重要です。例えば、あるシーケンスは個々の要素の取得はきちんと動くかもしれませんが、スライスの展開が意味をなさないかもしれません。"
" (W3C のドキュメントオブジェクトモデルにある :class:`~xml.dom.NodeList` インターフェースがその一例です。)"

#: ../../reference/datamodel.rst:1161
msgid "Basic customization"
msgstr "基本的なカスタマイズ"

#: ../../reference/datamodel.rst:1167
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static"
" method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""
"クラス *cls* の新しいインスタンスを作るために呼び出されます。 :meth:`__new__` は静的メソッドで "
"(このメソッドは特別扱いされているので、明示的に静的メソッドと宣言する必要はありません)、インスタンスを生成するよう要求されているクラスを第一引数にとります。残りの引数はオブジェクトのコンストラクタの式"
" (クラスの呼び出し文) に渡されます。 :meth:`__new__` の戻り値は新しいオブジェクトのインスタンス (通常は *cls* "
"のインスタンス) でなければなりません。"

#: ../../reference/datamodel.rst:1174
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super().__new__(cls[, ...])`` "
"with appropriate arguments and then modifying the newly-created instance as "
"necessary before returning it."
msgstr ""
"典型的な実装では、クラスの新たなインスタンスを生成するときには ``super().__new__(cls[, ...])`` "
"に適切な引数を指定してスーパクラスの :meth:`__new__` メソッドを呼び出し、新たに生成されたインスタンスに必要な変更を加えてから返します。"

#: ../../reference/datamodel.rst:1179
msgid ""
"If :meth:`__new__` is invoked during object construction and it returns an "
"instance or subclass of *cls*, then the new instance’s :meth:`__init__` "
"method will be invoked like ``__init__(self[, ...])``, where *self* is the "
"new instance and the remaining arguments are the same as were passed to the "
"object constructor."
msgstr ""

#: ../../reference/datamodel.rst:1184
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
":meth:`__new__` が *cls* のインスタンスを返さない場合、インスタンスの :meth:`__init__` "
"メソッドは呼び出されません。"

#: ../../reference/datamodel.rst:1187
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` の主な目的は、変更不能な型 (int, str, tuple など) "
"のサブクラスでインスタンス生成をカスタマイズすることにあります。また、クラス生成をカスタマイズするために、カスタムのメタクラスでよくオーバーライドされます。"

#: ../../reference/datamodel.rst:1196
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the"
" derived class's :meth:`__init__` method, if any, must explicitly call it to"
" ensure proper initialization of the base class part of the instance; for "
"example: ``super().__init__([args...])``."
msgstr ""
"インスタンスが (:meth:`__new__` によって) "
"生成された後、それが呼び出し元に返される前に呼び出されます。引数はクラスのコンストラクタ式に渡したものです。基底クラスとその派生クラスがともに "
":meth:`__init__` メソッドを持つ場合、派生クラスの :meth:`__init__` メソッドは基底クラスの "
":meth:`__init__` メソッドを明示的に呼び出して、インスタンスの基底クラス部分が適切に初期化されること保証しなければなりません。例えば、 "
"``super().__init__([args...])`` 。"

#: ../../reference/datamodel.rst:1203
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customize "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""
":meth:`__new__` と :meth:`__init__` は連携してオブジェクトを構成する (:meth:`__new__` が作成し、 "
":meth:`__init__` がそれをカスタマイズする) ので、 :meth:`__init__` から非 ``None`` "
"値を返してはいけません; そうしてしまうと、実行時に :exc:`TypeError` が送出されてしまいます。"

#: ../../reference/datamodel.rst:1216
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"finalizer or (improperly) a destructor.  If a base class has a "
":meth:`__del__` method, the derived class's :meth:`__del__` method, if any, "
"must explicitly call it to ensure proper deletion of the base class part of "
"the instance."
msgstr ""
"インスタンスが破棄されるときに呼び出されます。\n"
"これはファイナライザや (適切ではありませんが) デストラクタとも呼ばれます。\n"
"基底クラスが :meth:`__del__` メソッドを持っている場合は、派生クラスの :meth:`__del__` メソッドは何であれ、基底クラスの :meth:`__del__`  メソッドを明示的に呼び出して、インスタンスの基底クラス部分をきちんと確実に削除しなければなりません。"

#: ../../reference/datamodel.rst:1222
msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  "
"This is called object *resurrection*.  It is implementation-dependent "
"whether :meth:`__del__` is called a second time when a resurrected object is"
" about to be destroyed; the current :term:`CPython` implementation only "
"calls it once."
msgstr ""
":meth:`__del__` メソッドが破棄しようとしているインスタンスへの新しい参照を作り、破棄を送らせることは (推奨されないものの) 可能です。\n"
"これはオブジェクトの *復活* と呼ばれます。\n"
"復活したオブジェクトが再度破棄される直前に :meth:`__del__` が呼び出されるかどうかは実装依存です;\n"
"現在の :term:`CPython` の実装では最初の一回しか呼び出されません。"

#: ../../reference/datamodel.rst:1229
msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits."
msgstr "インタプリタが終了したときに、残存しているオブジェクトの :meth:`__del__` メソッドが呼び出される保証はありません。"

#: ../../reference/datamodel.rst:1234
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero."
msgstr ""
"``del x`` は直接 ``x.__del__()`` を呼び出しません --- 前者は ``x`` の参照カウントを 1 つ減らし、後者は "
"``x`` の参照カウントが 0 まで落ちたときのみ呼び出されます。"

#: ../../reference/datamodel.rst:1249
msgid "Documentation for the :mod:`gc` module."
msgstr ":mod:`gc` モジュールのドキュメント。"

#: ../../reference/datamodel.rst:1253
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""
"メソッド :meth:`__del__` は不安定な状況で呼び出されるため、実行中に発生した例外は無視され、代わりに ``sys.stderr`` "
"に警告が表示されます。特に:"

#: ../../reference/datamodel.rst:1257
msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the resource "
"may already be taken by the code that gets interrupted to execute "
":meth:`__del__`."
msgstr ""
":meth:`__del__` は、任意のコードが実行されているときに、任意のスレッドから呼び出せます。\n"
":meth:`__del__` で、ロックを取ったり、ブロックするリソースを呼び出したりする必要がある場合、 :meth:`__del__` の実行により中断されたコードにより、そのリソースが既に取得されていて、デッドロックが起きるかもしれません。"

#: ../../reference/datamodel.rst:1263
msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python guarantees"
" that globals whose name begins with a single underscore are deleted from "
"their module before other globals are deleted; if no other references to "
"such globals exist, this may help in assuring that imported modules are "
"still available at the time when the :meth:`__del__` method is called."
msgstr ""
":meth:`__del__` は、インタプリタのシャットダウン中に実行できます。\n"
"従って、(他のモジュールも含めた) アクセスする必要があるグローバル変数はすでに削除されているか、 ``None`` に設定されているかもしれません。\n"
"Python は、単一のアンダースコアで始まる名前のグローバルオブジェクトは、他のグローバル変数が削除される前にモジュールから削除されることを保証します; そのようなグローバル変数への他からの参照が存在しない場合、:meth:`__del__` メソッドが呼ばれた時点で、インポートされたモジュールがまだ利用可能であることを保証するのに役立つかもしれません。"

#: ../../reference/datamodel.rst:1278
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look "
"like a valid Python expression that could be used to recreate an object with"
" the same value (given an appropriate environment).  If this is not "
"possible, a string of the form ``<...some useful description...>`` should be"
" returned. The return value must be a string object. If a class defines "
":meth:`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used"
" when an \"informal\" string representation of instances of that class is "
"required."
msgstr ""
":func:`repr` 組み込み関数によって呼び出され、オブジェクトを表す「公式の (official)」文字列を計算します。可能なら、これは "
"(適切な環境が与えられれば) 同じ値のオブジェクトを再生成するのに使える、有効な Python 式のようなものであるべきです。できないなら、 "
"``<...some useful description...>`` "
"形式の文字列が返されるべきです。戻り値は文字列オブジェクトでなければなりません。クラスが :meth:`__repr__` を定義していて "
":meth:`__str__` は定義していなければ、そのクラスのインスタンスの「非公式の (informal)」文字列表現が要求されたときにも "
":meth:`__repr__` が使われます。"

#: ../../reference/datamodel.rst:1287
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr "この関数はデバッグの際によく用いられるので、たくさんの情報を含み、あいまいでないような表記にすることが重要です。"

#: ../../reference/datamodel.rst:1298
msgid ""
"Called by :func:`str(object) <str>` and the built-in functions "
":func:`format` and :func:`print` to compute the \"informal\" or nicely "
"printable string representation of an object.  The return value must be a "
":ref:`string <textseq>` object."
msgstr ""
"オブジェクトの「非公式の (informal)」あるいは表示に適した文字列表現を計算するために、 :func:`str(object) <str>` "
"と組み込み関数 :func:`format`, :func:`print` によって呼ばれます。戻り値は :ref:`string <textseq>`"
" オブジェクトでなければなりません。"

#: ../../reference/datamodel.rst:1303
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more "
"convenient or concise representation can be used."
msgstr ""
":meth:`__str__` が有効な Python 表現を返すことが期待されないという点で、このメソッドは "
":meth:`object.__repr__` とは異なります: より便利な、または簡潔な表現を使用することができます。"

#: ../../reference/datamodel.rst:1307
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""
"組み込み型 :class:`object` によって定義されたデフォルト実装は、 :meth:`object.__repr__` を呼び出します。"

#: ../../reference/datamodel.rst:1317
msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string representation "
"of an object. This should return a :class:`bytes` object."
msgstr ""
":ref:`bytes <func-bytes>` によって呼び出され、オブジェクトのバイト文字列表現を計算します。これは :class:`bytes`"
" オブジェクトを返すべきです。"

#: ../../reference/datamodel.rst:1328
msgid ""
"Called by the :func:`format` built-in function, and by extension, evaluation"
" of :ref:`formatted string literals <f-strings>` and the :meth:`str.format` "
"method, to produce a \"formatted\" string representation of an object. The "
"*format_spec* argument is a string that contains a description of the "
"formatting options desired. The interpretation of the *format_spec* argument"
" is up to the type implementing :meth:`__format__`, however most classes "
"will either delegate formatting to one of the built-in types, or use a "
"similar formatting option syntax."
msgstr ""
":func:`format` 組み込み関数、さらには :ref:`フォーマット済み文字列リテラル <f-strings>` の評価、 "
":meth:`str.format` メソッドによって呼び出され、オブジェクトの \"フォーマット化された (formatted)\" "
"文字列表現を作ります。 *format_spec* 引数は、 必要なフォーマット化オプションの記述を含む文字列です。 *format_spec* "
"引数の解釈は、 :meth:`__format__` を実装する型によりますが、 ほとんどのクラスは組み込み型のいずれかにフォーマット化を委譲したり、 "
"同じようなフォーマット化オプション構文を使います。"

#: ../../reference/datamodel.rst:1338
msgid ""
"See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr "標準のフォーマット構文の解説は、 :ref:`formatspec` を参照してください。"

#: ../../reference/datamodel.rst:1340
msgid "The return value must be a string object."
msgstr "戻り値は文字列オブジェクトでなければなりません。"

#: ../../reference/datamodel.rst:1342
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""
"空でない文字列が渡された場合 ``object`` 自身の __format__ メソッドは :exc:`TypeError` を送出します。"

#: ../../reference/datamodel.rst:1346
msgid ""
"``object.__format__(x, '')`` is now equivalent to ``str(x)`` rather than "
"``format(str(self), '')``."
msgstr ""
"``object.__format__(x, '')`` は ``format(str(self), '')`` ではなく ``str(x)`` "
"と等価になりました。"

#: ../../reference/datamodel.rst:1362
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls "
"``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls "
"``x.__eq__(y)``, ``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls "
"``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr ""
"これらはいわゆる \"拡張比較 (rich comparison)\" メソッドです。演算子シンボルとメソッド名の対応は以下の通りです: ``x<y``"
" は ``x.__lt__(y)`` を呼び出します; ``x<=y`` は ``x.__le__(y)`` を呼び出します; ``x==y`` は "
"``x.__eq__(y)`` を呼び出します; ``x!=y`` は ``x.__ne__(y)`` を呼び出します; ``x>y`` は "
"``x.__gt__(y)`` を呼び出します; ``x>=y`` は ``x.__ge__(y)`` を呼び出します。"

#: ../../reference/datamodel.rst:1368
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if it "
"does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison."
" However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""
"拡張比較メソッドは与えられた引数のペアに対する演算を実装していないときに、 シングルトン ``NotImplemented`` を返すかもしれません。\n"
"慣例として、正常に比較が行われたときには ``False`` か ``True`` を返します。\n"
"しかし、これらのメソッドは任意の値を返すことができるので、比較演算子がブール値のコンテキスト (たとえば ``if`` 文の条件部分) で使われた場合、 Python はその値に対して :func:`bool` を呼び出して結果の真偽を判断します。"

#: ../../reference/datamodel.rst:1375
msgid ""
"By default, :meth:`__ne__` delegates to :meth:`__eq__` and inverts the "
"result unless it is ``NotImplemented``.  There are no other implied "
"relationships among the comparison operators, for example, the truth of "
"``(x<y or x==y)`` does not imply ``x<=y``. To automatically generate "
"ordering operations from a single root operation, see "
":func:`functools.total_ordering`."
msgstr ""
"デフォルトでは :meth:`__ne__` は ``NotImplemented`` でない限り :meth:`__eq__` "
"に委譲して結果を反転させます。比較演算の間には他に暗黙の関係はありません。例えば ``(x<y or x==y)`` が真であることは暗黙的に "
"``x<=y`` ではありません。元となる一つの演算から自動的に順序の演算を生成するには "
":func:`functools.total_ordering` を参照してください。"

#: ../../reference/datamodel.rst:1382
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on creating "
":term:`hashable` objects which support custom comparison operations and are "
"usable as dictionary keys."
msgstr ""
"カスタムの比較演算をサポートしていて、辞書のキーに使うことができる :term:`ハッシュ可能 <hashable>` "
"オブジェクトを作るときの重要な注意点について、 :meth:`__hash__` のドキュメント内に書かれているので参照してください。"

#: ../../reference/datamodel.rst:1386
msgid ""
"There are no swapped-argument versions of these methods (to be used when the"
" left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, "
":meth:`__le__` and :meth:`__ge__` are each other's reflection, and "
":meth:`__eq__` and :meth:`__ne__` are their own reflection. If the operands "
"are of different types, and right operand's type is a direct or indirect "
"subclass of the left operand's type, the reflected method of the right "
"operand has priority, otherwise the left operand's method has priority.  "
"Virtual subclassing is not considered."
msgstr ""
"これらのメソッドには (左引数が演算をサポートしないが、右引数はサポートする場合に用いられるような) 引数を入れ替えたバージョンは存在しません。\n"
"むしろ、 :meth:`__lt__` と :meth:`__gt__` は互いの反射、 :meth:`__le__` と :meth:`__ge__` は互いの反射、および :meth:`__eq__` と :meth:`__ne__` はそれら自身の反射です。\n"
"被演算子が異なる型で右の被演算子の型が左の被演算子の直接的または間接的サブクラスの場合、右被演算子の反射されたメソッドが優先されます。\n"
"そうでない場合左の被演算子のメソッドが優先されます。\n"
"仮想サブクラス化は考慮されません。"

#: ../../reference/datamodel.rst:1403
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and "
":class:`dict`.  :meth:`__hash__` should return an integer. The only required"
" property is that objects which compare equal have the same hash value; it "
"is advised to mix together the hash values of the components of the object "
"that also play a part in comparison of objects by packing them into a tuple "
"and hashing the tuple. Example::"
msgstr ""
"組み込みの :func:`hash` 関数や、 :class:`set`, :class:`frozenset`, :class:`dict` のようなハッシュを使ったコレクション型の要素に対する操作から呼び出されます。\n"
":meth:`__hash__` は整数を返さなければなりません。\n"
"このメソッドに必要な性質は、比較結果が等しいオブジェクトは同じハッシュ値を持つということです;\n"
"オブジェクトを比較するときでも利用される要素をタプルに詰めてハッシュ値を計算することで、それぞれの要素のハッシュ値を混合することをおすすめします。"

#: ../../reference/datamodel.rst:1416
msgid ""
":func:`hash` truncates the value returned from an object's custom "
":meth:`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is "
"typically 8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an "
"object's   :meth:`__hash__` must interoperate on builds of different bit "
"sizes, be sure to check the width on all supported builds.  An easy way to "
"do this is with ``python -c \"import sys; print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` はオブジェクト独自の :meth:`__hash__`  メソッドが返す値を :c:type:`Py_ssize_t` のサイズに切り詰めます。\n"
"これは 64-bit でビルドされていると 8 バイトで、 32-bit でビルドされていると 4 バイトです。\n"
"オブジェクトの :meth:`__hash__` が異なる bit サイズのビルドでも可搬性が必要である場合は、必ず全てのサポートするビルドの bit 幅をチェックしてください。\n"
"そうする簡単な方法は ``python -c \"import sys; print(sys.hash_info.width)\"`` を実行することです。"

#: ../../reference/datamodel.rst:1424
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define a "
":meth:`__hash__` operation either; if it defines :meth:`__eq__` but not "
":meth:`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an "
":meth:`__eq__` method, it should not implement :meth:`__hash__`, since the "
"implementation of hashable collections requires that a key's hash value is "
"immutable (if the object's hash value changes, it will be in the wrong hash "
"bucket)."
msgstr ""
"クラスが :meth:`__eq__` メソッドを定義していないなら、 :meth:`__hash__` メソッドも定義してはなりません; クラスが "
":meth:`__eq__` を定義していても :meth:`__hash__` "
"を定義していないなら、そのインスタンスはハッシュ可能コレクションの要素として使えません。クラスがミュータブルなオブジェクトを定義しており、 "
":meth:`__eq__` メソッドを実装しているなら、 :meth:`__hash__` "
"を定義してはなりません。これは、ハッシュ可能コレクションの実装においてキーのハッシュ値がイミュータブルであることが要求されているからです "
"(オブジェクトのハッシュ値が変化すると、誤ったハッシュバケツ: hash bucket に入ってしまいます)。"

#: ../../reference/datamodel.rst:1433
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) and"
" ``x.__hash__()`` returns an appropriate value such that ``x == y`` implies "
"both that ``x is y`` and ``hash(x) == hash(y)``."
msgstr ""
"ユーザー定義クラスはデフォルトで :meth:`__eq__` と :meth:`__hash__` メソッドを持っています。 このとき、(同一でない)"
" すべてのオブジェクトは比較して異なり、 ``x.__hash__()`` は ``x == y`` が ``x is y`` と ``hash(x) "
"== hash(y)`` の両方を意味するような適切な値を返します。"

#: ../../reference/datamodel.rst:1438
msgid ""
"A class that overrides :meth:`__eq__` and does not define :meth:`__hash__` "
"will have its :meth:`__hash__` implicitly set to ``None``.  When the "
":meth:`__hash__` method of a class is ``None``, instances of the class will "
"raise an appropriate :exc:`TypeError` when a program attempts to retrieve "
"their hash value, and will also be correctly identified as unhashable when "
"checking ``isinstance(obj, collections.abc.Hashable)``."
msgstr ""
":meth:`__eq__` をオーバーライドしていて :meth:`__hash__` を定義していないクラスでは、 :meth:`__hash__` は暗黙的に ``None`` に設定されます。\n"
"クラスの :meth:`__hash__` メソッドが ``None`` の場合、そのクラスのインスタンスのハッシュ値を取得しようとすると適切な :exc:`TypeError` が送出され、 ``isinstance(obj, collections.abc.Hashable)`` でチェックするとハッシュ不能なものとして正しく認識されます。"

#: ../../reference/datamodel.rst:1445
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the implementation "
"of :meth:`__hash__` from a parent class, the interpreter must be told this "
"explicitly by setting ``__hash__ = <ParentClass>.__hash__``."
msgstr ""
":meth:`__eq__` をオーバーライドしたクラスが親クラスからの :meth:`__hash__` の 実装を保持したいなら、明示的に "
"``__hash__ = <ParentClass>.__hash__`` を設定することで、それをインタプリタに伝えなければなりません。"

#: ../../reference/datamodel.rst:1449
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A "
"class which defines its own :meth:`__hash__` that explicitly raises a "
":exc:`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.abc.Hashable)`` call."
msgstr ""
":meth:`__eq__` をオーバーライドしていないクラスがハッシュサポートを抑制したい場合、クラス定義に ``__hash__ = None`` "
"を含めてください。クラス自身で明示的に :exc:`TypeError` を送出する :meth:`__hash__` を定義すると、 "
"``isinstance(obj, collections.abc.Hashable)`` 呼び出しで誤ってハッシュ可能と識別されるでしょう。"

#: ../../reference/datamodel.rst:1458
msgid ""
"By default, the :meth:`__hash__` values of str and bytes objects are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""

#: ../../reference/datamodel.rst:1463
msgid ""
"This is intended to provide protection against a denial-of-service caused by"
" carefully-chosen inputs that exploit the worst case performance of a dict "
"insertion, O(n^2) complexity.  See "
"http://www.ocert.org/advisories/ocert-2011-003.html for details."
msgstr ""
"この目的は、慎重に選ばれた入力で辞書挿入の最悪性能 O(n^2) 計算量を悪用することで引き起こされるサービス妨害 (denial-of-service, DoS) に対する保護です。\n"
"詳細は http://www.ocert.org/advisories/ocert-2011-003.html を参照してください。"

#: ../../reference/datamodel.rst:1468
msgid ""
"Changing hash values affects the iteration order of sets. Python has never "
"made guarantees about this ordering (and it typically varies between 32-bit "
"and 64-bit builds)."
msgstr ""
"ハッシュ値の変更は、集合のイテレーション順序に影響します。Python はこの順序付けを保証していません (そして通常 32-bit と 64-bit "
"の間でも異なります)。"

#: ../../reference/datamodel.rst:1472
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr ":envvar:`PYTHONHASHSEED` も参照してください。"

#: ../../reference/datamodel.rst:1474
msgid "Hash randomization is enabled by default."
msgstr "ハッシュのランダム化がデフォルトで有効になりました。"

#: ../../reference/datamodel.rst:1482
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not "
"defined, :meth:`__len__` is called, if it is defined, and the object is "
"considered true if its result is nonzero.  If a class defines neither "
":meth:`__len__` nor :meth:`__bool__`, all its instances are considered true."
msgstr ""
"真理値テストや組み込み演算 ``bool()`` を実装するために呼び出されます; ``False`` または ``True`` "
"を返さなければなりません。このメソッドが定義されていないとき、 :meth:`__len__` が定義されていれば呼び出され、その結果が非 0 "
"であれば真とみなされます。クラスが :meth:`__len__` も :meth:`__bool__` "
"も定義していないければ、そのクラスのインスタンスはすべて真とみなされます。"

#: ../../reference/datamodel.rst:1493
msgid "Customizing attribute access"
msgstr "属性値アクセスをカスタマイズする"

#: ../../reference/datamodel.rst:1495
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""
"以下のメソッドを定義して、クラスインスタンスへの属性値アクセス ( 属性値の使用、属性値への代入、 ``x.name`` の削除) "
"の意味をカスタマイズすることができます。"

#: ../../reference/datamodel.rst:1503
msgid ""
"Called when the default attribute access fails with an :exc:`AttributeError`"
" (either :meth:`__getattribute__` raises an :exc:`AttributeError` because "
"*name* is not an instance attribute or an attribute in the class tree for "
"``self``; or :meth:`__get__` of a *name* property raises "
":exc:`AttributeError`).  This method should either return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception."
msgstr ""
"デフォルトの属性アクセスが :exc:`AttributeError` で失敗したとき (*name* がインスタンスの属性または ``self`` のクラスツリーの属性でないために :meth:`__getattribute__` が :exc:`AttributeError` を送出したか、 *name* プロパティの :meth:`__get__` が :exc:`AttributeError` を送出したとき) に呼び出されます。\n"
"このメソッドは (計算された) 属性値を返すか、 :exc:`AttributeError` 例外を送出しなければなりません。"

#: ../../reference/datamodel.rst:1510
msgid ""
"Note that if the attribute is found through the normal mechanism, "
":meth:`__getattr__` is not called.  (This is an intentional asymmetry "
"between :meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can fake total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control over attribute access."
msgstr ""
"なお、通常の過程で属性が見つかれば、 :meth:`__getattr__` は呼び出されません。(これは、 :meth:`__getattr__`  "
"と :meth:`__setattr__` が意図的に非対称にされている点です。) これは、効率のためと、こうしないと "
":meth:`__getattr__` "
"がインスタンスの他の属性値にアクセスする方法がなくなるためです。また、少なくともインスタンス変数に対しては、値をインスタンスの属性値辞書に挿入しないことで"
" (代わりに他のオブジェクトに挿入することで)、属性値を完全に制御しているふりができます。実際に属性アクセスを完全に制御する方法は、以下の "
":meth:`__getattribute__` メソッドを参照してください。"

#: ../../reference/datamodel.rst:1523
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be"
" called unless :meth:`__getattribute__` either calls it explicitly or raises"
" an :exc:`AttributeError`. This method should return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception. In order to "
"avoid infinite recursion in this method, its implementation should always "
"call the base class method with the same name to access any attributes it "
"needs, for example, ``object.__getattribute__(self, name)``."
msgstr ""
"クラスのインスタンスに対する属性アクセスを実装するために、無条件に呼び出されます。クラスが :meth:`__getattr__` も定義している場合、"
" :meth:`__getattr__` は、 :meth:`__getattribute__` で明示的に呼び出すか、 "
":exc:`AttributeError` 例外を送出しない限り呼ばれません。このメソッドは (計算された) 属性値を返すか、 "
":exc:`AttributeError` "
"例外を送出します。このメソッドが再帰的に際限なく呼び出されてしまうのを防ぐため、実装の際には常に、必要な属性全てへのアクセスで、例えば "
"``object.__getattribute__(self, name)`` "
"のように基底クラスのメソッドを同じ属性名を使って呼び出さなければなりません。"

#: ../../reference/datamodel.rst:1534
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. See"
" :ref:`special-lookup`."
msgstr ""
"言語構文や組み込み関数から暗黙に呼び出された特殊メソッドの検索では、このメソッドも回避されることがあります。 :ref:`special-lookup`"
" を参照してください。"

#: ../../reference/datamodel.rst:1541
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of"
" the normal mechanism (i.e. store the value in the instance dictionary). "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""
"属性の代入が試みられた際に呼び出されます。これは通常の代入の過程 (すなわち、インスタンス辞書への値の代入) の代わりに呼び出されます。*name* "
"は属性名で、*value* はその属性に代入する値です。"

#: ../../reference/datamodel.rst:1545
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"call the base class method with the same name, for example, "
"``object.__setattr__(self, name, value)``."
msgstr ""
":meth:`__setattr__` "
"の中でインスタンス属性への代入が必要なら、基底クラスのこれと同じ名前のメソッドを呼び出さなければなりません。例えば、 "
"``object.__setattr__(self, name, value)`` とします。"

#: ../../reference/datamodel.rst:1552
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""
":meth:`__setattr__` に似ていますが、代入ではなく値の削除を行います。このメソッドを実装するのは、オブジェクトにとって ``del "
"obj.name`` が意味がある場合だけにしなければなりません。"

#: ../../reference/datamodel.rst:1558
msgid ""
"Called when :func:`dir` is called on the object. A sequence must be "
"returned. :func:`dir` converts the returned sequence to a list and sorts it."
msgstr ""
"オブジェクトに :func:`dir` が呼び出されたときに呼び出されます。シーケンスが返されなければなりません。 :func:`dir` "
"は返されたシーケンスをリストに変換し、ソートします。"

#: ../../reference/datamodel.rst:1563
msgid "Customizing module attribute access"
msgstr "モジュールの属性値アクセスをカスタマイズする"

#: ../../reference/datamodel.rst:1570
msgid ""
"Special names ``__getattr__`` and ``__dir__`` can be also used to customize "
"access to module attributes. The ``__getattr__`` function at the module "
"level should accept one argument which is the name of an attribute and "
"return the computed value or raise an :exc:`AttributeError`. If an attribute"
" is not found on a module object through the normal lookup, i.e. "
":meth:`object.__getattribute__`, then ``__getattr__`` is searched in the "
"module ``__dict__`` before raising an :exc:`AttributeError`. If found, it is"
" called with the attribute name and the result is returned."
msgstr ""
"特殊な名前の ``__getattr__`` と ``__dir__`` も、モジュール属性へのアクセスをカスタマイズするのに使えます。\n"
"モジュールレベルの ``__getattr__`` 関数は属性名である 1 引数を受け取り、計算した値を返すか :exc:`AttributeError` を送出します。\n"
"属性がモジュールオブジェクトから、通常の検索、つまり :meth:`object.__getattribute__` で見付からなかった場合は、 :exc:`AttributeError` を送出する前に、モジュールの ``__dict__`` から ``__getattr__`` が検索されます。\n"
"見付かった場合は、その属性名で呼び出され、結果が返されます。"

#: ../../reference/datamodel.rst:1579
msgid ""
"The ``__dir__`` function should accept no arguments, and return a sequence "
"of strings that represents the names accessible on module. If present, this "
"function overrides the standard :func:`dir` search on a module."
msgstr ""

#: ../../reference/datamodel.rst:1583
msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of a "
"module object to a subclass of :class:`types.ModuleType`. For example::"
msgstr ""
"より細かい粒度でのモジュールの動作 (属性やプロパティの設定など) のカスタマイズのために、モジュールオブジェクトの ``__class__`` 属性に :class:`types.ModuleType` のサブクラスが設定できます。\n"
"例えば次のようになります::"

#: ../../reference/datamodel.rst:1601
msgid ""
"Defining module ``__getattr__`` and setting module ``__class__`` only affect"
" lookups made using the attribute access syntax -- directly accessing the "
"module globals (whether by code within the module, or via a reference to the"
" module's globals dictionary) is unaffected."
msgstr ""
"モジュールの ``__getattr__`` を定義したり ``__class__`` "
"を設定したりしても、影響があるのは属性アクセスの構文が使われる検索だけです -- モジュールの globals への直接アクセスは "
"(モジュール内のコードからとモジュールの globals のどちらでも) 影響を受けません。"

#: ../../reference/datamodel.rst:1606
msgid "``__class__`` module attribute is now writable."
msgstr "モジュールの属性 ``__class__`` が書き込み可能になりました。"

#: ../../reference/datamodel.rst:1609
msgid "``__getattr__`` and ``__dir__`` module attributes."
msgstr "``__getattr__`` モジュール属性と ``__dir__`` モジュール属性。"

#: ../../reference/datamodel.rst:1614
msgid ":pep:`562` - Module __getattr__ and __dir__"
msgstr ":pep:`562` - モジュールの __getattr__ と __dir__"

#: ../../reference/datamodel.rst:1615
msgid "Describes the ``__getattr__`` and ``__dir__`` functions on modules."
msgstr "モジュールの ``__getattr__`` 関数および ``__dir__`` 関数の説明。"

#: ../../reference/datamodel.rst:1621
msgid "Implementing Descriptors"
msgstr "デスクリプタ (descriptor) の実装"

#: ../../reference/datamodel.rst:1623
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the"
" descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property in"
" the owner class' :attr:`~object.__dict__`."
msgstr ""
"以下のメソッドは、このメソッドを持つクラス (いわゆる *デスクリプタ(descriptor)* クラス) のインスタンスが、 *オーナー (owner)* クラスに存在するときにのみ適用されます (デスクリプタは、オーナーのクラス辞書か、その親のいずれかのクラス辞書になければなりません)。\n"
"以下の例では、\"属性\" とは、名前がオーナークラスの :attr:`~object.__dict__` のプロパティ (porperty) のキーであるような属性を指します。"

#: ../../reference/datamodel.rst:1633
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). The optional "
"*owner* argument is the owner class, while *instance* is the instance that "
"the attribute was accessed through, or ``None`` when the attribute is "
"accessed through the *owner*."
msgstr ""

#: ../../reference/datamodel.rst:1639
msgid ""
"This method should return the computed attribute value or raise an "
":exc:`AttributeError` exception."
msgstr ""

#: ../../reference/datamodel.rst:1642
msgid ""
":PEP:`252` specifies that :meth:`__get__` is callable with one or two "
"arguments.  Python's own built-in descriptors support this specification; "
"however, it is likely that some third-party tools have descriptors that "
"require both arguments.  Python's own :meth:`__getattribute__` "
"implementation always passes in both arguments whether they are required or "
"not."
msgstr ""

#: ../../reference/datamodel.rst:1651
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr "オーナークラスのインスタンス *instance* 上の属性を新たな値 *value* に設定する際に呼び出されます。"

#: ../../reference/datamodel.rst:1654
msgid ""
"Note, adding :meth:`__set__` or :meth:`__delete__` changes the kind of "
"descriptor to a \"data descriptor\".  See :ref:`descriptor-invocation` for "
"more details."
msgstr ""

#: ../../reference/datamodel.rst:1660
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr "オーナークラスのインスタンス *instance* 上の属性を削除する際に呼び出されます。"

#: ../../reference/datamodel.rst:1665
msgid ""
"Called at the time the owning class *owner* is created. The descriptor has "
"been assigned to *name*."
msgstr ""
"オーナーとなるクラス *owner* が作成された時点で呼び出されます。\n"
"ディスクリプタは *name* に割り当てられます。"

#: ../../reference/datamodel.rst:1670
msgid ""
":meth:`__set_name__` is only called implicitly as part of the :class:`type` "
"constructor, so it will need to be called explicitly with the appropriate "
"parameters when a descriptor is added to a class after initial creation::"
msgstr ""

#: ../../reference/datamodel.rst:1681
msgid "See :ref:`class-object-creation` for more details."
msgstr ""

#: ../../reference/datamodel.rst:1685
msgid ""
"The attribute :attr:`__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting this "
"appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given "
"type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods that "
"are implemented in C)."
msgstr ""
":attr:`__objclass__` 属性は :mod:`inspect` モジュールによって解釈され、このオブジェクトが定義されたクラスを特定するのに使われます (この属性を適切に設定しておくと、動的なクラスの属性を実行時に調べる助けになります)。\n"
"呼び出される側にとっては、この属性で指定されたクラス (もしくはそのサブクラス) のインスタンスが1番目の位置引数として期待もしくは要求されていることが示せます (例えば、 CPython は束縛されていない C で実行されたメソッドにこの属性を設定します)。"

#: ../../reference/datamodel.rst:1696
msgid "Invoking Descriptors"
msgstr "デスクリプタの呼び出し"

#: ../../reference/datamodel.rst:1698
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`__get__`, :meth:`__set__`, and :meth:`__delete__`. If any "
"of those methods are defined for an object, it is said to be a descriptor."
msgstr ""
"一般にデスクリプタとは、特殊な \"束縛に関する動作 (binding behaviour)\" "
"をもつオブジェクト属性のことです。デスクリプタは、デスクリプタプロトコル (descriptor protocol) のメソッド: "
":meth:`__get__`, :meth:`__set__`, および :meth:`__delete__` "
"を使って、属性アクセスをオーバーライドしているものです。これらのメソッドのいずれかがオブジェクトに対して定義されている場合、オブジェクトはデスクリプタであるといいます。"

#: ../../reference/datamodel.rst:1703
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and"
" continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"属性アクセスのデフォルトの動作は、オブジェクトの辞書から値を取り出したり、値を設定したり、削除したりするというものです。例えば、 ``a.x`` "
"による属性の検索では、まず ``a.__dict__['x']`` 、次に ``type(a).__dict__['x']`` 、そして "
"``type(a)`` の基底クラスでメタクラスでないものに続く、といった具合に連鎖が起こります。"

#: ../../reference/datamodel.rst:1708
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called."
msgstr ""
"しかし、検索対象の値が、デスクリプタメソッドのいずれかを定義しているオブジェクトであれば、Python "
"はデフォルトの動作をオーバーライドして、代わりにデスクリプタメソッドを呼び出します。先述の連鎖の中のどこでデスクリプタメソッドが呼び出されるかは、どのデスクリプタメソッドが定義されていて、どのように呼び出されたかに依存します。"

#: ../../reference/datamodel.rst:1713
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""
"デスクリプタ呼び出しの基点となるのは、属性名への束縛 (binding) 、すなわち ``a.x`` です。引数がどのようにデスクリプタに結合されるかは"
" ``a`` に依存します:"

#: ../../reference/datamodel.rst:1718
msgid "Direct Call"
msgstr "直接呼び出し (Direct Call)"

#: ../../reference/datamodel.rst:1717
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""
"最も単純で、かつめったに使われない呼び出し操作は、コード中で直接デスクリプタメソッドの呼び出し: ``x.__get__(a)`` "
"を行うというものです。"

#: ../../reference/datamodel.rst:1722
msgid "Instance Binding"
msgstr "インスタンス束縛 (Instance Binding)"

#: ../../reference/datamodel.rst:1721
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"オブジェクトインスタンスへ束縛すると、``a.x`` は呼び出し ``type(a).__dict__['x'].__get__(a, "
"type(a))`` に変換されます。"

#: ../../reference/datamodel.rst:1726
msgid "Class Binding"
msgstr "クラス束縛 (Class Binding)"

#: ../../reference/datamodel.rst:1725
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: "
"``A.__dict__['x'].__get__(None, A)``."
msgstr "クラスへ束縛すると、``A.x`` は呼び出し ``A.__dict__['x'].__get__(None, A)`` に変換されます。"

#: ../../reference/datamodel.rst:1732
msgid "Super Binding"
msgstr "super 束縛 (Super Binding)"

#: ../../reference/datamodel.rst:1729
msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, "
"obj).m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately preceding ``B`` and then invokes the descriptor with the call: "
"``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr ""
"``a`` が :class:`super` のインスタンスである場合、束縛 ``super(B, obj).m()`` を行うとまず ``A`` "
"、続いて ``B`` に対して ``obj.__class_.__mro__`` を検索し、次に呼び出し: "
"``A.__dict__['m'].__get__(obj, obj.__class__)`` でデスクリプタを呼び出します。"

#: ../../reference/datamodel.rst:1734
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"the which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  If "
"it does not define :meth:`__get__`, then accessing the attribute will return"
" the descriptor object itself unless there is a value in the object's "
"instance dictionary.  If the descriptor defines :meth:`__set__` and/or "
":meth:`__delete__`, it is a data descriptor; if it defines neither, it is a "
"non-data descriptor.  Normally, data descriptors define both :meth:`__get__`"
" and :meth:`__set__`, while non-data descriptors have just the "
":meth:`__get__` method.  Data descriptors with :meth:`__set__` and "
":meth:`__get__` defined always override a redefinition in an instance "
"dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr ""
"インスタンス束縛では、デスクリプタ呼び出しの優先順位はどのデスクリプタが定義されているかに依存します。データデスクリプタは、 "
":meth:`__get__` と :meth:`__set__` 、 :meth:`__delete__` の任意の組合せを定義することができます。 "
":meth:`__get__` "
"が定義されない場合には、その属性にアクセスすると、そのオブジェクトのインスタンス辞書にその値がある場合を除けば、デスクリプタオブジェクト自身が返ってきます。デスクリプタが"
" :meth:`__set__` と :meth:`__delete__` またはそのどちらかを定義していれば、データデスクリプタとなります; "
"もし両方とも定義しなければ、非データデスクリプタです。通常、データデスクリプタでは、 :meth:`__get__` と :meth:`__set__`"
" を定義し、一方、非データデスクリプタには :meth:`__get__` メソッドしかありません。 :meth:`__set__` と "
":meth:`__get__` "
"を定義したデータデスクリプタは、インスタンス辞書内で属性値が再定義されても、常にこの値をオーバーライドします。対照的に、非データデスクリプタの場合には、属性値はインスタンス側でオーバーライドされます。"

#: ../../reference/datamodel.rst:1747
msgid ""
"Python methods (including :func:`staticmethod` and :func:`classmethod`) are "
"implemented as non-data descriptors.  Accordingly, instances can redefine "
"and override methods.  This allows individual instances to acquire behaviors"
" that differ from other instances of the same class."
msgstr ""
"(:func:`staticmethod` や :func:`classmethod` を含む) Python "
"メソッドは、非データデスクリプタとして実装されています。その結果、インスタンスではメソッドを再定義したりオーバーライドできます。このことにより、個々のインスタンスが同じクラスの他のインスタンスと互いに異なる動作を獲得することができます。"

#: ../../reference/datamodel.rst:1752
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
":func:`property` "
"関数はデータデスクリプタとして実装されています。従って、インスタンスはあるプロパティの動作をオーバーライドすることができません。"

#: ../../reference/datamodel.rst:1759
msgid "__slots__"
msgstr "__slots__"

#: ../../reference/datamodel.rst:1761
msgid ""
"*__slots__* allow us to explicitly declare data members (like properties) "
"and deny the creation of *__dict__* and *__weakref__* (unless explicitly "
"declared in *__slots__* or available in a parent.)"
msgstr ""
"*__slots__* を使うと、(プロパティのように) データメンバを明示的に宣言し、 (明示的に *__slots__* "
"で宣言しているか親クラスに存在しているかでない限り) *__dict__* や *__weakref__* を作成しないようにできます。"

#: ../../reference/datamodel.rst:1765
msgid ""
"The space saved over using *__dict__* can be significant. Attribute lookup "
"speed can be significantly improved as well."
msgstr ""
"*__dict__* を使うのに比べて、節約できるメモリ空間はかなり大きいです。\n"
"属性探索のスピードもかなり向上できます。"

#: ../../reference/datamodel.rst:1770
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves space "
"for the declared variables and prevents the automatic creation of *__dict__*"
" and *__weakref__* for each instance."
msgstr ""
"このクラス変数には、インスタンスが用いる変数名を表す、文字列、イテラブル、または文字列のシーケンスを代入できます。*__slots__* "
"は、各インスタンスに対して宣言された変数に必要な記憶領域を確保し、*__dict__* と *__weakref__* "
"が自動的に生成されないようにします。"

#: ../../reference/datamodel.rst:1777
msgid "Notes on using *__slots__*"
msgstr "*__slots__* を利用する際の注意"

#: ../../reference/datamodel.rst:1779
msgid ""
"When inheriting from a class without *__slots__*, the *__dict__* and "
"*__weakref__* attribute of the instances will always be accessible."
msgstr ""
"*__slots__* を持たないクラスから継承するとき、インスタンスの *__dict__* 属性と *__weakref__* "
"属性は常に利用可能です。"

#: ../../reference/datamodel.rst:1782
msgid ""
"Without a *__dict__* variable, instances cannot be assigned new variables "
"not listed in the *__slots__* definition.  Attempts to assign to an unlisted"
" variable name raises :exc:`AttributeError`. If dynamic assignment of new "
"variables is desired, then add ``'__dict__'`` to the sequence of strings in "
"the *__slots__* declaration."
msgstr ""
"*__dict__* 変数がない場合、 *__slots__* "
"に列挙されていない新たな変数をインスタンスに代入することはできません。列挙されていない変数名を使って代入しようとした場合、 "
":exc:`AttributeError` が送出されます。新たな変数を動的に代入したいのなら、 *__slots__* を宣言する際に "
"``'__dict__'`` を変数名のシーケンスに追加してください。"

#: ../../reference/datamodel.rst:1788
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support weak references to its instances. If weak "
"reference support is needed, then add ``'__weakref__'`` to the sequence of "
"strings in the *__slots__* declaration."
msgstr ""
"*__slots__* を定義しているクラスの各インスタンスに *__weakref__* 変数がない場合、インスタンスに対する弱参照 (weak "
"reference) はサポートされません。弱参照のサポートが必要なら、 *__slots__* を宣言する際に ``'__weakref__'`` "
"を変数名のシーケンスに追加してください。"

#: ../../reference/datamodel.rst:1793
msgid ""
"*__slots__* are implemented at the class level by creating descriptors "
"(:ref:`descriptors`) for each variable name.  As a result, class attributes "
"cannot be used to set default values for instance variables defined by "
"*__slots__*; otherwise, the class attribute would overwrite the descriptor "
"assignment."
msgstr ""
"*__slots__* は、クラスのレベルで各変数に対するデスクリプタ (:ref:`descriptors` を参照) "
"を使って実装されます。その結果、 *__slots__* に定義されているインスタンス変数のデフォルト値はクラス属性を使って設定できなくなっています; "
"そうしないと、デスクリプタによる代入をクラス属性が上書きしてしまうからです。"

#: ../../reference/datamodel.rst:1799
msgid ""
"The action of a *__slots__* declaration is not limited to the class where it"
" is defined.  *__slots__* declared in parents are available in child "
"classes. However, child subclasses will get a *__dict__*  and *__weakref__* "
"unless they also define *__slots__* (which should only contain names of any "
"*additional* slots)."
msgstr ""
"*__slots__* の宣言の作用は、それが定義されたクラスだけには留まりません。\n"
"親クラスで宣言された *__slots__* は子クラスでも利用可能です。\n"
"ただし、子クラスは、自身も *__slots__* (ここには *追加の* スロットの名前のみ含めるべき) を定義しない限り*__dict__* や *__weakref__* を持ちます。"

#: ../../reference/datamodel.rst:1805
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""
"あるクラスで、基底クラスですでに定義されているスロットを定義した場合、基底クラスのスロットで定義されているインスタンス変数は "
"(デスクリプタを基底クラスから直接取得しない限り) "
"アクセスできなくなります。これにより、プログラムの趣意が不定になってしまいます。将来は、この問題を避けるために何らかのチェックが追加されるかもしれません。"

#: ../../reference/datamodel.rst:1810
msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-"
"length\" built-in types such as :class:`int`, :class:`bytes` and "
":class:`tuple`."
msgstr ""
"空でない *__slots__* は、 :class:`int` や :class:`bytes` や :class:`tuple` のような "
"\"可変長の\" 組み込み型から派生したクラスでは動作しません。"

#: ../../reference/datamodel.rst:1813
msgid ""
"Any non-string iterable may be assigned to *__slots__*. Mappings may also be"
" used; however, in the future, special meaning may be assigned to the values"
" corresponding to each key."
msgstr ""
"*__slots__* には、文字列でない反復可能オブジェクトを代入することができます。辞書型も使うことができます; "
"しかし将来、辞書の各キーに相当する値に何らかの特殊な意味が割り当てられるかもしれません。"

#: ../../reference/datamodel.rst:1817
msgid ""
"*__class__* assignment works only if both classes have the same *__slots__*."
msgstr "*__class__* への代入は、両方のクラスが同じ *__slots__* を持っているときのみ動作します。"

#: ../../reference/datamodel.rst:1819
msgid ""
"Multiple inheritance with multiple slotted parent classes can be used, but "
"only one parent is allowed to have attributes created by slots (the other "
"bases must have empty slot layouts) - violations raise :exc:`TypeError`."
msgstr ""
"複数のスロットを持つ親クラスを使った多重継承はできますが、スロットで作成された属性を持つ親クラスは 1 つに限られます "
"(他の基底クラスのスロットは空でなければなりません) - それに違反すると :exc:`TypeError` が送出されます。"

#: ../../reference/datamodel.rst:1824
msgid ""
"If an iterator is used for *__slots__* then a descriptor is created for each"
" of the iterator's values. However, the *__slots__* attribute will be an "
"empty iterator."
msgstr ""

#: ../../reference/datamodel.rst:1831
msgid "Customizing class creation"
msgstr "クラス生成をカスタマイズする"

#: ../../reference/datamodel.rst:1833
msgid ""
"Whenever a class inherits from another class, *__init_subclass__* is called "
"on that class. This way, it is possible to write classes which change the "
"behavior of subclasses. This is closely related to class decorators, but "
"where class decorators only affect the specific class they're applied to, "
"``__init_subclass__`` solely applies to future subclasses of the class "
"defining the method."
msgstr ""
"クラスが他のクラスを継承するときに必ず、継承元のクラスの *__init_subclass__* "
"が呼び出されます。これを利用すると、サブクラスの挙動を変更するクラスを書くことができます。これは、クラスデコレータととても良く似ていますが、クラスデコレータが、それが適用された特定のクラスにのみに影響するのに対して、"
" ``__init_subclass__`` は、もっぱら、このメソッドを定義したクラスの将来のサブクラスに適用されます。"

#: ../../reference/datamodel.rst:1842
msgid ""
"This method is called whenever the containing class is subclassed. *cls* is "
"then the new subclass. If defined as a normal instance method, this method "
"is implicitly converted to a class method."
msgstr ""
"このメソッドは、それが定義されたクラスが継承された際に必ず呼び出されます。*cls* "
"は新しいサブクラスです。もし、このメソッドがインスタンスメソッドとして定義されると、暗黙的にクラスメソッドに変換されます。"

#: ../../reference/datamodel.rst:1846
msgid ""
"Keyword arguments which are given to a new class are passed to the parent's "
"class ``__init_subclass__``. For compatibility with other classes using "
"``__init_subclass__``, one should take out the needed keyword arguments and "
"pass the others over to the base class, as in::"
msgstr ""
"新しいクラスに与えられたキーワード引数は、親のクラスの ``__init_subclass__`` に渡されます。 "
"``__init_subclass__`` "
"を利用している他のクラスとの互換性のために、以下のコードのように必要なキーワード引数を取得したら、他の引数は基底クラスに引き渡すべきです::"

#: ../../reference/datamodel.rst:1860
msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but "
"raises an error if it is called with any arguments."
msgstr ""
"``object.__init_subclass__`` "
"のデフォルト実装は何も行いませんが、何らかの引数とともに呼び出された場合は、エラーを送出します。"

#: ../../reference/datamodel.rst:1865
msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. The"
" actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""
"メタクラスのヒント ``metaclass`` は残りの型機構によって消費され、 ``__init_subclass__`` 実装に渡されることはありません。\n"
"実際のメタクラス (明示的なヒントではなく) は、 ``type(cls)`` としてアクセスできます。"

#: ../../reference/datamodel.rst:1876
msgid "Metaclasses"
msgstr "メタクラス"

#: ../../reference/datamodel.rst:1883
msgid ""
"By default, classes are constructed using :func:`type`. The class body is "
"executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"デフォルトでは、クラスは :func:`type` を使って構築されます。 クラス本体は新しい名前空間で実行され、クラス名が ``type(name, "
"bases, namespace)`` の結果にローカルに束縛されます。"

#: ../../reference/datamodel.rst:1887
msgid ""
"The class creation process can be customized by passing the ``metaclass`` "
"keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"クラス生成プロセスはカスタマイズできます。\n"
"そのためにはクラス定義行で ``metaclass`` キーワード引数を渡すか、そのような引数を定義行に含む既存のクラスを継承します。\n"
"次の例で ``MyClass`` と ``MySubclass`` は両方とも ``Meta`` のインスタンスです::"

#: ../../reference/datamodel.rst:1901
msgid ""
"Any other keyword arguments that are specified in the class definition are "
"passed through to all metaclass operations described below."
msgstr "クラス定義の中で指定された他のキーワード引数は、後述するすべてのメタクラス操作に渡されます。"

#: ../../reference/datamodel.rst:1904
msgid "When a class definition is executed, the following steps occur:"
msgstr "クラス定義が実行される際に、以下のステップが生じます:"

#: ../../reference/datamodel.rst:1906
msgid "MRO entries are resolved;"
msgstr "MRO エントリの解決が行われる;"

#: ../../reference/datamodel.rst:1907
msgid "the appropriate metaclass is determined;"
msgstr "適切なメタクラスが決定される;"

#: ../../reference/datamodel.rst:1908
msgid "the class namespace is prepared;"
msgstr "クラスの名前空間が準備される;"

#: ../../reference/datamodel.rst:1909
msgid "the class body is executed;"
msgstr "クラスの本体が実行される;"

#: ../../reference/datamodel.rst:1910
msgid "the class object is created."
msgstr "クラスオブジェクトが作られる。"

#: ../../reference/datamodel.rst:1914
msgid "Resolving MRO entries"
msgstr "MRO エントリの解決"

#: ../../reference/datamodel.rst:1916
msgid ""
"If a base that appears in class definition is not an instance of "
":class:`type`, then an ``__mro_entries__`` method is searched on it. If "
"found, it is called with the original bases tuple. This method must return a"
" tuple of classes that will be used instead of this base. The tuple may be "
"empty, in such case the original base is ignored."
msgstr ""
"クラス定義に現れる基底が :class:`type` のインスタンスではない場合、そのインスタンスの ``__mro_entries__`` メソッドが検索されます。\n"
"見付かった場合、その基底そのものを要素に持つタプルを引数として、 ``__mro_entries__`` メソッドが呼び出されます。\n"
"このメソッドは、この基底の代わりに使われるクラスのタプルを返さなければなりません。\n"
"このタプルは空であることもあり、そのような場合ではその基底は無視されます。"

#: ../../reference/datamodel.rst:1924 ../../reference/datamodel.rst:2114
msgid ":pep:`560` - Core support for typing module and generic types"
msgstr ":pep:`560` - typing モジュールとジェネリック型に対する言語コアによるサポート"

#: ../../reference/datamodel.rst:1928
msgid "Determining the appropriate metaclass"
msgstr "適切なメタクラスの決定"

#: ../../reference/datamodel.rst:1932
msgid ""
"The appropriate metaclass for a class definition is determined as follows:"
msgstr "クラス定義に対して適切なメタクラスは、以下のように決定されます:"

#: ../../reference/datamodel.rst:1934
msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is used;"
msgstr "基底も明示的なメタクラスも与えられていない場合は、 :func:`type` が使われます;"

#: ../../reference/datamodel.rst:1935
msgid ""
"if an explicit metaclass is given and it is *not* an instance of "
":func:`type`, then it is used directly as the metaclass;"
msgstr ""
"明示的なメタクラスが与えられていて、それが :func:`type` のインスタンス *ではない* 場合、それをメタクラスとして直接使います;"

#: ../../reference/datamodel.rst:1937
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or bases "
"are defined, then the most derived metaclass is used."
msgstr ""
"明示的なメタクラスとして :func:`type` のインスタンスが与えられたか、基底が定義されていた場合は、最も派生した (継承関係で最も下の) "
"メタクラスが使われます。"

#: ../../reference/datamodel.rst:1940
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all specified"
" base classes. The most derived metaclass is one which is a subtype of *all*"
" of these candidate metaclasses. If none of the candidate metaclasses meets "
"that criterion, then the class definition will fail with ``TypeError``."
msgstr ""
"最も派生的なメタクラスは、(もしあれば) "
"明示的に指定されたメタクラスと、指定されたすべてのベースクラスのメタクラスから選ばれます。最も派生的なメタクラスは、これらのメタクラス候補のすべてのサブタイプであるようなものです。メタクラス候補のどれもその基準を満たさなければ、クラス定義は"
" ``TypeError`` で失敗します。"

#: ../../reference/datamodel.rst:1950
msgid "Preparing the class namespace"
msgstr "クラスの名前空間の準備"

#: ../../reference/datamodel.rst:1955
msgid ""
"Once the appropriate metaclass has been identified, then the class namespace"
" is prepared. If the metaclass has a ``__prepare__`` attribute, it is called"
" as ``namespace = metaclass.__prepare__(name, bases, **kwds)`` (where the "
"additional keyword arguments, if any, come from the class definition). The "
"``__prepare__`` method should be implemented as a :func:`classmethod`. The "
"namespace returned by ``__prepare__`` is passed in to ``__new__``, but when "
"the final class object is created the namespace is copied into a new "
"``dict``."
msgstr ""

#: ../../reference/datamodel.rst:1963
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class namespace "
"is initialised as an empty ordered mapping."
msgstr "メタクラスに ``__prepare__`` 属性がない場合、クラスの名前空間は空の 順序付きマッピングとして初期化されます。"

#: ../../reference/datamodel.rst:1968
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaclasses in Python 3000"

#: ../../reference/datamodel.rst:1969
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "``__prepare__`` 名前空間フックの導入"

#: ../../reference/datamodel.rst:1973
msgid "Executing the class body"
msgstr "クラス本体の実行"

#: ../../reference/datamodel.rst:1978
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is that "
"lexical scoping allows the class body (including any methods) to reference "
"names from the current and outer scopes when the class definition occurs "
"inside a function."
msgstr ""
"クラス本体が (大まかには) ``exec(body, globals(), namespace)`` として実行されます。通常の呼び出しと "
":func:`exec` の重要な違いは、クラス定義が関数内部で行われる場合、レキシカルスコープによってクラス本体 (任意のメソッドを含む) "
"が現在のスコープと外側のスコープから名前を参照できるという点です。"

#: ../../reference/datamodel.rst:1984
msgid ""
"However, even when the class definition occurs inside the function, methods "
"defined inside the class still cannot see names defined at the class scope. "
"Class variables must be accessed through the first parameter of instance or "
"class methods, or through the implicit lexically scoped ``__class__`` "
"reference described in the next section."
msgstr ""
"しかし、クラス定義が関数内部で行われる時でさえ、クラス内部で定義されたメソッドはクラススコープで定義された名前を見ることはできません。クラス変数はインスタンスメソッドかクラスメソッドの最初のパラメータからアクセスするか、次の節で説明する、暗黙的に静的スコープが切られている"
" ``__class__`` 参照からアクセスしなければなりません。"

#: ../../reference/datamodel.rst:1993
msgid "Creating the class object"
msgstr "クラスオブジェクトの作成"

#: ../../reference/datamodel.rst:2000
msgid ""
"Once the class namespace has been populated by executing the class body, the"
" class object is created by calling ``metaclass(name, bases, namespace, "
"**kwds)`` (the additional keywords passed here are the same as those passed "
"to ``__prepare__``)."
msgstr ""
"クラス本体の実行によってクラスの名前空間が初期化されたら、``metaclass(name, bases, namespace, **kwds)`` "
"を呼び出すことでクラスオブジェクトが作成されます (ここで渡される追加のキーワードは ``__prepare__`` に渡されるものと同じです)。"

#: ../../reference/datamodel.rst:2005
msgid ""
"This class object is the one that will be referenced by the zero-argument "
"form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of "
":func:`super` to correctly identify the class being defined based on lexical"
" scoping, while the class or instance that was used to make the current call"
" is identified based on the first argument passed to the method."
msgstr ""
"このクラスオブジェクトは、 :func:`super` の無引数形式によって参照されるものです。 ``__class__`` "
"は、クラス本体中のメソッドが ``__class__`` または ``super`` "
"のいずれかを参照している場合に、コンパイラによって作成される暗黙のクロージャー参照です。これは、メソッドに渡された最初の引数に基づいて現在の呼び出しを行うために使用されるクラスまたはインスタンスが識別される一方、"
" :func:`super` の無引数形式がレキシカルスコープに基づいて定義されているクラスを正確に識別することを可能にします。"

#: ../../reference/datamodel.rst:2015
msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the metaclass "
"as a ``__classcell__`` entry in the class namespace. If present, this must "
"be propagated up to the ``type.__new__`` call in order for the class to be "
"initialised correctly. Failing to do so will result in a :exc:`RuntimeError`"
" in Python 3.8."
msgstr ""

#: ../../reference/datamodel.rst:2021
msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customisation "
"steps are invoked after creating the class object:"
msgstr ""
"デフォルトのメタクラス :class:`type` や最終的には ``type.__new__`` "
"を呼び出すメタクラスを使っているときは、クラスオブジェクトを作成した後に次のカスタム化の手順が起動されます:"

#: ../../reference/datamodel.rst:2025
msgid ""
"first, ``type.__new__`` collects all of the descriptors in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""
"最初に、 ``type.__new__`` が :meth:`~object.__set_name__` "
"が定義されているクラスの名前空間にある全てのデスクリプタを収集します;"

#: ../../reference/datamodel.rst:2027
msgid ""
"second, all of these ``__set_name__`` methods are called with the class "
"being defined and the assigned name of that particular descriptor;"
msgstr ""
"次に、それら全ての ``__set_name__`` "
"メソッドが、そのメソッドが定義されているクラス、およびそこに属するデスクリプタに割り当てられている名前を引数として呼び出されます;"

#: ../../reference/datamodel.rst:2029
msgid ""
"finally, the :meth:`~object.__init_subclass__` hook is called on the "
"immediate parent of the new class in its method resolution order."
msgstr ""
"最後に、新しいクラスのメソッド解決順序ですぐ上に位置する親クラスで :meth:`~object.__init_subclass__` "
"フックが呼び出されます。"

#: ../../reference/datamodel.rst:2032
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is bound "
"in the local namespace as the defined class."
msgstr ""
"クラスオブジェクトが作成された後には、クラス定義に含まれているクラスデコレータ (もしあれば) "
"にクラスオブジェクトが渡され、デコレータが返すオブジェクトがここで定義されたクラスとしてローカルの名前空間に束縛されます。"

#: ../../reference/datamodel.rst:2036
msgid ""
"When a new class is created by ``type.__new__``, the object provided as the "
"namespace parameter is copied to a new ordered mapping and the original "
"object is discarded. The new copy is wrapped in a read-only proxy, which "
"becomes the :attr:`~object.__dict__` attribute of the class object."
msgstr ""
"新しいクラスが ``type.__new__`` で生成されたときは、名前空間引数として与えられたオブジェクトは新しい順序付きのマッピングに複製され、元のオブジェクトは破棄されます。\n"
"新しく複製したものは読み出し専用のプロキシでラップされ、クラスオブジェクトの :attr:`~object.__dict__` 属性になります。"

#: ../../reference/datamodel.rst:2043
msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` - New super"

#: ../../reference/datamodel.rst:2044
msgid "Describes the implicit ``__class__`` closure reference"
msgstr "暗黙の ``__class__`` クロージャ参照について記述しています"

#: ../../reference/datamodel.rst:2048
msgid "Uses for metaclasses"
msgstr "メタクラスの用途"

#: ../../reference/datamodel.rst:2050
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored include enum, logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""
"メタクラスは限りない潜在的利用価値を持っています。これまで試されてきたアイデアには、列挙型、ログ記録、インタフェースのチェック、 "
"自動デリゲーション、自動プロパティ生成、プロキシ、フレームワーク、そして自動リソースロック／同期といったものがあります。"

#: ../../reference/datamodel.rst:2057
msgid "Customizing instance and subclass checks"
msgstr "インスタンスのカスタマイズとサブクラスチェック"

#: ../../reference/datamodel.rst:2059
msgid ""
"The following methods are used to override the default behavior of the "
":func:`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"以下のメソッドは組み込み関数 :func:`isinstance` と :func:`issubclass` "
"のデフォルトの動作を上書きするのに利用します。"

#: ../../reference/datamodel.rst:2062
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""
"特に、 :class:`abc.ABCMeta` メタクラスは、抽象基底クラス (ABCs) を\"仮想基底クラス (virtual base "
"classes)\" として、他の ABC を含む、任意のクラスや (組み込み型を含む) 型に追加するために、これらのメソッドを実装しています。"

#: ../../reference/datamodel.rst:2069
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""
"*instance* が (直接、または間接的に) *class* のインスタンスと考えられる場合に true を返します。定義されていれば、 "
"``isinstance(instance, class)`` の実装のために呼び出されます。"

#: ../../reference/datamodel.rst:2076
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass,"
" class)``."
msgstr ""
"*subclass* が (直接、または間接的に) *class* のサブクラスと考えられる場合に true を返します。定義されていれば、 "
"``issubclass(subclass, class)`` の実装のために呼び出されます。"

#: ../../reference/datamodel.rst:2081
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""
"なお、これらのメソッドは、クラスの型 (メタクラス) "
"上で検索されます。実際のクラスにクラスメソッドとして定義することはできません。これは、インスタンスそれ自体がクラスであるこの場合にのみ、インスタンスに呼び出される特殊メソッドの検索と一貫しています。"

#: ../../reference/datamodel.rst:2092
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - 抽象基底クラスの導入"

#: ../../reference/datamodel.rst:2089
msgid ""
"Includes the specification for customizing :func:`isinstance` and "
":func:`issubclass` behavior through :meth:`~class.__instancecheck__` and "
":meth:`~class.__subclasscheck__`, with motivation for this functionality in "
"the context of adding Abstract Base Classes (see the :mod:`abc` module) to "
"the language."
msgstr ""
"抽象基底クラス (:mod:`abc` モジュールを参照) を言語に追加する文脈においての動機から、 "
":meth:`~class.__instancecheck__` と :meth:`~class.__subclasscheck__` を通して、 "
":func:`isinstance` と :func:`issubclass` に独自の動作をさせるための仕様の記述があります。"

#: ../../reference/datamodel.rst:2097
msgid "Emulating generic types"
msgstr "ジェネリック型をエミュレートする"

#: ../../reference/datamodel.rst:2099
msgid ""
"One can implement the generic class syntax as specified by :pep:`484` (for "
"example ``List[int]``) by defining a special method:"
msgstr ""
"特殊メソッドを定義することで、 :pep:`484` で指定されたジェネリッククラス構文 (例えば ``List[int]``) を実装できます:"

#: ../../reference/datamodel.rst:2104
msgid ""
"Return an object representing the specialization of a generic class by type "
"arguments found in *key*."
msgstr "*key* にある型引数で特殊化されたジェネリッククラスを表すオブジェクトを返します。"

#: ../../reference/datamodel.rst:2107
msgid ""
"This method is looked up on the class object itself, and when defined in the"
" class body, this method is implicitly a class method.  Note, this mechanism"
" is primarily reserved for use with static type hints, other usage is "
"discouraged."
msgstr ""
"このメソッドはクラスオブジェクト自身から検索され、クラスの本体に定義されていたら、暗黙的にクラスメソッドになります。\n"
"この機構は主に静的な型ヒントで使うために備わっているもので、それ以外での使用は推奨されません。"

#: ../../reference/datamodel.rst:2120
msgid "Emulating callable objects"
msgstr "呼び出し可能オブジェクトをエミュレートする"

#: ../../reference/datamodel.rst:2127
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, arg2, "
"...)``."
msgstr ""
"インスタンスが関数として \"呼ばれた\" 際に呼び出されます; このメソッドが定義されている場合、 ``x(arg1, arg2, ...)`` は "
"``x.__call__(arg1, arg2, ...)`` を短く書いたものになります。"

#: ../../reference/datamodel.rst:2134
msgid "Emulating container types"
msgstr "コンテナをエミュレートする"

#: ../../reference/datamodel.rst:2136
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are sequences (such as lists or tuples) or mappings (like"
" dictionaries), but can represent other containers as well.  The first set "
"of methods is used either to emulate a sequence or to emulate a mapping; the"
" difference is that for a sequence, the allowable keys should be the "
"integers *k* for which ``0 <= k < N`` where *N* is the length of the "
"sequence, or slice objects, which define a range of items.  It is also "
"recommended that mappings provide the methods :meth:`keys`, :meth:`values`, "
":meth:`items`, :meth:`get`, :meth:`clear`, :meth:`setdefault`, :meth:`pop`, "
":meth:`popitem`, :meth:`!copy`, and :meth:`update` behaving similar to those"
" for Python's standard dictionary objects.  The :mod:`collections.abc` "
"module provides a :class:`~collections.abc.MutableMapping` abstract base "
"class to help create those methods from a base set of :meth:`__getitem__`, "
":meth:`__setitem__`, :meth:`__delitem__`, and :meth:`keys`. Mutable "
"sequences should provide methods :meth:`append`, :meth:`count`, "
":meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, :meth:`remove`, "
":meth:`reverse` and :meth:`sort`, like Python standard list objects.  "
"Finally, sequence types should implement addition (meaning concatenation) "
"and multiplication (meaning repetition) by defining the methods "
":meth:`__add__`, :meth:`__radd__`, :meth:`__iadd__`, :meth:`__mul__`, "
":meth:`__rmul__` and :meth:`__imul__` described below; they should not "
"define other numerical operators.  It is recommended that both mappings and "
"sequences implement the :meth:`__contains__` method to allow efficient use "
"of the ``in`` operator; for mappings, ``in`` should search the mapping's "
"keys; for sequences, it should search through the values.  It is further "
"recommended that both mappings and sequences implement the :meth:`__iter__` "
"method to allow efficient iteration through the container; for mappings, "
":meth:`__iter__` should iterate through the object's keys; for sequences, it"
" should iterate through the values."
msgstr ""

#: ../../reference/datamodel.rst:2171
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`__bool__` method and whose :meth:`__len__` method returns "
"zero is considered to be false in a Boolean context."
msgstr ""
"呼び出して組み込み関数 :func:`len` を実装します。\n"
"オブジェクトの長さを 0 以上の整数で返さなければなりません。\n"
"また、 :meth:`__bool__`  メソッドを定義しておらず、 :meth:`__len__` メソッドが 0 を返すようなオブジェクトは、ブール演算コンテキストでは偽とみなされます。"

#: ../../reference/datamodel.rst:2178
msgid ""
"In CPython, the length is required to be at most :attr:`sys.maxsize`. If the"
" length is larger than :attr:`!sys.maxsize` some features (such as "
":func:`len`) may raise :exc:`OverflowError`.  To prevent raising "
":exc:`!OverflowError` by truth value testing, an object must define a "
":meth:`__bool__` method."
msgstr ""
"CPython では、オブジェクトの長さは最大でも :attr:`sys.maxsize` であることが要求されます。\n"
"長さが :attr:`!sys.maxsize` を越える場合、(:func:`len` のような) いくつかの機能は :exc:`OverflowError` を送出するでしょう。\n"
"真偽値としての判定で :exc:`!OverflowError` を送出しないようにするには、オブジェクトは meth:`__bool__` メソッドを定義していなければなりません。"

#: ../../reference/datamodel.rst:2187
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an estimated"
" length for the object (which may be greater or less than the actual "
"length). The length must be an integer ``>=`` 0. The return value may also "
"be :const:`NotImplemented`, which is treated the same as if the "
"``__length_hint__`` method didn't exist at all. This method is purely an "
"optimization and is never required for correctness."
msgstr ""

#: ../../reference/datamodel.rst:2201
msgid ""
"Slicing is done exclusively with the following three methods.  A call like "
"::"
msgstr "スライシングは、以下の 3 メソッドによって排他的に行われます。次のような呼び出しは ::"

#: ../../reference/datamodel.rst:2205
msgid "is translated to ::"
msgstr "次のように翻訳され ::"

#: ../../reference/datamodel.rst:2209
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr "以下も同様です。存在しないスライスの要素は ``None`` で埋められます。"

#: ../../reference/datamodel.rst:2214
msgid ""
"Called to implement evaluation of ``self[key]``. For sequence types, the "
"accepted keys should be integers and slice objects.  Note that the special "
"interpretation of negative indexes (if the class wishes to emulate a "
"sequence type) is up to the :meth:`__getitem__` method. If *key* is of an "
"inappropriate type, :exc:`TypeError` may be raised; if of a value outside "
"the set of indexes for the sequence (after any special interpretation of "
"negative values), :exc:`IndexError` should be raised. For mapping types, if "
"*key* is missing (not in the container), :exc:`KeyError` should be raised."
msgstr ""
"``self[key]`` の値評価 (evaluation) "
"を実現するために呼び出されます。シーケンスの場合、キーとして整数とスライスオブジェクトを受理できなければなりません。 "
"(シーケンス型をエミュレートする場合) 負のインデクスの解釈は :meth:`__getitem__` メソッド次第となります。 *key* "
"が不適切な型であった場合、 :exc:`TypeError` を送出してもかまいません; (負のインデクス値に対して何らかの解釈を行った上で) "
"*key* がシーケンスのインデクス集合外の値である場合、 :exc:`IndexError` を送出しなければなりません。マップ型の場合は、 "
"*key* に誤りがある場合（コンテナに含まれていない場合）、 :exc:`KeyError` を送出しなければなりません。"

#: ../../reference/datamodel.rst:2225
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
":keyword:`for` ループでは、シーケンスの終端を正しく検出できるようにするために、不正なインデクスに対して "
":exc:`IndexError` が送出されるものと期待しています。"

#: ../../reference/datamodel.rst:2231
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the "
"objects support changes to the values for keys, or if new keys can be added,"
" or for sequences if elements can be replaced.  The same exceptions should "
"be raised for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"``self[key]`` に対する代入を実装するために呼び出されます。 :meth:`__getitem__` "
"と同じ注意事項があてはまります。このメソッドを実装できるのは、あるキーに対する値の変更をサポートしているか、新たなキーを追加できるようなマップの場合と、ある要素を置き換えることができるシーケンスの場合だけです。不正な"
" *key* に対しては、 :meth:`__getitem__` メソッドと同様の例外の送出を行わなければなりません。"

#: ../../reference/datamodel.rst:2240
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the "
"objects support removal of keys, or for sequences if elements can be removed"
" from the sequence.  The same exceptions should be raised for improper *key*"
" values as for the :meth:`__getitem__` method."
msgstr ""
"``self[key]`` の削除を実装するために呼び出されます。 :meth:`__getitem__` "
"と同じ注意事項があてはまります。このメソッドを実装できるのは、キーの削除をサポートしているマップの場合と、要素を削除できるシーケンスの場合だけです。不正な"
" *key* に対しては、 :meth:`__getitem__` メソッドと同様の例外の送出を行わなければなりません。"

#: ../../reference/datamodel.rst:2249
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]``"
" for dict subclasses when key is not in the dictionary."
msgstr ""
"``self[key]`` の実装において辞書内にキーが存在しなかった場合に、 dict のサブクラスのために :class:`dict`\\ .\\ "
":meth:`__getitem__` によって呼び出されます。"

#: ../../reference/datamodel.rst:2255
msgid ""
"This method is called when an iterator is required for a container. This "
"method should return a new iterator object that can iterate over all the "
"objects in the container.  For mappings, it should iterate over the keys of "
"the container."
msgstr ""
"このメソッドは、コンテナに対してイテレータが要求された際に呼び出されます。このメソッドは、コンテナ内の全てのオブジェクトに渡って反復処理できるような、新たなイテレータオブジェクトを返さなければなりません。マッピングでは、コンテナ内のキーに渡って反復処理しなければなりません。"

#: ../../reference/datamodel.rst:2259
msgid ""
"Iterator objects also need to implement this method; they are required to "
"return themselves.  For more information on iterator objects, see "
":ref:`typeiter`."
msgstr ""
"イテレータオブジェクトでもこのメソッドを実装する必要があります; "
"イテレータの場合、自分自身を返さなければなりません。イテレータオブジェクトに関するより詳細な情報は、 :ref:`typeiter` "
"を参照してください。"

#: ../../reference/datamodel.rst:2265
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""
":func:`reversed` "
"組み込み関数が逆方向イテレーションを実装するために、(存在すれば)呼び出します。コンテナ内の全要素を逆順にイテレートする、新しいイテレータを返すべきです。"

#: ../../reference/datamodel.rst:2269
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and "
":meth:`__getitem__`).  Objects that support the sequence protocol should "
"only provide :meth:`__reversed__` if they can provide an implementation that"
" is more efficient than the one provided by :func:`reversed`."
msgstr ""
":meth:`__reversed__` メソッドが定義されていない場合、 :func:`reversed` 組込み関数は sequence プロトコル"
" (:meth:`__len__` と :meth:`__getitem__`) を使った方法にフォールバックします。 sequence "
"プロトコルをサポートしたオブジェクトは、 :func:`reversed` よりも効率のいい実装を提供できる場合にのみ "
":meth:`__reversed__` を定義するべきです。"

#: ../../reference/datamodel.rst:2276
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a container. However, container"
" objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be iterable."
msgstr ""

#: ../../reference/datamodel.rst:2283
msgid ""
"Called to implement membership test operators.  Should return true if *item*"
" is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""
"帰属テスト演算を実装するために呼び出されます。 *item* が *self* "
"内に存在する場合には真を、そうでない場合には偽を返さなければなりません。マップオブジェクトの場合、値やキーと値の組ではなく、キーに対する帰属テストを考えなければなりません。"

#: ../../reference/datamodel.rst:2287
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""
":meth:`__contains__` を定義しないオブジェクトに対しては、メンバシップテストはまず、 :meth:`__iter__` "
"を使った反復を試みます、次に古いシーケンス反復プロトコル :meth:`__getitem__` を使います、 :ref:`言語レファレンスのこの節 "
"<membership-test-details>` を参照して下さい。"

#: ../../reference/datamodel.rst:2296
msgid "Emulating numeric types"
msgstr "数値型をエミュレートする"

#: ../../reference/datamodel.rst:2298
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of"
" number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""
"以下のメソッドを定義して、数値型オブジェクトをエミュレートすることができます。特定の種類の数値型ではサポートされていないような演算に対応するメソッド "
"(非整数の数値に対するビット単位演算など) は、未定義のままにしておかなければなりません。"

#: ../../reference/datamodel.rst:2324
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to"
" evaluate the expression ``x + y``, where *x* is an instance of a class that"
" has an :meth:`__add__` method, ``x.__add__(y)`` is called.  The "
":meth:`__divmod__` method should be the equivalent to using "
":meth:`__floordiv__` and :meth:`__mod__`; it should not be related to "
":meth:`__truediv__`.  Note that :meth:`__pow__` should be defined to accept "
"an optional third argument if the ternary version of the built-in "
":func:`pow` function is to be supported."
msgstr ""
"これらのメソッドを呼んで二項算術演算子 (``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) を実装します。\n"
"例えば *x* が :meth:`__add__` メソッドのあるクラスのインスタンスである場合、式 ``x + y`` を評価すると ``x.__add__(y)`` が呼ばれます。\n"
":meth:`__divmod__` メソッドは :meth:`__floordiv__` と :meth:`__mod__` を使用するのと等価でなければなりません。\n"
":meth:`__truediv__` と関連してはなりません。\n"
"組み込みの :func:`pow` 関数の三項のものがサポートされていなければならない場合、 :meth:`__pow__` はオプションの第三引数を受け取るものとして定義されなければなりません。"

#: ../../reference/datamodel.rst:2335
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr "これらのメソッドのいずれかが渡された引数に対する操作を提供していない場合、 ``NotImplemented`` を返すべきです。"

#: ../../reference/datamodel.rst:2358
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected "
"(swapped) operands.  These functions are only called if the left operand "
"does not support the corresponding operation [#]_ and the operands are of "
"different types. [#]_ For instance, to evaluate the expression ``x - y``, "
"where *y* is an instance of a class that has an :meth:`__rsub__` method, "
"``y.__rsub__(x)`` is called if ``x.__sub__(y)`` returns *NotImplemented*."
msgstr ""
"これらのメソッドを呼んで二項算術演算 (``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) の、被演算子が反射した (入れ替えられた) ものを実装します。\n"
"これらの関数は、左側の被演算子が対応する演算をサポートしておらず  [#]_  、非演算子が異なる型の場合にのみ呼び出されます。 [#]_\n"
"例えば、 *y* が :meth:`__rsub__` メソッドのあるクラスのインスタンスである場合、 式 ``x - y`` を評価すると ``x.__sub__(y)`` が *NotImplemented* を返すときは ``y.__rsub__(x)`` が呼ばれます。"

#: ../../reference/datamodel.rst:2369
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""
"ただし、三項演算子 :func:`pow` が :meth:`__rpow__` を呼ぶことはないので注意してください "
"(型強制の規則が非常に難解になるからです)。"

#: ../../reference/datamodel.rst:2374
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides the reflected method for the operation, this method "
"will be called before the left operand's non-reflected method.  This "
"behavior allows subclasses to override their ancestors' operations."
msgstr ""
"右側の被演算子の型が左側の被演算子の型のサブクラスであり、このサブクラスであるメソッドに対する反射メソッドが定義されている場合には、左側の被演算子の非反射メソッドが呼ばれる前に、このメソッドが呼ばれます。この振る舞いにより、サブクラスが親の演算をオーバーライドすることが可能になります。"

#: ../../reference/datamodel.rst:2394
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, "
"``>>=``, ``&=``, ``^=``, ``|=``).  These methods should attempt to do the "
"operation in-place (modifying *self*) and return the result (which could be,"
" but does not have to be, *self*).  If a specific method is not defined, the"
" augmented assignment falls back to the normal methods.  For instance, if "
"*x* is an instance of a class with an :meth:`__iadd__` method, ``x += y`` is"
" equivalent to ``x = x.__iadd__(y)`` . Otherwise, ``x.__add__(y)`` and "
"``y.__radd__(x)`` are considered, as with the evaluation of ``x + y``. In "
"certain situations, augmented assignment can result in unexpected errors "
"(see :ref:`faq-augmented-assignment-tuple-error`), but this behavior is in "
"fact part of the data model."
msgstr ""
"これらのメソッドを呼び出して累算算術代入 (``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``) を実装します。\n"
"これらのメソッドは演算をインプレースで (*self* を変更する) 行うよう試み、その結果 (その必要はありませんが *self* でも構いません) を返さなければなりません。\n"
"特定のメソッドが定義されていない場合、その累算算術演算は通常のメソッドにフォールバックされます。\n"
"例えば *x* が :meth:`__iadd__` メソッドを持つクラスのインスタンスである場合、``x += y`` は ``x = x.__iadd__(y)`` と等価です。\n"
"そうでない場合、``x + y`` の評価と同様に ``x.__add__(y)`` と ``y.__radd__(x)`` が考慮されます。\n"
"特定の状況では、累算代入は予期しないエラーに終わるかもしれません (:ref:`faq-augmented-assignment-tuple-error` を参照してください) が、この挙動は実際はデータモデルの挙動の一部です。"

#: ../../reference/datamodel.rst:2415
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, "
":func:`abs` and ``~``)."
msgstr "呼び出して単項算術演算 (``-``, ``+``, :func:`abs` および ``~``) を実装します。"

#: ../../reference/datamodel.rst:2428
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` and "
":func:`float`.  Should return a value of the appropriate type."
msgstr ""
"組み込み関数の :func:`complex`, :func:`int`, :func:`float` の実装から呼び出されます。\n"
"適切な型の値を返さなければなりません。"

#: ../../reference/datamodel.rst:2435
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is an "
"integer type.  Must return an integer."
msgstr ""
"呼び出して :func:`operator.index` を実装します。\n"
"Python が数値オブジェクトを整数オブジェクトに損失なく変換する必要がある場合 (たとえばスライシングや、組み込みの :func:`bin` 、 :func:`hex` 、 :func:`oct` 関数) は常に呼び出されます。\n"
"このメソッドがあるとその数値オブジェクトが整数型であることが示唆されます。\n"
"整数を返さなければなりません。"

#: ../../reference/datamodel.rst:2441
msgid ""
"If :meth:`__int__`, :meth:`__float__` and :meth:`__complex__` are not "
"defined then corresponding built-in functions :func:`int`, :func:`float` and"
" :func:`complex` fall back to :meth:`__index__`."
msgstr ""

#: ../../reference/datamodel.rst:2453
msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and :func:`~math.ceil`. "
"Unless *ndigits* is passed to :meth:`!__round__` all these methods should "
"return the value of the object truncated to an :class:`~numbers.Integral` "
"(typically an :class:`int`)."
msgstr ""
"組み込み関数の :func:`round` と :mod:`math` モジュール関数の :func:`~math.trunc`, :func:`~math.floor`, :func:`~math.ceil` の実装から呼び出されます。\n"
"*ndigits* が :meth:`!__round__` に渡されない限りは、これらの全てのメソッドは :class:`~numbers.Integral` (たいていは :class:`int`) に切り詰められたオブジェクトの値を返すべきです。"

#: ../../reference/datamodel.rst:2459
msgid ""
"If :meth:`__int__` is not defined then the built-in function :func:`int` "
"falls back to :meth:`__trunc__`."
msgstr ""
":meth:`__int__` が定義されていない場合は、組み込み関数の :func:`int` は :meth:`__trunc__` "
"へフォールバックされます。"

#: ../../reference/datamodel.rst:2466
msgid "With Statement Context Managers"
msgstr "with文とコンテキストマネージャ"

#: ../../reference/datamodel.rst:2468
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be"
" established when executing a :keyword:`with` statement. The context manager"
" handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`!with` statement (described in section :ref:`with`), but"
" can also be used by directly invoking their methods."
msgstr ""
"コンテキストマネージャ(:dfn:`context manager`) とは、 :keyword:`with` "
"文の実行時にランタイムコンテキストを定義するオブジェクトです。コンテキストマネージャは、コードブロックを実行するために必要な入り口および出口の処理を扱います。コンテキストマネージャは通常、"
" :keyword:`!with` 文（ :ref:`with` "
"の章を参照）により起動されますが、これらのメソッドを直接呼び出すことで起動することもできます。"

#: ../../reference/datamodel.rst:2479
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""
"コンテキストマネージャの代表的な使い方としては、様々なグローバル情報の保存および更新、リソースのロックとアンロック、ファイルのオープンとクローズなどが挙げられます。"

#: ../../reference/datamodel.rst:2482
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`."
msgstr "コンテキストマネージャについてのさらなる情報については、 :ref:`typecontextmanager` を参照してください。"

#: ../../reference/datamodel.rst:2487
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in"
" the :keyword:`!as` clause of the statement, if any."
msgstr ""
"コンテキストマネージャのの入り口で実行される処理です。 :keyword:`with` 文は、文の :keyword:`!as` "
"節で規定された値を返すこのメソッドを呼び出します。"

#: ../../reference/datamodel.rst:2494
msgid ""
"Exit the runtime context related to this object. The parameters describe the"
" exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""
"コンテキストマネージャの出口で実行される処理です。パラメータは、コンテキストが終了した原因となった例外について説明しています。コンテキストが例外を送出せず終了した場合は、全ての引き数に"
" :const:`None` が設定されます。"

#: ../../reference/datamodel.rst:2498
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception"
" (i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""
"もし、例外が送出され、かつメソッドが例外を抑制したい場合（すなわち、例外が伝播されるのを防ぎたい場合）、このメソッドは True "
"を返す必要があります。そうでなければ、このメソッドの終了後、例外は通常通り伝播することになります。"

#: ../../reference/datamodel.rst:2502
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ":meth:`__exit__` メソッドは受け取った例外を再度送出すべきではありません。これは、呼び出し側の責任でおこなってください。"

#: ../../reference/datamodel.rst:2509
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" 文"

#: ../../reference/datamodel.rst:2509
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python の :keyword:`with` 文の仕様、背景、および例が記載されています。"

#: ../../reference/datamodel.rst:2516
msgid "Special method lookup"
msgstr "特殊メソッド検索"

#: ../../reference/datamodel.rst:2518
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""
"カスタムクラスでは、特殊メソッドの暗黙の呼び出しは、オブジェクトのインスタンス辞書ではなく、オブジェクトの型で定義されているときにのみ正しく動作することが保証されます。この動作のため、以下のコードは例外を送出します::"

#: ../../reference/datamodel.rst:2533
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`__hash__` and :meth:`__repr__` that are implemented by all "
"objects, including type objects. If the implicit lookup of these methods "
"used the conventional lookup process, they would fail when invoked on the "
"type object itself::"
msgstr ""
"この動作の背景となる理由は、 :meth:`__hash__` と :meth:`__repr__` といった type "
"オブジェクトを含むすべてのオブジェクトで定義されている特殊メソッドにあります。これらのメソッドの暗黙の検索が通常の検索プロセスを使った場合、 type "
"オブジェクト自体に対して実行されたときに失敗してしまいます::"

#: ../../reference/datamodel.rst:2546
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is"
" sometimes referred to as 'metaclass confusion', and is avoided by bypassing"
" the instance when looking up special methods::"
msgstr ""
"クラスの非結合メソッドをこのようにして実行しようとすることは、'metaclass confusion' "
"と呼ばれることもあり、特殊メソッドを検索するときはインスタンスをバイパスすることで回避されます::"

#: ../../reference/datamodel.rst:2555
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the "
":meth:`__getattribute__` method even of the object's metaclass::"
msgstr ""
"正確性のためにインスタンス属性をスキップするのに加えて、特殊メソッド検索はオブジェクトのメタクラスを含めて、 "
":meth:`__getattribute__` メソッドもバイパスします::"

#: ../../reference/datamodel.rst:2581
msgid ""
"Bypassing the :meth:`__getattribute__` machinery in this fashion provides "
"significant scope for speed optimisations within the interpreter, at the "
"cost of some flexibility in the handling of special methods (the special "
"method *must* be set on the class object itself in order to be consistently "
"invoked by the interpreter)."
msgstr ""
"このように :meth:`__getattribute__` 機構をバイパスすることで、特殊メソッドの扱いに関するある程度の自由度と引き換えに "
"(特殊メソッドはインタプリタから一貫して実行されるためにクラスオブジェクトに設定 "
"*しなければならない*)、インタープリタを高速化するための大きな余地が手に入ります。"

#: ../../reference/datamodel.rst:2592
msgid "Coroutines"
msgstr "コルーチン"

#: ../../reference/datamodel.rst:2596
msgid "Awaitable Objects"
msgstr "待機可能オブジェクト (Awaitable Object)"

#: ../../reference/datamodel.rst:2598
msgid ""
"An :term:`awaitable` object generally implements an :meth:`__await__` "
"method. :term:`Coroutine` objects returned from :keyword:`async def` "
"functions are awaitable."
msgstr ""
":term:`awaitable` オブジェクトは一般的には :meth:`__await__` が実装されています。\n"
":keyword:`async def` 関数が返す :term:`Coroutine` オブジェクトは待機可能です。"

#: ../../reference/datamodel.rst:2604
msgid ""
"The :term:`generator iterator` objects returned from generators decorated "
"with :func:`types.coroutine` or :func:`asyncio.coroutine` are also "
"awaitable, but they do not implement :meth:`__await__`."
msgstr ""
":func:`types.coroutine` デコレータもしくは :func:`asyncio.coroutine` "
"でデコレータが付けられたジェネレータから返される :term:`generator iterator` オブジェクトも待機可能ですが、 "
":meth:`__await__` は実装されていません。"

#: ../../reference/datamodel.rst:2610
msgid ""
"Must return an :term:`iterator`.  Should be used to implement "
":term:`awaitable` objects.  For instance, :class:`asyncio.Future` implements"
" this method to be compatible with the :keyword:`await` expression."
msgstr ""
":term:`iterator` を返さなければなりません。\n"
"このメソッドは :term:`awaitable` オブジェクトを実装するのに使われるべきです。\n"
"簡単のために、 :class:`asyncio.Future` にはこのメソッドが実装され、 :keyword:`await` 式と互換性を持つようになっています。"

#: ../../reference/datamodel.rst:2616
msgid ":pep:`492` for additional information about awaitable objects."
msgstr "待機可能オブジェクトについてより詳しくは :pep:`492` を参照してください。"

#: ../../reference/datamodel.rst:2622
msgid "Coroutine Objects"
msgstr "コルーチンオブジェクト"

#: ../../reference/datamodel.rst:2624
msgid ""
":term:`Coroutine` objects are :term:`awaitable` objects. A coroutine's "
"execution can be controlled by calling :meth:`__await__` and iterating over "
"the result.  When the coroutine has finished executing and returns, the "
"iterator raises :exc:`StopIteration`, and the exception's "
":attr:`~StopIteration.value` attribute holds the return value.  If the "
"coroutine raises an exception, it is propagated by the iterator.  Coroutines"
" should not directly raise unhandled :exc:`StopIteration` exceptions."
msgstr ""
":term:`Coroutine` オブジェクトは :term:`awaitable` オブジェクトです。\n"
":meth:`__await__` を呼び出し、その返り値に対し反復処理をすることでコルーチンの実行を制御できます。\n"
"コルーチンの実行が完了し制御を戻したとき、イテレータは :exc:`StopIteration` を送出し、その例外の :attr:`~StopIteration.value` 属性に返り値を持たせます。\n"
"コルーチンが例外を送出した場合は、イテレータにより伝搬されます。\n"
"コルーチンから :exc:`StopIteration` 例外を外に送出すべきではありません。"

#: ../../reference/datamodel.rst:2632
msgid ""
"Coroutines also have the methods listed below, which are analogous to those "
"of generators (see :ref:`generator-methods`).  However, unlike generators, "
"coroutines do not directly support iteration."
msgstr ""
"コルーチンには以下に挙げるメソッドもあり、これらはジェネレータのメソッドからの類似です (:ref:`generator-methods` を参照してください)。\n"
"ただし、ジェネレータと違って、コルーチンは反復処理を直接はサポートしていません。"

#: ../../reference/datamodel.rst:2636
msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr "コルーチンで2回以上待機 (await) すると :exc:`RuntimeError` となります。"

#: ../../reference/datamodel.rst:2642
msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, this "
"is equivalent to advancing the iterator returned by :meth:`__await__`.  If "
"*value* is not ``None``, this method delegates to the "
":meth:`~generator.send` method of the iterator that caused the coroutine to "
"suspend.  The result (return value, :exc:`StopIteration`, or other "
"exception) is the same as when iterating over the :meth:`__await__` return "
"value, described above."
msgstr ""
"コルーチンの実行を開始したり再開したりします。\n"
"*value* が ``None`` の場合は、 :meth:`__await__` から返されたイテレータを進めるのと同等です。\n"
"*value* が ``None`` でない場合は、このコルーチンを一時停止させたイテレータの :meth:`~generator.send` メソッドに処理を委任します。\n"
"結果 (返り値か :exc:`StopIteration` かその他の例外) は、上で解説したような :meth:`__await__` の返り値に対して反復処理を行ったときと同じです。"

#: ../../reference/datamodel.rst:2652
msgid ""
"Raises the specified exception in the coroutine.  This method delegates to "
"the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception is "
"raised at the suspension point.  The result (return value, "
":exc:`StopIteration`, or other exception) is the same as when iterating over"
" the :meth:`__await__` return value, described above.  If the exception is "
"not caught in the coroutine, it propagates back to the caller."
msgstr ""
"コルーチンで指定された例外を送出します。\n"
"このメソッドは、イテレータにコルーチンを一時停止する :meth:`~generator.throw` メソッドがある場合に処理を委任します。\n"
"そうでない場合には、中断した地点から例外が送出されます。\n"
"結果 (返り値か :exc:`StopIteration` かその他の例外) は、上で解説したような :meth:`__await__` の返り値に対して反復処理を行ったときと同じです。\n"
"例外がコルーチンの中で捕捉されなかった場合、呼び出し元へ伝搬されます。"

#: ../../reference/datamodel.rst:2663
msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has such "
"a method.  Then it raises :exc:`GeneratorExit` at the suspension point, "
"causing the coroutine to immediately clean itself up. Finally, the coroutine"
" is marked as having finished executing, even if it was never started."
msgstr ""
"コルーチンが自分自身の後片付けをし終了します。\n"
"コルーチンが一時停止している場合は、コルーチンを一時停止させたイテレータに :meth:`~generator.close` メソッドがあれば、まずはそれに処理を委任します。\n"
"そして一時停止した地点から :exc:`GeneratorExit` が送出され、ただちにコルーチンが自分自身の後片付けを行います。\n"
"最後に、実行が開始されていなかった場合でも、コルーチンに実行が完了した印を付けます。"

#: ../../reference/datamodel.rst:2671
msgid ""
"Coroutine objects are automatically closed using the above process when they"
" are about to be destroyed."
msgstr "コルーチンオブジェクトが破棄されるときには、上記の手順を経て自動的に閉じられます。"

#: ../../reference/datamodel.rst:2677
msgid "Asynchronous Iterators"
msgstr "非同期イテレータ (Asynchronous Iterator)"

#: ../../reference/datamodel.rst:2679
msgid ""
"An *asynchronous iterator* can call asynchronous code in its ``__anext__`` "
"method."
msgstr "*非同期イテレータ* の ``__anext__`` メソッドからは非同期のコードが呼べます。"

#: ../../reference/datamodel.rst:2682
msgid ""
"Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr "非同期イテレータは :keyword:`async for` 文の中で使えます。"

#: ../../reference/datamodel.rst:2686
msgid "Must return an *asynchronous iterator* object."
msgstr "*非同期イテレータ* オブジェクトを返さなくてはなりません。"

#: ../../reference/datamodel.rst:2690
msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is over."
msgstr ""
"イテレータの次の値を返す *待機可能オブジェクト* を返さなければなりません。\n"
"反復処理が終了したときには :exc:`StopAsyncIteration` エラーを送出すべきです。"

#: ../../reference/datamodel.rst:2693
msgid "An example of an asynchronous iterable object::"
msgstr "非同期イテラブルオブジェクトの例::"

#: ../../reference/datamodel.rst:2710
msgid ""
"Prior to Python 3.7, ``__aiter__`` could return an *awaitable* that would "
"resolve to an :term:`asynchronous iterator <asynchronous iterator>`."
msgstr ""
"Python 3.7 より前では、 ``__aiter__`` は :term:`非同期イテレータ <asynchronous iterator>` "
"になる *awaitable* を返せました。"

#: ../../reference/datamodel.rst:2715
msgid ""
"Starting with Python 3.7, ``__aiter__`` must return an asynchronous iterator"
" object.  Returning anything else will result in a :exc:`TypeError` error."
msgstr ""
"Python 3.7 からは、 ``__aiter__`` は非同期イテレータオブジェクトを返さなければなりません。\n"
"それ以外のものを返すと :exc:`TypeError` になります。"

#: ../../reference/datamodel.rst:2723
msgid "Asynchronous Context Managers"
msgstr "非同期コンテキストマネージャ (Asynchronous Context Manager)"

#: ../../reference/datamodel.rst:2725
msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""
"*非同期コンテキストマネージャ* は、 ``__aenter__`` メソッドと ``__aexit__`` メソッド内部で実行を一時停止できる "
"*コンテキストマネージャ* です。"

#: ../../reference/datamodel.rst:2728
msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr "非同期コンテキストマネージャは :keyword:`async with` 文の中で使えます。"

#: ../../reference/datamodel.rst:2732
msgid ""
"Semantically similar to :meth:`__enter__`, the only difference being that it"
" must return an *awaitable*."
msgstr ""

#: ../../reference/datamodel.rst:2737
msgid ""
"Semantically similar to :meth:`__exit__`, the only difference being that it "
"must return an *awaitable*."
msgstr ""

#: ../../reference/datamodel.rst:2740
msgid "An example of an asynchronous context manager class::"
msgstr "非同期コンテキストマネージャクラスの例::"

#: ../../reference/datamodel.rst:2753
msgid "Footnotes"
msgstr "脚注"

#: ../../reference/datamodel.rst:2754
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"特定の条件が満たされた場合、オブジェクトの type を変更することが *できます* "
"。これは、正しく扱われなかった場合にとても奇妙な動作を引き起こすので、一般的には良い考えではありません。"

#: ../../reference/datamodel.rst:2758
msgid ""
"The :meth:`__hash__`, :meth:`__iter__`, :meth:`__reversed__`, and "
":meth:`__contains__` methods have special handling for this; others will "
"still raise a :exc:`TypeError`, but may do so by relying on the behavior "
"that ``None`` is not callable."
msgstr ""
":meth:`__hash__`, :meth:`__iter__`, :meth:`__reversed__`, :meth:`__contains__` メソッドはこのような特別な扱われ方をします;\n"
"他の特殊メソッドも :exc:`TypeError` を送出するかもしれませんが、これは ``None`` が呼び出し可能でないという振る舞いに基づいた動作です。"

#: ../../reference/datamodel.rst:2763
msgid ""
"\"Does not support\" here means that the class has no such method, or the "
"method returns ``NotImplemented``.  Do not set the method to ``None`` if you"
" want to force fallback to the right operand's reflected method—that will "
"instead have the opposite effect of explicitly *blocking* such fallback."
msgstr ""
"ここでの \"サポートしていない\" というのは、クラスがそのメソッドを持っていないか、そのメソッドが ``NotImplemented`` を返すという意味です。\n"
"右の被演算子の対をなすメソッドへ処理を回したい場合には、メソッドに ``None`` を設定してはいけません—こうするとむしろ、処理を回すのを明示的に *妨げる* という正反対の効果を生みます。"

#: ../../reference/datamodel.rst:2769
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method (such as :meth:`__add__`) fails the operation is not supported, which"
" is why the reflected method is not called."
msgstr ""
"同じ型の被演算子については、無反転のメソッド (たとえば :meth:`__add__`) が失敗した場合、その演算はサポートされていないとみなされます。\n"
"これは、反射したメソッドが呼び出されないためです。"
