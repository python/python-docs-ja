# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# cocoatomo, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2015-2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2018-01-25 02:06+0000\n"
"Last-Translator: cocoatomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr "データモデル"

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "オブジェクト、値、および型"

#: ../../reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer,\" code is also represented by objects.)"
msgstr "Python における :dfn:`オブジェクト (object)` とは、データを抽象的に表したものです。Python プログラムにおけるデータは全て、オブジェクトまたはオブジェクト間の関係として表されます。(ある意味では、プログラムコードもまたオブジェクトとして表されます。これはフォン・ノイマン: Von Neumann の \"プログラム記憶方式コンピュータ: stored program computer\" のモデルに適合します。)"

#: ../../reference/datamodel.rst:32
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The ':keyword:`is`' operator compares the identity of "
"two objects; the :func:`id` function returns an integer representing its "
"identity (currently implemented as its address). An object's :dfn:`type` is "
"also unchangeable. [#]_ An object's type determines the operations that the "
"object supports (e.g., \"does it have a length?\") and also defines the "
"possible values for objects of that type.  The :func:`type` function returns"
" an object's type (which is an object itself).  The *value* of some objects "
"can change.  Objects whose value can change are said to be *mutable*; "
"objects whose value is unchangeable once they are created are called "
"*immutable*. (The value of an immutable container object that contains a "
"reference to a mutable object can change when the latter's value is changed;"
" however the container is still considered immutable, because the collection"
" of objects it contains cannot be changed.  So, immutability is not strictly"
" the same as having an unchangeable value, it is more subtle.) An object's "
"mutability is determined by its type; for instance, numbers, strings and "
"tuples are immutable, while dictionaries and lists are mutable."
msgstr "オブジェクトはアイデンティティ値 (identity) 、型 (type) 、そして値 (value) を持ちます。オブジェクトが一度生成されると、そのオブジェクトの *アイデンティティ値* は決して変化することがありません; アイデンティティ値をオブジェクトのメモリ上のアドレスと考えてもかまいません。演算子 ':keyword:`is`' は、二つのオブジェクト間のアイデンティティ値を比較します; 関数 :func:`id` は、オブジェクトのアイデンティティ値を表す整数 (現在の実装ではオブジェクトのメモリ上のアドレス) を返します。オブジェクトの :dfn:`型` もまた変わることがありません。 [#]_ オブジェクトの型は、そのオブジェクトのサポートする操作 (\"長さを持っているか？\" など) を決定し、その型のオブジェクトが取りうる値について定義しています。 :func:`type` 関数は、オブジェクトの型 (型自体も一つのオブジェクトです) を返します。オブジェクトによっては、 *値 (value)* を変えることができます。値を変えることができるオブジェクトは *変更可能 (mutable)* であるといいます; 値を一度設定すると、その後は変えることができないオブジェクトは *変更不能 (immutable)* であると呼びます。 (変更不能なコンテナオブジェクトが変更可能なオブジェクトへの参照を含んでいる場合、その値は後者のオブジェクトの変更によって変わる場合があります; その場合でも、コンテナの含んでいるオブジェクトの集まりは変わらないため、コンテナは変更不能と考えます。したがって、変更不能性 (immutability) は、厳密には変更できない値を持っていることとは違い、もっと微妙な概念です。) オブジェクトの変更可能性は型で決定されます; 例えば、数値、文字列、およびタプルは変更不能であり、辞書やリストは変更可能です。"

#: ../../reference/datamodel.rst:55
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr "オブジェクトを明示的に破壊することはできません; しかし、オブジェクトに到達不能 (unreachable) になると、ガベージコレクション (garbage-collection) によって処理されます。実装では、ごみ収集を遅らせたり、全く行わないようにすることができます --- 到達可能なオブジェクトをごみ収集処理してしまわないかぎり、どう実装するかは実装品質の問題です。"

#: ../../reference/datamodel.rst:63
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (ex: "
"always close files)."
msgstr "現在の CPython 実装では参照カウント(reference-counting) 方式を使っており、(オプションとして) 循環参照を行っているごみオブジェクトを遅延検出します。この実装ではほとんどのオブジェクトを到達不能になると同時に処理することができますが、循環参照を含むごみオブジェクトの収集が確実に行われるよう保証しているわけではありません。循環参照を持つごみオブジェクト収集の制御については、 :mod:`gc` モジュールを参照してください。 CPython以外の実装は別の方式を使っており、CPythonも将来は別の方式を使うかもしれません。オブジェクトが到達不能になったときに即座に終了処理されることに頼らないでください (例えば、ファイルは必ず閉じてください)。"

#: ../../reference/datamodel.rst:72
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a ':keyword:`try`...\\ :keyword:`except`' "
"statement may keep objects alive."
msgstr "実装のトレース機能やデバッグ機能を使えば、通常は収集されてしまうようなオブジェクトを生かしておくことがあるので注意してください。また、 ':keyword:`try`...\\ :keyword:`except`' 文を使って例外を捕捉できるようにすると、オブジェクトを生かしておくことがあります。"

#: ../../reference/datamodel.rst:77
msgid ""
"Some objects contain references to \"external\" resources such as open files"
" or windows.  It is understood that these resources are freed when the "
"object is garbage-collected, but since garbage collection is not guaranteed "
"to happen, such objects also provide an explicit way to release the external"
" resource, usually a :meth:`close` method. Programs are strongly recommended"
" to explicitly close such objects.  The ':keyword:`try`...\\ "
":keyword:`finally`' statement provides a convenient way to do this."
msgstr "オブジェクトによっては、開かれたファイルやウィンドウといった、 \"外部 (external) の\" リソースに対する参照を行っています。これらのリソースは、オブジェクトがごみ収集された際に解放されるものと理解されていますが、ごみ収集が行われる保証はないので、こうしたオブジェクトでは外部リソースを明示的に解放する方法、大抵は :meth:`close` メソッドを提供しています。こうしたオブジェクトは明示的に close するよう強く奨めます。操作をする際には、':keyword:`try`...\\ :keyword:`finally`' 文を使うと便利です。"

#: ../../reference/datamodel.rst:87
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk"
" about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr "他のオブジェクトに対する参照をもつオブジェクトもあります; これらは *コンテナ (container)* と呼ばれます。コンテナオブジェクトの例として、タプル、リスト、および辞書が挙げられます。オブジェクトへの参照自体がコンテナの値の一部です。ほとんどの場合、コンテナの値というと、コンテナに入っているオブジェクトの値のことを指し、それらオブジェクトのアイデンティティではありません; しかしながら、コンテナの変更可能性について述べる場合、今まさにコンテナに入っているオブジェクトのアイデンティティのことを指します。したがって、 (タプルのように) 変更不能なオブジェクトが変更可能なオブジェクトへの参照を含む場合、その値が変化するのは変更可能なオブジェクトが変更された時、ということになります。"

#: ../../reference/datamodel.rst:96
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer"
" to the same object with the value one, depending on the implementation, but"
" after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two "
"different, unique, newly created empty lists. (Note that ``c = d = []`` "
"assigns the same object to both ``c`` and ``d``.)"
msgstr "型はオブジェクトの動作のほとんど全てに影響します。オブジェクトのアイデンティティが重要かどうかでさえ、ある意味では型に左右されます: 変更不能な型では、新たな値を計算するような操作を行うと、実際には同じ型と値を持った既存のオブジェクトへの参照を返すことがありますが、変更可能なオブジェクトではそのような動作は起こりえません。例えば、 ``a = 1; b = 1`` とすると、 ``a`` と ``b`` は値 1 を持つ同じオブジェクトを参照するときもあるし、そうでないときもあります。これは実装に依存します。しかし、 ``c = []; d = []`` とすると、 ``c`` と ``d`` はそれぞれ二つの異なった、互いに一意な、新たに作成された空のリストを参照することが保証されています。 (``c = d = []`` とすると、 ``c`` と ``d`` の両方に同じオブジェクトを代入します)"

#: ../../reference/datamodel.rst:110
msgid "The standard type hierarchy"
msgstr "標準型の階層"

#: ../../reference/datamodel.rst:119
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the"
" type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.)."
msgstr "以下は Python に組み込まれている型のリストです。(C、Java、または実装に使われているその他の言語で書かれた) 拡張モジュールでは、その他に新たな型を定義することができます。将来のバージョンの Python では、型の階層に新たな型 (整数を使って効率的に記憶される有理数型、など) を追加することができるかもしれません。"

#: ../../reference/datamodel.rst:129
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation"
" and are not intended for general use.  Their definition may change in the "
"future."
msgstr "以下に説明する型のいくつかには、'特殊属性 (special attribute)' と題された段落が連ねられています。これらの属性は実装へのアクセス手段を提供するもので、一般的な用途に利用するためのものではありません。特殊属性の定義は将来変更される可能性があります。"

#: ../../reference/datamodel.rst:139
msgid "None"
msgstr "None"

#: ../../reference/datamodel.rst:136
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from"
" functions that don't explicitly return anything. Its truth value is false."
msgstr "この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトは組み込み名 ``None`` でアクセスされます。このオブジェクトは、様々な状況で値が存在しないことをしめします。例えば、明示的に値を返さない関数は ``None`` を返します。 ``None`` の真値 (truth value) は偽 (false) です。"

#: ../../reference/datamodel.rst:149
msgid "NotImplemented"
msgstr "NotImplemented"

#: ../../reference/datamodel.rst:144
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods may return this value if they do"
" not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  Its truth value is true."
msgstr "この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトは組み込み名 ``NotImplemented`` でアクセスされます。数値演算に関するメソッドや拡張比較 (rich comparison) メソッドは、被演算子が該当する演算を行うための実装をもたない場合、この値を返すことがあります。(演算子によっては、インタプリタが関連のある演算を試したり、他の代替操作を行います。) 真値は真 (true) です。"

#: ../../reference/datamodel.rst:157
msgid "Ellipsis"
msgstr "Ellipsis"

#: ../../reference/datamodel.rst:154
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``Ellipsis``. It is used "
"to indicate the presence of the ``...`` syntax in a slice.  Its truth value "
"is true."
msgstr "この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトは組み込み名 ``Ellipsis`` でアクセスされます。スライス内に ``...`` 構文がある場合に使われます。真値は真 (true)です。"

#: ../../reference/datamodel.rst:249
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../../reference/datamodel.rst:162
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable;"
" once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr "数値リテラルによって作成されたり、算術演算や組み込みの算術関数によって返されるオブジェクトです。数値オブジェクトは変更不能です; 一度値が生成されると、二度と変更されることはありません。Python の数値オブジェクトはいうまでもなく数学で言うところの数値と強く関係していますが、コンピュータ内で数値を表現する際に伴う制限を受けています。"

#: ../../reference/datamodel.rst:168
msgid ""
"Python distinguishes between integers, floating point numbers, and complex "
"numbers:"
msgstr "Python は整数、浮動小数点数、複素数の間で区別を行っています:"

#: ../../reference/datamodel.rst:224
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral` (整数)"

#: ../../reference/datamodel.rst:174
msgid ""
"These represent elements from the mathematical set of integers (positive and"
" negative)."
msgstr "整数型は、整数(正の数および負の数)を表す数学的集合内における要素を表現する型です。"

#: ../../reference/datamodel.rst:177
msgid "There are three types of integers:"
msgstr "以下に三つの整数型を示します:"

#: ../../reference/datamodel.rst:192
msgid "Plain integers"
msgstr "(通常の) 整数型 (plain integer)"

#: ../../reference/datamodel.rst:184
msgid ""
"These represent numbers in the range -2147483648 through 2147483647. (The "
"range may be larger on machines with a larger natural word size, but not "
"smaller.)  When the result of an operation would fall outside this range, "
"the result is normally returned as a long integer (in some cases, the "
"exception :exc:`OverflowError` is raised instead).  For the purpose of shift"
" and mask operations, integers are assumed to have a binary, 2's complement "
"notation using 32 or more bits, and hiding no bits from the user (i.e., all "
"4294967296 different bit patterns correspond to different values)."
msgstr "-2147483648 から 2147483647 までの整数を表現します (基本ワードサイズ: natural word size がより大きなマシンではより大きな定義域になることもあります。より小さくなることはありません。) 演算の結果が定義域を超えた値になった場合、結果は通常長整数で返されます (場合によっては、 :exc:`OverflowError` が送出されます) 。シフト演算やマスク演算のために、整数は 32 ビット以上の 2 の補数で表されたバイナリ表現を持つ (すなわち、4294967296 の異なったビットパターン全てが異なる値を持つ) と仮定されています。"

#: ../../reference/datamodel.rst:201
msgid "Long integers"
msgstr "長整数型 (long integer)"

#: ../../reference/datamodel.rst:197
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr "長整数は無限の定義域を持ち、利用可能な (仮想) メモリサイズの制限のみをうけます。長整数はシフト演算やマスク演算のためにバイナリ表現をもつものと仮定されます。負の数は符号ビットが左に無限に延びているような錯覚を与える 2 の補数表現の変型で表されます。"

#: ../../reference/datamodel.rst:214
msgid "Booleans"
msgstr "ブール型 (boolean)"

#: ../../reference/datamodel.rst:209
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects."
" The Boolean type is a subtype of plain integers, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception"
" being that when converted to a string, the strings ``\"False\"`` or "
"``\"True\"`` are returned, respectively."
msgstr "真偽値の False と True を表します。``False`` と ``True`` を表す 2 つのオブジェクトのみがブール値オブジェクトです。ブール型は整数型の部分型であり、ほとんどの状況でそれぞれ 0 と 1 のように振る舞いますが、例外として文字列に変換されたときはそれぞれ ``\"False\"`` および ``\"True\"`` という文字列が返されます。"

#: ../../reference/datamodel.rst:218
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers and the least surprises when switching between the plain and long "
"integer domains.  Any operation, if it yields a result in the plain integer "
"domain, will yield the same result in the long integer domain or when using "
"mixed operands.  The switch between domains is transparent to the "
"programmer."
msgstr "整数表現に関する規則は、シフト演算やマスク演算において、負の整数も含めて最も有意義な解釈ができるように、かつ通常の整数と長整数との間で定義域を切り替える際にできるだけ混乱しないように決められています。すべての演算で、演算結果がオーバフローを起こさずに整数の定義域の値になる場合は、長整数を使った場合でも、被演算子に整数と長整数を混合した場合でも同じ結果になります。定義域の切り替えはプログラマに対して透過的に(意識させることなく)行われます。"

#: ../../reference/datamodel.rst:239
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`) (実数)"

#: ../../reference/datamodel.rst:233
msgid ""
"These represent machine-level double precision floating point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does"
" not support single-precision floating point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to"
" complicate the language with two kinds of floating point numbers."
msgstr "この型は計算機レベルの倍精度浮動小数点数を表現します。表現可能な値の範囲やオーバーフローの扱いは計算機のアーキテクチャ（および、CやJavaによる実装）に従います。Pythonは単精度浮動小数点数をサポートしません。一般的に単精度浮動小数点数を使う理由はプロセッサーとメモリの使用を節約するためと説明されます。しかし、こうした節約はPythonでオブジェクトを扱う際のオーバーヘッドに比べれば微々たるものです。また、2種類の浮動小数点数型を持つことで複雑になる理由はありません。"

#: ../../reference/datamodel.rst:249
msgid ":class:`numbers.Complex`"
msgstr ":class:`numbers.Complex` (複素数)"

#: ../../reference/datamodel.rst:246
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating point numbers.  The same caveats apply as for floating point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr "この型は、計算機レベルで倍精度とされている浮動小数点を 2 つ一組にして複素数を表現します。浮動小数点について述べたのと同じ性質が当てはまります。複素数 ``z`` の実数部および虚数部は、それぞれ読み出し専用属性 ``z.real`` および ``z.imag`` で取り出すことができます。"

#: ../../reference/datamodel.rst:386
msgid "Sequences"
msgstr "シーケンス型 (sequence)"

#: ../../reference/datamodel.rst:259
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr "この型は、有限の順序集合 (ordered set) を表現します。要素は非負の整数でインデクス化されています。組み込み関数 :func:`len` を使うと、シーケンスの要素数を返します。シーケンスの長さが *n* の場合、インデクスは 0, 1, ..., *n* -1 からなる集合です。シーケンス *a* の要素 *i* は ``a[i]`` で選択します。"

#: ../../reference/datamodel.rst:266
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type.  This implies that the index set is renumbered "
"so that it starts at 0."
msgstr "シーケンスはスライス操作 (slice) もサポートしています: ``a[i:j]`` とすると、 *i* ``<=`` *k* ``<`` *j* であるインデクス *k* をもつ全ての要素を選択します。式表現としてスライスを用いた場合、スライスは同じ型をもつ新たなシーケンスを表します。新たなシーケンス内では、インデクス集合が 0 から始まるようにインデクスの値を振りなおします。"

#: ../../reference/datamodel.rst:273
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr "シーケンスによっては、第三の \"ステップ (step)\" パラメタを持つ \"拡張スライス (extended slice)\" もサポートしています: ``a[i:j:k]`` は、 ``x = i + n*k``, *n* ``>=`` ``0`` かつ *i* ``<=`` *x* ``<`` *j* であるようなインデクス *x* を持つような *a* 全ての要素を選択します。"

#: ../../reference/datamodel.rst:277
msgid "Sequences are distinguished according to their mutability:"
msgstr "シーケンスは、変更可能なものか、そうでないかで区別されています:"

#: ../../reference/datamodel.rst:352
msgid "Immutable sequences"
msgstr "変更不能なシーケンス (immutable sequence)"

#: ../../reference/datamodel.rst:284
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may"
" be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr "変更不能なシーケンス型のオブジェクトは、一度生成されるとその値を変更することができません。 (オブジェクトに他のオブジェクトへの参照が入っている場合、参照されているオブジェクトは変更可能なオブジェクトでもよく、その値は変更される可能性があります; しかし、変更不能なオブジェクトが直接参照しているオブジェクトの集合自体は、変更することができません。)"

#: ../../reference/datamodel.rst:289
msgid "The following types are immutable sequences:"
msgstr "以下の型は変更不能なシーケンス型です:"

#: ../../reference/datamodel.rst:319
msgid "Strings"
msgstr "文字列型 (string)"

#: ../../reference/datamodel.rst:300
msgid ""
"The items of a string are characters.  There is no separate character type; "
"a character is represented by a string of one item. Characters represent (at"
" least) 8-bit bytes.  The built-in functions :func:`chr` and :func:`ord` "
"convert between characters and nonnegative integers representing the byte "
"values.  Bytes with the values 0--127 usually represent the corresponding "
"ASCII values, but the interpretation of values is up to the program.  The "
"string data type is also used to represent arrays of bytes, e.g., to hold "
"data read from a file."
msgstr "文字列の各要素は文字 (character) です。文字型 (character type) は存在しません。単一の文字は、要素が一つだけの文字列として表現されます。各文字は(少なくとも)8-bit の 1 byte を表現します。組み込み関数 :func:`chr` および :func:`ord` を使うと、文字と非負の整数で表されたバイト値の間で変換を行えます。0--127 の値を持つバイト値は、通常同じ ASCII 値をもつ文字を表現していますが、値をどう解釈するかはプログラムにゆだねられています。文字列データ型はまた、例えばファイルから読み出されたデータを記憶するといった用途で、バイト値のアレイを表現するために用いられます。"

#: ../../reference/datamodel.rst:316
msgid ""
"(On systems whose native character set is not ASCII, strings may use EBCDIC "
"in their internal representation, provided the functions :func:`chr` and "
":func:`ord` implement a mapping between ASCII and EBCDIC, and string "
"comparison preserves the ASCII order. Or perhaps someone can propose a "
"better rule?)"
msgstr "(ネイティブの文字セットが ASCIIでないシステムでは、 :func:`chr` や :func:`ord` が ASCII と EBCDIC との間で対応付けを行っており、文字列間の比較で ASCII 順が守られる限り、文字列の内部表現として EBCDIC を使ってもかまいません。誰か他にもっとましなルールをお持ちですか?)"

#: ../../reference/datamodel.rst:340
msgid "Unicode"
msgstr "Unicode 文字列型"

#: ../../reference/datamodel.rst:331
msgid ""
"The items of a Unicode object are Unicode code units.  A Unicode code unit "
"is represented by a Unicode object of one item and can hold either a 16-bit "
"or 32-bit value representing a Unicode ordinal (the maximum value for the "
"ordinal is given in ``sys.maxunicode``, and depends on how Python is "
"configured at compile time).  Surrogate pairs may be present in the Unicode "
"object, and will be reported as two separate items.  The built-in functions "
":func:`unichr` and :func:`ord` convert between code units and nonnegative "
"integers representing the Unicode ordinals as defined in the Unicode "
"Standard 3.0. Conversion from and to other encodings are possible through "
"the Unicode method :meth:`encode` and the built-in function :func:`unicode`."
msgstr "Unicode オブジェクトの各要素は Unicode コード単位です。 Unicode コード単位とは、単一の Unicode オブジェクトで、Unicode 序数を表現する 16-bit または 32-bit の値を保持できるものです (この序数の最大値は ``sys.maxunicode`` で与えられており、コンパイル時に Python がどう設定されているかに依存します)。 Unicode オブジェクト内にサロゲートペア (surrogate pair) があってもよく、Python はサロゲートペアを二つの別々の Unicode 要素として報告します。組み込み関数 :func:`unichr` および :func:`ord` は、コード単位と非負の整数で表された Unicode 標準 3.0 で定義された Unicode 序数との間で変換を行います。他の文字エンコード形式との相互変換は、 Unicode メソッド :meth:`encode` および組み込み関数 :func:`unicode` で行うことができます。"

#: ../../reference/datamodel.rst:352
msgid "Tuples"
msgstr "タプル型 (tuple)"

#: ../../reference/datamodel.rst:348
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr "タプルの要素は任意の Python オブジェクトです。二つ以上の要素からなるタプルは、個々の要素を表現する式をカンマで区切って構成します。単一の要素からなるタプル (単集合 'singleton') を作るには、要素を表現する式の直後にカンマをつけます (単一の式だけではタプルを形成しません。これは、式をグループ化するのに丸括弧を使えるようにしなければならないからです)。要素の全くない丸括弧の対を作ると空のタプルになります。"

#: ../../reference/datamodel.rst:386
msgid "Mutable sequences"
msgstr "変更可能なシーケンス型 (mutable sequence)"

#: ../../reference/datamodel.rst:362
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and "
":keyword:`del` (delete) statements."
msgstr "変更可能なシーケンスは、作成した後で変更することができます。変更可能なシーケンスでは、添字表記やスライス表記を使って指定された要素に代入を行うことができ、 :keyword:`del` (delete) 文を使って要素を削除することができます。"

#: ../../reference/datamodel.rst:366
msgid "There are currently two intrinsic mutable sequence types:"
msgstr "Python に最初から組み込まれている変更可能なシーケンス型は、今のところ二つです:"

#: ../../reference/datamodel.rst:373
msgid "Lists"
msgstr "リスト型 (list)"

#: ../../reference/datamodel.rst:371
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that"
" there are no special cases needed to form lists of length 0 or 1.)"
msgstr "リストの要素は任意の Python オブジェクトにできます。リストは、角括弧の中にカンマで区切られた式を並べて作ります。 (長さが 0 や 1 のシーケンスを作るために特殊な場合分けは必要ないことに注意してください。)"

#: ../../reference/datamodel.rst:381
msgid "Byte Arrays"
msgstr "バイト配列"

#: ../../reference/datamodel.rst:378
msgid ""
"A bytearray object is a mutable array. They are created by the built-in "
":func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable bytes objects."
msgstr "bytearray オブジェクトは変更可能な配列です。組み込みの :func:`bytearray` コンストラクタによって作成されます。変更可能なことを除けば (つまりハッシュ化できない)、 byte array は変更不能な bytes オブジェクトと同じインターフェースと機能を提供します。"

#: ../../reference/datamodel.rst:385
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type."
msgstr "拡張モジュール :mod:`array` では、別の変更可能なシーケンス型を提供しています。"

#: ../../reference/datamodel.rst:420
msgid "Set types"
msgstr "集合型"

#: ../../reference/datamodel.rst:393
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated"
" over, and the built-in function :func:`len` returns the number of items in "
"a set. Common uses for sets are fast membership testing, removing duplicates"
" from a sequence, and computing mathematical operations such as "
"intersection, union, difference, and symmetric difference."
msgstr "集合型は、順序のない、ユニークで不変なオブジェクトの有限集合を表現します。そのため、(配列の)添字を使ったインデックスアクセスはできません。ただし、イテレートは可能で、組み込み関数 :func:`len` は集合の要素数を返します。集合型の一般的な使い方は、集合に属しているかの高速なテスト、シーケンスからの重複の排除、共通集合・和集合・差・対称差といった数学的な演算の計算です。"

#: ../../reference/datamodel.rst:400
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two"
" numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr "集合の要素には、辞書のキーと同じ普遍性に関するルールが適用されます。数値型は通常の数値比較のルールに従うことに注意してください。もし2つの数値の比較結果が同値である(例えば、 ``1`` と ``1.0``)なら、そのうちの1つのみを集合に含めることができます。"

#: ../../reference/datamodel.rst:405
msgid "There are currently two intrinsic set types:"
msgstr "現在、2つの組み込み集合型があります:"

#: ../../reference/datamodel.rst:412
msgid "Sets"
msgstr "集合型"

#: ../../reference/datamodel.rst:410
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as "
":meth:`~set.add`."
msgstr "可変な集合型です。組み込みの :func:`set` コンストラクタで作成され、後から :meth:`~set.add` などのいくつかのメソッドで更新できます。"

#: ../../reference/datamodel.rst:420
msgid "Frozen sets"
msgstr "Frozen set 型"

#: ../../reference/datamodel.rst:417
msgid ""
"These represent an immutable set.  They are created by the built-in "
":func:`frozenset` constructor.  As a frozenset is immutable and "
":term:`hashable`, it can be used again as an element of another set, or as a"
" dictionary key."
msgstr "不変な集合型です。組み込みの :func:`frozenset` コンストラクタによって作成されます。 frozenset は不変でハッシュ可能(:term:`hashable`)なので、別の集合型の要素になったり、辞書のキーにすることができます。"

#: ../../reference/datamodel.rst:457
msgid "Mappings"
msgstr "マップ型 (mapping)"

#: ../../reference/datamodel.rst:428
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr "任意のインデクス集合でインデクス化された、有限のオブジェクトからなる集合を表現します。添字表記 ``a[k]`` は、 ``k`` でインデクス指定された要素を ``a`` から選択します; 選択された要素は式の中で使うことができ、代入や :keyword:`del` 文の対象にすることができます。組み込み関数 :func:`len` は、マップ内の要素数を返します。"

#: ../../reference/datamodel.rst:434
msgid "There is currently a single intrinsic mapping type:"
msgstr "Python に最初から組み込まれているマップ型は、今のところ一つだけです:"

#: ../../reference/datamodel.rst:457
msgid "Dictionaries"
msgstr "辞書型 (dictionary)"

#: ../../reference/datamodel.rst:439
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr "ほとんどどんな値でもインデクスとして使えるような、有限個のオブジェクトからなる集合を表します。キー値 (key) として使えない値は、リストや辞書を含む値や、アイデンティティではなく値でオブジェクトが比較される、その他の変更可能な型です。これは、辞書型を効率的に実装する上で、キーのハッシュ値が一定であることが必要だからです。数値型をキーに使う場合、キー値は通常の数値比較における規則に従います: 二つの値が等しくなる場合 (例えば ``1`` と ``1.0``)、互いに同じ辞書のエントリを表すインデクスとして使うことができます。"

#: ../../reference/datamodel.rst:448
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation (see"
" section :ref:`dict`)."
msgstr "辞書は変更可能な型です; 辞書は ``{...}`` 表記で生成します (:ref:`dict` を参照してください)。"

#: ../../reference/datamodel.rst:456
msgid ""
"The extension modules :mod:`dbm`, :mod:`gdbm`, and :mod:`bsddb` provide "
"additional examples of mapping types."
msgstr "拡張モジュール :mod:`dbm` 、 :mod:`gdbm` 、および :mod:`bsddb` では、別のマップ型を提供しています。"

#: ../../reference/datamodel.rst:727
msgid "Callable types"
msgstr "呼び出し可能型 (callable type)"

#: ../../reference/datamodel.rst:466
msgid ""
"These are the types to which the function call operation (see section "
":ref:`calls`) can be applied:"
msgstr "関数呼び出し操作 (:ref:`calls` 参照) を行うことができる型です:"

#: ../../reference/datamodel.rst:560
msgid "User-defined functions"
msgstr "ユーザ定義関数 (user-defined function)"

#: ../../reference/datamodel.rst:475
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr "ユーザ定義関数オブジェクトは、関数定義を行うことで生成されます (:ref:`function` 参照)。関数は、仮引数 (formal parameter) リストと同じ数の要素が入った引数リストとともに呼び出されます。"

#: ../../reference/datamodel.rst:480
msgid "Special attributes:"
msgstr "特殊属性:"

#: ../../reference/datamodel.rst:503
msgid "Attribute"
msgstr "属性"

#: ../../reference/datamodel.rst:503
msgid "Meaning"
msgstr "意味"

#: ../../reference/datamodel.rst:505
msgid ":attr:`__doc__` :attr:`func_doc`"
msgstr ":attr:`__doc__` :attr:`func_doc`"

#: ../../reference/datamodel.rst:505
msgid "The function's documentation string, or ``None`` if unavailable."
msgstr "関数のドキュメンテーション文字列です。ドキュメンテーションがない場合は ``None`` になります。"

#: ../../reference/datamodel.rst:505 ../../reference/datamodel.rst:509
#: ../../reference/datamodel.rst:513 ../../reference/datamodel.rst:517
#: ../../reference/datamodel.rst:523 ../../reference/datamodel.rst:533
msgid "Writable"
msgstr "書き込み可能"

#: ../../reference/datamodel.rst:509
msgid ":attr:`~definition.\\ __name__` :attr:`func_name`"
msgstr ":attr:`~definition.\\ __name__` :attr:`func_name`"

#: ../../reference/datamodel.rst:509
msgid "The function's name"
msgstr "関数の名前です"

#: ../../reference/datamodel.rst:513
msgid ":attr:`__module__`"
msgstr ":attr:`__module__`"

#: ../../reference/datamodel.rst:513
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr "関数が定義されているモジュールの名前です。モジュール名がない場合は ``None`` になります。"

#: ../../reference/datamodel.rst:517
msgid ":attr:`__defaults__` :attr:`func_defaults`"
msgstr ":attr:`__defaults__` :attr:`func_defaults`"

#: ../../reference/datamodel.rst:517
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value."
msgstr "デフォルト値を持つ引数に対するデフォルト値が収められたタプルで、デフォルト値を持つ引数がない場合には ``None`` になります"

#: ../../reference/datamodel.rst:523
msgid ":attr:`__code__` :attr:`func_code`"
msgstr ":attr:`__code__` :attr:`func_code`"

#: ../../reference/datamodel.rst:523
msgid "The code object representing the compiled function body."
msgstr "コンパイルされた関数本体を表現するコードオブジェクトです。"

#: ../../reference/datamodel.rst:526
msgid ":attr:`__globals__` :attr:`func_globals`"
msgstr ":attr:`__globals__` :attr:`func_globals`"

#: ../../reference/datamodel.rst:526
msgid ""
"A reference to the dictionary that holds the function's global variables ---"
" the global namespace of the module in which the function was defined."
msgstr "関数のグローバル変数の入った辞書 (への参照) です --- この辞書は、関数が定義されているモジュールのグローバルな名前空間を決定します。"

#: ../../reference/datamodel.rst:526 ../../reference/datamodel.rst:537
msgid "Read-only"
msgstr "読み込み専用"

#: ../../reference/datamodel.rst:533
msgid ":attr:`~object.\\ __dict__` :attr:`func_dict`"
msgstr ":attr:`~object.\\ __dict__` :attr:`func_dict`"

#: ../../reference/datamodel.rst:533
msgid "The namespace supporting arbitrary function attributes."
msgstr "任意の関数属性をサポートするための名前空間が収められています。"

#: ../../reference/datamodel.rst:537
msgid ":attr:`__closure__` :attr:`func_closure`"
msgstr ":attr:`__closure__` :attr:`func_closure`"

#: ../../reference/datamodel.rst:537
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's free "
"variables."
msgstr "``None`` または関数の個々の自由変数 (引数以外の変数) に対して値を結び付けているセル (cell) 群からなるタプルになります。"

#: ../../reference/datamodel.rst:542
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the assigned "
"value."
msgstr "「書き込み可能」とラベルされている属性のほとんどは、代入された値の型をチェックします。"

#: ../../reference/datamodel.rst:544
msgid "``func_name`` is now writable."
msgstr "``func_name`` は書き込み可能になりました."

#: ../../reference/datamodel.rst:547
msgid ""
"The double-underscore attributes ``__closure__``, ``__code__``, "
"``__defaults__``, and ``__globals__`` were introduced as aliases for the "
"corresponding ``func_*`` attributes for forwards compatibility with Python "
"3."
msgstr "Python 3 との前方互換のために、ダブルアンダースコアの属性 ``__closure__``, ``__code__``, ``__defaults__``, ``__globals__`` が対応する ``func_*`` への別名として導入されました。"

#: ../../reference/datamodel.rst:553
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes. *Note that "
"the current implementation only supports function attributes on user-defined"
" functions. Function attributes on built-in functions may be supported in "
"the future.*"
msgstr "関数オブジェクトはまた、任意の属性を設定したり取得したりできます。この機能は、例えば関数にメタデータを付与したい場合などに使えます。関数の get や set には、通常のドット表記を使います。 *現在の実装では、ユーザ定義の関数でのみ属性をサポートしているので注意して下さい。組み込み関数の属性は将来サポートする予定です。*"

#: ../../reference/datamodel.rst:559
msgid ""
"Additional information about a function's definition can be retrieved from "
"its code object; see the description of internal types below."
msgstr "関数定義に関するその他の情報は、関数のコードオブジェクトから得られます; 後述の内部型 (internal type) に関する説明を参照してください。"

#: ../../reference/datamodel.rst:658
msgid "User-defined methods"
msgstr "ユーザ定義メソッド (user-defined method)"

#: ../../reference/datamodel.rst:568
msgid ""
"A user-defined method object combines a class, a class instance (or "
"``None``) and any callable object (normally a user-defined function)."
msgstr "ユーザ定義のメソッドオブジェクトは、クラスやクラスインスタンス (あるいは ``None``) を任意の呼び出し可能オブジェクト (通常はユーザ定義関数) と結合し (combine) ます。"

#: ../../reference/datamodel.rst:571
msgid ""
"Special read-only attributes: :attr:`im_self` is the class instance object, "
":attr:`im_func` is the function object; :attr:`im_class` is the class of "
":attr:`im_self` for bound methods or the class that asked for the method for"
" unbound methods; :attr:`__doc__` is the method's documentation (same as "
"``im_func.__doc__``); :attr:`~definition.__name__` is the method name (same "
"as ``im_func.__name__``); :attr:`__module__` is the name of the module the "
"method was defined in, or ``None`` if unavailable."
msgstr "読み出し専用の特殊属性: :attr:`im_self` はクラスインスタンスオブジェクトで、 :attr:`im_func` は関数オブジェクトです; :attr:`im_class` は結合メソッド (bound method) において :attr:`im_self` が属しているクラスか、あるいは非結合メソッド (unbound method) において、要求されたメソッドを定義しているクラスです; :attr:`__doc__` はメソッドのドキュメンテーション文字列 (``im_func.__doc__`` と同じ) です; :attr:`~definition.__name__` はメソッドの名前 (``im_func.__name__`` と同じ) です; :attr:`__module__` はメソッドが定義されているモジュールの名前になるか、モジュール名がない場合は ``None`` になります。"

#: ../../reference/datamodel.rst:579
msgid ":attr:`im_self` used to refer to the class that defined the method."
msgstr "メソッドを定義しているクラスを参照するために :attr:`im_self` が使われていました."

#: ../../reference/datamodel.rst:582
msgid ""
"For Python 3 forward-compatibility, :attr:`im_func` is also available as "
":attr:`__func__`, and :attr:`im_self` as :attr:`__self__`."
msgstr "Python 3 との前方互換性のために、 :attr:`im_func` の代わりに :attr:`__func__` も、 :attr:`im_self` の代わりに :attr:`__self__` も使うことができます。"

#: ../../reference/datamodel.rst:593
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr "メソッドもまた、根底にある関数オブジェクトの任意の関数属性に (値の設定はできませんが) アクセスできます。"

#: ../../reference/datamodel.rst:596
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined function object, an unbound user-defined method object, or a class "
"method object. When the attribute is a user-defined method object, a new "
"method object is only created if the class from which it is being retrieved "
"is the same as, or a derived class of, the class stored in the original "
"method object; otherwise, the original method object is used as it is."
msgstr "クラスの属性を (おそらくクラスのインスタンスを介して) 取得する際には、その属性がユーザ定義の関数オブジェクト、非結合 (unbound) のユーザ定義メソッドオブジェクト、あるいはクラスメソッドオブジェクトであれば、ユーザ定義メソッドオブジェクトが生成されることがあります。属性がユーザ定義メソッドオブジェクトの場合、属性を取得する対象のオブジェクトが属するクラスがもとのメソッドオブジェクトが定義されているクラスと同じクラスであるか、またはそのサブクラスであれば、新たなメソッドオブジェクトだけが生成されます。それ以外の場合には、もとのメソッドオブジェクトがそのまま使われます。"

#: ../../reference/datamodel.rst:609
msgid ""
"When a user-defined method object is created by retrieving a user-defined "
"function object from a class, its :attr:`im_self` attribute is ``None`` and "
"the method object is said to be unbound. When one is created by retrieving a"
" user-defined function object from a class via one of its instances, its "
":attr:`im_self` attribute is the instance, and the method object is said to "
"be bound. In either case, the new method's :attr:`im_class` attribute is the"
" class from which the retrieval takes place, and its :attr:`im_func` "
"attribute is the original function object."
msgstr "クラスからユーザ定義関数オブジェクトを取得する方法でユーザ定義メソッドオブジェクトを生成すると、 :attr:`im_self` 属性は ``None`` になり、メソッドオブジェクトは非結合 (unbound) であるといいます。クラスのインスタンスからユーザ定義関数オブジェクトを取得する方法でユーザ定義メソッドオブジェクトを生成すると、 :attr:`im_self` 属性はインスタンスになり、メソッドオブジェクトは結合 (bound) であるといいます。どちらの場合も、新たなメソッドの :attr:`im_class` 属性は、メソッドの取得が行われたクラスになり、 :attr:`im_func` 属性はもとの関数オブジェクトになります。"

#: ../../reference/datamodel.rst:620
msgid ""
"When a user-defined method object is created by retrieving another method "
"object from a class or instance, the behaviour is the same as for a function"
" object, except that the :attr:`im_func` attribute of the new instance is "
"not the original method object but its :attr:`im_func` attribute."
msgstr "クラスやインスタンスから他のユーザ定義メソッドオブジェクトを取得する方法でユーザ定義メソッドオブジェクトを生成した場合、その動作は関数オブジェクトの場合と同様ですが、新たなインスタンスの :attr:`im_func` 属性はもとのメソッドオブジェクトの属性ではなく、新たなインスタンスの属性になります。"

#: ../../reference/datamodel.rst:630
msgid ""
"When a user-defined method object is created by retrieving a class method "
"object from a class or instance, its :attr:`im_self` attribute is the class "
"itself, and its :attr:`im_func` attribute is the function object underlying "
"the class method."
msgstr "クラスやインスタンスからクラスメソッドオブジェクトを取得する方法でユーザ定義メソッドオブジェクトを生成した場合、 :attr:`im_self` 属性はクラス自体となり、 :attr:`im_func` 属性はクラスメソッドの根底にある関数オブジェクトになります。"

#: ../../reference/datamodel.rst:634
msgid ""
"When an unbound user-defined method object is called, the underlying "
"function (:attr:`im_func`) is called, with the restriction that the first "
"argument must be an instance of the proper class (:attr:`im_class`) or of a "
"derived class thereof."
msgstr "非結合ユーザ定義メソッドオブジェクトの呼び出しの際には、根底にある関数 (:attr:`im_func`) が呼び出されます。このとき、最初の引数は適切なクラス (:attr:`im_class`) またはサブクラスのインスタンスでなければならないという制限が課されています。"

#: ../../reference/datamodel.rst:639
msgid ""
"When a bound user-defined method object is called, the underlying function "
"(:attr:`im_func`) is called, inserting the class instance (:attr:`im_self`) "
"in front of the argument list.  For instance, when :class:`C` is a class "
"which contains a definition for a function :meth:`f`, and ``x`` is an "
"instance of :class:`C`, calling ``x.f(1)`` is equivalent to calling ``C.f(x,"
" 1)``."
msgstr "結合ユーザ定義メソッドオブジェクトの呼び出しの際には、根底にある関数 (:attr:`im_func`) が呼び出されます。このとき、クラスインスタンス (:attr:`im_self`) が引数の先頭に挿入されます。例えば、関数 :meth:`f` の定義が入ったクラスを :class:`C` とし、 ``x`` を :class:`C` のインスタンスとすると、 ``x.f(1)`` の呼び出しは ``C.f(x, 1)`` と同じになります。"

#: ../../reference/datamodel.rst:645
msgid ""
"When a user-defined method object is derived from a class method object, the"
" \"class instance\" stored in :attr:`im_self` will actually be the class "
"itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to "
"calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr "ユーザ定義メソッドオブジェクトがクラスオブジェクトから派生した際、 :attr:`im_self` に記憶されている \"クラスインスタンス\" はクラス自体になります。これは、 ``x.f(1)`` や ``C.f(1)`` の呼び出しが根底にある関数を ``f`` としたときの呼び出し ``f(C,1)`` と等価になるようにするためです。"

#: ../../reference/datamodel.rst:650
msgid ""
"Note that the transformation from function object to (unbound or bound) "
"method object happens each time the attribute is retrieved from the class or"
" instance. In some cases, a fruitful optimization is to assign the attribute"
" to a local variable and call that local variable. Also notice that this "
"transformation only happens for user-defined functions; other callable "
"objects (and all non-callable objects) are retrieved without transformation."
"  It is also important to note that user-defined functions which are "
"attributes of a class instance are not converted to bound methods; this "
"*only* happens when the function is an attribute of the class."
msgstr "関数オブジェクトから (結合または非結合の) メソッドオブジェクトへの変換は、クラスやインスタンスから属性を取り出すたびに行われるので注意してください。場合によっては、属性をローカルな変数に代入しておき、その変数を使って関数呼び出しを行うと効果的な最適化になります。また、上記の変換はユーザ定義関数に対してのみ起こるので注意してください; その他の呼び出し可能オブジェクト (および呼び出し可能でない全てのオブジェクト) は、変換を受けずに取り出されます。それから、クラスインスタンスの属性になっているユーザ定義関数は、結合メソッドに変換できないと知っておくことも重要です; 結合メソッドへの変換が行われるのは、関数がクラスの一属性である場合 *だけ* です。"

#: ../../reference/datamodel.rst:674
msgid "Generator functions"
msgstr "ジェネレータ関数 (generator function)"

#: ../../reference/datamodel.rst:665
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section "
":ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an iterator object which can be used to execute the "
"body of the function:  calling the iterator's :meth:`~iterator.next` method "
"will cause the function to execute until it provides a value using the "
":keyword:`yield` statement.  When the function executes a :keyword:`return` "
"statement or falls off the end, a :exc:`StopIteration` exception is raised "
"and the iterator will have reached the end of the set of values to be "
"returned."
msgstr ":keyword:`yield` 文 (:ref:`yield` の節を参照) を使う関数もしくはメソッドは :dfn:`ジェネレータ関数` と呼ばれます。そのような関数が呼び出されたときは常に、関数の本体を実行するのに使えるイテレータオブジェクトを返します: イテレータの :meth:`~iterator.next` メソッドを呼び出すと、 :keyword:`yield` 文を使って値が提供されるまで関数を実行します。関数の :keyword:`return` 文を実行するか終端に達したときは、 :exc:`StopIteration` 例外が送出され、イテレータが返すべき値の最後まで到達しています。"

#: ../../reference/datamodel.rst:689
msgid "Built-in functions"
msgstr "組み込み関数 (built-in function)"

#: ../../reference/datamodel.rst:682
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: :attr:`__doc__` "
"is the function's documentation string, or ``None`` if unavailable; "
":attr:`~definition.__name__` is the function's name; :attr:`__self__` is set"
" to ``None`` (but see the next item); :attr:`__module__` is the name of the "
"module the function was defined in or ``None`` if unavailable."
msgstr "組み込み関数オブジェクトはC関数へのラッパーです。\n組み込み関数の例は :func:`len` や :func:`math.sin` (:mod:`math` は標準の組み込みモジュール) です。\n引数の数や型は C 関数で決定されています。\n読み出し専用の特殊属性: :attr:`__doc__` は関数のドキュメンテーション文字列です。\nドキュメンテーションがない場合は ``None`` になります;\n:attr:`~definition.__name__` は関数の名前です;\n:attr:`__self__` は ``None`` に設定されています (組み込みメソッドの節も参照してください);\n:attr:`__module__` は、関数が定義されているモジュールの名前です。\nモジュール名がない場合は ``None`` になります。"

#: ../../reference/datamodel.rst:701
msgid "Built-in methods"
msgstr "組み込みメソッド (built-in method)"

#: ../../reference/datamodel.rst:697
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra argument."
"  An example of a built-in method is ``alist.append()``, assuming *alist* is"
" a list object. In this case, the special read-only attribute "
":attr:`__self__` is set to the object denoted by *alist*."
msgstr "実際には組み込み関数を別の形で隠蔽したもので、こちらの場合には C 関数に渡される何らかのオブジェクトを非明示的な外部引数として持っています。組み込みメソッドの例は、 *alist* をリストオブジェクトとしたときの ``alist.append()`` です。この場合には、読み出し専用の属性 :attr:`__self__` は *alist* で表されるオブジェクトになります。"

#: ../../reference/datamodel.rst:708
msgid "Class Types"
msgstr "クラス型 (class type)"

#: ../../reference/datamodel.rst:704
msgid ""
"Class types, or \"new-style classes,\" are callable.  These objects normally"
" act as factories for new instances of themselves, but variations are "
"possible for class types that override :meth:`__new__`.  The arguments of "
"the call are passed to :meth:`__new__` and, in the typical case, to "
":meth:`__init__` to initialize the new instance."
msgstr "クラス型、あるいは \"新しいクラス型 (new-style class)\" や呼び出し可能オブジェクトです。クラス型オブジェクトは通常、そのクラスの新たなインスタンスを生成する際のファクトリクラスとして振舞いますが、 :meth:`__new__` をオーバライドして、バリエーションを持たせることもできます。呼び出しの際に使われた引数は :meth:`__new__` に渡され、さらに典型的な場合では新たなインスタンスを初期化するために :meth:`__init__` に渡されます。"

#: ../../reference/datamodel.rst:722
msgid "Classic Classes"
msgstr "旧クラス型 (classic class)"

#: ../../reference/datamodel.rst:718
msgid ""
"Class objects are described below.  When a class object is called, a new "
"class instance (also described below) is created and returned.  This implies"
" a call to the class's :meth:`__init__` method if it has one.  Any arguments"
" are passed on to the :meth:`__init__` method.  If there is no "
":meth:`__init__` method, the class must be called without arguments."
msgstr "(旧) クラスオブジェクトは後で詳しく説明します。クラスオブジェクトが呼び出されると、新たにクラスインスタンス (後述) が生成され、返されます。この操作には、クラスの :meth:`__init__` メソッドの呼び出し (定義されている場合) が含まれています。呼び出しの際に使われた引数は、すべて :meth:`__init__` メソッドに渡されます。 :meth:`__init__` メソッドがない場合、クラスは引数なしで呼び出さなければなりません。"

#: ../../reference/datamodel.rst:727 ../../reference/datamodel.rst:879
msgid "Class instances"
msgstr "クラスインスタンス (class instance)"

#: ../../reference/datamodel.rst:725
msgid ""
"Class instances are described below.  Class instances are callable only when"
" the class has a :meth:`__call__` method; ``x(arguments)`` is a shorthand "
"for ``x.__call__(arguments)``."
msgstr "クラスインスタンスは後で詳しく説明します。クラスインスタンスはクラスが :meth:`__call__` メソッドを持っている場合にのみ呼び出すことができます; ``x(arguments)`` とすると、 ``x.__call__(arguments)`` 呼び出しを短く書けます。"

#: ../../reference/datamodel.rst:770
msgid "Modules"
msgstr "モジュール (module)"

#: ../../reference/datamodel.rst:734
msgid ""
"Modules are imported by the :keyword:`import` statement (see section "
":ref:`import`). A module object has a namespace implemented by a dictionary "
"object (this is the dictionary referenced by the func_globals attribute of "
"functions defined in the module).  Attribute references are translated to "
"lookups in this dictionary, e.g., ``m.x`` is equivalent to "
"``m.__dict__[\"x\"]``. A module object does not contain the code object used"
" to initialize the module (since it isn't needed once the initialization is "
"done)."
msgstr "モジュールは :keyword:`import` 文で import します (:ref:`import` 参照)。モジュールオブジェクトは、辞書オブジェクト (モジュール内で定義されている関数が func_globals 属性で参照している辞書です) で実装された名前空間を持っています。属性への参照は、この辞書に対する検索 (lookup) に翻訳されます。例えば、 ``m.x`` は ``m.__dict__[\"x\"]`` と同じです。モジュールオブジェクトには、モジュールを初期化するために使われるコードオブジェクトは入っていません (一度初期化が終わればもう必要ないからです)。"

#: ../../reference/datamodel.rst:743
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr "属性の代入を行うと、モジュールの名前空間辞書の内容を更新します。例えば、 ``m.x = 1`` は ``m.__dict__[\"x\"] = 1`` と同じです。"

#: ../../reference/datamodel.rst:748
msgid ""
"Special read-only attribute: :attr:`~object.__dict__` is the module's "
"namespace as a dictionary object."
msgstr "読み出し専用の特殊属性: :attr:`~object.__dict__` はモジュールの名前空間で、辞書オブジェクトです。"

#: ../../reference/datamodel.rst:753
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary"
" will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr "CPython がモジュール辞書を削除する方法により、モジュール辞書が生きた参照を持っていたとしてもその辞書はモジュールがスコープから外れた時に削除されます。これを避けるには、辞書をコピーするか、辞書を直接使っている間モジュールを保持してください。"

#: ../../reference/datamodel.rst:764
msgid ""
"Predefined (writable) attributes: :attr:`__name__` is the module's name; "
":attr:`__doc__` is the module's documentation string, or ``None`` if "
"unavailable; :attr:`__file__` is the pathname of the file from which the "
"module was loaded, if it was loaded from a file. The :attr:`__file__` "
"attribute is not present for C modules that are statically linked into the "
"interpreter; for extension modules loaded dynamically from a shared library,"
" it is the pathname of the shared library file."
msgstr "定義済みの (書き込み可能な) 属性: :attr:`__name__` はモジュールの名前です; :attr:`__doc__` は関数のドキュメンテーション文字列です。ドキュメンテーションがない場合は ``None`` になります; モジュールがファイルからロードされた場合、 :attr:`__file__` はロードされたモジュールファイルのパス名です。インタプリタに静的にリンクされている C モジュールの場合、 :attr:`__file__` 属性はありません; 共有ライブラリから動的にロードされた拡張モジュールの場合、この属性は共有ライブラリファイルのパス名になります。"

#: ../../reference/datamodel.rst:833
msgid "Classes"
msgstr "クラス"

#: ../../reference/datamodel.rst:773
msgid ""
"Both class types (new-style classes) and class objects (old-style/classic "
"classes) are typically created by class definitions (see section "
":ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, "
"e.g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although for new-style"
" classes in particular there are a number of hooks which allow for other "
"means of locating attributes). When the attribute name is not found there, "
"the attribute search continues in the base classes.  For old-style classes, "
"the search is depth-first, left-to-right in the order of occurrence in the "
"base class list. New-style classes use the more complex C3 method resolution"
" order which behaves correctly even in the presence of 'diamond' inheritance"
" structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by new-style classes "
"can be found in the documentation accompanying the 2.3 release at "
"https://www.python.org/download/releases/2.3/mro/."
msgstr "2 種類のクラス、 type (新スタイルクラス) と class object (旧スタイルクラス) の両方とも、通常はクラス定義 (:ref:`class` 参照) で生成されます。クラスは辞書で実装された名前空間を持っています。クラス属性への参照は、この辞書に対する検索 (lookup) に翻訳されます。例えば、 ``C.x`` は ``C.__dict__[\"x\"]`` と同じです。(ただし、特に新スタイルクラスにおいて、属性参照の意味を変えられる幾つかのフックがあります)。属性がこの検索で見つからない場合、現在のクラスの基底クラスへと検索を続けます。旧スタイルクラスの場合、検索は深さ優先 (depth-first)、かつ基底クラスの挙げられているリスト中の左から右 (left-to-right) の順番で行われます。新スタイルクラスは、より複雑な、C3メソッド解決順序(MRO=method resolution order) を利用していて、複数の継承パスが共通の祖先にたどり着く「ダイアモンド継承」があっても正しく動作します。 C3 MRO についてのより詳細な情報は、2.3リリースに付属するドキュメントにあります。 (https://www.python.org/download/releases/2.3/mro/)"

#: ../../reference/datamodel.rst:800
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield a "
"user-defined function object or an unbound user-defined method object whose "
"associated class is either :class:`C` or one of its base classes, it is "
"transformed into an unbound user-defined method object whose "
":attr:`im_class` attribute is :class:`C`. When it would yield a class method"
" object, it is transformed into a bound user-defined method object whose "
":attr:`im_self` attribute is :class:`C`.  When it would yield a static "
"method object, it is transformed into the object wrapped by the static "
"method object. See section :ref:`descriptors` for another way in which "
"attributes retrieved from a class may differ from those actually contained "
"in its :attr:`~object.__dict__` (note that only new-style classes support "
"descriptors)."
msgstr "クラス (:class:`C` とします) への属性参照で、要求している属性がユーザ定義関数オブジェクトや、 :class:`C` やその基底クラスに関連付けられている非結合のユーザ定義メソッドオブジェクトである場合、 :attr:`im_class` 属性が :class:`C` であるような非結合ユーザ定義メソッドオブジェクトに変換されます。要求している属性がクラスメソッドオブジェクトの場合、その :attr:`im_self` 属性が :class:`C` であるようなユーザ定義メソッドオブジェクトに変換されます。要求している属性が静的メソッドオブジェクトの場合、静的メソッドオブジェクトでラップされたオブジェクトに変換されます。クラスから取り出した属性と実際に :attr:`~object.__dict__` に入っているものが異なるような他の場合については、 :ref:`descriptors` を参照してください (新スタイルクラスだけがディスクリプタをサポートしていることに注意してください)。"

#: ../../reference/datamodel.rst:814
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr "クラス属性を代入すると、そのクラスの辞書だけが更新され、基底クラスの辞書は更新しません。"

#: ../../reference/datamodel.rst:819
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr "クラスオブジェクトを呼び出す (上記を参照) と、クラスインスタンスを生成します (下記を参照)。"

#: ../../reference/datamodel.rst:828
msgid ""
"Special attributes: :attr:`~definition.__name__` is the class name; "
":attr:`__module__` is the module name in which the class was defined; "
":attr:`~object.__dict__` is the dictionary containing the class's namespace;"
" :attr:`~class.__bases__` is a tuple (possibly empty or a singleton) "
"containing the base classes, in the order of their occurrence in the base "
"class list; :attr:`__doc__` is the class's documentation string, or ``None``"
" if undefined."
msgstr "特殊属性: :attr:`~definition.__name__` はクラス名です;\n:attr:`__module__` はクラスが定義されたモジュール名です;\n:attr:`~object.__dict__` はクラスが持つ名前空間が入った辞書です;\n:attr:`~class.__bases__` は基底クラスからなるタプル (空もしくは要素が 1 つしかないこともあります) で、基底クラスのリストに表れる順序で並んでいます;\n:attr:`__doc__` はクラスのドキュメント文字列で、未定義の場合は None です。"

#: ../../reference/datamodel.rst:842
msgid ""
"A class instance is created by calling a class object (see above). A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object or an unbound user-defined method "
"object whose associated class is the class (call it :class:`C`) of the "
"instance for which the attribute reference was initiated or one of its "
"bases, it is transformed into a bound user-defined method object whose "
":attr:`im_class` attribute is :class:`C` and whose :attr:`im_self` attribute"
" is the instance. Static method and class method objects are also "
"transformed, as if they had been retrieved from class :class:`C`; see above "
"under \"Classes\". See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`. If no class"
" attribute is found, and the object's class has a :meth:`__getattr__` "
"method, that is called to satisfy the lookup."
msgstr "クラスインスタンスはクラスオブジェクト (上記参照) を呼び出して生成します。クラスインスタンスは辞書で実装された名前空間を持っており、属性参照の時にはこの辞書が最初に検索されます。辞書内に属性が見つからず、かつインスタンスのクラスに該当する属性名がある場合、検索はクラス属性にまで広げられます。見つかったクラス属性がユーザ定義関数オブジェクトや、インスタンスのクラス (:class:`C` とします) やその基底クラスに関連付けられている非結合のユーザ定義メソッドオブジェクトの場合、 :attr:`im_class` 属性が :class:`C` で :attr:`im_self` 属性がインスタンスになっている結合ユーザ定義メソッドオブジェクトに変換されます。静的メソッドやクラスメソッドオブジェクトもまた、 :class:`C` から取り出した場合と同様に変換されます; 上記の \"クラス\" を参照してください。クラスから取り出した属性と実際に :attr:`~object.__dict__` に入っているものが異なるような他の場合については、 :ref:`descriptors` 節を参照してください。クラス属性が見つからず、かつオブジェクトのクラスが :meth:`__getattr__` メソッドを持っている場合、このメソッドを呼び出して属性名の検索を充足させます。"

#: ../../reference/datamodel.rst:861
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`__setattr__` or "
":meth:`__delattr__` method, this is called instead of updating the instance "
"dictionary directly."
msgstr "属性の代入や削除を行うと、インスタンスの辞書を更新しますが、クラスの辞書を更新することはありません。クラスで :meth:`__setattr__` や :meth:`__delattr__` メソッドが定義されている場合、直接インスタンスの辞書を更新する代わりにこれらのメソッドが呼び出されます。"

#: ../../reference/datamodel.rst:871
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr "クラスインスタンスは、ある特定の名前のメソッドを持っている場合、数値型やシーケンス型、あるいはマップ型のように振舞うことができます。 :ref:`specialnames` を参照してください。"

#: ../../reference/datamodel.rst:878
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary; "
":attr:`~instance.__class__` is the instance's class."
msgstr "特殊属性: :attr:`~object.__dict__` は属性の辞書です; :attr:`~instance.__class__` はインスタンスのクラスです。"

#: ../../reference/datamodel.rst:902
msgid "Files"
msgstr "ファイル (file)"

#: ../../reference/datamodel.rst:895
msgid ""
"A file object represents an open file.  File objects are created by the "
":func:`open` built-in function, and also by :func:`os.popen`, "
":func:`os.fdopen`, and the :meth:`makefile` method of socket objects (and "
"perhaps by other functions or methods provided by extension modules).  The "
"objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized to "
"file objects corresponding to the interpreter's standard input, output and "
"error streams.  See :ref:`bltin-file-objects` for complete documentation of "
"file objects."
msgstr "ファイルオブジェクトは開かれたファイルを表します。ファイルオブジェクトは組み込み関数 :func:`open` や、 :func:`os.popen`, :func:`os.fdopen`, および socke オブジェクトの :meth:`makefile` メソッド (その他の拡張モジュールで提供されている関数やメソッド) で生成されます。 ``sys.stdin``, ``sys.stdout`` および ``sys.stderr`` といったオブジェクトは、インタプリタの標準入力、標準出力、および標準エラー出力ストリームに対応するよう初期化されます。ファイルオブジェクトに関する完全な記述については、 :ref:`bltin-file-objects` を参照してください。"

#: ../../reference/datamodel.rst:1110
msgid "Internal types"
msgstr "内部型 (internal type)"

#: ../../reference/datamodel.rst:909
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr "インタプリタが内部的に使っているいくつかの型は、ユーザに公開されています。これらの定義は将来のインタプリタのバージョンでは変更される可能性がありますが、ここでは記述の完全性のために触れておきます。"

#: ../../reference/datamodel.rst:977
msgid "Code objects"
msgstr "コードオブジェクト"

#: ../../reference/datamodel.rst:916
msgid ""
"Code objects represent *byte-compiled* executable Python code, or "
":term:`bytecode`. The difference between a code object and a function object"
" is that the function object contains an explicit reference to the "
"function's globals (the module in which it was defined), while a code object"
" contains no context; also the default argument values are stored in the "
"function object, not in the code object (because they represent values "
"calculated at run-time).  Unlike function objects, code objects are "
"immutable and contain no references (directly or indirectly) to mutable "
"objects."
msgstr "コードオブジェクトは *バイトコンパイルされた (byte-compiled)* 実行可能な Python コード、別名バイトコード(:term:`bytecode`) を表現します。コードオブジェクトと関数オブジェクトの違いは、関数オブジェクトが関数のグローバル変数 (関数を定義しているモジュールのグローバル) に対して明示的な参照を持っているのに対し、コードオブジェクトにはコンテキストがないということです; また、関数オブジェクトではデフォルト引数値を記憶できますが、コードオブジェクトではできません (実行時に計算される値を表現するため)。関数オブジェクトと違い、コードオブジェクトは変更不可能で、変更可能なオブジェクトへの参照を (直接、間接に関わらず) 含みません。"

#: ../../reference/datamodel.rst:941
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; "
":attr:`co_argcount` is the number of positional arguments (including "
"arguments with default values); :attr:`co_nlocals` is the number of local "
"variables used by the function (including arguments); :attr:`co_varnames` is"
" a tuple containing the names of the local variables (starting with the "
"argument names); :attr:`co_cellvars` is a tuple containing the names of "
"local variables that are referenced by nested functions; :attr:`co_freevars`"
" is a tuple containing the names of free variables; :attr:`co_code` is a "
"string representing the sequence of bytecode instructions; :attr:`co_consts`"
" is a tuple containing the literals used by the bytecode; :attr:`co_names` "
"is a tuple containing the names used by the bytecode; :attr:`co_filename` is"
" the filename from which the code was compiled; :attr:`co_firstlineno` is "
"the first line number of the function; :attr:`co_lnotab` is a string "
"encoding the mapping from bytecode offsets to line numbers (for details see "
"the source code of the interpreter); :attr:`co_stacksize` is the required "
"stack size (including local variables); :attr:`co_flags` is an integer "
"encoding a number of flags for the interpreter."
msgstr "読み出し専用の特殊属性: :attr:`co_name` は関数名を表します; :attr:`co_argcount` は固定引数 (positional argument) の数です; :attr:`co_nlocals` は関数が使う (引数を含めた) ローカル変数の数です; :attr:`co_varnames` はローカル変数名の入ったタプルです (引数名から始まっています); :attr:`co_cellvars` はネストされた関数で参照されているローカル変数の名前が入ったタプルです; :attr:`co_freevars` は自由変数の名前が入ったタプルです。 :attr:`co_code` はバイトコード列を表現している文字列です; :attr:`co_consts` はバイトコードで使われているリテラルの入ったタプルです; :attr:`co_names` はバイトコードで使われている名前の入ったタプルです; :attr:`co_filename` はバイトコードのコンパイルが行われたファイル名です; :attr:`co_firstlineno` は関数の最初の行番号です; :attr:`co_lnotab` はバイトコードオフセットから行番号への対応付けをコード化した文字列です (詳細についてはインタプリタのソースコードを参照してください); :attr:`co_stacksize` は関数で (ローカル変数の分も含めて) 必要なスタックサイズです; :attr:`co_flags` はインタプリタ用の様々なフラグをコード化した整数です。"

#: ../../reference/datamodel.rst:960
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is "
"set if the function uses the ``*arguments`` syntax to accept an arbitrary "
"number of positional arguments; bit ``0x08`` is set if the function uses the"
" ``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` "
"is set if the function is a generator."
msgstr "以下のフラグビットが :attr:`co_flags` で定義されています: ``0x04`` ビットは、関数が ``*arguments`` 構文を使って任意の数の固定引数を受理できる場合に立てられます; ``0x08`` ビットは、関数が ``**keywords`` 構文を使ってキーワード引数を受理できる場合に立てられます; ``0x20`` ビットは、関数がジェネレータである場合に立てられます。"

#: ../../reference/datamodel.rst:966
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`co_flags` to indicate whether a code object was compiled with"
" a particular feature enabled: bit ``0x2000`` is set if the function was "
"compiled with future division enabled; bits ``0x10`` and ``0x1000`` were "
"used in earlier versions of Python."
msgstr "将来機能 (future feature) 宣言 (``from __future__ import division``) もまた、 :attr:`co_flags` のビットを立てることで、コードオブジェクトが特定の機能を有効にしてコンパイルされていることを示します: ``0x2000`` ビットは、関数が将来機能を有効にしてコンパイルされている場合に立てられます; 以前のバージョンの Python では、 ``0x10`` および ``0x1000`` ビットが使われていました。"

#: ../../reference/datamodel.rst:972
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ":attr:`co_flags` のその他のビットは将来に内部的に利用するために予約されています。"

#: ../../reference/datamodel.rst:976
msgid ""
"If a code object represents a function, the first item in :attr:`co_consts` "
"is the documentation string of the function, or ``None`` if undefined."
msgstr "コードオブジェクトが関数を表現している場合、 :attr:`co_consts` の最初の要素は関数のドキュメンテーション文字列になります。ドキュメンテーション文字列が定義されていない場合には ``None`` になります。"

#: ../../reference/datamodel.rst:1019
msgid "Frame objects"
msgstr "フレーム (frame) オブジェクト"

#: ../../reference/datamodel.rst:984
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below)."
msgstr "フレームオブジェクトは実行フレーム (execution frame) を表します。実行フレームはトレースバックオブジェクト内に出現します (下記参照)。"

#: ../../reference/datamodel.rst:996
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack frame "
"(towards the caller), or ``None`` if this is the bottom stack frame; "
":attr:`f_code` is the code object being executed in this frame; "
":attr:`f_locals` is the dictionary used to look up local variables; "
":attr:`f_globals` is used for global variables; :attr:`f_builtins` is used "
"for built-in (intrinsic) names; :attr:`f_restricted` is a flag indicating "
"whether the function is executing in restricted execution mode; "
":attr:`f_lasti` gives the precise instruction (this is an index into the "
"bytecode string of the code object)."
msgstr "読み出し専用の特殊属性: :attr:`f_back` は (呼び出し側にとっての) 以前のスタックフレームです。呼び出し側がスタックフレームの最下段である場合には ``None`` です; :attr:`f_code` は現在のフレームで実行しようとしているコードオブジェクトです; :attr:`f_locals` はローカル変数を検索するために使われる辞書です; :attr:`f_globals` はグローバル変数用です; :attr:`f_builtins` は組み込みの (Python 固有の) 名前です; :attr:`f_restricted` は、関数が制限つき実行 (restricted execution) モードで実行されているかどうかを示すフラグです; :attr:`f_lasti` は厳密な命令コード (コードオブジェクト中のバイトコード文字列へのインデクス) です。"

#: ../../reference/datamodel.rst:1012
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a function"
" called at the start of each source code line (this is used by the "
"debugger); :attr:`f_exc_type`, :attr:`f_exc_value`, :attr:`f_exc_traceback` "
"represent the last exception raised in the parent frame provided another "
"exception was ever raised in the current frame (in all other cases they are "
"``None``); :attr:`f_lineno` is the current line number of the frame --- "
"writing to this from within a trace function jumps to the given line (only "
"for the bottom-most frame).  A debugger can implement a Jump command (aka "
"Set Next Statement) by writing to f_lineno."
msgstr "書き込み可能な特殊属性: :attr:`f_trace` が ``None`` でない場合、各ソースコード行の先頭で呼び出される関数になります; :attr:`f_exc_type`, :attr:`f_exc_value`, :attr:`f_exc_traceback` は、現在のフレームが以前に引き起こした例外が提供する親フレーム内でもっとも最近捕捉された例外を表します (それ以外の場合は、これらは ``None`` になります); :attr:`f_lineno` はフレーム中における現在の行番号です --- トレース関数 (trace function) 側でこの値に書き込みを行うと、指定した行にジャンプします (最下段の実行フレームにいるときのみ) 。デバッガでは、 f_fileno を書き込むことで、ジャンプ命令 (Set Next Statement 命令とも呼ばれます) を実装できます。"

#: ../../reference/datamodel.rst:1061
msgid "Traceback objects"
msgstr "トレースバック (traceback) オブジェクト"

#: ../../reference/datamodel.rst:1034
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is created when an exception occurs.  When the search for an "
"exception handler unwinds the execution stack, at each unwound level a "
"traceback object is inserted in front of the current traceback.  When an "
"exception handler is entered, the stack trace is made available to the "
"program. (See section :ref:`try`.) It is accessible as "
"``sys.exc_traceback``, and also as the third item of the tuple returned by "
"``sys.exc_info()``.  The latter is the preferred interface, since it works "
"correctly when the program is using multiple threads. When the program "
"contains no suitable handler, the stack trace is written (nicely formatted) "
"to the standard error stream; if the interpreter is interactive, it is also "
"made available to the user as ``sys.last_traceback``."
msgstr "トレースバックオブジェクトは例外のスタックトレースを表現します。トレースバックオブジェクトは例外が発生した際に生成されます。例外ハンドラを検索して実行スタックを戻っていく際、戻ったレベル毎に、トレースバックオブジェクトが現在のトレースバックの前に挿入されます。例外ハンドラに入ると、スタックトレースをプログラム側で利用できるようになります (:ref:`try` を参照)。トレースバックは ``sys.exc_traceback`` として得ることができ、 ``sys.exc_info()`` が返すタプルの三番目の要素としても得られます. インタフェースとしては後者の方が推奨されていますが、これはプログラムがマルチスレッドを使っている場合に正しく動作するからです。プログラムに適切なハンドラがない場合、スタックトレースは (うまく書式化されて) 標準エラーストリームに書き出されます; インタプリタが対話的に実行されている場合、 ``sys.last_traceback`` として得ることもできます。"

#: ../../reference/datamodel.rst:1054
msgid ""
"Special read-only attributes: :attr:`tb_next` is the next level in the stack"
" trace (towards the frame where the exception occurred), or ``None`` if "
"there is no next level; :attr:`tb_frame` points to the execution frame of "
"the current level; :attr:`tb_lineno` gives the line number where the "
"exception occurred; :attr:`tb_lasti` indicates the precise instruction.  The"
" line number and last instruction in the traceback may differ from the line "
"number of its frame object if the exception occurred in a :keyword:`try` "
"statement with no matching except clause or with a finally clause."
msgstr "読み出し専用の特殊属性: :attr:`tb_next` はスタックトレース内の (例外の発生しているフレームに向かって) 次のレベルです。次のレベルが存在しない場合には ``None`` になります; :attr:`tb_frame` は現在のレベルにおける実行フレームを指します; :attr:`tb_lineno` は例外の発生した行番号です; :attr:`tb_lasti` は厳密な命令コードです。トレースバック内の行番号や最後に実行された命令は、 :keyword:`try` 文内で例外が発生し、かつ対応する :keyword:`except` 節や :keyword:`finally` 節がない場合には、フレームオブジェクト内の行番号とは異なるかもしれません。"

#: ../../reference/datamodel.rst:1092
msgid "Slice objects"
msgstr "スライス (slice) オブジェクト"

#: ../../reference/datamodel.rst:1066
msgid ""
"Slice objects are used to represent slices when *extended slice syntax* is "
"used. This is a slice using two colons, or multiple slices or ellipses "
"separated by commas, e.g., ``a[i:j:step]``, ``a[i:j, k:l]``, or ``a[..., "
"i:j]``.  They are also created by the built-in :func:`slice` function."
msgstr "スライスオブジェクトは *拡張スライス構文 (extended slice syntax)* が使われた際にスライスを表現するために使われます。拡張スライス構文とは、二つのコロンや、コンマで区切られた複数のスライスや省略符号 (ellipse) を使ったスライスで、例えば ``a[i:j:step]`` 、 ``a[i:j, k:l]`` 、あるいは ``a[..., i:j]`` です。スライスオブジェクトは組み込み関数 :func:`slice` で生成されます。"

#: ../../reference/datamodel.rst:1076
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; "
":attr:`~slice.stop` is the upper bound; :attr:`~slice.step` is the step "
"value; each is ``None`` if omitted.  These attributes can have any type."
msgstr "読み込み専用の特殊属性: :attr:`~slice.start` は下限です; :attr:`~slice.stop` は上限です; :attr:`~slice.step` はステップの値です; それぞれ省略された場合は ``None`` となっています。これらの属性は任意の型を持てます。"

#: ../../reference/datamodel.rst:1080
msgid "Slice objects support one method:"
msgstr "スライスオブジェクトはメソッドを一つサポートします:"

#: ../../reference/datamodel.rst:1085
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the extended slice that the slice object would describe if"
" applied to a sequence of *length* items.  It returns a tuple of three "
"integers; respectively these are the *start* and *stop* indices and the "
"*step* or stride length of the slice. Missing or out-of-bounds indices are "
"handled in a manner consistent with regular slices."
msgstr "このメソッドは単一の整数引数 *length* を取り、 *length* 個の要素からなるシーケンスに適用した際にスライスオブジェクトから提供することになる、拡張スライスに関する情報を計算します。このメソッドは三つの整数からなるタプルを返します; それぞれ *start* および *stop* のインデクスと、 *step* またはスライス間の幅に対応します。インデクス値がないか、範囲外の値である場合、通常のスライスに対して一貫性のあるやりかたで扱われます。"

#: ../../reference/datamodel.rst:1102
msgid "Static method objects"
msgstr "静的メソッド (static method) オブジェクト"

#: ../../reference/datamodel.rst:1095
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are not themselves "
"callable, although the objects they wrap usually are. Static method objects "
"are created by the built-in :func:`staticmethod` constructor."
msgstr "静的メソッドは、上で説明したような関数オブジェクトからメソッドオブジェクトへの変換を阻止するための方法を提供します。静的メソッドオブジェクトは他の何らかのオブジェクト、通常はユーザ定義メソッドオブジェクトを包むラッパです。静的メソッドをクラスやクラスインスタンスから取得すると、実際に返されるオブジェクトはラップされたオブジェクトになり、それ以上は変換の対象にはなりません。静的メソッドオブジェクトは通常呼び出し可能なオブジェクトをラップしますが、静的オブジェクト自体は呼び出すことができません。静的オブジェクトは組み込みコンストラクタ :func:`staticmethod` で生成されます。"

#: ../../reference/datamodel.rst:1110
msgid "Class method objects"
msgstr "クラスメソッドオブジェクト"

#: ../../reference/datamodel.rst:1105
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such"
" retrieval is described above, under \"User-defined methods\". Class method "
"objects are created by the built-in :func:`classmethod` constructor."
msgstr "クラスメソッドオブジェクトは、静的メソッドオブジェクトに似て、別のオブジェクトを包むラッパであり、そのオブジェクトをクラスやクラスインスタンスから取り出す方法を代替します。このようにして取得したクラスメソッドオブジェクトの動作については、上の \"ユーザ定義メソッド (user-defined method)\" で説明されています。クラスメソッドオブジェクトは組み込みのコンストラクタ :func:`classmethod` で生成されます。"

#: ../../reference/datamodel.rst:1115
msgid "New-style and classic classes"
msgstr "新スタイルと旧スタイル"

#: ../../reference/datamodel.rst:1117
msgid ""
"Classes and instances come in two flavors: old-style (or classic) and new-"
"style."
msgstr "クラスとインスタンスは好みに合わせて2種類の方法で記述することができます: 旧スタイル(もしくはクラシックスタイル)と新スタイルです。"

#: ../../reference/datamodel.rst:1119
msgid ""
"Up to Python 2.1 the concept of ``class`` was unrelated to the concept of "
"``type``, and old-style classes were the only flavor available.  For an old-"
"style class, the statement ``x.__class__`` provides the class of *x*, but "
"``type(x)`` is always ``<type 'instance'>``.  This reflects the fact that "
"all old-style instances, independent of their class, are implemented with a "
"single built-in type, called ``instance``."
msgstr "Python 2.1 までは、 ``class`` の概念は ``type`` の概念とは無関係で、また、旧スタイルクラスが唯一のものでした。旧スタイルクラスでは、 ``x.__class__`` は *x* のクラスを提供はしますが、 ``type(x)`` は常に ``<type 'instance'>`` になります。これは、すべての旧スタイルのインスタンスが、それらのクラスとは独立の、 ``instance`` と呼ばれる一つの内蔵型として実行されるということを反映しています。"

#: ../../reference/datamodel.rst:1126
msgid ""
"New-style classes were introduced in Python 2.2 to unify the concepts of "
"``class`` and ``type``.  A new-style class is simply a user-defined type, no"
" more, no less.  If *x* is an instance of a new-style class, then "
"``type(x)`` is typically the same as ``x.__class__`` (although this is not "
"guaranteed -- a new-style class instance is permitted to override the value "
"returned for ``x.__class__``)."
msgstr "新スタイルのクラスは、　``class`` と ``type`` の概念を統一するために Python 2.2 で導入されました。新スタイルのクラスはユーザ定義型そのもので、それ以上でも以下でもありません。もし、 *x* が新スタイルクラスのインスタンスであった場合、 ``type(x)`` は ``x.__class__`` と同じになります。 (ただし、これは保証されている動作ではありません -- 新スタイルクラスのインスタンスは、 ``x.__class__`` で返る値をオーバーライドすることができます。)"

#: ../../reference/datamodel.rst:1133
msgid ""
"The major motivation for introducing new-style classes is to provide a "
"unified object model with a full meta-model.  It also has a number of "
"practical benefits, like the ability to subclass most built-in types, or the"
" introduction of \"descriptors\", which enable computed properties."
msgstr "新スタイルクラスを導入する一番の理由は、メタモデルを用いた統一的なオブジェクトモデルを提供することにあります。また、ほとんどの組み込み型のサブクラスが作成できる、属性を計算するための\"デスクリプタ\"の導入できる等の利点があります。"

#: ../../reference/datamodel.rst:1138
msgid ""
"For compatibility reasons, classes are still old-style by default.  New-"
"style classes are created by specifying another new-style class (i.e. a "
"type) as a parent class, or the \"top-level type\" :class:`object` if no "
"other parent is needed.  The behaviour of new-style classes differs from "
"that of old-style classes in a number of important details in addition to "
"what :func:`type` returns.  Some of these changes are fundamental to the new"
" object model, like the way special methods are invoked.  Others are "
"\"fixes\" that could not be implemented before for compatibility concerns, "
"like the method resolution order in case of multiple inheritance."
msgstr "互換性のために、デフォルトではクラスは旧スタイルになります。新スタイルのクラスは、他の新スタイルクラス (すなわち型)を親クラスとして定義する、もしくは、他の親クラスが必要ない場合に \"最上位型\" :class:`object` を継承することで作成することができます。新スタイルクラスの動作は旧スタイルクラスの動作とは、 :func:`type` が何を返すかといったことをはじめ、何点か重要な部分が異なります。特殊メソッドの呼び出しなど、これらの変更は新オブジェクトモデルの基盤となっています。それ以外の部分は、多重継承時のメソッドの解決順などのように、互換性の問題で以前は実装が不可能であった\"修正\"が新クラスに含まれています。"

#: ../../reference/datamodel.rst:1148
msgid ""
"While this manual aims to provide comprehensive coverage of Python's class "
"mechanics, it may still be lacking in some areas when it comes to its "
"coverage of new-style classes. Please see "
"https://www.python.org/doc/newstyle/ for sources of additional information."
msgstr "このマニュアルは Python のクラスメカニズムに関する総合的な情報を提供しようとしていますが、新スタイルクラスについては、まだ足りない部分があるかもしれません。より詳細な情報を得たい場合は、 `<https://www.python.org/doc/newstyle/>`_ を参照してください。"

#: ../../reference/datamodel.rst:1158
msgid ""
"Old-style classes are removed in Python 3, leaving only new-style classes."
msgstr "Python 3 では旧スタイルクラスが削除されて、新スタイルクラスが唯一のクラスになりました。"

#: ../../reference/datamodel.rst:1164
msgid "Special method names"
msgstr "特殊メソッド名"

#: ../../reference/datamodel.rst:1170
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named "
":meth:`__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` "
"is roughly equivalent to ``x.__getitem__(i)`` for old-style classes and "
"``type(x).__getitem__(x, i)`` for new-style classes.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or "
":exc:`TypeError`)."
msgstr "特殊な名前をもったメソッドを定義することで、特殊な構文 (算術演算や添え字表記、スライス表記のような) 特定の演算をクラスで実装することができます。これは、個々のクラスが Python 言語で提供されている演算子に対応した独自の振る舞いをできるようにするための、演算子のオーバロード (:dfn:`operator overloading`) に対する Python のアプローチです。例えば、あるクラスが :meth:`__getitem__` という名前のメソッドを定義しており、 ``x`` がこのクラスのインスタンスであるとすると、 ``x[i]`` は旧スタイルクラスの場合 ``x.__getitem__(i)`` と、新スタイルクラスの場合 ``type(x).__getitem__(x, i)`` とほぼ等価になります。特に注釈のない限り、適切なメソッドが定義されていない場合にこのような演算を行おうとすると例外が送出されます。 (発生する例外はたいてい、 :exc:`AttributeError` か :exc:`TypeError` です。)"

#: ../../reference/datamodel.rst:1181
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for"
" the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make sense."
"  (One example of this is the :class:`~xml.dom.NodeList` interface in the "
"W3C's Document Object Model.)"
msgstr "組み込み型を模倣するクラスを実装するときは、真似されるオブジェクトにとって意味がある範囲に実装をとどめるのが重要です。例えば、あるシーケンスは個々の要素の取得はきちんと動くかもしれませんが、スライスの展開が意味を為さないかもしれません。 (W3C のドキュメントオブジェクトモデルにある :class:`~xml.dom.NodeList` インターフェースがその一例です。)"

#: ../../reference/datamodel.rst:1192
msgid "Basic customization"
msgstr "基本的なカスタマイズ"

#: ../../reference/datamodel.rst:1198
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static"
" method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr "クラス *cls* の新しいインスタンスを作るために呼び出されます。 :meth:`__new__` は静的メソッドで (このメソッドは特別扱いされているので、明示的に静的メソッドと宣言する必要はありません)、インスタンスを生成するよう要求されているクラスを第一引数にとります。残りの引数はオブジェクトのコンストラクタの式 (クラスの呼び出し文) に渡されます。 :meth:`__new__` の戻り値は新しいオブジェクトのインスタンス (通常は *cls* のインスタンス) でなければなりません。"

#: ../../reference/datamodel.rst:1205
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super(currentclass, "
"cls).__new__(cls[, ...])`` with appropriate arguments and then modifying the"
" newly-created instance as necessary before returning it."
msgstr "典型的な実装では、クラスの新たなインスタンスを生成するときには ``super(currentclass, cls).__new__(cls[, ...])`` に適切な引数を指定してスーパクラスの :meth:`__new__` メソッドを呼び出し、新たに生成されたインスタンスに必要な変更を加えてから返します。"

#: ../../reference/datamodel.rst:1210
msgid ""
"If :meth:`__new__` returns an instance of *cls*, then the new instance's "
":meth:`__init__` method will be invoked like ``__init__(self[, ...])``, "
"where *self* is the new instance and the remaining arguments are the same as"
" were passed to :meth:`__new__`."
msgstr ":meth:`__new__` が *cls* のインスタンスを返した場合、 ``__init__(self[, ...])`` のようにしてインスタンスの :meth:`__init__` が呼び出されます。このとき、 *self* は新たに生成されたインスタンスで、残りの引数は :meth:`__new__` に渡された引数と同じになります。"

#: ../../reference/datamodel.rst:1215
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ":meth:`__new__` が *cls* のインスタンスを返さない場合、インスタンスの :meth:`__init__` メソッドは呼び出されません。"

#: ../../reference/datamodel.rst:1218
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ":meth:`__new__` の主な目的は、変更不能な型 (int, str, tuple など) のサブクラスでインスタンス生成をカスタマイズすることにあります。また、クラス生成をカスタマイズするために、カスタムのメタクラスでよくオーバーライドされます。"

#: ../../reference/datamodel.rst:1227
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the"
" derived class's :meth:`__init__` method, if any, must explicitly call it to"
" ensure proper initialization of the base class part of the instance; for "
"example: ``BaseClass.__init__(self, [args...])``."
msgstr "インスタンスが (:meth:`__new__` によって) 生成された後、それが呼び出し元に返される前に呼び出されます。引数はクラスのコンストラクタ式に渡したものです。基底クラスとその派生クラスがともに :meth:`__init__` メソッドを持つ場合、派生クラスの :meth:`__init__` メソッドは基底クラスの :meth:`__init__` メソッドを明示的に呼び出して、インスタンスの基底クラス部分が適切に初期化されること保証しなければなりません。例えば、 ``BaseClass.__init__(self, [args...])`` 。"

#: ../../reference/datamodel.rst:1234
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customise "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ":meth:`__new__` と :meth:`__init__` は共同してオブジェクトを構成する (:meth:`__new__` が作成し、 :meth:`__init__` がそれをカスタマイズする) ので、 :meth:`__init__` が非 ``None`` 値を返すことがあってはなりません; さもなければ、実行時に :exc:`TypeError` が送出される原因になります。"

#: ../../reference/datamodel.rst:1246
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"destructor.  If a base class has a :meth:`__del__` method, the derived "
"class's :meth:`__del__` method, if any, must explicitly call it to ensure "
"proper deletion of the base class part of the instance.  Note that it is "
"possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  It "
"may then be called at a later time when this new reference is deleted.  It "
"is not guaranteed that :meth:`__del__` methods are called for objects that "
"still exist when the interpreter exits."
msgstr "インスタンスが消滅させられる際に呼び出されます。このメソッドはデストラクタ (destructor)  とも呼ばれます。基底クラスとその派生クラスがともに :meth:`__del__` メソッドを持つ場合、派生クラスの :meth:`__del__` メソッドは基底クラスの :meth:`__del__` メソッドを明示的に呼び出して、インスタンスの基底クラス部分が適切に消滅処理されること保証しなければなりません。 :meth:`__del__` メソッドでインスタンスに対する新たな参照を作ることで、インスタンスの消滅を遅らせることができます (とはいえ、推奨しません！)。このようにすると、新たに作成された参照がその後削除された際にもう一度 :meth:`__del__` メソッドが呼び出されます。インタプリタが終了する際に残っているオブジェクトに対して、 :meth:`__del__` メソッドが呼び出される保証はありません。"

#: ../../reference/datamodel.rst:1258
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero.  Some common situations that may "
"prevent the reference count of an object from going to zero include: "
"circular references between objects (e.g., a doubly-linked list or a tree "
"data structure with parent and child pointers); a reference to the object on"
" the stack frame of a function that caught an exception (the traceback "
"stored in ``sys.exc_traceback`` keeps the stack frame alive); or a reference"
" to the object on the stack frame that raised an unhandled exception in "
"interactive mode (the traceback stored in ``sys.last_traceback`` keeps the "
"stack frame alive).  The first situation can only be remedied by explicitly "
"breaking the cycles; the latter two situations can be resolved by storing "
"``None`` in ``sys.exc_traceback`` or ``sys.last_traceback``.  Circular "
"references which are garbage are detected when the option cycle detector is "
"enabled (it's on by default), but can only be cleaned up if there are no "
"Python-level :meth:`__del__` methods involved. Refer to the documentation "
"for the :mod:`gc` module for more information about how :meth:`__del__` "
"methods are handled by the cycle detector, particularly the description of "
"the ``garbage`` value."
msgstr "``del x`` は直接 ``x.__del__()`` を呼び出しません --- 前者は ``x`` への参照カウント (reference count) を 1 つ減らし、後者は ``x`` への参照カウントがゼロになった際にのみ呼び出されます。オブジェクトへの参照カウントがゼロになるのを妨げる可能性のあるよくある状況には、以下のようなものがあります: 複数のオブジェクト間における循環参照 (二重リンクリストや、親と子へのポインタを持つツリーデータ構造); 例外を捕捉した関数におけるスタックフレーム上にあるオブジェクトへの参照 (``sys.exc_traceback`` に記憶されているトレースバックが、スタックフレームを生き延びさせます); または、対話モードでハンドルされなかった例外を送出したスタックフレーム上にあるオブジェクトへの参照 (``sys.last_traceback`` に記憶されているトレースバックが、スタックフレームを生き延びさせます); 最初の状況については、明示的に循環参照を壊すしか解決策はありません; 後者の二つの状況は、 ``None`` を ``sys.exc_traceback`` や ``sys.last_traceback`` に入れることで解決できます。ごみオブジェクトと化した循環参照は、オプションの循環参照検出機構 (cycle detector) が有効にされている場合 (これはデフォルトの設定です) には検出されますが、検出された循環参照を消去するのは Python レベルで :meth:`__del__` メソッドが定義されていない場合だけです。 :meth:`__del__` メソッドが循環参照検出機構でどのように扱われるか、とりわけ ``garbage`` 値の記述に関しては、 :mod:`gc` モジュールのドキュメントを参照してください。"

#: ../../reference/datamodel.rst:1280
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  Also, when :meth:`__del__` is"
" invoked in response to a module being deleted (e.g., when execution of the "
"program is done), other globals referenced by the :meth:`__del__` method may"
" already have been deleted or in the process of being torn down (e.g. the "
"import machinery shutting down).  For this reason, :meth:`__del__` methods "
"should do the absolute minimum needed to maintain external invariants.  "
"Starting with version 1.5, Python guarantees that globals whose name begins "
"with a single underscore are deleted from their module before other globals "
"are deleted; if no other references to such globals exist, this may help in "
"assuring that imported modules are still available at the time when the "
":meth:`__del__` method is called."
msgstr ":meth:`__del__` メソッドの呼び出しが起きるのは不安定な状況下なので、 :meth:`__del__` の実行中に発生した例外は無視され、代わりに ``sys.stderr`` に警告が出力されます。また、 (例えばプログラムの実行終了による) モジュールの削除に伴って :meth:`__del__` が呼び出される際には、 :meth:`__del__` メソッドが参照している他のグローバル変数はすでに削除されていたり、削除中(例えば、import機構のシャットダウン中)かもしれません。この理由から、 :meth:`__del__` メソッドでは外部の不変関係を維持する上で絶対最低限必要なことだけをすべきです。バージョン 1.5 からは、単一のアンダースコアで始まるようなグローバル変数は、他のグローバル変数が削除される前にモジュールから削除されるように Python 側で保証しています; これらのアンダースコア付きグローバル変数は、 :meth:`__del__` が呼び出された際に、import されたモジュールがまだ残っているか確認する上で役に立ちます。"

#: ../../reference/datamodel.rst:1295
msgid "See also the :option:`-R` command-line option."
msgstr ":option:`-R` コマンドラインオプションも参照して下さい。"

#: ../../reference/datamodel.rst:1302
msgid ""
"Called by the :func:`repr` built-in function and by string conversions "
"(reverse quotes) to compute the \"official\" string representation of an "
"object.  If at all possible, this should look like a valid Python expression"
" that could be used to recreate an object with the same value (given an "
"appropriate environment).  If this is not possible, a string of the form "
"``<...some useful description...>`` should be returned.  The return value "
"must be a string object. If a class defines :meth:`__repr__` but not "
":meth:`__str__`, then :meth:`__repr__` is also used when an \"informal\" "
"string representation of instances of that class is required."
msgstr "組み込み関数 :func:`repr` や、文字列への変換 (逆クオート表記: reverse quote) の際に呼び出され、オブジェクトを表す \"公式の (official)\" 文字列を計算します。可能な場合には、この値は同じ値を持ったオブジェクトを (適切な環境で) 再生成するために使えるような有効な Python 式に似せるべきです。それが不可能なら、 ``<...some useful description...>`` 形式の文字列を返してください。戻り値は文字列オブジェクトでなければなりません。クラスが :meth:`__repr__` を定義しているが :meth:`__str__` を定義していない場合、そのクラスのインスタンスに対する \"非公式の (informal)\" 文字列表現が必要なときにも :meth:`__repr__` が使われます。"

#: ../../reference/datamodel.rst:1318
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr "この関数はデバッグの際によく用いられるので、たくさんの情報を含み、あいまいでないような表記にすることが重要です。"

#: ../../reference/datamodel.rst:1328
msgid ""
"Called by the :func:`str` built-in function and by the :keyword:`print` "
"statement to compute the \"informal\" string representation of an object.  "
"This differs from :meth:`__repr__` in that it does not have to be a valid "
"Python expression: a more convenient or concise representation may be used "
"instead. The return value must be a string object."
msgstr "組み込み関数 :func:`str` および :keyword:`print` 文によって呼び出され、オブジェクトを表す \"非公式の\" 文字列を計算します。このメソッドは、有効な Python 式を返さなくても良いという点で、 :meth:`__repr__` と異なります: その代わり、より便利で分かりやすい表現を返すようにしてください。戻り値は文字列オブジェクトでなければなりません。"

#: ../../reference/datamodel.rst:1347
msgid ""
"These are the so-called \"rich comparison\" methods, and are called for "
"comparison operators in preference to :meth:`__cmp__` below. The "
"correspondence between operator symbols and method names is as follows: "
"``x<y`` calls ``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` "
"calls ``x.__eq__(y)``, ``x!=y`` and ``x<>y`` call ``x.__ne__(y)``, ``x>y`` "
"calls ``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr "これらのメソッドは \"拡張比較 (rich comparison)\" メソッドと呼ばれ、下記の :meth:`__cmp__` に優先して呼び出されます。演算子シンボルとメソッド名の対応は以下の通りです: ``x<y`` は ``x.__lt__(y)`` を呼び出します; ``x<=y`` は ``x.__le__(y)`` を呼び出します; ``x==y`` は ``x.__eq__(y)`` を呼び出します; ``x!=y`` および ``x<>y`` は ``x.__ne__(y)`` を呼び出します; ``x>y`` は ``x.__gt__(y)`` を呼び出します; ``x>=y`` は ``x.__ge__(y)`` を呼び出します。"

#: ../../reference/datamodel.rst:1354
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if it "
"does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison."
" However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr "拡張比較メソッドは、与えられた引数のペアに対する操作を実装していないときに、 ``NotImplemented`` というシングルトンを返すかもしれません。慣例として、正常に比較が行われたときには ``False`` か ``True`` を返します。しかし、これらのメソッドは任意の値を返すことができるので、比較演算子がブール値のコンテキスト(たとえば、 ``if`` 文の条件部分)で使われた場合、 Python はその値に対して :func:`bool` を呼び出して結果の真偽を判断します。"

#: ../../reference/datamodel.rst:1361
msgid ""
"There are no implied relationships among the comparison operators. The truth"
" of ``x==y`` does not imply that ``x!=y`` is false.  Accordingly, when "
"defining :meth:`__eq__`, one should also define :meth:`__ne__` so that the "
"operators will behave as expected.  See the paragraph on :meth:`__hash__` "
"for some important notes on creating :term:`hashable` objects which support "
"custom comparison operations and are usable as dictionary keys."
msgstr "比較演算子間には、暗黙的な論理関係はありません。すなわち、 ``x==y`` が真である場合、暗黙のうちに ``x!=y`` が偽になるわけではありません。従って、 :meth:`__eq__` を実装する際、演算子が期待通りに動作するようにするために :meth:`__ne__` も定義する必要があります。カスタムの比較演算をサポートしていて、辞書のキーに使うことができるハッシュ可能(:term:`hashable`) オブジェクトを作るときの重要な注意点について、 :meth:`__hash__` のドキュメント内に書かれているので参照してください。"

#: ../../reference/datamodel.rst:1368
msgid ""
"There are no swapped-argument versions of these methods (to be used when the"
" left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, "
":meth:`__le__` and :meth:`__ge__` are each other's reflection, and "
":meth:`__eq__` and :meth:`__ne__` are their own reflection."
msgstr "これらのメソッドには、(左引数が演算をサポートしないが、右引数はサポートする場合に用いられるような) 鏡像となる (引数を入れ替えた) バージョンは存在しません; むしろ、 :meth:`__lt__` と :meth:`__gt__` は互いに鏡像であり、 :meth:`__le__` と :meth:`__ge__` 、および :meth:`__eq__` と :meth:`__ne__` はそれぞれ互いに鏡像です。"

#: ../../reference/datamodel.rst:1374
msgid "Arguments to rich comparison methods are never coerced."
msgstr "拡張比較メソッドの引数には型強制 (coerce) が起こりません。"

#: ../../reference/datamodel.rst:1376
msgid ""
"To automatically generate ordering operations from a single root operation, "
"see :func:`functools.total_ordering`."
msgstr "単一の基本演算から順序付けするための演算を自動的に生成したい場合には、 :func:`functools.total_ordering` を参照してください。"

#: ../../reference/datamodel.rst:1385
msgid ""
"Called by comparison operations if rich comparison (see above) is not "
"defined.  Should return a negative integer if ``self < other``, zero if "
"``self == other``, a positive integer if ``self > other``.  If no "
":meth:`__cmp__`, :meth:`__eq__` or :meth:`__ne__` operation is defined, "
"class instances are compared by object identity (\"address\").  See also the"
" description of :meth:`__hash__` for some important notes on creating "
":term:`hashable` objects which support custom comparison operations and are "
"usable as dictionary keys. (Note: the restriction that exceptions are not "
"propagated by :meth:`__cmp__` has been removed since Python 1.5.)"
msgstr "拡張比較 (上参照) が定義されていない場合、比較演算によって呼び出されます。 ``self < other`` である場合には負の値、 ``self == other`` ならばゼロ、 ``self > other`` であれば正の値を返さなければなりません。演算 :meth:`__cmp__` 、 :meth:`__eq__` および :meth:`__ne__` がいずれも定義されていない場合、クラスインスタンスはオブジェクトのアイデンティティ(\"アドレス\") で比較されます。自作の比較演算をサポートするオブジェクトや、辞書のキーとして使えるオブジェクトを生成するには、 :meth:`__hash__` に関する記述を参照してください。 (注意: :meth:`__cmp__` が例外を伝播しないという制限は Python 1.5 から除去されました。)"

#: ../../reference/datamodel.rst:1398
msgid "No longer supported."
msgstr "もはやサポートされていません."

#: ../../reference/datamodel.rst:1408
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and "
":class:`dict`.  :meth:`__hash__` should return an integer.  The only "
"required property is that objects which compare equal have the same hash "
"value; it is advised to mix together the hash values of the components of "
"the object that also play a part in comparison of objects by packing them "
"into a tuple and hashing the tuple. Example::"
msgstr "組み込みの :func:`hash` 関数や、 :class:`set`, :class:`frozenset`, :class:`dict` のようなハッシュを使ったコレクション型の要素に対する操作から呼び出されます。\n:meth:`__hash__` は整数を返さなければなりません。\nこのメソッドに必要な性質は、比較結果が等しいオブジェクトは同じハッシュ値を持つということです;\nオブジェクトを比較するときでも利用される要素をタプルに詰めてハッシュ値を計算することで、それぞれの要素のハッシュ値を混合することをおすすめします。"

#: ../../reference/datamodel.rst:1419
msgid ""
"If a class does not define a :meth:`__cmp__` or :meth:`__eq__` method it "
"should not define a :meth:`__hash__` operation either; if it defines "
":meth:`__cmp__` or :meth:`__eq__` but not :meth:`__hash__`, its instances "
"will not be usable in hashed collections.  If a class defines mutable "
"objects and implements a :meth:`__cmp__` or :meth:`__eq__` method, it should"
" not implement :meth:`__hash__`, since hashable collection implementations "
"require that an object's hash value is immutable (if the object's hash value"
" changes, it will be in the wrong hash bucket)."
msgstr "クラスが :meth:`__cmp__` や :meth:`__eq__` メソッドを定義していない場合、 :meth:`__hash__` メソッドも定義してはなりません; クラスが :meth:`__cmp__` または :meth:`__eq__` を定義しているが、 :meth:`__hash__` を定義していない場合、インスタンスを辞書のキーとして使うことはできません。クラスが変更可能なオブジェクトを定義しており、 :meth:`__cmp__` または :meth:`__eq__` メソッドを実装している場合、 :meth:`__hash__` を定義してはなりません。これは、辞書の実装においてハッシュ値が変更不能であることが要求されているからです (オブジェクトのハッシュ値が変化すると、キーが誤ったハッシュバケツ (hash bucket) に入っていることになってしまいます)。"

#: ../../reference/datamodel.rst:1428
msgid ""
"User-defined classes have :meth:`__cmp__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) and"
" ``x.__hash__()`` returns a result derived from ``id(x)``."
msgstr "ユーザー定義クラスはデフォルトで :meth:`__cmp__` と :meth:`__hash__` メソッドを持っています。これらは、同一以外のすべてのオブジェクトに対して比較結果が偽になり、 ``x.__hash__()`` は ``id(x)`` から得られる結果を返します。"

#: ../../reference/datamodel.rst:1432
msgid ""
"Classes which inherit a :meth:`__hash__` method from a parent class but "
"change the meaning of :meth:`__cmp__` or :meth:`__eq__` such that the hash "
"value returned is no longer appropriate (e.g. by switching to a value-based "
"concept of equality instead of the default identity based equality) can "
"explicitly flag themselves as being unhashable by setting ``__hash__ = "
"None`` in the class definition. Doing so means that not only will instances "
"of the class raise an appropriate :exc:`TypeError` when a program attempts "
"to retrieve their hash value, but they will also be correctly identified as "
"unhashable when checking ``isinstance(obj, collections.Hashable)`` (unlike "
"classes which define their own :meth:`__hash__` to explicitly raise "
":exc:`TypeError`)."
msgstr "親クラスから :meth:`__hash__` メソッドを継承して、 :meth:`__cmp__` か :meth:`__eq__` の意味を変更している(例えば、デフォルトの同一性ベースの同値関係から値ベースの同値関係に変更する) クラスのハッシュ値は妥当ではなくなるので、 ``__hash__ = None`` をクラス定義に書く事で、明示的にハッシュ不可能であることを宣言できます。こうすると、プログラムがそのクラスのインスタンスのハッシュ値を取得しようとしたときに適切な :exc:`TypeError` 例外を送出するようになるだけでなく、 (:exc:`TypeError` を発生させる :meth:`__hash__` メソッドを持つクラスと違って) ``isinstance(obj, collections.Hashable)`` をチェックしたときに、ハッシュ不可能と判定されるようになります。"

#: ../../reference/datamodel.rst:1444
msgid ""
":meth:`__hash__` may now also return a long integer object; the 32-bit "
"integer is then derived from the hash of that object."
msgstr ":meth:`__hash__` は現在では長整数オブジェクトも返せるようになりました。 32ビット整数はこのオブジェクトのハッシュから導出されます。"

#: ../../reference/datamodel.rst:1448
msgid ""
":attr:`__hash__` may now be set to :const:`None` to explicitly flag "
"instances of a class as unhashable."
msgstr "クラスのインスタンスがハッシュ不可能であることを明示的に宣言するために、 :attr:`__hash__` に :const:`None` を設定することができるようになりました。"

#: ../../reference/datamodel.rst:1457
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``, or their integer "
"equivalents ``0`` or ``1``.  When this method is not defined, "
":meth:`__len__` is called, if it is defined, and the object is considered "
"true if its result is nonzero. If a class defines neither :meth:`__len__` "
"nor :meth:`__nonzero__`, all its instances are considered true."
msgstr "真値テストや組み込み演算 ``bool()`` を実現するために呼び出されます; ``False`` または ``True`` か、等価な整数値 ``0`` または ``1`` を返さなければなりません。このメソッドが定義されていない場合、 :meth:`__len__` が定義されていれば呼び出され、その結果が nonzero であれば真になります。 :meth:`__len__` と :meth:`__nonzero__` のどちらもクラスで定義されていない場合、そのクラスのインスタンスはすべて真の値を持つものとみなされます。"

#: ../../reference/datamodel.rst:1469
msgid ""
"Called to implement :func:`unicode` built-in; should return a Unicode "
"object. When this method is not defined, string conversion is attempted, and"
" the result of string conversion is converted to Unicode using the system "
"default encoding."
msgstr "組み込み関数 :func:`unicode` を実現するために呼び出されます。Unicode オブジェクトを返さなければなりません。このメソッドが定義されていなければ、文字列への変換が試みられ、その結果がデフォルトの文字エンコードを用いて Unicode に変換されます。"

#: ../../reference/datamodel.rst:1477
msgid "Customizing attribute access"
msgstr "属性値アクセスをカスタマイズする"

#: ../../reference/datamodel.rst:1479
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr "以下のメソッドを定義して、クラスインスタンスへの属性値アクセス ( 属性値の使用、属性値への代入、 ``x.name`` の削除) の意味をカスタマイズすることができます。"

#: ../../reference/datamodel.rst:1485
msgid ""
"Called when an attribute lookup has not found the attribute in the usual "
"places (i.e. it is not an instance attribute nor is it found in the class "
"tree for ``self``).  ``name`` is the attribute name. This method should "
"return the (computed) attribute value or raise an :exc:`AttributeError` "
"exception."
msgstr "属性値の検索を行った結果、通常の場所に属性値が見つからなかった場合 (すなわち、 ``self`` のインスタンス属性でなく、かつクラスツリーにも見つからなかった場合) に呼び出されます。``name`` は属性名です。このメソッドは (計算された) 属性値を返すか、 :exc:`AttributeError` 例外を送出しなければなりません。"

#: ../../reference/datamodel.rst:1492
msgid ""
"Note that if the attribute is found through the normal mechanism, "
":meth:`__getattr__` is not called.  (This is an intentional asymmetry "
"between :meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can fake total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control in new-style classes."
msgstr "通常のメカニズムを介して属性値が見つかった場合、 :meth:`__getattr__` は呼び出されないので注意してください。(これは、 :meth:`__getattr__` と :meth:`__setattr__` の間に意図的に導入された非対称性です。) これは、効率性のためと、こうしなければ :meth:`__getattr__` がインスタンスの他の属性値にアクセスする方法がなくなるためです。少なくともインスタンス変数に対しては、値をインスタンスの属性値辞書に挿入しないようにして (代わりに他のオブジェクトに挿入することで) 属性値が完全に制御されているように見せかけられることに注意してください。新スタイルクラスで実際に完全な制御を行う方法は、以下の :meth:`__getattribute__` メソッドを参照してください。"

#: ../../reference/datamodel.rst:1505
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of"
" the normal mechanism (i.e. store the value in the instance dictionary).  "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr "属性値への代入が試みられた際に呼び出されます。このメソッドは通常の代入メカニズム (すなわち、インスタンス辞書への値の代入) の代わりに呼び出されます。 *name* は属性名で、 *value* はその属性に代入する値です。"

#: ../../reference/datamodel.rst:1511
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"not simply execute ``self.name = value`` --- this would cause a recursive "
"call to itself.  Instead, it should insert the value in the dictionary of "
"instance attributes, e.g., ``self.__dict__[name] = value``.  For new-style "
"classes, rather than accessing the instance dictionary, it should call the "
"base class method with the same name, for example, "
"``object.__setattr__(self, name, value)``."
msgstr ":meth:`__setattr__` の中でインスタンス属性値への代入が必要な場合、単に ``self.name = value`` としてはなりません --- このようにすると、自分自身に対する再帰呼び出しがおきてしまいます。その代わりに、インスタンス属性の辞書に値を挿入してください。例えば、 ``self.__dict__[name] = value`` とします。新しい形式のクラスでは、インスタンス辞書にアクセスするのではなく、基底クラスのメソッドを同じ属性名で呼び出します。例えば、 ``object.__setattr__(self, name, value)`` とします。"

#: ../../reference/datamodel.rst:1522
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ":meth:`__setattr__` に似ていますが、代入ではなく値の削除を行います。このメソッドを実装するのは、オブジェクトにとって ``del obj.name`` が意味がある場合だけにしなければなりません。"

#: ../../reference/datamodel.rst:1529
msgid "More attribute access for new-style classes"
msgstr "新しい形式のクラスのための別の属性アクセス"

#: ../../reference/datamodel.rst:1531
msgid "The following methods only apply to new-style classes."
msgstr "以下のメソッドは新しい形式のクラス (new-style class) のみに適用されます。"

#: ../../reference/datamodel.rst:1536
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be"
" called unless :meth:`__getattribute__` either calls it explicitly or raises"
" an :exc:`AttributeError`. This method should return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception. In order to "
"avoid infinite recursion in this method, its implementation should always "
"call the base class method with the same name to access any attributes it "
"needs, for example, ``object.__getattribute__(self, name)``."
msgstr "クラスのインスタンスに対する属性アクセスを実装するために、無条件に呼び出されます。クラスが :meth:`__getattr__` も定義している場合、 :meth:`__getattr__` は、 :meth:`__getattribute__` で明示的に呼び出すか、 :exc:`AttributeError` 例外を送出しない限り呼ばれません。このメソッドは (計算された) 属性値を返すか、 :exc:`AttributeError` 例外を送出します。このメソッドが再帰的に際限なく呼び出されてしまうのを防ぐため、実装の際には常に、必要な属性全てへのアクセスで、例えば ``object.__getattribute__(self, name)`` のように基底クラスのメソッドを同じ属性名を使って呼び出さなければなりません。"

#: ../../reference/datamodel.rst:1547
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. See"
" :ref:`new-style-special-lookup`."
msgstr "ビルトイン関数や言語構文により暗黙的に特殊メソッドが検索されるときは、このメソッドの呼び出しはバイパスされるでしょう。 :ref:`new-style-special-lookup` を参照してください。"

#: ../../reference/datamodel.rst:1555
msgid "Implementing Descriptors"
msgstr "デスクリプタ (descriptor) の実装"

#: ../../reference/datamodel.rst:1557
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the"
" descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property in"
" the owner class' :attr:`~object.__dict__`."
msgstr "以下のメソッドは、このメソッドを持つクラス (いわゆる *デスクリプタ(descriptor)* クラス) のインスタンスが、 *オーナー (owner)* クラスに存在するときにのみ適用されます (デスクリプタは、オーナーのクラス辞書か、その親のいずれかのクラス辞書になければなりません)。\n以下の例では、\"属性\" とは、名前がオーナークラスの :attr:`~object.__dict__` のプロパティ (porperty) のキーであるような属性を指します。"

#: ../../reference/datamodel.rst:1567
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). *owner* is always "
"the owner class, while *instance* is the instance that the attribute was "
"accessed through, or ``None`` when the attribute is accessed through the "
"*owner*.  This method should return the (computed) attribute value or raise "
"an :exc:`AttributeError` exception."
msgstr "オーナクラスの属性を取得する (クラス属性へのアクセス) 際や、オーナクラスのインスタンスの属性を取得する (インスタンス属性へのアクセス) 場合に呼び出されます。 *owner* は常にオーナクラスです。一方、 *instance* は属性へのアクセスを仲介するインスタンスか属性が *owner* を介してアクセスされる場合は ``None`` になります。このメソッドは (計算された) 属性値を返すか、 :exc:`AttributeError` 例外を送出しなければなりません。"

#: ../../reference/datamodel.rst:1577
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr "オーナクラスのインスタンス *instance* 上の属性を新たな値 *value* に設定する際に呼び出されます。"

#: ../../reference/datamodel.rst:1583
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr "オーナクラスのインスタンス *instance* 上の属性を削除する際に呼び出されます。"

#: ../../reference/datamodel.rst:1589
msgid "Invoking Descriptors"
msgstr "デスクリプタの呼び出し"

#: ../../reference/datamodel.rst:1591
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`__get__`, :meth:`__set__`, and :meth:`__delete__`. If any "
"of those methods are defined for an object, it is said to be a descriptor."
msgstr "一般にデスクリプタとは、特殊な \"束縛に関する動作 (binding behaviour)\" をもつオブジェクト属性のことです。デスクリプタは、デスクリプタプロトコル (descriptor protocol) のメソッド: :meth:`__get__`, :meth:`__set__`, および :meth:`__delete__` を使って、属性アクセスをオーバライドしているものです。これらのメソッドのいずれかがオブジェクトに対して定義されている場合、オブジェクトはデスクリプタであるといいます。"

#: ../../reference/datamodel.rst:1596
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and"
" continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr "属性アクセスのデフォルトの動作は、オブジェクトの辞書から値を取り出したり、値を設定したり、削除したりするというものです。例えば、 ``a.x`` による属性の検索では、まず ``a.__dict__['x']`` 、次に ``type(a).__dict__['x']`` 、そして ``type(a)`` の基底クラスでメタクラスでないものに続く、といった具合に連鎖が起こります。"

#: ../../reference/datamodel.rst:1601
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called.  "
"Note that descriptors are only invoked for new style objects or classes "
"(ones that subclass :class:`object()` or :class:`type()`)."
msgstr "しかしながら、検索対象となる値が、デスクリプタメソッドのいずれかを定義しているオブジェクトの属性値である場合、Python はデフォルトの動作をオーバライドして、デスクリプタメソッドの方を呼び出します。前後する呼び出し連鎖の中のどこでデスクリプタメソッドが呼び出されるかは、どのデスクリプタメソッドが定義されているかと、どうやってデスクリプタメソッドが呼ばれるかに依存します。デスクリプタは新しい形式のオブジェクトやクラス (:class:`object()` や :class:`type()` をサブクラス化したもの) だけに対して呼び出されるので注意してください。"

#: ../../reference/datamodel.rst:1608
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr "デスクリプタ呼び出しの基点となるのは、属性名への束縛 (binding) 、すなわち ``a.x`` です。引数がどのようにデスクリプタに結合されるかは ``a`` に依存します:"

#: ../../reference/datamodel.rst:1613
msgid "Direct Call"
msgstr "直接呼び出し (Direct Call)"

#: ../../reference/datamodel.rst:1612
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr "最も単純で、かつめったに使われない呼び出し操作は、コード中で直接デスクリプタメソッドの呼び出し: ``x.__get__(a)`` を行うというものです。"

#: ../../reference/datamodel.rst:1617
msgid "Instance Binding"
msgstr "インスタンス束縛 (Instance Binding)"

#: ../../reference/datamodel.rst:1616
msgid ""
"If binding to a new-style object instance, ``a.x`` is transformed into the "
"call: ``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr "新しい形式のクラスのインスタンスに対する束縛では、 ``a.x`` は呼び出し: ``type(a).__dict__['x'].__get__(a, type(a))`` に変換されます。"

#: ../../reference/datamodel.rst:1621
msgid "Class Binding"
msgstr "クラス束縛 (Class Binding)"

#: ../../reference/datamodel.rst:1620
msgid ""
"If binding to a new-style class, ``A.x`` is transformed into the call: "
"``A.__dict__['x'].__get__(None, A)``."
msgstr "新しい形式のクラスに対する束縛では、 ``A.x`` は呼び出し: ``A.__dict__['x'].__get__(None, A)`` に変換されます。"

#: ../../reference/datamodel.rst:1627
msgid "Super Binding"
msgstr "super 束縛 (Super Binding)"

#: ../../reference/datamodel.rst:1624
msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, "
"obj).m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately preceding ``B`` and then invokes the descriptor with the call: "
"``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr "``a`` が :class:`super` のインスタンスである場合、束縛 ``super(B, obj).m()`` を行うとまず ``A`` 、続いて ``B`` に対して ``obj.__class_.__mro__`` を検索し、次に呼び出し: ``A.__dict__['m'].__get__(obj, obj.__class__)`` でデスクリプタを呼び出します。"

#: ../../reference/datamodel.rst:1629
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"the which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  If "
"it does not define :meth:`__get__`, then accessing the attribute will return"
" the descriptor object itself unless there is a value in the object's "
"instance dictionary.  If the descriptor defines :meth:`__set__` and/or "
":meth:`__delete__`, it is a data descriptor; if it defines neither, it is a "
"non-data descriptor.  Normally, data descriptors define both :meth:`__get__`"
" and :meth:`__set__`, while non-data descriptors have just the "
":meth:`__get__` method.  Data descriptors with :meth:`__set__` and "
":meth:`__get__` defined always override a redefinition in an instance "
"dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr "インスタンス束縛では、デスクリプタ呼び出しの優先順位はどのデスクリプタが定義されているかに依存します。データデスクリプタは、 :meth:`__get__` と :meth:`__set__` 、 :meth:`__delete__` の任意の組合せを定義することができます。 :meth:`__get__` が定義されない場合には、その属性にアクセスすると、そのオブジェクトのインスタンス辞書にその値がある場合を除けば、デスクリプタオブジェクト自身が返ってきます。デスクリプタが :meth:`__set__` と :meth:`__delete__` またはそのどちらかを定義していれば、データデスクリプタとなります; もし両方とも定義しなければ、非データデスクリプタです。通常、データデスクリプタでは、 :meth:`__get__` と :meth:`__set__` を定義し、一方、非データデスクリプタには :meth:`__get__` メソッドしかありません。 :meth:`__set__` と :meth:`__get__` を定義したデータデスクリプタは、インスタンス辞書内で属性値が再定義されても、常にこの値をオーバライドします。対照的に、非データデスクリプタの場合には、属性値はインスタンス側でオーバライドされます。"

#: ../../reference/datamodel.rst:1642
msgid ""
"Python methods (including :func:`staticmethod` and :func:`classmethod`) are "
"implemented as non-data descriptors.  Accordingly, instances can redefine "
"and override methods.  This allows individual instances to acquire behaviors"
" that differ from other instances of the same class."
msgstr "(:func:`staticmethod` や :func:`classmethod` を含む) Python メソッドは、非データデスクリプタとして実装されています。その結果、インスタンスではメソッドを再定義したりオーバライドできます。このことにより、個々のインスタンスが同じクラスの他のインスタンスと互いに異なる動作を獲得することができます。"

#: ../../reference/datamodel.rst:1647
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ":func:`property` 関数はデータデスクリプタとして実装されています。従って、インスタンスはあるプロパティの動作をオーバライドすることができません。"

#: ../../reference/datamodel.rst:1654
msgid "__slots__"
msgstr "__slots__"

#: ../../reference/datamodel.rst:1656
msgid ""
"By default, instances of both old and new-style classes have a dictionary "
"for attribute storage.  This wastes space for objects having very few "
"instance variables.  The space consumption can become acute when creating "
"large numbers of instances."
msgstr "デフォルトでは、新旧どちらのクラスも、属性の記憶領域として使うための辞書を持っています。この仕様は、ほとんどインスタンス変数を持たないようなオブジェクトの場合には記憶領域の無駄遣いになります。記憶領域の消費量は、大量のインスタンスを生成する際には深刻です。"

#: ../../reference/datamodel.rst:1661
msgid ""
"The default can be overridden by defining *__slots__* in a new-style class "
"definition.  The *__slots__* declaration takes a sequence of instance "
"variables and reserves just enough space in each instance to hold a value "
"for each variable.  Space is saved because *__dict__* is not created for "
"each instance."
msgstr "このデフォルトの設定は、新たな形式のクラス定義において *__slots__* を定義することでオーバライドできます。 *__slots_* 宣言はインスタンス変数のシーケンスを受け取ります。各々のインスタンス上には、各変数の値を記憶するのにちょうど必要な量だけの記憶領域を確保します。各々のインスタンスに対して *__dict__* が生成されることがないので、記憶領域が節約されます。"

#: ../../reference/datamodel.rst:1669
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  If defined in a new-style "
"class, *__slots__* reserves space for the declared variables and prevents "
"the automatic creation of *__dict__* and *__weakref__* for each instance."
msgstr "このクラス変数には、文字列、反復可能オブジェクト、あるいはインスタンスが用いる変数名を表す文字列からなるシーケンスを代入することができます。この変数が新しい形式のクラスで定義されている場合、 *__slots__* は、各インスタンスに対して宣言された変数に必要な記憶領域を確保し、 *__dict__* と *__weakref__* が自動的に生成されないようにします。"

#: ../../reference/datamodel.rst:1676
msgid "Notes on using *__slots__*"
msgstr "*__slots__* を利用する際の注意"

#: ../../reference/datamodel.rst:1678
msgid ""
"When inheriting from a class without *__slots__*, the *__dict__* attribute "
"of that class will always be accessible, so a *__slots__* definition in the "
"subclass is meaningless."
msgstr "*__slots__* を持たないクラスから継承する場合、 *__dict__* 属性は常にアクセス可能なので、サブクラスで *__slots__* を定義しても意味がありません。"

#: ../../reference/datamodel.rst:1682
msgid ""
"Without a *__dict__* variable, instances cannot be assigned new variables "
"not listed in the *__slots__* definition.  Attempts to assign to an unlisted"
" variable name raises :exc:`AttributeError`. If dynamic assignment of new "
"variables is desired, then add ``'__dict__'`` to the sequence of strings in "
"the *__slots__* declaration."
msgstr "*__dict__* 変数がない場合、 *__slots__* に列挙されていない新たな変数をインスタンスに代入することはできません。列挙されていない変数名を使って代入しようとした場合、 :exc:`AttributeError` が送出されます。新たな変数を動的に代入したいのなら、 *__slots__* を宣言する際に ``'__dict__'`` を変数名のシーケンスに追加してください。"

#: ../../reference/datamodel.rst:1688
msgid ""
"Previously, adding ``'__dict__'`` to the *__slots__* declaration would not "
"enable the assignment of new attributes not specifically listed in the "
"sequence of instance variable names."
msgstr "これまでは、 ``'__dict__'`` を *__slots__* 宣言に追加しても、インスタンス変数名として他にリストされていない新たな属性の代入はできませんでした。"

#: ../../reference/datamodel.rst:1693
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support weak references to its instances. If weak "
"reference support is needed, then add ``'__weakref__'`` to the sequence of "
"strings in the *__slots__* declaration."
msgstr "*__slots__* を定義しているクラスの各インスタンスに *__weakref__* 変数がない場合、インスタンスに対する弱参照 (weak reference) はサポートされません。弱参照のサポートが必要なら、 *__slots__* を宣言する際に ``'__weakref__'`` を変数名のシーケンスに追加してください。"

#: ../../reference/datamodel.rst:1698
msgid ""
"Previously, adding ``'__weakref__'`` to the *__slots__* declaration would "
"not enable support for weak references."
msgstr "これまでは、 ``'__weakref__'`` を *__slots__* 宣言に追加しても、弱参照のサポートを有効にできませんでした。"

#: ../../reference/datamodel.rst:1702
msgid ""
"*__slots__* are implemented at the class level by creating descriptors "
"(:ref:`descriptors`) for each variable name.  As a result, class attributes "
"cannot be used to set default values for instance variables defined by "
"*__slots__*; otherwise, the class attribute would overwrite the descriptor "
"assignment."
msgstr "*__slots__* は、クラスのレベルで各変数に対するデスクリプタ (:ref:`descriptors` を参照) を使って実装されます。その結果、 *__slots__* に定義されているインスタンス変数のデフォルト値はクラス属性を使って設定できなくなっています; そうしないと、デスクリプタによる代入をクラス属性が上書きしてしまうからです。"

#: ../../reference/datamodel.rst:1708
msgid ""
"The action of a *__slots__* declaration is limited to the class where it is "
"defined.  As a result, subclasses will have a *__dict__* unless they also "
"define *__slots__* (which must only contain names of any *additional* "
"slots)."
msgstr "*__slots__* 宣言が動作するのは、定義が行われたクラスだけに限られています。その結果、サブクラスでは、 *__slots__* を定義しない限り *__dict__* を持つことになります。"

#: ../../reference/datamodel.rst:1712
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr "あるクラスで、基底クラスですでに定義されているスロットを定義した場合、基底クラスのスロットで定義されているインスタンス変数は (デスクリプタを基底クラスから直接取得しない限り) アクセスできなくなります。これにより、プログラムの趣意が不定になってしまいます。将来は、この問題を避けるために何らかのチェックが追加されるかもしれません。"

#: ../../reference/datamodel.rst:1717
msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-"
"length\" built-in types such as :class:`long`, :class:`str` and "
":class:`tuple`."
msgstr "空でない *__slots__* は、 :class:`long` 、 :class:`str` 、および :class:`tuple` といった、\"可変長 (variable-length)\" の組み込み型から派生したクラスでは動作しません。"

#: ../../reference/datamodel.rst:1720
msgid ""
"Any non-string iterable may be assigned to *__slots__*. Mappings may also be"
" used; however, in the future, special meaning may be assigned to the values"
" corresponding to each key."
msgstr "*__slots__* には、文字列でない反復可能オブジェクトを代入することができます。辞書型も使うことができます; しかし将来、辞書の各キーに相当する値に何らかの特殊な意味が割り当てられるかもしれません。"

#: ../../reference/datamodel.rst:1724
msgid ""
"*__class__* assignment works only if both classes have the same *__slots__*."
msgstr "*__class__* への代入は、両方のクラスが同じ *__slots__* を持っているときのみ動作します。"

#: ../../reference/datamodel.rst:1726
msgid ""
"Previously, *__class__* assignment raised an error if either new or old "
"class had *__slots__*."
msgstr "以前は、新旧どちらかのクラスが *__slots__* を持っていたら *__class__* への代入はエラーを発生していました。"

#: ../../reference/datamodel.rst:1734
msgid "Customizing class creation"
msgstr "クラス生成をカスタマイズする"

#: ../../reference/datamodel.rst:1736
msgid ""
"By default, new-style classes are constructed using :func:`type`. A class "
"definition is read into a separate namespace and the value of class name is "
"bound to the result of ``type(name, bases, dict)``."
msgstr "デフォルトでは、新スタイルクラスは :func:`type` を使って構築されます。クラス定義が別の名前空間に読み込まれ、クラス名は ``type(name, bases, dict)`` の結果に結合されます。"

#: ../../reference/datamodel.rst:1740
msgid ""
"When the class definition is read, if *__metaclass__* is defined then the "
"callable assigned to it will be called instead of :func:`type`. This allows "
"classes or functions to be written which monitor or alter the class creation"
" process:"
msgstr "クラス定義が読み込まれる際、 *__metaclass__* が定義されていれば、 :func:`type` の代わりに *__metaclass__* が指している呼び出し可能オブジェクトが呼び出されます。これによって、"

#: ../../reference/datamodel.rst:1745
msgid "Modifying the class dictionary prior to the class being created."
msgstr "クラスが生成される前にクラス辞書を変更する"

#: ../../reference/datamodel.rst:1747
msgid ""
"Returning an instance of another class -- essentially performing the role of"
" a factory function."
msgstr "他のクラスのインスタンスを返す -- 本質的にはファクトリ関数の役割を果たす"

#: ../../reference/datamodel.rst:1750
msgid ""
"These steps will have to be performed in the metaclass's :meth:`__new__` "
"method -- :meth:`type.__new__` can then be called from this method to create"
" a class with different properties.  This example adds a new element to the "
"class dictionary before creating the class::"
msgstr "これらのステップは、メタクラスの :meth:`__new__` メソッドで実行されなければなりません。 -- このメソッドから他の属性を持ったクラスを作るには、 :meth:`type.__new__` を呼び出すことができます。次の例ではクラスを生成する前に新しい要素をクラス辞書に追加しています。 ::"

#: ../../reference/datamodel.rst:1760
msgid ""
"You can of course also override other class methods (or add new methods); "
"for example defining a custom :meth:`__call__` method in the metaclass "
"allows custom behavior when the class is called, e.g. not always creating a "
"new instance."
msgstr "もちろん、他のクラスメソッドをオーバーライドする(または新しいメソッドを追加する)こともできます。例えば、カスタムの :meth:`__call__` メソッドをメタクラスに定義して、新しいインスタンスを常には造らないといったカスタムの動作を実装できます。"

#: ../../reference/datamodel.rst:1767
msgid ""
"This variable can be any callable accepting arguments for ``name``, "
"``bases``, and ``dict``.  Upon class creation, the callable is used instead "
"of the built-in :func:`type`."
msgstr "この変数は ``name`` 、 ``bases`` 、および ``dict`` を引数として取るような任意の呼び出し可能オブジェクトにできます。クラス生成の際、組み込みの :func:`type` の代わりに、指定された呼び出しオブジェクトが呼び出されます。"

#: ../../reference/datamodel.rst:1773
msgid ""
"The appropriate metaclass is determined by the following precedence rules:"
msgstr "以下に優先順で並んだ規則によって、適切なメタクラスが決定されます:"

#: ../../reference/datamodel.rst:1775
msgid "If ``dict['__metaclass__']`` exists, it is used."
msgstr "``dict['__metaclass__']`` があればそれを使います。"

#: ../../reference/datamodel.rst:1777
msgid ""
"Otherwise, if there is at least one base class, its metaclass is used (this "
"looks for a *__class__* attribute first and if not found, uses its type)."
msgstr "それ以外の場合で、最低でも一つ基底クラスを持っているなら、基底クラスのメタクラス (*__class__* 属性を探し、なければ基底クラスの型) を使います。"

#: ../../reference/datamodel.rst:1780
msgid ""
"Otherwise, if a global variable named __metaclass__ exists, it is used."
msgstr "それ以外の場合で、__metaclass__ という名前のグローバル変数があれば、それをつかいます。"

#: ../../reference/datamodel.rst:1782
msgid "Otherwise, the old-style, classic metaclass (types.ClassType) is used."
msgstr "それ以外の場合には、旧スタイルのメタクラス (types.ClassType) を使います。"

#: ../../reference/datamodel.rst:1784
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored including logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr "メタクラスは限りない潜在的利用価値を持っています。これまで試されてきたアイデアには、ログ記録、インタフェースのチェック、自動デリゲーション、自動プロパティ生成、プロキシ、フレームワーク、そして自動リソースロック／同期といったものがあります。"

#: ../../reference/datamodel.rst:1791
msgid "Customizing instance and subclass checks"
msgstr "インスタンスのカスタマイズとサブクラスチェック"

#: ../../reference/datamodel.rst:1795
msgid ""
"The following methods are used to override the default behavior of the "
":func:`isinstance` and :func:`issubclass` built-in functions."
msgstr "以下のメソッドは組み込み関数 :func:`isinstance` と :func:`issubclass` のデフォルトの動作を上書きするのに利用します。"

#: ../../reference/datamodel.rst:1798
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr "特に、 :class:`abc.ABCMeta` メタクラスは、抽象基底クラス (ABCs) を\"仮想基底クラス (virtual base classes)\" として、他の ABC を含む、任意のクラスや (組み込み型を含む) 型に追加するために、これらのメソッドを実装しています。"

#: ../../reference/datamodel.rst:1805
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr "*instance* が (直接、または間接的に) *class* のインスタンスと考えられる場合に true を返します。定義されていれば、 ``isinstance(instance, class)`` の実装のために呼び出されます。"

#: ../../reference/datamodel.rst:1812
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass,"
" class)``."
msgstr "*subclass* が (直接、または間接的に) *class* のサブクラスと考えられる場合に true を返します。定義されていれば、 ``issubclass(subclass, class)`` の実装のために呼び出されます。"

#: ../../reference/datamodel.rst:1817
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr "なお、これらのメソッドは、クラスの型 (メタクラス) 上で検索されます。実際のクラスにクラスメソッドとして定義することはできません。これは、インスタンスそれ自体がクラスであるこの場合にのみ、インスタンスに呼び出される特殊メソッドの検索と一貫しています。"

#: ../../reference/datamodel.rst:1828
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - 抽象基底クラスの導入"

#: ../../reference/datamodel.rst:1825
msgid ""
"Includes the specification for customizing :func:`isinstance` and "
":func:`issubclass` behavior through :meth:`~class.__instancecheck__` and "
":meth:`~class.__subclasscheck__`, with motivation for this functionality in "
"the context of adding Abstract Base Classes (see the :mod:`abc` module) to "
"the language."
msgstr "抽象基底クラス (:mod:`abc` モジュールを参照) を言語に追加する文脈においての動機から、 :meth:`~class.__instancecheck__` と :meth:`~class.__subclasscheck__` を通して、 :func:`isinstance` と :func:`issubclass` に独自の動作をさせるための仕様の記述があります。"

#: ../../reference/datamodel.rst:1835
msgid "Emulating callable objects"
msgstr "呼び出し可能オブジェクトをエミュレートする"

#: ../../reference/datamodel.rst:1842
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, arg2, "
"...)``."
msgstr "インスタンスが関数として \"呼ばれた\" 際に呼び出されます; このメソッドが定義されている場合、 ``x(arg1, arg2, ...)`` は ``x.__call__(arg1, arg2, ...)`` を短く書いたものになります。"

#: ../../reference/datamodel.rst:1849
msgid "Emulating container types"
msgstr "コンテナをエミュレートする"

#: ../../reference/datamodel.rst:1851
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are sequences (such as lists or tuples) or mappings (like"
" dictionaries), but can represent other containers as well.  The first set "
"of methods is used either to emulate a sequence or to emulate a mapping; the"
" difference is that for a sequence, the allowable keys should be the "
"integers *k* for which ``0 <= k < N`` where *N* is the length of the "
"sequence, or slice objects, which define a range of items. (For backwards "
"compatibility, the method :meth:`__getslice__` (see below) can also be "
"defined to handle simple, but not extended slices.) It is also recommended "
"that mappings provide the methods :meth:`keys`, :meth:`values`, "
":meth:`items`, :meth:`has_key`, :meth:`get`, :meth:`clear`, "
":meth:`setdefault`, :meth:`iterkeys`, :meth:`itervalues`, :meth:`iteritems`,"
" :meth:`pop`, :meth:`popitem`, :meth:`!copy`, and :meth:`update` behaving "
"similar to those for Python's standard dictionary objects.  The "
":mod:`UserDict` module provides a :class:`DictMixin` class to help create "
"those methods from a base set of :meth:`__getitem__`, :meth:`__setitem__`, "
":meth:`__delitem__`, and :meth:`keys`. Mutable sequences should provide "
"methods :meth:`append`, :meth:`count`, :meth:`index`, :meth:`extend`, "
":meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:`reverse` and "
":meth:`sort`, like Python standard list objects.  Finally, sequence types "
"should implement addition (meaning concatenation) and multiplication "
"(meaning repetition) by defining the methods :meth:`__add__`, "
":meth:`__radd__`, :meth:`__iadd__`, :meth:`__mul__`, :meth:`__rmul__` and "
":meth:`__imul__` described below; they should not define :meth:`__coerce__` "
"or other numerical operators.  It is recommended that both mappings and "
"sequences implement the :meth:`__contains__` method to allow efficient use "
"of the ``in`` operator; for mappings, ``in`` should be equivalent of "
":meth:`has_key`; for sequences, it should search through the values.  It is "
"further recommended that both mappings and sequences implement the "
":meth:`__iter__` method to allow efficient iteration through the container; "
"for mappings, :meth:`__iter__` should be the same as :meth:`iterkeys`; for "
"sequences, it should iterate through the values."
msgstr "以下のメソッドを定義して、コンテナオブジェクトを実装することができます。コンテナは通常、(リストやタプルのような) シーケンスや、(辞書のような) マップ型を指しますが、他のコンテナも同じように表現することができます。最初の一連のメソッドは、シーケンスをエミュレートしたり、マップ型をエミュレートするために使われます; その違いとして、シーケンスの場合には、キーとして許されているのが、シーケンスの長さが *N* であるときの ``0 <= k < N`` なる整数 *k* か、あるいは要素の範囲を表すスライスオブジェクトでなければならないということです。 (後方互換性のため、 :meth:`__getslice__` (以下参照) を定義して、拡張されていない単純なスライスを扱うようにもできます。)変更可能なシーケンスでは、Python の標準リストオブジェクトのように、メソッド :meth:`append`, :meth:`count`, :meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:`reverse`,および :meth:`sort` を提供しなければなりません。マップ型でも、Python の標準辞書オブジェクトのように、 :meth:`keys`, :meth:`values`, :meth:`items`, :meth:`has_key`, :meth:`get`, :meth:`clear`, :meth:`setdefault`, :meth:`iterkeys`, :meth:`itervalues`, :meth:`iteritems`, :meth:`pop`, :meth:`popitem`, :meth:`!copy`,および :meth:`update` といったメソッドをマップ型で提供するよう推奨しています。 :mod:`UserDict` モジュールでは、これらのメソッドを :meth:`__getitem__`, :meth:`__setitem__`, :meth:`__delitem__`,および :meth:`keys` といった基本セットから作成する上で役に立つ :class:`DictMixin` クラスを提供しています。最後に、シーケンス型では以下に述べるメソッド群 :meth:`__add__`, :meth:`__radd__`, :meth:`__iadd__`, :meth:`__mul__`, :meth:`__rmul__`,および :meth:`__imul__` を定義して、 (シーケンス間の結合を意味する) 加算操作と (要素の繰り返しを意味する) 乗算操作を実装しなければなりません; :meth:`__coerce__` や、その他の数値演算子を定義してはなりません。マップでもシーケンスでも、 ``in`` 演算子が有効利用できるように :meth:`__contains__` メソッドの定義を推奨します; マップ型では、 ``in`` は :meth:`has_key` と等価でなければなりません; シーケンスでは、シーケンス内の値にわたって検索を行わなければなりません。さらに、マップでもシーケンスでも、コンテナ内にわたる反復操作ができるようにするため、 :meth:`__iter__` を実装するよう勧めます; マップ型の場合、 :meth:`__iter__` は :meth:`iterkeys` と等価でなければなりません; シーケンスの場合、シーケンス内の値にわたって反復操作を行わなければなりません。"

#: ../../reference/datamodel.rst:1889
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`__nonzero__` method and whose :meth:`__len__` method returns"
" zero is considered to be false in a Boolean context."
msgstr "組み込み関数 :func:`len` を実現するために呼び出されます。オブジェクトの長さを ``>=`` 0 である整数で返さなければなりません。また、オブジェクトが :meth:`__nonzero__` メソッドを定義しておらず、 :meth:`__len__` メソッドがゼロを返す場合には、ブール演算コンテキストでは偽であるとみなされます。"

#: ../../reference/datamodel.rst:1896
msgid ""
"In CPython, the length is required to be at most :attr:`sys.maxsize`. If the"
" length is larger than :attr:`!sys.maxsize` some features (such as "
":func:`len`) may raise :exc:`OverflowError`.  To prevent raising "
":exc:`!OverflowError` by truth value testing, an object must define a "
":meth:`__nonzero__` method."
msgstr ""

#: ../../reference/datamodel.rst:1907
msgid ""
"Called to implement evaluation of ``self[key]``. For sequence types, the "
"accepted keys should be integers and slice objects.  Note that the special "
"interpretation of negative indexes (if the class wishes to emulate a "
"sequence type) is up to the :meth:`__getitem__` method. If *key* is of an "
"inappropriate type, :exc:`TypeError` may be raised; if of a value outside "
"the set of indexes for the sequence (after any special interpretation of "
"negative values), :exc:`IndexError` should be raised. For mapping types, if "
"*key* is missing (not in the container), :exc:`KeyError` should be raised."
msgstr "``self[key]`` の値評価 (evaluation) を実現するために呼び出されます。シーケンスの場合、キーとして整数とスライスオブジェクトを受理できなければなりません。 (シーケンス型をエミュレートする場合) 負のインデクスの解釈は :meth:`__getitem__` メソッド次第となります。 *key* が不適切な型であった場合、 :exc:`TypeError` を送出してもかまいません; (負のインデクス値に対して何らかの解釈を行った上で) *key* がシーケンスのインデクス集合外の値である場合、 :exc:`IndexError` を送出しなければなりません。マップ型の場合は、 *key* に誤りがある場合（コンテナに含まれていない場合）、 :exc:`KeyError` を送出しなければなりません。"

#: ../../reference/datamodel.rst:1918
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ":keyword:`for` ループでは、シーケンスの終端を正しく検出できるようにするために、不正なインデクスに対して :exc:`IndexError` が送出されるものと期待しています。"

#: ../../reference/datamodel.rst:1924
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]``"
" for dict subclasses when key is not in the dictionary."
msgstr "``self[key]`` の実装において辞書内にキーが存在しなかった場合に、 dict のサブクラスのために :class:`dict`\\ .\\ :meth:`__getitem__` によって呼び出されます。"

#: ../../reference/datamodel.rst:1930
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the "
"objects support changes to the values for keys, or if new keys can be added,"
" or for sequences if elements can be replaced.  The same exceptions should "
"be raised for improper *key* values as for the :meth:`__getitem__` method."
msgstr "``self[key]`` に対する代入を実現するために呼び出されます。 :meth:`__getitem__` と同じ注意事項があてはまります。このメソッドを実装できるのは、あるキーに対する値の変更をサポートしているか、新たなキーを追加できるようなマップの場合と、ある要素を置き換えることができるシーケンスの場合だけです。不正な *key* に対しては、 :meth:`__getitem__` メソッドと同様の例外の送出を行わなければなりません。"

#: ../../reference/datamodel.rst:1939
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the "
"objects support removal of keys, or for sequences if elements can be removed"
" from the sequence.  The same exceptions should be raised for improper *key*"
" values as for the :meth:`__getitem__` method."
msgstr "``self[key]`` の削除を実現するために呼び出されます。 :meth:`__getitem__` と同じ注意事項があてはまります。このメソッドを実装できるのは、キーの削除をサポートしているマップの場合と、要素を削除できるシーケンスの場合だけです。不正な *key* に対しては、 :meth:`__getitem__` メソッドと同様の例外の送出を行わなければなりません。"

#: ../../reference/datamodel.rst:1948
msgid ""
"This method is called when an iterator is required for a container. This "
"method should return a new iterator object that can iterate over all the "
"objects in the container.  For mappings, it should iterate over the keys of "
"the container, and should also be made available as the method "
":meth:`iterkeys`."
msgstr "このメソッドは、コンテナに対してイテレータが要求された際に呼び出されます。このメソッドは、コンテナ内の全てのオブジェクトにわたる反復処理ができるような、新たなイテレータオブジェクトを返さなければなりません。マップの場合、コンテナ内のキーに渡る反復処理でなければならず、かつ :meth:`iterkeys` によって利用できなければなりません。"

#: ../../reference/datamodel.rst:1953
msgid ""
"Iterator objects also need to implement this method; they are required to "
"return themselves.  For more information on iterator objects, see "
":ref:`typeiter`."
msgstr "イテレータオブジェクトでもこのメソッドを実装する必要があります; イテレータの場合、自分自身を返さなければなりません。イテレータオブジェクトに関するより詳細な情報は、 :ref:`typeiter` を参照してください。"

#: ../../reference/datamodel.rst:1959
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ":func:`reversed` 組み込み関数が逆方向イテレーションを実装するために、(存在すれば)呼び出します。コンテナ内の全要素を逆順にイテレートする、新しいイテレータを返すべきです。"

#: ../../reference/datamodel.rst:1963
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and "
":meth:`__getitem__`).  Objects that support the sequence protocol should "
"only provide :meth:`__reversed__` if they can provide an implementation that"
" is more efficient than the one provided by :func:`reversed`."
msgstr ":meth:`__reversed__` メソッドが定義されていない場合、 :func:`reversed` 組込み関数は sequence プロトコル (:meth:`__len__` と :meth:`__getitem__`) を使った方法にフォールバックします。 sequence プロトコルをサポートしたオブジェクトは、 :func:`reversed` よりも効率のいい実装を提供できる場合にのみ :meth:`__reversed__` を定義するべきです。"

#: ../../reference/datamodel.rst:1972
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a sequence.  However, container"
" objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be a sequence."
msgstr "メンバシップテスト演算子 (:keyword:`in` および :keyword:`not in`) は通常、シーケンスに渡る反復処理を使って実装されます。しかし、コンテナオブジェクトで以下の特殊メソッドを定義して、より効率的な実装を行ったり、オブジェクトがシーケンスでなくてもよいようにできます。"

#: ../../reference/datamodel.rst:1979
msgid ""
"Called to implement membership test operators.  Should return true if *item*"
" is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr "メンバシップテスト演算を実現するために呼び出されます。 *item* が *self* 内に存在する場合には真を、そうでない場合には偽を返さなければなりません。マップオブジェクトの場合、値やキーと値の組ではなく、キーに対するメンバシップテストを考えなければなりません。"

#: ../../reference/datamodel.rst:1983
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ":meth:`__contains__` を定義しないオブジェクトに対しては、メンバシップテストはまず、 :meth:`__iter__` を使った反復を試みます、次に古いシーケンス反復プロトコル :meth:`__getitem__` を使います、 :ref:`言語レファレンスのこの節 <membership-test-details>` を参照して下さい。"

#: ../../reference/datamodel.rst:1992
msgid "Additional methods for emulation of sequence types"
msgstr "シーケンス型エミュレーションで使われるその他のメソッド"

#: ../../reference/datamodel.rst:1994
msgid ""
"The following optional methods can be defined to further emulate sequence "
"objects.  Immutable sequences methods should at most only define "
":meth:`__getslice__`; mutable sequences might define all three methods."
msgstr "以下のオプションとなるメソッドを定義して、シーケンスオブジェクトをより高度にエミュレーションできます。変更不能なシーケンスのメソッドでは、 :meth:`__getslice__` が定義できるだけです; 変更可能なシーケンスでは三つのメソッド全てを定義できます。"

#: ../../reference/datamodel.rst:2001
msgid ""
"Support slice objects as parameters to the :meth:`__getitem__` method. "
"(However, built-in types in CPython currently still implement "
":meth:`__getslice__`.  Therefore, you have to override it in derived classes"
" when implementing slicing.)"
msgstr "スライスオブジェクトは :meth:`__getitem__` メソッドのパラメタとしてサポートするようになりました。 (しかし、現在の CPython はいまだに :meth:`__getslice__` を実装しています。なので、派生クラスでスライスを実装する場合は、このメソッドをオーバーライドしなければなりません。)"

#: ../../reference/datamodel.rst:2007
msgid ""
"Called to implement evaluation of ``self[i:j]``. The returned object should "
"be of the same type as *self*.  Note that missing *i* or *j* in the slice "
"expression are replaced by zero or :attr:`sys.maxsize`, respectively.  If "
"negative indexes are used in the slice, the length of the sequence is added "
"to that index. If the instance does not implement the :meth:`__len__` "
"method, an :exc:`AttributeError` is raised. No guarantee is made that "
"indexes adjusted this way are not still negative.  Indexes which are greater"
" than the length of the sequence are not modified. If no "
":meth:`__getslice__` is found, a slice object is created instead, and passed"
" to :meth:`__getitem__` instead."
msgstr "``self[i:j]`` の値評価を実現するために呼び出されます。返されるオブジェクトは *self* と同じ型でなければなりません。スライス表記で *i* や *j* がない場合には、それぞれゼロや :attr:`sys.maxsize` に置き換えられるので注意してください。スライスに負のインデクスが用いられた場合、シーケンスの長さがインデクス値に加算されます。インスタンスが :meth:`__len__` メソッドを実装していない場合には、 :exc:`AttributeError` が送出されます。この計算の結果、インデクス値が負でなくなるという保証はありません。シーケンスの長さよりも大きなインデクス値は修正されません。 :meth:`__getslice__` が定義されていない場合、代わりにスライスオブジェクトが生成されて :meth:`__getitem__` に渡されます。"

#: ../../reference/datamodel.rst:2020
msgid ""
"Called to implement assignment to ``self[i:j]``. Same notes for *i* and *j* "
"as for :meth:`__getslice__`."
msgstr "``self[i:j]`` への代入を実現するために呼び出されます。 *i* および *j* に関しては、 :meth:`__getslice__` と同じ注釈があてはまります。"

#: ../../reference/datamodel.rst:2023
msgid ""
"This method is deprecated. If no :meth:`__setslice__` is found, or for "
"extended slicing of the form ``self[i:j:k]``, a slice object is created, and"
" passed to :meth:`__setitem__`, instead of :meth:`__setslice__` being "
"called."
msgstr "このメソッドは撤廃されています。 :meth:`__setslice__` がないか、 ``self[i:j:k]`` 形式の拡張スライスの場合には、 :meth:`__setslice__` が呼ばれる代わりにスライスオブジェクトが生成され、 :meth:`__setitem__` に渡されます。"

#: ../../reference/datamodel.rst:2030
msgid ""
"Called to implement deletion of ``self[i:j]``. Same notes for *i* and *j* as"
" for :meth:`__getslice__`. This method is deprecated. If no "
":meth:`__delslice__` is found, or for extended slicing of the form "
"``self[i:j:k]``, a slice object is created, and passed to "
":meth:`__delitem__`, instead of :meth:`__delslice__` being called."
msgstr "``self[i:j]`` の削除を実現するために呼び出されます。 *i* および *j* に関しては、 :meth:`__getslice__` と同じ注釈があてはまります。このメソッドは撤廃されています。 :meth:`__delslice__` がないか、 ``self[i:j:k]`` 形式の拡張スライスの場合には、 :meth:`__delslice__` が呼ばれる代わりにスライスオブジェクトが生成され、 :meth:`__delitem__` に渡されます。"

#: ../../reference/datamodel.rst:2036
msgid ""
"Notice that these methods are only invoked when a single slice with a single"
" colon is used, and the slice method is available.  For slice operations "
"involving extended slice notation, or in absence of the slice methods, "
":meth:`__getitem__`, :meth:`__setitem__` or :meth:`__delitem__` is called "
"with a slice object as argument."
msgstr "これらのメソッドは、単一のコロンを使った単一のスライスで、かつスライスメソッドが利用できるときにだけ呼び出されることに注意してください。拡張スライス表記を含んでいるスライス表記や、スライスメソッドがない場合、 :meth:`__getitem__` 、 :meth:`__setitem__` 、あるいは :meth:`__delitem__` がスライスオブジェクトを引数として呼び出されます。"

#: ../../reference/datamodel.rst:2042
msgid ""
"The following example demonstrate how to make your program or module "
"compatible with earlier versions of Python (assuming that methods "
":meth:`__getitem__`, :meth:`__setitem__` and :meth:`__delitem__` support "
"slice objects as arguments)::"
msgstr "以下の例は、プログラムやモジュールを以前のバージョンの Python に対して互換性を持たせる方法を示したものです (:meth:`__getitem__` 、 :meth:`__setitem__` 、および :meth:`__delitem__` は引数としてスライスオブジェクトをサポートするものと仮定します)::"

#: ../../reference/datamodel.rst:2067
msgid ""
"Note the calls to :func:`max`; these are necessary because of the handling "
"of negative indices before the :meth:`__\\*slice__` methods are called.  "
"When negative indexes are used, the :meth:`__\\*item__` methods receive them"
" as provided, but the :meth:`__\\*slice__` methods get a \"cooked\" form of "
"the index values.  For each negative index value, the length of the sequence"
" is added to the index before calling the method (which may still result in "
"a negative index); this is the customary handling of negative indexes by the"
" built-in sequence types, and the :meth:`__\\*item__` methods are expected "
"to do this as well.  However, since they should already be doing that, "
"negative indexes cannot be passed in; they must be constrained to the bounds"
" of the sequence before being passed to the :meth:`__\\*item__` methods. "
"Calling ``max(0, i)`` conveniently returns the proper value."
msgstr ":func:`max` を呼び出していることに注意してください; この呼び出し :meth:`__\\*slice__` メソッド呼び出される前に、負のインデクス値を処理しておくために必要です。負のインデクス値が使われた場合、 :meth:`__\\*item__` メソッドは与えられた値をそのまま使いますが、 :meth:`__\\*slice__` メソッドは \"調理済みの (cooked)\" 形式になったインデクス値を受け取ります。負のインデクス値が使われると、メソッドを呼び出す前に、常にシーケンスの長さをインデクス値に加算します (加算してもまだ負の値となっていてもかまいません); これは、組み込みシーケンス型における慣習的な負のインデクス処理方法で、 :meth:`__\\*item__` メソッドでも同様の処理を行うよう期待しています。しかし、ここではすでに負のインデクス値の処理を行っているので、負のインデクスを渡すべきではありません; インデクス値は、 :meth:`__\\*item__` メソッドに渡される前に、シーケンスのインデクス集合の境界に制限されていなければなりません。 ``max(0, i)`` を呼び出せば、適切な値を返すので便利です。"

#: ../../reference/datamodel.rst:2084
msgid "Emulating numeric types"
msgstr "数値型をエミュレーションする"

#: ../../reference/datamodel.rst:2086
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of"
" number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr "以下のメソッドを定義して、数値型オブジェクトをエミュレートすることができます。特定の種類の数値型ではサポートされていないような演算に対応するメソッド (非整数の数値に対するビット単位演算など) は、未定義のままにしておかなければなりません。"

#: ../../reference/datamodel.rst:2110
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, "
"``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to evaluate the "
"expression ``x + y``, where *x* is an instance of a class that has an "
":meth:`__add__` method, ``x.__add__(y)`` is called.  The :meth:`__divmod__` "
"method should be the equivalent to using :meth:`__floordiv__` and "
":meth:`__mod__`; it should not be related to :meth:`__truediv__` (described "
"below).  Note that :meth:`__pow__` should be defined to accept an optional "
"third argument if the ternary version of the built-in :func:`pow` function "
"is to be supported."
msgstr "これらのメソッドは、二項算術演算 (``+``, ``-``, ``*``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) を実現するために呼び出されます。例えば、式 ``x + y`` の場合、 *x* が :meth:`__add__` メソッドをもつクラスのインスタンスであれば、 ``x.__add__(y)`` が呼び出されます。 :meth:`__divmod__` メソッドは、 :meth:`__floordiv__` と :meth:`__mod__` を使った場合と等価にならなければなりません; :meth:`__truediv__` (下記参照) と関連づける必要はありません。組み込みの三項演算子バージョンの関数 :func:`pow` をサポートする場合には、 :meth:`__pow__` は、オプションとなる第三の引数を受け取れなくてはなりません。"

#: ../../reference/datamodel.rst:2120
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr "こらのメソッドが渡された引き数に対する操作を提供していない場合には、 ``NotImplemented`` を送出しなければなりません。"

#: ../../reference/datamodel.rst:2127
msgid ""
"The division operator (``/``) is implemented by these methods.  The "
":meth:`__truediv__` method is used when ``__future__.division`` is in "
"effect, otherwise :meth:`__div__` is used.  If only one of these two methods"
" is defined, the object will not support division in the alternate context; "
":exc:`TypeError` will be raised instead."
msgstr "除算演算 (``/``) は、これらのメソッドで実現されています。 :meth:`__truediv__` は、 ``__future__.division`` が有効であるときに使われます。それ以外の場合には :meth:`__div__` が使われますs。二つのメソッドのうち一方しか定義されていなければ、オブジェクトは他方の演算コンテキストをサポートしなくなります; このとき、 :exc:`TypeError` が送出されます。"

#: ../../reference/datamodel.rst:2153
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``/``, ``%``, :func:`divmod`, :func:`pow`, ``**``, "
"``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) operands.  "
"These functions are only called if the left operand does not support the "
"corresponding operation and the operands are of different types. [#]_ For "
"instance, to evaluate the expression ``x - y``, where *y* is an instance of "
"a class that has an :meth:`__rsub__` method, ``y.__rsub__(x)`` is called if "
"``x.__sub__(y)`` returns *NotImplemented*."
msgstr "これらのメソッドは二項算術演算 (``+``, ``-``, ``*``, ``/``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) を実現しますが、メソッド呼び出しが行われる被演算子が逆転して (reflected, swapped: 入れ替えられて) います。これらの関数は、左側の被演算子が対応する演算をサポートしておらずかつ両者の演算子が異なる場合にのみ呼び出されます。 [#]_ 例えば、 ``x - y`` の式を評価する場合、 *y* が :meth:`__rsub__` メソッドを持つクラスのインスタンスであって、しかも ``x.__sub__(y)`` が *NotImplemented* を返す場合には、 ``y.__rsub__(x)`` が呼び出されます。"

#: ../../reference/datamodel.rst:2164
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr "ただし、三項演算子 :func:`pow` が :meth:`__rpow__` を呼ぶことはないので注意してください (型強制の規則が非常に難解になるからです)。"

#: ../../reference/datamodel.rst:2169
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides the reflected method for the operation, this method "
"will be called before the left operand's non-reflected method.  This "
"behavior allows subclasses to override their ancestors' operations."
msgstr "右側の被演算子の型が左側の被演算子の型のサブクラスであり、このサブクラスであるメソッドに対する逆転メソッドが定義されている場合には、左側の被演算子の非逆転メソッドが呼ばれる前に、このメソッドが呼ばれます。この振る舞いにより、サブクラスが親の操作をオーバーライドすることが可能になります。"

#: ../../reference/datamodel.rst:2189
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``,"
" ``&=``, ``^=``, ``|=``).  These methods should attempt to do the operation "
"in-place (modifying *self*) and return the result (which could be, but does "
"not have to be, *self*).  If a specific method is not defined, the augmented"
" assignment falls back to the normal methods.  For instance, to execute the "
"statement ``x += y``, where *x* is an instance of a class that has an "
":meth:`__iadd__` method, ``x.__iadd__(y)`` is called.  If *x* is an instance"
" of a class that does not define a :meth:`__iadd__` method, ``x.__add__(y)``"
" and ``y.__radd__(x)`` are considered, as with the evaluation of ``x + y``."
msgstr "これらのメソッドは、累算算術代入 (augmented arithmetic assignments, ``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``) を実現するために呼び出されます。これらのメソッドは、演算をその場で(*self* を変更する形で) 行うよう試み、その結果(変更された *self* またはその代わりのもの)を返さなければなりません。特定のメソッドが定義されていない場合、その累算算術演算は通常のメソッドで代用されます。例えば、 ``x += y`` を評価する際、 *x* が :meth:`__iadd__` メソッドを持つクラスのインスタンスであれば、 ``x.__iadd__(y)`` が呼び出されます。逆に、 *x* が :meth:`__iadd` メソッドを持たないクラスのインスタンスであれば、 ``x + y`` の評価と同じように ``x.__add__(y)`` および ``y.__radd__(x)`` を考慮します。"

#: ../../reference/datamodel.rst:2208
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, "
":func:`abs` and ``~``)."
msgstr "単項算術演算 (``-``, ``+``, :func:`abs` および ``~``) を実現するために呼び出されます。"

#: ../../reference/datamodel.rst:2223
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int`, "
":func:`long`, and :func:`float`.  Should return a value of the appropriate "
"type."
msgstr "組み込み関数 :func:`complex`, :func:`int`, :func:`long`, および :func:`float` を実現するために呼び出されます。適切な型の値を返さなければなりません。"

#: ../../reference/datamodel.rst:2234
msgid ""
"Called to implement the built-in functions :func:`oct` and :func:`hex`.  "
"Should return a string value."
msgstr "組み込み関数 :func:`oct` および :func:`hex` を実現するために呼び出されます。文字列型を返さなければなりません。"

#: ../../reference/datamodel.rst:2240
msgid ""
"Called to implement :func:`operator.index`.  Also called whenever Python "
"needs an integer object (such as in slicing).  Must return an integer (int "
"or long)."
msgstr ":func:`operator.index` を実装するために呼び出されます。また、（スライシング）のように Python が整数オブジェクトを必要とする場合には何処でも呼び出されます。整数（int もしくは long）を返す必要があります。"

#: ../../reference/datamodel.rst:2248
msgid ""
"Called to implement \"mixed-mode\" numeric arithmetic.  Should either return"
" a 2-tuple containing *self* and *other* converted to a common numeric type,"
" or ``None`` if conversion is impossible.  When the common type would be the"
" type of ``other``, it is sufficient to return ``None``, since the "
"interpreter will also ask the other object to attempt a coercion (but "
"sometimes, if the implementation of the other type cannot be changed, it is "
"useful to do the conversion to the other type here).  A return value of "
"``NotImplemented`` is equivalent to returning ``None``."
msgstr "\"型混合モード (mixed-mode)\" での数値間の算術演算を実現するために呼び出されます。 *self* と *other* を共通の数値型に変換して、 2 要素のタプルにして返すか、不可能な場合には ``None`` を返さなければなりません。共通の型が ``other`` の型になる場合、 ``None`` を返すだけで十分です。この場合、インタプリタはもう一方のオブジェクトを調べて型強制を行おうとするからです (とはいえ、もう一方の値の型が実装上変更できない場合には、ここで *self* を *other* の型に変換しておいた方が便利です)。戻り値に ``NotImplemented`` を使うのは、 ``None`` を返すのと同じです。"

#: ../../reference/datamodel.rst:2261
msgid "Coercion rules"
msgstr "型強制規則 (coercion rule)"

#: ../../reference/datamodel.rst:2263
msgid ""
"This section used to document the rules for coercion.  As the language has "
"evolved, the coercion rules have become hard to document precisely; "
"documenting what one version of one particular implementation does is "
"undesirable.  Instead, here are some informal guidelines regarding coercion."
"  In Python 3, coercion will not be supported."
msgstr "本節では、型強制 (coercion) に関する規則について記述します。プログラム言語が進化するにつれ、型強制規則について正確に記述するのは難しくなってゆきます; 従って、あるバージョンのある実装について記述するのは望ましくありません。その代わりに、型強制に関する非公式的なガイドラインを示しておきます。 Python 3 からは、型強制がサポートされなくなる予定です。"

#: ../../reference/datamodel.rst:2271
msgid ""
"If the left operand of a % operator is a string or Unicode object, no "
"coercion takes place and the string formatting operation is invoked instead."
msgstr "% 演算子の左被演算子が文字列か Unicode オブジェクトの場合、型強制は起きず、文字列としての書式化操作が呼び出されます。"

#: ../../reference/datamodel.rst:2276
msgid ""
"It is no longer recommended to define a coercion operation. Mixed-mode "
"operations on types that don't define coercion pass the original arguments "
"to the operation."
msgstr "型強制演算の定義はもはや推奨されていません。型強制を定義していない混合型 (mixed-mode) 演算は、もとの引数をそのまま演算操作に渡すようになっています。"

#: ../../reference/datamodel.rst:2282
msgid ""
"New-style classes (those derived from :class:`object`) never invoke the "
":meth:`__coerce__` method in response to a binary operator; the only time "
":meth:`__coerce__` is invoked is when the built-in function :func:`coerce` "
"is called."
msgstr "新しい形式のクラス (:class:`object` から派生したもの) が、二項演算子に対して :meth:`__coerce__` メソッドを呼び出すことはありません。; :meth:`__coerce__` が呼び出されるのは、組み込み関数 :func:`coerce` が呼び出されたときだけです。"

#: ../../reference/datamodel.rst:2289
msgid ""
"For most intents and purposes, an operator that returns ``NotImplemented`` "
"is treated the same as one that is not implemented at all."
msgstr "事実上、 ``NotImplemented`` を返す演算子は、全く実装されていないものとして扱われます。"

#: ../../reference/datamodel.rst:2294
msgid ""
"Below, :meth:`__op__` and :meth:`__rop__` are used to signify the generic "
"method names corresponding to an operator; :meth:`__iop__` is used for the "
"corresponding in-place operator.  For example, for the operator '``+``', "
":meth:`__add__` and :meth:`__radd__` are used for the left and right variant"
" of the binary operator, and :meth:`__iadd__` for the in-place variant."
msgstr "以下の説明では、 :meth:`__op__` および :meth:`__rop__` は、演算子に相当する一般的なメソッド名を表すために使われます; :meth:`__iop__` はインプレース演算子を表します。例えば、演算子 '``+``' の場合、 :meth:`__add__` および :meth:`__radd__` がそれぞれ左右の被演算子用の二項演算子として使われ、 :meth:`__iadd__` がインプレース演算用の演算子として使われる、といった具合です。"

#: ../../reference/datamodel.rst:2302
msgid ""
"For objects *x* and *y*, first ``x.__op__(y)`` is tried.  If this is not "
"implemented or returns ``NotImplemented``, ``y.__rop__(x)`` is tried.  If "
"this is also not implemented or returns ``NotImplemented``, a "
":exc:`TypeError` exception is raised.  But see the following exception:"
msgstr "オブジェクト *x* および *y* に対して、まず ``x.__op__(y)`` が試されます。この演算が実装されていないか、 ``NotImplemented`` を返す場合、次に ``y.__rop__(x)`` が試されます。この演算も実装されていないか、 ``NotImplemented`` を返すなら、 :exc:`TypeError` 例外が送出されます。ただし、以下の例外があるので参照してください:"

#: ../../reference/datamodel.rst:2309
msgid ""
"Exception to the previous item: if the left operand is an instance of a "
"built-in type or a new-style class, and the right operand is an instance of "
"a proper subclass of that type or class and overrides the base's "
":meth:`__rop__` method, the right operand's :meth:`__rop__` method is tried "
"*before* the left operand's :meth:`__op__` method."
msgstr "前項に対する例外: 左被演算子が組み込み型や新スタイルクラスのインスタンスであり、かつ右被演算子が左被演算子と同じクラスか適切なサブクラスのインスタンスであり、さらに親クラスの :meth:`__rop__` メソッドをオーバライドしている場合、左被演算子の :meth:`__op__` メソッドを試す *前に* 右被演算子の :meth:`__rop__` が試されます。"

#: ../../reference/datamodel.rst:2315
msgid ""
"This is done so that a subclass can completely override binary operators. "
"Otherwise, the left operand's :meth:`__op__` method would always accept the "
"right operand: when an instance of a given class is expected, an instance of"
" a subclass of that class is always acceptable."
msgstr "これは、サブクラス側で二項演算子を完全にオーバライドできるようにするためです。そうしなければ、常に左被演算子の :meth:`__op__` メソッドが右被演算子を受理してしまいます: あるクラスのインスタンスが被演算子になるとされている場合、そのサブクラスのインスタンスもまた受理可能だからです。"

#: ../../reference/datamodel.rst:2322
msgid ""
"When either operand type defines a coercion, this coercion is called before "
"that type's :meth:`__op__` or :meth:`__rop__` method is called, but no "
"sooner.  If the coercion returns an object of a different type for the "
"operand whose coercion is invoked, part of the process is redone using the "
"new object."
msgstr "双方の被演算子が型強制を定義している場合、型強制は被演算子の型の :meth:`__op__` や :meth:`__rop__` メソッドが呼び出される前に呼び出され、それより早くなることはありません。型強制の結果、型強制を行うことになったいずれの被演算子とも異なる型が返された場合、返されたオブジェクトの新たな型を使って、この過程が部分的に再度行われます。"

#: ../../reference/datamodel.rst:2329
msgid ""
"When an in-place operator (like '``+=``') is used, if the left operand "
"implements :meth:`__iop__`, it is invoked without any coercion.  When the "
"operation falls back to :meth:`__op__` and/or :meth:`__rop__`, the normal "
"coercion rules apply."
msgstr "('``+=``' のような) インプレース型の演算子を用いる際、左被演算子が :meth:`__iop__` を実装していれば、 :meth:`__iop__` が呼び出され、型強制は一切行われません。演算が :meth:`__op__` かつ/または :meth:`__rop__` に帰着した場合、通常の型強制規則が適用されます。"

#: ../../reference/datamodel.rst:2336
msgid ""
"In ``x + y``, if *x* is a sequence that implements sequence concatenation, "
"sequence concatenation is invoked."
msgstr "``x + y`` において、 *x* が結合 (concatenation) 演算を実装しているシーケンスであれば、シーケンスの結合が実行されます。"

#: ../../reference/datamodel.rst:2341
msgid ""
"In ``x * y``, if one operand is a sequence that implements sequence "
"repetition, and the other is an integer (:class:`int` or :class:`long`), "
"sequence repetition is invoked."
msgstr "``x * y`` において、一方の演算子が繰り返し (repeat) 演算を実装しているシーケンスであり、かつ他方が整数 (:class:`int` または :class:`long`) である場合、シーケンスの繰り返しが実行されます。"

#: ../../reference/datamodel.rst:2347
msgid ""
"Rich comparisons (implemented by methods :meth:`__eq__` and so on) never use"
" coercion.  Three-way comparison (implemented by :meth:`__cmp__`) does use "
"coercion under the same conditions as other binary operations use it."
msgstr "(:meth:`__eq__` などのメソッドで実装されている) 拡張比較は、決して型強制を行いません。(:meth:`__cmp__` で実装されている) 三値比較 (three-way comparison) は、他の二項演算子で行われているのと同じ条件で型強制を受けます。"

#: ../../reference/datamodel.rst:2353
msgid ""
"In the current implementation, the built-in numeric types :class:`int`, "
":class:`long`, :class:`float`, and :class:`complex` do not use coercion. All"
" these types implement a :meth:`__coerce__` method, for use by the built-in "
":func:`coerce` function."
msgstr "現在の実装では、組み込み数値型 :class:`int`, :class:`long`, :class:`float` および :class:`complex` は型強制を行いません; これらの型は全て、関数 :func:`coerce` から利用するための :meth:`__coerce__` メソッドを実装しています。"

#: ../../reference/datamodel.rst:2360
msgid ""
"The complex type no longer makes implicit calls to the :meth:`__coerce__` "
"method for mixed-type binary arithmetic operations."
msgstr "複素数型は、型混合の二項算術演算に :meth:`__coerce__` を暗示的に呼び出さなくなりました。"

#: ../../reference/datamodel.rst:2367
msgid "With Statement Context Managers"
msgstr "with文とコンテキストマネージャ"

#: ../../reference/datamodel.rst:2371
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be"
" established when executing a :keyword:`with` statement. The context manager"
" handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr "コンテキストマネージャ(:dfn:`context manager`) とは、 :keyword:`with` 文の実行時にランタイムコンテキストを定義するオブジェクトです。コンテキストマネージャは、コードブロックを実行するために必要な入り口および出口の処理を扱います。コンテキストマネージャは通常、 :keyword:`with` 文（ :ref:`with` の章を参照）により起動されますが、これらのメソッドを直接呼び出すことで起動することもできます。"

#: ../../reference/datamodel.rst:2382
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr "コンテキストマネージャの代表的な使い方としては、様々なグローバル情報の保存および更新、リソースのロックとアンロック、ファイルのオープンとクローズなどが挙げられます。"

#: ../../reference/datamodel.rst:2385
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`."
msgstr "コンテキストマネージャについてのさらなる情報については、 :ref:`typecontextmanager` を参照してください。"

#: ../../reference/datamodel.rst:2390
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in"
" the :keyword:`as` clause of the statement, if any."
msgstr "コンテキストマネージャのの入り口で実行される処理です。 :keyword:`with` 文は、文の :keyword:`as` 節で規定された値を返すこのメソッドを呼び出します。"

#: ../../reference/datamodel.rst:2397
msgid ""
"Exit the runtime context related to this object. The parameters describe the"
" exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr "コンテキストマネージャの出口で実行される処理です。パラメータは、コンテキストが終了した原因となった例外について説明しています。コンテキストが例外を送出せず終了した場合は、全ての引き数に :const:`None` が設定されます。"

#: ../../reference/datamodel.rst:2401
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception"
" (i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr "もし、例外が送出され、かつメソッドが例外を抑制したい場合（すなわち、例外が伝播されるのを防ぎたい場合）、このメソッドは True を返す必要があります。そうでなければ、このメソッドの終了後、例外は通常通り伝播することになります。"

#: ../../reference/datamodel.rst:2405
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ":meth:`__exit__` メソッドは受け取った例外を再度送出すべきではありません。これは、呼び出し側の責任でおこなってください。"

#: ../../reference/datamodel.rst:2412
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" ステートメント"

#: ../../reference/datamodel.rst:2412
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python の :keyword:`with` 文の仕様、背景、および例が記載されています。"

#: ../../reference/datamodel.rst:2419
msgid "Special method lookup for old-style classes"
msgstr "旧スタイルクラスの特殊メソッド検索"

#: ../../reference/datamodel.rst:2421
msgid ""
"For old-style classes, special methods are always looked up in exactly the "
"same way as any other method or attribute. This is the case regardless of "
"whether the method is being looked up explicitly as in ``x.__getitem__(i)`` "
"or implicitly as in ``x[i]``."
msgstr "旧スタイルクラスにおいて、特殊メソッドは常に他のメソッドや属性と同じ方法で検索されます。これは、メソッドが ``x.__getitem__(i)`` のように明示的に検索された時も、 ``x[i]`` のように暗黙的に検索された時も同じです。"

#: ../../reference/datamodel.rst:2426
msgid ""
"This behaviour means that special methods may exhibit different behaviour "
"for different instances of a single old-style class if the appropriate "
"special attributes are set differently::"
msgstr "これにより、1つの旧スタイルクラスの異なるインスタンスが、それぞれ別の適切な特殊属性を持っている場合、異なる動作をすることになります。 ::"

#: ../../reference/datamodel.rst:2446
msgid "Special method lookup for new-style classes"
msgstr "新スタイルクラスの特殊メソッド検索"

#: ../../reference/datamodel.rst:2448
msgid ""
"For new-style classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception (unlike the equivalent example with old-"
"style classes)::"
msgstr "新スタイルクラスでは、特殊メソッドの暗黙的な呼び出しは、オブジェクトインスタンスの辞書ではなく、 type の辞書で定義されているときにのみ正しく動作することが保証されます。この動作は、以下のコードが(旧スタイルクラスの同等な例と異なり)例外を発生させる理由です。 ::"

#: ../../reference/datamodel.rst:2463
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`__hash__` and :meth:`__repr__` that are implemented by all "
"objects, including type objects. If the implicit lookup of these methods "
"used the conventional lookup process, they would fail when invoked on the "
"type object itself::"
msgstr "この動作の背景となる理由は、 :meth:`__hash__` と :meth:`__repr__` といった type オブジェクトを含むすべてのオブジェクトで定義されている特殊メソッドにあります。これらのメソッドの暗黙の検索が通常の検索プロセスを使った場合、 type オブジェクト自体に対して実行されたときに失敗してしまいます::"

#: ../../reference/datamodel.rst:2476
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is"
" sometimes referred to as 'metaclass confusion', and is avoided by bypassing"
" the instance when looking up special methods::"
msgstr "クラスの非結合メソッドをこのようにして実行しようとすることは、'metaclass confusion' と呼ばれることもあり、特殊メソッドを検索するときはインスタンスをバイパスすることで回避されます::"

#: ../../reference/datamodel.rst:2485
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the "
":meth:`__getattribute__` method even of the object's metaclass::"
msgstr "正確性のためにインスタンス属性をスキップするのに加えて、特殊メソッド検索はオブジェクトのメタクラスを含めて、 :meth:`__getattribute__` メソッドもバイパスします::"

#: ../../reference/datamodel.rst:2512
msgid ""
"Bypassing the :meth:`__getattribute__` machinery in this fashion provides "
"significant scope for speed optimisations within the interpreter, at the "
"cost of some flexibility in the handling of special methods (the special "
"method *must* be set on the class object itself in order to be consistently "
"invoked by the interpreter)."
msgstr "このように :meth:`__getattribute__` 機構をバイパスすることで、特殊メソッドの扱いに関するある程度の自由度と引き換えに (特殊メソッドはインタプリタから一貫して実行されるためにクラスオブジェクトに設定 *しなければならない*)、インタープリタを高速化するための大きな余地が手に入ります。"

#: ../../reference/datamodel.rst:2520
msgid "Footnotes"
msgstr "注記"

#: ../../reference/datamodel.rst:2521
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr "特定の条件が満たされた場合、オブジェクトの type を変更することが *できます* 。これは、正しく扱われなかった場合にとても奇妙な動作を引き起こすので、一般的には良い考えではありません。"

#: ../../reference/datamodel.rst:2525
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method (such as :meth:`__add__`) fails the operation is not supported, which"
" is why the reflected method is not called."
msgstr "同じ型の操作に対しては、(:meth:`__add__` のような)逆転できないメソッドが失敗した時と同じような想定のもと処理されます。これは、逆転したメソッドを呼び出すことができないからです。"
