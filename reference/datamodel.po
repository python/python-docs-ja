# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-17 14:56+0900\n"
"PO-Revision-Date: 2018-06-29 17:52+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr "ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«"

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€å€¤ã€ãŠã‚ˆã³å‹"

#: ../../reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer,\" code is also represented by objects.)"
msgstr ""
"Python ã«ãŠã‘ã‚‹ :dfn:`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (object)` ã¨ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½è±¡çš„ã«è¡¨ã—ãŸã‚‚ã®ã§ã™ã€‚Python "
"ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã‘ã‚‹ãƒ‡ãƒ¼ã‚¿ã¯å…¨ã¦ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé–“ã®é–¢ä¿‚ã¨ã—ã¦è¡¨ã•ã‚Œã¾ã™ã€‚(ã‚ã‚‹æ„å‘³ã§ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚³ãƒ¼ãƒ‰ã‚‚ã¾ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¡¨ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ãƒ•ã‚©ãƒ³ãƒ»ãƒã‚¤ãƒãƒ³:"
" Von Neumann ã® \"ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨˜æ†¶æ–¹å¼ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿: stored program computer\" ã®ãƒ¢ãƒ‡ãƒ«ã«é©åˆã—ã¾ã™ã€‚)"

#: ../../reference/datamodel.rst:35
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The ':keyword:`is`' operator compares the identity of "
"two objects; the :func:`id` function returns an integer representing its "
"identity."
msgstr ""
"ã™ã¹ã¦ã®å±æ€§ã¯ã€åŒä¸€æ€§ (identity)ã€å‹ã€å€¤ã‚’ã‚‚ã£ã¦ã„ã¾ã™ã€‚ *åŒä¸€æ€§* "
"ã¯ç”Ÿæˆã•ã‚ŒãŸã‚ã¨ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ã‚ˆã†ãªã‚‚ã®ã ã¨è€ƒãˆã‚‰ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ ':keyword:`is`' "
"æ¼”ç®—å­ã¯2ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŒä¸€æ€§ã‚’æ¯”è¼ƒã—ã¾ã™ã€‚ :func:`id` é–¢æ•°ã¯åŒä¸€æ€§ã‚’è¡¨ã™æ•´æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:42
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr "CPython ã§ã¯ã€``id(x)`` ã¯ ``x`` ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ¡ãƒ¢ãƒªä¸Šã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:44
msgid ""
"An object's type determines the operations that the object supports (e.g., "
"\"does it have a length?\") and also defines the possible values for objects"
" of that type.  The :func:`type` function returns an object's type (which is"
" an object itself).  Like its identity, an object's :dfn:`type` is also "
"unchangeable. [#]_"
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹æ“ä½œ (ä¾‹: :func:`len` ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‹) ã¨ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå–ã‚Šã†ã‚‹å€¤ã‚’æ±ºå®šã—ã¾ã™ã€‚ "
":func:`type` é–¢æ•°ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ (å‹è‡ªä½“ã‚‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™) ã‚’è¿”ã—ã¾ã™ã€‚åŒä¸€æ€§ã¨åŒã˜ãã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹(:dfn:`type`) "
"ã‚‚å¤‰æ›´ä¸å¯èƒ½ã§ã™ã€‚ [#]_"

#: ../../reference/datamodel.rst:50
msgid ""
"The *value* of some objects can change.  Objects whose value can change are "
"said to be *mutable*; objects whose value is unchangeable once they are "
"created are called *immutable*. (The value of an immutable container object "
"that contains a reference to a mutable object can change when the latter's "
"value is changed; however the container is still considered immutable, "
"because the collection of objects it contains cannot be changed.  So, "
"immutability is not strictly the same as having an unchangeable value, it is"
" more subtle.) An object's mutability is determined by its type; for "
"instance, numbers, strings and tuples are immutable, while dictionaries and "
"lists are mutable."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã£ã¦ã¯ *å€¤* ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚å€¤ã‚’å¤‰æ›´ã§ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã“ã¨ã‚’ *mutable* "
"ã¨å‘¼ã³ã¾ã™ã€‚ç”Ÿæˆå¾Œã«å€¤ã‚’å¤‰æ›´ã§ããªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã“ã¨ã‚’ *immutable* ã¨å‘¼ã³ã¾ã™ã€‚(mutable ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’æ ¼ç´ã—ã¦ã„ã‚‹ "
"immutableãªã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã¯ã€ãã®æ ¼ç´ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ãŒå¤‰åŒ–ã—ãŸæ™‚ã«å¤‰åŒ–ã—ã¾ã™ãŒã€ã‚³ãƒ³ãƒ†ãƒŠãŒã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ ¼ç´ã—ã¦ã„ã‚‹ã®ã‹ãŒå¤‰åŒ–ã—ãªã„ã®ã§ã‚ã‚Œã°"
" immutable ã ã¨è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€immutable ã‹ã©ã†ã‹ã¯å€¤ãŒå¤‰æ›´å¯èƒ½ã‹ã©ã†ã‹ã¨å®Œå…¨ã«ä¸€è‡´ã™ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“) "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ mutable ã‹ã©ã†ã‹ã¯ãã®å‹ã«ã‚ˆã£ã¦æ±ºã¾ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€æ•°å€¤å‹ã€æ–‡å­—åˆ—å‹ã¨ã‚¿ãƒ—ãƒ«å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ immutable ã§ã€dict"
" ã‚„ list ã¯ mutable ã§ã™ã€‚"

#: ../../reference/datamodel.rst:65
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ˜ç¤ºçš„ã«ç ´å£Šã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“; ã—ã‹ã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åˆ°é”ä¸èƒ½ (unreachable) ã«ãªã‚‹ã¨ã€ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ "
"(garbage-collection) ã«ã‚ˆã£ã¦å‡¦ç†ã•ã‚Œã¾ã™ã€‚å®Ÿè£…ã§ã¯ã€ã”ã¿åé›†ã‚’é…ã‚‰ã›ãŸã‚Šã€å…¨ãè¡Œã‚ãªã„ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ --- "
"åˆ°é”å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã”ã¿åé›†å‡¦ç†ã—ã¦ã—ã¾ã‚ãªã„ã‹ãã‚Šã€ã©ã†å®Ÿè£…ã™ã‚‹ã‹ã¯å®Ÿè£…å“è³ªã®å•é¡Œã§ã™ã€‚"

#: ../../reference/datamodel.rst:73
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (so you "
"should always close files explicitly)."
msgstr ""
"ç¾åœ¨ã® CPython å®Ÿè£…ã§ã¯å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ(reference-counting) æ–¹å¼ã‚’ä½¿ã£ã¦ãŠã‚Šã€(ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨ã—ã¦) "
"å¾ªç’°å‚ç…§ã‚’è¡Œã£ã¦ã„ã‚‹ã”ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é…å»¶æ¤œå‡ºã—ã¾ã™ã€‚ã“ã®å®Ÿè£…ã§ã¯ã»ã¨ã‚“ã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆ°é”ä¸èƒ½ã«ãªã‚‹ã¨åŒæ™‚ã«å‡¦ç†ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€å¾ªç’°å‚ç…§ã‚’å«ã‚€ã”ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åé›†ãŒç¢ºå®Ÿã«è¡Œã‚ã‚Œã‚‹ã‚ˆã†ä¿è¨¼ã—ã¦ã„ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å¾ªç’°å‚ç…§ã‚’æŒã¤ã”ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåé›†ã®åˆ¶å¾¡ã«ã¤ã„ã¦ã¯ã€"
" :mod:`gc` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ "
"CPythonä»¥å¤–ã®å®Ÿè£…ã¯åˆ¥ã®æ–¹å¼ã‚’ä½¿ã£ã¦ãŠã‚Šã€CPythonã‚‚å°†æ¥ã¯åˆ¥ã®æ–¹å¼ã‚’ä½¿ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒåˆ°é”ä¸èƒ½ã«ãªã£ãŸã¨ãã«å³åº§ã«çµ‚äº†å‡¦ç†ã•ã‚Œã‚‹ã“ã¨ã«é ¼ã‚‰ãªã„ã§ãã ã•ã„"
" (ã§ã™ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã¯å¿…ãšæ˜ç¤ºçš„ã«é–‰ã˜ã¦ãã ã•ã„)ã€‚"

#: ../../reference/datamodel.rst:82
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a ':keyword:`try`...\\ :keyword:`except`' "
"statement may keep objects alive."
msgstr ""
"å®Ÿè£…ã®ãƒˆãƒ¬ãƒ¼ã‚¹æ©Ÿèƒ½ã‚„ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ã‚’ä½¿ãˆã°ã€é€šå¸¸ã¯åé›†ã•ã‚Œã¦ã—ã¾ã†ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿå­˜ã•ã›ã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã¾ãŸã€ "
"':keyword:`try`...\\ :keyword:`except`' "
"æ–‡ã‚’ä½¿ã£ã¦ä¾‹å¤–ã‚’æ•æ‰ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã¨ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿå­˜ã•ã›ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:87
msgid ""
"Some objects contain references to \"external\" resources such as open files"
" or windows.  It is understood that these resources are freed when the "
"object is garbage-collected, but since garbage collection is not guaranteed "
"to happen, such objects also provide an explicit way to release the external"
" resource, usually a :meth:`close` method. Programs are strongly recommended"
" to explicitly close such objects.  The ':keyword:`try`...\\ "
":keyword:`finally`' statement and the ':keyword:`with`' statement provide "
"convenient ways to do this."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚„ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã¨ã„ã£ãŸã€ \"å¤–éƒ¨ (external) ã®\" "
"ãƒªã‚½ãƒ¼ã‚¹ã¸ã®å‚ç…§ã‚’å«ã‚€ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒªã‚½ãƒ¼ã‚¹ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã”ã¿åé›†ã•ã‚ŒãŸéš›ã«è§£æ”¾ã•ã‚Œã‚‹ã‚‚ã®ã¨ç†è§£ã•ã‚Œã¦ã„ã¾ã™ãŒã€ã”ã¿åé›†ãŒè¡Œã‚ã‚Œã‚‹ä¿è¨¼ã¯ãªã„ã®ã§ã€ã“ã†ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤–éƒ¨ãƒªã‚½ãƒ¼ã‚¹ã‚’æ˜ç¤ºçš„ã«è§£æ”¾ã™ã‚‹æ–¹æ³•ã€å¤§æŠµã¯"
" :meth:`close` ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚æä¾›ã—ã¦ã„ã¾ã™ã€‚ã“ã†ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ˜ç¤ºçš„ã« close "
"ã™ã‚‹ã‚ˆã†å¼·ãå¥¨ã‚ã¾ã™ã€‚ã“ã®æ“ä½œã‚’ã™ã‚‹éš›ã«ã¯ã€':keyword:`try`...\\ :keyword:`finally`' æ–‡ã‚„ã€ "
"':keyword:`with`' æ–‡ã‚’ä½¿ã†ã¨ä¾¿åˆ©ã§ã™ã€‚"

#: ../../reference/datamodel.rst:97
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk"
" about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ã‚’ã‚‚ã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ã‚ã‚Šã¾ã™; ã“ã‚Œã‚‰ã¯ *ã‚³ãƒ³ãƒ†ãƒŠ (container)* "
"ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¾‹ã¨ã—ã¦ã€ã‚¿ãƒ—ãƒ«ã€ãƒªã‚¹ãƒˆã€ãŠã‚ˆã³è¾æ›¸ãŒæŒ™ã’ã‚‰ã‚Œã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§è‡ªä½“ãŒã‚³ãƒ³ãƒ†ãƒŠã®å€¤ã®ä¸€éƒ¨ã§ã™ã€‚ã»ã¨ã‚“ã©ã®å ´åˆã€ã‚³ãƒ³ãƒ†ãƒŠã®å€¤ã¨ã„ã†ã¨ã€ã‚³ãƒ³ãƒ†ãƒŠã«å…¥ã£ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã®ã“ã¨ã‚’æŒ‡ã—ã€ãã‚Œã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã§ã¯ã‚ã‚Šã¾ã›ã‚“;"
" ã—ã‹ã—ãªãŒã‚‰ã€ã‚³ãƒ³ãƒ†ãƒŠã®å¤‰æ›´å¯èƒ½æ€§ã«ã¤ã„ã¦è¿°ã¹ã‚‹å ´åˆã€ä»Šã¾ã•ã«ã‚³ãƒ³ãƒ†ãƒŠã«å…¥ã£ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ã“ã¨ã‚’æŒ‡ã—ã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ "
"(ã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ã«) "
"å¤‰æ›´ä¸èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’å«ã‚€å ´åˆã€ãã®å€¤ãŒå¤‰åŒ–ã™ã‚‹ã®ã¯å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚ã€ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:106
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer"
" to the same object with the value one, depending on the implementation, but"
" after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two "
"different, unique, newly created empty lists. (Note that ``c = d = []`` "
"assigns the same object to both ``c`` and ``d``.)"
msgstr ""
"å‹ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹•ä½œã®ã»ã¨ã‚“ã©å…¨ã¦ã«å½±éŸ¿ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãŒé‡è¦ã‹ã©ã†ã‹ã§ã•ãˆã€ã‚ã‚‹æ„å‘³ã§ã¯å‹ã«å·¦å³ã•ã‚Œã¾ã™: "
"å¤‰æ›´ä¸èƒ½ãªå‹ã§ã¯ã€æ–°ãŸãªå€¤ã‚’è¨ˆç®—ã™ã‚‹ã‚ˆã†ãªæ“ä½œã‚’è¡Œã†ã¨ã€å®Ÿéš›ã«ã¯åŒã˜å‹ã¨å€¤ã‚’æŒã£ãŸæ—¢å­˜ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’è¿”ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ãŒã€å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãã®ã‚ˆã†ãªå‹•ä½œã¯èµ·ã“ã‚Šãˆã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€"
" ``a = 1; b = 1`` ã¨ã™ã‚‹ã¨ã€ ``a`` ã¨ ``b`` ã¯å€¤ 1 "
"ã‚’æŒã¤åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã™ã‚‹ã¨ãã‚‚ã‚ã‚‹ã—ã€ãã†ã§ãªã„ã¨ãã‚‚ã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯å®Ÿè£…ã«ä¾å­˜ã—ã¾ã™ã€‚ã—ã‹ã—ã€ ``c = []; d = []`` "
"ã¨ã™ã‚‹ã¨ã€ ``c`` ã¨ ``d`` ã¯ãã‚Œãã‚ŒäºŒã¤ã®ç•°ãªã£ãŸã€äº’ã„ã«ä¸€æ„ãªã€æ–°ãŸã«ä½œæˆã•ã‚ŒãŸç©ºã®ãƒªã‚¹ãƒˆã‚’å‚ç…§ã™ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã¾ã™ã€‚ (``c "
"= d = []`` ã¨ã™ã‚‹ã¨ã€ ``c`` ã¨ ``d`` ã®ä¸¡æ–¹ã«åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»£å…¥ã—ã¾ã™)"

#: ../../reference/datamodel.rst:120
msgid "The standard type hierarchy"
msgstr "æ¨™æº–å‹ã®éšå±¤"

#: ../../reference/datamodel.rst:129
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the"
" type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.), although such additions will often be provided via the "
"standard library instead."
msgstr ""
"ä»¥ä¸‹ã¯ Python ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹å‹ã®ãƒªã‚¹ãƒˆã§ã™ã€‚(å®Ÿè£…ã«ã‚ˆã£ã¦ã€Cã€Javaã€ã¾ãŸã¯ãã®ä»–ã®è¨€èªã§æ›¸ã‹ã‚ŒãŸ) "
"æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã€ãã®ä»–ã®å‹ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚æ–°ãŸãªå‹ (æœ‰ç†æ•°ã‚„ã€æ•´æ•°ã‚’åŠ¹ç‡çš„ã«è¨˜æ†¶ã™ã‚‹é…åˆ—ã€ãªã©) "
"ã®è¿½åŠ ã¯ã€ãŸã„ã¦ã„æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’é€šã—ã¦æä¾›ã•ã‚Œã¾ã™ãŒã€å°†æ¥ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã§ã¯ã€å‹ã®éšå±¤æ§‹é€ ã«ã“ã®ã‚ˆã†ãªè¿½åŠ ãŒãªã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:140
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation"
" and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""
"ä»¥ä¸‹ã«èª¬æ˜ã™ã‚‹å‹ã®ã„ãã¤ã‹ã«ã¯ã€ 'ç‰¹æ®Šå±æ€§ (special attribute)' "
"ã‚’åˆ—æŒ™ã—ãŸæ®µè½ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®å±æ€§ã¯å®Ÿè£…ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ‰‹æ®µã‚’æä¾›ã™ã‚‹ã‚‚ã®ã§ã€ä¸€èˆ¬çš„ãªç”¨é€”ã«åˆ©ç”¨ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ç‰¹æ®Šå±æ€§ã®å®šç¾©ã¯å°†æ¥å¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:150
msgid "None"
msgstr "None"

#: ../../reference/datamodel.rst:147
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from"
" functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"ã“ã®å‹ã«ã¯å˜ä¸€ã®å€¤ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®å€¤ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãŸã ä¸€ã¤ã—ã‹å­˜åœ¨ã—ã¾ã›ã‚“ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿å ``None`` "
"ã§ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€æ§˜ã€…ãªçŠ¶æ³ã§å€¤ãŒå­˜åœ¨ã—ãªã„ã“ã¨ã‚’ã—ã‚ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€æ˜ç¤ºçš„ã«å€¤ã‚’è¿”ã•ãªã„é–¢æ•°ã¯ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ "
"``None`` ã®çœŸå€¤ (truth value) ã¯å½ (false) ã§ã™ã€‚"

#: ../../reference/datamodel.rst:165
msgid "NotImplemented"
msgstr "NotImplemented"

#: ../../reference/datamodel.rst:155
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods should return this value if they"
" do not implement the operation for the operands provided.  (The interpreter"
" will then try the reflected operation, or some other fallback, depending on"
" the operator.)  Its truth value is true."
msgstr ""
"ã“ã®å‹ã«ã¯å˜ä¸€ã®å€¤ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®å€¤ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãŸã ä¸€ã¤ã—ã‹å­˜åœ¨ã—ã¾ã›ã‚“ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿å ``NotImplemented``"
" ã§ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã¾ã™ã€‚æ•°å€¤æ¼”ç®—ã«é–¢ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚„æ‹¡å¼µæ¯”è¼ƒ (rich comparison) "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€è¢«æ¼”ç®—å­ãŒè©²å½“ã™ã‚‹æ¼”ç®—ã‚’è¡Œã†ãŸã‚ã®å®Ÿè£…ã‚’ã‚‚ãŸãªã„å ´åˆã€ã“ã®å€¤ã‚’è¿”ã™ã¹ãã§ã™ã€‚(æ¼”ç®—å­ã«ã‚ˆã£ã¦ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒé–¢é€£ã®ã‚ã‚‹æ¼”ç®—ã‚’è©¦ã—ãŸã‚Šã€ä»–ã®ä»£æ›¿æ“ä½œã‚’è¡Œã„ã¾ã™ã€‚)"
" çœŸå€¤ã¯çœŸ (true) ã§ã™ã€‚"

#: ../../reference/datamodel.rst:162
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr "è©³ç´°ã¯ :ref:`implementing-the-arithmetic-operations` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:174
msgid "Ellipsis"
msgstr "Ellipsis"

#: ../../reference/datamodel.rst:172
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""
"ã“ã®å‹ã«ã¯å˜ä¸€ã®å€¤ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®å€¤ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãŸã ä¸€ã¤ã—ã‹å­˜åœ¨ã—ã¾ã›ã‚“ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒªãƒ†ãƒ©ãƒ« ``...`` ã¾ãŸã¯çµ„ã¿è¾¼ã¿å "
"``Ellipsis`` ã§ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã¾ã™ã€‚çœŸç†å€¤ã¯çœŸ (true)ã§ã™ã€‚"

#: ../../reference/datamodel.rst:244
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../../reference/datamodel.rst:179
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable;"
" once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""
"æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã«ã‚ˆã£ã¦ä½œæˆã•ã‚ŒãŸã‚Šã€ç®—è¡“æ¼”ç®—ã‚„çµ„ã¿è¾¼ã¿ã®ç®—è¡“é–¢æ•°ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚æ•°å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤‰æ›´ä¸èƒ½ã§ã™; "
"ä¸€åº¦å€¤ãŒç”Ÿæˆã•ã‚Œã‚‹ã¨ã€äºŒåº¦ã¨å¤‰æ›´ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚Python "
"ã®æ•°å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã„ã†ã¾ã§ã‚‚ãªãæ•°å­¦ã§è¨€ã†ã¨ã“ã‚ã®æ•°å€¤ã¨å¼·ãé–¢ä¿‚ã—ã¦ã„ã¾ã™ãŒã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿å†…ã§æ•°å€¤ã‚’è¡¨ç¾ã™ã‚‹éš›ã«ä¼´ã†åˆ¶é™ã‚’å—ã‘ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:185
msgid ""
"Python distinguishes between integers, floating point numbers, and complex "
"numbers:"
msgstr "Python ã¯æ•´æ•°ã€æµ®å‹•å°æ•°ç‚¹æ•°ã€è¤‡ç´ æ•°ã®é–“ã§åŒºåˆ¥ã‚’è¡Œã£ã¦ã„ã¾ã™:"

#: ../../reference/datamodel.rst:219
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral` (æ•´æ•°)"

#: ../../reference/datamodel.rst:191
msgid ""
"These represent elements from the mathematical set of integers (positive and"
" negative)."
msgstr "æ•´æ•°å‹ã¯ã€æ•´æ•°(æ­£ã®æ•°ãŠã‚ˆã³è² ã®æ•°)ã‚’è¡¨ã™æ•°å­¦çš„é›†åˆå†…ã«ãŠã‘ã‚‹è¦ç´ ã‚’è¡¨ç¾ã™ã‚‹å‹ã§ã™ã€‚"

#: ../../reference/datamodel.rst:194
msgid "There are two types of integers:"
msgstr "æ•´æ•°ã«ã¯ 2 ç¨®é¡ã‚ã‚Šã¾ã™:"

#: ../../reference/datamodel.rst:196
msgid "Integers (:class:`int`)"
msgstr "æ•´æ•° (:class:`int`)"

#: ../../reference/datamodel.rst:198
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""
"ç„¡åˆ¶é™ã®ç¯„å›²ã®æ•°ã‚’è¡¨ç¾ã—ã¾ã™ãŒã€åˆ©ç”¨å¯èƒ½ãª (ä»®æƒ³) "
"ãƒ¡ãƒ¢ãƒªã‚µã‚¤ã‚ºã®åˆ¶é™ã®ã¿ã‚’å—ã‘ã¾ã™ã€‚ã‚·ãƒ•ãƒˆæ¼”ç®—ã‚„ãƒã‚¹ã‚¯æ¼”ç®—ã®ãŸã‚ã«2é€²æ•°è¡¨ç¾ã‚’æŒã¤ã¨æƒ³å®šã•ã‚Œã¾ã™ã€‚è² ã®æ•°ã¯ç¬¦å·ãƒ“ãƒƒãƒˆãŒå·¦ã«ç„¡é™ã«å»¶ã³ã¦ã„ã‚‹ã‚ˆã†ãªéŒ¯è¦šã‚’ä¸ãˆã‚‹"
" 2 ã®è£œæ•°è¡¨ç¾ã®å¤‰å‹ã§è¡¨ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:214
msgid "Booleans (:class:`bool`)"
msgstr "ãƒ–ãƒ¼ãƒ«å€¤ (:class:`bool`)"

#: ../../reference/datamodel.rst:210
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects."
" The Boolean type is a subtype of the integer type, and Boolean values "
"behave like the values 0 and 1, respectively, in almost all contexts, the "
"exception being that when converted to a string, the strings ``\"False\"`` "
"or ``\"True\"`` are returned, respectively."
msgstr ""
"çœŸå½å€¤ã® False ã¨ True ã‚’è¡¨ã—ã¾ã™ã€‚``False`` ã¨ ``True`` ã‚’è¡¨ã™ 2 "
"ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ãŒãƒ–ãƒ¼ãƒ«å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ãƒ–ãƒ¼ãƒ«å‹ã¯æ•´æ•°å‹ã®æ´¾ç”Ÿå‹ã§ã‚ã‚Šã€ã»ã¨ã‚“ã©ã®çŠ¶æ³ã§ãã‚Œãã‚Œ 0 ã¨ 1 "
"ã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã„ã¾ã™ãŒã€ä¾‹å¤–ã¨ã—ã¦æ–‡å­—åˆ—ã«å¤‰æ›ã•ã‚ŒãŸã¨ãã¯ãã‚Œãã‚Œ ``\"False\"`` ãŠã‚ˆã³ ``\"True\"`` "
"ã¨ã„ã†æ–‡å­—åˆ—ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:218
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers."
msgstr "æ•´æ•°è¡¨ç¾ã«é–¢ã™ã‚‹è¦å‰‡ã¯ã€è² ã®æ•´æ•°ã‚’å«ã‚€ã‚·ãƒ•ãƒˆæ¼”ç®—ã‚„ãƒã‚¹ã‚¯æ¼”ç®—ã«ãŠã„ã¦ã€æœ€ã‚‚æœ‰æ„ç¾©ãªè§£é‡ˆãŒã§ãã‚‹ã‚ˆã†ã«æ„å›³ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:234
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`) (å®Ÿæ•°)"

#: ../../reference/datamodel.rst:228
msgid ""
"These represent machine-level double precision floating point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does"
" not support single-precision floating point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to"
" complicate the language with two kinds of floating point numbers."
msgstr ""
"ã“ã®å‹ã¯è¨ˆç®—æ©Ÿãƒ¬ãƒ™ãƒ«ã®å€ç²¾åº¦æµ®å‹•å°æ•°ç‚¹æ•°ã‚’è¡¨ç¾ã—ã¾ã™ã€‚è¡¨ç¾å¯èƒ½ãªå€¤ã®ç¯„å›²ã‚„ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®æ‰±ã„ã¯è¨ˆç®—æ©Ÿã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ï¼ˆãŠã‚ˆã³ã€Cã‚„Javaã«ã‚ˆã‚‹å®Ÿè£…ï¼‰ã«å¾“ã„ã¾ã™ã€‚Pythonã¯å˜ç²¾åº¦æµ®å‹•å°æ•°ç‚¹æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚ä¸€èˆ¬çš„ã«å˜ç²¾åº¦æµ®å‹•å°æ•°ç‚¹æ•°ã‚’ä½¿ã†ç†ç”±ã¯ãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼ã¨ãƒ¡ãƒ¢ãƒªã®ä½¿ç”¨ã‚’ç¯€ç´„ã™ã‚‹ãŸã‚ã¨èª¬æ˜ã•ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€ã“ã†ã—ãŸç¯€ç´„ã¯Pythonã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ‰±ã†éš›ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã«æ¯”ã¹ã‚Œã°å¾®ã€…ãŸã‚‹ã‚‚ã®ã§ã™ã€‚ã¾ãŸã€2ç¨®é¡ã®æµ®å‹•å°æ•°ç‚¹æ•°å‹ã‚’æŒã¤ã“ã¨ã§è¤‡é›‘ã«ãªã‚‹ç†ç”±ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:244
msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ":class:`numbers.Complex` (:class:`complex`)"

#: ../../reference/datamodel.rst:241
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating point numbers.  The same caveats apply as for floating point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""
"ã“ã®å‹ã¯ã€è¨ˆç®—æ©Ÿãƒ¬ãƒ™ãƒ«ã§å€ç²¾åº¦ã¨ã•ã‚Œã¦ã„ã‚‹æµ®å‹•å°æ•°ç‚¹ã‚’ 2 ã¤ä¸€çµ„ã«ã—ã¦è¤‡ç´ æ•°ã‚’è¡¨ç¾ã—ã¾ã™ã€‚æµ®å‹•å°æ•°ç‚¹ã«ã¤ã„ã¦è¿°ã¹ãŸã®ã¨åŒã˜æ€§è³ªãŒå½“ã¦ã¯ã¾ã‚Šã¾ã™ã€‚è¤‡ç´ æ•°"
" ``z`` ã®å®Ÿæ•°éƒ¨ãŠã‚ˆã³è™šæ•°éƒ¨ã¯ã€ãã‚Œãã‚Œèª­ã¿å‡ºã—å°‚ç”¨å±æ€§ ``z.real`` ãŠã‚ˆã³ ``z.imag`` ã§å–ã‚Šå‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:361
msgid "Sequences"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ (sequence)"

#: ../../reference/datamodel.rst:254
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""
"ã“ã®å‹ã¯ã€æœ‰é™ã®é †åºé›†åˆ (ordered set) ã‚’è¡¨ç¾ã—ã¾ã™ã€‚è¦ç´ ã¯éè² ã®æ•´æ•°ã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚çµ„ã¿è¾¼ã¿é–¢æ•° :func:`len` "
"ã‚’ä½¿ã†ã¨ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®è¦ç´ æ•°ã‚’è¿”ã—ã¾ã™ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒ *n* ã®å ´åˆã€ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã¯ 0, 1, ..., *n* -1 "
"ã‹ã‚‰ãªã‚‹é›†åˆã§ã™ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *a* ã®è¦ç´  *i* ã¯ ``a[i]`` ã§é¸æŠã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:261
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type.  This implies that the index set is renumbered "
"so that it starts at 0."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã‚¹ãƒ©ã‚¤ã‚¹æ“ä½œ (slice) ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™: ``a[i:j]`` ã¨ã™ã‚‹ã¨ã€ *i* ``<=`` *k* ``<`` *j* "
"ã§ã‚ã‚‹ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ *k* "
"ã‚’ã‚‚ã¤å…¨ã¦ã®è¦ç´ ã‚’é¸æŠã—ã¾ã™ã€‚å¼è¡¨ç¾ã¨ã—ã¦ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ç”¨ã„ãŸå ´åˆã€ã‚¹ãƒ©ã‚¤ã‚¹ã¯åŒã˜å‹ã‚’ã‚‚ã¤æ–°ãŸãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚æ–°ãŸãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å†…ã§ã¯ã€ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹é›†åˆãŒ"
" 0 ã‹ã‚‰å§‹ã¾ã‚‹ã‚ˆã†ã«ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã®å€¤ã‚’æŒ¯ã‚ŠãªãŠã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:266
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ã‚ˆã£ã¦ã¯ã€ç¬¬ä¸‰ã® \"ã‚¹ãƒ†ãƒƒãƒ— (step)\" ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’æŒã¤ \"æ‹¡å¼µã‚¹ãƒ©ã‚¤ã‚¹ (extended slice)\" "
"ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™: ``a[i:j:k]`` ã¯ã€ ``x = i + n*k``, *n* ``>=`` ``0`` ã‹ã¤ *i* ``<=`` "
"*x* ``<`` *j* ã§ã‚ã‚‹ã‚ˆã†ãªã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ *x* ã‚’æŒã¤ã‚ˆã†ãª *a* å…¨ã¦ã®è¦ç´ ã‚’é¸æŠã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:270
msgid "Sequences are distinguished according to their mutability:"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€å¤‰æ›´å¯èƒ½ãªã‚‚ã®ã‹ã€ãã†ã§ãªã„ã‹ã§åŒºåˆ¥ã•ã‚Œã¦ã„ã¾ã™:"

#: ../../reference/datamodel.rst:327
msgid "Immutable sequences"
msgstr "å¤‰æ›´ä¸èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ (immutable sequence)"

#: ../../reference/datamodel.rst:277
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may"
" be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""
"å¤‰æ›´ä¸èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ä¸€åº¦ç”Ÿæˆã•ã‚Œã‚‹ã¨ãã®å€¤ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ "
"(ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ãŒå…¥ã£ã¦ã„ã‚‹å ´åˆã€å‚ç…§ã•ã‚Œã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚ã‚ˆãã€ãã®å€¤ã¯å¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™;"
" ã—ã‹ã—ã€å¤‰æ›´ä¸èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç›´æ¥å‚ç…§ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é›†åˆè‡ªä½“ã¯ã€å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚)"

#: ../../reference/datamodel.rst:282
msgid "The following types are immutable sequences:"
msgstr "ä»¥ä¸‹ã®å‹ã¯å¤‰æ›´ä¸èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã§ã™:"

#: ../../reference/datamodel.rst:305
msgid "Strings"
msgstr "æ–‡å­—åˆ—å‹ (string)"

#: ../../reference/datamodel.rst:295
msgid ""
"A string is a sequence of values that represent Unicode code points. All the"
" code points in the range ``U+0000 - U+10FFFF`` can be represented in a "
"string.  Python doesn't have a :c:type:`char` type; instead, every code "
"point in the string is represented as a string object with length ``1``.  "
"The built-in function :func:`ord` converts a code point from its string form"
" to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an integer "
"in the range ``0 - 10FFFF`` to the corresponding length ``1`` string object."
" :meth:`str.encode` can be used to convert a :class:`str` to :class:`bytes` "
"using the given text encoding, and :meth:`bytes.decode` can be used to "
"achieve the opposite."
msgstr ""
"æ–‡å­—åˆ—ã¯Unicodeã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’è¡¨ç¾ã™ã‚‹å€¤ã®é…åˆ—ã§ã™ã€‚æ–‡å­—åˆ—ä¸­ã®ã©ã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚‚ ``U+0000 - U+10FFFF`` "
"ã®ç¯„å›²ã§è¡¨ç¾ã•ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚Pythonã¯ :c:type:`char` å‹ã‚’æŒã¡ã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«ã€æ–‡å­—åˆ—ä¸­ã®ã©ã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚‚é•·ã• ''1''"
" ã®æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚çµ„ã¿è¾¼ã¿é–¢æ•° :func:`ord` ã¯æ–‡å­—åˆ—å½¢å¼ã‚’0 - "
"10FFFFã®ç¯„å›²ã®æ•´æ•°ã«å¤‰æ›ã—ã¾ã™ã€‚ã¾ãŸã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`chr` ã¯ ``0 - 10FFFF`` ã®ç¯„å›²ã®æ•´æ•°ã‚’å¯¾å¿œã™ã‚‹é•·ã• "
"``1`` ã®æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¾ã™ã€‚:meth:`str.encode` ã¯ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã†ã“ã¨ã§ :class:`str` ã‚’ "
":class:`bytes` ã«å¤‰æ›ã™ã‚‹ãŸã‚ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ã¾ãŸã€:meth:`bytes.decode` ã«ã‚ˆã‚Šãã®é€†ãŒå®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:318
msgid "Tuples"
msgstr "ã‚¿ãƒ—ãƒ«å‹ (tuple)"

#: ../../reference/datamodel.rst:313
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""
"ã‚¿ãƒ—ãƒ«ã®è¦ç´ ã¯ä»»æ„ã® Python "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚äºŒã¤ä»¥ä¸Šã®è¦ç´ ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã¯ã€å€‹ã€…ã®è¦ç´ ã‚’è¡¨ç¾ã™ã‚‹å¼ã‚’ã‚«ãƒ³ãƒã§åŒºåˆ‡ã£ã¦æ§‹æˆã—ã¾ã™ã€‚å˜ä¸€ã®è¦ç´ ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ« (å˜é›†åˆ "
"'singleton') ã‚’ä½œã‚‹ã«ã¯ã€è¦ç´ ã‚’è¡¨ç¾ã™ã‚‹å¼ã®ç›´å¾Œã«ã‚«ãƒ³ãƒã‚’ã¤ã‘ã¾ã™ "
"(å˜ä¸€ã®å¼ã ã‘ã§ã¯ã‚¿ãƒ—ãƒ«ã‚’å½¢æˆã—ã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€å¼ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã™ã‚‹ã®ã«ä¸¸æ‹¬å¼§ã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã‹ã‚‰ã§ã™)ã€‚è¦ç´ ã®å…¨ããªã„ä¸¸æ‹¬å¼§ã®å¯¾ã‚’ä½œã‚‹ã¨ç©ºã®ã‚¿ãƒ—ãƒ«ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:327
msgid "Bytes"
msgstr "bytes"

#: ../../reference/datamodel.rst:323
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes()` constructor can be used to "
"create bytes objects.  Also, bytes objects can be decoded to strings via the"
" :meth:`~bytes.decode` method."
msgstr ""
"bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸å¤‰ãªé…åˆ—ã§ã™ã€‚è¦ç´ ã¯ 8-bit ãƒã‚¤ãƒˆã§ã€ 0 <= x < 256 ã®ç¯„å›²ã®æ•´æ•°ã§è¡¨ç¾ã•ã‚Œã¾ã™ã€‚ (``b'abc'``"
" ã®ã‚ˆã†ãª) bytes ãƒªãƒ†ãƒ©ãƒ«ã‚„çµ„ã¿è¾¼ã¿ã® :func:`bytes()` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½¿ã£ã¦ bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã§ãã¾ã™ã€‚ã¾ãŸã€ "
"bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :meth:`~bytes.decode` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’é€šã—ã¦æ–‡å­—åˆ—ã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:361
msgid "Mutable sequences"
msgstr "å¤‰æ›´å¯èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ (mutable sequence)"

#: ../../reference/datamodel.rst:337
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and "
":keyword:`del` (delete) statements."
msgstr ""
"å¤‰æ›´å¯èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€ä½œæˆã—ãŸå¾Œã§å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å¤‰æ›´å¯èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã¯ã€æ·»å­—è¡¨è¨˜ã‚„ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã‚’ä½¿ã£ã¦æŒ‡å®šã•ã‚ŒãŸè¦ç´ ã«ä»£å…¥ã‚’è¡Œã†ã“ã¨ãŒã§ãã€"
" :keyword:`del` (delete) æ–‡ã‚’ä½¿ã£ã¦è¦ç´ ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:341
msgid "There are currently two intrinsic mutable sequence types:"
msgstr "Python ã«æœ€åˆã‹ã‚‰çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹å¤‰æ›´å¯èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã¯ã€ä»Šã®ã¨ã“ã‚äºŒã¤ã§ã™:"

#: ../../reference/datamodel.rst:348
msgid "Lists"
msgstr "ãƒªã‚¹ãƒˆå‹ (list)"

#: ../../reference/datamodel.rst:346
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that"
" there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"ãƒªã‚¹ãƒˆã®è¦ç´ ã¯ä»»æ„ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã§ãã¾ã™ã€‚ãƒªã‚¹ãƒˆã¯ã€è§’æ‹¬å¼§ã®ä¸­ã«ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸå¼ã‚’ä¸¦ã¹ã¦ä½œã‚Šã¾ã™ã€‚ (é•·ã•ãŒ 0 ã‚„ 1 "
"ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ä½œã‚‹ãŸã‚ã«ç‰¹æ®Šãªå ´åˆåˆ†ã‘ã¯å¿…è¦ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚)"

#: ../../reference/datamodel.rst:356
msgid "Byte Arrays"
msgstr "ãƒã‚¤ãƒˆé…åˆ—"

#: ../../reference/datamodel.rst:353
msgid ""
"A bytearray object is a mutable array. They are created by the built-in "
":func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤‰æ›´å¯èƒ½ãªé…åˆ—ã§ã™ã€‚çµ„ã¿è¾¼ã¿ã® :func:`bytearray` "
"ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã¾ã™ã€‚å¤‰æ›´å¯èƒ½ãªã“ã¨ã‚’é™¤ã‘ã° (ã¤ã¾ã‚Šãƒãƒƒã‚·ãƒ¥åŒ–ã§ããªã„)ã€ byte array ã¯å¤‰æ›´ä¸èƒ½ãª "
":class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒã˜ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¨æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:360
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type, as does the :mod:`collections` module."
msgstr ""
"æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`array` ã‚„ã€ :mod:`collections` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã€ã•ã‚‰ãªã‚‹ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã®ä¾‹ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:395
msgid "Set types"
msgstr "é›†åˆå‹"

#: ../../reference/datamodel.rst:368
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated"
" over, and the built-in function :func:`len` returns the number of items in "
"a set. Common uses for sets are fast membership testing, removing duplicates"
" from a sequence, and computing mathematical operations such as "
"intersection, union, difference, and symmetric difference."
msgstr ""
"é›†åˆå‹ã¯ã€é †åºã®ãªã„ã€ãƒ¦ãƒ‹ãƒ¼ã‚¯ã§ä¸å¤‰ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æœ‰é™é›†åˆã‚’è¡¨ç¾ã—ã¾ã™ã€‚ãã®ãŸã‚ã€(é…åˆ—ã®)æ·»å­—ã‚’ä½¿ã£ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚¢ã‚¯ã‚»ã‚¹ã¯ã§ãã¾ã›ã‚“ã€‚ãŸã ã—ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã¯å¯èƒ½ã§ã€çµ„ã¿è¾¼ã¿é–¢æ•°"
" :func:`len` "
"ã¯é›†åˆã®è¦ç´ æ•°ã‚’è¿”ã—ã¾ã™ã€‚é›†åˆå‹ã®ä¸€èˆ¬çš„ãªä½¿ã„æ–¹ã¯ã€é›†åˆã«å±ã—ã¦ã„ã‚‹ã‹ã®é«˜é€Ÿãªãƒ†ã‚¹ãƒˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‹ã‚‰ã®é‡è¤‡ã®æ’é™¤ã€å…±é€šé›†åˆãƒ»å’Œé›†åˆãƒ»å·®ãƒ»å¯¾ç§°å·®ã¨ã„ã£ãŸæ•°å­¦çš„ãªæ¼”ç®—ã®è¨ˆç®—ã§ã™ã€‚"

#: ../../reference/datamodel.rst:375
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two"
" numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""
"é›†åˆã®è¦ç´ ã«ã¯ã€è¾æ›¸ã®ã‚­ãƒ¼ã¨åŒã˜æ™®éæ€§ã«é–¢ã™ã‚‹ãƒ«ãƒ¼ãƒ«ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚æ•°å€¤å‹ã¯é€šå¸¸ã®æ•°å€¤æ¯”è¼ƒã®ãƒ«ãƒ¼ãƒ«ã«å¾“ã†ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã‚‚ã—2ã¤ã®æ•°å€¤ã®æ¯”è¼ƒçµæœãŒåŒå€¤ã§ã‚ã‚‹(ä¾‹ãˆã°ã€"
" ``1`` ã¨ ``1.0``)ãªã‚‰ã€ãã®ã†ã¡ã®1ã¤ã®ã¿ã‚’é›†åˆã«å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:380
msgid "There are currently two intrinsic set types:"
msgstr "ç¾åœ¨ã€2ã¤ã®çµ„ã¿è¾¼ã¿é›†åˆå‹ãŒã‚ã‚Šã¾ã™:"

#: ../../reference/datamodel.rst:387
msgid "Sets"
msgstr "é›†åˆå‹"

#: ../../reference/datamodel.rst:385
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as "
":meth:`~set.add`."
msgstr ""
"å¯å¤‰ãªé›†åˆå‹ã§ã™ã€‚çµ„ã¿è¾¼ã¿ã® :func:`set` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ä½œæˆã•ã‚Œã€å¾Œã‹ã‚‰ :meth:`~set.add` "
"ãªã©ã®ã„ãã¤ã‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§æ›´æ–°ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:395
msgid "Frozen sets"
msgstr "Frozen set å‹"

#: ../../reference/datamodel.rst:392
msgid ""
"These represent an immutable set.  They are created by the built-in "
":func:`frozenset` constructor.  As a frozenset is immutable and "
":term:`hashable`, it can be used again as an element of another set, or as a"
" dictionary key."
msgstr ""
"ä¸å¤‰ãªé›†åˆå‹ã§ã™ã€‚çµ„ã¿è¾¼ã¿ã® :func:`frozenset` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã¾ã™ã€‚ frozenset "
"ã¯ä¸å¤‰ã§ãƒãƒƒã‚·ãƒ¥å¯èƒ½(:term:`hashable`)ãªã®ã§ã€åˆ¥ã®é›†åˆå‹ã®è¦ç´ ã«ãªã£ãŸã‚Šã€è¾æ›¸ã®ã‚­ãƒ¼ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:432
msgid "Mappings"
msgstr "ãƒãƒƒãƒ”ãƒ³ã‚°å‹ (mapping)"

#: ../../reference/datamodel.rst:403
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""
"ä»»æ„ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹é›†åˆã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹åŒ–ã•ã‚ŒãŸã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãªã‚‹æœ‰é™ã®é›†åˆã‚’è¡¨ç¾ã—ã¾ã™ã€‚æ·»å­—è¡¨è¨˜ ``a[k]`` ã¯ã€ ``k`` "
"ã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹æŒ‡å®šã•ã‚ŒãŸè¦ç´ ã‚’ ``a`` ã‹ã‚‰é¸æŠã—ã¾ã™; é¸æŠã•ã‚ŒãŸè¦ç´ ã¯å¼ã®ä¸­ã§ä½¿ã†ã“ã¨ãŒã§ãã€ä»£å…¥ã‚„ :keyword:`del` "
"æ–‡ã®å¯¾è±¡ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚çµ„ã¿è¾¼ã¿é–¢æ•° :func:`len` ã¯ã€ãƒãƒƒãƒ”ãƒ³ã‚°å†…ã®è¦ç´ æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:409
msgid "There is currently a single intrinsic mapping type:"
msgstr "Python ã«æœ€åˆã‹ã‚‰çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ãƒãƒƒãƒ”ãƒ³ã‚°å‹ã¯ã€ä»Šã®ã¨ã“ã‚ä¸€ã¤ã ã‘ã§ã™:"

#: ../../reference/datamodel.rst:432
msgid "Dictionaries"
msgstr "è¾æ›¸å‹ (dictionary)"

#: ../../reference/datamodel.rst:414
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""
"ã»ã¼ä»»æ„ã®å€¤ã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãªã‚‹æœ‰é™ã®é›†åˆã‚’è¡¨ã—ã¾ã™ã€‚\n"
"ã‚­ãƒ¼ (key) ã¨ã—ã¦ä½¿ãˆãªã„å€¤ã®å”¯ä¸€ã®å‹ã¯ã€ãƒªã‚¹ãƒˆã‚„è¾æ›¸ã€ãã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŒä¸€æ€§ã§ãªãå€¤ã§æ¯”è¼ƒã•ã‚Œã‚‹ãã®ä»–ã®å¤‰æ›´å¯èƒ½ãªå‹ã§ã™ã€‚\n"
"ã“ã‚Œã¯ã€è¾æ›¸å‹ã‚’åŠ¹ç‡çš„ã«å®Ÿè£…ã™ã‚‹ä¸Šã§ã€ã‚­ãƒ¼ã®ãƒãƒƒã‚·ãƒ¥å€¤ãŒä¸å¤‰ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã§ã™ã€‚\n"
"æ•°å€¤å‹ã‚’ã‚­ãƒ¼ã«ä½¿ã†å ´åˆã€ã‚­ãƒ¼å€¤ã¯é€šå¸¸ã®æ•°å€¤æ¯”è¼ƒã«ãŠã‘ã‚‹è¦å‰‡ã«å¾“ã„ã¾ã™: äºŒã¤ã®å€¤ãŒç­‰ã—ããªã‚‹å ´åˆ (ä¾‹ãˆã° ``1`` ã¨ ``1.0``)ã€äº’ã„ã«åŒã˜è¾æ›¸ã®ã‚¨ãƒ³ãƒˆãƒªã‚’è¡¨ã™ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã¨ã—ã¦ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:423
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation (see"
" section :ref:`dict`)."
msgstr "è¾æ›¸ã¯å¤‰æ›´å¯èƒ½ãªå‹ã§ã™; è¾æ›¸ã¯ ``{...}`` è¡¨è¨˜ã§ç”Ÿæˆã—ã¾ã™ (:ref:`dict` ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../reference/datamodel.rst:430
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional "
"examples of mapping types, as does the :mod:`collections` module."
msgstr ""
"æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`dbm.ndbm` ã€ :mod:`dbm.gnu` ã¯ã€ :mod:`collections` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚ˆã†ã«ã€åˆ¥ã®ãƒãƒƒãƒ”ãƒ³ã‚°å‹ã®ä¾‹ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:688
msgid "Callable types"
msgstr "å‘¼ã³å‡ºã—å¯èƒ½å‹ (callable type)"

#: ../../reference/datamodel.rst:441
msgid ""
"These are the types to which the function call operation (see section "
":ref:`calls`) can be applied:"
msgstr "é–¢æ•°å‘¼ã³å‡ºã—æ“ä½œ (:ref:`calls` å‚ç…§) ã‚’è¡Œã†ã“ã¨ãŒã§ãã‚‹å‹ã§ã™:"

#: ../../reference/datamodel.rst:536
msgid "User-defined functions"
msgstr "ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•° (user-defined function)"

#: ../../reference/datamodel.rst:450
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""
"ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€é–¢æ•°å®šç¾©ã‚’è¡Œã†ã“ã¨ã§ç”Ÿæˆã•ã‚Œã¾ã™ (:ref:`function` å‚ç…§)ã€‚é–¢æ•°ã¯ã€ä»®å¼•æ•° (formal "
"parameter) ãƒªã‚¹ãƒˆã¨åŒã˜æ•°ã®è¦ç´ ãŒå…¥ã£ãŸå¼•æ•°ãƒªã‚¹ãƒˆã¨ã¨ã‚‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:455
msgid "Special attributes:"
msgstr "ç‰¹æ®Šå±æ€§:"

#: ../../reference/datamodel.rst:473
msgid "Attribute"
msgstr "å±æ€§"

#: ../../reference/datamodel.rst:473
msgid "Meaning"
msgstr "æ„å‘³"

#: ../../reference/datamodel.rst:475
msgid ":attr:`__doc__`"
msgstr ":attr:`__doc__`"

#: ../../reference/datamodel.rst:475
msgid ""
"The function's documentation string, or ``None`` if unavailable; not "
"inherited by subclasses"
msgstr "é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã§ã™ã€‚ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã«ç¶™æ‰¿ã•ã‚Œã¾ã›ã‚“"

#: ../../reference/datamodel.rst:475 ../../reference/datamodel.rst:480
#: ../../reference/datamodel.rst:483 ../../reference/datamodel.rst:488
#: ../../reference/datamodel.rst:492 ../../reference/datamodel.rst:498
#: ../../reference/datamodel.rst:508 ../../reference/datamodel.rst:516
#: ../../reference/datamodel.rst:523
msgid "Writable"
msgstr "æ›¸ãè¾¼ã¿å¯èƒ½"

#: ../../reference/datamodel.rst:480
msgid ":attr:`~definition.\\ __name__`"
msgstr ":attr:`~definition.\\ __name__`"

#: ../../reference/datamodel.rst:480
msgid "The function's name"
msgstr "é–¢æ•°ã®åå‰ã§ã™"

#: ../../reference/datamodel.rst:483
msgid ":attr:`~definition.\\ __qualname__`"
msgstr ":attr:`~definition.\\ __qualname__`"

#: ../../reference/datamodel.rst:483
msgid "The function's :term:`qualified name`"
msgstr "é–¢æ•°ã® :term:`qualified name` ã§ã™"

#: ../../reference/datamodel.rst:488
msgid ":attr:`__module__`"
msgstr ":attr:`__module__`"

#: ../../reference/datamodel.rst:488
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr "é–¢æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã§ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:492
msgid ":attr:`__defaults__`"
msgstr ":attr:`__defaults__`"

#: ../../reference/datamodel.rst:492
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value"
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒã¤å¼•æ•°ã«å¯¾ã™ã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒåã‚ã‚‰ã‚ŒãŸã‚¿ãƒ—ãƒ«ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒã¤å¼•æ•°ãŒãªã„å ´åˆã«ã¯ ``None`` ã«ãªã‚Šã¾ã™"

#: ../../reference/datamodel.rst:498
msgid ":attr:`__code__`"
msgstr ":attr:`__code__`"

#: ../../reference/datamodel.rst:498
msgid "The code object representing the compiled function body."
msgstr "ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸé–¢æ•°æœ¬ä½“ã‚’è¡¨ç¾ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../reference/datamodel.rst:501
msgid ":attr:`__globals__`"
msgstr ":attr:`__globals__`"

#: ../../reference/datamodel.rst:501
msgid ""
"A reference to the dictionary that holds the function's global variables ---"
" the global namespace of the module in which the function was defined."
msgstr ""
"é–¢æ•°ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®å…¥ã£ãŸè¾æ›¸ (ã¸ã®å‚ç…§) ã§ã™ --- ã“ã®è¾æ›¸ã¯ã€é–¢æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ç©ºé–“ã‚’æ±ºå®šã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:501 ../../reference/datamodel.rst:512
msgid "Read-only"
msgstr "èª­ã¿å‡ºã—å°‚ç”¨"

#: ../../reference/datamodel.rst:508
msgid ":attr:`~object.__dict__`"
msgstr ":attr:`~object.__dict__`"

#: ../../reference/datamodel.rst:508
msgid "The namespace supporting arbitrary function attributes."
msgstr "ä»»æ„ã®é–¢æ•°å±æ€§ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã®åå‰ç©ºé–“ãŒåã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:512
msgid ":attr:`__closure__`"
msgstr ":attr:`__closure__`"

#: ../../reference/datamodel.rst:512
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's free "
"variables."
msgstr ""
"``None`` ã¾ãŸã¯é–¢æ•°ã®å€‹ã€…ã®è‡ªç”±å¤‰æ•° (å¼•æ•°ä»¥å¤–ã®å¤‰æ•°) ã«å¯¾ã—ã¦å€¤ã‚’çµã³ä»˜ã‘ã¦ã„ã‚‹ã‚»ãƒ« (cell) ç¾¤ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:516
msgid ":attr:`__annotations__`"
msgstr ":attr:`__annotations__`"

#: ../../reference/datamodel.rst:516
msgid ""
"A dict containing annotations of parameters.  The keys of the dict are the "
"parameter names, and ``'return'`` for the return annotation, if provided."
msgstr "ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ³¨é‡ˆãŒå…¥ã£ãŸè¾æ›¸ã§ã™ã€‚è¾æ›¸ã®ã‚­ãƒ¼ã¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åã§ã€è¿”ã‚Šå€¤ã®æ³¨é‡ˆãŒã‚ã‚‹å ´åˆã¯ã€``'return'`` ãŒãã®ã‚­ãƒ¼ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:523
msgid ":attr:`__kwdefaults__`"
msgstr ":attr:`__kwdefaults__`"

#: ../../reference/datamodel.rst:523
msgid "A dict containing defaults for keyword-only parameters."
msgstr "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å°‚ç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’å«ã‚€è¾æ›¸ã§ã™ã€‚"

#: ../../reference/datamodel.rst:527
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the assigned "
"value."
msgstr "ã€Œæ›¸ãè¾¼ã¿å¯èƒ½ã€ã¨ãƒ©ãƒ™ãƒ«ã•ã‚Œã¦ã„ã‚‹å±æ€§ã®ã»ã¨ã‚“ã©ã¯ã€ä»£å…¥ã•ã‚ŒãŸå€¤ã®å‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:529
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes. *Note that "
"the current implementation only supports function attributes on user-defined"
" functions. Function attributes on built-in functions may be supported in "
"the future.*"
msgstr ""
"é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã¾ãŸã€ä»»æ„ã®å±æ€§ã‚’è¨­å®šã—ãŸã‚Šå–å¾—ã—ãŸã‚Šã§ãã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã¯ã€ä¾‹ãˆã°é–¢æ•°ã«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä»˜ä¸ã—ãŸã„å ´åˆãªã©ã«ä½¿ãˆã¾ã™ã€‚é–¢æ•°ã® get ã‚„ "
"set ã«ã¯ã€é€šå¸¸ã®ãƒ‰ãƒƒãƒˆè¡¨è¨˜ã‚’ä½¿ã„ã¾ã™ã€‚ "
"*ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€ãƒ¦ãƒ¼ã‚¶å®šç¾©ã®é–¢æ•°ã§ã®ã¿å±æ€§ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã®ã§æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚çµ„ã¿è¾¼ã¿é–¢æ•°ã®å±æ€§ã¯å°†æ¥ã‚µãƒãƒ¼ãƒˆã™ã‚‹äºˆå®šã§ã™ã€‚*"

#: ../../reference/datamodel.rst:535
msgid ""
"Additional information about a function's definition can be retrieved from "
"its code object; see the description of internal types below."
msgstr ""
"é–¢æ•°å®šç¾©ã«é–¢ã™ã‚‹ãã®ä»–ã®æƒ…å ±ã¯ã€é–¢æ•°ã®ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å¾—ã‚‰ã‚Œã¾ã™; å¾Œè¿°ã®å†…éƒ¨å‹ (internal type) ã«é–¢ã™ã‚‹èª¬æ˜ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:605
msgid "Instance methods"
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../reference/datamodel.rst:544
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚¯ãƒ©ã‚¹ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ä»»æ„ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (é€šå¸¸ã¯ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°) ã‚’çµã³ã¤ã‘ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:554
msgid ""
"Special read-only attributes: :attr:`__self__` is the class instance object,"
" :attr:`__func__` is the function object; :attr:`__doc__` is the method's "
"documentation (same as ``__func__.__doc__``); :attr:`~definition.__name__` "
"is the method name (same as ``__func__.__name__``); :attr:`__module__` is "
"the name of the module the method was defined in, or ``None`` if "
"unavailable."
msgstr ""
"èª­ã¿å‡ºã—å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`__self__` ã¯ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ :attr:`__func__` ã¯é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™;\n"
":attr:`__doc__` ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ— (``__func__.__doc__`` ã¨åŒã˜) ã§ã™;\n"
":attr:`~definition.__name__` ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã®åå‰ (``__func__.__name__`` ã¨åŒã˜) ã§ã™;\n"
":attr:`__module__` ã¯ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã‹ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:560
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ã¾ãŸã€æ ¹åº•ã«ã‚ã‚‹é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»»æ„ã®é–¢æ•°å±æ€§ã« (å€¤ã®è¨­å®šã¯ã§ãã¾ã›ã‚“ãŒ) ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:563
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined function object or a class method object."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã®å±æ€§ã‚’ (å ´åˆã«ã‚ˆã£ã¦ã¯ãã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä»‹ã—ã¦) "
"å–å¾—ã™ã‚‹ã¨ãã€ãã®å±æ€§ãŒãƒ¦ãƒ¼ã‚¶å®šç¾©ã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚Œã°ã€ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:567
msgid ""
"When an instance method object is created by retrieving a user-defined "
"function object from a class via one of its instances, its :attr:`__self__` "
"attribute is the instance, and the method object is said to be bound.  The "
"new method's :attr:`__func__` attribute is the original function object."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã‹ã‚‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’çµŒç”±ã—ã¦ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã•ã‚ŒãŸã¨ãã€ "
":attr:`__self__` å±æ€§ã¯ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æŸç¸›ã•ã‚Œã¦ã„ã‚‹ (bound) ã¨ã„ã„ã¾ã™ã€‚æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã® "
":attr:`__func__` å±æ€§ã¯ã‚‚ã¨ã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../reference/datamodel.rst:573
msgid ""
"When a user-defined method object is created by retrieving another method "
"object from a class or instance, the behaviour is the same as for a function"
" object, except that the :attr:`__func__` attribute of the new instance is "
"not the original method object but its :attr:`__func__` attribute."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã‚„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã•ã‚ŒãŸã¨ãã€ãã®å‹•ä½œã¯é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã¨åŒæ§˜ã§ã™ãŒã€æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®"
" :attr:`__func__` å±æ€§ã¯ã‚‚ã¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãªãã€ãã® :attr:`__func__` å±æ€§ã§ã™ã€‚"

#: ../../reference/datamodel.rst:579
msgid ""
"When an instance method object is created by retrieving a class method "
"object from a class or instance, its :attr:`__self__` attribute is the class"
" itself, and its :attr:`__func__` attribute is the function object "
"underlying the class method."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã‚„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã•ã‚ŒãŸã¨ãã€ "
":attr:`__self__` å±æ€§ã¯ã‚¯ãƒ©ã‚¹ãã®ã‚‚ã®ã§ã€ :attr:`__func__` å±æ€§ã¯ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã®æ ¹åº•ã«ã‚ã‚‹é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../reference/datamodel.rst:584
msgid ""
"When an instance method object is called, the underlying function "
"(:attr:`__func__`) is called, inserting the class instance "
"(:attr:`__self__`) in front of the argument list.  For instance, when "
":class:`C` is a class which contains a definition for a function :meth:`f`, "
"and ``x`` is an instance of :class:`C`, calling ``x.f(1)`` is equivalent to "
"calling ``C.f(x, 1)``."
msgstr ""
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‘¼ã³å‡ºã•ã‚Œã‚‹éš›ã€æ ¹åº•ã«ã‚ã‚‹é–¢æ•° (:attr:`__func__`) ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®ã¨ãã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ "
"(:attr:`__self__`) ãŒå¼•æ•°ãƒªã‚¹ãƒˆã®å…ˆé ­ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ :class:`C` ã‚’é–¢æ•° :meth:`f` ã®å®šç¾©ã‚’å«ã‚€ã‚¯ãƒ©ã‚¹ã€"
" ``x`` ã‚’ :class:`C` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã™ã‚‹ã¨ã€ ``x.f(1)`` ã®å‘¼ã³å‡ºã—ã¯ ``C.f(x, 1)`` ã®å‘¼ã³å‡ºã—ã¨åŒã˜ã§ã™ã€‚"

#: ../../reference/datamodel.rst:591
msgid ""
"When an instance method object is derived from a class method object, the "
"\"class instance\" stored in :attr:`__self__` will actually be the class "
"itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to "
"calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""
"ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå°å‡ºã•ã‚Œã‚‹éš›ã€ :attr:`__self__` ã«è¨˜æ†¶ã•ã‚Œã¦ã„ã‚‹ "
"\"ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹\" ã¯å®Ÿéš›ã¯ã‚¯ãƒ©ã‚¹ãã®ã‚‚ã®ãªã®ã§ã€ ``x.f(1)`` ã‚„ ``C.f(1)`` ã®å‘¼ã³å‡ºã—ã¯ã€æ ¹åº•ã«ã‚ã‚‹é–¢æ•°ã‚’ ``f`` "
"ã¨ã—ã¦ ``f(C,1)`` ã®å‘¼ã³å‡ºã—ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../reference/datamodel.rst:596
msgid ""
"Note that the transformation from function object to instance method object "
"happens each time the attribute is retrieved from the instance.  In some "
"cases, a fruitful optimization is to assign the attribute to a local "
"variable and call that local variable. Also notice that this transformation "
"only happens for user-defined functions; other callable objects (and all "
"non-callable objects) are retrieved without transformation.  It is also "
"important to note that user-defined functions which are attributes of a "
"class instance are not converted to bound methods; this *only* happens when "
"the function is an attribute of the class."
msgstr ""
"ãªãŠã€é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¤‰æ›ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰å±æ€§ãŒå–ã‚Šå‡ºã•ã‚Œã‚‹ãŸã³ã«è¡Œã‚ã‚Œã¾ã™ã€‚å ´åˆã«ã‚ˆã£ã¦ã¯ã€å±æ€§ã‚’ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã«ä»£å…¥ã—ã¦ãŠãã€ãã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«ã™ã‚‹ã®ãŒåŠ¹æœçš„ãªæœ€é©åŒ–ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸã€ä¸Šè¨˜ã®å¤‰æ›ã¯ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã«å¯¾ã—ã¦ã®ã¿è¡Œã‚ã‚Œã¾ã™;"
" ãã®ä»–ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ãŠã‚ˆã³å‘¼ã³å‡ºã—å¯èƒ½ã§ãªã„å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) "
"ã¯ã€å¤‰æ›ã•ã‚Œãšã«å–ã‚Šå‡ºã•ã‚Œã¾ã™ã€‚ãã‚Œã‹ã‚‰ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ã«ãªã£ã¦ã„ã‚‹ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã¯ã€æŸç¸›ãƒ¡ã‚½ãƒƒãƒ‰ã«å¤‰æ›ã•ã‚Œã¾ã›ã‚“; "
"å¤‰æ›ã•ã‚Œã‚‹ã®ã¯ã€é–¢æ•°ãŒã‚¯ãƒ©ã‚¹ã®å±æ€§ã§ã‚ã‚‹å ´åˆ *ã ã‘* ã§ã™ã€‚"

#: ../../reference/datamodel.rst:620
msgid "Generator functions"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•° (generator function)"

#: ../../reference/datamodel.rst:612
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section "
":ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an iterator object which can be used to execute the "
"body of the function:  calling the iterator's :meth:`iterator.__next__` "
"method will cause the function to execute until it provides a value using "
"the :keyword:`yield` statement.  When the function executes a "
":keyword:`return` statement or falls off the end, a :exc:`StopIteration` "
"exception is raised and the iterator will have reached the end of the set of"
" values to be returned."
msgstr ""
":keyword:`yield` æ–‡ (:ref:`yield` ã®ç¯€ã‚’å‚ç…§) ã‚’ä½¿ã†é–¢æ•°ã‚‚ã—ãã¯ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ :dfn:`ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°` "
"ã¨å‘¼ã³ã¾ã™ã€‚ãã®ã‚ˆã†ãªé–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã¯å¸¸ã«ã€é–¢æ•°ã®æœ¬ä½“ã‚’å®Ÿè¡Œã™ã‚‹ã®ã«ä½¿ãˆã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™: ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã® "
":meth:`iterator.__next__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¨ã€ :keyword:`yield` "
"æ–‡ã‚’ä½¿ã£ã¦å€¤ãŒæä¾›ã•ã‚Œã‚‹ã¾ã§é–¢æ•°ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚é–¢æ•°ã® :keyword:`return` æ–‡ã‚’å®Ÿè¡Œã™ã‚‹ã‹çµ‚ç«¯ã«é”ã—ãŸã¨ãã¯ã€ "
":exc:`StopIteration` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒè¿”ã™ã¹ãå€¤ã®æœ€å¾Œã¾ã§åˆ°é”ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:630
msgid "Coroutine functions"
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³é–¢æ•° (coroutine function)"

#: ../../reference/datamodel.rst:626
msgid ""
"A function or method which is defined using :keyword:`async def` is called a"
" :dfn:`coroutine function`.  Such a function, when called, returns a "
":term:`coroutine` object.  It may contain :keyword:`await` expressions, as "
"well as :keyword:`async with` and :keyword:`async for` statements. See also "
"the :ref:`coroutine-objects` section."
msgstr ""
":keyword:`async def` ã‚’ä½¿ç”¨ã—ã¦å®šç¾©ã•ã‚ŒãŸé–¢æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ :dfn:`ã‚³ãƒ«ãƒ¼ãƒãƒ³é–¢æ•° (coroutine function)` ã¨å‘¼ã³ã¾ã™ã€‚ \n"
"å‘¼ã³å‡ºã•ã‚ŒãŸæ™‚ã€ãã®ã‚ˆã†ãªé–¢æ•°ã¯ :term:`coroutine` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚\n"
"ã‚³ãƒ«ãƒ¼ãƒãƒ³é–¢æ•°ã¯ :keyword:`async with` ã‚„ :keyword:`async for` æ–‡ã ã‘ã§ãªã :keyword:`await` å¼ã‚’æŒã¤ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚\n"
":ref:`coroutine-objects` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:649
msgid "Asynchronous generator functions"
msgstr "éåŒæœŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•° (asynchronous generator function)"

#: ../../reference/datamodel.rst:637
msgid ""
"A function or method which is defined using :keyword:`async def` and which "
"uses the :keyword:`yield` statement is called a :dfn:`asynchronous generator"
" function`.  Such a function, when called, returns an asynchronous iterator "
"object which can be used in an :keyword:`async for` statement to execute the"
" body of the function."
msgstr ""
":keyword:`async def` ã‚’ä½¿ã£ã¦å®šç¾©ã•ã‚Œã€ :keyword:`yield` æ–‡ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹é–¢æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ :dfn:`asynchronous generator function` ã¨å‘¼ã³ã¾ã™ã€‚\n"
"ãã®ã‚ˆã†ãªé–¢æ•°ã¯ã€å‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã€éåŒæœŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚\n"
"ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :keyword:`async for` æ–‡ã§é–¢æ•°ã®æœ¬ä½“ã‚’å®Ÿè¡Œã™ã‚‹ã®ã«ä½¿ãˆã¾ã™ã€‚"

#: ../../reference/datamodel.rst:643
msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__` method will "
"return an :term:`awaitable` which when awaited will execute until it "
"provides a value using the :keyword:`yield` expression.  When the function "
"executes an empty :keyword:`return` statement or falls off the end, a "
":exc:`StopAsyncIteration` exception is raised and the asynchronous iterator "
"will have reached the end of the set of values to be yielded."
msgstr ""

#: ../../reference/datamodel.rst:664
msgid "Built-in functions"
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•° (built-in function)"

#: ../../reference/datamodel.rst:657
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: :attr:`__doc__` "
"is the function's documentation string, or ``None`` if unavailable; "
":attr:`~definition.__name__` is the function's name; :attr:`__self__` is set"
" to ``None`` (but see the next item); :attr:`__module__` is the name of the "
"module the function was defined in or ``None`` if unavailable."
msgstr ""
"çµ„ã¿è¾¼ã¿é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯Cé–¢æ•°ã¸ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã§ã™ã€‚\n"
"çµ„ã¿è¾¼ã¿é–¢æ•°ã®ä¾‹ã¯ :func:`len` ã‚„ :func:`math.sin` (:mod:`math` ã¯æ¨™æº–ã®çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«) ã§ã™ã€‚\n"
"å¼•æ•°ã®æ•°ã‚„å‹ã¯ C é–¢æ•°ã§æ±ºå®šã•ã‚Œã¦ã„ã¾ã™ã€‚\n"
"èª­ã¿å‡ºã—å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`__doc__` ã¯é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã§ã™ã€‚\n"
"ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™;\n"
":attr:`~definition.__name__` ã¯é–¢æ•°ã®åå‰ã§ã™;\n"
":attr:`__self__` ã¯ ``None`` ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã™ (çµ„ã¿è¾¼ã¿ãƒ¡ã‚½ãƒƒãƒ‰ã®ç¯€ã‚‚å‚ç…§ã—ã¦ãã ã•ã„);\n"
":attr:`__module__` ã¯ã€é–¢æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã§ã™ã€‚\n"
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:676
msgid "Built-in methods"
msgstr "çµ„ã¿è¾¼ã¿ãƒ¡ã‚½ãƒƒãƒ‰ (built-in method)"

#: ../../reference/datamodel.rst:672
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra argument."
"  An example of a built-in method is ``alist.append()``, assuming *alist* is"
" a list object. In this case, the special read-only attribute "
":attr:`__self__` is set to the object denoted by *alist*."
msgstr ""
"å®Ÿéš›ã«ã¯çµ„ã¿è¾¼ã¿é–¢æ•°ã‚’åˆ¥ã®å½¢ã§éš è”½ã—ãŸã‚‚ã®ã§ã€ã“ã¡ã‚‰ã®å ´åˆã«ã¯ C "
"é–¢æ•°ã«æ¸¡ã•ã‚Œã‚‹ä½•ã‚‰ã‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’éæ˜ç¤ºçš„ãªå¤–éƒ¨å¼•æ•°ã¨ã—ã¦æŒã£ã¦ã„ã¾ã™ã€‚çµ„ã¿è¾¼ã¿ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¾‹ã¯ã€ *alist* ã‚’ãƒªã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ãŸã¨ãã® "
"``alist.append()`` ã§ã™ã€‚ã“ã®å ´åˆã«ã¯ã€èª­ã¿å‡ºã—å°‚ç”¨ã®å±æ€§ :attr:`__self__` ã¯ *alist* "
"ã§è¡¨ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:683
msgid "Classes"
msgstr "ã‚¯ãƒ©ã‚¹"

#: ../../reference/datamodel.rst:679
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that "
"override :meth:`__new__`.  The arguments of the call are passed to "
":meth:`__new__` and, in the typical case, to :meth:`__init__` to initialize "
"the new instance."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã¯å‘¼ã³å‡ºã—å¯èƒ½ã§ã™ã€‚ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é€šå¸¸ã€ãã®ã‚¯ãƒ©ã‚¹ã®æ–°ãŸãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªã¨ã—ã¦æŒ¯èˆã„ã¾ã™ãŒã€ :meth:`__new__` "
"ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¦ã€ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æŒãŸã›ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚å‘¼ã³å‡ºã—ã«ä½¿ã‚ã‚ŒãŸå¼•æ•°ã¯ã€ :meth:`__new__` ã¨ã€å…¸å‹çš„ãªå ´åˆã§ã¯ "
":meth:`__init__` ã«æ¸¡ã•ã‚Œã€æ–°ãŸãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®åˆæœŸåŒ–ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:688
msgid "Class Instances"
msgstr "ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹"

#: ../../reference/datamodel.rst:686
msgid ""
"Instances of arbitrary classes can be made callable by defining a "
":meth:`__call__` method in their class."
msgstr "ä»»æ„ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ã‚¯ãƒ©ã‚¹ã§ :meth:`__call__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§å‘¼ã³å‡ºã—å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:738
msgid "Modules"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (module)"

#: ../../reference/datamodel.rst:695
msgid ""
"Modules are a basic organizational unit of Python code, and are created by "
"the :ref:`import system <importsystem>` as invoked either by the "
":keyword:`import` statement (see :keyword:`import`), or by calling functions"
" such as :func:`importlib.import_module` and built-in :func:`__import__`.  A"
" module object has a namespace implemented by a dictionary object (this is "
"the dictionary referenced by the ``__globals__`` attribute of functions "
"defined in the module).  Attribute references are translated to lookups in "
"this dictionary, e.g., ``m.x`` is equivalent to ``m.__dict__[\"x\"]``. A "
"module object does not contain the code object used to initialize the module"
" (since it isn't needed once the initialization is done)."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ Python ã‚³ãƒ¼ãƒ‰ã®åŸºç¤çš„ãªçµ„ç¹”å˜ä½ã§ã€ :keyword:`import` æ–‡ã‚ã‚‹ã„ã¯ "
":func:`importlib.import_module` ã‚„çµ„ã¿è¾¼ã¿ã® :func:`__import__` "
"ã®ã‚ˆã†ãªé–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§èµ·å‹•ã•ã‚Œã‚‹ :ref:`import system <importsystem>` ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã¾ã™ "
"(:keyword:`import` ã‚’å‚ç…§)ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€è¾æ›¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ã“ã‚Œã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§å®šç¾©ã•ã‚ŒãŸé–¢æ•°ã® "
"``__globals__`` å±æ€§ã‹ã‚‰å‚ç…§ã•ã‚Œã‚‹è¾æ›¸ã§ã™) ã§å®Ÿè£…ã•ã‚ŒãŸåå‰ç©ºé–“ã‚’æŒã£ã¦ã„ã¾ã™ã€‚å±æ€§ã®å‚ç…§ã¯ã€ã“ã®è¾æ›¸ã®æ¤œç´¢ã«ç¿»è¨³ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ "
"``m.x`` ã¯ ``m.__dict__[\"x\"]`` "
"ã¨ç­‰ä¾¡ã§ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–ã«ä½¿ã‚ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å«ã‚“ã§ã„ã¾ã›ã‚“ (åˆæœŸåŒ–ãŒçµ‚ã‚ã‚Œã°ã‚‚ã†å¿…è¦ãªã„ã‹ã‚‰ã§ã™)ã€‚"

#: ../../reference/datamodel.rst:707
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"å±æ€§ã®ä»£å…¥ã‚’è¡Œã†ã¨ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“è¾æ›¸ã®å†…å®¹ã‚’æ›´æ–°ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``m.x = 1`` ã¯ ``m.__dict__[\"x\"] = 1``"
" ã¨åŒã˜ã§ã™ã€‚"

#: ../../reference/datamodel.rst:717
msgid ""
"Predefined (writable) attributes: :attr:`__name__` is the module's name; "
":attr:`__doc__` is the module's documentation string, or ``None`` if "
"unavailable; :attr:`__annotations__` (optional) is a dictionary containing "
":term:`variable annotations <variable annotation>` collected during module "
"body execution; :attr:`__file__` is the pathname of the file from which the "
"module was loaded, if it was loaded from a file. The :attr:`__file__` "
"attribute may be missing for certain types of modules, such as C modules "
"that are statically linked into the interpreter; for extension modules "
"loaded dynamically from a shared library, it is the pathname of the shared "
"library file."
msgstr ""
"å®šç¾©æ¸ˆã¿ã® (æ›¸ãè¾¼ã¿å¯èƒ½ãª) å±æ€§: :attr:`__name__` ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã§ã™;  :attr:`__doc__` "
"ã¯é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã§ã™ã€‚ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™; :attr:`__annotations__`"
" (ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«) ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æœ¬ä½“ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹ã¨ãã«åé›†ã—ãŸ :term:`å¤‰æ•°ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ <variable annotation>` "
"ãŒå…¥ã£ãŸè¾æ›¸ã§ã™; ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå ´åˆã€ :attr:`__file__` "
"ã¯ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹åã§ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«é™çš„ã«ãƒªãƒ³ã‚¯ã•ã‚Œã¦ã„ã‚‹ C ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚ˆã†ãªç‰¹å®šã®ç¨®é¡ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ "
":attr:`__file__` å±æ€§ã¯å­˜åœ¨ã—ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“; å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‹ã‚‰å‹•çš„ã«ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸæ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å ´åˆã€ã“ã®å±æ€§ã¯ "
"å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹åã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:730
msgid ""
"Special read-only attribute: :attr:`~object.__dict__` is the module's "
"namespace as a dictionary object."
msgstr "èª­ã¿å‡ºã—å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`~object.__dict__` ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ã§ã€è¾æ›¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../reference/datamodel.rst:735
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary"
" will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""
"CPython "
"ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¾æ›¸ã‚’å‰Šé™¤ã™ã‚‹æ–¹æ³•ã«ã‚ˆã‚Šã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¾æ›¸ãŒç”ŸããŸå‚ç…§ã‚’æŒã£ã¦ã„ãŸã¨ã—ã¦ã‚‚ãã®è¾æ›¸ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å¤–ã‚ŒãŸæ™‚ã«å‰Šé™¤ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚’é¿ã‘ã‚‹ã«ã¯ã€è¾æ›¸ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã‹ã€è¾æ›¸ã‚’ç›´æ¥ä½¿ã£ã¦ã„ã‚‹é–“ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä¿æŒã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:797
msgid "Custom classes"
msgstr "ã‚«ã‚¹ã‚¿ãƒ ã‚¯ãƒ©ã‚¹å‹"

#: ../../reference/datamodel.rst:741
msgid ""
"Custom class types are typically created by class definitions (see section "
":ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, "
"e.g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although there are a "
"number of hooks which allow for other means of locating attributes). When "
"the attribute name is not found there, the attribute search continues in the"
" base classes. This search of the base classes uses the C3 method resolution"
" order which behaves correctly even in the presence of 'diamond' inheritance"
" structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by Python can be "
"found in the documentation accompanying the 2.3 release at "
"https://www.python.org/download/releases/2.3/mro/."
msgstr ""
"ã‚«ã‚¹ã‚¿ãƒ ã‚¯ãƒ©ã‚¹å‹ã¯é€šå¸¸ã€ã‚¯ãƒ©ã‚¹å®šç¾© (:ref:`class` å‚ç…§) "
"ã§ç”Ÿæˆã•ã‚Œã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã¯è¾æ›¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§å®Ÿè£…ã•ã‚ŒãŸåå‰ç©ºé–“ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹å±æ€§ã®å‚ç…§ã¯ã€ã“ã®è¾æ›¸ã«å¯¾ã™ã‚‹æ¢ç´¢ (lookup) "
"ã«ç¿»è¨³ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ``C.x`` ã¯ ``C.__dict__[\"x\"]`` ã«ç¿»è¨³ã•ã‚Œã¾ã™ "
"(ãŸã ã—ã€å±æ€§å‚ç…§ã®æ„å‘³ã‚’å¤‰ãˆã‚‰ã‚Œã‚‹å¹¾ã¤ã‹ã®ãƒ•ãƒƒã‚¯ãŒã‚ã‚Šã¾ã™)ã€‚å±æ€§ãŒã“ã®æ¢ç´¢ã§è¦‹ã¤ã‹ã‚‰ãªã„ã¨ãã€ãã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§æ¢ç´¢ãŒç¶šã‘ã‚‰ã‚Œã¾ã™ã€‚åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã“ã®æ¢ç´¢ã¯ã€C3"
" ãƒ¡ã‚½ãƒƒãƒ‰è§£æ±ºé †åº (MRO=method resolution order) "
"ã‚’åˆ©ç”¨ã—ã¦ã„ã¦ã€è¤‡æ•°ã®ç¶™æ‰¿çµŒè·¯ãŒå…±é€šã®ç¥–å…ˆã«ã¤ãªãŒã‚‹ã€Œãƒ€ã‚¤ã‚¢ãƒ¢ãƒ³ãƒ‰ã€ç¶™æ‰¿æ§‹é€ ãŒã‚ã£ã¦ã‚‚æ­£ã—ãå‹•ä½œã—ã¾ã™ã€‚ C3 MRO ã«ã¤ã„ã¦ã®ã‚ˆã‚Šè©³ç´°ãªæƒ…å ±ã¯ã€ "
"2.3ãƒªãƒªãƒ¼ã‚¹ã«ä»˜å±ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ https://www.python.org/download/releases/2.3/mro/ ã«ã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:765
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield a "
"class method object, it is transformed into an instance method object whose "
":attr:`__self__` attribute is :class:`C`.  When it would yield a static "
"method object, it is transformed into the object wrapped by the static "
"method object. See section :ref:`descriptors` for another way in which "
"attributes retrieved from a class may differ from those actually contained "
"in its :attr:`~object.__dict__`."
msgstr ""
"ã‚¯ãƒ©ã‚¹ (:class:`C` ã¨ã—ã¾ã™) å±æ€§å‚ç…§ãŒã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ãã†ã¨ã™ã‚‹ã¨ãã«ã¯ã€ ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :attr:`__self__` å±æ€§ãŒ :class:`C` ã§ã‚ã‚‹ã‚ˆã†ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚\n"
"é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ãã†ã¨ã™ã‚‹ã¨ãã«ã¯ã€é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚\n"
":ref:`descriptors` ç¯€ã‚’å‚ç…§ã™ã‚‹ã¨ã€ã¾ãŸåˆ¥ã®ç†ç”±ã§ã‚¯ãƒ©ã‚¹ã‹ã‚‰å–ã‚Šå‡ºã—ãŸå±æ€§ã¨å®Ÿéš›ã« :attr:`~object.__dict__` ã«ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ãŒç•°ãªã‚‹ã“ã¨ãŒã‚ã‚‹ã®ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:775
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr "ã‚¯ãƒ©ã‚¹å±æ€§ã‚’ä»£å…¥ã™ã‚‹ã¨ã€ãã®ã‚¯ãƒ©ã‚¹ã®è¾æ›¸ã ã‘ãŒæ›´æ–°ã•ã‚Œã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®è¾æ›¸ã¯æ›´æ–°ã—ã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:780
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr "ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‘¼ã³å‡ºã™ (ä¸Šè¨˜ã‚’å‚ç…§) ã¨ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ (ä¸‹è¨˜ã‚’å‚ç…§)ã€‚"

#: ../../reference/datamodel.rst:790
msgid ""
"Special attributes: :attr:`~definition.__name__` is the class name; "
":attr:`__module__` is the module name in which the class was defined; "
":attr:`~object.__dict__` is the dictionary containing the class's namespace;"
" :attr:`~class.__bases__` is a tuple containing the base classes, in the "
"order of their occurrence in the base class list; :attr:`__doc__` is the "
"class's documentation string, or ``None`` if undefined; "
":attr:`__annotations__` (optional) is a dictionary containing "
":term:`variable annotations <variable annotation>` collected during class "
"body execution."
msgstr ""
"ç‰¹æ®Šå±æ€§: :attr:`~definition.__name__` ã¯ã‚¯ãƒ©ã‚¹åã§ã™;\n"
":attr:`__module__` ã¯ã‚¯ãƒ©ã‚¹ãŒå®šç¾©ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã§ã™;\n"
":attr:`~object.__dict__` ã¯ã‚¯ãƒ©ã‚¹ãŒæŒã¤åå‰ç©ºé–“ãŒå…¥ã£ãŸè¾æ›¸ã§ã™;\n"
":attr:`~class.__bases__` ã¯åŸºåº•ã‚¯ãƒ©ã‚¹ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã§ã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒªã‚¹ãƒˆã«è¡¨ã‚Œã‚‹é †åºã§ä¸¦ã‚“ã§ã„ã¾ã™;\n"
":attr:`__doc__` ã¯ã‚¯ãƒ©ã‚¹ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ–‡å­—åˆ—ã§ã€æœªå®šç¾©ã®å ´åˆã¯ None ã§ã™;\n"
":attr:`__annotations__` (ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«) ã¯ã‚¯ãƒ©ã‚¹ã®æœ¬ä½“ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹ã¨ãã«åé›†ã—ãŸ :term:`å¤‰æ•°ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ <variable annotation>` ãŒå…¥ã£ãŸè¾æ›¸ã§ã™ã€‚"

#: ../../reference/datamodel.rst:840
msgid "Class instances"
msgstr "ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ (class instance)"

#: ../../reference/datamodel.rst:806
msgid ""
"A class instance is created by calling a class object (see above).  A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object, it is transformed into an instance "
"method object whose :attr:`__self__` attribute is the instance.  Static "
"method and class method objects are also transformed; see above under "
"\"Classes\".  See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`.  If no "
"class attribute is found, and the object's class has a :meth:`__getattr__` "
"method, that is called to satisfy the lookup."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ä¸Šè¨˜å‚ç…§) ã‚’å‘¼ã³å‡ºã—ã¦ç”Ÿæˆã—ã¾ã™ã€‚\n"
"ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯è¾æ›¸ã§å®Ÿè£…ã•ã‚ŒãŸåå‰ç©ºé–“ã‚’æŒã£ã¦ãŠã‚Šã€å±æ€§å‚ç…§ã®æ™‚ã«ã¯ã¾ãšã“ã®è¾æ›¸ãŒæ¢ç´¢ã•ã‚Œã¾ã™ã€‚\n"
"ã“ã“ã§å±æ€§ãŒè¦‹ã¤ã‹ã‚‰ãšã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¯ãƒ©ã‚¹ã«ãã®åå‰ã®å±æ€§ãŒã‚ã‚‹ã¨ãã¯ã€ç¶šã‘ã¦ã‚¯ãƒ©ã‚¹å±æ€§ã‚’æ¤œç´¢ã—ã¾ã™ã€‚\n"
"è¦‹ã¤ã‹ã£ãŸã‚¯ãƒ©ã‚¹å±æ€§ãŒãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã ã£ãŸå ´åˆã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ :attr:`__self__` å±æ€§ã¨ã™ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚\n"
"é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚åŒæ§˜ã«å¤‰æ›ã•ã‚Œã¾ã™;\n"
"ä¸Šè¨˜ã® \"ã‚¯ãƒ©ã‚¹\" ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚\n"
":ref:`descriptors` ç¯€ã‚’å‚ç…§ã™ã‚‹ã¨ã€ã¾ãŸåˆ¥ã®ç†ç”±ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’é€šã—ã¦ã‚¯ãƒ©ã‚¹ã‹ã‚‰å–ã‚Šå‡ºã—ãŸå±æ€§ã¨å®Ÿéš›ã« :attr:`~object.__dict__` ã«ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ãŒç•°ãªã‚‹ã“ã¨ãŒã‚ã‚‹ã®ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚\n"
"ã‚¯ãƒ©ã‚¹å±æ€§ãŒè¦‹ã¤ã‹ã‚‰ãšã€ã‹ã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¯ãƒ©ã‚¹ãŒ :meth:`__getattr__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã¯ã€æ¢ç´¢ã®ç¾©å‹™ã‚’æœãŸã™ãŸã‚ã«ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:822
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`__setattr__` or "
":meth:`__delattr__` method, this is called instead of updating the instance "
"dictionary directly."
msgstr ""
"å±æ€§ã®ä»£å…¥ã‚„å‰Šé™¤ã‚’è¡Œã†ã¨ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è¾æ›¸ã‚’æ›´æ–°ã—ã¾ã™ãŒã€ã‚¯ãƒ©ã‚¹ã®è¾æ›¸ã‚’æ›´æ–°ã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¹ã§ :meth:`__setattr__` ã‚„"
" :meth:`__delattr__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ç›´æ¥ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è¾æ›¸ã‚’æ›´æ–°ã™ã‚‹ä»£ã‚ã‚Šã«ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:832
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ã‚ã‚‹ç‰¹å®šã®åå‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã€æ•°å€¤å‹ã‚„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã€ã‚ã‚‹ã„ã¯ãƒãƒƒãƒ—å‹ã®ã‚ˆã†ã«æŒ¯èˆã†ã“ã¨ãŒã§ãã¾ã™ã€‚ "
":ref:`specialnames` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:839
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary; "
":attr:`~instance.__class__` is the instance's class."
msgstr ""
"ç‰¹æ®Šå±æ€§: :attr:`~object.__dict__` ã¯å±æ€§ã®è¾æ›¸ã§ã™; :attr:`~instance.__class__` "
"ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../reference/datamodel.rst:866
msgid "I/O objects (also known as file objects)"
msgstr "I/O ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åˆ¥å)"

#: ../../reference/datamodel.rst:856
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and "
"also :func:`os.popen`, :func:`os.fdopen`, and the "
":meth:`~socket.socket.makefile` method of socket objects (and perhaps by "
"other functions or methods provided by extension modules)."
msgstr ""
":term:`file object` ã¯é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¡¨ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚‹ãŸã‚ã®æ§˜ã€…ãªã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆãŒã‚ã‚Šã¾ã™: "
":func:`open` çµ„ã¿è¾¼ã¿é–¢æ•°ã€ :func:`os.popen` ã€ :func:`os.fdopen` ã€ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® "
":meth:`~socket.socket.makefile` ãƒ¡ã‚½ãƒƒãƒ‰ (ã‚ã‚‹ã„ã¯æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰æä¾›ã•ã‚Œã‚‹ä»–ã®é–¢æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰) ã€‚"

#: ../../reference/datamodel.rst:862
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized"
" to file objects corresponding to the interpreter's standard input, output "
"and error streams; they are all open in text mode and therefore follow the "
"interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ``sys.stdin`` ã€ ``sys.stdout`` ãŠã‚ˆã³ ``sys.stderr`` "
"ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®æ¨™æº–å…¥åŠ›ã€æ¨™æº–å‡ºåŠ›ã€ãŠã‚ˆã³æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾å¿œã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã¯ã™ã¹ã¦ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§é–‹ã‹ã‚Œã€"
" :class:`io.TextIOBase` æŠ½è±¡ã‚¯ãƒ©ã‚¹ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã«å¾“ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1072
msgid "Internal types"
msgstr "å†…éƒ¨å‹ (internal type)"

#: ../../reference/datamodel.rst:873
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""
"ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒå†…éƒ¨çš„ã«ä½¿ã£ã¦ã„ã‚‹ã„ãã¤ã‹ã®å‹ã¯ã€ãƒ¦ãƒ¼ã‚¶ã«å…¬é–‹ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å®šç¾©ã¯å°†æ¥ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯å¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ãŒã€ã“ã“ã§ã¯è¨˜è¿°ã®å®Œå…¨æ€§ã®ãŸã‚ã«è§¦ã‚Œã¦ãŠãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:941
msgid "Code objects"
msgstr "ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../reference/datamodel.rst:880
msgid ""
"Code objects represent *byte-compiled* executable Python code, or "
":term:`bytecode`. The difference between a code object and a function object"
" is that the function object contains an explicit reference to the "
"function's globals (the module in which it was defined), while a code object"
" contains no context; also the default argument values are stored in the "
"function object, not in the code object (because they represent values "
"calculated at run-time).  Unlike function objects, code objects are "
"immutable and contain no references (directly or indirectly) to mutable "
"objects."
msgstr ""
"ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ *ãƒã‚¤ãƒˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸ (byte-compiled)* å®Ÿè¡Œå¯èƒ½ãª Python "
"ã‚³ãƒ¼ãƒ‰ã€åˆ¥åãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰(:term:`bytecode`) "
"ã‚’è¡¨ç¾ã—ã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é•ã„ã¯ã€é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒé–¢æ•°ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° (é–¢æ•°ã‚’å®šç¾©ã—ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«) "
"ã«å¯¾ã—ã¦æ˜ç¤ºçš„ãªå‚ç…§ã‚’æŒã£ã¦ã„ã‚‹ã®ã«å¯¾ã—ã€ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒãªã„ã¨ã„ã†ã“ã¨ã§ã™; "
"ã¾ãŸã€é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°å€¤ã‚’è¨˜æ†¶ã§ãã¾ã™ãŒã€ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã§ãã¾ã›ã‚“ "
"(å®Ÿè¡Œæ™‚ã«è¨ˆç®—ã•ã‚Œã‚‹å€¤ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚)ã€‚é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨é•ã„ã€ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤‰æ›´ä¸å¯èƒ½ã§ã€å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’ "
"(ç›´æ¥ã€é–“æ¥ã«é–¢ã‚ã‚‰ãš) å«ã¿ã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:905
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; "
":attr:`co_argcount` is the number of positional arguments (including "
"arguments with default values); :attr:`co_nlocals` is the number of local "
"variables used by the function (including arguments); :attr:`co_varnames` is"
" a tuple containing the names of the local variables (starting with the "
"argument names); :attr:`co_cellvars` is a tuple containing the names of "
"local variables that are referenced by nested functions; :attr:`co_freevars`"
" is a tuple containing the names of free variables; :attr:`co_code` is a "
"string representing the sequence of bytecode instructions; :attr:`co_consts`"
" is a tuple containing the literals used by the bytecode; :attr:`co_names` "
"is a tuple containing the names used by the bytecode; :attr:`co_filename` is"
" the filename from which the code was compiled; :attr:`co_firstlineno` is "
"the first line number of the function; :attr:`co_lnotab` is a string "
"encoding the mapping from bytecode offsets to line numbers (for details see "
"the source code of the interpreter); :attr:`co_stacksize` is the required "
"stack size (including local variables); :attr:`co_flags` is an integer "
"encoding a number of flags for the interpreter."
msgstr ""
"èª­ã¿å‡ºã—å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`co_name` ã¯é–¢æ•°åã‚’è¡¨ã—ã¾ã™; :attr:`co_argcount` ã¯ä½ç½®å¼•æ•° "
"(positional argument) ã®æ•°ã§ã™; :attr:`co_nlocals` ã¯é–¢æ•°ãŒä½¿ã† (å¼•æ•°ã‚’å«ã‚ãŸ) ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®æ•°ã§ã™; "
":attr:`co_varnames` ã¯ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°åã®å…¥ã£ãŸã‚¿ãƒ—ãƒ«ã§ã™ (å¼•æ•°åã‹ã‚‰å§‹ã¾ã£ã¦ã„ã¾ã™); :attr:`co_cellvars` "
"ã¯ãƒã‚¹ãƒˆã•ã‚ŒãŸé–¢æ•°ã§å‚ç…§ã•ã‚Œã¦ã„ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®åå‰ãŒå…¥ã£ãŸã‚¿ãƒ—ãƒ«ã§ã™; :attr:`co_freevars` ã¯è‡ªç”±å¤‰æ•°ã®åå‰ãŒå…¥ã£ãŸã‚¿ãƒ—ãƒ«ã§ã™ã€‚ "
":attr:`co_code` ã¯ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰åˆ—ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹æ–‡å­—åˆ—ã§ã™; :attr:`co_consts` "
"ã¯ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ãƒªãƒ†ãƒ©ãƒ«ã®å…¥ã£ãŸã‚¿ãƒ—ãƒ«ã§ã™; :attr:`co_names` ã¯ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹åå‰ã®å…¥ã£ãŸã‚¿ãƒ—ãƒ«ã§ã™; "
":attr:`co_filename` ã¯ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒè¡Œã‚ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«åã§ã™; :attr:`co_firstlineno` "
"ã¯é–¢æ•°ã®æœ€åˆã®è¡Œç•ªå·ã§ã™; :attr:`co_lnotab` ã¯ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã‚ªãƒ•ã‚»ãƒƒãƒˆã‹ã‚‰è¡Œç•ªå·ã¸ã®å¯¾å¿œä»˜ã‘ã‚’ã‚³ãƒ¼ãƒ‰åŒ–ã—ãŸæ–‡å­—åˆ—ã§ã™ "
"(è©³ç´°ã«ã¤ã„ã¦ã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å‚ç…§ã—ã¦ãã ã•ã„); :attr:`co_stacksize` ã¯é–¢æ•°ã§ (ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®åˆ†ã‚‚å«ã‚ã¦) "
"å¿…è¦ãªã‚¹ã‚¿ãƒƒã‚¯ã‚µã‚¤ã‚ºã§ã™; :attr:`co_flags` ã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ç”¨ã®æ§˜ã€…ãªãƒ•ãƒ©ã‚°ã‚’ã‚³ãƒ¼ãƒ‰åŒ–ã—ãŸæ•´æ•°ã§ã™ã€‚"

#: ../../reference/datamodel.rst:924
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is "
"set if the function uses the ``*arguments`` syntax to accept an arbitrary "
"number of positional arguments; bit ``0x08`` is set if the function uses the"
" ``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` "
"is set if the function is a generator."
msgstr ""
"ä»¥ä¸‹ã®ãƒ•ãƒ©ã‚°ãƒ“ãƒƒãƒˆãŒ :attr:`co_flags` ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™: ``0x04`` ãƒ“ãƒƒãƒˆã¯ã€é–¢æ•°ãŒ ``*arguments`` "
"æ§‹æ–‡ã‚’ä½¿ã£ã¦ä»»æ„ã®æ•°ã®ä½ç½®å¼•æ•°ã‚’å—ç†ã§ãã‚‹å ´åˆã«ç«‹ã¦ã‚‰ã‚Œã¾ã™; ``0x08`` ãƒ“ãƒƒãƒˆã¯ã€é–¢æ•°ãŒ ``**keywords`` "
"æ§‹æ–‡ã‚’ä½¿ã£ã¦ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’å—ç†ã§ãã‚‹å ´åˆã«ç«‹ã¦ã‚‰ã‚Œã¾ã™; ``0x20`` ãƒ“ãƒƒãƒˆã¯ã€é–¢æ•°ãŒã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã§ã‚ã‚‹å ´åˆã«ç«‹ã¦ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:930
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`co_flags` to indicate whether a code object was compiled with"
" a particular feature enabled: bit ``0x2000`` is set if the function was "
"compiled with future division enabled; bits ``0x10`` and ``0x1000`` were "
"used in earlier versions of Python."
msgstr ""
"å°†æ¥æ©Ÿèƒ½ (future feature) å®£è¨€ (``from __future__ import division``) ã‚‚ã¾ãŸã€ "
":attr:`co_flags` ã®ãƒ“ãƒƒãƒˆã‚’ç«‹ã¦ã‚‹ã“ã¨ã§ã€ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç‰¹å®šã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹ã«ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™: "
"``0x2000`` ãƒ“ãƒƒãƒˆã¯ã€é–¢æ•°ãŒå°†æ¥æ©Ÿèƒ½ã‚’æœ‰åŠ¹ã«ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ç«‹ã¦ã‚‰ã‚Œã¾ã™; ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã§ã¯ã€ "
"``0x10`` ãŠã‚ˆã³ ``0x1000`` ãƒ“ãƒƒãƒˆãŒä½¿ã‚ã‚Œã¦ã„ã¾ã—ãŸã€‚"

#: ../../reference/datamodel.rst:936
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ":attr:`co_flags` ã®ãã®ä»–ã®ãƒ“ãƒƒãƒˆã¯å°†æ¥ã«å†…éƒ¨çš„ã«åˆ©ç”¨ã™ã‚‹ãŸã‚ã«äºˆç´„ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:940
msgid ""
"If a code object represents a function, the first item in :attr:`co_consts` "
"is the documentation string of the function, or ``None`` if undefined."
msgstr ""
"ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒé–¢æ•°ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹å ´åˆã€ :attr:`co_consts` "
"ã®æœ€åˆã®è¦ç´ ã¯é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã«ãªã‚Šã¾ã™ã€‚ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã«ã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:990
msgid "Frame objects"
msgstr "ãƒ•ãƒ¬ãƒ¼ãƒ  (frame) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../reference/datamodel.rst:948
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below)."
msgstr ""
"ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å®Ÿè¡Œãƒ•ãƒ¬ãƒ¼ãƒ  (execution frame) ã‚’è¡¨ã—ã¾ã™ã€‚å®Ÿè¡Œãƒ•ãƒ¬ãƒ¼ãƒ ã¯ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå†…ã«å‡ºç¾ã—ã¾ã™ "
"(ä¸‹è¨˜å‚ç…§)ã€‚"

#: ../../reference/datamodel.rst:959
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack frame "
"(towards the caller), or ``None`` if this is the bottom stack frame; "
":attr:`f_code` is the code object being executed in this frame; "
":attr:`f_locals` is the dictionary used to look up local variables; "
":attr:`f_globals` is used for global variables; :attr:`f_builtins` is used "
"for built-in (intrinsic) names; :attr:`f_lasti` gives the precise "
"instruction (this is an index into the bytecode string of the code object)."
msgstr ""
"èª­ã¿å‡ºã—å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`f_back` ã¯ç›´å‰ã®ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ  (å‘¼ã³å‡ºã—å´ã®æ–¹å‘) ã§ã€ãã‚ŒãŒã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã®æœ€ä¸‹æ®µãªã‚‰ "
"``None`` ã§ã™; :attr:`f_code` ã¯ãã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™; :attr:`f_locals` "
"ã¯ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®æ¢ç´¢ã«ä½¿ã‚ã‚Œã‚‹è¾æ›¸ã§ã™; :attr:`f_globals` ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ä½¿ã‚ã‚Œã¾ã™; :attr:`f_builtins` "
"ã¯çµ„ã¿è¾¼ã¿ã® (Python å›ºæœ‰ã®) åå‰ã«ä½¿ã‚ã‚Œã¾ã™; :attr:`f_lasti` ã¯å³å¯†ãªå‘½ä»¤ã‚³ãƒ¼ãƒ‰ "
"(ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—ã¸ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹) ã§ã™ã€‚"

#: ../../reference/datamodel.rst:971
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a function"
" called at the start of each source code line (this is used by the "
"debugger); :attr:`f_lineno` is the current line number of the frame --- "
"writing to this from within a trace function jumps to the given line (only "
"for the bottom-most frame).  A debugger can implement a Jump command (aka "
"Set Next Statement) by writing to f_lineno."
msgstr ""
"æ›¸ãè¾¼ã¿å¯èƒ½ãªç‰¹æ®Šå±æ€§: :attr:`f_trace` ã¯ã€ ``None`` ã§ãªã‘ã‚Œã°ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®å„è¡Œã®å…ˆé ­ã§å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°ã§ã™ "
"(ãƒ‡ãƒãƒƒã‚¬ã«ä½¿ã‚ã‚Œã¾ã™); :attr:`f_lineno` ã¯ãƒ•ãƒ¬ãƒ¼ãƒ ä¸­ã«ãŠã‘ã‚‹ç¾åœ¨ã®è¡Œç•ªå·ã§ã™ --- ãƒˆãƒ¬ãƒ¼ã‚¹é–¢æ•° (trace "
"function) å´ã§ã“ã®å€¤ã«æ›¸ãè¾¼ã¿ã‚’è¡Œã†ã¨ã€æŒ‡å®šã—ãŸè¡Œã«ã‚¸ãƒ£ãƒ³ãƒ—ã—ã¾ã™ (æœ€ä¸‹æ®µã®å®Ÿè¡Œãƒ•ãƒ¬ãƒ¼ãƒ ã«ã„ã‚‹ã¨ãã®ã¿)ã€‚ãƒ‡ãƒãƒƒã‚¬ã§ã¯ã€ f_fileno "
"ã‚’æ›¸ãè¾¼ã‚€ã“ã¨ã§ã€ã‚¸ãƒ£ãƒ³ãƒ—å‘½ä»¤ (Set Next Statement å‘½ä»¤ã¨ã‚‚) ã‚’å®Ÿè£…ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:978
msgid "Frame objects support one method:"
msgstr "ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¸€ã¤ã‚µãƒãƒ¼ãƒˆã—ã¾ã™:"

#: ../../reference/datamodel.rst:982
msgid ""
"This method clears all references to local variables held by the frame.  "
"Also, if the frame belonged to a generator, the generator is finalized.  "
"This helps break reference cycles involving frame objects (for example when "
"catching an exception and storing its traceback for later use)."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ•ãƒ¬ãƒ¼ãƒ ãŒä¿æŒã—ã¦ã„ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã¸ã®å‚ç…§ã‚’å…¨ã¦å‰Šé™¤ã—ã¾ã™ã€‚\n"
"ã¾ãŸã€ãƒ•ãƒ¬ãƒ¼ãƒ ãŒã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã«å±ã—ã¦ã„ãŸå ´åˆã¯ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã«ã‚‚çµ‚äº†å‡¦ç†ãŒè¡Œã‚ã‚Œã¾ã™ã€‚\n"
"ã“ã‚Œã«ã‚ˆã£ã¦ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å«ã‚“ã å¾ªç’°å‚ç…§ãŒè§£æ¶ˆã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ (ä¾‹ãˆã°ã€ä¾‹å¤–ã‚’æ•æ‰ã—ã€å¾Œã§ä½¿ã†ãŸã‚ã«ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚’ä¿å­˜ã™ã‚‹å ´åˆ)ã€‚"

#: ../../reference/datamodel.rst:988
msgid ":exc:`RuntimeError` is raised if the frame is currently executing."
msgstr "ãƒ•ãƒ¬ãƒ¼ãƒ ãŒç¾åœ¨å®Ÿè¡Œä¸­ã®å ´åˆ :exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1028
msgid "Traceback objects"
msgstr "ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ (traceback) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../reference/datamodel.rst:1003
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is created when an exception occurs.  When the search for an "
"exception handler unwinds the execution stack, at each unwound level a "
"traceback object is inserted in front of the current traceback.  When an "
"exception handler is entered, the stack trace is made available to the "
"program. (See section :ref:`try`.) It is accessible as the third item of the"
" tuple returned by ``sys.exc_info()``. When the program contains no suitable"
" handler, the stack trace is written (nicely formatted) to the standard "
"error stream; if the interpreter is interactive, it is also made available "
"to the user as ``sys.last_traceback``."
msgstr ""
"ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¾‹å¤–ã®ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸéš›ã«ç”Ÿæˆã•ã‚Œã¾ã™ã€‚ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã®æ¤œç´¢ãŒå®Ÿè¡Œã‚¹ã‚¿ãƒƒã‚¯ã‚’æˆ»ã£ã¦ã„ãéš›ã€æˆ»ã£ãŸãƒ¬ãƒ™ãƒ«æ¯ã«ã€ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç¾åœ¨ã®ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã®å‰ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã«å…¥ã‚‹ã¨ã€ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ å´ã§åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"
" (:ref:`try` ã‚’å‚ç…§ã€‚) ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã¯ã€ ``sys.exc_info()`` "
"ãŒè¿”ã™ã‚¿ãƒ—ãƒ«ã®ä¸‰ç•ªç›®ã®è¦ç´ ã¨ã—ã¦å¾—ã‚‰ã‚Œã¾ã™ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«é©åˆ‡ãªãƒãƒ³ãƒ‰ãƒ©ãŒãªã„ã¨ãã€ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã¯ (ã†ã¾ãæ›¸å¼åŒ–ã•ã‚Œã¦) "
"æ¨™æº–ã‚¨ãƒ©ãƒ¼ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«æ›¸ãå‡ºã•ã‚Œã¾ã™; ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒå¯¾è©±çš„ã«å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹å ´åˆã€ ``sys.last_traceback`` "
"ã¨ã—ã¦å¾—ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1021
msgid ""
"Special read-only attributes: :attr:`tb_next` is the next level in the stack"
" trace (towards the frame where the exception occurred), or ``None`` if "
"there is no next level; :attr:`tb_frame` points to the execution frame of "
"the current level; :attr:`tb_lineno` gives the line number where the "
"exception occurred; :attr:`tb_lasti` indicates the precise instruction.  The"
" line number and last instruction in the traceback may differ from the line "
"number of its frame object if the exception occurred in a :keyword:`try` "
"statement with no matching except clause or with a finally clause."
msgstr ""
"èª­ã¿å‡ºã—å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`tb_next` ã¯ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹å†…ã® (ä¾‹å¤–ã®ç™ºç”Ÿã—ã¦ã„ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã«å‘ã‹ã£ã¦) "
"æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã§ã™ã€‚æ¬¡ã®ãƒ¬ãƒ™ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã«ã¯ ``None`` ã«ãªã‚Šã¾ã™; :attr:`tb_frame` "
"ã¯ç¾åœ¨ã®ãƒ¬ãƒ™ãƒ«ã«ãŠã‘ã‚‹å®Ÿè¡Œãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æŒ‡ã—ã¾ã™; :attr:`tb_lineno` ã¯ä¾‹å¤–ã®ç™ºç”Ÿã—ãŸè¡Œç•ªå·ã§ã™; :attr:`tb_lasti` "
"ã¯å³å¯†ãªå‘½ä»¤ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯å†…ã®è¡Œç•ªå·ã‚„æœ€å¾Œã«å®Ÿè¡Œã•ã‚ŒãŸå‘½ä»¤ã¯ã€ :keyword:`try` æ–‡å†…ã§ä¾‹å¤–ãŒç™ºç”Ÿã—ã€ã‹ã¤å¯¾å¿œã™ã‚‹ "
":keyword:`except` ç¯€ã‚„ :keyword:`finally` "
"ç¯€ãŒãªã„å ´åˆã«ã¯ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå†…ã®è¡Œç•ªå·ã¨ã¯ç•°ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1054
msgid "Slice objects"
msgstr "ã‚¹ãƒ©ã‚¤ã‚¹ (slice) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../reference/datamodel.rst:1033
msgid ""
"Slice objects are used to represent slices for :meth:`__getitem__` methods."
"  They are also created by the built-in :func:`slice` function."
msgstr ""
"ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ :meth:`__getitem__` ãƒ¡ã‚½ãƒƒãƒ‰ã®ãŸã‚ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’è¡¨ã™ã®ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿ã® "
":func:`slice` é–¢æ•°ã§ã‚‚ç”Ÿæˆã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1041
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; "
":attr:`~slice.stop` is the upper bound; :attr:`~slice.step` is the step "
"value; each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"èª­ã¿å‡ºã—å°‚ç”¨ã®ç‰¹æ®Šå±æ€§: :attr:`~slice.start` ã¯ä¸‹é™ã§ã™; :attr:`~slice.stop` ã¯ä¸Šé™ã§ã™; "
":attr:`~slice.step` ã¯ã‚¹ãƒ†ãƒƒãƒ—ã®å€¤ã§ã™; ãã‚Œãã‚Œçœç•¥ã•ã‚ŒãŸå ´åˆã¯ ``None`` "
"ã¨ãªã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å±æ€§ã¯ä»»æ„ã®å‹ã‚’æŒã¦ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1045
msgid "Slice objects support one method:"
msgstr "ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¸€ã¤ã‚µãƒãƒ¼ãƒˆã—ã¾ã™:"

#: ../../reference/datamodel.rst:1049
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if applied "
"to a sequence of *length* items.  It returns a tuple of three integers; "
"respectively these are the *start* and *stop* indices and the *step* or "
"stride length of the slice. Missing or out-of-bounds indices are handled in "
"a manner consistent with regular slices."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å˜ä¸€ã®æ•´æ•°å¼•æ•° *length* ã‚’å–ã‚Šã€ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ *length* "
"è¦ç´ ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«é©ç”¨ã•ã‚ŒãŸã¨ãã«è¡¨ç¾ã™ã‚‹ã€ã‚¹ãƒ©ã‚¤ã‚¹ã«é–¢ã™ã‚‹æƒ…å ±ã‚’è¨ˆç®—ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ 3 ã¤ã®æ•´æ•°ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™; ãã‚Œãã‚Œ "
"*start* ãŠã‚ˆã³ *stop* ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ã€*step* "
"ã™ãªã‚ã¡ã‚¹ãƒ©ã‚¤ã‚¹ã®ã¾ãŸãå¹…ã§ã™ã€‚ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å€¤ãŒãªã„ã‹ã€ç¯„å›²å¤–ã®å€¤ã§ã‚ã‚Œã°ã€é€šå¸¸ã®ã‚¹ãƒ©ã‚¤ã‚¹ã¨å¤‰ã‚ã‚‰ãªã„ã‚„ã‚Šã‹ãŸã§æ‰±ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1064
msgid "Static method objects"
msgstr "é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ (static method) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../reference/datamodel.rst:1057
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are not themselves "
"callable, although the objects they wrap usually are. Static method objects "
"are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä¸Šã§èª¬æ˜ã—ãŸã‚ˆã†ãªé–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¤‰æ›ã‚’é˜»æ­¢ã™ã‚‹ãŸã‚ã®æ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»–ã®ä½•ã‚‰ã‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€é€šå¸¸ã¯ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åŒ…ã‚€ãƒ©ãƒƒãƒ‘ã§ã™ã€‚é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚¯ãƒ©ã‚¹ã‚„ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰å–å¾—ã™ã‚‹ã¨ã€å®Ÿéš›ã«è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã€ãã‚Œä»¥ä¸Šã¯å¤‰æ›ã®å¯¾è±¡ã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é€šå¸¸å‘¼ã³å‡ºã—å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ©ãƒƒãƒ—ã—ã¾ã™ãŒã€é™çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã¯å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚é™çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿"
" :func:`staticmethod` ã§ç”Ÿæˆã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1072
msgid "Class method objects"
msgstr "ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../reference/datamodel.rst:1067
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such"
" retrieval is described above, under \"User-defined methods\". Class method "
"objects are created by the built-in :func:`classmethod` constructor."
msgstr ""
"ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ä¼¼ã¦ã€åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åŒ…ã‚€ãƒ©ãƒƒãƒ‘ã§ã‚ã‚Šã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒ©ã‚¹ã‚„ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰å–ã‚Šå‡ºã™æ–¹æ³•ã‚’ä»£æ›¿ã—ã¾ã™ã€‚ã“ã®ã‚ˆã†ã«ã—ã¦å–å¾—ã—ãŸã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹•ä½œã«ã¤ã„ã¦ã¯ã€ä¸Šã®"
" \"ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ¡ã‚½ãƒƒãƒ‰ (user-defined method)\" ã§èª¬æ˜ã•ã‚Œã¦ã„ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ "
":func:`classmethod` ã§ç”Ÿæˆã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1077
msgid "Special method names"
msgstr "ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰å"

#: ../../reference/datamodel.rst:1083
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named "
":meth:`__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` "
"is roughly equivalent to ``type(x).__getitem__(x, i)``.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or "
":exc:`TypeError`)."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã¯ã€ç‰¹æ®Šãªåå‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã€ç‰¹æ®Šãªæ§‹æ–‡ (ç®—è¡“æ¼”ç®—ã‚„æ·»ãˆå­—è¡¨è¨˜ã€ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ãªã©) ã«ã‚ˆã‚‹ç‰¹å®šã®æ¼”ç®—ã‚’å®Ÿè£…ã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€Python "
"ã®æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ­ãƒ¼ãƒ‰ (:dfn:`operator overloading`) "
"ã¸ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¯ãƒ©ã‚¹ã¯è¨€èªã®æ¼”ç®—å­ã«å¯¾ã™ã‚‹ç‹¬è‡ªã®æŒ¯ã‚‹èˆã„ã‚’å®šç¾©ã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚ã‚‹ã‚¯ãƒ©ã‚¹ãŒ :meth:`__getitem__` "
"ã¨ã„ã†åå‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ãŠã‚Šã€ ``x`` ãŒã“ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹ã¨ã™ã‚‹ã¨ã€ ``x[i]`` ã¯ "
"``type(x).__getitem__(x, i)`` "
"ã¨ã»ã¼ç­‰ä¾¡ã§ã™ã€‚ç‰¹ã«æ³¨é‡ˆã®ãªã„é™ã‚Šã€é©åˆ‡ãªãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„ã¨ãã€ã“ã®ã‚ˆã†ãªæ¼”ç®—ã‚’è©¦ã¿ã‚‹ã¨ä¾‹å¤– (ãŸã„ã¦ã„ã¯ "
":exc:`AttributeError` ã‹ :exc:`TypeError`) ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1093
msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets :meth:`__iter__` "
"to ``None``, the class is not iterable, so calling :func:`iter` on its "
"instances will raise a :exc:`TypeError` (without falling back to "
":meth:`__getitem__`). [#]_"
msgstr ""
"ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã« ``None`` ã‚’è¨­å®šã™ã‚‹ã“ã¨ã¯ã€ãã‚Œã«å¯¾å¿œã™ã‚‹æ¼”ç®—ãŒåˆ©ç”¨ã§ããªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚\n"
"ä¾‹ãˆã°ã€ã‚¯ãƒ©ã‚¹ã® :meth:`__iter__` ã‚’ ``None`` ã«è¨­å®šã—ãŸå ´åˆã€ãã®ã‚¯ãƒ©ã‚¹ã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã«ã¯ãªã‚‰ãšã€ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã— :func:`iter` ã‚’å‘¼ã³å‡ºã™ã¨ (:meth:`__getitem__` ã«å‡¦ç†ãŒæˆ»ã•ã‚Œãšã«) :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚ [#]_"

#: ../../reference/datamodel.rst:1099
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for"
" the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make sense."
"  (One example of this is the :class:`~xml.dom.NodeList` interface in the "
"W3C's Document Object Model.)"
msgstr ""
"çµ„ã¿è¾¼ã¿å‹ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã‚¯ãƒ©ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ã¨ãã¯ã€æ¨¡ç¯„ã¨ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¨ã£ã¦æ„å‘³ãŒã‚ã‚‹ç¯„å›²ã«å®Ÿè£…ã‚’ã¨ã©ã‚ã‚‹ã®ãŒé‡è¦ã§ã™ã€‚ä¾‹ãˆã°ã€ã‚ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯å€‹ã€…ã®è¦ç´ ã®å–å¾—ã¯ãã¡ã‚“ã¨å‹•ãã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ã‚¹ãƒ©ã‚¤ã‚¹ã®å±•é–‹ãŒæ„å‘³ã‚’ãªã•ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"
" (W3C ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ¢ãƒ‡ãƒ«ã«ã‚ã‚‹ :class:`~xml.dom.NodeList` ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒãã®ä¸€ä¾‹ã§ã™ã€‚)"

#: ../../reference/datamodel.rst:1110
msgid "Basic customization"
msgstr "åŸºæœ¬çš„ãªã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º"

#: ../../reference/datamodel.rst:1116
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static"
" method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""
"ã‚¯ãƒ©ã‚¹ *cls* ã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ :meth:`__new__` ã¯é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã§ "
"(ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ç‰¹åˆ¥æ‰±ã„ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€æ˜ç¤ºçš„ã«é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã¨å®£è¨€ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“)ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ã‚ˆã†è¦æ±‚ã•ã‚Œã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã‚’ç¬¬ä¸€å¼•æ•°ã«ã¨ã‚Šã¾ã™ã€‚æ®‹ã‚Šã®å¼•æ•°ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å¼"
" (ã‚¯ãƒ©ã‚¹ã®å‘¼ã³å‡ºã—æ–‡) ã«æ¸¡ã•ã‚Œã¾ã™ã€‚ :meth:`__new__` ã®æˆ»ã‚Šå€¤ã¯æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ (é€šå¸¸ã¯ *cls* "
"ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹) ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1123
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super().__new__(cls[, ...])`` "
"with appropriate arguments and then modifying the newly-created instance as "
"necessary before returning it."
msgstr ""
"å…¸å‹çš„ãªå®Ÿè£…ã§ã¯ã€ã‚¯ãƒ©ã‚¹ã®æ–°ãŸãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ã¨ãã«ã¯ ``super().__new__(cls[, ...])`` "
"ã«é©åˆ‡ãªå¼•æ•°ã‚’æŒ‡å®šã—ã¦ã‚¹ãƒ¼ãƒ‘ã‚¯ãƒ©ã‚¹ã® :meth:`__new__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã€æ–°ãŸã«ç”Ÿæˆã•ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¿…è¦ãªå¤‰æ›´ã‚’åŠ ãˆã¦ã‹ã‚‰è¿”ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1128
msgid ""
"If :meth:`__new__` returns an instance of *cls*, then the new instance's "
":meth:`__init__` method will be invoked like ``__init__(self[, ...])``, "
"where *self* is the new instance and the remaining arguments are the same as"
" were passed to :meth:`__new__`."
msgstr ""
":meth:`__new__` ãŒ *cls* ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ãŸå ´åˆã€ ``__init__(self[, ...])`` "
"ã®ã‚ˆã†ã«ã—ã¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® :meth:`__init__` ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®ã¨ãã€ *self* ã¯æ–°ãŸã«ç”Ÿæˆã•ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã€æ®‹ã‚Šã®å¼•æ•°ã¯"
" :meth:`__new__` ã«æ¸¡ã•ã‚ŒãŸå¼•æ•°ã¨åŒã˜ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1133
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
":meth:`__new__` ãŒ *cls* ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã•ãªã„å ´åˆã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® :meth:`__init__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯å‘¼ã³å‡ºã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1136
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` ã®ä¸»ãªç›®çš„ã¯ã€å¤‰æ›´ä¸èƒ½ãªå‹ (int, str, tuple ãªã©) "
"ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã“ã¨ã«ã‚ã‚Šã¾ã™ã€‚ã¾ãŸã€ã‚¯ãƒ©ã‚¹ç”Ÿæˆã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ãŸã‚ã«ã€ã‚«ã‚¹ã‚¿ãƒ ã®ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã§ã‚ˆãã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1145
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the"
" derived class's :meth:`__init__` method, if any, must explicitly call it to"
" ensure proper initialization of the base class part of the instance; for "
"example: ``super().__init__([args...])``."
msgstr ""
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ (:meth:`__new__` ã«ã‚ˆã£ã¦) "
"ç”Ÿæˆã•ã‚ŒãŸå¾Œã€ãã‚ŒãŒå‘¼ã³å‡ºã—å…ƒã«è¿”ã•ã‚Œã‚‹å‰ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚å¼•æ•°ã¯ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å¼ã«æ¸¡ã—ãŸã‚‚ã®ã§ã™ã€‚åŸºåº•ã‚¯ãƒ©ã‚¹ã¨ãã®æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ãŒã¨ã‚‚ã« "
":meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤å ´åˆã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã® :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯åŸºåº•ã‚¯ãƒ©ã‚¹ã® "
":meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ˜ç¤ºçš„ã«å‘¼ã³å‡ºã—ã¦ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®åŸºåº•ã‚¯ãƒ©ã‚¹éƒ¨åˆ†ãŒé©åˆ‡ã«åˆæœŸåŒ–ã•ã‚Œã‚‹ã“ã¨ä¿è¨¼ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ "
"``super().__init__([args...])`` ã€‚"

#: ../../reference/datamodel.rst:1152
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customize "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""
":meth:`__new__` ã¨ :meth:`__init__` ã¯é€£æºã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹æˆã™ã‚‹ (:meth:`__new__` ãŒä½œæˆã—ã€ "
":meth:`__init__` ãŒãã‚Œã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹) ã®ã§ã€ :meth:`__init__` ã‹ã‚‰é ``None`` "
"å€¤ã‚’è¿”ã—ã¦ã¯ã„ã‘ã¾ã›ã‚“; ãã†ã—ã¦ã—ã¾ã†ã¨ã€å®Ÿè¡Œæ™‚ã« :exc:`TypeError` ãŒé€å‡ºã•ã‚Œã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1165
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"finalizer or (improperly) a destructor.  If a base class has a "
":meth:`__del__` method, the derived class's :meth:`__del__` method, if any, "
"must explicitly call it to ensure proper deletion of the base class part of "
"the instance."
msgstr ""
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒç ´æ£„ã•ã‚Œã‚‹ã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
"ã“ã‚Œã¯ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ã‚„ (é©åˆ‡ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒ) ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚\n"
"åŸºåº•ã‚¯ãƒ©ã‚¹ãŒ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã¯ã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã® :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä½•ã§ã‚ã‚Œã€åŸºåº•ã‚¯ãƒ©ã‚¹ã® :meth:`__del__`  ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ˜ç¤ºçš„ã«å‘¼ã³å‡ºã—ã¦ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®åŸºåº•ã‚¯ãƒ©ã‚¹éƒ¨åˆ†ã‚’ãã¡ã‚“ã¨ç¢ºå®Ÿã«å‰Šé™¤ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1171
msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  "
"This is called object *resurrection*.  It is implementation-dependent "
"whether :meth:`__del__` is called a second time when a resurrected object is"
" about to be destroyed; the current :term:`CPython` implementation only "
"calls it once."
msgstr ""
":meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒç ´æ£„ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ã®æ–°ã—ã„å‚ç…§ã‚’ä½œã‚Šã€ç ´æ£„ã‚’é€ã‚‰ã›ã‚‹ã“ã¨ã¯ (æ¨å¥¨ã•ã‚Œãªã„ã‚‚ã®ã®) å¯èƒ½ã§ã™ã€‚\n"
"ã“ã‚Œã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® *å¾©æ´»* ã¨å‘¼ã°ã‚Œã¾ã™ã€‚\n"
"å¾©æ´»ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå†åº¦ç ´æ£„ã•ã‚Œã‚‹ç›´å‰ã« :meth:`__del__` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã‹ã©ã†ã‹ã¯å®Ÿè£…ä¾å­˜ã§ã™;\n"
"ç¾åœ¨ã® :term:`CPython` ã®å®Ÿè£…ã§ã¯æœ€åˆã®ä¸€å›ã—ã‹å‘¼ã³å‡ºã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1178
msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits."
msgstr "ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒçµ‚äº†ã—ãŸã¨ãã«ã€æ®‹å­˜ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ä¿è¨¼ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1183
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero."
msgstr ""
"``del x`` ã¯ç›´æ¥ ``x.__del__()`` ã‚’å‘¼ã³å‡ºã—ã¾ã›ã‚“ --- å‰è€…ã¯ ``x`` ã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ 1 ã¤æ¸›ã‚‰ã—ã€å¾Œè€…ã¯ "
"``x`` ã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒ 0 ã¾ã§è½ã¡ãŸã¨ãã®ã¿å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1198
msgid "Documentation for the :mod:`gc` module."
msgstr ":mod:`gc` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€‚"

#: ../../reference/datamodel.rst:1202
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""

#: ../../reference/datamodel.rst:1206
msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the resource "
"may already be taken by the code that gets interrupted to execute "
":meth:`__del__`."
msgstr ""

#: ../../reference/datamodel.rst:1212
msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python guarantees"
" that globals whose name begins with a single underscore are deleted from "
"their module before other globals are deleted; if no other references to "
"such globals exist, this may help in assuring that imported modules are "
"still available at the time when the :meth:`__del__` method is called."
msgstr ""

#: ../../reference/datamodel.rst:1227
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look "
"like a valid Python expression that could be used to recreate an object with"
" the same value (given an appropriate environment).  If this is not "
"possible, a string of the form ``<...some useful description...>`` should be"
" returned. The return value must be a string object. If a class defines "
":meth:`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used"
" when an \"informal\" string representation of instances of that class is "
"required."
msgstr ""
":func:`repr` çµ„ã¿è¾¼ã¿é–¢æ•°ã«ã‚ˆã£ã¦å‘¼ã³å‡ºã•ã‚Œã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã™ã€Œå…¬å¼ã® (official)ã€æ–‡å­—åˆ—ã‚’è¨ˆç®—ã—ã¾ã™ã€‚å¯èƒ½ãªã‚‰ã€ã“ã‚Œã¯ "
"(é©åˆ‡ãªç’°å¢ƒãŒä¸ãˆã‚‰ã‚Œã‚Œã°) åŒã˜å€¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†ç”Ÿæˆã™ã‚‹ã®ã«ä½¿ãˆã‚‹ã€æœ‰åŠ¹ãª Python å¼ã®ã‚ˆã†ãªã‚‚ã®ã§ã‚ã‚‹ã¹ãã§ã™ã€‚ã§ããªã„ãªã‚‰ã€ "
"``<...some useful description...>`` "
"å½¢å¼ã®æ–‡å­—åˆ—ãŒè¿”ã•ã‚Œã‚‹ã¹ãã§ã™ã€‚æˆ»ã‚Šå€¤ã¯æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¹ãŒ :meth:`__repr__` ã‚’å®šç¾©ã—ã¦ã„ã¦ "
":meth:`__str__` ã¯å®šç¾©ã—ã¦ã„ãªã‘ã‚Œã°ã€ãã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã€Œéå…¬å¼ã® (informal)ã€æ–‡å­—åˆ—è¡¨ç¾ãŒè¦æ±‚ã•ã‚ŒãŸã¨ãã«ã‚‚ "
":meth:`__repr__` ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1236
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr "ã“ã®é–¢æ•°ã¯ãƒ‡ãƒãƒƒã‚°ã®éš›ã«ã‚ˆãç”¨ã„ã‚‰ã‚Œã‚‹ã®ã§ã€ãŸãã•ã‚“ã®æƒ…å ±ã‚’å«ã¿ã€ã‚ã„ã¾ã„ã§ãªã„ã‚ˆã†ãªè¡¨è¨˜ã«ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1247
msgid ""
"Called by :func:`str(object) <str>` and the built-in functions "
":func:`format` and :func:`print` to compute the \"informal\" or nicely "
"printable string representation of an object.  The return value must be a "
":ref:`string <textseq>` object."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã€Œéå…¬å¼ã® (informal)ã€ã‚ã‚‹ã„ã¯è¡¨ç¤ºã«é©ã—ãŸæ–‡å­—åˆ—è¡¨ç¾ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«ã€ :func:`str(object) <str>` "
"ã¨çµ„ã¿è¾¼ã¿é–¢æ•° :func:`format`, :func:`print` ã«ã‚ˆã£ã¦å‘¼ã°ã‚Œã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ :ref:`string <textseq>`"
" ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1252
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more "
"convenient or concise representation can be used."
msgstr ""
":meth:`__str__` ãŒæœ‰åŠ¹ãª Python è¡¨ç¾ã‚’è¿”ã™ã“ã¨ãŒæœŸå¾…ã•ã‚Œãªã„ã¨ã„ã†ç‚¹ã§ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ "
":meth:`object.__repr__` ã¨ã¯ç•°ãªã‚Šã¾ã™: ã‚ˆã‚Šä¾¿åˆ©ãªã€ã¾ãŸã¯ç°¡æ½”ãªè¡¨ç¾ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1256
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""
"çµ„ã¿è¾¼ã¿å‹ :class:`object` ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚ŒãŸãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã¯ã€ :meth:`object.__repr__` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1266
msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string representation "
"of an object. This should return a :class:`bytes` object."
msgstr ""
":ref:`bytes <func-bytes>` ã«ã‚ˆã£ã¦å‘¼ã³å‡ºã•ã‚Œã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒã‚¤ãƒˆæ–‡å­—åˆ—è¡¨ç¾ã‚’è¨ˆç®—ã—ã¾ã™ã€‚ã“ã‚Œã¯ :class:`bytes`"
" ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã¹ãã§ã™ã€‚"

#: ../../reference/datamodel.rst:1277
msgid ""
"Called by the :func:`format` built-in function, and by extension, evaluation"
" of :ref:`formatted string literals <f-strings>` and the :meth:`str.format` "
"method, to produce a \"formatted\" string representation of an object. The "
"``format_spec`` argument is a string that contains a description of the "
"formatting options desired. The interpretation of the ``format_spec`` "
"argument is up to the type implementing :meth:`__format__`, however most "
"classes will either delegate formatting to one of the built-in types, or use"
" a similar formatting option syntax."
msgstr ""
":func:`format` çµ„ã¿è¾¼ã¿é–¢æ•°ã€ã•ã‚‰ã«ã¯ :ref:`ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¸ˆã¿æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ« <f-strings>` ã®è©•ä¾¡ã€ "
":meth:`str.format` ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦å‘¼ã³å‡ºã•ã‚Œã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® \"ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆåŒ–ã•ã‚ŒãŸ (formatted)\" "
"æ–‡å­—åˆ—è¡¨ç¾ã‚’ä½œã‚Šã¾ã™ã€‚ ``format_spec`` å¼•æ•°ã¯ã€ å¿…è¦ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆåŒ–ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®è¨˜è¿°ã‚’å«ã‚€æ–‡å­—åˆ—ã§ã™ã€‚ ``format_spec``"
" å¼•æ•°ã®è§£é‡ˆã¯ã€ :meth:`__format__` ã‚’å®Ÿè£…ã™ã‚‹å‹ã«ã‚ˆã‚Šã¾ã™ãŒã€ ã»ã¨ã‚“ã©ã®ã‚¯ãƒ©ã‚¹ã¯çµ„ã¿è¾¼ã¿å‹ã®ã„ãšã‚Œã‹ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆåŒ–ã‚’å§”è­²ã—ãŸã‚Šã€"
" åŒã˜ã‚ˆã†ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆåŒ–ã‚ªãƒ—ã‚·ãƒ§ãƒ³æ§‹æ–‡ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1287
msgid ""
"See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr "æ¨™æº–ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ§‹æ–‡ã®è§£èª¬ã¯ã€ :ref:`formatspec` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1289
msgid "The return value must be a string object."
msgstr "æˆ»ã‚Šå€¤ã¯æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1291
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""
"ç©ºã§ãªã„æ–‡å­—åˆ—ãŒæ¸¡ã•ã‚ŒãŸå ´åˆ ``object`` è‡ªèº«ã® __format__ ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1307
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls "
"``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls "
"``x.__eq__(y)``, ``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls "
"``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr ""
"ã“ã‚Œã‚‰ã¯ã„ã‚ã‚†ã‚‹ \"æ‹¡å¼µæ¯”è¼ƒ (rich comparison)\" ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚æ¼”ç®—å­ã‚·ãƒ³ãƒœãƒ«ã¨ãƒ¡ã‚½ãƒƒãƒ‰åã®å¯¾å¿œã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™: ``x<y``"
" ã¯ ``x.__lt__(y)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™; ``x<=y`` ã¯ ``x.__le__(y)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™; ``x==y`` ã¯ "
"``x.__eq__(y)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™; ``x!=y`` ã¯ ``x.__ne__(y)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™; ``x>y`` ã¯ "
"``x.__gt__(y)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™; ``x>=y`` ã¯ ``x.__ge__(y)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1313
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if it "
"does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison."
" However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""
"æ‹¡å¼µæ¯”è¼ƒãƒ¡ã‚½ãƒƒãƒ‰ã¯ä¸ãˆã‚‰ã‚ŒãŸå¼•æ•°ã®ãƒšã‚¢ã«å¯¾ã™ã‚‹æ¼”ç®—ã‚’å®Ÿè£…ã—ã¦ã„ãªã„ã¨ãã«ã€ ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ ``NotImplemented`` ã‚’è¿”ã™ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚\n"
"æ…£ä¾‹ã¨ã—ã¦ã€æ­£å¸¸ã«æ¯”è¼ƒãŒè¡Œã‚ã‚ŒãŸã¨ãã«ã¯ ``False`` ã‹ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚\n"
"ã—ã‹ã—ã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä»»æ„ã®å€¤ã‚’è¿”ã™ã“ã¨ãŒã§ãã‚‹ã®ã§ã€æ¯”è¼ƒæ¼”ç®—å­ãŒãƒ–ãƒ¼ãƒ«å€¤ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ (ãŸã¨ãˆã° ``if`` æ–‡ã®æ¡ä»¶éƒ¨åˆ†) ã§ä½¿ã‚ã‚ŒãŸå ´åˆã€ Python ã¯ãã®å€¤ã«å¯¾ã—ã¦ :func:`bool` ã‚’å‘¼ã³å‡ºã—ã¦çµæœã®çœŸå½ã‚’åˆ¤æ–­ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1320
msgid ""
"By default, :meth:`__ne__` delegates to :meth:`__eq__` and inverts the "
"result unless it is ``NotImplemented``.  There are no other implied "
"relationships among the comparison operators, for example, the truth of "
"``(x<y or x==y)`` does not imply ``x<=y``. To automatically generate "
"ordering operations from a single root operation, see "
":func:`functools.total_ordering`."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ :meth:`__ne__` ã¯ ``NotImplemented`` ã§ãªã„é™ã‚Š :meth:`__eq__` "
"ã«å§”è­²ã—ã¦çµæœã‚’åè»¢ã•ã›ã¾ã™ã€‚æ¯”è¼ƒæ¼”ç®—ã®é–“ã«ã¯ä»–ã«æš—é»™ã®é–¢ä¿‚ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã° ``(x<y or x==y)`` ãŒçœŸã§ã‚ã‚‹ã“ã¨ã¯æš—é»™çš„ã« "
"``x<=y`` ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å…ƒã¨ãªã‚‹ä¸€ã¤ã®æ¼”ç®—ã‹ã‚‰è‡ªå‹•çš„ã«é †åºã®æ¼”ç®—ã‚’ç”Ÿæˆã™ã‚‹ã«ã¯ "
":func:`functools.total_ordering` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1327
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on creating "
":term:`hashable` objects which support custom comparison operations and are "
"usable as dictionary keys."
msgstr ""
"ã‚«ã‚¹ã‚¿ãƒ ã®æ¯”è¼ƒæ¼”ç®—ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¦ã€è¾æ›¸ã®ã‚­ãƒ¼ã«ä½¿ã†ã“ã¨ãŒã§ãã‚‹ãƒãƒƒã‚·ãƒ¥å¯èƒ½(:term:`hashable`) "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚‹ã¨ãã®é‡è¦ãªæ³¨æ„ç‚¹ã«ã¤ã„ã¦ã€ :meth:`__hash__` ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå†…ã«æ›¸ã‹ã‚Œã¦ã„ã‚‹ã®ã§å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1331
msgid ""
"There are no swapped-argument versions of these methods (to be used when the"
" left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, "
":meth:`__le__` and :meth:`__ge__` are each other's reflection, and "
":meth:`__eq__` and :meth:`__ne__` are their own reflection. If the operands "
"are of different types, and right operand's type is a direct or indirect "
"subclass of the left operand's type, the reflected method of the right "
"operand has priority, otherwise the left operand's method has priority.  "
"Virtual subclassing is not considered."
msgstr ""
"ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯ (å·¦å¼•æ•°ãŒæ¼”ç®—ã‚’ã‚µãƒãƒ¼ãƒˆã—ãªã„ãŒã€å³å¼•æ•°ã¯ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã«ç”¨ã„ã‚‰ã‚Œã‚‹ã‚ˆã†ãª) å¼•æ•°ã‚’å…¥ã‚Œæ›¿ãˆãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚\n"
"ã‚€ã—ã‚ã€ :meth:`__lt__` ã¨ :meth:`__gt__` ã¯äº’ã„ã®åå°„ã€ :meth:`__le__` ã¨ :meth:`__ge__` ã¯äº’ã„ã®åå°„ã€ãŠã‚ˆã³ :meth:`__eq__` ã¨ :meth:`__ne__` ã¯ãã‚Œã‚‰è‡ªèº«ã®åå°„ã§ã™ã€‚\n"
"è¢«æ¼”ç®—å­ãŒç•°ãªã‚‹å‹ã§å³ã®è¢«æ¼”ç®—å­ã®å‹ãŒå·¦ã®è¢«æ¼”ç®—å­ã®ç›´æ¥çš„ã¾ãŸã¯é–“æ¥çš„ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®å ´åˆã€å³è¢«æ¼”ç®—å­ã®åå°„ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ãŒå„ªå…ˆã•ã‚Œã¾ã™ã€‚\n"
"ãã†ã§ãªã„å ´åˆå·¦ã®è¢«æ¼”ç®—å­ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå„ªå…ˆã•ã‚Œã¾ã™ã€‚\n"
"ä»®æƒ³ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã¯è€ƒæ…®ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1348
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and "
":class:`dict`.  :meth:`__hash__` should return an integer. The only required"
" property is that objects which compare equal have the same hash value; it "
"is advised to mix together the hash values of the components of the object "
"that also play a part in comparison of objects by packing them into a tuple "
"and hashing the tuple. Example::"
msgstr ""
"çµ„ã¿è¾¼ã¿ã® :func:`hash` é–¢æ•°ã‚„ã€ :class:`set`, :class:`frozenset`, :class:`dict` ã®ã‚ˆã†ãªãƒãƒƒã‚·ãƒ¥ã‚’ä½¿ã£ãŸã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹ã®è¦ç´ ã«å¯¾ã™ã‚‹æ“ä½œã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
":meth:`__hash__` ã¯æ•´æ•°ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«å¿…è¦ãªæ€§è³ªã¯ã€æ¯”è¼ƒçµæœãŒç­‰ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯åŒã˜ãƒãƒƒã‚·ãƒ¥å€¤ã‚’æŒã¤ã¨ã„ã†ã“ã¨ã§ã™;\n"
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¯”è¼ƒã™ã‚‹ã¨ãã§ã‚‚åˆ©ç”¨ã•ã‚Œã‚‹è¦ç´ ã‚’ã‚¿ãƒ—ãƒ«ã«è©°ã‚ã¦ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ã§ã€ãã‚Œãã‚Œã®è¦ç´ ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’æ··åˆã™ã‚‹ã“ã¨ã‚’ãŠã™ã™ã‚ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1361
msgid ""
":func:`hash` truncates the value returned from an object's custom "
":meth:`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is "
"typically 8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an "
"object's   :meth:`__hash__` must interoperate on builds of different bit "
"sizes, be sure to check the width on all supported builds.  An easy way to "
"do this is with ``python -c \"import sys; print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç‹¬è‡ªã® :meth:`__hash__`  ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿”ã™å€¤ã‚’ :c:type:`Py_ssize_t` ã®ã‚µã‚¤ã‚ºã«åˆ‡ã‚Šè©°ã‚ã¾ã™ã€‚\n"
"ã“ã‚Œã¯ 64-bit ã§ãƒ“ãƒ«ãƒ‰ã•ã‚Œã¦ã„ã‚‹ã¨ 8 ãƒã‚¤ãƒˆã§ã€ 32-bit ã§ãƒ“ãƒ«ãƒ‰ã•ã‚Œã¦ã„ã‚‹ã¨ 4 ãƒã‚¤ãƒˆã§ã™ã€‚\n"
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`__hash__` ãŒç•°ãªã‚‹ bit ã‚µã‚¤ã‚ºã®ãƒ“ãƒ«ãƒ‰ã§ã‚‚å¯æ¬æ€§ãŒå¿…è¦ã§ã‚ã‚‹å ´åˆã¯ã€å¿…ãšå…¨ã¦ã®ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãƒ“ãƒ«ãƒ‰ã® bit å¹…ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚\n"
"ãã†ã™ã‚‹ç°¡å˜ãªæ–¹æ³•ã¯ ``python -c \"import sys; print(sys.hash_info.width)\"`` ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1369
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define a "
":meth:`__hash__` operation either; if it defines :meth:`__eq__` but not "
":meth:`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an "
":meth:`__eq__` method, it should not implement :meth:`__hash__`, since the "
"implementation of hashable collections requires that a key's hash value is "
"immutable (if the object's hash value changes, it will be in the wrong hash "
"bucket)."
msgstr ""
"ã‚¯ãƒ©ã‚¹ãŒ :meth:`__eq__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ãªã„ãªã‚‰ã€ :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚å®šç¾©ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“; ã‚¯ãƒ©ã‚¹ãŒ "
":meth:`__eq__` ã‚’å®šç¾©ã—ã¦ã„ã¦ã‚‚ :meth:`__hash__` "
"ã‚’å®šç¾©ã—ã¦ã„ãªã„ãªã‚‰ã€ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ãƒãƒƒã‚·ãƒ¥å¯èƒ½ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®è¦ç´ ã¨ã—ã¦ä½¿ãˆã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¹ãŒãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®šç¾©ã—ã¦ãŠã‚Šã€ "
":meth:`__eq__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ãªã‚‰ã€ :meth:`__hash__` "
"ã‚’å®šç¾©ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€ãƒãƒƒã‚·ãƒ¥å¯èƒ½ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®å®Ÿè£…ã«ãŠã„ã¦ã‚­ãƒ¼ã®ãƒãƒƒã‚·ãƒ¥å€¤ãŒã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã§ã‚ã‚‹ã“ã¨ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã§ã™ "
"(ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒƒã‚·ãƒ¥å€¤ãŒå¤‰åŒ–ã™ã‚‹ã¨ã€èª¤ã£ãŸãƒãƒƒã‚·ãƒ¥ãƒã‚±ãƒ„: hash bucket ã«å…¥ã£ã¦ã—ã¾ã„ã¾ã™)ã€‚"

#: ../../reference/datamodel.rst:1378
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) and"
" ``x.__hash__()`` returns an appropriate value such that ``x == y`` implies "
"both that ``x is y`` and ``hash(x) == hash(y)``."
msgstr ""
"ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ã‚¯ãƒ©ã‚¹ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ :meth:`__eq__` ã¨ :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ ã“ã®ã¨ãã€(åŒä¸€ã§ãªã„)"
" ã™ã¹ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ¯”è¼ƒã—ã¦ç•°ãªã‚Šã€ ``x.__hash__()`` ã¯ ``x == y`` ãŒ ``x is y`` ã¨ ``hash(x) "
"== hash(y)`` ã®ä¸¡æ–¹ã‚’æ„å‘³ã™ã‚‹ã‚ˆã†ãªé©åˆ‡ãªå€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1383
msgid ""
"A class that overrides :meth:`__eq__` and does not define :meth:`__hash__` "
"will have its :meth:`__hash__` implicitly set to ``None``.  When the "
":meth:`__hash__` method of a class is ``None``, instances of the class will "
"raise an appropriate :exc:`TypeError` when a program attempts to retrieve "
"their hash value, and will also be correctly identified as unhashable when "
"checking ``isinstance(obj, collections.Hashable)``."
msgstr ""
":meth:`__eq__` ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¦ã„ã¦ :meth:`__hash__` ã‚’å®šç¾©ã—ã¦ã„ãªã„ã‚¯ãƒ©ã‚¹ã§ã¯ã€ :meth:`__hash__` ã¯æš—é»™çš„ã« ``None`` ã«è¨­å®šã•ã‚Œã¾ã™ã€‚\n"
"ã‚¯ãƒ©ã‚¹ã® :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒ ``None`` ã®å ´åˆã€ãã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’å–å¾—ã—ã‚ˆã†ã¨ã™ã‚‹ã¨é©åˆ‡ãª :exc:`TypeError` ãŒé€å‡ºã•ã‚Œã€ ``isinstance(obj, collections.Hashable)`` ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã¨ãƒãƒƒã‚·ãƒ¥ä¸èƒ½ãªã‚‚ã®ã¨ã—ã¦æ­£ã—ãèªè­˜ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1390
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the implementation "
"of :meth:`__hash__` from a parent class, the interpreter must be told this "
"explicitly by setting ``__hash__ = <ParentClass>.__hash__``."
msgstr ""
":meth:`__eq__` ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ãŸã‚¯ãƒ©ã‚¹ãŒè¦ªã‚¯ãƒ©ã‚¹ã‹ã‚‰ã® :meth:`__hash__` ã® å®Ÿè£…ã‚’ä¿æŒã—ãŸã„ãªã‚‰ã€æ˜ç¤ºçš„ã« "
"``__hash__ = <ParentClass>.__hash__`` ã‚’è¨­å®šã™ã‚‹ã“ã¨ã§ã€ãã‚Œã‚’ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ä¼ãˆãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1394
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A "
"class which defines its own :meth:`__hash__` that explicitly raises a "
":exc:`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.Hashable)`` call."
msgstr ""
":meth:`__eq__` ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¦ã„ãªã„ã‚¯ãƒ©ã‚¹ãŒãƒãƒƒã‚·ãƒ¥ã‚µãƒãƒ¼ãƒˆã‚’æŠ‘åˆ¶ã—ãŸã„å ´åˆã€ã‚¯ãƒ©ã‚¹å®šç¾©ã« ``__hash__ = None`` "
"ã‚’å«ã‚ã¦ãã ã•ã„ã€‚ã‚¯ãƒ©ã‚¹è‡ªèº«ã§æ˜ç¤ºçš„ã« :exc:`TypeError` ã‚’é€å‡ºã™ã‚‹ :meth:`__hash__` ã‚’å®šç¾©ã™ã‚‹ã¨ã€ "
"``isinstance(obj, collections.Hashable)`` å‘¼ã³å‡ºã—ã§èª¤ã£ã¦ãƒãƒƒã‚·ãƒ¥å¯èƒ½ã¨è­˜åˆ¥ã•ã‚Œã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../reference/datamodel.rst:1403
msgid ""
"By default, the :meth:`__hash__` values of str, bytes and datetime objects "
"are \"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€æ–‡å­—åˆ—ã€ãƒã‚¤ãƒˆåˆ—ã€datetime ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`__hash__` å€¤ã¯äºˆæ¸¬ä¸å¯èƒ½ãªãƒ©ãƒ³ãƒ€ãƒ å€¤ã§ \"å¡©æ¼¬ã‘\" "
"ã•ã‚Œã¾ã™ã€‚ ãƒãƒƒã‚·ãƒ¥å€¤ã¯å˜ç‹¬ã® Python ãƒ—ãƒ­ã‚»ã‚¹å†…ã§ã¯å®šæ•°ã§ã‚ã‚Šç¶šã‘ã¾ã™ãŒã€Python ã‚’ç¹°ã‚Šè¿”ã—èµ·å‹•ã™ã‚‹æ¯ã«ã€äºˆæ¸¬ã§ããªããªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1408
msgid ""
"This is intended to provide protection against a denial-of-service caused by"
" carefully-chosen inputs that exploit the worst case performance of a dict "
"insertion, O(n^2) complexity.  See "
"http://www.ocert.org/advisories/ocert-2011-003.html for details."
msgstr ""
"ã“ã®ç›®çš„ã¯ã€æ…é‡ã«é¸ã°ã‚ŒãŸå…¥åŠ›ã§è¾æ›¸æŒ¿å…¥ã®æœ€æ‚ªæ€§èƒ½ O(n^2) è¨ˆç®—é‡ã‚’æ‚ªç”¨ã™ã‚‹ã“ã¨ã§å¼•ãèµ·ã“ã•ã‚Œã‚‹ã‚µãƒ¼ãƒ“ã‚¹å¦¨å®³ (denial-of-service, DoS) ã«å¯¾ã™ã‚‹ä¿è­·ã§ã™ã€‚\n"
"è©³ç´°ã¯ http://www.ocert.org/advisories/ocert-2011-003.html ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1413
msgid ""
"Changing hash values affects the iteration order of dicts, sets and other "
"mappings.  Python has never made guarantees about this ordering (and it "
"typically varies between 32-bit and 64-bit builds)."
msgstr ""
"ãƒãƒƒã‚·ãƒ¥å€¤ã®å¤‰æ›´ã¯ã€è¾æ›¸ã€é›†åˆã€ãã®ä»–ã®ãƒãƒƒãƒ—å‹ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é †åºã«å½±éŸ¿ã—ã¾ã™ã€‚Python ã¯ã“ã®é †åºä»˜ã‘ã‚’ä¿è¨¼ã—ã¦ã„ã¾ã›ã‚“ (ãã—ã¦é€šå¸¸ "
"32-bit ã¨ 64-bit ã®é–“ã§ã‚‚ç•°ãªã‚Šã¾ã™)ã€‚"

#: ../../reference/datamodel.rst:1417
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr ":envvar:`PYTHONHASHSEED` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1419
msgid "Hash randomization is enabled by default."
msgstr "ãƒãƒƒã‚·ãƒ¥ã®ãƒ©ãƒ³ãƒ€ãƒ åŒ–ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æœ‰åŠ¹ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../reference/datamodel.rst:1427
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not "
"defined, :meth:`__len__` is called, if it is defined, and the object is "
"considered true if its result is nonzero.  If a class defines neither "
":meth:`__len__` nor :meth:`__bool__`, all its instances are considered true."
msgstr ""
"çœŸç†å€¤ãƒ†ã‚¹ãƒˆã‚„çµ„ã¿è¾¼ã¿æ¼”ç®— ``bool()`` ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™; ``False`` ã¾ãŸã¯ ``True`` "
"ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„ã¨ãã€ :meth:`__len__` ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚Œã°å‘¼ã³å‡ºã•ã‚Œã€ãã®çµæœãŒé 0 "
"ã§ã‚ã‚Œã°çœŸã¨ã¿ãªã•ã‚Œã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ãŒ :meth:`__len__` ã‚‚ :meth:`__bool__` "
"ã‚‚å®šç¾©ã—ã¦ã„ãªã„ã‘ã‚Œã°ã€ãã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã™ã¹ã¦çœŸã¨ã¿ãªã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1438
msgid "Customizing attribute access"
msgstr "å±æ€§å€¤ã‚¢ã‚¯ã‚»ã‚¹ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹"

#: ../../reference/datamodel.rst:1440
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""
"ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ã®å±æ€§å€¤ã‚¢ã‚¯ã‚»ã‚¹ ( å±æ€§å€¤ã®ä½¿ç”¨ã€å±æ€§å€¤ã¸ã®ä»£å…¥ã€ ``x.name`` ã®å‰Šé™¤) "
"ã®æ„å‘³ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1448
msgid ""
"Called when the default attribute access fails with an :exc:`AttributeError`"
" (either :meth:`__getattribute__` raises an :exc:`AttributeError` because "
"*name* is not an instance attribute or an attribute in the class tree for "
"``self``; or :meth:`__get__` of a *name* property raises "
":exc:`AttributeError`).  This method should either return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception."
msgstr ""

#: ../../reference/datamodel.rst:1455
msgid ""
"Note that if the attribute is found through the normal mechanism, "
":meth:`__getattr__` is not called.  (This is an intentional asymmetry "
"between :meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can fake total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control over attribute access."
msgstr ""
"ãªãŠã€é€šå¸¸ã®éç¨‹ã§å±æ€§ãŒè¦‹ã¤ã‹ã‚Œã°ã€ :meth:`__getattr__` ã¯å‘¼ã³å‡ºã•ã‚Œã¾ã›ã‚“ã€‚(ã“ã‚Œã¯ã€ :meth:`__getattr__`  "
"ã¨ :meth:`__setattr__` ãŒæ„å›³çš„ã«éå¯¾ç§°ã«ã•ã‚Œã¦ã„ã‚‹ç‚¹ã§ã™ã€‚) ã“ã‚Œã¯ã€åŠ¹ç‡ã®ãŸã‚ã¨ã€ã“ã†ã—ãªã„ã¨ "
":meth:`__getattr__` "
"ãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä»–ã®å±æ€§å€¤ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ–¹æ³•ãŒãªããªã‚‹ãŸã‚ã§ã™ã€‚ã¾ãŸã€å°‘ãªãã¨ã‚‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã«å¯¾ã—ã¦ã¯ã€å€¤ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§å€¤è¾æ›¸ã«æŒ¿å…¥ã—ãªã„ã“ã¨ã§"
" (ä»£ã‚ã‚Šã«ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æŒ¿å…¥ã™ã‚‹ã“ã¨ã§)ã€å±æ€§å€¤ã‚’å®Œå…¨ã«åˆ¶å¾¡ã—ã¦ã„ã‚‹ãµã‚ŠãŒã§ãã¾ã™ã€‚å®Ÿéš›ã«å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã‚’å®Œå…¨ã«åˆ¶å¾¡ã™ã‚‹æ–¹æ³•ã¯ã€ä»¥ä¸‹ã® "
":meth:`__getattribute__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1468
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be"
" called unless :meth:`__getattribute__` either calls it explicitly or raises"
" an :exc:`AttributeError`. This method should return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception. In order to "
"avoid infinite recursion in this method, its implementation should always "
"call the base class method with the same name to access any attributes it "
"needs, for example, ``object.__getattribute__(self, name)``."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã™ã‚‹å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€ç„¡æ¡ä»¶ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ãŒ :meth:`__getattr__` ã‚‚å®šç¾©ã—ã¦ã„ã‚‹å ´åˆã€"
" :meth:`__getattr__` ã¯ã€ :meth:`__getattribute__` ã§æ˜ç¤ºçš„ã«å‘¼ã³å‡ºã™ã‹ã€ "
":exc:`AttributeError` ä¾‹å¤–ã‚’é€å‡ºã—ãªã„é™ã‚Šå‘¼ã°ã‚Œã¾ã›ã‚“ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ (è¨ˆç®—ã•ã‚ŒãŸ) å±æ€§å€¤ã‚’è¿”ã™ã‹ã€ "
":exc:`AttributeError` "
"ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå†å¸°çš„ã«éš›é™ãªãå‘¼ã³å‡ºã•ã‚Œã¦ã—ã¾ã†ã®ã‚’é˜²ããŸã‚ã€å®Ÿè£…ã®éš›ã«ã¯å¸¸ã«ã€å¿…è¦ãªå±æ€§å…¨ã¦ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã§ã€ä¾‹ãˆã° "
"``object.__getattribute__(self, name)`` "
"ã®ã‚ˆã†ã«åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’åŒã˜å±æ€§åã‚’ä½¿ã£ã¦å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1479
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. See"
" :ref:`special-lookup`."
msgstr ""
"è¨€èªæ§‹æ–‡ã‚„çµ„ã¿è¾¼ã¿é–¢æ•°ã‹ã‚‰æš—é»™ã«å‘¼ã³å‡ºã•ã‚ŒãŸç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã®æ¤œç´¢ã§ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚å›é¿ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ :ref:`special-lookup`"
" ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1486
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of"
" the normal mechanism (i.e. store the value in the instance dictionary). "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""
"å±æ€§ã®ä»£å…¥ãŒè©¦ã¿ã‚‰ã‚ŒãŸéš›ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯é€šå¸¸ã®ä»£å…¥ã®éç¨‹ (ã™ãªã‚ã¡ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è¾æ›¸ã¸ã®å€¤ã®ä»£å…¥) ã®ä»£ã‚ã‚Šã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚*name* "
"ã¯å±æ€§åã§ã€*value* ã¯ãã®å±æ€§ã«ä»£å…¥ã™ã‚‹å€¤ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1490
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"call the base class method with the same name, for example, "
"``object.__setattr__(self, name, value)``."
msgstr ""
":meth:`__setattr__` "
"ã®ä¸­ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã¸ã®ä»£å…¥ãŒå¿…è¦ãªã‚‰ã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã“ã‚Œã¨åŒã˜åå‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ "
"``object.__setattr__(self, name, value)`` ã¨ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1497
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""
":meth:`__setattr__` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ä»£å…¥ã§ã¯ãªãå€¤ã®å‰Šé™¤ã‚’è¡Œã„ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ã®ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¨ã£ã¦ ``del "
"obj.name`` ãŒæ„å‘³ãŒã‚ã‚‹å ´åˆã ã‘ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1503
msgid ""
"Called when :func:`dir` is called on the object. A sequence must be "
"returned. :func:`dir` converts the returned sequence to a list and sorts it."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã« :func:`dir` ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒè¿”ã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ :func:`dir` "
"ã¯è¿”ã•ã‚ŒãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ãƒªã‚¹ãƒˆã«å¤‰æ›ã—ã€ã‚½ãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1508
msgid "Customizing module attribute access"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å±æ€§å€¤ã‚¢ã‚¯ã‚»ã‚¹ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹"

#: ../../reference/datamodel.rst:1513
msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of a "
"module object to a subclass of :class:`types.ModuleType`. For example::"
msgstr ""
"ã‚ˆã‚Šç´°ã‹ã„ç²’åº¦ã§ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å‹•ä½œ (å±æ€§ã‚„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®è¨­å®šãªã©) ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã®ãŸã‚ã«ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® ``__class__`` å±æ€§ã« :class:`types.ModuleType` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒè¨­å®šã§ãã¾ã™ã€‚\n"
"ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../reference/datamodel.rst:1531
msgid ""
"Setting module ``__class__`` only affects lookups made using the attribute "
"access syntax -- directly accessing the module globals (whether by code "
"within the module, or via a reference to the module's globals dictionary) is"
" unaffected."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``__class__`` ã‚’è¨­å®šã—ã¦ã‚‚ã€å½±éŸ¿ãŒã‚ã‚‹ã®ã¯å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã®æ§‹æ–‡ãŒä½¿ã‚ã‚Œã‚‹æ¤œç´¢ã ã‘ã§ã™ -- ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® globals "
"ã¸ã®ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã¯ (ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã®ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® globals ã®ã©ã¡ã‚‰ã§ã‚‚) å½±éŸ¿ã‚’å—ã‘ã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1536
msgid "``__class__`` module attribute is now writable."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å±æ€§ ``__class__`` ãŒæ›¸ãè¾¼ã¿å¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../reference/datamodel.rst:1543
msgid "Implementing Descriptors"
msgstr "ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ (descriptor) ã®å®Ÿè£…"

#: ../../reference/datamodel.rst:1545
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the"
" descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property in"
" the owner class' :attr:`~object.__dict__`."
msgstr ""
"ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚¯ãƒ©ã‚¹ (ã„ã‚ã‚†ã‚‹ *ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿(descriptor)* ã‚¯ãƒ©ã‚¹) ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã€ *ã‚ªãƒ¼ãƒŠãƒ¼ (owner)* ã‚¯ãƒ©ã‚¹ã«å­˜åœ¨ã™ã‚‹ã¨ãã«ã®ã¿é©ç”¨ã•ã‚Œã¾ã™ (ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€ã‚ªãƒ¼ãƒŠãƒ¼ã®ã‚¯ãƒ©ã‚¹è¾æ›¸ã‹ã€ãã®è¦ªã®ã„ãšã‚Œã‹ã®ã‚¯ãƒ©ã‚¹è¾æ›¸ã«ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“)ã€‚\n"
"ä»¥ä¸‹ã®ä¾‹ã§ã¯ã€\"å±æ€§\" ã¨ã¯ã€åå‰ãŒã‚ªãƒ¼ãƒŠãƒ¼ã‚¯ãƒ©ã‚¹ã® :attr:`~object.__dict__` ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ (porperty) ã®ã‚­ãƒ¼ã§ã‚ã‚‹ã‚ˆã†ãªå±æ€§ã‚’æŒ‡ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1555
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). *owner* is always "
"the owner class, while *instance* is the instance that the attribute was "
"accessed through, or ``None`` when the attribute is accessed through the "
"*owner*.  This method should return the (computed) attribute value or raise "
"an :exc:`AttributeError` exception."
msgstr ""
"ã‚ªãƒ¼ãƒŠã‚¯ãƒ©ã‚¹ã®å±æ€§ã‚’å–å¾—ã™ã‚‹ (ã‚¯ãƒ©ã‚¹å±æ€§ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹) éš›ã‚„ã€ã‚ªãƒ¼ãƒŠã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ã‚’å–å¾—ã™ã‚‹ (ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹) "
"å ´åˆã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ *owner* ã¯å¸¸ã«ã‚ªãƒ¼ãƒŠã‚¯ãƒ©ã‚¹ã§ã™ã€‚ä¸€æ–¹ã€ *instance* ã¯å±æ€§ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ä»²ä»‹ã™ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹å±æ€§ãŒ "
"*owner* ã‚’ä»‹ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ (è¨ˆç®—ã•ã‚ŒãŸ) å±æ€§å€¤ã‚’è¿”ã™ã‹ã€ "
":exc:`AttributeError` ä¾‹å¤–ã‚’é€å‡ºã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1565
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr "ã‚ªãƒ¼ãƒŠã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ *instance* ä¸Šã®å±æ€§ã‚’æ–°ãŸãªå€¤ *value* ã«è¨­å®šã™ã‚‹éš›ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1571
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr "ã‚ªãƒ¼ãƒŠã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ *instance* ä¸Šã®å±æ€§ã‚’å‰Šé™¤ã™ã‚‹éš›ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1576
msgid ""
"Called at the time the owning class *owner* is created. The descriptor has "
"been assigned to *name*."
msgstr ""

#: ../../reference/datamodel.rst:1582
msgid ""
"The attribute :attr:`__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting this "
"appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given "
"type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods that "
"are implemented in C)."
msgstr ""
":attr:`__objclass__` å±æ€§ã¯ :mod:`inspect` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ˆã£ã¦è§£é‡ˆã•ã‚Œã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå®šç¾©ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚’ç‰¹å®šã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã¾ã™ (ã“ã®å±æ€§ã‚’é©åˆ‡ã«è¨­å®šã—ã¦ãŠãã¨ã€å‹•çš„ãªã‚¯ãƒ©ã‚¹ã®å±æ€§ã‚’å®Ÿè¡Œæ™‚ã«èª¿ã¹ã‚‹åŠ©ã‘ã«ãªã‚Šã¾ã™)ã€‚\n"
"å‘¼ã³å‡ºã•ã‚Œã‚‹å´ã«ã¨ã£ã¦ã¯ã€ã“ã®å±æ€§ã§æŒ‡å®šã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ (ã‚‚ã—ãã¯ãã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹) ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ1ç•ªç›®ã®ä½ç½®å¼•æ•°ã¨ã—ã¦æœŸå¾…ã‚‚ã—ãã¯è¦æ±‚ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒç¤ºã›ã¾ã™ (ä¾‹ãˆã°ã€ CPython ã¯æŸç¸›ã•ã‚Œã¦ã„ãªã„ C ã§å®Ÿè¡Œã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã«ã“ã®å±æ€§ã‚’è¨­å®šã—ã¾ã™)ã€‚"

#: ../../reference/datamodel.rst:1593
msgid "Invoking Descriptors"
msgstr "ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å‘¼ã³å‡ºã—"

#: ../../reference/datamodel.rst:1595
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`__get__`, :meth:`__set__`, and :meth:`__delete__`. If any "
"of those methods are defined for an object, it is said to be a descriptor."
msgstr ""
"ä¸€èˆ¬ã«ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨ã¯ã€ç‰¹æ®Šãª \"æŸç¸›ã«é–¢ã™ã‚‹å‹•ä½œ (binding behaviour)\" "
"ã‚’ã‚‚ã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå±æ€§ã®ã“ã¨ã§ã™ã€‚ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ« (descriptor protocol) ã®ãƒ¡ã‚½ãƒƒãƒ‰: "
":meth:`__get__`, :meth:`__set__`, ãŠã‚ˆã³ :meth:`__delete__` "
"ã‚’ä½¿ã£ã¦ã€å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¦ã„ã‚‹ã‚‚ã®ã§ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ã„ãšã‚Œã‹ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã§ã‚ã‚‹ã¨ã„ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1600
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and"
" continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¾æ›¸ã‹ã‚‰å€¤ã‚’å–ã‚Šå‡ºã—ãŸã‚Šã€å€¤ã‚’è¨­å®šã—ãŸã‚Šã€å‰Šé™¤ã—ãŸã‚Šã™ã‚‹ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚ä¾‹ãˆã°ã€ ``a.x`` "
"ã«ã‚ˆã‚‹å±æ€§ã®æ¤œç´¢ã§ã¯ã€ã¾ãš ``a.__dict__['x']`` ã€æ¬¡ã« ``type(a).__dict__['x']`` ã€ãã—ã¦ "
"``type(a)`` ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã§ãªã„ã‚‚ã®ã«ç¶šãã€ã¨ã„ã£ãŸå…·åˆã«é€£é–ãŒèµ·ã“ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1605
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called."
msgstr ""
"ã—ã‹ã—ã€æ¤œç´¢å¯¾è±¡ã®å€¤ãŒã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ã®ã„ãšã‚Œã‹ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚Œã°ã€Python "
"ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¦ã€ä»£ã‚ã‚Šã«ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚å…ˆè¿°ã®é€£é–ã®ä¸­ã®ã©ã“ã§ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã‹ã¯ã€ã©ã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã¦ã€ã©ã®ã‚ˆã†ã«å‘¼ã³å‡ºã•ã‚ŒãŸã‹ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1610
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""
"ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿å‘¼ã³å‡ºã—ã®åŸºç‚¹ã¨ãªã‚‹ã®ã¯ã€å±æ€§åã¸ã®æŸç¸› (binding) ã€ã™ãªã‚ã¡ ``a.x`` ã§ã™ã€‚å¼•æ•°ãŒã©ã®ã‚ˆã†ã«ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã«çµåˆã•ã‚Œã‚‹ã‹ã¯"
" ``a`` ã«ä¾å­˜ã—ã¾ã™:"

#: ../../reference/datamodel.rst:1615
msgid "Direct Call"
msgstr "ç›´æ¥å‘¼ã³å‡ºã— (Direct Call)"

#: ../../reference/datamodel.rst:1614
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""
"æœ€ã‚‚å˜ç´”ã§ã€ã‹ã¤ã‚ã£ãŸã«ä½¿ã‚ã‚Œãªã„å‘¼ã³å‡ºã—æ“ä½œã¯ã€ã‚³ãƒ¼ãƒ‰ä¸­ã§ç›´æ¥ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—: ``x.__get__(a)`` "
"ã‚’è¡Œã†ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1619
msgid "Instance Binding"
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æŸç¸› (Instance Binding)"

#: ../../reference/datamodel.rst:1618
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸æŸç¸›ã™ã‚‹ã¨ã€``a.x`` ã¯å‘¼ã³å‡ºã— ``type(a).__dict__['x'].__get__(a, "
"type(a))`` ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1623
msgid "Class Binding"
msgstr "ã‚¯ãƒ©ã‚¹æŸç¸› (Class Binding)"

#: ../../reference/datamodel.rst:1622
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: "
"``A.__dict__['x'].__get__(None, A)``."
msgstr "ã‚¯ãƒ©ã‚¹ã¸æŸç¸›ã™ã‚‹ã¨ã€``A.x`` ã¯å‘¼ã³å‡ºã— ``A.__dict__['x'].__get__(None, A)`` ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1629
msgid "Super Binding"
msgstr "super æŸç¸› (Super Binding)"

#: ../../reference/datamodel.rst:1626
msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, "
"obj).m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately preceding ``B`` and then invokes the descriptor with the call: "
"``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr ""
"``a`` ãŒ :class:`super` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹å ´åˆã€æŸç¸› ``super(B, obj).m()`` ã‚’è¡Œã†ã¨ã¾ãš ``A`` "
"ã€ç¶šã„ã¦ ``B`` ã«å¯¾ã—ã¦ ``obj.__class_.__mro__`` ã‚’æ¤œç´¢ã—ã€æ¬¡ã«å‘¼ã³å‡ºã—: "
"``A.__dict__['m'].__get__(obj, obj.__class__)`` ã§ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1631
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"the which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  If "
"it does not define :meth:`__get__`, then accessing the attribute will return"
" the descriptor object itself unless there is a value in the object's "
"instance dictionary.  If the descriptor defines :meth:`__set__` and/or "
":meth:`__delete__`, it is a data descriptor; if it defines neither, it is a "
"non-data descriptor.  Normally, data descriptors define both :meth:`__get__`"
" and :meth:`__set__`, while non-data descriptors have just the "
":meth:`__get__` method.  Data descriptors with :meth:`__set__` and "
":meth:`__get__` defined always override a redefinition in an instance "
"dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr ""
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æŸç¸›ã§ã¯ã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿å‘¼ã³å‡ºã—ã®å„ªå…ˆé †ä½ã¯ã©ã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹ã«ä¾å­˜ã—ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€ "
":meth:`__get__` ã¨ :meth:`__set__` ã€ :meth:`__delete__` ã®ä»»æ„ã®çµ„åˆã›ã‚’å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ "
":meth:`__get__` "
"ãŒå®šç¾©ã•ã‚Œãªã„å ´åˆã«ã¯ã€ãã®å±æ€§ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è¾æ›¸ã«ãã®å€¤ãŒã‚ã‚‹å ´åˆã‚’é™¤ã‘ã°ã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªèº«ãŒè¿”ã£ã¦ãã¾ã™ã€‚ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãŒ"
" :meth:`__set__` ã¨ :meth:`__delete__` ã¾ãŸã¯ãã®ã©ã¡ã‚‰ã‹ã‚’å®šç¾©ã—ã¦ã„ã‚Œã°ã€ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨ãªã‚Šã¾ã™; "
"ã‚‚ã—ä¸¡æ–¹ã¨ã‚‚å®šç¾©ã—ãªã‘ã‚Œã°ã€éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã§ã™ã€‚é€šå¸¸ã€ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã§ã¯ã€ :meth:`__get__` ã¨ :meth:`__set__`"
" ã‚’å®šç¾©ã—ã€ä¸€æ–¹ã€éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã«ã¯ :meth:`__get__` ãƒ¡ã‚½ãƒƒãƒ‰ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ :meth:`__set__` ã¨ "
":meth:`__get__` "
"ã‚’å®šç¾©ã—ãŸãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è¾æ›¸å†…ã§å±æ€§å€¤ãŒå†å®šç¾©ã•ã‚Œã¦ã‚‚ã€å¸¸ã«ã“ã®å€¤ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¾ã™ã€‚å¯¾ç…§çš„ã«ã€éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å ´åˆã«ã¯ã€å±æ€§å€¤ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å´ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1644
msgid ""
"Python methods (including :func:`staticmethod` and :func:`classmethod`) are "
"implemented as non-data descriptors.  Accordingly, instances can redefine "
"and override methods.  This allows individual instances to acquire behaviors"
" that differ from other instances of the same class."
msgstr ""
"(:func:`staticmethod` ã‚„ :func:`classmethod` ã‚’å«ã‚€) Python "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚ãã®çµæœã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å†å®šç¾©ã—ãŸã‚Šã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã§ãã¾ã™ã€‚ã“ã®ã“ã¨ã«ã‚ˆã‚Šã€å€‹ã€…ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒåŒã˜ã‚¯ãƒ©ã‚¹ã®ä»–ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨äº’ã„ã«ç•°ãªã‚‹å‹•ä½œã‚’ç²å¾—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1649
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
":func:`property` "
"é–¢æ•°ã¯ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚å¾“ã£ã¦ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã‚ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å‹•ä½œã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1656
msgid "__slots__"
msgstr "__slots__"

#: ../../reference/datamodel.rst:1658
msgid ""
"*__slots__* allow us to explicitly declare data members (like properties) "
"and deny the creation of *__dict__* and *__weakref__* (unless explicitly "
"declared in *__slots__* or available in a parent.)"
msgstr ""

#: ../../reference/datamodel.rst:1662
msgid "The space saved over using *__dict__* can be significant."
msgstr "*__dict__* ã‚’ä½¿ã†ã®ã«æ¯”ã¹ã¦ã€ç¯€ç´„ã§ãã‚‹ãƒ¡ãƒ¢ãƒªç©ºé–“ã¯ã‹ãªã‚Šå¤§ãã„ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1666
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves space "
"for the declared variables and prevents the automatic creation of *__dict__*"
" and *__weakref__* for each instance."
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹å¤‰æ•°ã«ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒç”¨ã„ã‚‹å¤‰æ•°åã‚’è¡¨ã™ã€æ–‡å­—åˆ—ã€ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã€ã¾ãŸã¯æ–‡å­—åˆ—ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ä»£å…¥ã§ãã¾ã™ã€‚*__slots__* "
"ã¯ã€å„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã—ã¦å®£è¨€ã•ã‚ŒãŸå¤‰æ•°ã«å¿…è¦ãªè¨˜æ†¶é ˜åŸŸã‚’ç¢ºä¿ã—ã€*__dict__* ã¨ *__weakref__* "
"ãŒè‡ªå‹•çš„ã«ç”Ÿæˆã•ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1673
msgid "Notes on using *__slots__*"
msgstr "*__slots__* ã‚’åˆ©ç”¨ã™ã‚‹éš›ã®æ³¨æ„"

#: ../../reference/datamodel.rst:1675
msgid ""
"When inheriting from a class without *__slots__*, the *__dict__* and "
"*__weakref__* attribute of the instances will always be accessible."
msgstr ""

#: ../../reference/datamodel.rst:1678
msgid ""
"Without a *__dict__* variable, instances cannot be assigned new variables "
"not listed in the *__slots__* definition.  Attempts to assign to an unlisted"
" variable name raises :exc:`AttributeError`. If dynamic assignment of new "
"variables is desired, then add ``'__dict__'`` to the sequence of strings in "
"the *__slots__* declaration."
msgstr ""
"*__dict__* å¤‰æ•°ãŒãªã„å ´åˆã€ *__slots__* "
"ã«åˆ—æŒ™ã•ã‚Œã¦ã„ãªã„æ–°ãŸãªå¤‰æ•°ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ä»£å…¥ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚åˆ—æŒ™ã•ã‚Œã¦ã„ãªã„å¤‰æ•°åã‚’ä½¿ã£ã¦ä»£å…¥ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã€ "
":exc:`AttributeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚æ–°ãŸãªå¤‰æ•°ã‚’å‹•çš„ã«ä»£å…¥ã—ãŸã„ã®ãªã‚‰ã€ *__slots__* ã‚’å®£è¨€ã™ã‚‹éš›ã« "
"``'__dict__'`` ã‚’å¤‰æ•°åã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«è¿½åŠ ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1684
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support weak references to its instances. If weak "
"reference support is needed, then add ``'__weakref__'`` to the sequence of "
"strings in the *__slots__* declaration."
msgstr ""
"*__slots__* ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã®å„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã« *__weakref__* å¤‰æ•°ãŒãªã„å ´åˆã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã™ã‚‹å¼±å‚ç…§ (weak "
"reference) ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã›ã‚“ã€‚å¼±å‚ç…§ã®ã‚µãƒãƒ¼ãƒˆãŒå¿…è¦ãªã‚‰ã€ *__slots__* ã‚’å®£è¨€ã™ã‚‹éš›ã« ``'__weakref__'`` "
"ã‚’å¤‰æ•°åã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«è¿½åŠ ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:1689
msgid ""
"*__slots__* are implemented at the class level by creating descriptors "
"(:ref:`descriptors`) for each variable name.  As a result, class attributes "
"cannot be used to set default values for instance variables defined by "
"*__slots__*; otherwise, the class attribute would overwrite the descriptor "
"assignment."
msgstr ""
"*__slots__* ã¯ã€ã‚¯ãƒ©ã‚¹ã®ãƒ¬ãƒ™ãƒ«ã§å„å¤‰æ•°ã«å¯¾ã™ã‚‹ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ (:ref:`descriptors` ã‚’å‚ç…§) "
"ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã¾ã™ã€‚ãã®çµæœã€ *__slots__* ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ã‚¯ãƒ©ã‚¹å±æ€§ã‚’ä½¿ã£ã¦è¨­å®šã§ããªããªã£ã¦ã„ã¾ã™; "
"ãã†ã—ãªã„ã¨ã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã«ã‚ˆã‚‹ä»£å…¥ã‚’ã‚¯ãƒ©ã‚¹å±æ€§ãŒä¸Šæ›¸ãã—ã¦ã—ã¾ã†ã‹ã‚‰ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1695
msgid ""
"The action of a *__slots__* declaration is not limited to the class where it"
" is defined.  *__slots__* declared in parents are available in child "
"classes. However, child subclasses will get a *__dict__*  and *__weakref__* "
"unless they also define *__slots__* (which should only contain names of any "
"*additional* slots)."
msgstr ""

#: ../../reference/datamodel.rst:1701
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""
"ã‚ã‚‹ã‚¯ãƒ©ã‚¹ã§ã€åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã§ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¹ãƒ­ãƒƒãƒˆã‚’å®šç¾©ã—ãŸå ´åˆã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚¹ãƒ­ãƒƒãƒˆã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã¯ "
"(ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’åŸºåº•ã‚¯ãƒ©ã‚¹ã‹ã‚‰ç›´æ¥å–å¾—ã—ãªã„é™ã‚Š) "
"ã‚¢ã‚¯ã‚»ã‚¹ã§ããªããªã‚Šã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®è¶£æ„ãŒä¸å®šã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚å°†æ¥ã¯ã€ã“ã®å•é¡Œã‚’é¿ã‘ã‚‹ãŸã‚ã«ä½•ã‚‰ã‹ã®ãƒã‚§ãƒƒã‚¯ãŒè¿½åŠ ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1706
msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-"
"length\" built-in types such as :class:`int`, :class:`bytes` and "
":class:`tuple`."
msgstr ""
"ç©ºã§ãªã„ *__slots__* ã¯ã€ :class:`int` ã‚„ :class:`bytes` ã‚„ :class:`tuple` ã®ã‚ˆã†ãª "
"\"å¯å¤‰é•·ã®\" çµ„ã¿è¾¼ã¿å‹ã‹ã‚‰æ´¾ç”Ÿã—ãŸã‚¯ãƒ©ã‚¹ã§ã¯å‹•ä½œã—ã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1709
msgid ""
"Any non-string iterable may be assigned to *__slots__*. Mappings may also be"
" used; however, in the future, special meaning may be assigned to the values"
" corresponding to each key."
msgstr ""
"*__slots__* ã«ã¯ã€æ–‡å­—åˆ—ã§ãªã„åå¾©å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»£å…¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚è¾æ›¸å‹ã‚‚ä½¿ã†ã“ã¨ãŒã§ãã¾ã™; "
"ã—ã‹ã—å°†æ¥ã€è¾æ›¸ã®å„ã‚­ãƒ¼ã«ç›¸å½“ã™ã‚‹å€¤ã«ä½•ã‚‰ã‹ã®ç‰¹æ®Šãªæ„å‘³ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1713
msgid ""
"*__class__* assignment works only if both classes have the same *__slots__*."
msgstr "*__class__* ã¸ã®ä»£å…¥ã¯ã€ä¸¡æ–¹ã®ã‚¯ãƒ©ã‚¹ãŒåŒã˜ *__slots__* ã‚’æŒã£ã¦ã„ã‚‹ã¨ãã®ã¿å‹•ä½œã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1715
msgid ""
"Multiple inheritance with multiple slotted parent classes can be used, but "
"only one parent is allowed to have attributes created by slots (the other "
"bases must have empty slot layouts) - violations raise :exc:`TypeError`."
msgstr ""

#: ../../reference/datamodel.rst:1723
msgid "Customizing class creation"
msgstr "ã‚¯ãƒ©ã‚¹ç”Ÿæˆã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹"

#: ../../reference/datamodel.rst:1725
msgid ""
"Whenever a class inherits from another class, *__init_subclass__* is called "
"on that class. This way, it is possible to write classes which change the "
"behavior of subclasses. This is closely related to class decorators, but "
"where class decorators only affect the specific class they're applied to, "
"``__init_subclass__`` solely applies to future subclasses of the class "
"defining the method."
msgstr ""
"ã‚¯ãƒ©ã‚¹ãŒä»–ã®ã‚¯ãƒ©ã‚¹ã‚’ç¶™æ‰¿ã™ã‚‹ã¨ãã«å¿…ãšã€ç¶™æ‰¿å…ƒã®ã‚¯ãƒ©ã‚¹ã® *__init_subclass__* "
"ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã¨ã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®æŒ™å‹•ã‚’å¤‰æ›´ã™ã‚‹ã‚¯ãƒ©ã‚¹ã‚’æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€ã‚¯ãƒ©ã‚¹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¨ã¨ã¦ã‚‚è‰¯ãä¼¼ã¦ã„ã¾ã™ãŒã€ã‚¯ãƒ©ã‚¹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãŒã€ãã‚ŒãŒé©ç”¨ã•ã‚ŒãŸç‰¹å®šã®ã‚¯ãƒ©ã‚¹ã«ã®ã¿ã«å½±éŸ¿ã™ã‚‹ã®ã«å¯¾ã—ã¦ã€"
" ``__init_subclass__`` ã¯ã€ã‚‚ã£ã±ã‚‰ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ãŸã‚¯ãƒ©ã‚¹ã®å°†æ¥ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1734
msgid ""
"This method is called whenever the containing class is subclassed. *cls* is "
"then the new subclass. If defined as a normal instance method, this method "
"is implicitly converted to a class method."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãã‚ŒãŒå®šç¾©ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ãŒç¶™æ‰¿ã•ã‚ŒãŸéš›ã«å¿…ãšå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚*cls* "
"ã¯æ–°ã—ã„ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ã‚‚ã—ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦å®šç¾©ã•ã‚Œã‚‹ã¨ã€æš—é»™çš„ã«ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1738
msgid ""
"Keyword arguments which are given to a new class are passed to the parent's "
"class ``__init_subclass__``. For compatibility with other classes using "
"``__init_subclass__``, one should take out the needed keyword arguments and "
"pass the others over to the base class, as in::"
msgstr ""
"æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã«ä¸ãˆã‚‰ã‚ŒãŸã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¯ã€è¦ªã®ã‚¯ãƒ©ã‚¹ã® ``__init_subclass__`` ã«æ¸¡ã•ã‚Œã¾ã™ã€‚ "
"``__init_subclass__`` "
"ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ä»–ã®ã‚¯ãƒ©ã‚¹ã¨ã®äº’æ›æ€§ã®ãŸã‚ã«ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã®ã‚ˆã†ã«å¿…è¦ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’å–å¾—ã—ãŸã‚‰ã€ä»–ã®å¼•æ•°ã¯åŸºåº•ã‚¯ãƒ©ã‚¹ã«å¼•ãæ¸¡ã™ã¹ãã§ã™::"

#: ../../reference/datamodel.rst:1752
msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but "
"raises an error if it is called with any arguments."
msgstr ""
"``object.__init_subclass__`` "
"ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã¯ä½•ã‚‚è¡Œã„ã¾ã›ã‚“ãŒã€ä½•ã‚‰ã‹ã®å¼•æ•°ã¨ã¨ã‚‚ã«å‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆã¯ã€ã‚¨ãƒ©ãƒ¼ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1757
msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. The"
" actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""

#: ../../reference/datamodel.rst:1768
msgid "Metaclasses"
msgstr "ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹"

#: ../../reference/datamodel.rst:1775
msgid ""
"By default, classes are constructed using :func:`type`. The class body is "
"executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã‚¯ãƒ©ã‚¹ã¯ :func:`type` ã‚’ä½¿ã£ã¦æ§‹ç¯‰ã•ã‚Œã¾ã™ã€‚ ã‚¯ãƒ©ã‚¹æœ¬ä½“ã¯æ–°ã—ã„åå‰ç©ºé–“ã§å®Ÿè¡Œã•ã‚Œã€ã‚¯ãƒ©ã‚¹åãŒ ``type(name, "
"bases, namespace)`` ã®çµæœã«ãƒ­ãƒ¼ã‚«ãƒ«ã«æŸç¸›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1779
msgid ""
"The class creation process can be customized by passing the ``metaclass`` "
"keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"ã‚¯ãƒ©ã‚¹ç”Ÿæˆãƒ—ãƒ­ã‚»ã‚¹ã¯ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚\n"
"ãã®ãŸã‚ã«ã¯ã‚¯ãƒ©ã‚¹å®šç¾©è¡Œã§ ``metaclass`` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’æ¸¡ã™ã‹ã€ãã®ã‚ˆã†ãªå¼•æ•°ã‚’å®šç¾©è¡Œã«å«ã‚€æ—¢å­˜ã®ã‚¯ãƒ©ã‚¹ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚\n"
"æ¬¡ã®ä¾‹ã§ ``MyClass`` ã¨ ``MySubclass`` ã¯ä¸¡æ–¹ã¨ã‚‚ ``Meta`` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã™::"

#: ../../reference/datamodel.rst:1793
msgid ""
"Any other keyword arguments that are specified in the class definition are "
"passed through to all metaclass operations described below."
msgstr "ã‚¯ãƒ©ã‚¹å®šç¾©ã®ä¸­ã§æŒ‡å®šã•ã‚ŒãŸä»–ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¯ã€å¾Œè¿°ã™ã‚‹ã™ã¹ã¦ã®ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹æ“ä½œã«æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1796
msgid "When a class definition is executed, the following steps occur:"
msgstr "ã‚¯ãƒ©ã‚¹å®šç¾©ãŒå®Ÿè¡Œã•ã‚Œã‚‹éš›ã«ã€ä»¥ä¸‹ã®ã‚¹ãƒ†ãƒƒãƒ—ãŒç”Ÿã˜ã¾ã™:"

#: ../../reference/datamodel.rst:1798
msgid "the appropriate metaclass is determined"
msgstr "é©åˆ‡ãªãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ãŒæ±ºå®šã•ã‚Œã‚‹"

#: ../../reference/datamodel.rst:1799
msgid "the class namespace is prepared"
msgstr "ã‚¯ãƒ©ã‚¹ã®åå‰ç©ºé–“ãŒæº–å‚™ã•ã‚Œã‚‹"

#: ../../reference/datamodel.rst:1800
msgid "the class body is executed"
msgstr "ã‚¯ãƒ©ã‚¹ã®æœ¬ä½“ãŒå®Ÿè¡Œã•ã‚Œã‚‹"

#: ../../reference/datamodel.rst:1801
msgid "the class object is created"
msgstr "ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œã‚‰ã‚Œã‚‹"

#: ../../reference/datamodel.rst:1804
msgid "Determining the appropriate metaclass"
msgstr "é©åˆ‡ãªãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã®æ±ºå®š"

#: ../../reference/datamodel.rst:1808
msgid ""
"The appropriate metaclass for a class definition is determined as follows:"
msgstr "ã‚¯ãƒ©ã‚¹å®šç¾©ã«å¯¾ã—ã¦é©åˆ‡ãªãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ±ºå®šã•ã‚Œã¾ã™:"

#: ../../reference/datamodel.rst:1810
msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is used"
msgstr "ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã‚‚æ˜ç¤ºçš„ãªãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã‚‚æŒ‡å®šã•ã‚Œãªã‹ã£ãŸå ´åˆã€ :func:`type` ãŒä½¿ã‚ã‚Œã¾ã™"

#: ../../reference/datamodel.rst:1811
msgid ""
"if an explicit metaclass is given and it is *not* an instance of "
":func:`type`, then it is used directly as the metaclass"
msgstr "æ˜ç¤ºçš„ã«ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ãŒæŒ‡å®šã•ã‚Œã€ãã‚ŒãŒ :func:`type` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ *ã§ãªã„* å ´åˆã€ãã‚ŒãŒç›´æ¥ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™"

#: ../../reference/datamodel.rst:1813
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or bases "
"are defined, then the most derived metaclass is used"
msgstr ""
":func:`type` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒæ˜ç¤ºçš„ã«ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã¨ã—ã¦æŒ‡å®šã•ã‚ŒãŸã‚Šã€ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã€æœ€ã‚‚æ´¾ç”Ÿçš„ãªãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ãŒä½¿ã‚ã‚Œã¾ã™"

#: ../../reference/datamodel.rst:1816
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all specified"
" base classes. The most derived metaclass is one which is a subtype of *all*"
" of these candidate metaclasses. If none of the candidate metaclasses meets "
"that criterion, then the class definition will fail with ``TypeError``."
msgstr ""
"æœ€ã‚‚æ´¾ç”Ÿçš„ãªãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã¯ã€(ã‚‚ã—ã‚ã‚Œã°) "
"æ˜ç¤ºçš„ã«æŒ‡å®šã•ã‚ŒãŸãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã¨ã€æŒ‡å®šã•ã‚ŒãŸã™ã¹ã¦ã®ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã‹ã‚‰é¸ã°ã‚Œã¾ã™ã€‚æœ€ã‚‚æ´¾ç”Ÿçš„ãªãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã¯ã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹å€™è£œã®ã™ã¹ã¦ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ã‚ã‚‹ã‚ˆã†ãªã‚‚ã®ã§ã™ã€‚ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹å€™è£œã®ã©ã‚Œã‚‚ãã®åŸºæº–ã‚’æº€ãŸã•ãªã‘ã‚Œã°ã€ã‚¯ãƒ©ã‚¹å®šç¾©ã¯"
" ``TypeError`` ã§å¤±æ•—ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1826
msgid "Preparing the class namespace"
msgstr "ã‚¯ãƒ©ã‚¹ã®åå‰ç©ºé–“ã®æº–å‚™"

#: ../../reference/datamodel.rst:1831
msgid ""
"Once the appropriate metaclass has been identified, then the class namespace"
" is prepared. If the metaclass has a ``__prepare__`` attribute, it is called"
" as ``namespace = metaclass.__prepare__(name, bases, **kwds)`` (where the "
"additional keyword arguments, if any, come from the class definition)."
msgstr ""
"é©åˆ‡ãªãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ãŒè­˜åˆ¥ã•ã‚ŒãŸã‚‰ã€æ¬¡ã«ã‚¯ãƒ©ã‚¹ã®åå‰ç©ºé–“ãŒæº–å‚™ã•ã‚Œã¾ã™ã€‚ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã« ``__prepare__`` "
"å±æ€§ãŒã‚ã‚‹å ´åˆã€ãã‚Œã¯ã€``namespace = metaclass.__prepare__(name, bases, **kwds)`` "
"ã¨ã—ã¦å‘¼ã°ã‚Œã¾ã™ (ã“ã“ã§è¿½åŠ ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¯ã€ã‚‚ã—ã‚ã‚Œã°ã‚¯ãƒ©ã‚¹å®šç¾©ã‹ã‚‰æ¥ã¾ã™)ã€‚"

#: ../../reference/datamodel.rst:1836
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class namespace "
"is initialised as an empty ordered mapping."
msgstr "ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã« ``__prepare__`` å±æ€§ãŒãªã„å ´åˆã€ã‚¯ãƒ©ã‚¹ã®åå‰ç©ºé–“ã¯ç©ºã® é †åºä»˜ããƒãƒƒãƒ”ãƒ³ã‚°ã¨ã—ã¦åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1841
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaclasses in Python 3000"

#: ../../reference/datamodel.rst:1842
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "``__prepare__`` åå‰ç©ºé–“ãƒ•ãƒƒã‚¯ã®å°å…¥"

#: ../../reference/datamodel.rst:1846
msgid "Executing the class body"
msgstr "ã‚¯ãƒ©ã‚¹æœ¬ä½“ã®å®Ÿè¡Œ"

#: ../../reference/datamodel.rst:1851
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is that "
"lexical scoping allows the class body (including any methods) to reference "
"names from the current and outer scopes when the class definition occurs "
"inside a function."
msgstr ""
"ã‚¯ãƒ©ã‚¹æœ¬ä½“ãŒ (å¤§ã¾ã‹ã«ã¯) ``exec(body, globals(), namespace)`` ã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚é€šå¸¸ã®å‘¼ã³å‡ºã—ã¨ "
":func:`exec` ã®é‡è¦ãªé•ã„ã¯ã€ã‚¯ãƒ©ã‚¹å®šç¾©ãŒé–¢æ•°å†…éƒ¨ã§è¡Œã‚ã‚Œã‚‹å ´åˆã€ãƒ¬ã‚­ã‚·ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«ã‚ˆã£ã¦ã‚¯ãƒ©ã‚¹æœ¬ä½“ (ä»»æ„ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å«ã‚€) "
"ãŒç¾åœ¨ã®ã‚¹ã‚³ãƒ¼ãƒ—ã¨å¤–å´ã®ã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰åå‰ã‚’å‚ç…§ã§ãã‚‹ã¨ã„ã†ç‚¹ã§ã™ã€‚"

#: ../../reference/datamodel.rst:1857
msgid ""
"However, even when the class definition occurs inside the function, methods "
"defined inside the class still cannot see names defined at the class scope. "
"Class variables must be accessed through the first parameter of instance or "
"class methods, or through the implicit lexically scoped ``__class__`` "
"reference described in the next section."
msgstr ""
"ã—ã‹ã—ã€ã‚¯ãƒ©ã‚¹å®šç¾©ãŒé–¢æ•°å†…éƒ¨ã§è¡Œã‚ã‚Œã‚‹æ™‚ã§ã•ãˆã€ã‚¯ãƒ©ã‚¹å†…éƒ¨ã§å®šç¾©ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¯ãƒ©ã‚¹ã‚¹ã‚³ãƒ¼ãƒ—ã§å®šç¾©ã•ã‚ŒãŸåå‰ã‚’è¦‹ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¹å¤‰æ•°ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã®æœ€åˆã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã‹ã€æ¬¡ã®ç¯€ã§èª¬æ˜ã™ã‚‹ã€æš—é»™çš„ã«é™çš„ã‚¹ã‚³ãƒ¼ãƒ—ãŒåˆ‡ã‚‰ã‚Œã¦ã„ã‚‹"
" ``__class__`` å‚ç…§ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:1866
msgid "Creating the class object"
msgstr "ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ"

#: ../../reference/datamodel.rst:1873
msgid ""
"Once the class namespace has been populated by executing the class body, the"
" class object is created by calling ``metaclass(name, bases, namespace, "
"**kwds)`` (the additional keywords passed here are the same as those passed "
"to ``__prepare__``)."
msgstr ""
"ã‚¯ãƒ©ã‚¹æœ¬ä½“ã®å®Ÿè¡Œã«ã‚ˆã£ã¦ã‚¯ãƒ©ã‚¹ã®åå‰ç©ºé–“ãŒåˆæœŸåŒ–ã•ã‚ŒãŸã‚‰ã€``metaclass(name, bases, namespace, **kwds)`` "
"ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã•ã‚Œã¾ã™ (ã“ã“ã§æ¸¡ã•ã‚Œã‚‹è¿½åŠ ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯ ``__prepare__`` ã«æ¸¡ã•ã‚Œã‚‹ã‚‚ã®ã¨åŒã˜ã§ã™)ã€‚"

#: ../../reference/datamodel.rst:1878
msgid ""
"This class object is the one that will be referenced by the zero-argument "
"form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of "
":func:`super` to correctly identify the class being defined based on lexical"
" scoping, while the class or instance that was used to make the current call"
" is identified based on the first argument passed to the method."
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ :func:`super` ã®ç„¡å¼•æ•°å½¢å¼ã«ã‚ˆã£ã¦å‚ç…§ã•ã‚Œã‚‹ã‚‚ã®ã§ã™ã€‚ ``__class__`` "
"ã¯ã€ã‚¯ãƒ©ã‚¹æœ¬ä½“ä¸­ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒ ``__class__`` ã¾ãŸã¯ ``super`` "
"ã®ã„ãšã‚Œã‹ã‚’å‚ç…§ã—ã¦ã„ã‚‹å ´åˆã«ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã‚‹æš—é»™ã®ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼å‚ç…§ã§ã™ã€‚ã“ã‚Œã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã•ã‚ŒãŸæœ€åˆã®å¼•æ•°ã«åŸºã¥ã„ã¦ç¾åœ¨ã®å‘¼ã³å‡ºã—ã‚’è¡Œã†ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚¯ãƒ©ã‚¹ã¾ãŸã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒè­˜åˆ¥ã•ã‚Œã‚‹ä¸€æ–¹ã€"
" :func:`super` ã®ç„¡å¼•æ•°å½¢å¼ãŒãƒ¬ã‚­ã‚·ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«åŸºã¥ã„ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã‚’æ­£ç¢ºã«è­˜åˆ¥ã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1888
msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the metaclass "
"as a ``__classcell__`` entry in the class namespace. If present, this must "
"be propagated up to the ``type.__new__`` call in order for the class to be "
"initialised correctly. Failing to do so will result in a "
":exc:`DeprecationWarning` in Python 3.6, and a :exc:`RuntimeError` in Python"
" 3.8."
msgstr ""

#: ../../reference/datamodel.rst:1895
msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customisation "
"steps are invoked after creating the class object:"
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ :class:`type` ã‚„æœ€çµ‚çš„ã«ã¯ ``type.__new__`` "
"ã‚’å‘¼ã³å‡ºã™ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã£ã¦ã„ã‚‹ã¨ãã¯ã€ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ãŸå¾Œã«æ¬¡ã®ã‚«ã‚¹ã‚¿ãƒ åŒ–ã®æ‰‹é †ãŒèµ·å‹•ã•ã‚Œã¾ã™:"

#: ../../reference/datamodel.rst:1899
msgid ""
"first, ``type.__new__`` collects all of the descriptors in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""
"æœ€åˆã«ã€ ``type.__new__`` ãŒ :meth:`~object.__set_name__` "
"ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã®åå‰ç©ºé–“ã«ã‚ã‚‹å…¨ã¦ã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’åé›†ã—ã¾ã™;"

#: ../../reference/datamodel.rst:1901
msgid ""
"second, all of these ``__set_name__`` methods are called with the class "
"being defined and the assigned name of that particular descriptor; and"
msgstr ""
"æ¬¡ã«ã€ãã‚Œã‚‰å…¨ã¦ã® ``__set_name__`` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã€ãŠã‚ˆã³ãã“ã«å±ã™ã‚‹ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã‚‹åå‰ã‚’å¼•æ•°ã¨ã—ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™;"

#: ../../reference/datamodel.rst:1903
msgid ""
"finally, the :meth:`~object.__init_subclass__` hook is called on the "
"immediate parent of the new class in its method resolution order."
msgstr ""
"æœ€å¾Œã«ã€æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰è§£æ±ºé †åºã§ã™ãä¸Šã«ä½ç½®ã™ã‚‹è¦ªã‚¯ãƒ©ã‚¹ã§ :meth:`~object.__init_subclass__` "
"ãƒ•ãƒƒã‚¯ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1906
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is bound "
"in the local namespace as the defined class."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã•ã‚ŒãŸå¾Œã«ã¯ã€ã‚¯ãƒ©ã‚¹å®šç¾©ã«å«ã¾ã‚Œã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ (ã‚‚ã—ã‚ã‚Œã°) "
"ã«ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ¸¡ã•ã‚Œã€ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãŒè¿”ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã“ã“ã§å®šç¾©ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã¨ã—ã¦ãƒ­ãƒ¼ã‚«ãƒ«ã®åå‰ç©ºé–“ã«æŸç¸›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1910
msgid ""
"When a new class is created by ``type.__new__``, the object provided as the "
"namespace parameter is copied to a new ordered mapping and the original "
"object is discarded. The new copy is wrapped in a read-only proxy, which "
"becomes the :attr:`~object.__dict__` attribute of the class object."
msgstr ""
"æ–°ã—ã„ã‚¯ãƒ©ã‚¹ãŒ ``type.__new__`` ã§ç”Ÿæˆã•ã‚ŒãŸã¨ãã¯ã€åå‰ç©ºé–“å¼•æ•°ã¨ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ–°ã—ã„é †åºä»˜ãã®ãƒãƒƒãƒ”ãƒ³ã‚°ã«è¤‡è£½ã•ã‚Œã€å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ç ´æ£„ã•ã‚Œã¾ã™ã€‚\n"
"æ–°ã—ãè¤‡è£½ã—ãŸã‚‚ã®ã¯èª­ã¿å‡ºã—å°‚ç”¨ã®ãƒ—ãƒ­ã‚­ã‚·ã§ãƒ©ãƒƒãƒ—ã•ã‚Œã€ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :attr:`~object.__dict__` å±æ€§ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1917
msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` - New super"

#: ../../reference/datamodel.rst:1918
msgid "Describes the implicit ``__class__`` closure reference"
msgstr "æš—é»™ã® ``__class__`` ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£å‚ç…§ã«ã¤ã„ã¦è¨˜è¿°ã—ã¦ã„ã¾ã™"

#: ../../reference/datamodel.rst:1922
msgid "Uses for metaclasses"
msgstr ""

#: ../../reference/datamodel.rst:1924
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored include enum, logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""
"ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã¯é™ã‚Šãªã„æ½œåœ¨çš„åˆ©ç”¨ä¾¡å€¤ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¾ã§è©¦ã•ã‚Œã¦ããŸã‚¢ã‚¤ãƒ‡ã‚¢ã«ã¯ã€åˆ—æŒ™å‹ã€ãƒ­ã‚°è¨˜éŒ²ã€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã®ãƒã‚§ãƒƒã‚¯ã€ "
"è‡ªå‹•ãƒ‡ãƒªã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã€è‡ªå‹•ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ç”Ÿæˆã€ãƒ—ãƒ­ã‚­ã‚·ã€ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã€ãã—ã¦è‡ªå‹•ãƒªã‚½ãƒ¼ã‚¹ãƒ­ãƒƒã‚¯ï¼åŒæœŸã¨ã„ã£ãŸã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1931
msgid "Customizing instance and subclass checks"
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã¨ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãƒã‚§ãƒƒã‚¯"

#: ../../reference/datamodel.rst:1933
msgid ""
"The following methods are used to override the default behavior of the "
":func:`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯çµ„ã¿è¾¼ã¿é–¢æ•° :func:`isinstance` ã¨ :func:`issubclass` "
"ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œã‚’ä¸Šæ›¸ãã™ã‚‹ã®ã«åˆ©ç”¨ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1936
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""
"ç‰¹ã«ã€ :class:`abc.ABCMeta` ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã¯ã€æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ (ABCs) ã‚’\"ä»®æƒ³åŸºåº•ã‚¯ãƒ©ã‚¹ (virtual base "
"classes)\" ã¨ã—ã¦ã€ä»–ã® ABC ã‚’å«ã‚€ã€ä»»æ„ã®ã‚¯ãƒ©ã‚¹ã‚„ (çµ„ã¿è¾¼ã¿å‹ã‚’å«ã‚€) å‹ã«è¿½åŠ ã™ã‚‹ãŸã‚ã«ã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1943
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""
"*instance* ãŒ (ç›´æ¥ã€ã¾ãŸã¯é–“æ¥çš„ã«) *class* ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨è€ƒãˆã‚‰ã‚Œã‚‹å ´åˆã« true ã‚’è¿”ã—ã¾ã™ã€‚å®šç¾©ã•ã‚Œã¦ã„ã‚Œã°ã€ "
"``isinstance(instance, class)`` ã®å®Ÿè£…ã®ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1950
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass,"
" class)``."
msgstr ""
"*subclass* ãŒ (ç›´æ¥ã€ã¾ãŸã¯é–“æ¥çš„ã«) *class* ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã¨è€ƒãˆã‚‰ã‚Œã‚‹å ´åˆã« true ã‚’è¿”ã—ã¾ã™ã€‚å®šç¾©ã•ã‚Œã¦ã„ã‚Œã°ã€ "
"``issubclass(subclass, class)`` ã®å®Ÿè£…ã®ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1955
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""
"ãªãŠã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚¯ãƒ©ã‚¹ã®å‹ (ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹) "
"ä¸Šã§æ¤œç´¢ã•ã‚Œã¾ã™ã€‚å®Ÿéš›ã®ã‚¯ãƒ©ã‚¹ã«ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦å®šç¾©ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãã‚Œè‡ªä½“ãŒã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ã“ã®å ´åˆã«ã®ã¿ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã®æ¤œç´¢ã¨ä¸€è²«ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1966
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã®å°å…¥"

#: ../../reference/datamodel.rst:1963
msgid ""
"Includes the specification for customizing :func:`isinstance` and "
":func:`issubclass` behavior through :meth:`~class.__instancecheck__` and "
":meth:`~class.__subclasscheck__`, with motivation for this functionality in "
"the context of adding Abstract Base Classes (see the :mod:`abc` module) to "
"the language."
msgstr ""
"æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ (:mod:`abc` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§) ã‚’è¨€èªã«è¿½åŠ ã™ã‚‹æ–‡è„ˆã«ãŠã„ã¦ã®å‹•æ©Ÿã‹ã‚‰ã€ "
":meth:`~class.__instancecheck__` ã¨ :meth:`~class.__subclasscheck__` ã‚’é€šã—ã¦ã€ "
":func:`isinstance` ã¨ :func:`issubclass` ã«ç‹¬è‡ªã®å‹•ä½œã‚’ã•ã›ã‚‹ãŸã‚ã®ä»•æ§˜ã®è¨˜è¿°ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1973
msgid "Emulating callable objects"
msgstr "å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹"

#: ../../reference/datamodel.rst:1980
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, arg2, "
"...)``."
msgstr ""
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒé–¢æ•°ã¨ã—ã¦ \"å‘¼ã°ã‚ŒãŸ\" éš›ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™; ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ ``x(arg1, arg2, ...)`` ã¯ "
"``x.__call__(arg1, arg2, ...)`` ã‚’çŸ­ãæ›¸ã„ãŸã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:1987
msgid "Emulating container types"
msgstr "ã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹"

#: ../../reference/datamodel.rst:1989
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are sequences (such as lists or tuples) or mappings (like"
" dictionaries), but can represent other containers as well.  The first set "
"of methods is used either to emulate a sequence or to emulate a mapping; the"
" difference is that for a sequence, the allowable keys should be the "
"integers *k* for which ``0 <= k < N`` where *N* is the length of the "
"sequence, or slice objects, which define a range of items.  It is also "
"recommended that mappings provide the methods :meth:`keys`, :meth:`values`, "
":meth:`items`, :meth:`get`, :meth:`clear`, :meth:`setdefault`, :meth:`pop`, "
":meth:`popitem`, :meth:`!copy`, and :meth:`update` behaving similar to those"
" for Python's standard dictionary objects.  The :mod:`collections` module "
"provides a :class:`~collections.abc.MutableMapping` abstract base class to "
"help create those methods from a base set of :meth:`__getitem__`, "
":meth:`__setitem__`, :meth:`__delitem__`, and :meth:`keys`. Mutable "
"sequences should provide methods :meth:`append`, :meth:`count`, "
":meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, :meth:`remove`, "
":meth:`reverse` and :meth:`sort`, like Python standard list objects.  "
"Finally, sequence types should implement addition (meaning concatenation) "
"and multiplication (meaning repetition) by defining the methods "
":meth:`__add__`, :meth:`__radd__`, :meth:`__iadd__`, :meth:`__mul__`, "
":meth:`__rmul__` and :meth:`__imul__` described below; they should not "
"define other numerical operators.  It is recommended that both mappings and "
"sequences implement the :meth:`__contains__` method to allow efficient use "
"of the ``in`` operator; for mappings, ``in`` should search the mapping's "
"keys; for sequences, it should search through the values.  It is further "
"recommended that both mappings and sequences implement the :meth:`__iter__` "
"method to allow efficient iteration through the container; for mappings, "
":meth:`__iter__` should be the same as :meth:`keys`; for sequences, it "
"should iterate through the values."
msgstr ""
"ä»¥ä¸‹ã«æŒ™ã’ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§ã€ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿè£…ã§ãã¾ã™ã€‚ã‚³ãƒ³ãƒ†ãƒŠã¯é€šå¸¸ã¯ (ãƒªã‚¹ãƒˆã‚„ã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãª) ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚„ (è¾æ›¸ã®ã‚ˆã†ãª) "
"ãƒãƒƒãƒ”ãƒ³ã‚°ã§ã™ãŒã€ä»–ã®ã‚³ãƒ³ãƒ†ãƒŠã‚‚åŒã˜ã‚ˆã†ã«è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æœ€åˆã®ãƒ¡ã‚½ãƒƒãƒ‰ç¾¤ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚‚ã—ãã¯ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’æ¨¡å€£ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™; "
"ä¸¡è€…ã®é•ã„ã¯ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã‚­ãƒ¼ã¨ã—ã¦ä½¿ãˆã‚‹ã®ã¯ã€ *N* ã‚’ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã¨ã—ã¦ ``0 <= k < N`` ã‚’æº€ãŸã™æ•´æ•° *k* "
"ã€ã‚‚ã—ãã¯è¦ç´ ã®ç¯„å›²ã‚’å®šç¾©ã™ã‚‹ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ãƒãƒƒãƒ”ãƒ³ã‚°ã¯ã€ Python ã®æ¨™æº–ã®è¾æ›¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨ä¼¼ãŸæŒ¯ã‚‹èˆã„ã‚’ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ "
":meth:`keys` ã€ :meth:`values` ã€ :meth:`items` ã€ :meth:`get` ã€ :meth:`clear` "
"ã€ :meth:`setdefault` ã€ :meth:`pop` ã€ :meth:`popitem` ã€ :meth:`!copy` ã€ "
":meth:`update` ã‚’æä¾›ã™ã‚‹ã“ã¨ã‚‚æ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ã€‚ :mod:`collections` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ "
":class:`~collections.abc.MutableMapping` æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’æä¾›ã—ã€ :meth:`__getitem__` ã€ "
":meth:`__setitem__` ã€ :meth:`__delitem__` ã€ :meth:`keys` "
"ã¨ã„ã†åŸºç¤ã¨ãªã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ç¾¤ã‹ã‚‰å‰æ–‡ã§æŒ™ã’ãŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½œæˆã™ã‚‹ã®ã‚’åŠ©ã‘ã¦ãã‚Œã¾ã™ã€‚å¯å¤‰ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€ Python "
"ã®æ¨™æº–ã®ãƒªã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒã˜ã‚ˆã†ã«ã€ãƒ¡ã‚½ãƒƒãƒ‰ :meth:`append` ã€ :meth:`count` ã€ :meth:`index` ã€ "
":meth:`extend` ã€ :meth:`insert` ã€ :meth:`pop` ã€ :meth:`remove` ã€ "
":meth:`reverse` ã€ :meth:`sort` ã‚’æä¾›ã™ã¹ãã§ã™ã€‚æœ€å¾Œã«ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã¯ (é€£çµã‚’æ„å‘³ã™ã‚‹) åŠ ç®—ã¨ "
"(ç¹°ã‚Šè¿”ã—ã‚’æ„å‘³ã™ã‚‹) ä¹—ç®—ã‚’ã€ä»¥ä¸‹ã«èª¬æ˜ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ :meth:`__add__` ã€ :meth:`__radd__` ã€ "
":meth:`__iadd__` ã€ :meth:`__mul__` ã€ :meth:`__rmul__` ã€ :meth:`__imul__` "
"ã‚’å®šç¾©ã—ã¦å®Ÿè£…ã™ã¹ãã§ã™; ãã—ã¦ã€ãã‚Œä»¥å¤–ã®æ•°å€¤æ¼”ç®—å­ã¯å®šç¾©ã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ”ãƒ³ã‚°ã¨ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ä¸¡æ–¹ã¨ã‚‚ã€åŠ¹ç‡ã®è‰¯ã„ ``in`` "
"æ¼”ç®—å­ãŒä½¿ãˆã‚‹ã‚ˆã†ã« :meth:`__contains__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã¹ãã§ã™; ãƒãƒƒãƒ”ãƒ³ã‚°ã§ã¯ ``in`` "
"ã¯ãƒãƒƒãƒ”ãƒ³ã‚°ã®ã‚­ãƒ¼ã‚’æ¤œç´¢ã™ã¹ãã§ã™; ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã¯å€¤ã‚’æ¤œç´¢ã™ã¹ãã§ã™ã€‚ãƒãƒƒãƒ”ãƒ³ã‚°ã‚‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚‚ã€ã‚³ãƒ³ãƒ†ãƒŠã®åŠ¹ç‡ã®è‰¯ã„åå¾©å‡¦ç†ãŒã§ãã‚‹ã‚ˆã† "
":meth:`__iter__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã¹ãã§ã™; ãƒãƒƒãƒ”ãƒ³ã‚°ã§ã¯ :meth:`__iter__` ã¯ :meth:`keys` "
"ã¨åŒã˜ã§ã‚ã‚‹ã¹ãã§ã™; ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã¯å€¤å…¨ä½“ã®åå¾©å‡¦ç†ã‚’è¡Œã†ã¹ãã§ã™ã€‚"

#: ../../reference/datamodel.rst:2024
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`__bool__` method and whose :meth:`__len__` method returns "
"zero is considered to be false in a Boolean context."
msgstr ""
"å‘¼ã³å‡ºã—ã¦çµ„ã¿è¾¼ã¿é–¢æ•° :func:`len` ã‚’å®Ÿè£…ã—ã¾ã™ã€‚\n"
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é•·ã•ã‚’ 0 ä»¥ä¸Šã®æ•´æ•°ã§è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"ã¾ãŸã€ :meth:`__bool__`  ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ãŠã‚‰ãšã€ :meth:`__len__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒ 0 ã‚’è¿”ã™ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒ–ãƒ¼ãƒ«æ¼”ç®—ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã¯å½ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2031
msgid ""
"In CPython, the length is required to be at most :attr:`sys.maxsize`. If the"
" length is larger than :attr:`!sys.maxsize` some features (such as "
":func:`len`) may raise :exc:`OverflowError`.  To prevent raising "
":exc:`!OverflowError` by truth value testing, an object must define a "
":meth:`__bool__` method."
msgstr ""
"CPython ã§ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é•·ã•ã¯æœ€å¤§ã§ã‚‚ :attr:`sys.maxsize` ã§ã‚ã‚‹ã“ã¨ãŒè¦æ±‚ã•ã‚Œã¾ã™ã€‚\n"
"é•·ã•ãŒ :attr:`!sys.maxsize` ã‚’è¶Šãˆã‚‹å ´åˆã€(:func:`len` ã®ã‚ˆã†ãª) ã„ãã¤ã‹ã®æ©Ÿèƒ½ã¯ :exc:`OverflowError` ã‚’é€å‡ºã™ã‚‹ã§ã—ã‚‡ã†ã€‚\n"
"çœŸå½å€¤ã¨ã—ã¦ã®åˆ¤å®šã§ :exc:`!OverflowError` ã‚’é€å‡ºã—ãªã„ã‚ˆã†ã«ã™ã‚‹ã«ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ meth:`__bool__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2040
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an estimated"
" length for the object (which may be greater or less than the actual "
"length). The length must be an integer ``>=`` 0. This method is purely an "
"optimization and is never required for correctness."
msgstr ""
"å‘¼ã³å‡ºã—ã¦ :func:`operator.length_hint` ã‚’å®Ÿè£…ã—ã¾ã™ã€‚\n"
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ¨å®šã•ã‚Œã‚‹é•·ã• (å®Ÿéš›ã®ã‚‚ã®ã‚ˆã‚Šé•·ã‹ã£ãŸã‚ŠçŸ­ã‹ã£ãŸã‚Šã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“) ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"é•·ã•ã¯ 0 ä»¥ä¸Šã®æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ç´”ç²‹ã«æœ€é©åŒ–ã§ã‚ã‚Šã€æ­£ç¢ºæ€§ã®ãŸã‚ã«å¿…è¦ãªã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2050
msgid ""
"Slicing is done exclusively with the following three methods.  A call like "
"::"
msgstr "ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ã¯ã€ä»¥ä¸‹ã® 3 ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦æ’ä»–çš„ã«è¡Œã‚ã‚Œã¾ã™ã€‚æ¬¡ã®ã‚ˆã†ãªå‘¼ã³å‡ºã—ã¯ ::"

#: ../../reference/datamodel.rst:2054
msgid "is translated to ::"
msgstr "æ¬¡ã®ã‚ˆã†ã«ç¿»è¨³ã•ã‚Œ ::"

#: ../../reference/datamodel.rst:2058
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr "ä»¥ä¸‹ã‚‚åŒæ§˜ã§ã™ã€‚å­˜åœ¨ã—ãªã„ã‚¹ãƒ©ã‚¤ã‚¹ã®è¦ç´ ã¯ ``None`` ã§åŸ‹ã‚ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2065
msgid ""
"Called to implement evaluation of ``self[key]``. For sequence types, the "
"accepted keys should be integers and slice objects.  Note that the special "
"interpretation of negative indexes (if the class wishes to emulate a "
"sequence type) is up to the :meth:`__getitem__` method. If *key* is of an "
"inappropriate type, :exc:`TypeError` may be raised; if of a value outside "
"the set of indexes for the sequence (after any special interpretation of "
"negative values), :exc:`IndexError` should be raised. For mapping types, if "
"*key* is missing (not in the container), :exc:`KeyError` should be raised."
msgstr ""
"``self[key]`` ã®å€¤è©•ä¾¡ (evaluation) "
"ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å ´åˆã€ã‚­ãƒ¼ã¨ã—ã¦æ•´æ•°ã¨ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ç†ã§ããªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ "
"(ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹å ´åˆ) è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã®è§£é‡ˆã¯ :meth:`__getitem__` ãƒ¡ã‚½ãƒƒãƒ‰æ¬¡ç¬¬ã¨ãªã‚Šã¾ã™ã€‚ *key* "
"ãŒä¸é©åˆ‡ãªå‹ã§ã‚ã£ãŸå ´åˆã€ :exc:`TypeError` ã‚’é€å‡ºã—ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“; (è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹å€¤ã«å¯¾ã—ã¦ä½•ã‚‰ã‹ã®è§£é‡ˆã‚’è¡Œã£ãŸä¸Šã§) "
"*key* ãŒã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹é›†åˆå¤–ã®å€¤ã§ã‚ã‚‹å ´åˆã€ :exc:`IndexError` ã‚’é€å‡ºã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ—å‹ã®å ´åˆã¯ã€ "
"*key* ã«èª¤ã‚ŠãŒã‚ã‚‹å ´åˆï¼ˆã‚³ãƒ³ãƒ†ãƒŠã«å«ã¾ã‚Œã¦ã„ãªã„å ´åˆï¼‰ã€ :exc:`KeyError` ã‚’é€å‡ºã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2076
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
":keyword:`for` ãƒ«ãƒ¼ãƒ—ã§ã¯ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®çµ‚ç«¯ã‚’æ­£ã—ãæ¤œå‡ºã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€ä¸æ­£ãªã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã«å¯¾ã—ã¦ "
":exc:`IndexError` ãŒé€å‡ºã•ã‚Œã‚‹ã‚‚ã®ã¨æœŸå¾…ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2082
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]``"
" for dict subclasses when key is not in the dictionary."
msgstr ""
"``self[key]`` ã®å®Ÿè£…ã«ãŠã„ã¦è¾æ›¸å†…ã«ã‚­ãƒ¼ãŒå­˜åœ¨ã—ãªã‹ã£ãŸå ´åˆã«ã€ dict ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ãŸã‚ã« :class:`dict`\\ .\\ "
":meth:`__getitem__` ã«ã‚ˆã£ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2088
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the "
"objects support changes to the values for keys, or if new keys can be added,"
" or for sequences if elements can be replaced.  The same exceptions should "
"be raised for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"``self[key]`` ã«å¯¾ã™ã‚‹ä»£å…¥ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ :meth:`__getitem__` "
"ã¨åŒã˜æ³¨æ„äº‹é …ãŒã‚ã¦ã¯ã¾ã‚Šã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã§ãã‚‹ã®ã¯ã€ã‚ã‚‹ã‚­ãƒ¼ã«å¯¾ã™ã‚‹å€¤ã®å¤‰æ›´ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ã€æ–°ãŸãªã‚­ãƒ¼ã‚’è¿½åŠ ã§ãã‚‹ã‚ˆã†ãªãƒãƒƒãƒ—ã®å ´åˆã¨ã€ã‚ã‚‹è¦ç´ ã‚’ç½®ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å ´åˆã ã‘ã§ã™ã€‚ä¸æ­£ãª"
" *key* ã«å¯¾ã—ã¦ã¯ã€ :meth:`__getitem__` ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒæ§˜ã®ä¾‹å¤–ã®é€å‡ºã‚’è¡Œã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2097
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the "
"objects support removal of keys, or for sequences if elements can be removed"
" from the sequence.  The same exceptions should be raised for improper *key*"
" values as for the :meth:`__getitem__` method."
msgstr ""
"``self[key]`` ã®å‰Šé™¤ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ :meth:`__getitem__` "
"ã¨åŒã˜æ³¨æ„äº‹é …ãŒã‚ã¦ã¯ã¾ã‚Šã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã§ãã‚‹ã®ã¯ã€ã‚­ãƒ¼ã®å‰Šé™¤ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãƒãƒƒãƒ—ã®å ´åˆã¨ã€è¦ç´ ã‚’å‰Šé™¤ã§ãã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å ´åˆã ã‘ã§ã™ã€‚ä¸æ­£ãª"
" *key* ã«å¯¾ã—ã¦ã¯ã€ :meth:`__getitem__` ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒæ§˜ã®ä¾‹å¤–ã®é€å‡ºã‚’è¡Œã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2106
msgid ""
"This method is called when an iterator is required for a container. This "
"method should return a new iterator object that can iterate over all the "
"objects in the container.  For mappings, it should iterate over the keys of "
"the container."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚³ãƒ³ãƒ†ãƒŠã«å¯¾ã—ã¦ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒè¦æ±‚ã•ã‚ŒãŸéš›ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚³ãƒ³ãƒ†ãƒŠå†…ã®å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æ¸¡ã£ã¦åå¾©å‡¦ç†ã§ãã‚‹ã‚ˆã†ãªã€æ–°ãŸãªã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ”ãƒ³ã‚°ã§ã¯ã€ã‚³ãƒ³ãƒ†ãƒŠå†…ã®ã‚­ãƒ¼ã«æ¸¡ã£ã¦åå¾©å‡¦ç†ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2110
msgid ""
"Iterator objects also need to implement this method; they are required to "
"return themselves.  For more information on iterator objects, see "
":ref:`typeiter`."
msgstr ""
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™; "
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®å ´åˆã€è‡ªåˆ†è‡ªèº«ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«é–¢ã™ã‚‹ã‚ˆã‚Šè©³ç´°ãªæƒ…å ±ã¯ã€ :ref:`typeiter` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:2116
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""
":func:`reversed` "
"çµ„ã¿è¾¼ã¿é–¢æ•°ãŒé€†æ–¹å‘ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€(å­˜åœ¨ã™ã‚Œã°)å‘¼ã³å‡ºã—ã¾ã™ã€‚ã‚³ãƒ³ãƒ†ãƒŠå†…ã®å…¨è¦ç´ ã‚’é€†é †ã«ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã€æ–°ã—ã„ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã™ã¹ãã§ã™ã€‚"

#: ../../reference/datamodel.rst:2120
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and "
":meth:`__getitem__`).  Objects that support the sequence protocol should "
"only provide :meth:`__reversed__` if they can provide an implementation that"
" is more efficient than the one provided by :func:`reversed`."
msgstr ""
":meth:`__reversed__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ :func:`reversed` çµ„è¾¼ã¿é–¢æ•°ã¯ sequence ãƒ—ãƒ­ãƒˆã‚³ãƒ«"
" (:meth:`__len__` ã¨ :meth:`__getitem__`) ã‚’ä½¿ã£ãŸæ–¹æ³•ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ã€‚ sequence "
"ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ :func:`reversed` ã‚ˆã‚Šã‚‚åŠ¹ç‡ã®ã„ã„å®Ÿè£…ã‚’æä¾›ã§ãã‚‹å ´åˆã«ã®ã¿ "
":meth:`__reversed__` ã‚’å®šç¾©ã™ã‚‹ã¹ãã§ã™ã€‚"

#: ../../reference/datamodel.rst:2127
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a sequence.  However, container"
" objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be a sequence."
msgstr ""
"å¸°å±ãƒ†ã‚¹ãƒˆæ¼”ç®—å­ (:keyword:`in` ãŠã‚ˆã³ :keyword:`not in`) "
"ã¯é€šå¸¸ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«æ¸¡ã‚‹åå¾©å‡¦ç†ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ä»¥ä¸‹ã®ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã€ã‚ˆã‚ŠåŠ¹ç‡çš„ãªå®Ÿè£…ã‚’è¡Œã£ãŸã‚Šã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ãªãã¦ã‚‚ã‚ˆã„ã‚ˆã†ã«ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2134
msgid ""
"Called to implement membership test operators.  Should return true if *item*"
" is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""
"å¸°å±ãƒ†ã‚¹ãƒˆæ¼”ç®—ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ *item* ãŒ *self* "
"å†…ã«å­˜åœ¨ã™ã‚‹å ´åˆã«ã¯çœŸã‚’ã€ãã†ã§ãªã„å ´åˆã«ã¯å½ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€å€¤ã‚„ã‚­ãƒ¼ã¨å€¤ã®çµ„ã§ã¯ãªãã€ã‚­ãƒ¼ã«å¯¾ã™ã‚‹å¸°å±ãƒ†ã‚¹ãƒˆã‚’è€ƒãˆãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2138
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""
":meth:`__contains__` ã‚’å®šç¾©ã—ãªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã¯ã€ãƒ¡ãƒ³ãƒã‚·ãƒƒãƒ—ãƒ†ã‚¹ãƒˆã¯ã¾ãšã€ :meth:`__iter__` "
"ã‚’ä½¿ã£ãŸåå¾©ã‚’è©¦ã¿ã¾ã™ã€æ¬¡ã«å¤ã„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹åå¾©ãƒ—ãƒ­ãƒˆã‚³ãƒ« :meth:`__getitem__` ã‚’ä½¿ã„ã¾ã™ã€ :ref:`è¨€èªãƒ¬ãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã®ã“ã®ç¯€ "
"<membership-test-details>` ã‚’å‚ç…§ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../reference/datamodel.rst:2147
msgid "Emulating numeric types"
msgstr "æ•°å€¤å‹ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹"

#: ../../reference/datamodel.rst:2149
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of"
" number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""
"ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã€æ•°å€¤å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ç‰¹å®šã®ç¨®é¡ã®æ•°å€¤å‹ã§ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã‚ˆã†ãªæ¼”ç®—ã«å¯¾å¿œã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ "
"(éæ•´æ•°ã®æ•°å€¤ã«å¯¾ã™ã‚‹ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—ãªã©) ã¯ã€æœªå®šç¾©ã®ã¾ã¾ã«ã—ã¦ãŠã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2175
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to"
" evaluate the expression ``x + y``, where *x* is an instance of a class that"
" has an :meth:`__add__` method, ``x.__add__(y)`` is called.  The "
":meth:`__divmod__` method should be the equivalent to using "
":meth:`__floordiv__` and :meth:`__mod__`; it should not be related to "
":meth:`__truediv__`.  Note that :meth:`__pow__` should be defined to accept "
"an optional third argument if the ternary version of the built-in "
":func:`pow` function is to be supported."
msgstr ""
"ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã‚“ã§äºŒé …ç®—è¡“æ¼”ç®—å­ (``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) ã‚’å®Ÿè£…ã—ã¾ã™ã€‚\n"
"ä¾‹ãˆã° *x* ãŒ :meth:`__add__` ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚ã‚‹ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹å ´åˆã€å¼ ``x + y`` ã‚’è©•ä¾¡ã™ã‚‹ã¨ ``x.__add__(y)`` ãŒå‘¼ã°ã‚Œã¾ã™ã€‚\n"
":meth:`__divmod__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :meth:`__floordiv__` ã¨ :meth:`__mod__` ã‚’ä½¿ç”¨ã™ã‚‹ã®ã¨ç­‰ä¾¡ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
":meth:`__truediv__` ã¨é–¢é€£ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚\n"
"çµ„ã¿è¾¼ã¿ã® :func:`pow` é–¢æ•°ã®ä¸‰é …ã®ã‚‚ã®ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚‰ãªã„å ´åˆã€ :meth:`__pow__` ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ç¬¬ä¸‰å¼•æ•°ã‚’å—ã‘å–ã‚‹ã‚‚ã®ã¨ã—ã¦å®šç¾©ã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2186
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr "ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ã„ãšã‚Œã‹ãŒæ¸¡ã•ã‚ŒãŸå¼•æ•°ã«å¯¾ã™ã‚‹æ“ä½œã‚’æä¾›ã—ã¦ã„ãªã„å ´åˆã€ ``NotImplemented`` ã‚’è¿”ã™ã¹ãã§ã™ã€‚"

#: ../../reference/datamodel.rst:2209
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected "
"(swapped) operands.  These functions are only called if the left operand "
"does not support the corresponding operation [#]_ and the operands are of "
"different types. [#]_ For instance, to evaluate the expression ``x - y``, "
"where *y* is an instance of a class that has an :meth:`__rsub__` method, "
"``y.__rsub__(x)`` is called if ``x.__sub__(y)`` returns *NotImplemented*."
msgstr ""
"ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã‚“ã§äºŒé …ç®—è¡“æ¼”ç®— (``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) ã®ã€è¢«æ¼”ç®—å­ãŒåå°„ã—ãŸ (å…¥ã‚Œæ›¿ãˆã‚‰ã‚ŒãŸ) ã‚‚ã®ã‚’å®Ÿè£…ã—ã¾ã™ã€‚\n"
"ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ã€å·¦å´ã®è¢«æ¼”ç®—å­ãŒå¯¾å¿œã™ã‚‹æ¼”ç®—ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ãŠã‚‰ãš  [#]_  ã€éæ¼”ç®—å­ãŒç•°ãªã‚‹å‹ã®å ´åˆã«ã®ã¿å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ [#]_\n"
"ä¾‹ãˆã°ã€ *y* ãŒ :meth:`__rsub__` ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚ã‚‹ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹å ´åˆã€ å¼ ``x - y`` ã‚’è©•ä¾¡ã™ã‚‹ã¨ ``x.__sub__(y)`` ãŒ *NotImplemented* ã‚’è¿”ã™ã¨ãã¯ ``y.__rsub__(x)`` ãŒå‘¼ã°ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2220
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""
"ãŸã ã—ã€ä¸‰é …æ¼”ç®—å­ :func:`pow` ãŒ :meth:`__rpow__` ã‚’å‘¼ã¶ã“ã¨ã¯ãªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ "
"(å‹å¼·åˆ¶ã®è¦å‰‡ãŒéå¸¸ã«é›£è§£ã«ãªã‚‹ã‹ã‚‰ã§ã™)ã€‚"

#: ../../reference/datamodel.rst:2225
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides the reflected method for the operation, this method "
"will be called before the left operand's non-reflected method.  This "
"behavior allows subclasses to override their ancestors' operations."
msgstr ""
"å³å´ã®è¢«æ¼”ç®—å­ã®å‹ãŒå·¦å´ã®è¢«æ¼”ç®—å­ã®å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€ã“ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã«å¯¾ã™ã‚‹åå°„ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯ã€å·¦å´ã®è¢«æ¼”ç®—å­ã®éåå°„ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã‚‹å‰ã«ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã¾ã™ã€‚ã“ã®æŒ¯ã‚‹èˆã„ã«ã‚ˆã‚Šã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒè¦ªã®æ¼”ç®—ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2245
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, "
"``>>=``, ``&=``, ``^=``, ``|=``).  These methods should attempt to do the "
"operation in-place (modifying *self*) and return the result (which could be,"
" but does not have to be, *self*).  If a specific method is not defined, the"
" augmented assignment falls back to the normal methods.  For instance, if "
"*x* is an instance of a class with an :meth:`__iadd__` method, ``x += y`` is"
" equivalent to ``x = x.__iadd__(y)`` . Otherwise, ``x.__add__(y)`` and "
"``y.__radd__(x)`` are considered, as with the evaluation of ``x + y``. In "
"certain situations, augmented assignment can result in unexpected errors "
"(see :ref:`faq-augmented-assignment-tuple-error`), but this behavior is in "
"fact part of the data model."
msgstr ""
"ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ç´¯ç®—ç®—è¡“ä»£å…¥ (``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``) ã‚’å®Ÿè£…ã—ã¾ã™ã€‚\n"
"ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ¼”ç®—ã‚’ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã§ (*self* ã‚’å¤‰æ›´ã™ã‚‹) è¡Œã†ã‚ˆã†è©¦ã¿ã€ãã®çµæœ (ãã®å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ãŒ *self* ã§ã‚‚æ§‹ã„ã¾ã›ã‚“) ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"ç‰¹å®šã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ãã®ç´¯ç®—ç®—è¡“æ¼”ç®—ã¯é€šå¸¸ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚\n"
"ä¾‹ãˆã° *x* ãŒ :meth:`__iadd__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹å ´åˆã€``x += y`` ã¯ ``x = x.__iadd__(y)`` ã¨ç­‰ä¾¡ã§ã™ã€‚\n"
"ãã†ã§ãªã„å ´åˆã€``x + y`` ã®è©•ä¾¡ã¨åŒæ§˜ã« ``x.__add__(y)`` ã¨ ``y.__radd__(x)`` ãŒè€ƒæ…®ã•ã‚Œã¾ã™ã€‚\n"
"ç‰¹å®šã®çŠ¶æ³ã§ã¯ã€ç´¯ç®—ä»£å…¥ã¯äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ã«çµ‚ã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ (:ref:`faq-augmented-assignment-tuple-error` ã‚’å‚ç…§ã—ã¦ãã ã•ã„) ãŒã€ã“ã®æŒ™å‹•ã¯å®Ÿéš›ã¯ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ã®æŒ™å‹•ã®ä¸€éƒ¨ã§ã™ã€‚"

#: ../../reference/datamodel.rst:2266
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, "
":func:`abs` and ``~``)."
msgstr "å‘¼ã³å‡ºã—ã¦å˜é …ç®—è¡“æ¼”ç®— (``-``, ``+``, :func:`abs` ãŠã‚ˆã³ ``~``) ã‚’å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2279
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` and "
":func:`float`.  Should return a value of the appropriate type."
msgstr ""
"çµ„ã¿è¾¼ã¿é–¢æ•°ã® :func:`complex`, :func:`int`, :func:`float` ã®å®Ÿè£…ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
"é©åˆ‡ãªå‹ã®å€¤ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2286
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is an "
"integer type.  Must return an integer."
msgstr ""
"å‘¼ã³å‡ºã—ã¦ :func:`operator.index` ã‚’å®Ÿè£…ã—ã¾ã™ã€‚\n"
"Python ãŒæ•°å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æå¤±ãªãå¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆ (ãŸã¨ãˆã°ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ã‚„ã€çµ„ã¿è¾¼ã¿ã® :func:`bin` ã€ :func:`hex` ã€ :func:`oct` é–¢æ•°) ã¯å¸¸ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚‹ã¨ãã®æ•°å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ•´æ•°å‹ã§ã‚ã‚‹ã“ã¨ãŒç¤ºå”†ã•ã‚Œã¾ã™ã€‚\n"
"æ•´æ•°ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2294
msgid ""
"In order to have a coherent integer type class, when :meth:`__index__` is "
"defined :meth:`__int__` should also be defined, and both should return the "
"same value."
msgstr ""
"æ•´æ•°å‹ã‚¯ãƒ©ã‚¹ã®ä¸€è²«æ€§ã‚’ä¿ã¤ãŸã‚ã€:meth:`__index__` ãŒå®šç¾©ã•ã‚ŒãŸå ´åˆã€:meth:`__int__` "
"ã‚‚ã¾ãŸå®šç¾©ã•ã‚Œã‚‹ã¹ãã§ã‚ã‚Šã€ã©ã¡ã‚‰ã‚‚åŒã˜å€¤ã‚’è¿”ã™ã¹ãã§ã™ã€‚"

#: ../../reference/datamodel.rst:2306
msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and :func:`~math.ceil`. "
"Unless *ndigits* is passed to :meth:`!__round__` all these methods should "
"return the value of the object truncated to an :class:`~numbers.Integral` "
"(typically an :class:`int`)."
msgstr ""
"çµ„ã¿è¾¼ã¿é–¢æ•°ã® :func:`round` ã¨ :mod:`math` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–¢æ•°ã® :func:`~math.trunc`, :func:`~math.floor`, :func:`~math.ceil` ã®å®Ÿè£…ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
"*ndigits* ãŒ :meth:`!__round__` ã«æ¸¡ã•ã‚Œãªã„é™ã‚Šã¯ã€ã“ã‚Œã‚‰ã®å…¨ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :class:`~numbers.Integral` (ãŸã„ã¦ã„ã¯ :class:`int`) ã«åˆ‡ã‚Šè©°ã‚ã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã‚’è¿”ã™ã¹ãã§ã™ã€‚"

#: ../../reference/datamodel.rst:2312
msgid ""
"If :meth:`__int__` is not defined then the built-in function :func:`int` "
"falls back to :meth:`__trunc__`."
msgstr ""

#: ../../reference/datamodel.rst:2319
msgid "With Statement Context Managers"
msgstr "withæ–‡ã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£"

#: ../../reference/datamodel.rst:2321
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be"
" established when executing a :keyword:`with` statement. The context manager"
" handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""
"ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£(:dfn:`context manager`) ã¨ã¯ã€ :keyword:`with` "
"æ–‡ã®å®Ÿè¡Œæ™‚ã«ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å®šç¾©ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¯ã€ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«å¿…è¦ãªå…¥ã‚Šå£ãŠã‚ˆã³å‡ºå£ã®å‡¦ç†ã‚’æ‰±ã„ã¾ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¯é€šå¸¸ã€"
" :keyword:`with` æ–‡ï¼ˆ :ref:`with` "
"ã®ç« ã‚’å‚ç…§ï¼‰ã«ã‚ˆã‚Šèµ·å‹•ã•ã‚Œã¾ã™ãŒã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç›´æ¥å‘¼ã³å‡ºã™ã“ã¨ã§èµ·å‹•ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2332
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""
"ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®ä»£è¡¨çš„ãªä½¿ã„æ–¹ã¨ã—ã¦ã¯ã€æ§˜ã€…ãªã‚°ãƒ­ãƒ¼ãƒãƒ«æƒ…å ±ã®ä¿å­˜ãŠã‚ˆã³æ›´æ–°ã€ãƒªã‚½ãƒ¼ã‚¹ã®ãƒ­ãƒƒã‚¯ã¨ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚ªãƒ¼ãƒ—ãƒ³ã¨ã‚¯ãƒ­ãƒ¼ã‚ºãªã©ãŒæŒ™ã’ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2335
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã«ã¤ã„ã¦ã®ã•ã‚‰ãªã‚‹æƒ…å ±ã«ã¤ã„ã¦ã¯ã€ :ref:`typecontextmanager` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:2340
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in"
" the :keyword:`as` clause of the statement, if any."
msgstr ""
"ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®ã®å…¥ã‚Šå£ã§å®Ÿè¡Œã•ã‚Œã‚‹å‡¦ç†ã§ã™ã€‚ :keyword:`with` æ–‡ã¯ã€æ–‡ã® :keyword:`as` "
"ç¯€ã§è¦å®šã•ã‚ŒãŸå€¤ã‚’è¿”ã™ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2347
msgid ""
"Exit the runtime context related to this object. The parameters describe the"
" exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""
"ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®å‡ºå£ã§å®Ÿè¡Œã•ã‚Œã‚‹å‡¦ç†ã§ã™ã€‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒçµ‚äº†ã—ãŸåŸå› ã¨ãªã£ãŸä¾‹å¤–ã«ã¤ã„ã¦èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒä¾‹å¤–ã‚’é€å‡ºã›ãšçµ‚äº†ã—ãŸå ´åˆã¯ã€å…¨ã¦ã®å¼•ãæ•°ã«"
" :const:`None` ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2351
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception"
" (i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""
"ã‚‚ã—ã€ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã€ã‹ã¤ãƒ¡ã‚½ãƒƒãƒ‰ãŒä¾‹å¤–ã‚’æŠ‘åˆ¶ã—ãŸã„å ´åˆï¼ˆã™ãªã‚ã¡ã€ä¾‹å¤–ãŒä¼æ’­ã•ã‚Œã‚‹ã®ã‚’é˜²ããŸã„å ´åˆï¼‰ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ True "
"ã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®çµ‚äº†å¾Œã€ä¾‹å¤–ã¯é€šå¸¸é€šã‚Šä¼æ’­ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2355
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ":meth:`__exit__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å—ã‘å–ã£ãŸä¾‹å¤–ã‚’å†åº¦é€å‡ºã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€å‘¼ã³å‡ºã—å´ã®è²¬ä»»ã§ãŠã“ãªã£ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:2362
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆ"

#: ../../reference/datamodel.rst:2362
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python ã® :keyword:`with` æ–‡ã®ä»•æ§˜ã€èƒŒæ™¯ã€ãŠã‚ˆã³ä¾‹ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2369
msgid "Special method lookup"
msgstr "ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰æ¤œç´¢"

#: ../../reference/datamodel.rst:2371
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""
"ã‚«ã‚¹ã‚¿ãƒ ã‚¯ãƒ©ã‚¹ã§ã¯ã€ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã®æš—é»™ã®å‘¼ã³å‡ºã—ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è¾æ›¸ã§ã¯ãªãã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã¨ãã«ã®ã¿æ­£ã—ãå‹•ä½œã™ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚ã“ã®å‹•ä½œã®ãŸã‚ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™::"

#: ../../reference/datamodel.rst:2386
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`__hash__` and :meth:`__repr__` that are implemented by all "
"objects, including type objects. If the implicit lookup of these methods "
"used the conventional lookup process, they would fail when invoked on the "
"type object itself::"
msgstr ""
"ã“ã®å‹•ä½œã®èƒŒæ™¯ã¨ãªã‚‹ç†ç”±ã¯ã€ :meth:`__hash__` ã¨ :meth:`__repr__` ã¨ã„ã£ãŸ type "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å«ã‚€ã™ã¹ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®æš—é»™ã®æ¤œç´¢ãŒé€šå¸¸ã®æ¤œç´¢ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½¿ã£ãŸå ´åˆã€ type "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã«å¯¾ã—ã¦å®Ÿè¡Œã•ã‚ŒãŸã¨ãã«å¤±æ•—ã—ã¦ã—ã¾ã„ã¾ã™::"

#: ../../reference/datamodel.rst:2399
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is"
" sometimes referred to as 'metaclass confusion', and is avoided by bypassing"
" the instance when looking up special methods::"
msgstr ""
"ã‚¯ãƒ©ã‚¹ã®éçµåˆãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã“ã®ã‚ˆã†ã«ã—ã¦å®Ÿè¡Œã—ã‚ˆã†ã¨ã™ã‚‹ã“ã¨ã¯ã€'metaclass confusion' "
"ã¨å‘¼ã°ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Šã€ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ¤œç´¢ã™ã‚‹ã¨ãã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ãƒã‚¤ãƒ‘ã‚¹ã™ã‚‹ã“ã¨ã§å›é¿ã•ã‚Œã¾ã™::"

#: ../../reference/datamodel.rst:2408
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the "
":meth:`__getattribute__` method even of the object's metaclass::"
msgstr ""
"æ­£ç¢ºæ€§ã®ãŸã‚ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ã®ã«åŠ ãˆã¦ã€ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰æ¤œç´¢ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã‚’å«ã‚ã¦ã€ "
":meth:`__getattribute__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ãƒã‚¤ãƒ‘ã‚¹ã—ã¾ã™::"

#: ../../reference/datamodel.rst:2434
msgid ""
"Bypassing the :meth:`__getattribute__` machinery in this fashion provides "
"significant scope for speed optimisations within the interpreter, at the "
"cost of some flexibility in the handling of special methods (the special "
"method *must* be set on the class object itself in order to be consistently "
"invoked by the interpreter)."
msgstr ""
"ã“ã®ã‚ˆã†ã« :meth:`__getattribute__` æ©Ÿæ§‹ã‚’ãƒã‚¤ãƒ‘ã‚¹ã™ã‚‹ã“ã¨ã§ã€ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã®æ‰±ã„ã«é–¢ã™ã‚‹ã‚ã‚‹ç¨‹åº¦ã®è‡ªç”±åº¦ã¨å¼•ãæ›ãˆã« "
"(ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‹ã‚‰ä¸€è²«ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã«ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¨­å®š "
"*ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„*)ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã‚’é«˜é€ŸåŒ–ã™ã‚‹ãŸã‚ã®å¤§ããªä½™åœ°ãŒæ‰‹ã«å…¥ã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2445
msgid "Coroutines"
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³"

#: ../../reference/datamodel.rst:2449
msgid "Awaitable Objects"
msgstr "å¾…æ©Ÿå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (Awaitable Object)"

#: ../../reference/datamodel.rst:2451
msgid ""
"An :term:`awaitable` object generally implements an :meth:`__await__` "
"method. :term:`Coroutine` objects returned from :keyword:`async def` "
"functions are awaitable."
msgstr ""
":term:`awaitable` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸€èˆ¬çš„ã«ã¯ :meth:`__await__` ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚\n"
":keyword:`async def` é–¢æ•°ãŒè¿”ã™ :term:`Coroutine` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¾…æ©Ÿå¯èƒ½ã§ã™ã€‚"

#: ../../reference/datamodel.rst:2457
msgid ""
"The :term:`generator iterator` objects returned from generators decorated "
"with :func:`types.coroutine` or :func:`asyncio.coroutine` are also "
"awaitable, but they do not implement :meth:`__await__`."
msgstr ""
":func:`types.coroutine` ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã‚‚ã—ãã¯ :func:`asyncio.coroutine` "
"ã§ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãŒä»˜ã‘ã‚‰ã‚ŒãŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‹ã‚‰è¿”ã•ã‚Œã‚‹ :term:`generator iterator` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚å¾…æ©Ÿå¯èƒ½ã§ã™ãŒã€ "
":meth:`__await__` ã¯å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2463
msgid ""
"Must return an :term:`iterator`.  Should be used to implement "
":term:`awaitable` objects.  For instance, :class:`asyncio.Future` implements"
" this method to be compatible with the :keyword:`await` expression."
msgstr ""
":term:`iterator` ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :term:`awaitable` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹ã¹ãã§ã™ã€‚\n"
"ç°¡å˜ã®ãŸã‚ã«ã€ :class:`asyncio.Future` ã«ã¯ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®Ÿè£…ã•ã‚Œã€ :keyword:`await` å¼ã¨äº’æ›æ€§ã‚’æŒã¤ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2469
msgid ":pep:`492` for additional information about awaitable objects."
msgstr "å¾…æ©Ÿå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã‚ˆã‚Šè©³ã—ãã¯ :pep:`492` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/datamodel.rst:2475
msgid "Coroutine Objects"
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../reference/datamodel.rst:2477
msgid ""
":term:`Coroutine` objects are :term:`awaitable` objects. A coroutine's "
"execution can be controlled by calling :meth:`__await__` and iterating over "
"the result.  When the coroutine has finished executing and returns, the "
"iterator raises :exc:`StopIteration`, and the exception's "
":attr:`~StopIteration.value` attribute holds the return value.  If the "
"coroutine raises an exception, it is propagated by the iterator.  Coroutines"
" should not directly raise unhandled :exc:`StopIteration` exceptions."
msgstr ""
":term:`Coroutine` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :term:`awaitable` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚\n"
":meth:`__await__` ã‚’å‘¼ã³å‡ºã—ã€ãã®è¿”ã‚Šå€¤ã«å¯¾ã—åå¾©å‡¦ç†ã‚’ã™ã‚‹ã“ã¨ã§ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®å®Ÿè¡Œã‚’åˆ¶å¾¡ã§ãã¾ã™ã€‚\n"
"ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®å®Ÿè¡ŒãŒå®Œäº†ã—åˆ¶å¾¡ã‚’æˆ»ã—ãŸã¨ãã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ :exc:`StopIteration` ã‚’é€å‡ºã—ã€ãã®ä¾‹å¤–ã® :attr:`~StopIteration.value` å±æ€§ã«è¿”ã‚Šå€¤ã‚’æŒãŸã›ã¾ã™ã€‚\n"
"ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒä¾‹å¤–ã‚’é€å‡ºã—ãŸå ´åˆã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã«ã‚ˆã‚Šä¼æ¬ã•ã‚Œã¾ã™ã€‚\n"
"ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‹ã‚‰ :exc:`StopIteration` ä¾‹å¤–ã‚’å¤–ã«é€å‡ºã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2485
msgid ""
"Coroutines also have the methods listed below, which are analogous to those "
"of generators (see :ref:`generator-methods`).  However, unlike generators, "
"coroutines do not directly support iteration."
msgstr ""
"ã‚³ãƒ«ãƒ¼ãƒãƒ³ã«ã¯ä»¥ä¸‹ã«æŒ™ã’ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ã‚ã‚Šã€ã“ã‚Œã‚‰ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰ã®é¡ä¼¼ã§ã™ (:ref:`generator-methods` ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚\n"
"ãŸã ã—ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¨é•ã£ã¦ã€ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯åå¾©å‡¦ç†ã‚’ç›´æ¥ã¯ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2489
msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³ã§2å›ä»¥ä¸Šå¾…æ©Ÿ (await) ã™ã‚‹ã¨ :exc:`RuntimeError` ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2495
msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, this "
"is equivalent to advancing the iterator returned by :meth:`__await__`.  If "
"*value* is not ``None``, this method delegates to the "
":meth:`~generator.send` method of the iterator that caused the coroutine to "
"suspend.  The result (return value, :exc:`StopIteration`, or other "
"exception) is the same as when iterating over the :meth:`__await__` return "
"value, described above."
msgstr ""
"ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®å®Ÿè¡Œã‚’é–‹å§‹ã—ãŸã‚Šå†é–‹ã—ãŸã‚Šã—ã¾ã™ã€‚\n"
"*value* ãŒ ``None`` ã®å ´åˆã¯ã€ :meth:`__await__` ã‹ã‚‰è¿”ã•ã‚ŒãŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’é€²ã‚ã‚‹ã®ã¨åŒç­‰ã§ã™ã€‚\n"
"*value* ãŒ ``None`` ã§ãªã„å ´åˆã¯ã€ã“ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚’ä¸€æ™‚åœæ­¢ã•ã›ãŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã® :meth:`~generator.send` ãƒ¡ã‚½ãƒƒãƒ‰ã«å‡¦ç†ã‚’å§”ä»»ã—ã¾ã™ã€‚\n"
"çµæœ (è¿”ã‚Šå€¤ã‹ :exc:`StopIteration` ã‹ãã®ä»–ã®ä¾‹å¤–) ã¯ã€ä¸Šã§è§£èª¬ã—ãŸã‚ˆã†ãª :meth:`__await__` ã®è¿”ã‚Šå€¤ã«å¯¾ã—ã¦åå¾©å‡¦ç†ã‚’è¡Œã£ãŸã¨ãã¨åŒã˜ã§ã™ã€‚"

#: ../../reference/datamodel.rst:2505
msgid ""
"Raises the specified exception in the coroutine.  This method delegates to "
"the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception is "
"raised at the suspension point.  The result (return value, "
":exc:`StopIteration`, or other exception) is the same as when iterating over"
" the :meth:`__await__` return value, described above.  If the exception is "
"not caught in the coroutine, it propagates back to the caller."
msgstr ""
"ã‚³ãƒ«ãƒ¼ãƒãƒ³ã§æŒ‡å®šã•ã‚ŒãŸä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚\n"
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã«ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚’ä¸€æ™‚åœæ­¢ã™ã‚‹ :meth:`~generator.throw` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚‹å ´åˆã«å‡¦ç†ã‚’å§”ä»»ã—ã¾ã™ã€‚\n"
"ãã†ã§ãªã„å ´åˆã«ã¯ã€ä¸­æ–­ã—ãŸåœ°ç‚¹ã‹ã‚‰ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚\n"
"çµæœ (è¿”ã‚Šå€¤ã‹ :exc:`StopIteration` ã‹ãã®ä»–ã®ä¾‹å¤–) ã¯ã€ä¸Šã§è§£èª¬ã—ãŸã‚ˆã†ãª :meth:`__await__` ã®è¿”ã‚Šå€¤ã«å¯¾ã—ã¦åå¾©å‡¦ç†ã‚’è¡Œã£ãŸã¨ãã¨åŒã˜ã§ã™ã€‚\n"
"ä¾‹å¤–ãŒã‚³ãƒ«ãƒ¼ãƒãƒ³ã®ä¸­ã§æ•æ‰ã•ã‚Œãªã‹ã£ãŸå ´åˆã€å‘¼ã³å‡ºã—å…ƒã¸ä¼æ¬ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2516
msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has such "
"a method.  Then it raises :exc:`GeneratorExit` at the suspension point, "
"causing the coroutine to immediately clean itself up. Finally, the coroutine"
" is marked as having finished executing, even if it was never started."
msgstr ""
"ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒè‡ªåˆ†è‡ªèº«ã®å¾Œç‰‡ä»˜ã‘ã‚’ã—çµ‚äº†ã—ã¾ã™ã€‚\n"
"ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒä¸€æ™‚åœæ­¢ã—ã¦ã„ã‚‹å ´åˆã¯ã€ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚’ä¸€æ™‚åœæ­¢ã•ã›ãŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã« :meth:`~generator.close` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Œã°ã€ã¾ãšã¯ãã‚Œã«å‡¦ç†ã‚’å§”ä»»ã—ã¾ã™ã€‚\n"
"ãã—ã¦ä¸€æ™‚åœæ­¢ã—ãŸåœ°ç‚¹ã‹ã‚‰ :exc:`GeneratorExit` ãŒé€å‡ºã•ã‚Œã€ãŸã ã¡ã«ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒè‡ªåˆ†è‡ªèº«ã®å¾Œç‰‡ä»˜ã‘ã‚’è¡Œã„ã¾ã™ã€‚\n"
"æœ€å¾Œã«ã€å®Ÿè¡ŒãŒé–‹å§‹ã•ã‚Œã¦ã„ãªã‹ã£ãŸå ´åˆã§ã‚‚ã€ã‚³ãƒ«ãƒ¼ãƒãƒ³ã«å®Ÿè¡ŒãŒå®Œäº†ã—ãŸå°ã‚’ä»˜ã‘ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2524
msgid ""
"Coroutine objects are automatically closed using the above process when they"
" are about to be destroyed."
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç ´æ£„ã•ã‚Œã‚‹ã¨ãã«ã¯ã€ä¸Šè¨˜ã®æ‰‹é †ã‚’çµŒã¦è‡ªå‹•çš„ã«é–‰ã˜ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2530
msgid "Asynchronous Iterators"
msgstr "éåŒæœŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ (Asynchronous Iterator)"

#: ../../reference/datamodel.rst:2532
msgid ""
"An *asynchronous iterable* is able to call asynchronous code in its "
"``__aiter__`` implementation, and an *asynchronous iterator* can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
"*éåŒæœŸã‚¤ãƒ†ãƒ©ãƒ–ãƒ«* ã® ``__aiter__`` ã®å®Ÿè£…ã‹ã‚‰ã¯éåŒæœŸã®ã‚³ãƒ¼ãƒ‰ãŒå‘¼ã¹ã€ *éåŒæœŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿* ã® ``__anext__`` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰ã¯éåŒæœŸã®ã‚³ãƒ¼ãƒ‰ãŒå‘¼ã¹ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2536
msgid ""
"Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr "éåŒæœŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ :keyword:`async for` æ–‡ã®ä¸­ã§ä½¿ãˆã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2540
msgid "Must return an *asynchronous iterator* object."
msgstr "*éåŒæœŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã•ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2544
msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is over."
msgstr ""
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®æ¬¡ã®å€¤ã‚’è¿”ã™ *å¾…æ©Ÿå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ* ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"åå¾©å‡¦ç†ãŒçµ‚äº†ã—ãŸã¨ãã«ã¯ :exc:`StopAsyncIteration` ã‚¨ãƒ©ãƒ¼ã‚’é€å‡ºã™ã¹ãã§ã™ã€‚"

#: ../../reference/datamodel.rst:2547
msgid "An example of an asynchronous iterable object::"
msgstr "éåŒæœŸã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¾‹::"

#: ../../reference/datamodel.rst:2566
msgid ""
"Starting with CPython 3.5.2, ``__aiter__`` can directly return "
":term:`asynchronous iterators <asynchronous iterator>`.  Returning an "
":term:`awaitable` object will result in a :exc:`PendingDeprecationWarning`."
msgstr ""
"CPython 3.5.2 ä»¥é™ã§ã¯ã€ ``__aiter__`` ã¯ :term:`éåŒæœŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ <asynchronous iterator>` ã‚’ç›´æ¥è¿”ã›ã¾ã™ã€‚\n"
":term:`awaitable` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã¨ :exc:`PendingDeprecationWarning` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2572
msgid ""
"The recommended way of writing backwards compatible code in CPython 3.5.x is"
" to continue returning awaitables from ``__aiter__``.  If you want to avoid "
"the PendingDeprecationWarning and keep the code backwards compatible, the "
"following decorator can be used::"
msgstr ""
"CPython 3.5.x ã§ã®å¾Œæ–¹äº’æ›æ€§ã®ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã¨ãã«æ¨å¥¨ã•ã‚Œã‚‹æ–¹æ³•ã¯ã€ ``__aiter__`` ã‹ã‚‰å¾…æ©Ÿå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ç¶šã‘ã‚‹ã“ã¨ã§ã™ã€‚\n"
"PendingDeprecationWarning ã‚’é¿ã‘ã€ã‚³ãƒ¼ãƒ‰ã®å¾Œæ–¹äº’æ›æ€§ã‚’ä¿ã¡ãŸã„å ´åˆã¯ã€æ¬¡ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãŒä½¿ãˆã¾ã™::"

#: ../../reference/datamodel.rst:2591
msgid "Example::"
msgstr "ä»¥ä¸‹ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¾‹ã§ã™::"

#: ../../reference/datamodel.rst:2602
msgid ""
"Starting with CPython 3.6, the :exc:`PendingDeprecationWarning` will be "
"replaced with the :exc:`DeprecationWarning`. In CPython 3.7, returning an "
"awaitable from ``__aiter__`` will result in a :exc:`RuntimeError`."
msgstr ""
"CPython 3.6 ã‹ã‚‰ã¯ã€ :exc:`PendingDeprecationWarning` ã¯ :exc:`DeprecationWarning` ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚\n"
"CPython 3.7 ã§ã¯ã€ ``__aiter__`` ã‹ã‚‰å¾…æ©Ÿå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã¨ :exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2609
msgid "Asynchronous Context Managers"
msgstr "éåŒæœŸã‚³ãƒ³ãƒ†ã‚¯ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ (Asynchronous Context Manager)"

#: ../../reference/datamodel.rst:2611
msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""
"*éåŒæœŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£* ã¯ã€ ``__aenter__`` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ ``__aexit__`` ãƒ¡ã‚½ãƒƒãƒ‰å†…éƒ¨ã§å®Ÿè¡Œã‚’ä¸€æ™‚åœæ­¢ã§ãã‚‹ "
"*ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£* ã§ã™ã€‚"

#: ../../reference/datamodel.rst:2614
msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr "éåŒæœŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¯ :keyword:`async with` æ–‡ã®ä¸­ã§ä½¿ãˆã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2618
msgid ""
"This method is semantically similar to the :meth:`__enter__`, with only "
"difference that it must return an *awaitable*."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ–‡æ³•çš„ã«ã¯ :meth:`__enter__` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ *å¾…æ©Ÿå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ* ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ã“ã‚ã ã‘ãŒç•°ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2623
msgid ""
"This method is semantically similar to the :meth:`__exit__`, with only "
"difference that it must return an *awaitable*."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ–‡æ³•çš„ã«ã¯ :meth:`__exit__` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ *å¾…æ©Ÿå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ* ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ã“ã‚ã ã‘ãŒç•°ãªã‚Šã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2626
msgid "An example of an asynchronous context manager class::"
msgstr "éåŒæœŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚¯ãƒ©ã‚¹ã®ä¾‹::"

#: ../../reference/datamodel.rst:2639
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../reference/datamodel.rst:2640
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"ç‰¹å®šã®æ¡ä»¶ãŒæº€ãŸã•ã‚ŒãŸå ´åˆã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® type ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒ *ã§ãã¾ã™* "
"ã€‚ã“ã‚Œã¯ã€æ­£ã—ãæ‰±ã‚ã‚Œãªã‹ã£ãŸå ´åˆã«ã¨ã¦ã‚‚å¥‡å¦™ãªå‹•ä½œã‚’å¼•ãèµ·ã“ã™ã®ã§ã€ä¸€èˆ¬çš„ã«ã¯è‰¯ã„è€ƒãˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/datamodel.rst:2644
msgid ""
"The :meth:`__hash__`, :meth:`__iter__`, :meth:`__reversed__`, and "
":meth:`__contains__` methods have special handling for this; others will "
"still raise a :exc:`TypeError`, but may do so by relying on the behavior "
"that ``None`` is not callable."
msgstr ""
":meth:`__hash__`, :meth:`__iter__`, :meth:`__reversed__`, :meth:`__contains__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã“ã®ã‚ˆã†ãªç‰¹åˆ¥ãªæ‰±ã‚ã‚Œæ–¹ã‚’ã—ã¾ã™;\n"
"ä»–ã®ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ :exc:`TypeError` ã‚’é€å‡ºã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ã“ã‚Œã¯ ``None`` ãŒå‘¼ã³å‡ºã—å¯èƒ½ã§ãªã„ã¨ã„ã†æŒ¯ã‚‹èˆã„ã«åŸºã¥ã„ãŸå‹•ä½œã§ã™ã€‚"

#: ../../reference/datamodel.rst:2649
msgid ""
"\"Does not support\" here means that the class has no such method, or the "
"method returns ``NotImplemented``.  Do not set the method to ``None`` if you"
" want to force fallback to the right operand's reflected methodâ€”that will "
"instead have the opposite effect of explicitly *blocking* such fallback."
msgstr ""
"ã“ã“ã§ã® \"ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„\" ã¨ã„ã†ã®ã¯ã€ã‚¯ãƒ©ã‚¹ãŒãã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ãªã„ã‹ã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒ ``NotImplemented`` ã‚’è¿”ã™ã¨ã„ã†æ„å‘³ã§ã™ã€‚\n"
"å³ã®è¢«æ¼”ç®—å­ã®å¯¾ã‚’ãªã™ãƒ¡ã‚½ãƒƒãƒ‰ã¸å‡¦ç†ã‚’å›ã—ãŸã„å ´åˆã«ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã« ``None`` ã‚’è¨­å®šã—ã¦ã¯ã„ã‘ã¾ã›ã‚“â€”ã“ã†ã™ã‚‹ã¨ã‚€ã—ã‚ã€å‡¦ç†ã‚’å›ã™ã®ã‚’æ˜ç¤ºçš„ã« *å¦¨ã’ã‚‹* ã¨ã„ã†æ­£åå¯¾ã®åŠ¹æœã‚’ç”Ÿã¿ã¾ã™ã€‚"

#: ../../reference/datamodel.rst:2655
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method (such as :meth:`__add__`) fails the operation is not supported, which"
" is why the reflected method is not called."
msgstr ""
"åŒã˜å‹ã®è¢«æ¼”ç®—å­ã«ã¤ã„ã¦ã¯ã€ç„¡åè»¢ã®ãƒ¡ã‚½ãƒƒãƒ‰ (ãŸã¨ãˆã° :meth:`__add__`) ãŒå¤±æ•—ã—ãŸå ´åˆã€ãã®æ¼”ç®—ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚\n"
"ã“ã‚Œã¯ã€åå°„ã—ãŸãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œãªã„ãŸã‚ã§ã™ã€‚"
