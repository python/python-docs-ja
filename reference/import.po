# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-21 13:06+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Akihiro Uchida <uchida@turbare.net>, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/import.rst:6
msgid "The import system"
msgstr "インポートシステム"

#: ../../reference/import.rst:10
msgid ""
"Python code in one :term:`module` gains access to the code in another module"
" by the process of :term:`importing` it.  The :keyword:`import` statement is"
" the most common way of invoking the import machinery, but it is not the "
"only way.  Functions such as :func:`importlib.import_module` and built-in "
":func:`__import__` can also be used to invoke the import machinery."
msgstr ""
"ある 1 つの :term:`module` にある Python コードから他のモジュールをインポート (:term:`importing`) "
"することで、そこにあるコードへアクセスできるようになります。 :keyword:`import` "
"文はインポート機構を動かす最も一般的な方法ですが、それが唯一の方法ではありません。 :func:`importlib.import_module` "
"や組み込みの :func:`__import__` といった関数を使っても、インポート機構を動かすことができます。"

#: ../../reference/import.rst:16
msgid ""
"The :keyword:`import` statement combines two operations; it searches for the"
" named module, then it binds the results of that search to a name in the "
"local scope.  The search operation of the :keyword:`import` statement is "
"defined as a call to the :func:`__import__` function, with the appropriate "
"arguments. The return value of :func:`__import__` is used to perform the "
"name binding operation of the :keyword:`import` statement.  See the "
":keyword:`import` statement for the exact details of that name binding "
"operation."
msgstr ""
":keyword:`import` 文は 2 つの処理を連続して行っています; "
"ある名前のモジュールを探し、その検索結果をローカルスコープの名前に束縛します。 :keyword:`import` 文の検索処理は、適切な引数で "
":func:`__import__` 関数を呼び出すこととして定義されています。 :func:`__import__` の戻り値は "
":keyword:`import` 文の名前束縛処理の実行で使われます。名前束縛処理の厳密な詳細は :keyword:`import` "
"文を参照してください。"

#: ../../reference/import.rst:25
msgid ""
"A direct call to :func:`__import__` performs only the module search and, if "
"found, the module creation operation.  While certain side-effects may occur,"
" such as the importing of parent packages, and the updating of various "
"caches (including :data:`sys.modules`), only the :keyword:`import` statement"
" performs a name binding operation."
msgstr ""
":func:`__import__` "
"を直接呼び出すとモジュールの検索のみが行われ、見つかった場合、モジュールの作成処理が行われます。親パッケージのインポートや "
"(:data:`sys.modules` を含む) 様々なキャッシュの更新などの副作用は起きるかもしれませんが、 :keyword:`import` "
"文のみが名前束縛処理を行います。"

#: ../../reference/import.rst:31
msgid ""
"When calling :func:`__import__` as part of an import statement, the standard"
" builtin :func:`__import__` is called. Other mechanisms for invoking the "
"import system (such as :func:`importlib.import_module`) may choose to "
"subvert :func:`__import__` and use its own solution to implement import "
"semantics."
msgstr ""
"import 文の一部として :func:`__import__` を呼び出したときは標準の組み込みの :func:`__import__` "
"が呼ばれます。インポートシステムを起動する他の機構 (たとえば :func:`importlib.import_module` など) は、 "
":func:`__import__` を覆すことを選んで固有のインポートセマンティクスを実装するための方法を用いることがあります。"

#: ../../reference/import.rst:37
msgid ""
"When a module is first imported, Python searches for the module and if "
"found, it creates a module object [#fnmo]_, initializing it.  If the named "
"module cannot be found, a :exc:`ModuleNotFoundError` is raised.  Python "
"implements various strategies to search for the named module when the import"
" machinery is invoked.  These strategies can be modified and extended by "
"using various hooks described in the sections below."
msgstr ""
"モジュールが初めてインポートされるとき、 Python はそのモジュールを検索し、見付かった場合、モジュールオブジェクトを作成し、初期化します "
"[#fnmo]_ 。その名前のモジュールが見付からなかった場合、 :exc:`ModuleNotFoundError` が送出されます。 Python "
"には、インポート機構が実行されたときに名前からモジュールを検索する様々な戦略が実装されています。これらの戦略は、これ以降の節で解説される様々なフックを使って、修正したり拡張したりできます。"

#: ../../reference/import.rst:44
msgid ""
"The import system has been updated to fully implement the second phase of "
":pep:`302`. There is no longer any implicit import machinery - the full "
"import system is exposed through :data:`sys.meta_path`. In addition, native "
"namespace package support has been implemented (see :pep:`420`)."
msgstr ""
"インポートシステムが :pep:`302` の第 2 フェーズの完全な実装へ更新されました。もはや暗黙的なインポート機構はありません - "
"インポート機構全体は :data:`sys.meta_path` "
"を通して公開されています。加えて、ネイティブの名前空間パッケージのサポートは実装されています (:pep:`420` を参照) 。"

#: ../../reference/import.rst:52
msgid ":mod:`importlib`"
msgstr ":mod:`importlib`"

#: ../../reference/import.rst:54
msgid ""
"The :mod:`importlib` module provides a rich API for interacting with the "
"import system.  For example :func:`importlib.import_module` provides a "
"recommended, simpler API than built-in :func:`__import__` for invoking the "
"import machinery.  Refer to the :mod:`importlib` library documentation for "
"additional detail."
msgstr ""
":mod:`importlib` モジュールはインポート機構とやり取りするための便利な API を提供します。例えば "
":func:`importlib.import_module` は、インポート機構を実行するための組み込みの :func:`__import__` "
"よりもシンプルで推奨される API を提供します。より詳細なことは :mod:`importlib` ライブラリのドキュメントを参照してください。"

#: ../../reference/import.rst:63
msgid "Packages"
msgstr "パッケージ"

#: ../../reference/import.rst:68
msgid ""
"Python has only one type of module object, and all modules are of this type,"
" regardless of whether the module is implemented in Python, C, or something "
"else.  To help organize modules and provide a naming hierarchy, Python has a"
" concept of :term:`packages <package>`."
msgstr ""
"Python にはモジュールオブジェクトの種類は 1 種類しかなく、 Python 、 C "
"、それ以外のもののどれで実装されているかに関係なく、すべてのモジュールはこの種類になります。モジュールの組織化を助け、名前階層を提供するために、 "
"Python には :term:`パッケージ <package>` という概念があります。"

#: ../../reference/import.rst:73
msgid ""
"You can think of packages as the directories on a file system and modules as"
" files within directories, but don't take this analogy too literally since "
"packages and modules need not originate from the file system.  For the "
"purposes of this documentation, we'll use this convenient analogy of "
"directories and files.  Like file system directories, packages are organized"
" hierarchically, and packages may themselves contain subpackages, as well as"
" regular modules."
msgstr ""
"パッケージはファイルシステムのディレクトリ、モジュールはディレクトリにあるファイルと考えることができますが、パッケージやモジュールはファイルシステムから生まれる必要はないので、この比喩を額面通りに受け取ってはいけません。この文書の目的のために、ディレクトリとファイルという便利な比喩を使うことにします。ファイルシステムのディレクトリのように、パッケージは階層構造を成し、通常のモジュールだけでなく、サブパッケージを含むこともあります。"

#: ../../reference/import.rst:81
msgid ""
"It's important to keep in mind that all packages are modules, but not all "
"modules are packages.  Or put another way, packages are just a special kind "
"of module.  Specifically, any module that contains a ``__path__`` attribute "
"is considered a package."
msgstr ""
"すべてのパッケージはモジュールですが、すべてのモジュールがパッケージとは限らないことを心に留めておくのが重要です。もしくは他の言い方をすると、パッケージは単なる特別な種類のモジュールであると言えます。特に、``__path__``"
" 属性を持つ任意のモジュールはパッケージと見なされます。"

#: ../../reference/import.rst:86
msgid ""
"All modules have a name.  Subpackage names are separated from their parent "
"package name by dots, akin to Python's standard attribute access syntax.  "
"Thus you might have a module called :mod:`sys` and a package called "
":mod:`email`, which in turn has a subpackage called :mod:`email.mime` and a "
"module within that subpackage called :mod:`email.mime.text`."
msgstr ""
"すべてのモジュールには名前があります。サブパッケージ名は、 Python "
"の標準の属性アクセスの構文に似て、親パッケージ名とドットで区切られています。したがって、 :mod:`sys` と呼ばれるモジュールや "
":mod:`email` と呼ばれるパッケージを見掛けることがあるでしょう。その中には :mod:`email.mime` "
"と呼ばれるサブパッケージと、そのサブパッケージの中に :mod:`email.mime.text` と呼ばれるモジュールがあります。"

#: ../../reference/import.rst:94
msgid "Regular packages"
msgstr "通常のパッケージ"

#: ../../reference/import.rst:99
msgid ""
"Python defines two types of packages, :term:`regular packages <regular "
"package>` and :term:`namespace packages <namespace package>`.  Regular "
"packages are traditional packages as they existed in Python 3.2 and earlier."
" A regular package is typically implemented as a directory containing an "
"``__init__.py`` file.  When a regular package is imported, this "
"``__init__.py`` file is implicitly executed, and the objects it defines are "
"bound to names in the package's namespace.  The ``__init__.py`` file can "
"contain the same Python code that any other module can contain, and Python "
"will add some additional attributes to the module when it is imported."
msgstr ""
"Python では、 :term:`通常のパッケージ <regular package>` と :term:`名前空間パッケージ <namespace "
"package>` の 2 種類のパッケージが定義されています。通常のパッケージは Python 3.2 "
"以前から存在する伝統的なパッケージです。典型的な通常のパッケージは ``__init__.py`` "
"ファイルを含むディレクトリとして実装されます。通常のパッケージがインポートされたとき、この ``__init__.py`` "
"ファイルが暗黙的に実行され、それで定義しているオブジェクトがパッケージ名前空間にある名前に束縛されます。 ``__init__.py`` "
"ファイルは、他のモジュールに書ける Python コードと同じものを含むことができ、モジュールがインポートされたときに Python "
"はモジュールに属性を追加したりします。"

#: ../../reference/import.rst:109
msgid ""
"For example, the following file system layout defines a top level ``parent``"
" package with three subpackages::"
msgstr "例えば、以下のようなファイルシステム配置は、3 つのサブパッケージを持つ最上位の ``parent`` パッケージを定義します::"

#: ../../reference/import.rst:121
msgid ""
"Importing ``parent.one`` will implicitly execute ``parent/__init__.py`` and "
"``parent/one/__init__.py``.  Subsequent imports of ``parent.two`` or "
"``parent.three`` will execute ``parent/two/__init__.py`` and "
"``parent/three/__init__.py`` respectively."
msgstr ""
"``parent.one`` をインポートすると暗黙的に ``parent/__init__.py`` と "
"``parent/one/__init__.py`` が実行されます。その後に ``parent.two`` もしくは ``parent.three``"
" をインポートすると、それぞれ ``parent/two/__init__.py`` や ``parent/three/__init__.py`` "
"が実行されます。"

#: ../../reference/import.rst:128
msgid "Namespace packages"
msgstr "名前空間パッケージ"

#: ../../reference/import.rst:134
msgid ""
"A namespace package is a composite of various :term:`portions <portion>`, "
"where each portion contributes a subpackage to the parent package.  Portions"
" may reside in different locations on the file system.  Portions may also be"
" found in zip files, on the network, or anywhere else that Python searches "
"during import.  Namespace packages may or may not correspond directly to "
"objects on the file system; they may be virtual modules that have no "
"concrete representation."
msgstr ""
"名前空間パッケージは様々な :term:`ポーション <portion>` "
"を寄せ集めたもので、それぞれのポーションはサブパッケージを親パッケージに提供します。ポーションはファイルシステムの別々の場所にあることもあります。ポーションは、"
" zip ファイルの中やネットワーク上や、それ以外のインポート時に Python "
"が探すどこかの場所で見つかることもあります。名前空間パッケージはファイルシステム上のオブジェクトに対応することもあるし、そうでないこともあります; "
"それらは実際の実体のない仮想モジュールです。"

#: ../../reference/import.rst:142
msgid ""
"Namespace packages do not use an ordinary list for their ``__path__`` "
"attribute. They instead use a custom iterable type which will automatically "
"perform a new search for package portions on the next import attempt within "
"that package if the path of their parent package (or :data:`sys.path` for a "
"top level package) changes."
msgstr ""
"名前空間パッケージは、  ``__path__`` 属性に普通のリストは使いません。その代わりに独自の iterable "
"型を使っていて、ポーションの親パッケージのパス (もしくは最上位パッケージのための :data:`sys.path`) "
"が変わった場合、そのパッケージでの次のインポートの際に、新たに自動でパッケージポーションを検索します。"

#: ../../reference/import.rst:148
msgid ""
"With namespace packages, there is no ``parent/__init__.py`` file.  In fact, "
"there may be multiple ``parent`` directories found during import search, "
"where each one is provided by a different portion.  Thus ``parent/one`` may "
"not be physically located next to ``parent/two``.  In this case, Python will"
" create a namespace package for the top-level ``parent`` package whenever it"
" or one of its subpackages is imported."
msgstr ""
"名前空間パッケージには ``parent/__init__.py`` ファイルはありません。それどころか、異なるポーションがそれぞれ提供する複数の "
"``parent`` ディレクトリがインポート検索の際に見つかることもあります。したがって ``parent/one`` は物理的に "
"``parent/two`` の隣りにあるとは限りません。その場合、そのパッケージかサブパッケージのうち 1 つがインポートされたとき、Python "
"は最上位の ``parent`` パッケージのための名前空間パッケージを作成します。"

#: ../../reference/import.rst:155
msgid "See also :pep:`420` for the namespace package specification."
msgstr "名前空間パッケージの仕様については :pep:`420` も参照してください。"

#: ../../reference/import.rst:159
msgid "Searching"
msgstr "検索"

#: ../../reference/import.rst:161
msgid ""
"To begin the search, Python needs the :term:`fully qualified <qualified "
"name>` name of the module (or package, but for the purposes of this "
"discussion, the difference is immaterial) being imported.  This name may "
"come from various arguments to the :keyword:`import` statement, or from the "
"parameters to the :func:`importlib.import_module` or :func:`__import__` "
"functions."
msgstr ""
"検索を始めるためには、 Python はインポートされるモジュール (もしくはパッケージですが、ここでの議論の目的においてはささいな違いです) の "
":term:`完全修飾 <qualified name>` 名を必要とします。この名前は、 :keyword:`import` 文の様々な引数や "
":func:`importlib.import_module` および :func:`__import__` 関数のパラメータから得られます。"

#: ../../reference/import.rst:167
msgid ""
"This name will be used in various phases of the import search, and it may be"
" the dotted path to a submodule, e.g. ``foo.bar.baz``.  In this case, Python"
" first tries to import ``foo``, then ``foo.bar``, and finally "
"``foo.bar.baz``. If any of the intermediate imports fail, a "
":exc:`ModuleNotFoundError` is raised."
msgstr ""
"この名前はインポート検索の様々なフェーズで使われ、これは例えば ``foo.bar.baz`` "
"のようなドットで区切られたサブモジュールへのパスだったりします。この場合、 Python は最初に ``foo`` を、次に ``foo.bar`` "
"、そして最後に ``foo.bar.baz`` をインポートしようとします。中間のいずれかのインポートに失敗した場合は、 "
":exc:`ModuleNotFoundError` が送出されます。"

#: ../../reference/import.rst:174
msgid "The module cache"
msgstr "モジュールキャッシュ"

#: ../../reference/import.rst:179
msgid ""
"The first place checked during import search is :data:`sys.modules`.  This "
"mapping serves as a cache of all modules that have been previously imported,"
" including the intermediate paths.  So if ``foo.bar.baz`` was previously "
"imported, :data:`sys.modules` will contain entries for ``foo``, ``foo.bar``,"
" and ``foo.bar.baz``.  Each key will have as its value the corresponding "
"module object."
msgstr ""
"インポート検索で最初に調べる場所は :data:`sys.modules` "
"です。このマッピングは、中間のパスを含む、これまでにインポートされたすべてのモジュールのキャッシュを提供します。なので ``foo.bar.baz`` "
"がインポート済みの場合、 :data:`sys.modules` は ``foo`` 、 ``foo.bar`` 、 ``foo.bar.baz`` "
"のエントリーを含みます。それぞれのキーはその値として対応するモジュールオブジェクトを持ちます。"

#: ../../reference/import.rst:186
msgid ""
"During import, the module name is looked up in :data:`sys.modules` and if "
"present, the associated value is the module satisfying the import, and the "
"process completes.  However, if the value is ``None``, then a "
":exc:`ModuleNotFoundError` is raised.  If the module name is missing, Python"
" will continue searching for the module."
msgstr ""
"インポートではモジュール名は :data:`sys.modules` "
"から探され、存在した場合は、対応する値がインポートされるべきモジュールであり、この処理は完了します。しかし値が ``None`` だった場合、 "
":exc:`ModuleNotFoundError` が送出されます。モジュール名が見付からなかった場合は、 Python "
"はモジュールの検索を続けます。"

#: ../../reference/import.rst:192
msgid ""
":data:`sys.modules` is writable.  Deleting a key may not destroy the "
"associated module (as other modules may hold references to it), but it will "
"invalidate the cache entry for the named module, causing Python to search "
"anew for the named module upon its next import. The key can also be assigned"
" to ``None``, forcing the next import of the module to result in a "
":exc:`ModuleNotFoundError`."
msgstr ""
":data:`sys.modules` は書き込み可能です。キーの削除は対応するモジュールを破壊しない "
"(他のモジュールがそのモジュールへの参照を持っている) "
"かもしれませんが、指定されたモジュールのキャッシュされたエントリーを無効にし、それが次にインポートされたとき Python "
"にそのモジュールを改めて検索させることになります。キーを ``None`` に対応付けることもできますが、次にそのモジュールがインポートされるときに "
":exc:`ModuleNotFoundError` となってしまいます。"

#: ../../reference/import.rst:199
msgid ""
"Beware though, as if you keep a reference to the module object, invalidate "
"its cache entry in :data:`sys.modules`, and then re-import the named module,"
" the two module objects will *not* be the same. By contrast, "
":func:`importlib.reload` will reuse the *same* module object, and simply "
"reinitialise the module contents by rerunning the module's code."
msgstr ""
"たとえモジュールオブジェクトへの参照を保持しておいて、 :data:`sys.modules` "
"にキャッシュされたエントリーを無効にし、その指定したモジュールを再インポートしたとしても、 2 つのモジュールオブジェクトは同じでは *ない* "
"ことに注意してください。それとは対照的に、 :func:`importlib.reload` は *同じ* "
"モジュールオブジェクトを再利用し、モジュールのコードを再実行することで単にモジュールの内容を再初期化するだけです。"

#: ../../reference/import.rst:207
msgid "Finders and loaders"
msgstr "ファインダーとローダー"

#: ../../reference/import.rst:214
msgid ""
"If the named module is not found in :data:`sys.modules`, then Python's "
"import protocol is invoked to find and load the module.  This protocol "
"consists of two conceptual objects, :term:`finders <finder>` and "
":term:`loaders <loader>`. A finder's job is to determine whether it can find"
" the named module using whatever strategy it knows about. Objects that "
"implement both of these interfaces are referred to as :term:`importers "
"<importer>` - they return themselves when they find that they can load the "
"requested module."
msgstr ""
":data:`sys.modules` に指定されたモジュールが見つからなかった場合は、 Python "
"のインポートプロトコルが起動され、モジュールを見つけロードします。このプロトコルは 2 つの概念的なオブジェクト、 :term:`ファインダー "
"<finder>` と :term:`ローダー <loader>` "
"から成ります。ファインダーの仕事は、知っている戦略を使って指定されたモジュールを見つけられるかどうか判断することです。両方のインターフェースを実装しているオブジェクトは"
" :term:`インポーター <importer>` と呼ばれます - "
"インポーターは要求されたモジュールがロードできると分かったとき、自分自身を返します。"

#: ../../reference/import.rst:222
msgid ""
"Python includes a number of default finders and importers.  The first one "
"knows how to locate built-in modules, and the second knows how to locate "
"frozen modules.  A third default finder searches an :term:`import path` for "
"modules.  The :term:`import path` is a list of locations that may name file "
"system paths or zip files.  It can also be extended to search for any "
"locatable resource, such as those identified by URLs."
msgstr ""
"Python にはデフォルトのファインダーとインポーターがいくつかあります。 1 つ目のものは組み込みモジュールの見つけ方を知っていて、 2 "
"つ目のものは凍結されたモジュール (訳注: freeze ツールで処理されたモジュールのこと。 :doc:`プログラミング FAQ "
"<../faq/programming>` の「どうしたら Python スクリプトからスタンドアロンバイナリを作れますか？」の項目を参照) "
"の見つけ方を知っています。 3 つ目のものは :term:`インポートパス <import path>` からモジュールを探します。 "
":term:`インポートパス <import path>` はファイルシステムのパスや zip ファイルの位置を示すリストです。このリストは、 URL "
"で特定できるもののような、位置を示すことのできる任意のリソースの検索にまで拡張することもできます。"

#: ../../reference/import.rst:229
msgid ""
"The import machinery is extensible, so new finders can be added to extend "
"the range and scope of module searching."
msgstr "インポート機構は拡張可能なので、モジュール検索の範囲とスコープを拡張するために新しいファインダーを付け加えることができます。"

#: ../../reference/import.rst:232
msgid ""
"Finders do not actually load modules.  If they can find the named module, "
"they return a :dfn:`module spec`, an encapsulation of the module's import-"
"related information, which the import machinery then uses when loading the "
"module."
msgstr ""
"ファインダーは実際にはモジュールをロードしません。指定されたモジュールが見つかった場合、ファインダーは :dfn:`module spec` "
"(モジュール仕様)、すなわちモジュールのインポート関連の情報をカプセル化したものを返します。モジュールのロード時にインポート機構はそれを利用します。"

#: ../../reference/import.rst:236
msgid ""
"The following sections describe the protocol for finders and loaders in more"
" detail, including how you can create and register new ones to extend the "
"import machinery."
msgstr ""
"次の節では、インポート機構を拡張するための新しいファインダーやローダーの作成と登録を含め、ファインダーとローダーのプロトコルについてより詳しく解説します。"

#: ../../reference/import.rst:240
msgid ""
"In previous versions of Python, finders returned :term:`loaders <loader>` "
"directly, whereas now they return module specs which *contain* loaders. "
"Loaders are still used during import but have fewer responsibilities."
msgstr ""
"Python の以前のバージョンでは、ファインダーは直接 :term:`ローダー <loader>` を返していましたが、現在はローダーを *含む* "
"モジュール仕様を返します。ローダーはインポート中はまだ使われていますが、責任は減りました。"

#: ../../reference/import.rst:246
msgid "Import hooks"
msgstr "インポートフック"

#: ../../reference/import.rst:256
msgid ""
"The import machinery is designed to be extensible; the primary mechanism for"
" this are the *import hooks*.  There are two types of import hooks: *meta "
"hooks* and *import path hooks*."
msgstr ""
"インポート機構は拡張可能なように設計されています; その主となる仕組みは *インポートフック* です。インポートフックには 2 種類あります: "
"*メタフック* と *インポートパスフック* です。"

#: ../../reference/import.rst:260
msgid ""
"Meta hooks are called at the start of import processing, before any other "
"import processing has occurred, other than :data:`sys.modules` cache look "
"up. This allows meta hooks to override :data:`sys.path` processing, frozen "
"modules, or even built-in modules.  Meta hooks are registered by adding new "
"finder objects to :data:`sys.meta_path`, as described below."
msgstr ""
"メタフックはインポート処理の最初、 :data:`sys.modules` キャッシュの検索以外のインポート処理より前に呼び出されます。これにより、 "
":data:`sys.path` "
"の処理や凍結されたモジュールや組み込みのモジュールでさえも、メタフックで上書きすることができます。メタフックは以下で解説するように、 "
":data:`sys.meta_path` に新しいファインダーオブジェクトを追加することで登録されます。"

#: ../../reference/import.rst:266
msgid ""
"Import path hooks are called as part of :data:`sys.path` (or "
"``package.__path__``) processing, at the point where their associated path "
"item is encountered.  Import path hooks are registered by adding new "
"callables to :data:`sys.path_hooks` as described below."
msgstr ""
"インポートパスフックは、 :data:`sys.path` (もしくは ``package.__path__``) "
"の処理の一部として、対応するパス要素を取り扱うところで呼び出されます。インポートパスフックは以下で解説するように、新しい呼び出し可能オブジェクトを "
":data:`sys.path_hooks` に追加することで登録されます。"

#: ../../reference/import.rst:273
msgid "The meta path"
msgstr "メタパス"

#: ../../reference/import.rst:279
msgid ""
"When the named module is not found in :data:`sys.modules`, Python next "
"searches :data:`sys.meta_path`, which contains a list of meta path finder "
"objects.  These finders are queried in order to see if they know how to "
"handle the named module.  Meta path finders must implement a method called "
":meth:`~importlib.abc.MetaPathFinder.find_spec()` which takes three "
"arguments: a name, an import path, and (optionally) a target module.  The "
"meta path finder can use any strategy it wants to determine whether it can "
"handle the named module or not."
msgstr ""
"指定されたモジュールが :data:`sys.modules` に見つからなかったとき、 Python "
"は次にメタパス・ファインダー・オブジェクトが格納されている :data:`sys.meta_path` "
"を検索します。指定されたモジュールを扱うことができるかどうかを調べるために、各ファインダーに問い合わせを行います。メタパス・ファインダーには、名前とインポートパスと"
" (オプションの) ターゲットモジュールの 3 つの引数を取る "
":meth:`~importlib.abc.MetaPathFinder.find_spec()` "
"という名前のメソッドが実装されていなければいけません。メタパス・ファインダーでは、指定されたモジュールを扱えるかどうかを判定するための戦略は任意のものを使って構いません。"

#: ../../reference/import.rst:288
msgid ""
"If the meta path finder knows how to handle the named module, it returns a "
"spec object.  If it cannot handle the named module, it returns ``None``.  If"
" :data:`sys.meta_path` processing reaches the end of its list without "
"returning a spec, then a :exc:`ModuleNotFoundError` is raised.  Any other "
"exceptions raised are simply propagated up, aborting the import process."
msgstr ""
"meta path finder が指定されたモジュールの扱い方を知っている場合は、ファインダは spec "
"オブジェクトを返します。指定されたモジュールを扱えない場合は ``None`` を返します。 :data:`sys.meta_path` に対する処理が"
" spec を返さずにリストの末尾に到達してしまった場合は、 :exc:`ModuleNotFoundError` "
"を送出します。その他の送出された例外はそのまま呼び出し元に伝播され、インポート処理を異常終了させます。"

#: ../../reference/import.rst:294
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec()` method of meta path "
"finders is called with two or three arguments.  The first is the fully "
"qualified name of the module being imported, for example ``foo.bar.baz``. "
"The second argument is the path entries to use for the module search.  For "
"top-level modules, the second argument is ``None``, but for submodules or "
"subpackages, the second argument is the value of the parent package's "
"``__path__`` attribute. If the appropriate ``__path__`` attribute cannot be "
"accessed, a :exc:`ModuleNotFoundError` is raised.  The third argument is an "
"existing module object that will be the target of loading later. The import "
"system passes in a target module only during reload."
msgstr ""
"メタパス・ファインダーの :meth:`~importlib.abc.MetaPathFinder.find_spec()` メソッドは 2 つまたは "
"3 つの引数を渡して呼び出します。1 つ目の引数はインポートされるモジュールの完全修飾名で、例えば ``foo.bar.baz`` などです。2 "
"つ目の引数はモジュールの検索で使われるパスです。最上位のモジュールでは 2 つ目の引数は ``None`` "
"にしますが、サブモジュールやサブパッケージでは 2 つ目の引数は親パッケージの ``__path__`` 属性の値です。適切な ``__path__``"
" 属性にアクセスできなかった場合は、 :exc:`ModuleNotFoundError` が送出されます。3 "
"つ目の引数は、あとでロードされるターゲットとなる既存のモジュールオブジェクトです。インポートシステムはリロードの間だけターゲットモジュール "
"をセットします。"

#: ../../reference/import.rst:305
msgid ""
"The meta path may be traversed multiple times for a single import request. "
"For example, assuming none of the modules involved has already been cached, "
"importing ``foo.bar.baz`` will first perform a top level import, calling "
"``mpf.find_spec(\"foo\", None, None)`` on each meta path finder (``mpf``). "
"After ``foo`` has been imported, ``foo.bar`` will be imported by traversing "
"the meta path a second time, calling ``mpf.find_spec(\"foo.bar\", "
"foo.__path__, None)``. Once ``foo.bar`` has been imported, the final "
"traversal will call ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, "
"None)``."
msgstr ""
"メタパスは、1 回のインポート要求で複数回走査される可能性があります。例えば、関係するモジュールがどれもまだキャッシュされていないとしたときに "
"``foo.bar.baz`` をインポートすると、最初は各メタパス・ファインダー (``mpf``) に対して "
"``mpf.find_spec(\"foo\", None, None)`` を呼び出して、最上位のインポート処理を行います。``foo`` "
"がインポートされた後に、``mpf.find_spec(\"foo.bar\", foo.__path__, None)`` を呼び出していく 2 "
"回目のメタパスの走査が行われ、``foo.bar`` がインポートされます。``foo.bar`` のインポートまで行われたら、最後の走査で "
"``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)`` を呼び出していきます。"

#: ../../reference/import.rst:315
msgid ""
"Some meta path finders only support top level imports. These importers will "
"always return ``None`` when anything other than ``None`` is passed as the "
"second argument."
msgstr ""
"あるメタパス・ファインダーは最上位のインポートのみサポートしています。これらのインポーターは、2 つ目の引数に ``None`` "
"以外のものが渡されたとき、常に ``None`` を返します。"

#: ../../reference/import.rst:319
msgid ""
"Python's default :data:`sys.meta_path` has three meta path finders, one that"
" knows how to import built-in modules, one that knows how to import frozen "
"modules, and one that knows how to import modules from an :term:`import "
"path` (i.e. the :term:`path based finder`)."
msgstr ""
"Python のデフォルトの :data:`sys.meta_path` は 3 "
"つのパスファインダーを持っています。組み込みモジュールのインポートの方法を知っているもの、凍結されたモジュールのインポートの方法を知っているもの、 "
":term:`インポートパス <import path>` からのモジュールのインポートの方法を知っているもの (つまり "
":term:`パスベース・ファインダー <path based finder>`) があります。"

#: ../../reference/import.rst:324
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders replaced :meth:`~importlib.abc.MetaPathFinder.find_module`, which is"
" now deprecated.  While it will continue to work without change, the import "
"machinery will try it only if the finder does not implement ``find_spec()``."
msgstr ""
"メタパス・ファインダーの :meth:`~importlib.abc.MetaPathFinder.find_spec` メソッドは "
":meth:`~importlib.abc.MetaPathFinder.find_module` を置き換えました。 "
"``find_module()`` メソッドは deprecated です。それは今でも変更なしに動きますが、インポート機構はファインダーが "
"``find_spec()`` を実装していない場合にのみそれを試します。"

#: ../../reference/import.rst:333
msgid "Loading"
msgstr "ロード"

#: ../../reference/import.rst:335
msgid ""
"If and when a module spec is found, the import machinery will use it (and "
"the loader it contains) when loading the module.  Here is an approximation "
"of what happens during the loading portion of import::"
msgstr ""
"モジュール仕様が見つかった場合、インポート機構はモジュールをロードする時にそれ (およびそれに含まれるローダー) "
"を使います。これは、インポートのロード部分で起こることの近似です::"

#: ../../reference/import.rst:370
msgid "Note the following details:"
msgstr "以下の詳細に注意してください:"

#: ../../reference/import.rst:372
msgid ""
"If there is an existing module object with the given name in "
":data:`sys.modules`, import will have already returned it."
msgstr ""
":data:`sys.modules` の中に与えられた名前を持つ既存のモジュールオブジェクトがあるなら、 import "
"は既にそれを返しているでしょう。"

#: ../../reference/import.rst:375
msgid ""
"The module will exist in :data:`sys.modules` before the loader executes the "
"module code.  This is crucial because the module code may (directly or "
"indirectly) import itself; adding it to :data:`sys.modules` beforehand "
"prevents unbounded recursion in the worst case and multiple loading in the "
"best."
msgstr ""
"モジュールは、ローダーがモジュールコードを実行する前に :data:`sys.modules` に存在しています。 モジュールコードが "
"(直接的または間接的に) 自分自身をインポートする可能性があるので、これは重要です; モジュールを :data:`sys.modules` "
"に追加することで、最悪のケースでは無限の再帰が、そして最良のケースでは複数回のロードが、前もって防止されます。"

#: ../../reference/import.rst:381
msgid ""
"If loading fails, the failing module -- and only the failing module -- gets "
"removed from :data:`sys.modules`.  Any module already in the "
":data:`sys.modules` cache, and any module that was successfully loaded as a "
"side-effect, must remain in the cache.  This contrasts with reloading where "
"even the failing module is left in :data:`sys.modules`."
msgstr ""
"ロード処理に失敗した場合、その失敗したモジュールは -- そして、そのモジュールだけが -- :data:`sys.modules` "
"から取り除かれます。 :data:`sys.modules` "
"キャッシュに既に含まれていたすべてのモジュールと、副作用としてロードに成功したすべてのモジュールは、常にキャッシュに残されます。これはリロードとは対照的で、リロードの場合は失敗したモジュールも"
" :data:`sys.modules` に残されます。"

#: ../../reference/import.rst:387
msgid ""
"After the module is created but before execution, the import machinery sets "
"the import-related module attributes (\"_init_module_attrs\" in the pseudo-"
"code example above), as summarized in a :ref:`later section <import-mod-"
"attrs>`."
msgstr ""
":ref:`後のセクション <import-mod-attrs>` "
"で要約されるように、モジュールが作られてから実行されるまでの間にインポート機構はインポート関連のモジュール属性を設定します (上記擬似コード例の "
"\"_init_module_attrs\")。"

#: ../../reference/import.rst:392
msgid ""
"Module execution is the key moment of loading in which the module's "
"namespace gets populated.  Execution is entirely delegated to the loader, "
"which gets to decide what gets populated and how."
msgstr ""
"モジュール実行はモジュールの名前空間が構築されるロードの重要な瞬間です。実行はローダーに完全に委任され、ローダーは何をどのように構築するかを決定することになります。"

#: ../../reference/import.rst:396
msgid ""
"The module created during loading and passed to exec_module() may not be the"
" one returned at the end of import [#fnlo]_."
msgstr ""
"ロードの間に作成されて exec_module() に渡されたモジュールは、インポートの終わりに返されるものとは異なるかもしれません [#fnlo]_。"

#: ../../reference/import.rst:399
msgid ""
"The import system has taken over the boilerplate responsibilities of "
"loaders.  These were previously performed by the "
":meth:`importlib.abc.Loader.load_module` method."
msgstr ""
"インポートシステムはローダーの定型的な責任を引き継ぎました。これらは以前は "
":meth:`importlib.abc.Loader.load_module` メソッドによって実行されました。"

#: ../../reference/import.rst:405
msgid "Loaders"
msgstr "ローダー"

#: ../../reference/import.rst:407
msgid ""
"Module loaders provide the critical function of loading: module execution. "
"The import machinery calls the :meth:`importlib.abc.Loader.exec_module` "
"method with a single argument, the module object to execute.  Any value "
"returned from :meth:`~importlib.abc.Loader.exec_module` is ignored."
msgstr ""
"モジュールローダーは、ロードの重要な機能であるモジュール実行機能を提供します。インポート機構は、実行しようとするモジュールオブジェクトを単一の引数として"
" :meth:`importlib.abc.Loader.exec_module` メソッドを呼び出します。 "
":meth:`importlib.abc.Loader.exec_module` から返された任意の値は無視されます。"

#: ../../reference/import.rst:412
msgid "Loaders must satisfy the following requirements:"
msgstr "ローダーは以下の仕様を満たしていなければいけません:"

#: ../../reference/import.rst:414
msgid ""
"If the module is a Python module (as opposed to a built-in module or a "
"dynamically loaded extension), the loader should execute the module's code "
"in the module's global name space (``module.__dict__``)."
msgstr ""
"モジュールが (組み込みモジュールや動的に読み込まれる拡張モジュールではなくて) Python "
"モジュールだった場合、ローダーはモジュールのグローバル名前空間 (``module.__dict__``) で、モジュールのコードを実行すべきです。"

#: ../../reference/import.rst:418
msgid ""
"If the loader cannot execute the module, it should raise an "
":exc:`ImportError`, although any other exception raised during "
":meth:`~importlib.abc.Loader.exec_module` will be propagated."
msgstr ""
":meth:`~importlib.abc.Loader.exec_module` の呼び出し中に :exc:`ImportError` "
"以外の例外が送出され、伝播されてきたとしても、モジュールをロードできない場合は :exc:`ImportError` を送出すべきです。"

#: ../../reference/import.rst:422
msgid ""
"In many cases, the finder and loader can be the same object; in such cases "
"the :meth:`~importlib.abc.MetaPathFinder.find_spec` method would just return"
" a spec with the loader set to ``self``."
msgstr ""
"多くの場合、ファインダーとローダーは同じオブジェクトで構いません; そのような場合では "
":meth:`~importlib.abc.MetaPathFinder.find_spec` メソッドは単に ``self`` (訳注: "
"オブジェクト自身) を返すだけです。"

#: ../../reference/import.rst:426
msgid ""
"Module loaders may opt in to creating the module object during loading by "
"implementing a :meth:`~importlib.abc.Loader.create_module` method. It takes "
"one argument, the module spec, and returns the new module object to use "
"during loading.  ``create_module()`` does not need to set any attributes on "
"the module object.  If the method returns ``None``, the import machinery "
"will create the new module itself."
msgstr ""
"モジュールローダーは、 :meth:`~importlib.abc.Loader.create_module` "
"メソッドを実装することでロード中にモジュールオブジェクトを作成することを選択できます。このメソッドは、モジュール仕様を引数に取って、ロード中に使う新しいモジュールオブジェクトを返します。"
" ``create_module()`` はモジュールオブジェクトに属性を設定する必要はありません。もしこのメソッドが ``None`` "
"を返すなら、インポート機構は新しいモジュールを自身で作成します。"

#: ../../reference/import.rst:433
msgid "The :meth:`~importlib.abc.Loader.create_module` method of loaders."
msgstr "ローダーの :meth:`~importlib.abc.Loader.create_module` メソッド。"

#: ../../reference/import.rst:436
msgid ""
"The :meth:`~importlib.abc.Loader.load_module` method was replaced by "
":meth:`~importlib.abc.Loader.exec_module` and the import machinery assumed "
"all the boilerplate responsibilities of loading."
msgstr ""
":meth:`~importlib.abc.Loader.load_module` メソッドは "
":meth:`~importlib.abc.Loader.exec_module` "
"によって置き換えられ、インポート機構がロードのすべての定型責任を引き受けました。"

#: ../../reference/import.rst:441
msgid ""
"For compatibility with existing loaders, the import machinery will use the "
"``load_module()`` method of loaders if it exists and the loader does not "
"also implement ``exec_module()``.  However, ``load_module()`` has been "
"deprecated and loaders should implement ``exec_module()`` instead."
msgstr ""
"既存のローダーとの互換性のため、もしローダーに ``load_module()`` メソッドが存在し、かつローダーが ``exec_module()``"
" を実装していなければ、インポート機構はローダーの ``load_module()`` メソッドを使います。しかし、 ``load_module()``"
" は deprecated であり、ローダーは代わりに ``exec_module()`` を実装すべきです。"

#: ../../reference/import.rst:446
msgid ""
"The ``load_module()`` method must implement all the boilerplate loading "
"functionality described above in addition to executing the module.  All the "
"same constraints apply, with some additional clarification:"
msgstr ""
"``load_module()`` "
"メソッドは、モジュールを実行することに加えて上記で説明されたすべての定型的なロード機能を実施しなければなりません。同じ制約が適用されます。以下は追加の明確化です:"

#: ../../reference/import.rst:450
msgid ""
"If there is an existing module object with the given name in "
":data:`sys.modules`, the loader must use that existing module. (Otherwise, "
":func:`importlib.reload` will not work correctly.)  If the named module does"
" not exist in :data:`sys.modules`, the loader must create a new module "
"object and add it to :data:`sys.modules`."
msgstr ""
":data:`sys.modules` に与えられた名前のモジュールが存在している場合、ローダーはその既存のモジュールを使わなければいけません。 "
"(そうしないと :func:`importlib.reload` は正しく動かないでしょう。) 指定されたモジュールが "
":data:`sys.modules` に存在しない場合、ローダーは新しいモジュールオブジェクトを作成し、 :data:`sys.modules` "
"に追加しなければいけません。"

#: ../../reference/import.rst:456
msgid ""
"The module *must* exist in :data:`sys.modules` before the loader executes "
"the module code, to prevent unbounded recursion or multiple loading."
msgstr ""
"無限の再帰または複数回のロードを防止するために、ローダーがモジュールコードを実行する前にモジュールは :data:`sys.modules` "
"に存在しなければなりません (*must*)。"

#: ../../reference/import.rst:460
msgid ""
"If loading fails, the loader must remove any modules it has inserted into "
":data:`sys.modules`, but it must remove **only** the failing module(s), and "
"only if the loader itself has loaded the module(s) explicitly."
msgstr ""
"ロード処理に失敗した場合、ローダーは :data:`sys.modules` "
"に追加したモジュールを取り除かなければいけませんが、それはロードに失敗したモジュール **のみ** "
"を、そのモジュールがローダー自身に明示的にロードされた場合に限り、除去しなければなりません。"

#: ../../reference/import.rst:465
msgid ""
"A :exc:`DeprecationWarning` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"``exec_module()`` が定義されていて ``create_module()`` が定義されていない場合、 "
":exc:`DeprecationWarning` が送出されるようになりました。"

#: ../../reference/import.rst:469
msgid ""
"An :exc:`ImportError` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"``exec_module()`` が定義されていて ``create_module()`` が定義されていない場合、 "
":exc:`ImportError` が送出されるようになりました。"

#: ../../reference/import.rst:474
msgid "Submodules"
msgstr "サブモジュール"

#: ../../reference/import.rst:476
msgid ""
"When a submodule is loaded using any mechanism (e.g. ``importlib`` APIs, the"
" ``import`` or ``import-from`` statements, or built-in ``__import__()``) a "
"binding is placed in the parent module's namespace to the submodule object. "
"For example, if package ``spam`` has a submodule ``foo``, after importing "
"``spam.foo``, ``spam`` will have an attribute ``foo`` which is bound to the "
"submodule.  Let's say you have the following directory structure::"
msgstr ""
"サブモジュールをロードするのにどのようなメカニズム (例えば、 ``importlib`` API 、 ``import`` または ``import-"
"from`` ステートメント、またはビルトイン関数の ``__import__``) "
"が使われた場合でも、バインディングはサブモジュールオブジェクトを親モジュールの名前空間に配置します。例えば、もしパッケージ ``spam`` "
"がサブモジュール ``foo`` を持っていた場合、 ``spam.foo`` をインポートした後は ``spam`` "
"は値がサブモジュールに束縛された属性 ``foo`` を持ちます。以下のディレクトリ構造を持っているとしましょう::"

#: ../../reference/import.rst:488
msgid "and ``spam/__init__.py`` has the following lines in it::"
msgstr "そして ``spam/__init__.py`` は以下のようになっているとします::"

#: ../../reference/import.rst:493
msgid ""
"then executing the following puts a name binding to ``foo`` and ``bar`` in "
"the ``spam`` module::"
msgstr ""
"このとき、以下を実行することにより ``spam`` モジュールの中に ``foo`` と ``bar`` に束縛された名前が置かれます::"

#: ../../reference/import.rst:502
msgid ""
"Given Python's familiar name binding rules this might seem surprising, but "
"it's actually a fundamental feature of the import system.  The invariant "
"holding is that if you have ``sys.modules['spam']`` and "
"``sys.modules['spam.foo']`` (as you would after the above import), the "
"latter must appear as the ``foo`` attribute of the former."
msgstr ""
"Python "
"の慣れ親しんだ名前束縛ルールからするとこれは驚きかもしれませんが、それは実際インポートシステムの基本的な機能です。不変に保たなければならないのは "
"(上記のインポートの後などで) ``sys.modules['spam']`` と ``sys.modules['spam.foo']`` "
"が存在する場合、後者が前者の ``foo`` 属性として存在しなければならないということです。"

#: ../../reference/import.rst:509
msgid "Module spec"
msgstr "モジュール仕様"

#: ../../reference/import.rst:511
msgid ""
"The import machinery uses a variety of information about each module during "
"import, especially before loading.  Most of the information is common to all"
" modules.  The purpose of a module's spec is to encapsulate this import-"
"related information on a per-module basis."
msgstr ""
"インポート機構は、インポートの間 (特にロードの前) "
"に、個々のモジュールについてのさまざまな情報を扱います。情報のほとんどはすべてのモジュールで共通です。モジュール仕様の目的は、このインポート関連の情報をモジュールの単位でカプセル化することです。"

#: ../../reference/import.rst:516
msgid ""
"Using a spec during import allows state to be transferred between import "
"system components, e.g. between the finder that creates the module spec and "
"the loader that executes it.  Most importantly, it allows the import "
"machinery to perform the boilerplate operations of loading, whereas without "
"a module spec the loader had that responsibility."
msgstr ""
"インポートの際にモジュール仕様を使うことは、インポートシステムコンポーネント間、例えばモジュール仕様を作成するファインダーとそれを実行するローダーの間で状態を転送することを可能にします。最も重要なのは、それによってインポート機構がロードの定型的な作業を実行できるようになるということです。これに対して、モジュール仕様なしではローダがその責任を担っていました。"

#: ../../reference/import.rst:522
msgid ""
"The module's spec is exposed as the ``__spec__`` attribute on a module "
"object. See :class:`~importlib.machinery.ModuleSpec` for details on the "
"contents of the module spec."
msgstr ""
"モジュール仕様は、モジュールオブジェクトの ``__spec__`` 属性として公開されます。\n"
"モジュール仕様の内容の詳細については :class:`~importlib.machinery.ModuleSpec` を参照してください。"

#: ../../reference/import.rst:531
msgid "Import-related module attributes"
msgstr "インポート関連のモジュール属性"

#: ../../reference/import.rst:533
msgid ""
"The import machinery fills in these attributes on each module object during "
"loading, based on the module's spec, before the loader executes the module."
msgstr "インポート機構はロードの間、モジュールの仕様に基づいて、ローダーがモジュールが実行する前に以下の属性を書き込みます。"

#: ../../reference/import.rst:539
msgid ""
"The ``__name__`` attribute must be set to the fully-qualified name of the "
"module.  This name is used to uniquely identify the module in the import "
"system."
msgstr ""
"``__name__`` 属性はモジュールの完全修飾名に設定されなければなりません。この名前を利用してインポートシステムでモジュールを一意に識別します。"

#: ../../reference/import.rst:545
msgid ""
"The ``__loader__`` attribute must be set to the loader object that the "
"import machinery used when loading the module.  This is mostly for "
"introspection, but can be used for additional loader-specific functionality,"
" for example getting data associated with a loader."
msgstr ""
"``__loader__`` "
"属性はモジュールロード時にインポート機構が使用したローダーオブジェクトに設定されなければなりません。この属性は普通は内省用のものですが、ローダー固有の追加機能のために用いることが出来ます。例えばローダー関連のデータの取得です。"

#: ../../reference/import.rst:552
msgid ""
"The module's ``__package__`` attribute must be set.  Its value must be a "
"string, but it can be the same value as its ``__name__``.  When the module "
"is a package, its ``__package__`` value should be set to its ``__name__``.  "
"When the module is not a package, ``__package__`` should be set to the empty"
" string for top-level modules, or for submodules, to the parent package's "
"name.  See :pep:`366` for further details."
msgstr ""
"モジュールの ``__package__`` 属性は設定されなければなりません。値は文字列でなければなりませんが、``__name__`` "
"と同じ値でも構いません。モジュールがパッケージの場合、``__package__`` の値はその ``__name__`` "
"でなければなりません。モジュールがパッケージでない場合、トップレベルのモジュールでは ``__package__`` "
"空の文字列、サブモジュールでは親のパッケージ名でなければなりません。詳細は :pep:`366` を参照してください。"

#: ../../reference/import.rst:560
msgid ""
"This attribute is used instead of ``__name__`` to calculate explicit "
"relative imports for main modules, as defined in :pep:`366`. It is expected "
"to have the same value as ``__spec__.parent``."
msgstr ""
"この属性は :pep:`366` で定義されているように、メインモジュールからの明示的な相対インポートを計算するために、 ``__name__`` の代わりに使用されます。\n"
"この属性は ``__spec__.parent`` と同じ値を持つことを要求されます。"

#: ../../reference/import.rst:564
msgid ""
"The value of ``__package__`` is expected to be the same as "
"``__spec__.parent``."
msgstr "``__package__`` の値が ``__spec__.parent`` と同じ値を持つことを要求されるようになりました。"

#: ../../reference/import.rst:570
msgid ""
"The ``__spec__`` attribute must be set to the module spec that was used when"
" importing the module. Setting ``__spec__`` appropriately applies equally to"
" :ref:`modules initialized during interpreter startup <programs>`.  The one "
"exception is ``__main__``, where ``__spec__`` is :ref:`set to None in some "
"cases <main_spec>`."
msgstr ""
"``__spec__`` 属性はモジュールロード時に使用されたモジュールスペックに設定されなければなりません。\n"
"``__spec__`` を適切に設定すると :ref:`インタープリタ起動中に初期化されるモジュール <programs>` にも同様に適用されます。\n"
"例外は ``__main__`` で、``__spec__`` は :ref:`場合によっては None に設定されます <main_spec>`。"

#: ../../reference/import.rst:576
msgid ""
"When ``__package__`` is not defined, ``__spec__.parent`` is used as a "
"fallback."
msgstr "``__package__`` が定義されていないときは ``__spec__.parent`` がフォールバックとして使われます。"

#: ../../reference/import.rst:581
msgid ""
"``__spec__.parent`` is used as a fallback when ``__package__`` is not "
"defined."
msgstr ""
"``__package__`` が定義されていないときに ``__spec__.parent`` がフォールバックとして使われるようになりました。"

#: ../../reference/import.rst:587
msgid ""
"If the module is a package (either regular or namespace), the module "
"object's ``__path__`` attribute must be set.  The value must be iterable, "
"but may be empty if ``__path__`` has no further significance. If "
"``__path__`` is not empty, it must produce strings when iterated over. More "
"details on the semantics of ``__path__`` are given :ref:`below <package-"
"path-rules>`."
msgstr ""
"モジュールが (通常のまたは名前空間) パッケージの場合、モジュールオブジェクトの  ``__path__`` "
"属性が設定される必要があります。値はイテレート可能でなければなりませんが、``__path__`` "
"に意味がない場合は空でも構いません。``__path__`` が空でない場合、イテレート時に文字列を生成しなければなりません。``__path__`` "
"のセマンティクスの詳細は  :ref:`下記 <package-path-rules>` の通りです。"

#: ../../reference/import.rst:594
msgid "Non-package modules should not have a ``__path__`` attribute."
msgstr "パッケージでないモジュールは ``__path__`` 属性を持ってはいけません。"

#: ../../reference/import.rst:599
msgid ""
"``__file__`` is optional. If set, this attribute's value must be a string.  "
"The import system may opt to leave ``__file__`` unset if it has no semantic "
"meaning (e.g. a module loaded from a database)."
msgstr ""
"``__file__`` はオプションです。もし設定されるならば、この属性の値は文字列でなければなりません。もしそのような属性が意味を持たない場合 "
"(例えばモジュールがデータベースからロードされた場合) インポートシステムは ``__file__`` を未設定のままにしても構いません。"

#: ../../reference/import.rst:603
msgid ""
"If ``__file__`` is set, it may also be appropriate to set the ``__cached__``"
" attribute which is the path to any compiled version of the code (e.g. byte-"
"compiled file). The file does not need to exist to set this attribute; the "
"path can simply point to where the compiled file would exist (see "
":pep:`3147`)."
msgstr ""
"もし ``__file__`` を設定するなら、 ``__cached__`` 属性もコードのコンパイルされたバージョンのどれか "
"(例えば、バイトコンパイルされたファイル) へのパスに設定することが適切でしょう。この属性を設定するにあたってファイルが存在する必要はありません; "
"パスは、単にコンパイルされたファイルが存在するかもしれない場所を示しているだけです (:pep:`3147` を参照)。"

#: ../../reference/import.rst:609
msgid ""
"It is also appropriate to set ``__cached__`` when ``__file__`` is not set.  "
"However, that scenario is quite atypical.  Ultimately, the loader is what "
"makes use of ``__file__`` and/or ``__cached__``.  So if a loader can load "
"from a cached module but otherwise does not load from a file, that atypical "
"scenario may be appropriate."
msgstr ""
"``__file__`` が設定されない場合にも ``__cached__`` "
"を設定することは適切です。しかし、そのシナリオはかなり変則的です。究極的には、ローダーとは ``__file__`` と ``__cached__`` "
"のどちらかまたは両方を利用するものです。したがって、もしローダーがキャッシュされたモジュールからロードする一方でファイルからはロードしないなら、その変則的なシナリオは適切でしょう。"

#: ../../reference/import.rst:618
msgid "module.__path__"
msgstr "module.__path__"

#: ../../reference/import.rst:620
msgid ""
"By definition, if a module has a ``__path__`` attribute, it is a package."
msgstr ""

#: ../../reference/import.rst:622
msgid ""
"A package's ``__path__`` attribute is used during imports of its "
"subpackages. Within the import machinery, it functions much the same as "
":data:`sys.path`, i.e. providing a list of locations to search for modules "
"during import. However, ``__path__`` is typically much more constrained than"
" :data:`sys.path`."
msgstr ""
"パッケージの ``__path__`` 属性は、そのサブパッケージのインポート中に使われます。インポート機構の内部では、それは "
":data:`sys.path` とほとんど同じように機能します。つまり、インポート中にモジュールを探す場所のリストを提供します。しかし、一般的に "
"``__path__`` は :data:`sys.path` よりも制約が強いです。"

#: ../../reference/import.rst:628
msgid ""
"``__path__`` must be an iterable of strings, but it may be empty. The same "
"rules used for :data:`sys.path` also apply to a package's ``__path__``, and "
":data:`sys.path_hooks` (described below) are consulted when traversing a "
"package's ``__path__``."
msgstr ""
"``__path__`` は文字列の iterable でなければいけませんが、空でも構いません。 :data:`sys.path` "
"と同じ規則がパッケージの ``__path__`` にも適用され、パッケージの ``__path__`` を走査するときに (後で解説する) "
":data:`sys.path_hooks` が考慮に入れられます。"

#: ../../reference/import.rst:633
msgid ""
"A package's ``__init__.py`` file may set or alter the package's ``__path__``"
" attribute, and this was typically the way namespace packages were "
"implemented prior to :pep:`420`.  With the adoption of :pep:`420`, namespace"
" packages no longer need to supply ``__init__.py`` files containing only "
"``__path__`` manipulation code; the import machinery automatically sets "
"``__path__`` correctly for the namespace package."
msgstr ""
"パッケージの ``__init__.py`` ファイルは、パッケージの ``__path__`` 属性を設定もしくは変更することがあり、これが "
":pep:`420` 以前の名前空間パッケージの典型的な実装方法でした。 :pep:`420` の採択により、もはや名前空間パッケージは、 "
"``__path__`` を操作するコードだけを含む ``__init__.py`` "
"ファイルを提供する必要がなくなりました;インポート機構は、名前空間パッケージに対し自動的に適切な ``__path__`` をセットします。"

#: ../../reference/import.rst:641
msgid "Module reprs"
msgstr "モジュールの repr"

#: ../../reference/import.rst:643
msgid ""
"By default, all modules have a usable repr, however depending on the "
"attributes set above, and in the module's spec, you can more explicitly "
"control the repr of module objects."
msgstr ""
"デフォルトでは、すべてのモジュールは利用可能な repr "
"を持っています。ただしこれは上位で設定された属性に依存しており、モジュール仕様によってモジュールオブジェクトの repr "
"をより明示的に制御することができます。"

#: ../../reference/import.rst:647
msgid ""
"If the module has a spec (``__spec__``), the import machinery will try to "
"generate a repr from it.  If that fails or there is no spec, the import "
"system will craft a default repr using whatever information is available on "
"the module.  It will try to use the ``module.__name__``, "
"``module.__file__``, and ``module.__loader__`` as input into the repr, with "
"defaults for whatever information is missing."
msgstr ""
"もしモジュールが仕様 (``__spec__``) を持っていれば、インポート機構はそこから repr "
"を生成しようとします。もしそれが失敗するか、または仕様が存在しなければ、インポートシステムはモジュールで入手可能なあらゆる情報を使ってデフォルトの "
"repr を構築します。それは ``module.__name__``, ``module.__file__``, "
"``module.__loader__`` を (足りない情報についてはデフォルト値を使って補いながら) repr への入力として使おうと試みます。"

#: ../../reference/import.rst:654
msgid "Here are the exact rules used:"
msgstr "これが使われている正確な規則です:"

#: ../../reference/import.rst:656
msgid ""
"If the module has a ``__spec__`` attribute, the information in the spec is "
"used to generate the repr.  The \"name\", \"loader\", \"origin\", and "
"\"has_location\" attributes are consulted."
msgstr ""
"モジュールが ``__spec__`` 属性を持っていれば、仕様に含まれる情報が repr を生成するために使われます。 \"name\", "
"\"loader\", \"origin\", \"has_location\" 属性が参照されます。"

#: ../../reference/import.rst:660
msgid ""
"If the module has a ``__file__`` attribute, this is used as part of the "
"module's repr."
msgstr "モジュールに ``__file__`` 属性がある場合は、モジュールの repr の一部として使われます。"

#: ../../reference/import.rst:663
msgid ""
"If the module has no ``__file__`` but does have a ``__loader__`` that is not"
" ``None``, then the loader's repr is used as part of the module's repr."
msgstr ""
"モジュールに ``__file__`` はないが ``__loader__`` があり、その値が ``None`` ではない場合は、ローダーの repr"
" がモジュールの repr の一部として使われます。"

#: ../../reference/import.rst:666
msgid "Otherwise, just use the module's ``__name__`` in the repr."
msgstr "そうでなければ、単にモジュールの ``__name__`` を repr の中で使います。"

#: ../../reference/import.rst:668
msgid ""
"Use of :meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` has "
"been deprecated and the module spec is now used by the import machinery to "
"generate a module repr."
msgstr ""
":meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` の使用は "
"deprecated です。インポート機構によりモジュール仕様がモジュール repr を生成するために使用されるようになりました。"

#: ../../reference/import.rst:673
msgid ""
"For backward compatibility with Python 3.3, the module repr will be "
"generated by calling the loader's :meth:`~importlib.abc.Loader.module_repr` "
"method, if defined, before trying either approach described above.  However,"
" the method is deprecated."
msgstr ""
"Python 3.3 との後方互換性のために、ローダーの :meth:`~importlib.abc.Loader.module_repr` "
"メソッドが定義されていたら、モジュール repr を生成するために上記のいずれかのアプローチを試す前にそのメソッドが呼ばれます。ただし、このメソッドは "
"deprecated です。"

#: ../../reference/import.rst:680
msgid "The Path Based Finder"
msgstr "パスベース・ファインダー"

#: ../../reference/import.rst:685
msgid ""
"As mentioned previously, Python comes with several default meta path "
"finders. One of these, called the :term:`path based finder` "
"(:class:`~importlib.machinery.PathFinder`), searches an :term:`import path`,"
" which contains a list of :term:`path entries <path entry>`.  Each path "
"entry names a location to search for modules."
msgstr ""
"上で触れた通り、 Python にはいくつかのデフォルトのメタパス・ファインダーが備わっています。そのうちの 1 つは "
":term:`パスベース・ファインダー <path based finder>` "
"(:class:`~importlib.machinery.PathFinder`) と呼ばれ、 :term:`パスエントリ <path entry>`"
" のリストである :term:`インポートパス <import path>` "
"を検索します。それぞれのパスエントリは、モジュールを探す場所を指しています。"

#: ../../reference/import.rst:691
msgid ""
"The path based finder itself doesn't know how to import anything. Instead, "
"it traverses the individual path entries, associating each of them with a "
"path entry finder that knows how to handle that particular kind of path."
msgstr ""
"パスベース・ファインダー自体は何かのインポート方法を知っているわけではありません。その代わりに、個々のパスエントリを走査し、それぞれに特定の種類のパスの扱いを知っているパスエントリ・ファインダーを関連付けます。"

#: ../../reference/import.rst:695
msgid ""
"The default set of path entry finders implement all the semantics for "
"finding modules on the file system, handling special file types such as "
"Python source code (``.py`` files), Python byte code (``.pyc`` files) and "
"shared libraries (e.g. ``.so`` files). When supported by the "
":mod:`zipimport` module in the standard library, the default path entry "
"finders also handle loading all of these file types (other than shared "
"libraries) from zipfiles."
msgstr ""
"デフォルトのパスエントリ・ファインダーは、ファイルシステム上のモジュールを見つけるためのすべてのセマンティクスを実装しています。それは Python "
"ソースコード (``.py`` ファイル) 、Python バイトコード (``.pyc`` ファイル) 、共有ライブラリ (例えば ``.so`` "
"ファイル) などの特別なファイルタイプを処理します。標準ライブラリの :mod:`zipimport` "
"モジュールによってサポートされる場合は、デフォルトのパスエントリ・ファインダーは (共有ライブラリ以外の) すべてのファイルタイプの zip "
"ファイルからのロードも扱います。"

#: ../../reference/import.rst:702
msgid ""
"Path entries need not be limited to file system locations.  They can refer "
"to URLs, database queries, or any other location that can be specified as a "
"string."
msgstr ""
"パスエントリはファイルシステム上の場所に限定される必要はありません。URL やデータベースクエリやその他文字列で指定できる場所を参照することも可能です。"

#: ../../reference/import.rst:706
msgid ""
"The path based finder provides additional hooks and protocols so that you "
"can extend and customize the types of searchable path entries.  For example,"
" if you wanted to support path entries as network URLs, you could write a "
"hook that implements HTTP semantics to find modules on the web.  This hook "
"(a callable) would return a :term:`path entry finder` supporting the "
"protocol described below, which was then used to get a loader for the module"
" from the web."
msgstr ""
"パスベース・ファインダーにはフックやプロトコルを追加することができ、それによって検索可能なパスエントリの種類を拡張し、カスタマイズすることができます。例えば、ネットワーク上の"
" URL をパスエントリとしてサポートしたい場合、 web 上のモジュールを見つけるために HTTP "
"の取り扱い方を実装したフックを書くことができます。この (呼び出し可能オブジェクトである) フックは、下で解説するプロトコルをサポートする "
":term:`パスエントリ・ファインダー <path entry finder>` を返します。このプロトコルは  web "
"からモジュールのローダーを取得するのに使われます。"

#: ../../reference/import.rst:714
msgid ""
"A word of warning: this section and the previous both use the term *finder*,"
" distinguishing between them by using the terms :term:`meta path finder` and"
" :term:`path entry finder`.  These two types of finders are very similar, "
"support similar protocols, and function in similar ways during the import "
"process, but it's important to keep in mind that they are subtly different. "
"In particular, meta path finders operate at the beginning of the import "
"process, as keyed off the :data:`sys.meta_path` traversal."
msgstr ""
"警告の言葉: この節と前の節の両方で *ファインダー* という言葉が、 :term:`メタパス・ファインダー <meta path finder>` と"
" :term:`パスエントリ・ファインダー <path entry finder>` という用語で区別されて使われています。これら 2 "
"種類のファインダーは非常に似ており、似たプロトコルをサポートし、インポート処理で同じように機能しますが、微妙に異なっているのを心に留めておくのは重要です。特に、メタパス・ファインダーはインポート処理の開始時、"
" :data:`sys.meta_path` の走査が動くときに動作します。"

#: ../../reference/import.rst:722
msgid ""
"By contrast, path entry finders are in a sense an implementation detail of "
"the path based finder, and in fact, if the path based finder were to be "
"removed from :data:`sys.meta_path`, none of the path entry finder semantics "
"would be invoked."
msgstr ""
"それとは対照的に、パスエントリ・ファインダーはある意味でパスベース・ファインダーの実装詳細であり、実際 :data:`sys.meta_path` "
"からパスベース・ファインダーが取り除かれた場合、パスエントリ・ファインダーの実装は何も実行されないでしょう。"

#: ../../reference/import.rst:729
msgid "Path entry finders"
msgstr "パスエントリ・ファインダー"

#: ../../reference/import.rst:737
msgid ""
"The :term:`path based finder` is responsible for finding and loading Python "
"modules and packages whose location is specified with a string :term:`path "
"entry`.  Most path entries name locations in the file system, but they need "
"not be limited to this."
msgstr ""
":term:`パスベース・ファインダー <path based finder>` には、文字列 :term:`パスエントリ <path entry>` "
"で指定された場所の Python モジュールや Python "
"パッケージを見つけ、ロードする責任があります。ほとんどのパスエントリはファイルシステム上の場所を指定していますが、そこに制限される必要はありません。"

#: ../../reference/import.rst:742
msgid ""
"As a meta path finder, the :term:`path based finder` implements the "
":meth:`~importlib.abc.MetaPathFinder.find_spec` protocol previously "
"described, however it exposes additional hooks that can be used to customize"
" how modules are found and loaded from the :term:`import path`."
msgstr ""
"メタパス・ファインダーとして、 :term:`パスベース・ファインダー <path based finder>` には前に解説した "
":meth:`~importlib.abc.MetaPathFinder.find_spec` プロトコルが実装されていますが、これに加えて "
":term:`インポートパス <import path>` からモジュールを見つけ、ロードする方法をカスタマイズするために使えるフックを提供しています。"

#: ../../reference/import.rst:747
msgid ""
"Three variables are used by the :term:`path based finder`, :data:`sys.path`,"
" :data:`sys.path_hooks` and :data:`sys.path_importer_cache`.  The "
"``__path__`` attributes on package objects are also used.  These provide "
"additional ways that the import machinery can be customized."
msgstr ""
":term:`パスベース・ファインダー <path based finder>` は :data:`sys.path` 、 "
":data:`sys.path_hooks` 、 :data:`sys.path_importer_cache` という 3 "
"つの変数を使います。さらにパッケージオブジェクトの ``__path__`` "
"属性も使います。これらによって、インポート処理をカスタマイズする方法が提供されます。"

#: ../../reference/import.rst:752
msgid ""
":data:`sys.path` contains a list of strings providing search locations for "
"modules and packages.  It is initialized from the :data:`PYTHONPATH` "
"environment variable and various other installation- and implementation-"
"specific defaults.  Entries in :data:`sys.path` can name directories on the "
"file system, zip files, and potentially other \"locations\" (see the "
":mod:`site` module) that should be searched for modules, such as URLs, or "
"database queries.  Only strings and bytes should be present on "
":data:`sys.path`; all other data types are ignored.  The encoding of bytes "
"entries is determined by the individual :term:`path entry finders <path "
"entry finder>`."
msgstr ""
":data:`sys.path` には、モジュールとパッケージを探す場所文字列の一覧があります。これは :data:`PYTHONPATH` "
"環境変数とその他様々なインストール方法や実装に依存するデフォルト値で初期化されます。 :data:`sys.path` "
"内の要素は、ファイルシステム上のディレクトリや zip ファイルやその他モジュールを探すべき \"場所\" となりうるもの (:mod:`site` "
"モジュールを参照) を指すことができます。文字列およびバイト列のみを :data:`sys.path` に入れるべきです; "
"他のデータ型は無視されます。バイト列の要素のエンコーディングは、各 :term:`パスエントリ・ファインダー <path entry finder>` "
"によって判別されます。"

#: ../../reference/import.rst:763
msgid ""
"The :term:`path based finder` is a :term:`meta path finder`, so the import "
"machinery begins the :term:`import path` search by calling the path based "
"finder's :meth:`~importlib.machinery.PathFinder.find_spec` method as "
"described previously.  When the ``path`` argument to "
":meth:`~importlib.machinery.PathFinder.find_spec` is given, it will be a "
"list of string paths to traverse - typically a package's ``__path__`` "
"attribute for an import within that package.  If the ``path`` argument is "
"``None``, this indicates a top level import and :data:`sys.path` is used."
msgstr ""
":term:`パスベース・ファインダー <path based finder>` は :term:`メタパス・ファインダー <meta path "
"finder>` なので、インポート機構は、前で解説したパスベース・ファインダーの "
":meth:`~importlib.machinery.PathFinder.find_spec`  メソッドを呼び出すことで "
":term:`インポートパス <import path>` の検索を始めます。 ``path`` 引数が "
":meth:`~importlib.machinery.PathFinder.find_spec` に渡されたときは、それは走査するパス文字列のリスト "
"- 典型的にはそのパッケージの中でインポートしているパッケージの ``__path__`` 属性になります。 ``path`` 引数が ``None``"
" だった場合、それは最上位のインポートであることを示していて、 :data:`sys.path` が使われます。"

#: ../../reference/import.rst:772
msgid ""
"The path based finder iterates over every entry in the search path, and for "
"each of these, looks for an appropriate :term:`path entry finder` "
"(:class:`~importlib.abc.PathEntryFinder`) for the path entry.  Because this "
"can be an expensive operation (e.g. there may be `stat()` call overheads for"
" this search), the path based finder maintains a cache mapping path entries "
"to path entry finders.  This cache is maintained in "
":data:`sys.path_importer_cache` (despite the name, this cache actually "
"stores finder objects rather than being limited to :term:`importer` "
"objects). In this way, the expensive search for a particular :term:`path "
"entry` location's :term:`path entry finder` need only be done once.  User "
"code is free to remove cache entries from :data:`sys.path_importer_cache` "
"forcing the path based finder to perform the path entry search again "
"[#fnpic]_."
msgstr ""
"パスベース・ファインダーは検索パスのすべての要素について反復処理をし、それぞれのパスに対して適切な :term:`パスエントリ・ファインダー <path"
" entry finder>` (:class:`~importlib.abc.PathEntryFinder`) を探します。これは時間のかかる処理 "
"(例えば、この検索のための `stat()` 呼び出しのオーバーヘッド) "
"になり得るので、パスベース・ファインダーはパス要素からパスエントリ・ファインダーへの対応付けをキャッシュとして持っておきます。このキャッシュは "
":data:`sys.path_importer_cache` に持っています (名前に反して、このキャッシュは実際には :term:`インポーター "
"<importer>` には制限されておらず、ファインダーオブジェクトを保持します) 。このようにして、時間のかかる特定の :term:`パスエントリ "
"<path entry>` の場所のための :term:`パスエントリ・ファインダー <path entry finder>` "
"の検索を一度だけ検索すれば良くなります。パスベース・ファインダーにパスエントリの検索を再度行わせるために、ユーザコードでは自由に "
":data:`sys.path_importer_cache` からキャッシュを取り除いて構いません  [#fnpic]_ 。"

#: ../../reference/import.rst:785
msgid ""
"If the path entry is not present in the cache, the path based finder "
"iterates over every callable in :data:`sys.path_hooks`.  Each of the "
":term:`path entry hooks <path entry hook>` in this list is called with a "
"single argument, the path entry to be searched.  This callable may either "
"return a :term:`path entry finder` that can handle the path entry, or it may"
" raise :exc:`ImportError`.  An :exc:`ImportError` is used by the path based "
"finder to signal that the hook cannot find a :term:`path entry finder` for "
"that :term:`path entry`.  The exception is ignored and :term:`import path` "
"iteration continues.  The hook should expect either a string or bytes "
"object; the encoding of bytes objects is up to the hook (e.g. it may be a "
"file system encoding, UTF-8, or something else), and if the hook cannot "
"decode the argument, it should raise :exc:`ImportError`."
msgstr ""
"path entry がキャッシュの中に無かった場合、 path based finder は :data:`sys.path_hooks` の中の呼び出し可能オブジェクトを全て辿ります。\n"
"このリストのそれぞれの :term:`path entry フック <path entry hook>` は、検索する path entry という引数 1 つを渡して呼び出されます。\n"
"その呼び出し可能オブジェクトは path entry を扱える :term:`path entry finder` を返すか、  :exc:`ImportError` を送出します。\n"
":exc:`ImportError` は、フックが :term:`path entry` のための :term:`path entry finder` を探せないことを報せるために path based finder が使います。\n"
"この例外は処理されず、 :term:`import path` を辿っていく処理が続けられます。\n"
"フックは引数として文字列またはバイト列オブジェクトを期待します;\n"
"バイト列オブジェクトのエンコーディングはフックに任されていて (例えば、ファイルシステムのエンコーディングの UTF-8 やそれ以外などです) 、フックが引数をデコードできなかった場合は :exc:`ImportError` を送出すべきです。"

#: ../../reference/import.rst:799
msgid ""
"If :data:`sys.path_hooks` iteration ends with no :term:`path entry finder` "
"being returned, then the path based finder's "
":meth:`~importlib.machinery.PathFinder.find_spec` method will store ``None``"
" in :data:`sys.path_importer_cache` (to indicate that there is no finder for"
" this path entry) and return ``None``, indicating that this :term:`meta path"
" finder` could not find the module."
msgstr ""
":data:`sys.path_hooks` を辿る処理が :term:`パスエントリ・ファインダー <path entry finder>` "
"を何も返さずに終わった場合、パスベース・ファインダーの "
":meth:`~importlib.machinery.PathFinder.find_spec` メソッドは、 "
":data:`sys.path_importer_cache` に (このパスエントリに対するファインダーが存在しないことを示すために) "
"``None`` を保存し、 :term:`メタパス・ファインダー <meta path finder>` "
"はモジュールが見つからなかったことを伝えるために ``None`` を返します。"

#: ../../reference/import.rst:806
msgid ""
"If a :term:`path entry finder` *is* returned by one of the :term:`path entry"
" hook` callables on :data:`sys.path_hooks`, then the following protocol is "
"used to ask the finder for a module spec, which is then used when loading "
"the module."
msgstr ""
":data:`sys.path_hooks` 上の :term:`パスエントリフック <path entry hook>` "
"呼び出し可能オブジェクトの戻り値のいずれかが :term:`パスエントリ・ファインダー <path entry finder>` *であった* "
"場合、後で出てくるモジュール仕様を探すためのプロトコルが使われ、それがモジュールをロードするために使われます。"

#: ../../reference/import.rst:811
msgid ""
"The current working directory -- denoted by an empty string -- is handled "
"slightly differently from other entries on :data:`sys.path`. First, if the "
"current working directory is found to not exist, no value is stored in "
":data:`sys.path_importer_cache`. Second, the value for the current working "
"directory is looked up fresh for each module lookup. Third, the path used "
"for :data:`sys.path_importer_cache` and returned by "
":meth:`importlib.machinery.PathFinder.find_spec` will be the actual current "
"working directory and not the empty string."
msgstr ""
"（空の文字列によって表される）現在のディレクトリは、 :data:`sys.path` "
"の他のエントリとは多少異なる方法で処理されます。まず、現在のディレクトリが存在しないことが判明した場合、 "
":data:`sys.path_importer_cache` "
"には何も追加されません。次に、現在のディレクトリに対する値は個々のモジュールのルックアップで毎回新たに検索されます。 3番目に、 "
":data:`sys.path_importer_cache` に使われ、 "
":meth:`importlib.machinery.PathFinder.find_spec` "
"が返すパスは、実際のディレクトリであって空の文字列ではありません。"

#: ../../reference/import.rst:821
msgid "Path entry finder protocol"
msgstr "パスエントリ・ファインダー・プロトコル"

#: ../../reference/import.rst:823
msgid ""
"In order to support imports of modules and initialized packages and also to "
"contribute portions to namespace packages, path entry finders must implement"
" the :meth:`~importlib.abc.PathEntryFinder.find_spec` method."
msgstr ""
"モジュールと初期化されたパッケージのインポートをサポートするため、および名前空間パッケージのポーションとして提供するために、パスエントリ・ファインダーは"
" :meth:`~importlib.abc.PathEntryFinder.find_spec`  メソッドを実装しなければいけません。"

#: ../../reference/import.rst:827
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` takes two argument, the "
"fully qualified name of the module being imported, and the (optional) target"
" module.  ``find_spec()`` returns a fully populated spec for the module. "
"This spec will always have \"loader\" set (with one exception)."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` は 2 "
"つの引数を取ります。インポートしようとしているモジュールの完全修飾名と、 (オプションの) 対象モジュールです。 `find_spec()` "
"はモジュールに対応する完全に初期化 (populated) された仕様を返します。この仕様は (1つの例外を除いて) 常に \"loader\" "
"セットを持っています。"

#: ../../reference/import.rst:832
msgid ""
"To indicate to the import machinery that the spec represents a namespace "
":term:`portion`. the path entry finder sets \"loader\" on the spec to "
"``None`` and \"submodule_search_locations\" to a list containing the "
"portion."
msgstr ""
"モジュール仕様が名前空間 :term:`ポーション <portion>` "
"を表していることをインポート機構に示すために、パスエントリ・ファインダーはモジュール仕様の \"loader\" を ``None`` に、 "
"\"submodule_search_locations\" を名前空間ポーションを含むリストに設定します。"

#: ../../reference/import.rst:837
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` replaced "
":meth:`~importlib.abc.PathEntryFinder.find_loader` and "
":meth:`~importlib.abc.PathEntryFinder.find_module`, both of which are now "
"deprecated, but will be used if ``find_spec()`` is not defined."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` は "
":meth:`~importlib.abc.PathEntryFinder.find_loader` と "
":meth:`~importlib.abc.PathEntryFinder.find_module` を置き換えました。両者は deprecated "
"ですが、 `find_spec()` が定義されていなければ使われます。"

#: ../../reference/import.rst:843
msgid ""
"Older path entry finders may implement one of these two deprecated methods "
"instead of ``find_spec()``.  The methods are still respected for the sake of"
" backward compatibility.  However, if ``find_spec()`` is implemented on the "
"path entry finder, the legacy methods are ignored."
msgstr ""
"古いパスエントリ・ファインダーの中には、 ``find_spec()`` の代わりにこれら 2 つの deperecated "
"なメソッドのうちのいずれかを実装しているものがあるかもしれません。これらのメソッドは後方互換性のためにまだ考慮されています。しかし、パスエントリ・ファインダーに"
" ``find_spec()`` が実装されていれば、古いメソッドは無視されます。"

#: ../../reference/import.rst:848
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` takes one argument, the "
"fully qualified name of the module being imported.  ``find_loader()`` "
"returns a 2-tuple where the first item is the loader and the second item is "
"a namespace :term:`portion`.  When the first item (i.e. the loader) is "
"``None``, this means that while the path entry finder does not have a loader"
" for the named module, it knows that the path entry contributes to a "
"namespace portion for the named module.  This will almost always be the case"
" where Python is asked to import a namespace package that has no physical "
"presence on the file system.  When a path entry finder returns ``None`` for "
"the loader, the second item of the 2-tuple return value must be a sequence, "
"although it can be empty."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` "
"はインポートされるモジュールの完全修飾名を引数に取ります。 ``find_loader()`` は、第 1 要素がローダで第  2要素が名前空間 "
":term:`ポーション <portion>` である 2 要素のタプルを返します。第 1 要素 (つまりローダー) が ``None`` "
"の場合、その意味は、パスエントリ・ファインダー自身は指定されたモジュールのためのローダーを持っていないものの、パスエントリがモジュールの名前空間ポーションに関係している"
" (contribute) "
"のをパスエントリ・ファインダーが知っているということです。これは、ほとんど常にファイルシステム上に物理的な実体のない名前空間パッケージをインポートしようとした場合です。パスエントリ・ファインダーがローダーとして"
" ``None`` を返す場合には、 2 要素タプルである戻り値の第 2 要素はシーケンスでなければなりません。ただし、シーケンスは空でも構いません。"

#: ../../reference/import.rst:860
msgid ""
"If ``find_loader()`` returns a non-``None`` loader value, the portion is "
"ignored and the loader is returned from the path based finder, terminating "
"the search through the path entries."
msgstr ""
"``find_loader()`` が ``None`` "
"でないローダー値を返した場合、ポーションは無視され、パスベース・ファインダーからローダーが返され、パスエントリ上の検索が終了します。"

#: ../../reference/import.rst:864
msgid ""
"For backwards compatibility with other implementations of the import "
"protocol, many path entry finders also support the same, traditional "
"``find_module()`` method that meta path finders support. However path entry "
"finder ``find_module()`` methods are never called with a ``path`` argument "
"(they are expected to record the appropriate path information from the "
"initial call to the path hook)."
msgstr ""
"他のインポート機構の実装に対する後方互換性のために、多くのパスエントリ・ファインダーは、メタパス・ファインダーがサポートするのと同じ伝統的な "
"``find_module()``  メソッドもサポートしています。しかし、パスエントリ・ファインダーの ``find_module()``  "
"メソッドは、決して ``path`` 引数では呼び出されません "
"(このメソッドは、パスフックの最初の呼び出しから適切なパス情報を記録する動作が期待されています)。"

#: ../../reference/import.rst:871
msgid ""
"The ``find_module()`` method on path entry finders is deprecated, as it does"
" not allow the path entry finder to contribute portions to namespace "
"packages.  If both ``find_loader()`` and ``find_module()`` exist on a path "
"entry finder, the import system will always call ``find_loader()`` in "
"preference to ``find_module()``."
msgstr ""
"パスエントリ・ファインダーの ``find_module()`` メソッドは deprecated "
"です。なぜなら、その方法ではパスエントリ・ファインダーが名前空間パッケージに対してポーションを提供することができないからです。もし "
"``find_loader()`` と ``find_module()`` の両方がパスエントリ・ファインダーに存在したら、インポートシステムは常に "
"``find_module()`` よりも ``find_loader()`` を優先して呼び出します。"

#: ../../reference/import.rst:879
msgid "Replacing the standard import system"
msgstr "標準のインポートシステムを置き換える"

#: ../../reference/import.rst:881
msgid ""
"The most reliable mechanism for replacing the entire import system is to "
"delete the default contents of :data:`sys.meta_path`, replacing them "
"entirely with a custom meta path hook."
msgstr ""
"インポートシステム全体を置き換えるための最も信頼性のある仕組みは、 :data:`sys.meta_path` "
"のデフォルトの内容を削除し、全部をカスタムのメタパスフックで置き換えるものです。"

#: ../../reference/import.rst:885
msgid ""
"If it is acceptable to only alter the behaviour of import statements without"
" affecting other APIs that access the import system, then replacing the "
"builtin :func:`__import__` function may be sufficient. This technique may "
"also be employed at the module level to only alter the behaviour of import "
"statements within that module."
msgstr ""
"もし、 import 文の動作だけを変更し、インポートシステムにアクセスする他の API には影響を与えなくてもよければ、組み込みの "
":func:`__import__` 関数を置き換えるだけで十分です。この手法は、ある 1 つのモジュール内だけで import "
"文の動作を変更するのにも用いられます。"

#: ../../reference/import.rst:891
msgid ""
"To selectively prevent import of some modules from a hook early on the meta "
"path (rather than disabling the standard import system entirely), it is "
"sufficient to raise :exc:`ModuleNotFoundError` directly from "
":meth:`~importlib.abc.MetaPathFinder.find_spec` instead of returning "
"``None``. The latter indicates that the meta path search should continue, "
"while raising an exception terminates it immediately."
msgstr ""
"(標準のインポートシステム全体を停止するのではなく) すでにメタパスにいるフックからあるモジュールのインポートを選択的に防ぐためには、 "
":meth:`~importlib.abc.MetaPathFinder.find_spec` から ``None`` を返す代わりに、直接 "
":exc:`ModuleNotFoundError` を送出するだけで十分です。 ``None`` "
"を返すのはメタパスの走査を続けるべきであることを意味しますが、例外を送出するとすぐに走査を打ち切ります。"

#: ../../reference/import.rst:900
msgid "Special considerations for __main__"
msgstr "__main__ に対する特別な考慮"

#: ../../reference/import.rst:902
msgid ""
"The :mod:`__main__` module is a special case relative to Python's import "
"system.  As noted :ref:`elsewhere <programs>`, the ``__main__`` module is "
"directly initialized at interpreter startup, much like :mod:`sys` and "
":mod:`builtins`.  However, unlike those two, it doesn't strictly qualify as "
"a built-in module.  This is because the manner in which ``__main__`` is "
"initialized depends on the flags and other options with which the "
"interpreter is invoked."
msgstr ""
":mod:`__main__` モジュールは、 Python のインポートシステムに関連する特別なケースです。 :ref:`他の場所 "
"<programs>` で言及されているように、 ``__main__`` モジュールは :mod:`sys` や :mod:`builtins` "
"などと同様にインタプリタースタートアップで直接初期化されます。しかし、前者 2 つのモジュールと違って、 ``__main__`` "
"は厳密にはビルトインのモジュールとしての資格を持っていません。これは、 ``__main__`` "
"が初期化される方法がインタプリタが起動されるときのフラグやその他のオプションに依存するためです。"

#: ../../reference/import.rst:913
msgid "__main__.__spec__"
msgstr "__main__.__spec__"

#: ../../reference/import.rst:915
msgid ""
"Depending on how :mod:`__main__` is initialized, ``__main__.__spec__`` gets "
"set appropriately or to ``None``."
msgstr ""
":mod:`__main__` がどのように初期化されるかに依存して、 ``__main__.__spec__`` は適切に設定されることもあれば "
"``None`` になることもあります。"

#: ../../reference/import.rst:918
msgid ""
"When Python is started with the :option:`-m` option, ``__spec__`` is set to "
"the module spec of the corresponding module or package. ``__spec__`` is also"
" populated when the ``__main__`` module is loaded as part of executing a "
"directory, zipfile or other :data:`sys.path` entry."
msgstr ""
"Python が :option:`-m` オプションを付けて実行された場合には、 ``__spec__`` "
"は対応するモジュールまたはパッケージのモジュール仕様に設定されます。また、ディレクトリや zip ファイル、または他の :data:`sys.path`"
" エントリを実行する処理の一部として ``__main__`` モジュールがロードされる場合にも ``__spec__`` が生成 (populate)"
" されます。"

#: ../../reference/import.rst:923
msgid ""
"In :ref:`the remaining cases <using-on-interface-options>` "
"``__main__.__spec__`` is set to ``None``, as the code used to populate the "
":mod:`__main__` does not correspond directly with an importable module:"
msgstr ""
":ref:`それ以外のケース <using-on-interface-options>` では、 ``__main__.__spec__`` は "
"``None`` に設定されます。これは、 :mod:`__main__` を生成 (populate) "
"するために使われたコードがインポート可能なモジュールと直接一致していないためです:"

#: ../../reference/import.rst:927
msgid "interactive prompt"
msgstr "対話プロンプト"

#: ../../reference/import.rst:928
msgid "-c switch"
msgstr "-c スイッチ"

#: ../../reference/import.rst:929
msgid "running from stdin"
msgstr "stdin から起動された場合"

#: ../../reference/import.rst:930
msgid "running directly from a source or bytecode file"
msgstr "ソースファイルやバイトコードファイルから直接起動された場合"

#: ../../reference/import.rst:932
msgid ""
"Note that ``__main__.__spec__`` is always ``None`` in the last case, *even "
"if* the file could technically be imported directly as a module instead. Use"
" the :option:`-m` switch if valid module metadata is desired in "
":mod:`__main__`."
msgstr ""
"最後のケースでは、たとえ技術的にはファイルがモジュールとして直接インポートできた *としても* ``__main__.__spec__`` は常に "
"``None`` になることに注意してください。もし :mod:`__main__` において有効なモジュールメタデータが必要なら "
":option:`-m` スイッチを使ってください。"

#: ../../reference/import.rst:937
msgid ""
"Note also that even when ``__main__`` corresponds with an importable module "
"and ``__main__.__spec__`` is set accordingly, they're still considered "
"*distinct* modules. This is due to the fact that blocks guarded by ``if "
"__name__ == \"__main__\":`` checks only execute when the module is used to "
"populate the ``__main__`` namespace, and not during normal import."
msgstr ""
"``__main__`` がインポート可能なモジュールと一致し、 ``__main__.__spec__`` "
"がそれに応じて設定されていたとしても、それでもなお、この 2 つのモジュールは別物とみなされることに注意してください。これは、 ``if "
"__name__ == \"__main__\":`` チェックによって保証されるブロックは、 ``__main__`` 名前空間を生成 "
"(populate) するためにモジュールが使用される時にだけ実行され、通常のインポート時には実行されない、という事実に起因しています。"

#: ../../reference/import.rst:945
msgid "Open issues"
msgstr "取り掛かり中の問題"

#: ../../reference/import.rst:947
msgid "XXX It would be really nice to have a diagram."
msgstr "XXX 図があるととても良い。"

#: ../../reference/import.rst:949
msgid ""
"XXX * (import_machinery.rst) how about a section devoted just to the "
"attributes of modules and packages, perhaps expanding upon or supplanting "
"the related entries in the data model reference page?"
msgstr ""
"XXX * (import_machinery.rst) モジュールとパッケージの属性のみに紙面を割いた節を設けるのは何如でしょうか? "
"もしかしたらデータモデルについての言語リファレンスのページにある関係する内容を拡張したり、置き換えるようなものになるかもしれません。"

#: ../../reference/import.rst:953
msgid ""
"XXX runpy, pkgutil, et al in the library manual should all get \"See Also\" "
"links at the top pointing to the new import system section."
msgstr ""
"XXX ライブラリマニュアルの runpy や pkgutil の解説の先頭すべてに、\"こちらも参照 (See Also)\" "
"という、この新しいインポートシステムの節へのリンクを置くべき。"

#: ../../reference/import.rst:956
msgid ""
"XXX Add more explanation regarding the different ways in which ``__main__`` "
"is initialized?"
msgstr "XXX ``__main__`` が初期化される様々な方法についてより多くの説明を追加する?"

#: ../../reference/import.rst:959
msgid ""
"XXX Add more info on ``__main__`` quirks/pitfalls (i.e. copy from "
":pep:`395`)."
msgstr "XXX ``__main__`` の特異性/落とし穴についてより多くの情報を追加する (つまり :pep:`395` からコピーする)"

#: ../../reference/import.rst:964
msgid "References"
msgstr "参考資料"

#: ../../reference/import.rst:966
msgid ""
"The import machinery has evolved considerably since Python's early days.  "
"The original `specification for packages "
"<https://www.python.org/doc/essays/packages/>`_ is still available to read, "
"although some details have changed since the writing of that document."
msgstr ""
"Python の初期の頃からすると、インポート機構は目覚ましい発展を遂げました。\n"
"一部細かいところがドキュメントが書かれたときから変わってはいますが、最初期の `パッケージの仕様 <https://www.python.org/doc/essays/packages/>`_ はまだ読むことができます。"

#: ../../reference/import.rst:971
msgid ""
"The original specification for :data:`sys.meta_path` was :pep:`302`, with "
"subsequent extension in :pep:`420`."
msgstr ""
"オリジナルの :data:`sys.meta_path` の仕様は :pep:`302` で、その後継となる拡張が :pep:`420` です。"

#: ../../reference/import.rst:974
msgid ""
":pep:`420` introduced :term:`namespace packages <namespace package>` for "
"Python 3.3.  :pep:`420` also introduced the :meth:`find_loader` protocol as "
"an alternative to :meth:`find_module`."
msgstr ""
":pep:`420` は Python 3.3 に :term:`名前空間パッケージ <namespace package>` を導入しています。 "
":pep:`420` はまた :meth:`find_module` に代わるものとして :meth:`find_loader` "
"プロトコルを導入しています。"

#: ../../reference/import.rst:978
msgid ""
":pep:`366` describes the addition of the ``__package__`` attribute for "
"explicit relative imports in main modules."
msgstr ""
":pep:`366` は、メインモジュールでの明示的な相対インポートのために追加した ``__package__`` 属性の解説をしています。"

#: ../../reference/import.rst:981
msgid ""
":pep:`328` introduced absolute and explicit relative imports and initially "
"proposed ``__name__`` for semantics :pep:`366` would eventually specify for "
"``__package__``."
msgstr ""
":pep:`328` は絶対インポート、明示的な相対インポート、および、当初 ``__name__`` で提案し、後に :pep:`366` が "
"``__package__`` で定めた仕様を導入しました。"

#: ../../reference/import.rst:985
msgid ":pep:`338` defines executing modules as scripts."
msgstr ":pep:`338` はモジュールをスクリプトとして実行するときの仕様を定めています。"

#: ../../reference/import.rst:987
msgid ""
":pep:`451` adds the encapsulation of per-module import state in spec "
"objects.  It also off-loads most of the boilerplate responsibilities of "
"loaders back onto the import machinery.  These changes allow the deprecation"
" of several APIs in the import system and also addition of new methods to "
"finders and loaders."
msgstr ""
":pep:`451` "
"は、モジュール仕様オブジェクトにおけるモジュール毎のインポート状態のカプセル化を追加しています。また、ローダーの定型的な責任のほとんどをインポート機構に肩代わりさせています。これらの変更により、インポートシステムのいくつかの"
" API が deprecate され、またファインダーとローダーには新しいメソッドが追加されました。"

#: ../../reference/import.rst:994
msgid "Footnotes"
msgstr "脚注"

#: ../../reference/import.rst:995
msgid "See :class:`types.ModuleType`."
msgstr ":class:`types.ModuleType` を参照してください。"

#: ../../reference/import.rst:997
msgid ""
"The importlib implementation avoids using the return value directly. "
"Instead, it gets the module object by looking the module name up in "
":data:`sys.modules`.  The indirect effect of this is that an imported module"
" may replace itself in :data:`sys.modules`.  This is implementation-specific"
" behavior that is not guaranteed to work in other Python implementations."
msgstr ""
"importlib の実装は、戻り値を直接使うことは避けています。その代わりに、モジュール名を調べて :data:`sys.modules` "
"からモジュールオブジェクトを得ます。こうすることの間接的な効果は、インポートされたモジュールが :data:`sys.modules` "
"にいる自分自身を置き換えることがあるということです。これは実装依存の動作であり、他の Python 実装では保証されていない動作です。"

#: ../../reference/import.rst:1004
msgid ""
"In legacy code, it is possible to find instances of "
":class:`imp.NullImporter` in the :data:`sys.path_importer_cache`.  It is "
"recommended that code be changed to use ``None`` instead.  See "
":ref:`portingpythoncode` for more details."
msgstr ""
"レガシーなコードでは、 :data:`sys.path_importer_cache` に :class:`imp.NullImporter` "
"のインスタンスがいることがあります。それの代わりに ``None`` を使うようにコードを変更することが推奨されます。より詳しいことは "
":ref:`portingpythoncode` を参照してください。"
