# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Akihiro Uchida <uchida@turbare.net>, 2017
# E. Kawashima, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2017
# Arihiro TAKASE, 2017
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2017
# tomoğŸ§, 2018
# yudetamago <yudetamago.orz@gmail.com>, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-08 09:41+0900\n"
"PO-Revision-Date: 2017-02-16 23:38+0000\n"
"Last-Translator: yudetamago <yudetamago.orz@gmail.com>, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/import.rst:6
msgid "The import system"
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ "

#: ../../reference/import.rst:10
msgid ""
"Python code in one :term:`module` gains access to the code in another module"
" by the process of :term:`importing` it.  The :keyword:`import` statement is"
" the most common way of invoking the import machinery, but it is not the "
"only way.  Functions such as :func:`importlib.import_module` and built-in "
":func:`__import__` can also be used to invoke the import machinery."
msgstr ""
"ã‚ã‚‹ 1 ã¤ã® :term:`module` ã«ã‚ã‚‹ Python ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ (:term:`importing`) "
"ã™ã‚‹ã“ã¨ã§ã€ãã“ã«ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ã¸ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ :keyword:`import` "
"æ–‡ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã‚’å‹•ã‹ã™æœ€ã‚‚ä¸€èˆ¬çš„ãªæ–¹æ³•ã§ã™ãŒã€ãã‚ŒãŒå”¯ä¸€ã®æ–¹æ³•ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ :func:`importlib.import_module` "
"ã‚„çµ„ã¿è¾¼ã¿ã® :func:`__import__` ã¨ã„ã£ãŸé–¢æ•°ã‚’ä½¿ã£ã¦ã‚‚ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã‚’å‹•ã‹ã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/import.rst:16
msgid ""
"The :keyword:`import` statement combines two operations; it searches for the"
" named module, then it binds the results of that search to a name in the "
"local scope.  The search operation of the :keyword:`import` statement is "
"defined as a call to the :func:`__import__` function, with the appropriate "
"arguments. The return value of :func:`__import__` is used to perform the "
"name binding operation of the :keyword:`import` statement.  See the "
":keyword:`import` statement for the exact details of that name binding "
"operation."
msgstr ""
":keyword:`import` æ–‡ã¯ 2 ã¤ã®å‡¦ç†ã‚’é€£ç¶šã—ã¦è¡Œã£ã¦ã„ã¾ã™; "
"ã‚ã‚‹åå‰ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¢ã—ã€ãã®æ¤œç´¢çµæœã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®åå‰ã«æŸç¸›ã—ã¾ã™ã€‚ :keyword:`import` æ–‡ã®æ¤œç´¢å‡¦ç†ã¯ã€é©åˆ‡ãªå¼•æ•°ã§ "
":func:`__import__` é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ :func:`__import__` ã®æˆ»ã‚Šå€¤ã¯ "
":keyword:`import` æ–‡ã®åå‰æŸç¸›å‡¦ç†ã®å®Ÿè¡Œã§ä½¿ã‚ã‚Œã¾ã™ã€‚åå‰æŸç¸›å‡¦ç†ã®å³å¯†ãªè©³ç´°ã¯ :keyword:`import` "
"æ–‡ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/import.rst:25
msgid ""
"A direct call to :func:`__import__` performs only the module search and, if "
"found, the module creation operation.  While certain side-effects may occur,"
" such as the importing of parent packages, and the updating of various "
"caches (including :data:`sys.modules`), only the :keyword:`import` statement"
" performs a name binding operation."
msgstr ""
":func:`__import__` "
"ã‚’ç›´æ¥å‘¼ã³å‡ºã™ã¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ¤œç´¢ã®ã¿ãŒè¡Œã‚ã‚Œã€è¦‹ã¤ã‹ã£ãŸå ´åˆã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½œæˆå‡¦ç†ãŒè¡Œã‚ã‚Œã¾ã™ã€‚è¦ªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚„ "
"(:data:`sys.modules` ã‚’å«ã‚€) æ§˜ã€…ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®æ›´æ–°ãªã©ã®å‰¯ä½œç”¨ã¯èµ·ãã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ :keyword:`import` "
"æ–‡ã®ã¿ãŒåå‰æŸç¸›å‡¦ç†ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../reference/import.rst:31
msgid ""
"When an :keyword:`import` statement is executed, the standard builtin "
":func:`__import__` function is called. Other mechanisms for invoking the "
"import system (such as :func:`importlib.import_module`) may choose to bypass"
" :func:`__import__` and use their own solutions to implement import "
"semantics."
msgstr ""

#: ../../reference/import.rst:36
msgid ""
"When a module is first imported, Python searches for the module and if "
"found, it creates a module object [#fnmo]_, initializing it.  If the named "
"module cannot be found, a :exc:`ModuleNotFoundError` is raised.  Python "
"implements various strategies to search for the named module when the import"
" machinery is invoked.  These strategies can be modified and extended by "
"using various hooks described in the sections below."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆã‚ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã‚‹ã¨ãã€ Python ã¯ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¤œç´¢ã—ã€è¦‹ä»˜ã‹ã£ãŸå ´åˆã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã€åˆæœŸåŒ–ã—ã¾ã™ "
"[#fnmo]_ ã€‚ãã®åå‰ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ä»˜ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã€ :exc:`ModuleNotFoundError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ Python "
"ã«ã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ãŒå®Ÿè¡Œã•ã‚ŒãŸã¨ãã«åå‰ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¤œç´¢ã™ã‚‹æ§˜ã€…ãªæˆ¦ç•¥ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®æˆ¦ç•¥ã¯ã€ã“ã‚Œä»¥é™ã®ç¯€ã§è§£èª¬ã•ã‚Œã‚‹æ§˜ã€…ãªãƒ•ãƒƒã‚¯ã‚’ä½¿ã£ã¦ã€ä¿®æ­£ã—ãŸã‚Šæ‹¡å¼µã—ãŸã‚Šã§ãã¾ã™ã€‚"

#: ../../reference/import.rst:43
msgid ""
"The import system has been updated to fully implement the second phase of "
":pep:`302`. There is no longer any implicit import machinery - the full "
"import system is exposed through :data:`sys.meta_path`. In addition, native "
"namespace package support has been implemented (see :pep:`420`)."
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ãŒ :pep:`302` ã®ç¬¬ 2 ãƒ•ã‚§ãƒ¼ã‚ºã®å®Œå…¨ãªå®Ÿè£…ã¸æ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚ã‚‚ã¯ã‚„æš—é»™çš„ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ã‚ã‚Šã¾ã›ã‚“ - "
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹å…¨ä½“ã¯ :data:`sys.meta_path` "
"ã‚’é€šã—ã¦å…¬é–‹ã•ã‚Œã¦ã„ã¾ã™ã€‚åŠ ãˆã¦ã€ãƒã‚¤ãƒ†ã‚£ãƒ–ã®åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚µãƒãƒ¼ãƒˆã¯å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ (:pep:`420` ã‚’å‚ç…§) ã€‚"

#: ../../reference/import.rst:51
msgid ":mod:`importlib`"
msgstr ":mod:`importlib`"

#: ../../reference/import.rst:53
msgid ""
"The :mod:`importlib` module provides a rich API for interacting with the "
"import system.  For example :func:`importlib.import_module` provides a "
"recommended, simpler API than built-in :func:`__import__` for invoking the "
"import machinery.  Refer to the :mod:`importlib` library documentation for "
"additional detail."
msgstr ""
":mod:`importlib` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¨ã‚„ã‚Šå–ã‚Šã™ã‚‹ãŸã‚ã®ä¾¿åˆ©ãª API ã‚’æä¾›ã—ã¾ã™ã€‚ä¾‹ãˆã° "
":func:`importlib.import_module` ã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã®çµ„ã¿è¾¼ã¿ã® :func:`__import__` "
"ã‚ˆã‚Šã‚‚ã‚·ãƒ³ãƒ—ãƒ«ã§æ¨å¥¨ã•ã‚Œã‚‹ API ã‚’æä¾›ã—ã¾ã™ã€‚ã‚ˆã‚Šè©³ç´°ãªã“ã¨ã¯ :mod:`importlib` ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/import.rst:62
msgid "Packages"
msgstr "ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸"

#: ../../reference/import.rst:67
msgid ""
"Python has only one type of module object, and all modules are of this type,"
" regardless of whether the module is implemented in Python, C, or something "
"else.  To help organize modules and provide a naming hierarchy, Python has a"
" concept of :term:`packages <package>`."
msgstr ""
"Python ã«ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç¨®é¡ã¯ 1 ç¨®é¡ã—ã‹ãªãã€ Python ã€ C "
"ã€ãã‚Œä»¥å¤–ã®ã‚‚ã®ã®ã©ã‚Œã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹ã«é–¢ä¿‚ãªãã€ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã“ã®ç¨®é¡ã«ãªã‚Šã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®çµ„ç¹”åŒ–ã‚’åŠ©ã‘ã€åå‰éšå±¤ã‚’æä¾›ã™ã‚‹ãŸã‚ã«ã€ "
"Python ã«ã¯ :term:`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ <package>` ã¨ã„ã†æ¦‚å¿µãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/import.rst:72
msgid ""
"You can think of packages as the directories on a file system and modules as"
" files within directories, but don't take this analogy too literally since "
"packages and modules need not originate from the file system.  For the "
"purposes of this documentation, we'll use this convenient analogy of "
"directories and files.  Like file system directories, packages are organized"
" hierarchically, and packages may themselves contain subpackages, as well as"
" regular modules."
msgstr ""
"ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã¨è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰ç”Ÿã¾ã‚Œã‚‹å¿…è¦ã¯ãªã„ã®ã§ã€ã“ã®æ¯”å–©ã‚’é¡é¢é€šã‚Šã«å—ã‘å–ã£ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚ã“ã®æ–‡æ›¸ã®ç›®çš„ã®ãŸã‚ã«ã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã„ã†ä¾¿åˆ©ãªæ¯”å–©ã‚’ä½¿ã†ã“ã¨ã«ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ã‚ˆã†ã«ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯éšå±¤æ§‹é€ ã‚’æˆã—ã€é€šå¸¸ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã ã‘ã§ãªãã€ã‚µãƒ–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’å«ã‚€ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/import.rst:80
msgid ""
"It's important to keep in mind that all packages are modules, but not all "
"modules are packages.  Or put another way, packages are just a special kind "
"of module.  Specifically, any module that contains a ``__path__`` attribute "
"is considered a package."
msgstr ""
"ã™ã¹ã¦ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ãŒã€ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ã¯é™ã‚‰ãªã„ã“ã¨ã‚’å¿ƒã«ç•™ã‚ã¦ãŠãã®ãŒé‡è¦ã§ã™ã€‚ã‚‚ã—ãã¯ä»–ã®è¨€ã„æ–¹ã‚’ã™ã‚‹ã¨ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯å˜ãªã‚‹ç‰¹åˆ¥ãªç¨®é¡ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã‚ã‚‹ã¨è¨€ãˆã¾ã™ã€‚ç‰¹ã«ã€``__path__``"
" å±æ€§ã‚’æŒã¤ä»»æ„ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨è¦‹ãªã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:85
msgid ""
"All modules have a name.  Subpackage names are separated from their parent "
"package name by dots, akin to Python's standard attribute access syntax.  "
"Thus you might have a module called :mod:`sys` and a package called "
":mod:`email`, which in turn has a subpackage called :mod:`email.mime` and a "
"module within that subpackage called :mod:`email.mime.text`."
msgstr ""
"ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯åå‰ãŒã‚ã‚Šã¾ã™ã€‚ã‚µãƒ–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åã¯ã€ Python "
"ã®æ¨™æº–ã®å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã®æ§‹æ–‡ã«ä¼¼ã¦ã€è¦ªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åã¨ãƒ‰ãƒƒãƒˆã§åŒºåˆ‡ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ :mod:`sys` ã¨å‘¼ã°ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ "
":mod:`email` ã¨å‘¼ã°ã‚Œã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è¦‹æ›ã‘ã‚‹ã“ã¨ãŒã‚ã‚‹ã§ã—ã‚‡ã†ã€‚ãã®ä¸­ã«ã¯ :mod:`email.mime` "
"ã¨å‘¼ã°ã‚Œã‚‹ã‚µãƒ–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ã€ãã®ã‚µãƒ–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ä¸­ã« :mod:`email.mime.text` ã¨å‘¼ã°ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/import.rst:93
msgid "Regular packages"
msgstr "é€šå¸¸ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸"

#: ../../reference/import.rst:98
msgid ""
"Python defines two types of packages, :term:`regular packages <regular "
"package>` and :term:`namespace packages <namespace package>`.  Regular "
"packages are traditional packages as they existed in Python 3.2 and earlier."
" A regular package is typically implemented as a directory containing an "
"``__init__.py`` file.  When a regular package is imported, this "
"``__init__.py`` file is implicitly executed, and the objects it defines are "
"bound to names in the package's namespace.  The ``__init__.py`` file can "
"contain the same Python code that any other module can contain, and Python "
"will add some additional attributes to the module when it is imported."
msgstr ""
"Python ã§ã¯ã€ :term:`é€šå¸¸ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ <regular package>` ã¨ :term:`åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ <namespace "
"package>` ã® 2 ç¨®é¡ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚é€šå¸¸ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ Python 3.2 "
"ä»¥å‰ã‹ã‚‰å­˜åœ¨ã™ã‚‹ä¼çµ±çš„ãªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã™ã€‚å…¸å‹çš„ãªé€šå¸¸ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ ``__init__.py`` "
"ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å«ã‚€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¾ã™ã€‚é€šå¸¸ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸã¨ãã€ã“ã® ``__init__.py`` "
"ãƒ•ã‚¡ã‚¤ãƒ«ãŒæš—é»™çš„ã«å®Ÿè¡Œã•ã‚Œã€ãã‚Œã§å®šç¾©ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åå‰ç©ºé–“ã«ã‚ã‚‹åå‰ã«æŸç¸›ã•ã‚Œã¾ã™ã€‚ ``__init__.py`` "
"ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æ›¸ã‘ã‚‹ Python ã‚³ãƒ¼ãƒ‰ã¨åŒã˜ã‚‚ã®ã‚’å«ã‚€ã“ã¨ãŒã§ãã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸã¨ãã« Python "
"ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å±æ€§ã‚’è¿½åŠ ã—ãŸã‚Šã—ã¾ã™ã€‚"

#: ../../reference/import.rst:108
msgid ""
"For example, the following file system layout defines a top level ``parent``"
" package with three subpackages::"
msgstr "ä¾‹ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ é…ç½®ã¯ã€3 ã¤ã®ã‚µãƒ–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’æŒã¤æœ€ä¸Šä½ã® ``parent`` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’å®šç¾©ã—ã¾ã™::"

#: ../../reference/import.rst:120
msgid ""
"Importing ``parent.one`` will implicitly execute ``parent/__init__.py`` and "
"``parent/one/__init__.py``.  Subsequent imports of ``parent.two`` or "
"``parent.three`` will execute ``parent/two/__init__.py`` and "
"``parent/three/__init__.py`` respectively."
msgstr ""
"``parent.one`` ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã¨æš—é»™çš„ã« ``parent/__init__.py`` ã¨ "
"``parent/one/__init__.py`` ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ãã®å¾Œã« ``parent.two`` ã‚‚ã—ãã¯ ``parent.three``"
" ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã¨ã€ãã‚Œãã‚Œ ``parent/two/__init__.py`` ã‚„ ``parent/three/__init__.py`` "
"ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:127
msgid "Namespace packages"
msgstr "åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸"

#: ../../reference/import.rst:133
msgid ""
"A namespace package is a composite of various :term:`portions <portion>`, "
"where each portion contributes a subpackage to the parent package.  Portions"
" may reside in different locations on the file system.  Portions may also be"
" found in zip files, on the network, or anywhere else that Python searches "
"during import.  Namespace packages may or may not correspond directly to "
"objects on the file system; they may be virtual modules that have no "
"concrete representation."
msgstr ""
"åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯æ§˜ã€…ãª :term:`ãƒãƒ¼ã‚·ãƒ§ãƒ³ <portion>` "
"ã‚’å¯„ã›é›†ã‚ãŸã‚‚ã®ã§ã€ãã‚Œãã‚Œã®ãƒãƒ¼ã‚·ãƒ§ãƒ³ã¯ã‚µãƒ–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è¦ªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«æä¾›ã—ã¾ã™ã€‚ãƒãƒ¼ã‚·ãƒ§ãƒ³ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®åˆ¥ã€…ã®å ´æ‰€ã«ã‚ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚ãƒãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€"
" zip ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸­ã‚„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸Šã‚„ã€ãã‚Œä»¥å¤–ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ™‚ã« Python "
"ãŒæ¢ã™ã©ã“ã‹ã®å ´æ‰€ã§è¦‹ã¤ã‹ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾å¿œã™ã‚‹ã“ã¨ã‚‚ã‚ã‚‹ã—ã€ãã†ã§ãªã„ã“ã¨ã‚‚ã‚ã‚Šã¾ã™; "
"ãã‚Œã‚‰ã¯å®Ÿéš›ã®å®Ÿä½“ã®ãªã„ä»®æƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ã€‚"

#: ../../reference/import.rst:141
msgid ""
"Namespace packages do not use an ordinary list for their ``__path__`` "
"attribute. They instead use a custom iterable type which will automatically "
"perform a new search for package portions on the next import attempt within "
"that package if the path of their parent package (or :data:`sys.path` for a "
"top level package) changes."
msgstr ""
"åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€  ``__path__`` å±æ€§ã«æ™®é€šã®ãƒªã‚¹ãƒˆã¯ä½¿ã„ã¾ã›ã‚“ã€‚ãã®ä»£ã‚ã‚Šã«ç‹¬è‡ªã® iterable "
"å‹ã‚’ä½¿ã£ã¦ã„ã¦ã€ãƒãƒ¼ã‚·ãƒ§ãƒ³ã®è¦ªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ãƒ‘ã‚¹ (ã‚‚ã—ãã¯æœ€ä¸Šä½ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ãŸã‚ã® :data:`sys.path`) "
"ãŒå¤‰ã‚ã£ãŸå ´åˆã€ãã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã®æ¬¡ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®éš›ã«ã€æ–°ãŸã«è‡ªå‹•ã§ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ¤œç´¢ã—ã¾ã™ã€‚"

#: ../../reference/import.rst:147
msgid ""
"With namespace packages, there is no ``parent/__init__.py`` file.  In fact, "
"there may be multiple ``parent`` directories found during import search, "
"where each one is provided by a different portion.  Thus ``parent/one`` may "
"not be physically located next to ``parent/two``.  In this case, Python will"
" create a namespace package for the top-level ``parent`` package whenever it"
" or one of its subpackages is imported."
msgstr ""
"åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«ã¯ ``parent/__init__.py`` ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã‚Œã©ã“ã‚ã‹ã€ç•°ãªã‚‹ãƒãƒ¼ã‚·ãƒ§ãƒ³ãŒãã‚Œãã‚Œæä¾›ã™ã‚‹è¤‡æ•°ã® "
"``parent`` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆæ¤œç´¢ã®éš›ã«è¦‹ã¤ã‹ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚ã—ãŸãŒã£ã¦ ``parent/one`` ã¯ç‰©ç†çš„ã« "
"``parent/two`` ã®éš£ã‚Šã«ã‚ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚ãã®å ´åˆã€ãã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‹ã‚µãƒ–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã†ã¡ 1 ã¤ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸã¨ãã€Python "
"ã¯æœ€ä¸Šä½ã® ``parent`` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ãŸã‚ã®åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../reference/import.rst:154
msgid "See also :pep:`420` for the namespace package specification."
msgstr "åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ä»•æ§˜ã«ã¤ã„ã¦ã¯ :pep:`420` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/import.rst:158
msgid "Searching"
msgstr "æ¤œç´¢"

#: ../../reference/import.rst:160
msgid ""
"To begin the search, Python needs the :term:`fully qualified <qualified "
"name>` name of the module (or package, but for the purposes of this "
"discussion, the difference is immaterial) being imported.  This name may "
"come from various arguments to the :keyword:`import` statement, or from the "
"parameters to the :func:`importlib.import_module` or :func:`__import__` "
"functions."
msgstr ""
"æ¤œç´¢ã‚’å§‹ã‚ã‚‹ãŸã‚ã«ã¯ã€ Python ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (ã‚‚ã—ãã¯ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã™ãŒã€ã“ã“ã§ã®è­°è«–ã®ç›®çš„ã«ãŠã„ã¦ã¯ã•ã•ã„ãªé•ã„ã§ã™) ã® "
":term:`å®Œå…¨ä¿®é£¾ <qualified name>` åã‚’å¿…è¦ã¨ã—ã¾ã™ã€‚ã“ã®åå‰ã¯ã€ :keyword:`import` æ–‡ã®æ§˜ã€…ãªå¼•æ•°ã‚„ "
":func:`importlib.import_module` ãŠã‚ˆã³ :func:`__import__` é–¢æ•°ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰å¾—ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:166
msgid ""
"This name will be used in various phases of the import search, and it may be"
" the dotted path to a submodule, e.g. ``foo.bar.baz``.  In this case, Python"
" first tries to import ``foo``, then ``foo.bar``, and finally "
"``foo.bar.baz``. If any of the intermediate imports fail, a "
":exc:`ModuleNotFoundError` is raised."
msgstr ""
"ã“ã®åå‰ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ¤œç´¢ã®æ§˜ã€…ãªãƒ•ã‚§ãƒ¼ã‚ºã§ä½¿ã‚ã‚Œã€ã“ã‚Œã¯ä¾‹ãˆã° ``foo.bar.baz`` "
"ã®ã‚ˆã†ãªãƒ‰ãƒƒãƒˆã§åŒºåˆ‡ã‚‰ã‚ŒãŸã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸ã®ãƒ‘ã‚¹ã ã£ãŸã‚Šã—ã¾ã™ã€‚ã“ã®å ´åˆã€ Python ã¯æœ€åˆã« ``foo`` ã‚’ã€æ¬¡ã« ``foo.bar`` "
"ã€ãã—ã¦æœ€å¾Œã« ``foo.bar.baz`` ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚ä¸­é–“ã®ã„ãšã‚Œã‹ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ãŸå ´åˆã¯ã€ "
":exc:`ModuleNotFoundError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:173
msgid "The module cache"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥"

#: ../../reference/import.rst:178
msgid ""
"The first place checked during import search is :data:`sys.modules`.  This "
"mapping serves as a cache of all modules that have been previously imported,"
" including the intermediate paths.  So if ``foo.bar.baz`` was previously "
"imported, :data:`sys.modules` will contain entries for ``foo``, ``foo.bar``,"
" and ``foo.bar.baz``.  Each key will have as its value the corresponding "
"module object."
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ¤œç´¢ã§æœ€åˆã«èª¿ã¹ã‚‹å ´æ‰€ã¯ :data:`sys.modules` "
"ã§ã™ã€‚ã“ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã¯ã€ä¸­é–“ã®ãƒ‘ã‚¹ã‚’å«ã‚€ã€ã“ã‚Œã¾ã§ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æä¾›ã—ã¾ã™ã€‚ãªã®ã§ ``foo.bar.baz`` "
"ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆæ¸ˆã¿ã®å ´åˆã€ :data:`sys.modules` ã¯ ``foo`` ã€ ``foo.bar`` ã€ ``foo.bar.baz`` "
"ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’å«ã¿ã¾ã™ã€‚ãã‚Œãã‚Œã®ã‚­ãƒ¼ã¯ãã®å€¤ã¨ã—ã¦å¯¾å¿œã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒã¡ã¾ã™ã€‚"

#: ../../reference/import.rst:185
msgid ""
"During import, the module name is looked up in :data:`sys.modules` and if "
"present, the associated value is the module satisfying the import, and the "
"process completes.  However, if the value is ``None``, then a "
":exc:`ModuleNotFoundError` is raised.  If the module name is missing, Python"
" will continue searching for the module."
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã¯ :data:`sys.modules` "
"ã‹ã‚‰æ¢ã•ã‚Œã€å­˜åœ¨ã—ãŸå ´åˆã¯ã€å¯¾å¿œã™ã‚‹å€¤ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã‚‹ã¹ããƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã‚ã‚Šã€ã“ã®å‡¦ç†ã¯å®Œäº†ã—ã¾ã™ã€‚ã—ã‹ã—å€¤ãŒ ``None`` ã ã£ãŸå ´åˆã€ "
":exc:`ModuleNotFoundError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åãŒè¦‹ä»˜ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã¯ã€ Python "
"ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ¤œç´¢ã‚’ç¶šã‘ã¾ã™ã€‚"

#: ../../reference/import.rst:191
msgid ""
":data:`sys.modules` is writable.  Deleting a key may not destroy the "
"associated module (as other modules may hold references to it), but it will "
"invalidate the cache entry for the named module, causing Python to search "
"anew for the named module upon its next import. The key can also be assigned"
" to ``None``, forcing the next import of the module to result in a "
":exc:`ModuleNotFoundError`."
msgstr ""
":data:`sys.modules` ã¯æ›¸ãè¾¼ã¿å¯èƒ½ã§ã™ã€‚ã‚­ãƒ¼ã®å‰Šé™¤ã¯å¯¾å¿œã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç ´å£Šã—ãªã„ "
"(ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸ã®å‚ç…§ã‚’æŒã£ã¦ã„ã‚‹) "
"ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’ç„¡åŠ¹ã«ã—ã€ãã‚ŒãŒæ¬¡ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸã¨ã Python "
"ã«ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ”¹ã‚ã¦æ¤œç´¢ã•ã›ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã‚­ãƒ¼ã‚’ ``None`` ã«å¯¾å¿œä»˜ã‘ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ãŒã€æ¬¡ã«ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã‚‹ã¨ãã« "
":exc:`ModuleNotFoundError` ã¨ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../reference/import.rst:198
msgid ""
"Beware though, as if you keep a reference to the module object, invalidate "
"its cache entry in :data:`sys.modules`, and then re-import the named module,"
" the two module objects will *not* be the same. By contrast, "
":func:`importlib.reload` will reuse the *same* module object, and simply "
"reinitialise the module contents by rerunning the module's code."
msgstr ""
"ãŸã¨ãˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’ä¿æŒã—ã¦ãŠã„ã¦ã€ :data:`sys.modules` "
"ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’ç„¡åŠ¹ã«ã—ã€ãã®æŒ‡å®šã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å†ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ãŸã¨ã—ã¦ã‚‚ã€ 2 ã¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯åŒã˜ã§ã¯ *ãªã„* "
"ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãã‚Œã¨ã¯å¯¾ç…§çš„ã«ã€ :func:`importlib.reload` ã¯ *åŒã˜* "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†åˆ©ç”¨ã—ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã‚’å†å®Ÿè¡Œã™ã‚‹ã“ã¨ã§å˜ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†…å®¹ã‚’å†åˆæœŸåŒ–ã™ã‚‹ã ã‘ã§ã™ã€‚"

#: ../../reference/import.rst:206
msgid "Finders and loaders"
msgstr "ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¨ãƒ­ãƒ¼ãƒ€ãƒ¼"

#: ../../reference/import.rst:213
msgid ""
"If the named module is not found in :data:`sys.modules`, then Python's "
"import protocol is invoked to find and load the module.  This protocol "
"consists of two conceptual objects, :term:`finders <finder>` and "
":term:`loaders <loader>`. A finder's job is to determine whether it can find"
" the named module using whatever strategy it knows about. Objects that "
"implement both of these interfaces are referred to as :term:`importers "
"<importer>` - they return themselves when they find that they can load the "
"requested module."
msgstr ""
":data:`sys.modules` ã«æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã¯ã€ Python "
"ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒèµ·å‹•ã•ã‚Œã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ã¤ã‘ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ 2 ã¤ã®æ¦‚å¿µçš„ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ :term:`ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ "
"<finder>` ã¨ :term:`ãƒ­ãƒ¼ãƒ€ãƒ¼ <loader>` "
"ã‹ã‚‰æˆã‚Šã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã®ä»•äº‹ã¯ã€çŸ¥ã£ã¦ã„ã‚‹æˆ¦ç•¥ã‚’ä½¿ã£ã¦æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œã‚‹ã‹ã©ã†ã‹åˆ¤æ–­ã™ã‚‹ã“ã¨ã§ã™ã€‚ä¸¡æ–¹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯"
" :term:`ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ <importer>` ã¨å‘¼ã°ã‚Œã¾ã™ - "
"ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã¯è¦æ±‚ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ­ãƒ¼ãƒ‰ã§ãã‚‹ã¨åˆ†ã‹ã£ãŸã¨ãã€è‡ªåˆ†è‡ªèº«ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/import.rst:221
msgid ""
"Python includes a number of default finders and importers.  The first one "
"knows how to locate built-in modules, and the second knows how to locate "
"frozen modules.  A third default finder searches an :term:`import path` for "
"modules.  The :term:`import path` is a list of locations that may name file "
"system paths or zip files.  It can also be extended to search for any "
"locatable resource, such as those identified by URLs."
msgstr ""
"Python ã«ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¨ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ãŒã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚ 1 ã¤ç›®ã®ã‚‚ã®ã¯çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è¦‹ã¤ã‘æ–¹ã‚’çŸ¥ã£ã¦ã„ã¦ã€ 2 "
"ã¤ç›®ã®ã‚‚ã®ã¯å‡çµã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (è¨³æ³¨: freeze ãƒ„ãƒ¼ãƒ«ã§å‡¦ç†ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã“ã¨ã€‚ :doc:`ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° FAQ "
"<../faq/programming>` ã®ã€Œã©ã†ã—ãŸã‚‰ Python ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‹ã‚‰ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ãƒã‚¤ãƒŠãƒªã‚’ä½œã‚Œã¾ã™ã‹ï¼Ÿã€ã®é …ç›®ã‚’å‚ç…§) "
"ã®è¦‹ã¤ã‘æ–¹ã‚’çŸ¥ã£ã¦ã„ã¾ã™ã€‚ 3 ã¤ç›®ã®ã‚‚ã®ã¯ :term:`ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‘ã‚¹ <import path>` ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¢ã—ã¾ã™ã€‚ "
":term:`ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‘ã‚¹ <import path>` ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‘ã‚¹ã‚„ zip ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½ç½®ã‚’ç¤ºã™ãƒªã‚¹ãƒˆã§ã™ã€‚ã“ã®ãƒªã‚¹ãƒˆã¯ã€ URL "
"ã§ç‰¹å®šã§ãã‚‹ã‚‚ã®ã®ã‚ˆã†ãªã€ä½ç½®ã‚’ç¤ºã™ã“ã¨ã®ã§ãã‚‹ä»»æ„ã®ãƒªã‚½ãƒ¼ã‚¹ã®æ¤œç´¢ã«ã¾ã§æ‹¡å¼µã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../reference/import.rst:228
msgid ""
"The import machinery is extensible, so new finders can be added to extend "
"the range and scope of module searching."
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯æ‹¡å¼µå¯èƒ½ãªã®ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¤œç´¢ã®ç¯„å›²ã¨ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æ‹¡å¼µã™ã‚‹ãŸã‚ã«æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã‚’ä»˜ã‘åŠ ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/import.rst:231
msgid ""
"Finders do not actually load modules.  If they can find the named module, "
"they return a :dfn:`module spec`, an encapsulation of the module's import-"
"related information, which the import machinery then uses when loading the "
"module."
msgstr ""
"ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯å®Ÿéš›ã«ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã›ã‚“ã€‚æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯ :dfn:`module spec` "
"(ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜)ã€ã™ãªã‚ã¡ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆé–¢é€£ã®æƒ…å ±ã‚’ã‚«ãƒ—ã‚»ãƒ«åŒ–ã—ãŸã‚‚ã®ã‚’è¿”ã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ­ãƒ¼ãƒ‰æ™‚ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ãã‚Œã‚’åˆ©ç”¨ã—ã¾ã™ã€‚"

#: ../../reference/import.rst:235
msgid ""
"The following sections describe the protocol for finders and loaders in more"
" detail, including how you can create and register new ones to extend the "
"import machinery."
msgstr ""
"æ¬¡ã®ç¯€ã§ã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã‚’æ‹¡å¼µã™ã‚‹ãŸã‚ã®æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã‚„ãƒ­ãƒ¼ãƒ€ãƒ¼ã®ä½œæˆã¨ç™»éŒ²ã‚’å«ã‚ã€ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¨ãƒ­ãƒ¼ãƒ€ãƒ¼ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«ã¤ã„ã¦ã‚ˆã‚Šè©³ã—ãè§£èª¬ã—ã¾ã™ã€‚"

#: ../../reference/import.rst:239
msgid ""
"In previous versions of Python, finders returned :term:`loaders <loader>` "
"directly, whereas now they return module specs which *contain* loaders. "
"Loaders are still used during import but have fewer responsibilities."
msgstr ""
"Python ã®ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯ç›´æ¥ :term:`ãƒ­ãƒ¼ãƒ€ãƒ¼ <loader>` ã‚’è¿”ã—ã¦ã„ã¾ã—ãŸãŒã€ç¾åœ¨ã¯ãƒ­ãƒ¼ãƒ€ãƒ¼ã‚’ *å«ã‚€* "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ã‚’è¿”ã—ã¾ã™ã€‚ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸­ã¯ã¾ã ä½¿ã‚ã‚Œã¦ã„ã¾ã™ãŒã€è²¬ä»»ã¯æ¸›ã‚Šã¾ã—ãŸã€‚"

#: ../../reference/import.rst:245
msgid "Import hooks"
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ•ãƒƒã‚¯"

#: ../../reference/import.rst:255
msgid ""
"The import machinery is designed to be extensible; the primary mechanism for"
" this are the *import hooks*.  There are two types of import hooks: *meta "
"hooks* and *import path hooks*."
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯æ‹¡å¼µå¯èƒ½ãªã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™; ãã®ä¸»ã¨ãªã‚‹ä»•çµ„ã¿ã¯ *ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ•ãƒƒã‚¯* ã§ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ•ãƒƒã‚¯ã«ã¯ 2 ç¨®é¡ã‚ã‚Šã¾ã™: "
"*ãƒ¡ã‚¿ãƒ•ãƒƒã‚¯* ã¨ *ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‘ã‚¹ãƒ•ãƒƒã‚¯* ã§ã™ã€‚"

#: ../../reference/import.rst:259
msgid ""
"Meta hooks are called at the start of import processing, before any other "
"import processing has occurred, other than :data:`sys.modules` cache look "
"up. This allows meta hooks to override :data:`sys.path` processing, frozen "
"modules, or even built-in modules.  Meta hooks are registered by adding new "
"finder objects to :data:`sys.meta_path`, as described below."
msgstr ""
"ãƒ¡ã‚¿ãƒ•ãƒƒã‚¯ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã®æœ€åˆã€ :data:`sys.modules` ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®æ¤œç´¢ä»¥å¤–ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã‚ˆã‚Šå‰ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ "
":data:`sys.path` "
"ã®å‡¦ç†ã‚„å‡çµã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„çµ„ã¿è¾¼ã¿ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã•ãˆã‚‚ã€ãƒ¡ã‚¿ãƒ•ãƒƒã‚¯ã§ä¸Šæ›¸ãã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ¡ã‚¿ãƒ•ãƒƒã‚¯ã¯ä»¥ä¸‹ã§è§£èª¬ã™ã‚‹ã‚ˆã†ã«ã€ "
":data:`sys.meta_path` ã«æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã§ç™»éŒ²ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:265
msgid ""
"Import path hooks are called as part of :data:`sys.path` (or "
"``package.__path__``) processing, at the point where their associated path "
"item is encountered.  Import path hooks are registered by adding new "
"callables to :data:`sys.path_hooks` as described below."
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‘ã‚¹ãƒ•ãƒƒã‚¯ã¯ã€ :data:`sys.path` (ã‚‚ã—ãã¯ ``package.__path__``) "
"ã®å‡¦ç†ã®ä¸€éƒ¨ã¨ã—ã¦ã€å¯¾å¿œã™ã‚‹ãƒ‘ã‚¹è¦ç´ ã‚’å–ã‚Šæ‰±ã†ã¨ã“ã‚ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‘ã‚¹ãƒ•ãƒƒã‚¯ã¯ä»¥ä¸‹ã§è§£èª¬ã™ã‚‹ã‚ˆã†ã«ã€æ–°ã—ã„å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ "
":data:`sys.path_hooks` ã«è¿½åŠ ã™ã‚‹ã“ã¨ã§ç™»éŒ²ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:272
msgid "The meta path"
msgstr "ãƒ¡ã‚¿ãƒ‘ã‚¹"

#: ../../reference/import.rst:278
msgid ""
"When the named module is not found in :data:`sys.modules`, Python next "
"searches :data:`sys.meta_path`, which contains a list of meta path finder "
"objects.  These finders are queried in order to see if they know how to "
"handle the named module.  Meta path finders must implement a method called "
":meth:`~importlib.abc.MetaPathFinder.find_spec()` which takes three "
"arguments: a name, an import path, and (optionally) a target module.  The "
"meta path finder can use any strategy it wants to determine whether it can "
"handle the named module or not."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ :data:`sys.modules` ã«è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã¨ãã€ Python "
"ã¯æ¬¡ã«ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ :data:`sys.meta_path` "
"ã‚’æ¤œç´¢ã—ã¾ã™ã€‚æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ‰±ã†ã“ã¨ãŒã§ãã‚‹ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹ãŸã‚ã«ã€å„ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã«å•ã„åˆã‚ã›ã‚’è¡Œã„ã¾ã™ã€‚ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã«ã¯ã€åå‰ã¨ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‘ã‚¹ã¨"
" (ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®) ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® 3 ã¤ã®å¼•æ•°ã‚’å–ã‚‹ "
":meth:`~importlib.abc.MetaPathFinder.find_spec()` "
"ã¨ã„ã†åå‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®Ÿè£…ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã§ã¯ã€æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ‰±ãˆã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ãŸã‚ã®æˆ¦ç•¥ã¯ä»»æ„ã®ã‚‚ã®ã‚’ä½¿ã£ã¦æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../reference/import.rst:287
msgid ""
"If the meta path finder knows how to handle the named module, it returns a "
"spec object.  If it cannot handle the named module, it returns ``None``.  If"
" :data:`sys.meta_path` processing reaches the end of its list without "
"returning a spec, then a :exc:`ModuleNotFoundError` is raised.  Any other "
"exceptions raised are simply propagated up, aborting the import process."
msgstr ""
"meta path finder ãŒæŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ‰±ã„æ–¹ã‚’çŸ¥ã£ã¦ã„ã‚‹å ´åˆã¯ã€ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ã¯ spec "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ‰±ãˆãªã„å ´åˆã¯ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ :data:`sys.meta_path` ã«å¯¾ã™ã‚‹å‡¦ç†ãŒ"
" spec ã‚’è¿”ã•ãšã«ãƒªã‚¹ãƒˆã®æœ«å°¾ã«åˆ°é”ã—ã¦ã—ã¾ã£ãŸå ´åˆã¯ã€ :exc:`ModuleNotFoundError` "
"ã‚’é€å‡ºã—ã¾ã™ã€‚ãã®ä»–ã®é€å‡ºã•ã‚ŒãŸä¾‹å¤–ã¯ãã®ã¾ã¾å‘¼ã³å‡ºã—å…ƒã«ä¼æ’­ã•ã‚Œã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã‚’ç•°å¸¸çµ‚äº†ã•ã›ã¾ã™ã€‚"

#: ../../reference/import.rst:293
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec()` method of meta path "
"finders is called with two or three arguments.  The first is the fully "
"qualified name of the module being imported, for example ``foo.bar.baz``. "
"The second argument is the path entries to use for the module search.  For "
"top-level modules, the second argument is ``None``, but for submodules or "
"subpackages, the second argument is the value of the parent package's "
"``__path__`` attribute. If the appropriate ``__path__`` attribute cannot be "
"accessed, a :exc:`ModuleNotFoundError` is raised.  The third argument is an "
"existing module object that will be the target of loading later. The import "
"system passes in a target module only during reload."
msgstr ""
"ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã® :meth:`~importlib.abc.MetaPathFinder.find_spec()` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ 2 ã¤ã¾ãŸã¯ "
"3 ã¤ã®å¼•æ•°ã‚’æ¸¡ã—ã¦å‘¼ã³å‡ºã—ã¾ã™ã€‚1 ã¤ç›®ã®å¼•æ•°ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å®Œå…¨ä¿®é£¾åã§ã€ä¾‹ãˆã° ``foo.bar.baz`` ãªã©ã§ã™ã€‚2 "
"ã¤ç›®ã®å¼•æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ¤œç´¢ã§ä½¿ã‚ã‚Œã‚‹ãƒ‘ã‚¹ã§ã™ã€‚æœ€ä¸Šä½ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ 2 ã¤ç›®ã®å¼•æ•°ã¯ ``None`` "
"ã«ã—ã¾ã™ãŒã€ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ã‚µãƒ–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã¯ 2 ã¤ç›®ã®å¼•æ•°ã¯è¦ªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® ``__path__`` å±æ€§ã®å€¤ã§ã™ã€‚é©åˆ‡ãª ``__path__``"
" å±æ€§ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã‹ã£ãŸå ´åˆã¯ã€ :exc:`ModuleNotFoundError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚3 "
"ã¤ç›®ã®å¼•æ•°ã¯ã€ã‚ã¨ã§ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ãªã‚‹æ—¢å­˜ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã¯ãƒªãƒ­ãƒ¼ãƒ‰ã®é–“ã ã‘ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« "
"ã‚’ã‚»ãƒƒãƒˆã—ã¾ã™ã€‚"

#: ../../reference/import.rst:304
msgid ""
"The meta path may be traversed multiple times for a single import request. "
"For example, assuming none of the modules involved has already been cached, "
"importing ``foo.bar.baz`` will first perform a top level import, calling "
"``mpf.find_spec(\"foo\", None, None)`` on each meta path finder (``mpf``). "
"After ``foo`` has been imported, ``foo.bar`` will be imported by traversing "
"the meta path a second time, calling ``mpf.find_spec(\"foo.bar\", "
"foo.__path__, None)``. Once ``foo.bar`` has been imported, the final "
"traversal will call ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, "
"None)``."
msgstr ""
"ãƒ¡ã‚¿ãƒ‘ã‚¹ã¯ã€1 å›ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆè¦æ±‚ã§è¤‡æ•°å›èµ°æŸ»ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€é–¢ä¿‚ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã©ã‚Œã‚‚ã¾ã ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¦ã„ãªã„ã¨ã—ãŸã¨ãã« "
"``foo.bar.baz`` ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã¨ã€æœ€åˆã¯å„ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ (``mpf``) ã«å¯¾ã—ã¦ "
"``mpf.find_spec(\"foo\", None, None)`` ã‚’å‘¼ã³å‡ºã—ã¦ã€æœ€ä¸Šä½ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã‚’è¡Œã„ã¾ã™ã€‚``foo`` "
"ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸå¾Œã«ã€``mpf.find_spec(\"foo.bar\", foo.__path__, None)`` ã‚’å‘¼ã³å‡ºã—ã¦ã„ã 2 "
"å›ç›®ã®ãƒ¡ã‚¿ãƒ‘ã‚¹ã®èµ°æŸ»ãŒè¡Œã‚ã‚Œã€``foo.bar`` ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚``foo.bar`` ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¾ã§è¡Œã‚ã‚ŒãŸã‚‰ã€æœ€å¾Œã®èµ°æŸ»ã§ "
"``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)`` ã‚’å‘¼ã³å‡ºã—ã¦ã„ãã¾ã™ã€‚"

#: ../../reference/import.rst:314
msgid ""
"Some meta path finders only support top level imports. These importers will "
"always return ``None`` when anything other than ``None`` is passed as the "
"second argument."
msgstr ""
"ã‚ã‚‹ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯æœ€ä¸Šä½ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®ã¿ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã¯ã€2 ã¤ç›®ã®å¼•æ•°ã« ``None`` "
"ä»¥å¤–ã®ã‚‚ã®ãŒæ¸¡ã•ã‚ŒãŸã¨ãã€å¸¸ã« ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/import.rst:318
msgid ""
"Python's default :data:`sys.meta_path` has three meta path finders, one that"
" knows how to import built-in modules, one that knows how to import frozen "
"modules, and one that knows how to import modules from an :term:`import "
"path` (i.e. the :term:`path based finder`)."
msgstr ""
"Python ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® :data:`sys.meta_path` ã¯ 3 "
"ã¤ã®ãƒ‘ã‚¹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã‚’æŒã£ã¦ã„ã¾ã™ã€‚çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®æ–¹æ³•ã‚’çŸ¥ã£ã¦ã„ã‚‹ã‚‚ã®ã€å‡çµã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®æ–¹æ³•ã‚’çŸ¥ã£ã¦ã„ã‚‹ã‚‚ã®ã€ "
":term:`ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‘ã‚¹ <import path>` ã‹ã‚‰ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®æ–¹æ³•ã‚’çŸ¥ã£ã¦ã„ã‚‹ã‚‚ã® (ã¤ã¾ã‚Š "
":term:`ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path based finder>`) ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/import.rst:323
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders replaced :meth:`~importlib.abc.MetaPathFinder.find_module`, which is"
" now deprecated.  While it will continue to work without change, the import "
"machinery will try it only if the finder does not implement ``find_spec()``."
msgstr ""
"ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã® :meth:`~importlib.abc.MetaPathFinder.find_spec` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ "
":meth:`~importlib.abc.MetaPathFinder.find_module` ã‚’ç½®ãæ›ãˆã¾ã—ãŸã€‚ "
"``find_module()`` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ deprecated ã§ã™ã€‚ãã‚Œã¯ä»Šã§ã‚‚å¤‰æ›´ãªã—ã«å‹•ãã¾ã™ãŒã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒ "
"``find_spec()`` ã‚’å®Ÿè£…ã—ã¦ã„ãªã„å ´åˆã«ã®ã¿ãã‚Œã‚’è©¦ã—ã¾ã™ã€‚"

#: ../../reference/import.rst:332
msgid "Loading"
msgstr "ãƒ­ãƒ¼ãƒ‰"

#: ../../reference/import.rst:334
msgid ""
"If and when a module spec is found, the import machinery will use it (and "
"the loader it contains) when loading the module.  Here is an approximation "
"of what happens during the loading portion of import::"
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹æ™‚ã«ãã‚Œ (ãŠã‚ˆã³ãã‚Œã«å«ã¾ã‚Œã‚‹ãƒ­ãƒ¼ãƒ€ãƒ¼) "
"ã‚’ä½¿ã„ã¾ã™ã€‚ã“ã‚Œã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®ãƒ­ãƒ¼ãƒ‰éƒ¨åˆ†ã§èµ·ã“ã‚‹ã“ã¨ã®è¿‘ä¼¼ã§ã™::"

#: ../../reference/import.rst:369
msgid "Note the following details:"
msgstr "ä»¥ä¸‹ã®è©³ç´°ã«æ³¨æ„ã—ã¦ãã ã•ã„:"

#: ../../reference/import.rst:371
msgid ""
"If there is an existing module object with the given name in "
":data:`sys.modules`, import will have already returned it."
msgstr ""
":data:`sys.modules` ã®ä¸­ã«ä¸ãˆã‚‰ã‚ŒãŸåå‰ã‚’æŒã¤æ—¢å­˜ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚‹ãªã‚‰ã€ import "
"ã¯æ—¢ã«ãã‚Œã‚’è¿”ã—ã¦ã„ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../reference/import.rst:374
msgid ""
"The module will exist in :data:`sys.modules` before the loader executes the "
"module code.  This is crucial because the module code may (directly or "
"indirectly) import itself; adding it to :data:`sys.modules` beforehand "
"prevents unbounded recursion in the worst case and multiple loading in the "
"best."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹å‰ã« :data:`sys.modules` ã«å­˜åœ¨ã—ã¦ã„ã¾ã™ã€‚ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚³ãƒ¼ãƒ‰ãŒ "
"(ç›´æ¥çš„ã¾ãŸã¯é–“æ¥çš„ã«) è‡ªåˆ†è‡ªèº«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã€ã“ã‚Œã¯é‡è¦ã§ã™; ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ :data:`sys.modules` "
"ã«è¿½åŠ ã™ã‚‹ã“ã¨ã§ã€æœ€æ‚ªã®ã‚±ãƒ¼ã‚¹ã§ã¯ç„¡é™ã®å†å¸°ãŒã€ãã—ã¦æœ€è‰¯ã®ã‚±ãƒ¼ã‚¹ã§ã¯è¤‡æ•°å›ã®ãƒ­ãƒ¼ãƒ‰ãŒã€å‰ã‚‚ã£ã¦é˜²æ­¢ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:380
msgid ""
"If loading fails, the failing module -- and only the failing module -- gets "
"removed from :data:`sys.modules`.  Any module already in the "
":data:`sys.modules` cache, and any module that was successfully loaded as a "
"side-effect, must remain in the cache.  This contrasts with reloading where "
"even the failing module is left in :data:`sys.modules`."
msgstr ""
"ãƒ­ãƒ¼ãƒ‰å‡¦ç†ã«å¤±æ•—ã—ãŸå ´åˆã€ãã®å¤±æ•—ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ -- ãã—ã¦ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã ã‘ãŒ -- :data:`sys.modules` "
"ã‹ã‚‰å–ã‚Šé™¤ã‹ã‚Œã¾ã™ã€‚ :data:`sys.modules` "
"ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«æ—¢ã«å«ã¾ã‚Œã¦ã„ãŸã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã€å‰¯ä½œç”¨ã¨ã—ã¦ãƒ­ãƒ¼ãƒ‰ã«æˆåŠŸã—ãŸã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€å¸¸ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«æ®‹ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ãƒªãƒ­ãƒ¼ãƒ‰ã¨ã¯å¯¾ç…§çš„ã§ã€ãƒªãƒ­ãƒ¼ãƒ‰ã®å ´åˆã¯å¤±æ•—ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚"
" :data:`sys.modules` ã«æ®‹ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:386
msgid ""
"After the module is created but before execution, the import machinery sets "
"the import-related module attributes (\"_init_module_attrs\" in the pseudo-"
"code example above), as summarized in a :ref:`later section <import-mod-"
"attrs>`."
msgstr ""
":ref:`å¾Œã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ <import-mod-attrs>` "
"ã§è¦ç´„ã•ã‚Œã‚‹ã‚ˆã†ã«ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä½œã‚‰ã‚Œã¦ã‹ã‚‰å®Ÿè¡Œã•ã‚Œã‚‹ã¾ã§ã®é–“ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆé–¢é€£ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å±æ€§ã‚’è¨­å®šã—ã¾ã™ (ä¸Šè¨˜æ“¬ä¼¼ã‚³ãƒ¼ãƒ‰ä¾‹ã® "
"\"_init_module_attrs\")ã€‚"

#: ../../reference/import.rst:391
msgid ""
"Module execution is the key moment of loading in which the module's "
"namespace gets populated.  Execution is entirely delegated to the loader, "
"which gets to decide what gets populated and how."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®Ÿè¡Œã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ãŒæ§‹ç¯‰ã•ã‚Œã‚‹ãƒ­ãƒ¼ãƒ‰ã®é‡è¦ãªç¬é–“ã§ã™ã€‚å®Ÿè¡Œã¯ãƒ­ãƒ¼ãƒ€ãƒ¼ã«å®Œå…¨ã«å§”ä»»ã•ã‚Œã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ä½•ã‚’ã©ã®ã‚ˆã†ã«æ§‹ç¯‰ã™ã‚‹ã‹ã‚’æ±ºå®šã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/import.rst:395
msgid ""
"The module created during loading and passed to exec_module() may not be the"
" one returned at the end of import [#fnlo]_."
msgstr ""
"ãƒ­ãƒ¼ãƒ‰ã®é–“ã«ä½œæˆã•ã‚Œã¦ exec_module() ã«æ¸¡ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®çµ‚ã‚ã‚Šã«è¿”ã•ã‚Œã‚‹ã‚‚ã®ã¨ã¯ç•°ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ [#fnlo]_ã€‚"

#: ../../reference/import.rst:398
msgid ""
"The import system has taken over the boilerplate responsibilities of "
"loaders.  These were previously performed by the "
":meth:`importlib.abc.Loader.load_module` method."
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã¯ãƒ­ãƒ¼ãƒ€ãƒ¼ã®å®šå‹çš„ãªè²¬ä»»ã‚’å¼•ãç¶™ãã¾ã—ãŸã€‚ã“ã‚Œã‚‰ã¯ä»¥å‰ã¯ "
":meth:`importlib.abc.Loader.load_module` ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦å®Ÿè¡Œã•ã‚Œã¾ã—ãŸã€‚"

#: ../../reference/import.rst:404
msgid "Loaders"
msgstr "ãƒ­ãƒ¼ãƒ€ãƒ¼"

#: ../../reference/import.rst:406
msgid ""
"Module loaders provide the critical function of loading: module execution. "
"The import machinery calls the :meth:`importlib.abc.Loader.exec_module` "
"method with a single argument, the module object to execute.  Any value "
"returned from :meth:`~importlib.abc.Loader.exec_module` is ignored."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ã€ãƒ­ãƒ¼ãƒ‰ã®é‡è¦ãªæ©Ÿèƒ½ã§ã‚ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®Ÿè¡Œæ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ã€å®Ÿè¡Œã—ã‚ˆã†ã¨ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å˜ä¸€ã®å¼•æ•°ã¨ã—ã¦"
" :meth:`importlib.abc.Loader.exec_module` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ "
":meth:`importlib.abc.Loader.exec_module` ã‹ã‚‰è¿”ã•ã‚ŒãŸä»»æ„ã®å€¤ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:411
msgid "Loaders must satisfy the following requirements:"
msgstr "ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ä»¥ä¸‹ã®ä»•æ§˜ã‚’æº€ãŸã—ã¦ã„ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“:"

#: ../../reference/import.rst:413
msgid ""
"If the module is a Python module (as opposed to a built-in module or a "
"dynamically loaded extension), the loader should execute the module's code "
"in the module's global name space (``module.__dict__``)."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ (çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„å‹•çš„ã«èª­ã¿è¾¼ã¾ã‚Œã‚‹æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ãªãã¦) Python "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã ã£ãŸå ´åˆã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«åå‰ç©ºé–“ (``module.__dict__``) ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã¹ãã§ã™ã€‚"

#: ../../reference/import.rst:417
msgid ""
"If the loader cannot execute the module, it should raise an "
":exc:`ImportError`, although any other exception raised during "
":meth:`~importlib.abc.Loader.exec_module` will be propagated."
msgstr ""
":meth:`~importlib.abc.Loader.exec_module` ã®å‘¼ã³å‡ºã—ä¸­ã« :exc:`ImportError` "
"ä»¥å¤–ã®ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã€ä¼æ’­ã•ã‚Œã¦ããŸã¨ã—ã¦ã‚‚ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã§ããªã„å ´åˆã¯ :exc:`ImportError` ã‚’é€å‡ºã™ã¹ãã§ã™ã€‚"

#: ../../reference/import.rst:421
msgid ""
"In many cases, the finder and loader can be the same object; in such cases "
"the :meth:`~importlib.abc.MetaPathFinder.find_spec` method would just return"
" a spec with the loader set to ``self``."
msgstr ""
"å¤šãã®å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¨ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§æ§‹ã„ã¾ã›ã‚“; ãã®ã‚ˆã†ãªå ´åˆã§ã¯ "
":meth:`~importlib.abc.MetaPathFinder.find_spec` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å˜ã« ``self`` (è¨³æ³¨: "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªèº«) ã‚’è¿”ã™ã ã‘ã§ã™ã€‚"

#: ../../reference/import.rst:425
msgid ""
"Module loaders may opt in to creating the module object during loading by "
"implementing a :meth:`~importlib.abc.Loader.create_module` method. It takes "
"one argument, the module spec, and returns the new module object to use "
"during loading.  ``create_module()`` does not need to set any attributes on "
"the module object.  If the method returns ``None``, the import machinery "
"will create the new module itself."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ã€ :meth:`~importlib.abc.Loader.create_module` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ãƒ­ãƒ¼ãƒ‰ä¸­ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã“ã¨ã‚’é¸æŠã§ãã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ã‚’å¼•æ•°ã«å–ã£ã¦ã€ãƒ­ãƒ¼ãƒ‰ä¸­ã«ä½¿ã†æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"
" ``create_module()`` ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å±æ€§ã‚’è¨­å®šã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒ ``None`` "
"ã‚’è¿”ã™ãªã‚‰ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è‡ªèº«ã§ä½œæˆã—ã¾ã™ã€‚"

#: ../../reference/import.rst:432
msgid "The :meth:`~importlib.abc.Loader.create_module` method of loaders."
msgstr "ãƒ­ãƒ¼ãƒ€ãƒ¼ã® :meth:`~importlib.abc.Loader.create_module` ãƒ¡ã‚½ãƒƒãƒ‰ã€‚"

#: ../../reference/import.rst:435
msgid ""
"The :meth:`~importlib.abc.Loader.load_module` method was replaced by "
":meth:`~importlib.abc.Loader.exec_module` and the import machinery assumed "
"all the boilerplate responsibilities of loading."
msgstr ""
":meth:`~importlib.abc.Loader.load_module` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ "
":meth:`~importlib.abc.Loader.exec_module` "
"ã«ã‚ˆã£ã¦ç½®ãæ›ãˆã‚‰ã‚Œã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ãŒãƒ­ãƒ¼ãƒ‰ã®ã™ã¹ã¦ã®å®šå‹è²¬ä»»ã‚’å¼•ãå—ã‘ã¾ã—ãŸã€‚"

#: ../../reference/import.rst:440
msgid ""
"For compatibility with existing loaders, the import machinery will use the "
"``load_module()`` method of loaders if it exists and the loader does not "
"also implement ``exec_module()``.  However, ``load_module()`` has been "
"deprecated and loaders should implement ``exec_module()`` instead."
msgstr ""
"æ—¢å­˜ã®ãƒ­ãƒ¼ãƒ€ãƒ¼ã¨ã®äº’æ›æ€§ã®ãŸã‚ã€ã‚‚ã—ãƒ­ãƒ¼ãƒ€ãƒ¼ã« ``load_module()`` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå­˜åœ¨ã—ã€ã‹ã¤ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒ ``exec_module()``"
" ã‚’å®Ÿè£…ã—ã¦ã„ãªã‘ã‚Œã°ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ãƒ­ãƒ¼ãƒ€ãƒ¼ã® ``load_module()`` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã„ã¾ã™ã€‚ã—ã‹ã—ã€ ``load_module()``"
" ã¯ deprecated ã§ã‚ã‚Šã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ä»£ã‚ã‚Šã« ``exec_module()`` ã‚’å®Ÿè£…ã™ã¹ãã§ã™ã€‚"

#: ../../reference/import.rst:445
msgid ""
"The ``load_module()`` method must implement all the boilerplate loading "
"functionality described above in addition to executing the module.  All the "
"same constraints apply, with some additional clarification:"
msgstr ""
"``load_module()`` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã«åŠ ãˆã¦ä¸Šè¨˜ã§èª¬æ˜ã•ã‚ŒãŸã™ã¹ã¦ã®å®šå‹çš„ãªãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ã‚’å®Ÿæ–½ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚åŒã˜åˆ¶ç´„ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚ä»¥ä¸‹ã¯è¿½åŠ ã®æ˜ç¢ºåŒ–ã§ã™:"

#: ../../reference/import.rst:449
msgid ""
"If there is an existing module object with the given name in "
":data:`sys.modules`, the loader must use that existing module. (Otherwise, "
":func:`importlib.reload` will not work correctly.)  If the named module does"
" not exist in :data:`sys.modules`, the loader must create a new module "
"object and add it to :data:`sys.modules`."
msgstr ""
":data:`sys.modules` ã«ä¸ãˆã‚‰ã‚ŒãŸåå‰ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå­˜åœ¨ã—ã¦ã„ã‚‹å ´åˆã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ãã®æ—¢å­˜ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã‚ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚ "
"(ãã†ã—ãªã„ã¨ :func:`importlib.reload` ã¯æ­£ã—ãå‹•ã‹ãªã„ã§ã—ã‚‡ã†ã€‚) æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ "
":data:`sys.modules` ã«å­˜åœ¨ã—ãªã„å ´åˆã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã€ :data:`sys.modules` "
"ã«è¿½åŠ ã—ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../reference/import.rst:455
msgid ""
"The module *must* exist in :data:`sys.modules` before the loader executes "
"the module code, to prevent unbounded recursion or multiple loading."
msgstr ""
"ç„¡é™ã®å†å¸°ã¾ãŸã¯è¤‡æ•°å›ã®ãƒ­ãƒ¼ãƒ‰ã‚’é˜²æ­¢ã™ã‚‹ãŸã‚ã«ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹å‰ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :data:`sys.modules` "
"ã«å­˜åœ¨ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ (*must*)ã€‚"

#: ../../reference/import.rst:459
msgid ""
"If loading fails, the loader must remove any modules it has inserted into "
":data:`sys.modules`, but it must remove **only** the failing module(s), and "
"only if the loader itself has loaded the module(s) explicitly."
msgstr ""
"ãƒ­ãƒ¼ãƒ‰å‡¦ç†ã«å¤±æ•—ã—ãŸå ´åˆã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ :data:`sys.modules` "
"ã«è¿½åŠ ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å–ã‚Šé™¤ã‹ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ãŒã€ãã‚Œã¯ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« **ã®ã¿** "
"ã‚’ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ­ãƒ¼ãƒ€ãƒ¼è‡ªèº«ã«æ˜ç¤ºçš„ã«ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå ´åˆã«é™ã‚Šã€é™¤å»ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/import.rst:464
msgid ""
"A :exc:`DeprecationWarning` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"``exec_module()`` ãŒå®šç¾©ã•ã‚Œã¦ã„ã¦ ``create_module()`` ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ "
":exc:`DeprecationWarning` ãŒé€å‡ºã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../reference/import.rst:468
msgid ""
"An :exc:`ImportError` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"``exec_module()`` ãŒå®šç¾©ã•ã‚Œã¦ã„ã¦ ``create_module()`` ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ "
":exc:`ImportError` ãŒé€å‡ºã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../reference/import.rst:473
msgid "Submodules"
msgstr "ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../reference/import.rst:475
msgid ""
"When a submodule is loaded using any mechanism (e.g. ``importlib`` APIs, the"
" ``import`` or ``import-from`` statements, or built-in ``__import__()``) a "
"binding is placed in the parent module's namespace to the submodule object. "
"For example, if package ``spam`` has a submodule ``foo``, after importing "
"``spam.foo``, ``spam`` will have an attribute ``foo`` which is bound to the "
"submodule.  Let's say you have the following directory structure::"
msgstr ""
"ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã®ã«ã©ã®ã‚ˆã†ãªãƒ¡ã‚«ãƒ‹ã‚ºãƒ  (ä¾‹ãˆã°ã€ ``importlib`` API ã€ ``import`` ã¾ãŸã¯ ``import-"
"from`` ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã€ã¾ãŸã¯ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•°ã® ``__import__``) "
"ãŒä½¿ã‚ã‚ŒãŸå ´åˆã§ã‚‚ã€ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã¯ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¦ªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ã«é…ç½®ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚‚ã—ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ ``spam`` "
"ãŒã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« ``foo`` ã‚’æŒã£ã¦ã„ãŸå ´åˆã€ ``spam.foo`` ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ãŸå¾Œã¯ ``spam`` "
"ã¯å€¤ãŒã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æŸç¸›ã•ã‚ŒãŸå±æ€§ ``foo`` ã‚’æŒã¡ã¾ã™ã€‚ä»¥ä¸‹ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚’æŒã£ã¦ã„ã‚‹ã¨ã—ã¾ã—ã‚‡ã†::"

#: ../../reference/import.rst:487
msgid "and ``spam/__init__.py`` has the following lines in it::"
msgstr "ãã—ã¦ ``spam/__init__.py`` ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã¨ã—ã¾ã™::"

#: ../../reference/import.rst:492
msgid ""
"then executing the following puts a name binding to ``foo`` and ``bar`` in "
"the ``spam`` module::"
msgstr ""
"ã“ã®ã¨ãã€ä»¥ä¸‹ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã«ã‚ˆã‚Š ``spam`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¸­ã« ``foo`` ã¨ ``bar`` ã«æŸç¸›ã•ã‚ŒãŸåå‰ãŒç½®ã‹ã‚Œã¾ã™::"

#: ../../reference/import.rst:501
msgid ""
"Given Python's familiar name binding rules this might seem surprising, but "
"it's actually a fundamental feature of the import system.  The invariant "
"holding is that if you have ``sys.modules['spam']`` and "
"``sys.modules['spam.foo']`` (as you would after the above import), the "
"latter must appear as the ``foo`` attribute of the former."
msgstr ""
"Python "
"ã®æ…£ã‚Œè¦ªã—ã‚“ã åå‰æŸç¸›ãƒ«ãƒ¼ãƒ«ã‹ã‚‰ã™ã‚‹ã¨ã“ã‚Œã¯é©šãã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ãã‚Œã¯å®Ÿéš›ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®åŸºæœ¬çš„ãªæ©Ÿèƒ½ã§ã™ã€‚ä¸å¤‰ã«ä¿ãŸãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã¯ "
"(ä¸Šè¨˜ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®å¾Œãªã©ã§) ``sys.modules['spam']`` ã¨ ``sys.modules['spam.foo']`` "
"ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€å¾Œè€…ãŒå‰è€…ã® ``foo`` å±æ€§ã¨ã—ã¦å­˜åœ¨ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../reference/import.rst:508
msgid "Module spec"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜"

#: ../../reference/import.rst:510
msgid ""
"The import machinery uses a variety of information about each module during "
"import, especially before loading.  Most of the information is common to all"
" modules.  The purpose of a module's spec is to encapsulate this import-"
"related information on a per-module basis."
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®é–“ (ç‰¹ã«ãƒ­ãƒ¼ãƒ‰ã®å‰) "
"ã«ã€å€‹ã€…ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦ã®ã•ã¾ã–ã¾ãªæƒ…å ±ã‚’æ‰±ã„ã¾ã™ã€‚æƒ…å ±ã®ã»ã¨ã‚“ã©ã¯ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å…±é€šã§ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ã®ç›®çš„ã¯ã€ã“ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆé–¢é€£ã®æƒ…å ±ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å˜ä½ã§ã‚«ãƒ—ã‚»ãƒ«åŒ–ã™ã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../reference/import.rst:515
msgid ""
"Using a spec during import allows state to be transferred between import "
"system components, e.g. between the finder that creates the module spec and "
"the loader that executes it.  Most importantly, it allows the import "
"machinery to perform the boilerplate operations of loading, whereas without "
"a module spec the loader had that responsibility."
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®éš›ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ã‚’ä½¿ã†ã“ã¨ã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆé–“ã€ä¾‹ãˆã°ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ã‚’ä½œæˆã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¨ãã‚Œã‚’å®Ÿè¡Œã™ã‚‹ãƒ­ãƒ¼ãƒ€ãƒ¼ã®é–“ã§çŠ¶æ…‹ã‚’è»¢é€ã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚æœ€ã‚‚é‡è¦ãªã®ã¯ã€ãã‚Œã«ã‚ˆã£ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ãŒãƒ­ãƒ¼ãƒ‰ã®å®šå‹çš„ãªä½œæ¥­ã‚’å®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ã“ã‚Œã«å¯¾ã—ã¦ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ãªã—ã§ã¯ãƒ­ãƒ¼ãƒ€ãŒãã®è²¬ä»»ã‚’æ‹…ã£ã¦ã„ã¾ã—ãŸã€‚"

#: ../../reference/import.rst:521
msgid ""
"The module's spec is exposed as the ``__spec__`` attribute on a module "
"object. See :class:`~importlib.machinery.ModuleSpec` for details on the "
"contents of the module spec."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® ``__spec__`` å±æ€§ã¨ã—ã¦å…¬é–‹ã•ã‚Œã¾ã™ã€‚\n"
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ã®å†…å®¹ã®è©³ç´°ã«ã¤ã„ã¦ã¯ :class:`~importlib.machinery.ModuleSpec` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/import.rst:530
msgid "Import-related module attributes"
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆé–¢é€£ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å±æ€§"

#: ../../reference/import.rst:532
msgid ""
"The import machinery fills in these attributes on each module object during "
"loading, based on the module's spec, before the loader executes the module."
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ãƒ­ãƒ¼ãƒ‰ã®é–“ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä»•æ§˜ã«åŸºã¥ã„ã¦ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå®Ÿè¡Œã™ã‚‹å‰ã«ä»¥ä¸‹ã®å±æ€§ã‚’æ›¸ãè¾¼ã¿ã¾ã™ã€‚"

#: ../../reference/import.rst:538
msgid ""
"The ``__name__`` attribute must be set to the fully-qualified name of the "
"module.  This name is used to uniquely identify the module in the import "
"system."
msgstr ""
"``__name__`` å±æ€§ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å®Œå…¨ä¿®é£¾åã«è¨­å®šã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®åå‰ã‚’åˆ©ç”¨ã—ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä¸€æ„ã«è­˜åˆ¥ã—ã¾ã™ã€‚"

#: ../../reference/import.rst:544
msgid ""
"The ``__loader__`` attribute must be set to the loader object that the "
"import machinery used when loading the module.  This is mostly for "
"introspection, but can be used for additional loader-specific functionality,"
" for example getting data associated with a loader."
msgstr ""
"``__loader__`` "
"å±æ€§ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ­ãƒ¼ãƒ‰æ™‚ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ãŒä½¿ç”¨ã—ãŸãƒ­ãƒ¼ãƒ€ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¨­å®šã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®å±æ€§ã¯æ™®é€šã¯å†…çœç”¨ã®ã‚‚ã®ã§ã™ãŒã€ãƒ­ãƒ¼ãƒ€ãƒ¼å›ºæœ‰ã®è¿½åŠ æ©Ÿèƒ½ã®ãŸã‚ã«ç”¨ã„ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚ä¾‹ãˆã°ãƒ­ãƒ¼ãƒ€ãƒ¼é–¢é€£ã®ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã§ã™ã€‚"

#: ../../reference/import.rst:551
msgid ""
"The module's ``__package__`` attribute must be set.  Its value must be a "
"string, but it can be the same value as its ``__name__``.  When the module "
"is a package, its ``__package__`` value should be set to its ``__name__``.  "
"When the module is not a package, ``__package__`` should be set to the empty"
" string for top-level modules, or for submodules, to the parent package's "
"name.  See :pep:`366` for further details."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``__package__`` å±æ€§ã¯è¨­å®šã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å€¤ã¯æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ãŒã€``__name__`` "
"ã¨åŒã˜å€¤ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å ´åˆã€``__package__`` ã®å€¤ã¯ãã® ``__name__`` "
"ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ãªã„å ´åˆã€ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ ``__package__`` "
"ç©ºã®æ–‡å­—åˆ—ã€ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯è¦ªã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚è©³ç´°ã¯ :pep:`366` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/import.rst:559
msgid ""
"This attribute is used instead of ``__name__`` to calculate explicit "
"relative imports for main modules, as defined in :pep:`366`. It is expected "
"to have the same value as ``__spec__.parent``."
msgstr ""
"ã“ã®å±æ€§ã¯ :pep:`366` ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã€ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ã®æ˜ç¤ºçš„ãªç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«ã€ ``__name__`` ã®ä»£ã‚ã‚Šã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚\n"
"ã“ã®å±æ€§ã¯ ``__spec__.parent`` ã¨åŒã˜å€¤ã‚’æŒã¤ã“ã¨ã‚’è¦æ±‚ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:563
msgid ""
"The value of ``__package__`` is expected to be the same as "
"``__spec__.parent``."
msgstr "``__package__`` ã®å€¤ãŒ ``__spec__.parent`` ã¨åŒã˜å€¤ã‚’æŒã¤ã“ã¨ã‚’è¦æ±‚ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../reference/import.rst:569
msgid ""
"The ``__spec__`` attribute must be set to the module spec that was used when"
" importing the module. Setting ``__spec__`` appropriately applies equally to"
" :ref:`modules initialized during interpreter startup <programs>`.  The one "
"exception is ``__main__``, where ``__spec__`` is :ref:`set to None in some "
"cases <main_spec>`."
msgstr ""
"``__spec__`` å±æ€§ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ­ãƒ¼ãƒ‰æ™‚ã«ä½¿ç”¨ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ãƒšãƒƒã‚¯ã«è¨­å®šã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"``__spec__`` ã‚’é©åˆ‡ã«è¨­å®šã™ã‚‹ã¨ :ref:`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿èµ·å‹•ä¸­ã«åˆæœŸåŒ–ã•ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« <programs>` ã«ã‚‚åŒæ§˜ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚\n"
"ä¾‹å¤–ã¯ ``__main__`` ã§ã€``__spec__`` ã¯ :ref:`å ´åˆã«ã‚ˆã£ã¦ã¯ None ã«è¨­å®šã•ã‚Œã¾ã™ <main_spec>`ã€‚"

#: ../../reference/import.rst:575
msgid ""
"When ``__package__`` is not defined, ``__spec__.parent`` is used as a "
"fallback."
msgstr "``__package__`` ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„ã¨ãã¯ ``__spec__.parent`` ãŒãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:580
msgid ""
"``__spec__.parent`` is used as a fallback when ``__package__`` is not "
"defined."
msgstr ""
"``__package__`` ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„ã¨ãã« ``__spec__.parent`` ãŒãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../reference/import.rst:586
msgid ""
"If the module is a package (either regular or namespace), the module "
"object's ``__path__`` attribute must be set.  The value must be iterable, "
"but may be empty if ``__path__`` has no further significance. If "
"``__path__`` is not empty, it must produce strings when iterated over. More "
"details on the semantics of ``__path__`` are given :ref:`below <package-"
"path-rules>`."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ (é€šå¸¸ã®ã¾ãŸã¯åå‰ç©ºé–“) ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å ´åˆã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®  ``__path__`` "
"å±æ€§ãŒè¨­å®šã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å€¤ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ãŒã€``__path__`` "
"ã«æ„å‘³ãŒãªã„å ´åˆã¯ç©ºã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚``__path__`` ãŒç©ºã§ãªã„å ´åˆã€ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆæ™‚ã«æ–‡å­—åˆ—ã‚’ç”Ÿæˆã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚``__path__`` "
"ã®ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã®è©³ç´°ã¯  :ref:`ä¸‹è¨˜ <package-path-rules>` ã®é€šã‚Šã§ã™ã€‚"

#: ../../reference/import.rst:593
msgid "Non-package modules should not have a ``__path__`` attribute."
msgstr "ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ãªã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ ``__path__`` å±æ€§ã‚’æŒã£ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../reference/import.rst:598
msgid ""
"``__file__`` is optional. If set, this attribute's value must be a string.  "
"The import system may opt to leave ``__file__`` unset if it has no semantic "
"meaning (e.g. a module loaded from a database)."
msgstr ""
"``__file__`` ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã™ã€‚ã‚‚ã—è¨­å®šã•ã‚Œã‚‹ãªã‚‰ã°ã€ã“ã®å±æ€§ã®å€¤ã¯æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—ãã®ã‚ˆã†ãªå±æ€§ãŒæ„å‘³ã‚’æŒãŸãªã„å ´åˆ "
"(ä¾‹ãˆã°ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå ´åˆ) ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã¯ ``__file__`` ã‚’æœªè¨­å®šã®ã¾ã¾ã«ã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../reference/import.rst:602
msgid ""
"If ``__file__`` is set, it may also be appropriate to set the ``__cached__``"
" attribute which is the path to any compiled version of the code (e.g. byte-"
"compiled file). The file does not need to exist to set this attribute; the "
"path can simply point to where the compiled file would exist (see "
":pep:`3147`)."
msgstr ""
"ã‚‚ã— ``__file__`` ã‚’è¨­å®šã™ã‚‹ãªã‚‰ã€ ``__cached__`` å±æ€§ã‚‚ã‚³ãƒ¼ãƒ‰ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã©ã‚Œã‹ "
"(ä¾‹ãˆã°ã€ãƒã‚¤ãƒˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«) ã¸ã®ãƒ‘ã‚¹ã«è¨­å®šã™ã‚‹ã“ã¨ãŒé©åˆ‡ã§ã—ã‚‡ã†ã€‚ã“ã®å±æ€§ã‚’è¨­å®šã™ã‚‹ã«ã‚ãŸã£ã¦ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“; "
"ãƒ‘ã‚¹ã¯ã€å˜ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„å ´æ‰€ã‚’ç¤ºã—ã¦ã„ã‚‹ã ã‘ã§ã™ (:pep:`3147` ã‚’å‚ç…§)ã€‚"

#: ../../reference/import.rst:608
msgid ""
"It is also appropriate to set ``__cached__`` when ``__file__`` is not set.  "
"However, that scenario is quite atypical.  Ultimately, the loader is what "
"makes use of ``__file__`` and/or ``__cached__``.  So if a loader can load "
"from a cached module but otherwise does not load from a file, that atypical "
"scenario may be appropriate."
msgstr ""
"``__file__`` ãŒè¨­å®šã•ã‚Œãªã„å ´åˆã«ã‚‚ ``__cached__`` "
"ã‚’è¨­å®šã™ã‚‹ã“ã¨ã¯é©åˆ‡ã§ã™ã€‚ã—ã‹ã—ã€ãã®ã‚·ãƒŠãƒªã‚ªã¯ã‹ãªã‚Šå¤‰å‰‡çš„ã§ã™ã€‚ç©¶æ¥µçš„ã«ã¯ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã¨ã¯ ``__file__`` ã¨ ``__cached__`` "
"ã®ã©ã¡ã‚‰ã‹ã¾ãŸã¯ä¸¡æ–¹ã‚’åˆ©ç”¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚ã—ãŸãŒã£ã¦ã€ã‚‚ã—ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ä¸€æ–¹ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã¯ãƒ­ãƒ¼ãƒ‰ã—ãªã„ãªã‚‰ã€ãã®å¤‰å‰‡çš„ãªã‚·ãƒŠãƒªã‚ªã¯é©åˆ‡ã§ã—ã‚‡ã†ã€‚"

#: ../../reference/import.rst:617
msgid "module.__path__"
msgstr "module.__path__"

#: ../../reference/import.rst:619
msgid ""
"By definition, if a module has a ``__path__`` attribute, it is a package."
msgstr "å®šç¾©ã‚ˆã‚Šã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã« ``__path__`` å±æ€§ãŒã‚ã‚Œã°ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../reference/import.rst:621
msgid ""
"A package's ``__path__`` attribute is used during imports of its "
"subpackages. Within the import machinery, it functions much the same as "
":data:`sys.path`, i.e. providing a list of locations to search for modules "
"during import. However, ``__path__`` is typically much more constrained than"
" :data:`sys.path`."
msgstr ""
"ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® ``__path__`` å±æ€§ã¯ã€ãã®ã‚µãƒ–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸­ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã®å†…éƒ¨ã§ã¯ã€ãã‚Œã¯ "
":data:`sys.path` ã¨ã»ã¨ã‚“ã©åŒã˜ã‚ˆã†ã«æ©Ÿèƒ½ã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸­ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¢ã™å ´æ‰€ã®ãƒªã‚¹ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚ã—ã‹ã—ã€ä¸€èˆ¬çš„ã« "
"``__path__`` ã¯ :data:`sys.path` ã‚ˆã‚Šã‚‚åˆ¶ç´„ãŒå¼·ã„ã§ã™ã€‚"

#: ../../reference/import.rst:627
msgid ""
"``__path__`` must be an iterable of strings, but it may be empty. The same "
"rules used for :data:`sys.path` also apply to a package's ``__path__``, and "
":data:`sys.path_hooks` (described below) are consulted when traversing a "
"package's ``__path__``."
msgstr ""
"``__path__`` ã¯æ–‡å­—åˆ—ã® iterable ã§ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ãŒã€ç©ºã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ :data:`sys.path` "
"ã¨åŒã˜è¦å‰‡ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® ``__path__`` ã«ã‚‚é©ç”¨ã•ã‚Œã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® ``__path__`` ã‚’èµ°æŸ»ã™ã‚‹ã¨ãã« (å¾Œã§è§£èª¬ã™ã‚‹) "
":data:`sys.path_hooks` ãŒè€ƒæ…®ã«å…¥ã‚Œã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:632
msgid ""
"A package's ``__init__.py`` file may set or alter the package's ``__path__``"
" attribute, and this was typically the way namespace packages were "
"implemented prior to :pep:`420`.  With the adoption of :pep:`420`, namespace"
" packages no longer need to supply ``__init__.py`` files containing only "
"``__path__`` manipulation code; the import machinery automatically sets "
"``__path__`` correctly for the namespace package."
msgstr ""
"ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® ``__init__.py`` ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® ``__path__`` å±æ€§ã‚’è¨­å®šã‚‚ã—ãã¯å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã€ã“ã‚ŒãŒ "
":pep:`420` ä»¥å‰ã®åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å…¸å‹çš„ãªå®Ÿè£…æ–¹æ³•ã§ã—ãŸã€‚ :pep:`420` ã®æ¡æŠã«ã‚ˆã‚Šã€ã‚‚ã¯ã‚„åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€ "
"``__path__`` ã‚’æ“ä½œã™ã‚‹ã‚³ãƒ¼ãƒ‰ã ã‘ã‚’å«ã‚€ ``__init__.py`` "
"ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æä¾›ã™ã‚‹å¿…è¦ãŒãªããªã‚Šã¾ã—ãŸ;ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ã€åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å¯¾ã—è‡ªå‹•çš„ã«é©åˆ‡ãª ``__path__`` ã‚’ã‚»ãƒƒãƒˆã—ã¾ã™ã€‚"

#: ../../reference/import.rst:640
msgid "Module reprs"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® repr"

#: ../../reference/import.rst:642
msgid ""
"By default, all modules have a usable repr, however depending on the "
"attributes set above, and in the module's spec, you can more explicitly "
"control the repr of module objects."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯åˆ©ç”¨å¯èƒ½ãª repr "
"ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ãŸã ã—ã“ã‚Œã¯ä¸Šä½ã§è¨­å®šã•ã‚ŒãŸå±æ€§ã«ä¾å­˜ã—ã¦ãŠã‚Šã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ã«ã‚ˆã£ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® repr "
"ã‚’ã‚ˆã‚Šæ˜ç¤ºçš„ã«åˆ¶å¾¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/import.rst:646
msgid ""
"If the module has a spec (``__spec__``), the import machinery will try to "
"generate a repr from it.  If that fails or there is no spec, the import "
"system will craft a default repr using whatever information is available on "
"the module.  It will try to use the ``module.__name__``, "
"``module.__file__``, and ``module.__loader__`` as input into the repr, with "
"defaults for whatever information is missing."
msgstr ""
"ã‚‚ã—ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä»•æ§˜ (``__spec__``) ã‚’æŒã£ã¦ã„ã‚Œã°ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ãã“ã‹ã‚‰ repr "
"ã‚’ç”Ÿæˆã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚ã‚‚ã—ãã‚ŒãŒå¤±æ•—ã™ã‚‹ã‹ã€ã¾ãŸã¯ä»•æ§˜ãŒå­˜åœ¨ã—ãªã‘ã‚Œã°ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å…¥æ‰‹å¯èƒ½ãªã‚ã‚‰ã‚†ã‚‹æƒ…å ±ã‚’ä½¿ã£ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® "
"repr ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚ãã‚Œã¯ ``module.__name__``, ``module.__file__``, "
"``module.__loader__`` ã‚’ (è¶³ã‚Šãªã„æƒ…å ±ã«ã¤ã„ã¦ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ã£ã¦è£œã„ãªãŒã‚‰) repr ã¸ã®å…¥åŠ›ã¨ã—ã¦ä½¿ãŠã†ã¨è©¦ã¿ã¾ã™ã€‚"

#: ../../reference/import.rst:653
msgid "Here are the exact rules used:"
msgstr "ã“ã‚ŒãŒä½¿ã‚ã‚Œã¦ã„ã‚‹æ­£ç¢ºãªè¦å‰‡ã§ã™:"

#: ../../reference/import.rst:655
msgid ""
"If the module has a ``__spec__`` attribute, the information in the spec is "
"used to generate the repr.  The \"name\", \"loader\", \"origin\", and "
"\"has_location\" attributes are consulted."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ ``__spec__`` å±æ€§ã‚’æŒã£ã¦ã„ã‚Œã°ã€ä»•æ§˜ã«å«ã¾ã‚Œã‚‹æƒ…å ±ãŒ repr ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ \"name\", "
"\"loader\", \"origin\", \"has_location\" å±æ€§ãŒå‚ç…§ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:659
msgid ""
"If the module has a ``__file__`` attribute, this is used as part of the "
"module's repr."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã« ``__file__`` å±æ€§ãŒã‚ã‚‹å ´åˆã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® repr ã®ä¸€éƒ¨ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:662
msgid ""
"If the module has no ``__file__`` but does have a ``__loader__`` that is not"
" ``None``, then the loader's repr is used as part of the module's repr."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã« ``__file__`` ã¯ãªã„ãŒ ``__loader__`` ãŒã‚ã‚Šã€ãã®å€¤ãŒ ``None`` ã§ã¯ãªã„å ´åˆã¯ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã® repr"
" ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® repr ã®ä¸€éƒ¨ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:665
msgid "Otherwise, just use the module's ``__name__`` in the repr."
msgstr "ãã†ã§ãªã‘ã‚Œã°ã€å˜ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``__name__`` ã‚’ repr ã®ä¸­ã§ä½¿ã„ã¾ã™ã€‚"

#: ../../reference/import.rst:667
msgid ""
"Use of :meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` has "
"been deprecated and the module spec is now used by the import machinery to "
"generate a module repr."
msgstr ""
":meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` ã®ä½¿ç”¨ã¯ "
"deprecated ã§ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã«ã‚ˆã‚Šãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« repr ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../reference/import.rst:672
msgid ""
"For backward compatibility with Python 3.3, the module repr will be "
"generated by calling the loader's :meth:`~importlib.abc.Loader.module_repr` "
"method, if defined, before trying either approach described above.  However,"
" the method is deprecated."
msgstr ""
"Python 3.3 ã¨ã®å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã«ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã® :meth:`~importlib.abc.Loader.module_repr` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãŸã‚‰ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« repr ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ä¸Šè¨˜ã®ã„ãšã‚Œã‹ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’è©¦ã™å‰ã«ãã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã¾ã™ã€‚ãŸã ã—ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ "
"deprecated ã§ã™ã€‚"

#: ../../reference/import.rst:680
msgid "Cached bytecode invalidation"
msgstr ""

#: ../../reference/import.rst:682
msgid ""
"Before Python loads cached bytecode from ``.pyc`` file, it checks whether "
"the cache is up-to-date with the source ``.py`` file. By default, Python "
"does this by storing the source's last-modified timestamp and size in the "
"cache file when writing it. At runtime, the import system then validates the"
" cache file by checking the stored metadata in the cache file against at "
"source's metadata."
msgstr ""

#: ../../reference/import.rst:689
msgid ""
"Python also supports \"hash-based\" cache files, which store a hash of the "
"source file's contents rather than its metadata. There are two variants of "
"hash-based ``.pyc`` files: checked and unchecked. For checked hash-based "
"``.pyc`` files, Python validates the cache file by hashing the source file "
"and comparing the resulting hash with the hash in the cache file. If a "
"checked hash-based cache file is found to be invalid, Python regenerates it "
"and writes a new checked hash-based cache file. For unchecked hash-based "
"``.pyc`` files, Python simply assumes the cache file is valid if it exists. "
"Hash-based ``.pyc`` files validation behavior may be overridden with the "
":option:`--check-hash-based-pycs` flag."
msgstr ""

#: ../../reference/import.rst:700
msgid ""
"Added hash-based ``.pyc`` files. Previously, Python only supported "
"timestamp-based invalidation of bytecode caches."
msgstr ""

#: ../../reference/import.rst:706
msgid "The Path Based Finder"
msgstr "ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼"

#: ../../reference/import.rst:711
msgid ""
"As mentioned previously, Python comes with several default meta path "
"finders. One of these, called the :term:`path based finder` "
"(:class:`~importlib.machinery.PathFinder`), searches an :term:`import path`,"
" which contains a list of :term:`path entries <path entry>`.  Each path "
"entry names a location to search for modules."
msgstr ""
"ä¸Šã§è§¦ã‚ŒãŸé€šã‚Šã€ Python ã«ã¯ã„ãã¤ã‹ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒå‚™ã‚ã£ã¦ã„ã¾ã™ã€‚ãã®ã†ã¡ã® 1 ã¤ã¯ "
":term:`ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path based finder>` "
"(:class:`~importlib.machinery.PathFinder`) ã¨å‘¼ã°ã‚Œã€ :term:`ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒª <path entry>`"
" ã®ãƒªã‚¹ãƒˆã§ã‚ã‚‹ :term:`ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‘ã‚¹ <import path>` "
"ã‚’æ¤œç´¢ã—ã¾ã™ã€‚ãã‚Œãã‚Œã®ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¢ã™å ´æ‰€ã‚’æŒ‡ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/import.rst:717
msgid ""
"The path based finder itself doesn't know how to import anything. Instead, "
"it traverses the individual path entries, associating each of them with a "
"path entry finder that knows how to handle that particular kind of path."
msgstr ""
"ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼è‡ªä½“ã¯ä½•ã‹ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–¹æ³•ã‚’çŸ¥ã£ã¦ã„ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã®ä»£ã‚ã‚Šã«ã€å€‹ã€…ã®ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªã‚’èµ°æŸ»ã—ã€ãã‚Œãã‚Œã«ç‰¹å®šã®ç¨®é¡ã®ãƒ‘ã‚¹ã®æ‰±ã„ã‚’çŸ¥ã£ã¦ã„ã‚‹ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã‚’é–¢é€£ä»˜ã‘ã¾ã™ã€‚"

#: ../../reference/import.rst:721
msgid ""
"The default set of path entry finders implement all the semantics for "
"finding modules on the file system, handling special file types such as "
"Python source code (``.py`` files), Python byte code (``.pyc`` files) and "
"shared libraries (e.g. ``.so`` files). When supported by the "
":mod:`zipimport` module in the standard library, the default path entry "
"finders also handle loading all of these file types (other than shared "
"libraries) from zipfiles."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã®ã™ã¹ã¦ã®ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚ãã‚Œã¯ Python "
"ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ (``.py`` ãƒ•ã‚¡ã‚¤ãƒ«) ã€Python ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ (``.pyc`` ãƒ•ã‚¡ã‚¤ãƒ«) ã€å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒª (ä¾‹ãˆã° ``.so`` "
"ãƒ•ã‚¡ã‚¤ãƒ«) ãªã©ã®ç‰¹åˆ¥ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã‚’å‡¦ç†ã—ã¾ã™ã€‚æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® :mod:`zipimport` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ˆã£ã¦ã‚µãƒãƒ¼ãƒˆã•ã‚Œã‚‹å ´åˆã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯ (å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªä»¥å¤–ã®) ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã® zip "
"ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®ãƒ­ãƒ¼ãƒ‰ã‚‚æ‰±ã„ã¾ã™ã€‚"

#: ../../reference/import.rst:728
msgid ""
"Path entries need not be limited to file system locations.  They can refer "
"to URLs, database queries, or any other location that can be specified as a "
"string."
msgstr ""
"ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®å ´æ‰€ã«é™å®šã•ã‚Œã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚URL ã‚„ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªã‚„ãã®ä»–æ–‡å­—åˆ—ã§æŒ‡å®šã§ãã‚‹å ´æ‰€ã‚’å‚ç…§ã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚"

#: ../../reference/import.rst:732
msgid ""
"The path based finder provides additional hooks and protocols so that you "
"can extend and customize the types of searchable path entries.  For example,"
" if you wanted to support path entries as network URLs, you could write a "
"hook that implements HTTP semantics to find modules on the web.  This hook "
"(a callable) would return a :term:`path entry finder` supporting the "
"protocol described below, which was then used to get a loader for the module"
" from the web."
msgstr ""
"ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã«ã¯ãƒ•ãƒƒã‚¯ã‚„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ãŒã§ãã€ãã‚Œã«ã‚ˆã£ã¦æ¤œç´¢å¯èƒ½ãªãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªã®ç¨®é¡ã‚’æ‹¡å¼µã—ã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸Šã®"
" URL ã‚’ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªã¨ã—ã¦ã‚µãƒãƒ¼ãƒˆã—ãŸã„å ´åˆã€ web ä¸Šã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã« HTTP "
"ã®å–ã‚Šæ‰±ã„æ–¹ã‚’å®Ÿè£…ã—ãŸãƒ•ãƒƒã‚¯ã‚’æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã® (å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹) ãƒ•ãƒƒã‚¯ã¯ã€ä¸‹ã§è§£èª¬ã™ã‚‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ "
":term:`ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path entry finder>` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯  web "
"ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ­ãƒ¼ãƒ€ãƒ¼ã‚’å–å¾—ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:740
msgid ""
"A word of warning: this section and the previous both use the term *finder*,"
" distinguishing between them by using the terms :term:`meta path finder` and"
" :term:`path entry finder`.  These two types of finders are very similar, "
"support similar protocols, and function in similar ways during the import "
"process, but it's important to keep in mind that they are subtly different. "
"In particular, meta path finders operate at the beginning of the import "
"process, as keyed off the :data:`sys.meta_path` traversal."
msgstr ""
"è­¦å‘Šã®è¨€è‘‰: ã“ã®ç¯€ã¨å‰ã®ç¯€ã®ä¸¡æ–¹ã§ *ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼* ã¨ã„ã†è¨€è‘‰ãŒã€ :term:`ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <meta path finder>` ã¨"
" :term:`ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path entry finder>` ã¨ã„ã†ç”¨èªã§åŒºåˆ¥ã•ã‚Œã¦ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ 2 "
"ç¨®é¡ã®ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯éå¸¸ã«ä¼¼ã¦ãŠã‚Šã€ä¼¼ãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã§åŒã˜ã‚ˆã†ã«æ©Ÿèƒ½ã—ã¾ã™ãŒã€å¾®å¦™ã«ç•°ãªã£ã¦ã„ã‚‹ã®ã‚’å¿ƒã«ç•™ã‚ã¦ãŠãã®ã¯é‡è¦ã§ã™ã€‚ç‰¹ã«ã€ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã®é–‹å§‹æ™‚ã€"
" :data:`sys.meta_path` ã®èµ°æŸ»ãŒå‹•ãã¨ãã«å‹•ä½œã—ã¾ã™ã€‚"

#: ../../reference/import.rst:748
msgid ""
"By contrast, path entry finders are in a sense an implementation detail of "
"the path based finder, and in fact, if the path based finder were to be "
"removed from :data:`sys.meta_path`, none of the path entry finder semantics "
"would be invoked."
msgstr ""
"ãã‚Œã¨ã¯å¯¾ç…§çš„ã«ã€ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯ã‚ã‚‹æ„å‘³ã§ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã®å®Ÿè£…è©³ç´°ã§ã‚ã‚Šã€å®Ÿéš› :data:`sys.meta_path` "
"ã‹ã‚‰ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒå–ã‚Šé™¤ã‹ã‚ŒãŸå ´åˆã€ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã®å®Ÿè£…ã¯ä½•ã‚‚å®Ÿè¡Œã•ã‚Œãªã„ã§ã—ã‚‡ã†ã€‚"

#: ../../reference/import.rst:755
msgid "Path entry finders"
msgstr "ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼"

#: ../../reference/import.rst:763
msgid ""
"The :term:`path based finder` is responsible for finding and loading Python "
"modules and packages whose location is specified with a string :term:`path "
"entry`.  Most path entries name locations in the file system, but they need "
"not be limited to this."
msgstr ""
":term:`ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path based finder>` ã«ã¯ã€æ–‡å­—åˆ— :term:`ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒª <path entry>` "
"ã§æŒ‡å®šã•ã‚ŒãŸå ´æ‰€ã® Python ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ Python "
"ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è¦‹ã¤ã‘ã€ãƒ­ãƒ¼ãƒ‰ã™ã‚‹è²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚ã»ã¨ã‚“ã©ã®ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®å ´æ‰€ã‚’æŒ‡å®šã—ã¦ã„ã¾ã™ãŒã€ãã“ã«åˆ¶é™ã•ã‚Œã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/import.rst:768
msgid ""
"As a meta path finder, the :term:`path based finder` implements the "
":meth:`~importlib.abc.MetaPathFinder.find_spec` protocol previously "
"described, however it exposes additional hooks that can be used to customize"
" how modules are found and loaded from the :term:`import path`."
msgstr ""
"ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¨ã—ã¦ã€ :term:`ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path based finder>` ã«ã¯å‰ã«è§£èª¬ã—ãŸ "
":meth:`~importlib.abc.MetaPathFinder.find_spec` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ãŒã€ã“ã‚Œã«åŠ ãˆã¦ "
":term:`ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‘ã‚¹ <import path>` ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ã¤ã‘ã€ãƒ­ãƒ¼ãƒ‰ã™ã‚‹æ–¹æ³•ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ãŸã‚ã«ä½¿ãˆã‚‹ãƒ•ãƒƒã‚¯ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/import.rst:773
msgid ""
"Three variables are used by the :term:`path based finder`, :data:`sys.path`,"
" :data:`sys.path_hooks` and :data:`sys.path_importer_cache`.  The "
"``__path__`` attributes on package objects are also used.  These provide "
"additional ways that the import machinery can be customized."
msgstr ""
":term:`ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path based finder>` ã¯ :data:`sys.path` ã€ "
":data:`sys.path_hooks` ã€ :data:`sys.path_importer_cache` ã¨ã„ã† 3 "
"ã¤ã®å¤‰æ•°ã‚’ä½¿ã„ã¾ã™ã€‚ã•ã‚‰ã«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® ``__path__`` "
"å±æ€§ã‚‚ä½¿ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã«ã‚ˆã£ã¦ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹æ–¹æ³•ãŒæä¾›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:778
msgid ""
":data:`sys.path` contains a list of strings providing search locations for "
"modules and packages.  It is initialized from the :data:`PYTHONPATH` "
"environment variable and various other installation- and implementation-"
"specific defaults.  Entries in :data:`sys.path` can name directories on the "
"file system, zip files, and potentially other \"locations\" (see the "
":mod:`site` module) that should be searched for modules, such as URLs, or "
"database queries.  Only strings and bytes should be present on "
":data:`sys.path`; all other data types are ignored.  The encoding of bytes "
"entries is determined by the individual :term:`path entry finders <path "
"entry finder>`."
msgstr ""
":data:`sys.path` ã«ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’æ¢ã™å ´æ‰€æ–‡å­—åˆ—ã®ä¸€è¦§ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ :data:`PYTHONPATH` "
"ç’°å¢ƒå¤‰æ•°ã¨ãã®ä»–æ§˜ã€…ãªã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•ã‚„å®Ÿè£…ã«ä¾å­˜ã™ã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚ :data:`sys.path` "
"å†…ã®è¦ç´ ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚„ zip ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãã®ä»–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¢ã™ã¹ã \"å ´æ‰€\" ã¨ãªã‚Šã†ã‚‹ã‚‚ã® (:mod:`site` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§) ã‚’æŒ‡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚æ–‡å­—åˆ—ãŠã‚ˆã³ãƒã‚¤ãƒˆåˆ—ã®ã¿ã‚’ :data:`sys.path` ã«å…¥ã‚Œã‚‹ã¹ãã§ã™; "
"ä»–ã®ãƒ‡ãƒ¼ã‚¿å‹ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ãƒã‚¤ãƒˆåˆ—ã®è¦ç´ ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ã€å„ :term:`ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path entry finder>` "
"ã«ã‚ˆã£ã¦åˆ¤åˆ¥ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:789
msgid ""
"The :term:`path based finder` is a :term:`meta path finder`, so the import "
"machinery begins the :term:`import path` search by calling the path based "
"finder's :meth:`~importlib.machinery.PathFinder.find_spec` method as "
"described previously.  When the ``path`` argument to "
":meth:`~importlib.machinery.PathFinder.find_spec` is given, it will be a "
"list of string paths to traverse - typically a package's ``__path__`` "
"attribute for an import within that package.  If the ``path`` argument is "
"``None``, this indicates a top level import and :data:`sys.path` is used."
msgstr ""
":term:`ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path based finder>` ã¯ :term:`ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <meta path "
"finder>` ãªã®ã§ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ã€å‰ã§è§£èª¬ã—ãŸãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã® "
":meth:`~importlib.machinery.PathFinder.find_spec`  ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ "
":term:`ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‘ã‚¹ <import path>` ã®æ¤œç´¢ã‚’å§‹ã‚ã¾ã™ã€‚ ``path`` å¼•æ•°ãŒ "
":meth:`~importlib.machinery.PathFinder.find_spec` ã«æ¸¡ã•ã‚ŒãŸã¨ãã¯ã€ãã‚Œã¯èµ°æŸ»ã™ã‚‹ãƒ‘ã‚¹æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆ "
"- å…¸å‹çš„ã«ã¯ãã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ä¸­ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® ``__path__`` å±æ€§ã«ãªã‚Šã¾ã™ã€‚ ``path`` å¼•æ•°ãŒ ``None``"
" ã ã£ãŸå ´åˆã€ãã‚Œã¯æœ€ä¸Šä½ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¦ã€ :data:`sys.path` ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:798
msgid ""
"The path based finder iterates over every entry in the search path, and for "
"each of these, looks for an appropriate :term:`path entry finder` "
"(:class:`~importlib.abc.PathEntryFinder`) for the path entry.  Because this "
"can be an expensive operation (e.g. there may be `stat()` call overheads for"
" this search), the path based finder maintains a cache mapping path entries "
"to path entry finders.  This cache is maintained in "
":data:`sys.path_importer_cache` (despite the name, this cache actually "
"stores finder objects rather than being limited to :term:`importer` "
"objects). In this way, the expensive search for a particular :term:`path "
"entry` location's :term:`path entry finder` need only be done once.  User "
"code is free to remove cache entries from :data:`sys.path_importer_cache` "
"forcing the path based finder to perform the path entry search again "
"[#fnpic]_."
msgstr ""
"ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯æ¤œç´¢ãƒ‘ã‚¹ã®ã™ã¹ã¦ã®è¦ç´ ã«ã¤ã„ã¦åå¾©å‡¦ç†ã‚’ã—ã€ãã‚Œãã‚Œã®ãƒ‘ã‚¹ã«å¯¾ã—ã¦é©åˆ‡ãª :term:`ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path"
" entry finder>` (:class:`~importlib.abc.PathEntryFinder`) ã‚’æ¢ã—ã¾ã™ã€‚ã“ã‚Œã¯æ™‚é–“ã®ã‹ã‹ã‚‹å‡¦ç† "
"(ä¾‹ãˆã°ã€ã“ã®æ¤œç´¢ã®ãŸã‚ã® `stat()` å‘¼ã³å‡ºã—ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰) "
"ã«ãªã‚Šå¾—ã‚‹ã®ã§ã€ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯ãƒ‘ã‚¹è¦ç´ ã‹ã‚‰ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¸ã®å¯¾å¿œä»˜ã‘ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¨ã—ã¦æŒã£ã¦ãŠãã¾ã™ã€‚ã“ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¯ "
":data:`sys.path_importer_cache` ã«æŒã£ã¦ã„ã¾ã™ (åå‰ã«åã—ã¦ã€ã“ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¯å®Ÿéš›ã«ã¯ :term:`ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ "
"<importer>` ã«ã¯åˆ¶é™ã•ã‚Œã¦ãŠã‚‰ãšã€ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿æŒã—ã¾ã™) ã€‚ã“ã®ã‚ˆã†ã«ã—ã¦ã€æ™‚é–“ã®ã‹ã‹ã‚‹ç‰¹å®šã® :term:`ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒª "
"<path entry>` ã®å ´æ‰€ã®ãŸã‚ã® :term:`ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path entry finder>` "
"ã®æ¤œç´¢ã‚’ä¸€åº¦ã ã‘æ¤œç´¢ã™ã‚Œã°è‰¯ããªã‚Šã¾ã™ã€‚ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã«ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªã®æ¤œç´¢ã‚’å†åº¦è¡Œã‚ã›ã‚‹ãŸã‚ã«ã€ãƒ¦ãƒ¼ã‚¶ã‚³ãƒ¼ãƒ‰ã§ã¯è‡ªç”±ã« "
":data:`sys.path_importer_cache` ã‹ã‚‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å–ã‚Šé™¤ã„ã¦æ§‹ã„ã¾ã›ã‚“  [#fnpic]_ ã€‚"

#: ../../reference/import.rst:811
msgid ""
"If the path entry is not present in the cache, the path based finder "
"iterates over every callable in :data:`sys.path_hooks`.  Each of the "
":term:`path entry hooks <path entry hook>` in this list is called with a "
"single argument, the path entry to be searched.  This callable may either "
"return a :term:`path entry finder` that can handle the path entry, or it may"
" raise :exc:`ImportError`.  An :exc:`ImportError` is used by the path based "
"finder to signal that the hook cannot find a :term:`path entry finder` for "
"that :term:`path entry`.  The exception is ignored and :term:`import path` "
"iteration continues.  The hook should expect either a string or bytes "
"object; the encoding of bytes objects is up to the hook (e.g. it may be a "
"file system encoding, UTF-8, or something else), and if the hook cannot "
"decode the argument, it should raise :exc:`ImportError`."
msgstr ""
"path entry ãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ä¸­ã«ç„¡ã‹ã£ãŸå ´åˆã€ path based finder ã¯ :data:`sys.path_hooks` ã®ä¸­ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å…¨ã¦è¾¿ã‚Šã¾ã™ã€‚\n"
"ã“ã®ãƒªã‚¹ãƒˆã®ãã‚Œãã‚Œã® :term:`path entry ãƒ•ãƒƒã‚¯ <path entry hook>` ã¯ã€æ¤œç´¢ã™ã‚‹ path entry ã¨ã„ã†å¼•æ•° 1 ã¤ã‚’æ¸¡ã—ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
"ãã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ path entry ã‚’æ‰±ãˆã‚‹ :term:`path entry finder` ã‚’è¿”ã™ã‹ã€  :exc:`ImportError` ã‚’é€å‡ºã—ã¾ã™ã€‚\n"
":exc:`ImportError` ã¯ã€ãƒ•ãƒƒã‚¯ãŒ :term:`path entry` ã®ãŸã‚ã® :term:`path entry finder` ã‚’æ¢ã›ãªã„ã“ã¨ã‚’å ±ã›ã‚‹ãŸã‚ã« path based finder ãŒä½¿ã„ã¾ã™ã€‚\n"
"ã“ã®ä¾‹å¤–ã¯å‡¦ç†ã•ã‚Œãšã€ :term:`import path` ã‚’è¾¿ã£ã¦ã„ãå‡¦ç†ãŒç¶šã‘ã‚‰ã‚Œã¾ã™ã€‚\n"
"ãƒ•ãƒƒã‚¯ã¯å¼•æ•°ã¨ã—ã¦æ–‡å­—åˆ—ã¾ãŸã¯ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æœŸå¾…ã—ã¾ã™;\n"
"ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ãƒ•ãƒƒã‚¯ã«ä»»ã•ã‚Œã¦ã„ã¦ (ä¾‹ãˆã°ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã® UTF-8 ã‚„ãã‚Œä»¥å¤–ãªã©ã§ã™) ã€ãƒ•ãƒƒã‚¯ãŒå¼•æ•°ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã§ããªã‹ã£ãŸå ´åˆã¯ :exc:`ImportError` ã‚’é€å‡ºã™ã¹ãã§ã™ã€‚"

#: ../../reference/import.rst:825
msgid ""
"If :data:`sys.path_hooks` iteration ends with no :term:`path entry finder` "
"being returned, then the path based finder's "
":meth:`~importlib.machinery.PathFinder.find_spec` method will store ``None``"
" in :data:`sys.path_importer_cache` (to indicate that there is no finder for"
" this path entry) and return ``None``, indicating that this :term:`meta path"
" finder` could not find the module."
msgstr ""
":data:`sys.path_hooks` ã‚’è¾¿ã‚‹å‡¦ç†ãŒ :term:`ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path entry finder>` "
"ã‚’ä½•ã‚‚è¿”ã•ãšã«çµ‚ã‚ã£ãŸå ´åˆã€ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã® "
":meth:`~importlib.machinery.PathFinder.find_spec` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ "
":data:`sys.path_importer_cache` ã« (ã“ã®ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªã«å¯¾ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒå­˜åœ¨ã—ãªã„ã“ã¨ã‚’ç¤ºã™ãŸã‚ã«) "
"``None`` ã‚’ä¿å­˜ã—ã€ :term:`ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <meta path finder>` "
"ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã“ã¨ã‚’ä¼ãˆã‚‹ãŸã‚ã« ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/import.rst:832
msgid ""
"If a :term:`path entry finder` *is* returned by one of the :term:`path entry"
" hook` callables on :data:`sys.path_hooks`, then the following protocol is "
"used to ask the finder for a module spec, which is then used when loading "
"the module."
msgstr ""
":data:`sys.path_hooks` ä¸Šã® :term:`ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ•ãƒƒã‚¯ <path entry hook>` "
"å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æˆ»ã‚Šå€¤ã®ã„ãšã‚Œã‹ãŒ :term:`ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path entry finder>` *ã§ã‚ã£ãŸ* "
"å ´åˆã€å¾Œã§å‡ºã¦ãã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ã‚’æ¢ã™ãŸã‚ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒä½¿ã‚ã‚Œã€ãã‚ŒãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:837
msgid ""
"The current working directory -- denoted by an empty string -- is handled "
"slightly differently from other entries on :data:`sys.path`. First, if the "
"current working directory is found to not exist, no value is stored in "
":data:`sys.path_importer_cache`. Second, the value for the current working "
"directory is looked up fresh for each module lookup. Third, the path used "
"for :data:`sys.path_importer_cache` and returned by "
":meth:`importlib.machinery.PathFinder.find_spec` will be the actual current "
"working directory and not the empty string."
msgstr ""
"ï¼ˆç©ºã®æ–‡å­—åˆ—ã«ã‚ˆã£ã¦è¡¨ã•ã‚Œã‚‹ï¼‰ç¾åœ¨ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¯ã€ :data:`sys.path` "
"ã®ä»–ã®ã‚¨ãƒ³ãƒˆãƒªã¨ã¯å¤šå°‘ç•°ãªã‚‹æ–¹æ³•ã§å‡¦ç†ã•ã‚Œã¾ã™ã€‚ã¾ãšã€ç¾åœ¨ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„ã“ã¨ãŒåˆ¤æ˜ã—ãŸå ´åˆã€ "
":data:`sys.path_importer_cache` "
"ã«ã¯ä½•ã‚‚è¿½åŠ ã•ã‚Œã¾ã›ã‚“ã€‚æ¬¡ã«ã€ç¾åœ¨ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«å¯¾ã™ã‚‹å€¤ã¯å€‹ã€…ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ«ãƒƒã‚¯ã‚¢ãƒƒãƒ—ã§æ¯å›æ–°ãŸã«æ¤œç´¢ã•ã‚Œã¾ã™ã€‚ 3ç•ªç›®ã«ã€ "
":data:`sys.path_importer_cache` ã«ä½¿ã‚ã‚Œã€ "
":meth:`importlib.machinery.PathFinder.find_spec` "
"ãŒè¿”ã™ãƒ‘ã‚¹ã¯ã€å®Ÿéš›ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã‚ã£ã¦ç©ºã®æ–‡å­—åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/import.rst:847
msgid "Path entry finder protocol"
msgstr "ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãƒ»ãƒ—ãƒ­ãƒˆã‚³ãƒ«"

#: ../../reference/import.rst:849
msgid ""
"In order to support imports of modules and initialized packages and also to "
"contribute portions to namespace packages, path entry finders must implement"
" the :meth:`~importlib.abc.PathEntryFinder.find_spec` method."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨åˆæœŸåŒ–ã•ã‚ŒãŸãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã€ãŠã‚ˆã³åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ãƒãƒ¼ã‚·ãƒ§ãƒ³ã¨ã—ã¦æä¾›ã™ã‚‹ãŸã‚ã«ã€ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯"
" :meth:`~importlib.abc.PathEntryFinder.find_spec`  ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../reference/import.rst:853
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` takes two argument, the "
"fully qualified name of the module being imported, and the (optional) target"
" module.  ``find_spec()`` returns a fully populated spec for the module. "
"This spec will always have \"loader\" set (with one exception)."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` ã¯ 2 "
"ã¤ã®å¼•æ•°ã‚’å–ã‚Šã¾ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å®Œå…¨ä¿®é£¾åã¨ã€ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®) å¯¾è±¡ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ã€‚ `find_spec()` "
"ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å¯¾å¿œã™ã‚‹å®Œå…¨ã«åˆæœŸåŒ– (populated) ã•ã‚ŒãŸä»•æ§˜ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ä»•æ§˜ã¯ (1ã¤ã®ä¾‹å¤–ã‚’é™¤ã„ã¦) å¸¸ã« \"loader\" "
"ã‚»ãƒƒãƒˆã‚’æŒã£ã¦ã„ã¾ã™ã€‚"

#: ../../reference/import.rst:858
msgid ""
"To indicate to the import machinery that the spec represents a namespace "
":term:`portion`. the path entry finder sets \"loader\" on the spec to "
"``None`` and \"submodule_search_locations\" to a list containing the "
"portion."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ãŒåå‰ç©ºé–“ :term:`ãƒãƒ¼ã‚·ãƒ§ãƒ³ <portion>` "
"ã‚’è¡¨ã—ã¦ã„ã‚‹ã“ã¨ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã«ç¤ºã™ãŸã‚ã«ã€ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ã® \"loader\" ã‚’ ``None`` ã«ã€ "
"\"submodule_search_locations\" ã‚’åå‰ç©ºé–“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’å«ã‚€ãƒªã‚¹ãƒˆã«è¨­å®šã—ã¾ã™ã€‚"

#: ../../reference/import.rst:863
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` replaced "
":meth:`~importlib.abc.PathEntryFinder.find_loader` and "
":meth:`~importlib.abc.PathEntryFinder.find_module`, both of which are now "
"deprecated, but will be used if ``find_spec()`` is not defined."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` ã¯ "
":meth:`~importlib.abc.PathEntryFinder.find_loader` ã¨ "
":meth:`~importlib.abc.PathEntryFinder.find_module` ã‚’ç½®ãæ›ãˆã¾ã—ãŸã€‚ä¸¡è€…ã¯ deprecated "
"ã§ã™ãŒã€ `find_spec()` ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:869
msgid ""
"Older path entry finders may implement one of these two deprecated methods "
"instead of ``find_spec()``.  The methods are still respected for the sake of"
" backward compatibility.  However, if ``find_spec()`` is implemented on the "
"path entry finder, the legacy methods are ignored."
msgstr ""
"å¤ã„ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã®ä¸­ã«ã¯ã€ ``find_spec()`` ã®ä»£ã‚ã‚Šã«ã“ã‚Œã‚‰ 2 ã¤ã® deperecated "
"ãªãƒ¡ã‚½ãƒƒãƒ‰ã®ã†ã¡ã®ã„ãšã‚Œã‹ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‚‚ã®ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã«ã¾ã è€ƒæ…®ã•ã‚Œã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã«"
" ``find_spec()`` ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚Œã°ã€å¤ã„ãƒ¡ã‚½ãƒƒãƒ‰ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:874
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` takes one argument, the "
"fully qualified name of the module being imported.  ``find_loader()`` "
"returns a 2-tuple where the first item is the loader and the second item is "
"a namespace :term:`portion`.  When the first item (i.e. the loader) is "
"``None``, this means that while the path entry finder does not have a loader"
" for the named module, it knows that the path entry contributes to a "
"namespace portion for the named module.  This will almost always be the case"
" where Python is asked to import a namespace package that has no physical "
"presence on the file system.  When a path entry finder returns ``None`` for "
"the loader, the second item of the 2-tuple return value must be a sequence, "
"although it can be empty."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` "
"ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å®Œå…¨ä¿®é£¾åã‚’å¼•æ•°ã«å–ã‚Šã¾ã™ã€‚ ``find_loader()`` ã¯ã€ç¬¬ 1 è¦ç´ ãŒãƒ­ãƒ¼ãƒ€ã§ç¬¬  2è¦ç´ ãŒåå‰ç©ºé–“ "
":term:`ãƒãƒ¼ã‚·ãƒ§ãƒ³ <portion>` ã§ã‚ã‚‹ 2 è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ç¬¬ 1 è¦ç´  (ã¤ã¾ã‚Šãƒ­ãƒ¼ãƒ€ãƒ¼) ãŒ ``None`` "
"ã®å ´åˆã€ãã®æ„å‘³ã¯ã€ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼è‡ªèº«ã¯æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãŸã‚ã®ãƒ­ãƒ¼ãƒ€ãƒ¼ã‚’æŒã£ã¦ã„ãªã„ã‚‚ã®ã®ã€ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã«é–¢ä¿‚ã—ã¦ã„ã‚‹"
" (contribute) "
"ã®ã‚’ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒçŸ¥ã£ã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ã“ã‚Œã¯ã€ã»ã¨ã‚“ã©å¸¸ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã«ç‰©ç†çš„ãªå®Ÿä½“ã®ãªã„åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã‚ˆã†ã¨ã—ãŸå ´åˆã§ã™ã€‚ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒãƒ­ãƒ¼ãƒ€ãƒ¼ã¨ã—ã¦"
" ``None`` ã‚’è¿”ã™å ´åˆã«ã¯ã€ 2 è¦ç´ ã‚¿ãƒ—ãƒ«ã§ã‚ã‚‹æˆ»ã‚Šå€¤ã®ç¬¬ 2 è¦ç´ ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãŸã ã—ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ç©ºã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../reference/import.rst:886
msgid ""
"If ``find_loader()`` returns a non-``None`` loader value, the portion is "
"ignored and the loader is returned from the path based finder, terminating "
"the search through the path entries."
msgstr ""
"``find_loader()`` ãŒ ``None`` "
"ã§ãªã„ãƒ­ãƒ¼ãƒ€ãƒ¼å€¤ã‚’è¿”ã—ãŸå ´åˆã€ãƒãƒ¼ã‚·ãƒ§ãƒ³ã¯ç„¡è¦–ã•ã‚Œã€ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã‹ã‚‰ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒè¿”ã•ã‚Œã€ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªä¸Šã®æ¤œç´¢ãŒçµ‚äº†ã—ã¾ã™ã€‚"

#: ../../reference/import.rst:890
msgid ""
"For backwards compatibility with other implementations of the import "
"protocol, many path entry finders also support the same, traditional "
"``find_module()`` method that meta path finders support. However path entry "
"finder ``find_module()`` methods are never called with a ``path`` argument "
"(they are expected to record the appropriate path information from the "
"initial call to the path hook)."
msgstr ""
"ä»–ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã®å®Ÿè£…ã«å¯¾ã™ã‚‹å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã«ã€å¤šãã®ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯ã€ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹ã®ã¨åŒã˜ä¼çµ±çš„ãª "
"``find_module()``  ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã® ``find_module()``  "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æ±ºã—ã¦ ``path`` å¼•æ•°ã§ã¯å‘¼ã³å‡ºã•ã‚Œã¾ã›ã‚“ "
"(ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ‘ã‚¹ãƒ•ãƒƒã‚¯ã®æœ€åˆã®å‘¼ã³å‡ºã—ã‹ã‚‰é©åˆ‡ãªãƒ‘ã‚¹æƒ…å ±ã‚’è¨˜éŒ²ã™ã‚‹å‹•ä½œãŒæœŸå¾…ã•ã‚Œã¦ã„ã¾ã™)ã€‚"

#: ../../reference/import.rst:897
msgid ""
"The ``find_module()`` method on path entry finders is deprecated, as it does"
" not allow the path entry finder to contribute portions to namespace "
"packages.  If both ``find_loader()`` and ``find_module()`` exist on a path "
"entry finder, the import system will always call ``find_loader()`` in "
"preference to ``find_module()``."
msgstr ""
"ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã® ``find_module()`` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ deprecated "
"ã§ã™ã€‚ãªãœãªã‚‰ã€ãã®æ–¹æ³•ã§ã¯ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒåå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å¯¾ã—ã¦ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’æä¾›ã™ã‚‹ã“ã¨ãŒã§ããªã„ã‹ã‚‰ã§ã™ã€‚ã‚‚ã— "
"``find_loader()`` ã¨ ``find_module()`` ã®ä¸¡æ–¹ãŒãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã«å­˜åœ¨ã—ãŸã‚‰ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã¯å¸¸ã« "
"``find_module()`` ã‚ˆã‚Šã‚‚ ``find_loader()`` ã‚’å„ªå…ˆã—ã¦å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../reference/import.rst:905
msgid "Replacing the standard import system"
msgstr "æ¨™æº–ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã‚’ç½®ãæ›ãˆã‚‹"

#: ../../reference/import.rst:907
msgid ""
"The most reliable mechanism for replacing the entire import system is to "
"delete the default contents of :data:`sys.meta_path`, replacing them "
"entirely with a custom meta path hook."
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã‚’ç½®ãæ›ãˆã‚‹ãŸã‚ã®æœ€ã‚‚ä¿¡é ¼æ€§ã®ã‚ã‚‹ä»•çµ„ã¿ã¯ã€ :data:`sys.meta_path` "
"ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å†…å®¹ã‚’å‰Šé™¤ã—ã€å…¨éƒ¨ã‚’ã‚«ã‚¹ã‚¿ãƒ ã®ãƒ¡ã‚¿ãƒ‘ã‚¹ãƒ•ãƒƒã‚¯ã§ç½®ãæ›ãˆã‚‹ã‚‚ã®ã§ã™ã€‚"

#: ../../reference/import.rst:911
msgid ""
"If it is acceptable to only alter the behaviour of import statements without"
" affecting other APIs that access the import system, then replacing the "
"builtin :func:`__import__` function may be sufficient. This technique may "
"also be employed at the module level to only alter the behaviour of import "
"statements within that module."
msgstr ""
"ã‚‚ã—ã€ import æ–‡ã®å‹•ä½œã ã‘ã‚’å¤‰æ›´ã—ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ä»–ã® API ã«ã¯å½±éŸ¿ã‚’ä¸ãˆãªãã¦ã‚‚ã‚ˆã‘ã‚Œã°ã€çµ„ã¿è¾¼ã¿ã® "
":func:`__import__` é–¢æ•°ã‚’ç½®ãæ›ãˆã‚‹ã ã‘ã§ååˆ†ã§ã™ã€‚ã“ã®æ‰‹æ³•ã¯ã€ã‚ã‚‹ 1 ã¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã ã‘ã§ import "
"æ–‡ã®å‹•ä½œã‚’å¤‰æ›´ã™ã‚‹ã®ã«ã‚‚ç”¨ã„ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:917
msgid ""
"To selectively prevent import of some modules from a hook early on the meta "
"path (rather than disabling the standard import system entirely), it is "
"sufficient to raise :exc:`ModuleNotFoundError` directly from "
":meth:`~importlib.abc.MetaPathFinder.find_spec` instead of returning "
"``None``. The latter indicates that the meta path search should continue, "
"while raising an exception terminates it immediately."
msgstr ""
"(æ¨™æº–ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã‚’åœæ­¢ã™ã‚‹ã®ã§ã¯ãªã) ã™ã§ã«ãƒ¡ã‚¿ãƒ‘ã‚¹ã«ã„ã‚‹ãƒ•ãƒƒã‚¯ã‹ã‚‰ã‚ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’é¸æŠçš„ã«é˜²ããŸã‚ã«ã¯ã€ "
":meth:`~importlib.abc.MetaPathFinder.find_spec` ã‹ã‚‰ ``None`` ã‚’è¿”ã™ä»£ã‚ã‚Šã«ã€ç›´æ¥ "
":exc:`ModuleNotFoundError` ã‚’é€å‡ºã™ã‚‹ã ã‘ã§ååˆ†ã§ã™ã€‚ ``None`` "
"ã‚’è¿”ã™ã®ã¯ãƒ¡ã‚¿ãƒ‘ã‚¹ã®èµ°æŸ»ã‚’ç¶šã‘ã‚‹ã¹ãã§ã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ãŒã€ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ã¨ã™ãã«èµ°æŸ»ã‚’æ‰“ã¡åˆ‡ã‚Šã¾ã™ã€‚"

#: ../../reference/import.rst:926
msgid "Special considerations for __main__"
msgstr "__main__ ã«å¯¾ã™ã‚‹ç‰¹åˆ¥ãªè€ƒæ…®"

#: ../../reference/import.rst:928
msgid ""
"The :mod:`__main__` module is a special case relative to Python's import "
"system.  As noted :ref:`elsewhere <programs>`, the ``__main__`` module is "
"directly initialized at interpreter startup, much like :mod:`sys` and "
":mod:`builtins`.  However, unlike those two, it doesn't strictly qualify as "
"a built-in module.  This is because the manner in which ``__main__`` is "
"initialized depends on the flags and other options with which the "
"interpreter is invoked."
msgstr ""
":mod:`__main__` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ Python ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã«é–¢é€£ã™ã‚‹ç‰¹åˆ¥ãªã‚±ãƒ¼ã‚¹ã§ã™ã€‚ :ref:`ä»–ã®å ´æ‰€ "
"<programs>` ã§è¨€åŠã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã€ ``__main__`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :mod:`sys` ã‚„ :mod:`builtins` "
"ãªã©ã¨åŒæ§˜ã«ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãƒ¼ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—ã§ç›´æ¥åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€å‰è€… 2 ã¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨é•ã£ã¦ã€ ``__main__`` "
"ã¯å³å¯†ã«ã¯ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã—ã¦ã®è³‡æ ¼ã‚’æŒã£ã¦ã„ã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€ ``__main__`` "
"ãŒåˆæœŸåŒ–ã•ã‚Œã‚‹æ–¹æ³•ãŒã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒèµ·å‹•ã•ã‚Œã‚‹ã¨ãã®ãƒ•ãƒ©ã‚°ã‚„ãã®ä»–ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«ä¾å­˜ã™ã‚‹ãŸã‚ã§ã™ã€‚"

#: ../../reference/import.rst:939
msgid "__main__.__spec__"
msgstr "__main__.__spec__"

#: ../../reference/import.rst:941
msgid ""
"Depending on how :mod:`__main__` is initialized, ``__main__.__spec__`` gets "
"set appropriately or to ``None``."
msgstr ""
":mod:`__main__` ãŒã©ã®ã‚ˆã†ã«åˆæœŸåŒ–ã•ã‚Œã‚‹ã‹ã«ä¾å­˜ã—ã¦ã€ ``__main__.__spec__`` ã¯é©åˆ‡ã«è¨­å®šã•ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Œã° "
"``None`` ã«ãªã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/import.rst:944
msgid ""
"When Python is started with the :option:`-m` option, ``__spec__`` is set to "
"the module spec of the corresponding module or package. ``__spec__`` is also"
" populated when the ``__main__`` module is loaded as part of executing a "
"directory, zipfile or other :data:`sys.path` entry."
msgstr ""
"Python ãŒ :option:`-m` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ä»˜ã‘ã¦å®Ÿè¡Œã•ã‚ŒãŸå ´åˆã«ã¯ã€ ``__spec__`` "
"ã¯å¯¾å¿œã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¾ãŸã¯ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ã«è¨­å®šã•ã‚Œã¾ã™ã€‚ã¾ãŸã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚„ zip ãƒ•ã‚¡ã‚¤ãƒ«ã€ã¾ãŸã¯ä»–ã® :data:`sys.path`"
" ã‚¨ãƒ³ãƒˆãƒªã‚’å®Ÿè¡Œã™ã‚‹å‡¦ç†ã®ä¸€éƒ¨ã¨ã—ã¦ ``__main__`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹å ´åˆã«ã‚‚ ``__spec__`` ãŒç”Ÿæˆ (populate)"
" ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/import.rst:949
msgid ""
"In :ref:`the remaining cases <using-on-interface-options>` "
"``__main__.__spec__`` is set to ``None``, as the code used to populate the "
":mod:`__main__` does not correspond directly with an importable module:"
msgstr ""
":ref:`ãã‚Œä»¥å¤–ã®ã‚±ãƒ¼ã‚¹ <using-on-interface-options>` ã§ã¯ã€ ``__main__.__spec__`` ã¯ "
"``None`` ã«è¨­å®šã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ :mod:`__main__` ã‚’ç”Ÿæˆ (populate) "
"ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚ŒãŸã‚³ãƒ¼ãƒ‰ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆå¯èƒ½ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ç›´æ¥ä¸€è‡´ã—ã¦ã„ãªã„ãŸã‚ã§ã™:"

#: ../../reference/import.rst:953
msgid "interactive prompt"
msgstr "å¯¾è©±ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ"

#: ../../reference/import.rst:954
msgid ":option:`-c` option"
msgstr ""

#: ../../reference/import.rst:955
msgid "running from stdin"
msgstr "stdin ã‹ã‚‰èµ·å‹•ã•ã‚ŒãŸå ´åˆ"

#: ../../reference/import.rst:956
msgid "running directly from a source or bytecode file"
msgstr "ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç›´æ¥èµ·å‹•ã•ã‚ŒãŸå ´åˆ"

#: ../../reference/import.rst:958
msgid ""
"Note that ``__main__.__spec__`` is always ``None`` in the last case, *even "
"if* the file could technically be imported directly as a module instead. Use"
" the :option:`-m` switch if valid module metadata is desired in "
":mod:`__main__`."
msgstr ""
"æœ€å¾Œã®ã‚±ãƒ¼ã‚¹ã§ã¯ã€ãŸã¨ãˆæŠ€è¡“çš„ã«ã¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã—ã¦ç›´æ¥ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ããŸ *ã¨ã—ã¦ã‚‚* ``__main__.__spec__`` ã¯å¸¸ã« "
"``None`` ã«ãªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã‚‚ã— :mod:`__main__` ã«ãŠã„ã¦æœ‰åŠ¹ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦ãªã‚‰ "
":option:`-m` ã‚¹ã‚¤ãƒƒãƒã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../reference/import.rst:963
msgid ""
"Note also that even when ``__main__`` corresponds with an importable module "
"and ``__main__.__spec__`` is set accordingly, they're still considered "
"*distinct* modules. This is due to the fact that blocks guarded by ``if "
"__name__ == \"__main__\":`` checks only execute when the module is used to "
"populate the ``__main__`` namespace, and not during normal import."
msgstr ""
"``__main__`` ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆå¯èƒ½ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ä¸€è‡´ã—ã€ ``__main__.__spec__`` "
"ãŒãã‚Œã«å¿œã˜ã¦è¨­å®šã•ã‚Œã¦ã„ãŸã¨ã—ã¦ã‚‚ã€ãã‚Œã§ã‚‚ãªãŠã€ã“ã® 2 ã¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯åˆ¥ç‰©ã¨ã¿ãªã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã¯ã€ ``if "
"__name__ == \"__main__\":`` ãƒã‚§ãƒƒã‚¯ã«ã‚ˆã£ã¦ä¿è¨¼ã•ã‚Œã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã¯ã€ ``__main__`` åå‰ç©ºé–“ã‚’ç”Ÿæˆ "
"(populate) ã™ã‚‹ãŸã‚ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä½¿ç”¨ã•ã‚Œã‚‹æ™‚ã«ã ã‘å®Ÿè¡Œã•ã‚Œã€é€šå¸¸ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ™‚ã«ã¯å®Ÿè¡Œã•ã‚Œãªã„ã€ã¨ã„ã†äº‹å®Ÿã«èµ·å› ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/import.rst:971
msgid "Open issues"
msgstr "å–ã‚Šæ›ã‹ã‚Šä¸­ã®å•é¡Œ"

#: ../../reference/import.rst:973
msgid "XXX It would be really nice to have a diagram."
msgstr "XXX å›³ãŒã‚ã‚‹ã¨ã¨ã¦ã‚‚è‰¯ã„ã€‚"

#: ../../reference/import.rst:975
msgid ""
"XXX * (import_machinery.rst) how about a section devoted just to the "
"attributes of modules and packages, perhaps expanding upon or supplanting "
"the related entries in the data model reference page?"
msgstr ""
"XXX * (import_machinery.rst) ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å±æ€§ã®ã¿ã«ç´™é¢ã‚’å‰²ã„ãŸç¯€ã‚’è¨­ã‘ã‚‹ã®ã¯ä½•å¦‚ã§ã—ã‚‡ã†ã‹? "
"ã‚‚ã—ã‹ã—ãŸã‚‰ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ã«ã¤ã„ã¦ã®è¨€èªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã®ãƒšãƒ¼ã‚¸ã«ã‚ã‚‹é–¢ä¿‚ã™ã‚‹å†…å®¹ã‚’æ‹¡å¼µã—ãŸã‚Šã€ç½®ãæ›ãˆã‚‹ã‚ˆã†ãªã‚‚ã®ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/import.rst:979
msgid ""
"XXX runpy, pkgutil, et al in the library manual should all get \"See Also\" "
"links at the top pointing to the new import system section."
msgstr ""
"XXX ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã® runpy ã‚„ pkgutil ã®è§£èª¬ã®å…ˆé ­ã™ã¹ã¦ã«ã€\"ã“ã¡ã‚‰ã‚‚å‚ç…§ (See Also)\" "
"ã¨ã„ã†ã€ã“ã®æ–°ã—ã„ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®ç¯€ã¸ã®ãƒªãƒ³ã‚¯ã‚’ç½®ãã¹ãã€‚"

#: ../../reference/import.rst:982
msgid ""
"XXX Add more explanation regarding the different ways in which ``__main__`` "
"is initialized?"
msgstr "XXX ``__main__`` ãŒåˆæœŸåŒ–ã•ã‚Œã‚‹æ§˜ã€…ãªæ–¹æ³•ã«ã¤ã„ã¦ã‚ˆã‚Šå¤šãã®èª¬æ˜ã‚’è¿½åŠ ã™ã‚‹?"

#: ../../reference/import.rst:985
msgid ""
"XXX Add more info on ``__main__`` quirks/pitfalls (i.e. copy from "
":pep:`395`)."
msgstr "XXX ``__main__`` ã®ç‰¹ç•°æ€§/è½ã¨ã—ç©´ã«ã¤ã„ã¦ã‚ˆã‚Šå¤šãã®æƒ…å ±ã‚’è¿½åŠ ã™ã‚‹ (ã¤ã¾ã‚Š :pep:`395` ã‹ã‚‰ã‚³ãƒ”ãƒ¼ã™ã‚‹)"

#: ../../reference/import.rst:990
msgid "References"
msgstr "å‚è€ƒè³‡æ–™"

#: ../../reference/import.rst:992
msgid ""
"The import machinery has evolved considerably since Python's early days.  "
"The original `specification for packages "
"<https://www.python.org/doc/essays/packages/>`_ is still available to read, "
"although some details have changed since the writing of that document."
msgstr ""
"Python ã®åˆæœŸã®é ƒã‹ã‚‰ã™ã‚‹ã¨ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ç›®è¦šã¾ã—ã„ç™ºå±•ã‚’é‚ã’ã¾ã—ãŸã€‚\n"
"ä¸€éƒ¨ç´°ã‹ã„ã¨ã“ã‚ãŒãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒæ›¸ã‹ã‚ŒãŸã¨ãã‹ã‚‰å¤‰ã‚ã£ã¦ã¯ã„ã¾ã™ãŒã€æœ€åˆæœŸã® `ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ä»•æ§˜ <https://www.python.org/doc/essays/packages/>`_ ã¯ã¾ã èª­ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/import.rst:997
msgid ""
"The original specification for :data:`sys.meta_path` was :pep:`302`, with "
"subsequent extension in :pep:`420`."
msgstr ""
"ã‚ªãƒªã‚¸ãƒŠãƒ«ã® :data:`sys.meta_path` ã®ä»•æ§˜ã¯ :pep:`302` ã§ã€ãã®å¾Œç¶™ã¨ãªã‚‹æ‹¡å¼µãŒ :pep:`420` ã§ã™ã€‚"

#: ../../reference/import.rst:1000
msgid ""
":pep:`420` introduced :term:`namespace packages <namespace package>` for "
"Python 3.3.  :pep:`420` also introduced the :meth:`find_loader` protocol as "
"an alternative to :meth:`find_module`."
msgstr ""
":pep:`420` ã¯ Python 3.3 ã« :term:`åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ <namespace package>` ã‚’å°å…¥ã—ã¦ã„ã¾ã™ã€‚ "
":pep:`420` ã¯ã¾ãŸ :meth:`find_module` ã«ä»£ã‚ã‚‹ã‚‚ã®ã¨ã—ã¦ :meth:`find_loader` "
"ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å°å…¥ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/import.rst:1004
msgid ""
":pep:`366` describes the addition of the ``__package__`` attribute for "
"explicit relative imports in main modules."
msgstr ""
":pep:`366` ã¯ã€ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã®æ˜ç¤ºçš„ãªç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®ãŸã‚ã«è¿½åŠ ã—ãŸ ``__package__`` å±æ€§ã®è§£èª¬ã‚’ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/import.rst:1007
msgid ""
":pep:`328` introduced absolute and explicit relative imports and initially "
"proposed ``__name__`` for semantics :pep:`366` would eventually specify for "
"``__package__``."
msgstr ""
":pep:`328` ã¯çµ¶å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã€æ˜ç¤ºçš„ãªç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ãŠã‚ˆã³ã€å½“åˆ ``__name__`` ã§ææ¡ˆã—ã€å¾Œã« :pep:`366` ãŒ "
"``__package__`` ã§å®šã‚ãŸä»•æ§˜ã‚’å°å…¥ã—ã¾ã—ãŸã€‚"

#: ../../reference/import.rst:1011
msgid ":pep:`338` defines executing modules as scripts."
msgstr ":pep:`338` ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨ã—ã¦å®Ÿè¡Œã™ã‚‹ã¨ãã®ä»•æ§˜ã‚’å®šã‚ã¦ã„ã¾ã™ã€‚"

#: ../../reference/import.rst:1013
msgid ""
":pep:`451` adds the encapsulation of per-module import state in spec "
"objects.  It also off-loads most of the boilerplate responsibilities of "
"loaders back onto the import machinery.  These changes allow the deprecation"
" of several APIs in the import system and also addition of new methods to "
"finders and loaders."
msgstr ""
":pep:`451` "
"ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãŠã‘ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¯ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆçŠ¶æ…‹ã®ã‚«ãƒ—ã‚»ãƒ«åŒ–ã‚’è¿½åŠ ã—ã¦ã„ã¾ã™ã€‚ã¾ãŸã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã®å®šå‹çš„ãªè²¬ä»»ã®ã»ã¨ã‚“ã©ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã«è‚©ä»£ã‚ã‚Šã•ã›ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å¤‰æ›´ã«ã‚ˆã‚Šã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®ã„ãã¤ã‹ã®"
" API ãŒ deprecate ã•ã‚Œã€ã¾ãŸãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¨ãƒ­ãƒ¼ãƒ€ãƒ¼ã«ã¯æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../reference/import.rst:1020
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../reference/import.rst:1021
msgid "See :class:`types.ModuleType`."
msgstr ":class:`types.ModuleType` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/import.rst:1023
msgid ""
"The importlib implementation avoids using the return value directly. "
"Instead, it gets the module object by looking the module name up in "
":data:`sys.modules`.  The indirect effect of this is that an imported module"
" may replace itself in :data:`sys.modules`.  This is implementation-specific"
" behavior that is not guaranteed to work in other Python implementations."
msgstr ""
"importlib ã®å®Ÿè£…ã¯ã€æˆ»ã‚Šå€¤ã‚’ç›´æ¥ä½¿ã†ã“ã¨ã¯é¿ã‘ã¦ã„ã¾ã™ã€‚ãã®ä»£ã‚ã‚Šã«ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’èª¿ã¹ã¦ :data:`sys.modules` "
"ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¾—ã¾ã™ã€‚ã“ã†ã™ã‚‹ã“ã¨ã®é–“æ¥çš„ãªåŠ¹æœã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ :data:`sys.modules` "
"ã«ã„ã‚‹è‡ªåˆ†è‡ªèº«ã‚’ç½®ãæ›ãˆã‚‹ã“ã¨ãŒã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ã“ã‚Œã¯å®Ÿè£…ä¾å­˜ã®å‹•ä½œã§ã‚ã‚Šã€ä»–ã® Python å®Ÿè£…ã§ã¯ä¿è¨¼ã•ã‚Œã¦ã„ãªã„å‹•ä½œã§ã™ã€‚"

#: ../../reference/import.rst:1030
msgid ""
"In legacy code, it is possible to find instances of "
":class:`imp.NullImporter` in the :data:`sys.path_importer_cache`.  It is "
"recommended that code be changed to use ``None`` instead.  See "
":ref:`portingpythoncode` for more details."
msgstr ""
"ãƒ¬ã‚¬ã‚·ãƒ¼ãªã‚³ãƒ¼ãƒ‰ã§ã¯ã€ :data:`sys.path_importer_cache` ã« :class:`imp.NullImporter` "
"ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã„ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã®ä»£ã‚ã‚Šã« ``None`` ã‚’ä½¿ã†ã‚ˆã†ã«ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¾ã™ã€‚ã‚ˆã‚Šè©³ã—ã„ã“ã¨ã¯ "
":ref:`portingpythoncode` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"
