# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2021
# mollinaca, 2021
# Shin Saito, 2021
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-24 14:15+0000\n"
"PO-Revision-Date: 2021-06-28 01:49+0000\n"
"Last-Translator: Shin Saito, 2021\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/import.rst:6
msgid "The import system"
msgstr "インポートシステム"

#: ../../reference/import.rst:10
msgid ""
"Python code in one :term:`module` gains access to the code in another module "
"by the process of :term:`importing` it.  The :keyword:`import` statement is "
"the most common way of invoking the import machinery, but it is not the only "
"way.  Functions such as :func:`importlib.import_module` and built-in :func:"
"`__import__` can also be used to invoke the import machinery."
msgstr ""
"ある 1 つの :term:`module` にある Python コードから他のモジュールを :term:`イ"
"ンポート <importing>` することで、そこにあるコードへアクセスできるようになり"
"ます。 :keyword:`import` 文はインポート機構を動かす最も一般的な方法ですが、そ"
"れが唯一の方法ではありません。 :func:`importlib.import_module` や組み込みの :"
"func:`__import__` といった関数を使っても、インポート機構を動かすことができま"
"す。"

#: ../../reference/import.rst:16
msgid ""
"The :keyword:`import` statement combines two operations; it searches for the "
"named module, then it binds the results of that search to a name in the "
"local scope.  The search operation of the :keyword:`!import` statement is "
"defined as a call to the :func:`__import__` function, with the appropriate "
"arguments. The return value of :func:`__import__` is used to perform the "
"name binding operation of the :keyword:`!import` statement.  See the :"
"keyword:`!import` statement for the exact details of that name binding "
"operation."
msgstr ""
":keyword:`import` 文は 2 つの処理を連続して行っています; ある名前のモジュール"
"を探し、その検索結果をローカルスコープの名前に束縛します。 :keyword:`!"
"import` 文の検索処理は、適切な引数で :func:`__import__` 関数を呼び出すことと"
"して定義されています。 :func:`__import__` の戻り値は :keyword:`!import` 文の"
"名前束縛処理の実行で使われます。名前束縛処理の厳密な詳細は :keyword:`!"
"import` 文を参照してください。"

#: ../../reference/import.rst:25
msgid ""
"A direct call to :func:`__import__` performs only the module search and, if "
"found, the module creation operation.  While certain side-effects may occur, "
"such as the importing of parent packages, and the updating of various caches "
"(including :data:`sys.modules`), only the :keyword:`import` statement "
"performs a name binding operation."
msgstr ""
":func:`__import__` を直接呼び出すとモジュールの検索のみが行われ、見つかった場"
"合、モジュールの作成処理が行われます。親パッケージのインポートや (:data:`sys."
"modules` を含む) 様々なキャッシュの更新などの副作用は起きるかもしれません"
"が、 :keyword:`import` 文のみが名前束縛処理を行います。"

#: ../../reference/import.rst:31
msgid ""
"When an :keyword:`import` statement is executed, the standard builtin :func:"
"`__import__` function is called. Other mechanisms for invoking the import "
"system (such as :func:`importlib.import_module`) may choose to bypass :func:"
"`__import__` and use their own solutions to implement import semantics."
msgstr ""
":keyword:`import` 文が実行されるときには、標準の組み込み関数 :func:"
"`__import__` が呼ばれます。インポートシステムを呼び出すその他の (:func:"
"`importlib.import_module` 関数のような)  メカニズムは、:func:`__import__` の"
"呼び出しをバイパスして独自のインポート・セマンティクスを実装している可能性が"
"あります。"

#: ../../reference/import.rst:36
msgid ""
"When a module is first imported, Python searches for the module and if "
"found, it creates a module object [#fnmo]_, initializing it.  If the named "
"module cannot be found, a :exc:`ModuleNotFoundError` is raised.  Python "
"implements various strategies to search for the named module when the import "
"machinery is invoked.  These strategies can be modified and extended by "
"using various hooks described in the sections below."
msgstr ""
"モジュールが初めてインポートされるとき、 Python はそのモジュールを検索し、見"
"付かった場合、モジュールオブジェクトを作成し、初期化します [#fnmo]_ 。その名"
"前のモジュールが見付からなかった場合、 :exc:`ModuleNotFoundError` が送出され"
"ます。 Python には、インポート機構が実行されたときに名前からモジュールを検索"
"する様々な戦略が実装されています。これらの戦略は、これ以降の節で解説される"
"様々なフックを使って、修正したり拡張したりできます。"

#: ../../reference/import.rst:43
msgid ""
"The import system has been updated to fully implement the second phase of :"
"pep:`302`. There is no longer any implicit import machinery - the full "
"import system is exposed through :data:`sys.meta_path`. In addition, native "
"namespace package support has been implemented (see :pep:`420`)."
msgstr ""
"インポートシステムが :pep:`302` の第 2 フェーズの完全な実装へ更新されました。"
"もはや暗黙的なインポート機構はありません - インポート機構全体は :data:`sys."
"meta_path` を通して公開されています。加えて、ネイティブの名前空間パッケージの"
"サポートは実装されています (:pep:`420` を参照) 。"

#: ../../reference/import.rst:51
msgid ":mod:`importlib`"
msgstr ":mod:`importlib`"

#: ../../reference/import.rst:53
msgid ""
"The :mod:`importlib` module provides a rich API for interacting with the "
"import system.  For example :func:`importlib.import_module` provides a "
"recommended, simpler API than built-in :func:`__import__` for invoking the "
"import machinery.  Refer to the :mod:`importlib` library documentation for "
"additional detail."
msgstr ""
":mod:`importlib` モジュールはインポート機構とやり取りするための便利な API を"
"提供します。例えば :func:`importlib.import_module` は、インポート機構を実行す"
"るための組み込みの :func:`__import__` よりもシンプルで推奨される API を提供し"
"ます。より詳細なことは :mod:`importlib` ライブラリのドキュメントを参照してく"
"ださい。"

#: ../../reference/import.rst:62
msgid "Packages"
msgstr "パッケージ"

#: ../../reference/import.rst:67
msgid ""
"Python has only one type of module object, and all modules are of this type, "
"regardless of whether the module is implemented in Python, C, or something "
"else.  To help organize modules and provide a naming hierarchy, Python has a "
"concept of :term:`packages <package>`."
msgstr ""
"Python にはモジュールオブジェクトの種類は 1 種類しかなく、 Python 、 C 、それ"
"以外のもののどれで実装されているかに関係なく、すべてのモジュールはこの種類に"
"なります。モジュールの組織化を助け、名前階層を提供するために、 Python には :"
"term:`パッケージ <package>` という概念があります。"

#: ../../reference/import.rst:72
msgid ""
"You can think of packages as the directories on a file system and modules as "
"files within directories, but don't take this analogy too literally since "
"packages and modules need not originate from the file system.  For the "
"purposes of this documentation, we'll use this convenient analogy of "
"directories and files.  Like file system directories, packages are organized "
"hierarchically, and packages may themselves contain subpackages, as well as "
"regular modules."
msgstr ""
"パッケージはファイルシステムのディレクトリ、モジュールはディレクトリにある"
"ファイルと考えることができますが、パッケージやモジュールはファイルシステムか"
"ら生まれる必要はないので、この比喩を額面通りに受け取ってはいけません。この文"
"書の目的のために、ディレクトリとファイルという便利な比喩を使うことにします。"
"ファイルシステムのディレクトリのように、パッケージは階層構造を成し、通常のモ"
"ジュールだけでなく、サブパッケージを含むこともあります。"

#: ../../reference/import.rst:80
msgid ""
"It's important to keep in mind that all packages are modules, but not all "
"modules are packages.  Or put another way, packages are just a special kind "
"of module.  Specifically, any module that contains a ``__path__`` attribute "
"is considered a package."
msgstr ""
"すべてのパッケージはモジュールですが、すべてのモジュールがパッケージとは限ら"
"ないことを心に留めておくのが重要です。もしくは他の言い方をすると、パッケージ"
"は単なる特別な種類のモジュールであると言えます。特に、``__path__`` 属性を持つ"
"任意のモジュールはパッケージと見なされます。"

#: ../../reference/import.rst:85
msgid ""
"All modules have a name.  Subpackage names are separated from their parent "
"package name by a dot, akin to Python's standard attribute access syntax.  "
"Thus you might have a package called :mod:`email`, which in turn has a "
"subpackage called :mod:`email.mime` and a module within that subpackage "
"called :mod:`email.mime.text`."
msgstr ""

#: ../../reference/import.rst:93
msgid "Regular packages"
msgstr "通常のパッケージ"

#: ../../reference/import.rst:98
msgid ""
"Python defines two types of packages, :term:`regular packages <regular "
"package>` and :term:`namespace packages <namespace package>`.  Regular "
"packages are traditional packages as they existed in Python 3.2 and earlier. "
"A regular package is typically implemented as a directory containing an "
"``__init__.py`` file.  When a regular package is imported, this ``__init__."
"py`` file is implicitly executed, and the objects it defines are bound to "
"names in the package's namespace.  The ``__init__.py`` file can contain the "
"same Python code that any other module can contain, and Python will add some "
"additional attributes to the module when it is imported."
msgstr ""
"Python では、 :term:`通常のパッケージ <regular package>` と :term:`名前空間"
"パッケージ <namespace package>` の 2 種類のパッケージが定義されています。通常"
"のパッケージは Python 3.2 以前から存在する伝統的なパッケージです。典型的な通"
"常のパッケージは ``__init__.py`` ファイルを含むディレクトリとして実装されま"
"す。通常のパッケージがインポートされたとき、この ``__init__.py`` ファイルが暗"
"黙的に実行され、それで定義しているオブジェクトがパッケージ名前空間にある名前"
"に束縛されます。 ``__init__.py`` ファイルは、他のモジュールに書ける Python "
"コードと同じものを含むことができ、モジュールがインポートされたときに Python "
"はモジュールに属性を追加したりします。"

#: ../../reference/import.rst:108
msgid ""
"For example, the following file system layout defines a top level ``parent`` "
"package with three subpackages::"
msgstr ""
"例えば、以下のようなファイルシステム配置は、3 つのサブパッケージを持つ最上位"
"の ``parent`` パッケージを定義します::"

#: ../../reference/import.rst:120
msgid ""
"Importing ``parent.one`` will implicitly execute ``parent/__init__.py`` and "
"``parent/one/__init__.py``.  Subsequent imports of ``parent.two`` or "
"``parent.three`` will execute ``parent/two/__init__.py`` and ``parent/three/"
"__init__.py`` respectively."
msgstr ""
"``parent.one`` をインポートすると暗黙的に ``parent/__init__.py`` と ``parent/"
"one/__init__.py`` が実行されます。その後に ``parent.two`` もしくは ``parent."
"three`` をインポートすると、それぞれ ``parent/two/__init__.py`` や ``parent/"
"three/__init__.py`` が実行されます。"

#: ../../reference/import.rst:127
msgid "Namespace packages"
msgstr "名前空間パッケージ"

#: ../../reference/import.rst:133
msgid ""
"A namespace package is a composite of various :term:`portions <portion>`, "
"where each portion contributes a subpackage to the parent package.  Portions "
"may reside in different locations on the file system.  Portions may also be "
"found in zip files, on the network, or anywhere else that Python searches "
"during import.  Namespace packages may or may not correspond directly to "
"objects on the file system; they may be virtual modules that have no "
"concrete representation."
msgstr ""
"名前空間パッケージは様々な :term:`ポーション <portion>` を寄せ集めたもので、"
"それぞれのポーションはサブパッケージを親パッケージに提供します。ポーションは"
"ファイルシステムの別々の場所にあることもあります。ポーションは、 zip ファイル"
"の中やネットワーク上や、それ以外のインポート時に Python が探すどこかの場所で"
"見つかることもあります。名前空間パッケージはファイルシステム上のオブジェクト"
"に対応することもあるし、そうでないこともあります; それらは実際の実体のない仮"
"想モジュールです。"

#: ../../reference/import.rst:141
msgid ""
"Namespace packages do not use an ordinary list for their ``__path__`` "
"attribute. They instead use a custom iterable type which will automatically "
"perform a new search for package portions on the next import attempt within "
"that package if the path of their parent package (or :data:`sys.path` for a "
"top level package) changes."
msgstr ""
"名前空間パッケージは、  ``__path__`` 属性に普通のリストは使いません。その代わ"
"りに独自の iterable 型を使っていて、ポーションの親パッケージのパス (もしくは"
"最上位パッケージのための :data:`sys.path`) が変わった場合、そのパッケージでの"
"次のインポートの際に、新たに自動でパッケージポーションを検索します。"

#: ../../reference/import.rst:147
msgid ""
"With namespace packages, there is no ``parent/__init__.py`` file.  In fact, "
"there may be multiple ``parent`` directories found during import search, "
"where each one is provided by a different portion.  Thus ``parent/one`` may "
"not be physically located next to ``parent/two``.  In this case, Python will "
"create a namespace package for the top-level ``parent`` package whenever it "
"or one of its subpackages is imported."
msgstr ""
"名前空間パッケージには ``parent/__init__.py`` ファイルはありません。それどこ"
"ろか、異なるポーションがそれぞれ提供する複数の ``parent`` ディレクトリがイン"
"ポート検索の際に見つかることもあります。したがって ``parent/one`` は物理的に "
"``parent/two`` の隣りにあるとは限りません。その場合、そのパッケージかサブパッ"
"ケージのうち 1 つがインポートされたとき、Python は最上位の ``parent`` パッ"
"ケージのための名前空間パッケージを作成します。"

#: ../../reference/import.rst:154
msgid "See also :pep:`420` for the namespace package specification."
msgstr "名前空間パッケージの仕様については :pep:`420` も参照してください。"

#: ../../reference/import.rst:158
msgid "Searching"
msgstr "検索"

#: ../../reference/import.rst:160
msgid ""
"To begin the search, Python needs the :term:`fully qualified <qualified "
"name>` name of the module (or package, but for the purposes of this "
"discussion, the difference is immaterial) being imported.  This name may "
"come from various arguments to the :keyword:`import` statement, or from the "
"parameters to the :func:`importlib.import_module` or :func:`__import__` "
"functions."
msgstr ""
"検索を始めるためには、 Python はインポートされるモジュール (もしくはパッケー"
"ジですが、ここでの議論の目的においてはささいな違いです) の :term:`完全修飾 "
"<qualified name>` 名を必要とします。この名前は、 :keyword:`import` 文の様々な"
"引数や :func:`importlib.import_module` および :func:`__import__` 関数のパラ"
"メータから得られます。"

#: ../../reference/import.rst:166
msgid ""
"This name will be used in various phases of the import search, and it may be "
"the dotted path to a submodule, e.g. ``foo.bar.baz``.  In this case, Python "
"first tries to import ``foo``, then ``foo.bar``, and finally ``foo.bar."
"baz``. If any of the intermediate imports fail, a :exc:`ModuleNotFoundError` "
"is raised."
msgstr ""
"この名前はインポート検索の様々なフェーズで使われ、これは例えば ``foo.bar."
"baz`` のようなドットで区切られたサブモジュールへのパスだったりします。この場"
"合、 Python は最初に ``foo`` を、次に ``foo.bar`` 、そして最後に ``foo.bar."
"baz`` をインポートしようとします。中間のいずれかのインポートに失敗した場合"
"は、 :exc:`ModuleNotFoundError` が送出されます。"

#: ../../reference/import.rst:173
msgid "The module cache"
msgstr "モジュールキャッシュ"

#: ../../reference/import.rst:178
msgid ""
"The first place checked during import search is :data:`sys.modules`.  This "
"mapping serves as a cache of all modules that have been previously imported, "
"including the intermediate paths.  So if ``foo.bar.baz`` was previously "
"imported, :data:`sys.modules` will contain entries for ``foo``, ``foo.bar``, "
"and ``foo.bar.baz``.  Each key will have as its value the corresponding "
"module object."
msgstr ""
"インポート検索で最初に調べる場所は :data:`sys.modules` です。このマッピング"
"は、中間のパスを含む、これまでにインポートされたすべてのモジュールのキャッ"
"シュを提供します。なので ``foo.bar.baz`` がインポート済みの場合、 :data:`sys."
"modules` は ``foo`` 、 ``foo.bar`` 、 ``foo.bar.baz`` のエントリーを含みま"
"す。それぞれのキーはその値として対応するモジュールオブジェクトを持ちます。"

#: ../../reference/import.rst:185
msgid ""
"During import, the module name is looked up in :data:`sys.modules` and if "
"present, the associated value is the module satisfying the import, and the "
"process completes.  However, if the value is ``None``, then a :exc:"
"`ModuleNotFoundError` is raised.  If the module name is missing, Python will "
"continue searching for the module."
msgstr ""
"インポートではモジュール名は :data:`sys.modules` から探され、存在した場合は、"
"対応する値がインポートされるべきモジュールであり、この処理は完了します。しか"
"し値が ``None`` だった場合、 :exc:`ModuleNotFoundError` が送出されます。モ"
"ジュール名が見付からなかった場合は、 Python はモジュールの検索を続けます。"

#: ../../reference/import.rst:191
msgid ""
":data:`sys.modules` is writable.  Deleting a key may not destroy the "
"associated module (as other modules may hold references to it), but it will "
"invalidate the cache entry for the named module, causing Python to search "
"anew for the named module upon its next import. The key can also be assigned "
"to ``None``, forcing the next import of the module to result in a :exc:"
"`ModuleNotFoundError`."
msgstr ""
":data:`sys.modules` は書き込み可能です。キーの削除は対応するモジュールを破壊"
"しない (他のモジュールがそのモジュールへの参照を持っている) かもしれません"
"が、指定されたモジュールのキャッシュされたエントリーを無効にし、それが次にイ"
"ンポートされたとき Python にそのモジュールを改めて検索させることになります。"
"キーを ``None`` に対応付けることもできますが、次にそのモジュールがインポート"
"されるときに :exc:`ModuleNotFoundError` となってしまいます。"

#: ../../reference/import.rst:198
msgid ""
"Beware though, as if you keep a reference to the module object, invalidate "
"its cache entry in :data:`sys.modules`, and then re-import the named module, "
"the two module objects will *not* be the same. By contrast, :func:`importlib."
"reload` will reuse the *same* module object, and simply reinitialise the "
"module contents by rerunning the module's code."
msgstr ""
"たとえモジュールオブジェクトへの参照を保持しておいて、 :data:`sys.modules` に"
"キャッシュされたエントリーを無効にし、その指定したモジュールを再インポートし"
"たとしても、 2 つのモジュールオブジェクトは同じでは *ない* ことに注意してくだ"
"さい。それとは対照的に、 :func:`importlib.reload` は *同じ* モジュールオブ"
"ジェクトを再利用し、モジュールのコードを再実行することで単にモジュールの内容"
"を再初期化するだけです。"

#: ../../reference/import.rst:208
msgid "Finders and loaders"
msgstr "ファインダーとローダー"

#: ../../reference/import.rst:215
msgid ""
"If the named module is not found in :data:`sys.modules`, then Python's "
"import protocol is invoked to find and load the module.  This protocol "
"consists of two conceptual objects, :term:`finders <finder>` and :term:"
"`loaders <loader>`. A finder's job is to determine whether it can find the "
"named module using whatever strategy it knows about. Objects that implement "
"both of these interfaces are referred to as :term:`importers <importer>` - "
"they return themselves when they find that they can load the requested "
"module."
msgstr ""
":data:`sys.modules` に指定されたモジュールが見つからなかった場合は、 Python "
"のインポートプロトコルが起動され、モジュールを見つけロードします。このプロト"
"コルは 2 つの概念的なオブジェクト、 :term:`ファインダー <finder>` と :term:`"
"ローダー <loader>` から成ります。ファインダーの仕事は、知っている戦略を使って"
"指定されたモジュールを見つけられるかどうか判断することです。両方のインター"
"フェースを実装しているオブジェクトは :term:`インポーター <importer>` と呼ばれ"
"ます - インポーターは要求されたモジュールがロードできると分かったとき、自分自"
"身を返します。"

#: ../../reference/import.rst:223
msgid ""
"Python includes a number of default finders and importers.  The first one "
"knows how to locate built-in modules, and the second knows how to locate "
"frozen modules.  A third default finder searches an :term:`import path` for "
"modules.  The :term:`import path` is a list of locations that may name file "
"system paths or zip files.  It can also be extended to search for any "
"locatable resource, such as those identified by URLs."
msgstr ""
"Python にはデフォルトのファインダーとインポーターがいくつかあります。 1 つ目"
"のものは組み込みモジュールの見つけ方を知っていて、 2 つ目のものは凍結されたモ"
"ジュール (訳注: freeze ツールで処理されたモジュールのこと。 :doc:`プログラミ"
"ング FAQ <../faq/programming>` の「どうしたら Python スクリプトからスタンドア"
"ロンバイナリを作れますか？」の項目を参照) の見つけ方を知っています。 3 つ目の"
"ものは :term:`インポートパス <import path>` からモジュールを探します。 :term:"
"`インポートパス <import path>` はファイルシステムのパスや zip ファイルの位置"
"を示すリストです。このリストは、 URL で特定できるもののような、位置を示すこと"
"のできる任意のリソースの検索にまで拡張することもできます。"

#: ../../reference/import.rst:230
msgid ""
"The import machinery is extensible, so new finders can be added to extend "
"the range and scope of module searching."
msgstr ""
"インポート機構は拡張可能なので、モジュール検索の範囲とスコープを拡張するため"
"に新しいファインダーを付け加えることができます。"

#: ../../reference/import.rst:233
msgid ""
"Finders do not actually load modules.  If they can find the named module, "
"they return a :dfn:`module spec`, an encapsulation of the module's import-"
"related information, which the import machinery then uses when loading the "
"module."
msgstr ""
"ファインダーは実際にはモジュールをロードしません。指定されたモジュールが見つ"
"かった場合、ファインダーは :dfn:`module spec` (モジュール仕様)、すなわちモ"
"ジュールのインポート関連の情報をカプセル化したものを返します。モジュールの"
"ロード時にインポート機構はそれを利用します。"

#: ../../reference/import.rst:237
msgid ""
"The following sections describe the protocol for finders and loaders in more "
"detail, including how you can create and register new ones to extend the "
"import machinery."
msgstr ""
"次の節では、インポート機構を拡張するための新しいファインダーやローダーの作成"
"と登録を含め、ファインダーとローダーのプロトコルについてより詳しく解説しま"
"す。"

#: ../../reference/import.rst:241
msgid ""
"In previous versions of Python, finders returned :term:`loaders <loader>` "
"directly, whereas now they return module specs which *contain* loaders. "
"Loaders are still used during import but have fewer responsibilities."
msgstr ""
"Python の以前のバージョンでは、ファインダーは直接 :term:`ローダー <loader>` "
"を返していましたが、現在はローダーを *含む* モジュール仕様を返します。ロー"
"ダーはインポート中はまだ使われていますが、責任は減りました。"

#: ../../reference/import.rst:247
msgid "Import hooks"
msgstr "インポートフック"

#: ../../reference/import.rst:257
msgid ""
"The import machinery is designed to be extensible; the primary mechanism for "
"this are the *import hooks*.  There are two types of import hooks: *meta "
"hooks* and *import path hooks*."
msgstr ""
"インポート機構は拡張可能なように設計されています; その主となる仕組みは *イン"
"ポートフック* です。インポートフックには 2 種類あります: *メタフック* と *イ"
"ンポートパスフック* です。"

#: ../../reference/import.rst:261
msgid ""
"Meta hooks are called at the start of import processing, before any other "
"import processing has occurred, other than :data:`sys.modules` cache look "
"up. This allows meta hooks to override :data:`sys.path` processing, frozen "
"modules, or even built-in modules.  Meta hooks are registered by adding new "
"finder objects to :data:`sys.meta_path`, as described below."
msgstr ""
"メタフックはインポート処理の最初、 :data:`sys.modules` キャッシュの検索以外の"
"インポート処理より前に呼び出されます。これにより、 :data:`sys.path` の処理や"
"凍結されたモジュールや組み込みのモジュールでさえも、メタフックで上書きするこ"
"とができます。メタフックは以下で解説するように、 :data:`sys.meta_path` に新し"
"いファインダーオブジェクトを追加することで登録されます。"

#: ../../reference/import.rst:267
msgid ""
"Import path hooks are called as part of :data:`sys.path` (or ``package."
"__path__``) processing, at the point where their associated path item is "
"encountered.  Import path hooks are registered by adding new callables to :"
"data:`sys.path_hooks` as described below."
msgstr ""
"インポートパスフックは、 :data:`sys.path` (もしくは ``package.__path__``) の"
"処理の一部として、対応するパス要素を取り扱うところで呼び出されます。インポー"
"トパスフックは以下で解説するように、新しい呼び出し可能オブジェクトを :data:"
"`sys.path_hooks` に追加することで登録されます。"

#: ../../reference/import.rst:274
msgid "The meta path"
msgstr "メタパス"

#: ../../reference/import.rst:280
msgid ""
"When the named module is not found in :data:`sys.modules`, Python next "
"searches :data:`sys.meta_path`, which contains a list of meta path finder "
"objects.  These finders are queried in order to see if they know how to "
"handle the named module.  Meta path finders must implement a method called :"
"meth:`~importlib.abc.MetaPathFinder.find_spec()` which takes three "
"arguments: a name, an import path, and (optionally) a target module.  The "
"meta path finder can use any strategy it wants to determine whether it can "
"handle the named module or not."
msgstr ""
"指定されたモジュールが :data:`sys.modules` に見つからなかったとき、 Python は"
"次にメタパス・ファインダー・オブジェクトが格納されている :data:`sys."
"meta_path` を検索します。指定されたモジュールを扱うことができるかどうかを調べ"
"るために、各ファインダーに問い合わせを行います。メタパス・ファインダーには、"
"名前とインポートパスと (オプションの) ターゲットモジュールの 3 つの引数を取"
"る :meth:`~importlib.abc.MetaPathFinder.find_spec()` という名前のメソッドが実"
"装されていなければいけません。メタパス・ファインダーでは、指定されたモジュー"
"ルを扱えるかどうかを判定するための戦略は任意のものを使って構いません。"

#: ../../reference/import.rst:289
msgid ""
"If the meta path finder knows how to handle the named module, it returns a "
"spec object.  If it cannot handle the named module, it returns ``None``.  "
"If :data:`sys.meta_path` processing reaches the end of its list without "
"returning a spec, then a :exc:`ModuleNotFoundError` is raised.  Any other "
"exceptions raised are simply propagated up, aborting the import process."
msgstr ""
"meta path finder が指定されたモジュールの扱い方を知っている場合は、ファインダ"
"は spec オブジェクトを返します。指定されたモジュールを扱えない場合は "
"``None`` を返します。 :data:`sys.meta_path` に対する処理が spec を返さずにリ"
"ストの末尾に到達してしまった場合は、 :exc:`ModuleNotFoundError` を送出しま"
"す。その他の送出された例外はそのまま呼び出し元に伝播され、インポート処理を異"
"常終了させます。"

#: ../../reference/import.rst:295
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec()` method of meta path "
"finders is called with two or three arguments.  The first is the fully "
"qualified name of the module being imported, for example ``foo.bar.baz``. "
"The second argument is the path entries to use for the module search.  For "
"top-level modules, the second argument is ``None``, but for submodules or "
"subpackages, the second argument is the value of the parent package's "
"``__path__`` attribute. If the appropriate ``__path__`` attribute cannot be "
"accessed, a :exc:`ModuleNotFoundError` is raised.  The third argument is an "
"existing module object that will be the target of loading later. The import "
"system passes in a target module only during reload."
msgstr ""
"メタパス・ファインダーの :meth:`~importlib.abc.MetaPathFinder.find_spec()` メ"
"ソッドは 2 つまたは 3 つの引数を渡して呼び出します。1 つ目の引数はインポート"
"されるモジュールの完全修飾名で、例えば ``foo.bar.baz`` などです。2 つ目の引数"
"はモジュールの検索で使われるパスです。最上位のモジュールでは 2 つ目の引数は "
"``None`` にしますが、サブモジュールやサブパッケージでは 2 つ目の引数は親パッ"
"ケージの ``__path__`` 属性の値です。適切な ``__path__`` 属性にアクセスできな"
"かった場合は、 :exc:`ModuleNotFoundError` が送出されます。3 つ目の引数は、あ"
"とでロードされるターゲットとなる既存のモジュールオブジェクトです。インポート"
"システムはリロードの間だけターゲットモジュール をセットします。"

#: ../../reference/import.rst:306
msgid ""
"The meta path may be traversed multiple times for a single import request. "
"For example, assuming none of the modules involved has already been cached, "
"importing ``foo.bar.baz`` will first perform a top level import, calling "
"``mpf.find_spec(\"foo\", None, None)`` on each meta path finder (``mpf``). "
"After ``foo`` has been imported, ``foo.bar`` will be imported by traversing "
"the meta path a second time, calling ``mpf.find_spec(\"foo.bar\", foo."
"__path__, None)``. Once ``foo.bar`` has been imported, the final traversal "
"will call ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."
msgstr ""
"メタパスは、1 回のインポート要求で複数回走査される可能性があります。例えば、"
"関係するモジュールがどれもまだキャッシュされていないとしたときに ``foo.bar."
"baz`` をインポートすると、最初は各メタパス・ファインダー (``mpf``) に対して "
"``mpf.find_spec(\"foo\", None, None)`` を呼び出して、最上位のインポート処理を"
"行います。``foo`` がインポートされた後に、``mpf.find_spec(\"foo.bar\", foo."
"__path__, None)`` を呼び出していく 2 回目のメタパスの走査が行われ、``foo."
"bar`` がインポートされます。``foo.bar`` のインポートまで行われたら、最後の走"
"査で ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)`` を呼び出して"
"いきます。"

#: ../../reference/import.rst:316
msgid ""
"Some meta path finders only support top level imports. These importers will "
"always return ``None`` when anything other than ``None`` is passed as the "
"second argument."
msgstr ""
"あるメタパス・ファインダーは最上位のインポートのみサポートしています。これら"
"のインポーターは、2 つ目の引数に ``None`` 以外のものが渡されたとき、常に "
"``None`` を返します。"

#: ../../reference/import.rst:320
msgid ""
"Python's default :data:`sys.meta_path` has three meta path finders, one that "
"knows how to import built-in modules, one that knows how to import frozen "
"modules, and one that knows how to import modules from an :term:`import "
"path` (i.e. the :term:`path based finder`)."
msgstr ""
"Python のデフォルトの :data:`sys.meta_path` は 3 つのパスファインダーを持って"
"います。組み込みモジュールのインポートの方法を知っているもの、凍結されたモ"
"ジュールのインポートの方法を知っているもの、 :term:`インポートパス <import "
"path>` からのモジュールのインポートの方法を知っているもの (つまり :term:`パス"
"ベース・ファインダー <path based finder>`) があります。"

#: ../../reference/import.rst:325
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders replaced :meth:`~importlib.abc.MetaPathFinder.find_module`, which is "
"now deprecated.  While it will continue to work without change, the import "
"machinery will try it only if the finder does not implement ``find_spec()``."
msgstr ""
"メタパス・ファインダーの :meth:`~importlib.abc.MetaPathFinder.find_module` メ"
"ソッドは :meth:`~importlib.abc.MetaPathFinder.find_spec` に置き換えられまし"
"た。 ``find_module()`` メソッドは非推奨 (deprecated) です。前者のメソッドは今"
"でも変更なしに動きますが、インポート機構はファインダーが ``find_spec()`` を実"
"装していない場合にのみそれを試します。"

#: ../../reference/import.rst:332
msgid ""
"Use of :meth:`~importlib.abc.MetaPathFinder.find_module` by the import "
"system now raises :exc:`ImportWarning`."
msgstr ""
"インポート機構が :meth:`~importlib.abc.MetaPathFinder.find_module` を使用した"
"場合、:exc:`ImportWarning` が発生します。"

#: ../../reference/import.rst:338
msgid "Loading"
msgstr "ロード"

#: ../../reference/import.rst:340
msgid ""
"If and when a module spec is found, the import machinery will use it (and "
"the loader it contains) when loading the module.  Here is an approximation "
"of what happens during the loading portion of import::"
msgstr ""
"モジュール仕様が見つかった場合、インポート機構はモジュールをロードする時にそ"
"れ (およびそれに含まれるローダー) を使います。これは、インポートのロード部分"
"で起こることの近似です::"

#: ../../reference/import.rst:374
msgid "Note the following details:"
msgstr "以下の詳細に注意してください:"

#: ../../reference/import.rst:376
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, import will have already returned it."
msgstr ""
":data:`sys.modules` の中に与えられた名前を持つ既存のモジュールオブジェクトが"
"あるなら、 import は既にそれを返しているでしょう。"

#: ../../reference/import.rst:379
msgid ""
"The module will exist in :data:`sys.modules` before the loader executes the "
"module code.  This is crucial because the module code may (directly or "
"indirectly) import itself; adding it to :data:`sys.modules` beforehand "
"prevents unbounded recursion in the worst case and multiple loading in the "
"best."
msgstr ""
"モジュールは、ローダーがモジュールコードを実行する前に :data:`sys.modules` に"
"存在しています。 モジュールコードが (直接的または間接的に) 自分自身をインポー"
"トする可能性があるので、これは重要です; モジュールを :data:`sys.modules` に追"
"加することで、最悪のケースでは無限の再帰が、そして最良のケースでは複数回の"
"ロードが、前もって防止されます。"

#: ../../reference/import.rst:385
msgid ""
"If loading fails, the failing module -- and only the failing module -- gets "
"removed from :data:`sys.modules`.  Any module already in the :data:`sys."
"modules` cache, and any module that was successfully loaded as a side-"
"effect, must remain in the cache.  This contrasts with reloading where even "
"the failing module is left in :data:`sys.modules`."
msgstr ""
"ロード処理に失敗した場合、その失敗したモジュールは -- そして、そのモジュール"
"だけが -- :data:`sys.modules` から取り除かれます。 :data:`sys.modules` キャッ"
"シュに既に含まれていたすべてのモジュールと、副作用としてロードに成功したすべ"
"てのモジュールは、常にキャッシュに残されます。これはリロードとは対照的で、リ"
"ロードの場合は失敗したモジュールも :data:`sys.modules` に残されます。"

#: ../../reference/import.rst:391
msgid ""
"After the module is created but before execution, the import machinery sets "
"the import-related module attributes (\"_init_module_attrs\" in the pseudo-"
"code example above), as summarized in a :ref:`later section <import-mod-"
"attrs>`."
msgstr ""
":ref:`後のセクション <import-mod-attrs>` で要約されるように、モジュールが作ら"
"れてから実行されるまでの間にインポート機構はインポート関連のモジュール属性を"
"設定します (上記擬似コード例の \"_init_module_attrs\")。"

#: ../../reference/import.rst:396
msgid ""
"Module execution is the key moment of loading in which the module's "
"namespace gets populated.  Execution is entirely delegated to the loader, "
"which gets to decide what gets populated and how."
msgstr ""
"モジュール実行はモジュールの名前空間が構築されるロードの重要な瞬間です。実行"
"はローダーに完全に委任され、ローダーは何をどのように構築するかを決定すること"
"になります。"

#: ../../reference/import.rst:400
msgid ""
"The module created during loading and passed to exec_module() may not be the "
"one returned at the end of import [#fnlo]_."
msgstr ""
"ロードの間に作成されて exec_module() に渡されたモジュールは、インポートの終わ"
"りに返されるものとは異なるかもしれません [#fnlo]_。"

#: ../../reference/import.rst:403
msgid ""
"The import system has taken over the boilerplate responsibilities of "
"loaders.  These were previously performed by the :meth:`importlib.abc.Loader."
"load_module` method."
msgstr ""
"インポートシステムはローダーの定型的な責任を引き継ぎました。これらは以前は :"
"meth:`importlib.abc.Loader.load_module` メソッドによって実行されました。"

#: ../../reference/import.rst:409
msgid "Loaders"
msgstr "ローダー"

#: ../../reference/import.rst:411
msgid ""
"Module loaders provide the critical function of loading: module execution. "
"The import machinery calls the :meth:`importlib.abc.Loader.exec_module` "
"method with a single argument, the module object to execute.  Any value "
"returned from :meth:`~importlib.abc.Loader.exec_module` is ignored."
msgstr ""
"モジュールローダーは、ロードの重要な機能であるモジュール実行機能を提供しま"
"す。インポート機構は、実行しようとするモジュールオブジェクトを単一の引数とし"
"て :meth:`importlib.abc.Loader.exec_module` メソッドを呼び出します。 :meth:"
"`importlib.abc.Loader.exec_module` から返された任意の値は無視されます。"

#: ../../reference/import.rst:416
msgid "Loaders must satisfy the following requirements:"
msgstr "ローダーは以下の仕様を満たしていなければいけません:"

#: ../../reference/import.rst:418
msgid ""
"If the module is a Python module (as opposed to a built-in module or a "
"dynamically loaded extension), the loader should execute the module's code "
"in the module's global name space (``module.__dict__``)."
msgstr ""
"モジュールが (組み込みモジュールや動的に読み込まれる拡張モジュールではなく"
"て) Python モジュールだった場合、ローダーはモジュールのグローバル名前空間 "
"(``module.__dict__``) で、モジュールのコードを実行すべきです。"

#: ../../reference/import.rst:422
msgid ""
"If the loader cannot execute the module, it should raise an :exc:"
"`ImportError`, although any other exception raised during :meth:`~importlib."
"abc.Loader.exec_module` will be propagated."
msgstr ""
":meth:`~importlib.abc.Loader.exec_module` の呼び出し中に :exc:`ImportError` "
"以外の例外が送出され、伝播されてきたとしても、モジュールをロードできない場合"
"は :exc:`ImportError` を送出すべきです。"

#: ../../reference/import.rst:426
msgid ""
"In many cases, the finder and loader can be the same object; in such cases "
"the :meth:`~importlib.abc.MetaPathFinder.find_spec` method would just return "
"a spec with the loader set to ``self``."
msgstr ""
"多くの場合、ファインダーとローダーは同じオブジェクトで構いません; そのような"
"場合では :meth:`~importlib.abc.MetaPathFinder.find_spec` メソッドは単に "
"``self`` (訳注: オブジェクト自身) を返すだけです。"

#: ../../reference/import.rst:430
msgid ""
"Module loaders may opt in to creating the module object during loading by "
"implementing a :meth:`~importlib.abc.Loader.create_module` method. It takes "
"one argument, the module spec, and returns the new module object to use "
"during loading.  ``create_module()`` does not need to set any attributes on "
"the module object.  If the method returns ``None``, the import machinery "
"will create the new module itself."
msgstr ""
"モジュールローダーは、 :meth:`~importlib.abc.Loader.create_module` メソッドを"
"実装することでロード中にモジュールオブジェクトを作成することを選択できます。"
"このメソッドは、モジュール仕様を引数に取って、ロード中に使う新しいモジュール"
"オブジェクトを返します。 ``create_module()`` はモジュールオブジェクトに属性を"
"設定する必要はありません。もしこのメソッドが ``None`` を返すなら、インポート"
"機構は新しいモジュールを自身で作成します。"

#: ../../reference/import.rst:437
msgid "The :meth:`~importlib.abc.Loader.create_module` method of loaders."
msgstr "ローダーの :meth:`~importlib.abc.Loader.create_module` メソッド。"

#: ../../reference/import.rst:440
msgid ""
"The :meth:`~importlib.abc.Loader.load_module` method was replaced by :meth:"
"`~importlib.abc.Loader.exec_module` and the import machinery assumed all the "
"boilerplate responsibilities of loading."
msgstr ""
":meth:`~importlib.abc.Loader.load_module` メソッドは :meth:`~importlib.abc."
"Loader.exec_module` によって置き換えられ、インポート機構がロードのすべての定"
"型的な処理を引き受けました。"

#: ../../reference/import.rst:445
msgid ""
"For compatibility with existing loaders, the import machinery will use the "
"``load_module()`` method of loaders if it exists and the loader does not "
"also implement ``exec_module()``.  However, ``load_module()`` has been "
"deprecated and loaders should implement ``exec_module()`` instead."
msgstr ""
"既存のローダーとの互換性のため、もしローダーに ``load_module()`` メソッドが存"
"在し、かつローダーが ``exec_module()`` を実装していなければ、インポート機構は"
"ローダーの ``load_module()`` メソッドを使います。しかし、 ``load_module()`` "
"は deprecated であり、ローダーは代わりに ``exec_module()`` を実装すべきです。"

#: ../../reference/import.rst:450
msgid ""
"The ``load_module()`` method must implement all the boilerplate loading "
"functionality described above in addition to executing the module.  All the "
"same constraints apply, with some additional clarification:"
msgstr ""
"``load_module()`` メソッドは、モジュールを実行することに加えて上記で説明され"
"たすべての定型的なロード機能を実施しなければなりません。同じ制約が適用されま"
"す。以下は追加の明確化です:"

#: ../../reference/import.rst:454
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, the loader must use that existing module. (Otherwise, :func:"
"`importlib.reload` will not work correctly.)  If the named module does not "
"exist in :data:`sys.modules`, the loader must create a new module object and "
"add it to :data:`sys.modules`."
msgstr ""
":data:`sys.modules` に与えられた名前のモジュールが存在している場合、ローダー"
"はその既存のモジュールを使わなければいけません。 (そうしないと :func:"
"`importlib.reload` は正しく動かないでしょう。) 指定されたモジュールが :data:"
"`sys.modules` に存在しない場合、ローダーは新しいモジュールオブジェクトを作成"
"し、 :data:`sys.modules` に追加しなければいけません。"

#: ../../reference/import.rst:460
msgid ""
"The module *must* exist in :data:`sys.modules` before the loader executes "
"the module code, to prevent unbounded recursion or multiple loading."
msgstr ""
"無限の再帰または複数回のロードを防止するために、ローダーがモジュールコードを"
"実行する前にモジュールは :data:`sys.modules` に存在しなければなりません "
"(*must*)。"

#: ../../reference/import.rst:464
msgid ""
"If loading fails, the loader must remove any modules it has inserted into :"
"data:`sys.modules`, but it must remove **only** the failing module(s), and "
"only if the loader itself has loaded the module(s) explicitly."
msgstr ""
"ロード処理に失敗した場合、ローダーは :data:`sys.modules` に追加したモジュール"
"を取り除かなければいけませんが、それはロードに失敗したモジュール **のみ** "
"を、そのモジュールがローダー自身に明示的にロードされた場合に限り、除去しなけ"
"ればなりません。"

#: ../../reference/import.rst:469
msgid ""
"A :exc:`DeprecationWarning` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"``exec_module()`` が定義されていて ``create_module()`` が定義されていない場"
"合、 :exc:`DeprecationWarning` が送出されるようになりました。"

#: ../../reference/import.rst:473
msgid ""
"An :exc:`ImportError` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"``exec_module()`` が定義されていて ``create_module()`` が定義されていない場"
"合、 :exc:`ImportError` が送出されるようになりました。"

#: ../../reference/import.rst:477
msgid "Use of ``load_module()`` will raise :exc:`ImportWarning`."
msgstr "``load_module()`` を使用すると :exc:`ImportWarning` が発生します。"

#: ../../reference/import.rst:481
msgid "Submodules"
msgstr "サブモジュール"

#: ../../reference/import.rst:483
msgid ""
"When a submodule is loaded using any mechanism (e.g. ``importlib`` APIs, the "
"``import`` or ``import-from`` statements, or built-in ``__import__()``) a "
"binding is placed in the parent module's namespace to the submodule object. "
"For example, if package ``spam`` has a submodule ``foo``, after importing "
"``spam.foo``, ``spam`` will have an attribute ``foo`` which is bound to the "
"submodule.  Let's say you have the following directory structure::"
msgstr ""
"サブモジュールをロードするのにどのようなメカニズム (例えば、 ``importlib`` "
"API 、 ``import`` または ``import-from`` ステートメント、またはビルトイン関数"
"の ``__import__``) が使われた場合でも、バインディングはサブモジュールオブジェ"
"クトを親モジュールの名前空間に配置します。例えば、もしパッケージ ``spam`` が"
"サブモジュール ``foo`` を持っていた場合、 ``spam.foo`` をインポートした後は "
"``spam`` は値がサブモジュールに束縛された属性 ``foo`` を持ちます。以下のディ"
"レクトリ構造を持っているとしましょう::"

#: ../../reference/import.rst:494
msgid "and ``spam/__init__.py`` has the following line in it::"
msgstr ""

#: ../../reference/import.rst:498
msgid ""
"then executing the following puts name bindings for ``foo`` and ``Foo`` in "
"the ``spam`` module::"
msgstr ""

#: ../../reference/import.rst:507
msgid ""
"Given Python's familiar name binding rules this might seem surprising, but "
"it's actually a fundamental feature of the import system.  The invariant "
"holding is that if you have ``sys.modules['spam']`` and ``sys.modules['spam."
"foo']`` (as you would after the above import), the latter must appear as the "
"``foo`` attribute of the former."
msgstr ""
"Python の慣れ親しんだ名前束縛ルールからするとこれは驚きかもしれませんが、それ"
"は実際インポートシステムの基本的な機能です。不変に保たなければならないのは "
"(上記のインポートの後などで) ``sys.modules['spam']`` と ``sys.modules['spam."
"foo']`` が存在する場合、後者が前者の ``foo`` 属性として存在しなければならない"
"ということです。"

#: ../../reference/import.rst:514
msgid "Module spec"
msgstr "モジュール仕様"

#: ../../reference/import.rst:516
msgid ""
"The import machinery uses a variety of information about each module during "
"import, especially before loading.  Most of the information is common to all "
"modules.  The purpose of a module's spec is to encapsulate this import-"
"related information on a per-module basis."
msgstr ""
"インポート機構は、インポートの間 (特にロードの前) に、個々のモジュールについ"
"てのさまざまな情報を扱います。情報のほとんどはすべてのモジュールで共通です。"
"モジュール仕様の目的は、このインポート関連の情報をモジュールの単位でカプセル"
"化することです。"

#: ../../reference/import.rst:521
msgid ""
"Using a spec during import allows state to be transferred between import "
"system components, e.g. between the finder that creates the module spec and "
"the loader that executes it.  Most importantly, it allows the import "
"machinery to perform the boilerplate operations of loading, whereas without "
"a module spec the loader had that responsibility."
msgstr ""
"インポートの際にモジュール仕様を使うことは、インポートシステムコンポーネント"
"間、例えばモジュール仕様を作成するファインダーとそれを実行するローダーの間で"
"状態を転送することを可能にします。最も重要なのは、それによってインポート機構"
"がロードの定型的な作業を実行できるようになるということです。これに対して、モ"
"ジュール仕様なしではローダがその責任を担っていました。"

#: ../../reference/import.rst:527
msgid ""
"The module's spec is exposed as the ``__spec__`` attribute on a module "
"object. See :class:`~importlib.machinery.ModuleSpec` for details on the "
"contents of the module spec."
msgstr ""
"モジュール仕様は、モジュールオブジェクトの ``__spec__`` 属性として公開されま"
"す。\n"
"モジュール仕様の内容の詳細については :class:`~importlib.machinery."
"ModuleSpec` を参照してください。"

#: ../../reference/import.rst:536
msgid "Import-related module attributes"
msgstr "インポート関連のモジュール属性"

#: ../../reference/import.rst:538
msgid ""
"The import machinery fills in these attributes on each module object during "
"loading, based on the module's spec, before the loader executes the module."
msgstr ""
"インポート機構はロードの間、モジュールの仕様に基づいて、ローダーがモジュール"
"が実行する前に以下の属性を書き込みます。"

#: ../../reference/import.rst:544
msgid ""
"The ``__name__`` attribute must be set to the fully qualified name of the "
"module.  This name is used to uniquely identify the module in the import "
"system."
msgstr ""

#: ../../reference/import.rst:550
msgid ""
"The ``__loader__`` attribute must be set to the loader object that the "
"import machinery used when loading the module.  This is mostly for "
"introspection, but can be used for additional loader-specific functionality, "
"for example getting data associated with a loader."
msgstr ""
"``__loader__`` 属性はモジュールロード時にインポート機構が使用したローダーオブ"
"ジェクトに設定されなければなりません。この属性は普通は内省用のものですが、"
"ローダー固有の追加機能のために用いることが出来ます。例えばローダー関連のデー"
"タの取得です。"

#: ../../reference/import.rst:557
msgid ""
"The module's ``__package__`` attribute must be set.  Its value must be a "
"string, but it can be the same value as its ``__name__``.  When the module "
"is a package, its ``__package__`` value should be set to its ``__name__``.  "
"When the module is not a package, ``__package__`` should be set to the empty "
"string for top-level modules, or for submodules, to the parent package's "
"name.  See :pep:`366` for further details."
msgstr ""
"モジュールの ``__package__`` 属性は設定されなければなりません。値は文字列でな"
"ければなりませんが、``__name__`` と同じ値でも構いません。モジュールがパッケー"
"ジの場合、``__package__`` の値はその ``__name__`` でなければなりません。モ"
"ジュールがパッケージでない場合、トップレベルのモジュールでは ``__package__`` "
"は空の文字列、サブモジュールでは親のパッケージ名でなければなりません。詳細"
"は :pep:`366` を参照してください。"

#: ../../reference/import.rst:565
msgid ""
"This attribute is used instead of ``__name__`` to calculate explicit "
"relative imports for main modules, as defined in :pep:`366`. It is expected "
"to have the same value as ``__spec__.parent``."
msgstr ""
"この属性は :pep:`366` で定義されているように、メインモジュールからの明示的な"
"相対インポートを計算するために、 ``__name__`` の代わりに使用されます。\n"
"この属性は ``__spec__.parent`` と同じ値を持つことを要求されます。"

#: ../../reference/import.rst:569
msgid ""
"The value of ``__package__`` is expected to be the same as ``__spec__."
"parent``."
msgstr ""
"``__package__`` の値が ``__spec__.parent`` と同じ値を持つことを要求されるよう"
"になりました。"

#: ../../reference/import.rst:575
msgid ""
"The ``__spec__`` attribute must be set to the module spec that was used when "
"importing the module. Setting ``__spec__`` appropriately applies equally to :"
"ref:`modules initialized during interpreter startup <programs>`.  The one "
"exception is ``__main__``, where ``__spec__`` is :ref:`set to None in some "
"cases <main_spec>`."
msgstr ""
"``__spec__`` 属性はモジュールロード時に使用されたモジュールスペックに設定され"
"なければなりません。\n"
"``__spec__`` を適切に設定すると :ref:`インタープリタ起動中に初期化されるモ"
"ジュール <programs>` にも同様に適用されます。\n"
"例外は ``__main__`` で、``__spec__`` は :ref:`場合によっては None に設定され"
"ます <main_spec>`。"

#: ../../reference/import.rst:581
msgid ""
"When ``__package__`` is not defined, ``__spec__.parent`` is used as a "
"fallback."
msgstr ""
"``__package__`` が定義されていないときは ``__spec__.parent`` がフォールバック"
"として使われます。"

#: ../../reference/import.rst:586
msgid ""
"``__spec__.parent`` is used as a fallback when ``__package__`` is not "
"defined."
msgstr ""
"``__package__`` が定義されていないときに ``__spec__.parent`` がフォールバック"
"として使われるようになりました。"

#: ../../reference/import.rst:592
msgid ""
"If the module is a package (either regular or namespace), the module "
"object's ``__path__`` attribute must be set.  The value must be iterable, "
"but may be empty if ``__path__`` has no further significance. If "
"``__path__`` is not empty, it must produce strings when iterated over. More "
"details on the semantics of ``__path__`` are given :ref:`below <package-path-"
"rules>`."
msgstr ""
"モジュールが (通常のまたは名前空間) パッケージの場合、モジュールオブジェクト"
"の  ``__path__`` 属性が設定される必要があります。値はイテレート可能でなければ"
"なりませんが、``__path__`` に意味がない場合は空でも構いません。``__path__`` "
"が空でない場合、イテレート時に文字列を生成しなければなりません。``__path__`` "
"のセマンティクスの詳細は  :ref:`下記 <package-path-rules>` の通りです。"

#: ../../reference/import.rst:599
msgid "Non-package modules should not have a ``__path__`` attribute."
msgstr "パッケージでないモジュールは ``__path__`` 属性を持ってはいけません。"

#: ../../reference/import.rst:604
msgid ""
"``__file__`` is optional (if set, value must be a string). It indicates the "
"pathname of the file from which the module was loaded (if loaded from a "
"file), or the pathname of the shared library file for extension modules "
"loaded dynamically from a shared library. It might be missing for certain "
"types of modules, such as C modules that are statically linked into the "
"interpreter, and the import system may opt to leave it unset if it has no "
"semantic meaning (e.g. a module loaded from a database)."
msgstr ""

#: ../../reference/import.rst:613
msgid ""
"If ``__file__`` is set then the ``__cached__`` attribute might also be set,  "
"which is the path to any compiled version of the code (e.g. byte-compiled "
"file). The file does not need to exist to set this attribute; the path can "
"simply point to where the compiled file would exist (see :pep:`3147`)."
msgstr ""

#: ../../reference/import.rst:619
msgid ""
"Note that ``__cached__`` may be set even if ``__file__`` is not set.  "
"However, that scenario is quite atypical.  Ultimately, the loader is what "
"makes use of the module spec provided by the finder (from which ``__file__`` "
"and ``__cached__`` are derived).  So if a loader can load from a cached "
"module but otherwise does not load from a file, that atypical scenario may "
"be appropriate."
msgstr ""

#: ../../reference/import.rst:629
msgid "module.__path__"
msgstr "module.__path__"

#: ../../reference/import.rst:631
msgid ""
"By definition, if a module has a ``__path__`` attribute, it is a package."
msgstr ""
"定義より、モジュールに ``__path__`` 属性があれば、そのモジュールはパッケージ"
"となります。"

#: ../../reference/import.rst:633
msgid ""
"A package's ``__path__`` attribute is used during imports of its "
"subpackages. Within the import machinery, it functions much the same as :"
"data:`sys.path`, i.e. providing a list of locations to search for modules "
"during import. However, ``__path__`` is typically much more constrained "
"than :data:`sys.path`."
msgstr ""
"パッケージの ``__path__`` 属性は、そのサブパッケージのインポート中に使われま"
"す。インポート機構の内部では、それは :data:`sys.path` とほとんど同じように機"
"能します。つまり、インポート中にモジュールを探す場所のリストを提供します。し"
"かし、一般的に ``__path__`` は :data:`sys.path` よりも制約が強いです。"

#: ../../reference/import.rst:639
msgid ""
"``__path__`` must be an iterable of strings, but it may be empty. The same "
"rules used for :data:`sys.path` also apply to a package's ``__path__``, and :"
"data:`sys.path_hooks` (described below) are consulted when traversing a "
"package's ``__path__``."
msgstr ""
"``__path__`` は文字列の iterable でなければいけませんが、空でも構いません。 :"
"data:`sys.path` と同じ規則がパッケージの ``__path__`` にも適用され、パッケー"
"ジの ``__path__`` を走査するときに (後で解説する) :data:`sys.path_hooks` が考"
"慮に入れられます。"

#: ../../reference/import.rst:644
msgid ""
"A package's ``__init__.py`` file may set or alter the package's ``__path__`` "
"attribute, and this was typically the way namespace packages were "
"implemented prior to :pep:`420`.  With the adoption of :pep:`420`, namespace "
"packages no longer need to supply ``__init__.py`` files containing only "
"``__path__`` manipulation code; the import machinery automatically sets "
"``__path__`` correctly for the namespace package."
msgstr ""
"パッケージの ``__init__.py`` ファイルは、パッケージの ``__path__`` 属性を設定"
"もしくは変更することがあり、これが :pep:`420` 以前の名前空間パッケージの典型"
"的な実装方法でした。 :pep:`420` の採択により、もはや名前空間パッケージは、 "
"``__path__`` を操作するコードだけを含む ``__init__.py`` ファイルを提供する必"
"要がなくなりました;インポート機構は、名前空間パッケージに対し自動的に適切な "
"``__path__`` をセットします。"

#: ../../reference/import.rst:652
msgid "Module reprs"
msgstr "モジュールの repr"

#: ../../reference/import.rst:654
msgid ""
"By default, all modules have a usable repr, however depending on the "
"attributes set above, and in the module's spec, you can more explicitly "
"control the repr of module objects."
msgstr ""
"デフォルトでは、すべてのモジュールは利用可能な repr を持っています。ただしこ"
"れは、これまでに説明した属性の設定内容に依存しており、モジュール仕様によって"
"モジュールオブジェクトの repr をより明示的に制御することができます。"

#: ../../reference/import.rst:658
msgid ""
"If the module has a spec (``__spec__``), the import machinery will try to "
"generate a repr from it.  If that fails or there is no spec, the import "
"system will craft a default repr using whatever information is available on "
"the module.  It will try to use the ``module.__name__``, ``module."
"__file__``, and ``module.__loader__`` as input into the repr, with defaults "
"for whatever information is missing."
msgstr ""
"もしモジュールが仕様 (``__spec__``) を持っていれば、インポート機構はそこから "
"repr を生成しようとします。もしそれが失敗するか、または仕様が存在しなければ、"
"インポートシステムはモジュールで入手可能なあらゆる情報を使ってデフォルトの "
"repr を構築します。それは ``module.__name__``, ``module.__file__``, ``module."
"__loader__`` を (足りない情報についてはデフォルト値を使って補いながら) repr "
"への入力として使おうと試みます。"

#: ../../reference/import.rst:665
msgid "Here are the exact rules used:"
msgstr "これが使われている正確な規則です:"

#: ../../reference/import.rst:667
msgid ""
"If the module has a ``__spec__`` attribute, the information in the spec is "
"used to generate the repr.  The \"name\", \"loader\", \"origin\", and "
"\"has_location\" attributes are consulted."
msgstr ""
"モジュールが ``__spec__`` 属性を持っていれば、仕様に含まれる情報が repr を生"
"成するために使われます。 \"name\", \"loader\", \"origin\", \"has_location\" "
"属性が参照されます。"

#: ../../reference/import.rst:671
msgid ""
"If the module has a ``__file__`` attribute, this is used as part of the "
"module's repr."
msgstr ""
"モジュールに ``__file__`` 属性がある場合は、モジュールの repr の一部として使"
"われます。"

#: ../../reference/import.rst:674
msgid ""
"If the module has no ``__file__`` but does have a ``__loader__`` that is not "
"``None``, then the loader's repr is used as part of the module's repr."
msgstr ""
"モジュールに ``__file__`` はないが ``__loader__`` があり、その値が ``None`` "
"ではない場合は、ローダーの repr がモジュールの repr の一部として使われます。"

#: ../../reference/import.rst:677
msgid "Otherwise, just use the module's ``__name__`` in the repr."
msgstr "そうでなければ、単にモジュールの ``__name__`` を repr の中で使います。"

#: ../../reference/import.rst:679
msgid ""
"Use of :meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` has "
"been deprecated and the module spec is now used by the import machinery to "
"generate a module repr."
msgstr ""
":meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` の使用は非推"
"奨 (deprecated) です。インポート機構によりモジュール仕様がモジュール repr を"
"生成するために使用されるようになりました。"

#: ../../reference/import.rst:684
msgid ""
"For backward compatibility with Python 3.3, the module repr will be "
"generated by calling the loader's :meth:`~importlib.abc.Loader.module_repr` "
"method, if defined, before trying either approach described above.  However, "
"the method is deprecated."
msgstr ""
"Python 3.3 との後方互換性のために、ローダーの :meth:`~importlib.abc.Loader."
"module_repr` メソッドが定義されていたら、モジュール repr を生成するために上記"
"のいずれかのアプローチを試す前にそのメソッドが呼ばれます。ただし、このメソッ"
"ドは deprecated です。"

#: ../../reference/import.rst:691
msgid ""
"Calling :meth:`~importlib.abc.Loader.module_repr` now occurs after trying to "
"use a module's ``__spec__`` attribute but before falling back on "
"``__file__``. Use of :meth:`~importlib.abc.Loader.module_repr` is slated to "
"stop in Python 3.12."
msgstr ""
":meth:`~importlib.abc.Loader.module_repr` の呼び出しは、モジュールの "
"``__spec__`` 属性のアクセスに失敗した後、かつ、``__file__`` 属性を試す前のタ"
"イミングで行われるようになりました。Python 3.12 では :meth:`~importlib.abc."
"Loader.module_repr` は使用されなくなる予定です。"

#: ../../reference/import.rst:699
msgid "Cached bytecode invalidation"
msgstr "キャッシュされたバイトコードの無効化"

#: ../../reference/import.rst:701
msgid ""
"Before Python loads cached bytecode from a ``.pyc`` file, it checks whether "
"the cache is up-to-date with the source ``.py`` file. By default, Python "
"does this by storing the source's last-modified timestamp and size in the "
"cache file when writing it. At runtime, the import system then validates the "
"cache file by checking the stored metadata in the cache file against the "
"source's metadata."
msgstr ""

#: ../../reference/import.rst:708
msgid ""
"Python also supports \"hash-based\" cache files, which store a hash of the "
"source file's contents rather than its metadata. There are two variants of "
"hash-based ``.pyc`` files: checked and unchecked. For checked hash-based ``."
"pyc`` files, Python validates the cache file by hashing the source file and "
"comparing the resulting hash with the hash in the cache file. If a checked "
"hash-based cache file is found to be invalid, Python regenerates it and "
"writes a new checked hash-based cache file. For unchecked hash-based ``."
"pyc`` files, Python simply assumes the cache file is valid if it exists. "
"Hash-based ``.pyc`` files validation behavior may be overridden with the :"
"option:`--check-hash-based-pycs` flag."
msgstr ""

#: ../../reference/import.rst:719
msgid ""
"Added hash-based ``.pyc`` files. Previously, Python only supported timestamp-"
"based invalidation of bytecode caches."
msgstr ""

#: ../../reference/import.rst:725
msgid "The Path Based Finder"
msgstr "パスベース・ファインダー"

#: ../../reference/import.rst:730
msgid ""
"As mentioned previously, Python comes with several default meta path "
"finders. One of these, called the :term:`path based finder` (:class:"
"`~importlib.machinery.PathFinder`), searches an :term:`import path`, which "
"contains a list of :term:`path entries <path entry>`.  Each path entry names "
"a location to search for modules."
msgstr ""
"上で触れた通り、 Python にはいくつかのデフォルトのメタパス・ファインダーが備"
"わっています。そのうちの 1 つは :term:`パスベース・ファインダー <path based "
"finder>` (:class:`~importlib.machinery.PathFinder`) と呼ばれ、 :term:`パスエ"
"ントリ <path entry>` のリストである :term:`インポートパス <import path>` を検"
"索します。それぞれのパスエントリは、モジュールを探す場所を指しています。"

#: ../../reference/import.rst:736
msgid ""
"The path based finder itself doesn't know how to import anything. Instead, "
"it traverses the individual path entries, associating each of them with a "
"path entry finder that knows how to handle that particular kind of path."
msgstr ""
"パスベース・ファインダー自体は何かのインポート方法を知っているわけではありま"
"せん。その代わりに、個々のパスエントリを走査し、それぞれに特定の種類のパスの"
"扱いを知っているパスエントリ・ファインダーを関連付けます。"

#: ../../reference/import.rst:740
msgid ""
"The default set of path entry finders implement all the semantics for "
"finding modules on the file system, handling special file types such as "
"Python source code (``.py`` files), Python byte code (``.pyc`` files) and "
"shared libraries (e.g. ``.so`` files). When supported by the :mod:"
"`zipimport` module in the standard library, the default path entry finders "
"also handle loading all of these file types (other than shared libraries) "
"from zipfiles."
msgstr ""
"デフォルトのパスエントリ・ファインダーは、ファイルシステム上のモジュールを見"
"つけるためのすべてのセマンティクスを実装しています。それは Python ソースコー"
"ド (``.py`` ファイル) 、Python バイトコード (``.pyc`` ファイル) 、共有ライブ"
"ラリ (例えば ``.so`` ファイル) などの特別なファイルタイプを処理します。標準ラ"
"イブラリの :mod:`zipimport` モジュールによってサポートされる場合は、デフォル"
"トのパスエントリ・ファインダーは (共有ライブラリ以外の) すべてのファイルタイ"
"プの zip ファイルからのロードも扱います。"

#: ../../reference/import.rst:747
msgid ""
"Path entries need not be limited to file system locations.  They can refer "
"to URLs, database queries, or any other location that can be specified as a "
"string."
msgstr ""
"パスエントリはファイルシステム上の場所に限定される必要はありません。URL や"
"データベースクエリやその他文字列で指定できる場所を参照することも可能です。"

#: ../../reference/import.rst:751
msgid ""
"The path based finder provides additional hooks and protocols so that you "
"can extend and customize the types of searchable path entries.  For example, "
"if you wanted to support path entries as network URLs, you could write a "
"hook that implements HTTP semantics to find modules on the web.  This hook "
"(a callable) would return a :term:`path entry finder` supporting the "
"protocol described below, which was then used to get a loader for the module "
"from the web."
msgstr ""
"パスベース・ファインダーにはフックやプロトコルを追加することができ、それに"
"よって検索可能なパスエントリの種類を拡張し、カスタマイズすることができます。"
"例えば、ネットワーク上の URL をパスエントリとしてサポートしたい場合、 web 上"
"のモジュールを見つけるために HTTP の取り扱い方を実装したフックを書くことがで"
"きます。この (呼び出し可能オブジェクトである) フックは、下で解説するプロトコ"
"ルをサポートする :term:`パスエントリ・ファインダー <path entry finder>` を返"
"します。このプロトコルは  web からモジュールのローダーを取得するのに使われま"
"す。"

#: ../../reference/import.rst:759
msgid ""
"A word of warning: this section and the previous both use the term *finder*, "
"distinguishing between them by using the terms :term:`meta path finder` and :"
"term:`path entry finder`.  These two types of finders are very similar, "
"support similar protocols, and function in similar ways during the import "
"process, but it's important to keep in mind that they are subtly different. "
"In particular, meta path finders operate at the beginning of the import "
"process, as keyed off the :data:`sys.meta_path` traversal."
msgstr ""
"警告の言葉: この節と前の節の両方で *ファインダー* という言葉が、 :term:`メタ"
"パス・ファインダー <meta path finder>` と :term:`パスエントリ・ファインダー "
"<path entry finder>` という用語で区別されて使われています。これら 2 種類の"
"ファインダーは非常に似ており、似たプロトコルをサポートし、インポート処理で同"
"じように機能しますが、微妙に異なっているのを心に留めておくのは重要です。特"
"に、メタパス・ファインダーはインポート処理の開始時、 :data:`sys.meta_path` の"
"走査が動くときに動作します。"

#: ../../reference/import.rst:767
msgid ""
"By contrast, path entry finders are in a sense an implementation detail of "
"the path based finder, and in fact, if the path based finder were to be "
"removed from :data:`sys.meta_path`, none of the path entry finder semantics "
"would be invoked."
msgstr ""
"それとは対照的に、パスエントリ・ファインダーはある意味でパスベース・ファイン"
"ダーの実装詳細であり、実際 :data:`sys.meta_path` からパスベース・ファインダー"
"が取り除かれた場合、パスエントリ・ファインダーの実装は何も実行されないでしょ"
"う。"

#: ../../reference/import.rst:774
msgid "Path entry finders"
msgstr "パスエントリ・ファインダー"

#: ../../reference/import.rst:782
msgid ""
"The :term:`path based finder` is responsible for finding and loading Python "
"modules and packages whose location is specified with a string :term:`path "
"entry`.  Most path entries name locations in the file system, but they need "
"not be limited to this."
msgstr ""
":term:`パスベース・ファインダー <path based finder>` には、文字列 :term:`パス"
"エントリ <path entry>` で指定された場所の Python モジュールや Python パッケー"
"ジを見つけ、ロードする責任があります。ほとんどのパスエントリはファイルシステ"
"ム上の場所を指定していますが、そこに制限される必要はありません。"

#: ../../reference/import.rst:787
msgid ""
"As a meta path finder, the :term:`path based finder` implements the :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` protocol previously described, "
"however it exposes additional hooks that can be used to customize how "
"modules are found and loaded from the :term:`import path`."
msgstr ""
"メタパス・ファインダーとして、 :term:`パスベース・ファインダー <path based "
"finder>` には前に解説した :meth:`~importlib.abc.MetaPathFinder.find_spec` プ"
"ロトコルが実装されていますが、これに加えて :term:`インポートパス <import "
"path>` からモジュールを見つけ、ロードする方法をカスタマイズするために使える"
"フックを提供しています。"

#: ../../reference/import.rst:792
msgid ""
"Three variables are used by the :term:`path based finder`, :data:`sys."
"path`, :data:`sys.path_hooks` and :data:`sys.path_importer_cache`.  The "
"``__path__`` attributes on package objects are also used.  These provide "
"additional ways that the import machinery can be customized."
msgstr ""
":term:`パスベース・ファインダー <path based finder>` は :data:`sys.path` 、 :"
"data:`sys.path_hooks` 、 :data:`sys.path_importer_cache` という 3 つの変数を"
"使います。さらにパッケージオブジェクトの ``__path__`` 属性も使います。これら"
"によって、インポート処理をカスタマイズする方法が提供されます。"

#: ../../reference/import.rst:797
msgid ""
":data:`sys.path` contains a list of strings providing search locations for "
"modules and packages.  It is initialized from the :data:`PYTHONPATH` "
"environment variable and various other installation- and implementation-"
"specific defaults.  Entries in :data:`sys.path` can name directories on the "
"file system, zip files, and potentially other \"locations\" (see the :mod:"
"`site` module) that should be searched for modules, such as URLs, or "
"database queries.  Only strings should be present on :data:`sys.path`; all "
"other data types are ignored."
msgstr ""

#: ../../reference/import.rst:806
msgid ""
"The :term:`path based finder` is a :term:`meta path finder`, so the import "
"machinery begins the :term:`import path` search by calling the path based "
"finder's :meth:`~importlib.machinery.PathFinder.find_spec` method as "
"described previously.  When the ``path`` argument to :meth:`~importlib."
"machinery.PathFinder.find_spec` is given, it will be a list of string paths "
"to traverse - typically a package's ``__path__`` attribute for an import "
"within that package.  If the ``path`` argument is ``None``, this indicates a "
"top level import and :data:`sys.path` is used."
msgstr ""
":term:`パスベース・ファインダー <path based finder>` は :term:`メタパス・ファ"
"インダー <meta path finder>` なので、インポート機構は、前で解説したパスベー"
"ス・ファインダーの :meth:`~importlib.machinery.PathFinder.find_spec`  メソッ"
"ドを呼び出すことで :term:`インポートパス <import path>` の検索を始めます。 "
"``path`` 引数が :meth:`~importlib.machinery.PathFinder.find_spec` に渡された"
"ときは、それは走査するパス文字列のリスト - 典型的にはそのパッケージの中でイン"
"ポートしているパッケージの ``__path__`` 属性になります。 ``path`` 引数が "
"``None`` だった場合、それは最上位のインポートであることを示していて、 :data:"
"`sys.path` が使われます。"

#: ../../reference/import.rst:815
msgid ""
"The path based finder iterates over every entry in the search path, and for "
"each of these, looks for an appropriate :term:`path entry finder` (:class:"
"`~importlib.abc.PathEntryFinder`) for the path entry.  Because this can be "
"an expensive operation (e.g. there may be ``stat()`` call overheads for this "
"search), the path based finder maintains a cache mapping path entries to "
"path entry finders.  This cache is maintained in :data:`sys."
"path_importer_cache` (despite the name, this cache actually stores finder "
"objects rather than being limited to :term:`importer` objects). In this way, "
"the expensive search for a particular :term:`path entry` location's :term:"
"`path entry finder` need only be done once.  User code is free to remove "
"cache entries from :data:`sys.path_importer_cache` forcing the path based "
"finder to perform the path entry search again [#fnpic]_."
msgstr ""

#: ../../reference/import.rst:828
msgid ""
"If the path entry is not present in the cache, the path based finder "
"iterates over every callable in :data:`sys.path_hooks`.  Each of the :term:"
"`path entry hooks <path entry hook>` in this list is called with a single "
"argument, the path entry to be searched.  This callable may either return a :"
"term:`path entry finder` that can handle the path entry, or it may raise :"
"exc:`ImportError`.  An :exc:`ImportError` is used by the path based finder "
"to signal that the hook cannot find a :term:`path entry finder` for that :"
"term:`path entry`.  The exception is ignored and :term:`import path` "
"iteration continues.  The hook should expect either a string or bytes "
"object; the encoding of bytes objects is up to the hook (e.g. it may be a "
"file system encoding, UTF-8, or something else), and if the hook cannot "
"decode the argument, it should raise :exc:`ImportError`."
msgstr ""
"path entry がキャッシュの中に無かった場合、 path based finder は :data:`sys."
"path_hooks` の中の呼び出し可能オブジェクトを全て辿ります。\n"
"このリストのそれぞれの :term:`path entry フック <path entry hook>` は、検索す"
"る path entry という引数 1 つを渡して呼び出されます。\n"
"その呼び出し可能オブジェクトは path entry を扱える :term:`path entry finder` "
"を返すか、  :exc:`ImportError` を送出します。\n"
":exc:`ImportError` は、フックが :term:`path entry` のための :term:`path "
"entry finder` を探せないことを報せるために path based finder が使います。\n"
"この例外は処理されず、 :term:`import path` を辿っていく処理が続けられます。\n"
"フックは引数として文字列またはバイト列オブジェクトを期待します;\n"
"バイト列オブジェクトのエンコーディングはフックに任されていて (例えば、ファイ"
"ルシステムのエンコーディングの UTF-8 やそれ以外などです) 、フックが引数をデ"
"コードできなかった場合は :exc:`ImportError` を送出すべきです。"

#: ../../reference/import.rst:842
msgid ""
"If :data:`sys.path_hooks` iteration ends with no :term:`path entry finder` "
"being returned, then the path based finder's :meth:`~importlib.machinery."
"PathFinder.find_spec` method will store ``None`` in :data:`sys."
"path_importer_cache` (to indicate that there is no finder for this path "
"entry) and return ``None``, indicating that this :term:`meta path finder` "
"could not find the module."
msgstr ""
":data:`sys.path_hooks` を辿る処理が :term:`パスエントリ・ファインダー <path "
"entry finder>` を何も返さずに終わった場合、パスベース・ファインダーの :meth:"
"`~importlib.machinery.PathFinder.find_spec` メソッドは、 :data:`sys."
"path_importer_cache` に (このパスエントリに対するファインダーが存在しないこと"
"を示すために) ``None`` を保存し、 :term:`メタパス・ファインダー <meta path "
"finder>` はモジュールが見つからなかったことを伝えるために ``None`` を返しま"
"す。"

#: ../../reference/import.rst:849
msgid ""
"If a :term:`path entry finder` *is* returned by one of the :term:`path entry "
"hook` callables on :data:`sys.path_hooks`, then the following protocol is "
"used to ask the finder for a module spec, which is then used when loading "
"the module."
msgstr ""
":data:`sys.path_hooks` 上の :term:`パスエントリフック <path entry hook>` 呼び"
"出し可能オブジェクトの戻り値のいずれかが :term:`パスエントリ・ファインダー "
"<path entry finder>` *であった* 場合、後で出てくるモジュール仕様を探すための"
"プロトコルが使われ、それがモジュールをロードするために使われます。"

#: ../../reference/import.rst:854
msgid ""
"The current working directory -- denoted by an empty string -- is handled "
"slightly differently from other entries on :data:`sys.path`. First, if the "
"current working directory is found to not exist, no value is stored in :data:"
"`sys.path_importer_cache`. Second, the value for the current working "
"directory is looked up fresh for each module lookup. Third, the path used "
"for :data:`sys.path_importer_cache` and returned by :meth:`importlib."
"machinery.PathFinder.find_spec` will be the actual current working directory "
"and not the empty string."
msgstr ""
"（空の文字列によって表される）現在のディレクトリは、 :data:`sys.path` の他の"
"エントリとは多少異なる方法で処理されます。まず、現在のディレクトリが存在しな"
"いことが判明した場合、 :data:`sys.path_importer_cache` には何も追加されませ"
"ん。次に、現在のディレクトリに対する値は個々のモジュールのルックアップで毎回"
"新たに検索されます。 3番目に、 :data:`sys.path_importer_cache` に使われ、 :"
"meth:`importlib.machinery.PathFinder.find_spec` が返すパスは、実際のディレク"
"トリであって空の文字列ではありません。"

#: ../../reference/import.rst:864
msgid "Path entry finder protocol"
msgstr "パスエントリ・ファインダー・プロトコル"

#: ../../reference/import.rst:866
msgid ""
"In order to support imports of modules and initialized packages and also to "
"contribute portions to namespace packages, path entry finders must implement "
"the :meth:`~importlib.abc.PathEntryFinder.find_spec` method."
msgstr ""
"モジュールと初期化されたパッケージのインポートをサポートするため、および名前"
"空間パッケージのポーションとして提供するために、パスエントリ・ファインダー"
"は :meth:`~importlib.abc.PathEntryFinder.find_spec`  メソッドを実装しなければ"
"いけません。"

#: ../../reference/import.rst:870
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` takes two arguments: the "
"fully qualified name of the module being imported, and the (optional) target "
"module.  ``find_spec()`` returns a fully populated spec for the module. This "
"spec will always have \"loader\" set (with one exception)."
msgstr ""

#: ../../reference/import.rst:875
msgid ""
"To indicate to the import machinery that the spec represents a namespace :"
"term:`portion`, the path entry finder sets \"submodule_search_locations\" to "
"a list containing the portion."
msgstr ""

#: ../../reference/import.rst:879
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` replaced :meth:`~importlib."
"abc.PathEntryFinder.find_loader` and :meth:`~importlib.abc.PathEntryFinder."
"find_module`, both of which are now deprecated, but will be used if "
"``find_spec()`` is not defined."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` は :meth:`~importlib.abc."
"PathEntryFinder.find_loader` と :meth:`~importlib.abc.PathEntryFinder."
"find_module` を置き換えました。両者は deprecated ですが、 `find_spec()` が定"
"義されていなければ使われます。"

#: ../../reference/import.rst:885
msgid ""
"Older path entry finders may implement one of these two deprecated methods "
"instead of ``find_spec()``.  The methods are still respected for the sake of "
"backward compatibility.  However, if ``find_spec()`` is implemented on the "
"path entry finder, the legacy methods are ignored."
msgstr ""
"古いパスエントリ・ファインダーの中には、 ``find_spec()`` の代わりにこれら 2 "
"つの deperecated なメソッドのうちのいずれかを実装しているものがあるかもしれま"
"せん。これらのメソッドは後方互換性のためにまだ考慮されています。しかし、パス"
"エントリ・ファインダーに ``find_spec()`` が実装されていれば、古いメソッドは無"
"視されます。"

#: ../../reference/import.rst:890
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` takes one argument, the "
"fully qualified name of the module being imported.  ``find_loader()`` "
"returns a 2-tuple where the first item is the loader and the second item is "
"a namespace :term:`portion`."
msgstr ""

#: ../../reference/import.rst:895
msgid ""
"For backwards compatibility with other implementations of the import "
"protocol, many path entry finders also support the same, traditional "
"``find_module()`` method that meta path finders support. However path entry "
"finder ``find_module()`` methods are never called with a ``path`` argument "
"(they are expected to record the appropriate path information from the "
"initial call to the path hook)."
msgstr ""
"他のインポート機構の実装に対する後方互換性のために、多くのパスエントリ・ファ"
"インダーは、メタパス・ファインダーがサポートするのと同じ伝統的な "
"``find_module()``  メソッドもサポートしています。しかし、パスエントリ・ファイ"
"ンダーの ``find_module()``  メソッドは、決して ``path`` 引数では呼び出されま"
"せん (このメソッドは、パスフックの最初の呼び出しから適切なパス情報を記録する"
"動作が期待されています)。"

#: ../../reference/import.rst:902
msgid ""
"The ``find_module()`` method on path entry finders is deprecated, as it does "
"not allow the path entry finder to contribute portions to namespace "
"packages.  If both ``find_loader()`` and ``find_module()`` exist on a path "
"entry finder, the import system will always call ``find_loader()`` in "
"preference to ``find_module()``."
msgstr ""
"パスエントリ・ファインダーの ``find_module()`` メソッドは deprecated です。な"
"ぜなら、その方法ではパスエントリ・ファインダーが名前空間パッケージに対して"
"ポーションを提供することができないからです。もし ``find_loader()`` と "
"``find_module()`` の両方がパスエントリ・ファインダーに存在したら、インポート"
"システムは常に ``find_module()`` よりも ``find_loader()`` を優先して呼び出し"
"ます。"

#: ../../reference/import.rst:908
msgid ""
"Calls to :meth:`~importlib.abc.PathEntryFinder.find_module` and :meth:"
"`~importlib.abc.PathEntryFinder.find_loader` by the import system will "
"raise :exc:`ImportWarning`."
msgstr ""

#: ../../reference/import.rst:915
msgid "Replacing the standard import system"
msgstr "標準のインポートシステムを置き換える"

#: ../../reference/import.rst:917
msgid ""
"The most reliable mechanism for replacing the entire import system is to "
"delete the default contents of :data:`sys.meta_path`, replacing them "
"entirely with a custom meta path hook."
msgstr ""
"インポートシステム全体を置き換えるための最も信頼性のある仕組みは、 :data:"
"`sys.meta_path` のデフォルトの内容を削除し、全部をカスタムのメタパスフックで"
"置き換えるものです。"

#: ../../reference/import.rst:921
msgid ""
"If it is acceptable to only alter the behaviour of import statements without "
"affecting other APIs that access the import system, then replacing the "
"builtin :func:`__import__` function may be sufficient. This technique may "
"also be employed at the module level to only alter the behaviour of import "
"statements within that module."
msgstr ""
"もし、 import 文の動作だけを変更し、インポートシステムにアクセスする他の API "
"には影響を与えなくてもよければ、組み込みの :func:`__import__` 関数を置き換え"
"るだけで十分です。この手法は、ある 1 つのモジュール内だけで import 文の動作を"
"変更するのにも用いられます。"

#: ../../reference/import.rst:927
msgid ""
"To selectively prevent the import of some modules from a hook early on the "
"meta path (rather than disabling the standard import system entirely), it is "
"sufficient to raise :exc:`ModuleNotFoundError` directly from :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` instead of returning ``None``. The "
"latter indicates that the meta path search should continue, while raising an "
"exception terminates it immediately."
msgstr ""

#: ../../reference/import.rst:937
msgid "Package Relative Imports"
msgstr ""

#: ../../reference/import.rst:939
msgid ""
"Relative imports use leading dots. A single leading dot indicates a relative "
"import, starting with the current package. Two or more leading dots indicate "
"a relative import to the parent(s) of the current package, one level per dot "
"after the first. For example, given the following package layout::"
msgstr ""

#: ../../reference/import.rst:955
msgid ""
"In either ``subpackage1/moduleX.py`` or ``subpackage1/__init__.py``, the "
"following are valid relative imports::"
msgstr ""

#: ../../reference/import.rst:965
msgid ""
"Absolute imports may use either the ``import <>`` or ``from <> import <>`` "
"syntax, but relative imports may only use the second form; the reason for "
"this is that::"
msgstr ""

#: ../../reference/import.rst:971
msgid ""
"should expose ``XXX.YYY.ZZZ`` as a usable expression, but .moduleY is not a "
"valid expression."
msgstr ""

#: ../../reference/import.rst:978
msgid "Special considerations for __main__"
msgstr "__main__ に対する特別な考慮"

#: ../../reference/import.rst:980
msgid ""
"The :mod:`__main__` module is a special case relative to Python's import "
"system.  As noted :ref:`elsewhere <programs>`, the ``__main__`` module is "
"directly initialized at interpreter startup, much like :mod:`sys` and :mod:"
"`builtins`.  However, unlike those two, it doesn't strictly qualify as a "
"built-in module.  This is because the manner in which ``__main__`` is "
"initialized depends on the flags and other options with which the "
"interpreter is invoked."
msgstr ""
":mod:`__main__` モジュールは、 Python のインポートシステムに関連する特別な"
"ケースです。 :ref:`他の場所 <programs>` で言及されているように、 "
"``__main__`` モジュールは :mod:`sys` や :mod:`builtins` などと同様にインタプ"
"リタースタートアップで直接初期化されます。しかし、前者 2 つのモジュールと違っ"
"て、 ``__main__`` は厳密にはビルトインのモジュールとしての資格を持っていませ"
"ん。これは、 ``__main__`` が初期化される方法がインタプリタが起動されるときの"
"フラグやその他のオプションに依存するためです。"

#: ../../reference/import.rst:991
msgid "__main__.__spec__"
msgstr "__main__.__spec__"

#: ../../reference/import.rst:993
msgid ""
"Depending on how :mod:`__main__` is initialized, ``__main__.__spec__`` gets "
"set appropriately or to ``None``."
msgstr ""
":mod:`__main__` がどのように初期化されるかに依存して、 ``__main__.__spec__`` "
"は適切に設定されることもあれば ``None`` になることもあります。"

#: ../../reference/import.rst:996
msgid ""
"When Python is started with the :option:`-m` option, ``__spec__`` is set to "
"the module spec of the corresponding module or package. ``__spec__`` is also "
"populated when the ``__main__`` module is loaded as part of executing a "
"directory, zipfile or other :data:`sys.path` entry."
msgstr ""
"Python が :option:`-m` オプションを付けて実行された場合には、 ``__spec__`` は"
"対応するモジュールまたはパッケージのモジュール仕様に設定されます。また、ディ"
"レクトリや zip ファイル、または他の :data:`sys.path` エントリを実行する処理の"
"一部として ``__main__`` モジュールがロードされる場合にも ``__spec__`` が生成 "
"(populate) されます。"

#: ../../reference/import.rst:1001
msgid ""
"In :ref:`the remaining cases <using-on-interface-options>` ``__main__."
"__spec__`` is set to ``None``, as the code used to populate the :mod:"
"`__main__` does not correspond directly with an importable module:"
msgstr ""
":ref:`それ以外のケース <using-on-interface-options>` では、 ``__main__."
"__spec__`` は ``None`` に設定されます。これは、 :mod:`__main__` を生成 "
"(populate) するために使われたコードがインポート可能なモジュールと直接一致して"
"いないためです:"

#: ../../reference/import.rst:1005
msgid "interactive prompt"
msgstr "対話プロンプト"

#: ../../reference/import.rst:1006
msgid ":option:`-c` option"
msgstr ":option:`-c` オプション"

#: ../../reference/import.rst:1007
msgid "running from stdin"
msgstr "stdin から起動された場合"

#: ../../reference/import.rst:1008
msgid "running directly from a source or bytecode file"
msgstr "ソースファイルやバイトコードファイルから直接起動された場合"

#: ../../reference/import.rst:1010
msgid ""
"Note that ``__main__.__spec__`` is always ``None`` in the last case, *even "
"if* the file could technically be imported directly as a module instead. Use "
"the :option:`-m` switch if valid module metadata is desired in :mod:"
"`__main__`."
msgstr ""
"最後のケースでは、たとえ技術的にはファイルがモジュールとして直接インポートで"
"きた *としても* ``__main__.__spec__`` は常に ``None`` になることに注意してく"
"ださい。もし :mod:`__main__` において有効なモジュールメタデータが必要なら :"
"option:`-m` スイッチを使ってください。"

#: ../../reference/import.rst:1015
msgid ""
"Note also that even when ``__main__`` corresponds with an importable module "
"and ``__main__.__spec__`` is set accordingly, they're still considered "
"*distinct* modules. This is due to the fact that blocks guarded by ``if "
"__name__ == \"__main__\":`` checks only execute when the module is used to "
"populate the ``__main__`` namespace, and not during normal import."
msgstr ""
"``__main__`` がインポート可能なモジュールと一致し、 ``__main__.__spec__`` が"
"それに応じて設定されていたとしても、それでもなお、この 2 つのモジュールは別物"
"とみなされることに注意してください。これは、 ``if __name__ == \"__main__\":"
"`` チェックによって保証されるブロックは、 ``__main__`` 名前空間を生成 "
"(populate) するためにモジュールが使用される時にだけ実行され、通常のインポート"
"時には実行されない、という事実に起因しています。"

#: ../../reference/import.rst:1023
msgid "References"
msgstr "参考資料"

#: ../../reference/import.rst:1025
msgid ""
"The import machinery has evolved considerably since Python's early days.  "
"The original `specification for packages <https://www.python.org/doc/essays/"
"packages/>`_ is still available to read, although some details have changed "
"since the writing of that document."
msgstr ""
"Python の初期の頃からすると、インポート機構は目覚ましい発展を遂げました。\n"
"一部細かいところがドキュメントが書かれたときから変わってはいますが、最初期の "
"`パッケージの仕様 <https://www.python.org/doc/essays/packages/>`_ はまだ読む"
"ことができます。"

#: ../../reference/import.rst:1030
msgid ""
"The original specification for :data:`sys.meta_path` was :pep:`302`, with "
"subsequent extension in :pep:`420`."
msgstr ""
"オリジナルの :data:`sys.meta_path` の仕様は :pep:`302` で、その後継となる拡張"
"が :pep:`420` です。"

#: ../../reference/import.rst:1033
msgid ""
":pep:`420` introduced :term:`namespace packages <namespace package>` for "
"Python 3.3.  :pep:`420` also introduced the :meth:`find_loader` protocol as "
"an alternative to :meth:`find_module`."
msgstr ""
":pep:`420` は Python 3.3 に :term:`名前空間パッケージ <namespace package>` を"
"導入しています。 :pep:`420` はまた :meth:`find_module` に代わるものとして :"
"meth:`find_loader` プロトコルを導入しています。"

#: ../../reference/import.rst:1037
msgid ""
":pep:`366` describes the addition of the ``__package__`` attribute for "
"explicit relative imports in main modules."
msgstr ""
":pep:`366` は、メインモジュールでの明示的な相対インポートのために追加した "
"``__package__`` 属性の解説をしています。"

#: ../../reference/import.rst:1040
msgid ""
":pep:`328` introduced absolute and explicit relative imports and initially "
"proposed ``__name__`` for semantics :pep:`366` would eventually specify for "
"``__package__``."
msgstr ""
":pep:`328` は絶対インポート、明示的な相対インポート、および、当初 "
"``__name__`` で提案し、後に :pep:`366` が ``__package__`` で定めた仕様を導入"
"しました。"

#: ../../reference/import.rst:1044
msgid ":pep:`338` defines executing modules as scripts."
msgstr ""
":pep:`338` はモジュールをスクリプトとして実行するときの仕様を定めています。"

#: ../../reference/import.rst:1046
msgid ""
":pep:`451` adds the encapsulation of per-module import state in spec "
"objects.  It also off-loads most of the boilerplate responsibilities of "
"loaders back onto the import machinery.  These changes allow the deprecation "
"of several APIs in the import system and also addition of new methods to "
"finders and loaders."
msgstr ""
":pep:`451` は、モジュール仕様オブジェクトにおけるモジュール毎のインポート状態"
"のカプセル化を追加しています。また、ローダーの定型的な責任のほとんどをイン"
"ポート機構に肩代わりさせています。これらの変更により、インポートシステムのい"
"くつかの API が deprecate され、またファインダーとローダーには新しいメソッド"
"が追加されました。"

#: ../../reference/import.rst:1053
msgid "Footnotes"
msgstr "脚注"

#: ../../reference/import.rst:1054
msgid "See :class:`types.ModuleType`."
msgstr ":class:`types.ModuleType` を参照してください。"

#: ../../reference/import.rst:1056
msgid ""
"The importlib implementation avoids using the return value directly. "
"Instead, it gets the module object by looking the module name up in :data:"
"`sys.modules`.  The indirect effect of this is that an imported module may "
"replace itself in :data:`sys.modules`.  This is implementation-specific "
"behavior that is not guaranteed to work in other Python implementations."
msgstr ""
"importlib の実装は、戻り値を直接使うことは避けています。その代わりに、モ"
"ジュール名を調べて :data:`sys.modules` からモジュールオブジェクトを得ます。こ"
"うすることの間接的な効果は、インポートされたモジュールが :data:`sys.modules` "
"にいる自分自身を置き換えることがあるということです。これは実装依存の動作であ"
"り、他の Python 実装では保証されていない動作です。"

#: ../../reference/import.rst:1063
msgid ""
"In legacy code, it is possible to find instances of :class:`imp."
"NullImporter` in the :data:`sys.path_importer_cache`.  It is recommended "
"that code be changed to use ``None`` instead.  See :ref:`portingpythoncode` "
"for more details."
msgstr ""
"レガシーなコードでは、 :data:`sys.path_importer_cache` に :class:`imp."
"NullImporter` のインスタンスがいることがあります。それの代わりに ``None`` を"
"使うようにコードを変更することが推奨されます。より詳しいことは :ref:"
"`portingpythoncode` を参照してください。"
