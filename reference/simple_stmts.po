# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# E. Kawashima, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2017
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2017
# Arihiro TAKASE, 2017
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-29 09:36+0900\n"
"PO-Revision-Date: 2017-02-16 23:39+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr "å˜ç´”æ–‡ (simple statement)"

#: ../../reference/simple_stmts.rst:10
msgid ""
"A simple statement is comprised within a single logical line. Several simple"
" statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""
"å˜ç´”æ–‡ã¨ã¯ã€å˜ä¸€ã®è«–ç†è¡Œå†…ã«åã‚ã‚‰ã‚Œã‚‹æ–‡ã§ã™ã€‚å˜ä¸€ã®è¡Œå†…ã«ã¯ã€è¤‡æ•°ã®å˜ç´”æ–‡ã‚’ã‚»ãƒŸã‚³ãƒ­ãƒ³ã§åŒºåˆ‡ã£ã¦å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å˜ç´”æ–‡ã®æ§‹æ–‡ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™:"

#: ../../reference/simple_stmts.rst:35
msgid "Expression statements"
msgstr "å¼æ–‡ (expression statement)"

#: ../../reference/simple_stmts.rst:42
msgid ""
"Expression statements are used (mostly interactively) to compute and write a"
" value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""
"å¼æ–‡ã¯ã€(ä¸»ã«å¯¾è©±çš„ãªä½¿ã„æ–¹ã§ã¯) å€¤ã‚’è¨ˆç®—ã—ã¦å‡ºåŠ›ã™ã‚‹ãŸã‚ã«ä½¿ã£ãŸã‚Šã€(é€šå¸¸ã¯) ãƒ—ãƒ­ã‚·ã‚¸ãƒ£ (procedure: "
"æœ‰æ„ãªçµæœã‚’è¿”ã•ãªã„é–¢æ•°ã®ã“ã¨ã§ã™; Python ã§ã¯ã€ãƒ—ãƒ­ã‚·ã‚¸ãƒ£ã¯å€¤ ``None`` ã‚’è¿”ã—ã¾ã™) "
"ã‚’å‘¼ã³å‡ºã™ãŸã‚ã«ä½¿ã„ã¾ã™ã€‚ãã®ä»–ã®ä½¿ã„æ–¹ã§ã‚‚å¼æ–‡ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã—ã€æœ‰ç”¨ãªã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚å¼æ–‡ã®æ§‹æ–‡ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™:"

#: ../../reference/simple_stmts.rst:51
msgid ""
"An expression statement evaluates the expression list (which may be a single"
" expression)."
msgstr "å¼æ–‡ã¯å¼ã®ãƒªã‚¹ãƒˆ (å˜ä¸€ã®å¼ã®ã“ã¨ã‚‚ã‚ã‚Šã¾ã™) ã‚’å€¤è©•ä¾¡ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:63
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""
"å¯¾è©±ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€å€¤ãŒ ``None`` ã§ãªã‘ã‚Œã°ã€å€¤ã‚’çµ„ã¿è¾¼ã¿é–¢æ•° :func:`repr` "
"ã§æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¦ã€ãã®çµæœã®æ–‡å­—åˆ—ã‚’æ¨™æº–å‡ºåŠ›ã«ä¸€è¡Œä½¿ã£ã¦æ›¸ãå‡ºã—ã¾ã™ã€‚ (``None`` "
"ã«ãªã‚‹å¼æ–‡ã®å€¤ã¯æ›¸ãå‡ºã•ã‚Œãªã„ã®ã§ã€ãƒ—ãƒ­ã‚·ã‚¸ãƒ£ã®å‘¼ã³å‡ºã—ã‚’è¡Œã£ã¦ã‚‚å‡ºåŠ›ã¯å¾—ã‚‰ã‚Œã¾ã›ã‚“ã€‚)"

#: ../../reference/simple_stmts.rst:71
msgid "Assignment statements"
msgstr "ä»£å…¥æ–‡ (assignment statement)"

#: ../../reference/simple_stmts.rst:81
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr "ä»£å…¥æ–‡ã¯ã€åå‰ã‚’å€¤ã« (å†) æŸç¸›ã—ãŸã‚Šã€å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§ã‚„è¦ç´ ã‚’å¤‰æ›´ã—ãŸã‚Šã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™:"

#: ../../reference/simple_stmts.rst:95
msgid ""
"(See section :ref:`primaries` for the syntax definitions for *attributeref*,"
" *subscription*, and *slicing*.)"
msgstr ""
"(*attributeref*, *subscription*, *slicing* ã®æ§‹æ–‡ã«ã¤ã„ã¦ã¯ :ref:`primaries` "
"ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚)"

#: ../../reference/simple_stmts.rst:98
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""
"ä»£å…¥æ–‡ã¯å¼ã®ãƒªã‚¹ãƒˆ (ã“ã‚Œã¯å˜ä¸€ã®å¼ã§ã‚‚ã€ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸå¼ãƒªã‚¹ãƒˆã§ã‚‚ã‚ˆãã€å¾Œè€…ã¯ã‚¿ãƒ—ãƒ«ã«ãªã‚‹ã“ã¨ã‚’æ€ã„å‡ºã—ã¦ãã ã•ã„) "
"ã‚’è©•ä¾¡ã—ã€å¾—ã‚‰ã‚ŒãŸå˜ä¸€ã®çµæœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ (target) ã®ãƒªã‚¹ãƒˆã«å¯¾ã—ã¦å·¦ã‹ã‚‰å³ã¸ã¨ä»£å…¥ã—ã¦ã‚†ãã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:107
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""
"ä»£å…¥ã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ (ãƒªã‚¹ãƒˆ) ã®å½¢å¼ã«å¾“ã£ã¦å†å¸°çš„ã«è¡Œã‚ã‚Œã¾ã™ã€‚ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒå¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (å±æ€§å‚ç…§ã€æ·»å­—è¡¨è¨˜ã€ã¾ãŸã¯ã‚¹ãƒ©ã‚¤ã‚¹) "
"ã®ä¸€éƒ¨ã§ã‚ã‚‹å ´åˆã€ã“ã®å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æœ€çµ‚çš„ã«ä»£å…¥ã‚’å®Ÿè¡Œã—ã¦ã€ãã®ä»£å…¥ãŒæœ‰åŠ¹ãªæ“ä½œã§ã‚ã‚‹ã‹åˆ¤æ–­ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä»£å…¥ãŒä¸å¯èƒ½ãªå ´åˆã«ã¯ä¾‹å¤–ã‚’ç™ºè¡Œã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚å‹ã”ã¨ã«ã¿ã‚‰ã‚Œã‚‹è¦å‰‡ã‚„ã€é€å‡ºã•ã‚Œã‚‹ä¾‹å¤–ã¯ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹å®šç¾©ã§ä¸ãˆã‚‰ã‚Œã¦ã„ã¾ã™"
" (:ref:`types` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„)."

#: ../../reference/simple_stmts.rst:120
msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses"
" or square brackets, is recursively defined as follows."
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆã¯ã€ä¸¸æ‹¬å¼§ã‚„è§’æ‹¬å¼§ã§å›²ã¾ã‚Œã¦ã„ã¦ã‚‚ã‚ˆãã€ãã‚Œã«å¯¾ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»£å…¥ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å†å¸°çš„ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:123
msgid ""
"If the target list is empty: The object must also be an empty iterable."
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆãŒç©ºã®å ´åˆ: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ç©ºã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:125
msgid ""
"If the target list is a single target in parentheses: The object is assigned"
" to that target."
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒ1ã¤ã ã‘ã®å ´åˆ: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ä»£å…¥ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:128
msgid ""
"If the target list is a comma-separated list of targets, or a single target "
"in square brackets: The object must be an iterable with the same number of "
"items as there are targets in the target list, and the items are assigned, "
"from left to right, to the corresponding targets."
msgstr ""
"ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆãŒã€ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸè¤‡æ•°ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã€ã‚‚ã—ãã¯è§’æ‹¬å¼§ã§å›²ã¾ã‚ŒãŸå˜ä¸€ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å ´åˆ: "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆä¸­ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ•°ã¨åŒã˜æ•°ã®è¦ç´ ã‹ã‚‰ãªã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ãã®å„è¦ç´ ã¯å·¦ã‹ã‚‰å³ã¸ã¨å¯¾å¿œã™ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ä»£å…¥ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:133
msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be an iterable with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the iterable are assigned, from left to right, to the targets before the "
"starred target.  The final items of the iterable are assigned to the targets"
" after the starred target.  A list of the remaining items in the iterable is"
" then assigned to the starred target (the list can be empty)."
msgstr ""
"\"æ˜Ÿä»˜ã\"ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨å‘¼ã°ã‚Œã‚‹ã€é ­ã«ã‚¢ã‚¹ã‚¿ãƒªã‚¹ã‚¯ãŒä¸€ã¤ä»˜ã„ãŸã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆã«ä¸€ã¤ã ã‘å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆ: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã§ã€å°‘ãªãã¨ã‚‚ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®æ•°ã‚ˆã‚Šã‚‚ä¸€ã¤å°‘ãªã„è¦ç´ ã‚’æŒãŸãªã‘ã‚Œã°ã¯ãªã‚Šã¾ã›ã‚“ã€‚\n"
"æ˜Ÿä»˜ãã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚ˆã‚Šå‰ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã€ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã®å…ˆé ­ã®è¦ç´ ãŒå·¦ã‹ã‚‰å³ã¸ä»£å…¥ã•ã‚Œã¾ã™ã€‚\n"
"æ˜Ÿä»˜ãã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚ˆã‚Šå¾Œã‚ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã€ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã®æœ«å°¾ã®è¦ç´ ãŒä»£å…¥ã•ã‚Œã¾ã™ã€‚\n"
"æ˜Ÿä»˜ãã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã€ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã®æ®‹ã£ãŸè¦ç´ ã®ãƒªã‚¹ãƒˆãŒä»£å…¥ã•ã‚Œã¾ã™ (ãƒªã‚¹ãƒˆç©ºã§ã‚‚ã‹ã¾ã„ã¾ã›ã‚“)ã€‚"

#: ../../reference/simple_stmts.rst:141
msgid ""
"Else: The object must be an iterable with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr ""
"ãã†ã§ãªã„å ´åˆ: "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨åŒã˜æ•°ã®è¦ç´ ã‚’æŒã¤ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€è¦ç´ ã¯å·¦ã‹ã‚‰å³ã¸å¯¾å¿œã™ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ä»£å…¥ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:145
msgid ""
"Assignment of an object to a single target is recursively defined as "
"follows."
msgstr "å˜ä¸€ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸ã®å˜ä¸€ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»£å…¥ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦å†å¸°çš„ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:147
msgid "If the target is an identifier (name):"
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒè­˜åˆ¥å­ (åå‰) ã®å ´åˆ:"

#: ../../reference/simple_stmts.rst:149
msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""
"åå‰ãŒç¾åœ¨ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å†…ã® :keyword:`global` ã‚„ :keyword:`nonlocal` æ–‡ã«æ›¸ã‹ã‚Œã¦ã„ãªã„ã‘ã‚Œã°: "
"åå‰ã¯ç¾åœ¨ã®ãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“å†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æŸç¸›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:153
msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""
"ãã†ã§ãªã‘ã‚Œã°: åå‰ã¯ãã‚Œãã‚Œã‚°ãƒ­ãƒ¼ãƒãƒ«åå‰ç©ºé–“å†…ã‹ã€ :keyword:`nonlocal` "
"ã§æ±ºã‚ã‚‰ã‚ŒãŸå¤–å´ã®åå‰ç©ºé–“å†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æŸç¸›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:158
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the"
" object to be deallocated and its destructor (if it has one) to be called."
msgstr ""
"åå‰ãŒã™ã§ã«æŸç¸›æ¸ˆã¿ã®å ´åˆã€å†æŸç¸› (rebind) ãŒãŠã“ãªã‚ã‚Œã¾ã™ã€‚å†æŸç¸›ã«ã‚ˆã£ã¦ã€ä»¥å‰ãã®åå‰ã«æŸç¸›ã•ã‚Œã¦ã„ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ "
"(reference count) ãŒã‚¼ãƒ­ã«ãªã£ãŸå ´åˆã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è§£æ”¾ (deallocate) ã•ã‚Œã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿  (destructor) ãŒ"
" (å­˜åœ¨ã™ã‚Œã°) å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:164
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not"
" necessarily :exc:`AttributeError`)."
msgstr ""
"ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒå±æ€§å‚ç…§ã®å ´åˆ: å‚ç…§ã•ã‚Œã¦ã„ã‚‹ä¸€æ¬¡èªã®å¼ãŒå€¤è©•ä¾¡ã•ã‚Œã¾ã™ã€‚å€¤ã¯ä»£å…¥å¯èƒ½ãªå±æ€§ã‚’ä¼´ã†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; ãã†ã§ãªã‘ã‚Œã°ã€ "
":exc:`TypeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚æ¬¡ã«ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã€è¢«ä»£å…¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã—ãŸå±æ€§ã«ä»£å…¥ã—ã¦ã‚ˆã„ã‹å•ã„åˆã‚ã›ã¾ã™; "
"ä»£å…¥ã‚’å®Ÿè¡Œã§ããªã„å ´åˆã€ä¾‹å¤– (é€šå¸¸ã¯ :exc:`AttributeError` ã§ã™ãŒã€å¿…ç„¶ã§ã¯ã‚ã‚Šã¾ã›ã‚“) ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:173
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the RHS expression, ``a.x`` can "
"access either an instance attribute or (if no instance attribute exists) a "
"class attribute.  The LHS target ``a.x`` is always set as an instance "
"attribute, creating it if necessary.  Thus, the two occurrences of ``a.x`` "
"do not necessarily refer to the same attribute: if the RHS expression refers"
" to a class attribute, the LHS creates a new instance attribute as the "
"target of the assignment::"
msgstr ""
"æ³¨æ„: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã€ä»£å…¥æ¼”ç®—å­ã®ä¸¡è¾ºã«å±æ€§å‚ç…§ãŒã‚ã‚‹ã¨ãã€å³è¾ºå¼ã® ``a.x`` ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ã¨ "
"(ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ãŒå­˜åœ¨ã—ãªã‘ã‚Œã°) ã‚¯ãƒ©ã‚¹å±æ€§ã®ã©ã¡ã‚‰ã«ã‚‚ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚å·¦è¾ºã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ ``a.x`` "
"ã¯å¸¸ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ã¨ã—ã¦å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã€å¿…è¦ãªã‚‰ã°ç”Ÿæˆã•ã‚Œã¾ã™ã€‚ã“ã®ã¨ãŠã‚Šã€ç¾ã‚Œã‚‹äºŒã¤ã® ``a.x`` ã¯åŒã˜å€¤ã‚’å‚ç…§ã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“: "
"å³è¾ºå¼ã¯ã‚¯ãƒ©ã‚¹å±æ€§ã‚’å‚ç…§ã—ã€å·¦è¾ºã¯æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã‚’ä»£å…¥ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦ç”Ÿæˆã™ã‚‹ã‚ˆã†ãªã¨ã::"

#: ../../reference/simple_stmts.rst:187
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""
"ã“ã®ã“ã¨ã¯ã€ :func:`property` ã§ä½œæˆã•ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ã‚ˆã†ãªãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿å±æ€§ã«å¯¾ã—ã¦ã¯ã€å¿…ãšã—ã‚‚ã‚ã¦ã¯ã¾ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:194
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""
"ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒæ·»å­—è¡¨è¨˜ãªã‚‰: å‚ç…§ã•ã‚Œã¦ã„ã‚‹ä¸€æ¬¡èªå¼ãŒè©•ä¾¡ã•ã‚Œã¾ã™ã€‚å‚ç…§ã‹ã‚‰ (ãƒªã‚¹ãƒˆã®ã‚ˆã†ãª) ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã€(è¾æ›¸ã®ã‚ˆã†ãª)"
" ãƒãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¾—ã‚‰ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æ¬¡ã«ã€æ·»å­—è¡¨è¨˜ã®è¡¨ã™å¼ãŒè©•ä¾¡ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:203
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to"
" it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, "
":exc:`IndexError` is raised (assignment to a subscripted sequence cannot add"
" new items to a list)."
msgstr ""
"ä¸€æ¬¡èªãŒ (ãƒªã‚¹ãƒˆã®ã‚ˆã†ãª) "
"ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚Œã°ã€æ·»å­—è¡¨è¨˜ã¯æ•´æ•°ã‚’ä¸ãˆãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æ•´æ•°ãŒè² ãªã‚‰ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒåŠ ç®—ã•ã‚Œã¾ã™ã€‚æ•´æ•°ã¯æœ€çµ‚çš„ã«ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã‚ˆã‚Šã‚‚å°ã•ãªéè² ã®æ•´æ•°ã§ãªãã¦ã¯ãªã‚‰ãšã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€ãã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã«æŒã¤è¦ç´ ã«è¢«ä»£å…¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»£å…¥ã—ã¦ã‚ˆã„ã‹å•ã„åˆã‚ã›ã‚‰ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ãŒç¯„å›²å¤–ãªã‚‰ã€"
" :exc:`IndexError` ãŒé€å‡ºã•ã‚Œã¾ã™ (æ·»å­—æŒ‡å®šã•ã‚ŒãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ä»£å…¥ã‚’è¡Œã£ã¦ã‚‚ã€ãƒªã‚¹ãƒˆè¦ç´ ã®æ–°ãŸãªè¿½åŠ ã¯ã§ãã¾ã›ã‚“)ã€‚"

#: ../../reference/simple_stmts.rst:214
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""
"ä¸€æ¬¡èªãŒ (è¾æ›¸ã®ã‚ˆã†ãª) "
"ãƒãƒƒãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€ã¾ãšæ·»å­—ã¯ãƒãƒƒãƒ—ã®ã‚­ãƒ¼å‹ã¨äº’æ›æ€§ã®ã‚ã‚‹å‹ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚æ¬¡ã«ã€æ·»å­—ã‚’è¢«ä»£å…¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«é–¢é€£ä»˜ã‘ã‚‹ã‚ˆã†ãªã‚­ãƒ¼/ãƒ‡ãƒ¼ã‚¿ã®å¯¾ã‚’ç”Ÿæˆã™ã‚‹ã‚ˆã†ãƒãƒƒãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å•ã„åˆã‚ã›ã¾ã™ã€‚ã“ã®æ“ä½œã§ã¯ã€æ—¢å­˜ã®ã‚­ãƒ¼/å€¤ã®å¯¾ã‚’åŒã˜ã‚­ãƒ¼ã¨åˆ¥ã®å€¤ã§ç½®ãæ›ãˆã¦ã‚‚ã‚ˆãã€(åŒã˜å€¤ã‚’æŒã¤ã‚­ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆ)"
" æ–°ãŸãªã‚­ãƒ¼/å€¤ã®å¯¾ã‚’æŒ¿å…¥ã—ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:220
msgid ""
"For user-defined objects, the :meth:`__setitem__` method is called with "
"appropriate arguments."
msgstr "ãƒ¦ãƒ¼ã‚¶å®šç¾©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€é©åˆ‡ãªå¼•æ•°ã§ :meth:`__setitem__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:225
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The"
" assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"integers. If either bound is negative, the sequence's length is added to it."
"  The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the target sequence allows it."
msgstr ""
"ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒã‚¹ãƒ©ã‚¤ã‚¹ãªã‚‰: å‚ç…§ã•ã‚Œã¦ã„ã‚‹ä¸€æ¬¡èªå¼ãŒè©•ä¾¡ã•ã‚Œã¾ã™ã€‚ä¸€æ¬¡èªå¼ã¯ã€(ãƒªã‚¹ãƒˆã®ã‚ˆã†ãª) "
"ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¸ãˆãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚è¢«ä»£å…¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯åŒã˜å‹ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æ¬¡ã«ã€ã‚¹ãƒ©ã‚¤ã‚¹ã®ä¸‹é™ã¨ä¸Šé™ã‚’ç¤ºã™å¼ãŒã‚ã‚Œã°è©•ä¾¡ã•ã‚Œã¾ã™;"
" ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ãã‚Œãã‚Œ 0 "
"ã¨ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã§ã™ã€‚ä¸Šé™ã¨ä¸‹é™ã®è©•ä¾¡ã¯æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã„ãšã‚Œã‹ã®å¢ƒç•ŒãŒè² æ•°ãªã‚‰ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒåŠ ç®—ã•ã‚Œã¾ã™ã€‚æœ€çµ‚çš„ã«ã€å¢ƒç•Œã¯ 0 "
"ã‹ã‚‰ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã¾ã§ã«åã¾ã‚‹ã‚ˆã†ã«åˆˆã‚Šã“ã¾ã‚Œã¾ã™ã€‚æœ€å¾Œã«ã€ã‚¹ãƒ©ã‚¤ã‚¹ã‚’è¢«ä»£å…¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ç½®ãæ›ãˆã¦ã‚ˆã„ã‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å•ã„åˆã‚ã›ã¾ã™ã€‚ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§è¨±ã•ã‚Œã¦ã„ã‚‹é™ã‚Šã€ã‚¹ãƒ©ã‚¤ã‚¹ã®é•·ã•ã¯è¢«ä»£å…¥ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã¨ç•°ãªã£ã¦ã„ã¦ã‚ˆãã€ã“ã®å ´åˆã«ã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒå¤‰æ›´ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:239
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""
"ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®æ§‹æ–‡ã¯å¼ã®æ§‹æ–‡ã¨åŒã˜ã§ã‚ã‚‹ã¨ã¿ãªã•ã‚Œã¦ãŠã‚Šã€ç„¡åŠ¹ãªæ§‹æ–‡ã¯ã‚³ãƒ¼ãƒ‰ç”Ÿæˆãƒ•ã‚§ãƒ¼ã‚ºä¸­ã«è©³ç´°ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä¼´ã£ã¦æ‹’å¦ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:243
msgid ""
"Although the definition of assignment implies that overlaps between the "
"left-hand side and the right-hand side are 'simultaneous' (for example ``a, "
"b = b, a`` swaps two variables), overlaps *within* the collection of "
"assigned-to variables occur left-to-right, sometimes resulting in confusion."
"  For instance, the following program prints ``[0, 2]``::"
msgstr ""
"ä»£å…¥ã®å®šç¾©ã«ã‚ˆã‚Œã°ã€å·¦è¾ºã¨å³è¾ºã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒƒãƒ—ã¯ 'åŒæ™‚ (simultaneous)' ã§ã™ (ä¾‹ãˆã° ``a, b = b, a`` "
"ã¯äºŒã¤ã®å¤‰æ•°ã‚’å…¥ã‚Œæ›¿ãˆã¾ã™) ãŒã€ä»£å…¥å¯¾è±¡ã¨ãªã‚‹å¤‰æ•°ç¾¤ *ã©ã†ã—* ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒƒãƒ—ã¯å·¦ã‹ã‚‰å³ã¸èµ·ã“ã‚Šã€æ··ä¹±ã®å…ƒã§ã™ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ "
"``[0, 2]`` ã‚’å‡ºåŠ›ã—ã¦ã—ã¾ã„ã¾ã™::"

#: ../../reference/simple_stmts.rst:257
msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ":pep:`3132` - Extended Iterable Unpacking"

#: ../../reference/simple_stmts.rst:258
msgid "The specification for the ``*target`` feature."
msgstr "``*target`` ã®æŒ‡å®šæ©Ÿèƒ½ã€‚"

#: ../../reference/simple_stmts.rst:264
msgid "Augmented assignment statements"
msgstr "ç´¯ç®—ä»£å…¥æ–‡ (augmented assignment statement)"

#: ../../reference/simple_stmts.rst:282
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr "ç´¯ç®—ä»£å…¥æ–‡ã¯ã€äºŒé …æ¼”ç®—ã¨ä»£å…¥æ–‡ã‚’çµ„ã¿åˆã‚ã›ã¦ä¸€ã¤ã®æ–‡ã«ã—ãŸã‚‚ã®ã§ã™:"

#: ../../reference/simple_stmts.rst:291
msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last three "
"symbols.)"
msgstr "(æœ€å¾Œã®3ã¤ã®æ§‹æ–‡å®šç¾©ã«ã¤ã„ã¦ã¯ :ref:`primaries` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚)"

#: ../../reference/simple_stmts.rst:294
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only"
" evaluated once."
msgstr ""
"ç´¯ç®—ä»£å…¥æ–‡ã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ (é€šå¸¸ã®ä»£å…¥æ–‡ã¨é•ã£ã¦ã€ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ã¯èµ·ã“ã‚Šã¾ã›ã‚“) "
"ã¨å¼ãƒªã‚¹ãƒˆã‚’è©•ä¾¡ã—ã€ãã‚Œã‚‰äºŒã¤ã®è¢«æ¼”ç®—å­é–“ã§ç‰¹å®šã®ç´¯ç®—ä»£å…¥å‹ã®äºŒé …æ¼”ç®—ã‚’è¡Œã„ã€çµæœã‚’ã‚‚ã¨ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ä»£å…¥ã—ã¾ã™ã€‚ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¯ä¸€åº¦ã—ã‹è©•ä¾¡ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:299
msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as ``x ="
" x + 1`` to achieve a similar, but not exactly equal effect. In the "
"augmented version, ``x`` is only evaluated once. Also, when possible, the "
"actual operation is performed *in-place*, meaning that rather than creating "
"a new object and assigning that to the target, the old object is modified "
"instead."
msgstr ""
"``x += 1`` ã®ã‚ˆã†ãªç´¯ç®—ä»£å…¥å¼ã¯ã€ ``x = x + 1`` "
"ã®ã‚ˆã†ã«æ›¸ãæ›ãˆã¦ã»ã¼åŒæ§˜ã®å‹•ä½œã«ã§ãã¾ã™ãŒã€å³å¯†ã«ç­‰ä¾¡ã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚ç´¯ç®—ä»£å…¥ã®æ–¹ã§ã¯ã€ ``x`` "
"ã¯ä¸€åº¦ã—ã‹è©•ä¾¡ã•ã‚Œã¾ã›ã‚“ã€‚ã¾ãŸã€å®Ÿéš›ã®å‡¦ç†ã¨ã—ã¦ã€å¯èƒ½ãªã‚‰ã° *ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ (in-place)* "
"æ¼”ç®—ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ä»£å…¥æ™‚ã«æ–°ãŸãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¦ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ä»£å…¥ã™ã‚‹ã®ã§ã¯ãªãã€ä»¥å‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…å®¹ã‚’å¤‰æ›´ã™ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:305
msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand side"
" *before* evaluating the right-hand side.  For example, ``a[i] += f(x)`` "
"first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs the "
"addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""
"é€šå¸¸ã®ä»£å…¥ã¨ã¯é•ã„ã€ç´¯ç®—ä»£å…¥æ–‡ã¯å³è¾ºã‚’è©•ä¾¡ã™ã‚‹*å‰ã«*å·¦è¾ºã‚’è©•ä¾¡ã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€``a[i] += f(x)`` ã¯ã¾ãš ``a[i]`` "
"ã‚’èª¿ã¹ã€``f(x)`` ã‚’è©•ä¾¡ã—ã¦åŠ ç®—ã‚’è¡Œã„ã€æœ€å¾Œã«çµæœã‚’ ``a[i]`` ã«å‰²ã‚Šå½“ã¦ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:310
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled"
" the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""
"ç´¯ç®—ä»£å…¥æ–‡ã§è¡Œã‚ã‚Œã‚‹ä»£å…¥ã¯ã€ã‚¿ãƒ—ãƒ«ã¸ã®ä»£å…¥ã‚„ã€ä¸€æ–‡ä¸­ã«è¤‡æ•°ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒå­˜åœ¨ã™ã‚‹å ´åˆã‚’é™¤ãã€é€šå¸¸ã®ä»£å…¥ã¨åŒã˜ã‚ˆã†ã«æ‰±ã‚ã‚Œã¾ã™ã€‚åŒæ§˜ã«ã€ç´¯ç®—ä»£å…¥ã§è¡Œã‚ã‚Œã‚‹äºŒé …æ¼”ç®—ã¯ã€å ´åˆã«ã‚ˆã£ã¦"
" *ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹æ¼”ç®—* ãŒè¡Œã‚ã‚Œã‚‹ã“ã¨ã‚’é™¤ãã€é€šå¸¸ã®äºŒé …æ¼”ç®—ã¨åŒã˜ã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:316
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""
"å±æ€§å‚ç…§ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å ´åˆã€ :ref:`ã‚¯ãƒ©ã‚¹å±æ€§ã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã«ã¤ã„ã¦ã®æ³¨æ„ <attr-target-note>` "
"ã¨åŒæ§˜ã«é€šå¸¸ã®ä»£å…¥ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:323
msgid "Annotated assignment statements"
msgstr "æ³¨é‡ˆä»˜ãä»£å…¥æ–‡ (annotated assignment statements)"

#: ../../reference/simple_stmts.rst:330
msgid ""
"Annotation assignment is the combination, in a single statement, of a "
"variable or attribute annotation and an optional assignment statement:"
msgstr "æ³¨é‡ˆä»£å…¥ã¯ã€1 ã¤ã®æ–‡ã®ä¸­ã§ã€å¤‰æ•°ã‚„å±æ€§ã®ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ä»£å…¥æ–‡ã‚’çµ„ã¿åˆã‚ã›ãŸã‚‚ã®ã§ã™:"

#: ../../reference/simple_stmts.rst:336
msgid ""
"The difference from normal :ref:`assignment` is that only single target and "
"only single right hand side value is allowed."
msgstr ":ref:`assignment` ã¨ã®é•ã„ã¯ã€ä»£å…¥å…ˆãŒ 1 ã¤ã«é™å®šã•ã‚Œå³è¾ºã®å€¤ã‚‚ 1 ã¤ã«é™å®šã•ã‚Œã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:339
msgid ""
"For simple names as assignment targets, if in class or module scope, the "
"annotations are evaluated and stored in a special class or module attribute "
":attr:`__annotations__` that is a dictionary mapping from variable names "
"(mangled if private) to evaluated annotations. This attribute is writable "
"and is automatically created at the start of class or module body execution,"
" if annotations are found statically."
msgstr ""
"ä»£å…¥å…ˆã¨ã—ã¦å˜ç´”åã‚’ä½¿ã†ã¨ã€ã‚¯ãƒ©ã‚¹ã‚¹ã‚³ãƒ¼ãƒ—ã‚‚ã—ãã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®å ´åˆã€æ³¨é‡ˆã¯è©•ä¾¡ã•ã‚Œã€ã‚¯ãƒ©ã‚¹ã‚‚ã—ãã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ç‰¹æ®Šå±æ€§ :attr:`__annotations__` ã«æ ¼ç´ã•ã‚Œã¾ã™ã€‚\n"
"ã“ã®å±æ€§ã¯ã€å¤‰æ•°å (ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆå¤‰æ•°ã®å ´åˆã¯ãƒãƒ³ã‚°ãƒªãƒ³ã‚°ã•ã‚ŒãŸåå‰) ã‹ã‚‰è©•ä¾¡å¾Œã®æ³¨é‡ˆã¸ã®å¯¾å¿œä»˜ã‘ã‚’æŒã¤è¾æ›¸ã§ã™ã€‚\n"
"ã“ã®å±æ€§ã¯æ›¸ãè¾¼ã¿å¯èƒ½ã§ã‚ã‚Šã€æ³¨é‡ˆãŒé™çš„ã«å­˜åœ¨ã—ã¦ã„ã‚‹å ´åˆã€ã‚¯ãƒ©ã‚¹ã‚‚ã—ãã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æœ¬ä½“ã®å®Ÿè¡Œã®å…ˆé ­ã§è‡ªå‹•çš„ã«ä½œæˆã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:347
msgid ""
"For expressions as assignment targets, the annotations are evaluated if in "
"class or module scope, but not stored."
msgstr "ä»£å…¥å…ˆã¨ã—ã¦å¼ã‚’ä½¿ã†ã¨ã€ã‚¯ãƒ©ã‚¹ã‚¹ã‚³ãƒ¼ãƒ—ã‚‚ã—ãã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®å ´åˆã€æ³¨é‡ˆã¯è©•ä¾¡ã•ã‚Œã¾ã™ãŒã€æ ¼ç´ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:350
msgid ""
"If a name is annotated in a function scope, then this name is local for that"
" scope. Annotations are never evaluated and stored in function scopes."
msgstr ""
"é–¢æ•°ã‚¹ã‚³ãƒ¼ãƒ—ã§åå‰ã«æ³¨é‡ˆãŒä»˜ã„ã¦ã„ãŸå ´åˆã¯ã€ãã®åå‰ã¯ãã®é–¢æ•°ã‚¹ã‚³ãƒ¼ãƒ—ã§ãƒ­ãƒ¼ã‚«ãƒ«ãªã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚\n"
"æ³¨é‡ˆã¯çµ¶å¯¾ã«è©•ä¾¡ã•ã‚Œãšã€é–¢æ•°ã‚¹ã‚³ãƒ¼ãƒ—ã«ã‚‚æ ¼ç´ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:353
msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment before evaluating annotations (where applicable). If the "
"right hand side is not present for an expression target, then the "
"interpreter evaluates the target except for the last :meth:`__setitem__` or "
":meth:`__setattr__` call."
msgstr ""

#: ../../reference/simple_stmts.rst:364
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ""

#: ../../reference/simple_stmts.rst:362
msgid ""
"The proposal that added syntax for annotating the types of variables "
"(including class variables and instance variables), instead of expressing "
"them through comments."
msgstr ""

#: ../../reference/simple_stmts.rst:368
msgid ":pep:`484` - Type hints"
msgstr ""

#: ../../reference/simple_stmts.rst:367
msgid ""
"The proposal that added the :mod:`typing` module to provide a standard "
"syntax for type annotations that can be used in static analysis tools and "
"IDEs."
msgstr ""

#: ../../reference/simple_stmts.rst:375
msgid "The :keyword:`assert` statement"
msgstr ":keyword:`assert` æ–‡"

#: ../../reference/simple_stmts.rst:382
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a"
" program:"
msgstr "assert æ–‡ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã«ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ (debugging assertion) ã‚’ä»•æ›ã‘ã‚‹ãŸã‚ã®ä¾¿åˆ©ãªæ–¹æ³•ã§ã™:"

#: ../../reference/simple_stmts.rst:388
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "å˜ç´”ãªå½¢å¼ ``assert expression`` ã¯ ::"

#: ../../reference/simple_stmts.rst:393
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr "ã¨ç­‰ä¾¡ã§ã™ã€‚æ‹¡å¼µå½¢å¼ ``assert expression1, expression2`` ã¯ã€ã“ã‚Œã¨ç­‰ä¾¡ã§ã™ ::"

#: ../../reference/simple_stmts.rst:402
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable :const:`__debug__` is ``True`` under "
"normal circumstances, ``False`` when optimization is requested (command line"
" option -O).  The current code generator emits no code for an assert "
"statement when optimization is requested at compile time.  Note that it is "
"unnecessary to include the source code for the expression that failed in the"
" error message; it will be displayed as part of the stack trace."
msgstr ""
"ä¸Šè¨˜ã®ç­‰ä¾¡é–¢ä¿‚ã¯ã€ :const:`__debug__` ã¨ :exc:`AssertionError` "
"ãŒã€åŒåã®çµ„ã¿è¾¼ã¿å¤‰æ•°ã‚’å‚ç…§ã—ã¦ã„ã‚‹ã¨ã„ã†å‰æã®ä¸Šã«æˆã‚Šç«‹ã£ã¦ã„ã¾ã™ã€‚ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€çµ„ã¿è¾¼ã¿å¤‰æ•° :const:`__debug__` "
"ã¯é€šå¸¸ã®çŠ¶æ³ã§ã¯ ``True`` ã§ã‚ã‚Šã€æœ€é©åŒ–ãŒãƒªã‚¯ã‚¨ã‚¹ãƒˆã•ã‚ŒãŸå ´åˆï¼ˆã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‚ªãƒ—ã‚·ãƒ§ãƒ³ -Oï¼‰ã¯ ``False`` "
"ã§ã™ã€‚ç¾çŠ¶ã®ã‚³ãƒ¼ãƒ‰ç”Ÿæˆå™¨ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«æœ€é©åŒ–ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹ã¨ assert "
"æ–‡ã«å¯¾ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’å…¨ãå‡ºåŠ›ã—ã¾ã›ã‚“ã€‚å®Ÿè¡Œã«å¤±æ•—ã—ãŸå¼ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…ã«å…¥ã‚Œã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“; "
"ã‚³ãƒ¼ãƒ‰ã¯ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹å†…ã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:411
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ":const:`__debug__` ã¸ã®ä»£å…¥ã¯ä¸æ­£ãªæ“ä½œã§ã™ã€‚çµ„ã¿è¾¼ã¿å¤‰æ•°ã®å€¤ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒé–‹å§‹ã™ã‚‹ã¨ãã«æ±ºå®šã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:418
msgid "The :keyword:`pass` statement"
msgstr ":keyword:`pass` æ–‡"

#: ../../reference/simple_stmts.rst:428
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""
":keyword:`pass` ã¯ãƒŒãƒ«æ“ä½œ (null operation) ã§ã™ --- :keyword:`pass` "
"ãŒå®Ÿè¡Œã•ã‚Œã¦ã‚‚ã€ä½•ã‚‚èµ·ãã¾ã›ã‚“ã€‚ :keyword:`pass` "
"ã¯ã€æ§‹æ–‡æ³•çš„ã«ã¯æ–‡ãŒå¿…è¦ã ãŒã€ã‚³ãƒ¼ãƒ‰ã¨ã—ã¦ã¯ä½•ã‚‚å®Ÿè¡Œã—ãŸããªã„å ´åˆã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ã¨ã—ã¦æœ‰ç”¨ã§ã™ã€‚ä¾‹ãˆã°::"

#: ../../reference/simple_stmts.rst:440
msgid "The :keyword:`del` statement"
msgstr ":keyword:`del` æ–‡"

#: ../../reference/simple_stmts.rst:450
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‰Šé™¤ (deletion) "
"ã¯ã€ä»£å…¥ã®å®šç¾©ã¨éå¸¸ã«ä¼¼ãŸæ–¹æ³•ã§å†å¸°çš„ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã“ã§ã¯å®Œå…¨ãªè©³ç´°ã¯è¨˜è¿°ã›ãšã€ã„ãã¤ã‹ã®ãƒ’ãƒ³ãƒˆã‚’è¿°ã¹ã‚‹ã«ã¨ã©ã‚ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:453
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆã«å¯¾ã™ã‚‹å‰Šé™¤ã¯ã€å„ã€…ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’å·¦ã‹ã‚‰å³ã¸ã¨é †ã«å†å¸°çš„ã«å‰Šé™¤ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:459
msgid ""
"Deletion of a name removes the binding of that name from the local or global"
" namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  If the name is unbound, a "
":exc:`NameError` exception will be raised."
msgstr ""
"åå‰ã®å‰Šé™¤ã¯ã€ãƒ­ãƒ¼ã‚«ãƒ«ã¾ãŸã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«åå‰ç©ºé–“ã‹ã‚‰ãã®åå‰ã®æŸç¸›ã‚’å–ã‚Šé™¤ãã¾ã™ã€‚ã©ã¡ã‚‰ã®åå‰ç©ºé–“ã‹ã¯ã€åå‰ãŒåŒã˜ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å†…ã® "
":keyword:`global` æ–‡ã§å®£è¨€ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã«ã‚ˆã‚Šã¾ã™ã€‚åå‰ãŒæœªæŸç¸› (unbound) ãªã‚‰ã€ :exc:`NameError` "
"ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:466
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr ""
"å±æ€§å‚ç…§ã€æ·»å­—è¡¨è¨˜ã€ãŠã‚ˆã³ã‚¹ãƒ©ã‚¤ã‚¹ã®å‰Šé™¤æ“ä½œã¯ã€å¯¾è±¡ã¨ãªã‚‹ä¸€æ¬¡èªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æ¸¡ã•ã‚Œã¾ã™; "
"ã‚¹ãƒ©ã‚¤ã‚¹ã®å‰Šé™¤ã¯ä¸€èˆ¬çš„ã«ã¯é©åˆ‡ãªå‹ã®ç©ºã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ä»£å…¥ã™ã‚‹ã®ã¨ç­‰ä¾¡ã§ã™ (ãŒã€ã“ã®ä»•æ§˜è‡ªä½“ã‚‚ã‚¹ãƒ©ã‚¤ã‚¹ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§æ±ºå®šã•ã‚Œã¦ã„ã¾ã™)ã€‚"

#: ../../reference/simple_stmts.rst:471
msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr "ä»¥å‰ã¯ã€ã‚ã‚‹åå‰ãŒãƒã‚¹ãƒˆã—ãŸãƒ–ãƒ­ãƒƒã‚¯ã®è‡ªç”±å¤‰æ•°ã¨ã—ã¦è¡¨ã‚Œã‚‹å ´åˆã¯ã€ãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“ã‹ã‚‰ãã®åå‰ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã¯ä¸æ­£ãªå‡¦ç†ã§ã—ãŸã€‚"

#: ../../reference/simple_stmts.rst:479
msgid "The :keyword:`return` statement"
msgstr ":keyword:`return` æ–‡"

#: ../../reference/simple_stmts.rst:489
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ":keyword:`return` ã¯ã€é–¢æ•°å®šç¾©å†…ã§æ§‹æ–‡æ³•çš„ã«ãƒã‚¹ãƒˆã—ã¦ç¾ã‚Œã¾ã™ãŒã€ãƒã‚¹ãƒˆã—ãŸã‚¯ãƒ©ã‚¹å®šç¾©å†…ã«ã¯ç¾ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:492
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr "å¼ãƒªã‚¹ãƒˆãŒã‚ã‚‹å ´åˆã€ãƒªã‚¹ãƒˆãŒå€¤è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ ``None`` ã§ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:494
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ":keyword:`return` ã‚’ä½¿ã†ã¨ã€å¼ãƒªã‚¹ãƒˆ (ã¾ãŸã¯ ``None``) ã‚’æˆ»ã‚Šå€¤ã¨ã—ã¦ã€ç¾åœ¨ã®é–¢æ•°å‘¼ã³å‡ºã—ã‹ã‚‰æŠœã‘å‡ºã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:499
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with"
" a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really leaving the function."
msgstr ""
":keyword:`return` ã«ã‚ˆã£ã¦ã€ :keyword:`finally` ç¯€ã‚’ã¨ã‚‚ãªã† :keyword:`try` "
"æ–‡ã®å¤–ã«å‡¦ç†ãŒå¼•ãæ¸¡ã•ã‚Œã‚‹ã¨ã€å®Ÿéš›ã«é–¢æ•°ã‹ã‚‰æŠœã‘ã‚‹å‰ã« :keyword:`finally` ç¯€ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:503
msgid ""
"In a generator function, the :keyword:`return` statement indicates that the "
"generator is done and will cause :exc:`StopIteration` to be raised. The "
"returned value (if any) is used as an argument to construct "
":exc:`StopIteration` and becomes the :attr:`StopIteration.value` attribute."
msgstr ""
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã§ã¯ã€ :keyword:`return` æ–‡ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®çµ‚ã‚ã‚Šã‚’ç¤ºã—ã€ :exc:`StopIteration` "
"ä¾‹å¤–ã‚’é€å‡ºã•ã›ã¾ã™ã€‚è¿”ã•ã‚ŒãŸå€¤ã¯ (ã‚ã‚Œã°)ã€ :exc:`StopIteration` ã‚’æ§‹æˆã™ã‚‹å¼•æ•°ã«ä½¿ã‚ã‚Œã€ "
":attr:`StopIteration.value` å±æ€§ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:508
msgid ""
"In an asynchronous generator function, an empty :keyword:`return` statement "
"indicates that the asynchronous generator is done and will cause "
":exc:`StopAsyncIteration` to be raised.  A non-empty :keyword:`return` "
"statement is a syntax error in an asynchronous generator function."
msgstr ""
"éåŒæœŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã§ã¯ã€å¼•æ•°ç„¡ã—ã® :keyword:`return` æ–‡ã¯éåŒæœŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®çµ‚ã‚ã‚Šã‚’ç¤ºã—ã€ :exc:`StopAsyncIteration` ã‚’é€å‡ºã•ã›ã¾ã™ã€‚\n"
"å¼•æ•°ã‚ã‚Šã® :keyword:`return` æ–‡ã¯ã€éåŒæœŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã§ã¯æ–‡æ³•ã‚¨ãƒ©ãƒ¼ã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:516
msgid "The :keyword:`yield` statement"
msgstr ":keyword:`yield` æ–‡"

#: ../../reference/simple_stmts.rst:528
msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The yield statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""
":keyword:`yield` æ–‡ã¯æ„å‘³çš„ã« :ref:`yield expression <yieldexpr>` å¼ã¨åŒã˜ã§ã™ã€‚yield "
"æ–‡ã‚’ç”¨ã„ã‚‹ã¨ yield å¼æ–‡ã§å¿…è¦ãªæ‹¬å¼§ã‚’çœç•¥ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚ä¾‹ãˆã°ã€yield æ–‡ ::"

#: ../../reference/simple_stmts.rst:536
msgid "are equivalent to the yield expression statements ::"
msgstr "ã¯ä»¥ä¸‹ã® yield å¼æ–‡ã¨ç­‰ä¾¡ã§ã™ ::"

#: ../../reference/simple_stmts.rst:541
msgid ""
"Yield expressions and statements are only used when defining a "
":term:`generator` function, and are only used in the body of the generator "
"function.  Using yield in a function definition is sufficient to cause that "
"definition to create a generator function instead of a normal function."
msgstr ""
"yield å¼åŠã³æ–‡ã¯ :term:`generator` ã‚’å®šç¾©ã™ã‚‹ã¨ãã«ã€ãã®æœ¬ä½“å†…ã§ã®ã¿ä½¿ã†ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚é–¢æ•°å®šç¾©å†…ã§ yield "
"ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ãã®å®šç¾©ã¯é€šå¸¸ã®é–¢æ•°ã§ãªãã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:546
msgid ""
"For full details of :keyword:`yield` semantics, refer to the "
":ref:`yieldexpr` section."
msgstr ":keyword:`yield` ã®æ„å‘³ã®å®Œå…¨ãªèª¬æ˜ã¯ã€ :ref:`yieldexpr` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/simple_stmts.rst:552
msgid "The :keyword:`raise` statement"
msgstr ":keyword:`raise` æ–‡"

#: ../../reference/simple_stmts.rst:563
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the last exception"
" that was active in the current scope.  If no exception is active in the "
"current scope, a :exc:`RuntimeError` exception is raised indicating that "
"this is an error."
msgstr ""
"å¼ã‚’ä¼´ã‚ãªã‘ã‚Œã°ã€ :keyword:`raise` "
"ã¯ç¾åœ¨ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§æœ€çµ‚çš„ã«æœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹ä¾‹å¤–ã‚’å†é€å‡ºã—ã¾ã™ã€‚ãã®ã‚ˆã†ãªä¾‹å¤–ãŒç¾åœ¨ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ãªã„å ´åˆã€ "
":exc:`RuntimeError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¦ã€ã“ã‚ŒãŒã‚¨ãƒ©ãƒ¼ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:568
msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of "
":class:`BaseException`. If it is a class, the exception instance will be "
"obtained when needed by instantiating the class with no arguments."
msgstr ""
"ãã†ã§ãªã‘ã‚Œã°ã€ :keyword:`raise` ã¯æœ€åˆã®å¼ã‚’ã€ä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è©•ä¾¡ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ "
":class:`BaseException` "
"ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã¾ãŸã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¹ãªã‚‰ã€ä¾‹å¤–ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒå¿…è¦ãªã¨ãã€ã‚¯ãƒ©ã‚¹ã‚’ç„¡å¼•æ•°ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ã“ã¨ã§å¾—ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:573
msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the "
":dfn:`value` is the instance itself."
msgstr "ä¾‹å¤–ã® :dfn:`å‹` ã¯ä¾‹å¤–ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¯ãƒ©ã‚¹ã§ã€ :dfn:`å€¤` ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãã®ã‚‚ã®ã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:578
msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`__traceback__` attribute, which is "
"writable. You can create an exception and set your own traceback in one step"
" using the :meth:`with_traceback` exception method (which returns the same "
"exception instance, with its traceback set to its argument), like so::"
msgstr ""
"ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é€šå¸¸ã€ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã‚‹æ™‚ã«è‡ªå‹•ã§ä½œã‚‰ã‚Œã€ãã®ä¾‹å¤–ã«æ›¸ãè¾¼ã¿å¯èƒ½ã® :attr:`__traceback__` "
"å±æ€§ã¨ã—ã¦ä»˜ä¸ã•ã‚Œã¾ã™ã€‚ :meth:`with_traceback` ä¾‹å¤–ãƒ¡ã‚½ãƒƒãƒ‰ (ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚’å¼•æ•°ã«è¨­å®šã—ãŸåŒã˜ä¾‹å¤–ã‚’è¿”ã—ã¾ã™) "
"ã‚’ä½¿ã„ã€ä¾‹å¤–ã‚’ä½œã£ã¦ç‹¬è‡ªã®ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚’è¨­å®šã™ã‚‹ã®ã‚’ä¸€åº¦ã«å‡ºæ¥ã¾ã™ã€‚ã“ã®ã‚ˆã†ã«::"

#: ../../reference/simple_stmts.rst:590
msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance, which will then be"
" attached to the raised exception as the :attr:`__cause__` attribute (which "
"is writable).  If the raised exception is not handled, both exceptions will "
"be printed::"
msgstr ""
"``from`` ç¯€ã¯ä¾‹å¤–ã®é€£é–ã«ä½¿ã‚ã‚Œã¾ã™: ç¬¬äºŒã® *expression* "
"ã¯ã€ä¸ãˆã‚‰ã‚Œã‚‹ãªã‚‰ã€åˆ¥ã®ä¾‹å¤–ã‚¯ãƒ©ã‚¹ã¾ãŸã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ã“ã‚ŒãŒé€å‡ºã•ã‚ŒãŸä¾‹å¤–ã« (æ›¸ãè¾¼ã¿å¯èƒ½ã®) :attr:`__cause__` "
"å±æ€§ã¨ã—ã¦ä»˜ä¸ã•ã‚Œã¾ã™ã€‚é€å‡ºã•ã‚ŒãŸä¾‹å¤–ãŒãƒãƒ³ãƒ‰ãƒ«ã•ã‚Œãªã‘ã‚Œã°ã€ä¸¡æ–¹ã®ä¾‹å¤–ãŒå°å­—ã•ã‚Œã¾ã™::"

#: ../../reference/simple_stmts.rst:611
msgid ""
"A similar mechanism works implicitly if an exception is raised inside an "
"exception handler or a :keyword:`finally` clause: the previous exception is "
"then attached as the new exception's :attr:`__context__` attribute::"
msgstr ""
"ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã¾ãŸã¯ :keyword:`finally` "
"ç¯€ã®ä¸­ã§ä¾‹å¤–ãŒé€å‡ºã•ã‚ŒãŸæ™‚ã‚‚ã€åŒã˜ã‚ˆã†ãªæ©Ÿæ§‹ãŒæš—é»™ã«åƒãã¾ã™ã€‚ã“ã®ã¨ãã€å…ˆã«èµ·ã“ã£ãŸä¾‹å¤–ãŒã€æ–°ã—ã„ä¾‹å¤–ã® :attr:`__context__` "
"å±æ€§ã«ä»˜ä¸ã•ã‚Œã¾ã™::"

#: ../../reference/simple_stmts.rst:630
msgid ""
"Exception chaining can be explicitly suppressed by specifying :const:`None` "
"in the ``from`` clause::"
msgstr "``from`` ç¯€ã« :const:`None` ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ã€ä¾‹å¤–ã®é€£é–ã‚’æ˜ç¤ºçš„ã«éè¡¨ç¤ºã«ã§ãã¾ã™::"

#: ../../reference/simple_stmts.rst:642
msgid ""
"Additional information on exceptions can be found in section "
":ref:`exceptions`, and information about handling exceptions is in section "
":ref:`try`."
msgstr ""
"ä¾‹å¤–ã«é–¢ã™ã‚‹è¿½åŠ æƒ…å ±ã¯ :ref:`exceptions` ç¯€ã«ã‚ã‚Šã¾ã™ã€‚ã¾ãŸã€ä¾‹å¤–å‡¦ç†ã«é–¢ã™ã‚‹æƒ…å ±ã¯ :ref:`try` ç¯€ã«ã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:645
msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr ":const:`None` ãŒ ``raise X from Y`` ã® ``Y`` ã¨ã—ã¦ä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../reference/simple_stmts.rst:648
msgid ""
"The ``__suppress_context__`` attribute to suppress automatic display of the "
"exception context."
msgstr "``__suppress_context__`` å±æ€§ã®è¨­å®šã§ã€ä¾‹å¤–ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒè‡ªå‹•çš„ã«éè¡¨ç¤ºã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:655
msgid "The :keyword:`break` statement"
msgstr ":keyword:`break` æ–‡"

#: ../../reference/simple_stmts.rst:666
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or "
":keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""
":keyword:`break` æ–‡ã¯ã€æ§‹æ–‡ã¨ã—ã¦ã¯ :keyword:`for` ãƒ«ãƒ¼ãƒ—ã‚„ :keyword:`while` "
"ãƒ«ãƒ¼ãƒ—ã®å†…å´ã§ã®ã¿å‡ºç¾ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€ãƒ«ãƒ¼ãƒ—å†…ã®é–¢æ•°å®šç¾©ã‚„ã‚¯ãƒ©ã‚¹å®šç¾©ã®å†…å´ã«ã¯å‡ºç¾ã§ãã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:673
msgid ""
"It terminates the nearest enclosing loop, skipping the optional "
":keyword:`else` clause if the loop has one."
msgstr ""
":keyword:`break` æ–‡ã¯ã€æ–‡ã‚’å›²ã†æœ€ã‚‚å†…å´ã®ãƒ«ãƒ¼ãƒ—ã‚’çµ‚äº†ã•ã›ã€ãƒ«ãƒ¼ãƒ—ã«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® :keyword:`else` "
"ç¯€ãŒã‚ã‚‹å ´åˆã«ã¯ãã‚Œã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:676
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control"
" target keeps its current value."
msgstr ""
":keyword:`for` ãƒ«ãƒ¼ãƒ—ã‚’ :keyword:`break` ã«ã‚ˆã£ã¦çµ‚äº†ã™ã‚‹ã¨ã€ãƒ«ãƒ¼ãƒ—åˆ¶å¾¡ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¯ãã®æ™‚ã®å€¤ã‚’ä¿æŒã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:681
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really leaving the loop."
msgstr ""
":keyword:`break` ãŒ :keyword:`finally` ç¯€ã‚’ä¼´ã† :keyword:`try` "
"æ–‡ã®å¤–å´ã«å‡¦ç†ã‚’æ¸¡ã™éš›ã«ã¯ã€ãƒ«ãƒ¼ãƒ—ã‚’å®Ÿéš›ã«æŠœã‘ã‚‹å‰ã«ãã® :keyword:`finally` ç¯€ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:689
msgid "The :keyword:`continue` statement"
msgstr ":keyword:`continue` æ–‡"

#: ../../reference/simple_stmts.rst:701
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"or :keyword:`finally` clause within that loop.  It continues with the next "
"cycle of the nearest enclosing loop."
msgstr ""
":keyword:`continue` æ–‡ã¯ :keyword:`for` ãƒ«ãƒ¼ãƒ—ã‚„ :keyword:`while` "
"ãƒ«ãƒ¼ãƒ—å†…ã®ãƒã‚¹ãƒˆã§æ§‹æ–‡æ³•çš„ã«ã®ã¿ç¾ã‚Œã¾ã™ãŒã€ãƒ«ãƒ¼ãƒ—å†…ã®é–¢æ•°å®šç¾©ã‚„ã‚¯ãƒ©ã‚¹å®šç¾©ã€ :keyword:`finally` å¥ã®ä¸­ã«ã¯ç¾ã‚Œã¾ã›ã‚“ã€‚ "
":keyword:`continue` æ–‡ã¯ã€æ–‡ã‚’å›²ã†æœ€ã‚‚å†…å´ã®ãƒ«ãƒ¼ãƒ—ã®æ¬¡ã®å‘¨æœŸã«å‡¦ç†ã‚’ç¶™ç¶šã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:706
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`finally` clause is executed"
" before really starting the next loop cycle."
msgstr ""
":keyword:`continue` ãŒ :keyword:`finally` å¥ã‚’æŒã£ãŸ :keyword:`try` æ–‡ã‚’æŠœã‘ã‚‹ã¨ãã€ãã® "
":keyword:`finally` å¥ãŒæ¬¡ã®ãƒ«ãƒ¼ãƒ—ã‚µã‚¤ã‚¯ãƒ«ã‚’å§‹ã‚ã‚‹å‰ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:715
msgid "The :keyword:`import` statement"
msgstr ":keyword:`import` æ–‡"

#: ../../reference/simple_stmts.rst:736
msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two "
"steps:"
msgstr "(:keyword:`from` ç¯€ãŒç„¡ã„) åŸºæœ¬ã® import æ–‡ã¯ 2 ã¤ã®ã‚¹ãƒ†ãƒƒãƒ—ã§å®Ÿè¡Œã•ã‚Œã¾ã™:"

#: ../../reference/simple_stmts.rst:739
msgid "find a module, loading and initializing it if necessary"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ä»˜ã‘å‡ºã—ã€å¿…è¦ã§ã‚ã‚Œã°ãƒ­ãƒ¼ãƒ‰ã—åˆæœŸåŒ–ã™ã‚‹"

#: ../../reference/simple_stmts.rst:740
msgid ""
"define a name or names in the local namespace for the scope where the "
":keyword:`import` statement occurs."
msgstr ":keyword:`import` æ–‡ãŒè¡¨ã‚Œã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ã®ãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“ã§åå‰ã‚’å®šç¾©ã™ã‚‹ã€‚"

#: ../../reference/simple_stmts.rst:743
msgid ""
"When the statement contains multiple clauses (separated by commas) the two "
"steps are carried out separately for each clause, just as though the clauses"
" had been separated out into individual import statements."
msgstr ""
"æ–‡ãŒ (ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸ) è¤‡æ•°ã®ç¯€ã‚’å«ã‚“ã§ã„ã‚‹ã¨ãã¯ã€ã¡ã‚‡ã†ã©ãã®ç¯€ãŒå€‹åˆ¥ã® import "
"æ–‡ã«åˆ†å‰²ã•ã‚ŒãŸã‹ã®ã‚ˆã†ã«ã€2ã¤ã®ã‚¹ãƒ†ãƒƒãƒ—ãŒç¯€ã”ã¨ã«å€‹åˆ¥ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:748
msgid ""
"The details of the first step, finding and loading modules are described in "
"greater detail in the section on the :ref:`import system <importsystem>`, "
"which also describes the various types of packages and modules that can be "
"imported, as well as all the hooks that can be used to customize the import "
"system. Note that failures in this step may indicate either that the module "
"could not be located, *or* that an error occurred while initializing the "
"module, which includes execution of the module's code."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ä»˜ã‘ã€ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ 1 ã¤ç›®ã®ã‚¹ãƒ†ãƒƒãƒ—ã®è©³ç´°ã«ã¤ã„ã¦ã¯ã€ :ref:`ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ  <importsystem>` "
"ã®ç¯€ã«ã‚ˆã‚Šè©³ã—ãæ›¸ã‹ã‚Œã¦ã„ã¾ã™ã€‚ãã“ã§ã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®å‹•ä½œã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã®ã«ä½¿ãˆã‚‹å…¨ã¦ã®ãƒ•ãƒƒã‚¯ã®ä»•çµ„ã¿ã ã‘ã§ãªãã€æ§˜ã€…ãªç¨®é¡ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦ã‚‚è§£èª¬ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ã‚¹ãƒ†ãƒƒãƒ—ãŒå¤±æ•—ã™ã‚‹ã¨ã„ã†ã“ã¨ã¯ã€ãŠãã‚‰ããƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ä»˜ã‹ã‚‰ãªã„ã‹ã€"
" *ã‚ã‚‹ã„ã¯* ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ã®å®Ÿè¡Œã‚’å«ã‚ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–ã®é€”ä¸­ã§ã‚¨ãƒ©ãƒ¼ãŒèµ·ãã‚‹ã‹ã®ã©ã¡ã‚‰ã‹ãŒèµ·ãã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/simple_stmts.rst:756
msgid ""
"If the requested module is retrieved successfully, it will be made available"
" in the local namespace in one of three ways:"
msgstr "è¦æ±‚ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒç„¡äº‹ã«å–å¾—ã§ããŸå ´åˆã€æ¬¡ã® 3 ã¤ã®ã†ã¡ã® 1 ã¤ã®æ–¹æ³•ã§ãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“ã§ä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™:"

#: ../../reference/simple_stmts.rst:761
msgid ""
"If the module name is followed by :keyword:`as`, then the name following "
":keyword:`as` is bound directly to the imported module."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã®å¾Œã« :keyword:`as` ãŒç¶šã„ã¦ã„ãŸå ´åˆã¯ã€ :keyword:`as` "
"ã®å¾Œã‚ã®åå‰ã‚’ç›´æ¥ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæŸç¸›ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:763
msgid ""
"If no other name is specified, and the module being imported is a top level "
"module, the module's name is bound in the local namespace as a reference to "
"the imported module"
msgstr ""
"ä»–ã®åå‰ãŒæŒ‡å®šã•ã‚Œã¦ãŠã‚‰ãšã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæœ€ä¸Šä½ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã ã£ãŸå ´åˆã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸ã®å‚ç…§ã¨ã—ã¦ã€ãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“ã§æŸç¸›ã•ã‚Œã¾ã™"

#: ../../reference/simple_stmts.rst:766
msgid ""
"If the module being imported is *not* a top level module, then the name of "
"the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module must "
"be accessed using its full qualified name rather than directly"
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæœ€ä¸Šä½ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« *ã§ãªã„* "
"å ´åˆã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å«ã‚€æœ€ä¸Šä½ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åãŒã€ãã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¸ã®å‚ç…§ã¨ã—ã¦ã€ãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“ã§æŸç¸›ã•ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã€ç›´æ¥ã§ã¯ãªãå®Œå…¨ä¿®é£¾åã‚’ä½¿ã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“"

#: ../../reference/simple_stmts.rst:776
msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr ":keyword:`from` å½¢å¼ã§ã¯ã‚‚ã†å°‘ã—è¤‡é›‘ãªæ‰‹é †ã‚’è¸ã¿ã¾ã™:"

#: ../../reference/simple_stmts.rst:778
msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr ":keyword:`from` ç¯€ã§æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ä»˜ã‘å‡ºã—ã€å¿…è¦ã§ã‚ã‚Œã°ãƒ­ãƒ¼ãƒ‰ã—åˆæœŸåŒ–ã™ã‚‹;"

#: ../../reference/simple_stmts.rst:780
msgid ""
"for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr ":keyword:`import` ç¯€ã§æŒ‡å®šã•ã‚ŒãŸãã‚Œãã‚Œã®è­˜åˆ¥å­ã«å¯¾ã—ä»¥ä¸‹ã®å‡¦ç†ã‚’è¡Œã†:"

#: ../../reference/simple_stmts.rst:782
msgid "check if the imported module has an attribute by that name"
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãã®è­˜åˆ¥å­åã®å±æ€§ã‚’æŒã£ã¦ã„ã‚‹ã‹ã‚’ç¢ºèªã™ã‚‹"

#: ../../reference/simple_stmts.rst:783
msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr "æŒã£ã¦ã„ãªã‹ã£ãŸå ´åˆã¯ã€ãã®è­˜åˆ¥å­åã§ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’è©¦ã¿ã€å†åº¦ãã®å±æ€§ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ã‚‹ã‹ç¢ºèªã™ã‚‹"

#: ../../reference/simple_stmts.rst:785
msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr "å±æ€§ãŒè¦‹ä»˜ã‹ã‚‰ãªã„å ´åˆã¯ã€ :exc:`ImportError` ã‚’é€å‡ºã™ã‚‹ã€‚"

#: ../../reference/simple_stmts.rst:786
msgid ""
"otherwise, a reference to that value is stored in the local namespace, using"
" the name in the :keyword:`as` clause if it is present, otherwise using the "
"attribute name"
msgstr ""
"å±æ€§ãŒè¦‹ä»˜ã‹ã£ãŸå ´åˆã¯ã€ :keyword:`as` ç¯€ãŒã‚ã‚‹ãªã‚‰ãã“ã®åå‰ã€ãã†ã§ãªã„ãªã‚‰å±æ€§åã‚’ä½¿ã£ã¦ã€ãã®å€¤ã¸ã®å‚ç…§ãŒãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“ã«ä¿å­˜ã•ã‚Œã‚‹"

#: ../../reference/simple_stmts.rst:790
msgid "Examples::"
msgstr "ä¾‹::"

#: ../../reference/simple_stmts.rst:800
msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public names"
" defined in the module are bound in the local namespace for the scope where "
"the :keyword:`import` statement occurs."
msgstr ""
"è­˜åˆ¥å­ã®ãƒªã‚¹ãƒˆãŒæ˜Ÿ (``'*'``) ã«ç½®ãæ›ã‚ã£ã¦ã„ã‚‹å ´åˆã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹å…¬é–‹ã•ã‚ŒãŸå…¨ã¦ã®åå‰ãŒã€ :keyword:`import`"
" æ–‡ãŒã„ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ã®ãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“ã«æŸç¸›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:806
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to"
" exist.  If ``__all__`` is not defined, the set of public names includes all"
" names found in the module's namespace which do not begin with an underscore"
" character (``'_'``).  ``__all__`` should contain the entire public API. It "
"is intended to avoid accidentally exporting items that are not part of the "
"API (such as library modules which were imported and used within the "
"module)."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã‚‹ *å…¬é–‹ã•ã‚ŒãŸåå‰* ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ã«ã‚ã‚‹ ``__all__`` ã¨ã„ã†åå‰ã®å¤‰æ•°ã‚’èª¿ã¹ã‚‹ã“ã¨ã§æ±ºå®šã•ã‚Œã¾ã™; "
"ãã®å¤‰æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã‚Œã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚ŒãŸã‹ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸåå‰ã‹ã‚‰ãªã‚‹ã€æ–‡å­—åˆ—ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚``__all__``"
" ã§åˆ—æŒ™ã•ã‚ŒãŸåå‰ã¯ã€å…¨ã¦å…¬é–‹ã•ã‚Œã¦ã„ã‚‹ã¨è¦‹ãªã•ã‚Œã€å­˜åœ¨ã™ã‚‹ã“ã¨ãŒè¦æ±‚ã•ã‚Œã¾ã™ã€‚``__all__`` "
"ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€å…¬é–‹ã•ã‚ŒãŸåå‰ã¨ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ã§è¦‹ä»˜ã‹ã£ãŸã€ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢æ–‡å­— (``'_'``) "
"ã§å§‹ã¾ã‚‰ãªã„å…¨ã¦ã®åå‰ã®ã“ã¨ã§ã™ã€‚``__all__`` ã¯å…¨ã¦ã®å…¬é–‹ API ã‚’å«ã‚€ã¹ãã§ã™ã€‚ã“ã‚Œã¯ API ã®ä¸€éƒ¨ã§ãªã„ã‚‚ã® "
"(ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œä½¿ã‚ã‚Œã¦ã„ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãªã©) ã‚’ã†ã£ã‹ã‚Šå¤–éƒ¨ã«å…¬é–‹ã—ã¦ã—ã¾ã‚ãªã„ãŸã‚ã®ä»•çµ„ã¿ã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:816
msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰å½¢å¼ --- ``from module import *`` --- "
"ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã§ã®ã¿è¨±ã•ã‚Œã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã‚„é–¢æ•°å®šç¾©ã§ã“ã®å½¢å¼ã‚’ä½¿ãŠã†ã¨ã™ã‚‹ã¨ã€ :exc:`SyntaxError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:823
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top"
" package without having to mention the package name. By using leading dots "
"in the specified module or package after :keyword:`from` you can specify how"
" high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the"
" import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained "
"within :pep:`328`."
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æŒ‡å®šã™ã‚‹ã¨ãã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®çµ¶å¯¾å (absolute name) "
"ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒä»–ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€å…±é€šã®ãƒˆãƒƒãƒ—ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‹ã‚‰ãã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åã‚’è¨˜è¿°ã™ã‚‹ã“ã¨ãªãç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"
" :keyword:`from` "
"ã®å¾Œã«æŒ‡å®šã•ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å…ˆé ­ã«è¤‡æ•°å€‹ã®ãƒ‰ãƒƒãƒˆã‚’ä»˜ã‘ã‚‹ã“ã¨ã§ã€æ­£ç¢ºãªåå‰ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãªã—ã«ç¾åœ¨ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸éšå±¤ã‹ã‚‰ã„ãã¤ä¸Šã®éšå±¤ã¸è¡Œãã‹ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å…ˆé ­ã®ãƒ‰ãƒƒãƒˆãŒ"
" 1 ã¤ã®å ´åˆã€ import ã‚’ãŠã“ãªã£ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå­˜åœ¨ã™ã‚‹ç¾åœ¨ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ç¤ºã—ã¾ã™ã€‚ 3 ã¤ã®ãƒ‰ãƒƒãƒˆã¯ 2 ã¤ä¸Šã®ãƒ¬ãƒ™ãƒ«ã‚’ç¤ºã—ã¾ã™ã€‚ãªã®ã§ã€"
" ``pkg`` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ä¸­ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ ``from . import mod`` ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ ``pkg.mod`` "
"ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ ``pkg.subpkg1`` ã®ä¸­ã‹ã‚‰ ``from ..subpkg2 import mod`` ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ "
"``pkg.subpkg2.mod`` ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®ä»•æ§˜ã¯ :pep:`328` ã«å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:836
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ""
"ã©ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã¹ãã‹ã‚’å‹•çš„ã«æ±ºã‚ãŸã„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãŸã‚ã«ã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`importlib.import_module`"
" ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:843
msgid "Future statements"
msgstr "future æ–‡ (future statement)"

#: ../../reference/simple_stmts.rst:849
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python where the feature becomes standard."
msgstr ""
":dfn:`future æ–‡` ã¯ã€å°†æ¥ã®ç‰¹å®šã®æ–°ãŸãªæ©Ÿèƒ½ãŒæ¨™æº–åŒ–ã•ã‚ŒãŸ Python "
"ã®ãƒªãƒªãƒ¼ã‚¹ã§åˆ©ç”¨å¯èƒ½ã«ãªã‚‹ã‚ˆã†ãªæ§‹æ–‡ã‚„æ„å‘³ä»˜ã‘ã‚’ä½¿ã£ã¦ã€ç‰¹å®šã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã›ã‚‹ãŸã‚ã®ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«å¯¾ã™ã‚‹æŒ‡ç¤ºå¥ (directive) "
"ã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:853
msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows use "
"of the new features on a per-module basis before the release in which the "
"feature becomes standard."
msgstr ""
"future æ–‡ã¯äº’æ›æ€§ã®ãªã„å¤‰æ›´ãŒã•ã‚ŒãŸå°†æ¥ã® Python ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«å®¹æ˜“ã«ç§»è¡Œã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚future "
"æ–‡ã«ã‚ˆã£ã¦æ–°æ©Ÿèƒ½ãŒæ¨™æº–ã¨ãªã‚‹ãƒªãƒªãƒ¼ã‚¹ã®å‰ã«ãã‚Œã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å˜ä½ã§ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:865
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr "future æ–‡ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å…ˆé ­å‘¨è¾ºã«æ›¸ã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ future æ–‡ã®å‰ã«æ›¸ã„ã¦ã‚ˆã„å†…å®¹ã¯ä»¥ä¸‹ã§ã™ :"

#: ../../reference/simple_stmts.rst:868
msgid "the module docstring (if any),"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ— ( ã‚ã‚Œã° )"

#: ../../reference/simple_stmts.rst:869
msgid "comments,"
msgstr "ã‚³ãƒ¡ãƒ³ãƒˆ ,"

#: ../../reference/simple_stmts.rst:870
msgid "blank lines, and"
msgstr "ç©ºè¡Œ ,"

#: ../../reference/simple_stmts.rst:871
msgid "other future statements."
msgstr "ãã®ä»–ã® future æ–‡ã€‚"

#: ../../reference/simple_stmts.rst:873
msgid ""
"The only feature in Python 3.7 that requires using the future statement is "
"``annotations``."
msgstr ""

#: ../../reference/simple_stmts.rst:876
msgid ""
"All historical features enabled by the future statement are still recognized"
" by Python 3.  The list includes ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` and ``with_statement``.  They are all "
"redundant because they are always enabled, and only kept for backwards "
"compatibility."
msgstr ""

#: ../../reference/simple_stmts.rst:883
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""
"future æ–‡ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ç‰¹åˆ¥ãªã‚„ã‚Šæ–¹ã§èªè­˜ã•ã‚Œã€æ‰±ã‚ã‚Œã¾ã™: è¨€èªã®ä¸­æ ¸ã‚’ãªã™æ§‹æ–‡æ§‹æˆ (construct) "
"ã«å¯¾ã™ã‚‹æ„å‘³ä»˜ã‘ãŒå¤‰æ›´ã•ã‚Œã¦ã„ã‚‹å ´åˆã€å¤‰æ›´éƒ¨åˆ†ã¯ã—ã°ã—ã°ç•°ãªã‚‹ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã§å®Ÿç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚æ–°ãŸãªæ©Ÿèƒ½ã«ã‚ˆã£ã¦ã€(æ–°ãŸãªäºˆç´„èªã®ã‚ˆã†ãª) "
"äº’æ›æ€§ã®ãªã„æ–°ãŸãªæ§‹æ–‡ãŒå–ã‚Šå…¥ã‚Œã‚‰ã‚Œã‚‹ã“ã¨ã•ãˆã‚ã‚Šã¾ã™ã€‚ã“ã®å ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆ¥ã®ã‚„ã‚Šã‹ãŸã§è§£æã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã†ã—ãŸã‚³ãƒ¼ãƒ‰ç”Ÿæˆã«é–¢ã™ã‚‹æ±ºå®šã¯ã€å®Ÿè¡Œæ™‚ã¾ã§å…ˆå»¶ã°ã—ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:890
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""
"ã“ã‚Œã¾ã§ã®å…¨ã¦ã®ãƒªãƒªãƒ¼ã‚¹ã«ãŠã„ã¦ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã©ã®æ©Ÿèƒ½ãŒå®šç¾©æ¸ˆã¿ã‹ã‚’çŸ¥ã£ã¦ãŠã‚Šã€ future "
"æ–‡ã«æœªçŸ¥ã®æ©Ÿèƒ½ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã‚¨ãƒ©ãƒ¼ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:894
msgid ""
"The direct runtime semantics are the same as for any import statement: there"
" is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""
"future æ–‡ã®å®Ÿè¡Œæ™‚ã«ãŠã‘ã‚‹ç›´æ¥çš„ãªæ„å‘³ä»˜ã‘ã¯ã€ import æ–‡ã¨åŒã˜ã§ã™ã€‚æ¨™æº–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`__future__` "
"ãŒã‚ã‚Šã€ã“ã‚Œã«ã¤ã„ã¦ã¯å¾Œã§è¿°ã¹ã¾ã™ã€‚ :mod:`__future__` ã¯ã€ future æ–‡ãŒå®Ÿè¡Œã•ã‚Œã‚‹éš›ã«é€šå¸¸ã®æ–¹æ³•ã§ import ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:898
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr "future æ–‡ã®å®Ÿè¡Œæ™‚ã«ãŠã‘ã‚‹ç‰¹åˆ¥ãªæ„å‘³ä»˜ã‘ã¯ã€ future æ–‡ã§æœ‰åŠ¹åŒ–ã•ã‚Œã‚‹ç‰¹å®šã®æ©Ÿèƒ½ã«ã‚ˆã£ã¦å¤‰ã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:901
msgid "Note that there is nothing special about the statement::"
msgstr "ä»¥ä¸‹ã®æ–‡ã«ã¯ã€ä½•ã‚‰ç‰¹æ®Šãªæ„å‘³ã¯ãªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„::"

#: ../../reference/simple_stmts.rst:905
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr "ã“ã‚Œã¯ future æ–‡ã§ã¯ã‚ã‚Šã¾ã›ã‚“; ã“ã®æ–‡ã¯é€šå¸¸ã® import æ–‡ã§ã‚ã‚Šã€ãã®ä»–ã®ç‰¹æ®Šãªæ„å‘³ä»˜ã‘ã‚„æ§‹æ–‡çš„ãªåˆ¶é™ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:908
msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and "
":func:`compile` that occur in a module :mod:`M` containing a future "
"statement will, by default, use the new syntax or semantics associated with "
"the future statement.  This can be controlled by optional arguments to "
":func:`compile` --- see the documentation of that function for details."
msgstr ""
"future æ–‡ã®å…¥ã£ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`M` å†…ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹çµ„ã¿è¾¼ã¿é–¢æ•° :func:`exec` ã‚„ :func:`compile` "
"ã«ã‚ˆã£ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¨­å®šã§ã¯ã€ future æ–‡ã«é–¢ä¿‚ã™ã‚‹æ–°ãŸãªæ§‹æ–‡ã‚„æ„å‘³ä»˜ã‘ã‚’ä½¿ã†ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚ã“ã®ä»•æ§˜ã¯ "
":func:`compile` ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•°ã§åˆ¶å¾¡ã§ãã¾ã™ --- è©³ç´°ã¯ã“ã®é–¢æ•°ã«é–¢ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/simple_stmts.rst:914
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""
"å¯¾è©±çš„ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§ã‚¿ã‚¤ãƒ—å…¥åŠ›ã—ãŸ future æ–‡ã¯ã€ãã®å¾Œã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸­ã§æœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ "
":option:`-i` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§èµ·å‹•ã—ã¦å®Ÿè¡Œã™ã¹ãã‚¹ã‚¯ãƒªãƒ—ãƒˆåã‚’æ¸¡ã—ã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆä¸­ã« future "
"æ–‡ã‚’å…¥ã‚Œã¦ãŠãã¨ã€æ–°ãŸãªæ©Ÿèƒ½ã¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒå®Ÿè¡Œã•ã‚ŒãŸå¾Œã«é–‹å§‹ã™ã‚‹å¯¾è©±ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§æœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:922
msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` - Back to the __future__"

#: ../../reference/simple_stmts.rst:923
msgid "The original proposal for the __future__ mechanism."
msgstr "__future__ æ©Ÿæ§‹ã®åŸæ¡ˆ"

#: ../../reference/simple_stmts.rst:929
msgid "The :keyword:`global` statement"
msgstr ":keyword:`global` æ–‡"

#: ../../reference/simple_stmts.rst:939
msgid ""
"The :keyword:`global` statement is a declaration which holds for the entire "
"current code block.  It means that the listed identifiers are to be "
"interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`global`, although free variables may refer to "
"globals without being declared global."
msgstr ""
":keyword:`global` æ–‡ã¯ã€ç¾åœ¨ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å…¨ä½“ã§ç¶­æŒã•ã‚Œã‚‹å®£è¨€æ–‡ã§ã™ã€‚ :keyword:`global` "
"æ–‡ã¯ã€åˆ—æŒ™ã—ãŸè­˜åˆ¥å­ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦è§£é‡ˆã™ã‚‹ã‚ˆã†æŒ‡å®šã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ :keyword:`global` "
"ã‚’ä½¿ã‚ãšã«ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ä»£å…¥ã‚’è¡Œã†ã“ã¨ã¯ä¸å¯èƒ½ã§ã™ãŒã€è‡ªç”±å¤‰æ•°ã‚’ä½¿ãˆã°ãã®å¤‰æ•°ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§ã‚ã‚‹ã¨å®£è¨€ã›ãšã«ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’å‚ç…§ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:945
msgid ""
"Names listed in a :keyword:`global` statement must not be used in the same "
"code block textually preceding that :keyword:`global` statement."
msgstr ""
":keyword:`global` æ–‡ã§åˆ—æŒ™ã™ã‚‹åå‰ã¯ã€åŒã˜ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ä¸­ã§ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ†ã‚­ã‚¹ãƒˆä¸Š :keyword:`global` "
"æ–‡ã‚ˆã‚Šå‰ã«ä½¿ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:948
msgid ""
"Names listed in a :keyword:`global` statement must not be defined as formal "
"parameters or in a :keyword:`for` loop control target, :keyword:`class` "
"definition, function definition, :keyword:`import` statement, or variable "
"annotation."
msgstr ""
":keyword:`global` æ–‡ã§åˆ—æŒ™ã™ã‚‹åå‰ã¯ã€ :keyword:`for` ãƒ«ãƒ¼ãƒ—ã®ãƒ«ãƒ¼ãƒ—åˆ¶å¾¡ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚„ã€ "
":keyword:`class` å®šç¾©ã€é–¢æ•°å®šç¾©ã€ :keyword:`import` æ–‡ã€å¤‰æ•°ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã§ä»®å¼•æ•°ã¨ã—ã¦ä½¿ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:955
msgid ""
"The current implementation does not enforce some of these restrictions, but "
"programs should not abuse this freedom, as future implementations may "
"enforce them or silently change the meaning of the program."
msgstr ""
"ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€ã“ã‚Œã‚‰ã®åˆ¶é™ã®ã†ã¡å¹¾ã¤ã‹ã«ã¤ã„ã¦ã¯å¼·åˆ¶ã—ã¦ã„ã¾ã›ã‚“ãŒã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã“ã®ç·©å’Œã•ã‚ŒãŸä»•æ§˜ã‚’ä¹±ç”¨ã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å°†æ¥ã®å®Ÿè£…ã§ã¯ã€ã“ã®åˆ¶é™ã‚’å¼·åˆ¶ã—ãŸã‚Šã€æš—é»™ã®ã†ã¡ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ„å‘³ä»˜ã‘ã‚’å¤‰æ›´ã—ãŸã‚Šã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:964
msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`global` "
"statement. In particular, a :keyword:`global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained"
" in such a string is unaffected by :keyword:`global` statements in the code "
"containing the function call.  The same applies to the :func:`eval` and "
":func:`compile` functions."
msgstr ""
"**ãƒ—ãƒ­ã‚°ãƒ©ãƒã®ãŸã‚ã®æ³¨æ„ç‚¹:** :keyword:`global` ã¯ãƒ‘ãƒ¼ã‚¶ã«å¯¾ã™ã‚‹æŒ‡ç¤ºå¥ (directive) ã§ã™ã€‚ã“ã®æŒ‡ç¤ºå¥ã¯ã€ "
":keyword:`global` æ–‡ã¨åŒæ™‚ã«èª­ã¿è¾¼ã¾ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã«å¯¾ã—ã¦ã®ã¿é©ç”¨ã•ã‚Œã¾ã™ã€‚ç‰¹ã«ã€çµ„ã¿è¾¼ã¿ã® :func:`exec` é–¢æ•°å†…ã«å…¥ã£ã¦ã„ã‚‹"
" :keyword:`global` æ–‡ã¯ã€é–¢æ•°ã®å‘¼ã³å‡ºã—ã‚’ *å«ã‚“ã§ã„ã‚‹* "
"ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å†…ã«åŠ¹æœã‚’åŠã¼ã™ã“ã¨ã¯ãªãã€ãã®ã‚ˆã†ãªæ–‡å­—åˆ—ã«å«ã¾ã‚Œã¦ã„ã‚‹ã‚³ãƒ¼ãƒ‰ã¯ã€é–¢æ•°ã®å‘¼ã³å‡ºã—ã‚’å«ã‚€ã‚³ãƒ¼ãƒ‰å†…ã® :keyword:`global` "
"æ–‡ã«å½±éŸ¿ã‚’å—ã‘ã¾ã›ã‚“ã€‚åŒæ§˜ã®ã“ã¨ãŒã€é–¢æ•° :func:`eval` ãŠã‚ˆã³ :func:`compile` ã«ã‚‚å½“ã¦ã¯ã¾ã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:976
msgid "The :keyword:`nonlocal` statement"
msgstr ":keyword:`nonlocal` æ–‡"

#: ../../reference/simple_stmts.rst:988
msgid ""
"The :keyword:`nonlocal` statement causes the listed identifiers to refer to "
"previously bound variables in the nearest enclosing scope excluding globals."
" This is important because the default behavior for binding is to search the"
" local namespace first.  The statement allows encapsulated code to rebind "
"variables outside of the local scope besides the global (module) scope."
msgstr ""
":keyword:`nonlocal` "
"æ–‡ã¯ã€åˆ—æŒ™ã•ã‚ŒãŸè­˜åˆ¥å­ãŒã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚’é™¤ãä¸€ã¤å¤–å´ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§å…ˆã«æŸç¸›ã•ã‚ŒãŸå¤‰æ•°ã‚’å‚ç…§ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€æŸç¸›ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œãŒã¾ãšãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“ã‚’æ¢ç´¢ã™ã‚‹ã®ã§é‡è¦ã§ã™ã€‚ã“ã®æ–‡ã¯ã€ä¸­ã«ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ãŒã€ã‚°ãƒ­ãƒ¼ãƒãƒ«"
" (ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«) ã‚¹ã‚³ãƒ¼ãƒ—ä»¥å¤–ã®ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®å¤–å´ã®å¤‰æ•°ã‚’å†æŸç¸›ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:998
msgid ""
"Names listed in a :keyword:`nonlocal` statement, unlike those listed in a "
":keyword:`global` statement, must refer to pre-existing bindings in an "
"enclosing scope (the scope in which a new binding should be created cannot "
"be determined unambiguously)."
msgstr ""
":keyword:`nonlocal` æ–‡ã§åˆ—æŒ™ã•ã‚ŒãŸåå‰ã¯ã€ :keyword:`global` "
"æ–‡ã§åˆ—æŒ™ã•ã‚ŒãŸåå‰ã¨é•ã„ã€å¤–å´ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§ã™ã§ã«å­˜åœ¨ã™ã‚‹æŸç¸›ã‚’å‚ç…§ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ "
"(æ–°ã—ã„æŸç¸›ãŒä½œã‚‰ã‚Œã‚‹ã¹ãã‚¹ã‚³ãƒ¼ãƒ—ã®é¸æŠãŒæ›–æ˜§ã•ã‚’æ’é™¤ã§ãã¾ã›ã‚“)ã€‚"

#: ../../reference/simple_stmts.rst:1003
msgid ""
"Names listed in a :keyword:`nonlocal` statement must not collide with pre-"
"existing bindings in the local scope."
msgstr ":keyword:`nonlocal` æ–‡ã§åˆ—æŒ™ã•ã‚ŒãŸåå‰ã¯ã€ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã§ã™ã§ã«å­˜åœ¨ã™ã‚‹æŸç¸›ã¨è¡çªã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:1008
msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ":pep:`3104` - Access to Names in Outer Scopes"

#: ../../reference/simple_stmts.rst:1009
msgid "The specification for the :keyword:`nonlocal` statement."
msgstr ":keyword:`nonlocal` æ–‡ã®è©³ç´°ã€‚"
