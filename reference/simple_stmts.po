# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2018
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2015-2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-08 14:51+0900\n"
"PO-Revision-Date: 2018-03-23 01:30+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr "å˜ç´”æ–‡ (simple statement)"

#: ../../reference/simple_stmts.rst:10
msgid ""
"Simple statements are comprised within a single logical line. Several simple"
" statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr "å˜ç´”æ–‡ã¨ã¯ã€å˜ä¸€ã®è«–ç†è¡Œå†…ã«åã‚ã‚‰ã‚Œã‚‹æ–‡ã§ã™ã€‚å˜ä¸€ã®è¡Œå†…ã«ã¯ã€è¤‡æ•°ã®å˜ç´”æ–‡ã‚’ã‚»ãƒŸã‚³ãƒ­ãƒ³ã§åŒºåˆ‡ã£ã¦å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å˜ç´”æ–‡ã®æ§‹æ–‡ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™:"

#: ../../reference/simple_stmts.rst:36
msgid "Expression statements"
msgstr "å¼æ–‡ (expression statement)"

#: ../../reference/simple_stmts.rst:42
msgid ""
"Expression statements are used (mostly interactively) to compute and write a"
" value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr "å¼æ–‡ã¯ã€(ä¸»ã«å¯¾è©±çš„ãªä½¿ã„æ–¹ã§ã¯) å€¤ã‚’è¨ˆç®—ã—ã¦å‡ºåŠ›ã™ã‚‹ãŸã‚ã«ä½¿ã£ãŸã‚Šã€(é€šå¸¸ã¯) ãƒ—ãƒ­ã‚·ã‚¸ãƒ£ (procedure: æœ‰æ„ãªçµæœã‚’è¿”ã•ãªã„é–¢æ•°ã®ã“ã¨ã§ã™; Python ã§ã¯ã€ãƒ—ãƒ­ã‚·ã‚¸ãƒ£ã¯å€¤ ``None`` ã‚’è¿”ã—ã¾ã™) ã‚’å‘¼ã³å‡ºã™ãŸã‚ã«ä½¿ã„ã¾ã™ã€‚ãã®ä»–ã®ä½¿ã„æ–¹ã§ã‚‚å¼æ–‡ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã—ã€æœ‰ç”¨ãªã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚å¼æ–‡ã®æ§‹æ–‡ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™:"

#: ../../reference/simple_stmts.rst:51
msgid ""
"An expression statement evaluates the expression list (which may be a single"
" expression)."
msgstr "å¼æ–‡ã¯å¼ã®ãƒªã‚¹ãƒˆ (å˜ä¸€ã®å¼ã®ã“ã¨ã‚‚ã‚ã‚Šã¾ã™) ã‚’å€¤è©•ä¾¡ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:63
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output (see section :ref:`print`) on a line by itself.  "
"(Expression statements yielding ``None`` are not written, so that procedure "
"calls do not cause any output.)"
msgstr "å¯¾è©±ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€å€¤ãŒ ``None`` ã§ãªã„å ´åˆã€å€¤ã‚’çµ„ã¿è¾¼ã¿é–¢æ•° :func:`repr` ã§æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¦ã€ãã®çµæœã®ã¿ã‹ã‚‰ãªã‚‹ä¸€è¡Œã‚’æ¨™æº–å‡ºåŠ›ã«æ›¸ãå‡ºã—ã¾ã™ ( :ref:`print` ç¯€å‚ç…§ ) ã€‚ (``None`` ã«ãªã‚‹å¼æ–‡ã®å€¤ã¯æ›¸ãå‡ºã•ã‚Œãªã„ã®ã§ã€ãƒ—ãƒ­ã‚·ã‚¸ãƒ£å‘¼ã³å‡ºã—ã‚’è¡Œã£ã¦ã‚‚å‡ºåŠ›ã¯å¾—ã‚‰ã‚Œã¾ã›ã‚“ã€‚ )"

#: ../../reference/simple_stmts.rst:73
msgid "Assignment statements"
msgstr "ä»£å…¥æ–‡ (assignment statement)"

#: ../../reference/simple_stmts.rst:83
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr "ä»£å…¥æ–‡ã¯ã€åå‰ã‚’å€¤ã« (å†) æŸç¸›ã—ãŸã‚Šã€å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§ã‚„è¦ç´ ã‚’å¤‰æ›´ã—ãŸã‚Šã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™:"

#: ../../reference/simple_stmts.rst:96 ../../reference/simple_stmts.rst:268
msgid ""
"(See section :ref:`primaries` for the syntax definitions for the last three "
"symbols.)"
msgstr "(æœ«å°¾ã®ä¸‰ã¤ã®ã‚·ãƒ³ãƒœãƒ«ã®æ§‹æ–‡ã«ã¤ã„ã¦ã¯ :ref:`primaries` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚)"

#: ../../reference/simple_stmts.rst:101
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr "ä»£å…¥æ–‡ã¯å¼ã®ãƒªã‚¹ãƒˆ (ã“ã‚Œã¯å˜ä¸€ã®å¼ã§ã‚‚ã€ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸå¼ãƒªã‚¹ãƒˆã§ã‚‚ã‚ˆãã€å¾Œè€…ã¯ã‚¿ãƒ—ãƒ«ã«ãªã‚‹ã“ã¨ã‚’æ€ã„å‡ºã—ã¦ãã ã•ã„) ã‚’è©•ä¾¡ã—ã€å¾—ã‚‰ã‚ŒãŸå˜ä¸€ã®çµæœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ (target) ã®ãƒªã‚¹ãƒˆã«å¯¾ã—ã¦å·¦ã‹ã‚‰å³ã¸ã¨ä»£å…¥ã—ã¦ã‚†ãã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:110
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr "ä»£å…¥ã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ (ãƒªã‚¹ãƒˆ) ã®å½¢å¼ã«å¾“ã£ã¦å†å¸°çš„ã«è¡Œã‚ã‚Œã¾ã™ã€‚ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒå¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (å±æ€§å‚ç…§ã€æ·»å­—è¡¨è¨˜ã€ã¾ãŸã¯ã‚¹ãƒ©ã‚¤ã‚¹) ã®ä¸€éƒ¨ã§ã‚ã‚‹å ´åˆã€ã“ã®å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æœ€çµ‚çš„ã«ä»£å…¥ã‚’å®Ÿè¡Œã—ã¦ã€ãã®ä»£å…¥ãŒæœ‰åŠ¹ãªæ“ä½œã§ã‚ã‚‹ã‹åˆ¤æ–­ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä»£å…¥ãŒä¸å¯èƒ½ãªå ´åˆã«ã¯ä¾‹å¤–ã‚’ç™ºè¡Œã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚å‹ã”ã¨ã«ã¿ã‚‰ã‚Œã‚‹è¦å‰‡ã‚„ã€é€å‡ºã•ã‚Œã‚‹ä¾‹å¤–ã¯ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹å®šç¾©ã§ä¸ãˆã‚‰ã‚Œã¦ã„ã¾ã™ (:ref:`types` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„)."

#: ../../reference/simple_stmts.rst:119
msgid ""
"Assignment of an object to a target list is recursively defined as follows."
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆã¸ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»£å…¥ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦å†å¸°çš„ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:121
msgid ""
"If the target list is a single target: The object is assigned to that "
"target."
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆãŒå˜ä¸€ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‹ã‚‰ãªã‚‹å ´åˆ: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ä»£å…¥ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:123
msgid ""
"If the target list is a comma-separated list of targets: The object must be "
"an iterable with the same number of items as there are targets in the target"
" list, and the items are assigned, from left to right, to the corresponding "
"targets."
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆãŒã€ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸè¤‡æ•°ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã®å ´åˆ: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆä¸­ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ•°ã¨åŒã˜æ•°ã®è¦ç´ ã‹ã‚‰ãªã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ãã®å„è¦ç´ ã¯å·¦ã‹ã‚‰å³ã¸ã¨å¯¾å¿œã™ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ä»£å…¥ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:127
msgid ""
"Assignment of an object to a single target is recursively defined as "
"follows."
msgstr "å˜ä¸€ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸ã®å˜ä¸€ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»£å…¥ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦å†å¸°çš„ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:129
msgid "If the target is an identifier (name):"
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒè­˜åˆ¥å­ (åå‰) ã®å ´åˆ:"

#: ../../reference/simple_stmts.rst:133
msgid ""
"If the name does not occur in a :keyword:`global` statement in the current "
"code block: the name is bound to the object in the current local namespace."
msgstr "åå‰ãŒç¾åœ¨ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å†…ã® :keyword:`global` æ–‡ã«æ›¸ã‹ã‚Œã¦ã„ãªã„å ´åˆ : åå‰ã¯ç¾åœ¨ã®ãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“å†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æŸç¸›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:136
msgid ""
"Otherwise: the name is bound to the object in the current global namespace."
msgstr "ãã‚Œä»¥å¤–ã®å ´åˆ : åå‰ã¯ç¾åœ¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«åå‰ç©ºé–“å†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æŸç¸›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:140
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the"
" object to be deallocated and its destructor (if it has one) to be called."
msgstr "åå‰ãŒã™ã§ã«æŸç¸›æ¸ˆã¿ã®å ´åˆã€å†æŸç¸› (rebind) ãŒãŠã“ãªã‚ã‚Œã¾ã™ã€‚å†æŸç¸›ã«ã‚ˆã£ã¦ã€ä»¥å‰ãã®åå‰ã«æŸç¸›ã•ã‚Œã¦ã„ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ (reference count) ãŒã‚¼ãƒ­ã«ãªã£ãŸå ´åˆã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è§£æ”¾ (deallocate) ã•ã‚Œã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿  (destructor) ãŒ (å­˜åœ¨ã™ã‚Œã°) å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:144
msgid ""
"If the target is a target list enclosed in parentheses or in square "
"brackets: The object must be an iterable with the same number of items as "
"there are targets in the target list, and its items are assigned, from left "
"to right, to the corresponding targets."
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒä¸¸æ‹¬å¼§ã‚„è§’æ‹¬å¼§ã§å›²ã‚ã‚ŒãŸã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆã®å ´åˆ: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆä¸­ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ•°ã¨åŒã˜æ•°ã®è¦ç´ ã‹ã‚‰ãªã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ãã®å„è¦ç´ ã¯å·¦ã‹ã‚‰å³ã¸ã¨å¯¾å¿œã™ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ä»£å…¥ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:151
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not"
" necessarily :exc:`AttributeError`)."
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒå±æ€§å‚ç…§ã®å ´åˆ: å‚ç…§ã•ã‚Œã¦ã„ã‚‹ä¸€æ¬¡èªã®å¼ãŒå€¤è©•ä¾¡ã•ã‚Œã¾ã™ã€‚å€¤ã¯ä»£å…¥å¯èƒ½ãªå±æ€§ã‚’ä¼´ã†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; ãã†ã§ãªã‘ã‚Œã°ã€ :exc:`TypeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚æ¬¡ã«ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã€è¢«ä»£å…¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã—ãŸå±æ€§ã«ä»£å…¥ã—ã¦ã‚ˆã„ã‹å•ã„åˆã‚ã›ã¾ã™; ä»£å…¥ã‚’å®Ÿè¡Œã§ããªã„å ´åˆã€ä¾‹å¤– (é€šå¸¸ã¯ :exc:`AttributeError` ã§ã™ãŒã€å¿…ç„¶ã§ã¯ã‚ã‚Šã¾ã›ã‚“) ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:160
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the RHS expression, ``a.x`` can "
"access either an instance attribute or (if no instance attribute exists) a "
"class attribute.  The LHS target ``a.x`` is always set as an instance "
"attribute, creating it if necessary.  Thus, the two occurrences of ``a.x`` "
"do not necessarily refer to the same attribute: if the RHS expression refers"
" to a class attribute, the LHS creates a new instance attribute as the "
"target of the assignment::"
msgstr "æ³¨æ„: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã€ä»£å…¥æ¼”ç®—å­ã®ä¸¡è¾ºã«å±æ€§å‚ç…§ãŒã‚ã‚‹ã¨ãã€å³è¾ºå¼ã® ``a.x`` ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ã¨ (ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ãŒå­˜åœ¨ã—ãªã‘ã‚Œã°) ã‚¯ãƒ©ã‚¹å±æ€§ã®ã©ã¡ã‚‰ã«ã‚‚ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚å·¦è¾ºã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ ``a.x`` ã¯å¸¸ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ã¨ã—ã¦å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã€å¿…è¦ãªã‚‰ã°ç”Ÿæˆã•ã‚Œã¾ã™ã€‚ã“ã®ã¨ãŠã‚Šã€ç¾ã‚Œã‚‹äºŒã¤ã® ``a.x`` ã¯åŒã˜å€¤ã‚’å‚ç…§ã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“: å³è¾ºå¼ã¯ã‚¯ãƒ©ã‚¹å±æ€§ã‚’å‚ç…§ã—ã€å·¦è¾ºã¯æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã‚’ä»£å…¥ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦ç”Ÿæˆã™ã‚‹ã‚ˆã†ãªã¨ã::"

#: ../../reference/simple_stmts.rst:174
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr "ã“ã®ã“ã¨ã¯ã€ :func:`property` ã§ä½œæˆã•ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ã‚ˆã†ãªãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿å±æ€§ã«å¯¾ã—ã¦ã¯ã€å¿…ãšã—ã‚‚ã‚ã¦ã¯ã¾ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:181
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary). Next, the subscript "
"expression is evaluated."
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒæ·»å­—è¡¨è¨˜ã®å ´åˆ : å‚ç…§ã•ã‚Œã¦ã„ã‚‹ä¸€æ¬¡èªã®å¼ãŒå€¤è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ã¾ãšã€å€¤ã¯å¤‰æ›´å¯èƒ½ãª ( ãƒªã‚¹ãƒˆã®ã‚ˆã†ãª ) ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã€ ( è¾æ›¸ã®ã‚ˆã†ãª ) ãƒãƒƒãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æ¬¡ã«ã€æ·»å­—è¡¨è¨˜ã®è¡¨ã™å¼ãŒå€¤è©•ä¾¡ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:190
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield a plain integer.  If it is negative, the sequence's length is "
"added to it. The resulting value must be a nonnegative integer less than the"
" sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, "
":exc:`IndexError` is raised (assignment to a subscripted sequence cannot add"
" new items to a list)."
msgstr "ä¸€æ¬¡èªãŒå¤‰æ›´å¯èƒ½ãª ( ãƒªã‚¹ãƒˆã®ã‚ˆã†ãª ) ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€ã¾ãšæ·»å­—ã¯æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æ·»å­—ãŒè² æ•°ã®å ´åˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒåŠ ç®—ã•ã‚Œã¾ã™ã€‚æ·»å­—ã¯æœ€çµ‚çš„ã«ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã‚ˆã‚Šã‚‚å°ã•ãªéè² ã®æ•´æ•°ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚æ¬¡ã«ã€æ·»å­—ã‚’ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã«æŒã¤è¦ç´ ã«éä»£å…¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»£å…¥ã—ã¦ã‚ˆã„ã‹ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«å•ã„åˆã‚ã›ã¾ã™ã€‚ç¯„å›²ã‚’è¶…ãˆãŸã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã«å¯¾ã—ã¦ã¯ :exc:`IndexError` ãŒé€å‡ºã•ã‚Œã¾ã™ ( æ·»å­—æŒ‡å®šã•ã‚ŒãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ä»£å…¥ã‚’è¡Œã£ã¦ã‚‚ã€ãƒªã‚¹ãƒˆè¦ç´ ã®æ–°ãŸãªè¿½åŠ ã¯ã§ãã¾ã›ã‚“ ) ã€‚"

#: ../../reference/simple_stmts.rst:201
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr "ä¸€æ¬¡èªãŒ (è¾æ›¸ã®ã‚ˆã†ãª) ãƒãƒƒãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€ã¾ãšæ·»å­—ã¯ãƒãƒƒãƒ—ã®ã‚­ãƒ¼å‹ã¨äº’æ›æ€§ã®ã‚ã‚‹å‹ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚æ¬¡ã«ã€æ·»å­—ã‚’è¢«ä»£å…¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«é–¢é€£ä»˜ã‘ã‚‹ã‚ˆã†ãªã‚­ãƒ¼/ãƒ‡ãƒ¼ã‚¿ã®å¯¾ã‚’ç”Ÿæˆã™ã‚‹ã‚ˆã†ãƒãƒƒãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å•ã„åˆã‚ã›ã¾ã™ã€‚ã“ã®æ“ä½œã§ã¯ã€æ—¢å­˜ã®ã‚­ãƒ¼/å€¤ã®å¯¾ã‚’åŒã˜ã‚­ãƒ¼ã¨åˆ¥ã®å€¤ã§ç½®ãæ›ãˆã¦ã‚‚ã‚ˆãã€(åŒã˜å€¤ã‚’æŒã¤ã‚­ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆ) æ–°ãŸãªã‚­ãƒ¼/å€¤ã®å¯¾ã‚’æŒ¿å…¥ã—ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:209
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The"
" assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"(small) integers.  If either bound is negative, the sequence's length is "
"added to it. The resulting bounds are clipped to lie between zero and the "
"sequence's length, inclusive.  Finally, the sequence object is asked to "
"replace the slice with the items of the assigned sequence.  The length of "
"the slice may be different from the length of the assigned sequence, thus "
"changing the length of the target sequence, if the object allows it."
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒã‚¹ãƒ©ã‚¤ã‚¹ã®å ´åˆ : å‚ç…§ã•ã‚Œã¦ã„ã‚‹ä¸€æ¬¡èªã®å¼ãŒå€¤è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ã¾ãšã€å€¤ã¯å¤‰æ›´å¯èƒ½ãª ( ãƒªã‚¹ãƒˆã®ã‚ˆã†ãª ) ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚è¢«ä»£å…¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯åŒã˜å‹ã‚’æŒã£ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æ¬¡ã«ã€ã‚¹ãƒ©ã‚¤ã‚¹ã®ä¸‹å¢ƒç•Œã¨ä¸Šå¢ƒç•Œã‚’ç¤ºã™å¼ãŒã‚ã‚Œã°è©•ä¾¡ã•ã‚Œã¾ã™ ; ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ãã‚Œãã‚Œã‚¼ãƒ­ã¨ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã§ã™ã€‚ä¸Šä¸‹å¢ƒç•Œã¯æ•´æ•°ã«ãªã‚‰ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã„ãšã‚Œã‹ã®å¢ƒç•ŒãŒè² æ•°ã«ãªã£ãŸå ´åˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒåŠ ç®—ã•ã‚Œã¾ã™ã€‚æœ€çµ‚çš„ã«ã€å¢ƒç•Œã¯ã‚¼ãƒ­ã‹ã‚‰ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã¾ã§ã®å†…åŒ…ã«ãªã‚‹ã‚ˆã†ã«ã‚¯ãƒªãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚æœ€å¾Œã«ã€ã‚¹ãƒ©ã‚¤ã‚¹ã‚’è¢«ä»£å…¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ç½®ãæ›ãˆã¦ã‚ˆã„ã‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å•ã„åˆã‚ã›ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§è¨±ã•ã‚Œã¦ã„ã‚‹é™ã‚Šã€ã‚¹ãƒ©ã‚¤ã‚¹ã®é•·ã•ã¯è¢«ä»£å…¥ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã¨ç•°ãªã£ã¦ã„ã¦ã‚ˆãã€ã“ã®å ´åˆã«ã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒå¤‰æ›´ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:223
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr "ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®æ§‹æ–‡ã¯å¼ã®æ§‹æ–‡ã¨åŒã˜ã§ã‚ã‚‹ã¨ã¿ãªã•ã‚Œã¦ãŠã‚Šã€ç„¡åŠ¹ãªæ§‹æ–‡ã¯ã‚³ãƒ¼ãƒ‰ç”Ÿæˆãƒ•ã‚§ãƒ¼ã‚ºä¸­ã«è©³ç´°ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä¼´ã£ã¦æ‹’å¦ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:227
msgid ""
"WARNING: Although the definition of assignment implies that overlaps between"
" the left-hand side and the right-hand side are 'safe' (for example ``a, b ="
" b, a`` swaps two variables), overlaps *within* the collection of assigned-"
"to variables are not safe!  For instance, the following program prints ``[0,"
" 2]``::"
msgstr "è­¦å‘Š: ä»£å…¥ã®å®šç¾©ã§ã¯ã€å·¦è¾ºå€¤ã¨å³è¾ºå€¤ãŒã‚ªãƒ¼ãƒãƒ©ãƒƒãƒ—ã™ã‚‹ã‚ˆã†ãªä»£å…¥ (ä¾‹ãˆã°ã€ ``a, b = b, a`` ã‚’è¡Œã†ã¨ã€äºŒã¤ã®å¤‰æ•°ã‚’å…¥ã‚Œæ›¿ãˆã¾ã™) ã‚’å®šç¾©ã—ã¦ã‚‚ 'å®‰å…¨ (safe)' ã«ä»£å…¥ã§ãã¾ã™ãŒã€ä»£å…¥å¯¾è±¡ã¨ãªã‚‹å¤‰æ•°ç¾¤ *ã®é–“ã§* ã‚ªãƒ¼ãƒãƒ©ãƒƒãƒ—ãŒã‚ã‚‹å ´åˆã¯å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ä¾‹ãˆã°ã€ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ ``[0, 2]`` ã‚’å‡ºåŠ›ã—ã¦ã—ã¾ã„ã¾ã™::"

#: ../../reference/simple_stmts.rst:241
msgid "Augmented assignment statements"
msgstr "ç´¯ç®—ä»£å…¥æ–‡ (augmented assignment statement)"

#: ../../reference/simple_stmts.rst:259
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr "ç´¯ç®—ä»£å…¥æ–‡ã¯ã€äºŒé …æ¼”ç®—ã¨ä»£å…¥æ–‡ã‚’çµ„ã¿åˆã‚ã›ã¦ä¸€ã¤ã®æ–‡ã«ã—ãŸã‚‚ã®ã§ã™:"

#: ../../reference/simple_stmts.rst:271
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only"
" evaluated once."
msgstr "ç´¯ç®—ä»£å…¥æ–‡ã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ (é€šå¸¸ã®ä»£å…¥æ–‡ã¨é•ã£ã¦ã€ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ã¯èµ·ã“ã‚Šã¾ã›ã‚“) ã¨å¼ãƒªã‚¹ãƒˆã‚’è©•ä¾¡ã—ã€ãã‚Œã‚‰äºŒã¤ã®è¢«æ¼”ç®—å­é–“ã§ç‰¹å®šã®ç´¯ç®—ä»£å…¥å‹ã®äºŒé …æ¼”ç®—ã‚’è¡Œã„ã€çµæœã‚’ã‚‚ã¨ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ä»£å…¥ã—ã¾ã™ã€‚ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¯ä¸€åº¦ã—ã‹è©•ä¾¡ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:276
msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as ``x ="
" x + 1`` to achieve a similar, but not exactly equal effect. In the "
"augmented version, ``x`` is only evaluated once. Also, when possible, the "
"actual operation is performed *in-place*, meaning that rather than creating "
"a new object and assigning that to the target, the old object is modified "
"instead."
msgstr "``x += 1`` ã®ã‚ˆã†ãªç´¯ç®—ä»£å…¥å¼ã¯ã€ ``x = x + 1`` ã®ã‚ˆã†ã«æ›¸ãæ›ãˆã¦ã»ã¼åŒæ§˜ã®å‹•ä½œã«ã§ãã¾ã™ãŒã€å³å¯†ã«ç­‰ä¾¡ã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚ç´¯ç®—ä»£å…¥ã®æ–¹ã§ã¯ã€ ``x`` ã¯ä¸€åº¦ã—ã‹è©•ä¾¡ã•ã‚Œã¾ã›ã‚“ã€‚ã¾ãŸã€å®Ÿéš›ã®å‡¦ç†ã¨ã—ã¦ã€å¯èƒ½ãªã‚‰ã° *ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ (in-place)* æ¼”ç®—ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ä»£å…¥æ™‚ã«æ–°ãŸãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¦ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ä»£å…¥ã™ã‚‹ã®ã§ã¯ãªãã€ä»¥å‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…å®¹ã‚’å¤‰æ›´ã™ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:282
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled"
" the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr "ç´¯ç®—ä»£å…¥æ–‡ã§è¡Œã‚ã‚Œã‚‹ä»£å…¥ã¯ã€ã‚¿ãƒ—ãƒ«ã¸ã®ä»£å…¥ã‚„ã€ä¸€æ–‡ä¸­ã«è¤‡æ•°ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒå­˜åœ¨ã™ã‚‹å ´åˆã‚’é™¤ãã€é€šå¸¸ã®ä»£å…¥ã¨åŒã˜ã‚ˆã†ã«æ‰±ã‚ã‚Œã¾ã™ã€‚åŒæ§˜ã«ã€ç´¯ç®—ä»£å…¥ã§è¡Œã‚ã‚Œã‚‹äºŒé …æ¼”ç®—ã¯ã€å ´åˆã«ã‚ˆã£ã¦ *ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹æ¼”ç®—* ãŒè¡Œã‚ã‚Œã‚‹ã“ã¨ã‚’é™¤ãã€é€šå¸¸ã®äºŒé …æ¼”ç®—ã¨åŒã˜ã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:288
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr "å±æ€§å‚ç…§ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å ´åˆã€ :ref:`ã‚¯ãƒ©ã‚¹ã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ã«ã¤ã„ã¦ã®æ³¨æ„ <attr-target-note>` ã¨åŒæ§˜ã«é€šå¸¸ã®ä»£å…¥ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:295
msgid "The :keyword:`assert` statement"
msgstr ":keyword:`assert` æ–‡"

#: ../../reference/simple_stmts.rst:301
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a"
" program:"
msgstr "assert æ–‡ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã«ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ (debugging assertion) ã‚’ä»•æ›ã‘ã‚‹ãŸã‚ã®ä¾¿åˆ©ãªæ–¹æ³•ã§ã™:"

#: ../../reference/simple_stmts.rst:307
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "å˜ç´”ãªå½¢å¼ ``assert expression`` ã¯ ::"

#: ../../reference/simple_stmts.rst:312
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr "ã¨ç­‰ä¾¡ã§ã™ã€‚æ‹¡å¼µå½¢å¼ ``assert expression1, expression2`` ã¯ã€ã“ã‚Œã¨ç­‰ä¾¡ã§ã™ ::"

#: ../../reference/simple_stmts.rst:321
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable :const:`__debug__` is ``True`` under "
"normal circumstances, ``False`` when optimization is requested (command line"
" option -O).  The current code generator emits no code for an assert "
"statement when optimization is requested at compile time.  Note that it is "
"unnecessary to include the source code for the expression that failed in the"
" error message; it will be displayed as part of the stack trace."
msgstr "ä¸Šè¨˜ã®ç­‰ä¾¡é–¢ä¿‚ã¯ã€ :const:`__debug__` ã¨ :exc:`AssertionError` ãŒã€åŒåã®çµ„ã¿è¾¼ã¿å¤‰æ•°ã‚’å‚ç…§ã—ã¦ã„ã‚‹ã¨ã„ã†å‰æã®ä¸Šã«æˆã‚Šç«‹ã£ã¦ã„ã¾ã™ã€‚ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€çµ„ã¿è¾¼ã¿å¤‰æ•° :const:`__debug__` ã¯é€šå¸¸ã®çŠ¶æ³ã§ã¯ ``True`` ã§ã‚ã‚Šã€æœ€é©åŒ–ãŒãƒªã‚¯ã‚¨ã‚¹ãƒˆã•ã‚ŒãŸå ´åˆï¼ˆã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‚ªãƒ—ã‚·ãƒ§ãƒ³ -Oï¼‰ã¯ ``False`` ã§ã™ã€‚ç¾çŠ¶ã®ã‚³ãƒ¼ãƒ‰ç”Ÿæˆå™¨ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«æœ€é©åŒ–ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹ã¨ assert æ–‡ã«å¯¾ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’å…¨ãå‡ºåŠ›ã—ã¾ã›ã‚“ã€‚å®Ÿè¡Œã«å¤±æ•—ã—ãŸå¼ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…ã«å…¥ã‚Œã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“; ã‚³ãƒ¼ãƒ‰ã¯ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹å†…ã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:330
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ":const:`__debug__` ã¸ã®ä»£å…¥ã¯ä¸æ­£ãªæ“ä½œã§ã™ã€‚çµ„ã¿è¾¼ã¿å¤‰æ•°ã®å€¤ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒé–‹å§‹ã™ã‚‹ã¨ãã«æ±ºå®šã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:337
msgid "The :keyword:`pass` statement"
msgstr ":keyword:`pass` æ–‡"

#: ../../reference/simple_stmts.rst:346
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ":keyword:`pass` ã¯ãƒŒãƒ«æ“ä½œ (null operation) ã§ã™ --- :keyword:`pass` ãŒå®Ÿè¡Œã•ã‚Œã¦ã‚‚ã€ä½•ã‚‚èµ·ãã¾ã›ã‚“ã€‚ :keyword:`pass` ã¯ã€æ§‹æ–‡æ³•çš„ã«ã¯æ–‡ãŒå¿…è¦ã ãŒã€ã‚³ãƒ¼ãƒ‰ã¨ã—ã¦ã¯ä½•ã‚‚å®Ÿè¡Œã—ãŸããªã„å ´åˆã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ã¨ã—ã¦æœ‰ç”¨ã§ã™ã€‚ä¾‹ãˆã°::"

#: ../../reference/simple_stmts.rst:358
msgid "The :keyword:`del` statement"
msgstr ":keyword:`del` æ–‡"

#: ../../reference/simple_stmts.rst:368
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‰Šé™¤ (deletion) ã¯ã€ä»£å…¥ã®å®šç¾©ã¨éå¸¸ã«ä¼¼ãŸæ–¹æ³•ã§å†å¸°çš„ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã“ã§ã¯å®Œå…¨ãªè©³ç´°ã¯è¨˜è¿°ã›ãšã€ã„ãã¤ã‹ã®ãƒ’ãƒ³ãƒˆã‚’è¿°ã¹ã‚‹ã«ã¨ã©ã‚ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:371
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªã‚¹ãƒˆã«å¯¾ã™ã‚‹å‰Šé™¤ã¯ã€å„ã€…ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’å·¦ã‹ã‚‰å³ã¸ã¨é †ã«å†å¸°çš„ã«å‰Šé™¤ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:377
msgid ""
"Deletion of a name removes the binding of that name  from the local or "
"global namespace, depending on whether the name occurs in a "
":keyword:`global` statement in the same code block.  If the name is unbound,"
" a :exc:`NameError` exception will be raised."
msgstr "åå‰ã«å¯¾ã—ã¦å‰Šé™¤ã‚’è¡Œã†ã¨ã€ãƒ­ãƒ¼ã‚«ãƒ«ã¾ãŸã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«åå‰ç©ºé–“ã§ã®ãã®åå‰ã®æŸç¸›ã‚’è§£é™¤ã—ã¾ã™ã€‚ã©ã¡ã‚‰ã®åå‰ç©ºé–“ã‹ã¯ã€åå‰ãŒåŒã˜ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å†…ã® :keyword:`global` æ–‡ã§å®£è¨€ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã«ã‚ˆã‚Šã¾ã™ã€‚åå‰ãŒæœªæŸç¸› (unbound) ã§ã‚ã‚‹ã°ã‚ã„ã€ :exc:`NameError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:384
msgid ""
"It is illegal to delete a name from the local namespace if it occurs as a "
"free variable in a nested block."
msgstr "ãƒã‚¹ãƒˆã—ãŸãƒ–ãƒ­ãƒƒã‚¯ä¸­ã§è‡ªç”±å¤‰æ•°ã«ãªã£ã¦ã„ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«åå‰ç©ºé–“ä¸Šã®åå‰ã«å¯¾ã™ã‚‹å‰Šé™¤ã¯ä¸æ­£ãªæ“ä½œã«ãªã‚Šã¾ã™"

#: ../../reference/simple_stmts.rst:389
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr "å±æ€§å‚ç…§ã€æ·»å­—è¡¨è¨˜ã€ãŠã‚ˆã³ã‚¹ãƒ©ã‚¤ã‚¹ã®å‰Šé™¤æ“ä½œã¯ã€å¯¾è±¡ã¨ãªã‚‹ä¸€æ¬¡èªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æ¸¡ã•ã‚Œã¾ã™; ã‚¹ãƒ©ã‚¤ã‚¹ã®å‰Šé™¤ã¯ä¸€èˆ¬çš„ã«ã¯é©åˆ‡ãªå‹ã®ç©ºã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ä»£å…¥ã™ã‚‹ã®ã¨ç­‰ä¾¡ã§ã™ (ãŒã€ã“ã®ä»•æ§˜è‡ªä½“ã‚‚ã‚¹ãƒ©ã‚¤ã‚¹ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§æ±ºå®šã•ã‚Œã¦ã„ã¾ã™)ã€‚"

#: ../../reference/simple_stmts.rst:398
msgid "The :keyword:`print` statement"
msgstr ":keyword:`print` æ–‡"

#: ../../reference/simple_stmts.rst:406
msgid ""
":keyword:`print` evaluates each expression in turn and writes the resulting "
"object to standard output (see below).  If an object is not a string, it is "
"first converted to a string using the rules for string conversions.  The "
"(resulting or original) string is then written.  A space is written before "
"each object is (converted and) written, unless the output system believes it"
" is positioned at the beginning of a line.  This is the case (1) when no "
"characters have yet been written to standard output, (2) when the last "
"character written to standard output is a whitespace character except ``' "
"'``, or (3) when the last write operation on standard output was not a "
":keyword:`print` statement. (In some cases it may be functional to write an "
"empty string to standard output for this reason.)"
msgstr ":keyword:`print` ã¯ã€å¼ã‚’é€æ¬¡çš„ã«è©•ä¾¡ã—ã€å¾—ã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¨™æº–å‡ºåŠ›ã«æ›¸ãå‡ºã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ã€ã¾ãšæ–‡å­—åˆ—å¤‰æ›è¦å‰‡ã‚’ä½¿ã£ã¦æ–‡å­—åˆ—ã«å¤‰æ›ã•ã‚Œã€æ¬¡ã„ã§ ( å¾—ã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã‹ã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã®æ–‡å­—åˆ—ãŒ ) æ›¸ãå‡ºã•ã‚Œã¾ã™ã€‚å‡ºåŠ›ç³»ã®ç¾åœ¨ã®æ›¸ãå‡ºã—ä½ç½®ãŒè¡Œé ­ã«ã‚ã‚‹ã¨è€ƒãˆã‚‰ã‚Œã‚‹å ´åˆã‚’é™¤ãã€å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‡ºåŠ›å‰ã«ã‚¹ãƒšãƒ¼ã‚¹ãŒä¸€ã¤å‡ºåŠ›ã•ã‚Œã¾ã™ã€‚è¡Œé ­ã«ã‚ã‚‹å ´åˆã¨ã¯ã€ (1) æ¨™æº–å‡ºåŠ›ã«ã¾ã ä½•ã‚‚æ›¸ãå‡ºã•ã‚Œã¦ã„ãªã„å ´åˆã€ (2) æ¨™æº–å‡ºåŠ›ã«æœ€å¾Œã«æ›¸ãå‡ºã•ã‚ŒãŸæ–‡å­—ãŒ ``' '`` ã‚’é™¤ãç©ºç™½ã§ã‚ã‚‹ã€ã¾ãŸã¯ (3) æ¨™æº–å‡ºåŠ›ã«å¯¾ã™ã‚‹æœ€å¾Œã®æ›¸ãå‡ºã—æ“ä½œãŒ :keyword:`print` æ–‡ã«ã‚ˆã‚‹ã‚‚ã®ã§ã¯ãªã„å ´åˆã€ã§ã™ã€‚ ( ã“ã†ã—ãŸç†ç”±ã‹ã‚‰ã€å ´åˆã«ã‚ˆã£ã¦ã¯ç©ºæ–‡å­—ã‚’æ¨™æº–å‡ºåŠ›ã«æ›¸ãå‡ºã™ã¨ä¾¿åˆ©ãªã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ )"

#: ../../reference/simple_stmts.rst:420
msgid ""
"Objects which act like file objects but which are not the built-in file "
"objects often do not properly emulate this aspect of the file object's "
"behavior, so it is best not to rely on this."
msgstr "çµ„ã¿è¾¼ã¿ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã„ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ä¼¼ãŸå‹•ä½œã‚’ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€çµ„ã¿è¾¼ã¿ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæŒã¤ä¸Šè¨˜ã®æ€§è³ªã‚’é©åˆ‡ã«ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã¦ã„ãªã„ã“ã¨ãŒã‚ã‚‹ãŸã‚ã€å½“ã¦ã«ã—ãªã„ã»ã†ãŒã‚ˆã„ã§ã—ã‚‡ã†ã€‚"

#: ../../reference/simple_stmts.rst:430
msgid ""
"A ``'\\n'`` character is written at the end, unless the :keyword:`print` "
"statement ends with a comma.  This is the only action if the statement "
"contains just the keyword :keyword:`print`."
msgstr ":keyword:`print` æ–‡ãŒã‚«ãƒ³ãƒã§çµ‚äº†ã—ã¦ã„ãªã„é™ã‚Šã€æœ«å°¾ã«ã¯æ–‡å­— ``'\\n'`` ãŒæ›¸ãå‡ºã•ã‚Œã¾ã™ã€‚ã“ã®ä»•æ§˜ã¯ã€æ–‡ã«äºˆç´„èª :keyword:`print` ãŒã‚ã‚‹å ´åˆã®ã¿ã®å‹•ä½œã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:440
msgid ""
"Standard output is defined as the file object named ``stdout`` in the built-"
"in module :mod:`sys`.  If no such object exists, or if it does not have a "
":meth:`write` method, a :exc:`RuntimeError` exception is raised."
msgstr "æ¨™æº–å‡ºåŠ›ã¯ã€çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`sys` å†…ã§ ``stdout`` ã¨ã„ã†åå‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚è©²å½“ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå­˜åœ¨ã—ãªã„ã‹ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã« :meth:`write` ãƒ¡ã‚½ãƒƒãƒ‰ãŒãªã„å ´åˆã€ :exc:`RuntimeError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ ."

#: ../../reference/simple_stmts.rst:446
msgid ""
":keyword:`print` also has an extended form, defined by the second portion of"
" the syntax described above. This form is sometimes referred to as "
"\":keyword:`print` chevron.\" In this form, the first expression after the "
"``>>`` must evaluate to a \"file-like\" object, specifically an object that "
"has a :meth:`write` method as described above.  With this extended form, the"
" subsequent expressions are printed to this file object.  If the first "
"expression evaluates to ``None``, then ``sys.stdout`` is used as the file "
"for output."
msgstr ":keyword:`print` ã«ã¯ã€ä¸Šã§èª¬æ˜ã—ãŸæ§‹æ–‡ã®ç¬¬äºŒå½¢å¼ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹æ‹¡å¼µå½¢å¼ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®å½¢å¼ã¯ã€ \" å±±å½¢ :keyword:`print` è¡¨è¨˜ (:keyword:`print` chevron)\" ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã®å½¢å¼ã§ã¯ã€ ``>>`` ã®ç›´å¾Œã«ãã‚‹æœ€åˆã®å¼ã®å€¤è©•ä¾¡çµæœã¯ \" ãƒ•ã‚¡ã‚¤ãƒ«é¡ä¼¼ (file-like)\" ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã¨ã‚Šã‚ã‘ä¸Šã§è¿°ã¹ãŸã‚ˆã†ã« :meth:`write` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®æ‹¡å¼µå½¢å¼ã§ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã™ã‚‹å¼ã‚ˆã‚Šã‚‚å¾Œã‚ã®å¼ãŒã€æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å‡ºåŠ›ã•ã‚Œã¾ã™ã€‚æœ€åˆã®å¼ã®å€¤è©•ä¾¡çµæœãŒ ``None`` ã«ãªã£ãŸå ´åˆã€ ``sys.stdout`` ãŒå‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:458
msgid "The :keyword:`return` statement"
msgstr ":keyword:`return` æ–‡"

#: ../../reference/simple_stmts.rst:468
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ":keyword:`return` ã¯ã€é–¢æ•°å®šç¾©å†…ã§æ§‹æ–‡æ³•çš„ã«ãƒã‚¹ãƒˆã—ã¦ç¾ã‚Œã¾ã™ãŒã€ãƒã‚¹ãƒˆã—ãŸã‚¯ãƒ©ã‚¹å®šç¾©å†…ã«ã¯ç¾ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:471
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr "å¼ãƒªã‚¹ãƒˆãŒã‚ã‚‹å ´åˆã€ãƒªã‚¹ãƒˆãŒå€¤è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ ``None`` ã§ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:473
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ":keyword:`return` ã‚’ä½¿ã†ã¨ã€å¼ãƒªã‚¹ãƒˆ (ã¾ãŸã¯ ``None``) ã‚’æˆ»ã‚Šå€¤ã¨ã—ã¦ã€ç¾åœ¨ã®é–¢æ•°å‘¼ã³å‡ºã—ã‹ã‚‰æŠœã‘å‡ºã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:478
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with"
" a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really leaving the function."
msgstr ":keyword:`return` ã«ã‚ˆã£ã¦ã€ :keyword:`finally` ç¯€ã‚’ã¨ã‚‚ãªã† :keyword:`try` æ–‡ã®å¤–ã«å‡¦ç†ãŒå¼•ãæ¸¡ã•ã‚Œã‚‹ã¨ã€å®Ÿéš›ã«é–¢æ•°ã‹ã‚‰æŠœã‘ã‚‹å‰ã« :keyword:`finally` ç¯€ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:482
msgid ""
"In a generator function, the :keyword:`return` statement is not allowed to "
"include an :token:`expression_list`.  In that context, a bare "
":keyword:`return` indicates that the generator is done and will cause "
":exc:`StopIteration` to be raised."
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã®å ´åˆã«ã¯ã€ :keyword:`return` æ–‡ã®ä¸­ã« :token:`expression_list` ã‚’å…¥ã‚Œã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã®å‡¦ç†ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã¯ã€å˜ä½“ã® :keyword:`return` ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å‡¦ç†ã‚’çµ‚äº†ã— :exc:`StopIteration` ã‚’é€å‡ºã•ã›ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:491
msgid "The :keyword:`yield` statement"
msgstr ":keyword:`yield` æ–‡"

#: ../../reference/simple_stmts.rst:503
msgid ""
"The :keyword:`yield` statement is only used when defining a generator "
"function, and is only used in the body of the generator function. Using a "
":keyword:`yield` statement in a function definition is sufficient to cause "
"that definition to create a generator function instead of a normal function."
msgstr ":keyword:`yield` æ–‡ã¯ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•° (generator function) ã‚’å®šç¾©ã™ã‚‹ã¨ãã ã‘ä½¿ã‚ã‚Œã€ã‹ã¤ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã®æœ¬ä½“ã®ä¸­ã§ã ã‘ç”¨ã„ã‚‰ã‚Œã¾ã™ã€‚é–¢æ•°å®šç¾©ä¸­ã§ :keyword:`yield` æ–‡ã‚’ä½¿ã†ã ã‘ã§ã€é–¢æ•°å®šç¾©ã¯é€šå¸¸ã®é–¢æ•°ã§ãªãã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:508
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator iterator, or more commonly, a generator.  The body of the "
"generator function is executed by calling the generator's "
":meth:`~generator.next` method repeatedly until it raises an exception."
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ (generator iterator) ã€ä¸€èˆ¬çš„ã«ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ (generator) ã‚’è¿”ã—ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã®æœ¬ä½“ã¯ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã® :meth:`~generator.next` ãŒä¾‹å¤–ã‚’ç™ºè¡Œã™ã‚‹ã¾ã§ç¹°ã‚Šè¿”ã—å‘¼ã³å‡ºã—ã¦å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:513
msgid ""
"When a :keyword:`yield` statement is executed, the state of the generator is"
" frozen and the value of :token:`expression_list` is returned to "
":meth:`~generator.next`'s caller.  By \"frozen\" we mean that all local "
"state is retained, including the current bindings of local variables, the "
"instruction pointer, and the internal evaluation stack: enough information "
"is saved so that the next time :meth:`~generator.next` is invoked, the "
"function can proceed exactly as if the :keyword:`yield` statement were just "
"another external call."
msgstr ":keyword:`yield` æ–‡ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ã€ç¾åœ¨ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®çŠ¶æ…‹ã¯å‡çµ (freeze) ã•ã‚Œã€ :token:`expression_list` ã®å€¤ãŒ :meth:`~generator.next` ã®å‘¼ã³å‡ºã—å´ã«è¿”ã•ã‚Œã¾ã™ã€‚ã“ã“ã§ã® \"å‡çµ\" ã¯ã€ãƒ­ãƒ¼ã‚«ãƒ«ãªå¤‰æ•°ã¸ã®æŸç¸›ã€å‘½ä»¤ãƒã‚¤ãƒ³ã‚¿ (instruction pointer) ã€ãŠã‚ˆã³å†…éƒ¨å®Ÿè¡Œã‚¹ã‚¿ãƒƒã‚¯ (internal evaluation stack) ã‚’å«ã‚€ã€å…¨ã¦ã®ãƒ­ãƒ¼ã‚«ãƒ«ãªçŠ¶æ…‹ãŒä¿å­˜ã•ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ : ã™ãªã‚ã¡ã€å¿…è¦ãªæƒ…å ±ã‚’ä¿å­˜ã—ã¦ãŠãã€æ¬¡ã« :meth:`~generator.next` ãŒå‘¼ã³å‡ºã•ã‚ŒãŸéš›ã«ã€é–¢æ•°ãŒ :keyword:`yield` æ–‡ã‚’ã‚ãŸã‹ã‚‚ã‚‚ã†ä¸€ã¤ã®å¤–éƒ¨å‘¼å‡ºã—ã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«å‡¦ç†ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:521
msgid ""
"As of Python version 2.5, the :keyword:`yield` statement is now allowed in "
"the :keyword:`try` clause of a :keyword:`try` ...  :keyword:`finally` "
"construct.  If the generator is not resumed before it is finalized (by "
"reaching a zero reference count or by being garbage collected), the "
"generator-iterator's :meth:`close` method will be called, allowing any "
"pending :keyword:`finally` clauses to execute."
msgstr "Python ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 2.5 ã§ã¯ã€ :keyword:`yield` æ–‡ãŒ :keyword:`try` ... :keyword:`finally` æ§‹é€ ã«ãŠã‘ã‚‹ :keyword:`try` ç¯€ã§è¨±ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒçµ‚äº†ï¼ˆ finalized ï¼‰ã•ã‚Œã‚‹ï¼ˆå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«ãªã‚‹ã‹ã€ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã•ã‚Œã‚‹ ) ã¾ã§ã«å†é–‹ã•ã‚Œãªã‘ã‚Œã°ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ - ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã® :meth:`close` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã€ç•™ä¿ã•ã‚Œã¦ã„ã‚‹ :keyword:`finally` ç¯€ãŒå®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:528
msgid ""
"For full details of :keyword:`yield` semantics, refer to the "
":ref:`yieldexpr` section."
msgstr ":keyword:`yield` ã®æ„å‘³ã®å®Œå…¨ãªèª¬æ˜ã¯ã€ :ref:`yieldexpr` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/simple_stmts.rst:533
msgid ""
"In Python 2.2, the :keyword:`yield` statement was only allowed when the "
"``generators`` feature has been enabled.  This ``__future__`` import "
"statement was used to enable the feature::"
msgstr "Python 2.2 ã§ã¯ã€ ``generators`` æ©Ÿèƒ½ãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹å ´åˆã«ã®ã¿ :keyword:`yield` æ–‡ã‚’ä½¿ãˆã¾ã—ãŸã€‚ã“ã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹ã«ã™ã‚‹ãŸã‚ã® ``__future__`` import æ–‡ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã—ãŸã€‚ ::"

#: ../../reference/simple_stmts.rst:543
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - å˜ç´”ãªã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿"

#: ../../reference/simple_stmts.rst:543
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr "Python ã¸ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¨ :keyword:`yield` æ–‡ã®å°å…¥ææ¡ˆã€‚"

#: ../../reference/simple_stmts.rst:546
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`0342` - æ‹¡å¼µã•ã‚ŒãŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚’ç”¨ã„ãŸã‚³ãƒ«ãƒ¼ãƒãƒ³"

#: ../../reference/simple_stmts.rst:546
msgid ""
"The proposal that, among other generator enhancements, proposed allowing "
":keyword:`yield` to appear inside a :keyword:`try` ... :keyword:`finally` "
"block."
msgstr "ãã®ä»–ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®æ”¹å–„ã¨å…±ã«ã€ :keyword:`yield` ãŒ :keyword:`try` ... :keyword:`finally` ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­ã«å­˜åœ¨ã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã™ã‚‹ãŸã‚ã®ææ¡ˆ"

#: ../../reference/simple_stmts.rst:553
msgid "The :keyword:`raise` statement"
msgstr ":keyword:`raise` æ–‡"

#: ../../reference/simple_stmts.rst:563
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the last exception"
" that was active in the current scope.  If no exception is active in the "
"current scope, a :exc:`TypeError` exception is raised indicating that this "
"is an error (if running under IDLE, a :exc:`Queue.Empty` exception is raised"
" instead)."
msgstr "å¼ã‚’ä¼´ã‚ãªã„å ´åˆã€ :keyword:`raise` ã¯ç¾åœ¨ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§æœ€çµ‚çš„ã«æœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹ä¾‹å¤–ã‚’å†é€å‡ºã—ã¾ã™ã€‚ãã®ã‚ˆã†ãªä¾‹å¤–ãŒç¾åœ¨ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ãªã„å ´åˆã€ :exc:`TypeError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¦ã€ã“ã‚ŒãŒã‚¨ãƒ©ãƒ¼ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ (IDLE ã§å®Ÿè¡Œã—ãŸå ´åˆã¯ã€ä»£ã‚ã‚Šã« exceptionQueue.Empty ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ ) ã€‚"

#: ../../reference/simple_stmts.rst:568
msgid ""
"Otherwise, :keyword:`raise` evaluates the expressions to get three objects, "
"using ``None`` as the value of omitted expressions.  The first two objects "
"are used to determine the *type* and *value* of the exception."
msgstr "ãã‚Œä»¥å¤–ã®å ´åˆã€ :keyword:`raise` ã¯å¼ã‚’å€¤è©•ä¾¡ã—ã¦ã€ä¸‰ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã—ã¾ã™ã€‚ã“ã®ã¨ãã€ ``None`` ã‚’çœç•¥ã•ã‚ŒãŸå¼ã®å€¤ã¨ã—ã¦ä½¿ã„ã¾ã™ã€‚æœ€åˆã®äºŒã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ä¾‹å¤–ã® * å‹ (type)* ã¨ä¾‹å¤–ã® * å€¤ (value)* ã‚’æ±ºå®šã™ã‚‹ãŸã‚ã«ç”¨ã„ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:572
msgid ""
"If the first object is an instance, the type of the exception is the class "
"of the instance, the instance itself is the value, and the second object "
"must be ``None``."
msgstr "æœ€åˆã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹å ´åˆã€ä¾‹å¤–ã®å‹ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¯ãƒ©ã‚¹ã«ãªã‚Šã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è‡ªä½“ãŒä¾‹å¤–ã®å€¤ã«ãªã‚Šã¾ã™ã€‚ã“ã®ã¨ãç¬¬äºŒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ ``None`` ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:576
msgid ""
"If the first object is a class, it becomes the type of the exception. The "
"second object is used to determine the exception value: If it is an instance"
" of the class, the instance becomes the exception value. If the second "
"object is a tuple, it is used as the argument list for the class "
"constructor; if it is ``None``, an empty argument list is used, and any "
"other object is treated as a single argument to the constructor.  The "
"instance so created by calling the constructor is used as the exception "
"value."
msgstr "æœ€åˆã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¯ãƒ©ã‚¹ã®å ´åˆã€ä¾‹å¤–ã®å‹ã«ãªã‚Šã¾ã™ã€‚ç¬¬äºŒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ä¾‹å¤–ã®å€¤ã‚’æ±ºã‚ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ : ç¬¬äºŒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãªã‚‰ã°ã€ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒä¾‹å¤–ã®å€¤ã«ãªã‚Šã¾ã™ã€‚ç¬¬äºŒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¿ãƒ—ãƒ«ã®å ´åˆã€ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«å¯¾ã™ã‚‹å¼•æ•°ãƒªã‚¹ãƒˆã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ ; ``None`` ãªã‚‰ã€ç©ºã®å¼•æ•°ãƒªã‚¹ãƒˆã¨ã—ã¦æ‰±ã‚ã‚Œã€ãã‚Œä»¥å¤–ã®å‹ãªã‚‰ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«å¯¾ã™ã‚‹å˜ä¸€ã®å¼•æ•°ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚ã“ã®ã‚ˆã†ã«ã—ã¦ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å‘¼ã³å‡ºã—ã¦ç”Ÿæˆã—ãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒä¾‹å¤–ã®å€¤ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:586
msgid ""
"If a third object is present and not ``None``, it must be a traceback object"
" (see section :ref:`types`), and it is substituted instead of the current "
"location as the place where the exception occurred.  If the third object is "
"present and not a traceback object or ``None``, a :exc:`TypeError` exception"
" is raised.  The three-expression form of :keyword:`raise` is useful to re-"
"raise an exception transparently in an except clause, but :keyword:`raise` "
"with no expressions should be preferred if the exception to be re-raised was"
" the most recently active exception in the current scope."
msgstr "ç¬¬ä¸‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå­˜åœ¨ã—ã€ã‹ã¤ ``None`` ã§ãªã‘ã‚Œã°ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ ( :ref:`types` ç¯€å‚ç…§ ) ã€‚ã¾ãŸã€ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸå ´æ‰€ã¯ç¾åœ¨ã®å‡¦ç†ä½ç½®ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚ç¬¬ä¸‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå­˜åœ¨ã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚ ``None`` ã§ã‚‚ãªã‘ã‚Œã°ã€ :exc:`TypeError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ :keyword:`raise` ã®ä¸‰é€£å¼å‹ã¯ã€ :keyword:`except` ç¯€ã‹ã‚‰é€éçš„ã«ä¾‹å¤–ã‚’å†é€å‡ºã™ã‚‹ã®ã«ä¾¿åˆ©ã§ã™ãŒã€å†é€å‡ºã™ã¹ãä¾‹å¤–ãŒç¾åœ¨ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§ç™ºç”Ÿã—ãŸæœ€ã‚‚æ–°ã—ã„ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªä¾‹å¤–ã§ã‚ã‚‹å ´åˆã«ã¯ã€å¼ãªã—ã® :keyword:`raise` ã‚’ä½¿ã†ã‚ˆã†æ¨å¥¨ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:595
msgid ""
"Additional information on exceptions can be found in section "
":ref:`exceptions`, and information about handling exceptions is in section "
":ref:`try`."
msgstr "ä¾‹å¤–ã«é–¢ã™ã‚‹è¿½åŠ æƒ…å ±ã¯ :ref:`exceptions` ç¯€ã«ã‚ã‚Šã¾ã™ã€‚ã¾ãŸã€ä¾‹å¤–å‡¦ç†ã«é–¢ã™ã‚‹æƒ…å ±ã¯ :ref:`try` ç¯€ã«ã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:602
msgid "The :keyword:`break` statement"
msgstr ":keyword:`break` æ–‡"

#: ../../reference/simple_stmts.rst:613
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or "
":keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ":keyword:`break` æ–‡ã¯ã€æ§‹æ–‡ã¨ã—ã¦ã¯ :keyword:`for` ãƒ«ãƒ¼ãƒ—ã‚„ :keyword:`while` ãƒ«ãƒ¼ãƒ—ã®å†…å´ã§ã®ã¿å‡ºç¾ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€ãƒ«ãƒ¼ãƒ—å†…ã®é–¢æ•°å®šç¾©ã‚„ã‚¯ãƒ©ã‚¹å®šç¾©ã®å†…å´ã«ã¯å‡ºç¾ã§ãã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:619
msgid ""
"It terminates the nearest enclosing loop, skipping the optional "
":keyword:`else` clause if the loop has one."
msgstr ":keyword:`break` æ–‡ã¯ã€æ–‡ã‚’å›²ã†æœ€ã‚‚å†…å´ã®ãƒ«ãƒ¼ãƒ—ã‚’çµ‚äº†ã•ã›ã€ãƒ«ãƒ¼ãƒ—ã«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® :keyword:`else` ç¯€ãŒã‚ã‚‹å ´åˆã«ã¯ãã‚Œã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:624
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control"
" target keeps its current value."
msgstr ":keyword:`for` ãƒ«ãƒ¼ãƒ—ã‚’ :keyword:`break` ã«ã‚ˆã£ã¦çµ‚äº†ã™ã‚‹ã¨ã€ãƒ«ãƒ¼ãƒ—åˆ¶å¾¡ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¯ãã®æ™‚ã®å€¤ã‚’ä¿æŒã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:629
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really leaving the loop."
msgstr ":keyword:`break` ãŒ :keyword:`finally` ç¯€ã‚’ä¼´ã† :keyword:`try` æ–‡ã®å¤–å´ã«å‡¦ç†ã‚’æ¸¡ã™éš›ã«ã¯ã€ãƒ«ãƒ¼ãƒ—ã‚’å®Ÿéš›ã«æŠœã‘ã‚‹å‰ã«ãã® :keyword:`finally` ç¯€ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:637
msgid "The :keyword:`continue` statement"
msgstr ":keyword:`continue` æ–‡"

#: ../../reference/simple_stmts.rst:649
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"or :keyword:`finally` clause within that loop.  It continues with the next "
"cycle of the nearest enclosing loop."
msgstr ":keyword:`continue` æ–‡ã¯ :keyword:`for` ãƒ«ãƒ¼ãƒ—ã‚„ :keyword:`while` ãƒ«ãƒ¼ãƒ—å†…ã®ãƒã‚¹ãƒˆã§æ§‹æ–‡æ³•çš„ã«ã®ã¿ç¾ã‚Œã¾ã™ãŒã€ãƒ«ãƒ¼ãƒ—å†…ã®é–¢æ•°å®šç¾©ã‚„ã‚¯ãƒ©ã‚¹å®šç¾©ã€ :keyword:`finally` å¥ã®ä¸­ã«ã¯ç¾ã‚Œã¾ã›ã‚“ã€‚ :keyword:`continue` æ–‡ã¯ã€æ–‡ã‚’å›²ã†æœ€ã‚‚å†…å´ã®ãƒ«ãƒ¼ãƒ—ã®æ¬¡ã®å‘¨æœŸã«å‡¦ç†ã‚’ç¶™ç¶šã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:654
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`finally` clause is executed"
" before really starting the next loop cycle."
msgstr ":keyword:`continue` ãŒ :keyword:`finally` å¥ã‚’æŒã£ãŸ :keyword:`try` æ–‡ã‚’æŠœã‘ã‚‹ã¨ãã€ãã® :keyword:`finally` å¥ãŒæ¬¡ã®ãƒ«ãƒ¼ãƒ—ã‚µã‚¤ã‚¯ãƒ«ã‚’å§‹ã‚ã‚‹å‰ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:663
msgid "The :keyword:`import` statement"
msgstr ":keyword:`import` æ–‡"

#: ../../reference/simple_stmts.rst:683
msgid ""
"Import statements are executed in two steps: (1) find a module, and "
"initialize it if necessary; (2) define a name or names in the local "
"namespace (of the scope where the :keyword:`import` statement occurs). The "
"statement comes in two forms differing on whether it uses the "
":keyword:`from` keyword. The first form (without :keyword:`from`) repeats "
"these steps for each identifier in the list. The form with :keyword:`from` "
"performs step (1) once, and then performs step (2) repeatedly."
msgstr "import æ–‡ã¯ã€ (1) ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¢ã—ã€å¿…è¦ãªã‚‰åˆæœŸåŒ– (initialize) ã™ã‚‹ ; (:keyword:`import` æ–‡ã®ã‚ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ã«ãŠã‘ã‚‹ ) ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ç©ºé–“ã§åå‰ã‚’å®šç¾©ã™ã‚‹ã€ã®äºŒã¤ã®æ®µéšã‚’è¸ã‚“ã§åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚ :keyword:`import` æ–‡ã«ã¯ã€ :keyword:`from` ã‚’ä½¿ã†ã‹ä½¿ã‚ãªã„ã‹ã® 2 ç¨®é¡ã®å½¢å¼ãŒã‚ã‚Šã¾ã™ã€‚ç¬¬ä¸€å½¢å¼ (:keyword:`from` ã®ãªã„å½¢å¼ ) ã¯ã€ä¸Šè¨˜ã®æ®µéšã‚’ãƒªã‚¹ãƒˆä¸­ã«ã‚ã‚‹å„è­˜åˆ¥å­ã«å¯¾ã—ã¦ç¹°ã‚Šè¿”ã—å®Ÿè¡Œã—ã¦ã„ãã¾ã™ã€‚ :keyword:`from` ã®ã‚ã‚‹å½¢å¼ã§ã¯ã€ (1) ã‚’ä¸€åº¦ã ã‘è¡Œã„ã€æ¬¡ã„ã§ (2) ã‚’ç¹°ã‚Šè¿”ã—å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:694
msgid ""
"To understand how step (1) occurs, one must first understand how Python "
"handles hierarchical naming of modules. To help organize modules and provide"
" a hierarchy in naming, Python has a concept of packages. A package can "
"contain other packages and modules while modules cannot contain other "
"modules or packages. From a file system perspective, packages are "
"directories and modules are files."
msgstr "ã‚¹ãƒ†ãƒƒãƒ— (1) ãŒã©ã®ã‚ˆã†ã«è¡Œã‚ã‚Œã‚‹ã®ã‹ã‚’ç†è§£ã™ã‚‹ã«ã¯ã€ã¾ãšã€ Python ãŒéšå±¤çš„ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’ã©ã†æ‰±ã†ã®ã‹ã‚’ç†è§£ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’çµ„ç¹”åŒ–ã—åå‰ã«éšå±¤ã‚’æŒãŸã›ã‚‹ãŸã‚ã«ã€ Python ã¯ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ã„ã†æ¦‚å¿µã‚’æŒã£ã¦ã„ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’å«ã‚€ã“ã¨ãŒã§ããªã„ã®ã«å¯¾ã—ã¦ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ä»–ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å«ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®è¦–ç‚¹ã‹ã‚‰è¦‹ã‚‹ã¨ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:704
msgid ""
"Once the name of the module is known (unless otherwise specified, the term "
"\"module\" will refer to both packages and modules), searching for the "
"module or package can begin. The first place checked is :data:`sys.modules`,"
" the cache of all modules that have been imported previously. If the module "
"is found there then it is used in step (2) of import."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å ( ç‰¹ã«è¨˜è¿°ã—ã¦ã„ãªã„å ´åˆã¯ã€ \" ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« \" ã¨ã¯ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸¡æ–¹ã‚’æŒ‡ã—ã¦ã„ã¾ã™ ) ãŒåˆ¤ã£ãŸã¨ãã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®æ¤œç´¢ãŒå§‹ã¾ã‚Šã¾ã™ã€‚æœ€åˆã«ãƒã‚§ãƒƒã‚¯ã•ã‚Œã‚‹å ´æ‰€ã¯ã€ãã‚Œã¾ã§ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã§ã‚ã‚‹ :data:`sys.modules` ã§ã™ã€‚ã‚‚ã—ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãã“ã§è¦‹ã¤ã‹ã‚Œã°ã€ãã‚ŒãŒ import ã®ã‚¹ãƒ†ãƒƒãƒ— (2) ã§åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:716
msgid ""
"If the module is not found in the cache, then :data:`sys.meta_path` is "
"searched (the specification for :data:`sys.meta_path` can be found in "
":pep:`302`). The object is a list of :term:`finder` objects which are "
"queried in order as to whether they know how to load the module by calling "
"their :meth:`find_module` method with the name of the module. If the module "
"happens to be contained within a package (as denoted by the existence of a "
"dot in the name), then a second argument to :meth:`find_module` is given as "
"the value of the :attr:`__path__` attribute from the parent package "
"(everything up to the last dot in the name of the module being imported). If"
" a finder can find the module it returns a :term:`loader` (discussed later) "
"or returns ``None``."
msgstr "ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã€æ¬¡ã¯ :data:`sys.meta_path` ãŒæ¤œç´¢ã•ã‚Œã¾ã™ã€‚ (:data:`sys.meta_path` ã®ä»•æ§˜ã¯ :pep:`302` ã«è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚) ã“ã‚Œã¯ :term:`finder` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆã§ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã‚€æ–¹æ³•ã‚’çŸ¥ã£ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ãã® :meth:`find_module` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’å¼•æ•°ã¨ã—ã¦å‘¼ã³å‡ºã™ã“ã¨ã§ã€é †ç•ªã«å•ã„åˆã›ã¦ã„ãã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å«ã¾ã‚Œã¦ã„ãŸ (ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã®ä¸­ã«ãƒ‰ãƒƒãƒˆãŒå«ã¾ã‚Œã¦ã„ãŸ) å ´åˆã€ :meth:`find_module` ã®ç¬¬ 2 å¼•æ•°ã«è¦ªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® :attr:`__path__` å±æ€§ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚ (ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã®æœ€å¾Œã®ãƒ‰ãƒƒãƒˆã‚ˆã‚Šå‰ã®ã™ã¹ã¦ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¾ã™) finder ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ã¤ã‘ãŸã¨ãã€ (å¾Œã§è§£èª¬ã™ã‚‹) :term:`loader` ã‹ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:732
msgid ""
"If none of the finders on :data:`sys.meta_path` are able to find the module "
"then some implicitly defined finders are queried. Implementations of Python "
"vary in what implicit meta path finders are defined. The one they all do "
"define, though, is one that handles :data:`sys.path_hooks`, "
":data:`sys.path_importer_cache`, and :data:`sys.path`."
msgstr ":data:`sys.meta_path` ã«å«ã¾ã‚Œã‚‹ã™ã¹ã¦ã® finder ãŒ module ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œãªã„å ´åˆã€å¹¾ã¤ã‹ã®æš—é»™çš„ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ finder ã«å•ã„åˆã‚ã›ã‚‰ã‚Œã¾ã™ã€‚ã©ã‚“ãªæš—é»™ã® meta path finder ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹ã¯ Python ã®å®Ÿè£…ã«ã‚ˆã£ã¦æ§˜ã€…ã§ã™ã€‚ã™ã¹ã¦ã®å®Ÿè£…ãŒå®šç¾©ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ 1 ã¤ã® finder ã¯ã€ :data:`sys.path_hooks` ã‚’æ‰±ã„ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:738
msgid ""
"The implicit finder searches for the requested module in the \"paths\" "
"specified in one of two places (\"paths\" do not have to be file system "
"paths). If the module being imported is supposed to be contained within a "
"package then the second argument passed to :meth:`find_module`, "
":attr:`__path__` on the parent package, is used as the source of paths. If "
"the module is not contained in a package then :data:`sys.path` is used as "
"the source of paths."
msgstr "ã“ã®æš—é»™ã® finder ã¯è¦æ±‚ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã€ 2 ç®‡æ‰€ã®ã©ã¡ã‚‰ã‹ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ \"paths\" ã‹ã‚‰æ¢ã—ã¾ã™ã€‚ (\"paths\" ãŒãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ãƒ‘ã‚¹ã§ã‚ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ ) ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€è¦ªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® :attr:`__path__` ãŒ :meth:`find_module` ã®ç¬¬ 2 å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã€ãã‚ŒãŒ paths ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å«ã¾ã‚Œã¦ã„ãªã„å ´åˆã€ :data:`sys.path` ãŒ paths ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:745
msgid ""
"Once the source of paths is chosen it is iterated over to find a finder that"
" can handle that path. The dict at :data:`sys.path_importer_cache` caches "
"finders for paths and is checked for a finder. If the path does not have a "
"finder cached then :data:`sys.path_hooks` is searched by calling each object"
" in the list with a single argument of the path, returning a finder or "
"raises :exc:`ImportError`. If a finder is returned then it is cached in "
":data:`sys.path_importer_cache` and then used for that path entry. If no "
"finder can be found but the path exists then a value of ``None`` is stored "
"in :data:`sys.path_importer_cache` to signify that an implicit, file-based "
"finder that handles modules stored as individual files should be used for "
"that path. If the path does not exist then a finder which always returns "
"``None`` is placed in the cache for the path."
msgstr "paths ãŒæ±ºå®šã•ã‚ŒãŸã‚‰ã€ãã‚Œã‚’å·¡å›ã—ã¦ãã® path ã‚’æ‰±ãˆã‚‹ finder ã‚’æ¢ã—ã¾ã™ã€‚ :data:`sys.path_importer_cache` è¾æ›¸ã¯ path ã«å¯¾ã™ã‚‹ finder ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã¦ãŠã‚Šã€ finder ã‚’æ¢ã™ã¨ãã«ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚ path ãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ :data:`sys.path_hooks` ã®å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ 1 ã¤ã®å¼•æ•° path ã§å‘¼ã³å‡ºã—ã¾ã™ã€‚å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ finder ã‚’è¿”ã™ã‹ã€ :exc:`ImportError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚ finder ãŒè¿”ã•ã‚ŒãŸå ´åˆã€ãã‚Œã‚’ :data:`sys.path_importer_cache` ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã¦ã€ãã® path ã«å¯¾ã—ã¦ãã® finder ã‚’ä½¿ã„ã¾ã™ã€‚ finder ãŒè¦‹ã¤ã‹ã‚‰ãšã€ path ãŒå­˜åœ¨ã—ã¦ã„ã‚‹å ´åˆã€ ``None`` ãŒ :data:`sys.path_importer_cache` ã«æ ¼ç´ã•ã‚Œã¦ã€æš—é»™ã®ã€å˜ä¸€ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã¨ã—ã¦ã‚ã¤ã‹ã†ãƒ•ã‚¡ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹ã® finder ã‚’ãã® path ã«å¯¾ã—ã¦åˆ©ç”¨ã™ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚ãã® path ãŒå­˜åœ¨ã—ãªã‹ã£ãŸå ´åˆã€å¸¸ã« ``None`` ã‚’è¿”ã™ finder ãŒãã® path ã«å¯¾ã™ã‚‹ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¨ã—ã¦æ ¼ç´ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:763
msgid ""
"If no finder can find the module then :exc:`ImportError` is raised. "
"Otherwise some finder returned a loader whose :meth:`load_module` method is "
"called with the name of the module to load (see :pep:`302` for the original "
"definition of loaders). A loader has several responsibilities to perform on "
"a module it loads. First, if the module already exists in "
":data:`sys.modules` (a possibility if the loader is called outside of the "
"import machinery) then it is to use that module for initialization and not a"
" new module. But if the module does not exist in :data:`sys.modules` then it"
" is to be added to that dict before initialization begins. If an error "
"occurs during loading of the module and it was added to :data:`sys.modules` "
"it is to be removed from the dict. If an error occurs but the module was "
"already in :data:`sys.modules` it is left in the dict."
msgstr "å…¨ã¦ã® finder ãŒãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œãªã„ã¨ãã¯ã€ :exc:`ImportError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ã©ã‚Œã‹ã® finder ãŒ loader ã‚’è¿”ã—ã€ãã® :meth:`load_module` ãƒ¡ã‚½ãƒƒãƒ‰ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’å¼•æ•°ã«å‘¼ã³å‡ºã•ã‚Œã¦ãƒ­ãƒ¼ãƒ‰ã‚’è¡Œãªã„ã¾ã™ã€‚ ( ãƒ­ãƒ¼ãƒ€ãƒ¼ã®ã‚ªãƒªã‚¸ãƒŠãƒ«ã®å®šç¾©ã«ã¤ã„ã¦ã¯ :pep:`302` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ ) loader ã¯ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å¯¾ã—ã¦å¹¾ã¤ã‹ã®è²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚ã¾ãšã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã™ã§ã« :data:`sys.modules` ã«ã‚ã‚Œã°ã€ ( ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒ import æ©Ÿæ§‹ã®å¤–ã‹ã‚‰å‘¼ã°ã‚ŒãŸå ´åˆã«æœ‰ã‚Šå¾—ã¾ã™ ) ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–ã«ä½¿ã„ã€æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã„ã¾ã›ã‚“ã€‚ :data:`sys.modules` ã«ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãªã‘ã‚Œã°ã€åˆæœŸåŒ–ã‚’å§‹ã‚ã‚‹å‰ã« :data:`sys.modules` ã«è¿½åŠ ã—ã¾ã™ã€‚ :data:`sys.modules` ã«è¿½åŠ ã—ãŸã‚ã¨ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ­ãƒ¼ãƒ‰ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã€ãã®è¾æ›¸ã‹ã‚‰å‰Šé™¤ã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæ—¢ã« :data:`sys.modules` ã«ã‚ã£ãŸå ´åˆã¯ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ãã®è¾æ›¸ã«æ®‹ã—ã¦ãŠãã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:783
msgid ""
"The loader must set several attributes on the module. :data:`__name__` is to"
" be set to the name of the module. :data:`__file__` is to be the \"path\" to"
" the file unless the module is built-in (and thus listed in "
":data:`sys.builtin_module_names`) in which case the attribute is not set. If"
" what is being imported is a package then :data:`__path__` is to be set to a"
" list of paths to be searched when looking for modules and packages "
"contained within the package being imported. :data:`__package__` is optional"
" but should be set to the name of package that contains the module or "
"package (the empty string is used for module not contained in a package). "
":data:`__loader__` is also optional but should be set to the loader object "
"that is loading the module."
msgstr "ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯å¹¾ã¤ã‹ã®å±æ€§ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«è¨­å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’ :data:`__name__` ã«è¨­å®šã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã® \"path\" ã‚’ :data:`__file__` ã«è¨­å®šã—ã¾ã™ãŒã€ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (:data:`sys.builtin_module_names` ã«ãƒªã‚¹ãƒˆã•ã‚Œã¦ã„ã‚‹ ) ã®å ´åˆã«ã¯ãã®å±æ€§ã‚’è¨­å®šã—ã¾ã›ã‚“ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã®ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã ã£ãŸå ´åˆã¯ã€ãã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒå«ã‚€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’æ¢ã™å ´æ‰€ã® path ã®ãƒªã‚¹ãƒˆã‚’ :data:`__path_` ã«è¨­å®šã—ã¾ã™ã€‚ :data:`__package__` ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã™ãŒã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’å«ã‚€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å ( ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å«ã¾ã‚Œã¦ã„ãªã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ç©ºæ–‡å­—åˆ— ) ã‚’è¨­å®šã™ã‚‹ã¹ãã§ã™ã€‚ :data:`__loader__` ã‚‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã™ãŒã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ãŸ loader ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¨­å®šã™ã‚‹ã¹ãã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:798
msgid ""
"If an error occurs during loading then the loader raises :exc:`ImportError` "
"if some other exception is not already being propagated. Otherwise the "
"loader returns the module that was loaded and initialized."
msgstr "ãƒ­ãƒ¼ãƒ‰ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã€ä»–ã®ä¾‹å¤–ãŒã™ã§ã«ä¼æ’­ã—ã¦ã„ãªã„ã®ã§ã‚ã‚Œã°ã€ loader ã¯ :exc:`ImportError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€ loader ã¯ãƒ­ãƒ¼ãƒ‰ã—ã¦åˆæœŸåŒ–ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:802
msgid ""
"When step (1) finishes without raising an exception, step (2) can begin."
msgstr "æ®µéš (1) ãŒä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ã“ã¨ãªãå®Œäº†ã—ãŸãªã‚‰ã€æ®µéš (2) ã‚’é–‹å§‹ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:804
msgid ""
"The first form of :keyword:`import` statement binds the module name in the "
"local namespace to the module object, and then goes on to import the next "
"identifier, if any.  If the module name is followed by :keyword:`as`, the "
"name following :keyword:`as` is used as the local name for the module."
msgstr ":keyword:`import` æ–‡ã®ç¬¬ä¸€å½¢å¼ã¯ã€ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ç©ºé–“ã«ç½®ã‹ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æŸç¸›ã—ã€ import ã™ã¹ãæ¬¡ã®è­˜åˆ¥å­ãŒã‚ã‚Œã°ãã®å‡¦ç†ã«ç§»ã‚Šã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã®å¾Œã‚ã« :keyword:`as` ãŒã‚ã‚‹å ´åˆã€ :keyword:`as` ã®å¾Œã‚ã®åå‰ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:813
msgid ""
"The :keyword:`from` form does not bind the module name: it goes through the "
"list of identifiers, looks each one of them up in the module found in step "
"(1), and binds the name in the local namespace to the object thus found.  As"
" with the first form of :keyword:`import`, an alternate local name can be "
"supplied by specifying \":keyword:`as` localname\".  If a name is not found,"
" :exc:`ImportError` is raised.  If the list of identifiers is replaced by a "
"star (``'*'``), all public names defined in the module are bound in the "
"local namespace of the :keyword:`import` statement.."
msgstr ":keyword:`from` å½¢å¼ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã®æŸç¸›ã‚’è¡Œã„ã¾ã›ã‚“ : :keyword:`from` å½¢å¼ã§ã¯ã€æ®µéš (1) ã§è¦‹ã¤ã‹ã£ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã‹ã‚‰ã€è­˜åˆ¥å­ãƒªã‚¹ãƒˆã®å„åå‰ã‚’é †ã«æ¤œç´¢ã—ã€è¦‹ã¤ã‹ã£ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è­˜åˆ¥å­ã®åå‰ã§ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ç©ºé–“ã«ãŠã„ã¦æŸç¸›ã—ã¾ã™ã€‚ :keyword:`import` ã®ç¬¬ä¸€å½¢å¼ã¨åŒã˜ã‚ˆã†ã«ã€ \":keyword:`as` localname\" ã§åˆ¥åã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æŒ‡å®šã•ã‚ŒãŸåå‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ :exc:`ImportError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚è­˜åˆ¥å­ã®ãƒªã‚¹ãƒˆã‚’æ˜Ÿå° (``'*'``) ã§ç½®ãæ›ãˆã‚‹ã¨ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å…¬é–‹ã•ã‚Œã¦ã„ã‚‹åå‰ (public name) å…¨ã¦ã‚’ :keyword:`import` æ–‡ã®ã‚ã‚‹å ´æ‰€ã®ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ç©ºé–“ã«æŸç¸›ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:824
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to"
" exist.  If ``__all__`` is not defined, the set of public names includes all"
" names found in the module's namespace which do not begin with an underscore"
" character (``'_'``). ``__all__`` should contain the entire public API. It "
"is intended to avoid accidentally exporting items that are not part of the "
"API (such as library modules which were imported and used within the "
"module)."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ * å…¬é–‹ã•ã‚Œã¦ã„ã‚‹åå‰ (public names)* ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“å†…ã«ã‚ã‚‹ ``__all__`` ã¨ã„ã†åå‰ã®å¤‰æ•°ã‚’èª¿ã¹ã¦æ±ºå®šã—ã¾ã™ ; ``__all__`` ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ ``__all__`` ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ãŸã‚Šã€ import ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªåå‰ã®æ–‡å­—åˆ—ã‹ã‚‰ãªã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ ``__all__`` å†…ã«ã‚ã‚‹åå‰ã¯ã€å…¨ã¦å…¬é–‹ã•ã‚ŒãŸåå‰ã§ã‚ã‚Šã€å®Ÿåœ¨ã™ã‚‹ã‚‚ã®ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚ ``__all__`` ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ã«è¦‹ã¤ã‹ã£ãŸåå‰ã§ã€ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢æ–‡å­— (``'_'``) ã§å§‹ã¾ã£ã¦ã„ãªã„å…¨ã¦ã®åå‰ãŒå…¬é–‹ã•ã‚ŒãŸåå‰ã«ãªã‚Šã¾ã™ã€‚ ``__all__`` ã«ã¯ã€å…¬é–‹ã•ã‚Œã¦ã„ã‚‹ API å…¨ã¦ã‚’å…¥ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ ``__all__`` ã«ã¯ã€ ( ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§ import ã•ã‚Œã¦ä½¿ã‚ã‚Œã¦ã„ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚ˆã†ã« ) API ã‚’æ§‹æˆã—ãªã„è¦ç´ ã‚’æ„ã«åã—ã¦å…¬é–‹ã—ã¦ã—ã¾ã†ã®ã‚’é¿ã‘ã‚‹ã¨ã„ã†æ„å›³ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:834
msgid ""
"The :keyword:`from` form with ``*`` may only occur in a module scope.  If "
"the wild card form of import --- ``import *`` --- is used in a function and "
"the function contains or is a nested block with free variables, the compiler"
" will raise a :exc:`SyntaxError`."
msgstr "``*`` ã‚’ä½¿ã£ãŸ :keyword:`from` å½¢å¼ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¹ã‚³ãƒ¼ãƒ—å†…ã ã‘ã«ä½œç”¨ã—ã¾ã™ã€‚é–¢æ•°å†…ã§ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ã® import æ–‡ --- ``import *`` --- ã‚’ä½¿ã„ã€é–¢æ•°ãŒè‡ªç”±å¤‰æ•°ã‚’ä¼´ã†ãƒã‚¹ãƒˆã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ã§ã‚ã£ãŸã‚Šã€ãƒ–ãƒ­ãƒƒã‚¯ã‚’å«ã‚“ã§ã„ã‚‹å ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ :exc:`SyntaxError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:842
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top"
" package without having to mention the package name. By using leading dots "
"in the specified module or package after :keyword:`from` you can specify how"
" high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the"
" import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained "
"within :pep:`328`."
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æŒ‡å®šã™ã‚‹ã¨ãã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®çµ¶å¯¾å (absolute name) ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒä»–ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€å…±é€šã®ãƒˆãƒƒãƒ—ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‹ã‚‰ãã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åã‚’è¨˜è¿°ã™ã‚‹ã“ã¨ãªãç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ :keyword:`from` ã®å¾Œã«æŒ‡å®šã•ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å…ˆé ­ã«è¤‡æ•°å€‹ã®ãƒ‰ãƒƒãƒˆã‚’ä»˜ã‘ã‚‹ã“ã¨ã§ã€æ­£ç¢ºãªåå‰ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãªã—ã«ç¾åœ¨ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸éšå±¤ã‹ã‚‰ã„ãã¤ä¸Šã®éšå±¤ã¸è¡Œãã‹ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å…ˆé ­ã®ãƒ‰ãƒƒãƒˆãŒ 1 ã¤ã®å ´åˆã€ import ã‚’ãŠã“ãªã£ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå­˜åœ¨ã™ã‚‹ç¾åœ¨ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ç¤ºã—ã¾ã™ã€‚ 3 ã¤ã®ãƒ‰ãƒƒãƒˆã¯ 2 ã¤ä¸Šã®ãƒ¬ãƒ™ãƒ«ã‚’ç¤ºã—ã¾ã™ã€‚ãªã®ã§ã€ ``pkg`` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ä¸­ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ ``from . import mod`` ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ ``pkg.mod`` ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ ``pkg.subpkg1`` ã®ä¸­ã‹ã‚‰ ``from ..subpkg2 import mod`` ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ ``pkg.subpkg2.mod`` ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®ä»•æ§˜ã¯ :pep:`328` ã«å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:855
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine which modules need to be loaded dynamically."
msgstr "ã©ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã¹ãã‹ã‚’å‹•çš„ã«æ±ºã‚ãŸã„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãŸã‚ã«ã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`importlib.import_module` ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:862
msgid "Future statements"
msgstr "future æ–‡ (future statement)"

#: ../../reference/simple_stmts.rst:866
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python.  The future statement is intended "
"to ease migration to future versions of Python that introduce incompatible "
"changes to the language.  It allows use of the new features on a per-module "
"basis before the release in which the feature becomes standard."
msgstr ":dfn:`future æ–‡` ã¯ã€å°†æ¥ã®ç‰¹å®šã® Python ã®ãƒªãƒªãƒ¼ã‚¹ã§åˆ©ç”¨å¯èƒ½ã«ãªã‚‹ã‚ˆã†ãªæ§‹æ–‡ã‚„æ„å‘³ä»˜ã‘ã‚’ä½¿ã£ã¦ã€ç‰¹å®šã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã›ã‚‹ãŸã‚ã®ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«å¯¾ã™ã‚‹æŒ‡ç¤ºå¥ (directive) ã§ã™ã€‚ future æ–‡ã¯ã€è¨€èªä»•æ§˜ã«éäº’æ›æ€§ãŒã‚‚ãŸã‚‰ã•ã‚Œã‚‹ã‚ˆã†ãªã€å°†æ¥ã® Python ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«å®¹æ˜“ã«ç§»è¡Œã§ãã‚‹ã‚ˆã†æ„å›³ã•ã‚Œã¦ã„ã¾ã™ã€‚ future æ–‡ã«ã‚ˆã£ã¦ã€æ–°ãŸãªæ©Ÿèƒ½ãŒæ¨™æº–åŒ–ã•ã‚ŒãŸãƒªãƒªãƒ¼ã‚¹ãŒå‡ºã•ã‚Œã‚‹å‰ã«ã€ãã®æ©Ÿèƒ½ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å˜ä½ã§ä½¿ãˆã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:881
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr "future æ–‡ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å…ˆé ­å‘¨è¾ºã«æ›¸ã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ future æ–‡ã®å‰ã«æ›¸ã„ã¦ã‚ˆã„å†…å®¹ã¯ä»¥ä¸‹ã§ã™ :"

#: ../../reference/simple_stmts.rst:884
msgid "the module docstring (if any),"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ— ( ã‚ã‚Œã° )"

#: ../../reference/simple_stmts.rst:885
msgid "comments,"
msgstr "ã‚³ãƒ¡ãƒ³ãƒˆ ,"

#: ../../reference/simple_stmts.rst:886
msgid "blank lines, and"
msgstr "ç©ºè¡Œ ,"

#: ../../reference/simple_stmts.rst:887
msgid "other future statements."
msgstr "ãã®ä»–ã® future æ–‡ã€‚"

#: ../../reference/simple_stmts.rst:889
msgid ""
"The features recognized by Python 2.6 are ``unicode_literals``, "
"``print_function``, ``absolute_import``, ``division``, ``generators``, "
"``nested_scopes`` and ``with_statement``.  ``generators``, "
"``with_statement``, ``nested_scopes`` are redundant in Python version 2.6 "
"and above because they are always enabled."
msgstr "Python 2.6 ãŒèªè­˜ã™ã‚‹æ©Ÿèƒ½ã¯ã€ ``unicode_literals``, ``print_function``, ``absolute_import``, ``division``, ``generators``, ``nested_scopes``, ``with_statement`` ã§ã™ã€‚ ``generators``, ``with_statement``, ``nested_scopes`` ã¯ Python 2.6 ä»¥ä¸Šã§ã¯å¸¸ã«æœ‰åŠ¹ãªã®ã§å†—é•·ã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:895
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr "future æ–‡ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ç‰¹åˆ¥ãªã‚„ã‚Šæ–¹ã§èªè­˜ã•ã‚Œã€æ‰±ã‚ã‚Œã¾ã™: è¨€èªã®ä¸­æ ¸ã‚’ãªã™æ§‹æ–‡æ§‹æˆ (construct) ã«å¯¾ã™ã‚‹æ„å‘³ä»˜ã‘ãŒå¤‰æ›´ã•ã‚Œã¦ã„ã‚‹å ´åˆã€å¤‰æ›´éƒ¨åˆ†ã¯ã—ã°ã—ã°ç•°ãªã‚‹ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã§å®Ÿç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚æ–°ãŸãªæ©Ÿèƒ½ã«ã‚ˆã£ã¦ã€(æ–°ãŸãªäºˆç´„èªã®ã‚ˆã†ãª) äº’æ›æ€§ã®ãªã„æ–°ãŸãªæ§‹æ–‡ãŒå–ã‚Šå…¥ã‚Œã‚‰ã‚Œã‚‹ã“ã¨ã•ãˆã‚ã‚Šã¾ã™ã€‚ã“ã®å ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆ¥ã®ã‚„ã‚Šã‹ãŸã§è§£æã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã†ã—ãŸã‚³ãƒ¼ãƒ‰ç”Ÿæˆã«é–¢ã™ã‚‹æ±ºå®šã¯ã€å®Ÿè¡Œæ™‚ã¾ã§å…ˆå»¶ã°ã—ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:902
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr "ã“ã‚Œã¾ã§ã®å…¨ã¦ã®ãƒªãƒªãƒ¼ã‚¹ã«ãŠã„ã¦ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã©ã®æ©Ÿèƒ½ãŒå®šç¾©æ¸ˆã¿ã‹ã‚’çŸ¥ã£ã¦ãŠã‚Šã€ future æ–‡ã«æœªçŸ¥ã®æ©Ÿèƒ½ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã‚¨ãƒ©ãƒ¼ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:906
msgid ""
"The direct runtime semantics are the same as for any import statement: there"
" is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr "future æ–‡ã®å®Ÿè¡Œæ™‚ã«ãŠã‘ã‚‹ç›´æ¥çš„ãªæ„å‘³ä»˜ã‘ã¯ã€ import æ–‡ã¨åŒã˜ã§ã™ã€‚æ¨™æº–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`__future__` ãŒã‚ã‚Šã€ã“ã‚Œã«ã¤ã„ã¦ã¯å¾Œã§è¿°ã¹ã¾ã™ã€‚ :mod:`__future__` ã¯ã€ future æ–‡ãŒå®Ÿè¡Œã•ã‚Œã‚‹éš›ã«é€šå¸¸ã®æ–¹æ³•ã§ import ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:910
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr "future æ–‡ã®å®Ÿè¡Œæ™‚ã«ãŠã‘ã‚‹ç‰¹åˆ¥ãªæ„å‘³ä»˜ã‘ã¯ã€ future æ–‡ã§æœ‰åŠ¹åŒ–ã•ã‚Œã‚‹ç‰¹å®šã®æ©Ÿèƒ½ã«ã‚ˆã£ã¦å¤‰ã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:913
msgid "Note that there is nothing special about the statement::"
msgstr "ä»¥ä¸‹ã®æ–‡ã«ã¯ã€ä½•ã‚‰ç‰¹æ®Šãªæ„å‘³ã¯ãªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„::"

#: ../../reference/simple_stmts.rst:917
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr "ã“ã‚Œã¯ future æ–‡ã§ã¯ã‚ã‚Šã¾ã›ã‚“; ã“ã®æ–‡ã¯é€šå¸¸ã® import æ–‡ã§ã‚ã‚Šã€ãã®ä»–ã®ç‰¹æ®Šãªæ„å‘³ä»˜ã‘ã‚„æ§‹æ–‡çš„ãªåˆ¶é™ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:920
msgid ""
"Code compiled by an :keyword:`exec` statement or calls to the built-in "
"functions :func:`compile` and :func:`execfile` that occur in a module "
":mod:`M` containing a future statement will, by default, use the new  syntax"
" or semantics associated with the future statement.  This can, starting with"
" Python 2.2 be controlled by optional arguments to :func:`compile` --- see "
"the documentation of that function for details."
msgstr "future æ–‡ã®å…¥ã£ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`M` å†…ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ :keyword:`exec` æ–‡ã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`compile` ã‚„ :func:`execfile` ã«ã‚ˆã£ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¨­å®šã§ã¯ã€ future æ–‡ã«é–¢ä¿‚ã™ã‚‹æ–°ãŸãªæ§‹æ–‡ã‚„æ„å‘³ä»˜ã‘ã‚’ä½¿ã†ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚ Python 2.2 ã‹ã‚‰ã¯ã€ã“ã®ä»•æ§˜ã‚’ :func:`compile` ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•°ã§åˆ¶å¾¡ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸ --- è©³ç´°ã¯ã“ã®é–¢æ•°ã«é–¢ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/simple_stmts.rst:927
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr "å¯¾è©±çš„ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§ã‚¿ã‚¤ãƒ—å…¥åŠ›ã—ãŸ future æ–‡ã¯ã€ãã®å¾Œã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸­ã§æœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ :option:`-i` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§èµ·å‹•ã—ã¦å®Ÿè¡Œã™ã¹ãã‚¹ã‚¯ãƒªãƒ—ãƒˆåã‚’æ¸¡ã—ã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆä¸­ã« future æ–‡ã‚’å…¥ã‚Œã¦ãŠãã¨ã€æ–°ãŸãªæ©Ÿèƒ½ã¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒå®Ÿè¡Œã•ã‚ŒãŸå¾Œã«é–‹å§‹ã™ã‚‹å¯¾è©±ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§æœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:935
msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` - Back to the __future__"

#: ../../reference/simple_stmts.rst:936
msgid "The original proposal for the __future__ mechanism."
msgstr "__future__ æ©Ÿæ§‹ã®åŸæ¡ˆ"

#: ../../reference/simple_stmts.rst:942
msgid "The :keyword:`global` statement"
msgstr ":keyword:`global` æ–‡"

#: ../../reference/simple_stmts.rst:951
msgid ""
"The :keyword:`global` statement is a declaration which holds for the entire "
"current code block.  It means that the listed identifiers are to be "
"interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`global`, although free variables may refer to "
"globals without being declared global."
msgstr ":keyword:`global` æ–‡ã¯ã€ç¾åœ¨ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å…¨ä½“ã§ç¶­æŒã•ã‚Œã‚‹å®£è¨€æ–‡ã§ã™ã€‚ :keyword:`global` æ–‡ã¯ã€åˆ—æŒ™ã—ãŸè­˜åˆ¥å­ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦è§£é‡ˆã™ã‚‹ã‚ˆã†æŒ‡å®šã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ :keyword:`global` ã‚’ä½¿ã‚ãšã«ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ä»£å…¥ã‚’è¡Œã†ã“ã¨ã¯ä¸å¯èƒ½ã§ã™ãŒã€è‡ªç”±å¤‰æ•°ã‚’ä½¿ãˆã°ãã®å¤‰æ•°ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§ã‚ã‚‹ã¨å®£è¨€ã›ãšã«ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’å‚ç…§ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:957
msgid ""
"Names listed in a :keyword:`global` statement must not be used in the same "
"code block textually preceding that :keyword:`global` statement."
msgstr ":keyword:`global` æ–‡ã§åˆ—æŒ™ã™ã‚‹åå‰ã¯ã€åŒã˜ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ä¸­ã§ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ†ã‚­ã‚¹ãƒˆä¸Š :keyword:`global` æ–‡ã‚ˆã‚Šå‰ã«ä½¿ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:960
msgid ""
"Names listed in a :keyword:`global` statement must not be defined as formal "
"parameters or in a :keyword:`for` loop control target, :keyword:`class` "
"definition, function definition, or :keyword:`import` statement."
msgstr ":keyword:`global` æ–‡ã§åˆ—æŒ™ã™ã‚‹åå‰ã¯ã€ :keyword:`for` ãƒ«ãƒ¼ãƒ—ã®ãƒ«ãƒ¼ãƒ—åˆ¶å¾¡ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚„ã€ :keyword:`class` å®šç¾©ã€é–¢æ•°å®šç¾©ã€ :keyword:`import` æ–‡å†…ã§ä»®å¼•æ•°ã¨ã—ã¦ä½¿ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/simple_stmts.rst:966
msgid ""
"The current implementation does not enforce the latter two restrictions, but"
" programs should not abuse this freedom, as future implementations may "
"enforce them or silently change the meaning of the program."
msgstr "ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€å¾Œã‚äºŒã¤ã®åˆ¶é™ã«ã¤ã„ã¦ã¯å¼·åˆ¶ã—ã¦ã„ã¾ã›ã‚“ãŒã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã“ã®ç·©å’Œã•ã‚ŒãŸä»•æ§˜ã‚’ä¹±ç”¨ã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å°†æ¥ã®å®Ÿè£…ã§ã¯ã€ã“ã®åˆ¶é™ã‚’å¼·åˆ¶ã—ãŸã‚Šã€æš—é»™ã®ã†ã¡ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ„å‘³ä»˜ã‘ã‚’å¤‰æ›´ã—ãŸã‚Šã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:976
msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`global` "
"statement. In particular, a :keyword:`global` statement contained in an "
":keyword:`exec` statement does not affect the code block *containing* the "
":keyword:`exec` statement, and code contained in an :keyword:`exec` "
"statement is unaffected by :keyword:`global` statements in the code "
"containing the :keyword:`exec` statement.  The same applies to the "
":func:`eval`, :func:`execfile` and :func:`compile` functions."
msgstr "**ãƒ—ãƒ­ã‚°ãƒ©ãƒã®ãŸã‚ã®æ³¨æ„æ›¸ã:** :keyword:`global` ã¯ãƒ‘ãƒ¼ã‚µãƒ¼ã«å¯¾ã™ã‚‹æŒ‡ç¤ºå¥ (directive) ã§ã™ã€‚ã“ã®æŒ‡ç¤ºå¥ã¯ã€ :keyword:`global` æ–‡ã¨åŒæ™‚ã«èª­ã¿è¾¼ã¾ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã«å¯¾ã—ã¦ã®ã¿é©ç”¨ã•ã‚Œã¾ã™ã€‚ç‰¹ã«ã€ :keyword:`exec` æ–‡å†…ã«å…¥ã£ã¦ã„ã‚‹ :keyword:`global` æ–‡ã¯ã€ :keyword:`exec` æ–‡ã‚’ * å«ã‚“ã§ã„ã‚‹ * ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å†…ã«åŠ¹æœã‚’åŠã¼ã™ã“ã¨ã¯ãªãã€ :keyword:`exec` æ–‡å†…ã«å«ã¾ã‚Œã¦ã„ã‚‹ã‚³ãƒ¼ãƒ‰ã¯ã€ :keyword:`exec` æ–‡ã‚’å«ã‚€ã‚³ãƒ¼ãƒ‰å†…ã§ã® :keyword:`global` æ–‡ã«å½±éŸ¿ã‚’å—ã‘ã¾ã›ã‚“ã€‚åŒæ§˜ã®ã“ã¨ãŒã€é–¢æ•° :func:`eval` ã€ :func:`execfile` ã€ãŠã‚ˆã³ :func:`compile` ã«ã‚‚å½“ã¦ã¯ã¾ã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:989
msgid "The :keyword:`exec` statement"
msgstr ":keyword:`exec` æ–‡"

#: ../../reference/simple_stmts.rst:996
msgid ""
"This statement supports dynamic execution of Python code.  The first "
"expression should evaluate to either a Unicode string, a *Latin-1* encoded "
"string, an open file object, a code object, or a tuple.  If it is a string, "
"the string is parsed as a suite of Python statements which is then executed "
"(unless a syntax error occurs). [#]_ If it is an open file, the file is "
"parsed until EOF and executed. If it is a code object, it is simply "
"executed.  For the interpretation of a tuple, see below.  In all cases, the "
"code that's executed is expected to be valid as file input (see section :ref"
":`file-input`).  Be aware that the :keyword:`return` and :keyword:`yield` "
"statements may not be used outside of function definitions even within the "
"context of code passed to the :keyword:`exec` statement."
msgstr "ã“ã®æ–‡ã¯ã€ Python ã‚³ãƒ¼ãƒ‰ã®å‹•çš„ãªå®Ÿè¡Œã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚æœ€åˆã®å¼ã®å€¤è©•ä¾¡çµæœ Unicode æ–‡å­—åˆ—, *Latin-1* ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—, é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ, ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ, ã‚¿ãƒ—ãƒ«ã®ã„ãšã‚Œã‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æ–‡å­—åˆ—ã®å ´åˆã€ä¸€é€£ã® Python å®Ÿè¡Œæ–‡ã¨ã—ã¦è§£æã—ã€ (æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ãŒç”Ÿã˜ãªã„é™ã‚Š) å®Ÿè¡Œã—ã¾ã™ã€‚ [#]_ é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚ã‚Œã°ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ EOF ã¾ã§èª­ã‚“ã§è§£æã—ã€å®Ÿè¡Œã—ã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã‚‰ã€å˜ã«ã“ã‚Œã‚’å®Ÿè¡Œã—ã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã®ç¿»è¨³ã«ã¤ã„ã¦ã¯å¾Œè¿°ã—ã¾ã™ã€‚å…¨ã¦ã®å ´åˆã§ã€å®Ÿè¡Œã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã¯ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã¨ã—ã¦æœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ãŒæœŸå¾…ã•ã‚Œã¾ã™ (ã‚»ã‚¯ã‚·ãƒ§ãƒ³ :ref:`file-input` ã‚’å‚ç…§) ã€‚ :keyword:`return` ã¨ :keyword:`yield` æ–‡ã¯ã€ :keyword:`exec` æ–‡ã«æ¸¡ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã®æ–‡è„ˆä¸­ã«ãŠã„ã¦ã‚‚é–¢æ•°å®šç¾©ã®å¤–ã§ã¯ä½¿ã‚ã‚Œãªã„ç‚¹ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/simple_stmts.rst:1008
msgid ""
"In all cases, if the optional parts are omitted, the code is executed in the"
" current scope.  If only the first expression after ``in`` is specified, it "
"should be a dictionary, which will be used for both the global and the local"
" variables.  If two expressions are given, they are used for the global and "
"local variables, respectively. If provided, *locals* can be any mapping "
"object. Remember that at module level, globals and locals are the same "
"dictionary. If two separate objects are given as *globals* and *locals*, the"
" code will be executed as if it were embedded in a class definition."
msgstr "ã„ãšã‚Œã®å ´åˆã§ã‚‚ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®éƒ¨åˆ†ãŒçœç•¥ã•ã‚Œã‚‹ã¨ã€ã‚³ãƒ¼ãƒ‰ã¯ç¾åœ¨ã®ã‚¹ã‚³ãƒ¼ãƒ—å†…ã§å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ ``in`` ã®å¾Œã‚ã«ä¸€ã¤ã ã‘å¼ã‚’æŒ‡å®šã™ã‚‹å ´åˆã€ãã®å¼ã¯è¾æ›¸ã§ãªãã¦ã¯ãªã‚‰ãšã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®ä¸¡æ–¹ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã¯ãã‚Œãã‚Œã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚ *locals* ã‚’æŒ‡å®šã™ã‚‹å ´åˆã¯ä½•ã‚‰ã‹ã®ãƒãƒƒãƒ—å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã›ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã§ã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ã¨ãƒ­ãƒ¼ã‚«ãƒ«ã¯åŒã˜è¾æ›¸ã§ã™ã€‚ *globals* ã¨ *locals* ã¨ã—ã¦åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–ã£ãŸå ´åˆã€ã‚³ãƒ¼ãƒ‰ã¯ã‚¯ãƒ©ã‚¹å®šç¾©ã«åŸ‹ã‚è¾¼ã¾ã‚ŒãŸã‹ã®ã‚ˆã†ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:1017
msgid ""
"The first expression may also be a tuple of length 2 or 3.  In this case, "
"the optional parts must be omitted.  The form ``exec(expr, globals)`` is "
"equivalent to ``exec expr in globals``, while the form ``exec(expr, globals,"
" locals)`` is equivalent to ``exec expr in globals, locals``.  The tuple "
"form of ``exec`` provides compatibility with Python 3, where ``exec`` is a "
"function rather than a statement."
msgstr "æœ€åˆã®å¼ã¯é•·ã• 2 ã‹ 3 ã®ã‚¿ãƒ—ãƒ«ã«ã§ãã¾ã™ã€‚ã“ã®ã‚±ãƒ¼ã‚¹ã®å ´åˆã¯ã€æ®‹ã‚Šã®çœç•¥å¯èƒ½éƒ¨åˆ†ã¯çœç•¥ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ ``exec(expr, globals)`` å½¢å¼ã¯ ``exec expr in globals`` ã¨ç­‰ä¾¡ã§ã€ ``exec(expr, globals, locals)`` å½¢å¼ã¯ ``exec expr in globals, locals`` ã¨ç­‰ä¾¡ã§ã™ã€‚ ``exec`` ã®ã‚¿ãƒ—ãƒ«å½¢å¼ã¯ã€ ``exec`` ãŒæ–‡ã§ã¯ãªãé–¢æ•°ã«ãªã£ã¦ã„ã‚‹ Python 3 ã¨ã®äº’æ›æ€§ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:1024
msgid "Formerly, *locals* was required to be a dictionary."
msgstr "ä»¥å‰ã¯ *locals* ã¯è¾æ›¸ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã§ã—ãŸ ."

#: ../../reference/simple_stmts.rst:1031
msgid ""
"As a side effect, an implementation may insert additional keys into the "
"dictionaries given besides those corresponding to variable names set by the "
"executed code.  For example, the current implementation may add a reference "
"to the dictionary of the built-in module :mod:`__builtin__` under the key "
"``__builtins__`` (!)."
msgstr ":keyword:`exec` ã®å‰¯ä½œç”¨ã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã§è¨­å®šã•ã‚ŒãŸå¤‰æ•°åã«å¯¾å¿œã™ã‚‹åå‰ã®ä»–ã«ã€è¿½åŠ ã®ã‚­ãƒ¼ã‚’è¾æ›¸ã«è¿½åŠ ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`__builtin__` ã®è¾æ›¸ã«å¯¾ã™ã‚‹å‚ç…§ã‚’ã€ ``__builtins__`` (!) ã¨ã„ã†ã‚­ãƒ¼ã§è¿½åŠ ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/simple_stmts.rst:1042
msgid ""
"**Programmer's hints:** dynamic evaluation of expressions is supported by "
"the built-in function :func:`eval`.  The built-in functions :func:`globals` "
"and :func:`locals` return the current global and local dictionary, "
"respectively, which may be useful to pass around for use by :keyword:`exec`."
msgstr "**ãƒ—ãƒ­ã‚°ãƒ©ãƒã®ãŸã‚ã®ãƒ’ãƒ³ãƒˆ:** å¼ã®å‹•çš„ãªè©•ä¾¡ã¯ã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`eval` ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚çµ„ã¿è¾¼ã¿é–¢æ•° :func:`globals` ãŠã‚ˆã³ :func:`locals` ã¯ã€ãã‚Œãã‚Œç¾åœ¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«è¾æ›¸ã¨ãƒ­ãƒ¼ã‚«ãƒ«è¾æ›¸ã‚’è¿”ã™ã®ã§ã€ :keyword:`exec` ã«æ¸¡ã—ã¦ä½¿ã†ã¨ä¾¿åˆ©ã§ã™ã€‚"

#: ../../reference/simple_stmts.rst:1049
msgid "Footnotes"
msgstr "æ³¨è¨˜"

#: ../../reference/simple_stmts.rst:1050
msgid ""
"Note that the parser only accepts the Unix-style end of line convention. If "
"you are reading the code from a file, make sure to use :term:`universal "
"newlines` mode to convert Windows or Mac-style newlines."
msgstr "ãªãŠã€ãƒ‘ãƒ¼ã‚µã¯ Unix ã‚¹ã‚¿ã‚¤ãƒ«ã®è¡Œæœ«ã®è¨˜æ³•ã—ã‹å—ã‘ä»˜ã‘ã¾ã›ã‚“ã€‚ã‚³ãƒ¼ãƒ‰ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã‚“ã§ã„ã‚‹ãªã‚‰ã€å¿…ãšã€ :term:`universal newlines`  ãƒ¢ãƒ¼ãƒ‰ã§ Windows ã‚„ Mac ã‚¹ã‚¿ã‚¤ãƒ«ã®æ”¹è¡Œã‚’å¤‰æ›ã—ã¦ãã ã•ã„ã€‚"
