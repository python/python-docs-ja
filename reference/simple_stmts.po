# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# tomo, 2018
# 秘湯 <xwhhsprings@gmail.com>, 2015-2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr "単純文 (simple statement)"

#: ../../reference/simple_stmts.rst:10
msgid ""
"Simple statements are comprised within a single logical line. Several simple "
"statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""
"単純文とは、単一の論理行内に収められる文です。単一の行内には、複数の単純文を"
"セミコロンで区切って入れることができます。単純文の構文は以下の通りです:"

#: ../../reference/simple_stmts.rst:36
msgid "Expression statements"
msgstr "式文 (expression statement)"

#: ../../reference/simple_stmts.rst:42
msgid ""
"Expression statements are used (mostly interactively) to compute and write a "
"value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""
"式文は、(主に対話的な使い方では) 値を計算して出力するために使ったり、(通常"
"は) プロシジャ (procedure: 有意な結果を返さない関数のことです; Python では、"
"プロシジャは値 ``None`` を返します) を呼び出すために使います。その他の使い方"
"でも式文を使うことができますし、有用なこともあります。式文の構文は以下の通り"
"です:"

#: ../../reference/simple_stmts.rst:51
msgid ""
"An expression statement evaluates the expression list (which may be a single "
"expression)."
msgstr "式文は式のリスト (単一の式のこともあります) を値評価します。"

#: ../../reference/simple_stmts.rst:63
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output (see section :ref:`print`) on a line by itself.  "
"(Expression statements yielding ``None`` are not written, so that procedure "
"calls do not cause any output.)"
msgstr ""
"対話モードでは、値が ``None`` でない場合、値を組み込み関数 :func:`repr` で文"
"字列に変換して、その結果のみからなる一行を標準出力に書き出します ( :ref:"
"`print` 節参照 ) 。 (``None`` になる式文の値は書き出されないので、プロシジャ"
"呼び出しを行っても出力は得られません。 )"

#: ../../reference/simple_stmts.rst:73
msgid "Assignment statements"
msgstr "代入文 (assignment statement)"

#: ../../reference/simple_stmts.rst:83
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""
"代入文は、名前を値に (再) 束縛したり、変更可能なオブジェクトの属性や要素を変"
"更したりするために使われます:"

#: ../../reference/simple_stmts.rst:96 ../../reference/simple_stmts.rst:268
msgid ""
"(See section :ref:`primaries` for the syntax definitions for the last three "
"symbols.)"
msgstr ""
"(末尾の三つのシンボルの構文については :ref:`primaries` 節を参照してくださ"
"い。)"

#: ../../reference/simple_stmts.rst:101
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""
"代入文は式のリスト (これは単一の式でも、カンマで区切られた式リストでもよく、"
"後者はタプルになることを思い出してください) を評価し、得られた単一の結果オブ"
"ジェクトをターゲット (target) のリストに対して左から右へと代入してゆきます。"

#: ../../reference/simple_stmts.rst:110
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""
"代入はターゲット (リスト) の形式に従って再帰的に行われます。ターゲットが変更"
"可能なオブジェクト (属性参照、添字表記、またはスライス) の一部である場合、こ"
"の変更可能なオブジェクトは最終的に代入を実行して、その代入が有効な操作である"
"か判断しなければなりません。代入が不可能な場合には例外を発行することもできま"
"す。型ごとにみられる規則や、送出される例外は、そのオブジェクト型定義で与えら"
"れています (:ref:`types` 節を参照してください)."

#: ../../reference/simple_stmts.rst:119
msgid ""
"Assignment of an object to a target list is recursively defined as follows."
msgstr ""
"ターゲットリストへのオブジェクトの代入は、以下のようにして再帰的に定義されて"
"います。"

#: ../../reference/simple_stmts.rst:121
msgid ""
"If the target list is a single target: The object is assigned to that target."
msgstr ""
"ターゲットリストが単一のターゲットからなる場合: オブジェクトはそのターゲット"
"に代入されます。"

#: ../../reference/simple_stmts.rst:123
msgid ""
"If the target list is a comma-separated list of targets: The object must be "
"an iterable with the same number of items as there are targets in the target "
"list, and the items are assigned, from left to right, to the corresponding "
"targets."
msgstr ""
"ターゲットリストが、カンマで区切られた複数のターゲットからなるリストの場合: "
"オブジェクトはターゲットリスト中のターゲット数と同じ数の要素からなるイテレー"
"ト可能オブジェクトでなければならず、その各要素は左から右へと対応するターゲッ"
"トに代入されます。"

#: ../../reference/simple_stmts.rst:127
msgid ""
"Assignment of an object to a single target is recursively defined as follows."
msgstr ""
"単一のターゲットへの単一のオブジェクトの代入は、以下のようにして再帰的に定義"
"されています。"

#: ../../reference/simple_stmts.rst:129
msgid "If the target is an identifier (name):"
msgstr "ターゲットが識別子 (名前) の場合:"

#: ../../reference/simple_stmts.rst:133
msgid ""
"If the name does not occur in a :keyword:`global` statement in the current "
"code block: the name is bound to the object in the current local namespace."
msgstr ""
"名前が現在のコードブロック内の :keyword:`global` 文に書かれていない場合 : 名"
"前は現在のローカル名前空間内のオブジェクトに束縛されます。"

#: ../../reference/simple_stmts.rst:136
msgid ""
"Otherwise: the name is bound to the object in the current global namespace."
msgstr ""
"それ以外の場合 : 名前は現在のグローバル名前空間内のオブジェクトに束縛されま"
"す。"

#: ../../reference/simple_stmts.rst:140
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the "
"object to be deallocated and its destructor (if it has one) to be called."
msgstr ""
"名前がすでに束縛済みの場合、再束縛 (rebind) がおこなわれます。再束縛によっ"
"て、以前その名前に束縛されていたオブジェクトの参照カウント (reference count) "
"がゼロになった場合、オブジェクトは解放 (deallocate) され、デストラクタ  "
"(destructor) が (存在すれば) 呼び出されます。"

#: ../../reference/simple_stmts.rst:144
msgid ""
"If the target is a target list enclosed in parentheses or in square "
"brackets: The object must be an iterable with the same number of items as "
"there are targets in the target list, and its items are assigned, from left "
"to right, to the corresponding targets."
msgstr ""
"ターゲットが丸括弧や角括弧で囲われたターゲットリストの場合: オブジェクトは"
"ターゲットリスト中のターゲット数と同じ数の要素からなるイテレート可能オブジェ"
"クトでなければならず、その各要素は左から右へと対応するターゲットに代入されま"
"す。"

#: ../../reference/simple_stmts.rst:151
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not "
"necessarily :exc:`AttributeError`)."
msgstr ""
"ターゲットが属性参照の場合: 参照されている一次語の式が値評価されます。値は代"
"入可能な属性を伴うオブジェクトでなければなりません; そうでなければ、 :exc:"
"`TypeError` が送出されます。次に、このオブジェクトに対して、被代入オブジェク"
"トを指定した属性に代入してよいか問い合わせます; 代入を実行できない場合、例外 "
"(通常は :exc:`AttributeError` ですが、必然ではありません) を送出します。"

#: ../../reference/simple_stmts.rst:160
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the RHS expression, ``a.x`` can "
"access either an instance attribute or (if no instance attribute exists) a "
"class attribute.  The LHS target ``a.x`` is always set as an instance "
"attribute, creating it if necessary.  Thus, the two occurrences of ``a.x`` "
"do not necessarily refer to the same attribute: if the RHS expression refers "
"to a class attribute, the LHS creates a new instance attribute as the target "
"of the assignment::"
msgstr ""
"注意: オブジェクトがクラスインスタンスで、代入演算子の両辺に属性参照があると"
"き、右辺式の ``a.x`` はインスタンスの属性と (インスタンスの属性が存在しなけれ"
"ば) クラス属性のどちらにもアクセスする可能性があります。左辺のターゲット ``a."
"x`` は常にインスタンスの属性として割り当てられ、必要ならば生成されます。この"
"とおり、現れる二つの ``a.x`` は同じ値を参照するとは限りません: 右辺式はクラス"
"属性を参照し、左辺は新しいインスタンス属性を代入のターゲットとして生成するよ"
"うなとき::"

#: ../../reference/simple_stmts.rst:174
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""
"このことは、 :func:`property` で作成されたプロパティのようなデスクリプタ属性"
"に対しては、必ずしもあてはまるとは限りません。"

#: ../../reference/simple_stmts.rst:181
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary). Next, the subscript "
"expression is evaluated."
msgstr ""
"ターゲットが添字表記の場合 : 参照されている一次語の式が値評価されます。まず、"
"値は変更可能な ( リストのような ) シーケンスオブジェクトか、 ( 辞書のよう"
"な ) マップオブジェクトでなければなりません。次に、添字表記の表す式が値評価さ"
"れます。"

#: ../../reference/simple_stmts.rst:190
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield a plain integer.  If it is negative, the sequence's length is "
"added to it. The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, :exc:"
"`IndexError` is raised (assignment to a subscripted sequence cannot add new "
"items to a list)."
msgstr ""
"一次語が変更可能な ( リストのような ) シーケンスオブジェクトの場合、まず添字"
"は整数でなければなりません。添字が負数の場合、シーケンスの長さが加算されま"
"す。添字は最終的に、シーケンスの長さよりも小さな非負の整数でなくてはなりませ"
"ん。次に、添字をインデクスに持つ要素に非代入オブジェクトを代入してよいか、"
"シーケンスに問い合わせます。範囲を超えたインデクスに対しては :exc:"
"`IndexError` が送出されます ( 添字指定されたシーケンスに代入を行っても、リス"
"ト要素の新たな追加はできません ) 。"

#: ../../reference/simple_stmts.rst:201
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""
"一次語が (辞書のような) マップオブジェクトの場合、まず添字はマップのキー型と"
"互換性のある型でなくてはなりません。次に、添字を被代入オブジェクトに関連付け"
"るようなキー/データの対を生成するようマップオブジェクトに問い合わせます。この"
"操作では、既存のキー/値の対を同じキーと別の値で置き換えてもよく、(同じ値を持"
"つキーが存在しない場合) 新たなキー/値の対を挿入してもかまいません。"

#: ../../reference/simple_stmts.rst:209
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The "
"assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"(small) integers.  If either bound is negative, the sequence's length is "
"added to it. The resulting bounds are clipped to lie between zero and the "
"sequence's length, inclusive.  Finally, the sequence object is asked to "
"replace the slice with the items of the assigned sequence.  The length of "
"the slice may be different from the length of the assigned sequence, thus "
"changing the length of the target sequence, if the object allows it."
msgstr ""
"ターゲットがスライスの場合 : 参照されている一次語の式が値評価されます。まず、"
"値は変更可能な ( リストのような ) シーケンスオブジェクトでなければなりませ"
"ん。被代入オブジェクトは同じ型を持ったシーケンスオブジェクトでなければなりま"
"せん。次に、スライスの下境界と上境界を示す式があれば評価されます ; デフォルト"
"値はそれぞれゼロとシーケンスの長さです。上下境界は整数にならなければなりませ"
"ん。いずれかの境界が負数になった場合、シーケンスの長さが加算されます。最終的"
"に、境界はゼロからシーケンスの長さまでの内包になるようにクリップされます。最"
"後に、スライスを被代入オブジェクトで置き換えてよいかシーケンスオブジェクトに"
"問い合わせます。オブジェクトで許されている限り、スライスの長さは被代入シーケ"
"ンスの長さと異なっていてよく、この場合にはターゲットシーケンスの長さが変更さ"
"れます。"

#: ../../reference/simple_stmts.rst:223
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""
"現在の実装では、ターゲットの構文は式の構文と同じであるとみなされており、無効"
"な構文はコード生成フェーズ中に詳細なエラーメッセージを伴って拒否されます。"

#: ../../reference/simple_stmts.rst:227
msgid ""
"WARNING: Although the definition of assignment implies that overlaps between "
"the left-hand side and the right-hand side are 'safe' (for example ``a, b = "
"b, a`` swaps two variables), overlaps *within* the collection of assigned-to "
"variables are not safe!  For instance, the following program prints ``[0, "
"2]``::"
msgstr ""
"警告: 代入の定義では、左辺値と右辺値がオーバラップするような代入 (例えば、 "
"``a, b = b, a`` を行うと、二つの変数を入れ替えます) を定義しても '安全 "
"(safe)' に代入できますが、代入対象となる変数群 *の間で* オーバラップがある場"
"合は安全ではありません！例えば、以下のプログラムは ``[0, 2]`` を出力してしま"
"います::"

#: ../../reference/simple_stmts.rst:241
msgid "Augmented assignment statements"
msgstr "累算代入文 (augmented assignment statement)"

#: ../../reference/simple_stmts.rst:259
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr "累算代入文は、二項演算と代入文を組み合わせて一つの文にしたものです:"

#: ../../reference/simple_stmts.rst:271
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only "
"evaluated once."
msgstr ""
"累算代入文は、ターゲット (通常の代入文と違って、アンパックは起こりません) と"
"式リストを評価し、それら二つの被演算子間で特定の累算代入型の二項演算を行い、"
"結果をもとのターゲットに代入します。ターゲットは一度しか評価されません。"

#: ../../reference/simple_stmts.rst:276
msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented "
"version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""
"``x += 1`` のような累算代入式は、 ``x = x + 1`` のように書き換えてほぼ同様の"
"動作にできますが、厳密に等価にはなりません。累算代入の方では、 ``x`` は一度し"
"か評価されません。また、実際の処理として、可能ならば *インプレース (in-"
"place)* 演算が実行されます。これは、代入時に新たなオブジェクトを生成してター"
"ゲットに代入するのではなく、以前のオブジェクトの内容を変更するということで"
"す。"

#: ../../reference/simple_stmts.rst:282
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled "
"the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""
"累算代入文で行われる代入は、タプルへの代入や、一文中に複数のターゲットが存在"
"する場合を除き、通常の代入と同じように扱われます。同様に、累算代入で行われる"
"二項演算は、場合によって *インプレース演算* が行われることを除き、通常の二項"
"演算と同じです。"

#: ../../reference/simple_stmts.rst:288
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""
"属性参照のターゲットの場合、 :ref:`クラスとインスタンスの属性についての注意 "
"<attr-target-note>` と同様に通常の代入が適用されます。"

#: ../../reference/simple_stmts.rst:295
msgid "The :keyword:`assert` statement"
msgstr ":keyword:`assert` 文"

#: ../../reference/simple_stmts.rst:301
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a "
"program:"
msgstr ""
"assert 文は、プログラム内にデバッグ用アサーション (debugging assertion) を仕"
"掛けるための便利な方法です:"

#: ../../reference/simple_stmts.rst:307
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "単純な形式 ``assert expression`` は ::"

#: ../../reference/simple_stmts.rst:312
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr ""
"と等価です。拡張形式 ``assert expression1, expression2`` は、これと等価で"
"す ::"

#: ../../reference/simple_stmts.rst:321
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable :const:`__debug__` is ``True`` under "
"normal circumstances, ``False`` when optimization is requested (command line "
"option -O).  The current code generator emits no code for an assert "
"statement when optimization is requested at compile time.  Note that it is "
"unnecessary to include the source code for the expression that failed in the "
"error message; it will be displayed as part of the stack trace."
msgstr ""
"上記の等価関係は、 :const:`__debug__` と :exc:`AssertionError` が、同名の組み"
"込み変数を参照しているという前提の上に成り立っています。現在の実装では、組み"
"込み変数 :const:`__debug__` は通常の状況では ``True`` であり、最適化がリクエ"
"ストされた場合（コマンドラインオプション -O）は ``False`` です。現状のコード"
"生成器は、コンパイル時に最適化が要求されていると assert 文に対するコードを全"
"く出力しません。実行に失敗した式のソースコードをエラーメッセージ内に入れる必"
"要はありません; コードはスタックトレース内で表示されます。"

#: ../../reference/simple_stmts.rst:330
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ""
":const:`__debug__` への代入は不正な操作です。組み込み変数の値は、インタプリタ"
"が開始するときに決定されます。"

#: ../../reference/simple_stmts.rst:337
msgid "The :keyword:`pass` statement"
msgstr ":keyword:`pass` 文"

#: ../../reference/simple_stmts.rst:346
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""
":keyword:`pass` はヌル操作 (null operation) です --- :keyword:`pass` が実行さ"
"れても、何も起きません。 :keyword:`pass` は、構文法的には文が必要だが、コード"
"としては何も実行したくない場合のプレースホルダとして有用です。例えば::"

#: ../../reference/simple_stmts.rst:358
msgid "The :keyword:`del` statement"
msgstr ":keyword:`del` 文"

#: ../../reference/simple_stmts.rst:368
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""
"オブジェクトの削除 (deletion) は、代入の定義と非常に似た方法で再帰的に定義さ"
"れています。ここでは完全な詳細は記述せず、いくつかのヒントを述べるにとどめま"
"す。"

#: ../../reference/simple_stmts.rst:371
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr ""
"ターゲットリストに対する削除は、各々のターゲットを左から右へと順に再帰的に削"
"除します。"

#: ../../reference/simple_stmts.rst:377
msgid ""
"Deletion of a name removes the binding of that name  from the local or "
"global namespace, depending on whether the name occurs in a :keyword:"
"`global` statement in the same code block.  If the name is unbound, a :exc:"
"`NameError` exception will be raised."
msgstr ""
"名前に対して削除を行うと、ローカルまたはグローバル名前空間でのその名前の束縛"
"を解除します。どちらの名前空間かは、名前が同じコードブロック内の :keyword:"
"`global` 文で宣言されているかどうかによります。名前が未束縛 (unbound) である"
"ばあい、 :exc:`NameError` 例外が送出されます。"

#: ../../reference/simple_stmts.rst:384
msgid ""
"It is illegal to delete a name from the local namespace if it occurs as a "
"free variable in a nested block."
msgstr ""
"ネストしたブロック中で自由変数になっているローカル名前空間上の名前に対する削"
"除は不正な操作になります"

#: ../../reference/simple_stmts.rst:389
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr ""
"属性参照、添字表記、およびスライスの削除操作は、対象となる一次語オブジェクト"
"に渡されます; スライスの削除は一般的には適切な型の空のスライスを代入するのと"
"等価です (が、この仕様自体もスライスされるオブジェクトで決定されています)。"

#: ../../reference/simple_stmts.rst:398
msgid "The :keyword:`print` statement"
msgstr ":keyword:`print` 文"

#: ../../reference/simple_stmts.rst:406
msgid ""
":keyword:`print` evaluates each expression in turn and writes the resulting "
"object to standard output (see below).  If an object is not a string, it is "
"first converted to a string using the rules for string conversions.  The "
"(resulting or original) string is then written.  A space is written before "
"each object is (converted and) written, unless the output system believes it "
"is positioned at the beginning of a line.  This is the case (1) when no "
"characters have yet been written to standard output, (2) when the last "
"character written to standard output is a whitespace character except ``' "
"'``, or (3) when the last write operation on standard output was not a :"
"keyword:`print` statement. (In some cases it may be functional to write an "
"empty string to standard output for this reason.)"
msgstr ""
":keyword:`print` は、式を逐次的に評価し、得られたオブジェクトを標準出力に書き"
"出します。オブジェクトが文字列でなければ、まず文字列変換規則を使って文字列に"
"変換され、次いで ( 得られた文字列か、オリジナルの文字列が ) 書き出されます。"
"出力系の現在の書き出し位置が行頭にあると考えられる場合を除き、各オブジェクト"
"の出力前にスペースが一つ出力されます。行頭にある場合とは、 (1) 標準出力にまだ"
"何も書き出されていない場合、 (2) 標準出力に最後に書き出された文字が ``' '`` "
"を除く空白である、または (3) 標準出力に対する最後の書き出し操作が :keyword:"
"`print` 文によるものではない場合、です。 ( こうした理由から、場合によっては空"
"文字を標準出力に書き出すと便利なことがあります。 )"

#: ../../reference/simple_stmts.rst:420
msgid ""
"Objects which act like file objects but which are not the built-in file "
"objects often do not properly emulate this aspect of the file object's "
"behavior, so it is best not to rely on this."
msgstr ""
"組み込みのファイルオブジェクトでない、ファイルオブジェクトに似た動作をするオ"
"ブジェクトでは、組み込みのファイルオブジェクトが持つ上記の性質を適切にエミュ"
"レートしていないことがあるため、当てにしないほうがよいでしょう。"

#: ../../reference/simple_stmts.rst:430
msgid ""
"A ``'\\n'`` character is written at the end, unless the :keyword:`print` "
"statement ends with a comma.  This is the only action if the statement "
"contains just the keyword :keyword:`print`."
msgstr ""
":keyword:`print` 文がカンマで終了していない限り、末尾には文字 ``'\\n'`` が書"
"き出されます。この仕様は、文に予約語 :keyword:`print` がある場合のみの動作で"
"す。"

#: ../../reference/simple_stmts.rst:440
msgid ""
"Standard output is defined as the file object named ``stdout`` in the built-"
"in module :mod:`sys`.  If no such object exists, or if it does not have a :"
"meth:`write` method, a :exc:`RuntimeError` exception is raised."
msgstr ""
"標準出力は、組み込みモジュール :mod:`sys` 内で ``stdout`` という名前のファイ"
"ルオブジェクトとして定義されています。該当するオブジェクトが存在しないか、オ"
"ブジェクトに :meth:`write` メソッドがない場合、 :exc:`RuntimeError` 例外が送"
"出されます。 ."

#: ../../reference/simple_stmts.rst:446
msgid ""
":keyword:`print` also has an extended form, defined by the second portion of "
"the syntax described above. This form is sometimes referred to as \":keyword:"
"`print` chevron.\" In this form, the first expression after the ``>>`` must "
"evaluate to a \"file-like\" object, specifically an object that has a :meth:"
"`write` method as described above.  With this extended form, the subsequent "
"expressions are printed to this file object.  If the first expression "
"evaluates to ``None``, then ``sys.stdout`` is used as the file for output."
msgstr ""
":keyword:`print` には、上で説明した構文の第二形式で定義されている拡張形式があ"
"ります。この形式は、 \" 山形 :keyword:`print` 表記 (:keyword:`print` "
"chevron)\" と呼ばれます。この形式では、 ``>>`` の直後にくる最初の式の値評価結"
"果は \" ファイル類似 (file-like)\" なオブジェクト、とりわけ上で述べたように :"
"meth:`write` メソッドを持つオブジェクトでなければなりません。この拡張形式で"
"は、ファイルオブジェクトを指定する式よりも後ろの式が、指定されたファイルオブ"
"ジェクトに出力されます。最初の式の値評価結果が ``None`` になった場合、 ``sys."
"stdout`` が出力ファイルとして使われます。"

#: ../../reference/simple_stmts.rst:458
msgid "The :keyword:`return` statement"
msgstr ":keyword:`return` 文"

#: ../../reference/simple_stmts.rst:468
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""
":keyword:`return` は、関数定義内で構文法的にネストして現れますが、ネストした"
"クラス定義内には現れません。"

#: ../../reference/simple_stmts.rst:471
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""
"式リストがある場合、リストが値評価されます。それ以外の場合は ``None`` で置き"
"換えられます。"

#: ../../reference/simple_stmts.rst:473
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ""
":keyword:`return` を使うと、式リスト (または ``None``) を戻り値として、現在の"
"関数呼び出しから抜け出します。"

#: ../../reference/simple_stmts.rst:478
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really leaving the function."
msgstr ""
":keyword:`return` によって、 :keyword:`finally` 節をともなう :keyword:`try` "
"文の外に処理が引き渡されると、実際に関数から抜ける前に :keyword:`finally` 節"
"が実行されます。"

#: ../../reference/simple_stmts.rst:482
msgid ""
"In a generator function, the :keyword:`return` statement is not allowed to "
"include an :token:`expression_list`.  In that context, a bare :keyword:"
"`return` indicates that the generator is done and will cause :exc:"
"`StopIteration` to be raised."
msgstr ""
"ジェネレータ関数の場合には、 :keyword:`return` 文の中に :token:"
"`expression_list` を入れることはできません。ジェネレータ関数の処理コンテキス"
"トでは、単体の :keyword:`return` はジェネレータ処理を終了し :exc:"
"`StopIteration` を送出させることを示します。"

#: ../../reference/simple_stmts.rst:491
msgid "The :keyword:`yield` statement"
msgstr ":keyword:`yield` 文"

#: ../../reference/simple_stmts.rst:503
msgid ""
"The :keyword:`yield` statement is only used when defining a generator "
"function, and is only used in the body of the generator function. Using a :"
"keyword:`yield` statement in a function definition is sufficient to cause "
"that definition to create a generator function instead of a normal function."
msgstr ""
":keyword:`yield` 文は、ジェネレータ関数 (generator function) を定義するときだ"
"け使われ、かつジェネレータ関数の本体の中でだけ用いられます。関数定義中で :"
"keyword:`yield` 文を使うだけで、関数定義は通常の関数でなくジェネレータ関数に"
"なります。"

#: ../../reference/simple_stmts.rst:508
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator iterator, or more commonly, a generator.  The body of the "
"generator function is executed by calling the generator's :meth:`~generator."
"next` method repeatedly until it raises an exception."
msgstr ""
"ジェネレータ関数が呼び出されると、ジェネレータイテレータ (generator "
"iterator) 、一般的にはジェネレータ (generator) を返します。ジェネレータ関数の"
"本体は、ジェネレータの :meth:`~generator.next` が例外を発行するまで繰り返し呼"
"び出して実行します。"

#: ../../reference/simple_stmts.rst:513
msgid ""
"When a :keyword:`yield` statement is executed, the state of the generator is "
"frozen and the value of :token:`expression_list` is returned to :meth:"
"`~generator.next`'s caller.  By \"frozen\" we mean that all local state is "
"retained, including the current bindings of local variables, the instruction "
"pointer, and the internal evaluation stack: enough information is saved so "
"that the next time :meth:`~generator.next` is invoked, the function can "
"proceed exactly as if the :keyword:`yield` statement were just another "
"external call."
msgstr ""
":keyword:`yield` 文が実行されると、現在のジェネレータの状態は凍結 (freeze) さ"
"れ、 :token:`expression_list` の値が :meth:`~generator.next` の呼び出し側に返"
"されます。ここでの \"凍結\" は、ローカルな変数への束縛、命令ポインタ "
"(instruction pointer) 、および内部実行スタック (internal evaluation stack) を"
"含む、全てのローカルな状態が保存されることを意味します : すなわち、必要な情報"
"を保存しておき、次に :meth:`~generator.next` が呼び出された際に、関数が :"
"keyword:`yield` 文をあたかももう一つの外部呼出しであるかのように処理できるよ"
"うにします。"

#: ../../reference/simple_stmts.rst:521
msgid ""
"As of Python version 2.5, the :keyword:`yield` statement is now allowed in "
"the :keyword:`try` clause of a :keyword:`try` ...  :keyword:`finally` "
"construct.  If the generator is not resumed before it is finalized (by "
"reaching a zero reference count or by being garbage collected), the "
"generator-iterator's :meth:`close` method will be called, allowing any "
"pending :keyword:`finally` clauses to execute."
msgstr ""
"Python バージョン 2.5 では、 :keyword:`yield` 文が :keyword:`try` ... :"
"keyword:`finally` 構造における :keyword:`try` 節で許されるようになりました。"
"ジェネレータが終了（ finalized ）される（参照カウントがゼロになるか、ガベージ"
"コレクションされる ) までに再開されなければ、ジェネレータ - イテレータの :"
"meth:`close` メソッドが呼ばれ、留保されている :keyword:`finally` 節が実行でき"
"るようになります。"

#: ../../reference/simple_stmts.rst:528
msgid ""
"For full details of :keyword:`yield` semantics, refer to the :ref:"
"`yieldexpr` section."
msgstr ""
":keyword:`yield` の意味の完全な説明は、 :ref:`yieldexpr` 節を参照してくださ"
"い。"

#: ../../reference/simple_stmts.rst:533
msgid ""
"In Python 2.2, the :keyword:`yield` statement was only allowed when the "
"``generators`` feature has been enabled.  This ``__future__`` import "
"statement was used to enable the feature::"
msgstr ""
"Python 2.2 では、 ``generators`` 機能が有効になっている場合にのみ :keyword:"
"`yield` 文を使えました。この機能を有効にするための ``__future__`` import 文は"
"次のとおりでした。 ::"

#: ../../reference/simple_stmts.rst:543
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - 単純なジェネレータ"

#: ../../reference/simple_stmts.rst:543
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr "Python へのジェネレータと :keyword:`yield` 文の導入提案。"

#: ../../reference/simple_stmts.rst:546
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`0342` - 拡張されたジェネレータを用いたコルーチン"

#: ../../reference/simple_stmts.rst:546
msgid ""
"The proposal that, among other generator enhancements, proposed allowing :"
"keyword:`yield` to appear inside a :keyword:`try` ... :keyword:`finally` "
"block."
msgstr ""
"その他のジェネレータの改善と共に、 :keyword:`yield` が :keyword:`try` ... :"
"keyword:`finally` ブロックの中に存在することを可能にするための提案"

#: ../../reference/simple_stmts.rst:553
msgid "The :keyword:`raise` statement"
msgstr ":keyword:`raise` 文"

#: ../../reference/simple_stmts.rst:563
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the last exception "
"that was active in the current scope.  If no exception is active in the "
"current scope, a :exc:`TypeError` exception is raised indicating that this "
"is an error (if running under IDLE, a :exc:`Queue.Empty` exception is raised "
"instead)."
msgstr ""
"式を伴わない場合、 :keyword:`raise` は現在のスコープで最終的に有効になってい"
"る例外を再送出します。そのような例外が現在のスコープでアクティブでない場"
"合、 :exc:`TypeError` 例外が送出されて、これがエラーであることを示します "
"(IDLE で実行した場合は、代わりに exceptionQueue.Empty 例外を送出します ) 。"

#: ../../reference/simple_stmts.rst:568
msgid ""
"Otherwise, :keyword:`raise` evaluates the expressions to get three objects, "
"using ``None`` as the value of omitted expressions.  The first two objects "
"are used to determine the *type* and *value* of the exception."
msgstr ""
"それ以外の場合、 :keyword:`raise` は式を値評価して、三つのオブジェクトを取得"
"します。このとき、 ``None`` を省略された式の値として使います。最初の二つのオ"
"ブジェクトは、例外の * 型 (type)* と例外の * 値 (value)* を決定するために用い"
"られます。"

#: ../../reference/simple_stmts.rst:572
msgid ""
"If the first object is an instance, the type of the exception is the class "
"of the instance, the instance itself is the value, and the second object "
"must be ``None``."
msgstr ""
"最初のオブジェクトがインスタンスである場合、例外の型はインスタンスのクラスに"
"なり、インスタンス自体が例外の値になります。このとき第二のオブジェクトは "
"``None`` でなければなりません。"

#: ../../reference/simple_stmts.rst:576
msgid ""
"If the first object is a class, it becomes the type of the exception. The "
"second object is used to determine the exception value: If it is an instance "
"of the class, the instance becomes the exception value. If the second object "
"is a tuple, it is used as the argument list for the class constructor; if it "
"is ``None``, an empty argument list is used, and any other object is treated "
"as a single argument to the constructor.  The instance so created by calling "
"the constructor is used as the exception value."
msgstr ""
"最初のオブジェクトがクラスの場合、例外の型になります。第二のオブジェクトは、"
"例外の値を決めるために使われます : 第二のオブジェクトがインスタンスならば、そ"
"のインスタンスが例外の値になります。第二のオブジェクトがタプルの場合、クラス"
"のコンストラクタに対する引数リストとして使われます ; ``None`` なら、空の引数"
"リストとして扱われ、それ以外の型ならコンストラクタに対する単一の引数として扱"
"われます。このようにしてコンストラクタを呼び出して生成したインスタンスが例外"
"の値になります。"

#: ../../reference/simple_stmts.rst:586
msgid ""
"If a third object is present and not ``None``, it must be a traceback object "
"(see section :ref:`types`), and it is substituted instead of the current "
"location as the place where the exception occurred.  If the third object is "
"present and not a traceback object or ``None``, a :exc:`TypeError` exception "
"is raised.  The three-expression form of :keyword:`raise` is useful to re-"
"raise an exception transparently in an except clause, but :keyword:`raise` "
"with no expressions should be preferred if the exception to be re-raised was "
"the most recently active exception in the current scope."
msgstr ""
"第三のオブジェクトが存在し、かつ ``None`` でなければ、オブジェクトはトレース"
"バックオブジェクトでなければなりません ( :ref:`types` 節参照 ) 。また、例外が"
"発生した場所は現在の処理位置に置き換えられます。第三のオブジェクトが存在し、"
"オブジェクトがトレースバックオブジェクトでも ``None`` でもなければ、 :exc:"
"`TypeError` 例外が送出されます。 :keyword:`raise` の三連式型は、 :keyword:"
"`except` 節から透過的に例外を再送出するのに便利ですが、再送出すべき例外が現在"
"のスコープで発生した最も新しいアクティブな例外である場合には、式なしの :"
"keyword:`raise` を使うよう推奨します。"

#: ../../reference/simple_stmts.rst:595
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information about handling exceptions is in section :ref:"
"`try`."
msgstr ""
"例外に関する追加情報は :ref:`exceptions` 節にあります。また、例外処理に関する"
"情報は :ref:`try` 節にあります。"

#: ../../reference/simple_stmts.rst:602
msgid "The :keyword:`break` statement"
msgstr ":keyword:`break` 文"

#: ../../reference/simple_stmts.rst:613
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :"
"keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""
":keyword:`break` 文は、構文としては :keyword:`for` ループや :keyword:`while` "
"ループの内側でのみ出現することができますが、ループ内の関数定義やクラス定義の"
"内側には出現できません。"

#: ../../reference/simple_stmts.rst:619
msgid ""
"It terminates the nearest enclosing loop, skipping the optional :keyword:"
"`else` clause if the loop has one."
msgstr ""
":keyword:`break` 文は、文を囲う最も内側のループを終了させ、ループにオプション"
"の :keyword:`else` 節がある場合にはそれをスキップします。"

#: ../../reference/simple_stmts.rst:624
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control "
"target keeps its current value."
msgstr ""
":keyword:`for` ループを :keyword:`break` によって終了すると、ループ制御ター"
"ゲットはその時の値を保持します。"

#: ../../reference/simple_stmts.rst:629
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really leaving the loop."
msgstr ""
":keyword:`break` が :keyword:`finally` 節を伴う :keyword:`try` 文の外側に処理"
"を渡す際には、ループを実際に抜ける前にその :keyword:`finally` 節が実行されま"
"す。"

#: ../../reference/simple_stmts.rst:637
msgid "The :keyword:`continue` statement"
msgstr ":keyword:`continue` 文"

#: ../../reference/simple_stmts.rst:649
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"or :keyword:`finally` clause within that loop.  It continues with the next "
"cycle of the nearest enclosing loop."
msgstr ""
":keyword:`continue` 文は :keyword:`for` ループや :keyword:`while` ループ内の"
"ネストで構文法的にのみ現れますが、ループ内の関数定義やクラス定義、 :keyword:"
"`finally` 句の中には現れません。 :keyword:`continue` 文は、文を囲う最も内側の"
"ループの次の周期に処理を継続します。"

#: ../../reference/simple_stmts.rst:654
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really starting the next loop cycle."
msgstr ""
":keyword:`continue` が :keyword:`finally` 句を持った :keyword:`try` 文を抜け"
"るとき、その :keyword:`finally` 句が次のループサイクルを始める前に実行されま"
"す。"

#: ../../reference/simple_stmts.rst:663
msgid "The :keyword:`import` statement"
msgstr ":keyword:`import` 文"

#: ../../reference/simple_stmts.rst:683
msgid ""
"Import statements are executed in two steps: (1) find a module, and "
"initialize it if necessary; (2) define a name or names in the local "
"namespace (of the scope where the :keyword:`import` statement occurs). The "
"statement comes in two forms differing on whether it uses the :keyword:"
"`from` keyword. The first form (without :keyword:`from`) repeats these steps "
"for each identifier in the list. The form with :keyword:`from` performs step "
"(1) once, and then performs step (2) repeatedly."
msgstr ""
"import 文は、 (1) モジュールを探し、必要なら初期化 (initialize) する ; (:"
"keyword:`import` 文のあるスコープにおける ) ローカルな名前空間で名前を定義す"
"る、の二つの段階を踏んで初期化されます。 :keyword:`import` 文には、 :keyword:"
"`from` を使うか使わないかの 2 種類の形式があります。第一形式 (:keyword:"
"`from` のない形式 ) は、上記の段階をリスト中にある各識別子に対して繰り返し実"
"行していきます。 :keyword:`from` のある形式では、 (1) を一度だけ行い、次いで "
"(2) を繰り返し実行します。"

#: ../../reference/simple_stmts.rst:694
msgid ""
"To understand how step (1) occurs, one must first understand how Python "
"handles hierarchical naming of modules. To help organize modules and provide "
"a hierarchy in naming, Python has a concept of packages. A package can "
"contain other packages and modules while modules cannot contain other "
"modules or packages. From a file system perspective, packages are "
"directories and modules are files."
msgstr ""
"ステップ (1) がどのように行われるのかを理解するには、まず、 Python が階層的な"
"モジュール名をどう扱うのかを理解する必要があります。モジュールを組織化し名前"
"に階層を持たせるために、 Python はパッケージという概念を持っています。モ"
"ジュールが他のモジュールやパッケージを含むことができないのに対して、パッケー"
"ジは他のパッケージやモジュールを含むことができます。ファイルシステムの視点か"
"ら見ると、パッケージはディレクトリでモジュールはファイルです。"

#: ../../reference/simple_stmts.rst:704
msgid ""
"Once the name of the module is known (unless otherwise specified, the term "
"\"module\" will refer to both packages and modules), searching for the "
"module or package can begin. The first place checked is :data:`sys.modules`, "
"the cache of all modules that have been imported previously. If the module "
"is found there then it is used in step (2) of import."
msgstr ""
"モジュール名 ( 特に記述していない場合は、 \" モジュール \" とはパッケージとモ"
"ジュール両方を指しています ) が判ったとき、モジュールかパッケージの検索が始ま"
"ります。最初にチェックされる場所は、それまでにインポートされたすべてのモ"
"ジュールのキャッシュである :data:`sys.modules` です。もしモジュールがそこで見"
"つかれば、それが import のステップ (2) で利用されます。"

#: ../../reference/simple_stmts.rst:716
msgid ""
"If the module is not found in the cache, then :data:`sys.meta_path` is "
"searched (the specification for :data:`sys.meta_path` can be found in :pep:"
"`302`). The object is a list of :term:`finder` objects which are queried in "
"order as to whether they know how to load the module by calling their :meth:"
"`find_module` method with the name of the module. If the module happens to "
"be contained within a package (as denoted by the existence of a dot in the "
"name), then a second argument to :meth:`find_module` is given as the value "
"of the :attr:`__path__` attribute from the parent package (everything up to "
"the last dot in the name of the module being imported). If a finder can find "
"the module it returns a :term:`loader` (discussed later) or returns ``None``."
msgstr ""
"キャッシュにモジュールが見つからなかった場合、次は :data:`sys.meta_path` が検"
"索されます。 (:data:`sys.meta_path` の仕様は :pep:`302` に見つけることができ"
"ます。) これは :term:`finder` オブジェクトのリストで、そのモジュールを読み込"
"む方法を知っているかどうかをその :meth:`find_module` メソッドをモジュール名を"
"引数として呼び出すことで、順番に問い合せていきます。モジュールがパッケージに"
"含まれていた (モジュール名の中にドットが含まれていた) 場合、 :meth:"
"`find_module` の第 2 引数に親パッケージの :attr:`__path__` 属性が渡されま"
"す。 (モジュール名の最後のドットより前のすべてがインポートされます) finder は"
"モジュールを見つけたとき、 (後で解説する) :term:`loader` か ``None`` を返しま"
"す。"

#: ../../reference/simple_stmts.rst:732
msgid ""
"If none of the finders on :data:`sys.meta_path` are able to find the module "
"then some implicitly defined finders are queried. Implementations of Python "
"vary in what implicit meta path finders are defined. The one they all do "
"define, though, is one that handles :data:`sys.path_hooks`, :data:`sys."
"path_importer_cache`, and :data:`sys.path`."
msgstr ""
":data:`sys.meta_path` に含まれるすべての finder が module を見つけられない場"
"合、幾つかの暗黙的に定義されている finder に問い合わせられます。どんな暗黙の "
"meta path finder が定義されているかは Python の実装によって様々です。すべての"
"実装が定義しなければならない 1 つの finder は、 :data:`sys.path_hooks` を扱い"
"ます。"

#: ../../reference/simple_stmts.rst:738
msgid ""
"The implicit finder searches for the requested module in the \"paths\" "
"specified in one of two places (\"paths\" do not have to be file system "
"paths). If the module being imported is supposed to be contained within a "
"package then the second argument passed to :meth:`find_module`, :attr:"
"`__path__` on the parent package, is used as the source of paths. If the "
"module is not contained in a package then :data:`sys.path` is used as the "
"source of paths."
msgstr ""
"この暗黙の finder は要求されたモジュールを、 2 箇所のどちらかで定義されてい"
"る \"paths\" から探します。 (\"paths\" がファイルシステムパスである必要はあり"
"ません ) インポートしようとしているモジュールがパッケージに含まれている場合、"
"親パッケージの :attr:`__path__` が :meth:`find_module` の第 2 引数として渡さ"
"れ、それが paths として扱われます。モジュールがパッケージに含まれていない場"
"合、 :data:`sys.path` が paths として扱われます。"

#: ../../reference/simple_stmts.rst:745
msgid ""
"Once the source of paths is chosen it is iterated over to find a finder that "
"can handle that path. The dict at :data:`sys.path_importer_cache` caches "
"finders for paths and is checked for a finder. If the path does not have a "
"finder cached then :data:`sys.path_hooks` is searched by calling each object "
"in the list with a single argument of the path, returning a finder or "
"raises :exc:`ImportError`. If a finder is returned then it is cached in :"
"data:`sys.path_importer_cache` and then used for that path entry. If no "
"finder can be found but the path exists then a value of ``None`` is stored "
"in :data:`sys.path_importer_cache` to signify that an implicit, file-based "
"finder that handles modules stored as individual files should be used for "
"that path. If the path does not exist then a finder which always returns "
"``None`` is placed in the cache for the path."
msgstr ""
"paths が決定されたら、それを巡回してその path を扱える finder を探します。 :"
"data:`sys.path_importer_cache` 辞書は path に対する finder をキャッシュしてお"
"り、 finder を探すときにチェックされます。 path がキャッシュに登録されていな"
"い場合は、 :data:`sys.path_hooks` の各オブジェクトを 1 つの引数 path で呼び出"
"します。各オブジェクトは finder を返すか、 :exc:`ImportError` を発生させま"
"す。 finder が返された場合、それを :data:`sys.path_importer_cache` にキャッ"
"シュして、その path に対してその finder を使います。 finder が見つからず、 "
"path が存在している場合、 ``None`` が :data:`sys.path_importer_cache` に格納"
"されて、暗黙の、単一のファイルとしてモジュールが格納されているとしてあつかう"
"ファイルベースの finder をその path に対して利用することを示します。その "
"path が存在しなかった場合、常に ``None`` を返す finder がその path に対する"
"キャッシュとして格納されます。"

#: ../../reference/simple_stmts.rst:763
msgid ""
"If no finder can find the module then :exc:`ImportError` is raised. "
"Otherwise some finder returned a loader whose :meth:`load_module` method is "
"called with the name of the module to load (see :pep:`302` for the original "
"definition of loaders). A loader has several responsibilities to perform on "
"a module it loads. First, if the module already exists in :data:`sys."
"modules` (a possibility if the loader is called outside of the import "
"machinery) then it is to use that module for initialization and not a new "
"module. But if the module does not exist in :data:`sys.modules` then it is "
"to be added to that dict before initialization begins. If an error occurs "
"during loading of the module and it was added to :data:`sys.modules` it is "
"to be removed from the dict. If an error occurs but the module was already "
"in :data:`sys.modules` it is left in the dict."
msgstr ""
"全ての finder がそのモジュールを見つけられないときは、 :exc:`ImportError` が"
"発生します。そうでなければ、どれかの finder が loader を返し、その :meth:"
"`load_module` メソッドがモジュール名を引数に呼び出されてロードを行ないます。 "
"( ローダーのオリジナルの定義については :pep:`302` を参照してください。 ) "
"loader はロードするモジュールに対して幾つかの責任があります。まず、そのモ"
"ジュールがすでに :data:`sys.modules` にあれば、 ( ローダーが import 機構の外"
"から呼ばれた場合に有り得ます ) そのモジュールを初期化に使い、新しいモジュール"
"を使いません。 :data:`sys.modules` にそのモジュールがなければ、初期化を始める"
"前に :data:`sys.modules` に追加します。 :data:`sys.modules` に追加したあと、"
"モジュールのロード中にエラーが発生した場合は、その辞書から削除します。モ"
"ジュールが既に :data:`sys.modules` にあった場合は、エラーが発生してもその辞書"
"に残しておきます。"

#: ../../reference/simple_stmts.rst:783
msgid ""
"The loader must set several attributes on the module. :data:`__name__` is to "
"be set to the name of the module. :data:`__file__` is to be the \"path\" to "
"the file unless the module is built-in (and thus listed in :data:`sys."
"builtin_module_names`) in which case the attribute is not set. If what is "
"being imported is a package then :data:`__path__` is to be set to a list of "
"paths to be searched when looking for modules and packages contained within "
"the package being imported. :data:`__package__` is optional but should be "
"set to the name of package that contains the module or package (the empty "
"string is used for module not contained in a package). :data:`__loader__` is "
"also optional but should be set to the loader object that is loading the "
"module."
msgstr ""
"ローダーは幾つかの属性をモジュールに設定しなければなりません。モジュール名"
"を :data:`__name__` に設定します。ファイルの \"path\" を :data:`__file__` に"
"設定しますが、ビルトインモジュール (:data:`sys.builtin_module_names` にリスト"
"されている ) の場合にはその属性を設定しません。インポートしているのがパッケー"
"ジだった場合は、そのパッケージが含むモジュールやパッケージを探す場所の path "
"のリストを :data:`__path_` に設定します。 :data:`__package__` はオプションで"
"すが、そのモジュールやパッケージを含むパッケージ名 ( パッケージに含まれていな"
"いモジュールには空文字列 ) を設定するべきです。 :data:`__loader__` もオプショ"
"ンですが、そのモジュールをロードした loader オブジェクトを設定するべきです。"

#: ../../reference/simple_stmts.rst:798
msgid ""
"If an error occurs during loading then the loader raises :exc:`ImportError` "
"if some other exception is not already being propagated. Otherwise the "
"loader returns the module that was loaded and initialized."
msgstr ""
"ロード中にエラーが発生した場合、他の例外がすでに伝播していないのであれば、 "
"loader は :exc:`ImportError` を発生させます。それ以外の場合は、 loader はロー"
"ドして初期化したモジュールを返します。"

#: ../../reference/simple_stmts.rst:802
msgid ""
"When step (1) finishes without raising an exception, step (2) can begin."
msgstr "段階 (1) が例外を送出することなく完了したなら、段階 (2) を開始します。"

#: ../../reference/simple_stmts.rst:804
msgid ""
"The first form of :keyword:`import` statement binds the module name in the "
"local namespace to the module object, and then goes on to import the next "
"identifier, if any.  If the module name is followed by :keyword:`as`, the "
"name following :keyword:`as` is used as the local name for the module."
msgstr ""
":keyword:`import` 文の第一形式は、ローカルな名前空間に置かれたモジュール名を"
"モジュールオブジェクトに束縛し、 import すべき次の識別子があればその処理に移"
"ります。モジュール名の後ろに :keyword:`as` がある場合、 :keyword:`as` の後ろ"
"の名前はモジュールのローカルな名前として使われます。"

#: ../../reference/simple_stmts.rst:813
msgid ""
"The :keyword:`from` form does not bind the module name: it goes through the "
"list of identifiers, looks each one of them up in the module found in step "
"(1), and binds the name in the local namespace to the object thus found.  As "
"with the first form of :keyword:`import`, an alternate local name can be "
"supplied by specifying \":keyword:`as` localname\".  If a name is not "
"found, :exc:`ImportError` is raised.  If the list of identifiers is replaced "
"by a star (``'*'``), all public names defined in the module are bound in the "
"local namespace of the :keyword:`import` statement.."
msgstr ""
":keyword:`from` 形式は、モジュール名の束縛を行いません : :keyword:`from` 形式"
"では、段階 (1) で見つかったモジュール内から、識別子リストの各名前を順に検索"
"し、見つかったオブジェクトを識別子の名前でローカルな名前空間において束縛しま"
"す。 :keyword:`import` の第一形式と同じように、 \":keyword:`as` localname\" "
"で別名を与えることができます。指定された名前が見つからない場合、 :exc:"
"`ImportError` が送出されます。識別子のリストを星印 (``'*'``) で置き換えると、"
"モジュールで公開されている名前 (public name) 全てを :keyword:`import` 文のあ"
"る場所のローカルな名前空間に束縛します。"

#: ../../reference/simple_stmts.rst:824
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to "
"exist.  If ``__all__`` is not defined, the set of public names includes all "
"names found in the module's namespace which do not begin with an underscore "
"character (``'_'``). ``__all__`` should contain the entire public API. It is "
"intended to avoid accidentally exporting items that are not part of the API "
"(such as library modules which were imported and used within the module)."
msgstr ""
"モジュールで * 公開されている名前 (public names)* は、モジュールの名前空間内"
"にある ``__all__`` という名前の変数を調べて決定します ; ``__all__`` が定義さ"
"れている場合、 ``__all__`` はモジュールで定義されていたり、 import されている"
"ような名前の文字列からなるシーケンスでなければなりません。 ``__all__`` 内にあ"
"る名前は、全て公開された名前であり、実在するものとみなされます。 ``__all__`` "
"が定義されていない場合、モジュールの名前空間に見つかった名前で、アンダースコ"
"ア文字 (``'_'``) で始まっていない全ての名前が公開された名前になります。 "
"``__all__`` には、公開されている API 全てを入れなければなりません。 "
"``__all__`` には、 ( モジュール内で import されて使われているライブラリモ"
"ジュールのように ) API を構成しない要素を意に反して公開してしまうのを避けると"
"いう意図があります。"

#: ../../reference/simple_stmts.rst:834
msgid ""
"The :keyword:`from` form with ``*`` may only occur in a module scope.  If "
"the wild card form of import --- ``import *`` --- is used in a function and "
"the function contains or is a nested block with free variables, the compiler "
"will raise a :exc:`SyntaxError`."
msgstr ""
"``*`` を使った :keyword:`from` 形式は、モジュールのスコープ内だけに作用しま"
"す。関数内でワイルドカードの import 文 --- ``import *`` --- を使い、関数が自"
"由変数を伴うネストされたブロックであったり、ブロックを含んでいる場合、コンパ"
"イラは :exc:`SyntaxError` を送出します。"

#: ../../reference/simple_stmts.rst:842
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top "
"package without having to mention the package name. By using leading dots in "
"the specified module or package after :keyword:`from` you can specify how "
"high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the "
"import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained "
"within :pep:`328`."
msgstr ""
"インポートするモジュールを指定するとき、そのモジュールの絶対名 (absolute "
"name) を指定する必要はありません。モジュールやパッケージが他のパッケージに含"
"まれている場合、共通のトップパッケージからそのパッケージ名を記述することなく"
"相対インポートすることができます。 :keyword:`from` の後に指定されるモジュール"
"やパッケージの先頭に複数個のドットを付けることで、正確な名前を指定することな"
"しに現在のパッケージ階層からいくつ上の階層へ行くかを指定することができます。"
"先頭のドットが 1 つの場合、 import をおこなっているモジュールが存在する現在の"
"パッケージを示します。 3 つのドットは 2 つ上のレベルを示します。なので、 "
"``pkg`` パッケージの中のモジュールで ``from . import mod`` を実行すると、 "
"``pkg.mod`` をインポートすることになります。 ``pkg.subpkg1`` の中から "
"``from ..subpkg2 import mod`` を実行すると、 ``pkg.subpkg2.mod`` をインポート"
"します。相対インポートの仕様は :pep:`328` に含まれています。"

#: ../../reference/simple_stmts.rst:855
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine which modules need to be loaded dynamically."
msgstr ""
"どのモジュールがロードされるべきかを動的に決めたいアプリケーションのために、"
"組み込み関数 :func:`importlib.import_module` が提供されています。"

#: ../../reference/simple_stmts.rst:862
msgid "Future statements"
msgstr "future 文 (future statement)"

#: ../../reference/simple_stmts.rst:866
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python.  The future statement is intended "
"to ease migration to future versions of Python that introduce incompatible "
"changes to the language.  It allows use of the new features on a per-module "
"basis before the release in which the feature becomes standard."
msgstr ""
":dfn:`future 文` は、将来の特定の Python のリリースで利用可能になるような構文"
"や意味付けを使って、特定のモジュールをコンパイルさせるための、コンパイラに対"
"する指示句 (directive) です。 future 文は、言語仕様に非互換性がもたらされるよ"
"うな、将来の Python のバージョンに容易に移行できるよう意図されています。 "
"future 文によって、新たな機能が標準化されたリリースが出される前に、その機能を"
"モジュール単位で使えるようにします。"

#: ../../reference/simple_stmts.rst:881
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr ""
"future 文は、モジュールの先頭周辺に書かなければなりません。 future 文の前に書"
"いてよい内容は以下です :"

#: ../../reference/simple_stmts.rst:884
msgid "the module docstring (if any),"
msgstr "モジュールのドキュメンテーション文字列 ( あれば )"

#: ../../reference/simple_stmts.rst:885
msgid "comments,"
msgstr "コメント ,"

#: ../../reference/simple_stmts.rst:886
msgid "blank lines, and"
msgstr "空行 ,"

#: ../../reference/simple_stmts.rst:887
msgid "other future statements."
msgstr "その他の future 文。"

#: ../../reference/simple_stmts.rst:889
msgid ""
"The features recognized by Python 2.6 are ``unicode_literals``, "
"``print_function``, ``absolute_import``, ``division``, ``generators``, "
"``nested_scopes`` and ``with_statement``.  ``generators``, "
"``with_statement``, ``nested_scopes`` are redundant in Python version 2.6 "
"and above because they are always enabled."
msgstr ""
"Python 2.6 が認識する機能は、 ``unicode_literals``, ``print_function``, "
"``absolute_import``, ``division``, ``generators``, ``nested_scopes``, "
"``with_statement`` です。 ``generators``, ``with_statement``, "
"``nested_scopes`` は Python 2.6 以上では常に有効なので冗長です。"

#: ../../reference/simple_stmts.rst:895
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""
"future 文は、コンパイル時に特別なやり方で認識され、扱われます: 言語の中核をな"
"す構文構成 (construct) に対する意味付けが変更されている場合、変更部分はしばし"
"ば異なるコードを生成することで実現されています。新たな機能によって、(新たな予"
"約語のような) 互換性のない新たな構文が取り入れられることさえあります。この場"
"合、コンパイラはモジュールを別のやりかたで解析する必要があるかもしれません。"
"こうしたコード生成に関する決定は、実行時まで先延ばしすることはできません。"

#: ../../reference/simple_stmts.rst:902
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""
"これまでの全てのリリースにおいて、コンパイラはどの機能が定義済みかを知ってお"
"り、 future 文に未知の機能が含まれている場合にはコンパイル時エラーを送出しま"
"す。"

#: ../../reference/simple_stmts.rst:906
msgid ""
"The direct runtime semantics are the same as for any import statement: there "
"is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""
"future 文の実行時における直接的な意味付けは、 import 文と同じです。標準モ"
"ジュール :mod:`__future__` があり、これについては後で述べます。 :mod:"
"`__future__` は、 future 文が実行される際に通常の方法で import されます。"

#: ../../reference/simple_stmts.rst:910
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr ""
"future 文の実行時における特別な意味付けは、 future 文で有効化される特定の機能"
"によって変わります。"

#: ../../reference/simple_stmts.rst:913
msgid "Note that there is nothing special about the statement::"
msgstr "以下の文には、何ら特殊な意味はないので注意してください::"

#: ../../reference/simple_stmts.rst:917
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr ""
"これは future 文ではありません; この文は通常の import 文であり、その他の特殊"
"な意味付けや構文的な制限はありません。"

#: ../../reference/simple_stmts.rst:920
msgid ""
"Code compiled by an :keyword:`exec` statement or calls to the built-in "
"functions :func:`compile` and :func:`execfile` that occur in a module :mod:"
"`M` containing a future statement will, by default, use the new  syntax or "
"semantics associated with the future statement.  This can, starting with "
"Python 2.2 be controlled by optional arguments to :func:`compile` --- see "
"the documentation of that function for details."
msgstr ""
"future 文の入ったモジュール :mod:`M` 内で使われている :keyword:`exec` 文、組"
"み込み関数 :func:`compile` や :func:`execfile` によってコンパイルされるコード"
"は、デフォルトの設定では、 future 文に関係する新たな構文や意味付けを使うよう"
"になっています。 Python 2.2 からは、この仕様を :func:`compile` のオプション引"
"数で制御できるようになりました --- 詳細はこの関数に関するドキュメントを参照し"
"てください。"

#: ../../reference/simple_stmts.rst:927
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""
"対話的インタプリタのプロンプトでタイプ入力した future 文は、その後のインタプ"
"リタセッション中で有効になります。インタプリタを :option:`-i` オプションで起"
"動して実行すべきスクリプト名を渡し、スクリプト中に future 文を入れておくと、"
"新たな機能はスクリプトが実行された後に開始する対話セッションで有効になりま"
"す。"

#: ../../reference/simple_stmts.rst:935
msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` - Back to the __future__"

#: ../../reference/simple_stmts.rst:936
msgid "The original proposal for the __future__ mechanism."
msgstr "__future__ 機構の原案"

#: ../../reference/simple_stmts.rst:942
msgid "The :keyword:`global` statement"
msgstr ":keyword:`global` 文"

#: ../../reference/simple_stmts.rst:951
msgid ""
"The :keyword:`global` statement is a declaration which holds for the entire "
"current code block.  It means that the listed identifiers are to be "
"interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`global`, although free variables may refer to "
"globals without being declared global."
msgstr ""
":keyword:`global` 文は、現在のコードブロック全体で維持される宣言文です。 :"
"keyword:`global` 文は、列挙した識別子をグローバル変数として解釈するよう指定す"
"ることを意味します。 :keyword:`global` を使わずにグローバル変数に代入を行うこ"
"とは不可能ですが、自由変数を使えばその変数をグローバルであると宣言せずにグ"
"ローバル変数を参照することができます。"

#: ../../reference/simple_stmts.rst:957
msgid ""
"Names listed in a :keyword:`global` statement must not be used in the same "
"code block textually preceding that :keyword:`global` statement."
msgstr ""
":keyword:`global` 文で列挙する名前は、同じコードブロック中で、プログラムテキ"
"スト上 :keyword:`global` 文より前に使ってはなりません。"

#: ../../reference/simple_stmts.rst:960
msgid ""
"Names listed in a :keyword:`global` statement must not be defined as formal "
"parameters or in a :keyword:`for` loop control target, :keyword:`class` "
"definition, function definition, or :keyword:`import` statement."
msgstr ""
":keyword:`global` 文で列挙する名前は、 :keyword:`for` ループのループ制御ター"
"ゲットや、 :keyword:`class` 定義、関数定義、 :keyword:`import` 文内で仮引数と"
"して使ってはなりません。"

#: ../../reference/simple_stmts.rst:966
msgid ""
"The current implementation does not enforce the latter two restrictions, but "
"programs should not abuse this freedom, as future implementations may "
"enforce them or silently change the meaning of the program."
msgstr ""
"現在の実装では、後ろ二つの制限については強制していませんが、プログラムでこの"
"緩和された仕様を乱用すべきではありません。将来の実装では、この制限を強制した"
"り、暗黙のうちにプログラムの意味付けを変更したりする可能性があります。"

#: ../../reference/simple_stmts.rst:976
msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`global` "
"statement. In particular, a :keyword:`global` statement contained in an :"
"keyword:`exec` statement does not affect the code block *containing* the :"
"keyword:`exec` statement, and code contained in an :keyword:`exec` statement "
"is unaffected by :keyword:`global` statements in the code containing the :"
"keyword:`exec` statement.  The same applies to the :func:`eval`, :func:"
"`execfile` and :func:`compile` functions."
msgstr ""
"**プログラマのための注意書き:** :keyword:`global` はパーサーに対する指示句 "
"(directive) です。この指示句は、 :keyword:`global` 文と同時に読み込まれたコー"
"ドに対してのみ適用されます。特に、 :keyword:`exec` 文内に入っている :keyword:"
"`global` 文は、 :keyword:`exec` 文を * 含んでいる * コードブロック内に効果を"
"及ぼすことはなく、 :keyword:`exec` 文内に含まれているコードは、 :keyword:"
"`exec` 文を含むコード内での :keyword:`global` 文に影響を受けません。同様のこ"
"とが、関数 :func:`eval` 、 :func:`execfile` 、および :func:`compile` にも当て"
"はまります。"

#: ../../reference/simple_stmts.rst:989
msgid "The :keyword:`exec` statement"
msgstr ":keyword:`exec` 文"

#: ../../reference/simple_stmts.rst:996
msgid ""
"This statement supports dynamic execution of Python code.  The first "
"expression should evaluate to either a Unicode string, a *Latin-1* encoded "
"string, an open file object, a code object, or a tuple.  If it is a string, "
"the string is parsed as a suite of Python statements which is then executed "
"(unless a syntax error occurs). [#]_ If it is an open file, the file is "
"parsed until EOF and executed. If it is a code object, it is simply "
"executed.  For the interpretation of a tuple, see below.  In all cases, the "
"code that's executed is expected to be valid as file input (see section :ref:"
"`file-input`).  Be aware that the :keyword:`return` and :keyword:`yield` "
"statements may not be used outside of function definitions even within the "
"context of code passed to the :keyword:`exec` statement."
msgstr ""
"この文は、 Python コードの動的な実行をサポートします。最初の式の値評価結果 "
"Unicode 文字列, *Latin-1* エンコード文字列, 開かれたファイルオブジェクト, "
"コードオブジェクト, タプルのいずれかでなければなりません。文字列の場合、一連"
"の Python 実行文として解析し、 (構文エラーが生じない限り) 実行します。 [#]_ "
"開かれたファイルであれば、ファイルを EOF まで読んで解析し、実行します。コード"
"オブジェクトなら、単にこれを実行します。タプルの翻訳については後述します。全"
"ての場合で、実行されたコードはファイル入力として有効であることが期待されます "
"(セクション :ref:`file-input` を参照) 。 :keyword:`return` と :keyword:"
"`yield` 文は、 :keyword:`exec` 文に渡されたコードの文脈中においても関数定義の"
"外では使われない点に注意してください。"

#: ../../reference/simple_stmts.rst:1008
msgid ""
"In all cases, if the optional parts are omitted, the code is executed in the "
"current scope.  If only the first expression after ``in`` is specified, it "
"should be a dictionary, which will be used for both the global and the local "
"variables.  If two expressions are given, they are used for the global and "
"local variables, respectively. If provided, *locals* can be any mapping "
"object. Remember that at module level, globals and locals are the same "
"dictionary. If two separate objects are given as *globals* and *locals*, the "
"code will be executed as if it were embedded in a class definition."
msgstr ""
"いずれの場合でも、オプションの部分が省略されると、コードは現在のスコープ内で"
"実行されます。 ``in`` の後ろに一つだけ式を指定する場合、その式は辞書でなくて"
"はならず、グローバル変数とローカル変数の両方に使われます。これらはそれぞれグ"
"ローバル変数とローカル変数として使われます。 *locals* を指定する場合は何らか"
"のマップ型オブジェクトにせねばなりません。モジュールレベルでは、グローバルと"
"ローカルは同じ辞書です。 *globals* と *locals* として別のオブジェクトを取った"
"場合、コードはクラス定義に埋め込まれたかのように実行されます。"

#: ../../reference/simple_stmts.rst:1017
msgid ""
"The first expression may also be a tuple of length 2 or 3.  In this case, "
"the optional parts must be omitted.  The form ``exec(expr, globals)`` is "
"equivalent to ``exec expr in globals``, while the form ``exec(expr, globals, "
"locals)`` is equivalent to ``exec expr in globals, locals``.  The tuple form "
"of ``exec`` provides compatibility with Python 3, where ``exec`` is a "
"function rather than a statement."
msgstr ""
"最初の式は長さ 2 か 3 のタプルにできます。このケースの場合は、残りの省略可能"
"部分は省略しなければなりません。 ``exec(expr, globals)`` 形式は ``exec expr "
"in globals`` と等価で、 ``exec(expr, globals, locals)`` 形式は ``exec expr "
"in globals, locals`` と等価です。 ``exec`` のタプル形式は、 ``exec`` が文では"
"なく関数になっている Python 3 との互換性を提供します。"

#: ../../reference/simple_stmts.rst:1024
msgid "Formerly, *locals* was required to be a dictionary."
msgstr "以前は *locals* は辞書でなければなりませんでした ."

#: ../../reference/simple_stmts.rst:1031
msgid ""
"As a side effect, an implementation may insert additional keys into the "
"dictionaries given besides those corresponding to variable names set by the "
"executed code.  For example, the current implementation may add a reference "
"to the dictionary of the built-in module :mod:`__builtin__` under the key "
"``__builtins__`` (!)."
msgstr ""
":keyword:`exec` の副作用として実行されるコードで設定された変数名に対応する名"
"前の他に、追加のキーを辞書に追加することがあります。例えば、現在の実装では、"
"組み込みモジュール :mod:`__builtin__` の辞書に対する参照を、 "
"``__builtins__`` (!) というキーで追加することがあります。"

#: ../../reference/simple_stmts.rst:1042
msgid ""
"**Programmer's hints:** dynamic evaluation of expressions is supported by "
"the built-in function :func:`eval`.  The built-in functions :func:`globals` "
"and :func:`locals` return the current global and local dictionary, "
"respectively, which may be useful to pass around for use by :keyword:`exec`."
msgstr ""
"**プログラマのためのヒント:** 式の動的な評価は、組み込み関数 :func:`eval` で"
"サポートされています。組み込み関数 :func:`globals` および :func:`locals` は、"
"それぞれ現在のグローバル辞書とローカル辞書を返すので、 :keyword:`exec` に渡し"
"て使うと便利です。"

#: ../../reference/simple_stmts.rst:1049
msgid "Footnotes"
msgstr "注記"

#: ../../reference/simple_stmts.rst:1050
msgid ""
"Note that the parser only accepts the Unix-style end of line convention. If "
"you are reading the code from a file, make sure to use :term:`universal "
"newlines` mode to convert Windows or Mac-style newlines."
msgstr ""
"なお、パーサは Unix スタイルの行末の記法しか受け付けません。コードをファイル"
"から読んでいるなら、必ず、 :term:`universal newlines`  モードで Windows や "
"Mac スタイルの改行を変換してください。"
