# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2021
# mollinaca, 2021
# Atsuo Ishimoto <atsuoishimoto@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-24 14:15+0000\n"
"PO-Revision-Date: 2021-06-28 01:49+0000\n"
"Last-Translator: Atsuo Ishimoto <atsuoishimoto@gmail.com>, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr "単純文 (simple statement)"

#: ../../reference/simple_stmts.rst:10
msgid ""
"A simple statement is comprised within a single logical line. Several simple "
"statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""
"単純文とは、単一の論理行内に収められる文です。単一の行内には、複数の単純文を"
"セミコロンで区切って入れることができます。単純文の構文は以下の通りです:"

#: ../../reference/simple_stmts.rst:36
msgid "Expression statements"
msgstr "式文 (expression statement)"

#: ../../reference/simple_stmts.rst:43
msgid ""
"Expression statements are used (mostly interactively) to compute and write a "
"value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""
"式文は、(主に対話的な使い方では) 値を計算して出力するために使ったり、(通常"
"は) プロシジャ (procedure: 有意な結果を返さない関数のことです; Python では、"
"プロシジャは値 ``None`` を返します) を呼び出すために使います。その他の使い方"
"でも式文を使うことができますし、有用なこともあります。式文の構文は以下の通り"
"です:"

#: ../../reference/simple_stmts.rst:52
msgid ""
"An expression statement evaluates the expression list (which may be a single "
"expression)."
msgstr "式文は式のリスト (単一の式のこともあります) を値評価します。"

#: ../../reference/simple_stmts.rst:64
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""
"対話モードでは、値が ``None`` でなければ、値を組み込み関数 :func:`repr` で文"
"字列に変換して、その結果の文字列を標準出力に一行使って書き出します。 "
"(``None`` になる式文の値は書き出されないので、プロシジャの呼び出しを行っても"
"出力は得られません。)"

#: ../../reference/simple_stmts.rst:72
msgid "Assignment statements"
msgstr "代入文 (assignment statement)"

#: ../../reference/simple_stmts.rst:82
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""
"代入文は、名前を値に (再) 束縛したり、変更可能なオブジェクトの属性や要素を変"
"更したりするために使われます:"

#: ../../reference/simple_stmts.rst:96
msgid ""
"(See section :ref:`primaries` for the syntax definitions for *attributeref*, "
"*subscription*, and *slicing*.)"
msgstr ""
"(*attributeref*, *subscription*, *slicing* の構文については :ref:`primaries` "
"節を参照してください。)"

#: ../../reference/simple_stmts.rst:99
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""
"代入文は式のリスト (これは単一の式でも、カンマで区切られた式リストでもよく、"
"後者はタプルになることを思い出してください) を評価し、得られたそれぞれのオブ"
"ジェクトをターゲット (target) のリストに対して左から右へと代入してゆきます。"

#: ../../reference/simple_stmts.rst:108
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""
"代入はターゲット (リスト) の形式に従って再帰的に行われます。ターゲットが変更"
"可能なオブジェクト (属性参照、添字表記、またはスライス) の一部である場合、こ"
"の変更可能なオブジェクトは最終的に代入を実行して、その代入が有効な操作である"
"か判断しなければなりません。代入が不可能な場合には例外を発行することもできま"
"す。型ごとにみられる規則や、送出される例外は、そのオブジェクト型定義で与えら"
"れています (:ref:`types` 節を参照してください)."

#: ../../reference/simple_stmts.rst:121
msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses "
"or square brackets, is recursively defined as follows."
msgstr ""
"ターゲットリストは、丸括弧や角括弧で囲まれていてもよく、それに対するオブジェ"
"クトの代入は、以下のように再帰的に定義されています。"

#: ../../reference/simple_stmts.rst:124
msgid ""
"If the target list is a single target with no trailing comma, optionally in "
"parentheses, the object is assigned to that target."
msgstr ""
"ターゲットリストのターゲットが1つだけでコンマが続いておらず、任意に丸括弧で囲"
"われている場合、オブジェクトはそのターゲットに代入されます。"

#: ../../reference/simple_stmts.rst:127
msgid "Else:"
msgstr ""

#: ../../reference/simple_stmts.rst:129
msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be an iterable with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the iterable are assigned, from left to right, to the targets before the "
"starred target.  The final items of the iterable are assigned to the targets "
"after the starred target.  A list of the remaining items in the iterable is "
"then assigned to the starred target (the list can be empty)."
msgstr ""
"\"星付き\"のターゲットと呼ばれる、頭にアスタリスクが一つ付いたターゲットが"
"ターゲットリストに一つだけ含まれている場合: オブジェクトはイテラブルで、少な"
"くともターゲットリストのターゲットの数よりも一つ少ない要素を持たなければなり"
"ません。\n"
"星付きのターゲットより前のターゲットに、イテラブルの先頭の要素が左から右へ代"
"入されます。\n"
"星付きのターゲットより後ろのターゲットに、イテラブルの末尾の要素が代入されま"
"す。\n"
"星付きのターゲットに、イテラブルの残った要素のリストが代入されます (リスト空"
"でもかまいません)。"

#: ../../reference/simple_stmts.rst:137
msgid ""
"Else: The object must be an iterable with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr ""
"そうでない場合: オブジェクトは、ターゲットリストのターゲットと同じ数の要素を"
"持つイテラブルでなければならず、要素は左から右へ対応するターゲットに代入され"
"ます。"

#: ../../reference/simple_stmts.rst:141
msgid ""
"Assignment of an object to a single target is recursively defined as follows."
msgstr ""
"単一のターゲットへの単一のオブジェクトの代入は、以下のようにして再帰的に定義"
"されています。"

#: ../../reference/simple_stmts.rst:143
msgid "If the target is an identifier (name):"
msgstr "ターゲットが識別子 (名前) の場合:"

#: ../../reference/simple_stmts.rst:145
msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""
"名前が現在のコードブロック内の :keyword:`global` や :keyword:`nonlocal` 文に"
"書かれていないければ: 名前は現在のローカル名前空間内のオブジェクトに束縛され"
"ます。"

#: ../../reference/simple_stmts.rst:149
msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""
"そうでなければ: 名前はそれぞれグローバル名前空間内か、 :keyword:`nonlocal` で"
"決められた外側の名前空間内のオブジェクトに束縛されます。"

#: ../../reference/simple_stmts.rst:154
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the "
"object to be deallocated and its destructor (if it has one) to be called."
msgstr ""
"名前がすでに束縛済みの場合、再束縛 (rebind) がおこなわれます。再束縛によっ"
"て、以前その名前に束縛されていたオブジェクトの参照カウント (reference count) "
"がゼロになった場合、オブジェクトは解放 (deallocate) され、デストラクタ  "
"(destructor) が (存在すれば) 呼び出されます。"

#: ../../reference/simple_stmts.rst:160
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not "
"necessarily :exc:`AttributeError`)."
msgstr ""
"ターゲットが属性参照の場合: 参照されている一次語の式が値評価されます。値は代"
"入可能な属性を伴うオブジェクトでなければなりません; そうでなければ、 :exc:"
"`TypeError` が送出されます。次に、このオブジェクトに対して、被代入オブジェク"
"トを指定した属性に代入してよいか問い合わせます; 代入を実行できない場合、例外 "
"(通常は :exc:`AttributeError` ですが、必然ではありません) を送出します。"

#: ../../reference/simple_stmts.rst:169
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the right-hand side expression, "
"``a.x`` can access either an instance attribute or (if no instance attribute "
"exists) a class attribute.  The left-hand side target ``a.x`` is always set "
"as an instance attribute, creating it if necessary.  Thus, the two "
"occurrences of ``a.x`` do not necessarily refer to the same attribute: if "
"the right-hand side expression refers to a class attribute, the left-hand "
"side creates a new instance attribute as the target of the assignment::"
msgstr ""

#: ../../reference/simple_stmts.rst:183
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""
"このことは、 :func:`property` で作成されたプロパティのようなデスクリプタ属性"
"に対しては、必ずしもあてはまるとは限りません。"

#: ../../reference/simple_stmts.rst:190
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""
"ターゲットが添字表記なら: 参照されている一次語式が評価されます。参照から (リ"
"ストのような) ミュータブルなシーケンスオブジェクトか、(辞書のような) マッピン"
"グオブジェクトが得られなければなりません。次に、添字表記の表す式が評価されま"
"す。"

#: ../../reference/simple_stmts.rst:199
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to "
"it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, :exc:"
"`IndexError` is raised (assignment to a subscripted sequence cannot add new "
"items to a list)."
msgstr ""
"一次語が (リストのような) ミュータブルなシーケンスオブジェクトであれば、添字"
"表記は整数を与えなければなりません。整数が負なら、シーケンスの長さが加算され"
"ます。整数は最終的に、シーケンスの長さよりも小さな非負の整数でなくてはなら"
"ず、シーケンスは、そのインデクスに持つ要素に被代入オブジェクトを代入してよい"
"か問い合わせられます。インデクスが範囲外なら、 :exc:`IndexError` が送出されま"
"す (添字指定されたシーケンスに代入を行っても、リスト要素の新たな追加はできま"
"せん)。"

#: ../../reference/simple_stmts.rst:210
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""
"一次語が (辞書のような) マップオブジェクトの場合、まず添字はマップのキー型と"
"互換性のある型でなくてはなりません。次に、添字を被代入オブジェクトに関連付け"
"るようなキー/データの対を生成するようマップオブジェクトに問い合わせます。この"
"操作では、既存のキー/値の対を同じキーと別の値で置き換えてもよく、(同じ値を持"
"つキーが存在しない場合) 新たなキー/値の対を挿入してもかまいません。"

#: ../../reference/simple_stmts.rst:216
msgid ""
"For user-defined objects, the :meth:`__setitem__` method is called with "
"appropriate arguments."
msgstr ""
"ユーザ定義のオブジェクトには、適切な引数で :meth:`__setitem__` メソッドが呼び"
"出されます。"

#: ../../reference/simple_stmts.rst:221
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The "
"assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"integers. If either bound is negative, the sequence's length is added to "
"it.  The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the target sequence allows it."
msgstr ""
"ターゲットがスライスなら: 参照されている一次語式が評価されます。一次語式は、"
"(リストのような) ミュータブルなシーケンスオブジェクトを与えなければなりませ"
"ん。被代入オブジェクトは同じ型のシーケンスオブジェクトでなければなりません。"
"次に、スライスの下限と上限を示す式があれば評価されます; デフォルト値はそれぞ"
"れ 0 とシーケンスの長さです。上限と下限の評価は整数でなければなりません。いず"
"れかの境界が負数なら、シーケンスの長さが加算されます。最終的に、境界は 0 から"
"シーケンスの長さまでに収まるように刈りこまれます。最後に、スライスを被代入オ"
"ブジェクトで置き換えてよいかシーケンスオブジェクトに問い合わせます。ターゲッ"
"トシーケンスで許されている限り、スライスの長さは被代入シーケンスの長さと異"
"なっていてよく、この場合にはターゲットシーケンスの長さが変更されます。"

#: ../../reference/simple_stmts.rst:235
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""
"現在の実装では、ターゲットの構文は式の構文と同じであるとみなされており、無効"
"な構文はコード生成フェーズ中に詳細なエラーメッセージを伴って拒否されます。"

#: ../../reference/simple_stmts.rst:239
msgid ""
"Although the definition of assignment implies that overlaps between the left-"
"hand side and the right-hand side are 'simultaneous' (for example ``a, b = "
"b, a`` swaps two variables), overlaps *within* the collection of assigned-to "
"variables occur left-to-right, sometimes resulting in confusion.  For "
"instance, the following program prints ``[0, 2]``::"
msgstr ""
"代入の定義によれば、左辺と右辺のオーバーラップは '同時 (simultaneous)' です "
"(例えば ``a, b = b, a`` は二つの変数を入れ替えます) が、代入対象となる変数群 "
"*どうし* のオーバーラップは左から右へ起こり、混乱の元です。例えば、以下のプロ"
"グラムは ``[0, 2]`` を出力してしまいます::"

#: ../../reference/simple_stmts.rst:253
msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ":pep:`3132` - Extended Iterable Unpacking"

#: ../../reference/simple_stmts.rst:254
msgid "The specification for the ``*target`` feature."
msgstr "``*target`` の指定機能。"

#: ../../reference/simple_stmts.rst:260
msgid "Augmented assignment statements"
msgstr "累算代入文 (augmented assignment statement)"

#: ../../reference/simple_stmts.rst:278
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr "累算代入文は、二項演算と代入文を組み合わせて一つの文にしたものです:"

#: ../../reference/simple_stmts.rst:287
msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last three "
"symbols.)"
msgstr "(最後の3つの構文定義については :ref:`primaries` を参照してください。)"

#: ../../reference/simple_stmts.rst:290
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only "
"evaluated once."
msgstr ""
"累算代入文は、ターゲット (通常の代入文と違って、アンパックは起こりません) と"
"式リストを評価し、それら二つの被演算子間で特定の累算代入型の二項演算を行い、"
"結果をもとのターゲットに代入します。ターゲットは一度しか評価されません。"

#: ../../reference/simple_stmts.rst:295
msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented "
"version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""
"``x += 1`` のような累算代入式は、 ``x = x + 1`` のように書き換えてほぼ同様の"
"動作にできますが、厳密に等価にはなりません。累算代入の方では、 ``x`` は一度し"
"か評価されません。また、実際の処理として、可能ならば *インプレース (in-"
"place)* 演算が実行されます。これは、代入時に新たなオブジェクトを生成してター"
"ゲットに代入するのではなく、以前のオブジェクトの内容を変更するということで"
"す。"

#: ../../reference/simple_stmts.rst:301
msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand side "
"*before* evaluating the right-hand side.  For example, ``a[i] += f(x)`` "
"first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs the "
"addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""
"通常の代入とは違い、累算代入文は右辺を評価する *前に* 左辺を評価します。たと"
"えば、``a[i] += f(x)`` はまず ``a[i]`` を調べ、``f(x)`` を評価して加算を行"
"い、最後に結果を ``a[i]`` に割り当てます。"

#: ../../reference/simple_stmts.rst:306
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled "
"the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""
"累算代入文で行われる代入は、タプルへの代入や、一文中に複数のターゲットが存在"
"する場合を除き、通常の代入と同じように扱われます。同様に、累算代入で行われる"
"二項演算は、場合によって *インプレース演算* が行われることを除き、通常の二項"
"演算と同じです。"

#: ../../reference/simple_stmts.rst:312
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""
"属性参照のターゲットの場合、 :ref:`クラス属性とインスタンス属性についての注"
"意 <attr-target-note>` と同様に通常の代入が適用されます。"

#: ../../reference/simple_stmts.rst:319
msgid "Annotated assignment statements"
msgstr "注釈付き代入文 (annotated assignment statements)"

#: ../../reference/simple_stmts.rst:326
msgid ""
":term:`Annotation <variable annotation>` assignment is the combination, in a "
"single statement, of a variable or attribute annotation and an optional "
"assignment statement:"
msgstr ""
":term:`注釈 <variable annotation>` 代入は、1 つの文の中で変数や属性のアノテー"
"ションとオプションの代入文を組み合わせたものです:"

#: ../../reference/simple_stmts.rst:333
msgid ""
"The difference from normal :ref:`assignment` is that only a single target is "
"allowed."
msgstr ""

#: ../../reference/simple_stmts.rst:335
msgid ""
"For simple names as assignment targets, if in class or module scope, the "
"annotations are evaluated and stored in a special class or module attribute :"
"attr:`__annotations__` that is a dictionary mapping from variable names "
"(mangled if private) to evaluated annotations. This attribute is writable "
"and is automatically created at the start of class or module body execution, "
"if annotations are found statically."
msgstr ""
"代入先として単純名を使うと、クラススコープもしくはモジュールスコープの場合、"
"注釈は評価され、クラスもしくはモジュールの特殊属性 :attr:`__annotations__` に"
"格納されます。\n"
"この属性は、変数名 (プライベート変数の場合はマングリングされた名前) から評価"
"後の注釈への対応付けを持つ辞書です。\n"
"この属性は書き込み可能であり、注釈が静的に存在している場合、クラスもしくはモ"
"ジュールの本体の実行の先頭で自動的に作成されます。"

#: ../../reference/simple_stmts.rst:343
msgid ""
"For expressions as assignment targets, the annotations are evaluated if in "
"class or module scope, but not stored."
msgstr ""
"代入先として式を使うと、クラススコープもしくはモジュールスコープの場合、注釈"
"は評価されますが、格納されません。"

#: ../../reference/simple_stmts.rst:346
msgid ""
"If a name is annotated in a function scope, then this name is local for that "
"scope. Annotations are never evaluated and stored in function scopes."
msgstr ""
"関数スコープで名前に注釈が付いていた場合は、その名前はその関数スコープでロー"
"カルなものになります。\n"
"注釈は絶対に評価されず、関数スコープにも格納されません。"

#: ../../reference/simple_stmts.rst:349
msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment before evaluating annotations (where applicable). If the "
"right hand side is not present for an expression target, then the "
"interpreter evaluates the target except for the last :meth:`__setitem__` or :"
"meth:`__setattr__` call."
msgstr ""
"右辺がある場合、注釈代入はアノテーション (有効であれば) を評価する前に、実際"
"に代入を行います。\n"
"対象となる式の右辺が無い場合は、インタプリタは最後の :meth:`__setitem__` や :"
"meth:`__setattr__` 呼び出し以外の対象の式を評価します。"

#: ../../reference/simple_stmts.rst:360
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Syntax for Variable Annotations"

#: ../../reference/simple_stmts.rst:358
msgid ""
"The proposal that added syntax for annotating the types of variables "
"(including class variables and instance variables), instead of expressing "
"them through comments."
msgstr ""
"(クラス変数やインスタンス変数を含んだ) 変数の型注釈を付ける、コメントで表現す"
"るのではない文法の追加提案。"

#: ../../reference/simple_stmts.rst:364
msgid ":pep:`484` - Type hints"
msgstr ":pep:`484` - Type hints"

#: ../../reference/simple_stmts.rst:363
msgid ""
"The proposal that added the :mod:`typing` module to provide a standard "
"syntax for type annotations that can be used in static analysis tools and "
"IDEs."
msgstr ""
":mod:`typing` モジュールを追加し、静的解析ツールや IDE で使える型アノテーショ"
"ンの標準的な文法を提供する提案。"

#: ../../reference/simple_stmts.rst:367
msgid ""
"Now annotated assignments allow the same expressions in the right hand side "
"as regular assignments. Previously, some expressions (like un-parenthesized "
"tuple expressions) caused a syntax error."
msgstr ""

#: ../../reference/simple_stmts.rst:376
msgid "The :keyword:`!assert` statement"
msgstr ":keyword:`!assert` 文"

#: ../../reference/simple_stmts.rst:383
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a "
"program:"
msgstr ""
"assert 文は、プログラム内にデバッグ用アサーション (debugging assertion) を仕"
"掛けるための便利な方法です:"

#: ../../reference/simple_stmts.rst:389
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "単純な形式 ``assert expression`` は ::"

#: ../../reference/simple_stmts.rst:394
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr ""
"と等価です。拡張形式 ``assert expression1, expression2`` は、これと等価で"
"す ::"

#: ../../reference/simple_stmts.rst:403
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable :const:`__debug__` is ``True`` under "
"normal circumstances, ``False`` when optimization is requested (command line "
"option :option:`-O`).  The current code generator emits no code for an "
"assert statement when optimization is requested at compile time.  Note that "
"it is unnecessary to include the source code for the expression that failed "
"in the error message; it will be displayed as part of the stack trace."
msgstr ""
"上記の等価関係は、 ``__debug__`` と :exc:`AssertionError` が、同名の組み込み"
"変数を参照しているという前提の上に成り立っています。現在の実装では、組み込み"
"変数 ``__debug__`` は通常の状況では ``True`` であり、最適化が要求された場合"
"（コマンドラインオプション :option:`-O`）は ``False`` です。現状のコード生成"
"器は、コンパイル時に最適化が要求されていると assert 文のコードを一切出力しま"
"せん。実行に失敗した式のソースコードをエラーメッセージ内に入れる必要はありま"
"せん; コードはスタックトレース内で表示されます。"

#: ../../reference/simple_stmts.rst:412
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ""
":const:`__debug__` への代入は不正な操作です。組み込み変数の値は、インタプリタ"
"が開始するときに決定されます。"

#: ../../reference/simple_stmts.rst:419
msgid "The :keyword:`!pass` statement"
msgstr ":keyword:`!pass` 文"

#: ../../reference/simple_stmts.rst:429
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""
":keyword:`pass` はヌル操作 (null operation) です --- :keyword:`pass` が実行さ"
"れても、何も起きません。 :keyword:`pass` は、構文法的には文が必要だが、コード"
"としては何も実行したくない場合のプレースホルダとして有用です。例えば::"

#: ../../reference/simple_stmts.rst:441
msgid "The :keyword:`!del` statement"
msgstr ":keyword:`!del` 文"

#: ../../reference/simple_stmts.rst:451
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""
"オブジェクトの削除 (deletion) は、代入の定義と非常に似た方法で再帰的に定義さ"
"れています。ここでは完全な詳細は記述せず、いくつかのヒントを述べるにとどめま"
"す。"

#: ../../reference/simple_stmts.rst:454
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr ""
"ターゲットリストに対する削除は、各々のターゲットを左から右へと順に再帰的に削"
"除します。"

#: ../../reference/simple_stmts.rst:460
msgid ""
"Deletion of a name removes the binding of that name from the local or global "
"namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  If the name is unbound, a :exc:"
"`NameError` exception will be raised."
msgstr ""
"名前の削除は、ローカルまたはグローバル名前空間からその名前の束縛を取り除きま"
"す。どちらの名前空間かは、名前が同じコードブロック内の :keyword:`global` 文で"
"宣言されているかどうかによります。名前が未束縛 (unbound) なら、 :exc:"
"`NameError` 例外が送出されます。"

#: ../../reference/simple_stmts.rst:467
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr ""
"属性参照、添字表記、およびスライスの削除操作は、対象となる一次語オブジェクト"
"に渡されます; スライスの削除は一般的には適切な型の空のスライスを代入するのと"
"等価です (が、この仕様自体もスライスされるオブジェクトで決定されています)。"

#: ../../reference/simple_stmts.rst:472
msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr ""
"以前は、ある名前がネストしたブロックの自由変数として表れる場合は、ローカル名"
"前空間からその名前を削除することは不正な処理でした。"

#: ../../reference/simple_stmts.rst:480
msgid "The :keyword:`!return` statement"
msgstr ":keyword:`!return` 文"

#: ../../reference/simple_stmts.rst:490
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""
":keyword:`return` は、関数定義内で構文法的にネストして現れますが、ネストした"
"クラス定義内には現れません。"

#: ../../reference/simple_stmts.rst:493
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""
"式リストがある場合、リストが値評価されます。それ以外の場合は ``None`` で置き"
"換えられます。"

#: ../../reference/simple_stmts.rst:495
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ""
":keyword:`return` を使うと、式リスト (または ``None``) を戻り値として、現在の"
"関数呼び出しから抜け出します。"

#: ../../reference/simple_stmts.rst:500
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the function."
msgstr ""
":keyword:`return` によって、 :keyword:`finally` 節をともなう :keyword:`try` "
"文の外に処理が引き渡されると、実際に関数から抜ける前に :keyword:`!finally` 節"
"が実行されます。"

#: ../../reference/simple_stmts.rst:504
msgid ""
"In a generator function, the :keyword:`return` statement indicates that the "
"generator is done and will cause :exc:`StopIteration` to be raised. The "
"returned value (if any) is used as an argument to construct :exc:"
"`StopIteration` and becomes the :attr:`StopIteration.value` attribute."
msgstr ""
"ジェネレータ関数では、 :keyword:`return` 文はジェネレータの終わりを示し、 :"
"exc:`StopIteration` 例外を送出させます。返された値は (あれば)、 :exc:"
"`StopIteration` を構成する引数に使われ、 :attr:`StopIteration.value` 属性にな"
"ります。"

#: ../../reference/simple_stmts.rst:509
msgid ""
"In an asynchronous generator function, an empty :keyword:`return` statement "
"indicates that the asynchronous generator is done and will cause :exc:"
"`StopAsyncIteration` to be raised.  A non-empty :keyword:`!return` statement "
"is a syntax error in an asynchronous generator function."
msgstr ""
"非同期ジェネレータ関数では、引数無しの :keyword:`return` 文は非同期ジェネレー"
"タの終わりを示し、 :exc:`StopAsyncIteration` を送出させます。\n"
"引数ありの :keyword:`!return` 文は、非同期ジェネレータ関数では文法エラーで"
"す。"

#: ../../reference/simple_stmts.rst:517
msgid "The :keyword:`!yield` statement"
msgstr ":keyword:`!yield` 文"

#: ../../reference/simple_stmts.rst:529
msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The yield statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""
":keyword:`yield` 文は意味的に :ref:`yield 式 <yieldexpr>` と同じです。yield "
"文を用いると yield 式文で必要な括弧を省略することが出来ます。例えば、yield "
"文 ::"

#: ../../reference/simple_stmts.rst:537
msgid "are equivalent to the yield expression statements ::"
msgstr "は以下の yield 式文と等価です ::"

#: ../../reference/simple_stmts.rst:542
msgid ""
"Yield expressions and statements are only used when defining a :term:"
"`generator` function, and are only used in the body of the generator "
"function.  Using yield in a function definition is sufficient to cause that "
"definition to create a generator function instead of a normal function."
msgstr ""
"yield 式及び文は :term:`generator` を定義するときに、その本体内でのみ使うこと"
"が出来ます。関数定義内で yield を使用することで、その定義は通常の関数でなく"
"ジェネレータ関数になります。"

#: ../../reference/simple_stmts.rst:547
msgid ""
"For full details of :keyword:`yield` semantics, refer to the :ref:"
"`yieldexpr` section."
msgstr ""
":keyword:`yield` の意味の完全な説明は、 :ref:`yieldexpr` 節を参照してくださ"
"い。"

#: ../../reference/simple_stmts.rst:553
msgid "The :keyword:`!raise` statement"
msgstr ":keyword:`!raise` 文"

#: ../../reference/simple_stmts.rst:564
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the exception that "
"is currently being handled, which is also known as the *active exception*. "
"If there isn't currently an active exception, a :exc:`RuntimeError` "
"exception is raised indicating that this is an error."
msgstr ""

#: ../../reference/simple_stmts.rst:569
msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of :class:"
"`BaseException`. If it is a class, the exception instance will be obtained "
"when needed by instantiating the class with no arguments."
msgstr ""
"そうでなければ、 :keyword:`raise` は最初の式を、例外オブジェクトとして評価し"
"ます。これは、 :class:`BaseException` のサブクラスまたはインスタンスでなけれ"
"ばなりません。クラスなら、例外インスタンスが必要なとき、クラスを無引数でイン"
"スタンス化することで得られます。"

#: ../../reference/simple_stmts.rst:574
msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the :dfn:"
"`value` is the instance itself."
msgstr ""
"例外の :dfn:`型` は例外インスタンスのクラスで、 :dfn:`値` はインスタンスその"
"ものです。"

#: ../../reference/simple_stmts.rst:579
msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`__traceback__` attribute, which is "
"writable. You can create an exception and set your own traceback in one step "
"using the :meth:`~BaseException.with_traceback` exception method (which "
"returns the same exception instance, with its traceback set to its "
"argument), like so::"
msgstr ""

#: ../../reference/simple_stmts.rst:591
msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance. If the second "
"expression is an exception instance, it will be attached to the raised "
"exception as the :attr:`__cause__` attribute (which is writable). If the "
"expression is an exception class, the class will be instantiated and the "
"resulting exception instance will be attached to the raised exception as "
"the :attr:`__cause__` attribute. If the raised exception is not handled, "
"both exceptions will be printed::"
msgstr ""

#: ../../reference/simple_stmts.rst:615
msgid ""
"A similar mechanism works implicitly if a new exception is raised when an "
"exception is already being handled.  An exception may be handled when an :"
"keyword:`except` or :keyword:`finally` clause, or a :keyword:`with` "
"statement, is used.  The previous exception is then attached as the new "
"exception's :attr:`__context__` attribute::"
msgstr ""

#: ../../reference/simple_stmts.rst:636
msgid ""
"Exception chaining can be explicitly suppressed by specifying :const:`None` "
"in the ``from`` clause::"
msgstr ""
"``from`` 節に :const:`None` を指定することで、例外の連鎖を明示的に非表示にで"
"きます::"

#: ../../reference/simple_stmts.rst:648
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information about handling exceptions is in section :ref:"
"`try`."
msgstr ""
"例外に関する追加情報は :ref:`exceptions` 節にあります。また、例外処理に関する"
"情報は :ref:`try` 節にあります。"

#: ../../reference/simple_stmts.rst:651
msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr ""
":const:`None` が ``raise X from Y`` の ``Y`` として使えるようになりました。"

#: ../../reference/simple_stmts.rst:654
msgid ""
"The ``__suppress_context__`` attribute to suppress automatic display of the "
"exception context."
msgstr ""
"``__suppress_context__`` 属性の設定で、例外のコンテキストが自動的に非表示にな"
"ります。"

#: ../../reference/simple_stmts.rst:658
msgid ""
"If the traceback of the active exception is modified in an :keyword:`except` "
"clause, a subsequent ``raise`` statement re-raises the exception with the "
"modified traceback. Previously, the exception was re-raised with the "
"traceback it had when it was caught."
msgstr ""

#: ../../reference/simple_stmts.rst:667
msgid "The :keyword:`!break` statement"
msgstr ":keyword:`!break` 文"

#: ../../reference/simple_stmts.rst:678
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :"
"keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""
":keyword:`break` 文は、構文としては :keyword:`for` ループや :keyword:`while` "
"ループの内側でのみ出現することができますが、ループ内の関数定義やクラス定義の"
"内側には出現できません。"

#: ../../reference/simple_stmts.rst:685
msgid ""
"It terminates the nearest enclosing loop, skipping the optional :keyword:`!"
"else` clause if the loop has one."
msgstr ""
":keyword:`break` 文は、文を囲う最も内側のループを終了させ、ループにオプション"
"の :keyword:`!else` 節がある場合にはそれをスキップします。"

#: ../../reference/simple_stmts.rst:688
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control "
"target keeps its current value."
msgstr ""
":keyword:`for` ループを :keyword:`break` によって終了すると、ループ制御ター"
"ゲットはその時の値を保持します。"

#: ../../reference/simple_stmts.rst:693
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the loop."
msgstr ""
":keyword:`break` が :keyword:`finally` 節を伴う :keyword:`try` 文の外側に処理"
"を渡す際には、ループを実際に抜ける前にその :keyword:`!finally` 節が実行されま"
"す。"

#: ../../reference/simple_stmts.rst:701
msgid "The :keyword:`!continue` statement"
msgstr ":keyword:`!continue` 文"

#: ../../reference/simple_stmts.rst:713
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"within that loop.  It continues with the next cycle of the nearest enclosing "
"loop."
msgstr ""

#: ../../reference/simple_stmts.rst:717
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really starting the next loop cycle."
msgstr ""
":keyword:`continue` が :keyword:`finally` 句を持った :keyword:`try` 文を抜け"
"るとき、その :keyword:`!finally` 句が次のループサイクルを始める前に実行されま"
"す。"

#: ../../reference/simple_stmts.rst:726
msgid "The :keyword:`!import` statement"
msgstr ":keyword:`!import` 文"

#: ../../reference/simple_stmts.rst:747
msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two "
"steps:"
msgstr ""
"(:keyword:`from` 節が無い) 基本の import 文は 2 つのステップで実行されます:"

#: ../../reference/simple_stmts.rst:750
msgid "find a module, loading and initializing it if necessary"
msgstr "モジュールを見付け出し、必要であればロードし初期化する"

#: ../../reference/simple_stmts.rst:751
msgid ""
"define a name or names in the local namespace for the scope where the :"
"keyword:`import` statement occurs."
msgstr ""
":keyword:`import` 文が表れるスコープのローカル名前空間で名前を定義する。"

#: ../../reference/simple_stmts.rst:754
msgid ""
"When the statement contains multiple clauses (separated by commas) the two "
"steps are carried out separately for each clause, just as though the clauses "
"had been separated out into individual import statements."
msgstr ""
"文が (カンマで区切られた) 複数の節を含んでいるときは、ちょうどその節が個別の "
"import 文に分割されたかのように、2つのステップが節ごとに個別に実行されます。"

#: ../../reference/simple_stmts.rst:759
msgid ""
"The details of the first step, finding and loading modules, are described in "
"greater detail in the section on the :ref:`import system <importsystem>`, "
"which also describes the various types of packages and modules that can be "
"imported, as well as all the hooks that can be used to customize the import "
"system. Note that failures in this step may indicate either that the module "
"could not be located, *or* that an error occurred while initializing the "
"module, which includes execution of the module's code."
msgstr ""

#: ../../reference/simple_stmts.rst:767
msgid ""
"If the requested module is retrieved successfully, it will be made available "
"in the local namespace in one of three ways:"
msgstr ""
"要求したモジュールが無事に取得できた場合、次の 3 つのうちの 1 つの方法でロー"
"カル名前空間で使えるようになります:"

#: ../../reference/simple_stmts.rst:772
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"モジュール名の後に :keyword:`!as` が続いていた場合は、 :keyword:`!as` の後ろ"
"の名前を直接、インポートされたモジュールが束縛します。"

#: ../../reference/simple_stmts.rst:774
msgid ""
"If no other name is specified, and the module being imported is a top level "
"module, the module's name is bound in the local namespace as a reference to "
"the imported module"
msgstr ""
"他の名前が指定されておらず、インポートされているモジュールが最上位のモジュー"
"ルだった場合、そのモジュール名がインポートされたモジュールへの参照として、"
"ローカル名前空間で束縛されます"

#: ../../reference/simple_stmts.rst:777
msgid ""
"If the module being imported is *not* a top level module, then the name of "
"the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module must "
"be accessed using its full qualified name rather than directly"
msgstr ""
"インポートされているモジュールが最上位のモジュール *でない* 場合、モジュール"
"を含む最上位のパッケージ名が、そのパッケージへの参照として、ローカル名前空間"
"で束縛されます。インポートされたモジュールには、直接ではなく完全修飾名を使っ"
"てアクセスしなければなりません"

#: ../../reference/simple_stmts.rst:787
msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr ":keyword:`from` 形式ではもう少し複雑な手順を踏みます:"

#: ../../reference/simple_stmts.rst:789
msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr ""
":keyword:`from` 節で指定されたモジュールを見付け出し、必要であればロードし初"
"期化する;"

#: ../../reference/simple_stmts.rst:791
msgid "for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr ""
":keyword:`import` 節で指定されたそれぞれの識別子に対し以下の処理を行う:"

#: ../../reference/simple_stmts.rst:793
msgid "check if the imported module has an attribute by that name"
msgstr "インポートされたモジュールがその識別子名の属性を持っているかを確認する"

#: ../../reference/simple_stmts.rst:794
msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr ""
"その識別子名の属性を持っていなかった場合は、その識別子名でサブモジュールのイ"
"ンポートを試み、インポートされたモジュールにその属性があるか再度確認する"

#: ../../reference/simple_stmts.rst:796
msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr "属性が見付からない場合は、 :exc:`ImportError` を送出する。"

#: ../../reference/simple_stmts.rst:797
msgid ""
"otherwise, a reference to that value is stored in the local namespace, using "
"the name in the :keyword:`!as` clause if it is present, otherwise using the "
"attribute name"
msgstr ""
"属性が見付かった場合は、 :keyword:`!as` 節があるならそこの名前、そうでないな"
"ら属性名を使って、その値への参照がローカル名前空間に保存される"

#: ../../reference/simple_stmts.rst:801
msgid "Examples::"
msgstr "例::"

#: ../../reference/simple_stmts.rst:811
msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public names "
"defined in the module are bound in the local namespace for the scope where "
"the :keyword:`import` statement occurs."
msgstr ""
"識別子のリストが星 (``'*'``) に置き換わっている場合は、モジュールで定義されて"
"いる公開された全ての名前が、 :keyword:`import` 文がいるスコープのローカル名前"
"空間に束縛されます。"

#: ../../reference/simple_stmts.rst:817
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to "
"exist.  If ``__all__`` is not defined, the set of public names includes all "
"names found in the module's namespace which do not begin with an underscore "
"character (``'_'``).  ``__all__`` should contain the entire public API. It "
"is intended to avoid accidentally exporting items that are not part of the "
"API (such as library modules which were imported and used within the module)."
msgstr ""
"モジュールで定義される *公開された名前* は、モジュールの名前空間にある "
"``__all__`` という名前の変数を調べることで決定されます; その変数が定義されて"
"いる場合は、それはモジュールで定義されたかインポートされた名前からなる、文字"
"列のシーケンスでなければいけません。``__all__`` で列挙された名前は、全て公開"
"されていると見なされ、存在することが要求されます。``__all__`` が定義されてい"
"ない場合、公開された名前とは、モジュールの名前空間で見付かった、アンダースコ"
"ア文字 (``'_'``) で始まらない全ての名前のことです。``__all__`` は全ての公開 "
"API を含むべきです。これは API の一部でないもの (そのモジュールでインポートさ"
"れ使われているライブラリモジュールなど) をうっかり外部に公開してしまわないた"
"めの仕組みです。"

#: ../../reference/simple_stmts.rst:827
msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""
"インポートのワイルドカード形式 --- ``from module import *`` --- は、モジュー"
"ルレベルでのみ許されます。クラスや関数定義でこの形式を使おうとすると、 :exc:"
"`SyntaxError` が送出されます。"

#: ../../reference/simple_stmts.rst:834
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top "
"package without having to mention the package name. By using leading dots in "
"the specified module or package after :keyword:`from` you can specify how "
"high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the "
"import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained in "
"the :ref:`relativeimports` section."
msgstr ""
"インポートするモジュールを指定するとき、そのモジュールの絶対名 (absolute "
"name) を指定する必要はありません。モジュールやパッケージが他のパッケージに含"
"まれている場合、共通のトップパッケージからそのパッケージ名を記述することなく"
"相対インポートすることができます。 :keyword:`from` の後に指定されるモジュール"
"やパッケージの先頭に複数個のドットを付けることで、正確な名前を指定することな"
"しに現在のパッケージ階層からいくつ上の階層へ行くかを指定することができます。"
"先頭のドットが 1 つの場合、 import をおこなっているモジュールが存在する現在の"
"パッケージを示します。 3 つのドットは 2 つ上のレベルを示します。なので、 "
"``pkg`` パッケージの中のモジュールで ``from . import mod`` を実行すると、 "
"``pkg.mod`` をインポートすることになります。 ``pkg.subpkg1`` の中から "
"``from ..subpkg2 import mod`` を実行すると、 ``pkg.subpkg2.mod`` をインポート"
"します。相対インポートの仕様は :ref:`relativeimports` の節に含まれています。"

#: ../../reference/simple_stmts.rst:848
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ""
"どのモジュールがロードされるべきかを動的に決めたいアプリケーションのために、"
"組み込み関数 :func:`importlib.import_module` が提供されています。"

#: ../../reference/simple_stmts.rst:851
msgid ""
"Raises an :ref:`auditing event <auditing>` ``import`` with arguments "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, ``sys."
"path_hooks``."
msgstr ""

#: ../../reference/simple_stmts.rst:856
msgid "Future statements"
msgstr "future 文 (future statement)"

#: ../../reference/simple_stmts.rst:862
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python where the feature becomes standard."
msgstr ""
":dfn:`future 文` は、将来の特定の新たな機能が標準化された Python のリリースで"
"利用可能になるような構文や意味付けを使って、特定のモジュールをコンパイルさせ"
"るための、コンパイラに対する指示句 (directive) です。"

#: ../../reference/simple_stmts.rst:866
msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows use "
"of the new features on a per-module basis before the release in which the "
"feature becomes standard."
msgstr ""
"future 文は互換性のない変更がされた将来の Python のバージョンに容易に移行する"
"ためのものです。future 文によって新機能が標準となるリリースの前にそれをモ"
"ジュール単位で使用することが出来ます。"

#: ../../reference/simple_stmts.rst:878
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr ""
"future 文は、モジュールの先頭周辺に書かなければなりません。 future 文の前に書"
"いてよい内容は以下です :"

#: ../../reference/simple_stmts.rst:881
msgid "the module docstring (if any),"
msgstr "モジュールのドキュメンテーション文字列 ( あれば )"

#: ../../reference/simple_stmts.rst:882
msgid "comments,"
msgstr "コメント ,"

#: ../../reference/simple_stmts.rst:883
msgid "blank lines, and"
msgstr "空行 ,"

#: ../../reference/simple_stmts.rst:884
msgid "other future statements."
msgstr "その他の future 文。"

#: ../../reference/simple_stmts.rst:886
msgid ""
"The only feature that requires using the future statement is ``annotations`` "
"(see :pep:`563`)."
msgstr ""

#: ../../reference/simple_stmts.rst:889
msgid ""
"All historical features enabled by the future statement are still recognized "
"by Python 3.  The list includes ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` and ``with_statement``.  They are all "
"redundant because they are always enabled, and only kept for backwards "
"compatibility."
msgstr ""
"future 文で有効にできる歴史的な機能は、今でも Python 3 が認識します。\n"
"そのリストは ``absolute_import``, ``division``, ``generator_stop``, "
"``generators``, ``unicode_literals``, ``print_function``, ``nested_scopes``, "
"``with_statement`` です。\n"
"これらは既に全てが有効になっていて、後方互換性のためだけに残されているため、"
"冗長なだけです。"

#: ../../reference/simple_stmts.rst:896
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""
"future 文は、コンパイル時に特別なやり方で認識され、扱われます: 言語の中核をな"
"す構文構成 (construct) に対する意味付けが変更されている場合、変更部分はしばし"
"ば異なるコードを生成することで実現されています。新たな機能によって、(新たな予"
"約語のような) 互換性のない新たな構文が取り入れられることさえあります。この場"
"合、コンパイラはモジュールを別のやりかたで解析する必要があるかもしれません。"
"こうしたコード生成に関する決定は、実行時まで先延ばしすることはできません。"

#: ../../reference/simple_stmts.rst:903
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""
"これまでの全てのリリースにおいて、コンパイラはどの機能が定義済みかを知ってお"
"り、 future 文に未知の機能が含まれている場合にはコンパイル時エラーを送出しま"
"す。"

#: ../../reference/simple_stmts.rst:907
msgid ""
"The direct runtime semantics are the same as for any import statement: there "
"is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""
"future 文の実行時における直接的な意味付けは、 import 文と同じです。標準モ"
"ジュール :mod:`__future__` があり、これについては後で述べます。 :mod:"
"`__future__` は、 future 文が実行される際に通常の方法で import されます。"

#: ../../reference/simple_stmts.rst:911
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr ""
"future 文の実行時における特別な意味付けは、 future 文で有効化される特定の機能"
"によって変わります。"

#: ../../reference/simple_stmts.rst:914
msgid "Note that there is nothing special about the statement::"
msgstr "以下の文には、何ら特殊な意味はないので注意してください::"

#: ../../reference/simple_stmts.rst:918
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr ""
"これは future 文ではありません; この文は通常の import 文であり、その他の特殊"
"な意味付けや構文的な制限はありません。"

#: ../../reference/simple_stmts.rst:921
msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and :func:"
"`compile` that occur in a module :mod:`M` containing a future statement "
"will, by default, use the new syntax or semantics associated with the future "
"statement.  This can be controlled by optional arguments to :func:`compile` "
"--- see the documentation of that function for details."
msgstr ""
"future 文の入ったモジュール :mod:`M` 内で使われている組み込み関数 :func:"
"`exec` や :func:`compile` によってコンパイルされるコードは、デフォルトの設定"
"では、 future 文に関係する新たな構文や意味付けを使うようになっています。この"
"仕様は :func:`compile` のオプション引数で制御できます --- 詳細はこの関数に関"
"するドキュメントを参照してください。"

#: ../../reference/simple_stmts.rst:927
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""
"対話的インタプリタのプロンプトでタイプ入力した future 文は、その後のインタプ"
"リタセッション中で有効になります。インタプリタを :option:`-i` オプションで起"
"動して実行すべきスクリプト名を渡し、スクリプト中に future 文を入れておくと、"
"新たな機能はスクリプトが実行された後に開始する対話セッションで有効になりま"
"す。"

#: ../../reference/simple_stmts.rst:935
msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` - Back to the __future__"

#: ../../reference/simple_stmts.rst:936
msgid "The original proposal for the __future__ mechanism."
msgstr "__future__ 機構の原案"

#: ../../reference/simple_stmts.rst:942
msgid "The :keyword:`!global` statement"
msgstr ":keyword:`!global` 文"

#: ../../reference/simple_stmts.rst:952
msgid ""
"The :keyword:`global` statement is a declaration which holds for the entire "
"current code block.  It means that the listed identifiers are to be "
"interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`!global`, although free variables may refer to "
"globals without being declared global."
msgstr ""
":keyword:`global` 文は、現在のコードブロック全体で維持される宣言文です。 :"
"keyword:`global` 文は、列挙した識別子をグローバル変数として解釈するよう指定す"
"ることを意味します。 :keyword:`!global` を使わずにグローバル変数に代入を行う"
"ことは不可能ですが、自由変数を使えばその変数をグローバルであると宣言せずにグ"
"ローバル変数を参照することができます。"

#: ../../reference/simple_stmts.rst:958
msgid ""
"Names listed in a :keyword:`global` statement must not be used in the same "
"code block textually preceding that :keyword:`!global` statement."
msgstr ""
":keyword:`global` 文で列挙する名前は、同じコードブロック中で、プログラムテキ"
"スト上 :keyword:`!global` 文より前に使ってはなりません。"

#: ../../reference/simple_stmts.rst:961
msgid ""
"Names listed in a :keyword:`global` statement must not be defined as formal "
"parameters, or as targets in :keyword:`with` statements or :keyword:`except` "
"clauses, or in a :keyword:`for` target list, :keyword:`class` definition, "
"function definition, :keyword:`import` statement, or variable annotation."
msgstr ""

#: ../../reference/simple_stmts.rst:968
msgid ""
"The current implementation does not enforce some of these restrictions, but "
"programs should not abuse this freedom, as future implementations may "
"enforce them or silently change the meaning of the program."
msgstr ""
"現在の実装では、これらの制限のうち幾つかについては強制していませんが、プログ"
"ラムでこの緩和された仕様を乱用すべきではありません。将来の実装では、この制限"
"を強制したり、暗黙のうちにプログラムの意味付けを変更したりする可能性がありま"
"す。"

#: ../../reference/simple_stmts.rst:977
msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`!global` "
"statement. In particular, a :keyword:`!global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained "
"in such a string is unaffected by :keyword:`!global` statements in the code "
"containing the function call.  The same applies to the :func:`eval` and :"
"func:`compile` functions."
msgstr ""
"**プログラマのための注意点:** :keyword:`global` はパーザに対する指示句 "
"(directive) です。この指示句は、 :keyword:`!global` 文と同時に読み込まれた"
"コードに対してのみ適用されます。特に、組み込みの :func:`exec` 関数内に入って"
"いる :keyword:`!global` 文は、関数の呼び出しを *含んでいる* コードブロック内"
"に効果を及ぼすことはなく、そのような文字列に含まれているコードは、関数の呼び"
"出しを含むコード内の :keyword:`!global` 文に影響を受けません。同様のことが、"
"関数 :func:`eval` および :func:`compile` にも当てはまります。"

#: ../../reference/simple_stmts.rst:989
msgid "The :keyword:`!nonlocal` statement"
msgstr ":keyword:`!nonlocal` 文"

#: ../../reference/simple_stmts.rst:997
msgid ""
"The :keyword:`nonlocal` statement causes the listed identifiers to refer to "
"previously bound variables in the nearest enclosing scope excluding globals. "
"This is important because the default behavior for binding is to search the "
"local namespace first.  The statement allows encapsulated code to rebind "
"variables outside of the local scope besides the global (module) scope."
msgstr ""
":keyword:`nonlocal` 文は、列挙された識別子がグローバルを除く一つ外側のスコー"
"プで先に束縛された変数を参照するようにします。これは、束縛のデフォルトの動作"
"がまずローカル名前空間を探索するので重要です。この文は、中にあるコードが、グ"
"ローバル (モジュール) スコープ以外のローカルスコープの外側の変数を再束縛でき"
"るようにします。"

#: ../../reference/simple_stmts.rst:1003
msgid ""
"Names listed in a :keyword:`nonlocal` statement, unlike those listed in a :"
"keyword:`global` statement, must refer to pre-existing bindings in an "
"enclosing scope (the scope in which a new binding should be created cannot "
"be determined unambiguously)."
msgstr ""
":keyword:`nonlocal` 文で列挙された名前は、 :keyword:`global` 文で列挙された名"
"前と違い、外側のスコープですでに存在する束縛を参照しなければなりません (新し"
"い束縛が作られるべきスコープの選択が曖昧さを排除できません)。"

#: ../../reference/simple_stmts.rst:1008
msgid ""
"Names listed in a :keyword:`nonlocal` statement must not collide with pre-"
"existing bindings in the local scope."
msgstr ""
":keyword:`nonlocal` 文で列挙された名前は、ローカルスコープですでに存在する束"
"縛と衝突してはなりません。"

#: ../../reference/simple_stmts.rst:1013
msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ":pep:`3104` - Access to Names in Outer Scopes"

#: ../../reference/simple_stmts.rst:1014
msgid "The specification for the :keyword:`nonlocal` statement."
msgstr ":keyword:`nonlocal` 文の詳細。"
