# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# 秘湯 <xwhhsprings@gmail.com>, 2015-2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-10 13:32+0900\n"
"PO-Revision-Date: 2018-06-25 18:16+0000\n"
"Last-Translator: cocoatomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "字句解析"

#: ../../reference/lexical_analysis.rst:13
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr "Python で書かれたプログラムは *パーザ (parser)* に読み込まれます。パーザへの入力は、 *字句解析器 (lexical analyzer)* によって生成された一連の *トークン (token)* からなります。この章では、字句解析器がファイルをトークン列に分解する方法について解説します。"

#: ../../reference/lexical_analysis.rst:17
msgid "Python uses the 7-bit ASCII character set for program text."
msgstr "Python は 7-bit の ASCII 文字セットをプログラムのテキストに使います。"

#: ../../reference/lexical_analysis.rst:19
msgid ""
"An encoding declaration can be used to indicate that  string literals and "
"comments use an encoding different from ASCII."
msgstr "エンコード宣言を使って、文字列リテラルやコメントに ASCII ではない文字セットが使われていることを明示できます。."

#: ../../reference/lexical_analysis.rst:23
msgid ""
"For compatibility with older versions, Python only warns if it finds 8-bit "
"characters; those warnings should be corrected by either declaring an "
"explicit encoding, or using escape sequences if those bytes are binary data,"
" instead of characters."
msgstr "以前のバージョンとの互換性のために、Python は 8-bit 文字が見つかっても警告を出すだけにとどめます; こうした警告は、エンコーディングを明示したり、バイナリデータの場合には文字ではなくエスケープシーケンスを使うことで解決できます。"

#: ../../reference/lexical_analysis.rst:28
msgid ""
"The run-time character set depends on the I/O devices connected to the "
"program but is generally a superset of ASCII."
msgstr "実行時の文字セットは、プログラムが接続されている I/O デバイスにもよりますが、通常 ASCIIのサブセットです。"

#: ../../reference/lexical_analysis.rst:31
msgid ""
"**Future compatibility note:** It may be tempting to assume that the "
"character set for 8-bit characters is ISO Latin-1 (an ASCII superset that "
"covers most western languages that use the Latin alphabet), but it is "
"possible that in the future Unicode text editors will become common.  These "
"generally use the UTF-8 encoding, which is also an ASCII superset, but with "
"very different use for the characters with ordinals 128-255.  While there is"
" no consensus on this subject yet, it is unwise to assume either Latin-1 or "
"UTF-8, even though the current implementation appears to favor Latin-1.  "
"This applies both to the source character set and the run-time character "
"set."
msgstr "**将来のバージョンとの互換性に関する注意:** 8-bit 文字に対する文字セットを ISO Latin-1 (ラテン語系アルファベットを用いるほとんどの西欧言語をカバーするASCII の上位セット) とみなしたい気にもなるかもしれません。しかし、おそらく Unicode を編集できるテキストエディタが将来一般的になるはずです。こうしたエディタでは一般的に UTF-8 エンコードを使いますが、UTF-8 エンコードは ASCII の上位セットではあるものの、文字序数 (ordinal) 128-255 の扱いが非常に異なります。この問題に関してはまだ合意が得られていませんが、 Latin-1 と UTF-8 のどちらかとみなすのは、たとえ現在の実装が Latin-1 びいきのように思えたとしても賢明とはいえません。これはソースコード文字セットと実行時の文字セットのどちらにも該当します。"

#: ../../reference/lexical_analysis.rst:45
msgid "Line structure"
msgstr "行構造"

#: ../../reference/lexical_analysis.rst:49
msgid "A Python program is divided into a number of *logical lines*."
msgstr "Python プログラムは多数の *論理行 (logical lines)* に分割されます。"

#: ../../reference/lexical_analysis.rst:55
msgid "Logical lines"
msgstr "論理行 (logical line)"

#: ../../reference/lexical_analysis.rst:63
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr "論理行の終端は、トークン NEWLINE で表されます。構文上許されている場合 (複合文: compound statement 中の実行文: statement) を除いて、実行文は論理行間にまたがることはできません。論理行は一行またはそれ以上の *物理行(physical line)* からなり、物理行の末尾には明示的または非明示的な *行連結(line joining)* 規則が続きます。"

#: ../../reference/lexical_analysis.rst:73
msgid "Physical lines"
msgstr "物理行 (physical line)"

#: ../../reference/lexical_analysis.rst:75
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line "
"termination sequences can be used - the Unix form using ASCII LF (linefeed),"
" the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) character."
"  All of these forms can be used equally, regardless of platform. The end of"
" input also serves as an implicit terminator for the final physical line."
msgstr "物理行とは、行終端コードで区切られた文字列のことです。\nソースファイルやソース文字列では、各プラットフォームごとの標準の行終端コードを使用することができます。\nUnix形式ではASCII LF (行送り: linefeed)文字、 Windows形式ではASCII 配列の CR LF (復帰: return に続いて行送り) 、 Macintosh形式ではASCII CR (復帰) 文字です。\nこれら全ての形式のコードは、違うプラットフォームでも等しく使用することができます。\n入力の末尾も、最後の物理行の暗黙的な終端としての役割を果たします。"

#: ../../reference/lexical_analysis.rst:83
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr "Pythonに埋め込む場合には、標準のC言語の改行文字の変換規則 (ASCII LFを表現した文字コード ``\\n`` が行終端となります) に従って、 Python APIにソースコードを渡す必要があります。"

#: ../../reference/lexical_analysis.rst:91
msgid "Comments"
msgstr "コメント (Comments)"

#: ../../reference/lexical_analysis.rst:97
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax; they are not tokens."
msgstr "コメントは文字列リテラル内に入っていないハッシュ文字 (``#``) から始まり、同じ物理行の末端で終わります。非明示的な行継続規則が適用されていない限り、コメントは論理行を終端させます。コメントは構文上無視されます; コメントはトークンになりません。"

#: ../../reference/lexical_analysis.rst:106
msgid "Encoding declarations"
msgstr "エンコード宣言 (encoding declaration)"

#: ../../reference/lexical_analysis.rst:110
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr "Python スクリプト中の一行目か二行目にあるコメントが正規表現 ``coding[=:]\\s*([-\\w.]+)`` にマッチする場合、コメントはエンコード宣言として処理されます; この表現の最初のグループがソースコードファイルのエンコードを指定します。エンコード宣言は自身の行になければなりません。二行目にある場合、一行目もコメントのみの行でなければなりません。エンコード宣言式として推奨する形式は ::"

#: ../../reference/lexical_analysis.rst:119
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "これは GNU Emacs で認識できます。または ::"

#: ../../reference/lexical_analysis.rst:123
msgid ""
"which is recognized by Bram Moolenaar's VIM. In addition, if the first bytes"
" of the file are the UTF-8 byte-order mark (``'\\xef\\xbb\\xbf'``), the "
"declared file encoding is UTF-8 (this is supported, among others, by "
"Microsoft's :program:`notepad`)."
msgstr "です。さらに、ファイルの先頭のバイト列が UTF-8 バイトオーダ記号 (``'\\xef\\xbb\\xbf'``) の場合、ファイルのエンコードは UTF-8 と宣言されているものとします (この機能は Microsoft の :program:`notepad` やその他のエディタでサポートされています)。"

#: ../../reference/lexical_analysis.rst:128
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python. "
"The encoding is used for all lexical analysis, in particular to find the end"
" of a string, and to interpret the contents of Unicode literals. String "
"literals are converted to Unicode for syntactical analysis, then converted "
"back to their original encoding before interpretation starts."
msgstr "エンコードが宣言されている場合、Python はそのエンコード名を認識できなければなりません。宣言されたエンコードは全ての字句解析、特に文字列の終端を検出する際や Unicode リテラルの内容を翻訳する上で用いられます。文字列リテラルは文法的な解析を行うために Unicode に変換され、解釈が行われる前に元のエンコードに戻されます。"

#: ../../reference/lexical_analysis.rst:140
msgid "Explicit line joining"
msgstr "明示的な行継続"

#: ../../reference/lexical_analysis.rst:148
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr "二つまたはそれ以上の物理行を論理行としてつなげるためには、バックスラッシュ文字 (``\\``) を使って以下のようにします: 物理行が文字列リテラルやコメント中の文字でないバックスラッシュで終わっている場合、後続する行とつなげて一つの論理行を構成し、バックスラッシュおよびバックスラッシュの後ろにある行末文字を削除します。例えば::"

#: ../../reference/lexical_analysis.rst:159
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string"
" literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr "バックスラッシュで終わる行にはコメントを入れることはできません。また、バックスラッシュを使ってコメントを継続することはできません。バックスラッシュが文字列リテラル中にある場合を除き、バックスラッシュの後ろにトークンを継続することはできません (すなわち、物理行内の文字列リテラル以外のトークンをバックスラッシュを使って分断することはできません)。上記以外の場所では、文字列リテラル外にあるバックスラッシュはどこにあっても不正となります。"

#: ../../reference/lexical_analysis.rst:169
msgid "Implicit line joining"
msgstr "非明示的な行継続"

#: ../../reference/lexical_analysis.rst:171
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr "丸括弧 (parentheses)、角括弧 (square bracket) 、および波括弧 (curly brace) 内の式は、バックスラッシュを使わずに一行以上の物理行に分割することができます。例えば::"

#: ../../reference/lexical_analysis.rst:179
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr "非明示的に継続された行にはコメントを含めることができます。継続行のインデントは重要ではありません。空の継続行を書くことができます。非明示的な継続行中には、NEWLINE トークンは存在しません。非明示的な行の継続は、三重クオートされた文字列 (下記参照) でも発生します; この場合には、コメントを含めることができません。"

#: ../../reference/lexical_analysis.rst:189
msgid "Blank lines"
msgstr "空行"

#: ../../reference/lexical_analysis.rst:193
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard implementation, an entirely blank logical line (i.e. one containing"
" not even whitespace or a comment) terminates a multi-line statement."
msgstr "スペース、タブ、フォームフィード、およびコメントのみを含む論理行は無視されます (すなわち、NEWLINE トークンは生成されません)。文を対話的に入力している際には、空行の扱いは行読み込み-評価-出力 (read-eval-print) ループの実装によって異なるかもしれません。標準的な実装では、完全な空行でできた論理行 (すなわち、空白文字もコメントも全く含まない空行) は、複数行からなる実行文の終端を示します。"

#: ../../reference/lexical_analysis.rst:204
msgid "Indentation"
msgstr "インデント"

#: ../../reference/lexical_analysis.rst:215
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr "論理行の行頭にある、先頭の空白 (スペースおよびタブ) の連なりは、その行のインデントレベルを計算するために使われます。インデントレベルは、実行文のグループ化方法を決定するために用いられます。"

#: ../../reference/lexical_analysis.rst:219
msgid ""
"First, tabs are replaced (from left to right) by one to eight spaces such "
"that the total number of characters up to and including the replacement is a"
" multiple of eight (this is intended to be the same rule as used by Unix).  "
"The total number of spaces preceding the first non-blank character then "
"determines the line's indentation.  Indentation cannot be split over "
"multiple physical lines using backslashes; the whitespace up to the first "
"backslash determines the indentation."
msgstr "まず、タブは (左から右の方向に) 1 つから 8 つのスペースで置き換えられ、置き換え後の文字列の終わりの位置までの文字数が 8 の倍数になるように調整されます (Unixで使われている規則と同じになるよう意図されています)。次に、空白文字でない最初の文字までのスペースの総数から、その行のインデントを決定します。バックスラッシュを使ってインデントを複数の物理行に分割することはできません; 最初のバックスラッシュまでの空白がインデントを決定します。"

#: ../../reference/lexical_analysis.rst:227
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors"
" on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for"
" the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr "**プラットフォーム間の互換性に関する注意:** 非 UNIX プラットフォームにおけるテキストエディタの性質上、一つのソースファイル内でタブとインデントを混在させて使うのは賢明ではありません。また、プラットフォームによっては、最大インデントレベルを明示的に制限しているかもしれません。"

#: ../../reference/lexical_analysis.rst:232
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr "フォームフィード文字が行の先頭にあっても構いません; フォームフィード文字は上のインデントレベル計算時には無視されます。フォームフィード文字が先頭の空白中の他の場所にある場合、その影響は未定義です (例えば、スペースの数を 0 にリセットするかもしれません)。"

#: ../../reference/lexical_analysis.rst:241
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr "連続する行における各々のインデントレベルは、 INDENT および DEDENT トークンを生成するために使われます。トークンの生成はスタックを用いて以下のように行われます。"

#: ../../reference/lexical_analysis.rst:244
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack"
" will always be strictly increasing from bottom to top.  At the beginning of"
" each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on"
" the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr "ファイル中の最初の行を読み出す前に、スタックにゼロが一つ積まれ (push され) ます; このゼロは決して除去 (pop) されることはありません。スタックの先頭に積まれてゆく数字は、常にスタックの末尾から先頭にかけて厳密に増加するようになっています。各論理行の開始位置において、その行のインデントレベル値がスタックの先頭の値と比較されます。値が等しければ何もしません。インデントレベル値がスタック上の値よりも大きければ、インデントレベル値はスタックに積まれ、INDENT トークンが一つ生成されます。インデントレベル値がスタック上の値よりも小さい場合、その値はスタック内のいずれかの値と *等しくなければなりません* ; スタック上のインデントレベル値よりも大きい値はすべて除去され、値が一つ除去されるごとに DEDENT トークンが一つ生成されます。ファイルの末尾では、スタックに残っているゼロより大きい値は全て除去され、値が一つ除去されるごとに DEDENT トークンが一つ生成されます。"

#: ../../reference/lexical_analysis.rst:255
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr "以下の例に正しく (しかし当惑させるように) インデントされた Python コードの一部を示します::"

#: ../../reference/lexical_analysis.rst:270
msgid "The following example shows various indentation errors::"
msgstr "以下の例は、様々なインデントエラーになります::"

#: ../../reference/lexical_analysis.rst:280
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr "(実際は、最初の 3 つのエラーはパーザによって検出されます; 最後のエラーのみが字句解析器で見つかります --- ``return r`` のインデントは、スタックから逐次除去されていくどのインデントレベル値とも一致しません)"

#: ../../reference/lexical_analysis.rst:288
msgid "Whitespace between tokens"
msgstr "トークン間の空白"

#: ../../reference/lexical_analysis.rst:290
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to"
" separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr "論理行の先頭や文字列の内部にある場合を除き、空白文字であるスペース、タブ、およびフォームフィードは、トークンを分割するために自由に利用することができます。二つのトークンを並べて書くと別のトークンとしてみなされてしまうような場合には、トークンの間に空白が必要となります (例えば、ab は一つのトークンですが、 a b は二つのトークンとなります)。"

#: ../../reference/lexical_analysis.rst:300
msgid "Other tokens"
msgstr "その他のトークン"

#: ../../reference/lexical_analysis.rst:302
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*."
" Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr "NEWLINE、INDENT、および DEDENT の他、以下のトークンのカテゴリ: *識別子 (identifier)*, *キーワード(keyword)*, *リテラル*, *演算子 (operator)*, *デリミタ (delimiter)* が存在します。空白文字 (上で述べた行終端文字以外) はトークンではありませんが、トークンを区切る働きがあります。トークンの解析にあいまいさが生じた場合、トークンは左から右に読んで不正でないトークンを構築できる最長の文字列を含むように構築されます。"

#: ../../reference/lexical_analysis.rst:312
msgid "Identifiers and keywords"
msgstr "識別子 (identifier) およびキーワード (keyword)"

#: ../../reference/lexical_analysis.rst:318
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions:"
msgstr "識別子 (または *名前 (name)*) は、以下の字句定義で記述されます:"

#: ../../reference/lexical_analysis.rst:328
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr "識別子の長さには制限がありません。大小文字は区別されます。"

#: ../../reference/lexical_analysis.rst:334
msgid "Keywords"
msgstr "キーワード (keyword)"

#: ../../reference/lexical_analysis.rst:340
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr "以下の識別子は、予約語、または Python 言語における *キーワード (keyword)* として使われ、通常の識別子として使うことはできません。キーワードは厳密に下記の通りに綴らなければなりません:"

#: ../../reference/lexical_analysis.rst:354
msgid ""
":const:`None` became a constant and is now recognized by the compiler as a "
"name for the built-in object :const:`None`.  Although it is not a keyword, "
"you cannot assign a different object to it."
msgstr "このバージョンから :const:`None` は定数になり、組み込みオブジェクト :const:`None` の名前としてコンパイラに認識されるようになりました。これは予約語ではありませんが、これに他のオブジェクトを割り当てることはできません。"

#: ../../reference/lexical_analysis.rst:359
msgid ""
"Using :keyword:`as` and :keyword:`with` as identifiers triggers a warning.  "
"To use them as keywords, enable the ``with_statement`` future feature ."
msgstr ":keyword:`as` と :keyword:`with` を識別子として使用した場合は、ワーニングが表示されます。これらをキーワードとして使うには、 ``with_statement`` 機能を future 文によって有効にします。"

#: ../../reference/lexical_analysis.rst:363
msgid ":keyword:`as` and :keyword:`with` are full keywords."
msgstr ":keyword:`as` と :keyword:`with` は完全なキーワードになりました。"

#: ../../reference/lexical_analysis.rst:370
msgid "Reserved classes of identifiers"
msgstr "予約済みの識別子種 (reserved classes of identifiers)"

#: ../../reference/lexical_analysis.rst:372
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr "ある種の (キーワードを除く) 識別子には、特殊な意味があります。これらの識別子種は、先頭や末尾にあるアンダースコア文字のパターンで区別されます:"

#: ../../reference/lexical_analysis.rst:386
msgid "``_*``"
msgstr "``_*``"

#: ../../reference/lexical_analysis.rst:377
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` is "
"used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`__builtin__` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr "この識別子は ``from module import *`` で import されません。対話インタプリタでは、最も最近行われた値評価の結果を記憶するために特殊な識別子 ``_`` が使われます; この識別子は :mod:`__builtin__` モジュール内に記憶されます。対話モードでない場合、 ``_`` には特殊な意味はなく、定義されていません。 :ref:`import` を参照してください。"

#: ../../reference/lexical_analysis.rst:384
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer"
" to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr "名前 ``_`` は、しばしば国際化 (internationalization) と共に用いられます; この慣習についての詳しい情報は、 :mod:`gettext` を参照してください。"

#: ../../reference/lexical_analysis.rst:394
msgid "``__*__``"
msgstr "``__*__``"

#: ../../reference/lexical_analysis.rst:389
msgid ""
"System-defined names. These names are defined by the interpreter and its "
"implementation (including the standard library).  Current system names are "
"discussed in the :ref:`specialnames` section and elsewhere.  More will "
"likely be defined in future versions of Python.  *Any* use of ``__*__`` "
"names, in any context, that does not follow explicitly documented use, is "
"subject to breakage without warning."
msgstr "システムで定義された (system-defined) 名前です。これらの名前はインタプリタと (標準ライブラリを含む) 実装上で定義されています; 現行のシステムでの名前は :ref:`specialnames` などで話題に挙げられています。 Python の将来のバージョンではより多くの名前が定義されることになります。このドキュメントで明記されている用法に従わない、 *あらゆる* ``__*__`` の名前は、いかなる文脈における利用でも、警告無く損害を引き起こすことがあります。"

#: ../../reference/lexical_analysis.rst:401
msgid "``__*``"
msgstr "``__*``"

#: ../../reference/lexical_analysis.rst:397
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See"
" section :ref:`atom-identifiers`."
msgstr "クラスプライベート (class-private) な名前です。このカテゴリに属する名前は、クラス定義のコンテキスト上で用いられた場合、基底クラスと派生クラスの \"プライベートな\" 属性間で名前衝突が起こるのを防ぐために書き直されます。 :ref:`atom-identifiers` を参照してください。"

#: ../../reference/lexical_analysis.rst:406
msgid "Literals"
msgstr "リテラル"

#: ../../reference/lexical_analysis.rst:412
msgid "Literals are notations for constant values of some built-in types."
msgstr "リテラル (literal) とは、いくつかの組み込み型の定数を表記したものです。"

#: ../../reference/lexical_analysis.rst:418
msgid "String literals"
msgstr "文字列リテラル"

#: ../../reference/lexical_analysis.rst:422
msgid "String literals are described by the following lexical definitions:"
msgstr "文字列リテラルは以下の字句定義で記述されます:"

#: ../../reference/lexical_analysis.rst:439
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` and the rest of "
"the string literal. The source character set is defined by the encoding "
"declaration; it is ASCII if no encoding declaration is given in the source "
"file; see section :ref:`encodings`."
msgstr "上記の生成規則で示されていない文法的な制限が一つあります。それは文字列リテラルの :token:`stringprefix` と残りの部分の間に空白を入れてはならないということです。ソースコード文字セット (source character set) はエンコード宣言で決まります．エンコード宣言がない場合には ASCII になります． :ref:`encodings` 節を参照してください．"

#: ../../reference/lexical_analysis.rst:451
msgid ""
"In plain English: String literals can be enclosed in matching single quotes "
"(``'``) or double quotes (``\"``).  They can also be enclosed in matching "
"groups of three single or double quotes (these are generally referred to as "
"*triple-quoted strings*).  The backslash (``\\``) character is used to "
"escape characters that otherwise have a special meaning, such as newline, "
"backslash itself, or the quote character.  String literals may optionally be"
" prefixed with a letter ``'r'`` or ``'R'``; such strings are called "
":dfn:`raw strings` and use different rules for interpreting backslash escape"
" sequences.  A prefix of ``'u'`` or ``'U'`` makes the string a Unicode "
"string.  Unicode strings use the Unicode character set as defined by the "
"Unicode Consortium and ISO 10646.  Some additional escape sequences, "
"described below, are available in Unicode strings. A prefix of ``'b'`` or "
"``'B'`` is ignored in Python 2; it indicates that the literal should become "
"a bytes literal in Python 3 (e.g. when code is automatically converted with "
"2to3).  A ``'u'`` or ``'b'`` prefix may be followed by an ``'r'`` prefix."
msgstr "より平易な説明: 文字列リテラルは、対応する一重引用符 (``'``) または二重引用符 (``\"``) で囲われます。また、対応する三連の一重引用符や二重引用符で囲うこともできます (通常、 *三重クオート文字列: triple-quoted string* として参照されます)。バックスラッシュ (``\\``) 文字を使って、ある文字を例えば改行文字やバックスラッシュ自体、クオート文字といった別の意味を持つようにエスケープすることができます。文字列リテラルの前には、オプションとして ``'r'`` または ``'R'`` 一文字を接頭してもかまいません; このような文字列は :dfn:`raw 文字列 (raw string)` と呼ばれ、バックスラッシュによるエスケープシーケンスの解釈規則が異なります。 ``'u'`` や ``'U'`` を接頭すると、文字列は Unicode 文字列 (Unicode string) になります。Unicode 文字列は Unicode コンソーシアムおよび ISO 10646 で定義されている Unicode 文字セットを使います。Unicode 文字列では、文字セットに加えて、以下で説明するようなエスケープシーケンスを利用できます。 ``'b'`` または ``'B'`` の接頭辞は Python 2 では無視されます。これは、(例えば、コードが 2to3 で自動的に変換されるときなどに) Python 3 でバイト列リテラルとなるべきであることを示します。 ``'u'`` または ``'b'`` 接頭辞のあとに ``'r'`` 接頭辞を続けることもできます。"

#: ../../reference/lexical_analysis.rst:467
msgid ""
"In triple-quoted strings, unescaped newlines and quotes are allowed (and are"
" retained), except that three unescaped quotes in a row terminate the "
"string.  (A \"quote\" is the character used to open the string, i.e. either "
"``'`` or ``\"``.)"
msgstr "三重クオート文字列中には、三連のエスケープされないクオート文字で文字列を終端してしまわないかぎり、エスケープされていない改行やクオートを書くことができます (さらに、それらはそのまま文字列中に残ります)。 (ここでいう \"クオート\" とは、文字列の囲みを開始するときに使った文字を示し、 ``'`` か ``\"`` のいずれかです)。"

#: ../../reference/lexical_analysis.rst:477
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in strings "
"are interpreted according to rules similar to those used by Standard C.  The"
" recognized escape sequences are:"
msgstr "``'r'`` または ``'R'`` 接頭文字がつかないかぎり、文字列中のエスケープシーケンスは標準 C で使われているのと同様の法則にしたがって解釈されます。以下に Python で認識されるエスケープシーケンスを示します:"

#: ../../reference/lexical_analysis.rst:482
msgid "Escape Sequence"
msgstr "エスケープシーケンス"

#: ../../reference/lexical_analysis.rst:482
msgid "Meaning"
msgstr "意味"

#: ../../reference/lexical_analysis.rst:482
msgid "Notes"
msgstr "注釈"

#: ../../reference/lexical_analysis.rst:484
msgid "``\\newline``"
msgstr "``\\newline``"

#: ../../reference/lexical_analysis.rst:484
msgid "Ignored"
msgstr "無視"

#: ../../reference/lexical_analysis.rst:486
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../../reference/lexical_analysis.rst:486
msgid "Backslash (``\\``)"
msgstr "バックスラッシュ (``\\``)"

#: ../../reference/lexical_analysis.rst:488
msgid "``\\'``"
msgstr "``\\'``"

#: ../../reference/lexical_analysis.rst:488
msgid "Single quote (``'``)"
msgstr "一重引用符 (``'``)"

#: ../../reference/lexical_analysis.rst:490
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../../reference/lexical_analysis.rst:490
msgid "Double quote (``\"``)"
msgstr "二重引用符 (``\"``)"

#: ../../reference/lexical_analysis.rst:492
msgid "``\\a``"
msgstr "``\\a``"

#: ../../reference/lexical_analysis.rst:492
msgid "ASCII Bell (BEL)"
msgstr "ASCII 端末ベル (BEL)"

#: ../../reference/lexical_analysis.rst:494
msgid "``\\b``"
msgstr "``\\b``"

#: ../../reference/lexical_analysis.rst:494
msgid "ASCII Backspace (BS)"
msgstr "ASCII バックスペース (BS)"

#: ../../reference/lexical_analysis.rst:496
msgid "``\\f``"
msgstr "``\\f``"

#: ../../reference/lexical_analysis.rst:496
msgid "ASCII Formfeed (FF)"
msgstr "ASCII フォームフィード (FF)"

#: ../../reference/lexical_analysis.rst:498
msgid "``\\n``"
msgstr "``\\n``"

#: ../../reference/lexical_analysis.rst:498
msgid "ASCII Linefeed (LF)"
msgstr "ASCII 行送り (LF)"

#: ../../reference/lexical_analysis.rst:500
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: ../../reference/lexical_analysis.rst:500
msgid "Character named *name* in the Unicode database (Unicode only)"
msgstr "Unicode データベース中で名前 *name* を持つ文字 (Unicode のみ)"

#: ../../reference/lexical_analysis.rst:503
msgid "``\\r``"
msgstr "``\\r``"

#: ../../reference/lexical_analysis.rst:503
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII 復帰 (CR)"

#: ../../reference/lexical_analysis.rst:505
msgid "``\\t``"
msgstr "``\\t``"

#: ../../reference/lexical_analysis.rst:505
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII 水平タブ (TAB)"

#: ../../reference/lexical_analysis.rst:507
msgid "``\\uxxxx``"
msgstr "``\\uxxxx``"

#: ../../reference/lexical_analysis.rst:507
msgid "Character with 16-bit hex value *xxxx* (Unicode only)"
msgstr "16-bit の 16 進数値 *xxxx* を持つ文字 (Unicode のみ)"

#: ../../reference/lexical_analysis.rst:507
msgid "\\(1)"
msgstr "\\(1)"

#: ../../reference/lexical_analysis.rst:510
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxx``"

#: ../../reference/lexical_analysis.rst:510
msgid "Character with 32-bit hex value *xxxxxxxx* (Unicode only)"
msgstr "32-bit の 16 進数値 *xxxxxxxx* を持つ文字 (Unicode のみ)"

#: ../../reference/lexical_analysis.rst:510
msgid "\\(2)"
msgstr "\\(2)"

#: ../../reference/lexical_analysis.rst:513
msgid "``\\v``"
msgstr "``\\v``"

#: ../../reference/lexical_analysis.rst:513
msgid "ASCII Vertical Tab (VT)"
msgstr "ASCII 垂直タブ (VT)"

#: ../../reference/lexical_analysis.rst:515
msgid "``\\ooo``"
msgstr "``\\ooo``"

#: ../../reference/lexical_analysis.rst:515
msgid "Character with octal value *ooo*"
msgstr "8 進数値 *ooo* を持つ文字"

#: ../../reference/lexical_analysis.rst:515
msgid "(3,5)"
msgstr "(3,5)"

#: ../../reference/lexical_analysis.rst:518
msgid "``\\xhh``"
msgstr "``\\xhh``"

#: ../../reference/lexical_analysis.rst:518
msgid "Character with hex value *hh*"
msgstr "16 進数値 *hh* を持つ文字"

#: ../../reference/lexical_analysis.rst:518
msgid "(4,5)"
msgstr "(4,5)"

#: ../../reference/lexical_analysis.rst:523
msgid "Notes:"
msgstr "注釈:"

#: ../../reference/lexical_analysis.rst:526
msgid ""
"Individual code units which form parts of a surrogate pair can be encoded "
"using this escape sequence."
msgstr "サロゲートペアの断片を形成する個々のコード単位は、このエスケープシーケンスでエンコードすることができます。"

#: ../../reference/lexical_analysis.rst:530
msgid ""
"Any Unicode character can be encoded this way, but characters outside the "
"Basic Multilingual Plane (BMP) will be encoded using a surrogate pair if "
"Python is compiled to use 16-bit code units (the default)."
msgstr "Unicode 文字はすべてこの方法でエンコードできますが、 Python が 16-bit コード単位を扱うようにコンパイルされている (デフォルトの設定です) 場合、基本多言語面 (Basic Multilingual Plane, BMP) 外の文字はサロゲートペア (surrogate pair) を使ってエンコードすることになります。"

#: ../../reference/lexical_analysis.rst:535
msgid "As in Standard C, up to three octal digits are accepted."
msgstr "標準 C と同じく、最大で 3 桁の 8 進数まで受理します。"

#: ../../reference/lexical_analysis.rst:538
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr "標準 C とは違い、ちょうど 2 桁の 16 進数しか受理されません。"

#: ../../reference/lexical_analysis.rst:541
msgid ""
"In a string literal, hexadecimal and octal escapes denote the byte with the "
"given value; it is not necessary that the byte encodes a character in the "
"source character set. In a Unicode literal, these escapes denote a Unicode "
"character with the given value."
msgstr "文字列リテラル中では， 16 進および 8 進エスケープはエスケープの示すバイト文字になります．そのバイト文字がソース文字セットでエンコードされている保証はありません．Unicode リテラル中では，エスケープ文字はエスケープ文字の表現する値を持つ Unicode 文字になります．"

#: ../../reference/lexical_analysis.rst:548
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the string*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences marked as \"(Unicode only)\" in the table above "
"fall into the category of unrecognized escapes for non-Unicode string "
"literals."
msgstr "標準の C とは違い、認識されなかったエスケープシーケンスはそのまま文字列中に残されます。すなわち。 *バックスラッシュも文字列中に残ります。* (この挙動はデバッグの際に便利です: エスケープシーケンスを誤入力した場合、その結果として出力に失敗しているのが用意にわかります) テーブル中で \"(Unicode のみ)\" と書かれたエスケープシーケンスは、非 Unicode 文字列リテラル中では認識されないエスケープシーケンスのカテゴリに分類されるので注意してください。"

#: ../../reference/lexical_analysis.rst:555
msgid ""
"When an ``'r'`` or ``'R'`` prefix is present, a character following a "
"backslash is included in the string without change, and *all backslashes are"
" left in the string*.  For example, the string literal ``r\"\\n\"`` consists"
" of two characters: a backslash and a lowercase ``'n'``.  String quotes can "
"be escaped with a backslash, but the backslash remains in the string; for "
"example, ``r\"\\\"\"`` is a valid string literal consisting of two "
"characters: a backslash and a double quote; ``r\"\\\"`` is not a valid "
"string literal (even a raw string cannot end in an odd number of "
"backslashes).  Specifically, *a raw string cannot end in a single backslash*"
" (since the backslash would escape the following quote character).  Note "
"also that a single backslash followed by a newline is interpreted as those "
"two characters as part of the string, *not* as a line continuation."
msgstr "接頭文字 ``'r'`` または ``'R'`` がある場合、バックスラッシュの後にくる文字はそのまま文字列中に入り、 *バックスラッシュは全て文字列中に残されます* 。例えば、文字列リテラル ``r\"\\n\"`` は二つの文字: バックスラッシュと小文字の ``'n'`` からなる文字列を表すことになります。引用符はバックスラッシュでエスケープすることができますが、バックスラッシュ自体も残ってしまいます; 例えば、 ``r\"\\\"\"`` は不正でない文字列リテラルで、バックスラッシュと二重引用符からなる文字列を表します; ``r\"\\\"`` は正しくない文字列リテラルです (raw 文字列を奇数個連なったバックスラッシュで終わらせることはできません)。厳密にいえば、 (バックスラッシュが直後のクオート文字をエスケープしてしまうため) *raw文字列を単一のバックスラッシュで終わらせることはできない* ということになります。また、バックスラッシュの直後に改行がきても、行継続を意味する *のではなく* 、それら二つの文字として解釈されるので注意してください。"

#: ../../reference/lexical_analysis.rst:568
msgid ""
"When an ``'r'`` or ``'R'`` prefix is used in conjunction with a ``'u'`` or "
"``'U'`` prefix, then the ``\\uXXXX`` and ``\\UXXXXXXXX`` escape sequences "
"are processed while  *all other backslashes are left in the string*. For "
"example, the string literal ``ur\"\\u0062\\n\"`` consists of three Unicode "
"characters: 'LATIN SMALL LETTER B', 'REVERSE SOLIDUS', and 'LATIN SMALL "
"LETTER N'. Backslashes can be escaped with a preceding backslash; however, "
"both remain in the string.  As a result, ``\\uXXXX`` escape sequences are "
"only recognized when there are an odd number of backslashes."
msgstr "``'r'`` および ``'R'`` 接頭文字を ``'u'`` や ``'U'`` と合わせて使った場合、 ``\\uXXXX`` および ``\\UXXXXXXXX`` エスケープシーケンスは処理されますが、 *その他のバックスラッシュはすべて文字列中に残されます* 。例えば、文字列リテラル ``ur\"\\u0062\\n\"`` は、3つの Unicode 文字: 'LATIN SMALL LETTER B' (ラテン小文字 B)、'REVERSE SOLIDUS' (逆向き斜線)、および 'LATIN SMALL LETTER N' (ラテン小文字 N) を表します。バックスラッシュの前にバックスラッシュをつけてエスケープすることはできます; しかし、バックスラッシュは両方とも文字列中に残されます。その結果、 ``\\uXXXX`` エスケープシーケンスは、バックスラッシュが奇数個連なっている場合にのみ認識されます。"

#: ../../reference/lexical_analysis.rst:581
msgid "String literal concatenation"
msgstr "文字列リテラルの結合 (concatenation)"

#: ../../reference/lexical_analysis.rst:583
msgid ""
"Multiple adjacent string literals (delimited by whitespace), possibly using "
"different quoting conventions, are allowed, and their meaning is the same as"
" their concatenation.  Thus, ``\"hello\" 'world'`` is equivalent to "
"``\"helloworld\"``.  This feature can be used to reduce the number of "
"backslashes needed, to split long strings conveniently across long lines, or"
" even to add comments to parts of strings, for example::"
msgstr "複数の文字列リテラルは、互いに異なる引用符を使っていても (空白文字で区切って) 隣接させることができ、その意味は各々の文字列を結合したものと同じになります。したがって、 ``\"hello\" 'world'`` は ``\"helloworld\"`` と同じになります。この機能を使うと、長い文字列を分離して、複数行にまたがらせる際に便利です。また、部分文字列ごとにコメントを追加することもできます。例えば::"

#: ../../reference/lexical_analysis.rst:594
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings)."
msgstr "この機能は文法レベルで定義されていますが、スクリプトをコンパイルする際の処理として実現されることに注意してください。実行時に文字列表現を結合したければ、 '+' 演算子を使わなければなりません。また、リテラルの結合においては、結合する各要素に異なる引用符形式を使える (raw 文字列と三重引用符を混ぜることさえできます) ので注意してください。"

#: ../../reference/lexical_analysis.rst:603
msgid "Numeric literals"
msgstr "数値リテラル"

#: ../../reference/lexical_analysis.rst:619
msgid ""
"There are four types of numeric literals: plain integers, long integers, "
"floating point numbers, and imaginary numbers.  There are no complex "
"literals (complex numbers can be formed by adding a real number and an "
"imaginary number)."
msgstr "数値リテラルは 4 種類あります: 整数 (plain integer)、長整数 (long integer)、浮動小数点数 (floating point number)、そして虚数 (imaginary number) です。複素数のためのリテラルはありません (複素数は実数と虚数の和で作ることができます)。"

#: ../../reference/lexical_analysis.rst:623
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr "数値リテラルには符号が含まれていないことに注意してください; ``-1`` のような句は、実際には単項演算子 (unary operator) '``-``' とリテラル ``1`` を組み合わせたものです。"

#: ../../reference/lexical_analysis.rst:631
msgid "Integer and long integer literals"
msgstr "整数および長整数リテラル"

#: ../../reference/lexical_analysis.rst:633
msgid ""
"Integer and long integer literals are described by the following lexical "
"definitions:"
msgstr "整数および長整数リテラルは以下の字句定義で記述されます:"

#: ../../reference/lexical_analysis.rst:648
msgid ""
"Although both lower case ``'l'`` and upper case ``'L'`` are allowed as "
"suffix for long integers, it is strongly recommended to always use ``'L'``, "
"since the letter ``'l'`` looks too much like the digit ``'1'``."
msgstr "長整数を表す末尾の文字は小文字の ``'l'`` でも大文字の ``'L'`` でもかまいませんが、 ``'l'`` は ``'1'`` に良く似ているので、常に ``'L'`` を使うよう強く勧めます。"

#: ../../reference/lexical_analysis.rst:652
msgid ""
"Plain integer literals that are above the largest representable plain "
"integer (e.g., 2147483647 when using 32-bit arithmetic) are accepted as if "
"they were long integers instead. [#]_  There is no limit for long integer "
"literals apart from what can be stored in available memory."
msgstr "整数で表現できる最大の値よりも大きい整数のリテラル (例えば 32-bit 整数を使っている場合には 2147483647) は、長整数として表現できる値であれば受理されます。 [#]_ 値がメモリ上に収まるかどうかという問題を除けば、長整数リテラルには値域の制限がありません。"

#: ../../reference/lexical_analysis.rst:657
msgid ""
"Some examples of plain integer literals (first row) and long integer "
"literals (second and third rows)::"
msgstr "整数リテラル (最初の行) と長整数リテラル (二行目および三行目) の例を以下に示します::"

#: ../../reference/lexical_analysis.rst:668
msgid "Floating point literals"
msgstr "浮動小数点数リテラル"

#: ../../reference/lexical_analysis.rst:670
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr "浮動小数点数リテラルは以下の字句定義で記述されます:"

#: ../../reference/lexical_analysis.rst:680
msgid ""
"Note that the integer and exponent parts of floating point numbers can look "
"like octal integers, but are interpreted using radix 10.  For example, "
"``077e010`` is legal, and denotes the same number as ``77e10``. The allowed "
"range of floating point literals is implementation-dependent. Some examples "
"of floating point literals::"
msgstr "浮動小数点数における整数部と指数部は 8 進数のように見えることもありますが、10 を基数として解釈されるので注意してください。例えば、 ``077e010`` は正しい表記であり、 ``77e10`` と同じ数を表します。浮動小数点数リテラルの取りうる値の範囲は実装に依存します。浮動小数点数リテラルの例をいくつか示します::"

#: ../../reference/lexical_analysis.rst:688
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator ``-`` and the literal "
"``1``."
msgstr "数値リテラルには符号が含まれていないことに注意してください; ``-1`` のような句は、実際には単項演算子 (unary operator) '``-``' とリテラル ``1`` を組み合わせたものです。"

#: ../../reference/lexical_analysis.rst:696
msgid "Imaginary literals"
msgstr "虚数 (imaginary) リテラル"

#: ../../reference/lexical_analysis.rst:698
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr "虚数リテラルは以下のような字句定義で記述されます:"

#: ../../reference/lexical_analysis.rst:703
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have"
" the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr "虚数リテラルは、実数部が 0.0 の複素数を表します。複素数は二つ組の浮動小数点型の数値で表され、それぞれの数値は浮動小数点型と同じ定義域の範囲を持ちます。実数部がゼロでない浮動小数点を生成するには、 ``(3+4j)`` のように虚数リテラルに浮動小数点数を加算します。以下に虚数リテラルの例をいくつか示します::"

#: ../../reference/lexical_analysis.rst:715
msgid "Operators"
msgstr "演算子 (operator)"

#: ../../reference/lexical_analysis.rst:719
msgid "The following tokens are operators:"
msgstr "以下のトークンは演算子です:"

#: ../../reference/lexical_analysis.rst:728
msgid ""
"The comparison operators ``<>`` and ``!=`` are alternate spellings of the "
"same operator.  ``!=`` is the preferred spelling; ``<>`` is obsolescent."
msgstr "比較演算子 ``<>`` と ``!=`` は、同じ演算子について別の書き方をしたものです。書き方としては ``!=`` を推奨します; ``<>`` は時代遅れの書き方です。"

#: ../../reference/lexical_analysis.rst:735
msgid "Delimiters"
msgstr "デリミタ (delimiter)"

#: ../../reference/lexical_analysis.rst:739
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "以下のトークンは文法上のデリミタとして働きます:"

#: ../../reference/lexical_analysis.rst:748
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis in slices. "
"The second half of the list, the augmented assignment operators, serve "
"lexically as delimiters, but also perform an operation."
msgstr "浮動小数点数や虚数リテラル中にピリオドがあってもかまいません。ピリオド三つの列はスライス表記における省略符号 (ellipsis) として特別な意味を持っています。リスト後半の累算代入演算子 (augmented assignment operator) は、字句的にはデリミタとして振舞いますが、演算も行います。"

#: ../../reference/lexical_analysis.rst:753
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr "以下の印字可能 ASCII 文字は、他のトークンの一部として特殊な意味を持っていたり、字句解析器にとって重要な意味を持っています:"

#: ../../reference/lexical_analysis.rst:762
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr "以下の印字可能 ASCII 文字は、Python では使われていません。これらの文字が文字列リテラルやコメントの外にある場合、無条件にエラーとなります:"

#: ../../reference/lexical_analysis.rst:770
msgid "Footnotes"
msgstr "注記"

#: ../../reference/lexical_analysis.rst:771
msgid ""
"In versions of Python prior to 2.4, octal and hexadecimal literals in the "
"range just above the largest representable plain integer but below the "
"largest unsigned 32-bit number (on a machine using 32-bit arithmetic), "
"4294967296, were taken as the negative plain integer obtained by subtracting"
" 4294967296 from their unsigned value."
msgstr "バージョン 2.4 以前の Python では， 8 進および 16 進のリテラルのうち，通常の整数型として表現可能な値より大きく，かつ符号無しの 32-bit (32-bit 演算を使う計算機の場合) 整数で表現できる最大値，すなわち 4294967296 よりも小さな数は，リテラルを符号無し整数として表現した値から 4294967296 を引いて得られる負の整数として扱っていました．"
