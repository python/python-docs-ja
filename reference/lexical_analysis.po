# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Shin Saito, 2021
# tomo, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-24 14:15+0000\n"
"PO-Revision-Date: 2021-06-28 01:49+0000\n"
"Last-Translator: tomo, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "字句解析"

#: ../../reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""
"Python で書かれたプログラムは *パーザ (parser)* に読み込まれます。パーザへの"
"入力は、 *字句解析器 (lexical analyzer)* によって生成された一連の *トークン "
"(token)* からなります。この章では、字句解析器がファイルをトークン列に分解する"
"方法について解説します。"

#: ../../reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see :pep:"
"`3120` for details.  If the source file cannot be decoded, a :exc:"
"`SyntaxError` is raised."
msgstr ""
"Python はプログラムテキストを Unicode コードポイントとして読み込みます。ソー"
"スファイルのエンコーディングはエンコーディング宣言で与えられ、デフォルトは "
"UTF-8  です。詳細は :pep:`3120` を参照してください。ソースファイルがデコード"
"できなければ、 :exc:`SyntaxError` が送出されます。"

#: ../../reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr "行構造"

#: ../../reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr "Python プログラムは多数の *論理行 (logical lines)* に分割されます。"

#: ../../reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr "論理行 (logical line)"

#: ../../reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""
"論理行の終端は、トークン NEWLINE で表されます。構文上許されている場合 (複合"
"文: compound statement 中の実行文: statement) を除いて、実行文は論理行間にま"
"たがることはできません。論理行は一行またはそれ以上の *物理行(physical line)* "
"からなり、物理行の末尾には明示的または非明示的な *行連結(line joining)* 規則"
"が続きます。"

#: ../../reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr "物理行 (physical line)"

#: ../../reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line "
"termination sequences can be used - the Unix form using ASCII LF (linefeed), "
"the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) character.  "
"All of these forms can be used equally, regardless of platform. The end of "
"input also serves as an implicit terminator for the final physical line."
msgstr ""
"物理行とは、行終端コードで区切られた文字列のことです。\n"
"ソースファイルやソース文字列では、各プラットフォームごとの標準の行終端コード"
"を使用することができます。\n"
"Unix形式ではASCII LF (行送り: linefeed)文字、 Windows形式ではASCII 配列の CR "
"LF (復帰: return に続いて行送り) 、 Macintosh形式ではASCII CR (復帰) 文字で"
"す。\n"
"これら全ての形式のコードは、違うプラットフォームでも等しく使用することができ"
"ます。\n"
"入力の末尾も、最後の物理行の暗黙的な終端としての役割を果たします。"

#: ../../reference/lexical_analysis.rst:57
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""
"Pythonに埋め込む場合には、標準のC言語の改行文字の変換規則 (ASCII LFを表現した"
"文字コード ``\\n`` が行終端となります) に従って、 Python APIにソースコードを"
"渡す必要があります。"

#: ../../reference/lexical_analysis.rst:65
msgid "Comments"
msgstr "コメント (Comments)"

#: ../../reference/lexical_analysis.rst:70
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax."
msgstr ""
"コメントは文字列リテラル内に入っていないハッシュ文字 (``#``) から始まり、同じ"
"物理行の末端で終わります。\n"
"非明示的な行継続規則が適用されていない限り、コメントは論理行を終端させま"
"す。\n"
"コメントは構文上無視されます。"

#: ../../reference/lexical_analysis.rst:79
msgid "Encoding declarations"
msgstr "エンコード宣言 (encoding declaration)"

#: ../../reference/lexical_analysis.rst:84
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"Python スクリプト中の一行目か二行目にあるコメントが正規表現 "
"``coding[=:]\\s*([-\\w.]+)`` にマッチする場合、コメントはエンコード宣言として"
"処理されます; この表現の最初のグループがソースコードファイルのエンコードを指"
"定します。エンコード宣言は自身の行になければなりません。二行目にある場合、一"
"行目もコメントのみの行でなければなりません。エンコード宣言式として推奨する形"
"式は ::"

#: ../../reference/lexical_analysis.rst:93
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "これは GNU Emacs で認識できます。または ::"

#: ../../reference/lexical_analysis.rst:97
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "これは、Bram Moolenar による VIM が認識できる形式です。"

#: ../../reference/lexical_analysis.rst:99
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""
"エンコーディング宣言が見つからなければ、デフォルトのエンコーディングは UTF-8 "
"です。さらに、ファイルの先頭のバイト列が UTF-8 バイトオーダ記号 "
"(``b'\\xef\\xbb\\xbf'``) なら、ファイルのエンコーディングは UTF-8 と宣言され"
"ているものとします (この機能は Microsoft の :program:`notepad` やその他のエ"
"ディタでサポートされています)。"

#: ../../reference/lexical_analysis.rst:104
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python "
"(see :ref:`standard-encodings`). The encoding is used for all lexical "
"analysis, including string literals, comments and identifiers."
msgstr ""

#: ../../reference/lexical_analysis.rst:113
msgid "Explicit line joining"
msgstr "明示的な行継続"

#: ../../reference/lexical_analysis.rst:117
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"二つまたはそれ以上の物理行を論理行としてつなげるためには、バックスラッシュ文"
"字 (``\\``) を使って以下のようにします: 物理行が文字列リテラルやコメント中の"
"文字でないバックスラッシュで終わっている場合、後続する行とつなげて一つの論理"
"行を構成し、バックスラッシュおよびバックスラッシュの後ろにある行末文字を削除"
"します。例えば::"

#: ../../reference/lexical_analysis.rst:128
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"バックスラッシュで終わる行にはコメントを入れることはできません。また、バック"
"スラッシュを使ってコメントを継続することはできません。バックスラッシュが文字"
"列リテラル中にある場合を除き、バックスラッシュの後ろにトークンを継続すること"
"はできません (すなわち、物理行内の文字列リテラル以外のトークンをバックスラッ"
"シュを使って分断することはできません)。上記以外の場所では、文字列リテラル外に"
"あるバックスラッシュはどこにあっても不正となります。"

#: ../../reference/lexical_analysis.rst:138
msgid "Implicit line joining"
msgstr "非明示的な行継続"

#: ../../reference/lexical_analysis.rst:140
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"丸括弧 (parentheses)、角括弧 (square bracket) 、および波括弧 (curly brace) 内"
"の式は、バックスラッシュを使わずに一行以上の物理行に分割することができます。"
"例えば::"

#: ../../reference/lexical_analysis.rst:148
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"非明示的に継続された行にはコメントを含めることができます。継続行のインデント"
"は重要ではありません。空の継続行を書くことができます。非明示的な継続行中に"
"は、NEWLINE トークンは存在しません。非明示的な行の継続は、三重クオートされた"
"文字列 (下記参照) でも発生します; この場合には、コメントを含めることができま"
"せん。"

#: ../../reference/lexical_analysis.rst:158
msgid "Blank lines"
msgstr "空行"

#: ../../reference/lexical_analysis.rst:162
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"スペース、タブ、フォームフィード、およびコメントのみを含む論理行は無視されま"
"す (すなわち、NEWLINE トークンは生成されません)。文を対話的に入力している際に"
"は、空行の扱いは行読み込み-評価-出力 (read-eval-print) ループの実装によって異"
"なることがあります。標準的な対話的インタプリタの実装では、完全な空行でできた"
"論理行 (すなわち、空白文字もコメントも全く含まない空行) は、複数行からなる文"
"の終端を示します。"

#: ../../reference/lexical_analysis.rst:173
msgid "Indentation"
msgstr "インデント"

#: ../../reference/lexical_analysis.rst:177
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""
"論理行の行頭にある、先頭の空白 (スペースおよびタブ) の連なりは、その行のイン"
"デントレベルを計算するために使われます。インデントレベルは、実行文のグループ"
"化方法を決定するために用いられます。"

#: ../../reference/lexical_analysis.rst:181
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""
"タブは (左から右の方向に) 1 つにつき 8 つのスペースで置き換えられ、置き換え後"
"の文字数は 8 の倍数になります (Unix で使われている規則と同じになるよう意図さ"
"れています)。そして、最初の非空白文字までのスペースの総数が、その行のインデン"
"トを決定します。インデントは、バックスラッシュで複数の物理行に分割できませ"
"ん; 最初のバックスラッシュまでの空白がインデントを決定します。"

#: ../../reference/lexical_analysis.rst:189
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"ソースファイルがタブとスペースを混在させ、その意味づけがタブのスペース換算数"
"に依存するようなら、インデントは不合理なものとして却下されます。その場合は :"
"exc:`TabError` が送出されます。"

#: ../../reference/lexical_analysis.rst:193
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**プラットフォーム間の互換性に関する注意:** 非 UNIX プラットフォームにおける"
"テキストエディタの性質上、一つのソースファイル内でタブとインデントを混在させ"
"て使うのは賢明ではありません。また、プラットフォームによっては、最大インデン"
"トレベルを明示的に制限しているかもしれません。"

#: ../../reference/lexical_analysis.rst:198
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"フォームフィード文字が行の先頭にあっても構いません; フォームフィード文字は上"
"のインデントレベル計算時には無視されます。フォームフィード文字が先頭の空白中"
"の他の場所にある場合、その影響は未定義です (例えば、スペースの数を 0 にリセッ"
"トするかもしれません)。"

#: ../../reference/lexical_analysis.rst:205
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""
"連続する行における各々のインデントレベルは、 INDENT および DEDENT トークンを"
"生成するために使われます。トークンの生成はスタックを用いて以下のように行われ"
"ます。"

#: ../../reference/lexical_analysis.rst:208
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""
"ファイル中の最初の行を読み出す前に、スタックにゼロが一つ積まれ (push され) ま"
"す; このゼロは決して除去 (pop) されることはありません。スタックの先頭に積まれ"
"てゆく数字は、常にスタックの末尾から先頭にかけて厳密に増加するようになってい"
"ます。各論理行の開始位置において、その行のインデントレベル値がスタックの先頭"
"の値と比較されます。値が等しければ何もしません。インデントレベル値がスタック"
"上の値よりも大きければ、インデントレベル値はスタックに積まれ、INDENT トークン"
"が一つ生成されます。インデントレベル値がスタック上の値よりも小さい場合、その"
"値はスタック内のいずれかの値と *等しくなければなりません* ; スタック上のイン"
"デントレベル値よりも大きい値はすべて除去され、値が一つ除去されるごとに "
"DEDENT トークンが一つ生成されます。ファイルの末尾では、スタックに残っているゼ"
"ロより大きい値は全て除去され、値が一つ除去されるごとに DEDENT トークンが一つ"
"生成されます。"

#: ../../reference/lexical_analysis.rst:219
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""
"以下の例に正しく (しかし当惑させるように) インデントされた Python コードの一"
"部を示します::"

#: ../../reference/lexical_analysis.rst:234
msgid "The following example shows various indentation errors::"
msgstr "以下の例は、様々なインデントエラーになります::"

#: ../../reference/lexical_analysis.rst:244
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"(実際は、最初の 3 つのエラーはパーザによって検出されます; 最後のエラーのみが"
"字句解析器で見つかります --- ``return r`` のインデントは、スタックから逐次除"
"去されていくどのインデントレベル値とも一致しません)"

#: ../../reference/lexical_analysis.rst:252
msgid "Whitespace between tokens"
msgstr "トークン間の空白"

#: ../../reference/lexical_analysis.rst:254
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""
"論理行の先頭や文字列の内部にある場合を除き、空白文字であるスペース、タブ、お"
"よびフォームフィードは、トークンを分割するために自由に利用することができま"
"す。二つのトークンを並べて書くと別のトークンとしてみなされてしまうような場合"
"には、トークンの間に空白が必要となります (例えば、ab は一つのトークンです"
"が、 a b は二つのトークンとなります)。"

#: ../../reference/lexical_analysis.rst:264
msgid "Other tokens"
msgstr "その他のトークン"

#: ../../reference/lexical_analysis.rst:266
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""
"NEWLINE、INDENT、および DEDENT の他、以下のトークンのカテゴリ: *識別子 "
"(identifier)*, *キーワード(keyword)*, *リテラル*, *演算子 (operator)*, *デリ"
"ミタ (delimiter)* が存在します。空白文字 (上で述べた行終端文字以外) はトーク"
"ンではありませんが、トークンを区切る働きがあります。トークンの解析にあいまい"
"さが生じた場合、トークンは左から右に読んで不正でないトークンを構築できる最長"
"の文字列を含むように構築されます。"

#: ../../reference/lexical_analysis.rst:276
msgid "Identifiers and keywords"
msgstr "識別子 (identifier) およびキーワード (keyword)"

#: ../../reference/lexical_analysis.rst:280
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr "識別子 (または *名前 (name)*) は、以下の字句定義で記述されます。"

#: ../../reference/lexical_analysis.rst:283
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr ""
"Python における識別子の構文は、Unicode 標準仕様添付書類 UAX-31 に基づき、詳細"
"と変更点は以下で定義します。詳しくは :pep:`3131` を参照してください。"

#: ../../reference/lexical_analysis.rst:287
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the first "
"character, the digits ``0`` through ``9``."
msgstr ""
"ASCII 範囲 (U+0001..U+007F) 内では、識別子として有効な文字は Python 2.x にお"
"けるものと同じです。大文字と小文字の ``A`` から ``Z``、アンダースコア ``_``、"
"先頭の文字を除く数字 ``0`` から ``9`` です。"

#: ../../reference/lexical_analysis.rst:292
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the :mod:"
"`unicodedata` module."
msgstr ""
"Python 3.0 は、さらに ASCII 範囲外から文字を導入します (:pep:`3131` を参照し"
"てください。)。これらの文字については、分類は :mod:`unicodedata` モジュールに"
"含まれる Unicode Character Database の版を使います。"

#: ../../reference/lexical_analysis.rst:296
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr "識別子の長さには制限がありません。大小文字は区別されます。"

#: ../../reference/lexical_analysis.rst:305
msgid "The Unicode category codes mentioned above stand for:"
msgstr "上で言及した Unicode カテゴリコードは以下を表します:"

#: ../../reference/lexical_analysis.rst:307
msgid "*Lu* - uppercase letters"
msgstr "*Lu* - 大文字 (uppercase letters)"

#: ../../reference/lexical_analysis.rst:308
msgid "*Ll* - lowercase letters"
msgstr "*Ll* - 小文字 (lowercase letters)"

#: ../../reference/lexical_analysis.rst:309
msgid "*Lt* - titlecase letters"
msgstr "*Lt* - 先頭が大文字 (titlecase letters)"

#: ../../reference/lexical_analysis.rst:310
msgid "*Lm* - modifier letters"
msgstr "*Lm* - 修飾文字 (modifier letters)"

#: ../../reference/lexical_analysis.rst:311
msgid "*Lo* - other letters"
msgstr "*Lo* - その他の文字 (other letters)"

#: ../../reference/lexical_analysis.rst:312
msgid "*Nl* - letter numbers"
msgstr "*Nl* - 数値を表す文字 (letter numbers)"

#: ../../reference/lexical_analysis.rst:313
msgid "*Mn* - nonspacing marks"
msgstr "*Mn* - 字幅のない記号 (nonspacing marks)"

#: ../../reference/lexical_analysis.rst:314
msgid "*Mc* - spacing combining marks"
msgstr "*Mc* - 字幅のある結合記号 (spacing combining marks)"

#: ../../reference/lexical_analysis.rst:315
msgid "*Nd* - decimal numbers"
msgstr "*Nd* - 10 進数字 (decimal numbers)"

#: ../../reference/lexical_analysis.rst:316
msgid "*Pc* - connector punctuations"
msgstr "*Pc* - 連結用句読記号 (connector punctuations)"

#: ../../reference/lexical_analysis.rst:317
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt <https://www."
"unicode.org/Public/14.0.0/ucd/PropList.txt>`_ to support backwards "
"compatibility"
msgstr ""

#: ../../reference/lexical_analysis.rst:320
msgid "*Other_ID_Continue* - likewise"
msgstr "*Other_ID_Continue* - 同様"

#: ../../reference/lexical_analysis.rst:322
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr ""
"すべての識別子は、解析中は正規化形式 NFKC に変換されます。識別子間の比較は "
"NFKC に基づきます。"

#: ../../reference/lexical_analysis.rst:325
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 14.0.0 can be found at https://www.unicode.org/Public/14.0.0/ucd/"
"DerivedCoreProperties.txt"
msgstr ""

#: ../../reference/lexical_analysis.rst:333
msgid "Keywords"
msgstr "キーワード (keyword)"

#: ../../reference/lexical_analysis.rst:339
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""
"以下の識別子は、予約語、または Python 言語における *キーワード (keyword)* と"
"して使われ、通常の識別子として使うことはできません。キーワードは厳密に下記の"
"通りに綴らなければなりません:"

#: ../../reference/lexical_analysis.rst:357
msgid "Soft Keywords"
msgstr "ソフトキーワード"

#: ../../reference/lexical_analysis.rst:363
msgid ""
"Some identifiers are only reserved under specific contexts. These are known "
"as *soft keywords*.  The identifiers ``match``, ``case`` and ``_`` can "
"syntactically act as keywords in contexts related to the pattern matching "
"statement, but this distinction is done at the parser level, not when "
"tokenizing."
msgstr ""
"特定のコンテキストのも元でだけ予約される識別子があります。\n"
"それらは *ソフトキーワード* として知られています。\n"
"識別子 ``match``, ``case``, ``_`` は、パターンマッチング文に関係するコンテキ"
"ストの元でキーワードとして構文に沿って働きますが、このキーワードになるかなら"
"ないかの違いは構文解析レベルで出てくるもので、語句解析の時点では出ません。"

#: ../../reference/lexical_analysis.rst:369
msgid ""
"As soft keywords, their use with pattern matching is possible while still "
"preserving compatibility with existing code that uses ``match``, ``case`` "
"and ``_`` as identifier names."
msgstr ""
"``match``, ``case``, ``_`` を識別子名として使っている既存のコードがあって、今"
"でも互換性を保っていても、ソフトキーワードとしてパターンマッチングで使えま"
"す。"

#: ../../reference/lexical_analysis.rst:380
msgid "Reserved classes of identifiers"
msgstr "予約済みの識別子種 (reserved classes of identifiers)"

#: ../../reference/lexical_analysis.rst:382
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""
"ある種の (キーワードを除く) 識別子には、特殊な意味があります。これらの識別子"
"種は、先頭や末尾にあるアンダースコア文字のパターンで区別されます:"

#: ../../reference/lexical_analysis.rst:387
msgid "``_*``"
msgstr "``_*``"

#: ../../reference/lexical_analysis.rst:387
msgid "Not imported by ``from module import *``."
msgstr ""

#: ../../reference/lexical_analysis.rst:408
msgid "``_``"
msgstr ""

#: ../../reference/lexical_analysis.rst:390
msgid ""
"In a ``case`` pattern within a :keyword:`match` statement, ``_`` is a :ref:"
"`soft keyword <soft-keywords>` that denotes a :ref:`wildcard <wildcard-"
"patterns>`."
msgstr ""

#: ../../reference/lexical_analysis.rst:394
msgid ""
"Separately, the interactive interpreter makes the result of the last "
"evaluation available in the variable ``_``. (It is stored in the :mod:"
"`builtins` module, alongside built-in functions like ``print``.)"
msgstr ""

#: ../../reference/lexical_analysis.rst:399
msgid ""
"Elsewhere, ``_`` is a regular identifier. It is often used to name "
"\"special\" items, but it is not special to Python itself."
msgstr ""

#: ../../reference/lexical_analysis.rst:404
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""
"名前 ``_`` は、しばしば国際化 (internationalization) と共に用いられます; この"
"慣習についての詳しい情報は、 :mod:`gettext` を参照してください。"

#: ../../reference/lexical_analysis.rst:408
msgid "It is also commonly used for unused variables."
msgstr ""

#: ../../reference/lexical_analysis.rst:416
msgid "``__*__``"
msgstr "``__*__``"

#: ../../reference/lexical_analysis.rst:411
msgid ""
"System-defined names, informally known as \"dunder\" names. These names are "
"defined by the interpreter and its implementation (including the standard "
"library). Current system names are discussed in the :ref:`specialnames` "
"section and elsewhere. More will likely be defined in future versions of "
"Python.  *Any* use of ``__*__`` names, in any context, that does not follow "
"explicitly documented use, is subject to breakage without warning."
msgstr ""
"システムで定義された (system-defined) 名前です。非公式には\"dunder\"な名前と"
"呼ばれます(訳注: double underscoresの略)。これらの名前はインタープリタと (標"
"準ライブラリを含む) 実装上で定義されています。 現行のシステムでの名前は :ref:"
"`specialnames` などで話題に挙げられています。 Python の将来のバージョンではよ"
"り多くの名前が定義されることになります。このドキュメントで明記されている用法"
"に従わない、 *あらゆる* ``__*__`` の名前は、いかなるコンテキストにおける利用"
"でも、警告無く損害を引き起こすことがあります。 "

#: ../../reference/lexical_analysis.rst:423
msgid "``__*``"
msgstr "``__*``"

#: ../../reference/lexical_analysis.rst:419
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""
"クラスプライベート (class-private) な名前です。このカテゴリに属する名前は、ク"
"ラス定義のコンテキスト上で用いられた場合、基底クラスと派生クラスの \"プライ"
"ベートな\" 属性間で名前衝突が起こるのを防ぐために書き直されます。 :ref:`atom-"
"identifiers` を参照してください。"

#: ../../reference/lexical_analysis.rst:428
msgid "Literals"
msgstr "リテラル"

#: ../../reference/lexical_analysis.rst:432
msgid "Literals are notations for constant values of some built-in types."
msgstr ""
"リテラル (literal) とは、いくつかの組み込み型の定数を表記したものです。"

#: ../../reference/lexical_analysis.rst:443
msgid "String and Bytes literals"
msgstr "文字列およびバイト列リテラル"

#: ../../reference/lexical_analysis.rst:445
msgid "String literals are described by the following lexical definitions:"
msgstr "文字列リテラルは以下の字句定義で記述されます:"

#: ../../reference/lexical_analysis.rst:470
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`~python-grammar:stringprefix` "
"or :token:`~python-grammar:bytesprefix` and the rest of the literal. The "
"source character set is defined by the encoding declaration; it is UTF-8 if "
"no encoding declaration is given in the source file; see section :ref:"
"`encodings`."
msgstr ""

#: ../../reference/lexical_analysis.rst:480
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*).  The backslash (``\\``) character "
"is used to escape characters that otherwise have a special meaning, such as "
"newline, backslash itself, or the quote character."
msgstr ""
"より平易な説明: これらの型のリテラルは、対応する一重引用符 (``'``) または二重"
"引用符 (``\"``) で囲われます。また、対応する三連の一重引用符や二重引用符で囲"
"うこともできます  (通常、*三重クオート文字列: triple-quoted string* と呼ばれ"
"ます)。バックスラッシュ (``\\``) 文字で、本来特別な意味を持つ文字、例えば改行"
"文字、バックスラッシュ自身、クオート文字などを、エスケープできます。"

#: ../../reference/lexical_analysis.rst:491
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""
"バイト列リテラルには、常に ``'b'`` や ``'B'`` が接頭します。これらによっ"
"て、 :class:`str` 型ではなく :class:`bytes` 型のインスタンスが作成されます。"
"バイト列リテラルは ASCII 文字のみ含むことができます。 128 以上の数値を持つバ"
"イトはエスケープして表されなければなりません。"

#: ../../reference/lexical_analysis.rst:500
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially. "
"Given that Python 2.x's raw unicode literals behave differently than Python "
"3.x's the ``'ur'`` syntax is not supported."
msgstr ""
"文字列リテラルとバイト列リテラルの両方は、任意で文字 ``'r'`` または ``'R'`` "
"をプレフィックスに持つことができます; そのような文字列は :dfn:`raw strings` "
"と呼ばれ、バックスラッシュをリテラル文字として扱います。その結果、文字列リテ"
"ラルでは raw 文字列中の ``'\\U'`` と ``'\\u'`` のエスケープは特別扱いされませ"
"ん。 Python 2.x の raw unicode リテラルが Python 3.x とは異なる振る舞いをする"
"ため、 ``'ur'`` 構文はサポートされません。"

#: ../../reference/lexical_analysis.rst:507
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr ""
"raw バイト列リテラルの ``'rb'`` プレフィックスが ``'br'`` の同義語として追加"
"されました。"

#: ../../reference/lexical_analysis.rst:511
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See :pep:"
"`414` for more information."
msgstr ""
"Python 2.x と 3.x 両対応のコードベースのメンテナンスを単純化するために、レガ"
"シー unicode リテラル (``u'value'``) のサポートが再び導入されました。詳細は :"
"pep:`414` を参照してください。"

#: ../../reference/lexical_analysis.rst:520
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a :dfn:`formatted "
"string literal`; see :ref:`f-strings`.  The ``'f'`` may be combined with "
"``'r'``, but not with ``'b'`` or ``'u'``, therefore raw formatted strings "
"are possible, but formatted bytes literals are not."
msgstr ""
"``'f'`` または ``'F'`` の接頭辞が付いた文字列リテラルはフォーマット済み文字列"
"リテラル（ :dfn:`formatted string literal` ）です。詳細については :ref:`"
"フォーマット済み文字列リテラル <f-strings>` を参照してください。接頭辞の "
"``'f'`` は ``'r'`` と組み合わせられますが、 ``'b'`` や ``'u'`` と組み合わせる"
"ことはできません。つまりフォーマット済みの raw 文字列リテラルは可ですが、"
"フォーマット済みのバイト列リテラルは不可です。"

#: ../../reference/lexical_analysis.rst:525
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and "
"are retained), except that three unescaped quotes in a row terminate the "
"literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""
"三重クオートリテラル中には、三連のエスケープされないクオート文字でリテラルを"
"終端してしまわないかぎり、エスケープされていない改行やクオートを書くことがで"
"きます (さらに、それらはそのまま文字列中に残ります)。(ここでいう \"クオート"
"\" とは、文字列の囲みを開始するときに使った文字を示し、``'`` か ``\"`` のいず"
"れかです。)"

#: ../../reference/lexical_analysis.rst:544
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""
"``'r'`` または ``'R'`` 接頭文字がつかないかぎり、文字列またはバイト列リテラル"
"中のエスケープシーケンスは標準 C で使われているのと同様の法則にしたがって解釈"
"されます。以下に Python で認識されるエスケープシーケンスを示します:"

#: ../../reference/lexical_analysis.rst:549
#: ../../reference/lexical_analysis.rst:582
msgid "Escape Sequence"
msgstr "エスケープシーケンス"

#: ../../reference/lexical_analysis.rst:549
#: ../../reference/lexical_analysis.rst:582
msgid "Meaning"
msgstr "意味"

#: ../../reference/lexical_analysis.rst:549
#: ../../reference/lexical_analysis.rst:582
msgid "Notes"
msgstr "注釈"

#: ../../reference/lexical_analysis.rst:551
msgid "``\\``\\ <newline>"
msgstr ""

#: ../../reference/lexical_analysis.rst:551
msgid "Backslash and newline ignored"
msgstr "バックスラッシュと改行文字が無視されます"

#: ../../reference/lexical_analysis.rst:551
msgid "\\(1)"
msgstr "\\(1)"

#: ../../reference/lexical_analysis.rst:553
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../../reference/lexical_analysis.rst:553
msgid "Backslash (``\\``)"
msgstr "バックスラッシュ (``\\``)"

#: ../../reference/lexical_analysis.rst:555
msgid "``\\'``"
msgstr "``\\'``"

#: ../../reference/lexical_analysis.rst:555
msgid "Single quote (``'``)"
msgstr "一重引用符 (``'``)"

#: ../../reference/lexical_analysis.rst:557
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../../reference/lexical_analysis.rst:557
msgid "Double quote (``\"``)"
msgstr "二重引用符 (``\"``)"

#: ../../reference/lexical_analysis.rst:559
msgid "``\\a``"
msgstr "``\\a``"

#: ../../reference/lexical_analysis.rst:559
msgid "ASCII Bell (BEL)"
msgstr "ASCII 端末ベル (BEL)"

#: ../../reference/lexical_analysis.rst:561
msgid "``\\b``"
msgstr "``\\b``"

#: ../../reference/lexical_analysis.rst:561
msgid "ASCII Backspace (BS)"
msgstr "ASCII バックスペース (BS)"

#: ../../reference/lexical_analysis.rst:563
msgid "``\\f``"
msgstr "``\\f``"

#: ../../reference/lexical_analysis.rst:563
msgid "ASCII Formfeed (FF)"
msgstr "ASCII フォームフィード (FF)"

#: ../../reference/lexical_analysis.rst:565
msgid "``\\n``"
msgstr "``\\n``"

#: ../../reference/lexical_analysis.rst:565
msgid "ASCII Linefeed (LF)"
msgstr "ASCII 行送り (LF)"

#: ../../reference/lexical_analysis.rst:567
msgid "``\\r``"
msgstr "``\\r``"

#: ../../reference/lexical_analysis.rst:567
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII 復帰 (CR)"

#: ../../reference/lexical_analysis.rst:569
msgid "``\\t``"
msgstr "``\\t``"

#: ../../reference/lexical_analysis.rst:569
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII 水平タブ (TAB)"

#: ../../reference/lexical_analysis.rst:571
msgid "``\\v``"
msgstr "``\\v``"

#: ../../reference/lexical_analysis.rst:571
msgid "ASCII Vertical Tab (VT)"
msgstr "ASCII 垂直タブ (VT)"

#: ../../reference/lexical_analysis.rst:573
msgid "``\\ooo``"
msgstr "``\\ooo``"

#: ../../reference/lexical_analysis.rst:573
msgid "Character with octal value *ooo*"
msgstr "8 進数値 *ooo* を持つ文字"

#: ../../reference/lexical_analysis.rst:573
msgid "(2,4)"
msgstr ""

#: ../../reference/lexical_analysis.rst:576
msgid "``\\xhh``"
msgstr "``\\xhh``"

#: ../../reference/lexical_analysis.rst:576
msgid "Character with hex value *hh*"
msgstr "16 進数値 *hh* を持つ文字"

#: ../../reference/lexical_analysis.rst:576
msgid "(3,4)"
msgstr ""

#: ../../reference/lexical_analysis.rst:579
msgid "Escape sequences only recognized in string literals are:"
msgstr "文字列でのみ認識されるエスケープシーケンスは以下のとおりです:"

#: ../../reference/lexical_analysis.rst:584
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: ../../reference/lexical_analysis.rst:584
msgid "Character named *name* in the Unicode database"
msgstr "Unicode データベース中で *name* という名前の文字"

#: ../../reference/lexical_analysis.rst:584
msgid "\\(5)"
msgstr "\\(5)"

#: ../../reference/lexical_analysis.rst:587
msgid "``\\uxxxx``"
msgstr "``\\uxxxx``"

#: ../../reference/lexical_analysis.rst:587
msgid "Character with 16-bit hex value *xxxx*"
msgstr "16-bit の十六進値 *xxxx* を持つ文字"

#: ../../reference/lexical_analysis.rst:587
msgid "\\(6)"
msgstr "\\(6)"

#: ../../reference/lexical_analysis.rst:590
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxx``"

#: ../../reference/lexical_analysis.rst:590
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr "32-bit の十六進値 *xxxxxxxx* を持つ文字"

#: ../../reference/lexical_analysis.rst:590
msgid "\\(7)"
msgstr "\\(7)"

#: ../../reference/lexical_analysis.rst:594
msgid "Notes:"
msgstr "注釈:"

#: ../../reference/lexical_analysis.rst:597
msgid "A backslash can be added at the end of a line to ignore the newline::"
msgstr ""

#: ../../reference/lexical_analysis.rst:603
msgid ""
"The same result can be achieved using :ref:`triple-quoted strings "
"<strings>`, or parentheses and :ref:`string literal concatenation <string-"
"concatenation>`."
msgstr ""

#: ../../reference/lexical_analysis.rst:608
msgid "As in Standard C, up to three octal digits are accepted."
msgstr "標準 C と同じく、最大で 3 桁の 8 進数まで受理します。"

#: ../../reference/lexical_analysis.rst:610
msgid ""
"Octal escapes with value larger than ``0o377`` produce a :exc:"
"`DeprecationWarning`. In a future Python version they will be a :exc:"
"`SyntaxWarning` and eventually a :exc:`SyntaxError`."
msgstr ""

#: ../../reference/lexical_analysis.rst:616
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr "標準 C とは違い、ちょうど 2 桁の 16 進数しか受理されません。"

#: ../../reference/lexical_analysis.rst:619
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr ""
"バイト列リテラル中では、十六進および八進エスケープは与えられた値のバイトを表"
"します。文字列リテラル中では、エスケープ文字は与えられた値を持つ Unicode 文字"
"を表します。"

#: ../../reference/lexical_analysis.rst:624
msgid "Support for name aliases [#]_ has been added."
msgstr "name aliases [#]_ に対するサポートが追加されました。"

#: ../../reference/lexical_analysis.rst:628
msgid "Exactly four hex digits are required."
msgstr "ちょうど 4 桁の 16 進数しか受理されません。"

#: ../../reference/lexical_analysis.rst:631
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits are "
"required."
msgstr ""
"あらゆるユニコード文字はこのようにしてエンコードすることができます。正確に8文"
"字の16進数字が必要です。"

#: ../../reference/lexical_analysis.rst:637
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the result*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""
"標準の C とは違い、認識されなかったエスケープシーケンスはすべて、そのまま文字"
"列中に残ります。すなわち、*バックスラッシュも結果中に残ります*。(この挙動はデ"
"バッグの際に便利です: エスケープシーケンスが誤入力されたら、その出力結果が失"
"敗しているのが分かりやすくなります。) 文字列中でのみ認識されるエスケープシー"
"ケンスは、バイト列リテラルには、認識されないエスケープシーケンスとして分類さ"
"れるので注意してください。"

#: ../../reference/lexical_analysis.rst:644
msgid ""
"Unrecognized escape sequences produce a :exc:`DeprecationWarning`.  In a "
"future Python version they will be a :exc:`SyntaxWarning` and eventually a :"
"exc:`SyntaxError`."
msgstr ""
"認識されなかったエスケープシーケンスは :exc:`DeprecationWarning` を生成しま"
"す。これは将来のバージョンでは :exc:`SyntaxWarning` になり、いずれ :exc:"
"`SyntaxError` になります。"

#: ../../reference/lexical_analysis.rst:649
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""
"raw リテラルでも、引用符はバックスラッシュでエスケープできますが、バックス"
"ラッシュ自体も文字列に残ります; 例えば、``r\"\\\"\"`` は有効な文字列リテラル"
"で、バックスラッシュと二重引用符からなる文字列を表します; ``r\"\\\"`` は無効"
"な文字列リテラルです (raw リテラルを奇数個連なったバックスラッシュで終わらせ"
"ることはできません)。具体的には、(バックスラッシュが直後のクオート文字をエス"
"ケープしてしまうので)  *raw文字列を単一のバックスラッシュで終わらせることはで"
"きません* さらに、バックスラッシュの直後に改行がきても、行継続を意味する *の"
"ではなく*、リテラルの一部であるそれら二つの文字として解釈されます。"

#: ../../reference/lexical_analysis.rst:662
msgid "String literal concatenation"
msgstr "文字列リテラルの結合 (concatenation)"

#: ../../reference/lexical_analysis.rst:664
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long "
"lines, or even to add comments to parts of strings, for example::"
msgstr ""
"文字列やバイト列リテラルは、互いに異なる引用符を使っていても (空白文字で区"
"切っても) 複数隣接させることができます。これは各々の文字列を結合するのと同じ"
"意味を持ちます。したがって、``\"hello\" 'world'`` は ``\"helloworld\"`` と同"
"じです。この機能を使うと、バックスラッシュを減らしたり、長い文字列を手軽に分"
"離して複数行にまたがらせたり、あるいは部分文字列ごとにコメントを追加すること"
"さえできます。例えば::"

#: ../../reference/lexical_analysis.rst:675
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings), and formatted string literals may be concatenated "
"with plain string literals."
msgstr ""
"この機能は文法レベルで定義されていますが、スクリプトをコンパイルする際の処理"
"として実現されることに注意してください。実行時に文字列表現を結合したければ、 "
"'+' 演算子を使わなければなりません。また、リテラルの結合においては、結合する"
"各要素に異なる引用符形式を使ったり (raw 文字列と三重引用符を混ぜることさえで"
"きます) 、フォーマット済み文字列リテラルと通常の文字列リテラルを結合したりす"
"ることもできますので注意してください。"

#: ../../reference/lexical_analysis.rst:696
msgid "Formatted string literals"
msgstr "フォーマット済み文字列リテラル"

#: ../../reference/lexical_analysis.rst:700
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces ``{}``. "
"While other string literals always have a constant value, formatted strings "
"are really expressions evaluated at run time."
msgstr ""
"フォーマット済み文字列リテラル（ :dfn:`formatted string literal` ）または :"
"dfn:`f-string` は、接頭辞 ``'f'`` または ``'F'`` の付いた文字列リテラルです。"
"これらの文字列には、波括弧 ``{}`` で区切られた式である置換フィールドを含める"
"ことができます。他の文字列リテラルの場合は内容が常に一定で変わることが無いの"
"に対して、フォーマット済み文字列リテラルは実行時に式として評価されます。"

#: ../../reference/lexical_analysis.rst:706
msgid ""
"Escape sequences are decoded like in ordinary string literals (except when a "
"literal is also marked as a raw string).  After decoding, the grammar for "
"the contents of the string is:"
msgstr ""
"エスケープシーケンスは通常の文字列リテラルと同様にデコードされます (ただしリ"
"テラルが raw 文字列でもある場合は除きます) 。エスケープシーケンスをデコードし"
"た後は、文字列の内容は次の文法で解釈されます:"

#: ../../reference/lexical_analysis.rst:720
msgid ""
"The parts of the string outside curly braces are treated literally, except "
"that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced with the "
"corresponding single curly brace.  A single opening curly bracket ``'{'`` "
"marks a replacement field, which starts with a Python expression. To display "
"both the expression text and its value after evaluation, (useful in "
"debugging), an equal sign ``'='`` may be added after the expression. A "
"conversion field, introduced by an exclamation point ``'!'`` may follow.  A "
"format specifier may also be appended, introduced by a colon ``':'``. A "
"replacement field ends with a closing curly bracket ``'}'``."
msgstr ""
"文字列のうち、波括弧で囲まれた部分以外は文字通り解釈されます。ただし、二重波"
"括弧 ``'{{'`` および ``'}}'`` は単一の波括弧に置き換えられます。単一の開き波"
"括弧 ``'{'`` は置換フィールドの始まりを意味し、その中身は Python の式で始まり"
"ます。(デバッグ時に便利な機能として) 式のテキストと、評価後の値との両者を表示"
"したい場合には、式の後に等号 ``'='`` を加えてください。その後ろには、感嘆符 "
"``'!'`` によって導入される変換フィールドを続けることができます。さらに、"
"``':'`` に続いて書式指定子を追加できます。置換フィールドは単一の閉じ波括弧 "
"``'}'`` で終わります。"

#: ../../reference/lexical_analysis.rst:730
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and both :keyword:`lambda`  and assignment "
"expressions ``:=`` must be surrounded by explicit parentheses. Replacement "
"expressions can contain line breaks (e.g. in triple-quoted strings), but "
"they cannot contain comments.  Each expression is evaluated in the context "
"where the formatted string literal appears, in order from left to right."
msgstr ""
"フォーマット済文字列リテラルの中に現れる式は、括弧で囲まれた通常の Python の"
"式のように扱われますが、いくつかの例外があります。まず、空の式は許されませ"
"ん。そして、:keyword:`lambda` 式および代入式 ``:=`` は明示的に括弧で囲む必要"
"があります。置換フィールド内の式 (replacement expressions) は (例えば、三重ク"
"オート文字列などを用いて) 改行を含むことができますが、コメントを含むことはで"
"きません。フォーマット済文字列リテラル内の式は、当該リテラルが出現するコンテ"
"キストで、左から右の順で評価されます。"

#: ../../reference/lexical_analysis.rst:739
msgid ""
"Prior to Python 3.7, an :keyword:`await` expression and comprehensions "
"containing an :keyword:`async for` clause were illegal in the expressions in "
"formatted string literals due to a problem with the implementation."
msgstr ""
"Python 3.7 より前のバージョンでは、:keyword:`await` 式および :keyword:`async "
"for` 句を含む内包表記は、実装に伴う問題の都合により許されていませんでした。"

#: ../../reference/lexical_analysis.rst:744
msgid ""
"When the equal sign ``'='`` is provided, the output will have the expression "
"text, the ``'='`` and the evaluated value. Spaces after the opening brace "
"``'{'``, within the expression and after the ``'='`` are all retained in the "
"output. By default, the ``'='`` causes the :func:`repr` of the expression to "
"be provided, unless there is a format specified. When a format is specified "
"it defaults to the :func:`str` of the expression unless a conversion ``'!"
"r'`` is declared."
msgstr ""
"等号 ``'='`` が指定されたとき、出力文字列は、式のテキスト表現、等号 ``'='``、"
"および評価された式を含みます。開き波括弧 ``'{'`` の直後、式の中、および "
"``'='`` の後に含まれる空白文字はすべて保存されます。書式指定子が存在しない限"
"り、``'='`` を指定した場合は、式に対して :func:`repr` を適用した結果が出力に"
"なります。一方、書式指定子が存在する場合は、変換フィールドで ``'!r'`` が指定"
"されていない限り、デフォルトで :func:`str` が適用されます。"

#: ../../reference/lexical_analysis.rst:752
msgid "The equal sign ``'='``."
msgstr "等号 ``'='``。"

#: ../../reference/lexical_analysis.rst:755
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on the "
"result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`."
msgstr ""
"もし変換フィールドが指定されていた場合、式の評価結果はフォーマットの前に変換"
"されます。変換 ``'!s'`` は :func:`str` を、 ``'!r'`` は :func:`repr` を、そし"
"て ``'!a'`` は :func:`ascii` を呼び出します。"

#: ../../reference/lexical_analysis.rst:759
msgid ""
"The result is then formatted using the :func:`format` protocol.  The format "
"specifier is passed to the :meth:`__format__` method of the expression or "
"conversion result.  An empty string is passed when the format specifier is "
"omitted.  The formatted result is then included in the final value of the "
"whole string."
msgstr ""
"その結果は、続いて :func:`format` のプロトコルでフォーマットされます。書式指"
"定子は式または変換結果の :meth:`__format__` メソッドに渡されます。書式指定子"
"が省略された場合は、空文字列が渡されます。そしてフォーマットされた結果は、文"
"字列全体の最終的な値に挿入されます。"

#: ../../reference/lexical_analysis.rst:765
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply nested replacement "
"fields. The :ref:`format specifier mini-language <formatspec>` is the same "
"as that used by the :meth:`str.format` method."
msgstr ""

#: ../../reference/lexical_analysis.rst:771
msgid ""
"Formatted string literals may be concatenated, but replacement fields cannot "
"be split across literals."
msgstr ""
"フォーマット済み文字列リテラルは他の文字列リテラルと結合できますが、置換"
"フィールドを複数のリテラルに分割して書くことはできません。"

#: ../../reference/lexical_analysis.rst:774
msgid "Some examples of formatted string literals::"
msgstr "フォーマット済み文字列リテラルの例をいくつか挙げます::"

#: ../../reference/lexical_analysis.rst:806
msgid ""
"A consequence of sharing the same syntax as regular string literals is that "
"characters in the replacement fields must not conflict with the quoting used "
"in the outer formatted string literal::"
msgstr ""
"通常の文字列リテラルと構文が共通なので（訳註：通常の文字列リテラルにおける引"
"用符の扱いと同様に）、置換フィールド中に、外側のフォーマット済み文字列リテラ"
"ルで使われている引用符を含めることはできません::"

#: ../../reference/lexical_analysis.rst:813
msgid ""
"Backslashes are not allowed in format expressions and will raise an error::"
msgstr "式の中でバックスラッシュは使用できず、エラーを送出します::"

#: ../../reference/lexical_analysis.rst:818
msgid ""
"To include a value in which a backslash escape is required, create a "
"temporary variable."
msgstr ""
"バックスラッシュでのエスケープが必要な値を含める必要がある場合は、一時変数を"
"作成してください。"

#: ../../reference/lexical_analysis.rst:825
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do not "
"include expressions."
msgstr ""
"フォーマット済み文字列リテラルは、たとえ式を含んでいなかったとしても、 "
"docstring としては使えません。"

#: ../../reference/lexical_analysis.rst:836
msgid ""
"See also :pep:`498` for the proposal that added formatted string literals, "
"and :meth:`str.format`, which uses a related format string mechanism."
msgstr ""
"フォーマット済み文字列リテラルを Python に追加した提案 :pep:`498` も参照して"
"ください。また関連する文字列フォーマットの仕組みを使っている :meth:`str."
"format` も参照してください。"

#: ../../reference/lexical_analysis.rst:843
msgid "Numeric literals"
msgstr "数値リテラル"

#: ../../reference/lexical_analysis.rst:849
msgid ""
"There are three types of numeric literals: integers, floating point numbers, "
"and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr ""
"数値リテラルには 3 種類あります。整数 (integer)、浮動小数点数 (floating "
"point number)、虚数(imaginary numbers) です。複素数リテラルは存在しません。"
"(複素数は実数と虚数の和として作れます)。"

#: ../../reference/lexical_analysis.rst:853
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""
"数値リテラルには符号が含まれていないことに注意してください; ``-1`` のような句"
"は、実際には単項演算子 (unary operator) '``-``' とリテラル ``1`` を組み合わせ"
"たものです。"

#: ../../reference/lexical_analysis.rst:867
msgid "Integer literals"
msgstr "整数リテラル"

#: ../../reference/lexical_analysis.rst:869
msgid "Integer literals are described by the following lexical definitions:"
msgstr "整数リテラルは以下の字句定義で記述されます:"

#: ../../reference/lexical_analysis.rst:883
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr ""
"値がメモリ上に収まるかどうかという問題を除けば、整数リテラルには長さの制限が"
"ありません。"

#: ../../reference/lexical_analysis.rst:886
msgid ""
"Underscores are ignored for determining the numeric value of the literal.  "
"They can be used to group digits for enhanced readability.  One underscore "
"can occur between digits, and after base specifiers like ``0x``."
msgstr ""
"アンダースコアはリテラルの値を判断するにあたって無視されます。そのためアン"
"ダースコアを使って数字をグループ化することで読みやすくできます。アンダースコ"
"アは数字と数字の間に 1 つだけ、あるいは ``0x`` のような基数指定の直後に 1 つ"
"だけ挿入できます。"

#: ../../reference/lexical_analysis.rst:890
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr ""
"なお、非 0 の十進数の先頭には 0 を付けられません。これは、Python がバージョ"
"ン 3.0 以前に使っていた C 形式の八進リテラルとの曖昧さを回避するためです。"

#: ../../reference/lexical_analysis.rst:894
msgid "Some examples of integer literals::"
msgstr "整数リテラルの例をいくつか示します::"

#: ../../reference/lexical_analysis.rst:900
#: ../../reference/lexical_analysis.rst:932
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr ""
"グループ化を目的としたリテラル中のアンダースコアが許されるようになりました。"

#: ../../reference/lexical_analysis.rst:911
msgid "Floating point literals"
msgstr "浮動小数点数リテラル"

#: ../../reference/lexical_analysis.rst:913
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr "浮動小数点数リテラルは以下の字句定義で記述されます:"

#: ../../reference/lexical_analysis.rst:923
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating point literals is implementation-"
"dependent.  As in integer literals, underscores are supported for digit "
"grouping."
msgstr ""
"なお、整数部と指数部は常に 10 を基数として解釈されます。例えば、``077e010`` "
"は正しい表記であり、``77e10`` と同じ数を表します。浮動小数点数リテラルの取り"
"うる値の範囲は実装に依存します。整数リテラルと同じように、アンダースコアで数"
"字をグループ分けできます。"

#: ../../reference/lexical_analysis.rst:928
msgid "Some examples of floating point literals::"
msgstr "浮動小数点数リテラルの例をいくつか示します::"

#: ../../reference/lexical_analysis.rst:941
msgid "Imaginary literals"
msgstr "虚数 (imaginary) リテラル"

#: ../../reference/lexical_analysis.rst:943
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr "虚数リテラルは以下のような字句定義で記述されます:"

#: ../../reference/lexical_analysis.rst:948
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""
"虚数リテラルは、実数部が 0.0 の複素数を表します。複素数は二つ組の浮動小数点型"
"の数値で表され、それぞれの数値は浮動小数点型と同じ定義域の範囲を持ちます。実"
"数部がゼロでない浮動小数点を生成するには、 ``(3+4j)`` のように虚数リテラルに"
"浮動小数点数を加算します。以下に虚数リテラルの例をいくつか示します::"

#: ../../reference/lexical_analysis.rst:960
msgid "Operators"
msgstr "演算子"

#: ../../reference/lexical_analysis.rst:964
msgid "The following tokens are operators:"
msgstr "以下のトークンは演算子です:"

#: ../../reference/lexical_analysis.rst:977
msgid "Delimiters"
msgstr "デリミタ (delimiter)"

#: ../../reference/lexical_analysis.rst:981
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "以下のトークンは文法上のデリミタとして働きます:"

#: ../../reference/lexical_analysis.rst:990
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically "
"as delimiters, but also perform an operation."
msgstr ""
"ピリオドは浮動小数点数や虚数リテラル中にも置けます。ピリオド三つの列はスライ"
"ス表記における省略符号 (ellipsis) リテラルとして特別な意味を持ちます。リスト"
"後半の累算代入演算子 (augmented assignment operator) は、字句的にはデリミタと"
"して振舞いますが、演算も行います。"

#: ../../reference/lexical_analysis.rst:995
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr ""
"以下の印字可能 ASCII 文字は、他のトークンの一部として特殊な意味を持っていた"
"り、字句解析器にとって重要な意味を持っています:"

#: ../../reference/lexical_analysis.rst:1002
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr ""
"以下の印字可能 ASCII 文字は、Python では使われていません。これらの文字が文字"
"列リテラルやコメントの外にある場合、無条件にエラーとなります:"

#: ../../reference/lexical_analysis.rst:1011
msgid "Footnotes"
msgstr "脚注"

#: ../../reference/lexical_analysis.rst:1012
msgid "https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
msgstr "https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
