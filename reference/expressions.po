# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# tomo, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:22+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/expressions.rst:6
msgid "Expressions"
msgstr "式 (expression)"

#: ../../reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr "この章では、Python の式における個々の要素の意味について解説します。"

#: ../../reference/expressions.rst:14
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""
"**表記法に関する注意:** この章と以降の章での拡張BNF (extended BNF) 表記は、字"
"句解析規則ではなく、構文規則を記述するために用いられています。ある構文規則 "
"(のある表現方法) が、以下の形式"

#: ../../reference/expressions.rst:23
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""
"で記述されていて、この構文特有の意味付け (semantics) が記述されていない場"
"合、 ``name`` の形式をとる構文の意味付けは ``othername`` の意味付けと同じにな"
"ります。"

#: ../../reference/expressions.rst:30
msgid "Arithmetic conversions"
msgstr "算術変換 (arithmetic conversion)"

#: ../../reference/expressions.rst:34
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type,\" the arguments are "
"coerced using the coercion rules listed at  :ref:`coercion-rules`.  If both "
"arguments are standard numeric types, the following coercions are applied:"
msgstr ""
"以下の算術演算子の記述で、「数値引数は共通の型に変換されます」と書かれている"
"場合、引数は :ref:`coercion-rules` に記載されている型強制規則に基づいて型強制"
"されます。引数がいずれも標準の数値型である場合、以下の型強制が適用されます:"

#: ../../reference/expressions.rst:39
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr "片方の引数が複素数型であれば、他方は複素数型に変換されます;"

#: ../../reference/expressions.rst:41
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr ""
"それ以外の場合で、片方の引数が浮動小数点数であれば、他方は浮動小数点型に変換"
"されます;"

#: ../../reference/expressions.rst:44
msgid ""
"otherwise, if either argument is a long integer, the other is converted to "
"long integer;"
msgstr ""
"それ以外の場合で、片方の引数が長整数型であれば、他方は長整数型に変換されます;"

#: ../../reference/expressions.rst:47
msgid "otherwise, both must be plain integers and no conversion is necessary."
msgstr ""
"それ以外の場合で、両方の引数が通常の整数型であれば、変換の必要はありません。"

#: ../../reference/expressions.rst:49
msgid ""
"Some additional rules apply for certain operators (e.g., a string left "
"argument to the '%' operator). Extensions can define their own coercions."
msgstr ""
"特定の演算子 (文字列を左引数とする '%' 演算子など) では、さらに別の規則が適用"
"されます。拡張をおこなうことで、個々の演算子に対する型強制を定義できます。"

#: ../../reference/expressions.rst:56
msgid "Atoms"
msgstr "アトム、原子的要素 (atom)"

#: ../../reference/expressions.rst:60
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in reverse quotes or in "
"parentheses, brackets or braces are also categorized syntactically as "
"atoms.  The syntax for atoms is:"
msgstr ""
"アトム (原子的要素: atom) は、式を構成する基本単位です。もっとも単純なアトム"
"は、識別子またはリテラルになります。逆クオートや丸括弧、波括弧、または角括弧"
"で囲われた形式 (form) もまた、文法的にはアトムに分類されます。アトムの構文定"
"義は以下のようになります:"

#: ../../reference/expressions.rst:75
msgid "Identifiers (Names)"
msgstr "識別子 (identifier、または名前 (name))"

#: ../../reference/expressions.rst:81
msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""
"アトムの形になっている識別子 (identifier) は名前 (name) です。字句定義につい"
"ては :ref:`identifiers` 節を、名前付けや束縛については :ref:`naming` 節を参照"
"してください。"

#: ../../reference/expressions.rst:87
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr ""
"名前があるオブジェクトに束縛されている場合、名前 atom を評価するとそのオブ"
"ジェクトになります。名前が束縛されていない場合、 atom を評価しようとすると :"
"exc:`NameError` 例外を送出します。"

#: ../../reference/expressions.rst:95
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name, with leading "
"underscores removed and a single underscore inserted, in front of the name.  "
"For example, the identifier ``__spam`` occurring in a class named ``Ham`` "
"will be transformed to ``_Ham__spam``.  This transformation is independent "
"of the syntactical context in which the identifier is used.  If the "
"transformed name is extremely long (longer than 255 characters), "
"implementation defined truncation may happen. If the class name consists "
"only of underscores, no transformation is done."
msgstr ""
"**プライベートな名前の名前修飾:** クラス定義内に書かれた識別子で、2つ以上のア"
"ンダースコアから始まり、末尾が2つ以上のアンダースコアで終わっていないものは、"
"そのクラスの :dfn:`プライベートな名前` とみなされます。プライベートな名前は、"
"コードが生成される前により長い形式に変換されます。この変換によって、クラス名"
"の先頭にアンダースコアがあれば除去し、先頭にアンダースコアを1つ付加し、名前の"
"前に挿入されます。例えば、クラス名 ``Ham`` の中の識別子 ``__spam`` は、"
"``_Ham__spam`` に変換されます。変換は識別子が使用されている構文のコンテキスト"
"からは独立しています。変換された名前が非常に長い (255文字を超える) 場合、実装"
"によっては名前の切り詰めが行われるかもしれません。クラス名がアンダースコアの"
"みから成る場合は変換は行われません。"

#: ../../reference/expressions.rst:112
msgid "Literals"
msgstr "リテラル"

#: ../../reference/expressions.rst:116
msgid "Python supports string literals and various numeric literals:"
msgstr "Python では、文字列リテラルと、様々な数値リテラルをサポートしています:"

#: ../../reference/expressions.rst:122
msgid ""
"Evaluation of a literal yields an object of the given type (string, integer, "
"long integer, floating point number, complex number) with the given value.  "
"The value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""
"リテラルを評価すると、指定した型 (文字列、整数、長整数、浮動小数点数、複素"
"数) の指定した値を持つオブジェクトになります。浮動小数点や虚数 (複素数) リテ"
"ラルの場合、値は近似値になる場合があります。詳しくは :ref:`literals` を参照し"
"てください。"

#: ../../reference/expressions.rst:131
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals "
"with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""
"リテラルは全て変更不能なデータ型に対応します。このため、オブジェクトのアイデ"
"ンティティはオブジェクトの値ほど重要ではありません。同じ値を持つ複数のリテラ"
"ルを評価した場合、(それらのリテラルがプログラムの同じ場所由来のものであって"
"も、そうでなくても) 同じオブジェクトを指しているか、まったく同じ値を持つ別の"
"オブジェクトになります。"

#: ../../reference/expressions.rst:141
msgid "Parenthesized forms"
msgstr "丸括弧形式 (parenthesized form)"

#: ../../reference/expressions.rst:145
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr "丸括弧形式とは、式リストの一形態で、丸括弧で囲ったものです:"

#: ../../reference/expressions.rst:150
msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""
"丸括弧で囲われた式のリストは、個々の式が表現するものになります: リスト内に少"
"なくとも一つのカンマが入っていた場合、タプルになります; そうでない場合、式の"
"リストを構成している単一の式自体の値になります。"

#: ../../reference/expressions.rst:156
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the rules for literals apply (i.e., two occurrences of the empty "
"tuple may or may not yield the same object)."
msgstr ""
"中身が空の丸括弧のペアは、空のタプルオブジェクトを表します。タプルは変更不能"
"なので、リテラルと同じ規則が適用されます (すなわち、空のタプルが二箇所で使わ"
"れると、それらは同じオブジェクトになることもあるし、ならないこともあります)。"

#: ../../reference/expressions.rst:164
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma operator.  The exception is the empty tuple, for which parentheses "
"*are* required --- allowing unparenthesized \"nothing\" in expressions would "
"cause ambiguities and allow common typos to pass uncaught."
msgstr ""
"タプルは丸括弧で作成されるのではなく、カンマによって作成されることに注意して"
"ください。例外は空のタプルで、この場合には丸括弧が *必要です* --- 丸括弧のつ"
"かない \"何も記述しない式 (nothing)\" を使えるようにしてしまうと、文法があい"
"まいなものになってしまい、よくあるタイプミスが検出されなくなってしまいます。"

#: ../../reference/expressions.rst:173
msgid "List displays"
msgstr "リスト表現"

#: ../../reference/expressions.rst:179
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr ""
"リスト表現は、角括弧で囲われた式の系列です。系列は空の系列であってもかまいま"
"せん:"

#: ../../reference/expressions.rst:196
msgid ""
"A list display yields a new list object.  Its contents are specified by "
"providing either a list of expressions or a list comprehension.  When a "
"comma-separated list of expressions is supplied, its elements are evaluated "
"from left to right and placed into the list object in that order.  When a "
"list comprehension is supplied, it consists of a single expression followed "
"by at least one :keyword:`for` clause and zero or more :keyword:`for` or :"
"keyword:`if` clauses.  In this case, the elements of the new list are those "
"that would be produced by considering each of the :keyword:`for` or :keyword:"
"`if` clauses a block, nesting from left to right, and evaluating the "
"expression to produce a list element each time the innermost block is "
"reached [#]_."
msgstr ""
"リスト表現は、新に作成されたリストオブジェクトを表します。新たなリストの内容"
"は、式のリストを与えるか、リストの内包表記 (list comprehension) で指定しま"
"す。カンマで区切られた式のリストを与えた場合、リストの各要素は左から右へと順"
"に評価され、評価された順番にリスト内に配置されます。リストの内包表記を与える"
"場合、内包表記はまず単一の式、続いて少なくとも一つの :keyword:`for` 節、続い"
"てゼロ個以上の :keyword:`for` 節か :keyword:`if` 節になります。この場合、新た"
"に作成されるリストの各要素は、各々の :keyword:`for` や :keyword:`if` 節を左か"
"ら右の順にネストしたブロックとみなして実行し、ネストの最内ブロックに到達する"
"度に式を評価した値となります。 [#]_"

#: ../../reference/expressions.rst:211
msgid "Displays for sets and dictionaries"
msgstr "集合と辞書の表現"

#: ../../reference/expressions.rst:213
msgid ""
"For constructing a set or a dictionary Python provides special syntax called "
"\"displays\", each of them in two flavors:"
msgstr ""
"Python は、集合や辞書を構成するために、\"表現 (display)\" と呼ばれる特殊な構"
"文を、それぞれ二種類づつ提供していて、コンテナの内容は:"

#: ../../reference/expressions.rst:216
msgid "either the container contents are listed explicitly, or"
msgstr "明示的に列挙される、または"

#: ../../reference/expressions.rst:218
msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr ""
":dfn:`内包表記 (comprehension)` と呼ばれる、ループ処理とフィルター処理の命令"
"の組み合わせを通じて計算されます。"

#: ../../reference/expressions.rst:221
msgid "Common syntax elements for comprehensions are:"
msgstr "内包表記の共通の構文要素はこの通りです:"

#: ../../reference/expressions.rst:229
msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`for` clause and zero or more :keyword:`for` or :keyword:`if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`for` or :keyword:`if` "
"clauses a block, nesting from left to right, and evaluating the expression "
"to produce an element each time the innermost block is reached."
msgstr ""
"内包表記はまず単一の式、続いて :keyword:`for` 節、さらに続いて 0 個以上の :"
"keyword:`for` 節や :keyword:`if` 節からなります。この場合、新たなコンテナの各"
"要素は、各々の :keyword:`for` や :keyword:`if` 節を、左から右にネストしたブ"
"ロックとみなして実行し、ネストの最内のブロックに到達する度に式を評価すること"
"で作成されたものになります。"

#: ../../reference/expressions.rst:236
msgid ""
"Note that the comprehension is executed in a separate scope, so names "
"assigned to in the target list don't \"leak\" in the enclosing scope."
msgstr ""
"なお、これらの内包表記は別のスコープで実行されるので、対象のリスト内で代入さ"
"れた名前が外側のスコープに \"漏れる\" ことはありません。"

#: ../../reference/expressions.rst:243
msgid "Generator expressions"
msgstr "ジェネレータ式"

#: ../../reference/expressions.rst:248
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr ""
"ジェネレータ式 (generator expression) とは、丸括弧を使ったコンパクトなジェネ"
"レータ表記法です:"

#: ../../reference/expressions.rst:253
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""
"ジェネレータ式は新たなジェネレータオブジェクトを与えます。この構文は内包表記"
"とほぼ同じですが、角括弧や波括弧ではなく、丸括弧で囲まれます。"

#: ../../reference/expressions.rst:257
msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`__next__` method is called for generator object (in the same fashion "
"as normal generators).  However, the leftmost :keyword:`for` clause is "
"immediately evaluated, so that an error produced by it can be seen before "
"any other possible error in the code that handles the generator expression.  "
"Subsequent :keyword:`for` clauses cannot be evaluated immediately since they "
"may depend on the previous :keyword:`for` loop. For example: ``(x*y for x in "
"range(10) for y in bar(x))``."
msgstr ""
"ジェネレータ式で使われる変数は、ジェネレータオブジェクトに :meth:`next` メ"
"ソッドが呼び出されたときに遅延評価されます (通常のジェネレータと同じ流儀で"
"す)。しかし、最も左に位置する :keyword:`for` 節は直ちに評価されるため、そこで"
"生じたエラーは、ジェネレータ式を扱うコードで起こりえる他のエラーの前に現れる"
"ことがあります。その後に続く :keyword:`for` 節は、その前の :keyword:`for` "
"ループに依存しているため、直ちには評価されません。例: ``(x*y for x in "
"range(10) for y in bar(x))``"

#: ../../reference/expressions.rst:266
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for the detail."
msgstr ""
"関数の唯一の引数として渡す場合には、丸括弧を省略できます。詳しくは :ref:"
"`calls` 節を参照してください。"

#: ../../reference/expressions.rst:272
msgid "Dictionary displays"
msgstr "辞書表現"

#: ../../reference/expressions.rst:278
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs enclosed "
"in curly braces:"
msgstr ""
"辞書表現は、波括弧で囲われた、キーと値のペアからなる系列です。系列は空の系列"
"であってもかまいません:"

#: ../../reference/expressions.rst:287
msgid "A dictionary display yields a new dictionary object."
msgstr "辞書表現は、新たな辞書オブジェクトを表します。"

#: ../../reference/expressions.rst:289
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: each "
"key object is used as a key into the dictionary to store the corresponding "
"datum.  This means that you can specify the same key multiple times in the "
"key/datum list, and the final dictionary's value for that key will be the "
"last one given."
msgstr ""
"カンマ区切りの一連のキー/データの対が与えられたときは、その要素は左から右へ評"
"価され、辞書の項目を定義します。すなわち、それぞれのキーオブジェクトが、辞書"
"内で対応するデータを保存するキーとして使われます。これにより、キー/データリス"
"トの中で同じキーを複数回指定することができ、そのキーに対する最終的な辞書の値"
"は、最後に与えられたものになります。"

#: ../../reference/expressions.rst:295
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""
"辞書内包表記は、リストや集合の内包表記とは対照的に、通常の \"for\" や \"if\" "
"節の前に、コロンで分けられた 2 つの式が必要です。内包表記が起動すると、結果の"
"キーと値の要素が、作られた順に新しい辞書に挿入されます。"

#: ../../reference/expressions.rst:303
msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last datum (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""
"キーの値として使える型に関する制限は :ref:`types` 節ですでに列挙しています。"
"(一言でいうと、キーは変更可能なオブジェクトを全て排除した :term:`hashable` で"
"なければなりません。) 重複するキー間で衝突が起きても、衝突が検出されることは"
"ありません; あるキーに対して、最後に渡されたデータ (プログラムテキスト上で"
"は、辞書表記の最も右側値となるもの) が使われます。"

#: ../../reference/expressions.rst:313
msgid "Set displays"
msgstr "集合表現"

#: ../../reference/expressions.rst:318
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr ""
"集合表現は波括弧で表され、キーと値を分けるコロンがないことで辞書表現と区別さ"
"れます:"

#: ../../reference/expressions.rst:324
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"集合表示は、一連の式または内包表記によって指定された内容の、ミュータブルな集"
"合オブジェクトを与えます。カンマ区切りの一連の式が与えられたときは、その要素"
"は左から右へ順に評価され、集合オブジェクトに加えられます。内包表記が与えられ"
"たときは、内包表記の結果となる要素で集合が構成されます。"

#: ../../reference/expressions.rst:330
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr "空集合は ``{}`` で構成できません。このリテラルは空の辞書を構成します。"

#: ../../reference/expressions.rst:337
msgid "String conversions"
msgstr "文字列変換"

#: ../../reference/expressions.rst:345
msgid ""
"A string conversion is an expression list enclosed in reverse (a.k.a. "
"backward) quotes:"
msgstr ""
"文字列変換は、逆クオート (reverse quite, 別名バッククオート: backward quote) "
"で囲われた式のリストです:"

#: ../../reference/expressions.rst:351
msgid ""
"A string conversion evaluates the contained expression list and converts the "
"resulting object into a string according to rules specific to its type."
msgstr ""
"文字列変換は、逆クオート内の式リストを評価して、評価結果のオブジェクトを各オ"
"ブジェクトの型特有の規則に従って文字列に変換します。"

#: ../../reference/expressions.rst:354
msgid ""
"If the object is a string, a number, ``None``, or a tuple, list or "
"dictionary containing only objects whose type is one of these, the resulting "
"string is a valid Python expression which can be passed to the built-in "
"function :func:`eval` to yield an expression with the same value (or an "
"approximation, if floating point numbers are involved)."
msgstr ""
"オブジェクトが文字列、数値、 ``None`` か、それらの型のオブジェクトのみを含む"
"タプル、リストまたは辞書の場合、評価結果の文字列は有効な Python 式となり、組"
"み込み関数 :func:`eval` に渡した場合に同じ値となります (浮動小数点が含まれて"
"いる場合には近似値の場合もあります)。"

#: ../../reference/expressions.rst:360
msgid ""
"(In particular, converting a string adds quotes around it and converts "
"\"funny\" characters to escape sequences that are safe to print.)"
msgstr ""
"(特に、文字列を変換すると、値を安全に出力するために文字列の両側にクオートが付"
"けられ、\"変 (funny) な\" 文字はエスケープシーケンスに変換されます。)"

#: ../../reference/expressions.rst:365
msgid ""
"Recursive objects (for example, lists or dictionaries that contain a "
"reference to themselves, directly or indirectly) use ``...`` to indicate a "
"recursive reference, and the result cannot be passed to :func:`eval` to get "
"an equal value (:exc:`SyntaxError` will be raised instead)."
msgstr ""
"再帰的な構造をもつオブジェクト (例えば自分自身を直接または間接的に含むリスト"
"や辞書) では ``...`` を使って再帰的参照であることが示され、オブジェクトの評価"
"結果は :func:`eval` に渡しても等価な値を得ることができません (:exc:"
"`SyntaxError` が送出されます)。"

#: ../../reference/expressions.rst:374
msgid ""
"The built-in function :func:`repr` performs exactly the same conversion in "
"its argument as enclosing it in parentheses and reverse quotes does.  The "
"built-in function :func:`str` performs a similar but more user-friendly "
"conversion."
msgstr ""
"組み込み関数 :func:`repr` は、括弧内の引数に対して、逆クオート表記で囲われた"
"中身と全く同じ変換を実行します。組み込み関数 :func:`str` は似たような動作をし"
"ますが、もっとユーザフレンドリな変換になります。"

#: ../../reference/expressions.rst:382
msgid "Yield expressions"
msgstr "Yield 式"

#: ../../reference/expressions.rst:395
msgid ""
"The :keyword:`yield` expression is only used when defining a generator "
"function, and can only be used in the body of a function definition. Using "
"a :keyword:`yield` expression in a function definition is sufficient to "
"cause that definition to create a generator function instead of a normal "
"function."
msgstr ""
":keyword:`yield` 式はジェネレータ関数を定義するときにその関数の内部でのみ使用"
"されます。関数内で :keyword:`yield` 式を使用すると、普通の関数ではなくジェネ"
"レータ関数が作成されます。"

#: ../../reference/expressions.rst:400
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of a generator "
"function. The execution starts when one of the generator's methods is "
"called.  At that time, the execution proceeds to the first :keyword:`yield` "
"expression, where it is suspended again, returning the value of :token:"
"`expression_list` to generator's caller.  By suspended we mean that all "
"local state is retained, including the current bindings of local variables, "
"the instruction pointer, and the internal evaluation stack.  When the "
"execution is resumed by calling one of the generator's methods, the function "
"can proceed exactly as if the :keyword:`yield` expression was just another "
"external call. The value of the :keyword:`yield` expression after resuming "
"depends on the method which resumed the execution."
msgstr ""
"ジェネレータ関数が呼び出されるとき、ジェネレータとしてのイテレータを返しま"
"す。そのジェネレータはジェネレータ関数の実行を制御します。ジェネレータのメ"
"ソッドが呼び出されるときに実行が開始されます。メソッドを呼び出すと、実行は :"
"keyword:`yield` の最初の位置まで処理されて一時停止します。そして、ジェネレー"
"タの呼び出し元へ :token:`expression_list` の値を返します。ここで言う一時停止"
"とは、ローカル変数の束縛、命令ポインタや内部の評価スタックを含めたローカルの"
"全ての状態が保持されることを指します。再度、ジェネレータのメソッドを呼び出し"
"て実行を再開するとき、そのジェネレータ関数はまさに :keyword:`yield` 式がただ"
"の外部呼び出しであったかのように処理が継続されます。再開した後の :keyword:"
"`yield` 式の値は実行を再開するメソッドに依存します。"

#: ../../reference/expressions.rst:415
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where should the execution continue after it yields; "
"the control is always transferred to the generator's caller."
msgstr ""
"これまで説明した内容から、ジェネレータ関数はコルーチンにとてもよく似ていま"
"す。ジェネレータ関数は何度も生成し、1つ以上のエントリポイントを持ち、その実行"
"は一時停止されます。ジェネレータ関数は yield した後で実行の継続を制御できない"
"ことが唯一の違いです。その制御は常にジェネレータの呼び出し元へ移されます。"

#: ../../reference/expressions.rst:425
msgid "Generator-iterator methods"
msgstr "ジェネレータ-イテレータメソッド"

#: ../../reference/expressions.rst:427
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr ""
"この説ではジェネレータイテレータのメソッドについて説明します。これらはジェネ"
"レータ関数の実行制御に使用できます。"

#: ../../reference/expressions.rst:430
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr ""
"以下のジェネレータメソッドの呼び出しは、ジェネレータが既に実行中の場合 :exc:"
"`ValueError` 例外を送出する点に注意してください。"

#: ../../reference/expressions.rst:438
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed :keyword:`yield` expression.  When a generator function is resumed "
"with a :meth:`~generator.next` method, the current :keyword:`yield` "
"expression always evaluates to :const:`None`.  The execution then continues "
"to the next :keyword:`yield` expression, where the generator is suspended "
"again, and the value of the :token:`expression_list` is returned to :meth:"
"`~generator.next`'s caller. If the generator exits without yielding another "
"value, a :exc:`StopIteration` exception is raised."
msgstr ""
"ジェネレータ関数の実行を開始するか、最後に :keyword:`yield` 式が実行されたと"
"ころから再開します。ジェネレータ関数が :meth:`~generator.next` メソッドによっ"
"て再開された時、その時点の :keyword:`yield` 式の値は常に :const:`None` と評価"
"されます。その後次の :keyword:`yield` 式まで実行し、ジェネレータは一時停止"
"し、 :token:`expression_list` の値を :meth:`~generator.next` メソッドの呼び出"
"し元に返します。ジェネレータが次の値を yield せずに終了した場合、 :exc:"
"`StopIteration` 例外が送出されます。"

#: ../../reference/expressions.rst:451
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The ``value`` argument becomes the result of the current :keyword:`yield` "
"expression.  The :meth:`send` method returns the next value yielded by the "
"generator, or raises :exc:`StopIteration` if the generator exits without "
"yielding another value. When :meth:`send` is called to start the generator, "
"it must be called with :const:`None` as the argument, because there is no :"
"keyword:`yield` expression that could receive the value."
msgstr ""
"ジェネレータ関数の内部へ値を \"送り\"、実行を再開します。引数の ``value`` は"
"カレントの :keyword:`yield` 式の結果になります。 :meth:`send` メソッドはジェ"
"ネレータが生成した次の値、またはジェネレータが値を生成することなく終了する"
"と :exc:`StopIteration` が発生します。ジェネレータが再開するために :meth:"
"`send` を呼び出すときは、引数として :const:`None` を指定しなければなりませ"
"ん。そうしないと、値を受け取る :keyword:`yield` 式が存在しないからです。"

#: ../../reference/expressions.rst:462
msgid ""
"Raises an exception of type ``type`` at the point where generator was "
"paused, and returns the next value yielded by the generator function.  If "
"the generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised.  If the generator function does not catch the passed-in "
"exception, or raises a different exception, then that exception propagates "
"to the caller."
msgstr ""
"ジェネレータが中断した位置で ``type`` 型の例外を発生させて、ジェネレータ関数"
"が生成する次の値を返します。ジェネレータが値を生成することなく終了すると :"
"exc:`StopIteration` が発生します。ジェネレータ関数が渡された例外を捕捉しな"
"い、もしくは違う例外を発生させるなら、その例外は呼び出し元へ伝搬されます。"

#: ../../reference/expressions.rst:473
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then raises :exc:`StopIteration` (by "
"exiting normally, or due to already being closed) or :exc:`GeneratorExit` "
"(by not catching the exception), close returns to its caller.  If the "
"generator yields a value, a :exc:`RuntimeError` is raised.  If the generator "
"raises any other exception, it is propagated to the caller.  :meth:`close` "
"does nothing if the generator has already exited due to an exception or "
"normal exit."
msgstr ""
"ジェネレータ関数が中断した位置で :exc:`GeneratorExit` を発生させます。ジェネ"
"レータ関数が (通常の終了または既にクローズされたことで) :exc:"
"`StopIteration` 、もしくは (例外を捕捉しないことで) :exc:`GeneratorExit` を発"
"生させる場合 close() は呼び出し元へ返されます。ジェネレータが値を生成する場"
"合 :exc:`RuntimeError` が発生します。 :meth:`close` はジェネレータが通常の終"
"了または例外により既に終了している場合は何もしません。"

#: ../../reference/expressions.rst:481
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr ""
"以下の簡単なサンプルはジェネレータとジェネレータ関数の振る舞いを実際に紹介し"
"ます::"

#: ../../reference/expressions.rst:512
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`0342` - 拡張されたジェネレータを用いたコルーチン"

#: ../../reference/expressions.rst:512
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr ""
"シンプルなコルーチンとして利用できるように、ジェネレータの構文と API を拡張す"
"る提案です。"

#: ../../reference/expressions.rst:519
msgid "Primaries"
msgstr "プライマリ"

#: ../../reference/expressions.rst:523
msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr ""
"プライマリは、言語において最も結合の強い操作を表します。文法は以下のようにな"
"ります:"

#: ../../reference/expressions.rst:533
msgid "Attribute references"
msgstr "属性参照"

#: ../../reference/expressions.rst:537
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr "属性参照は、プライマリの後ろにピリオドと名前を連ねたものです:"

#: ../../reference/expressions.rst:547
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, e.g., a module, list, or an instance.  This object is then asked "
"to produce the attribute whose name is the identifier.  If this attribute is "
"not available, the exception :exc:`AttributeError` is raised. Otherwise, the "
"type and value of the object produced is determined by the object.  Multiple "
"evaluations of the same attribute reference may yield different objects."
msgstr ""
"プライマリの値評価結果は、例えばモジュール、リスト、インスタンスといった、属"
"性参照をサポートする型でなければなりません。オブジェクトは次に、指定した名前"
"が識別子名となっているような属性を生成するよう問い合わせされます。問い合わせ"
"た属性が得られない場合、例外 :exc:`AttributeError` が送出されます。それ以外の"
"場合、オブジェクトは属性オブジェクトの型と値を決定し、生成して返します。同じ"
"属性参照を複数回評価したとき、互いに異なる属性オブジェクトになることがありま"
"す。"

#: ../../reference/expressions.rst:558
msgid "Subscriptions"
msgstr "添字表記 (subscription)"

#: ../../reference/expressions.rst:571
msgid ""
"A subscription selects an item of a sequence (string, tuple or list) or "
"mapping (dictionary) object:"
msgstr ""
"添字表記は、シーケンス (文字列、タプルまたはリスト) やマップ (辞書) オブジェ"
"クトから、要素を一つ選択します:"

#: ../../reference/expressions.rst:577
msgid "The primary must evaluate to an object of a sequence or mapping type."
msgstr ""
"プライマリの値評価結果は、シーケンス型かマップ型のオブジェクトでなければなり"
"ません。"

#: ../../reference/expressions.rst:579
msgid ""
"If the primary is a mapping, the expression list must evaluate to an object "
"whose value is one of the keys of the mapping, and the subscription selects "
"the value in the mapping that corresponds to that key.  (The expression list "
"is a tuple except if it has exactly one item.)"
msgstr ""
"プライマリがマップであれば、式リストの値評価結果はマップ内のいずれかのキー値"
"に相当するオブジェクトにならなければなりません。添字表記は、そのキーに対応す"
"るマップ内の値 (value) を選択します。 (式リストの要素が単独である場合を除き、"
"式リストはタプルでなければなりません。)"

#: ../../reference/expressions.rst:584
msgid ""
"If the primary is a sequence, the expression list must evaluate to a plain "
"integer.  If this value is negative, the length of the sequence is added to "
"it (so that, e.g., ``x[-1]`` selects the last item of ``x``.)  The resulting "
"value must be a nonnegative integer less than the number of items in the "
"sequence, and the subscription selects the item whose index is that value "
"(counting from zero)."
msgstr ""

#: ../../reference/expressions.rst:595
msgid ""
"A string's items are characters.  A character is not a separate data type "
"but a string of exactly one character."
msgstr ""
"文字列型の要素は文字 (character) です。文字は個別の型ではなく、 1 文字だけか"
"らなる文字列です。"

#: ../../reference/expressions.rst:602
msgid "Slicings"
msgstr "スライス表記 (slicing)"

#: ../../reference/expressions.rst:614
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""
"スライス表記はシーケンスオブジェクト (文字列、タプルまたはリスト) におけるあ"
"る範囲の要素を選択します。スライス表記は式として用いたり、代入や :keyword:"
"`del` 文の対象として用いたりできます。スライス表記の構文は以下のようになりま"
"す:"

#: ../../reference/expressions.rst:634
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice nor ellipses).  "
"Similarly, when the slice list has exactly one short slice and no trailing "
"comma, the interpretation as a simple slicing takes priority over that as an "
"extended slicing."
msgstr ""
"上記の形式的な構文法にはあいまいさがあります: 式リストに見えるものは、スライ"
"スリストにも見えるため、添字表記はスライス表記としても解釈されうるということ"
"です。この場合には、(スライスリストの評価結果が、適切なスライスや省略表記 "
"(ellipsis) にならない場合)、スライス表記としての解釈よりも添字表記としての解"
"釈の方が高い優先順位を持つように定義することで、構文法をより難解にすることな"
"くあいまいさを取り除いています。同様に、スライスリストが厳密に一つだけの短い"
"スライスで、末尾にカンマが続いていない場合、拡張スライスとしての解釈より、単"
"純なスライスとしての解釈が優先されます。"

#: ../../reference/expressions.rst:643
msgid ""
"The semantics for a simple slicing are as follows.  The primary must "
"evaluate to a sequence object.  The lower and upper bound expressions, if "
"present, must evaluate to plain integers; defaults are zero and the ``sys."
"maxint``, respectively.  If either bound is negative, the sequence's length "
"is added to it.  The slicing now selects all items with index *k* such that "
"``i <= k < j`` where *i* and *j* are the specified lower and upper bounds.  "
"This may be an empty sequence.  It is not an error if *i* or *j* lie outside "
"the range of valid indexes (such items don't exist so they aren't selected)."
msgstr ""
"単純なスライスに対する意味付けは以下のようになります。プライマリの値評価結果"
"は、シーケンス型のオブジェクトでなければなりません。下境界および上境界を表す"
"式がある場合、それらの値評価結果は整数でなくてはなりません; デフォルトの値"
"は、それぞれゼロと ``sys.maxint`` です。どちらかの境界値が負である場合、シー"
"ケンスの長さが加算されます。こうして、スライスは *i* および *j* をそれぞれ指"
"定した下境界、上境界として、インデクス *k* が ``i <= k < j`` となる全ての要素"
"を選択します。選択の結果、空のシーケンスになることもあります。 *i* や *j* が"
"有効なインデクス範囲の外側にある場合でも、エラーにはなりません (範囲外の要素"
"は存在しないので、選択されないだけです)。"

#: ../../reference/expressions.rst:657
msgid ""
"The semantics for an extended slicing are as follows.  The primary must "
"evaluate to a mapping object, and it is indexed with a key that is "
"constructed from the slice list, as follows.  If the slice list contains at "
"least one comma, the key is a tuple containing the conversion of the slice "
"items; otherwise, the conversion of the lone slice item is the key.  The "
"conversion of a slice item that is an expression is that expression.  The "
"conversion of an ellipsis slice item is the built-in ``Ellipsis`` object.  "
"The conversion of a proper slice is a slice object (see section :ref:"
"`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and :attr:`~slice."
"step` attributes are the values of the expressions given as lower bound, "
"upper bound and stride, respectively, substituting ``None`` for missing "
"expressions."
msgstr ""
"拡張スライスに対する意味付けは、以下のようになります。プライマリの値評価結果"
"は、辞書型のオブジェクトでなければなりません。また、辞書は以下に述べるように"
"してスライスリストから生成されたキーによってインデクス指定できなければなりま"
"せん。スライスリストに少なくとも一つのカンマが含まれている場合、キーは各スラ"
"イス要素を値変換したものからなるタプルになります; それ以外の場合、単一のスラ"
"イス要素自体を値変換したものがキーになります。一個の式でできたスライス要素の"
"変換は、その式になります。省略表記スライス要素の変換は、組み込みの "
"``Ellipsis`` オブジェクトになります。適切なスライスの変換は、スライスオブジェ"
"クト (:ref:`types` 参照) で :attr:`~slice.start`, :attr:`~slice.stop` およ"
"び :attr:`~slice.step` 属性は、それぞれ指定した下境界、上境界、およびとび幅 "
"(stride) になります。式がない場合には ``None`` に置き換えられます。"

#: ../../reference/expressions.rst:678
msgid "Calls"
msgstr "呼び出し (call)"

#: ../../reference/expressions.rst:680
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""
"呼び出しは、呼び出し可能オブジェクト (例えば :term:`function`) を :term:"
"`arguments <argument>` の系列とともに呼び出します。系列は空の系列であってもか"
"まいません:"

#: ../../reference/expressions.rst:697
msgid ""
"A trailing comma may be present after the positional and keyword arguments "
"but does not affect the semantics."
msgstr ""
"固定引数やキーワード引数の後ろにカンマをつけてもかまいません。構文の意味付け"
"に影響を及ぼすことはありません。"

#: ../../reference/expressions.rst:703
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and certain class instances themselves are callable; "
"extensions may define additional callable object types).  All argument "
"expressions are evaluated before the call is attempted.  Please refer to "
"section :ref:`function` for the syntax of formal :term:`parameter` lists."
msgstr ""
"プライマリの値評価結果は、呼び出し可能オブジェクトでなければなりません (ユー"
"ザ定義関数、組み込み関数、組み込みオブジェクトのメソッド、クラスオブジェク"
"ト、クラスインスタンスのメソッド、そして特定のクラスインスタンス自体が呼び出"
"し可能です; 拡張によって、その他の呼び出し可能オブジェクト型を定義することが"
"できます)。引数式は全て、呼び出しを試みる前に値評価されます。仮引数 (formal :"
"term:`parameter`) リストの構文については :ref:`function` を参照してください。"

#: ../../reference/expressions.rst:710
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the value of the argument is placed in the slot, filling it (even if the "
"expression is ``None``, it fills the slot).  When all arguments have been "
"processed, the slots that are still unfilled are filled with the "
"corresponding default value from the function definition.  (Default values "
"are calculated, once, when the function is defined; thus, a mutable object "
"such as a list or dictionary used as default value will be shared by all "
"calls that don't specify an argument value for the corresponding slot; this "
"should usually be avoided.)  If there are any unfilled slots for which no "
"default value is specified, a :exc:`TypeError` exception is raised.  "
"Otherwise, the list of filled slots is used as the argument list for the "
"call."
msgstr ""
"キーワード引数が存在する場合、以下のようにして最初に固定引数 (positional "
"argument) に変換されます。まず、値の入っていないスロットが仮引数に対して生成"
"されます。N 個の固定引数がある場合、固定引数は先頭の N スロットに配置されま"
"す。次に、各キーワード引数について、識別子を使って対応するスロットを決定しま"
"す (識別子が最初の仮引数パラメタ名と同じなら、最初のスロットを使う、といった"
"具合です)。スロットがすでにすべて埋まっていたなら :exc:`TypeError` 例外が送出"
"されます。それ以外の場合、引数値をスロットに埋めていきます。 (式が ``None`` "
"であっても、その式でスロットを埋めます)。全ての引数が処理されたら、まだ埋めら"
"れていないスロットをそれぞれに対応する関数定義時のデフォルト値で埋めます。(デ"
"フォルト値は、関数が定義されたときに一度だけ計算されます; 従って、リストや辞"
"書のような変更可能なオブジェクトがデフォルト値として使われると、対応するス"
"ロットに引数を指定しない限り、このオブジェクトが全ての呼び出しから共有されま"
"す; このような状況は通常避けるべきです。) デフォルト値が指定されていない、値"
"の埋められていないスロットが残っている場合 :exc:`TypeError` 例外が送出されま"
"す。そうでない場合、値の埋められたスロットからなるリストが呼び出しの引数とし"
"て使われます。"

#: ../../reference/expressions.rst:730
msgid ""
"An implementation may provide built-in functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :c:func:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"実装では、名前を持たない固定引数を受け取る組み込み関数を提供するかもしれませ"
"ん。そういった引数がドキュメント化のために '名付けられて' いたとしても、実際"
"には名付けられていないのでキーワードによって提供されません。 CPython では、C "
"言語で実装された関数の、名前を持たない固定引数を解析するために :c:func:"
"`PyArg_ParseTuple` を使用します。"

#: ../../reference/expressions.rst:736
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""
"仮引数スロットの数よりも多くの固定引数がある場合、構文 ``*identifier`` を使っ"
"て指定された仮引数がないかぎり、 :exc:`TypeError` 例外が送出されます; 仮引数 "
"``*identifier`` がある場合、この仮引数は余分な固定引数が入ったタプル (もしく"
"は、余分な固定引数がない場合には空のタプル) を受け取ります。"

#: ../../reference/expressions.rst:742
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""
"キーワード引数のいずれかが仮引数名に対応しない場合、構文 ``**identifier`` を"
"使って指定された仮引数がない限り、 :exc:`TypeError` 例外が送出されます; 仮引"
"数 ``**identifier`` がある場合、この仮引数は余分なキーワード引数が入った "
"(キーワードをキーとし、引数値をキーに対応する値とした) 辞書を受け取ります。余"
"分なキーワード引数がない場合には、空の (新たな) 辞書を受け取ります。"

#: ../../reference/expressions.rst:752
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an iterable.  Elements from this iterable are treated as if "
"they were additional positional arguments; if there are positional arguments "
"*x1*, ..., *xN*, and ``expression`` evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+N positional arguments *x1*, ..., *xN*, "
"*y1*, ..., *yM*."
msgstr ""
"関数呼び出しの際に構文 ``*expression`` が使われるなら、 ``expression`` の評価"
"はシーケンスでなくてはなりません。このシーケンスの要素は、追加の固定引数のよ"
"うに扱われます; すなわち、固定引数 *x1* ,..., *xN* があり、 ``expression`` の"
"評価がシーケンス *y1* ,..., *yM* であるなら、M+N 個の固定引数 *x1* ,..., "
"*xN* , *y1* ,..., *yM* を使った呼び出しと同じになります。"

#: ../../reference/expressions.rst:759
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* some keyword arguments, it is processed *before* the keyword "
"arguments (and the ``**expression`` argument, if any -- see below).  So::"
msgstr ""
"``*expression`` 構文はキーワード引数の *後ろ* で指定しても良いですが、キー"
"ワード引数よりも *前* で指定されたものとして処理されます (``**expression`` 引"
"数を指定したときの振る舞いは以下を参照)。従って、このようになります::"

#: ../../reference/expressions.rst:775
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not arise."
msgstr ""
"キーワード引数と ``*expression`` 構文を同じ呼び出しで一緒に使うことはあまりな"
"いので、実際に上記のような混乱が生じることはありません。"

#: ../../reference/expressions.rst:781
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a mapping, the contents of which are treated as additional "
"keyword arguments.  In the case of a keyword appearing in both "
"``expression`` and as an explicit keyword argument, a :exc:`TypeError` "
"exception is raised."
msgstr ""
"関数呼び出しで ``**expression`` 構文が使われた場合、 ``expression`` の値評価"
"結果はマップ型でなければなりません。辞書の内容は追加のキーワード引数として扱"
"われます。明示的なキーワード引数が ``expression`` 内のキーワードと重複した場"
"合には :exc:`TypeError` 例外が送出されます。"

#: ../../reference/expressions.rst:786
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names.  "
"Formal parameters using the syntax ``(sublist)`` cannot be used as keyword "
"argument names; the outermost sublist corresponds to a single unnamed "
"argument slot, and the argument value is assigned to the sublist using the "
"usual tuple assignment rules after all other parameter processing is done."
msgstr ""
"``*identifier`` や ``**identifier`` 構文を使った仮引数は、固定引数スロットや"
"キーワード引数名にすることができません。 ``(sublist)`` 構文を使った仮引数は、"
"キーワード引数名には使えません; sublist は、リスト全体が一つの無名の引数ス"
"ロットに対応しており、sublist 中の引数は、他の全てのパラメタに対する処理が終"
"わった後に、通常のタプル形式の代入規則を使ってスロットに入れられます。"

#: ../../reference/expressions.rst:793
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""
"呼び出しを行うと、例外を送出しない限り、常に何らかの値を返します。 ``None`` "
"を返す場合もあります。戻り値がどのように算出されるかは、呼び出し可能オブジェ"
"クトの形態によって異なります。"

#: ../../reference/expressions.rst:797
msgid "If it is---"
msgstr "これが---"

#: ../../reference/expressions.rst:810
msgid "a user-defined function:"
msgstr "ユーザ定義関数:"

#: ../../reference/expressions.rst:806
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr ""
"関数のコードブロックに引数リストが渡され、実行されます。コードブロックは、ま"
"ず仮引数を実引数に結合 (bind) します; この動作については :ref:`function` で記"
"述しています。コードブロックで :keyword:`return` 文が実行される際に、関数呼び"
"出しの戻り値 (return value) が決定されます。"

#: ../../reference/expressions.rst:824
msgid "a built-in function or method:"
msgstr "組み込み関数またはメソッド:"

#: ../../reference/expressions.rst:823
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""
"結果はインタプリタに依存します; 組み込み関数やメソッドの詳細は :ref:`built-"
"in-funcs` を参照してください。"

#: ../../reference/expressions.rst:831
msgid "a class object:"
msgstr "クラスオブジェクト:"

#: ../../reference/expressions.rst:831
msgid "A new instance of that class is returned."
msgstr "そのクラスの新しいインスタンスが返されます。"

#: ../../reference/expressions.rst:841
msgid "a class instance method:"
msgstr "クラスインスタンスメソッド:"

#: ../../reference/expressions.rst:839
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""
"対応するユーザ定義の関数が呼び出されます。このとき、呼び出し時の引数リストよ"
"り一つ長い引数リストで呼び出されます: インスタンスが引数リストの先頭に追加さ"
"れます。"

#: ../../reference/expressions.rst:850
msgid "a class instance:"
msgstr "クラスインスタンス:"

#: ../../reference/expressions.rst:848
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the same "
"as if that method was called."
msgstr ""
"クラスで :meth:`__call__` メソッドが定義されていなければなりません; :meth:"
"`__call__` メソッドが呼び出された場合と同じ効果をもたらします。"

#: ../../reference/expressions.rst:855
msgid "The power operator"
msgstr "べき乗演算 (power operator)"

#: ../../reference/expressions.rst:857
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""
"べき乗演算は、左側にある単項演算子よりも強い結合優先順位があります; 一方、右"
"側にある単項演算子よりは低い結合優先順位になっています。構文は以下のようにな"
"ります:"

#: ../../reference/expressions.rst:863
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""
"従って、べき乗演算子と単項演算子からなる演算列が丸括弧で囲われていない場合、"
"演算子は右から左へと評価されます (この場合は演算子の評価順序を強制しません。"
"つまり ``-1**2`` は ``-1`` になります)。"

#: ../../reference/expressions.rst:867
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type.  The result type is that of the arguments after "
"coercion."
msgstr ""
"べき乗演算子は、二つの引数で呼び出される組み込み関数 :func:`pow` と同じ意味付"
"けを持っています。引数はまず共通の型に変換されます。結果の型は、型強制後の引"
"数の型になります。"

#: ../../reference/expressions.rst:872
msgid ""
"With mixed operand types, the coercion rules for binary arithmetic operators "
"apply. For int and long int operands, the result has the same type as the "
"operands (after coercion) unless the second argument is negative; in that "
"case, all arguments are converted to float and a float result is delivered. "
"For example, ``10**2`` returns ``100``, but ``10**-2`` returns ``0.01``. "
"(This last feature was added in Python 2.2. In Python 2.1 and before, if "
"both arguments were of integer types and the second argument was negative, "
"an exception was raised)."
msgstr ""
"引数型を混合すると、二項算術演算における型強制規則が適用されます。整数や長整"
"数の被演算子の場合、第二引数が負でない限り、結果は (型強制後の) 被演算子と同"
"じになります; 第二引数が負の場合、全ての引数は浮動小数点型に変換され、浮動小"
"数点型が返されます。例えば ``10**2`` は ``100`` を返しますが、 ``10**-2`` は "
"``0.01`` を返します。 (上述の仕様のうち、最後のものは Python 2.2 で追加されま"
"した。 Python 2.1 以前では、双方の引数が整数型で、第二引数が負の場合、例外が"
"送出されていました。)"

#: ../../reference/expressions.rst:881
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :exc:"
"`ValueError`."
msgstr ""
"``0.0`` を負の数でべき乗すると :exc:`ZeroDivisionError` を送出します。負の数"
"を小数でべき乗すると :exc:`ValueError` になります。"

#: ../../reference/expressions.rst:888
msgid "Unary arithmetic and bitwise operations"
msgstr "単項算術演算とビット単位演算(unary arithmetic and bitwise operation)"

#: ../../reference/expressions.rst:894
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr "全ての単項算術演算とビット単位演算は、同じ優先順位を持っています:"

#: ../../reference/expressions.rst:903
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric argument."
msgstr ""
"単項演算子 ``-`` (マイナス) は、引数となる数値の符号を反転 (negation) しま"
"す。"

#: ../../reference/expressions.rst:907
msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr "単項演算子 ``+`` (プラス) は、数値引数を変更しません。"

#: ../../reference/expressions.rst:911
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its plain "
"or long integer argument.  The bitwise inversion of ``x`` is defined as ``-"
"(x+1)``.  It only applies to integral numbers."
msgstr ""
"単項演算子 ``~`` (反転) は、整数または長整数の引数をビット単位反転 (bitwise "
"invert) します。 ``x`` のビット単位反転は、 ``-(x+1)`` として定義されていま"
"す。この演算子は整数にのみ適用されます。"

#: ../../reference/expressions.rst:917
msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr ""
"上記の三つはいずれも、引数が正しい型でない場合には :exc:`TypeError` 例外が送"
"出されます。"

#: ../../reference/expressions.rst:924
msgid "Binary arithmetic operations"
msgstr "二項算術演算 (binary arithmetic operation)"

#: ../../reference/expressions.rst:928
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""
"二項算術演算は、慣習的な優先順位を踏襲しています。演算子のいずれかは、特定の"
"非数値型にも適用されるので注意してください。べき乗 (power) 演算子を除き、演算"
"子には二つのレベル、すなわち乗算的 (multiplicatie) 演算子と加算的 (additie) "
"演算子しかありません:"

#: ../../reference/expressions.rst:940
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer (plain or long) and the other must be a sequence. In the former "
"case, the numbers are converted to a common type and then multiplied "
"together.  In the latter case, sequence repetition is performed; a negative "
"repetition factor yields an empty sequence."
msgstr ""
"``*`` (乗算: multiplication) 演算は、引数間の積になります。引数の組は、双方と"
"もに数値型であるか、片方が整数 (通常の整数または長整数) 型で他方がシーケンス"
"型かのどちらかでなければなりません。前者の場合、数値は共通の型に変換された後"
"乗算されます。後者の場合、シーケンスの繰り返し操作が行われます。繰り返し数を"
"負にすると、空のシーケンスになります。"

#: ../../reference/expressions.rst:951
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Plain or long integer division yields an integer of the same "
"type; the result is that of mathematical division with the 'floor' function "
"applied to the result. Division by zero raises the :exc:`ZeroDivisionError` "
"exception."
msgstr ""
"``/`` (除算: division) および ``//`` (切り捨て除算: floor division) は、引数"
"間の商になります。数値引数はまず共通の型に変換されます。整数または長整数の除"
"算結果は、同じ型の整数になります; この場合、結果は数学的な除算に関数 'floor' "
"を適用したものになります。ゼロによる除算を行うと :exc:`ZeroDivisionError` 例"
"外を送出します。"

#: ../../reference/expressions.rst:959
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""
"``%`` (モジュロ: modulo) 演算は、第一引数を第二引数で除算したときの剰余になり"
"ます。数値引数はまず共通の型に変換されます。右引数値がゼロの場合には :exc:"
"`ZeroDivisionError` 例外が送出されます。引数値は浮動小数点でもよく。例えば "
"``3.14%0.7`` は ``0.34`` になります (``3.14`` は ``4*0.7 + 0.34`` だからで"
"す)。モジュロ演算子は常に第二引数と同じ符号 (またはゼロ) の結果になります; モ"
"ジュロ演算の結果の絶対値は、常に第二引数の絶対値よりも小さくなります。 [#]_"

#: ../../reference/expressions.rst:968
msgid ""
"The integer division and modulo operators are connected by the following "
"identity: ``x == (x/y)*y + (x%y)``.  Integer division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x/y, "
"x%y)``.  These identities don't hold for floating point numbers; there "
"similar identities hold approximately where ``x/y`` is replaced by ``floor(x/"
"y)`` or ``floor(x/y) - 1`` [#]_."
msgstr ""
"整数による除算演算やモジュロ演算は、恒等式: ``x == (x/y)*y + (x%y)`` と関係し"
"ています。整数除算やモジュロはまた、組み込み関数 :func:`divmod`: ``divmod(x, "
"y) == (x/y, x%y)`` と関係しています。これらの恒等関係は浮動小数点の場合には維"
"持されません; ``x/y`` が ``floor(x/y)`` や ``floor(x/y) - 1`` に置き換えられ"
"た場合、これらの恒等式は近似性を維持します。 [#]_"

#: ../../reference/expressions.rst:975
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string and unicode objects to perform string "
"formatting (also known as interpolation). The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`string-"
"formatting`."
msgstr ""
"数値に対するモジュロ演算の実行に加えて ``%`` 演算子は文字列 (string) とユニ"
"コードオブジェクトにオーバーロードされ、文字列の書式化 (文字列の挿入としても"
"知られる) を行います。文字列の書式化の構文は Python ライブラリリファレンス :"
"ref:`string-formatting` 節を参照してください。"

#: ../../reference/expressions.rst:980
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are no longer defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""
"切り捨て除算演算子、モジュロ演算子、および :func:`divmod` 関数は、複素数に対"
"してはもはや定義されていません。目的に合うならば、代わりに :func:`abs` を使っ"
"て浮動小数点に変換してください。"

#: ../../reference/expressions.rst:987
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments. The arguments "
"must either both be numbers or both sequences of the same type.  In the "
"former case, the numbers are converted to a common type and then added "
"together.  In the latter case, the sequences are concatenated."
msgstr ""
"``+`` (加算) 演算は、引数を加算した値を返します。引数は双方とも数値型か、双方"
"とも同じ型のシーケンスでなければなりません。前者の場合、数値は共通の型に変換"
"され、加算されます。後者の場合、シーケンスは結合 (concatenate) されます。"

#: ../../reference/expressions.rst:994
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr ""
"``-`` (減算) 演算は、引数間で減算を行った値を返します。数値引数はまず共通の型"
"に変換されます。"

#: ../../reference/expressions.rst:1001
msgid "Shifting operations"
msgstr "シフト演算 (shifting operation)"

#: ../../reference/expressions.rst:1005
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr "シフト演算は、算術演算よりも低い優先順位を持っています:"

#: ../../reference/expressions.rst:1010
msgid ""
"These operators accept plain or long integers as arguments.  The arguments "
"are converted to a common type.  They shift the first argument to the left "
"or right by the number of bits given by the second argument."
msgstr ""
"シフトの演算子は整数または長整数を引数にとります。引数は共通の型に変換されま"
"す。シフト演算では、最初の引数を二つ目の引数に応じたビット数だけ、左または右"
"にビットシフトします。"

#: ../../reference/expressions.rst:1016
msgid ""
"A right shift by *n* bits is defined as division by ``pow(2, n)``.  A left "
"shift by *n* bits is defined as multiplication with ``pow(2, n)``.  Negative "
"shift counts raise a :exc:`ValueError` exception."
msgstr ""
"*n* ビットの右シフトは ``pow(2,n)`` による除算として定義されています。 *n* "
"ビットの左シフトは ``pow(2,n)`` による乗算として定義されます。負のビット数で"
"シフトを行うと :exc:`ValueError` 例外を送出します。"

#: ../../reference/expressions.rst:1022
msgid ""
"In the current implementation, the right-hand operand is required to be at "
"most :attr:`sys.maxsize`.  If the right-hand operand is larger than :attr:"
"`sys.maxsize` an :exc:`OverflowError` exception is raised."
msgstr ""
"現在の実装では、右辺被演算子は最大でも :attr:`sys.maxsize` でなければなりませ"
"ん。右辺被演算子が :attr:`sys.maxsize` よりも大きいと、 :exc:`OverflowError` "
"例外が送出されます。"

#: ../../reference/expressions.rst:1029
msgid "Binary bitwise operations"
msgstr "ビット単位演算の二項演算 (binary bitwise operation)"

#: ../../reference/expressions.rst:1033
msgid "Each of the three bitwise operations has a different priority level:"
msgstr ""
"以下の三つのビット単位演算には、それぞれ異なる優先順位レベルがあります:"

#: ../../reference/expressions.rst:1042
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"plain or long integers.  The arguments are converted to a common type."
msgstr ""
"``&`` 演算子は、引数間でビット単位の AND をとった値になります。引数は整数また"
"は長整数でなければなりません。引数は共通の型に変換されます。"

#: ../../reference/expressions.rst:1049
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be plain or long integers.  The arguments are converted to a "
"common type."
msgstr ""
"``^`` 演算子は、引数間でビット単位の XOR (排他的 OR) をとった値になります。引"
"数は整数または長整数でなければなりません。引数は共通の型に変換されます。"

#: ../../reference/expressions.rst:1056
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be plain or long integers.  The arguments are converted to a common "
"type."
msgstr ""
"``|`` 演算子は、引数間でビット単位の OR (非排他的 OR) をとった値になります。"
"引数は整数または長整数でなければなりません。引数は共通の型に変換されます。"

#: ../../reference/expressions.rst:1063
msgid "Comparisons"
msgstr "比較"

#: ../../reference/expressions.rst:1069
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""
"C 言語と違って、Python における比較演算子は同じ優先順位をもっており、全ての算"
"術演算子、シフト演算子、ビット単位演算子よりも低くなっています。また ``a < b "
"< c`` が数学で伝統的に用いられているのと同じ解釈になる点も C 言語と違います:"

#: ../../reference/expressions.rst:1079
msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr "比較演算の結果はブール値: ``True`` または ``False`` になります。"

#: ../../reference/expressions.rst:1083
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""
"比較はいくらでも連鎖することができます。例えば ``x < y <= z`` は ``x < y and "
"y <= z`` と等価になります。ただしこの場合、前者では ``y`` はただ一度だけ評価"
"される点が異なります (どちらの場合でも、 ``x < y`` が偽になると ``z`` の値は"
"まったく評価されません)。"

#: ../../reference/expressions.rst:1087
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""
"形式的には、 *a*, *b*, *c*, ..., *y*, *z* が式で *op1*, *op2*, ..., *opN* が"
"比較演算子である場合、 ``a op1 b op2 c ... y opN z`` は ``a op1 b and b op2 "
"c and ... y opN z`` と等価になります。ただし、前者では各式は多くても一度しか"
"評価されません。"

#: ../../reference/expressions.rst:1092
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""
"``a op1 b op2 c`` と書いた場合、 *a* から *c* までの範囲にあるかどうかのテス"
"トを指すのではないことに注意してください。例えば ``x < y > z`` は (きれいな書"
"き方ではありませんが) 完全に正しい文法です。"

#: ../../reference/expressions.rst:1096
msgid ""
"The forms ``<>`` and ``!=`` are equivalent; for consistency with C, ``!=`` "
"is preferred; where ``!=`` is mentioned below ``<>`` is also accepted.  The "
"``<>`` spelling is considered obsolescent."
msgstr ""
"``<>`` と ``!=`` の二つの形式は等価です; C との整合性を持たせるためには ``!"
"=`` を推奨します; 以下で ``!=`` について触れている部分では ``<>`` を使うこと"
"もできます。 ``<>`` のような書き方は、現在では古い書き方とみなされています。"

#: ../../reference/expressions.rst:1101
msgid "Value comparisons"
msgstr "値の比較"

#: ../../reference/expressions.rst:1103
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects do not need to have the same type."
msgstr ""
"演算子 ``<``, ``>``, ``==``, ``>=``, ``<=``, および ``!=`` は2つのオブジェク"
"トの値を比較します。\n"
"オブジェクトが同じ型を持つ必要はりません。"

#: ../../reference/expressions.rst:1106
msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to type "
"and identity).  The value of an object is a rather abstract notion in "
"Python: For example, there is no canonical access method for an object's "
"value.  Also, there is no requirement that the value of an object should be "
"constructed in a particular way, e.g. comprised of all its data attributes. "
"Comparison operators implement a particular notion of what the value of an "
"object is.  One can think of them as defining the value of an object "
"indirectly, by means of their comparison implementation."
msgstr ""
":ref:`objects` の章では、オブジェクトは (型や同一性に加えて) 値を持つことを述"
"べています。\n"
"オブジェクトの値は Python ではやや抽象的な概念です: 例えば、オブジェクトの値"
"にアクセスする正統な方法はありません。\n"
"また、その全てのデータ属性から構成されるなどの特定の方法で、オブジェクトの値"
"を構築する必要性もありません。\n"
"比較演算子は、オブジェクトの値とは何かについての特定の概念を実装していま"
"す。\n"
"この比較の実装によって、間接的にオブジェクトの値を定義している考えることもで"
"きます。"

#: ../../reference/expressions.rst:1115
msgid ""
"Types can customize their comparison behavior by implementing a :meth:"
"`__cmp__` method or :dfn:`rich comparison methods` like :meth:`__lt__`, "
"described in :ref:`customization`."
msgstr ""
":ref:`customization` で解説されているように、型を使って :meth:`__cmp__` メ"
"ソッドや :dfn:`rich comparison methods` である :meth:`__lt__` などのメソッド"
"を実装することで、 比較の振る舞いをカスタマイズできます。"

#: ../../reference/expressions.rst:1120
msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based on "
"the identity of the objects.  Hence, equality comparison of instances with "
"the same identity results in equality, and equality comparison of instances "
"with different identities results in inequality.  A motivation for this "
"default behavior is the desire that all objects should be reflexive (i.e. "
"``x is y`` implies ``x == y``)."
msgstr ""
"等価性比較 (``==`` および ``!=``) のデフォルトの振る舞いは、オブジェクトの同"
"一性に基づいています。\n"
"従って、同一のインスタンスの等価性比較は等価となり、同一でないインスタンスの"
"等価性比較は等価でないとなります。\n"
"デフォルトの振る舞いをこのようにしたのは、全てのオブジェクトを反射的 "
"(reflexive つまり ``x is y`` ならば ``x == y``) なものにしたかったからです。"

#: ../../reference/expressions.rst:1127
msgid ""
"The default order comparison (``<``, ``>``, ``<=``, and ``>=``) gives a "
"consistent but arbitrary order."
msgstr ""
"デフォルトの順序比較 (``<``, ``>``, ``<=``, ``>=``) は一貫性はありますがいい"
"加減な順序です。"

#: ../../reference/expressions.rst:1130
msgid ""
"(This unusual definition of comparison was used to simplify the definition "
"of operations like sorting and the :keyword:`in` and :keyword:`not in` "
"operators. In the future, the comparison rules for objects of different "
"types are likely to change.)"
msgstr ""
"(このような比較演算の変則的な定義は、ソートのような操作や :keyword:`in` およ"
"び :keyword:`not in` といった演算子の定義を単純化するためのものです。将来、異"
"なる型のオブジェクト間における比較規則は変更されるかもしれません。)"

#: ../../reference/expressions.rst:1135
msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types "
"will need that have a sensible definition of object value and value-based "
"equality.  Such types will need to customize their comparison behavior, and "
"in fact, a number of built-in types have done that."
msgstr ""
"同一でないインスタンスは常に等価でないとする等価性比較のデフォルトの振る舞い"
"は、型が必要とするオブジェクトの値や値に基づいた等価性の実用的な定義とは対照"
"的に思えるでしょう。\n"
"そのような型では比較の振る舞いをカスタマイズする必要が出てきて、実際にたくさ"
"んの組み込み型でそれが行われています。"

#: ../../reference/expressions.rst:1141
msgid ""
"The following list describes the comparison behavior of the most important "
"built-in types."
msgstr "次のリストでは、最重要の組み込み型の比較の振る舞いを解説しています。"

#: ../../reference/expressions.rst:1144
msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard "
"library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can "
"be compared within and across their types, with the restriction that complex "
"numbers do not support order comparison.  Within the limits of the types "
"involved, they compare mathematically (algorithmically) correct without loss "
"of precision."
msgstr ""
"いくつかの組み込みの数値型 (:ref:`typesnumeric`) と標準ライブラリの型 :class:"
"`fractions.Fraction` および :class:`decimal.Decimal` は、同じ型や別の型どうし"
"で比較できますが、複素数では順序比較がサポートされていないという制限がありま"
"す。\n"
"関わる型の制限の範囲内では、精度のロス無しに数学的に (アルゴリズム的に) 正し"
"い比較が行われます。"

#: ../../reference/expressions.rst:1151
msgid ""
"Strings (instances of :class:`str` or :class:`unicode`) compare "
"lexicographically using the numeric equivalents (the result of the built-in "
"function :func:`ord`) of their characters. [#]_ When comparing an 8-bit "
"string and a Unicode string, the 8-bit string is converted to Unicode.  If "
"the conversion fails, the strings are considered unequal."
msgstr ""
"文字列 (:class:`str` もしくは :class:`unicode` のインスタンス) では、数値的な"
"同等性 (組み込み関数 :func:`ord` の結果) を使い、辞書式の比較を行います。 "
"[#]_\n"
"8 bit 文字列と Unicode 文字列を比較するときは、8 bit 文字列は Unicode へ変換"
"されます。\n"
"変換が失敗した場合は、その文字列は等価でないと見なされます。"

#: ../../reference/expressions.rst:1158
msgid ""
"Instances of :class:`tuple` or :class:`list` can be compared only within "
"each of their types.  Equality comparison across these types results in "
"unequality, and ordering comparison across these types gives an arbitrary "
"order."
msgstr ""
":class:`tuple` や :class:`list` のインスタンスは同じ型どうしでしか比較できま"
"せん。\n"
"異なる型どうしでの等価性比較は等価でないとなり、異なる型どうしでの順序比較は"
"いい加減な順序になります。"

#: ../../reference/expressions.rst:1163
msgid ""
"These sequences compare lexicographically using comparison of corresponding "
"elements, whereby reflexivity of the elements is enforced."
msgstr ""
"これらのシーケンスでは、要素の反射性があるものとして、個々の対応する要素の比"
"較を使って辞書式の比較が行われます。"

#: ../../reference/expressions.rst:1166
msgid ""
"In enforcing reflexivity of elements, the comparison of collections assumes "
"that for a collection element ``x``, ``x == x`` is always true.  Based on "
"that assumption, element identity is compared first, and element comparison "
"is performed only for distinct elements.  This approach yields the same "
"result as a strict element comparison would, if the compared elements are "
"reflexive.  For non-reflexive elements, the result is different than for "
"strict element comparison."
msgstr ""
"要素の反射性があるものとされると、コレクションの比較では、コレクションの要素 "
"``x`` に対して ``x == x`` が常に真だと仮定します。\n"
"この仮定に基づいて、最初に要素の同一性が比較され、同一でない要素どうしに対し"
"てのみ要素の比較が行われます。\n"
"この手法は、比較される要素が反射的な場合、厳密な要素比較と同じ結果をもたらし"
"ます。\n"
"反射的でない要素では、厳密な要素比較と異なる結果になります。"

#: ../../reference/expressions.rst:1174
msgid ""
"Lexicographical comparison between built-in collections works as follows:"
msgstr "組み込みのコレクションどうしの辞書式比較は次のように動作します:"

#: ../../reference/expressions.rst:1176
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal "
"(for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr ""
"比較の結果が等価となる2つのコレクションは、同じ型、同じ長さ、対応する要素どう"
"しの比較の結果が等価でなければなりません (例えば、 ``[1,2] == (1,2)`` は型が"
"同じでないので偽です)。"

#: ../../reference/expressions.rst:1181
msgid ""
"Collections are ordered the same as their first unequal elements (for "
"example, ``cmp([1,2,x], [1,2,y])`` returns the same as ``cmp(x,y)``).  If a "
"corresponding element does not exist, the shorter collection is ordered "
"first (for example, ``[1,2] < [1,2,3]`` is true)."
msgstr ""
"コレクションの順序は、最初の等価でない要素の順序と同じになります (例えば、 "
"``cmp([1,2,x], [1,2,y])`` は ``cmp(x,y)`` と同じ返り値になります)。\n"
"対応する要素が存在しない場合、短い方のコレクションが順序として先となります "
"(例えば、 ``[1,2] < [1,2,3]`` は真です)。"

#: ../../reference/expressions.rst:1187
msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they have "
"equal `(key, value)` pairs. Equality comparison of the keys and values "
"enforces reflexivity."
msgstr ""
"マッピング (:class:`dict` のインスタンス) の比較の結果が等価となるのは、同じ "
"`(key, value)` を持っているときかつそのときに限ります。\n"
"キーと値の等価性比較では反射性が強制されます。"

#: ../../reference/expressions.rst:1191
msgid ""
"Outcomes other than equality are resolved consistently, but are not "
"otherwise defined. [#]_"
msgstr ""
"等価性評価以外の結果は一貫したやりかたで解決されるか、定義されないかのいずれ"
"かです。 [#]_"

#: ../../reference/expressions.rst:1194
msgid ""
"Most other objects of built-in types compare unequal unless they are the "
"same object; the choice whether one object is considered smaller or larger "
"than another one is made arbitrarily but consistently within one execution "
"of a program."
msgstr ""
"その他のほとんどの組み込み型のオブジェクト比較では、同じオブジェクトでないか"
"ぎり等価にはなりません; あるオブジェクトの他のオブジェクトに対する大小関係は"
"任意に決定され、一つのプログラムの実行中は一貫したものとなります。"

#: ../../reference/expressions.rst:1199
msgid ""
"User-defined classes that customize their comparison behavior should follow "
"some consistency rules, if possible:"
msgstr ""
"比較の振る舞いをカスタマイズしたユーザ定義クラスは、可能なら次の一貫性の規則"
"に従う必要があります:"

#: ../../reference/expressions.rst:1202
msgid ""
"Equality comparison should be reflexive. In other words, identical objects "
"should compare equal:"
msgstr ""
"等価比較は反射的でなければなりません。\n"
"つまり、同一のオブジェクトは等しくなければなりません:"

#: ../../reference/expressions.rst:1205
msgid "``x is y`` implies ``x == y``"
msgstr "``x is y`` は暗黙的に ``x == y``"

#: ../../reference/expressions.rst:1207
msgid ""
"Comparison should be symmetric. In other words, the following expressions "
"should have the same result:"
msgstr ""
"比較は対称でなければなりません。\n"
"つまり、以下の式の結果は同じでなければなりません:"

#: ../../reference/expressions.rst:1210
msgid "``x == y`` and ``y == x``"
msgstr "``x == y`` と ``y == x``"

#: ../../reference/expressions.rst:1212
msgid "``x != y`` and ``y != x``"
msgstr "``x != y`` と ``y != x``"

#: ../../reference/expressions.rst:1214
msgid "``x < y`` and ``y > x``"
msgstr "``x < y`` と ``y > x``"

#: ../../reference/expressions.rst:1216
msgid "``x <= y`` and ``y >= x``"
msgstr "``x <= y`` と ``y >= x``"

#: ../../reference/expressions.rst:1218
msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr ""
"比較は推移的でなければなりません。\n"
"以下の (包括的でない) 例がその説明です:"

#: ../../reference/expressions.rst:1221
msgid "``x > y and y > z`` implies ``x > z``"
msgstr "``x > y and y > z`` は暗黙的に ``x > z``"

#: ../../reference/expressions.rst:1223
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr "``x < y and y <= z`` は暗黙的に ``x < z``"

#: ../../reference/expressions.rst:1225
msgid ""
"Inverse comparison should result in the boolean negation. In other words, "
"the following expressions should have the same result:"
msgstr ""
"比較の逆はブールの否定でなければなりません。\n"
"つまり、以下の式の結果は同じでなければなりません:"

#: ../../reference/expressions.rst:1228
msgid "``x == y`` and ``not x != y``"
msgstr "``x == y`` と ``not x != y``"

#: ../../reference/expressions.rst:1230
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr "``x < y`` と ``not x >= y`` (全順序の場合)"

#: ../../reference/expressions.rst:1232
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr "``x > y`` と ``not x <= y`` (全順序の場合)"

#: ../../reference/expressions.rst:1234
msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the :func:`~functools."
"total_ordering` decorator."
msgstr ""
"最後の2式は全順序の集まりに適用されます (たとえばシーケンスには適用されますが"
"セットやマッピングには適用されません)。\n"
":func:`~functools.total_ordering` デコレータも参照してください。"

#: ../../reference/expressions.rst:1238
msgid ""
"The :func:`hash` result should be consistent with equality. Objects that are "
"equal should either have the same hash value, or be marked as unhashable."
msgstr ""
":func:`hash` の結果は等価性と一貫している必要があります。\n"
"等価なオブジェクトどうしは同じハッシュ値を持つか、ハッシュ値が計算できないも"
"のとされる必要があります。"

#: ../../reference/expressions.rst:1242
msgid "Python does not enforce these consistency rules."
msgstr "Python はこれらの一貫性の規則を強制しません。"

#: ../../reference/expressions.rst:1250
msgid "Membership test operations"
msgstr "帰属検査演算"

#: ../../reference/expressions.rst:1252
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False`` "
"otherwise. ``x not in s`` returns the negation of ``x in s``.  All built-in "
"sequences and set types support this as well as dictionary, for which :"
"keyword:`in` tests whether the dictionary has a given key. For container "
"types such as list, tuple, set, frozenset, dict, or collections.deque, the "
"expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""
"演算子 :keyword:`in` および :keyword:`not in` は所属関係を調べます。 ``x in "
"s`` の評価は、 *x* が *s* の要素であれば ``True`` となり、そうでなければ "
"``False`` となります。 ``x not in s`` は ``x in s`` の否定を返します。すべて"
"の組み込みのシーケンスと集合型に加えて、辞書も、 :keyword:`in` を辞書が与えら"
"れたキーを持っているかを調べるものとしてサポートしています。リスト、タプル、"
"集合、凍結集合、辞書、あるいは collections.deque のようなコンテナ型について、"
"式 ``x in y`` は ``any(x is e or x == e for e in y)`` と等価です。"

#: ../../reference/expressions.rst:1260
msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x* is "
"a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty "
"strings are always considered to be a substring of any other string, so "
"``\"\" in \"abc\"`` will return ``True``."
msgstr ""
"文字列やバイト列型については、 ``x in y`` は *x* が *y* の部分文字列であると"
"き、かつそのときに限り ``True`` になります。これは ``y.find(x) != -1`` と等価"
"です。空文字列は、他の任意の文字列の部分文字列とみなされます。従って ``\"\" "
"in \"abc\"`` は ``True`` を返すことになります。"

#: ../../reference/expressions.rst:1265
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, ``x "
"in y`` returns ``True`` if ``y.__contains__(x)`` returns a true value, and "
"``False`` otherwise."
msgstr ""
":meth:`__contains__` メソッドを実装したユーザ定義クラスでは、 ``y."
"__contains__(x)`` の返り値が真となる場合に ``x in y`` の返り値は ``True`` と"
"なり、そうでない場合は ``False`` となります。"

#: ../../reference/expressions.rst:1269
msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is ``True`` if some value ``z`` with ``x "
"== z`` is produced while iterating over ``y``.  If an exception is raised "
"during the iteration, it is as if :keyword:`in` raised that exception."
msgstr ""
":meth:`__contains__` を定義していないが :meth:`__iter__` は定義しているユーザ"
"定義クラスでは、 ``x == z`` となるようなある値 ``z`` が ``y`` 内にわたる反復"
"で生成された場合、 ``x in y`` は ``True`` となります。\n"
"反復処理の途中で例外が送出された場合、 :keyword:`in` が例外を発生させたように"
"振る舞います。"

#: ../../reference/expressions.rst:1274
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines :meth:"
"`__getitem__`, ``x in y`` is ``True`` if and only if there is a non-negative "
"integer index *i* such that ``x == y[i]``, and all lower integer indices do "
"not raise :exc:`IndexError` exception. (If any other exception is raised, it "
"is as if :keyword:`in` raised that exception)."
msgstr ""
"最終的には、旧式の反復プロトコルの実行を試みます、もし :meth:`__getitem__` を"
"定義しているようなユーザ定義クラスでは、 ``x in y`` は ``x == y[i]`` となるよ"
"うな非負の整数インデクス *i* が存在するとき、かつそのときにかぎり ``True`` と"
"なります。インデクス *i* が負である場合に :exc:`IndexError` 例外が送出される"
"ことはありません。 (別の何らかの例外が送出された場合、例外は :keyword:`in` か"
"ら送出されたかのようになります)。"

#: ../../reference/expressions.rst:1286
msgid ""
"The operator :keyword:`not in` is defined to have the inverse true value of :"
"keyword:`in`."
msgstr ""
"演算子 :keyword:`not in` は :keyword:`in` の真値を反転した値として定義されて"
"います。"

#: ../../reference/expressions.rst:1299
msgid "Identity comparisons"
msgstr "同一性の比較"

#: ../../reference/expressions.rst:1301
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for object identity: "
"``x is y`` is true if and only if *x* and *y* are the same object.  ``x is "
"not y`` yields the inverse truth value. [#]_"
msgstr ""
"演算子 :keyword:`is` および :keyword:`is not` は、オブジェクトのアイデンティ"
"ティに対するテストを行います: ``x is y`` は、 *x* と *y* が同じオブジェクトを"
"指すとき、かつそのときに限り真になります。 ``x is not y`` は :keyword:`is` の"
"真値を反転したものになります。 [#]_"

#: ../../reference/expressions.rst:1312
msgid "Boolean operations"
msgstr "ブール演算 (boolean operation)"

#: ../../reference/expressions.rst:1323
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  (See the :meth:"
"`~object.__nonzero__` special method for a way to change this.)"
msgstr ""
"ブール演算のコンテキストや、式が制御フロー文中で使われる最には、以下の値: "
"``False`` 、 ``None`` 、すべての型における数値のゼロ、空の文字列とコンテナ "
"(文字列、タプル、リスト、辞書、set、frozenset を含む) は偽 (false) であると解"
"釈されます。それ以外の値は真 (true) であると解釈されます。 (この振る舞いを変"
"更する方法については特殊メソッド :meth:`~object.__nonzero__` を参照してくださ"
"い)"

#: ../../reference/expressions.rst:1332
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""
"演算子 :keyword:`not` は、引数が偽である場合には ``True`` を、それ以外の場合"
"には ``False`` になります。"

#: ../../reference/expressions.rst:1337
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"式 ``x and y`` は、まず *x* を評価します; *x* が偽なら *x* の値を返します; そ"
"れ以外の場合には、 *y* の値を評価し、その結果を返します。"

#: ../../reference/expressions.rst:1342
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"式 ``x or y`` は、まず *x* を評価します; *x* が真なら *x* の値を返します; そ"
"れ以外の場合には、 *y* の値を評価し、その結果を返します。"

#: ../../reference/expressions.rst:1345
msgid ""
"(Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument. This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"invent a value anyway, it does not bother to return a value of the same type "
"as its argument, so e.g., ``not 'foo'`` yields ``False``, not ``''``.)"
msgstr ""
"(:keyword:`and` も :keyword:`not` も、返す値を ``False`` や ``True`` に制限す"
"るのではなく、最後に評価した引数の値を返すので注意してください。この仕様は、"
"例えば ``s`` を文字列として ``s`` が空文字列の場合にデフォルトの値に置き換え"
"るような場合に、 ``s or 'foo'`` と書くと期待通りの値になるために便利なことが"
"あります。 :keyword:`not` は、式の値でなく独自に値を作成して返すので、引数と"
"同じ型の値を返すような処理に煩わされることはありません。例えば、 ``not "
"'foo'`` は、 ``''`` ではなく ``False`` になります)"

#: ../../reference/expressions.rst:1355
msgid "Conditional Expressions"
msgstr "条件演算 (Conditional Expressions)"

#: ../../reference/expressions.rst:1367
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr ""
"条件演算式 (しばしば、\"三項演算子\" と呼ばれます) は最も優先度が低いPython "
"の操作です。"

#: ../../reference/expressions.rst:1370
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* (*not* "
"*x*); if *C* is true, *x* is evaluated and its value is returned; otherwise, "
"*y* is evaluated and its value is returned."
msgstr ""
"``x if C else y`` という式は最初に条件 *C* (*x* では *ありません*) を評価しま"
"す; *C* が true の場合 *x* が評価され値が返されます; それ以外の場合には *y* "
"が評価され返されます。"

#: ../../reference/expressions.rst:1374
msgid "See :pep:`308` for more details about conditional expressions."
msgstr "条件演算に関してより詳しくは :pep:`308` を参照してください。"

#: ../../reference/expressions.rst:1381
msgid "Lambdas"
msgstr "ラムダ (lambda)"

#: ../../reference/expressions.rst:1391
msgid ""
"Lambda expressions (sometimes called lambda forms) have the same syntactic "
"position as expressions.  They are a shorthand to create anonymous "
"functions; the expression ``lambda parameters: expression`` yields a "
"function object.  The unnamed object behaves like a function object defined "
"with ::"
msgstr ""

#: ../../reference/expressions.rst:1399
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements."
msgstr ""
"パラメータの構文の一覧は :ref:`関数定義 <function>` を参照してください。ラム"
"ダ式で作成された関数は命令文を含むことができない点に注意してください。"

#: ../../reference/expressions.rst:1406
msgid "Expression lists"
msgstr "式のリスト"

#: ../../reference/expressions.rst:1415
msgid ""
"An expression list containing at least one comma yields a tuple.  The length "
"of the tuple is the number of expressions in the list.  The expressions are "
"evaluated from left to right."
msgstr ""
"少なくとも一つのカンマを含む式のリストは、タプルになります。タプルの長さは、"
"リスト中の式の数に等しくなります。リスト中の式は左から右へと順に評価されま"
"す。"

#: ../../reference/expressions.rst:1421
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the value "
"of that expression. (To create an empty tuple, use an empty pair of "
"parentheses: ``()``.)"
msgstr ""
"単一要素のタプル (別名 *単集合 (singleton)* ) を作りたければ、末尾にカンマが"
"必要です。単一の式だけで、末尾にカンマをつけない場合には、タプルではなくその"
"式の値になります (空のタプルを作りたいなら、中身が空の丸括弧ペア: ``()`` を使"
"います。)"

#: ../../reference/expressions.rst:1431
msgid "Evaluation order"
msgstr "評価順序"

#: ../../reference/expressions.rst:1435
msgid ""
"Python evaluates expressions from left to right. Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""
"Python は、式を左から右へと順に評価してゆきます。ただし、代入式を評価する最に"
"は、代入演算子の右側項が左側項よりも先に評価されるので注意してください。"

#: ../../reference/expressions.rst:1438
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""
"以下に示す実行文の各行での評価順序は、添え字の数字順序と同じになります::"

#: ../../reference/expressions.rst:1452
msgid "Operator precedence"
msgstr "演算子の優先順位"

#: ../../reference/expressions.rst:1456
msgid ""
"The following table summarizes the operator precedences in Python, from "
"lowest precedence (least binding) to highest precedence (most binding). "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for comparisons, including tests, which all have the "
"same precedence and chain from left to right --- see section :ref:"
"`comparisons` --- and exponentiation, which groups from right to left)."
msgstr ""
"以下の表は、Python における演算子を、優先順位の最も低い (結合度が最も低い) も"
"のから最も高い (結合度が最も高い) ものの順に並べたものです。同じボックス内に"
"示された演算子は同じ優先順位を持ちます。演算子の文法が示されていないかぎり、"
"演算子は全て二項演算子です。同じボックス内の演算子は、左から右へとグループ化"
"されます (値のテストを含む比較演算子を除きます。比較演算子は、左から右に連鎖"
"します --- :ref:`comparisons` を参照してください。また、べき乗演算子も除きま"
"す。べき乗演算子は右から左にグループ化されます)。"

#: ../../reference/expressions.rst:1465
msgid "Operator"
msgstr "演算子"

#: ../../reference/expressions.rst:1465
msgid "Description"
msgstr "説明"

#: ../../reference/expressions.rst:1467
msgid ":keyword:`lambda`"
msgstr ":keyword:`lambda`"

#: ../../reference/expressions.rst:1467
msgid "Lambda expression"
msgstr "ラムダ式"

#: ../../reference/expressions.rst:1469
msgid ":keyword:`if` -- :keyword:`else`"
msgstr ":keyword:`if` -- :keyword:`else`"

#: ../../reference/expressions.rst:1469
msgid "Conditional expression"
msgstr "条件演算"

#: ../../reference/expressions.rst:1471
msgid ":keyword:`or`"
msgstr ":keyword:`or`"

#: ../../reference/expressions.rst:1471
msgid "Boolean OR"
msgstr "ブール演算 OR"

#: ../../reference/expressions.rst:1473
msgid ":keyword:`and`"
msgstr ":keyword:`and`"

#: ../../reference/expressions.rst:1473
msgid "Boolean AND"
msgstr "ブール演算 AND"

#: ../../reference/expressions.rst:1475
msgid ":keyword:`not` ``x``"
msgstr ":keyword:`not` ``x``"

#: ../../reference/expressions.rst:1475
msgid "Boolean NOT"
msgstr "ブール演算 NOT"

#: ../../reference/expressions.rst:1477
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``<>``, ``!=``, ``==``"
msgstr ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``<>``, ``!=``, ``==``"

#: ../../reference/expressions.rst:1477
msgid "Comparisons, including membership tests and identity tests"
msgstr "帰属や同一性のテストを含む比較"

#: ../../reference/expressions.rst:1481
msgid "``|``"
msgstr "``|``"

#: ../../reference/expressions.rst:1481
msgid "Bitwise OR"
msgstr "ビット単位 OR"

#: ../../reference/expressions.rst:1483
msgid "``^``"
msgstr "``^``"

#: ../../reference/expressions.rst:1483
msgid "Bitwise XOR"
msgstr "ビット単位 XOR"

#: ../../reference/expressions.rst:1485
msgid "``&``"
msgstr "``&``"

#: ../../reference/expressions.rst:1485
msgid "Bitwise AND"
msgstr "ビット単位 AND"

#: ../../reference/expressions.rst:1487
msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

#: ../../reference/expressions.rst:1487
msgid "Shifts"
msgstr "シフト演算"

#: ../../reference/expressions.rst:1489
msgid "``+``, ``-``"
msgstr "``+``, ``-``"

#: ../../reference/expressions.rst:1489
msgid "Addition and subtraction"
msgstr "加算および減算"

#: ../../reference/expressions.rst:1491
msgid "``*``, ``/``, ``//``, ``%``"
msgstr "``*``, ``/``, ``//``, ``%``"

#: ../../reference/expressions.rst:1491
msgid "Multiplication, division, remainder [#]_"
msgstr "乗算、除算、剰余 [#]_"

#: ../../reference/expressions.rst:1494
msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

#: ../../reference/expressions.rst:1494
msgid "Positive, negative, bitwise NOT"
msgstr "正符号、負符号、ビット単位 NOT"

#: ../../reference/expressions.rst:1496
msgid "``**``"
msgstr "``**``"

#: ../../reference/expressions.rst:1496
msgid "Exponentiation [#]_"
msgstr "べき乗 [#]_"

#: ../../reference/expressions.rst:1498
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"

#: ../../reference/expressions.rst:1498
msgid "Subscription, slicing, call, attribute reference"
msgstr "添字指定、スライス操作属性参照"

#: ../../reference/expressions.rst:1501
msgid ""
"``(expressions...)``, ``[expressions...]``, ``{key: value...}``, "
"```expressions...```"
msgstr ""
"``(expressions...)``, ``[expressions...]``, ``{key: value...}``, "
"```expressions...```"

#: ../../reference/expressions.rst:1501
msgid ""
"Binding or tuple display, list display, dictionary display, string conversion"
msgstr "式結合またはタプル表現、リスト表現、辞書表現、文字列への型変換"

#: ../../reference/expressions.rst:1508
msgid "Footnotes"
msgstr "注記"

#: ../../reference/expressions.rst:1509
msgid ""
"In Python 2.3 and later releases, a list comprehension \"leaks\" the control "
"variables of each ``for`` it contains into the containing scope.  However, "
"this behavior is deprecated, and relying on it will not work in Python 3."
msgstr ""
"Python 2.3 以降のリスト内包は ``for`` の中で使う制御変数を内包表記内のスコー"
"プに「リーク」します。しかし、この挙動は廃止予定です。Python 3 ではこの挙動に"
"依存したコードは動作しなくなります。"

#: ../../reference/expressions.rst:1513
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""
"``abs(x%y) < abs(y)`` は数学的には真となりますが、浮動小数点に対する演算の場"
"合には、値丸め (roundoff) のために数値計算的に真にならない場合があります。例"
"えば、Python の浮動小数点型が IEEE754 倍精度数型になっているプラットフォーム"
"を仮定すると、 ``-1e-100 % 1e100`` は ``1e100`` と同じ符号になるはずなのに、"
"計算結果は ``-1e-100 + 1e100`` となります。これは数値計算的には厳密に "
"``1e100`` と等価です。関数 :func:`math.fmod` は、最初の引数と符号が一致するよ"
"うな値を返すので、上記の場合には ``-1e-100`` を返します。どちらのアプローチが"
"適切かは、アプリケーションに依存します。"

#: ../../reference/expressions.rst:1522
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for "
"``floor(x/y)`` to be one larger than ``(x-x%y)/y`` due to rounding.  In such "
"cases, Python returns the latter result, in order to preserve that "
"``divmod(x,y)[0] * y + x % y`` be very close to ``x``."
msgstr ""
"x が y の整数倍に非常に近い場合、丸め誤差によって ``floor(x/y)`` は ``(x-"
"x%y)/y`` よりも大きな値になる可能性があります。そのような場合、 Python は "
"``divmod(x,y)[0] * y + x % y`` が ``x`` に非常に近くなるという関係を保つため"
"に、後者の値を返します。"

#: ../../reference/expressions.rst:1527
msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) "
"and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most "
"abstract characters in Unicode are only represented using one code point, "
"there is a number of abstract characters that can in addition be represented "
"using a sequence of more than one code point.  For example, the abstract "
"character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a "
"single :dfn:`precomposed character` at code position U+00C7, or as a "
"sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL "
"LETTER C), followed by a :dfn:`combining character` at code position U+0327 "
"(COMBINING CEDILLA)."
msgstr ""
"Unicode 標準では、 :dfn:`コードポイント (code point)` (例えば、U+0041) と :"
"dfn:`抽象文字 (abstract character)` (例えば、\"LATIN CAPITAL LETTER A\") を区"
"別します。\n"
"Unicode のほとんどの抽象文字は 1 つのコードポイントだけを使って表現されます"
"が、複数のコードポイントの列を使っても表現できる抽象文字もたくさんありま"
"す。\n"
"例えば、抽象文字 \"LATIN CAPITAL LETTER C WITH CEDILLA\" はコード位置 U+00C7 "
"にある :dfn:`合成済み文字 (precomposed character)` 1 つだけでも表現できます"
"し、コード位置 U+0043 (LATIN CAPITAL LETTER C) にある :dfn:`基底文字 (base "
"character)` の後ろに、コード位置 U+0327 (COMBINING CEDILLA) にある :dfn:`結合"
"文字 (combining character)` が続く列としても表現できます。"

#: ../../reference/expressions.rst:1538
msgid ""
"The comparison operators on unicode strings compare at the level of Unicode "
"code points. This may be counter-intuitive to humans.  For example, "
"``u\"\\u00C7\" == u\"\\u0043\\u0327\"`` is ``False``, even though both "
"strings represent the same abstract character \"LATIN CAPITAL LETTER C WITH "
"CEDILLA\"."
msgstr ""
"Unicode 文字列の比較操作は Unicode のコードポイントのレベルで行われます。\n"
"これは人間にとっては直感的ではないかもしれません。\n"
"例えば、 ``u\"\\u00C7\" == u\"\\u0043\\u0327\"`` は、どちらの文字も同じ抽象文"
"字 \"LATIN CAPITAL LETTER C WITH CEDILLA\" を表現しているにもかかわらず、その"
"結果は ``False`` となります。"

#: ../../reference/expressions.rst:1543
msgid ""
"To compare strings at the level of abstract characters (that is, in a way "
"intuitive to humans), use :func:`unicodedata.normalize`."
msgstr ""
"抽象文字のレベルで (つまり、人間にとって直感的な方法で) 文字列を比較するに"
"は :func:`unicodedata.normalize` を使ってください。"

#: ../../reference/expressions.rst:1546
msgid ""
"Earlier versions of Python used lexicographic comparison of the sorted (key, "
"value) lists, but this was very expensive for the common case of comparing "
"for equality.  An even earlier version of Python compared dictionaries by "
"identity only, but this caused surprises because people expected to be able "
"to test a dictionary for emptiness by comparing it to ``{}``."
msgstr ""
"Python の初期のバージョンでは、ソートされた (key, value) のリストに対して辞書"
"的な比較を行っていましたが、これは等価性の計算のようなよくある操作を実現する"
"には非常にコストの高い操作でした。もっと以前のバージョンの Python では、辞書"
"はアイデンティティだけで比較されていました。しかしこの仕様は、 ``{}`` との比"
"較によって辞書が空であるか確かめられると期待していた人々を混乱させていまし"
"た。"

#: ../../reference/expressions.rst:1552
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""
"自動的なガベージコレクション、フリーリスト、ディスクリプタの動的特性のため"
"に、インスタンスメソッドや定数の比較を行うようなときに :keyword:`is` 演算子の"
"利用は、一見すると普通ではない振る舞いだと気付くかもしれません。詳細はそれぞ"
"れのドキュメントを確認してください。"

#: ../../reference/expressions.rst:1557
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr ""
"``%`` 演算子は文字列フォーマットにも使われ、同じ優先順位が当てはまります。"

#: ../../reference/expressions.rst:1560
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""
"べき乗演算子 ``**`` はその右側にある単項演算子かビット単位演算子よりも優先し"
"て束縛されます。つまり ``2**-1`` は ``0.5`` になります。"
