# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-16 13:40+0900\n"
"PO-Revision-Date: 2018-06-20 04:55+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/expressions.rst:6
msgid "Expressions"
msgstr "å¼ (expression)"

#: ../../reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr "ã“ã®ç« ã§ã¯ã€Python ã®å¼ã«ãŠã‘ã‚‹å€‹ã€…ã®è¦ç´ ã®æ„å‘³ã«ã¤ã„ã¦è§£èª¬ã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:14
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr "**è¡¨è¨˜æ³•ã«é–¢ã™ã‚‹æ³¨æ„:** ã“ã®ç« ã¨ä»¥é™ã®ç« ã§ã®æ‹¡å¼µBNF (extended BNF) è¡¨è¨˜ã¯ã€å­—å¥è§£æè¦å‰‡ã§ã¯ãªãã€æ§‹æ–‡è¦å‰‡ã‚’è¨˜è¿°ã™ã‚‹ãŸã‚ã«ç”¨ã„ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ã‚ã‚‹æ§‹æ–‡è¦å‰‡ (ã®ã‚ã‚‹è¡¨ç¾æ–¹æ³•) ãŒã€ä»¥ä¸‹ã®å½¢å¼"

#: ../../reference/expressions.rst:23
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr "ã§è¨˜è¿°ã•ã‚Œã¦ã„ã¦ã€ã“ã®æ§‹æ–‡ç‰¹æœ‰ã®æ„å‘³ä»˜ã‘ (semantics) ãŒè¨˜è¿°ã•ã‚Œã¦ã„ãªã„å ´åˆã€ ``name`` ã®å½¢å¼ã‚’ã¨ã‚‹æ§‹æ–‡ã®æ„å‘³ä»˜ã‘ã¯ ``othername`` ã®æ„å‘³ä»˜ã‘ã¨åŒã˜ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:30
msgid "Arithmetic conversions"
msgstr "ç®—è¡“å¤‰æ› (arithmetic conversion)"

#: ../../reference/expressions.rst:34
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type,\" the arguments are "
"coerced using the coercion rules listed at  :ref:`coercion-rules`.  If both "
"arguments are standard numeric types, the following coercions are applied:"
msgstr "ä»¥ä¸‹ã®ç®—è¡“æ¼”ç®—å­ã®è¨˜è¿°ã§ã€ã€Œæ•°å€¤å¼•æ•°ã¯å…±é€šã®å‹ã«å¤‰æ›ã•ã‚Œã¾ã™ã€ã¨æ›¸ã‹ã‚Œã¦ã„ã‚‹å ´åˆã€å¼•æ•°ã¯ :ref:`coercion-rules` ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹å‹å¼·åˆ¶è¦å‰‡ã«åŸºã¥ã„ã¦å‹å¼·åˆ¶ã•ã‚Œã¾ã™ã€‚å¼•æ•°ãŒã„ãšã‚Œã‚‚æ¨™æº–ã®æ•°å€¤å‹ã§ã‚ã‚‹å ´åˆã€ä»¥ä¸‹ã®å‹å¼·åˆ¶ãŒé©ç”¨ã•ã‚Œã¾ã™:"

#: ../../reference/expressions.rst:39
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr "ç‰‡æ–¹ã®å¼•æ•°ãŒè¤‡ç´ æ•°å‹ã§ã‚ã‚Œã°ã€ä»–æ–¹ã¯è¤‡ç´ æ•°å‹ã«å¤‰æ›ã•ã‚Œã¾ã™;"

#: ../../reference/expressions.rst:41
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr "ãã‚Œä»¥å¤–ã®å ´åˆã§ã€ç‰‡æ–¹ã®å¼•æ•°ãŒæµ®å‹•å°æ•°ç‚¹æ•°ã§ã‚ã‚Œã°ã€ä»–æ–¹ã¯æµ®å‹•å°æ•°ç‚¹å‹ã«å¤‰æ›ã•ã‚Œã¾ã™;"

#: ../../reference/expressions.rst:44
msgid ""
"otherwise, if either argument is a long integer, the other is converted to "
"long integer;"
msgstr "ãã‚Œä»¥å¤–ã®å ´åˆã§ã€ç‰‡æ–¹ã®å¼•æ•°ãŒé•·æ•´æ•°å‹ã§ã‚ã‚Œã°ã€ä»–æ–¹ã¯é•·æ•´æ•°å‹ã«å¤‰æ›ã•ã‚Œã¾ã™;"

#: ../../reference/expressions.rst:47
msgid "otherwise, both must be plain integers and no conversion is necessary."
msgstr "ãã‚Œä»¥å¤–ã®å ´åˆã§ã€ä¸¡æ–¹ã®å¼•æ•°ãŒé€šå¸¸ã®æ•´æ•°å‹ã§ã‚ã‚Œã°ã€å¤‰æ›ã®å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/expressions.rst:49
msgid ""
"Some additional rules apply for certain operators (e.g., a string left "
"argument to the '%' operator). Extensions can define their own coercions."
msgstr "ç‰¹å®šã®æ¼”ç®—å­ (æ–‡å­—åˆ—ã‚’å·¦å¼•æ•°ã¨ã™ã‚‹ '%' æ¼”ç®—å­ãªã©) ã§ã¯ã€ã•ã‚‰ã«åˆ¥ã®è¦å‰‡ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚æ‹¡å¼µã‚’ãŠã“ãªã†ã“ã¨ã§ã€å€‹ã€…ã®æ¼”ç®—å­ã«å¯¾ã™ã‚‹å‹å¼·åˆ¶ã‚’å®šç¾©ã§ãã¾ã™ã€‚"

#: ../../reference/expressions.rst:56
msgid "Atoms"
msgstr "ã‚¢ãƒˆãƒ ã€åŸå­çš„è¦ç´  (atom)"

#: ../../reference/expressions.rst:60
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in reverse quotes or in "
"parentheses, brackets or braces are also categorized syntactically as atoms."
"  The syntax for atoms is:"
msgstr "ã‚¢ãƒˆãƒ  (åŸå­çš„è¦ç´ : atom) ã¯ã€å¼ã‚’æ§‹æˆã™ã‚‹åŸºæœ¬å˜ä½ã§ã™ã€‚ã‚‚ã£ã¨ã‚‚å˜ç´”ãªã‚¢ãƒˆãƒ ã¯ã€è­˜åˆ¥å­ã¾ãŸã¯ãƒªãƒ†ãƒ©ãƒ«ã«ãªã‚Šã¾ã™ã€‚é€†ã‚¯ã‚ªãƒ¼ãƒˆã‚„ä¸¸æ‹¬å¼§ã€æ³¢æ‹¬å¼§ã€ã¾ãŸã¯è§’æ‹¬å¼§ã§å›²ã‚ã‚ŒãŸå½¢å¼ (form) ã‚‚ã¾ãŸã€æ–‡æ³•çš„ã«ã¯ã‚¢ãƒˆãƒ ã«åˆ†é¡ã•ã‚Œã¾ã™ã€‚ã‚¢ãƒˆãƒ ã®æ§‹æ–‡å®šç¾©ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™:"

#: ../../reference/expressions.rst:75
msgid "Identifiers (Names)"
msgstr "è­˜åˆ¥å­ (identifierã€ã¾ãŸã¯åå‰ (name))"

#: ../../reference/expressions.rst:81
msgid ""
"An identifier occurring as an atom is a name.  See section "
":ref:`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr "ã‚¢ãƒˆãƒ ã®å½¢ã«ãªã£ã¦ã„ã‚‹è­˜åˆ¥å­ (identifier) ã¯åå‰ (name) ã§ã™ã€‚å­—å¥å®šç¾©ã«ã¤ã„ã¦ã¯ :ref:`identifiers` ç¯€ã‚’ã€åå‰ä»˜ã‘ã‚„æŸç¸›ã«ã¤ã„ã¦ã¯ :ref:`naming` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:87
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a "
":exc:`NameError` exception."
msgstr "åå‰ãŒã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹å ´åˆã€åå‰ atom ã‚’è©•ä¾¡ã™ã‚‹ã¨ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚åå‰ãŒæŸç¸›ã•ã‚Œã¦ã„ãªã„å ´åˆã€ atom ã‚’è©•ä¾¡ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ :exc:`NameError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:95
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name, with leading"
" underscores removed and a single underscore inserted, in front of the name."
"  For example, the identifier ``__spam`` occurring in a class named ``Ham`` "
"will be transformed to ``_Ham__spam``.  This transformation is independent "
"of the syntactical context in which the identifier is used.  If the "
"transformed name is extremely long (longer than 255 characters), "
"implementation defined truncation may happen. If the class name consists "
"only of underscores, no transformation is done."
msgstr "**ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªåå‰ã®åå‰ä¿®é£¾:** ã‚¯ãƒ©ã‚¹å®šç¾©å†…ã«æ›¸ã‹ã‚ŒãŸè­˜åˆ¥å­ã§ã€2ã¤ä»¥ä¸Šã®ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã‹ã‚‰å§‹ã¾ã‚Šã€æœ«å°¾ãŒ2ã¤ä»¥ä¸Šã®ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã§çµ‚ã‚ã£ã¦ã„ãªã„ã‚‚ã®ã¯ã€ãã®ã‚¯ãƒ©ã‚¹ã® :dfn:`ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªåå‰` ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªåå‰ã¯ã€ã‚³ãƒ¼ãƒ‰ãŒç”Ÿæˆã•ã‚Œã‚‹å‰ã«ã‚ˆã‚Šé•·ã„å½¢å¼ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚ã“ã®å¤‰æ›ã«ã‚ˆã£ã¦ã€ã‚¯ãƒ©ã‚¹åã®å…ˆé ­ã«ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ãŒã‚ã‚Œã°é™¤å»ã—ã€å…ˆé ­ã«ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã‚’1ã¤ä»˜åŠ ã—ã€åå‰ã®å‰ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚¯ãƒ©ã‚¹å ``Ham`` ã®ä¸­ã®è­˜åˆ¥å­ ``__spam`` ã¯ã€``_Ham__spam`` ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚å¤‰æ›ã¯è­˜åˆ¥å­ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹æ§‹æ–‡ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã¯ç‹¬ç«‹ã—ã¦ã„ã¾ã™ã€‚å¤‰æ›ã•ã‚ŒãŸåå‰ãŒéå¸¸ã«é•·ã„ (255æ–‡å­—ã‚’è¶…ãˆã‚‹) å ´åˆã€å®Ÿè£…ã«ã‚ˆã£ã¦ã¯åå‰ã®åˆ‡ã‚Šè©°ã‚ãŒè¡Œã‚ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¹åãŒã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã®ã¿ã‹ã‚‰æˆã‚‹å ´åˆã¯å¤‰æ›ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/expressions.rst:112
msgid "Literals"
msgstr "ãƒªãƒ†ãƒ©ãƒ«"

#: ../../reference/expressions.rst:116
msgid "Python supports string literals and various numeric literals:"
msgstr "Python ã§ã¯ã€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¨ã€æ§˜ã€…ãªæ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™:"

#: ../../reference/expressions.rst:122
msgid ""
"Evaluation of a literal yields an object of the given type (string, integer,"
" long integer, floating point number, complex number) with the given value."
"  The value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr "ãƒªãƒ†ãƒ©ãƒ«ã‚’è©•ä¾¡ã™ã‚‹ã¨ã€æŒ‡å®šã—ãŸå‹ (æ–‡å­—åˆ—ã€æ•´æ•°ã€é•·æ•´æ•°ã€æµ®å‹•å°æ•°ç‚¹æ•°ã€è¤‡ç´ æ•°) ã®æŒ‡å®šã—ãŸå€¤ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚æµ®å‹•å°æ•°ç‚¹ã‚„è™šæ•° (è¤‡ç´ æ•°) ãƒªãƒ†ãƒ©ãƒ«ã®å ´åˆã€å€¤ã¯è¿‘ä¼¼å€¤ã«ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚è©³ã—ãã¯ :ref:`literals` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:131
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals"
" with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr "ãƒªãƒ†ãƒ©ãƒ«ã¯å…¨ã¦å¤‰æ›´ä¸èƒ½ãªãƒ‡ãƒ¼ã‚¿å‹ã«å¯¾å¿œã—ã¾ã™ã€‚ã“ã®ãŸã‚ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã»ã©é‡è¦ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚åŒã˜å€¤ã‚’æŒã¤è¤‡æ•°ã®ãƒªãƒ†ãƒ©ãƒ«ã‚’è©•ä¾¡ã—ãŸå ´åˆã€(ãã‚Œã‚‰ã®ãƒªãƒ†ãƒ©ãƒ«ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®åŒã˜å ´æ‰€ç”±æ¥ã®ã‚‚ã®ã§ã‚ã£ã¦ã‚‚ã€ãã†ã§ãªãã¦ã‚‚) åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã—ã¦ã„ã‚‹ã‹ã€ã¾ã£ãŸãåŒã˜å€¤ã‚’æŒã¤åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:141
msgid "Parenthesized forms"
msgstr "ä¸¸æ‹¬å¼§å½¢å¼ (parenthesized form)"

#: ../../reference/expressions.rst:145
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr "ä¸¸æ‹¬å¼§å½¢å¼ã¨ã¯ã€å¼ãƒªã‚¹ãƒˆã®ä¸€å½¢æ…‹ã§ã€ä¸¸æ‹¬å¼§ã§å›²ã£ãŸã‚‚ã®ã§ã™:"

#: ../../reference/expressions.rst:150
msgid ""
"A parenthesized expression list yields whatever that expression list yields:"
" if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr "ä¸¸æ‹¬å¼§ã§å›²ã‚ã‚ŒãŸå¼ã®ãƒªã‚¹ãƒˆã¯ã€å€‹ã€…ã®å¼ãŒè¡¨ç¾ã™ã‚‹ã‚‚ã®ã«ãªã‚Šã¾ã™: ãƒªã‚¹ãƒˆå†…ã«å°‘ãªãã¨ã‚‚ä¸€ã¤ã®ã‚«ãƒ³ãƒãŒå…¥ã£ã¦ã„ãŸå ´åˆã€ã‚¿ãƒ—ãƒ«ã«ãªã‚Šã¾ã™; ãã†ã§ãªã„å ´åˆã€å¼ã®ãƒªã‚¹ãƒˆã‚’æ§‹æˆã—ã¦ã„ã‚‹å˜ä¸€ã®å¼è‡ªä½“ã®å€¤ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:156
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are"
" immutable, the rules for literals apply (i.e., two occurrences of the empty"
" tuple may or may not yield the same object)."
msgstr "ä¸­èº«ãŒç©ºã®ä¸¸æ‹¬å¼§ã®ãƒšã‚¢ã¯ã€ç©ºã®ã‚¿ãƒ—ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã—ã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã¯å¤‰æ›´ä¸èƒ½ãªã®ã§ã€ãƒªãƒ†ãƒ©ãƒ«ã¨åŒã˜è¦å‰‡ãŒé©ç”¨ã•ã‚Œã¾ã™ (ã™ãªã‚ã¡ã€ç©ºã®ã‚¿ãƒ—ãƒ«ãŒäºŒç®‡æ‰€ã§ä½¿ã‚ã‚Œã‚‹ã¨ã€ãã‚Œã‚‰ã¯åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚‹ã“ã¨ã‚‚ã‚ã‚‹ã—ã€ãªã‚‰ãªã„ã“ã¨ã‚‚ã‚ã‚Šã¾ã™)ã€‚"

#: ../../reference/expressions.rst:164
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the"
" comma operator.  The exception is the empty tuple, for which parentheses "
"*are* required --- allowing unparenthesized \"nothing\" in expressions would"
" cause ambiguities and allow common typos to pass uncaught."
msgstr "ã‚¿ãƒ—ãƒ«ã¯ä¸¸æ‹¬å¼§ã§ä½œæˆã•ã‚Œã‚‹ã®ã§ã¯ãªãã€ã‚«ãƒ³ãƒã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ä¾‹å¤–ã¯ç©ºã®ã‚¿ãƒ—ãƒ«ã§ã€ã“ã®å ´åˆã«ã¯ä¸¸æ‹¬å¼§ãŒ *å¿…è¦ã§ã™* --- ä¸¸æ‹¬å¼§ã®ã¤ã‹ãªã„ \"ä½•ã‚‚è¨˜è¿°ã—ãªã„å¼ (nothing)\" ã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ã—ã¦ã—ã¾ã†ã¨ã€æ–‡æ³•ãŒã‚ã„ã¾ã„ãªã‚‚ã®ã«ãªã£ã¦ã—ã¾ã„ã€ã‚ˆãã‚ã‚‹ã‚¿ã‚¤ãƒ—ãƒŸã‚¹ãŒæ¤œå‡ºã•ã‚Œãªããªã£ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../reference/expressions.rst:173
msgid "List displays"
msgstr "ãƒªã‚¹ãƒˆè¡¨ç¾"

#: ../../reference/expressions.rst:179
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr "ãƒªã‚¹ãƒˆè¡¨ç¾ã¯ã€è§’æ‹¬å¼§ã§å›²ã‚ã‚ŒãŸå¼ã®ç³»åˆ—ã§ã™ã€‚ç³»åˆ—ã¯ç©ºã®ç³»åˆ—ã§ã‚ã£ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“:"

#: ../../reference/expressions.rst:196
msgid ""
"A list display yields a new list object.  Its contents are specified by "
"providing either a list of expressions or a list comprehension.  When a "
"comma-separated list of expressions is supplied, its elements are evaluated "
"from left to right and placed into the list object in that order.  When a "
"list comprehension is supplied, it consists of a single expression followed "
"by at least one :keyword:`for` clause and zero or more :keyword:`for` or "
":keyword:`if` clauses.  In this case, the elements of the new list are those"
" that would be produced by considering each of the :keyword:`for` or "
":keyword:`if` clauses a block, nesting from left to right, and evaluating "
"the expression to produce a list element each time the innermost block is "
"reached [#]_."
msgstr "ãƒªã‚¹ãƒˆè¡¨ç¾ã¯ã€æ–°ã«ä½œæˆã•ã‚ŒãŸãƒªã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã—ã¾ã™ã€‚æ–°ãŸãªãƒªã‚¹ãƒˆã®å†…å®¹ã¯ã€å¼ã®ãƒªã‚¹ãƒˆã‚’ä¸ãˆã‚‹ã‹ã€ãƒªã‚¹ãƒˆã®å†…åŒ…è¡¨è¨˜ (list comprehension) ã§æŒ‡å®šã—ã¾ã™ã€‚ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸå¼ã®ãƒªã‚¹ãƒˆã‚’ä¸ãˆãŸå ´åˆã€ãƒªã‚¹ãƒˆã®å„è¦ç´ ã¯å·¦ã‹ã‚‰å³ã¸ã¨é †ã«è©•ä¾¡ã•ã‚Œã€è©•ä¾¡ã•ã‚ŒãŸé †ç•ªã«ãƒªã‚¹ãƒˆå†…ã«é…ç½®ã•ã‚Œã¾ã™ã€‚ãƒªã‚¹ãƒˆã®å†…åŒ…è¡¨è¨˜ã‚’ä¸ãˆã‚‹å ´åˆã€å†…åŒ…è¡¨è¨˜ã¯ã¾ãšå˜ä¸€ã®å¼ã€ç¶šã„ã¦å°‘ãªãã¨ã‚‚ä¸€ã¤ã® :keyword:`for` ç¯€ã€ç¶šã„ã¦ã‚¼ãƒ­å€‹ä»¥ä¸Šã® :keyword:`for` ç¯€ã‹ :keyword:`if` ç¯€ã«ãªã‚Šã¾ã™ã€‚ã“ã®å ´åˆã€æ–°ãŸã«ä½œæˆã•ã‚Œã‚‹ãƒªã‚¹ãƒˆã®å„è¦ç´ ã¯ã€å„ã€…ã® :keyword:`for` ã‚„ :keyword:`if` ç¯€ã‚’å·¦ã‹ã‚‰å³ã®é †ã«ãƒã‚¹ãƒˆã—ãŸãƒ–ãƒ­ãƒƒã‚¯ã¨ã¿ãªã—ã¦å®Ÿè¡Œã—ã€ãƒã‚¹ãƒˆã®æœ€å†…ãƒ–ãƒ­ãƒƒã‚¯ã«åˆ°é”ã™ã‚‹åº¦ã«å¼ã‚’è©•ä¾¡ã—ãŸå€¤ã¨ãªã‚Šã¾ã™ã€‚ [#]_"

#: ../../reference/expressions.rst:211
msgid "Displays for sets and dictionaries"
msgstr "é›†åˆã¨è¾æ›¸ã®è¡¨ç¾"

#: ../../reference/expressions.rst:213
msgid ""
"For constructing a set or a dictionary Python provides special syntax called"
" \"displays\", each of them in two flavors:"
msgstr "Python ã¯ã€é›†åˆã‚„è¾æ›¸ã‚’æ§‹æˆã™ã‚‹ãŸã‚ã«ã€\"è¡¨ç¾ (display)\" ã¨å‘¼ã°ã‚Œã‚‹ç‰¹æ®Šãªæ§‹æ–‡ã‚’ã€ãã‚Œãã‚ŒäºŒç¨®é¡ã¥ã¤æä¾›ã—ã¦ã„ã¦ã€ã‚³ãƒ³ãƒ†ãƒŠã®å†…å®¹ã¯:"

#: ../../reference/expressions.rst:216
msgid "either the container contents are listed explicitly, or"
msgstr "æ˜ç¤ºçš„ã«åˆ—æŒ™ã•ã‚Œã‚‹ã€ã¾ãŸã¯"

#: ../../reference/expressions.rst:218
msgid ""
"they are computed via a set of looping and filtering instructions, called a "
":dfn:`comprehension`."
msgstr ":dfn:`å†…åŒ…è¡¨è¨˜ (comprehension)` ã¨å‘¼ã°ã‚Œã‚‹ã€ãƒ«ãƒ¼ãƒ—å‡¦ç†ã¨ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å‡¦ç†ã®å‘½ä»¤ã®çµ„ã¿åˆã‚ã›ã‚’é€šã˜ã¦è¨ˆç®—ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:221
msgid "Common syntax elements for comprehensions are:"
msgstr "å†…åŒ…è¡¨è¨˜ã®å…±é€šã®æ§‹æ–‡è¦ç´ ã¯ã“ã®é€šã‚Šã§ã™:"

#: ../../reference/expressions.rst:229
msgid ""
"The comprehension consists of a single expression followed by at least one "
":keyword:`for` clause and zero or more :keyword:`for` or :keyword:`if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`for` or :keyword:`if`"
" clauses a block, nesting from left to right, and evaluating the expression "
"to produce an element each time the innermost block is reached."
msgstr "å†…åŒ…è¡¨è¨˜ã¯ã¾ãšå˜ä¸€ã®å¼ã€ç¶šã„ã¦ :keyword:`for` ç¯€ã€ã•ã‚‰ã«ç¶šã„ã¦ 0 å€‹ä»¥ä¸Šã® :keyword:`for` ç¯€ã‚„ :keyword:`if` ç¯€ã‹ã‚‰ãªã‚Šã¾ã™ã€‚ã“ã®å ´åˆã€æ–°ãŸãªã‚³ãƒ³ãƒ†ãƒŠã®å„è¦ç´ ã¯ã€å„ã€…ã® :keyword:`for` ã‚„ :keyword:`if` ç¯€ã‚’ã€å·¦ã‹ã‚‰å³ã«ãƒã‚¹ãƒˆã—ãŸãƒ–ãƒ­ãƒƒã‚¯ã¨ã¿ãªã—ã¦å®Ÿè¡Œã—ã€ãƒã‚¹ãƒˆã®æœ€å†…ã®ãƒ–ãƒ­ãƒƒã‚¯ã«åˆ°é”ã™ã‚‹åº¦ã«å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ä½œæˆã•ã‚ŒãŸã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:236
msgid ""
"Note that the comprehension is executed in a separate scope, so names "
"assigned to in the target list don't \"leak\" in the enclosing scope."
msgstr "ãªãŠã€ã“ã‚Œã‚‰ã®å†…åŒ…è¡¨è¨˜ã¯åˆ¥ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§å®Ÿè¡Œã•ã‚Œã‚‹ã®ã§ã€å¯¾è±¡ã®ãƒªã‚¹ãƒˆå†…ã§ä»£å…¥ã•ã‚ŒãŸåå‰ãŒå¤–å´ã®ã‚¹ã‚³ãƒ¼ãƒ—ã« \"æ¼ã‚Œã‚‹\" ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/expressions.rst:243
msgid "Generator expressions"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼"

#: ../../reference/expressions.rst:248
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ (generator expression) ã¨ã¯ã€ä¸¸æ‹¬å¼§ã‚’ä½¿ã£ãŸã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿è¡¨è¨˜æ³•ã§ã™:"

#: ../../reference/expressions.rst:253
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã¯æ–°ãŸãªã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¸ãˆã¾ã™ã€‚ã“ã®æ§‹æ–‡ã¯å†…åŒ…è¡¨è¨˜ã¨ã»ã¼åŒã˜ã§ã™ãŒã€è§’æ‹¬å¼§ã‚„æ³¢æ‹¬å¼§ã§ã¯ãªãã€ä¸¸æ‹¬å¼§ã§å›²ã¾ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:257
msgid ""
"Variables used in the generator expression are evaluated lazily when the "
":meth:`__next__` method is called for generator object (in the same fashion "
"as normal generators).  However, the leftmost :keyword:`for` clause is "
"immediately evaluated, so that an error produced by it can be seen before "
"any other possible error in the code that handles the generator expression."
"  Subsequent :keyword:`for` clauses cannot be evaluated immediately since "
"they may depend on the previous :keyword:`for` loop. For example: ``(x*y for"
" x in range(10) for y in bar(x))``."
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã§ä½¿ã‚ã‚Œã‚‹å¤‰æ•°ã¯ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã« :meth:`next` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã«é…å»¶è©•ä¾¡ã•ã‚Œã¾ã™ (é€šå¸¸ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¨åŒã˜æµå„€ã§ã™)ã€‚ã—ã‹ã—ã€æœ€ã‚‚å·¦ã«ä½ç½®ã™ã‚‹ :keyword:`for` ç¯€ã¯ç›´ã¡ã«è©•ä¾¡ã•ã‚Œã‚‹ãŸã‚ã€ãã“ã§ç”Ÿã˜ãŸã‚¨ãƒ©ãƒ¼ã¯ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã‚’æ‰±ã†ã‚³ãƒ¼ãƒ‰ã§èµ·ã“ã‚Šãˆã‚‹ä»–ã®ã‚¨ãƒ©ãƒ¼ã®å‰ã«ç¾ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ãã®å¾Œã«ç¶šã :keyword:`for` ç¯€ã¯ã€ãã®å‰ã® :keyword:`for` ãƒ«ãƒ¼ãƒ—ã«ä¾å­˜ã—ã¦ã„ã‚‹ãŸã‚ã€ç›´ã¡ã«ã¯è©•ä¾¡ã•ã‚Œã¾ã›ã‚“ã€‚ä¾‹: ``(x*y for x in range(10) for y in bar(x))``"

#: ../../reference/expressions.rst:266
msgid ""
"The parentheses can be omitted on calls with only one argument.  See section"
" :ref:`calls` for the detail."
msgstr "é–¢æ•°ã®å”¯ä¸€ã®å¼•æ•°ã¨ã—ã¦æ¸¡ã™å ´åˆã«ã¯ã€ä¸¸æ‹¬å¼§ã‚’çœç•¥ã§ãã¾ã™ã€‚è©³ã—ãã¯ :ref:`calls` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:272
msgid "Dictionary displays"
msgstr "è¾æ›¸è¡¨ç¾"

#: ../../reference/expressions.rst:278
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs enclosed "
"in curly braces:"
msgstr "è¾æ›¸è¡¨ç¾ã¯ã€æ³¢æ‹¬å¼§ã§å›²ã‚ã‚ŒãŸã€ã‚­ãƒ¼ã¨å€¤ã®ãƒšã‚¢ã‹ã‚‰ãªã‚‹ç³»åˆ—ã§ã™ã€‚ç³»åˆ—ã¯ç©ºã®ç³»åˆ—ã§ã‚ã£ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“:"

#: ../../reference/expressions.rst:287
msgid "A dictionary display yields a new dictionary object."
msgstr "è¾æ›¸è¡¨ç¾ã¯ã€æ–°ãŸãªè¾æ›¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:289
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: each "
"key object is used as a key into the dictionary to store the corresponding "
"datum.  This means that you can specify the same key multiple times in the "
"key/datum list, and the final dictionary's value for that key will be the "
"last one given."
msgstr "ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã®ä¸€é€£ã®ã‚­ãƒ¼/ãƒ‡ãƒ¼ã‚¿ã®å¯¾ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã¯ã€ãã®è¦ç´ ã¯å·¦ã‹ã‚‰å³ã¸è©•ä¾¡ã•ã‚Œã€è¾æ›¸ã®é …ç›®ã‚’å®šç¾©ã—ã¾ã™ã€‚ã™ãªã‚ã¡ã€ãã‚Œãã‚Œã®ã‚­ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã€è¾æ›¸å†…ã§å¯¾å¿œã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã™ã‚‹ã‚­ãƒ¼ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚­ãƒ¼/ãƒ‡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆã®ä¸­ã§åŒã˜ã‚­ãƒ¼ã‚’è¤‡æ•°å›æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã€ãã®ã‚­ãƒ¼ã«å¯¾ã™ã‚‹æœ€çµ‚çš„ãªè¾æ›¸ã®å€¤ã¯ã€æœ€å¾Œã«ä¸ãˆã‚‰ã‚ŒãŸã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:295
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements"
" are inserted in the new dictionary in the order they are produced."
msgstr "è¾æ›¸å†…åŒ…è¡¨è¨˜ã¯ã€ãƒªã‚¹ãƒˆã‚„é›†åˆã®å†…åŒ…è¡¨è¨˜ã¨ã¯å¯¾ç…§çš„ã«ã€é€šå¸¸ã® \"for\" ã‚„ \"if\" ç¯€ã®å‰ã«ã€ã‚³ãƒ­ãƒ³ã§åˆ†ã‘ã‚‰ã‚ŒãŸ 2 ã¤ã®å¼ãŒå¿…è¦ã§ã™ã€‚å†…åŒ…è¡¨è¨˜ãŒèµ·å‹•ã™ã‚‹ã¨ã€çµæœã®ã‚­ãƒ¼ã¨å€¤ã®è¦ç´ ãŒã€ä½œã‚‰ã‚ŒãŸé †ã«æ–°ã—ã„è¾æ›¸ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:303
msgid ""
"Restrictions on the types of the key values are listed earlier in section "
":ref:`types`.  (To summarize, the key type should be :term:`hashable`, which"
" excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last datum (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr "ã‚­ãƒ¼ã®å€¤ã¨ã—ã¦ä½¿ãˆã‚‹å‹ã«é–¢ã™ã‚‹åˆ¶é™ã¯ :ref:`types` ç¯€ã§ã™ã§ã«åˆ—æŒ™ã—ã¦ã„ã¾ã™ã€‚(ä¸€è¨€ã§ã„ã†ã¨ã€ã‚­ãƒ¼ã¯å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å…¨ã¦æ’é™¤ã—ãŸ :term:`hashable` ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚) é‡è¤‡ã™ã‚‹ã‚­ãƒ¼é–“ã§è¡çªãŒèµ·ãã¦ã‚‚ã€è¡çªãŒæ¤œå‡ºã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“; ã‚ã‚‹ã‚­ãƒ¼ã«å¯¾ã—ã¦ã€æœ€å¾Œã«æ¸¡ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ (ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ†ã‚­ã‚¹ãƒˆä¸Šã§ã¯ã€è¾æ›¸è¡¨è¨˜ã®æœ€ã‚‚å³å´å€¤ã¨ãªã‚‹ã‚‚ã®) ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:313
msgid "Set displays"
msgstr "é›†åˆè¡¨ç¾"

#: ../../reference/expressions.rst:318
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary"
" displays by the lack of colons separating keys and values:"
msgstr "é›†åˆè¡¨ç¾ã¯æ³¢æ‹¬å¼§ã§è¡¨ã•ã‚Œã€ã‚­ãƒ¼ã¨å€¤ã‚’åˆ†ã‘ã‚‹ã‚³ãƒ­ãƒ³ãŒãªã„ã“ã¨ã§è¾æ›¸è¡¨ç¾ã¨åŒºåˆ¥ã•ã‚Œã¾ã™:"

#: ../../reference/expressions.rst:324
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr "é›†åˆè¡¨ç¤ºã¯ã€ä¸€é€£ã®å¼ã¾ãŸã¯å†…åŒ…è¡¨è¨˜ã«ã‚ˆã£ã¦æŒ‡å®šã•ã‚ŒãŸå†…å®¹ã®ã€ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªé›†åˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¸ãˆã¾ã™ã€‚ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã®ä¸€é€£ã®å¼ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã¯ã€ãã®è¦ç´ ã¯å·¦ã‹ã‚‰å³ã¸é †ã«è©•ä¾¡ã•ã‚Œã€é›†åˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åŠ ãˆã‚‰ã‚Œã¾ã™ã€‚å†…åŒ…è¡¨è¨˜ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã¯ã€å†…åŒ…è¡¨è¨˜ã®çµæœã¨ãªã‚‹è¦ç´ ã§é›†åˆãŒæ§‹æˆã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:330
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr "ç©ºé›†åˆã¯ ``{}`` ã§æ§‹æˆã§ãã¾ã›ã‚“ã€‚ã“ã®ãƒªãƒ†ãƒ©ãƒ«ã¯ç©ºã®è¾æ›¸ã‚’æ§‹æˆã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:337
msgid "String conversions"
msgstr "æ–‡å­—åˆ—å¤‰æ›"

#: ../../reference/expressions.rst:345
msgid ""
"A string conversion is an expression list enclosed in reverse (a.k.a. "
"backward) quotes:"
msgstr "æ–‡å­—åˆ—å¤‰æ›ã¯ã€é€†ã‚¯ã‚ªãƒ¼ãƒˆ (reverse quite, åˆ¥åãƒãƒƒã‚¯ã‚¯ã‚ªãƒ¼ãƒˆ: backward quote) ã§å›²ã‚ã‚ŒãŸå¼ã®ãƒªã‚¹ãƒˆã§ã™:"

#: ../../reference/expressions.rst:351
msgid ""
"A string conversion evaluates the contained expression list and converts the"
" resulting object into a string according to rules specific to its type."
msgstr "æ–‡å­—åˆ—å¤‰æ›ã¯ã€é€†ã‚¯ã‚ªãƒ¼ãƒˆå†…ã®å¼ãƒªã‚¹ãƒˆã‚’è©•ä¾¡ã—ã¦ã€è©•ä¾¡çµæœã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ç‰¹æœ‰ã®è¦å‰‡ã«å¾“ã£ã¦æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:354
msgid ""
"If the object is a string, a number, ``None``, or a tuple, list or "
"dictionary containing only objects whose type is one of these, the resulting"
" string is a valid Python expression which can be passed to the built-in "
"function :func:`eval` to yield an expression with the same value (or an "
"approximation, if floating point numbers are involved)."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ–‡å­—åˆ—ã€æ•°å€¤ã€ ``None`` ã‹ã€ãã‚Œã‚‰ã®å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã€ãƒªã‚¹ãƒˆã¾ãŸã¯è¾æ›¸ã®å ´åˆã€è©•ä¾¡çµæœã®æ–‡å­—åˆ—ã¯æœ‰åŠ¹ãª Python å¼ã¨ãªã‚Šã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`eval` ã«æ¸¡ã—ãŸå ´åˆã«åŒã˜å€¤ã¨ãªã‚Šã¾ã™ (æµ®å‹•å°æ•°ç‚¹ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯è¿‘ä¼¼å€¤ã®å ´åˆã‚‚ã‚ã‚Šã¾ã™)ã€‚"

#: ../../reference/expressions.rst:360
msgid ""
"(In particular, converting a string adds quotes around it and converts "
"\"funny\" characters to escape sequences that are safe to print.)"
msgstr "(ç‰¹ã«ã€æ–‡å­—åˆ—ã‚’å¤‰æ›ã™ã‚‹ã¨ã€å€¤ã‚’å®‰å…¨ã«å‡ºåŠ›ã™ã‚‹ãŸã‚ã«æ–‡å­—åˆ—ã®ä¸¡å´ã«ã‚¯ã‚ªãƒ¼ãƒˆãŒä»˜ã‘ã‚‰ã‚Œã€\"å¤‰ (funny) ãª\" æ–‡å­—ã¯ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚)"

#: ../../reference/expressions.rst:365
msgid ""
"Recursive objects (for example, lists or dictionaries that contain a "
"reference to themselves, directly or indirectly) use ``...`` to indicate a "
"recursive reference, and the result cannot be passed to :func:`eval` to get "
"an equal value (:exc:`SyntaxError` will be raised instead)."
msgstr "å†å¸°çš„ãªæ§‹é€ ã‚’ã‚‚ã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ä¾‹ãˆã°è‡ªåˆ†è‡ªèº«ã‚’ç›´æ¥ã¾ãŸã¯é–“æ¥çš„ã«å«ã‚€ãƒªã‚¹ãƒˆã‚„è¾æ›¸) ã§ã¯ ``...`` ã‚’ä½¿ã£ã¦å†å¸°çš„å‚ç…§ã§ã‚ã‚‹ã“ã¨ãŒç¤ºã•ã‚Œã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è©•ä¾¡çµæœã¯ :func:`eval` ã«æ¸¡ã—ã¦ã‚‚ç­‰ä¾¡ãªå€¤ã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ (:exc:`SyntaxError` ãŒé€å‡ºã•ã‚Œã¾ã™)ã€‚"

#: ../../reference/expressions.rst:374
msgid ""
"The built-in function :func:`repr` performs exactly the same conversion in "
"its argument as enclosing it in parentheses and reverse quotes does.  The "
"built-in function :func:`str` performs a similar but more user-friendly "
"conversion."
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•° :func:`repr` ã¯ã€æ‹¬å¼§å†…ã®å¼•æ•°ã«å¯¾ã—ã¦ã€é€†ã‚¯ã‚ªãƒ¼ãƒˆè¡¨è¨˜ã§å›²ã‚ã‚ŒãŸä¸­èº«ã¨å…¨ãåŒã˜å¤‰æ›ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚çµ„ã¿è¾¼ã¿é–¢æ•° :func:`str` ã¯ä¼¼ãŸã‚ˆã†ãªå‹•ä½œã‚’ã—ã¾ã™ãŒã€ã‚‚ã£ã¨ãƒ¦ãƒ¼ã‚¶ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãªå¤‰æ›ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:382
msgid "Yield expressions"
msgstr "Yield å¼"

#: ../../reference/expressions.rst:395
msgid ""
"The :keyword:`yield` expression is only used when defining a generator "
"function, and can only be used in the body of a function definition. Using a"
" :keyword:`yield` expression in a function definition is sufficient to cause"
" that definition to create a generator function instead of a normal "
"function."
msgstr ":keyword:`yield` å¼ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã‚’å®šç¾©ã™ã‚‹ã¨ãã«ãã®é–¢æ•°ã®å†…éƒ¨ã§ã®ã¿ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚é–¢æ•°å†…ã§ :keyword:`yield` å¼ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€æ™®é€šã®é–¢æ•°ã§ã¯ãªãã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ãŒä½œæˆã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:400
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of a generator "
"function. The execution starts when one of the generator's methods is "
"called.  At that time, the execution proceeds to the first :keyword:`yield` "
"expression, where it is suspended again, returning the value of "
":token:`expression_list` to generator's caller.  By suspended we mean that "
"all local state is retained, including the current bindings of local "
"variables, the instruction pointer, and the internal evaluation stack.  When"
" the execution is resumed by calling one of the generator's methods, the "
"function can proceed exactly as if the :keyword:`yield` expression was just "
"another external call. The value of the :keyword:`yield` expression after "
"resuming depends on the method which resumed the execution."
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ãã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ãã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã®å®Ÿè¡Œã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ãã«å®Ÿè¡ŒãŒé–‹å§‹ã•ã‚Œã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¨ã€å®Ÿè¡Œã¯ :keyword:`yield` ã®æœ€åˆã®ä½ç½®ã¾ã§å‡¦ç†ã•ã‚Œã¦ä¸€æ™‚åœæ­¢ã—ã¾ã™ã€‚ãã—ã¦ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®å‘¼ã³å‡ºã—å…ƒã¸ :token:`expression_list` ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚ã“ã“ã§è¨€ã†ä¸€æ™‚åœæ­¢ã¨ã¯ã€ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®æŸç¸›ã€å‘½ä»¤ãƒã‚¤ãƒ³ã‚¿ã‚„å†…éƒ¨ã®è©•ä¾¡ã‚¹ã‚¿ãƒƒã‚¯ã‚’å«ã‚ãŸãƒ­ãƒ¼ã‚«ãƒ«ã®å…¨ã¦ã®çŠ¶æ…‹ãŒä¿æŒã•ã‚Œã‚‹ã“ã¨ã‚’æŒ‡ã—ã¾ã™ã€‚å†åº¦ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦å®Ÿè¡Œã‚’å†é–‹ã™ã‚‹ã¨ãã€ãã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã¯ã¾ã•ã« :keyword:`yield` å¼ãŒãŸã ã®å¤–éƒ¨å‘¼ã³å‡ºã—ã§ã‚ã£ãŸã‹ã®ã‚ˆã†ã«å‡¦ç†ãŒç¶™ç¶šã•ã‚Œã¾ã™ã€‚å†é–‹ã—ãŸå¾Œã® :keyword:`yield` å¼ã®å€¤ã¯å®Ÿè¡Œã‚’å†é–‹ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:415
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where should the execution continue after it yields;"
" the control is always transferred to the generator's caller."
msgstr "ã“ã‚Œã¾ã§èª¬æ˜ã—ãŸå†…å®¹ã‹ã‚‰ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã¯ã‚³ãƒ«ãƒ¼ãƒãƒ³ã«ã¨ã¦ã‚‚ã‚ˆãä¼¼ã¦ã„ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã¯ä½•åº¦ã‚‚ç”Ÿæˆã—ã€1ã¤ä»¥ä¸Šã®ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆã‚’æŒã¡ã€ãã®å®Ÿè¡Œã¯ä¸€æ™‚åœæ­¢ã•ã‚Œã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã¯ yield ã—ãŸå¾Œã§å®Ÿè¡Œã®ç¶™ç¶šã‚’åˆ¶å¾¡ã§ããªã„ã“ã¨ãŒå”¯ä¸€ã®é•ã„ã§ã™ã€‚ãã®åˆ¶å¾¡ã¯å¸¸ã«ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®å‘¼ã³å‡ºã—å…ƒã¸ç§»ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:425
msgid "Generator-iterator methods"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿-ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../reference/expressions.rst:427
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr "ã“ã®èª¬ã§ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã®å®Ÿè¡Œåˆ¶å¾¡ã«ä½¿ç”¨ã§ãã¾ã™ã€‚"

#: ../../reference/expressions.rst:430
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr "ä»¥ä¸‹ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ã¯ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒæ—¢ã«å®Ÿè¡Œä¸­ã®å ´åˆ :exc:`ValueError` ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ç‚¹ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:438
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed :keyword:`yield` expression.  When a generator function is resumed "
"with a :meth:`~generator.next` method, the current :keyword:`yield` "
"expression always evaluates to :const:`None`.  The execution then continues "
"to the next :keyword:`yield` expression, where the generator is suspended "
"again, and the value of the :token:`expression_list` is returned to "
":meth:`~generator.next`'s caller. If the generator exits without yielding "
"another value, a :exc:`StopIteration` exception is raised."
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã®å®Ÿè¡Œã‚’é–‹å§‹ã™ã‚‹ã‹ã€æœ€å¾Œã« :keyword:`yield` å¼ãŒå®Ÿè¡Œã•ã‚ŒãŸã¨ã“ã‚ã‹ã‚‰å†é–‹ã—ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ãŒ :meth:`~generator.next` ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦å†é–‹ã•ã‚ŒãŸæ™‚ã€ãã®æ™‚ç‚¹ã® :keyword:`yield` å¼ã®å€¤ã¯å¸¸ã« :const:`None` ã¨è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ãã®å¾Œæ¬¡ã® :keyword:`yield` å¼ã¾ã§å®Ÿè¡Œã—ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯ä¸€æ™‚åœæ­¢ã—ã€ :token:`expression_list` ã®å€¤ã‚’ :meth:`~generator.next` ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—å…ƒã«è¿”ã—ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒæ¬¡ã®å€¤ã‚’ yield ã›ãšã«çµ‚äº†ã—ãŸå ´åˆã€ :exc:`StopIteration` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:451
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The ``value`` argument becomes the result of the current :keyword:`yield` "
"expression.  The :meth:`send` method returns the next value yielded by the "
"generator, or raises :exc:`StopIteration` if the generator exits without "
"yielding another value. When :meth:`send` is called to start the generator, "
"it must be called with :const:`None` as the argument, because there is no "
":keyword:`yield` expression that could receive the value."
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã®å†…éƒ¨ã¸å€¤ã‚’ \"é€ã‚Š\"ã€å®Ÿè¡Œã‚’å†é–‹ã—ã¾ã™ã€‚å¼•æ•°ã® ``value`` ã¯ã‚«ãƒ¬ãƒ³ãƒˆã® :keyword:`yield` å¼ã®çµæœã«ãªã‚Šã¾ã™ã€‚ :meth:`send` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒç”Ÿæˆã—ãŸæ¬¡ã®å€¤ã€ã¾ãŸã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒå€¤ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ãªãçµ‚äº†ã™ã‚‹ã¨ :exc:`StopIteration` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒå†é–‹ã™ã‚‹ãŸã‚ã« :meth:`send` ã‚’å‘¼ã³å‡ºã™ã¨ãã¯ã€å¼•æ•°ã¨ã—ã¦ :const:`None` ã‚’æŒ‡å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã†ã—ãªã„ã¨ã€å€¤ã‚’å—ã‘å–ã‚‹ :keyword:`yield` å¼ãŒå­˜åœ¨ã—ãªã„ã‹ã‚‰ã§ã™ã€‚"

#: ../../reference/expressions.rst:462
msgid ""
"Raises an exception of type ``type`` at the point where generator was "
"paused, and returns the next value yielded by the generator function.  If "
"the generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised.  If the generator function does not catch the passed-in"
" exception, or raises a different exception, then that exception propagates "
"to the caller."
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒä¸­æ–­ã—ãŸä½ç½®ã§ ``type`` å‹ã®ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¦ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ãŒç”Ÿæˆã™ã‚‹æ¬¡ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒå€¤ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ãªãçµ‚äº†ã™ã‚‹ã¨ :exc:`StopIteration` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ãŒæ¸¡ã•ã‚ŒãŸä¾‹å¤–ã‚’æ•æ‰ã—ãªã„ã€ã‚‚ã—ãã¯é•ã†ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹ãªã‚‰ã€ãã®ä¾‹å¤–ã¯å‘¼ã³å‡ºã—å…ƒã¸ä¼æ¬ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:473
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then raises :exc:`StopIteration` (by "
"exiting normally, or due to already being closed) or :exc:`GeneratorExit` "
"(by not catching the exception), close returns to its caller.  If the "
"generator yields a value, a :exc:`RuntimeError` is raised.  If the generator"
" raises any other exception, it is propagated to the caller.  :meth:`close` "
"does nothing if the generator has already exited due to an exception or "
"normal exit."
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ãŒä¸­æ–­ã—ãŸä½ç½®ã§ :exc:`GeneratorExit` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ãŒ (é€šå¸¸ã®çµ‚äº†ã¾ãŸã¯æ—¢ã«ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸã“ã¨ã§) :exc:`StopIteration` ã€ã‚‚ã—ãã¯ (ä¾‹å¤–ã‚’æ•æ‰ã—ãªã„ã“ã¨ã§) :exc:`GeneratorExit` ã‚’ç™ºç”Ÿã•ã›ã‚‹å ´åˆ close() ã¯å‘¼ã³å‡ºã—å…ƒã¸è¿”ã•ã‚Œã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒå€¤ã‚’ç”Ÿæˆã™ã‚‹å ´åˆ :exc:`RuntimeError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ :meth:`close` ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒé€šå¸¸ã®çµ‚äº†ã¾ãŸã¯ä¾‹å¤–ã«ã‚ˆã‚Šæ—¢ã«çµ‚äº†ã—ã¦ã„ã‚‹å ´åˆã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚"

#: ../../reference/expressions.rst:481
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr "ä»¥ä¸‹ã®ç°¡å˜ãªã‚µãƒ³ãƒ—ãƒ«ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¨ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã®æŒ¯ã‚‹èˆã„ã‚’å®Ÿéš›ã«ç´¹ä»‹ã—ã¾ã™::"

#: ../../reference/expressions.rst:512
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`0342` - æ‹¡å¼µã•ã‚ŒãŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚’ç”¨ã„ãŸã‚³ãƒ«ãƒ¼ãƒãƒ³"

#: ../../reference/expressions.rst:512
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable"
" as simple coroutines."
msgstr "ã‚·ãƒ³ãƒ—ãƒ«ãªã‚³ãƒ«ãƒ¼ãƒãƒ³ã¨ã—ã¦åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®æ§‹æ–‡ã¨ API ã‚’æ‹¡å¼µã™ã‚‹ææ¡ˆã§ã™ã€‚"

#: ../../reference/expressions.rst:519
msgid "Primaries"
msgstr "ãƒ—ãƒ©ã‚¤ãƒãƒª"

#: ../../reference/expressions.rst:523
msgid ""
"Primaries represent the most tightly bound operations of the language. Their"
" syntax is:"
msgstr "ãƒ—ãƒ©ã‚¤ãƒãƒªã¯ã€è¨€èªã«ãŠã„ã¦æœ€ã‚‚çµåˆã®å¼·ã„æ“ä½œã‚’è¡¨ã—ã¾ã™ã€‚æ–‡æ³•ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™:"

#: ../../reference/expressions.rst:533
msgid "Attribute references"
msgstr "å±æ€§å‚ç…§"

#: ../../reference/expressions.rst:537
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr "å±æ€§å‚ç…§ã¯ã€ãƒ—ãƒ©ã‚¤ãƒãƒªã®å¾Œã‚ã«ãƒ”ãƒªã‚ªãƒ‰ã¨åå‰ã‚’é€£ã­ãŸã‚‚ã®ã§ã™:"

#: ../../reference/expressions.rst:547
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, e.g., a module, list, or an instance.  This object is then asked"
" to produce the attribute whose name is the identifier.  If this attribute "
"is not available, the exception :exc:`AttributeError` is raised. Otherwise, "
"the type and value of the object produced is determined by the object.  "
"Multiple evaluations of the same attribute reference may yield different "
"objects."
msgstr "ãƒ—ãƒ©ã‚¤ãƒãƒªã®å€¤è©•ä¾¡çµæœã¯ã€ä¾‹ãˆã°ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã€ãƒªã‚¹ãƒˆã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã„ã£ãŸã€å±æ€§å‚ç…§ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ¬¡ã«ã€æŒ‡å®šã—ãŸåå‰ãŒè­˜åˆ¥å­åã¨ãªã£ã¦ã„ã‚‹ã‚ˆã†ãªå±æ€§ã‚’ç”Ÿæˆã™ã‚‹ã‚ˆã†å•ã„åˆã‚ã›ã•ã‚Œã¾ã™ã€‚å•ã„åˆã‚ã›ãŸå±æ€§ãŒå¾—ã‚‰ã‚Œãªã„å ´åˆã€ä¾‹å¤– :exc:`AttributeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å±æ€§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã¨å€¤ã‚’æ±ºå®šã—ã€ç”Ÿæˆã—ã¦è¿”ã—ã¾ã™ã€‚åŒã˜å±æ€§å‚ç…§ã‚’è¤‡æ•°å›è©•ä¾¡ã—ãŸã¨ãã€äº’ã„ã«ç•°ãªã‚‹å±æ€§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:558
msgid "Subscriptions"
msgstr "æ·»å­—è¡¨è¨˜ (subscription)"

#: ../../reference/expressions.rst:571
msgid ""
"A subscription selects an item of a sequence (string, tuple or list) or "
"mapping (dictionary) object:"
msgstr "æ·»å­—è¡¨è¨˜ã¯ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ (æ–‡å­—åˆ—ã€ã‚¿ãƒ—ãƒ«ã¾ãŸã¯ãƒªã‚¹ãƒˆ) ã‚„ãƒãƒƒãƒ— (è¾æ›¸) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã€è¦ç´ ã‚’ä¸€ã¤é¸æŠã—ã¾ã™:"

#: ../../reference/expressions.rst:577
msgid "The primary must evaluate to an object of a sequence or mapping type."
msgstr "ãƒ—ãƒ©ã‚¤ãƒãƒªã®å€¤è©•ä¾¡çµæœã¯ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã‹ãƒãƒƒãƒ—å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/expressions.rst:579
msgid ""
"If the primary is a mapping, the expression list must evaluate to an object "
"whose value is one of the keys of the mapping, and the subscription selects "
"the value in the mapping that corresponds to that key.  (The expression list"
" is a tuple except if it has exactly one item.)"
msgstr "ãƒ—ãƒ©ã‚¤ãƒãƒªãŒãƒãƒƒãƒ—ã§ã‚ã‚Œã°ã€å¼ãƒªã‚¹ãƒˆã®å€¤è©•ä¾¡çµæœã¯ãƒãƒƒãƒ—å†…ã®ã„ãšã‚Œã‹ã®ã‚­ãƒ¼å€¤ã«ç›¸å½“ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚‰ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æ·»å­—è¡¨è¨˜ã¯ã€ãã®ã‚­ãƒ¼ã«å¯¾å¿œã™ã‚‹ãƒãƒƒãƒ—å†…ã®å€¤ (value) ã‚’é¸æŠã—ã¾ã™ã€‚ (å¼ãƒªã‚¹ãƒˆã®è¦ç´ ãŒå˜ç‹¬ã§ã‚ã‚‹å ´åˆã‚’é™¤ãã€å¼ãƒªã‚¹ãƒˆã¯ã‚¿ãƒ—ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚)"

#: ../../reference/expressions.rst:584
msgid ""
"If the primary is a sequence, the expression list must evaluate to a plain "
"integer.  If this value is negative, the length of the sequence is added to "
"it (so that, e.g., ``x[-1]`` selects the last item of ``x``.)  The resulting"
" value must be a nonnegative integer less than the number of items in the "
"sequence, and the subscription selects the item whose index is that value "
"(counting from zero)."
msgstr ""

#: ../../reference/expressions.rst:595
msgid ""
"A string's items are characters.  A character is not a separate data type "
"but a string of exactly one character."
msgstr "æ–‡å­—åˆ—å‹ã®è¦ç´ ã¯æ–‡å­— (character) ã§ã™ã€‚æ–‡å­—ã¯å€‹åˆ¥ã®å‹ã§ã¯ãªãã€ 1 æ–‡å­—ã ã‘ã‹ã‚‰ãªã‚‹æ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../reference/expressions.rst:602
msgid "Slicings"
msgstr "ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ (slicing)"

#: ../../reference/expressions.rst:614
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr "ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (æ–‡å­—åˆ—ã€ã‚¿ãƒ—ãƒ«ã¾ãŸã¯ãƒªã‚¹ãƒˆ) ã«ãŠã‘ã‚‹ã‚ã‚‹ç¯„å›²ã®è¦ç´ ã‚’é¸æŠã—ã¾ã™ã€‚ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã¯å¼ã¨ã—ã¦ç”¨ã„ãŸã‚Šã€ä»£å…¥ã‚„ :keyword:`del` æ–‡ã®å¯¾è±¡ã¨ã—ã¦ç”¨ã„ãŸã‚Šã§ãã¾ã™ã€‚ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã®æ§‹æ–‡ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™:"

#: ../../reference/expressions.rst:634
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this"
" is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice nor ellipses).  "
"Similarly, when the slice list has exactly one short slice and no trailing "
"comma, the interpretation as a simple slicing takes priority over that as an"
" extended slicing."
msgstr "ä¸Šè¨˜ã®å½¢å¼çš„ãªæ§‹æ–‡æ³•ã«ã¯ã‚ã„ã¾ã„ã•ãŒã‚ã‚Šã¾ã™: å¼ãƒªã‚¹ãƒˆã«è¦‹ãˆã‚‹ã‚‚ã®ã¯ã€ã‚¹ãƒ©ã‚¤ã‚¹ãƒªã‚¹ãƒˆã«ã‚‚è¦‹ãˆã‚‹ãŸã‚ã€æ·»å­—è¡¨è¨˜ã¯ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã¨ã—ã¦ã‚‚è§£é‡ˆã•ã‚Œã†ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ã“ã®å ´åˆã«ã¯ã€(ã‚¹ãƒ©ã‚¤ã‚¹ãƒªã‚¹ãƒˆã®è©•ä¾¡çµæœãŒã€é©åˆ‡ãªã‚¹ãƒ©ã‚¤ã‚¹ã‚„çœç•¥è¡¨è¨˜ (ellipsis) ã«ãªã‚‰ãªã„å ´åˆ)ã€ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã¨ã—ã¦ã®è§£é‡ˆã‚ˆã‚Šã‚‚æ·»å­—è¡¨è¨˜ã¨ã—ã¦ã®è§£é‡ˆã®æ–¹ãŒé«˜ã„å„ªå…ˆé †ä½ã‚’æŒã¤ã‚ˆã†ã«å®šç¾©ã™ã‚‹ã“ã¨ã§ã€æ§‹æ–‡æ³•ã‚’ã‚ˆã‚Šé›£è§£ã«ã™ã‚‹ã“ã¨ãªãã‚ã„ã¾ã„ã•ã‚’å–ã‚Šé™¤ã„ã¦ã„ã¾ã™ã€‚åŒæ§˜ã«ã€ã‚¹ãƒ©ã‚¤ã‚¹ãƒªã‚¹ãƒˆãŒå³å¯†ã«ä¸€ã¤ã ã‘ã®çŸ­ã„ã‚¹ãƒ©ã‚¤ã‚¹ã§ã€æœ«å°¾ã«ã‚«ãƒ³ãƒãŒç¶šã„ã¦ã„ãªã„å ´åˆã€æ‹¡å¼µã‚¹ãƒ©ã‚¤ã‚¹ã¨ã—ã¦ã®è§£é‡ˆã‚ˆã‚Šã€å˜ç´”ãªã‚¹ãƒ©ã‚¤ã‚¹ã¨ã—ã¦ã®è§£é‡ˆãŒå„ªå…ˆã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:643
msgid ""
"The semantics for a simple slicing are as follows.  The primary must "
"evaluate to a sequence object.  The lower and upper bound expressions, if "
"present, must evaluate to plain integers; defaults are zero and the "
"``sys.maxint``, respectively.  If either bound is negative, the sequence's "
"length is added to it.  The slicing now selects all items with index *k* "
"such that ``i <= k < j`` where *i* and *j* are the specified lower and upper"
" bounds.  This may be an empty sequence.  It is not an error if *i* or *j* "
"lie outside the range of valid indexes (such items don't exist so they "
"aren't selected)."
msgstr "å˜ç´”ãªã‚¹ãƒ©ã‚¤ã‚¹ã«å¯¾ã™ã‚‹æ„å‘³ä»˜ã‘ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ãƒ—ãƒ©ã‚¤ãƒãƒªã®å€¤è©•ä¾¡çµæœã¯ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¸‹å¢ƒç•ŒãŠã‚ˆã³ä¸Šå¢ƒç•Œã‚’è¡¨ã™å¼ãŒã‚ã‚‹å ´åˆã€ãã‚Œã‚‰ã®å€¤è©•ä¾¡çµæœã¯æ•´æ•°ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“; ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å€¤ã¯ã€ãã‚Œãã‚Œã‚¼ãƒ­ã¨ ``sys.maxint`` ã§ã™ã€‚ã©ã¡ã‚‰ã‹ã®å¢ƒç•Œå€¤ãŒè² ã§ã‚ã‚‹å ´åˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒåŠ ç®—ã•ã‚Œã¾ã™ã€‚ã“ã†ã—ã¦ã€ã‚¹ãƒ©ã‚¤ã‚¹ã¯ *i* ãŠã‚ˆã³ *j* ã‚’ãã‚Œãã‚ŒæŒ‡å®šã—ãŸä¸‹å¢ƒç•Œã€ä¸Šå¢ƒç•Œã¨ã—ã¦ã€ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ *k* ãŒ ``i <= k < j`` ã¨ãªã‚‹å…¨ã¦ã®è¦ç´ ã‚’é¸æŠã—ã¾ã™ã€‚é¸æŠã®çµæœã€ç©ºã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ãªã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚ *i* ã‚„ *j* ãŒæœ‰åŠ¹ãªã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ç¯„å›²ã®å¤–å´ã«ã‚ã‚‹å ´åˆã§ã‚‚ã€ã‚¨ãƒ©ãƒ¼ã«ã¯ãªã‚Šã¾ã›ã‚“ (ç¯„å›²å¤–ã®è¦ç´ ã¯å­˜åœ¨ã—ãªã„ã®ã§ã€é¸æŠã•ã‚Œãªã„ã ã‘ã§ã™)ã€‚"

#: ../../reference/expressions.rst:657
msgid ""
"The semantics for an extended slicing are as follows.  The primary must "
"evaluate to a mapping object, and it is indexed with a key that is "
"constructed from the slice list, as follows.  If the slice list contains at "
"least one comma, the key is a tuple containing the conversion of the slice "
"items; otherwise, the conversion of the lone slice item is the key.  The "
"conversion of a slice item that is an expression is that expression.  The "
"conversion of an ellipsis slice item is the built-in ``Ellipsis`` object.  "
"The conversion of a proper slice is a slice object (see section "
":ref:`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and "
":attr:`~slice.step` attributes are the values of the expressions given as "
"lower bound, upper bound and stride, respectively, substituting ``None`` for"
" missing expressions."
msgstr "æ‹¡å¼µã‚¹ãƒ©ã‚¤ã‚¹ã«å¯¾ã™ã‚‹æ„å‘³ä»˜ã‘ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ãƒ—ãƒ©ã‚¤ãƒãƒªã®å€¤è©•ä¾¡çµæœã¯ã€è¾æ›¸å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã¾ãŸã€è¾æ›¸ã¯ä»¥ä¸‹ã«è¿°ã¹ã‚‹ã‚ˆã†ã«ã—ã¦ã‚¹ãƒ©ã‚¤ã‚¹ãƒªã‚¹ãƒˆã‹ã‚‰ç”Ÿæˆã•ã‚ŒãŸã‚­ãƒ¼ã«ã‚ˆã£ã¦ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹æŒ‡å®šã§ããªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚¹ãƒ©ã‚¤ã‚¹ãƒªã‚¹ãƒˆã«å°‘ãªãã¨ã‚‚ä¸€ã¤ã®ã‚«ãƒ³ãƒãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€ã‚­ãƒ¼ã¯å„ã‚¹ãƒ©ã‚¤ã‚¹è¦ç´ ã‚’å€¤å¤‰æ›ã—ãŸã‚‚ã®ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã«ãªã‚Šã¾ã™; ãã‚Œä»¥å¤–ã®å ´åˆã€å˜ä¸€ã®ã‚¹ãƒ©ã‚¤ã‚¹è¦ç´ è‡ªä½“ã‚’å€¤å¤‰æ›ã—ãŸã‚‚ã®ãŒã‚­ãƒ¼ã«ãªã‚Šã¾ã™ã€‚ä¸€å€‹ã®å¼ã§ã§ããŸã‚¹ãƒ©ã‚¤ã‚¹è¦ç´ ã®å¤‰æ›ã¯ã€ãã®å¼ã«ãªã‚Šã¾ã™ã€‚çœç•¥è¡¨è¨˜ã‚¹ãƒ©ã‚¤ã‚¹è¦ç´ ã®å¤‰æ›ã¯ã€çµ„ã¿è¾¼ã¿ã® ``Ellipsis`` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚é©åˆ‡ãªã‚¹ãƒ©ã‚¤ã‚¹ã®å¤‰æ›ã¯ã€ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (:ref:`types` å‚ç…§) ã§ :attr:`~slice.start`, :attr:`~slice.stop` ãŠã‚ˆã³ :attr:`~slice.step` å±æ€§ã¯ã€ãã‚Œãã‚ŒæŒ‡å®šã—ãŸä¸‹å¢ƒç•Œã€ä¸Šå¢ƒç•Œã€ãŠã‚ˆã³ã¨ã³å¹… (stride) ã«ãªã‚Šã¾ã™ã€‚å¼ãŒãªã„å ´åˆã«ã¯ ``None`` ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:678
msgid "Calls"
msgstr "å‘¼ã³å‡ºã— (call)"

#: ../../reference/expressions.rst:680
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr "å‘¼ã³å‡ºã—ã¯ã€å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ä¾‹ãˆã° :term:`function`) ã‚’ :term:`arguments <argument>` ã®ç³»åˆ—ã¨ã¨ã‚‚ã«å‘¼ã³å‡ºã—ã¾ã™ã€‚ç³»åˆ—ã¯ç©ºã®ç³»åˆ—ã§ã‚ã£ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“:"

#: ../../reference/expressions.rst:697
msgid ""
"A trailing comma may be present after the positional and keyword arguments "
"but does not affect the semantics."
msgstr "å›ºå®šå¼•æ•°ã‚„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®å¾Œã‚ã«ã‚«ãƒ³ãƒã‚’ã¤ã‘ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚æ§‹æ–‡ã®æ„å‘³ä»˜ã‘ã«å½±éŸ¿ã‚’åŠã¼ã™ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/expressions.rst:703
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and certain class instances themselves are callable; "
"extensions may define additional callable object types).  All argument "
"expressions are evaluated before the call is attempted.  Please refer to "
"section :ref:`function` for the syntax of formal :term:`parameter` lists."
msgstr "ãƒ—ãƒ©ã‚¤ãƒãƒªã®å€¤è©•ä¾¡çµæœã¯ã€å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ (ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã€çµ„ã¿è¾¼ã¿é–¢æ•°ã€çµ„ã¿è¾¼ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã€ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã€ãã—ã¦ç‰¹å®šã®ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è‡ªä½“ãŒå‘¼ã³å‡ºã—å¯èƒ½ã§ã™; æ‹¡å¼µã«ã‚ˆã£ã¦ã€ãã®ä»–ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã‚’å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™)ã€‚å¼•æ•°å¼ã¯å…¨ã¦ã€å‘¼ã³å‡ºã—ã‚’è©¦ã¿ã‚‹å‰ã«å€¤è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ä»®å¼•æ•° (formal :term:`parameter`) ãƒªã‚¹ãƒˆã®æ§‹æ–‡ã«ã¤ã„ã¦ã¯ :ref:`function` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:710
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the value of the argument is placed in the slot, filling it (even if the "
"expression is ``None``, it fills the slot).  When all arguments have been "
"processed, the slots that are still unfilled are filled with the "
"corresponding default value from the function definition.  (Default values "
"are calculated, once, when the function is defined; thus, a mutable object "
"such as a list or dictionary used as default value will be shared by all "
"calls that don't specify an argument value for the corresponding slot; this "
"should usually be avoided.)  If there are any unfilled slots for which no "
"default value is specified, a :exc:`TypeError` exception is raised.  "
"Otherwise, the list of filled slots is used as the argument list for the "
"call."
msgstr "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦æœ€åˆã«å›ºå®šå¼•æ•° (positional argument) ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚ã¾ãšã€å€¤ã®å…¥ã£ã¦ã„ãªã„ã‚¹ãƒ­ãƒƒãƒˆãŒä»®å¼•æ•°ã«å¯¾ã—ã¦ç”Ÿæˆã•ã‚Œã¾ã™ã€‚N å€‹ã®å›ºå®šå¼•æ•°ãŒã‚ã‚‹å ´åˆã€å›ºå®šå¼•æ•°ã¯å…ˆé ­ã® N ã‚¹ãƒ­ãƒƒãƒˆã«é…ç½®ã•ã‚Œã¾ã™ã€‚æ¬¡ã«ã€å„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã«ã¤ã„ã¦ã€è­˜åˆ¥å­ã‚’ä½¿ã£ã¦å¯¾å¿œã™ã‚‹ã‚¹ãƒ­ãƒƒãƒˆã‚’æ±ºå®šã—ã¾ã™ (è­˜åˆ¥å­ãŒæœ€åˆã®ä»®å¼•æ•°ãƒ‘ãƒ©ãƒ¡ã‚¿åã¨åŒã˜ãªã‚‰ã€æœ€åˆã®ã‚¹ãƒ­ãƒƒãƒˆã‚’ä½¿ã†ã€ã¨ã„ã£ãŸå…·åˆã§ã™)ã€‚ã‚¹ãƒ­ãƒƒãƒˆãŒã™ã§ã«ã™ã¹ã¦åŸ‹ã¾ã£ã¦ã„ãŸãªã‚‰ :exc:`TypeError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã€å¼•æ•°å€¤ã‚’ã‚¹ãƒ­ãƒƒãƒˆã«åŸ‹ã‚ã¦ã„ãã¾ã™ã€‚ (å¼ãŒ ``None`` ã§ã‚ã£ã¦ã‚‚ã€ãã®å¼ã§ã‚¹ãƒ­ãƒƒãƒˆã‚’åŸ‹ã‚ã¾ã™)ã€‚å…¨ã¦ã®å¼•æ•°ãŒå‡¦ç†ã•ã‚ŒãŸã‚‰ã€ã¾ã åŸ‹ã‚ã‚‰ã‚Œã¦ã„ãªã„ã‚¹ãƒ­ãƒƒãƒˆã‚’ãã‚Œãã‚Œã«å¯¾å¿œã™ã‚‹é–¢æ•°å®šç¾©æ™‚ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§åŸ‹ã‚ã¾ã™ã€‚(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ã€é–¢æ•°ãŒå®šç¾©ã•ã‚ŒãŸã¨ãã«ä¸€åº¦ã ã‘è¨ˆç®—ã•ã‚Œã¾ã™; å¾“ã£ã¦ã€ãƒªã‚¹ãƒˆã‚„è¾æ›¸ã®ã‚ˆã†ãªå¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹ã¨ã€å¯¾å¿œã™ã‚‹ã‚¹ãƒ­ãƒƒãƒˆã«å¼•æ•°ã‚’æŒ‡å®šã—ãªã„é™ã‚Šã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå…¨ã¦ã®å‘¼ã³å‡ºã—ã‹ã‚‰å…±æœ‰ã•ã‚Œã¾ã™; ã“ã®ã‚ˆã†ãªçŠ¶æ³ã¯é€šå¸¸é¿ã‘ã‚‹ã¹ãã§ã™ã€‚) ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ã€å€¤ã®åŸ‹ã‚ã‚‰ã‚Œã¦ã„ãªã„ã‚¹ãƒ­ãƒƒãƒˆãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆ :exc:`TypeError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ãã†ã§ãªã„å ´åˆã€å€¤ã®åŸ‹ã‚ã‚‰ã‚ŒãŸã‚¹ãƒ­ãƒƒãƒˆã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆãŒå‘¼ã³å‡ºã—ã®å¼•æ•°ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:730
msgid ""
"An implementation may provide built-in functions whose positional parameters"
" do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use "
":c:func:`PyArg_ParseTuple` to parse their arguments."
msgstr "å®Ÿè£…ã§ã¯ã€åå‰ã‚’æŒãŸãªã„å›ºå®šå¼•æ•°ã‚’å—ã‘å–ã‚‹çµ„ã¿è¾¼ã¿é–¢æ•°ã‚’æä¾›ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãã†ã„ã£ãŸå¼•æ•°ãŒãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŒ–ã®ãŸã‚ã« 'åä»˜ã‘ã‚‰ã‚Œã¦' ã„ãŸã¨ã—ã¦ã‚‚ã€å®Ÿéš›ã«ã¯åä»˜ã‘ã‚‰ã‚Œã¦ã„ãªã„ã®ã§ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«ã‚ˆã£ã¦æä¾›ã•ã‚Œã¾ã›ã‚“ã€‚ CPython ã§ã¯ã€C è¨€èªã§å®Ÿè£…ã•ã‚ŒãŸé–¢æ•°ã®ã€åå‰ã‚’æŒãŸãªã„å›ºå®šå¼•æ•°ã‚’è§£æã™ã‚‹ãŸã‚ã« :c:func:`PyArg_ParseTuple` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:736
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an"
" empty tuple if there were no excess positional arguments)."
msgstr "ä»®å¼•æ•°ã‚¹ãƒ­ãƒƒãƒˆã®æ•°ã‚ˆã‚Šã‚‚å¤šãã®å›ºå®šå¼•æ•°ãŒã‚ã‚‹å ´åˆã€æ§‹æ–‡ ``*identifier`` ã‚’ä½¿ã£ã¦æŒ‡å®šã•ã‚ŒãŸä»®å¼•æ•°ãŒãªã„ã‹ãã‚Šã€ :exc:`TypeError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™; ä»®å¼•æ•° ``*identifier`` ãŒã‚ã‚‹å ´åˆã€ã“ã®ä»®å¼•æ•°ã¯ä½™åˆ†ãªå›ºå®šå¼•æ•°ãŒå…¥ã£ãŸã‚¿ãƒ—ãƒ« (ã‚‚ã—ãã¯ã€ä½™åˆ†ãªå›ºå®šå¼•æ•°ãŒãªã„å ´åˆã«ã¯ç©ºã®ã‚¿ãƒ—ãƒ«) ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:742
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a "
":exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®ã„ãšã‚Œã‹ãŒä»®å¼•æ•°åã«å¯¾å¿œã—ãªã„å ´åˆã€æ§‹æ–‡ ``**identifier`` ã‚’ä½¿ã£ã¦æŒ‡å®šã•ã‚ŒãŸä»®å¼•æ•°ãŒãªã„é™ã‚Šã€ :exc:`TypeError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™; ä»®å¼•æ•° ``**identifier`` ãŒã‚ã‚‹å ´åˆã€ã“ã®ä»®å¼•æ•°ã¯ä½™åˆ†ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ãŒå…¥ã£ãŸ (ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ã‚­ãƒ¼ã¨ã—ã€å¼•æ•°å€¤ã‚’ã‚­ãƒ¼ã«å¯¾å¿œã™ã‚‹å€¤ã¨ã—ãŸ) è¾æ›¸ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ä½™åˆ†ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ãŒãªã„å ´åˆã«ã¯ã€ç©ºã® (æ–°ãŸãª) è¾æ›¸ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:752
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an iterable.  Elements from this iterable are treated as if"
" they were additional positional arguments; if there are positional "
"arguments *x1*, ..., *xN*, and ``expression`` evaluates to a sequence *y1*, "
"..., *yM*, this is equivalent to a call with M+N positional arguments *x1*, "
"..., *xN*, *y1*, ..., *yM*."
msgstr "é–¢æ•°å‘¼ã³å‡ºã—ã®éš›ã«æ§‹æ–‡ ``*expression`` ãŒä½¿ã‚ã‚Œã‚‹ãªã‚‰ã€ ``expression`` ã®è©•ä¾¡ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®è¦ç´ ã¯ã€è¿½åŠ ã®å›ºå®šå¼•æ•°ã®ã‚ˆã†ã«æ‰±ã‚ã‚Œã¾ã™; ã™ãªã‚ã¡ã€å›ºå®šå¼•æ•° *x1* ,..., *xN* ãŒã‚ã‚Šã€ ``expression`` ã®è©•ä¾¡ãŒã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *y1* ,..., *yM* ã§ã‚ã‚‹ãªã‚‰ã€M+N å€‹ã®å›ºå®šå¼•æ•° *x1* ,..., *xN* , *y1* ,..., *yM* ã‚’ä½¿ã£ãŸå‘¼ã³å‡ºã—ã¨åŒã˜ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:759
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear"
" *after* some keyword arguments, it is processed *before* the keyword "
"arguments (and the ``**expression`` argument, if any -- see below).  So::"
msgstr "``*expression`` æ§‹æ–‡ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã® *å¾Œã‚* ã§æŒ‡å®šã—ã¦ã‚‚è‰¯ã„ã§ã™ãŒã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚ˆã‚Šã‚‚ *å‰* ã§æŒ‡å®šã•ã‚ŒãŸã‚‚ã®ã¨ã—ã¦å‡¦ç†ã•ã‚Œã¾ã™ (``**expression`` å¼•æ•°ã‚’æŒ‡å®šã—ãŸã¨ãã®æŒ¯ã‚‹èˆã„ã¯ä»¥ä¸‹ã‚’å‚ç…§)ã€‚å¾“ã£ã¦ã€ã“ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../reference/expressions.rst:775
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not arise."
msgstr "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ ``*expression`` æ§‹æ–‡ã‚’åŒã˜å‘¼ã³å‡ºã—ã§ä¸€ç·’ã«ä½¿ã†ã“ã¨ã¯ã‚ã¾ã‚Šãªã„ã®ã§ã€å®Ÿéš›ã«ä¸Šè¨˜ã®ã‚ˆã†ãªæ··ä¹±ãŒç”Ÿã˜ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/expressions.rst:781
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a mapping, the contents of which are treated as additional "
"keyword arguments.  In the case of a keyword appearing in both "
"``expression`` and as an explicit keyword argument, a :exc:`TypeError` "
"exception is raised."
msgstr "é–¢æ•°å‘¼ã³å‡ºã—ã§ ``**expression`` æ§‹æ–‡ãŒä½¿ã‚ã‚ŒãŸå ´åˆã€ ``expression`` ã®å€¤è©•ä¾¡çµæœã¯ãƒãƒƒãƒ—å‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚è¾æ›¸ã®å†…å®¹ã¯è¿½åŠ ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚æ˜ç¤ºçš„ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ãŒ ``expression`` å†…ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¨é‡è¤‡ã—ãŸå ´åˆã«ã¯ :exc:`TypeError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:786
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names.  "
"Formal parameters using the syntax ``(sublist)`` cannot be used as keyword "
"argument names; the outermost sublist corresponds to a single unnamed "
"argument slot, and the argument value is assigned to the sublist using the "
"usual tuple assignment rules after all other parameter processing is done."
msgstr "``*identifier`` ã‚„ ``**identifier`` æ§‹æ–‡ã‚’ä½¿ã£ãŸä»®å¼•æ•°ã¯ã€å›ºå®šå¼•æ•°ã‚¹ãƒ­ãƒƒãƒˆã‚„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°åã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ ``(sublist)`` æ§‹æ–‡ã‚’ä½¿ã£ãŸä»®å¼•æ•°ã¯ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°åã«ã¯ä½¿ãˆã¾ã›ã‚“; sublist ã¯ã€ãƒªã‚¹ãƒˆå…¨ä½“ãŒä¸€ã¤ã®ç„¡åã®å¼•æ•°ã‚¹ãƒ­ãƒƒãƒˆã«å¯¾å¿œã—ã¦ãŠã‚Šã€sublist ä¸­ã®å¼•æ•°ã¯ã€ä»–ã®å…¨ã¦ã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã«å¯¾ã™ã‚‹å‡¦ç†ãŒçµ‚ã‚ã£ãŸå¾Œã«ã€é€šå¸¸ã®ã‚¿ãƒ—ãƒ«å½¢å¼ã®ä»£å…¥è¦å‰‡ã‚’ä½¿ã£ã¦ã‚¹ãƒ­ãƒƒãƒˆã«å…¥ã‚Œã‚‰ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:793
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr "å‘¼ã³å‡ºã—ã‚’è¡Œã†ã¨ã€ä¾‹å¤–ã‚’é€å‡ºã—ãªã„é™ã‚Šã€å¸¸ã«ä½•ã‚‰ã‹ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚ ``None`` ã‚’è¿”ã™å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚æˆ»ã‚Šå€¤ãŒã©ã®ã‚ˆã†ã«ç®—å‡ºã•ã‚Œã‚‹ã‹ã¯ã€å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å½¢æ…‹ã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:797
msgid "If it is---"
msgstr "ã“ã‚ŒãŒ---"

#: ../../reference/expressions.rst:810
msgid "a user-defined function:"
msgstr "ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°:"

#: ../../reference/expressions.rst:806
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr "é–¢æ•°ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã«å¼•æ•°ãƒªã‚¹ãƒˆãŒæ¸¡ã•ã‚Œã€å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã¯ã€ã¾ãšä»®å¼•æ•°ã‚’å®Ÿå¼•æ•°ã«çµåˆ (bind) ã—ã¾ã™; ã“ã®å‹•ä½œã«ã¤ã„ã¦ã¯ :ref:`function` ã§è¨˜è¿°ã—ã¦ã„ã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã§ :keyword:`return` æ–‡ãŒå®Ÿè¡Œã•ã‚Œã‚‹éš›ã«ã€é–¢æ•°å‘¼ã³å‡ºã—ã®æˆ»ã‚Šå€¤ (return value) ãŒæ±ºå®šã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:824
msgid "a built-in function or method:"
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•°ã¾ãŸã¯ãƒ¡ã‚½ãƒƒãƒ‰:"

#: ../../reference/expressions.rst:823
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr "çµæœã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ä¾å­˜ã—ã¾ã™; çµ„ã¿è¾¼ã¿é–¢æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã®è©³ç´°ã¯ :ref:`built-in-funcs` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:831
msgid "a class object:"
msgstr "ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ:"

#: ../../reference/expressions.rst:831
msgid "A new instance of that class is returned."
msgstr "ãã®ã‚¯ãƒ©ã‚¹ã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:841
msgid "a class instance method:"
msgstr "ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰:"

#: ../../reference/expressions.rst:839
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr "å¯¾å¿œã™ã‚‹ãƒ¦ãƒ¼ã‚¶å®šç¾©ã®é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®ã¨ãã€å‘¼ã³å‡ºã—æ™‚ã®å¼•æ•°ãƒªã‚¹ãƒˆã‚ˆã‚Šä¸€ã¤é•·ã„å¼•æ•°ãƒªã‚¹ãƒˆã§å‘¼ã³å‡ºã•ã‚Œã¾ã™: ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒå¼•æ•°ãƒªã‚¹ãƒˆã®å…ˆé ­ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:850
msgid "a class instance:"
msgstr "ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹:"

#: ../../reference/expressions.rst:848
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the same"
" as if that method was called."
msgstr "ã‚¯ãƒ©ã‚¹ã§ :meth:`__call__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; :meth:`__call__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆã¨åŒã˜åŠ¹æœã‚’ã‚‚ãŸã‚‰ã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:855
msgid "The power operator"
msgstr "ã¹ãä¹—æ¼”ç®— (power operator)"

#: ../../reference/expressions.rst:857
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr "ã¹ãä¹—æ¼”ç®—ã¯ã€å·¦å´ã«ã‚ã‚‹å˜é …æ¼”ç®—å­ã‚ˆã‚Šã‚‚å¼·ã„çµåˆå„ªå…ˆé †ä½ãŒã‚ã‚Šã¾ã™; ä¸€æ–¹ã€å³å´ã«ã‚ã‚‹å˜é …æ¼”ç®—å­ã‚ˆã‚Šã¯ä½ã„çµåˆå„ªå…ˆé †ä½ã«ãªã£ã¦ã„ã¾ã™ã€‚æ§‹æ–‡ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™:"

#: ../../reference/expressions.rst:863
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr "å¾“ã£ã¦ã€ã¹ãä¹—æ¼”ç®—å­ã¨å˜é …æ¼”ç®—å­ã‹ã‚‰ãªã‚‹æ¼”ç®—åˆ—ãŒä¸¸æ‹¬å¼§ã§å›²ã‚ã‚Œã¦ã„ãªã„å ´åˆã€æ¼”ç®—å­ã¯å³ã‹ã‚‰å·¦ã¸ã¨è©•ä¾¡ã•ã‚Œã¾ã™ (ã“ã®å ´åˆã¯æ¼”ç®—å­ã®è©•ä¾¡é †åºã‚’å¼·åˆ¶ã—ã¾ã›ã‚“ã€‚ã¤ã¾ã‚Š ``-1**2`` ã¯ ``-1`` ã«ãªã‚Šã¾ã™)ã€‚"

#: ../../reference/expressions.rst:867
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised"
" to the power of its right argument.  The numeric arguments are first "
"converted to a common type.  The result type is that of the arguments after "
"coercion."
msgstr "ã¹ãä¹—æ¼”ç®—å­ã¯ã€äºŒã¤ã®å¼•æ•°ã§å‘¼ã³å‡ºã•ã‚Œã‚‹çµ„ã¿è¾¼ã¿é–¢æ•° :func:`pow` ã¨åŒã˜æ„å‘³ä»˜ã‘ã‚’æŒã£ã¦ã„ã¾ã™ã€‚å¼•æ•°ã¯ã¾ãšå…±é€šã®å‹ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚çµæœã®å‹ã¯ã€å‹å¼·åˆ¶å¾Œã®å¼•æ•°ã®å‹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:872
msgid ""
"With mixed operand types, the coercion rules for binary arithmetic operators"
" apply. For int and long int operands, the result has the same type as the "
"operands (after coercion) unless the second argument is negative; in that "
"case, all arguments are converted to float and a float result is delivered. "
"For example, ``10**2`` returns ``100``, but ``10**-2`` returns ``0.01``. "
"(This last feature was added in Python 2.2. In Python 2.1 and before, if "
"both arguments were of integer types and the second argument was negative, "
"an exception was raised)."
msgstr "å¼•æ•°å‹ã‚’æ··åˆã™ã‚‹ã¨ã€äºŒé …ç®—è¡“æ¼”ç®—ã«ãŠã‘ã‚‹å‹å¼·åˆ¶è¦å‰‡ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚æ•´æ•°ã‚„é•·æ•´æ•°ã®è¢«æ¼”ç®—å­ã®å ´åˆã€ç¬¬äºŒå¼•æ•°ãŒè² ã§ãªã„é™ã‚Šã€çµæœã¯ (å‹å¼·åˆ¶å¾Œã®) è¢«æ¼”ç®—å­ã¨åŒã˜ã«ãªã‚Šã¾ã™; ç¬¬äºŒå¼•æ•°ãŒè² ã®å ´åˆã€å…¨ã¦ã®å¼•æ•°ã¯æµ®å‹•å°æ•°ç‚¹å‹ã«å¤‰æ›ã•ã‚Œã€æµ®å‹•å°æ•°ç‚¹å‹ãŒè¿”ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã° ``10**2`` ã¯ ``100`` ã‚’è¿”ã—ã¾ã™ãŒã€ ``10**-2`` ã¯ ``0.01`` ã‚’è¿”ã—ã¾ã™ã€‚ (ä¸Šè¿°ã®ä»•æ§˜ã®ã†ã¡ã€æœ€å¾Œã®ã‚‚ã®ã¯ Python 2.2 ã§è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ Python 2.1 ä»¥å‰ã§ã¯ã€åŒæ–¹ã®å¼•æ•°ãŒæ•´æ•°å‹ã§ã€ç¬¬äºŒå¼•æ•°ãŒè² ã®å ´åˆã€ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¦ã„ã¾ã—ãŸã€‚)"

#: ../../reference/expressions.rst:881
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a "
":exc:`ValueError`."
msgstr "``0.0`` ã‚’è² ã®æ•°ã§ã¹ãä¹—ã™ã‚‹ã¨ :exc:`ZeroDivisionError` ã‚’é€å‡ºã—ã¾ã™ã€‚è² ã®æ•°ã‚’å°æ•°ã§ã¹ãä¹—ã™ã‚‹ã¨ :exc:`ValueError` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:888
msgid "Unary arithmetic and bitwise operations"
msgstr "å˜é …ç®—è¡“æ¼”ç®—ã¨ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—(unary arithmetic and bitwise operation)"

#: ../../reference/expressions.rst:894
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr "å…¨ã¦ã®å˜é …ç®—è¡“æ¼”ç®—ã¨ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—ã¯ã€åŒã˜å„ªå…ˆé †ä½ã‚’æŒã£ã¦ã„ã¾ã™:"

#: ../../reference/expressions.rst:903
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric "
"argument."
msgstr "å˜é …æ¼”ç®—å­ ``-`` (ãƒã‚¤ãƒŠã‚¹) ã¯ã€å¼•æ•°ã¨ãªã‚‹æ•°å€¤ã®ç¬¦å·ã‚’åè»¢ (negation) ã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:907
msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr "å˜é …æ¼”ç®—å­ ``+`` (ãƒ—ãƒ©ã‚¹) ã¯ã€æ•°å€¤å¼•æ•°ã‚’å¤‰æ›´ã—ã¾ã›ã‚“ã€‚"

#: ../../reference/expressions.rst:911
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its plain "
"or long integer argument.  The bitwise inversion of ``x`` is defined as "
"``-(x+1)``.  It only applies to integral numbers."
msgstr "å˜é …æ¼”ç®—å­ ``~`` (åè»¢) ã¯ã€æ•´æ•°ã¾ãŸã¯é•·æ•´æ•°ã®å¼•æ•°ã‚’ãƒ“ãƒƒãƒˆå˜ä½åè»¢ (bitwise invert) ã—ã¾ã™ã€‚ ``x`` ã®ãƒ“ãƒƒãƒˆå˜ä½åè»¢ã¯ã€ ``-(x+1)`` ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®æ¼”ç®—å­ã¯æ•´æ•°ã«ã®ã¿é©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:917
msgid ""
"In all three cases, if the argument does not have the proper type, a "
":exc:`TypeError` exception is raised."
msgstr "ä¸Šè¨˜ã®ä¸‰ã¤ã¯ã„ãšã‚Œã‚‚ã€å¼•æ•°ãŒæ­£ã—ã„å‹ã§ãªã„å ´åˆã«ã¯ :exc:`TypeError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:924
msgid "Binary arithmetic operations"
msgstr "äºŒé …ç®—è¡“æ¼”ç®— (binary arithmetic operation)"

#: ../../reference/expressions.rst:928
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types."
"  Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr "äºŒé …ç®—è¡“æ¼”ç®—ã¯ã€æ…£ç¿’çš„ãªå„ªå…ˆé †ä½ã‚’è¸è¥²ã—ã¦ã„ã¾ã™ã€‚æ¼”ç®—å­ã®ã„ãšã‚Œã‹ã¯ã€ç‰¹å®šã®éæ•°å€¤å‹ã«ã‚‚é©ç”¨ã•ã‚Œã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã¹ãä¹— (power) æ¼”ç®—å­ã‚’é™¤ãã€æ¼”ç®—å­ã«ã¯äºŒã¤ã®ãƒ¬ãƒ™ãƒ«ã€ã™ãªã‚ã¡ä¹—ç®—çš„ (multiplicatie) æ¼”ç®—å­ã¨åŠ ç®—çš„ (additie) æ¼”ç®—å­ã—ã‹ã‚ã‚Šã¾ã›ã‚“:"

#: ../../reference/expressions.rst:940
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer (plain or long) and the other must be a sequence. In the former "
"case, the numbers are converted to a common type and then multiplied "
"together.  In the latter case, sequence repetition is performed; a negative "
"repetition factor yields an empty sequence."
msgstr "``*`` (ä¹—ç®—: multiplication) æ¼”ç®—ã¯ã€å¼•æ•°é–“ã®ç©ã«ãªã‚Šã¾ã™ã€‚å¼•æ•°ã®çµ„ã¯ã€åŒæ–¹ã¨ã‚‚ã«æ•°å€¤å‹ã§ã‚ã‚‹ã‹ã€ç‰‡æ–¹ãŒæ•´æ•° (é€šå¸¸ã®æ•´æ•°ã¾ãŸã¯é•·æ•´æ•°) å‹ã§ä»–æ–¹ãŒã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã‹ã®ã©ã¡ã‚‰ã‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å‰è€…ã®å ´åˆã€æ•°å€¤ã¯å…±é€šã®å‹ã«å¤‰æ›ã•ã‚ŒãŸå¾Œä¹—ç®—ã•ã‚Œã¾ã™ã€‚å¾Œè€…ã®å ´åˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ç¹°ã‚Šè¿”ã—æ“ä½œãŒè¡Œã‚ã‚Œã¾ã™ã€‚ç¹°ã‚Šè¿”ã—æ•°ã‚’è² ã«ã™ã‚‹ã¨ã€ç©ºã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:951
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a"
" common type. Plain or long integer division yields an integer of the same "
"type; the result is that of mathematical division with the 'floor' function "
"applied to the result. Division by zero raises the :exc:`ZeroDivisionError` "
"exception."
msgstr "``/`` (é™¤ç®—: division) ãŠã‚ˆã³ ``//`` (åˆ‡ã‚Šæ¨ã¦é™¤ç®—: floor division) ã¯ã€å¼•æ•°é–“ã®å•†ã«ãªã‚Šã¾ã™ã€‚æ•°å€¤å¼•æ•°ã¯ã¾ãšå…±é€šã®å‹ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚æ•´æ•°ã¾ãŸã¯é•·æ•´æ•°ã®é™¤ç®—çµæœã¯ã€åŒã˜å‹ã®æ•´æ•°ã«ãªã‚Šã¾ã™; ã“ã®å ´åˆã€çµæœã¯æ•°å­¦çš„ãªé™¤ç®—ã«é–¢æ•° 'floor' ã‚’é©ç”¨ã—ãŸã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚ã‚¼ãƒ­ã«ã‚ˆã‚‹é™¤ç®—ã‚’è¡Œã†ã¨ :exc:`ZeroDivisionError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:959
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or"
" zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr "``%`` (ãƒ¢ã‚¸ãƒ¥ãƒ­: modulo) æ¼”ç®—ã¯ã€ç¬¬ä¸€å¼•æ•°ã‚’ç¬¬äºŒå¼•æ•°ã§é™¤ç®—ã—ãŸã¨ãã®å‰°ä½™ã«ãªã‚Šã¾ã™ã€‚æ•°å€¤å¼•æ•°ã¯ã¾ãšå…±é€šã®å‹ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚å³å¼•æ•°å€¤ãŒã‚¼ãƒ­ã®å ´åˆã«ã¯ :exc:`ZeroDivisionError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚å¼•æ•°å€¤ã¯æµ®å‹•å°æ•°ç‚¹ã§ã‚‚ã‚ˆãã€‚ä¾‹ãˆã° ``3.14%0.7`` ã¯ ``0.34`` ã«ãªã‚Šã¾ã™ (``3.14`` ã¯ ``4*0.7 + 0.34`` ã ã‹ã‚‰ã§ã™)ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ­æ¼”ç®—å­ã¯å¸¸ã«ç¬¬äºŒå¼•æ•°ã¨åŒã˜ç¬¦å· (ã¾ãŸã¯ã‚¼ãƒ­) ã®çµæœã«ãªã‚Šã¾ã™; ãƒ¢ã‚¸ãƒ¥ãƒ­æ¼”ç®—ã®çµæœã®çµ¶å¯¾å€¤ã¯ã€å¸¸ã«ç¬¬äºŒå¼•æ•°ã®çµ¶å¯¾å€¤ã‚ˆã‚Šã‚‚å°ã•ããªã‚Šã¾ã™ã€‚ [#]_"

#: ../../reference/expressions.rst:968
msgid ""
"The integer division and modulo operators are connected by the following "
"identity: ``x == (x/y)*y + (x%y)``.  Integer division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x/y,"
" x%y)``.  These identities don't hold for floating point numbers; there "
"similar identities hold approximately where ``x/y`` is replaced by "
"``floor(x/y)`` or ``floor(x/y) - 1`` [#]_."
msgstr "æ•´æ•°ã«ã‚ˆã‚‹é™¤ç®—æ¼”ç®—ã‚„ãƒ¢ã‚¸ãƒ¥ãƒ­æ¼”ç®—ã¯ã€æ’ç­‰å¼: ``x == (x/y)*y + (x%y)`` ã¨é–¢ä¿‚ã—ã¦ã„ã¾ã™ã€‚æ•´æ•°é™¤ç®—ã‚„ãƒ¢ã‚¸ãƒ¥ãƒ­ã¯ã¾ãŸã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`divmod`: ``divmod(x, y) == (x/y, x%y)`` ã¨é–¢ä¿‚ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®æ’ç­‰é–¢ä¿‚ã¯æµ®å‹•å°æ•°ç‚¹ã®å ´åˆã«ã¯ç¶­æŒã•ã‚Œã¾ã›ã‚“; ``x/y`` ãŒ ``floor(x/y)`` ã‚„ ``floor(x/y) - 1`` ã«ç½®ãæ›ãˆã‚‰ã‚ŒãŸå ´åˆã€ã“ã‚Œã‚‰ã®æ’ç­‰å¼ã¯è¿‘ä¼¼æ€§ã‚’ç¶­æŒã—ã¾ã™ã€‚ [#]_"

#: ../../reference/expressions.rst:975
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string and unicode objects to perform string "
"formatting (also known as interpolation). The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`string-"
"formatting`."
msgstr "æ•°å€¤ã«å¯¾ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ­æ¼”ç®—ã®å®Ÿè¡Œã«åŠ ãˆã¦ ``%`` æ¼”ç®—å­ã¯æ–‡å­—åˆ— (string) ã¨ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã€æ–‡å­—åˆ—ã®æ›¸å¼åŒ– (æ–‡å­—åˆ—ã®æŒ¿å…¥ã¨ã—ã¦ã‚‚çŸ¥ã‚‰ã‚Œã‚‹) ã‚’è¡Œã„ã¾ã™ã€‚æ–‡å­—åˆ—ã®æ›¸å¼åŒ–ã®æ§‹æ–‡ã¯ Python ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ :ref:`string-formatting` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:980
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are no longer defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr "åˆ‡ã‚Šæ¨ã¦é™¤ç®—æ¼”ç®—å­ã€ãƒ¢ã‚¸ãƒ¥ãƒ­æ¼”ç®—å­ã€ãŠã‚ˆã³ :func:`divmod` é–¢æ•°ã¯ã€è¤‡ç´ æ•°ã«å¯¾ã—ã¦ã¯ã‚‚ã¯ã‚„å®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ç›®çš„ã«åˆã†ãªã‚‰ã°ã€ä»£ã‚ã‚Šã« :func:`abs` ã‚’ä½¿ã£ã¦æµ®å‹•å°æ•°ç‚¹ã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:987
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments. The arguments"
" must either both be numbers or both sequences of the same type.  In the "
"former case, the numbers are converted to a common type and then added "
"together.  In the latter case, the sequences are concatenated."
msgstr "``+`` (åŠ ç®—) æ¼”ç®—ã¯ã€å¼•æ•°ã‚’åŠ ç®—ã—ãŸå€¤ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•°ã¯åŒæ–¹ã¨ã‚‚æ•°å€¤å‹ã‹ã€åŒæ–¹ã¨ã‚‚åŒã˜å‹ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å‰è€…ã®å ´åˆã€æ•°å€¤ã¯å…±é€šã®å‹ã«å¤‰æ›ã•ã‚Œã€åŠ ç®—ã•ã‚Œã¾ã™ã€‚å¾Œè€…ã®å ´åˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯çµåˆ (concatenate) ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:994
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr "``-`` (æ¸›ç®—) æ¼”ç®—ã¯ã€å¼•æ•°é–“ã§æ¸›ç®—ã‚’è¡Œã£ãŸå€¤ã‚’è¿”ã—ã¾ã™ã€‚æ•°å€¤å¼•æ•°ã¯ã¾ãšå…±é€šã®å‹ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:1001
msgid "Shifting operations"
msgstr "ã‚·ãƒ•ãƒˆæ¼”ç®— (shifting operation)"

#: ../../reference/expressions.rst:1005
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr "ã‚·ãƒ•ãƒˆæ¼”ç®—ã¯ã€ç®—è¡“æ¼”ç®—ã‚ˆã‚Šã‚‚ä½ã„å„ªå…ˆé †ä½ã‚’æŒã£ã¦ã„ã¾ã™:"

#: ../../reference/expressions.rst:1010
msgid ""
"These operators accept plain or long integers as arguments.  The arguments "
"are converted to a common type.  They shift the first argument to the left "
"or right by the number of bits given by the second argument."
msgstr "ã‚·ãƒ•ãƒˆã®æ¼”ç®—å­ã¯æ•´æ•°ã¾ãŸã¯é•·æ•´æ•°ã‚’å¼•æ•°ã«ã¨ã‚Šã¾ã™ã€‚å¼•æ•°ã¯å…±é€šã®å‹ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚ã‚·ãƒ•ãƒˆæ¼”ç®—ã§ã¯ã€æœ€åˆã®å¼•æ•°ã‚’äºŒã¤ç›®ã®å¼•æ•°ã«å¿œã˜ãŸãƒ“ãƒƒãƒˆæ•°ã ã‘ã€å·¦ã¾ãŸã¯å³ã«ãƒ“ãƒƒãƒˆã‚·ãƒ•ãƒˆã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:1016
msgid ""
"A right shift by *n* bits is defined as division by ``pow(2, n)``.  A left "
"shift by *n* bits is defined as multiplication with ``pow(2, n)``.  Negative"
" shift counts raise a :exc:`ValueError` exception."
msgstr "*n* ãƒ“ãƒƒãƒˆã®å³ã‚·ãƒ•ãƒˆã¯ ``pow(2,n)`` ã«ã‚ˆã‚‹é™¤ç®—ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ *n* ãƒ“ãƒƒãƒˆã®å·¦ã‚·ãƒ•ãƒˆã¯ ``pow(2,n)`` ã«ã‚ˆã‚‹ä¹—ç®—ã¨ã—ã¦å®šç¾©ã•ã‚Œã¾ã™ã€‚è² ã®ãƒ“ãƒƒãƒˆæ•°ã§ã‚·ãƒ•ãƒˆã‚’è¡Œã†ã¨ :exc:`ValueError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:1022
msgid ""
"In the current implementation, the right-hand operand is required to be at "
"most :attr:`sys.maxsize`.  If the right-hand operand is larger than "
":attr:`sys.maxsize` an :exc:`OverflowError` exception is raised."
msgstr "ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€å³è¾ºè¢«æ¼”ç®—å­ã¯æœ€å¤§ã§ã‚‚ :attr:`sys.maxsize` ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å³è¾ºè¢«æ¼”ç®—å­ãŒ :attr:`sys.maxsize` ã‚ˆã‚Šã‚‚å¤§ãã„ã¨ã€ :exc:`OverflowError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:1029
msgid "Binary bitwise operations"
msgstr "ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—ã®äºŒé …æ¼”ç®— (binary bitwise operation)"

#: ../../reference/expressions.rst:1033
msgid "Each of the three bitwise operations has a different priority level:"
msgstr "ä»¥ä¸‹ã®ä¸‰ã¤ã®ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—ã«ã¯ã€ãã‚Œãã‚Œç•°ãªã‚‹å„ªå…ˆé †ä½ãƒ¬ãƒ™ãƒ«ãŒã‚ã‚Šã¾ã™:"

#: ../../reference/expressions.rst:1042
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"plain or long integers.  The arguments are converted to a common type."
msgstr "``&`` æ¼”ç®—å­ã¯ã€å¼•æ•°é–“ã§ãƒ“ãƒƒãƒˆå˜ä½ã® AND ã‚’ã¨ã£ãŸå€¤ã«ãªã‚Šã¾ã™ã€‚å¼•æ•°ã¯æ•´æ•°ã¾ãŸã¯é•·æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å¼•æ•°ã¯å…±é€šã®å‹ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:1049
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be plain or long integers.  The arguments are converted to a "
"common type."
msgstr "``^`` æ¼”ç®—å­ã¯ã€å¼•æ•°é–“ã§ãƒ“ãƒƒãƒˆå˜ä½ã® XOR (æ’ä»–çš„ OR) ã‚’ã¨ã£ãŸå€¤ã«ãªã‚Šã¾ã™ã€‚å¼•æ•°ã¯æ•´æ•°ã¾ãŸã¯é•·æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å¼•æ•°ã¯å…±é€šã®å‹ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:1056
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which"
" must be plain or long integers.  The arguments are converted to a common "
"type."
msgstr "``|`` æ¼”ç®—å­ã¯ã€å¼•æ•°é–“ã§ãƒ“ãƒƒãƒˆå˜ä½ã® OR (éæ’ä»–çš„ OR) ã‚’ã¨ã£ãŸå€¤ã«ãªã‚Šã¾ã™ã€‚å¼•æ•°ã¯æ•´æ•°ã¾ãŸã¯é•·æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å¼•æ•°ã¯å…±é€šã®å‹ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:1063
msgid "Comparisons"
msgstr "æ¯”è¼ƒ"

#: ../../reference/expressions.rst:1069
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr "C è¨€èªã¨é•ã£ã¦ã€Python ã«ãŠã‘ã‚‹æ¯”è¼ƒæ¼”ç®—å­ã¯åŒã˜å„ªå…ˆé †ä½ã‚’ã‚‚ã£ã¦ãŠã‚Šã€å…¨ã¦ã®ç®—è¡“æ¼”ç®—å­ã€ã‚·ãƒ•ãƒˆæ¼”ç®—å­ã€ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—å­ã‚ˆã‚Šã‚‚ä½ããªã£ã¦ã„ã¾ã™ã€‚ã¾ãŸ ``a < b < c`` ãŒæ•°å­¦ã§ä¼çµ±çš„ã«ç”¨ã„ã‚‰ã‚Œã¦ã„ã‚‹ã®ã¨åŒã˜è§£é‡ˆã«ãªã‚‹ç‚¹ã‚‚ C è¨€èªã¨é•ã„ã¾ã™:"

#: ../../reference/expressions.rst:1079
msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr "æ¯”è¼ƒæ¼”ç®—ã®çµæœã¯ãƒ–ãƒ¼ãƒ«å€¤: ``True`` ã¾ãŸã¯ ``False`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:1083
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr "æ¯”è¼ƒã¯ã„ãã‚‰ã§ã‚‚é€£é–ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã° ``x < y <= z`` ã¯ ``x < y and y <= z`` ã¨ç­‰ä¾¡ã«ãªã‚Šã¾ã™ã€‚ãŸã ã—ã“ã®å ´åˆã€å‰è€…ã§ã¯ ``y`` ã¯ãŸã ä¸€åº¦ã ã‘è©•ä¾¡ã•ã‚Œã‚‹ç‚¹ãŒç•°ãªã‚Šã¾ã™ (ã©ã¡ã‚‰ã®å ´åˆã§ã‚‚ã€ ``x < y`` ãŒå½ã«ãªã‚‹ã¨ ``z`` ã®å€¤ã¯ã¾ã£ãŸãè©•ä¾¡ã•ã‚Œã¾ã›ã‚“)ã€‚"

#: ../../reference/expressions.rst:1087
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, *op2*, "
"..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN z`` is "
"equivalent to ``a op1 b and b op2 c and ... y opN z``, except that each "
"expression is evaluated at most once."
msgstr "å½¢å¼çš„ã«ã¯ã€ *a*, *b*, *c*, ..., *y*, *z* ãŒå¼ã§ *op1*, *op2*, ..., *opN* ãŒæ¯”è¼ƒæ¼”ç®—å­ã§ã‚ã‚‹å ´åˆã€ ``a op1 b op2 c ... y opN z`` ã¯ ``a op1 b and b op2 c and ... y opN z`` ã¨ç­‰ä¾¡ã«ãªã‚Šã¾ã™ã€‚ãŸã ã—ã€å‰è€…ã§ã¯å„å¼ã¯å¤šãã¦ã‚‚ä¸€åº¦ã—ã‹è©•ä¾¡ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../reference/expressions.rst:1092
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a*"
" and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps "
"not pretty)."
msgstr "``a op1 b op2 c`` ã¨æ›¸ã„ãŸå ´åˆã€ *a* ã‹ã‚‰ *c* ã¾ã§ã®ç¯„å›²ã«ã‚ã‚‹ã‹ã©ã†ã‹ã®ãƒ†ã‚¹ãƒˆã‚’æŒ‡ã™ã®ã§ã¯ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ä¾‹ãˆã° ``x < y > z`` ã¯ (ãã‚Œã„ãªæ›¸ãæ–¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒ) å®Œå…¨ã«æ­£ã—ã„æ–‡æ³•ã§ã™ã€‚"

#: ../../reference/expressions.rst:1096
msgid ""
"The forms ``<>`` and ``!=`` are equivalent; for consistency with C, ``!=`` "
"is preferred; where ``!=`` is mentioned below ``<>`` is also accepted.  The "
"``<>`` spelling is considered obsolescent."
msgstr "``<>`` ã¨ ``!=`` ã®äºŒã¤ã®å½¢å¼ã¯ç­‰ä¾¡ã§ã™; C ã¨ã®æ•´åˆæ€§ã‚’æŒãŸã›ã‚‹ãŸã‚ã«ã¯ ``!=`` ã‚’æ¨å¥¨ã—ã¾ã™; ä»¥ä¸‹ã§ ``!=`` ã«ã¤ã„ã¦è§¦ã‚Œã¦ã„ã‚‹éƒ¨åˆ†ã§ã¯ ``<>`` ã‚’ä½¿ã†ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ ``<>`` ã®ã‚ˆã†ãªæ›¸ãæ–¹ã¯ã€ç¾åœ¨ã§ã¯å¤ã„æ›¸ãæ–¹ã¨ã¿ãªã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/expressions.rst:1101
msgid "Value comparisons"
msgstr "å€¤ã®æ¯”è¼ƒ"

#: ../../reference/expressions.rst:1103
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects do not need to have the same type."
msgstr "æ¼”ç®—å­ ``<``, ``>``, ``==``, ``>=``, ``<=``, ãŠã‚ˆã³ ``!=`` ã¯2ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã‚’æ¯”è¼ƒã—ã¾ã™ã€‚\nã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒåŒã˜å‹ã‚’æŒã¤å¿…è¦ã¯ã‚Šã¾ã›ã‚“ã€‚"

#: ../../reference/expressions.rst:1106
msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to type"
" and identity).  The value of an object is a rather abstract notion in "
"Python: For example, there is no canonical access method for an object's "
"value.  Also, there is no requirement that the value of an object should be "
"constructed in a particular way, e.g. comprised of all its data attributes. "
"Comparison operators implement a particular notion of what the value of an "
"object is.  One can think of them as defining the value of an object "
"indirectly, by means of their comparison implementation."
msgstr ":ref:`objects` ã®ç« ã§ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ (å‹ã‚„åŒä¸€æ€§ã«åŠ ãˆã¦) å€¤ã‚’æŒã¤ã“ã¨ã‚’è¿°ã¹ã¦ã„ã¾ã™ã€‚\nã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã¯ Python ã§ã¯ã‚„ã‚„æŠ½è±¡çš„ãªæ¦‚å¿µã§ã™: ä¾‹ãˆã°ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ­£çµ±ãªæ–¹æ³•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚\nã¾ãŸã€ãã®å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿å±æ€§ã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹ãªã©ã®ç‰¹å®šã®æ–¹æ³•ã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã‚’æ§‹ç¯‰ã™ã‚‹å¿…è¦æ€§ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚\næ¯”è¼ƒæ¼”ç®—å­ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã¨ã¯ä½•ã‹ã«ã¤ã„ã¦ã®ç‰¹å®šã®æ¦‚å¿µã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚\nã“ã®æ¯”è¼ƒã®å®Ÿè£…ã«ã‚ˆã£ã¦ã€é–“æ¥çš„ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã‚’å®šç¾©ã—ã¦ã„ã‚‹è€ƒãˆã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../reference/expressions.rst:1115
msgid ""
"Types can customize their comparison behavior by implementing a "
":meth:`__cmp__` method or :dfn:`rich comparison methods` like "
":meth:`__lt__`, described in :ref:`customization`."
msgstr ":ref:`customization` ã§è§£èª¬ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã€å‹ã‚’ä½¿ã£ã¦ :meth:`__cmp__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚„ :dfn:`rich comparison methods` ã§ã‚ã‚‹ :meth:`__lt__` ãªã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€ æ¯”è¼ƒã®æŒ¯ã‚‹èˆã„ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚"

#: ../../reference/expressions.rst:1120
msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based on"
" the identity of the objects.  Hence, equality comparison of instances with "
"the same identity results in equality, and equality comparison of instances "
"with different identities results in inequality.  A motivation for this "
"default behavior is the desire that all objects should be reflexive (i.e. "
"``x is y`` implies ``x == y``)."
msgstr "ç­‰ä¾¡æ€§æ¯”è¼ƒ (``==`` ãŠã‚ˆã³ ``!=``) ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æŒ¯ã‚‹èˆã„ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŒä¸€æ€§ã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚\nå¾“ã£ã¦ã€åŒä¸€ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ç­‰ä¾¡æ€§æ¯”è¼ƒã¯ç­‰ä¾¡ã¨ãªã‚Šã€åŒä¸€ã§ãªã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ç­‰ä¾¡æ€§æ¯”è¼ƒã¯ç­‰ä¾¡ã§ãªã„ã¨ãªã‚Šã¾ã™ã€‚\nãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æŒ¯ã‚‹èˆã„ã‚’ã“ã®ã‚ˆã†ã«ã—ãŸã®ã¯ã€å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åå°„çš„ (reflexive ã¤ã¾ã‚Š ``x is y`` ãªã‚‰ã° ``x == y``) ãªã‚‚ã®ã«ã—ãŸã‹ã£ãŸã‹ã‚‰ã§ã™ã€‚"

#: ../../reference/expressions.rst:1127
msgid ""
"The default order comparison (``<``, ``>``, ``<=``, and ``>=``) gives a "
"consistent but arbitrary order."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®é †åºæ¯”è¼ƒ (``<``, ``>``, ``<=``, ``>=``) ã¯ä¸€è²«æ€§ã¯ã‚ã‚Šã¾ã™ãŒã„ã„åŠ æ¸›ãªé †åºã§ã™ã€‚"

#: ../../reference/expressions.rst:1130
msgid ""
"(This unusual definition of comparison was used to simplify the definition "
"of operations like sorting and the :keyword:`in` and :keyword:`not in` "
"operators. In the future, the comparison rules for objects of different "
"types are likely to change.)"
msgstr "(ã“ã®ã‚ˆã†ãªæ¯”è¼ƒæ¼”ç®—ã®å¤‰å‰‡çš„ãªå®šç¾©ã¯ã€ã‚½ãƒ¼ãƒˆã®ã‚ˆã†ãªæ“ä½œã‚„ :keyword:`in` ãŠã‚ˆã³ :keyword:`not in` ã¨ã„ã£ãŸæ¼”ç®—å­ã®å®šç¾©ã‚’å˜ç´”åŒ–ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚å°†æ¥ã€ç•°ãªã‚‹å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé–“ã«ãŠã‘ã‚‹æ¯”è¼ƒè¦å‰‡ã¯å¤‰æ›´ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚)"

#: ../../reference/expressions.rst:1135
msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types "
"will need that have a sensible definition of object value and value-based "
"equality.  Such types will need to customize their comparison behavior, and "
"in fact, a number of built-in types have done that."
msgstr "åŒä¸€ã§ãªã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯å¸¸ã«ç­‰ä¾¡ã§ãªã„ã¨ã™ã‚‹ç­‰ä¾¡æ€§æ¯”è¼ƒã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æŒ¯ã‚‹èˆã„ã¯ã€å‹ãŒå¿…è¦ã¨ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã‚„å€¤ã«åŸºã¥ã„ãŸç­‰ä¾¡æ€§ã®å®Ÿç”¨çš„ãªå®šç¾©ã¨ã¯å¯¾ç…§çš„ã«æ€ãˆã‚‹ã§ã—ã‚‡ã†ã€‚\nãã®ã‚ˆã†ãªå‹ã§ã¯æ¯”è¼ƒã®æŒ¯ã‚‹èˆã„ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹å¿…è¦ãŒå‡ºã¦ãã¦ã€å®Ÿéš›ã«ãŸãã•ã‚“ã®çµ„ã¿è¾¼ã¿å‹ã§ãã‚ŒãŒè¡Œã‚ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/expressions.rst:1141
msgid ""
"The following list describes the comparison behavior of the most important "
"built-in types."
msgstr "æ¬¡ã®ãƒªã‚¹ãƒˆã§ã¯ã€æœ€é‡è¦ã®çµ„ã¿è¾¼ã¿å‹ã®æ¯”è¼ƒã®æŒ¯ã‚‹èˆã„ã‚’è§£èª¬ã—ã¦ã„ã¾ã™ã€‚"

#: ../../reference/expressions.rst:1144
msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard "
"library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can "
"be compared within and across their types, with the restriction that complex"
" numbers do not support order comparison.  Within the limits of the types "
"involved, they compare mathematically (algorithmically) correct without loss"
" of precision."
msgstr "ã„ãã¤ã‹ã®çµ„ã¿è¾¼ã¿ã®æ•°å€¤å‹ (:ref:`typesnumeric`) ã¨æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‹ :class:`fractions.Fraction` ãŠã‚ˆã³ :class:`decimal.Decimal` ã¯ã€åŒã˜å‹ã‚„åˆ¥ã®å‹ã©ã†ã—ã§æ¯”è¼ƒã§ãã¾ã™ãŒã€è¤‡ç´ æ•°ã§ã¯é †åºæ¯”è¼ƒãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã¨ã„ã†åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚\né–¢ã‚ã‚‹å‹ã®åˆ¶é™ã®ç¯„å›²å†…ã§ã¯ã€ç²¾åº¦ã®ãƒ­ã‚¹ç„¡ã—ã«æ•°å­¦çš„ã« (ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ çš„ã«) æ­£ã—ã„æ¯”è¼ƒãŒè¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:1151
msgid ""
"Strings (instances of :class:`str` or :class:`unicode`) compare "
"lexicographically using the numeric equivalents (the result of the built-in "
"function :func:`ord`) of their characters. [#]_ When comparing an 8-bit "
"string and a Unicode string, the 8-bit string is converted to Unicode.  If "
"the conversion fails, the strings are considered unequal."
msgstr "æ–‡å­—åˆ— (:class:`str` ã‚‚ã—ãã¯ :class:`unicode` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹) ã§ã¯ã€æ•°å€¤çš„ãªåŒç­‰æ€§ (çµ„ã¿è¾¼ã¿é–¢æ•° :func:`ord` ã®çµæœ) ã‚’ä½¿ã„ã€è¾æ›¸å¼ã®æ¯”è¼ƒã‚’è¡Œã„ã¾ã™ã€‚ [#]_\n8 bit æ–‡å­—åˆ—ã¨ Unicode æ–‡å­—åˆ—ã‚’æ¯”è¼ƒã™ã‚‹ã¨ãã¯ã€8 bit æ–‡å­—åˆ—ã¯ Unicode ã¸å¤‰æ›ã•ã‚Œã¾ã™ã€‚\nå¤‰æ›ãŒå¤±æ•—ã—ãŸå ´åˆã¯ã€ãã®æ–‡å­—åˆ—ã¯ç­‰ä¾¡ã§ãªã„ã¨è¦‹ãªã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:1158
msgid ""
"Instances of :class:`tuple` or :class:`list` can be compared only within "
"each of their types.  Equality comparison across these types results in "
"unequality, and ordering comparison across these types gives an arbitrary "
"order."
msgstr ":class:`tuple` ã‚„ :class:`list` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯åŒã˜å‹ã©ã†ã—ã§ã—ã‹æ¯”è¼ƒã§ãã¾ã›ã‚“ã€‚\nç•°ãªã‚‹å‹ã©ã†ã—ã§ã®ç­‰ä¾¡æ€§æ¯”è¼ƒã¯ç­‰ä¾¡ã§ãªã„ã¨ãªã‚Šã€ç•°ãªã‚‹å‹ã©ã†ã—ã§ã®é †åºæ¯”è¼ƒã¯ã„ã„åŠ æ¸›ãªé †åºã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:1163
msgid ""
"These sequences compare lexicographically using comparison of corresponding "
"elements, whereby reflexivity of the elements is enforced."
msgstr "ã“ã‚Œã‚‰ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã¯ã€è¦ç´ ã®åå°„æ€§ãŒã‚ã‚‹ã‚‚ã®ã¨ã—ã¦ã€å€‹ã€…ã®å¯¾å¿œã™ã‚‹è¦ç´ ã®æ¯”è¼ƒã‚’ä½¿ã£ã¦è¾æ›¸å¼ã®æ¯”è¼ƒãŒè¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:1166
msgid ""
"In enforcing reflexivity of elements, the comparison of collections assumes "
"that for a collection element ``x``, ``x == x`` is always true.  Based on "
"that assumption, element identity is compared first, and element comparison "
"is performed only for distinct elements.  This approach yields the same "
"result as a strict element comparison would, if the compared elements are "
"reflexive.  For non-reflexive elements, the result is different than for "
"strict element comparison."
msgstr "è¦ç´ ã®åå°„æ€§ãŒã‚ã‚‹ã‚‚ã®ã¨ã•ã‚Œã‚‹ã¨ã€ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®æ¯”è¼ƒã§ã¯ã€ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®è¦ç´  ``x`` ã«å¯¾ã—ã¦ ``x == x`` ãŒå¸¸ã«çœŸã ã¨ä»®å®šã—ã¾ã™ã€‚\nã“ã®ä»®å®šã«åŸºã¥ã„ã¦ã€æœ€åˆã«è¦ç´ ã®åŒä¸€æ€§ãŒæ¯”è¼ƒã•ã‚Œã€åŒä¸€ã§ãªã„è¦ç´ ã©ã†ã—ã«å¯¾ã—ã¦ã®ã¿è¦ç´ ã®æ¯”è¼ƒãŒè¡Œã‚ã‚Œã¾ã™ã€‚\nã“ã®æ‰‹æ³•ã¯ã€æ¯”è¼ƒã•ã‚Œã‚‹è¦ç´ ãŒåå°„çš„ãªå ´åˆã€å³å¯†ãªè¦ç´ æ¯”è¼ƒã¨åŒã˜çµæœã‚’ã‚‚ãŸã‚‰ã—ã¾ã™ã€‚\nåå°„çš„ã§ãªã„è¦ç´ ã§ã¯ã€å³å¯†ãªè¦ç´ æ¯”è¼ƒã¨ç•°ãªã‚‹çµæœã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:1174
msgid ""
"Lexicographical comparison between built-in collections works as follows:"
msgstr "çµ„ã¿è¾¼ã¿ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã©ã†ã—ã®è¾æ›¸å¼æ¯”è¼ƒã¯æ¬¡ã®ã‚ˆã†ã«å‹•ä½œã—ã¾ã™:"

#: ../../reference/expressions.rst:1176
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal "
"(for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr "æ¯”è¼ƒã®çµæœãŒç­‰ä¾¡ã¨ãªã‚‹2ã¤ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€åŒã˜å‹ã€åŒã˜é•·ã•ã€å¯¾å¿œã™ã‚‹è¦ç´ ã©ã†ã—ã®æ¯”è¼ƒã®çµæœãŒç­‰ä¾¡ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ (ä¾‹ãˆã°ã€ ``[1,2] == (1,2)`` ã¯å‹ãŒåŒã˜ã§ãªã„ã®ã§å½ã§ã™)ã€‚"

#: ../../reference/expressions.rst:1181
msgid ""
"Collections are ordered the same as their first unequal elements (for "
"example, ``cmp([1,2,x], [1,2,y])`` returns the same as ``cmp(x,y)``).  If a "
"corresponding element does not exist, the shorter collection is ordered "
"first (for example, ``[1,2] < [1,2,3]`` is true)."
msgstr "ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®é †åºã¯ã€æœ€åˆã®ç­‰ä¾¡ã§ãªã„è¦ç´ ã®é †åºã¨åŒã˜ã«ãªã‚Šã¾ã™ (ä¾‹ãˆã°ã€ ``cmp([1,2,x], [1,2,y])`` ã¯ ``cmp(x,y)`` ã¨åŒã˜è¿”ã‚Šå€¤ã«ãªã‚Šã¾ã™)ã€‚\nå¯¾å¿œã™ã‚‹è¦ç´ ãŒå­˜åœ¨ã—ãªã„å ´åˆã€çŸ­ã„æ–¹ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãŒé †åºã¨ã—ã¦å…ˆã¨ãªã‚Šã¾ã™ (ä¾‹ãˆã°ã€ ``[1,2] < [1,2,3]`` ã¯çœŸã§ã™)ã€‚"

#: ../../reference/expressions.rst:1187
msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they have"
" equal `(key, value)` pairs. Equality comparison of the keys and values "
"enforces reflexivity."
msgstr "ãƒãƒƒãƒ”ãƒ³ã‚° (:class:`dict` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹) ã®æ¯”è¼ƒã®çµæœãŒç­‰ä¾¡ã¨ãªã‚‹ã®ã¯ã€åŒã˜ `(key, value)` ã‚’æŒã£ã¦ã„ã‚‹ã¨ãã‹ã¤ãã®ã¨ãã«é™ã‚Šã¾ã™ã€‚\nã‚­ãƒ¼ã¨å€¤ã®ç­‰ä¾¡æ€§æ¯”è¼ƒã§ã¯åå°„æ€§ãŒå¼·åˆ¶ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:1191
msgid ""
"Outcomes other than equality are resolved consistently, but are not "
"otherwise defined. [#]_"
msgstr "ç­‰ä¾¡æ€§è©•ä¾¡ä»¥å¤–ã®çµæœã¯ä¸€è²«ã—ãŸã‚„ã‚Šã‹ãŸã§è§£æ±ºã•ã‚Œã‚‹ã‹ã€å®šç¾©ã•ã‚Œãªã„ã‹ã®ã„ãšã‚Œã‹ã§ã™ã€‚ [#]_"

#: ../../reference/expressions.rst:1194
msgid ""
"Most other objects of built-in types compare unequal unless they are the "
"same object; the choice whether one object is considered smaller or larger "
"than another one is made arbitrarily but consistently within one execution "
"of a program."
msgstr "ãã®ä»–ã®ã»ã¨ã‚“ã©ã®çµ„ã¿è¾¼ã¿å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ¯”è¼ƒã§ã¯ã€åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã„ã‹ãã‚Šç­‰ä¾¡ã«ã¯ãªã‚Šã¾ã›ã‚“; ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å¤§å°é–¢ä¿‚ã¯ä»»æ„ã«æ±ºå®šã•ã‚Œã€ä¸€ã¤ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡Œä¸­ã¯ä¸€è²«ã—ãŸã‚‚ã®ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:1199
msgid ""
"User-defined classes that customize their comparison behavior should follow "
"some consistency rules, if possible:"
msgstr "æ¯”è¼ƒã®æŒ¯ã‚‹èˆã„ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ãŸãƒ¦ãƒ¼ã‚¶å®šç¾©ã‚¯ãƒ©ã‚¹ã¯ã€å¯èƒ½ãªã‚‰æ¬¡ã®ä¸€è²«æ€§ã®è¦å‰‡ã«å¾“ã†å¿…è¦ãŒã‚ã‚Šã¾ã™:"

#: ../../reference/expressions.rst:1202
msgid ""
"Equality comparison should be reflexive. In other words, identical objects "
"should compare equal:"
msgstr "ç­‰ä¾¡æ¯”è¼ƒã¯åå°„çš„ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\nã¤ã¾ã‚Šã€åŒä¸€ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ç­‰ã—ããªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“:"

#: ../../reference/expressions.rst:1205
msgid "``x is y`` implies ``x == y``"
msgstr "``x is y`` ã¯æš—é»™çš„ã« ``x == y``"

#: ../../reference/expressions.rst:1207
msgid ""
"Comparison should be symmetric. In other words, the following expressions "
"should have the same result:"
msgstr "æ¯”è¼ƒã¯å¯¾ç§°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\nã¤ã¾ã‚Šã€ä»¥ä¸‹ã®å¼ã®çµæœã¯åŒã˜ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“:"

#: ../../reference/expressions.rst:1210
msgid "``x == y`` and ``y == x``"
msgstr "``x == y`` ã¨ ``y == x``"

#: ../../reference/expressions.rst:1212
msgid "``x != y`` and ``y != x``"
msgstr "``x != y`` ã¨ ``y != x``"

#: ../../reference/expressions.rst:1214
msgid "``x < y`` and ``y > x``"
msgstr "``x < y`` ã¨ ``y > x``"

#: ../../reference/expressions.rst:1216
msgid "``x <= y`` and ``y >= x``"
msgstr "``x <= y`` ã¨ ``y >= x``"

#: ../../reference/expressions.rst:1218
msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr "æ¯”è¼ƒã¯æ¨ç§»çš„ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\nä»¥ä¸‹ã® (åŒ…æ‹¬çš„ã§ãªã„) ä¾‹ãŒãã®èª¬æ˜ã§ã™:"

#: ../../reference/expressions.rst:1221
msgid "``x > y and y > z`` implies ``x > z``"
msgstr "``x > y and y > z`` ã¯æš—é»™çš„ã« ``x > z``"

#: ../../reference/expressions.rst:1223
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr "``x < y and y <= z`` ã¯æš—é»™çš„ã« ``x < z``"

#: ../../reference/expressions.rst:1225
msgid ""
"Inverse comparison should result in the boolean negation. In other words, "
"the following expressions should have the same result:"
msgstr "æ¯”è¼ƒã®é€†ã¯ãƒ–ãƒ¼ãƒ«ã®å¦å®šã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\nã¤ã¾ã‚Šã€ä»¥ä¸‹ã®å¼ã®çµæœã¯åŒã˜ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“:"

#: ../../reference/expressions.rst:1228
msgid "``x == y`` and ``not x != y``"
msgstr "``x == y`` ã¨ ``not x != y``"

#: ../../reference/expressions.rst:1230
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr "``x < y`` ã¨ ``not x >= y`` (å…¨é †åºã®å ´åˆ)"

#: ../../reference/expressions.rst:1232
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr "``x > y`` ã¨ ``not x <= y`` (å…¨é †åºã®å ´åˆ)"

#: ../../reference/expressions.rst:1234
msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the "
":func:`~functools.total_ordering` decorator."
msgstr "æœ€å¾Œã®2å¼ã¯å…¨é †åºã®é›†ã¾ã‚Šã«é©ç”¨ã•ã‚Œã¾ã™ (ãŸã¨ãˆã°ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ã¯é©ç”¨ã•ã‚Œã¾ã™ãŒã‚»ãƒƒãƒˆã‚„ãƒãƒƒãƒ”ãƒ³ã‚°ã«ã¯é©ç”¨ã•ã‚Œã¾ã›ã‚“)ã€‚\n:func:`~functools.total_ordering` ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:1238
msgid ""
"The :func:`hash` result should be consistent with equality. Objects that are"
" equal should either have the same hash value, or be marked as unhashable."
msgstr ":func:`hash` ã®çµæœã¯ç­‰ä¾¡æ€§ã¨ä¸€è²«ã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\nç­‰ä¾¡ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã©ã†ã—ã¯åŒã˜ãƒãƒƒã‚·ãƒ¥å€¤ã‚’æŒã¤ã‹ã€ãƒãƒƒã‚·ãƒ¥å€¤ãŒè¨ˆç®—ã§ããªã„ã‚‚ã®ã¨ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:1242
msgid "Python does not enforce these consistency rules."
msgstr "Python ã¯ã“ã‚Œã‚‰ã®ä¸€è²«æ€§ã®è¦å‰‡ã‚’å¼·åˆ¶ã—ã¾ã›ã‚“ã€‚"

#: ../../reference/expressions.rst:1250
msgid "Membership test operations"
msgstr "å¸°å±æ¤œæŸ»æ¼”ç®—"

#: ../../reference/expressions.rst:1252
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False`` "
"otherwise. ``x not in s`` returns the negation of ``x in s``.  All built-in "
"sequences and set types support this as well as dictionary, for which "
":keyword:`in` tests whether the dictionary has a given key. For container "
"types such as list, tuple, set, frozenset, dict, or collections.deque, the "
"expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr "æ¼”ç®—å­ :keyword:`in` ãŠã‚ˆã³ :keyword:`not in` ã¯æ‰€å±é–¢ä¿‚ã‚’èª¿ã¹ã¾ã™ã€‚ ``x in s`` ã®è©•ä¾¡ã¯ã€ *x* ãŒ *s* ã®è¦ç´ ã§ã‚ã‚Œã° ``True`` ã¨ãªã‚Šã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã¨ãªã‚Šã¾ã™ã€‚ ``x not in s`` ã¯ ``x in s`` ã®å¦å®šã‚’è¿”ã—ã¾ã™ã€‚ã™ã¹ã¦ã®çµ„ã¿è¾¼ã¿ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨é›†åˆå‹ã«åŠ ãˆã¦ã€è¾æ›¸ã‚‚ã€ :keyword:`in` ã‚’è¾æ›¸ãŒä¸ãˆã‚‰ã‚ŒãŸã‚­ãƒ¼ã‚’æŒã£ã¦ã„ã‚‹ã‹ã‚’èª¿ã¹ã‚‹ã‚‚ã®ã¨ã—ã¦ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ãƒªã‚¹ãƒˆã€ã‚¿ãƒ—ãƒ«ã€é›†åˆã€å‡çµé›†åˆã€è¾æ›¸ã€ã‚ã‚‹ã„ã¯ collections.deque ã®ã‚ˆã†ãªã‚³ãƒ³ãƒ†ãƒŠå‹ã«ã¤ã„ã¦ã€å¼ ``x in y`` ã¯ ``any(x is e or x == e for e in y)`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../reference/expressions.rst:1260
msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x* is"
" a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty "
"strings are always considered to be a substring of any other string, so "
"``\"\" in \"abc\"`` will return ``True``."
msgstr "æ–‡å­—åˆ—ã‚„ãƒã‚¤ãƒˆåˆ—å‹ã«ã¤ã„ã¦ã¯ã€ ``x in y`` ã¯ *x* ãŒ *y* ã®éƒ¨åˆ†æ–‡å­—åˆ—ã§ã‚ã‚‹ã¨ãã€ã‹ã¤ãã®ã¨ãã«é™ã‚Š ``True`` ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ ``y.find(x) != -1`` ã¨ç­‰ä¾¡ã§ã™ã€‚ç©ºæ–‡å­—åˆ—ã¯ã€ä»–ã®ä»»æ„ã®æ–‡å­—åˆ—ã®éƒ¨åˆ†æ–‡å­—åˆ—ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚å¾“ã£ã¦ ``\"\" in \"abc\"`` ã¯ ``True`` ã‚’è¿”ã™ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:1265
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, ``x "
"in y`` returns ``True`` if ``y.__contains__(x)`` returns a true value, and "
"``False`` otherwise."
msgstr ":meth:`__contains__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ãŸãƒ¦ãƒ¼ã‚¶å®šç¾©ã‚¯ãƒ©ã‚¹ã§ã¯ã€ ``y.__contains__(x)`` ã®è¿”ã‚Šå€¤ãŒçœŸã¨ãªã‚‹å ´åˆã« ``x in y`` ã®è¿”ã‚Šå€¤ã¯ ``True`` ã¨ãªã‚Šã€ãã†ã§ãªã„å ´åˆã¯ ``False`` ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:1269
msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is ``True`` if some value ``z`` with ``x"
" == z`` is produced while iterating over ``y``.  If an exception is raised "
"during the iteration, it is as if :keyword:`in` raised that exception."
msgstr ":meth:`__contains__` ã‚’å®šç¾©ã—ã¦ã„ãªã„ãŒ :meth:`__iter__` ã¯å®šç¾©ã—ã¦ã„ã‚‹ãƒ¦ãƒ¼ã‚¶å®šç¾©ã‚¯ãƒ©ã‚¹ã§ã¯ã€ ``x == z`` ã¨ãªã‚‹ã‚ˆã†ãªã‚ã‚‹å€¤ ``z`` ãŒ ``y`` å†…ã«ã‚ãŸã‚‹åå¾©ã§ç”Ÿæˆã•ã‚ŒãŸå ´åˆã€ ``x in y`` ã¯ ``True`` ã¨ãªã‚Šã¾ã™ã€‚\nåå¾©å‡¦ç†ã®é€”ä¸­ã§ä¾‹å¤–ãŒé€å‡ºã•ã‚ŒãŸå ´åˆã€ :keyword:`in` ãŒä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ãŸã‚ˆã†ã«æŒ¯ã‚‹èˆã„ã¾ã™ã€‚"

#: ../../reference/expressions.rst:1274
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines "
":meth:`__getitem__`, ``x in y`` is ``True`` if and only if there is a non-"
"negative integer index *i* such that ``x == y[i]``, and all lower integer "
"indices do not raise :exc:`IndexError` exception. (If any other exception is"
" raised, it is as if :keyword:`in` raised that exception)."
msgstr "æœ€çµ‚çš„ã«ã¯ã€æ—§å¼ã®åå¾©ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®å®Ÿè¡Œã‚’è©¦ã¿ã¾ã™ã€ã‚‚ã— :meth:`__getitem__` ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã‚ˆã†ãªãƒ¦ãƒ¼ã‚¶å®šç¾©ã‚¯ãƒ©ã‚¹ã§ã¯ã€ ``x in y`` ã¯ ``x == y[i]`` ã¨ãªã‚‹ã‚ˆã†ãªéè² ã®æ•´æ•°ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ *i* ãŒå­˜åœ¨ã™ã‚‹ã¨ãã€ã‹ã¤ãã®ã¨ãã«ã‹ãã‚Š ``True`` ã¨ãªã‚Šã¾ã™ã€‚ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ *i* ãŒè² ã§ã‚ã‚‹å ´åˆã« :exc:`IndexError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ (åˆ¥ã®ä½•ã‚‰ã‹ã®ä¾‹å¤–ãŒé€å‡ºã•ã‚ŒãŸå ´åˆã€ä¾‹å¤–ã¯ :keyword:`in` ã‹ã‚‰é€å‡ºã•ã‚ŒãŸã‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™)ã€‚"

#: ../../reference/expressions.rst:1286
msgid ""
"The operator :keyword:`not in` is defined to have the inverse true value of "
":keyword:`in`."
msgstr "æ¼”ç®—å­ :keyword:`not in` ã¯ :keyword:`in` ã®çœŸå€¤ã‚’åè»¢ã—ãŸå€¤ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../reference/expressions.rst:1299
msgid "Identity comparisons"
msgstr "åŒä¸€æ€§ã®æ¯”è¼ƒ"

#: ../../reference/expressions.rst:1301
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for object identity: "
"``x is y`` is true if and only if *x* and *y* are the same object.  ``x is "
"not y`` yields the inverse truth value. [#]_"
msgstr "æ¼”ç®—å­ :keyword:`is` ãŠã‚ˆã³ :keyword:`is not` ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã«å¯¾ã™ã‚‹ãƒ†ã‚¹ãƒˆã‚’è¡Œã„ã¾ã™: ``x is y`` ã¯ã€ *x* ã¨ *y* ãŒåŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã™ã¨ãã€ã‹ã¤ãã®ã¨ãã«é™ã‚ŠçœŸã«ãªã‚Šã¾ã™ã€‚ ``x is not y`` ã¯ :keyword:`is` ã®çœŸå€¤ã‚’åè»¢ã—ãŸã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚ [#]_"

#: ../../reference/expressions.rst:1312
msgid "Boolean operations"
msgstr "ãƒ–ãƒ¼ãƒ«æ¼”ç®— (boolean operation)"

#: ../../reference/expressions.rst:1323
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  (See the "
":meth:`~object.__nonzero__` special method for a way to change this.)"
msgstr "ãƒ–ãƒ¼ãƒ«æ¼”ç®—ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚„ã€å¼ãŒåˆ¶å¾¡ãƒ•ãƒ­ãƒ¼æ–‡ä¸­ã§ä½¿ã‚ã‚Œã‚‹æœ€ã«ã¯ã€ä»¥ä¸‹ã®å€¤: ``False`` ã€ ``None`` ã€ã™ã¹ã¦ã®å‹ã«ãŠã‘ã‚‹æ•°å€¤ã®ã‚¼ãƒ­ã€ç©ºã®æ–‡å­—åˆ—ã¨ã‚³ãƒ³ãƒ†ãƒŠ (æ–‡å­—åˆ—ã€ã‚¿ãƒ—ãƒ«ã€ãƒªã‚¹ãƒˆã€è¾æ›¸ã€setã€frozenset ã‚’å«ã‚€) ã¯å½ (false) ã§ã‚ã‚‹ã¨è§£é‡ˆã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å€¤ã¯çœŸ (true) ã§ã‚ã‚‹ã¨è§£é‡ˆã•ã‚Œã¾ã™ã€‚ (ã“ã®æŒ¯ã‚‹èˆã„ã‚’å¤‰æ›´ã™ã‚‹æ–¹æ³•ã«ã¤ã„ã¦ã¯ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ :meth:`~object.__nonzero__` ã‚’å‚ç…§ã—ã¦ãã ã•ã„)"

#: ../../reference/expressions.rst:1332
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr "æ¼”ç®—å­ :keyword:`not` ã¯ã€å¼•æ•°ãŒå½ã§ã‚ã‚‹å ´åˆã«ã¯ ``True`` ã‚’ã€ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ ``False`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:1337
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is "
"returned."
msgstr "å¼ ``x and y`` ã¯ã€ã¾ãš *x* ã‚’è©•ä¾¡ã—ã¾ã™; *x* ãŒå½ãªã‚‰ *x* ã®å€¤ã‚’è¿”ã—ã¾ã™; ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€ *y* ã®å€¤ã‚’è©•ä¾¡ã—ã€ãã®çµæœã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:1342
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr "å¼ ``x or y`` ã¯ã€ã¾ãš *x* ã‚’è©•ä¾¡ã—ã¾ã™; *x* ãŒçœŸãªã‚‰ *x* ã®å€¤ã‚’è¿”ã—ã¾ã™; ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€ *y* ã®å€¤ã‚’è©•ä¾¡ã—ã€ãã®çµæœã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:1345
msgid ""
"(Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument. This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"invent a value anyway, it does not bother to return a value of the same type"
" as its argument, so e.g., ``not 'foo'`` yields ``False``, not ``''``.)"
msgstr "(:keyword:`and` ã‚‚ :keyword:`not` ã‚‚ã€è¿”ã™å€¤ã‚’ ``False`` ã‚„ ``True`` ã«åˆ¶é™ã™ã‚‹ã®ã§ã¯ãªãã€æœ€å¾Œã«è©•ä¾¡ã—ãŸå¼•æ•°ã®å€¤ã‚’è¿”ã™ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã®ä»•æ§˜ã¯ã€ä¾‹ãˆã° ``s`` ã‚’æ–‡å­—åˆ—ã¨ã—ã¦ ``s`` ãŒç©ºæ–‡å­—åˆ—ã®å ´åˆã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å€¤ã«ç½®ãæ›ãˆã‚‹ã‚ˆã†ãªå ´åˆã«ã€ ``s or 'foo'`` ã¨æ›¸ãã¨æœŸå¾…é€šã‚Šã®å€¤ã«ãªã‚‹ãŸã‚ã«ä¾¿åˆ©ãªã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ :keyword:`not` ã¯ã€å¼ã®å€¤ã§ãªãç‹¬è‡ªã«å€¤ã‚’ä½œæˆã—ã¦è¿”ã™ã®ã§ã€å¼•æ•°ã¨åŒã˜å‹ã®å€¤ã‚’è¿”ã™ã‚ˆã†ãªå‡¦ç†ã«ç…©ã‚ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ ``not 'foo'`` ã¯ã€ ``''`` ã§ã¯ãªã ``False`` ã«ãªã‚Šã¾ã™)"

#: ../../reference/expressions.rst:1355
msgid "Conditional Expressions"
msgstr "æ¡ä»¶æ¼”ç®— (Conditional Expressions)"

#: ../../reference/expressions.rst:1367
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr "æ¡ä»¶æ¼”ç®—å¼ (ã—ã°ã—ã°ã€\"ä¸‰é …æ¼”ç®—å­\" ã¨å‘¼ã°ã‚Œã¾ã™) ã¯æœ€ã‚‚å„ªå…ˆåº¦ãŒä½ã„Python ã®æ“ä½œã§ã™ã€‚"

#: ../../reference/expressions.rst:1370
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* (*not* "
"*x*); if *C* is true, *x* is evaluated and its value is returned; otherwise,"
" *y* is evaluated and its value is returned."
msgstr "``x if C else y`` ã¨ã„ã†å¼ã¯æœ€åˆã«æ¡ä»¶ *C* (*x* ã§ã¯ *ã‚ã‚Šã¾ã›ã‚“*) ã‚’è©•ä¾¡ã—ã¾ã™; *C* ãŒ true ã®å ´åˆ *x* ãŒè©•ä¾¡ã•ã‚Œå€¤ãŒè¿”ã•ã‚Œã¾ã™; ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ *y* ãŒè©•ä¾¡ã•ã‚Œè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:1374
msgid "See :pep:`308` for more details about conditional expressions."
msgstr "æ¡ä»¶æ¼”ç®—ã«é–¢ã—ã¦ã‚ˆã‚Šè©³ã—ãã¯ :pep:`308` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:1381
msgid "Lambdas"
msgstr "ãƒ©ãƒ ãƒ€ (lambda)"

#: ../../reference/expressions.rst:1391
msgid ""
"Lambda expressions (sometimes called lambda forms) have the same syntactic "
"position as expressions.  They are a shorthand to create anonymous "
"functions; the expression ``lambda parameters: expression`` yields a "
"function object.  The unnamed object behaves like a function object defined "
"with ::"
msgstr ""

#: ../../reference/expressions.rst:1399
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements."
msgstr "ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ§‹æ–‡ã®ä¸€è¦§ã¯ :ref:`é–¢æ•°å®šç¾© <function>` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ãƒ©ãƒ ãƒ€å¼ã§ä½œæˆã•ã‚ŒãŸé–¢æ•°ã¯å‘½ä»¤æ–‡ã‚’å«ã‚€ã“ã¨ãŒã§ããªã„ç‚¹ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:1406
msgid "Expression lists"
msgstr "å¼ã®ãƒªã‚¹ãƒˆ"

#: ../../reference/expressions.rst:1415
msgid ""
"An expression list containing at least one comma yields a tuple.  The length"
" of the tuple is the number of expressions in the list.  The expressions are"
" evaluated from left to right."
msgstr "å°‘ãªãã¨ã‚‚ä¸€ã¤ã®ã‚«ãƒ³ãƒã‚’å«ã‚€å¼ã®ãƒªã‚¹ãƒˆã¯ã€ã‚¿ãƒ—ãƒ«ã«ãªã‚Šã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã®é•·ã•ã¯ã€ãƒªã‚¹ãƒˆä¸­ã®å¼ã®æ•°ã«ç­‰ã—ããªã‚Šã¾ã™ã€‚ãƒªã‚¹ãƒˆä¸­ã®å¼ã¯å·¦ã‹ã‚‰å³ã¸ã¨é †ã«è©•ä¾¡ã•ã‚Œã¾ã™ã€‚"

#: ../../reference/expressions.rst:1421
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the value"
" of that expression. (To create an empty tuple, use an empty pair of "
"parentheses: ``()``.)"
msgstr "å˜ä¸€è¦ç´ ã®ã‚¿ãƒ—ãƒ« (åˆ¥å *å˜é›†åˆ (singleton)* ) ã‚’ä½œã‚ŠãŸã‘ã‚Œã°ã€æœ«å°¾ã«ã‚«ãƒ³ãƒãŒå¿…è¦ã§ã™ã€‚å˜ä¸€ã®å¼ã ã‘ã§ã€æœ«å°¾ã«ã‚«ãƒ³ãƒã‚’ã¤ã‘ãªã„å ´åˆã«ã¯ã€ã‚¿ãƒ—ãƒ«ã§ã¯ãªããã®å¼ã®å€¤ã«ãªã‚Šã¾ã™ (ç©ºã®ã‚¿ãƒ—ãƒ«ã‚’ä½œã‚ŠãŸã„ãªã‚‰ã€ä¸­èº«ãŒç©ºã®ä¸¸æ‹¬å¼§ãƒšã‚¢: ``()`` ã‚’ä½¿ã„ã¾ã™ã€‚)"

#: ../../reference/expressions.rst:1431
msgid "Evaluation order"
msgstr "è©•ä¾¡é †åº"

#: ../../reference/expressions.rst:1435
msgid ""
"Python evaluates expressions from left to right. Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr "Python ã¯ã€å¼ã‚’å·¦ã‹ã‚‰å³ã¸ã¨é †ã«è©•ä¾¡ã—ã¦ã‚†ãã¾ã™ã€‚ãŸã ã—ã€ä»£å…¥å¼ã‚’è©•ä¾¡ã™ã‚‹æœ€ã«ã¯ã€ä»£å…¥æ¼”ç®—å­ã®å³å´é …ãŒå·¦å´é …ã‚ˆã‚Šã‚‚å…ˆã«è©•ä¾¡ã•ã‚Œã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:1438
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr "ä»¥ä¸‹ã«ç¤ºã™å®Ÿè¡Œæ–‡ã®å„è¡Œã§ã®è©•ä¾¡é †åºã¯ã€æ·»ãˆå­—ã®æ•°å­—é †åºã¨åŒã˜ã«ãªã‚Šã¾ã™::"

#: ../../reference/expressions.rst:1452
msgid "Operator precedence"
msgstr "æ¼”ç®—å­ã®å„ªå…ˆé †ä½"

#: ../../reference/expressions.rst:1456
msgid ""
"The following table summarizes the operator precedences in Python, from "
"lowest precedence (least binding) to highest precedence (most binding). "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for comparisons, including tests, which all have the "
"same precedence and chain from left to right --- see section "
":ref:`comparisons` --- and exponentiation, which groups from right to left)."
msgstr "ä»¥ä¸‹ã®è¡¨ã¯ã€Python ã«ãŠã‘ã‚‹æ¼”ç®—å­ã‚’ã€å„ªå…ˆé †ä½ã®æœ€ã‚‚ä½ã„ (çµåˆåº¦ãŒæœ€ã‚‚ä½ã„) ã‚‚ã®ã‹ã‚‰æœ€ã‚‚é«˜ã„ (çµåˆåº¦ãŒæœ€ã‚‚é«˜ã„) ã‚‚ã®ã®é †ã«ä¸¦ã¹ãŸã‚‚ã®ã§ã™ã€‚åŒã˜ãƒœãƒƒã‚¯ã‚¹å†…ã«ç¤ºã•ã‚ŒãŸæ¼”ç®—å­ã¯åŒã˜å„ªå…ˆé †ä½ã‚’æŒã¡ã¾ã™ã€‚æ¼”ç®—å­ã®æ–‡æ³•ãŒç¤ºã•ã‚Œã¦ã„ãªã„ã‹ãã‚Šã€æ¼”ç®—å­ã¯å…¨ã¦äºŒé …æ¼”ç®—å­ã§ã™ã€‚åŒã˜ãƒœãƒƒã‚¯ã‚¹å†…ã®æ¼”ç®—å­ã¯ã€å·¦ã‹ã‚‰å³ã¸ã¨ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã•ã‚Œã¾ã™ (å€¤ã®ãƒ†ã‚¹ãƒˆã‚’å«ã‚€æ¯”è¼ƒæ¼”ç®—å­ã‚’é™¤ãã¾ã™ã€‚æ¯”è¼ƒæ¼”ç®—å­ã¯ã€å·¦ã‹ã‚‰å³ã«é€£é–ã—ã¾ã™ --- :ref:`comparisons` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ã¾ãŸã€ã¹ãä¹—æ¼”ç®—å­ã‚‚é™¤ãã¾ã™ã€‚ã¹ãä¹—æ¼”ç®—å­ã¯å³ã‹ã‚‰å·¦ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã•ã‚Œã¾ã™)ã€‚"

#: ../../reference/expressions.rst:1465
msgid "Operator"
msgstr "æ¼”ç®—å­"

#: ../../reference/expressions.rst:1465
msgid "Description"
msgstr "èª¬æ˜"

#: ../../reference/expressions.rst:1467
msgid ":keyword:`lambda`"
msgstr ":keyword:`lambda`"

#: ../../reference/expressions.rst:1467
msgid "Lambda expression"
msgstr "ãƒ©ãƒ ãƒ€å¼"

#: ../../reference/expressions.rst:1469
msgid ":keyword:`if` -- :keyword:`else`"
msgstr ":keyword:`if` -- :keyword:`else`"

#: ../../reference/expressions.rst:1469
msgid "Conditional expression"
msgstr "æ¡ä»¶æ¼”ç®—"

#: ../../reference/expressions.rst:1471
msgid ":keyword:`or`"
msgstr ":keyword:`or`"

#: ../../reference/expressions.rst:1471
msgid "Boolean OR"
msgstr "ãƒ–ãƒ¼ãƒ«æ¼”ç®— OR"

#: ../../reference/expressions.rst:1473
msgid ":keyword:`and`"
msgstr ":keyword:`and`"

#: ../../reference/expressions.rst:1473
msgid "Boolean AND"
msgstr "ãƒ–ãƒ¼ãƒ«æ¼”ç®— AND"

#: ../../reference/expressions.rst:1475
msgid ":keyword:`not` ``x``"
msgstr ":keyword:`not` ``x``"

#: ../../reference/expressions.rst:1475
msgid "Boolean NOT"
msgstr "ãƒ–ãƒ¼ãƒ«æ¼”ç®— NOT"

#: ../../reference/expressions.rst:1477
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``<>``, ``!=``, ``==``"
msgstr ":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, ``<=``, ``>``, ``>=``, ``<>``, ``!=``, ``==``"

#: ../../reference/expressions.rst:1477
msgid "Comparisons, including membership tests and identity tests"
msgstr "å¸°å±ã‚„åŒä¸€æ€§ã®ãƒ†ã‚¹ãƒˆã‚’å«ã‚€æ¯”è¼ƒ"

#: ../../reference/expressions.rst:1481
msgid "``|``"
msgstr "``|``"

#: ../../reference/expressions.rst:1481
msgid "Bitwise OR"
msgstr "ãƒ“ãƒƒãƒˆå˜ä½ OR"

#: ../../reference/expressions.rst:1483
msgid "``^``"
msgstr "``^``"

#: ../../reference/expressions.rst:1483
msgid "Bitwise XOR"
msgstr "ãƒ“ãƒƒãƒˆå˜ä½ XOR"

#: ../../reference/expressions.rst:1485
msgid "``&``"
msgstr "``&``"

#: ../../reference/expressions.rst:1485
msgid "Bitwise AND"
msgstr "ãƒ“ãƒƒãƒˆå˜ä½ AND"

#: ../../reference/expressions.rst:1487
msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

#: ../../reference/expressions.rst:1487
msgid "Shifts"
msgstr "ã‚·ãƒ•ãƒˆæ¼”ç®—"

#: ../../reference/expressions.rst:1489
msgid "``+``, ``-``"
msgstr "``+``, ``-``"

#: ../../reference/expressions.rst:1489
msgid "Addition and subtraction"
msgstr "åŠ ç®—ãŠã‚ˆã³æ¸›ç®—"

#: ../../reference/expressions.rst:1491
msgid "``*``, ``/``, ``//``, ``%``"
msgstr "``*``, ``/``, ``//``, ``%``"

#: ../../reference/expressions.rst:1491
msgid "Multiplication, division, remainder [#]_"
msgstr "ä¹—ç®—ã€é™¤ç®—ã€å‰°ä½™ [#]_"

#: ../../reference/expressions.rst:1494
msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

#: ../../reference/expressions.rst:1494
msgid "Positive, negative, bitwise NOT"
msgstr "æ­£ç¬¦å·ã€è² ç¬¦å·ã€ãƒ“ãƒƒãƒˆå˜ä½ NOT"

#: ../../reference/expressions.rst:1496
msgid "``**``"
msgstr "``**``"

#: ../../reference/expressions.rst:1496
msgid "Exponentiation [#]_"
msgstr "ã¹ãä¹— [#]_"

#: ../../reference/expressions.rst:1498
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"

#: ../../reference/expressions.rst:1498
msgid "Subscription, slicing, call, attribute reference"
msgstr "æ·»å­—æŒ‡å®šã€ã‚¹ãƒ©ã‚¤ã‚¹æ“ä½œå±æ€§å‚ç…§"

#: ../../reference/expressions.rst:1501
msgid ""
"``(expressions...)``, ``[expressions...]``, ``{key: value...}``, "
"```expressions...```"
msgstr "``(expressions...)``, ``[expressions...]``, ``{key: value...}``, ```expressions...```"

#: ../../reference/expressions.rst:1501
msgid ""
"Binding or tuple display, list display, dictionary display, string "
"conversion"
msgstr "å¼çµåˆã¾ãŸã¯ã‚¿ãƒ—ãƒ«è¡¨ç¾ã€ãƒªã‚¹ãƒˆè¡¨ç¾ã€è¾æ›¸è¡¨ç¾ã€æ–‡å­—åˆ—ã¸ã®å‹å¤‰æ›"

#: ../../reference/expressions.rst:1508
msgid "Footnotes"
msgstr "æ³¨è¨˜"

#: ../../reference/expressions.rst:1509
msgid ""
"In Python 2.3 and later releases, a list comprehension \"leaks\" the control"
" variables of each ``for`` it contains into the containing scope.  However, "
"this behavior is deprecated, and relying on it will not work in Python 3."
msgstr "Python 2.3 ä»¥é™ã®ãƒªã‚¹ãƒˆå†…åŒ…ã¯ ``for`` ã®ä¸­ã§ä½¿ã†åˆ¶å¾¡å¤‰æ•°ã‚’å†…åŒ…è¡¨è¨˜å†…ã®ã‚¹ã‚³ãƒ¼ãƒ—ã«ã€Œãƒªãƒ¼ã‚¯ã€ã—ã¾ã™ã€‚ã—ã‹ã—ã€ã“ã®æŒ™å‹•ã¯å»ƒæ­¢äºˆå®šã§ã™ã€‚Python 3 ã§ã¯ã“ã®æŒ™å‹•ã«ä¾å­˜ã—ãŸã‚³ãƒ¼ãƒ‰ã¯å‹•ä½œã—ãªããªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:1513
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be"
" true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr "``abs(x%y) < abs(y)`` ã¯æ•°å­¦çš„ã«ã¯çœŸã¨ãªã‚Šã¾ã™ãŒã€æµ®å‹•å°æ•°ç‚¹ã«å¯¾ã™ã‚‹æ¼”ç®—ã®å ´åˆã«ã¯ã€å€¤ä¸¸ã‚ (roundoff) ã®ãŸã‚ã«æ•°å€¤è¨ˆç®—çš„ã«çœŸã«ãªã‚‰ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€Python ã®æµ®å‹•å°æ•°ç‚¹å‹ãŒ IEEE754 å€ç²¾åº¦æ•°å‹ã«ãªã£ã¦ã„ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚’ä»®å®šã™ã‚‹ã¨ã€ ``-1e-100 % 1e100`` ã¯ ``1e100`` ã¨åŒã˜ç¬¦å·ã«ãªã‚‹ã¯ãšãªã®ã«ã€è¨ˆç®—çµæœã¯ ``-1e-100 + 1e100`` ã¨ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯æ•°å€¤è¨ˆç®—çš„ã«ã¯å³å¯†ã« ``1e100`` ã¨ç­‰ä¾¡ã§ã™ã€‚é–¢æ•° :func:`math.fmod` ã¯ã€æœ€åˆã®å¼•æ•°ã¨ç¬¦å·ãŒä¸€è‡´ã™ã‚‹ã‚ˆã†ãªå€¤ã‚’è¿”ã™ã®ã§ã€ä¸Šè¨˜ã®å ´åˆã«ã¯ ``-1e-100`` ã‚’è¿”ã—ã¾ã™ã€‚ã©ã¡ã‚‰ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒãŒé©åˆ‡ã‹ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:1522
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for "
"``floor(x/y)`` to be one larger than ``(x-x%y)/y`` due to rounding.  In such"
" cases, Python returns the latter result, in order to preserve that "
"``divmod(x,y)[0] * y + x % y`` be very close to ``x``."
msgstr "x ãŒ y ã®æ•´æ•°å€ã«éå¸¸ã«è¿‘ã„å ´åˆã€ä¸¸ã‚èª¤å·®ã«ã‚ˆã£ã¦ ``floor(x/y)`` ã¯ ``(x-x%y)/y`` ã‚ˆã‚Šã‚‚å¤§ããªå€¤ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ãã®ã‚ˆã†ãªå ´åˆã€ Python ã¯ ``divmod(x,y)[0] * y + x % y`` ãŒ ``x`` ã«éå¸¸ã«è¿‘ããªã‚‹ã¨ã„ã†é–¢ä¿‚ã‚’ä¿ã¤ãŸã‚ã«ã€å¾Œè€…ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../reference/expressions.rst:1527
msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) "
"and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most"
" abstract characters in Unicode are only represented using one code point, "
"there is a number of abstract characters that can in addition be represented"
" using a sequence of more than one code point.  For example, the abstract "
"character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a "
"single :dfn:`precomposed character` at code position U+00C7, or as a "
"sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL "
"LETTER C), followed by a :dfn:`combining character` at code position U+0327 "
"(COMBINING CEDILLA)."
msgstr "Unicode æ¨™æº–ã§ã¯ã€ :dfn:`ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ (code point)` (ä¾‹ãˆã°ã€U+0041) ã¨ :dfn:`æŠ½è±¡æ–‡å­— (abstract character)` (ä¾‹ãˆã°ã€\"LATIN CAPITAL LETTER A\") ã‚’åŒºåˆ¥ã—ã¾ã™ã€‚\nUnicode ã®ã»ã¨ã‚“ã©ã®æŠ½è±¡æ–‡å­—ã¯ 1 ã¤ã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã ã‘ã‚’ä½¿ã£ã¦è¡¨ç¾ã•ã‚Œã¾ã™ãŒã€è¤‡æ•°ã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®åˆ—ã‚’ä½¿ã£ã¦ã‚‚è¡¨ç¾ã§ãã‚‹æŠ½è±¡æ–‡å­—ã‚‚ãŸãã•ã‚“ã‚ã‚Šã¾ã™ã€‚\nä¾‹ãˆã°ã€æŠ½è±¡æ–‡å­— \"LATIN CAPITAL LETTER C WITH CEDILLA\" ã¯ã‚³ãƒ¼ãƒ‰ä½ç½® U+00C7 ã«ã‚ã‚‹ :dfn:`åˆæˆæ¸ˆã¿æ–‡å­— (precomposed character)` 1 ã¤ã ã‘ã§ã‚‚è¡¨ç¾ã§ãã¾ã™ã—ã€ã‚³ãƒ¼ãƒ‰ä½ç½® U+0043 (LATIN CAPITAL LETTER C) ã«ã‚ã‚‹ :dfn:`åŸºåº•æ–‡å­— (base character)` ã®å¾Œã‚ã«ã€ã‚³ãƒ¼ãƒ‰ä½ç½® U+0327 (COMBINING CEDILLA) ã«ã‚ã‚‹ :dfn:`çµåˆæ–‡å­— (combining character)` ãŒç¶šãåˆ—ã¨ã—ã¦ã‚‚è¡¨ç¾ã§ãã¾ã™ã€‚"

#: ../../reference/expressions.rst:1538
msgid ""
"The comparison operators on unicode strings compare at the level of Unicode "
"code points. This may be counter-intuitive to humans.  For example, "
"``u\"\\u00C7\" == u\"\\u0043\\u0327\"`` is ``False``, even though both "
"strings represent the same abstract character \"LATIN CAPITAL LETTER C WITH "
"CEDILLA\"."
msgstr "Unicode æ–‡å­—åˆ—ã®æ¯”è¼ƒæ“ä½œã¯ Unicode ã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ãƒ¬ãƒ™ãƒ«ã§è¡Œã‚ã‚Œã¾ã™ã€‚\nã“ã‚Œã¯äººé–“ã«ã¨ã£ã¦ã¯ç›´æ„Ÿçš„ã§ã¯ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚\nä¾‹ãˆã°ã€ ``u\"\\u00C7\" == u\"\\u0043\\u0327\"`` ã¯ã€ã©ã¡ã‚‰ã®æ–‡å­—ã‚‚åŒã˜æŠ½è±¡æ–‡å­— \"LATIN CAPITAL LETTER C WITH CEDILLA\" ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€ãã®çµæœã¯ ``False`` ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:1543
msgid ""
"To compare strings at the level of abstract characters (that is, in a way "
"intuitive to humans), use :func:`unicodedata.normalize`."
msgstr "æŠ½è±¡æ–‡å­—ã®ãƒ¬ãƒ™ãƒ«ã§ (ã¤ã¾ã‚Šã€äººé–“ã«ã¨ã£ã¦ç›´æ„Ÿçš„ãªæ–¹æ³•ã§) æ–‡å­—åˆ—ã‚’æ¯”è¼ƒã™ã‚‹ã«ã¯ :func:`unicodedata.normalize` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:1546
msgid ""
"Earlier versions of Python used lexicographic comparison of the sorted (key,"
" value) lists, but this was very expensive for the common case of comparing "
"for equality.  An even earlier version of Python compared dictionaries by "
"identity only, but this caused surprises because people expected to be able "
"to test a dictionary for emptiness by comparing it to ``{}``."
msgstr "Python ã®åˆæœŸã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸ (key, value) ã®ãƒªã‚¹ãƒˆã«å¯¾ã—ã¦è¾æ›¸çš„ãªæ¯”è¼ƒã‚’è¡Œã£ã¦ã„ã¾ã—ãŸãŒã€ã“ã‚Œã¯ç­‰ä¾¡æ€§ã®è¨ˆç®—ã®ã‚ˆã†ãªã‚ˆãã‚ã‚‹æ“ä½œã‚’å®Ÿç¾ã™ã‚‹ã«ã¯éå¸¸ã«ã‚³ã‚¹ãƒˆã®é«˜ã„æ“ä½œã§ã—ãŸã€‚ã‚‚ã£ã¨ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã§ã¯ã€è¾æ›¸ã¯ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã ã‘ã§æ¯”è¼ƒã•ã‚Œã¦ã„ã¾ã—ãŸã€‚ã—ã‹ã—ã“ã®ä»•æ§˜ã¯ã€ ``{}`` ã¨ã®æ¯”è¼ƒã«ã‚ˆã£ã¦è¾æ›¸ãŒç©ºã§ã‚ã‚‹ã‹ç¢ºã‹ã‚ã‚‰ã‚Œã‚‹ã¨æœŸå¾…ã—ã¦ã„ãŸäººã€…ã‚’æ··ä¹±ã•ã›ã¦ã„ã¾ã—ãŸã€‚"

#: ../../reference/expressions.rst:1552
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr "è‡ªå‹•çš„ãªã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã€ãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã€ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å‹•çš„ç‰¹æ€§ã®ãŸã‚ã«ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚„å®šæ•°ã®æ¯”è¼ƒã‚’è¡Œã†ã‚ˆã†ãªã¨ãã« :keyword:`is` æ¼”ç®—å­ã®åˆ©ç”¨ã¯ã€ä¸€è¦‹ã™ã‚‹ã¨æ™®é€šã§ã¯ãªã„æŒ¯ã‚‹èˆã„ã ã¨æ°—ä»˜ãã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚è©³ç´°ã¯ãã‚Œãã‚Œã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚"

#: ../../reference/expressions.rst:1557
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr "``%`` æ¼”ç®—å­ã¯æ–‡å­—åˆ—ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ã‚‚ä½¿ã‚ã‚Œã€åŒã˜å„ªå…ˆé †ä½ãŒå½“ã¦ã¯ã¾ã‚Šã¾ã™ã€‚"

#: ../../reference/expressions.rst:1560
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr "ã¹ãä¹—æ¼”ç®—å­ ``**`` ã¯ãã®å³å´ã«ã‚ã‚‹å˜é …æ¼”ç®—å­ã‹ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—å­ã‚ˆã‚Šã‚‚å„ªå…ˆã—ã¦æŸç¸›ã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Š ``2**-1`` ã¯ ``0.5`` ã«ãªã‚Šã¾ã™ã€‚"
