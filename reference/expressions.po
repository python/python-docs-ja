# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-23 13:22+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Naoki INADA <songofacandy@gmail.com>, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/expressions.rst:6
msgid "Expressions"
msgstr "式 (expression)"

#: ../../reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr "この章では、Python の式における個々の要素の意味について解説します。"

#: ../../reference/expressions.rst:12
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""
"**表記法に関する注意:** この章と以降の章での拡張BNF (extended BNF) "
"表記は、字句解析規則ではなく、構文規則を記述するために用いられています。ある構文規則 (のある表現方法) が、以下の形式"

#: ../../reference/expressions.rst:19
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""
"で記述されていて、この構文特有の意味付け (semantics) が記述されていない場合、 ``name`` の形式をとる構文の意味付けは "
"``othername`` の意味付けと同じになります。"

#: ../../reference/expressions.rst:26
msgid "Arithmetic conversions"
msgstr "算術変換 (arithmetic conversion)"

#: ../../reference/expressions.rst:30
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type,\" this means that the "
"operator implementation for built-in types works as follows:"
msgstr "以下の算術演算子の記述で、「数値引数は共通の型に変換されます」と書かれているとき、組み込み型に対する演算子の実装は以下の通りに動作します:"

#: ../../reference/expressions.rst:34
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr "片方の引数が複素数型であれば、他方は複素数型に変換されます;"

#: ../../reference/expressions.rst:36
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr "それ以外の場合で、片方の引数が浮動小数点数であれば、他方は浮動小数点型に変換されます;"

#: ../../reference/expressions.rst:39
msgid "otherwise, both must be integers and no conversion is necessary."
msgstr "それ以外場合は、両方の引数は整数でなければならず、変換の必要はありません。"

#: ../../reference/expressions.rst:41
msgid ""
"Some additional rules apply for certain operators (e.g., a string as a left "
"argument to the '%' operator).  Extensions must define their own conversion "
"behavior."
msgstr ""
"特定の演算子 ('%' 演算子の左引数としての文字列) "
"には、さらに別の規則が適用されます。拡張は、それ自身の型変換のふるまいを定義していなければなりません。"

#: ../../reference/expressions.rst:49
msgid "Atoms"
msgstr "アトム、原子的要素 (atom)"

#: ../../reference/expressions.rst:53
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in parentheses, brackets or braces "
"are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""
"atom は、式の一番基本的な要素です。もっとも単純な atom は、識別子またはリテラルです。丸括弧、角括弧、または波括弧で囲われた形式 (form)"
" もまた、構文上アトムに分類されます。atom の構文は以下のようになります:"

#: ../../reference/expressions.rst:66
msgid "Identifiers (Names)"
msgstr "識別子 (identifier、または名前 (name))"

#: ../../reference/expressions.rst:70
msgid ""
"An identifier occurring as an atom is a name.  See section "
":ref:`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""
"アトムの形になっている識別子 (identifier) は名前 (name) です。字句定義については :ref:`identifiers` "
"節を、名前付けや束縛については :ref:`naming` 節を参照してください。"

#: ../../reference/expressions.rst:76
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a "
":exc:`NameError` exception."
msgstr ""
"名前があるオブジェクトに束縛されている場合、名前 atom を評価するとそのオブジェクトになります。名前が束縛されていない場合、 atom "
"を評価しようとすると :exc:`NameError` 例外を送出します。"

#: ../../reference/expressions.rst:84
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name, with leading"
" underscores removed and a single underscore inserted, in front of the name."
"  For example, the identifier ``__spam`` occurring in a class named ``Ham`` "
"will be transformed to ``_Ham__spam``.  This transformation is independent "
"of the syntactical context in which the identifier is used.  If the "
"transformed name is extremely long (longer than 255 characters), "
"implementation defined truncation may happen. If the class name consists "
"only of underscores, no transformation is done."
msgstr ""
"**プライベートな名前のマングリング:** "
"クラス定義内に書かれた識別子で、2つ以上のアンダースコアから始まり、末尾が2つ以上のアンダースコアで終わっていないものは、そのクラスの "
":dfn:`プライベートな名前` "
"とみなされます。プライベートな名前は、コードが生成される前により長い形式に変換されます。この変換によって、クラス名の先頭にアンダースコアがあれば除去し、先頭にアンダースコアを1つ付加し、名前の前に挿入されます。例えば、クラス名"
" ``Ham`` の中の識別子 ``__spam`` は、``_Ham__spam`` "
"に変換されます。変換は識別子が使用されている構文のコンテキストからは独立しています。変換された名前が非常に長い (255文字を超える) "
"場合、実装によっては名前の切り詰めが行われるかもしれません。クラス名がアンダースコアのみから成る場合は変換は行われません。"

#: ../../reference/expressions.rst:100
msgid "Literals"
msgstr "リテラル"

#: ../../reference/expressions.rst:104
msgid ""
"Python supports string and bytes literals and various numeric literals:"
msgstr "Python では、文字列やバイト列リテラルと、様々な数値リテラルをサポートしています:"

#: ../../reference/expressions.rst:110
msgid ""
"Evaluation of a literal yields an object of the given type (string, bytes, "
"integer, floating point number, complex number) with the given value.  The "
"value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""
"リテラルの評価は、与えられた型 (文字列、バイト列、整数、浮動小数点数、複素数) の与えられた値を持つオブジェクトを与えます。浮動小数点や虚数 "
"(複素数) リテラルの場合、値は近似値になる場合があります。詳しくは :ref:`literals` を参照してください。"

#: ../../reference/expressions.rst:119
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals"
" with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""
"リテラルは全て変更不能なデータ型に対応します。このため、オブジェクトのアイデンティティはオブジェクトの値ほど重要ではありません。同じ値を持つ複数のリテラルを評価した場合、(それらのリテラルがプログラムの同じ場所由来のものであっても、そうでなくても)"
" 同じオブジェクトを指しているか、まったく同じ値を持つ別のオブジェクトになります。"

#: ../../reference/expressions.rst:129
msgid "Parenthesized forms"
msgstr "丸括弧形式 (parenthesized form)"

#: ../../reference/expressions.rst:133
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr "丸括弧形式とは、式リストの一形態で、丸括弧で囲ったものです:"

#: ../../reference/expressions.rst:138
msgid ""
"A parenthesized expression list yields whatever that expression list yields:"
" if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""
"丸括弧で囲われた式のリストは、個々の式が表現するものになります: リスト内に少なくとも一つのカンマが入っていた場合、タプルになります; "
"そうでない場合、式のリストを構成している単一の式自体の値になります。"

#: ../../reference/expressions.rst:144
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are"
" immutable, the rules for literals apply (i.e., two occurrences of the empty"
" tuple may or may not yield the same object)."
msgstr ""
"中身が空の丸括弧のペアは、空のタプルオブジェクトを表します。タプルは変更不能なので、リテラルと同じ規則が適用されます "
"(すなわち、空のタプルが二箇所で使われると、それらは同じオブジェクトになることもあるし、ならないこともあります)。"

#: ../../reference/expressions.rst:152
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the"
" comma operator.  The exception is the empty tuple, for which parentheses "
"*are* required --- allowing unparenthesized \"nothing\" in expressions would"
" cause ambiguities and allow common typos to pass uncaught."
msgstr ""
"タプルは丸括弧で作成されるのではなく、カンマによって作成されることに注意してください。例外は空のタプルで、この場合には丸括弧が *必要です* --- "
"丸括弧のつかない \"何も記述しない式 (nothing)\" "
"を使えるようにしてしまうと、文法があいまいなものになってしまい、よくあるタイプミスが検出されなくなってしまいます。"

#: ../../reference/expressions.rst:161
msgid "Displays for lists, sets and dictionaries"
msgstr "リスト、集合、辞書の表示"

#: ../../reference/expressions.rst:163
msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr ""
"Python は、リスト、集合、または辞書を構成するために、 \"表示 (display)\" "
"と呼ばれる特殊な構文を、それぞれ二種類づつ提供していて、コンテナの内容は:"

#: ../../reference/expressions.rst:166
msgid "either the container contents are listed explicitly, or"
msgstr "明示的に列挙される、または"

#: ../../reference/expressions.rst:168
msgid ""
"they are computed via a set of looping and filtering instructions, called a "
":dfn:`comprehension`."
msgstr ":dfn:`内包表記 (comprehension)` と呼ばれる、ループ処理とフィルター処理の命令の組み合わせを通じて計算されます。"

#: ../../reference/expressions.rst:171
msgid "Common syntax elements for comprehensions are:"
msgstr "内包表記の共通の構文要素はこの通りです:"

#: ../../reference/expressions.rst:179
msgid ""
"The comprehension consists of a single expression followed by at least one "
":keyword:`for` clause and zero or more :keyword:`for` or :keyword:`if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`for` or :keyword:`if`"
" clauses a block, nesting from left to right, and evaluating the expression "
"to produce an element each time the innermost block is reached."
msgstr ""
"内包表記はまず単一の式、続いて少なくとも 1 個の :keyword:`for` 節、さらに続いて 0 個以上の :keyword:`for` 節あるいは :keyword:`if` 節からなります。\n"
"この場合、各々の :keyword:`for` や :keyword:`if` 節を、左から右へ深くなっていくネストしたブロックとみなし、ネストの最内のブロックに到達するごとに内包表記の先頭にある式を評価した結果が、最終的にできあがるコンテナの各要素になります。"

#: ../../reference/expressions.rst:186
msgid ""
"Note that the comprehension is executed in a separate scope, so names "
"assigned to in the target list don't \"leak\" into the enclosing scope."
msgstr "なお、これらの内包表記は別のスコープで実行されるので、対象のリスト内で代入された名前が外側のスコープに \"漏れる\" ことはありません。"

#: ../../reference/expressions.rst:189
msgid ""
"Since Python 3.6, in an :keyword:`async def` function, an :keyword:`async "
"for` clause may be used to iterate over a :term:`asynchronous iterator`. A "
"comprehension in an :keyword:`async def` function may consist of either a "
":keyword:`for` or :keyword:`async for` clause following the leading "
"expression, may contain additional :keyword:`for` or :keyword:`async for` "
"clauses, and may also use :keyword:`await` expressions. If a comprehension "
"contains either :keyword:`async for` clauses or :keyword:`await` expressions"
" it is called an :dfn:`asynchronous comprehension`.  An asynchronous "
"comprehension may suspend the execution of the coroutine function in which "
"it appears. See also :pep:`530`."
msgstr ""

#: ../../reference/expressions.rst:204
msgid "List displays"
msgstr "リスト表現"

#: ../../reference/expressions.rst:212
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr "リスト表現は、角括弧で囲われた式の系列です。系列は空の系列であってもかまいません:"

#: ../../reference/expressions.rst:218
msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a comprehension "
"is supplied, the list is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"リスト表示は、新しいリストオブジェクトを与えます。リストの内容は、式のリストまたはリスト内包表記 (list comprehension) で指定されます。\n"
"カンマで区切られた式のリストが与えられたときは、それらの各要素は左から右へと順に評価され、その順にリスト内に配置されます。\n"
"内包表記が与えられたときは、内包表記の結果の要素でリストが構成されます。"

#: ../../reference/expressions.rst:228
msgid "Set displays"
msgstr "集合表現"

#: ../../reference/expressions.rst:233
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary"
" displays by the lack of colons separating keys and values:"
msgstr "集合表現は波括弧で表され、キーと値を分けるコロンがないことで辞書表現と区別されます:"

#: ../../reference/expressions.rst:239
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"集合表示は、新しいミュータブルな集合オブジェクトを与えます。集合の内容は、式の並びまたは内包表記によって指定されます。\n"
"カンマ区切りの式のリストが与えられたときは、その要素は左から右へ順に評価され、集合オブジェクトに加えられます。\n"
"内包表記が与えられたときは、内包表記の結果の要素で集合が構成されます。"

#: ../../reference/expressions.rst:245
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr "空集合は ``{}`` で構成できません。このリテラルは空の辞書を構成します。"

#: ../../reference/expressions.rst:252
msgid "Dictionary displays"
msgstr "辞書表現"

#: ../../reference/expressions.rst:258
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs enclosed "
"in curly braces:"
msgstr "辞書表現は、波括弧で囲われた、キーと値のペアからなる系列です。系列は空の系列であってもかまいません:"

#: ../../reference/expressions.rst:267
msgid "A dictionary display yields a new dictionary object."
msgstr "辞書表現は、新たな辞書オブジェクトを表します。"

#: ../../reference/expressions.rst:269
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: each "
"key object is used as a key into the dictionary to store the corresponding "
"datum.  This means that you can specify the same key multiple times in the "
"key/datum list, and the final dictionary's value for that key will be the "
"last one given."
msgstr ""
"キーとデータからなる対の並びがカンマ区切りで与えられたときは、その要素は左から右へ評価され、辞書のエントリーを定義します。すなわち、それぞれのキーオブジェクトが、辞書内で対応するデータを保存するキーとして使われます。\n"
"これにより、キーとデータのリストの中で同じキーを複数回指定することができ、そのキーに対する最終的な辞書の値は、最後に与えられたものになります。"

#: ../../reference/expressions.rst:277
msgid ""
"A double asterisk ``**`` denotes :dfn:`dictionary unpacking`. Its operand "
"must be a :term:`mapping`.  Each mapping item is added to the new "
"dictionary.  Later values replace values already set by earlier key/datum "
"pairs and earlier dictionary unpackings."
msgstr ""
"ダブルアスタリスク ``**`` は :dfn:`辞書のアンパック` を表します。このとき被演算子は :term:`mapping` "
"でなければなりません。それぞれのmappingの要素は、新たな辞書に追加されます。キー/データの対もしくは辞書のアンパックによって先に追加された値は、後から追加された値によって上書きされます。"

#: ../../reference/expressions.rst:282
msgid "Unpacking into dictionary displays, originally proposed by :pep:`448`."
msgstr ""

#: ../../reference/expressions.rst:285
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements"
" are inserted in the new dictionary in the order they are produced."
msgstr ""
"辞書内包表記は、リストや集合の内包表記とは対照的に、通常の \"for\" や \"if\" 節の前に、コロンで分けられた 2 "
"つの式が必要です。内包表記が起動すると、結果のキーと値の要素が、作られた順に新しい辞書に挿入されます。"

#: ../../reference/expressions.rst:293
msgid ""
"Restrictions on the types of the key values are listed earlier in section "
":ref:`types`.  (To summarize, the key type should be :term:`hashable`, which"
" excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last datum (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""
"キーの値として使える型に関する制限は :ref:`types` 節ですでに列挙しています。(一言でいうと、キーは変更可能なオブジェクトを全て排除した "
":term:`hashable` でなければなりません。) 重複するキー間で衝突が起きても、衝突が検出されることはありません; "
"あるキーに対して、最後に渡されたデータ (プログラムテキスト上では、辞書表記の最も右側値となるもの) が使われます。"

#: ../../reference/expressions.rst:303
msgid "Generator expressions"
msgstr "ジェネレータ式"

#: ../../reference/expressions.rst:308
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr "ジェネレータ式 (generator expression) とは、丸括弧を使ったコンパクトなジェネレータ表記法です:"

#: ../../reference/expressions.rst:313
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr "ジェネレータ式は新たなジェネレータオブジェクトを与えます。この構文は内包表記とほぼ同じですが、角括弧や波括弧ではなく、丸括弧で囲まれます。"

#: ../../reference/expressions.rst:317
msgid ""
"Variables used in the generator expression are evaluated lazily when the "
":meth:`~generator.__next__` method is called for the generator object (in "
"the same fashion as normal generators).  However, the leftmost "
":keyword:`for` clause is immediately evaluated, so that an error produced by"
" it can be seen before any other possible error in the code that handles the"
" generator expression. Subsequent :keyword:`for` clauses cannot be evaluated"
" immediately since they may depend on the previous :keyword:`for` loop. For "
"example: ``(x*y for x in range(10) for y in bar(x))``."
msgstr ""
"ジェネレータ式の中で使われている変数は、 (通常のジェネレータと同じように) そのジェネレータオブジェクトに対して "
":meth:`~generator.__next__` メソッドが呼ばれたときに遅延評価されます。ただし、最も左に位置する :keyword:`for`"
" 節は直ちに評価されるため、そこで生じたエラーは、 ジェネレータ式を扱うコードの中で起きる他のエラーよりも前に表示されます。前の "
":keyword:`for` ループに依存するかもしれないので、後の :keyword:`for` 節は即座に評価することができません。例えば: "
"``(x*y for x in range(10) for y in bar(x))`` 。"

#: ../../reference/expressions.rst:326
msgid ""
"The parentheses can be omitted on calls with only one argument.  See section"
" :ref:`calls` for details."
msgstr "関数の唯一の引数として渡す場合には、丸括弧を省略できます。詳しくは :ref:`calls` 節を参照してください。"

#: ../../reference/expressions.rst:329
msgid ""
"Since Python 3.6, if the generator appears in an :keyword:`async def` "
"function, then :keyword:`async for` clauses and :keyword:`await` expressions"
" are permitted as with an asynchronous comprehension.  If a generator "
"expression contains either :keyword:`async for` clauses or :keyword:`await` "
"expressions it is called an :dfn:`asynchronous generator expression`. An "
"asynchronous generator expression yields a new asynchronous generator "
"object, which is an asynchronous iterator (see :ref:`async-iterators`)."
msgstr ""

#: ../../reference/expressions.rst:341
msgid "Yield expressions"
msgstr "Yield 式"

#: ../../reference/expressions.rst:352
msgid ""
"The yield expression is used when defining a :term:`generator` function or "
"an :term:`asynchronous generator` function and thus can only be used in the "
"body of a function definition.  Using a yield expression in a function's "
"body causes that function to be a generator, and using it in an "
":keyword:`async def` function's body causes that coroutine function to be an"
" asynchronous generator. For example::"
msgstr ""

#: ../../reference/expressions.rst:365
msgid ""
"Generator functions are described below, while asynchronous generator "
"functions are described separately in section :ref:`asynchronous-generator-"
"functions`."
msgstr ""

#: ../../reference/expressions.rst:369
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of the generator "
"function. The execution starts when one of the generator's methods is "
"called.  At that time, the execution proceeds to the first yield expression,"
" where it is suspended again, returning the value of "
":token:`expression_list` to the generator's caller.  By suspended, we mean "
"that all local state is retained, including the current bindings of local "
"variables, the instruction pointer, the internal evaluation stack, and the "
"state of any exception handling.  When the execution is resumed by calling "
"one of the generator's methods, the function can proceed exactly as if the "
"yield expression were just another external call.  The value of the yield "
"expression after resuming depends on the method which resumed the execution."
"  If :meth:`~generator.__next__` is used (typically via either a "
":keyword:`for` or the :func:`next` builtin) then the result is "
":const:`None`.  Otherwise, if :meth:`~generator.send` is used, then the "
"result will be the value passed in to that method."
msgstr ""
"ジェネレータ関数が呼び出された時、ジェネレータとしてのイテレータを返します。ジェネレータはその後ジェネレータ関数の実行を制御します。ジェネレータのメソッドが呼び出されると実行が開始されます。開始されると、最初の"
" yield 式まで処理して一時停止し、呼び出し元へ :token:`expression_list` "
"の値を返します。ここで言う一時停止とは、ローカル変数の束縛、命令ポインタや内部の評価スタック、そして例外処理のを含むすべてのローカル状態が保持されることを意味します。再度、ジェネレータのメソッドが呼び出されて実行を再開した時、ジェネレータは"
" yield 式がただの外部呼び出しであったかのように処理を継続します。再開後の yield "
"式の値は実行を再開するメソッドに依存します。:meth:`~generator.__next__` を使用した場合 (一般に "
":keyword:`for` 文や組み込み関数 :func:`next` など) の結果は :const:`None` "
"となり、:meth:`~generator.send` を使用した場合はそのメソッドに渡された値が結果になります。"

#: ../../reference/expressions.rst:388
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where the execution should continue after it yields;"
" the control is always transferred to the generator's caller."
msgstr ""
"これまで説明した内容から、ジェネレータ関数はコルーチンにとてもよく似ています。ジェネレータ関数は何度も生成し、1つ以上のエントリポイントを持ち、その実行は一時停止されます。ジェネレータ関数は"
" yield した後で実行の継続を制御できないことが唯一の違いです。その制御は常にジェネレータの呼び出し元へ移されます。"

#: ../../reference/expressions.rst:394
msgid ""
"Yield expressions are allowed anywhere in a :keyword:`try` construct.  If "
"the generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), the generator-iterator's "
":meth:`~generator.close` method will be called, allowing any pending "
":keyword:`finally` clauses to execute."
msgstr ""
"yield 式は :keyword:`try` 構造内で使用できます。ジェネレータの (参照カウントがゼロに達するか、ガベージコレクションによる) "
"完了前に再開されない場合、ジェネレータ-イテレータの :meth:`~generator.close` "
"メソッドが呼ばれ、:keyword:`finally` 節が実行されます。"

#: ../../reference/expressions.rst:400
msgid ""
"When ``yield from <expr>`` is used, it treats the supplied expression as a "
"subiterator. All values produced by that subiterator are passed directly to "
"the caller of the current generator's methods. Any values passed in with "
":meth:`~generator.send` and any exceptions passed in with "
":meth:`~generator.throw` are passed to the underlying iterator if it has the"
" appropriate methods.  If this is not the case, then :meth:`~generator.send`"
" will raise :exc:`AttributeError` or :exc:`TypeError`, while "
":meth:`~generator.throw` will just raise the passed in exception "
"immediately."
msgstr ""
"``yield from <expr>`` "
"を使用した場合、与えられた式はサブイテレータとして扱われます。サブイテレータによって生成されたすべての値は現在のジェネレータのメソッドの呼び出し元へ直接渡されます。:meth:`~generator.send`"
" で渡されたあらゆる値と :meth:`~generator.throw` "
"で渡されたあらゆる例外は根底のイテレータに適切なメソッドがあれば渡されます。適切なメソッドがない場合、:meth:`~generator.send` は"
" :exc:`AttributeError` か :exc:`TypeError` を、:meth:`~generator.throw` "
"は渡された例外を即座に送出します。"

#: ../../reference/expressions.rst:409
msgid ""
"When the underlying iterator is complete, the :attr:`~StopIteration.value` "
"attribute of the raised :exc:`StopIteration` instance becomes the value of "
"the yield expression. It can be either set explicitly when raising "
":exc:`StopIteration`, or automatically when the sub-iterator is a generator "
"(by returning a value from the sub-generator)."
msgstr ""
"根底のイテレータの完了時、引き起こされた :exc:`StopIteration` インスタンスの "
":attr:`~StopIteration.value` 属性はその yield 式の値となります。 :exc:`StopIteration` "
"を起こす際に明示的にセットされるか、サブイテレータがジェネレータであれば (サブイテレータからかえる値で) 自動的にセットされるかのどちらかです。"

#: ../../reference/expressions.rst:415
msgid "Added ``yield from <expr>`` to delegate control flow to a subiterator."
msgstr "サブイテレータに制御フローを委譲するために ``yield from <expr>`` が追加されました。"

#: ../../reference/expressions.rst:418
msgid ""
"The parentheses may be omitted when the yield expression is the sole "
"expression on the right hand side of an assignment statement."
msgstr "yield 式が代入文の単独の右辺式であるとき、括弧は省略できます。"

#: ../../reference/expressions.rst:424
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - 単純なジェネレータ"

#: ../../reference/expressions.rst:424
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr "Python へのジェネレータと :keyword:`yield` 文の導入提案。"

#: ../../reference/expressions.rst:428
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`0342` - 拡張されたジェネレータを用いたコルーチン"

#: ../../reference/expressions.rst:427
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable"
" as simple coroutines."
msgstr "シンプルなコルーチンとして利用できるように、ジェネレータの構文と API を拡張する提案です。"

#: ../../reference/expressions.rst:431
msgid ":pep:`380` - Syntax for Delegating to a Subgenerator"
msgstr ":pep:`380` - サブジェネレータへの委譲構文"

#: ../../reference/expressions.rst:431
msgid ""
"The proposal to introduce the :token:`yield_from` syntax, making delegation "
"to sub-generators easy."
msgstr "サブジェネレータの委譲を簡単にするための、 :token:`yield_from` 構文の導入提案。"

#: ../../reference/expressions.rst:438
msgid "Generator-iterator methods"
msgstr "ジェネレータ-イテレータメソッド"

#: ../../reference/expressions.rst:440
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr "この説ではジェネレータイテレータのメソッドについて説明します。これらはジェネレータ関数の実行制御に使用できます。"

#: ../../reference/expressions.rst:443
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr ""
"以下のジェネレータメソッドの呼び出しは、ジェネレータが既に実行中の場合 :exc:`ValueError` 例外を送出する点に注意してください。"

#: ../../reference/expressions.rst:451
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed yield expression.  When a generator function is resumed with a "
":meth:`~generator.__next__` method, the current yield expression always "
"evaluates to :const:`None`.  The execution then continues to the next yield "
"expression, where the generator is suspended again, and the value of the "
":token:`expression_list` is returned to :meth:`__next__`'s caller.  If the "
"generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised."
msgstr ""
"ジェネレータ関数の実行を開始するか、最後に yield 式が実行されたところから再開します。ジェネレータ関数が "
":meth:`~generator.__next__` メソッドによって再開された時、その時点の :keyword:`yield` 式の値は常に "
":const:`None` と評価されます。その後次の :keyword:`yield` "
"式まで実行し、ジェネレータは一時停止し、:token:`expression_list` の値を :meth:`__next__` "
"メソッドの呼び出し元に返します。ジェネレータが次の値を yield せずに終了した場合、:exc:`StopIteration` 例外が送出されます。"

#: ../../reference/expressions.rst:460
msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop, or"
" by the built-in :func:`next` function."
msgstr "このメソッドは通常、例えば :keyword:`for` ループや組み込みの :func:`next` 関数によって暗黙に呼び出されます。"

#: ../../reference/expressions.rst:466
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The *value* argument becomes the result of the current yield expression.  "
"The :meth:`send` method returns the next value yielded by the generator, or "
"raises :exc:`StopIteration` if the generator exits without yielding another "
"value.  When :meth:`send` is called to start the generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""
"ジェネレータ関数の内部へ値を \"送り\"、実行を再開します。引数の *value* はその時点の yield 式の結果になります。 "
":meth:`send` メソッドは次にジェネレータが生成した値を返し、ジェネレータが次の値を生成することなく終了すると "
":exc:`StopIteration` を送出します。 :meth:`send` が呼び出されてジェネレータが開始するときは、値を受け取る yield"
" 式が存在しないので、 :const:`None` を引数として呼び出さなければなりません。"

#: ../../reference/expressions.rst:477
msgid ""
"Raises an exception of type ``type`` at the point where the generator was "
"paused, and returns the next value yielded by the generator function.  If "
"the generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised.  If the generator function does not catch the passed-in"
" exception, or raises a different exception, then that exception propagates "
"to the caller."
msgstr ""
"ジェネレータが中断した位置で ``type`` "
"型の例外を発生させて、そのジェネレータ関数が生成する次の値を返します。ジェネレータが値を生成することなく終了すると "
":exc:`StopIteration` "
"が発生します。ジェネレータ関数が渡された例外を捕捉しない、もしくは違う例外を発生させるなら、その例外は呼び出し元へ伝搬されます。"

#: ../../reference/expressions.rst:488
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then exits gracefully, is already closed,"
" or raises :exc:`GeneratorExit` (by not catching the exception), close "
"returns to its caller.  If the generator yields a value, a "
":exc:`RuntimeError` is raised.  If the generator raises any other exception,"
" it is propagated to the caller.  :meth:`close` does nothing if the "
"generator has already exited due to an exception or normal exit."
msgstr ""

#: ../../reference/expressions.rst:499
msgid "Examples"
msgstr "使用例"

#: ../../reference/expressions.rst:501
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr "以下の簡単なサンプルはジェネレータとジェネレータ関数の振る舞いを実際に紹介します::"

#: ../../reference/expressions.rst:528
msgid ""
"For examples using ``yield from``, see :ref:`pep-380` in \"What's New in "
"Python.\""
msgstr ""
"``yield from`` の使用例は、\"What's New in Python.\" の :ref:`pep-380` を参照してください。"

#: ../../reference/expressions.rst:534
msgid "Asynchronous generator functions"
msgstr "非同期ジェネレータ関数 (asynchronous generator function)"

#: ../../reference/expressions.rst:536
msgid ""
"The presence of a yield expression in a function or method defined using "
":keyword:`async def` further defines the function as a :term:`asynchronous "
"generator` function."
msgstr ""

#: ../../reference/expressions.rst:540
msgid ""
"When an asynchronous generator function is called, it returns an "
"asynchronous iterator known as an asynchronous generator object. That object"
" then controls the execution of the generator function. An asynchronous "
"generator object is typically used in an :keyword:`async for` statement in a"
" coroutine function analogously to how a generator object would be used in a"
" :keyword:`for` statement."
msgstr ""

#: ../../reference/expressions.rst:547
msgid ""
"Calling one of the asynchronous generator's methods returns an "
":term:`awaitable` object, and the execution starts when this object is "
"awaited on. At that time, the execution proceeds to the first yield "
"expression, where it is suspended again, returning the value of "
":token:`expression_list` to the awaiting coroutine. As with a generator, "
"suspension means that all local state is retained, including the current "
"bindings of local variables, the instruction pointer, the internal "
"evaluation stack, and the state of any exception handling.  When the "
"execution is resumed by awaiting on the next object returned by the "
"asynchronous generator's methods, the function can proceed exactly as if the"
" yield expression were just another external call. The value of the yield "
"expression after resuming depends on the method which resumed the execution."
"  If :meth:`~agen.__anext__` is used then the result is :const:`None`. "
"Otherwise, if :meth:`~agen.asend` is used, then the result will be the value"
" passed in to that method."
msgstr ""

#: ../../reference/expressions.rst:563
msgid ""
"In an asynchronous generator function, yield expressions are allowed "
"anywhere in a :keyword:`try` construct. However, if an asynchronous "
"generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), then a yield expression "
"within a :keyword:`try` construct could result in a failure to execute "
"pending :keyword:`finally` clauses.  In this case, it is the responsibility "
"of the event loop or scheduler running the asynchronous generator to call "
"the asynchronous generator-iterator's :meth:`~agen.aclose` method and run "
"the resulting coroutine object, thus allowing any pending :keyword:`finally`"
" clauses to execute."
msgstr ""

#: ../../reference/expressions.rst:574
msgid ""
"To take care of finalization, an event loop should define a *finalizer* "
"function which takes an asynchronous generator-iterator and presumably calls"
" :meth:`~agen.aclose` and executes the coroutine. This  *finalizer* may be "
"registered by calling :func:`sys.set_asyncgen_hooks`. When first iterated "
"over, an asynchronous generator-iterator will store the registered "
"*finalizer* to be called upon finalization. For a reference example of a "
"*finalizer* method see the implementation of "
"``asyncio.Loop.shutdown_asyncgens`` in :source:`Lib/asyncio/base_events.py`."
msgstr ""

#: ../../reference/expressions.rst:583
msgid ""
"The expression ``yield from <expr>`` is a syntax error when used in an "
"asynchronous generator function."
msgstr ""

#: ../../reference/expressions.rst:590
msgid "Asynchronous generator-iterator methods"
msgstr ""

#: ../../reference/expressions.rst:592
msgid ""
"This subsection describes the methods of an asynchronous generator iterator,"
" which are used to control the execution of a generator function."
msgstr ""

#: ../../reference/expressions.rst:600
msgid ""
"Returns an awaitable which when run starts to execute the asynchronous "
"generator or resumes it at the last executed yield expression.  When an "
"asynchronous generator function is resumed with a :meth:`~agen.__anext__` "
"method, the current yield expression always evaluates to :const:`None` in "
"the returned awaitable, which when run will continue to the next yield "
"expression. The value of the :token:`expression_list` of the yield "
"expression is the value of the :exc:`StopIteration` exception raised by the "
"completing coroutine.  If the asynchronous generator exits without yielding "
"another value, the awaitable instead raises an :exc:`StopAsyncIteration` "
"exception, signalling that the asynchronous iteration has completed."
msgstr ""

#: ../../reference/expressions.rst:612
msgid ""
"This method is normally called implicitly by a :keyword:`async for` loop."
msgstr ""

#: ../../reference/expressions.rst:617
msgid ""
"Returns an awaitable which when run resumes the execution of the "
"asynchronous generator. As with the :meth:`~generator.send()` method for a "
"generator, this \"sends\" a value into the asynchronous generator function, "
"and the *value* argument becomes the result of the current yield expression."
" The awaitable returned by the :meth:`asend` method will return the next "
"value yielded by the generator as the value of the raised "
":exc:`StopIteration`, or raises :exc:`StopAsyncIteration` if the "
"asynchronous generator exits without yielding another value.  When "
":meth:`asend` is called to start the asynchronous generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""

#: ../../reference/expressions.rst:632
msgid ""
"Returns an awaitable that raises an exception of type ``type`` at the point "
"where the asynchronous generator was paused, and returns the next value "
"yielded by the generator function as the value of the raised "
":exc:`StopIteration` exception.  If the asynchronous generator exits without"
" yielding another value, an :exc:`StopAsyncIteration` exception is raised by"
" the awaitable. If the generator function does not catch the passed-in "
"exception, or raises a different exception, then when the awaitable is run "
"that exception propagates to the caller of the awaitable."
msgstr ""

#: ../../reference/expressions.rst:647
msgid ""
"Returns an awaitable that when run will throw a :exc:`GeneratorExit` into "
"the asynchronous generator function at the point where it was paused. If the"
" asynchronous generator function then exits gracefully, is already closed, "
"or raises :exc:`GeneratorExit` (by not catching the exception), then the "
"returned awaitable will raise a :exc:`StopIteration` exception. Any further "
"awaitables returned by subsequent calls to the asynchronous generator will "
"raise a :exc:`StopAsyncIteration` exception.  If the asynchronous generator "
"yields a value, a :exc:`RuntimeError` is raised by the awaitable.  If the "
"asynchronous generator raises any other exception, it is propagated to the "
"caller of the awaitable.  If the asynchronous generator has already exited "
"due to an exception or normal exit, then further calls to :meth:`aclose` "
"will return an awaitable that does nothing."
msgstr ""

#: ../../reference/expressions.rst:663
msgid "Primaries"
msgstr "プライマリ"

#: ../../reference/expressions.rst:667
msgid ""
"Primaries represent the most tightly bound operations of the language. Their"
" syntax is:"
msgstr "プライマリは、言語において最も結合の強い操作を表します。文法は以下のようになります:"

#: ../../reference/expressions.rst:677
msgid "Attribute references"
msgstr "属性参照"

#: ../../reference/expressions.rst:681
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr "属性参照は、プライマリの後ろにピリオドと名前を連ねたものです:"

#: ../../reference/expressions.rst:691
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce the"
" attribute whose name is the identifier.  This production can be customized "
"by overriding the :meth:`__getattr__` method.  If this attribute is not "
"available, the exception :exc:`AttributeError` is raised.  Otherwise, the "
"type and value of the object produced is determined by the object.  Multiple"
" evaluations of the same attribute reference may yield different objects."
msgstr ""
"プライマリの評価は、属性参照をサポートする型のオブジェクトでなければならず、これにはほとんどのオブジェクトが当てはまります。そしてこのオブジェクトは、名前が指定した識別子名であるような属性を生成しなければなりません。この生成は"
" :meth:`__getattr__` メソッドをオーバーライドすることでカスタマイズできます。その属性が得られなければ、例外 "
":exc:`AttributeError` "
"が送出されます。そうでなければ、生成されるオブジェクトの型と値は、属性を生成したオブジェクトにより決まります。同じ属性参照を複数回評価すると、互いに異なる属性オブジェクトが得られることがあります。"

#: ../../reference/expressions.rst:703
msgid "Subscriptions"
msgstr "添字表記 (subscription)"

#: ../../reference/expressions.rst:716
msgid ""
"A subscription selects an item of a sequence (string, tuple or list) or "
"mapping (dictionary) object:"
msgstr "添字表記は、シーケンス (文字列、タプルまたはリスト) やマップ (辞書) オブジェクトから、要素を一つ選択します:"

#: ../../reference/expressions.rst:722
msgid ""
"The primary must evaluate to an object that supports subscription (lists or "
"dictionaries for example).  User-defined objects can support subscription by"
" defining a :meth:`__getitem__` method."
msgstr ""
"プライマリの評価は、添字表記をサポートするオブジェクト (例えばリストや辞書) でなければなりません。ユーザ定義のオブジェクトは、 "
":meth:`__getitem__` メソッドを定義することで添字表記をサポートできます。"

#: ../../reference/expressions.rst:726
msgid ""
"For built-in objects, there are two types of objects that support "
"subscription:"
msgstr "組み込みオブジェクトでは、添字表記をサポートするオブジェクトには 2 種類あります:"

#: ../../reference/expressions.rst:728
msgid ""
"If the primary is a mapping, the expression list must evaluate to an object "
"whose value is one of the keys of the mapping, and the subscription selects "
"the value in the mapping that corresponds to that key.  (The expression list"
" is a tuple except if it has exactly one item.)"
msgstr ""
"プライマリがマップであれば、式リストの値評価結果はマップ内のいずれかのキー値に相当するオブジェクトにならなければなりません。添字表記は、そのキーに対応するマップ内の値"
" (value) を選択します。 (式リストの要素が単独である場合を除き、式リストはタプルでなければなりません。)"

#: ../../reference/expressions.rst:733
msgid ""
"If the primary is a sequence, the expression (list) must evaluate to an "
"integer or a slice (as discussed in the following section)."
msgstr "プライマリがシーケンスであれば、式 (リスト) の評価は整数またはスライス (以下の節で論じます) でなければなりません。"

#: ../../reference/expressions.rst:736
msgid ""
"The formal syntax makes no special provision for negative indices in "
"sequences; however, built-in sequences all provide a :meth:`__getitem__` "
"method that interprets negative indices by adding the length of the sequence"
" to the index (so that ``x[-1]`` selects the last item of ``x``).  The "
"resulting value must be a nonnegative integer less than the number of items "
"in the sequence, and the subscription selects the item whose index is that "
"value (counting from zero). Since the support for negative indices and "
"slicing occurs in the object's :meth:`__getitem__` method, subclasses "
"overriding this method will need to explicitly add that support."
msgstr ""
"形式的な構文はシーケンスの負のインデックスにいかなる特例も与えません。しかし、すべての組み込みのシーケンスが与える "
":meth:`__getitem__` メソッドは、負のインデックスを、インデックスにシーケンスの長さを加えて解釈します (つまり、 ``x[-1]``"
" は ``x`` の最後の要素を選択します)。結果の値はシーケンスの要素数より小さな非負の整数でなければなりません。添字表記は、(0 から数えた) "
"インデックスを持つ要素を選択します。負のインデックスのサポートは、オブジェクトの :meth:`__getitem__` "
"メソッドに現れるので、このメソッドをオーバーライドするサブクラスは、明示的にこのサポートを追加する必要があります。"

#: ../../reference/expressions.rst:750
msgid ""
"A string's items are characters.  A character is not a separate data type "
"but a string of exactly one character."
msgstr "文字列型の要素は文字 (character) です。文字は個別の型ではなく、 1 文字だけからなる文字列です。"

#: ../../reference/expressions.rst:757
msgid "Slicings"
msgstr "スライス表記 (slicing)"

#: ../../reference/expressions.rst:769
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""
"スライス表記はシーケンスオブジェクト (文字列、タプルまたはリスト) におけるある範囲の要素を選択します。スライス表記は式として用いたり、代入や "
":keyword:`del` 文の対象として用いたりできます。スライス表記の構文は以下のようになります:"

#: ../../reference/expressions.rst:782
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this"
" is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice)."
msgstr ""
"上記の形式的な構文法にはあいまいなところがあります: "
"式リストに見えるものは、スライスリストにも見えるため、添字表記はスライス表記としても解釈されうるということです。(スライスリストが適切なスライスを含まない場合)、これ以上の構文の複雑化はせず、スライス表記としての解釈よりも添字表記としての解釈が優先されるように定義することで、あいまいさを取り除いています。"

#: ../../reference/expressions.rst:794
msgid ""
"The semantics for a slicing are as follows.  The primary is indexed (using "
"the same :meth:`__getitem__` method as normal subscription) with a key that "
"is constructed from the slice list, as follows.  If the slice list contains "
"at least one comma, the key is a tuple containing the conversion of the "
"slice items; otherwise, the conversion of the lone slice item is the key.  "
"The conversion of a slice item that is an expression is that expression.  "
"The conversion of a proper slice is a slice object (see section "
":ref:`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and "
":attr:`~slice.step` attributes are the values of the expressions given as "
"lower bound, upper bound and stride, respectively, substituting ``None`` for"
" missing expressions."
msgstr ""
"スライス表記に対する意味付けは、以下のようになります。プライマリの値評価結果は、以下に述べるようにしてスライスリストから生成されたキーによって "
"(通常の添字表記と同じ :meth:`__getitem__` メソッドを使って) "
"インデクス指定できなければなりません。スライスリストに一つ以上のカンマが含まれている場合、キーは各スライス要素を値変換したものからなるタプルになります;"
" "
"それ以外の場合、単一のスライス要素自体を値変換したものがキーになります。一個の式であるスライス要素は、その式に変換されます。適切なスライスは、スライスオブジェクト"
" (:ref:`types` 参照) に変換され、その :attr:`~slice.start`, :attr:`~slice.stop` および "
":attr:`~slice.step`  属性は、それぞれ指定した下境界、上境界、およびとび幅 (stride) になります。式がない場所は "
"``None`` で置き換えられます。"

#: ../../reference/expressions.rst:815
msgid "Calls"
msgstr "呼び出し (call)"

#: ../../reference/expressions.rst:817
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""
"呼び出しは、呼び出し可能オブジェクト (例えば :term:`function`) を :term:`arguments <argument>` "
"の系列とともに呼び出します。系列は空の系列であってもかまいません:"

#: ../../reference/expressions.rst:833
msgid ""
"An optional trailing comma may be present after the positional and keyword "
"arguments but does not affect the semantics."
msgstr "最後の位置引数やキーワード引数の後にカンマをつけてもかまいません。構文の意味付けに影響を及ぼすことはありません。"

#: ../../reference/expressions.rst:839
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and all objects having a :meth:`__call__` method are "
"callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of formal"
" :term:`parameter` lists."
msgstr ""
"プライマリの評価は呼び出し可能オブジェクトでなければなりません。 "
"(ユーザ定義関数、組み込み関数、組み込みオブジェクトのメソッド、クラスオブジェクト、クラスインスタンスのメソッド、および "
":meth:`__call__` メソッドを持つ全てのオブジェクトが呼び出し可能です)。引数式は全て、呼び出しを試みる前に評価されます。仮引数 "
"(formal :term:`parameter`) リストの構文については :ref:`function` を参照してください。"

#: ../../reference/expressions.rst:847
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the value of the argument is placed in the slot, filling it (even if the "
"expression is ``None``, it fills the slot).  When all arguments have been "
"processed, the slots that are still unfilled are filled with the "
"corresponding default value from the function definition.  (Default values "
"are calculated, once, when the function is defined; thus, a mutable object "
"such as a list or dictionary used as default value will be shared by all "
"calls that don't specify an argument value for the corresponding slot; this "
"should usually be avoided.)  If there are any unfilled slots for which no "
"default value is specified, a :exc:`TypeError` exception is raised.  "
"Otherwise, the list of filled slots is used as the argument list for the "
"call."
msgstr ""
"キーワード引数が存在する場合、以下のようにして最初に位置引数 (positional argument) "
"に変換されます。まず、値の入っていないスロットが仮引数に対して生成されます。N 個の位置引数がある場合、位置引数は先頭の N "
"スロットに配置されます。次に、各キーワード引数について、識別子を使って対応するスロットを決定します "
"(識別子が最初の仮引数名と同じなら、最初のスロットを使う、といった具合です)。スロットがすでにすべて埋まっていたなら :exc:`TypeError` "
"例外が送出されます。それ以外の場合、引数値をスロットに埋めていきます。 (式が ``None`` "
"であっても、その式でスロットを埋めます)。全ての引数が処理されたら、まだ埋められていないスロットをそれぞれに対応する関数定義時のデフォルト値で埋めます。(デフォルト値は、関数が定義されたときに一度だけ計算されます;"
" "
"従って、リストや辞書のような変更可能なオブジェクトがデフォルト値として使われると、対応するスロットに引数を指定しない限り、このオブジェクトが全ての呼び出しから共有されます;"
" このような状況は通常避けるべきです。) デフォルト値が指定されていない、値の埋められていないスロットが残っている場合 :exc:`TypeError`"
" 例外が送出されます。そうでない場合、値の埋められたスロットからなるリストが呼び出しの引数として使われます。"

#: ../../reference/expressions.rst:867
msgid ""
"An implementation may provide built-in functions whose positional parameters"
" do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use "
":c:func:`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"実装では、名前を持たない位置引数を受け取る組み込み関数を提供されるかもしれません。そういった引数がドキュメント化のために '名付けられて' "
"いたとしても、実際には名付けられていないのでキーワードでは提供されません。 CPython では、C "
"言語で実装された関数の、名前を持たない位置引数をパースするために :c:func:`PyArg_ParseTuple` を使用します。"

#: ../../reference/expressions.rst:873
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an"
" empty tuple if there were no excess positional arguments)."
msgstr ""
"仮引数スロットの数よりも多くの位置引数がある場合、構文 ``*identifier`` を使って指定された仮引数がないかぎり、 "
":exc:`TypeError` 例外が送出されます; 仮引数 ``*identifier`` がある場合、この仮引数は余分な位置引数が入ったタプル "
"(もしくは、余分な位置引数がない場合には空のタプル) を受け取ります。"

#: ../../reference/expressions.rst:879
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a "
":exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""
"キーワード引数のいずれかが仮引数名に対応しない場合、構文 ``**identifier`` を使って指定された仮引数がない限り、 "
":exc:`TypeError` 例外が送出されます; 仮引数 ``**identifier`` がある場合、この仮引数は余分なキーワード引数が入った "
"(キーワードをキーとし、引数値をキーに対応する値とした) 辞書を受け取ります。余分なキーワード引数がない場合には、空の (新たな) 辞書を受け取ります。"

#: ../../reference/expressions.rst:890
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an :term:`iterable`.  Elements from these iterables are "
"treated as if they were additional positional arguments.  For the call "
"``f(x1, x2, *y, x3, x4)``, if *y* evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+4 positional arguments *x1*, *x2*, *y1*,"
" ..., *yM*, *x3*, *x4*."
msgstr ""

#: ../../reference/expressions.rst:897
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear"
" *after* explicit keyword arguments, it is processed *before* the keyword "
"arguments (and any ``**expression`` arguments -- see below).  So::"
msgstr ""

#: ../../reference/expressions.rst:913
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not arise."
msgstr ""
"キーワード引数と ``*expression`` 構文を同じ呼び出しで一緒に使うことはあまりないので、実際に上記のような混乱が生じることはありません。"

#: ../../reference/expressions.rst:919
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a :term:`mapping`, the contents of which are treated as "
"additional keyword arguments.  If a keyword is already present (as an "
"explicit keyword argument, or from another unpacking), a :exc:`TypeError` "
"exception is raised."
msgstr ""

#: ../../reference/expressions.rst:925
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr ""
"``*identifier`` や ``**identifier`` 構文を使った仮引数は、位置引数スロットやキーワード引数名にすることができません。"

#: ../../reference/expressions.rst:928
msgid ""
"Function calls accept any number of ``*`` and ``**`` unpackings, positional "
"arguments may follow iterable unpackings (``*``), and keyword arguments may "
"follow dictionary unpackings (``**``). Originally proposed by :pep:`448`."
msgstr ""

#: ../../reference/expressions.rst:934
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""
"呼び出しを行うと、例外を送出しない限り、常に何らかの値を返します。 ``None`` "
"を返す場合もあります。戻り値がどのように算出されるかは、呼び出し可能オブジェクトの形態によって異なります。"

#: ../../reference/expressions.rst:938
msgid "If it is---"
msgstr "各形態では---"

#: ../../reference/expressions.rst:951
msgid "a user-defined function:"
msgstr "ユーザ定義関数:"

#: ../../reference/expressions.rst:947
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr ""
"関数のコードブロックに引数リストが渡され、実行されます。コードブロックは、まず仮引数を実引数に結合 (bind) します; この動作については "
":ref:`function` で記述しています。コードブロックで :keyword:`return` 文が実行される際に、関数呼び出しの戻り値 "
"(return value) が決定されます。"

#: ../../reference/expressions.rst:965
msgid "a built-in function or method:"
msgstr "組み込み関数またはメソッド:"

#: ../../reference/expressions.rst:964
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr "結果はインタプリタに依存します; 組み込み関数やメソッドの詳細は :ref:`built-in-funcs` を参照してください。"

#: ../../reference/expressions.rst:972
msgid "a class object:"
msgstr "クラスオブジェクト:"

#: ../../reference/expressions.rst:972
msgid "A new instance of that class is returned."
msgstr "そのクラスの新しいインスタンスが返されます。"

#: ../../reference/expressions.rst:982
msgid "a class instance method:"
msgstr "クラスインスタンスメソッド:"

#: ../../reference/expressions.rst:980
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""
"対応するユーザ定義の関数が呼び出されます。このとき、呼び出し時の引数リストより一つ長い引数リストで呼び出されます: "
"インスタンスが引数リストの先頭に追加されます。"

#: ../../reference/expressions.rst:991
msgid "a class instance:"
msgstr "クラスインスタンス:"

#: ../../reference/expressions.rst:989
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the same"
" as if that method was called."
msgstr ""
"クラスで :meth:`__call__` メソッドが定義されていなければなりません; :meth:`__call__` "
"メソッドが呼び出された場合と同じ効果をもたらします。"

#: ../../reference/expressions.rst:996 ../../reference/expressions.rst:1702
msgid "Await expression"
msgstr "Await 式"

#: ../../reference/expressions.rst:998
msgid ""
"Suspend the execution of :term:`coroutine` on an :term:`awaitable` object. "
"Can only be used inside a :term:`coroutine function`."
msgstr ""
":term:`awaitable` オブジェクトでの :term:`coroutine` 実行を一時停止します。\n"
":term:`coroutine function` 内でのみ使用できます。"

#: ../../reference/expressions.rst:1010
msgid "The power operator"
msgstr "べき乗演算 (power operator)"

#: ../../reference/expressions.rst:1012
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""
"べき乗演算は、左側にある単項演算子よりも強い結合優先順位があります; "
"一方、右側にある単項演算子よりは低い結合優先順位になっています。構文は以下のようになります:"

#: ../../reference/expressions.rst:1018
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""
"従って、べき乗演算子と単項演算子からなる演算列が丸括弧で囲われていない場合、演算子は右から左へと評価されます "
"(この場合は演算子の評価順序を強制しません。つまり ``-1**2`` は ``-1`` になります)。"

#: ../../reference/expressions.rst:1022
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised"
" to the power of its right argument.  The numeric arguments are first "
"converted to a common type, and the result is of that type."
msgstr ""
"べき乗演算子の意味は、二つの引数で呼び出される組み込み関数 :func:`pow` "
"と同じで、左引数を右引数乗して与えます。数値引数はまず共通の型に変換され、結果はその型です。"

#: ../../reference/expressions.rst:1027
msgid ""
"For int operands, the result has the same type as the operands unless the "
"second argument is negative; in that case, all arguments are converted to "
"float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""
"整数の被演算子では、第二引数が負でない限り、結果は被演算子と同じ型になります; "
"第二引数が負の場合、全ての引数は浮動小数点型に変換され、浮動小数点型が返されます。例えば ``10**2`` は ``100`` "
"を返しますが、``10**-2`` は ``0.01`` を返します。"

#: ../../reference/expressions.rst:1032
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a "
":class:`complex` number. (In earlier versions it raised a "
":exc:`ValueError`.)"
msgstr ""
"``0.0`` を負の数でべき乗すると :exc:`ZeroDivisionError` を送出します。負の数を小数でべき乗した結果は複素数 "
"(:class:`complex` number) になります。 (以前のバージョンでは :exc:`ValueError` を送出していました)"

#: ../../reference/expressions.rst:1040
msgid "Unary arithmetic and bitwise operations"
msgstr "単項算術演算とビット単位演算 (unary arithmetic and bitwise operation)"

#: ../../reference/expressions.rst:1046
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr "全ての単項算術演算とビット単位演算は、同じ優先順位を持っています:"

#: ../../reference/expressions.rst:1055
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric "
"argument."
msgstr "単項演算子 ``-`` (マイナス) は、引数となる数値の符号を反転 (negation) します。"

#: ../../reference/expressions.rst:1059
msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr "単項演算子 ``+`` (プラス) は、数値引数を変更しません。"

#: ../../reference/expressions.rst:1064
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``."
"  It only applies to integral numbers."
msgstr ""
"単項演算子 ``~`` (反転) は、整数引数をビット単位反転 (bitwise invert) したものを与えます。``x`` "
"のビット単位反転は、``-(x+1)`` として定義されています。この演算子は整数にのみ適用されます。"

#: ../../reference/expressions.rst:1070
msgid ""
"In all three cases, if the argument does not have the proper type, a "
":exc:`TypeError` exception is raised."
msgstr "上記の三つはいずれも、引数が正しい型でない場合には :exc:`TypeError` 例外が送出されます。"

#: ../../reference/expressions.rst:1077
msgid "Binary arithmetic operations"
msgstr "二項算術演算 (binary arithmetic operation)"

#: ../../reference/expressions.rst:1081
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types."
"  Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""
"二項算術演算は、慣習的な優先順位を踏襲しています。演算子のいずれかは、特定の非数値型にも適用されるので注意してください。べき乗 (power) "
"演算子を除き、演算子には二つのレベル、すなわち乗算的 (multiplicatie) 演算子と加算的 (additie) 演算子しかありません:"

#: ../../reference/expressions.rst:1094
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers "
"are converted to a common type and then multiplied together.  In the latter "
"case, sequence repetition is performed; a negative repetition factor yields "
"an empty sequence."
msgstr ""
"``*`` (乗算: multiplication) "
"演算子は、引数同士の積を与えます。引数は、両方とも数値であるか、片方が整数で他方がシーケンスかのどちらかでなければなりません。前者の場合、数値は共通の型に変換された後乗算されます。後者の場合、シーケンスの繰り返し操作が行われます。繰り返し数を負にすると、空のシーケンスを与えます。"

#: ../../reference/expressions.rst:1102
msgid ""
"The ``@`` (at) operator is intended to be used for matrix multiplication.  "
"No builtin Python types implement this operator."
msgstr ""
"``@`` (at) 演算子は行列の乗算に対し使用されます。\n"
"Python の組み込み型はこの演算子を実装していません。"

#: ../../reference/expressions.rst:1111
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a"
" common type. Division of integers yields a float, while floor division of "
"integers results in an integer; the result is that of mathematical division "
"with the 'floor' function applied to the result.  Division by zero raises "
"the :exc:`ZeroDivisionError` exception."
msgstr ""
"``/`` (除算: division) および ``//`` (切り捨て除算: floor division) "
"は、引数同士の商を与えます。数値引数はまず共通の型に変換されます。整数の除算結果は浮動小数点になりますが、整数の切り捨て除算結果は整数になります; "
"この場合、結果は数学的な除算に 'floor' 関数 を適用したものになります。ゼロによる除算を行うと :exc:`ZeroDivisionError`"
" 例外を送出します。"

#: ../../reference/expressions.rst:1120
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or"
" zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""
"``%`` (剰余: modulo) "
"演算は、第一引数を第二引数で除算したときの剰余になります。数値引数はまず共通の型に変換されます。右引数値がゼロの場合には "
":exc:`ZeroDivisionError` 例外が送出されます。引数値は浮動小数点でもよく。例えば ``3.14%0.7`` は ``0.34``"
" になります (``3.14`` は ``4*0.7 + 0.34`` だからです)。剰余演算子は常に第二引数と同じ符号 (またはゼロ) "
"の結果になります; 剰余演算の結果の絶対値は、常に第二引数の絶対値よりも小さくなります。 [#]_"

#: ../../reference/expressions.rst:1129
msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == "
"(x//y, x%y)``. [#]_."
msgstr ""
"切り捨て除算演算と剰余演算は、恒等式: ``x == (x//y)*y + (x%y)`` の関係にあります。切り捨て除算や剰余はまた、組み込み関数 "
":func:`divmod`: ``divmod(x, y) == (x//y, x%y)`` とも関係しています。 [#]_ 。"

#: ../../reference/expressions.rst:1134
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string "
"formatting (also known as interpolation).  The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`old-string-"
"formatting`."
msgstr ""
"``%`` 演算子は、数値に対する剰余演算を行うのに加えて、文字列 (string) オブジェクトにオーバーロードされ、旧式の文字列の書式化 "
"(いわゆる補間) を行います。文字列の書式化の構文は Python ライブラリリファレンス :ref:`old-string-formatting` "
"節を参照してください。"

#: ../../reference/expressions.rst:1139
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""
"切り捨て除算演算子、剰余演算子、および :func:`divmod` 関数は、複素数に対しては定義されていません。目的に合うならば、代わりに "
":func:`abs` を使って浮動小数点に変換してください。"

#: ../../reference/expressions.rst:1145
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both be sequences of the same type."
"  In the former case, the numbers are converted to a common type and then "
"added together. In the latter case, the sequences are concatenated."
msgstr ""
"``+`` (加算) "
"演算は、引数同士の和を与えます。引数は双方とも数値型か、双方とも同じ型のシーケンスでなければなりません。前者の場合、数値は共通の型に変換され、加算されます。後者の場合、シーケンスは結合"
" (concatenate) されます。"

#: ../../reference/expressions.rst:1152
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr "``-`` (減算) 演算は、引数間で減算を行った値を返します。数値引数はまず共通の型に変換されます。"

#: ../../reference/expressions.rst:1159
msgid "Shifting operations"
msgstr "シフト演算 (shifting operation)"

#: ../../reference/expressions.rst:1163
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr "シフト演算は、算術演算よりも低い優先順位を持っています:"

#: ../../reference/expressions.rst:1168
msgid ""
"These operators accept integers as arguments.  They shift the first argument"
" to the left or right by the number of bits given by the second argument."
msgstr ""
"これらは整数を引数にとります。引数は共通の型に変換されます。シフト演算は第一引数を、第二引数で与えられたビット数だけ、左または右にビットシフトします。"

#: ../../reference/expressions.rst:1173
msgid ""
"A right shift by *n* bits is defined as floor division by ``pow(2,n)``.  A "
"left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""
"*n* ビットの右シフトは ``pow(2,n)`` による除算として定義されます。*n* ビットの左シフトは ``pow(2,n)`` "
"による乗算として定義されます。"

#: ../../reference/expressions.rst:1178
msgid ""
"In the current implementation, the right-hand operand is required to be at "
"most :attr:`sys.maxsize`.  If the right-hand operand is larger than "
":attr:`sys.maxsize` an :exc:`OverflowError` exception is raised."
msgstr ""
"現在の実装では、右辺被演算子は最大でも :attr:`sys.maxsize` でなければなりません。右辺被演算子が "
":attr:`sys.maxsize` よりも大きいと、 :exc:`OverflowError` 例外が送出されます。"

#: ../../reference/expressions.rst:1185
msgid "Binary bitwise operations"
msgstr "ビット単位演算の二項演算 (binary bitwise operation)"

#: ../../reference/expressions.rst:1189
msgid "Each of the three bitwise operations has a different priority level:"
msgstr "以下の三つのビット単位演算には、それぞれ異なる優先順位レベルがあります:"

#: ../../reference/expressions.rst:1198
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"integers."
msgstr "``&`` 演算子は、引数同士のビット単位の AND を与えます。引数は整数でなければなりません。"

#: ../../reference/expressions.rst:1205
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be integers."
msgstr "``^`` 演算子は、引数同士のビット単位の XOR (排他的 OR) を与えます。引数は整数でなければなりません。"

#: ../../reference/expressions.rst:1212
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which"
" must be integers."
msgstr "``|`` 演算子は、引数同士のビット単位の (包含的) OR を与えます。引数は整数でなければなりません。"

#: ../../reference/expressions.rst:1219
msgid "Comparisons"
msgstr "比較"

#: ../../reference/expressions.rst:1225
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""
"C 言語と違って、Python "
"における比較演算子は同じ優先順位をもっており、全ての算術演算子、シフト演算子、ビット単位演算子よりも低くなっています。また ``a < b < c`` "
"が数学で伝統的に用いられているのと同じ解釈になる点も C 言語と違います:"

#: ../../reference/expressions.rst:1235
msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr "比較演算の結果はブール値: ``True`` または ``False`` になります。"

#: ../../reference/expressions.rst:1239
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""
"比較はいくらでも連鎖することができます。例えば ``x < y <= z`` は ``x < y and y <= z`` "
"と等価になります。ただしこの場合、前者では ``y`` はただ一度だけ評価される点が異なります (どちらの場合でも、 ``x < y`` が偽になると "
"``z`` の値はまったく評価されません)。"

#: ../../reference/expressions.rst:1243
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, *op2*, "
"..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN z`` is "
"equivalent to ``a op1 b and b op2 c and ... y opN z``, except that each "
"expression is evaluated at most once."
msgstr ""
"形式的には、 *a*, *b*, *c*, ..., *y*, *z* が式で *op1*, *op2*, ..., *opN* "
"が比較演算子である場合、 ``a op1 b op2 c ... y opN z`` は ``a op1 b and b op2 c and ... y"
" opN z`` と等価になります。ただし、前者では各式は多くても一度しか評価されません。"

#: ../../reference/expressions.rst:1248
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a*"
" and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps "
"not pretty)."
msgstr ""
"``a op1 b op2 c`` と書いた場合、 *a* から *c* までの範囲にあるかどうかのテストを指すのではないことに注意してください。例えば"
" ``x < y > z`` は (きれいな書き方ではありませんが) 完全に正しい文法です。"

#: ../../reference/expressions.rst:1253
msgid "Value comparisons"
msgstr "値の比較"

#: ../../reference/expressions.rst:1255
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects do not need to have the same type."
msgstr ""
"演算子 ``<``, ``>``, ``==``, ``>=``, ``<=``, および ``!=`` は2つのオブジェクトの値を比較します。\n"
"オブジェクトが同じ型を持つ必要はりません。"

#: ../../reference/expressions.rst:1258
msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to type"
" and identity).  The value of an object is a rather abstract notion in "
"Python: For example, there is no canonical access method for an object's "
"value.  Also, there is no requirement that the value of an object should be "
"constructed in a particular way, e.g. comprised of all its data attributes. "
"Comparison operators implement a particular notion of what the value of an "
"object is.  One can think of them as defining the value of an object "
"indirectly, by means of their comparison implementation."
msgstr ""
":ref:`objects` の章では、オブジェクトは (型や id のに加えて) 値を持つことを述べています。\n"
"オブジェクトの値は Python ではやや抽象的な概念です: 例えば、オブジェクトの値にアクセスする正統な方法はありません。\n"
"また、その全てのデータ属性から構成されるなどの特定の方法で、オブジェクトの値を構築する必要性もありません。\n"
"比較演算子は、オブジェクトの値とは何かについての特定の概念を実装しています。\n"
"この比較の実装によって、間接的にオブジェクトの値を定義している考えることもできます。"

#: ../../reference/expressions.rst:1267
msgid ""
"Because all types are (direct or indirect) subtypes of :class:`object`, they"
" inherit the default comparison behavior from :class:`object`.  Types can "
"customize their comparison behavior by implementing :dfn:`rich comparison "
"methods` like :meth:`__lt__`, described in :ref:`customization`."
msgstr ""

#: ../../reference/expressions.rst:1273
msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based on"
" the identity of the objects.  Hence, equality comparison of instances with "
"the same identity results in equality, and equality comparison of instances "
"with different identities results in inequality.  A motivation for this "
"default behavior is the desire that all objects should be reflexive (i.e. "
"``x is y`` implies ``x == y``)."
msgstr ""
"等価性比較 (``==`` および ``!=``) のデフォルトの振る舞いは、オブジェクトの同一性に基づいています。\n"
"従って、同一のインスタンスの等価性比較の結果は等しいとなり、同一でないインスタンスの等価性比較の結果は等しくないとなります。\n"
"デフォルトの振る舞いをこのようにしたのは、全てのオブジェクトを反射的 (reflexive つまり ``x is y`` ならば ``x == y``) なものにしたかったからです。"

#: ../../reference/expressions.rst:1280
msgid ""
"A default order comparison (``<``, ``>``, ``<=``, and ``>=``) is not "
"provided; an attempt raises :exc:`TypeError`.  A motivation for this default"
" behavior is the lack of a similar invariant as for equality."
msgstr ""

#: ../../reference/expressions.rst:1284
msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types "
"will need that have a sensible definition of object value and value-based "
"equality.  Such types will need to customize their comparison behavior, and "
"in fact, a number of built-in types have done that."
msgstr ""
"同一でないインスタンスは常に等価でないとする等価性比較のデフォルトの振る舞いは、型が必要とするオブジェクトの値や値に基づいた等価性の実用的な定義とは対照的に思えるでしょう。\n"
"そのような型では比較の振る舞いをカスタマイズする必要が出てきて、実際にたくさんの組み込み型でそれが行われています。"

#: ../../reference/expressions.rst:1290
msgid ""
"The following list describes the comparison behavior of the most important "
"built-in types."
msgstr "次のリストでは、最重要の組み込み型の比較の振る舞いを解説しています。"

#: ../../reference/expressions.rst:1293
msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard "
"library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can "
"be compared within and across their types, with the restriction that complex"
" numbers do not support order comparison.  Within the limits of the types "
"involved, they compare mathematically (algorithmically) correct without loss"
" of precision."
msgstr ""
"いくつかの組み込みの数値型 (:ref:`typesnumeric`) と標準ライブラリの型 :class:`fractions.Fraction` および :class:`decimal.Decimal` は、同じ型や別の型どうしで比較できますが、複素数では順序比較がサポートされていないという制限があります。\n"
"関わる型の制限の範囲内では、精度のロス無しに数学的に (アルゴリズム的に) 正しい比較が行われます。"

#: ../../reference/expressions.rst:1300
msgid ""
"The not-a-number values :const:`float('NaN')` and :const:`Decimal('NaN')` "
"are special.  They are identical to themselves (``x is x`` is true) but are "
"not equal to themselves (``x == x`` is false).  Additionally, comparing any "
"number to a not-a-number value will return ``False``.  For example, both ``3"
" < float('NaN')`` and ``float('NaN') < 3`` will return ``False``."
msgstr ""

#: ../../reference/expressions.rst:1307
msgid ""
"Binary sequences (instances of :class:`bytes` or :class:`bytearray`) can be "
"compared within and across their types.  They compare lexicographically "
"using the numeric values of their elements."
msgstr ""

#: ../../reference/expressions.rst:1311
msgid ""
"Strings (instances of :class:`str`) compare lexicographically using the "
"numerical Unicode code points (the result of the built-in function "
":func:`ord`) of their characters. [#]_"
msgstr ""

#: ../../reference/expressions.rst:1315
msgid "Strings and binary sequences cannot be directly compared."
msgstr ""

#: ../../reference/expressions.rst:1317
msgid ""
"Sequences (instances of :class:`tuple`, :class:`list`, or :class:`range`) "
"can be compared only within each of their types, with the restriction that "
"ranges do not support order comparison.  Equality comparison across these "
"types results in inequality, and ordering comparison across these types "
"raises :exc:`TypeError`."
msgstr ""

#: ../../reference/expressions.rst:1323
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements, whereby reflexivity of the elements is enforced."
msgstr ""

#: ../../reference/expressions.rst:1326
msgid ""
"In enforcing reflexivity of elements, the comparison of collections assumes "
"that for a collection element ``x``, ``x == x`` is always true.  Based on "
"that assumption, element identity is compared first, and element comparison "
"is performed only for distinct elements.  This approach yields the same "
"result as a strict element comparison would, if the compared elements are "
"reflexive.  For non-reflexive elements, the result is different than for "
"strict element comparison, and may be surprising:  The non-reflexive "
"not-a-number values for example result in the following comparison behavior "
"when used in a list::"
msgstr ""

#: ../../reference/expressions.rst:1344
msgid ""
"Lexicographical comparison between built-in collections works as follows:"
msgstr "組み込みのコレクションどうしの辞書式比較は次のように動作します:"

#: ../../reference/expressions.rst:1346
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal "
"(for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr ""
"比較の結果が等価となる2つのコレクションは、同じ型、同じ長さ、対応する要素どうしの比較の結果が等価でなければなりません (例えば、 ``[1,2] =="
" (1,2)`` は型が同じでないので偽です)。"

#: ../../reference/expressions.rst:1351
msgid ""
"Collections that support order comparison are ordered the same as their "
"first unequal elements (for example, ``[1,2,x] <= [1,2,y]`` has the same "
"value as ``x <= y``).  If a corresponding element does not exist, the "
"shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is "
"true)."
msgstr ""

#: ../../reference/expressions.rst:1357
msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they have"
" equal `(key, value)` pairs. Equality comparison of the keys and values "
"enforces reflexivity."
msgstr ""
"マッピング (:class:`dict` のインスタンス) の比較の結果が等価となるのは、同じ `(key, value)` を持っているときかつそのときに限ります。\n"
"キーと値の等価性比較では反射性が強制されます。"

#: ../../reference/expressions.rst:1361
msgid ""
"Order comparisons (``<``, ``>``, ``<=``, and ``>=``) raise :exc:`TypeError`."
msgstr ""

#: ../../reference/expressions.rst:1363
msgid ""
"Sets (instances of :class:`set` or :class:`frozenset`) can be compared "
"within and across their types."
msgstr ""

#: ../../reference/expressions.rst:1366
msgid ""
"They define order comparison operators to mean subset and superset tests.  "
"Those relations do not define total orderings (for example, the two sets "
"``{1,2}`` and ``{2,3}`` are not equal, nor subsets of one another, nor "
"supersets of one another).  Accordingly, sets are not appropriate arguments "
"for functions which depend on total ordering (for example, :func:`min`, "
":func:`max`, and :func:`sorted` produce undefined results given a list of "
"sets as inputs)."
msgstr ""

#: ../../reference/expressions.rst:1374
msgid "Comparison of sets enforces reflexivity of its elements."
msgstr ""

#: ../../reference/expressions.rst:1376
msgid ""
"Most other built-in types have no comparison methods implemented, so they "
"inherit the default comparison behavior."
msgstr ""

#: ../../reference/expressions.rst:1379
msgid ""
"User-defined classes that customize their comparison behavior should follow "
"some consistency rules, if possible:"
msgstr "比較の振る舞いをカスタマイズしたユーザ定義クラスは、可能なら次の一貫性の規則に従う必要があります:"

#: ../../reference/expressions.rst:1382
msgid ""
"Equality comparison should be reflexive. In other words, identical objects "
"should compare equal:"
msgstr ""
"等価比較は反射的でなければなりません。\n"
"つまり、同一のオブジェクトは等しくなければなりません:"

#: ../../reference/expressions.rst:1385
msgid "``x is y`` implies ``x == y``"
msgstr "``x is y`` は暗黙的に ``x == y``"

#: ../../reference/expressions.rst:1387
msgid ""
"Comparison should be symmetric. In other words, the following expressions "
"should have the same result:"
msgstr ""
"比較は対称でなければなりません。\n"
"つまり、以下の式の結果は同じでなければなりません:"

#: ../../reference/expressions.rst:1390
msgid "``x == y`` and ``y == x``"
msgstr "``x == y`` と ``y == x``"

#: ../../reference/expressions.rst:1392
msgid "``x != y`` and ``y != x``"
msgstr "``x != y`` と ``y != x``"

#: ../../reference/expressions.rst:1394
msgid "``x < y`` and ``y > x``"
msgstr "``x < y`` と ``y > x``"

#: ../../reference/expressions.rst:1396
msgid "``x <= y`` and ``y >= x``"
msgstr "``x <= y`` と ``y >= x``"

#: ../../reference/expressions.rst:1398
msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr ""
"比較は推移的でなければなりません。\n"
"以下の (包括的でない) 例がその説明です:"

#: ../../reference/expressions.rst:1401
msgid "``x > y and y > z`` implies ``x > z``"
msgstr "``x > y and y > z`` は暗黙的に ``x > z``"

#: ../../reference/expressions.rst:1403
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr "``x < y and y <= z`` は暗黙的に ``x < z``"

#: ../../reference/expressions.rst:1405
msgid ""
"Inverse comparison should result in the boolean negation. In other words, "
"the following expressions should have the same result:"
msgstr ""
"比較の逆はブールの否定でなければなりません。\n"
"つまり、以下の式の結果は同じでなければなりません:"

#: ../../reference/expressions.rst:1408
msgid "``x == y`` and ``not x != y``"
msgstr "``x == y`` と ``not x != y``"

#: ../../reference/expressions.rst:1410
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr "``x < y`` と ``not x >= y`` (全順序の場合)"

#: ../../reference/expressions.rst:1412
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr "``x > y`` と ``not x <= y`` (全順序の場合)"

#: ../../reference/expressions.rst:1414
msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the "
":func:`~functools.total_ordering` decorator."
msgstr ""
"最後の2式は全順序の集まりに適用されます (たとえばシーケンスには適用されますがセットやマッピングには適用されません)。\n"
":func:`~functools.total_ordering` デコレータも参照してください。"

#: ../../reference/expressions.rst:1418
msgid ""
"The :func:`hash` result should be consistent with equality. Objects that are"
" equal should either have the same hash value, or be marked as unhashable."
msgstr ""
":func:`hash` の結果は等価性と一貫している必要があります。\n"
"等価なオブジェクトどうしは同じハッシュ値を持つか、ハッシュ値が計算できないものとされる必要があります。"

#: ../../reference/expressions.rst:1422
msgid ""
"Python does not enforce these consistency rules. In fact, the not-a-number "
"values are an example for not following these rules."
msgstr ""

#: ../../reference/expressions.rst:1431
msgid "Membership test operations"
msgstr "帰属検査演算"

#: ../../reference/expressions.rst:1433
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False`` "
"otherwise. ``x not in s`` returns the negation of ``x in s``.  All built-in "
"sequences and set types support this as well as dictionary, for which "
":keyword:`in` tests whether the dictionary has a given key. For container "
"types such as list, tuple, set, frozenset, dict, or collections.deque, the "
"expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""
"演算子 :keyword:`in` および :keyword:`not in` は、帰属 (membership) を調べます。 ``x in s`` "
"の評価は、 *x* が *s* の要素であれば ``True`` となり、そうでなければ ``False`` となります。 ``x not in s``"
" は ``x in s`` の否定 (negation) を返します。すべての組み込みのシーケンスと集合型に加えて、辞書も、 :keyword:`in`"
" を辞書が与えられたキーを持っているかを調べるものとしてサポートしています。リスト、タプル、集合、凍結集合、辞書、あるいは "
"collection.deque のようなコンテナ型について、式 ``x in y`` は ``any(x is e or x == e for e "
"in y)`` と等価です。"

#: ../../reference/expressions.rst:1441
msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x* is"
" a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty "
"strings are always considered to be a substring of any other string, so "
"``\"\" in \"abc\"`` will return ``True``."
msgstr ""
"文字列やバイト列型については、 ``x in y`` は *x* が *y* の部分文字列であるとき、かつそのときに限り ``True`` "
"になります。これは ``y.find(x) != -1`` と等価です。空文字列は、他の任意の文字列の部分文字列とみなされます。従って ``\"\" "
"in \"abc\"`` は ``True`` を返すことになります。"

#: ../../reference/expressions.rst:1446
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, ``x "
"in y`` returns ``True`` if ``y.__contains__(x)`` returns a true value, and "
"``False`` otherwise."
msgstr ""
":meth:`__contains__` メソッドを実装したユーザ定義クラスでは、 ``y.__contains__(x)`` の返り値が真となる場合に"
" ``x in y`` の返り値は ``True`` となり、そうでない場合は ``False`` となります。"

#: ../../reference/expressions.rst:1450
msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is ``True`` if some value ``z`` with ``x"
" == z`` is produced while iterating over ``y``.  If an exception is raised "
"during the iteration, it is as if :keyword:`in` raised that exception."
msgstr ""
":meth:`__contains__` を定義していないが :meth:`__iter__` は定義しているユーザ定義クラスでは、 ``x in "
"y`` は ``x == z`` となるようなある値 `z` が ``y`` 内にわたる反復で生成された場合、 ``True`` "
"となります。もし、反復の間に例外が発生すれば、 :keyword:`in` が例外を発生させたようにみえます。"

#: ../../reference/expressions.rst:1455
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines "
":meth:`__getitem__`, ``x in y`` is ``True`` if and only if there is a non-"
"negative integer index *i* such that ``x == y[i]``, and all lower integer "
"indices do not raise :exc:`IndexError` exception.  (If any other exception "
"is raised, it is as if :keyword:`in` raised that exception)."
msgstr ""

#: ../../reference/expressions.rst:1467
msgid ""
"The operator :keyword:`not in` is defined to have the inverse true value of "
":keyword:`in`."
msgstr "演算子 :keyword:`not in` は :keyword:`in` の真値を反転した値として定義されています。"

#: ../../reference/expressions.rst:1480
msgid "Identity comparisons"
msgstr "同一性の比較"

#: ../../reference/expressions.rst:1482
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for object identity: "
"``x is y`` is true if and only if *x* and *y* are the same object.  Object "
"identity is determined using the :meth:`id` function.  ``x is not y`` yields"
" the inverse truth value. [#]_"
msgstr ""

#: ../../reference/expressions.rst:1494
msgid "Boolean operations"
msgstr "ブール演算 (boolean operation)"

#: ../../reference/expressions.rst:1505
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`__bool__` "
"method."
msgstr ""
"ブール演算のコンテキストや、式が制御フロー文中で使われる際には、以下の値: ``False`` 、 ``None`` すべての型における数値の "
"0、空の文字列、空のコンテナ (文字列、タプル、リスト、辞書、集合、凍結集合など) は偽 (false) であると解釈されます。それ以外の値は真 "
"(true) であると解釈されます。ユーザ定義のメソッドは、 :meth:`__bool__` メソッドを与えることで、真理値をカスタマイズできます。"

#: ../../reference/expressions.rst:1514
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""
"演算子 :keyword:`not` は、引数が偽である場合には ``True`` を、それ以外の場合には ``False`` になります。"

#: ../../reference/expressions.rst:1519
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is "
"returned."
msgstr ""
"式 ``x and y`` は、まず *x* を評価します; *x* が偽なら *x* の値を返します; それ以外の場合には、 *y* "
"の値を評価し、その結果を返します。"

#: ../../reference/expressions.rst:1524
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"式 ``x or y`` は、まず *x* を評価します; *x* が真なら *x* の値を返します; それ以外の場合には、 *y* "
"の値を評価し、その結果を返します。"

#: ../../reference/expressions.rst:1527
msgid ""
"(Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"create a new value, it returns a boolean value regardless of the type of its"
" argument (for example, ``not 'foo'`` produces ``False`` rather than "
"``''``.)"
msgstr ""
"(なお、 :keyword:`and` も :keyword:`or` も、返す値を ``True`` や ``False`` "
"に制限せず、最後に評価した引数を返します。この仕様が便利なこともあり、例えば ``s`` が文字列で、空文字列ならデフォルトの値に置き換えたいとき、式 "
"``s or 'foo'`` は望んだ値を与えます。 :keyword:`not` は引数の型に関係なく、必ずブール値を返すからです。例えば、 "
"``not 'foo'`` は、 ``''`` ではなく ``False`` を与えます。)"

#: ../../reference/expressions.rst:1537
msgid "Conditional expressions"
msgstr "条件式 (Conditional Expressions)"

#: ../../reference/expressions.rst:1548
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr "条件式 (しばしば \"三項演算子\" と呼ばれます) は最も優先度が低いPython の演算です。"

#: ../../reference/expressions.rst:1551
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* rather "
"than *x*. If *C* is true, *x* is evaluated and its value is returned; "
"otherwise, *y* is evaluated and its value is returned."
msgstr ""
"``x if C else y`` という式は最初に条件 *x* ではなく *C* を評価します; *C* が true の場合 *x* "
"が評価され値が返されます; それ以外の場合には *y* が評価され返されます。"

#: ../../reference/expressions.rst:1555
msgid "See :pep:`308` for more details about conditional expressions."
msgstr "条件演算に関してより詳しくは :pep:`308` を参照してください。"

#: ../../reference/expressions.rst:1562
msgid "Lambdas"
msgstr "ラムダ (lambda)"

#: ../../reference/expressions.rst:1573
msgid ""
"Lambda expressions (sometimes called lambda forms) are used to create "
"anonymous functions. The expression ``lambda parameters: expression`` yields"
" a function object.  The unnamed object behaves like a function object "
"defined with:"
msgstr ""

#: ../../reference/expressions.rst:1582
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements or "
"annotations."
msgstr ""
"引数の一覧の構文は :ref:`関数定義 <function>` "
"を参照してください。ラムダ式で作成された関数は文やアノテーションを含むことができない点に注意してください。"

#: ../../reference/expressions.rst:1590
msgid "Expression lists"
msgstr "式のリスト"

#: ../../reference/expressions.rst:1602
msgid ""
"Except when part of a list or set display, an expression list containing at "
"least one comma yields a tuple.  The length of the tuple is the number of "
"expressions in the list.  The expressions are evaluated from left to right."
msgstr ""

#: ../../reference/expressions.rst:1611
msgid ""
"An asterisk ``*`` denotes :dfn:`iterable unpacking`.  Its operand must be an"
" :term:`iterable`.  The iterable is expanded into a sequence of items, which"
" are included in the new tuple, list, or set, at the site of the unpacking."
msgstr ""

#: ../../reference/expressions.rst:1616
msgid ""
"Iterable unpacking in expression lists, originally proposed by :pep:`448`."
msgstr ""

#: ../../reference/expressions.rst:1621
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the value"
" of that expression. (To create an empty tuple, use an empty pair of "
"parentheses: ``()``.)"
msgstr ""
"単一要素のタプル (別名 *単集合 (singleton)* ) "
"を作りたければ、末尾にカンマが必要です。単一の式だけで、末尾にカンマをつけない場合には、タプルではなくその式の値になります "
"(空のタプルを作りたいなら、中身が空の丸括弧ペア: ``()`` を使います。)"

#: ../../reference/expressions.rst:1631
msgid "Evaluation order"
msgstr "評価順序"

#: ../../reference/expressions.rst:1635
msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""
"Python は、式を左から右へと順に評価します。\n"
"ただし、代入式を評価するときは、右辺が左辺よりも先に評価されます。"

#: ../../reference/expressions.rst:1638
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr "以下に示す実行文の各行での評価順序は、添え字の数字順序と同じになります::"

#: ../../reference/expressions.rst:1652
msgid "Operator precedence"
msgstr "演算子の優先順位"

#: ../../reference/expressions.rst:1656
msgid ""
"The following table summarizes the operator precedence in Python, from "
"lowest precedence (least binding) to highest precedence (most binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for exponentiation, which groups from right to left)."
msgstr ""
"以下の表は Python における演算子の優先順位を要約したものです。優先順位の最も低い (結合が最も弱い) ものから最も高い (結合が最も強い) "
"ものに並べてあります。同じボックス内の演算子の優先順位は同じです。構文が明示的に示されていないものは二項演算子です。同じボックス内の演算子は、左から右へとグループ化されます"
" (例外として、べき乗は右から左にグループ化されます)。"

#: ../../reference/expressions.rst:1662
msgid ""
"Note that comparisons, membership tests, and identity tests, all have the "
"same precedence and have a left-to-right chaining feature as described in "
"the :ref:`comparisons` section."
msgstr ""
":ref:`comparisons` "
"節で述べられているように、比較、帰属、同一性のテストは全てが同じ優先順位を持っていて、左から右に連鎖するという特徴を持っていることに注意してください。"

#: ../../reference/expressions.rst:1668
msgid "Operator"
msgstr "演算子"

#: ../../reference/expressions.rst:1668
msgid "Description"
msgstr "説明"

#: ../../reference/expressions.rst:1670
msgid ":keyword:`lambda`"
msgstr ":keyword:`lambda`"

#: ../../reference/expressions.rst:1670
msgid "Lambda expression"
msgstr "ラムダ式"

#: ../../reference/expressions.rst:1672
msgid ":keyword:`if` -- :keyword:`else`"
msgstr ":keyword:`if` -- :keyword:`else`"

#: ../../reference/expressions.rst:1672
msgid "Conditional expression"
msgstr "条件式"

#: ../../reference/expressions.rst:1674
msgid ":keyword:`or`"
msgstr ":keyword:`or`"

#: ../../reference/expressions.rst:1674
msgid "Boolean OR"
msgstr "ブール演算 OR"

#: ../../reference/expressions.rst:1676
msgid ":keyword:`and`"
msgstr ":keyword:`and`"

#: ../../reference/expressions.rst:1676
msgid "Boolean AND"
msgstr "ブール演算 AND"

#: ../../reference/expressions.rst:1678
msgid ":keyword:`not` ``x``"
msgstr ":keyword:`not` ``x``"

#: ../../reference/expressions.rst:1678
msgid "Boolean NOT"
msgstr "ブール演算 NOT"

#: ../../reference/expressions.rst:1680
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"

#: ../../reference/expressions.rst:1680
msgid "Comparisons, including membership tests and identity tests"
msgstr "帰属や同一性のテストを含む比較"

#: ../../reference/expressions.rst:1684
msgid "``|``"
msgstr "``|``"

#: ../../reference/expressions.rst:1684
msgid "Bitwise OR"
msgstr "ビット単位 OR"

#: ../../reference/expressions.rst:1686
msgid "``^``"
msgstr "``^``"

#: ../../reference/expressions.rst:1686
msgid "Bitwise XOR"
msgstr "ビット単位 XOR"

#: ../../reference/expressions.rst:1688
msgid "``&``"
msgstr "``&``"

#: ../../reference/expressions.rst:1688
msgid "Bitwise AND"
msgstr "ビット単位 AND"

#: ../../reference/expressions.rst:1690
msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

#: ../../reference/expressions.rst:1690
msgid "Shifts"
msgstr "シフト演算"

#: ../../reference/expressions.rst:1692
msgid "``+``, ``-``"
msgstr "``+``, ``-``"

#: ../../reference/expressions.rst:1692
msgid "Addition and subtraction"
msgstr "加算および減算"

#: ../../reference/expressions.rst:1694
msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr "``*``, ``@``, ``/``, ``//``, ``%``"

#: ../../reference/expressions.rst:1694
msgid ""
"Multiplication, matrix multiplication, division, floor division, remainder "
"[#]_"
msgstr ""

#: ../../reference/expressions.rst:1698
msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

#: ../../reference/expressions.rst:1698
msgid "Positive, negative, bitwise NOT"
msgstr "正数、負数、ビット単位 NOT"

#: ../../reference/expressions.rst:1700
msgid "``**``"
msgstr "``**``"

#: ../../reference/expressions.rst:1700
msgid "Exponentiation [#]_"
msgstr "べき乗 [#]_"

#: ../../reference/expressions.rst:1702
msgid "``await`` ``x``"
msgstr "``await`` ``x``"

#: ../../reference/expressions.rst:1704
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr ""
"``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"

#: ../../reference/expressions.rst:1704
msgid "Subscription, slicing, call, attribute reference"
msgstr "添字指定、スライス操作、呼び出し、属性参照"

#: ../../reference/expressions.rst:1707
msgid ""
"``(expressions...)``, ``[expressions...]``, ``{key: value...}``, "
"``{expressions...}``"
msgstr ""
"``(expressions...)``, ``[expressions...]``, ``{key: value...}``, "
"``{expressions...}``"

#: ../../reference/expressions.rst:1707
msgid ""
"Binding or tuple display, list display, dictionary display, set display"
msgstr "式結合またはタプル表示、リスト表示、辞書表示、集合表示"

#: ../../reference/expressions.rst:1715
msgid "Footnotes"
msgstr "脚注"

#: ../../reference/expressions.rst:1716
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be"
" true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""
"``abs(x%y) < abs(y)`` は数学的には真となりますが、浮動小数点に対する演算の場合には、値丸め (roundoff) "
"のために数値計算的に真にならない場合があります。例えば、Python の浮動小数点型が IEEE754 "
"倍精度数型になっているプラットフォームを仮定すると、 ``-1e-100 % 1e100`` は ``1e100`` "
"と同じ符号になるはずなのに、計算結果は ``-1e-100 + 1e100`` となります。これは数値計算的には厳密に ``1e100`` "
"と等価です。関数 :func:`math.fmod` は、最初の引数と符号が一致するような値を返すので、上記の場合には ``-1e-100`` "
"を返します。どちらのアプローチが適切かは、アプリケーションに依存します。"

#: ../../reference/expressions.rst:1725
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for "
"``x//y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such "
"cases, Python returns the latter result, in order to preserve that "
"``divmod(x,y)[0] * y + x % y`` be very close to ``x``."
msgstr ""
"x が y の正確な整数倍に非常に近いと、丸めのために ``x//y`` が ``(x-x%y)//y`` よりも 1 "
"だけ大きくなる可能性があります。そのような場合、Python は ``divmod(x,y)[0] * y + x % y`` が ``x`` "
"に非常に近くなるという関係を保つために、後者の値を返します。"

#: ../../reference/expressions.rst:1730
msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) "
"and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most"
" abstract characters in Unicode are only represented using one code point, "
"there is a number of abstract characters that can in addition be represented"
" using a sequence of more than one code point.  For example, the abstract "
"character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a "
"single :dfn:`precomposed character` at code position U+00C7, or as a "
"sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL "
"LETTER C), followed by a :dfn:`combining character` at code position U+0327 "
"(COMBINING CEDILLA)."
msgstr ""
"Unicode 標準では、 :dfn:`コードポイント (code point)` (例えば、U+0041) と :dfn:`抽象文字 (abstract character)` (例えば、\"LATIN CAPITAL LETTER A\") を区別します。\n"
"Unicode のほとんどの抽象文字は 1 つのコードポイントだけを使って表現されますが、複数のコードポイントの列を使っても表現できる抽象文字もたくさんあります。\n"
"例えば、抽象文字 \"LATIN CAPITAL LETTER C WITH CEDILLA\" はコード位置 U+00C7 にある :dfn:`合成済み文字 (precomposed character)` 1 つだけでも表現できますし、コード位置 U+0043 (LATIN CAPITAL LETTER C) にある :dfn:`基底文字 (base character)` の後ろに、コード位置 U+0327 (COMBINING CEDILLA) にある :dfn:`結合文字 (combining character)` が続く列としても表現できます。"

#: ../../reference/expressions.rst:1741
msgid ""
"The comparison operators on strings compare at the level of Unicode code "
"points. This may be counter-intuitive to humans.  For example, ``\"\\u00C7\""
" == \"\\u0043\\u0327\"`` is ``False``, even though both strings represent "
"the same abstract character \"LATIN CAPITAL LETTER C WITH CEDILLA\"."
msgstr ""

#: ../../reference/expressions.rst:1746
msgid ""
"To compare strings at the level of abstract characters (that is, in a way "
"intuitive to humans), use :func:`unicodedata.normalize`."
msgstr ""
"抽象文字のレベルで (つまり、人間にとって直感的な方法で) 文字列を比較するには :func:`unicodedata.normalize` "
"を使ってください。"

#: ../../reference/expressions.rst:1749
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""
"自動的なガベージコレクション、フリーリスト、ディスクリプタの動的特性のために、インスタンスメソッドや定数の比較を行うようなときに "
":keyword:`is` 演算子の利用は、一見すると普通ではない振る舞いだと気付くかもしれません。詳細はそれぞれのドキュメントを確認してください。"

#: ../../reference/expressions.rst:1754
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr "``%`` 演算子は文字列フォーマットにも使われ、同じ優先順位が当てはまります。"

#: ../../reference/expressions.rst:1757
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""
"べき乗演算子 ``**`` はその右側にある単項演算子かビット単位演算子よりも優先して結合します。つまり ``2**-1`` は ``0.5`` "
"になります。"
