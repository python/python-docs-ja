# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Yuto Horiuchi <hotz07ggl@gmail.com>, 2017
# Osamu NAKAMURA, 2017
# KAMIYA Ayako <sleepybonbon@gmail.com>, 2017
# Arihiro TAKASE, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2017
# tomo, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 12:40+0000\n"
"PO-Revision-Date: 2017-02-16 23:42+0000\n"
"Last-Translator: tomo, 2020\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.1.rst:3
msgid "What's New in Python 2.1"
msgstr "What's New in Python 2.1"

#: ../../whatsnew/2.1.rst:0
msgid "Author"
msgstr "著者"

#: ../../whatsnew/2.1.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.1.rst:13
msgid "Introduction"
msgstr "はじめに"

#: ../../whatsnew/2.1.rst:15
msgid ""
"This article explains the new features in Python 2.1.  While there aren't as"
" many changes in 2.1 as there were in Python 2.0, there are still some "
"pleasant surprises in store.  2.1 is the first release to be steered through"
" the use of Python Enhancement Proposals, or PEPs, so most of the sizable "
"changes have accompanying PEPs that provide more complete documentation and "
"a design rationale for the change.  This article doesn't attempt to document"
" the new features completely, but simply provides an overview of the new "
"features for Python programmers. Refer to the Python 2.1 documentation, or "
"to the specific PEP, for more details about any new feature that "
"particularly interests you."
msgstr ""
"この記事はPython 2.1の新機能について説明します。Python 2.1には Python "
"2.0ほど多くの変更点はありませんが、楽しい驚きがあります。2.1はPythonの拡張計画（PEP）を使い動かす最初のリリースであり、大きい変更点のほとんどは、より詳細なドキュメントや変更のための設計原理を提供するPEPに付随しています。この記事は新機能について網羅していませんが、Pythonプログラマのための新機能について概要を示します。特に興味のある任意の新機能の詳細については、Python"
" 2.1ドキュメントか特定のPEPを参照してください。"

#: ../../whatsnew/2.1.rst:25
msgid ""
"One recent goal of the Python development team has been to accelerate the "
"pace of new releases, with a new release coming every 6 to 9 months. 2.1 is "
"the first release to come out at this faster pace, with the first alpha "
"appearing in January, 3 months after the final version of 2.0 was released."
msgstr ""
"Python開発チームの最近の目標の一つとして新しいリリースのペースを上げており、一つのリリースにつき6～9ヶ月ごとにリリースしています。2.1はこの速いペースになって出てきた最初のリリースで、初のアルファ版は、2.0の最終版がリリースされた3ヶ月後の1月に登場しました。"

#: ../../whatsnew/2.1.rst:30
msgid "The final release of Python 2.1 was made on April 17, 2001."
msgstr "Python 2.1の最終版は2001年4月17日に作成されました。"

#: ../../whatsnew/2.1.rst:36
msgid "PEP 227: Nested Scopes"
msgstr "PEP 227: 入れ子状のスコープ"

#: ../../whatsnew/2.1.rst:38
msgid ""
"The largest change in Python 2.1 is to Python's scoping rules.  In Python "
"2.0, at any given time there are at most three namespaces used to look up "
"variable names: local, module-level, and the built-in namespace.  This often"
" surprised people because it didn't match their intuitive expectations.  For"
" example, a nested recursive function definition doesn't work::"
msgstr ""
"Python2.1における最も大きな変更点はPythonのスコープルールです。Python2.0では、ある指定された時点である変数の名前を検索するために多くても3つの名前空間、つまりローカル、モジュールレベル、ビルトイン名前空間しか使われませんでした。このことは直感的な期待と一致せずしばしば人々を驚かせました。例えば、入れ子になった再帰関数の定義は動きません::"

#: ../../whatsnew/2.1.rst:51
msgid ""
"The function :func:`g` will always raise a :exc:`NameError` exception, "
"because the binding of the name ``g`` isn't in either its local namespace or"
" in the module-level namespace.  This isn't much of a problem in practice "
"(how often do you recursively define interior functions like this?), but "
"this also made using the :keyword:`lambda` expression clumsier, and this was"
" a problem in practice. In code which uses :keyword:`lambda` you can often "
"find local variables being copied by passing them as the default values of "
"arguments. ::"
msgstr ""
"名前 ``g`` はローカルの名前空間にもモジュールレベルの名前空間にも紐付かないので、関数 :func:`g` は常に "
":exc:`NameError` 例外を上げます。これは実際には大した問題ではありません "
"(このような内部関数を再帰的に定義する頻度はそう多くありません)が、 :keyword:`lambda` "
"式をより使いにくくするのでこれについては問題です。 :keyword:`lambda` "
"を使うコードにおいて、デフォルトの引数としてこれらを渡してコピーされるローカル変数を頻繁に見かけます。::"

#: ../../whatsnew/2.1.rst:65
msgid ""
"The readability of Python code written in a strongly functional style "
"suffers greatly as a result."
msgstr "過度な関数型スタイルで書かれた Python コードの可読性は、結果的にはひどく苦痛を感じるものですね。"

#: ../../whatsnew/2.1.rst:68
msgid ""
"The most significant change to Python 2.1 is that static scoping has been "
"added to the language to fix this problem.  As a first effect, the "
"``name=name`` default argument is now unnecessary in the above example.  Put"
" simply, when a given variable name is not assigned a value within a "
"function (by an assignment, or the :keyword:`def`, :keyword:`class`, or "
":keyword:`import` statements), references to the variable will be looked up "
"in the local namespace of the enclosing scope.  A more detailed explanation "
"of the rules, and a dissection of the implementation, can be found in the "
"PEP."
msgstr ""
"Python 2.1の最も重要な変更点は、この問題を解決するために静的なスコープが追加されたことです。最初の効果として、``name=name`` "
"という例ではデフォルトの引数は必要ありません。簡単に言えば、指定された引数名が関数内の値に割り当てられない場合(:keyword:`def`、:keyword:`class`"
" または :keyword:`import` "
"ステートメントの割り当てによって)、変数の参照は外側のスコープのローカル名前空間で検索されます。ルールや実装の詳細はPEPで参照できます。"

#: ../../whatsnew/2.1.rst:77
msgid ""
"This change may cause some compatibility problems for code where the same "
"variable name is used both at the module level and as a local variable "
"within a function that contains further function definitions. This seems "
"rather unlikely though, since such code would have been pretty confusing to "
"read in the first place."
msgstr ""
"この変更は、同じ変数名がモジュールレベルと関数の定義が含まれている関数内のローカルの両方で変数名として使用されているコードで、互換性の問題を引き起こす可能性があります。ですがむしろ気にしなくてよいでしょう。そのようなコードはそもそも最初から相当こんがらかっているので。"

#: ../../whatsnew/2.1.rst:83
msgid ""
"One side effect of the change is that the ``from module import *`` and "
"``exec`` statements have been made illegal inside a function scope under "
"certain conditions.  The Python reference manual has said all along that "
"``from module import *`` is only legal at the top level of a module, but the"
" CPython interpreter has never enforced this before.  As part of the "
"implementation of nested scopes, the compiler which turns Python source into"
" bytecodes has to generate different code to access variables in a "
"containing scope.  ``from module import *`` and ``exec`` make it impossible "
"for the compiler to figure this out, because they add names to the local "
"namespace that are unknowable at compile time. Therefore, if a function "
"contains function definitions or :keyword:`lambda` expressions with free "
"variables, the compiler will flag this by raising a :exc:`SyntaxError` "
"exception."
msgstr ""
"この変更の副作用の一つは、 ``from module import *`` と ``exec`` "
"の両ステートメントが特定の条件下の関数スコープ内で不正となることです。 Python のリファレンスマニュアルははじめからずっと ``from "
"module import *`` はトップレベルモジュールでのみ合法であると言ってきましたが、以前の CPython "
"インタプリタはこれを一度も強制していませんでした。入れ子になったスコープ実装の一環として、Python "
"のソースをバイトコードに変換するコンパイラは、内包されたスコープ内の変数にアクセスするために別のコードを生成する必要があります。 ``from "
"module import *``, ``exec`` "
"はコンパイラにこれを理解することを不可能にしてしまいます。なぜならそれらはコンパイル時にはわからないローカル名前空間に名前を追加するからです。それゆえ、もし関数が関数定義を含んだり自由な変数に"
" :keyword:`lambda` の語句を含んだりする場合、コンパイラは :exc:`SyntaxError` 例外を上げて知らせます。"

#: ../../whatsnew/2.1.rst:96
msgid "To make the preceding explanation a bit clearer, here's an example::"
msgstr "前述した説明を少し明確にするため、例を挙げます::"

#: ../../whatsnew/2.1.rst:105
msgid ""
"Line 4 containing the ``exec`` statement is a syntax error, since ``exec`` "
"would define a new local variable named ``x`` whose value should be accessed"
" by :func:`g`."
msgstr ""
"``exec`` 文を含む 4 行目は文法エラーです。 ``exec`` としては新しいローカル変数 ``x`` を定義したいのですが、これは "
":func:`g` からアクセスされなければなりません。"

#: ../../whatsnew/2.1.rst:109
msgid ""
"This shouldn't be much of a limitation, since ``exec`` is rarely used in "
"most Python code (and when it is used, it's often a sign of a poor design "
"anyway)."
msgstr ""
"これは実際には大した制約でもないはずです。 ``exec`` が Python "
"コードで使われるのは稀です(使われているとしたら大抵どこか貧弱な設計であることの証)。"

#: ../../whatsnew/2.1.rst:113
msgid ""
"Compatibility concerns have led to nested scopes being introduced gradually;"
" in Python 2.1, they aren't enabled by default, but can be turned on within "
"a module by using a future statement as described in :pep:`236`.  (See the "
"following section for further discussion of :pep:`236`.)  In Python 2.2, "
"nested scopes will become the default and there will be no way to turn them "
"off, but users will have had all of 2.1's lifetime to fix any breakage "
"resulting from their introduction."
msgstr ""
"互換性の問題が考慮されて、入れ子のスコープは段階的導入につながりました; Python 2.1 ではそれらはデフォルトで有効になっていませんが、 "
":pep:`236` に記載されているように、future 文を使用してモジュール内でオンにすることができます。(:pep:`236` "
"の更なる議論について、続くセクションを参照してください。) Python "
"2.2では入れ子になったスコープがデフォルトになり、それをオフにする方法はありませんが、ユーザは 2.1 "
"の全ライフタイムを通して、導入の結果起きるあらゆる破損を修正し続けるでしょう。"

#: ../../whatsnew/2.1.rst:123
msgid ":pep:`227` - Statically Nested Scopes"
msgstr ":pep:`227` - 静的に入れ子になったスコープ"

#: ../../whatsnew/2.1.rst:124
msgid "Written and implemented by Jeremy Hylton."
msgstr "Jeremy Hylton著、実装"

#: ../../whatsnew/2.1.rst:130
msgid "PEP 236: __future__ Directives"
msgstr "PEP 236: __future__ 指示文"

#: ../../whatsnew/2.1.rst:132
msgid ""
"The reaction to nested scopes was widespread concern about the dangers of "
"breaking code with the 2.1 release, and it was strong enough to make the "
"Pythoneers take a more conservative approach.  This approach consists of "
"introducing a convention for enabling optional functionality in release N "
"that will become compulsory in release N+1."
msgstr ""
"ネストされたスコープへのこの対応は、リリース 2.1 ではコードを壊すことの危険性について広く懸念されており、  Pythoneer "
"達に保守的なアプローチを選ばせるには十分でした。このアプローチは、必須とするリリース N+1 に対する、 リリース N "
"でのオプション機能として有効化という序奏、というものです。"

#: ../../whatsnew/2.1.rst:138
msgid ""
"The syntax uses a ``from...import`` statement using the reserved module name"
" :mod:`__future__`.  Nested scopes can be enabled by the following "
"statement::"
msgstr ""
"この構文は :mod:`__future__` という名の予約モジュールを使う ``from...import`` "
"ステートメントを使用します。ネストしたスコープは以下のステートメントで有効にできます。"

#: ../../whatsnew/2.1.rst:143
msgid ""
"While it looks like a normal :keyword:`import` statement, it's not; there "
"are strict rules on where such a future statement can be put. They can only "
"be at the top of a module, and must precede any Python code or regular "
":keyword:`!import` statements.  This is because such statements can affect "
"how the Python bytecode compiler parses code and generates bytecode, so they"
" must precede any statement that will result in bytecodes being produced."
msgstr ""
"普通 の :keyword:`import` ステートメントに見えますが、実は違います; "
"このような未来のステートメントが置かれる場所には厳格なルールがあります。これらはモジュールの冒頭にしか置けませんし、必ず何らかのPythonコードや正規の"
" :keyword:`!import` "
"ステートメントの前になければなりません。それと言うのもこのようなステートメントは、Pythonのバイトコードコンパイラがコードを解析し、バイトコードを生成する方法に影響しますので、生成されるバイトコードとなるステートメントの前になくてはならないのです。"

#: ../../whatsnew/2.1.rst:153
msgid ":pep:`236` - Back to the :mod:`__future__`"
msgstr ":pep:`236` - バック・トゥ・ザ・ :mod:`__future__` "

#: ../../whatsnew/2.1.rst:154
msgid "Written by Tim Peters, and primarily implemented by Jeremy Hylton."
msgstr "Tim Peter著、Jeremy Hylton主実装"

#: ../../whatsnew/2.1.rst:160
msgid "PEP 207: Rich Comparisons"
msgstr "PEP 207: 拡張比較"

#: ../../whatsnew/2.1.rst:162
msgid ""
"In earlier versions, Python's support for implementing comparisons on user-"
"defined classes and extension types was quite simple. Classes could "
"implement a :meth:`__cmp__` method that was given two instances of a class, "
"and could only return 0 if they were equal or +1 or -1 if they weren't; the "
"method couldn't raise an exception or return anything other than a Boolean "
"value.  Users of Numeric Python often found this model too weak and "
"restrictive, because in the number-crunching programs that numeric Python is"
" used for, it would be more useful to be able to perform elementwise "
"comparisons of two matrices, returning a matrix containing the results of a "
"given comparison for each element.  If the two matrices are of different "
"sizes, then the compare has to be able to raise an exception to signal the "
"error."
msgstr ""
"以前のバージョンでは、ユーザ定義クラスや拡張型の比較を実装するための Python のサポートはとても単純なものでした。クラスは 2 "
"つのインスタンスを与えられる :meth:`__cmp__` メソッドを実装でき、実際の値がどうあれ、同値の場合には 0 、そうでないなら +1 か "
"-1 を返せるだけでした; メソッドは例外を上げることも、ブール値以外のものを返すこともできませんでした。Numeric Python "
"が使われるような複雑な計算プログラムでは、要素ごとに与えられた比較結果を含む行列を返し、2 "
"つの行列を要素単位で比較できることがより便利なので、Numeric Python "
"のユーザはこのモデルがとても脆弱で限定的であることにしばしば気付きました。もし 2 "
"つの行列サイズが異なる場合、この比較はエラー通知の例外を上げられなければなりません。"

#: ../../whatsnew/2.1.rst:174
msgid ""
"In Python 2.1, rich comparisons were added in order to support this need. "
"Python classes can now individually overload each of the ``<``, ``<=``, "
"``>``, ``>=``, ``==``, and ``!=`` operations.  The new magic method names "
"are:"
msgstr ""
"Python2.1で、このニーズを満たすために拡張比較が追加されました。Pythonのクラスは、``<``、``<=``、``>``、``>=``、``==``、``!=``"
" の各演算を個別にオーバーロードできます。この新しい特殊メソッドの名前は:"

#: ../../whatsnew/2.1.rst:179
msgid "Operation"
msgstr "演算"

#: ../../whatsnew/2.1.rst:179
msgid "Method name"
msgstr "メソッド名"

#: ../../whatsnew/2.1.rst:181
msgid "``<``"
msgstr "``<``"

#: ../../whatsnew/2.1.rst:181
msgid ":meth:`__lt__`"
msgstr ":meth:`__lt__`"

#: ../../whatsnew/2.1.rst:183
msgid "``<=``"
msgstr "``<=``"

#: ../../whatsnew/2.1.rst:183
msgid ":meth:`__le__`"
msgstr ":meth:`__le__`"

#: ../../whatsnew/2.1.rst:185
msgid "``>``"
msgstr "``>``"

#: ../../whatsnew/2.1.rst:185
msgid ":meth:`__gt__`"
msgstr ":meth:`__gt__`"

#: ../../whatsnew/2.1.rst:187
msgid "``>=``"
msgstr "``>=``"

#: ../../whatsnew/2.1.rst:187
msgid ":meth:`__ge__`"
msgstr ":meth:`__ge__`"

#: ../../whatsnew/2.1.rst:189
msgid "``==``"
msgstr "``==``"

#: ../../whatsnew/2.1.rst:189
msgid ":meth:`__eq__`"
msgstr ":meth:`__eq__`"

#: ../../whatsnew/2.1.rst:191
msgid "``!=``"
msgstr "``!=``"

#: ../../whatsnew/2.1.rst:191
msgid ":meth:`__ne__`"
msgstr ":meth:`__ne__`"

#: ../../whatsnew/2.1.rst:194
msgid ""
"(The magic methods are named after the corresponding Fortran operators "
"``.LT.``. ``.LE.``, &c.  Numeric programmers are almost certainly quite "
"familiar with these names and will find them easy to remember.)"
msgstr ""
"(特殊メソッドはFortranの ``.LT.`` や ``.LE.`` "
"等々の演算子にちなんで命名されています。プログラマはほぼ確実にこれらの名前を熟知していますので、覚えやすいでしょう。)"

#: ../../whatsnew/2.1.rst:198
msgid ""
"Each of these magic methods is of the form ``method(self, other)``, where "
"``self`` will be the object on the left-hand side of the operator, while "
"``other`` will be the object on the right-hand side.  For example, the "
"expression ``A < B`` will cause ``A.__lt__(B)`` to be called."
msgstr ""
"これらの特殊メソッドは ``method(self, other)`` の形式になっており、``self`` が演算子の左辺、``other`` "
"が右辺のオブジェクトになります。例えば、式 ``A < B`` は ``A.__lt__(B)`` を呼び出します。"

#: ../../whatsnew/2.1.rst:203
msgid ""
"Each of these magic methods can return anything at all: a Boolean, a matrix,"
" a list, or any other Python object.  Alternatively they can raise an "
"exception if the comparison is impossible, inconsistent, or otherwise "
"meaningless."
msgstr ""
"これらの特殊メソッドは何でも、つまり真偽値や行列、リストや他のPython "
"オブジェクトを返せます。もし比較が不可能であったり、矛盾していたり、意味がない場合は、代わりに例外を上げることができます。"

#: ../../whatsnew/2.1.rst:207
msgid ""
"The built-in ``cmp(A,B)`` function can use the rich comparison machinery, "
"and now accepts an optional argument specifying which comparison operation "
"to use; this is given as one of the strings ``\"<\"``, ``\"<=\"``, "
"``\">\"``, ``\">=\"``, ``\"==\"``, or ``\"!=\"``.  If called without the "
"optional third argument, :func:`cmp` will only return -1, 0, or +1 as in "
"previous versions of Python; otherwise it will call the appropriate method "
"and can return any Python object."
msgstr ""
"ビルトインの :func:`cmp(A,B)` "
"関数は拡張比較機構を利用出来、使用する比較演算を指定する省略可能引数を受け付けるようになっています。指定には文字列 ``\"<\"``, "
"``\"<=\"``, ``\">\"``, ``\">=\"``, ``\"==\"``, or ``\"!=\"`` "
"のいずれか一つを渡します。省略可能のその 3 番目引数が省略されて呼ばれれば、 :func:`cmp` は以前のバージョンの Python のように "
"-1, 0, または +1 だけを返します; 指定されれば、それはその適切なメソッドを呼び出し、任意の Python オブジェクトを返せます。(訳注: "
"2015年の今となって、ここに書かれている cmp の仕様が実在したのか不明な状態になっている。ビルトインの cmp "
"リファレンスにはこれに関係する履歴は書かれていない。What's New を 2.7 まで追いかけても以後変更された記録はない。)"

#: ../../whatsnew/2.1.rst:214
msgid ""
"There are also corresponding changes of interest to C programmers; there's a"
" new slot ``tp_richcmp`` in type objects and an API for performing a given "
"rich comparison.  I won't cover the C API here, but will refer you to "
":pep:`207`, or to 2.1's C API documentation, for the full list of related "
"functions."
msgstr ""
"C プログラマにとって興味深い関連する変更があります。型オブジェクトに新しい ``tp_richcmp`` "
"スロットと、この拡張された比較を行うAPIが追加されました。ここではC APIについて言及しませんが、あながた関連する関数のリストを見たければ、 "
":pep:`207` かバージョン2.1のC APIドキュメントを参照してください。"

#: ../../whatsnew/2.1.rst:223
msgid ":pep:`207` - Rich Comparisons"
msgstr ":pep:`207`: 拡張比較"

#: ../../whatsnew/2.1.rst:223
msgid ""
"Written by Guido van Rossum, heavily based on earlier work by David Ascher, "
"and implemented by Guido van Rossum."
msgstr "David Ascher によるかつての仕事に大きく拠りますが  Guido van Rossum によって著され、実装されました。"

#: ../../whatsnew/2.1.rst:230
msgid "PEP 230: Warning Framework"
msgstr "PEP 230: 警告フレームワーク"

#: ../../whatsnew/2.1.rst:232
msgid ""
"Over its 10 years of existence, Python has accumulated a certain number of "
"obsolete modules and features along the way.  It's difficult to know when a "
"feature is safe to remove, since there's no way of knowing how much code "
"uses it --- perhaps no programs depend on the feature, or perhaps many do.  "
"To enable removing old features in a more structured way, a warning "
"framework was added. When the Python developers want to get rid of a "
"feature, it will first trigger a warning in the next version of Python.  The"
" following Python version can then drop the feature, and users will have had"
" a full release cycle to remove uses of the old feature."
msgstr ""
"10 年の間に、Python "
"は途中で廃止されたモジュールと機能の特定の番号を蓄積してきました。どれだけのコードが活用されているか知る術はないので、機能を削除して問題ないか把握することは困難です。その機能に依存するプログラムは一つもないかもしれませんし、たくさんあるかもしれません。より構造化された方法で古い機能を削除できるようにするために、警告のフレームワークが追加されました。Python"
" の開発者がある機能を取り除きたいときは、まずは Python の次のバージョンで警告を引き起こします。続く Python "
"バージョンで開発者はその機能を削除出来、ユーザは古い機能の使用を取り除くために Python リリースサイクル一つ丸々使えます。"

#: ../../whatsnew/2.1.rst:242
msgid ""
"Python 2.1 adds the warning framework to be used in this scheme.  It adds a "
":mod:`warnings` module that provide functions to issue warnings, and to "
"filter out warnings that you don't want to be displayed. Third-party modules"
" can also use this framework to deprecate old features that they no longer "
"wish to support."
msgstr ""
"Python 2.1 はこのスキームで使われる警告フレームワークを追加します。また、警告の表示機能や表示させたくない警告を除外する機能を提供する、 "
":mod:`warnings` "
"モジュールを追加します。サードパーティーのモジュールはまた、彼らがサポート対象外にしたい古い機能を非推奨と知らしめるのにこのフレームワークを利用できます。"

#: ../../whatsnew/2.1.rst:248
msgid ""
"For example, in Python 2.1 the :mod:`regex` module is deprecated, so "
"importing it causes a warning to be printed::"
msgstr "例えば、Python2.1では :mod:`regex` モジュールは廃止されたので、これをインポートすると警告が表示されます::"

#: ../../whatsnew/2.1.rst:256
msgid "Warnings can be issued by calling the :func:`warnings.warn` function::"
msgstr "警告は :func:`warnings.warn` 関数を呼び出すことで発行できます::"

#: ../../whatsnew/2.1.rst:260
msgid ""
"The first parameter is the warning message; an additional optional "
"parameters can be used to specify a particular warning category."
msgstr "最初のパラメータは警告メッセージです。任意追加のパラメータは、特定の警告カテゴリを指定するために利用することができます。"

#: ../../whatsnew/2.1.rst:263
msgid ""
"Filters can be added to disable certain warnings; a regular expression "
"pattern can be applied to the message or to the module name in order to "
"suppress a warning.  For example, you may have a program that uses the "
":mod:`regex` module and not want to spare the time to convert it to use the "
":mod:`re` module right now.  The warning can be suppressed by calling ::"
msgstr ""
"特定の警告を無効にするためにフィルターを追加できます。また警告を抑止するためにメッセージまたはモジュール名に正規表現が適用できます。例えば "
":mod:`regex` モジュールを使ったプログラムで、今すぐには :mod:`re` "
"モジュールに変換する時間をかけられないプログラムがあるとします。警告は以下呼び出しにより抑制できます::"

#: ../../whatsnew/2.1.rst:275
msgid ""
"This adds a filter that will apply only to warnings of the class "
":class:`DeprecationWarning` triggered in the :mod:`__main__` module, and "
"applies a regular expression to only match the message about the "
":mod:`regex` module being deprecated, and will cause such warnings to be "
"ignored.  Warnings can also be printed only once, printed every time the "
"offending code is executed, or turned into exceptions that will cause the "
"program to stop (unless the exceptions are caught in the usual way, of "
"course)."
msgstr ""
"これは :mod:`__main__` モジュール内で引き起こされた :class:`DeprecationWarning` 警告だけに適用され、 "
":mod:`regex` "
"モジュールが非推奨となったことについてのメッセージにマッチする正規表現を適用するフィルタを追加し、そして結果としてそのような警告は無視されることになります。警告を一回きりの表示にしたり、違反コードが実行されるたびに表示したり、警告ではなく例外に切り替えてプログラム停止することも出来ます(例外が普通の方法で捕捉されない限り、です、もちろん)。"

#: ../../whatsnew/2.1.rst:283
msgid ""
"Functions were also added to Python's C API for issuing warnings; refer to "
"PEP 230 or to Python's API documentation for the details."
msgstr ""
"関数は、警告を発行するための Python の C API にも追加されました。詳細については PEP 230 または Python の API "
"ドキュメントを参照してください。"

#: ../../whatsnew/2.1.rst:293
msgid ":pep:`5` - Guidelines for Language Evolution"
msgstr ":pep:`5` - 言語の進化のためのガイドライン"

#: ../../whatsnew/2.1.rst:290
msgid ""
"Written by Paul Prescod, to specify procedures to be followed when removing "
"old features from Python.  The policy described in this PEP hasn't been "
"officially adopted, but the eventual policy probably won't be too different "
"from Prescod's proposal."
msgstr ""
"Python から古い機能を削除する時に従うべき手順を示すため、 Paul Prescod により書かれました。当 PEP "
"に記載された方針は正式に採用されていませんが、最終的な方針も Prescod の提案とおそらくさほど違いはないでしょう。"

#: ../../whatsnew/2.1.rst:295
msgid ":pep:`230` - Warning Framework"
msgstr ":pep:`230` - 警告フレームワーク"

#: ../../whatsnew/2.1.rst:296
msgid "Written and implemented by Guido van Rossum."
msgstr "Guido van Rossum 著、実装"

#: ../../whatsnew/2.1.rst:302
msgid "PEP 229: New Build System"
msgstr "PEP 229: 新しいビルドシステム"

#: ../../whatsnew/2.1.rst:304
msgid ""
"When compiling Python, the user had to go in and edit the "
":file:`Modules/Setup` file in order to enable various additional modules; "
"the default set is relatively small and limited to modules that compile on "
"most Unix platforms. This means that on Unix platforms with many more "
"features, most notably Linux, Python installations often don't contain all "
"useful modules they could."
msgstr ""
"Python のコンパイル時、ユーザはソースツリーの中に入って、様々な追加モジュールを有効にするために :file:`Modules/Setup` "
"ファイルを編集しなければなりませんでした; デフォルトのセットは比較的小さくて、ほとんどの Unix "
"プラットフォームで、コンパイルするモジュールを制限しています。これは、特に Linux に顕著ですが、たくさんの追加機能を持った Unix "
"プラットフォームでは、Python "
"インストレーションはしばしば、そう出来るのに有用なモジュールを全く含まない、といったことが起こることを意味しています。"

#: ../../whatsnew/2.1.rst:310
msgid ""
"Python 2.0 added the Distutils, a set of modules for distributing and "
"installing extensions.  In Python 2.1, the Distutils are used to compile "
"much of the standard library of extension modules, autodetecting which ones "
"are supported on the current machine.  It's hoped that this will make Python"
" installations easier and more featureful."
msgstr ""
"Python 2.0 は、配布と拡張のインストールをするためのモジュールのセットである Distutils を追加しました。Python 2.1 では "
"Distutils を、たくさんの拡張モジュールの標準ライブラリを、サポートする機器かどうかを自動検出してコンパイルするのに使っています。これが "
"Python インストレーションをより簡単に、より機能的とするものであることが期待されています。"

#: ../../whatsnew/2.1.rst:316
msgid ""
"Instead of having to edit the :file:`Modules/Setup` file in order to enable "
"modules, a :file:`setup.py` script in the top directory of the Python source"
" distribution is run at build time, and attempts to discover which modules "
"can be enabled by examining the modules and header files on the system.  If "
"a module is configured in :file:`Modules/Setup`, the :file:`setup.py` script"
" won't attempt to compile that module and will defer to the "
":file:`Modules/Setup` file's contents.  This provides a way to specific any "
"strange command-line flags or libraries that are required for a specific "
"platform."
msgstr ""
"モジュールを有効化するために :file:`Modules/Setup` を編集する必要性の代わりに、Python "
"ソースツリーのトップレベルディレクトリにある :file:`setup.py` "
"スクリプトがビルド時に実行され、システムのモジュールとヘッダファイルを調べることによって、どのモジュールが有効に出来るのかを検出しようと試みます。モジュールが"
" :file:`Modules/Setup` 内でそう構成されていれば、 :file:`setup.py` "
"スクリプトはそのモジュールをコンパイルしようとはせずに :file:`Modules/Setup` "
"ファイル内容に従います。これは特定のプラットフォームで必要となるヘンチクリンなコマンドラインフラグやライブラリフラグを特定する手段も与えてくれます。"

#: ../../whatsnew/2.1.rst:325
msgid ""
"In another far-reaching change to the build mechanism, Neil Schemenauer "
"restructured things so Python now uses a single makefile that isn't "
"recursive, instead of makefiles in the top directory and in each of the "
":file:`Python/`, :file:`Parser/`, :file:`Objects/`, and :file:`Modules/` "
"subdirectories.  This makes building Python faster and also makes hacking "
"the Makefiles clearer and simpler."
msgstr ""
"もう一つの大きなビルド機構の変更点は Neil Schemenauer による再構成で、今や Python は、トップディレクトリと "
":file:`Python/`, :file:`Parser/`, :file:`Objects/`, :file:`Modules/` "
"サブディレクトリにあった別々の Makefile が再帰的にビルドする代わりに、再帰をしないトップレベルの単一 makefile "
"を使うようになっています。このことで Python のビルドは速くなり、 Makefile をもてあそぶのが単純明快になっています。"

#: ../../whatsnew/2.1.rst:335
msgid ":pep:`229` - Using Distutils to Build Python"
msgstr ":pep:`229` - Distutils を使った Python のビルド"

#: ../../whatsnew/2.1.rst:336 ../../whatsnew/2.1.rst:571
msgid "Written and implemented by A.M. Kuchling."
msgstr "A.M. Kuchling 著、実装"

#: ../../whatsnew/2.1.rst:342
msgid "PEP 205: Weak References"
msgstr "PEP 205: 弱参照"

#: ../../whatsnew/2.1.rst:344
msgid ""
"Weak references, available through the :mod:`weakref` module, are a minor "
"but useful new data type in the Python programmer's toolbox."
msgstr ""
":mod:`weakref` モジュールを通して利用出来る弱参照(weak references)は、ささやかですが有用な、Python "
"プログラマの道具箱に新たに加わったデータ型です。"

#: ../../whatsnew/2.1.rst:347
msgid ""
"Storing a reference to an object (say, in a dictionary or a list) has the "
"side effect of keeping that object alive forever.  There are a few specific "
"cases where this behaviour is undesirable, object caches being the most "
"common one, and another being circular references in data structures such as"
" trees."
msgstr ""
"オブジェクトへの参照(辞書内やリスト内を思い浮かべてください)を記憶しておくということは、オブジェクトを生き永らえさせるという副作用を持っています。少しばかりの、この振る舞いが望ましくない特殊なケースがあります。オブジェクトのキャッシュがその最もありがちな一つで、もう一つはツリーのようなデータ構造での循環参照です。"

#: ../../whatsnew/2.1.rst:352
msgid ""
"For example, consider a memoizing function that caches the results of "
"another function ``f(x)`` by storing the function's argument and its result "
"in a dictionary::"
msgstr ""
"例えば、 ひとさまの関数 ``f(x)`` の結果をキャッシュしておくメモ化関数を考えてみましょう。関数 ``f(x)`` "
"の引数ごとに辞書に記憶します::"

#: ../../whatsnew/2.1.rst:368
msgid ""
"This version works for simple things such as integers, but it has a side "
"effect; the ``_cache`` dictionary holds a reference to the return values, so"
" they'll never be deallocated until the Python process exits and cleans up. "
"This isn't very noticeable for integers, but if :func:`f` returns an object,"
" or a data structure that takes up a lot of memory, this can be a problem."
msgstr ""
"このバージョンは整数のような単純なものにはうまく働きますが、副作用を持っています; 辞書 ``_cache`` は戻り値への参照を保持するので、それらは"
" Python プロセスが終了してクリーンアップされない限り、解放されません。整数であればそれは気にすることではありませんが、:func:`f` "
"がオブジェクトや何かメモリをたくさん使うようなデータ構造を返すならば、これは問題になるかもしれません。"

#: ../../whatsnew/2.1.rst:374
msgid ""
"Weak references provide a way to implement a cache that won't keep objects "
"alive beyond their time.  If an object is only accessible through weak "
"references, the object will be deallocated and the weak references will now "
"indicate that the object it referred to no longer exists.  A weak reference "
"to an object *obj* is created by calling ``wr = weakref.ref(obj)``.  The "
"object being referred to is returned by calling the weak reference as if it "
"were a function: ``wr()``.  It will return the referenced object, or "
"``None`` if the object no longer exists."
msgstr ""
"弱参照は、オブジェクトをその時間を超えて生き永らえさせたくないキャッシュの実装のための手段を提供します。オブジェクトがアクセス出来るのが弱参照からのみである場合、そのオブジェクトは解放されて、その弱参照は参照しているそのオブジェクトがもはや存在しないことを表明します。オブジェクト"
" *obj* への弱参照を作るには、 ``wr = weakref.ref(obj)`` "
"とします。参照されているオブジェクトは、それがあたかも関数であったかのように弱参照を「コール」することで得ます: ``wr()`` "
"。それは参照されたオブジェクトを返すか、もう存在していないのであれば ``None`` を返します。"

#: ../../whatsnew/2.1.rst:382
msgid ""
"This makes it possible to write a :func:`memoize` function whose cache "
"doesn't keep objects alive, by storing weak references in the cache. ::"
msgstr ""
"これでオブジェクトを生き残らせないキャッシュを使う :func:`memoize` を、キャッシュ内に弱参照を記憶するというやり方で書けます::"

#: ../../whatsnew/2.1.rst:400
msgid ""
"The :mod:`weakref` module also allows creating proxy objects which behave "
"like weak references --- an object referenced only by proxy objects is "
"deallocated -- but instead of requiring an explicit call to retrieve the "
"object, the proxy transparently forwards all operations to the object as "
"long as the object still exists.  If the object is deallocated, attempting "
"to use a proxy will cause a :exc:`weakref.ReferenceError` exception to be "
"raised. ::"
msgstr ""
":mod:`weakref` モジュールでは、弱参照のように振舞うプロキシオブジェクトも作れます --- "
"プロキシオブジェクトによってのみ参照されるオブジェクトが解放されます -- "
"オブジェクトを取り出すために明示的に「呼び出す」必要をなくすためにプロキシは、全てのオブジェクトへの操作を、オブジェクトが生きている限り透過的に転送します。オブジェクトが解放された場合、プロキシを使おうとすると"
" :exc:`weakref.ReferenceError` 例外が起こります::"

#: ../../whatsnew/2.1.rst:416
msgid ":pep:`205` - Weak References"
msgstr ":pep:`205` - 弱参照"

#: ../../whatsnew/2.1.rst:417
msgid "Written and implemented by Fred L. Drake, Jr."
msgstr "Fred L. Drake, Jr. 著、実装"

#: ../../whatsnew/2.1.rst:423
msgid "PEP 232: Function Attributes"
msgstr "PEP 232: 関数の属性"

#: ../../whatsnew/2.1.rst:425
msgid ""
"In Python 2.1, functions can now have arbitrary information attached to "
"them. People were often using docstrings to hold information about functions"
" and methods, because the ``__doc__`` attribute was the only way of "
"attaching any information to a function.  For example, in the Zope Web "
"application server, functions are marked as safe for public access by having"
" a docstring, and in John Aycock's SPARK parsing framework, docstrings hold "
"parts of the BNF grammar to be parsed.  This overloading is unfortunate, "
"since docstrings are really intended to hold a function's documentation; for"
" example, it means you can't properly document functions intended for "
"private use in Zope."
msgstr ""
"Python 2.1 "
"では、関数に任意の情報をアタッチさせる(付随させる)ことが出来るようになりました。人々はしばしば関数やメソッドについての情報を保持するのに "
"docstring を使ってきました。というのも ``__doc__`` だけが唯一関数に任意の情報をアタッチ出来る方法だったからです。例えば、Zope"
" ウェブアプリケーションでは、関数は docstring に情報を持つことによって公開アクセスのために安全かどうかマークされ、John Aycock の"
" SPARK 解析フレームワークでは docstring は BNF "
"文法記述の部分を、解析のために保持していました。この「詰め込み」は嘆かわしいことです。docstring "
"はまったくもって関数のドキュメンテーションを保持するのに意図されたものです。例えば Zope "
"では自分のために行儀よく関数にドキュメント付け出来ないということです。"

#: ../../whatsnew/2.1.rst:435
msgid ""
"Arbitrary attributes can now be set and retrieved on functions using the "
"regular Python syntax::"
msgstr "ついに関数に、任意の属性をセットし、取り出すことが出来るようになりました。普通の Python 構文で出来ます::"

#: ../../whatsnew/2.1.rst:444
msgid ""
"The dictionary containing attributes can be accessed as the function's "
":attr:`~object.__dict__`. Unlike the :attr:`~object.__dict__` attribute of "
"class instances, in functions you can actually assign a new dictionary to "
":attr:`~object.__dict__`, though the new value is restricted to a regular "
"Python dictionary; you *can't* be tricky and set it to a :class:`UserDict` "
"instance, or any other random object that behaves like a mapping."
msgstr ""
"属性を含んだ辞書に、関数の属性 :attr:`~object.__dict__` としてアクセス出来ます。クラスインスタンスの "
":attr:`~object.__dict__` 属性とは違って、関数では実際には、 :attr:`~object.__dict__` "
"に別の辞書を代入出来ます。ですが、新しい値は普通の Python 辞書に制限されています; ズルは *出来ません* し、 "
":class:`UserDict` インスタンスやなにかほかのマッピングのように振舞うデタラメなオブジェクトはセット出来ません。"

#: ../../whatsnew/2.1.rst:454
msgid ":pep:`232` - Function Attributes"
msgstr ":pep:`232` - 関数の属性"

#: ../../whatsnew/2.1.rst:455
msgid "Written and implemented by Barry Warsaw."
msgstr "Barry Warsaw 著、実装"

#: ../../whatsnew/2.1.rst:461
msgid "PEP 235: Importing Modules on Case-Insensitive Platforms"
msgstr "PEP 235: 大文字小文字を区別しないプラットフォームでのモジュールの読み込み"

#: ../../whatsnew/2.1.rst:463
msgid ""
"Some operating systems have filesystems that are case-insensitive, MacOS and"
" Windows being the primary examples; on these systems, it's impossible to "
"distinguish the filenames ``FILE.PY`` and ``file.py``, even though they do "
"store the file's name  in its original case (they're case-preserving, too)."
msgstr ""
"いくつかのオペレーティングシステムは、大小文字区別に無関心なファイルシステムを持っています。MacOS と Windows "
"がその代表例です。それらシステムにおいてはファイル名 ``FILE.PY`` と ``file.py`` "
"の区別が出来ません。たとえそれが元のファイル名を尊重して格納出来たとしてもです(それらは大小文字維持、でもあります)。"

#: ../../whatsnew/2.1.rst:468
msgid ""
"In Python 2.1, the :keyword:`import` statement will work to simulate case-"
"sensitivity on case-insensitive platforms.  Python will now search for the "
"first case-sensitive match by default, raising an :exc:`ImportError` if no "
"such file is found, so ``import file`` will not import a module named "
"``FILE.PY``. Case-insensitive matching can be requested by setting the "
":envvar:`PYTHONCASEOK` environment variable before starting the Python "
"interpreter."
msgstr ""
"Python 2.1 では :keyword:`import` 文が、case-insensitive (大小文字に無関心)なプラットフォームで "
"case-sensitivity (大小文字への繊細さ)をシミュレートして動作します。Python は今や、まずはデフォルトで case-"
"sensitive なマッチによる検索をし、それで見つからなければ :exc:`ImportError` を投げます。ですから ``import "
"file`` は ``FILE.PY`` をインポートしません。case-insensitive マッチングは Python "
"インタプリタ開始前に環境変数 :envvar:`PYTHONCASEOK` をセットすることで要求出来ます。"

#: ../../whatsnew/2.1.rst:479
msgid "PEP 217: Interactive Display Hook"
msgstr "PEP 217: 対話モード用 Display Hook"

#: ../../whatsnew/2.1.rst:481
msgid ""
"When using the Python interpreter interactively, the output of commands is "
"displayed using the built-in :func:`repr` function. In Python 2.1, the "
"variable :func:`sys.displayhook` can be set to a callable object which will "
"be called instead of :func:`repr`. For example, you can set it to a special "
"pretty-printing function::"
msgstr ""
"Python インタプリタを対話的に使う際には、コマンドの出力結果表示にはビルトインの :func:`repr` 関数が使われます。Python 2.1"
" ではこの :func:`repr` の代わりに呼び出される呼び出し可能オブジェクトを、 :func:`sys.displayhook` "
"変数にセット出来ます。たとえば特別な pretty- printing 関数をセット出来ます::"

#: ../../whatsnew/2.1.rst:502
msgid ":pep:`217` - Display Hook for Interactive Use"
msgstr ":pep:`217` - Display Hook の対話的な使用"

#: ../../whatsnew/2.1.rst:503
msgid "Written and implemented by Moshe Zadka."
msgstr "Moshe Zadka 著、実装"

#: ../../whatsnew/2.1.rst:509
msgid "PEP 208: New Coercion Model"
msgstr "PEP 208: 新しい型強制モデル"

#: ../../whatsnew/2.1.rst:511
msgid ""
"How numeric coercion is done at the C level was significantly modified.  "
"This will only affect the authors of C extensions to Python, allowing them "
"more flexibility in writing extension types that support numeric operations."
msgstr ""
"数値強制が C レベルでどのようになされるかについての修正は、とても大きなものでした。これは Python の C "
"拡張の著者にのみ影響し、数値操作をサポートする拡張型を書くのをより柔軟にするものです。"

#: ../../whatsnew/2.1.rst:515
msgid ""
"Extension types can now set the type flag ``Py_TPFLAGS_CHECKTYPES`` in their"
" ``PyTypeObject`` structure to indicate that they support the new coercion "
"model. In such extension types, the numeric slot functions can no longer "
"assume that they'll be passed two arguments of the same type; instead they "
"may be passed two arguments of differing types, and can then perform their "
"own internal coercion. If the slot function is passed a type it can't "
"handle, it can indicate the failure by returning a reference to the "
"``Py_NotImplemented`` singleton value. The numeric functions of the other "
"type will then be tried, and perhaps they can handle the operation; if the "
"other type also returns ``Py_NotImplemented``, then a :exc:`TypeError` will "
"be raised.  Numeric methods written in Python can also return "
"``Py_NotImplemented``, causing the interpreter to act as if the method did "
"not exist (perhaps raising a :exc:`TypeError`, perhaps trying another "
"object's numeric methods)."
msgstr ""
"拡張型はその ``PyTypeObject`` 構造体に、新しい型強制モデルをサポートすることを示すために "
"``Py_TPFLAGS_CHECKTYPES`` フラグをセット出来るようになりました。そのような拡張型内では、数値的スロット関数は 2 "
"つの引数が同じ型であることを仮定しなくなります。代わりに、2 "
"つの引数が異なる型を渡せて、内部的に型変換を実行出来ます。スロット関数にそれが処理出来ない型が渡された場合は、それが失敗であることを表すために "
"``Py_NotImplemented`` シングルトン値への参照を返せます。この場合他の数値関数が試されて、おそらく操作を実行出来ます。それでも "
"``Py_NotImplemented`` を返すなら :exc:`TypeError` が送出されます。Python で書かれた数値メソッドも "
"``Py_NotImplemented`` を返せます。この場合インタプリタはメソッドが存在しないものとして振舞います。 (おそらく "
":exc:`TypeError` が投げられたり、オブジェクトのほかの数値メソッドが試されます。)"

#: ../../whatsnew/2.1.rst:534
msgid ":pep:`208` - Reworking the Coercion Model"
msgstr ":pep:`208` - 型強制モデルの手直し"

#: ../../whatsnew/2.1.rst:533
msgid ""
"Written and implemented by Neil Schemenauer, heavily based upon earlier work"
" by Marc-André Lemburg.  Read this to understand the fine points of how "
"numeric operations will now be processed at the C level."
msgstr ""
"Neil Schemenauer により著され、実装されましたが、大変多くを Marc-André Lemburg による以前の仕事に拠っています。C "
"レベルで今では数値操作がどのように処理されるようになったかの細かい点を理解したければ、これを読んで下さい。"

#: ../../whatsnew/2.1.rst:541
msgid "PEP 241: Metadata in Python Packages"
msgstr "PEP 241: Pythonソフトウェアパッケージのためのメタデータ"

#: ../../whatsnew/2.1.rst:543
msgid ""
"A common complaint from Python users is that there's no single catalog of "
"all the Python modules in existence.  T. Middleton's Vaults of Parnassus at "
"http://www.vex.net/parnassus/ are the largest catalog of Python modules, but"
" registering software at the Vaults is optional, and many people don't "
"bother."
msgstr ""
"Python ユーザからの日常的な不平は、既にある全ての Python モジュールの単一のカタログがないことです。T. Middleton の "
"http://www.vex.net/parnassus/ にある Vaults of Parnassus が Python "
"モジュールの最小限のカタログとしてありますが、Vaults にソフトウェアを登録することはオプショナルであって、多くの人々はわざわざそれをしません。"

#: ../../whatsnew/2.1.rst:548
msgid ""
"As a first small step toward fixing the problem, Python software packaged "
"using the Distutils :command:`sdist` command will include a file named :file"
":`PKG-INFO` containing information about the package such as its name, "
"version, and author (metadata, in cataloguing terminology).  :pep:`241` "
"contains the full list of fields that can be present in the :file:`PKG-INFO`"
" file.  As people began to package their software using Python 2.1, more and"
" more packages will include metadata, making it possible to build automated "
"cataloguing systems and experiment with them.  With the result experience, "
"perhaps it'll be possible to design a really good catalog and then build "
"support for it into Python 2.2. For example, the Distutils :command:`sdist` "
"and :command:`bdist_\\*` commands could support an ``upload`` option that "
"would automatically upload your package to a catalog server."
msgstr ""
"この問題をどうにかするための最初の小さな一歩として、Distutils の :command:`sdist` コマンドを使ってパッケージ化する "
"Python ソフトウェアに :file:`PKG-INFO` と名付けられたファイルを含むようにしました。これには名前、バージョン、著者 "
"(カタログ化の用語ではメタデータ) のような情報を含んでいます。 :pep:`241` が :file:`PKG-INFO` "
"ファイルに持てるフィールドの完全なリストを記述しています。Python 2.1 "
"を使ったソフトウェアをパッケージ化し始めた人々によってパッケージがどんどんメタデータを含み、自動的なカタログ化システムを構築し、それを実験することが出来るようになります。その結果の経験により、おそらく本当に良いカタログを設計出来、Python"
" 2.2 でそのサポートを構築出来るでしょう。例えば Distutils の :command:`sdist` コマンドと "
":command:`bdist_\\*` コマンド群はあなたのパッケージをカタログサーバに自動的にアップロードする ``upload`` "
"オプションをサポート出来るでしょう。"

#: ../../whatsnew/2.1.rst:561
msgid ""
"You can start creating packages containing :file:`PKG-INFO` even if you're "
"not using Python 2.1, since a new release of the Distutils will be made for "
"users of earlier Python versions.  Version 1.0.2 of the Distutils includes "
"the changes described in :pep:`241`, as well as various bugfixes and "
"enhancements.  It will be available from the Distutils SIG at "
"https://www.python.org/community/sigs/current/distutils-sig/."
msgstr ""
":file:`PKG-INFO` を含んだパッケージの作成は Python 2.1 を使っていなくても開始することが出来ます。Distutils "
"の新しいリリースが以前のバージョンの Python ユーザ向けにも作られているからです。Distutils のバージョン 1.0.2 "
"が、多数のバグフィックスや拡張とともに、 :pep:`241` の変更を含んでいます。これは "
"https://www.python.org/community/sigs/current/distutils-sig/ にある Distutils "
"SIG から入手可能です。"

#: ../../whatsnew/2.1.rst:571
msgid ":pep:`241` - Metadata for Python Software Packages"
msgstr ":pep:`241` - Pythonソフトウェアパッケージのためのメタデータ"

#: ../../whatsnew/2.1.rst:574
msgid ":pep:`243` - Module Repository Upload Mechanism"
msgstr ":pep:`243` - レポジトリアップロードモジュールのメカニズム"

#: ../../whatsnew/2.1.rst:574
msgid ""
"Written by Sean Reifschneider, this draft PEP describes a proposed mechanism"
" for uploading  Python packages to a central server."
msgstr ""
"Sean Reifschneider により著されました。このドラフト PEP は中央サーバに Python "
"パッケージをアップロードする機構について提案しています。"

#: ../../whatsnew/2.1.rst:581
msgid "New and Improved Modules"
msgstr "新しいモジュールと改良されたモジュール"

#: ../../whatsnew/2.1.rst:583
msgid ""
"Ka-Ping Yee contributed two new modules: :mod:`inspect.py`, a module for "
"getting information about live Python code, and :mod:`pydoc.py`, a module "
"for interactively converting docstrings to HTML or text.  As a bonus, "
":file:`Tools/scripts/pydoc`, which is now automatically installed, uses "
":mod:`pydoc.py` to display documentation given a Python module, package, or "
"class name.  For example, ``pydoc xml.dom`` displays the following::"
msgstr ""
"Ka-Ping Yee が 2 つの新規モジュールを寄稿しました: :mod:`inspect` モジュールは、動作中の Python "
"コードについての情報を取得するもので、 :mod:`pydoc` モジュールは docstring を対話的に HTML "
"またはテキストに変換します。オマケとして、 :file:`Tools/scripts/pydoc` "
"が自動的にインストールされるようになっていて、これは指定した Python モジュール、パッケージ、またはクラス名のドキュメントを "
":mod:`pydoc.py` を使って出力します。例えば ``pydoc xml.dom`` はこのような出力をします::"

#: ../../whatsnew/2.1.rst:605
msgid ""
":file:`pydoc` also includes a Tk-based interactive help browser.   "
":file:`pydoc` quickly becomes addictive; try it out!"
msgstr ""
":file:`pydoc` には TK ベースの対話的ヘルプブラウザも含まれています。 :file:`pydoc` "
"はすぐに病みつきになります。お試しあれ。"

#: ../../whatsnew/2.1.rst:608
msgid ""
"Two different modules for unit testing were added to the standard library. "
"The :mod:`doctest` module, contributed by Tim Peters, provides a testing "
"framework based on running embedded examples in docstrings and comparing the"
" results against the expected output.  PyUnit, contributed by Steve Purcell,"
" is a unit testing framework inspired by JUnit, which was in turn an "
"adaptation of Kent Beck's Smalltalk testing framework.  See "
"http://pyunit.sourceforge.net/ for more information about PyUnit."
msgstr ""
"2 つの異なる単体テスト用モジュールが標準ライブラリに追加されました。Tim Peters によって寄稿された :mod:`doctest` "
"モジュールは、docstring 内に埋め込まれた実例を実行することによるテストのフレームワークで、期待の出力と結果を比較します。Steve "
"Purcell の手による PyUnit は JUnit に触発された単体テストフレームワークです。JUnit も Kent Beck の "
"Smalltalk のテストフレームワーク由来です。PyUnit についてのより詳細な情報は "
"http://pyunit.sourceforge.net/ を参照してください。"

#: ../../whatsnew/2.1.rst:616
msgid ""
"The :mod:`difflib` module contains a class, :class:`SequenceMatcher`, which "
"compares two sequences and computes the changes required to transform one "
"sequence into the other.  For example, this module can be used to write a "
"tool similar to the Unix :program:`diff` program, and in fact the sample "
"program :file:`Tools/scripts/ndiff.py` demonstrates how to write such a "
"script."
msgstr ""
"新規の :mod:`difflib` モジュールは :class:`SequenceMatcher` クラスを含んでおり、これは 2 "
"つのシーケンスを比較し、一方のシーケンスから他方に変換するのに必要な変更点を計算します。例えば、このモジュールは Unix の "
":program:`diff` プログラムに似たツールを書くのに使えます。事実、サンプルプログラム "
":file:`Tools/scripts/ndiff.py` が、そのようなスクリプトをどのようにして書くかを実演しています。"

#: ../../whatsnew/2.1.rst:622
msgid ""
":mod:`curses.panel`, a wrapper for the panel library, part of ncurses and of"
" SYSV curses, was contributed by Thomas Gellekum.  The panel library "
"provides windows with the additional feature of depth. Windows can be moved "
"higher or lower in the depth ordering, and the panel library figures out "
"where panels overlap and which sections are visible."
msgstr ""
":mod:`curses.panel` はパネルライブラリへのラッパーであり、ncurses と SYSV curses の一部であり、 Thomas "
"Gellekum "
"により寄稿されました。パネルライブラリは深さ(depth)の追加機能を持つウィンドウを提供しています。ウィンドウは深さ順での高い方、低い方に移動出来、パネルライブラリはパネルがどこで重なるか、区域のどちらが可視かを理解します。"

#: ../../whatsnew/2.1.rst:628
msgid ""
"The PyXML package has gone through a few releases since Python 2.0, and "
"Python 2.1 includes an updated version of the :mod:`xml` package.  Some of "
"the noteworthy changes include support for Expat 1.2 and later versions, the"
" ability for Expat parsers to handle files in any encoding supported by "
"Python, and various bugfixes for SAX, DOM, and the :mod:`minidom` module."
msgstr ""
"PyXML パッケージは Python 2.0 から少しのリリースでいなくなり、Python 2.1 では :mod:`xml` "
"パッケージの更新バージョンを含んでいます。いくつかの特筆すべき変更点には Expat 1.2 以降のバージョンのサポートがあり、Expat パーサで "
"Python でサポートされる任意のエンコーディングのファイルを処理出来るようにし、SAX、DOM、 :mod:`minidom` "
"モジュールについての色々なバグフィックスがあります。"

#: ../../whatsnew/2.1.rst:634
msgid ""
"Ping also contributed another hook for handling uncaught exceptions. "
":func:`sys.excepthook` can be set to a callable object.  When an exception "
"isn't caught by any :keyword:`try`...\\ :keyword:`except` blocks, the "
"exception will be passed to :func:`sys.excepthook`, which can then do "
"whatever it likes.  At the Ninth Python Conference, Ping demonstrated an "
"application for this hook: printing an extended traceback that not only "
"lists the stack frames, but also lists the function arguments and the local "
"variables for each frame."
msgstr ""
"Ka-Ping Yee は未捕捉の例外を処理するもうひとつのフックも寄稿しました。 :func:`sys.excepthook` "
"には呼び出し可能オブジェクトをセット出来ます。例外がどの :keyword:`try`...\\ :keyword:`except` "
"にも捕捉されない場合に、例外は :func:`sys.excepthook` に通されて、そこで好きなことを何でも出来ます。9 回目の Python "
"カンファレンスにおいて、Ping "
"はこのフックを使ったアプリケーションのデモを行いました。そこでは、スタックフレームを列挙するだけでなくそれぞれのフレームでの関数の引数とローカル変数の列挙も行う拡張トレースバックの表示をしていました。"

#: ../../whatsnew/2.1.rst:642
msgid ""
"Various functions in the :mod:`time` module, such as :func:`asctime` and "
":func:`localtime`, require a floating point argument containing the time in "
"seconds since the epoch.  The most common use of these functions is to work "
"with the current time, so the floating point argument has been made "
"optional; when a value isn't provided, the current time will be used.  For "
"example, log file entries usually need a string containing the current time;"
" in Python 2.1, ``time.asctime()`` can be used, instead of the lengthier "
"``time.asctime(time.localtime(time.time()))`` that was previously required."
msgstr ""
":func:`asctime` や :func:`localtime` のような :mod:`time` "
"モジュールの多くの関数が、エポックからの秒数での浮動小数点数の引数を必要とします。これら関数の最も一般的な使い方は現在時刻とともに用いるものですから、浮動小数点数引数が省略可能となりました。値が与えられなければ現在時刻が使われます。例えばログファイルのエントリは普通現在時刻を含んだ文字列が必要なものですが、Python"
" 2.1 では、以前では長々しい ``time.asctime(time.localtime(time.time()))`` "
"と書かなければならなかったものを代わりに ``time.asctime()`` とすることが出来ます。"

#: ../../whatsnew/2.1.rst:651
msgid "This change was proposed and implemented by Thomas Wouters."
msgstr "この変更は Thomas Wouters により提案され、実装されました。"

#: ../../whatsnew/2.1.rst:653
msgid ""
"The :mod:`ftplib` module now defaults to retrieving files in passive mode, "
"because passive mode is more likely to work from behind a firewall.  This "
"request came from the Debian bug tracking system, since other Debian "
"packages use :mod:`ftplib` to retrieve files and then don't work from behind"
" a firewall. It's deemed unlikely that this will cause problems for anyone, "
"because Netscape defaults to passive mode and few people complain, but if "
"passive mode is unsuitable for your application or network setup, call "
"``set_pasv(0)`` on FTP objects to disable passive mode."
msgstr ""
":mod:`ftplib` "
"モジュールがデフォルトでパッシブモードでファイルを取得するようになりました。これはパッシブモードがファイアウォール配下ではより良く動作するようだからです。この要望は"
" Debian のバグトラッキングシステムから起こりました。ほかの Debian パッケージがファイル取得に :mod:`ftplib` "
"を使い、ファイアウォールの元で動作しなかったのです。このことが誰かの問題になるとは思えません。Netscape "
"のデフォルトがパッシブモードですし、苦情を言う人々も稀でした。ですがもしもパッシブモードがあなたのアプリケーションやネットワーク構成にとって不適切である場合には、FTP"
" オブジェクトの ``set_pasv(0)`` を呼び出して、パッシブモードを無効にしてください。"

#: ../../whatsnew/2.1.rst:662
msgid ""
"Support for raw socket access has been added to the :mod:`socket` module, "
"contributed by Grant Edwards."
msgstr ""
":mod:`socket` モジュールに、Grant Edwards により寄稿された、生のソケットへのアクセスのサポートが追加されました。"

#: ../../whatsnew/2.1.rst:665
msgid ""
"The :mod:`pstats` module now contains a simple interactive statistics "
"browser for displaying timing profiles for Python programs, invoked when the"
" module is run as a script.  Contributed by  Eric S. Raymond."
msgstr ""
":mod:`pstats` モジュールに、Python "
"プログラムの時間計測プロファイルを表示する単純な対話的統計ブラウザが含まれるようになり、これはモジュールがスクリプトとして実行された場合に呼び出されます。Eric"
" S. Raymond によって寄稿されました。"

#: ../../whatsnew/2.1.rst:669
msgid ""
"A new implementation-dependent function, ``sys._getframe([depth])``, has "
"been added to return a given frame object from the current call stack. "
":func:`sys._getframe` returns the frame at the top of the call stack;  if "
"the optional integer argument *depth* is supplied, the function returns the "
"frame that is *depth* calls below the top of the stack.  For example, "
"``sys._getframe(1)`` returns the caller's frame object."
msgstr ""
"実装依存の関数ですが ``sys._getframe([depth])`` "
"が、現在の呼び出しスタックより、指定したフレームオブジェクトを返すものとして追加されました。 :func:`sys._getframe` "
"は呼び出しスタックの一番上のフレームを返します。オプショナルな整数引数 *depth* を与えると、関数はスタックの一番上から下 *depth* "
"ぶんの呼び出しのフレームを返します。例えば ``sys._getframe(1)`` は呼び出し元のフレームオブジェクトを返します。"

#: ../../whatsnew/2.1.rst:676
msgid ""
"This function is only present in CPython, not in Jython or the .NET "
"implementation.  Use it for debugging, and resist the temptation to put it "
"into production code."
msgstr ""
"この関数は CPython のみに含まれ、 Jython や .NET "
"実装にはありません。デバッグのためだけに用い、製品コード内にこれを書いてしまう誘惑に打ち克ってください。"

#: ../../whatsnew/2.1.rst:684
msgid "Other Changes and Fixes"
msgstr "その他の変更と修正"

#: ../../whatsnew/2.1.rst:686
msgid ""
"There were relatively few smaller changes made in Python 2.1 due to the "
"shorter release cycle.  A search through the CVS change logs turns up 117 "
"patches applied, and 136 bugs fixed; both figures are likely to be "
"underestimates.  Some of the more notable changes are:"
msgstr ""
"短めのリリースサイクルだったため Python 2.1 では比較的少ない変更でした。CVS 変更ログの検索では 117 のパッチ適用と 136 "
"のバグフィックスが見つかります。ともに少なく見積もっています。いくつかの注目に値する変更を紹介します:"

#: ../../whatsnew/2.1.rst:691
msgid ""
"A specialized object allocator is now optionally available, that should be "
"faster than the system :func:`malloc` and have less memory overhead.  The "
"allocator uses C's :func:`malloc` function to get large pools of memory, and"
" then fulfills smaller memory requests from these pools.  It can be enabled "
"by providing the :option:`!--with-pymalloc` option to the "
":program:`configure` script; see :file:`Objects/obmalloc.c` for the "
"implementation details."
msgstr ""
"特殊化されたオブジェクトアロケータがオプショナルで利用可能になっています。これはシステムの :func:`malloc` "
"よりも速くて省メモリであるはずです。このアロケータは C の :func:`malloc` "
"関数を大きなメモリプールを得るのに使い、それより小さなメモリ要求はこれらプールで実現しています。この機能は :program:`configure` "
"スクリプトに :option:`!--with-pymalloc` オプションを与えることで有効化出来ます。実装の詳細については "
":file:`Objects/obmalloc.c` をみてください。"

#: ../../whatsnew/2.1.rst:698
msgid ""
"Authors of C extension modules should test their code with the object "
"allocator enabled, because some incorrect code may break, causing core dumps"
" at runtime. There are a bunch of memory allocation functions in Python's C "
"API that have previously been just aliases for the C library's "
":func:`malloc` and :func:`free`, meaning that if you accidentally called "
"mismatched functions, the error wouldn't be noticeable.  When the object "
"allocator is enabled, these functions aren't aliases of :func:`malloc` and "
":func:`free` any more, and calling the wrong function to free memory will "
"get you a core dump.  For example, if memory was allocated using "
":func:`PyMem_New`, it has to be freed using :func:`PyMem_Del`, not "
":func:`free`.  A few modules included with Python fell afoul of this and had"
" to be fixed; doubtless there are more third-party modules that will have "
"the same problem."
msgstr ""
"C "
"拡張モジュールの作者はこのオブジェクトアロケータを有効にしてテストすべきです。というのもある種の誤ったコードが破壊されて、ランタイムにコアダンプを引き起こしうるからです。Python"
" の C API 内には数多くのメモリアロケーション関数がありますが、これは以前は単に C ライブラリの :c:func:`malloc` と "
":c:func:`free` "
"への別名であり、何かの間違いでミスマッチな関数呼び出しをしても、誤りは気付かれないものでした。今回のこのオブジェクトアロケータを有効化すると、これら関数は"
" :c:func:`malloc` と :c:func:`free` "
"への別名ではまったくなくて、メモリ解放に誤った関数を呼び出すとコアダンプし得ます。例えば :func:`PyMem_New` を使って獲得したメモリは "
":c:func:`free` ではなく :func:`PyMem_Del` を使って解放する必要があります。Python "
"に含まれるいくつかのモジュールがまさにこれに抵触し、修正の必要がありました。間違いなく多くのサードパーティモジュールが同じ問題を抱えているでしょう。"

#: ../../whatsnew/2.1.rst:711
msgid "The object allocator was contributed by Vladimir Marangozov."
msgstr "オブジェクトアロケータは Vladimir Marangozov により寄稿されました。"

#: ../../whatsnew/2.1.rst:713
msgid ""
"The speed of line-oriented file I/O has been improved because people often "
"complain about its lack of speed, and because it's often been used as a "
"naïve benchmark.  The :meth:`readline` method of file objects has therefore "
"been rewritten to be much faster.  The exact amount of the speedup will vary"
" from platform to platform depending on how slow the C library's "
":func:`getc` was, but is around 66%, and potentially much faster on some "
"particular operating systems. Tim Peters did much of the benchmarking and "
"coding for this change, motivated by a discussion in comp.lang.python."
msgstr ""

#: ../../whatsnew/2.1.rst:722
msgid ""
"A new module and method for file objects was also added, contributed by Jeff"
" Epler. The new method, :meth:`xreadlines`, is similar to the existing "
":func:`xrange` built-in.  :func:`xreadlines` returns an opaque sequence "
"object that only supports being iterated over, reading a line on every "
"iteration but not reading the entire file into memory as the existing "
":meth:`readlines` method does. You'd use it like this::"
msgstr ""

#: ../../whatsnew/2.1.rst:733
msgid ""
"For a fuller discussion of the line I/O changes, see the python-dev summary "
"for January 1--15, 2001 at https://mail.python.org/pipermail/python-"
"dev/2001-January/."
msgstr ""

#: ../../whatsnew/2.1.rst:736
msgid ""
"A new method, :meth:`popitem`, was added to dictionaries to enable "
"destructively iterating through the contents of a dictionary; this can be "
"faster for large dictionaries because there's no need to construct a list "
"containing all the keys or values. ``D.popitem()`` removes a random ``(key, "
"value)`` pair from the dictionary ``D`` and returns it as a 2-tuple.  This "
"was implemented mostly by Tim Peters and Guido van Rossum, after a "
"suggestion and preliminary patch by Moshe Zadka."
msgstr ""
"辞書に新しくメソッド :meth:`popitem` "
"が追加されました。これで辞書の内容を破壊的にイテレートすることが出来ます。これは大きな辞書では速くなりえます。全てのキーまたは値を含んだリストを構築する必要がないからです。"
" ``D.popitem()`` は辞書 ``D`` からランダムに ``(key, value)`` ペアを削除して、その 2 "
"要素タプルを返します。これは Moshe Zadka による示唆と事前のパッチののちに、Tim Peters と Guido van Rossum "
"によりほとんどが実装されました。(---訳注: 速くなる理由の説明が、イテレータもジェネレータもなかった Python 2.1 "
"時点での説明であることに注意してください。---)"

#: ../../whatsnew/2.1.rst:744
msgid ""
"Modules can now control which names are imported when ``from module import "
"*`` is used, by defining an ``__all__`` attribute containing a list of names"
" that will be imported.  One common complaint is that if the module imports "
"other modules such as :mod:`sys` or :mod:`string`, ``from module import *`` "
"will add them to the importing module's namespace.  To fix this, simply list"
" the public names in ``__all__``::"
msgstr ""
"``from module import *`` "
"を使ってインポートする際にインポートされる名前を制御出来るようになりました。インポートされるべき名前のリストを含む ``__all__`` "
"属性を定義することでこれを行えます。一つのよくある不平が、 :mod:`sys` や :mod:`string` "
"のように、ほかのモジュールをモジュールがインポートする場合に、 ``from module import *`` "
"がインポートしているモジュールの名前空間内にそれらを追加することです。これをフィックスするには、 ``__all__`` に公開名を単に列挙します::"

#: ../../whatsnew/2.1.rst:754
msgid ""
"A stricter version of this patch was first suggested and implemented by Ben "
"Wolfson, but after some python-dev discussion, a weaker final version was "
"checked in."
msgstr ""
"このパッチのより厳密な版が最初に示唆されて Ben Wolfson により実装されましたが、python-dev "
"でのいくつかの議論を経てからより弱い最終版がチェックインされました。"

#: ../../whatsnew/2.1.rst:758
msgid ""
"Applying :func:`repr` to strings previously used octal escapes for non-"
"printable characters; for example, a newline was ``'\\012'``.  This was a "
"vestigial trace of Python's C ancestry, but today octal is of very little "
"practical use.  Ka-Ping Yee suggested using hex escapes instead of octal "
"ones, and using the ``\\n``, ``\\t``, ``\\r`` escapes for the appropriate "
"characters, and implemented this new formatting."
msgstr ""
"文字列に :func:`repr` を適用するとこれまでは表示出来ない文字について、8 進エスケープが使われていました。例えば改行コードは "
"``'\\012'`` でした。これは Python の起源である C に追従した名残ですが、こんにちでは普段使いで 8 "
"進エスケープが使われることは非常に少なくなりました。Ka-Ping Yee が 8 進の代わりに 16 進を使いつつ相応の文字には ``\\n``, "
"``\\t``, ``\\r`` などのエスケープを使うよう示唆し、この新しい書式化を実装しました。"

#: ../../whatsnew/2.1.rst:765
msgid ""
"Syntax errors detected at compile-time can now raise exceptions containing "
"the filename and line number of the error, a pleasant side effect of the "
"compiler reorganization done by Jeremy Hylton."
msgstr ""
"コンパイル時点で検出される構文エラーがエラーとなったファイル名と行番号を含む例外を送出できるようになり、またこれによりコンパイラの再編成という喜ばしい副作用がありました。Jeremy"
" Hylton により達成されました。"

#: ../../whatsnew/2.1.rst:769
msgid ""
"C extensions which import other modules have been changed to use "
":func:`PyImport_ImportModule`, which means that they will use any import "
"hooks that have been installed.  This is also encouraged for third-party "
"extensions that need to import some other module from C code."
msgstr ""
"他のモジュールをインポートする C 拡張が :func:`PyImport_ImportModule` "
"を使うように変更されました。これによりインストールされている任意のインポートフックが使われます。これは C "
"コードより他のモジュールをインポートする必要があるサードパーティ拡張にも推奨されます。"

#: ../../whatsnew/2.1.rst:774
msgid ""
"The size of the Unicode character database was shrunk by another 340K thanks"
" to Fredrik Lundh."
msgstr "Unicode 文字データベースのサイズが Fredrik Lundh のおかげでさらに 340K だけ小さくなりました。"

#: ../../whatsnew/2.1.rst:777
msgid ""
"Some new ports were contributed: MacOS X (by Steven Majewski), Cygwin (by "
"Jason Tishler); RISCOS (by Dietmar Schwertberger); Unixware 7  (by Billy G. "
"Allie)."
msgstr ""
"いくつかの新たなポートの寄与: MacOS X (by Steven Majewski), Cygwin (by Jason Tishler); "
"RISCOS (by Dietmar Schwertberger); Unixware 7  (by Billy G. Allie)."

#: ../../whatsnew/2.1.rst:781
msgid ""
"And there's the usual list of minor bugfixes, minor memory leaks, docstring "
"edits, and other tweaks, too lengthy to be worth itemizing; see the CVS logs"
" for the full details if you want them."
msgstr ""
"そしてよくあるマイナーなバグフィックス、マイナーなメモリリーク、ドキュメンテーション文字列の編集やほかの微調整があり、全てを列挙するには長過ぎます。もし見たいのであれば、CVS"
" ログで完全な詳細を読んで下さい。"

#: ../../whatsnew/2.1.rst:789
msgid "Acknowledgements"
msgstr "謝辞"

#: ../../whatsnew/2.1.rst:791
msgid ""
"The author would like to thank the following people for offering suggestions"
" on various drafts of this article: Graeme Cross, David Goodger, Jay Graves,"
" Michael Hudson, Marc-André Lemburg, Fredrik Lundh, Neil Schemenauer, Thomas"
" Wouters."
msgstr ""
"著者は提案の申し出や修正、様々なこの記事の草稿の助けをしてくれた以下の人々に感謝します:  Graeme Cross, David Goodger, "
"Jay Graves, Michael Hudson, Marc-André Lemburg, Fredrik Lundh, Neil "
"Schemenauer, Thomas Wouters."
