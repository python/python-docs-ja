# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2021
# Tetsuo Koyama <tkoyama010@gmail.com>, 2021
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-24 14:15+0000\n"
"PO-Revision-Date: 2021-06-28 01:51+0000\n"
"Last-Translator: Tetsuo Koyama <tkoyama010@gmail.com>, 2021\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.2.rst:3
msgid "What's New in Python 2.2"
msgstr "What's New in Python 2.2"

#: ../../whatsnew/2.2.rst:0
msgid "Author"
msgstr "著者"

#: ../../whatsnew/2.2.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.2.rst:13
msgid "Introduction"
msgstr "はじめに"

#: ../../whatsnew/2.2.rst:15
msgid ""
"This article explains the new features in Python 2.2.2, released on October "
"14, 2002.  Python 2.2.2 is a bugfix release of Python 2.2, originally "
"released on December 21, 2001."
msgstr ""
"この文書は 2002 年 10 月 14 日にリリースされた Python 2.2.2 の新機能について"
"解説します。Python 2.2.2 は 2001 年 12 月 21 日にリリースされた Python 2.2 の"
"バグフィックスリリースです。"

#: ../../whatsnew/2.2.rst:19
msgid ""
"Python 2.2 can be thought of as the \"cleanup release\".  There are some "
"features such as generators and iterators that are completely new, but most "
"of the changes, significant and far-reaching though they may be, are aimed "
"at cleaning up irregularities and dark corners of the language design."
msgstr ""
"Python 2.2 は「クリーンアップリリース」と考えることが出来ます。ジェネレータや"
"イテレータのように、完全に書き直されたいくつかの機能があります。ほとんどのそ"
"の変更は著しくて以前とはかけ離れたものとなりましたが、これは言語設計の不品行"
"と暗黒面を綺麗に掃除することを目的としています。"

#: ../../whatsnew/2.2.rst:24
msgid ""
"This article doesn't attempt to provide a complete specification of the new "
"features, but instead provides a convenient overview.  For full details, you "
"should refer to the documentation for Python 2.2, such as the `Python "
"Library Reference <https://docs.python.org/2.2/lib/lib.html>`_ and the "
"`Python Reference Manual <https://docs.python.org/2.2/ref/ref.html>`_.  If "
"you want to understand the complete implementation and design rationale for "
"a change, refer to the PEP for a particular new feature."
msgstr ""
"このドキュメントは個々の新機能の完全な詳細を提供するのではなくて、簡易な概要"
"を提供することを目的にしています。完全な詳細が知りたければ、`Python ライブラ"
"リリファレンス <https://docs.python.org/2.2/lib/lib.html>`_ 、`Python リファ"
"レンスマニュアル <https://docs.python.org/2.2/ref/ref.html>`_ のような "
"Python 2.2 のドキュメントを参照すべきです。設計と実装の根拠を理解したい場合"
"は、新機能に関する PEP を参照してください。"

#: ../../whatsnew/2.2.rst:43
msgid "PEPs 252 and 253: Type and Class Changes"
msgstr "PEP 252 と PEP 253: 型とクラスについての変更"

#: ../../whatsnew/2.2.rst:45
msgid ""
"The largest and most far-reaching changes in Python 2.2 are to Python's "
"model of objects and classes.  The changes should be backward compatible, so "
"it's likely that your code will continue to run unchanged, but the changes "
"provide some amazing new capabilities. Before beginning this, the longest "
"and most complicated section of this article, I'll provide an overview of "
"the changes and offer some comments."
msgstr ""
"最大にして広範に影響が及ぶ Python 2.2 の変更は、 オブジェクトとクラスの "
"Python モデルについてのものです。変更は後方互換であるはずなので、あなたのコー"
"ドは変更なしで動きそうです。ですがその変更は、いくつかの素晴らしい能力を発揮"
"させます。この、本記事中において最も長くて複雑なセクションについて始める前"
"に、変更の概要を提供し、いくつかの所感を提示しておこうと思います。"

#: ../../whatsnew/2.2.rst:52
msgid ""
"A long time ago I wrote a web page listing flaws in Python's design.  One of "
"the most significant flaws was that it's impossible to subclass Python types "
"implemented in C.  In particular, it's not possible to subclass built-in "
"types, so you can't just subclass, say, lists in order to add a single "
"useful method to them. The :mod:`UserList` module provides a class that "
"supports all of the methods of lists and that can be subclassed further, but "
"there's lots of C code that expects a regular Python list and won't accept "
"a :class:`UserList` instance."
msgstr ""

#: ../../whatsnew/2.2.rst:61
msgid ""
"Python 2.2 fixes this, and in the process adds some exciting new "
"capabilities. A brief summary:"
msgstr ""
"Python 2.2 はこれを修正し、また、その過程においていくつかの心躍る新機能を追加"
"しました。簡単に要約します:"

#: ../../whatsnew/2.2.rst:64
msgid ""
"You can subclass built-in types such as lists and even integers, and your "
"subclasses should work in every place that requires the original type."
msgstr ""
"あなたはリストのような組み込み型をサブクラス化出来ます。整数でさえ出来ます。"
"そしてあなたのサブクラスは、元の型を要求している全ての場所で動作します。"

#: ../../whatsnew/2.2.rst:67
msgid ""
"It's now possible to define static and class methods, in addition to the "
"instance methods available in previous versions of Python."
msgstr ""
"以前より使えたインスタンスメソッド加え、静的メソッド、クラスメソッドを今や定"
"義出来ます。"

#: ../../whatsnew/2.2.rst:70
msgid ""
"It's also possible to automatically call methods on accessing or setting an "
"instance attribute by using a new mechanism called :dfn:`properties`.  Many "
"uses of :meth:`__getattr__` can be rewritten to use properties instead, "
"making the resulting code simpler and faster.  As a small side benefit, "
"attributes can now have docstrings, too."
msgstr ""
":dfn:`properties` と名付けられた新しい機構を使うと、インスタンスの属性への参"
"照または設定時に自動的にメソッドを呼び出すようにも出来ます。従来の :meth:"
"`__getattr__` の多くの用法は properties を使って書き換えることが出来、それは"
"またコードを単純にし、高速化もします。小さなオマケとして、属性にも docstring "
"を持てるようになりました。"

#: ../../whatsnew/2.2.rst:76
msgid ""
"The list of legal attributes for an instance can be limited to a particular "
"set using :dfn:`slots`, making it possible to safeguard against typos and "
"perhaps make more optimizations possible in future versions of Python."
msgstr ""
":dfn:`slots` を使って、インスタンスの適正な属性を特定の集合に制限できます。こ"
"れはタイプミスに対する安全装置にも出来ますし、将来のバージョンの Python では"
"今よりも最適化される可能性があります。"

#: ../../whatsnew/2.2.rst:80
msgid ""
"Some users have voiced concern about all these changes.  Sure, they say, the "
"new features are neat and lend themselves to all sorts of tricks that "
"weren't possible in previous versions of Python, but they also make the "
"language more complicated.  Some people have said that they've always "
"recommended Python for its simplicity, and feel that its simplicity is being "
"lost."
msgstr ""
"一部のユーザはこれら全ての変更に懸念を表明しました。そうだね、彼らは言いま"
"す、新しい機能はかっこいいし昔の Python では出来なかった全ての芸当の役に立つ"
"さ、だけどさ、それって言語をより複雑にするよなぁ。一部の人々はずっと常に、"
"Python が単純さを保つことを提言してきました。そして彼らはその単純さが失われる"
"と感じたのです。"

#: ../../whatsnew/2.2.rst:86
msgid ""
"Personally, I think there's no need to worry.  Many of the new features are "
"quite esoteric, and you can write a lot of Python code without ever needed "
"to be aware of them.  Writing a simple class is no more difficult than it "
"ever was, so you don't need to bother learning or teaching them unless "
"they're actually needed.  Some very complicated tasks that were previously "
"only possible from C will now be possible in pure Python, and to my mind "
"that's all for the better."
msgstr ""
"個人的に私は、それらは心配には及ばない、と思っています。多くのそれら新機能は"
"随分と秘伝的で、あなたはそれらに気付く必要もないままたくさんの Python コード"
"を書けます。単純なクラスを書くことはかつてよりも難しいということはなく、実際"
"にそれを必要としない限りは、秘伝をわざわざ学習することも教育することも必要あ"
"りません。以前ならば C 言語からでしか可能でなかったようなある種の複雑なタスク"
"は、いまやピュアな python から出来て、私には何もかもが良い方向に思えます。"

#: ../../whatsnew/2.2.rst:93
msgid ""
"I'm not going to attempt to cover every single corner case and small change "
"that were required to make the new features work.  Instead this section will "
"paint only the broad strokes.  See section :ref:`sect-rellinks`, \"Related "
"Links\", for further sources of information about Python 2.2's new object "
"model."
msgstr ""
"この記事では全てのショーケースの品を陳列しようとはしませんし、将来の拡張のた"
"めに必要な小さな変更は説明しません。代わりにこのセクションではおおまかなアウ"
"トラインを描きます。Python 2.2 の新しいオブジェクトモデルの追加的な情報源につ"
"いては、 :ref:`sect-rellinks` を参照してください。"

#: ../../whatsnew/2.2.rst:100
msgid "Old and New Classes"
msgstr "旧と新クラス"

#: ../../whatsnew/2.2.rst:102
msgid ""
"First, you should know that Python 2.2 really has two kinds of classes: "
"classic or old-style classes, and new-style classes.  The old-style class "
"model is exactly the same as the class model in earlier versions of Python.  "
"All the new features described in this section apply only to new-style "
"classes. This divergence isn't intended to last forever; eventually old-"
"style classes will be dropped, possibly in Python 3.0."
msgstr ""
"まず、 Python 2.2 は本当に 2 種類のクラスを持っているのだ、ということを知る必"
"要があります: クラシック、あるいは旧スタイルクラス、と、新スタイルクラスで"
"す。旧スタイルクラスのモデルは、以前のバージョンのクラスモデルと完全に同じも"
"のです。このセクションに記述する全ての新機能は、全て新スタイルクラスだけに適"
"用されるものです。この逸脱が未来永劫続くことは望まれていません; 最終的には旧"
"スタイルクラスは撤廃されます。たぶん Python 3.0 で。"

#: ../../whatsnew/2.2.rst:109
msgid ""
"So how do you define a new-style class?  You do it by subclassing an "
"existing new-style class.  Most of Python's built-in types, such as "
"integers, lists, dictionaries, and even files, are new-style classes now.  A "
"new-style class named :class:`object`, the base class for all built-in "
"types, has also been added so if no built-in type is suitable, you can just "
"subclass :class:`object`::"
msgstr ""
"では、新スタイルクラスは、どうやって定義すればいいのでしょう? 答えは、既存の"
"新スタイルクラスをサブクラス化することです。たとえば整数、リスト、辞書やファ"
"イルでさえも、ほとんどの Python 組み込み型は今では新スタイルクラスです。 :"
"class:`object` という名の新スタイルクラスは全ての組み込み型の基底クラスとして"
"既に追加されていて、相応しい組み込み型がなければ単に :class:`object` をサブク"
"ラス化すれば良いです::"

#: ../../whatsnew/2.2.rst:121
msgid ""
"This means that :keyword:`class` statements that don't have any base classes "
"are always classic classes in Python 2.2.  (Actually you can also change "
"this by setting a module-level variable named :attr:`__metaclass__` --- see :"
"pep:`253` for the details --- but it's easier to just subclass :class:"
"`object`.)"
msgstr ""
"これは、Python 2.2 では、基底クラスを持たない :keyword:`class` 文はいつでも旧"
"スタイルクラスになることを意味します。(実際には、モジュールレベルの変数 :"
"attr:`__metaclass__` をセットすることでこれは変更出来ます --- 詳細は :pep:"
"`253` 参照 --- ですが :class:`object` をサブクラス化する方が簡単です。)"

#: ../../whatsnew/2.2.rst:126
msgid ""
"The type objects for the built-in types are available as built-ins, named "
"using a clever trick.  Python has always had built-in functions named :func:"
"`int`, :func:`float`, and :func:`str`.  In 2.2, they aren't functions any "
"more, but type objects that behave as factories when called. ::"
msgstr ""
"組み込み型(ビルトイン型)のための型オブジェクトは、クレバーなトリックを使って"
"名付けられた組み込み(ビルトイン)として利用可能です。Python は既に組み込み関"
"数 :func:`int`, :func:`float`, :func:`str` を持っていました。2.2 にはその関数"
"はなくなり、型オブジェクトは呼び出されるとファクトリとして振舞います::"

#: ../../whatsnew/2.2.rst:136
msgid ""
"To make the set of types complete, new type objects such as :func:`dict` "
"and :func:`file` have been added.  Here's a more interesting example, adding "
"a :meth:`lock` method to file objects::"
msgstr ""
"型の集合を完全にするために、 :func:`dict` や :func:`file` のような新しい型オ"
"ブジェクトが追加されました。もっと面白い例を挙げておきましょう。以下はファイ"
"ルオブジェクトに :meth:`lock` メソッドを追加します::"

#: ../../whatsnew/2.2.rst:146
msgid ""
"The now-obsolete :mod:`posixfile` module contained a class that emulated all "
"of a file object's methods and also added a :meth:`lock` method, but this "
"class couldn't be passed to internal functions that expected a built-in "
"file, something which is possible with our new :class:`LockableFile`."
msgstr ""
"今は撤廃された :mod:`posixfile` モジュールにはファイルオブジェクトのメソッド"
"を全てエミュレートしつつ :meth:`lock` を追加しているクラスが含まれています"
"が、このクラスは組み込み型のファイルオブジェクトを期待する内部関数に渡すこと"
"が出来ません。私たちの新しい :class:`LockableFile` ではそれが出来ます。"

#: ../../whatsnew/2.2.rst:153
msgid "Descriptors"
msgstr "デスクリプタ"

#: ../../whatsnew/2.2.rst:155
msgid ""
"In previous versions of Python, there was no consistent way to discover what "
"attributes and methods were supported by an object. There were some informal "
"conventions, such as defining :attr:`__members__` and :attr:`__methods__` "
"attributes that were lists of names, but often the author of an extension "
"type or a class wouldn't bother to define them.  You could fall back on "
"inspecting the :attr:`~object.__dict__` of an object, but when class "
"inheritance or an arbitrary :meth:`__getattr__` hook were in use this could "
"still be inaccurate."
msgstr ""
"以前のバージョンの Python には、オブジェクトによってサポートされている属性と"
"メソッドがなんなのかを見つけ出すための一貫した方法はありませんでした。 :attr:"
"`__members__` と :attr:`__methods__` で名前のリストを公開するといった非公式な"
"慣習は存在してはいましたが、拡張型やクラスの作者はわざわざそれらを定義しない"
"ということは、ままありました。一歩後退してオブジェクトの :attr:`~object."
"__dict__` を調べられたとしても、クラスが継承や任意の :meth:`__getattr__` フッ"
"クを使っていたりすれば、これはなお不正確になりえました。"

#: ../../whatsnew/2.2.rst:163
msgid ""
"The one big idea underlying the new class model is that an API for "
"describing the attributes of an object using :dfn:`descriptors` has been "
"formalized. Descriptors specify the value of an attribute, stating whether "
"it's a method or a field.  With the descriptor API, static methods and class "
"methods become possible, as well as more exotic constructs."
msgstr ""
"その新しいクラスモデルの根底にあったひとつの大きな着想は、 :dfn:"
"`descriptors` を使ったオブジェクトの属性を記述する API を正式なものにしてしま"
"うことです。デスクリプタは属性の値を記述し、それがメソッドなのかフィールドな"
"のかを伝えます。デスククリプタ API によって、静的メソッドとクラスメソッドが、"
"より風変わりなコンストラクタとともに可能となりました。"

#: ../../whatsnew/2.2.rst:169
msgid ""
"Attribute descriptors are objects that live inside class objects, and have a "
"few attributes of their own:"
msgstr ""
"属性デスクリプタはクラスオブジェクト内部に棲息するオブジェクトで、それ自身の"
"いくつかの属性を持っています:"

#: ../../whatsnew/2.2.rst:172
msgid ":attr:`~definition.__name__` is the attribute's name."
msgstr ":attr:`~definition.__name__` は属性の名前です。"

#: ../../whatsnew/2.2.rst:174
msgid ":attr:`__doc__` is the attribute's docstring."
msgstr ":attr:`__doc__` は属性の docstring です。"

#: ../../whatsnew/2.2.rst:176
msgid ""
"``__get__(object)`` is a method that retrieves the attribute value from "
"*object*."
msgstr "``__get__(object)`` は *object* から属性値を取り出すメソッドです。"

#: ../../whatsnew/2.2.rst:179
msgid "``__set__(object, value)`` sets the attribute on *object* to *value*."
msgstr ""
"``__set__(object, value)`` は *object* の属性に  *value* をセットするメソッド"
"です。"

#: ../../whatsnew/2.2.rst:181
msgid ""
"``__delete__(object, value)`` deletes the *value*  attribute of *object*."
msgstr ""
"``__delete__(object, value)`` は *object* の *value*  属性を削除します。"

#: ../../whatsnew/2.2.rst:183
msgid ""
"For example, when you write ``obj.x``, the steps that Python actually "
"performs are::"
msgstr ""
"例えば、あなたが ``obj.x`` と書いたときに Python が実際に行うことは以下です::"

#: ../../whatsnew/2.2.rst:189
msgid ""
"For methods, :meth:`descriptor.__get__` returns a temporary object that's "
"callable, and wraps up the instance and the method to be called on it. This "
"is also why static methods and class methods are now possible; they have "
"descriptors that wrap up just the method, or the method and the class.  As a "
"brief explanation of these new kinds of methods, static methods aren't "
"passed the instance, and therefore resemble regular functions.  Class "
"methods are passed the class of the object, but not the object itself.  "
"Static and class methods are defined like this::"
msgstr ""
"メソッドに対しては、 :meth:`descriptor.__get__` は、そのインスタンスとその上"
"で呼び出されるメソッドをまとめた、呼び出し可能な一時オブジェクトを返します,こ"
"れはどうして静的メソッドとクラスメソッドが今や可能となったのか、の理由でもあ"
"ります; それらは各々、メソッドだけ、メソッドとクラスをまとめる、とするデスク"
"リプタを持っているのです。これら新種のメソッドの簡単な説明としては、静的メ"
"ソッドはインスタンスを渡さないので、普通の関数に似ていて、クラスメソッドはオ"
"ブジェクトそのものではなくクラスを渡します。静的メソッドとクラスメソッドはこ"
"のように定義します::"

#: ../../whatsnew/2.2.rst:207
msgid ""
"The :func:`staticmethod` function takes the function :func:`f`, and returns "
"it wrapped up in a descriptor so it can be stored in the class object.  You "
"might expect there to be special syntax for creating such methods (``def "
"static f``, ``defstatic f()``, or something like that) but no such syntax "
"has been defined yet; that's been left for future versions of Python."
msgstr ""
":func:`staticmethod` 関数は関数 :func:`f` を引数に取り、デスクリプタにまとめ"
"あげて返しますので、クラスオブジェクト内に格納出来ます。きっとあなたがそのよ"
"うなメソッドを作る何か特別な文法を期待するでしょう(``def static f``, "
"``defstatic f()`` みたいな、あるいはそんななにか)が、まだありません; 将来バー"
"ジョンの Python に期待、です(訳注: Python 2.4 で PEP 318 として実現)。"

#: ../../whatsnew/2.2.rst:213
msgid ""
"More new features, such as slots and properties, are also implemented as new "
"kinds of descriptors, and it's not difficult to write a descriptor class "
"that does something novel.  For example, it would be possible to write a "
"descriptor class that made it possible to write Eiffel-style preconditions "
"and postconditions for a method.  A class that used this feature might be "
"defined like this::"
msgstr ""
"スロットとプロパティのような新機能がさらに新種のデスクリプタとして実装され、"
"また、何か奇抜なデスクリプタクラスを書くことは難しくはありません。例えば、"
"Eiffel 言語スタイルのメソッドに対する事前条件・事後条件を書くことを可能とする"
"デスクリプタクラスを書けるかもしれません。それを使ったクラスはきっとこう定義"
"出来るでしょう::"

#: ../../whatsnew/2.2.rst:235
msgid ""
"Note that a person using the new :func:`eiffelmethod` doesn't have to "
"understand anything about descriptors.  This is why I think the new features "
"don't increase the basic complexity of the language. There will be a few "
"wizards who need to know about it in order to write :func:`eiffelmethod` or "
"the ZODB or whatever, but most users will just write code on top of the "
"resulting libraries and ignore the implementation details."
msgstr ""
"新しい :func:`eiffelmethod` を使う人にとっては、デスクリプタについての何らか"
"も理解する必要がないことに注目してください。これが私が新機能が言語の基本的な"
"複雑さを増さないのだと考える理由です。例えば :func:`eiffelmethod` やら ZODB "
"やらなんやらを書くためにそれを知る必要がある、限られた陰陽道使いがいるという"
"ことです。そして大半のユーザは出来上がったライブラリの頂上部を使ってコードを"
"書くだけのことで、実装の詳細なんかは気にしません。"

#: ../../whatsnew/2.2.rst:244
msgid "Multiple Inheritance: The Diamond Rule"
msgstr "多重継承: ダイヤモンドルール"

#: ../../whatsnew/2.2.rst:246
msgid ""
"Multiple inheritance has also been made more useful through changing the "
"rules under which names are resolved.  Consider this set of classes (diagram "
"taken from :pep:`253` by Guido van Rossum)::"
msgstr ""
"多重継承は名前解決のルールの変更を経てより有用なものになっています。クラスの"
"このようなセットを考えてみましょう (ダイアグラムは Guido van Rossum による :"
"pep:`253` より)::"

#: ../../whatsnew/2.2.rst:264
msgid ""
"The lookup rule for classic classes is simple but not very smart; the base "
"classes are searched depth-first, going from left to right.  A reference to :"
"meth:`D.save` will search the classes :class:`D`, :class:`B`, and then :"
"class:`A`, where :meth:`save` would be found and returned.  :meth:`C.save` "
"would never be found at all.  This is bad, because if :class:`C`'s :meth:"
"`save` method is saving some internal state specific to :class:`C`, not "
"calling it will result in that state never getting saved."
msgstr ""
"クラシッククラスでの探索ルールは単純ですがあまりスマートではありません; 基底"
"クラスは深さ優先で左から右へ検索されます。 :meth:`D.save` への参照は :class:"
"`D`, :class:`B`, :class:`A` と辿って :meth:`save` が見つかるのでこれが返りま"
"す。 :meth:`C.save` はまったく見つけられることはありません。これはよくありま"
"せん。:class:`C` の :meth:`save` が仮に何か :class:`C` に固有な状態を保存する"
"のだとしたら、これを呼ばないことはその状態が決して保存されないことに繋がりま"
"す。"

#: ../../whatsnew/2.2.rst:272
msgid ""
"New-style classes follow a different algorithm that's a bit more complicated "
"to explain, but does the right thing in this situation. (Note that Python "
"2.3 changes this algorithm to one that produces the same results in most "
"cases, but produces more useful results for really complicated inheritance "
"graphs.)"
msgstr ""
"新スタイルクラスはちょっと説明するのに複雑な違ったアルゴリズムを使い、この状"
"況では正しいことをします(Python 2.3 ではこのアルゴリズムはさらに変更されて、"
"ほとんどのケースで同じ結果となり、本当に複雑な継承グラフの場合にもっと有用な"
"結果となりました)。"

#: ../../whatsnew/2.2.rst:277
msgid ""
"List all the base classes, following the classic lookup rule and include a "
"class multiple times if it's visited repeatedly.  In the above example, the "
"list of visited classes is [:class:`D`, :class:`B`, :class:`A`, :class:`C`, :"
"class:`A`]."
msgstr ""
"基底クラス全てを、クラシックな検索ルールに従って検索し、繰り返し訪れるなら複"
"数回含めます。上の例の場合は訪問クラスのリストは [:class:`D`, :class:`B`, :"
"class:`A`, :class:`C`, :class:`A`] となります。"

#: ../../whatsnew/2.2.rst:282
msgid ""
"Scan the list for duplicated classes.  If any are found, remove all but one "
"occurrence, leaving the *last* one in the list.  In the above example, the "
"list becomes [:class:`D`, :class:`B`, :class:`C`, :class:`A`] after dropping "
"duplicates."
msgstr ""
"リストから重複クラスを探します。もしあれば、 *最後* に現れる一つだけ残して全"
"て削除します。上の例の場合、リストは重複削除後 [:class:`D`, :class:`B`, :"
"class:`C`, :class:`A`] になります。"

#: ../../whatsnew/2.2.rst:287
msgid ""
"Following this rule, referring to :meth:`D.save` will return :meth:`C.save`, "
"which is the behaviour we're after.  This lookup rule is the same as the one "
"followed by Common Lisp.  A new built-in function, :func:`super`, provides a "
"way to get at a class's superclasses without having to reimplement Python's "
"algorithm. The most commonly used form will be  ``super(class, obj)``, which "
"returns  a bound superclass object (not the actual class object).  This form "
"will be used in methods to call a method in the superclass; for example, :"
"class:`D`'s :meth:`save` method would look like this::"
msgstr ""
"このルールに従うと :meth:`D.save` 参照は :meth:`C.save` を返します。これが"
"我々が望んだ振る舞いです。この探索ルールは Common Lisp に倣ったものです。新し"
"い組み込み関数 :func:`super` は Python のアルゴリズムを再実装する必要なくクラ"
"スのスーパークラスを得る手段を提供します。その最も一般的な用法は "
"``super(class, obj)`` とすることで束縛されたスーパークラスのオブジェクト(実際"
"のクラスオブジェクトではなく)を取得することです。この形式はスーパークラス内の"
"メソッドを呼び出すメソッドで使われるでしょう。例えば :class:`D` の :meth:"
"`save` メソッドはこのように呼び出すことが出来ます::"

#: ../../whatsnew/2.2.rst:303
msgid ""
":func:`super` can also return unbound superclass objects when called as "
"``super(class)`` or ``super(class1, class2)``, but this probably won't often "
"be useful."
msgstr ""
":func:`super` は ``super(class)`` や ``super(class1, class2)`` のように呼ばれ"
"れば非束縛のスーパークラスオブジェクトも返せますが、これはあまり役には立たな"
"いでしょう。"

#: ../../whatsnew/2.2.rst:309
msgid "Attribute Access"
msgstr "属性アクセス"

#: ../../whatsnew/2.2.rst:311
msgid ""
"A fair number of sophisticated Python classes define hooks for attribute "
"access using :meth:`__getattr__`; most commonly this is done for "
"convenience, to make code more readable by automatically mapping an "
"attribute access such as ``obj.parent`` into a method call such as ``obj."
"get_parent``.  Python 2.2 adds some new ways of controlling attribute access."
msgstr ""
"かなりの数の洗練された Python クラスが、 :meth:`__getattr__` を使って属性アク"
"セスのフックを定義しています; もっとも一般的なのは、 ``obj.parent`` のような"
"属性アクセスを ``obj.get_parent`` のようなメソッド呼び出しに自動的にマッピン"
"グすることによって、コードを読みやすくするための便宜としてです。Python 2.2 は"
"属性アクセスをコントロールする新しい方法を追加しました。"

#: ../../whatsnew/2.2.rst:317
msgid ""
"First, ``__getattr__(attr_name)`` is still supported by new-style classes, "
"and nothing about it has changed.  As before, it will be called when an "
"attempt is made to access ``obj.foo`` and no attribute named ``foo`` is "
"found in the instance's dictionary."
msgstr ""
"まず、 ``__getattr__(attr_name)`` は新スタイルクラスにおいてもなおサポートさ"
"れ、変更はありません。これまで同様に、 ``obj.foo`` アクセスが試みられて、イン"
"スタンスの辞書に ``foo`` 名の属性が見つからなければ呼び出されます。"

#: ../../whatsnew/2.2.rst:322
msgid ""
"New-style classes also support a new method, "
"``__getattribute__(attr_name)``.  The difference between the two methods is "
"that :meth:`__getattribute__` is *always* called whenever any attribute is "
"accessed, while the old :meth:`__getattr__` is only called if ``foo`` isn't "
"found in the instance's dictionary."
msgstr ""
"新スタイルクラスでは新しいメソッド ``__getattribute__(attr_name)`` もサポート"
"されます。 2 つのメソッドの違いは、古いほうの :meth:`__getattr__` が ``foo`` "
"がインスタンスの辞書に見つからなかった場合のみ呼ばれる一方で、 :meth:"
"`__getattribute__` は任意の属性アクセスがあればいつでも *常に* 呼び出されるこ"
"とです。"

#: ../../whatsnew/2.2.rst:328
msgid ""
"However, Python 2.2's support for :dfn:`properties` will often be a simpler "
"way to trap attribute references.  Writing a :meth:`__getattr__` method is "
"complicated because to avoid recursion you can't use regular attribute "
"accesses inside them, and instead have to mess around with the contents of :"
"attr:`~object.__dict__`. :meth:`__getattr__` methods also end up being "
"called by Python when it checks for other methods such as :meth:`__repr__` "
"or :meth:`__coerce__`, and so have to be written with this in mind. Finally, "
"calling a function on every attribute access results in a sizable "
"performance loss."
msgstr ""
"しかしながら、Python 2.2 の :dfn:`properties` サポートは、しばしば属性参照を"
"トラップするより簡単な方法になります。 :meth:`__getattr__` メソッドの記述が複"
"雑になるのは、再帰を避けるために内部では普通の属性アクセスが出来ず、代わり"
"に :attr:`~object.__dict__` の中身をもてあそぶ必要があるからです。 :meth:"
"`__getattr__` メソッド は、 :meth:`__repr__` や :meth:`__coerce__` のようなほ"
"かのメソッドのためにチェックするのにも結局 Python によって呼び出されるので、"
"これを念頭に置いて書かなければなりません。挙句、属性アクセスのたびに毎回関数"
"を呼び出すことは、かなり大きなパフォーマンスロスに繋がります。"

#: ../../whatsnew/2.2.rst:337
msgid ""
":class:`property` is a new built-in type that packages up three functions "
"that get, set, or delete an attribute, and a docstring.  For example, if you "
"want to define a :attr:`size` attribute that's computed, but also settable, "
"you could write::"
msgstr ""
":class:`property` は新しい組み込み型で、属性の get, set, delete の 3 つの関数"
"と docstring を梱包したものです。例えば、計算で求まるけれども設定も出来る :"
"attr:`size` 属性を定義したいとすると、このように書けます::"

#: ../../whatsnew/2.2.rst:357
msgid ""
"That is certainly clearer and easier to write than a pair of :meth:"
"`__getattr__`/:meth:`__setattr__` methods that check for the :attr:`size` "
"attribute and handle it specially while retrieving all other attributes from "
"the instance's :attr:`~object.__dict__`.  Accesses to :attr:`size` are also "
"the only ones which have to perform the work of calling a function, so "
"references to other attributes run at their usual speed."
msgstr ""
"これは確実に、より明快であり書くのが容易です。 :meth:`__getattr__`/:meth:"
"`__setattr__` メソッドのペアでは、全てのほかの属性をインスタンスの :attr:"
"`~object.__dict__` から抽出しながら :attr:`size` 属性を特別に処理しなければな"
"らないところでした。:attr:`size` へのアクセス時に行われるのは仕掛けた関数を呼"
"び出すことだけなので、ほかの属性への参照が速度を落とすことはありません。"

#: ../../whatsnew/2.2.rst:364
msgid ""
"Finally, it's possible to constrain the list of attributes that can be "
"referenced on an object using the new :attr:`~object.__slots__` class "
"attribute. Python objects are usually very dynamic; at any time it's "
"possible to define a new attribute on an instance by just doing ``obj."
"new_attr=1``.   A new-style class can define a class attribute named :attr:"
"`~object.__slots__` to limit the legal attributes  to a particular set of "
"names.  An example will make this clear::"
msgstr ""
"もう一つ最後、新しいクラス属性 :attr:`~object.__slots__` を使うと、オブジェク"
"トで参照出来る属性リストを制約することが出来ます。Python オブジェクトは普通非"
"常に動的で、どんなときにもインスタンスに対して単に ``obj.new_attr=1`` とする"
"だけで新しい属性を定義出来ます。新スタイルクラスは :attr:`~object.__slots__` "
"という名前のクラス属性を定義出来、これにより適正な属性名集合を特定の集合に制"
"限出来ます。実例をみるのが早いです::"

#: ../../whatsnew/2.2.rst:385
msgid ""
"Note how you get an :exc:`AttributeError` on the attempt to assign to an "
"attribute not listed in :attr:`~object.__slots__`."
msgstr ""
":attr:`~object.__slots__` リストに含めなかった属性への代入を試みて :exc:"
"`AttributeError` になっていることに注目してください。"

#: ../../whatsnew/2.2.rst:392
msgid "Related Links"
msgstr "関連リンク"

#: ../../whatsnew/2.2.rst:394
msgid ""
"This section has just been a quick overview of the new features, giving "
"enough of an explanation to start you programming, but many details have "
"been simplified or ignored.  Where should you go to get a more complete "
"picture?"
msgstr ""
"このセクションは新機能について、あなたがプログラミングを始める説明としては十"
"分な簡単な概要だけ示しました。ですが、多くの詳細は、単純化したり無視していま"
"す。もっと完全な光景を眺めたければ、どこに行けば良いでしょうか?"

#: ../../whatsnew/2.2.rst:398
msgid ""
"The :ref:`descriptorhowto` is a lengthy tutorial introduction to the "
"descriptor features, written by Guido van Rossum. If my description has "
"whetted your appetite, go read this tutorial next, because it goes into much "
"more detail about the new features while still remaining quite easy to read."
msgstr ""

#: ../../whatsnew/2.2.rst:403
msgid ""
"Next, there are two relevant PEPs, :pep:`252` and :pep:`253`.  :pep:`252` is "
"titled \"Making Types Look More Like Classes\", and covers the descriptor "
"API. :pep:`253` is titled \"Subtyping Built-in Types\", and describes the "
"changes to type objects that make it possible to subtype built-in objects.  :"
"pep:`253` is the more complicated PEP of the two, and at a few points the "
"necessary explanations of types and meta-types may cause your head to "
"explode.  Both PEPs were written and implemented by Guido van Rossum, with "
"substantial assistance from the rest of the Zope Corp. team."
msgstr ""
"次です。2 つの関連する PEP、 :pep:`252`, :pep:`253` があります。 :pep:`252` "
"は \"型をもっとクラスに似せる(Making Types Look More Like Classes)\" というタ"
"イトルで、デスクリプタ API についてカバーしています。 :pep:`253` は \"組み込"
"み型のサブタイプ化(Subtyping Built-in Types)\" というタイトルで、組み込み型の"
"サブタイプを可能とするための型オブジェクトの変更について記述しています。 :"
"pep:`253` は 252 よりも複雑な PEP で、型とメタ型で必要な説明のいくつかのポイ"
"ントでは、あなたの脳味噌は爆発するかもしれないです。どちらの PEP も、著・実装"
"ともに、Zope Corp. チームの残りのメンバーからのかなりの支援を受けて、Guido "
"van Rossum によって書かれました。"

#: ../../whatsnew/2.2.rst:412
msgid ""
"Finally, there's the ultimate authority: the source code.  Most of the "
"machinery for the type handling is in :file:`Objects/typeobject.c`, but you "
"should only resort to it after all other avenues have been exhausted, "
"including posting a question to python-list or python-dev."
msgstr ""
"最後ですが、究極の権威があります: ソースコードです。型ハンドリングのほとんど"
"の機構は :file:`Objects/typeobject.c` 内にあります。ただしこれに頼るのは、"
"python-list や python-dev へ質問を投稿することを含むほかの全ての手段を使い果"
"たしたのちの最後の手段にしてください。"

#: ../../whatsnew/2.2.rst:421
msgid "PEP 234: Iterators"
msgstr "PEP 234: イテレータ"

#: ../../whatsnew/2.2.rst:423
msgid ""
"Another significant addition to 2.2 is an iteration interface at both the C "
"and Python levels.  Objects can define how they can be looped over by "
"callers."
msgstr ""
"2.2 でのもう一つの重要な追加は、C と Python レベル両方に対するイテレーション"
"インターフェイスです。オブジェクトが呼び出し元からどのように反復されるのか定"
"義出来ます。"

#: ../../whatsnew/2.2.rst:426
msgid ""
"In Python versions up to 2.1, the usual way to make ``for item in obj`` work "
"is to define a :meth:`__getitem__` method that looks something like this::"
msgstr ""
"2.1 までの Python では ``for item in obj`` が動作するようにするための手段は普"
"通、 :meth:`__getitem__` メソッドをおよそこのような具合に定義することです::"

#: ../../whatsnew/2.2.rst:432
msgid ""
":meth:`__getitem__` is more properly used to define an indexing operation on "
"an object so that you can write ``obj[5]`` to retrieve the sixth element.  "
"It's a bit misleading when you're using this only to support :keyword:`for` "
"loops. Consider some file-like object that wants to be looped over; the "
"*index* parameter is essentially meaningless, as the class probably assumes "
"that a series of :meth:`__getitem__` calls will be made with *index* "
"incrementing by one each time.  In other words, the presence of the :meth:"
"`__getitem__` method doesn't mean that using ``file[5]``  to randomly access "
"the sixth element will work, though it really should."
msgstr ""
":meth:`__getitem__` はもっと相応しい用途、つまり 6 番目の要素を取り出すため"
"に ``obj[5]`` と書くことが出来るようにオブジェクトへの添え字操作を定義するの"
"に使うものです。 :keyword:`for` ループをサポートするためだけにこれを使うこと"
"は、少しばかり人を欺いてしまいます。なにかファイルのように振舞うオブジェクト"
"を巡回出来るようにしたいとしましょう; *index* パラメータは本質的に無意味で"
"す。そのクラスはおそらく :meth:`__getitem__` 呼び出しの連続で呼ばれるたびに "
"*index* を加算して然るべきだと考えるでしょう。言い換えれば、 :meth:"
"`__getitem__` の存在はランダムに ``file[5]`` を使って 6 番目の要素にアクセス"
"出来ることを意味しません、本来そうであるべきなのに。"

#: ../../whatsnew/2.2.rst:442
msgid ""
"In Python 2.2, iteration can be implemented separately, and :meth:"
"`__getitem__` methods can be limited to classes that really do support "
"random access.  The basic idea of iterators is  simple.  A new built-in "
"function, ``iter(obj)`` or ``iter(C, sentinel)``, is used to get an "
"iterator. ``iter(obj)`` returns an iterator for the object *obj*, while "
"``iter(C, sentinel)`` returns an iterator that will invoke the callable "
"object *C* until it returns *sentinel* to signal that the iterator is done."
msgstr ""
"Python 2.2 においては、イテレーションは分けて定義出来ます。 :meth:"
"`__getitem__` メソッドは本当にランダムアクセスをサポートしたいクラスだけが使"
"えば良いです。イテレータの基礎的なアイディアは単純です。新しいビルトイン関数 "
"``iter(obj)`` または ``iter(C, sentinel)`` は、イテレータを取り出すのに使いま"
"す。 ``iter(obj)`` はオブジェクト  *obj* についてのイテレータを返し、 "
"``iter(C, sentinel)`` は、そのイテレータが完了を表明する *sentinel* を返すま"
"で呼び出し可能オブジェクト *C* を呼び続けるイテレータを返します。"

#: ../../whatsnew/2.2.rst:450
msgid ""
"Python classes can define an :meth:`__iter__` method, which should create "
"and return a new iterator for the object; if the object is its own iterator, "
"this method can just return ``self``.  In particular, iterators will usually "
"be their own iterators.  Extension types implemented in C can implement a :c:"
"member:`~PyTypeObject.tp_iter` function in order to return an iterator, and "
"extension types that want to behave as iterators can define a :c:member:"
"`~PyTypeObject.tp_iternext` function."
msgstr ""
"Python クラスはオブジェクトの新しいイテレータを構築して返す :meth:`__iter__` "
"メソッドを定義出来ます; そのオブジェクト自身が自身のイテレータであれば、この"
"メソッドは単に ``self`` を返すだけで良いです。特に、イテレータは普通自身への"
"イテレータです。C で実装される拡張型はイテレータを返すために :c:member:"
"`~PyTypeObject.tp_iter` 関数を実装出来、イテレータとして振舞いたい拡張型"
"は、 :c:member:`~PyTypeObject.tp_iternext` 関数を実装出来ます。"

#: ../../whatsnew/2.2.rst:457
msgid ""
"So, after all this, what do iterators actually do?  They have one required "
"method, :meth:`next`, which takes no arguments and returns the next value.  "
"When there are no more values to be returned, calling :meth:`next` should "
"raise the :exc:`StopIteration` exception. ::"
msgstr ""
"それでは、結局のところイテレータは実際どんなでしょうか? これに必要なメソッド"
"は一つ、 :meth:`next` です (---訳注: Python 3 で ``__next__`` に変更されてい"
"ます---)。これは引数を取らず、次の値を返します。返すべき値がなくなったら、 :"
"meth:`next` 呼び出しは :exc:`StopIteration` 例外を送出しなければなりません::"

#: ../../whatsnew/2.2.rst:478
msgid ""
"In 2.2, Python's :keyword:`for` statement no longer expects a sequence; it "
"expects something for which :func:`iter` will return an iterator. For "
"backward compatibility and convenience, an iterator is automatically "
"constructed for sequences that don't implement :meth:`__iter__` or a :c:"
"member:`~PyTypeObject.tp_iter` slot, so ``for i in [1,2,3]`` will still "
"work.  Wherever the Python interpreter loops over a sequence, it's been "
"changed to use the iterator protocol.  This means you can do things like "
"this::"
msgstr ""
"2.2 では、Python の :keyword:`for` ステートメントはもはやシーケンスであること"
"を要求しません; それは :func:`iter` がイテレータを返す何かであれば良いです。"
"後方互換と便宜のために、 :meth:`__iter__` や :c:member:`~PyTypeObject."
"tp_iter` スロットを実装しないシーケンスについては、自動的にイテレータが構築さ"
"れるので、 ``for i in [1,2,3]`` はそのまま動きます (---訳注: 2.2 時点では "
"list に ``__iter__`` が実装されていなかったのかもしれませんが、以降の What's "
"New に明示はないものの、少なくとも 2.7 の list はイテレータプロトコルを実装し"
"ています。---)。Python インタプリタがシーケンスを反復する場合にはいつでも、そ"
"れはイテレータプロトコルの使用に変換されます。つまりこんなことが出来るという"
"ことです::"

#: ../../whatsnew/2.2.rst:492
msgid ""
"Iterator support has been added to some of Python's basic types.   Calling :"
"func:`iter` on a dictionary will return an iterator which loops over its "
"keys::"
msgstr ""
"いくつかの Python の基礎型には既にイテレータのサポートが追加されています。辞"
"書に対して :func:`iter` を呼び出すと、キーの反復をするイテレータが返ります::"

#: ../../whatsnew/2.2.rst:512
msgid ""
"That's just the default behaviour.  If you want to iterate over keys, "
"values, or key/value pairs, you can explicitly call the :meth:`iterkeys`, :"
"meth:`itervalues`, or :meth:`iteritems` methods to get an appropriate "
"iterator. In a minor related change, the :keyword:`in` operator now works on "
"dictionaries, so ``key in dict`` is now equivalent to ``dict.has_key(key)``."
msgstr ""
":func:`iter` がキーでの反復イテレータを返すのはただのデフォルトの振る舞いで"
"す。キーで、値で、キーと値のペアで反復したければ、 :meth:`iterkeys`, :meth:"
"`itervalues`, :meth:`iteritems` で適切なイテレータを取れます (---訳注: "
"Python 3 では対応するメソッド名が ``keys``, ``values``, ``items`` に変わった"
"だけでなく、これらは「ビュー」オブジェクトを返すように変更されています。---) "
"ほかに小さな変更点としては、 :keyword:`in` 演算子は今では辞書に対して動作"
"し、 ``key in dict`` は ``dict.has_key(key)`` と等価です (---訳注: Python 3 "
"では辞書オブジェクトのメソッド ``has_key`` はなくなり、 ``key in dict`` が"
"キー有無を直接問い合わせる唯一の方法です---)。"

#: ../../whatsnew/2.2.rst:518
msgid ""
"Files also provide an iterator, which calls the :meth:`readline` method "
"until there are no more lines in the file.  This means you can now read each "
"line of a file using code like this::"
msgstr ""
"ファイルもイテレータを提供しています。これはファイルに読むべき行がなくなるま"
"で :meth:`readline` を呼び出すもので、つまりファイルを行ごとに読み出すのにこ"
"のように書けるわけです::"

#: ../../whatsnew/2.2.rst:526
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it. An iterator "
"object could provide such additional capabilities, but the iterator protocol "
"only requires a :meth:`next` method."
msgstr ""
"イテレータは前進しか出来ないことに注意してください; 前の要素を取り出す手段も"
"なければ、イテレータをリセットしたりコピーしたりといったことも出来ません。イ"
"テレータオブジェクトにそのような追加の能力を持たせることは出来ますが、イテ"
"レータプロトコルが規定するのは :meth:`next` メソッドのみです。"

#: ../../whatsnew/2.2.rst:535
msgid ":pep:`234` - Iterators"
msgstr ":pep:`234`: イテレータ"

#: ../../whatsnew/2.2.rst:535
msgid ""
"Written by Ka-Ping Yee and GvR; implemented  by the Python Labs crew, mostly "
"by GvR and Tim Peters."
msgstr ""
"著: Ka-Ping Yee と GvR (Guido van Rossum); 実装: Python Labs クルー, 主に "
"GvR と Tim Peters."

#: ../../whatsnew/2.2.rst:542
msgid "PEP 255: Simple Generators"
msgstr "PEP 255: 単純なジェネレータ"

#: ../../whatsnew/2.2.rst:544
msgid ""
"Generators are another new feature, one that interacts with the introduction "
"of iterators."
msgstr ""
"ジェネレータはもう一つの新機能で、これはイテレータの導入と連携するものです。"

#: ../../whatsnew/2.2.rst:547
msgid ""
"You're doubtless familiar with how function calls work in Python or C.  When "
"you call a function, it gets a private namespace where its local variables "
"are created.  When the function reaches a :keyword:`return` statement, the "
"local variables are destroyed and the resulting value is returned to the "
"caller.  A later call to the same function will get a fresh new set of local "
"variables. But, what if the local variables weren't thrown away on exiting a "
"function? What if you could later resume the function where it left off?  "
"This is what generators provide; they can be thought of as resumable "
"functions."
msgstr ""
"Python や C の標準的な関数コールについては、よくご存じに違いありません。関数"
"を呼ぶと、ローカル変数を作るプライベートな名前空間ができますね。その関数が :"
"keyword:`return` 文まで来ると、ローカル変数が破壊されてから、返り値が呼び出し"
"元に返ります。次に同じ関数をもう一度呼ぶと、新しいプライベート名前空間に新規"
"のローカル変数が作られるのです。しかし、関数を出るときにローカル変数を捨てな"
"ければどうなるでしょうか。その出ていったところから関数を続行できたとしたら、"
"どうでしょう。これこそジェネレータが提供する機能です; すなわち、ジェネレータ"
"は続行できる関数と考えることができます。"

#: ../../whatsnew/2.2.rst:556
msgid "Here's the simplest example of a generator function::"
msgstr "ジェネレータ関数の最も単純な例です::"

#: ../../whatsnew/2.2.rst:562
msgid ""
"A new keyword, :keyword:`yield`, was introduced for generators.  Any "
"function containing a :keyword:`!yield` statement is a generator function; "
"this is detected by Python's bytecode compiler which compiles the function "
"specially as a result.  Because a new keyword was introduced, generators "
"must be explicitly enabled in a module by including a ``from __future__ "
"import generators`` statement near the top of the module's source code.  In "
"Python 2.3 this statement will become unnecessary."
msgstr ""
"新しいキーワード :keyword:`yield` がジェネレータのために導入されました。 :"
"keyword:`!yield` ステートメントを含むどんな関数もジェネレータ関数です; "
"Python バイトコードコンパイラはこれを検知し、関数が特別に扱われるように翻訳し"
"ます。新たなキーワードの導入なので、ジェネレータを使えるようにするには "
"``from __future__ import generators`` ステートメントをモジュールソースコード"
"の先頭付近に含めなければなりません。Python 2.3 ではこのステートメントは不要に"
"なります。(---訳注: Python 2.5 の PEP 342 も参照して下さい。この 2.2 で導入時"
"点の ``yield`` はステートメントではなく式に変更されています。---)"

#: ../../whatsnew/2.2.rst:570
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the :keyword:`yield` statement, the generator outputs the value "
"of ``i``, similar to a :keyword:`return` statement.  The big difference "
"between :keyword:`!yield` and a :keyword:`!return` statement is that on "
"reaching a :keyword:`!yield` the generator's state of execution is suspended "
"and local variables are preserved.  On the next call to the generator's "
"``next()`` method, the function will resume executing immediately after the :"
"keyword:`!yield` statement.  (For complicated reasons, the :keyword:`!yield` "
"statement isn't allowed inside the :keyword:`!try` block of a :keyword:"
"`try`...\\ :keyword:`finally` statement; read :pep:`255` for a full "
"explanation of the interaction between :keyword:`!yield` and exceptions.)"
msgstr ""
"ジェネレータ関数を呼び出すと、単一の値の代わりにイテレータプロトコルに対応し"
"たオブジェクトを返します。上の例で :keyword:`!yield` を実行したとき、ジェネ"
"レータは :keyword:`!return` 文のようにして ``i`` の値を生成します。 "
"``yield`` と ``return`` 文の大きな違いは、 ``yield`` に到達した段階でジェネ"
"レータの実行状態が一時停止になって、ローカル変数が保存される点です。次回その"
"ジェネレータの ``.next()`` メソッドを呼ぶと、 :keyword:`!yield` の直後から関"
"数が実行を再開します。(複雑な理由により、 :keyword:`!yield` は :keyword:`!"
"try`...\\ :keyword:`finally` の :keyword:`!try` ブロック内に含めることは許さ"
"れていません; :pep:`255` に :keyword:`!yield` と例外の相互作用についての詳細"
"説明がありますので参照して下さい。) --- (---訳注: Python 2.5 の PEP 342 で :"
"keyword:`try`...\\ :keyword:`finally` 内に置けないという制約はなくなりまし"
"た。また、 :keyword:`try`...\\ :keyword:`finally` の :keyword:`try` 、とここ"
"であえて特定しているのは、同じく 2.5 の PEP 341 によって try/except/finally "
"の一体化されるまでは、 ``finally`` の ``try`` と ``except`` の ``try`` が別物"
"だったからです。---)"

#: ../../whatsnew/2.2.rst:583
msgid "Here's a sample usage of the :func:`generate_ints` generator::"
msgstr "上記 ``generate_ints()`` ジェネレータはこんな具合に使います::"

#: ../../whatsnew/2.2.rst:600
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a,b,c = "
"generate_ints(3)``."
msgstr ""
"同じく ``for i in generate_ints(5)`` や ``a,b,c = generate_ints(3)`` といった"
"書き方もできます。"

#: ../../whatsnew/2.2.rst:603
msgid ""
"Inside a generator function, the :keyword:`return` statement can only be "
"used without a value, and signals the end of the procession of values; "
"afterwards the generator cannot return any further values. :keyword:`!"
"return` with a value, such as ``return 5``, is a syntax error inside a "
"generator function.  The end of the generator's results can also be "
"indicated by raising :exc:`StopIteration` manually, or by just letting the "
"flow of execution fall off the bottom of the function."
msgstr ""
"ジェネレータ関数内で :keyword:`return` 文は、引数を付けずに、処理の終わりを知"
"らせるためにだけ使うことができます; ``return`` を実行したあとは、もうそのジェ"
"ネレータが値を返すことはできません。ジェネレータ関数の中では、 ``return 5`` "
"などと値を付けた :keyword:`!return` は構文エラーです。ジェネレータの出力が終"
"わったことを示すには、ほかにも、手動で :exc:`StopIteration`  を投げてもいいで"
"すし、関数の最後まで実行するだけでも同じことになります。(---訳注: Python 2.7 "
"まではジェネレータ内での戻り値のある ``return 5`` は構文エラーになりますが、"
"少なくとも Python 3.4 で構文エラーとはなりません。単に無視されます。リファレ"
"ンスに言及されていない振舞いなので、何かの事故かもしれません。いずれにせよ"
"ジェネレータ内では Python 3 でも ``return`` で値は戻せません。---)"

#: ../../whatsnew/2.2.rst:611
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`next` method increment "
"``self.count`` and return it. However, for a moderately complicated "
"generator, writing a corresponding class would be much messier. :file:`Lib/"
"test/test_generators.py` contains a number of more interesting examples.  "
"The simplest one implements an in-order traversal of a tree using generators "
"recursively. ::"
msgstr ""
"自分でクラスを書いて、ジェネレータで言うところのローカル変数をインスタンス変"
"数として全部保管しておけば、同じ効果を得ることは可能です。たとえば整数のリス"
"トを返すのは、 ``self.count`` を 0 にして、 :meth:`next` メソッドが ``self."
"count`` をインクリメントして返すようにすればできます。しかしながら、ある程度"
"複雑なジェネレータになってくると、同じことをするクラスを書くのは格段にややこ"
"しいことになります。 :file:`Lib/test/test_generators.py` にはもっと面白い例が"
"たくさん含まれています。一番単純な一つは、ジェネレータを再帰的に使ってツリー"
"を順繰りに横断する実装をするこれです (---訳注: ジェネレータは現在の最新 3.5 "
"までの間に 2 度大きな機能強化が行われているのですが、一つが 2.5 での PEP 342 "
"でこれは yield 「に」値を戻せるようにするものです。もう一つが 3.3 での PEP "
"380 で、これはサブジェネレータへの委譲 ``yield from <subgen>`` の追加でした。"
"ですのでこの 3.3 からの ``yield from`` を使うと下記例はもっとスッキリ書けま"
"す。---)::"

#: ../../whatsnew/2.2.rst:629
msgid ""
"Two other examples in :file:`Lib/test/test_generators.py` produce solutions "
"for the N-Queens problem (placing $N$ queens on an $NxN$ chess board so that "
"no queen threatens another) and the Knight's Tour (a route that takes a "
"knight to every square of an $NxN$ chessboard without visiting any square "
"twice)."
msgstr ""
"ほかにも :file:`Lib/test/test_generators.py` には、N-Queens 問題 (N×N コマの"
"チェス盤に、互いに攻撃できないような配置で N 個のクイーンを置く) やナイト・ツ"
"アー (N×N 盤の全コマをナイトが一度ずつ通るような経路を探す) の解を出す例が"
"入っています。"

#: ../../whatsnew/2.2.rst:634
msgid ""
"The idea of generators comes from other programming languages, especially "
"Icon (https://www.cs.arizona.edu/icon/), where the idea of generators is "
"central.  In Icon, every expression and function call behaves like a "
"generator.  One example from \"An Overview of the Icon Programming "
"Language\" at https://www.cs.arizona.edu/icon/docs/ipd266.htm gives an idea "
"of what this looks like::"
msgstr ""
"ジェネレータの発想はほかのプログラミング言語、特に Icon (https://www.cs."
"arizona.edu/icon/) から着想しています。Icon ではジェネレータが言語の中枢に"
"なっています。Icon では、あらゆる式と関数がジェネレータのように振舞います。 "
"https://www.cs.arizona.edu/icon/docs/ipd266.htm の \"Icon プログラミング言語"
"の概要\" の一つの例が、これがどのようなものであるのかを教えてくれます::"

#: ../../whatsnew/2.2.rst:644
msgid ""
"In Icon the :func:`find` function returns the indexes at which the substring "
"\"or\" is found: 3, 23, 33.  In the :keyword:`if` statement, ``i`` is first "
"assigned a value of 3, but 3 is less than 5, so the comparison fails, and "
"Icon retries it with the second value of 23.  23 is greater than 5, so the "
"comparison now succeeds, and the code prints the value 23 to the screen."
msgstr ""
"Icon では :func:`find` 関数は部分文字列 \"or\" が見つかる位置 3, 23, 33 を返"
"します。 :keyword:`if` 文内では ``i`` には最初 3 が代入されますが、これは 3 "
"より小さいので比較は失敗し、Icon は次の値 23 を取り出します。 23 は 5 より大"
"きいので比較は成功し、コードは 23 をスクリーンに表示します。"

#: ../../whatsnew/2.2.rst:650
msgid ""
"Python doesn't go nearly as far as Icon in adopting generators as a central "
"concept.  Generators are considered a new part of the core Python language, "
"but learning or using them isn't compulsory; if they don't solve any "
"problems that you have, feel free to ignore them. One novel feature of "
"Python's interface as compared to Icon's is that a generator's state is "
"represented as a concrete object (the iterator) that can be passed around to "
"other functions or stored in a data structure."
msgstr ""
"Python では Icon がそうするほどにはジェネレータを中心的概念に置きません。ジェ"
"ネレータは Python 言語中核の新たな一面ではありますが、それらを学ぶのも使うの"
"も誰しも行うべきだというものでもなく、そしてこれで解決できない何か問題があれ"
"ば、忘れてしまっても良いものです。Icon と比較した特筆すべき Python インター"
"フェイスの機能はジェネレータの状態が具象オブジェクト (イテレータ) で表現され"
"ることであり、それは他の関数に渡せますし、データ構造に記憶しておくことも出来"
"ます。(---訳注: ジェネレータについてかなり控えめなのは、この時点で著者は将来"
"の拡張を既に見据えていたから? かもしれませんね。PEP 342 と PEP 380 により今や"
"ジェネレータはこの頃より遥かに高機能になっており、今ではきっと「こんなものな"
"くても困らない」なんて Python 使いはいないでしょう。---)"

#: ../../whatsnew/2.2.rst:662
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - 単純なジェネレータ"

#: ../../whatsnew/2.2.rst:662
msgid ""
"Written by Neil Schemenauer, Tim Peters, Magnus Lie Hetland.  Implemented "
"mostly by Neil Schemenauer and Tim Peters, with other fixes from the Python "
"Labs crew."
msgstr ""
"Neil Schemenauer, Tim Peters, Magnus Lie Hetland により著されました。実装のほ"
"とんどは Neil Schemenauer と Tim Peters により行われ、 Python Labs クルーによ"
"り他の修正が行われました。"

#: ../../whatsnew/2.2.rst:669
msgid "PEP 237: Unifying Long Integers and Integers"
msgstr "PEP 237: 長整数と整数を一体化していく"

#: ../../whatsnew/2.2.rst:671
msgid ""
"In recent versions, the distinction between regular integers, which are 32-"
"bit values on most machines, and long integers, which can be of arbitrary "
"size, was becoming an annoyance.  For example, on platforms that support "
"files larger than ``2**32`` bytes, the :meth:`tell` method of file objects "
"has to return a long integer. However, there were various bits of Python "
"that expected plain integers and would raise an error if a long integer was "
"provided instead.  For example, in Python 1.5, only regular integers could "
"be used as a slice index, and ``'abc'[1L:]`` would raise a :exc:`TypeError` "
"exception with the message 'slice index must be int'."
msgstr ""
"最近のバージョンでは、普通の整数、これはほとんどの機器で 32 ビットの値です"
"が、これと長整数、こちらは任意サイズになりえます、この 2 つの区別が、苛立ちの"
"種になってきています。たとえば ``2**32`` より大きなファイルをサポートするプ"
"ラットフォームでは、ファイルオブジェクトの :meth:`tell` メソッドは長整数で値"
"を返さなければなりません。しかしながら Python の様々な場所では無印の整数を期"
"待していて、長整数を渡すと例外を引き起こすのでした。例えば Python 1.5 ではス"
"ライスのインデクスとして普通の整数しか使えず、 ``'abc'[1L:]`` は 'slice "
"index must be int' というメッセージとともに :exc:`TypeError` を引き起こしまし"
"た。"

#: ../../whatsnew/2.2.rst:681
msgid ""
"Python 2.2 will shift values from short to long integers as required. The "
"'L' suffix is no longer needed to indicate a long integer literal, as now "
"the compiler will choose the appropriate type.  (Using the 'L' suffix will "
"be discouraged in future 2.x versions of Python, triggering a warning in "
"Python 2.4, and probably dropped in Python 3.0.)  Many operations that used "
"to raise an :exc:`OverflowError` will now return a long integer as their "
"result.  For example::"
msgstr ""
"Python 2.2 は必要に応じて short 整数を長整数に値をシフトします。 'L' サフィッ"
"クスは長整数リテラルを示すのにはもはや不要です。今ではコンパイラは相応しい型"
"を選べます。('L' サフィックスは将来の Python 2.x では非推奨となり、Python "
"2.4 では警告となり、おそらく Python 3.0 では削除されます。 --- 訳注: Python "
"3 で 'L' が廃止されて、付けると構文エラーになるようになったのは事実です。です"
"が少なくとも Python 2.7 では :option:`!-3` でも :option:`!-Qwarnall` でも警告"
"とならないので注意してください。Python 2 系を使っていて Python 3 との互換性を"
"持ちたいならば、 2.2 以降では 'L' は付けるべきではありません。 --- ) かつて :"
"exc:`OverflowError` となっていたような多くの演算が、今ではその結果として長整"
"数を返します。例えば::"

#: ../../whatsnew/2.2.rst:694
msgid ""
"In most cases, integers and long integers will now be treated identically.  "
"You can still distinguish them with the :func:`type` built-in function, but "
"that's rarely needed."
msgstr ""
"ほとんどのケースで、今や整数と長整数は同じものとして扱われるでしょう。 :func:"
"`type` ビルトインで今でも区別出来ますが、ほとんど必要ないでしょう (--- 訳注: "
"Python 3 では本当にこの2つの区別がなくなったので、当然区別出来ません。Python "
"3 系への移行を考えている Python 2 コードは、両者の区別に頼らないようにするべ"
"きです。 ---)。"

#: ../../whatsnew/2.2.rst:702
msgid ":pep:`237` - Unifying Long Integers and Integers"
msgstr ":pep:`237` - 長整数と整数を一体化していく"

#: ../../whatsnew/2.2.rst:702
msgid ""
"Written by Moshe Zadka and Guido van Rossum.  Implemented mostly by Guido "
"van Rossum."
msgstr "Moshe Zadka と Guido van Rossum 著、実装 (ほぼ) Guido van Rossum.。"

#: ../../whatsnew/2.2.rst:709
msgid "PEP 238: Changing the Division Operator"
msgstr "PEP 238: 除算演算子を変更していく"

#: ../../whatsnew/2.2.rst:711
msgid ""
"The most controversial change in Python 2.2 heralds the start of an effort "
"to fix an old design flaw that's been in Python from the beginning. "
"Currently Python's division operator, ``/``, behaves like C's division "
"operator when presented with two integer arguments: it returns an integer "
"result that's truncated down when there would be a fractional part.  For "
"example, ``3/2`` is 1, not 1.5, and ``(-1)/2`` is -1, not -0.5.  This means "
"that the results of division can vary unexpectedly depending on the type of "
"the two operands and because Python is dynamically typed, it can be "
"difficult to determine the possible types of the operands."
msgstr ""
"Python 2.2 の変更で最も物議を醸すものが、Python 誕生時からずっとそうであり続"
"けた古い設計の欠陥、これを修正するための取り組み開始の予兆です。現在の "
"Python の除算演算子 ``/`` は 2 つの整数引数に対して C 言語の除算演算子のよう"
"に振舞います: 端数部があれば切り捨てて整数を結果として返します。例えば "
"``3/2`` は 1.5 ではなく 1 で、 ``(-1)/2`` は -0.5 ではなく -1 です。Python の"
"動的型付けにより演算対象の型がなんなのかを容易には決定できないくせに 2 つの演"
"算対象の型に依存するので、除算の結果は予想に反したものとなりうるのです。"

#: ../../whatsnew/2.2.rst:721
msgid ""
"(The controversy is over whether this is *really* a design flaw, and whether "
"it's worth breaking existing code to fix this.  It's caused endless "
"discussions on python-dev, and in July 2001 erupted into a storm of acidly "
"sarcastic postings on :newsgroup:`comp.lang.python`. I won't argue for "
"either side here and will stick to describing what's  implemented in 2.2.  "
"Read :pep:`238` for a summary of arguments and counter-arguments.)"
msgstr ""
"(議論の的となるのはこれが *本当の* 設計の欠陥なのかどうかと、果たしてこれを修"
"正することで既存のコードを破壊する価値はあるのかどうかです。それは python-"
"dev での終わりのない議論を巻き起こし、2001 年 7 月には :newsgroup:`comp.lang."
"python` への辛辣な投稿の嵐に突入しました。私はここではどちらかの側に立って説"
"きつけるつもりはなく、Python 2.2 で何が実現したのかを記述することだけに専念し"
"ます。:pep:`238` にはその主張と反対意見の要約が書かれていますので、そちらをお"
"読みください。)"

#: ../../whatsnew/2.2.rst:728
msgid ""
"Because this change might break code, it's being introduced very gradually. "
"Python 2.2 begins the transition, but the switch won't be complete until "
"Python 3.0."
msgstr ""
"この変更がコードを破壊しうるために、導入は大変ゆっくり少しずつ進められていき"
"ます。Python 2.2 が移行を始めますが、切り替えは Python 3.0 になるまで達成させ"
"られることはありません。"

#: ../../whatsnew/2.2.rst:732
msgid ""
"First, I'll borrow some terminology from :pep:`238`.  \"True division\" is "
"the division that most non-programmers are familiar with: 3/2 is 1.5, 1/4 is "
"0.25, and so forth.  \"Floor division\" is what Python's ``/`` operator "
"currently does when given integer operands; the result is the floor of the "
"value returned by true division.  \"Classic division\" is the current mixed "
"behaviour of ``/``; it returns the result of floor division when the "
"operands are integers, and returns the result of true division when one of "
"the operands is a floating-point number."
msgstr ""
"まず最初に、いくつか :pep:`238` から用語を借りることにします。\n"
"\"真の除算 (True division)\" とは、プログラマでない人々が一番馴染みのある除算"
"です。\n"
"3/2 は 1.5、1/4 は 0.25、などなど。\n"
"\"切り捨て除算 (Floor division)\" は、整数の被演算子が与えられたときの "
"Python の ``/`` 演算子が現在やっていることで、結果は真の除算の結果の値の小数"
"点以下を小さくなる方向へ丸めたものです。\n"
"\"クラシック除算 (Classic division)\" は現在の ``/`` の混合した振る舞いを指し"
"ます。演算対象が整数同士であれば切り捨て除算の結果となり、一方が浮動小数点数"
"であれば真の除算の結果となる振る舞いです。"

#: ../../whatsnew/2.2.rst:740
msgid "Here are the changes 2.2 introduces:"
msgstr "以下が 2.2 で導入される変更です:"

#: ../../whatsnew/2.2.rst:742
msgid ""
"A new operator, ``//``, is the floor division operator. (Yes, we know it "
"looks like C++'s comment symbol.)  ``//`` *always* performs floor division "
"no matter what the types of its operands are, so ``1 // 2`` is 0 and "
"``1.0 // 2.0`` is also 0.0."
msgstr ""
"新しい演算子 ``//`` が floor division の演算子です。(いえーい、これって C++ "
"コメントのシンボルに似てるね、なんてことは私たちは知っています。) ``//`` は演"
"算対象の型がなんであれ *いつでも* floor division を実行しますので、 ``1 // "
"2`` は 0、 ``1.0 // 2.0`` も 0.0 です。"

#: ../../whatsnew/2.2.rst:747
msgid ""
"``//`` is always available in Python 2.2; you don't need to enable it using "
"a ``__future__`` statement."
msgstr ""
"``//`` は Python 2.2 でいつでも使えます; ``__future__`` を使って有効化するな"
"んてことは必要ないです。"

#: ../../whatsnew/2.2.rst:750
msgid ""
"By including a ``from __future__ import division`` in a module, the ``/`` "
"operator will be changed to return the result of true division, so ``1/2`` "
"is 0.5.  Without the ``__future__`` statement, ``/`` still means classic "
"division. The default meaning of ``/`` will not change until Python 3.0."
msgstr ""
"``from __future__ import division`` をモジュールに import することで、 ``/`` "
"演算子が真の除算 (true division) の結果を返すように変更されるので、 ``1/2`` "
"は 0.5 になります。 ``__future__`` 文なしでは ``/`` はクラシック除算 "
"(classic division) のままです。 ``/`` が持つデフォルトの意味は Python 3.0 に"
"なるまで変更されません。"

#: ../../whatsnew/2.2.rst:755
msgid ""
"Classes can define methods called :meth:`__truediv__` and :meth:"
"`__floordiv__` to overload the two division operators.  At the C level, "
"there are also slots in the :c:type:`PyNumberMethods` structure so extension "
"types can define the two operators."
msgstr ""
"クラスでは :meth:`__truediv__` と :meth:`__floordiv__` メソッドを、2つの除算"
"演算子をオーバロードするために定義出来ます。C のレベルにも :c:type:"
"`PyNumberMethods` 構造体内にスロットがあり、拡張型もその 2 つの演算子を定義出"
"来ます。"

#: ../../whatsnew/2.2.rst:760
msgid ""
"Python 2.2 supports some command-line arguments for testing whether code "
"will work with the changed division semantics.  Running python with :option:"
"`!-Q warn` will cause a warning to be issued whenever division is applied to "
"two integers.  You can use this to find code that's affected by the change "
"and fix it.  By default, Python 2.2 will simply perform classic division "
"without a warning; the warning will be turned on by default in Python 2.3."
msgstr ""
"Python 2.2 は、コードが変更後の除算セマンティクスで動作するかどうかをテストす"
"るコマンドライン引数をサポートします。 :option:`!-Q warn` で python を実行す"
"ると、除算が二つの整数に適用されている箇所全てで警告します。除算の意味変更の"
"影響を受ける箇所の特定と修正に使えるでしょう。デフォルトでは、Python 2.2 は警"
"告なしで単純に classic division を実行します; その警告がデフォルトになるのは "
"Python 2.3 からです。"

#: ../../whatsnew/2.2.rst:770
msgid ":pep:`238` - Changing the Division Operator"
msgstr ":pep:`238` - 除算演算子を変更していく"

#: ../../whatsnew/2.2.rst:771
msgid ""
"Written by Moshe Zadka and  Guido van Rossum.  Implemented by Guido van "
"Rossum.."
msgstr "Moshe Zadka と Guido van Rossum 著、実装 Guido van Rossum.。"

#: ../../whatsnew/2.2.rst:777
msgid "Unicode Changes"
msgstr "Unicode の変更"

#: ../../whatsnew/2.2.rst:779
msgid ""
"Python's Unicode support has been enhanced a bit in 2.2.  Unicode strings "
"are usually stored as UCS-2, as 16-bit unsigned integers. Python 2.2 can "
"also be compiled to use UCS-4, 32-bit unsigned integers, as its internal "
"encoding by supplying :option:`!--enable-unicode=ucs4` to the configure "
"script.   (It's also possible to specify :option:`!--disable-unicode` to "
"completely disable Unicode support.)"
msgstr ""
"Python の Unicode サポートが 2.2 で少し拡張されています。Unicode 文字列は普通"
"は 16 ビット符号なし整数としての UCS-2 で格納されます。Python 2.2 は内部エン"
"コーディングとして 32 ビット符号なし整数の UCS-4 を使うようにもコンパイル出来"
"ます。これは :program:`configure` スクリプトに :option:`!--enable-"
"unicode=ucs4` オプションを与えることで行います。(:option:`!--disable-"
"unicode` を与えることで完全に Unicode サポートを無効にすることも出来ます。)"

#: ../../whatsnew/2.2.rst:786
msgid ""
"When built to use UCS-4 (a \"wide Python\"), the interpreter can natively "
"handle Unicode characters from U+000000 to U+110000, so the range of legal "
"values for the :func:`unichr` function is expanded accordingly.  Using an "
"interpreter compiled to use UCS-2 (a \"narrow Python\"), values greater than "
"65535 will still cause :func:`unichr` to raise a :exc:`ValueError` "
"exception. This is all described in :pep:`261`, \"Support for 'wide' Unicode "
"characters\"; consult it for further details."
msgstr ""
"UCS-4 (\"wide Python\") を使ってビルドすると、インタプリタは U+000000 から "
"U+110000 までの Unicode 文字をネイティブに処理出来ますので、 :func:`unichr` "
"関数へのこの範囲の正当な値は適切に処理されます。UCS-2 (\"narrow Python\") を"
"用いてビルドしたインタプリタの場合は、 65535 を超える値を :func:`unichr` に与"
"えるとこれまで通り :exc:`ValueError` を投げます。この変更については :pep:"
"`261` 「'wide' Unicode 文字のサポート」に全て記述されていますので、詳細はこれ"
"を調べてください。"

#: ../../whatsnew/2.2.rst:794
msgid ""
"Another change is simpler to explain. Since their introduction, Unicode "
"strings have supported an :meth:`encode` method to convert the string to a "
"selected encoding such as UTF-8 or Latin-1.  A symmetric "
"``decode([*encoding*])`` method has been added to 8-bit strings (though not "
"to Unicode strings) in 2.2. :meth:`decode` assumes that the string is in the "
"specified encoding and decodes it, returning whatever is returned by the "
"codec."
msgstr ""
"もう一つの変更については説明は簡単です。その導入以来 Unicode 文字列は、文字列"
"を選択した UTF-8 や Latin-1 のようなエンコーディングで変換するための :meth:"
"`encode` メソッドをサポートしてきました。2.2 では、対となる "
"``decode([*encoding*])`` メソッドが (Unicode 文字列ではない)  8 ビット文字列"
"に追加されました。 :meth:`decode` は文字列が特定のエンコーディングであること"
"を仮定してデコードを行い、コーデックにより返されるものを返します。"

#: ../../whatsnew/2.2.rst:801
msgid ""
"Using this new feature, codecs have been added for tasks not directly "
"related to Unicode.  For example, codecs have been added for uu-encoding, "
"MIME's base64 encoding, and compression with the :mod:`zlib` module::"
msgstr ""
"この新たなインターフェイスに相乗りする形で、 Unicode には無関係のタスクのため"
"のコーデックが追加されました。例えば uu エンコーディング、 MIME の base64 エ"
"ンコーディング、 :mod:`zlib` モジュールでの圧縮のためのエンコーディングが追加"
"されています::"

#: ../../whatsnew/2.2.rst:822
msgid ""
"To convert a class instance to Unicode, a :meth:`__unicode__` method can be "
"defined by a class, analogous to :meth:`__str__`."
msgstr ""
"クラスのインスタンスを Unicode に変換するために、クラスに :meth:"
"`__unicode__` メソッドを定義出来ます。これは :meth:`__str__` への相似です。"

#: ../../whatsnew/2.2.rst:825
msgid ""
":meth:`encode`, :meth:`decode`, and :meth:`__unicode__` were implemented by "
"Marc-André Lemburg.  The changes to support using UCS-4 internally were "
"implemented by Fredrik Lundh and Martin von Löwis."
msgstr ""
":meth:`encode`, :meth:`decode`, :meth:`__unicode__` は Marc-André Lemburg に"
"より実装されました。UCS-4 を内部的に使う変更に関しては Fredrik Lundh と "
"Martin von Löwis により実装されました。"

#: ../../whatsnew/2.2.rst:832
msgid ":pep:`261` - Support for 'wide' Unicode characters"
msgstr ":pep:`261` - 'wide' Unicode 文字のサポート"

#: ../../whatsnew/2.2.rst:833
msgid "Written by Paul Prescod."
msgstr ""
"Paul Prescod 著。 (---訳注: この What's New セクションと PEP 内容は 2.x では"
"ずっと有効ですが、3.x で大幅に変わっていて逐一補足出来ないほど大きく違ってい"
"ます。変更の概要についてはクックブックの「Python 2 から Python 3 への移植」が"
"わかりやすいと思います。---)"

#: ../../whatsnew/2.2.rst:839
msgid "PEP 227: Nested Scopes"
msgstr "PEP 227: 入れ子状のスコープ"

#: ../../whatsnew/2.2.rst:841
msgid ""
"In Python 2.1, statically nested scopes were added as an optional feature, "
"to be enabled by a ``from __future__ import nested_scopes`` directive.  In "
"2.2 nested scopes no longer need to be specially enabled, and are now always "
"present.  The rest of this section is a copy of the description of nested "
"scopes from my \"What's New in Python 2.1\" document; if you read it when "
"2.1 came out, you can skip the rest of this section."
msgstr ""
"Python 2.1 では、静的にネストされたスコープが ``from __future__ import "
"nested_scopes`` ディレクティブで有効に出来るオプションの機能として追加されま"
"した。2.2 では入れ子のスコープには特別に有効化する必要なく、もういつでもそこ"
"にあります。このセクションの残りの部分は \"What's New in Python 2.1\" の入れ"
"子のスコープの記述からの丸々コピーですので、2.1 のときに読んだなら読み飛ばし"
"てもらって結構です。"

#: ../../whatsnew/2.2.rst:848
msgid ""
"The largest change introduced in Python 2.1, and made complete in 2.2, is to "
"Python's scoping rules.  In Python 2.0, at any given time there are at most "
"three namespaces used to look up variable names: local, module-level, and "
"the built-in namespace.  This often surprised people because it didn't match "
"their intuitive expectations.  For example, a nested recursive function "
"definition doesn't work::"
msgstr ""
"Python2.1 で導入され、2.2 で完成した最も大きな変更点は Python のスコープルー"
"ルです。Python2.0では、ある指定された時点である変数の名前を検索するために多く"
"ても3つの名前空間、つまりローカル、モジュールレベル、ビルトイン名前空間しか使"
"われませんでした。このことは直感的な期待と一致せずしばしば人々を驚かせまし"
"た。例えば、入れ子になった再帰関数の定義は動きません::"

#: ../../whatsnew/2.2.rst:862
msgid ""
"The function :func:`g` will always raise a :exc:`NameError` exception, "
"because the binding of the name ``g`` isn't in either its local namespace or "
"in the module-level namespace.  This isn't much of a problem in practice "
"(how often do you recursively define interior functions like this?), but "
"this also made using the :keyword:`lambda` expression clumsier, and this was "
"a problem in practice. In code which uses :keyword:`!lambda` you can often "
"find local variables being copied by passing them as the default values of "
"arguments. ::"
msgstr ""
"名前 ``g`` はローカルの名前空間にもモジュールレベルの名前空間にも紐付かないの"
"で、関数 :func:`g` は常に :exc:`NameError` 例外を上げます。これは実際には大し"
"た問題ではありません (このような内部関数を再帰的に定義する頻度はそう多くあり"
"ません)が、 :keyword:`lambda` 式をより使いにくくするのでこれについては問題で"
"す。 :keyword:`!lambda` を使うコードにおいて、デフォルトの引数としてこれらを"
"渡してコピーされるローカル変数を頻繁に見かけます。::"

#: ../../whatsnew/2.2.rst:876
msgid ""
"The readability of Python code written in a strongly functional style "
"suffers greatly as a result."
msgstr ""
"過度な関数型スタイルで書かれた Python コードの可読性は、結果的にはひどく苦痛"
"を感じるものですね。"

#: ../../whatsnew/2.2.rst:879
msgid ""
"The most significant change to Python 2.2 is that static scoping has been "
"added to the language to fix this problem.  As a first effect, the "
"``name=name`` default argument is now unnecessary in the above example.  Put "
"simply, when a given variable name is not assigned a value within a function "
"(by an assignment, or the :keyword:`def`, :keyword:`class`, or :keyword:"
"`import` statements), references to the variable will be looked up in the "
"local namespace of the enclosing scope.  A more detailed explanation of the "
"rules, and a dissection of the implementation, can be found in the PEP."
msgstr ""
"Python 2.2 の最も重要な変更点は、この問題を解決するために静的なスコープが追加"
"されたことです。最初の効果として、 ``name=name`` という例ではデフォルトの引数"
"は必要ありません。簡単に言えば、指定された引数名が関数内の値に割り当てられな"
"い場合(:keyword:`def` 、 :keyword:`class` または :keyword:`import` ステートメ"
"ントの割り当てによって)、変数の参照は外側のスコープのローカル名前空間で検索さ"
"れます。ルールや実装の詳細は PEP で参照できます。"

#: ../../whatsnew/2.2.rst:888
msgid ""
"This change may cause some compatibility problems for code where the same "
"variable name is used both at the module level and as a local variable "
"within a function that contains further function definitions. This seems "
"rather unlikely though, since such code would have been pretty confusing to "
"read in the first place."
msgstr ""
"この変更は、同じ変数名がモジュールレベルと関数の定義が含まれている関数内の"
"ローカルの両方で変数名として使用されているコードで、互換性の問題を引き起こす"
"可能性があります。ですがむしろ気にしなくてよいでしょう。そのようなコードはそ"
"もそも最初から相当こんがらかっているので。"

#: ../../whatsnew/2.2.rst:894
msgid ""
"One side effect of the change is that the ``from module import *`` and "
"``exec`` statements have been made illegal inside a function scope under "
"certain conditions.  The Python reference manual has said all along that "
"``from module import *`` is only legal at the top level of a module, but the "
"CPython interpreter has never enforced this before.  As part of the "
"implementation of nested scopes, the compiler which turns Python source into "
"bytecodes has to generate different code to access variables in a containing "
"scope.  ``from module import *`` and ``exec`` make it impossible for the "
"compiler to figure this out, because they add names to the local namespace "
"that are unknowable at compile time. Therefore, if a function contains "
"function definitions or :keyword:`lambda` expressions with free variables, "
"the compiler will flag this by raising a :exc:`SyntaxError` exception."
msgstr ""
"この変更の副作用の一つは、 ``from module import *`` と ``exec`` の両ステート"
"メントが特定の条件下の関数スコープ内で不正となることです。 Python のリファレ"
"ンスマニュアルははじめからずっと ``from module import *`` はトップレベルモ"
"ジュールでのみ合法であると言ってきましたが、以前の CPython インタプリタはこれ"
"を一度も強制していませんでした。入れ子になったスコープ実装の一環として、"
"Python のソースをバイトコードに変換するコンパイラは、内包されたスコープ内の変"
"数にアクセスするために別のコードを生成する必要があります。 ``from module "
"import *``, ``exec`` はコンパイラにこれを理解することを不可能にしてしまいま"
"す。なぜならそれらはコンパイル時にはわからないローカル名前空間に名前を追加す"
"るからです。それゆえ、もし関数が関数定義を含んだり自由な変数に :keyword:"
"`lambda` の語句を含んだりする場合、コンパイラは :exc:`SyntaxError` 例外を上げ"
"て知らせます。"

#: ../../whatsnew/2.2.rst:907
msgid "To make the preceding explanation a bit clearer, here's an example::"
msgstr "前述した説明を少し明確にするため、例を挙げます::"

#: ../../whatsnew/2.2.rst:916
msgid ""
"Line 4 containing the ``exec`` statement is a syntax error, since ``exec`` "
"would define a new local variable named ``x`` whose value should be accessed "
"by :func:`g`."
msgstr ""
"``exec`` 文を含む 4 行目は文法エラーです。 ``exec`` としては新しいローカル変"
"数 ``x`` を定義したいのですが、これは :func:`g` からアクセスされなければなり"
"ません。"

#: ../../whatsnew/2.2.rst:920
msgid ""
"This shouldn't be much of a limitation, since ``exec`` is rarely used in "
"most Python code (and when it is used, it's often a sign of a poor design "
"anyway)."
msgstr ""
"これは実際には大した制約でもないはずです。 ``exec`` が Python コードで使われ"
"るのは稀です(使われているとしたら大抵どこか貧弱な設計であることの証)。"

#: ../../whatsnew/2.2.rst:927
msgid ":pep:`227` - Statically Nested Scopes"
msgstr ":pep:`227` - 静的に入れ子になったスコープ"

#: ../../whatsnew/2.2.rst:928
msgid "Written and implemented by Jeremy Hylton."
msgstr "Jeremy Hylton著、実装"

#: ../../whatsnew/2.2.rst:934
msgid "New and Improved Modules"
msgstr "新しいモジュールと改良されたモジュール"

#: ../../whatsnew/2.2.rst:936
msgid ""
"The :mod:`xmlrpclib` module was contributed to the standard library by "
"Fredrik Lundh, providing support for writing XML-RPC clients.  XML-RPC is a "
"simple remote procedure call protocol built on top of HTTP and XML. For "
"example, the following snippet retrieves a list of RSS channels from the "
"O'Reilly Network, and then  lists the recent headlines for one channel::"
msgstr ""
"Fredrik Lundh により寄稿された :mod:`xmlrpclib` モジュールは、 XML-RPC クライ"
"アントを記述するためのサポートを提供します。XML-RPC は HTTP と XML の上に成り"
"立つシンプルなリモートプロシージャコールのプロトコルです。例えば以下のコード"
"断片は O'Reilly ネットワークから RSS チャンネルのリストを抽出して、一つのチャ"
"ンネルの最新のヘッドラインをリストします::"

#: ../../whatsnew/2.2.rst:959
msgid ""
"The :mod:`SimpleXMLRPCServer` module makes it easy to create straightforward "
"XML-RPC servers.  See http://xmlrpc.scripting.com/ for more information "
"about XML-RPC."
msgstr ""
":mod:`SimpleXMLRPCServer` モジュールは、直裁的な XML-RPC サーバを書くのを容易"
"にします。XML-RPC の詳細については  http://xmlrpc.scripting.com/ を参照して下"
"さい。"

#: ../../whatsnew/2.2.rst:962
msgid ""
"The new :mod:`hmac` module implements the HMAC algorithm described by :rfc:"
"`2104`. (Contributed by Gerhard Häring.)"
msgstr ""
"新しい :mod:`hmac` モジュールは、 :rfc:`2104` で記述される HMAC アルゴリズム"
"を実装します 。 (Contributed by Gerhard Häring.)"

#: ../../whatsnew/2.2.rst:965
msgid ""
"Several functions that originally returned lengthy tuples now return pseudo-"
"sequences that still behave like tuples but also have mnemonic attributes "
"such as memberst_mtime or :attr:`tm_year`. The enhanced functions include :"
"func:`stat`, :func:`fstat`, :func:`statvfs`, and :func:`fstatvfs` in the :"
"mod:`os` module, and :func:`localtime`, :func:`gmtime`, and :func:`strptime` "
"in the :mod:`time` module."
msgstr ""
"元々が長ったらしいタプルを返していたいくつもの関数が、擬似シーケンスを返すよ"
"うに変更されています。変更後もそれはタプルとして振舞いますが、例えば "
"memberst_mtime や :attr:`tm_year` といった記憶しやすい属性も持ちます。この変"
"更が行われたものには :mod:`os` モジュールの :func:`stat`, :func:`fstat`, :"
"func:`statvfs`, :func:`fstatvfs` や :mod:`time` モジュールの :func:"
"`localtime`, :func:`gmtime`, :func:`strptime` が含まれます。"

#: ../../whatsnew/2.2.rst:972
msgid ""
"For example, to obtain a file's size using the old tuples, you'd end up "
"writing something like ``file_size = os.stat(filename)[stat.ST_SIZE]``, but "
"now this can be written more clearly as ``file_size = os.stat(filename)."
"st_size``."
msgstr ""
"例えば旧式のタプルでファイルサイズを得るには ``file_size = os.stat(filename)"
"[stat.ST_SIZE]`` のように書くしかありませんでしたが、今ではもっとわかりやす"
"い ``file_size = os.stat(filename).st_size`` のように書くことが出来ます。"

#: ../../whatsnew/2.2.rst:976
msgid "The original patch for this feature was contributed by Nick Mathewson."
msgstr "この機能のオリジナルのパッチは Nick Mathewson により寄稿されました。"

#: ../../whatsnew/2.2.rst:978
msgid ""
"The Python profiler has been extensively reworked and various errors in its "
"output have been corrected.  (Contributed by Fred L. Drake, Jr. and Tim "
"Peters.)"
msgstr ""
"Python プロファイラが大幅に改造されて、出力の色々な間違いが修正されました。 "
"(Contributed by Fred L. Drake, Jr. and Tim Peters.)"

#: ../../whatsnew/2.2.rst:981
msgid ""
"The :mod:`socket` module can be compiled to support IPv6; specify the :"
"option:`!--enable-ipv6` option to Python's configure script.  (Contributed "
"by Jun-ichiro \"itojun\" Hagino.)"
msgstr ""
":mod:`socket` モジュールを IPv6 サポート付きでコンパイル可能になりました。"
"Python の :program:`configure` スクリプトに :option:`!--enable-ipv6` オプショ"
"ンを与えてください。(Contributed by Jun-ichiro \"itojun\" Hagino.)"

#: ../../whatsnew/2.2.rst:985
msgid ""
"Two new format characters were added to the :mod:`struct` module for 64-bit "
"integers on platforms that support the C :c:expr:`long long` type.  ``q`` is "
"for a signed 64-bit integer, and ``Q`` is for an unsigned one.  The value is "
"returned in Python's long integer type.  (Contributed by Tim Peters.)"
msgstr ""

#: ../../whatsnew/2.2.rst:990
msgid ""
"In the interpreter's interactive mode, there's a new built-in function :func:"
"`help` that uses the :mod:`pydoc` module introduced in Python 2.1 to provide "
"interactive help. ``help(object)`` displays any available help text about "
"*object*.  :func:`help` with no argument puts you in an online help utility, "
"where you can enter the names of functions, classes, or modules to read "
"their help text. (Contributed by Guido van Rossum, using Ka-Ping Yee's :mod:"
"`pydoc` module.)"
msgstr ""
"インタプリタの対話モードに新たに :func:`help` ビルトインが追加されています。"
"これは Python 2.1 で導入された :mod:`pydoc` モジュールを用いて対話的なヘルプ"
"を提供します。 ``help(object)`` で *object* について手に入る任意のヘルプを表"
"示します。 :func:`help` を引数なしで起動するとオンラインのヘルプユーティリ"
"ティに入ります。ここから関数名やクラス名、モジュール名をタイプすることで、そ"
"れらのヘルプテキストを読むことが出来ます。 (Contributed by Guido van Rossum, "
"using Ka-Ping Yee's :mod:`pydoc` module.)"

#: ../../whatsnew/2.2.rst:998
msgid ""
"Various bugfixes and performance improvements have been made to the SRE "
"engine underlying the :mod:`re` module.  For example, the :func:`re.sub` "
"and :func:`re.split` functions have been rewritten in C.  Another "
"contributed patch speeds up certain Unicode character ranges by a factor of "
"two, and a new :meth:`finditer`  method that returns an iterator over all "
"the non-overlapping matches in  a given string.  (SRE is maintained by "
"Fredrik Lundh.  The BIGCHARSET patch was contributed by Martin von Löwis.)"
msgstr ""
":mod:`re` モジュールのもととなる SRE エンジンに多数のバグフィックスとパフォー"
"マンス改善がありました。例えば :func:`re.sub` 関数、 :func:`re.split` 関数が "
"C で書き直されました。もうひとつ、貢献されたパッチが特定の範囲の Unicode 文字"
"での 2 倍の高速化を果たし、また新しく、与えられた文字列での重ならないマッチ全"
"体を渡るイテレータを返す :meth:`finditer` メソッドが追加されました。(SRE is "
"maintained by Fredrik Lundh. The BIGCHARSET patch was contributed by Martin "
"von Löwis.)"

#: ../../whatsnew/2.2.rst:1006
msgid ""
"The :mod:`smtplib` module now supports :rfc:`2487`, \"Secure SMTP over "
"TLS\", so it's now possible to encrypt the SMTP traffic between a Python "
"program and the mail transport agent being handed a message.  :mod:`smtplib` "
"also supports SMTP authentication.  (Contributed by Gerhard Häring.)"
msgstr ""
":mod:`smtplib` モジュールに :rfc:`2487` 「Secure SMTP over TLS」のサポートが"
"追加されました。これにより Python プログラムとメール転送エージェント間での"
"メッセージの暗号化された SMTP トラフィックが可能になりました。 :mod:"
"`smtplib` は SMTP 認証もサポートしています。 (Contributed by Gerhard Häring.)"

#: ../../whatsnew/2.2.rst:1011
msgid ""
"The :mod:`imaplib` module, maintained by Piers Lauder, has support for "
"several new extensions: the NAMESPACE extension defined in :rfc:`2342`, "
"SORT, GETACL and SETACL.  (Contributed by Anthony Baxter and Michel "
"Pelletier.)"
msgstr ""
"Piers Lauder によって保守されている :mod:`imaplib` モジュールに新たに多くの拡"
"張のサポートが追加されました: :rfc:`2342` で定義されている NAMESPACE 拡張、 "
"SORT、 GETACL、 SETACL。(Contributed by Anthony Baxter and Michel Pelletier.)"

#: ../../whatsnew/2.2.rst:1015
msgid ""
"The :mod:`rfc822` module's parsing of email addresses is now compliant with :"
"rfc:`2822`, an update to :rfc:`822`.  (The module's name is *not* going to "
"be changed to ``rfc2822``.)  A new package, :mod:`email`, has also been "
"added for parsing and generating e-mail messages.  (Contributed by Barry "
"Warsaw, and arising out of his work on Mailman.)"
msgstr ""
"email アドレスのパースをする :mod:`rfc822` モジュールが :rfc:`2822` に準拠す"
"るようになりました。これは :rfc:`822` の更新版です。(モジュール名は "
"``rfc2822`` には変更 *されません* 。) 新しいパッケージ :mod:`email` も追加さ"
"れています。これは e-mail メッセージをパース・生成します。(Contributed by "
"Barry Warsaw, and arising out of his work on Mailman.)"

#: ../../whatsnew/2.2.rst:1021
msgid ""
"The :mod:`difflib` module now contains a new :class:`Differ` class for "
"producing human-readable lists of changes (a \"delta\") between two "
"sequences of lines of text.  There are also two generator functions, :func:"
"`ndiff` and :func:`restore`, which respectively return a delta from two "
"sequences, or one of the original sequences from a delta. (Grunt work "
"contributed by David Goodger, from ndiff.py code by Tim Peters who then did "
"the generatorization.)"
msgstr ""
":mod:`difflib` モジュールに新規クラス :class:`Differ` が追加されています。こ"
"れはテキスト行のシーケンス 2 つについての変更 (\"delta\") の、人間にとって読"
"みやすいリストを生成します。生成関数も 2 つ追加されています。 :func:`ndiff` "
"と :func:`restore` で、前者が 2 つのシーケンスの delta を返し、後者が delta "
"から元のシーケンスの一つを返します。 (Grunt work contributed by David "
"Goodger, from ndiff.py code by Tim Peters who then did the generatorization.)"

#: ../../whatsnew/2.2.rst:1028
msgid ""
"New constants :const:`ascii_letters`, :const:`ascii_lowercase`, and :const:"
"`ascii_uppercase` were added to the :mod:`string` module.  There were "
"several modules in the standard library that used :const:`string.letters` to "
"mean the ranges A-Za-z, but that assumption is incorrect when locales are in "
"use, because :const:`string.letters` varies depending on the set of legal "
"characters defined by the current locale.  The buggy modules have all been "
"fixed to use :const:`ascii_letters` instead. (Reported by an unknown person; "
"fixed by Fred L. Drake, Jr.)"
msgstr ""
":mod:`string` モジュールに新規定数 :const:`ascii_letters`, :const:"
"`ascii_lowercase`, :const:`ascii_uppercase` が追加されました。標準ライブラリ"
"内では A-Za-z 範囲を意味する :const:`string.letters` がありましたが、この仮定"
"はロケールを使っている場合は正しくありません。 :const:`string.letters` は現在"
"のロケールで定義される合法な文字集合に依存して変化するからです。それら誤った"
"モジュールは :const:`ascii_letters` を代わりに用いることで全て修正されまし"
"た。 (Reported by an unknown person; fixed by Fred L. Drake, Jr.)"

#: ../../whatsnew/2.2.rst:1037
msgid ""
"The :mod:`mimetypes` module now makes it easier to use alternative MIME-type "
"databases by the addition of a :class:`MimeTypes` class, which takes a list "
"of filenames to be parsed.  (Contributed by Fred L. Drake, Jr.)"
msgstr ""
":mod:`mimetypes` モジュールで代替の MIME-type データベースを使うのが簡単にな"
"りました。 :class:`MimeTypes` クラスがパースされるファイル名のリストを取りま"
"す。(Contributed by Fred L. Drake, Jr.)"

#: ../../whatsnew/2.2.rst:1041
msgid ""
"A :class:`Timer` class was added to the :mod:`threading` module that allows "
"scheduling an activity to happen at some future time.  (Contributed by "
"Itamar Shtull-Trauring.)"
msgstr ""
":mod:`threading` モジュールに :class:`Timer` クラスが追加されました。これによ"
"りある未来の時間に活性化するようスケジュールすることが出来ます。 "
"(Contributed by Itamar Shtull-Trauring.)"

#: ../../whatsnew/2.2.rst:1049
msgid "Interpreter Changes and Fixes"
msgstr "インタプリタの変更と修正"

#: ../../whatsnew/2.2.rst:1051
msgid ""
"Some of the changes only affect people who deal with the Python interpreter "
"at the C level because they're writing Python extension modules, embedding "
"the interpreter, or just hacking on the interpreter itself. If you only "
"write Python code, none of the changes described here will affect you very "
"much."
msgstr ""
"Python 拡張モジュールを書いたり、インタプリタの埋め込みをしたり、あるいは単に"
"インタプリタそのものをハックしたりするために C レベルでインタプリタを扱う人々"
"以外には影響しないいくつかの変更があります。Python コードを書くだけであればこ"
"こに記述する変更は、あなたに関係するものは全くありません。"

#: ../../whatsnew/2.2.rst:1056
msgid ""
"Profiling and tracing functions can now be implemented in C, which can "
"operate at much higher speeds than Python-based functions and should reduce "
"the overhead of profiling and tracing.  This  will be of interest to authors "
"of development environments for Python.  Two new C functions were added to "
"Python's API, :c:func:`PyEval_SetProfile` and :c:func:`PyEval_SetTrace`. The "
"existing :func:`sys.setprofile` and :func:`sys.settrace` functions still "
"exist, and have simply been changed to use the new C-level interface.  "
"(Contributed by Fred L. Drake, Jr.)"
msgstr ""
"プロファイルとトレースの関数が C で実装されました。Python ベースのものと比較"
"して圧倒的に高速に操作出来、プロファイルとトレースのオーバヘッドを削減するは"
"ずです。これは Python の開発環境の著者に朗報でしょう。2 つの C 関数、 :c:"
"func:`PyEval_SetProfile` と :c:func:`PyEval_SetTrace` が Python API に追加さ"
"れました。既存の :func:`sys.setprofile` 関数、 :func:`sys.settrace` 関数はそ"
"のまま存在し、単純に新規 C レベル関数を使うように修正されました。 "
"(Contributed by Fred L. Drake, Jr.)"

#: ../../whatsnew/2.2.rst:1065
msgid ""
"Another low-level API, primarily of interest to implementors of Python "
"debuggers and development tools, was added. :c:func:"
"`PyInterpreterState_Head` and :c:func:`PyInterpreterState_Next` let a caller "
"walk through all the existing interpreter objects; :c:func:"
"`PyInterpreterState_ThreadHead` and :c:func:`PyThreadState_Next` allow "
"looping over all the thread states for a given interpreter.  (Contributed by "
"David Beazley.)"
msgstr ""
"もうひとつ、主として Python デバッガ、開発ツールの実装者にとって興味深い低レ"
"ベル API が追加されています。 :c:func:`PyInterpreterState_Head` と :c:func:"
"`PyInterpreterState_Next` は呼び出し可能オブジェクトに、存在しているインタプ"
"リタのオブジェクト全てを渡り歩かせます。 :c:func:"
"`PyInterpreterState_ThreadHead` と :c:func:`PyThreadState_Next` は与えられた"
"インタプリタについてのスレッド状態全てに渡るループを可能にしています。 "
"(Contributed by David Beazley.)"

#: ../../whatsnew/2.2.rst:1072
msgid ""
"The C-level interface to the garbage collector has been changed to make it "
"easier to write extension types that support garbage collection and to debug "
"misuses of the functions. Various functions have slightly different "
"semantics, so a bunch of functions had to be renamed.  Extensions that use "
"the old API will still compile but will *not* participate in garbage "
"collection, so updating them for 2.2 should be considered fairly high "
"priority."
msgstr ""
"ガーベージコレクタの C レベルインターフェイスが変更されています。これはガー"
"ベージコレクションをサポートする拡張型を書いたり、関数の利用誤りのデバッグを"
"するのを簡単にします。多数の関数が少々これまでとは異なったセマンティクスを持"
"つので、関数群がリネームされました。旧 API を使う拡張はこれまで通りコンパイル"
"は出来ますが、ガーベージコレクションには参加 *出来ません* 。このため 2.2 のた"
"めにはかなり高優先度で更新を検討すべきです。"

#: ../../whatsnew/2.2.rst:1079
msgid ""
"To upgrade an extension module to the new API, perform the following steps:"
msgstr ""
"拡張モジュールを新 API でアップグレードするには、以下のステップを実施してくだ"
"さい:"

#: ../../whatsnew/2.2.rst:1081
msgid "Rename :c:func:`Py_TPFLAGS_GC` to :c:func:`PyTPFLAGS_HAVE_GC`."
msgstr ""
":c:func:`Py_TPFLAGS_GC` を :c:func:`PyTPFLAGS_HAVE_GC` にリネームします。"

#: ../../whatsnew/2.2.rst:1084
msgid ""
"Use :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar` to allocate"
msgstr ""
"オブジェクトのアロケートには :c:func:`PyObject_GC_New` または :c:func:"
"`PyObject_GC_NewVar` を使ってください。"

#: ../../whatsnew/2.2.rst:1084
msgid "objects, and :c:func:`PyObject_GC_Del` to deallocate them."
msgstr ""
"そしてオブジェクトのデアロケートには :c:func:`PyObject_GC_Del` を使ってくださ"
"い。"

#: ../../whatsnew/2.2.rst:1087
msgid "Rename :c:func:`PyObject_GC_Init` to :c:func:`PyObject_GC_Track` and"
msgstr ""
":c:func:`PyObject_GC_Init` は :c:func:`PyObject_GC_Track` にリネームし、"

#: ../../whatsnew/2.2.rst:1087
msgid ":c:func:`PyObject_GC_Fini` to :c:func:`PyObject_GC_UnTrack`."
msgstr ""
":c:func:`PyObject_GC_Fini` は :c:func:`PyObject_GC_UnTrack` にリネームしてく"
"ださい。"

#: ../../whatsnew/2.2.rst:1089
msgid "Remove :c:func:`PyGC_HEAD_SIZE` from object size calculations."
msgstr ""
"オブジェクトのサイズ計算をするのに :c:func:`PyGC_HEAD_SIZE` を使うのをやめま"
"す。"

#: ../../whatsnew/2.2.rst:1091
msgid ""
"Remove calls to :c:func:`PyObject_AS_GC` and :c:func:`PyObject_FROM_GC`."
msgstr ""
":c:func:`PyObject_AS_GC` と :c:func:`PyObject_FROM_GC` 呼び出しを削除します。"

#: ../../whatsnew/2.2.rst:1093
msgid ""
"A new ``et`` format sequence was added to :c:func:`PyArg_ParseTuple`; ``et`` "
"takes both a parameter and an encoding name, and converts the parameter to "
"the given encoding if the parameter turns out to be a Unicode string, or "
"leaves it alone if it's an 8-bit string, assuming it to already be in the "
"desired encoding.  This differs from the ``es`` format character, which "
"assumes that 8-bit strings are in Python's default ASCII encoding and "
"converts them to the specified new encoding. (Contributed by M.-A. Lemburg, "
"and used for the MBCS support on Windows described in the following section.)"
msgstr ""
":c:func:`PyArg_ParseTuple` に新たな書式化シーケンス ``et`` が追加されまし"
"た。 ``et`` はパラメータとエンコーディング名の両方を取りパラメータを与えられ"
"たエンコーディングで変換しますが、パラメータが Unicode である場合には変換し、"
"8 ビット文字列である場合にはこれが既に望みのものであることと仮定してそのまま"
"にします。このことは ``es`` 書式化文字が 8 ビット文字列は Python デフォルト"
"の ASCII エンコーディングであると仮定して新たに与えられたエンコーディングで変"
"換するのとは違っています。 (Contributed by M.-A. Lemburg, and used for the "
"MBCS support on Windows described in the following section.)"

#: ../../whatsnew/2.2.rst:1102
msgid ""
"A different argument parsing function, :c:func:`PyArg_UnpackTuple`, has been "
"added that's simpler and presumably faster.  Instead of specifying a format "
"string, the caller simply gives the minimum and maximum number of arguments "
"expected, and a set of pointers to :c:expr:`PyObject*` variables that will "
"be filled in with argument values."
msgstr ""

#: ../../whatsnew/2.2.rst:1108
msgid ""
"Two new flags :const:`METH_NOARGS` and :const:`METH_O` are available in "
"method definition tables to simplify implementation of methods with no "
"arguments or a single untyped argument. Calling such methods is more "
"efficient than calling a corresponding method that uses :const:"
"`METH_VARARGS`.  Also, the old :const:`METH_OLDARGS` style of writing C "
"methods is  now officially deprecated."
msgstr ""
"メソッド定義テーブルでの新規フラグ :const:`METH_NOARGS` と :const:`METH_O` が"
"利用可能です。これは引数なし、または単一の型の特定されない引数を取るメソッド"
"の実装を単純化します。 :const:`METH_VARARGS` を使って同じことをするよりも、こ"
"れらを使うと呼び出しがより効率的です。また C メソッドの記述に使う古い :const:"
"`METH_OLDARGS` スタイルは公式に非推奨となりました。"

#: ../../whatsnew/2.2.rst:1114
msgid ""
"Two new wrapper functions, :c:func:`PyOS_snprintf` and :c:func:"
"`PyOS_vsnprintf` were added to provide  cross-platform implementations for "
"the relatively new :c:func:`snprintf` and :c:func:`vsnprintf` C lib APIs. In "
"contrast to the standard :c:func:`sprintf` and :c:func:`vsprintf` functions, "
"the Python versions check the bounds of the buffer used to protect against "
"buffer overruns. (Contributed by M.-A. Lemburg.)"
msgstr ""
"比較的新しい C ライブラリである :c:func:`snprintf` と :c:func:`vsnprintf` に"
"ついてのクロスプラットフォームな実装として、ラッパー関数 :c:func:"
"`PyOS_snprintf` と :c:func:`PyOS_vsnprintf` が追加されています。標準の :c:"
"func:`sprintf` と :c:func:`vsprintf` とは対照的に、Python バージョンはバッ"
"ファオーバランから守るためにバッファの境界チェックを行います。 (Contributed "
"by M.-A. Lemburg.)"

#: ../../whatsnew/2.2.rst:1121
msgid ""
"The :c:func:`_PyTuple_Resize` function has lost an unused parameter, so now "
"it takes 2 parameters instead of 3.  The third argument was never used, and "
"can simply be discarded when porting code from earlier versions to Python "
"2.2."
msgstr ""
":c:func:`_PyTuple_Resize` 関数の未使用パラメータを取り除いたので、今後は 3 つ"
"ではなく 2 つのパラメータを取ります。3 つ目の引数は一度も使われることはなかっ"
"たため、Python 2.2 以前のコードからの移植時には単純に捨てることが出来ます。"

#: ../../whatsnew/2.2.rst:1129
msgid "Other Changes and Fixes"
msgstr "その他の変更と修正"

#: ../../whatsnew/2.2.rst:1131
msgid ""
"As usual there were a bunch of other improvements and bugfixes scattered "
"throughout the source tree.  A search through the CVS change logs finds "
"there were 527 patches applied and 683 bugs fixed between Python 2.1 and "
"2.2; 2.2.1 applied 139 patches and fixed 143 bugs; 2.2.2 applied 106 patches "
"and fixed 82 bugs.  These figures are likely to be underestimates."
msgstr ""
"いつものように、たくさんのほかの改善とバグフィックスがソースツリー全体に渡っ"
"て散らばっています。CVS 変更ログを検索すると、Python 2.1 から 2.2 にかけて適"
"用されたパッチは 527、バグ修正は 683、2.2.1 で適用されたパッチは 139、バグ修"
"正は 143、2.2.2 で適用されたパッチは 106、バグ修正は 82。いずれも少なく見積"
"もって、です。"

#: ../../whatsnew/2.2.rst:1137
msgid "Some of the more notable changes are:"
msgstr "ほかの、さらに特筆すべき変更のいくつかを挙げます:"

#: ../../whatsnew/2.2.rst:1139
msgid ""
"The code for the MacOS port for Python, maintained by Jack Jansen, is now "
"kept in the main Python CVS tree, and many changes have been made to support "
"MacOS X."
msgstr ""

#: ../../whatsnew/2.2.rst:1142
msgid ""
"The most significant change is the ability to build Python as a framework, "
"enabled by supplying the :option:`!--enable-framework` option to the "
"configure script when compiling Python.  According to Jack Jansen, \"This "
"installs a self-contained Python installation plus the OS X framework "
"\"glue\" into :file:`/Library/Frameworks/Python.framework` (or another "
"location of choice). For now there is little immediate added benefit to this "
"(actually, there is the disadvantage that you have to change your PATH to be "
"able to find Python), but it is the basis for creating a full-blown Python "
"application, porting the MacPython IDE, possibly using Python as a standard "
"OSA scripting language and much more.\""
msgstr ""

#: ../../whatsnew/2.2.rst:1153
msgid ""
"Most of the MacPython toolbox modules, which interface to MacOS APIs such as "
"windowing, QuickTime, scripting, etc. have been ported to OS X, but they've "
"been left commented out in :file:`setup.py`.  People who want to experiment "
"with these modules can uncomment them manually."
msgstr ""

#: ../../whatsnew/2.2.rst:1176
msgid ""
"Keyword arguments passed to built-in functions that don't take them now "
"cause a :exc:`TypeError` exception to be raised, with the message "
"\"*function* takes no keyword arguments\"."
msgstr ""
"キーワード引数を取らないビルトイン関数にそれを渡すと、メッセージ "
"\"*function* takes no keyword arguments\" を伴う :exc:`TypeError` 例外を励起"
"するようになりました。"

#: ../../whatsnew/2.2.rst:1180
msgid ""
"Weak references, added in Python 2.1 as an extension module, are now part of "
"the core because they're used in the implementation of new-style classes.  "
"The :exc:`ReferenceError` exception has therefore moved from the :mod:"
"`weakref` module to become a built-in exception."
msgstr ""
"Python 2.1 で拡張モジュールとして追加された弱参照は、今では Python 中核の一部"
"です。これは新スタイルクラスの実装のために使われるからです。このため :mod:"
"`weakref` モジュールにいた :exc:`ReferenceError` 例外をビルトイン例外に移動し"
"ました。"

#: ../../whatsnew/2.2.rst:1185
msgid ""
"A new script, :file:`Tools/scripts/cleanfuture.py` by Tim Peters, "
"automatically removes obsolete ``__future__`` statements from Python source "
"code."
msgstr ""
"Tim Peters による新しいスクリプト :file:`Tools/scripts/cleanfuture.py` は、"
"Python ソースコードから自動的に廃止された ``__future__`` 文を削除します。"

#: ../../whatsnew/2.2.rst:1189
msgid ""
"An additional *flags* argument has been added to the built-in function :func:"
"`compile`, so the behaviour of ``__future__`` statements can now be "
"correctly observed in simulated shells, such as those presented by IDLE and "
"other development environments.  This is described in :pep:`264`. "
"(Contributed by Michael Hudson.)"
msgstr ""
"ビルトイン関数 :func:`compile` に *flags* 引数が追加され、これにより "
"``__future__`` ステートメントの振る舞いが、IDLE 内やほかの開発環境内にある模"
"擬的なシェル内で正しく準拠するようになりました。この変更は :pep:`264` に記述"
"されています。 (Contributed by Michael Hudson.)"

#: ../../whatsnew/2.2.rst:1195
msgid ""
"The new license introduced with Python 1.6 wasn't GPL-compatible.  This is "
"fixed by some minor textual changes to the 2.2 license, so it's now legal to "
"embed Python inside a GPLed program again.  Note that Python itself is not "
"GPLed, but instead is under a license that's essentially equivalent to the "
"BSD license, same as it always was.  The license changes were also applied "
"to the Python 2.0.1 and 2.1.1 releases."
msgstr ""
"Python 1.6 で導入された新ライセンスは GPL 互換ではありませんでした。2.2 ライ"
"センスのためにいくつか小さな字句的修正によりこれをフィックスし、GPL プログラ"
"ム内に Python を埋め込むことが再び合法になりました。Python そのものは GPL で"
"はなく、かつても今後も BSD ライセンスに本質的に等価なものであることに注意して"
"ください。このライセンスの変更は Python 2.0.1 リリース、2.1.1 リリースにも適"
"用されました。"

#: ../../whatsnew/2.2.rst:1202
msgid ""
"When presented with a Unicode filename on Windows, Python will now convert "
"it to an MBCS encoded string, as used by the Microsoft file APIs.  As MBCS "
"is explicitly used by the file APIs, Python's choice of ASCII as the default "
"encoding turns out to be an annoyance.  On Unix, the locale's character set "
"is used if ``locale.nl_langinfo(CODESET)`` is available.  (Windows support "
"was contributed by Mark Hammond with assistance from Marc-André Lemburg. "
"Unix support was added by Martin von Löwis.)"
msgstr ""
"Windows において Unicode ファイル名がある場合に、Python はそれを Microsoft "
"ファイル API を使うことで MBCS 文字列に変換するようになりました。MBCS はその"
"ファイル API によって明示的に使われるので、デフォルトのエンコーディングとし"
"て Python が ASCII を選択するのは苛立たしいことがわかりました。Unix において"
"は ``locale.nl_langinfo(CODESET)`` が利用可能であればロケールの文字セットが使"
"われます。 (Windows support was contributed by Mark Hammond with assistance "
"from Marc-André Lemburg. Unix support was added by Martin von Löwis.)"

#: ../../whatsnew/2.2.rst:1210
msgid ""
"Large file support is now enabled on Windows.  (Contributed by Tim Peters.)"
msgstr ""
"Windows でのラージファイルのサポートが有効になりました。  (Contributed by "
"Tim Peters.)"

#: ../../whatsnew/2.2.rst:1212
msgid ""
"The :file:`Tools/scripts/ftpmirror.py` script now parses a :file:`.netrc` "
"file, if you have one. (Contributed by Mike Romberg.)"
msgstr ""
":file:`Tools/scripts/ftpmirror.py` スクリプトが、もしあれば、 :file:`.netrc` "
"ファイルを読むようになりました。 (Contributed by Mike Romberg.)"

#: ../../whatsnew/2.2.rst:1215
msgid ""
"Some features of the object returned by the :func:`xrange` function are now "
"deprecated, and trigger warnings when they're accessed; they'll disappear in "
"Python 2.3. :class:`xrange` objects tried to pretend they were full sequence "
"types by supporting slicing, sequence multiplication, and the :keyword:`in` "
"operator, but these features were rarely used and therefore buggy.  The :"
"meth:`tolist` method and the :attr:`start`, :attr:`stop`, and :attr:`step` "
"attributes are also being deprecated.  At the C level, the fourth argument "
"to the :c:func:`PyRange_New` function, ``repeat``, has also been deprecated."
msgstr ""
":func:`xrange` 関数より返されるオブジェクトのいくつかの機能が非推奨となり、そ"
"れにアクセスすると警告が発せられます。これら機能は Python 2.3 では削除されま"
"す。 :class:`xrange` オブジェクトはスライス、シーケンスの積算、 :keyword:"
"`in` 演算子のサポートをすることによりシーケンス型を完全に装うように試みられま"
"したが、これら機能が使われることは稀だったためにバギーでした。 :meth:"
"`tolist` メソッドと属性 :attr:`start`, :attr:`stop`, :attr:`step` も同様に非"
"推奨になります。 C レベルでは :c:func:`PyRange_New` 関数の 4 つ目の引数 "
"``repeat`` も非推奨になりました。"

#: ../../whatsnew/2.2.rst:1224
msgid ""
"There were a bunch of patches to the dictionary implementation, mostly to "
"fix potential core dumps if a dictionary contains objects that sneakily "
"changed their hash value, or mutated the dictionary they were contained in. "
"For a while python-dev fell into a gentle rhythm of Michael Hudson finding a "
"case that dumped core, Tim Peters fixing the bug, Michael finding another "
"case, and round and round it went."
msgstr ""
"辞書実装に対するパッチの束がありました。ほとんどが、辞書にこっそりとそのハッ"
"シュ値を変更するオブジェクトを含んでいたり、それが含まれる辞書を変更する場合"
"に潜在的にコアダンプしていたことに対する修正です。Michael Hudson がコアダンプ"
"するケースを見つけて python-dev に穏やかなリズムで報告している間に Tim "
"Peters がバグをフィックスし、 Michael がまた別のケースを見つけ、ということを"
"繰り返しました。"

#: ../../whatsnew/2.2.rst:1231
msgid ""
"On Windows, Python can now be compiled with Borland C thanks to a number of "
"patches contributed by Stephen Hansen, though the result isn't fully "
"functional yet.  (But this *is* progress...)"
msgstr ""

#: ../../whatsnew/2.2.rst:1235
msgid ""
"Another Windows enhancement: Wise Solutions generously offered PythonLabs "
"use of their InstallerMaster 8.1 system.  Earlier PythonLabs Windows "
"installers used Wise 5.0a, which was beginning to show its age.  (Packaged "
"up by Tim Peters.)"
msgstr ""

#: ../../whatsnew/2.2.rst:1239
msgid ""
"Files ending in ``.pyw`` can now be imported on Windows. ``.pyw`` is a "
"Windows-only thing, used to indicate that a script needs to be run using "
"PYTHONW.EXE instead of PYTHON.EXE in order to prevent a DOS console from "
"popping up to display the output.  This patch makes it possible to import "
"such scripts, in case they're also usable as modules.  (Implemented by David "
"Bolen.)"
msgstr ""
"ファイル名が ``.pyw`` で終わるものが Windows でインポート出来るようになりまし"
"た。 ``.pyw`` は Windows のみのものであり、スクリプトが PYTHON.EXE ではなく "
"PYTHONW.EXE を使って実行されることを示すのに使われます。これは出力のために "
"DOS コンソールがポップアップしてしまうのを避けるのに使われます。このパッチは"
"そのようなスクリプトを、それがモジュールとしても利用可能であるケースでイン"
"ポート出来るようにします。 (Implemented by David Bolen.)"

#: ../../whatsnew/2.2.rst:1245
msgid ""
"On platforms where Python uses the C :c:func:`dlopen` function  to load "
"extension modules, it's now possible to set the flags used  by :c:func:"
"`dlopen` using the :func:`sys.getdlopenflags` and :func:`sys.setdlopenflags` "
"functions. (Contributed by Bram Stolk.)"
msgstr ""
"Python が C の :c:func:`dlopen` 関数を拡張モジュールのロードに用いるプラット"
"フォームにおいて、 :c:func:`dlopen` で使われるフラグを :func:`sys."
"getdlopenflags` 関数と :func:`sys.setdlopenflags` 関数でセット出来るようにな"
"りました。 (Contributed by Bram Stolk.)"

#: ../../whatsnew/2.2.rst:1250
msgid ""
"The :func:`pow` built-in function no longer supports 3 arguments when "
"floating-point numbers are supplied. ``pow(x, y, z)`` returns ``(x**y) % "
"z``, but this is never useful for floating point numbers, and the final "
"result varies unpredictably depending on the platform.  A call such as "
"``pow(2.0, 8.0, 7.0)`` will now raise a :exc:`TypeError` exception."
msgstr ""
"組み込み関数 :func:`pow` はもはや浮動小数点数の際の 3 番目の引数をサポートし"
"ません。 ``pow(x, y, z)`` は ``(x**y) % z`` を返しますが、浮動小数点の場合は"
"これは決して役には立ちません。最終結果はプラットフォーム依存で予測不可能なも"
"のになります。 ``pow(2.0, 8.0, 7.0)`` のような呼び出しは、 :exc:`TypeError` "
"例外を発生させるようにしました。"

#: ../../whatsnew/2.2.rst:1260
msgid "Acknowledgements"
msgstr "謝辞"

#: ../../whatsnew/2.2.rst:1262
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Fred Bremmer, Keith Briggs, Andrew Dalke, Fred L. Drake, Jr., Carel "
"Fellinger, David Goodger, Mark Hammond, Stephen Hansen, Michael Hudson, Jack "
"Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik Lundh, Michael McLay, "
"Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don O'Donnell, Joonas "
"Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, Guido van "
"Rossum, Greg Ward, Edward Welbourne."
msgstr ""
"著者は提案の申し出や修正、様々なこの記事の草稿の助けをしてくれた以下の人々に"
"感謝します:  Fred Bremmer, Keith Briggs, Andrew Dalke, Fred L. Drake, Jr., "
"Carel Fellinger, David Goodger, Mark Hammond, Stephen Hansen, Michael "
"Hudson, Jack Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik Lundh, "
"Michael McLay, Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don O'Donnell, "
"Joonas Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, "
"Guido van Rossum, Greg Ward, Edward Welbourne."
