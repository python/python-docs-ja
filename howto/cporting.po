# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# tomoğŸ§, 2017
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2017
# Arihiro TAKASE, 2017
# ttakah <ttakah@gmail.com>, 2017
# SHIMIZU Taku <shimizu.taku@gmail.com>, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-30 05:56+0900\n"
"PO-Revision-Date: 2017-02-16 17:44+0000\n"
"Last-Translator: ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/cporting.rst:7
msgid "Porting Extension Modules to Python 3"
msgstr "Python 3 ã¸ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç§»æ¤"

#: ../../howto/cporting.rst:0
msgid "author"
msgstr "author"

#: ../../howto/cporting.rst:9
msgid "Benjamin Peterson"
msgstr "Benjamin Peterson"

#: ../../howto/cporting.rstNone
msgid "Abstract"
msgstr "æ¦‚è¦"

#: ../../howto/cporting.rst:14
msgid ""
"Although changing the C-API was not one of Python 3's objectives, the many "
"Python-level changes made leaving Python 2's API intact impossible.  In "
"fact, some changes such as :func:`int` and :func:`long` unification are more"
" obvious on the C level.  This document endeavors to document "
"incompatibilities and how they can be worked around."
msgstr ""
"C-API ã®å¤‰æ›´ã¯ Python 3 ã®ç›®æ¨™ã«ã¯å…¥ã£ã¦ã„ã¾ã›ã‚“ã§ã—ãŸãŒã€Python ãƒ¬ãƒ™ãƒ«ã§ã®å¤‰æ›´ãŒãŸãã•ã‚“ã‚ã£ãŸã®ã§ã€Python 2 ã® API"
" ã‚’ç„¡å‚·ã§æ¸ˆã¾ã›ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚å®Ÿéš›ã€ :func:`int` ã¨ :func:`long` ã®çµ±åˆãªã©ã¯ C "
"ãƒ¬ãƒ™ãƒ«ã®ã»ã†ãŒç›®ç«‹ã¡ã¾ã™ã€‚ã“ã®æ–‡æ›¸ã§ã¯ã€ãªããªã£ãŸäº’æ›æ€§ã¨ã€ãã®å¯¾å‡¦æ–¹æ³•ã«ã¤ã„ã¦è¨˜è¿°ã—ã‚ˆã†ã¨æ€ã„ã¾ã™ã€‚"

#: ../../howto/cporting.rst:23
msgid "Conditional compilation"
msgstr "æ¡ä»¶ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«"

#: ../../howto/cporting.rst:25
msgid ""
"The easiest way to compile only some code for Python 3 is to check if "
":c:macro:`PY_MAJOR_VERSION` is greater than or equal to 3. ::"
msgstr ""
"ä¸€éƒ¨ã®ã‚³ãƒ¼ãƒ‰ã‚’ Python 3 ã«ã ã‘ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ãŸã‚ã®ä¸€ç•ªç°¡å˜ãªæ–¹æ³•ã¯ã€ :c:macro:`PY_MAJOR_VERSION` ãŒ 3 "
"ä»¥ä¸Šã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã“ã¨ã§ã™ã€‚ ::"

#: ../../howto/cporting.rst:32
msgid ""
"API functions that are not present can be aliased to their equivalents "
"within conditional blocks."
msgstr "å­˜åœ¨ã—ãªããªã£ãŸé–¢æ•°ã«ã¤ã„ã¦ã¯ã€æ¡ä»¶ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­ã§åŒç­‰å“ã«ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã™ã‚Œã°è‰¯ã„ã§ã—ã‚‡ã†ã€‚"

#: ../../howto/cporting.rst:37
msgid "Changes to Object APIs"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ API ã®å¤‰æ›´"

#: ../../howto/cporting.rst:39
msgid ""
"Python 3 merged together some types with similar functions while cleanly "
"separating others."
msgstr "Python 3 ã§ã¯ã€ä¼¼ãŸæ©Ÿèƒ½ã‚’æŒã¤ã‚¿ã‚¤ãƒ—ã®ã„ãã¤ã‹ã‚’ã€çµ±åˆã—ãŸã‚Šã€ãã£ã¡ã‚Šåˆ†ã‘ãŸã‚Šã—ã¾ã—ãŸã€‚"

#: ../../howto/cporting.rst:44
msgid "str/unicode Unification"
msgstr "str/unicode ã®çµ±åˆ"

#: ../../howto/cporting.rst:46
msgid ""
"Python 3's :func:`str` type is equivalent to Python 2's :func:`unicode`; the"
" C functions are called ``PyUnicode_*`` for both.  The old 8-bit string type"
" has become :func:`bytes`, with C functions called ``PyBytes_*``.  Python "
"2.6 and later provide a compatibility header, :file:`bytesobject.h`, mapping"
" ``PyBytes`` names to ``PyString`` ones.  For best compatibility with Python"
" 3, :c:type:`PyUnicode` should be used for textual data and "
":c:type:`PyBytes` for binary data.  It's also important to remember that "
":c:type:`PyBytes` and :c:type:`PyUnicode` in Python 3 are not "
"interchangeable like :c:type:`PyString` and :c:type:`PyUnicode` are in "
"Python 2.  The following example shows best practices with regards to "
":c:type:`PyUnicode`, :c:type:`PyString`, and :c:type:`PyBytes`. ::"
msgstr ""
"Python 3 ã® :func:`str` ã‚¿ã‚¤ãƒ—ã¯ Python 2 ã® :func:`unicode` ã¨åŒã˜ã‚‚ã®ã§ã€ã©ã¡ã‚‰ã‚‚ C é–¢æ•°ã¯ "
"``PyUnicode_*`` ã¨å‘¼ã°ã‚Œã¾ã™ã€‚æ˜”ã® 8 ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã‚¿ã‚¤ãƒ—ã¯ :func:`bytes` ã«ãªã‚Šã€C é–¢æ•°ã¯ ``PyBytes_*``"
" ã¨å‘¼ã°ã‚Œã¾ã™ã€‚Python 2.6 ä»¥é™ã«ã¯äº’æ›æ€§ãƒ˜ãƒƒãƒ€ :file:`bytesobject.h` ãŒç”¨æ„ã•ã‚Œã¦ãŠã‚Šã€ ``PyBytes`` "
"ç³»ã®åå‰ã‚’ ``PyString`` ç³»ã«ãƒãƒƒãƒ—ã—ã¦ã„ã¾ã™ã€‚Python 3 ã¨ã®äº’æ›æ€§ã‚’æœ€å¤§é™ç¢ºä¿ã™ã‚‹ã«ã¯ã€ :c:type:`PyUnicode` "
"ã¯æ–‡å­—ãƒ‡ãƒ¼ã‚¿ã«ã€ :c:type:`PyBytes` ã¯ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã«ã ã‘ä½¿ã†ã¹ãã§ã™ã€‚ã»ã‹ã«ã‚‚ã€Python 3 ã® "
":c:type:`PyBytes` ã¨ :c:type:`PyUnicode` ã¯ Python 2 ã® :c:type:`PyString` ã¨ "
":c:type:`PyUnicode` ã¨ã¯é•ã£ã¦äº¤æ›ä¸å¯èƒ½ã ã¨ã„ã†ã“ã¨ã‚‚é‡è¦ã§ã™ã€‚ä»¥ä¸‹ã®ä¾‹ã§ã¯ :c:type:`PyUnicode`, "
":c:type:`PyString`, :c:type:`PyBytes` ã«é–¢ã™ã‚‹ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ ::"

#: ../../howto/cporting.rst:95
msgid "long/int Unification"
msgstr "long/int ã®çµ±åˆ"

#: ../../howto/cporting.rst:97
msgid ""
"Python 3 has only one integer type, :func:`int`.  But it actually "
"corresponds to Python 2's :func:`long` typeâ€”the :func:`int` type used in "
"Python 2 was removed.  In the C-API, ``PyInt_*`` functions are replaced by "
"their ``PyLong_*`` equivalents."
msgstr ""
"Python 3 ã«ã¯æ•´æ•°å‹ãŒ :func:`int` ã®ä¸€ã¤ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚\n"
"ã“ã‚Œã¯å®Ÿéš›ã«ã¯ Python 2 ã® :func:`long` ã‚¿ã‚¤ãƒ—ã¨åŒã˜ã‚‚ã®ã§ã€ Python 2 ã§ä½¿ã‚ã‚Œã¦ã„ãŸ :func:`int` ã¯å–ã‚Šé™¤ã‹ã‚Œã¾ã—ãŸã€‚\n"
"C-API ã§ã¯ ``PyInt_*`` é–¢æ•°ç¾¤ãŒã€åŒç­‰ã® ``PyLong_*`` ã«ç½®ãæ›ãˆã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../howto/cporting.rst:104
msgid "Module initialization and state"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–ã¨çŠ¶æ…‹æƒ…å ±"

#: ../../howto/cporting.rst:106
msgid ""
"Python 3 has a revamped extension module initialization system.  (See "
":pep:`3121`.)  Instead of storing module state in globals, they should be "
"stored in an interpreter specific structure.  Creating modules that act "
"correctly in both Python 2 and Python 3 is tricky.  The following simple "
"example demonstrates how. ::"
msgstr ""
"Python 3 ã«ã¯ã€æ”¹è‰¯ã•ã‚ŒãŸæ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–ã‚·ã‚¹ãƒ†ãƒ ãŒã‚ã‚Šã¾ã™ (:pep:`3121` "
"å‚ç…§)ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®çŠ¶æ…‹ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«æŒã¤ã®ã§ã¯ãªãã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å›ºæœ‰ã®æ§‹é€ ä½“ã«æŒã¤ã¹ãã ã¨ã„ã†ã“ã¨ã«ãªã£ãŸã®ã§ã™ã€‚Pythonk 2 ã¨ "
"Python 3 ã®ã©ã¡ã‚‰ã§ã‚‚å‹•ããƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œã‚‹ã®ã«ã¯ã‚³ãƒ„ãŒè¦ã‚Šã¾ã™ã€‚æ¬¡ã®ç°¡å˜ãªä¾‹ã§ã€ãã®æ–¹æ³•ã‚’å®Ÿæ¼”ã—ã¦ã¿ã¾ã™ã€‚ ::"

#: ../../howto/cporting.rst:197
msgid "CObject replaced with Capsule"
msgstr "CObject ã® Capsule ã¸ã®å¤‰æ›´"

#: ../../howto/cporting.rst:199
msgid ""
"The :c:type:`Capsule` object was introduced in Python 3.1 and 2.7 to replace"
" :c:type:`CObject`.  CObjects were useful, but the :c:type:`CObject` API was"
" problematic: it didn't permit distinguishing between valid CObjects, which "
"allowed mismatched CObjects to crash the interpreter, and some of its APIs "
"relied on undefined behavior in C. (For further reading on the rationale "
"behind Capsules, please see :issue:`5630`.)"
msgstr ""
"Python 3.1 ã¨ 2.7 ã« :c:type:`Capsule` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå°å…¥ã•ã‚Œã¾ã—ãŸã€‚ã“ã‚Œã¯ :c:type:`CObject` "
"ã®ã‹ã‚ã‚Šã«ãªã‚‹ã‚‚ã®ã§ã™ã€‚  CObject ã¯ä¾¿åˆ©ã§ã—ãŸãŒã€ :c:type:`CObject` API ã«ã¯å•é¡ŒãŒã‚ã‚Šã¾ã—ãŸ: æœ‰åŠ¹ãª CObject"
" ã§ã‚ã‚Œã°ãã‚Œä»¥ä¸Šã®è­˜åˆ¥ãŒä¸å¯èƒ½ãªã®ã§ã€åˆã‚ãªã„ CObject ã‚’æ··ãœã¦ä½¿ã†ã¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã‚’ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã•ã›ã‹ã­ãªã‹ã£ãŸã“ã¨ã€ãã—ã¦ API ã®ä¸€éƒ¨ãŒ"
" C ã®æœªå®šç¾©ãªæŒ™å‹•ã«ä¾å­˜ã—ã¦ã„ãŸã“ã¨ã§ã™ã€‚ (Capsule ã®èƒŒæ™¯ã«ã¤ã„ã¦è©³ã—ãã¯ :issue:`5630` ã‚’ã”è¦§ãã ã•ã„ã€‚)"

#: ../../howto/cporting.rst:206
msgid ""
"If you're currently using CObjects, and you want to migrate to 3.1 or newer,"
" you'll need to switch to Capsules. :c:type:`CObject` was deprecated in 3.1 "
"and 2.7 and completely removed in Python 3.2.  If you only support 2.7, or "
"3.1 and above, you can simply switch to :c:type:`Capsule`.  If you need to "
"support Python 3.0, or versions of Python earlier than 2.7, you'll have to "
"support both CObjects and Capsules. (Note that Python 3.0 is no longer "
"supported, and it is not recommended for production use.)"
msgstr ""
"ç¾æ™‚ç‚¹ã§ CObject ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã§ã‚ã‚Œã°ã€3.1 ä»¥é™ã¸ç§»è¡Œã™ã‚‹ã«ã¯ Capsule ã¸åˆ‡ã‚Šæ›ãˆã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ "
":c:type:`CObject` ã¯ 3.1 ãŠã‚ˆã³ 2.7 ã§éæ¨å¥¨ã¨ãªã‚Šã€Python 3.2 ã§ã¯å®Œå…¨ã«å‰Šé™¤ã•ã‚ŒãŸã‹ã‚‰ã§ã™ã€‚  2.7 ã¨ "
"3.1 ä»¥ä¸Šã ã‘ã®å¯¾å¿œã§ã„ã„ãªã‚‰ã€å˜ã« :c:type:`Capsule` ã¸åˆ‡ã‚Šæ›ãˆã‚‹ã ã‘ã§ã™ã€‚  ã—ã‹ã— Python 3.0 ã‚„ã€ã‚ã‚‹ã„ã¯ 2.7"
" æœªæº€ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«å¯¾å¿œã—ãªã‘ã‚Œã°ãªã‚‰ãªã„å ´åˆã¯ã€CObject ã¨ Capsule ã®ä¸¡æ–¹ã«å¯¾å¿œã™ã‚‹å¿…è¦ãŒå‡ºã¦ãã¾ã™ã€‚(ãŸã ã— Python 3.0 "
"ã¯ã‚µãƒãƒ¼ãƒˆãŒçµ‚äº†ã—ã¦ã„ã‚‹ãŸã‚ç¾å ´åˆ©ç”¨ã«ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“ã€‚)"

#: ../../howto/cporting.rst:216
msgid ""
"The following example header file :file:`capsulethunk.h` may solve the "
"problem for you.  Simply write your code against the :c:type:`Capsule` API "
"and include this header file after :file:`Python.h`.  Your code will "
"automatically use Capsules in versions of Python with Capsules, and switch "
"to CObjects when Capsules are unavailable."
msgstr ""
"ãã†ã—ãŸå•é¡Œã¯ã€ä¸‹ã«ä¾‹ç¤ºã™ã‚‹ :file:`capsulethunk.h` ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã§è§£æ±ºã§ãã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚  å¿…è¦ãªä½œæ¥­ã¯ã€ "
":c:type:`Capsule` API ã§ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã€ã“ã®ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ :file:`Python.h` ã®å¾Œã§ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã™ã‚‹ã ã‘ã§ã™ã€‚  "
"ã™ã‚‹ã¨è‡ªå‹•çš„ã«ã€Capsule ã®ã‚ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã§ã¯ Capsule ã‚’ä½¿ã„ã€ãªã‘ã‚Œã° CObject ã‚’ä½¿ã†ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/cporting.rst:223
msgid ""
":file:`capsulethunk.h` simulates Capsules using CObjects.  However, "
":c:type:`CObject` provides no place to store the capsule's \"name\".  As a "
"result the simulated :c:type:`Capsule` objects created by "
":file:`capsulethunk.h` behave slightly differently from real Capsules.  "
"Specifically:"
msgstr ""
"ãã®å ´åˆ :file:`capsulethunk.h` ã¯ CObject ã‚’ä½¿ã£ã¦ Capsule ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã¾ã™ã€‚  ã—ã‹ã— "
":c:type:`CObject` ã«ã¯ capsule ã® \"name\" ã‚’ä¿æŒã™ã‚‹ä½™åœ°ãŒã‚ã‚Šã¾ã›ã‚“ã€‚  ã‚ˆã£ã¦ã€ "
":file:`capsulethunk.h` ã§ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚ŒãŸ :c:type:`Capsule` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹•ä½œã¯ã€æœ¬ç‰©ã® Capsule "
"ã¨ã¯å°‘ã—ç•°ãªã‚Šã¾ã™ã€‚  å…·ä½“çš„ã«ã¯:"

#: ../../howto/cporting.rst:228
msgid "The name parameter passed in to :c:func:`PyCapsule_New` is ignored."
msgstr ":c:func:`PyCapsule_New` ã«æ¸¡ã•ã‚ŒãŸ name å¼•æ•°ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../howto/cporting.rst:230
msgid ""
"The name parameter passed in to :c:func:`PyCapsule_IsValid` and "
":c:func:`PyCapsule_GetPointer` is ignored, and no error checking of the name"
" is performed."
msgstr ""
":c:func:`PyCapsule_IsValid` ãŠã‚ˆã³ :c:func:`PyCapsule_GetPointer` ã«æ¸¡ã•ã‚ŒãŸ name "
"å¼•æ•°ã¯ç„¡è¦–ã•ã‚Œã€name ã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã‚‚å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../howto/cporting.rst:234
msgid ":c:func:`PyCapsule_GetName` always returns NULL."
msgstr ":c:func:`PyCapsule_GetName` ã¯å¸¸ã« NULL ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../howto/cporting.rst:236
msgid ""
":c:func:`PyCapsule_SetName` always raises an exception and returns failure."
"  (Since there's no way to store a name in a CObject, noisy failure of "
":c:func:`PyCapsule_SetName` was deemed preferable to silent failure here.  "
"If this is inconvenient, feel free to modify your local copy as you see "
"fit.)"
msgstr ""
":c:func:`PyCapsule_SetName` ã¯å¸¸ã«ä¾‹å¤–ã‚’é€å‡ºã—ã¦ã€å¤±æ•—ã‚’è¿”ã—ã¾ã™ã€‚ (CObject "
"ã«åå‰ã‚’æ ¼ç´ã™ã‚‹æ–¹æ³•ãŒãªã„ã®ã§ã€ã“ã“ã§ã¯ :c:func:`PyCapsule_SetName` "
"ã®ã†ã‚‹ã•ã„å¤±æ•—ã¯æš—é»™ã®å¤±æ•—ã‚ˆã‚Šå¥½ã¾ã—ã„ã¨è€ƒãˆã‚‰ã‚Œã¾ã—ãŸã€‚ã“ã‚ŒãŒä¸ä¾¿ãªå ´åˆã¯ã€é©åˆ‡ã¨æ€ã†ã‚„ã‚Šæ–¹ã§è‡ªç”±ã«ãƒ­ãƒ¼ã‚«ãƒ«ã‚³ãƒ”ãƒ¼ã‚’ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚)"

#: ../../howto/cporting.rst:243
msgid ""
"You can find :file:`capsulethunk.h` in the Python source distribution as "
":source:`Doc/includes/capsulethunk.h`.  We also include it here for your "
"convenience:"
msgstr ""
":file:`capsulethunk.h` ã¯ Python ã®ã‚½ãƒ¼ã‚¹ã®ä¸­ã« "
":source:`Doc/includes/capsulethunk.h` ã¨ã„ã†åå‰ã§å…¥ã£ã¦ã„ã¾ã™ã€‚  "
"èª­è€…ã®ä¾¿å®œã®ãŸã‚ã€ã“ã“ã«ã‚‚å¼•ç”¨ã—ã¦ãŠãã¾ã—ã‚‡ã†:"

#: ../../howto/cporting.rst:252
msgid "Other options"
msgstr "ãã®ä»–ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³"

#: ../../howto/cporting.rst:254
msgid ""
"If you are writing a new extension module, you might consider `Cython "
"<http://cython.org/>`_.  It translates a Python-like language to C.  The "
"extension modules it creates are compatible with Python 3 and Python 2."
msgstr ""
"æ–°è¦ã«æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ›¸ã“ã†ã¨æ€ã£ã¦ã„ã‚‹ã®ã§ã‚ã‚Œã°ã€`Cython <http://cython.org/>`_ ã‚’æ¤œè¨ã—ã¦ã¿ã¦ã‚‚è‰¯ã„ã§ã—ã‚‡ã†ã€‚ã“ã‚Œã¯ "
"Python é¢¨ã®è¨€èªã‚’ C ã«ç¿»è¨³ã—ã¦ãã‚Œã‚‹ã‚‚ã®ã§ã€å‡ºåŠ›ã•ã‚Œã‚‹æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ Python 3 ã¨ Python 2 ã«ä¸¡æ–¹å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚"
