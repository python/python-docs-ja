# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Takanori Suzuki <takanori@takanory.net>, 2021
# tomo, 2021
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-29 12:56+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: tomo, 2021\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/enum.rst:3
msgid "Enum HOWTO"
msgstr "列挙型 HOWTO"

#: ../../howto/enum.rst:0
msgid "Author"
msgstr "著者"

#: ../../howto/enum.rst:5
msgid "Ethan Furman <ethan at stoneleaf dot us>"
msgstr ""

#: ../../howto/enum.rst:12
msgid "Basic Enum Tutorial"
msgstr ""

#: ../../howto/enum.rst:14
msgid ""
"An :class:`Enum` is a set of symbolic names bound to unique values.  They "
"are similar to global variables, but they offer a more useful :func:"
"`repr()`, grouping, type-safety, and a few other features."
msgstr ""
":class:`Enum` は、ユニークな値に束縛されたシンボル名の集合です。グローバル変"
"数に似ていますが、 :func:`repr()` がより便利だったり、グルーピングの機能、型"
"安全などいくつかの機能があります。"

#: ../../howto/enum.rst:18
msgid ""
"They are most useful when you have a variable that can take one of a limited "
"selection of values.  For example, the days of the week::"
msgstr ""
"これらは、限られた選択肢の値の一つを取る変数がある場合に便利です。例えば、曜"
"日情報があります:"

#: ../../howto/enum.rst:31
msgid ""
"As you can see, creating an :class:`Enum` is as simple as writing a class "
"that inherits from :class:`Enum` itself."
msgstr ""
"ご覧の通り、 :class:`Enum` の作成は :class:`Enum` 自体を継承するクラスを作成"
"するのと同じくらい簡単です。"

#: ../../howto/enum.rst:34
msgid "Case of Enum Members"
msgstr "Enumメンバーは大文字/小文字？"

#: ../../howto/enum.rst:36
msgid ""
"Because Enums are used to represent constants we recommend using UPPER_CASE "
"names for members, and will be using that style in our examples."
msgstr ""
"Enumクラス群は定数を表現するために使われるため、メンバーの名前にはUPPER_CASE"
"を使うことを推奨します。本ページのドキュメントのサンプルでもそのスタイルを採"
"用します。"

#: ../../howto/enum.rst:39
msgid ""
"Depending on the nature of the enum a member's value may or may not be "
"important, but either way that value can be used to get the corresponding "
"member::"
msgstr ""
"列挙型の性質によって、メンバの値は重要な場合とそうでない場合がありますが、い"
"ずれの場合でも、その値は対応するメンバを取得するのに使えます::"

#: ../../howto/enum.rst:46
msgid ""
"As you can see, the ``repr()`` of a member shows the enum name and the "
"member name.  The ``str()`` on a member shows only its name::"
msgstr ""

#: ../../howto/enum.rst:52
msgid "The *type* of an enumeration member is the enum it belongs to::"
msgstr "列挙型のメンバの型はそのメンバの属する列挙型です::"

#: ../../howto/enum.rst:59
msgid "Enum members have an attribute that contains just their :attr:`name`::"
msgstr "列挙型のメンバはその名前だけを含む属性 :attr:`name` を持っています::"

#: ../../howto/enum.rst:64
msgid "Likewise, they have an attribute for their :attr:`value`::"
msgstr "同じように、値のための属性 :attr:`value` もあります::"

#: ../../howto/enum.rst:70
msgid ""
"Unlike many languages that treat enumerations solely as name/value pairs, "
"Python Enums can have behavior added.  For example, :class:`datetime.date` "
"has two methods for returning the weekday: :meth:`weekday` and :meth:"
"`isoweekday`. The difference is that one of them counts from 0-6 and the "
"other from 1-7. Rather than keep track of that ourselves we can add a method "
"to the :class:`Weekday` enum to extract the day from the :class:`date` "
"instance and return the matching enum member::"
msgstr ""

#: ../../howto/enum.rst:82
msgid "The complete :class:`Weekday` enum now looks like this::"
msgstr ""

#: ../../howto/enum.rst:97
msgid "Now we can find out what today is!  Observe::"
msgstr ""

#: ../../howto/enum.rst:103
msgid ""
"Of course, if you're reading this on some other day, you'll see that day "
"instead."
msgstr ""

#: ../../howto/enum.rst:105
msgid ""
"This :class:`Weekday` enum is great if our variable only needs one day, but "
"what if we need several?  Maybe we're writing a function to plot chores "
"during a week, and don't want to use a :class:`list` -- we could use a "
"different type of :class:`Enum`::"
msgstr ""

#: ../../howto/enum.rst:120
msgid ""
"We've changed two things: we're inherited from :class:`Flag`, and the values "
"are all powers of 2."
msgstr ""

#: ../../howto/enum.rst:123
msgid ""
"Just like the original :class:`Weekday` enum above, we can have a single "
"selection::"
msgstr ""

#: ../../howto/enum.rst:129
msgid ""
"But :class:`Flag` also allows us to combine several members into a single "
"variable::"
msgstr ""

#: ../../howto/enum.rst:136
msgid "You can even iterate over a :class:`Flag` variable::"
msgstr ""

#: ../../howto/enum.rst:143
msgid "Okay, let's get some chores set up::"
msgstr ""

#: ../../howto/enum.rst:151
msgid "And a function to display the chores for a given day::"
msgstr ""

#: ../../howto/enum.rst:160
msgid ""
"In cases where the actual values of the members do not matter, you can save "
"yourself some work and use :func:`auto()` for the values::"
msgstr ""

#: ../../howto/enum.rst:177
msgid "Programmatic access to enumeration members and their attributes"
msgstr "列挙型メンバーおよびそれらの属性へのプログラム的アクセス"

#: ../../howto/enum.rst:179
msgid ""
"Sometimes it's useful to access members in enumerations programmatically (i."
"e. situations where ``Color.RED`` won't do because the exact color is not "
"known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"プログラム的にメンバーに番号でアクセスしたほうが便利な場合があります (すなわ"
"ち、プログラムを書いている時点で正確な色がまだわからなく、``Color.RED`` と書"
"くのが無理な場合など)。 ``Enum`` ではそのようなアクセスも可能です::"

#: ../../howto/enum.rst:188
msgid "If you want to access enum members by *name*, use item access::"
msgstr ""
"列挙型メンバーに *名前* でアクセスしたい場合はアイテムとしてアクセスできま"
"す::"

#: ../../howto/enum.rst:195
msgid "If you have an enum member and need its :attr:`name` or :attr:`value`::"
msgstr "列挙型メンバーの :attr:`name` か :attr:`value` が必要な場合::"

#: ../../howto/enum.rst:205
msgid "Duplicating enum members and values"
msgstr "列挙型メンバーと値の重複"

#: ../../howto/enum.rst:207
msgid "Having two enum members with the same name is invalid::"
msgstr "同じ名前の列挙型メンバーを複数持つことはできません::"

#: ../../howto/enum.rst:217
msgid ""
"However, an enum member can have other names associated with it.  Given two "
"entries ``A`` and ``B`` with the same value (and ``A`` defined first), ``B`` "
"is an alias for the member ``A``.  By-value lookup of the value of ``A`` "
"will return the member ``A``.  By-name lookup of ``A`` will return the "
"member ``A``. By-name lookup of ``B`` will also return the member ``A``::"
msgstr ""

#: ../../howto/enum.rst:238
msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr ""
"すでに定義されている属性と同じ名前のメンバー (一方がメンバーでもう一方がメ"
"ソッド、など) の作成、あるいはメンバーと同じ名前の属性の作成はできません。"

#: ../../howto/enum.rst:244
msgid "Ensuring unique enumeration values"
msgstr "番号付けの値が一意であることの確認"

#: ../../howto/enum.rst:246
msgid ""
"By default, enumerations allow multiple names as aliases for the same value. "
"When this behavior isn't desired, you can use the :func:`unique` decorator::"
msgstr ""

#: ../../howto/enum.rst:263
msgid "Using automatic values"
msgstr "値の自動設定を使う"

#: ../../howto/enum.rst:265
msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr "正確な値が重要でない場合、 :class:`auto` が使えます::"

#: ../../howto/enum.rst:276
msgid ""
"The values are chosen by :func:`_generate_next_value_`, which can be "
"overridden::"
msgstr ""
"その値は :func:`_generate_next_value_` によって選ばれ、この関数はオーバーライ"
"ドできます::"

#: ../../howto/enum.rst:294
msgid ""
"The :meth:`_generate_next_value_` method must be defined before any members."
msgstr ""
":meth:`_generate_next_value_` メソッドは他のメンバーよりも前に定義される必要"
"があります。"

#: ../../howto/enum.rst:297
msgid "Iteration"
msgstr "イテレーション"

#: ../../howto/enum.rst:299
msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr "列挙型のメンバーのイテレートは別名をサポートしていません::"

#: ../../howto/enum.rst:304
msgid ""
"The special attribute ``__members__`` is a read-only ordered mapping of "
"names to members.  It includes all names defined in the enumeration, "
"including the aliases::"
msgstr ""
"特殊属性 ``__members__`` は読み出し専用で、順序を保持した、対応する名前と列挙"
"型メンバーのマッピングです。これには別名も含め、列挙されたすべての名前が入っ"
"ています。"

#: ../../howto/enum.rst:316
msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr ""
"属性 ``__members__`` は列挙型メンバーへの詳細なアクセスに使用できます。以下は"
"すべての別名を探す例です::"

#: ../../howto/enum.rst:324
msgid "Comparisons"
msgstr "比較"

#: ../../howto/enum.rst:326
msgid "Enumeration members are compared by identity::"
msgstr "列挙型メンバーは同一性を比較できます::"

#: ../../howto/enum.rst:335
msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr ""
"列挙型の値の順序の比較はサポートされて *いません*。Enum メンバーは整数ではあ"
"りません (`IntEnum`_ を参照してください)::"

#: ../../howto/enum.rst:343
msgid "Equality comparisons are defined though::"
msgstr "ただし等価の比較は定義されています::"

#: ../../howto/enum.rst:352
msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr ""
"非列挙型の値との比較は常に不等となります (繰り返しになりますが、:class:"
"`IntEnum` はこれと異なる挙動になるよう設計されています)::"

#: ../../howto/enum.rst:361
msgid "Allowed members and attributes of enumerations"
msgstr "列挙型で許されるメンバーと属性"

#: ../../howto/enum.rst:363
msgid ""
"Most of the examples above use integers for enumeration values.  Using "
"integers is short and handy (and provided by default by the `Functional "
"API`_), but not strictly enforced.  In the vast majority of use-cases, one "
"doesn't care what the actual value of an enumeration is.  But if the value "
"*is* important, enumerations can have arbitrary values."
msgstr ""

#: ../../howto/enum.rst:369
msgid ""
"Enumerations are Python classes, and can have methods and special methods as "
"usual.  If we have this enumeration::"
msgstr ""
"列挙型は Python のクラスであり、通常どおりメソッドや特殊メソッドを持つことが"
"できます::"

#: ../../howto/enum.rst:389
msgid "Then::"
msgstr "上記の結果が以下のようになります::"

#: ../../howto/enum.rst:398
msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`__str__`, :meth:"
"`__add__`, etc.), descriptors (methods are also descriptors), and variable "
"names listed in :attr:`_ignore_`."
msgstr ""
"何が許されているかのルールは次のとおりです。先頭と末尾が 1 個のアンダースコア"
"の名前は列挙型により予約されているため、使用できません。列挙型内で定義された"
"その他すべての名前は、その列挙型のメンバーとして使用できます。特殊メソッド (:"
"meth:`__str__`, :meth:`__add__` など) と、メソッドを含むデスクリプタ(記述"
"子)、 :attr:`_ignore_` に記載されている変数名は例外です。"

#: ../../howto/enum.rst:405
msgid ""
"Note:  if your enumeration defines :meth:`__new__` and/or :meth:`__init__` "
"then any value(s) given to the enum member will be passed into those "
"methods. See `Planet`_ for an example."
msgstr ""
"注意: 列挙型で :meth:`__new__` および/または :meth:`__init__` を定義した場"
"合、列挙型メンバーに与えられた値はすべてこれらのメソッドに渡されます。例 "
"`Planet`_ を参照してください。"

#: ../../howto/enum.rst:411
msgid "Restricted Enum subclassing"
msgstr "Enumのサブクラス化の制限"

#: ../../howto/enum.rst:413
msgid ""
"A new :class:`Enum` class must have one base enum class, up to one concrete "
"data type, and as many :class:`object`-based mixin classes as needed.  The "
"order of these base classes is::"
msgstr ""
"新しい :class:`Enum` クラスは、ベースの enum クラスを1つ、具象データ型を1つ、"
"複数の :class:`object` ベースのミックスインクラスが許容されます。これらのベー"
"スクラスの順序は次の通りです::"

#: ../../howto/enum.rst:420
msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does not "
"define any members.  So this is forbidden::"
msgstr ""
"列挙型のサブクラスの作成はその列挙型にメンバーが一つも定義されていない場合の"
"み行なえます。従って以下は許されません::"

#: ../../howto/enum.rst:430
msgid "But this is allowed::"
msgstr "以下のような場合は許されます::"

#: ../../howto/enum.rst:441
msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"メンバーが定義された列挙型のサブクラス化を許可すると、いくつかのデータ型およ"
"びインスタンスの重要な不変条件の違反を引き起こします。とはいえ、それが許可さ"
"れると、列挙型のグループ間での共通の挙動を共有するという利点もあります。 "
"(`OrderedEnum`_ の例を参照してください。)"

#: ../../howto/enum.rst:448
msgid "Pickling"
msgstr "Pickle 化"

#: ../../howto/enum.rst:450
msgid "Enumerations can be pickled and unpickled::"
msgstr "列挙型は pickle 化と unpickle 化が行えます::"

#: ../../howto/enum.rst:457
msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr ""
"通常の pickle 化の制限事項が適用されます: pickle 可能な列挙型はモジュールの"
"トップレベルで定義されていなくてはならず、unpickle 化はモジュールからインポー"
"ト可能でなければなりません。"

#: ../../howto/enum.rst:463
msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr ""
"pickle プロトコルバージョン 4 では他のクラスで入れ子になった列挙型の pickle "
"化も容易です。"

#: ../../howto/enum.rst:466
msgid ""
"It is possible to modify how enum members are pickled/unpickled by defining :"
"meth:`__reduce_ex__` in the enumeration class."
msgstr ""
"enum のメンバーをどう pickle 化/unpickle 化するかは、列挙型クラス内の :meth:"
"`__reduce_ex__` で定義することで変更できます。"

#: ../../howto/enum.rst:471
msgid "Functional API"
msgstr "機能 API"

#: ../../howto/enum.rst:473
msgid ""
"The :class:`Enum` class is callable, providing the following functional API::"
msgstr ""
":class:`Enum` クラスは呼び出し可能で、以下の関数 API を提供しています::"

#: ../../howto/enum.rst:485
msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr ""
"この API の動作は :class:`~collections.namedtuple` と似ています。:class:"
"`Enum` 呼び出しの第 1 引数は列挙型の名前です。"

#: ../../howto/enum.rst:488
msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of 2-"
"tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`Animal` is equivalent to::"
msgstr ""
"第 2 引数は列挙型メンバー名の *ソース* です。空白で区切った名前の文字列、名前"
"のシーケンス、キー/値のペアの 2 要素タプルのシーケンス、あるいは名前と値の"
"マッピング (例: 辞書) を指定できます。最後の 2 個のオプションでは、列挙型へ任"
"意の値を割り当てることができます。前の 2 つのオプションでは、1 から始まり増加"
"していく整数を自動的に割り当てます (別の開始値を指定するには、``start`` 引数"
"を使用します)。:class:`Enum` から派生した新しいクラスが返されます。言い換えれ"
"ば、上記の :class:`Animal` への割り当ては以下と等価です::"

#: ../../howto/enum.rst:504
msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but by default enum members all "
"evaluate to ``True``."
msgstr ""

#: ../../howto/enum.rst:508
msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in separate module, and also may not work on IronPython or Jython). "
"The solution is to specify the module name explicitly as follows::"
msgstr ""
"機能 API による Enum の pickle 化は、その列挙型がどのモジュールで作成されたか"
"を見つけ出すためにフレームスタックの実装の詳細が使われるので、トリッキーにな"
"ることがあります (例えば別のモジュールのユーティリティ関数を使うと失敗します"
"し、IronPython や Jython ではうまくいきません)。解決策は、以下のようにモ"
"ジュール名を明示的に指定することです::"

#: ../../howto/enum.rst:518
msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new "
"Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr ""
"``module`` が与えられない場合、Enum はそれがなにか決定できないため、新しい "
"Enum メンバーは unpickle 化できなくなります; エラーをソースの近いところで発生"
"させるため、pickle 化は無効になります。"

#: ../../howto/enum.rst:522
msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on :attr:"
"`~definition.__qualname__` being set to the location where pickle will be "
"able to find the class.  For example, if the class was made available in "
"class SomeData in the global scope::"
msgstr ""
"新しい pickle プロトコルバージョン 4 では、一部の状況において、pickle がクラ"
"スを発見するための場所の設定に :attr:`~definition.__qualname__` を参照しま"
"す。例えば、そのクラスがグローバルスコープ内のクラス SomeData 内で利用可能と"
"するには以下のように指定します::"

#: ../../howto/enum.rst:529
msgid "The complete signature is::"
msgstr "完全な構文は以下のようになります::"

#: ../../howto/enum.rst:0
msgid "value"
msgstr "value"

#: ../../howto/enum.rst:541
msgid "What the new enum class will record as its name."
msgstr "新しい enum クラスに記録されるそれ自身の名前です。"

#: ../../howto/enum.rst:0
msgid "names"
msgstr "名前"

#: ../../howto/enum.rst:543
msgid ""
"The enum members.  This can be a whitespace or comma separated string "
"(values will start at 1 unless otherwise specified)::"
msgstr ""

#: ../../howto/enum.rst:548
msgid "or an iterator of names::"
msgstr "または名前のイテレータで指定もできます::"

#: ../../howto/enum.rst:552
msgid "or an iterator of (name, value) pairs::"
msgstr "または (名前, 値) のペアのイテレータでも指定できます::"

#: ../../howto/enum.rst:556
msgid "or a mapping::"
msgstr "またはマッピングでも指定できます::"

#: ../../howto/enum.rst:0
msgid "module"
msgstr "module"

#: ../../howto/enum.rst:560
msgid "name of module where new enum class can be found."
msgstr "新しい enum クラスが属するモジュールの名前です。"

#: ../../howto/enum.rst:0
msgid "qualname"
msgstr "qualname"

#: ../../howto/enum.rst:562
msgid "where in module new enum class can be found."
msgstr "新しい enum クラスが属するモジュールの場所です。"

#: ../../howto/enum.rst:0
msgid "type"
msgstr "type"

#: ../../howto/enum.rst:564
msgid "type to mix in to new enum class."
msgstr "新しい enum クラスに複合されるデータ型です。"

#: ../../howto/enum.rst:0
msgid "start"
msgstr "start"

#: ../../howto/enum.rst:566
msgid "number to start counting at if only names are passed in."
msgstr "names のみが渡されたときにカウントを開始する数です。"

#: ../../howto/enum.rst:568
msgid "The *start* parameter was added."
msgstr "*start* 引数が追加されました。"

#: ../../howto/enum.rst:573
msgid "Derived Enumerations"
msgstr "派生列挙型"

#: ../../howto/enum.rst:576
msgid "IntEnum"
msgstr "IntEnum"

#: ../../howto/enum.rst:578
msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass of :"
"class:`int`.  Members of an :class:`IntEnum` can be compared to integers; by "
"extension, integer enumerations of different types can also be compared to "
"each other::"
msgstr ""
"提供されている 1 つ目の :class:`Enum` の派生型であり、 :class:`int` のサブク"
"ラスでもあります。\n"
":class:`IntEnum` のメンバーは整数と比較できます;\n"
"さらに言うと、異なる整数列挙型どうしでも比較できます::"

#: ../../howto/enum.rst:599
msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr "ただし、これらも標準の :class:`Enum` 列挙型とは比較できません::"

#: ../../howto/enum.rst:612
msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr ":class:`IntEnum` の値は他の用途では整数のように振る舞います::"

#: ../../howto/enum.rst:623
msgid "StrEnum"
msgstr "StrEnum"

#: ../../howto/enum.rst:625
msgid ""
"The second variation of :class:`Enum` that is provided is also a subclass "
"of :class:`str`.  Members of a :class:`StrEnum` can be compared to strings; "
"by extension, string enumerations of different types can also be compared to "
"each other.  :class:`StrEnum` exists to help avoid the problem of getting an "
"incorrect member::"
msgstr ""

#: ../../howto/enum.rst:636
msgid ""
"Before :class:`StrEnum`, ``Directions.NORTH`` would have been the :class:"
"`tuple` ``('north',)``."
msgstr ""

#: ../../howto/enum.rst:643
msgid "IntFlag"
msgstr "IntFlag"

#: ../../howto/enum.rst:645
msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can be "
"combined using the bitwise operators (&, \\|, ^, ~) and the result is still "
"an :class:`IntFlag` member, if possible.  However, as the name implies, :"
"class:`IntFlag` members also subclass :class:`int` and can be used wherever "
"an :class:`int` is used."
msgstr ""

#: ../../howto/enum.rst:654
msgid ""
"Any operation on an :class:`IntFlag` member besides the bit-wise operations "
"will lose the :class:`IntFlag` membership."
msgstr ""
":class:`IntFlag` メンバーに対してビット演算以外のどんな演算をしても、その結果"
"は :class:`IntFlag` メンバーではなくなります。"

#: ../../howto/enum.rst:657
msgid ""
"Bit-wise operations that result in invalid :class:`IntFlag` values will lose "
"the :class:`IntFlag` membership.  See :class:`FlagBoundary` for details."
msgstr ""

#: ../../howto/enum.rst:664
msgid "Sample :class:`IntFlag` class::"
msgstr ":class:`IntFlag` クラスの例::"

#: ../../howto/enum.rst:680
msgid "It is also possible to name the combinations::"
msgstr "組み合わせにも名前を付けられます::"

#: ../../howto/enum.rst:696
msgid ""
"Named combinations are considered aliases.  Aliases do not show up during "
"iteration, but can be returned from by-value lookups."
msgstr ""

#: ../../howto/enum.rst:701
msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` is "
"that if no flags are set (the value is 0), its boolean evaluation is :data:"
"`False`::"
msgstr ""
":class:`IntFlag` と :class:`Enum` のもう 1 つの重要な違いは、フラグが設定され"
"ていない (値が0である) 場合、その真偽値としての評価は :data:`False` になるこ"
"とです::"

#: ../../howto/enum.rst:709
msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they "
"can be combined with them (but may lose :class:`IntFlag` membership::"
msgstr ""

#: ../../howto/enum.rst:720
msgid ""
"The negation operator, ``~``, always returns an :class:`IntFlag` member with "
"a positive value::"
msgstr ""

#: ../../howto/enum.rst:726
msgid ":class:`IntFlag` members can also be iterated over::"
msgstr ""

#: ../../howto/enum.rst:735
msgid "Flag"
msgstr "Flag"

#: ../../howto/enum.rst:737
msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:`Flag` "
"members can be combined using the bitwise operators (&, \\|, ^, ~).  Unlike :"
"class:`IntFlag`, they cannot be combined with, nor compared against, any "
"other :class:`Flag` enumeration, nor :class:`int`.  While it is possible to "
"specify the values directly it is recommended to use :class:`auto` as the "
"value and let :class:`Flag` select an appropriate value."
msgstr ""
"最後の派生型は :class:`Flag` です。\n"
":class:`IntFlag` と同様に、 :class:`Flag` メンバーもビット演算子 (&, \\|, ^, "
"~) を使って組み合わせられます。\n"
"しかし :class:`IntFlag` とは違い、他のどの :class:`Flag` 列挙型とも :class:"
"`int` とも組み合わせたり、比較したりできません。\n"
"値を直接指定することも可能ですが、値として :class:`auto` を使い、 :class:"
"`Flag` に適切な値を選ばせることが推奨されています。"

#: ../../howto/enum.rst:746
msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results in "
"no flags being set, the boolean evaluation is :data:`False`::"
msgstr ""
":class:`IntFlag` と同様に、 :class:`Flag` メンバーの組み合わせがどのフラグも"
"設定されていない状態になった場合、その真偽値としての評価は :data:`False` とな"
"ります::"

#: ../../howto/enum.rst:760
msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, "
"8, ...), while combinations of flags won't::"
msgstr ""
"個別のフラグは 2 のべき乗 (1, 2, 4, 8, ...) の値を持つべきですが、フラグの組"
"み合わせはそうはなりません::"

#: ../../howto/enum.rst:772
msgid ""
"Giving a name to the \"no flags set\" condition does not change its boolean "
"value::"
msgstr ""
"\"フラグが設定されていない\" 状態に名前を付けても、その真偽値は変わりません::"

#: ../../howto/enum.rst:786
msgid ":class:`Flag` members can also be iterated over::"
msgstr ""

#: ../../howto/enum.rst:796
msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are strongly "
"recommended, since :class:`IntEnum` and :class:`IntFlag` break some semantic "
"promises of an enumeration (by being comparable to integers, and thus by "
"transitivity to other unrelated enumerations).  :class:`IntEnum` and :class:"
"`IntFlag` should be used only in cases where :class:`Enum` and :class:`Flag` "
"will not do; for example, when integer constants are replaced with "
"enumerations, or for interoperability with other systems."
msgstr ""
"ほとんどの新しいコードでは、 :class:`Enum` と :class:`Flag` が強く推奨されま"
"す。\n"
"というのは、 :class:`IntEnum` と :class:`IntFlag` は (整数と比較でき、従って"
"推移的に他の無関係な列挙型と比較できてしまうことにより) 列挙型の意味論的な約"
"束に反するからです。\n"
":class:`IntEnum` と :class:`IntFlag` は、 :class:`Enum` や :class:`Flag` では"
"上手くいかない場合のみに使うべきです;\n"
"例えば、整数定数を列挙型で置き換えるときや、他のシステムとの相互運用性を持た"
"せたいときです。"

#: ../../howto/enum.rst:806
msgid "Others"
msgstr "その他"

#: ../../howto/enum.rst:808
msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr ""
":class:`IntEnum` は :mod:`enum` モジュールの一部ですが、単独での実装もとても"
"簡単に行なえます::"

#: ../../howto/enum.rst:814
msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`StrEnum` that mixes in :class:`str` instead of :class:"
"`int`."
msgstr ""
"ここでは似たような列挙型の派生を定義する方法を紹介します; 例えば、:class:"
"`StrEnum` は :class:`int` ではなく :class:`str` で複合させたものです。"

#: ../../howto/enum.rst:817
msgid "Some rules:"
msgstr "いくつかのルール:"

#: ../../howto/enum.rst:819
msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before :class:"
"`Enum` itself in the sequence of bases, as in the :class:`IntEnum` example "
"above."
msgstr ""
":class:`Enum` のサブクラスを作成するとき、複合させるデータ型は、基底クラスの"
"並びで :class:`Enum` 自身より先に記述しなければなりません (上記 :class:"
"`IntEnum` の例を参照)。"

#: ../../howto/enum.rst:822
msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. :class:"
"`int` above.  This restriction does not apply to mix-ins which only add "
"methods and don't specify another type."
msgstr ""
":class:`Enum` のメンバーはどんなデータ型でも構いませんが、追加のデータ型 (例"
"えば、上の例の :class:`int`) と複合させてしまうと、すべてのメンバーの値はその"
"データ型でなければならなくなります。この制限は、メソッドの追加するだけの、他"
"のデータ型を指定しない複合には適用されません。"

#: ../../howto/enum.rst:826
msgid ""
"When another data type is mixed in, the :attr:`value` attribute is *not the "
"same* as the enum member itself, although it is equivalent and will compare "
"equal."
msgstr ""
"他のデータ型と複合された場合、 :attr:`value` 属性は、たとえ等価であり等価であ"
"ると比較が行えても、列挙型メンバー自身としては *同じではありません* 。"

#: ../../howto/enum.rst:829
msgid ""
"%-style formatting:  `%s` and `%r` call the :class:`Enum` class's :meth:"
"`__str__` and :meth:`__repr__` respectively; other codes (such as `%i` or "
"`%h` for IntEnum) treat the enum member as its mixed-in type."
msgstr ""
"%-方式の書式:  `%s` および `%r` はそれぞれ :class:`Enum` クラスの :meth:"
"`__str__` および :meth:`__repr__` を呼び出します;\n"
"その他のコード (IntEnum の `%i` や `%h` など) は列挙型のメンバーを複合された"
"データ型として扱います。"

#: ../../howto/enum.rst:832
msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and :func:"
"`format` will use the mixed-in type's :meth:`__format__` unless :meth:"
"`__str__` or :meth:`__format__` is overridden in the subclass, in which case "
"the overridden methods or :class:`Enum` methods will be used. Use the !s "
"and !r format codes to force usage of the :class:`Enum` class's :meth:"
"`__str__` and :meth:`__repr__` methods."
msgstr ""

#: ../../howto/enum.rst:840
msgid "When to use :meth:`__new__` vs. :meth:`__init__`"
msgstr ":meth:`__new__` と :meth:`__init__` のどちらを使うべきか"

#: ../../howto/enum.rst:842
msgid ""
":meth:`__new__` must be used whenever you want to customize the actual value "
"of the :class:`Enum` member.  Any other modifications may go in either :meth:"
"`__new__` or :meth:`__init__`, with :meth:`__init__` being preferred."
msgstr ""
":meth:`__new__` は :class:`Enum` メンバーの実際の値をカスタマイズしたいときに"
"利用します。他の変更を加える場合、 :meth:`__new__` と :meth:`__init__` のどち"
"らを利用するかは、:meth:`__init__` の方が望ましいでしょう。"

#: ../../howto/enum.rst:846
msgid ""
"For example, if you want to pass several items to the constructor, but only "
"want one of them to be the value::"
msgstr ""
"例えば、複数の値をコンストラクタに渡すが、その中の1つだけを値として使いたい場"
"合は次のようにします:"

#: ../../howto/enum.rst:873
msgid "Finer Points"
msgstr "細かい点"

#: ../../howto/enum.rst:876
msgid "Supported ``__dunder__`` names"
msgstr "``__dunder__`` 名のサポート"

#: ../../howto/enum.rst:878
msgid ""
":attr:`__members__` is a read-only ordered mapping of ``member_name``:"
"``member`` items.  It is only available on the class."
msgstr ""
":attr:`__members__` は読み込み専用の、 ``member_name``:``member``  を要素とす"
"る順序付きマッピングです。これはクラスでのみ利用可能です。"

#: ../../howto/enum.rst:881
msgid ""
":meth:`__new__`, if specified, must create and return the enum members; it "
"is also a very good idea to set the member's :attr:`_value_` appropriately.  "
"Once all the members are created it is no longer used."
msgstr ""
":meth:`__new__` が、もし指定されていた場合、列挙型のメンバーを作成し、返しま"
"す;\n"
"そのメンバー の :attr:`_value_` を適切に設定するのも非常によい考えです。\n"
"いったん全てのメンバーが作成されると、それ以降 :meth:`__new__` は使われませ"
"ん。"

#: ../../howto/enum.rst:887
msgid "Supported ``_sunder_`` names"
msgstr "``_sunder_`` 名のサポート"

#: ../../howto/enum.rst:889
msgid "``_name_`` -- name of the member"
msgstr "``_name_`` -- メンバー名"

#: ../../howto/enum.rst:890
msgid ""
"``_value_`` -- value of the member; can be set / modified in ``__new__``"
msgstr ""
"``_value_`` -- メンバーの値; ``__new__`` で設定したり、変更したりできます"

#: ../../howto/enum.rst:892
msgid ""
"``_missing_`` -- a lookup function used when a value is not found; may be "
"overridden"
msgstr ""
"``_missing_`` -- 値が見付からなかったときに使われる検索関数; オーバーライドさ"
"れていることがあります"

#: ../../howto/enum.rst:894
msgid ""
"``_ignore_`` -- a list of names, either as a :class:`list` or a :class:"
"`str`, that will not be transformed into members, and will be removed from "
"the final class"
msgstr ""
"``_ignore_`` -- 名前のリストで、 :class:`list` もしくは :class:`str` です。こ"
"の名前の要素はメンバーへの変換が行われず、最終的なクラスから削除されます"

#: ../../howto/enum.rst:897
msgid ""
"``_order_`` -- used in Python 2/3 code to ensure member order is consistent "
"(class attribute, removed during class creation)"
msgstr ""
"``_order_`` -- Python 2/3のコードでメンバーの順序を固定化するのに利用されます"
"（クラス属性で、クラス作成時に削除されます）"

#: ../../howto/enum.rst:899
msgid ""
"``_generate_next_value_`` -- used by the `Functional API`_ and by :class:"
"`auto` to get an appropriate value for an enum member; may be overridden"
msgstr ""
"``_generate_next_value_`` -- `Functional API`_ から利用され、 :class:`auto` "
"が列挙型のメンバーの適切な値を取得するのに使われます。オーバーライドされま"
"す。"

#: ../../howto/enum.rst:905
msgid ""
"For standard :class:`Enum` classes the next value chosen is the last value "
"seen incremented by one."
msgstr ""

#: ../../howto/enum.rst:908
msgid ""
"For :class:`Flag` classes the next value chosen will be the next highest "
"power-of-two, regardless of the last value seen."
msgstr ""

#: ../../howto/enum.rst:911
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

#: ../../howto/enum.rst:912
msgid "``_ignore_``"
msgstr "``_ignore_``"

#: ../../howto/enum.rst:914
msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`_order_` attribute "
"can be provided.  It will be checked against the actual order of the "
"enumeration and raise an error if the two do not match::"
msgstr ""
"Pythono 2 / Python 3のコードの同期を取りやすくするために :attr:`_order_` 属性"
"を提供できます。実際の列挙値の順序と比較して一致してなければエラーを送出しま"
"す::"

#: ../../howto/enum.rst:932
msgid ""
"In Python 2 code the :attr:`_order_` attribute is necessary as definition "
"order is lost before it can be recorded."
msgstr ""
"Python 2のコードでは :attr:`_order_` 属性は定義順が記録される前消えてしまうた"
"め、重要です。"

#: ../../howto/enum.rst:937
msgid "_Private__names"
msgstr "_Private__names"

#: ../../howto/enum.rst:939
msgid ""
"Private names are not converted to enum members, but remain normal "
"attributes."
msgstr ""

#: ../../howto/enum.rst:945
msgid "``Enum`` member type"
msgstr "``Enum`` メンバー型"

#: ../../howto/enum.rst:947
msgid ""
"Enum members are instances of their enum class, and are normally accessed as "
"``EnumClass.member``.  In Python versions ``3.5`` to ``3.9`` you could "
"access members from other members -- this practice was discouraged, and in "
"``3.12`` :class:`Enum` will return to not allowing it, while in ``3.10`` and "
"``3.11`` it will raise a :exc:`DeprecationWarning`::"
msgstr ""

#: ../../howto/enum.rst:968
msgid "Creating members that are mixed with other data types"
msgstr ""

#: ../../howto/enum.rst:970
msgid ""
"When subclassing other data types, such as :class:`int` or :class:`str`, "
"with an :class:`Enum`, all values after the `=` are passed to that data "
"type's constructor.  For example::"
msgstr ""

#: ../../howto/enum.rst:982
msgid "Boolean value of ``Enum`` classes and members"
msgstr "``Enum`` クラスとメンバーの真偽値"

#: ../../howto/enum.rst:984
msgid ""
"Enum classes that are mixed with non-:class:`Enum` types (such as :class:"
"`int`, :class:`str`, etc.) are evaluated according to the mixed-in type's "
"rules; otherwise, all members evaluate as :data:`True`.  To make your own "
"enum's boolean evaluation depend on the member's value add the following to "
"your class::"
msgstr ""
"(:class:`int`, :class:`str` などのような) 非 :class:`Enum` 型と複合させた "
"enum クラスは、その複合された型の規則に従って評価されます;\n"
"そうでない場合は、全てのメンバーは :data:`True` と評価されます。\n"
"メンバーの値に依存する独自の enum の真偽値評価を行うには、クラスに次のコード"
"を追加してください::"

#: ../../howto/enum.rst:993
msgid "Plain :class:`Enum` classes always evaluate as :data:`True`."
msgstr ""

#: ../../howto/enum.rst:997
msgid "``Enum`` classes with methods"
msgstr "メソッド付きの ``Enum`` クラス"

#: ../../howto/enum.rst:999
msgid ""
"If you give your enum subclass extra methods, like the `Planet`_ class "
"above, those methods will show up in a :func:`dir` of the member, but not of "
"the class::"
msgstr ""

#: ../../howto/enum.rst:1010
msgid "Combining members of ``Flag``"
msgstr "``Flag`` のメンバーの組み合わせ"

#: ../../howto/enum.rst:1012
msgid ""
"Iterating over a combination of :class:`Flag` members will only return the "
"members that are comprised of a single bit::"
msgstr ""

#: ../../howto/enum.rst:1029
msgid "``StrEnum`` and :meth:`str.__str__`"
msgstr ""

#: ../../howto/enum.rst:1031
msgid ""
"An important difference between :class:`StrEnum` and other Enums is the :"
"meth:`__str__` method; because :class:`StrEnum` members are strings, some "
"parts of Python will read the string data directly, while others will call :"
"meth:`str()`. To make those two operations have the same result, :meth:"
"`StrEnum.__str__` will be the same as :meth:`str.__str__` so that "
"``str(StrEnum.member) == StrEnum.member`` is true."
msgstr ""

#: ../../howto/enum.rst:1039
msgid "``Flag`` and ``IntFlag`` minutia"
msgstr ""

#: ../../howto/enum.rst:1041
msgid "Using the following snippet for our examples::"
msgstr ""

#: ../../howto/enum.rst:1052
msgid "the following are true:"
msgstr ""

#: ../../howto/enum.rst:1054
msgid "single-bit flags are canonical"
msgstr ""

#: ../../howto/enum.rst:1055
msgid "multi-bit and zero-bit flags are aliases"
msgstr ""

#: ../../howto/enum.rst:1056
msgid "only canonical flags are returned during iteration::"
msgstr ""

#: ../../howto/enum.rst:1061
msgid ""
"negating a flag or flag set returns a new flag/flag set with the "
"corresponding positive integer value::"
msgstr ""

#: ../../howto/enum.rst:1070
msgid "names of pseudo-flags are constructed from their members' names::"
msgstr ""

#: ../../howto/enum.rst:1075
msgid "multi-bit flags, aka aliases, can be returned from operations::"
msgstr ""

#: ../../howto/enum.rst:1086
msgid ""
"membership / containment checking has changed slightly -- zero valued flags "
"are never considered to be contained::"
msgstr ""

#: ../../howto/enum.rst:1092
msgid ""
"otherwise, if all bits of one flag are in the other flag, True is returned::"
msgstr ""

#: ../../howto/enum.rst:1097
msgid ""
"There is a new boundary mechanism that controls how out-of-range / invalid "
"bits are handled: ``STRICT``, ``CONFORM``, ``EJECT``, and ``KEEP``:"
msgstr ""

#: ../../howto/enum.rst:1100
msgid "STRICT --> raises an exception when presented with invalid values"
msgstr ""

#: ../../howto/enum.rst:1101
msgid "CONFORM --> discards any invalid bits"
msgstr ""

#: ../../howto/enum.rst:1102
msgid "EJECT --> lose Flag status and become a normal int with the given value"
msgstr ""

#: ../../howto/enum.rst:1106
msgid "KEEP --> keep the extra bits"
msgstr ""

#: ../../howto/enum.rst:1104
msgid "keeps Flag status and extra bits"
msgstr ""

#: ../../howto/enum.rst:1105
msgid "extra bits do not show up in iteration"
msgstr ""

#: ../../howto/enum.rst:1106
msgid "extra bits do show up in repr() and str()"
msgstr ""

#: ../../howto/enum.rst:1108
msgid ""
"The default for Flag is ``STRICT``, the default for ``IntFlag`` is "
"``EJECT``, and the default for ``_convert_`` is ``KEEP`` (see ``ssl."
"Options`` for an example of when ``KEEP`` is needed)."
msgstr ""

#: ../../howto/enum.rst:1116
msgid "How are Enums different?"
msgstr "Enum はどう違うのか?"

#: ../../howto/enum.rst:1118
msgid ""
"Enums have a custom metaclass that affects many aspects of both derived :"
"class:`Enum` classes and their instances (members)."
msgstr ""
"Enum は :class:`Enum` 派生クラスやそれらのインスタンス (メンバー) 双方の多く"
"の側面に影響を及ぼすカスタムメタクラスを持っています。"

#: ../../howto/enum.rst:1123
msgid "Enum Classes"
msgstr "Enum クラス"

#: ../../howto/enum.rst:1125
msgid ""
"The :class:`EnumType` metaclass is responsible for providing the :meth:"
"`__contains__`, :meth:`__dir__`, :meth:`__iter__` and other methods that "
"allow one to do things with an :class:`Enum` class that fail on a typical "
"class, such as `list(Color)` or `some_enum_var in Color`.  :class:`EnumType` "
"is responsible for ensuring that various other methods on the final :class:"
"`Enum` class are correct (such as :meth:`__new__`, :meth:`__getnewargs__`, :"
"meth:`__str__` and :meth:`__repr__`)."
msgstr ""

#: ../../howto/enum.rst:1135
msgid "Enum Members (aka instances)"
msgstr "Enum メンバー (インスタンス)"

#: ../../howto/enum.rst:1137
msgid ""
"The most interesting thing about enum members is that they are singletons. :"
"class:`EnumType` creates them all while it is creating the enum class "
"itself, and then puts a custom :meth:`__new__` in place to ensure that no "
"new ones are ever instantiated by returning only the existing member "
"instances."
msgstr ""
"enum メンバーについて最も興味深いのは、それらがシングルトンであるということで"
"す。:class:`EnumType` は enum クラス自身を作成し、メンバーを作成し、新しいイ"
"ンスタンスが作成されていないかどうかを確認するために既存のメンバーインスタン"
"スだけを返すカスタム :meth:`__new__` を追加します。"

#: ../../howto/enum.rst:1146
msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag`, and :"
"class:`IntFlag` are expected to cover the majority of use-cases, they cannot "
"cover them all.  Here are recipes for some different types of enumerations "
"that can be used directly, or as examples for creating one's own."
msgstr ""
":class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag`, :class:"
"`IntFlag` は用途の大部分をカバーすると予想されますが、そのすべてをカバーでき"
"ているわけではありません。ここでは、そのまま、あるいは独自の列挙型を作る例と"
"して使える、様々なタイプの列挙型を紹介します。"

#: ../../howto/enum.rst:1153
msgid "Omitting values"
msgstr "値の省略"

#: ../../howto/enum.rst:1155
msgid ""
"In many use-cases one doesn't care what the actual value of an enumeration "
"is. There are several ways to define this type of simple enumeration:"
msgstr ""
"多くの用途では、列挙型の実際の値が何かは気にされません。\n"
"このタイプの単純な列挙型を定義する方法はいくつかあります:"

#: ../../howto/enum.rst:1158
msgid "use instances of :class:`auto` for the value"
msgstr "値に :class:`auto` インスタンスを使用する"

#: ../../howto/enum.rst:1159
msgid "use instances of :class:`object` as the value"
msgstr "値として :class:`object` インスタンスを使用する"

#: ../../howto/enum.rst:1160
msgid "use a descriptive string as the value"
msgstr "値として解説文字列を使用する"

#: ../../howto/enum.rst:1161
msgid ""
"use a tuple as the value and a custom :meth:`__new__` to replace the tuple "
"with an :class:`int` value"
msgstr ""
"値としてタプルを使用し、独自の :meth:`__new__` を使用してタプルを :class:"
"`int` 値で置き換える"

#: ../../howto/enum.rst:1164
msgid ""
"Using any of these methods signifies to the user that these values are not "
"important, and also enables one to add, remove, or reorder members without "
"having to renumber the remaining members."
msgstr ""
"これらのどの方法を使ってもユーザーに対して、値は重要ではなく、他のメンバーの"
"番号の振り直しをする必要無しに、メンバーの追加、削除、並べ替えが行えるという"
"ことを示せます。"

#: ../../howto/enum.rst:1170
msgid "Using :class:`auto`"
msgstr ":class:`auto` を使う"

#: ../../howto/enum.rst:1172
msgid "Using :class:`auto` would look like::"
msgstr ":class:`auto` を使うと次のようになります::"

#: ../../howto/enum.rst:1184
msgid "Using :class:`object`"
msgstr ":class:`object` を使う"

#: ../../howto/enum.rst:1186
msgid "Using :class:`object` would look like::"
msgstr ":class:`object` を使うと次のようになります::"

#: ../../howto/enum.rst:1198
msgid "Using a descriptive string"
msgstr "解説文字列を使う"

#: ../../howto/enum.rst:1200
msgid "Using a string as the value would look like::"
msgstr "値として文字列を使うと次のようになります::"

#: ../../howto/enum.rst:1214
msgid "Using a custom :meth:`__new__`"
msgstr "独自の :meth:`__new__` を使う"

#: ../../howto/enum.rst:1216
msgid "Using an auto-numbering :meth:`__new__` would look like::"
msgstr "自動で番号を振る :meth:`__new__` を使うと次のようになります::"

#: ../../howto/enum.rst:1235
msgid ""
"To make a more general purpose ``AutoNumber``, add ``*args`` to the "
"signature::"
msgstr ""
"``AutoNumber`` をより広い用途で使うには、シグニチャに ``*args`` を追加しま"
"す::"

#: ../../howto/enum.rst:1245
msgid ""
"Then when you inherit from ``AutoNumber`` you can write your own "
"``__init__`` to handle any extra arguments::"
msgstr ""
"``AutoNumber`` を継承すると、追加の引数を取り扱える独自の ``__init__`` が書け"
"ます。"

#: ../../howto/enum.rst:1264
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members."
msgstr ""
":meth:`__new__` メソッドが定義されていれば、Enum 番号の作成時に使用されます; "
"これは Enum の :meth:`__new__` と置き換えられ、クラスが作成された後の既存の番"
"号を取得に使用されます。"

#: ../../howto/enum.rst:1270
msgid "OrderedEnum"
msgstr "OrderedEnum"

#: ../../howto/enum.rst:1272
msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr ""
":class:`IntEnum` をベースとしないため、通常の :class:`Enum` の不変条件 (他の"
"列挙型と比較できないなど) のままで、メンバーを順序付けできる列挙型です::"

#: ../../howto/enum.rst:1306
msgid "DuplicateFreeEnum"
msgstr "DuplicateFreeEnum"

#: ../../howto/enum.rst:1308
msgid ""
"Raises an error if a duplicate member name is found instead of creating an "
"alias::"
msgstr ""
"値が同じメンバーが見つかった場合、別名を作るのではなく、エラーを送出します::"

#: ../../howto/enum.rst:1333
msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"これは Enum に別名を無効にするのと同様な振る舞いの追加や変更をおこなうための"
"サブクラス化に役立つ例です。単に別名を無効にしたいだけなら、 :func:`unique` "
"デコレーターを使用して行えます。"

#: ../../howto/enum.rst:1339
msgid "Planet"
msgstr "Planet"

#: ../../howto/enum.rst:1341
msgid ""
"If :meth:`__new__` or :meth:`__init__` is defined the value of the enum "
"member will be passed to those methods::"
msgstr ""
":meth:`__new__` や :meth:`__init__` が定義されている場合、列挙型メンバーの値"
"はこれらのメソッドに渡されます::"

#: ../../howto/enum.rst:1370
msgid "TimePeriod"
msgstr "TimePeriod"

#: ../../howto/enum.rst:1372
msgid "An example to show the :attr:`_ignore_` attribute in use::"
msgstr ":attr:`_ignore_` 属性の使用方法のサンプルです::"

#: ../../howto/enum.rst:1389
msgid "Conforming input to Flag"
msgstr ""

#: ../../howto/enum.rst:1391
msgid ""
"Creating a :class:`Flag` enum that is more resilient out-of-bounds results "
"to mathematical operations, you can use the :attr:`FlagBoundary.CONFORM` "
"setting::"
msgstr ""

#: ../../howto/enum.rst:1411
msgid "Subclassing EnumType"
msgstr "EnumType のサブクラスを作る"

#: ../../howto/enum.rst:1413
msgid ""
"While most enum needs can be met by customizing :class:`Enum` subclasses, "
"either with class decorators or custom functions, :class:`EnumType` can be "
"subclassed to provide a different Enum experience."
msgstr ""
