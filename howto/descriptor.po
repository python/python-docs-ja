# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2021
# mollinaca, 2021
# 渋川よしき <yoshiki@shibu.jp>, 2021
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-24 14:15+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: 渋川よしき <yoshiki@shibu.jp>, 2021\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/descriptor.rst:5
msgid "Descriptor HowTo Guide"
msgstr "デスクリプタ HowTo ガイド"

#: ../../howto/descriptor.rst:0
msgid "Author"
msgstr "著者"

#: ../../howto/descriptor.rst:7
msgid "Raymond Hettinger"
msgstr "Raymond Hettinger"

#: ../../howto/descriptor.rst:0
msgid "Contact"
msgstr "問い合わせ先"

#: ../../howto/descriptor.rst:8
msgid "<python at rcn dot com>"
msgstr "<python at rcn dot com>"

#: ../../howto/descriptor.rst:11
msgid "Contents"
msgstr "内容"

#: ../../howto/descriptor.rst:13
msgid ""
":term:`Descriptors <descriptor>` let objects customize attribute lookup, "
"storage, and deletion."
msgstr ""
":term:`デスクリプタ <descriptor>` を使うと、オブジェクトの属性検索、保存、削"
"除をカスタマイズできます。"

#: ../../howto/descriptor.rst:16
msgid "This guide has four major sections:"
msgstr "本ガイドは4つの大項目から構成されています。"

#: ../../howto/descriptor.rst:18
msgid ""
"The \"primer\" gives a basic overview, moving gently from simple examples, "
"adding one feature at a time.  Start here if you're new to descriptors."
msgstr ""
"最初の「入門」では基本の紹介をして、シンプルな例から少しずつ概念を説明してい"
"きます。もしデスクリプタに触れるのが初めての場合はここから学んでいきましょ"
"う。"

#: ../../howto/descriptor.rst:21
msgid ""
"The second section shows a complete, practical descriptor example.  If you "
"already know the basics, start there."
msgstr ""
"2つ目のセクションでは完全で実践的なデスクリプタのサンプルを紹介します。もしデ"
"スクリプタの基本を理解しているのであれば、ここから読み始めても良いでしょう。"

#: ../../howto/descriptor.rst:24
msgid ""
"The third section provides a more technical tutorial that goes into the "
"detailed mechanics of how descriptors work.  Most people don't need this "
"level of detail."
msgstr ""
"3番目のセクションはより技巧的なチュートリアルを通じて、デスクリプタがどのよう"
"なメカニズムで動作しているのかを紹介します。多くの人はこのレベルの理解は不要"
"でしょう。"

#: ../../howto/descriptor.rst:28
msgid ""
"The last section has pure Python equivalents for built-in descriptors that "
"are written in C.  Read this if you're curious about how functions turn into "
"bound methods or about the implementation of common tools like :func:"
"`classmethod`, :func:`staticmethod`, :func:`property`, and :term:`__slots__`."
msgstr ""
"最後のセクションは、Cで書かれた組み込みのデスクリプタをピュアPythonで実現する"
"方法を紹介します。このセクションがどのように関数が束縛メソッドになるのか、 :"
"func:`classmethod` や :func:`staticmethod`, :term:`__slots__` といった一般的"
"なツールの実装がどのようになっているのか興味を持ったら読んでください。"

#: ../../howto/descriptor.rst:36
msgid "Primer"
msgstr "入門"

#: ../../howto/descriptor.rst:38
msgid ""
"In this primer, we start with the most basic possible example and then we'll "
"add new capabilities one by one."
msgstr ""
"この入門では、なるべく基礎的なところから開始し、新しい要素を一つずつ紹介して"
"いきます。"

#: ../../howto/descriptor.rst:43
msgid "Simple example: A descriptor that returns a constant"
msgstr "シンプルな例: 定数を返すデスクリプタ"

#: ../../howto/descriptor.rst:45
msgid ""
"The :class:`Ten` class is a descriptor whose :meth:`__get__` method always "
"returns the constant ``10``:"
msgstr ""
":class:`Ten` クラスはデスクリプタで、その :meth:`__get__` メソッドは常に定数"
"の ``10`` を返します。"

#: ../../howto/descriptor.rst:54
msgid ""
"To use the descriptor, it must be stored as a class variable in another "
"class:"
msgstr "このデスクリプタを使うには他のクラスのクラス変数として保存します:"

#: ../../howto/descriptor.rst:62
msgid ""
"An interactive session shows the difference between normal attribute lookup "
"and descriptor lookup:"
msgstr ""
"インタラクティブセッションを使って、通常の属性ルックアップと、デスクリプタの"
"ルックアップの違いを見てみましょう。"

#: ../../howto/descriptor.rst:73
msgid ""
"In the ``a.x`` attribute lookup, the dot operator finds ``'x': 5`` in the "
"class dictionary.  In the ``a.y`` lookup, the dot operator finds a "
"descriptor instance, recognized by its ``__get__`` method. Calling that "
"method returns ``10``."
msgstr ""
"``a.x`` 属性ルックアップではドット演算子がクラス辞書野中から ``'x': 5`` を見"
"つけます。 ``a.y`` ルックアップではドット演算子は ``__get__`` メソッドを持つ"
"デスクリプタインスタンスを取得します。そのメソッドを呼び出すと、 ``10`` を返"
"します。"

#: ../../howto/descriptor.rst:78
msgid ""
"Note that the value ``10`` is not stored in either the class dictionary or "
"the instance dictionary.  Instead, the value ``10`` is computed on demand."
msgstr ""
"``10`` はクラスの辞書にも、インスタンスの辞書にも格納されていません。その代わ"
"り、 ``10`` はオンデマンドに計算されます。"

#: ../../howto/descriptor.rst:81
msgid ""
"This example shows how a simple descriptor works, but it isn't very useful. "
"For retrieving constants, normal attribute lookup would be better."
msgstr ""
"このサンプルは、シンプルなデスクリプタがどのように動作するかを説明するための"
"ものですが、実用的ではありません。定数を返す場合、通常の属性アクセスの方が良"
"いでしょう。"

#: ../../howto/descriptor.rst:84
msgid ""
"In the next section, we'll create something more useful, a dynamic lookup."
msgstr "次のセクションでは、より実践的な動的なルックアップを作成します。"

#: ../../howto/descriptor.rst:88
msgid "Dynamic lookups"
msgstr "動的なルックアップ"

#: ../../howto/descriptor.rst:90
msgid ""
"Interesting descriptors typically run computations instead of returning "
"constants:"
msgstr ""
"単に定数を返すよりも、なにか処理を実行するデスクリプタの方が面白いでしょう。"

#: ../../howto/descriptor.rst:109
msgid ""
"An interactive session shows that the lookup is dynamic — it computes "
"different, updated answers each time::"
msgstr ""
"インタラクティブセッションで見たように、この探索は動的です。実行ごとに異なる"
"計算を行い、毎回答えが更新されます。"

#: ../../howto/descriptor.rst:122
msgid ""
"Besides showing how descriptors can run computations, this example also "
"reveals the purpose of the parameters to :meth:`__get__`.  The *self* "
"parameter is *size*, an instance of *DirectorySize*.  The *obj* parameter is "
"either *g* or *s*, an instance of *Directory*.  It is the *obj* parameter "
"that lets the :meth:`__get__` method learn the target directory.  The "
"*objtype* parameter is the class *Directory*."
msgstr ""
"このサンプルはデスクリプタの中でどのように処理を行うかだけではなく、 :meth:"
"`__get__` の引数の目的も示しています。 *self* パラメータは *size* で、 "
"*DirectorySize* のインスタンスです。 *obj* パラメータは *g* や *s* といった "
"*Directory* のインスタンスです。 *obj* により、 :meth:`__get__` はターゲット"
"のディレクトリを知れます。 *objtype* パラメータは *Directory* クラスです。"

#: ../../howto/descriptor.rst:131
msgid "Managed attributes"
msgstr "管理された属性"

#: ../../howto/descriptor.rst:133
msgid ""
"A popular use for descriptors is managing access to instance data.  The "
"descriptor is assigned to a public attribute in the class dictionary while "
"the actual data is stored as a private attribute in the instance "
"dictionary.  The descriptor's :meth:`__get__` and :meth:`__set__` methods "
"are triggered when the public attribute is accessed."
msgstr ""
"デスクリプタで広く使われる用途がインスタンスのデータへのアクセスの管理です。"
"このデスクリプタはクラス辞書のパブリックな属性に割り当てられますが、実際の"
"データはインスタンス辞書のプライベートな属性に保存します。パブリックなアクセ"
"スが行われると、デスクリプタの :meth:`__get__` と :meth:`__set__` メソッドが"
"実行されます。"

#: ../../howto/descriptor.rst:139
msgid ""
"In the following example, *age* is the public attribute and *_age* is the "
"private attribute.  When the public attribute is accessed, the descriptor "
"logs the lookup or update:"
msgstr ""
"このサンプルでは *age* はパブリックな属性で、 *_age* はプライベートな属性で"
"す。パブリックな属性がアクセスされると、デスクリプタはルックアップや更新のロ"
"グ出力をします。"

#: ../../howto/descriptor.rst:172
msgid ""
"An interactive session shows that all access to the managed attribute *age* "
"is logged, but that the regular attribute *name* is not logged:"
msgstr ""
"インタラクティブセッションの結果で見てわかるように、管理された属性の *age* の"
"ログ出力が行われますが、通常の属性の *name* はログ出力されません。"

#: ../../howto/descriptor.rst:206
msgid ""
"One major issue with this example is that the private name *_age* is "
"hardwired in the *LoggedAgeAccess* class.  That means that each instance can "
"only have one logged attribute and that its name is unchangeable.  In the "
"next example, we'll fix that problem."
msgstr ""
"このサンプル実装には大きな問題があります。プライベートな名前の *_age* が "
"*LoggedAgeAccess* クラスの中でハードコードされています。そのため、どのインス"
"タンスも1つしかこのログ出力される属性が作れず、名前を変更できません。次のサン"
"プルでこの問題を解決していきます。"

#: ../../howto/descriptor.rst:213
msgid "Customized names"
msgstr "名前のカスタマイズ"

#: ../../howto/descriptor.rst:215
msgid ""
"When a class uses descriptors, it can inform each descriptor about which "
"variable name was used."
msgstr ""
"クラスがデスクリプタを使うときに、クラスはそれぞれのデスクリプタにどのような"
"変数名を使うかを通知します。"

#: ../../howto/descriptor.rst:218
msgid ""
"In this example, the :class:`Person` class has two descriptor instances, "
"*name* and *age*.  When the :class:`Person` class is defined, it makes a "
"callback to :meth:`__set_name__` in *LoggedAccess* so that the field names "
"can be recorded, giving each descriptor its own *public_name* and "
"*private_name*:"
msgstr ""
"このサンプルでは :class:`Person` クラスは、 *name* と *age* という2つのデスク"
"リプタインスタンスを持っています。 :class:`Person` が定義されると、  "
"*LoggedAccess* の :meth:`__set_name__` にコールバックを行うため、フィールド名"
"を記録できます。それぞれのデスクリプタは、 *public_name* と *private_name* を"
"持ちます。"

#: ../../howto/descriptor.rst:256
msgid ""
"An interactive session shows that the :class:`Person` class has called :meth:"
"`__set_name__` so that the field names would be recorded.  Here we call :"
"func:`vars` to look up the descriptor without triggering it:"
msgstr ""
"インタラクティブセッション上で試すと、 :class:`Person` クラスが :meth:"
"`__set_name__` を呼び出し、フィールド名が記録されることが分かるでしょう。 :"
"func:`vars` を呼んで、デスクリプタを起動しないでデスクリプタを取得してみま"
"しょう。"

#: ../../howto/descriptor.rst:267
msgid "The new class now logs access to both *name* and *age*:"
msgstr "新しいクラスは *name* と *age* の両方でログを出力します。"

#: ../../howto/descriptor.rst:284
msgid "The two *Person* instances contain only the private names:"
msgstr "2つの *Person* のインスタンスは、プライベート名しか保持していません。"

#: ../../howto/descriptor.rst:295
msgid "Closing thoughts"
msgstr "まとめ"

#: ../../howto/descriptor.rst:297
msgid ""
"A :term:`descriptor` is what we call any object that defines :meth:"
"`__get__`, :meth:`__set__`, or :meth:`__delete__`."
msgstr ""
":meth:`__get__` 、 :meth:`__set__` 、あるいは :meth:`__delete__` メソッドを定"
"義したあらゆるオブジェクトが、我々が :term:`descriptor` と呼ぶものです。"

#: ../../howto/descriptor.rst:300
msgid ""
"Optionally, descriptors can have a :meth:`__set_name__` method.  This is "
"only used in cases where a descriptor needs to know either the class where "
"it was created or the name of class variable it was assigned to.  (This "
"method, if present, is called even if the class is not a descriptor.)"
msgstr ""
"それに追加して、デスクリプタは :meth:`__set_name__` メソッドを持つこともでき"
"ます。このメソッドは、デスクリプタが設定されるクラス、あるいはアサインされた"
"クラス変数を知る必要がある場合に利用されます。もし存在していれば、クラスがデ"
"スクリプタでなくても呼ばれます。"

#: ../../howto/descriptor.rst:305
msgid ""
"Descriptors get invoked by the dot operator during attribute lookup.  If a "
"descriptor is accessed indirectly with ``vars(some_class)"
"[descriptor_name]``, the descriptor instance is returned without invoking it."
msgstr ""
"デスクリプタは属性のルックアップ中に、ドット演算子によって呼び出されます。 "
"``vars(some_class)[descriptor_name]`` という書き方によって間接的にデスクリプ"
"タがアクセスされると、デスクリプタを実行することなく、デスクリプタのインスタ"
"ンスが返されます。"

#: ../../howto/descriptor.rst:309
msgid ""
"Descriptors only work when used as class variables.  When put in instances, "
"they have no effect."
msgstr ""
"デスクリプタはクラス変数として利用したときにだけ動作します。インスタンスに設"
"定しても効果はありません。"

#: ../../howto/descriptor.rst:312
msgid ""
"The main motivation for descriptors is to provide a hook allowing objects "
"stored in class variables to control what happens during attribute lookup."
msgstr ""
"デスクリプタは、クラス変数として格納されているオブジェクトが属性ルックアップ"
"中に発生することを制御できるように、フックを提供することが主なモチベーション"
"となっています。"

#: ../../howto/descriptor.rst:315
msgid ""
"Traditionally, the calling class controls what happens during lookup. "
"Descriptors invert that relationship and allow the data being looked-up to "
"have a say in the matter."
msgstr ""
"伝統的には、呼び出し側のクラスが、ルックアップ中に発生することを制御してきま"
"したが、デスクリプタはその関係を逆転させ、検索されているデータが問題に介入で"
"きるようにします。"

#: ../../howto/descriptor.rst:319
msgid ""
"Descriptors are used throughout the language.  It is how functions turn into "
"bound methods.  Common tools like :func:`classmethod`, :func:"
"`staticmethod`, :func:`property`, and :func:`functools.cached_property` are "
"all implemented as descriptors."
msgstr ""
"デスクリプタは、Pythonのさまざまなところで利用されています。これにより、単な"
"る関数は、インスタンスに束縛されたメソッドになります。 :func:`classmethod`, :"
"func:`staticmethod`,  :func:`property`,:func:`functools.cached_property` と"
"いったツールもすべて、デスクリプタとして実装されています。"

#: ../../howto/descriptor.rst:326
msgid "Complete Practical Example"
msgstr "実践的なサンプル"

#: ../../howto/descriptor.rst:328
msgid ""
"In this example, we create a practical and powerful tool for locating "
"notoriously hard to find data corruption bugs."
msgstr ""
"このサンプルでは、発見が極めて難しいデータ破損バグを特定するのに利用可能な、"
"実践的でパワフルなツールを紹介します。"

#: ../../howto/descriptor.rst:333
msgid "Validator class"
msgstr "バリデータクラス"

#: ../../howto/descriptor.rst:335
msgid ""
"A validator is a descriptor for managed attribute access.  Prior to storing "
"any data, it verifies that the new value meets various type and range "
"restrictions.  If those restrictions aren't met, it raises an exception to "
"prevent data corruption at its source."
msgstr ""
"バリデータは管理された属性アクセスのためのデスクリプタです。データを格納する"
"前に、新しい値が型が適合しているか、値の範囲制限に適合しているかを検証しま"
"す。もし制限に合わなければ、例外を送出し、データが不正な状態になるのを防ぎま"
"す。"

#: ../../howto/descriptor.rst:340
msgid ""
"This :class:`Validator` class is both an :term:`abstract base class` and a "
"managed attribute descriptor:"
msgstr ""
":class:Valicator` クラスは :term:`abstract base class` であり、属性管理デスク"
"リプタでもあります。"

#: ../../howto/descriptor.rst:363
msgid ""
"Custom validators need to inherit from :class:`Validator` and must supply a :"
"meth:`validate` method to test various restrictions as needed."
msgstr ""
"カスタムバリデータを作成するには :class:`Valicator` を継承し、 :meth:"
"`validate` メソッドを作成して必要に応じてさまざまな制約の検証を行います。"

#: ../../howto/descriptor.rst:368
msgid "Custom validators"
msgstr "カスタムバリデータ"

#: ../../howto/descriptor.rst:370
msgid "Here are three practical data validation utilities:"
msgstr ""
"ここでは3つの実践的なバリデーションのユーティリティのサンプルを紹介します。"

#: ../../howto/descriptor.rst:372
msgid ""
":class:`OneOf` verifies that a value is one of a restricted set of options."
msgstr ""
":class:`OneOf` は制限された候補の集合に含まれる値かどうかを検証します。"

#: ../../howto/descriptor.rst:374
msgid ""
":class:`Number` verifies that a value is either an :class:`int` or :class:"
"`float`.  Optionally, it verifies that a value is between a given minimum or "
"maximum."
msgstr ""
":class:`Number` は値が :class:`int: か :class:`float` かどうかを検証します。"
"オプションで、値が指定された最小値と最大値に含まれるかも検証します。"

#: ../../howto/descriptor.rst:378
msgid ""
":class:`String` verifies that a value is a :class:`str`.  Optionally, it "
"validates a given minimum or maximum length.  It can validate a user-defined "
"`predicate <https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)>`_ "
"as well."
msgstr ""
":class:`String` は値が :calss:`str` かどうか検証します。オプションで、指定さ"
"れた最小、最大の長さの検証をします。ユーザー定義の `術語 <https://en."
"wikipedia.org/wiki/Predicate_(mathematical_logic)>`_ 検証も行えます。"

#: ../../howto/descriptor.rst:437
msgid "Practical application"
msgstr "実践的なアプリケーション"

#: ../../howto/descriptor.rst:439
msgid "Here's how the data validators can be used in a real class:"
msgstr "次のコードは実際のクラスでデータバリデータを使う方法のサンプルです。"

#: ../../howto/descriptor.rst:454
msgid "The descriptors prevent invalid instances from being created:"
msgstr "これらのデスクリプタは、不正インスタンスが作成されるのを防ぎます。"

#: ../../howto/descriptor.rst:481
msgid "Technical Tutorial"
msgstr "技術的なチュートリアル"

#: ../../howto/descriptor.rst:483
msgid ""
"What follows is a more technical tutorial for the mechanics and details of "
"how descriptors work."
msgstr ""
"これから先はデスクリプタのメカニズムや動作の詳細について、よりテクニカルな"
"チュートリアルになります。"

#: ../../howto/descriptor.rst:488
msgid "Abstract"
msgstr "概要"

#: ../../howto/descriptor.rst:490
msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors are "
"called.  Provides an example showing how object relational mappings work."
msgstr ""
"デスクリプタの定義、プロトコルのサマリー、デスクリプタがどのように呼び出され"
"るかの説明、ORマッパーがどのように動作するかのサンプルを提示します。"

#: ../../howto/descriptor.rst:493
msgid ""
"Learning about descriptors not only provides access to a larger toolset, it "
"creates a deeper understanding of how Python works."
msgstr ""
"デスクリプタについて学ぶことにより、新しいツールセットが使えるようになるだけ"
"でなく、Python の仕組みについてのより深い理解が得られます。"

#: ../../howto/descriptor.rst:498
msgid "Definition and introduction"
msgstr "定義と導入"

#: ../../howto/descriptor.rst:500
msgid ""
"In general, a descriptor is an attribute value that has one of the methods "
"in the descriptor protocol.  Those methods are :meth:`__get__`, :meth:"
"`__set__`, and :meth:`__delete__`.  If any of those methods are defined for "
"an attribute, it is said to be a :term:`descriptor`."
msgstr ""
"一般に、デスクリプタは、デスクリプタプロトコルで定義されたメソッドを持つ属性"
"値です。このメソッドは、 :meth:`__get__`, :meth:`__set__`, および :meth:"
"`__delete__` です。これらのメソッドのいずれかが、オブジェクトに定義されていれ"
"ば、それはデスクリプタと呼ばれます。"

#: ../../howto/descriptor.rst:505
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the method resolution order of ``type(a)``. If the looked-"
"up value is an object defining one of the descriptor methods, then Python "
"may override the default behavior and invoke the descriptor method instead. "
"Where this occurs in the precedence chain depends on which descriptor "
"methods were defined."
msgstr ""
"属性アクセスのデフォルトの振る舞いは、オブジェクトの辞書の属性の取得、設定、"
"削除です。例えば ``a.x`` は、まず ``a.__dict__['x']``、それから ``type(a)."
"__dict__['x']``、さらに ``type(a)`` のメソッド探索順序に従ったさらなる探索へ"
"と連鎖します。見つかった値が、デスクリプタメソッドのいずれかを定義しているオ"
"ブジェクトなら、Python はそのデフォルトの振る舞いをオーバーライドし、代わりに"
"デスクリプタメソッドを呼び出します。これがどの連鎖順位で行われるかは、どのデ"
"スクリプタメソッドが定義されているかに依ります。"

#: ../../howto/descriptor.rst:514
msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and :"
"func:`super()`.  They are used throughout Python itself.  Descriptors "
"simplify the underlying C code and offer a flexible set of new tools for "
"everyday Python programs."
msgstr ""
"デスクリプタは、強力な、多目的のプロトコルです。これはプロパティ、メソッド、"
"静的メソッド、クラスメソッド、そして :func:`super()` の背後にある機構です。"
"Python のいたるところで使われています。デスクリプタは、基幹にある C コードを"
"簡潔にし、毎日の Python プログラムに、柔軟な新しいツール群を提供します。"

#: ../../howto/descriptor.rst:522
msgid "Descriptor protocol"
msgstr "デスクリプタプロトコル"

#: ../../howto/descriptor.rst:524
msgid "``descr.__get__(self, obj, type=None) -> value``"
msgstr "``descr.__get__(self, obj, type=None) -> value``"

#: ../../howto/descriptor.rst:526
msgid "``descr.__set__(self, obj, value) -> None``"
msgstr "``descr.__set__(self, obj, value) -> None``"

#: ../../howto/descriptor.rst:528
msgid "``descr.__delete__(self, obj) -> None``"
msgstr "``descr.__delete__(self, obj) -> None``"

#: ../../howto/descriptor.rst:530
msgid ""
"That is all there is to it.  Define any of these methods and an object is "
"considered a descriptor and can override default behavior upon being looked "
"up as an attribute."
msgstr ""
"これで全てです。これらのメソッドのいずれかを定義すれば、オブジェクトはデスク"
"リプタとみなされ、探索された際のデフォルトの振る舞いをオーバーライドできま"
"す。"

#: ../../howto/descriptor.rst:534
msgid ""
"If an object defines :meth:`__set__` or :meth:`__delete__`, it is considered "
"a data descriptor.  Descriptors that only define :meth:`__get__` are called "
"non-data descriptors (they are often used for methods but other uses are "
"possible)."
msgstr ""
"あるオブジェクトが :meth:`__set__` と :meth:`__delete__` の両方を定義していた"
"ら、それはデータデスクリプタとみなされます。 :meth:`__get__` だけを定義してい"
"るデスクリプタは、非データデスクリプタと呼ばれます (これらはよくメソッドに使"
"われますが、他の使い方も出来ます)。"

#: ../../howto/descriptor.rst:539
msgid ""
"Data and non-data descriptors differ in how overrides are calculated with "
"respect to entries in an instance's dictionary.  If an instance's dictionary "
"has an entry with the same name as a data descriptor, the data descriptor "
"takes precedence.  If an instance's dictionary has an entry with the same "
"name as a non-data descriptor, the dictionary entry takes precedence."
msgstr ""
"データデスクリプタと非データデスクリプタでは、オーバーライドがインスタンスの"
"辞書のエントリに関してどのように計算されるかが異なります。インスタンスの辞書"
"に、データデスクリプタと同名の項目があれば、データデスクリプタの方が優先され"
"ます。インスタンスの辞書に、非データデスクリプタと同名の項目があれば、辞書の"
"項目の方が優先されます。"

#: ../../howto/descriptor.rst:545
msgid ""
"To make a read-only data descriptor, define both :meth:`__get__` and :meth:"
"`__set__` with the :meth:`__set__` raising an :exc:`AttributeError` when "
"called.  Defining the :meth:`__set__` method with an exception raising "
"placeholder is enough to make it a data descriptor."
msgstr ""
"読み出し専用のデータデスクリプタを作るには、 :meth:`__get__` と :meth:"
"`__set__` の両方を定義し、 :meth:`__set__` が呼び出されたときに :exc:"
"`AttributeError` が送出されるようにしてください。例外を送出する :meth:"
"`__set__` メソッドをプレースホルダとして定義すれば、データデスクリプタにする"
"のに十分です。"

#: ../../howto/descriptor.rst:552
msgid "Overview of descriptor invocation"
msgstr "デスクリプタ呼び出しの概要"

#: ../../howto/descriptor.rst:554
msgid ""
"A descriptor can be called directly with ``desc.__get__(obj)`` or ``desc."
"__get__(None, cls)``."
msgstr ""
"``desc.__get__(obj)`` や ``desc.__get__(None, cls)`` を使うとデスクリプタを直"
"接呼び出すことができます。"

#: ../../howto/descriptor.rst:557
msgid ""
"But it is more common for a descriptor to be invoked automatically from "
"attribute access."
msgstr ""
"しかし、属性アクセスの際に自動的に呼び出されるのが、一般的なデスクリプタの呼"
"び出し方法です。"

#: ../../howto/descriptor.rst:560
msgid ""
"The expression ``obj.x`` looks up the attribute ``x`` in the chain of "
"namespaces for ``obj``.  If the search finds a descriptor outside of the "
"instance ``__dict__``, its :meth:`__get__` method is invoked according to "
"the precedence rules listed below."
msgstr ""
"式 ``obj.x`` は ``obj`` の名前空間のチェーンの中で属性 ``x`` を探索します。も"
"し、その検索のロジックの中で、インスタンスの ``__dict__`` の外でデスクリプタ"
"を見つけた場合、探索ルールのリストのリストに従って、そのデスクリプタの :meth:"
"``__get__` メソッドが呼び出されます。"

#: ../../howto/descriptor.rst:565
msgid ""
"The details of invocation depend on whether ``obj`` is an object, class, or "
"instance of super."
msgstr ""
"呼び出しの詳細は、``obj`` がオブジェクトかクラスか、superのインスタンスかに依"
"ります。"

#: ../../howto/descriptor.rst:570
msgid "Invocation from an instance"
msgstr "インスタンスからの呼び出し"

#: ../../howto/descriptor.rst:572
msgid ""
"Instance lookup scans through a chain of namespaces giving data descriptors "
"the highest priority, followed by instance variables, then non-data "
"descriptors, then class variables, and lastly :meth:`__getattr__` if it is "
"provided."
msgstr ""
"名前空間のチェーンの中で行われるインスタンスルックアップでは、データデスクリ"
"プタが最優先で、次にインスタンス変数、その次にノンデータデスクリプタ、クラス"
"変数、最後に存在したら :meth:`__getattr__` が呼ばれます。"

#: ../../howto/descriptor.rst:577
msgid ""
"If a descriptor is found for ``a.x``, then it is invoked with: ``desc."
"__get__(a, type(a))``."
msgstr ""
"``a.x`` に対するデスクリプタが見つかった場合、 ``desc.__get__(a, type(a))`` "
"という形式で呼び出されます。"

#: ../../howto/descriptor.rst:580
msgid ""
"The logic for a dotted lookup is in :meth:`object.__getattribute__`.  Here "
"is a pure Python equivalent:"
msgstr ""
"ドットによるルックアップのロジックは\\ :meth:`object.__getattribute__` の中で"
"行われます。ピュアPythonで表した等価なロジックは次の通りです。"

#: ../../howto/descriptor.rst:719
msgid ""
"Note, there is no :meth:`__getattr__` hook in the :meth:`__getattribute__` "
"code.  That is why calling :meth:`__getattribute__` directly or with "
"``super().__getattribute__`` will bypass :meth:`__getattr__` entirely."
msgstr ""

#: ../../howto/descriptor.rst:723
msgid ""
"Instead, it is the dot operator and the :func:`getattr` function that are "
"responsible for invoking :meth:`__getattr__` whenever :meth:"
"`__getattribute__` raises an :exc:`AttributeError`.  Their logic is "
"encapsulated in a helper function:"
msgstr ""

#: ../../howto/descriptor.rst:773
msgid "Invocation from a class"
msgstr "クラスからの呼び出し"

#: ../../howto/descriptor.rst:775
msgid ""
"The logic for a dotted lookup such as ``A.x`` is in :meth:`type."
"__getattribute__`.  The steps are similar to those for :meth:`object."
"__getattribute__` but the instance dictionary lookup is replaced by a search "
"through the class's :term:`method resolution order`."
msgstr ""
"``A.x`` のようなドットを使ったルックアップのロジックは :meth:`type."
"__getattribute__` の中にあります。ロジックのステップは :meth:`object."
"__getattribute__` と似ていますが、インスタンス辞書のルックアップはクラスの :"
"term:`method resolution order` を通じた探索と置き換えられています。"

#: ../../howto/descriptor.rst:780
msgid "If a descriptor is found, it is invoked with ``desc.__get__(None, A)``."
msgstr ""
"``a.x`` に対するデスクリプタが見つかった場合、 ``desc.__get__(None, A)`` とい"
"う形式で呼び出されます。"

#: ../../howto/descriptor.rst:782
msgid ""
"The full C implementation can be found in :c:func:`type_getattro()` and :c:"
"func:`_PyType_Lookup()` in :source:`Objects/typeobject.c`."
msgstr ""
"完全なC言語による実装は :source:`Objects/typeobject.c` のファイル内の :c:"
"func:`type_getattro()` と :c:func:`_PyType_Lookup()` の中にあります。"

#: ../../howto/descriptor.rst:787
msgid "Invocation from super"
msgstr "superからの呼び出し"

#: ../../howto/descriptor.rst:789
msgid ""
"The logic for super's dotted lookup is in the :meth:`__getattribute__` "
"method for object returned by :class:`super()`."
msgstr ""
"superのドットを使ったルックアップは :class:`super()` が返すオブジェクトの :"
"meth:`__getattribute__` メソッドの中で行われます。"

#: ../../howto/descriptor.rst:792
msgid ""
"A dotted lookup such as ``super(A, obj).m`` searches ``obj.__class__."
"__mro__`` for the base class ``B`` immediately following ``A`` and then "
"returns ``B.__dict__['m'].__get__(obj, A)``.  If not a descriptor, ``m`` is "
"returned unchanged."
msgstr ""
"``super(A, obj).m`` のようなドットを使ったルックアップは ``obj.__class__."
"__mro__`` を探索して、 ``A`` の直前のクラス ``B`` をまず探し、 ``B."
"__dict__['m'].__get__(obj, A)`` を返します。もしデスクリプタでなければ ``m`` "
"を変更せずに返します。"

#: ../../howto/descriptor.rst:797
msgid ""
"The full C implementation can be found in :c:func:`super_getattro()` in :"
"source:`Objects/typeobject.c`.  A pure Python equivalent can be found in "
"`Guido's Tutorial <https://www.python.org/download/releases/2.2.3/descrintro/"
"#cooperation>`_."
msgstr ""
"完全なC言語による実装は :source:`Objects/typeobject.c` の中の :c:func:"
"`super_getattro()` の中にあります。等価なピュアPython実装は `Guidoのチュート"
"リアル <https://www.python.org/download/releases/2.2.3/descrintro/"
"#cooperation>`_ で見られます。"

#: ../../howto/descriptor.rst:804
msgid "Summary of invocation logic"
msgstr "呼び出しロジックのまとめ"

#: ../../howto/descriptor.rst:806
msgid ""
"The mechanism for descriptors is embedded in the :meth:`__getattribute__()` "
"methods for :class:`object`, :class:`type`, and :func:`super`."
msgstr ""
"デスクリプタのメカニズムは、 :class:`object` 、 :class:`type` 、 :func:"
"`super` の  :meth:`__getattribute__()` メソッドの中に組み込まれています。"

#: ../../howto/descriptor.rst:809
msgid "The important points to remember are:"
msgstr "憶えておくべき重要な点は:"

#: ../../howto/descriptor.rst:811
msgid "Descriptors are invoked by the :meth:`__getattribute__` method."
msgstr "デスクリプタは :meth:`__getattribute__` メソッドによって呼び出される"

#: ../../howto/descriptor.rst:813
msgid ""
"Classes inherit this machinery from :class:`object`, :class:`type`, or :func:"
"`super`."
msgstr ""
"クラスはこの機構を :class:`object` 、 :class:`type` 、 :func:`super` から継承"
"する"

#: ../../howto/descriptor.rst:816
msgid ""
"Overriding :meth:`__getattribute__` prevents automatic descriptor calls "
"because all the descriptor logic is in that method."
msgstr ""
"すべてのデスクリプタのロジックが :meth:`__getattribute__` にあるため、このメ"
"ソッドをオーバーライドすると、すべての自動的なデスクリプタ呼び出しは抑制され"
"る"

#: ../../howto/descriptor.rst:819
msgid ""
":meth:`object.__getattribute__` and :meth:`type.__getattribute__` make "
"different calls to :meth:`__get__`.  The first includes the instance and may "
"include the class.  The second puts in ``None`` for the instance and always "
"includes the class."
msgstr ""
":meth:`object.__getattribute__` と :meth:`type.__getattribute__` は :meth:"
"`__get__` の呼び出し方が異なる。前者はインスタンスとおそらくメソッドを含む。"
"後者はインスタンスとして ``None`` を渡し、クラスは常に渡される"

#: ../../howto/descriptor.rst:824
msgid "Data descriptors always override instance dictionaries."
msgstr "データデスクリプタは、必ずインスタンス辞書をオーバーライドする"

#: ../../howto/descriptor.rst:826
msgid "Non-data descriptors may be overridden by instance dictionaries."
msgstr ""
"非データデスクリプタは、インスタンス辞書にオーバーライドされることがある"

#: ../../howto/descriptor.rst:830
msgid "Automatic name notification"
msgstr "自動的の名前の伝達"

#: ../../howto/descriptor.rst:832
msgid ""
"Sometimes it is desirable for a descriptor to know what class variable name "
"it was assigned to.  When a new class is created, the :class:`type` "
"metaclass scans the dictionary of the new class.  If any of the entries are "
"descriptors and if they define :meth:`__set_name__`, that method is called "
"with two arguments.  The *owner* is the class where the descriptor is used, "
"and the *name* is the class variable the descriptor was assigned to."
msgstr ""
"デスクリプタにとって、自分がアサインされるクラス変数名が知りたいことがありま"
"す。新しいクラスが作られると、 :class:`type` メタクラスは新しいクラスの辞書を"
"スキャンします。もし、要素がデスクリプタで、なおかつ :meth:`__set_name__` メ"
"ソッドを持っている場合、このメソッドは2つの引数を伴って呼び出されます。 "
"*owner* はデスクリプタが使用されたクラスで、 *name* はデスクリプタがアサイン"
"されたクラス変数の名前です。"

#: ../../howto/descriptor.rst:839
msgid ""
"The implementation details are in :c:func:`type_new()` and :c:func:"
"`set_names()` in :source:`Objects/typeobject.c`."
msgstr ""
"完全なC言語による実装は :source:`Objects/typeobject.c` のファイル内の :c:"
"func:`type_new()` と :c:func:`set_names()` の中にあります。"

#: ../../howto/descriptor.rst:842
msgid ""
"Since the update logic is in :meth:`type.__new__`, notifications only take "
"place at the time of class creation.  If descriptors are added to the class "
"afterwards, :meth:`__set_name__` will need to be called manually."
msgstr ""
"更新のロジックは :meth:`type.__new__` にあり、通知はクラス作成のタイミングに"
"しかありません。もしデスクリプタが後からクラスに追加された場合は、 :meth:"
"`__set_name__` を手動で呼び出す必要があるでしょう。"

#: ../../howto/descriptor.rst:848
msgid "ORM example"
msgstr "ORMのサンプル"

#: ../../howto/descriptor.rst:850
msgid ""
"The following code is a simplified skeleton showing how data descriptors "
"could be used to implement an `object relational mapping <https://en."
"wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_."
msgstr ""

#: ../../howto/descriptor.rst:854
msgid ""
"The essential idea is that the data is stored in an external database.  The "
"Python instances only hold keys to the database's tables.  Descriptors take "
"care of lookups or updates:"
msgstr ""
"基本的な考え方は、データが外部のデータベースに保存することです。 Pythonインス"
"タンスは、データベースのテーブルへのキーのみを保持します。デスクリプタがルッ"
"クアップや更新をします。"

#: ../../howto/descriptor.rst:873
msgid ""
"We can use the :class:`Field` class to define `models <https://en.wikipedia."
"org/wiki/Database_model>`_ that describe the schema for each table in a "
"database:"
msgstr ""
":class:`Field` クラスを使って、データベースのテーブルごとのスキーマを説明する"
"ための `モデル <https://ja.wikipedia.org/wiki/"
"%E3%83%87%E3%83%BC%E3%82%BF%E3%83%A2%E3%83%87%E3%83%AB>`_ を定義します。"

#: ../../howto/descriptor.rst:898
msgid "To use the models, first connect to the database::"
msgstr "モデルを使用するにはまずデータベースに接続します::"

#: ../../howto/descriptor.rst:903
msgid ""
"An interactive session shows how data is retrieved from the database and how "
"it can be updated:"
msgstr ""
"次のインタラクティブセッションでは、データベースからのデータの取得と、更新方"
"法を示しています。"

#: ../../howto/descriptor.rst:948
msgid "Pure Python Equivalents"
msgstr "ピュアPythonの等価実装"

#: ../../howto/descriptor.rst:950
msgid ""
"The descriptor protocol is simple and offers exciting possibilities.  "
"Several use cases are so common that they have been prepackaged into built-"
"in tools. Properties, bound methods, static methods, class methods, and "
"\\_\\_slots\\_\\_ are all based on the descriptor protocol."
msgstr ""
"このプロトコルは単純ですが、ワクワクする可能性も秘めています。ユースケースの"
"中には、あまりに一般的なので組み込みに追加されたものもあります。プロパティ、"
"束縛のメソッド、静的メソッド、クラスメソッド、 \\_\\_slots\\_\\_ は、全てデス"
"クリプタプロトコルに基づいています。"

#: ../../howto/descriptor.rst:957
msgid "Properties"
msgstr "プロパティ"

#: ../../howto/descriptor.rst:959
msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers a function call upon access to an attribute.  Its signature "
"is::"
msgstr ""
":func:`property` を呼び出すことで、属性へアクセスすると関数の呼び出しを引き起"
"こす、データデスクリプタを簡潔に組み立てられます。シグネチャはこうです::"

#: ../../howto/descriptor.rst:964
msgid ""
"The documentation shows a typical use to define a managed attribute ``x``:"
msgstr ""
"このドキュメントでは、管理された属性 ``x`` を定義する典型的な使用法を示しま"
"す:"

#: ../../howto/descriptor.rst:988
msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent:"
msgstr ""
"デスクリプタの見地から :func:`property` がどのように実装されているかを見るた"
"めに、等価な Python 版をここに挙げます:"

#: ../../howto/descriptor.rst:1091
msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of a "
"method."
msgstr ""
"組み込みの :func:`property` 関数は、ユーザインターフェースへの属性アクセスが"
"与えられ、続く変更がメソッドの介入を要求するときに役立ちます。"

#: ../../howto/descriptor.rst:1095
msgid ""
"For instance, a spreadsheet class may grant access to a cell value through "
"``Cell('b10').value``. Subsequent improvements to the program require the "
"cell to be recalculated on every access; however, the programmer does not "
"want to affect existing client code accessing the attribute directly.  The "
"solution is to wrap access to the value attribute in a property data "
"descriptor:"
msgstr ""
"例えば、スプレッドシートクラスが、``Cell('b10').value`` でセルの値を取得でき"
"るとします。続く改良により、プログラムがアクセスの度にセルの再計算をすること"
"を要求しました。しかしプログラマは、その属性に直接アクセスする既存のクライア"
"ントコードに影響を与えたくありません。この解決策は、property データデスクリプ"
"タ内に値属性へのアクセスをラップすることです:"

#: ../../howto/descriptor.rst:1112
msgid ""
"Either the built-in :func:`property` or our :func:`Property` equivalent "
"would work in this example."
msgstr ""
"組み込みの :func:`property` も、この :func:`Property` も、このサンプルの中で"
"同じように利用できます。"

#: ../../howto/descriptor.rst:1117
msgid "Functions and methods"
msgstr "関数とメソッド"

#: ../../howto/descriptor.rst:1119
msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr ""
"Python のオブジェクト指向機能は、関数に基づく環境の上に構築されています。非"
"データデスクリプタを使って、この 2 つはシームレスに組み合わされています。"

#: ../../howto/descriptor.rst:1122
msgid ""
"Functions stored in class dictionaries get turned into methods when invoked. "
"Methods only differ from regular functions in that the object instance is "
"prepended to the other arguments.  By convention, the instance is called "
"*self* but could be called *this* or any other variable name."
msgstr ""
"クラス辞書に格納された関数は、実行時にメソッドに変換されます。メソッドと通常"
"の関数はオブジェクトのインスタンスが他の引数よりも前に渡される点だけが異なり"
"ます。監修ではインスタンスは *self* という名前が使われますが、 *this* や他の"
"変数名も使えます。"

#: ../../howto/descriptor.rst:1127
msgid ""
"Methods can be created manually with :class:`types.MethodType` which is "
"roughly equivalent to:"
msgstr ""
"メソッドは、ほぼ次のコードと同等な :class:`types.MethodType` を使えば手動で作"
"れます。"

#: ../../howto/descriptor.rst:1144
msgid ""
"To support automatic creation of methods, functions include the :meth:"
"`__get__` method for binding methods during attribute access.  This means "
"that functions are non-data descriptors that return bound methods during "
"dotted lookup from an instance.  Here's how it works:"
msgstr ""
"メソッドの自動作成をサポートするには、関数に対し、属性アクセスでメソッドの束"
"縛に利用される :meth:`__get__` メソッドを追加します。これはつまり、この関数は"
"ドットアクセスされたときに束縛されたメソッドを返す非データデスクリプタである"
"ことを意味します。次のように動作します。"

#: ../../howto/descriptor.rst:1160
msgid ""
"Running the following class in the interpreter shows how the function "
"descriptor works in practice:"
msgstr ""
"次のクラスをインタプリタを起動すると、この関数デスクリプタが実際にどう働くか"
"を見られます::"

#: ../../howto/descriptor.rst:1169
msgid ""
"The function has a :term:`qualified name` attribute to support introspection:"
msgstr ""
"この関数はイントロスペクションをサポートするために :term:`qualified name` も"
"持っています。"

#: ../../howto/descriptor.rst:1176
msgid ""
"Accessing the function through the class dictionary does not invoke :meth:"
"`__get__`.  Instead, it just returns the underlying function object::"
msgstr ""
"クラス辞書を通じて関数にアクセスすると :meth:`__get__` が実行されません。その"
"ため、裏にある関数オブジェクトをそのまま返します。"

#: ../../howto/descriptor.rst:1182
msgid ""
"Dotted access from a class calls :meth:`__get__` which just returns the "
"underlying function unchanged::"
msgstr ""
"クラスのドットアクセスは :meth:`__get__` は呼び出しますが、これも裏にある関数"
"を変更せずに返します。"

#: ../../howto/descriptor.rst:1188
msgid ""
"The interesting behavior occurs during dotted access from an instance.  The "
"dotted lookup calls :meth:`__get__` which returns a bound method object::"
msgstr ""
"インスタンスに対してドットアクセスをすると面白い動作をします。ドットのルック"
"アップは、束縛メソッドオブジェクトを返す :meth:`__get__` を呼び出します。"

#: ../../howto/descriptor.rst:1195
msgid ""
"Internally, the bound method stores the underlying function and the bound "
"instance::"
msgstr ""
"内部では、束縛メソッドはオリジナルの関数と束縛されたインスタンスを保持してい"
"ます。"

#: ../../howto/descriptor.rst:1204
msgid ""
"If you have ever wondered where *self* comes from in regular methods or "
"where *cls* comes from in class methods, this is it!"
msgstr ""
"もし、通常のメソッドの *self* や、クラスメソッドの *cls* がどこから来るの疑問"
"に思っている人がいるとしたら、これがその答えになります！"

#: ../../howto/descriptor.rst:1209
msgid "Kinds of methods"
msgstr "メソッドの種類"

#: ../../howto/descriptor.rst:1211
msgid ""
"Non-data descriptors provide a simple mechanism for variations on the usual "
"patterns of binding functions into methods."
msgstr ""
"非データデスクリプタは、関数をメソッドに束縛する、各種の一般的なパターンに、"
"単純な機構を提供します。"

#: ../../howto/descriptor.rst:1214
msgid ""
"To recap, functions have a :meth:`__get__` method so that they can be "
"converted to a method when accessed as attributes.  The non-data descriptor "
"transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  Calling ``cls."
"f(*args)`` becomes ``f(*args)``."
msgstr ""
"まとめると、関数は :meth:`__get__` メソッドを持ち、属性としてアクセスされたと"
"き、メソッドに変換されます。この非データディスクリプタは、 ``obj.f(*args)`` "
"の呼び出しを ``f(obj, *args)`` に変換します。 ``cls.f(*args)`` を呼び出すと "
"``f(*args)`` になります。"

#: ../../howto/descriptor.rst:1219
msgid "This chart summarizes the binding and its two most useful variants:"
msgstr "このチャートは、束縛と、その 2 つの異なる便利な形をまとめています:"

#: ../../howto/descriptor.rst:1222
msgid "Transformation"
msgstr "変換"

#: ../../howto/descriptor.rst:1222
msgid "Called from an object"
msgstr "オブジェクトから呼び出される"

#: ../../howto/descriptor.rst:1222
msgid "Called from a class"
msgstr "クラスから呼び出される"

#: ../../howto/descriptor.rst:1225
msgid "function"
msgstr "関数"

#: ../../howto/descriptor.rst:1225
msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

#: ../../howto/descriptor.rst:1225 ../../howto/descriptor.rst:1227
msgid "f(\\*args)"
msgstr "f(\\*args)"

#: ../../howto/descriptor.rst:1227
msgid "staticmethod"
msgstr "静的メソッド"

#: ../../howto/descriptor.rst:1229
msgid "classmethod"
msgstr "クラスメソッド"

#: ../../howto/descriptor.rst:1229
msgid "f(type(obj), \\*args)"
msgstr "f(type(obj), \\*args)"

#: ../../howto/descriptor.rst:1229
msgid "f(cls, \\*args)"
msgstr "f(cls, \\*args)"

#: ../../howto/descriptor.rst:1234
msgid "Static methods"
msgstr "静的メソッド"

#: ../../howto/descriptor.rst:1236
msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into ``object."
"__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, \"f\")``. As a "
"result, the function becomes identically accessible from either an object or "
"a class."
msgstr ""
"静的メソッドは、下にある関数をそのまま返します。 ``c.f`` や ``C.f`` は、 "
"``object.__getattribute__(c, \"f\")`` や ``object.__getattribute__(C, "
"\"f\")`` を直接探索するのと同じです。結果として、関数はオブジェクトとクラスか"
"ら同じようにアクセスできます。"

#: ../../howto/descriptor.rst:1242
msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr ""
"静的メソッドにすると良いのは、 ``self`` 変数への参照を持たないメソッドです。"

#: ../../howto/descriptor.rst:1245
msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on the "
"data. However, there may be useful functions which are conceptually related "
"but do not depend on the data.  For instance, ``erf(x)`` is handy conversion "
"routine that comes up in statistical work but does not directly depend on a "
"particular dataset. It can be called either from an object or the class:  "
"``s.erf(1.5) --> .9332`` or ``Sample.erf(1.5) --> .9332``."
msgstr ""
"例えば、統計パッケージに、実験データのコンテナがあるとします。そのクラスは、"
"平均、メジアン、その他の、データに依る記述統計を計算する標準メソッドを提供し"
"ます。しかし、概念上は関係があっても、データには依らないような便利な関数もあ"
"ります。例えば、 ``erf(x)`` は統計上の便利な変換ルーチンですが、特定のデータ"
"セットに直接には依存しません。これは、オブジェクトからでもクラスからでも呼び"
"出せます: ``s.erf(1.5) --> .9332`` または ``Sample.erf(1.5) --> .9332`` 。"

#: ../../howto/descriptor.rst:1254
msgid ""
"Since static methods return the underlying function with no changes, the "
"example calls are unexciting:"
msgstr ""
"静的メソッドは下にある関数をそのまま返すので、呼び出しの例は面白くありません:"

#: ../../howto/descriptor.rst:1271
msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`staticmethod` would look like this:"
msgstr ""
"非データデスクリプタプロトコルを使うと、pure Python 版の :func:"
"`staticmethod` は以下のようになります:"

#: ../../howto/descriptor.rst:1310
msgid "Class methods"
msgstr "クラスメソッド"

#: ../../howto/descriptor.rst:1312
msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class:"
msgstr ""
"静的メソッドとは違って、クラスメソッドは関数を呼び出す前にクラス参照を引数リ"
"ストの先頭に加えます。このフォーマットは、呼び出し元がオブジェクトでもクラス"
"でも同じです:"

#: ../../howto/descriptor.rst:1330
msgid ""
"This behavior is useful whenever the method only needs to have a class "
"reference and does not rely on data stored in a specific instance.  One use "
"for class methods is to create alternate class constructors.  For example, "
"the classmethod :func:`dict.fromkeys` creates a new dictionary from a list "
"of keys.  The pure Python equivalent is:"
msgstr ""
"この振る舞いは、関数がクラス参照のみを必要とし、特定のインスタンスに保存され"
"たデータに依存しないときに便利です。クラスメソッドの使い方の一つは、代わりの"
"クラスコンストラクタを作ることです。例えば、クラスメソッド :func:`dict."
"fromkeys` は新しい辞書をキーのリストから生成します。等価な pure Python 版は:"

#: ../../howto/descriptor.rst:1347
msgid "Now a new dictionary of unique keys can be constructed like this:"
msgstr "これで一意なキーを持つ新しい辞書が以下のように構成できます:"

#: ../../howto/descriptor.rst:1357
msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`classmethod` would look like this:"
msgstr ""
"非データデスクリプタプロトコルを使った、 :func:`classmethod` の pure Python "
"版はこのようになります:"

#: ../../howto/descriptor.rst:1408
msgid ""
"The code path for ``hasattr(type(self.f), '__get__')`` was added in Python "
"3.9 and makes it possible for :func:`classmethod` to support chained "
"decorators.  For example, a classmethod and property could be chained "
"together.  In Python 3.11, this functionality was deprecated."
msgstr ""

#: ../../howto/descriptor.rst:1428
msgid "Member objects and __slots__"
msgstr "メンバーオブジェクトと __slots__"

#: ../../howto/descriptor.rst:1430
msgid ""
"When a class defines ``__slots__``, it replaces instance dictionaries with a "
"fixed-length array of slot values.  From a user point of view that has "
"several effects:"
msgstr ""
"クラスが ``__slots__`` を定義すると、インスタンスの辞書が固定超のスロットの値"
"の配列と置き換えられます。ユーザーの目線からみると、いくつかの変化がありま"
"す。"

#: ../../howto/descriptor.rst:1434
msgid ""
"1. Provides immediate detection of bugs due to misspelled attribute "
"assignments.  Only attribute names specified in ``__slots__`` are allowed:"
msgstr ""
"1. 属性のアサイン時に、すぐにミススペルが原因のバグが検知される。 "
"``__slots__`` で指定された属性名だけが許可されます:"

#: ../../howto/descriptor.rst:1450
msgid ""
"2. Helps create immutable objects where descriptors manage access to private "
"attributes stored in ``__slots__``:"
msgstr ""
"2. デスクリプタが ``__slots__`` に格納されたプライベートな属性へのアクセスを"
"制御するような、イミュータブルオブジェクトが作りやすくなる。"

#: ../../howto/descriptor.rst:1485
msgid ""
"3. Saves memory.  On a 64-bit Linux build, an instance with two attributes "
"takes 48 bytes with ``__slots__`` and 152 bytes without.  This `flyweight "
"design pattern <https://en.wikipedia.org/wiki/Flyweight_pattern>`_ likely "
"only matters when a large number of instances are going to be created."
msgstr ""
"3. メモリの節約。64bitのLinux版のPythonでは、 ``__slots__`` を使った場合に、2"
"つの属性を持つインスタンスは48バイト、使わない場合は152バイトメモリを使用しま"
"す。この `flyweightデザインパターン <https://ja.wikipedia.org/wiki/"
"Flyweight_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3>`_ は大量のインスタンスを作成"
"するときにのみ問題になります。"

#: ../../howto/descriptor.rst:1490
msgid ""
"4. Improves speed.  Reading instance variables is 35% faster with "
"``__slots__`` (as measured with Python 3.10 on an Apple M1 processor)."
msgstr ""
"4. 速度の改善。 ``__slots__`` を使うとインスタンス変数の読み込み速度が35%早く"
"なります（Apple M1プロセッサで動作させたPython 3.10で測定）"

#: ../../howto/descriptor.rst:1493
msgid ""
"5. Blocks tools like :func:`functools.cached_property` which require an "
"instance dictionary to function correctly:"
msgstr ""
"5. :func:`functools.cached_property` のような、動作にインスタンス辞書が必要な"
"ツールが使えなくなる。"

#: ../../howto/descriptor.rst:1515
msgid ""
"It is not possible to create an exact drop-in pure Python version of "
"``__slots__`` because it requires direct access to C structures and control "
"over object memory allocation.  However, we can build a mostly faithful "
"simulation where the actual C structure for slots is emulated by a private "
"``_slotvalues`` list.  Reads and writes to that private structure are "
"managed by member descriptors:"
msgstr ""
"``__slots__`` はC構造体に直接アクセスし、オブジェクトのメモリ確保を制御する必"
"要があるため、ピュアPythonバージョンを作成することはできません。しかし、プラ"
"イベートの ``__slotvalues`` リストを使ってC構造体のスロットをほぼ忠実にエミュ"
"レートすることはできます。そのプライベートな構造体への読み書きはメンバーのデ"
"スクリプタによって管理されます。"

#: ../../howto/descriptor.rst:1560
msgid ""
"The :meth:`type.__new__` method takes care of adding member objects to class "
"variables:"
msgstr ""
":meth:`type.__new__` メソッドはクラス変数へのメンバーオブジェクトの追加を処理"
"します。"

#: ../../howto/descriptor.rst:1576
msgid ""
"The :meth:`object.__new__` method takes care of creating instances that have "
"slots instead of an instance dictionary.  Here is a rough simulation in pure "
"Python:"
msgstr ""
":meth:`object.__new__` メソッドはインスタンス辞書の代わりにスロットを持つイン"
"スタンスの作成の処理をします。おおざっぱにピュアPythonでのシミュレーションし"
"たコードがこちらです。"

#: ../../howto/descriptor.rst:1611
msgid ""
"To use the simulation in a real class, just inherit from :class:`Object` and "
"set the :term:`metaclass` to :class:`Type`:"
msgstr ""
"実際のクラスでシミュレーションコードを利用するには、 :class:`Object` を継承"
"し、 :term:`metaclass` を :class:`Type` にします。"

#: ../../howto/descriptor.rst:1625
msgid ""
"At this point, the metaclass has loaded member objects for *x* and *y*::"
msgstr ""
"この時点ではメタクラスは *x* と *y* のメンバーオブジェクトをロードします。"

#: ../../howto/descriptor.rst:1646
msgid ""
"When instances are created, they have a ``slot_values`` list where the "
"attributes are stored:"
msgstr ""
"インスタンスが作成されると、属性が保持される ``slot_values``  のリストをイン"
"スタンスが保持します:"

#: ../../howto/descriptor.rst:1658
msgid "Misspelled or unassigned attributes will raise an exception:"
msgstr "スペルミスや、未アサインの属性は例外を送出します。"
