# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# tomo, 2018
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/descriptor.rst:3
msgid "Descriptor HowTo Guide"
msgstr "ディスクリプタ HowTo ガイド"

#: ../../howto/descriptor.rst:0
msgid "Author"
msgstr "著者"

#: ../../howto/descriptor.rst:5
msgid "Raymond Hettinger"
msgstr "Raymond Hettinger"

#: ../../howto/descriptor.rst:0
msgid "Contact"
msgstr "問い合わせ先"

#: ../../howto/descriptor.rst:6
msgid "<python at rcn dot com>"
msgstr "<python at rcn dot com>"

#: ../../howto/descriptor.rst:8
msgid "Contents"
msgstr "内容"

#: ../../howto/descriptor.rst:11
msgid "Abstract"
msgstr "概要"

#: ../../howto/descriptor.rst:13
msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors are "
"called.  Examines a custom descriptor and several built-in python "
"descriptors including functions, properties, static methods, and class "
"methods.  Shows how each works by giving a pure Python equivalent and a "
"sample application."
msgstr ""
"ディスクリプタを定義し、プロトコルを要約し、ディスクリプタがどのように呼び出"
"されるか示します。カスタムのディスクリプタや、関数、プロパティ、静的メソッ"
"ド、クラスメソッドを含む、いくつかの組み込み Python ディスクリプタを考察しま"
"す。等価な pure Python 版やサンプルアプリケーションを与えることにより、それぞ"
"れがどのように働くかを示します。"

#: ../../howto/descriptor.rst:18
msgid ""
"Learning about descriptors not only provides access to a larger toolset, it "
"creates a deeper understanding of how Python works and an appreciation for "
"the elegance of its design."
msgstr ""
"ディスクリプタについて学ぶことにより、新しいツールセットが使えるようになるだ"
"けでなく、Python の仕組みや、洗練された設計のアプリケーションについてのより深"
"い理解が得られます。"

#: ../../howto/descriptor.rst:24
msgid "Definition and Introduction"
msgstr "定義と導入"

#: ../../howto/descriptor.rst:26
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol.  Those methods are :meth:`__get__`, :meth:`__set__`, and :meth:"
"`__delete__`.  If any of those methods are defined for an object, it is said "
"to be a descriptor."
msgstr ""
"一般に、ディスクリプタは \"束縛動作 (binding behavior)\" をもつオブジェクト属"
"性で、その属性アクセスが、ディスクリプタプロトコルのメソッドによってオーバー"
"ライドされたものです。このメソッドは、 :meth:`__get__`, :meth:`__set__`, およ"
"び :meth:`__delete__` です。これらのメソッドのいずれかが、オブジェクトに定義"
"されていれば、それはディスクリプタと呼ばれます。"

#: ../../howto/descriptor.rst:32
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses. If "
"the looked-up value is an object defining one of the descriptor methods, "
"then Python may override the default behavior and invoke the descriptor "
"method instead. Where this occurs in the precedence chain depends on which "
"descriptor methods were defined.  Note that descriptors are only invoked for "
"new style objects or classes (a class is new style if it inherits from :"
"class:`object` or :class:`type`)."
msgstr ""
"属性アクセスのデフォルトの振る舞いは、オブジェクトの辞書の属性の取得、設定、"
"削除です。例えば ``a.x`` は、まず ``a.__dict__['x']`` 、それから ``type(a)."
"__dict__['x']`` 、さらに ``type(a)`` のメタクラスを除く基底クラスへと続くとい"
"うように探索が連鎖します。見つかった値が、ディスクリプタメソッドのいずれかを"
"定義しているオブジェクトなら、 Python はそのデフォルトの振る舞いをオーバーラ"
"イドし、代わりにディスクリプタメソッドを呼び出します。これがどの連鎖順位で行"
"われるかは、どのディスクリプタメソッドが定義されているかに依ります。なお、"
"ディスクリプタは、新スタイルのオブジェクトまたはクラスにのみ呼び出されます "
"(あるクラスは、それが :class:`object` または :class:`type` を継承していれば、"
"新スタイルです)。"

#: ../../howto/descriptor.rst:43
msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and :"
"func:`super()`. They are used throughout Python itself to implement the new "
"style classes introduced in version 2.2.  Descriptors simplify the "
"underlying C-code and offer a flexible set of new tools for everyday Python "
"programs."
msgstr ""
"ディスクリプタは、強力な、多目的のプロトコルです。これはプロパティ、メソッ"
"ド、静的メソッド、クラスメソッド、そして :func:`super()` の背後にある機構で"
"す。これはバージョン 2.2 で導入された新スタイルクラスを実装するために、"
"Python のいたるところで使われています。ディスクリプタは、基幹にある C コード"
"を簡潔にし、毎日の Python プログラムに、柔軟な新しいツール群を提供します。"

#: ../../howto/descriptor.rst:51
msgid "Descriptor Protocol"
msgstr "ディスクリプタプロトコル"

#: ../../howto/descriptor.rst:53
msgid "``descr.__get__(self, obj, type=None) --> value``"
msgstr "``descr.__get__(self, obj, type=None) --> value``"

#: ../../howto/descriptor.rst:55
msgid "``descr.__set__(self, obj, value) --> None``"
msgstr "``descr.__set__(self, obj, value) --> None``"

#: ../../howto/descriptor.rst:57
msgid "``descr.__delete__(self, obj) --> None``"
msgstr "``descr.__delete__(self, obj) --> None``"

#: ../../howto/descriptor.rst:59
msgid ""
"That is all there is to it.  Define any of these methods and an object is "
"considered a descriptor and can override default behavior upon being looked "
"up as an attribute."
msgstr ""
"これで全てです。これらのメソッドのいずれかを定義すれば、オブジェクトはディス"
"クリプタとみなされ、探索された際のデフォルトの振る舞いをオーバーライドできま"
"す。"

#: ../../howto/descriptor.rst:63
msgid ""
"If an object defines both :meth:`__get__` and :meth:`__set__`, it is "
"considered a data descriptor.  Descriptors that only define :meth:`__get__` "
"are called non-data descriptors (they are typically used for methods but "
"other uses are possible)."
msgstr ""
"あるオブジェクトが :meth:`__get__` と :meth:`__set__` の両方を定義していた"
"ら、それはデータディスクリプタとみなされます。 :meth:`__get__` だけを定義して"
"いるディスクリプタは、非データディスクリプタと呼ばれます (これらは典型的には"
"メソッドに使われますが、他の使い方も出来ます)。"

#: ../../howto/descriptor.rst:68
msgid ""
"Data and non-data descriptors differ in how overrides are calculated with "
"respect to entries in an instance's dictionary.  If an instance's dictionary "
"has an entry with the same name as a data descriptor, the data descriptor "
"takes precedence.  If an instance's dictionary has an entry with the same "
"name as a non-data descriptor, the dictionary entry takes precedence."
msgstr ""
"データディスクリプタと非データディスクリプタでは、オーバーライドがインスタン"
"スの辞書のエントリに関してどのように計算されるかが異なります。インスタンスの"
"辞書に、データディスクリプタと同名の項目があれば、データディスクリプタの方が"
"優先されます。インスタンスの辞書に、非データディスクリプタと同名の項目があれ"
"ば、辞書の項目の方が優先されます。"

#: ../../howto/descriptor.rst:74
msgid ""
"To make a read-only data descriptor, define both :meth:`__get__` and :meth:"
"`__set__` with the :meth:`__set__` raising an :exc:`AttributeError` when "
"called.  Defining the :meth:`__set__` method with an exception raising "
"placeholder is enough to make it a data descriptor."
msgstr ""
"読み込み専用のデータディスクリプタを作るには、 :meth:`__get__` と :meth:"
"`__set__` の両方を定義し、 :meth:`__set__` が呼び出されたときに :exc:"
"`AttributeError` が送出されるようにしてください。例外を送出する :meth:"
"`__set__` メソッドをプレースホルダとして定義すれば、データディスクリプタにす"
"るのに十分です。"

#: ../../howto/descriptor.rst:81
msgid "Invoking Descriptors"
msgstr "デスクリプタの呼び出し"

#: ../../howto/descriptor.rst:83
msgid ""
"A descriptor can be called directly by its method name.  For example, ``d."
"__get__(obj)``."
msgstr ""
"ディスクリプタは、メソッド名で直接呼ぶことも出来ます。例えば、 ``d."
"__get__(obj)`` です。"

#: ../../howto/descriptor.rst:86
msgid ""
"Alternatively, it is more common for a descriptor to be invoked "
"automatically upon attribute access.  For example, ``obj.d`` looks up ``d`` "
"in the dictionary of ``obj``.  If ``d`` defines the method :meth:`__get__`, "
"then ``d.__get__(obj)`` is invoked according to the precedence rules listed "
"below."
msgstr ""
"または、一般的に、ディスクリプタは属性アクセスから自動的に呼び出されます。例"
"えば、 ``obj.d`` は ``obj`` の辞書から ``d`` を探索します。 ``d`` がメソッ"
"ド :meth:`__get__` を定義していたら、以下に列挙する優先順位に従って、 ``d."
"__get__(obj)`` が呼び出されます。"

#: ../../howto/descriptor.rst:91
msgid ""
"The details of invocation depend on whether ``obj`` is an object or a class. "
"Either way, descriptors only work for new style objects and classes.  A "
"class is new style if it is a subclass of :class:`object`."
msgstr ""
"呼び出しの詳細は、 ``obj`` がオブジェクトかクラスかに依ります。どちらにして"
"も、ディスクリプタは新スタイルのオブジェクトやクラスにのみ働きます。クラス"
"は、それが :class:`object` のサブクラスであるなら新スタイルです。"

#: ../../howto/descriptor.rst:95
msgid ""
"For objects, the machinery is in :meth:`object.__getattribute__` which "
"transforms ``b.x`` into ``type(b).__dict__['x'].__get__(b, type(b))``.  The "
"implementation works through a precedence chain that gives data descriptors "
"priority over instance variables, instance variables priority over non-data "
"descriptors, and assigns lowest priority to :meth:`__getattr__` if provided. "
"The full C implementation can be found in :c:func:"
"`PyObject_GenericGetAttr()` in :source:`Objects/object.c`."
msgstr ""
"オブジェクトでは、その機構は ``b.x`` を ``type(b).__dict__['x'].__get__(b, "
"type(b))`` に変換する :meth:`object.__getattribute__` にあります。データディ"
"スクリプタの優先度はインスタンス変数より高く、インスタンス変数の優先度は非"
"データディスクリプタより高く、(提供されていれば) :meth:`__getattr__` の優先度"
"が最も低いように実装されています。完全な C 実装は、 :source:`Objects/object."
"c` の :c:func:`PyObject_GenericGetAttr()` で見つかります。"

#: ../../howto/descriptor.rst:103
msgid ""
"For classes, the machinery is in :meth:`type.__getattribute__` which "
"transforms ``B.x`` into ``B.__dict__['x'].__get__(None, B)``.  In pure "
"Python, it looks like::"
msgstr ""
"クラスでは、その機構は ``B.x`` を ``B.__dict__['x'].__get__(None, B)`` に変換"
"する :meth:`type.__getattribute__` にあります。 pure Python では、このように"
"なります::"

#: ../../howto/descriptor.rst:114
msgid "The important points to remember are:"
msgstr "憶えておくべき重要な点は:"

#: ../../howto/descriptor.rst:116
msgid "descriptors are invoked by the :meth:`__getattribute__` method"
msgstr "ディスクリプタは :meth:`__getattribute__` メソッドによって呼び出される"

#: ../../howto/descriptor.rst:117
msgid "overriding :meth:`__getattribute__` prevents automatic descriptor calls"
msgstr ""
":meth:`__getattribute__` をオーバーライドすると、自動的なディスクリプタの呼び"
"出しが行われなくなる"

#: ../../howto/descriptor.rst:118
msgid ""
":meth:`__getattribute__` is only available with new style classes and objects"
msgstr ""
":meth:`__getattribute__` は新スタイルのクラスとオブジェクトにのみ使える。"

#: ../../howto/descriptor.rst:119
msgid ""
":meth:`object.__getattribute__` and :meth:`type.__getattribute__` make "
"different calls to :meth:`__get__`."
msgstr ""
":meth:`object.__getattribute__` と :meth:`type.__getattribute__` では、 :"
"meth:`__get__` の呼び出しが異なる。"

#: ../../howto/descriptor.rst:121
msgid "data descriptors always override instance dictionaries."
msgstr "データディスクリプタは、必ずインスタンス辞書をオーバーライドする。"

#: ../../howto/descriptor.rst:122
msgid "non-data descriptors may be overridden by instance dictionaries."
msgstr ""
"非データディスクリプタは、インスタンス辞書にオーバーライドされることがある。"

#: ../../howto/descriptor.rst:124
msgid ""
"The object returned by ``super()`` also has a custom :meth:"
"`__getattribute__` method for invoking descriptors.  The call ``super(B, "
"obj).m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately following ``B`` and then returns ``A.__dict__['m'].__get__(obj, "
"B)``.  If not a descriptor, ``m`` is returned unchanged.  If not in the "
"dictionary, ``m`` reverts to a search using :meth:`object.__getattribute__`."
msgstr ""
"``super()`` が返したオブジェクトにはさらにディスクリプタを起動するカスタム :"
"meth:`__getattribute__` メソッドがあります。 ``super(B, obj).m()`` の呼び出し"
"は、 ``B`` に続き基底クラス ``A`` を見つけるために ``obj.__class__.__mro__`` "
"を探索し、 ``A.__dict__['m'].__get__(obj, B)`` を返します。ディスクリプタでは"
"ない場合、 ``m`` が変更されずに返されます。辞書になければ、  ``m`` は :meth:"
"`object.__getattribute__` を使用した探索に戻ります。"

#: ../../howto/descriptor.rst:131
msgid ""
"Note, in Python 2.2, ``super(B, obj).m()`` would only invoke :meth:`__get__` "
"if ``m`` was a data descriptor.  In Python 2.3, non-data descriptors also "
"get invoked unless an old-style class is involved.  The implementation "
"details are in :c:func:`super_getattro()` in :source:`Objects/typeobject.c`."
msgstr ""
"なお、Python 2.2 では、 ``m`` がデータディスクリプタなら、 ``super(B, obj)."
"m()`` は :meth:`__get__` を呼び出すだけです。 Python 2.3 では、旧スタイルクラ"
"スが呼び出されなければ、非データディスクリプタも呼び出されます。実装の詳細"
"は、 :source:`Objects/typeobject.c` 内の :c:func:`super_getattro()` を参照し"
"てください。"

#: ../../howto/descriptor.rst:138
msgid ""
"The details above show that the mechanism for descriptors is embedded in "
"the :meth:`__getattribute__()` methods for :class:`object`, :class:`type`, "
"and :func:`super`.  Classes inherit this machinery when they derive from :"
"class:`object` or if they have a meta-class providing similar functionality. "
"Likewise, classes can turn-off descriptor invocation by overriding :meth:"
"`__getattribute__()`."
msgstr ""
"上述の詳細は、ディスクリプタの機構が、 :meth:`__getattribute__()` メソッドに"
"埋めこまれ、 :class:`object`, :class:`type`, そして :func:`super` に使われて"
"いるということを表しています。クラスは、 :class:`object` から導出されたとき、"
"または、同じような機能を提供するメタクラスをもつとき、この機構を継承します。"
"同様に、 :meth:`__getattribute__()` をオーバーライドすることで、ディスクリプ"
"タの呼び出しを無効にできます。"

#: ../../howto/descriptor.rst:147
msgid "Descriptor Example"
msgstr "ディスクリプタの例"

#: ../../howto/descriptor.rst:149
msgid ""
"The following code creates a class whose objects are data descriptors which "
"print a message for each get or set.  Overriding :meth:`__getattribute__` is "
"alternate approach that could do this for every attribute.  However, this "
"descriptor is useful for monitoring just a few chosen attributes::"
msgstr ""
"以下のコードは、オブジェクトが取得と設定のたびにメッセージを表示するデータ"
"ディスクリプタであるようなクラスを生成します。代わりに :meth:"
"`__getattribute__` をオーバーライドすると、全ての属性に対してこれができます。"
"しかし、このディスクリプタは、少数の選ばれた属性を監視するのに便利です::"

#: ../../howto/descriptor.rst:187
msgid ""
"The protocol is simple and offers exciting possibilities.  Several use cases "
"are so common that they have been packaged into individual function calls. "
"Properties, bound and unbound methods, static methods, and class methods are "
"all based on the descriptor protocol."
msgstr ""
"このプロトコルは単純ですが、ワクワクする可能性も秘めています。ユースケースの"
"中には、あまりに一般的なので個別の関数の呼び出しにまとめられたものもありま"
"す。プロパティ、束縛および非束縛のメソッド、静的メソッド、そしてクラスメソッ"
"ドは、全てデスクリプタプロトコルに基づいています。"

#: ../../howto/descriptor.rst:194
msgid "Properties"
msgstr "プロパティ"

#: ../../howto/descriptor.rst:196
msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers function calls upon access to an attribute.  Its signature is::"
msgstr ""
":func:`property` を呼び出すことで、属性へアクセスすると関数の呼び出しを引き起"
"こす、データディスクリプタを簡潔に組み立てられます。シグネチャはこうです::"

#: ../../howto/descriptor.rst:201
msgid ""
"The documentation shows a typical use to define a managed attribute ``x``::"
msgstr ""
"このドキュメントでは、管理された属性 ``x`` を定義する典型的な使用法を示しま"
"す::"

#: ../../howto/descriptor.rst:209
msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent::"
msgstr ""
"ディスクリプタの見地から :func:`property` がどのように実装されているかを見る"
"ために、等価な Python 版をここに挙げます::"

#: ../../howto/descriptor.rst:249
msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of a "
"method."
msgstr ""
"組み込みの :func:`property` 関数は、ユーザインタフェースへの属性アクセスが与"
"えられ、続く変更がメソッドの介入を要求するときに役立ちます。"

#: ../../howto/descriptor.rst:253
msgid ""
"For instance, a spreadsheet class may grant access to a cell value through "
"``Cell('b10').value``. Subsequent improvements to the program require the "
"cell to be recalculated on every access; however, the programmer does not "
"want to affect existing client code accessing the attribute directly.  The "
"solution is to wrap access to the value attribute in a property data "
"descriptor::"
msgstr ""
"例えば、スプレッドシートクラスが、 ``Cell('b10').value`` でセルの値を取得でき"
"るとします。続く改良により、プログラムがアクセスの度にセルの再計算をすること"
"を要求しました。しかしプログラマは、その属性に直接アクセスする既存のクライア"
"ントコードに影響を与えたくありません。この解決策は、property データディスクリ"
"プタ内に値属性へのアクセスをラップすることです::"

#: ../../howto/descriptor.rst:269
msgid "Functions and Methods"
msgstr "関数とメソッド"

#: ../../howto/descriptor.rst:271
msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr ""
"Python のオブジェクト指向機能は、関数に基づく環境の上に構築されています。非"
"データディスクリプタを使って、この 2 つはシームレスに組み合わされています。"

#: ../../howto/descriptor.rst:274
msgid ""
"Class dictionaries store methods as functions.  In a class definition, "
"methods are written using :keyword:`def` and :keyword:`lambda`, the usual "
"tools for creating functions.  The only difference from regular functions is "
"that the first argument is reserved for the object instance.  By Python "
"convention, the instance reference is called *self* but may be called *this* "
"or any other variable name."
msgstr ""
"クラス辞書は、メソッドを関数として保存します。クラス定義内で、メソッドは、関"
"数を使うのに便利なツール、 :keyword:`def` や :keyword:`lambda` を使って書かれ"
"ます。標準の関数との唯一の違いは、第一引数がオブジェクトインスタンスのために"
"予約されていることです。 Python の慣習では、このインスタンスの参照は *self* "
"と呼ばれますが、 *this* その他の好きな変数名で呼び出せます。"

#: ../../howto/descriptor.rst:281
msgid ""
"To support method calls, functions include the :meth:`__get__` method for "
"binding methods during attribute access.  This means that all functions are "
"non-data descriptors which return bound or unbound methods depending whether "
"they are invoked from an object or a class.  In pure python, it works like "
"this::"
msgstr ""
"メソッドの呼び出しをサポートするために、関数の :meth:`__get__` メソッドは属性"
"アクセス時にメソッドを束縛します。これにより、すべての関数は、それが呼び出さ"
"れたのがオブジェクトかクラスかによって、束縛か非束縛メソッドを返す非データデ"
"スクリプタになります。pure Python では、これはこのようにはたらきます::"

#: ../../howto/descriptor.rst:293
msgid ""
"Running the interpreter shows how the function descriptor works in practice::"
msgstr ""
"インタプリタを起動すると、この関数ディスクリプタが実際にどうはたらくかを見ら"
"れます::"

#: ../../howto/descriptor.rst:307
msgid ""
"The output suggests that bound and unbound methods are two different types. "
"While they could have been implemented that way, the actual C implementation "
"of :c:type:`PyMethod_Type` in :source:`Objects/classobject.c` is a single "
"object with two different representations depending on whether the :attr:"
"`im_self` field is set or is *NULL* (the C equivalent of ``None``)."
msgstr ""
"この出力は、束縛メソッドと非束縛メソッドは 2 つの異なる型であることを示してい"
"ます。\n"
"これらは、異なる型として実装することも出来ますが、 :source:`Objects/"
"classobject.c` における :c:type:`PyMethod_Type` の実際の C 実装は 1 つのオブ"
"ジェクトで、 :attr:`im_self` が *NULL* (C での ``None`` と同等のもの) に設定"
"されているかどうかで決まる 2 つの異なる表現を持ってるのです。"

#: ../../howto/descriptor.rst:313
msgid ""
"Likewise, the effects of calling a method object depend on the :attr:"
"`im_self` field. If set (meaning bound), the original function (stored in "
"the :attr:`im_func` field) is called as expected with the first argument set "
"to the instance.  If unbound, all of the arguments are passed unchanged to "
"the original function. The actual C implementation of :func:"
"`instancemethod_call()` is only slightly more complex in that it includes "
"some type checking."
msgstr ""
"同様に、メソッドオブジェクトを呼び出すことの効果も、 :attr:`im_self` フィール"
"ドに依ります。設定されていれば (束縛を意味し)、期待通り (:attr:`im_func` "
"フィールドに保存されている) 元の関数が、第一引数をインスタンスとして、呼び出"
"されます。非束縛なら、すべての引数がそのまま元の関数に渡されます。 :func:"
"`instancemethod_call()` の実際の C 実装は、型チェックがあるため、もう少しだけ"
"複雑です。"

#: ../../howto/descriptor.rst:322
msgid "Static Methods and Class Methods"
msgstr "静的メソッドとクラスメソッド"

#: ../../howto/descriptor.rst:324
msgid ""
"Non-data descriptors provide a simple mechanism for variations on the usual "
"patterns of binding functions into methods."
msgstr ""
"非データディスクリプタは、関数をメソッドに束縛する、各種の一般的なパターン"
"に、単純な機構を提供します。"

#: ../../howto/descriptor.rst:327
msgid ""
"To recap, functions have a :meth:`__get__` method so that they can be "
"converted to a method when accessed as attributes.  The non-data descriptor "
"transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  Calling ``klass."
"f(*args)`` becomes ``f(*args)``."
msgstr ""
"まとめると、関数は :meth:`__get__` メソッドを持ち、属性としてアクセスされたと"
"き、メソッドに変換されます。この非データディスクリプタは、 ``obj.f(*args)`` "
"の呼び出しを ``f(obj, *args)`` に変換します。 ``klass.f(*args)`` を呼び出す"
"と ``f(*args)`` になります。"

#: ../../howto/descriptor.rst:332
msgid "This chart summarizes the binding and its two most useful variants:"
msgstr "このチャートは、束縛と、その 2 つの異なる便利な形をまとめています:"

#: ../../howto/descriptor.rst:335
msgid "Transformation"
msgstr "変換"

#: ../../howto/descriptor.rst:335
msgid "Called from an Object"
msgstr "オブジェクトから呼び出される"

#: ../../howto/descriptor.rst:335
msgid "Called from a Class"
msgstr "クラスから呼び出される"

#: ../../howto/descriptor.rst:338
msgid "function"
msgstr "関数"

#: ../../howto/descriptor.rst:338
msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

#: ../../howto/descriptor.rst:338 ../../howto/descriptor.rst:340
msgid "f(\\*args)"
msgstr "f(\\*args)"

#: ../../howto/descriptor.rst:340
msgid "staticmethod"
msgstr "静的メソッド"

#: ../../howto/descriptor.rst:342
msgid "classmethod"
msgstr "クラスメソッド"

#: ../../howto/descriptor.rst:342
msgid "f(type(obj), \\*args)"
msgstr "f(type(obj), \\*args)"

#: ../../howto/descriptor.rst:342
msgid "f(klass, \\*args)"
msgstr "f(klass, \\*args)"

#: ../../howto/descriptor.rst:345
msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into ``object."
"__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, \"f\")``. As a "
"result, the function becomes identically accessible from either an object or "
"a class."
msgstr ""
"静的メソッドは、下にある関数をそのまま返します。 ``c.f`` や ``C.f`` は、 "
"``object.__getattribute__(c, \"f\")`` や ``object.__getattribute__(C, "
"\"f\")`` を直接探索するのと同じです。結果として、関数はオブジェクトとクラスか"
"ら同じようにアクセスできます。"

#: ../../howto/descriptor.rst:351
msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr ""
"静的メソッドにすると良いのは、 ``self`` 変数への参照を持たないメソッドです。"

#: ../../howto/descriptor.rst:354
msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on the "
"data. However, there may be useful functions which are conceptually related "
"but do not depend on the data.  For instance, ``erf(x)`` is handy conversion "
"routine that comes up in statistical work but does not directly depend on a "
"particular dataset. It can be called either from an object or the class:  "
"``s.erf(1.5) --> .9332`` or ``Sample.erf(1.5) --> .9332``."
msgstr ""
"例えば、統計パッケージに、実験データのコンテナがあるとします。そのクラスは、"
"平均、メジアン、その他の、データに依る記述統計を計算する標準メソッドを提供し"
"ます。しかし、概念上は関係があっても、データには依らないような便利な関数もあ"
"ります。例えば、 ``erf(x)`` は統計上の便利な変換ルーチンですが、特定のデータ"
"セットに直接には依存しません。これは、オブジェクトからでもクラスからでも呼び"
"出せます: ``s.erf(1.5) --> .9332`` または ``Sample.erf(1.5) --> .9332`` 。"

#: ../../howto/descriptor.rst:363
msgid ""
"Since staticmethods return the underlying function with no changes, the "
"example calls are unexciting::"
msgstr ""
"静的メソッドは下にある関数をそのまま返すので、呼び出しの例は面白くありませ"
"ん::"

#: ../../howto/descriptor.rst:376
msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`staticmethod` would look like this::"
msgstr ""
"非データディスクリプタプロトコルを使うと、pure Python 版の :func:"
"`staticmethod` は以下のようになります::"

#: ../../howto/descriptor.rst:388
msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class::"
msgstr ""
"静的メソッドとは違って、クラスメソッドは関数を呼び出す前にクラス参照を引数リ"
"ストの先頭に加えます。このフォーマットは、呼び出し元がオブジェクトでもクラス"
"でも同じです::"

#: ../../howto/descriptor.rst:403
msgid ""
"This behavior is useful whenever the function only needs to have a class "
"reference and does not care about any underlying data.  One use for "
"classmethods is to create alternate class constructors.  In Python 2.3, the "
"classmethod :func:`dict.fromkeys` creates a new dictionary from a list of "
"keys.  The pure Python equivalent is::"
msgstr ""
"この振る舞いは、関数がクラス参照のみを必要とし、下にあるデータを考慮しないと"
"きに便利です。クラスメソッドの使い方の一つは、代わりのクラスコンストラクタを"
"作ることです。Python 2.3 では、クラスメソッド :func:`dict.fromkeys` は新しい"
"辞書をキーのリストから生成します。等価な pure Python 版は::"

#: ../../howto/descriptor.rst:419
msgid "Now a new dictionary of unique keys can be constructed like this::"
msgstr "これで一意なキーを持つ新しい辞書が以下のように構成できます::"

#: ../../howto/descriptor.rst:424
msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`classmethod` would look like this::"
msgstr ""
"非データディスクリプタプロトコルを使った、 :func:`classmethod` の pure "
"Python 版はこのようになります::"
