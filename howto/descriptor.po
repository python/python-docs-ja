# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2018
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-29 13:25+0900\n"
"PO-Revision-Date: 2018-05-29 04:30+0000\n"
"Last-Translator: Arihiro TAKASE <artakase@gmail.com>\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/descriptor.rst:3
msgid "Descriptor HowTo Guide"
msgstr "ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ HowTo ã‚¬ã‚¤ãƒ‰"

#: ../../howto/descriptor.rst:0
msgid "Author"
msgstr "è‘—è€…"

#: ../../howto/descriptor.rst:5
msgid "Raymond Hettinger"
msgstr "Raymond Hettinger"

#: ../../howto/descriptor.rst:0
msgid "Contact"
msgstr "å•ã„åˆã‚ã›å…ˆ"

#: ../../howto/descriptor.rst:6
msgid "<python at rcn dot com>"
msgstr "<python at rcn dot com>"

#: ../../howto/descriptor.rst:8
msgid "Contents"
msgstr "å†…å®¹"

#: ../../howto/descriptor.rst:11
msgid "Abstract"
msgstr "æ¦‚è¦"

#: ../../howto/descriptor.rst:13
msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors are "
"called.  Examines a custom descriptor and several built-in python "
"descriptors including functions, properties, static methods, and class "
"methods.  Shows how each works by giving a pure Python equivalent and a "
"sample application."
msgstr "ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’å®šç¾©ã—ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’è¦ç´„ã—ã€ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãŒã©ã®ã‚ˆã†ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã‹ç¤ºã—ã¾ã™ã€‚ã‚«ã‚¹ã‚¿ãƒ ã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚„ã€é–¢æ•°ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã€é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã€ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å«ã‚€ã€ã„ãã¤ã‹ã®çµ„ã¿è¾¼ã¿ Python ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’è€ƒå¯Ÿã—ã¾ã™ã€‚ç­‰ä¾¡ãª pure Python ç‰ˆã‚„ã‚µãƒ³ãƒ—ãƒ«ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä¸ãˆã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ãã‚Œãã‚ŒãŒã©ã®ã‚ˆã†ã«åƒãã‹ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../howto/descriptor.rst:18
msgid ""
"Learning about descriptors not only provides access to a larger toolset, it "
"creates a deeper understanding of how Python works and an appreciation for "
"the elegance of its design."
msgstr "ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã«ã¤ã„ã¦å­¦ã¶ã“ã¨ã«ã‚ˆã‚Šã€æ–°ã—ã„ãƒ„ãƒ¼ãƒ«ã‚»ãƒƒãƒˆãŒä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚‹ã ã‘ã§ãªãã€Python ã®ä»•çµ„ã¿ã‚„ã€æ´—ç·´ã•ã‚ŒãŸè¨­è¨ˆã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ã¤ã„ã¦ã®ã‚ˆã‚Šæ·±ã„ç†è§£ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../howto/descriptor.rst:24
msgid "Definition and Introduction"
msgstr "å®šç¾©ã¨å°å…¥"

#: ../../howto/descriptor.rst:26
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol.  Those methods are :meth:`__get__`, :meth:`__set__`, and "
":meth:`__delete__`.  If any of those methods are defined for an object, it "
"is said to be a descriptor."
msgstr "ä¸€èˆ¬ã«ã€ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ \"æŸç¸›å‹•ä½œ (binding behavior)\" ã‚’ã‚‚ã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå±æ€§ã§ã€ãã®å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ãŒã€ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã•ã‚ŒãŸã‚‚ã®ã§ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ :meth:`__get__`, :meth:`__set__`, ãŠã‚ˆã³ :meth:`__delete__` ã§ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ã„ãšã‚Œã‹ãŒã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å®šç¾©ã•ã‚Œã¦ã„ã‚Œã°ã€ãã‚Œã¯ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨å‘¼ã°ã‚Œã¾ã™ã€‚"

#: ../../howto/descriptor.rst:32
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and"
" continuing through the base classes of ``type(a)`` excluding metaclasses. "
"If the looked-up value is an object defining one of the descriptor methods, "
"then Python may override the default behavior and invoke the descriptor "
"method instead. Where this occurs in the precedence chain depends on which "
"descriptor methods were defined.  Note that descriptors are only invoked for"
" new style objects or classes (a class is new style if it inherits from "
":class:`object` or :class:`type`)."
msgstr "å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æŒ¯ã‚‹èˆã„ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¾æ›¸ã®å±æ€§ã®å–å¾—ã€è¨­å®šã€å‰Šé™¤ã§ã™ã€‚ä¾‹ãˆã° ``a.x`` ã¯ã€ã¾ãš ``a.__dict__['x']`` ã€ãã‚Œã‹ã‚‰ ``type(a).__dict__['x']`` ã€ã•ã‚‰ã« ``type(a)`` ã®ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã‚’é™¤ãåŸºåº•ã‚¯ãƒ©ã‚¹ã¸ã¨ç¶šãã¨ã„ã†ã‚ˆã†ã«æ¢ç´¢ãŒé€£é–ã—ã¾ã™ã€‚è¦‹ã¤ã‹ã£ãŸå€¤ãŒã€ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ã®ã„ãšã‚Œã‹ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã‚‰ã€ Python ã¯ãã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æŒ¯ã‚‹èˆã„ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã€ä»£ã‚ã‚Šã«ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ã“ã‚ŒãŒã©ã®é€£é–é †ä½ã§è¡Œã‚ã‚Œã‚‹ã‹ã¯ã€ã©ã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹ã«ä¾ã‚Šã¾ã™ã€‚ãªãŠã€ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ã‚¯ãƒ©ã‚¹ã«ã®ã¿å‘¼ã³å‡ºã•ã‚Œã¾ã™ (ã‚ã‚‹ã‚¯ãƒ©ã‚¹ã¯ã€ãã‚ŒãŒ :class:`object` ã¾ãŸã¯ :class:`type` ã‚’ç¶™æ‰¿ã—ã¦ã„ã‚Œã°ã€æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã§ã™)ã€‚"

#: ../../howto/descriptor.rst:43
msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and "
":func:`super()`. They are used throughout Python itself to implement the new"
" style classes introduced in version 2.2.  Descriptors simplify the "
"underlying C-code and offer a flexible set of new tools for everyday Python "
"programs."
msgstr "ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€å¼·åŠ›ãªã€å¤šç›®çš„ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚ã“ã‚Œã¯ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã€ãƒ¡ã‚½ãƒƒãƒ‰ã€é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã€ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã€ãã—ã¦ :func:`super()` ã®èƒŒå¾Œã«ã‚ã‚‹æ©Ÿæ§‹ã§ã™ã€‚ã“ã‚Œã¯ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 2.2 ã§å°å…¥ã•ã‚ŒãŸæ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€Python ã®ã„ãŸã‚‹ã¨ã“ã‚ã§ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€åŸºå¹¹ã«ã‚ã‚‹ C ã‚³ãƒ¼ãƒ‰ã‚’ç°¡æ½”ã«ã—ã€æ¯æ—¥ã® Python ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã€æŸ”è»Ÿãªæ–°ã—ã„ãƒ„ãƒ¼ãƒ«ç¾¤ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../howto/descriptor.rst:51
msgid "Descriptor Protocol"
msgstr "ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«"

#: ../../howto/descriptor.rst:53
msgid "``descr.__get__(self, obj, type=None) --> value``"
msgstr "``descr.__get__(self, obj, type=None) --> value``"

#: ../../howto/descriptor.rst:55
msgid "``descr.__set__(self, obj, value) --> None``"
msgstr "``descr.__set__(self, obj, value) --> None``"

#: ../../howto/descriptor.rst:57
msgid "``descr.__delete__(self, obj) --> None``"
msgstr "``descr.__delete__(self, obj) --> None``"

#: ../../howto/descriptor.rst:59
msgid ""
"That is all there is to it.  Define any of these methods and an object is "
"considered a descriptor and can override default behavior upon being looked "
"up as an attribute."
msgstr "ã“ã‚Œã§å…¨ã¦ã§ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ã„ãšã‚Œã‹ã‚’å®šç¾©ã™ã‚Œã°ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨ã¿ãªã•ã‚Œã€æ¢ç´¢ã•ã‚ŒãŸéš›ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æŒ¯ã‚‹èˆã„ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã§ãã¾ã™ã€‚"

#: ../../howto/descriptor.rst:63
msgid ""
"If an object defines both :meth:`__get__` and :meth:`__set__`, it is "
"considered a data descriptor.  Descriptors that only define :meth:`__get__` "
"are called non-data descriptors (they are typically used for methods but "
"other uses are possible)."
msgstr "ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ :meth:`__get__` ã¨ :meth:`__set__` ã®ä¸¡æ–¹ã‚’å®šç¾©ã—ã¦ã„ãŸã‚‰ã€ãã‚Œã¯ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚ :meth:`__get__` ã ã‘ã‚’å®šç¾©ã—ã¦ã„ã‚‹ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨å‘¼ã°ã‚Œã¾ã™ (ã“ã‚Œã‚‰ã¯å…¸å‹çš„ã«ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã«ä½¿ã‚ã‚Œã¾ã™ãŒã€ä»–ã®ä½¿ã„æ–¹ã‚‚å‡ºæ¥ã¾ã™)ã€‚"

#: ../../howto/descriptor.rst:68
msgid ""
"Data and non-data descriptors differ in how overrides are calculated with "
"respect to entries in an instance's dictionary.  If an instance's dictionary"
" has an entry with the same name as a data descriptor, the data descriptor "
"takes precedence.  If an instance's dictionary has an entry with the same "
"name as a non-data descriptor, the dictionary entry takes precedence."
msgstr "ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã§ã¯ã€ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è¾æ›¸ã®ã‚¨ãƒ³ãƒˆãƒªã«é–¢ã—ã¦ã©ã®ã‚ˆã†ã«è¨ˆç®—ã•ã‚Œã‚‹ã‹ãŒç•°ãªã‚Šã¾ã™ã€‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è¾æ›¸ã«ã€ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨åŒåã®é …ç›®ãŒã‚ã‚Œã°ã€ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ–¹ãŒå„ªå…ˆã•ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è¾æ›¸ã«ã€éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨åŒåã®é …ç›®ãŒã‚ã‚Œã°ã€è¾æ›¸ã®é …ç›®ã®æ–¹ãŒå„ªå…ˆã•ã‚Œã¾ã™ã€‚"

#: ../../howto/descriptor.rst:74
msgid ""
"To make a read-only data descriptor, define both :meth:`__get__` and "
":meth:`__set__` with the :meth:`__set__` raising an :exc:`AttributeError` "
"when called.  Defining the :meth:`__set__` method with an exception raising "
"placeholder is enough to make it a data descriptor."
msgstr "èª­ã¿è¾¼ã¿å°‚ç”¨ã®ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’ä½œã‚‹ã«ã¯ã€ :meth:`__get__` ã¨ :meth:`__set__` ã®ä¸¡æ–¹ã‚’å®šç¾©ã—ã€ :meth:`__set__` ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã« :exc:`AttributeError` ãŒé€å‡ºã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ :meth:`__set__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ã¨ã—ã¦å®šç¾©ã™ã‚Œã°ã€ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã«ã™ã‚‹ã®ã«ååˆ†ã§ã™ã€‚"

#: ../../howto/descriptor.rst:81
msgid "Invoking Descriptors"
msgstr "ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å‘¼ã³å‡ºã—"

#: ../../howto/descriptor.rst:83
msgid ""
"A descriptor can be called directly by its method name.  For example, "
"``d.__get__(obj)``."
msgstr "ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰åã§ç›´æ¥å‘¼ã¶ã“ã¨ã‚‚å‡ºæ¥ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``d.__get__(obj)`` ã§ã™ã€‚"

#: ../../howto/descriptor.rst:86
msgid ""
"Alternatively, it is more common for a descriptor to be invoked "
"automatically upon attribute access.  For example, ``obj.d`` looks up ``d`` "
"in the dictionary of ``obj``.  If ``d`` defines the method :meth:`__get__`, "
"then ``d.__get__(obj)`` is invoked according to the precedence rules listed "
"below."
msgstr "ã¾ãŸã¯ã€ä¸€èˆ¬çš„ã«ã€ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã‹ã‚‰è‡ªå‹•çš„ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ``obj.d`` ã¯ ``obj`` ã®è¾æ›¸ã‹ã‚‰ ``d`` ã‚’æ¢ç´¢ã—ã¾ã™ã€‚ ``d`` ãŒãƒ¡ã‚½ãƒƒãƒ‰ :meth:`__get__` ã‚’å®šç¾©ã—ã¦ã„ãŸã‚‰ã€ä»¥ä¸‹ã«åˆ—æŒ™ã™ã‚‹å„ªå…ˆé †ä½ã«å¾“ã£ã¦ã€ ``d.__get__(obj)`` ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../howto/descriptor.rst:91
msgid ""
"The details of invocation depend on whether ``obj`` is an object or a class."
" Either way, descriptors only work for new style objects and classes.  A "
"class is new style if it is a subclass of :class:`object`."
msgstr "å‘¼ã³å‡ºã—ã®è©³ç´°ã¯ã€ ``obj`` ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚¯ãƒ©ã‚¹ã‹ã«ä¾ã‚Šã¾ã™ã€‚ã©ã¡ã‚‰ã«ã—ã¦ã‚‚ã€ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„ã‚¯ãƒ©ã‚¹ã«ã®ã¿åƒãã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã¯ã€ãã‚ŒãŒ :class:`object` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ãªã‚‰æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã§ã™ã€‚"

#: ../../howto/descriptor.rst:95
msgid ""
"For objects, the machinery is in :meth:`object.__getattribute__` which "
"transforms ``b.x`` into ``type(b).__dict__['x'].__get__(b, type(b))``.  The "
"implementation works through a precedence chain that gives data descriptors "
"priority over instance variables, instance variables priority over non-data "
"descriptors, and assigns lowest priority to :meth:`__getattr__` if provided."
" The full C implementation can be found in "
":c:func:`PyObject_GenericGetAttr()` in :source:`Objects/object.c`."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€ãã®æ©Ÿæ§‹ã¯ ``b.x`` ã‚’ ``type(b).__dict__['x'].__get__(b, type(b))`` ã«å¤‰æ›ã™ã‚‹ :meth:`object.__getattribute__` ã«ã‚ã‚Šã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å„ªå…ˆåº¦ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‚ˆã‚Šé«˜ãã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã®å„ªå…ˆåº¦ã¯éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚ˆã‚Šé«˜ãã€(æä¾›ã•ã‚Œã¦ã„ã‚Œã°) :meth:`__getattr__` ã®å„ªå…ˆåº¦ãŒæœ€ã‚‚ä½ã„ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚å®Œå…¨ãª C å®Ÿè£…ã¯ã€ :source:`Objects/object.c` ã® :c:func:`PyObject_GenericGetAttr()` ã§è¦‹ã¤ã‹ã‚Šã¾ã™ã€‚"

#: ../../howto/descriptor.rst:103
msgid ""
"For classes, the machinery is in :meth:`type.__getattribute__` which "
"transforms ``B.x`` into ``B.__dict__['x'].__get__(None, B)``.  In pure "
"Python, it looks like::"
msgstr "ã‚¯ãƒ©ã‚¹ã§ã¯ã€ãã®æ©Ÿæ§‹ã¯ ``B.x`` ã‚’ ``B.__dict__['x'].__get__(None, B)`` ã«å¤‰æ›ã™ã‚‹ :meth:`type.__getattribute__` ã«ã‚ã‚Šã¾ã™ã€‚ pure Python ã§ã¯ã€ã“ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../howto/descriptor.rst:114
msgid "The important points to remember are:"
msgstr "æ†¶ãˆã¦ãŠãã¹ãé‡è¦ãªç‚¹ã¯:"

#: ../../howto/descriptor.rst:116
msgid "descriptors are invoked by the :meth:`__getattribute__` method"
msgstr "ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ :meth:`__getattribute__` ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦å‘¼ã³å‡ºã•ã‚Œã‚‹"

#: ../../howto/descriptor.rst:117
msgid ""
"overriding :meth:`__getattribute__` prevents automatic descriptor calls"
msgstr ":meth:`__getattribute__` ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã¨ã€è‡ªå‹•çš„ãªãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å‘¼ã³å‡ºã—ãŒè¡Œã‚ã‚Œãªããªã‚‹"

#: ../../howto/descriptor.rst:118
msgid ""
":meth:`__getattribute__` is only available with new style classes and "
"objects"
msgstr ":meth:`__getattribute__` ã¯æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚¯ãƒ©ã‚¹ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã®ã¿ä½¿ãˆã‚‹ã€‚"

#: ../../howto/descriptor.rst:119
msgid ""
":meth:`object.__getattribute__` and :meth:`type.__getattribute__` make "
"different calls to :meth:`__get__`."
msgstr ":meth:`object.__getattribute__` ã¨ :meth:`type.__getattribute__` ã§ã¯ã€ :meth:`__get__` ã®å‘¼ã³å‡ºã—ãŒç•°ãªã‚‹ã€‚"

#: ../../howto/descriptor.rst:121
msgid "data descriptors always override instance dictionaries."
msgstr "ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€å¿…ãšã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è¾æ›¸ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã€‚"

#: ../../howto/descriptor.rst:122
msgid "non-data descriptors may be overridden by instance dictionaries."
msgstr "éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è¾æ›¸ã«ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚"

#: ../../howto/descriptor.rst:124
msgid ""
"The object returned by ``super()`` also has a custom "
":meth:`__getattribute__` method for invoking descriptors.  The call "
"``super(B, obj).m()`` searches ``obj.__class__.__mro__`` for the base class "
"``A`` immediately following ``B`` and then returns "
"``A.__dict__['m'].__get__(obj, B)``.  If not a descriptor, ``m`` is returned"
" unchanged.  If not in the dictionary, ``m`` reverts to a search using "
":meth:`object.__getattribute__`."
msgstr "``super()`` ãŒè¿”ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã•ã‚‰ã«ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’èµ·å‹•ã™ã‚‹ã‚«ã‚¹ã‚¿ãƒ  :meth:`__getattribute__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚ ``super(B, obj).m()`` ã®å‘¼ã³å‡ºã—ã¯ã€ ``B`` ã«ç¶šãåŸºåº•ã‚¯ãƒ©ã‚¹ ``A`` ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã« ``obj.__class__.__mro__`` ã‚’æ¢ç´¢ã—ã€ ``A.__dict__['m'].__get__(obj, B)`` ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã§ã¯ãªã„å ´åˆã€ ``m`` ãŒå¤‰æ›´ã•ã‚Œãšã«è¿”ã•ã‚Œã¾ã™ã€‚è¾æ›¸ã«ãªã‘ã‚Œã°ã€  ``m`` ã¯ :meth:`object.__getattribute__` ã‚’ä½¿ç”¨ã—ãŸæ¢ç´¢ã«æˆ»ã‚Šã¾ã™ã€‚"

#: ../../howto/descriptor.rst:131
msgid ""
"Note, in Python 2.2, ``super(B, obj).m()`` would only invoke :meth:`__get__`"
" if ``m`` was a data descriptor.  In Python 2.3, non-data descriptors also "
"get invoked unless an old-style class is involved.  The implementation "
"details are in :c:func:`super_getattro()` in :source:`Objects/typeobject.c`."
msgstr "ãªãŠã€Python 2.2 ã§ã¯ã€ ``m`` ãŒãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãªã‚‰ã€ ``super(B, obj).m()`` ã¯ :meth:`__get__` ã‚’å‘¼ã³å‡ºã™ã ã‘ã§ã™ã€‚ Python 2.3 ã§ã¯ã€æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ãŒå‘¼ã³å‡ºã•ã‚Œãªã‘ã‚Œã°ã€éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚‚å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚å®Ÿè£…ã®è©³ç´°ã¯ã€ :source:`Objects/typeobject.c` å†…ã® :c:func:`super_getattro()` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../howto/descriptor.rst:138
msgid ""
"The details above show that the mechanism for descriptors is embedded in the"
" :meth:`__getattribute__()` methods for :class:`object`, :class:`type`, and "
":func:`super`.  Classes inherit this machinery when they derive from "
":class:`object` or if they have a meta-class providing similar "
"functionality. Likewise, classes can turn-off descriptor invocation by "
"overriding :meth:`__getattribute__()`."
msgstr "ä¸Šè¿°ã®è©³ç´°ã¯ã€ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ©Ÿæ§‹ãŒã€ :meth:`__getattribute__()` ãƒ¡ã‚½ãƒƒãƒ‰ã«åŸ‹ã‚ã“ã¾ã‚Œã€ :class:`object`, :class:`type`, ãã—ã¦ :func:`super` ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã‚’è¡¨ã—ã¦ã„ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã¯ã€ :class:`object` ã‹ã‚‰å°å‡ºã•ã‚ŒãŸã¨ãã€ã¾ãŸã¯ã€åŒã˜ã‚ˆã†ãªæ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã‚’ã‚‚ã¤ã¨ãã€ã“ã®æ©Ÿæ§‹ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚åŒæ§˜ã«ã€ :meth:`__getattribute__()` ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã“ã¨ã§ã€ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å‘¼ã³å‡ºã—ã‚’ç„¡åŠ¹ã«ã§ãã¾ã™ã€‚"

#: ../../howto/descriptor.rst:147
msgid "Descriptor Example"
msgstr "ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®ä¾‹"

#: ../../howto/descriptor.rst:149
msgid ""
"The following code creates a class whose objects are data descriptors which "
"print a message for each get or set.  Overriding :meth:`__getattribute__` is"
" alternate approach that could do this for every attribute.  However, this "
"descriptor is useful for monitoring just a few chosen attributes::"
msgstr "ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå–å¾—ã¨è¨­å®šã®ãŸã³ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã§ã‚ã‚‹ã‚ˆã†ãªã‚¯ãƒ©ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ä»£ã‚ã‚Šã« :meth:`__getattribute__` ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã¨ã€å…¨ã¦ã®å±æ€§ã«å¯¾ã—ã¦ã“ã‚ŒãŒã§ãã¾ã™ã€‚ã—ã‹ã—ã€ã“ã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€å°‘æ•°ã®é¸ã°ã‚ŒãŸå±æ€§ã‚’ç›£è¦–ã™ã‚‹ã®ã«ä¾¿åˆ©ã§ã™::"

#: ../../howto/descriptor.rst:187
msgid ""
"The protocol is simple and offers exciting possibilities.  Several use cases"
" are so common that they have been packaged into individual function calls. "
"Properties, bound and unbound methods, static methods, and class methods are"
" all based on the descriptor protocol."
msgstr "ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯å˜ç´”ã§ã™ãŒã€ãƒ¯ã‚¯ãƒ¯ã‚¯ã™ã‚‹å¯èƒ½æ€§ã‚‚ç§˜ã‚ã¦ã„ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã®ä¸­ã«ã¯ã€ã‚ã¾ã‚Šã«ä¸€èˆ¬çš„ãªã®ã§å€‹åˆ¥ã®é–¢æ•°ã®å‘¼ã³å‡ºã—ã«ã¾ã¨ã‚ã‚‰ã‚ŒãŸã‚‚ã®ã‚‚ã‚ã‚Šã¾ã™ã€‚ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã€æŸç¸›ãŠã‚ˆã³éæŸç¸›ã®ãƒ¡ã‚½ãƒƒãƒ‰ã€é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã€ãã—ã¦ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å…¨ã¦ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚"

#: ../../howto/descriptor.rst:194
msgid "Properties"
msgstr "ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£"

#: ../../howto/descriptor.rst:196
msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers function calls upon access to an attribute.  Its signature "
"is::"
msgstr ":func:`property` ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€å±æ€§ã¸ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨é–¢æ•°ã®å‘¼ã³å‡ºã—ã‚’å¼•ãèµ·ã“ã™ã€ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’ç°¡æ½”ã«çµ„ã¿ç«‹ã¦ã‚‰ã‚Œã¾ã™ã€‚ã‚·ã‚°ãƒãƒãƒ£ã¯ã“ã†ã§ã™::"

#: ../../howto/descriptor.rst:201
msgid ""
"The documentation shows a typical use to define a managed attribute ``x``::"
msgstr "ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ã€ç®¡ç†ã•ã‚ŒãŸå±æ€§ ``x`` ã‚’å®šç¾©ã™ã‚‹å…¸å‹çš„ãªä½¿ç”¨æ³•ã‚’ç¤ºã—ã¾ã™::"

#: ../../howto/descriptor.rst:209
msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent::"
msgstr "ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®è¦‹åœ°ã‹ã‚‰ :func:`property` ãŒã©ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹ã‚’è¦‹ã‚‹ãŸã‚ã«ã€ç­‰ä¾¡ãª Python ç‰ˆã‚’ã“ã“ã«æŒ™ã’ã¾ã™::"

#: ../../howto/descriptor.rst:249
msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of a "
"method."
msgstr "çµ„ã¿è¾¼ã¿ã® :func:`property` é–¢æ•°ã¯ã€ãƒ¦ãƒ¼ã‚¶ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¸ã®å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ãŒä¸ãˆã‚‰ã‚Œã€ç¶šãå¤‰æ›´ãŒãƒ¡ã‚½ãƒƒãƒ‰ã®ä»‹å…¥ã‚’è¦æ±‚ã™ã‚‹ã¨ãã«å½¹ç«‹ã¡ã¾ã™ã€‚"

#: ../../howto/descriptor.rst:253
msgid ""
"For instance, a spreadsheet class may grant access to a cell value through "
"``Cell('b10').value``. Subsequent improvements to the program require the "
"cell to be recalculated on every access; however, the programmer does not "
"want to affect existing client code accessing the attribute directly.  The "
"solution is to wrap access to the value attribute in a property data "
"descriptor::"
msgstr "ä¾‹ãˆã°ã€ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚¯ãƒ©ã‚¹ãŒã€ ``Cell('b10').value`` ã§ã‚»ãƒ«ã®å€¤ã‚’å–å¾—ã§ãã‚‹ã¨ã—ã¾ã™ã€‚ç¶šãæ”¹è‰¯ã«ã‚ˆã‚Šã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚¢ã‚¯ã‚»ã‚¹ã®åº¦ã«ã‚»ãƒ«ã®å†è¨ˆç®—ã‚’ã™ã‚‹ã“ã¨ã‚’è¦æ±‚ã—ã¾ã—ãŸã€‚ã—ã‹ã—ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ã€ãã®å±æ€§ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ—¢å­˜ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚³ãƒ¼ãƒ‰ã«å½±éŸ¿ã‚’ä¸ãˆãŸãã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®è§£æ±ºç­–ã¯ã€property ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿å†…ã«å€¤å±æ€§ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹ã“ã¨ã§ã™::"

#: ../../howto/descriptor.rst:269
msgid "Functions and Methods"
msgstr "é–¢æ•°ã¨ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../howto/descriptor.rst:271
msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr "Python ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘æ©Ÿèƒ½ã¯ã€é–¢æ•°ã«åŸºã¥ãç’°å¢ƒã®ä¸Šã«æ§‹ç¯‰ã•ã‚Œã¦ã„ã¾ã™ã€‚éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’ä½¿ã£ã¦ã€ã“ã® 2 ã¤ã¯ã‚·ãƒ¼ãƒ ãƒ¬ã‚¹ã«çµ„ã¿åˆã‚ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../howto/descriptor.rst:274
msgid ""
"Class dictionaries store methods as functions.  In a class definition, "
"methods are written using :keyword:`def` and :keyword:`lambda`, the usual "
"tools for creating functions.  The only difference from regular functions is"
" that the first argument is reserved for the object instance.  By Python "
"convention, the instance reference is called *self* but may be called *this*"
" or any other variable name."
msgstr "ã‚¯ãƒ©ã‚¹è¾æ›¸ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚’é–¢æ•°ã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹å®šç¾©å†…ã§ã€ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€é–¢æ•°ã‚’ä½¿ã†ã®ã«ä¾¿åˆ©ãªãƒ„ãƒ¼ãƒ«ã€ :keyword:`def` ã‚„ :keyword:`lambda` ã‚’ä½¿ã£ã¦æ›¸ã‹ã‚Œã¾ã™ã€‚æ¨™æº–ã®é–¢æ•°ã¨ã®å”¯ä¸€ã®é•ã„ã¯ã€ç¬¬ä¸€å¼•æ•°ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãŸã‚ã«äºˆç´„ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã§ã™ã€‚ Python ã®æ…£ç¿’ã§ã¯ã€ã“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å‚ç…§ã¯ *self* ã¨å‘¼ã°ã‚Œã¾ã™ãŒã€ *this* ãã®ä»–ã®å¥½ããªå¤‰æ•°åã§å‘¼ã³å‡ºã›ã¾ã™ã€‚"

#: ../../howto/descriptor.rst:281
msgid ""
"To support method calls, functions include the :meth:`__get__` method for "
"binding methods during attribute access.  This means that all functions are "
"non-data descriptors which return bound or unbound methods depending whether"
" they are invoked from an object or a class.  In pure python, it works like "
"this::"
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ã€é–¢æ•°ã® :meth:`__get__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å±æ€§ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã«ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŸç¸›ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã™ã¹ã¦ã®é–¢æ•°ã¯ã€ãã‚ŒãŒå‘¼ã³å‡ºã•ã‚ŒãŸã®ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚¯ãƒ©ã‚¹ã‹ã«ã‚ˆã£ã¦ã€æŸç¸›ã‹éæŸç¸›ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿”ã™éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã«ãªã‚Šã¾ã™ã€‚pure Python ã§ã¯ã€ã“ã‚Œã¯ã“ã®ã‚ˆã†ã«ã¯ãŸã‚‰ãã¾ã™::"

#: ../../howto/descriptor.rst:293
msgid ""
"Running the interpreter shows how the function descriptor works in "
"practice::"
msgstr "ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’èµ·å‹•ã™ã‚‹ã¨ã€ã“ã®é–¢æ•°ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãŒå®Ÿéš›ã«ã©ã†ã¯ãŸã‚‰ãã‹ã‚’è¦‹ã‚‰ã‚Œã¾ã™::"

#: ../../howto/descriptor.rst:307
msgid ""
"The output suggests that bound and unbound methods are two different types. "
"While they could have been implemented that way, the actual C implementation"
" of :c:type:`PyMethod_Type` in :source:`Objects/classobject.c` is a single "
"object with two different representations depending on whether the "
":attr:`im_self` field is set or is *NULL* (the C equivalent of ``None``)."
msgstr "ã“ã®å‡ºåŠ›ã¯ã€æŸç¸›ãƒ¡ã‚½ãƒƒãƒ‰ã¨éæŸç¸›ãƒ¡ã‚½ãƒƒãƒ‰ã¯ 2 ã¤ã®ç•°ãªã‚‹å‹ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚\nã“ã‚Œã‚‰ã¯ã€ç•°ãªã‚‹å‹ã¨ã—ã¦å®Ÿè£…ã™ã‚‹ã“ã¨ã‚‚å‡ºæ¥ã¾ã™ãŒã€ :source:`Objects/classobject.c` ã«ãŠã‘ã‚‹ :c:type:`PyMethod_Type` ã®å®Ÿéš›ã® C å®Ÿè£…ã¯ 1 ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ :attr:`im_self` ãŒ *NULL* (C ã§ã® ``None`` ã¨åŒç­‰ã®ã‚‚ã®) ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã§æ±ºã¾ã‚‹ 2 ã¤ã®ç•°ãªã‚‹è¡¨ç¾ã‚’æŒã£ã¦ã‚‹ã®ã§ã™ã€‚"

#: ../../howto/descriptor.rst:313
msgid ""
"Likewise, the effects of calling a method object depend on the "
":attr:`im_self` field. If set (meaning bound), the original function (stored"
" in the :attr:`im_func` field) is called as expected with the first argument"
" set to the instance.  If unbound, all of the arguments are passed unchanged"
" to the original function. The actual C implementation of "
":func:`instancemethod_call()` is only slightly more complex in that it "
"includes some type checking."
msgstr "åŒæ§˜ã«ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‘¼ã³å‡ºã™ã“ã¨ã®åŠ¹æœã‚‚ã€ :attr:`im_self` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ä¾ã‚Šã¾ã™ã€‚è¨­å®šã•ã‚Œã¦ã„ã‚Œã° (æŸç¸›ã‚’æ„å‘³ã—)ã€æœŸå¾…é€šã‚Š (:attr:`im_func` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ä¿å­˜ã•ã‚Œã¦ã„ã‚‹) å…ƒã®é–¢æ•°ãŒã€ç¬¬ä¸€å¼•æ•°ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã—ã¦ã€å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚éæŸç¸›ãªã‚‰ã€ã™ã¹ã¦ã®å¼•æ•°ãŒãã®ã¾ã¾å…ƒã®é–¢æ•°ã«æ¸¡ã•ã‚Œã¾ã™ã€‚ :func:`instancemethod_call()` ã®å®Ÿéš›ã® C å®Ÿè£…ã¯ã€å‹ãƒã‚§ãƒƒã‚¯ãŒã‚ã‚‹ãŸã‚ã€ã‚‚ã†å°‘ã—ã ã‘è¤‡é›‘ã§ã™ã€‚"

#: ../../howto/descriptor.rst:322
msgid "Static Methods and Class Methods"
msgstr "é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../howto/descriptor.rst:324
msgid ""
"Non-data descriptors provide a simple mechanism for variations on the usual "
"patterns of binding functions into methods."
msgstr "éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€é–¢æ•°ã‚’ãƒ¡ã‚½ãƒƒãƒ‰ã«æŸç¸›ã™ã‚‹ã€å„ç¨®ã®ä¸€èˆ¬çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã€å˜ç´”ãªæ©Ÿæ§‹ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../howto/descriptor.rst:327
msgid ""
"To recap, functions have a :meth:`__get__` method so that they can be "
"converted to a method when accessed as attributes.  The non-data descriptor "
"transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  Calling "
"``klass.f(*args)`` becomes ``f(*args)``."
msgstr "ã¾ã¨ã‚ã‚‹ã¨ã€é–¢æ•°ã¯ :meth:`__get__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¡ã€å±æ€§ã¨ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚ŒãŸã¨ãã€ãƒ¡ã‚½ãƒƒãƒ‰ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚ã“ã®éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ã€ ``obj.f(*args)`` ã®å‘¼ã³å‡ºã—ã‚’ ``f(obj, *args)`` ã«å¤‰æ›ã—ã¾ã™ã€‚ ``klass.f(*args)`` ã‚’å‘¼ã³å‡ºã™ã¨ ``f(*args)`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/descriptor.rst:332
msgid "This chart summarizes the binding and its two most useful variants:"
msgstr "ã“ã®ãƒãƒ£ãƒ¼ãƒˆã¯ã€æŸç¸›ã¨ã€ãã® 2 ã¤ã®ç•°ãªã‚‹ä¾¿åˆ©ãªå½¢ã‚’ã¾ã¨ã‚ã¦ã„ã¾ã™:"

#: ../../howto/descriptor.rst:335
msgid "Transformation"
msgstr "å¤‰æ›"

#: ../../howto/descriptor.rst:335
msgid "Called from an Object"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹"

#: ../../howto/descriptor.rst:335
msgid "Called from a Class"
msgstr "ã‚¯ãƒ©ã‚¹ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹"

#: ../../howto/descriptor.rst:338
msgid "function"
msgstr "é–¢æ•°"

#: ../../howto/descriptor.rst:338
msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

#: ../../howto/descriptor.rst:338 ../../howto/descriptor.rst:340
#: ../../howto/descriptor.rst:340
msgid "f(\\*args)"
msgstr "f(\\*args)"

#: ../../howto/descriptor.rst:340
msgid "staticmethod"
msgstr "é™çš„ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../howto/descriptor.rst:342
msgid "classmethod"
msgstr "ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../howto/descriptor.rst:342
msgid "f(type(obj), \\*args)"
msgstr "f(type(obj), \\*args)"

#: ../../howto/descriptor.rst:342
msgid "f(klass, \\*args)"
msgstr "f(klass, \\*args)"

#: ../../howto/descriptor.rst:345
msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into "
"``object.__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, "
"\"f\")``. As a result, the function becomes identically accessible from "
"either an object or a class."
msgstr "é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä¸‹ã«ã‚ã‚‹é–¢æ•°ã‚’ãã®ã¾ã¾è¿”ã—ã¾ã™ã€‚ ``c.f`` ã‚„ ``C.f`` ã¯ã€ ``object.__getattribute__(c, \"f\")`` ã‚„ ``object.__getattribute__(C, \"f\")`` ã‚’ç›´æ¥æ¢ç´¢ã™ã‚‹ã®ã¨åŒã˜ã§ã™ã€‚çµæœã¨ã—ã¦ã€é–¢æ•°ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã‚¯ãƒ©ã‚¹ã‹ã‚‰åŒã˜ã‚ˆã†ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚"

#: ../../howto/descriptor.rst:351
msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr "é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã«ã™ã‚‹ã¨è‰¯ã„ã®ã¯ã€ ``self`` å¤‰æ•°ã¸ã®å‚ç…§ã‚’æŒãŸãªã„ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚"

#: ../../howto/descriptor.rst:354
msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on the "
"data. However, there may be useful functions which are conceptually related "
"but do not depend on the data.  For instance, ``erf(x)`` is handy conversion"
" routine that comes up in statistical work but does not directly depend on a"
" particular dataset. It can be called either from an object or the class:  "
"``s.erf(1.5) --> .9332`` or ``Sample.erf(1.5) --> .9332``."
msgstr "ä¾‹ãˆã°ã€çµ±è¨ˆãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«ã€å®Ÿé¨“ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ³ãƒ†ãƒŠãŒã‚ã‚‹ã¨ã—ã¾ã™ã€‚ãã®ã‚¯ãƒ©ã‚¹ã¯ã€å¹³å‡ã€ãƒ¡ã‚¸ã‚¢ãƒ³ã€ãã®ä»–ã®ã€ãƒ‡ãƒ¼ã‚¿ã«ä¾ã‚‹è¨˜è¿°çµ±è¨ˆã‚’è¨ˆç®—ã™ã‚‹æ¨™æº–ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¾ã™ã€‚ã—ã‹ã—ã€æ¦‚å¿µä¸Šã¯é–¢ä¿‚ãŒã‚ã£ã¦ã‚‚ã€ãƒ‡ãƒ¼ã‚¿ã«ã¯ä¾ã‚‰ãªã„ã‚ˆã†ãªä¾¿åˆ©ãªé–¢æ•°ã‚‚ã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ ``erf(x)`` ã¯çµ±è¨ˆä¸Šã®ä¾¿åˆ©ãªå¤‰æ›ãƒ«ãƒ¼ãƒãƒ³ã§ã™ãŒã€ç‰¹å®šã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã«ç›´æ¥ã«ã¯ä¾å­˜ã—ã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã§ã‚‚ã‚¯ãƒ©ã‚¹ã‹ã‚‰ã§ã‚‚å‘¼ã³å‡ºã›ã¾ã™: ``s.erf(1.5) --> .9332`` ã¾ãŸã¯ ``Sample.erf(1.5) --> .9332`` ã€‚"

#: ../../howto/descriptor.rst:363
msgid ""
"Since staticmethods return the underlying function with no changes, the "
"example calls are unexciting::"
msgstr "é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä¸‹ã«ã‚ã‚‹é–¢æ•°ã‚’ãã®ã¾ã¾è¿”ã™ã®ã§ã€å‘¼ã³å‡ºã—ã®ä¾‹ã¯é¢ç™½ãã‚ã‚Šã¾ã›ã‚“::"

#: ../../howto/descriptor.rst:376
msgid ""
"Using the non-data descriptor protocol, a pure Python version of "
":func:`staticmethod` would look like this::"
msgstr "éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ä½¿ã†ã¨ã€pure Python ç‰ˆã® :func:`staticmethod` ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../howto/descriptor.rst:388
msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class::"
msgstr "é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã¯é•ã£ã¦ã€ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¯é–¢æ•°ã‚’å‘¼ã³å‡ºã™å‰ã«ã‚¯ãƒ©ã‚¹å‚ç…§ã‚’å¼•æ•°ãƒªã‚¹ãƒˆã®å…ˆé ­ã«åŠ ãˆã¾ã™ã€‚ã“ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã€å‘¼ã³å‡ºã—å…ƒãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚ã‚¯ãƒ©ã‚¹ã§ã‚‚åŒã˜ã§ã™::"

#: ../../howto/descriptor.rst:403
msgid ""
"This behavior is useful whenever the function only needs to have a class "
"reference and does not care about any underlying data.  One use for "
"classmethods is to create alternate class constructors.  In Python 2.3, the "
"classmethod :func:`dict.fromkeys` creates a new dictionary from a list of "
"keys.  The pure Python equivalent is::"
msgstr "ã“ã®æŒ¯ã‚‹èˆã„ã¯ã€é–¢æ•°ãŒã‚¯ãƒ©ã‚¹å‚ç…§ã®ã¿ã‚’å¿…è¦ã¨ã—ã€ä¸‹ã«ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’è€ƒæ…®ã—ãªã„ã¨ãã«ä¾¿åˆ©ã§ã™ã€‚ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã®ä½¿ã„æ–¹ã®ä¸€ã¤ã¯ã€ä»£ã‚ã‚Šã®ã‚¯ãƒ©ã‚¹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½œã‚‹ã“ã¨ã§ã™ã€‚Python 2.3 ã§ã¯ã€ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ :func:`dict.fromkeys` ã¯æ–°ã—ã„è¾æ›¸ã‚’ã‚­ãƒ¼ã®ãƒªã‚¹ãƒˆã‹ã‚‰ç”Ÿæˆã—ã¾ã™ã€‚ç­‰ä¾¡ãª pure Python ç‰ˆã¯::"

#: ../../howto/descriptor.rst:419
msgid "Now a new dictionary of unique keys can be constructed like this::"
msgstr "ã“ã‚Œã§ä¸€æ„ãªã‚­ãƒ¼ã‚’æŒã¤æ–°ã—ã„è¾æ›¸ãŒä»¥ä¸‹ã®ã‚ˆã†ã«æ§‹æˆã§ãã¾ã™::"

#: ../../howto/descriptor.rst:424
msgid ""
"Using the non-data descriptor protocol, a pure Python version of "
":func:`classmethod` would look like this::"
msgstr "éãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ä½¿ã£ãŸã€ :func:`classmethod` ã® pure Python ç‰ˆã¯ã“ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"
