# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Ryuichi Takano <ryuichi.takano@sinewave.onmicrosoft.com>, 2017
# Arihiro TAKASE, 2017
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2017
# tomoğŸ§, 2017
# Yuma.M, 2018
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-30 05:56+0900\n"
"PO-Revision-Date: 2017-02-16 17:45+0000\n"
"Last-Translator: ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/regex.rst:5
msgid "Regular Expression HOWTO"
msgstr "æ­£è¦è¡¨ç¾ HOWTO"

#: ../../howto/regex.rst:0
msgid "Author"
msgstr "è‘—è€…"

#: ../../howto/regex.rst:7
msgid "A.M. Kuchling <amk@amk.ca>"
msgstr "A.M. Kuchling <amk@amk.ca>"

#: ../../howto/regex.rstNone
msgid "Abstract"
msgstr "æ¦‚è¦"

#: ../../howto/regex.rst:18
msgid ""
"This document is an introductory tutorial to using regular expressions in "
"Python with the :mod:`re` module.  It provides a gentler introduction than "
"the corresponding section in the Library Reference."
msgstr ""
"ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ :mod:`re` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦ Python "
"ã§æ­£è¦è¡¨ç¾ã‚’æ‰±ã†ãŸã‚ã®å°å…¥ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã§ã™ã€‚ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¬ãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã®æ­£è¦è¡¨ç¾ã®ç¯€ã‚ˆã‚Šã‚‚ã‚„ã•ã—ã„å…¥é–€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ç”¨æ„ã—ã¦ã„ã¾ã™ã€‚"

#: ../../howto/regex.rst:24
msgid "Introduction"
msgstr "ã¯ã˜ã‚ã«"

#: ../../howto/regex.rst:26
msgid ""
"Regular expressions (called REs, or regexes, or regex patterns) are "
"essentially a tiny, highly specialized programming language embedded inside "
"Python and made available through the :mod:`re` module. Using this little "
"language, you specify the rules for the set of possible strings that you "
"want to match; this set might contain English sentences, or e-mail "
"addresses, or TeX commands, or anything you like.  You can then ask "
"questions such as \"Does this string match the pattern?\", or \"Is there a "
"match for the pattern anywhere in this string?\".  You can also use REs to "
"modify a string or to split it apart in various ways."
msgstr ""
"æ­£è¦è¡¨ç¾ regular expressions (REs ã‚„ regexes ã¾ãŸã¯ regex patterns ã¨å‘¼ã°ã‚Œã¾ã™) "
"ã¯æœ¬è³ªçš„ã«å°ã•ãã€Python å†…éƒ¨ã«åŸ‹ã‚è¾¼ã¾ã‚ŒãŸé«˜åº¦ã«ç‰¹åŒ–ã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ :mod:`re` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰åˆ©ç”¨å¯èƒ½ã§ã™ã€‚ã“ã®å°ã•ãªè¨€èªã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€ãƒãƒƒãƒã•ã›ãŸã„æ–‡å­—åˆ—ã«é©åˆã™ã‚‹ã‚ˆã†ãªæ–‡å­—åˆ—ã®é›†åˆã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™; ã“ã®é›†åˆã¯è‹±æ–‡ã‚„"
" e-mail ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚„ TeX "
"ã‚³ãƒãƒ³ãƒ‰ãªã©ã€ã©ã‚“ãªã‚‚ã®ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ã€Œã“ã®æ–‡å­—åˆ—ã¯æŒ‡å®šã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã—ã¾ã™ã‹?ã€ã€Œã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã“ã®æ–‡å­—åˆ—ã®ã©ã®éƒ¨åˆ†ã«ãƒãƒƒãƒã™ã‚‹ã®ã§ã™ã‹?ã€ã¨ã„ã£ãŸã“ã¨ã‚’å•ã„åˆã‚ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ­£è¦è¡¨ç¾ã‚’ä½¿ã£ã¦æ–‡å­—åˆ—ã‚’å¤‰æ›´ã—ãŸã‚Šã„ã‚ã„ã‚ãªæ–¹æ³•ã§åˆ¥ã€…ã®éƒ¨åˆ†ã«åˆ†å‰²ã—ãŸã‚Šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../howto/regex.rst:35
msgid ""
"Regular expression patterns are compiled into a series of bytecodes which "
"are then executed by a matching engine written in C.  For advanced use, it "
"may be necessary to pay careful attention to how the engine will execute a "
"given RE, and write the RE in a certain way in order to produce bytecode "
"that runs faster. Optimization isn't covered in this document, because it "
"requires that you have a good understanding of the matching engine's "
"internals."
msgstr ""
"æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ä¸€é€£ã®ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã¨ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€C "
"ã§æ›¸ã‹ã‚ŒãŸãƒãƒƒãƒãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³ã«ã‚ˆã£ã¦å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã‚ˆã‚Šé€²ã‚“ã åˆ©ç”¨æ³•ã§ã¯ã€ã‚¨ãƒ³ã‚¸ãƒ³ãŒã©ã†ä¸ãˆã‚‰ã‚ŒãŸæ­£è¦è¡¨ç¾ã‚’å®Ÿè¡Œã™ã‚‹ã‹ã«æ³¨æ„ã™ã‚‹ã“ã¨ãŒå¿…è¦ã«ãªã‚Šã€é«˜é€Ÿã«å®Ÿè¡Œã§ãã‚‹ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã™ã‚‹ã‚ˆã†ã«æ­£è¦è¡¨ç¾ã‚’æ›¸ãã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯æœ€é©åŒ–ã¾ã§ã¯æ‰±ã„ã¾ã›ã‚“ã€ãã‚Œã«ã¯ãƒãƒƒãƒãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³ã®å†…éƒ¨ã«å¯¾ã™ã‚‹ååˆ†ãªç†è§£ãŒå¿…è¦ã ã‹ã‚‰ã§ã™ã€‚"

#: ../../howto/regex.rst:42
msgid ""
"The regular expression language is relatively small and restricted, so not "
"all possible string processing tasks can be done using regular expressions."
"  There are also tasks that *can* be done with regular expressions, but the "
"expressions turn out to be very complicated.  In these cases, you may be "
"better off writing Python code to do the processing; while Python code will "
"be slower than an elaborate regular expression, it will also probably be "
"more understandable."
msgstr ""
"æ­£è¦è¡¨ç¾è¨€èªã¯ç›¸å¯¾çš„ã«å°ã•ãã€åˆ¶é™ã•ã‚Œã¦ã„ã¾ã™ã€ãã®ãŸã‚æ­£è¦è¡¨ç¾ã‚’ä½¿ã£ã¦ã‚ã‚‰ã‚†ã‚‹æ–‡å­—åˆ—å‡¦ç†ä½œæ¥­ã‚’è¡Œãªãˆã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æ­£è¦è¡¨ç¾ã‚’ä½¿ã£ã¦è¡Œã†ã“ã¨ã®ã§ãã‚‹ä½œæ¥­ã‚‚ã‚ã‚Šã¾ã™ã€ãŸã è¡¨ç¾ã¯ã¨ã¦ã‚‚è¤‡é›‘ãªã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚ãã‚Œã‚‰ã®å ´åˆã§ã¯ã€Python"
" ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ãŸæ–¹ãŒã„ã„ã§ã—ã‚‡ã†; Python ã‚³ãƒ¼ãƒ‰ã¯å¿µå…¥ã‚Šã«ä½œã‚‰ã‚ŒãŸæ­£è¦è¡¨ç¾ã‚ˆã‚Šé…ããªã‚Šã¾ã™ãŒã€ãŠãã‚‰ãã‚ˆã‚Šèª­ã¿æ˜“ã„ã§ã—ã‚‡ã†ã€‚"

#: ../../howto/regex.rst:51
msgid "Simple Patterns"
msgstr "å˜ç´”ãªãƒ‘ã‚¿ãƒ¼ãƒ³"

#: ../../howto/regex.rst:53
msgid ""
"We'll start by learning about the simplest possible regular expressions.  "
"Since regular expressions are used to operate on strings, we'll begin with "
"the most common task: matching characters."
msgstr ""
"ã¾ãšã¯ã§ãã‚‹ã ã‘ç°¡å˜ãªæ­£è¦è¡¨ç¾ã‚’å­¦ã¶ã“ã¨ã‹ã‚‰å§‹ã‚ã¦ã¿ã¾ã—ã‚‡ã†ã€‚æ­£è¦è¡¨ç¾ã¯æ–‡å­—åˆ—ã®æ“ä½œã«ä½¿ã‚ã‚Œã‚‹ã®ã§ã€ã¾ã™ã¯æœ€ã‚‚ä¸€èˆ¬çš„ãªä½œæ¥­ã§ã‚ã‚‹æ–‡å­—ã®ãƒãƒƒãƒãƒ³ã‚°ã‚’ã—ã¦ã¿ã¾ã™ã€‚"

#: ../../howto/regex.rst:57
msgid ""
"For a detailed explanation of the computer science underlying regular "
"expressions (deterministic and non-deterministic finite automata), you can "
"refer to almost any textbook on writing compilers."
msgstr ""
"æ­£è¦è¡¨ç¾ã®åŸºç¤ã‚’æˆã™è¨ˆç®—æ©Ÿç§‘å­¦ (æ±ºå®šã€éæ±ºå®šæœ‰é™ã‚ªãƒ¼ãƒˆãƒãƒˆãƒ³) ã®è©³ç´°ãªèª¬æ˜ã«ã¤ã„ã¦ã¯, "
"ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ä½œæˆã«é–¢ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆãƒ–ãƒƒã‚¯ã‚’ã©ã‚Œã§ã‚‚ã„ã„ã®ã§å‚ç…§ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../howto/regex.rst:63
msgid "Matching Characters"
msgstr "æ–‡å­—ã®ãƒãƒƒãƒãƒ³ã‚°"

#: ../../howto/regex.rst:65
msgid ""
"Most letters and characters will simply match themselves.  For example, the "
"regular expression ``test`` will match the string ``test`` exactly.  (You "
"can enable a case-insensitive mode that would let this RE match ``Test`` or "
"``TEST`` as well; more about this later.)"
msgstr ""
"å¤šãã®æ´»å­—ã‚„æ–‡å­—ã¯å˜ç´”ã«ãã‚Œè‡ªèº«ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``test`` ã¨ã„ã†æ­£è¦è¡¨ç¾ã¯æ–‡å­—åˆ— ``test`` "
"ã«å³å¯†ã«ãƒãƒƒãƒã—ã¾ã™ã€‚(å¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„ãƒ¢ãƒ¼ãƒ‰ã§ãã®æ­£è¦è¡¨ç¾ãŒ ``Test`` ã‚„ ``TEST`` ã«ã‚‚åŒæ§˜ã«ãƒãƒƒãƒã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™; "
"è©³ã—ãã¯å¾Œè¿°ã—ã¾ã™ã€‚)"

#: ../../howto/regex.rst:70
msgid ""
"There are exceptions to this rule; some characters are special "
":dfn:`metacharacters`, and don't match themselves.  Instead, they signal "
"that some out-of-the-ordinary thing should be matched, or they affect other "
"portions of the RE by repeating them or changing their meaning.  Much of "
"this document is devoted to discussing various metacharacters and what they "
"do."
msgstr ""
"ã“ã®è¦å‰‡ã«ã¯ä¾‹å¤–ãŒå­˜åœ¨ã—ã¾ã™; ã„ãã¤ã‹ã®æ–‡å­—ã¯ç‰¹åˆ¥ãª :dfn:`ç‰¹æ®Šæ–‡å­— (metacharacters)` "
"ã§ã€ãã‚Œã‚‰è‡ªèº«ã«ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«é€šå¸¸ã®ãƒãƒƒãƒã™ã‚‹ã‚‚ã®ã¨ã¯é•ã†ã¨ã„ã†åˆå›³ã‚’å‡ºã—ãŸã‚Šã€æ­£è¦è¡¨ç¾ã®ä¸€éƒ¨ã«å¯¾ã—ã¦ç¹°ã‚Šè¿”ã—ãŸã‚Šã€æ„å‘³ã‚’å¤‰ãˆãŸã‚Šã—ã¦å½±éŸ¿ã‚’ä¸ãˆã¾ã™ã€‚ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ä¸­ã®å¤šãã¯æ§˜ã€…ãªç‰¹æ®Šæ–‡å­—ã¨ãã‚ŒãŒä½•ã‚’ã™ã‚‹ã‹ã«ã¤ã„ã¦è«–ã˜ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/regex.rst:76
msgid ""
"Here's a complete list of the metacharacters; their meanings will be "
"discussed in the rest of this HOWTO."
msgstr "ã“ã“ã«ç‰¹æ®Šæ–‡å­—ã®å®Œå…¨ãªä¸€è¦§ãŒã‚ã‚Šã¾ã™; ã“ã‚Œã‚‰ã®æ„å‘³ã¯ã“ã® HOWTO ã®æ®‹ã‚Šã®éƒ¨åˆ†ã§èª¬æ˜ã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:83
msgid ""
"The first metacharacters we'll look at are ``[`` and ``]``. They're used for"
" specifying a character class, which is a set of characters that you wish to"
" match.  Characters can be listed individually, or a range of characters can"
" be indicated by giving two characters and separating them by a ``'-'``.  "
"For example, ``[abc]`` will match any of the characters ``a``, ``b``, or "
"``c``; this is the same as ``[a-c]``, which uses a range to express the same"
" set of characters.  If you wanted to match only lowercase letters, your RE "
"would be ``[a-z]``."
msgstr ""
"æœ€åˆã«æ‰±ã†ç‰¹æ®Šæ–‡å­—ã¯ ``[`` ã¨ ``]`` "
"ã§ã™ã€‚ã“ã‚Œã‚‰ã¯æ–‡å­—ã‚¯ãƒ©ã‚¹ã‚’æŒ‡å®šã—ã¾ã™ã€æ–‡å­—ã‚¯ãƒ©ã‚¹ã¯ãƒãƒƒãƒã—ãŸã„æ–‡å­—ã®é›†åˆã§ã™ã€‚æ–‡å­—ã¯å€‹åˆ¥ã«ãƒªã‚¹ãƒˆã«ã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã—ã€äºŒã¤ã®æ–‡å­—ã‚’ ``'-'`` "
"ã§ã¤ãªã’ã¦æ–‡å­—ã‚’ç¯„å›²ã§ä¸ãˆã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚ãŸã¨ãˆã° ``[abc]`` ã¯ ``a``, ``b``, ã¾ãŸã¯ ``c`` "
"ã®ã©ã®æ–‡å­—åˆ—ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™; ã“ã‚Œã¯ ``[a-c]`` ã§åŒã˜æ–‡å­—é›†åˆã‚’ç¯„å›²ã§è¡¨ç¾ã—ã¦ã‚‚å…¨ãåŒã˜ã§ã™ã€‚å°æ–‡å­—ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã®ã¿ã«ãƒãƒƒãƒã—ãŸã„å ´åˆã€"
" ``[a-z]`` ã®æ­£è¦è¡¨ç¾ã‚’ã¤ã‹ã†ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../howto/regex.rst:92
msgid ""
"Metacharacters are not active inside classes.  For example, ``[akm$]`` will "
"match any of the characters ``'a'``, ``'k'``, ``'m'``, or ``'$'``; ``'$'`` "
"is usually a metacharacter, but inside a character class it's stripped of "
"its special nature."
msgstr ""
"ç‰¹æ®Šæ–‡å­—ã¯æ–‡å­—ã‚¯ãƒ©ã‚¹ã®å†…éƒ¨ã§ã¯æœ‰åŠ¹ã«ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ ``[akm$]`` ã¯ ``'a'``, ``'k'``, ``'m'`` ã¾ãŸã¯ "
"``'$'`` ã«ãƒãƒƒãƒã—ã¾ã™; ``'$'`` ã¯é€šå¸¸ã¯ç‰¹æ®Šæ–‡å­—ã§ã™ãŒã€æ–‡å­—ã‚¯ãƒ©ã‚¹å†…éƒ¨ã§ã¯ç‰¹æ®Šãªæ€§è³ªã¯å–ã‚Šé™¤ã‹ã‚Œã¾ã™ã€‚"

#: ../../howto/regex.rst:97
msgid ""
"You can match the characters not listed within the class by "
":dfn:`complementing` the set.  This is indicated by including a ``'^'`` as "
"the first character of the class; ``'^'`` outside a character class will "
"simply match the ``'^'`` character.  For example, ``[^5]`` will match any "
"character except ``'5'``."
msgstr ""
"æ–‡å­—ã‚¯ãƒ©ã‚¹å†…ã®ãƒªã‚¹ãƒˆã«ãªã„æ–‡å­—ã«å¯¾ã—ã¦ã‚‚ :dfn:`è£œé›†åˆ` ã‚’ä½¿ã£ã¦ãƒãƒƒãƒã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚è£œé›†åˆã¯ã‚¯ãƒ©ã‚¹ã®æœ€åˆã®æ–‡å­—ã¨ã—ã¦ ``'^'`` "
"ã‚’å«ã‚ã‚‹ã“ã¨ã§è¡¨ã™ã“ã¨ãŒã§ãã¾ã™; æ–‡å­—ã‚¯ãƒ©ã‚¹ã®å¤–å´ã® ``'^'`` ã¯å˜ã« ``'^'`` æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``[^5]`` ã¯ "
"``'5'`` ã‚’é™¤ãä»»æ„ã®æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:102
msgid ""
"Perhaps the most important metacharacter is the backslash, ``\\``.   As in "
"Python string literals, the backslash can be followed by various characters "
"to signal various special sequences.  It's also used to escape all the "
"metacharacters so you can still match them in patterns; for example, if you "
"need to match a ``[`` or  ``\\``, you can precede them with a backslash to "
"remove their special meaning: ``\\[`` or ``\\\\``."
msgstr ""
"ãŠãã‚‰ãæœ€ã‚‚é‡è¦ãªç‰¹æ®Šæ–‡å­—ã¯ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ ``\\`` ã§ã—ã‚‡ã†ã€‚ Python "
"ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã®ã‚ˆã†ã«ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«ç¶šã‘ã¦ã„ã‚ã„ã‚ãªæ–‡å­—ã‚’å…¥åŠ›ã™ã‚‹ã“ã¨ã§ã„ã‚ã„ã‚ãªç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®åˆå›³ã‚’é€ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã¾ãŸã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¯ã™ã¹ã¦ã®ç‰¹æ®Šæ–‡å­—ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹ã®ã«ã‚‚åˆ©ç”¨ã•ã‚Œã¾ã™ã€ã¤ã¾ã‚Šã€ç‰¹æ®Šæ–‡å­—ã‚’ãƒãƒƒãƒã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™;"
" ä¾‹ãˆã°ã€ ``[`` ã¾ãŸã¯ ``\\`` ã«ãƒãƒƒãƒã•ã›ãŸã„å ´åˆã€ãã‚Œã‚‰ã‚’ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«ç¶šã‘ã‚‹ã“ã¨ã§ç‰¹æ®Šãªæ„å‘³ã‚’é™¤ãã¾ã™: ``\\[`` ã¾ãŸã¯"
" ``\\\\`` ã€‚"

#: ../../howto/regex.rst:109
msgid ""
"Some of the special sequences beginning with ``'\\'`` represent predefined "
"sets of characters that are often useful, such as the set of digits, the set"
" of letters, or the set of anything that isn't whitespace."
msgstr "``'\\'`` ã§å§‹ã¾ã‚‹ã„ãã¤ã‹ã®ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€æ•°å­—ã€ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã€ç©ºç™½æ–‡å­—ä»¥å¤–ãªã©ã€ã‚ˆãä½¿ã†æ–‡å­—é›†åˆã‚’è¡¨ã—ã¦ã„ã¾ã™ã€‚"

#: ../../howto/regex.rst:114
msgid ""
"Let's take an example: ``\\w`` matches any alphanumeric character.  If the "
"regex pattern is expressed in bytes, this is equivalent to the class "
"``[a-zA-Z0-9_]``.  If the regex pattern is a string, ``\\w`` will match all "
"the characters marked as letters in the Unicode database provided by the "
":mod:`unicodedata` module.  You can use the more restricted definition of "
"``\\w`` in a string pattern by supplying the :const:`re.ASCII` flag when "
"compiling the regular expression."
msgstr ""
"ä¸€ã¤ä¾‹ã‚’ãŠè¦‹ã›ã—ã¾ã—ã‚‡ã†: ``\\w`` ã¯ä»»æ„ã®è‹±æ•°å­—æ–‡å­—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ãƒã‚¤ãƒˆåˆ—ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾ã—ã¦ã¯ã€ã“ã‚Œã¯æ–‡å­—ã‚¯ãƒ©ã‚¹ "
"``[a-zA-Z0-9_]`` ã¨ç­‰ä¾¡ã§ã™ã€‚ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾ã—ã¦ã¯ã€ ``\\w`` ã¯ :mod:`unicodedata` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§æä¾›ã•ã‚Œã¦ã„ã‚‹ Unicode ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ letters ã¨ã—ã¦ãƒãƒ¼ã‚¯ã•ã‚Œã¦ã„ã‚‹å…¨ã¦ã®æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™ã€‚æ­£è¦è¡¨ç¾ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã« "
":const:`re.ASCII` ãƒ•ãƒ©ã‚°ã‚’ä¸ãˆã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ ``\\w`` ã‚’ã€ã‚ˆã‚Šåˆ¶é™ã•ã‚ŒãŸå®šç¾©ã§ä½¿ã†ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚"

#: ../../howto/regex.rst:122
msgid ""
"The following list of special sequences isn't complete. For a complete list "
"of sequences and expanded class definitions for Unicode string patterns, see"
" the last part of :ref:`Regular Expression Syntax <re-syntax>` in the "
"Standard Library reference.  In general, the Unicode versions match any "
"character that's in the appropriate category in the Unicode database."
msgstr ""
"ä»¥ä¸‹ã«ç¶šãç‰¹åˆ¥ãªæ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã¯å®Œå…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨æ‹¡å¼µã‚¯ãƒ©ã‚¹ã«ã¤ã„ã¦ã®ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®šç¾©ã«ã¤ã„ã¦ã®å®Œå…¨ãªãƒªã‚¹ãƒˆã¯ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã®"
" :ref:`æ­£è¦è¡¨ç¾ã®æ§‹æ–‡ <re-syntax>` "
"ã®æœ€å¾Œã®ãƒ‘ãƒ¼ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ä¸€èˆ¬çš„ã«ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ã€ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã§ç›¸å¿œã—ã„ã‚«ãƒ†ã‚´ãƒªã«å±ã™ã‚Œã°ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:130
msgid "``\\d``"
msgstr "``\\d``"

#: ../../howto/regex.rst:130
msgid "Matches any decimal digit; this is equivalent to the class ``[0-9]``."
msgstr "ä»»æ„ã®åé€²æ•°ã¨ãƒãƒƒãƒã—ã¾ã™; ã“ã‚Œã¯é›†åˆ ``[0-9]`` ã¨åŒã˜æ„å‘³ã§ã™ã€‚"

#: ../../howto/regex.rst:133
msgid "``\\D``"
msgstr "``\\D``"

#: ../../howto/regex.rst:133
msgid ""
"Matches any non-digit character; this is equivalent to the class ``[^0-9]``."
msgstr "ä»»æ„ã®éæ•°å­—æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™; ã“ã‚Œã¯é›†åˆ ``[^0-9]`` ã¨åŒã˜æ„å‘³ã§ã™ã€‚"

#: ../../howto/regex.rst:137
msgid "``\\s``"
msgstr "``\\s``"

#: ../../howto/regex.rst:136
msgid ""
"Matches any whitespace character; this is equivalent to the class ``[ "
"\\t\\n\\r\\f\\v]``."
msgstr "ä»»æ„ã®ç©ºç™½æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™; ã“ã‚Œã¯é›†åˆ ``[ \\t\\n\\r\\f\\v]`` ã¨åŒã˜æ„å‘³ã§ã™ã€‚"

#: ../../howto/regex.rst:141
msgid "``\\S``"
msgstr "``\\S``"

#: ../../howto/regex.rst:140
msgid ""
"Matches any non-whitespace character; this is equivalent to the class ``[^ "
"\\t\\n\\r\\f\\v]``."
msgstr "ä»»æ„ã®éç©ºç™½æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™; ã“ã‚Œã¯é›†åˆ ``[^ \\t\\n\\r\\f\\v]`` ã¨åŒã˜æ„å‘³ã§ã™ã€‚"

#: ../../howto/regex.rst:145
msgid "``\\w``"
msgstr "``\\w``"

#: ../../howto/regex.rst:144
msgid ""
"Matches any alphanumeric character; this is equivalent to the class "
"``[a-zA-Z0-9_]``."
msgstr "ä»»æ„ã®è‹±æ•°æ–‡å­—ãŠã‚ˆã³ä¸‹ç·šã¨ãƒãƒƒãƒã—ã¾ã™; ã“ã‚Œã¯ã€é›†åˆ ``[a-zA-Z0-9_]`` ã¨åŒã˜æ„å‘³ã§ã™ã€‚"

#: ../../howto/regex.rst:149
msgid "``\\W``"
msgstr "``\\W``"

#: ../../howto/regex.rst:148
msgid ""
"Matches any non-alphanumeric character; this is equivalent to the class "
"``[^a-zA-Z0-9_]``."
msgstr "ä»»æ„ã®éè‹±æ•°æ–‡å­—ã¨ãƒãƒƒãƒã—ã¾ã™; ã“ã‚Œã¯é›†åˆ ``[^a-zA-Z0-9_]`` ã¨åŒã˜æ„å‘³ã§ã™ã€‚"

#: ../../howto/regex.rst:151
msgid ""
"These sequences can be included inside a character class.  For example, "
"``[\\s,.]`` is a character class that will match any whitespace character, "
"or ``','`` or ``'.'``."
msgstr ""
"ã“ã‚Œã‚‰ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯æ–‡å­—ã‚¯ãƒ©ã‚¹å†…ã«å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ ``[\\s,.]`` ã¯ç©ºç™½æ–‡å­—ã‚„ ``','`` ã¾ãŸã¯ ``'.'`` "
"ã«ãƒãƒƒãƒã™ã‚‹æ–‡å­—ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../howto/regex.rst:155
msgid ""
"The final metacharacter in this section is ``.``.  It matches anything "
"except a newline character, and there's an alternate mode "
"(:const:`re.DOTALL`) where it will match even a newline.  ``.`` is often "
"used where you want to match \"any character\"."
msgstr ""

#: ../../howto/regex.rst:162
msgid "Repeating Things"
msgstr "ç¹°ã‚Šè¿”ã—"

#: ../../howto/regex.rst:164
msgid ""
"Being able to match varying sets of characters is the first thing regular "
"expressions can do that isn't already possible with the methods available on"
" strings.  However, if that was the only additional capability of regexes, "
"they wouldn't be much of an advance. Another capability is that you can "
"specify that portions of the RE must be repeated a certain number of times."
msgstr ""
"ã•ã¾ã–ã¾ãªæ–‡å­—é›†åˆã‚’ãƒãƒƒãƒã•ã›ã‚‹ã“ã¨ã¯æ­£è¦è¡¨ç¾ã§æœ€åˆã«ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã“ã¨ã§ã€ã“ã‚Œã¯æ–‡å­—åˆ—ã«å¯¾ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ãã«ã§ãã‚‹ã“ã¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã—ã‹ã—ã€æ­£è¦è¡¨ç¾ãŒã‚ˆã‚ŠåŠ›ã‚’ç™ºæ®ã™ã‚‹å ´é¢ãŒã“ã‚Œã ã‘ã ã¨ã™ã‚‹ã¨ã€æ­£è¦è¡¨ç¾ã¯ã‚ã¾ã‚Šå…ˆé€²çš„ã¨ã¯ã„ãˆã¾ã›ã‚“ã€‚æ­£è¦è¡¨ç¾ã®åŠ›ã‚’ã‚‚ã†ä¸€ã¤ã®èƒ½åŠ›ã¯ã€æ­£è¦è¡¨ç¾ã®ä¸€éƒ¨ãŒä½•åº¦ã‚‚ç¹°ã‚Šè¿”ã•ã‚Œã‚‹ã‚ˆã†ã‚‚ã®ã‚’æŒ‡å®šã§ãã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../howto/regex.rst:170
msgid ""
"The first metacharacter for repeating things that we'll look at is ``*``.  "
"``*`` doesn't match the literal character ``'*'``; instead, it specifies "
"that the previous character can be matched zero or more times, instead of "
"exactly once."
msgstr ""

#: ../../howto/regex.rst:174
msgid ""
"For example, ``ca*t`` will match ``'ct'`` (0 ``'a'`` characters), ``'cat'`` "
"(1 ``'a'``), ``'caaat'`` (3 ``'a'`` characters), and so forth."
msgstr ""
"ä¾‹ãˆã°ã€ ``ca*t`` ã¯ ``'ct'`` ( ``'a'`` ã¨ã„ã†æ–‡å­—ãŒ 0 å€‹ã®å ´åˆ)ã€ ``'cat'`` (``'a'`` "
"ãŒ1å€‹ã®å ´åˆ)ã€ ``'caaat'`` (``'a'`` ãŒ3å€‹ã®å ´åˆ)ã€ãªã©ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:177
msgid ""
"Repetitions such as ``*`` are :dfn:`greedy`; when repeating a RE, the "
"matching engine will try to repeat it as many times as possible. If later "
"portions of the pattern don't match, the matching engine will then back up "
"and try again with fewer repetitions."
msgstr ""
"``*`` ã®ã‚ˆã†ãªç¹°ã‚Šè¿”ã—ã¯ :dfn:`è²ªæ¬² (greedy)` ã§ã™; "
"æ­£è¦è¡¨ç¾ã‚’ç¹°ã‚Šè¿”ã—ãŸã„ã¨ãã€ãƒãƒƒãƒãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³ã¯å¯èƒ½ãªé™ã‚Šä½•åº¦ã‚‚ç¹°ã‚Šè¿”ãã†ã¨è©¦ã¿ã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å¾Œã‚ã®éƒ¨åˆ†ã«ãƒãƒƒãƒã—ãªã„å ´åˆã€ãƒãƒƒãƒãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³ã¯æˆ»ã£ã¦ã‚ˆã‚Šå°‘ãªã„ç¹°ã‚Šè¿”ã—ã‚’å†ã³è©¦ã¿ã¾ã™ã€‚"

#: ../../howto/regex.rst:182
msgid ""
"A step-by-step example will make this more obvious.  Let's consider the "
"expression ``a[bcd]*b``.  This matches the letter ``'a'``, zero or more "
"letters from the class ``[bcd]``, and finally ends with a ``'b'``.  Now "
"imagine matching this RE against the string ``'abcbd'``."
msgstr ""

#: ../../howto/regex.rst:188
msgid "Step"
msgstr "ã‚¹ãƒ†ãƒƒãƒ—"

#: ../../howto/regex.rst:188
msgid "Matched"
msgstr "ãƒãƒƒãƒã—ãŸæ–‡å­—åˆ—"

#: ../../howto/regex.rst:188
msgid "Explanation"
msgstr "èª¬æ˜"

#: ../../howto/regex.rst:190
msgid "1"
msgstr "1"

#: ../../howto/regex.rst:190
msgid "``a``"
msgstr "``a``"

#: ../../howto/regex.rst:190
msgid "The ``a`` in the RE matches."
msgstr "``a`` ãŒæ­£è¦è¡¨ç¾ã«ãƒãƒƒãƒã€‚"

#: ../../howto/regex.rst:192
msgid "2"
msgstr "2"

#: ../../howto/regex.rst:192
msgid "``abcbd``"
msgstr "``abcbd``"

#: ../../howto/regex.rst:192
msgid ""
"The engine matches ``[bcd]*``, going as far as it can, which is to the end "
"of the string."
msgstr "æ­£è¦è¡¨ç¾ã‚¨ãƒ³ã‚¸ãƒ³ãŒ ``[bcd]*`` ã§æ–‡å­—åˆ—ã®æœ€å¾Œã¾ã§å¯èƒ½ãªé™ã‚Šé€²ã‚€ã€‚"

#: ../../howto/regex.rst:196
msgid "3"
msgstr "3"

#: ../../howto/regex.rst:196 ../../howto/regex.rst:204
msgid "*Failure*"
msgstr "*å¤±æ•—*"

#: ../../howto/regex.rst:196
msgid ""
"The engine tries to match ``b``, but the current position is at the end of "
"the string, so it fails."
msgstr "ã‚¨ãƒ³ã‚¸ãƒ³ãŒ ``b`` ã¨ã®ãƒãƒƒãƒã‚’è©¦ã¿ã‚‹ãŒã€ç¾åœ¨ã®ä½ç½®ãŒæ–‡å­—åˆ—ã®æœ€å¾Œãªã®ã§ã€å¤±æ•—ã™ã‚‹ã€‚"

#: ../../howto/regex.rst:201
msgid "4"
msgstr "4"

#: ../../howto/regex.rst:201 ../../howto/regex.rst:212
msgid "``abcb``"
msgstr "``abcb``"

#: ../../howto/regex.rst:201
msgid "Back up, so that  ``[bcd]*`` matches one less character."
msgstr "æˆ»ã£ã¦ ``[bcd]*`` ã¯ä¸€æ–‡å­—å°‘ãªããƒãƒƒãƒã€‚"

#: ../../howto/regex.rst:204
msgid "5"
msgstr "5"

#: ../../howto/regex.rst:204
msgid ""
"Try ``b`` again, but the current position is at the last character, which is"
" a ``'d'``."
msgstr "å†ã³ ``b`` ã¸ã®ãƒãƒƒãƒã‚’è©¦ã¿ã‚‹ãŒã€ç¾åœ¨ã®æ–‡å­—ã¯æœ€å¾Œã®æ–‡å­— ``'d'`` ã€‚"

#: ../../howto/regex.rst:208 ../../howto/regex.rst:212
msgid "6"
msgstr "6"

#: ../../howto/regex.rst:208
msgid "``abc``"
msgstr "``abc``"

#: ../../howto/regex.rst:208
msgid "Back up again, so that ``[bcd]*`` is only matching ``bc``."
msgstr "å†ã³æˆ»ã‚‹, ``[bcd]*`` ã¯ ``bc`` ã®ã¿ã«ãƒãƒƒãƒã€‚"

#: ../../howto/regex.rst:212
msgid ""
"Try ``b`` again.  This time the character at the current position is "
"``'b'``, so it succeeds."
msgstr "å†ã³ ``b`` ã‚’è©¦ã¿ã‚‹ã€‚ä»Šå›ã®ç¾åœ¨ä½ç½®ã®æ–‡å­—ã¯ ``'b'`` ãªã®ã§æˆåŠŸã€‚"

#: ../../howto/regex.rst:218
msgid ""
"The end of the RE has now been reached, and it has matched ``'abcb'``.  This"
" demonstrates how the matching engine goes as far as it can at first, and if"
" no match is found it will then progressively back up and retry the rest of "
"the RE again and again.  It will back up until it has tried zero matches for"
" ``[bcd]*``, and if that subsequently fails, the engine will conclude that "
"the string doesn't match the RE at all."
msgstr ""

#: ../../howto/regex.rst:225
msgid ""
"Another repeating metacharacter is ``+``, which matches one or more times.  "
"Pay careful attention to the difference between ``*`` and ``+``; ``*`` "
"matches *zero* or more times, so whatever's being repeated may not be "
"present at all, while ``+`` requires at least *one* occurrence.  To use a "
"similar example, ``ca+t`` will match ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 "
"``'a'``\\ s), but won't match ``'ct'``."
msgstr ""

#: ../../howto/regex.rst:232
msgid ""
"There are two more repeating qualifiers.  The question mark character, "
"``?``, matches either once or zero times; you can think of it as marking "
"something as being optional.  For example, ``home-?brew`` matches either "
"``'homebrew'`` or ``'home-brew'``."
msgstr ""

#: ../../howto/regex.rst:237
msgid ""
"The most complicated repeated qualifier is ``{m,n}``, where *m* and *n* are "
"decimal integers.  This qualifier means there must be at least *m* "
"repetitions, and at most *n*.  For example, ``a/{1,3}b`` will match "
"``'a/b'``, ``'a//b'``, and ``'a///b'``.  It won't match ``'ab'``, which has "
"no slashes, or ``'a////b'``, which has four."
msgstr ""

#: ../../howto/regex.rst:243
msgid ""
"You can omit either *m* or *n*; in that case, a reasonable value is assumed "
"for the missing value.  Omitting *m* is interpreted as a lower limit of 0, "
"while omitting *n* results in an upper bound of infinity."
msgstr ""

#: ../../howto/regex.rst:247
msgid ""
"Readers of a reductionist bent may notice that the three other qualifiers "
"can all be expressed using this notation.  ``{0,}`` is the same as ``*``, "
"``{1,}`` is equivalent to ``+``, and ``{0,1}`` is the same as ``?``.  It's "
"better to use ``*``, ``+``, or ``?`` when you can, simply because they're "
"shorter and easier to read."
msgstr ""
"é‚„å…ƒä¸»ç¾©çš„ç´ é¤Šã®ã‚ã‚‹èª­è€…ã¯ã€3ã¤ã®ä¿®é£¾å­ãŒã“ã®è¡¨è¨˜ã§è¡¨ç¾ã§ãã‚‹ã“ã¨ã«æ°—ã¥ãã§ã—ã‚‡ã†ã€‚ ``{0,}`` ã¯ ``*`` ã¨åŒã˜ã§ ``{1,}`` ã¯ "
"``+`` ã¨ã€ãã—ã¦ ``{0,1}`` ã¯ ``?`` ã¨åŒã˜ã§ã™ã€‚åˆ©ç”¨ã§ãã‚‹å ´åˆã«ã¯ ``*``, ``+`` ã¾ãŸã¯ ``?`` "
"ã‚’åˆ©ç”¨ã—ãŸæ–¹ãŒè³¢æ˜ã§ã™ã€ãã†ã™ã‚‹ã“ã¨ã§å˜ç´”ã«ã€çŸ­ãèª­ã¿æ˜“ãã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../howto/regex.rst:255
msgid "Using Regular Expressions"
msgstr "æ­£è¦è¡¨ç¾ã‚’ä½¿ã†"

#: ../../howto/regex.rst:257
msgid ""
"Now that we've looked at some simple regular expressions, how do we actually"
" use them in Python?  The :mod:`re` module provides an interface to the "
"regular expression engine, allowing you to compile REs into objects and then"
" perform matches with them."
msgstr ""
"ã“ã‚Œã¾ã§ã§ã„ãã¤ã‹ã®å˜ç´”ãªæ­£è¦è¡¨ç¾ã«è§¦ã‚Œã¦ãã¾ã—ãŸã€å®Ÿéš›ã« Python ã§ã¯ã“ã‚Œã‚‰ã‚’ã©ã†ä½¿ãˆã°ã„ã„ã®ã§ã—ã‚‡ã†? :mod:`re` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯æ­£è¦è¡¨ç¾ã‚¨ãƒ³ã‚¸ãƒ³ã«å¯¾ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¦ã„ã¦ã€ãã‚Œã‚‰ã‚’ä½¿ã†ã“ã¨ã§æ­£è¦è¡¨ç¾ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã€ãƒãƒƒãƒã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../howto/regex.rst:264
msgid "Compiling Regular Expressions"
msgstr "æ­£è¦è¡¨ç¾ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹"

#: ../../howto/regex.rst:266
msgid ""
"Regular expressions are compiled into pattern objects, which have methods "
"for various operations such as searching for pattern matches or performing "
"string substitutions. ::"
msgstr ""
"æ­£è¦è¡¨ç¾ã¯ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã™ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤šãã®æ“ä½œã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã®æ¤œç´¢ã‚„æ–‡å­—åˆ—ã®ç½®æ›ã®å®Ÿè¡Œãªã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã™ã€‚"
" ::"

#: ../../howto/regex.rst:275
msgid ""
":func:`re.compile` also accepts an optional *flags* argument, used to enable"
" various special features and syntax variations.  We'll go over the "
"available settings later, but for now a single example will do::"
msgstr ""
":func:`re.compile` ã¯ã„ãã¤ã‹ã® *flags* "
"å¼•æ•°ã‚’å—ã‘ä»˜ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€ã“ã®å¼•æ•°ã¯ã•ã¾ã–ã¾ãªç‰¹åˆ¥ãªæ©Ÿèƒ½ã‚’æœ‰åŠ¹ã«ã—ãŸã‚Šã€æ§‹æ–‡ã‚’å¤‰åŒ–ã•ã›ãŸã‚Šã—ã¾ã™ã€‚åˆ©ç”¨ã§ãã‚‹è¨­å®šã«ä½•ãŒã‚ã‚‹ã‹ã¯å¾Œã«é£›ã°ã™ã“ã¨ã«ã—ã¦ã€ç°¡å˜ãªä¾‹ã‚’ã‚„ã‚‹ã“ã¨ã«ã—ã¾ã—ã‚‡ã†::"

#: ../../howto/regex.rst:281
msgid ""
"The RE is passed to :func:`re.compile` as a string.  REs are handled as "
"strings because regular expressions aren't part of the core Python language,"
" and no special syntax was created for expressing them.  (There are "
"applications that don't need REs at all, so there's no need to bloat the "
"language specification by including them.) Instead, the :mod:`re` module is "
"simply a C extension module included with Python, just like the "
":mod:`socket` or :mod:`zlib` modules."
msgstr ""
"æ­£è¦è¡¨ç¾ã¯æ–‡å­—åˆ—ã¨ã—ã¦ :func:`re.compile` ã«æ¸¡ã•ã‚Œã¾ã™ã€‚æ­£è¦è¡¨ç¾ã¯æ–‡å­—åˆ—ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ãŒã€ãã‚Œã¯æ­£è¦è¡¨ç¾ãŒ Python "
"è¨€èªã®ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã«å«ã¾ã‚Œãªã„ãŸã‚ã§ã™ã€ãã®ãŸã‚æ­£è¦è¡¨ç¾ã‚’è¡¨ã‚ã™ç‰¹æ®Šãªæ§‹æ–‡ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ "
"(æ­£è¦è¡¨ç¾ã‚’å…¨ãå¿…è¦ã¨ã—ãªã„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚‚å­˜åœ¨ã—ã¾ã™ã€ãã®ãŸã‚ãã‚Œã‚‰ã‚’å«ã‚ã¦è¨€èªä»•æ§˜ã‚’ç„¡é§„ã«å¤§ããã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“) ãã®ä»£ã‚ã‚Šã€ "
":mod:`re` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :mod:`socket` ã‚„ :mod:`zlib` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚ˆã†ãªé€šå¸¸ã® C æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã—ã¦ "
"Python ã«å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../howto/regex.rst:288
msgid ""
"Putting REs in strings keeps the Python language simpler, but has one "
"disadvantage which is the topic of the next section."
msgstr ""
"æ­£è¦è¡¨ç¾ã‚’æ–‡å­—åˆ—ã¨ã—ã¦ãŠãã“ã¨ã§ Python è¨€èªã¯ã‚ˆã‚Šç°¡ç´ ã«ä¿ãŸã‚Œã¦ã„ã¾ã™ãŒã€ãã®ãŸã‚1ã¤ã®æ¬ ç‚¹ãŒã‚ã‚Šã¾ã™ã€ã“ã‚Œã«ã¤ã„ã¦ã¯æ¬¡ã®ç¯€ã§è©±é¡Œã¨ã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:295
msgid "The Backslash Plague"
msgstr "ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥æ„ŸæŸ“ç—‡"

#: ../../howto/regex.rst:297
msgid ""
"As stated earlier, regular expressions use the backslash character "
"(``'\\'``) to indicate special forms or to allow special characters to be "
"used without invoking their special meaning. This conflicts with Python's "
"usage of the same character for the same purpose in string literals."
msgstr ""
"å…ˆã«è¿°ã¹ãŸã‚ˆã†ã«ã€æ­£è¦è¡¨ç¾ã¯ç‰¹åˆ¥ãªå½¢å¼ã‚„ç‰¹æ®Šãªæ–‡å­—ã®ç‰¹åˆ¥ãªæ„å‘³ã‚’æ„å‘³ã‚’é™¤ãã“ã¨ã‚’ç¤ºã™ãŸã‚ã«ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥æ–‡å­— (``'\\'``) "
"ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚ã“ã‚Œã¯ Python ãŒæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«å¯¾ã—ã¦ã€åŒã˜æ–‡å­—ã‚’åŒã˜ç›®çš„ã§ä½¿ã†ã“ã¨ã¨è¡çªã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:302
msgid ""
"Let's say you want to write a RE that matches the string ``\\section``, "
"which might be found in a LaTeX file.  To figure out what to write in the "
"program code, start with the desired string to be matched.  Next, you must "
"escape any backslashes and other metacharacters by preceding them with a "
"backslash, resulting in the string ``\\\\section``.  The resulting string "
"that must be passed to :func:`re.compile` must be ``\\\\section``.  However,"
" to express this as a Python string literal, both backslashes must be "
"escaped *again*."
msgstr ""
"``\\section`` ã¨ã„ã†æ–‡å­—åˆ— (ã“ã‚Œã¯ LaTeX ãƒ•ã‚¡ã‚¤ãƒ«ã§ã¿ã‹ã‘ã¾ã™) "
"ã«ãƒãƒƒãƒã™ã‚‹æ­£è¦è¡¨ç¾ã‚’æ›¸ããŸã„ã¨ã—ã¾ã™ã€‚ã©ã‚“ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãã‹è€ƒãˆã€ãƒãƒƒãƒã—ã¦æ¬²ã—ã„æ–‡å­—åˆ—ã‚’ã¯ã˜ã‚ã«è€ƒãˆã¾ã™ã€‚æ¬¡ã«ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚„ä»–ã®ç‰¹æ®Šæ–‡å­—ã‚’ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«ç¶šã‘ã¦æ›¸ãã“ã¨ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã—ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€ãã®çµæœ"
" ``\\\\section`` ã®ã‚ˆã†ãªæ–‡å­—åˆ—ã¨ãªã‚Šã¾ã™ã€‚ã“ã†ã—ã¦ã§ããŸ :func:`re.compile` ã«æ¸¡ã™æ–‡å­—åˆ—ã¯ "
"``\\\\section`` ã§ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ã“ã‚Œã‚’ Python ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¨ã—ã¦æ‰±ã†ã«ã¯ã“ã®äºŒã¤ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ *å†ã³*"
" ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/regex.rst:311
msgid "Characters"
msgstr "æ–‡å­—"

#: ../../howto/regex.rst:311
msgid "Stage"
msgstr "æ®µéš"

#: ../../howto/regex.rst:313
msgid "``\\section``"
msgstr "``\\section``"

#: ../../howto/regex.rst:313
msgid "Text string to be matched"
msgstr "ãƒãƒƒãƒã•ã›ã‚‹ãƒ†ã‚­ã‚¹ãƒˆ"

#: ../../howto/regex.rst:315
msgid "``\\\\section``"
msgstr "``\\\\section``"

#: ../../howto/regex.rst:315
msgid "Escaped backslash for :func:`re.compile`"
msgstr ":func:`re.compile` ã®ãŸã‚ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—"

#: ../../howto/regex.rst:317 ../../howto/regex.rst:344
msgid "``\"\\\\\\\\section\"``"
msgstr "``\"\\\\\\\\section\"``"

#: ../../howto/regex.rst:317
msgid "Escaped backslashes for a string literal"
msgstr "æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã®ãŸã‚ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—"

#: ../../howto/regex.rst:320
msgid ""
"In short, to match a literal backslash, one has to write ``'\\\\\\\\'`` as "
"the RE string, because the regular expression must be ``\\\\``, and each "
"backslash must be expressed as ``\\\\`` inside a regular Python string "
"literal.  In REs that feature backslashes repeatedly, this leads to lots of "
"repeated backslashes and makes the resulting strings difficult to "
"understand."
msgstr ""
"è¦ç‚¹ã ã‘ã‚’ã„ãˆã°ã€ãƒªãƒ†ãƒ©ãƒ«ã¨ã—ã¦ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«ãƒãƒƒãƒã•ã›ã‚‹ãŸã‚ã«ã€æ­£è¦è¡¨ç¾æ–‡å­—åˆ—ã¨ã—ã¦ ``'\\\\\\\\'`` "
"æ›¸ã‹ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€ãªãœãªã‚‰æ­£è¦è¡¨ç¾ã¯ ``\\\\`` ã§ã‚ã‚Šã€é€šå¸¸ã® Python ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¨ã—ã¦ã¯ãã‚Œãã‚Œã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¯ "
"``\\\\`` "
"ã§è¡¨ç¾ã—ãªã‘ã‚Œã°ã„ã‘ãªã„ã‹ã‚‰ã§ã™ã€‚æ­£è¦è¡¨ç¾ã«é–¢ã—ã¦ã“ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã®ç¹°ã‚Šè¿”ã—ã®æ©Ÿèƒ½ã¯ã€ãŸãã•ã‚“ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã®ç¹°ã‚Šè¿”ã—ã‚’ç”Ÿã‚€ã“ã¨ã«ãªã‚Šã€ãã®çµæœã¨ã—ã¦ä½œã‚‰ã‚Œã‚‹æ–‡å­—åˆ—ã¯ç†è§£ã™ã‚‹ã“ã¨ãŒé›£ã—ããªã‚Šã¾ã™ã€‚"

#: ../../howto/regex.rst:326
msgid ""
"The solution is to use Python's raw string notation for regular expressions;"
" backslashes are not handled in any special way in a string literal prefixed"
" with ``'r'``, so ``r\"\\n\"`` is a two-character string containing ``'\\'``"
" and ``'n'``, while ``\"\\n\"`` is a one-character string containing a "
"newline. Regular expressions will often be written in Python code using this"
" raw string notation."
msgstr ""
"ã“ã®å•é¡Œã®è§£æ±ºç­–ã¨ã—ã¦ã¯æ­£è¦è¡¨ç¾ã«å¯¾ã—ã¦ã¯ Python ã® raw string è¨˜æ³•ã‚’ä½¿ã†ã“ã¨ã§ã™; ``'r'`` "
"ã‚’æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã®å…ˆé ­ã«æ›¸ãã“ã¨ã§ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¯ç‰¹åˆ¥æ‰±ã„ã•ã‚Œãªããªã‚Šã¾ã™ã€ã¤ã¾ã‚Š ``\"\\n\"`` "
"ã¯æ”¹è¡Œã‚’å«ã‚€1ã¤ã®æ–‡å­—ã‹ã‚‰ãªã‚‹æ–‡å­—åˆ—ã§ã‚ã‚‹ã®ã«å¯¾ã—ã¦ã€ ``r\"\\n\"`` ã¯2ã¤ã®æ–‡å­— ``'\\'`` ã¨ ``'n'`` "
"ã‚’å«ã‚€æ–‡å­—åˆ—ã¨ãªã‚Šã¾ã™ã€‚å¤šãã®å ´åˆ Python ã‚³ãƒ¼ãƒ‰ã®ä¸­ã®æ­£è¦è¡¨ç¾ã¯ã“ã® raw string è¨˜æ³•ã‚’ä½¿ã£ã¦æ›¸ã‹ã‚Œã¾ã™ã€‚"

#: ../../howto/regex.rst:332
msgid ""
"In addition, special escape sequences that are valid in regular expressions,"
" but not valid as Python string literals, now result in a "
":exc:`DeprecationWarning` and will eventually become a :exc:`SyntaxError`, "
"which means the sequences will be invalid if raw string notation or escaping"
" the backslashes isn't used."
msgstr ""

#: ../../howto/regex.rst:340
msgid "Regular String"
msgstr "é€šå¸¸ã®æ–‡å­—åˆ—"

#: ../../howto/regex.rst:340
msgid "Raw string"
msgstr "Raw string"

#: ../../howto/regex.rst:342
msgid "``\"ab*\"``"
msgstr "``\"ab*\"``"

#: ../../howto/regex.rst:342
msgid "``r\"ab*\"``"
msgstr "``r\"ab*\"``"

#: ../../howto/regex.rst:344
msgid "``r\"\\\\section\"``"
msgstr "``r\"\\\\section\"``"

#: ../../howto/regex.rst:346
msgid "``\"\\\\w+\\\\s+\\\\1\"``"
msgstr "``\"\\\\w+\\\\s+\\\\1\"``"

#: ../../howto/regex.rst:346
msgid "``r\"\\w+\\s+\\1\"``"
msgstr "``r\"\\w+\\s+\\1\"``"

#: ../../howto/regex.rst:351
msgid "Performing Matches"
msgstr "ãƒãƒƒãƒã®å®Ÿè¡Œ"

#: ../../howto/regex.rst:353
msgid ""
"Once you have an object representing a compiled regular expression, what do "
"you do with it?  Pattern objects have several methods and attributes. Only "
"the most significant ones will be covered here; consult the :mod:`re` docs "
"for a complete listing."
msgstr ""
"ä¸€æ—¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸæ­£è¦è¡¨ç¾ã‚’è¡¨ç¾ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ãŸã‚‰ã€æ¬¡ã«ä½•ã‚’ã—ã¾ã™ã‹? "
"ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã„ãã¤ã‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚„å±æ€§ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã“ã“ã§ã¯ã€ãã®ä¸­ã§ã‚‚æœ€ã‚‚é‡è¦ãªã‚‚ã®ã«ã¤ã„ã¦æ‰±ã„ã¾ã™; å®Œå…¨ãªãƒªã‚¹ãƒˆã¯ :mod:`re` "
"ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../howto/regex.rst:359 ../../howto/regex.rst:417
#: ../../howto/regex.rst:1056
msgid "Method/Attribute"
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰/å±æ€§"

#: ../../howto/regex.rst:359 ../../howto/regex.rst:417
#: ../../howto/regex.rst:1056
msgid "Purpose"
msgstr "ç›®çš„"

#: ../../howto/regex.rst:361
msgid "``match()``"
msgstr "``match()``"

#: ../../howto/regex.rst:361
msgid "Determine if the RE matches at the beginning of the string."
msgstr "æ–‡å­—åˆ—ã®å…ˆé ­ã§æ­£è¦è¡¨ç¾ã¨ãƒãƒƒãƒã™ã‚‹ã‹åˆ¤å®šã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:364
msgid "``search()``"
msgstr "``search()``"

#: ../../howto/regex.rst:364
msgid "Scan through a string, looking for any location where this RE matches."
msgstr "æ–‡å­—åˆ—ã‚’æ“ä½œã—ã¦ã€æ­£è¦è¡¨ç¾ãŒã©ã“ã«ãƒãƒƒãƒã™ã‚‹ã‹èª¿ã¹ã¾ã™ã€‚"

#: ../../howto/regex.rst:367
msgid "``findall()``"
msgstr "``findall()``"

#: ../../howto/regex.rst:367
msgid "Find all substrings where the RE matches, and returns them as a list."
msgstr "æ­£è¦è¡¨ç¾ã«ãƒãƒƒãƒã™ã‚‹éƒ¨åˆ†æ–‡å­—åˆ—ã‚’å…¨ã¦æ¢ã—ã ã—ãƒªã‚¹ãƒˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:370
msgid "``finditer()``"
msgstr "``finditer()``"

#: ../../howto/regex.rst:370
msgid ""
"Find all substrings where the RE matches, and returns them as an "
":term:`iterator`."
msgstr "æ­£è¦è¡¨ç¾ã«ãƒãƒƒãƒã™ã‚‹éƒ¨åˆ†æ–‡å­—åˆ—ã‚’å…¨ã¦æ¢ã—ã ã— :term:`iterator` ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:374
msgid ""
":meth:`~re.Pattern.match` and :meth:`~re.Pattern.search` return ``None`` if "
"no match can be found.  If they're successful, a :ref:`match object <match-"
"objects>` instance is returned, containing information about the match: "
"where it starts and ends, the substring it matched, and more."
msgstr ""

#: ../../howto/regex.rst:379
msgid ""
"You can learn about this by interactively experimenting with the :mod:`re` "
"module.  If you have :mod:`tkinter` available, you may also want to look at "
":source:`Tools/demo/redemo.py`, a demonstration program included with the "
"Python distribution.  It allows you to enter REs and strings, and displays "
"whether the RE matches or fails. :file:`redemo.py` can be quite useful when "
"trying to debug a complicated RE."
msgstr ""
":mod:`re` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å¯¾è©±çš„ã«å®Ÿé¨“ã™ã‚‹ã“ã¨ã§å­¦ã¶ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ :mod:`tkinter` ãŒåˆ©ç”¨ã§ãã‚Œã°ã€Python "
"ã«å«ã¾ã‚Œã‚‹ãƒ‡ãƒ¢ãƒ—ãƒ­ã‚°ãƒ©ãƒ  :source:`Tools/demo/redemo.py` "
"ã‚’è¦‹ã‚‹ã¨ã„ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã®ãƒ‡ãƒ¢ã¯æ­£è¦è¡¨ç¾ã¨æ–‡å­—åˆ—ã‚’å…¥åŠ›ã—ã€æ­£è¦è¡¨ç¾ãŒãƒãƒƒãƒã—ãŸã‹ã©ã†ã‹ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚ :file:`redemo.py` "
"ã¯è¤‡é›‘ãªæ­£è¦è¡¨ç¾ã®ãƒ‡ãƒãƒƒã‚°ã‚’è©¦ã¿ã‚‹ã¨ãã«ã‚‚ä¾¿åˆ©ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../howto/regex.rst:386
msgid ""
"This HOWTO uses the standard Python interpreter for its examples. First, run"
" the Python interpreter, import the :mod:`re` module, and compile a RE::"
msgstr ""
"ã“ã® HOWTO ã§ã¯ä¾‹ã¨ã—ã¦æ¨™æº–ã® Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ä½¿ã„ã¾ã™ã€‚æœ€åˆã« Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’èµ·å‹•ã—ã¦ã€ :mod:`re` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã€æ­£è¦è¡¨ç¾ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¾ã™::"

#: ../../howto/regex.rst:394
msgid ""
"Now, you can try matching various strings against the RE ``[a-z]+``.  An "
"empty string shouldn't match at all, since ``+`` means 'one or more "
"repetitions'. :meth:`~re.Pattern.match` should return ``None`` in this case,"
" which will cause the interpreter to print no output.  You can explicitly "
"print the result of :meth:`!match` to make this clear. ::"
msgstr ""

#: ../../howto/regex.rst:404
msgid ""
"Now, let's try it on a string that it should match, such as ``tempo``.  In "
"this case, :meth:`~re.Pattern.match` will return a :ref:`match object "
"<match-objects>`, so you should store the result in a variable for later "
"use. ::"
msgstr ""

#: ../../howto/regex.rst:412
msgid ""
"Now you can query the :ref:`match object <match-objects>` for information "
"about the matching string.  Match object instances also have several methods"
" and attributes; the most important ones are:"
msgstr ""

#: ../../howto/regex.rst:419
msgid "``group()``"
msgstr "``group()``"

#: ../../howto/regex.rst:419
msgid "Return the string matched by the RE"
msgstr "æ­£è¦è¡¨ç¾ã«ãƒãƒƒãƒã—ãŸæ–‡å­—åˆ—ã‚’è¿”ã™"

#: ../../howto/regex.rst:421
msgid "``start()``"
msgstr "``start()``"

#: ../../howto/regex.rst:421
msgid "Return the starting position of the match"
msgstr "ãƒãƒƒãƒã®é–‹å§‹ä½ç½®ã‚’è¿”ã™"

#: ../../howto/regex.rst:423
msgid "``end()``"
msgstr "``end()``"

#: ../../howto/regex.rst:423
msgid "Return the ending position of the match"
msgstr "ãƒãƒƒãƒã®çµ‚äº†ä½ç½®ã‚’è¿”ã™"

#: ../../howto/regex.rst:425
msgid "``span()``"
msgstr "``span()``"

#: ../../howto/regex.rst:425
msgid "Return a tuple containing the (start, end) positions  of the match"
msgstr "ãƒãƒƒãƒã®ä½ç½® (start, end) ã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã‚’è¿”ã™"

#: ../../howto/regex.rst:429
msgid "Trying these methods will soon clarify their meaning::"
msgstr "ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è©¦ã›ã°ã€ãã®æ„å‘³ã¯ã™ãã«ç†è§£ã§ãã¾ã™::"

#: ../../howto/regex.rst:438
msgid ""
":meth:`~re.Match.group` returns the substring that was matched by the RE.  "
":meth:`~re.Match.start` and :meth:`~re.Match.end` return the starting and "
"ending index of the match. :meth:`~re.Match.span` returns both start and end"
" indexes in a single tuple.  Since the :meth:`~re.Pattern.match` method only"
" checks if the RE matches at the start of a string, :meth:`!start` will "
"always be zero.  However, the :meth:`~re.Pattern.search` method of patterns "
"scans through the string, so  the match may not start at zero in that case. "
"::"
msgstr ""

#: ../../howto/regex.rst:455
msgid ""
"In actual programs, the most common style is to store the :ref:`match object"
" <match-objects>` in a variable, and then check if it was ``None``.  This "
"usually looks like::"
msgstr ""
"å®Ÿéš›ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ :ref:`Match ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-objects>` ã‚’å¤‰æ•°ã«è¨˜æ†¶ã—ã¦ãŠã, ãã®æ¬¡ã« ``None`` "
"ãªã®ã‹èª¿ã¹ã‚‹ã®ãŒä¸€èˆ¬çš„ãªã‚¹ã‚¿ã‚¤ãƒ«ã§ã™ã€‚æ™®é€šã“ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../howto/regex.rst:466
msgid ""
"Two pattern methods return all of the matches for a pattern. "
":meth:`~re.Pattern.findall` returns a list of matching strings::"
msgstr ""

#: ../../howto/regex.rst:473
msgid ""
"The ``r`` prefix, making the literal a raw string literal, is needed in this"
" example because escape sequences in a normal \"cooked\" string literal that"
" are not recognized by Python, as opposed to regular expressions, now result"
" in a :exc:`DeprecationWarning` and will eventually become a "
":exc:`SyntaxError`.  See :ref:`the-backslash-plague`."
msgstr ""

#: ../../howto/regex.rst:479
msgid ""
":meth:`~re.Pattern.findall` has to create the entire list before it can be "
"returned as the result.  The :meth:`~re.Pattern.finditer` method returns a "
"sequence of :ref:`match object <match-objects>` instances as an "
":term:`iterator`::"
msgstr ""

#: ../../howto/regex.rst:495
msgid "Module-Level Functions"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®é–¢æ•°"

#: ../../howto/regex.rst:497
msgid ""
"You don't have to create a pattern object and call its methods; the "
":mod:`re` module also provides top-level functions called :func:`~re.match`,"
" :func:`~re.search`, :func:`~re.findall`, :func:`~re.sub`, and so forth.  "
"These functions take the same arguments as the corresponding pattern method "
"with the RE string added as the first argument, and still return either "
"``None`` or a :ref:`match object <match-objects>` instance. ::"
msgstr ""
"ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã£ã¦ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã€ã¨ã™ã‚‹å¿…è¦ã¯å¿…ãšã—ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚ :mod:`re` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®é–¢æ•°ã¨ã—ã¦ "
":func:`~re.match`, :func:`~re.search`, :func:`~re.findall`, :func:`~re.sub` "
"ãªã©ã‚’ç”¨æ„ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰é–¢æ•°ã¯ã€å¯¾å¿œã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã®æœ€åˆã®å¼•æ•°ã« RE ãŒè¿½åŠ ã•ã‚ŒãŸã ã‘ã§å¾Œã¯åŒã˜ã§ã€ ``None`` ã‹ :ref:`Match "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-objects>` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™ã®ã‚‚åŒã˜ã§ã™::"

#: ../../howto/regex.rst:509
msgid ""
"Under the hood, these functions simply create a pattern object for you and "
"call the appropriate method on it.  They also store the compiled object in a"
" cache, so future calls using the same RE won't need to parse the pattern "
"again and again."
msgstr ""
"å†…éƒ¨çš„ã«ã¯ã€ã“ã‚Œã‚‰é–¢æ•°ã¯å˜ã«ã‚ãªãŸã®ãŸã‚ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã€å¯¾å¿œã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã ã‘ã®ã“ã¨ã§ã™ã€‚ã¨ã¨ã‚‚ã«ã€å°†æ¥ã®å‘¼ã³å‡ºã—ã§åŒã˜ RE "
"ã®ãƒ‘ãƒ¼ã‚¹ãŒä½•åº¦ã‚‚ä½•åº¦ã‚‚å¿…è¦ã¨ãªã‚‰ãªã„ã‚ˆã†ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¾ã™ã€‚"

#: ../../howto/regex.rst:514
msgid ""
"Should you use these module-level functions, or should you get the pattern "
"and call its methods yourself?  If you're accessing a regex within a loop, "
"pre-compiling it will save a few function calls. Outside of loops, there's "
"not much difference thanks to the internal cache."
msgstr ""
"ã“ã‚Œã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«é–¢æ•°ã‚’ä½¿ã†ã®ã¨ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è‡ªèº«ã§ä½œã£ã¦è‡ªèº«ã§å‘¼ã³å‡ºã™ã®ã¨ã§ã©ã¡ã‚‰ã‚’ä½¿ã†ã¹ãã§ã—ã‚‡ã†? "
"æ­£è¦è¡¨ç¾ã‚’ãƒ«ãƒ¼ãƒ—ã®å†…å´ã§ä½¿ã†ãªã‚‰ã°ã€ãƒ—ãƒªã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã¯é–¢æ•°å‘¼ã³å‡ºã—ã‚’æ¸›ã‚‰ã—ã¾ã™ã€‚ãƒ«ãƒ¼ãƒ—ã®å¤–å´ã§ã‚ã‚Œã°ã€å†…éƒ¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ãŠã‹ã’ã§ã€ã©ã¡ã‚‰ã§ã‚‚å¤§å·®ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../howto/regex.rst:522
msgid "Compilation Flags"
msgstr "ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãƒ•ãƒ©ã‚°"

#: ../../howto/regex.rst:524
msgid ""
"Compilation flags let you modify some aspects of how regular expressions "
"work. Flags are available in the :mod:`re` module under two names, a long "
"name such as :const:`IGNORECASE` and a short, one-letter form such as "
":const:`I`.  (If you're familiar with Perl's pattern modifiers, the one-"
"letter forms use the same letters; the short form of :const:`re.VERBOSE` is "
":const:`re.X`, for example.) Multiple flags can be specified by bitwise OR-"
"ing them; ``re.I | re.M`` sets both the :const:`I` and :const:`M` flags, for"
" example."
msgstr ""
"ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãƒ•ãƒ©ã‚°ã¯æ­£è¦è¡¨ç¾ã®å‹•ä½œã‚’ã„ãã¤ã‹ã®å´é¢ã‹ã‚‰å¤‰æ›´ã—ã¾ã™ã€‚ãƒ•ãƒ©ã‚°ã¯ :mod:`re` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸‹ã§äºŒã¤ã®åå‰ã§åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€ä¾‹ãˆã°é•·ã„åå‰ã¯ :const:`IGNORECASE` ã§çŸ­ã„åå‰ã¯1æ–‡å­—ã§ :const:`I` "
"ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚ (1æ–‡å­—å½¢å¼ã¯ Perl ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ä¿®é£¾å­ã¨åŒã˜å½¢å¼ã‚’ä½¿ã„ã¾ã™; ä¾‹ãˆã° :const:`re.VERBOSE` ã®çŸ­ã‹ã„å½¢å¼ã¯"
" :const:`re.X` ã§ã™ã€‚) è¤‡æ•°ã®ãƒ•ãƒ©ã‚°ãŒ OR ãƒ“ãƒƒãƒˆæ¼”ç®—ã§æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™; ä¾‹ãˆã° ``re.I | re.M`` ã¯ "
":const:`I` ã¨ :const:`M` ãƒ•ãƒ©ã‚°ã®ä¸¡æ–¹ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:532
msgid ""
"Here's a table of the available flags, followed by a more detailed "
"explanation of each one."
msgstr "ã“ã“ã«åˆ©ç”¨å¯èƒ½ãªãƒ•ãƒ©ã‚°ã®è¡¨ãŒã‚ã‚Šã¾ã™ã€ãã‚Œãã‚Œã«ã¤ã„ã¦ã®ã‚ˆã‚Šè©³ç´°ãªèª¬æ˜ãŒå¾Œã«ç¶šãã¾ã™ã€‚"

#: ../../howto/regex.rst:536
msgid "Flag"
msgstr "Flag"

#: ../../howto/regex.rst:536
msgid "Meaning"
msgstr "æ„å‘³"

#: ../../howto/regex.rst:538
msgid ":const:`ASCII`, :const:`A`"
msgstr ":const:`ASCII`, :const:`A`"

#: ../../howto/regex.rst:538
msgid ""
"Makes several escapes like ``\\w``, ``\\b``, ``\\s`` and ``\\d`` match only "
"on ASCII characters with the respective property."
msgstr "``\\w``, ``\\b``, ``\\s``, ãã—ã¦ ``\\d`` ãªã©ã‚’ãã‚Œãã‚Œã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ã‚‚ã¤ ASCII æ–‡å­—ã ã‘ã«ãƒãƒƒãƒã•ã›ã¾ã™ã€‚"

#: ../../howto/regex.rst:542
msgid ":const:`DOTALL`, :const:`S`"
msgstr ":const:`DOTALL`, :const:`S`"

#: ../../howto/regex.rst:542
msgid "Make ``.`` match any character, including newlines."
msgstr ""

#: ../../howto/regex.rst:545
msgid ":const:`IGNORECASE`, :const:`I`"
msgstr ":const:`IGNORECASE`, :const:`I`"

#: ../../howto/regex.rst:545
msgid "Do case-insensitive matches."
msgstr ""

#: ../../howto/regex.rst:547
msgid ":const:`LOCALE`, :const:`L`"
msgstr ":const:`LOCALE`, :const:`L`"

#: ../../howto/regex.rst:547
msgid "Do a locale-aware match."
msgstr ""

#: ../../howto/regex.rst:549
msgid ":const:`MULTILINE`, :const:`M`"
msgstr ":const:`MULTILINE`, :const:`M`"

#: ../../howto/regex.rst:549
msgid "Multi-line matching, affecting ``^`` and ``$``."
msgstr ""

#: ../../howto/regex.rst:552
msgid ":const:`VERBOSE`, :const:`X` (for 'extended')"
msgstr ":const:`VERBOSE`, :const:`X` ('X' ã¯ 'extended' ã® 'X')"

#: ../../howto/regex.rst:552
msgid ""
"Enable verbose REs, which can be organized more cleanly and understandably."
msgstr "å†—é•·ãªæ­£è¦è¡¨ç¾ã‚’åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã€ã‚ˆã‚Šãã‚Œã„ã§ç†è§£ã—ã‚„ã™ãã¾ã¨ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../howto/regex.rst:561
msgid ""
"Perform case-insensitive matching; character class and literal strings will "
"match letters by ignoring case.  For example, ``[A-Z]`` will match lowercase"
" letters, too. Full Unicode matching also works unless the :const:`ASCII` "
"flag is used to disable non-ASCII matches.  When the Unicode patterns "
"``[a-z]`` or ``[A-Z]`` are used in combination with the :const:`IGNORECASE` "
"flag, they will match the 52 ASCII letters and 4 additional non-ASCII "
"letters: 'Ä°' (U+0130, Latin capital letter I with dot above), 'Ä±' (U+0131, "
"Latin small letter dotless i), 'Å¿' (U+017F, Latin small letter long s) and "
"'â„ª' (U+212A, Kelvin sign).  ``Spam`` will match ``'Spam'``, ``'spam'``, "
"``'spAM'``, or ``'Å¿pam'`` (the latter is matched only in Unicode mode). This"
" lowercasing doesn't take the current locale into account; it will if you "
"also set the :const:`LOCALE` flag."
msgstr ""

#: ../../howto/regex.rst:579
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale instead of the Unicode database."
msgstr ""

#: ../../howto/regex.rst:582
msgid ""
"Locales are a feature of the C library intended to help in writing programs "
"that take account of language differences.  For example, if you're "
"processing encoded French text, you'd want to be able to write ``\\w+`` to "
"match words, but ``\\w`` only matches the character class ``[A-Za-z]`` in "
"bytes patterns; it won't match bytes corresponding to ``Ã©`` or ``Ã§``. If "
"your system is configured properly and a French locale is selected, certain "
"C functions will tell the program that the byte corresponding to ``Ã©`` "
"should also be considered a letter. Setting the :const:`LOCALE` flag when "
"compiling a regular expression will cause the resulting compiled object to "
"use these C functions for ``\\w``; this is slower, but also enables ``\\w+``"
" to match French words as you'd expect. The use of this flag is discouraged "
"in Python 3 as the locale mechanism is very unreliable, it only handles one "
"\"culture\" at a time, and it only works with 8-bit locales.  Unicode "
"matching is already enabled by default in Python 3 for Unicode (str) "
"patterns, and it is able to handle different locales/languages."
msgstr ""

#: ../../howto/regex.rst:604
msgid ""
"(``^`` and ``$`` haven't been explained yet;  they'll be introduced in "
"section :ref:`more-metacharacters`.)"
msgstr ""
"(``^`` ã¨ ``$`` ã«ã¤ã„ã¦ã¯ã¾ã èª¬æ˜ã—ã¦ã„ã¾ã›ã‚“; ã“ã‚Œã‚‰ã¯ :ref:`more-metacharacters` ã®ç¯€ã§èª¬æ˜ã—ã¾ã™ã€‚)"

#: ../../howto/regex.rst:607
msgid ""
"Usually ``^`` matches only at the beginning of the string, and ``$`` matches"
" only at the end of the string and immediately before the newline (if any) "
"at the end of the string. When this flag is specified, ``^`` matches at the "
"beginning of the string and at the beginning of each line within the string,"
" immediately following each newline.  Similarly, the ``$`` metacharacter "
"matches either at the end of the string and at the end of each line "
"(immediately preceding each newline)."
msgstr ""
"é€šå¸¸ ``^`` ã¯æ–‡å­—åˆ—ã®å…ˆé ­ã«ãƒãƒƒãƒã—ã€ ``$`` "
"ã¯æ–‡å­—åˆ—ã®æœ«å°¾ã¨æ–‡å­—åˆ—ã®æœ«å°¾ã«æ”¹è¡Œ(ãŒã‚ã‚Œã°)ãã®ç›´å‰ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã®ãƒ•ãƒ©ã‚°ãŒæŒ‡å®šã•ã‚Œã‚‹ã¨ã€ ``^`` "
"ã¯æ–‡å­—åˆ—ã®å…ˆé ­ã¨æ–‡å­—åˆ—ã®ä¸­ã®æ”¹è¡Œã«ç¶šãå„è¡Œã®å…ˆé ­ã«ãƒãƒƒãƒã—ã¾ã™ã€‚åŒæ§˜ã« ``$`` "
"ç‰¹æ®Šæ–‡å­—ã¯æ–‡å­—åˆ—ã®æœ«å°¾ã¨å„è¡Œã®æœ«å°¾(å„æ”¹è¡Œã®ç›´å‰)ã®ã©ã¡ã‚‰ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:620
msgid ""
"Makes the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"ç‰¹åˆ¥ãªæ–‡å­— ``'.'`` ã‚’æ”¹è¡Œã‚’å«ã‚€å…¨ã¦ã®ä»»æ„ã®æ–‡å­—ã¨ãƒãƒƒãƒã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™; ã“ã®ãƒ•ãƒ©ã‚°ãŒç„¡ã—ã§ã¯ã€ ``'.'`` ã¯æ”¹è¡Œ *ä»¥å¤–* "
"ã®å…¨ã¦ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:628
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` perform ASCII-"
"only matching instead of full Unicode matching. This is only meaningful for "
"Unicode patterns, and is ignored for byte patterns."
msgstr ""
"``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s``, ``\\S`` ãŒã€å®Œå…¨ãª Unicode "
"ãƒãƒƒãƒãƒ³ã‚°ã§ã¯ãªãã€ASCII ã®ã¿ã®ãƒãƒƒãƒãƒ³ã‚°ã‚’ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã‚Œã¯ Unicode ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã®ã¿æ„å‘³ãŒã‚ã‚Šã€byte "
"ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../howto/regex.rst:637
msgid ""
"This flag allows you to write regular expressions that are more readable by "
"granting you more flexibility in how you can format them.  When this flag "
"has been specified, whitespace within the RE string is ignored, except when "
"the whitespace is in a character class or preceded by an unescaped "
"backslash; this lets you organize and indent the RE more clearly.  This flag"
" also lets you put comments within a RE that will be ignored by the engine; "
"comments are marked by a ``'#'`` that's neither in a character class or "
"preceded by an unescaped backslash."
msgstr ""
"ã“ã®ãƒ•ãƒ©ã‚°ã¯ã‚ˆã‚ŠæŸ”è»Ÿãªå½¢å¼ã§æ­£è¦è¡¨ç¾ã‚’èª­ã¿æ˜“ãæ›¸ã‘ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã®ãƒ•ãƒ©ã‚°ã‚’æŒ‡å®šã™ã‚‹ã¨ã€æ­£è¦è¡¨ç¾ã®ä¸­ã®ç©ºç™½ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€ãŸã ã—ã€æ–‡å­—ã‚¯ãƒ©ã‚¹å†…ã‚„ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¦ã„ãªã„ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«ç¶šãç©ºç™½ã®å ´åˆã¯ä¾‹å¤–ã¨ã—ã¦ç„¡è¦–ã•ã‚Œã¾ã›ã‚“;"
" ã“ã‚Œã«ã‚ˆã£ã¦æ­£è¦è¡¨ç¾ã‚’ã¾ã¨ã‚ãŸã‚Šã€ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã—ã¦ã‚ˆã‚Šæ˜ç¢ºã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®ãƒ•ãƒ©ã‚°ã¯ã•ã‚‰ã«ã‚¨ãƒ³ã‚¸ãƒ³ãŒç„¡è¦–ã™ã‚‹ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™; "
"ã‚³ãƒ¡ãƒ³ãƒˆã¯ ``'#'`` ã§ç¤ºã—ã¾ã™ã€ã“ã‚Œã¯æ–‡å­—ã‚¯ãƒ©ã‚¹ã‚„ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¦ã„ãªã„ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«ç¶šãã‚‚ã®ã§ã‚ã£ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../howto/regex.rst:646
msgid ""
"For example, here's a RE that uses :const:`re.VERBOSE`; see how much easier "
"it is to read? ::"
msgstr "ä¾‹ãˆã°ã€ã“ã“ã« :const:`re.VERBOSE` ã‚’åˆ©ç”¨ã—ãŸæ­£è¦è¡¨ç¾ãŒã‚ã‚Šã¾ã™; èª­ã¿æ˜“ã„ã¨æ€ã„ã¾ã›ã‚“ã‹? ::"

#: ../../howto/regex.rst:659
msgid "Without the verbose setting, the RE would look like this::"
msgstr "å†—é•·ãªè¡¨ç¾ã‚’åˆ©ç”¨ã—ãªã„è¨­å®šã®å ´åˆã€æ­£è¦è¡¨ç¾ã¯ã“ã†ãªã‚Šã¾ã™::"

#: ../../howto/regex.rst:665
msgid ""
"In the above example, Python's automatic concatenation of string literals "
"has been used to break up the RE into smaller pieces, but it's still more "
"difficult to understand than the version using :const:`re.VERBOSE`."
msgstr ""
"ä¸Šã®ä¾‹ã§ã¯ã€Python ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã®è‡ªå‹•çµåˆã«ã‚ˆã£ã¦æ­£è¦è¡¨ç¾ã‚’å°ã•ãªéƒ¨åˆ†ã«åˆ†å‰²ã—ã¦ã„ã¾ã™ã€ãã‚Œã§ã‚‚ :const:`re.VERBOSE` "
"ã‚’ä½¿ã£ãŸå ´åˆã«æ¯”ã¹ã‚‹ã¨ã¾ã é›£ã—ããªã£ã¦ã„ã¾ã™ã€‚"

#: ../../howto/regex.rst:671
msgid "More Pattern Power"
msgstr "ãƒ‘ã‚¿ãƒ¼ãƒ³ã®èƒ½åŠ›ã‚’ã•ã‚‰ã«"

#: ../../howto/regex.rst:673
msgid ""
"So far we've only covered a part of the features of regular expressions.  In"
" this section, we'll cover some new metacharacters, and how to use groups to"
" retrieve portions of the text that was matched."
msgstr ""
"ã“ã“ã¾ã§ã§ã€æ­£è¦è¡¨ç¾ã®æ©Ÿèƒ½ã®ã»ã‚“ã®ä¸€éƒ¨ã‚’æ‰±ã£ã¦ãã¾ã—ãŸã€‚ã“ã®ç¯€ã§ã¯ã€æ–°ãŸã«ã„ãã¤ã‹ã®ç‰¹æ®Šæ–‡å­—ã¨ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½¿ã£ã¦ãƒãƒƒãƒã—ãŸãƒ†ã‚­ã‚¹ãƒˆã®ä¸€éƒ¨ã‚’ã©ã†å–å¾—ã™ã‚‹ã‹ã«ã¤ã„ã¦æ‰±ã„ã¾ã™ã€‚"

#: ../../howto/regex.rst:681
msgid "More Metacharacters"
msgstr "ã•ã‚‰ãªã‚‹ç‰¹æ®Šæ–‡å­—"

#: ../../howto/regex.rst:683
msgid ""
"There are some metacharacters that we haven't covered yet.  Most of them "
"will be covered in this section."
msgstr "ã“ã‚Œã¾ã§ã§ã€ã¾ã æ‰±ã£ã¦ã„ãªã„ç‰¹æ®Šæ–‡å­—ãŒã„ãã¤ã‹ã‚ã‚Šã¾ã—ãŸã€‚ãã®ã»ã¨ã‚“ã©ã‚’ã“ã®ç¯€ã§æ‰±ã£ã¦ã„ãã¾ã™ã€‚"

#: ../../howto/regex.rst:686
msgid ""
"Some of the remaining metacharacters to be discussed are :dfn:`zero-width "
"assertions`.  They don't cause the engine to advance through the string; "
"instead, they consume no characters at all, and simply succeed or fail.  For"
" example, ``\\b`` is an assertion that the current position is located at a "
"word boundary; the position isn't changed by the ``\\b`` at all.  This means"
" that zero-width assertions should never be repeated, because if they match "
"once at a given location, they can obviously be matched an infinite number "
"of times."
msgstr ""
"æ®‹ã‚Šã®ç‰¹æ®Šæ–‡å­—ã®å†…ã„ãã¤ã‹ã¯ :dfn:`ã‚¼ãƒ­å¹…ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ zero-width-assertions` "
"ã«é–¢ã™ã‚‹ã‚‚ã®ã§ã™ã€‚ã“ã‚Œã‚‰ã¯æ–‡å­—åˆ—ã«å¯¾ã—ã¦ã‚¨ãƒ³ã‚¸ãƒ³ã‚’é€²ã‚ã¾ã›ã‚“; æ–‡å­—åˆ—ã‚’å…¨ãåˆ©ç”¨ã—ãªã„ä»£ã‚ã‚Šã«ã€å˜ç´”ã«æˆåŠŸã‹å¤±æ•—ã‹ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``\\b``"
" ã¯ç¾åœ¨ä½ç½®ãŒå˜èªã®å¢ƒç•Œã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™; ``\\b`` "
"ã«ã‚ˆã£ã¦ã‚¨ãƒ³ã‚¸ãƒ³ã®èª­ã‚“ã§ã„ã‚‹ä½ç½®ã¯å…¨ãå¤‰åŒ–ã—ã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šã€ã“ã‚Œã¯ã‚¼ãƒ­å¹…ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¯ç¹°ã‚Šè¿”ã—ä½¿ã†ã“ã¨ãŒã‚ã‚Šã¾ã›ã‚“ã€ä¸€åº¦ã‚ã‚‹ä½ç½®ã§ãƒãƒƒãƒã—ãŸã‚‰ã€æ˜ã‚‰ã‹ã«ç„¡é™å›ãƒãƒƒãƒã§ãã¾ã™ã€‚"

#: ../../howto/regex.rst:702
msgid "``|``"
msgstr "``|``"

#: ../../howto/regex.rst:695
msgid ""
"Alternation, or the \"or\" operator.   If *A* and *B* are regular "
"expressions, ``A|B`` will match any string that matches either *A* or *B*. "
"``|`` has very low precedence in order to make it work reasonably when "
"you're alternating multi-character strings. ``Crow|Servo`` will match either"
" ``'Crow'`` or ``'Servo'``, not ``'Cro'``, a ``'w'`` or an ``'S'``, and "
"``'ervo'``."
msgstr ""

#: ../../howto/regex.rst:701
msgid ""
"To match a literal ``'|'``, use ``\\|``, or enclose it inside a character "
"class, as in ``[|]``."
msgstr "ãƒªãƒ†ãƒ©ãƒ« ``'|'`` ã«ãƒãƒƒãƒã™ã‚‹ã«ã¯ã€ ``\\|`` ã‚’åˆ©ç”¨ã™ã‚‹ã‹ã€ ``[|]`` ã®ã‚ˆã†ã«æ–‡å­—ã‚¯ãƒ©ã‚¹å†…ã«åã‚ã¦ä¸‹ã•ã„ã€‚"

#: ../../howto/regex.rst:717
msgid "``^``"
msgstr "``^``"

#: ../../howto/regex.rst:705
msgid ""
"Matches at the beginning of lines.  Unless the :const:`MULTILINE` flag has "
"been set, this will only match at the beginning of the string.  In "
":const:`MULTILINE` mode, this also matches immediately after each newline "
"within the string."
msgstr ""
"è¡Œã®å…ˆé ­ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ :const:`MULTILINE` ãƒ•ãƒ©ã‚°ãŒè¨­å®šã•ã‚Œãªã„å ´åˆã«ã¯ã€æ–‡å­—åˆ—ã®å…ˆé ­ã«ã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚ "
":const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã§ã¯æ–‡å­—åˆ—å†…ã®å„æ”¹è¡Œã®ç›´å¾Œã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:709
msgid ""
"For example, if you wish to match the word ``From`` only at the beginning of"
" a line, the RE to use is ``^From``. ::"
msgstr "ä¾‹ãˆã°ã€è¡Œã®å…ˆé ­ã® ``From`` ã«ã®ã¿ãƒãƒƒãƒã•ã›ãŸã„å ´åˆã«ã¯ ``^From`` æ­£è¦è¡¨ç¾ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚ ::"

#: ../../howto/regex.rst:717
msgid "To match a literal ``'^'``, use ``\\^``."
msgstr ""

#: ../../howto/regex.rst:731
msgid "``$``"
msgstr "``$``"

#: ../../howto/regex.rst:720
msgid ""
"Matches at the end of a line, which is defined as either the end of the "
"string, or any location followed by a newline character.     ::"
msgstr "è¡Œã®æœ«å°¾ã«ãƒãƒƒãƒã—ã¾ã™ã€è¡Œã®æœ«å°¾ã¯æ–‡å­—åˆ—ã®æœ«å°¾ã¨æ”¹è¡Œæ–‡å­—ã®ç›´å‰ã¨ã—ã¦å®šç¾©ã•ã‚Œã¾ã™ã€‚ ::"

#: ../../howto/regex.rst:730
msgid ""
"To match a literal ``'$'``, use ``\\$`` or enclose it inside a character "
"class, as in  ``[$]``."
msgstr "ãƒªãƒ†ãƒ©ãƒ« ``'$'`` ã«ãƒãƒƒãƒã™ã‚‹ã«ã¯ã€ ``\\$`` ã‚’åˆ©ç”¨ã™ã‚‹ã‹ã€ ``[$]`` ã®ã‚ˆã†ã«æ–‡å­—ã‚¯ãƒ©ã‚¹å†…ã«åã‚ã¦ä¸‹ã•ã„ã€‚"

#: ../../howto/regex.rst:737
msgid "``\\A``"
msgstr "``\\A``"

#: ../../howto/regex.rst:734
msgid ""
"Matches only at the start of the string.  When not in :const:`MULTILINE` "
"mode, ``\\A`` and ``^`` are effectively the same.  In :const:`MULTILINE` "
"mode, they're different: ``\\A`` still matches only at the beginning of the "
"string, but ``^`` may match at any location inside the string that follows a"
" newline character."
msgstr ""
"æ–‡å­—åˆ—ã®å…ˆé ­ã«ã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚ :const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã§ãªã„å ´åˆã«ã¯ ``\\A`` ã¨ ``^`` ã¯å®Ÿè³ªçš„ã«åŒã˜ã§ã™ã€‚ "
":const:`MULTILINE` ãƒ¢ãƒ¼ãƒ‰ã§ã®ã“ã‚Œã‚‰ã®é•ã„ã¯: ``\\A`` ã¯ä¾ç„¶ã¨ã—ã¦æ–‡å­—åˆ—ã®å…ˆé ­ã«ã®ã¿ãƒãƒƒãƒã—ã¾ã™ãŒã€ ``^`` "
"ã¯æ–‡å­—åˆ—å†…ã«æ”¹è¡Œæ–‡å­—ã«ç¶šãéƒ¨åˆ†ãŒã‚ã‚Œã°ãã“ã«ãƒãƒƒãƒã™ã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../howto/regex.rst:740
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../howto/regex.rst:740
msgid "Matches only at the end of the string."
msgstr "æ–‡å­—åˆ—ã®æœ«å°¾ã¨ã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:775
msgid "``\\b``"
msgstr "``\\b``"

#: ../../howto/regex.rst:743
msgid ""
"Word boundary.  This is a zero-width assertion that matches only at the "
"beginning or end of a word.  A word is defined as a sequence of alphanumeric"
" characters, so the end of a word is indicated by whitespace or a non-"
"alphanumeric character."
msgstr ""
"å˜èªã®å¢ƒç•Œã€‚ã“ã‚Œã¯ã‚¼ãƒ­å¹…ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§ã€å˜èªã®å§‹ã¾ã‚Šã‹çµ‚ã‚ã‚Šã«ã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚å˜èªã¯è‹±æ•°æ–‡å­—ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦å®šç¾©ã•ã‚Œã¾ã™ã€ã¤ã¾ã‚Šå˜èªã®çµ‚ã‚ã‚Šã¯ç©ºç™½ã‹éè‹±æ•°æ–‡å­—ã¨ã—ã¦è¡¨ã‚ã‚Œã¾ã™ã€‚"

#: ../../howto/regex.rst:748
msgid ""
"The following example matches ``class`` only when it's a complete word; it "
"won't match when it's contained inside another word. ::"
msgstr "ä»¥ä¸‹ã®ä¾‹ã§ã¯ ``class`` ãŒãã®ã‚‚ã®ã®å˜èªã®ã¨ãã®ã¿ãƒãƒƒãƒã—ã¾ã™; åˆ¥ã®å˜èªå†…ã«å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã€‚ ::"

#: ../../howto/regex.rst:759
msgid ""
"There are two subtleties you should remember when using this special "
"sequence. First, this is the worst collision between Python's string "
"literals and regular expression sequences.  In Python's string literals, "
"``\\b`` is the backspace character, ASCII value 8.  If you're not using raw "
"strings, then Python will convert the ``\\b`` to a backspace, and your RE "
"won't match as you expect it to. The following example looks the same as our"
" previous RE, but omits the ``'r'`` in front of the RE string. ::"
msgstr ""
"ã“ã®ç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’åˆ©ç”¨ã™ã‚‹ã¨ãã«ã¯äºŒã¤ã®å¾®å¦™ãªç‚¹ã‚’å¿ƒã«ã¨ã‚ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã¾ãšã²ã¨ã¤ã‚ã¯ Python "
"ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¨è¡¨ç¾ã®é–“ã®æœ€æ‚ªã®è¡çªã‚’å¼•ãèµ·ã™ã“ã¨ã§ã™ã€‚Python ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã§ã¯ ``\\b`` ã¯ ASCII "
"å€¤8ã®ãƒãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¹æ–‡å­—ã§ã™ã€‚raw string ã‚’åˆ©ç”¨ã—ã¦ã„ãªã„å ´åˆã€Python ã¯ ``\\b`` "
"ã‚’ãƒãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã«å¤‰æ›ã—ã€æ­£è¦è¡¨ç¾ã¯æœŸå¾…ã™ã‚‹ã‚‚ã®ã¨ãƒãƒƒãƒã—ãªããªã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®ä¾‹ã¯ã•ãã»ã©ã¨åŒã˜æ­£è¦è¡¨ç¾ã®ã‚ˆã†ã«è¦‹ãˆã¾ã™ãŒã€æ­£è¦è¡¨ç¾æ–‡å­—åˆ—ã®å‰ã® "
"``'r'`` ãŒçœç•¥ã•ã‚Œã¦ã„ã¾ã™ã€‚ ::"

#: ../../howto/regex.rst:773
msgid ""
"Second, inside a character class, where there's no use for this assertion, "
"``\\b`` represents the backspace character, for compatibility with Python's "
"string literals."
msgstr ""
"ãµãŸã¤ã‚ã¯ã“ã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒåˆ©ç”¨ã§ããªã„æ–‡å­—åˆ—ã‚¯ãƒ©ã‚¹ã®å†…éƒ¨ã§ã¯ Python ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¨ã®äº’æ›æ€§ã®ãŸã‚ã«ã€ ``\\b`` "
"ã¯ãƒãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¹æ–‡å­—ã‚’è¡¨ã‚ã™ã“ã¨ã«ãªã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../howto/regex.rst:780
msgid "``\\B``"
msgstr "``\\B``"

#: ../../howto/regex.rst:778
msgid ""
"Another zero-width assertion, this is the opposite of ``\\b``, only matching"
" when the current position is not at a word boundary."
msgstr "åˆ¥ã®ã‚¼ãƒ­å¹…ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§ã€ ``\\b`` ã¨é€†ã§ã€ç¾åœ¨ã®ä½ç½®ãŒå˜èªã®å¢ƒç•Œã§ãªã„ã¨ãã«ã®ã¿ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:783
msgid "Grouping"
msgstr "ã‚°ãƒ«ãƒ¼ãƒ”ãƒ³ã‚°"

#: ../../howto/regex.rst:785
msgid ""
"Frequently you need to obtain more information than just whether the RE "
"matched or not.  Regular expressions are often used to dissect strings by "
"writing a RE divided into several subgroups which match different components"
" of interest. For example, an RFC-822 header line is divided into a header "
"name and a value, separated by a ``':'``, like this:"
msgstr ""

#: ../../howto/regex.rst:798
msgid ""
"This can be handled by writing a regular expression which matches an entire "
"header line, and has one group which matches the header name, and another "
"group which matches the header's value."
msgstr ""
"ã“ã‚Œã¯ãƒ˜ãƒƒãƒ€å…¨ä½“ã«ãƒãƒƒãƒã—ã€ãã—ã¦ãƒ˜ãƒƒãƒ€åã«ãƒãƒƒãƒã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã¨ãƒ˜ãƒƒãƒ€ã®å€¤ã«ãƒãƒƒãƒã™ã‚‹åˆ¥ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æŒã¤ã‚ˆã†ã«æ­£è¦è¡¨ç¾ã‚’æ›¸ãã“ã¨ã§æ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../howto/regex.rst:802
msgid ""
"Groups are marked by the ``'('``, ``')'`` metacharacters. ``'('`` and "
"``')'`` have much the same meaning as they do in mathematical expressions; "
"they group together the expressions contained inside them, and you can "
"repeat the contents of a group with a repeating qualifier, such as ``*``, "
"``+``, ``?``, or ``{m,n}``.  For example, ``(ab)*`` will match zero or more "
"repetitions of ``ab``. ::"
msgstr ""
"ã‚°ãƒ«ãƒ¼ãƒ—ã¯ç‰¹æ®Šæ–‡å­— ``'('``, ``')'`` ã§è¡¨ã‚ã•ã‚Œã¾ã™ã€‚ ``'('`` ã¨ ``')'`` ã¯æ•°å­¦ã§ã®æ„å‘³ã¨ã»ã¼åŒã˜æ„å‘³ã‚’æŒã£ã¦ã„ã¾ã™;"
" ãã®ä¸­ã«å«ã¾ã‚ŒãŸè¡¨ç¾ã¯ã¾ã¨ã‚ã¦ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã•ã‚Œã€ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¸­èº«ã‚’ ``*``, ``+``, ``?`` ã‚„ ``{m,n}`` "
"ã®ã‚ˆã†ãªç¹°ã‚Šè¿”ã—ã®ä¿®é£¾å­ã‚’ä½¿ã£ã¦ç¹°ã‚Šè¿”ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ ``(ab)*`` ã¯ ``ab`` ã®0å›ä»¥ä¸Šã®ç¹°ã‚Šè¿”ã—ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ ::"

#: ../../howto/regex.rst:813
msgid ""
"Groups indicated with ``'('``, ``')'`` also capture the starting and ending "
"index of the text that they match; this can be retrieved by passing an "
"argument to :meth:`~re.Match.group`, :meth:`~re.Match.start`, "
":meth:`~re.Match.end`, and :meth:`~re.Match.span`.  Groups are numbered "
"starting with 0.  Group 0 is always present; it's the whole RE, so "
":ref:`match object <match-objects>` methods all have group 0 as their "
"default argument.  Later we'll see how to express groups that don't capture "
"the span of text that they match. ::"
msgstr ""

#: ../../howto/regex.rst:829
msgid ""
"Subgroups are numbered from left to right, from 1 upward.  Groups can be "
"nested; to determine the number, just count the opening parenthesis "
"characters, going from left to right. ::"
msgstr ""
"ã‚µãƒ–ã‚°ãƒ«ãƒ¼ãƒ—ã¯å·¦ã‹ã‚‰å³ã¸1ã¥ã¤ç•ªå·ä»˜ã‘ã•ã‚Œã¾ã™ã€‚ã‚°ãƒ«ãƒ¼ãƒ—ã¯ãƒã‚¹ãƒˆã—ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“; ç•ªå·ã‚’æ±ºã‚ã‚‹ã«ã¯ã€å˜ã«é–‹ãæ‹¬å¼§ã‚’å·¦ã‹ã‚‰å³ã¸æ•°ãˆä¸Šã’ã¾ã™ã€‚ ::"

#: ../../howto/regex.rst:842
msgid ""
":meth:`~re.Match.group` can be passed multiple group numbers at a time, in "
"which case it will return a tuple containing the corresponding values for "
"those groups. ::"
msgstr ""

#: ../../howto/regex.rst:848
msgid ""
"The :meth:`~re.Match.groups` method returns a tuple containing the strings "
"for all the subgroups, from 1 up to however many there are. ::"
msgstr ""

#: ../../howto/regex.rst:854
msgid ""
"Backreferences in a pattern allow you to specify that the contents of an "
"earlier capturing group must also be found at the current location in the "
"string.  For example, ``\\1`` will succeed if the exact contents of group 1 "
"can be found at the current position, and fails otherwise.  Remember that "
"Python's string literals also use a backslash followed by numbers to allow "
"including arbitrary characters in a string, so be sure to use a raw string "
"when incorporating backreferences in a RE."
msgstr ""
"ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸­ã§å¾Œæ–¹å‚ç…§ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€å‰ã«å–ã‚Šå‡ºã•ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ—ãŒæ–‡å­—åˆ—ã®ä¸­ã®ç¾åœ¨ä½ç½®ã§è¦‹ã¤ã‹ã‚‹ã‚ˆã†ã«æŒ‡å®šã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€``\\1`` "
"ã¯ã‚°ãƒ«ãƒ¼ãƒ—1ã®å†…å®¹ãŒç¾åœ¨ä½ç½®ã§è¦‹ã¤ã‹ã£ãŸå ´åˆæˆåŠŸã—ã€ãã‚Œä»¥å¤–ã®å ´åˆã«å¤±æ•—ã—ã¾ã™ã€‚Python "
"ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã§ã‚‚ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«ç¶šãæ•°å­—ã¯ä»»æ„ã®æ–‡å­—ã‚’æ–‡å­—åˆ—ã«å«ã‚ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹ã¨ã„ã†ã“ã¨ã‚’å¿ƒã«ç•™ã‚ã¦ãŠã„ã¦ä¸‹ã•ã„ã€ãã®ãŸã‚æ­£è¦è¡¨ç¾ã§å¾Œæ–¹å‚ç…§ã‚’å«ã‚€å ´åˆã«ã¯"
" raw string ã‚’å¿…ãšåˆ©ç”¨ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../howto/regex.rst:862
msgid "For example, the following RE detects doubled words in a string. ::"
msgstr "ä¾‹ãˆã°ã€ä»¥ä¸‹ã®æ­£è¦è¡¨ç¾ã¯äºŒé‡ã«ãªã£ãŸå˜èªã‚’æ¤œå‡ºã—ã¾ã™ã€‚ ::"

#: ../../howto/regex.rst:868
msgid ""
"Backreferences like this aren't often useful for just searching through a "
"string --- there are few text formats which repeat data in this way --- but "
"you'll soon find out that they're *very* useful when performing string "
"substitutions."
msgstr ""
"ã“ã®ã‚ˆã†ãªå¾Œæ–¹å‚ç…§ã¯æ–‡å­—åˆ—ã‚’æ¤œç´¢ã™ã‚‹ã ã‘ã®ç”¨é€”ã§ã¯å¤šãã®å ´åˆå½¹ã«ç«‹ã¡ã¾ã›ã‚“ã€‚--- ã“ã®ã‚ˆã†ã«ç¹°ã‚Šè¿”ã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯å°‘æ•°ã§ã™ã€‚--- "
"ã—ã‹ã—ã€æ–‡å­—åˆ—ã®ç½®æ›ã‚’ã™ã‚‹å ´åˆã«ã¯ *ã¨ã¦ã‚‚* æœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ã«æ°—ã¥ãã§ã—ã‚‡ã†ã€‚"

#: ../../howto/regex.rst:874
msgid "Non-capturing and Named Groups"
msgstr "å–ã‚Šå‡ºã•ãªã„ã‚°ãƒ«ãƒ¼ãƒ—ã¨åå‰ã¤ãã‚°ãƒ«ãƒ¼ãƒ—"

#: ../../howto/regex.rst:876
msgid ""
"Elaborate REs may use many groups, both to capture substrings of interest, "
"and to group and structure the RE itself.  In complex REs, it becomes "
"difficult to keep track of the group numbers.  There are two features which "
"help with this problem.  Both of them use a common syntax for regular "
"expression extensions, so we'll look at that first."
msgstr ""
"å¿µå…¥ã‚Šã«ä½œã‚‰ã‚ŒãŸæ­£è¦è¡¨ç¾ã¯å¤šãã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’åˆ©ç”¨ã—ã¾ã™ã€ãã®åˆ©ç”¨æ³•ã«ã¯å¯¾è±¡ã¨ãªã‚‹éƒ¨åˆ†æ–‡å­—åˆ—ã‚’å–ã‚Šå‡ºã™ã€æ­£è¦è¡¨ç¾è‡ªèº«ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ãŸã‚Šæ§‹é€ åŒ–ã™ã‚‹ã€ã¨ã„ã†äºŒã¤ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚è¤‡é›‘ãªæ­£è¦è¡¨ç¾ã§ã¯ã€ã‚°ãƒ«ãƒ¼ãƒ—ç•ªå·ã‚’è¿½ã£ã¦ã„ãã“ã¨ã¯å›°é›£ã«ãªã£ã¦ã„ãã¾ã™ã€‚ã“ã®å•é¡Œã®è§£æ±ºã‚’åŠ©ã‘ã‚‹äºŒã¤ã®æ©Ÿèƒ½ãŒã‚ã‚Šã¾ã™ã€‚ãã®ä¸¡æ–¹ãŒæ­£è¦è¡¨ç¾ã‚’æ‹¡å¼µã™ã‚‹ãŸã‚ã®ä¸€èˆ¬çš„ãªæ§‹æ–‡ã‚’åˆ©ç”¨ã—ã¾ã™ã€ã¾ãšã¯ãã‚Œã‚‰ã‚’ã¿ã¦ã¿ã¾ã—ã‚‡ã†ã€‚"

#: ../../howto/regex.rst:882
msgid ""
"Perl 5 is well known for its powerful additions to standard regular "
"expressions. For these new features the Perl developers couldn't choose new "
"single-keystroke metacharacters or new special sequences beginning with "
"``\\`` without making Perl's regular expressions confusingly different from "
"standard REs.  If they chose ``&`` as a new metacharacter, for example, old "
"expressions would be assuming that ``&`` was a regular character and "
"wouldn't have escaped it by writing ``\\&`` or ``[&]``."
msgstr ""
"Perl 5 ã¯æ¨™æº–æ­£è¦è¡¨ç¾ã«ãƒ‘ãƒ¯ãƒ•ãƒ«ãªæ‹¡å¼µã‚’åŠ ãˆãŸã“ã¨ã§ã‚ˆãçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ãã‚Œã‚‰ã®æ–°ã—ã„æ©Ÿèƒ½ã®ãŸã‚ã« Perl "
"é–‹ç™ºè€…ãŸã¡ã¯ã€Perlæ­£è¦è¡¨ç¾ã¨æ¨™æº–æ­£è¦è¡¨ç¾ã¨ã®æ··ä¹±ã‚’æ‹›ãé•ã„ãªã—ã«ã¯ã€æ–°ãŸãªä¸€æ–‡å­—ãƒ¡ã‚¿ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ã‚‚ ``\\`` "
"ã§ã¯ã˜ã¾ã‚‹æ–°ãŸãªç‰¹æ®Šã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚‚ã©ã¡ã‚‰ã‚‚é¸æŠå‡ºæ¥ã¾ã›ã‚“ã§ã—ãŸã€‚ãŸã¨ãˆã°å½¼ã‚‰ãŒã‚‚ã— ``&`` ã‚’æ–°ãŸãªãƒ¡ã‚¿ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ã¨ã—ã¦é¸ã‚“ã§ã„ãŸã‚‰ã€ ``&`` "
"ãŒé€šå¸¸æ–‡å­—ã¨ã¿ãªã•ã‚Œã¦ã„ãŸå¤ã„æ­£è¦è¡¨ç¾ã¯ ``\\&`` ã‚„ ``[&]`` ã®ã‚ˆã†ã«æ›¸ãã“ã¨ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œãªã‘ã‚Œã°ãªã‚‰ãªã‹ã£ãŸã§ã—ã‚‡ã†ã€‚"

#: ../../howto/regex.rst:889
msgid ""
"The solution chosen by the Perl developers was to use ``(?...)`` as the "
"extension syntax.  ``?`` immediately after a parenthesis was a syntax error "
"because the ``?`` would have nothing to repeat, so this didn't introduce any"
" compatibility problems.  The characters immediately after the ``?``  "
"indicate what extension is being used, so ``(?=foo)`` is one thing (a "
"positive lookahead assertion) and ``(?:foo)`` is something else (a non-"
"capturing group containing the subexpression ``foo``)."
msgstr ""
"è§£æ±ºç­–ã¨ã—ã¦ Perl é–‹ç™ºè€…ãŒé¸ã‚“ã ã‚‚ã®ã¯ ``(?...)`` ã‚’æ­£è¦è¡¨ç¾æ§‹æ–‡ã¨ã—ã¦åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã—ãŸã€‚æ‹¬å¼§ã®ç›´å¾Œã® ``?`` "
"ã¯æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã¾ã™ã€ã“ã‚Œã¯ ``?`` ã§ç¹°ã‚Šè¿”ã™å¯¾è±¡ãŒãªã„ãŸã‚ã§ã™ã€ãã®ãŸã‚ã“ã‚Œã¯äº’æ›æ€§ã®å•é¡Œã‚’æŒã¡è¾¼ã¿ã¾ã›ã‚“ã€‚ ``?`` "
"ã®ç›´å¾Œã®æ–‡å­—ã¯ã©ã®æ‹¡å¼µãŒåˆ©ç”¨ã•ã‚Œã‚‹ã‹ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€ã¤ã¾ã‚Šã€ ``(?=foo)`` ã¯ä¸€ã¤ã®æ‹¡å¼µã‚’åˆ©ç”¨ã—ãŸã‚‚ã® (è‚¯å®šå…ˆèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³) ã¨ãªã‚Šã€ "
"``(?:foo)`` ã¯åˆ¥ã®æ‹¡å¼µã‚’åˆ©ç”¨ã—ãŸè¡¨ç¾(``foo`` ã‚’å«ã‚€å–ã‚Šè¾¼ã¾ãªã„ã‚°ãƒ«ãƒ¼ãƒ—)ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../howto/regex.rst:897
msgid ""
"Python supports several of Perl's extensions and adds an extension syntax to"
" Perl's extension syntax.  If the first character after the question mark is"
" a ``P``, you know that it's an extension that's specific to Python."
msgstr ""
"Python ã¯ Perl ã®æ‹¡å¼µã®ã„ãã¤ã‹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã€ã¾ãŸã€Perl ã®æ‹¡å¼µã«ä¸€ã¤æ‹¡å¼µã‚’åŠ ãˆã¦ã„ã¾ã™ã€‚ã‚¯ã‚¨ã‚¹ãƒãƒ§ãƒ³ãƒãƒ¼ã‚¯ã«ç¶šãæœ€åˆã®æ–‡å­—ãŒ "
"``P`` ã®ã‚‚ã®ã¯ã€ãã†ã§ã™ã€Python å›ºæœ‰ã®æ‹¡å¼µã§ã™ã€‚"

#: ../../howto/regex.rst:902
msgid ""
"Now that we've looked at the general extension syntax, we can return to the "
"features that simplify working with groups in complex REs."
msgstr "ä¸€èˆ¬åŒ–ã•ã‚ŒãŸæ‹¡å¼µæ§‹æ–‡ã«ã¤ã„ã¦ã¯ã‚ã‹ã‚Šã¾ã—ãŸã®ã§ã€ã„ã‚ˆã„ã‚ˆè¤‡é›‘ãªæ­£è¦è¡¨ç¾å†…ã§ã®ã‚°ãƒ«ãƒ¼ãƒ—ã®æ‰±ã„ã‚’å˜ç´”åŒ–ã™ã‚‹æ©Ÿèƒ½ã«è©±ã‚’æˆ»ã—ã¾ã—ã‚‡ã†ã€‚"

#: ../../howto/regex.rst:905
msgid ""
"Sometimes you'll want to use a group to denote a part of a regular "
"expression, but aren't interested in retrieving the group's contents. You "
"can make this fact explicit by using a non-capturing group: ``(?:...)``, "
"where you can replace the ``...`` with any other regular expression. ::"
msgstr ""
"ã¨ãã¨ã—ã¦ã‚ãªãŸã¯ã€æ­£è¦è¡¨ç¾ã®ä¸€éƒ¨ã¨ã—ã¦ä½¿ã„ãŸã„ã‘ã‚Œã©ã‚‚ã€ãã®å†…å®¹ã‚’å–ã‚Šå‡ºã™ã“ã¨ã«èˆˆå‘³ãŒãªã„ã‚ˆã†ãªã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¨˜è¿°ã™ã‚‹å¿…è¦ã«è¿«ã‚‰ã‚Œã¾ã™ã€‚ã“ã®ãŸã‚ã«ã¯ã€å–ã‚Šå‡ºã•ãªã„ã‚°ãƒ«ãƒ¼ãƒ—:"
" ``(?:...)`` ã‚’ä½¿ã„ã¾ã™ã€‚ ``...`` éƒ¨åˆ†ã¯ä»»æ„ã®æ­£è¦è¡¨ç¾ã§ã™ã€‚ ::"

#: ../../howto/regex.rst:917
msgid ""
"Except for the fact that you can't retrieve the contents of what the group "
"matched, a non-capturing group behaves exactly the same as a capturing "
"group; you can put anything inside it, repeat it with a repetition "
"metacharacter such as ``*``, and nest it within other groups (capturing or "
"non-capturing). ``(?:...)`` is particularly useful when modifying an "
"existing pattern, since you can add new groups without changing how all the "
"other groups are numbered.  It should be mentioned that there's no "
"performance difference in searching between capturing and non-capturing "
"groups; neither form is any faster than the other."
msgstr ""
"ãƒãƒƒãƒã—ãŸã‚°ãƒ«ãƒ¼ãƒ—ã®å†…å®¹ã‚’å–å¾—ã—ãªã„ã¨ã„ã†ã“ã¨ã‚’é™¤ã‘ã°ã€å–ã‚Šè¾¼ã¾ãªã„ã‚°ãƒ«ãƒ¼ãƒ—ã¯å³å¯†ã«å–ã‚Šè¾¼ã‚€ã‚°ãƒ«ãƒ¼ãƒ—ã¨åŒæ§˜ã«æŒ¯ã‚‹èˆã„ã¾ã™; "
"ã“ã®ä¸­ã«ä½•ã‚’å…¥ã‚Œã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€ ``*`` ã®ã‚ˆã†ãªç¹°ã‚Šè¿”ã—ã®ç‰¹æ®Šæ–‡å­—ã§ç¹°ã‚Šè¿”ã—ãŸã‚Šã€ä»–ã®ã‚°ãƒ«ãƒ¼ãƒ— (å–ã‚Šè¾¼ã‚€ã¾ãŸã¯å–ã‚Šè¾¼ã¾ãªã„) "
"ã®å…¥ã‚Œå­ã«ã™ã‚‹ã“ã¨ã‚‚ã§ã„ã¾ã™ã€‚ ``(?:...)`` "
"ã¯ç‰¹ã«ã€æ—¢ã«ã‚ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å¤‰æ›´ã™ã‚‹éš›ã«ä¾¿åˆ©ã§ã™ã€ãªãœãªã‚‰ä»–ã®ç•ªå·ã¥ã‘æ–°ã—ã„ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãªãæ–°ã—ã„ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å–ã‚Šè¾¼ã‚€ã‚°ãƒ«ãƒ¼ãƒ—ã¨å–ã‚Šè¾¼ã¾ãªã„ã‚°ãƒ«ãƒ¼ãƒ—ã§æ¤œç´¢ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«å·®ãŒãªã„ã“ã¨ã«ã‚‚è§¦ã‚Œã¦ãŠãã¹ãã“ã¨ã§ã™;"
" ã©ã¡ã‚‰ã‚‚åŒã˜é€Ÿåº¦ã§å‹•ä½œã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:926
msgid ""
"A more significant feature is named groups: instead of referring to them by "
"numbers, groups can be referenced by a name."
msgstr "ã‚ˆã‚Šé‡è¦ãªæ©Ÿèƒ½ã¯åå‰ã¤ãã‚°ãƒ«ãƒ¼ãƒ—ã§ã™: ç•ªå·ã§å‚ç…§ã™ã‚‹ä»£ã‚ã‚Šã«ã€ã‚°ãƒ«ãƒ¼ãƒ—ã«å¯¾ã—ã¦åå‰ã§å‚ç…§ã§ãã¾ã™ã€‚"

#: ../../howto/regex.rst:929
msgid ""
"The syntax for a named group is one of the Python-specific extensions: "
"``(?P<name>...)``.  *name* is, obviously, the name of the group.  Named "
"groups behave exactly like capturing groups, and additionally associate a "
"name with a group.  The :ref:`match object <match-objects>` methods that "
"deal with capturing groups all accept either integers that refer to the "
"group by number or strings that contain the desired group's name.  Named "
"groups are still given numbers, so you can retrieve information about a "
"group in two ways::"
msgstr ""
"åå‰ã¤ãã‚°ãƒ«ãƒ¼ãƒ—ã®ãŸã‚ã®æ§‹æ–‡ã¯ã€ Python å›ºæœ‰æ‹¡å¼µã®ä¸€ã¤: ``(?P<name>...)`` ã‚’ä½¿ã„ã¾ã™ã€‚ *name* "
"ã¯ã€ã‚‚ã¡ã‚ã‚“ã€ã‚°ãƒ«ãƒ¼ãƒ—ã®åå‰ã§ã™ã€‚åå‰ã¤ãã‚°ãƒ«ãƒ¼ãƒ—ã¯å–ã‚Šè¾¼ã‚€ã‚°ãƒ«ãƒ¼ãƒ—ã¨å®Œå…¨ã«åŒã˜ã«æŒ¯ã‚‹èˆã„ã€åŠ ãˆã¦åå‰ãŒé–¢é€£ä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚ :ref:`Match "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-objects>` "
"ã®å–ã‚Šã“ã‚€ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ‰±ã†ãƒ¡ã‚½ãƒƒãƒ‰ã¯å…¨ã¦ã€ç•ªå·ã«ã‚ˆã‚‹ã‚°ãƒ«ãƒ¼ãƒ—å‚ç…§ã®ãŸã‚ã®æ•´æ•°ã€åå‰ã«ã‚ˆã‚‹ã‚°ãƒ«ãƒ¼ãƒ—å‚ç…§ã®ãŸã‚ã®æ–‡å­—åˆ—ã€ã¨ã‚‚ã«è¨±å®¹ã—ã¦ã„ã¾ã™ã€‚åå‰ã¤ãã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚‚ç•ªå·ãŒæŒ¯ã‚‰ã‚Œã¾ã™ã®ã§ã€ã‚°ãƒ«ãƒ¼ãƒ—ã«ã¤ã„ã¦ã®æƒ…å ±ã‚’ã€2ã¤ã®æ–¹æ³•ã§å–ã‚Šå‡ºã›ã¾ã™::"

#: ../../howto/regex.rst:944
msgid ""
"Named groups are handy because they let you use easily-remembered names, "
"instead of having to remember numbers.  Here's an example RE from the "
":mod:`imaplib` module::"
msgstr ""
"åå‰ã¤ãã‚°ãƒ«ãƒ¼ãƒ—ã¯ã€ç•ªå·ã‚’è¦šãˆã‚‹ä»£ã‚ã‚Šã«ã€ç°¡å˜ã«è¦šãˆã‚‰ã‚Œã‚‹åå‰ã‚’åˆ©ç”¨ã§ãã‚‹ã®ã§ã€ç°¡å˜ã«æ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ :mod:`imaplib` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰æ­£è¦è¡¨ç¾ã®ä¾‹ã§ã™::"

#: ../../howto/regex.rst:955
msgid ""
"It's obviously much easier to retrieve ``m.group('zonem')``, instead of "
"having to remember to retrieve group 9."
msgstr "å–å¾—ã™ã‚‹ç•ªå·9ã‚’è¦šãˆã‚‹ã‚ˆã‚Šã‚‚ã€ ``m.group('zonem')`` ã§å–å¾—ã—ãŸæ–¹ãŒæ˜ã‚‰ã‹ã«ç°¡å˜ã«ã™ã¿ã¾ã™ã€‚"

#: ../../howto/regex.rst:958
msgid ""
"The syntax for backreferences in an expression such as ``(...)\\1`` refers "
"to the number of the group.  There's naturally a variant that uses the group"
" name instead of the number. This is another Python extension: ``(?P=name)``"
" indicates that the contents of the group called *name* should again be "
"matched at the current point.  The regular expression for finding doubled "
"words, ``\\b(\\w+)\\s+\\1\\b`` can also be written as "
"``\\b(?P<word>\\w+)\\s+(?P=word)\\b``::"
msgstr ""

#: ../../howto/regex.rst:971
msgid "Lookahead Assertions"
msgstr "å…ˆèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ (Lookahead Assertions)"

#: ../../howto/regex.rst:973
msgid ""
"Another zero-width assertion is the lookahead assertion.  Lookahead "
"assertions are available in both positive and negative form, and  look like "
"this:"
msgstr "ä»–ã®ã‚¼ãƒ­å¹…ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¯å…ˆèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚å…ˆèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¯è‚¯å®šã€å¦å®šã®ä¸¡æ–¹ã®å½¢å¼ãŒåˆ©ç”¨å¯èƒ½ã§ã™ã€ã“ã‚Œã‚’è¦‹ã¦ãã ã•ã„:"

#: ../../howto/regex.rst:981
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../howto/regex.rst:977
msgid ""
"Positive lookahead assertion.  This succeeds if the contained regular "
"expression, represented here by ``...``, successfully matches at the current"
" location, and fails otherwise. But, once the contained expression has been "
"tried, the matching engine doesn't advance at all; the rest of the pattern "
"is tried right where the assertion started."
msgstr ""
"è‚¯å®šå…ˆèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã€‚ ``...`` "
"ã§è¡¨ã‚ã™æ­£è¦è¡¨ç¾ãŒç¾åœ¨ä½ç½®ã§ãƒãƒƒãƒã™ã‚Œã°æˆåŠŸã—ã€ãã‚Œä»¥å¤–ã®å ´åˆå¤±æ•—ã—ã¾ã™ã€‚ã—ã‹ã—ã€è¡¨ç¾ãŒè©¦è¡Œã•ã‚ŒãŸå ´åˆã§ã‚‚ã‚¨ãƒ³ã‚¸ãƒ³ã¯å…ˆã«é€²ã¿ã¾ã›ã‚“; "
"ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ®‹ã‚Šã®éƒ¨åˆ†ã¯ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã®é–‹å§‹æ™‚ç‚¹ã‹ã‚‰å³ã«è©¦è¡Œã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:986
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../howto/regex.rst:984
msgid ""
"Negative lookahead assertion.  This is the opposite of the positive "
"assertion; it succeeds if the contained expression *doesn't* match at the "
"current position in the string."
msgstr "å¦å®šå…ˆèª­ã¿ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã€‚ã“ã‚Œã¯è‚¯å®šã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã®é€†ã§ã€æ­£è¦è¡¨ç¾ãŒæ–‡å­—åˆ—ã®ç¾åœ¨ä½ç½®ã«ãƒãƒƒãƒ *ã—ãªã‹ã£ãŸ* å ´åˆã«æˆåŠŸã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:988
msgid ""
"To make this concrete, let's look at a case where a lookahead is useful. "
"Consider a simple pattern to match a filename and split it apart into a base"
" name and an extension, separated by a ``.``.  For example, in ``news.rc``, "
"``news`` is the base name, and ``rc`` is the filename's extension."
msgstr ""
"ã‚ˆã‚Šå…·ä½“çš„ã«ã™ã‚‹ãŸã‚ã€å…ˆèª­ã¿ãŒä¾¿åˆ©ãªå ´åˆã‚’ã¿ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ãƒ•ã‚¡ã‚¤ãƒ«åã«ãƒãƒƒãƒã—ã€ ``.`` "
"ã§åˆ†ã‘ã‚‰ã‚ŒãŸåŸºæœ¬éƒ¨åˆ†ã¨æ‹¡å¼µå­ã«åˆ†é›¢ã™ã‚‹å˜ç´”ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è€ƒãˆã¾ã—ã‚‡ã†ã€‚ä¾‹ãˆã°ã€ ``news.rc`` ã¯ ``news`` ãŒåŸºæœ¬éƒ¨åˆ†ã§ ``rc`` "
"ãŒãƒ•ã‚¡ã‚¤ãƒ«åã®æ‹¡å¼µå­ã§ã™ã€‚"

#: ../../howto/regex.rst:993
msgid "The pattern to match this is quite simple:"
msgstr "ãƒãƒƒãƒã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã¨ã¦ã‚‚å˜ç´”ã§ã™:"

#: ../../howto/regex.rst:995
msgid "``.*[.].*$``"
msgstr "``.*[.].*$``"

#: ../../howto/regex.rst:997
msgid ""
"Notice that the ``.`` needs to be treated specially because it's a "
"metacharacter, so it's inside a character class to only match that specific "
"character.  Also notice the trailing ``$``; this is added to ensure that all"
" the rest of the string must be included in the extension.  This regular "
"expression matches ``foo.bar`` and ``autoexec.bat`` and ``sendmail.cf`` and "
"``printers.conf``."
msgstr ""
"``.`` ã¯ãƒ¡ã‚¿ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ã§ã™ã®ã§ç‰¹åˆ¥ã«æ‰±ã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã‹ã‚‰ã€æ–‡å­—ã‚¯ãƒ©ã‚¹å†…ã«å…¥ã‚Œã¦ã€ãã®ã‚‚ã®ã¨ã ã‘ãƒãƒƒãƒã™ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã‚‹ã“ã¨ã«æ³¨ç›®ã§ã™ã€‚æœ«å°¾ã®"
" ``$`` ã«ã‚‚æ³¨ç›®ã—ã¦ãã ã•ã„; ã“ã‚Œã¯æ®‹ã‚Šå…¨ã¦ã®æ–‡å­—åˆ—ãŒæ‹¡å¼µå­ã«å«ã¾ã‚Œã‚‹ã¹ãã§ã‚ã‚‹ã“ã¨ã‚’ä¿éšœã™ã‚‹ãŸã‚ã«è¿½åŠ ã—ã¦ã„ã¾ã™ã€‚ã“ã®æ­£è¦è¡¨ç¾ã¯ "
"``foo.bar``, ``autoexec.bat``, ``sendmail.cf``, ``printers.conf`` ã«ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:1004
msgid ""
"Now, consider complicating the problem a bit; what if you want to match "
"filenames where the extension is not ``bat``? Some incorrect attempts:"
msgstr "ã•ã¦ã€å•é¡Œã‚’å°‘ã—è¤‡é›‘ã«ã—ã¦ã¿ã¾ã—ã‚‡ã†; æ‹¡å¼µå­ãŒ ``bat`` ã§ãªã„ãƒ•ã‚¡ã‚¤ãƒ«åã«ãƒãƒƒãƒã—ãŸã„å ´åˆã¯ã©ã†ã§ã—ã‚‡ã†ï¼Ÿé–“é•ã£ãŸè©¦ã¿:"

#: ../../howto/regex.rst:1007
msgid ""
"``.*[.][^b].*$``  The first attempt above tries to exclude ``bat`` by "
"requiring that the first character of the extension is not a ``b``.  This is"
" wrong, because the pattern also doesn't match ``foo.bar``."
msgstr ""
"``.*[.][^b].*$`` ã“ã®æœ€åˆã® ``bat`` ã‚’é™¤ãè©¦ã¿ã¯ã€æœ€åˆã®æ–‡å­—ãŒ ``b`` "
"ã§ãªã„ã“ã¨ã‚’è¦æ±‚ã—ã¾ã™ã€‚ã“ã‚Œã¯èª¤ã£ã¦ã„ã¾ã™ã€ãªãœãªã‚‰ ``foo.bar`` ã«ã‚‚ãƒãƒƒãƒã—ãªã„ã‹ã‚‰ã§ã™ã€‚"

#: ../../howto/regex.rst:1011
msgid "``.*[.]([^b]..|.[^a].|..[^t])$``"
msgstr "``.*[.]([^b]..|.[^a].|..[^t])$``"

#: ../../howto/regex.rst:1013
msgid ""
"The expression gets messier when you try to patch up the first solution by "
"requiring one of the following cases to match: the first character of the "
"extension isn't ``b``; the second character isn't ``a``; or the third "
"character isn't ``t``.  This accepts ``foo.bar`` and rejects "
"``autoexec.bat``, but it requires a three-letter extension and won't accept "
"a filename with a two-letter extension such as ``sendmail.cf``.  We'll "
"complicate the pattern again in an effort to fix it."
msgstr ""
"æ­£è¦è¡¨ç¾ãŒæ··ä¹±ã—ã¦ãã¾ã—ãŸã€‚æœ€åˆã®è§£æ±ºç­–ã‚’å–ã‚Šç¹•ã£ã¦ã€ä»¥ä¸‹ã®å ´åˆã«åˆã‚ã›ã‚‹ã“ã¨ã‚’è¦æ±‚ã—ã¦ã„ã¾ã™: æ‹¡å¼µå­ã®æœ€åˆã®æ–‡å­—ã¯ ``b`` ã§ãªã; "
"äºŒç•ªç›®ã®æ–‡å­—ã¯ ``a`` ã§ãªã; ä¸‰ç•ªç›®ã®æ–‡å­—ã¯ ``t`` ã§ãªã„ã€‚ã“ã‚Œã¯ ``foo.bar`` ã‚’å—ã‘ä»˜ã‘ã¾ã™ãŒã€ "
"``autoexec.bat`` ã¯æ‹’å¦ã—ã¾ã™ã€‚ã—ã‹ã—ã€ä¸‰æ–‡å­—ã®æ‹¡å¼µå­ã‚’è¦æ±‚ã—ã€ ``sendmail.cf`` "
"ã®ã‚ˆã†ãªäºŒæ–‡å­—ã®æ‹¡å¼µå­ã‚’å—ã‘ä»˜ã‘ã¾ã›ã‚“ã€‚ã“ã‚Œã‚’ä¿®æ­£ã™ã‚‹ã®ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å†ã³è¤‡é›‘ã«ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/regex.rst:1021
msgid "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"
msgstr "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"

#: ../../howto/regex.rst:1023
msgid ""
"In the third attempt, the second and third letters are all made optional in "
"order to allow matching extensions shorter than three characters, such as "
"``sendmail.cf``."
msgstr ""
"ä¸‰ç•ªç›®ã®è©¦ã¿ã§ã¯ã€ ``sendmail.cf`` ã®ã‚ˆã†ã«ä¸‰æ–‡å­—ã‚ˆã‚ŠçŸ­ã„æ‹¡å¼µå­ã¨ãƒãƒƒãƒã™ã‚‹ãŸã‚ã«ç¬¬äºŒç¬¬ä¸‰ã®æ–‡å­—ã‚’å…¨ã¦ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«ã—ã¦ã„ã¾ã™ã€‚"

#: ../../howto/regex.rst:1027
msgid ""
"The pattern's getting really complicated now, which makes it hard to read "
"and understand.  Worse, if the problem changes and you want to exclude both "
"``bat`` and ``exe`` as extensions, the pattern would get even more "
"complicated and confusing."
msgstr ""
"ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã•ã‚‰ã«è¤‡é›‘ã•ã‚’å¢—ã—ã€èª­ã¿ã«ããã€ç†è§£ãŒé›£ã—ããªã‚Šã¾ã—ãŸã€‚ã‚ˆã‚Šæ‚ªã„ã“ã¨ã«ã€å•é¡ŒãŒ ``bat`` ã¨ ``exe`` "
"ä¸¡æ–¹ã‚’æ‹¡å¼µå­ã‹ã‚‰é™¤ããŸã„å ´åˆã«å¤‰ã‚ã£ãŸå ´åˆã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã‚ˆã‚Šè¤‡é›‘ã§æ··ä¹±ã—ã‚„ã™ã„ã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/regex.rst:1032
msgid "A negative lookahead cuts through all this confusion:"
msgstr "å¦å®šå…ˆèª­ã¿ã¯ã“ã®æ··ä¹±å…¨ã¦ã‚’å–ã‚Šé™¤ãã¾ã™:"

#: ../../howto/regex.rst:1034
msgid ""
"``.*[.](?!bat$)[^.]*$``  The negative lookahead means: if the expression "
"``bat`` doesn't match at this point, try the rest of the pattern; if "
"``bat$`` does match, the whole pattern will fail.  The trailing ``$`` is "
"required to ensure that something like ``sample.batch``, where the extension"
" only starts with ``bat``, will be allowed.  The ``[^.]*`` makes sure that "
"the pattern works when there are multiple dots in the filename."
msgstr ""
"``.*[.](?!bat$)[^.]*$`` å¦å®šå…ˆèª­ã¿ã¯ä»¥ä¸‹ã‚’æ„å‘³ã—ã¾ã™: ã“ã®ä½ç½®ã§æ‹¡å¼µå­ ``bat`` ã«ãƒãƒƒãƒã—ãªã„å ´åˆã€æ®‹ã‚Šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒè©¦è¡Œã•ã‚Œã¾ã™; ã‚‚ã— ``bat$`` ã«ãƒãƒƒãƒã™ã‚Œã°ãƒ‘ã‚¿ãƒ¼ãƒ³å…¨ä½“ãŒå¤±æ•—ã—ã¾ã™ã€‚``$`` ã‚’ç¶šã‘ã‚‹ã“ã¨ã§ã€``sample.batch`` ã«ã‚ˆã†ã« ``bat`` ã§å§‹ã¾ã‚‹æ‹¡å¼µå­ã‚’è¨±å®¹ã™ã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¦ã„ã¾ã™ã€‚\n"
"ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ ``[^.]*`` ã‚’ä½¿ã†ã“ã¨ã§ã€ãƒ•ã‚¡ã‚¤ãƒ«åã«è¤‡æ•°ã®ãƒ‰ãƒƒãƒˆãŒã‚ã£ãŸã¨ãã«ã‚‚ä¸Šæ‰‹ãã„ãã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/regex.rst:1041
msgid ""
"Excluding another filename extension is now easy; simply add it as an "
"alternative inside the assertion.  The following pattern excludes filenames "
"that end in either ``bat`` or ``exe``:"
msgstr ""
"ä»–ã®ãƒ•ã‚¡ã‚¤ãƒ«åã®æ‹¡å¼µå­ã‚’é™¤ãã“ã¨ã‚‚ç°¡å˜ã§ã™; å˜ç´”ã«ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³å†…ã«æ‹¡å¼µå­ã‚’ä»£æ›¿ (or) ã§åŠ ãˆã¾ã™ã€‚ä»¥ä¸‹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ ``bat`` ã‚„ "
"``exe`` ã®ã©ã¡ã‚‰ã‹ã§çµ‚ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«åã‚’é™¤å¤–ã—ã¾ã™:"

#: ../../howto/regex.rst:1045
msgid "``.*[.](?!bat$|exe$)[^.]*$``"
msgstr "``.*[.](?!bat$|exe$)[^.]*$``"

#: ../../howto/regex.rst:1049
msgid "Modifying Strings"
msgstr "æ–‡å­—åˆ—ã‚’å¤‰æ›´ã™ã‚‹"

#: ../../howto/regex.rst:1051
msgid ""
"Up to this point, we've simply performed searches against a static string. "
"Regular expressions are also commonly used to modify strings in various "
"ways, using the following pattern methods:"
msgstr ""
"ã“ã“ã¾ã§ã§ã¯å˜ç´”ã«é™çš„ãªæ–‡å­—åˆ—ã«å¯¾ã™ã‚‹æ¤œç´¢ã‚’å®Ÿè¡Œã—ã¦ãã¾ã—ãŸã€‚æ­£è¦è¡¨ç¾ã¯æ–‡å­—åˆ—ã‚’æ§˜ã€…ãªæ–¹æ³•ã§å¤‰æ›´ã™ã‚‹ã®ã«ã‚‚ã‚ˆãä½¿ã‚ã‚Œã¾ã™ã€‚å¤‰æ›´ã«ã¯ä»¥ä¸‹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ¡ã‚½ãƒƒãƒ‰ãŒåˆ©ç”¨ã•ã‚Œã¾ã™:"

#: ../../howto/regex.rst:1058
msgid "``split()``"
msgstr "``split()``"

#: ../../howto/regex.rst:1058
msgid "Split the string into a list, splitting it wherever the RE matches"
msgstr "æ–‡å­—åˆ—ã‚’ãƒªã‚¹ãƒˆã«åˆ†å‰²ã™ã‚‹ã€æ­£è¦è¡¨ç¾ãŒãƒãƒƒãƒã—ãŸå…¨ã¦ã®å ´æ‰€ã§åˆ†å‰²ã‚’è¡Œã†"

#: ../../howto/regex.rst:1061
msgid "``sub()``"
msgstr "``sub()``"

#: ../../howto/regex.rst:1061
msgid ""
"Find all substrings where the RE matches, and replace them with a different "
"string"
msgstr "æ­£è¦è¡¨ç¾ã«ãƒãƒƒãƒã—ãŸå…¨ã¦ã®æ–‡å­—åˆ—ã‚’ç™ºè¦‹ã—ã€åˆ¥ã®æ–‡å­—åˆ—ã«ç½®ãæ›ãˆã¾ã™"

#: ../../howto/regex.rst:1064
msgid "``subn()``"
msgstr "``subn()``"

#: ../../howto/regex.rst:1064
msgid ""
"Does the same thing as :meth:`!sub`,  but returns the new string and the "
"number of replacements"
msgstr ""

#: ../../howto/regex.rst:1071
msgid "Splitting Strings"
msgstr "æ–‡å­—åˆ—ã®åˆ†å‰²"

#: ../../howto/regex.rst:1073
msgid ""
"The :meth:`~re.Pattern.split` method of a pattern splits a string apart "
"wherever the RE matches, returning a list of the pieces. It's similar to the"
" :meth:`~str.split` method of strings but provides much more generality in "
"the delimiters that you can split by; string :meth:`!split` only supports "
"splitting by whitespace or by a fixed string.  As you'd expect, there's a "
"module-level :func:`re.split` function, too."
msgstr ""

#: ../../howto/regex.rst:1084
msgid ""
"Split *string* by the matches of the regular expression.  If capturing "
"parentheses are used in the RE, then their contents will also be returned as"
" part of the resulting list.  If *maxsplit* is nonzero, at most *maxsplit* "
"splits are performed."
msgstr ""
"*string* ã‚’æ­£è¦è¡¨ç¾ã®ãƒãƒƒãƒã§åˆ†å‰²ã—ã¾ã™ã€‚æ­£è¦è¡¨ç¾å†…ã«å–ã‚Šè¾¼ã‚€ãŸã‚ã®æ‹¬å¼§ãŒåˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®å†…å®¹ã‚‚çµæœã®ãƒªã‚¹ãƒˆã®ä¸€éƒ¨ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚ "
"*maxsplit* ãŒéã‚¼ãƒ­ã®å ´åˆã€æœ€å¤§ã§ *maxsplit* ã®åˆ†å‰²ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../howto/regex.rst:1089
msgid ""
"You can limit the number of splits made, by passing a value for *maxsplit*. "
"When *maxsplit* is nonzero, at most *maxsplit* splits will be made, and the "
"remainder of the string is returned as the final element of the list.  In "
"the following example, the delimiter is any sequence of non-alphanumeric "
"characters. ::"
msgstr ""
"*maxsplit* ã«å€¤ã‚’æ¸¡ã™ã“ã¨ã§ã€åˆ†å‰²ã•ã‚Œã‚‹å›æ•°ã‚’åˆ¶é™ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ *maxsplit* ãŒéã‚¼ãƒ­ã®å ´åˆã€æœ€å¤§ã§ *maxsplit* "
"ã®åˆ†å‰²ãŒè¡Œãªã‚ã‚Œã€æ–‡å­—åˆ—ã®æ®‹ã‚ŠãŒãƒªã‚¹ãƒˆã®æœ€çµ‚è¦ç´ ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚ä»¥ä¸‹ã®ä¾‹ã§ã¯ã€ãƒ‡ãƒªãƒŸã‚¿ã¯ä»»æ„ã®è‹±æ•°æ–‡å­—ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã™ã€‚ ::"

#: ../../howto/regex.rst:1101
msgid ""
"Sometimes you're not only interested in what the text between delimiters is,"
" but also need to know what the delimiter was.  If capturing parentheses are"
" used in the RE, then their values are also returned as part of the list.  "
"Compare the following calls::"
msgstr ""
"èˆˆå‘³ã®å¯¾è±¡ãŒãƒ‡ãƒªãƒŸã‚¿ã®é–“ã®ãƒ†ã‚­ã‚¹ãƒˆã ã‘ã§ãªãã€ãƒ‡ãƒªãƒŸã‚¿ãŒä½•ãªã®ã‹ã¨ã„ã†ã“ã¨ã‚’çŸ¥ã‚ŠãŸã„å ´åˆã¯ã‚ˆãã‚ã‚Šã¾ã™ã€‚å–ã‚Šã“ã¿ç”¨ã®æ‹¬å¼§ã‚’æ­£è¦è¡¨ç¾ã«ä½¿ã£ãŸå ´åˆã€ãã®å€¤ã‚‚ãƒªã‚¹ãƒˆã®ä¸€éƒ¨ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚ä»¥ä¸‹ã®å‘¼ã³å‡ºã—ã‚’æ¯”è¼ƒã—ã¦ã¿ã¾ã—ã‚‡ã†::"

#: ../../howto/regex.rst:1113
msgid ""
"The module-level function :func:`re.split` adds the RE to be used as the "
"first argument, but is otherwise the same.   ::"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«é–¢æ•° :func:`re.split` ã¯æœ€åˆã®å¼•æ•°ã«åˆ©ç”¨ã™ã‚‹æ­£è¦è¡¨ç¾ã‚’è¿½åŠ ã—ã¾ã™ãŒã€ãã‚Œä»¥å¤–ã¯åŒã˜ã§ã™ã€‚ ::"

#: ../../howto/regex.rst:1125
msgid "Search and Replace"
msgstr "æ¤œç´¢ã¨ç½®æ›"

#: ../../howto/regex.rst:1127
msgid ""
"Another common task is to find all the matches for a pattern, and replace "
"them with a different string.  The :meth:`~re.Pattern.sub` method takes a "
"replacement value, which can be either a string or a function, and the "
"string to be processed."
msgstr ""

#: ../../howto/regex.rst:1134
msgid ""
"Returns the string obtained by replacing the leftmost non-overlapping "
"occurrences of the RE in *string* by the replacement *replacement*.  If the "
"pattern isn't found, *string* is returned unchanged."
msgstr ""
"*string* å†…ã§æœ€ã‚‚é•·ãã€ä»–ã®éƒ¨åˆ†ã¨é‡è¤‡ã™ã‚‹ã¨ã“ã‚ãŒãªã„æ­£è¦è¡¨ç¾ã‚’ã‚’ *replacement* "
"ã«ç½®æ›ã—ãŸæ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ *string* ã¯å¤‰æ›´ã•ã‚Œãšã«è¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../howto/regex.rst:1138
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  The default value "
"of 0 means to replace all occurrences."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *count* ã¯ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å‡ºç¾ã®æœ€å¤§ç½®æ›å›æ•°ã§ã™; *count* ã¯éè² ã®æ•´æ•°ã§ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ 0 "
"ã¯å…¨ã¦ã®å‡ºç¾ã§ç½®æ›ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:1142
msgid ""
"Here's a simple example of using the :meth:`~re.Pattern.sub` method.  It "
"replaces colour names with the word ``colour``::"
msgstr ""

#: ../../howto/regex.rst:1151
msgid ""
"The :meth:`~re.Pattern.subn` method does the same work, but returns a "
"2-tuple containing the new string value and the number of replacements  that"
" were performed::"
msgstr ""

#: ../../howto/regex.rst:1160
msgid ""
"Empty matches are replaced only when they're not adjacent to a previous "
"empty match. ::"
msgstr ""

#: ../../howto/regex.rst:1167
msgid ""
"If *replacement* is a string, any backslash escapes in it are processed.  "
"That is, ``\\n`` is converted to a single newline character, ``\\r`` is "
"converted to a carriage return, and so forth. Unknown escapes such as "
"``\\&`` are left alone. Backreferences, such as ``\\6``, are replaced with "
"the substring matched by the corresponding group in the RE.  This lets you "
"incorporate portions of the original text in the resulting replacement "
"string."
msgstr ""
"*replacement* ãŒæ–‡å­—åˆ—ã®å ´åˆã€æ–‡å­—åˆ—å†…ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯å‡¦ç†ã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šã€``\\n`` ã¯æ”¹è¡Œæ–‡å­—ã« ``\\r`` "
"ã¯ã‚­ãƒ£ãƒªãƒƒã‚¸ãƒªã‚¿ãƒ¼ãƒ³ã«ã€ç­‰ã¨ãªã‚Šã¾ã™ã€‚``\\&`` ã®ã‚ˆã†ãªæœªçŸ¥ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ãã®ã¾ã¾æ®‹ã•ã‚Œã¾ã™ã€‚``\\6`` "
"ã®ã‚ˆã†ãªå¾Œæ–¹å‚ç…§ã¯æ­£è¦è¡¨ç¾å†…ã®å¯¾å¿œã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã«ãƒãƒƒãƒã™ã‚‹æ–‡å­—åˆ—ã«ç½®æ›ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚’ä½¿ã†ã“ã¨ã§å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã®ä¸€éƒ¨ã‚’ã€ç½®æ›å¾Œã®æ–‡å­—åˆ—ã«çµ„ã¿è¾¼ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../howto/regex.rst:1174
msgid ""
"This example matches the word ``section`` followed by a string enclosed in "
"``{``, ``}``, and changes ``section`` to ``subsection``::"
msgstr ""
"ã“ã®ä¾‹ã¯å˜èª ``section`` ã«ç¶šã ``{`` ã¨ ``}`` ã§é–‰ã˜ã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã«ãƒãƒƒãƒã—ã€ ``section`` ã‚’ "
"``subsection`` ã«å¤‰æ›´ã—ã¾ã™::"

#: ../../howto/regex.rst:1181
msgid ""
"There's also a syntax for referring to named groups as defined by the "
"``(?P<name>...)`` syntax.  ``\\g<name>`` will use the substring matched by "
"the group named ``name``, and  ``\\g<number>``  uses the corresponding group"
" number. ``\\g<2>`` is therefore equivalent to ``\\2``,  but isn't ambiguous"
" in a replacement string such as ``\\g<2>0``.  (``\\20`` would be "
"interpreted as a reference to group 20, not a reference to group 2 followed "
"by the literal character ``'0'``.)  The following substitutions are all "
"equivalent, but use all three variations of the replacement string. ::"
msgstr ""
"``(?P<name>...)`` æ§‹æ–‡ã§å®šç¾©ã•ã‚ŒãŸåå‰ã¤ãã‚°ãƒ«ãƒ¼ãƒ—ã‚’å‚ç…§ã™ã‚‹ãŸã‚ã®æ§‹æ–‡ã‚‚ã‚ã‚Šã¾ã™ã€‚ ``\\g<name>`` ã¯ ``name`` "
"ã§åå‰ã¥ã‘ã•ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ—ã«ãƒãƒƒãƒã™ã‚‹æ–‡å­—åˆ—ã‚’åˆ©ç”¨ã—ã€ ``\\g<number>`` ã¯å¯¾å¿œã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ç•ªå·ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚ã¤ã¾ã‚Š ``\\g<2>`` "
"ã¯ ``\\2`` ã¨ç­‰ä¾¡ã§ã™ãŒã€ ``\\g<2>0`` ã®ã‚ˆã†ãªç½®æ›æ–‡å­—åˆ—ã«å¯¾ã—ã¦ã¯æ˜ç¢ºã«ç•°ãªã‚Šã¾ã™ã€‚ (``\\20`` "
"ã¯ã‚°ãƒ«ãƒ¼ãƒ—ç•ªå·20ã¸ã®å‚ç…§ã¨è§£é‡ˆã•ã‚Œã€ã‚°ãƒ«ãƒ¼ãƒ—2ã®å¾Œã«ãƒªãƒ†ãƒ©ãƒ«æ–‡å­— ``'0'`` ãŒç¶šãã¨ã¯è§£é‡ˆã•ã‚Œã¾ã›ã‚“ã€‚) "
"ä»¥ä¸‹ã«ç¤ºã™ç½®æ›ã¯å…¨ã¦ç­‰ä¾¡ã§ã™ãŒã€ã“ã‚Œã‚‰ã¯æ–‡å­—åˆ—ç½®æ›ã«å…¨éƒ¨ã§3ç¨®ã®å¤‰ç¨®ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚ ::"

#: ../../howto/regex.rst:1198
msgid ""
"*replacement* can also be a function, which gives you even more control.  If"
" *replacement* is a function, the function is called for every non-"
"overlapping occurrence of *pattern*.  On each call, the function is passed a"
" :ref:`match object <match-objects>` argument for the match and can use this"
" information to compute the desired replacement string and return it."
msgstr ""
"ã‚ˆã‚Šç´°ã‹ãªåˆ¶å¾¡ã‚’æ‰‹ä¸­ã«ã™ã‚‹ãŸã‚ã« *replacement* ã¨ã—ã¦é–¢æ•°ã‚’ä½¿ã†ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚ *replacement* "
"ãŒé–¢æ•°ã§ã‚ã‚Œã°ã€ãã®é–¢æ•°ã¯é‡ãªã‚Šåˆã‚ãªã„ *pattern* ã®ç™ºç”Ÿã®ãŸã³ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ãã‚Œãã‚Œã®å‘¼ã³å‡ºã—ã§ã€ãƒãƒƒãƒã—ãŸ :ref:`Match "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <match-objects>` ãŒå¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã‚‹ã®ã§ã€æœ›ã¿ã®ç½®æ›ã¨è¿”å´ã®ãŸã‚ã«ã“ã®æƒ…å ±ã‚’åˆ©ç”¨å‡ºæ¥ã¾ã™ã€‚"

#: ../../howto/regex.rst:1204
msgid ""
"In the following example, the replacement function translates decimals into "
"hexadecimal::"
msgstr "ç¶šãä¾‹ã§ã¯ã€ç½®æ›é–¢æ•°ã¯åé€²æ•°æ–‡å­—åˆ—ã‚’åå…­é€²æ•°æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¦ã„ã¾ã™::"

#: ../../howto/regex.rst:1216
msgid ""
"When using the module-level :func:`re.sub` function, the pattern is passed "
"as the first argument.  The pattern may be provided as an object or as a "
"string; if you need to specify regular expression flags, you must either use"
" a pattern object as the first parameter, or use embedded modifiers in the "
"pattern string, e.g. ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` returns ``'x "
"x'``."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã® :func:`re.sub` é–¢æ•°ã‚’ä½¿ã†ã¨ãã«ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒæœ€åˆã®å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„æ–‡å­—åˆ—ã‚’ã¨ã‚Šã¾ã™; "
"æ­£è¦è¡¨ç¾ãƒ•ãƒ©ã‚°ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æœ€åˆã®å¼•æ•°ã¨ã—ã¦ä½¿ã†ã‹ã€ä¿®é£¾å­ã‚’åŸ‹ã‚è¾¼ã‚“ã ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­—åˆ—ã‚’ä½¿ã†ã‹ã—ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€ä¾‹ãˆã°"
" ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` ã¯ ``'x x'`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:1224
msgid "Common Problems"
msgstr "ã‚ˆãã‚ã‚‹å•é¡Œ"

#: ../../howto/regex.rst:1226
msgid ""
"Regular expressions are a powerful tool for some applications, but in some "
"ways their behaviour isn't intuitive and at times they don't behave the way "
"you may expect them to.  This section will point out some of the most common"
" pitfalls."
msgstr ""
"æ­£è¦è¡¨ç¾ã¯ã„ãã¤ã‹ã®å¿œç”¨ã«å¯¾ã—ã¦å¼·åŠ›ãªãƒ„ãƒ¼ãƒ«ã§ã™ãŒã€ã„ãã¤ã‹ã®éƒ¨åˆ†ã§ãã‚Œã‚‰ã®æŒ¯ã‚‹èˆã„ã¯ç›´æ„Ÿçš„ã§ã¯ãªãã€æœŸå¾…é€šã‚Šã«æŒ¯ã‚‹èˆã‚ãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ç¯€ã§ã¯æœ€ã‚‚ã‚ˆãã‚ã‚‹è½ã¨ã—ç©´ã‚’æŒ‡æ‘˜ã—ã¾ã™ã€‚"

#: ../../howto/regex.rst:1232
msgid "Use String Methods"
msgstr "æ–‡å­—åˆ—ãƒ¡ã‚½ãƒƒãƒ‰ã‚’åˆ©ç”¨ã™ã‚‹"

#: ../../howto/regex.rst:1234
msgid ""
"Sometimes using the :mod:`re` module is a mistake.  If you're matching a "
"fixed string, or a single character class, and you're not using any "
":mod:`re` features such as the :const:`~re.IGNORECASE` flag, then the full "
"power of regular expressions may not be required. Strings have several "
"methods for performing operations with fixed strings and they're usually "
"much faster, because the implementation is a single small C loop that's been"
" optimized for the purpose, instead of the large, more generalized regular "
"expression engine."
msgstr ""

#: ../../howto/regex.rst:1242
msgid ""
"One example might be replacing a single fixed string with another one; for "
"example, you might replace ``word`` with ``deed``.  :func:`re.sub` seems "
"like the function to use for this, but consider the :meth:`~str.replace` "
"method.  Note that :meth:`!replace` will also replace ``word`` inside words,"
" turning ``swordfish`` into ``sdeedfish``, but the  naive RE ``word`` would "
"have done that, too.  (To avoid performing the substitution on parts of "
"words, the pattern would have to be ``\\bword\\b``, in order to require that"
" ``word`` have a word boundary on either side.  This takes the job beyond  "
":meth:`!replace`'s abilities.)"
msgstr ""

#: ../../howto/regex.rst:1251
msgid ""
"Another common task is deleting every occurrence of a single character from "
"a string or replacing it with another single character.  You might do this "
"with something like ``re.sub('\\n', ' ', S)``, but :meth:`~str.translate` is"
" capable of doing both tasks and will be faster than any regular expression "
"operation can be."
msgstr ""

#: ../../howto/regex.rst:1257
msgid ""
"In short, before turning to the :mod:`re` module, consider whether your "
"problem can be solved with a faster and simpler string method."
msgstr "è¦ã¯ã€ :mod:`re` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å‘ã†å‰ã«å•é¡ŒãŒé«˜é€Ÿã§å˜ç´”ãªæ–‡å­—åˆ—ãƒ¡ã‚½ãƒƒãƒ‰ã§è§£æ±ºã§ãã‚‹ã‹è€ƒãˆã¾ã—ã‚‡ã†ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../howto/regex.rst:1262
msgid "match() versus search()"
msgstr "match() å¯¾ search()"

#: ../../howto/regex.rst:1264
msgid ""
"The :func:`~re.match` function only checks if the RE matches at the "
"beginning of the string while :func:`~re.search` will scan forward through "
"the string for a match. It's important to keep this distinction in mind.  "
"Remember,  :func:`!match` will only report a successful match which will "
"start at 0; if the match wouldn't start at zero,  :func:`!match` will *not* "
"report it. ::"
msgstr ""

#: ../../howto/regex.rst:1275
msgid ""
"On the other hand, :func:`~re.search` will scan forward through the string, "
"reporting the first match it finds. ::"
msgstr ""

#: ../../howto/regex.rst:1283
msgid ""
"Sometimes you'll be tempted to keep using :func:`re.match`, and just add "
"``.*`` to the front of your RE.  Resist this temptation and use "
":func:`re.search` instead.  The regular expression compiler does some "
"analysis of REs in order to speed up the process of looking for a match.  "
"One such analysis figures out what the first character of a match must be; "
"for example, a pattern starting with ``Crow`` must match starting with a "
"``'C'``.  The analysis lets the engine quickly scan through the string "
"looking for the starting character, only trying the full match if a ``'C'`` "
"is found."
msgstr ""
"ã—ã°ã—ã°ã€ :func:`re.match` ã‚’ä½¿ã„ã€ ``.*`` "
"ã‚’æ­£è¦è¡¨ç¾ã®æœ€åˆã«ä»˜ã‘åŠ ãˆã‚‹èª˜æƒ‘ã«ã‹ã‚‰ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ã§ã—ã‚‡ã†ã€‚ã“ã®èª˜æƒ‘ã«æ‰“ã¡å…‹ã£ã¦ã€ä»£ã‚ã‚Šã« :func:`re.search` "
"ã‚’åˆ©ç”¨ã™ã¹ãã§ã™ã€‚æ­£è¦è¡¨ç¾ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ãƒãƒƒãƒã‚’æ¢ã™å‡¦ç†ã®é«˜é€ŸåŒ–ã®ãŸã‚ã«ã„ãã¤ã‹ã®è§£æã‚’è¡Œã„ã¾ã™ã€‚ãã®ã‚ˆã†ãªè§£æã®ã†ã¡ã®ã²ã¨ã¤ã¯ãƒãƒƒãƒã®æœ€åˆã®æ–‡å­—ãŒä½•ã§ã‚ã‚‹ã‹è©•ä¾¡ã™ã‚‹ã“ã¨ã§ã™;"
" ä¾‹ãˆã°ã€ ``Crow`` ã§å§‹ã¾ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ ``'C'`` "
"ã‹ã‚‰å§‹ã¾ã‚‰ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚è§£æã«ã‚ˆã£ã¦ã‚¨ãƒ³ã‚¸ãƒ³ã¯é€Ÿã‚„ã‹ã«é–‹å§‹æ–‡å­—ã‚’æ¢ã—ã¦èµ°æŸ»ã—ã¾ã™ã€ ``'C'`` "
"ãŒç™ºè¦‹ã•ã‚ŒãŸå ´åˆã«ã¯ã˜ã‚ã¦å®Œå…¨ãªãƒãƒƒãƒã‚’è©¦ã¿ã¾ã™ã€‚"

#: ../../howto/regex.rst:1292
msgid ""
"Adding ``.*`` defeats this optimization, requiring scanning to the end of "
"the string and then backtracking to find a match for the rest of the RE.  "
"Use :func:`re.search` instead."
msgstr ""
"``.*`` "
"ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã¯ã“ã®æœ€é©åŒ–ã‚’ç„¡åŠ¹ã«ã—ã¾ã™ã€æ–‡å­—åˆ—ã®çµ‚ç«¯ã¾ã§ã®èµ°æŸ»ãŒå¿…è¦ã¨ãªã‚Šã€èµ°æŸ»å¾Œã«ã¯æ®‹ã‚Šã®æ­£è¦è¡¨ç¾ã¨ã®ãƒãƒƒãƒéƒ¨åˆ†ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«å¼•ãè¿”ã™ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ä»£ã‚ã‚Šã«"
" :func:`re.search` ã‚’åˆ©ç”¨ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../howto/regex.rst:1298
msgid "Greedy versus Non-Greedy"
msgstr "è²ªæ¬² (greedy) å¯¾éè²ªæ¬² (non-greedy)"

#: ../../howto/regex.rst:1300
msgid ""
"When repeating a regular expression, as in ``a*``, the resulting action is "
"to consume as much of the pattern as possible.  This fact often bites you "
"when you're trying to match a pair of balanced delimiters, such as the angle"
" brackets surrounding an HTML tag.  The naive pattern for matching a single "
"HTML tag doesn't work because of the greedy nature of ``.*``. ::"
msgstr ""
"æ­£è¦è¡¨ç¾ã‚’ç¹°ã‚Šè¿”ã™å ´åˆã€ãŸã¨ãˆã° ``a*`` "
"ã®ã‚ˆã†ã«ã€ã§ãã‚‹ã ã‘ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å¤šãã«ãƒãƒƒãƒã™ã‚‹ã‚ˆã†ã«å‹•ä½œã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã“ã®å‹•ä½œã¯ã€ä¾‹ãˆã°è§’æ‹¬å¼§ã§å›²ã¾ã‚ŒãŸ HTML "
"ã‚¿ã‚°ã®ã‚ˆã†ãªå·¦å³å¯¾ç§°ã®ãƒ‡ãƒªãƒŸã‚¿ã®å¯¾ã«ãƒãƒƒãƒã—ã‚ˆã†ã¨ã„ã†å ´åˆã«å•é¡Œã¨ãªã‚Šã¾ã™ã€‚å˜ä¸€ã® HTML "
"ã‚¿ã‚°ã«ãƒãƒƒãƒã™ã‚‹ç´ æœ´ãªæ­£è¦è¡¨ç¾ã¯ã†ã¾ãå‹•ä½œã—ã¾ã›ã‚“ã€ãªãœãªã‚‰ã° ``.*`` ã¯è²ªæ¬²ã«å‹•ä½œã™ã‚‹ã‹ã‚‰ã§ã™ã€‚ ::"

#: ../../howto/regex.rst:1314
msgid ""
"The RE matches the ``'<'`` in ``'<html>'``, and the ``.*`` consumes the rest"
" of the string.  There's still more left in the RE, though, and the ``>`` "
"can't match at the end of the string, so the regular expression engine has "
"to backtrack character by character until it finds a match for the ``>``.   "
"The final match extends from the ``'<'`` in ``'<html>'`` to the ``'>'`` in "
"``'</title>'``, which isn't what you want."
msgstr ""

#: ../../howto/regex.rst:1321
msgid ""
"In this case, the solution is to use the non-greedy qualifiers ``*?``, "
"``+?``, ``??``, or ``{m,n}?``, which match as *little* text as possible.  In"
" the above example, the ``'>'`` is tried immediately after the first ``'<'``"
" matches, and when it fails, the engine advances a character at a time, "
"retrying the ``'>'`` at every step.  This produces just the right result::"
msgstr ""
"ã“ã®å ´åˆã€è§£æ±ºæ³•ã¯éè²ªæ¬²ã‚’ç¤ºã™ä¿®é£¾å­ ``*?``, ``+?``, ``??`` ã¾ãŸã¯ ``{m,n}?`` "
"ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã™ã€ã“ã‚Œã‚‰ã¯ãƒ†ã‚­ã‚¹ãƒˆã«å¯èƒ½ãªé™ã‚Š *å°‘ãªã* ãƒãƒƒãƒã—ã¾ã™ã€‚ä¸Šã®ä¾‹ã§ã¯ã€ ``'>'`` ã¯æœ€åˆã® ``'<'`` ã¨ã®ãƒãƒƒãƒå¾Œã™ãã« "
"``'>'`` ã‚’è©¦ã¿ã¾ã€å¤±æ•—ã—ãŸå ´åˆã«ã¯ã‚¨ãƒ³ã‚¸ãƒ³ãŒæ–‡å­—ã‚’å…ˆã«é€²ã‚ã€``'>'`` ãŒæ¯ã‚¹ãƒ†ãƒƒãƒ—å†è©¦è¡Œã•ã‚Œã¾ã™ã€‚ã“ã®å‹•ä½œã¯æ­£ã—ã„çµæœã‚’ç”Ÿã¿å‡ºã—ã¾ã™::"

#: ../../howto/regex.rst:1330
msgid ""
"(Note that parsing HTML or XML with regular expressions is painful. Quick-"
"and-dirty patterns will handle common cases, but HTML and XML have special "
"cases that will break the obvious regular expression; by the time you've "
"written a regular expression that handles all of the possible cases, the "
"patterns will be *very* complicated.  Use an HTML or XML parser module for "
"such tasks.)"
msgstr ""
"(HTML ã‚„ XML "
"ã‚’æ­£è¦è¡¨ç¾ã§ãƒ‘ãƒ¼ã‚¹ã™ã‚‹ã“ã¨ã¯è‹¦ç—›ã‚’ä¼´ã†ã‚‚ã®ã§ã‚ã‚‹ã“ã¨ã¯è¨˜æ†¶ã«ç•™ã‚ã¦ãŠã„ã¦ä¸‹ã•ã„ã€‚ç´ æ—©ãã€æ±šã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯å¤§æŠµã®å ´åˆã†ã¾ãå‹•ä½œã—ã¾ã™ãŒã€HTML ã¨ XML"
" ã¯æ­£è¦è¡¨ç¾ãŒç ´ç¶»ã™ã‚‹ç‰¹åˆ¥ãªä¾‹ã§ã™; å…¨ã¦ã®å¯èƒ½ãªå ´åˆã«ã†ã¾ãå‹•ä½œã™ã‚‹æ­£è¦è¡¨ç¾ã‚’æ›¸ãä¸Šã’ãŸã¨ãã«ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ *éå¸¸ã«* "
"è¤‡é›‘ãªã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚ãã®ã‚ˆã†ãªä½œæ¥­ã‚’ã™ã‚‹å ´åˆã«ã¯ HTML ã‚„ XML ãƒ‘ãƒ¼ã‚µã‚’åˆ©ç”¨ã—ã¾ã—ã‚‡ã†ã€‚)"

#: ../../howto/regex.rst:1338
msgid "Using re.VERBOSE"
msgstr "re.VERBOSE ã®åˆ©ç”¨"

#: ../../howto/regex.rst:1340
msgid ""
"By now you've probably noticed that regular expressions are a very compact "
"notation, but they're not terribly readable.  REs of moderate complexity can"
" become lengthy collections of backslashes, parentheses, and metacharacters,"
" making them difficult to read and understand."
msgstr ""
"ã“ã“ã¾ã§ã§ã€æ­£è¦è¡¨ç¾ãŒã¨ã¦ã‚‚ç°¡æ½”ãªè¡¨è¨˜ã§ã‚ã‚‹ã“ã¨ã«æ°—ã¥ã„ãŸã§ã—ã‚‡ã†ã€ã¾ãŸã€æ­£è¦è¡¨ç¾ã¯èª­ã¿ã‚„ã™ã„ã‚‚ã®ã§ã‚‚ãªã„ã¨ã„ã†ã“ã¨ã«ã‚‚æ°—ã¥ã„ãŸã“ã¨ã§ã—ã‚‡ã†ã€‚ãã“ãã“ã«å…¥ã‚Šçµ„ã‚“ã æ­£è¦è¡¨ç¾ã¯ã¯ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã€æ‹¬å¼§ã€ç‰¹æ®Šæ–‡å­—ãŒé•·ãç¶šã„ã¦ã€èª­ã¿ã«ããã€ç†è§£ã—ã¥ã‚‰ã„ã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/regex.rst:1345
msgid ""
"For such REs, specifying the :const:`re.VERBOSE` flag when compiling the "
"regular expression can be helpful, because it allows you to format the "
"regular expression more clearly."
msgstr ""

#: ../../howto/regex.rst:1349
msgid ""
"The ``re.VERBOSE`` flag has several effects.  Whitespace in the regular "
"expression that *isn't* inside a character class is ignored.  This means "
"that an expression such as ``dog | cat`` is equivalent to the less readable "
"``dog|cat``, but ``[a b]`` will still match the characters ``'a'``, ``'b'``,"
" or a space.  In addition, you can also put comments inside a RE; comments "
"extend from a ``#`` character to the next newline.  When used with triple-"
"quoted strings, this enables REs to be formatted more neatly::"
msgstr ""
"``re.VERBOSE`` ã®åŠ¹æœã¯ã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚æ­£è¦è¡¨ç¾å†…ã®æ–‡å­—ã‚¯ãƒ©ã‚¹å†…ã« *ç„¡ã„* ç©ºç™½ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ ``dog | cat`` "
"ã®ã‚ˆã†ãªè¡¨ç¾ãŒå°‘ã€…å¯èª­æ€§ã®è½ã¡ã‚‹ ``dog|cat`` ã¨ç­‰ä¾¡ã¨ãªã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€ã—ã‹ã—ã€ ``[a b]`` ã¯ä¾ç„¶ã¨ã—ã¦ ``'a'``, "
"``'b'``, ã¾ãŸã¯ç©ºç™½ã«ãƒãƒƒãƒã—ã¾ã™ã€‚åŠ ãˆã¦ã€æ­£è¦è¡¨ç¾ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’å…¥ã‚Œã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™; ``#`` "
"æ–‡å­—ã‹ã‚‰æ¬¡ã®æ”¹è¡Œã¾ã§ãŒã‚³ãƒ¡ãƒ³ãƒˆã®ç¯„å›²ã§ã™ã€‚ä¸‰é‡ã‚¯ã‚©ãƒ¼ãƒˆã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€æ­£è¦è¡¨ç¾ã‚’ãã¡ã‚“ã¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../howto/regex.rst:1366
msgid "This is far more readable than::"
msgstr "ã“ã‚Œã¯ä¸‹ã‚ˆã‚Šã¯ã‚‹ã‹ã«èª­ã¿ã‚„ã™ã„ã§ã™::"

#: ../../howto/regex.rst:1372
msgid "Feedback"
msgstr "ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯"

#: ../../howto/regex.rst:1374
msgid ""
"Regular expressions are a complicated topic.  Did this document help you "
"understand them?  Were there parts that were unclear, or Problems you "
"encountered that weren't covered here?  If so, please send suggestions for "
"improvements to the author."
msgstr ""
"æ­£è¦è¡¨ç¾ã¯è¤‡é›‘ãªè©±é¡Œã§ã™ã€‚ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯åŠ©ã‘ã«ãªã£ãŸã§ã—ã‚‡ã†ã‹ï¼Ÿã‚ã‹ã‚Šã«ãã‹ã£ãŸã¨ã“ã‚ã‚„ã€ã‚ãªãŸãŒé­é‡ã—ãŸå•é¡ŒãŒæ‰±ã‚ã‚Œã¦ã„ãªã„ç­‰ãªã‹ã£ãŸã§ã—ã‚‡ã†ã‹ï¼Ÿã‚‚ã—ãã‚“ãªå•é¡ŒãŒã‚ã‚Œã°ã€è‘—è€…ã«æ”¹å–„ã®ææ¡ˆã‚’é€ã£ã¦ä¸‹ã•ã„ã€‚"

#: ../../howto/regex.rst:1379
msgid ""
"The most complete book on regular expressions is almost certainly Jeffrey "
"Friedl's Mastering Regular Expressions, published by O'Reilly.  "
"Unfortunately, it exclusively concentrates on Perl and Java's flavours of "
"regular expressions, and doesn't contain any Python material at all, so it "
"won't be useful as a reference for programming in Python.  (The first "
"edition covered Python's now-removed :mod:`!regex` module, which won't help "
"you much.)  Consider checking it out from your library."
msgstr ""
