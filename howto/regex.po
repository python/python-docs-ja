# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2020
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 16:06+0000\n"
"PO-Revision-Date: 2020-05-30 11:54+0000\n"
"Last-Translator: tomo, 2020\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/regex.rst:5
msgid "Regular Expression HOWTO"
msgstr "正規表現 HOWTO"

#: ../../howto/regex.rst:0
msgid "Author"
msgstr "著者"

#: ../../howto/regex.rst:7
msgid "A.M. Kuchling <amk@amk.ca>"
msgstr "A.M. Kuchling <amk@amk.ca>"

#: ../../howto/regex.rstNone
msgid "Abstract"
msgstr "概要"

#: ../../howto/regex.rst:18
msgid ""
"This document is an introductory tutorial to using regular expressions in "
"Python with the :mod:`re` module.  It provides a gentler introduction than "
"the corresponding section in the Library Reference."
msgstr ""
"このドキュメントは :mod:`re` モジュールを使って Python で正規表現を扱うための"
"導入のチュートリアルです。ライブラリレファレンスの正規表現の節よりもやさしい"
"入門ドキュメントを用意しています。"

#: ../../howto/regex.rst:24
msgid "Introduction"
msgstr "はじめに"

#: ../../howto/regex.rst:26
msgid ""
"Regular expressions (called REs, or regexes, or regex patterns) are "
"essentially a tiny, highly specialized programming language embedded inside "
"Python and made available through the :mod:`re` module. Using this little "
"language, you specify the rules for the set of possible strings that you "
"want to match; this set might contain English sentences, or e-mail "
"addresses, or TeX commands, or anything you like.  You can then ask "
"questions such as \"Does this string match the pattern?\", or \"Is there a "
"match for the pattern anywhere in this string?\".  You can also use REs to "
"modify a string or to split it apart in various ways."
msgstr ""
"正規表現 regular expressions (REs や regexes または regex patterns と呼ばれま"
"す) は本質的に小さく、Python 内部に埋め込まれた高度に特化したプログラミング言"
"語で :mod:`re` モジュールから利用可能です。この小さな言語を利用することで、"
"マッチさせたい文字列に適合するような文字列の集合を指定することができます; こ"
"の集合は英文や e-mail アドレスや TeX コマンドなど、どんなものでも構いません。"
"「この文字列は指定したパターンにマッチしますか?」「このパターンはこの文字列の"
"どの部分にマッチするのですか?」といったことを問い合わせることができます。正規"
"表現を使って文字列を変更したりいろいろな方法で別々の部分に分割したりすること"
"もできます。"

#: ../../howto/regex.rst:35
msgid ""
"Regular expression patterns are compiled into a series of bytecodes which "
"are then executed by a matching engine written in C.  For advanced use, it "
"may be necessary to pay careful attention to how the engine will execute a "
"given RE, and write the RE in a certain way in order to produce bytecode "
"that runs faster. Optimization isn't covered in this document, because it "
"requires that you have a good understanding of the matching engine's "
"internals."
msgstr ""
"正規表現パターンは一連のバイトコードとしてコンパイルされ、C で書かれたマッチ"
"ングエンジンによって実行されます。より進んだ利用法では、エンジンがどう与えら"
"れた正規表現を実行するかに注意することが必要になり、高速に実行できるバイト"
"コードを生成するように正規表現を書くことになります。このドキュメントでは最適"
"化までは扱いません、それにはマッチングエンジンの内部に対する十分な理解が必要"
"だからです。"

#: ../../howto/regex.rst:42
msgid ""
"The regular expression language is relatively small and restricted, so not "
"all possible string processing tasks can be done using regular expressions.  "
"There are also tasks that *can* be done with regular expressions, but the "
"expressions turn out to be very complicated.  In these cases, you may be "
"better off writing Python code to do the processing; while Python code will "
"be slower than an elaborate regular expression, it will also probably be "
"more understandable."
msgstr ""
"正規表現言語は相対的に小さく、制限されています、そのため正規表現を使ってあら"
"ゆる文字列処理作業を行なえるわけではありません。正規表現を使って行うことので"
"きる作業もあります、ただ表現はとても複雑なものになります。それらの場合では、"
"Python コードを書いた方がいいでしょう; Python コードは念入りに作られた正規表"
"現より遅くなりますが、おそらくより読み易いでしょう。"

#: ../../howto/regex.rst:51
msgid "Simple Patterns"
msgstr "単純なパターン"

#: ../../howto/regex.rst:53
msgid ""
"We'll start by learning about the simplest possible regular expressions.  "
"Since regular expressions are used to operate on strings, we'll begin with "
"the most common task: matching characters."
msgstr ""
"まずはできるだけ簡単な正規表現を学ぶことから始めてみましょう。正規表現は文字"
"列の操作に使われるので、ますは最も一般的な作業である文字のマッチングをしてみ"
"ます。"

#: ../../howto/regex.rst:57
msgid ""
"For a detailed explanation of the computer science underlying regular "
"expressions (deterministic and non-deterministic finite automata), you can "
"refer to almost any textbook on writing compilers."
msgstr ""
"正規表現の基礎を成す計算機科学 (決定、非決定有限オートマトン) の詳細な説明に"
"ついては, コンパイラ作成に関するテキストブックをどれでもいいので参照して下さ"
"い。"

#: ../../howto/regex.rst:63
msgid "Matching Characters"
msgstr "文字のマッチング"

#: ../../howto/regex.rst:65
msgid ""
"Most letters and characters will simply match themselves.  For example, the "
"regular expression ``test`` will match the string ``test`` exactly.  (You "
"can enable a case-insensitive mode that would let this RE match ``Test`` or "
"``TEST`` as well; more about this later.)"
msgstr ""
"多くの活字や文字は単純にそれ自身とマッチします。例えば、 ``test`` という正規"
"表現は文字列 ``test`` に厳密にマッチします。(大文字小文字を区別しないモードで"
"その正規表現が ``Test`` や ``TEST`` にも同様にマッチすることもできます; 詳し"
"くは後述します。)"

#: ../../howto/regex.rst:70
msgid ""
"There are exceptions to this rule; some characters are special :dfn:"
"`metacharacters`, and don't match themselves.  Instead, they signal that "
"some out-of-the-ordinary thing should be matched, or they affect other "
"portions of the RE by repeating them or changing their meaning.  Much of "
"this document is devoted to discussing various metacharacters and what they "
"do."
msgstr ""
"この規則には例外が存在します; いくつかの文字は特別な :dfn:`特殊文字 "
"(metacharacters)` で、それら自身にマッチしません。代わりに通常のマッチするも"
"のとは違うという合図を出したり、正規表現の一部に対して繰り返したり、意味を変"
"えたりして影響を与えます。このドキュメントの中の多くは様々な特殊文字とそれが"
"何をするかについて論じることになります。"

#: ../../howto/regex.rst:76
msgid ""
"Here's a complete list of the metacharacters; their meanings will be "
"discussed in the rest of this HOWTO."
msgstr ""
"ここに特殊文字の完全な一覧があります; これらの意味はこの HOWTO の残りの部分で"
"説明します。"

#: ../../howto/regex.rst:83
msgid ""
"The first metacharacters we'll look at are ``[`` and ``]``. They're used for "
"specifying a character class, which is a set of characters that you wish to "
"match.  Characters can be listed individually, or a range of characters can "
"be indicated by giving two characters and separating them by a ``'-'``.  For "
"example, ``[abc]`` will match any of the characters ``a``, ``b``, or ``c``; "
"this is the same as ``[a-c]``, which uses a range to express the same set of "
"characters.  If you wanted to match only lowercase letters, your RE would be "
"``[a-z]``."
msgstr ""
"最初に扱う特殊文字は ``[`` と ``]`` です。これらは文字クラスを指定します、文"
"字クラスはマッチしたい文字の集合です。文字は個別にリストにしても構いません"
"し、二つの文字を ``'-'`` でつなげて文字を範囲で与えてもかまいません。たとえ"
"ば ``[abc]`` は ``a``, ``b``, または ``c`` のどの文字列にもマッチします; これ"
"は ``[a-c]`` で同じ文字集合を範囲で表現しても全く同じです。小文字のアルファ"
"ベットのみにマッチしたい場合、 ``[a-z]`` の正規表現をつかうことになるでしょ"
"う。"

#: ../../howto/regex.rst:92
msgid ""
"Metacharacters are not active inside classes.  For example, ``[akm$]`` will "
"match any of the characters ``'a'``, ``'k'``, ``'m'``, or ``'$'``; ``'$'`` "
"is usually a metacharacter, but inside a character class it's stripped of "
"its special nature."
msgstr ""
"特殊文字は文字クラスの内部では有効になりません。例えば、 ``[akm$]`` は "
"``'a'``, ``'k'``, ``'m'`` または ``'$'`` にマッチします; ``'$'`` は通常は特殊"
"文字ですが、文字クラス内部では特殊な性質は取り除かれます。"

#: ../../howto/regex.rst:97
msgid ""
"You can match the characters not listed within the class by :dfn:"
"`complementing` the set.  This is indicated by including a ``'^'`` as the "
"first character of the class. For example, ``[^5]`` will match any character "
"except ``'5'``.  If the caret appears elsewhere in a character class, it "
"does not have special meaning. For example: ``[5^]`` will match either a "
"``'5'`` or a ``'^'``."
msgstr ""
":dfn:`補集合を取る` ことで、文字クラス内のリストにない文字に対してマッチさせ"
"られます。\n"
"補集合は、クラスの最初の文字として ``'^'`` を含めることで表せます。\n"
"例えば、 ``[^5]`` は ``'5'`` 以外の文字にマッチします。\n"
"キャレットが文字クラス以外の場所に現れた場合は、特別な意味は持ちません。\n"
"例えば、 ``[5^]`` は ``'5'`` や ``'^'`` にマッチします。"

#: ../../howto/regex.rst:103
msgid ""
"Perhaps the most important metacharacter is the backslash, ``\\``.   As in "
"Python string literals, the backslash can be followed by various characters "
"to signal various special sequences.  It's also used to escape all the "
"metacharacters so you can still match them in patterns; for example, if you "
"need to match a ``[`` or  ``\\``, you can precede them with a backslash to "
"remove their special meaning: ``\\[`` or ``\\\\``."
msgstr ""
"おそらく最も重要な特殊文字はバックスラッシュ ``\\`` でしょう。 Python の文字"
"列リテラルのようにバックスラッシュに続けていろいろな文字を入力することでいろ"
"いろな特殊シーケンスの合図を送ることができます。また、バックスラッシュはすべ"
"ての特殊文字をエスケープするのにも利用されます、つまり、特殊文字をマッチさせ"
"ることができます; 例えば、 ``[`` または ``\\`` にマッチさせたい場合、それらを"
"バックスラッシュに続けることで特殊な意味を除きます: ``\\[`` または ``\\"
"\\`` 。"

#: ../../howto/regex.rst:110
msgid ""
"Some of the special sequences beginning with ``'\\'`` represent predefined "
"sets of characters that are often useful, such as the set of digits, the set "
"of letters, or the set of anything that isn't whitespace."
msgstr ""
"``'\\'`` で始まるいくつかの特殊シーケンスは、数字、アルファベット、空白文字以"
"外など、よく使う文字集合を表しています。"

#: ../../howto/regex.rst:115
msgid ""
"Let's take an example: ``\\w`` matches any alphanumeric character.  If the "
"regex pattern is expressed in bytes, this is equivalent to the class ``[a-zA-"
"Z0-9_]``.  If the regex pattern is a string, ``\\w`` will match all the "
"characters marked as letters in the Unicode database provided by the :mod:"
"`unicodedata` module.  You can use the more restricted definition of ``\\w`` "
"in a string pattern by supplying the :const:`re.ASCII` flag when compiling "
"the regular expression."
msgstr ""
"一つ例をお見せしましょう: ``\\w`` は任意の英数字文字にマッチします。バイト列"
"パターンに対しては、これは文字クラス ``[a-zA-Z0-9_]`` と等価です。ユニコード"
"パターンに対しては、 ``\\w`` は :mod:`unicodedata` モジュールで提供されてい"
"る Unicode データベースで letters としてマークされている全ての文字とマッチし"
"ます。正規表現のコンパイル時に :const:`re.ASCII` フラグを与えることにより、 "
"``\\w`` を、より制限された定義で使うことが出来ます。"

#: ../../howto/regex.rst:123
msgid ""
"The following list of special sequences isn't complete. For a complete list "
"of sequences and expanded class definitions for Unicode string patterns, see "
"the last part of :ref:`Regular Expression Syntax <re-syntax>` in the "
"Standard Library reference.  In general, the Unicode versions match any "
"character that's in the appropriate category in the Unicode database."
msgstr ""
"以下に続く特別な文字列のリストは完全ではありません。特殊シーケンスと拡張クラ"
"スについてのユニコードパターンの定義についての完全なリストは、標準ライブラリ"
"リファレンスの :ref:`正規表現の構文 <re-syntax>` の最後のパートを参照してくだ"
"さい。一般的にユニコードバージョンは、ユニコードデータベース内で相応しいカテ"
"ゴリに属すればマッチします。"

#: ../../howto/regex.rst:131
msgid "``\\d``"
msgstr "``\\d``"

#: ../../howto/regex.rst:131
msgid "Matches any decimal digit; this is equivalent to the class ``[0-9]``."
msgstr "任意の十進数とマッチします; これは集合 ``[0-9]`` と同じ意味です。"

#: ../../howto/regex.rst:134
msgid "``\\D``"
msgstr "``\\D``"

#: ../../howto/regex.rst:134
msgid ""
"Matches any non-digit character; this is equivalent to the class ``[^0-9]``."
msgstr "任意の非数字文字とマッチします; これは集合 ``[^0-9]`` と同じ意味です。"

#: ../../howto/regex.rst:138
msgid "``\\s``"
msgstr "``\\s``"

#: ../../howto/regex.rst:137
msgid ""
"Matches any whitespace character; this is equivalent to the class "
"``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"任意の空白文字とマッチします; これは集合 ``[ \\t\\n\\r\\f\\v]`` と同じ意味で"
"す。"

#: ../../howto/regex.rst:142
msgid "``\\S``"
msgstr "``\\S``"

#: ../../howto/regex.rst:141
msgid ""
"Matches any non-whitespace character; this is equivalent to the class ``[^ "
"\\t\\n\\r\\f\\v]``."
msgstr ""
"任意の非空白文字とマッチします; これは集合 ``[^ \\t\\n\\r\\f\\v]`` と同じ意味"
"です。"

#: ../../howto/regex.rst:146
msgid "``\\w``"
msgstr "``\\w``"

#: ../../howto/regex.rst:145
msgid ""
"Matches any alphanumeric character; this is equivalent to the class ``[a-zA-"
"Z0-9_]``."
msgstr ""
"任意の英数文字および下線とマッチします; これは、集合 ``[a-zA-Z0-9_]`` と同じ"
"意味です。"

#: ../../howto/regex.rst:150
msgid "``\\W``"
msgstr "``\\W``"

#: ../../howto/regex.rst:149
msgid ""
"Matches any non-alphanumeric character; this is equivalent to the class "
"``[^a-zA-Z0-9_]``."
msgstr ""
"任意の非英数文字とマッチします; これは集合 ``[^a-zA-Z0-9_]`` と同じ意味です。"

#: ../../howto/regex.rst:152
msgid ""
"These sequences can be included inside a character class.  For example, "
"``[\\s,.]`` is a character class that will match any whitespace character, "
"or ``','`` or ``'.'``."
msgstr ""
"これらのシーケンスは文字クラス内に含めることができます。例えば、 ``[\\s,.]`` "
"は空白文字や ``','`` または ``'.'`` にマッチする文字クラスです。"

#: ../../howto/regex.rst:156
msgid ""
"The final metacharacter in this section is ``.``.  It matches anything "
"except a newline character, and there's an alternate mode (:const:`re."
"DOTALL`) where it will match even a newline.  ``.`` is often used where you "
"want to match \"any character\"."
msgstr ""
"この節での最後の特殊文字は ``.`` です。\n"
"これは改行文字を除く任意の文字にマッチし、さらに改行文字に対してもマッチさせ"
"る代替モード (:const:`re.DOTALL`) があります。\n"
"``.`` は「任意の文字」にマッチさせたい場合に利用されます。"

#: ../../howto/regex.rst:163
msgid "Repeating Things"
msgstr "繰り返し"

#: ../../howto/regex.rst:165
msgid ""
"Being able to match varying sets of characters is the first thing regular "
"expressions can do that isn't already possible with the methods available on "
"strings.  However, if that was the only additional capability of regexes, "
"they wouldn't be much of an advance. Another capability is that you can "
"specify that portions of the RE must be repeated a certain number of times."
msgstr ""
"さまざまな文字集合をマッチさせることは正規表現で最初にできるようになること"
"で、これは文字列に対するメソッドですぐにできることではありません。しかし、正"
"規表現がより力を発揮する場面がこれだけだとすると、正規表現はあまり先進的とは"
"いえません。正規表現の力をもう一つの能力は、正規表現の一部が何度も繰り返され"
"るようものを指定できることです。"

#: ../../howto/regex.rst:171
msgid ""
"The first metacharacter for repeating things that we'll look at is ``*``.  "
"``*`` doesn't match the literal character ``'*'``; instead, it specifies "
"that the previous character can be matched zero or more times, instead of "
"exactly once."
msgstr ""
"最初にとりあげる繰り返しのための最初の特殊文字は ``*`` です。\n"
"``*`` は文字リテラル ``'*'`` とはマッチしません; その代わりに、前の文字がぴっ"
"たり1回ではなく0回以上繰り返されるパターンを指定します。"

#: ../../howto/regex.rst:175
msgid ""
"For example, ``ca*t`` will match ``'ct'`` (0 ``'a'`` characters), ``'cat'`` "
"(1 ``'a'``), ``'caaat'`` (3 ``'a'`` characters), and so forth."
msgstr ""
"例えば、 ``ca*t`` は ``'ct'`` (文字 ``'a'`` が 0 個)、 ``'cat'`` (``'a'`` が "
"1 個)、 ``'caaat'`` (``'a'`` が 3 個)、などにマッチします。"

#: ../../howto/regex.rst:178
msgid ""
"Repetitions such as ``*`` are :dfn:`greedy`; when repeating a RE, the "
"matching engine will try to repeat it as many times as possible. If later "
"portions of the pattern don't match, the matching engine will then back up "
"and try again with fewer repetitions."
msgstr ""
"``*`` のような繰り返しは :dfn:`貪欲 (greedy)` です; 正規表現を繰り返したいと"
"き、マッチングエンジンは可能な限り何度も繰り返そうと試みます。パターンの後ろ"
"の部分にマッチしない場合、マッチングエンジンは戻ってより少ない繰り返しを再び"
"試みます。"

#: ../../howto/regex.rst:183
msgid ""
"A step-by-step example will make this more obvious.  Let's consider the "
"expression ``a[bcd]*b``.  This matches the letter ``'a'``, zero or more "
"letters from the class ``[bcd]``, and finally ends with a ``'b'``.  Now "
"imagine matching this RE against the string ``'abcbd'``."
msgstr ""
"一歩ずつ例を進めていくとより明確にわかります。\n"
"正規表現 ``a[bcd]*b`` を考えましょう。\n"
"この正規表現は文字 ``'a'`` 、文字クラス ``[bcd]`` の 0 個以上の文字、最後に来"
"る ``'b'`` にマッチします。\n"
"この正規表現が文字列 ``'abcbd'`` に対してマッチする流れを想像してみましょう。"

#: ../../howto/regex.rst:189
msgid "Step"
msgstr "ステップ"

#: ../../howto/regex.rst:189
msgid "Matched"
msgstr "マッチした文字列"

#: ../../howto/regex.rst:189
msgid "Explanation"
msgstr "説明"

#: ../../howto/regex.rst:191
msgid "1"
msgstr "1"

#: ../../howto/regex.rst:191
msgid "``a``"
msgstr "``a``"

#: ../../howto/regex.rst:191
msgid "The ``a`` in the RE matches."
msgstr "正規表現の ``a`` がマッチ。"

#: ../../howto/regex.rst:193
msgid "2"
msgstr "2"

#: ../../howto/regex.rst:193
msgid "``abcbd``"
msgstr "``abcbd``"

#: ../../howto/regex.rst:193
msgid ""
"The engine matches ``[bcd]*``, going as far as it can, which is to the end "
"of the string."
msgstr ""
"正規表現エンジンが、文字列の終わりに向かってできるだけ遠くまで ``[bcd]*`` を"
"マッチさせる。"

#: ../../howto/regex.rst:197
msgid "3"
msgstr "3"

#: ../../howto/regex.rst:197 ../../howto/regex.rst:205
msgid "*Failure*"
msgstr "*失敗*"

#: ../../howto/regex.rst:197
msgid ""
"The engine tries to match ``b``, but the current position is at the end of "
"the string, so it fails."
msgstr ""
"正規表現エンジンが ``b`` でマッチを試みるが、現在の位置が文字列の最後なので失"
"敗。"

#: ../../howto/regex.rst:202
msgid "4"
msgstr "4"

#: ../../howto/regex.rst:202 ../../howto/regex.rst:213
msgid "``abcb``"
msgstr "``abcb``"

#: ../../howto/regex.rst:202
msgid "Back up, so that  ``[bcd]*`` matches one less character."
msgstr "``[bcd]*`` が一文字少なくマッチするように戻る。"

#: ../../howto/regex.rst:205
msgid "5"
msgstr "5"

#: ../../howto/regex.rst:205
msgid ""
"Try ``b`` again, but the current position is at the last character, which is "
"a ``'d'``."
msgstr "再び ``b`` にマッチするか試みるが、現在の位置は最後の文字 ``'d'`` 。"

#: ../../howto/regex.rst:209 ../../howto/regex.rst:213
msgid "6"
msgstr "6"

#: ../../howto/regex.rst:209
msgid "``abc``"
msgstr "``abc``"

#: ../../howto/regex.rst:209
msgid "Back up again, so that ``[bcd]*`` is only matching ``bc``."
msgstr "``[bcd]*`` は ``bc`` のみにマッチするように再び戻る。"

#: ../../howto/regex.rst:213
msgid ""
"Try ``b`` again.  This time the character at the current position is "
"``'b'``, so it succeeds."
msgstr "再び ``b`` を試みる。今回の現在位置の文字は ``'b'`` なので成功。"

#: ../../howto/regex.rst:219
msgid ""
"The end of the RE has now been reached, and it has matched ``'abcb'``.  This "
"demonstrates how the matching engine goes as far as it can at first, and if "
"no match is found it will then progressively back up and retry the rest of "
"the RE again and again.  It will back up until it has tried zero matches for "
"``[bcd]*``, and if that subsequently fails, the engine will conclude that "
"the string doesn't match the RE at all."
msgstr ""
"正規表現の終端に達して、 ``'abcd'`` にマッチしました。\n"
"この説明は、マッチングエンジンが最初に到達できるところまで進みマッチしなかっ"
"た場合、逐次戻って再度残りの正規表現とのマッチを次々と試みること様子を示して"
"います。\n"
"正規表現エンジンは ``[bcd]*`` の 0 回マッチを試すところまで戻り、その後続の正"
"規表現とのマッチに失敗した場合には、エンジンは正規表現と文字列が完全にマッチ"
"しないと結論づけることになります。"

#: ../../howto/regex.rst:226
msgid ""
"Another repeating metacharacter is ``+``, which matches one or more times.  "
"Pay careful attention to the difference between ``*`` and ``+``; ``*`` "
"matches *zero* or more times, so whatever's being repeated may not be "
"present at all, while ``+`` requires at least *one* occurrence.  To use a "
"similar example, ``ca+t`` will match ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 "
"``'a'``\\ s), but won't match ``'ct'``."
msgstr ""
"別の繰り返しのメタ文字には ``+`` があり、この特殊文字は 1 回以上の繰り返しに"
"マッチします。\n"
"``*`` と ``+`` に違いに対しては十分注意して下さい; ``*`` は *0 回* 以上の繰り"
"返しにマッチするので、繰り返す部分が全くなくても問題ありません。一方で ``+`` "
"は少なくとも *1 回* は表われる必要があります。\n"
"同様の例を使うと ``ca+t`` は ``'cat'`` (``'a'`` 1 文字)、 ``'caaat'`` "
"(``'a'`` 3 文字)、とマッチし、``'ct'`` とはマッチしません。"

#: ../../howto/regex.rst:233
msgid ""
"There are two more repeating qualifiers.  The question mark character, ``?"
"``, matches either once or zero times; you can think of it as marking "
"something as being optional.  For example, ``home-?brew`` matches either "
"``'homebrew'`` or ``'home-brew'``."
msgstr ""
"2回以上の繰り返しを制限する修飾子も存在します。\n"
"クエスチョンマーク ``?`` は0か1回のどちらかにマッチします; これはオプショナル"
"な何かを示しているとも考えられます。\n"
"例えば、``home-?brew`` は ``'homebrew'`` と ``'home-brew'`` のどちらにもマッ"
"チします。"

#: ../../howto/regex.rst:238
msgid ""
"The most complicated repeated qualifier is ``{m,n}``, where *m* and *n* are "
"decimal integers.  This qualifier means there must be at least *m* "
"repetitions, and at most *n*.  For example, ``a/{1,3}b`` will match ``'a/"
"b'``, ``'a//b'``, and ``'a///b'``.  It won't match ``'ab'``, which has no "
"slashes, or ``'a////b'``, which has four."
msgstr ""
"最も複雑な繰り返しの修飾子は ``{m,n}`` で、ここで *m* と *n* は 10 進整数で"
"す。\n"
"この修飾子は最低 *m* 回、最大で *n* 回の繰り返すことを意味しています。\n"
"例えば、 ``a/{1,3}b`` は ``'a/b'`` と ``'a//b'`` そして ``'a///b'`` にマッチ"
"し、スラッシュの無い ``'ab'`` や4つのスラッシュを持つ ``'a////b'`` にはマッチ"
"しません。"

#: ../../howto/regex.rst:244
msgid ""
"You can omit either *m* or *n*; in that case, a reasonable value is assumed "
"for the missing value.  Omitting *m* is interpreted as a lower limit of 0, "
"while omitting *n* results in an upper bound of infinity."
msgstr ""
"*m* か *n* のどちらかは省略することができます; その場合は、省略された値は合理"
"的な値が仮定されます。\n"
"*m* の省略は下限は 0 と解釈され、*n* の省略は上限は無限として解釈されます。"

#: ../../howto/regex.rst:248
msgid ""
"Readers of a reductionist bent may notice that the three other qualifiers "
"can all be expressed using this notation.  ``{0,}`` is the same as ``*``, "
"``{1,}`` is equivalent to ``+``, and ``{0,1}`` is the same as ``?``.  It's "
"better to use ``*``, ``+``, or ``?`` when you can, simply because they're "
"shorter and easier to read."
msgstr ""
"還元主義者傾向のある読者は、3つの修飾子がこの表記を使って表現できることに気付"
"くでしょう。\n"
"``{0,}`` は ``*`` と、 ``{1,}`` は ``+`` と、そして ``{0,1}`` は ``?`` と同じ"
"です。\n"
"できるなら ``*``, ``+``, ``?`` を利用した方が賢明です。それは単に、短く読み易"
"くなるからです。"

#: ../../howto/regex.rst:256
msgid "Using Regular Expressions"
msgstr "正規表現を使う"

#: ../../howto/regex.rst:258
msgid ""
"Now that we've looked at some simple regular expressions, how do we actually "
"use them in Python?  The :mod:`re` module provides an interface to the "
"regular expression engine, allowing you to compile REs into objects and then "
"perform matches with them."
msgstr ""
"これまででいくつかの単純な正規表現に触れてきました、実際に Python ではこれら"
"をどう使えばいいのでしょう? :mod:`re` モジュールは正規表現エンジンに対するイ"
"ンターフェースを提供していて、それらを使うことで正規表現をオブジェクトにコン"
"パイルし、マッチを実行することができます。"

#: ../../howto/regex.rst:265
msgid "Compiling Regular Expressions"
msgstr "正規表現をコンパイルする"

#: ../../howto/regex.rst:267
msgid ""
"Regular expressions are compiled into pattern objects, which have methods "
"for various operations such as searching for pattern matches or performing "
"string substitutions. ::"
msgstr ""
"正規表現はパターンオブジェクトにコンパイルされます、パターンオブジェクトは多"
"くの操作、パターンマッチの検索や文字列の置換の実行などのメソッドを持っていま"
"す。 ::"

#: ../../howto/regex.rst:276
msgid ""
":func:`re.compile` also accepts an optional *flags* argument, used to enable "
"various special features and syntax variations.  We'll go over the available "
"settings later, but for now a single example will do::"
msgstr ""
":func:`re.compile` はいくつかの *flags* 引数を受け付けることができます、この"
"引数はさまざまな特別な機能を有効にしたり、構文を変化させたりします。利用でき"
"る設定に何があるかは後に飛ばすことにして、簡単な例をやることにしましょう::"

#: ../../howto/regex.rst:282
msgid ""
"The RE is passed to :func:`re.compile` as a string.  REs are handled as "
"strings because regular expressions aren't part of the core Python language, "
"and no special syntax was created for expressing them.  (There are "
"applications that don't need REs at all, so there's no need to bloat the "
"language specification by including them.) Instead, the :mod:`re` module is "
"simply a C extension module included with Python, just like the :mod:"
"`socket` or :mod:`zlib` modules."
msgstr ""
"正規表現は文字列として :func:`re.compile` に渡されます。正規表現は文字列とし"
"て扱われますが、それは正規表現が Python 言語のコアシステムに含まれないためで"
"す、そのため正規表現を表わす特殊な構文はありません。 (正規表現を全く必要とし"
"ないアプリケーションも存在します、そのためそれらを含めて言語仕様を無駄に大き"
"くする必要はありません) その代わり、 :mod:`re` モジュールは :mod:`socket` "
"や :mod:`zlib` モジュールのような通常の C 拡張モジュールとして Python に含ま"
"れています。"

#: ../../howto/regex.rst:289
msgid ""
"Putting REs in strings keeps the Python language simpler, but has one "
"disadvantage which is the topic of the next section."
msgstr ""
"正規表現を文字列としておくことで Python 言語はより簡素に保たれていますが、そ"
"のため1つの欠点があります、これについては次の節で話題とします。"

#: ../../howto/regex.rst:296
msgid "The Backslash Plague"
msgstr "バックスラッシュ感染症"

#: ../../howto/regex.rst:298
msgid ""
"As stated earlier, regular expressions use the backslash character "
"(``'\\'``) to indicate special forms or to allow special characters to be "
"used without invoking their special meaning. This conflicts with Python's "
"usage of the same character for the same purpose in string literals."
msgstr ""
"先に述べたように、正規表現は特別な形式や特殊な文字の特別な意味を意味を除くこ"
"とを示すためにバックスラッシュ文字 (``'\\'``) を利用します。これは Python が"
"文字列リテラルに対して、同じ文字を同じ目的で使うことと衝突します。"

#: ../../howto/regex.rst:303
msgid ""
"Let's say you want to write a RE that matches the string ``\\section``, "
"which might be found in a LaTeX file.  To figure out what to write in the "
"program code, start with the desired string to be matched.  Next, you must "
"escape any backslashes and other metacharacters by preceding them with a "
"backslash, resulting in the string ``\\\\section``.  The resulting string "
"that must be passed to :func:`re.compile` must be ``\\\\section``.  However, "
"to express this as a Python string literal, both backslashes must be escaped "
"*again*."
msgstr ""
"``\\section`` という文字列 (これは LaTeX ファイルでみかけます) にマッチする正"
"規表現を書きたいとします。どんなプログラムを書くか考え、マッチして欲しい文字"
"列をはじめに考えます。次に、バックスラッシュや他の特殊文字をバックスラッシュ"
"に続けて書くことでエスケープしなければいけません、その結果 ``\\\\section`` の"
"ような文字列となります。こうしてできた :func:`re.compile` に渡す文字列は ``\\"
"\\section`` でなければいけません。しかし、これを Python の文字列リテラルとし"
"て扱うにはこの二つのバックスラッシュを *再び* エスケープする必要があります。"

#: ../../howto/regex.rst:312
msgid "Characters"
msgstr "文字"

#: ../../howto/regex.rst:312
msgid "Stage"
msgstr "段階"

#: ../../howto/regex.rst:314
msgid "``\\section``"
msgstr "``\\section``"

#: ../../howto/regex.rst:314
msgid "Text string to be matched"
msgstr "マッチさせるテキスト"

#: ../../howto/regex.rst:316
msgid "``\\\\section``"
msgstr "``\\\\section``"

#: ../../howto/regex.rst:316
msgid "Escaped backslash for :func:`re.compile`"
msgstr ":func:`re.compile` のためのバックスラッシュエスケープ"

#: ../../howto/regex.rst:318 ../../howto/regex.rst:345
msgid "``\"\\\\\\\\section\"``"
msgstr "``\"\\\\\\\\section\"``"

#: ../../howto/regex.rst:318
msgid "Escaped backslashes for a string literal"
msgstr "文字列リテラルのためのバックスラッシュエスケープ"

#: ../../howto/regex.rst:321
msgid ""
"In short, to match a literal backslash, one has to write ``'\\\\\\\\'`` as "
"the RE string, because the regular expression must be ``\\\\``, and each "
"backslash must be expressed as ``\\\\`` inside a regular Python string "
"literal.  In REs that feature backslashes repeatedly, this leads to lots of "
"repeated backslashes and makes the resulting strings difficult to understand."
msgstr ""
"要点だけをいえば、リテラルとしてのバックスラッシュにマッチさせるために、正規"
"表現文字列として ``'\\\\\\\\'`` 書かなければいけません、なぜなら正規表現は "
"``\\\\`` であり、通常の Python の文字列リテラルとしてはそれぞれのバックスラッ"
"シュは ``\\\\`` で表現しなければいけないからです。正規表現に関してこのバック"
"スラッシュの繰り返しの機能は、たくさんのバックスラッシュの繰り返しを生むこと"
"になり、その結果として作られる文字列は理解することが難しくなります。"

#: ../../howto/regex.rst:327
msgid ""
"The solution is to use Python's raw string notation for regular expressions; "
"backslashes are not handled in any special way in a string literal prefixed "
"with ``'r'``, so ``r\"\\n\"`` is a two-character string containing ``'\\'`` "
"and ``'n'``, while ``\"\\n\"`` is a one-character string containing a "
"newline. Regular expressions will often be written in Python code using this "
"raw string notation."
msgstr ""
"この問題の解決策としては正規表現に対しては Python の raw string 記法を使うこ"
"とです; ``'r'`` を文字列リテラルの先頭に書くことでバックスラッシュは特別扱い"
"されなくなります、つまり ``\"\\n\"`` は改行を含む1つの文字からなる文字列であ"
"るのに対して、 ``r\"\\n\"`` は2つの文字 ``'\\'`` と ``'n'`` を含む文字列とな"
"ります。多くの場合 Python コードの中の正規表現はこの raw string 記法を使って"
"書かれます。"

#: ../../howto/regex.rst:333
msgid ""
"In addition, special escape sequences that are valid in regular expressions, "
"but not valid as Python string literals, now result in a :exc:"
"`DeprecationWarning` and will eventually become a :exc:`SyntaxError`, which "
"means the sequences will be invalid if raw string notation or escaping the "
"backslashes isn't used."
msgstr ""
"それに加えて、正規表現では有効であるものの Python の文字列リテラルとしては有"
"効でない特殊文字のエスケープシーケンスは、現在では :exc:`DeprecationWarning` "
"を引き起こし、最終的には :exc:`SyntaxError` となります。すなわち、そのような"
"シーケンスは raw string 記法を使うか、バックスラッシュによるエスケープを使わ"
"ないかぎり無効になることを意味します。"

#: ../../howto/regex.rst:341
msgid "Regular String"
msgstr "通常の文字列"

#: ../../howto/regex.rst:341
msgid "Raw string"
msgstr "Raw string"

#: ../../howto/regex.rst:343
msgid "``\"ab*\"``"
msgstr "``\"ab*\"``"

#: ../../howto/regex.rst:343
msgid "``r\"ab*\"``"
msgstr "``r\"ab*\"``"

#: ../../howto/regex.rst:345
msgid "``r\"\\\\section\"``"
msgstr "``r\"\\\\section\"``"

#: ../../howto/regex.rst:347
msgid "``\"\\\\w+\\\\s+\\\\1\"``"
msgstr "``\"\\\\w+\\\\s+\\\\1\"``"

#: ../../howto/regex.rst:347
msgid "``r\"\\w+\\s+\\1\"``"
msgstr "``r\"\\w+\\s+\\1\"``"

#: ../../howto/regex.rst:352
msgid "Performing Matches"
msgstr "マッチの実行"

#: ../../howto/regex.rst:354
msgid ""
"Once you have an object representing a compiled regular expression, what do "
"you do with it?  Pattern objects have several methods and attributes. Only "
"the most significant ones will be covered here; consult the :mod:`re` docs "
"for a complete listing."
msgstr ""
"一旦コンパイルした正規表現を表現するオブジェクトを作成したら、次に何をします"
"か? パターンオブジェクトはいくつかのメソッドや属性を持っています。ここでは、"
"その中でも最も重要なものについて扱います; 完全なリストは :mod:`re` ドキュメン"
"トを参照して下さい。"

#: ../../howto/regex.rst:360 ../../howto/regex.rst:418
#: ../../howto/regex.rst:1064
msgid "Method/Attribute"
msgstr "メソッド/属性"

#: ../../howto/regex.rst:360 ../../howto/regex.rst:418
#: ../../howto/regex.rst:1064
msgid "Purpose"
msgstr "目的"

#: ../../howto/regex.rst:362
msgid "``match()``"
msgstr "``match()``"

#: ../../howto/regex.rst:362
msgid "Determine if the RE matches at the beginning of the string."
msgstr "文字列の先頭で正規表現とマッチするか判定します。"

#: ../../howto/regex.rst:365
msgid "``search()``"
msgstr "``search()``"

#: ../../howto/regex.rst:365
msgid "Scan through a string, looking for any location where this RE matches."
msgstr "文字列を操作して、正規表現がどこにマッチするか調べます。"

#: ../../howto/regex.rst:368
msgid "``findall()``"
msgstr "``findall()``"

#: ../../howto/regex.rst:368
msgid "Find all substrings where the RE matches, and returns them as a list."
msgstr "正規表現にマッチする部分文字列を全て探しだしリストとして返します。"

#: ../../howto/regex.rst:371
msgid "``finditer()``"
msgstr "``finditer()``"

#: ../../howto/regex.rst:371
msgid ""
"Find all substrings where the RE matches, and returns them as an :term:"
"`iterator`."
msgstr ""
"正規表現にマッチする部分文字列を全て探しだし :term:`iterator` として返しま"
"す。"

#: ../../howto/regex.rst:375
msgid ""
":meth:`~re.Pattern.match` and :meth:`~re.Pattern.search` return ``None`` if "
"no match can be found.  If they're successful, a :ref:`match object <match-"
"objects>` instance is returned, containing information about the match: "
"where it starts and ends, the substring it matched, and more."
msgstr ""
":meth:`~re.Pattern.match` と :meth:`~re.Pattern.search` はマッチするものが見"
"つからなければ ``None`` を返します。\n"
"成功すればそれらは :ref:`Match オブジェクト <match-objects>` のインスタンスを"
"返します。このオブジェクトにはマッチした情報が含まれます: マッチの開始と終了"
"位置、マッチした部分文字列、など。"

#: ../../howto/regex.rst:380
msgid ""
"You can learn about this by interactively experimenting with the :mod:`re` "
"module.  If you have :mod:`tkinter` available, you may also want to look at :"
"source:`Tools/demo/redemo.py`, a demonstration program included with the "
"Python distribution.  It allows you to enter REs and strings, and displays "
"whether the RE matches or fails. :file:`redemo.py` can be quite useful when "
"trying to debug a complicated RE."
msgstr ""
":mod:`re` モジュールで対話的に実験することで学ぶこともできます。 :mod:"
"`tkinter` が利用できれば、Python に含まれるデモプログラム :source:`Tools/"
"demo/redemo.py` を見るといいかもしれません。このデモは正規表現と文字列を入力"
"し、正規表現がマッチしたかどうかを表示します。 :file:`redemo.py` は複雑な正規"
"表現のデバッグを試みるときにも便利に使うことができます。"

#: ../../howto/regex.rst:387
msgid ""
"This HOWTO uses the standard Python interpreter for its examples. First, run "
"the Python interpreter, import the :mod:`re` module, and compile a RE::"
msgstr ""
"この HOWTO では例として標準の Python インタプリタを使います。最初に Python イ"
"ンタプリタを起動して、 :mod:`re` モジュールをインポートし、正規表現をコンパイ"
"ルします::"

#: ../../howto/regex.rst:395
msgid ""
"Now, you can try matching various strings against the RE ``[a-z]+``.  An "
"empty string shouldn't match at all, since ``+`` means 'one or more "
"repetitions'. :meth:`~re.Pattern.match` should return ``None`` in this case, "
"which will cause the interpreter to print no output.  You can explicitly "
"print the result of :meth:`!match` to make this clear. ::"
msgstr ""
"さて、いろいろな文字列を使って正規表現 ``[a-z]+`` に対するマッチングを試して"
"みましょう。空の文字列は全くマッチしません、なぜなら ``+`` は「1 回以上の繰り"
"返し」を意味するからです。この場合では :meth:`~re.Pattern.match` は ``None`` "
"を返すべきで、インタプタは何も出力しません。明確にするために :meth:`!match` "
"の結果を明示的に出力することもできます::"

#: ../../howto/regex.rst:405
msgid ""
"Now, let's try it on a string that it should match, such as ``tempo``.  In "
"this case, :meth:`~re.Pattern.match` will return a :ref:`match object <match-"
"objects>`, so you should store the result in a variable for later use. ::"
msgstr ""
"では、今度はマッチするはずの文字列、例えば ``tempo`` を試してみましょう。この"
"ケースでは、 :meth:`~re.Pattern.match` は :ref:`match object <match-"
"objects>` を返すので、後で使うために結果を変数に記憶しておくべきです。 ::"

#: ../../howto/regex.rst:413
msgid ""
"Now you can query the :ref:`match object <match-objects>` for information "
"about the matching string.  Match object instances also have several methods "
"and attributes; the most important ones are:"
msgstr ""
"これでマッチした文字列についての情報を :ref:`Match オブジェクト <match-"
"objects>` に問い合わせることが出来ます。\n"
"Match オブジェクトインスタンスはいくつかのメソッドと属性も持っていて、最も重"
"要なのは次のものです:"

#: ../../howto/regex.rst:420
msgid "``group()``"
msgstr "``group()``"

#: ../../howto/regex.rst:420
msgid "Return the string matched by the RE"
msgstr "正規表現にマッチした文字列を返す"

#: ../../howto/regex.rst:422
msgid "``start()``"
msgstr "``start()``"

#: ../../howto/regex.rst:422
msgid "Return the starting position of the match"
msgstr "マッチの開始位置を返す"

#: ../../howto/regex.rst:424
msgid "``end()``"
msgstr "``end()``"

#: ../../howto/regex.rst:424
msgid "Return the ending position of the match"
msgstr "マッチの終了位置を返す"

#: ../../howto/regex.rst:426
msgid "``span()``"
msgstr "``span()``"

#: ../../howto/regex.rst:426
msgid "Return a tuple containing the (start, end) positions  of the match"
msgstr "マッチの位置 (start, end) を含むタプルを返す"

#: ../../howto/regex.rst:430
msgid "Trying these methods will soon clarify their meaning::"
msgstr "これらのメソッドを試せば、その意味はすぐに理解できます::"

#: ../../howto/regex.rst:439
msgid ""
":meth:`~re.Match.group` returns the substring that was matched by the RE.  :"
"meth:`~re.Match.start` and :meth:`~re.Match.end` return the starting and "
"ending index of the match. :meth:`~re.Match.span` returns both start and end "
"indexes in a single tuple.  Since the :meth:`~re.Pattern.match` method only "
"checks if the RE matches at the start of a string, :meth:`!start` will "
"always be zero.  However, the :meth:`~re.Pattern.search` method of patterns "
"scans through the string, so  the match may not start at zero in that "
"case. ::"
msgstr ""
":meth:`~re.Match.group` は正規表現でマッチした部分文字列を返します。 :meth:"
"`~re.Match.start` と :meth:`~re.Match.end` はそれぞれ、マッチの開始インデクス"
"と終了インデクスを返します。 :meth:`~re.Match.span` は開始と終了のインデクス"
"を一つのタプルにして返します。\n"
":meth:`~re.Pattern.match` メソッドは正規表現が文字列の開始位置でマッチするか"
"どうかだけをチェックするので、 :meth:`!start` は必ずゼロを返します。\n"
"しかし、 :meth:`~re.Pattern.search` メソッドではパターンを文字列全体について"
"走査するので、マッチの開始はゼロにならないかもしれません。 ::"

#: ../../howto/regex.rst:456
msgid ""
"In actual programs, the most common style is to store the :ref:`match object "
"<match-objects>` in a variable, and then check if it was ``None``.  This "
"usually looks like::"
msgstr ""
"実際のプログラムでは :ref:`Match オブジェクト <match-objects>` を変数に記憶し"
"ておき, その次に ``None`` なのか調べるのが一般的なスタイルです。普通このよう"
"にします::"

#: ../../howto/regex.rst:467
msgid ""
"Two pattern methods return all of the matches for a pattern. :meth:`~re."
"Pattern.findall` returns a list of matching strings::"
msgstr ""
"あるパターンにマッチするもの全てを返す Pattern インスタンスのメソッドが2つあ"
"ります。\n"
":meth:`~re.Pattern.findall` はマッチした文字列のリストを返します::"

#: ../../howto/regex.rst:474
msgid ""
"The ``r`` prefix, making the literal a raw string literal, is needed in this "
"example because escape sequences in a normal \"cooked\" string literal that "
"are not recognized by Python, as opposed to regular expressions, now result "
"in a :exc:`DeprecationWarning` and will eventually become a :exc:"
"`SyntaxError`.  See :ref:`the-backslash-plague`."
msgstr ""
"この例では、文字列リテラルを raw string リテラルにするプレフィックス ``r`` が"
"必要です。これは、正規表現とは異なり、通常の \"調理済み\" 文字列リテラルにお"
"けるエスケープシーケンスは Python では認識されないためであり、現在では :exc:"
"`DeprecationWarning` を引き起こし、最終的には :exc:`SyntaxError` となります。"
"詳しくは :ref:`the-backslash-plague` を参照してください。"

#: ../../howto/regex.rst:480
msgid ""
":meth:`~re.Pattern.findall` has to create the entire list before it can be "
"returned as the result.  The :meth:`~re.Pattern.finditer` method returns a "
"sequence of :ref:`match object <match-objects>` instances as an :term:"
"`iterator`::"
msgstr ""
":meth:`~re.Pattern.findall` は結果を返す前に完全なリストを必ず生成してしまい"
"ます。いっぽう :meth:`~re.Pattern.finditer` メソッドは :ref:`マッチオブジェク"
"ト <match-objects>` インスタンスのシーケンスを :term:`iterator` として返しま"
"す::"

#: ../../howto/regex.rst:496
msgid "Module-Level Functions"
msgstr "モジュールレベルの関数"

#: ../../howto/regex.rst:498
msgid ""
"You don't have to create a pattern object and call its methods; the :mod:"
"`re` module also provides top-level functions called :func:`~re.match`, :"
"func:`~re.search`, :func:`~re.findall`, :func:`~re.sub`, and so forth.  "
"These functions take the same arguments as the corresponding pattern method "
"with the RE string added as the first argument, and still return either "
"``None`` or a :ref:`match object <match-objects>` instance. ::"
msgstr ""
"パターンオブジェクトを作ってそのメソッドを呼び出す、とする必要は必ずしもあり"
"ません。 :mod:`re` モジュールはトップレベルの関数として :func:`~re.match`, :"
"func:`~re.search`, :func:`~re.findall`, :func:`~re.sub` などを用意していま"
"す。これら関数は、対応するメソッドの最初の引数に RE が追加されただけで後は同"
"じで、 ``None`` か :ref:`Match オブジェクト <match-objects>` インスタンスを返"
"すのも同じです::"

#: ../../howto/regex.rst:510
msgid ""
"Under the hood, these functions simply create a pattern object for you and "
"call the appropriate method on it.  They also store the compiled object in a "
"cache, so future calls using the same RE won't need to parse the pattern "
"again and again."
msgstr ""
"内部的には、これら関数は単にあなたのためにパターンオブジェクトを生成し、対応"
"するメソッドを呼び出すだけのことです。とともに、将来の呼び出しで同じ RE の"
"パースが何度も何度も必要とならないよう、コンパイル済みオブジェクトはキャッ"
"シュされます。"

#: ../../howto/regex.rst:515
msgid ""
"Should you use these module-level functions, or should you get the pattern "
"and call its methods yourself?  If you're accessing a regex within a loop, "
"pre-compiling it will save a few function calls. Outside of loops, there's "
"not much difference thanks to the internal cache."
msgstr ""
"これらモジュールレベル関数を使うのと、パターンを自身で作って自身で呼び出すの"
"とでどちらを使うべきでしょう? 正規表現をループの内側で使うならば、プリコンパ"
"イルは関数呼び出しを減らします。ループの外側であれば、内部キャッシュのおかげ"
"で、どちらでも大差ありません。"

#: ../../howto/regex.rst:523
msgid "Compilation Flags"
msgstr "コンパイルフラグ"

#: ../../howto/regex.rst:525
msgid ""
"Compilation flags let you modify some aspects of how regular expressions "
"work. Flags are available in the :mod:`re` module under two names, a long "
"name such as :const:`IGNORECASE` and a short, one-letter form such as :const:"
"`I`.  (If you're familiar with Perl's pattern modifiers, the one-letter "
"forms use the same letters; the short form of :const:`re.VERBOSE` is :const:"
"`re.X`, for example.) Multiple flags can be specified by bitwise OR-ing "
"them; ``re.I | re.M`` sets both the :const:`I` and :const:`M` flags, for "
"example."
msgstr ""
"コンパイルフラグは正規表現の動作をいくつかの側面から変更します。フラグは :"
"mod:`re` モジュール下で二つの名前で利用することができます、例えば長い名前は :"
"const:`IGNORECASE` で短い名前は1文字で :const:`I` のようになっています。 (1文"
"字形式は Perl のパターン修飾子と同じ形式を使います; 例えば :const:`re."
"VERBOSE` の短かい形式は :const:`re.X` です。) 複数のフラグが OR ビット演算で"
"指定することができます; 例えば ``re.I | re.M`` は :const:`I` と :const:`M` フ"
"ラグの両方を設定します。"

#: ../../howto/regex.rst:533
msgid ""
"Here's a table of the available flags, followed by a more detailed "
"explanation of each one."
msgstr ""
"ここに利用可能なフラグの表があります、それぞれについてのより詳細な説明が後に"
"続きます。"

#: ../../howto/regex.rst:537
msgid "Flag"
msgstr "Flag"

#: ../../howto/regex.rst:537
msgid "Meaning"
msgstr "意味"

#: ../../howto/regex.rst:539
msgid ":const:`ASCII`, :const:`A`"
msgstr ":const:`ASCII`, :const:`A`"

#: ../../howto/regex.rst:539
msgid ""
"Makes several escapes like ``\\w``, ``\\b``, ``\\s`` and ``\\d`` match only "
"on ASCII characters with the respective property."
msgstr ""
"``\\w``, ``\\b``, ``\\s``, そして ``\\d`` などをそれぞれのプロパティをもつ "
"ASCII 文字だけにマッチさせます。"

#: ../../howto/regex.rst:543
msgid ":const:`DOTALL`, :const:`S`"
msgstr ":const:`DOTALL`, :const:`S`"

#: ../../howto/regex.rst:543
msgid "Make ``.`` match any character, including newlines."
msgstr "``.`` を改行を含む任意の文字にマッチするようにします。"

#: ../../howto/regex.rst:546
msgid ":const:`IGNORECASE`, :const:`I`"
msgstr ":const:`IGNORECASE`, :const:`I`"

#: ../../howto/regex.rst:546
msgid "Do case-insensitive matches."
msgstr "大文字小文字を区別しないマッチを行います。"

#: ../../howto/regex.rst:548
msgid ":const:`LOCALE`, :const:`L`"
msgstr ":const:`LOCALE`, :const:`L`"

#: ../../howto/regex.rst:548
msgid "Do a locale-aware match."
msgstr "ロケールに対応したマッチを行います。"

#: ../../howto/regex.rst:550
msgid ":const:`MULTILINE`, :const:`M`"
msgstr ":const:`MULTILINE`, :const:`M`"

#: ../../howto/regex.rst:550
msgid "Multi-line matching, affecting ``^`` and ``$``."
msgstr ""
"``^`` や ``$`` の意味を変更し、複数行文字列に対するマッチングを行います。"

#: ../../howto/regex.rst:553
msgid ":const:`VERBOSE`, :const:`X` (for 'extended')"
msgstr ":const:`VERBOSE`, :const:`X` ('X' は 'extended' の 'X')"

#: ../../howto/regex.rst:553
msgid ""
"Enable verbose REs, which can be organized more cleanly and understandably."
msgstr ""
"冗長な正規表現を利用できるようにして、よりきれいで理解しやすくまとめることが"
"できます。"

#: ../../howto/regex.rst:562
msgid ""
"Perform case-insensitive matching; character class and literal strings will "
"match letters by ignoring case.  For example, ``[A-Z]`` will match lowercase "
"letters, too. Full Unicode matching also works unless the :const:`ASCII` "
"flag is used to disable non-ASCII matches.  When the Unicode patterns ``[a-"
"z]`` or ``[A-Z]`` are used in combination with the :const:`IGNORECASE` flag, "
"they will match the 52 ASCII letters and 4 additional non-ASCII letters: "
"'İ' (U+0130, Latin capital letter I with dot above), 'ı' (U+0131, Latin "
"small letter dotless i), 'ſ' (U+017F, Latin small letter long s) and "
"'K' (U+212A, Kelvin sign).  ``Spam`` will match ``'Spam'``, ``'spam'``, "
"``'spAM'``, or ``'ſpam'`` (the latter is matched only in Unicode mode). This "
"lowercasing doesn't take the current locale into account; it will if you "
"also set the :const:`LOCALE` flag."
msgstr ""
"大文字と小文字を区別しないマッチングを実行します; 文字クラスと文字列リテラル"
"は大文字か小文字かに関係なくパターンにマッチします。例えば、 ``[A-Z]`` は小文"
"字のアルファベットにもマッチします。 :const:`ASCII` フラグによって非 ASCII 文"
"字のマッチングが無効化されていなければ、完全なユニコードのマッチングも可能で"
"す。ユニコードで ``[a-z]`` または ``[A-Z]`` が :const:`IGNORECASE` フラグとと"
"もに使われると、 52個の ASCII 文字に加えて 次の4つの 非 ASCII 文字にマッチし"
"ます: 'İ' (U+0130, ラテン語の大文字 I で、上部に点がついたもの), "
"'ı' (U+0131, ラテン語の小文字 i で上部に点がない), 'ſ' (U+017F, ラテン語の小"
"文字 s),  'K' (U+212A, ケルビン記号)。 ``Spam`` は ``'Spam'``, ``'spam'``, "
"``'spAM'``, そして ``'ſpam'`` にマッチします (ただし最後の文字列はユニコード"
"モードの場合のみマッチします)。この「小文字化」は現在のロケールを考慮しませ"
"ん; ただし :const:`LOCALE` フラグをセットした場合はロケールを考慮します。"

#: ../../howto/regex.rst:580
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale instead of the Unicode database."
msgstr ""
"``\\w``, ``\\W``, ``\\b``,  ``\\B`` と小文字大文字の区別を無視したマッチング"
"を、 Unicode データベースではなく現在のロケールに従って行います。"

#: ../../howto/regex.rst:583
msgid ""
"Locales are a feature of the C library intended to help in writing programs "
"that take account of language differences.  For example, if you're "
"processing encoded French text, you'd want to be able to write ``\\w+`` to "
"match words, but ``\\w`` only matches the character class ``[A-Za-z]`` in "
"bytes patterns; it won't match bytes corresponding to ``é`` or ``ç``. If "
"your system is configured properly and a French locale is selected, certain "
"C functions will tell the program that the byte corresponding to ``é`` "
"should also be considered a letter. Setting the :const:`LOCALE` flag when "
"compiling a regular expression will cause the resulting compiled object to "
"use these C functions for ``\\w``; this is slower, but also enables ``\\w+`` "
"to match French words as you'd expect. The use of this flag is discouraged "
"in Python 3 as the locale mechanism is very unreliable, it only handles one "
"\"culture\" at a time, and it only works with 8-bit locales.  Unicode "
"matching is already enabled by default in Python 3 for Unicode (str) "
"patterns, and it is able to handle different locales/languages."
msgstr ""
"ロケールは言語の違いを考慮したプログラムを書くことを手助けすることを目的とし"
"た C ライブラリの機能です。例えば、エンコードされたフランス語のテキストを処理"
"していて、``\\w+`` を使って単語のマッチを行いたいとします。ですがこの場合、 "
"``\\w`` はバイトパターンにおいて文字クラス ``[A-Za-z]`` だけにマッチします; "
"すなわち ``é`` や ``ç`` に対応するバイト列にはマッチしません。もしシステムが"
"適切に設定されていて、ロケールがフランス語に設定されていれば、ある C 関数はプ"
"ログラムに ``é`` に対応するバイト列も文字として考慮するべきであると伝えます。"
"正規表現をコンパイルするときに :const:`LOCALE` フラグを設定すると、コンパイル"
"されたオブジェクトが ``\\w`` に対してロケールを考慮する C 関数を使うようにな"
"ります; これにより処理は遅くなりますが、 ``\\w+`` を期待通りフランス語の単語"
"にマッチさせることが可能になります。このフラグを Python 3 で利用することは推"
"奨されません。なぜならロケールの仕組みは非常に信頼性が低く、同時にひとつの "
"\"文化\" しか扱うことができず、また8ビットのロケールでしか正しく動作しないか"
"らです。Python 3 ではユニコード (文字列の) パターンに対してユニコードのマッチ"
"ングがデフォルトで有効化されており、これにより異なるロケールまたは言語を同時"
"に扱うことができます。   "

#: ../../howto/regex.rst:605
msgid ""
"(``^`` and ``$`` haven't been explained yet;  they'll be introduced in "
"section :ref:`more-metacharacters`.)"
msgstr ""
"(``^`` と ``$`` についてはまだ説明していません; これらは :ref:`more-"
"metacharacters` の節で説明します。)"

#: ../../howto/regex.rst:608
msgid ""
"Usually ``^`` matches only at the beginning of the string, and ``$`` matches "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. When this flag is specified, ``^`` matches at the "
"beginning of the string and at the beginning of each line within the string, "
"immediately following each newline.  Similarly, the ``$`` metacharacter "
"matches either at the end of the string and at the end of each line "
"(immediately preceding each newline)."
msgstr ""
"通常 ``^`` は文字列の先頭にマッチし、 ``$`` は文字列の末尾と文字列の末尾に改"
"行(があれば)その直前にマッチします。このフラグが指定されると、 ``^`` は文字列"
"の先頭と文字列の中の改行に続く各行の先頭にマッチします。同様に ``$`` 特殊文字"
"は文字列の末尾と各行の末尾(各改行の直前)のどちらにもマッチします。"

#: ../../howto/regex.rst:621
msgid ""
"Makes the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"特別な文字 ``'.'`` を改行を含む全ての任意の文字とマッチするようにします; この"
"フラグが無しでは、 ``'.'`` は改行 *以外* の全てにマッチします。"

#: ../../howto/regex.rst:629
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` perform ASCII-"
"only matching instead of full Unicode matching. This is only meaningful for "
"Unicode patterns, and is ignored for byte patterns."
msgstr ""
"``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s``, ``\\S`` が、完全な Unicode マッ"
"チングではなく、ASCII のみのマッチングをするようにします。これは Unicode パ"
"ターンにのみ意味があり、byte パターンには無視されます。"

#: ../../howto/regex.rst:638
msgid ""
"This flag allows you to write regular expressions that are more readable by "
"granting you more flexibility in how you can format them.  When this flag "
"has been specified, whitespace within the RE string is ignored, except when "
"the whitespace is in a character class or preceded by an unescaped "
"backslash; this lets you organize and indent the RE more clearly.  This flag "
"also lets you put comments within a RE that will be ignored by the engine; "
"comments are marked by a ``'#'`` that's neither in a character class or "
"preceded by an unescaped backslash."
msgstr ""
"このフラグはより柔軟な形式で正規表現を読み易く書けるようにします。このフラグ"
"を指定すると、正規表現の中の空白は無視されます、ただし、文字クラス内やエス"
"ケープされていないバックスラッシュに続く空白の場合は例外として無視されませ"
"ん; これによって正規表現をまとめたり、インデントしてより明確にすることができ"
"ます。このフラグはさらにエンジンが無視するコメントを追加することもできます; "
"コメントは ``'#'`` で示します、これは文字クラスやエスケープされていないバック"
"スラッシュに続くものであってはいけません。"

#: ../../howto/regex.rst:647
msgid ""
"For example, here's a RE that uses :const:`re.VERBOSE`; see how much easier "
"it is to read? ::"
msgstr ""
"例えば、ここに :const:`re.VERBOSE` を利用した正規表現があります; 読み易いと思"
"いませんか? ::"

#: ../../howto/regex.rst:660
msgid "Without the verbose setting, the RE would look like this::"
msgstr "冗長な表現を利用しない設定の場合、正規表現はこうなります::"

#: ../../howto/regex.rst:666
msgid ""
"In the above example, Python's automatic concatenation of string literals "
"has been used to break up the RE into smaller pieces, but it's still more "
"difficult to understand than the version using :const:`re.VERBOSE`."
msgstr ""
"上の例では、Python の文字列リテラルの自動結合によって正規表現を小さな部分に分"
"割しています、それでも :const:`re.VERBOSE` を使った場合に比べるとまだ難しく"
"なっています。"

#: ../../howto/regex.rst:672
msgid "More Pattern Power"
msgstr "パターンの能力をさらに"

#: ../../howto/regex.rst:674
msgid ""
"So far we've only covered a part of the features of regular expressions.  In "
"this section, we'll cover some new metacharacters, and how to use groups to "
"retrieve portions of the text that was matched."
msgstr ""
"ここまでで、正規表現の機能のほんの一部を扱ってきました。この節では、新たにい"
"くつかの特殊文字とグループを使ってマッチしたテキストの一部をどう取得するかに"
"ついて扱います。"

#: ../../howto/regex.rst:682
msgid "More Metacharacters"
msgstr "さらなる特殊文字"

#: ../../howto/regex.rst:684
msgid ""
"There are some metacharacters that we haven't covered yet.  Most of them "
"will be covered in this section."
msgstr ""
"これまでで、まだ扱っていない特殊文字がいくつかありました。そのほとんどをこの"
"節で扱っていきます。"

#: ../../howto/regex.rst:687
msgid ""
"Some of the remaining metacharacters to be discussed are :dfn:`zero-width "
"assertions`.  They don't cause the engine to advance through the string; "
"instead, they consume no characters at all, and simply succeed or fail.  For "
"example, ``\\b`` is an assertion that the current position is located at a "
"word boundary; the position isn't changed by the ``\\b`` at all.  This means "
"that zero-width assertions should never be repeated, because if they match "
"once at a given location, they can obviously be matched an infinite number "
"of times."
msgstr ""
"残りの特殊文字の内いくつかは :dfn:`ゼロ幅アサーション zero-width-assertions` "
"に関するものです。これらは文字列に対してエンジンを進めません; 文字列を全く利"
"用しない代わりに、単純に成功か失敗かを利用します。例えば、 ``\\b`` は現在位置"
"が単語の境界であることを示します; ``\\b`` によってエンジンの読んでいる位置は"
"全く変化しません。つまり、これはゼロ幅アサーションは繰り返し使うことがありま"
"せん、一度ある位置でマッチしたら、明らかに無限回マッチできます。"

#: ../../howto/regex.rst:703
msgid "``|``"
msgstr "``|``"

#: ../../howto/regex.rst:696
msgid ""
"Alternation, or the \"or\" operator.   If *A* and *B* are regular "
"expressions, ``A|B`` will match any string that matches either *A* or *B*. "
"``|`` has very low precedence in order to make it work reasonably when "
"you're alternating multi-character strings. ``Crow|Servo`` will match either "
"``'Crow'`` or ``'Servo'``, not ``'Cro'``, a ``'w'`` or an ``'S'``, and "
"``'ervo'``."
msgstr ""
"代替 (alternation) または \"or\" 演算子です。 *A* と *B* が正規表現の場合、 "
"``A|B`` は *A* と *B* のどちらかにマッチするような文字列にマッチします。複数"
"の文字からなる文字列による代替処理が適切に動作するために、 ``|`` の優先度は非"
"常に低く設定されています。 ``Crow|Servo`` は ``'Crow'`` か ``'Servo'`` のどち"
"らかにマッチするパターンであり、 「``'Cro'`` に続いて ``'w'`` または ``'S'`` "
"があり、さらに ``'ervo'`` が続く」という意味ではありません。"

#: ../../howto/regex.rst:702
msgid ""
"To match a literal ``'|'``, use ``\\|``, or enclose it inside a character "
"class, as in ``[|]``."
msgstr ""
"リテラル ``'|'`` にマッチするには、 ``\\|`` を利用するか、 ``[|]`` のように文"
"字クラス内に収めて下さい。"

#: ../../howto/regex.rst:718
msgid "``^``"
msgstr "``^``"

#: ../../howto/regex.rst:706
msgid ""
"Matches at the beginning of lines.  Unless the :const:`MULTILINE` flag has "
"been set, this will only match at the beginning of the string.  In :const:"
"`MULTILINE` mode, this also matches immediately after each newline within "
"the string."
msgstr ""
"行の先頭にマッチします。 :const:`MULTILINE` フラグが設定されない場合には、文"
"字列の先頭にのみマッチします。 :const:`MULTILINE` モードでは文字列内の各改行"
"の直後にマッチします。"

#: ../../howto/regex.rst:710
msgid ""
"For example, if you wish to match the word ``From`` only at the beginning of "
"a line, the RE to use is ``^From``. ::"
msgstr ""
"例えば、行の先頭の ``From`` にのみマッチさせたい場合には ``^From`` 正規表現を"
"利用します。 ::"

#: ../../howto/regex.rst:718
msgid "To match a literal ``'^'``, use ``\\^``."
msgstr "リテラル ``'^'`` にマッチするには ``\\^`` を利用してください。"

#: ../../howto/regex.rst:732
msgid "``$``"
msgstr "``$``"

#: ../../howto/regex.rst:721
msgid ""
"Matches at the end of a line, which is defined as either the end of the "
"string, or any location followed by a newline character.     ::"
msgstr ""
"行の末尾にマッチします、行の末尾は文字列の末尾と改行文字の直前として定義され"
"ます。 ::"

#: ../../howto/regex.rst:731
msgid ""
"To match a literal ``'$'``, use ``\\$`` or enclose it inside a character "
"class, as in  ``[$]``."
msgstr ""
"リテラル ``'$'`` にマッチするには、 ``\\$`` を利用するか、 ``[$]`` のように文"
"字クラス内に収めて下さい。"

#: ../../howto/regex.rst:738
msgid "``\\A``"
msgstr "``\\A``"

#: ../../howto/regex.rst:735
msgid ""
"Matches only at the start of the string.  When not in :const:`MULTILINE` "
"mode, ``\\A`` and ``^`` are effectively the same.  In :const:`MULTILINE` "
"mode, they're different: ``\\A`` still matches only at the beginning of the "
"string, but ``^`` may match at any location inside the string that follows a "
"newline character."
msgstr ""
"文字列の先頭にのみマッチします。 :const:`MULTILINE` モードでない場合には "
"``\\A`` と ``^`` は実質的に同じです。 :const:`MULTILINE` モードでのこれらの違"
"いは: ``\\A`` は依然として文字列の先頭にのみマッチしますが、 ``^`` は文字列内"
"に改行文字に続く部分があればそこにマッチすることです。"

#: ../../howto/regex.rst:741
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../howto/regex.rst:741
msgid "Matches only at the end of the string."
msgstr "文字列の末尾とのみマッチします。"

#: ../../howto/regex.rst:776
msgid "``\\b``"
msgstr "``\\b``"

#: ../../howto/regex.rst:744
msgid ""
"Word boundary.  This is a zero-width assertion that matches only at the "
"beginning or end of a word.  A word is defined as a sequence of alphanumeric "
"characters, so the end of a word is indicated by whitespace or a non-"
"alphanumeric character."
msgstr ""
"単語の境界。これはゼロ幅アサーションで、単語の始まりか終わりにのみマッチしま"
"す。単語は英数文字のシーケンスとして定義されます、つまり単語の終わりは空白か"
"非英数文字として表われます。"

#: ../../howto/regex.rst:749
msgid ""
"The following example matches ``class`` only when it's a complete word; it "
"won't match when it's contained inside another word. ::"
msgstr ""
"以下の例では ``class`` がそのものの単語のときのみマッチします; 別の単語内に含"
"まれている場合はマッチしません。 ::"

#: ../../howto/regex.rst:760
msgid ""
"There are two subtleties you should remember when using this special "
"sequence. First, this is the worst collision between Python's string "
"literals and regular expression sequences.  In Python's string literals, "
"``\\b`` is the backspace character, ASCII value 8.  If you're not using raw "
"strings, then Python will convert the ``\\b`` to a backspace, and your RE "
"won't match as you expect it to. The following example looks the same as our "
"previous RE, but omits the ``'r'`` in front of the RE string. ::"
msgstr ""
"この特殊シーケンスを利用するときには二つの微妙な点を心にとめておく必要があり"
"ます。まずひとつめは Python の文字列リテラルと表現の間の最悪の衝突を引き起す"
"ことです。Python の文字列リテラルでは ``\\b`` は ASCII 値8のバックスペース文"
"字です。raw string を利用していない場合、Python は ``\\b`` をバックスペースに"
"変換し、正規表現は期待するものとマッチしなくなります。以下の例はさきほどと同"
"じ正規表現のように見えますが、正規表現文字列の前の ``'r'`` が省略されていま"
"す。 ::"

#: ../../howto/regex.rst:774
msgid ""
"Second, inside a character class, where there's no use for this assertion, "
"``\\b`` represents the backspace character, for compatibility with Python's "
"string literals."
msgstr ""
"ふたつめはこのアサーションが利用できない文字列クラスの内部では Python の文字"
"列リテラルとの互換性のために、 ``\\b`` はバックスペース文字を表わすことになる"
"ということです。"

#: ../../howto/regex.rst:781
msgid "``\\B``"
msgstr "``\\B``"

#: ../../howto/regex.rst:779
msgid ""
"Another zero-width assertion, this is the opposite of ``\\b``, only matching "
"when the current position is not at a word boundary."
msgstr ""
"別のゼロ幅アサーションで、 ``\\b`` と逆で、現在の位置が単語の境界でないときに"
"のみマッチします。"

#: ../../howto/regex.rst:784
msgid "Grouping"
msgstr "グルーピング"

#: ../../howto/regex.rst:786
msgid ""
"Frequently you need to obtain more information than just whether the RE "
"matched or not.  Regular expressions are often used to dissect strings by "
"writing a RE divided into several subgroups which match different components "
"of interest. For example, an RFC-822 header line is divided into a header "
"name and a value, separated by a ``':'``, like this:"
msgstr ""
"正規表現にマッチするかどうかだけでなく、より多くの情報を得なければいけない場"
"合は多々あります。正規表現はしばしば、正規表現をいくつかのサブグループに分け"
"て興味ある部分にマッチするようにして、文字列を分割するのに使われます。例え"
"ば、RFC-822 ヘッダ行は ``':'`` を挟んでこのようにヘッダ名と値に分割されます:"

#: ../../howto/regex.rst:799
msgid ""
"This can be handled by writing a regular expression which matches an entire "
"header line, and has one group which matches the header name, and another "
"group which matches the header's value."
msgstr ""
"これはヘッダ全体にマッチし、そしてヘッダ名にマッチするグループとヘッダの値に"
"マッチする別のグループを持つように正規表現を書くことで扱うことができます。"

#: ../../howto/regex.rst:803
msgid ""
"Groups are marked by the ``'('``, ``')'`` metacharacters. ``'('`` and "
"``')'`` have much the same meaning as they do in mathematical expressions; "
"they group together the expressions contained inside them, and you can "
"repeat the contents of a group with a repeating qualifier, such as ``*``, "
"``+``, ``?``, or ``{m,n}``.  For example, ``(ab)*`` will match zero or more "
"repetitions of ``ab``. ::"
msgstr ""
"グループは特殊文字 ``'('``, ``')'`` で表わされます。 ``'('`` と ``')'`` は数"
"学での意味とほぼ同じ意味を持っています; その中に含まれた表現はまとめてグルー"
"プ化され、グループの中身を ``*``, ``+``, ``?`` や ``{m,n}`` のような繰り返し"
"の修飾子を使って繰り返すことができます。例えば、 ``(ab)*`` は ``ab`` の0回以"
"上の繰り返しにマッチします。 ::"

#: ../../howto/regex.rst:814
msgid ""
"Groups indicated with ``'('``, ``')'`` also capture the starting and ending "
"index of the text that they match; this can be retrieved by passing an "
"argument to :meth:`~re.Match.group`, :meth:`~re.Match.start`, :meth:`~re."
"Match.end`, and :meth:`~re.Match.span`.  Groups are numbered starting with "
"0.  Group 0 is always present; it's the whole RE, so :ref:`match object "
"<match-objects>` methods all have group 0 as their default argument.  Later "
"we'll see how to express groups that don't capture the span of text that "
"they match. ::"
msgstr ""
"``'('``, ``')'`` で指示されたグループは、マッチしたテキスト開始と終了位置も"
"キャプチャします; :meth:`~re.Match.group`, :meth:`~re.Match.start`, :meth:"
"`~re.Match.end`, :meth:`~re.Match.span` に引数を与えて取り出せます。グループ"
"はゼロ始まりの数値です。グループ 0 は常に使えます; それは RE でマッチした全体"
"で、 :ref:`Match オブジェクト <match-objects>` メソッドの全てはグループ 0 を"
"デフォルト引数にしています。マッチするテキストの範囲をキャプチャしないグルー"
"プの書き方はのちほど見ることにします。 ::"

#: ../../howto/regex.rst:830
msgid ""
"Subgroups are numbered from left to right, from 1 upward.  Groups can be "
"nested; to determine the number, just count the opening parenthesis "
"characters, going from left to right. ::"
msgstr ""
"サブグループは左から右へ1づつ番号付けされます。グループはネストしてもかまいま"
"せん; 番号を決めるには、単に開き括弧を左から右へ数え上げます。 ::"

#: ../../howto/regex.rst:843
msgid ""
":meth:`~re.Match.group` can be passed multiple group numbers at a time, in "
"which case it will return a tuple containing the corresponding values for "
"those groups. ::"
msgstr ""
":meth:`~re.Match.group` には一回に複数の引数を渡してもかまいません、その場合"
"にはそれらのグループに対応する値を含むタプルを返します。 ::"

#: ../../howto/regex.rst:849
msgid ""
"The :meth:`~re.Match.groups` method returns a tuple containing the strings "
"for all the subgroups, from 1 up to however many there are. ::"
msgstr ""
":meth:`~re.Match.groups` メソッドは 1 から全てのサブグループの文字列を含むタ"
"プルを返します。::"

#: ../../howto/regex.rst:855
msgid ""
"Backreferences in a pattern allow you to specify that the contents of an "
"earlier capturing group must also be found at the current location in the "
"string.  For example, ``\\1`` will succeed if the exact contents of group 1 "
"can be found at the current position, and fails otherwise.  Remember that "
"Python's string literals also use a backslash followed by numbers to allow "
"including arbitrary characters in a string, so be sure to use a raw string "
"when incorporating backreferences in a RE."
msgstr ""
"パターン中で後方参照を利用することで、前に取り出されたグループが文字列の中の"
"現在位置で見つかるように指定できます。例えば、``\\1`` はグループ1の内容が現在"
"位置で見つかった場合成功し、それ以外の場合に失敗します。Python の文字列リテラ"
"ルでもバックスラッシュに続く数字は任意の文字を文字列に含めるために使われると"
"いうことを心に留めておいて下さい、そのため正規表現で後方参照を含む場合には "
"raw string を必ず利用して下さい。"

#: ../../howto/regex.rst:863
msgid "For example, the following RE detects doubled words in a string. ::"
msgstr "例えば、以下の正規表現は二重になった単語を検出します。 ::"

#: ../../howto/regex.rst:869
msgid ""
"Backreferences like this aren't often useful for just searching through a "
"string --- there are few text formats which repeat data in this way --- but "
"you'll soon find out that they're *very* useful when performing string "
"substitutions."
msgstr ""
"このような後方参照は文字列を検索するだけの用途では多くの場合役に立ちませ"
"ん。--- このように繰り返されるテキストフォーマットは少数です。--- しかし、文"
"字列の置換をする場合には *とても* 有効であることに気づくでしょう。"

#: ../../howto/regex.rst:875
msgid "Non-capturing and Named Groups"
msgstr "取り出さないグループと名前つきグループ"

#: ../../howto/regex.rst:877
msgid ""
"Elaborate REs may use many groups, both to capture substrings of interest, "
"and to group and structure the RE itself.  In complex REs, it becomes "
"difficult to keep track of the group numbers.  There are two features which "
"help with this problem.  Both of them use a common syntax for regular "
"expression extensions, so we'll look at that first."
msgstr ""
"念入りに作られた正規表現は多くのグループを利用します、その利用法には対象とな"
"る部分文字列を取り出す、正規表現自身をグループ化したり構造化する、という二つ"
"の方法があります。複雑な正規表現では、グループ番号を追っていくことは困難に"
"なっていきます。この問題の解決を助ける二つの機能があります。その両方が正規表"
"現を拡張するための一般的な構文を利用します、まずはそれらをみてみましょう。"

#: ../../howto/regex.rst:883
msgid ""
"Perl 5 is well known for its powerful additions to standard regular "
"expressions. For these new features the Perl developers couldn't choose new "
"single-keystroke metacharacters or new special sequences beginning with "
"``\\`` without making Perl's regular expressions confusingly different from "
"standard REs.  If they chose ``&`` as a new metacharacter, for example, old "
"expressions would be assuming that ``&`` was a regular character and "
"wouldn't have escaped it by writing ``\\&`` or ``[&]``."
msgstr ""
"Perl 5 は標準正規表現にパワフルな拡張を加えたことでよく知られています。それら"
"の新しい機能のために Perl 開発者たちは、Perl正規表現と標準正規表現との混乱を"
"招く違いなしには、新たな一文字メタキャラクタも ``\\`` ではじまる新たな特殊"
"シーケンスもどちらも選択出来ませんでした。たとえば彼らがもし ``&`` を新たなメ"
"タキャラクタとして選んでいたら、 ``&`` が通常文字とみなされていた古い正規表現"
"は ``\\&`` や ``[&]`` のように書くことでエスケープされなければならなかったで"
"しょう。"

#: ../../howto/regex.rst:890
msgid ""
"The solution chosen by the Perl developers was to use ``(?...)`` as the "
"extension syntax.  ``?`` immediately after a parenthesis was a syntax error "
"because the ``?`` would have nothing to repeat, so this didn't introduce any "
"compatibility problems.  The characters immediately after the ``?``  "
"indicate what extension is being used, so ``(?=foo)`` is one thing (a "
"positive lookahead assertion) and ``(?:foo)`` is something else (a non-"
"capturing group containing the subexpression ``foo``)."
msgstr ""
"解決策として Perl 開発者が選んだものは ``(?...)`` を正規表現構文として利用す"
"ることでした。括弧の直後の ``?`` は構文エラーとなります、これは ``?`` で繰り"
"返す対象がないためです、そのためこれは互換性の問題を持ち込みません。 ``?`` の"
"直後の文字はどの拡張が利用されるかを示しています、つまり、 ``(?=foo)`` は一つ"
"の拡張を利用したもの (肯定先読みアサーション) となり、 ``(?:foo)`` は別の拡張"
"を利用した表現(``foo`` を含む取り込まないグループ)となります。"

#: ../../howto/regex.rst:898
msgid ""
"Python supports several of Perl's extensions and adds an extension syntax to "
"Perl's extension syntax.  If the first character after the question mark is "
"a ``P``, you know that it's an extension that's specific to Python."
msgstr ""
"Python は Perl の拡張のいくつかをサポートし、また、Perl の拡張に一つ拡張を加"
"えています。クエスチョンマークに続く最初の文字が ``P`` のものは、そうです、"
"Python 固有の拡張です。"

#: ../../howto/regex.rst:903
msgid ""
"Now that we've looked at the general extension syntax, we can return to the "
"features that simplify working with groups in complex REs."
msgstr ""
"一般化された拡張構文についてはわかりましたので、いよいよ複雑な正規表現内での"
"グループの扱いを単純化する機能に話を戻しましょう。"

#: ../../howto/regex.rst:906
msgid ""
"Sometimes you'll want to use a group to denote a part of a regular "
"expression, but aren't interested in retrieving the group's contents. You "
"can make this fact explicit by using a non-capturing group: ``(?:...)``, "
"where you can replace the ``...`` with any other regular expression. ::"
msgstr ""
"ときとしてあなたは、正規表現の一部として使いたいけれども、その内容を取り出す"
"ことに興味がないようなグループを記述する必要に迫られます。このためには、取り"
"出さないグループ: ``(?:...)`` を使います。 ``...`` 部分は任意の正規表現で"
"す。 ::"

#: ../../howto/regex.rst:918
msgid ""
"Except for the fact that you can't retrieve the contents of what the group "
"matched, a non-capturing group behaves exactly the same as a capturing "
"group; you can put anything inside it, repeat it with a repetition "
"metacharacter such as ``*``, and nest it within other groups (capturing or "
"non-capturing). ``(?:...)`` is particularly useful when modifying an "
"existing pattern, since you can add new groups without changing how all the "
"other groups are numbered.  It should be mentioned that there's no "
"performance difference in searching between capturing and non-capturing "
"groups; neither form is any faster than the other."
msgstr ""
"マッチしたグループの内容を取得しないということを除けば、取り込まないグループ"
"は厳密に取り込むグループと同様に振る舞います; この中に何を入れてもかまいませ"
"ん、 ``*`` のような繰り返しの特殊文字で繰り返したり、他のグループ (取り込むま"
"たは取り込まない) の入れ子にすることもでいます。 ``(?:...)`` は特に、既にある"
"パターンを変更する際に便利です、なぜなら他の番号づけ新しいグループを変更する"
"ことなく新しいグループを追加することができます。取り込むグループと取り込まな"
"いグループで検索のパフォーマンスに差がないことにも触れておくべきことです; ど"
"ちらも同じ速度で動作します。"

#: ../../howto/regex.rst:927
msgid ""
"A more significant feature is named groups: instead of referring to them by "
"numbers, groups can be referenced by a name."
msgstr ""
"より重要な機能は名前つきグループです: 番号で参照する代わりに、グループに対し"
"て名前で参照できます。"

#: ../../howto/regex.rst:930
msgid ""
"The syntax for a named group is one of the Python-specific extensions: ``(?"
"P<name>...)``.  *name* is, obviously, the name of the group.  Named groups "
"behave exactly like capturing groups, and additionally associate a name with "
"a group.  The :ref:`match object <match-objects>` methods that deal with "
"capturing groups all accept either integers that refer to the group by "
"number or strings that contain the desired group's name.  Named groups are "
"still given numbers, so you can retrieve information about a group in two "
"ways::"
msgstr ""
"名前つきグループのための構文は、 Python 固有拡張の一つ: ``(?P<name>...)`` を"
"使います。 *name* は、もちろん、グループの名前です。名前つきグループは取り込"
"むグループと完全に同じに振る舞い、加えて名前が関連付けられます。 :ref:`Match "
"オブジェクト <match-objects>` の取りこむグループを扱うメソッドは全て、番号に"
"よるグループ参照のための整数、名前によるグループ参照のための文字列、ともに許"
"容しています。名前つきグループにも番号が振られますので、グループについての情"
"報を、2つの方法で取り出せます::"

#: ../../howto/regex.rst:945
msgid ""
"Additionally, you can retrieve named groups as a dictionary with :meth:`~re."
"Match.groupdict`::"
msgstr ""
"さらに、名前付きのグループを :meth:`~re.Match.groupdict` を使って辞書として取"
"り出すこともできます::"

#: ../../howto/regex.rst:952
msgid ""
"Named groups are handy because they let you use easily-remembered names, "
"instead of having to remember numbers.  Here's an example RE from the :mod:"
"`imaplib` module::"
msgstr ""
"名前つきグループは、番号を覚える代わりに、簡単に覚えられる名前を利用できるの"
"で、簡単に扱うことができます。これは :mod:`imaplib` モジュールから正規表現の"
"例です::"

#: ../../howto/regex.rst:963
msgid ""
"It's obviously much easier to retrieve ``m.group('zonem')``, instead of "
"having to remember to retrieve group 9."
msgstr ""
"取得する番号9を覚えるよりも、 ``m.group('zonem')`` で取得した方が明らかに簡単"
"にすみます。"

#: ../../howto/regex.rst:966
msgid ""
"The syntax for backreferences in an expression such as ``(...)\\1`` refers "
"to the number of the group.  There's naturally a variant that uses the group "
"name instead of the number. This is another Python extension: ``(?P=name)`` "
"indicates that the contents of the group called *name* should again be "
"matched at the current point.  The regular expression for finding doubled "
"words, ``\\b(\\w+)\\s+\\1\\b`` can also be written as ``\\b(?"
"P<word>\\w+)\\s+(?P=word)\\b``::"
msgstr ""
"後方参照のための構文 ``(...)\\1`` はグループ番号への参照となっています。\n"
"グループ番号の代わりに、グループ名を利用する変種があるのは当然でしょう。\n"
"これはもう一つの Python 拡張です: ``(?P=name)`` は、 *name* という名前のグ"
"ループの内容が、現在の位置で再びマッチすることを示しています。\n"
"同じ単語が2つ連なっているのを見つける正規表現 ``\\b(\\w+)\\s+\\1\\b`` は "
"``\\b(?P<word>\\w+)\\s+(?P=word)\\b`` のように書けます::"

#: ../../howto/regex.rst:979
msgid "Lookahead Assertions"
msgstr "先読みアサーション (Lookahead Assertions)"

#: ../../howto/regex.rst:981
msgid ""
"Another zero-width assertion is the lookahead assertion.  Lookahead "
"assertions are available in both positive and negative form, and  look like "
"this:"
msgstr ""
"他のゼロ幅アサーションは先読みアサーションです。先読みアサーションは肯定、否"
"定の両方の形式が利用可能です、これを見てください:"

#: ../../howto/regex.rst:989
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../howto/regex.rst:985
msgid ""
"Positive lookahead assertion.  This succeeds if the contained regular "
"expression, represented here by ``...``, successfully matches at the current "
"location, and fails otherwise. But, once the contained expression has been "
"tried, the matching engine doesn't advance at all; the rest of the pattern "
"is tried right where the assertion started."
msgstr ""
"肯定先読みアサーション。 ``...`` で表わす正規表現が現在位置でマッチすれば成功"
"し、それ以外の場合失敗します。しかし、表現が試行された場合でもエンジンは先に"
"進みません; パターンの残りの部分はアサーションの開始時点から右に試行します。"

#: ../../howto/regex.rst:994
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../howto/regex.rst:992
msgid ""
"Negative lookahead assertion.  This is the opposite of the positive "
"assertion; it succeeds if the contained expression *doesn't* match at the "
"current position in the string."
msgstr ""
"否定先読みアサーション。これは肯定アサーションの逆で、正規表現が文字列の現在"
"位置にマッチ *しなかった* 場合に成功します。"

#: ../../howto/regex.rst:996
msgid ""
"To make this concrete, let's look at a case where a lookahead is useful. "
"Consider a simple pattern to match a filename and split it apart into a base "
"name and an extension, separated by a ``.``.  For example, in ``news.rc``, "
"``news`` is the base name, and ``rc`` is the filename's extension."
msgstr ""
"より具体的にするため、先読みが便利な場合をみてみましょう。ファイル名にマッチ"
"し、 ``.`` で分けられた基本部分と拡張子に分離する単純なパターンを考えましょ"
"う。例えば、 ``news.rc`` は ``news`` が基本部分で ``rc`` がファイル名の拡張子"
"です。"

#: ../../howto/regex.rst:1001
msgid "The pattern to match this is quite simple:"
msgstr "マッチするパターンはとても単純です:"

#: ../../howto/regex.rst:1003
msgid "``.*[.].*$``"
msgstr "``.*[.].*$``"

#: ../../howto/regex.rst:1005
msgid ""
"Notice that the ``.`` needs to be treated specially because it's a "
"metacharacter, so it's inside a character class to only match that specific "
"character.  Also notice the trailing ``$``; this is added to ensure that all "
"the rest of the string must be included in the extension.  This regular "
"expression matches ``foo.bar`` and ``autoexec.bat`` and ``sendmail.cf`` and "
"``printers.conf``."
msgstr ""
"``.`` はメタキャラクタですので特別に扱わなければなりませんから、文字クラス内"
"に入れて、そのものとだけマッチするようにしていることに注目です。末尾の ``$`` "
"にも注目してください; これは残り全ての文字列が拡張子に含まれるべきであること"
"を保障するために追加しています。この正規表現は ``foo.bar``, ``autoexec."
"bat``, ``sendmail.cf``, ``printers.conf`` にマッチします。"

#: ../../howto/regex.rst:1012
msgid ""
"Now, consider complicating the problem a bit; what if you want to match "
"filenames where the extension is not ``bat``? Some incorrect attempts:"
msgstr ""
"さて、問題を少し複雑にしてみましょう; 拡張子が ``bat`` でないファイル名にマッ"
"チしたい場合はどうでしょう？間違った試み:"

#: ../../howto/regex.rst:1015
msgid ""
"``.*[.][^b].*$``  The first attempt above tries to exclude ``bat`` by "
"requiring that the first character of the extension is not a ``b``.  This is "
"wrong, because the pattern also doesn't match ``foo.bar``."
msgstr ""
"``.*[.][^b].*$`` この最初の ``bat`` を除く試みは、最初の文字が ``b`` でないこ"
"とを要求します。これは誤っています、なぜなら ``foo.bar`` にもマッチしないから"
"です。"

#: ../../howto/regex.rst:1019
msgid "``.*[.]([^b]..|.[^a].|..[^t])$``"
msgstr "``.*[.]([^b]..|.[^a].|..[^t])$``"

#: ../../howto/regex.rst:1021
msgid ""
"The expression gets messier when you try to patch up the first solution by "
"requiring one of the following cases to match: the first character of the "
"extension isn't ``b``; the second character isn't ``a``; or the third "
"character isn't ``t``.  This accepts ``foo.bar`` and rejects ``autoexec."
"bat``, but it requires a three-letter extension and won't accept a filename "
"with a two-letter extension such as ``sendmail.cf``.  We'll complicate the "
"pattern again in an effort to fix it."
msgstr ""
"正規表現が混乱してきました。最初の解決策を取り繕って、以下の場合に合わせるこ"
"とを要求しています: 拡張子の最初の文字は ``b`` でなく; 二番目の文字は ``a`` "
"でなく; 三番目の文字は ``t`` でない。これは ``foo.bar`` を受け付けますが、 "
"``autoexec.bat`` は拒否します。しかし、三文字の拡張子を要求し、 ``sendmail."
"cf`` のような二文字の拡張子を受け付けません。これを修正するのにパターンを再び"
"複雑にすることになります。"

#: ../../howto/regex.rst:1029
msgid "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"
msgstr "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"

#: ../../howto/regex.rst:1031
msgid ""
"In the third attempt, the second and third letters are all made optional in "
"order to allow matching extensions shorter than three characters, such as "
"``sendmail.cf``."
msgstr ""
"三番目の試みでは、 ``sendmail.cf`` のように三文字より短い拡張子とマッチするた"
"めに第二第三の文字を全てオプションにしています。"

#: ../../howto/regex.rst:1035
msgid ""
"The pattern's getting really complicated now, which makes it hard to read "
"and understand.  Worse, if the problem changes and you want to exclude both "
"``bat`` and ``exe`` as extensions, the pattern would get even more "
"complicated and confusing."
msgstr ""
"パターンはさらに複雑さを増し、読みにくく、理解が難しくなりました。より悪いこ"
"とに、問題が ``bat`` と ``exe`` 両方を拡張子から除きたい場合に変わった場合、"
"パターンはより複雑で混乱しやすいものになります。"

#: ../../howto/regex.rst:1040
msgid "A negative lookahead cuts through all this confusion:"
msgstr "否定先読みはこの混乱全てを取り除きます:"

#: ../../howto/regex.rst:1042
msgid ""
"``.*[.](?!bat$)[^.]*$``  The negative lookahead means: if the expression "
"``bat`` doesn't match at this point, try the rest of the pattern; if "
"``bat$`` does match, the whole pattern will fail.  The trailing ``$`` is "
"required to ensure that something like ``sample.batch``, where the extension "
"only starts with ``bat``, will be allowed.  The ``[^.]*`` makes sure that "
"the pattern works when there are multiple dots in the filename."
msgstr ""
"``.*[.](?!bat$)[^.]*$`` 否定先読みは以下を意味します: この位置で拡張子 "
"``bat`` にマッチしない場合、残りのパターンが試行されます; もし ``bat$`` に"
"マッチすればパターン全体が失敗します。``$`` を続けることで、``sample.batch`` "
"にように ``bat`` で始まる拡張子を許容することを保証しています。\n"
"このパターンで ``[^.]*`` を使うことで、ファイル名に複数のドットがあったときに"
"も上手くいくようになります。"

#: ../../howto/regex.rst:1049
msgid ""
"Excluding another filename extension is now easy; simply add it as an "
"alternative inside the assertion.  The following pattern excludes filenames "
"that end in either ``bat`` or ``exe``:"
msgstr ""
"他のファイル名の拡張子を除くことも簡単です; 単純にアサーション内に拡張子を代"
"替 (or) で加えます。以下のパターンは ``bat`` や ``exe`` のどちらかで終わる"
"ファイル名を除外します:"

#: ../../howto/regex.rst:1053
msgid "``.*[.](?!bat$|exe$)[^.]*$``"
msgstr "``.*[.](?!bat$|exe$)[^.]*$``"

#: ../../howto/regex.rst:1057
msgid "Modifying Strings"
msgstr "文字列を変更する"

#: ../../howto/regex.rst:1059
msgid ""
"Up to this point, we've simply performed searches against a static string. "
"Regular expressions are also commonly used to modify strings in various "
"ways, using the following pattern methods:"
msgstr ""
"ここまででは単純に静的な文字列に対する検索を実行してきました。正規表現は文字"
"列を様々な方法で変更するのにもよく使われます。変更には以下のパターンメソッド"
"が利用されます:"

#: ../../howto/regex.rst:1066
msgid "``split()``"
msgstr "``split()``"

#: ../../howto/regex.rst:1066
msgid "Split the string into a list, splitting it wherever the RE matches"
msgstr "文字列をリストに分割する、正規表現がマッチした全ての場所で分割を行う"

#: ../../howto/regex.rst:1069
msgid "``sub()``"
msgstr "``sub()``"

#: ../../howto/regex.rst:1069
msgid ""
"Find all substrings where the RE matches, and replace them with a different "
"string"
msgstr "正規表現にマッチした全ての文字列を発見し、別の文字列に置き換えます"

#: ../../howto/regex.rst:1072
msgid "``subn()``"
msgstr "``subn()``"

#: ../../howto/regex.rst:1072
msgid ""
"Does the same thing as :meth:`!sub`,  but returns the new string and the "
"number of replacements"
msgstr ""
":meth:`!sub` と同じことをしますが、新しい文字列と置き換えの回数を返します"

#: ../../howto/regex.rst:1079
msgid "Splitting Strings"
msgstr "文字列の分割"

#: ../../howto/regex.rst:1081
msgid ""
"The :meth:`~re.Pattern.split` method of a pattern splits a string apart "
"wherever the RE matches, returning a list of the pieces. It's similar to "
"the :meth:`~str.split` method of strings but provides much more generality "
"in the delimiters that you can split by; string :meth:`!split` only supports "
"splitting by whitespace or by a fixed string.  As you'd expect, there's a "
"module-level :func:`re.split` function, too."
msgstr ""
":meth:`~re.Match.split` メソッドは文字列を正規表現にマッチした場所で分割し、"
"リストで返却します。文字列の :meth:`~str.split` メソッドに似てはいますが、"
"もっとずっと一般化したデリミタで分割出来ます; 文字列の :meth:`!split` メソッ"
"ドは単に空白文字か固定文字列で分割出来るだけです。ご想像通り、モジュールレベ"
"ルの :func:`re.split` 関数もあります。"

#: ../../howto/regex.rst:1092
msgid ""
"Split *string* by the matches of the regular expression.  If capturing "
"parentheses are used in the RE, then their contents will also be returned as "
"part of the resulting list.  If *maxsplit* is nonzero, at most *maxsplit* "
"splits are performed."
msgstr ""
"*string* を正規表現のマッチで分割します。正規表現内に取り込むための括弧が利用"
"されている場合、その内容も結果のリストの一部として返されます。 *maxsplit* が"
"非ゼロの場合、最大で *maxsplit* の分割が実行されます。"

#: ../../howto/regex.rst:1097
msgid ""
"You can limit the number of splits made, by passing a value for *maxsplit*. "
"When *maxsplit* is nonzero, at most *maxsplit* splits will be made, and the "
"remainder of the string is returned as the final element of the list.  In "
"the following example, the delimiter is any sequence of non-alphanumeric "
"characters. ::"
msgstr ""
"*maxsplit* に値を渡すことで、分割される回数を制限することができます。 "
"*maxsplit* が非ゼロの場合、最大で *maxsplit* の分割が行なわれ、文字列の残りが"
"リストの最終要素として返されます。以下の例では、デリミタは任意の英数文字の"
"シーケンスです。 ::"

#: ../../howto/regex.rst:1109
msgid ""
"Sometimes you're not only interested in what the text between delimiters is, "
"but also need to know what the delimiter was.  If capturing parentheses are "
"used in the RE, then their values are also returned as part of the list.  "
"Compare the following calls::"
msgstr ""
"興味の対象がデリミタの間のテキストだけでなく、デリミタが何なのかということを"
"知りたい場合はよくあります。取りこみ用の括弧を正規表現に使った場合、その値も"
"リストの一部として返されます。以下の呼び出しを比較してみましょう::"

#: ../../howto/regex.rst:1121
msgid ""
"The module-level function :func:`re.split` adds the RE to be used as the "
"first argument, but is otherwise the same.   ::"
msgstr ""
"モジュールレベル関数 :func:`re.split` は最初の引数に利用する正規表現を追加し"
"ますが、それ以外は同じです。 ::"

#: ../../howto/regex.rst:1133
msgid "Search and Replace"
msgstr "検索と置換"

#: ../../howto/regex.rst:1135
msgid ""
"Another common task is to find all the matches for a pattern, and replace "
"them with a different string.  The :meth:`~re.Pattern.sub` method takes a "
"replacement value, which can be either a string or a function, and the "
"string to be processed."
msgstr ""
"もう一つのよくある作業は、パターンにマッチする全ての文字列を探し、異なる文字"
"列に置換します。\n"
":meth:`~re.Pattern.sub` メソッドは置換する値をとります、文字列と関数の両方を"
"とることができ、文字列を処理します。"

#: ../../howto/regex.rst:1142
msgid ""
"Returns the string obtained by replacing the leftmost non-overlapping "
"occurrences of the RE in *string* by the replacement *replacement*.  If the "
"pattern isn't found, *string* is returned unchanged."
msgstr ""
"*string* 内で最も長く、他の部分と重複するところがない正規表現をを "
"*replacement* に置換した文字列を返します。パターンが見つからなかった場合 "
"*string* は変更されずに返されます。"

#: ../../howto/regex.rst:1146
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  The default value "
"of 0 means to replace all occurrences."
msgstr ""
"オプション引数 *count* はパターンの出現の最大置換回数です; *count* は非負の整"
"数でなければいけません。デフォルト値 0 は全ての出現で置換することを意味しま"
"す。"

#: ../../howto/regex.rst:1150
msgid ""
"Here's a simple example of using the :meth:`~re.Pattern.sub` method.  It "
"replaces colour names with the word ``colour``::"
msgstr ""
"ここに :meth:`~re.Pattern.sub` メソッドを使った単純な例があります。これは色の"
"名前を ``colour`` に置換します::"

#: ../../howto/regex.rst:1159
msgid ""
"The :meth:`~re.Pattern.subn` method does the same work, but returns a 2-"
"tuple containing the new string value and the number of replacements  that "
"were performed::"
msgstr ""
":meth:`~re.Pattern.subn` メソッドも同じ働きをしますが、新しい文字列と置換の実"
"行回数を含む 2-タプルを返します::"

#: ../../howto/regex.rst:1168
msgid ""
"Empty matches are replaced only when they're not adjacent to a previous "
"empty match. ::"
msgstr ""
"空文字列とのマッチは、直前の空文字列とマッチした部分と隣接していない場合にの"
"み置換されます。 ::"

#: ../../howto/regex.rst:1175
msgid ""
"If *replacement* is a string, any backslash escapes in it are processed.  "
"That is, ``\\n`` is converted to a single newline character, ``\\r`` is "
"converted to a carriage return, and so forth. Unknown escapes such as "
"``\\&`` are left alone. Backreferences, such as ``\\6``, are replaced with "
"the substring matched by the corresponding group in the RE.  This lets you "
"incorporate portions of the original text in the resulting replacement "
"string."
msgstr ""
"*replacement* が文字列の場合、文字列内のバックスラッシュエスケープは処理され"
"ます。つまり、``\\n`` は改行文字に ``\\r`` はキャリッジリターンに、等となりま"
"す。``\\&`` のような未知のエスケープシーケンスはそのまま残されます。``\\6`` "
"のような後方参照は正規表現内の対応するグループにマッチする文字列に置換されま"
"す。これを使うことで元のテキストの一部を、置換後の文字列に組み込むことができ"
"ます。"

#: ../../howto/regex.rst:1182
msgid ""
"This example matches the word ``section`` followed by a string enclosed in "
"``{``, ``}``, and changes ``section`` to ``subsection``::"
msgstr ""
"この例は単語 ``section`` に続く ``{`` と ``}`` で閉じられた文字列にマッチ"
"し、 ``section`` を ``subsection`` に変更します::"

#: ../../howto/regex.rst:1189
msgid ""
"There's also a syntax for referring to named groups as defined by the ``(?"
"P<name>...)`` syntax.  ``\\g<name>`` will use the substring matched by the "
"group named ``name``, and  ``\\g<number>``  uses the corresponding group "
"number. ``\\g<2>`` is therefore equivalent to ``\\2``,  but isn't ambiguous "
"in a replacement string such as ``\\g<2>0``.  (``\\20`` would be interpreted "
"as a reference to group 20, not a reference to group 2 followed by the "
"literal character ``'0'``.)  The following substitutions are all equivalent, "
"but use all three variations of the replacement string. ::"
msgstr ""
"``(?P<name>...)`` 構文で定義された名前つきグループを参照するための構文もあり"
"ます。 ``\\g<name>`` は ``name`` で名前づけされたグループにマッチする文字列を"
"利用し、 ``\\g<number>`` は対応するグループ番号を利用します。つまり "
"``\\g<2>`` は ``\\2`` と等価ですが、 ``\\g<2>0`` のような置換文字列に対しては"
"明確に異なります。 (``\\20`` はグループ番号20への参照と解釈され、グループ2の"
"後にリテラル文字 ``'0'`` が続くとは解釈されません。) 以下に示す置換は全て等価"
"ですが、これらは文字列置換に全部で3種の変種を利用しています。 ::"

#: ../../howto/regex.rst:1206
msgid ""
"*replacement* can also be a function, which gives you even more control.  If "
"*replacement* is a function, the function is called for every non-"
"overlapping occurrence of *pattern*.  On each call, the function is passed "
"a :ref:`match object <match-objects>` argument for the match and can use "
"this information to compute the desired replacement string and return it."
msgstr ""
"より細かな制御を手中にするために *replacement* として関数を使うことが出来ま"
"す。 *replacement* が関数であれば、その関数は重なり合わない *pattern* の発生"
"のたびに呼び出されます。それぞれの呼び出しで、マッチした :ref:`Match オブジェ"
"クト <match-objects>` が引数として渡されるので、望みの置換と返却のためにこの"
"情報を利用出来ます。"

#: ../../howto/regex.rst:1212
msgid ""
"In the following example, the replacement function translates decimals into "
"hexadecimal::"
msgstr "続く例では、置換関数は十進数文字列を十六進数文字列に変換しています::"

#: ../../howto/regex.rst:1224
msgid ""
"When using the module-level :func:`re.sub` function, the pattern is passed "
"as the first argument.  The pattern may be provided as an object or as a "
"string; if you need to specify regular expression flags, you must either use "
"a pattern object as the first parameter, or use embedded modifiers in the "
"pattern string, e.g. ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` returns ``'x "
"x'``."
msgstr ""
"モジュールレベルの :func:`re.sub` 関数を使うときには、パターンが最初の引数と"
"して渡されます。パターンはオブジェクトや文字列をとります; 正規表現フラグを指"
"定する必要がある場合、パターンオブジェクトを最初の引数として使うか、修飾子を"
"埋め込んだパターン文字列を使うかしなければいけません、例えば ``sub(\"(?i)b+"
"\", \"x\", \"bbbb BBBB\")`` は ``'x x'`` を返します。"

#: ../../howto/regex.rst:1232
msgid "Common Problems"
msgstr "よくある問題"

#: ../../howto/regex.rst:1234
msgid ""
"Regular expressions are a powerful tool for some applications, but in some "
"ways their behaviour isn't intuitive and at times they don't behave the way "
"you may expect them to.  This section will point out some of the most common "
"pitfalls."
msgstr ""
"正規表現はいくつかの応用に対して強力なツールですが、いくつかの部分でそれらの"
"振る舞いは直感的ではなく、期待通りに振る舞わないことがあります。この節では最"
"もよくある落とし穴を指摘します。"

#: ../../howto/regex.rst:1240
msgid "Use String Methods"
msgstr "文字列メソッドを利用する"

#: ../../howto/regex.rst:1242
msgid ""
"Sometimes using the :mod:`re` module is a mistake.  If you're matching a "
"fixed string, or a single character class, and you're not using any :mod:"
"`re` features such as the :const:`~re.IGNORECASE` flag, then the full power "
"of regular expressions may not be required. Strings have several methods for "
"performing operations with fixed strings and they're usually much faster, "
"because the implementation is a single small C loop that's been optimized "
"for the purpose, instead of the large, more generalized regular expression "
"engine."
msgstr ""
"いくつかの場合 :mod:`re` モジュールを利用することは間違いである場合がありま"
"す。固定文字列や単一の文字クラスにマッチさせる場合や、 :const:`~re."
"IGNORECASE` フラグのような :mod:`re` の機能を利用しない場合、正規表現の全ての"
"能力は必要とされていなでしょう。文字列は固定文字列に対する操作を実行するメ"
"ソッドを持っていて、大きな汎用化された正規表現エンジンではなく、目的のために"
"最適化された単一の小さな C loop で実装されているため、大抵の場合高速です."

#: ../../howto/regex.rst:1250
msgid ""
"One example might be replacing a single fixed string with another one; for "
"example, you might replace ``word`` with ``deed``.  :func:`re.sub` seems "
"like the function to use for this, but consider the :meth:`~str.replace` "
"method.  Note that :meth:`!replace` will also replace ``word`` inside words, "
"turning ``swordfish`` into ``sdeedfish``, but the  naive RE ``word`` would "
"have done that, too.  (To avoid performing the substitution on parts of "
"words, the pattern would have to be ``\\bword\\b``, in order to require that "
"``word`` have a word boundary on either side.  This takes the job beyond  :"
"meth:`!replace`'s abilities.)"
msgstr ""
"一つの例としては、単一の固定文字列を別の固定文字列に置き換える作業があるで"
"しょう; 例えば ``word`` を ``deed`` で置換したい場合です。\n"
":func:`re.sub` はこの目的で使う関数のように思えますが、 :meth:`~str.replace` "
"メソッドを利用することを考えた方がいいでしょう。\n"
":meth:`!replace` は単語内の ``word`` も置換し、 ``swordfish`` を "
"``sdeedfish`` に変えますが、安直な正規表現 ``word`` も同様に動作することに注"
"意して下さい。(単語の一部に対する置換の実行を避けるには、パターンを "
"``\\bword\\b`` として、 ``word`` の両側に単語の境界が要求されるようにします。"
"これは :meth:`!replace` の能力を越えた作業です。)"

#: ../../howto/regex.rst:1259
msgid ""
"Another common task is deleting every occurrence of a single character from "
"a string or replacing it with another single character.  You might do this "
"with something like ``re.sub('\\n', ' ', S)``, but :meth:`~str.translate` is "
"capable of doing both tasks and will be faster than any regular expression "
"operation can be."
msgstr ""
"別のよくある作業は、文字列の中に出現する文字を全て削除することと、別の文字で"
"置換することです。この作業を ``re.sub('\\n', ' ', S)`` のようにして行うかもし"
"れませんが、 :meth:`~str.translate` は削除と置換の両方の作業をこなし、正規表"
"現操作よりも高速に行うことができます。"

#: ../../howto/regex.rst:1265
msgid ""
"In short, before turning to the :mod:`re` module, consider whether your "
"problem can be solved with a faster and simpler string method."
msgstr ""
"要は、 :mod:`re` モジュールに向う前に問題が高速で単純な文字列メソッドで解決で"
"きるか考えましょうということです。"

#: ../../howto/regex.rst:1270
msgid "match() versus search()"
msgstr "match() 対 search()"

#: ../../howto/regex.rst:1272
msgid ""
"The :func:`~re.match` function only checks if the RE matches at the "
"beginning of the string while :func:`~re.search` will scan forward through "
"the string for a match. It's important to keep this distinction in mind.  "
"Remember,  :func:`!match` will only report a successful match which will "
"start at 0; if the match wouldn't start at zero,  :func:`!match` will *not* "
"report it. ::"
msgstr ""
":func:`~re.match` 関数は文字列の先頭に正規表現がマッチするかどうか調べるだけ"
"ですが、その一方 :func:`~re.search` はマッチするために文字列の先の方まで走査"
"します。\n"
"この違いを覚えておくことは重要なことです。\n"
":func:`!match` は開始位置0でマッチが成功したときのみ報告する; もし開始位置0で"
"マッチしなければ、 :func:`!match` はそれを報告 *しない* 、ということを覚えて"
"おいてください。 ::"

#: ../../howto/regex.rst:1283
msgid ""
"On the other hand, :func:`~re.search` will scan forward through the string, "
"reporting the first match it finds. ::"
msgstr ""
"一方 :func:`~re.search` は文字列の先の方まで走査し、最初にみつけたマッチを報"
"告します。::"

#: ../../howto/regex.rst:1291
msgid ""
"Sometimes you'll be tempted to keep using :func:`re.match`, and just add ``."
"*`` to the front of your RE.  Resist this temptation and use :func:`re."
"search` instead.  The regular expression compiler does some analysis of REs "
"in order to speed up the process of looking for a match.  One such analysis "
"figures out what the first character of a match must be; for example, a "
"pattern starting with ``Crow`` must match starting with a ``'C'``.  The "
"analysis lets the engine quickly scan through the string looking for the "
"starting character, only trying the full match if a ``'C'`` is found."
msgstr ""
"しばしば、 :func:`re.match` を使い、 ``.*`` を正規表現の最初に付け加える誘惑"
"にからされることがあるでしょう。この誘惑に打ち克って、代わりに :func:`re."
"search` を利用すべきです。正規表現コンパイラはマッチを探す処理の高速化のため"
"にいくつかの解析を行います。そのような解析のうちのひとつはマッチの最初の文字"
"が何であるか評価することです; 例えば、 ``Crow`` で始まるパターンは ``'C'`` か"
"ら始まらなければいけません。解析によってエンジンは速やかに開始文字を探して走"
"査します、 ``'C'`` が発見された場合にはじめて完全なマッチを試みます。"

#: ../../howto/regex.rst:1300
msgid ""
"Adding ``.*`` defeats this optimization, requiring scanning to the end of "
"the string and then backtracking to find a match for the rest of the RE.  "
"Use :func:`re.search` instead."
msgstr ""
"``.*`` を追加することはこの最適化を無効にします、文字列の終端までの走査が必要"
"となり、走査後には残りの正規表現とのマッチ部分を見つけるために引き返すことに"
"なります。代わりに :func:`re.search` を利用して下さい。"

#: ../../howto/regex.rst:1306
msgid "Greedy versus Non-Greedy"
msgstr "貪欲 (greedy) 対非貪欲 (non-greedy)"

#: ../../howto/regex.rst:1308
msgid ""
"When repeating a regular expression, as in ``a*``, the resulting action is "
"to consume as much of the pattern as possible.  This fact often bites you "
"when you're trying to match a pair of balanced delimiters, such as the angle "
"brackets surrounding an HTML tag.  The naive pattern for matching a single "
"HTML tag doesn't work because of the greedy nature of ``.*``. ::"
msgstr ""
"正規表現を繰り返す場合、たとえば ``a*`` のように、できるだけパターンの多くに"
"マッチするように動作することになります。この動作は、例えば角括弧で囲まれた "
"HTML タグのような左右対称のデリミタの対にマッチしようという場合に問題となりま"
"す。単一の HTML タグにマッチする素朴な正規表現はうまく動作しません、なぜなら"
"ば ``.*`` は貪欲に動作するからです。 ::"

#: ../../howto/regex.rst:1322
msgid ""
"The RE matches the ``'<'`` in ``'<html>'``, and the ``.*`` consumes the rest "
"of the string.  There's still more left in the RE, though, and the ``>`` "
"can't match at the end of the string, so the regular expression engine has "
"to backtrack character by character until it finds a match for the ``>``.   "
"The final match extends from the ``'<'`` in ``'<html>'`` to the ``'>'`` in "
"``'</title>'``, which isn't what you want."
msgstr ""
"正規表現は ``'<html>'`` 内の ``'<'`` にマッチし、 ``.*`` は残りの文字列の全て"
"にマッチします。\n"
"しかし、正規表現には依然として残っている部分があって、 ``>`` は文字列の終端に"
"マッチしないので、正規表現エンジンは一文字ずつ ``>`` とマッチするまで引き返す"
"ことになります。\n"
"最終的にマッチする領域は ``'<html>'`` の ``'<'`` から ``'</title>'`` の "
"``'>'`` まで広がりますが、これは望んだ結果ではありません。"

#: ../../howto/regex.rst:1329
msgid ""
"In this case, the solution is to use the non-greedy qualifiers ``*?``, ``+?"
"``, ``??``, or ``{m,n}?``, which match as *little* text as possible.  In the "
"above example, the ``'>'`` is tried immediately after the first ``'<'`` "
"matches, and when it fails, the engine advances a character at a time, "
"retrying the ``'>'`` at every step.  This produces just the right result::"
msgstr ""
"この場合、解決法は非貪欲を示す修飾子 ``*?``, ``+?``, ``??`` または ``{m,n}?"
"`` を利用することです、これらはテキストに可能な限り *少なく* マッチします。上"
"の例では、 ``'>'`` は最初の ``'<'`` とのマッチ後すぐに ``'>'`` を試みま、失敗"
"した場合にはエンジンが文字を先に進め、``'>'`` が毎ステップ再試行されます。こ"
"の動作は正しい結果を生み出します::"

#: ../../howto/regex.rst:1338
msgid ""
"(Note that parsing HTML or XML with regular expressions is painful. Quick-"
"and-dirty patterns will handle common cases, but HTML and XML have special "
"cases that will break the obvious regular expression; by the time you've "
"written a regular expression that handles all of the possible cases, the "
"patterns will be *very* complicated.  Use an HTML or XML parser module for "
"such tasks.)"
msgstr ""
"(HTML や XML を正規表現でパースすることは苦痛を伴うものであることは記憶に留め"
"ておいて下さい。素早く、汚いパターンは大抵の場合うまく動作しますが、HTML と "
"XML は正規表現が破綻する特別な例です; 全ての可能な場合にうまく動作する正規表"
"現を書き上げたときには、パターンは *非常に* 複雑なものになります。そのような"
"作業をする場合には HTML や XML パーサを利用しましょう。)"

#: ../../howto/regex.rst:1346
msgid "Using re.VERBOSE"
msgstr "re.VERBOSE の利用"

#: ../../howto/regex.rst:1348
msgid ""
"By now you've probably noticed that regular expressions are a very compact "
"notation, but they're not terribly readable.  REs of moderate complexity can "
"become lengthy collections of backslashes, parentheses, and metacharacters, "
"making them difficult to read and understand."
msgstr ""
"ここまでで、正規表現がとても簡潔な表記であることに気づいたでしょう、また、正"
"規表現は読みやすいものでもないということにも気づいたことでしょう。そこそこに"
"入り組んだ正規表現ははバックスラッシュ、括弧、特殊文字が長く続いて、読みにく"
"く、理解しづらいものになります。"

#: ../../howto/regex.rst:1353
msgid ""
"For such REs, specifying the :const:`re.VERBOSE` flag when compiling the "
"regular expression can be helpful, because it allows you to format the "
"regular expression more clearly."
msgstr ""
"そのような正規表現に対しては、正規表現をコンパイルする時に :const:`re."
"VERBOSE` フラグを指定することが助けになります。なぜなら、より明確な書式で正規"
"表現を書けるからです。"

#: ../../howto/regex.rst:1357
msgid ""
"The ``re.VERBOSE`` flag has several effects.  Whitespace in the regular "
"expression that *isn't* inside a character class is ignored.  This means "
"that an expression such as ``dog | cat`` is equivalent to the less readable "
"``dog|cat``, but ``[a b]`` will still match the characters ``'a'``, ``'b'``, "
"or a space.  In addition, you can also put comments inside a RE; comments "
"extend from a ``#`` character to the next newline.  When used with triple-"
"quoted strings, this enables REs to be formatted more neatly::"
msgstr ""
"``re.VERBOSE`` の効果はいくつかあります。正規表現内の文字クラス内に *無い* 空"
"白は無視されます。これは、 ``dog | cat`` のような表現が少々可読性の落ちる "
"``dog|cat`` と等価となるということです、しかし、 ``[a b]`` は依然として "
"``'a'``, ``'b'``, または空白にマッチします。加えて、正規表現にコメントを入れ"
"ることもできるようになります; ``#`` 文字から次の改行までがコメントの範囲で"
"す。三重クォートを利用することで、正規表現をきちんとフォーマットすることがで"
"きます::"

#: ../../howto/regex.rst:1374
msgid "This is far more readable than::"
msgstr "これは下よりはるかに読みやすいです::"

#: ../../howto/regex.rst:1380
msgid "Feedback"
msgstr "フィードバック"

#: ../../howto/regex.rst:1382
msgid ""
"Regular expressions are a complicated topic.  Did this document help you "
"understand them?  Were there parts that were unclear, or Problems you "
"encountered that weren't covered here?  If so, please send suggestions for "
"improvements to the author."
msgstr ""
"正規表現は複雑な話題です。このドキュメントは助けになったでしょうか？わかりに"
"くかったところや、あなたが遭遇した問題が扱われていない等なかったでしょうか？"
"もしそんな問題があれば、著者に改善の提案を送って下さい。"

#: ../../howto/regex.rst:1387
msgid ""
"The most complete book on regular expressions is almost certainly Jeffrey "
"Friedl's Mastering Regular Expressions, published by O'Reilly.  "
"Unfortunately, it exclusively concentrates on Perl and Java's flavours of "
"regular expressions, and doesn't contain any Python material at all, so it "
"won't be useful as a reference for programming in Python.  (The first "
"edition covered Python's now-removed :mod:`!regex` module, which won't help "
"you much.)  Consider checking it out from your library."
msgstr ""
"O'Reilly から出版されている Jeffrey Friedl の Mastering Regular Expressions "
"は正規表現に関するほぼ完璧な書籍です (訳注　日本語訳「詳説　正規表現」が出版"
"されています) 。不幸なことに、この本は Perl と Java の正規表現を集中して扱っ"
"ていて、 Python の正規表現については全く扱っていません、そのため Python プロ"
"グラミングのためのレファレンスとして使うことはできません。 (第一版はいまや削"
"除された Python の :mod:`!regex` モジュールについて扱っていましたが、これはあ"
"まり役に立たないでしょう。) 図書館で調べるのを検討してみましょう。"
