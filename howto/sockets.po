# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-29 13:26+0900\n"
"PO-Revision-Date: 2018-06-29 17:46+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/sockets.rst:5
msgid "Socket Programming HOWTO"
msgstr "ã‚½ã‚±ãƒƒãƒˆãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° HOWTO"

#: ../../howto/sockets.rst:0
msgid "Author"
msgstr "è‘—è€…"

#: ../../howto/sockets.rst:7
msgid "Gordon McMillan"
msgstr "Gordon McMillan"

#: ../../howto/sockets.rstNone
msgid "Abstract"
msgstr "æ¦‚è¦"

#: ../../howto/sockets.rst:12
msgid ""
"Sockets are used nearly everywhere, but are one of the most severely "
"misunderstood technologies around. This is a 10,000 foot overview of "
"sockets. It's not really a tutorial - you'll still have work to do in "
"getting things operational. It doesn't cover the fine points (and there are "
"a lot of them), but I hope it will give you enough background to begin using"
" them decently."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã¯ãã“ã‹ã—ã“ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ãŒã€æœ€å¤§ç´šã«èª¤è§£ã•ã‚Œã¦ã„ã‚‹æŠ€è¡“ã§ã‚‚ã‚ã‚‹ã€‚ã“ã®æ–‡æ›¸ã¯ã‚½ã‚±ãƒƒãƒˆã®å…¨ä½“åƒã‚’ä¿¯ç°ã—ã¦ãŠã‚Šã€ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã¨ã—ã¦ã¯ã‚ã¾ã‚Šå½¹ã«ç«‹ãŸãªã„ã€‚å®Ÿéš›ã«å‹•ããƒ¢ãƒã‚’å®Œæˆã•ã›ã‚‹ã«ã¯ã€ä»–ã«ã‚‚ã‚„ã‚‰ãªã‘ã‚Œã°ã„ã‘ãªã„ã“ã¨ãŒã‚ã‚‹ã‹ã‚‰ã ã€‚ã“ã®æ–‡æ›¸ã¯ã‚½ã‚±ãƒƒãƒˆã®å¾®å¦™ãªã¨ã“ã‚"
" (ãŸãã•ã‚“ã‚ã‚‹) ã¾ã§ã¯ã‚«ãƒãƒ¼ã—ã¦ã„ãªã„ãŒã€æ¥ãšã‹ã—ããªã„ä½¿ã„æ–¹ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ç¨‹åº¦ã®æƒ…å ±ã¯å¾—ã‚‰ã‚Œã‚‹ã¯ãšã ã€‚"

#: ../../howto/sockets.rst:20
msgid "Sockets"
msgstr "ã‚½ã‚±ãƒƒãƒˆ"

#: ../../howto/sockets.rst:22
msgid ""
"I'm only going to talk about INET (i.e. IPv4) sockets, but they account for "
"at least 99% of the sockets in use. And I'll only talk about STREAM (i.e. "
"TCP) sockets - unless you really know what you're doing (in which case this "
"HOWTO isn't for you!), you'll get better behavior and performance from a "
"STREAM socket than anything else. I will try to clear up the mystery of what"
" a socket is, as well as some hints on how to work with blocking and non-"
"blocking sockets. But I'll start by talking about blocking sockets. You'll "
"need to know how they work before dealing with non-blocking sockets."
msgstr ""
"INET (ã™ãªã‚ã¡ IPv4) ã‚½ã‚±ãƒƒãƒˆã®ã“ã¨ã—ã‹èªã‚‰ãªã„ã¤ã‚‚ã‚Šã ãŒã€åˆ©ç”¨ç‡ã§ã„ã†ã¨ã‚½ã‚±ãƒƒãƒˆã® 99% ä»¥ä¸Šã¯ã“ã‚Œã ã€‚ã•ã‚‰ã«ä¸­ã§ã‚‚ STREAM "
"(ã™ãªã‚ã¡ TCP) ã‚½ã‚±ãƒƒãƒˆã«è©±é¡Œã‚’çµã‚ã†ã¨æ€ã† - è‡ªåˆ†ãŒä½•ã‚’ã—ã¦ã„ã‚‹ã®ã‹åˆ†ã‹ã£ã¦ã„ã‚‹ã®ã§ãªã„é™ã‚Š (åˆ†ã‹ã£ã¦ã‚‹ãªã‚‰ã“ã® HOWTO "
"ãªã‚“ã¦è¦ã‚‰ãªã„ã ã‚!)ã€STREAM "
"ã‚½ã‚±ãƒƒãƒˆãŒä¸€ç•ªåˆ†ã‹ã‚Šã‚„ã™ãã€ä¸€ç•ªæ€§èƒ½ãŒå‡ºã‚‹ã®ã ã€‚ãã†ã‚„ã£ã¦è¬ã«åŒ…ã¾ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã®æ­£ä½“ã‚’æ˜ã‚‰ã‹ã«ã—ã¦ã‚†ãã¨å…±ã«ã€ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãŠã‚ˆã³ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãªã‚½ã‚±ãƒƒãƒˆã®æ‰±ã„ã«é–¢ã™ã‚‹ã„ãã¤ã‹ã®ãƒ’ãƒ³ãƒˆã‚’æç¤ºã—ã‚ˆã†ã€‚ã ãŒã€ã¾ãšã¯ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰å§‹ã‚ã‚‹ã“ã¨ã«ã™ã‚‹ã€‚ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚’æ‰±ã†ã‚ˆã‚Šå…ˆã«ã€ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã®ä»•çµ„ã¿ã‚’çŸ¥ã£ã¦ãŠã‹ãªãã¦ã¯ãªã‚‰ãªã„ã®ã ã€‚"

#: ../../howto/sockets.rst:31
msgid ""
"Part of the trouble with understanding these things is that \"socket\" can "
"mean a number of subtly different things, depending on context. So first, "
"let's make a distinction between a \"client\" socket - an endpoint of a "
"conversation, and a \"server\" socket, which is more like a switchboard "
"operator. The client application (your browser, for example) uses \"client\""
" sockets exclusively; the web server it's talking to uses both \"server\" "
"sockets and \"client\" sockets."
msgstr ""
"è©±ã‚’ç†è§£ã—ã«ããã—ã¦ã„ã‚‹è¦å› ã¨ã—ã¦ã€ã€Œã‚½ã‚±ãƒƒãƒˆã€ã¨ã„ã†è¨€è‘‰ãŒæ–‡è„ˆã«ã‚ˆã£ã¦å¾®å¦™ã«é•ã†ã‚‚ã®ã‚’æŒ‡ã™ã“ã¨ãŒæŒ™ã’ã‚‰ã‚Œã‚‹ã€‚ãã“ã§ã¾ãšã€ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã€ã‚½ã‚±ãƒƒãƒˆ - "
"å¯¾è©±ã®ä¸¡ç«¯ - ã¨ã€Œã‚µãƒ¼ãƒã€ã‚½ã‚±ãƒƒãƒˆ - é›»è©±äº¤æ›æ‰‹ã¿ãŸã„ãªã‚‚ã® - ã®åŒºåˆ¥ã‚’ä»˜ã‘ã¦ãŠã“ã†ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ (ãŸã¨ãˆã°ãƒ–ãƒ©ã‚¦ã‚¶) "
"ã¯ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã€ã‚½ã‚±ãƒƒãƒˆã ã‘ã‚’ä½¿ã†ãŒã€è©±ã—ç›¸æ‰‹ã®ã‚¦ã‚§ãƒ–ã‚µãƒ¼ãƒã¯ã€Œã‚µãƒ¼ãƒã€ã‚½ã‚±ãƒƒãƒˆã¨ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã€ã‚½ã‚±ãƒƒãƒˆã®ä¸¡æ–¹ã‚’ä½¿ã†ã€‚"

#: ../../howto/sockets.rst:40
msgid "History"
msgstr "æ­´å²"

#: ../../howto/sockets.rst:42
msgid ""
"Of the various forms of :abbr:`IPC (Inter Process Communication)`, sockets "
"are by far the most popular.  On any given platform, there are likely to be "
"other forms of IPC that are faster, but for cross-platform communication, "
"sockets are about the only game in town."
msgstr ""
"å„ç¨® :abbr:`IPC (Inter Process Communication` (ãƒ—ãƒ­ã‚»ã‚¹é–“é€šä¿¡) "
"ã®ä¸­ã§ã‚‚ã€ã‚½ã‚±ãƒƒãƒˆã¯ç¾¤ã‚’æŠœã„ã¦äººæ°—ãŒã‚ã‚‹ã€‚ã©ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ã‚‚ã€ã‚½ã‚±ãƒƒãƒˆã‚ˆã‚Šé€Ÿã„ IPC "
"ã¯ã‚ã‚‹ã ã‚ã†ã€‚ã ãŒã€ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚’ã¾ãŸãé€šä¿¡ã¯ã‚½ã‚±ãƒƒãƒˆã®ç‹¬æ“…å ´ã ã€‚"

#: ../../howto/sockets.rst:47
msgid ""
"They were invented in Berkeley as part of the BSD flavor of Unix. They "
"spread like wildfire with the Internet. With good reason --- the combination"
" of sockets with INET makes talking to arbitrary machines around the world "
"unbelievably easy (at least compared to other schemes)."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã¯ BSD Unix ã®ä¸€éƒ¨ã¨ã—ã¦ãƒãƒ¼ã‚¯ãƒ¬ã‚¤ã§ç™ºæ˜ã•ã‚Œã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã®æ™®åŠã¨å…±ã«é‡ç«ã®ã”ã¨ãåºƒã¾ã£ãŸã€‚ãã‚Œã‚‚ã‚‚ã£ã¨ã‚‚ãªã“ã¨ã§ã€ã‚½ã‚±ãƒƒãƒˆã¨ "
"INET ã®ã‚³ãƒ³ãƒ“ã«ã‚ˆã£ã¦ä¸–ç•Œä¸­ã©ã‚“ãªãƒã‚·ãƒ³ã¨ã‚‚ã€ä¿¡ã˜ã‚‰ã‚Œãªã„ã»ã©ç°¡å˜ (å°‘ãªãã¨ã‚‚ä»–ã®ã‚¹ã‚­ãƒ¼ãƒ ã¨æ¯”ã¹ã¦) ã«é€šä¿¡ã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã®ã ã€‚"

#: ../../howto/sockets.rst:54
msgid "Creating a Socket"
msgstr "ã‚½ã‚±ãƒƒãƒˆã®ä½œæˆ"

#: ../../howto/sockets.rst:56
msgid ""
"Roughly speaking, when you clicked on the link that brought you to this "
"page, your browser did something like the following::"
msgstr "ã‚ãªãŸãŒãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã“ã®ãƒšãƒ¼ã‚¸ã«æ¥ãŸã¨ãã€ãƒ–ãƒ©ã‚¦ã‚¶ã¯å¤§é›‘æŠŠã«è¨€ã£ã¦æ¬¡ã®ã‚ˆã†ãªã“ã¨ã‚’ã—ãŸã®ã§ã‚ã‚‹::"

#: ../../howto/sockets.rst:64
msgid ""
"When the ``connect`` completes, the socket ``s`` can be used to send in a "
"request for the text of the page. The same socket will read the reply, and "
"then be destroyed. That's right, destroyed. Client sockets are normally only"
" used for one exchange (or a small set of sequential exchanges)."
msgstr ""
"ã“ã® ``connect`` ãŒå®Œäº†ã™ã‚‹ã¨ã€ã‚½ã‚±ãƒƒãƒˆ ``s`` "
"ã‚’ä½¿ã£ã¦ã“ã®ãƒšãƒ¼ã‚¸æ–‡ç« ã¸ã®è¦æ±‚ã‚’é€ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚ãã®åŒã˜ã‚½ã‚±ãƒƒãƒˆãŒè¿”ç­”ã‚’èª­ã¿ã€ãã—ã¦ç ´å£Šã•ã‚Œã‚‹ã€‚ãã†ã€ç ´å£Šã•ã‚Œã‚‹ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚½ã‚±ãƒƒãƒˆã¯é€šå¸¸ã€ä¸€å›"
" (ã‹å°‘æ•°ã®) ã‚„ã‚Šå–ã‚Šã§ä½¿ã„æ¨ã¦ã«ãªã‚‹ã®ã ã€‚"

#: ../../howto/sockets.rst:70
msgid ""
"What happens in the web server is a bit more complex. First, the web server "
"creates a \"server socket\"::"
msgstr "ã‚¦ã‚§ãƒ–ã‚µãƒ¼ãƒã§èµ·ã“ã‚‹äº‹æŸ„ã¯ã‚‚ã†å°‘ã—è¤‡é›‘ã ã€‚ã¾ãšã€Œã‚µãƒ¼ãƒã‚½ã‚±ãƒƒãƒˆã€ã‚’ä½œã‚‹::"

#: ../../howto/sockets.rst:80
msgid ""
"A couple things to notice: we used ``socket.gethostname()`` so that the "
"socket would be visible to the outside world.  If we had used "
"``s.bind(('localhost', 80))`` or ``s.bind(('127.0.0.1', 80))`` we would "
"still have a \"server\" socket, but one that was only visible within the "
"same machine.  ``s.bind(('', 80))`` specifies that the socket is reachable "
"by any address the machine happens to have."
msgstr ""
"ã“ã“ã§æ³¨æ„ã™ã¹ãç‚¹ãŒã„ãã¤ã‹ã‚ã‚‹: ä»Šå›ã¯ã‚½ã‚±ãƒƒãƒˆãŒå¤–ç•Œã«è¦‹ãˆã‚‹ã‚ˆã†ã€ ``socket.gethostname()`` ã‚’ä½¿ã£ãŸã€‚ "
"``s.bind(('localhost', 80))`` ã‚„  ``s.bind(('127.0.0.1', 80))`` "
"ã§ã‚‚ã€Œã‚µãƒ¼ãƒã€ã‚½ã‚±ãƒƒãƒˆã«ã¯ãªã‚‹ãŒã€ãã‚Œã ã¨åŒã˜ãƒã‚·ãƒ³å†…ã«ã—ã‹è¦‹ãˆãªã„ã‚‚ã®ã«ãªã£ã¦ã—ã¾ã†ã€‚ ``s.bind(('', 80))`` "
"ã¯ã“ã®ãƒã‚·ãƒ³ãŒæŒã£ã¦ã„ã‚‹å…¨ã¦ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§æ¥ç¶šå¯èƒ½ã«ãªã‚‹ã‚ˆã†ã«ã¨ã„ã†æŒ‡å®šã«ãªã‚‹ã€‚"

#: ../../howto/sockets.rst:87
msgid ""
"A second thing to note: low number ports are usually reserved for \"well "
"known\" services (HTTP, SNMP etc). If you're playing around, use a nice high"
" number (4 digits)."
msgstr ""
"ãµãŸã¤ã‚: å°ã•ãªç•ªå·ã®ãƒãƒ¼ãƒˆã¯å¤§æŠµã€ã€Œã‚¦ã‚§ãƒ«ãƒã‚¦ãƒ³ (æœ‰å)ã€ãªã‚µãƒ¼ãƒ“ã‚¹ (HTTP, SNMP ç­‰ã€…) "
"ã®ãŸã‚ã«å–ã£ã¦ã‚ã‚‹ã€‚ãŠéŠã³ã§ä½¿ã†ã®ãªã‚‰é©å½“ã«å¤§ããªæ•° (4æ¡) ã‚’ä½¿ãŠã†ã€‚"

#: ../../howto/sockets.rst:91
msgid ""
"Finally, the argument to ``listen`` tells the socket library that we want it"
" to queue up as many as 5 connect requests (the normal max) before refusing "
"outside connections. If the rest of the code is written properly, that "
"should be plenty."
msgstr ""
"æœ€å¾Œã«: ``listen`` ã®å¼•æ•°ã¯ã‚½ã‚±ãƒƒãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã€æ¥ç¶šè¦æ±‚ã‚’ 5 å€‹ (é€šå¸¸ã®æœ€å¤§å€¤) "
"ã¾ã§é †ç•ªå¾…ã¡ã•ã›ã‚‹ã‚ˆã†ã«å‘½ã˜ã¦ã„ã‚‹ã€‚ã“ã‚Œä»¥é™ã®å¤–éƒ¨æ¥ç¶šã¯æ‹’å¦ã™ã‚‹ã®ã ãŒã€ã‚³ãƒ¼ãƒ‰ãŒé©åˆ‡ã«æ›¸ã‹ã‚Œã¦ã„ã‚Œã°ã€ãã‚Œã§ååˆ†ã™ãã‚‹ã»ã©ã ã€‚"

#: ../../howto/sockets.rst:95
msgid ""
"Now that we have a \"server\" socket, listening on port 80, we can enter the"
" mainloop of the web server::"
msgstr "ã‚ˆã—ã€ã€Œã‚µãƒ¼ãƒãƒ¼ã‚½ã‚±ãƒƒãƒˆã€ãŒã§ãã¦ã€80 ç•ªãƒãƒ¼ãƒˆã§è€³ã‚’æ¾„ã¾ã—ã¦ã„ã‚‹ã¨ã“ã‚ã¾ã§æ¥ãŸã€‚ã§ã¯ã€ã‚¦ã‚§ãƒ–ã‚µãƒ¼ãƒã®ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ã«å…¥ã‚ã†::"

#: ../../howto/sockets.rst:106
msgid ""
"There's actually 3 general ways in which this loop could work - dispatching "
"a thread to handle ``clientsocket``, create a new process to handle "
"``clientsocket``, or restructure this app to use non-blocking sockets, and "
"multiplex between our \"server\" socket and any active ``clientsocket``\\ s "
"using ``select``. More about that later. The important thing to understand "
"now is this: this is *all* a \"server\" socket does. It doesn't send any "
"data. It doesn't receive any data. It just produces \"client\" sockets. Each"
" ``clientsocket`` is created in response to some *other* \"client\" socket "
"doing a ``connect()`` to the host and port we're bound to. As soon as we've "
"created that ``clientsocket``, we go back to listening for more connections."
" The two \"clients\" are free to chat it up - they are using some "
"dynamically allocated port which will be recycled when the conversation "
"ends."
msgstr ""
"ã“ã®ãƒ«ãƒ¼ãƒ—ã«ã¯å®Ÿéš›ã®ã¨ã“ã‚ã€3 é€šã‚Šã®ä¸€èˆ¬çš„ãªå‹•ä½œæ–¹æ³•ãŒã‚ã‚‹ - ``clientsocket`` "
"ã‚’æ‰±ã†ã‚ˆã†ã«ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’å‰²ã‚Šå½“ã¦ãŸã‚Šã€``clientsocket`` "
"ã‚’æ‰±ã†æ–°ã—ã„ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œã£ãŸã‚Šã€ã‚ã‚‹ã„ã¯ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚½ã‚±ãƒƒãƒˆã‚’ä½¿ã†ã‚ˆã†ã«ã‚¢ãƒ—ãƒªã‚’ä½œã‚Šç›´ã—ã¦ ``select`` ã§ã€Œã‚µãƒ¼ãƒã€ã‚½ã‚±ãƒƒãƒˆã¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãª"
" ``clientsocket`` ã®é–“ã‚’å¤šé‡åŒ–ã—ãŸã‚Šã™ã‚‹ã®ã ã€‚æœ€å¾Œã®ã«ã¤ã„ã¦ã¯ã¾ãŸå¾Œã«ã—ã‚ˆã†ã€‚ã“ã“ã§ç†è§£ã—ã¦ãŠãã¹ãè¦ç‚¹ã¯ã“ã‚Œã : "
"ä»¥ä¸ŠãŒã€Œã‚µãƒ¼ãƒã€ã‚½ã‚±ãƒƒãƒˆã®ä»•äº‹ã® *ã™ã¹ã¦* "
"ã§ã‚ã‚‹ã€‚ãƒ‡ãƒ¼ã‚¿ã¯ä¸€åˆ‡é€ä¿¡ã—ãªã„ã—ã€å—ä¿¡ã—ãªã„ã€‚ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã€ã‚½ã‚±ãƒƒãƒˆã‚’ç”Ÿã¿å‡ºã™ã ã‘ã€‚æˆ‘ã€…ã®ãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã¦ã„ã‚‹ãƒ›ã‚¹ãƒˆã¨ãƒãƒ¼ãƒˆã« "
"``connect()`` ã—ã¦ãã‚‹ *ä»–ã®* ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã€ã‚½ã‚±ãƒƒãƒˆã«å¿œãˆã‚‹å½¢ã§ ``clientsocket`` "
"ã‚’ä½œã‚Šã€ä½œã‚‹ã‚„å¦ã‚„ã€ã•ã‚‰ãªã‚‹æ¥ç¶šã‚’èãã«æˆ»ã£ã¦ã„ãã®ã ã€‚ã“ã®ãµãŸã¤ã®ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã€ã¯ã€ã‚ã¨ã¯å‹æ‰‹ã«å–‹ã£ã¦ã„ã‚Œã°ã„ã„ - "
"ä½¿ã†ãƒãƒ¼ãƒˆã¯å‹•çš„ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã€ä¼šè©±ãŒçµ‚ã‚ã‚Œã°ãƒªã‚µã‚¤ã‚¯ãƒ«ã«å»»ã•ã‚Œã‚‹ã€‚"

#: ../../howto/sockets.rst:121
msgid "IPC"
msgstr "IPC"

#: ../../howto/sockets.rst:123
msgid ""
"If you need fast IPC between two processes on one machine, you should look "
"into pipes or shared memory.  If you do decide to use AF_INET sockets, bind "
"the \"server\" socket to ``'localhost'``. On most platforms, this will take "
"a shortcut around a couple of layers of network code and be quite a bit "
"faster."
msgstr ""
"1ã¤ã®ãƒã‚·ãƒ³ä¸Šã®2ãƒ—ãƒ­ã‚»ã‚¹é–“ã§é«˜é€ŸãªIPCã‚’è¡Œã„ãŸã„å ´åˆã¯ã€pipe ã‹å…±æœ‰ãƒ¡ãƒ¢ãƒªã‚’æ¤œè¨ã™ã‚‹ã¹ãã§ã™ã€‚AF_INET "
"ã‚½ã‚±ãƒƒãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã¨æ±ºã‚ãŸå ´åˆã€ã€Œã‚µãƒ¼ãƒãƒ¼ã€ã‚½ã‚±ãƒƒãƒˆã¯ ``'localhost'`` "
"ã«ãƒã‚¤ãƒ³ãƒ‰ã—ã¾ã—ã‚‡ã†ã€‚ã»ã¨ã‚“ã©ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã€ã„ãã¤ã‹ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã™ã‚‹ã“ã¨ã§ã‹ãªã‚Šé«˜é€Ÿã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/sockets.rst:129
msgid ""
"The :mod:`multiprocessing` integrates cross-platform IPC into a higher-level"
" API."
msgstr ":mod:`multiprocessing` ã¯ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãªIPCã®é«˜ç´šãªAPIã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚"

#: ../../howto/sockets.rst:134
msgid "Using a Socket"
msgstr "ã‚½ã‚±ãƒƒãƒˆã®åˆ©ç”¨"

#: ../../howto/sockets.rst:136
msgid ""
"The first thing to note, is that the web browser's \"client\" socket and the"
" web server's \"client\" socket are identical beasts. That is, this is a "
"\"peer to peer\" conversation. Or to put it another way, *as the designer, "
"you will have to decide what the rules of etiquette are for a conversation*."
" Normally, the ``connect``\\ ing socket starts the conversation, by sending "
"in a request, or perhaps a signon. But that's a design decision - it's not a"
" rule of sockets."
msgstr ""
"ã¯ã˜ã‚ã«æ†¶ãˆã¦ãŠãã¹ããªã®ã¯ã€ã‚¦ã‚§ãƒ–ãƒ–ãƒ©ã‚¦ã‚¶ã®ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã€ã‚½ã‚±ãƒƒãƒˆã¨ã‚¦ã‚§ãƒ–ã‚µãƒ¼ãƒã®ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã€ã‚½ã‚±ãƒƒãƒˆãŒã¾ã£ãŸãåŒã˜ç¨®æ—ã ã¨ã„ã†ã“ã¨ã ã€‚ã¤ã¾ã‚Šã€ã“ã‚Œã¯ã€Œãƒ”ã‚¢ãƒ»ãƒˆã‚¥ãƒ»ãƒ”ã‚¢ã€(1"
" å¯¾ 1) ã®ä¼šè©±ã§ã‚ã‚‹ã€‚åˆ¥ã®è¨€ã„æ–¹ã‚’ã™ã‚‹ã¨ã€ *è¨­è¨ˆè€…ã¨ã—ã¦è‡ªåˆ†ã§ä¼šè©±ã®ã‚¨ãƒã‚±ãƒƒãƒˆè¦å‰‡ã‚’æ±ºã‚ãªãã¦ã¯ã„ã‘ãªã„* ã¨ã„ã†ã“ã¨ã§ã‚‚ã‚ã‚‹ã€‚é€šå¸¸ã¯ã€ "
"``connect`` ã—ã¦ãã‚‹ã‚½ã‚±ãƒƒãƒˆãŒè¦æ±‚ã‚ã‚‹ã„ã¯å®£è¨€ã‚’ã—ã¦ä¼šè©±ã‚’å§‹ã‚ã‚‹ã€‚ã ãŒã€ãã‚Œã¯ãã†è¨­è¨ˆã—ãŸã ã‘ã®ã“ã¨ã  - ã‚½ã‚±ãƒƒãƒˆã®è¦å‰‡ã§ã¯ãªã„ã€‚"

#: ../../howto/sockets.rst:143
msgid ""
"Now there are two sets of verbs to use for communication. You can use "
"``send`` and ``recv``, or you can transform your client socket into a file-"
"like beast and use ``read`` and ``write``. The latter is the way Java "
"presents its sockets. I'm not going to talk about it here, except to warn "
"you that you need to use ``flush`` on sockets. These are buffered \"files\","
" and a common mistake is to ``write`` something, and then ``read`` for a "
"reply. Without a ``flush`` in there, you may wait forever for the reply, "
"because the request may still be in your output buffer."
msgstr ""
"ã•ã¦ã€ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ä½¿ã†å‹•è©ã¯äºŒçµ„ã‚ã‚‹ã€‚ ``send`` ã¨ ``recv`` "
"ã‚’ä½¿ã†ã“ã¨ã‚‚ã§ãã‚‹ã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚½ã‚±ãƒƒãƒˆã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã£ã½ã„ç¨®æ—ã«å¤‰å½¢ã—ã¦ ``read`` ã¨ ``write`` ã‚’ä½¿ã£ã¦ã‚‚è‰¯ã„ã€‚å¾Œè€…ã¯ Java "
"ã®ã‚½ã‚±ãƒƒãƒˆã®è¡¨ç¾æ–¹æ³•ã ã€‚ã“ã“ã§è©³ã—ãèªã‚‹ã¤ã‚‚ã‚Šã¯ãªã„ãŒã€ãã®å ´åˆã¯ã‚½ã‚±ãƒƒãƒˆã‚‚ ``flush`` "
"ã—ãªã‘ã‚Œã°ã„ã‘ãªã„ã€ã¨ã ã‘è¨€ã£ã¦ãŠãã€‚ã“ã‚Œã¯ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã—ãŸã€Œãƒ•ã‚¡ã‚¤ãƒ«ã€ãªã®ã§ã€ä½•ã‹ã‚’ ``write`` ã—ã¦ã™ãã«è¿”ç­”ã‚’ ``read`` "
"ã™ã‚‹ã¨ã„ã†ã®ã¯ã‚ˆãã‚ã‚‹é–“é•ã„ã ã€‚é–“ã« ``flush`` ã‚’å…¥ã‚Œãªã„ã¨ã€è¦æ±‚ãŒã¾ã å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡ã«ã‚ã£ã¦æ°¸é ã«è¿”äº‹ãŒæ¥ãªã„ã€ã¨ã„ã†å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚"

#: ../../howto/sockets.rst:152
msgid ""
"Now we come to the major stumbling block of sockets - ``send`` and ``recv`` "
"operate on the network buffers. They do not necessarily handle all the bytes"
" you hand them (or expect from them), because their major focus is handling "
"the network buffers. In general, they return when the associated network "
"buffers have been filled (``send``) or emptied (``recv``). They then tell "
"you how many bytes they handled. It is *your* responsibility to call them "
"again until your message has been completely dealt with."
msgstr ""
"ã•ã‚ã€ã‚½ã‚±ãƒƒãƒˆã®ä¸»è¦ãªé›£é–¢ã«é€²ã‚‚ã† -  ``send`` ã¨ ``recv`` ã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒãƒƒãƒ•ã‚¡ã«åƒãã‹ã‘ã‚‹ã‚‚ã®ã ã€‚ã ã‹ã‚‰ã€æ‰‹æ¸¡ã—ãŸã‚‚ã® "
"(ã‚„è¿”ã—ã¦ã‚‚ã‚‰ã„ãŸã„ã‚‚ã®) ã‚’ 1 ãƒã‚¤ãƒˆã‚‚æ®‹ã•ãšå®Ÿéš›ã«å‡¦ç†ã—ã¦ãã‚Œã¦ã„ã‚‹ã¨ã¯é™ã‚‰ãªã„ã€‚ä¸€èˆ¬çš„ã«è¨€ã£ã¦ã€ ``send`` "
"ã¯ãƒãƒƒãƒ•ã‚¡ãŒåŸ‹ã¾ã‚‹ã¾ã§ã€``recv`` ã¯ãƒãƒƒãƒ•ã‚¡ãŒç©ºã«ãªã‚‹ã¾ã§å‡¦ç†ã‚’ã—ã¦ã€ãã®ãƒã‚¤ãƒˆæ•°ã‚’è¿”ã™ã€‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå®Œå…¨ã«å‡¦ç†ã•ã‚Œã‚‹ã¾ã§ç¹°ã‚Šè¿”ã—å‘¼ã³å‡ºã™ã®ã¯ "
"*è‡ªåˆ†ã®* è²¬ä»»ãªã®ã ã€‚"

#: ../../howto/sockets.rst:160
msgid ""
"When a ``recv`` returns 0 bytes, it means the other side has closed (or is "
"in the process of closing) the connection.  You will not receive any more "
"data on this connection. Ever.  You may be able to send data successfully; "
"I'll talk more about this later."
msgstr ""
"``recv`` ãŒ 0 ãƒã‚¤ãƒˆã‚’è¿”ã—ãŸã¨ãã¯ã€å‘ã“ã†å´ãŒæ¥ç¶šã‚’é–‰ã˜ã¦ã—ã¾ã£ãŸ (ã¾ãŸã¯é–‰ã˜ã‚ˆã†ã¨ã—ã¦ã„ã‚‹é€”ä¸­) "
"ã¨ã„ã†æ„å‘³ã ã€‚ã‚‚ã†ã“ã®æ¥ç¶šã§ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚‹ã“ã¨ã¯ãªã„ã€‚æ°¸é ã«ã ã€‚ãŸã ã€ãƒ‡ãƒ¼ã‚¿é€ä¿¡ã¯æˆåŠŸã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„; ã“ã‚Œã«ã¤ã„ã¦ã¯ã‚ã¨ã§èªã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚"

#: ../../howto/sockets.rst:165
msgid ""
"A protocol like HTTP uses a socket for only one transfer. The client sends a"
" request, then reads a reply.  That's it. The socket is discarded. This "
"means that a client can detect the end of the reply by receiving 0 bytes."
msgstr ""
"HTTP "
"ã®ã‚ˆã†ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã¯ã€ã²ã¨ã¤ã®ã‚½ã‚±ãƒƒãƒˆã‚’1å›ã®è»¢é€ã«ã—ã‹ä½¿ã‚ãªã„ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯è¦æ±‚ã‚’é€ã‚Šã€è¿”ç­”ã‚’å—ã‘ã‚‹ã€‚ä»¥ä¸Šã ã€‚ã“ã‚Œã§ã‚½ã‚±ãƒƒãƒˆã¯ç ´æ£„ã•ã‚Œã‚‹ã€‚ã ã‹ã‚‰ã“ã®å ´åˆã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯å—ä¿¡"
" 0 ãƒã‚¤ãƒˆã®æ™‚ç‚¹ã§è¿”ç­”ã®æœ«å°¾ã‚’æ¤œå‡ºã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚"

#: ../../howto/sockets.rst:169
msgid ""
"But if you plan to reuse your socket for further transfers, you need to "
"realize that *there is no* :abbr:`EOT (End of Transfer)` *on a socket.* I "
"repeat: if a socket ``send`` or ``recv`` returns after handling 0 bytes, the"
" connection has been broken.  If the connection has *not* been broken, you "
"may wait on a ``recv`` forever, because the socket will *not* tell you that "
"there's nothing more to read (for now).  Now if you think about that a bit, "
"you'll come to realize a fundamental truth of sockets: *messages must either"
" be fixed length* (yuck), *or be delimited* (shrug), *or indicate how long "
"they are* (much better), *or end by shutting down the connection*. The "
"choice is entirely yours, (but some ways are righter than others)."
msgstr ""
"ã ãŒã€ä»¥é™ã®è»¢é€ã«ã‚‚ãã®ã‚½ã‚±ãƒƒãƒˆã‚’ä½¿ã„å›ã™ã¤ã‚‚ã‚Šãªã‚‰ã€ã‚½ã‚±ãƒƒãƒˆã« :abbr:`EOT (End of Transfer)` ãªã© *å­˜åœ¨ã—ãªã„* "
"ã“ã¨ã‚’èªè­˜ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚ã‚‚ã†ä¸€åº¦è¨€ãŠã†: ã‚½ã‚±ãƒƒãƒˆã® ``send`` ã‚„ ``recv`` ãŒ 0 "
"ãƒã‚¤ãƒˆå‡¦ç†ã§è¿”ã£ã¦ããŸãªã‚‰ã€ãã®æ¥ç¶šã¯çµ‚ã‚ã£ã¦ã„ã‚‹ã€‚çµ‚ã‚ã£ã¦ *ã„ãªã„* ãªã‚‰ã€ã„ã¤ã¾ã§ ``recv`` "
"ã‚’å¾…ã¦ã°ã„ã„ã‹ã¯åˆ†ã‹ã‚‰ãªã„ã€‚ã‚½ã‚±ãƒƒãƒˆã¯ã€Œã‚‚ã†èª­ã‚€ã‚‚ã®ãŒ (ä»Šã®ã¨ã“ã‚) ãªã„ãœã€ãªã©ã¨ *è¨€ã‚ãªã„* "
"ã®ã ã‹ã‚‰ã€‚ã“ã®ã“ã¨ã‚’å°‘ã—è€ƒãˆã‚Œã°ã€ã‚½ã‚±ãƒƒãƒˆã®çœŸå®Ÿã‚’æ‚Ÿã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†: *ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯å¿…ãšå›ºå®šé•·ã‹* (ã†ã’ã‡) *åŒºåˆ‡ã‚Šæ–‡å­—ã‚’ä½¿ã†ã‹* (ã‚„ã‚Œã‚„ã‚Œ)"
" *é•·ã•æ¨™è­˜ã‚’ä»˜ã‘ã¦ãŠãã‹* (ã‹ãªã‚Šãƒã‚·) *æ¥ç¶šã‚’é–‰ã˜ã¦çµ‚ã‚ã‚‰ã›ã‚‹ã‹ã®ã„ãšã‚Œã‹ã§ãªã‘ã‚Œã°ã„ã‘ãªã„* ã®ã ã€‚é¸ã¶æ¨©åˆ©ã¨è²¬ä»»ã¯ã¾ã£ãŸãã‚‚ã£ã¦è‡ªåˆ†ã«ã‚ã‚‹ "
"(ãŒã€æ­£ã—ã•ã®ç¨‹åº¦ã«é•ã„ã¯ã‚ã‚‹)ã€‚"

#: ../../howto/sockets.rst:180
msgid ""
"Assuming you don't want to end the connection, the simplest solution is a "
"fixed length message::"
msgstr "æ¯å›æ¥ç¶šã‚’çµ‚ã‚ã‚‰ã›ã‚‹ã®ã¯ã‚¤ãƒ¤ã ã¨ã—ã¦ã€æœ€ã‚‚å˜ç´”ãªè§£æ±ºç­–ã¯å›ºå®šé•·ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã ã‚ã†::"

#: ../../howto/sockets.rst:217
msgid ""
"The sending code here is usable for almost any messaging scheme - in Python "
"you send strings, and you can use ``len()`` to determine its length (even if"
" it has embedded ``\\0`` characters). It's mostly the receiving code that "
"gets more complex. (And in C, it's not much worse, except you can't use "
"``strlen`` if the message has embedded ``\\0``\\ s.)"
msgstr ""
"ã“ã®é€ä¿¡ã‚³ãƒ¼ãƒ‰ã¯ã€ã»ã¼ã‚ã‚‰ã‚†ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€šä¿¡ã‚¹ã‚­ãƒ¼ãƒ ã§ä½¿ãˆã‚‹ - æ–‡å­—åˆ—ã‚’é€ã‚‹ã¨ãã€Python ãªã‚‰é•·ã•ã‚’ ``len()`` ã§è¦‹æ¥µã‚ã‚‹ã“ã¨ãŒã§ãã‚‹"
" (ä¸­ã« ``\\0`` ãŒåŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã¦ã‚‚å¤§ä¸ˆå¤«)ã€‚é›£ã—ãã—ã¦ã„ã‚‹ã®ã¯ã€ãŠã‚‚ã«å—ä¿¡ã‚³ãƒ¼ãƒ‰ã§ã‚ã‚‹ã€‚ (ãªãŠã€C "
"ã§ã‚‚äº‹æ…‹ã¯ã‚ã¾ã‚Šæ‚ªããªã‚‰ãªã„ãŒã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã« ``\\0`` ãŒåŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã‚‹ã¨ ``strlen`` ãŒä½¿ãˆãªã„ã®ã¯é¢å€’ã ã€‚)"

#: ../../howto/sockets.rst:223
msgid ""
"The easiest enhancement is to make the first character of the message an "
"indicator of message type, and have the type determine the length. Now you "
"have two ``recv``\\ s - the first to get (at least) that first character so "
"you can look up the length, and the second in a loop to get the rest. If you"
" decide to go the delimited route, you'll be receiving in some arbitrary "
"chunk size, (4096 or 8192 is frequently a good match for network buffer "
"sizes), and scanning what you've received for a delimiter."
msgstr ""
"æœ€ã‚‚ç°¡å˜ãªæ”¹è‰¯æ³•ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æœ€åˆã®ä¸€æ–‡å­—ã‚’ã‚¿ã‚¤ãƒ—æ¨™è­˜ã«ã—ã¦ã€ãã®ã‚¿ã‚¤ãƒ—ã§é•·ã•ã‚’æ±ºå®šã™ã‚‹ã¨ã„ã†ã‚‚ã®ã ã€‚ã“ã®å ´åˆãµãŸã¤ã® ``recv`` "
"ãŒã‚ã‚‹ã“ã¨ã«ãªã‚‹ - ä¸€ç•ªç›®ã§ãã®ä¸€æ–‡å­— (ã ã‘ã˜ã‚ƒãªãã¦ã‚‚å¯) "
"ã‚’å–ã£ã¦é•·ã•ã‚’èª¿ã¹ã€äºŒç•ªç›®ã§ãƒ«ãƒ¼ãƒ—ã—ã¦æ®‹ã‚Šã‚’å–ã‚‹ã®ã ã€‚ã‚ã‚‹ã„ã¯ã‚‚ã—åŒºåˆ‡ã‚Šæ–¹å¼ã®é“ã‚’è¡Œãã®ã§ã‚ã‚Œã°ã€ä»»æ„ã®ã‚µã‚¤ã‚º (4096 ã‹ 8192 "
"ãŒãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒãƒƒãƒ•ã‚¡ã«ã¯æœ€é©ãªã“ã¨ãŒå¤šã„) ã§å—ä¿¡ã—ã¦åŒºåˆ‡ã‚Šæ–‡å­—ã‚’èµ°æŸ»ã—ã¦ã„ãã“ã¨ã«ãªã‚‹ã€‚"

#: ../../howto/sockets.rst:231
msgid ""
"One complication to be aware of: if your conversational protocol allows "
"multiple messages to be sent back to back (without some kind of reply), and "
"you pass ``recv`` an arbitrary chunk size, you may end up reading the start "
"of a following message. You'll need to put that aside and hold onto it, "
"until it's needed."
msgstr ""
"å¿ƒã«ç•™ã‚ã¦ãŠãã¹ãé¢å€’ãªç‚¹ãŒã²ã¨ã¤: è¤‡æ•°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ¬¡ã€…ã« (ä½•ã‚‰ã‹ã®è¿”äº‹ã‚’å¾…ãŸãšã«) è¿”ã£ã¦ãã‚‹ã“ã¨ã®ã‚ã‚‹ä¼šè©±ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãªã‚‰ã€ãã—ã¦ä»»æ„ã®ã‚µã‚¤ã‚ºã‚’ "
"``recv`` "
"ã«æ¸¡ã—ã¦ã„ã‚‹ãªã‚‰ã€æ¬¡ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å†’é ­éƒ¨åˆ†ã¾ã§èª­ã‚“ã§ã—ã¾ã†ã“ã¨ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚ãã®ã¨ãã¯ã€å¿…è¦ã«ãªã‚‹ã¾ã§è„‡ã«ã‚ˆã‘ã¦ã€å¤§åˆ‡ã«ä¿ç®¡ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚‹ã€‚"

#: ../../howto/sockets.rst:237
msgid ""
"Prefixing the message with its length (say, as 5 numeric characters) gets "
"more complex, because (believe it or not), you may not get all 5 characters "
"in one ``recv``. In playing around, you'll get away with it; but in high "
"network loads, your code will very quickly break unless you use two ``recv``"
" loops - the first to determine the length, the second to get the data part "
"of the message. Nasty. This is also when you'll discover that ``send`` does "
"not always manage to get rid of everything in one pass. And despite having "
"read this, you will eventually get bit by it!"
msgstr ""
"ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†’é ­ã«é•·ã•ã‚’ (ãŸã¨ãˆã° 5 æ¡ã®æ•°å­—ã§) ä»˜ã‘ã‚‹ã®ã¯ã€ãã‚Œã‚ˆã‚Šã‚‚ã•ã‚‰ã«è¤‡é›‘ã«ãªã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€(ä¿¡ã˜ã‚‰ã‚Œãªã„ã‹ã‚‚ã—ã‚Œãªã„ãŒ) ä¸€å›ã® "
"``recv`` ã§ 5 "
"æ–‡å­—ã‚’å…¨éƒ¨å—ã‘å–ã‚‹ã“ã¨ãŒã§ãã‚‹ã¨ã¯é™ã‚‰ãªã„ã‹ã‚‰ã ã€‚ãŠéŠã³ã§ã‚„ã£ã¦ã„ã‚‹é–“ã¯ã”ã¾ã‹ã›ã¦ã‚‚ã€é«˜è² è·ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ã‚‚ã¨ã§ã¯ã€``recv`` "
"ãƒ«ãƒ¼ãƒ—ã‚’ãµãŸã¤ä½¿ã‚ãªã„ã‚³ãƒ¼ãƒ‰ã¯ã€ã‚ã£ã¨è¨€ã†é–“ã«ãƒ€ãƒ¡ã«ãªã£ã¦ã—ã¾ã† - "
"ä¸€ç•ªç›®ã¯é•·ã•ã‚’è¦‹å®šã‚ã‚‹ç”¨ã§ã€äºŒç•ªç›®ã¯ãƒ‡ãƒ¼ã‚¿éƒ¨åˆ†ã‚’å—ã‘å–ã‚‹ç”¨ã ã€‚ã†ãƒ¼ã‚€ã€ã„ã‚„ã‚‰ã—ã„ã€‚ã•ã‚‰ã«ã“ã®ã¨ãã€``send`` "
"ã‚‚ä¸€ç™ºã§å…¨éƒ¨ã‚’å‡ºã—åˆ‡ã‚Œã‚‹ã¨ã¯é™ã‚‰ãªã„ã“ã¨ã«æ°—ä»˜ãã ã‚ã†ã€‚ãªãŠã€ä»Šã“ã†ã‚„ã£ã¦èª­ã‚“ã§ã„ã¦ã‚‚ã€ã„ã¤ã‹èª°ã‚‚ãŒç—›ã„ç›®ã‚’è¦‹ã‚‹ã®ã§ã‚ã‚‹!"

#: ../../howto/sockets.rst:246
msgid ""
"In the interests of space, building your character, (and preserving my "
"competitive position), these enhancements are left as an exercise for the "
"reader. Lets move on to cleaning up."
msgstr "ç´™é¢ã®éƒ½åˆãŠã‚ˆã³æ•™è‚²çš„é…æ…® (ã¨è‘—è€…ã®åœ°ä½ç¢ºä¿) ã®ãŸã‚ã€ã“ã†ã—ãŸæ”¹è‰¯ã¯ç·´ç¿’å•é¡Œã¨ã—ã¦æ®‹ã—ã¦ãŠãã€‚ã•ã‚ç‰‡ä»˜ã‘ã¦ã—ã¾ãŠã†ã€‚"

#: ../../howto/sockets.rst:252
msgid "Binary Data"
msgstr "ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿"

#: ../../howto/sockets.rst:254
msgid ""
"It is perfectly possible to send binary data over a socket. The major "
"problem is that not all machines use the same formats for binary data. For "
"example, a Motorola chip will represent a 16 bit integer with the value 1 as"
" the two hex bytes 00 01. Intel and DEC, however, are byte-reversed - that "
"same 1 is 01 00. Socket libraries have calls for converting 16 and 32 bit "
"integers - ``ntohl, htonl, ntohs, htons`` where \"n\" means *network* and "
"\"h\" means *host*, \"s\" means *short* and \"l\" means *long*. Where "
"network order is host order, these do nothing, but where the machine is "
"byte-reversed, these swap the bytes around appropriately."
msgstr ""
"ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã¯ã¾ã£ãŸãå•é¡Œãªãã‚½ã‚±ãƒƒãƒˆã«ä¹—ã›ã‚‰ã‚Œã‚‹ã€‚å•é¡Œã¯ã€ã™ã¹ã¦ã®ãƒã‚·ãƒ³ã§åŒã˜å½¢å¼ã‚’ä½¿ã£ã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ã“ã¨ã«ã‚ã‚‹ã€‚ãŸã¨ãˆã° Motorola "
"ã®ãƒãƒƒãƒ—ãªã‚‰ 16 ãƒ“ãƒƒãƒˆæ•´æ•°ã® 1 ã¨ã„ã†å€¤ã‚’ãµãŸã¤ã® 16 é€²ãƒã‚¤ãƒˆåˆ— 00 01 ã§è¡¨ç¾ã™ã‚‹ãŒã€Intel ã‚„ DEC ã¯é€†ãƒã‚¤ãƒˆã  - åŒã˜ 1"
" ãŒ 01 00 ã«ãªã‚‹ã®ã ã€‚ã‚½ã‚±ãƒƒãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ 16 ãƒ“ãƒƒãƒˆã‚„ 32 ãƒ“ãƒƒãƒˆæ•´æ•°ã®å¤‰æ›ç”¨ã‚³ãƒ¼ãƒ«ã‚’æŒã£ã¦ã„ã‚‹ - ``ntohl, htonl, "
"ntohs, htons`` ã§ã‚ã‚‹ã€‚\"n\" ã¯ *network*\\ ã€ \"h\" ã¯ *host* ã‚’æ„å‘³ã™ã‚‹ã€‚ \"s\" ã¯ "
"*short* ã§ \"l\" ã¯ *long* ã ã€‚ã“ã‚Œã‚‰ã®ã‚³ãƒ¼ãƒ«ã¯ã€ã€Œãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸¦ã³ = "
"ãƒ›ã‚¹ãƒˆä¸¦ã³ã€ãªã‚‰ä½•ã‚‚ã—ãªã„ãŒã€ãƒã‚·ãƒ³ãŒé€†ãƒã‚¤ãƒˆãªã‚‰ãã‚Œã«åˆã‚ã›ã¦ãã‚‹ã£ã¨äº¤æ›ã—ã¦ãã‚Œã‚‹ã€‚"

#: ../../howto/sockets.rst:264
msgid ""
"In these days of 32 bit machines, the ascii representation of binary data is"
" frequently smaller than the binary representation. That's because a "
"surprising amount of the time, all those longs have the value 0, or maybe 1."
" The string \"0\" would be two bytes, while binary is four. Of course, this "
"doesn't fit well with fixed-length messages. Decisions, decisions."
msgstr ""
"ã“ã® 32 ãƒ“ãƒƒãƒˆæ™‚ä»£ã€ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã¯ ASCII è¡¨ç¾ã®ã»ã†ãŒå°ã•ããªã‚‹ã“ã¨ãŒå¤šã„ã€‚ã¨ã„ã†ã®ã‚‚ã€long ãªã®ã«å€¤ãŒ 0 ã°ã£ã‹ã‚Šã§ãŸã¾ã« 1 "
"ã ã¨ã‹ã„ã†ã“ã¨ã¯é©šãã»ã©å¤šã„ã‹ã‚‰ã ã€‚æ–‡å­—åˆ—ãªã‚‰ \"0\" ã¯ 2 ãƒã‚¤ãƒˆãªã®ã«ã€ãƒã‚¤ãƒŠãƒªã¯ 4 "
"ãƒã‚¤ãƒˆã‚‚å–°ã†ã€‚ã‚‚ã¡ã‚ã‚“ã“ã‚Œã¯å›ºå®šé•·ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¯åˆã‚ãªã„ãŒã€‚ã•ã‚ã€ã©ã†ã™ã‚‹ã€ã©ã†ã™ã‚‹ã€‚"

#: ../../howto/sockets.rst:272
msgid "Disconnecting"
msgstr "åˆ‡æ–­"

#: ../../howto/sockets.rst:274
msgid ""
"Strictly speaking, you're supposed to use ``shutdown`` on a socket before "
"you ``close`` it.  The ``shutdown`` is an advisory to the socket at the "
"other end. Depending on the argument you pass it, it can mean \"I'm not "
"going to send anymore, but I'll still listen\", or \"I'm not listening, good"
" riddance!\".  Most socket libraries, however, are so used to programmers "
"neglecting to use this piece of etiquette that normally a ``close`` is the "
"same as ``shutdown(); close()``.  So in most situations, an explicit "
"``shutdown`` is not needed."
msgstr ""
"å³å¯†ã«ã¯ã€ã‚½ã‚±ãƒƒãƒˆã‚’ ``close`` ã™ã‚‹å‰ã«ã¯ ``shutdown`` ã™ã‚‹ã“ã¨ã«ãªã£ã¦ã„ã‚‹ã€‚ ``shutdown`` "
"ã¯ç›¸æ‰‹ã‚½ã‚±ãƒƒãƒˆã«å¯¾ã™ã‚‹å ±å‘Šã§ã‚ã‚Šã€æ¸¡ã™å¼•æ•°ã«ã‚ˆã£ã¦ã€Œã“ã‚Œä»¥ä¸Šã“ã£ã¡ã‹ã‚‰ã¯é€ã‚‰ãªã„ã‘ã©ã€ã¾ã èã„ã¦ã‚‹ãœã€ã¨ã„ã†æ„å‘³ã«ãªã£ãŸã‚Šã€ã€Œã‚‚ã†èã‹ãªã„ã€‚ã›ã„ã›ã„ã—ãŸ!ã€ã ã£ãŸã‚Šã™ã‚‹ã€‚ã—ã‹ã—ã»ã¨ã‚“ã©ã®ã‚½ã‚±ãƒƒãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€ã“ã®ã‚¨ãƒã‚±ãƒƒãƒˆã‚’æ€ ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒã«æ…£ã‚Œã¦ã—ã¾ã£ã¦ã€é€šå¸¸"
" ``close`` ã ã‘ã§ ``shutdown(); close()`` ã¨åŒã˜ã“ã¨ã«ãªã‚‹ã€‚ã ã‹ã‚‰å¤§æŠµã¯ã‚ã–ã‚ã– ``shutdown`` "
"ã—ãªãã¦ã‚‚ã„ã„ã€‚"

#: ../../howto/sockets.rst:282
msgid ""
"One way to use ``shutdown`` effectively is in an HTTP-like exchange. The "
"client sends a request and then does a ``shutdown(1)``. This tells the "
"server \"This client is done sending, but can still receive.\"  The server "
"can detect \"EOF\" by a receive of 0 bytes. It can assume it has the "
"complete request.  The server sends a reply. If the ``send`` completes "
"successfully then, indeed, the client was still receiving."
msgstr ""
"``shutdown`` ã®åŠ¹æœçš„ãªä½¿ã„æ–¹ã®ã²ã¨ã¤ã¯ã€HTTP é¢¨ã®ã‚„ã‚Šã¨ã‚Šã ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯è¦æ±‚ã‚’å‡ºã—ã¦ã™ãã« ``shutdown(1)`` "
"ã™ã‚‹ã€‚ã“ã‚Œã§ã‚µãƒ¼ãƒã«ã€ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯é€ä¿¡å®Œäº†ã§ã™ãŒã€ã¾ã å—ä¿¡å¯èƒ½ã§ã™ã€ã¨ä¼ã‚ã‚‹ã€‚ã‚µãƒ¼ãƒã¯ 0 ãƒã‚¤ãƒˆå—ä¿¡ã§ \"EOF\" "
"ã‚’æ¤œå‡ºã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚è¦æ±‚ã‚’æ®‹ã•ãšå—ã‘å–ã£ãŸã“ã¨ã«ã—ã¦è‰¯ã„ã®ã ã€‚å¯¾ã—ã¦ã‚µãƒ¼ãƒã¯è¿”ç­”ã‚’é€ã‚‹ã€‚ãã® ``send`` "
"ãŒæˆåŠŸã—ãŸãªã‚‰ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯å®Ÿéš›ã«ã¾ã å—ä¿¡ã—ã¦ã„ãŸã“ã¨ã«ãªã‚‹ã€‚"

#: ../../howto/sockets.rst:289
msgid ""
"Python takes the automatic shutdown a step further, and says that when a "
"socket is garbage collected, it will automatically do a ``close`` if it's "
"needed. But relying on this is a very bad habit. If your socket just "
"disappears without doing a ``close``, the socket at the other end may hang "
"indefinitely, thinking you're just being slow. *Please* ``close`` your "
"sockets when you're done."
msgstr ""
"Python ã¯ã“ã®è‡ªå‹• shutdown ã‚’ã‚‚ã†ä¸€æ­©é€²ã‚ã¦ã€ã‚½ã‚±ãƒƒãƒˆãŒ GC ã•ã‚Œã‚‹ã¨ãã«å¿…è¦ãªã‚‰è‡ªå‹•ã§ ``close`` "
"ã—ã¦ãã‚Œã‚‹ã¨è¨€ã£ã¦ã„ã‚‹ã€‚ã—ã‹ã—ã“ã‚Œã«é ¼ã‚‹ã‚¯ã‚»ã‚’ã¤ã‘ã¦ã¯ã„ã‘ãªã„ã€‚ã‚‚ã—ã‚½ã‚±ãƒƒãƒˆãŒ ``close`` "
"ã›ãšã«å§¿ã‚’æ¶ˆã›ã°ã€ç›¸æ‰‹ã‚½ã‚±ãƒƒãƒˆã¯ã“ã¡ã‚‰ãŒé…ã„ã ã‘ã ã¨æ€ã£ã¦ãƒãƒ³ã‚°ã—ã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œãªã„ã€‚ *ãŠé¡˜ã„ã ã‹ã‚‰* çµ‚ã‚ã£ãŸã‚‰ã¡ã‚ƒã‚“ã¨ ``close`` "
"ã—ã¦ãã‚Œã€‚"

#: ../../howto/sockets.rst:297
msgid "When Sockets Die"
msgstr "ã‚½ã‚±ãƒƒãƒˆãŒæ­»ã¬ã¨"

#: ../../howto/sockets.rst:299
msgid ""
"Probably the worst thing about using blocking sockets is what happens when "
"the other side comes down hard (without doing a ``close``). Your socket is "
"likely to hang. TCP is a reliable protocol, and it will wait a long, long "
"time before giving up on a connection. If you're using threads, the entire "
"thread is essentially dead. There's not much you can do about it. As long as"
" you aren't doing something dumb, like holding a lock while doing a blocking"
" read, the thread isn't really consuming much in the way of resources. Do "
"*not* try to kill the thread - part of the reason that threads are more "
"efficient than processes is that they avoid the overhead associated with the"
" automatic recycling of resources. In other words, if you do manage to kill "
"the thread, your whole process is likely to be screwed up."
msgstr ""
"ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚½ã‚±ãƒƒãƒˆã‚’ä½¿ã£ã¦ã„ã¦ä¸€ç•ªã„ã‚„ãªã®ã¯å¤šåˆ†ã€ç›¸æ‰‹å´ãŒæ„åœ°æ‚ªã (``close`` ã›ãšã«) "
"ãƒ€ã‚¦ãƒ³ã™ã‚‹ã¨ãã«èµ·ã“ã‚‹äº‹æŸ„ã ã€‚è‡ªåˆ†å´ã®ã‚½ã‚±ãƒƒãƒˆã¯é«˜ç¢ºç‡ã§ãƒãƒ³ã‚°ã™ã‚‹ã ã‚ã†ã€‚TCP "
"ã¯ä¿¡é ¼æ€§ã®é«˜ã„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãªã®ã§ã€ãšã£ã¨ãšã£ã¨å¾…ã¡ç¶šã‘ã¦ã€ãªã‹ãªã‹è¦‹æ¨ã¦ãªã„ã®ã ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã§ã‚ã‚Œã°ã€ãã®ã‚¹ãƒ¬ãƒƒãƒ‰å…¨ä½“ãŒæ ¹æœ¬ã‹ã‚‰æ­»ã‚“ã çŠ¶æ…‹ã«ãªã‚‹ã€‚ã“ã†ãªã‚‹ã¨ã€ã‚‚ã†æ‰‹ã®æ–½ã—ã‚ˆã†ãŒãªã„ã€‚ã¾ã‚ã€ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°èª­ã¿å‡ºã—ã®é–“ãƒ­ãƒƒã‚¯ã—ç¶šã‘ã‚‹ã¨ã„ã£ãŸé¦¬é¹¿ã’ãŸã“ã¨ã‚’ã—ã¦ã„ãªã„é™ã‚Šã€ãƒªã‚½ãƒ¼ã‚¹ã®ç‚¹ã§ã¯ãŸã„ã—ã¦æ¶ˆè²»ã«ãªã‚‰ãªã„ã€‚ã ã‹ã‚‰"
" *ãœã£ãŸã„ã«* ãã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’æ®ºãã†ã¨ã—ã¦ã¯ã„ã‘ãªã„ - "
"ãƒ—ãƒ­ã‚»ã‚¹ã‚ˆã‚Šã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŠ¹ç‡çš„ã§ã‚ã‚‹ç†ç”±ã®ã²ã¨ã¤ã¯ã€è‡ªå‹•ãƒªã‚½ãƒ¼ã‚¹å›åã«ã¾ã¤ã‚ã‚‹ã‚ªãƒ¼ãƒãƒ˜ãƒƒãƒ‰ã‚’é¿ã‘ã‚‰ã‚Œã‚‹ã¨ã„ã†ç‚¹ã«ã‚ã‚‹ã®ã ã€‚ã¤ã¾ã‚Šåˆ¥ã®è¨€ã„æ–¹ã‚’ã™ã‚‹ã¨ã€ã©ã†ã«ã‹ã—ã¦ãã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’æ®ºã—ãŸãªã‚‰ã€ãƒ—ãƒ­ã‚»ã‚¹å…¨ä½“ãŒãã¡ã‚ƒãã¡ã‚ƒã«ãªã£ã¦ã—ã¾ã†ã ã‚ã†ã¨ã„ã†ã“ã¨ã ã€‚"

#: ../../howto/sockets.rst:313
msgid "Non-blocking Sockets"
msgstr "ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚½ã‚±ãƒƒãƒˆ"

#: ../../howto/sockets.rst:315
msgid ""
"If you've understood the preceding, you already know most of what you need "
"to know about the mechanics of using sockets. You'll still use the same "
"calls, in much the same ways. It's just that, if you do it right, your app "
"will be almost inside-out."
msgstr ""
"ã“ã“ã¾ã§ç†è§£ã—ã¦ããŸãªã‚‰ã€ã‚‚ã†ã‚½ã‚±ãƒƒãƒˆã®ä»•çµ„ã¿ã«ã¤ã„ã¦å¿…è¦ãªã“ã¨ã¯ã»ã¨ã‚“ã©çŸ¥ã£ã¦ã„ã‚‹ã“ã¨ã«ãªã‚‹ã€‚ã“ã‚Œã‹ã‚‰ã‚‚åŒã˜ã‚³ãƒ¼ãƒ«ã‚’ã€ã»ã¼åŒã˜ã‚ˆã†ã«ä½¿ã£ã¦ã„ãã ã‘ã€ãã‚Œã ã‘ã ã€‚ã“ã‚Œã‚’ã¡ã‚ƒã‚“ã¨ã‚„ã£ã¦ã„ã‚Œã°ã€ãã®ã‚¢ãƒ—ãƒªã¯ã ã„ãŸã„å®Œç’§ã§ã‚ã‚ã†ã€‚"

#: ../../howto/sockets.rst:320
msgid ""
"In Python, you use ``socket.setblocking(0)`` to make it non-blocking. In C, "
"it's more complex, (for one thing, you'll need to choose between the BSD "
"flavor ``O_NONBLOCK`` and the almost indistinguishable Posix flavor "
"``O_NDELAY``, which is completely different from ``TCP_NODELAY``), but it's "
"the exact same idea. You do this after creating the socket, but before using"
" it. (Actually, if you're nuts, you can switch back and forth.)"
msgstr ""
"Python ã®å ´åˆã€ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã«ã™ã‚‹ã«ã¯ ``socket.setblocking(0)`` ã‚’ä½¿ã†ã€‚ C ãªã‚‰ã‚‚ã£ã¨è¤‡é›‘ã  "
"(ä¸€ä¾‹ã‚’æŒ™ã’ã‚‹ã¨ã€BSD æ–¹å¼ã® ``O_NONBLOCK`` ãŠã‚ˆã³ã»ã¼é•ã„ã®ãªã„ POSIX æ–¹å¼ ``O_NDELAY`` "
"ã®ã©ã¡ã‚‰ã‚’é¸ã¶ã‹æ±ºã‚ãªãã¦ã¯ãªã‚‰ãªãã¦ã€å¾Œè€…ã¯ ``TCP_NODELAY`` ã¨ã¯å…¨ç„¶åˆ¥ç‰©ã ã£ãŸã‚Šã™ã‚‹) ãŒã€è€ƒãˆæ–¹ã¯ã¾ã£ãŸãä¸€ç·’ã ã€‚"

#: ../../howto/sockets.rst:327
msgid ""
"The major mechanical difference is that ``send``, ``recv``, ``connect`` and "
"``accept`` can return without having done anything. You have (of course) a "
"number of choices. You can check return code and error codes and generally "
"drive yourself crazy. If you don't believe me, try it sometime. Your app "
"will grow large, buggy and suck CPU. So let's skip the brain-dead solutions "
"and do it right."
msgstr ""
"æ§‹é€ ä¸Šã®å¤§ããªé•ã„ã¯ã€ ``send``, ``recv``, ``connect``, ``accept`` "
"ãŒä½•ã‚‚ã—ãªã„ã§æˆ»ã£ã¦ãã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã¨ã„ã†ç‚¹ã§ã‚ã‚‹ã€‚é¸æŠè‚¢ã¯ (å½“ç„¶ãªãŒã‚‰) "
"ã„ãã¤ã‹ã‚ã‚‹ã€‚è¿”ã‚Šå€¤ã¨ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã¨ã„ã†æ–¹æ³•ã‚‚ã‚ã‚‹ã€‚ãŒã€ç™ºç‹‚ã™ã‚‹ã“ã¨è«‹ã‘åˆã„ã ã€‚ä¿¡ã˜ãªã„ãªã‚‰ã€ã„ã¤ã‹ã‚„ã£ã¦ã¿ã‚‹ã¨ã„ã„ã€‚ã‚¢ãƒ—ãƒªã¯è‚¥å¤§åŒ–ã—ã€ãƒã‚°ãŒå¢—ãˆã€CPU"
" ã‚’å–°ã„å°½ãã™ã ã‚ã†ã€‚ã ã‹ã‚‰ãã‚“ãªæ„šã‹ãªè§£æ³•ã¯é£›ã°ã—ã¦ã€æ­£è§£ã«é€²ã‚‚ã†ã€‚"

#: ../../howto/sockets.rst:334
msgid "Use ``select``."
msgstr "``select`` ã‚’ä½¿ãˆã€‚"

#: ../../howto/sockets.rst:336
msgid ""
"In C, coding ``select`` is fairly complex. In Python, it's a piece of cake, "
"but it's close enough to the C version that if you understand ``select`` in "
"Python, you'll have little trouble with it in C::"
msgstr ""
"C ã«ãŠã„ã¦ ``select`` ã§ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã®ã¯ã‹ãªã‚Šé¢å€’ã ãŒã€Python ãªã‚‰é€ ä½œã‚‚ãªã„ã€‚ã—ã‹ã— Python ã§ ``select`` "
"ã‚’ç†è§£ã—ã¦ãŠã‘ã° C ã§ã‚‚ã»ã¨ã‚“ã©å•é¡Œãªãæ›¸ã‘ã‚‹ã€ã¨ã„ã†ç¨‹åº¦ã«ã¯ä¼¼ã¦ã„ã‚‹::"

#: ../../howto/sockets.rst:347
msgid ""
"You pass ``select`` three lists: the first contains all sockets that you "
"might want to try reading; the second all the sockets you might want to try "
"writing to, and the last (normally left empty) those that you want to check "
"for errors. You should note that a socket can go into more than one list. "
"The ``select`` call is blocking, but you can give it a timeout. This is "
"generally a sensible thing to do - give it a nice long timeout (say a "
"minute) unless you have good reason to do otherwise."
msgstr ""
"``select`` "
"ã«ä¸‰ã¤ã®ãƒªã‚¹ãƒˆã‚’æ¸¡ã—ã¦ã„ã‚‹ãŒã€ä¸€ç•ªç›®ã«ã¯ã‚ã¨ã§èª­ã¿ãŸããªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‚½ã‚±ãƒƒãƒˆã™ã¹ã¦ã€äºŒç•ªç›®ã«ã¯æ›¸ãè¾¼ã¿ãŸããªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‚½ã‚±ãƒƒãƒˆã™ã¹ã¦ã€æœ€å¾Œã« "
"(é€šå¸¸ã¯ç©ºã®ã¾ã¾ã ãŒ) "
"ã‚¨ãƒ©ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯ã—ãŸã„ã‚½ã‚±ãƒƒãƒˆãŒå…¥ã£ã¦ã„ã‚‹ã€‚ã²ã¨ã¤ã®ã‚½ã‚±ãƒƒãƒˆãŒè¤‡æ•°ã«ã¾ãŸãŒã£ã¦ãƒªã‚¹ãƒˆã•ã‚Œã¦ã‚‚æ§‹ã‚ãªã„ã“ã¨ã‚’æ†¶ãˆã¦ãŠãã¨è‰¯ã„ã€‚ãªãŠã€ ``select``"
" ã‚³ãƒ¼ãƒ«ã¯ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ãŒã€æ™‚é–“åˆ¶é™ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ã“ã‚Œã¯ã€ã‚„ã£ã¦ãŠã„ã¦æã¯ãªã„ - ç‰¹ã«ç†ç”±ãŒãªã‘ã‚Œã°ã€ã‹ãªã‚Šé•·ã„ (ãŸã¨ãˆã° 1 åˆ†ã¨ã‹ã®) "
"æ™‚é–“åˆ¶é™ã‚’ä»˜ã‘ã¦ãŠãã“ã¨ã ã€‚"

#: ../../howto/sockets.rst:355
msgid ""
"In return, you will get three lists. They contain the sockets that are "
"actually readable, writable and in error. Each of these lists is a subset "
"(possibly empty) of the corresponding list you passed in."
msgstr ""
"æˆ»ã‚Šå€¤ã¨ã—ã¦ã€ä¸‰ã¤ã®ãƒªã‚¹ãƒˆãŒæ‰‹ã«å…¥ã‚‹ã€‚ãã‚Œãã‚Œã«ã¯ã€å®Ÿéš›ã«èª­ã‚ã‚‹ã‚½ã‚±ãƒƒãƒˆã€æ›¸ã‘ã‚‹ã‚½ã‚±ãƒƒãƒˆã€ã‚¨ãƒ©ãƒ¼ä¸­ã®ã‚½ã‚±ãƒƒãƒˆãŒå…¥ã£ã¦ã„ã¦ã€æ¸¡ã—ãŸãƒªã‚¹ãƒˆã®éƒ¨åˆ†é›†åˆ "
"(ç©ºé›†åˆã‹ã‚‚ã—ã‚Œãªã„) ã«ãªã£ã¦ã„ã‚‹ã€‚"

#: ../../howto/sockets.rst:359
msgid ""
"If a socket is in the output readable list, you can be as-close-to-certain-"
"as-we-ever-get-in-this-business that a ``recv`` on that socket will return "
"*something*. Same idea for the writable list. You'll be able to send "
"*something*. Maybe not all you want to, but *something* is better than "
"nothing.  (Actually, any reasonably healthy socket will return as writable -"
" it just means outbound network buffer space is available.)"
msgstr ""
"å‡ºåŠ›ã®ã†ã¡ã€readable ãƒªã‚¹ãƒˆã«ã‚ã‚‹ã‚½ã‚±ãƒƒãƒˆã«ã¤ã„ã¦ã¯ã€ ``recv`` ãŒã¨ã‚Šã‚ãˆãš *ä½•ã‹* "
"ã‚’è¿”ã™ã§ã‚ã‚ã†ã€ã¨ã„ã†ã“ã¨ã¯å²ä¸Šæœ€é«˜åº¦ã«ç¢ºä¿¡ã§ãã‚‹ã€‚ writable ãƒªã‚¹ãƒˆã‚‚è€ƒãˆæ–¹ã¯åŒã˜ã§ã€ *ä½•ã‹* "
"ã¯é€ã‚Œã‚‹ã€‚é€ã‚ŠãŸã„ã‚‚ã®å…¨ä½“ã¯ç„¡ç†ã‹ã‚‚ã—ã‚Œãªã„ãŒã€ *ä½•ã‚‚* ãªã„ã‚ˆã‚Šã¯ãƒã‚·ã ã‚ã†ã€‚ (å®Ÿã®ã¨ã“ã‚ã€ãµã¤ã†ã«å¥åº·ãªã‚½ã‚±ãƒƒãƒˆãªã‚‰ writable "
"ã§è¿”ã£ã¦ãã‚‹ã“ã¨ãŒã§ãã‚‹ - ãã‚Œã¯å¤–å‘ããƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒãƒƒãƒ•ã‚¡ã«ç©ºããŒã‚ã‚‹ã¨ã„ã†ã ã‘ã®æ„å‘³ã—ã‹ãªã„ã®ã ã‹ã‚‰)"

#: ../../howto/sockets.rst:366
msgid ""
"If you have a \"server\" socket, put it in the potential_readers list. If it"
" comes out in the readable list, your ``accept`` will (almost certainly) "
"work. If you have created a new socket to ``connect`` to someone else, put "
"it in the potential_writers list. If it shows up in the writable list, you "
"have a decent chance that it has connected."
msgstr ""
"ã€Œã‚µãƒ¼ãƒã€ã‚½ã‚±ãƒƒãƒˆã¯ potential_readers ãƒªã‚¹ãƒˆã«å…¥ã‚Œã¦ãŠã“ã†ã€‚ãã‚ŒãŒ readable ãƒªã‚¹ãƒˆã«å…¥ã£ã¦å‡ºã¦ããŸã‚‰ã€ "
"``accept`` ã¯ (ã»ã¼) ç¢ºå®Ÿã«æˆåŠŸã™ã‚‹ã¯ãšã ã€‚ã©ã“ã‹ã¸ ``connect`` ã™ã‚‹ãŸã‚ã«ä½œã£ãŸæ–°ã—ã„ã‚½ã‚±ãƒƒãƒˆã¯ "
"potential_writers ãƒªã‚¹ãƒˆã«å…¥ã‚Œã‚‹ã€‚ãã‚ŒãŒ writable ãƒªã‚¹ãƒˆã«ç¾ã‚ŒãŸã‚‰ã€æ¥ç¶šãŒæˆåŠŸã—ã¦ã„ã‚‹å¯èƒ½æ€§ã¯é«˜ã„ã¨è¨€ãˆã‚‹ã€‚"

#: ../../howto/sockets.rst:372
msgid ""
"Actually, ``select`` can be handy even with blocking sockets. It's one way "
"of determining whether you will block - the socket returns as readable when "
"there's something in the buffers.  However, this still doesn't help with the"
" problem of determining whether the other end is done, or just busy with "
"something else."
msgstr ""
"ã˜ã¤ã¯ ``select`` ã¯ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚½ã‚±ãƒƒãƒˆã«ã‚‚ä¾¿åˆ©ã«ä½¿ãˆã‚‹ã€‚ãã‚Œã¯ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã‹ã©ã†ã‹ã‚’è¦‹æ¥µã‚ã‚‹æ–¹æ³•ã®ã²ã¨ã¤ã§ã‚ã‚‹ - ãƒãƒƒãƒ•ã‚¡ã«ä½•ã‹ãŒã‚ã‚Œã°"
" readable ã¨ã—ã¦è¿”ã£ã¦ãã‚‹ã®ã ã€‚ã—ã‹ã—ã“ã‚Œã‚‚ã€ç›¸æ‰‹ã®ç”¨äº‹ãŒã‚‚ã†æ¸ˆã‚“ã§ã„ã‚‹ã®ã‹ã€ãã‚Œã¨ã‚‚å˜ã«ä»–ã®ã“ã¨ã§å¿™ã—ã„ã ã‘ãªã®ã‹ã‚’è¦‹æ¥µã‚ã‚‹å½¹ã«ã¯ç«‹ãŸãªã„ã€‚"

#: ../../howto/sockets.rst:377
msgid ""
"**Portability alert**: On Unix, ``select`` works both with the sockets and "
"files. Don't try this on Windows. On Windows, ``select`` works with sockets "
"only. Also note that in C, many of the more advanced socket options are done"
" differently on Windows. In fact, on Windows I usually use threads (which "
"work very, very well) with my sockets."
msgstr ""
"**éäº’æ›è­¦å ±**: Unix ã§ã¯ã‚½ã‚±ãƒƒãƒˆã«ã‚‚ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚‚ ``select`` ãŒä½¿ãˆã‚‹ã€‚ã“ã‚Œã‚’ Windows "
"ã§ã‚„ã‚ã†ã¨ã—ã¦ã¯ã„ã‘ãªã„ã€‚Windows ã§ ``select`` ã¯ã‚½ã‚±ãƒƒãƒˆã«ã—ã‹ä½¿ãˆãªã„ã€‚ã¾ãŸ C "
"ã®å ´åˆã€é«˜åº¦ãªã‚½ã‚±ãƒƒãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¤šãã¯ã€ã‚„ã‚Šæ–¹ãŒ Windows ã§ã¯é•ã£ã¦ã„ã‚‹ã€‚å®Ÿéš›ã€Windows ãªã‚‰è‘—è€…ã¯é€šå¸¸ã€ã‚½ã‚±ãƒƒãƒˆã«ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ã„ã‚‹"
" (ã“ã‚Œã¯å®Ÿã«ã€å®Ÿã«ã†ã¾ãã„ã)ã€‚"
