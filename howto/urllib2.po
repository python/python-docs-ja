# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2021
# Tetsuo Koyama <tkoyama010@gmail.com>, 2021
# Takanori Suzuki <takanori@takanory.net>, 2023
# souma987, 2023
# TENMYO Masakazu, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-20 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: TENMYO Masakazu, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/urllib2.rst:5
msgid "HOWTO Fetch Internet Resources Using The urllib Package"
msgstr "urllib パッケージを使ってインターネット上のリソースを取得するには"

#: ../../howto/urllib2.rst:0
msgid "Author"
msgstr "著者"

#: ../../howto/urllib2.rst:7
msgid "`Michael Foord <https://agileabstractions.com/>`_"
msgstr "`Michael Foord <https://agileabstractions.com/>`_"

#: ../../howto/urllib2.rst:11
msgid "Introduction"
msgstr "はじめに"

#: ../../howto/urllib2.rst:15
msgid ""
"You may also find useful the following article on fetching web resources "
"with Python:"
msgstr ""
"同じように Python でインターネットリソースを取得するのに以下の記事が役に立ち"
"ます:"

#: ../../howto/urllib2.rst:18
msgid ""
"`Basic Authentication <https://web.archive.org/web/20201215133350/http://www."
"voidspace.org.uk/python/articles/authentication.shtml>`_"
msgstr ""
"`Basic Authentication <https://web.archive.org/web/20201215133350/http://www."
"voidspace.org.uk/python/articles/authentication.shtml>`_"

#: ../../howto/urllib2.rst:20
msgid "A tutorial on *Basic Authentication*, with examples in Python."
msgstr "*Basic 認証* についてのチュートリアルで Python の例がついています。"

#: ../../howto/urllib2.rst:22
msgid ""
"**urllib.request** is a Python module for fetching URLs (Uniform Resource "
"Locators). It offers a very simple interface, in the form of the *urlopen* "
"function. This is capable of fetching URLs using a variety of different "
"protocols. It also offers a slightly more complex interface for handling "
"common situations - like basic authentication, cookies, proxies and so on. "
"These are provided by objects called handlers and openers."
msgstr ""
"**urllib.request** は URLs (Uniform Resource Locators) を取得するための "
"Python モジュールです。このモジュールはとても簡単なインターフェースを "
"*urlopen* 関数の形式で提供しています。また、このモジュールは一般的な状況で利"
"用するためにいくらか複雑なインターフェースも提供しています - basic 認証やクッ"
"キー、プロキシ等。これらは handler や opener と呼ばれるオブジェクトとして提供"
"されます。"

#: ../../howto/urllib2.rst:29
msgid ""
"urllib.request supports fetching URLs for many \"URL schemes\" (identified "
"by the string before the ``\":\"`` in URL - for example ``\"ftp\"`` is the "
"URL scheme of ``\"ftp://python.org/\"``) using their associated network "
"protocols (e.g. FTP, HTTP). This tutorial focuses on the most common case, "
"HTTP."
msgstr ""
"urllib.request は多くの \"URL スキーム\" (URL の \":\" の前の文字列で識別され"
"るもの - 例えば \"ftp://python.org/\" では \"ftp\") の URL を、関連するネット"
"ワークプロトコル(例えば FTP, HTTP) を利用することで、取得できます。"

#: ../../howto/urllib2.rst:34
msgid ""
"For straightforward situations *urlopen* is very easy to use. But as soon as "
"you encounter errors or non-trivial cases when opening HTTP URLs, you will "
"need some understanding of the HyperText Transfer Protocol. The most "
"comprehensive and authoritative reference to HTTP is :rfc:`2616`. This is a "
"technical document and not intended to be easy to read. This HOWTO aims to "
"illustrate using *urllib*, with enough detail about HTTP to help you "
"through. It is not intended to replace the :mod:`urllib.request` docs, but "
"is supplementary to them."
msgstr ""
"単純な状況では *urlopen* はとても簡単に使うことができます。しかし HTTP の "
"URL を開くときにエラーが起きたり、特殊なケースに遭遇すると、 HyperText "
"Transfer Protocol に関するいくつかのことを理解する必要があります。 HTTP に関"
"して最も包括的で信頼できる文献は :rfc:`2616` です。この文書は技術文書なので簡"
"単には読めません。この HOWTO の目的は *urllib* の利用法を例示することです、 "
"HTTP についてはその助けになるのに十分に詳しく載せています。このドキュメント"
"は :mod:`urllib.request` のドキュメントの代わりにはなりませんが、補完する役割"
"を持っています。"

#: ../../howto/urllib2.rst:44
msgid "Fetching URLs"
msgstr "URL を取得する"

#: ../../howto/urllib2.rst:46
msgid "The simplest way to use urllib.request is as follows::"
msgstr "urllib.request を利用する最も簡単な方法は以下です::"

#: ../../howto/urllib2.rst:48
msgid ""
"import urllib.request\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"   html = response.read()"
msgstr ""

#: ../../howto/urllib2.rst:52
msgid ""
"If you wish to retrieve a resource via URL and store it in a temporary "
"location, you can do so via the :func:`shutil.copyfileobj` and :func:"
"`tempfile.NamedTemporaryFile` functions::"
msgstr ""
"URL によってリソースを取得し、それを一時的な場所に保存しておきたいときは、 :"
"func:`shutil.copyfileobj` と :func:`tempfile.NamedTemporaryFile` 関数を使って"
"行うことができます::"

#: ../../howto/urllib2.rst:56
msgid ""
"import shutil\n"
"import tempfile\n"
"import urllib.request\n"
"\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n"
"        shutil.copyfileobj(response, tmp_file)\n"
"\n"
"with open(tmp_file.name) as html:\n"
"    pass"
msgstr ""

#: ../../howto/urllib2.rst:67
msgid ""
"Many uses of urllib will be that simple (note that instead of an 'http:' URL "
"we could have used a URL starting with 'ftp:', 'file:', etc.).  However, "
"it's the purpose of this tutorial to explain the more complicated cases, "
"concentrating on HTTP."
msgstr ""
"多くの urllib の利用法はこのように簡単です ('http:' の代わりに URL を 'ftp:' "
"や 'file:' 等で始めればできます)。しかし、このチュートリアルの目的は、特に "
"HTTP に絞って、より複雑な状況を説明することです。"

#: ../../howto/urllib2.rst:72
msgid ""
"HTTP is based on requests and responses - the client makes requests and "
"servers send responses. urllib.request mirrors this with a ``Request`` "
"object which represents the HTTP request you are making. In its simplest "
"form you create a Request object that specifies the URL you want to fetch. "
"Calling ``urlopen`` with this Request object returns a response object for "
"the URL requested. This response is a file-like object, which means you can "
"for example call ``.read()`` on the response::"
msgstr ""
"HTTP はリクエスト (request) とレスポンス (response) が基本となっています - ク"
"ライアントがリクエストし、サーバーがレスポンスを送ります。urllib.request はこ"
"れを真似て、作成する HTTP リクエストを表現する ``Request`` オブジェクトを備え"
"ています。リクエストオブジェクトを作成する最も簡単な方法は取得したい URL を指"
"定することです。``urlopen`` をこのオブジェクトを使って呼び出すと、リクエスト"
"した URL のレスポンスオブジェクトが返されます。このレスポンスはファイルライク"
"オブジェクトで、これはつまりレスポンスに ``.read()`` と呼び出せることを意味し"
"ています::"

#: ../../howto/urllib2.rst:80
msgid ""
"import urllib.request\n"
"\n"
"req = urllib.request.Request('http://python.org/')\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""

#: ../../howto/urllib2.rst:86
msgid ""
"Note that urllib.request makes use of the same Request interface to handle "
"all URL schemes.  For example, you can make an FTP request like so::"
msgstr ""
"urllib.request は同じリクエストインターフェースを全ての URL スキームに対して"
"利用できるようにしています。例えば、FTP リクエストの場合はこうできます::"

#: ../../howto/urllib2.rst:89
msgid "req = urllib.request.Request('ftp://example.com/')"
msgstr ""

#: ../../howto/urllib2.rst:91
msgid ""
"In the case of HTTP, there are two extra things that Request objects allow "
"you to do: First, you can pass data to be sent to the server.  Second, you "
"can pass extra information (\"metadata\") *about* the data or about the "
"request itself, to the server - this information is sent as HTTP "
"\"headers\".  Let's look at each of these in turn."
msgstr ""
"HTTP の場合には、リクエストオブジェクトに対して二つの特別な操作ができます: 一"
"つ目はサーバーに送るデータを渡すことができる、二つ目はサーバーに送るデータや"
"リクエスト自身に *ついての* 特別な情報 (\"metadata\")を渡すことができます - "
"これらの送られる情報は HTTP 「ヘッダ」です。今度はこれらに関してひとつひとつ"
"見ていきましょう。"

#: ../../howto/urllib2.rst:98
msgid "Data"
msgstr "データ"

#: ../../howto/urllib2.rst:100
msgid ""
"Sometimes you want to send data to a URL (often the URL will refer to a CGI "
"(Common Gateway Interface) script or other web application). With HTTP, this "
"is often done using what's known as a **POST** request. This is often what "
"your browser does when you submit a HTML form that you filled in on the web. "
"Not all POSTs have to come from forms: you can use a POST to transmit "
"arbitrary data to your own application. In the common case of HTML forms, "
"the data needs to be encoded in a standard way, and then passed to the "
"Request object as the ``data`` argument. The encoding is done using a "
"function from the :mod:`urllib.parse` library. ::"
msgstr ""
"URL にデータを送りたい場合はよくあります (しばしば、その URL は CGI (Common "
"Gateway Interface) スクリプトや他の web アプリケーションを参照することになり"
"ます)。これは HTTP では、 **POST** リクエストとして知られる方法で行なわれま"
"す。これは web 上で HTML フォームを埋めて送信するときにブラウザが行なっている"
"ことです。全ての POST がフォームから送られるとは限りません: 自身のアプリケー"
"ションに対して任意のデータを POST を使って送ることができます。一般的な HTML "
"フォームの場合、データは標準的な方法でエンコードされている必要があり、リクエ"
"ストオブジェクトに ``data`` 引数として渡します。エンコーディングは :mod:"
"`urllib.parse` ライブラリの関数を使って行います。 ::"

#: ../../howto/urllib2.rst:110
msgid ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"values = {'name' : 'Michael Foord',\n"
"          'location' : 'Northampton',\n"
"          'language' : 'Python' }\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii') # data should be bytes\n"
"req = urllib.request.Request(url, data)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""

#: ../../howto/urllib2.rst:124
msgid ""
"Note that other encodings are sometimes required (e.g. for file upload from "
"HTML forms - see `HTML Specification, Form Submission <https://www.w3.org/TR/"
"REC-html40/interact/forms.html#h-17.13>`_ for more details)."
msgstr ""
"他のエンコーディングが必要な場合があることに注意して下さい (例えば、 HTML "
"フォームからファイルをアップロードするための詳細については `HTML "
"Specification, Form Submission <https://www.w3.org/TR/REC-html40/interact/"
"forms.html#h-17.13>`_ を見て下さい)。"

#: ../../howto/urllib2.rst:129
msgid ""
"If you do not pass the ``data`` argument, urllib uses a **GET** request. One "
"way in which GET and POST requests differ is that POST requests often have "
"\"side-effects\": they change the state of the system in some way (for "
"example by placing an order with the website for a hundredweight of tinned "
"spam to be delivered to your door).  Though the HTTP standard makes it clear "
"that POSTs are intended to *always* cause side-effects, and GET requests "
"*never* to cause side-effects, nothing prevents a GET request from having "
"side-effects, nor a POST requests from having no side-effects. Data can also "
"be passed in an HTTP GET request by encoding it in the URL itself."
msgstr ""
"``data`` 引数を渡さない場合、urllib は **GET** リクエストを利用します。GET "
"と POST リクエストの一つの違いは、POST リクエストにしばしば、「副作用」がある"
"ことです: POST リクエストはいくつかの方法によってシステムの状態を変化させま"
"す (例えば100ポンドのスパムの缶詰をドアの前まで配達する注文を web サイトで行"
"う)。とはいえ HTTP 標準で明確にされている内容では、POST は *常に* 副作用を持"
"ち、GET リクエストは *決して* 副作用を持たないことを意図するけれども、、GET "
"リクエストが副作用を持つことも、POST リクエストが副作用を持たないことも、妨げ"
"られません。HTTP の GET リクエストでもデータ自身をエンコーディングすることで"
"データを渡すことができます。"

#: ../../howto/urllib2.rst:139
msgid "This is done as follows::"
msgstr "以下のようにして行います::"

#: ../../howto/urllib2.rst:141
msgid ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = {}\n"
">>> data['name'] = 'Somebody Here'\n"
">>> data['location'] = 'Northampton'\n"
">>> data['language'] = 'Python'\n"
">>> url_values = urllib.parse.urlencode(data)\n"
">>> print(url_values)  # The order may differ from below.  \n"
"name=Somebody+Here&language=Python&location=Northampton\n"
">>> url = 'http://www.example.com/example.cgi'\n"
">>> full_url = url + '?' + url_values\n"
">>> data = urllib.request.urlopen(full_url)"
msgstr ""

#: ../../howto/urllib2.rst:154
msgid ""
"Notice that the full URL is created by adding a ``?`` to the URL, followed "
"by the encoded values."
msgstr ""
"``?`` を URL に加え、それにエンコードされた値が続くことで、完全な URL が作ら"
"れていることに注意して下さい。"

#: ../../howto/urllib2.rst:158
msgid "Headers"
msgstr "ヘッダ"

#: ../../howto/urllib2.rst:160
msgid ""
"We'll discuss here one particular HTTP header, to illustrate how to add "
"headers to your HTTP request."
msgstr ""
"ここでは特定の HTTP ヘッダについて議論します、 HTTP リクエストにヘッダを追加"
"する方法について例示します。"

#: ../../howto/urllib2.rst:163
msgid ""
"Some websites [#]_ dislike being browsed by programs, or send different "
"versions to different browsers [#]_. By default urllib identifies itself as "
"``Python-urllib/x.y`` (where ``x`` and ``y`` are the major and minor version "
"numbers of the Python release, e.g. ``Python-urllib/2.5``), which may "
"confuse the site, or just plain not work. The way a browser identifies "
"itself is through the ``User-Agent`` header [#]_. When you create a Request "
"object you can pass a dictionary of headers in. The following example makes "
"the same request as above, but identifies itself as a version of Internet "
"Explorer [#]_. ::"
msgstr ""
"いくつかの web サイト [#]_ はプログラムからブラウズされることを嫌っていたり、"
"異なるブラウザに対して異なるバージョンを送ります [#]_。デフォルトでは urllib "
"は自身の情報を ``Python-urllib/x.y`` として扱います ( ``x`` と ``y`` は "
"Python のリリースバージョンのメジャーバージョンとマイナーバージョンです、例え"
"ば ``Python-urllib/2.5`` など)。これによって web サイト側が混乱したり、動作し"
"ないかもしれません。ブラウザは自身の情報を ``User-Agent`` ヘッダ [#]_ を通し"
"て扱っています。リクエストオブジェクトを作るときに、ヘッダに辞書を渡すことが"
"できます。以下の例は上の例と同じですが、自身を Internet Explorer [#]_ のバー"
"ジョンの一つとして扱っています。 ::"

#: ../../howto/urllib2.rst:174
msgid ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"user_agent = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64)'\n"
"values = {'name': 'Michael Foord',\n"
"          'location': 'Northampton',\n"
"          'language': 'Python' }\n"
"headers = {'User-Agent': user_agent}\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii')\n"
"req = urllib.request.Request(url, data, headers)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""

#: ../../howto/urllib2.rst:190
msgid ""
"The response also has two useful methods. See the section on `info and "
"geturl`_ which comes after we have a look at what happens when things go "
"wrong."
msgstr ""
"レスポンスは二つの便利なメソッドも持っています。 `info と geturl`_ の節を見て"
"下さい、この節は後で問題が起きた場合に見ておくべき内容です。"

#: ../../howto/urllib2.rst:195
msgid "Handling Exceptions"
msgstr "例外を処理する"

#: ../../howto/urllib2.rst:197
msgid ""
"*urlopen* raises :exc:`~urllib.error.URLError` when it cannot handle a "
"response (though as usual with Python APIs, built-in exceptions such as :exc:"
"`ValueError`, :exc:`TypeError` etc. may also be raised)."
msgstr ""

#: ../../howto/urllib2.rst:201
msgid ""
":exc:`~urllib.error.HTTPError` is the subclass of :exc:`~urllib.error."
"URLError` raised in the specific case of HTTP URLs."
msgstr ""

#: ../../howto/urllib2.rst:204
msgid "The exception classes are exported from the :mod:`urllib.error` module."
msgstr "例外クラスは :mod:`urllib.error` モジュールから提供されています。"

#: ../../howto/urllib2.rst:207
msgid "URLError"
msgstr "URLError"

#: ../../howto/urllib2.rst:209
msgid ""
"Often, URLError is raised because there is no network connection (no route "
"to the specified server), or the specified server doesn't exist.  In this "
"case, the exception raised will have a 'reason' attribute, which is a tuple "
"containing an error code and a text error message."
msgstr ""
"URLError が送出されることはよく起こります、それはネットワーク接続が無い場合"
"や、指定したサーバが無い場合です。この場合、例外は 'reason' 属性を持ってい"
"て、この属性はエラーコードとエラーメッセージのテキストを含むタプルです。"

#: ../../howto/urllib2.rst:214
msgid "e.g. ::"
msgstr "例::"

#: ../../howto/urllib2.rst:216
msgid ""
">>> req = urllib.request.Request('http://www.pretend_server.org')\n"
">>> try: urllib.request.urlopen(req)\n"
"... except urllib.error.URLError as e:\n"
"...     print(e.reason)      \n"
"...\n"
"(4, 'getaddrinfo failed')"
msgstr ""

#: ../../howto/urllib2.rst:225
msgid "HTTPError"
msgstr "HTTPError"

#: ../../howto/urllib2.rst:227
msgid ""
"Every HTTP response from the server contains a numeric \"status code\". "
"Sometimes the status code indicates that the server is unable to fulfil the "
"request. The default handlers will handle some of these responses for you "
"(for example, if the response is a \"redirection\" that requests the client "
"fetch the document from a different URL, urllib will handle that for you). "
"For those it can't handle, urlopen will raise an :exc:`~urllib.error."
"HTTPError`. Typical errors include '404' (page not found), '403' (request "
"forbidden), and '401' (authentication required)."
msgstr ""

#: ../../howto/urllib2.rst:235
msgid ""
"See section 10 of :rfc:`2616` for a reference on all the HTTP error codes."
msgstr "HTTP のエラーコード全てについては :rfc:`2616` の10節を参照して下さい。"

#: ../../howto/urllib2.rst:237
msgid ""
"The :exc:`~urllib.error.HTTPError` instance raised will have an integer "
"'code' attribute, which corresponds to the error sent by the server."
msgstr ""

#: ../../howto/urllib2.rst:241
msgid "Error Codes"
msgstr "エラーコード"

#: ../../howto/urllib2.rst:243
msgid ""
"Because the default handlers handle redirects (codes in the 300 range), and "
"codes in the 100--299 range indicate success, you will usually only see "
"error codes in the 400--599 range."
msgstr ""
"デフォルトハンドラーはリダイレクト(コードは300番台にあります) を処理し、"
"100--299番台のコードは成功を意味しているので、たいていの場合は400--599番台の"
"エラーコードのみを見るだけですみます。"

#: ../../howto/urllib2.rst:247
msgid ""
":attr:`http.server.BaseHTTPRequestHandler.responses` is a useful dictionary "
"of response codes in that shows all the response codes used by :rfc:`2616`. "
"The dictionary is reproduced here for convenience ::"
msgstr ""
":attr:`http.server.BaseHTTPRequestHandler.responses` は :rfc:`2616` で利用さ"
"れるレスポンスコード全てを示す便利な辞書です。この辞書は便利なのでここに載せ"
"ておきます ::"

#: ../../howto/urllib2.rst:251
msgid ""
"# Table mapping response codes to messages; entries have the\n"
"# form {code: (shortmessage, longmessage)}.\n"
"responses = {\n"
"    100: ('Continue', 'Request received, please continue'),\n"
"    101: ('Switching Protocols',\n"
"          'Switching to new protocol; obey Upgrade header'),\n"
"\n"
"    200: ('OK', 'Request fulfilled, document follows'),\n"
"    201: ('Created', 'Document created, URL follows'),\n"
"    202: ('Accepted',\n"
"          'Request accepted, processing continues off-line'),\n"
"    203: ('Non-Authoritative Information', 'Request fulfilled from cache'),\n"
"    204: ('No Content', 'Request fulfilled, nothing follows'),\n"
"    205: ('Reset Content', 'Clear input form for further input.'),\n"
"    206: ('Partial Content', 'Partial content follows.'),\n"
"\n"
"    300: ('Multiple Choices',\n"
"          'Object has several resources -- see URI list'),\n"
"    301: ('Moved Permanently', 'Object moved permanently -- see URI list'),\n"
"    302: ('Found', 'Object moved temporarily -- see URI list'),\n"
"    303: ('See Other', 'Object moved -- see Method and URL list'),\n"
"    304: ('Not Modified',\n"
"          'Document has not changed since given time'),\n"
"    305: ('Use Proxy',\n"
"          'You must use proxy specified in Location to access this '\n"
"          'resource.'),\n"
"    307: ('Temporary Redirect',\n"
"          'Object moved temporarily -- see URI list'),\n"
"\n"
"    400: ('Bad Request',\n"
"          'Bad request syntax or unsupported method'),\n"
"    401: ('Unauthorized',\n"
"          'No permission -- see authorization schemes'),\n"
"    402: ('Payment Required',\n"
"          'No payment -- see charging schemes'),\n"
"    403: ('Forbidden',\n"
"          'Request forbidden -- authorization will not help'),\n"
"    404: ('Not Found', 'Nothing matches the given URI'),\n"
"    405: ('Method Not Allowed',\n"
"          'Specified method is invalid for this server.'),\n"
"    406: ('Not Acceptable', 'URI not available in preferred format.'),\n"
"    407: ('Proxy Authentication Required', 'You must authenticate with '\n"
"          'this proxy before proceeding.'),\n"
"    408: ('Request Timeout', 'Request timed out; try again later.'),\n"
"    409: ('Conflict', 'Request conflict.'),\n"
"    410: ('Gone',\n"
"          'URI no longer exists and has been permanently removed.'),\n"
"    411: ('Length Required', 'Client must specify Content-Length.'),\n"
"    412: ('Precondition Failed', 'Precondition in headers is false.'),\n"
"    413: ('Request Entity Too Large', 'Entity is too large.'),\n"
"    414: ('Request-URI Too Long', 'URI is too long.'),\n"
"    415: ('Unsupported Media Type', 'Entity body in unsupported format.'),\n"
"    416: ('Requested Range Not Satisfiable',\n"
"          'Cannot satisfy request range.'),\n"
"    417: ('Expectation Failed',\n"
"          'Expect condition could not be satisfied.'),\n"
"\n"
"    500: ('Internal Server Error', 'Server got itself in trouble'),\n"
"    501: ('Not Implemented',\n"
"          'Server does not support this operation'),\n"
"    502: ('Bad Gateway', 'Invalid responses from another server/proxy.'),\n"
"    503: ('Service Unavailable',\n"
"          'The server cannot process the request due to a high load'),\n"
"    504: ('Gateway Timeout',\n"
"          'The gateway server did not receive a timely response'),\n"
"    505: ('HTTP Version Not Supported', 'Cannot fulfill request.'),\n"
"    }"
msgstr ""

#: ../../howto/urllib2.rst:319
msgid ""
"When an error is raised the server responds by returning an HTTP error code "
"*and* an error page. You can use the :exc:`~urllib.error.HTTPError` instance "
"as a response on the page returned. This means that as well as the code "
"attribute, it also has read, geturl, and info, methods as returned by the "
"``urllib.response`` module::"
msgstr ""
"エラーが起きた場合、サーバーは HTTP エラーコード *および* エラーページを返し"
"て応答します。 :exc:`~urllib.error.HTTPError` インスタンスはエラーページのレ"
"スポンスとして扱えます。これは code 属性だけでなく、 ``urllib.response`` モ"
"ジュールが返すような read, geturl, info メソッドも持つことを意味します::"

#: ../../howto/urllib2.rst:324
msgid ""
">>> req = urllib.request.Request('http://www.python.org/fish.html')\n"
">>> try:\n"
"...     urllib.request.urlopen(req)\n"
"... except urllib.error.HTTPError as e:\n"
"...     print(e.code)\n"
"...     print(e.read())  \n"
"...\n"
"404\n"
"b'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"
"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional."
"dtd\">\\n\\n\\n<html\n"
"  ...\n"
"  <title>Page Not Found</title>\\n\n"
"  ..."
msgstr ""

#: ../../howto/urllib2.rst:339
msgid "Wrapping it Up"
msgstr "エラーをラップする"

#: ../../howto/urllib2.rst:341
msgid ""
"So if you want to be prepared for :exc:`~urllib.error.HTTPError` *or* :exc:"
"`~urllib.error.URLError` there are two basic approaches. I prefer the second "
"approach."
msgstr ""

#: ../../howto/urllib2.rst:345
msgid "Number 1"
msgstr "その1"

#: ../../howto/urllib2.rst:350
msgid ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError, HTTPError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except HTTPError as e:\n"
"    print('The server couldn\\'t fulfill the request.')\n"
"    print('Error code: ', e.code)\n"
"except URLError as e:\n"
"    print('We failed to reach a server.')\n"
"    print('Reason: ', e.reason)\n"
"else:\n"
"    # everything is fine"
msgstr ""

#: ../../howto/urllib2.rst:367
msgid ""
"The ``except HTTPError`` *must* come first, otherwise ``except URLError`` "
"will *also* catch an :exc:`~urllib.error.HTTPError`."
msgstr ""

#: ../../howto/urllib2.rst:371
msgid "Number 2"
msgstr "その2"

#: ../../howto/urllib2.rst:375
msgid ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except URLError as e:\n"
"    if hasattr(e, 'reason'):\n"
"        print('We failed to reach a server.')\n"
"        print('Reason: ', e.reason)\n"
"    elif hasattr(e, 'code'):\n"
"        print('The server couldn\\'t fulfill the request.')\n"
"        print('Error code: ', e.code)\n"
"else:\n"
"    # everything is fine"
msgstr ""

#: ../../howto/urllib2.rst:392
msgid "info and geturl"
msgstr "info と geturl"

#: ../../howto/urllib2.rst:394
msgid ""
"The response returned by urlopen (or the :exc:`~urllib.error.HTTPError` "
"instance) has two useful methods :meth:`!info` and :meth:`!geturl` and is "
"defined in the module :mod:`urllib.response`."
msgstr ""

#: ../../howto/urllib2.rst:398
msgid ""
"**geturl** - this returns the real URL of the page fetched. This is useful "
"because ``urlopen`` (or the opener object used) may have followed a "
"redirect. The URL of the page fetched may not be the same as the URL "
"requested."
msgstr ""
"**geturl** - これは取得したページの実際の URL を返します。 ``urlopen`` (また"
"は利用される opener オブジェクト) はリダイレクトに追従するため、有用です。取"
"得したページの URL は要求した URL と同じとは限りません。"

#: ../../howto/urllib2.rst:402
msgid ""
"**info** - this returns a dictionary-like object that describes the page "
"fetched, particularly the headers sent by the server. It is currently an :"
"class:`http.client.HTTPMessage` instance."
msgstr ""
"**info** - これは取得したページ (特にサーバからヘッダ)を表す辞書風オブジェク"
"トを返します。これは現在では :class:`http.client.HTTPMessage` インスタンスで"
"す。"

#: ../../howto/urllib2.rst:406
msgid ""
"Typical headers include 'Content-length', 'Content-type', and so on. See the "
"`Quick Reference to HTTP Headers <https://jkorpela.fi/http.html>`_ for a "
"useful listing of HTTP headers with brief explanations of their meaning and "
"use."
msgstr ""
"典型的なヘッダは 'Content-length', 'Content-type' 等を含んでいます。 HTTP "
"ヘッダの意味と利用法について簡単な説明つきの便利な一覧 `Quick Reference to "
"HTTP Headers <https://jkorpela.fi/http.html>`_ を参照して下さい。"

#: ../../howto/urllib2.rst:413
msgid "Openers and Handlers"
msgstr "Openers と Handlers"

#: ../../howto/urllib2.rst:415
msgid ""
"When you fetch a URL you use an opener (an instance of the perhaps "
"confusingly named :class:`urllib.request.OpenerDirector`). Normally we have "
"been using the default opener - via ``urlopen`` - but you can create custom "
"openers. Openers use handlers. All the \"heavy lifting\" is done by the "
"handlers. Each handler knows how to open URLs for a particular URL scheme "
"(http, ftp, etc.), or how to handle an aspect of URL opening, for example "
"HTTP redirections or HTTP cookies."
msgstr ""
"URL を取得する場合、opener (混乱を招きやすい名前ですが、 :class:`urllib."
"request.OpenerDirector` のインスタンス) を利用します。標準的にはデフォルトの "
"opener を - ``urlopen`` を通して - 利用していますが、カスタムの opener を作成"
"することもできます。 opener は handler を利用します。全ての「一番厄介な仕事」"
"はハンドラによって行なわれます。各 handler は特定の URL スキーム (http, ftp, "
"等) での URL の開き方を知っていたり、 URL を開く局面でどう処理するかを知って"
"います、例えば HTTP リダイレクションや HTTP のクッキーなど。"

#: ../../howto/urllib2.rst:423
msgid ""
"You will want to create openers if you want to fetch URLs with specific "
"handlers installed, for example to get an opener that handles cookies, or to "
"get an opener that does not handle redirections."
msgstr ""
"インストール済みの特定のハンドラで URL を取得したい場合には、 opener を作成し"
"たいと思うでしょう、例えばクッキーを処理する opener が得たい場合や、リダイレ"
"クションを処理しない opener を得たい場合。"

#: ../../howto/urllib2.rst:427
msgid ""
"To create an opener, instantiate an ``OpenerDirector``, and then call ``."
"add_handler(some_handler_instance)`` repeatedly."
msgstr ""
"opener を作成するには、 ``OpenerDirector`` をインスタンス化して、続けて、 ``."
"add_handler(some_handler_instance)`` を呼び出します。"

#: ../../howto/urllib2.rst:430
msgid ""
"Alternatively, you can use ``build_opener``, which is a convenience function "
"for creating opener objects with a single function call.  ``build_opener`` "
"adds several handlers by default, but provides a quick way to add more and/"
"or override the default handlers."
msgstr ""
"それに代わる方法として、 ``build_opener`` を利用することもできます、これは "
"opener オブジェクトを一回の関数呼び出しで作成できる便利な関数です。 "
"``build_opener`` はいくつかのハンドラをデフォルトで追加しますが、デフォルトの"
"ハンドラに対して追加、継承のどちらかまたは両方を行うのに手っ取り早い方法を提"
"供してくれます。"

#: ../../howto/urllib2.rst:435
msgid ""
"Other sorts of handlers you might want to can handle proxies, "
"authentication, and other common but slightly specialised situations."
msgstr ""
"追加したくなる可能性がある handler としては、プロキシ処理、認証など、一般的で"
"すがいくらか特定の状況に限られるものでしょう。"

#: ../../howto/urllib2.rst:438
msgid ""
"``install_opener`` can be used to make an ``opener`` object the (global) "
"default opener. This means that calls to ``urlopen`` will use the opener you "
"have installed."
msgstr ""
"``install_opener`` も (グローバルな) デフォルト ``opener`` オブジェクトの作成"
"に利用できます。つまり、 ``urlopen`` を呼び出すと、インストールした opener が"
"利用されます。"

#: ../../howto/urllib2.rst:442
msgid ""
"Opener objects have an ``open`` method, which can be called directly to "
"fetch urls in the same way as the ``urlopen`` function: there's no need to "
"call ``install_opener``, except as a convenience."
msgstr ""
"opener オブジェクトは ``open`` メソッドを持っていて、 ``urlopen`` 関数と同じ"
"様に、url を取得するのに直接呼び出すことができます: 利便性を除けば "
"``install_opener`` を使う必要はありません。"

#: ../../howto/urllib2.rst:448
msgid "Basic Authentication"
msgstr "Basic 認証"

#: ../../howto/urllib2.rst:450
msgid ""
"To illustrate creating and installing a handler we will use the "
"``HTTPBasicAuthHandler``. For a more detailed discussion of this subject -- "
"including an explanation of how Basic Authentication works - see the `Basic "
"Authentication Tutorial <https://web.archive.org/web/20201215133350/http://"
"www.voidspace.org.uk/python/articles/authentication.shtml>`__."
msgstr ""

#: ../../howto/urllib2.rst:456
msgid ""
"When authentication is required, the server sends a header (as well as the "
"401 error code) requesting authentication.  This specifies the "
"authentication scheme and a 'realm'. The header looks like: ``WWW-"
"Authenticate: SCHEME realm=\"REALM\"``."
msgstr ""
"認証が必要な場合、サーバは認証を要求するヘッダ (401 のエラーコードとともに) "
"を送ります。これによって認証スキームと 'realm' が指定されます。ヘッダはこのよ"
"うになっています: ``WWW-Authenticate: SCHEME realm=\"REALM\"`` 。"

#: ../../howto/urllib2.rst:461
msgid "e.g."
msgstr "例"

#: ../../howto/urllib2.rst:463
msgid "WWW-Authenticate: Basic realm=\"cPanel Users\""
msgstr ""

#: ../../howto/urllib2.rst:468
msgid ""
"The client should then retry the request with the appropriate name and "
"password for the realm included as a header in the request. This is 'basic "
"authentication'. In order to simplify this process we can create an instance "
"of ``HTTPBasicAuthHandler`` and an opener to use this handler."
msgstr ""
"クライアントはリクエストヘッダに含まれる realm に対して適切な名前とパスワード"
"とともにリクエストを再試行する必要があります。これが 'basic 認証' です。一連"
"の流れを簡単化するために、 ``HTTPBasicAuthHandler`` のインスタンスを作成し、 "
"opener が handler を利用するようにします。"

#: ../../howto/urllib2.rst:473
msgid ""
"The ``HTTPBasicAuthHandler`` uses an object called a password manager to "
"handle the mapping of URLs and realms to passwords and usernames. If you "
"know what the realm is (from the authentication header sent by the server), "
"then you can use a ``HTTPPasswordMgr``. Frequently one doesn't care what the "
"realm is. In that case, it is convenient to use "
"``HTTPPasswordMgrWithDefaultRealm``. This allows you to specify a default "
"username and password for a URL. This will be supplied in the absence of you "
"providing an alternative combination for a specific realm. We indicate this "
"by providing ``None`` as the realm argument to the ``add_password`` method."
msgstr ""
"``HTTPBasicAuthHandler`` はパスワードマネージャーと呼ばれる、 URL と realm を"
"パスワードとユーザ名への対応づけを処理する、オブジェクトを利用します。 realm "
"が何なのか(サーバから返される認証ヘッダから) 知りたい場合には、 "
"``HTTPPasswordMgr`` を利用できます。多くの場合、realm が何なのかについて気に"
"することはありません。そのような場合には ``HTTPPasswordMgrWithDefaultRealm`` "
"を使うと便利です。これは URL に対してデフォルトのユーザ名とパスワードを指定で"
"きます。これによって特定の realm に対する代替の組み合わせを提供することなしに"
"利用できるようになります。このことは ``add_password`` メソッドの realm 引数と"
"して ``None`` を与えることで明示することができます。"

#: ../../howto/urllib2.rst:483
msgid ""
"The top-level URL is the first URL that requires authentication. URLs "
"\"deeper\" than the URL you pass to .add_password() will also match. ::"
msgstr ""
"トップレベルの URL が認証が必要なはじめに URL です。この URL よりも「深い」"
"URL を渡しても .add_password() は同様にマッチします。::"

#: ../../howto/urllib2.rst:486
msgid ""
"# create a password manager\n"
"password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()\n"
"\n"
"# Add the username and password.\n"
"# If we knew the realm, we could use it instead of None.\n"
"top_level_url = \"http://example.com/foo/\"\n"
"password_mgr.add_password(None, top_level_url, username, password)\n"
"\n"
"handler = urllib.request.HTTPBasicAuthHandler(password_mgr)\n"
"\n"
"# create \"opener\" (OpenerDirector instance)\n"
"opener = urllib.request.build_opener(handler)\n"
"\n"
"# use the opener to fetch a URL\n"
"opener.open(a_url)\n"
"\n"
"# Install the opener.\n"
"# Now all calls to urllib.request.urlopen use our opener.\n"
"urllib.request.install_opener(opener)"
msgstr ""

#: ../../howto/urllib2.rst:508
msgid ""
"In the above example we only supplied our ``HTTPBasicAuthHandler`` to "
"``build_opener``. By default openers have the handlers for normal situations "
"-- ``ProxyHandler`` (if a proxy setting such as an :envvar:`!http_proxy` "
"environment variable is set), ``UnknownHandler``, ``HTTPHandler``, "
"``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, ``FTPHandler``, "
"``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."
msgstr ""

#: ../../howto/urllib2.rst:515
msgid ""
"``top_level_url`` is in fact *either* a full URL (including the 'http:' "
"scheme component and the hostname and optionally the port number) e.g. "
"``\"http://example.com/\"`` *or* an \"authority\" (i.e. the hostname, "
"optionally including the port number) e.g. ``\"example.com\"`` or "
"``\"example.com:8080\"`` (the latter example includes a port number).  The "
"authority, if present, must NOT contain the \"userinfo\" component - for "
"example ``\"joe:password@example.com\"`` is not correct."
msgstr ""
"``top_level_url`` は実際には \"http://example.com/\" のような完全な URL "
"('http:' スキームとホスト名、オプションとしてポート番号、含む)  *あるいは* "
"\"example.com\" や \"example.com:8080\" (後者はポート番号を含む) のような "
"\"authority\" (つまり、ホスト名とオプションとしてポート番号を含む) の *どちら"
"でも* かまいません。authority の場合には \"userinfo\" 要素は含んではいけませ"
"ん - 例えば \"joe:password@example.com\" は不適切です。"

#: ../../howto/urllib2.rst:525
msgid "Proxies"
msgstr "プロキシ"

#: ../../howto/urllib2.rst:527
msgid ""
"**urllib** will auto-detect your proxy settings and use those. This is "
"through the ``ProxyHandler``, which is part of the normal handler chain when "
"a proxy setting is detected.  Normally that's a good thing, but there are "
"occasions when it may not be helpful [#]_. One way to do this is to setup "
"our own ``ProxyHandler``, with no proxies defined. This is done using "
"similar steps to setting up a `Basic Authentication`_ handler: ::"
msgstr ""
"**urllib** は自動でプロキシ設定を認識して使います。これは通常の handler の組"
"に含まれる ``ProxyHandler`` を通して行なわれます。たいていの場合はこれでうま"
"くいきますが、役に立たない場合もあります [#]_。この問題に対処する一つの方法は"
"プロキシを定義しない ``ProxyHandler`` を組み立てることです。この方法は "
"`Basic Authentication`_ handler を設定したときと同じような流れで行うことがで"
"きます: ::"

#: ../../howto/urllib2.rst:534
msgid ""
">>> proxy_support = urllib.request.ProxyHandler({})\n"
">>> opener = urllib.request.build_opener(proxy_support)\n"
">>> urllib.request.install_opener(opener)"
msgstr ""

#: ../../howto/urllib2.rst:540
msgid ""
"Currently ``urllib.request`` *does not* support fetching of ``https`` "
"locations through a proxy.  However, this can be enabled by extending urllib."
"request as shown in the recipe [#]_."
msgstr ""
"現在 ``urllib.request`` はプロキシ経由で ``https`` ロケーションを取得する機能"
"をサポートしていません。しかし、urllib.request をこのレシピ [#]_ で拡張するこ"
"とで可能にすることができます。"

#: ../../howto/urllib2.rst:546
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"変数 ``REQUEST_METHOD`` が設定されている場合、 ``HTTP_PROXY`` は無視されま"
"す; :func:`~urllib.request.getproxies` のドキュメンテーションを参照してくださ"
"い。"

#: ../../howto/urllib2.rst:551
msgid "Sockets and Layers"
msgstr "ソケットとレイヤー"

#: ../../howto/urllib2.rst:553
msgid ""
"The Python support for fetching resources from the web is layered.  urllib "
"uses the :mod:`http.client` library, which in turn uses the socket library."
msgstr ""
"Web 上からリソースを取得する Python の機能はレイヤー化されています。urllib "
"は :mod:`http.client` ライブラリを利用していますが、そのライブラリはさらに "
"socket ライブラリを利用しています。"

#: ../../howto/urllib2.rst:556
msgid ""
"As of Python 2.3 you can specify how long a socket should wait for a "
"response before timing out. This can be useful in applications which have to "
"fetch web pages. By default the socket module has *no timeout* and can hang. "
"Currently, the socket timeout is not exposed at the http.client or urllib."
"request levels. However, you can set the default timeout globally for all "
"sockets using ::"
msgstr ""
"Python 2.3 ではレスポンスがタイムアウトするまでのソケットの待ち時間を指定する"
"ことができます。これは web ページを取得する場合に便利に使うことができます。"
"socket モジュールのデフォルトでは *タイムアウトが無く* ハングしてしまうかもし"
"れません。現在では socket のタイムアウトは http.client や urllib.request のレ"
"ベルからは隠蔽されていています。しかし、以下を利用することで全てのソケットに"
"対してグローバルにデフォルトタイムアウトを設定することができます ::"

#: ../../howto/urllib2.rst:562
msgid ""
"import socket\n"
"import urllib.request\n"
"\n"
"# timeout in seconds\n"
"timeout = 10\n"
"socket.setdefaulttimeout(timeout)\n"
"\n"
"# this call to urllib.request.urlopen now uses the default timeout\n"
"# we have set in the socket module\n"
"req = urllib.request.Request('http://www.voidspace.org.uk')\n"
"response = urllib.request.urlopen(req)"
msgstr ""

#: ../../howto/urllib2.rst:579
msgid "Footnotes"
msgstr "脚注"

#: ../../howto/urllib2.rst:581
msgid "This document was reviewed and revised by John Lee."
msgstr "このドキュメントは John Lee によって査読、改訂されました。"

#: ../../howto/urllib2.rst:583
msgid "Google for example."
msgstr "Google を例題にする。"

#: ../../howto/urllib2.rst:584
msgid ""
"Browser sniffing is a very bad practice for website design - building sites "
"using web standards is much more sensible. Unfortunately a lot of sites "
"still send different versions to different browsers."
msgstr ""
"ブラウザを検知すること (browser sniffing) は web サイトのデザインにおけるとて"
"も悪い習慣です - web 標準を利用する方が賢明でしょう。\n"
"不幸なことに未だに多くの web サイトが異なるブラウザに対して異なるバージョンを"
"返しています。"

#: ../../howto/urllib2.rst:587
msgid ""
"The user agent for MSIE 6 is *'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT "
"5.1; SV1; .NET CLR 1.1.4322)'*"
msgstr ""
"MSIE 6 のユーザエージェントは *'Mozilla/4.0 (compatible; MSIE 6.0; Windows "
"NT 5.1; SV1; .NET CLR 1.1.4322)'* です。"

#: ../../howto/urllib2.rst:589
msgid ""
"For details of more HTTP request headers, see `Quick Reference to HTTP "
"Headers`_."
msgstr ""
"HTTP リクエストヘッダの詳細については、 `Quick Reference to HTTP Headers`_ を"
"参照して下さい。"

#: ../../howto/urllib2.rst:591
msgid ""
"In my case I have to use a proxy to access the internet at work. If you "
"attempt to fetch *localhost* URLs through this proxy it blocks them. IE is "
"set to use the proxy, which urllib picks up on. In order to test scripts "
"with a localhost server, I have to prevent urllib from using the proxy."
msgstr ""
"私の場合は仕事中にインターネットにアクセスするにはプロキシを利用する必要があ"
"ります。*localhost* の URL に対してこのプロキシを経由してアクセスしようとすれ"
"ば、ブロックされます。IE を proxy を利用するように設定すれば、urllib はその情"
"報を利用します。localhost のサーバでスクリプトをテストしようとすると、urllib "
"がプロキシを利用するのを止めなければいけません。"

#: ../../howto/urllib2.rst:596
msgid ""
"urllib opener for SSL proxy (CONNECT method): `ASPN Cookbook Recipe <https://"
"code.activestate.com/recipes/456195-urrlib2-opener-for-ssl-proxy-connect-"
"method/>`_."
msgstr ""
