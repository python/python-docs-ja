# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2019
# mollinaca, 2020
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 16:02+0000\n"
"PO-Revision-Date: 2019-09-01 03:37+0000\n"
"Last-Translator: mollinaca, 2020\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/logging-cookbook.rst:5
msgid "Logging Cookbook"
msgstr "Logging クックブック"

#: ../../howto/logging-cookbook.rst:0
msgid "Author"
msgstr "著者"

#: ../../howto/logging-cookbook.rst:7
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../../howto/logging-cookbook.rst:9
msgid ""
"This page contains a number of recipes related to logging, which have been "
"found useful in the past."
msgstr ""
"このページでは、過去に見つかった logging に関するいくつかの便利なレシピを紹介"
"します。"

#: ../../howto/logging-cookbook.rst:15
msgid "Using logging in multiple modules"
msgstr "複数のモジュールで logging を使う"

#: ../../howto/logging-cookbook.rst:17
msgid ""
"Multiple calls to ``logging.getLogger('someLogger')`` return a reference to "
"the same logger object.  This is true not only within the same module, but "
"also across modules as long as it is in the same Python interpreter "
"process.  It is true for references to the same object; additionally, "
"application code can define and configure a parent logger in one module and "
"create (but not configure) a child logger in a separate module, and all "
"logger calls to the child will pass up to the parent.  Here is a main "
"module::"
msgstr ""
"``logging.getLogger('someLogger')`` の複数回の呼び出しは同じ logger への参照"
"を返します。これは同じ Python インタプリタプロセス上で動いている限り、一つの"
"モジュールの中からに限らず、モジュールをまたいでも当てはまります。同じオブ"
"ジェクトへの参照という点でも正しいです。さらに、一つのモジュールの中で親 "
"logger を定義して設定し、別のモジュールで子 logger を定義する (ただし設定はし"
"ない) ことが可能で、すべての子 logger への呼び出しは親にまで渡されます。まず"
"はメインのモジュールです::"

#: ../../howto/logging-cookbook.rst:55
msgid "Here is the auxiliary module::"
msgstr "そして補助モジュール (auxiliary module) がこちらです::"

#: ../../howto/logging-cookbook.rst:75
msgid "The output looks like this:"
msgstr "出力はこのようになります:"

#: ../../howto/logging-cookbook.rst:101
msgid "Logging from multiple threads"
msgstr "複数のスレッドからのロギング"

#: ../../howto/logging-cookbook.rst:103
msgid ""
"Logging from multiple threads requires no special effort. The following "
"example shows logging from the main (initial) thread and another thread::"
msgstr ""
"複数スレッドからのロギングでは特別に何かをする必要はありません。\n"
"次の例はmain (初期) スレッドとそれ以外のスレッドからのロギングの例です::"

#: ../../howto/logging-cookbook.rst:132
msgid "When run, the script should print something like the following:"
msgstr "実行すると、出力は以下のようになるはずです:"

#: ../../howto/logging-cookbook.rst:154
msgid ""
"This shows the logging output interspersed as one might expect. This "
"approach works for more threads than shown here, of course."
msgstr ""
"予想した通りかもしれませんが、ログ出力が散らばっているのが分かります。\n"
"もちろん、この手法はより多くのスレッドでも上手くいきます。"

#: ../../howto/logging-cookbook.rst:158
msgid "Multiple handlers and formatters"
msgstr "複数の handler と formatter"

#: ../../howto/logging-cookbook.rst:160
msgid ""
"Loggers are plain Python objects.  The :meth:`~Logger.addHandler` method has "
"no minimum or maximum quota for the number of handlers you may add.  "
"Sometimes it will be beneficial for an application to log all messages of "
"all severities to a text file while simultaneously logging errors or above "
"to the console.  To set this up, simply configure the appropriate handlers.  "
"The logging calls in the application code will remain unchanged.  Here is a "
"slight modification to the previous simple module-based configuration "
"example::"
msgstr ""
"logger は通常の Python オブジェクトです。 :meth:`~Logger.addHandler` メソッド"
"は追加されるハンドラの個数について最小値も最大値も定めていません。時にアプリ"
"ケーションがすべての深刻度のすべてのメッセージをテキストファイルに記録しつ"
"つ、同時にエラーやそれ以上のものをコンソールに出力することが役に立ちます。こ"
"れを実現する方法は、単に適切なハンドラを設定するだけです。アプリケーション"
"コードの中のログ記録の呼び出しは変更されずに残ります。少し前に取り上げた単純"
"なモジュール式の例を少し変えるとこうなります::"

#: ../../howto/logging-cookbook.rst:193
msgid ""
"Notice that the 'application' code does not care about multiple handlers.  "
"All that changed was the addition and configuration of a new handler named "
"*fh*."
msgstr ""
"'application' 部分のコードは複数の handler について何も気にしていないことに注"
"目してください。変更した箇所は新しい *fh* という名の handler を追加して設定し"
"たところがすべてです。"

#: ../../howto/logging-cookbook.rst:196
msgid ""
"The ability to create new handlers with higher- or lower-severity filters "
"can be very helpful when writing and testing an application.  Instead of "
"using many ``print`` statements for debugging, use ``logger.debug``: Unlike "
"the print statements, which you will have to delete or comment out later, "
"the logger.debug statements can remain intact in the source code and remain "
"dormant until you need them again.  At that time, the only change that needs "
"to happen is to modify the severity level of the logger and/or handler to "
"debug."
msgstr ""
"新しい handler を、異なる深刻度に対する filter と共に生成できることは、アプリ"
"ケーションを書いてテストを行うときとても助けになります。デバッグ用にたくさん"
"の ``print`` 文を使う代わりに ``logger.debug`` を使いましょう。あとで消したり"
"コメントアウトしたりしなければならない print 文と違って、logger.debug 命令は"
"ソースコードの中にそのまま残しておいて再び必要になるまで休眠させておけます。"
"その時必要になるのはただ logger および/または handler の深刻度の設定をいじる"
"ことだけです。"

#: ../../howto/logging-cookbook.rst:207
msgid "Logging to multiple destinations"
msgstr "複数の出力先にログを出力する"

#: ../../howto/logging-cookbook.rst:209
msgid ""
"Let's say you want to log to console and file with different message formats "
"and in differing circumstances. Say you want to log messages with levels of "
"DEBUG and higher to file, and those messages at level INFO and higher to the "
"console. Let's also assume that the file should contain timestamps, but the "
"console messages should not. Here's how you can achieve this::"
msgstr ""
"コンソールとファイルに、別々のメッセージ書式で、別々の状況に応じたログ出力を"
"行わせたいとしましょう。例えば DEBUG よりも高いレベルのメッセージはファイルに"
"記録し、INFO 以上のレベルのメッセージはコンソールに出力したいという場合です。"
"また、ファイルにはタイムスタンプを記録し、コンソールには出力しないとします。"
"以下のようにすれば、こうした挙動を実現できます::"

#: ../../howto/logging-cookbook.rst:247
msgid "When you run this, on the console you will see"
msgstr "これを実行すると、コンソールには以下のように出力されます。"

#: ../../howto/logging-cookbook.rst:256
msgid "and in the file you will see something like"
msgstr "そして、ファイルには以下のように出力されるはずです:"

#: ../../howto/logging-cookbook.rst:266
msgid ""
"As you can see, the DEBUG message only shows up in the file. The other "
"messages are sent to both destinations."
msgstr ""
"これを見て分かる通り、DEBUG メッセージはファイルだけに出力され、その他のメッ"
"セージは両方に出力されます。"

#: ../../howto/logging-cookbook.rst:269
msgid ""
"This example uses console and file handlers, but you can use any number and "
"combination of handlers you choose."
msgstr ""
"この例ではコンソールとファイルのハンドラだけを使っていますが、実際には任意の"
"数のハンドラや組み合わせを使えます。"

#: ../../howto/logging-cookbook.rst:274
msgid "Configuration server example"
msgstr "設定サーバの例"

#: ../../howto/logging-cookbook.rst:276
msgid "Here is an example of a module using the logging configuration server::"
msgstr "ログ記録設定サーバを使うモジュールの例です::"

#: ../../howto/logging-cookbook.rst:307
msgid ""
"And here is a script that takes a filename and sends that file to the "
"server, properly preceded with the binary-encoded length, as the new logging "
"configuration::"
msgstr ""
"そしてファイル名を受け取ってそのファイルをサーバに送るスクリプトですが、それ"
"に先だってバイナリエンコード長を新しいログ記録の設定として先に送っておきま"
"す::"

#: ../../howto/logging-cookbook.rst:330
msgid "Dealing with handlers that block"
msgstr "ブロックする handler を扱う"

#: ../../howto/logging-cookbook.rst:334
msgid ""
"Sometimes you have to get your logging handlers to do their work without "
"blocking the thread you're logging from. This is common in Web applications, "
"though of course it also occurs in other scenarios."
msgstr ""
"ときどき、logging を行っているスレッドをブロックせずに、handler が動くように"
"しないといけないときがあります。これは Web アプリケーションではよくあることで"
"すし、もちろん他のシナリオでも起きる話です。"

#: ../../howto/logging-cookbook.rst:338
msgid ""
"A common culprit which demonstrates sluggish behaviour is the :class:"
"`SMTPHandler`: sending emails can take a long time, for a number of reasons "
"outside the developer's control (for example, a poorly performing mail or "
"network infrastructure). But almost any network-based handler can block: "
"Even a :class:`SocketHandler` operation may do a DNS query under the hood "
"which is too slow (and this query can be deep in the socket library code, "
"below the Python layer, and outside your control)."
msgstr ""
"動作が鈍くなるときの元凶はたいてい、開発者のコントロール外にあるいくつもの理"
"由で (例えば、残念なパフォーマンスのメールやネットワークのインフラ) 、 :"
"class:`SMTPHandler`: が電子メールを送るのに時間がかかることです。しかし、ほと"
"んどのネットワークをまたぐ handler はブロックする可能性があります: :class:"
"`SocketHandler` による処理でさえ、裏で DNS への問い合わせというとても遅い処理"
"を行うことがあります (そしてこの問い合わせ処理は、 Python の層より下のあなた"
"の手の届かない、ソケットライブラリの深いところにある可能性もあります)。"

#: ../../howto/logging-cookbook.rst:346
msgid ""
"One solution is to use a two-part approach. For the first part, attach only "
"a :class:`QueueHandler` to those loggers which are accessed from performance-"
"critical threads. They simply write to their queue, which can be sized to a "
"large enough capacity or initialized with no upper bound to their size. The "
"write to the queue will typically be accepted quickly, though you will "
"probably need to catch the :exc:`queue.Full` exception as a precaution in "
"your code. If you are a library developer who has performance-critical "
"threads in their code, be sure to document this (together with a suggestion "
"to attach only ``QueueHandlers`` to your loggers) for the benefit of other "
"developers who will use your code."
msgstr ""
"解決策の1つは、2パートに分離したアプローチを用いることです。最初のパートは、"
"パフォーマンスが重要なスレッドからアクセスされる、 :class:`QueueHandler` だけ"
"をアタッチした logger です。この logger は単に、十分大きい、あるいは無制限の"
"容量を持ったキューに書き込むだけです。キューへの書き込みは通常すぐに完了しま"
"すが、念の為に :exc:`queue.Full` 例外をキャッチする必要があるかもしれません。"
"もしパフォーマンスクリティカルなスレッドを持つライブラリの開発者であるなら、"
"このことを (``QueueHandler`` だけをアタッチした logger についての言及を添え"
"て) ドキュメントに書いておきましょう。"

#: ../../howto/logging-cookbook.rst:357
msgid ""
"The second part of the solution is :class:`QueueListener`, which has been "
"designed as the counterpart to :class:`QueueHandler`.  A :class:"
"`QueueListener` is very simple: it's passed a queue and some handlers, and "
"it fires up an internal thread which listens to its queue for LogRecords "
"sent from ``QueueHandlers`` (or any other source of ``LogRecords``, for that "
"matter). The ``LogRecords`` are removed from the queue and passed to the "
"handlers for processing."
msgstr ""
"2つ目のパートは :class:`QueueHandler` の対向として作られた :class:"
"`QueueListener` です。 :class:`QueueListener` はとてもシンプルで、キューと "
"handler を渡され、内部で ``QueueHandler`` (もしくは他の ``LogRecord`` の出力"
"元) から送られた LogRecord をキューから受け取るスレッドを起動します。 "
"``LogRecord`` をキューから取り出して、 handler に渡して処理させます。"

#: ../../howto/logging-cookbook.rst:365
msgid ""
"The advantage of having a separate :class:`QueueListener` class is that you "
"can use the same instance to service multiple ``QueueHandlers``. This is "
"more resource-friendly than, say, having threaded versions of the existing "
"handler classes, which would eat up one thread per handler for no particular "
"benefit."
msgstr ""
"分離した :class:`QueueListener` クラスを持つメリットは、複数の "
"``QueueHandler`` に対して1つのインスタンスで logging できることです。既存の "
"handler のスレッド利用版を使って handler ごとにスレッドを持つよりはずっとリ"
"ソースにやさしくなります。"

#: ../../howto/logging-cookbook.rst:370
msgid "An example of using these two classes follows (imports omitted)::"
msgstr "この2つのクラスを利用する例です (import は省略)::"

#: ../../howto/logging-cookbook.rst:388
msgid "which, when run, will produce:"
msgstr "実行すると次のように出力します:"

#: ../../howto/logging-cookbook.rst:394
msgid ""
"Prior to Python 3.5, the :class:`QueueListener` always passed every message "
"received from the queue to every handler it was initialized with. (This was "
"because it was assumed that level filtering was all done on the other side, "
"where the queue is filled.) From 3.5 onwards, this behaviour can be changed "
"by passing a keyword argument ``respect_handler_level=True`` to the "
"listener's constructor. When this is done, the listener compares the level "
"of each message with the handler's level, and only passes a message to a "
"handler if it's appropriate to do so."
msgstr ""
"Python 3.5 以前は、 :class:`QueueListener` クラスは常にキューから受け取った"
"メッセージを、初期化元となっているそれぞれのハンドラーに受け渡していました。 "
"( というのも、レベルフィルターリングは別サイド、つまり、キューが満たされてい"
"る場所で処理されるということが想定されているからです) Python 3.5以降では、"
"キーワードとなる引数  ``respect_handler_level=True``  をリスナーのコントラク"
"ターに受け渡すことで、この挙動を変更することができるようになっています。これ"
"が行われると、各メッセージのレベルをハンドラーのレベルと比較して、そうするこ"
"とが適切な場合のみ、メッセージをハンドラーに渡します。"

#: ../../howto/logging-cookbook.rst:407
msgid "Sending and receiving logging events across a network"
msgstr "ネットワーク越しの logging イベントの送受信"

#: ../../howto/logging-cookbook.rst:409
msgid ""
"Let's say you want to send logging events across a network, and handle them "
"at the receiving end. A simple way of doing this is attaching a :class:"
"`SocketHandler` instance to the root logger at the sending end::"
msgstr ""
"ログイベントをネットワーク越しに送信し、受信端でそれを処理したいとしましょ"
"う。 :class:`SocketHandler` インスタンスを送信端の root logger にアタッチすれ"
"ば、簡単に実現できます::"

#: ../../howto/logging-cookbook.rst:437
msgid ""
"At the receiving end, you can set up a receiver using the :mod:"
"`socketserver` module. Here is a basic working example::"
msgstr ""
"受信端では :mod:`socketserver` モジュールを使って受信プログラムを作成しておき"
"ます。簡単な実用プログラムを以下に示します::"

#: ../../howto/logging-cookbook.rst:525
msgid ""
"First run the server, and then the client. On the client side, nothing is "
"printed on the console; on the server side, you should see something like:"
msgstr ""
"先にサーバを起動しておき、次にクライアントを起動します。クライアント側では、"
"コンソールには何も出力されません; サーバ側では以下のようなメッセージを目にす"
"るはずです::"

#: ../../howto/logging-cookbook.rst:537
msgid ""
"Note that there are some security issues with pickle in some scenarios. If "
"these affect you, you can use an alternative serialization scheme by "
"overriding the :meth:`~handlers.SocketHandler.makePickle` method and "
"implementing your alternative there, as well as adapting the above script to "
"use your alternative serialization."
msgstr ""
"特定のシナリオでは pickle にはいくつかのセキュリティ上の問題があることに注意"
"してください。これが問題になる場合、 :meth:`~handlers.SocketHandler."
"makePickle` メソッドをオーバーライドして代替手段を実装することで異なるシリア"
"ライズ手法を使用できます。代替シリアライズ手法を使うように上記のスクリプトを"
"修正することもできます。"

#: ../../howto/logging-cookbook.rst:547
msgid "Adding contextual information to your logging output"
msgstr "コンテキスト情報をログ記録出力に付加する"

#: ../../howto/logging-cookbook.rst:549
msgid ""
"Sometimes you want logging output to contain contextual information in "
"addition to the parameters passed to the logging call. For example, in a "
"networked application, it may be desirable to log client-specific "
"information in the log (e.g. remote client's username, or IP address). "
"Although you could use the *extra* parameter to achieve this, it's not "
"always convenient to pass the information in this way. While it might be "
"tempting to create :class:`Logger` instances on a per-connection basis, this "
"is not a good idea because these instances are not garbage collected. While "
"this is not a problem in practice, when the number of :class:`Logger` "
"instances is dependent on the level of granularity you want to use in "
"logging an application, it could be hard to manage if the number of :class:"
"`Logger` instances becomes effectively unbounded."
msgstr ""
"時にはログ記録出力にログ関数の呼び出し時に渡されたパラメータに加えてコンテキ"
"スト情報を含めたいこともあるでしょう。たとえば、ネットワークアプリケーション"
"で、クライアント固有の情報 (例: リモートクライアントの名前、 IP アドレス) も"
"ログ記録に残しておきたいと思ったとしましょう。 *extra* パラメータをこの目的に"
"使うこともできますが、いつでもこの方法で情報を渡すのが便利なやり方とも限りま"
"せん。また接続ごとに :class:`Logger` インスタンスを生成する誘惑に駆られるかも"
"しれませんが、生成した :class:`Logger` インスタンスはガーベジコレクションで回"
"収されないので、これは良いアイデアとは言えません。この例は現実的な問題ではな"
"いかもしれませんが、 :class:`Logger` インスタンスの個数がアプリケーションの中"
"でログ記録が行われるレベルの粒度に依存する場合、 :class:`Logger` インスタンス"
"の個数が事実上無制限にならないと、管理が難しくなります。"

#: ../../howto/logging-cookbook.rst:564
msgid "Using LoggerAdapters to impart contextual information"
msgstr "LoggerAdapter を使ったコンテキスト情報の伝達"

#: ../../howto/logging-cookbook.rst:566
msgid ""
"An easy way in which you can pass contextual information to be output along "
"with logging event information is to use the :class:`LoggerAdapter` class. "
"This class is designed to look like a :class:`Logger`, so that you can call :"
"meth:`debug`, :meth:`info`, :meth:`warning`, :meth:`error`, :meth:"
"`exception`, :meth:`critical` and :meth:`log`. These methods have the same "
"signatures as their counterparts in :class:`Logger`, so you can use the two "
"types of instances interchangeably."
msgstr ""
"logging イベントの情報と一緒に出力されるコンテキスト情報を渡す簡単な方法"
"は、 :class:`LoggerAdapter` を使うことです。このクラスは :class:`Logger` のよ"
"うに見えるように設計されていて、 :meth:`debug`, :meth:`info`, :meth:"
"`warning`, :meth:`error`, :meth:`exception`, :meth:`critical`, :meth:`log` の"
"各メソッドを呼び出せるようになっています。これらのメソッドは対応する :class:"
"`Logger` のメソッドと同じ引数を取るので、二つの型を取り替えて使うことができま"
"す。"

#: ../../howto/logging-cookbook.rst:574
msgid ""
"When you create an instance of :class:`LoggerAdapter`, you pass it a :class:"
"`Logger` instance and a dict-like object which contains your contextual "
"information. When you call one of the logging methods on an instance of :"
"class:`LoggerAdapter`, it delegates the call to the underlying instance of :"
"class:`Logger` passed to its constructor, and arranges to pass the "
"contextual information in the delegated call. Here's a snippet from the code "
"of :class:`LoggerAdapter`::"
msgstr ""
":class:`LoggerAdapter` のインスタンスを生成する際には、 :class:`Logger` イン"
"スタンスとコンテキスト情報を収めた辞書風 (dict-like) のオブジェクトを渡しま"
"す。 :class:`LoggerAdapter` のログ記録メソッドを呼び出すと、呼び出しをコンス"
"トラクタに渡された配下の :class:`Logger` インスタンスに委譲し、その際コンテキ"
"スト情報をその委譲された呼び出しに埋め込みます。 :class:`LoggerAdapter` の"
"コードから少し抜き出してみます::"

#: ../../howto/logging-cookbook.rst:590
msgid ""
"The :meth:`~LoggerAdapter.process` method of :class:`LoggerAdapter` is where "
"the contextual information is added to the logging output. It's passed the "
"message and keyword arguments of the logging call, and it passes back "
"(potentially) modified versions of these to use in the call to the "
"underlying logger. The default implementation of this method leaves the "
"message alone, but inserts an 'extra' key in the keyword argument whose "
"value is the dict-like object passed to the constructor. Of course, if you "
"had passed an 'extra' keyword argument in the call to the adapter, it will "
"be silently overwritten."
msgstr ""
":class:`LoggerAdapter` の :meth:`~LoggerAdapter.process` メソッドがコンテキス"
"ト情報をログ出力に加える場所です。そこではログ記録呼び出しのメッセージとキー"
"ワード引数が渡され、加工された (可能性のある) それらの情報を配下のロガーへの"
"呼び出しに渡し直します。このメソッドのデフォルト実装ではメッセージは元のまま"
"ですが、キーワード引数にはコンストラクタに渡された辞書風オブジェクトを値とし"
"て \"extra\" キーが挿入されます。もちろん、呼び出し時に \"extra\" キーワード"
"を使った場合には何事もなかったかのように上書きされます。"

#: ../../howto/logging-cookbook.rst:599
msgid ""
"The advantage of using 'extra' is that the values in the dict-like object "
"are merged into the :class:`LogRecord` instance's __dict__, allowing you to "
"use customized strings with your :class:`Formatter` instances which know "
"about the keys of the dict-like object. If you need a different method, e.g. "
"if you want to prepend or append the contextual information to the message "
"string, you just need to subclass :class:`LoggerAdapter` and override :meth:"
"`~LoggerAdapter.process` to do what you need. Here is a simple example::"
msgstr ""
"\"extra\" を用いる利点は辞書風オブジェクトの中の値が :class:`LogRecord` イン"
"スタンスの __dict__ にマージされることで、辞書風オブジェクトのキーを知ってい"
"る :class:`Formatter` を用意して文字列をカスタマイズするようにできることで"
"す。それ以外のメソッドが必要なとき、たとえばコンテキスト情報をメッセージの前"
"や後ろにつなげたい場合には、 :class:`LoggerAdapter` から :meth:"
"`~LoggerAdapter.process` を望むようにオーバライドしたサブクラスを作ることが必"
"要なだけです。次に挙げるのはこのクラスを使った例で、コンストラクタで使われる"
"「辞書風」オブジェクトにどの振る舞いが必要なのかも示しています::"

#: ../../howto/logging-cookbook.rst:615
msgid "which you can use like this::"
msgstr "これを次のように使うことができます::"

#: ../../howto/logging-cookbook.rst:620
msgid ""
"Then any events that you log to the adapter will have the value of "
"``some_conn_id`` prepended to the log messages."
msgstr ""
"これで、この adapter 経由でログした全てのイベントに対して、``some_conn_id`` "
"の値がログメッセージの前に追加されます。"

#: ../../howto/logging-cookbook.rst:624
msgid "Using objects other than dicts to pass contextual information"
msgstr "コンテキスト情報を渡すために dict 以外のオブジェクトを使う"

#: ../../howto/logging-cookbook.rst:626
msgid ""
"You don't need to pass an actual dict to a :class:`LoggerAdapter` - you "
"could pass an instance of a class which implements ``__getitem__`` and "
"``__iter__`` so that it looks like a dict to logging. This would be useful "
"if you want to generate values dynamically (whereas the values in a dict "
"would be constant)."
msgstr ""
":class:`LoggerAdapter` に渡すのは本物の dict でなくても構いません。 "
"``__getitem__`` と ``__iter__`` を実装していて logging が辞書のように扱えるク"
"ラスのインスタンスを利用することができます。これは (dict の値が固定されるのに"
"対して) 値を動的に生成できるので便利です。"

#: ../../howto/logging-cookbook.rst:635
msgid "Using Filters to impart contextual information"
msgstr "Filter を使ったコンテキスト情報の伝達"

#: ../../howto/logging-cookbook.rst:637
msgid ""
"You can also add contextual information to log output using a user-defined :"
"class:`Filter`. ``Filter`` instances are allowed to modify the "
"``LogRecords`` passed to them, including adding additional attributes which "
"can then be output using a suitable format string, or if needed a custom :"
"class:`Formatter`."
msgstr ""
"ユーザ定義の :class:`Filter` を使ってログ出力にコンテキスト情報を加えることも"
"できます。 ``Filter`` インスタンスは、渡された ``LogRecords`` を修正すること"
"ができます。これにより、適切なフォーマット文字列や必要なら :class:"
"`Formatter` を使って、出力となる属性を新しく追加することも出来ます。"

#: ../../howto/logging-cookbook.rst:642
msgid ""
"For example in a web application, the request being processed (or at least, "
"the interesting parts of it) can be stored in a threadlocal (:class:"
"`threading.local`) variable, and then accessed from a ``Filter`` to add, "
"say, information from the request - say, the remote IP address and remote "
"user's username - to the ``LogRecord``, using the attribute names 'ip' and "
"'user' as in the ``LoggerAdapter`` example above. In that case, the same "
"format string can be used to get similar output to that shown above. Here's "
"an example script::"
msgstr ""
"例えば、web アプリケーションで、処理されるリクエスト (または、少なくともその"
"重要な部分) は、スレッドローカル (:class:`threading.local`) な変数に保存し"
"て、 ``Filter`` からアクセスすることで、 ``LogRecord`` にリクエストの情報を追"
"加できます。例えば、リモート IP アドレスやリモートユーザのユーザ名にアクセス"
"したいなら、上述の ``LoggerAdapter`` の例のように属性名 'ip' や 'user' を使う"
"といったようにです。その場合、同じフォーマット文字列を使って以下に示すように"
"似たような出力を得られます。これはスクリプトの例です::"

#: ../../howto/logging-cookbook.rst:688
msgid "which, when run, produces something like:"
msgstr "実行すると、以下のようになります:"

#: ../../howto/logging-cookbook.rst:709
msgid "Logging to a single file from multiple processes"
msgstr "複数のプロセスからの単一ファイルへのログ記録"

#: ../../howto/logging-cookbook.rst:711
msgid ""
"Although logging is thread-safe, and logging to a single file from multiple "
"threads in a single process *is* supported, logging to a single file from "
"*multiple processes* is *not* supported, because there is no standard way to "
"serialize access to a single file across multiple processes in Python. If "
"you need to log to a single file from multiple processes, one way of doing "
"this is to have all the processes log to a :class:`~handlers.SocketHandler`, "
"and have a separate process which implements a socket server which reads "
"from the socket and logs to file. (If you prefer, you can dedicate one "
"thread in one of the existing processes to perform this function.) :ref:"
"`This section <network-logging>` documents this approach in more detail and "
"includes a working socket receiver which can be used as a starting point for "
"you to adapt in your own applications."
msgstr ""
"ログ記録はスレッドセーフであり、単一プロセスの複数のスレッドからの単一ファイ"
"ルへのログ記録はサポート *されています* が、 *複数プロセス* からの単一ファイ"
"ルへのログ記録はサポート *されません* 。なぜなら、複数のプロセスをまたいで単"
"一のファイルへのアクセスを直列化する標準の方法が Python には存在しないからで"
"す。複数のプロセスから単一ファイルへログ記録しなければならないなら、最も良い"
"方法は、すべてのプロセスが :class:`~handlers.SocketHandler` に対してログ記録"
"を行い、独立したプロセスとしてソケットサーバを動かすことです。ソケットサーバ"
"はソケットから読み取ってファイルにログを書き出します。 (この機能を実行するた"
"めに、既存のプロセスの 1 つのスレッドを割り当てることもできます) :ref:`この"
"節 <network-logging>` では、このアプローチをさらに詳細に文書化しています。動"
"作するソケット受信プログラムが含まれているので、アプリケーションに組み込むた"
"めの出発点として使用できるでしょう。"

#: ../../howto/logging-cookbook.rst:724
msgid ""
"If you are using a recent version of Python which includes the :mod:"
"`multiprocessing` module, you could write your own handler which uses the :"
"class:`~multiprocessing.Lock` class from this module to serialize access to "
"the file from your processes. The existing :class:`FileHandler` and "
"subclasses do not make use of :mod:`multiprocessing` at present, though they "
"may do so in the future. Note that at present, the :mod:`multiprocessing` "
"module does not provide working lock functionality on all platforms (see "
"https://bugs.python.org/issue3770)."
msgstr ""
":mod:`multiprocessing` モジュールを含む最近のバージョンの Python を使用してい"
"るなら、複数のプロセスからファイルへのアクセスを直列化するために :class:"
"`~multiprocessing.Lock` クラスを使って独自のハンドラを書くことができます。既"
"存の :class:`FileHandler` とそのサブクラスは現在のところ :mod:"
"`multiprocessing` を利用していませんが、将来は利用するようになるかもしれませ"
"ん。現在のところ :mod:`multiprocessing` モジュールが提供するロック機能はすべ"
"てのプラットホームで動作するわけではないことに注意してください (https://bugs."
"python.org/issue3770 参照)。"

#: ../../howto/logging-cookbook.rst:735
msgid ""
"Alternatively, you can use a ``Queue`` and a :class:`QueueHandler` to send "
"all logging events to one of the processes in your multi-process "
"application. The following example script demonstrates how you can do this; "
"in the example a separate listener process listens for events sent by other "
"processes and logs them according to its own logging configuration. Although "
"the example only demonstrates one way of doing it (for example, you may want "
"to use a listener thread rather than a separate listener process -- the "
"implementation would be analogous) it does allow for completely different "
"logging configurations for the listener and the other processes in your "
"application, and can be used as the basis for code meeting your own specific "
"requirements::"
msgstr ""
"別の方法として、 ``Queue`` と :class:`QueueHandler` を使って、マルチプロセス"
"アプリケーションの1つのプロセスに全ての logging イベントを送る事ができます。"
"次の例はこれを行う方法を示します。この例では独立した listener プロセスが他の"
"プロセスから送られた event を受け取り、それを独自の logging 設定にしたがって"
"保存します。この例は実装の方法の1つを示しているだけ (例えば、 listener プロセ"
"スを分離する代わりに listener スレッドを使うこともできます) ですが、これは "
"listener とアプリケーション内の他のプロセスで完全に異なる設定を使う例になって"
"いるので、各自の要求に応じたコードを書く叩き台になるでしょう::"

#: ../../howto/logging-cookbook.rst:851
msgid ""
"A variant of the above script keeps the logging in the main process, in a "
"separate thread::"
msgstr "上のスクリプトの亜種で、logging をメインプロセスの別スレッドで行う例::"

#: ../../howto/logging-cookbook.rst:946
msgid ""
"This variant shows how you can e.g. apply configuration for particular "
"loggers - e.g. the ``foo`` logger has a special handler which stores all "
"events in the ``foo`` subsystem in a file ``mplog-foo.log``. This will be "
"used by the logging machinery in the main process (even though the logging "
"events are generated in the worker processes) to direct the messages to the "
"appropriate destinations."
msgstr ""
"こちらは特定の logger に設定を適用する例になっています。``foo`` logger は "
"``foo`` サブシステムの中の全てのイベントを ``mplog-foo.log`` に保存する特別"
"な handler を持っています。これはメインプロセス側の log 処理で使われ、"
"(logging イベントは worker プロセス側で生成されますが) 各メッセージを適切な出"
"力先に出力します。"

#: ../../howto/logging-cookbook.rst:953
msgid "Using concurrent.futures.ProcessPoolExecutor"
msgstr ""

#: ../../howto/logging-cookbook.rst:955
msgid ""
"If you want to use :class:`concurrent.futures.ProcessPoolExecutor` to start "
"your worker processes, you need to create the queue slightly differently. "
"Instead of"
msgstr ""

#: ../../howto/logging-cookbook.rst:963
msgid "you should use"
msgstr ""

#: ../../howto/logging-cookbook.rst:969
msgid "and you can then replace the worker creation from this::"
msgstr ""

#: ../../howto/logging-cookbook.rst:980
msgid "to this (remembering to first import :mod:`concurrent.futures`)::"
msgstr ""

#: ../../howto/logging-cookbook.rst:988
msgid "Using file rotation"
msgstr "ファイルをローテートする"

#: ../../howto/logging-cookbook.rst:993
msgid ""
"Sometimes you want to let a log file grow to a certain size, then open a new "
"file and log to that. You may want to keep a certain number of these files, "
"and when that many files have been created, rotate the files so that the "
"number of files and the size of the files both remain bounded. For this "
"usage pattern, the logging package provides a :class:`~handlers."
"RotatingFileHandler`::"
msgstr ""
"ログファイルがある大きさに達したら、新しいファイルを開いてそこにログを取りた"
"いことがあります。そのファイルをある数だけ残し、その数のファイルが生成された"
"らファイルを循環し、ファイルの数も大きさも制限したいこともあるでしょう。この"
"利用パターンのために、logging パッケージは :class:`~handlers."
"RotatingFileHandler` を提供しています::"

#: ../../howto/logging-cookbook.rst:1025
msgid ""
"The result should be 6 separate files, each with part of the log history for "
"the application:"
msgstr ""

#: ../../howto/logging-cookbook.rst:1037
msgid ""
"The most current file is always :file:`logging_rotatingfile_example.out`, "
"and each time it reaches the size limit it is renamed with the suffix "
"``.1``. Each of the existing backup files is renamed to increment the suffix "
"(``.1`` becomes ``.2``, etc.)  and the ``.6`` file is erased."
msgstr ""
"最新のファイルはいつでも :file:`logging_rotatingfile_example.out` で、サイズ"
"の上限に達するたびに拡張子 ``.1`` を付けた名前に改名されます。既にあるバック"
"アップファイルはその拡張子がインクリメントされ (``.1`` が ``.2`` になるな"
"ど)、 ``.6`` ファイルは消去されます。"

#: ../../howto/logging-cookbook.rst:1042
msgid ""
"Obviously this example sets the log length much too small as an extreme "
"example.  You would want to set *maxBytes* to an appropriate value."
msgstr ""
"明らかに、ここでは極端な例示のためにファイルの大きさをかなり小さな値に設定し"
"ています。実際に使うときは *maxBytes* を適切な値に設定してください。"

#: ../../howto/logging-cookbook.rst:1048
msgid "Use of alternative formatting styles"
msgstr "別の format スタイルを利用する"

#: ../../howto/logging-cookbook.rst:1050
msgid ""
"When logging was added to the Python standard library, the only way of "
"formatting messages with variable content was to use the %-formatting "
"method. Since then, Python has gained two new formatting approaches: :class:"
"`string.Template` (added in Python 2.4) and :meth:`str.format` (added in "
"Python 2.6)."
msgstr ""
"logging が Python 標準ライブラリに追加された時、メッセージを動的な内容で"
"フォーマットする唯一の方法は % を使ったフォーマットでした。その後、 Python に"
"は新しい文字列フォーマット機構として :class:`string.Template` (Python 2.4 で"
"追加) と :meth:`str.format` (Python 2.6 で追加) が加わりました。"

#: ../../howto/logging-cookbook.rst:1056
msgid ""
"Logging (as of 3.2) provides improved support for these two additional "
"formatting styles. The :class:`Formatter` class been enhanced to take an "
"additional, optional keyword parameter named ``style``. This defaults to "
"``'%'``, but other possible values are ``'{'`` and ``'$'``, which correspond "
"to the other two formatting styles. Backwards compatibility is maintained by "
"default (as you would expect), but by explicitly specifying a style "
"parameter, you get the ability to specify format strings which work with :"
"meth:`str.format` or :class:`string.Template`. Here's an example console "
"session to show the possibilities:"
msgstr ""
"logging は (3.2 から) この2つの追加されたフォーマット方法をサポートしていま"
"す。 :class:`Formatter` クラスが ``style`` という名前のオプションのキーワード"
"引数を受け取ります。このデフォルト値は ``'%'`` ですが、他に ``'{'`` と "
"``'$'`` が指定可能で、それぞれのフォーマット方法に対応しています。後方互換性"
"はデフォルト値によって維持されていますが、明示的に style 引数を指定すること"
"で、 :meth:`str.format` か :class:`string.Template` を使った format を指定す"
"る事ができます。次の例はこの機能を使ってみています:"

#: ../../howto/logging-cookbook.rst:1090
msgid ""
"Note that the formatting of logging messages for final output to logs is "
"completely independent of how an individual logging message is constructed. "
"That can still use %-formatting, as shown here::"
msgstr ""
"最終的に出力されるログメッセージの format と、各メッセージを生成する部分は完"
"全に独立していることに注意してください。次の例でわかるように、メッセージを生"
"成する部分では % を使い続けています::"

#: ../../howto/logging-cookbook.rst:1098
msgid ""
"Logging calls (``logger.debug()``, ``logger.info()`` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the actual "
"logging call (e.g. the ``exc_info`` keyword parameter to indicate that "
"traceback information should be logged, or the ``extra`` keyword parameter "
"to indicate additional contextual information to be added to the log). So "
"you cannot directly make logging calls using :meth:`str.format` or :class:"
"`string.Template` syntax, because internally the logging package uses %-"
"formatting to merge the format string and the variable arguments. There "
"would be no changing this while preserving backward compatibility, since all "
"logging calls which are out there in existing code will be using %-format "
"strings."
msgstr ""

#: ../../howto/logging-cookbook.rst:1111
msgid ""
"There is, however, a way that you can use {}- and $- formatting to construct "
"your individual log messages. Recall that for a message you can use an "
"arbitrary object as a message format string, and that the logging package "
"will call ``str()`` on that object to get the actual format string. Consider "
"the following two classes::"
msgstr ""
"しかし、{} や $ を使ってログメッセージをフォーマットする方法はあります。ログ"
"メッセージには任意のオブジェクトを format 文字列として渡すことができ、"
"logging パッケージはそのオブジェクトに対して ``str()`` を使って実際の format "
"文字列を生成します。次の2つのクラスを見てください::"

#: ../../howto/logging-cookbook.rst:1135
msgid ""
"Either of these can be used in place of a format string, to allow {}- or $-"
"formatting to be used to build the actual \"message\" part which appears in "
"the formatted log output in place of \"%(message)s\" or \"{message}\" or "
"\"$message\". It's a little unwieldy to use the class names whenever you "
"want to log something, but it's quite palatable if you use an alias such as "
"__ (double underscore --- not to be confused with _, the single underscore "
"used as a synonym/alias for :func:`gettext.gettext` or its brethren)."
msgstr ""
"どちらのクラスも format 文字列の代わりに利用して、 {} や $ を使って実際のログ"
"の \"%(message)s\", \"{message}\", \"$message\" で指定された \"message\" 部分"
"を生成することができます。これは何かログを取りたいときに常に使うには使いにく"
"いクラス名ですが、 __ (アンダースコア2つ --- :func:`gettext.gettext` やその仲"
"間によくエイリアスとして使われるアンダースコア1つと混同しないように) などの使"
"いやすいエイリアスを使うことができます。"

#: ../../howto/logging-cookbook.rst:1143
msgid ""
"The above classes are not included in Python, though they're easy enough to "
"copy and paste into your own code. They can be used as follows (assuming "
"that they're declared in a module called ``wherever``):"
msgstr ""
"上のクラスは Python には含まれませんが、自分のコードにコピペして使うのは簡単"
"です。これらは次の例のようにして利用できます。(上のクラスが ``wherever`` とい"
"うモジュールで定義されていると仮定します):"

#: ../../howto/logging-cookbook.rst:1165
msgid ""
"While the above examples use ``print()`` to show how the formatting works, "
"you would of course use ``logger.debug()`` or similar to actually log using "
"this approach."
msgstr ""
"上の例ではフォーマットの動作を示すために ``print()`` を使っていますが、もちろ"
"ん実際にこの方法でログを出力するには ``logger.debug()`` などを使います。"

#: ../../howto/logging-cookbook.rst:1169
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to "
"a log by a handler. So the only slightly unusual thing which might trip you "
"up is that the parentheses go around the format string and the arguments, "
"not just the format string. That's because the __ notation is just syntax "
"sugar for a constructor call to one of the XXXMessage classes."
msgstr ""
"注意点として、この方法には大きなパフォーマンスのペナルティはありません。実際"
"のフォーマット操作は logging の呼び出し時ではなくて、メッセージが実際に "
"handler によって出力されるときに起こります。(出力されないならフォーマットもさ"
"れません) そのため、この方法で注意しないといけないのは、追加の括弧がフォー"
"マット文字列だけではなく引数も囲わないといけないことだけです。これは __ が "
"XXXMessage クラスのコンストラクタ呼び出しのシンタックスシュガーでしか無いから"
"です。"

#: ../../howto/logging-cookbook.rst:1177
msgid ""
"If you prefer, you can use a :class:`LoggerAdapter` to achieve a similar "
"effect to the above, as in the following example::"
msgstr ""
"次の例のように、 :class:`LoggerAdapter` を利用して上と似たような効果を実現す"
"る方法もあります::"

#: ../../howto/logging-cookbook.rst:1208
msgid ""
"The above script should log the message ``Hello, world!`` when run with "
"Python 3.2 or later."
msgstr ""
"上のスクリプトは Python 3.2 以降では ``Hello, world!`` というメッセージをログ"
"するはずです。"

#: ../../howto/logging-cookbook.rst:1217
msgid "Customizing ``LogRecord``"
msgstr "``LogRecord`` のカスタマイズ"

#: ../../howto/logging-cookbook.rst:1219
msgid ""
"Every logging event is represented by a :class:`LogRecord` instance. When an "
"event is logged and not filtered out by a logger's level, a :class:"
"`LogRecord` is created, populated with information about the event and then "
"passed to the handlers for that logger (and its ancestors, up to and "
"including the logger where further propagation up the hierarchy is "
"disabled). Before Python 3.2, there were only two places where this creation "
"was done:"
msgstr ""
"全ての logging イベントは :class:`LogRecord` のインスタンスとして表現されま"
"す。イベントのログが取られて logger のレベルでフィルタされなかった場合、イベ"
"ントの情報を含む :class:`LogRecord` が生成され、その logger (と、 propagate "
"が無効になるまでの上位 logger) の handler に渡されます。 Python 3.2 までは、"
"この生成が行われているのは2箇所だけでした:"

#: ../../howto/logging-cookbook.rst:1226
msgid ""
":meth:`Logger.makeRecord`, which is called in the normal process of logging "
"an event. This invoked :class:`LogRecord` directly to create an instance."
msgstr ""
":meth:`Logger.makeRecord`: 通常のイベント logging プロセスで呼ばれます。これ"
"は :class:`LogRecord` を直接読んでインスタンスを生成します。"

#: ../../howto/logging-cookbook.rst:1229
msgid ""
":func:`makeLogRecord`, which is called with a dictionary containing "
"attributes to be added to the LogRecord. This is typically invoked when a "
"suitable dictionary has been received over the network (e.g. in pickle form "
"via a :class:`~handlers.SocketHandler`, or in JSON form via an :class:"
"`~handlers.HTTPHandler`)."
msgstr ""
":func:`makeLogRecord`: LogRecord に追加される属性を含む辞書を渡して呼び出され"
"ます。これはネットワーク越しに (pickle 形式で :class:`~handlers."
"SocketHandler` 経由で、あるいは JSON 形式で :class:`~handlers.HTTPHandler` 経"
"由で) 辞書を受け取った場合などに利用されます。"

#: ../../howto/logging-cookbook.rst:1235
msgid ""
"This has usually meant that if you need to do anything special with a :class:"
"`LogRecord`, you've had to do one of the following."
msgstr ""
"そのために :class:`LogRecord` で何か特別なことをしたい場合は、次のどちらかを"
"しなければなりません。"

#: ../../howto/logging-cookbook.rst:1238
msgid ""
"Create your own :class:`Logger` subclass, which overrides :meth:`Logger."
"makeRecord`, and set it using :func:`~logging.setLoggerClass` before any "
"loggers that you care about are instantiated."
msgstr ""
":meth:`Logger.makeRecord` をオーバーライドした独自の :class:`Logger` のサブク"
"ラスを作り、利用したい logger のどれかがインスタンス化される前に、それを :"
"func:`~logging.setLoggerClass` を使って登録する。"

#: ../../howto/logging-cookbook.rst:1241
msgid ""
"Add a :class:`Filter` to a logger or handler, which does the necessary "
"special manipulation you need when its :meth:`~Filter.filter` method is "
"called."
msgstr ""
":meth:`~Filter.filter` メソッドで必要な特殊な処理を行う :class:`Filter` を "
"logger か handler に追加する。"

#: ../../howto/logging-cookbook.rst:1245
msgid ""
"The first approach would be a little unwieldy in the scenario where (say) "
"several different libraries wanted to do different things. Each would "
"attempt to set its own :class:`Logger` subclass, and the one which did this "
"last would win."
msgstr ""
"最初の方法は、複数の異なるライブラリが別々のことをしようとした場合にうまく行"
"きません。各ライブラリが独自の :class:`Logger` のサブクラスを登録しようとし"
"て、最後に登録されたライブラリが生き残ります。"

#: ../../howto/logging-cookbook.rst:1250
msgid ""
"The second approach works reasonably well for many cases, but does not allow "
"you to e.g. use a specialized subclass of :class:`LogRecord`. Library "
"developers can set a suitable filter on their loggers, but they would have "
"to remember to do this every time they introduced a new logger (which they "
"would do simply by adding new packages or modules and doing ::"
msgstr ""
"2つ目の方法はほとんどのケースでうまくいきますが、たとえば :class:`LogRecord` "
"を特殊化したサブクラスを使うことなどはできません。ライブラリの開発者は利用し"
"ている logger に適切な filter を設定できますが、新しい logger を作るたびに忘"
"れずに設定しないといけなくなります。 (新しいパッケージやモジュールを追加し、"
"モジュールレベルで次の式を実行することで、新しい logger が作られます) ::"

#: ../../howto/logging-cookbook.rst:1258
msgid ""
"at module level). It's probably one too many things to think about. "
"Developers could also add the filter to a :class:`~logging.NullHandler` "
"attached to their top-level logger, but this would not be invoked if an "
"application developer attached a handler to a lower-level library logger --- "
"so output from that handler would not reflect the intentions of the library "
"developer."
msgstr ""
"これでは考えることが余計に1つ増えてしまうでしょう。開発者は、最も高いレベルの"
"ロガーに取り付けられた :class:`~logging.NullHandler` に、フィルタを追加するこ"
"ともできますが、アプリケーション開発者が、より低いレベルに対するライブラリの"
"ロガーにハンドラを取り付けた場合、フィルタは呼び出されません --- 従って、その"
"ハンドラからの出力はライブラリ開発者の意図を反映したものにはなりません。"

#: ../../howto/logging-cookbook.rst:1264
msgid ""
"In Python 3.2 and later, :class:`~logging.LogRecord` creation is done "
"through a factory, which you can specify. The factory is just a callable you "
"can set with :func:`~logging.setLogRecordFactory`, and interrogate with :"
"func:`~logging.getLogRecordFactory`. The factory is invoked with the same "
"signature as the :class:`~logging.LogRecord` constructor, as :class:"
"`LogRecord` is the default setting for the factory."
msgstr ""
"Python 3.2 以降では、 :class:`~logging.LogRecord` の生成は、指定できるファク"
"トリ経由になります。ファクトリは callable で、 :func:`~logging."
"setLogRecordFactory` で登録でき、 :func:`~logging.getLogRecordFactory` で現在"
"のファクトリを取得できます。ファクトリは :class:`~logging.LogRecord` コンスト"
"ラクタと同じシグネチャで呼び出され、 :class:`LogRecord` がデフォルトのファク"
"トリとして設定されています。"

#: ../../howto/logging-cookbook.rst:1271
msgid ""
"This approach allows a custom factory to control all aspects of LogRecord "
"creation. For example, you could return a subclass, or just add some "
"additional attributes to the record once created, using a pattern similar to "
"this::"
msgstr ""
"このアプローチはカスタムのファクトリが LogRecord の生成のすべての面を制御でき"
"るようにしています。たとえば、サブクラスを返したり、次のようなパターンを使っ"
"て単に属性を追加することができます::"

#: ../../howto/logging-cookbook.rst:1284
msgid ""
"This pattern allows different libraries to chain factories together, and as "
"long as they don't overwrite each other's attributes or unintentionally "
"overwrite the attributes provided as standard, there should be no surprises. "
"However, it should be borne in mind that each link in the chain adds run-"
"time overhead to all logging operations, and the technique should only be "
"used when the use of a :class:`Filter` does not provide the desired result."
msgstr ""
"このアプローチでは複数の異なるライブラリがファクトリをチェインさせて、お互い"
"に同じ属性を上書きしたり、標準で提供されている属性を意図せず上書きしない限り"
"はうまくいきます。しかし、チェインのつながり全てが、全ての logging の操作に対"
"しての実行時のオーバーヘッドになることを念頭に置き、このテクニックは :class:"
"`Filter` を利用するだけでは望む結果が得られない場合にのみ使うべきです。"

#: ../../howto/logging-cookbook.rst:1295
msgid "Subclassing QueueHandler - a ZeroMQ example"
msgstr "QueueHandler を継承する - ZeroMQ を使う例"

#: ../../howto/logging-cookbook.rst:1297
msgid ""
"You can use a :class:`QueueHandler` subclass to send messages to other kinds "
"of queues, for example a ZeroMQ 'publish' socket. In the example below,the "
"socket is created separately and passed to the handler (as its 'queue')::"
msgstr ""
":class:`QueueHandler` のサブクラスを作ってメッセージを他のキュー、例えば "
"ZeroMQ の 'publish' ソケットに送信することができます。下の例では、ソケットを"
"別に作ってそれを handler に ('queue' として) 渡します::"

#: ../../howto/logging-cookbook.rst:1316
msgid ""
"Of course there are other ways of organizing this, for example passing in "
"the data needed by the handler to create the socket::"
msgstr ""
"もちろん同じことを別の設計でもできます。socket を作るのに必要な情報を "
"handler に渡す例です::"

#: ../../howto/logging-cookbook.rst:1334
msgid "Subclassing QueueListener - a ZeroMQ example"
msgstr "QueueListener のサブクラスを作る - ZeroMQ を使う例"

#: ../../howto/logging-cookbook.rst:1336
msgid ""
"You can also subclass :class:`QueueListener` to get messages from other "
"kinds of queues, for example a ZeroMQ 'subscribe' socket. Here's an example::"
msgstr ""
":class:`QueueListener` のサブクラスを作って、メッセージを他のキュー、例えば "
"ZeroMQ の 'subscribe' ソケットから取得する事もできます。サンプルです::"

#: ../../howto/logging-cookbook.rst:1355
msgid "Module :mod:`logging`"
msgstr ":mod:`logging` モジュール"

#: ../../howto/logging-cookbook.rst:1355
msgid "API reference for the logging module."
msgstr "logging モジュールの API リファレンス。"

#: ../../howto/logging-cookbook.rst:1358
msgid "Module :mod:`logging.config`"
msgstr ":mod:`logging.config` モジュール"

#: ../../howto/logging-cookbook.rst:1358
msgid "Configuration API for the logging module."
msgstr "logging モジュールの環境設定 API です。"

#: ../../howto/logging-cookbook.rst:1361
msgid "Module :mod:`logging.handlers`"
msgstr ":mod:`logging.handlers` モジュール"

#: ../../howto/logging-cookbook.rst:1361
msgid "Useful handlers included with the logging module."
msgstr "logging モジュールに含まれる、便利なハンドラです。"

#: ../../howto/logging-cookbook.rst:1363
msgid ":ref:`A basic logging tutorial <logging-basic-tutorial>`"
msgstr ":ref:`logging 基本チュートリアル <logging-basic-tutorial>`"

#: ../../howto/logging-cookbook.rst:1365
msgid ":ref:`A more advanced logging tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`logging 上級チュートリアル <logging-advanced-tutorial>`"

#: ../../howto/logging-cookbook.rst:1369
msgid "An example dictionary-based configuration"
msgstr "辞書ベースで構成する例"

#: ../../howto/logging-cookbook.rst:1371
msgid ""
"Below is an example of a logging configuration dictionary - it's taken from "
"the `documentation on the Django project <https://docs.djangoproject.com/"
"en/1.9/topics/logging/#configuring-logging>`_. This dictionary is passed to :"
"func:`~config.dictConfig` to put the configuration into effect::"
msgstr ""
"次の例は辞書を使った logging の構成です。この例は `Django プロジェクトのド"
"キュメント <https://docs.djangoproject.com/en/1.9/topics/logging/"
"#configuring-logging>`_ から持ってきました。この辞書を :func:`~config."
"dictConfig` に渡して設定を有効にします::"

#: ../../howto/logging-cookbook.rst:1427
msgid ""
"For more information about this configuration, you can see the `relevant "
"section <https://docs.djangoproject.com/en/1.9/topics/logging/#configuring-"
"logging>`_ of the Django documentation."
msgstr ""
"この構成方法についてのより詳しい情報は、 Django のドキュメントの `該当のセク"
"ション <https://docs.djangoproject.com/en/1.9/topics/logging/#configuring-"
"logging>`_ で見ることができます。"

#: ../../howto/logging-cookbook.rst:1434
msgid "Using a rotator and namer to customize log rotation processing"
msgstr "rotator と namer を使ってログローテートをカスタマイズする"

#: ../../howto/logging-cookbook.rst:1436
msgid ""
"An example of how you can define a namer and rotator is given in the "
"following snippet, which shows zlib-based compression of the log file::"
msgstr ""
"次の、ログファイルを zlib ベースの圧縮をするスニペットでは、namer と rotater "
"を定義する方法の例を提供してます::"

#: ../../howto/logging-cookbook.rst:1454
msgid ""
"These are not \"true\" .gz files, as they are bare compressed data, with no "
"\"container\" such as you’d find in an actual gzip file. This snippet is "
"just for illustration purposes."
msgstr ""
"これは本当の .gz ファイルではなく、実際の gzip ファイルが持っている \"コンテ"
"ナ\" がない生の圧縮データです。このスニペットはただの解説用です。"

#: ../../howto/logging-cookbook.rst:1459
msgid "A more elaborate multiprocessing example"
msgstr "より手の込んだ multiprocessing の例"

#: ../../howto/logging-cookbook.rst:1461
msgid ""
"The following working example shows how logging can be used with "
"multiprocessing using configuration files. The configurations are fairly "
"simple, but serve to illustrate how more complex ones could be implemented "
"in a real multiprocessing scenario."
msgstr ""
"次の実際に動作する例は、logging を multiprocessing と設定ファイルを使って利用"
"する方法を示しています。設定内容はかなりシンプルですが、より複雑な構成を実際"
"の multiprocessing を利用するシナリオで実装する方法を示しています。"

#: ../../howto/logging-cookbook.rst:1466
msgid ""
"In the example, the main process spawns a listener process and some worker "
"processes. Each of the main process, the listener and the workers have three "
"separate configurations (the workers all share the same configuration). We "
"can see logging in the main process, how the workers log to a QueueHandler "
"and how the listener implements a QueueListener and a more complex logging "
"configuration, and arranges to dispatch events received via the queue to the "
"handlers specified in the configuration. Note that these configurations are "
"purely illustrative, but you should be able to adapt this example to your "
"own scenario."
msgstr ""
"この例では、メインプロセスは listener プロセスといくつかのワーカープロセスを"
"起動します。メイン、listener、ワーカープロセスはそれぞれ分離した設定を持って"
"います (ワーカープロセス群は同じ設定を共有します)。この例から、メインプロセス"
"の logging, ワーカーが QueueHandler でログを送っているところ、listener が利用"
"する QueueListener の実装、複雑な設定、キューから受け取ったイベントを設定され"
"た handler に分配する部分を見ることができます。この設定は説明用のものですが、"
"この例を自分のシナリオに適応させることができるでしょう。"

#: ../../howto/logging-cookbook.rst:1476
msgid ""
"Here's the script - the docstrings and the comments hopefully explain how it "
"works::"
msgstr "これがそのスクリプトです。docstring とコメントで動作を説明しています::"

#: ../../howto/logging-cookbook.rst:1688
msgid "Inserting a BOM into messages sent to a SysLogHandler"
msgstr "SysLogHandler に送るメッセージに BOM を挿入する"

#: ../../howto/logging-cookbook.rst:1690
msgid ""
":rfc:`5424` requires that a Unicode message be sent to a syslog daemon as a "
"set of bytes which have the following structure: an optional pure-ASCII "
"component, followed by a UTF-8 Byte Order Mark (BOM), followed by Unicode "
"encoded using UTF-8. (See the :rfc:`relevant section of the specification "
"<5424#section-6>`.)"
msgstr ""

#: ../../howto/logging-cookbook.rst:1696
msgid ""
"In Python 3.1, code was added to :class:`~logging.handlers.SysLogHandler` to "
"insert a BOM into the message, but unfortunately, it was implemented "
"incorrectly, with the BOM appearing at the beginning of the message and "
"hence not allowing any pure-ASCII component to appear before it."
msgstr ""
"Python 3.1 で :class:`~logging.handlers.SysLogHandler` に、 message に BOM を"
"挿入するコードが追加されました。しかし、そのときの実装が悪くて、 message の先"
"頭に BOM をつけてしまうのでピュアASCII 部分をその前に書くことができませんでし"
"た。"

#: ../../howto/logging-cookbook.rst:1702
msgid ""
"As this behaviour is broken, the incorrect BOM insertion code is being "
"removed from Python 3.2.4 and later. However, it is not being replaced, and "
"if you want to produce :rfc:`5424`-compliant messages which include a BOM, "
"an optional pure-ASCII sequence before it and arbitrary Unicode after it, "
"encoded using UTF-8, then you need to do the following:"
msgstr ""

#: ../../howto/logging-cookbook.rst:1708
msgid ""
"Attach a :class:`~logging.Formatter` instance to your :class:`~logging."
"handlers.SysLogHandler` instance, with a format string such as::"
msgstr ""
":class:`~logging.handlers.SysLogHandler` のインスタンスに、次のような format "
"文字列を持った :class:`~logging.Formatter` インスタンスをアタッチする::"

#: ../../howto/logging-cookbook.rst:1714
msgid ""
"The Unicode code point U+FEFF, when encoded using UTF-8, will be encoded as "
"a UTF-8 BOM -- the byte-string ``b'\\xef\\xbb\\xbf'``."
msgstr ""
"Unicode のコードポイント U+FEFF は、UTF-8 でエンコードすると BOM -- "
"``b'\\xef\\xbb\\xbf'`` -- になります。"

#: ../../howto/logging-cookbook.rst:1717
msgid ""
"Replace the ASCII section with whatever placeholders you like, but make sure "
"that the data that appears in there after substitution is always ASCII (that "
"way, it will remain unchanged after UTF-8 encoding)."
msgstr ""
"ASCII セクションを好きなプレースホルダに変更する。ただしその部分の置換結果が"
"常に ASCII になるように注意する(UTF-8 でエンコードされてもその部分が変化しな"
"いようにする)。"

#: ../../howto/logging-cookbook.rst:1721
msgid ""
"Replace the Unicode section with whatever placeholders you like; if the data "
"which appears there after substitution contains characters outside the ASCII "
"range, that's fine -- it will be encoded using UTF-8."
msgstr ""
"Unicode セクションを任意のプレースホルダに置き換える。この部分を置換したデー"
"タに ASCII 外の文字が含まれていても、それは単に UTF-8 でエンコードされるだけ"
"です。"

#: ../../howto/logging-cookbook.rst:1725
msgid ""
"The formatted message *will* be encoded using UTF-8 encoding by "
"``SysLogHandler``. If you follow the above rules, you should be able to "
"produce :rfc:`5424`-compliant messages. If you don't, logging may not "
"complain, but your messages will not be RFC 5424-compliant, and your syslog "
"daemon may complain."
msgstr ""

#: ../../howto/logging-cookbook.rst:1732
msgid "Implementing structured logging"
msgstr "構造化ログを実装する"

#: ../../howto/logging-cookbook.rst:1734
msgid ""
"Although most logging messages are intended for reading by humans, and thus "
"not readily machine-parseable, there might be circumstances where you want "
"to output messages in a structured format which *is* capable of being parsed "
"by a program (without needing complex regular expressions to parse the log "
"message). This is straightforward to achieve using the logging package. "
"There are a number of ways in which this could be achieved, but the "
"following is a simple approach which uses JSON to serialise the event in a "
"machine-parseable manner::"
msgstr ""
"多くのログメッセージは人間が読むために書かれるため、機械的に処理しにくくなっ"
"ていますが、場合によっては (複雑な正規表現を使ってログメッセージをパースしな"
"くても) プログラムがパース *できる* 構造化されたフォーマットでメッセージを出"
"力したい場合があります。\n"
"logging パッケージを使うと、これを簡単に実現できます。\n"
"実現する方法は幾つもありますが、次の例は JSON を使ってイベントを、機械でパー"
"スできる形にシリアライズする単純な方法です::"

#: ../../howto/logging-cookbook.rst:1758
msgid "If the above script is run, it prints:"
msgstr ""

#: ../../howto/logging-cookbook.rst:1764 ../../howto/logging-cookbook.rst:1813
msgid ""
"Note that the order of items might be different according to the version of "
"Python used."
msgstr "要素の順序は Python のバージョンによって異なることに注意してください。"

#: ../../howto/logging-cookbook.rst:1767
msgid ""
"If you need more specialised processing, you can use a custom JSON encoder, "
"as in the following complete example::"
msgstr ""
"より特殊な処理が必要な場合、次の例のように、カスタムの JSON エンコーダを作る"
"ことができます::"

#: ../../howto/logging-cookbook.rst:1807
msgid "When the above script is run, it prints:"
msgstr ""

#: ../../howto/logging-cookbook.rst:1822
msgid "Customizing handlers with :func:`dictConfig`"
msgstr "handler を :func:`dictConfig` を使ってカスタマイズする"

#: ../../howto/logging-cookbook.rst:1824
msgid ""
"There are times when you want to customize logging handlers in particular "
"ways, and if you use :func:`dictConfig` you may be able to do this without "
"subclassing. As an example, consider that you may want to set the ownership "
"of a log file. On POSIX, this is easily done using :func:`shutil.chown`, but "
"the file handlers in the stdlib don't offer built-in support. You can "
"customize handler creation using a plain function such as::"
msgstr ""
"logging handler に特定のカスタマイズを何度もしたい場合で、 :func:"
"`dictConfig` を使っているなら、サブクラスを作らなくてもカスタマイズが可能で"
"す。例えば、ログファイルの owner を設定したいとします。これは POSIX 環境で"
"は :func:`shutil.chown` を使って簡単に実現できますが、標準ライブラリの file "
"handler はこの機能を組み込みでサポートしていません。 handler の生成を通常の関"
"数を使ってカスタマイズすることができます::"

#: ../../howto/logging-cookbook.rst:1838
msgid ""
"You can then specify, in a logging configuration passed to :func:"
"`dictConfig`, that a logging handler be created by calling this function::"
msgstr ""
"そして、 :func:`dictConfig` に渡される構成設定の中で、この関数を使って "
"logging handler を生成するように指定することができます::"

#: ../../howto/logging-cookbook.rst:1871
msgid ""
"In this example I am setting the ownership using the ``pulse`` user and "
"group, just for the purposes of illustration. Putting it together into a "
"working script, ``chowntest.py``::"
msgstr ""
"この例は説明用のものですが、owner の user と group を ``pulse`` に設定してい"
"ます。これを動くスクリプトに ``chowntest.py`` に組み込んでみます::"

#: ../../howto/logging-cookbook.rst:1918
msgid "To run this, you will probably need to run as ``root``:"
msgstr "これを実行するには、 ``root`` 権限で実行する必要があるかもしれません:"

#: ../../howto/logging-cookbook.rst:1928
msgid ""
"Note that this example uses Python 3.3 because that's where :func:`shutil."
"chown` makes an appearance. This approach should work with any Python "
"version that supports :func:`dictConfig` - namely, Python 2.7, 3.2 or later. "
"With pre-3.3 versions, you would need to implement the actual ownership "
"change using e.g. :func:`os.chown`."
msgstr ""
":func:`shutil.chown` が追加されたのが Python 3.3 からなので、この例は Python "
"3.3 を使っています。このアプローチ自体は :func:`dictConfig` をサポートした全"
"ての Python バージョン - Python 2.7, 3.2 以降 - で利用できます。 3.3 以前の"
"バージョンでは、オーナーを変更するのに :func:`os.chown` を利用する必要がある"
"でしょう。"

#: ../../howto/logging-cookbook.rst:1934
msgid ""
"In practice, the handler-creating function may be in a utility module "
"somewhere in your project. Instead of the line in the configuration::"
msgstr ""
"実際には、handler を生成する関数はプロジェクト内のどこかにあるユーティリティ"
"モジュールに置くことになるでしょう。設定の中で直接関数を参照する代わりに::"

#: ../../howto/logging-cookbook.rst:1939
msgid "you could use e.g.::"
msgstr "次のように書くこともできます::"

#: ../../howto/logging-cookbook.rst:1943
msgid ""
"where ``project.util`` can be replaced with the actual name of the package "
"where the function resides. In the above working script, using ``'ext://"
"__main__.owned_file_handler'`` should work. Here, the actual callable is "
"resolved by :func:`dictConfig` from the ``ext://`` specification."
msgstr ""
"``project.util`` は関数がある実際の場所に置き換えてください。上のスクリプトで"
"は ``'ext://__main__.owned_file_handler'`` で動くはずです。 :func:"
"`dictConfig` は ``ext://`` から実際の callable を見つけます。"

#: ../../howto/logging-cookbook.rst:1948
msgid ""
"This example hopefully also points the way to how you could implement other "
"types of file change - e.g. setting specific POSIX permission bits - in the "
"same way, using :func:`os.chmod`."
msgstr ""
"この例は他のファイルに対する変更を実装する例にもなっています。例えば :func:"
"`os.chmod` を使って、同じ方法で POSIX パーミッションを設定できるでしょう。"

#: ../../howto/logging-cookbook.rst:1952
msgid ""
"Of course, the approach could also be extended to types of handler other "
"than a :class:`~logging.FileHandler` - for example, one of the rotating file "
"handlers, or a different type of handler altogether."
msgstr ""
"もちろん、このアプローチは :class:`~logging.FileHandler` 以外の handler 、"
"ローテートする file handler のいずれかやその他の handler にも適用できます。"

#: ../../howto/logging-cookbook.rst:1962
msgid "Using particular formatting styles throughout your application"
msgstr "固有の書式化スタイルをアプリケーション全体で使う"

#: ../../howto/logging-cookbook.rst:1964
msgid ""
"In Python 3.2, the :class:`~logging.Formatter` gained a ``style`` keyword "
"parameter which, while defaulting to ``%`` for backward compatibility, "
"allowed the specification of ``{`` or ``$`` to support the formatting "
"approaches supported by :meth:`str.format` and :class:`string.Template`. "
"Note that this governs the formatting of logging messages for final output "
"to logs, and is completely orthogonal to how an individual logging message "
"is constructed."
msgstr ""
"Python 3.2 では、:class:`~logging.Formatter` クラスが ``style`` という名前の"
"オプションのキーワード引数を受け取ります。このデフォルト値は後方互換性を維持"
"するために ``%`` となっていますが、 ``{`` か ``$``  を指定することで、:meth:"
"`str.format` か :class:`string.Template` でサポートされているのと同じ書式化の"
"アプローチを採れます。これは最終的に出力されるログメッセージの書式化に影響を"
"与えますが、個々のログメッセージが構築される方法とは完全に直交していることに"
"注意してください。"

#: ../../howto/logging-cookbook.rst:1971
msgid ""
"Logging calls (:meth:`~Logger.debug`, :meth:`~Logger.info` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the logging "
"call (e.g. the ``exc_info`` keyword parameter to indicate that traceback "
"information should be logged, or the ``extra`` keyword parameter to indicate "
"additional contextual information to be added to the log). So you cannot "
"directly make logging calls using :meth:`str.format` or :class:`string."
"Template` syntax, because internally the logging package uses %-formatting "
"to merge the format string and the variable arguments. There would no "
"changing this while preserving backward compatibility, since all logging "
"calls which are out there in existing code will be using %-format strings."
msgstr ""
"logging の呼び出し (:meth:`~Logger.debug`, :meth:`~Logger.info`  など) は、ロ"
"グメッセージのために位置引数しか受け取らず、キーワード引数はそれを処理すると"
"きのオプションを指定するためだけに使われます。 (例えば、 ``exc_info`` キー"
"ワード引数を使ってログを取るトレースバック情報を指定したり、 ``extra`` キー"
"ワード引数を使ってログに付与する追加のコンテキスト情報を指定します。)logging "
"パッケージは内部で % を使って format 文字列と引数をマージしているので、 :"
"meth:`str.format` や :class:`string.Template` を使って logging を呼び出す事は"
"できません。既存の logging 呼び出しは %-format を使っているので、後方互換性の"
"ためにこの部分を変更することはできません。"

#: ../../howto/logging-cookbook.rst:1983
msgid ""
"There have been suggestions to associate format styles with specific "
"loggers, but that approach also runs into backward compatibility problems "
"because any existing code could be using a given logger name and using %-"
"formatting."
msgstr ""
"特定のロガーに関連付ける書式スタイルへの提案がなされてきましたが、そのアプ"
"ローチは同時に後方互換性の問題にぶち当たります。あらゆる既存のコードはロガー"
"の名前を使っているでしょうし、 % 形式書式化を使っているでしょう。"

#: ../../howto/logging-cookbook.rst:1987
msgid ""
"For logging to work interoperably between any third-party libraries and your "
"code, decisions about formatting need to be made at the level of the "
"individual logging call. This opens up a couple of ways in which alternative "
"formatting styles can be accommodated."
msgstr ""
"あらゆるサードパーティのライブラリ、あらゆるあなたのコードの間で相互運用可能"
"なようにロギングを行うには、書式化についての決定は、個々のログ呼び出しのレベ"
"ルで行う必要があります。これは受け容れ可能な代替書式化スタイルに様々な手段の"
"可能性を広げます。"

#: ../../howto/logging-cookbook.rst:1994
msgid "Using LogRecord factories"
msgstr "LogRecord ファクトリを使う"

#: ../../howto/logging-cookbook.rst:1996
msgid ""
"In Python 3.2, along with the :class:`~logging.Formatter` changes mentioned "
"above, the logging package gained the ability to allow users to set their "
"own :class:`LogRecord` subclasses, using the :func:`setLogRecordFactory` "
"function. You can use this to set your own subclass of :class:`LogRecord`, "
"which does the Right Thing by overriding the :meth:`~LogRecord.getMessage` "
"method. The base class implementation of this method is where the ``msg % "
"args`` formatting happens, and where you can substitute your alternate "
"formatting; however, you should be careful to support all formatting styles "
"and allow %-formatting as the default, to ensure interoperability with other "
"code. Care should also be taken to call ``str(self.msg)``, just as the base "
"implementation does."
msgstr ""
"Python 3.2 において、上述した :class:`~logging.Formatter` の変更とともに、 :"
"func:`setLogRecordFactory` 関数を使って :class:`LogRecord` のサブクラスをユー"
"ザに指定することを可能にするロギングパッケージの機能拡張がありました。これに"
"より、 :meth:`~LogRecord.getMessage` をオーバライドして た　だ　し　い　こと"
"をする、あなた自身の手による :class:`LogRecord` のサブクラスをセットすること"
"が出来ます。このメソッドの実装は基底クラスでは ``msg % args`` 書式化をし、あ"
"なたの代替の書式化の置換が出来る場所ですが、他のコードとの相互運用性を保障す"
"るために、全ての書式化スタイルをサポートするよう注意深く行うべきであり、ま"
"た、%-書式化をデフォルトで認めるべきです。基底クラスの実装がそうしているよう"
"に、 ``str(self.msg)`` 呼び出しもしてください。"

#: ../../howto/logging-cookbook.rst:2007
msgid ""
"Refer to the reference documentation on :func:`setLogRecordFactory` and :"
"class:`LogRecord` for more information."
msgstr ""
"さらに詳しい情報は、リファレンスの :func:`setLogRecordFactory`, :class:"
"`LogRecord` を参照してください。"

#: ../../howto/logging-cookbook.rst:2012
msgid "Using custom message objects"
msgstr "カスタムなメッセージオブジェクトを使う"

#: ../../howto/logging-cookbook.rst:2014
msgid ""
"There is another, perhaps simpler way that you can use {}- and $- formatting "
"to construct your individual log messages. You may recall (from :ref:"
"`arbitrary-object-messages`) that when logging you can use an arbitrary "
"object as a message format string, and that the logging package will call :"
"func:`str` on that object to get the actual format string. Consider the "
"following two classes::"
msgstr ""
"あなた独自のログメッセージを構築するのに {}- および $- 書式化を使えるようにす"
"るための、もうひとつの、おそらくもっと簡単な方法があります。ロギングの際に"
"は、あなたはメッセージ書式文字列として、任意のオブジェクトを使えることを(:"
"ref:`arbitrary-object-messages` より)思い出してみましょう、そしてロギングパッ"
"ケージはそのオブジェクトに対して実際の書式文字列を得るために :func:`str` を呼"
"び出すことも。以下 2 つのクラスを検討してみましょう::"

#: ../../howto/logging-cookbook.rst:2039
msgid ""
"Either of these can be used in place of a format string, to allow {}- or $-"
"formatting to be used to build the actual \"message\" part which appears in "
"the formatted log output in place of “%(message)s” or “{message}” or "
"“$message”. If you find it a little unwieldy to use the class names whenever "
"you want to log something, you can make it more palatable if you use an "
"alias such as ``M`` or ``_`` for the message (or perhaps ``__``, if you are "
"using ``_`` for localization)."
msgstr ""
"どちらのクラスも format 文字列の代わりに利用して、 {} や $ を使って実際のログ"
"の “%(message)s”, “{message}”, “$message” で指定された \"message\" 部分を生成"
"することができます。これは何かログを取りたいときに常に使うには使いにくいクラ"
"ス名ですが、使いやすいようにエイリアスを作れば良いでしょう、 ``M`` であると"
"か ``_`` のような(あるいは地域化のために既に ``_`` を使っているのであれば "
"``__`` が良いかもしれません)。"

#: ../../howto/logging-cookbook.rst:2047
msgid ""
"Examples of this approach are given below. Firstly, formatting with :meth:"
"`str.format`::"
msgstr ""
"このアプローチによる例をお見せします。最初は :meth:`str.format` を使って"
"フォーマットする例です::"

#: ../../howto/logging-cookbook.rst:2061
msgid "Secondly, formatting with :class:`string.Template`::"
msgstr "2つめは :class:`string.Template` でフォーマットする例です::"

#: ../../howto/logging-cookbook.rst:2068
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to "
"a log by a handler. So the only slightly unusual thing which might trip you "
"up is that the parentheses go around the format string and the arguments, "
"not just the format string. That’s because the __ notation is just syntax "
"sugar for a constructor call to one of the ``XXXMessage`` classes shown "
"above."
msgstr ""
"ひとつ注目すべきは、この方法には大きなパフォーマンス上のペナルティはないこと"
"です。実際のフォーマット操作は logging の呼び出し時ではなくて、メッセージが実"
"際に(そして必要な場合のみ) handler によって出力されるときに起こります。ですの"
"で、この方法での唯一の些細な注意点は、追加の括弧がフォーマット文字列だけでは"
"なく引数も囲わないといけないこと、だけです。__ は上でお見せした通り "
"``XXXMessage`` クラスのコンストラクタ呼び出しのシンタックスシュガーに過ぎませ"
"ん。"

#: ../../howto/logging-cookbook.rst:2082
msgid "Configuring filters with :func:`dictConfig`"
msgstr "filter を :func:`dictConfig` を使ってカスタマイズする"

#: ../../howto/logging-cookbook.rst:2084
msgid ""
"You *can* configure filters using :func:`~logging.config.dictConfig`, though "
"it might not be obvious at first glance how to do it (hence this recipe). "
"Since :class:`~logging.Filter` is the only filter class included in the "
"standard library, and it is unlikely to cater to many requirements (it's "
"only there as a base class), you will typically need to define your own :"
"class:`~logging.Filter` subclass with an overridden :meth:`~logging.Filter."
"filter` method. To do this, specify the ``()`` key in the configuration "
"dictionary for the filter, specifying a callable which will be used to "
"create the filter (a class is the most obvious, but you can provide any "
"callable which returns a :class:`~logging.Filter` instance). Here is a "
"complete example::"
msgstr ""
":func:`~logging.config.dictConfig` によってフィルタを設定 *出来ます* が、どう"
"やってそれを行うのかが初見では明快とは言えないでしょう(そのためのこのレシピで"
"す)。 :class:`~logging.Filter` のみが唯一標準ライブラリに含まれているだけです"
"し、それは何の要求にも応えてはくれません(ただの基底クラスですから)ので、典型"
"的には :meth:`~logging.Filter.filter` メソッドをオーバライドした :class:"
"`~logging.Filter` のサブクラスをあなた自身で定義する必要があります。これをす"
"るには、設定辞書内のフィルタ指定部分に、 ``()`` キーでそのフィルタを作るのに"
"使われる callable を指定してください(クラスを指定するのが最もわかりやすいです"
"が、 :class:`~logging.Filter` インスタンスを返却する callable を提供すること"
"でも出来ます)。以下に完全な例を示します::"

#: ../../howto/logging-cookbook.rst:2137
msgid ""
"This example shows how you can pass configuration data to the callable which "
"constructs the instance, in the form of keyword parameters. When run, the "
"above script will print:"
msgstr ""

#: ../../howto/logging-cookbook.rst:2145
msgid "which shows that the filter is working as configured."
msgstr "設定した通りに動いていますね。"

#: ../../howto/logging-cookbook.rst:2147
msgid "A couple of extra points to note:"
msgstr "ほかにもいくつか特筆すべき点があります:"

#: ../../howto/logging-cookbook.rst:2149
msgid ""
"If you can't refer to the callable directly in the configuration (e.g. if it "
"lives in a different module, and you can't import it directly where the "
"configuration dictionary is), you can use the form ``ext://...`` as "
"described in :ref:`logging-config-dict-externalobj`. For example, you could "
"have used the text ``'ext://__main__.MyFilter'`` instead of ``MyFilter`` in "
"the above example."
msgstr ""
"設定内で直接その callable を参照出来ない場合(例えばそれが異なるモジュール内に"
"あり、設定辞書のある場所からそれを直接インポート出来ない、など)には、 :ref:"
"`logging-config-dict-externalobj` に記述されている ``ext://...`` 形式を使えま"
"す。例えば、上記例のように ``MyFilter`` と指定する代わりに、 ``'ext://"
"__main__.MyFilter'`` と記述することが出来ます。"

#: ../../howto/logging-cookbook.rst:2156
msgid ""
"As well as for filters, this technique can also be used to configure custom "
"handlers and formatters. See :ref:`logging-config-dict-userdef` for more "
"information on how logging supports using user-defined objects in its "
"configuration, and see the other cookbook recipe :ref:`custom-handlers` "
"above."
msgstr ""
"フィルタについてとともに、このテクニックは、カスタムハンドラ、カスタムフォー"
"マッタに対しても同様に使えます。ロギングが設定において、どのようにユーザ定義"
"のオブジェクトをサポートするのかについてのさらなる詳細については、 :ref:"
"`logging-config-dict-userdef` と、本クックブックの上の方のレシピ :ref:"
"`custom-handlers` を参照してください。"

#: ../../howto/logging-cookbook.rst:2165
msgid "Customized exception formatting"
msgstr "例外の書式化をカスタマイズする"

#: ../../howto/logging-cookbook.rst:2167
msgid ""
"There might be times when you want to do customized exception formatting - "
"for argument's sake, let's say you want exactly one line per logged event, "
"even when exception information is present. You can do this with a custom "
"formatter class, as shown in the following example::"
msgstr ""
"例外の書式化をカスタマイズしたいことがあるでしょう - わかりやすさのために、例"
"外情報がある場合でもログイベントごとに一行に収まることを死守したいと望むとし"
"ましょう。フォーマッタのクラスをカスタマイズして、このように出来ます::"

#: ../../howto/logging-cookbook.rst:2208
msgid "When run, this produces a file with exactly two lines:"
msgstr ""

#: ../../howto/logging-cookbook.rst:2215
msgid ""
"While the above treatment is simplistic, it points the way to how exception "
"information can be formatted to your liking. The :mod:`traceback` module may "
"be helpful for more specialized needs."
msgstr ""
"これは扱いとしては単純過ぎますが、例外情報をどのようにしてあなた好みの書式化"
"出来るかを示しています。さらに特殊なニーズが必要な場合には :mod:`traceback` "
"モジュールが有用です。"

#: ../../howto/logging-cookbook.rst:2222
msgid "Speaking logging messages"
msgstr "ロギングメッセージを喋る"

#: ../../howto/logging-cookbook.rst:2224
msgid ""
"There might be situations when it is desirable to have logging messages "
"rendered in an audible rather than a visible format. This is easy to do if "
"you have text-to-speech (TTS) functionality available in your system, even "
"if it doesn't have a Python binding. Most TTS systems have a command line "
"program you can run, and this can be invoked from a handler using :mod:"
"`subprocess`. It's assumed here that TTS command line programs won't expect "
"to interact with users or take a long time to complete, and that the "
"frequency of logged messages will be not so high as to swamp the user with "
"messages, and that it's acceptable to have the messages spoken one at a time "
"rather than concurrently, The example implementation below waits for one "
"message to be spoken before the next is processed, and this might cause "
"other handlers to be kept waiting. Here is a short example showing the "
"approach, which assumes that the ``espeak`` TTS package is available::"
msgstr ""
"ロギングメッセージを目で見る形式ではなく音で聴く形式として出力したい、という"
"状況があるかもしれません。これはあなたのシステムで text- to-speech (TTS) 機能"
"が利用可能であれば、容易です。それが Python バインディングを持っていなくと"
"も、です。ほとんどの TTS システムはあなたが実行出来るコマンドラインプログラム"
"を持っていて、このことで、 :mod:`subprocess` を使うことでハンドラが呼び出せま"
"す。ここでは、TTS コマンドラインプログラムはユーザとの対話を期待せず、完了に"
"は時間がかかり、そしてログメッセージの頻度はユーザをメッセージで圧倒してしま"
"うほどには高くはなく、そして並列で喋るよりはメッセージ一つにつき一回喋ること"
"が受け容れられる、としておきます。ここでお見せする実装例では、次が処理される"
"前に一つのメッセージを喋り終わるまで待ち、結果としてほかのハンドラを待たせる"
"ことになります。 ``espeak`` TTS パッケージが手許にあるとして、このアプローチ"
"による短い例はこのようなものです::"

#: ../../howto/logging-cookbook.rst:2266
msgid ""
"When run, this script should say \"Hello\" and then \"Goodbye\" in a female "
"voice."
msgstr "実行すれば、女性の声で \"Hello\" に続き \"Goodbye\" と喋るはずです。"

#: ../../howto/logging-cookbook.rst:2268
msgid ""
"The above approach can, of course, be adapted to other TTS systems and even "
"other systems altogether which can process messages via external programs "
"run from a command line."
msgstr ""
"このアプローチは、もちろんほかの TTS システムにも採用出来ますし、メッセージを"
"コマンドライン経由で外部プログラムに渡せるようなものであれば、ほかのシステム"
"であっても全く同じです。"

#: ../../howto/logging-cookbook.rst:2276
msgid "Buffering logging messages and outputting them conditionally"
msgstr "ロギングメッセージをバッファリングし、条件に従って出力する"

#: ../../howto/logging-cookbook.rst:2278
msgid ""
"There might be situations where you want to log messages in a temporary area "
"and only output them if a certain condition occurs. For example, you may "
"want to start logging debug events in a function, and if the function "
"completes without errors, you don't want to clutter the log with the "
"collected debug information, but if there is an error, you want all the "
"debug information to be output as well as the error."
msgstr ""
"メッセージを一次領域に記録し、ある種の特定の状況になった場合にだけ出力した"
"い、ということがあるかもしれません。たとえばある関数内でのデバッグのためのロ"
"グ出力をしたくても、エラーなしで終了する限りにおいては収集されたデバッグ情報"
"による混雑は喰らいたくはなく、エラーがあった場合にだけエラー出力とともにデ"
"バッグ情報を見たいのだ、のようなことがあるでしょう。"

#: ../../howto/logging-cookbook.rst:2285
msgid ""
"Here is an example which shows how you could do this using a decorator for "
"your functions where you want logging to behave this way. It makes use of "
"the :class:`logging.handlers.MemoryHandler`, which allows buffering of "
"logged events until some condition occurs, at which point the buffered "
"events are ``flushed`` - passed to another handler (the ``target`` handler) "
"for processing. By default, the ``MemoryHandler`` flushed when its buffer "
"gets filled up or an event whose level is greater than or equal to a "
"specified threshold is seen. You can use this recipe with a more specialised "
"subclass of ``MemoryHandler`` if you want custom flushing behavior."
msgstr ""
"このような振る舞いをするロギングをしたい関数に対して、デコレータを用いてこれ"
"を行う例をお見せします。それには :class:`logging.handlers.MemoryHandler` を使"
"います。これにより何か条件を満たすまでロギングイベントを溜め込むことが出来、"
"条件を満たせば溜め込まれたイベントが ``flushed`` として他のハンドラ "
"(``target`` のハンドラ)に渡されます。デフォルトでは、 ``MemoryHandler`` はそ"
"のバッファが一杯になるか、指定された閾値のレベル以上のイベントが起こるとフ"
"ラッシュされます。何か特別なフラッシュの振る舞いをしたければ、このレシピはさ"
"らに特殊化した ``MemoryHandler`` とともに利用出来ます。"

#: ../../howto/logging-cookbook.rst:2295
msgid ""
"The example script has a simple function, ``foo``, which just cycles through "
"all the logging levels, writing to ``sys.stderr`` to say what level it's "
"about to log at, and then actually logging a message at that level. You can "
"pass a parameter to ``foo`` which, if true, will log at ERROR and CRITICAL "
"levels - otherwise, it only logs at DEBUG, INFO and WARNING levels."
msgstr ""
"スクリプト例では、 ``foo`` という、単に全てのログレベルについて、 ``sys."
"stderr`` にもどのレベルを出力したのかについて書き出しながら実際のログ出力も行"
"う、という単純な関数を使っています。 ``foo`` に真を与えると ERROR と "
"CRITICAL の出力をし、そうでなければ DEBUG, INFO, WARNING だけを出力します。"

#: ../../howto/logging-cookbook.rst:2301
msgid ""
"The script just arranges to decorate ``foo`` with a decorator which will do "
"the conditional logging that's required. The decorator takes a logger as a "
"parameter and attaches a memory handler for the duration of the call to the "
"decorated function. The decorator can be additionally parameterised using a "
"target handler, a level at which flushing should occur, and a capacity for "
"the buffer (number of records buffered). These default to a :class:`~logging."
"StreamHandler` which writes to ``sys.stderr``, ``logging.ERROR`` and ``100`` "
"respectively."
msgstr ""

#: ../../howto/logging-cookbook.rst:2309
msgid "Here's the script::"
msgstr "スクリプトはこれです::"

#: ../../howto/logging-cookbook.rst:2372
msgid "When this script is run, the following output should be observed:"
msgstr ""

#: ../../howto/logging-cookbook.rst:2402
msgid ""
"As you can see, actual logging output only occurs when an event is logged "
"whose severity is ERROR or greater, but in that case, any previous events at "
"lower severities are also logged."
msgstr ""
"見ての通り、実際のログ出力は重要度 ERROR かそれより大きい場合にのみ行っていま"
"すが、この場合はそれよりも重要度の低い ERROR よりも前に発生したイベントも出力"
"されます。"

#: ../../howto/logging-cookbook.rst:2406
msgid "You can of course use the conventional means of decoration::"
msgstr "当然のことですが、デコレーションはいつものやり方でどうぞ::"

#: ../../howto/logging-cookbook.rst:2416
msgid "Formatting times using UTC (GMT) via configuration"
msgstr "設定によって時刻を UTC(GMT) で書式化する"

#: ../../howto/logging-cookbook.rst:2418
msgid ""
"Sometimes you want to format times using UTC, which can be done using a "
"class such as `UTCFormatter`, shown below::"
msgstr ""
"場合によっては、時刻として UTC を使いたいと思うかもしれません。これには以下に"
"示すような `UTCFormatter` のようなクラスを使って出来ます::"

#: ../../howto/logging-cookbook.rst:2427
msgid ""
"and you can then use the ``UTCFormatter`` in your code instead of :class:"
"`~logging.Formatter`. If you want to do that via configuration, you can use "
"the :func:`~logging.config.dictConfig` API with an approach illustrated by "
"the following complete example::"
msgstr ""
"そしてコード中で ``UTCFormatter`` を :class:`~logging.Formatter` の代わりに使"
"えます。これを設定を通して行いたい場合、 :func:`~logging.config.dictConfig` "
"API を以下の完全な例で示すようなアプローチで使うことが出来ます::"

#: ../../howto/logging-cookbook.rst:2470
msgid "When this script is run, it should print something like:"
msgstr ""

#: ../../howto/logging-cookbook.rst:2477
msgid ""
"showing how the time is formatted both as local time and UTC, one for each "
"handler."
msgstr ""
"時刻をローカル時刻と UTC の両方に書式化するのに、それぞれのハンドラにそれぞれ"
"フォーマッタを与えています。"

#: ../../howto/logging-cookbook.rst:2484
msgid "Using a context manager for selective logging"
msgstr "ロギングの選択にコンテキストマネージャを使う"

#: ../../howto/logging-cookbook.rst:2486
msgid ""
"There are times when it would be useful to temporarily change the logging "
"configuration and revert it back after doing something. For this, a context "
"manager is the most obvious way of saving and restoring the logging context. "
"Here is a simple example of such a context manager, which allows you to "
"optionally change the logging level and add a logging handler purely in the "
"scope of the context manager::"
msgstr ""
"一時的にロギングの設定を変えて、作業をした後に設定を戻せると便利なときがあり"
"ます。\n"
"こういうときの、ロギングコンテキストの保存と復元をする方法ではコンテキストマ"
"ネージャを使うのが一番です。\n"
"以下にあるのがそのためのコンテキストマネージャの簡単な例で、これを使うと、任"
"意にロギングレベルを変更し、コンテキストマネージャのスコープ内で他に影響を及"
"ぼさずロギングハンドラを追加できるようになります::"

#: ../../howto/logging-cookbook.rst:2519
msgid ""
"If you specify a level value, the logger's level is set to that value in the "
"scope of the with block covered by the context manager. If you specify a "
"handler, it is added to the logger on entry to the block and removed on exit "
"from the block. You can also ask the manager to close the handler for you on "
"block exit - you could do this if you don't need the handler any more."
msgstr ""
"レベル値を指定した場合、コンテキストマネージャがカバーする with ブロックのス"
"コープ内でロガーのレベルがその値に設定されます。\n"
"ハンドラーを指定した場合、ブロックに入るときにロガーに追加され、ブロックから"
"抜けるときに取り除かれます。\n"
"ブロックを抜けるときに、自分で追加したハンドラをクローズするようコンテキスト"
"マネージャに指示することもできます - そのハンドラがそれ以降必要無いのであれば"
"クローズしてしまって構いません。"

#: ../../howto/logging-cookbook.rst:2525
msgid ""
"To illustrate how it works, we can add the following block of code to the "
"above::"
msgstr ""
"どのように動作するのかを示すためには、次のコード群を上のコードに付け加えると"
"よいです::"

#: ../../howto/logging-cookbook.rst:2543
msgid ""
"We initially set the logger's level to ``INFO``, so message #1 appears and "
"message #2 doesn't. We then change the level to ``DEBUG`` temporarily in the "
"following ``with`` block, and so message #3 appears. After the block exits, "
"the logger's level is restored to ``INFO`` and so message #4 doesn't appear. "
"In the next ``with`` block, we set the level to ``DEBUG`` again but also add "
"a handler writing to ``sys.stdout``. Thus, message #5 appears twice on the "
"console (once via ``stderr`` and once via ``stdout``). After the ``with`` "
"statement's completion, the status is as it was before so message #6 appears "
"(like message #1) whereas message #7 doesn't (just like message #2)."
msgstr ""
"最初はロガーのレベルを ``INFO`` に設定しているので、メッセージ #1 は現れ、"
"メッセージ #2 は現れません。\n"
"次に、その後の ``with`` ブロック内で一時的にレベルを ``DEBUG`` に変更したた"
"め、メッセージ #3 が現れます。\n"
"そのブロックを抜けた後、ロガーのレベルは ``INFO`` に復元され、メッセージ #4 "
"は現れません。\n"
"次の ``with`` ブロック内では、再度レベルを ``DEBUG`` に設定し、 ``sys."
"stdout`` に書き出すハンドラを追加します。\n"
"そのおかげでメッセージ #5 が 2 回 (1回は ``stderr`` を通して、もう1回は "
"``stdout`` を通して) コンソールに出力されます。\n"
"``with`` 文が完了すると、前の状態になるので (メッセージ #1 のように) メッセー"
"ジ #6 が現れ、(まさにメッセージ #2 のように) メッセージ #7 は現れません。"

#: ../../howto/logging-cookbook.rst:2553
msgid "If we run the resulting script, the result is as follows:"
msgstr "出来上がったスクリプトを実行すると、結果は次のようになります::"

#: ../../howto/logging-cookbook.rst:2564
msgid ""
"If we run it again, but pipe ``stderr`` to ``/dev/null``, we see the "
"following, which is the only message written to ``stdout``:"
msgstr ""
"``stderr`` を ``/dev/null`` へパイプした状態でもう一度実行すると、次のように"
"なり、これは ``stdout`` の方に書かれたメッセージだけが現れています:"

#: ../../howto/logging-cookbook.rst:2572
msgid "Once again, but piping ``stdout`` to ``/dev/null``, we get:"
msgstr ""
"``stdout`` を ``/dev/null`` へパイプした状態でさらにもう一度実行すると、こう"
"なります:"

#: ../../howto/logging-cookbook.rst:2582
msgid ""
"In this case, the message #5 printed to ``stdout`` doesn't appear, as "
"expected."
msgstr ""
"この場合では、 ``stdout`` の方に出力されたメッセージ #5 は予想通り現れませ"
"ん。"

#: ../../howto/logging-cookbook.rst:2584
msgid ""
"Of course, the approach described here can be generalised, for example to "
"attach logging filters temporarily. Note that the above code works in Python "
"2 as well as Python 3."
msgstr ""
"もちろんここで説明した手法は、例えば一時的にロギングフィルターを取り付けたり"
"するのに一般化できます。\n"
"上のコードは Python 2 だけでなく Python 3 でも動くことに注意してください。"

#: ../../howto/logging-cookbook.rst:2592
msgid "A CLI application starter template"
msgstr ""

#: ../../howto/logging-cookbook.rst:2594
msgid "Here's an example which shows how you can:"
msgstr ""

#: ../../howto/logging-cookbook.rst:2596
msgid "Use a logging level based on command-line arguments"
msgstr ""

#: ../../howto/logging-cookbook.rst:2597
msgid ""
"Dispatch to multiple subcommands in separate files, all logging at the same "
"level in a consistent way"
msgstr ""

#: ../../howto/logging-cookbook.rst:2599
msgid "Make use of simple, minimal configuration"
msgstr ""

#: ../../howto/logging-cookbook.rst:2601
msgid ""
"Suppose we have a command-line application whose job is to stop, start or "
"restart some services. This could be organised for the purposes of "
"illustration as a file ``app.py`` that is the main script for the "
"application, with individual commands implemented in ``start.py``, ``stop."
"py`` and ``restart.py``. Suppose further that we want to control the "
"verbosity of the application via a command-line argument, defaulting to "
"``logging.INFO``. Here's one way that ``app.py`` could be written::"
msgstr ""

#: ../../howto/logging-cookbook.rst:2650
msgid ""
"And the ``start``, ``stop`` and ``restart`` commands can be implemented in "
"separate modules, like so for starting::"
msgstr ""

#: ../../howto/logging-cookbook.rst:2663
msgid "and thus for stopping::"
msgstr ""

#: ../../howto/logging-cookbook.rst:2684
msgid "and similarly for restarting::"
msgstr ""

#: ../../howto/logging-cookbook.rst:2705
msgid ""
"If we run this application with the default log level, we get output like "
"this:"
msgstr ""

#: ../../howto/logging-cookbook.rst:2718
msgid ""
"The first word is the logging level, and the second word is the module or "
"package name of the place where the event was logged."
msgstr ""

#: ../../howto/logging-cookbook.rst:2721
msgid ""
"If we change the logging level, then we can change the information sent to "
"the log. For example, if we want more information:"
msgstr ""

#: ../../howto/logging-cookbook.rst:2738
msgid "And if we want less:"
msgstr ""

#: ../../howto/logging-cookbook.rst:2746
msgid ""
"In this case, the commands don't print anything to the console, since "
"nothing at ``WARNING`` level or above is logged by them."
msgstr ""

#: ../../howto/logging-cookbook.rst:2752
msgid "A Qt GUI for logging"
msgstr ""

#: ../../howto/logging-cookbook.rst:2754
msgid ""
"A question that comes up from time to time is about how to log to a GUI "
"application. The `Qt <https://www.qt.io/>`_ framework is a popular cross-"
"platform UI framework with Python bindings using `PySide2 <https://pypi.org/"
"project/PySide2/>`_ or `PyQt5 <https://pypi.org/project/PyQt5/>`_ libraries."
msgstr ""

#: ../../howto/logging-cookbook.rst:2760
msgid ""
"The following example shows how to log to a Qt GUI. This introduces a simple "
"``QtHandler`` class which takes a callable, which should be a slot in the "
"main thread that does GUI updates. A worker thread is also created to show "
"how you can log to the GUI from both the UI itself (via a button for manual "
"logging) as well as a worker thread doing work in the background (here, just "
"logging messages at random levels with random short delays in between)."
msgstr ""

#: ../../howto/logging-cookbook.rst:2767
msgid ""
"The worker thread is implemented using Qt's ``QThread`` class rather than "
"the :mod:`threading` module, as there are circumstances where one has to use "
"``QThread``, which offers better integration with other ``Qt`` components."
msgstr ""

#: ../../howto/logging-cookbook.rst:2771
msgid ""
"The code should work with recent releases of either ``PySide2`` or "
"``PyQt5``. You should be able to adapt the approach to earlier versions of "
"Qt. Please refer to the comments in the code snippet for more detailed "
"information."
msgstr ""
