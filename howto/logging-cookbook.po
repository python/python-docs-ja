# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# cocoatomo, 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2018-01-20 20:57+0000\n"
"Last-Translator: cocoatomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/logging-cookbook.rst:5
msgid "Logging Cookbook"
msgstr "Logging クックブック"

#: ../../howto/logging-cookbook.rst:0
msgid "Author"
msgstr "著者"

#: ../../howto/logging-cookbook.rst:7
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../../howto/logging-cookbook.rst:9
msgid ""
"This page contains a number of recipes related to logging, which have been "
"found useful in the past."
msgstr "このページでは、過去に見つかった logging に関するいくつかの便利なレシピを紹介します。"

#: ../../howto/logging-cookbook.rst:15
msgid "Using logging in multiple modules"
msgstr "複数のモジュールで logging を使う"

#: ../../howto/logging-cookbook.rst:17
msgid ""
"Multiple calls to ``logging.getLogger('someLogger')`` return a reference to "
"the same logger object.  This is true not only within the same module, but "
"also across modules as long as it is in the same Python interpreter process."
"  It is true for references to the same object; additionally, application "
"code can define and configure a parent logger in one module and create (but "
"not configure) a child logger in a separate module, and all logger calls to "
"the child will pass up to the parent.  Here is a main module::"
msgstr "``logging.getLogger('someLogger')`` の複数回の呼び出しは同じ logger への参照を返します。これは同じ Python インタプリタプロセス上で動いている限り、一つのモジュールの中からに限らず、モジュールをまたいでも当てはまります。同じオブジェクトへの参照という点でも正しいです。さらに、一つのモジュールの中で親 logger を定義して設定し、別のモジュールで子 logger を定義する (ただし設定はしない) ことが可能で、すべての子 logger への呼び出しは親にまで渡されます。まずはメインのモジュールです::"

#: ../../howto/logging-cookbook.rst:55
msgid "Here is the auxiliary module::"
msgstr "そして補助モジュール (auxiliary module) がこちらです::"

#: ../../howto/logging-cookbook.rst:75
msgid "The output looks like this::"
msgstr "出力はこのようになります::"

#: ../../howto/logging-cookbook.rst:99
msgid "Logging from multiple threads"
msgstr "複数のスレッドからのロギング"

#: ../../howto/logging-cookbook.rst:101
msgid ""
"Logging from multiple threads requires no special effort. The following "
"example shows logging from the main (initIal) thread and another thread::"
msgstr "複数スレッドからのロギングでは特別に何かをする必要はありません。\n次の例はmain (初期) スレッドとそれ以外のスレッドからのロギングの例です::"

#: ../../howto/logging-cookbook.rst:130
msgid "When run, the script should print something like the following::"
msgstr "実行すると、このスクリプトの出力は次のようなものになるはずです::"

#: ../../howto/logging-cookbook.rst:150
msgid ""
"This shows the logging output interspersed as one might expect. This "
"approach works for more threads than shown here, of course."
msgstr "予想した通りかもしれませんが、ログ出力が散らばっているのが分かります。\nもちろん、この手法はより多くのスレッドでも上手くいきます。"

#: ../../howto/logging-cookbook.rst:154
msgid "Multiple handlers and formatters"
msgstr "複数の handler と formatter"

#: ../../howto/logging-cookbook.rst:156
msgid ""
"Loggers are plain Python objects.  The :meth:`~Logger.addHandler` method has"
" no minimum or maximum quota for the number of handlers you may add.  "
"Sometimes it will be beneficial for an application to log all messages of "
"all severities to a text file while simultaneously logging errors or above "
"to the console.  To set this up, simply configure the appropriate handlers."
"  The logging calls in the application code will remain unchanged.  Here is "
"a slight modification to the previous simple module-based configuration "
"example::"
msgstr "logger は通常の Python オブジェクトです。 :meth:`~Logger.addHandler` メソッドは追加されるハンドラの個数について最小値も最大値も定めていません。時にアプリケーションがすべての深刻度のすべてのメッセージをテキストファイルに記録しつつ、同時にエラーやそれ以上のものをコンソールに出力することが役に立ちます。これを実現する方法は、単に適切なハンドラを設定するだけです。アプリケーションコードの中のログ記録の呼び出しは変更されずに残ります。少し前に取り上げた単純なモジュール式の例を少し変えるとこうなります::"

#: ../../howto/logging-cookbook.rst:189
msgid ""
"Notice that the 'application' code does not care about multiple handlers.  "
"All that changed was the addition and configuration of a new handler named "
"*fh*."
msgstr "'application' 部分のコードは複数の handler について何も気にしていないことに注目してください。変更した箇所は新しい *fh* という名の handler を追加して設定したところがすべてです。"

#: ../../howto/logging-cookbook.rst:192
msgid ""
"The ability to create new handlers with higher- or lower-severity filters "
"can be very helpful when writing and testing an application.  Instead of "
"using many ``print`` statements for debugging, use ``logger.debug``: Unlike "
"the print statements, which you will have to delete or comment out later, "
"the logger.debug statements can remain intact in the source code and remain "
"dormant until you need them again.  At that time, the only change that needs"
" to happen is to modify the severity level of the logger and/or handler to "
"debug."
msgstr "新しい handler を、異なる深刻度に対する filter と共に生成できることは、アプリケーションを書いてテストを行うときとても助けになります。デバッグ用にたくさんの ``print`` 文を使う代わりに ``logger.debug`` を使いましょう。あとで消したりコメントアウトしたりしなければならない print 文と違って、logger.debug 命令はソースコードの中にそのまま残しておいて再び必要になるまで休眠させておけます。その時必要になるのはただ logger および/または handler の深刻度の設定をいじることだけです。"

#: ../../howto/logging-cookbook.rst:203
msgid "Logging to multiple destinations"
msgstr "複数の出力先にログを出力する"

#: ../../howto/logging-cookbook.rst:205
msgid ""
"Let's say you want to log to console and file with different message formats"
" and in differing circumstances. Say you want to log messages with levels of"
" DEBUG and higher to file, and those messages at level INFO and higher to "
"the console. Let's also assume that the file should contain timestamps, but "
"the console messages should not. Here's how you can achieve this::"
msgstr "コンソールとファイルに、別々のメッセージ書式で、別々の状況に応じたログ出力を行わせたいとしましょう。例えば DEBUG よりも高いレベルのメッセージはファイルに記録し、INFO 以上のレベルのメッセージはコンソールに出力したいという場合です。また、ファイルにはタイムスタンプを記録し、コンソールには出力しないとします。以下のようにすれば、こうした挙動を実現できます::"

#: ../../howto/logging-cookbook.rst:243
msgid "When you run this, on the console you will see ::"
msgstr "このスクリプトを実行すると、コンソールには以下のように表示されるでしょう ::"

#: ../../howto/logging-cookbook.rst:250
msgid "and in the file you will see something like ::"
msgstr "そして、ファイルは以下のようになるはずです ::"

#: ../../howto/logging-cookbook.rst:258
msgid ""
"As you can see, the DEBUG message only shows up in the file. The other "
"messages are sent to both destinations."
msgstr "これを見て分かる通り、DEBUG メッセージはファイルだけに出力され、その他のメッセージは両方に出力されます。"

#: ../../howto/logging-cookbook.rst:261
msgid ""
"This example uses console and file handlers, but you can use any number and "
"combination of handlers you choose."
msgstr "この例ではコンソールとファイルのハンドラだけを使っていますが、実際には任意の数のハンドラや組み合わせを使えます。"

#: ../../howto/logging-cookbook.rst:266
msgid "Configuration server example"
msgstr "設定サーバの例"

#: ../../howto/logging-cookbook.rst:268
msgid ""
"Here is an example of a module using the logging configuration server::"
msgstr "ログ記録設定サーバを使うモジュールの例です::"

#: ../../howto/logging-cookbook.rst:299
msgid ""
"And here is a script that takes a filename and sends that file to the "
"server, properly preceded with the binary-encoded length, as the new logging"
" configuration::"
msgstr "そしてファイル名を受け取ってそのファイルをサーバに送るスクリプトですが、それに先だってバイナリエンコード長を新しいログ記録の設定として先に送っておきます::"

#: ../../howto/logging-cookbook.rst:324
msgid "Sending and receiving logging events across a network"
msgstr "ネットワーク越しの logging イベントの送受信"

#: ../../howto/logging-cookbook.rst:326
msgid ""
"Let's say you want to send logging events across a network, and handle them "
"at the receiving end. A simple way of doing this is attaching a "
":class:`SocketHandler` instance to the root logger at the sending end::"
msgstr "ログイベントをネットワーク越しに送信し、受信端でそれを処理したいとしましょう。 :class:`SocketHandler` インスタンスを送信端の root logger にアタッチすれば、簡単に実現できます::"

#: ../../howto/logging-cookbook.rst:354
msgid ""
"At the receiving end, you can set up a receiver using the "
":mod:`SocketServer` module. Here is a basic working example::"
msgstr "受信端では :mod:`SocketServer` モジュールを使って受信プログラムを作成しておきます。簡単な実用プログラムを以下に示します::"

#: ../../howto/logging-cookbook.rst:442
msgid ""
"First run the server, and then the client. On the client side, nothing is "
"printed on the console; on the server side, you should see something like::"
msgstr "先にサーバを起動しておき、次にクライアントを起動します。クライアント側では、コンソールには何も出力されません; サーバ側では以下のようなメッセージを目にするはずです::"

#: ../../howto/logging-cookbook.rst:452
msgid ""
"Note that there are some security issues with pickle in some scenarios. If "
"these affect you, you can use an alternative serialization scheme by "
"overriding the :meth:`~handlers.SocketHandler.makePickle` method and "
"implementing your alternative there, as well as adapting the above script to"
" use your alternative serialization."
msgstr "特定のシナリオでは pickle にはいくつかのセキュリティ上の問題があることに注意してください。これが問題になる場合、 :meth:`~handlers.SocketHandler.makePickle` メソッドをオーバーライドして代替手段を実装することで異なるシリアライズ手法を使用できます。代替シリアライズ手法を使うように上記のスクリプトを修正することもできます。"

#: ../../howto/logging-cookbook.rst:462
msgid "Adding contextual information to your logging output"
msgstr "コンテキスト情報をログ記録出力に付加する"

#: ../../howto/logging-cookbook.rst:466
msgid ""
"Sometimes you want logging output to contain contextual information in "
"addition to the parameters passed to the logging call. For example, in a "
"networked application, it may be desirable to log client-specific "
"information in the log (e.g. remote client's username, or IP address). "
"Although you could use the *extra* parameter to achieve this, it's not "
"always convenient to pass the information in this way. While it might be "
"tempting to create :class:`Logger` instances on a per-connection basis, this"
" is not a good idea because these instances are not garbage collected. While"
" this is not a problem in practice, when the number of :class:`Logger` "
"instances is dependent on the level of granularity you want to use in "
"logging an application, it could be hard to manage if the number of "
":class:`Logger` instances becomes effectively unbounded."
msgstr "時にはログ記録出力にログ関数の呼び出し時に渡されたパラメータに加えてコンテキスト情報を含めたいこともあるでしょう。たとえば、ネットワークアプリケーションで、クライアント固有の情報 (例: リモートクライアントの名前、 IP アドレス) もログ記録に残しておきたいと思ったとしましょう。 *extra* パラメータをこの目的に使うこともできますが、いつでもこの方法で情報を渡すのが便利なやり方とも限りません。また接続ごとに :class:`Logger` インスタンスを生成する誘惑に駆られるかもしれませんが、生成した :class:`Logger` インスタンスはガーベジコレクションで回収されないので、これは良いアイデアとは言えません。この例は現実的な問題ではないかもしれませんが、 :class:`Logger` インスタンスの個数がアプリケーションの中でログ記録が行われるレベルの粒度に依存する場合、 :class:`Logger` インスタンスの個数が事実上無制限にならないと、管理が難しくなります。"

#: ../../howto/logging-cookbook.rst:481
msgid "Using LoggerAdapters to impart contextual information"
msgstr "LoggerAdapter を使ったコンテキスト情報の伝達"

#: ../../howto/logging-cookbook.rst:483
msgid ""
"An easy way in which you can pass contextual information to be output along "
"with logging event information is to use the :class:`LoggerAdapter` class. "
"This class is designed to look like a :class:`Logger`, so that you can call "
":meth:`debug`, :meth:`info`, :meth:`warning`, :meth:`error`, "
":meth:`exception`, :meth:`critical` and :meth:`log`. These methods have the "
"same signatures as their counterparts in :class:`Logger`, so you can use the"
" two types of instances interchangeably."
msgstr "logging イベントの情報と一緒に出力されるコンテキスト情報を渡す簡単な方法は、 :class:`LoggerAdapter` を使うことです。このクラスは :class:`Logger` のように見えるように設計されていて、 :meth:`debug`, :meth:`info`, :meth:`warning`, :meth:`error`, :meth:`exception`, :meth:`critical`, :meth:`log` の各メソッドを呼び出せるようになっています。これらのメソッドは対応する :class:`Logger` のメソッドと同じ引数を取るので、二つの型を取り替えて使うことができます。"

#: ../../howto/logging-cookbook.rst:491
msgid ""
"When you create an instance of :class:`LoggerAdapter`, you pass it a "
":class:`Logger` instance and a dict-like object which contains your "
"contextual information. When you call one of the logging methods on an "
"instance of :class:`LoggerAdapter`, it delegates the call to the underlying "
"instance of :class:`Logger` passed to its constructor, and arranges to pass "
"the contextual information in the delegated call. Here's a snippet from the "
"code of :class:`LoggerAdapter`::"
msgstr ":class:`LoggerAdapter` のインスタンスを生成する際には、 :class:`Logger` インスタンスとコンテキスト情報を収めた辞書風 (dict-like) のオブジェクトを渡します。 :class:`LoggerAdapter` のログ記録メソッドを呼び出すと、呼び出しをコンストラクタに渡された配下の :class:`Logger` インスタンスに委譲し、その際コンテキスト情報をその委譲された呼び出しに埋め込みます。 :class:`LoggerAdapter` のコードから少し抜き出してみます::"

#: ../../howto/logging-cookbook.rst:507
msgid ""
"The :meth:`~LoggerAdapter.process` method of :class:`LoggerAdapter` is where"
" the contextual information is added to the logging output. It's passed the "
"message and keyword arguments of the logging call, and it passes back "
"(potentially) modified versions of these to use in the call to the "
"underlying logger. The default implementation of this method leaves the "
"message alone, but inserts an 'extra' key in the keyword argument whose "
"value is the dict-like object passed to the constructor. Of course, if you "
"had passed an 'extra' keyword argument in the call to the adapter, it will "
"be silently overwritten."
msgstr ":class:`LoggerAdapter` の :meth:`~LoggerAdapter.process` メソッドがコンテキスト情報をログ出力に加える場所です。そこではログ記録呼び出しのメッセージとキーワード引数が渡され、加工された (可能性のある) それらの情報を配下のロガーへの呼び出しに渡し直します。このメソッドのデフォルト実装ではメッセージは元のままですが、キーワード引数にはコンストラクタに渡された辞書風オブジェクトを値として \"extra\" キーが挿入されます。もちろん、呼び出し時に \"extra\" キーワードを使った場合には何事もなかったかのように上書きされます。"

#: ../../howto/logging-cookbook.rst:516
msgid ""
"The advantage of using 'extra' is that the values in the dict-like object "
"are merged into the :class:`LogRecord` instance's __dict__, allowing you to "
"use customized strings with your :class:`Formatter` instances which know "
"about the keys of the dict-like object. If you need a different method, e.g."
" if you want to prepend or append the contextual information to the message "
"string, you just need to subclass :class:`LoggerAdapter` and override "
":meth:`~LoggerAdapter.process` to do what you need. Here is a simple "
"example::"
msgstr "\"extra\" を用いる利点は辞書風オブジェクトの中の値が :class:`LogRecord` インスタンスの __dict__ にマージされることで、辞書風オブジェクトのキーを知っている :class:`Formatter` を用意して文字列をカスタマイズするようにできることです。それ以外のメソッドが必要なとき、たとえばコンテキスト情報をメッセージの前や後ろにつなげたい場合には、 :class:`LoggerAdapter` から :meth:`~LoggerAdapter.process` を望むようにオーバライドしたサブクラスを作ることが必要なだけです。次に挙げるのはこのクラスを使った例で、コンストラクタで使われる「辞書風」オブジェクトにどの振る舞いが必要なのかも示しています::"

#: ../../howto/logging-cookbook.rst:532
msgid "which you can use like this::"
msgstr "これを次のように使うことができます::"

#: ../../howto/logging-cookbook.rst:537
msgid ""
"Then any events that you log to the adapter will have the value of "
"``some_conn_id`` prepended to the log messages."
msgstr "これで、この adapter 経由でログした全てのイベントに対して、``some_conn_id`` の値がログメッセージの前に追加されます。"

#: ../../howto/logging-cookbook.rst:541
msgid "Using objects other than dicts to pass contextual information"
msgstr "コンテキスト情報を渡すために dict 以外のオブジェクトを使う"

#: ../../howto/logging-cookbook.rst:543
msgid ""
"You don't need to pass an actual dict to a :class:`LoggerAdapter` - you "
"could pass an instance of a class which implements ``__getitem__`` and "
"``__iter__`` so that it looks like a dict to logging. This would be useful "
"if you want to generate values dynamically (whereas the values in a dict "
"would be constant)."
msgstr ":class:`LoggerAdapter` に渡すのは本物の dict でなくても構いません。 ``__getitem__`` と ``__iter__`` を実装していて logging が辞書のように扱えるクラスのインスタンスを利用することができます。これは (dict の値が固定されるのに対して) 値を動的に生成できるので便利です。"

#: ../../howto/logging-cookbook.rst:552
msgid "Using Filters to impart contextual information"
msgstr "Filter を使ったコンテキスト情報の伝達"

#: ../../howto/logging-cookbook.rst:554
msgid ""
"You can also add contextual information to log output using a user-defined "
":class:`Filter`. ``Filter`` instances are allowed to modify the "
"``LogRecords`` passed to them, including adding additional attributes which "
"can then be output using a suitable format string, or if needed a custom "
":class:`Formatter`."
msgstr "ユーザ定義の :class:`Filter` を使ってログ出力にコンテキスト情報を加えることもできます。 ``Filter`` インスタンスは、渡された ``LogRecords`` を修正することができます。これにより、適切なフォーマット文字列や必要なら :class:`Formatter` を使って、出力となる属性を新しく追加することも出来ます。"

#: ../../howto/logging-cookbook.rst:559
msgid ""
"For example in a web application, the request being processed (or at least, "
"the interesting parts of it) can be stored in a threadlocal "
"(:class:`threading.local`) variable, and then accessed from a ``Filter`` to "
"add, say, information from the request - say, the remote IP address and "
"remote user's username - to the ``LogRecord``, using the attribute names "
"'ip' and 'user' as in the ``LoggerAdapter`` example above. In that case, the"
" same format string can be used to get similar output to that shown above. "
"Here's an example script::"
msgstr "例えば、web アプリケーションで、処理されるリクエスト (または、少なくともその重要な部分) は、スレッドローカル (:class:`threading.local`) な変数に保存して、 ``Filter`` からアクセスすることで、 ``LogRecord`` にリクエストの情報を追加できます。例えば、リモート IP アドレスやリモートユーザのユーザ名にアクセスしたいなら、上述の ``LoggerAdapter`` の例のように属性名 'ip' や 'user' を使うといったようにです。その場合、同じフォーマット文字列を使って以下に示すように似たような出力を得られます。これはスクリプトの例です::"

#: ../../howto/logging-cookbook.rst:605
msgid "which, when run, produces something like::"
msgstr "そして、実行時に、以下のようになります::"

#: ../../howto/logging-cookbook.rst:624
msgid "Logging to a single file from multiple processes"
msgstr "複数のプロセスからの単一ファイルへのログ記録"

#: ../../howto/logging-cookbook.rst:626
msgid ""
"Although logging is thread-safe, and logging to a single file from multiple "
"threads in a single process *is* supported, logging to a single file from "
"*multiple processes* is *not* supported, because there is no standard way to"
" serialize access to a single file across multiple processes in Python. If "
"you need to log to a single file from multiple processes, one way of doing "
"this is to have all the processes log to a :class:`~handlers.SocketHandler`,"
" and have a separate process which implements a socket server which reads "
"from the socket and logs to file. (If you prefer, you can dedicate one "
"thread in one of the existing processes to perform this function.) "
":ref:`This section <network-logging>` documents this approach in more detail"
" and includes a working socket receiver which can be used as a starting "
"point for you to adapt in your own applications."
msgstr "ログ記録はスレッドセーフであり、単一プロセスの複数のスレッドからの単一ファイルへのログ記録はサポート *されています* が、 *複数プロセス* からの単一ファイルへのログ記録はサポート *されません* 。なぜなら、複数のプロセスをまたいで単一のファイルへのアクセスを直列化する標準の方法が Python には存在しないからです。複数のプロセスから単一ファイルへログ記録しなければならないなら、最も良い方法は、すべてのプロセスが :class:`~handlers.SocketHandler` に対してログ記録を行い、独立したプロセスとしてソケットサーバを動かすことです。ソケットサーバはソケットから読み取ってファイルにログを書き出します。 (この機能を実行するために、既存のプロセスの 1 つのスレッドを割り当てることもできます) :ref:`この節 <network-logging>` では、このアプローチをさらに詳細に文書化しています。動作するソケット受信プログラムが含まれているので、アプリケーションに組み込むための出発点として使用できるでしょう。"

#: ../../howto/logging-cookbook.rst:639
msgid ""
"If you are using a recent version of Python which includes the "
":mod:`multiprocessing` module, you could write your own handler which uses "
"the :class:`~multiprocessing.Lock` class from this module to serialize "
"access to the file from your processes. The existing :class:`FileHandler` "
"and subclasses do not make use of :mod:`multiprocessing` at present, though "
"they may do so in the future. Note that at present, the "
":mod:`multiprocessing` module does not provide working lock functionality on"
" all platforms (see https://bugs.python.org/issue3770)."
msgstr ":mod:`multiprocessing` モジュールを含む最近のバージョンの Python を使用しているなら、複数のプロセスからファイルへのアクセスを直列化するために :class:`~multiprocessing.Lock` クラスを使って独自のハンドラを書くことができます。既存の :class:`FileHandler` とそのサブクラスは現在のところ :mod:`multiprocessing` を利用していませんが、将来は利用するようになるかもしれません。現在のところ :mod:`multiprocessing` モジュールが提供するロック機能はすべてのプラットホームで動作するわけではないことに注意してください (https://bugs.python.org/issue3770 参照)。"

#: ../../howto/logging-cookbook.rst:650
msgid "Using file rotation"
msgstr "ファイルをローテートする"

#: ../../howto/logging-cookbook.rst:655
msgid ""
"Sometimes you want to let a log file grow to a certain size, then open a new"
" file and log to that. You may want to keep a certain number of these files,"
" and when that many files have been created, rotate the files so that the "
"number of files and the size of the files both remain bounded. For this "
"usage pattern, the logging package provides a "
":class:`~handlers.RotatingFileHandler`::"
msgstr "ログファイルがある大きさに達したら、新しいファイルを開いてそこにログを取りたいことがあります。そのファイルをある数だけ残し、その数のファイルが生成されたらファイルを循環し、ファイルの数も大きさも制限したいこともあるでしょう。この利用パターンのために、logging パッケージは :class:`~handlers.RotatingFileHandler` を提供しています::"

#: ../../howto/logging-cookbook.rst:687
msgid ""
"The result should be 6 separate files, each with part of the log history for"
" the application::"
msgstr "この結果として、アプリケーションのログ履歴の一部である、6 つに別れたファイルが得られます::"

#: ../../howto/logging-cookbook.rst:697
msgid ""
"The most current file is always :file:`logging_rotatingfile_example.out`, "
"and each time it reaches the size limit it is renamed with the suffix "
"``.1``. Each of the existing backup files is renamed to increment the suffix"
" (``.1`` becomes ``.2``, etc.)  and the ``.6`` file is erased."
msgstr "最新のファイルはいつでも :file:`logging_rotatingfile_example.out` で、サイズの上限に達するたびに拡張子 ``.1`` を付けた名前に改名されます。既にあるバックアップファイルはその拡張子がインクリメントされ (``.1`` が ``.2`` になるなど)、 ``.6`` ファイルは消去されます。"

#: ../../howto/logging-cookbook.rst:702
msgid ""
"Obviously this example sets the log length much too small as an extreme "
"example.  You would want to set *maxBytes* to an appropriate value."
msgstr "明らかに、ここでは極端な例示のためにファイルの大きさをかなり小さな値に設定しています。実際に使うときは *maxBytes* を適切な値に設定してください。"

#: ../../howto/logging-cookbook.rst:706
msgid "An example dictionary-based configuration"
msgstr "辞書ベースで構成する例"

#: ../../howto/logging-cookbook.rst:708
msgid ""
"Below is an example of a logging configuration dictionary - it's taken from "
"the `documentation on the Django project "
"<https://docs.djangoproject.com/en/1.9/topics/logging/#configuring-"
"logging>`_. This dictionary is passed to :func:`~config.dictConfig` to put "
"the configuration into effect::"
msgstr "次の例は辞書を使った logging の構成です。この例は `Django プロジェクトのドキュメント <https://docs.djangoproject.com/en/1.9/topics/logging/#configuring-logging>`_ から持ってきました。この辞書を :func:`~config.dictConfig` に渡して設定を有効にします::"

#: ../../howto/logging-cookbook.rst:764
msgid ""
"For more information about this configuration, you can see the `relevant "
"section <https://docs.djangoproject.com/en/1.9/topics/logging/#configuring-"
"logging>`_ of the Django documentation."
msgstr "この構成方法についてのより詳しい情報は、 Django のドキュメントの `該当のセクション <https://docs.djangoproject.com/en/1.9/topics/logging/#configuring-logging>`_ で見ることができます。"

#: ../../howto/logging-cookbook.rst:769
msgid "Inserting a BOM into messages sent to a SysLogHandler"
msgstr "SysLogHandler に送るメッセージに BOM を挿入する"

#: ../../howto/logging-cookbook.rst:771
msgid ""
"`RFC 5424 <https://tools.ietf.org/html/rfc5424>`_ requires that a Unicode "
"message be sent to a syslog daemon as a set of bytes which have the "
"following structure: an optional pure-ASCII component, followed by a UTF-8 "
"Byte Order Mark (BOM), followed by Unicode encoded using UTF-8. (See the "
"`relevant section of the specification "
"<https://tools.ietf.org/html/rfc5424#section-6>`_.)"
msgstr "`RFC 5424 <https://tools.ietf.org/html/rfc5424>`_ は syslog デーモンに Unicode メッセージを送る時、次の構造を要求しています: オプショナルなピュア ASCII部分、続けて UTF-8 の Byte Order Mark (BOM)、続けて UTF-8 でエンコードされた Unicode. (`仕様の該当セクション <https://tools.ietf.org/html/rfc5424#section-6>`_ を参照)"

#: ../../howto/logging-cookbook.rst:777
msgid ""
"In Python 2.6 and 2.7, code was added to "
":class:`~logging.handlers.SysLogHandler` to insert a BOM into the message, "
"but unfortunately, it was implemented incorrectly, with the BOM appearing at"
" the beginning of the message and hence not allowing any pure-ASCII "
"component to appear before it."
msgstr "Python 2.6, 2.7 で :class:`~logging.handlers.SysLogHandler` に、 message に BOM を挿入するコードが追加されました。しかし、そのときの実装が悪くて、 message の先頭に BOM をつけてしまうのでピュアASCII 部分をその前に書くことができませんでした。"

#: ../../howto/logging-cookbook.rst:783
msgid ""
"As this behaviour is broken, the incorrect BOM insertion code is being "
"removed from Python 2.7.4 and later. However, it is not being replaced, and "
"if you want to produce RFC 5424-compliant messages which include a BOM, an "
"optional pure-ASCII sequence before it and arbitrary Unicode after it, "
"encoded using UTF-8, then you need to do the following:"
msgstr "この動作は壊れているので、Python 2.7.4 以降では BOM を挿入するコードが、削除されました。書き直されるのではなく削除されたので、RFC 5424 準拠の、BOM と、オプションのピュア ASCII部分をBOMの前に、任意の Unicode を BOM の後ろに持つ UTF-8 でエンコードされた message を生成したい場合、次の手順に従う必要があります:"

#: ../../howto/logging-cookbook.rst:789
msgid ""
"Attach a :class:`~logging.Formatter` instance to your "
":class:`~logging.handlers.SysLogHandler` instance, with a format string such"
" as::"
msgstr ":class:`~logging.handlers.SysLogHandler` のインスタンスに、次のような format 文字列を持った :class:`~logging.Formatter` インスタンスをアタッチする::"

#: ../../howto/logging-cookbook.rst:795
msgid ""
"The Unicode code point ``u'\\ufeff'``, when encoded using UTF-8, will be "
"encoded as a UTF-8 BOM -- the byte-string ``'\\xef\\xbb\\xbf'``."
msgstr "Unicode のコードポイント ``u'\\ufeff'`` は、UTF-8 でエンコードすると BOM -- ``'\\xef\\xbb\\xbf'`` -- になります。"

#: ../../howto/logging-cookbook.rst:798
msgid ""
"Replace the ASCII section with whatever placeholders you like, but make sure"
" that the data that appears in there after substitution is always ASCII "
"(that way, it will remain unchanged after UTF-8 encoding)."
msgstr "ASCII セクションを好きなプレースホルダに変更する。ただしその部分の置換結果が常に ASCII になるように注意する(UTF-8 でエンコードされてもその部分が変化しないようにする)。"

#: ../../howto/logging-cookbook.rst:802
msgid ""
"Replace the Unicode section with whatever placeholders you like; if the data"
" which appears there after substitution contains characters outside the "
"ASCII range, that's fine -- it will be encoded using UTF-8."
msgstr "Unicode セクションを任意のプレースホルダに置き換える。この部分を置換したデータに ASCII 外の文字が含まれていても、それは単に UTF-8 でエンコードされるだけです。"

#: ../../howto/logging-cookbook.rst:806
msgid ""
"If the formatted message is Unicode, it *will* be encoded using UTF-8 "
"encoding by ``SysLogHandler``. If you follow the above rules, you should be "
"able to produce RFC 5424-compliant messages. If you don't, logging may not "
"complain, but your messages will not be RFC 5424-compliant, and your syslog "
"daemon may complain."
msgstr "フォーマットされた message が Unicode の場合、 ``SysLogHandler`` によって UTF-8 でエンコードされます。上のルールに従えば、RFC 5424 準拠のメッセージを生成できます。上のルールに従わない場合、logging は何もエラーを起こしませんが、message は RFC 5424 に準拠しない形で送られるので、syslog デーモン側で何かエラーが起こる可能性があります。"

#: ../../howto/logging-cookbook.rst:814
msgid "Implementing structured logging"
msgstr "構造化ログを実装する"

#: ../../howto/logging-cookbook.rst:816
msgid ""
"Although most logging messages are intended for reading by humans, and thus "
"not readily machine-parseable, there might be circumstances where you want "
"to output messages in a structured format which *is* capable of being parsed"
" by a program (without needing complex regular expressions to parse the log "
"message). This is straightforward to achieve using the logging package. "
"There are a number of ways in which this could be achieved, but the "
"following is a simple approach which uses JSON to serialise the event in a "
"machine-parseable manner::"
msgstr "多くのログメッセージは人間が読むために書かれるため、機械的に処理しにくくなっていますが、場合によっては (複雑な正規表現を使ってログメッセージをパースしなくても) プログラムがパース *できる* 構造化されたフォーマットでメッセージを出力したい場合があります。\nlogging パッケージを使うと、これを簡単に実現できます。\n実現する方法は幾つもありますが、次の例は JSON を使ってイベントを、機械でパースできる形にシリアライズする単純な方法です::"

#: ../../howto/logging-cookbook.rst:840
msgid "If the above script is run, it prints::"
msgstr "上のスクリプトを実行すると次のように出力されます::"

#: ../../howto/logging-cookbook.rst:844 ../../howto/logging-cookbook.rst:891
msgid ""
"Note that the order of items might be different according to the version of "
"Python used."
msgstr "要素の順序は Python のバージョンによって異なることに注意してください。"

#: ../../howto/logging-cookbook.rst:847
msgid ""
"If you need more specialised processing, you can use a custom JSON encoder, "
"as in the following complete example::"
msgstr "より特殊な処理が必要な場合、次の例のように、カスタムの JSON エンコーダを作ることができます::"

#: ../../howto/logging-cookbook.rst:887
msgid "When the above script is run, it prints::"
msgstr "上のスクリプトを実行すると次のように出力されます::"

#: ../../howto/logging-cookbook.rst:900
msgid "Customizing handlers with :func:`dictConfig`"
msgstr "handler を :func:`dictConfig` を使ってカスタマイズする"

#: ../../howto/logging-cookbook.rst:902
msgid ""
"There are times when you want to customize logging handlers in particular "
"ways, and if you use :func:`dictConfig` you may be able to do this without "
"subclassing. As an example, consider that you may want to set the ownership "
"of a log file. On POSIX, this is easily done using :func:`os.chown`, but the"
" file handlers in the stdlib don't offer built-in support. You can customize"
" handler creation using a plain function such as::"
msgstr "logging handler に特定のカスタマイズを何度もしたい場合で、 :func:`dictConfig` を使っているなら、サブクラスを作らなくてもカスタマイズが可能です。例えば、ログファイルの owner を設定したいとします。これは POSIX 環境では :func:`os.chown` を使って簡単に実現できますが、標準ライブラリの file handler はこの機能を組み込みでサポートしていません。 handler の生成を通常の関数を使ってカスタマイズすることができます::"

#: ../../howto/logging-cookbook.rst:921
msgid ""
"You can then specify, in a logging configuration passed to "
":func:`dictConfig`, that a logging handler be created by calling this "
"function::"
msgstr "そして、 :func:`dictConfig` に渡される構成設定の中で、この関数を使って logging handler を生成するように指定することができます::"

#: ../../howto/logging-cookbook.rst:954
msgid ""
"In this example I am setting the ownership using the ``pulse`` user and "
"group, just for the purposes of illustration. Putting it together into a "
"working script, ``chowntest.py``::"
msgstr "この例は説明用のものですが、owner の user と group を ``pulse`` に設定しています。これを動くスクリプトに ``chowntest.py`` に組み込んでみます::"

#: ../../howto/logging-cookbook.rst:1001
msgid "To run this, you will probably need to run as ``root``:"
msgstr "これを実行するには、 ``root`` 権限で実行する必要があるかもしれません:"

#: ../../howto/logging-cookbook.rst:1011
msgid ""
"Note that this example uses Python 3.3 because that's where "
":func:`shutil.chown` makes an appearance. This approach should work with any"
" Python version that supports :func:`dictConfig` - namely, Python 2.7, 3.2 "
"or later. With pre-3.3 versions, you would need to implement the actual "
"ownership change using e.g. :func:`os.chown`."
msgstr ":func:`shutil.chown` が追加されたのが Python 3.3 からなので、この例は Python 3.3 を使っています。このアプローチ自体は :func:`dictConfig` をサポートした全ての Python バージョン - Python 2.7, 3.2 以降 - で利用できます。 3.3 以前のバージョンでは、オーナーを変更するのに :func:`os.chown` を利用する必要があるでしょう。"

#: ../../howto/logging-cookbook.rst:1017
msgid ""
"In practice, the handler-creating function may be in a utility module "
"somewhere in your project. Instead of the line in the configuration::"
msgstr "実際には、handler を生成する関数はプロジェクト内のどこかにあるユーティリティモジュールに置くことになるでしょう。設定の中で直接関数を参照する代わりに::"

#: ../../howto/logging-cookbook.rst:1022
msgid "you could use e.g.::"
msgstr "次のように書くこともできます::"

#: ../../howto/logging-cookbook.rst:1026
msgid ""
"where ``project.util`` can be replaced with the actual name of the package "
"where the function resides. In the above working script, using "
"``'ext://__main__.owned_file_handler'`` should work. Here, the actual "
"callable is resolved by :func:`dictConfig` from the ``ext://`` "
"specification."
msgstr "``project.util`` は関数がある実際の場所に置き換えてください。上のスクリプトでは ``'ext://__main__.owned_file_handler'`` で動くはずです。 :func:`dictConfig` は ``ext://`` から実際の callable を見つけます。"

#: ../../howto/logging-cookbook.rst:1031
msgid ""
"This example hopefully also points the way to how you could implement other "
"types of file change - e.g. setting specific POSIX permission bits - in the "
"same way, using :func:`os.chmod`."
msgstr "この例は他のファイルに対する変更を実装する例にもなっています。例えば :func:`os.chmod` を使って、同じ方法で POSIX パーミッションを設定できるでしょう。"

#: ../../howto/logging-cookbook.rst:1035
msgid ""
"Of course, the approach could also be extended to types of handler other "
"than a :class:`~logging.FileHandler` - for example, one of the rotating file"
" handlers, or a different type of handler altogether."
msgstr "もちろん、このアプローチは :class:`~logging.FileHandler` 以外の handler 、ローテートする file handler のいずれかやその他の handler にも適用できます。"

#: ../../howto/logging-cookbook.rst:1043
msgid "Configuring filters with :func:`dictConfig`"
msgstr "filter を :func:`dictConfig` を使ってカスタマイズする"

#: ../../howto/logging-cookbook.rst:1045
msgid ""
"You *can* configure filters using :func:`~logging.config.dictConfig`, though"
" it might not be obvious at first glance how to do it (hence this recipe). "
"Since :class:`~logging.Filter` is the only filter class included in the "
"standard library, and it is unlikely to cater to many requirements (it's "
"only there as a base class), you will typically need to define your own "
":class:`~logging.Filter` subclass with an overridden "
":meth:`~logging.Filter.filter` method. To do this, specify the ``()`` key in"
" the configuration dictionary for the filter, specifying a callable which "
"will be used to create the filter (a class is the most obvious, but you can "
"provide any callable which returns a :class:`~logging.Filter` instance). "
"Here is a complete example::"
msgstr ":func:`~logging.config.dictConfig` によってフィルタを設定 *出来ます* が、どうやってそれを行うのかが初見では明快とは言えないでしょう(そのためのこのレシピです)。 :class:`~logging.Filter` のみが唯一標準ライブラリに含まれているだけですし、それは何の要求にも応えてはくれません(ただの基底クラスですから)ので、典型的には :meth:`~logging.Filter.filter` メソッドをオーバライドした :class:`~logging.Filter` のサブクラスをあなた自身で定義する必要があります。これをするには、設定辞書内のフィルタ指定部分に、 ``()`` キーでそのフィルタを作るのに使われる callable を指定してください(クラスを指定するのが最もわかりやすいですが、 :class:`~logging.Filter` インスタンスを返却する callable を提供することでも出来ます)。以下に完全な例を示します::"

#: ../../howto/logging-cookbook.rst:1098
msgid ""
"This example shows how you can pass configuration data to the callable which"
" constructs the instance, in the form of keyword parameters. When run, the "
"above script will print::"
msgstr "どのようにして設定データとして、そのインスタンスを構築する callable をキーワードパラメータの形で渡すのか、をこの例は教えてくれます。上記スクリプトは実行すると、このような出力をします::"

#: ../../howto/logging-cookbook.rst:1104
msgid "which shows that the filter is working as configured."
msgstr "設定した通りに動いていますね。"

#: ../../howto/logging-cookbook.rst:1106
msgid "A couple of extra points to note:"
msgstr "ほかにもいくつか特筆すべき点があります:"

#: ../../howto/logging-cookbook.rst:1108
msgid ""
"If you can't refer to the callable directly in the configuration (e.g. if it"
" lives in a different module, and you can't import it directly where the "
"configuration dictionary is), you can use the form ``ext://...`` as "
"described in :ref:`logging-config-dict-externalobj`. For example, you could "
"have used the text ``'ext://__main__.MyFilter'`` instead of ``MyFilter`` in "
"the above example."
msgstr "設定内で直接その callable を参照出来ない場合(例えばそれが異なるモジュール内にあり、設定辞書のある場所からそれを直接インポート出来ない、など)には、 :ref:`logging-config-dict-externalobj` に記述されている ``ext://...`` 形式を使えます。例えば、上記例のように ``MyFilter`` と指定する代わりに、 ``'ext://__main__.MyFilter'`` と記述することが出来ます。"

#: ../../howto/logging-cookbook.rst:1115
msgid ""
"As well as for filters, this technique can also be used to configure custom "
"handlers and formatters. See :ref:`logging-config-dict-userdef` for more "
"information on how logging supports using user-defined objects in its "
"configuration, and see the other cookbook recipe :ref:`custom-handlers` "
"above."
msgstr "フィルタについてとともに、このテクニックは、カスタムハンドラ、カスタムフォーマッタに対しても同様に使えます。ロギングが設定において、どのようにユーザ定義のオブジェクトをサポートするのかについてのさらなる詳細については、 :ref:`logging-config-dict-userdef` と、本クックブックの上の方のレシピ :ref:`custom-handlers` を参照してください。"

#: ../../howto/logging-cookbook.rst:1124
msgid "Customized exception formatting"
msgstr "例外の書式化をカスタマイズする"

#: ../../howto/logging-cookbook.rst:1126
msgid ""
"There might be times when you want to do customized exception formatting - "
"for argument's sake, let's say you want exactly one line per logged event, "
"even when exception information is present. You can do this with a custom "
"formatter class, as shown in the following example::"
msgstr "例外の書式化をカスタマイズしたいことがあるでしょう - わかりやすさのために、例外情報がある場合でもログイベントごとに一行に収まることを死守したいと望むとしましょう。フォーマッタのクラスをカスタマイズして、このように出来ます::"

#: ../../howto/logging-cookbook.rst:1167
msgid "When run, this produces a file with exactly two lines::"
msgstr "実行してみましょう。このように正確に2行の出力を生成します::"

#: ../../howto/logging-cookbook.rst:1172
msgid ""
"While the above treatment is simplistic, it points the way to how exception "
"information can be formatted to your liking. The :mod:`traceback` module may"
" be helpful for more specialized needs."
msgstr "これは扱いとしては単純過ぎますが、例外情報をどのようにしてあなた好みの書式化出来るかを示しています。さらに特殊なニーズが必要な場合には :mod:`traceback` モジュールが有用です。"

#: ../../howto/logging-cookbook.rst:1179
msgid "Speaking logging messages"
msgstr "ロギングメッセージを喋る"

#: ../../howto/logging-cookbook.rst:1181
msgid ""
"There might be situations when it is desirable to have logging messages "
"rendered in an audible rather than a visible format. This is easy to do if "
"you have text-to-speech (TTS) functionality available in your system, even "
"if it doesn't have a Python binding. Most TTS systems have a command line "
"program you can run, and this can be invoked from a handler using "
":mod:`subprocess`. It's assumed here that TTS command line programs won't "
"expect to interact with users or take a long time to complete, and that the "
"frequency of logged messages will be not so high as to swamp the user with "
"messages, and that it's acceptable to have the messages spoken one at a time"
" rather than concurrently, The example implementation below waits for one "
"message to be spoken before the next is processed, and this might cause "
"other handlers to be kept waiting. Here is a short example showing the "
"approach, which assumes that the ``espeak`` TTS package is available::"
msgstr "ロギングメッセージを目で見る形式ではなく音で聴く形式として出力したい、という状況があるかもしれません。これはあなたのシステムで text- to-speech (TTS) 機能が利用可能であれば、容易です。それが Python バインディングを持っていなくとも、です。ほとんどの TTS システムはあなたが実行出来るコマンドラインプログラムを持っていて、このことで、 :mod:`subprocess` を使うことでハンドラが呼び出せます。ここでは、TTS コマンドラインプログラムはユーザとの対話を期待せず、完了には時間がかかり、そしてログメッセージの頻度はユーザをメッセージで圧倒してしまうほどには高くはなく、そして並列で喋るよりはメッセージ一つにつき一回喋ることが受け容れられる、としておきます。ここでお見せする実装例では、次が処理される前に一つのメッセージを喋り終わるまで待ち、結果としてほかのハンドラを待たせることになります。 ``espeak`` TTS パッケージが手許にあるとして、このアプローチによる短い例はこのようなものです::"

#: ../../howto/logging-cookbook.rst:1223
msgid ""
"When run, this script should say \"Hello\" and then \"Goodbye\" in a female "
"voice."
msgstr "実行すれば、女性の声で \"Hello\" に続き \"Goodbye\" と喋るはずです。"

#: ../../howto/logging-cookbook.rst:1225
msgid ""
"The above approach can, of course, be adapted to other TTS systems and even "
"other systems altogether which can process messages via external programs "
"run from a command line."
msgstr "このアプローチは、もちろんほかの TTS システムにも採用出来ますし、メッセージをコマンドライン経由で外部プログラムに渡せるようなものであれば、ほかのシステムであっても全く同じです。"

#: ../../howto/logging-cookbook.rst:1232
msgid "Buffering logging messages and outputting them conditionally"
msgstr "ロギングメッセージをバッファリングし、条件に従って出力する"

#: ../../howto/logging-cookbook.rst:1234
msgid ""
"There might be situations where you want to log messages in a temporary area"
" and only output them if a certain condition occurs. For example, you may "
"want to start logging debug events in a function, and if the function "
"completes without errors, you don't want to clutter the log with the "
"collected debug information, but if there is an error, you want all the "
"debug information to be output as well as the error."
msgstr "メッセージを一次領域に記録し、ある種の特定の状況になった場合にだけ出力したい、ということがあるかもしれません。たとえばある関数内でのデバッグのためのログ出力をしたくても、エラーなしで終了する限りにおいては収集されたデバッグ情報による混雑は喰らいたくはなく、エラーがあった場合にだけエラー出力とともにデバッグ情報を見たいのだ、のようなことがあるでしょう。"

#: ../../howto/logging-cookbook.rst:1241
msgid ""
"Here is an example which shows how you could do this using a decorator for "
"your functions where you want logging to behave this way. It makes use of "
"the :class:`logging.handlers.MemoryHandler`, which allows buffering of "
"logged events until some condition occurs, at which point the buffered "
"events are ``flushed`` - passed to another handler (the ``target`` handler) "
"for processing. By default, the ``MemoryHandler`` flushed when its buffer "
"gets filled up or an event whose level is greater than or equal to a "
"specified threshold is seen. You can use this recipe with a more specialised"
" subclass of ``MemoryHandler`` if you want custom flushing behavior."
msgstr "このような振る舞いをするロギングをしたい関数に対して、デコレータを用いてこれを行う例をお見せします。それには :class:`logging.handlers.MemoryHandler` を使います。これにより何か条件を満たすまでロギングイベントを溜め込むことが出来、条件を満たせば溜め込まれたイベントが ``flushed`` として他のハンドラ (``target`` のハンドラ)に渡されます。デフォルトでは、 ``MemoryHandler`` はそのバッファが一杯になるか、指定された閾値のレベル以上のイベントが起こるとフラッシュされます。何か特別なフラッシュの振る舞いをしたければ、このレシピはさらに特殊化した ``MemoryHandler`` とともに利用出来ます。"

#: ../../howto/logging-cookbook.rst:1251
msgid ""
"The example script has a simple function, ``foo``, which just cycles through"
" all the logging levels, writing to ``sys.stderr`` to say what level it's "
"about to log at, and then actually logging a message at that level. You can "
"pass a parameter to ``foo`` which, if true, will log at ERROR and CRITICAL "
"levels - otherwise, it only logs at DEBUG, INFO and WARNING levels."
msgstr "スクリプト例では、 ``foo`` という、単に全てのログレベルについて、 ``sys.stderr`` にもどのレベルを出力したのかについて書き出しながら実際のログ出力も行う、という単純な関数を使っています。 ``foo`` に真を与えると ERROR と CRITICAL の出力をし、そうでなければ DEBUG, INFO, WARNING だけを出力します。"

#: ../../howto/logging-cookbook.rst:1257
msgid ""
"The script just arranges to decorate ``foo`` with a decorator which will do "
"the conditional logging that's required. The decorator takes a logger as a "
"parameter and attaches a memory handler for the duration of the call to the "
"decorated function. The decorator can be additionally parameterised using a "
"target handler, a level at which flushing should occur, and a capacity for "
"the buffer. These default to a :class:`~logging.StreamHandler` which writes "
"to ``sys.stderr``, ``logging.ERROR`` and ``100`` respectively."
msgstr "スクリプトが行うことは単に、 ``foo`` を必要とされている特定の条件でのロギングを行うようにするデコレータで修飾することだけです。このデコレータはパラメータとしてロガーを取り、修飾された関数が呼ばれている間だけメモリハンドラをアタッチします。追加のパラメータとして、ターゲットのハンドラ、フラッシュが発生すべきレベル、バッファの容量も受け取れます。これらのデフォルトは順に ``sys.stderr`` へ書き出す :class:`~logging.StreamHandler`, ``logging.ERROR``, ``100`` です。"

#: ../../howto/logging-cookbook.rst:1265
msgid "Here's the script::"
msgstr "スクリプトはこれです::"

#: ../../howto/logging-cookbook.rst:1328
msgid "When this script is run, the following output should be observed::"
msgstr "実行すればこのような出力になるはずです::"

#: ../../howto/logging-cookbook.rst:1356
msgid ""
"As you can see, actual logging output only occurs when an event is logged "
"whose severity is ERROR or greater, but in that case, any previous events at"
" lower severities are also logged."
msgstr "見ての通り、実際のログ出力は重要度 ERROR かそれより大きい場合にのみ行っていますが、この場合はそれよりも重要度の低い ERROR よりも前に発生したイベントも出力されます。"

#: ../../howto/logging-cookbook.rst:1360
msgid "You can of course use the conventional means of decoration::"
msgstr "当然のことですが、デコレーションはいつものやり方でどうぞ::"

#: ../../howto/logging-cookbook.rst:1370
msgid "Formatting times using UTC (GMT) via configuration"
msgstr "設定によって時刻を UTC(GMT) で書式化する"

#: ../../howto/logging-cookbook.rst:1372
msgid ""
"Sometimes you want to format times using UTC, which can be done using a "
"class such as `UTCFormatter`, shown below::"
msgstr "場合によっては、時刻として UTC を使いたいと思うかもしれません。これには以下に示すような `UTCFormatter` のようなクラスを使って出来ます::"

#: ../../howto/logging-cookbook.rst:1381
msgid ""
"and you can then use the ``UTCFormatter`` in your code instead of "
":class:`~logging.Formatter`. If you want to do that via configuration, you "
"can use the :func:`~logging.config.dictConfig` API with an approach "
"illustrated by the following complete example::"
msgstr "そしてコード中で ``UTCFormatter`` を :class:`~logging.Formatter` の代わりに使えます。これを設定を通して行いたい場合、 :func:`~logging.config.dictConfig` API を以下の完全な例で示すようなアプローチで使うことが出来ます::"

#: ../../howto/logging-cookbook.rst:1424
msgid "When this script is run, it should print something like::"
msgstr "実行すれば、このような出力になるはずです::"

#: ../../howto/logging-cookbook.rst:1429
msgid ""
"showing how the time is formatted both as local time and UTC, one for each "
"handler."
msgstr "時刻をローカル時刻と UTC の両方に書式化するのに、それぞれのハンドラにそれぞれフォーマッタを与えています。"

#: ../../howto/logging-cookbook.rst:1436
msgid "Using a context manager for selective logging"
msgstr "ロギングの選択にコンテキストマネージャを使う"

#: ../../howto/logging-cookbook.rst:1438
msgid ""
"There are times when it would be useful to temporarily change the logging "
"configuration and revert it back after doing something. For this, a context "
"manager is the most obvious way of saving and restoring the logging context."
" Here is a simple example of such a context manager, which allows you to "
"optionally change the logging level and add a logging handler purely in the "
"scope of the context manager::"
msgstr "一時的にロギングの設定を変えて、作業をした後に設定を戻せると便利なときがあります。\nこういうときの、ロギングコンテキストの保存と復元をする方法ではコンテキストマネージャを使うのが一番です。\n以下にあるのがそのためのコンテキストマネージャの簡単な例で、これを使うと、任意にロギングレベルを変更し、コンテキストマネージャのスコープ内で他に影響を及ぼさずロギングハンドラを追加できるようになります::"

#: ../../howto/logging-cookbook.rst:1471
msgid ""
"If you specify a level value, the logger's level is set to that value in the"
" scope of the with block covered by the context manager. If you specify a "
"handler, it is added to the logger on entry to the block and removed on exit"
" from the block. You can also ask the manager to close the handler for you "
"on block exit - you could do this if you don't need the handler any more."
msgstr "レベル値を指定した場合、コンテキストマネージャがカバーする with ブロックのスコープ内でロガーのレベルがその値に設定されます。\nハンドラーを指定した場合、ブロックに入るときにロガーに追加され、ブロックから抜けるときに取り除かれます。\nブロックを抜けるときに、自分で追加したハンドラをクローズするようコンテキストマネージャに指示することもできます - そのハンドラがそれ以降必要無いのであればクローズしてしまって構いません。"

#: ../../howto/logging-cookbook.rst:1477
msgid ""
"To illustrate how it works, we can add the following block of code to the "
"above::"
msgstr "どのように動作するのかを示すためには、次のコード群を上のコードに付け加えるとよいです::"

#: ../../howto/logging-cookbook.rst:1495
msgid ""
"We initially set the logger's level to ``INFO``, so message #1 appears and "
"message #2 doesn't. We then change the level to ``DEBUG`` temporarily in the"
" following ``with`` block, and so message #3 appears. After the block exits,"
" the logger's level is restored to ``INFO`` and so message #4 doesn't "
"appear. In the next ``with`` block, we set the level to ``DEBUG`` again but "
"also add a handler writing to ``sys.stdout``. Thus, message #5 appears twice"
" on the console (once via ``stderr`` and once via ``stdout``). After the "
"``with`` statement's completion, the status is as it was before so message "
"#6 appears (like message #1) whereas message #7 doesn't (just like message "
"#2)."
msgstr "最初はロガーのレベルを ``INFO`` に設定しているので、メッセージ #1 は現れ、メッセージ #2 は現れません。\n次に、その後の ``with`` ブロック内で一時的にレベルを ``DEBUG`` に変更したため、メッセージ #3 が現れます。\nそのブロックを抜けた後、ロガーのレベルは ``INFO`` に復元され、メッセージ #4 は現れません。\n次の ``with`` ブロック内では、再度レベルを ``DEBUG`` に設定し、 ``sys.stdout`` に書き出すハンドラを追加します。\nそのおかげでメッセージ #5 が 2 回 (1回は ``stderr`` を通して、もう1回は ``stdout`` を通して) コンソールに出力されます。\n``with`` 文が完了すると、前の状態になるので (メッセージ #1 のように) メッセージ #6 が現れ、(まさにメッセージ #2 のように) メッセージ #7 は現れません。"

#: ../../howto/logging-cookbook.rst:1505
msgid "If we run the resulting script, the result is as follows:"
msgstr "出来上がったスクリプトを実行すると、結果は次のようになります::"

#: ../../howto/logging-cookbook.rst:1516
msgid ""
"If we run it again, but pipe ``stderr`` to ``/dev/null``, we see the "
"following, which is the only message written to ``stdout``:"
msgstr "``stderr`` を ``/dev/null`` へパイプした状態でもう一度実行すると、次のようになり、これは ``stdout`` の方に書かれたメッセージだけが現れています:"

#: ../../howto/logging-cookbook.rst:1524
msgid "Once again, but piping ``stdout`` to ``/dev/null``, we get:"
msgstr "``stdout`` を ``/dev/null`` へパイプした状態でさらにもう一度実行すると、こうなります:"

#: ../../howto/logging-cookbook.rst:1534
msgid ""
"In this case, the message #5 printed to ``stdout`` doesn't appear, as "
"expected."
msgstr "この場合では、 ``stdout`` の方に出力されたメッセージ #5 は予想通り現れません。"

#: ../../howto/logging-cookbook.rst:1536
msgid ""
"Of course, the approach described here can be generalised, for example to "
"attach logging filters temporarily. Note that the above code works in Python"
" 2 as well as Python 3."
msgstr "もちろんここで説明した手法は、例えば一時的にロギングフィルターを取り付けたりするのに一般化できます。\n上のコードは Python 2 だけでなく Python 3 でも動くことに注意してください。"
