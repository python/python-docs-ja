# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-05 15:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/functional.rst:3
msgid "Functional Programming HOWTO"
msgstr "é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° HOWTO"

#: ../../howto/functional.rst:0
msgid "Author"
msgstr "è‘—è€…"

#: ../../howto/functional.rst:5
msgid "A. M. Kuchling"
msgstr "A. M. Kuchling"

#: ../../howto/functional.rst:0
msgid "Release"
msgstr "ãƒªãƒªãƒ¼ã‚¹"

#: ../../howto/functional.rst:6
msgid "0.32"
msgstr "0.32"

#: ../../howto/functional.rst:8
msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to the "
"concepts of functional programming, we'll look at language features such as "
":term:`iterator`\\s and :term:`generator`\\s and relevant library modules "
"such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"ã“ã®æ–‡æ›¸ã§ã¯ã€é–¢æ•°å‹ã‚¹ã‚¿ã‚¤ãƒ«ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè£…ã™ã‚‹ã®ã«ãƒ”ãƒƒã‚¿ãƒªãª Python "
"ã®æ©Ÿèƒ½ã‚’è¦‹ã¦ã¾ã‚ã‚‹ã“ã¨ã«ã—ã¾ã—ã‚‡ã†ã€‚ã¾ãšé–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¨ã„ã†æ¦‚å¿µã‚’ç´¹ä»‹ã—ãŸã‚ã¨ã€ :term:`iterator` ã‚„ "
":term:`generator` ã®ã‚ˆã†ãªè¨€èªæ©Ÿèƒ½ã€ãŠã‚ˆã³ :mod:`itertools` ã‚„ :mod:`functools` "
"ã¨ã„ã£ãŸé–¢é€£ã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ã‚‹ã“ã¨ã«ã—ã¾ã™ã€‚"

#: ../../howto/functional.rst:16
msgid "Introduction"
msgstr "ã¯ã˜ã‚ã«"

#: ../../howto/functional.rst:18
msgid ""
"This section explains the basic concept of functional programming; if you're"
" just interested in learning about Python language features, skip to the "
"next section on :ref:`functional-howto-iterators`."
msgstr ""
"ã“ã®ç« ã¯é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®åŸºæœ¬æ¦‚å¿µã‚’èª¬æ˜ã—ã¾ã™; Python ã®è¨€èªæ©Ÿèƒ½ã«ã¤ã„ã¦ã ã‘çŸ¥ã‚ŠãŸã„äººã¯ã€æ¬¡ã®ç« ã® :ref:`functional-"
"howto-iterators` ã¾ã§é£›ã°ã—ã¦ãã ã•ã„ã€‚"

#: ../../howto/functional.rst:22
msgid ""
"Programming languages support decomposing problems in several different "
"ways:"
msgstr "ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¨ã¯å•é¡Œã‚’åˆ†è§£ã™ã‚‹ã‚‚ã®ã§ã™ãŒã€å„è¨€èªãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹åˆ†è§£æ–¹æ³•ã«ã¯ã„ãã¤ã‹ã®ç¨®é¡ãŒã‚ã‚Šã¾ã™:"

#: ../../howto/functional.rst:24
msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input.  C,"
" Pascal, and even Unix shells are procedural languages."
msgstr ""
"ã»ã¨ã‚“ã©ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¯ **æ‰‹ç¶šãå‹** ã§ã™: ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€å…¥åŠ›ã«å¯¾ã—ã¦è¡Œã†ã¹ãã“ã¨ã‚’ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã«æ•™ãˆã‚‹æŒ‡ç¤ºãƒªã‚¹ãƒˆã¨ãªã‚Šã¾ã™ã€‚ C, "
"Pascal, ã•ã‚‰ã«ã¯ Unix ã‚·ã‚§ãƒ«ã¾ã§ã‚‚ãŒæ‰‹ç¶šãå‹è¨€èªã«å…¥ã‚Šã¾ã™ã€‚"

#: ../../howto/functional.rst:28
msgid ""
"In **declarative** languages, you write a specification that describes the "
"problem to be solved, and the language implementation figures out how to "
"perform the computation efficiently.  SQL is the declarative language you're"
" most likely to be familiar with; a SQL query describes the data set you "
"want to retrieve, and the SQL engine decides whether to scan tables or use "
"indexes, which subclauses should be performed first, etc."
msgstr ""
"**å®£è¨€å‹** è¨€èªã§æ›¸ãã®ã¯ã€è§£ãã¹ãå•é¡Œã‚’èª¬æ˜ã™ã‚‹ä»•æ§˜æ›¸ã§ã‚ã£ã¦ã€ãã‚Œã‚’åŠ¹ç‡çš„ã«è¨ˆç®—å‡¦ç†ã™ã‚‹æ–¹æ³•ã‚’è¦‹ä»˜ã‘ã‚‹ã®ã¯è¨€èªå®Ÿè£…ã®å½¹ç›®ã§ã™ã€‚SQL "
"ã¯ãŠãã‚‰ãä¸€ç•ªã‚ˆãçŸ¥ã‚‰ã‚ŒãŸå®£è¨€å‹è¨€èªã§ã™; SQL "
"ã®ã‚¯ã‚¨ãƒªã¯å–å¾—ã—ãŸã„ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’èª¬æ˜ã—ã¦ã„ã‚‹ã ã‘ã§ã€ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’èµ°æŸ»ã™ã‚‹ã‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ã†ã‹ã€ã©ã®ã‚µãƒ–ã‚¯ãƒ­ãƒ¼ã‚ºã‹ã‚‰å®Ÿè¡Œã™ã‚‹ã‹ç­‰ã€…ã‚’æ±ºã‚ã‚‹ã®ã¯ SQL "
"ã‚¨ãƒ³ã‚¸ãƒ³ãªã®ã§ã™ã€‚"

#: ../../howto/functional.rst:35
msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this internal "
"state in some way. Smalltalk and Java are object-oriented languages.  C++ "
"and Python are languages that support object-oriented programming, but don't"
" force the use of object-oriented features."
msgstr ""
"**ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘** "
"ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é›†ã¾ã‚Šã‚’æ“ä½œã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯å†…éƒ¨çŠ¶æ…‹ãŒã‚ã‚Šã€ãã®çŠ¶æ…‹ã‚’èª¿ã¹ãŸã‚Šè‰²ã€…ã¨å¤‰æ›´ã—ãŸã‚Šã™ã‚‹ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚Smalltalk"
" ã‚„ Java ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘è¨€èªã§ã™ã€‚ C++ ã¨ Python "
"ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ãŒã€é–¢é€£ã™ã‚‹æ©Ÿèƒ½ã‚’ä½¿ã‚ãªãã¦ã‚‚æ§‹ã‚ãªã„ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../howto/functional.rst:41
msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have any "
"internal state that affects the output produced for a given input.  Well-"
"known functional languages include the ML family (Standard ML, OCaml, and "
"other variants) and Haskell."
msgstr ""
"**é–¢æ•°å‹** "
"ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯å•é¡Œã‚’ã„ãã¤ã‹ã®é–¢æ•°ã«ã‚ã‘ã¦è€ƒãˆã¾ã™ã€‚ç†æƒ³çš„ã«è¨€ã†ã¨ã€é–¢æ•°ã¯å…¥åŠ›ã‚’å—ã‘ã¦å‡ºåŠ›ã‚’åãã ã‘ã§ã€åŒã˜å…¥åŠ›ã«å¯¾ã—ã¦ç•°ãªã‚‹å‡ºåŠ›ã‚’ã™ã‚‹ã‚ˆã†ãªå†…éƒ¨çŠ¶æ…‹ã‚’ä¸€åˆ‡æŒã¡ã¾ã›ã‚“ã€‚æœ‰åãªé–¢æ•°å‹è¨€èªã«ã¯"
" ML ä¸€å®¶ (Standard ML, OCaml ç­‰ã€…) ã¨ Haskell ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/functional.rst:47
msgid ""
"The designers of some computer languages choose to emphasize one particular "
"approach to programming.  This often makes it difficult to write programs "
"that use a different approach.  Other languages are multi-paradigm languages"
" that support several different approaches. Lisp, C++, and Python are multi-"
"paradigm; you can write programs or libraries that are largely procedural, "
"object-oriented, or functional in all of these languages.  In a large "
"program, different sections might be written using different approaches; the"
" GUI might be object-oriented while the processing logic is procedural or "
"functional, for example."
msgstr ""
"è¨­è¨ˆè€…ãŒç‰¹å®šã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’å¼·èª¿ã™ã‚‹ã“ã¨ã«ã—ãŸè¨€èªã‚‚ã‚ã‚Šã¾ã™ãŒã€ãã†ã™ã‚‹ã¨å¤§æŠµã¯ã€åˆ¥ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’ä½¿ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãã«ãããªã‚Šã¾ã™ã€‚è¤‡æ•°ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«å¯¾å¿œã—ãŸè¨€èªã‚‚ã‚ã‚Šã€Lisp,"
" C++, Python ã¯ãã†ã—ãŸãƒãƒ«ãƒãƒ‘ãƒ©ãƒ€ã‚¤ãƒ è¨€èªã§ã™; "
"ã“ã®ä¸­ã®ã©ã‚Œã‚’ä½¿ã£ã¦ã‚‚ã€åŸºæœ¬çš„ã«æ‰‹ç¶šãå‹ãªã€ã¾ãŸã¯åŸºæœ¬çš„ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ãªã€ã¨ã‹ã€åŸºæœ¬çš„ã«é–¢æ•°å‹ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚å¤§ããªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã€å„éƒ¨ã§åˆ¥ã€…ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’ä½¿ã£ã¦æ›¸ãã“ã¨ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“;"
" GUI ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã§ã€ã§ã‚‚å‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯ã¯æ‰‹ç¶šãå‹ã‚„é–¢æ•°å‹ã§ã€ã¨ã„ã£ãŸã‚ˆã†ã«ã§ã™ã€‚"

#: ../../howto/functional.rst:58
msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional style "
"discourages functions with side effects that modify internal state or make "
"other changes that aren't visible in the function's return value.  Functions"
" that have no side effects at all are called **purely functional**.  "
"Avoiding side effects means not using data structures that get updated as a "
"program runs; every function's output must only depend on its input."
msgstr ""
"é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã€å…¥åŠ›ã¯ä¸€é€£ã®é–¢æ•°ã‚’é€šã£ã¦æµã‚Œã¦ã„ãã¾ã™ã€‚ãã‚Œãã‚Œã®é–¢æ•°ã¯å…¥åŠ›ã«ä½•ã‚‰ã‹ã®ä½œæ¥­ã‚’ã—ã¦å‡ºåŠ›ã—ã¾ã™ã€‚é–¢æ•°å‹ã‚¹ã‚¿ã‚¤ãƒ«ã«ãŠã„ã¦ã¯ã€å†…éƒ¨çŠ¶æ…‹ã‚’å¤‰ãˆã¦ã—ã¾ã£ãŸã‚Šã€è¿”ã‚Šå€¤ã«ç¾ã‚Œãªã„å¤‰æ›´ã‚’ã—ãŸã‚Šã¨ã„ã£ãŸå‰¯ä½œç”¨ã®ã‚ã‚‹é–¢æ•°ã¯ã‚„ã‚ã‚‹ã‚ˆã†ã«è¨€ã‚ã‚Œã¦ã„ã¾ã™ã€‚å‰¯ä½œç”¨ã®ã¾ã£ãŸããªã„é–¢æ•°ã¯"
" **ç´”ç²‹é–¢æ•°å‹** "
"ã§ã‚ã‚‹ã¨ã•ã‚Œã¾ã™ã€‚å‰¯ä½œç”¨ã‚’ãªãã™ã¨ã„ã†ã“ã¨ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡Œä¸­ã«é †æ¬¡å¤‰åŒ–ã—ã¦ã„ããƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’æŒãŸãªã„ã€ã¤ã¾ã‚Šå„é–¢æ•°ã®å‡ºåŠ›ã¯ãã®å…¥åŠ›ã«ã—ã‹å½±éŸ¿ã‚’å—ã‘ã¦ã¯ã„ã‘ãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../howto/functional.rst:66
msgid ""
"Some languages are very strict about purity and don't even have assignment "
"statements such as ``a=3`` or ``c = a + b``, but it's difficult to avoid all"
" side effects.  Printing to the screen or writing to a disk file are side "
"effects, for example.  For example, in Python a call to the :func:`print` or"
" :func:`time.sleep` function both return no useful value; they're only "
"called for their side effects of sending some text to the screen or pausing "
"execution for a second."
msgstr ""
"ã“ã®ç´”ç²‹æ€§ã‚’å®ˆã‚‹é¢ã§éå¸¸ã«å³ã—ã„è¨€èªã‚‚ã‚ã‚Šã€ãã†ã—ãŸè¨€èªã«ã¯ ``a=3`` ã‚„ ``c = a + b`` "
"ã¨ã„ã£ãŸä»£å…¥æ–‡ã•ãˆã‚ã‚Šã¾ã›ã‚“ã€‚ã—ã‹ã—å‰¯ä½œç”¨ã‚’å®Œå…¨ã«ãªãã™ã®ã¯é›£ã—ã„ã‚‚ã®ã§ã€ãŸã¨ãˆã°ç”»é¢è¡¨ç¤ºã‚„ãƒ‡ã‚£ã‚¹ã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®æ›¸ãè¾¼ã¿ã‚‚å‰¯ä½œç”¨ãªã®ã§ã™ã€‚ Python"
" ã§è¨€ã†ã¨ã€ãŸã¨ãˆã° :func:`print` ã‚„ :func:`time.sleep` é–¢æ•°ã®å‘¼ã³å‡ºã—ã¯ã©ã¡ã‚‰ã‚‚æ„å‘³ã‚ã‚‹å€¤ã‚’è¿”ã—ã¾ã›ã‚“; "
"ãŸã ç”»é¢ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’é€ã£ãŸã‚Šå‹•ä½œã‚’ 1 ç§’æ­¢ã‚ãŸã‚Šã¨ã„ã£ãŸå‰¯ä½œç”¨ã®ãŸã‚ã ã‘ã«å‘¼ã°ã‚Œã‚‹ã®ã§ã™ã€‚"

#: ../../howto/functional.rst:74
msgid ""
"Python programs written in functional style usually won't go to the extreme "
"of avoiding all I/O or all assignments; instead, they'll provide a "
"functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have "
"other side effects."
msgstr ""
"é–¢æ•°å‹ã‚¹ã‚¿ã‚¤ãƒ«ã§æ›¸ã„ãŸ Python ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ãµã¤ã†ã€I/O "
"ã‚„ä»£å…¥ã‚’å®Œå…¨ã«ãªãã™ã¨ã„ã£ãŸæ¥µç«¯ãªã¨ã“ã‚ã¾ã§ã¯è¡Œã‹ãšã«ã€é–¢æ•°å‹ã£ã½ãè¦‹ãˆã‚‹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¤ã¤ã‚‚å†…éƒ¨ã§ã¯éé–¢æ•°å‹ã®æ©Ÿèƒ½ã‚’ä½¿ã„ã¾ã™ã€‚ãŸã¨ãˆã°ã€é–¢æ•°å†…ã§ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®ä»£å…¥ã¯ä½¿ã„ã¾ã™ãŒã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¯å¤‰æ›´ã›ãšã€ä»–ã®å‰¯ä½œç”¨ã‚‚ãªã„ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ã®ã§ã™ã€‚"

#: ../../howto/functional.rst:80
msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, and "
"programs consist of making the right set of state changes.  Functional "
"programming wants to avoid state changes as much as possible and works with "
"data flowing between functions.  In Python you might combine the two "
"approaches by writing functions that take and return instances representing "
"objects in your application (e-mail messages, transactions, etc.)."
msgstr ""
"é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®åå¯¾ã¨è€ƒãˆã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã«ãŠã„ã¦ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å†…éƒ¨çŠ¶æ…‹ã¨ãã‚Œã‚’å¤‰æ›´ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚³ãƒ¼ãƒ«ã®å…¥ã£ãŸã‚«ãƒ—ã‚»ãƒ«ã§ã‚ã‚Šã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ãã®çŠ¶æ…‹ã‚’é©æ­£ã«å¤‰åŒ–ã•ã›ã¦ã„ãæ‰‹é †ã§ã™ã€‚ä¸€æ–¹ã§ã€é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯å¯èƒ½ãªã‹ãã‚ŠçŠ¶æ…‹ã®å¤‰æ›´ã‚’é¿ã‘ã€é–¢æ•°ã©ã†ã—ã®é–“ã‚’æµã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã ã‘ã‚’æ‰±ãŠã†ã¨ã—ã¾ã™ã€‚Python"
" ã§ã¯ã“ã®äºŒã¤ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’çµã³åˆã‚ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ãƒ¡ãƒ¼ãƒ«ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã€ç­‰ã€…) "
"ã‚’è¡¨ç¾ã—ãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã€é–¢æ•°ãŒå—ã‘æ¸¡ã—ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ã®ã§ã™ã€‚"

#: ../../howto/functional.rst:89
msgid ""
"Functional design may seem like an odd constraint to work under.  Why should"
" you avoid objects and side effects?  There are theoretical and practical "
"advantages to the functional style:"
msgstr ""
"é–¢æ•°å‹ãƒ‡ã‚¶ã‚¤ãƒ³ã¯ã€ã‚ã‘ã®ã‚ã‹ã‚‰ãªã„åˆ¶ç´„ã«è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã©ã†ã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚å‰¯ä½œç”¨ã‚‚ãªã„ã»ã†ãŒè‰¯ã„ã®ã§ã—ã‚‡ã†ã‹ã€‚å®Ÿã¯ã€é–¢æ•°å‹ã‚¹ã‚¿ã‚¤ãƒ«ã«ã¯ç†è«–ã¨å®Ÿè·µã«åŸºã¥ãæ¬¡ã®åˆ©ç‚¹ãŒã‚ã‚‹ã®ã§ã™:"

#: ../../howto/functional.rst:93
msgid "Formal provability."
msgstr "å½¢å¼çš„è¨¼æ˜å¯èƒ½æ€§ã€‚"

#: ../../howto/functional.rst:94
msgid "Modularity."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼æ€§ã€‚"

#: ../../howto/functional.rst:95
msgid "Composability."
msgstr "çµåˆæ€§ã€‚"

#: ../../howto/functional.rst:96
msgid "Ease of debugging and testing."
msgstr "ãƒ‡ãƒãƒƒã‚°ã‚„ãƒ†ã‚¹ãƒˆã®ç°¡å˜ã•ã€‚"

#: ../../howto/functional.rst:100
msgid "Formal provability"
msgstr "å½¢å¼çš„è¨¼æ˜å¯èƒ½æ€§"

#: ../../howto/functional.rst:102
msgid ""
"A theoretical benefit is that it's easier to construct a mathematical proof "
"that a functional program is correct."
msgstr "ç†è«–é¢ã®åˆ©ç‚¹ã¨ã—ã¦ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒæ­£ã—ã„ã“ã¨ã®æ•°å­¦çš„è¨¼æ˜ã‚’ä»–ã‚ˆã‚Šç°¡å˜ã«æ§‹ç¯‰ã§ãã‚‹ã¨ã„ã†ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/functional.rst:105
msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces "
"the right result for all possible inputs."
msgstr ""
"ç ”ç©¶è€…ãŸã¡ã¯é•·ã„ã‚ã„ã ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒæ­£ã—ã„ã“ã¨ã‚’æ•°å­¦çš„ã«è¨¼æ˜ã™ã‚‹æ–¹æ³•ã®ç™ºè¦‹ã«è¡€é“ã‚’ã‚ã’ã¦ãã¾ã—ãŸã€‚ã“ã‚Œã¯ã€è‰²ã€…ãªå…¥åŠ›ã§ãƒ†ã‚¹ãƒˆã—ã¦å‡ºåŠ›ãŒæ­£ã—ã‹ã£ãŸã‹ã‚‰ã¾ã‚æ­£ã—ã„ã ã‚ã†ã€ã¨çµè«–ã™ã‚‹ã®ã¨ã‚‚é•ã„ã¾ã™ã—ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚“ã§ã€Œé–“é•ã„ã¯ãªã•ãã†ã ã€ã¨è¨€ã†ã®ã¨ã‚‚åˆ¥ã®è©±ã§ã™;"
" ç›®æŒ‡ã™ã®ã¯ã€å‡ºç¾ã—ã†ã‚‹å…¥åŠ›ã™ã¹ã¦ã«å¯¾ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒæ­£ã—ã„çµæœã‚’å‡ºã™ã“ã¨ã®å³å¯†ãªè¨¼æ˜ãªã®ã§ã™ã€‚"

#: ../../howto/functional.rst:112
msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's variables "
"that are always true.  For each line of code, you then show that if "
"invariants X and Y are true **before** the line is executed, the slightly "
"different invariants X' and Y' are true **after** the line is executed.  "
"This continues until you reach the end of the program, at which point the "
"invariants should match the desired conditions on the program's output."
msgstr ""
"ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¨¼æ˜ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ã®ã¯ **ä¸å¤‰å¼** "
"ã‚’æ›¸ãå‡ºã—ã¦ã„ãã¨ã„ã†ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã§ã€ä¸å¤‰å¼ã¨ã¯å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã‚„ãƒ—ãƒ­ã‚°ãƒ©ãƒ å¤‰æ•°ã®ã†ã¡å¸¸ã«çœŸã§ã‚ã‚‹æ€§è³ªã®ã“ã¨ã§ã™ã€‚ã‚³ãƒ¼ãƒ‰ã®ä¸€è¡Œä¸€è¡Œã§ã€ **å®Ÿè¡Œå‰** ã®ä¸å¤‰å¼"
" X ã¨ Y ãŒçœŸãªã‚‰ **å®Ÿè¡Œå¾Œã«** ã¡ã‚‡ã£ã¨é•ã†ä¸å¤‰å¼ X' ã¨ Y' "
"ãŒçœŸã«ãªã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ãã€ã“ã‚Œã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®çµ‚ã‚ã‚Šã¾ã§ç¶šã‘ã‚‹ã‚ã‘ã§ã™ã€‚ã™ã‚‹ã¨æœ€çµ‚çš„ãªä¸å¤‰å¼ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å‡ºåŠ›ã«åˆã£ãŸæ¡ä»¶ã«ãªã£ã¦ã„ã‚‹ã¯ãšã§ã™ã€‚"

#: ../../howto/functional.rst:120
msgid ""
"Functional programming's avoidance of assignments arose because assignments "
"are difficult to handle with this technique; assignments can break "
"invariants that were true before the assignment without producing any new "
"invariants that can be propagated onward."
msgstr ""
"é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãŒä»£å…¥ã‚’å«Œã†ã®ã¯ã€ã“ã®ä¸å¤‰å¼ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã§ã¯ä»£å…¥ã‚’æ‰±ã„ã«ãã„ã‹ã‚‰ã§ã™; "
"ä»£å…¥ã¯ã€ãã‚Œã¾ã§çœŸã ã£ãŸä¸å¤‰å¼ã‚’å£Šã—ã¦ãŠã„ã¦ã€è‡ªåˆ†ã¯æ¬¡ã®è¡Œã«ä¼ãˆã¦ã‚†ã‘ã‚‹ä¸å¤‰å¼ã‚’ç”Ÿã¿å‡ºã•ãªã„ã“ã¨ãŒã‚ã‚‹ã®ã§ã™ã€‚"

#: ../../howto/functional.rst:125
msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that are "
"several pages long; the proof of correctness for a moderately complicated "
"program would be enormous, and few or none of the programs you use daily "
"(the Python interpreter, your XML parser, your web browser) could be proven "
"correct.  Even if you wrote down or generated a proof, there would then be "
"the question of verifying the proof; maybe there's an error in it, and you "
"wrongly believe you've proved the program correct."
msgstr ""
"æ®‹å¿µãªãŒã‚‰ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®è¨¼æ˜ã¯ã ã„ãŸã„å®Ÿéš›çš„ã§ã‚‚ã‚ã‚Šã¾ã›ã‚“ã—ã€Python "
"ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã«ã‚‚é–¢ä¿‚ã‚ã‚Šã¾ã›ã‚“ã€‚æœ¬å½“ã«ç°¡å˜ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã‚‚ã€è¨¼æ˜ã«ã¯æ•°ãƒšãƒ¼ã‚¸ã«ã‚ãŸã‚‹è«–æ–‡ãŒå¿…è¦ãªã®ã§ã™; "
"ã‚ã‚‹ç¨‹åº¦ã®è¤‡é›‘ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã‚‚ã†å°‹å¸¸ã§ãªã„é•·ã•ã«ãªã£ã¦ã—ã¾ã†ã®ã§ã€æ—¥å¸¸ã§ä½¿ã£ã¦ã„ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ  (Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã€XML "
"ãƒ‘ãƒ¼ã‚µã€ã‚¦ã‚§ãƒ–ãƒ–ãƒ©ã‚¦ã‚¶) "
"ã¯ã»ã¨ã‚“ã©ã€ã‚ã‚‹ã„ã¯ã™ã¹ã¦ã€æ­£ã—ã•ã‚’è¨¼æ˜ã™ã‚‹ã®ã¯ä¸å¯èƒ½ã§ã—ã‚‡ã†ã€‚ä»®ã«è¨¼æ˜ã‚’æ›¸ãå‡ºã—ãŸã‚Šç”Ÿæˆã—ãŸã‚Šã—ã¦ã‚‚ã€ãã®è¨¼æ˜ã‚’æ¤œè¨¼ã™ã‚‹ãŸã‚ã®ç–‘ã„ãŒæ®‹ã‚Šã¾ã™; "
"è¨¼æ˜ã«é–“é•ã„ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œãšã€ãã®å ´åˆã¯è¨¼æ˜ã—ãŸã¨è‡ªåˆ†ã§å‹æ‰‹ã«æ€ã„è¾¼ã‚“ã§ã„ãŸã ã‘ã«ãªã‚‹ã®ã§ã™ã€‚"

#: ../../howto/functional.rst:136
msgid "Modularity"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼æ€§"

#: ../../howto/functional.rst:138
msgid ""
"A more practical benefit of functional programming is that it forces you to "
"break apart your problem into small pieces.  Programs are more modular as a "
"result.  It's easier to specify and write a small function that does one "
"thing than a large function that performs a complicated transformation.  "
"Small functions are also easier to read and to check for errors."
msgstr ""
"ã‚ˆã‚Šå®Ÿç”¨çš„ã«ã¯ã€é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ã™ã‚‹ã¨å•é¡Œã‚’ç´°ã‹ãåˆ‡ã‚Šåˆ†ã‘ã‚‹ã“ã¨ã«ãªã‚‹ã¨ã„ã†åˆ©ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚çµæœã¨ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼åŒ–ã•ã‚Œã¾ã™ã€‚è¤‡é›‘ãªå¤‰å½¢ã‚’æ–½ã™å¤§ããªé–¢æ•°ã‚’æ›¸ãã‚ˆã‚Šã€ä¸€ã¤ã®ã“ã¨ã«çµã£ã¦ãã‚Œã ã‘ã‚’ã™ã‚‹å°ã•ãªé–¢æ•°ã®ã»ã†ãŒæ›¸ãã‚„ã™ã„ã‚‚ã®ã§ã™ã€‚ãã‚Œã«ã€å°ã•ã„ã»ã†ãŒèª­ã‚€ã®ã‚‚ã‚¨ãƒ©ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã®ã‚‚ç°¡å˜ã§ã™ã€‚"

#: ../../howto/functional.rst:146
msgid "Ease of debugging and testing"
msgstr "ãƒ‡ãƒã‚°ã‚„ãƒ†ã‚¹ãƒˆã®ç°¡å˜ã•"

#: ../../howto/functional.rst:148
msgid "Testing and debugging a functional-style program is easier."
msgstr "ãƒ†ã‚¹ãƒˆã‚„ãƒ‡ãƒã‚°ã‚‚é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãªã‚‰ç°¡å˜ã§ã™ã€‚"

#: ../../howto/functional.rst:150
msgid ""
"Debugging is simplified because functions are generally small and clearly "
"specified.  When a program doesn't work, each function is an interface point"
" where you can check that the data are correct.  You can look at the "
"intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"é–¢æ•°ãŒä¸€èˆ¬çš„ã«å°ã•ãã¦æ˜ç¢ºã«æ„å‘³ä»˜ã‘ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ãƒ‡ãƒã‚°æ–¹æ³•ã¯å˜ç´”ã§ã™ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒæ­£ã—ãå‹•ã‹ãªã„ã¨ãã«ã¯ã€é–¢æ•°ã²ã¨ã¤ã²ã¨ã¤ãŒãƒ‡ãƒ¼ã‚¿ã®æ­£ã—ã•ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãƒã‚¤ãƒ³ãƒˆã«ãªã‚‹ã®ã§ã€ãã‚Œãã‚Œã®æ™‚ç‚¹ã«ãŠã‘ã‚‹å…¥åŠ›ã¨å‡ºåŠ›ã‚’è¦‹ã¦ã„ã‘ã°ã€ãƒã‚°ã®åŸå› ã¨ãªã‚‹é–¢æ•°ã‚’ç´ æ—©ãåˆ‡ã‚Šå‡ºã™ã“ã¨ãŒã§ãã‚‹ã®ã§ã™ã€‚"

#: ../../howto/functional.rst:155
msgid ""
"Testing is easier because each function is a potential subject for a unit "
"test. Functions don't depend on system state that needs to be replicated "
"before running a test; instead you only have to synthesize the right input "
"and then check that the output matches expectations."
msgstr ""
"ã²ã¨ã¤ã²ã¨ã¤ã®é–¢æ•°ãŒãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã®å¯¾è±¡ã«ãªã‚Šå¾—ã‚‹ã‚ã‘ã§ã™ã‹ã‚‰ã€ãƒ†ã‚¹ãƒˆã‚‚ç°¡å˜ã§ã™ã€‚é–¢æ•°ã¯ã‚·ã‚¹ãƒ†ãƒ ã®çŠ¶æ…‹ã«ä¾å­˜ã—ã¾ã›ã‚“ã®ã§ã€ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œå‰ã«ãã†ã—ãŸçŠ¶æ…‹ã‚’å†ç¾ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“;"
" å˜ã«é©åˆ‡ãªå…¥åŠ›ã‚’åˆæˆã—ã¦ã€å‡ºåŠ›ãŒæœŸå¾…ã©ãŠã‚Šã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã ã‘ã§è‰¯ã„ã®ã§ã™ã€‚"

#: ../../howto/functional.rst:162
msgid "Composability"
msgstr "çµåˆæ€§"

#: ../../howto/functional.rst:164
msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will be "
"unavoidably specialized to a particular application, but others will be "
"useful in a wide variety of programs.  For example, a function that takes a "
"directory path and returns all the XML files in the directory, or a function"
" that takes a filename and returns its contents, can be applied to many "
"different situations."
msgstr ""
"é–¢æ•°å‹ã‚¹ã‚¿ã‚¤ãƒ«ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½œã£ã¦ã„ã‚‹ã¨ã€è‰²ã€…ãªå…¥åŠ›ã‚„å‡ºåŠ›ã®ãŸã‚ã«è‰²ã€…ãªé–¢æ•°ã‚’æ›¸ãã“ã¨ã«ãªã‚Šã¾ã™ã€‚ä»•æ–¹ãªãç‰¹å®šã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ç‰¹åŒ–ã—ãŸé–¢æ•°ã‚’æ›¸ãã“ã¨ã‚‚ã‚ã‚‹ã§ã—ã‚‡ã†ã‘ã‚Œã©ã€åºƒç¯„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ä½¿ãˆã‚‹é–¢æ•°ã‚‚ã‚ã‚‹ã“ã¨ã§ã—ã‚‡ã†ã€‚ãŸã¨ãˆã°ã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã‚’å—ã‘å–ã£ã¦ãã®ä¸­ã®"
" XML ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’è¿”ã™é–¢æ•°ã‚„ã€ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å—ã‘å–ã£ã¦å†…å®¹ã‚’è¿”ã™é–¢æ•°ãªã©ã¯ã€å¤šæ§˜ãªå ´é¢ã«é©ç”¨ã§ããã†ã§ã™ã€‚"

#: ../../howto/functional.rst:171
msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new configuration"
" and writing a few functions specialized for the current task."
msgstr ""
"æ™‚ãŸã¤ã†ã¡ã«è‡ªåˆ†ã®ç‰¹è£½ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚„ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãŒå……å®Ÿã—ã¦ãã‚‹ã¨ã€æ–°ã—ã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚‚ã€æ—¢å­˜ã®é–¢æ•°ã‚’èª¿æ•´ã—ã¦å°‘ã—ä»Šå›ã«ç‰¹åŒ–ã—ãŸé–¢æ•°ã‚’æ›¸ãã ã‘ã§çµ„ã¿ç«‹ã¦ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/functional.rst:179
msgid "Iterators"
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ (iterator)"

#: ../../howto/functional.rst:181
msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr "ã¾ãšã¯é–¢æ•°å‹ã‚¹ã‚¿ã‚¤ãƒ«ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãéš›ã®åŸºç¤ã¨ãªã‚‹é‡è¦ãª Python æ©Ÿèƒ½ã‹ã‚‰è¦‹ã¦ã„ãã¾ã—ã‚‡ã†: ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã§ã™ã€‚"

#: ../../howto/functional.rst:184
msgid ""
"An iterator is an object representing a stream of data; this object returns "
"the data one element at a time.  A Python iterator must support a method "
"called :meth:`~iterator.__next__` that takes no arguments and always returns"
" the next element of the stream.  If there are no more elements in the "
"stream, :meth:`~iterator.__next__` must raise the :exc:`StopIteration` "
"exception. Iterators don't have to be finite, though; it's perfectly "
"reasonable to write an iterator that produces an infinite stream of data."
msgstr ""
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯é€£ç¶šãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¾ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™; ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸€åº¦ã«ä¸€ã¤ã®è¦ç´ ãšã¤ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ Python ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ "
":meth:`~iterator.__next__` "
"ã¨ã„ã†ã€å¼•æ•°ã‚’å–ã‚‰ãšæ¬¡ã®è¦ç´ ã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å¿…ãšã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«è¦ç´ ãŒæ®‹ã£ã¦ã„ãªã„å ´åˆã€ "
":meth:`~iterator.__next__` ã¯å¿…ãš :exc:`StopIteration` "
"ä¾‹å¤–ã‚’å‡ºã—ã¾ã™ã€‚ãŸã ã—ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®é•·ã•ã¯æœ‰é™ã§ã‚ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“; ç„¡é™ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”Ÿæˆã™ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’æ›¸ãã¨ã„ã†ã®ã‚‚ã¾ã£ãŸãç†ã«é©ã£ãŸã“ã¨ã§ã™ã€‚"

#: ../../howto/functional.rst:192
msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to "
"return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  Several "
"of Python's built-in data types support iteration, the most common being "
"lists and dictionaries.  An object is called :term:`iterable` if you can get"
" an iterator for it."
msgstr ""
"ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã® :func:`iter` é–¢æ•°ã¯ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘ã¦ã€ ãã®ä¸­èº«ã‚„è¦ç´ ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ãã†ã¨ã—ã¾ã™ã€‚å¼•æ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ "
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œã‚Œãªã„ã¨ãã¯ :exc:`TypeError` ã‚’æŠ•ã’ã¾ã™ã€‚Python ã® "
"ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ãªãƒ‡ãƒ¼ã‚¿å‹ã«ã‚‚ã„ãã¤ã‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿åŒ–ã®ã§ãã‚‹ã‚‚ã®ãŒã‚ã‚Šã€ ä¸­ã§ã‚‚ã‚ˆãä½¿ã‚ã‚Œã‚‹ã®ã¯ãƒªã‚¹ãƒˆã¨è¾æ›¸ã§ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œã‚Œã‚‹ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ "
":term:`iterable` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨å‘¼ã°ã‚Œã¾ã™ã€‚"

#: ../../howto/functional.rst:199
msgid "You can experiment with the iteration interface manually:"
msgstr "æ‰‹ã‚’å‹•ã‹ã—ã¦ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿åŒ–ã®å®Ÿé¨“ã‚’ã—ã¦ã¿ã¾ã—ã‚‡ã†:"

#: ../../howto/functional.rst:217
msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the :keyword:`for` statement.  In the statement ``for X in "
"Y``, Y must be an iterator or some object for which :func:`iter` can create "
"an iterator.  These two statements are equivalent::"
msgstr ""
"Python ã¯è‰²ã€…ãªæ–‡è„ˆã§ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æœŸå¾…ã—ã¾ã™ãŒã€ æœ€ã‚‚é‡è¦ãªã®ã¯ :keyword:`for` æ–‡ã§ã™ã€‚ ``for X in "
"Y`` ã¨ã„ã†æ–‡ã® Y ã¯ã€ ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‹ã€ã‚ã‚‹ã„ã¯ :func:`iter` "
"ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚æ¬¡ã®äºŒã¤ã¯åŒã˜æ„å‘³ã«ãªã‚Šã¾ã™::"

#: ../../howto/functional.rst:229
msgid ""
"Iterators can be materialized as lists or tuples by using the :func:`list` "
"or :func:`tuple` constructor functions:"
msgstr ""
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ :func:`list` ã‚„ :func:`tuple` ã¨ã„ã£ãŸã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿é–¢æ•°ã‚’ä½¿ã£ã¦ãƒªã‚¹ãƒˆã‚„ã‚¿ãƒ—ãƒ«ã«å…·ç¾åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™:"

#: ../../howto/functional.rst:238
msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ã‚‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã«å¯¾å¿œã—ã¦ã„ã¾ã™: ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒ N "
"å€‹ã®è¦ç´ ã‚’è¿”ã™ã¨ã„ã†ã“ã¨ãŒäº‹å‰ã«ã‚ã‹ã£ã¦ã„ã‚Œã°ã€N-ã‚¿ãƒ—ãƒ«ã«ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™:"

#: ../../howto/functional.rst:247
msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The "
"``\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator.  "
"You'll run into obvious problems if the iterator is infinite; :func:`max`, "
":func:`min` will never return, and if the element X never appears in the "
"stream, the ``\"in\"`` and ``\"not in\"`` operators won't return either."
msgstr ""
"ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•°ã® :func:`max` ã‚„ :func:`min` ãªã©ã‚‚ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ä¸€ã¤ã ã‘ã‚’å¼•æ•°ã«å–ã£ã¦æœ€å¤§ãƒ»æœ€å°ã®è¦ç´ ã‚’è¿”ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ "
"``\"in\"`` ã‚„ ``\"not in\"`` æ¼”ç®—å­ã‚‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã«å¯¾å¿œã—ã¦ã„ã¾ã™: ``X in iterator`` "
"ã¯ã€ãã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‹ã‚‰è¿”ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã« X ãŒã‚ã‚Œã°çœŸã§ã™ã€‚ã§ã™ã‹ã‚‰ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒç„¡é™é•·ã ã¨ã€å½“ç„¶ãªãŒã‚‰å•é¡Œã«ç›´é¢ã—ã¾ã™; :func:`max`, "
":func:`min` ã¯ã„ã¤ã¾ã§ã‚‚æˆ»ã£ã¦æ¥ã¾ã›ã‚“ã—ã€ è¦ç´  X ãŒã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å‡ºã¦ã“ãªã‘ã‚Œã° ``\"in\"``, ``\"not in\"`` "
"ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ã‚‚æˆ»ã‚Šã¾ã›ã‚“ã€‚"

#: ../../howto/functional.rst:255
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it.  Iterator "
"objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the :meth:`~iterator.__next__` method.  "
"Functions may therefore consume all of the iterator's output, and if you "
"need to do something different with the same stream, you'll have to create a"
" new iterator."
msgstr ""
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯æ¬¡ã«é€²ã‚€ã“ã¨ã—ã‹ã§ãã¾ã›ã‚“ã®ã§ã”æ³¨æ„ãã ã•ã„; "
"å‰ã®è¦ç´ ã‚’æ‰‹ã«å…¥ã‚ŒãŸã‚Šã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆã—ãŸã‚Šã€ã‚³ãƒ”ãƒ¼ã‚’ä½œã£ãŸã‚Šã™ã‚‹æ–¹æ³•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ãã†ã—ãŸè¿½åŠ æ©Ÿèƒ½ã‚’ "
"æŒã¤ã“ã¨ã¯ã§ãã¾ã™ãŒã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã¯ :meth:`~iterator.__next__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã®ã“ã¨ã—ã‹æŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã§ã™ã‹ã‚‰é–¢æ•°ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®å‡ºåŠ›ã‚’ä½¿ã„å°½ãã—ã¦ ã—ã¾ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã—ã€åŒã˜ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ä½•ã‹åˆ¥ã®ã“ã¨ã‚’ã™ã‚‹ "
"å¿…è¦ãŒã‚ã‚‹ãªã‚‰æ–°ã—ã„ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œã‚‰ãªãã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../howto/functional.rst:265
msgid "Data Types That Support Iterators"
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿å¯¾å¿œã®ãƒ‡ãƒ¼ã‚¿å‹"

#: ../../howto/functional.rst:267
msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support creation "
"of an iterator."
msgstr ""
"ãƒªã‚¹ãƒˆã‚„ã‚¿ãƒ—ãƒ«ãŒã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã«å¯¾å¿œã—ã¦ã„ã‚‹æ–¹æ³•ã«ã¤ã„ã¦ã¯æ—¢ã«è¦‹ã¾ã—ãŸãŒã€å®Ÿã®ã¨ã“ã‚ Python "
"ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã¯ã©ã‚Œã§ã‚‚ã€ãŸã¨ãˆã°æ–‡å­—åˆ—ãªã©ã‚‚ã€è‡ªå‹•ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ç”Ÿæˆã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚"

#: ../../howto/functional.rst:271
msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop over"
" the dictionary's keys::"
msgstr "è¾æ›¸ã«å¯¾ã—ã¦ :func:`iter` ã™ã‚‹ã¨ã€è¾æ›¸ã®ã‚­ãƒ¼ã§ãƒ«ãƒ¼ãƒ—ã‚’å›ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒè¿”ã•ã‚Œã¾ã™::"

#: ../../howto/functional.rst:291
msgid ""
"Note that the order is essentially random, because it's based on the hash "
"ordering of the objects in the dictionary."
msgstr "é †ç•ªã¯åŸºæœ¬çš„ã«ãƒ©ãƒ³ãƒ€ãƒ ã§ã‚ã‚‹ã“ã¨ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã¯è¾æ›¸å†…ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒƒã‚·ãƒ¥ã®é †ç•ªã«ãªã£ã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../howto/functional.rst:294
msgid ""
"Applying :func:`iter` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over values or key/value pairs, you can explicitly call the "
":meth:`~dict.values` or :meth:`~dict.items` methods to get an appropriate "
"iterator."
msgstr ""
"è¾æ›¸ã¯ :func:`iter` "
"ã‚’é©ç”¨ã™ã‚‹ã¨ã‚­ãƒ¼ã§ãƒ«ãƒ¼ãƒ—ã‚’å›ã—ã¾ã™ãŒã€è¾æ›¸ã«ã¯ä»–ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ã‚ã‚Šã¾ã™ã€‚æ˜ç¤ºçš„ã«å€¤ã€ã‚ã‚‹ã„ã¯ã‚­ãƒ¼ã¨å€¤ã®ãƒšã‚¢ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã—ãŸã‘ã‚Œã°ã€:meth:`~dict.values`,"
" :meth:`~dict.items` ã¨ã„ã†ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../howto/functional.rst:300
msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite "
"stream of ``(key, value)`` tuples:"
msgstr ""
"é€†ã« :func:`dict` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€æœ‰é™ãª  ``(key, value)`` "
"ã‚¿ãƒ—ãƒ«ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’å—ã‘å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™:"

#: ../../howto/functional.rst:307
msgid ""
"Files also support iteration by calling the :meth:`~io.TextIOBase.readline` "
"method until there are no more lines in the file.  This means you can read "
"each line of a file like this::"
msgstr ""
"ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚ã€æœ€å¾Œã®è¡Œã¾ã§ :meth:`~io.TextIOBase.readline` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã‚“ã§ã„ãã“ã¨ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿åŒ–ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚ã¤ã¾ã‚Šã“ã†ã‚„ã£ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã®å„è¡Œã‚’èª­ã‚“ã§ã„ãã“ã¨ãŒã§ãã‚‹ã‚ã‘ã§ã™::"

#: ../../howto/functional.rst:315
msgid ""
"Sets can take their contents from an iterable and let you iterate over the "
"set's elements::"
msgstr "ã‚»ãƒƒãƒˆã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’å—ã‘å–ã‚Œã¾ã™ã—ã€ãã®ã‚»ãƒƒãƒˆã®è¦ç´ ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™::"

#: ../../howto/functional.rst:325
msgid "Generator expressions and list comprehensions"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã¨ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜"

#: ../../howto/functional.rst:327
msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®å‡ºåŠ›ã«å¯¾ã—ã¦ã‚ˆãä½¿ã†æ“ä½œãƒˆãƒƒãƒ— 2 ã¯ã€(1) ã²ã¨ã¤ãšã¤å…¨è¦ç´ ã«æ“ä½œã‚’å®Ÿè¡Œã™ã‚‹ã€ãŠã‚ˆã³ (2) "
"æ¡ä»¶ã«åˆã†è¦ç´ ã§ã‚µãƒ–ã‚»ãƒƒãƒˆã‚’ä½œã‚‹ã€ã§ã™ã€‚ãŸã¨ãˆã°æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆãªã‚‰ã€å„è¡Œã®ã†ã—ã‚ã«ä»˜ã„ãŸé‚ªé­”ãªãƒ›ãƒ¯ã‚¤ãƒˆã‚¹ãƒšãƒ¼ã‚¹ã‚’å‰Šã‚ŠãŸã„ã¨ã‹ã€ç‰¹å®šã®æ–‡å­—åˆ—ã‚’å«ã‚€éƒ¨åˆ†ã‚’ãƒ”ãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ãŸã„ãªã©ã¨æ€ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../howto/functional.rst:333
msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" and"
" \"genexps\") are a concise notation for such operations, borrowed from the "
"functional programming language Haskell (https://www.haskell.org/).  You can"
" strip all the whitespace from a stream of strings with the following code::"
msgstr ""
"ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã¨ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ (ç•¥ã—ã¦ã€Œlistcompã€ã¨ã€Œgenexpã€) "
"ã¯ã€ãã†ã—ãŸæ“ä½œå‘ã‘ã®ç°¡æ½”ãªè¡¨è¨˜æ–¹æ³•ã§ã™ã€‚ã“ã‚Œã¯é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èª Haskell (https://www.haskell.org/) "
"ã«ã‚¤ãƒ³ã‚¹ãƒ‘ã‚¤ã‚¢ã•ã‚Œã¾ã—ãŸã€‚æ–‡å­—åˆ—ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰ãƒ›ãƒ¯ã‚¤ãƒˆã‚¹ãƒšãƒ¼ã‚¹ã‚’ã™ã¹ã¦å‰Šã‚‹ã®ã¯æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã§ã§ãã¾ã™::"

#: ../../howto/functional.rst:346
msgid "You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr "ç‰¹å®šã®è¦ç´ ã ã‘ã‚’é¸ã³å‡ºã™ã®ã¯ ``\"if\"`` æ¡ä»¶å¼ã‚’ä»˜ã‘ã‚‹ã“ã¨ã§å¯èƒ½ã§ã™::"

#: ../../howto/functional.rst:351
msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` is "
"a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not "
"needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return an"
" infinite stream or a very large amount of data.  Generator expressions are "
"preferable in these situations."
msgstr ""
"ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã‚’ä½¿ã†ã¨ Python ãƒªã‚¹ãƒˆãŒè¿”ã£ã¦æ¥ã¾ã™; ``stripped_list`` "
"ã¯å®Ÿè¡Œçµæœã®è¡ŒãŒå…¥ã£ãŸãƒªã‚¹ãƒˆã§ã‚ã£ã¦ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã€ã“ã‚Œã ã¨å¿…è¦ã«å¿œã˜ã¦ã ã‘å€¤ã‚’ç®—å‡ºã—ã¾ã™ã®ã§ã€ã™ã¹ã¦ã®å€¤ã‚’ä¸€åº¦ã«å‡ºã™å¿…è¦ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã®ã»ã†ã¯ã€ç„¡é™é•·ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚„è†¨å¤§ãªãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™ã‚ˆã†ãªã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’æ‰±ã†éš›ã«ã¯ã€ã‚ã¾ã‚Šå½¹ã«ç«‹ãŸãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚ãã†ã„ã£ãŸçŠ¶æ³ã§ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã®ã»ã†ãŒå¥½ã¾ã—ã„ã¨è¨€ãˆã¾ã™ã€‚"

#: ../../howto/functional.rst:358
msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã¯ä¸¸æ‹¬å¼§ \"()\" ã§å›²ã¾ã‚Œã€ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã¯è§’æ‹¬å¼§ \"[]\" ã§å›²ã¾ã‚Œã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã®å½¢å¼ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™::"

#: ../../howto/functional.rst:371
msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr "ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã‚‚ã€å¤–å´ã®æ‹¬å¼§ãŒé•ã†ã ã‘ (ä¸¸ã§ã¯ãªãè§’æ‹¬å¼§) ã§ã€ã‚ã¨ã¯åŒã˜ã§ã™ã€‚"

#: ../../howto/functional.rst:374
msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when ``condition`` "
"is true."
msgstr ""
"ç”Ÿæˆã•ã‚Œã‚‹å‡ºåŠ›ã¯ ``expression`` éƒ¨åˆ†ã®å€¤ã‚’è¦ç´ ã¨ã—ã¦ä¸¦ã¹ãŸã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚ ``if`` ç¯€ã¯ã™ã¹ã¦ã€ãªãã¦ã‚‚å¤§ä¸ˆå¤«ã§ã™; ã‚ã‚Œã° "
"``condition`` ãŒçœŸã®ã¨ãã ã‘ ``expression`` ãŒè©•ä¾¡ã•ã‚Œã¦å‡ºåŠ›ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚"

#: ../../howto/functional.rst:378
msgid ""
"Generator expressions always have to be written inside parentheses, but the "
"parentheses signalling a function call also count.  If you want to create an"
" iterator that will be immediately passed to a function you can write::"
msgstr ""
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã¯å¸¸ã«æ‹¬å¼§ã®ä¸­ã«æ›¸ã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ãŒã€é–¢æ•°ã‚³ãƒ¼ãƒ«ã®ç›®å°ã«ãªã£ã¦ã„ã‚‹æ‹¬å¼§ã§ã‚‚å¤§ä¸ˆå¤«ã§ã™ã€‚é–¢æ•°ã«ã™ãæ¸¡ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œã‚ŠãŸã‘ã‚Œã°ã“ã†æ›¸ã‘ã‚‹ã®ã§ã™::"

#: ../../howto/functional.rst:384
msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated over "
"from left to right, **not** in parallel.  For each element in ``sequence1``,"
" ``sequence2`` is looped over from the beginning.  ``sequence3`` is then "
"looped over for each resulting pair of elements from ``sequence1`` and "
"``sequence2``."
msgstr ""
"``for...in`` ç¯€ã¯è¤‡æ•°ã¤ãªã’ã‚‰ã‚Œã¾ã™ãŒã€ã©ã‚Œã«ã‚‚ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ãŸã‚ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚ãã‚Œã‚‰ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ä¸¦è¡Œã—ã¦ "
"**ã§ã¯ãªã** ã€å·¦ã‹ã‚‰å³ã¸é †ç•ªã«ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã•ã‚Œã‚‹ã®ã§ã€é•·ã•ãŒåŒã˜ã§ã‚ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ ``sequence1`` ã®å„è¦ç´ ã”ã¨ã«æ¯å›æœ€åˆã‹ã‚‰ "
"``sequence2`` ã‚’ãƒ«ãƒ¼ãƒ—ã§å›ã™ã®ã§ã™ã€‚ãã®å¾Œ ``sequence1`` ã¨ ``sequence2`` ã‹ã‚‰å‡ºãŸè¦ç´ ãƒšã‚¢ã”ã¨ã«ã€ "
"``sequence3`` ã§ãƒ«ãƒ¼ãƒ—ã—ã¾ã™ã€‚"

#: ../../howto/functional.rst:390
msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr "åˆ¥ã®æ›¸ãæ–¹ã‚’ã™ã‚‹ã¨ã€ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã‚„ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã¯æ¬¡ã® Python ã‚³ãƒ¼ãƒ‰ã¨åŒã˜æ„å‘³ã«ãªã‚Šã¾ã™::"

#: ../../howto/functional.rst:407
msgid ""
"This means that when there are multiple ``for...in`` clauses but no ``if`` "
"clauses, the length of the resulting output will be equal to the product of "
"the lengths of all the sequences.  If you have two lists of length 3, the "
"output list is 9 elements long:"
msgstr ""
"ã¤ã¾ã‚Šã€è¤‡æ•°ã® ``for...in`` ç¯€ãŒã‚ã£ã¦ ``if`` ãŒãªã„ã¨ãã®æœ€çµ‚å‡ºåŠ›ã¯ã€é•·ã•ãŒå„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹é•·ã®ç©ã«ç­‰ã—ããªã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚é•·ã• 3"
" ã®ãƒªã‚¹ãƒˆäºŒã¤ãªã‚‰ã€å‡ºåŠ›ãƒªã‚¹ãƒˆã®é•·ã•ã¯ 9 è¦ç´ ã§ã™:"

#: ../../howto/functional.rst:419
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if ``expression`` "
"is creating a tuple, it must be surrounded with parentheses.  The first list"
" comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"Python ã®æ–‡æ³•ã«æ›–æ˜§ã•ã‚’ç´›ã‚Œè¾¼ã¾ã›ãªã„ã‚ˆã†ã«ã€ ``expression`` "
"ã§ã‚¿ãƒ—ãƒ«ã‚’ä½œã‚‹ãªã‚‰æ‹¬å¼§ã§å›²ã‚ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ä¸‹ã«ã‚ã‚‹ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã§ã€æœ€åˆã®ã¯æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã§ã™ãŒã€äºŒç•ªç›®ã¯æœ‰åŠ¹ã§ã™::"

#: ../../howto/functional.rst:430
msgid "Generators"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ (generator)"

#: ../../howto/functional.rst:432
msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr ""
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’æ›¸ãä½œæ¥­ã‚’ç°¡å˜ã«ã™ã‚‹ã€ç‰¹æ®Šãªé–¢æ•°ã§ã™ã€‚æ¨™æº–çš„ãªé–¢æ•°ã¯å€¤ã‚’è¨ˆç®—ã—ã¦è¿”ã—ã¾ã™ãŒã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒè¿”ã™ã®ã¯ã€ä¸€é€£ã®å€¤ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã§ã™ã€‚"

#: ../../howto/functional.rst:436
msgid ""
"You're doubtless familiar with how regular function calls work in Python or "
"C. When you call a function, it gets a private namespace where its local "
"variables are created.  When the function reaches a ``return`` statement, "
"the local variables are destroyed and the value is returned to the caller.  "
"A later call to the same function creates a new private namespace and a "
"fresh set of local variables. But, what if the local variables weren't "
"thrown away on exiting a function?  What if you could later resume the "
"function where it left off?  This is what generators provide; they can be "
"thought of as resumable functions."
msgstr ""
"Python ã‚„ C "
"ã®æ¨™æº–çš„ãªé–¢æ•°ã‚³ãƒ¼ãƒ«ã«ã¤ã„ã¦ã¯ã€ã‚ˆãã”å­˜ã˜ã«é•ã„ã‚ã‚Šã¾ã›ã‚“ã€‚é–¢æ•°ã‚’å‘¼ã¶ã¨ã€ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã‚’ä½œã‚‹ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªåå‰ç©ºé–“ãŒã§ãã¾ã™ã­ã€‚ãã®é–¢æ•°ãŒ "
"``return`` "
"æ–‡ã¾ã§æ¥ã‚‹ã¨ã€ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ãŒç ´å£Šã•ã‚Œã¦ã‹ã‚‰ã€è¿”ã‚Šå€¤ãŒå‘¼ã³å‡ºã—å…ƒã«è¿”ã‚Šã¾ã™ã€‚æ¬¡ã«åŒã˜é–¢æ•°ã‚’ã‚‚ã†ä¸€åº¦å‘¼ã¶ã¨ã€æ–°ã—ã„ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆåå‰ç©ºé–“ã«æ–°è¦ã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ãŒä½œã‚‰ã‚Œã‚‹ã®ã§ã™ã€‚ã—ã‹ã—ã€é–¢æ•°ã‚’å‡ºã‚‹ã¨ãã«ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã‚’æ¨ã¦ãªã‘ã‚Œã°ã©ã†ãªã‚‹ã§ã—ã‚‡ã†ã‹ã€‚ãã®å‡ºã¦ã„ã£ãŸã¨ã“ã‚ã‹ã‚‰é–¢æ•°ã‚’ç¶šè¡Œã§ããŸã¨ã—ãŸã‚‰ã€ã©ã†ã§ã—ã‚‡ã†ã€‚ã“ã‚Œã“ãã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒæä¾›ã™ã‚‹æ©Ÿèƒ½ã§ã™;"
" ã™ãªã‚ã¡ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯ç¶šè¡Œã§ãã‚‹é–¢æ•°ã¨è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../howto/functional.rst:445
msgid "Here's the simplest example of a generator function:"
msgstr "ã”ãå˜ç´”ãªã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã®ä¾‹ãŒã“ã¡ã‚‰ã«ã‚ã‚Šã¾ã™:"

#: ../../howto/functional.rst:451
msgid ""
"Any function containing a :keyword:`yield` keyword is a generator function; "
"this is detected by Python's :term:`bytecode` compiler which compiles the "
"function specially as a result."
msgstr ""
":keyword:`yield` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å«ã‚€é–¢æ•°ã¯ã™ã¹ã¦ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã§ã™; Python ã® :term:`bytecode` "
"ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒã“ã‚Œã‚’æ¤œå‡ºã—ã¦ã€ç‰¹åˆ¥ãªæ–¹æ³•ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¦ãã‚Œã‚‹ã®ã§ã™ã€‚"

#: ../../howto/functional.rst:455
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the ``yield`` expression, the generator outputs the value of "
"``i``, similar to a ``return`` statement.  The big difference between "
"``yield`` and a ``return`` statement is that on reaching a ``yield`` the "
"generator's state of execution is suspended and local variables are "
"preserved.  On the next call to the generator's :meth:`~generator.__next__` "
"method, the function will resume executing."
msgstr ""
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã¯ã€å‘¼ã°ã‚ŒãŸã¨ãã«ä¸€å›ã ã‘å€¤ã‚’è¿”ã™ã®ã§ã¯ãªãã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«å¯¾å¿œã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ä¸Šã®ä¾‹ã§ ``yield`` "
"ã‚’å®Ÿè¡Œã—ãŸã¨ãã€ ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯ ``return`` æ–‡ã®ã‚ˆã†ã«ã—ã¦ ``i`` ã®å€¤ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚ ``yield`` ã¨ ``return`` "
"æ–‡ã®å¤§ããªé•ã„ã¯ã€ ``yield`` ã«åˆ°é”ã—ãŸæ®µéšã§ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®å®Ÿè¡ŒçŠ¶æ…‹ãŒä¸€æ™‚åœæ­¢ã«ãªã£ã¦ã€ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ãŒä¿å­˜ã•ã‚Œã‚‹ç‚¹ã§ã™ã€‚ "
"æ¬¡å›ãã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã® :meth:`~generator.__next__` ã‚’å‘¼ã¶ã¨ã€ãã“ã‹ã‚‰é–¢æ•°ãŒå®Ÿè¡Œã‚’å†é–‹ã—ã¾ã™ã€‚"

#: ../../howto/functional.rst:464
msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "ä¸Šè¨˜ ``generate_ints()`` ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®ä½¿ç”¨ä¾‹ã¯ã“ã¡ã‚‰ã§ã™:"

#: ../../howto/functional.rst:481
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a,b,c = "
"generate_ints(3)``."
msgstr ""
"åŒã˜ã ``for i in generate_ints(5)`` ã‚„ ``a,b,c = generate_ints(3)`` "
"ã¨ã„ã£ãŸæ›¸ãæ–¹ã‚‚ã§ãã¾ã™ã€‚"

#: ../../howto/functional.rst:484
msgid ""
"Inside a generator function, ``return value`` causes "
"``StopIteration(value)`` to be raised from the :meth:`~generator.__next__` "
"method.  Once this happens, or the bottom of the function is reached, the "
"procession of values ends and the generator cannot yield any further values."
msgstr ""
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã®ä¸­ã§ã¯ã€``return value`` ã¯ :meth:`~generator.__next__` ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰é€å‡ºã•ã‚ŒãŸ "
"``StopIteration(value)`` "
"ã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚ã“ã‚ŒãŒç™ºç”Ÿã—ãŸå ´åˆã‚„ã€é–¢æ•°ã®çµ‚ã‚ã‚Šã«åˆ°é”ã—ãŸå ´åˆã¯ã€å€¤ã®ç”ŸæˆãŒçµ‚äº†ã—ã¦ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒãã‚Œä»¥ä¸Šã®å€¤ã‚’è¿”ã•ãªã„ã€‚"

#: ../../howto/functional.rst:489
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`~iterator.__next__` "
"method increment ``self.count`` and return it. However, for a moderately "
"complicated generator, writing a corresponding class can be much messier."
msgstr ""
"è‡ªåˆ†ã§ã‚¯ãƒ©ã‚¹ã‚’æ›¸ã„ã¦ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã§è¨€ã†ã¨ã“ã‚ã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã¨ã—ã¦å…¨éƒ¨ä¿ç®¡ã—ã¦ãŠã‘ã°ã€åŒã˜åŠ¹æœã‚’å¾—ã‚‹ã“ã¨ã¯å¯èƒ½ã§ã™ã€‚ãŸã¨ãˆã°æ•´æ•°ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™ã®ã¯ã€"
" ``self.count`` ã‚’ 0 ã«ã—ã¦ã€ :meth:`~iterator.__next__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒ ``self.count`` "
"ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦è¿”ã™ã‚ˆã†ã«ã™ã‚Œã°ã§ãã¾ã™ã€‚ã—ã‹ã—ãªãŒã‚‰ã€ã‚ã‚‹ç¨‹åº¦è¤‡é›‘ãªã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã«ãªã£ã¦ãã‚‹ã¨ã€åŒã˜ã“ã¨ã‚’ã™ã‚‹ã‚¯ãƒ©ã‚¹ã‚’æ›¸ãã®ã¯æ ¼æ®µã«ã‚„ã‚„ã“ã—ã„ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/functional.rst:497
msgid ""
"The test suite included with Python's library, "
":source:`Lib/test/test_generators.py`, contains a number of more interesting"
" examples.  Here's one generator that implements an in-order traversal of a "
"tree using generators recursively. ::"
msgstr ""
"Python ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å«ã¾ã‚Œã¦ã„ã‚‹ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ :source:`Lib/test/test_generators.py` "
"ã«ã¯ã€ã»ã‹ã«ã‚‚èˆˆå‘³æ·±ã„ä¾‹ãŒæ•°å¤šãå…¥ã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯äºŒåˆ†æœ¨ã®é€šã‚ŠãŒã‘é † (in-order) æ¢ç´¢ã‚’å†å¸°ã§å®Ÿè£…ã—ãŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã§ã™ã€‚ ::"

#: ../../howto/functional.rst:513
msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the "
"N-Queens problem (placing N queens on an NxN chess board so that no queen "
"threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"ã»ã‹ã«ã‚‚ ``test_generators.py`` ã«ã¯ã€N-Queens å•é¡Œ (NÃ—N ã‚³ãƒã®ãƒã‚§ã‚¹ç›¤ã«ã€äº’ã„ã«æ”»æ’ƒã§ããªã„ã‚ˆã†ãªé…ç½®ã§ N "
"å€‹ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’ç½®ã) ã‚„ãƒŠã‚¤ãƒˆãƒ»ãƒ„ã‚¢ãƒ¼ (NÃ—N ç›¤ã®å…¨ã‚³ãƒã‚’ãƒŠã‚¤ãƒˆãŒä¸€åº¦ãšã¤é€šã‚‹ã‚ˆã†ãªçµŒè·¯ã‚’æ¢ã™) ã®è§£ã‚’å‡ºã™ä¾‹ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚"

#: ../../howto/functional.rst:521
msgid "Passing values into a generator"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã«å€¤ã‚’æ¸¡ã™"

#: ../../howto/functional.rst:523
msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to pass"
" any new information into the function when its execution is resumed.  You "
"could hack together this ability by making the generator look at a global "
"variable or by passing in some mutable object that callers then modify, but "
"these approaches are messy."
msgstr ""
"Python 2.4 "
"ã¾ã§ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯å‡ºåŠ›ã™ã‚‹ã“ã¨ã—ã‹ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œã£ã¦ã—ã¾ã£ãŸã‚ã¨ã§ã€ãã®é–¢æ•°ã‚’å†é–‹ã™ã‚‹ã¨ãã«æ–°ã—ã„æƒ…å ±ã‚’æ¸¡ã™æ‰‹æ®µã¯ãªã‹ã£ãŸã®ã§ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’è¦‹ã‚‹ã‚ˆã†ã«ã—ãŸã‚Šã€ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã—ã¦ãŠã„ã¦å‘¼ã³å‡ºã—å…ƒã§ã‚ã¨ã‹ã‚‰ãã‚Œã‚’å¤‰æ›´ã—ãŸã‚Šã€ã¨ã„ã£ãŸãƒãƒƒã‚¯ã¯å¯èƒ½ã§ã—ãŸãŒã€ã©ã‚Œã‚‚ã‚´ãƒãƒ£ã‚´ãƒãƒ£ã—ã¦ã„ã¾ã™ã­ã€‚"

#: ../../howto/functional.rst:530
msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. "
":keyword:`yield` became an expression, returning a value that can be "
"assigned to a variable or otherwise operated on::"
msgstr ""
"Python 2.5 ã§ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã«å€¤ã‚’æ¸¡ã™ç°¡å˜ãªæ‰‹æ®µãŒã§ãã¾ã—ãŸã€‚ :keyword:`yield` "
"ãŒã€å¤‰æ•°ã«ä»£å…¥ã—ãŸã‚Šæ¼”ç®—ã—ãŸã‚Šã§ãã‚‹å€¤ã‚’è¿”ã™å¼ã«ãªã£ãŸã®ã§ã™::"

#: ../../howto/functional.rst:536
msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"ä¸Šã®ã‚ˆã†ã«ã€è¿”ã‚Šå€¤ã§ä½•ã‹ã‚’ã™ã‚‹ã¨ãã¯ ``yield`` å¼ã®å‰å¾Œã« **å¿…ãš** "
"æ‹¬å¼§ã‚’ä»˜ã‘ã‚‹ã‚ˆã†ãŠå‹§ã‚ã—ã¾ã™ã€‚æ‹¬å¼§ã¯å¸¸ã«å¿…è¦ãªã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ã©ã‚“ãªã¨ãä»˜ã‘ãªãã¦è‰¯ã„ã®ã‹ã‚’è¦šãˆã¦ãŠãã‚ˆã‚Šã€ã„ã¤ã‚‚ä»˜ã‘ã¦ãŠãã»ã†ãŒæ¥½ã§ã™ã‹ã‚‰ã€‚"

#: ../../howto/functional.rst:541
msgid ""
"(:pep:`342` explains the exact rules, which are that a ``yield``-expression "
"must always be parenthesized except when it occurs at the top-level "
"expression on the right-hand side of an assignment.  This means you can "
"write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` ãŒãã®è¦å‰‡ã‚’æ­£ç¢ºã«èª¬æ˜ã—ã¦ã„ã¾ã™ãŒã€ãã‚Œã«ã‚ˆã‚‹ã¨ "
"``yield``-å¼ã¯ã€ä»£å…¥å¼ã§å³è¾ºã®ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã«ã‚ã‚‹ã¨ãä»¥å¤–ã¯ã„ã¤ã‚‚æ‹¬å¼§ã‚’ä»˜ã‘ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã¤ã¾ã‚Š ``val = yield i`` "
"ã¨ã¯æ›¸ã‘ã¾ã™ãŒã€ ``val = (yield i) + 12`` ã®ã‚ˆã†ã«æ¼”ç®—å­ãŒã‚ã‚‹ã¨ãã¯æ‹¬å¼§ã‚’ä½¿ã‚ãªãã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚)"

#: ../../howto/functional.rst:547
msgid ""
"Values are sent into a generator by calling its :meth:`send(value) "
"<generator.send>` method.  This method resumes the generator's code and the "
"``yield`` expression returns the specified value.  If the regular "
":meth:`~generator.__next__` method is called, the ``yield`` returns "
"``None``."
msgstr ""
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã«å€¤ã‚’é€ã‚‹ã«ã¯ :meth:`send(value) <generator.send>` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³ã¾ã™ã€‚ "
"ã™ã‚‹ã¨ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®ã‚³ãƒ¼ãƒ‰ãŒå®Ÿè¡Œã‚’å†é–‹ã—ã€ ``yield`` å¼ãŒãã®å€¤ã‚’è¿”ã™ã®ã§ã™ã€‚ãµã¤ã†ã® :meth:`~generator.__next__`"
" ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã¶ã¨ã€ ``yield`` ã¯ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../howto/functional.rst:552
msgid ""
"Here's a simple counter that increments by 1 and allows changing the value "
"of the internal counter."
msgstr "ä¸‹ã«ã‚ã‚‹ã®ã¯ 1 ãšã¤å¢—ãˆã‚‹å˜ç´”ãªã‚«ã‚¦ãƒ³ã‚¿ã§ã™ãŒã€å†…éƒ¨ã‚«ã‚¦ãƒ³ã‚¿ã®å€¤ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../howto/functional.rst:567
msgid "And here's an example of changing the counter:"
msgstr "ãã—ã¦ã‚«ã‚¦ãƒ³ã‚¿å¤‰æ›´ã®ä¾‹ãŒã“ã¡ã‚‰ã§ã™:"

#: ../../howto/functional.rst:584
msgid ""
"Because ``yield`` will often be returning ``None``, you should always check "
"for this case.  Don't just use its value in expressions unless you're sure "
"that the :meth:`~generator.send` method will be the only method used to "
"resume your generator function."
msgstr ""
"``yield`` ãŒ ``None`` "
"ã‚’è¿”ã™ã“ã¨ã¯ã‚ˆãã‚ã‚‹ã®ã§ã™ã‹ã‚‰ã€ãã†ãªã£ã¦ã„ãªã„ã‹ã©ã†ã‹å¿…ãšãƒã‚§ãƒƒã‚¯ã—ã¦ãŠãã¹ãã§ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã‚’å†é–‹ã™ã‚‹ãŸã‚ã«ä½¿ã†ãƒ¡ã‚½ãƒƒãƒ‰ãŒ "
":meth:`~generator.send` ã—ã‹ãªã„ã®ã ã¨ç¢ºå®šã—ã¦ã‚‹ã®ã§ãªã„é™ã‚Šã€å¼ã®å€¤ã‚’ãã®ã¾ã¾ä½¿ã£ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../howto/functional.rst:589
msgid ""
"In addition to :meth:`~generator.send`, there are two other methods on "
"generators:"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã«ã¯ã€ :meth:`~generator.send` ã®ã»ã‹ã«ã‚‚ãƒ¡ã‚½ãƒƒãƒ‰ãŒäºŒã¤ã‚ã‚Šã¾ã™:"

#: ../../howto/functional.rst:592
msgid ""
":meth:`throw(type, value=None, traceback=None) <generator.throw>` is used to"
" raise an exception inside the generator; the exception is raised by the "
"``yield`` expression where the generator's execution is paused."
msgstr ""
":meth:`throw(type, value=None, traceback=None) <generator.throw>` "
"ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å†…ã§ä¾‹å¤–ã‚’æŠ•ã’ã‚‹ãŸã‚ã«ä½¿ã„ã¾ã™; ãã®ä¾‹å¤–ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®å®Ÿè¡ŒãŒåœæ­¢ã—ãŸã¨ã“ã‚ã® ``yield`` å¼ã«ã‚ˆã£ã¦æŠ•ã’ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../howto/functional.rst:596
msgid ""
":meth:`~generator.close` raises a :exc:`GeneratorExit` exception inside the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or "
":exc:`StopIteration`; catching the exception and doing anything else is "
"illegal and will trigger a :exc:`RuntimeError`.  :meth:`~generator.close` "
"will also be called by Python's garbage collector when the generator is "
"garbage-collected."
msgstr ""
":meth:`~generator.close` ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å†…ã§ :exc:`GeneratorExit` ä¾‹å¤–ã‚’æŠ•ã’ã¦ã€ "
"ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã‚’çµ‚äº†ã•ã›ã¾ã™ã€‚ã“ã®ä¾‹å¤–ã‚’å—ã‘å–ã£ãŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®ã‚³ãƒ¼ãƒ‰ã¯ :exc:`GeneratorExit` ã‹ "
":exc:`StopIteration` ã‚’æŠ•ã’ãªãã¦ã¯ã„ã‘ã¾ã›ã‚“; ã“ã®ä¾‹å¤–ã‚’æ•æ‰ã—ã¦ä½•ã‹ã»ã‹ã®ã“ã¨ã‚’ã—ã‚ˆã†ã¨ã™ã‚‹ã®ã¯è¦å‰‡é•åã§ã‚ã‚Šã€ "
":exc:`RuntimeError` ã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚ :meth:`~generator.close` ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒ GC "
"ã•ã‚Œã‚‹ã¨ãã«ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚"

#: ../../howto/functional.rst:604
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching "
":exc:`GeneratorExit`."
msgstr ""
":exc:`GeneratorExit` ãŒèµ·ã“ã£ãŸã¨ãã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ä½œæ¥­ã‚’ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãªã‚‰ã€ :exc:`GeneratorExit` "
"ã‚’æ•æ‰ã™ã‚‹ã®ã§ã¯ãªã ``try: ... finaly:`` ã™ã‚‹ã‚ˆã†ãŠå‹§ã‚ã—ã¾ã™ã€‚"

#: ../../howto/functional.rst:607
msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr "ã“ã‚Œã‚‰ã®å¤‰æ›´ã®åˆã‚ã›æŠ€ã§ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯æƒ…å ±ã®ä¸€æ–¹çš„ãªç”Ÿç”£è€…ã‹ã‚‰ã€ç”Ÿç”£è€…ã‹ã¤æ¶ˆè²»è€…ã¨ã„ã†å­˜åœ¨ã«å¤‰è²Œã‚’é‚ã’ãŸã®ã§ã™ã€‚"

#: ../../howto/functional.rst:610
msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but coroutines "
"can be entered, exited, and resumed at many different points (the ``yield`` "
"statements)."
msgstr ""
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯ **ã‚³ãƒ«ãƒ¼ãƒãƒ³** ã¨ã„ã†ã€ã‚ˆã‚Šä¸€èˆ¬åŒ–ã•ã‚ŒãŸå½¢å¼ã®ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³ã«ã‚‚ãªã‚Šã¾ã™ã€‚ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³ã¯ä¸€ã‚«æ‰€ (é–¢æ•°ã®å†’é ­) ã‹ã‚‰å…¥ã£ã¦åˆ¥ã®ä¸€ã‚«æ‰€ "
"(``return`` æ–‡) ã‹ã‚‰å‡ºã‚‹ã ã‘ã§ã™ãŒã€ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯ã„ã‚ã„ã‚ãªå ´æ‰€ (``yield`` æ–‡) ã‹ã‚‰å…¥ã£ãŸã‚Šå‡ºãŸã‚Šå†é–‹ã—ãŸã‚Šã§ãã‚‹ã®ã§ã™ã€‚"

#: ../../howto/functional.rst:617
msgid "Built-in functions"
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•° (built-in function)"

#: ../../howto/functional.rst:619
msgid ""
"Let's look in more detail at built-in functions often used with iterators."
msgstr "ã‚ˆãã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¨ä¸€ç·’ã«ä½¿ã†ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•°ã«ã¤ã„ã¦ã€ã‚‚ã£ã¨è©³ã—ãè¦‹ã¦ã„ãã¾ã—ã‚‡ã†ã€‚"

#: ../../howto/functional.rst:621
msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter` duplicate"
" the features of generator expressions:"
msgstr "Python ã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•° :func:`map` ã¨ :func:`filter` ã¯ã€æ©Ÿèƒ½ãŒã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã¨é‡è¤‡ã—ã¦ã„ã¾ã™:"

#: ../../howto/functional.rst:633
msgid ""
":func:`map(f, iterA, iterB, ...) <map>` returns an iterator over the "
"sequence"
msgstr ":func:`map(f, iterA, iterB, ...) <map>` ã¯ä»¥ä¸‹ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™"

#: ../../howto/functional.rst:625
msgid ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), "
"...``."
msgstr ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), "
"...``."

#: ../../howto/functional.rst:635
msgid "You can of course achieve the same effect with a list comprehension."
msgstr "ã‚‚ã¡ã‚ã‚“ã€ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã§ã‚‚åŒã˜çµæœãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../howto/functional.rst:637
msgid ""
":func:`filter(predicate, iter) <filter>` returns an iterator over all the "
"sequence elements that meet a certain condition, and is similarly duplicated"
" by list comprehensions.  A **predicate** is a function that returns the "
"truth value of some condition; for use with :func:`filter`, the predicate "
"must take a single value."
msgstr ""
":func:`filter(predicate, iter) <filter>` ã¯ã‚ã‚‹æ¡ä»¶ã‚’æº€ãŸã™è¦ç´ ã«æ¸¡ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã™ã®ã§ã€åŒæ§˜ã«ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã§å†ç¾ã§ãã¾ã™ã€‚\n"
"**predicate** ã¯ã€ã‚ã‚‹æ¡ä»¶ã«å¯¾ã™ã‚‹çœŸå½å€¤ã‚’è¿”ã™é–¢æ•°ã§ã™;\n"
":func:`filter` ã§ä½¿ã†ã«ã¯ã€ãã®é–¢æ•°ã®å¼•æ•°ã¯ä¸€ã¤ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../howto/functional.rst:650
msgid "This can also be written as a list comprehension:"
msgstr "ã“ã‚Œã¯ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã§ã‚‚æ›¸ã‘ã¾ã™:"

#: ../../howto/functional.rst:656
msgid ""
":func:`enumerate(iter, start=0) <enumerate>` counts off the elements in the "
"iterable returning 2-tuples containing the count (from *start*) and each "
"element. ::"
msgstr ""
":func:`enumerate(iter, start=0) <enumerate>` ã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã®è¦ç´ ã«é †ç•ªã«ç•ªå·ã‚’æŒ¯ã£ã¦ã„ãã€(*start* "
"ã‹ã‚‰æ•°ãˆå§‹ã‚ãŸã¨ãã®) ç•ªå·ã¨ãã‚Œãã‚Œã®è¦ç´ ã‚’å«ã‚€ 2 ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../howto/functional.rst:666
msgid ""
":func:`enumerate` is often used when looping through a list and recording "
"the indexes at which certain conditions are met::"
msgstr ":func:`enumerate` ã¯ã‚ˆãã€ãƒªã‚¹ãƒˆã«å¯¾ã—ã¦ãƒ«ãƒ¼ãƒ—ã•ã›ã¦ã€æ¡ä»¶ã«åˆã†æ‰€ã«å°ã‚’ä»˜ã‘ã¦ã„ãã¨ãã«ä½¿ã‚ã‚Œã¾ã™::"

#: ../../howto/functional.rst:674
msgid ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` collects all the "
"elements of the iterable into a list, sorts the list, and returns the sorted"
" result.  The *key* and *reverse* arguments are passed through to the "
"constructed list's :meth:`~list.sort` method. ::"
msgstr ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` "
"ã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã®è¦ç´ ã‚’ã™ã¹ã¦é›†ã‚ãŸãƒªã‚¹ãƒˆã‚’ä½œã‚Šã€ã‚½ãƒ¼ãƒˆã—ã¦è¿”ã—ã¾ã™ã€‚ å¼•æ•° *key* ãŠã‚ˆã³ *reverse* ã¯ã€ãƒªã‚¹ãƒˆã® "
":meth:`~list.sort` ãƒ¡ã‚½ãƒƒãƒ‰ã«ãã®ã¾ã¾æ¸¡ã•ã‚Œã¾ã™ã€‚ ::"

#: ../../howto/functional.rst:689
msgid ""
"(For a more detailed discussion of sorting, see the :ref:`sortinghowto`.)"
msgstr "(ã‚½ãƒ¼ãƒˆã«é–¢ã™ã‚‹è©³ç´°ãªè«–è­°ã¯ :ref:`sortinghowto` ã‚’å‚ç…§)"

#: ../../howto/functional.rst:692
msgid ""
"The :func:`any(iter) <any>` and :func:`all(iter) <all>` built-ins look at "
"the truth values of an iterable's contents.  :func:`any` returns ``True`` if"
" any element in the iterable is a true value, and :func:`all` returns "
"``True`` if all of the elements are true values:"
msgstr ""
"çµ„ã¿è¾¼ã¿ã® :func:`any(iter) <any>` ãŠã‚ˆã³ :func:`all(iter) <all>` ã¯ iterable "
"ã®å€¤ã®çœŸå½ã‚’èª¿ã¹ã¾ã™ã€‚ :func:`any` ã¯è¦ç´ ã®ã©ã‚Œã‹ãŒçœŸå€¤ãªã‚‰ ``True`` ã‚’è¿”ã—ã€ :func:`all` ã¯è¦ç´ ãŒå…¨ã¦çœŸå€¤ãªã‚‰ "
"``True`` ã‚’è¿”ã—ã¾ã™:"

#: ../../howto/functional.rst:711
msgid ""
":func:`zip(iterA, iterB, ...) <zip>` takes one element from each iterable "
"and returns them in a tuple::"
msgstr ""
":func:`zip(iterA, iterB, ...) <zip>` ã¯ãã‚Œãã‚Œã® iterable "
"ã‹ã‚‰1ã¤ã®è¦ç´ ã‚’å–ã‚Šã€ãã‚Œã‚‰ã‚’ã‚¿ãƒ—ãƒ«ã«å…¥ã‚Œã¦è¿”ã—ã¾ã™::"

#: ../../howto/functional.rst:717
msgid ""
"It doesn't construct an in-memory list and exhaust all the input iterators "
"before returning; instead tuples are constructed and returned only if "
"they're requested.  (The technical term for this behaviour is `lazy "
"evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"
msgstr ""
":func:`zip` ã¯çµæœã‚’è¿”ã™å‰ã«å…¥åŠ›ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’å…¨ã¦æ¶ˆè²»ã—ã¦ãƒ¡ãƒ¢ãƒªä¸Šã« list ã‚’ä½œæˆã—ã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«è¦æ±‚ã•ã‚Œã‚‹ãŸã³ã« tuple "
"ã‚’ç”Ÿæˆã—ã¦è¿”ã—ã¾ã™ã€‚(ã“ã®å‹•ä½œã‚’æŠ€è¡“çš„ãªç”¨èªã§ `lazy evaluation "
"<https://en.wikipedia.org/wiki/Lazy_evaluation>`__ (è¨³: `é…å»¶è©•ä¾¡ "
"<https://ja.wikipedia.org/wiki/%E9%81%85%E5%BB%B6%E8%A9%95%E4%BE%A1>`__) "
"ã¨å‘¼ã³ã¾ã™ã€‚)"

#: ../../howto/functional.rst:722
msgid ""
"This iterator is intended to be used with iterables that are all of the same"
" length.  If the iterables are of different lengths, the resulting stream "
"will be the same length as the shortest iterable. ::"
msgstr ""
"ã“ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®ç”¨é€”ã«ã¯ã€ã™ã¹ã¦åŒã˜é•·ã•ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚é•·ã•ãŒé•ã£ã¦ã„ã‚Œã°ã€å‡ºåŠ›ã•ã‚Œã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ä¸€ç•ªçŸ­ã„ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã¨åŒã˜é•·ã•ã«ãªã‚Šã¾ã™ã€‚"
" ::"

#: ../../howto/functional.rst:729
msgid ""
"You should avoid doing this, though, because an element may be taken from "
"the longer iterators and discarded.  This means you can't go on to use the "
"iterators further because you risk skipping a discarded element."
msgstr ""
"ã¨ã¯è¨€ãˆã€ã“ã‚Œã‚’ã‚„ã£ã¦ã—ã¾ã†ã¨é•·ã„ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‹ã‚‰è¦ç´ ã‚’ã²ã¨ã¤ç„¡é§„ã«å¤šãå–ã£ã¦æ¨ã¦ã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã®ã§ã€ã‚„ã‚ã¦ãŠã„ãŸã»ã†ãŒè‰¯ã„ã§ã™ã€‚ãã®æ¨ã¦ã‚‰ã‚ŒãŸè¦ç´ ã‚’æŠœã‹ã—ã¦ã—ã¾ã†å±é™ºãŒã‚ã‚‹ã®ã§ã€ã‚‚ã†ãã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ãã‚Œä»¥ä¸Šä½¿ãˆãªããªã£ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../howto/functional.rst:735
msgid "The itertools module"
msgstr "itertools ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../howto/functional.rst:737
msgid ""
"The :mod:`itertools` module contains a number of commonly-used iterators as "
"well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ""
":mod:`itertools` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã€ã‚ˆãä½¿ã†ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚„ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿åŒå£«ã®é€£çµã«ä½¿ã†é–¢æ•°ãŒãŸãã•ã‚“å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ç« ã§ã¯ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†…å®¹ã‚’å°ã•ãªä¾‹ã§ç´¹ä»‹ã—ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚"

#: ../../howto/functional.rst:741
msgid "The module's functions fall into a few broad classes:"
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–¢æ•°ã‚’å¤§ã¾ã‹ã«åˆ†ã‘ã‚‹ã¨ã“ã†ãªã‚Šã¾ã™:"

#: ../../howto/functional.rst:743
msgid "Functions that create a new iterator based on an existing iterator."
msgstr "æ—¢å­˜ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã«åŸºã¥ã„ã¦æ–°ã—ã„ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œã‚‹é–¢æ•°ã€‚"

#: ../../howto/functional.rst:744
msgid "Functions for treating an iterator's elements as function arguments."
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®è¦ç´ ã‚’å¼•æ•°ã¨ã—ã¦æ‰±ã†é–¢æ•°ã€‚"

#: ../../howto/functional.rst:745
msgid "Functions for selecting portions of an iterator's output."
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®å‡ºåŠ›ã‹ã‚‰ä¸€éƒ¨ã‚’å–ã‚Šå‡ºã™é–¢æ•°ã€‚"

#: ../../howto/functional.rst:746
msgid "A function for grouping an iterator's output."
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®å‡ºåŠ›ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘ã™ã‚‹é–¢æ•°ã€‚"

#: ../../howto/functional.rst:749
msgid "Creating new iterators"
msgstr "æ–°ã—ã„ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œã‚‹"

#: ../../howto/functional.rst:751
msgid ""
":func:`itertools.count(start, step) <itertools.count>` returns an infinite "
"stream of evenly spaced values.  You can optionally supply the starting "
"number, which defaults to 0, and the interval between numbers, which "
"defaults to 1::"
msgstr ""
":func:`itertools.count(start, step) <itertools.count>` ã¯å€¤ã®é–“éš”ãŒä¸€å®šã®ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã—ã¾ã™ã€‚\n"
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§é–‹å§‹ã™ã‚‹æ•° (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ 0) ã‚„æ•°ã©ã†ã—ã®é–“éš” (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ 1) ã‚’ä¸ãˆã‚‰ã‚Œã¾ã™::"

#: ../../howto/functional.rst:762
msgid ""
":func:`itertools.cycle(iter) <itertools.cycle>` saves a copy of the contents"
" of a provided iterable and returns a new iterator that returns its elements"
" from first to last.  The new iterator will repeat these elements "
"infinitely. ::"
msgstr ""
":func:`itertools.cycle(iter) <itertools.cycle>` ã¯ä¸ãˆã‚‰ã‚ŒãŸã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã®å†…å®¹ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã€ "
"ãã®è¦ç´ ã‚’æœ€åˆã‹ã‚‰æœ€å¾Œã¾ã§ç„¡é™ã«ç¹°ã‚Šè¿”ã—ã¦ã„ãã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ ::"

#: ../../howto/functional.rst:769
msgid ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returns the provided "
"element *n* times, or returns the element endlessly if *n* is not provided. "
"::"
msgstr ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸè¦ç´ ã‚’ *n* "
"å›è¿”ã—ã¾ã™ãŒã€ *n* ãŒãªã‘ã‚Œã°æ°¸é ã«è¿”ã—ç¶šã‘ã¾ã™ã€‚ ::"

#: ../../howto/functional.rst:777
msgid ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` takes an "
"arbitrary number of iterables as input, and returns all the elements of the "
"first iterator, then all the elements of the second, and so on, until all of"
" the iterables have been exhausted. ::"
msgstr ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` "
"ã¯ä»»æ„ã®æ•°ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’å—ã‘å–ã£ã¦ã€æœ€åˆã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‹ã‚‰è¦ç´ ã‚’ã™ã¹ã¦è¿”ã—ã€æ¬¡ã«äºŒç•ªç›®ã‹ã‚‰ è¦ç´ ã‚’ã™ã¹ã¦è¿”ã—ã€ã¨ã„ã†ã“ã¨ã‚’è¦ç´ ãŒãªããªã‚‹ã¾ã§ç¶šã‘ã¾ã™ã€‚ "
"::"

#: ../../howto/functional.rst:785
msgid ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returns a stream that's a slice of the iterator.  With a single *stop* "
"argument, it will return the first *stop* elements.  If you supply a "
"starting index, you'll get *stop-start* elements, and if you supply a value "
"for *step*, elements will be skipped accordingly.  Unlike Python's string "
"and list slicing, you can't use negative values for *start*, *stop*, or "
"*step*. ::"
msgstr ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã® ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§è¿”ã—ã¾ã™ã€‚ *stop* å¼•æ•°ã ã‘ã ã¨ã€æœ€åˆã® *stop* å€‹ã®è¦ç´ ã‚’è¿”ã—ã¾ã™ã€‚é–‹å§‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ¸¡ã™ã¨ "
"*stop-start* å€‹ã§ã€ *step* ã®å€¤ã‚‚æ¸¡ã›ã°ãã‚Œã«å¿œã˜ã¦è¦ç´ ã‚’æŠœã‹ã—ã¾ã™ã€‚Python "
"ã«ãŠã‘ã‚‹æ–‡å­—åˆ—ã‚„ãƒªã‚¹ãƒˆã®ã‚¹ãƒ©ã‚¤ã‚¹ã¨ã¯é•ã£ã¦ã€ãƒã‚¤ãƒŠã‚¹ã®å€¤ã¯ *start*, *stop*, *step* ã«ä½¿ãˆã¾ã›ã‚“ã€‚ ::"

#: ../../howto/functional.rst:799
msgid ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replicates an iterator; it "
"returns *n* independent iterators that will all return the contents of the "
"source iterator. If you don't supply a value for *n*, the default is 2.  "
"Replicating iterators requires saving some of the contents of the source "
"iterator, so this can consume significant memory if the iterator is large "
"and one of the new iterators is consumed more than the others. ::"
msgstr ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¤‡è£½ã—ã¾ã™; "
"å…ƒã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®å†…å®¹ã‚’åŒã˜ã‚ˆã†ã«è¿”ã™ã€ç‹¬ç«‹ã—ãŸ *n* å€‹ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã™ã®ã§ã™ã€‚ *n* ã®å€¤ã¯ã€æŒ‡å®šã—ãªã‘ã‚Œã°æ—¢å®šãŒ 2 "
"ã«ãªã£ã¦ã„ã¾ã™ã€‚è¤‡è£½ã™ã‚‹ã«ã¯å…ƒã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®å†…å®¹ã‚’ä¸€éƒ¨ä¿å­˜ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã‹ã‚‰ã€å¤§ããªã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‹ã‚‰è¤‡è£½ã—ãŸã†ã¡ã®ä¸€ã¤ãŒä»–ã‚ˆã‚Šã‚‚é€²ã‚“ã§ã„ã£ã¦ã—ã¾ã†ã¨ã€å¤§é‡ã®ãƒ¡ãƒ¢ãƒªã‚’æ¶ˆè²»ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"
" ::"

#: ../../howto/functional.rst:818
msgid "Calling functions on elements"
msgstr "è¦ç´ ã«å¯¾ã—ã¦é–¢æ•°ã‚’å‘¼ã¶"

#: ../../howto/functional.rst:820
msgid ""
"The :mod:`operator` module contains a set of functions corresponding to "
"Python's operators.  Some examples are :func:`operator.add(a, b) "
"<operator.add>` (adds two values), :func:`operator.ne(a, b)  <operator.ne>` "
"(same as ``a != b``), and :func:`operator.attrgetter('id') "
"<operator.attrgetter>` (returns a callable that fetches the ``.id`` "
"attribute)."
msgstr ""
"ã„ã¾ä½¿ã£ãŸ :mod:`operator` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã€Python ã®æ¼”ç®—å­ã«å¯¾å¿œã™ã‚‹é–¢æ•°ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚ã„ãã¤ã‹ä¾‹ã‚’æŒ™ã’ã‚‹ã¨ã€ "
":func:`operator.add(a, b) <operator.add>` (äºŒã¤ã®å€¤ã‚’åŠ ç®—)ã€ :func:`operator.ne(a, "
"b) <operator.ne>` (``a != b`` ã¨åŒã˜)ã€ :func:`operator.attrgetter('id') "
"<operator.attrgetter>` (``.id`` å±æ€§ã‚’å–å¾—ã™ã‚‹ã‚³ãƒ¼ãƒ©ãƒ–ãƒ«ã‚’è¿”ã™) ã¨ã„ã£ãŸé–¢æ•°ã§ã™ã€‚"

#: ../../howto/functional.rst:826
msgid ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assumes that the "
"iterable will return a stream of tuples, and calls *func* using these tuples"
" as the arguments::"
msgstr ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` "
"ã¯ã€ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ãŒã‚¿ãƒ—ãƒ«ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã™ã¨ã¿ãªã—ã¦ã€ ãã®ã‚¿ãƒ—ãƒ«ã‚’å¼•æ•°ã«ä½¿ã£ã¦ *func* ã‚’å‘¼ã³ã¾ã™::"

#: ../../howto/functional.rst:838
msgid "Selecting elements"
msgstr "è¦ç´ ã‚’é¸æŠã™ã‚‹"

#: ../../howto/functional.rst:840
msgid ""
"Another group of functions chooses a subset of an iterator's elements based "
"on a predicate."
msgstr "ã•ã‚‰ã«åˆ¥ã®ã‚°ãƒ«ãƒ¼ãƒ—ã¨ã—ã¦ã€è¿°èª (predicate) ã«åŸºã¥ã„ã¦ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®è¦ç´ ã‹ã‚‰ã‚µãƒ–ã‚»ãƒƒãƒˆã‚’é¸ã³å‡ºã™é–¢æ•°ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/functional.rst:843
msgid ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` is "
"the opposite of :func:`filter`, returning all elements for which the "
"predicate returns false::"
msgstr ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` ã¯ "
":func:`filter` ã¨ã¯åå¯¾ã«ã€ è¿°èªãŒå½ã‚’è¿”ã™è¦ç´ ã‚’ã™ã¹ã¦è¿”ã—ã¾ã™::"

#: ../../howto/functional.rst:850
msgid ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` returns "
"elements for as long as the predicate returns true.  Once the predicate "
"returns false, the iterator will signal the end of its results. ::"
msgstr ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` "
"ã¯è¿°èªãŒçœŸã‚’è¿”ã—ã¦ã„ã‚‹é–“ã ã‘è¦ç´ ã‚’è¿”ã—ã¾ã™ã€‚ä¸€åº¦ã§ã‚‚è¿°èªãŒå½ã‚’è¿”ã™ã¨ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯å‡ºåŠ›çµ‚äº†ã®åˆå›³ã‚’ã—ã¾ã™ã€‚ ::"

#: ../../howto/functional.rst:863
msgid ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` discards "
"elements while the predicate returns true, and then returns the rest of the "
"iterable's results. ::"
msgstr ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` "
"ã¯ã€è¿°èªãŒçœŸã‚’è¿”ã—ã¦ã„ã‚‹ã†ã¡ã¯è¦ç´ ã‚’ç„¡è¦–ã—ã€å½ã«ãªã£ã¦ã‹ã‚‰æ®‹ã‚Šã®å‡ºåŠ›ã‚’ã™ã¹ã¦è¿”ã—ã¾ã™ã€‚ ::"

#: ../../howto/functional.rst:873
msgid ""
":func:`itertools.compress(data, selectors) <itertools.compress>` takes two "
"iterators and returns only those elements of *data* for which the "
"corresponding element of *selectors* is true, stopping whenever either one "
"is exhausted::"
msgstr ""
":func:`itertools.compress(data, selectors) <itertools.compress>` ã¯ "
"2ã¤ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’å–ã‚Šã€ ã©ã¡ã‚‰ã‹ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ã„æœãŸã™ã¾ã§ã®ã€ *selectors* ãŒçœŸã¨ãªã‚‹è¦ç´ ã«å¯¾å¿œã™ã‚‹ *data* "
"è¦ç´ ã ã‘ã‚’è¿”ã—ã¾ã™::"

#: ../../howto/functional.rst:882
msgid "Combinatoric functions"
msgstr "çµ„åˆã›é–¢æ•°"

#: ../../howto/functional.rst:884
msgid ""
"The :func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returns an iterator giving all possible *r*-tuple combinations of the "
"elements contained in *iterable*.  ::"
msgstr ""
":func:`itertools.combinations(iterable, r) <itertools.combinations>` ã¯ã€ "
"*iterable* ã‹ã‚‰ *r*-tuple é¸æŠã™ã‚‹å…¨ã¦ã®çµ„ã¿åˆã‚ã›ã‚’æä¾›ã™ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ ::"

#: ../../howto/functional.rst:899
msgid ""
"The elements within each tuple remain in the same order as *iterable* "
"returned them.  For example, the number 1 is always before 2, 3, 4, or 5 in "
"the examples above.  A similar function, "
":func:`itertools.permutations(iterable, r=None) <itertools.permutations>`, "
"removes this constraint on the order, returning all possible arrangements of"
" length *r*::"
msgstr ""
"ãã‚Œãã‚Œã®ã‚¿ãƒ—ãƒ«å†…ã§ã¯ã€è¦ç´ ã¯ *iterable* ãŒãã‚Œã‚’è¿”ã—ãŸã®ã¨åŒã˜é †åºã‚’ä¿ã¡ã¾ã™ã€‚ä¾‹ãˆã°ä¸Šã®ä¾‹ã§ã‚ã‚Œã°ã€ 1 ã¯ã„ã¤ã§ã‚‚ 2, 3, 4, 5"
" ã®å‰ã«æ¥ã¾ã™ã€‚ä¼¼ãŸã‚ˆã†ãªé–¢æ•°ã« :func:`itertools.permutations(iterable, r=None) "
"<itertools.permutations>` ãŒã‚ã‚Šã€ã“ã¡ã‚‰ã¯ã“ã®é †åºã«ã¤ã„ã¦ã®åˆ¶ç´„ãŒãªãã€ *r* å€‹é¸æŠã™ã‚‹å…¨ã¦ã®é †åˆ—ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../howto/functional.rst:918
msgid ""
"If you don't supply a value for *r* the length of the iterable is used, "
"meaning that all the elements are permuted."
msgstr "*r* ã‚’ä¸ãˆãªã„å ´åˆã¯ iterable ã®é•·ã•ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Š iterable ã®å…¨ã¦ã®è¦ç´ ã‚’é¸ã‚“ã é †åˆ—ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../howto/functional.rst:921
msgid ""
"Note that these functions produce all of the possible combinations by "
"position and don't require that the contents of *iterable* are unique::"
msgstr "ã“ã‚Œã‚‰ã®é–¢æ•°ãŒç”Ÿæˆã™ã‚‹çµ„ã¿åˆã‚ã›ã¯ã€ä½ç½®ãŒåŸºæº–ã§ã™ã®ã§ã€ *iterable* ã®å†…å®¹ãŒä¸€æ„ã§ãªãã¨ã‚‚è‰¯ã„ã“ã¨ã«æ³¨ç›®ã—ã¦ãã ã•ã„::"

#: ../../howto/functional.rst:928
msgid ""
"The identical tuple ``('a', 'a', 'b')`` occurs twice, but the two 'a' "
"strings came from different positions."
msgstr "å…¨ãåŒã˜ã‚¿ãƒ—ãƒ« ``('a', 'a', 'b')`` ãŒ 2åº¦ç¾ã‚Œã¦ã„ã¾ã™ãŒã€ã“ã‚Œã¯ 2ã¤ã® 'a' ãŒåˆ¥ã®ä½ç½®ã‹ã‚‰ã®ã‚‚ã®ã ã‹ã‚‰ã§ã™ã€‚"

#: ../../howto/functional.rst:931
msgid ""
"The :func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` function relaxes a different "
"constraint: elements can be repeated within a single tuple.  Conceptually an"
" element is selected for the first position of each tuple and then is "
"replaced before the second element is selected.  ::"
msgstr ""
":func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` é–¢æ•°ã¯åˆ¥ã®åˆ¶ç´„ã‚’å–ã‚Šæ‰•ã„ã¾ã™: "
"ä¸€å›ã®é¸æŠã§åŒã˜è¦ç´ ã‚’ç¹°ã‚Šè¿”ã—é¸ã‚“ã§ã‚‚è‰¯ã„ã€‚æ¦‚å¿µçš„ã«ã¯ã€ãã‚Œãã‚Œã®ã‚¿ãƒ—ãƒ«ã®æœ€åˆã®ã‚‚ã®ã¨ã—ã¦ä¸€ã¤è¦ç´ ãŒé¸ã°ã‚Œã€ç¶šã„ã¦ "
"2ã¤ç›®ã®é¸æŠã®ã‹ã‚ã‚Šã«ãã‚Œã§ç½®ãæ›ã‚ã‚Šã¾ã™ ::"

#: ../../howto/functional.rst:946
msgid "Grouping elements"
msgstr "è¦ç´ ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘ã™ã‚‹"

#: ../../howto/functional.rst:948
msgid ""
"The last function I'll discuss, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, is the most complicated.  "
"``key_func(elem)`` is a function that can compute a key value for each "
"element returned by the iterable.  If you don't supply a key function, the "
"key is simply each element itself."
msgstr ""
"æœ€å¾Œã«è­°é¡Œã«ä¸Šã’ã‚‹é–¢æ•° :func:`itertools.groupby(iter, key_func=None) "
"<itertools.groupby>` ã¯ã€ ã“ã‚Œã¾ã§ã§æœ€ã‚‚è¤‡é›‘ã§ã™ã€‚ ``key_func(elem)`` "
"ã¯ã€ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‹ã‚‰è¿”ã£ã¦ããŸè¦ç´ ãã‚Œãã‚Œã®ã‚­ãƒ¼å€¤ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã§ã™ã€‚ã“ã®é–¢æ•°ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ ã‚­ãƒ¼ã¯å˜ã«å„è¦ç´ ãã®ã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/functional.rst:953
msgid ""
":func:`~itertools.groupby` collects all the consecutive elements from the "
"underlying iterable that have the same key value, and returns a stream of "
"2-tuples containing a key value and an iterator for the elements with that "
"key."
msgstr ""
":func:`~itertools.groupby` "
"ã¯ã€å…ƒã«ãªã‚‹ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‹ã‚‰åŒã˜ã‚­ãƒ¼å€¤ã‚’æŒã¤é€£ç¶šã™ã‚‹è¦ç´ ã‚’é›†ã‚ã¦ã€ã‚­ãƒ¼å€¤ã¨ãã®ã‚­ãƒ¼ã«å¯¾å¿œã™ã‚‹è¦ç´ ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã® 2-ã‚¿ãƒ—ãƒ«ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../howto/functional.rst:981
msgid ""
":func:`~itertools.groupby` assumes that the underlying iterable's contents "
"will already be sorted based on the key.  Note that the returned iterators "
"also use the underlying iterable, so you have to consume the results of "
"iterator-1 before requesting iterator-2 and its corresponding key."
msgstr ""
":func:`~itertools.groupby` "
"ã¯ã€å…ƒã«ãªã‚‹ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã®å†…å®¹ãŒã‚­ãƒ¼å€¤ã§ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸçŠ¶æ…‹ã§ä¸ãˆã‚‰ã‚Œã‚‹ã“ã¨ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚ã“ã“ã§ã€è¿”ã•ã‚Œã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿è‡ªä½“ã‚‚å…ƒã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’ä½¿ã†ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãã®ãŸã‚ã€"
" iterator-1 ã®çµæœã‚’èª­ã¿çµ‚ã‚ã‚‹ã¾ã§ã¯ iterator-2 ã¨ãã‚Œã«å¯¾å¿œã™ã‚‹ã‚­ãƒ¼å€¤ã‚’è¦æ±‚ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../howto/functional.rst:988
msgid "The functools module"
msgstr "functools ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../howto/functional.rst:990
msgid ""
"The :mod:`functools` module in Python 2.5 contains some higher-order "
"functions. A **higher-order function** takes one or more functions as input "
"and returns a new function.  The most useful tool in this module is the "
":func:`functools.partial` function."
msgstr ""
"Python 2.5 ã‹ã‚‰ã® :mod:`functools` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã€é«˜éšé–¢æ•°ãŒã„ãã¤ã‹å…¥ã£ã¦ã„ã¾ã™ã€‚ **é«˜éšé–¢æ•°** "
"ã¨ã¯ã€å…¥åŠ›ã¨ã—ã¦é–¢æ•°ã‚’å—ã‘å–ã£ã¦æ–°ãŸãªé–¢æ•°ã‚’è¿”ã™é–¢æ•°ã§ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä¸€ç•ªä¾¿åˆ©ãªãƒ„ãƒ¼ãƒ«ã¯ :func:`functools.partial` "
"é–¢æ•°ã§ã™ã€‚"

#: ../../howto/functional.rst:995
msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters "
"filled in. Consider a Python function ``f(a, b, c)``; you may wish to create"
" a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; you're "
"filling in a value for one of ``f()``'s parameters.  This is called "
"\"partial function application\"."
msgstr ""
"é–¢æ•°å‹ã‚¹ã‚¿ã‚¤ãƒ«ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯æ™‚æŠ˜ã€æ—¢å­˜ã®é–¢æ•°ã‹ã‚‰ä¸€éƒ¨ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’åŸ‹ã‚ãŸå¤‰ç¨®ã‚’ä½œã‚ŠãŸããªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚Python ã®é–¢æ•° ``f(a, b, "
"c)`` ã¨ã„ã†ã‚‚ã®ãŒã‚ã‚‹ã¨ã—ã¦ãã ã•ã„; ``f(1, b, c)`` ã¨åŒã˜æ„å‘³ã® ``g(b, c)`` ã¨ã„ã†é–¢æ•°ã‚’ä½œã‚ŠãŸããªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™;"
" ã¤ã¾ã‚Š ``f()`` ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ä¸€ã¤åŸ‹ã‚ã‚‹ã‚ã‘ã§ã™ã€‚ã“ã‚Œã¯ã€Œé–¢æ•°ã®éƒ¨åˆ†é©ç”¨ã€ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../howto/functional.rst:1001
msgid ""
"The constructor for :func:`~functools.partial` takes the arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  The "
"resulting object is callable, so you can just call it to invoke ``function``"
" with the filled-in arguments."
msgstr ""
":func:`~functools.partial` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ ``(function, arg1, arg2, ..., "
"kwarg1=value1, kwarg2=value2)`` "
"ã¨ã„ã†å¼•æ•°ã‚’å–ã‚Šã¾ã™ã€‚ã§ãã‚ãŒã£ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚³ãƒ¼ãƒ©ãƒ–ãƒ«ãªã®ã§ã€ãã‚Œã‚’å‘¼ã¹ã°ã€å¼•æ•°ã®åŸ‹ã¾ã£ãŸçŠ¶æ…‹ã§ ``function`` "
"ã‚’å®Ÿè¡Œã—ãŸã®ã¨åŒã˜ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/functional.rst:1006
msgid "Here's a small but realistic example::"
msgstr "ä»¥ä¸‹ã«ã‚ã‚‹ã®ã¯ã€å°ã•ã„ã‘ã‚Œã©ã‚‚ç¾å®Ÿçš„ãªä¸€ã¤ã®ä¾‹ã§ã™::"

#: ../../howto/functional.rst:1018
msgid ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"cumulatively performs an operation on all the iterable's elements and, "
"therefore, can't be applied to infinite iterables. *func* must be a function"
" that takes two elements and returns a single value.  "
":func:`functools.reduce` takes the first two elements A and B returned by "
"the iterator and calculates ``func(A, B)``.  It then requests the third "
"element, C, calculates ``func(func(A, B), C)``, combines this result with "
"the fourth element returned, and continues until the iterable is exhausted."
"  If the iterable returns no values at all, a :exc:`TypeError` exception is "
"raised.  If the initial value is supplied, it's used as a starting point and"
" ``func(initial_value, A)`` is the first calculation. ::"
msgstr ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"ã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã®è¦ç´ ã«å¯¾ã—ã¦æ¬¡ã€…ã«æ¼”ç®—ã‚’å®Ÿè¡Œã—ã¦ã„ã£ãŸæœ€çµ‚çµæœã‚’å‡ºã™ã‚‚ã®ã§ã€ãã‚Œã‚†ãˆç„¡é™é•·ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã«ã¯é©ç”¨ã§ãã¾ã›ã‚“ã€‚ *func* "
"ã«ã¯ã€è¦ç´ ã‚’äºŒã¤å–ã£ã¦å€¤ã‚’ä¸€ã¤è¿”ã™é–¢æ•°ãŒå…¥ã‚Šã¾ã™ã€‚ :func:`functools.reduce` ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒè¿”ã™æœ€åˆã®äºŒè¦ç´  A ã¨ B "
"ã‚’å–ã£ã¦ ``func(A, B)`` ã‚’è¨ˆç®—ã—ã¾ã™ã€‚ãã‚Œã‹ã‚‰ä¸‰ç•ªç›®ã®è¦ç´  C ã‚’è¦æ±‚ã—ã¦ ``func(func(A, B), C)`` "
"ã‚’è¨ˆç®—ã™ã‚‹ã¨ã€ãã®çµæœã‚’ã•ã‚‰ã«å››ç•ªç›®ã®è¦ç´ ã¨çµ„ã¿åˆã‚ã›ã¦â€¦â€¦ã¨ã„ã†ã“ã¨ã‚’ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ãŒå°½ãã‚‹ã¾ã§ç¶šã‘ã‚‹ã®ã§ã™ã€‚ ã‚‚ã—ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ãŒä¸€ã¤ã‚‚å€¤ã‚’è¿”ã•ãªã‘ã‚Œã° "
":exc:`TypeError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ åˆæœŸå€¤ ``initial_value`` ãŒã‚ã‚‹ã¨ãã«ã¯ã€æœ€åˆã®è¨ˆç®—ã§ "
"``func(initial_value, A)`` ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ ::"

#: ../../howto/functional.rst:1042
msgid ""
"If you use :func:`operator.add` with :func:`functools.reduce`, you'll add up"
" all the elements of the iterable.  This case is so common that there's a "
"special built-in called :func:`sum` to compute it:"
msgstr ""
":func:`operator.add` ã‚’ :func:`functools.reduce` ã§ä½¿ã†ã¨ã€ iterable "
"ã®å…¨è¦ç´ ã‚’åˆè¨ˆã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ä½¿ç”¨é »åº¦ãŒé«˜ã„ã®ã§ã€ãã®ãŸã‚ã® :func:`sum` ã¨ã„ã†ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•°ãŒã‚ã‚Šã¾ã™:"

#: ../../howto/functional.rst:1054
msgid ""
"For many uses of :func:`functools.reduce`, though, it can be clearer to just"
" write the obvious :keyword:`for` loop::"
msgstr ""
"ã¨ã¯ã„ãˆã€å¤šãã®å ´åˆ :func:`functools.reduce` ã‚’ä½¿ã†ã‚ˆã‚Šã¯ã€å˜ã« :keyword:`for` "
"ãƒ«ãƒ¼ãƒ—ã‚’æ›¸ã„ãŸã»ã†ãŒã‚ã‹ã‚Šã‚„ã™ããªã‚Šã¾ã™::"

#: ../../howto/functional.rst:1066
msgid ""
"A related function is :func:`itertools.accumulate(iterable, "
"func=operator.add) <itertools.accumulate>`.  It performs the same "
"calculation, but instead of returning only the final result, "
":func:`accumulate` returns an iterator that also yields each partial "
"result::"
msgstr ""
"é–¢é€£ã™ã‚‹é–¢æ•°ã¯ :func:`itertools.accumulate(iterable, func=operator.add) "
"<itertools.accumulate>` ã§ã™ã€‚ã“ã®é–¢æ•°ã¯åŒã˜è¨ˆç®—ã‚’ã—ã¾ã™ãŒã€æœ€çµ‚çµæœã‚’è¿”ã™ã®ã§ã¯ãªãã€ :func:`accumulate` "
"ã¯ãã‚Œãã‚Œã®ä¸­é–“çµæœã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒè¿”ã‚Šå€¤ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../howto/functional.rst:1079
msgid "The operator module"
msgstr "operator ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../howto/functional.rst:1081
msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often "
"useful in functional-style code because they save you from writing trivial "
"functions that perform a single operation."
msgstr ""
":mod:`operator` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€æ—¢ã«å–ã‚Šä¸Šã’ã¾ã—ãŸãŒã€Python "
"ã®æ¼”ç®—å­ã«å¯¾å¿œã™ã‚‹é–¢æ•°ãŒå…¥ã£ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ã€‚é–¢æ•°å‹ã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã«ãŠã„ã¦ã€æ¼”ç®—ã‚’ä¸€ã¤å®Ÿè¡Œã™ã‚‹ã ã‘ã®ãã ã‚‰ãªã„é–¢æ•°ã‚’æ›¸ã‹ãšã«æ¸ˆã‚€ã®ã§ã€ã‚ˆãä¸–è©±ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/functional.rst:1086
msgid "Some of the functions in this module are:"
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–¢æ•°ã‚’ä¸€éƒ¨ã ã‘ç´¹ä»‹ã—ã¾ã—ã‚‡ã†:"

#: ../../howto/functional.rst:1088
msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, ``abs()``,"
" ..."
msgstr ""
"æ•°å­¦æ¼”ç®—å­: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, ``abs()``, ..."

#: ../../howto/functional.rst:1089
msgid "Logical operations: ``not_()``, ``truth()``."
msgstr "è«–ç†æ¼”ç®—å­: ``not_()``, ``truth()``"

#: ../../howto/functional.rst:1090
msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr "ãƒ“ãƒƒãƒˆæ¼”ç®—å­: ``and_()``, ``or_()``, ``invert()``"

#: ../../howto/functional.rst:1091
msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and ``ge()``."
msgstr "æ¯”è¼ƒ: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, ``ge()``"

#: ../../howto/functional.rst:1092
msgid "Object identity: ``is_()``, ``is_not()``."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè­˜åˆ¥: ``is_()``, ``is_not()``"

#: ../../howto/functional.rst:1094
msgid "Consult the operator module's documentation for a complete list."
msgstr "ã¡ã‚ƒã‚“ã¨ã—ãŸä¸€è¦§ã¯ operator ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ–‡æ›¸ã§ã”è¦§ãã ã•ã„ã€‚"

#: ../../howto/functional.rst:1098
msgid "Small functions and the lambda expression"
msgstr "å°ã•ãªé–¢æ•°ã¨ãƒ©ãƒ ãƒ€å¼"

#: ../../howto/functional.rst:1100
msgid ""
"When writing functional-style programs, you'll often need little functions "
"that act as predicates or that combine elements in some way."
msgstr ""
"é–¢æ•°å‹ã‚¹ã‚¿ã‚¤ãƒ«ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã„ã¦ã„ã‚‹ã¨ã€è¿°èªã¨ã—ã¦åƒã„ãŸã‚Šã€ä½•ã‚‰ã‹ã®å½¢ã§è¦ç´ ã‚’ã¤ãªãåˆã‚ã›ãŸã‚Šã™ã‚‹ãƒŸãƒ‹ã‚µã‚¤ã‚ºã®é–¢æ•°ã‚’å¿…è¦ã¨ã™ã‚‹ã“ã¨ãŒã‚ˆãã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/functional.rst:1103
msgid ""
"If there's a Python built-in or a module function that's suitable, you don't"
" need to define a new function at all::"
msgstr "ã¡ã‚‡ã†ã©è‰¯ã„é–¢æ•°ãŒãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã‚„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å­˜åœ¨ã—ã¦ã„ã‚Œã°ã€æ–°ã—ã„é–¢æ•°ã‚’å®šç¾©ã™ã‚‹å¿…è¦ã¯ã¾ã£ãŸãã‚ã‚Šã¾ã›ã‚“::"

#: ../../howto/functional.rst:1109
msgid ""
"If the function you need doesn't exist, you need to write it.  One way to "
"write small functions is to use the :keyword:`lambda` statement.  ``lambda``"
" takes a number of parameters and an expression combining these parameters, "
"and creates an anonymous function that returns the value of the expression::"
msgstr ""
"ã—ã‹ã—ã€æ¬²ã—ã„é–¢æ•°ãŒãªã„ãªã‚‰æ›¸ãã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ãã†ã—ãŸå°ã•ãªé–¢æ•°ã‚’æ›¸ãæ–¹æ³•ã® ä¸€ã¤ãŒ :keyword:`lambda` æ–‡ã§ã™ã€‚ "
"``lambda`` ã¯å¼•æ•°ã¨ã—ã¦è¤‡æ•°ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ ãã‚Œã‚’ã¤ãªãå¼ã‚’å–ã‚Šã€ãã®å¼ã®å€¤ã‚’è¿”ã™ç„¡åã®é–¢æ•°ã‚’ä½œã‚Šã¾ã™::"

#: ../../howto/functional.rst:1118
msgid ""
"An alternative is to just use the ``def`` statement and define a function in"
" the usual way::"
msgstr "ã‚‚ã†ä¸€ã¤ã®é¸æŠè‚¢ã¯ã€ãµã¤ã†ã« ``def`` æ–‡ã§é–¢æ•°ã‚’å®šç¾©ã™ã‚‹ã ã‘ã§ã™::"

#: ../../howto/functional.rst:1127
msgid ""
"Which alternative is preferable?  That's a style question; my usual course "
"is to avoid using ``lambda``."
msgstr ""
"ã©ã¡ã‚‰ã®ã»ã†ãŒè‰¯ã„ã®ã§ã—ã‚‡ã†ã‹ã€‚ãã‚Œã¯å¥½ã¿ã®å•é¡Œã§ã™; è‘—è€…ã®ã‚¹ã‚¿ã‚¤ãƒ«ã¨ã—ã¦ã¯ã§ãã‚‹ã ã‘ ``lambda`` ã‚’ä½¿ã‚ãªã„ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚"

#: ../../howto/functional.rst:1130
msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much in a"
" ``lambda`` statement, you'll end up with an overly complicated expression "
"that's hard to read.  Quick, what's the following code doing? ::"
msgstr ""
"ãã®ã‚ˆã†ã«ã—ã¦ã„ã‚‹ç†ç”±ã®ä¸€ã¤ã«ã€``lambda`` "
"ã¯å®šç¾©ã§ãã‚‹é–¢æ•°ãŒéå¸¸ã«é™ã‚‰ã‚Œã¦ã„ã‚‹ã¨ã„ã†ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚ä¸€ã¤ã®å¼ã¨ã—ã¦ç®—å‡ºã§ãã‚‹çµæœã«ã—ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã®ã§ã€``if... elif... "
"else`` ã‚„ ``try... except`` ã®ã‚ˆã†ãªåˆ†å²ã‚’æŒã¤ã“ã¨ãŒã§ããªã„ã®ã§ã™ã€‚``lambda`` "
"æ–‡ã®ä¸­ã§ãŸãã•ã‚“ã®ã“ã¨ã‚’ã‚„ã‚ã†ã¨ã—ã™ãã‚‹ã¨ã€ã”ã¡ã‚ƒã”ã¡ã‚ƒã—ã¦èª­ã¿ã«ãã„å¼ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚ã•ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ä½•ã‚’ã—ã¦ã„ã‚‹ã§ã—ã‚‡ã†ã‹ã€ç´ æ—©ããŠç­”ãˆãã ã•ã„!"
" ::"

#: ../../howto/functional.rst:1140
msgid ""
"You can figure it out, but it takes time to disentangle the expression to "
"figure out what's going on.  Using a short nested ``def`` statements makes "
"things a little bit better::"
msgstr ""
"ã‚ã‹ã‚‹ã«ã¯ã‚ã‹ã‚‹ã§ã—ã‚‡ã†ãŒã€ä½•ãŒã©ã†ãªã£ã¦ã„ã‚‹ã®ã‹ç´è§£ã„ã¦ã„ãã«ã¯æ™‚é–“ãŒã‹ã‹ã‚‹ã¯ãšã§ã™ã€‚çŸ­ã„ ``def`` "
"æ–‡ã§å…¥ã‚Œå­ã«ã™ã‚‹ã¨ã€å°‘ã—è¦‹é€šã—ãŒè‰¯ããªã‚Šã¾ã™ãŒ::"

#: ../../howto/functional.rst:1150
msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr "ã§ã‚‚å˜ç´”ã« ``for`` ãƒ«ãƒ¼ãƒ—ã«ã™ã‚Œã°è‰¯ã‹ã£ãŸã®ã§ã™::"

#: ../../howto/functional.rst:1156
msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr "ã‚ã‚‹ã„ã¯ :func:`sum` ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã¨ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã§ã‚‚è‰¯ã„ã§ã™ã­::"

#: ../../howto/functional.rst:1160
msgid ""
"Many uses of :func:`functools.reduce` are clearer when written as ``for`` "
"loops."
msgstr ""
"å¤šãã®å ´åˆã€ :func:`functools.reduce` ã‚’ä½¿ã£ã¦ã„ã‚‹ã¨ã“ã‚ã¯ ``for`` ãƒ«ãƒ¼ãƒ—ã« æ›¸ãç›´ã—ãŸã»ã†ãŒè¦‹ã‚„ã™ã„ã§ã™ã€‚"

#: ../../howto/functional.rst:1162
msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring uses"
" of ``lambda``:"
msgstr "Fredrik Lundh ã¯ä»¥å‰ ``lambda`` åˆ©ç”¨ã®ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã«é–¢ã—ã¦ä»¥ä¸‹ã®æŒ‡é‡ã‚’ææ¡ˆã—ãŸã“ã¨ãŒã‚ã‚Šã¾ã™:"

#: ../../howto/functional.rst:1165
msgid "Write a lambda function."
msgstr "ãƒ©ãƒ ãƒ€é–¢æ•°ã‚’æ›¸ãã€‚"

#: ../../howto/functional.rst:1166
msgid "Write a comment explaining what the heck that lambda does."
msgstr "ãã®ãƒ©ãƒ ãƒ€ãŒä¸€ä½“ãœã‚“ãŸã„ä½•ã‚’ã—ã¦ã„ã‚‹ã®ã‹ã‚³ãƒ¡ãƒ³ãƒˆã§èª¬æ˜ã™ã‚‹ã€‚"

#: ../../howto/functional.rst:1167
msgid ""
"Study the comment for a while, and think of a name that captures the essence"
" of the comment."
msgstr "ãã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã—ã°ã‚‰ãç ”ç©¶ã—ã¦ã€æœ¬è³ªã‚’ã¨ã‚‰ãˆãŸåå‰ã‚’è€ƒãˆã‚‹ã€‚"

#: ../../howto/functional.rst:1169
msgid "Convert the lambda to a def statement, using that name."
msgstr "ãƒ©ãƒ ãƒ€ã‚’ãã®åå‰ã§ def æ–‡ã«æ›¸ãæ›ãˆã‚‹ã€‚"

#: ../../howto/functional.rst:1170
msgid "Remove the comment."
msgstr "ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ¶ˆã™ã€‚"

#: ../../howto/functional.rst:1172
msgid ""
"I really like these rules, but you're free to disagree about whether this "
"lambda-free style is better."
msgstr "è‘—è€…ã¯ã“ã®æŒ‡é‡ã‚’æœ¬å½“ã«æ°—ã«å…¥ã£ã¦ã„ã¾ã™ãŒã€ã“ã†ã—ãŸãƒ©ãƒ ãƒ€ãªã—ã‚¹ã‚¿ã‚¤ãƒ«ãŒä»–ã‚ˆã‚Šå„ªã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã«ã¤ã„ã¦ã€ç•°è«–ã¯èªã‚ã¾ã™ã€‚"

#: ../../howto/functional.rst:1177
msgid "Revision History and Acknowledgements"
msgstr "æ›´æ–°å±¥æ­´ã¨è¬è¾"

#: ../../howto/functional.rst:1179
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article:"
" Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike"
" Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton."
msgstr ""
"è‘—è€…ã¯ææ¡ˆã®ç”³ã—å‡ºã‚„ä¿®æ­£ã€æ§˜ã€…ãªã“ã®è¨˜äº‹ã®è‰ç¨¿ã®åŠ©ã‘ã‚’ã—ã¦ãã‚ŒãŸä»¥ä¸‹ã®äººã€…ã«æ„Ÿè¬ã—ã¾ã™: Ian Bicking, Nick Coghlan, Nick"
" Efford, Raymond Hettinger, Jim Jewett, Mike Krell, Leandro Lameiro, Jussi "
"Salmela, Collin Winter, Blake Winton."

#: ../../howto/functional.rst:1184
msgid "Version 0.1: posted June 30 2006."
msgstr "Version 0.1: posted June 30 2006."

#: ../../howto/functional.rst:1186
msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr "Version 0.11: posted July 1 2006.  Typo fixes."

#: ../../howto/functional.rst:1188
msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."
msgstr ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."

#: ../../howto/functional.rst:1191
msgid ""
"Version 0.21: Added more references suggested on the tutor mailing list."
msgstr ""
"Version 0.21: Added more references suggested on the tutor mailing list."

#: ../../howto/functional.rst:1193
msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."
msgstr ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."

#: ../../howto/functional.rst:1198
msgid "References"
msgstr "å‚è€ƒè³‡æ–™"

#: ../../howto/functional.rst:1201
msgid "General"
msgstr "ä¸€èˆ¬è«–"

#: ../../howto/functional.rst:1203
msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson and"
" Gerald Jay Sussman with Julie Sussman.  Full text at "
"https://mitpress.mit.edu/sicp/.  In this classic textbook of computer "
"science, chapters 2 and 3 discuss the use of sequences and streams to "
"organize the data flow inside a program.  The book uses Scheme for its "
"examples, but many of the design approaches described in these chapters are "
"applicable to functional-style Python code."
msgstr ""
"Harold Abelson ã¨ Gerald Jay Sussman, Julie Sussman ã«ã‚ˆã‚‹ **Structure and "
"Interpretation of Computer Programs**ã€‚https://mitpress.mit.edu/sicp/ "
"ã«å…¨æ–‡ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®è¨ˆç®—æ©Ÿç§‘å­¦ã«é–¢ã™ã‚‹å¤å…¸çš„ãªæ•™ç§‘æ›¸ã§ã¯ã€2 ç« ã¨ 3 "
"ç« ã§ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã§ã¾ã¨ã‚ã‚‹ãŸã‚ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®åˆ©ç”¨ã«ã¤ã„ã¦è­°è«–ã—ã¦ã„ã¾ã™ã€‚ã“ã®æœ¬ã¯ä¾‹ã¨ã—ã¦ Scheme "
"ã‚’ä½¿ã£ã¦ã„ã¾ã™ãŒã€ã“ã‚Œã‚‰ã®ç« å†…ã®å¤šãã®ãƒ‡ã‚¶ã‚¤ãƒ³ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯é–¢æ•°ã‚¹ã‚¿ã‚¤ãƒ«ãª Python ã‚³ãƒ¼ãƒ‰ã«ã‚‚é©ç”¨ã§ãã¾ã™ã€‚"

#: ../../howto/functional.rst:1211
msgid ""
"http://www.defmacro.org/ramblings/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy historical "
"introduction."
msgstr ""
"http://www.defmacro.org/ramblings/fp.html: é–¢æ•°ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ä¸€èˆ¬çš„ãªå…¥é–€ã§ Java "
"ã§ã®ä¾‹ã‚’åˆ©ç”¨ã—ã¦ã„ã¦ã€é•·å¤§ãªæ­´å²ã®ç´¹ä»‹ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/functional.rst:1214
msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr ""
"https://en.wikipedia.org/wiki/Functional_programming: "
"é–¢æ•°ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«é–¢ã™ã‚‹ä¸€èˆ¬çš„ãªå†…å®¹ã®è¨˜äº‹ã€‚"

#: ../../howto/functional.rst:1217
msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr "https://en.wikipedia.org/wiki/Coroutine: ã‚³ãƒ«ãƒ¼ãƒãƒ³ã«é–¢ã™ã‚‹è¨˜äº‹ã€‚"

#: ../../howto/functional.rst:1219
msgid ""
"https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr "https://en.wikipedia.org/wiki/Currying: ã‚«ãƒªãƒ¼åŒ–ã®æ¦‚å¿µã«é–¢ã™ã‚‹è¨˜äº‹ã€‚"

#: ../../howto/functional.rst:1222
msgid "Python-specific"
msgstr "Python ç‰¹æœ‰ã®è©±"

#: ../../howto/functional.rst:1224
msgid ""
"http://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming for "
"text processing, in the section titled \"Utilizing Higher-Order Functions in"
" Text Processing\"."
msgstr ""
"http://gnosis.cx/TPiP/: David Mertz's ã®æœ¬ã®æœ€åˆã®ç«  :title-reference:`Text "
"Processing in Python` ã§ã¯æ–‡æ›¸å‡¦ç†ã®ãŸã‚ã®é–¢æ•°ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«ã¤ã„ã¦è­°è«–ã—ã¦ã„ã¾ã™ã€ã“ã®è­°è«–ã®ç¯€ã«ã¯ \"Utilizing "
"Higher-Order Functions in Text Processing\" ã¨ã„ã†ã‚¿ã‚¤ãƒˆãƒ«ãŒã¤ã„ã¦ã„ã¾ã™ã€‚"

#: ../../howto/functional.rst:1229
msgid ""
"Mertz also wrote a 3-part series of articles on functional programming for "
"IBM's DeveloperWorks site; see `part 1 "
"<https://www.ibm.com/developerworks/linux/library/l-prog/index.html>`__, "
"`part 2 "
"<https://www.ibm.com/developerworks/linux/library/l-prog2/index.html>`__, "
"and `part 3 "
"<https://www.ibm.com/developerworks/linux/library/l-prog3/index.html>`__,"
msgstr ""
"Mertz ã¯ IBM ã® DeveloperWorks ã‚µã‚¤ãƒˆã«ã‚‚é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«é–¢ã™ã‚‹ 3 éƒ¨æ§‹æˆã®è¨˜äº‹ã‚’æ›¸ã„ã¦ã„ã¾ã™; `part 1 "
"<https://www.ibm.com/developerworks/linux/library/l-prog/index.html>`__, "
"`part 2 "
"<https://www.ibm.com/developerworks/linux/library/l-prog2/index.html>`__, "
"`part 3 "
"<https://www.ibm.com/developerworks/linux/library/l-prog3/index.html>`__,"

#: ../../howto/functional.rst:1237
msgid "Python documentation"
msgstr "Python æ–‡æ›¸"

#: ../../howto/functional.rst:1239
msgid "Documentation for the :mod:`itertools` module."
msgstr ":mod:`itertools` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ–‡æ›¸ã€‚"

#: ../../howto/functional.rst:1241
msgid "Documentation for the :mod:`functools` module."
msgstr ":mod:`functools` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€‚"

#: ../../howto/functional.rst:1243
msgid "Documentation for the :mod:`operator` module."
msgstr ":mod:`operator` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ–‡æ›¸ã€‚"

#: ../../howto/functional.rst:1245
msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`: \"Generator Expressions\""

#: ../../howto/functional.rst:1247
msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
