# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2019
# Tetsuo Koyama <tkoyama010@gmail.com>, 2020
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 16:02+0000\n"
"PO-Revision-Date: 2019-09-01 03:37+0000\n"
"Last-Translator: Tetsuo Koyama <tkoyama010@gmail.com>, 2020\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/functional.rst:3
msgid "Functional Programming HOWTO"
msgstr "関数型プログラミング HOWTO"

#: ../../howto/functional.rst:0
msgid "Author"
msgstr "著者"

#: ../../howto/functional.rst:5
msgid "A. M. Kuchling"
msgstr "A. M. Kuchling"

#: ../../howto/functional.rst:0
msgid "Release"
msgstr "リリース"

#: ../../howto/functional.rst:6
msgid "0.32"
msgstr "0.32"

#: ../../howto/functional.rst:8
msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to the "
"concepts of functional programming, we'll look at language features such as :"
"term:`iterator`\\s and :term:`generator`\\s and relevant library modules "
"such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"この文書では、関数型スタイルでプログラムを実装するのにピッタリな Python の機"
"能を見てまわることにしましょう。まず関数型プログラミングという概念を紹介した"
"あと、 :term:`iterator` や :term:`generator` のような言語機能、および :mod:"
"`itertools` や :mod:`functools` といった関連するライブラリモジュールを見るこ"
"とにします。"

#: ../../howto/functional.rst:16
msgid "Introduction"
msgstr "はじめに"

#: ../../howto/functional.rst:18
msgid ""
"This section explains the basic concept of functional programming; if you're "
"just interested in learning about Python language features, skip to the next "
"section on :ref:`functional-howto-iterators`."
msgstr ""
"この章は関数型プログラミングの基本概念を説明します; Python の言語機能について"
"だけ知りたい人は、次の章の :ref:`functional-howto-iterators` まで飛ばしてくだ"
"さい。"

#: ../../howto/functional.rst:22
msgid ""
"Programming languages support decomposing problems in several different ways:"
msgstr ""
"プログラミング言語とは問題を分解するものですが、各言語がサポートする分解方法"
"にはいくつかの種類があります:"

#: ../../howto/functional.rst:24
msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input.  C, "
"Pascal, and even Unix shells are procedural languages."
msgstr ""
"ほとんどのプログラミング言語は **手続き型** です: プログラムは、入力に対して"
"行うべきことをコンピュータに教える指示リストとなります。 C, Pascal, さらには "
"Unix シェルまでもが手続き型言語に入ります。"

#: ../../howto/functional.rst:28
msgid ""
"In **declarative** languages, you write a specification that describes the "
"problem to be solved, and the language implementation figures out how to "
"perform the computation efficiently.  SQL is the declarative language you're "
"most likely to be familiar with; a SQL query describes the data set you want "
"to retrieve, and the SQL engine decides whether to scan tables or use "
"indexes, which subclauses should be performed first, etc."
msgstr ""
"**宣言型** 言語で書くのは、解くべき問題を説明する仕様書であって、それを効率的"
"に計算処理する方法を見付けるのは言語実装の役目です。SQL はおそらく一番よく知"
"られた宣言型言語です; SQL のクエリは取得したいデータセットを説明しているだけ"
"で、テーブルを走査するかインデックスを使うか、どのサブクローズから実行するか"
"等々を決めるのは SQL エンジンなのです。"

#: ../../howto/functional.rst:35
msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this internal "
"state in some way. Smalltalk and Java are object-oriented languages.  C++ "
"and Python are languages that support object-oriented programming, but don't "
"force the use of object-oriented features."
msgstr ""
"**オブジェクト指向** プログラムはオブジェクトの集まりを操作します。オブジェク"
"トには内部状態があり、その状態を調べたり色々と変更したりするためのメソッドが"
"あります。Smalltalk や Java はオブジェクト指向言語です。 C++ と Python はオブ"
"ジェクト指向プログラミングをサポートしていますが、関連する機能を使わなくても"
"構わないようになっています。"

#: ../../howto/functional.rst:41
msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have any "
"internal state that affects the output produced for a given input.  Well-"
"known functional languages include the ML family (Standard ML, OCaml, and "
"other variants) and Haskell."
msgstr ""
"**関数型** プログラミングは問題をいくつかの関数にわけて考えます。理想的に言う"
"と、関数は入力を受けて出力を吐くだけで、同じ入力に対して異なる出力をするよう"
"な内部状態を一切持ちません。有名な関数型言語には ML 一家 (Standard ML, OCaml "
"等々) と Haskell があります。"

#: ../../howto/functional.rst:47
msgid ""
"The designers of some computer languages choose to emphasize one particular "
"approach to programming.  This often makes it difficult to write programs "
"that use a different approach.  Other languages are multi-paradigm languages "
"that support several different approaches. Lisp, C++, and Python are multi-"
"paradigm; you can write programs or libraries that are largely procedural, "
"object-oriented, or functional in all of these languages.  In a large "
"program, different sections might be written using different approaches; the "
"GUI might be object-oriented while the processing logic is procedural or "
"functional, for example."
msgstr ""
"設計者が特定のアプローチを強調することにした言語もありますが、そうすると大抵"
"は、別のアプローチを使うプログラムを書きにくくなります。複数のアプローチに対"
"応した言語もあり、Lisp, C++, Python はそうしたマルチパラダイム言語です; この"
"中のどれを使っても、基本的に手続き型な、または基本的にオブジェクト指向な、と"
"か、基本的に関数型なプログラムやライブラリを書くことができます。大きなプログ"
"ラムでは、各部で別々のアプローチを使って書くことがあるかもしれません; GUI は"
"オブジェクト指向で、でも処理ロジックは手続き型や関数型で、といったようにで"
"す。"

#: ../../howto/functional.rst:58
msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional style "
"discourages functions with side effects that modify internal state or make "
"other changes that aren't visible in the function's return value.  Functions "
"that have no side effects at all are called **purely functional**.  Avoiding "
"side effects means not using data structures that get updated as a program "
"runs; every function's output must only depend on its input."
msgstr ""
"関数型プログラムでは、入力は一連の関数を通って流れていきます。それぞれの関数"
"は入力に何らかの作業をして出力します。関数型スタイルにおいては、内部状態を変"
"えてしまったり、返り値に現れない変更をしたりといった副作用のある関数はやめる"
"ように言われています。副作用のまったくない関数は **純粋関数型** であるとされ"
"ます。副作用をなくすということは、プログラムの実行中に順次変化していくデータ"
"構造を持たない、つまり各関数の出力はその入力にしか影響を受けてはいけないとい"
"うことです。"

#: ../../howto/functional.rst:66
msgid ""
"Some languages are very strict about purity and don't even have assignment "
"statements such as ``a=3`` or ``c = a + b``, but it's difficult to avoid all "
"side effects.  Printing to the screen or writing to a disk file are side "
"effects, for example.  For example, in Python a call to the :func:`print` "
"or :func:`time.sleep` function both return no useful value; they're only "
"called for their side effects of sending some text to the screen or pausing "
"execution for a second."
msgstr ""
"この純粋性を守る面で非常に厳しい言語もあり、そうした言語には ``a=3`` や ``c "
"= a + b`` といった代入文さえありません。しかし副作用を完全になくすのは難しい"
"もので、たとえば画面表示やディスクファイルへの書き込みも副作用なのです。 "
"Python で言うと、たとえば :func:`print` や :func:`time.sleep` 関数の呼び出し"
"はどちらも意味ある値を返しません; ただ画面にテキストを送ったり動作を 1 秒止め"
"たりといった副作用のためだけに呼ばれるのです。"

#: ../../howto/functional.rst:74
msgid ""
"Python programs written in functional style usually won't go to the extreme "
"of avoiding all I/O or all assignments; instead, they'll provide a "
"functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have "
"other side effects."
msgstr ""
"関数型スタイルで書いた Python プログラムはふつう、I/O や代入を完全になくすと"
"いった極端なところまでは行かずに、関数型っぽく見えるインタフェースを提供しつ"
"つも内部では非関数型の機能を使います。たとえば、関数内でローカル変数の代入は"
"使いますが、グローバル変数は変更せず、他の副作用もないように実装するのです。"

#: ../../howto/functional.rst:80
msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, and "
"programs consist of making the right set of state changes.  Functional "
"programming wants to avoid state changes as much as possible and works with "
"data flowing between functions.  In Python you might combine the two "
"approaches by writing functions that take and return instances representing "
"objects in your application (e-mail messages, transactions, etc.)."
msgstr ""
"関数型プログラミングはオブジェクト指向プログラミングの反対と考えることもでき"
"ます。オブジェクト指向において、オブジェクトは内部状態とそれを変更するメソッ"
"ドコールの入ったカプセルであり、プログラムはその状態を適正に変化させていく手"
"順です。一方で、関数型プログラミングは可能なかぎり状態の変更を避け、関数どう"
"しの間を流れるデータだけを扱おうとします。Python ではこの二つのアプローチを結"
"び合わせることができます。アプリケーション内のオブジェクト (メール、トランザ"
"クション、等々) を表現したインスタンスを、関数が受け渡しするようにするので"
"す。"

#: ../../howto/functional.rst:89
msgid ""
"Functional design may seem like an odd constraint to work under.  Why should "
"you avoid objects and side effects?  There are theoretical and practical "
"advantages to the functional style:"
msgstr ""
"関数型デザインは、わけのわからない制約に見えるかもしれません。どうしてオブ"
"ジェクトも副作用もないほうが良いのでしょうか。実は、関数型スタイルには理論と"
"実践に基づく次の利点があるのです:"

#: ../../howto/functional.rst:93
msgid "Formal provability."
msgstr "形式的証明可能性。"

#: ../../howto/functional.rst:94
msgid "Modularity."
msgstr "モジュラー性。"

#: ../../howto/functional.rst:95
msgid "Composability."
msgstr "結合性。"

#: ../../howto/functional.rst:96
msgid "Ease of debugging and testing."
msgstr "デバッグやテストの簡単さ。"

#: ../../howto/functional.rst:100
msgid "Formal provability"
msgstr "形式的証明可能性"

#: ../../howto/functional.rst:102
msgid ""
"A theoretical benefit is that it's easier to construct a mathematical proof "
"that a functional program is correct."
msgstr ""
"理論面の利点としては、プログラムが正しいことの数学的証明を他より簡単に構築で"
"きるという点があります。"

#: ../../howto/functional.rst:105
msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces "
"the right result for all possible inputs."
msgstr ""
"研究者たちは長いあいだ、プログラムが正しいことを数学的に証明する方法の発見に"
"血道をあげてきました。これは、色々な入力でテストして出力が正しかったからまあ"
"正しいだろう、と結論するのとも違いますし、ソースコードを読んで「間違いはなさ"
"そうだ」と言うのとも別の話です; 目指すのは、出現しうる入力すべてに対してプロ"
"グラムが正しい結果を出すことの厳密な証明なのです。"

#: ../../howto/functional.rst:112
msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's variables "
"that are always true.  For each line of code, you then show that if "
"invariants X and Y are true **before** the line is executed, the slightly "
"different invariants X' and Y' are true **after** the line is executed.  "
"This continues until you reach the end of the program, at which point the "
"invariants should match the desired conditions on the program's output."
msgstr ""
"プログラムを証明するために使われているのは **不変式** を書き出していくという"
"テクニックで、不変式とは入力データやプログラム変数のうち常に真である性質のこ"
"とです。コードの一行一行で、 **実行前** の不変式 X と Y が真なら **実行後に"
"** ちょっと違う不変式 X' と Y' が真になることを示していき、これをプログラムの"
"終わりまで続けるわけです。すると最終的な不変式はプログラムの出力に合った条件"
"になっているはずです。"

#: ../../howto/functional.rst:120
msgid ""
"Functional programming's avoidance of assignments arose because assignments "
"are difficult to handle with this technique; assignments can break "
"invariants that were true before the assignment without producing any new "
"invariants that can be propagated onward."
msgstr ""
"関数型プログラミングが代入を嫌うのは、この不変式テクニックでは代入を扱いにく"
"いからです; 代入は、それまで真だった不変式を壊しておいて、自分は次の行に伝え"
"てゆける不変式を生み出さないことがあるのです。"

#: ../../howto/functional.rst:125
msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that are "
"several pages long; the proof of correctness for a moderately complicated "
"program would be enormous, and few or none of the programs you use daily "
"(the Python interpreter, your XML parser, your web browser) could be proven "
"correct.  Even if you wrote down or generated a proof, there would then be "
"the question of verifying the proof; maybe there's an error in it, and you "
"wrongly believe you've proved the program correct."
msgstr ""
"残念ながら、プログラムの証明はだいたい実際的でもありませんし、Python ソフト"
"ウェアにも関係ありません。本当に簡単なプログラムでも、証明には数ページにわた"
"る論文が必要なのです; ある程度の複雑なプログラムではもう尋常でない長さになっ"
"てしまうので、日常で使っているプログラム (Python インタプリタ、XML パーサ、"
"ウェブブラウザ) はほとんど、あるいはすべて、正しさを証明するのは不可能でしょ"
"う。仮に証明を書き出したり生成したりしても、その証明を検証するための疑いが残"
"ります; 証明に間違いがあるかもしれず、その場合は証明したと自分で勝手に思い込"
"んでいただけになるのです。"

#: ../../howto/functional.rst:136
msgid "Modularity"
msgstr "モジュラー性"

#: ../../howto/functional.rst:138
msgid ""
"A more practical benefit of functional programming is that it forces you to "
"break apart your problem into small pieces.  Programs are more modular as a "
"result.  It's easier to specify and write a small function that does one "
"thing than a large function that performs a complicated transformation.  "
"Small functions are also easier to read and to check for errors."
msgstr ""
"より実用的には、関数型プログラミングをすると問題を細かく切り分けることになる"
"という利点があります。結果としてプログラムはモジュラー化されます。複雑な変形"
"を施す大きな関数を書くより、一つのことに絞ってそれだけをする小さな関数のほう"
"が書きやすいものです。それに、小さいほうが読むのもエラーをチェックするのも簡"
"単です。"

#: ../../howto/functional.rst:146
msgid "Ease of debugging and testing"
msgstr "デバグやテストの簡単さ"

#: ../../howto/functional.rst:148
msgid "Testing and debugging a functional-style program is easier."
msgstr "テストやデバグも関数型プログラムなら簡単です。"

#: ../../howto/functional.rst:150
msgid ""
"Debugging is simplified because functions are generally small and clearly "
"specified.  When a program doesn't work, each function is an interface point "
"where you can check that the data are correct.  You can look at the "
"intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"関数が一般的に小さくて明確に意味付けされているので、デバグ方法は単純です。プ"
"ログラムが正しく動かないときには、関数ひとつひとつがデータの正しさをチェック"
"するポイントになるので、それぞれの時点における入力と出力を見ていけば、バグの"
"原因となる関数を素早く切り出すことができるのです。"

#: ../../howto/functional.rst:155
msgid ""
"Testing is easier because each function is a potential subject for a unit "
"test. Functions don't depend on system state that needs to be replicated "
"before running a test; instead you only have to synthesize the right input "
"and then check that the output matches expectations."
msgstr ""
"ひとつひとつの関数がユニットテストの対象になり得るわけですから、テストも簡単"
"です。関数はシステムの状態に依存しませんので、テストの実行前にそうした状態を"
"再現する必要はありません; 単に適切な入力を合成して、出力が期待どおりかどうか"
"チェックするだけで良いのです。"

#: ../../howto/functional.rst:162
msgid "Composability"
msgstr "結合性"

#: ../../howto/functional.rst:164
msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will be "
"unavoidably specialized to a particular application, but others will be "
"useful in a wide variety of programs.  For example, a function that takes a "
"directory path and returns all the XML files in the directory, or a function "
"that takes a filename and returns its contents, can be applied to many "
"different situations."
msgstr ""
"関数型スタイルのプログラムを作っていると、色々な入力や出力のために色々な関数"
"を書くことになります。仕方なく特定のアプリケーションに特化した関数を書くこと"
"もあるでしょうけれど、広範なプログラムに使える関数もあることでしょう。たとえ"
"ば、ディレクトリ名を受け取ってその中の XML ファイル一覧を返す関数や、ファイル"
"名を受け取って内容を返す関数などは、多様な場面に適用できそうです。"

#: ../../howto/functional.rst:171
msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new configuration "
"and writing a few functions specialized for the current task."
msgstr ""
"時たつうちに自分の特製ライブラリやユーティリティが充実してくると、新しいプロ"
"グラムも、既存の関数を調整して少し今回に特化した関数を書くだけで組み立てられ"
"るようになります。"

#: ../../howto/functional.rst:179
msgid "Iterators"
msgstr "イテレータ (iterator)"

#: ../../howto/functional.rst:181
msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr ""
"まずは関数型スタイルのプログラムを書く際の基礎となる重要な Python 機能から見"
"ていきましょう: イテレータです。"

#: ../../howto/functional.rst:184
msgid ""
"An iterator is an object representing a stream of data; this object returns "
"the data one element at a time.  A Python iterator must support a method "
"called :meth:`~iterator.__next__` that takes no arguments and always returns "
"the next element of the stream.  If there are no more elements in the "
"stream, :meth:`~iterator.__next__` must raise the :exc:`StopIteration` "
"exception. Iterators don't have to be finite, though; it's perfectly "
"reasonable to write an iterator that produces an infinite stream of data."
msgstr ""
"イテレータは連続データを表現するオブジェクトです; このオブジェクトは一度に一"
"つの要素ずつデータを返します。 Python のイテレータは :meth:`~iterator."
"__next__` という、引数を取らず次の要素を返すメソッドを必ずサポートしていま"
"す。データストリームに要素が残っていない場合、 :meth:`~iterator.__next__` は"
"必ず :exc:`StopIteration` 例外を出します。ただし、イテレータの長さは有限であ"
"る必要はありません; 無限のストリームを生成するイテレータを書くというのもまっ"
"たく理に適ったことです。"

#: ../../howto/functional.rst:192
msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to "
"return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  Several "
"of Python's built-in data types support iteration, the most common being "
"lists and dictionaries.  An object is called :term:`iterable` if you can get "
"an iterator for it."
msgstr ""
"ビルトインの :func:`iter` 関数は任意のオブジェクトを受けて、 その中身や要素を"
"返すイテレータを返そうとします。引数のオブジェクトが イテレータを作れないとき"
"は :exc:`TypeError` を投げます。Python の ビルトインなデータ型にもいくつかイ"
"テレータ化のできるものがあり、 中でもよく使われるのはリストと辞書です。イテ"
"レータを作れる オブジェクトは :term:`iterable` オブジェクトと呼ばれます。"

#: ../../howto/functional.rst:199
msgid "You can experiment with the iteration interface manually:"
msgstr "手を動かしてイテレータ化の実験をしてみましょう:"

#: ../../howto/functional.rst:217
msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the :keyword:`for` statement.  In the statement ``for X in "
"Y``, Y must be an iterator or some object for which :func:`iter` can create "
"an iterator.  These two statements are equivalent::"
msgstr ""
"Python は色々な文脈でイテラブルなオブジェクトを期待しますが、 最も重要なの"
"は :keyword:`for` 文です。 ``for X in Y`` という文の Y は、 イテレータか、あ"
"るいは :func:`iter` でイテレータを作れるオブジェクトである必要があります。次"
"の二つは同じ意味になります::"

#: ../../howto/functional.rst:229
msgid ""
"Iterators can be materialized as lists or tuples by using the :func:`list` "
"or :func:`tuple` constructor functions:"
msgstr ""
"イテレータは :func:`list` や :func:`tuple` といったコンストラクタ関数を使って"
"リストやタプルに具現化することができます:"

#: ../../howto/functional.rst:238
msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr ""
"シーケンスのアンパックもイテレータに対応しています: イテレータが N 個の要素を"
"返すということが事前にわかっていれば、N-タプルにアンパックすることができます:"

#: ../../howto/functional.rst:247
msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The "
"``\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator.  "
"You'll run into obvious problems if the iterator is infinite; :func:`max`, :"
"func:`min` will never return, and if the element X never appears in the "
"stream, the ``\"in\"`` and ``\"not in\"`` operators won't return either."
msgstr ""
"ビルトイン関数の :func:`max` や :func:`min` なども、イテレータ一つだけを引数"
"に取って最大・最小の要素を返すことができます。 ``\"in\"`` や ``\"not in\"`` "
"演算子もイテレータに対応しています: ``X in iterator`` は、そのイテレータから"
"返るストリームに X があれば真です。ですからイテレータが無限長だと、当然ながら"
"問題に直面します; :func:`max`, :func:`min` はいつまでも戻って来ませんし、 要"
"素 X がストリームに出てこなければ ``\"in\"``, ``\"not in\"`` オペレータも戻り"
"ません。"

#: ../../howto/functional.rst:255
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it.  Iterator "
"objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the :meth:`~iterator.__next__` method.  "
"Functions may therefore consume all of the iterator's output, and if you "
"need to do something different with the same stream, you'll have to create a "
"new iterator."
msgstr ""
"イテレータは次に進むことしかできませんのでご注意ください; 前の要素を手に入れ"
"たり、イテレータをリセットしたり、コピーを作ったりする方法はありません。イテ"
"レータがオブジェクトとしてそうした追加機能を 持つことはできますが、プロトコル"
"では :meth:`~iterator.__next__` メソッドのことしか指定されていません。ですか"
"ら関数はイテレータの出力を使い尽くして しまうかもしれませんし、同じストリーム"
"に何か別のことをする 必要があるなら新しいイテレータを作らなくてはいけません。"

#: ../../howto/functional.rst:265
msgid "Data Types That Support Iterators"
msgstr "イテレータ対応のデータ型"

#: ../../howto/functional.rst:267
msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support creation "
"of an iterator."
msgstr ""
"リストやタプルがイテレータに対応している方法については既に見ましたが、実のと"
"ころ Python のシーケンス型はどれでも、たとえば文字列なども、自動でイテレータ"
"生成に対応しています。"

#: ../../howto/functional.rst:271
msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop over "
"the dictionary's keys::"
msgstr ""
"辞書に対して :func:`iter` すると、辞書のキーでループを回すイテレータが返され"
"ます::"

#: ../../howto/functional.rst:291
msgid ""
"Note that starting with Python 3.7, dictionary iteration order is guaranteed "
"to be the same as the insertion order. In earlier versions, the behaviour "
"was unspecified and could vary between implementations."
msgstr ""
"Python 3.7 から、辞書の反復順序は挿入順序と同じであることが保証されていること"
"に注意してください。\n"
"以前のバージョンでは、その振る舞いは仕様が定められておらず、実装ごとに異なる"
"ことがありました。"

#: ../../howto/functional.rst:295
msgid ""
"Applying :func:`iter` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over values or key/value pairs, you can explicitly call the :meth:"
"`~dict.values` or :meth:`~dict.items` methods to get an appropriate iterator."
msgstr ""
"辞書は :func:`iter` を適用するとキーでループを回しますが、辞書には他のイテ"
"レータを返すメソッドもあります。明示的に値、あるいはキーと値のペアでイテレー"
"トしたければ、:meth:`~dict.values`, :meth:`~dict.items` というメソッドでイテ"
"レータを作ることができます。"

#: ../../howto/functional.rst:301
msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite "
"stream of ``(key, value)`` tuples:"
msgstr ""
"逆に :func:`dict` コンストラクタは、有限な  ``(key, value)`` タプルのストリー"
"ムを返すイテレータを受け入れることができます:"

#: ../../howto/functional.rst:308
msgid ""
"Files also support iteration by calling the :meth:`~io.TextIOBase.readline` "
"method until there are no more lines in the file.  This means you can read "
"each line of a file like this::"
msgstr ""
"ファイルも、最後の行まで :meth:`~io.TextIOBase.readline` メソッドを呼んでいく"
"ことでイテレータ化に対応しています。つまりこうやってファイルの各行を読んでい"
"くことができるわけです::"

#: ../../howto/functional.rst:316
msgid ""
"Sets can take their contents from an iterable and let you iterate over the "
"set's elements::"
msgstr ""
"セットはイテラブルを受け取れますし、そのセットの要素でイテレートすることもで"
"きます::"

#: ../../howto/functional.rst:326
msgid "Generator expressions and list comprehensions"
msgstr "ジェネレータ式とリスト内包表記"

#: ../../howto/functional.rst:328
msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"イテレータの出力に対してよく使う操作トップ 2 は、(1) ひとつずつ全要素に操作を"
"実行する、および (2) 条件に合う要素でサブセットを作る、です。たとえば文字列の"
"リストなら、各行のうしろに付いた邪魔なホワイトスペースを削りたいとか、特定の"
"文字列を含む部分をピックアップしたいなどと思うかもしれません。"

#: ../../howto/functional.rst:334
msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" and "
"\"genexps\") are a concise notation for such operations, borrowed from the "
"functional programming language Haskell (https://www.haskell.org/).  You can "
"strip all the whitespace from a stream of strings with the following code::"
msgstr ""
"リスト内包表記とジェネレータ式 (略して「listcomp」と「genexp」) は、そうした"
"操作向けの簡潔な表記方法です。これは関数型プログラミング言語 Haskell "
"(https://www.haskell.org/) にインスパイアされました。文字列のストリームからホ"
"ワイトスペースをすべて削るのは次のコードでできます::"

#: ../../howto/functional.rst:347
msgid ""
"You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr "特定の要素だけを選び出すのは ``\"if\"`` 条件式を付けることで可能です::"

#: ../../howto/functional.rst:352
msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` is "
"a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not "
"needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return an "
"infinite stream or a very large amount of data.  Generator expressions are "
"preferable in these situations."
msgstr ""
"リスト内包表記を使うと Python リストが返って来ます; ``stripped_list`` は実行"
"結果の行が入ったリストであって、イテレータではありません。ジェネレータ式はイ"
"テレータを返し、これだと必要に応じてだけ値を算出しますので、すべての値を一度"
"に出す必要がありません。つまりリスト内包表記のほうは、無限長ストリームや膨大"
"なデータを返すようなイテレータを扱う際には、あまり役に立たないということで"
"す。そういった状況ではジェネレータ式のほうが好ましいと言えます。"

#: ../../howto/functional.rst:359
msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr ""
"ジェネレータ式は丸括弧 \"()\" で囲まれ、リスト内包表記は角括弧 \"[]\" で囲ま"
"れます。ジェネレータ式の形式は次のとおりです::"

#: ../../howto/functional.rst:372
msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr ""
"リスト内包表記も、外側の括弧が違うだけ (丸ではなく角括弧) で、あとは同じで"
"す。"

#: ../../howto/functional.rst:375
msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when ``condition`` "
"is true."
msgstr ""
"生成される出力は ``expression`` 部分の値を要素として並べたものになります。 "
"``if`` 節はすべて、なくても大丈夫です; あれば ``condition`` が真のときだけ "
"``expression`` が評価されて出力に追加されます。"

#: ../../howto/functional.rst:379
msgid ""
"Generator expressions always have to be written inside parentheses, but the "
"parentheses signalling a function call also count.  If you want to create an "
"iterator that will be immediately passed to a function you can write::"
msgstr ""
"ジェネレータ式は常に括弧の中に書かなければなりませんが、関数コールの目印に"
"なっている括弧でも大丈夫です。関数にすぐ渡すイテレータを作りたければこう書け"
"るのです::"

#: ../../howto/functional.rst:385
msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated over "
"from left to right, **not** in parallel.  For each element in ``sequence1``, "
"``sequence2`` is looped over from the beginning.  ``sequence3`` is then "
"looped over for each resulting pair of elements from ``sequence1`` and "
"``sequence2``."
msgstr ""
"``for...in`` 節は複数つなげられますが、どれにも、イテレートするためのシーケン"
"スが含まれています。それらのシーケンスは並行して **ではなく** 、左から右へ順"
"番にイテレートされるので、長さが同じである必要はありません。 ``sequence1`` の"
"各要素ごとに毎回最初から ``sequence2`` をループで回すのです。その後 "
"``sequence1`` と ``sequence2`` から出た要素ペアごとに、 ``sequence3`` でルー"
"プします。"

#: ../../howto/functional.rst:391
msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr ""
"別の書き方をすると、リスト内包表記やジェネレータ式は次の Python コードと同じ"
"意味になります::"

#: ../../howto/functional.rst:408
msgid ""
"This means that when there are multiple ``for...in`` clauses but no ``if`` "
"clauses, the length of the resulting output will be equal to the product of "
"the lengths of all the sequences.  If you have two lists of length 3, the "
"output list is 9 elements long:"
msgstr ""
"つまり、複数の ``for...in`` 節があって ``if`` がないときの最終出力は、長さが"
"各シーケンス長の積に等しくなるということです。長さ 3 のリスト二つなら、出力リ"
"ストの長さは 9 要素です:"

#: ../../howto/functional.rst:420
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if ``expression`` "
"is creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"Python の文法に曖昧さを紛れ込ませないように、 ``expression`` でタプルを作るな"
"ら括弧で囲わなくてはなりません。下にあるリスト内包表記で、最初のは構文エラー"
"ですが、二番目は有効です::"

#: ../../howto/functional.rst:431
msgid "Generators"
msgstr "ジェネレータ (generator)"

#: ../../howto/functional.rst:433
msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr ""
"ジェネレータは、イテレータを書く作業を簡単にする、特殊な関数です。標準的な関"
"数は値を計算して返しますが、ジェネレータが返すのは、一連の値を返すイテレータ"
"です。"

#: ../../howto/functional.rst:437
msgid ""
"You're doubtless familiar with how regular function calls work in Python or "
"C. When you call a function, it gets a private namespace where its local "
"variables are created.  When the function reaches a ``return`` statement, "
"the local variables are destroyed and the value is returned to the caller.  "
"A later call to the same function creates a new private namespace and a "
"fresh set of local variables. But, what if the local variables weren't "
"thrown away on exiting a function?  What if you could later resume the "
"function where it left off?  This is what generators provide; they can be "
"thought of as resumable functions."
msgstr ""
"Python や C の標準的な関数コールについては、よくご存じに違いありません。関数"
"を呼ぶと、ローカル変数を作るプライベートな名前空間ができますね。その関数が "
"``return`` 文まで来ると、ローカル変数が破壊されてから、返り値が呼び出し元に返"
"ります。次に同じ関数をもう一度呼ぶと、新しいプライベート名前空間に新規のロー"
"カル変数が作られるのです。しかし、関数を出るときにローカル変数を捨てなければ"
"どうなるでしょうか。その出ていったところから関数を続行できたとしたら、どうで"
"しょう。これこそジェネレータが提供する機能です; すなわち、ジェネレータは続行"
"できる関数と考えることができます。"

#: ../../howto/functional.rst:446
msgid "Here's the simplest example of a generator function:"
msgstr "ごく単純なジェネレータ関数の例がこちらにあります:"

#: ../../howto/functional.rst:452
msgid ""
"Any function containing a :keyword:`yield` keyword is a generator function; "
"this is detected by Python's :term:`bytecode` compiler which compiles the "
"function specially as a result."
msgstr ""
":keyword:`yield` キーワードを含む関数はすべてジェネレータ関数です; Python "
"の :term:`bytecode` コンパイラがこれを検出して、特別な方法でコンパイルしてく"
"れるのです。"

#: ../../howto/functional.rst:456
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the ``yield`` expression, the generator outputs the value of "
"``i``, similar to a ``return`` statement.  The big difference between "
"``yield`` and a ``return`` statement is that on reaching a ``yield`` the "
"generator's state of execution is suspended and local variables are "
"preserved.  On the next call to the generator's :meth:`~generator.__next__` "
"method, the function will resume executing."
msgstr ""
"ジェネレータ関数は、呼ばれたときに一回だけ値を返すのではなく、イテレータ プロ"
"トコルに対応したオブジェクトを返します。上の例で ``yield`` を実行したとき、 "
"ジェネレータは ``return`` 文のようにして ``i`` の値を出力します。 ``yield`` "
"と ``return`` 文の大きな違いは、 ``yield`` に到達した段階でジェネレータの実行"
"状態が一時停止になって、ローカル変数が保存される点です。 次回そのジェネレータ"
"の :meth:`~generator.__next__` を呼ぶと、そこから関数が実行を再開します。"

#: ../../howto/functional.rst:465
msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "上記 ``generate_ints()`` ジェネレータの使用例はこちらです:"

#: ../../howto/functional.rst:482
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a, b, c = "
"generate_ints(3)``."
msgstr ""
"同じく ``for i in generate_ints(5)`` や ``a, b, c = generate_ints(3)`` といっ"
"た書き方もできます。"

#: ../../howto/functional.rst:485
msgid ""
"Inside a generator function, ``return value`` causes "
"``StopIteration(value)`` to be raised from the :meth:`~generator.__next__` "
"method.  Once this happens, or the bottom of the function is reached, the "
"procession of values ends and the generator cannot yield any further values."
msgstr ""
"ジェネレータ関数の中では、``return value`` は :meth:`~generator.__next__` メ"
"ソッドから送出された ``StopIteration(value)`` を引き起こします。これが発生し"
"た場合や、関数の終わりに到達した場合は、値の生成が終了してジェネレーターがそ"
"れ以上の値を返さない。"

#: ../../howto/functional.rst:490
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`~iterator.__next__` "
"method increment ``self.count`` and return it. However, for a moderately "
"complicated generator, writing a corresponding class can be much messier."
msgstr ""
"自分でクラスを書いて、ジェネレータで言うところのローカル変数をインスタンス変"
"数として全部保管しておけば、同じ効果を得ることは可能です。たとえば整数のリス"
"トを返すのは、 ``self.count`` を 0 にして、 :meth:`~iterator.__next__` メソッ"
"ドが ``self.count`` をインクリメントして返すようにすればできます。しかしなが"
"ら、ある程度複雑なジェネレータになってくると、同じことをするクラスを書くのは"
"格段にややこしいことになります。"

#: ../../howto/functional.rst:498
msgid ""
"The test suite included with Python's library, :source:`Lib/test/"
"test_generators.py`, contains a number of more interesting examples.  Here's "
"one generator that implements an in-order traversal of a tree using "
"generators recursively. ::"
msgstr ""
"Python のライブラリに含まれているテストスイート :source:`Lib/test/"
"test_generators.py` には、ほかにも興味深い例が数多く入っています。これは二分"
"木の通りがけ順 (in-order) 探索を再帰で実装したジェネレータです。 ::"

#: ../../howto/functional.rst:514
msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the N-"
"Queens problem (placing N queens on an NxN chess board so that no queen "
"threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"ほかにも ``test_generators.py`` には、N-Queens 問題 (N×N コマのチェス盤に、互"
"いに攻撃できないような配置で N 個のクイーンを置く) やナイト・ツアー (N×N 盤の"
"全コマをナイトが一度ずつ通るような経路を探す) の解を出す例が入っています。"

#: ../../howto/functional.rst:522
msgid "Passing values into a generator"
msgstr "ジェネレータに値を渡す"

#: ../../howto/functional.rst:524
msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to pass "
"any new information into the function when its execution is resumed.  You "
"could hack together this ability by making the generator look at a global "
"variable or by passing in some mutable object that callers then modify, but "
"these approaches are messy."
msgstr ""
"Python 2.4 までのジェネレータは出力することしかできませんでした。ジェネレータ"
"のコードを実行してイテレータを作ってしまったあとで、その関数を再開するときに"
"新しい情報を渡す手段はなかったのです。ジェネレータがグローバル変数を見るよう"
"にしたり、ミュータブルなオブジェクトを渡しておいて呼び出し元であとからそれを"
"変更したり、といったハックは可能でしたが、どれもゴチャゴチャしていますね。"

#: ../../howto/functional.rst:531
msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. :keyword:"
"`yield` became an expression, returning a value that can be assigned to a "
"variable or otherwise operated on::"
msgstr ""
"Python 2.5 で、ジェネレータに値を渡す簡単な手段ができました。 :keyword:"
"`yield` が、変数に代入したり演算したりできる値を返す式になったのです::"

#: ../../howto/functional.rst:537
msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"上のように、返り値で何かをするときは ``yield`` 式の前後に **必ず** 括弧を付け"
"るようお勧めします。括弧は常に必要なわけではありませんが、どんなとき付けなく"
"て良いのかを覚えておくより、いつも付けておくほうが楽ですから。"

#: ../../howto/functional.rst:542
msgid ""
"(:pep:`342` explains the exact rules, which are that a ``yield``-expression "
"must always be parenthesized except when it occurs at the top-level "
"expression on the right-hand side of an assignment.  This means you can "
"write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` がその規則を正確に説明していますが、それによると ``yield``-式は、"
"代入式で右辺のトップレベルにあるとき以外はいつも括弧を付ける必要があります。"
"つまり ``val = yield i`` とは書けますが、 ``val = (yield i) + 12`` のように演"
"算子があるときは括弧を使わなくてはいけません。)"

#: ../../howto/functional.rst:548
msgid ""
"Values are sent into a generator by calling its :meth:`send(value) "
"<generator.send>` method.  This method resumes the generator's code and the "
"``yield`` expression returns the specified value.  If the regular :meth:"
"`~generator.__next__` method is called, the ``yield`` returns ``None``."
msgstr ""
"ジェネレータに値を送るには :meth:`send(value) <generator.send>` メソッドを呼"
"びます。 するとジェネレータのコードが実行を再開し、 ``yield`` 式がその値を返"
"すのです。ふつうの :meth:`~generator.__next__` メソッドを呼ぶと、 ``yield`` "
"は ``None`` を返します。"

#: ../../howto/functional.rst:553
msgid ""
"Here's a simple counter that increments by 1 and allows changing the value "
"of the internal counter."
msgstr ""
"下にあるのは 1 ずつ増える単純なカウンタですが、内部カウンタの値を変更すること"
"ができるようになっています。"

#: ../../howto/functional.rst:568
msgid "And here's an example of changing the counter:"
msgstr "そしてカウンタ変更の例がこちらです:"

#: ../../howto/functional.rst:585
msgid ""
"Because ``yield`` will often be returning ``None``, you should always check "
"for this case.  Don't just use its value in expressions unless you're sure "
"that the :meth:`~generator.send` method will be the only method used to "
"resume your generator function."
msgstr ""
"``yield`` が ``None`` を返すことはよくあるのですから、そうなっていないかどう"
"か必ずチェックしておくべきです。ジェネレータ関数を再開するために使うメソッド"
"が :meth:`~generator.send` しかないのだと確定してるのでない限り、式の値をその"
"まま使ってはいけません。"

#: ../../howto/functional.rst:590
msgid ""
"In addition to :meth:`~generator.send`, there are two other methods on "
"generators:"
msgstr ""
"ジェネレータには、 :meth:`~generator.send` のほかにもメソッドが二つあります:"

#: ../../howto/functional.rst:593
msgid ""
":meth:`throw(type, value=None, traceback=None) <generator.throw>` is used to "
"raise an exception inside the generator; the exception is raised by the "
"``yield`` expression where the generator's execution is paused."
msgstr ""
":meth:`throw(type, value=None, traceback=None) <generator.throw>` はジェネ"
"レータ内で例外を投げるために使います; その例外はジェネレータの実行が停止した"
"ところの ``yield`` 式によって投げられます。"

#: ../../howto/functional.rst:597
msgid ""
":meth:`~generator.close` raises a :exc:`GeneratorExit` exception inside the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or :exc:"
"`StopIteration`; catching the exception and doing anything else is illegal "
"and will trigger a :exc:`RuntimeError`.  :meth:`~generator.close` will also "
"be called by Python's garbage collector when the generator is garbage-"
"collected."
msgstr ""
":meth:`~generator.close` はジェネレータ内で :exc:`GeneratorExit` 例外を投げ"
"て、 イテレートを終了させます。この例外を受け取ったジェネレータのコードは :"
"exc:`GeneratorExit` か :exc:`StopIteration` を投げなくてはいけません; この例"
"外を捕捉して何かほかのことをしようとするのは規則違反であり、 :exc:"
"`RuntimeError` を引き起こします。 :meth:`~generator.close` はジェネレータが "
"GC されるときにも呼ばれます。"

#: ../../howto/functional.rst:605
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching :exc:"
"`GeneratorExit`."
msgstr ""
":exc:`GeneratorExit` が起こったときにクリーンアップ作業をする必要があるな"
"ら、 :exc:`GeneratorExit` を捕捉するのではなく ``try: ... finaly:`` するよう"
"お勧めします。"

#: ../../howto/functional.rst:608
msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr ""
"これらの変更の合わせ技で、ジェネレータは情報の一方的な生産者から、生産者かつ"
"消費者という存在に変貌を遂げたのです。"

#: ../../howto/functional.rst:611
msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but coroutines "
"can be entered, exited, and resumed at many different points (the ``yield`` "
"statements)."
msgstr ""
"ジェネレータは **コルーチン** という、より一般化された形式のサブルーチンにも"
"なります。サブルーチンは一カ所 (関数の冒頭) から入って別の一カ所 (``return`` "
"文) から出るだけですが、コルーチンはいろいろな場所 (``yield`` 文) から入った"
"り出たり再開したりできるのです。"

#: ../../howto/functional.rst:618
msgid "Built-in functions"
msgstr "組み込み関数 (built-in function)"

#: ../../howto/functional.rst:620
msgid ""
"Let's look in more detail at built-in functions often used with iterators."
msgstr ""
"よくイテレータと一緒に使うビルトイン関数について、もっと詳しく見ていきましょ"
"う。"

#: ../../howto/functional.rst:622
msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter` duplicate "
"the features of generator expressions:"
msgstr ""
"Python のビルトイン関数 :func:`map` と :func:`filter` は、機能がジェネレータ"
"式と重複しています:"

#: ../../howto/functional.rst:634
msgid ""
":func:`map(f, iterA, iterB, ...) <map>` returns an iterator over the sequence"
msgstr ""
":func:`map(f, iterA, iterB, ...) <map>` は以下のシーケンスのイテレータを返し"
"ます"

#: ../../howto/functional.rst:626
msgid ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."
msgstr ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."

#: ../../howto/functional.rst:636
msgid "You can of course achieve the same effect with a list comprehension."
msgstr "もちろん、リスト内包表記でも同じ結果が得られます。"

#: ../../howto/functional.rst:638
msgid ""
":func:`filter(predicate, iter) <filter>` returns an iterator over all the "
"sequence elements that meet a certain condition, and is similarly duplicated "
"by list comprehensions.  A **predicate** is a function that returns the "
"truth value of some condition; for use with :func:`filter`, the predicate "
"must take a single value."
msgstr ""
":func:`filter(predicate, iter) <filter>` はある条件を満たす要素に渡るイテレー"
"タを返すので、同様にリスト内包表記で再現できます。\n"
"**predicate** は、ある条件に対する真偽値を返す関数です;\n"
":func:`filter` で使うには、その関数の引数は一つでなければなりません。"

#: ../../howto/functional.rst:651
msgid "This can also be written as a list comprehension:"
msgstr "これはリスト内包表記でも書けます:"

#: ../../howto/functional.rst:657
msgid ""
":func:`enumerate(iter, start=0) <enumerate>` counts off the elements in the "
"iterable returning 2-tuples containing the count (from *start*) and each "
"element. ::"
msgstr ""
":func:`enumerate(iter, start=0) <enumerate>` はイテラブルの要素に順番に番号を"
"振っていき、(*start* から数え始めたときの) 番号とそれぞれの要素を含む 2 タプ"
"ルを返します。"

#: ../../howto/functional.rst:667
msgid ""
":func:`enumerate` is often used when looping through a list and recording "
"the indexes at which certain conditions are met::"
msgstr ""
":func:`enumerate` はよく、リストに対してループさせて、条件に合う所に印を付け"
"ていくときに使われます::"

#: ../../howto/functional.rst:675
msgid ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` collects all the "
"elements of the iterable into a list, sorts the list, and returns the sorted "
"result.  The *key* and *reverse* arguments are passed through to the "
"constructed list's :meth:`~list.sort` method. ::"
msgstr ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` はイテラブルの要素"
"をすべて集めたリストを作り、ソートして返します。 引数 *key* および *reverse* "
"は、リストの :meth:`~list.sort` メソッドにそのまま渡されます。 ::"

#: ../../howto/functional.rst:690
msgid ""
"(For a more detailed discussion of sorting, see the :ref:`sortinghowto`.)"
msgstr "(ソートに関する詳細な論議は :ref:`sortinghowto` を参照)"

#: ../../howto/functional.rst:693
msgid ""
"The :func:`any(iter) <any>` and :func:`all(iter) <all>` built-ins look at "
"the truth values of an iterable's contents.  :func:`any` returns ``True`` if "
"any element in the iterable is a true value, and :func:`all` returns "
"``True`` if all of the elements are true values:"
msgstr ""
"組み込みの :func:`any(iter) <any>` および :func:`all(iter) <all>` は "
"iterable の値の真偽を調べます。 :func:`any` は要素のどれかが真値なら "
"``True`` を返し、 :func:`all` は要素が全て真値なら ``True`` を返します:"

#: ../../howto/functional.rst:712
msgid ""
":func:`zip(iterA, iterB, ...) <zip>` takes one element from each iterable "
"and returns them in a tuple::"
msgstr ""
":func:`zip(iterA, iterB, ...) <zip>` はそれぞれの iterable から1つの要素を取"
"り、それらをタプルに入れて返します::"

#: ../../howto/functional.rst:718
msgid ""
"It doesn't construct an in-memory list and exhaust all the input iterators "
"before returning; instead tuples are constructed and returned only if "
"they're requested.  (The technical term for this behaviour is `lazy "
"evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"
msgstr ""
":func:`zip` は結果を返す前に入力のイテレーターを全て消費してメモリ上に list "
"を作成しません。代わりに要求されるたびに tuple を生成して返します。(この動作"
"を技術的な用語で `lazy evaluation <https://en.wikipedia.org/wiki/"
"Lazy_evaluation>`__ (訳: `遅延評価 <https://ja.wikipedia.org/wiki/"
"%E9%81%85%E5%BB%B6%E8%A9%95%E4%BE%A1>`__) と呼びます。)"

#: ../../howto/functional.rst:723
msgid ""
"This iterator is intended to be used with iterables that are all of the same "
"length.  If the iterables are of different lengths, the resulting stream "
"will be the same length as the shortest iterable. ::"
msgstr ""
"このイテレータの用途には、すべて同じ長さのイテラブルを想定しています。長さが"
"違っていれば、出力されるストリームは一番短いイテラブルと同じ長さになりま"
"す。 ::"

#: ../../howto/functional.rst:730
msgid ""
"You should avoid doing this, though, because an element may be taken from "
"the longer iterators and discarded.  This means you can't go on to use the "
"iterators further because you risk skipping a discarded element."
msgstr ""
"とは言え、これをやってしまうと長いイテレータから要素をひとつ無駄に多く取って"
"捨ててしまうかもしれませんので、やめておいたほうが良いです。その捨てられた要"
"素を抜かしてしまう危険があるので、もうそのイテレータはそれ以上使えなくなって"
"しまいます。"

#: ../../howto/functional.rst:736
msgid "The itertools module"
msgstr "itertools モジュール"

#: ../../howto/functional.rst:738
msgid ""
"The :mod:`itertools` module contains a number of commonly-used iterators as "
"well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ""
":mod:`itertools` モジュールには、よく使うイテレータや、イテレータ同士の連結に"
"使う関数がたくさん含まれています。この章では、そのモジュールの内容を小さな例"
"で紹介していきたいと思います。"

#: ../../howto/functional.rst:742
msgid "The module's functions fall into a few broad classes:"
msgstr "このモジュールの関数を大まかに分けるとこうなります:"

#: ../../howto/functional.rst:744
msgid "Functions that create a new iterator based on an existing iterator."
msgstr "既存のイテレータに基づいて新しいイテレータを作る関数。"

#: ../../howto/functional.rst:745
msgid "Functions for treating an iterator's elements as function arguments."
msgstr "イテレータの要素を引数として扱う関数。"

#: ../../howto/functional.rst:746
msgid "Functions for selecting portions of an iterator's output."
msgstr "イテレータの出力から一部を取り出す関数。"

#: ../../howto/functional.rst:747
msgid "A function for grouping an iterator's output."
msgstr "イテレータの出力をグループ分けする関数。"

#: ../../howto/functional.rst:750
msgid "Creating new iterators"
msgstr "新しいイテレータを作る"

#: ../../howto/functional.rst:752
msgid ""
":func:`itertools.count(start, step) <itertools.count>` returns an infinite "
"stream of evenly spaced values.  You can optionally supply the starting "
"number, which defaults to 0, and the interval between numbers, which "
"defaults to 1::"
msgstr ""
":func:`itertools.count(start, step) <itertools.count>` は値の間隔が一定の無限"
"ストリームを返します。\n"
"オプションで開始する数 (デフォルトは 0) や数どうしの間隔 (デフォルトは 1) を"
"与えられます::"

#: ../../howto/functional.rst:763
msgid ""
":func:`itertools.cycle(iter) <itertools.cycle>` saves a copy of the contents "
"of a provided iterable and returns a new iterator that returns its elements "
"from first to last.  The new iterator will repeat these elements "
"infinitely. ::"
msgstr ""
":func:`itertools.cycle(iter) <itertools.cycle>` は与えられたイテラブルの内容"
"をコピーして、 その要素を最初から最後まで無限に繰り返していくイテレータを返し"
"ます。 ::"

#: ../../howto/functional.rst:770
msgid ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returns the provided "
"element *n* times, or returns the element endlessly if *n* is not "
"provided. ::"
msgstr ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` は、与えられた要素を "
"*n* 回返しますが、 *n* がなければ永遠に返し続けます。 ::"

#: ../../howto/functional.rst:778
msgid ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` takes an "
"arbitrary number of iterables as input, and returns all the elements of the "
"first iterator, then all the elements of the second, and so on, until all of "
"the iterables have been exhausted. ::"
msgstr ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` は任意の数のイテ"
"ラブルを受け取って、最初のイテレータから要素をすべて返し、次に二番目から 要素"
"をすべて返し、ということを要素がなくなるまで続けます。 ::"

#: ../../howto/functional.rst:786
msgid ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returns a stream that's a slice of the iterator.  With a single *stop* "
"argument, it will return the first *stop* elements.  If you supply a "
"starting index, you'll get *stop-start* elements, and if you supply a value "
"for *step*, elements will be skipped accordingly.  Unlike Python's string "
"and list slicing, you can't use negative values for *start*, *stop*, or "
"*step*. ::"
msgstr ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` は、"
"イテレータの スライスをストリームで返します。 *stop* 引数だけだと、最初の "
"*stop* 個の要素を返します。開始インデックスを渡すと *stop-start* 個で、 "
"*step* の値も渡せばそれに応じて要素を抜かします。Python における文字列やリス"
"トのスライスとは違って、マイナスの値は *start*, *stop*, *step* に使えませ"
"ん。 ::"

#: ../../howto/functional.rst:800
msgid ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replicates an iterator; it "
"returns *n* independent iterators that will all return the contents of the "
"source iterator. If you don't supply a value for *n*, the default is 2.  "
"Replicating iterators requires saving some of the contents of the source "
"iterator, so this can consume significant memory if the iterator is large "
"and one of the new iterators is consumed more than the others. ::"
msgstr ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` はイテレータを複製します; 元"
"のイテレータの内容を同じように返す、独立した *n* 個のイテレータを返すので"
"す。 *n* の値は、指定しなければ既定が 2 になっています。複製するには元のイテ"
"レータの内容を一部保存しておく必要がありますから、大きなイテレータから複製し"
"たうちの一つが他よりも進んでいってしまうと、大量のメモリを消費することがあり"
"ます。 ::"

#: ../../howto/functional.rst:819
msgid "Calling functions on elements"
msgstr "要素に対して関数を呼ぶ"

#: ../../howto/functional.rst:821
msgid ""
"The :mod:`operator` module contains a set of functions corresponding to "
"Python's operators.  Some examples are :func:`operator.add(a, b) <operator."
"add>` (adds two values), :func:`operator.ne(a, b)  <operator.ne>` (same as "
"``a != b``), and :func:`operator.attrgetter('id') <operator.attrgetter>` "
"(returns a callable that fetches the ``.id`` attribute)."
msgstr ""
"いま使った :mod:`operator` モジュールには、Python の演算子に対応する関数が"
"入っています。いくつか例を挙げると、 :func:`operator.add(a, b) <operator."
"add>` (二つの値を加算)、 :func:`operator.ne(a, b) <operator.ne>` (``a != b`` "
"と同じ)、 :func:`operator.attrgetter('id') <operator.attrgetter>` (``.id`` 属"
"性を取得するコーラブルを返す) といった関数です。"

#: ../../howto/functional.rst:827
msgid ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assumes that the "
"iterable will return a stream of tuples, and calls *func* using these tuples "
"as the arguments::"
msgstr ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` は、イテラブルがタ"
"プルのストリームを返すとみなして、 そのタプルを引数に使って *func* を呼びま"
"す::"

#: ../../howto/functional.rst:839
msgid "Selecting elements"
msgstr "要素を選択する"

#: ../../howto/functional.rst:841
msgid ""
"Another group of functions chooses a subset of an iterator's elements based "
"on a predicate."
msgstr ""
"さらに別のグループとして、述語 (predicate) に基づいてイテレータの要素からサブ"
"セットを選び出す関数があります。"

#: ../../howto/functional.rst:844
msgid ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` is "
"the opposite of :func:`filter`, returning all elements for which the "
"predicate returns false::"
msgstr ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` は :"
"func:`filter` とは反対に、 述語が偽を返す要素をすべて返します::"

#: ../../howto/functional.rst:851
msgid ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` returns "
"elements for as long as the predicate returns true.  Once the predicate "
"returns false, the iterator will signal the end of its results. ::"
msgstr ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` は述語が真"
"を返している間だけ要素を返します。一度でも述語が偽を返すと、イテレータは出力"
"終了の合図をします。 ::"

#: ../../howto/functional.rst:864
msgid ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` discards "
"elements while the predicate returns true, and then returns the rest of the "
"iterable's results. ::"
msgstr ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` は、述語が"
"真を返しているうちは要素を無視し、偽になってから残りの出力をすべて返しま"
"す。 ::"

#: ../../howto/functional.rst:874
msgid ""
":func:`itertools.compress(data, selectors) <itertools.compress>` takes two "
"iterators and returns only those elements of *data* for which the "
"corresponding element of *selectors* is true, stopping whenever either one "
"is exhausted::"
msgstr ""
":func:`itertools.compress(data, selectors) <itertools.compress>` は 2つのイテ"
"レータを取り、 どちらかのイテレータを使い果たすまでの、 *selectors* が真とな"
"る要素に対応する *data* 要素だけを返します::"

#: ../../howto/functional.rst:883
msgid "Combinatoric functions"
msgstr "組合せ関数"

#: ../../howto/functional.rst:885
msgid ""
"The :func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returns an iterator giving all possible *r*-tuple combinations of the "
"elements contained in *iterable*.  ::"
msgstr ""
":func:`itertools.combinations(iterable, r) <itertools.combinations>` は、 "
"*iterable* から *r*-tuple 選択する全ての組み合わせを提供するイテレータを返し"
"ます ::"

#: ../../howto/functional.rst:900
msgid ""
"The elements within each tuple remain in the same order as *iterable* "
"returned them.  For example, the number 1 is always before 2, 3, 4, or 5 in "
"the examples above.  A similar function, :func:`itertools."
"permutations(iterable, r=None) <itertools.permutations>`, removes this "
"constraint on the order, returning all possible arrangements of length *r*::"
msgstr ""
"それぞれのタプル内では、要素は *iterable* がそれを返したのと同じ順序を保ちま"
"す。例えば上の例であれば、 1 はいつでも 2, 3, 4, 5 の前に来ます。似たような関"
"数に :func:`itertools.permutations(iterable, r=None) <itertools."
"permutations>` があり、こちらはこの順序についての制約がなく、 *r* 個選択する"
"全ての順列を返します。"

#: ../../howto/functional.rst:919
msgid ""
"If you don't supply a value for *r* the length of the iterable is used, "
"meaning that all the elements are permuted."
msgstr ""
"*r* を与えない場合は iterable の長さが使われます。つまり iterable の全ての要"
"素を選んだ順列を返します。"

#: ../../howto/functional.rst:922
msgid ""
"Note that these functions produce all of the possible combinations by "
"position and don't require that the contents of *iterable* are unique::"
msgstr ""
"これらの関数が生成する組み合わせは、位置が基準ですので、 *iterable* の内容が"
"一意でなくとも良いことに注目してください::"

#: ../../howto/functional.rst:929
msgid ""
"The identical tuple ``('a', 'a', 'b')`` occurs twice, but the two 'a' "
"strings came from different positions."
msgstr ""
"全く同じタプル ``('a', 'a', 'b')`` が 2度現れていますが、これは 2つの 'a' が"
"別の位置からのものだからです。"

#: ../../howto/functional.rst:932
msgid ""
"The :func:`itertools.combinations_with_replacement(iterable, r) <itertools."
"combinations_with_replacement>` function relaxes a different constraint: "
"elements can be repeated within a single tuple.  Conceptually an element is "
"selected for the first position of each tuple and then is replaced before "
"the second element is selected.  ::"
msgstr ""
":func:`itertools.combinations_with_replacement(iterable, r) <itertools."
"combinations_with_replacement>` 関数は別の制約を取り払います: 一回の選択で同"
"じ要素を繰り返し選んでも良い。概念的には、それぞれのタプルの最初のものとして"
"一つ要素が選ばれ、続いて 2つ目の選択のかわりにそれで置き換わります ::"

#: ../../howto/functional.rst:947
msgid "Grouping elements"
msgstr "要素をグループ分けする"

#: ../../howto/functional.rst:949
msgid ""
"The last function I'll discuss, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, is the most complicated.  "
"``key_func(elem)`` is a function that can compute a key value for each "
"element returned by the iterable.  If you don't supply a key function, the "
"key is simply each element itself."
msgstr ""
"最後に議題に上げる関数 :func:`itertools.groupby(iter, key_func=None) "
"<itertools.groupby>` は、 これまでで最も複雑です。 ``key_func(elem)`` は、イ"
"テラブルから返ってきた要素それぞれのキー値を計算する関数です。この関数が指定"
"されていなければ、 キーは単に各要素そのものになります。"

#: ../../howto/functional.rst:954
msgid ""
":func:`~itertools.groupby` collects all the consecutive elements from the "
"underlying iterable that have the same key value, and returns a stream of 2-"
"tuples containing a key value and an iterator for the elements with that key."
msgstr ""
":func:`~itertools.groupby` は、元になるイテラブルから同じキー値を持つ連続する"
"要素を集めて、キー値とそのキーに対応する要素のイテレータの 2-タプルのストリー"
"ムを返します。"

#: ../../howto/functional.rst:982
msgid ""
":func:`~itertools.groupby` assumes that the underlying iterable's contents "
"will already be sorted based on the key.  Note that the returned iterators "
"also use the underlying iterable, so you have to consume the results of "
"iterator-1 before requesting iterator-2 and its corresponding key."
msgstr ""
":func:`~itertools.groupby` は、元になるイテラブルの内容がキー値でソートされた"
"状態で与えられることを想定しています。ここで、返されるイテレータ自体も元のイ"
"テラブルを使うということに注意してください。そのため、 iterator-1 の結果を読"
"み終わるまでは iterator-2 とそれに対応するキー値を要求することはできません。"

#: ../../howto/functional.rst:989
msgid "The functools module"
msgstr "functools モジュール"

#: ../../howto/functional.rst:991
msgid ""
"The :mod:`functools` module in Python 2.5 contains some higher-order "
"functions. A **higher-order function** takes one or more functions as input "
"and returns a new function.  The most useful tool in this module is the :"
"func:`functools.partial` function."
msgstr ""
"Python 2.5 からの :mod:`functools` モジュールには、高階関数がいくつか入ってい"
"ます。 **高階関数** とは、入力として関数を受け取って新たな関数を返す関数で"
"す。このモジュールで一番便利なツールは :func:`functools.partial` 関数です。"

#: ../../howto/functional.rst:996
msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters "
"filled in. Consider a Python function ``f(a, b, c)``; you may wish to create "
"a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; you're "
"filling in a value for one of ``f()``'s parameters.  This is called "
"\"partial function application\"."
msgstr ""
"関数型スタイルのプログラムでは時折、既存の関数から一部のパラメータを埋めた変"
"種を作りたくなることがあります。Python の関数 ``f(a, b, c)`` というものがある"
"としてください; ``f(1, b, c)`` と同じ意味の ``g(b, c)`` という関数を作りたく"
"なることがあります; つまり ``f()`` のパラメータを一つ埋めるわけです。これは"
"「関数の部分適用」と呼ばれています。"

#: ../../howto/functional.rst:1002
msgid ""
"The constructor for :func:`~functools.partial` takes the arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  The "
"resulting object is callable, so you can just call it to invoke ``function`` "
"with the filled-in arguments."
msgstr ""
":func:`~functools.partial` のコンストラクタは ``(function, arg1, arg2, ..., "
"kwarg1=value1, kwarg2=value2)`` という引数を取ります。できあがったオブジェク"
"トはコーラブルなので、それを呼べば、引数の埋まった状態で ``function`` を実行"
"したのと同じことになります。"

#: ../../howto/functional.rst:1007
msgid "Here's a small but realistic example::"
msgstr "以下にあるのは、小さいけれども現実的な一つの例です::"

#: ../../howto/functional.rst:1019
msgid ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"cumulatively performs an operation on all the iterable's elements and, "
"therefore, can't be applied to infinite iterables. *func* must be a function "
"that takes two elements and returns a single value.  :func:`functools."
"reduce` takes the first two elements A and B returned by the iterator and "
"calculates ``func(A, B)``.  It then requests the third element, C, "
"calculates ``func(func(A, B), C)``, combines this result with the fourth "
"element returned, and continues until the iterable is exhausted.  If the "
"iterable returns no values at all, a :exc:`TypeError` exception is raised.  "
"If the initial value is supplied, it's used as a starting point and "
"``func(initial_value, A)`` is the first calculation. ::"
msgstr ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` はイ"
"テラブルの要素に対して次々に演算を実行していった最終結果を出すもので、それゆ"
"え無限長イテラブルには適用できません。 *func* には、要素を二つ取って値を一つ"
"返す関数が入ります。 :func:`functools.reduce` はイテレータが返す最初の二要素 "
"A と B を取って ``func(A, B)`` を計算します。それから三番目の要素 C を要求し"
"て ``func(func(A, B), C)`` を計算すると、その結果をさらに四番目の要素と組み合"
"わせて……ということをイテラブルが尽きるまで続けるのです。 もしイテラブルが一つ"
"も値を返さなければ :exc:`TypeError` が発生します。 初期値 ``initial_value`` "
"があるときには、最初の計算で ``func(initial_value, A)`` が実行されます。 ::"

#: ../../howto/functional.rst:1043
msgid ""
"If you use :func:`operator.add` with :func:`functools.reduce`, you'll add up "
"all the elements of the iterable.  This case is so common that there's a "
"special built-in called :func:`sum` to compute it:"
msgstr ""
":func:`operator.add` を :func:`functools.reduce` で使うと、 iterable の全要素"
"を合計することになります。これは使用頻度が高いので、そのための :func:`sum` と"
"いうビルトイン関数があります:"

#: ../../howto/functional.rst:1055
msgid ""
"For many uses of :func:`functools.reduce`, though, it can be clearer to just "
"write the obvious :keyword:`for` loop::"
msgstr ""
"とはいえ、多くの場合 :func:`functools.reduce` を使うよりは、単に :keyword:"
"`for` ループを書いたほうがわかりやすくなります::"

#: ../../howto/functional.rst:1067
msgid ""
"A related function is :func:`itertools.accumulate(iterable, func=operator."
"add) <itertools.accumulate>`.  It performs the same calculation, but instead "
"of returning only the final result, :func:`accumulate` returns an iterator "
"that also yields each partial result::"
msgstr ""
"関連する関数は :func:`itertools.accumulate(iterable, func=operator.add) "
"<itertools.accumulate>` です。この関数は同じ計算をしますが、最終結果を返すの"
"ではなく、 :func:`accumulate` はそれぞれの中間結果を返すイテレータが返り値と"
"なります。"

#: ../../howto/functional.rst:1080
msgid "The operator module"
msgstr "operator モジュール"

#: ../../howto/functional.rst:1082
msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often "
"useful in functional-style code because they save you from writing trivial "
"functions that perform a single operation."
msgstr ""
":mod:`operator` モジュールは、既に取り上げましたが、Python の演算子に対応する"
"関数が入っているモジュールです。関数型スタイルのコードにおいて、演算を一つ実"
"行するだけのくだらない関数を書かずに済むので、よく世話になります。"

#: ../../howto/functional.rst:1087
msgid "Some of the functions in this module are:"
msgstr "このモジュールの関数を一部だけ紹介しましょう:"

#: ../../howto/functional.rst:1089
msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."
msgstr ""
"数学演算子: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, ``abs()``, ..."

#: ../../howto/functional.rst:1090
msgid "Logical operations: ``not_()``, ``truth()``."
msgstr "論理演算子: ``not_()``, ``truth()``"

#: ../../howto/functional.rst:1091
msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr "ビット演算子: ``and_()``, ``or_()``, ``invert()``"

#: ../../howto/functional.rst:1092
msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and ``ge()``."
msgstr "比較: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, ``ge()``"

#: ../../howto/functional.rst:1093
msgid "Object identity: ``is_()``, ``is_not()``."
msgstr "オブジェクト識別: ``is_()``, ``is_not()``"

#: ../../howto/functional.rst:1095
msgid "Consult the operator module's documentation for a complete list."
msgstr "ちゃんとした一覧は operator モジュールの文書でご覧ください。"

#: ../../howto/functional.rst:1099
msgid "Small functions and the lambda expression"
msgstr "小さな関数とラムダ式"

#: ../../howto/functional.rst:1101
msgid ""
"When writing functional-style programs, you'll often need little functions "
"that act as predicates or that combine elements in some way."
msgstr ""
"関数型スタイルのプログラムを書いていると、述語として働いたり、何らかの形で要"
"素をつなぎ合わせたりするミニサイズの関数を必要とすることがよくあります。"

#: ../../howto/functional.rst:1104
msgid ""
"If there's a Python built-in or a module function that's suitable, you don't "
"need to define a new function at all::"
msgstr ""
"ちょうど良い関数がビルトインやモジュールで存在していれば、新しい関数を定義す"
"る必要はまったくありません::"

#: ../../howto/functional.rst:1110
msgid ""
"If the function you need doesn't exist, you need to write it.  One way to "
"write small functions is to use the :keyword:`lambda` expression.  "
"``lambda`` takes a number of parameters and an expression combining these "
"parameters, and creates an anonymous function that returns the value of the "
"expression::"
msgstr ""
"しかし、欲しい関数がないなら書くしかありません。そうした小さな関数を書く方法"
"の 一つが :keyword:`lambda` 式です。 ``lambda`` は引数として複数のパラメータ"
"と それをつなぐ式を取り、その式の値を返す無名の関数を作ります::"

#: ../../howto/functional.rst:1119
msgid ""
"An alternative is to just use the ``def`` statement and define a function in "
"the usual way::"
msgstr "もう一つの選択肢は、ふつうに ``def`` 文で関数を定義するだけです::"

#: ../../howto/functional.rst:1128
msgid ""
"Which alternative is preferable?  That's a style question; my usual course "
"is to avoid using ``lambda``."
msgstr ""
"どちらのほうが良いのでしょうか。それは好みの問題です; 著者のスタイルとしては"
"できるだけ ``lambda`` を使わないようにしています。"

#: ../../howto/functional.rst:1131
msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much in a "
"``lambda`` statement, you'll end up with an overly complicated expression "
"that's hard to read.  Quick, what's the following code doing? ::"
msgstr ""
"そのようにしている理由の一つに、``lambda`` は定義できる関数が非常に限られてい"
"るという点があります。一つの式として算出できる結果にしなければいけませんの"
"で、``if... elif... else`` や ``try... except`` のような分岐を持つことができ"
"ないのです。``lambda`` 文の中でたくさんのことをやろうとしすぎると、ごちゃご"
"ちゃして読みにくい式になってしまいます。さて、次のコードは何をしているでしょ"
"うか、素早くお答えください! ::"

#: ../../howto/functional.rst:1141
msgid ""
"You can figure it out, but it takes time to disentangle the expression to "
"figure out what's going on.  Using a short nested ``def`` statements makes "
"things a little bit better::"
msgstr ""
"わかるにはわかるでしょうが、何がどうなっているのか紐解いていくには時間がかか"
"るはずです。短い ``def`` 文で入れ子にすると、少し見通しが良くなりますが::"

#: ../../howto/functional.rst:1151
msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr "でも単純に ``for`` ループにすれば良かったのです::"

#: ../../howto/functional.rst:1157
msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr "あるいは :func:`sum` ビルトインとジェネレータ式でも良いですね::"

#: ../../howto/functional.rst:1161
msgid ""
"Many uses of :func:`functools.reduce` are clearer when written as ``for`` "
"loops."
msgstr ""
"多くの場合、 :func:`functools.reduce` を使っているところは ``for`` ループに "
"書き直したほうが見やすいです。"

#: ../../howto/functional.rst:1163
msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring uses "
"of ``lambda``:"
msgstr ""
"Fredrik Lundh は以前 ``lambda`` 利用のリファクタリングに関して以下の指針を提"
"案したことがあります:"

#: ../../howto/functional.rst:1166
msgid "Write a lambda function."
msgstr "ラムダ関数を書く。"

#: ../../howto/functional.rst:1167
msgid "Write a comment explaining what the heck that lambda does."
msgstr "そのラムダが一体ぜんたい何をしているのかコメントで説明する。"

#: ../../howto/functional.rst:1168
msgid ""
"Study the comment for a while, and think of a name that captures the essence "
"of the comment."
msgstr "そのコメントをしばらく研究して、本質をとらえた名前を考える。"

#: ../../howto/functional.rst:1170
msgid "Convert the lambda to a def statement, using that name."
msgstr "ラムダをその名前で def 文に書き換える。"

#: ../../howto/functional.rst:1171
msgid "Remove the comment."
msgstr "コメントを消す。"

#: ../../howto/functional.rst:1173
msgid ""
"I really like these rules, but you're free to disagree about whether this "
"lambda-free style is better."
msgstr ""
"著者はこの指針を本当に気に入っていますが、こうしたラムダなしスタイルが他より"
"優れているかどうかについて、異論は認めます。"

#: ../../howto/functional.rst:1178
msgid "Revision History and Acknowledgements"
msgstr "更新履歴と謝辞"

#: ../../howto/functional.rst:1180
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike "
"Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton."
msgstr ""
"著者は提案の申し出や修正、様々なこの記事の草稿の助けをしてくれた以下の人々に"
"感謝します: Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim "
"Jewett, Mike Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake "
"Winton."

#: ../../howto/functional.rst:1185
msgid "Version 0.1: posted June 30 2006."
msgstr "Version 0.1: posted June 30 2006."

#: ../../howto/functional.rst:1187
msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr "Version 0.11: posted July 1 2006.  Typo fixes."

#: ../../howto/functional.rst:1189
msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."
msgstr ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."

#: ../../howto/functional.rst:1192
msgid ""
"Version 0.21: Added more references suggested on the tutor mailing list."
msgstr ""
"Version 0.21: Added more references suggested on the tutor mailing list."

#: ../../howto/functional.rst:1194
msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."
msgstr ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."

#: ../../howto/functional.rst:1199
msgid "References"
msgstr "参考資料"

#: ../../howto/functional.rst:1202
msgid "General"
msgstr "一般論"

#: ../../howto/functional.rst:1204
msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson and "
"Gerald Jay Sussman with Julie Sussman.  Full text at https://mitpress.mit."
"edu/sicp/.  In this classic textbook of computer science, chapters 2 and 3 "
"discuss the use of sequences and streams to organize the data flow inside a "
"program.  The book uses Scheme for its examples, but many of the design "
"approaches described in these chapters are applicable to functional-style "
"Python code."
msgstr ""
"Harold Abelson と Gerald Jay Sussman, Julie Sussman による **Structure and "
"Interpretation of Computer Programs**。https://mitpress.mit.edu/sicp/ に全文"
"があります。この計算機科学に関する古典的な教科書では、2 章と 3 章でデータフ"
"ローをプログラム内でまとめるためのシーケンスとストリームの利用について議論し"
"ています。この本は例として Scheme を使っていますが、これらの章内の多くのデザ"
"インアプローチは関数スタイルな Python コードにも適用できます。"

#: ../../howto/functional.rst:1212
msgid ""
"http://www.defmacro.org/ramblings/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy historical "
"introduction."
msgstr ""
"http://www.defmacro.org/ramblings/fp.html: 関数プログラミングの一般的な入門"
"で Java での例を利用していて、長大な歴史の紹介があります。"

#: ../../howto/functional.rst:1215
msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr ""
"https://en.wikipedia.org/wiki/Functional_programming: 関数プログラミングに関"
"する一般的な内容の記事。"

#: ../../howto/functional.rst:1218
msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr "https://en.wikipedia.org/wiki/Coroutine: コルーチンに関する記事。"

#: ../../howto/functional.rst:1220
msgid ""
"https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr "https://en.wikipedia.org/wiki/Currying: カリー化の概念に関する記事。"

#: ../../howto/functional.rst:1223
msgid "Python-specific"
msgstr "Python 特有の話"

#: ../../howto/functional.rst:1225
msgid ""
"http://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming for "
"text processing, in the section titled \"Utilizing Higher-Order Functions in "
"Text Processing\"."
msgstr ""
"http://gnosis.cx/TPiP/: David Mertz's の本の最初の章 :title-reference:`Text "
"Processing in Python` では文書処理のための関数プログラミングについて議論して"
"います、この議論の節には \"Utilizing Higher-Order Functions in Text "
"Processing\" というタイトルがついています。"

#: ../../howto/functional.rst:1230
msgid ""
"Mertz also wrote a 3-part series of articles on functional programming for "
"IBM's DeveloperWorks site; see `part 1 <https://developer.ibm.com/articles/l-"
"prog/>`__, `part 2 <https://developer.ibm.com/tutorials/l-prog2/>`__, and "
"`part 3 <https://developer.ibm.com/tutorials/l-prog3/>`__,"
msgstr ""
"Mertz は IBM の DeveloperWorks サイトにも関数型プログラミングに関する 3 部構"
"成の記事を書いています; `part 1 <https://developer.ibm.com/articles/l-prog/"
">`__, `part 2 <https://developer.ibm.com/tutorials/l-prog2/>`__, `part 3 "
"<https://developer.ibm.com/tutorials/l-prog3/>`__,"

#: ../../howto/functional.rst:1238
msgid "Python documentation"
msgstr "Python 文書"

#: ../../howto/functional.rst:1240
msgid "Documentation for the :mod:`itertools` module."
msgstr ":mod:`itertools` モジュールの文書。"

#: ../../howto/functional.rst:1242
msgid "Documentation for the :mod:`functools` module."
msgstr ":mod:`functools` モジュールについてのドキュメント。"

#: ../../howto/functional.rst:1244
msgid "Documentation for the :mod:`operator` module."
msgstr ":mod:`operator` モジュールの文書。"

#: ../../howto/functional.rst:1246
msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`: \"Generator Expressions\""

#: ../../howto/functional.rst:1248
msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
