# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Osamu NAKAMURA, 2021
# 秘湯 <xwhhsprings@gmail.com>, 2021
# 渋川よしき <yoshiki@shibu.jp>, 2022
# Takanori Suzuki <takanori@takanory.net>, 2023
# Takeshi Nakazato, 2023
# Arihiro TAKASE, 2023
# tomo, 2023
# souma987, 2023
# TENMYO Masakazu, 2024
# Inada Naoki <songofacandy@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-11 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Inada Naoki <songofacandy@gmail.com>, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/logging.rst:5
msgid "Logging HOWTO"
msgstr "Logging HOWTO"

#: ../../howto/logging.rst:0
msgid "Author"
msgstr "著者"

#: ../../howto/logging.rst:7
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../../howto/logging.rst:13
msgid ""
"This page contains tutorial information. For links to reference information "
"and a logging cookbook, please see :ref:`tutorial-ref-links`."
msgstr ""
"このページはチュートリアルです。レファレンスやロギングクックブックは、 :ref:"
"`tutorial-ref-links` を参照してください。"

#: ../../howto/logging.rst:17
msgid "Basic Logging Tutorial"
msgstr "基本 logging チュートリアル"

#: ../../howto/logging.rst:19
msgid ""
"Logging is a means of tracking events that happen when some software runs. "
"The software's developer adds logging calls to their code to indicate that "
"certain events have occurred. An event is described by a descriptive message "
"which can optionally contain variable data (i.e. data that is potentially "
"different for each occurrence of the event). Events also have an importance "
"which the developer ascribes to the event; the importance can also be called "
"the *level* or *severity*."
msgstr ""
"logging は、あるソフトウェアが実行されているときに起こったイベントを追跡する"
"ための手段です。ソフトウェアの開発者は、特定のイベントが発生したことを示す "
"logging の呼び出しをコードに加えます。イベントは、メッセージで記述され、これ"
"に変数データ (すなわち、イベントが起こる度に異なるかもしれないデータ) を加え"
"ることもできます。イベントには、開発者がそのイベントに定めた重要性も含まれま"
"す。重要性は、*レベル (level)* や *重大度 (severity)* とも呼ばれます。"

#: ../../howto/logging.rst:28
msgid "When to use logging"
msgstr "logging を使うとき"

#: ../../howto/logging.rst:30
msgid ""
"You can access logging functionality by creating a logger via ``logger = "
"getLogger(__name__)``, and then calling the logger's :meth:`~Logger.debug`, :"
"meth:`~Logger.info`, :meth:`~Logger.warning`, :meth:`~Logger.error` and :"
"meth:`~Logger.critical` methods. To determine when to use logging, and to "
"see which logger methods to use when, see the table below. It states, for "
"each of a set of common tasks, the best tool to use for that task."
msgstr ""

#: ../../howto/logging.rst:38
msgid "Task you want to perform"
msgstr "行いたいタスク"

#: ../../howto/logging.rst:38
msgid "The best tool for the task"
msgstr "そのタスクに最適なツール"

#: ../../howto/logging.rst:40
msgid ""
"Display console output for ordinary usage of a command line script or program"
msgstr "コマンドラインスクリプトやプログラムで普通に使う、コンソール出力の表示"

#: ../../howto/logging.rst:40
msgid ":func:`print`"
msgstr ":func:`print`"

#: ../../howto/logging.rst:44
msgid ""
"Report events that occur during normal operation of a program (e.g. for "
"status monitoring or fault investigation)"
msgstr ""
"プログラムの通常の操作中に発生したイベントの報告 (例えば、状態の監視や障害の"
"分析)"

#: ../../howto/logging.rst:44
msgid ""
"A logger's :meth:`~Logger.info` (or :meth:`~Logger.debug` method for very "
"detailed output for diagnostic purposes)"
msgstr ""

#: ../../howto/logging.rst:49
msgid "Issue a warning regarding a particular runtime event"
msgstr "特定のランタイムイベントに関わる警告の発行"

#: ../../howto/logging.rst:49
msgid ""
":func:`warnings.warn` in library code if the issue is avoidable and the "
"client application should be modified to eliminate the warning"
msgstr ""
"その発行が避けられるもので、クライアントアプリケーションを修正してその警告を"
"排除するべきなら :func:`warnings.warn`"

#: ../../howto/logging.rst:54
msgid ""
"A logger's :meth:`~Logger.warning` method if there is nothing the client "
"application can do about the situation, but the event should still be noted"
msgstr ""

#: ../../howto/logging.rst:60
msgid "Report an error regarding a particular runtime event"
msgstr "特定のランタイムイベントに関わるエラーの報告"

#: ../../howto/logging.rst:60
msgid "Raise an exception"
msgstr "例外の送出"

#: ../../howto/logging.rst:63
msgid ""
"Report suppression of an error without raising an exception (e.g. error "
"handler in a long-running server process)"
msgstr ""
"例外の送出をしないエラーの抑制 (例えば、長期のサーバプロセス中のエラーハンド"
"ラ)"

#: ../../howto/logging.rst:63
msgid ""
"A logger's :meth:`~Logger.error`, :meth:`~Logger.exception` or :meth:"
"`~Logger.critical` method as appropriate for the specific error and "
"application domain"
msgstr ""

#: ../../howto/logging.rst:70
msgid ""
"The logger methods are named after the level or severity of the events they "
"are used to track. The standard levels and their applicability are described "
"below (in increasing order of severity):"
msgstr ""

#: ../../howto/logging.rst:77 ../../howto/logging.rst:875
msgid "Level"
msgstr "レベル"

#: ../../howto/logging.rst:77
msgid "When it's used"
msgstr "いつ使うか"

#: ../../howto/logging.rst:79 ../../howto/logging.rst:885
msgid "``DEBUG``"
msgstr "``DEBUG``"

#: ../../howto/logging.rst:79
msgid ""
"Detailed information, typically of interest only when diagnosing problems."
msgstr "おもに問題を診断するときにのみ関心があるような、詳細な情報。"

#: ../../howto/logging.rst:82 ../../howto/logging.rst:883
msgid "``INFO``"
msgstr "``INFO``"

#: ../../howto/logging.rst:82
msgid "Confirmation that things are working as expected."
msgstr "想定された通りのことが起こったことの確認。"

#: ../../howto/logging.rst:85 ../../howto/logging.rst:881
msgid "``WARNING``"
msgstr "``WARNING``"

#: ../../howto/logging.rst:85
msgid ""
"An indication that something unexpected happened, or indicative of some "
"problem in the near future (e.g. 'disk space low'). The software is still "
"working as expected."
msgstr ""
"想定外のことが起こった、または問題が近く起こりそうである (例えば、'disk "
"space low') ことの表示。"

#: ../../howto/logging.rst:90 ../../howto/logging.rst:879
msgid "``ERROR``"
msgstr "``ERROR``"

#: ../../howto/logging.rst:90
msgid ""
"Due to a more serious problem, the software has not been able to perform "
"some function."
msgstr "より重大な問題により、ソフトウェアがある機能を実行できないこと。"

#: ../../howto/logging.rst:93 ../../howto/logging.rst:877
msgid "``CRITICAL``"
msgstr "``CRITICAL``"

#: ../../howto/logging.rst:93
msgid ""
"A serious error, indicating that the program itself may be unable to "
"continue running."
msgstr "プログラム自体が実行を続けられないことを表す、重大なエラー。"

#: ../../howto/logging.rst:97
msgid ""
"The default level is ``WARNING``, which means that only events of this "
"severity and higher will be tracked, unless the logging package is "
"configured to do otherwise."
msgstr ""

#: ../../howto/logging.rst:100
msgid ""
"Events that are tracked can be handled in different ways. The simplest way "
"of handling tracked events is to print them to the console. Another common "
"way is to write them to a disk file."
msgstr ""
"追跡されるイベントは、異なる方法で処理されます。追跡されたイベントを処理する"
"最も単純な方法は、それをコンソールに表示することです。その他のよくある方法"
"は、それをディスクファイルに書き出すことです。"

#: ../../howto/logging.rst:108
msgid "A simple example"
msgstr "簡単な例"

#: ../../howto/logging.rst:110
msgid "A very simple example is::"
msgstr "ごく簡単な例は::"

#: ../../howto/logging.rst:112
msgid ""
"import logging\n"
"logging.warning('Watch out!')  # will print a message to the console\n"
"logging.info('I told you so')  # will not print anything"
msgstr ""

#: ../../howto/logging.rst:116
msgid "If you type these lines into a script and run it, you'll see:"
msgstr ""
"これらの行をスクリプトにタイプして実行すると、次のようにコンソールに出力され"
"ます:"

#: ../../howto/logging.rst:118
msgid "WARNING:root:Watch out!"
msgstr ""

#: ../../howto/logging.rst:122
msgid ""
"printed out on the console. The ``INFO`` message doesn't appear because the "
"default level is ``WARNING``. The printed message includes the indication of "
"the level and the description of the event provided in the logging call, i."
"e. 'Watch out!'. The actual output can be formatted quite flexibly if you "
"need that; formatting options will also be explained later."
msgstr ""

#: ../../howto/logging.rst:128
msgid ""
"Notice that in this example, we use functions directly on the ``logging`` "
"module, like ``logging.debug``, rather than creating a logger and calling "
"functions on it. These functions operation on the root logger, but can be "
"useful as they will call :func:`~logging.basicConfig` for you if it has not "
"been called yet, like in this example.  In larger programs you'll usually "
"want to control the logging configuration explicitly however - so for that "
"reason as well as others, it's better to create loggers and call their "
"methods."
msgstr ""

#: ../../howto/logging.rst:137
msgid "Logging to a file"
msgstr "ファイルへの logging"

#: ../../howto/logging.rst:139
msgid ""
"A very common situation is that of recording logging events in a file, so "
"let's look at that next. Be sure to try the following in a newly started "
"Python interpreter, and don't just continue from the session described "
"above::"
msgstr ""
"logging イベントをファイルに記録するのは非常によくあるパターンなので次はこれ"
"を見て行きましょう。以下のサンプルを試すときは Python インタプリタを新しく起"
"動して、上のセッションの続きにならないようにしてください::"

#: ../../howto/logging.rst:143
msgid ""
"import logging\n"
"logger = logging.getLogger(__name__)\n"
"logging.basicConfig(filename='example.log', encoding='utf-8', level=logging."
"DEBUG)\n"
"logger.debug('This message should go to the log file')\n"
"logger.info('So should this')\n"
"logger.warning('And this, too')\n"
"logger.error('And non-ASCII stuff, too, like Øresund and Malmö')"
msgstr ""

#: ../../howto/logging.rst:151
msgid ""
"The *encoding* argument was added. In earlier Python versions, or if not "
"specified, the encoding used is the default value used by :func:`open`. "
"While not shown in the above example, an *errors* argument can also now be "
"passed, which determines how encoding errors are handled. For available "
"values and the default, see the documentation for :func:`open`."
msgstr ""
"*encoding* 引数が追加されました。以前のバージョンの Python では、あるいは指定"
"されなかったら、エンコーディングには :func:`open` が使うデフォルト値が使われ"
"ます。上の例に出てきていませんが、同じく渡せるようになった *errors* 引数は、"
"エンコーディングエラーの扱いを決定します。利用可能な値およびデフォルト値につ"
"いては、 :func:`open` のドキュメントを参照してください。"

#: ../../howto/logging.rst:158
msgid ""
"And now if we open the file and look at what we have, we should find the log "
"messages:"
msgstr "そして、ファイルの中身を確認すると、ログメッセージが確認できます:"

#: ../../howto/logging.rst:161
msgid ""
"DEBUG:__main__:This message should go to the log file\n"
"INFO:__main__:So should this\n"
"WARNING:__main__:And this, too\n"
"ERROR:__main__:And non-ASCII stuff, too, like Øresund and Malmö"
msgstr ""

#: ../../howto/logging.rst:168
msgid ""
"This example also shows how you can set the logging level which acts as the "
"threshold for tracking. In this case, because we set the threshold to "
"``DEBUG``, all of the messages were printed."
msgstr ""
"この例はまた、追跡のしきい値となるロギングレベルを設定する方法も示していま"
"す。この例では、しきい値を ``DEBUG`` に設定しているので、全てのメッセージが表"
"示されています。"

#: ../../howto/logging.rst:172
msgid ""
"If you want to set the logging level from a command-line option such as:"
msgstr "次のようなコマンドラインオプションでログレベルを設定したいと考え:"

#: ../../howto/logging.rst:174
msgid "--log=INFO"
msgstr ""

#: ../../howto/logging.rst:178
msgid ""
"and you have the value of the parameter passed for ``--log`` in some "
"variable *loglevel*, you can use::"
msgstr ""
"``--log`` に渡されたパラメータの値を変数 *loglevel* に保存しているとしたら、"

#: ../../howto/logging.rst:181
msgid "getattr(logging, loglevel.upper())"
msgstr ""

#: ../../howto/logging.rst:183
msgid ""
"to get the value which you'll pass to :func:`basicConfig` via the *level* "
"argument. You may want to error check any user input value, perhaps as in "
"the following example::"
msgstr ""
"というコードを使い、 :func:`basicConfig` の *level* 引数に渡すべき値が得られ"
"ます。ユーザの入力値をすべてエラーチェックしたくなり、次の例のように実装する"
"こともあるでしょう::"

#: ../../howto/logging.rst:187
msgid ""
"# assuming loglevel is bound to the string value obtained from the\n"
"# command line argument. Convert to upper case to allow the user to\n"
"# specify --log=DEBUG or --log=debug\n"
"numeric_level = getattr(logging, loglevel.upper(), None)\n"
"if not isinstance(numeric_level, int):\n"
"    raise ValueError('Invalid log level: %s' % loglevel)\n"
"logging.basicConfig(level=numeric_level, ...)"
msgstr ""

#: ../../howto/logging.rst:195
msgid ""
"The call to :func:`basicConfig` should come *before* any calls to a logger's "
"methods such as :meth:`~Logger.debug`, :meth:`~Logger.info`, etc. Otherwise, "
"that logging event may not be handled in the desired manner."
msgstr ""

#: ../../howto/logging.rst:199
msgid ""
"If you run the above script several times, the messages from successive runs "
"are appended to the file *example.log*. If you want each run to start "
"afresh, not remembering the messages from earlier runs, you can specify the "
"*filemode* argument, by changing the call in the above example to::"
msgstr ""
"上記のスクリプトを複数回実行すると、2 回目以降の実行によるメッセージは "
"*example.log* に加えられます。以前の実行によるメッセージを記憶せず、実行ごと"
"に新たに始めたいなら、上記の例での呼び出しを次のように変え、*filemode* 引数を"
"指定する方法がとれます::"

#: ../../howto/logging.rst:204
msgid ""
"logging.basicConfig(filename='example.log', filemode='w', level=logging."
"DEBUG)"
msgstr ""

#: ../../howto/logging.rst:206
msgid ""
"The output will be the same as before, but the log file is no longer "
"appended to, so the messages from earlier runs are lost."
msgstr ""
"出力は先ほどと同じになりますが、ログファイルは追記されなくなり、以前の実行に"
"よるメッセージは失われます。"

#: ../../howto/logging.rst:211
msgid "Logging variable data"
msgstr "変数データのロギング"

#: ../../howto/logging.rst:213
msgid ""
"To log variable data, use a format string for the event description message "
"and append the variable data as arguments. For example::"
msgstr ""
"変数データのログを取るには、イベント記述メッセージにフォーマット文字列を使"
"い、引数に変数データを加えてください。例えば::"

#: ../../howto/logging.rst:216
msgid ""
"import logging\n"
"logging.warning('%s before you %s', 'Look', 'leap!')"
msgstr ""

#: ../../howto/logging.rst:219
msgid "will display:"
msgstr "により、次のように表示されます:"

#: ../../howto/logging.rst:221
msgid "WARNING:root:Look before you leap!"
msgstr ""

#: ../../howto/logging.rst:225
msgid ""
"As you can see, merging of variable data into the event description message "
"uses the old, %-style of string formatting. This is for backwards "
"compatibility: the logging package pre-dates newer formatting options such "
"as :meth:`str.format` and :class:`string.Template`. These newer formatting "
"options *are* supported, but exploring them is outside the scope of this "
"tutorial: see :ref:`formatting-styles` for more information."
msgstr ""
"ご覧の通り、イベント記述メッセージに変数データを統合するために、古い、% スタ"
"イルの文字列フォーマットを使っています。これは後方互換性のためです。logging "
"パッケージは、 :meth:`str.format` や :class:`string.Template` のような新しい"
"フォーマットオプションよりも先に生まれました。新しいフォーマットオプションは"
"サポートされて *います* が、その探求はこのチュートリアルでは対象としません。"
"詳細は :ref:`formatting-styles` を参照してください。"

#: ../../howto/logging.rst:234
msgid "Changing the format of displayed messages"
msgstr "表示されるメッセージのフォーマットの変更"

#: ../../howto/logging.rst:236
msgid ""
"To change the format which is used to display messages, you need to specify "
"the format you want to use::"
msgstr ""
"メッセージを表示するのに使われるフォーマットを変更するには、使いたいフォー"
"マットを指定する必要があります::"

#: ../../howto/logging.rst:239
msgid ""
"import logging\n"
"logging.basicConfig(format='%(levelname)s:%(message)s', level=logging."
"DEBUG)\n"
"logging.debug('This message should appear on the console')\n"
"logging.info('So should this')\n"
"logging.warning('And this, too')"
msgstr ""

#: ../../howto/logging.rst:245
msgid "which would print:"
msgstr "により、次のように表示されます:"

#: ../../howto/logging.rst:247
msgid ""
"DEBUG:This message should appear on the console\n"
"INFO:So should this\n"
"WARNING:And this, too"
msgstr ""

#: ../../howto/logging.rst:253
msgid ""
"Notice that the 'root' which appeared in earlier examples has disappeared. "
"For a full set of things that can appear in format strings, you can refer to "
"the documentation for :ref:`logrecord-attributes`, but for simple usage, you "
"just need the *levelname* (severity), *message* (event description, "
"including variable data) and perhaps to display when the event occurred. "
"This is described in the next section."
msgstr ""
"ご覧の通り、先の例に現れた 'root' が消失しています。フォーマット文字列に含め"
"ることができるものの一覧は、 :ref:`logrecord-attributes` のドキュメントから参"
"照できますが、単純な用途では、必要なものは *levelname* (重大度)、 *message* "
"(変数データを含むイベント記述)、それともしかしたら、イベントがいつ起こったか"
"という表示だけです。これは次の節で解説します。"

#: ../../howto/logging.rst:262
msgid "Displaying the date/time in messages"
msgstr "メッセージ内での日付と時刻の表示"

#: ../../howto/logging.rst:264
msgid ""
"To display the date and time of an event, you would place '%(asctime)s' in "
"your format string::"
msgstr ""
"イベントの日付と時刻を表示するには、フォーマット文字列に '%(asctime)s' を置い"
"てください::"

#: ../../howto/logging.rst:267
msgid ""
"import logging\n"
"logging.basicConfig(format='%(asctime)s %(message)s')\n"
"logging.warning('is when this event was logged.')"
msgstr ""

#: ../../howto/logging.rst:271
msgid "which should print something like this:"
msgstr "これは以下の様なフォーマットで表示されます:"

#: ../../howto/logging.rst:273
msgid "2010-12-12 11:41:42,612 is when this event was logged."
msgstr ""

#: ../../howto/logging.rst:277
msgid ""
"The default format for date/time display (shown above) is like ISO8601 or :"
"rfc:`3339`. If you need more control over the formatting of the date/time, "
"provide a *datefmt* argument to ``basicConfig``, as in this example::"
msgstr ""
"デフォルトの日付と時間の表示フォーマット （上記の結果） は、ISO8601 や :rfc:"
"`3339` に似ています。日付と時間のフォーマットをより詳細に制御する必要があるな"
"ら、以下の例の様に、 ``basicConfig`` に *datefmt* 引数を指定してください::"

#: ../../howto/logging.rst:281
msgid ""
"import logging\n"
"logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:"
"%M:%S %p')\n"
"logging.warning('is when this event was logged.')"
msgstr ""

#: ../../howto/logging.rst:285
msgid "which would display something like this:"
msgstr "これは次のように表示されます:"

#: ../../howto/logging.rst:287
msgid "12/12/2010 11:46:36 AM is when this event was logged."
msgstr ""

#: ../../howto/logging.rst:291
msgid ""
"The format of the *datefmt* argument is the same as supported by :func:`time."
"strftime`."
msgstr ""
"*datefmt* 引数のフォーマットは、 :func:`time.strftime` でサポートされているも"
"のと同じです。"

#: ../../howto/logging.rst:296
msgid "Next Steps"
msgstr "次のステップ"

#: ../../howto/logging.rst:298
msgid ""
"That concludes the basic tutorial. It should be enough to get you up and "
"running with logging. There's a lot more that the logging package offers, "
"but to get the best out of it, you'll need to invest a little more of your "
"time in reading the following sections. If you're ready for that, grab some "
"of your favourite beverage and carry on."
msgstr ""
"基本チュートリアルはこれで終わりです。あなたがロギングを使っていくためには、"
"これで十分でしょう。logging パッケージが提供するものはもっとありますが、それ"
"を使いこなすためには、もうちょっと時間をかけて、以下のセクションを読む必要が"
"あります。その用意ができたら、好きな飲み物を持って、次に進みましょう。"

#: ../../howto/logging.rst:304
msgid ""
"If your logging needs are simple, then use the above examples to incorporate "
"logging into your own scripts, and if you run into problems or don't "
"understand something, please post a question on the comp.lang.python Usenet "
"group (available at https://groups.google.com/g/comp.lang.python) and you "
"should receive help before too long."
msgstr ""
"ロギングを簡潔に行いたいなら、上記の例を使って、ロギングをあなたのスクリプト"
"に組み込んでください。問題があったり理解出来ないことがあったら、comp.lang."
"python Usenet group (https://groups.google.com/g/comp.lang.python から利用で"
"きます) に質問を投稿してくだされば、そう遠くないうちに助けが得られるでしょ"
"う。"

#: ../../howto/logging.rst:310
msgid ""
"Still here? You can carry on reading the next few sections, which provide a "
"slightly more advanced/in-depth tutorial than the basic one above. After "
"that, you can take a look at the :ref:`logging-cookbook`."
msgstr ""
"まだいますか？もう少し上級の、踏み込んだチュートリアルを綴った、幾つかの節を"
"読み続けることができます。その後で、 :ref:`logging-cookbook` もご覧ください。"

#: ../../howto/logging.rst:318
msgid "Advanced Logging Tutorial"
msgstr "上級ロギングチュートリアル"

#: ../../howto/logging.rst:320
msgid ""
"The logging library takes a modular approach and offers several categories "
"of components: loggers, handlers, filters, and formatters."
msgstr ""
"logging ライブラリはモジュール方式のアプローチを取り、いくつかのカテゴリの部"
"品を提供します。ロガー、ハンドラ、フィルタ、フォーマッタです。"

#: ../../howto/logging.rst:323
msgid "Loggers expose the interface that application code directly uses."
msgstr ""
"ロガーは、アプリケーションコードが直接使うインターフェースを公開します。"

#: ../../howto/logging.rst:324
msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr ""
"ハンドラは、(ロガーによって生成された) ログ記録を適切な送信先に送ります。"

#: ../../howto/logging.rst:326
msgid ""
"Filters provide a finer grained facility for determining which log records "
"to output."
msgstr ""
"フィルタは、どのログ記録を出力するかを決定する、きめ細かい機能を提供します。"

#: ../../howto/logging.rst:328
msgid "Formatters specify the layout of log records in the final output."
msgstr "フォーマッタは、ログ記録が最終的に出力されるレイアウトを指定します。"

#: ../../howto/logging.rst:330
msgid ""
"Log event information is passed between loggers, handlers, filters and "
"formatters in a :class:`LogRecord` instance."
msgstr ""
"ログイベント情報は :class:`LogRecord` インスタンスの形で、 logger, handler, "
"filter, formatter の間でやりとりされます。"

#: ../../howto/logging.rst:333
msgid ""
"Logging is performed by calling methods on instances of the :class:`Logger` "
"class (hereafter called :dfn:`loggers`). Each instance has a name, and they "
"are conceptually arranged in a namespace hierarchy using dots (periods) as "
"separators. For example, a logger named 'scan' is the parent of loggers "
"'scan.text', 'scan.html' and 'scan.pdf'. Logger names can be anything you "
"want, and indicate the area of an application in which a logged message "
"originates."
msgstr ""
"ロギングは、 :class:`Logger` クラスのインスタンス (以下 :dfn:`ロガー`) にメ"
"ソッドを呼び出すことで実行されます。各インスタンスには名前があり、名前空間階"
"層構造に、ドット (ピリオド) をセパレータとして、概念的に並べられています。例"
"えば、 'scan' という名前のロガーは、ロガー 'scan.text', 'scan.html' および "
"'scan.pdf'の親です。ロガー名は、何でも望むものにでき、ロギングされたメッセー"
"ジが発生した場所を指し示します。"

#: ../../howto/logging.rst:340
msgid ""
"A good convention to use when naming loggers is to use a module-level "
"logger, in each module which uses logging, named as follows::"
msgstr ""
"ロガーに名前をつけるときの良い習慣は、ロギングを使う各モジュールに、以下のよ"
"うに名付けられた、モジュールレベルロガーを使うことです::"

#: ../../howto/logging.rst:343
msgid "logger = logging.getLogger(__name__)"
msgstr ""

#: ../../howto/logging.rst:345
msgid ""
"This means that logger names track the package/module hierarchy, and it's "
"intuitively obvious where events are logged just from the logger name."
msgstr ""
"これにより、ロガー名はパッケージ/モジュール階層をなぞり、ロガー名だけで、どこ"
"でイベントのログが取られたか、直感的に明らかになります。"

#: ../../howto/logging.rst:348
msgid ""
"The root of the hierarchy of loggers is called the root logger. That's the "
"logger used by the functions :func:`debug`, :func:`info`, :func:`warning`, :"
"func:`error` and :func:`critical`, which just call the same-named method of "
"the root logger. The functions and the methods have the same signatures. The "
"root logger's name is printed as 'root' in the logged output."
msgstr ""
"ロガーの階層構造の根源は、ルートロガーと呼ばれます。それが、関数 :func:"
"`debug`, :func:`info`, :func:`warning`, :func:`error` および :func:"
"`critical` によって使われるロガーとなります。これらの関数は単に、ルートロガー"
"の同名のメソッドを呼び出します。これらの関数とメソッドは、同じ署名をもってい"
"ます。ルートロガーの名前は、ログ出力では 'root' と表示されます。"

#: ../../howto/logging.rst:354
msgid ""
"It is, of course, possible to log messages to different destinations. "
"Support is included in the package for writing log messages to files, HTTP "
"GET/POST locations, email via SMTP, generic sockets, queues, or OS-specific "
"logging mechanisms such as syslog or the Windows NT event log. Destinations "
"are served by :dfn:`handler` classes. You can create your own log "
"destination class if you have special requirements not met by any of the "
"built-in handler classes."
msgstr ""
"もちろん、メッセージを異なる送信先に記録することも出来ます。このパッケージで"
"は、ファイルへ、 HTTP GET/POST 先へ、 SMTP 経由で電子メールへ、汎用のソケット"
"へ、キューへ、または Windows NT イベントログのような OS 毎のログ記録機構へ"
"の、ログメッセージの書きこみがサポートされています。送信先は、 :dfn:"
"`handler` クラスによって取り扱われます。組み込みのハンドラクラスでは満たせな"
"いような、特殊な要件があるなら、独自のログ送信先を生成できます。"

#: ../../howto/logging.rst:361
msgid ""
"By default, no destination is set for any logging messages. You can specify "
"a destination (such as console or file) by using :func:`basicConfig` as in "
"the tutorial examples. If you call the functions  :func:`debug`, :func:"
"`info`, :func:`warning`, :func:`error` and :func:`critical`, they will check "
"to see if no destination is set; and if one is not set, they will set a "
"destination of the console (``sys.stderr``) and a default format for the "
"displayed message before delegating to the root logger to do the actual "
"message output."
msgstr ""
"デフォルトでは、どのロギングメッセージに対しても、送信先は設定されていませ"
"ん。チュートリアルの例のように、 :func:`basicConfig` を使って、送信先 (コン"
"ソールやファイルなど) を指定できます。関数 :func:`debug`, :func:`info`, :"
"func:`warning`, :func:`error` および :func:`critical` を呼び出すと、それらは"
"送信先が設定されていないかを調べます。そして設定されていなければ、ルートロ"
"ガーに委譲して実際にメッセージを出力する前に、コンソール (``sys.stderr``) を"
"送信先に、デフォルトのフォーマットを表示されるメッセージに設定します。"

#: ../../howto/logging.rst:369
msgid "The default format set by :func:`basicConfig` for messages is:"
msgstr ""
":func:`basicConfig` が設定するデフォルトのメッセージのフォーマットは次のよう"
"になります:"

#: ../../howto/logging.rst:371
msgid "severity:logger name:message"
msgstr ""

#: ../../howto/logging.rst:375
msgid ""
"You can change this by passing a format string to :func:`basicConfig` with "
"the *format* keyword argument. For all options regarding how a format string "
"is constructed, see :ref:`formatter-objects`."
msgstr ""
":func:`basicConfig` の *format* キーワード引数にフォーマット文字列を渡すこと"
"で、これを変更できます。フォーマット文字列を構成するためのすべてのオプション"
"は、 :ref:`formatter-objects` を参照してください。"

#: ../../howto/logging.rst:380
msgid "Logging Flow"
msgstr "Logging Flow"

#: ../../howto/logging.rst:382
msgid ""
"The flow of log event information in loggers and handlers is illustrated in "
"the following diagram."
msgstr ""
"次の図はログイベントが logger と handler をどう流れるかを示しています。"

#: ../../howto/logging.rst:433
msgid "Loggers"
msgstr "ロガー"

#: ../../howto/logging.rst:435
msgid ""
":class:`Logger` objects have a threefold job.  First, they expose several "
"methods to application code so that applications can log messages at "
"runtime. Second, logger objects determine which log messages to act upon "
"based upon severity (the default filtering facility) or filter objects.  "
"Third, logger objects pass along relevant log messages to all interested log "
"handlers."
msgstr ""
":class:`Logger` オブジェクトの仕事は大きく三つに分かれます。一つ目は、アプリ"
"ケーションが実行中にメッセージを記録できるように、いくつかのメソッドをアプリ"
"ケーションから呼べるようにしています。二つ目に、ロガーオブジェクトはどのメッ"
"セージに対して作用するかを、深刻度 (デフォルトのフィルタ機構) またはフィルタ"
"オブジェクトに基づいて決定します。三つ目に、ロガーオブジェクトは関心を持って"
"いるすべてのログハンドラに関連するログメッセージを回送します。"

#: ../../howto/logging.rst:441
msgid ""
"The most widely used methods on logger objects fall into two categories: "
"configuration and message sending."
msgstr ""
"とりわけ広く使われるロガーオブジェクトのメソッドは、二つのカテゴリーに分類で"
"きます: 設定とメッセージ送信です。"

#: ../../howto/logging.rst:444
msgid "These are the most common configuration methods:"
msgstr "これらが設定メソッドの中でよく使われます:"

#: ../../howto/logging.rst:446
msgid ""
":meth:`Logger.setLevel` specifies the lowest-severity log message a logger "
"will handle, where debug is the lowest built-in severity level and critical "
"is the highest built-in severity.  For example, if the severity level is "
"INFO, the logger will handle only INFO, WARNING, ERROR, and CRITICAL "
"messages and will ignore DEBUG messages."
msgstr ""
":meth:`Logger.setLevel` はロガーが扱うログメッセージの最も低い深刻度を指定し"
"ます。組み込みの深刻度の中では DEBUG が一番低く、 CRITICAL が一番高くなりま"
"す。たとえば、深刻度が INFO と設定されたロガーは INFO, WARNING, ERROR, "
"CRITICAL のメッセージしか扱わず、 DEBUG メッセージは無視します。"

#: ../../howto/logging.rst:452
msgid ""
":meth:`Logger.addHandler` and :meth:`Logger.removeHandler` add and remove "
"handler objects from the logger object.  Handlers are covered in more detail "
"in :ref:`handler-basic`."
msgstr ""
":meth:`Logger.addHandler` と :meth:`Logger.removeHandler` は、ハンドラオブ"
"ジェクトをロガーオブジェクトから追加または削除します。ハンドラについては、 :"
"ref:`handler-basic` で詳しく述べます。"

#: ../../howto/logging.rst:456
msgid ""
":meth:`Logger.addFilter` and :meth:`Logger.removeFilter` add and remove "
"filter objects from the logger object.  Filters are covered in more detail "
"in :ref:`filter`."
msgstr ""
":meth:`Logger.addFilter` と :meth:`Logger.removeFilter` はロガーオブジェクト"
"にフィルタオブジェクトを追加または削除します。フィルタについては、 :ref:"
"`filter` で詳しく述べます。"

#: ../../howto/logging.rst:460
msgid ""
"You don't need to always call these methods on every logger you create. See "
"the last two paragraphs in this section."
msgstr ""
"これらのメソッドを、生成したすべてのロガーに毎回呼び出さなければならないわけ"
"ではありません。この節の最後の 2 段落を参照してください。"

#: ../../howto/logging.rst:463
msgid ""
"With the logger object configured, the following methods create log messages:"
msgstr ""
"ロガーオブジェクトが設定されれば、以下のメソッドがログメッセージを生成します:"

#: ../../howto/logging.rst:465
msgid ""
":meth:`Logger.debug`, :meth:`Logger.info`, :meth:`Logger.warning`, :meth:"
"`Logger.error`, and :meth:`Logger.critical` all create log records with a "
"message and a level that corresponds to their respective method names. The "
"message is actually a format string, which may contain the standard string "
"substitution syntax of ``%s``, ``%d``, ``%f``, and so on.  The rest of their "
"arguments is a list of objects that correspond with the substitution fields "
"in the message.  With regard to ``**kwargs``, the logging methods care only "
"about a keyword of ``exc_info`` and use it to determine whether to log "
"exception information."
msgstr ""
":meth:`Logger.debug`, :meth:`Logger.info`, :meth:`Logger.warning`, :meth:"
"`Logger.error`, :meth:`Logger.critical` はすべて、メッセージとメソッド名に対"
"応したレベルでログ記録を作り出します。メッセージは実際にはフォーマット文字列"
"であり、通常の文字列代入に使う ``%s``, ``%d``, ``%f`` などを含むことができま"
"す。残りの引数はメッセージの代入される位置に対応するオブジェクトのリストで"
"す。 ``**kwargs`` については、ログ記録メソッドが気にするキーワードは "
"``exc_info`` だけで、例外の情報をログに記録するかを決定するのに使います。"

#: ../../howto/logging.rst:475
msgid ""
":meth:`Logger.exception` creates a log message similar to :meth:`Logger."
"error`.  The difference is that :meth:`Logger.exception` dumps a stack trace "
"along with it.  Call this method only from an exception handler."
msgstr ""
":meth:`Logger.exception` は :meth:`Logger.error` と似たログメッセージを作成し"
"ます。違いは :meth:`Logger.exception` がスタックトレースを一緒にダンプするこ"
"とです。このメソッドは例外ハンドラからだけ呼び出すようにしてください。"

#: ../../howto/logging.rst:479
msgid ""
":meth:`Logger.log` takes a log level as an explicit argument.  This is a "
"little more verbose for logging messages than using the log level "
"convenience methods listed above, but this is how to log at custom log "
"levels."
msgstr ""
":meth:`Logger.log` はログレベルを明示的な引数として受け取ります。これは上に挙"
"げた便宜的なログレベル毎のメソッドを使うより少しコード量が多くなりますが、独"
"自のログレベルを使うことができます。"

#: ../../howto/logging.rst:483
msgid ""
":func:`getLogger` returns a reference to a logger instance with the "
"specified name if it is provided, or ``root`` if not.  The names are period-"
"separated hierarchical structures.  Multiple calls to :func:`getLogger` with "
"the same name will return a reference to the same logger object.  Loggers "
"that are further down in the hierarchical list are children of loggers "
"higher up in the list. For example, given a logger with a name of ``foo``, "
"loggers with names of ``foo.bar``, ``foo.bar.baz``, and ``foo.bam`` are all "
"descendants of ``foo``."
msgstr ""
":func:`getLogger` は、指定されればその特定の名前の、そうでなければ ``root`` "
"のロガーインスタンスへの参照を返します。ロガーの名前はピリオド区切りの階層構"
"造を表します。同じ名前で :func:`getLogger` を複数回呼び出した場合、同一のロ"
"ガーオブジェクトへの参照が返されます。階層リストを下ったロガーはリスト上位の"
"ロガーの子です。たとえば、名前が ``foo`` であるロガーがあったとして、 ``foo."
"bar``, ``foo.bar.baz``, ``foo.bam`` といった名前のロガーはすべて ``foo`` の子"
"孫になります。"

#: ../../howto/logging.rst:491
msgid ""
"Loggers have a concept of *effective level*. If a level is not explicitly "
"set on a logger, the level of its parent is used instead as its effective "
"level. If the parent has no explicit level set, *its* parent is examined, "
"and so on - all ancestors are searched until an explicitly set level is "
"found. The root logger always has an explicit level set (``WARNING`` by "
"default). When deciding whether to process an event, the effective level of "
"the logger is used to determine whether the event is passed to the logger's "
"handlers."
msgstr ""
"ロガーには、*有効レベル (effective level)* の概念があります。ロガーにレベルが"
"明示的に設定されていなければ、代わりに親のレベルがその有効レベルとして使われ"
"ます。親のレベルが設定されなければ、*その* 親のレベルが確かめられ、明示的に設"
"定されたレベルが見つかるまで祖先が探されます。ルートロガーは、必ず明示的なレ"
"ベルが設定されています (デフォルトでは ``WARNING`` です)。イベントを処理する"
"かを決定するとき、ロガーの有効レベルを使って、イベントがロガーのハンドラに渡"
"されるかが決められます。"

#: ../../howto/logging.rst:499
msgid ""
"Child loggers propagate messages up to the handlers associated with their "
"ancestor loggers. Because of this, it is unnecessary to define and configure "
"handlers for all the loggers an application uses. It is sufficient to "
"configure handlers for a top-level logger and create child loggers as "
"needed. (You can, however, turn off propagation by setting the *propagate* "
"attribute of a logger to ``False``.)"
msgstr ""
"子ロガーはメッセージを親ロガーのハンドラに伝えます。このため、アプリケーショ"
"ンが使っているすべてのロガーのためのハンドラを定義して設定する必要はありませ"
"ん。トップレベルのロガーのためのハンドラだけ設定しておいて必要に応じて子ロ"
"ガーを作成すれば十分です。(しかし、ロガーの *propagate* 属性を ``False`` に設"
"定することで、伝播を抑制できます。)"

#: ../../howto/logging.rst:510
msgid "Handlers"
msgstr "ハンドラ"

#: ../../howto/logging.rst:512
msgid ""
":class:`~logging.Handler` objects are responsible for dispatching the "
"appropriate log messages (based on the log messages' severity) to the "
"handler's specified destination.  :class:`Logger` objects can add zero or "
"more handler objects to themselves with an :meth:`~Logger.addHandler` "
"method.  As an example scenario, an application may want to send all log "
"messages to a log file, all log messages of error or higher to stdout, and "
"all messages of critical to an email address. This scenario requires three "
"individual handlers where each handler is responsible for sending messages "
"of a specific severity to a specific location."
msgstr ""
":class:`~logging.Handler` オブジェクトは適切なログメッセージを (ログメッセー"
"ジの深刻度に基づいて) ハンドラの指定された出力先に振り分けることに責任を持ち"
"ます。 :class:`Logger` オブジェクトには :meth:`~Logger.addHandler` メソッド"
"で 0 個以上のハンドラを追加することができます。例として、あるアプリケーション"
"がすべてのログメッセージをログファイルに、 error 以上のすべてのログメッセージ"
"を標準出力に、 critical のメッセージはすべてメールアドレスに、それぞれ送りた"
"いとします。この場合、 3 つの個別のハンドラがそれぞれの深刻度と宛先に応じて必"
"要になります。"

#: ../../howto/logging.rst:522
msgid ""
"The standard library includes quite a few handler types (see :ref:`useful-"
"handlers`); the tutorials use mainly :class:`StreamHandler` and :class:"
"`FileHandler` in its examples."
msgstr ""
"このライブラリには多くのハンドラが用意されています (:ref:`useful-handlers` を"
"参照してください) が、このチュートリアルでは :class:`StreamHandler` と :"
"class:`FileHandler` だけを例に取り上げます。"

#: ../../howto/logging.rst:526
msgid ""
"There are very few methods in a handler for application developers to "
"concern themselves with.  The only handler methods that seem relevant for "
"application developers who are using the built-in handler objects (that is, "
"not creating custom handlers) are the following configuration methods:"
msgstr ""
"アプリケーション開発者にとってハンドラを扱う上で気にするべきメソッドは極々限"
"られています。組み込みのハンドラオブジェクトを使う (つまり自作ハンドラを作ら"
"ない) 開発者に関係あるハンドラのメソッドは、次の設定用のメソッドだけでしょう:"

#: ../../howto/logging.rst:531
msgid ""
"The :meth:`~Handler.setLevel` method, just as in logger objects, specifies "
"the lowest severity that will be dispatched to the appropriate destination.  "
"Why are there two :meth:`~Handler.setLevel` methods?  The level set in the "
"logger determines which severity of messages it will pass to its handlers.  "
"The level set in each handler determines which messages that handler will "
"send on."
msgstr ""
":meth:`~Handler.setLevel` メソッドは、ロガーオブジェクトの場合と同様に、適切"
"な出力先に振り分けられるべき最も低い深刻度を指定します。なぜ 2 つも :meth:"
"`~Handler.setLevel` メソッドがあるのでしょうか? ロガーで設定されるレベルは、"
"付随するハンドラにどんな深刻度のメッセージを渡すか決めます。それぞれのハンド"
"ラで設定されるレベルは、そのハンドラがどのメッセージを転送するべきか決めま"
"す。"

#: ../../howto/logging.rst:537
msgid ""
":meth:`~Handler.setFormatter` selects a Formatter object for this handler to "
"use."
msgstr ""
":meth:`~Handler.setFormatter` でこのハンドラが使用する Formatter オブジェクト"
"を選択します。"

#: ../../howto/logging.rst:540
msgid ""
":meth:`~Handler.addFilter` and :meth:`~Handler.removeFilter` respectively "
"configure and deconfigure filter objects on handlers."
msgstr ""
":meth:`~Handler.addFilter` および :meth:`~Handler.removeFilter` はそれぞれハ"
"ンドラへのフィルタオブジェクトの設定と解除を行います。"

#: ../../howto/logging.rst:543
msgid ""
"Application code should not directly instantiate and use instances of :class:"
"`Handler`.  Instead, the :class:`Handler` class is a base class that defines "
"the interface that all handlers should have and establishes some default "
"behavior that child classes can use (or override)."
msgstr ""
"アプリケーションのコード中では :class:`Handler` のインスタンスを直接インスタ"
"ンス化して使ってはなりません。代わりに、 :class:`Handler` クラスはすべてのハ"
"ンドラが持つべきインターフェイスを定義する基底クラスであり、子クラスが使える "
"(もしくはオーバライドできる) いくつかのデフォルトの振る舞いを規定します。"

#: ../../howto/logging.rst:550
msgid "Formatters"
msgstr "フォーマッタ"

#: ../../howto/logging.rst:552
msgid ""
"Formatter objects configure the final order, structure, and contents of the "
"log message.  Unlike the base :class:`logging.Handler` class, application "
"code may instantiate formatter classes, although you could likely subclass "
"the formatter if your application needs special behavior.  The constructor "
"takes three optional arguments -- a message format string, a date format "
"string and a style indicator."
msgstr ""
"フォーマッタオブジェクトは最終的なログメッセージの順序、構造および内容を設定"
"します。基底クラスである :class:`logging.Handler` とは違って、アプリケーショ"
"ンのコードはフォーマッタクラスをインスタンス化しても構いません。特別な振る舞"
"いをさせたいアプリケーションではフォーマッタのサブクラスを使う可能性もありま"
"す。コンストラクタは三つのオプション引数を取ります -- メッセージのフォーマッ"
"ト文字列、日付のフォーマット文字列、スタイル標識です。"

#: ../../howto/logging.rst:561
msgid ""
"If there is no message format string, the default is to use the raw "
"message.  If there is no date format string, the default date format is:"
msgstr ""
"フォーマット文字列に何も渡さない場合は、デフォルトで行メッセージが利用されま"
"す。また、日付フォーマットに何も渡さない場合は、デフォルトで以下のフォーマッ"
"トが利用されます:"

#: ../../howto/logging.rst:564
msgid "%Y-%m-%d %H:%M:%S"
msgstr ""

#: ../../howto/logging.rst:568
msgid ""
"with the milliseconds tacked on at the end. The ``style`` is one of ``'%'``, "
"``'{'``, or ``'$'``. If one of these is not specified, then ``'%'`` will be "
"used."
msgstr ""
"時刻の末尾にはミリ秒が付きます。 ``style`` は ``'%'``, ``'{'``, または "
"``'{TX-PL-LABEL}#x27;`` のいずれかです。特に指定がなければ ``'%'`` が使われま"
"す。"

#: ../../howto/logging.rst:571
msgid ""
"If the ``style`` is ``'%'``, the message format string uses ``%(<dictionary "
"key>)s`` styled string substitution; the possible keys are documented in :"
"ref:`logrecord-attributes`. If the style is ``'{'``, the message format "
"string is assumed to be compatible with :meth:`str.format` (using keyword "
"arguments), while if the style is ``'$'`` then the message format string "
"should conform to what is expected by :meth:`string.Template.substitute`."
msgstr ""
"``style`` が ``'%'`` の場合、メッセージフォーマット文字列では "
"``%(<dictionary key>)s`` 形式の置換文字列が使われます; キーに指定できる属性名"
"は :ref:`logrecord-attributes` に文書化されています。 style が ``'{'`` の場"
"合、メッセージフォーマット文字列は (キーワード引数を使う) :meth:`str.format` "
"と互換となります。 style が ``'$'`` の場合、メッセージフォーマット文字列は :"
"meth:`string.Template.substitute` で期待されているものと一致します。"

#: ../../howto/logging.rst:578
msgid "Added the ``style`` parameter."
msgstr "``style`` パラメータが追加されました。"

#: ../../howto/logging.rst:581
msgid ""
"The following message format string will log the time in a human-readable "
"format, the severity of the message, and the contents of the message, in "
"that order::"
msgstr ""
"次のメッセージフォーマット文字列は、人が読みやすい形式の時刻、メッセージの深"
"刻度、およびメッセージの内容を、順番に出力します::"

#: ../../howto/logging.rst:585
msgid "'%(asctime)s - %(levelname)s - %(message)s'"
msgstr ""

#: ../../howto/logging.rst:587
msgid ""
"Formatters use a user-configurable function to convert the creation time of "
"a record to a tuple. By default, :func:`time.localtime` is used; to change "
"this for a particular formatter instance, set the ``converter`` attribute of "
"the instance to a function with the same signature as :func:`time.localtime` "
"or :func:`time.gmtime`. To change it for all formatters, for example if you "
"want all logging times to be shown in GMT, set the ``converter`` attribute "
"in the Formatter class (to ``time.gmtime`` for GMT display)."
msgstr ""
"フォーマッタは、ユーザが設定できる関数を使って、生成時刻をタプルに記録しま"
"す。デフォルトでは、 :func:`time.localtime` が使われます。特定のフォーマッタ"
"インスタンスに対してこれを変更するには、インスタンスの ``converter`` 属性を :"
"func:`time.localtime` や :func:`time.gmtime` と同じ署名をもつ関数に設定してく"
"ださい。すべてのフォーマッタインスタンスに対してこれを変更するには、例えば全"
"てのロギング時刻を GMT で表示するには、フォーマッタクラスの ``converter`` 属"
"性を (GMT 表示の ``time.gmtime`` に) 設定してください。"

#: ../../howto/logging.rst:597
msgid "Configuring Logging"
msgstr "ロギングの環境設定"

#: ../../howto/logging.rst:601
msgid "Programmers can configure logging in three ways:"
msgstr "プログラマは、ロギングを 3 種類の方法で設定できます:"

#: ../../howto/logging.rst:603
msgid ""
"Creating loggers, handlers, and formatters explicitly using Python code that "
"calls the configuration methods listed above."
msgstr ""
"上述の設定メソッドを呼び出す Python コードを明示的に使って、ロガー、ハンド"
"ラ、そしてフォーマッタを生成する。"

#: ../../howto/logging.rst:605
msgid ""
"Creating a logging config file and reading it using the :func:`fileConfig` "
"function."
msgstr ""
"ロギング設定ファイルを作り、それを :func:`fileConfig` 関数を使って読み込む。"

#: ../../howto/logging.rst:607
msgid ""
"Creating a dictionary of configuration information and passing it to the :"
"func:`dictConfig` function."
msgstr "設定情報の辞書を作り、それを :func:`dictConfig` 関数に渡す。"

#: ../../howto/logging.rst:610
msgid ""
"For the reference documentation on the last two options, see :ref:`logging-"
"config-api`.  The following example configures a very simple logger, a "
"console handler, and a simple formatter using Python code::"
msgstr ""
"最後の2つの選択肢については、 :ref:`logging-config-api` で解説しています。以"
"下の例では、Python コードを使って、とても簡単なロガー、コンソールハンドラ、そ"
"して簡単なフォーマッタを設定しています::"

#: ../../howto/logging.rst:614
msgid ""
"import logging\n"
"\n"
"# create logger\n"
"logger = logging.getLogger('simple_example')\n"
"logger.setLevel(logging.DEBUG)\n"
"\n"
"# create console handler and set level to debug\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.DEBUG)\n"
"\n"
"# create formatter\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - "
"%(message)s')\n"
"\n"
"# add formatter to ch\n"
"ch.setFormatter(formatter)\n"
"\n"
"# add ch to logger\n"
"logger.addHandler(ch)\n"
"\n"
"# 'application' code\n"
"logger.debug('debug message')\n"
"logger.info('info message')\n"
"logger.warning('warn message')\n"
"logger.error('error message')\n"
"logger.critical('critical message')"
msgstr ""

#: ../../howto/logging.rst:640
msgid ""
"Running this module from the command line produces the following output:"
msgstr ""
"このモジュールを実行すると、コマンドラインによって以下の出力がなされます:"

#: ../../howto/logging.rst:642
msgid ""
"$ python simple_logging_module.py\n"
"2005-03-19 15:10:26,618 - simple_example - DEBUG - debug message\n"
"2005-03-19 15:10:26,620 - simple_example - INFO - info message\n"
"2005-03-19 15:10:26,695 - simple_example - WARNING - warn message\n"
"2005-03-19 15:10:26,697 - simple_example - ERROR - error message\n"
"2005-03-19 15:10:26,773 - simple_example - CRITICAL - critical message"
msgstr ""

#: ../../howto/logging.rst:651
msgid ""
"The following Python module creates a logger, handler, and formatter nearly "
"identical to those in the example listed above, with the only difference "
"being the names of the objects::"
msgstr ""
"以下の Python モジュールは、ロガー、ハンドラ、フォーマッタをほとんど上述の例"
"と同じように生成していますが、オブジェクト名だけが異なります::"

#: ../../howto/logging.rst:655
msgid ""
"import logging\n"
"import logging.config\n"
"\n"
"logging.config.fileConfig('logging.conf')\n"
"\n"
"# create logger\n"
"logger = logging.getLogger('simpleExample')\n"
"\n"
"# 'application' code\n"
"logger.debug('debug message')\n"
"logger.info('info message')\n"
"logger.warning('warn message')\n"
"logger.error('error message')\n"
"logger.critical('critical message')"
msgstr ""

#: ../../howto/logging.rst:670
msgid "Here is the logging.conf file:"
msgstr "これが logging.conf ファイルです:"

#: ../../howto/logging.rst:672
msgid ""
"[loggers]\n"
"keys=root,simpleExample\n"
"\n"
"[handlers]\n"
"keys=consoleHandler\n"
"\n"
"[formatters]\n"
"keys=simpleFormatter\n"
"\n"
"[logger_root]\n"
"level=DEBUG\n"
"handlers=consoleHandler\n"
"\n"
"[logger_simpleExample]\n"
"level=DEBUG\n"
"handlers=consoleHandler\n"
"qualname=simpleExample\n"
"propagate=0\n"
"\n"
"[handler_consoleHandler]\n"
"class=StreamHandler\n"
"level=DEBUG\n"
"formatter=simpleFormatter\n"
"args=(sys.stdout,)\n"
"\n"
"[formatter_simpleFormatter]\n"
"format=%(asctime)s - %(name)s - %(levelname)s - %(message)s"
msgstr ""

#: ../../howto/logging.rst:702
msgid ""
"The output is nearly identical to that of the non-config-file-based example:"
msgstr "出力は、設定ファイルに基づく例とだいたい同じです:"

#: ../../howto/logging.rst:704
msgid ""
"$ python simple_logging_config.py\n"
"2005-03-19 15:38:55,977 - simpleExample - DEBUG - debug message\n"
"2005-03-19 15:38:55,979 - simpleExample - INFO - info message\n"
"2005-03-19 15:38:56,054 - simpleExample - WARNING - warn message\n"
"2005-03-19 15:38:56,055 - simpleExample - ERROR - error message\n"
"2005-03-19 15:38:56,130 - simpleExample - CRITICAL - critical message"
msgstr ""

#: ../../howto/logging.rst:713
msgid ""
"You can see that the config file approach has a few advantages over the "
"Python code approach, mainly separation of configuration and code and the "
"ability of noncoders to easily modify the logging properties."
msgstr ""
"この通り、設定ファイルの方法は、主に設定とコードが分かれ、非コーダがロギング"
"プロパティを変えやすくなるという点で、Python コードの方法より少し優れていま"
"す。"

#: ../../howto/logging.rst:717
msgid ""
"The :func:`fileConfig` function takes a default parameter, "
"``disable_existing_loggers``, which defaults to ``True`` for reasons of "
"backward compatibility. This may or may not be what you want, since it will "
"cause any non-root loggers existing before the :func:`fileConfig` call to be "
"disabled unless they (or an ancestor) are explicitly named in the "
"configuration. Please refer to the reference documentation for more "
"information, and specify ``False`` for this parameter if you wish."
msgstr ""
":func:`fileConfig` 関数はデフォルト引数 ``disable_existing_loggers`` を取り、"
"後方互換性のためにデフォルト値は ``True`` になっています。\n"
"これはあなたの望むものかもしれませんし、そうでないかもしれません。というの"
"は、設定で明示的に指定したクラス (もしくはその親クラス) を除いて、 :func:"
"`fileConfig` が呼び出される前に存在した非ルートロガーを無効化してしまうからで"
"す。\n"
"より詳細なことはリファレンスを参照し、望むならこの引数に ``False`` を指定して"
"ください。"

#: ../../howto/logging.rst:725
msgid ""
"The dictionary passed to :func:`dictConfig` can also specify a Boolean value "
"with key ``disable_existing_loggers``, which if not specified explicitly in "
"the dictionary also defaults to being interpreted as ``True``. This leads to "
"the logger-disabling behaviour described above, which may not be what you "
"want - in which case, provide the key explicitly with a value of ``False``."
msgstr ""
":func:`dictConfig` に渡される辞書でも、キー ``disable_existing_loggers`` で真"
"偽値を指定することができ、辞書の中で明示的に指定しなかった場合はデフォルトで "
"``True`` と解釈されます。これは上で説明したロガー無効化につながりますが、それ"
"を望まないこともあるでしょう - その場合は、明示的にキーを与えて値を "
"``False`` にしてください。"

#: ../../howto/logging.rst:735
msgid ""
"Note that the class names referenced in config files need to be either "
"relative to the logging module, or absolute values which can be resolved "
"using normal import mechanisms. Thus, you could use either :class:`~logging."
"handlers.WatchedFileHandler` (relative to the logging module) or ``mypackage."
"mymodule.MyHandler`` (for a class defined in package ``mypackage`` and "
"module ``mymodule``, where ``mypackage`` is available on the Python import "
"path)."
msgstr ""
"なお、設定ファイルで参照されるクラス名は、logging モジュールに対して相対であ"
"るか、通常のインポート機構を使って解決される絶対である値でなければなりませ"
"ん。従って、(logging モジュールに相対な) :class:`~logging.handlers."
"WatchedFileHandler` または (Python インポートパスとして ``mypackage`` が使え"
"るとき、パッケージ ``mypackage`` のモジュール ``mymodule`` で定義されたクラス"
"に) ``mypackage.mymodule.MyHandler`` のどちらかが使えます。"

#: ../../howto/logging.rst:743
msgid ""
"In Python 3.2, a new means of configuring logging has been introduced, using "
"dictionaries to hold configuration information. This provides a superset of "
"the functionality of the config-file-based approach outlined above, and is "
"the recommended configuration method for new applications and deployments. "
"Because a Python dictionary is used to hold configuration information, and "
"since you can populate that dictionary using different means, you have more "
"options for configuration. For example, you can use a configuration file in "
"JSON format, or, if you have access to YAML processing functionality, a file "
"in YAML format, to populate the configuration dictionary. Or, of course, you "
"can construct the dictionary in Python code, receive it in pickled form over "
"a socket, or use whatever approach makes sense for your application."
msgstr ""
"Python 3.2 では、ロギングを設定するのに新しく、辞書に設定情報を持たせる手段が"
"導入されました。これは、上で概説した設定ファイルに基づく方法による機能の上位"
"版を提供し、新しいアプリケーションやデプロイにはこのメソッドが推奨されます。"
"Python の辞書を使って設定情報を保持し、辞書は他の用途にも使えるので、設定の選"
"択肢が広がります。例えば、JSON フォーマットの設定ファイルや、YAML 処理機能が"
"使えれば YAML フォーマットのファイルを使って、設定辞書を構成できます。また、"
"もちろん、Python コードで辞書を構成し、ソケットを通して pickle 化された形式を"
"受け取るなど、アプリケーションで意味があるいかなるやり方でも使えます。"

#: ../../howto/logging.rst:755
msgid ""
"Here's an example of the same configuration as above, in YAML format for the "
"new dictionary-based approach:"
msgstr ""
"以下は、上記と同じ設定を辞書ベースの新しい手法で記載した YAML 形式の例です:"

#: ../../howto/logging.rst:758
msgid ""
"version: 1\n"
"formatters:\n"
"  simple:\n"
"    format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n"
"handlers:\n"
"  console:\n"
"    class: logging.StreamHandler\n"
"    level: DEBUG\n"
"    formatter: simple\n"
"    stream: ext://sys.stdout\n"
"loggers:\n"
"  simpleExample:\n"
"    level: DEBUG\n"
"    handlers: [console]\n"
"    propagate: no\n"
"root:\n"
"  level: DEBUG\n"
"  handlers: [console]"
msgstr ""

#: ../../howto/logging.rst:779
msgid ""
"For more information about logging using a dictionary, see :ref:`logging-"
"config-api`."
msgstr ""
"辞書を使ったロギングについて詳細は、 :ref:`logging-config-api` を参照してくだ"
"さい。"

#: ../../howto/logging.rst:783
msgid "What happens if no configuration is provided"
msgstr "環境設定が与えられないとどうなるか"

#: ../../howto/logging.rst:785
msgid ""
"If no logging configuration is provided, it is possible to have a situation "
"where a logging event needs to be output, but no handlers can be found to "
"output the event."
msgstr ""
"ロギング環境設定を与えられないと、ロギングイベントを出力しなければならないの"
"に、イベントを出力するハンドラが見つからないことがあります。"

#: ../../howto/logging.rst:789
msgid ""
"The event is output using a 'handler of last resort', stored in :data:"
"`lastResort`. This internal handler is not associated with any logger, and "
"acts like a :class:`~logging.StreamHandler` which writes the event "
"description message to the current value of ``sys.stderr`` (therefore "
"respecting any redirections which may be in effect). No formatting is done "
"on the message - just the bare event description message is printed. The "
"handler's level is set to ``WARNING``, so all events at this and greater "
"severities will be output."
msgstr ""
"イベントは、 :data:`lastResort` に格納された「最終手段ハンドラ」を使用して出"
"力されます。この内部的なハンドラはどんなロガーにも関係しておらず、イベント記"
"述メッセージを現在の ``sys.stderr`` に書く :class:`~logging.StreamHandler` の"
"ように動作します (したがって、あらゆるリダイレクトの効果が反映されます)。メッ"
"セージに対してフォーマットは行われません。イベント記述メッセージだけがそのま"
"ま表示されます。ハンドラのレベルは ``WARNING`` にセットされ、重大度がこれ以上"
"のすべてのイベントが出力されます。"

#: ../../howto/logging.rst:800
msgid "For versions of Python prior to 3.2, the behaviour is as follows:"
msgstr "Python 3.2 より前のバージョンでは、振る舞いは以下の通りです:"

#: ../../howto/logging.rst:802
msgid ""
"If :data:`raiseExceptions` is ``False`` (production mode), the event is "
"silently dropped."
msgstr ""
":data:`raiseExceptions` が ``False`` (製品モード) なら、イベントは黙って捨て"
"られます。"

#: ../../howto/logging.rst:805
msgid ""
"If :data:`raiseExceptions` is ``True`` (development mode), a message 'No "
"handlers could be found for logger X.Y.Z' is printed once."
msgstr ""
":data:`raiseExceptions` が ``True`` (開発モード) なら、メッセージ 'No "
"handlers could be found for logger X.Y.Z' が一度表示されます。"

#: ../../howto/logging.rst:808
msgid ""
"To obtain the pre-3.2 behaviour, :data:`lastResort` can be set to ``None``."
msgstr ""
"3.2 より前の動作にするために、:data:`lastResort` を ``None`` に設定することも"
"できます。"

#: ../../howto/logging.rst:814
msgid "Configuring Logging for a Library"
msgstr "ライブラリのためのロギングの設定"

#: ../../howto/logging.rst:816
msgid ""
"When developing a library which uses logging, you should take care to "
"document how the library uses logging - for example, the names of loggers "
"used. Some consideration also needs to be given to its logging "
"configuration. If the using application does not use logging, and library "
"code makes logging calls, then (as described in the previous section) events "
"of severity ``WARNING`` and greater will be printed to ``sys.stderr``. This "
"is regarded as the best default behaviour."
msgstr ""
"ロギングを使うライブラリを開発するときは、ライブラリがどのようにロギングを使"
"うのか、例えば使われているロガーの名前などを、ドキュメントにしておくべきで"
"す。ロギングの設定については、いくつか考えておくべきこともあります。使ってい"
"るアプリケーションがロギングを使っていなくて、ライブラリコードがロギングを呼"
"び出すと、(前の節で解説したように) 重大度 ``WARNING`` 以上のイベントが、"
"``sys.stderr`` に表示されます。これが最高のデフォルトの振る舞いと見なされま"
"す。"

#: ../../howto/logging.rst:824
msgid ""
"If for some reason you *don't* want these messages printed in the absence of "
"any logging configuration, you can attach a do-nothing handler to the top-"
"level logger for your library. This avoids the message being printed, since "
"a handler will always be found for the library's events: it just doesn't "
"produce any output. If the library user configures logging for application "
"use, presumably that configuration will add some handlers, and if levels are "
"suitably configured then logging calls made in library code will send output "
"to those handlers, as normal."
msgstr ""
"何らかの理由でロギング設定がなされていないときにメッセージを表示 *させたくな"
"い* のであれば、ライブラリのトップレベルのロガーに何もしないハンドラを取り付"
"けられます。ライブラリの全てのイベントに対してそのハンドラが見つかるので、"
"メッセージが表示されなくなります。ライブラリのユーザーがアプリケーションのた"
"めにロギングを設定する場合、おそらくハンドラが追加され、そしてレベルが適切に"
"設定された場合に、ライブラリコード内でのロギングの呼び出しは通常通りそのハン"
"ドラに出力を送るようになります。"

#: ../../howto/logging.rst:833
msgid ""
"A do-nothing handler is included in the logging package: :class:`~logging."
"NullHandler` (since Python 3.1). An instance of this handler could be added "
"to the top-level logger of the logging namespace used by the library (*if* "
"you want to prevent your library's logged events being output to ``sys."
"stderr`` in the absence of logging configuration). If all logging by a "
"library *foo* is done using loggers with names matching 'foo.x', 'foo.x.y', "
"etc. then the code::"
msgstr ""
"何もしないハンドラ :class:`~logging.NullHandler` (Python 3.1 以降) は、 "
"logging パッケージに含まれます。このハンドラのインスタンスを、 (ロギング設定"
"がなされていないときにライブラリのログイベントを ``sys.stderr`` に出力させた"
"く *ないなら*) ライブラリの名前空間で使われるトップレベルロガーに取り付けられ"
"ます。ライブラリ *foo* によるすべてのロギングが、 'foo.x', 'foo.x.y' その他に"
"該当する名前のロガーによってなされるなら::"

#: ../../howto/logging.rst:841
msgid ""
"import logging\n"
"logging.getLogger('foo').addHandler(logging.NullHandler())"
msgstr ""

#: ../../howto/logging.rst:844
msgid ""
"should have the desired effect. If an organisation produces a number of "
"libraries, then the logger name specified can be 'orgname.foo' rather than "
"just 'foo'."
msgstr ""
"とすれば望んだ効果が得られるでしょう。組織が複数のライブラリを作り出すなら、"
"指定されるロガー名は単に 'foo' ではなく、'orgname.foo' になります。"

#: ../../howto/logging.rst:848
msgid ""
"It is strongly advised that you *do not log to the root logger* in your "
"library. Instead, use a logger with a unique and easily identifiable name, "
"such as the ``__name__`` for your library's top-level package or module. "
"Logging to the root logger will make it difficult or impossible for the "
"application developer to configure the logging verbosity or handlers of your "
"library as they wish."
msgstr ""
"あなたのライブラリから *ルートロガーへ直接ログを記録しない* ことを強く推奨し"
"ます。代わりに、あなたのライブラリのトップレベルまたはモジュールレベルの "
"``__name__`` を使うなど、固有で、簡単に識別できる名前を持ったロガーを使ってく"
"ださい。ルートロガーに直接ログを記録することにより、あなたのライブラリを利用"
"するアプリケーション開発者が、ロギングの詳細度 (verbosity) やハンドラを望みの"
"とおりに設定することを困難にしたり、不可能にしてしまいます。"

#: ../../howto/logging.rst:855
msgid ""
"It is strongly advised that you *do not add any handlers other than* :class:"
"`~logging.NullHandler` *to your library's loggers*. This is because the "
"configuration of handlers is the prerogative of the application developer "
"who uses your library. The application developer knows their target audience "
"and what handlers are most appropriate for their application: if you add "
"handlers 'under the hood', you might well interfere with their ability to "
"carry out unit tests and deliver logs which suit their requirements."
msgstr ""
"*ライブラリのロガーには、* :class:`~logging.NullHandler` *以外のハンドラを追"
"加しない* ことを強く推奨します。これは、ハンドラの設定が、あなたのライブラリ"
"を使うアプリケーション開発者にも伝播するからです。アプリケーション開発者は、"
"対象となる聴衆と、そのアプリケーションにどのハンドラが最も適しているかを知っ"
"ています。ハンドラを 'ボンネットの中で' 加えてしまうと、ユニットテストをして"
"必要に応じたログを送達する能力に干渉しかねません。"

#: ../../howto/logging.rst:866
msgid "Logging Levels"
msgstr "ロギングレベル"

#: ../../howto/logging.rst:868
msgid ""
"The numeric values of logging levels are given in the following table. These "
"are primarily of interest if you want to define your own levels, and need "
"them to have specific values relative to the predefined levels. If you "
"define a level with the same numeric value, it overwrites the predefined "
"value; the predefined name is lost."
msgstr ""
"ログレベルの数値は以下の表のように与えられています。これらは基本的に自分でレ"
"ベルを定義したい人のためのもので、定義するレベルを既存のレベルの間に位置づけ"
"るためには具体的な値が必要になります。もし数値が他のレベルと同じだったら、既"
"存の値は上書きされその名前は失われます。"

#: ../../howto/logging.rst:875
msgid "Numeric value"
msgstr "数値"

#: ../../howto/logging.rst:877
msgid "50"
msgstr "50"

#: ../../howto/logging.rst:879
msgid "40"
msgstr "40"

#: ../../howto/logging.rst:881
msgid "30"
msgstr "30"

#: ../../howto/logging.rst:883
msgid "20"
msgstr "20"

#: ../../howto/logging.rst:885
msgid "10"
msgstr "10"

#: ../../howto/logging.rst:887
msgid "``NOTSET``"
msgstr "``NOTSET``"

#: ../../howto/logging.rst:887
msgid "0"
msgstr "0"

#: ../../howto/logging.rst:890
msgid ""
"Levels can also be associated with loggers, being set either by the "
"developer or through loading a saved logging configuration. When a logging "
"method is called on a logger, the logger compares its own level with the "
"level associated with the method call. If the logger's level is higher than "
"the method call's, no logging message is actually generated. This is the "
"basic mechanism controlling the verbosity of logging output."
msgstr ""
"レベルはロガーに関連付けることもでき、開発者が設定することも、保存されたログ"
"記録設定を読み込む際に設定することもできます。ロガーに対してログ記録メソッド"
"が呼び出されると、ロガーは自らのレベルとメソッド呼び出しに関連付けられたレベ"
"ルを比較します。ロガーのレベルがメソッド呼び出しのレベルよりも高い場合、実際"
"のログメッセージは生成されません。これはログ出力の冗長性を制御するための基本"
"的なメカニズムです。"

#: ../../howto/logging.rst:897
msgid ""
"Logging messages are encoded as instances of the :class:`~logging.LogRecord` "
"class. When a logger decides to actually log an event, a :class:`~logging."
"LogRecord` instance is created from the logging message."
msgstr ""
"ログ記録されるメッセージは :class:`~logging.LogRecord` クラスのインスタンスと"
"してエンコードされます。ロガーがあるイベントを実際にログ出力すると決定した場"
"合、ログメッセージから :class:`~logging.LogRecord` インスタンスが生成されま"
"す。"

#: ../../howto/logging.rst:901
msgid ""
"Logging messages are subjected to a dispatch mechanism through the use of :"
"dfn:`handlers`, which are instances of subclasses of the :class:`Handler` "
"class. Handlers are responsible for ensuring that a logged message (in the "
"form of a :class:`LogRecord`) ends up in a particular location (or set of "
"locations) which is useful for the target audience for that message (such as "
"end users, support desk staff, system administrators, developers). Handlers "
"are passed :class:`LogRecord` instances intended for particular "
"destinations. Each logger can have zero, one or more handlers associated "
"with it (via the :meth:`~Logger.addHandler` method of :class:`Logger`). In "
"addition to any handlers directly associated with a logger, *all handlers "
"associated with all ancestors of the logger* are called to dispatch the "
"message (unless the *propagate* flag for a logger is set to a false value, "
"at which point the passing to ancestor handlers stops)."
msgstr ""
"ログ記録されるメッセージは、ハンドラ (:dfn:`handlers`) を通してディスパッチ機"
"構にかけられます。ハンドラは :class:`Handler` クラスのサブクラスのインスタン"
"スで、ログ記録された (:class:`LogRecord` 形式の) メッセージが、そのメッセージ"
"の伝達対象となる相手 (エンドユーザ、サポートデスクのスタッフ、システム管理"
"者、開発者) に行き着くようにする役割を持ちます。ハンドラには特定の出力先を意"
"図された :class:`LogRecord` インスタンスが渡されます。各ロガーは 0 個以上のハ"
"ンドラを (:class:`Logger` の :meth:`~Logger.addHandler` メソッド) で関連付け"
"ることができます。ロガーに直接関連付けられたハンドラに加えて、\\ *ロガーの上"
"位にあるロガーすべてに関連付けられたハンドラ* がメッセージを処理する際に呼び"
"出されます (ただしロガーの *propagate* フラグが false 値にセットされている場"
"合を除きます。その場合は、祖先ハンドラへの伝搬はそこで止まります)。"

#: ../../howto/logging.rst:915
msgid ""
"Just as for loggers, handlers can have levels associated with them. A "
"handler's level acts as a filter in the same way as a logger's level does. "
"If a handler decides to actually dispatch an event, the :meth:`~Handler."
"emit` method is used to send the message to its destination. Most user-"
"defined subclasses of :class:`Handler` will need to override this :meth:"
"`~Handler.emit`."
msgstr ""
"ロガーと同様に、ハンドラは関連付けられたレベルを持つことができます。ハンドラ"
"のレベルはロガーのレベルと同じ方法で、フィルタとして働きます。ハンドラがある"
"イベントを実際に処理すると決定した場合、 :meth:`~Handler.emit` メソッドが使わ"
"れ、メッセージを出力先に送信します。ほとんどのユーザ定義の :class:`Handler` "
"のサブクラスで、この :meth:`~Handler.emit` をオーバライドする必要があるでしょ"
"う。"

#: ../../howto/logging.rst:924
msgid "Custom Levels"
msgstr "カスタムレベル"

#: ../../howto/logging.rst:926
msgid ""
"Defining your own levels is possible, but should not be necessary, as the "
"existing levels have been chosen on the basis of practical experience. "
"However, if you are convinced that you need custom levels, great care should "
"be exercised when doing this, and it is possibly *a very bad idea to define "
"custom levels if you are developing a library*. That's because if multiple "
"library authors all define their own custom levels, there is a chance that "
"the logging output from such multiple libraries used together will be "
"difficult for the using developer to control and/or interpret, because a "
"given numeric value might mean different things for different libraries."
msgstr ""
"独自のレベルを定義することは可能ですが、必須ではなく、実経験上は既存のレベル"
"が選ばれます。しかし、カスタムレベルが必要だと確信するなら、レベルの定義には"
"多大な注意を払うべきで、*ライブラリの開発の際、カスタムレベルを定義することは"
"とても悪いアイデア* になり得ます。これは、複数のライブラリの作者がみな独自の"
"カスタムレベルを定義すると、与えられた数値が異なるライブラリで異なる意味にな"
"りえるため、開発者がこれを制御または解釈するのが難しくなるからです。"

#: ../../howto/logging.rst:939
msgid "Useful Handlers"
msgstr "便利なハンドラ"

#: ../../howto/logging.rst:941
msgid ""
"In addition to the base :class:`Handler` class, many useful subclasses are "
"provided:"
msgstr ""
"基底の :class:`Handler` クラスに加え、多くの便利なサブクラスが提供されていま"
"す:"

#: ../../howto/logging.rst:944
msgid ""
":class:`StreamHandler` instances send messages to streams (file-like "
"objects)."
msgstr ""
":class:`StreamHandler` インスタンスは、メッセージをストリーム (ファイル風オブ"
"ジェクト) に送ります。"

#: ../../howto/logging.rst:947
msgid ":class:`FileHandler` instances send messages to disk files."
msgstr ""
":class:`FileHandler` インスタンスは、メッセージをディスクファイルに送ります。"

#: ../../howto/logging.rst:949
msgid ""
":class:`~handlers.BaseRotatingHandler` is the base class for handlers that "
"rotate log files at a certain point. It is not meant to be  instantiated "
"directly. Instead, use :class:`~handlers.RotatingFileHandler` or :class:"
"`~handlers.TimedRotatingFileHandler`."
msgstr ""
":class:`~handlers.BaseRotatingHandler` は、ある地点でログファイルを循環させる"
"ハンドラの基底クラスです。これを直接インスタンス化することは意図されていませ"
"ん。代わりに、 :class:`~handlers.RotatingFileHandler` や :class:`~handlers."
"TimedRotatingFileHandler` を使用してください。"

#: ../../howto/logging.rst:954
msgid ""
":class:`~handlers.RotatingFileHandler` instances send messages to disk "
"files, with support for maximum log file sizes and log file rotation."
msgstr ""
":class:`~handlers.RotatingFileHandler` インスタンスは、メッセージをディスク"
"ファイルに送り、最大ログファイル数とログファイル循環をサポートします。"

#: ../../howto/logging.rst:957
msgid ""
":class:`~handlers.TimedRotatingFileHandler` instances send messages to disk "
"files, rotating the log file at certain timed intervals."
msgstr ""
":class:`~handlers.TimedRotatingFileHandler` インスタンスは、メッセージをディ"
"スクファイルに送り、ログファイルを特定時間のインターバルで循環します。"

#: ../../howto/logging.rst:960
msgid ""
":class:`~handlers.SocketHandler` instances send messages to TCP/IP sockets. "
"Since 3.4, Unix domain sockets are also supported."
msgstr ""
":class:`~handlers.SocketHandler` インスタンスは、 TCP/IP ソケットにメッセージ"
"を送ります。バージョン3.4　から、 Unixドメインソケットもサポートされます。"

#: ../../howto/logging.rst:963
msgid ""
":class:`~handlers.DatagramHandler` instances send messages to UDP sockets. "
"Since 3.4, Unix domain sockets are also supported."
msgstr ""
":class:`~handlers.DatagramHandler` インスタンスは UDP ソケットにメッセージを"
"送ります。バージョン 3.4 から、Unix ドメインソケットもサポートされます。"

#: ../../howto/logging.rst:966
msgid ""
":class:`~handlers.SMTPHandler` instances send messages to a designated email "
"address."
msgstr ""
":class:`~handlers.SMTPHandler` インスタンスは、メッセージを指示された email "
"アドレスに送ります。"

#: ../../howto/logging.rst:969
msgid ""
":class:`~handlers.SysLogHandler` instances send messages to a Unix syslog "
"daemon, possibly on a remote machine."
msgstr ""
":class:`~handlers.SysLogHandler` インスタンスは、メッセージを、必要ならばリ"
"モートマシンの、Unix syslog daemon に送ります。"

#: ../../howto/logging.rst:972
msgid ""
":class:`~handlers.NTEventLogHandler` instances send messages to a Windows "
"NT/2000/XP event log."
msgstr ""
":class:`~handlers.NTEventLogHandler` インスタンスは、メッセージを Windows "
"NT/2000/XP イベントログに送ります。"

#: ../../howto/logging.rst:975
msgid ""
":class:`~handlers.MemoryHandler` instances send messages to a buffer in "
"memory, which is flushed whenever specific criteria are met."
msgstr ""
":class:`~handlers.MemoryHandler` インスタンスは、メッセージを、特定の基準が満"
"たされる度に流される、メモリ中のバッファに送ります。"

#: ../../howto/logging.rst:978
msgid ""
":class:`~handlers.HTTPHandler` instances send messages to an HTTP server "
"using either ``GET`` or ``POST`` semantics."
msgstr ""
":class:`~handlers.HTTPHandler` インスタンスは、メッセージを、 ``GET`` または "
"``POST`` セマンティクスを使って、HTTP サーバに送ります。"

#: ../../howto/logging.rst:981
msgid ""
":class:`~handlers.WatchedFileHandler` instances watch the file they are "
"logging to. If the file changes, it is closed and reopened using the file "
"name. This handler is only useful on Unix-like systems; Windows does not "
"support the underlying mechanism used."
msgstr ""
":class:`~handlers.WatchedFileHandler` インスタンスは、ロギングする先のファイ"
"ルを監視します。ファイルが変更されると、そのファイルは閉じられ、ファイル名を"
"使って再び開かれます。このハンドラは Unix 系のシステムにのみ便利です。"
"Windows は、使われている基の機構をサポートしていません。"

#: ../../howto/logging.rst:986
msgid ""
":class:`~handlers.QueueHandler` instances send messages to a queue, such as "
"those implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
":class:`~handlers.QueueHandler` インスタンスは、 :mod:`queue` モジュールや :"
"mod:`multiprocessing` モジュールなどで実装されているキューにメッセージを送り"
"ます。"

#: ../../howto/logging.rst:989
msgid ""
":class:`NullHandler` instances do nothing with error messages. They are used "
"by library developers who want to use logging, but want to avoid the 'No "
"handlers could be found for logger *XXX*' message which can be displayed if "
"the library user has not configured logging. See :ref:`library-config` for "
"more information."
msgstr ""
":class:`NullHandler` インスタンスは、エラーメッセージについて何もしません。こ"
"のクラスはライブラリ開発者が、 logging は使いたいが、ライブラリのユーザーが "
"logging の設定をしなかったときに表示されうる 'No handlers could be found for "
"logger *XXX*' のようなメッセージを回避したいときに使います。詳しくは、 :ref:"
"`library-config` を参照してください。"

#: ../../howto/logging.rst:995
msgid "The :class:`NullHandler` class."
msgstr ":class:`NullHandler` クラス。"

#: ../../howto/logging.rst:998
msgid "The :class:`~handlers.QueueHandler` class."
msgstr ":class:`~handlers.QueueHandler` クラス。"

#: ../../howto/logging.rst:1001
msgid ""
"The :class:`NullHandler`, :class:`StreamHandler` and :class:`FileHandler` "
"classes are defined in the core logging package. The other handlers are "
"defined in a sub-module, :mod:`logging.handlers`. (There is also another sub-"
"module, :mod:`logging.config`, for configuration functionality.)"
msgstr ""
"コア logging パッケージで、 :class:`NullHandler`, :class:`StreamHandler` およ"
"び :class:`FileHandler` クラスが定義されています。その他のハンドラは、サブモ"
"ジュールの :mod:`logging.handlers` で定義されています。(環境設定機能のための"
"サブモジュール、 :mod:`logging.config` もあります。)"

#: ../../howto/logging.rst:1006
msgid ""
"Logged messages are formatted for presentation through instances of the :"
"class:`Formatter` class. They are initialized with a format string suitable "
"for use with the % operator and a dictionary."
msgstr ""
"ログメッセージは、 :class:`Formatter` クラスのインスタンスを通してフォーマッ"
"ト化してから表示されます。このインスタンスは、 % 演算子と辞書で使うのに適切な"
"フォーマット文字列で初期化されます。"

#: ../../howto/logging.rst:1010
msgid ""
"For formatting multiple messages in a batch, instances of :class:"
"`BufferingFormatter` can be used. In addition to the format string (which is "
"applied to each message in the batch), there is provision for header and "
"trailer format strings."
msgstr ""
"複数のメッセージを一括してフォーマット化するには、 :class:"
"`BufferingFormatter` が使えます。(一連の文字列のそれぞれに適用される) フォー"
"マット文字列に加え、ヘッダとトレーラフォーマット文字列も提供されています。"

#: ../../howto/logging.rst:1015
msgid ""
"When filtering based on logger level and/or handler level is not enough, "
"instances of :class:`Filter` can be added to both :class:`Logger` and :class:"
"`Handler` instances (through their :meth:`~Handler.addFilter` method). "
"Before deciding to process a message further, both loggers and handlers "
"consult all their filters for permission. If any filter returns a false "
"value, the message is not processed further."
msgstr ""
"ロガーレベルおよび/またはハンドラレベルに基づくフィルタリングで十分でなけれ"
"ば、 :class:`Filter` のインスタンスを :class:`Logger` と :class:`Handler` イ"
"ンスタンスの両方に (:meth:`~Handler.addFilter` を通して) 加えることができま"
"す。メッセージの処理を続ける前に、ロガーもハンドラも、全てのフィルタに許可を"
"求めます。フィルタのいずれかが偽値を返したら、メッセージの処理は続けられませ"
"ん。"

#: ../../howto/logging.rst:1022
msgid ""
"The basic :class:`Filter` functionality allows filtering by specific logger "
"name. If this feature is used, messages sent to the named logger and its "
"children are allowed through the filter, and all others dropped."
msgstr ""
"基本の :class:`Filter` 機能では、特定のロガー名でのフィルタリングをできます。"
"この機能が使われると、指名されたロガーに送られたメッセージとその子だけがフィ"
"ルタを通り、その他は落とされます。"

#: ../../howto/logging.rst:1030
msgid "Exceptions raised during logging"
msgstr "ログ記録中に発生する例外"

#: ../../howto/logging.rst:1032
msgid ""
"The logging package is designed to swallow exceptions which occur while "
"logging in production. This is so that errors which occur while handling "
"logging events - such as logging misconfiguration, network or other similar "
"errors - do not cause the application using logging to terminate prematurely."
msgstr ""
"logging パッケージは、ログを生成している間に起こる例外を飲み込むように設計さ"
"れています。これは、ログ記録イベントを扱っている間に発生するエラー (ログ記録"
"の設定ミス、ネットワークまたは他の同様のエラー) によってログ記録を使用するア"
"プリケーションが早期に終了しないようにするためです。"

#: ../../howto/logging.rst:1037
msgid ""
":class:`SystemExit` and :class:`KeyboardInterrupt` exceptions are never "
"swallowed. Other exceptions which occur during the :meth:`~Handler.emit` "
"method of a :class:`Handler` subclass are passed to its :meth:`~Handler."
"handleError` method."
msgstr ""
":class:`SystemExit` と :class:`KeyboardInterrupt` 例外は決して飲み込まれませ"
"ん。 :class:`Handler` サブクラスの :meth:`~Handler.emit` メソッドの間に起こる"
"他の例外は、 :meth:`~Handler.handleError` メソッドに渡されます。"

#: ../../howto/logging.rst:1042
msgid ""
"The default implementation of :meth:`~Handler.handleError` in :class:"
"`Handler` checks to see if a module-level variable, :data:`raiseExceptions`, "
"is set. If set, a traceback is printed to :data:`sys.stderr`. If not set, "
"the exception is swallowed."
msgstr ""
":class:`Handler` の :meth:`~Handler.handleError` のデフォルト実装は、モジュー"
"ルレベル変数 :data:`raiseExceptions` が設定されているかどうかチェックします。"
"設定されているなら、トレースバックが :data:`sys.stderr` に出力されます。設定"
"されていないなら、例外は飲み込まれます。"

#: ../../howto/logging.rst:1048
msgid ""
"The default value of :data:`raiseExceptions` is ``True``. This is because "
"during development, you typically want to be notified of any exceptions that "
"occur. It's advised that you set :data:`raiseExceptions` to ``False`` for "
"production usage."
msgstr ""
":data:`raiseExceptions` のデフォルト値は ``True`` です。これは、開発の間に起"
"こるどんな例外についても通常は通知してほしいからです。実運用環境では :data:"
"`raiseExceptions` を ``False`` に設定することをお勧めします。"

#: ../../howto/logging.rst:1058
msgid "Using arbitrary objects as messages"
msgstr "任意のオブジェクトをメッセージに使用する"

#: ../../howto/logging.rst:1060
msgid ""
"In the preceding sections and examples, it has been assumed that the message "
"passed when logging the event is a string. However, this is not the only "
"possibility. You can pass an arbitrary object as a message, and its :meth:"
"`~object.__str__` method will be called when the logging system needs to "
"convert it to a string representation. In fact, if you want to, you can "
"avoid computing a string representation altogether - for example, the :class:"
"`~handlers.SocketHandler` emits an event by pickling it and sending it over "
"the wire."
msgstr ""
"前の節とそこで挙げた例では、イベントを記録するときに渡されたメッセージが文字"
"列であると仮定していました。しかし、これは唯一の可能性ではありません。メッ"
"セージとして任意のオブジェクトを渡すことができます。そして、ロギングシステム"
"がそのオブジェクトを文字列表現に変換する必要があるとき、オブジェクトの :meth:"
"`~object.__str__` メソッドが呼び出されます。実際、そうしたければ、文字列表現"
"を計算することを完全に避けることができます - 例えば、 :class:`~handlers."
"SocketHandler` は、イベントを pickle してネットワーク上で送信することでログ出"
"力します。"

#: ../../howto/logging.rst:1071
msgid "Optimization"
msgstr "最適化"

#: ../../howto/logging.rst:1073
msgid ""
"Formatting of message arguments is deferred until it cannot be avoided. "
"However, computing the arguments passed to the logging method can also be "
"expensive, and you may want to avoid doing it if the logger will just throw "
"away your event. To decide what to do, you can call the :meth:`~Logger."
"isEnabledFor` method which takes a level argument and returns true if the "
"event would be created by the Logger for that level of call. You can write "
"code like this::"
msgstr ""
"message 引数の整形は、必要になるまで延期されます。しかしながら、ログ記録メ"
"ソッドに渡す引数を計算するだけでもコストがかかる場合があります。ロガーが単に"
"イベントを捨てるなら、その計算を避けたいと考えるかもしれません。どうするかを"
"決定するために :meth:`~Logger.isEnabledFor` メソッドを呼ぶことができます。こ"
"のメソッドは引数にレベルを取って、そのレベルの呼び出しに対して Logger がイベ"
"ントを生成するなら true を返します。このようにコードを書くことができます::"

#: ../../howto/logging.rst:1081
msgid ""
"if logger.isEnabledFor(logging.DEBUG):\n"
"    logger.debug('Message with %s, %s', expensive_func1(),\n"
"                                        expensive_func2())"
msgstr ""

#: ../../howto/logging.rst:1085
msgid ""
"so that if the logger's threshold is set above ``DEBUG``, the calls to "
"``expensive_func1`` and ``expensive_func2`` are never made."
msgstr ""
"このようにすると、ロガーの閾値が ``DEBUG`` より上に設定されている場合、 "
"``expensive_func1`` と ``expensive_func2`` の呼び出しは行われません。"

#: ../../howto/logging.rst:1088
msgid ""
"In some cases, :meth:`~Logger.isEnabledFor` can itself be more expensive "
"than you'd like (e.g. for deeply nested loggers where an explicit level is "
"only set high up in the logger hierarchy). In such cases (or if you want to "
"avoid calling a method in tight loops), you can cache the result of a call "
"to :meth:`~Logger.isEnabledFor` in a local or instance variable, and use "
"that instead of calling the method each time. Such a cached value would only "
"need to be recomputed when the logging configuration changes dynamically "
"while the application is running (which is not all that common)."
msgstr ""
"ある種のケースでは、 :meth:`~Logger.isEnabledFor` それ自身があなたが期待する"
"よりも高価になる場合があります(たとえば明示的なレベル指定がロガー階層の上位の"
"みに設定されていて、ロガーが深くネストされているような場合です)。そのような"
"ケース(あるいはタイトなループ内でメソッド呼び出しを避けたい場合)は、 :meth:"
"`~Logger.isEnabledFor` 結果をローカルにもしくはインスタンス変数としてキャッ"
"シュし、メソッドを毎回呼び出すかわりに使えば良いです。そのようなキャッシュ値"
"は、(まったく一般的ではありませんが)ロギング設定がアプリケーション実行中に動"
"的に変更された場合にのみ再計算が必要でしょう。"

#: ../../howto/logging.rst:1097
msgid ""
"There are other optimizations which can be made for specific applications "
"which need more precise control over what logging information is collected. "
"Here's a list of things you can do to avoid processing during logging which "
"you don't need:"
msgstr ""
"これ以外にも、どんなログ情報が集められるかについてより正確なコントロールを必"
"要とする、特定のアプリケーションでできる最適化があります。これは、ログ記録の"
"間の不要な処理を避けるためにできることのリストです:"

#: ../../howto/logging.rst:1103
msgid "What you don't want to collect"
msgstr "不要な情報"

#: ../../howto/logging.rst:1103
msgid "How to avoid collecting it"
msgstr "それを避ける方法"

#: ../../howto/logging.rst:1105
msgid "Information about where calls were made from."
msgstr "呼び出しがどこから行われたかに関する情報。"

#: ../../howto/logging.rst:1105
msgid ""
"Set ``logging._srcfile`` to ``None``. This avoids calling :func:`sys."
"_getframe`, which may help to speed up your code in environments like PyPy "
"(which can't speed up code that uses :func:`sys._getframe`)."
msgstr ""
"``logging._srcfile`` を ``None`` にする。このことにより :func:`sys."
"_getframe` 呼び出しを避けることが出来、PyPy のような環境(:func:`sys."
"_getframe` の高速化が出来ない)において高速化の役に立ちます。"

#: ../../howto/logging.rst:1111
msgid "Threading information."
msgstr "スレッド情報。"

#: ../../howto/logging.rst:1111
msgid "Set ``logging.logThreads`` to ``False``."
msgstr "``logging.logThreads`` を ``False`` にする。"

#: ../../howto/logging.rst:1113
msgid "Current process ID (:func:`os.getpid`)"
msgstr "現在のプロセスID(:func:`os.getpid`)"

#: ../../howto/logging.rst:1113
msgid "Set ``logging.logProcesses`` to ``False``."
msgstr "``logging.logProcesses`` を ``False`` にする。"

#: ../../howto/logging.rst:1115
msgid ""
"Current process name when using ``multiprocessing`` to manage multiple "
"processes."
msgstr ""
"マルチプロセスの制御に ``multiprocessing`` を使っているときの、現在のプロセス"
"名"

#: ../../howto/logging.rst:1115
msgid "Set ``logging.logMultiprocessing`` to ``False``."
msgstr "``logging.logMultiprocessing`` を ``False`` にする。"

#: ../../howto/logging.rst:1118
msgid "Current :class:`asyncio.Task` name when using ``asyncio``."
msgstr "``asyncio`` を使っているときの、現在の :class:`asyncio.Task` の名前。"

#: ../../howto/logging.rst:1118
msgid "Set ``logging.logAsyncioTasks`` to ``False``."
msgstr "``logging.logAsyncioTasks`` を ``False`` に設定する。"

#: ../../howto/logging.rst:1122
msgid ""
"Also note that the core logging module only includes the basic handlers. If "
"you don't import :mod:`logging.handlers` and :mod:`logging.config`, they "
"won't take up any memory."
msgstr ""
"また、コア logging モジュールが基本的なハンドラだけを含んでいることに注意して"
"ください。 :mod:`logging.handlers` と :mod:`logging.config` をインポートしな"
"ければ、余分なメモリを消費することはありません。"

#: ../../howto/logging.rst:1129
msgid "Other resources"
msgstr "その他のリソース"

#: ../../howto/logging.rst:1133
msgid "Module :mod:`logging`"
msgstr ":mod:`logging` モジュール"

#: ../../howto/logging.rst:1134
msgid "API reference for the logging module."
msgstr "logging モジュールの API リファレンス。"

#: ../../howto/logging.rst:1136
msgid "Module :mod:`logging.config`"
msgstr ":mod:`logging.config` モジュール"

#: ../../howto/logging.rst:1137
msgid "Configuration API for the logging module."
msgstr "logging モジュールの環境設定 API です。"

#: ../../howto/logging.rst:1139
msgid "Module :mod:`logging.handlers`"
msgstr ":mod:`logging.handlers` モジュール"

#: ../../howto/logging.rst:1140
msgid "Useful handlers included with the logging module."
msgstr "logging モジュールに含まれる、便利なハンドラです。"

#: ../../howto/logging.rst:1142
msgid ":ref:`A logging cookbook <logging-cookbook>`"
msgstr ":ref:`ロギングクックブック <logging-cookbook>`"
