# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-10 13:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: cocoatomo, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/unicode.rst:5
msgid "Unicode HOWTO"
msgstr "Unicode HOWTO"

#: ../../howto/unicode.rst:0
msgid "Release"
msgstr "リリース"

#: ../../howto/unicode.rst:7
msgid "1.12"
msgstr "1.12"

#: ../../howto/unicode.rst:9
msgid ""
"This HOWTO discusses Python support for Unicode, and explains various "
"problems that people commonly encounter when trying to work with Unicode."
msgstr ""
"この HOWTO 文書は Python の Unicode サポートについて論じ、さらに Unicode "
"を使おうというときによくでくわす多くの問題について説明します。"

#: ../../howto/unicode.rst:14
msgid "Introduction to Unicode"
msgstr "Unicode 入門"

#: ../../howto/unicode.rst:17
msgid "History of Character Codes"
msgstr "文字コードの歴史"

#: ../../howto/unicode.rst:19
msgid ""
"In 1968, the American Standard Code for Information Interchange, better "
"known by its acronym ASCII, was standardized.  ASCII defined numeric codes "
"for various characters, with the numeric values running from 0 to 127.  For "
"example, the lowercase letter 'a' is assigned 97 as its code value."
msgstr ""
"1968年に American Standard Code for Information Interchange が標準化されました。これは頭文字の "
"ASCII でよく知られています。ASCII は0から127までの、異なる文字の数値コードを定義していて、例えば、小文字の 'a' にはコード値 97 "
"が割り当てられています。"

#: ../../howto/unicode.rst:24
msgid ""
"ASCII was an American-developed standard, so it only defined unaccented "
"characters.  There was an 'e', but no 'é' or 'Í'.  This meant that languages"
" which required accented characters couldn't be faithfully represented in "
"ASCII. (Actually the missing accents matter for English, too, which contains"
" words such as 'naïve' and 'café', and some publications have house styles "
"which require spellings such as 'coöperate'.)"
msgstr ""
"ASCII はアメリカの開発標準だったのでアクセント無しの文字のみを定義していて、 'e' はありましたが、 'é' や 'Í' "
"はありませんでした。つまり、アクセント付きの文字を必要とする言語は ASCII できちんと表現するとができません。 "
"(実際には英語でもアクセントが無いために起きる問題がありました、 'naïve' や 'café' のようなアクセントを含む単語や、いくつかの出版社は "
"'coöperate' のような独自のスタイルのつづりを必要とするなど)"

#: ../../howto/unicode.rst:31
msgid ""
"For a while people just wrote programs that didn't display accents. In the "
"mid-1980s an Apple II BASIC program written by a French speaker might have "
"lines like these:"
msgstr ""

#: ../../howto/unicode.rst:40
msgid ""
"Those messages should contain accents (terminée, paramètre, enregistrés) and"
" they just look wrong to someone who can read French."
msgstr ""
"これらのメッセージはアクセントを含んでいるはず (terminée, paramètre, enregistrés) "
"で、フランス語が読める人にとっては単なる間違いのように見られてしまいます。"

#: ../../howto/unicode.rst:43
msgid ""
"In the 1980s, almost all personal computers were 8-bit, meaning that bytes "
"could hold values ranging from 0 to 255.  ASCII codes only went up to 127, "
"so some machines assigned values between 128 and 255 to accented characters."
"  Different machines had different codes, however, which led to problems "
"exchanging files. Eventually various commonly used sets of values for the "
"128--255 range emerged. Some were true standards, defined by the "
"International Organization for Standardization, and some were *de facto* "
"conventions that were invented by one company or another and managed to "
"catch on."
msgstr ""
"1980 年代には、ほぼ全てのパーソナルコンピューターは 8-bit で、これは 0 から 255 "
"までの範囲の値を保持できることを意味しました。ASCII コードは最大で 127 までだったので、あるマシンでは 128 から 255 "
"までの値にアクセント付きの文字を割り当てていました。しかし、異なるマシンは異なる文字コードを持っていたため、ファイル交換で問題が起きるようになってきました。結局、128"
" から 255 まで範囲の値のセットで、よく使われるものが色々と現れました。そのうちいくつかは国際標準化機構 (International "
"Organization for Standardization) "
"によって定義された本物の標準になり、またいくつかはあちこちの会社で開発され、なんとか広まったものが *事実上の* 慣習となっていきました。"

#: ../../howto/unicode.rst:52
msgid ""
"255 characters aren't very many.  For example, you can't fit both the "
"accented characters used in Western Europe and the Cyrillic alphabet used "
"for Russian into the 128--255 range because there are more than 128 such "
"characters."
msgstr ""
"255文字というのは十分多い数ではありません。例えば、西ヨーロッパで使われるアクセント付き文字とロシアで使われるキリルアルファベットの両方は "
"128文字以上あるので、128--255の間におさめることはできません。"

#: ../../howto/unicode.rst:56
msgid ""
"You could write files using different codes (all your Russian files in a "
"coding system called KOI8, all your French files in a different coding "
"system called Latin1), but what if you wanted to write a French document "
"that quotes some Russian text?  In the 1980s people began to want to solve "
"this problem, and the Unicode standardization effort began."
msgstr ""
"異なる文字コードを使ってファイルを作成することは可能です (持っているロシア語のファイル全てを KOI8 "
"と呼ばれるコーディングシステムで、持っているフランス語のファイル全てを別の Latin1 "
"と呼ばれるコーディングシステムにすることで)、しかし、ロシア語の文章を引用するフランス語の文章を書きたい場合にはどうでしょう? "
"1989年代にこの問題を解決したいという要望が上って、Unicode 標準化の努力が始まりました。"

#: ../../howto/unicode.rst:62
msgid ""
"Unicode started out using 16-bit characters instead of 8-bit characters.  16"
" bits means you have 2^16 = 65,536 distinct values available, making it "
"possible to represent many different characters from many different "
"alphabets; an initial goal was to have Unicode contain the alphabets for "
"every single human language. It turns out that even 16 bits isn't enough to "
"meet that goal, and the modern Unicode specification uses a wider range of "
"codes, 0 through 1,114,111 ( ``0x10FFFF`` in base 16)."
msgstr ""
"Unicord は 8-bit 文字の代わりに 16-bit 文字を使うことに取り掛かりました。16 bit ということは 2^16 = 65,536 "
"の異なった値が使え、多くの様々なアルファベットの様々な文字を表現できるということを意味します; 最初の目標は、Unicode "
"に人間の1つ1つの言語のアルファベットを含めることでした。しかし 16 bit でさえ、その目標を達成するためには不十分であることが判明し、最新の "
"Unicode 規格では 0 から 1,114,111 (16進表記で ``0x10FFFF`` ) までのより広い範囲の文字コードを使っています。"

#: ../../howto/unicode.rst:70
msgid ""
"There's a related ISO standard, ISO 10646.  Unicode and ISO 10646 were "
"originally separate efforts, but the specifications were merged with the 1.1"
" revision of Unicode."
msgstr ""
"関連する ISO 標準も ISO 10646 があります。Unicode と ISO 10646 は元々独立した成果でしたが、 Unicode の "
"1.1 リビジョンで仕様を併合しました。"

#: ../../howto/unicode.rst:74
msgid ""
"(This discussion of Unicode's history is highly simplified.  The precise "
"historical details aren't necessary for understanding how to use Unicode "
"effectively, but if you're curious, consult the Unicode consortium site "
"listed in the References or the `Wikipedia entry for Unicode "
"<https://en.wikipedia.org/wiki/Unicode#History>`_ for more information.)"
msgstr ""
"(この Unicode の歴史についての解説は非常に単純化してあります。Unicode "
"の上手い使い方を理解するのに歴史的な詳細を精密に知る必要はありませんが、もし興味があれば、より詳しい情報は参考文献に載せた Unicode "
"コンソーシアムのサイトや `Wikipedia の Unicode の記事 "
"<http://en.wikipedia.org/wiki/Unicode#History>`_ を調べてください。)"

#: ../../howto/unicode.rst:83
msgid "Definitions"
msgstr "定義"

#: ../../howto/unicode.rst:85
msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are 'È' and 'Í'.  Characters "
"are abstractions, and vary depending on the language or context you're "
"talking about.  For example, the symbol for ohms (Ω) is usually drawn much "
"like the capital letter omega (Ω) in the Greek alphabet (they may even be "
"the same in some fonts), but these are two different characters that have "
"different meanings."
msgstr ""
"**文字** は文章の構成要素の中の最小のものです。'A', 'B', 'C' などは全て異なる文字です。 'È' や 'Í' "
"も同様に異なる文字です。文字は抽象的な概念で、言語や文脈に依存してさまざまに変化します。例えば、オーム(Ω) はふつう大文字ギリシャ文字のオメガ (Ω)"
" で書かれますが (これらはいくつかのフォントで全く同じ書体かもしれません) しかし、これらは異なる意味を持つ異なる文字とみなされます。"

#: ../../howto/unicode.rst:93
msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point is an integer value, usually denoted in base 16.  In"
" the standard, a code point is written using the notation ``U+12CA`` to mean"
" the character with value ``0x12ca`` (4,810 decimal).  The Unicode standard "
"contains a lot of tables listing characters and their corresponding code "
"points:"
msgstr ""
"Unicode 標準は文字をどのように **コードポイント (code points)** で表現されるのかを記述しています。コードポイントは通常 16"
" 進数で表記される整数値です。Unicode 標準では、コードポイントは ``U+12CA`` という表記を使って書かれ、これは ``0x12ca`` "
"(10 進表記で 4,810) という値を持つ文字ということを意味します。Unicode "
"標準は、文字とそれに対応するコードポイントを列挙した多くの表を含んでいます::"

#: ../../howto/unicode.rst:107
msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character ``U+12CA``'.  ``U+12CA`` is a code point, which represents some "
"particular character; in this case, it represents the character 'ETHIOPIC "
"SYLLABLE WI'.  In informal contexts, this distinction between code points "
"and characters will sometimes be forgotten."
msgstr ""
"厳密に言うと、この定義から「これは文字 ``U+12CA`` です」と言うのは意味の無いことだと分かります。``U+12CA`` "
"はコードポイントであり、それはある特定の文字を表しているのです; この場合では、'ETHIOPIC SYLLABLE WI' "
"という文字を表しています。形式ばらない文脈では、このコードポイントと文字の区別は忘れ去られることもあります。"

#: ../../howto/unicode.rst:113
msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the exact "
"details will depend on the font being used.  Most Python code doesn't need "
"to worry about glyphs; figuring out the correct glyph to display is "
"generally the job of a GUI toolkit or a terminal's font renderer."
msgstr ""
"文字は画面や紙面上では **グリフ (glyph)** と呼ばれるグラフィック要素の組で表示されます。大文字の A "
"のグリフは例えば、厳密な形は使っているフォントによって異なりますが、斜めの線と水平の線です。たいていの Python "
"コードではグリフの心配をする必要はありません; 一般的には表示する正しいグリフを見付けることは GUI toolkit "
"や端末のフォントレンダラーの仕事です。"

#: ../../howto/unicode.rst:122
msgid "Encodings"
msgstr "エンコーディング"

#: ../../howto/unicode.rst:124
msgid ""
"To summarize the previous section: a Unicode string is a sequence of code "
"points, which are numbers from 0 through ``0x10FFFF`` (1,114,111 decimal).  "
"This sequence needs to be represented as a set of bytes (meaning, values "
"from 0 through 255) in memory.  The rules for translating a Unicode string "
"into a sequence of bytes are called an **encoding**."
msgstr ""
"前の節をまとめると: Unicode 文字列はコードポイントのシーケンスであり、コードポイントとは 0 から ``0x10FFFF`` (10 進表記で"
" 1,114,111) までの数値です。このシーケンスはメモリ上ではバイト (つまり 0 から 255 までの値) "
"の集まりとして表される必要があります。Unicode 文字列をバイトのシーケンスとして翻訳する規則を **エンコーディング (encoding)** "
"と呼びます。"

#: ../../howto/unicode.rst:130
msgid ""
"The first encoding you might think of is an array of 32-bit integers.  In "
"this representation, the string \"Python\" would look like this:"
msgstr "まず考え付くエンコーディングは 32-bit 整数の配列でしょう。この表現では、文字列 \"Python\" は次のようになるでしょう:"

#: ../../howto/unicode.rst:139
msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr "この表現は直接的でわかりやすい方法ですが、この表現を使うにはいくつかの問題があります。"

#: ../../howto/unicode.rst:142
msgid "It's not portable; different processors order the bytes differently."
msgstr "可搬性がない; プロセッサが異なるとバイトの順序づけも変わってしまいます。"

#: ../../howto/unicode.rst:144
msgid ""
"It's very wasteful of space.  In most texts, the majority of the code points"
" are less than 127, or less than 255, so a lot of space is occupied by "
"``0x00`` bytes.  The above string takes 24 bytes compared to the 6 bytes "
"needed for an ASCII representation.  Increased RAM usage doesn't matter too "
"much (desktop computers have gigabytes of RAM, and strings aren't usually "
"that large), but expanding our usage of disk and network bandwidth by a "
"factor of 4 is intolerable."
msgstr ""
"無駄な領域が多いです。多くの文書では、コードポイントは 127 未満もしくは 255 未満が多数派を占め、そのため多くの領域が ``0x00`` "
"というバイトで埋め尽くされます。上の文字列は、ASCII 表現では 6 バイトなのに対し、24 バイトのサイズになっています。RAM "
"の使用量が増加するのはそれほど問題にはなりません (デスクトップコンピュータはギガバイト単位の RAM "
"を持っており、通常、文字列はそんな大きさにはなりません) が、ディスクとネットワーク大域が 4 倍多く使われてしまうのは我慢できるものではありません。"

#: ../../howto/unicode.rst:152
msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a new"
" family of wide string functions would need to be used."
msgstr "``strlen()`` のような現存する C 関数と互換性がありません、そのためワイド文字列関数一式が新たに必要となります。"

#: ../../howto/unicode.rst:155
msgid ""
"Many Internet standards are defined in terms of textual data, and can't "
"handle content with embedded zero bytes."
msgstr "多くのインターネット標準がテキストデータとして定義されていて、それらはゼロバイトの埋め込まれた内容を扱うことができません。"

#: ../../howto/unicode.rst:158
msgid ""
"Generally people don't use this encoding, instead choosing other encodings "
"that are more efficient and convenient.  UTF-8 is probably the most commonly"
" supported encoding; it will be discussed below."
msgstr ""
"一般的にこのエンコーディングは使わず、変わりにより効率的で便利な他のエンコーディングが選ばれています。 UTF-8 "
"はたぶん最も一般的にサポートされているエンコーディングです。このエンコーディングについては後で説明します。"

#: ../../howto/unicode.rst:162
msgid ""
"Encodings don't have to handle every possible Unicode character, and most "
"encodings don't.  The rules for converting a Unicode string into the ASCII "
"encoding, for example, are simple; for each code point:"
msgstr ""
"エンコーディングは全ての Unicode 文字を扱う必要はありませんし、多くのエンコーディングはそれをしません。Unicode 文字列を ASCII "
"エンコーディングに変換する規則は単純です; それぞれのコードポイントに対して:"

#: ../../howto/unicode.rst:166
msgid ""
"If the code point is < 128, each byte is the same as the value of the code "
"point."
msgstr "コードポイントは128より小さい場合、コードポイントと同じ値です。"

#: ../../howto/unicode.rst:169
msgid ""
"If the code point is 128 or greater, the Unicode string can't be represented"
" in this encoding.  (Python raises a :exc:`UnicodeEncodeError` exception in "
"this case.)"
msgstr ""
"コードポイントが128以上の場合、Unicode 文字列はエンコーディングで表示することができません。 (この場合 Python は "
":exc:`UnicodeEncodeError` 例外を送出します。)"

#: ../../howto/unicode.rst:173
msgid ""
"Latin-1, also known as ISO-8859-1, is a similar encoding.  Unicode code "
"points 0--255 are identical to the Latin-1 values, so converting to this "
"encoding simply requires converting code points to byte values; if a code "
"point larger than 255 is encountered, the string can't be encoded into "
"Latin-1."
msgstr ""
"Latin-1, ISO-8859-1 として知られるエンコーディングも同様のエンコーディングです。Unicode コードポイントの 0--255 は "
"Latin-1 の値と等価なので、このエンコーディングの変換するには、単純にコードポイントをバイト値に変換する必要があります; "
"もしコードポイントが255より大きい場合に遭遇した場合、文字列は Latin-1 にエンコードできません。"

#: ../../howto/unicode.rst:178
msgid ""
"Encodings don't have to be simple one-to-one mappings like Latin-1.  "
"Consider IBM's EBCDIC, which was used on IBM mainframes.  Letter values "
"weren't in one block: 'a' through 'i' had values from 129 to 137, but 'j' "
"through 'r' were 145 through 153.  If you wanted to use EBCDIC as an "
"encoding, you'd probably use some sort of lookup table to perform the "
"conversion, but this is largely an internal detail."
msgstr ""
"エンコーディングは Latin-1 のように単純な一対一対応を持っていません。 IBM メインフレームで使われていた IBM の EBCDIC "
"で考えてみます。文字は一つのブロックに収められていませんでした: 'a' から 'i' は 129 から 137 まででしたが、 'j' から 'r' "
"までは 145 から 153 までした。 EBICIC "
"を使いたいと思ったら、おそらく変換を実行するルックアップテーブルの類を使う必要があるでしょう、これは内部の詳細のことになりますが。"

#: ../../howto/unicode.rst:185
msgid ""
"UTF-8 is one of the most commonly used encodings.  UTF stands for \"Unicode "
"Transformation Format\", and the '8' means that 8-bit numbers are used in "
"the encoding.  (There are also a UTF-16 and UTF-32 encodings, but they are "
"less frequently used than UTF-8.)  UTF-8 uses the following rules:"
msgstr ""
"UTF-8 は最もよく使われているエンコーディングの1つです。UTF は \"Unicode Transformation Format\" "
"を表していて、'8' は 8-bit 整数がエンコーディングで使われていることを意味しています。(UTF-16 や UTF-32 "
"というエンコーディングもありますが、それらは UTF-8 ほどには頻繁に使われません。) UTF-8 は次のようなルールを使っています:"

#: ../../howto/unicode.rst:190
msgid ""
"If the code point is < 128, it's represented by the corresponding byte "
"value."
msgstr "コードポイントが 128 未満だった場合、対応するバイト値で表現します。"

#: ../../howto/unicode.rst:191
msgid ""
"If the code point is >= 128, it's turned into a sequence of two, three, or "
"four bytes, where each byte of the sequence is between 128 and 255."
msgstr "コードポイントが 128 以上の場合、128 から 255 までのバイトからなる、2、3 または 4 バイトのシーケンスに変換します。"

#: ../../howto/unicode.rst:194
msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8 はいくつかの便利な性質を持っています:"

#: ../../howto/unicode.rst:196
msgid "It can handle any Unicode code point."
msgstr "任意の Unicode コードポイントを扱うことができる。"

#: ../../howto/unicode.rst:197
msgid ""
"A Unicode string is turned into a sequence of bytes containing no embedded "
"zero bytes.  This avoids byte-ordering issues, and means UTF-8 strings can "
"be processed by C functions such as ``strcpy()`` and sent through protocols "
"that can't handle zero bytes."
msgstr ""

#: ../../howto/unicode.rst:201
msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "ASCII テキストの文字列は UTF-8 テキストとしても有効です。"

#: ../../howto/unicode.rst:202
msgid ""
"UTF-8 is fairly compact; the majority of commonly used characters can be "
"represented with one or two bytes."
msgstr "UTF-8 はかなりコンパクトです; よく使われている文字の大多数は 1 バイトか 2 バイトで表現できます。"

#: ../../howto/unicode.rst:204
msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of the "
"next UTF-8-encoded code point and resynchronize.  It's also unlikely that "
"random 8-bit data will look like valid UTF-8."
msgstr ""
"バイトが欠落したり、失われた場合、次の UTF-8 "
"でエンコードされたコードポイントの開始を決定し、再同期することができる可能性があります。同様の理由でランダムな 8-bit データは正当な UTF-8 "
"とみなされにくくなっています。"

#: ../../howto/unicode.rst:211 ../../howto/unicode.rst:485
#: ../../howto/unicode.rst:705
msgid "References"
msgstr "参考資料"

#: ../../howto/unicode.rst:213
msgid ""
"The `Unicode Consortium site <http://www.unicode.org>`_ has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  `A chronology "
"<http://www.unicode.org/history/>`_ of the origin and development of Unicode"
" is also available on the site."
msgstr ""
"`Unicode コンソーシアムのサイト <http://www.unicode.org>`_ には文字の図表、用語辞典、PDF 版の Unicode "
"仕様があります。これ読むのはそれなりに難しいので覚悟してください。Unicode の起源と発展の `年表 "
"<http://www.unicode.org/history/>`_ もサイトにあります。"

#: ../../howto/unicode.rst:218
msgid ""
"To help understand the standard, Jukka Korpela has written `an introductory "
"guide <https://www.cs.tut.fi/~jkorpela/unicode/guide.html>`_ to reading the "
"Unicode character tables."
msgstr ""

#: ../../howto/unicode.rst:222
msgid ""
"Another `good introductory article "
"<http://www.joelonsoftware.com/articles/Unicode.html>`_ was written by Joel "
"Spolsky. If this introduction didn't make things clear to you, you should "
"try reading this alternate article before continuing."
msgstr ""
"また別の `良い入門ガイド <http://www.joelonsoftware.com/articles/Unicode.html>`_ を Joel"
" Spolsky が書いています。この HOWTO の入門を読んでも理解が明確にならなかった場合は、続きを読む前にこの記事を読んでみるとよいです。"

#: ../../howto/unicode.rst:227
msgid ""
"Wikipedia entries are often helpful; see the entries for \"`character "
"encoding <https://en.wikipedia.org/wiki/Character_encoding>`_\" and `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_, for example."
msgstr ""

#: ../../howto/unicode.rst:233
msgid "Python's Unicode Support"
msgstr "Python の Unicode サポート"

#: ../../howto/unicode.rst:235
msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's "
"Unicode features."
msgstr "ここまでで Unicode の基礎を学びました、ここから Python の Unicode 機能に触れます。"

#: ../../howto/unicode.rst:239
msgid "The String Type"
msgstr "文字列型"

#: ../../howto/unicode.rst:241
msgid ""
"Since Python 3.0, the language features a :class:`str` type that contain "
"Unicode characters, meaning any string created using ``\"unicode rocks!\"``,"
" ``'unicode rocks!'``, or the triple-quoted string syntax is stored as "
"Unicode."
msgstr ""
"Python 3.0 から、言語は :class:`str` 型を Unicode 文字から成るものとして特徴付けています、つまり "
"``\"unicode rocks!\"`` や ``'unicode rocks!'`` や三重クオート文字列の構文を使って作られた文字列は "
"Unicode として格納されます。"

#: ../../howto/unicode.rst:245
msgid ""
"The default encoding for Python source code is UTF-8, so you can simply "
"include a Unicode character in a string literal::"
msgstr ""
"Python ソースコードのデフォルトエンコーディングは UTF-8 なので、文字列リテラルの中に Unicode "
"文字をそのまま含めることができます::"

#: ../../howto/unicode.rst:255
msgid ""
"You can use a different encoding from UTF-8 by putting a specially-formatted"
" comment as the first or second line of the source code::"
msgstr "特殊な形式のコメントをソースコードの1行目もしくは2行目に配置することで、UTF-8 ではないエンコーディングを使うことができます::"

#: ../../howto/unicode.rst:260
msgid ""
"Side note: Python 3 also supports using Unicode characters in identifiers::"
msgstr "追記: Python3 は Unicode 文字を使った識別子もサポートしています::"

#: ../../howto/unicode.rst:266
msgid ""
"If you can't enter a particular character in your editor or want to keep the"
" source code ASCII-only for some reason, you can also use escape sequences "
"in string literals. (Depending on your system, you may see the actual "
"capital-delta glyph instead of a \\u escape.) ::"
msgstr ""
"エディタである特定の文字が入力できなかったり、とある理由でソースコードを ASCII "
"のみに保ちたい場合は、文字列リテラルでエスケープシーケンスが使えます。(使ってるシステムによっては、\\u "
"でエスケープされた文字列ではなく、実物の大文字のラムダのグリフが見えるかもしれません。)::"

#: ../../howto/unicode.rst:278
msgid ""
"In addition, one can create a string using the :func:`~bytes.decode` method "
"of :class:`bytes`.  This method takes an *encoding* argument, such as "
"``UTF-8``, and optionally an *errors* argument."
msgstr ""
"加えて、 :class:`bytes` クラスの :func:`~bytes.decode` メソッドを使って文字列を作ることもできます。このメソッドは"
" ``UTF-8`` のような値を *encoding* 引数に取り、オプションで *errors* 引数を取ります。"

#: ../../howto/unicode.rst:282
msgid ""
"The *errors* argument specifies the response when the input string can't be "
"converted according to the encoding's rules.  Legal values for this argument"
" are ``'strict'`` (raise a :exc:`UnicodeDecodeError` exception), "
"``'replace'`` (use ``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` "
"(just leave the character out of the Unicode result), or "
"``'backslashreplace'`` (inserts a ``\\xNN`` escape sequence). The following "
"examples show the differences::"
msgstr ""
"*errors* 引数は、入力文字列に対しエンコーディングルールに従った変換ができなかったときの対応方法を指定します。この引数に使える値は "
"``'strict'`` (:exc:`UnicodeDecodeError` を送出する)、 ``'replace'`` (``REPLACEMENT"
" CHARACTER`` である ``U+FFFD`` を使う)、 ``'ignore'`` (結果となる Unicode から単に文字を除く) "
"、``'backslashreplace'`` (エスケープシーケンス ``\\xNN`` を挿入する) です。次の例はこれらの違いを示しています::"

#: ../../howto/unicode.rst:302
msgid ""
"Encodings are specified as strings containing the encoding's name.  Python "
"3.2 comes with roughly 100 different encodings; see the Python Library "
"Reference at :ref:`standard-encodings` for a list.  Some encodings have "
"multiple names; for example, ``'latin-1'``, ``'iso_8859_1'`` and ``'8859``' "
"are all synonyms for the same encoding."
msgstr ""
"エンコーディングはエンコーディングの名前を含んだ文字列で指定されます。 Python 3.2 はおよそ 100 "
"の異なるエンコーディングに対応しています; 一覧は Python ライブラリリファレンスの :ref:`standard-encodings` "
"を参照してください。いくつかのエンコーディングは複数の名前を持っています; 例えば、 ``'latin-1'`` と ``'iso_8859_1'`` "
"と ``'8859'`` は全て同じエンコーディングの別名です。"

#: ../../howto/unicode.rst:308
msgid ""
"One-character Unicode strings can also be created with the :func:`chr` "
"built-in function, which takes integers and returns a Unicode string of "
"length 1 that contains the corresponding code point.  The reverse operation "
"is the built-in :func:`ord` function that takes a one-character Unicode "
"string and returns the code point value::"
msgstr ""
"Unicode 文字列の一つの文字は :func:`chr` "
"組み込み関数で作成することができます、この関数は整数を引数にとり、対応するコードポイントを含む長さ1の Unicode 文字列を返します。逆の操作は "
":func:`ord` 組み込み関数です、この関数は一文字の Unicode 文字列を引数にとり、コードポイント値を返します::"

#: ../../howto/unicode.rst:320
msgid "Converting to Bytes"
msgstr "バイト列への変換"

#: ../../howto/unicode.rst:322
msgid ""
"The opposite method of :meth:`bytes.decode` is :meth:`str.encode`, which "
"returns a :class:`bytes` representation of the Unicode string, encoded in "
"the requested *encoding*."
msgstr ""
":meth:`bytes.decode` とは処理が逆向きのメソッドが :meth:`str.encode` です。このメソッドは、 Unicode "
"文字列を指定された *encoding* でエンコードして、 :class:`bytes` による表現で返します。"

#: ../../howto/unicode.rst:326
msgid ""
"The *errors* parameter is the same as the parameter of the "
":meth:`~bytes.decode` method but supports a few more possible handlers. As "
"well as ``'strict'``, ``'ignore'``, and ``'replace'`` (which in this case "
"inserts a question mark instead of the unencodable character), there is also"
" ``'xmlcharrefreplace'`` (inserts an XML character reference), "
"``backslashreplace`` (inserts a ``\\uNNNN`` escape sequence) and "
"``namereplace`` (inserts a ``\\N{...}`` escape sequence)."
msgstr ""
"*errors* 引数は :meth:`~bytes.decode` メソッドのパラメータと同じものですが、サポートされているハンドラの数がもう少し多いです。\n"
"``'strict'`` 、 ``'ignore'`` 、 ``'replace'`` (このメソッドでは、エンコードできなかった文字の代わりに疑問符を挿入する) の他に、 ``'xmlcharrefreplace'`` (XML 文字参照を挿入する) と ``backslashreplace`` (エスケープシーケンス ``\\nNNNN`` を挿入する)、 ``namereplace`` (エスケープシーケンス ``\\N{...}`` を挿入する) があります。"

#: ../../howto/unicode.rst:334
msgid "The following example shows the different results::"
msgstr "次の例では、それぞれの異なる処理結果が示されています::"

#: ../../howto/unicode.rst:355
msgid ""
"The low-level routines for registering and accessing the available encodings"
" are found in the :mod:`codecs` module.  Implementing new encodings also "
"requires understanding the :mod:`codecs` module. However, the encoding and "
"decoding functions returned by this module are usually more low-level than "
"is comfortable, and writing new encodings is a specialized task, so the "
"module won't be covered in this HOWTO."
msgstr ""
"利用可能なエンコーディングを登録したり、アクセスしたりする低レベルのルーチンは :mod:`codecs` "
"モジュールにあります。新しいエンコーディングを実装するには、 :mod:`codecs` "
"モジュールを理解していることも必要になります。しかし、このモジュールのエンコードやデコードの関数は、使い勝手が良いというより低レベルな関数で、新しいエンコーディングを書くのは特殊な作業なので、この"
" HOWTO では扱わないことにします。"

#: ../../howto/unicode.rst:364
msgid "Unicode Literals in Python Source Code"
msgstr "Python ソースコード内の Unicode リテラル"

#: ../../howto/unicode.rst:366
msgid ""
"In Python source code, specific Unicode code points can be written using the"
" ``\\u`` escape sequence, which is followed by four hex digits giving the "
"code point.  The ``\\U`` escape sequence is similar, but expects eight hex "
"digits, not four::"
msgstr ""
"Python のソースコード内では、特定のコードポイントはエスケープシーケンス ``\\u`` "
"を使い、続けてコードポイントを4桁の16進数を書きます。エスケープシーケンス ``\\U`` も同様です、ただし4桁ではなく8桁の16進数を使います::"

#: ../../howto/unicode.rst:378
msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters, as"
" you would in a program with messages in French or some other accent-using "
"language.  You can also assemble strings using the :func:`chr` built-in "
"function, but this is even more tedious."
msgstr ""
"127 "
"より大きいコードポイントに対してエスケープシーケンスを使うのは、エスケープシーケンスがあまり多くないうちは有効ですが、フランス語等のアクセントを使う言語でメッセージのような多くのアクセント文字を使う場合には邪魔になります。文字を"
" :func:`chr` 組み込み関数を使って組み上げることもできますが、それはさらに長くなってしまうでしょう。"

#: ../../howto/unicode.rst:384
msgid ""
"Ideally, you'd want to be able to write literals in your language's natural "
"encoding.  You could then edit Python source code with your favorite editor "
"which would display the accented characters naturally, and have the right "
"characters used at runtime."
msgstr ""
"理想的にはあなたの言語の自然なエンコーディングでリテラルを書くことでしょう。そうなれば、Python "
"のソースコードをアクセント付きの文字を自然に表示するお気に入りのエディタで編集し、実行時に正しい文字が得られます。"

#: ../../howto/unicode.rst:389
msgid ""
"Python supports writing source code in UTF-8 by default, but you can use "
"almost any encoding if you declare the encoding being used.  This is done by"
" including a special comment as either the first or second line of the "
"source file::"
msgstr ""
"Python はデフォルトでは UTF-8 "
"ソースコードを書くことができます、ただしどのエンコーディングを使うかを宣言すればほとんどのエンコーディングを使えます。それはソースファイルの一行目や二行目に特別なコメントを含めることによってできます::"

#: ../../howto/unicode.rst:399
msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local to"
" a file.  Emacs supports many different variables, but Python only supports "
"'coding'.  The ``-*-`` symbols indicate to Emacs that the comment is "
"special; they have no significance to Python but are a convention.  Python "
"looks for ``coding: name`` or ``coding=name`` in the comment."
msgstr ""
"この構文は Emacs のファイル固有の変数を指定する表記から影響を受けています。Emacs は様々な変数をサポートしていますが、Python "
"がサポートしているのは 'coding' のみです。 ``-*-`` の記法は Emacs に対してコメントが特別であることを示します。これは "
"Python にとって意味はありませんが慣習で使われています。 Python はコメント中に ``coding: name`` または "
"``coding=name`` を探します。"

#: ../../howto/unicode.rst:405
msgid ""
"If you don't include such a comment, the default encoding used will be UTF-8"
" as already mentioned.  See also :pep:`263` for more information."
msgstr ""
"このようなコメントを含んでいない場合、すでに述べた通り、使われるデフォルトエンコーディングは UTF-8 になります。より詳しい情報は "
":pep:`263` を参照してください。"

#: ../../howto/unicode.rst:410
msgid "Unicode Properties"
msgstr "Unicode プロパティ"

#: ../../howto/unicode.rst:412
msgid ""
"The Unicode specification includes a database of information about code "
"points. For each defined code point, the information includes the "
"character's name, its category, the numeric value if applicable (Unicode has"
" characters representing the Roman numerals and fractions such as one-third "
"and four-fifths).  There are also properties related to the code point's use"
" in bidirectional text and other display-related properties."
msgstr ""
"Unicode "
"仕様はコードポイントについての情報のデータベースも含んでいます。それぞれの定義されたコードポイントに対して、その情報は文字の名前、カテゴリ、適用可能であれば数値"
" (Unicode にはローマ数字や 1/3 や 4/5 のような分数を表す文字があります) "
"を含んでいます。また、右から読むテキストと左から読むテキストが混在しているテキストでのそのコードポイントの読む方向や、他の表示に関連した特質もあります。"

#: ../../howto/unicode.rst:419
msgid ""
"The following program displays some information about several characters, "
"and prints the numeric value of one particular character::"
msgstr "以下のプログラムはいくつかの文字に対する情報を表示し、特定の文字の数値を印字します::"

#: ../../howto/unicode.rst:433
msgid "When run, this prints:"
msgstr "実行すると、このように出力されます::"

#: ../../howto/unicode.rst:444
msgid ""
"The category codes are abbreviations describing the nature of the character."
" These are grouped into categories such as \"Letter\", \"Number\", "
"\"Punctuation\", or \"Symbol\", which in turn are broken up into "
"subcategories.  To take the codes from the above output, ``'Ll'`` means "
"'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is \"Mark, "
"nonspacing\", and ``'So'`` is \"Symbol, other\".  See `the General Category "
"Values section of the Unicode Character Database documentation "
"<http://www.unicode.org/reports/tr44/#General_Category_Values>`_ for a list "
"of category codes."
msgstr ""
"カテゴリーコードは文字の性質を略記で表したものです。カテゴリーコードは "
"\"Letter\"、\"Number\"、\"Punctuation\"、\"Symbol\" "
"などのカテゴリーに分類され、さらにサブカテゴリーに細分化されます。上記の出力からコードを拾うと、``'Ll'`` は 'Letter, "
"lowercase'、``'No'`` は \"Number, other\"、``'Mn'`` は \"Mark, "
"nonspacing\"、``'So'`` は \"Symbol, other\" を意味しています。カテゴリーコードの一覧は `Unicode "
"Character Database 文書の General Category Values 節 "
"<http://www.unicode.org/reports/tr44/#General_Category_Values>`_ を参照してください。"

#: ../../howto/unicode.rst:455
msgid "Unicode Regular Expressions"
msgstr "Unicode 正規表現"

#: ../../howto/unicode.rst:457
msgid ""
"The regular expressions supported by the :mod:`re` module can be provided "
"either as bytes or strings.  Some of the special character sequences such as"
" ``\\d`` and ``\\w`` have different meanings depending on whether the "
"pattern is supplied as bytes or a string.  For example, ``\\d`` will match "
"the characters ``[0-9]`` in bytes but in strings will match any character "
"that's in the ``'Nd'`` category."
msgstr ""
":mod:`re` モジュールがサポートしている正規表現はバイト列や文字列として与えられます。 ``\\d`` や ``\\w`` "
"などのいくつかの特殊な文字シーケンスは、そのパターンがバイト列として与えられたのか文字列として与えられたのかによって、異なる意味を持ちます。例えば、 "
"``\\d`` はバイト列では ``[0-9]`` の範囲の文字と一致しますが、文字列では ``'Nd'`` カテゴリーにある任意の文字と一致します。"

#: ../../howto/unicode.rst:464
msgid ""
"The string in this example has the number 57 written in both Thai and Arabic"
" numerals::"
msgstr "この例にある文字列には、タイ語の数字とアラビア数字の両方で数字の 57 が書いてあります。"

#: ../../howto/unicode.rst:474
msgid ""
"When executed, ``\\d+`` will match the Thai numerals and print them out.  If"
" you supply the :const:`re.ASCII` flag to :func:`~re.compile`, ``\\d+`` will"
" match the substring \"57\" instead."
msgstr ""
"実行すると、 ``\\d+`` はタイ語の数字と一致し、それを出力します。フラグ :const:`re.ASCII` を "
":func:`~re.compile` に渡した場合、 ``\\d+`` は先程とは違って部分文字列 \"57\" に一致します。"

#: ../../howto/unicode.rst:478
msgid ""
"Similarly, ``\\w`` matches a wide variety of Unicode characters but only "
"``[a-zA-Z0-9_]`` in bytes or if :const:`re.ASCII` is supplied, and ``\\s`` "
"will match either Unicode whitespace characters or ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"同様に、 ``\\w`` は非常に多くの Unicode 文字に一致しますが、バイト列の場合もしくは :const:`re.ASCII` "
"が渡された場合は ``[a-zA-Z0-9_]`` にしか一致しません。 ``\\s`` は文字列では Unicode 空白文字に、バイト列では ``["
" \\t\\n\\r\\f\\v]`` に一致します。"

#: ../../howto/unicode.rst:489
msgid "Some good alternative discussions of Python's Unicode support are:"
msgstr "Python の Unicode サポートについての参考になる議論は以下の2つです:"

#: ../../howto/unicode.rst:491
msgid ""
"`Processing Text Files in Python 3 <http://python-"
"notes.curiousefficiency.org/en/latest/python3/text_file_processing.html>`_, "
"by Nick Coghlan."
msgstr ""
"Nick Coghlan による `Processing Text Files in Python 3 <http://python-"
"notes.curiousefficiency.org/en/latest/python3/text_file_processing.html>`_"

#: ../../howto/unicode.rst:492
msgid ""
"`Pragmatic Unicode <http://nedbatchelder.com/text/unipain.html>`_, a PyCon "
"2012 presentation by Ned Batchelder."
msgstr ""
"Ned Batchelder による PyCon 2012 での発表 `Pragmatic Unicode "
"<http://nedbatchelder.com/text/unipain.html>`_"

#: ../../howto/unicode.rst:494
msgid ""
"The :class:`str` type is described in the Python library reference at "
":ref:`textseq`."
msgstr ":class:`str` 型については Python ライブラリリファレンスの :ref:`textseq` で解説されています。"

#: ../../howto/unicode.rst:497
msgid "The documentation for the :mod:`unicodedata` module."
msgstr ":mod:`unicodedata` モジュールについてのドキュメント。"

#: ../../howto/unicode.rst:499
msgid "The documentation for the :mod:`codecs` module."
msgstr ":mod:`codecs` モジュールについてのドキュメント。"

#: ../../howto/unicode.rst:501
msgid ""
"Marc-André Lemburg gave `a presentation titled \"Python and Unicode\" (PDF "
"slides) <https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>`_ at "
"EuroPython 2002.  The slides are an excellent overview of the design of "
"Python 2's Unicode features (where the Unicode string type is called "
"``unicode`` and literals start with ``u``)."
msgstr ""
"Marc-André Lemburg は EuroPython 2002 で `\"Python and Unicode\" "
"というタイトルのプレゼンテーション (PDF スライド) <https://downloads.egenix.com/python/Unicode-"
"EPC2002-Talk.pdf>`_ を行いました。このスライドは Python 2 の Unicode 機能 (Unicode 文字列型が "
"``unicode`` と呼ばれ、リテラルは ``u`` で始まります) の設計について概観する素晴しい資料です。"

#: ../../howto/unicode.rst:509
msgid "Reading and Writing Unicode Data"
msgstr "Unicode データを読み書きする"

#: ../../howto/unicode.rst:511
msgid ""
"Once you've written some code that works with Unicode data, the next problem"
" is input/output.  How do you get Unicode strings into your program, and how"
" do you convert Unicode into a form suitable for storage or transmission?"
msgstr ""
"一旦 Unicode データに対してコードが動作するように書き終えたら、次の問題は入出力です。プログラムは Unicode 文字列をどう受けとり、どう "
"Unicode を外部記憶装置や送受信装置に適した形式に変換するのでしょう?"

#: ../../howto/unicode.rst:515
msgid ""
"It's possible that you may not need to do anything depending on your input "
"sources and output destinations; you should check whether the libraries used"
" in your application support Unicode natively.  XML parsers often return "
"Unicode data, for example.  Many relational databases also support Unicode-"
"valued columns and can return Unicode values from an SQL query."
msgstr ""
"入力ソースと出力先に依存しないような方法は可能です; アプリケーションに利用されているライブラリが Unicode "
"をそのままサポートしているかを調べなければいけません。例えば XML パーサーは大抵 Unicode "
"データを返します。多くのリレーショナルデータベースも Unicode 値の入ったコラムをサポートしていますし、 SQL の問い合わせで Unicode "
"値を返すことができます。"

#: ../../howto/unicode.rst:521
msgid ""
"Unicode data is usually converted to a particular encoding before it gets "
"written to disk or sent over a socket.  It's possible to do all the work "
"yourself: open a file, read an 8-bit bytes object from it, and convert the "
"bytes with ``bytes.decode(encoding)``.  However, the manual approach is not "
"recommended."
msgstr ""
"Unicode "
"のデータはディスクに書き込まれるにあたって通常、特定のエンコーディングに変換されます。推奨はされませんが、これを手動で行うことも可能です。ファイルを開き、8バイトオブジェクトを読み込み、バイト列を"
" ``bytes.decode(encoding)`` で変換することにより実現できます。"

#: ../../howto/unicode.rst:526
msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character can"
" be represented by several bytes.  If you want to read the file in "
"arbitrary-sized chunks (say, 1024 or 4096 bytes), you need to write error-"
"handling code to catch the case where only part of the bytes encoding a "
"single Unicode character are read at the end of a chunk.  One solution would"
" be to read the entire file into memory and then perform the decoding, but "
"that prevents you from working with files that are extremely large; if you "
"need to read a 2 GiB file, you need 2 GiB of RAM. (More, really, since for "
"at least a moment you'd need to have both the encoded string and its Unicode"
" version in memory.)"
msgstr ""
"1つの問題はエンコーディングのマルチバイトという性質です; 1つの Unicode 文字はいくつかのバイトで表現され得ます。任意のサイズのチャンク "
"(例えば、1024 もしくは 4096 バイト) にファイルの内容を読み込みたい場合、ある 1 つの Unicode "
"文字をエンコードしたバイト列が、チャンクの末尾での一部分のみ読み込まれの場合のエラー処理のためのコードを書く必要があります。1つの解決策はファイル全体をメモリに読み込み、デコード処理を実行することですが、こうしてしまうと非常に大きなファイルを処理するときの妨げになります;"
" 2 GiB のファイルを読み込む必要がある場合、2 GiB の RAM が必要になります。(実際には、少なくともある瞬間では、エンコードされた文字列と"
" Unicode 文字列の両方をメモリに保持する必要があるため、より多くのメモリが必要です。)"

#: ../../howto/unicode.rst:536
msgid ""
"The solution would be to use the low-level decoding interface to catch the "
"case of partial coding sequences.  The work of implementing this has already"
" been done for you: the built-in :func:`open` function can return a file-"
"like object that assumes the file's contents are in a specified encoding and"
" accepts Unicode parameters for methods such as :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.write`.  This works through :func:`open`\\'s "
"*encoding* and *errors* parameters which are interpreted just like those in "
":meth:`str.encode` and :meth:`bytes.decode`."
msgstr ""

#: ../../howto/unicode.rst:545
msgid "Reading Unicode from a file is therefore simple::"
msgstr "そのためファイルから Unicode を読むのは単純です::"

#: ../../howto/unicode.rst:551
msgid ""
"It's also possible to open files in update mode, allowing both reading and "
"writing::"
msgstr "読み書きの両方ができる update モードでファイルを開くことも可能です::"

#: ../../howto/unicode.rst:559
msgid ""
"The Unicode character ``U+FEFF`` is used as a byte-order mark (BOM), and is "
"often written as the first character of a file in order to assist with "
"autodetection of the file's byte ordering.  Some encodings, such as UTF-16, "
"expect a BOM to be present at the start of a file; when such an encoding is "
"used, the BOM will be automatically written as the first character and will "
"be silently dropped when the file is read.  There are variants of these "
"encodings, such as 'utf-16-le' and 'utf-16-be' for little-endian and big-"
"endian encodings, that specify one particular byte ordering and don't skip "
"the BOM."
msgstr ""
"Unicode 文字 ``U+FEFF`` は byte-order mark (BOM) "
"として使われ、ファイルのバイト順の自動判定を支援するために、ファイルの最初の文字として書かれます。UTF-16 "
"のようないくつかのエンコーディングは、ファイルの先頭に BOM があることを要求します; そのようなエンコーディングが使われるとき、自動的に BOM "
"が最初の文字として書かれ、ファイルを読むときに暗黙の内に取り除かれます。これらのエンコーディングには、リトルエンディアン (little-endian)"
" 用の 'utf-16-le' やビッグエンディアン (big-endian) 用の 'utf-16-be' "
"というような変種があり、これらは特定の1つのバイト順を指定していて BOM をスキップしません。"

#: ../../howto/unicode.rst:568
msgid ""
"In some areas, it is also convention to use a \"BOM\" at the start of UTF-8 "
"encoded files; the name is misleading since UTF-8 is not byte-order "
"dependent. The mark simply announces that the file is encoded in UTF-8.  Use"
" the 'utf-8-sig' codec to automatically skip the mark if present for reading"
" such files."
msgstr ""
"いくつかの領域では、UTF-8 でエンコードされたファイルの先頭に \"BOM\" を利用する習慣があります; "
"この名前はよく誤解を招きますが、UTF-8 はバイトオーダーに依存しません。\"BOM\" の印は単にファイルが UTF-8 "
"でエンコーディングされていることを知らせるものです。もし、そのようなファイルを読む場合には、この印を自動的にスキップするために 'utf-8-sig' "
"コーデックを利用してください。"

#: ../../howto/unicode.rst:576
msgid "Unicode filenames"
msgstr "Unicode ファイル名"

#: ../../howto/unicode.rst:578
msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on "
"the system.  For example, Mac OS X uses UTF-8 while Windows uses a "
"configurable encoding; on Windows, Python uses the name \"mbcs\" to refer to"
" whatever the currently configured encoding is.  On Unix systems, there will"
" only be a filesystem encoding if you've set the ``LANG`` or ``LC_CTYPE`` "
"environment variables; if you haven't, the default encoding is UTF-8."
msgstr ""
"多くの OS では現在任意の Unicode 文字を含むファイル名をサポートしています。通常 Unicode "
"文字列をシステム依存のエンコーディングに変換することによって実装されています。例えば、Mac OS X は UTF-8 を利用し、Windows "
"ではエンコーディングが設定で変更することが可能です; Windows では Python は \"mbcs\" "
"という名前に現在設定されているエンコーディングを問い合わせて利用します。Unix システムでは ``LANG`` や ``LC_CTYPE`` "
"環境変数を設定していれば、それだけがファイルシステムのエンコーディングとなります; もしエンコーディングを設定しなければ、デフォルトエンコーディングは "
"UTF-8 になります。"

#: ../../howto/unicode.rst:587
msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to use "
"on your current system, in case you want to do the encoding manually, but "
"there's not much reason to bother.  When opening a file for reading or "
"writing, you can usually just provide the Unicode string as the filename, "
"and it will be automatically converted to the right encoding for you::"
msgstr ""
":func:`sys.getfilesystemencoding` "
"関数は現在のシステムで利用するエンコーディングを返し、エンコーディングを手動で設定したい場合利用します、ただしわざわざそうする積極的な理由はありません。読み書きのためにファイルを開く時には、ファイル名を"
" Unicode 文字列として渡すだけで正しいエンコーディングに自動的に変更されます::"

#: ../../howto/unicode.rst:597
msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also accept "
"Unicode filenames."
msgstr ":func:`os.stat` のような :mod:`os` モジュールの関数も Unicode のファイル名を受け付けます。"

#: ../../howto/unicode.rst:600
msgid ""
"The :func:`os.listdir` function returns filenames and raises an issue: "
"should it return the Unicode version of filenames, or should it return bytes"
" containing the encoded versions?  :func:`os.listdir` will do both, "
"depending on whether you provided the directory path as bytes or a Unicode "
"string.  If you pass a Unicode string as the path, filenames will be decoded"
" using the filesystem's encoding and a list of Unicode strings will be "
"returned, while passing a byte path will return the filenames as bytes.  For"
" example, assuming the default filesystem encoding is UTF-8, running the "
"following program::"
msgstr ""
":func:`os.listdir` 関数はファイル名を返しますが、ここで問題が起きます: この関数はファイル名を Unicode "
"で返すべきでしょうか? それともエンコードされたバイト列で返すべきでしょうか? :func:`os.listdir` "
"は、ディレクトリのパスをバイト列として渡したか、 Unicode 文字列として渡したかによって、どちらの形式でも返せます。パスを Unicode "
"文字列として渡した場合、ファイル名はファイルシステムエンコーディングを使ってデコードされ、 Unicode "
"文字列のリストが返されます。その一方、バイト列のパスを渡すとファイル名をバイト列として返します。例えば、デフォルトのファイルシステムエンコーディングが "
"UTF-8 だと仮定して、以下のプログラムを実行すると::"

#: ../../howto/unicode.rst:618
msgid "will produce the following output:"
msgstr "以下の出力結果が生成されます:"

#: ../../howto/unicode.rst:626
msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr "最初のリストは UTF-8 でエンコーディングされたファイル名を含み、第二のリストは Unicode 版を含んでいます。"

#: ../../howto/unicode.rst:629
msgid ""
"Note that on most occasions, the Unicode APIs should be used.  The bytes "
"APIs should only be used on systems where undecodable file names can be "
"present, i.e. Unix systems."
msgstr ""
"ほぼ全ての状況で Unicode API を利用すべきです。bytes API はシステムのデコードされていないファイル名が存在する場合、例えば "
"Unix システム、でのみ利用すべきです。"

#: ../../howto/unicode.rst:635
msgid "Tips for Writing Unicode-aware Programs"
msgstr "Unicode 対応のプログラムを書くための Tips"

#: ../../howto/unicode.rst:637
msgid ""
"This section provides some suggestions on writing software that deals with "
"Unicode."
msgstr "この章では Unicode を扱うプログラムを書くためのいくつかの提案を紹介します。"

#: ../../howto/unicode.rst:640
msgid "The most important tip is:"
msgstr "最も重要な助言としては:"

#: ../../howto/unicode.rst:642
msgid ""
"Software should only work with Unicode strings internally, decoding the "
"input data as soon as possible and encoding the output only at the end."
msgstr "ソフトウェアは内部では Unicode 文字列のみを利用し、入力データはできるだけ早期にデコードし、出力の直前でエンコードすべきです。"

#: ../../howto/unicode.rst:645
msgid ""
"If you attempt to write processing functions that accept both Unicode and "
"byte strings, you will find your program vulnerable to bugs wherever you "
"combine the two different kinds of strings.  There is no automatic encoding "
"or decoding: if you do e.g. ``str + bytes``, a :exc:`TypeError` will be "
"raised."
msgstr ""

#: ../../howto/unicode.rst:650
msgid ""
"When using data coming from a web browser or some other untrusted source, a "
"common technique is to check for illegal characters in a string before using"
" the string in a generated command line or storing it in a database.  If "
"you're doing this, be careful to check the decoded string, not the encoded "
"bytes data; some encodings may have interesting properties, such as not "
"being bijective or not being fully ASCII-compatible.  This is especially "
"true if the input data also specifies the encoding, since the attacker can "
"then choose a clever way to hide malicious text in the encoded bytestream."
msgstr ""
"web "
"ブラウザから来るデータやその他の信頼できないところからのデータを利用する場合、それらの文字列から生成したコマンド行の実行や、それらの文字列をデータベースに蓄える前に文字列の中に不正な文字が含まれていないか確認するのが一般的です。もしそういう状況になった場合には、エンコードされたバイトデータではなく、デコードされた文字列のチェックを入念に行なって下さい;"
" いくつかのエンコーディングは問題となる性質を持っています、例えば全単射でなかったり、完全に ASCII "
"互換でないなど。入力データがエンコーディングを指定している場合でもそうして下さい、なぜなら攻撃者は巧みに悪意あるテキストをエンコードした文字列の中に隠すことができるからです。"

#: ../../howto/unicode.rst:661
msgid "Converting Between File Encodings"
msgstr "ファイルエンコーディングの変換"

#: ../../howto/unicode.rst:663
msgid ""
"The :class:`~codecs.StreamRecoder` class can transparently convert between "
"encodings, taking a stream that returns data in encoding #1 and behaving "
"like a stream returning data in encoding #2."
msgstr ""

#: ../../howto/unicode.rst:667
msgid ""
"For example, if you have an input file *f* that's in Latin-1, you can wrap "
"it with a :class:`~codecs.StreamRecoder` to return bytes encoded in UTF-8::"
msgstr ""

#: ../../howto/unicode.rst:681
msgid "Files in an Unknown Encoding"
msgstr "不明なエンコーディングのファイル"

#: ../../howto/unicode.rst:683
msgid ""
"What can you do if you need to make a change to a file, but don't know the "
"file's encoding?  If you know the encoding is ASCII-compatible and only want"
" to examine or modify the ASCII parts, you can open the file with the "
"``surrogateescape`` error handler::"
msgstr ""

#: ../../howto/unicode.rst:697
msgid ""
"The ``surrogateescape`` error handler will decode any non-ASCII bytes as "
"code points in the Unicode Private Use Area ranging from U+DC80 to U+DCFF.  "
"These private code points will then be turned back into the same bytes when "
"the ``surrogateescape`` error handler is used when encoding the data and "
"writing it back out."
msgstr ""

#: ../../howto/unicode.rst:707
msgid ""
"One section of `Mastering Python 3 Input/Output "
"<http://pyvideo.org/video/289/pycon-2010--mastering-python-3-i-o>`_, a PyCon"
" 2010 talk by David Beazley, discusses text processing and binary data "
"handling."
msgstr ""

#: ../../howto/unicode.rst:711
msgid ""
"The `PDF slides for Marc-André Lemburg's presentation \"Writing Unicode-"
"aware Applications in Python\" <https://downloads.egenix.com/python/LSM2005"
"-Developing-Unicode-aware-applications-in-Python.pdf>`_ discuss questions of"
" character encodings as well as how to internationalize and localize an "
"application.  These slides cover Python 2.x only."
msgstr ""
"Marc-André Lemburg のプレゼンテーション \"Writing Unicode-aware Applications in "
"Python\" の PDF スライドが <https://downloads.egenix.com/python/LSM2005"
"-Developing-Unicode-aware-applications-in-Python.pdf> "
"から入手可能です、そして文字エンコーディングの問題と同様にアプリケーションの国際化やローカライズについても議論されています。このスライドは Python"
" 2.x のみをカバーしています。"

#: ../../howto/unicode.rst:717
msgid ""
"`The Guts of Unicode in Python <http://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ is a PyCon 2013 talk by Benjamin Peterson that "
"discusses the internal Unicode representation in Python 3.3."
msgstr ""

#: ../../howto/unicode.rst:724
msgid "Acknowledgements"
msgstr "謝辞"

#: ../../howto/unicode.rst:726
msgid ""
"The initial draft of this document was written by Andrew Kuchling. It has "
"since been revised further by Alexander Belopolsky, Georg Brandl, Andrew "
"Kuchling, and Ezio Melotti."
msgstr ""
"このドキュメントの最初の草稿は Andrew Kuchling によって書かれました。それからさらに Alexander Belopolsky, "
"Georg Brandl, Andrew Kuchling, Ezio Melotti らで改訂が重ねられています。"

#: ../../howto/unicode.rst:730
msgid ""
"Thanks to the following people who have noted errors or offered suggestions "
"on this article: Éric Araujo, Nicholas Bastin, Nick Coghlan, Marius "
"Gedminas, Kent Johnson, Ken Krugler, Marc-André Lemburg, Martin von Löwis, "
"Terry J. Reedy, Chad Whitacre."
msgstr ""
"この記事中の誤りの指摘や提案を申し出てくれた以下の人々に感謝します: Éric Araujo, Nicholas Bastin, Nick "
"Coghlan, Marius Gedminas, Kent Johnson, Ken Krugler, Marc-André Lemburg, "
"Martin von Löwis, Terry J. Reedy, Chad Whitacre."
