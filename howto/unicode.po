# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2018-01-20 20:57+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/unicode.rst:3
msgid "Unicode HOWTO"
msgstr "Unicode HOWTO"

#: ../../howto/unicode.rst:0
msgid "Release"
msgstr "ãƒªãƒªãƒ¼ã‚¹"

#: ../../howto/unicode.rst:5
msgid "1.03"
msgstr "1.03"

#: ../../howto/unicode.rst:7
msgid ""
"This HOWTO discusses Python 2.x's support for Unicode, and explains various "
"problems that people commonly encounter when trying to work with Unicode.  "
"For the Python 3 version, see "
"<https://docs.python.org/3/howto/unicode.html>."
msgstr "ã“ã® HOWTO æ–‡æ›¸ã¯ Python 2.x ã® Unicode ã‚µãƒãƒ¼ãƒˆã«ã¤ã„ã¦è«–ã˜ã€ã•ã‚‰ã« Unicode ã‚’ä½¿ãŠã†ã¨ã„ã†ã¨ãã«ã‚ˆãã§ãã‚ã™å¤šãã®å•é¡Œã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚ã“ã®æ–‡æ›¸ã® Python 3 ç‰ˆã¯ <https://docs.python.org/3/howto/unicode.html> ã‚’ã”è¦§ãã ã•ã„ã€‚"

#: ../../howto/unicode.rst:13
msgid "Introduction to Unicode"
msgstr "Unicode å…¥é–€"

#: ../../howto/unicode.rst:16
msgid "History of Character Codes"
msgstr "æ–‡å­—ã‚³ãƒ¼ãƒ‰ã®æ­´å²"

#: ../../howto/unicode.rst:18
msgid ""
"In 1968, the American Standard Code for Information Interchange, better "
"known by its acronym ASCII, was standardized.  ASCII defined numeric codes "
"for various characters, with the numeric values running from 0 to 127.  For "
"example, the lowercase letter 'a' is assigned 97 as its code value."
msgstr "1968å¹´ã« American Standard Code for Information Interchange ãŒæ¨™æº–åŒ–ã•ã‚Œã¾ã—ãŸã€‚ã“ã‚Œã¯é ­æ–‡å­—ã® ASCII ã§ã‚ˆãçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ASCII ã¯0ã‹ã‚‰127ã¾ã§ã®ã€ç•°ãªã‚‹æ–‡å­—ã®æ•°å€¤ã‚³ãƒ¼ãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã¦ã€ä¾‹ãˆã°ã€å°æ–‡å­—ã® 'a' ã«ã¯ã‚³ãƒ¼ãƒ‰å€¤ 97 ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:24
msgid ""
"ASCII was an American-developed standard, so it only defined unaccented "
"characters.  There was an 'e', but no 'Ã©' or 'Ã'.  This meant that languages"
" which required accented characters couldn't be faithfully represented in "
"ASCII. (Actually the missing accents matter for English, too, which contains"
" words such as 'naÃ¯ve' and 'cafÃ©', and some publications have house styles "
"which require spellings such as 'coÃ¶perate'.)"
msgstr "ASCII ã¯ã‚¢ãƒ¡ãƒªã‚«ã®é–‹ç™ºæ¨™æº–ã ã£ãŸã®ã§ã‚¢ã‚¯ã‚»ãƒ³ãƒˆç„¡ã—ã®æ–‡å­—ã®ã¿ã‚’å®šç¾©ã—ã¦ã„ã¦ã€ 'e' ã¯ã‚ã‚Šã¾ã—ãŸãŒã€ 'Ã©' ã‚„ 'Ã' ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã¤ã¾ã‚Šã€ã‚¢ã‚¯ã‚»ãƒ³ãƒˆä»˜ãã®æ–‡å­—ã‚’å¿…è¦ã¨ã™ã‚‹è¨€èªã¯ ASCII ã§ãã¡ã‚“ã¨è¡¨ç¾ã™ã‚‹ã¨ãŒã§ãã¾ã›ã‚“ã€‚ (å®Ÿéš›ã«ã¯è‹±èªã§ã‚‚ã‚¢ã‚¯ã‚»ãƒ³ãƒˆãŒç„¡ã„ãŸã‚ã«èµ·ãã‚‹å•é¡ŒãŒã‚ã‚Šã¾ã—ãŸã€ 'naÃ¯ve' ã‚„ 'cafÃ©' ã®ã‚ˆã†ãªã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚’å«ã‚€å˜èªã‚„ã€ã„ãã¤ã‹ã®å‡ºç‰ˆç¤¾ã¯ 'coÃ¶perate' ã®ã‚ˆã†ãªç‹¬è‡ªã®ã‚¹ã‚¿ã‚¤ãƒ«ã®ã¤ã¥ã‚Šã‚’å¿…è¦ã¨ã™ã‚‹ãªã©)"

#: ../../howto/unicode.rst:31
msgid ""
"For a while people just wrote programs that didn't display accents.  I "
"remember looking at Apple ][ BASIC programs, published in French-language "
"publications in the mid-1980s, that had lines like these::"
msgstr "ã—ã°ã‚‰ãã®é–“ã¯å˜ã«ã‚¢ã‚¯ã‚»ãƒ³ãƒˆãŒè¡¨ç¤ºã•ã‚Œãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãã¾ã—ãŸã€‚ 1980å¹´åŠã°ã®ãƒ•ãƒ©ãƒ³ã‚¹èªã§å‡ºç‰ˆã•ã‚ŒãŸ Apple ][ ã® BASIC ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¦‹ãŸè¨˜æ†¶ã‚’è¾¿ã‚‹ã¨ã€ãã“ã«ã¯ã“ã‚“ãªè¡ŒãŒå«ã¾ã‚Œã¦ã„ã¾ã—ãŸ::"

#: ../../howto/unicode.rst:38
msgid ""
"Those messages should contain accents, and they just look wrong to someone "
"who can read French."
msgstr "ã“ã‚Œã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚’å«ã‚€ã¹ãã§ã€ãƒ•ãƒ©ãƒ³ã‚¹èªã‚’èª­ã‚ã‚‹äººã‹ã‚‰è¦‹ã‚‹ã¨å˜ã«é–“é•ã„ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚"

#: ../../howto/unicode.rst:41
msgid ""
"In the 1980s, almost all personal computers were 8-bit, meaning that bytes "
"could hold values ranging from 0 to 255.  ASCII codes only went up to 127, "
"so some machines assigned values between 128 and 255 to accented characters."
"  Different machines had different codes, however, which led to problems "
"exchanging files. Eventually various commonly used sets of values for the "
"128--255 range emerged. Some were true standards, defined by the "
"International Organization for Standardization, and some were *de facto* "
"conventions that were invented by one company or another and managed to "
"catch on."
msgstr "1980 å¹´ä»£ã«ã¯ã€ã»ã¼å…¨ã¦ã®ãƒ‘ãƒ¼ã‚½ãƒŠãƒ«ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã¯ 8-bit ã§ã€ã“ã‚Œã¯ 0 ã‹ã‚‰ 255 ã¾ã§ã®ç¯„å›²ã®å€¤ã‚’ä¿æŒã§ãã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã—ãŸã€‚ASCII ã‚³ãƒ¼ãƒ‰ã¯æœ€å¤§ã§ 127 ã¾ã§ã ã£ãŸã®ã§ã€ã‚ã‚‹ãƒã‚·ãƒ³ã§ã¯ 128 ã‹ã‚‰ 255 ã¾ã§ã®å€¤ã«ã‚¢ã‚¯ã‚»ãƒ³ãƒˆä»˜ãã®æ–‡å­—ã‚’å‰²ã‚Šå½“ã¦ã¦ã„ã¾ã—ãŸã€‚ã—ã‹ã—ã€ç•°ãªã‚‹ãƒã‚·ãƒ³ã¯ç•°ãªã‚‹æ–‡å­—ã‚³ãƒ¼ãƒ‰ã‚’æŒã£ã¦ã„ãŸãŸã‚ã€ãƒ•ã‚¡ã‚¤ãƒ«äº¤æ›ã§å•é¡ŒãŒèµ·ãã‚‹ã‚ˆã†ã«ãªã£ã¦ãã¾ã—ãŸã€‚çµå±€ã€128 ã‹ã‚‰ 255 ã¾ã§ç¯„å›²ã®å€¤ã®ã‚»ãƒƒãƒˆã§ã€ã‚ˆãä½¿ã‚ã‚Œã‚‹ã‚‚ã®ãŒè‰²ã€…ã¨ç¾ã‚Œã¾ã—ãŸã€‚ãã®ã†ã¡ã„ãã¤ã‹ã¯å›½éš›æ¨™æº–åŒ–æ©Ÿæ§‹ (International Organization for Standardization) ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚ŒãŸæœ¬ç‰©ã®æ¨™æº–ã«ãªã‚Šã€ã¾ãŸã„ãã¤ã‹ã¯ã‚ã¡ã“ã¡ã®ä¼šç¤¾ã§é–‹ç™ºã•ã‚Œã€ãªã‚“ã¨ã‹åºƒã¾ã£ãŸã‚‚ã®ãŒ *äº‹å®Ÿä¸Šã®* æ…£ç¿’ã¨ãªã£ã¦ã„ãã¾ã—ãŸã€‚"

#: ../../howto/unicode.rst:50
msgid ""
"255 characters aren't very many.  For example, you can't fit both the "
"accented characters used in Western Europe and the Cyrillic alphabet used "
"for Russian into the 128--255 range because there are more than 128 such "
"characters."
msgstr "255æ–‡å­—ã¨ã„ã†ã®ã¯ååˆ†å¤šã„æ•°ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€è¥¿ãƒ¨ãƒ¼ãƒ­ãƒƒãƒ‘ã§ä½¿ã‚ã‚Œã‚‹ã‚¢ã‚¯ã‚»ãƒ³ãƒˆä»˜ãæ–‡å­—ã¨ãƒ­ã‚·ã‚¢ã§ä½¿ã‚ã‚Œã‚‹ã‚­ãƒªãƒ«ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã®ä¸¡æ–¹ã¯ 128æ–‡å­—ä»¥ä¸Šã‚ã‚‹ã®ã§ã€128--255ã®é–“ã«ãŠã•ã‚ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../howto/unicode.rst:54
msgid ""
"You could write files using different codes (all your Russian files in a "
"coding system called KOI8, all your French files in a different coding "
"system called Latin1), but what if you wanted to write a French document "
"that quotes some Russian text?  In the 1980s people began to want to solve "
"this problem, and the Unicode standardization effort began."
msgstr "ç•°ãªã‚‹æ–‡å­—ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã™ã‚‹ã“ã¨ã¯å¯èƒ½ã§ã™ (æŒã£ã¦ã„ã‚‹ãƒ­ã‚·ã‚¢èªã®ãƒ•ã‚¡ã‚¤ãƒ«å…¨ã¦ã‚’ KOI8 ã¨å‘¼ã°ã‚Œã‚‹ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã§ã€æŒã£ã¦ã„ã‚‹ãƒ•ãƒ©ãƒ³ã‚¹èªã®ãƒ•ã‚¡ã‚¤ãƒ«å…¨ã¦ã‚’åˆ¥ã® Latin1 ã¨å‘¼ã°ã‚Œã‚‹ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã™ã‚‹ã“ã¨ã§)ã€ã—ã‹ã—ã€ãƒ­ã‚·ã‚¢èªã®æ–‡ç« ã‚’å¼•ç”¨ã™ã‚‹ãƒ•ãƒ©ãƒ³ã‚¹èªã®æ–‡ç« ã‚’æ›¸ããŸã„å ´åˆã«ã¯ã©ã†ã§ã—ã‚‡ã†? 1989å¹´ä»£ã«ã“ã®å•é¡Œã‚’è§£æ±ºã—ãŸã„ã¨ã„ã†è¦æœ›ãŒä¸Šã£ã¦ã€Unicode æ¨™æº–åŒ–ã®åŠªåŠ›ãŒå§‹ã¾ã‚Šã¾ã—ãŸã€‚"

#: ../../howto/unicode.rst:60
msgid ""
"Unicode started out using 16-bit characters instead of 8-bit characters.  16"
" bits means you have 2^16 = 65,536 distinct values available, making it "
"possible to represent many different characters from many different "
"alphabets; an initial goal was to have Unicode contain the alphabets for "
"every single human language. It turns out that even 16 bits isn't enough to "
"meet that goal, and the modern Unicode specification uses a wider range of "
"codes, 0--1,114,111 (0x10ffff in base-16)."
msgstr "Unicode ã¯ 8-bit ã®æ–‡å­—ã®ä»£ã‚ã‚Šã« 16-bit ã®æ–‡å­—ã‚’ä½¿ã†ã“ã¨ã«ã¨ã‚Šã‹ã‹ã‚Šã¾ã—ãŸã€‚ 16bit ä½¿ã†ã¨ã„ã†ã“ã¨ã¯ 2^16 = 65,536 ã®ç•°ãªã‚‹å€¤ãŒåˆ©ç”¨å¯èƒ½ã ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€ã“ã‚Œã«ã‚ˆã£ã¦å¤šãã®ç•°ãªã‚‹ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆä¸Šã®å¤šãã®ç•°ãªã‚‹æ–‡å­—ã‚’è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™; æœ€åˆã®ç›®æ¨™ã¯ Unicode ãŒäººé–“ãŒä½¿ã†å€‹ã€…ã®è¨€èªã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã‚’å«ã‚€ã“ã¨ã§ã—ãŸã€‚ã‚ã¨ã«ãªã£ã¦ã“ã®ç›®æ¨™ã‚’é”æˆã™ã‚‹ã«ã¯ 16bit ã§ã•ãˆã‚‚ä¸ååˆ†ã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã—ãŸã€ãã—ã¦æœ€æ–°ã® Unicode è¦æ ¼ã¯ 0--1,114,111 (16é€²è¡¨è¨˜ã§ 0x10ffff) ã¾ã§ã®ã‚ˆã‚Šåºƒã„æ–‡å­—ã‚³ãƒ¼ãƒ‰ã®å¹…ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:68
msgid ""
"There's a related ISO standard, ISO 10646.  Unicode and ISO 10646 were "
"originally separate efforts, but the specifications were merged with the 1.1"
" revision of Unicode."
msgstr "é–¢é€£ã™ã‚‹ ISO æ¨™æº–ã‚‚ ISO 10646 ãŒã‚ã‚Šã¾ã™ã€‚Unicode ã¨ ISO 10646 ã¯å…ƒã€…ç‹¬ç«‹ã—ãŸæˆæœã§ã—ãŸãŒã€ Unicode ã® 1.1 ãƒªãƒ“ã‚¸ãƒ§ãƒ³ã§ä»•æ§˜ã‚’ä½µåˆã—ã¾ã—ãŸã€‚"

#: ../../howto/unicode.rst:72
msgid ""
"(This discussion of Unicode's history is highly simplified.  I don't think "
"the average Python programmer needs to worry about the historical details; "
"consult the Unicode consortium site listed in the References for more "
"information.)"
msgstr "(ã“ã® Unicode ã®æ­´å²ã«ã¤ã„ã¦ã®è§£èª¬ã¯éå¸¸ã«å˜ç´”åŒ–ã—ã¦ã„ã¾ã™ã€‚å¹³å‡çš„ãª Python ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯æ­´å²çš„ãªè©³ç´°ã‚’æ°—ã«ã™ã‚‹å¿…è¦ã¯ç„¡ã„ã¨è€ƒãˆã¦ã„ã¾ã™; ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã¯å‚è€ƒæ–‡çŒ®ã«è¼‰ã›ãŸ Unicode ã‚³ãƒ³ã‚½ãƒ¼ã‚·ã‚¢ãƒ ã®ã‚µã‚¤ãƒˆã‚’å‚è€ƒã«ã—ã¦ä¸‹ã•ã„ã€‚)"

#: ../../howto/unicode.rst:78
msgid "Definitions"
msgstr "å®šç¾©"

#: ../../howto/unicode.rst:80
msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are 'Ãˆ' and 'Ã'.  Characters "
"are abstractions, and vary depending on the language or context you're "
"talking about.  For example, the symbol for ohms (â„¦) is usually drawn much "
"like the capital letter omega (Î©) in the Greek alphabet (they may even be "
"the same in some fonts), but these are two different characters that have "
"different meanings."
msgstr "**æ–‡å­—** ã¯æ–‡ç« ã®æ§‹æˆè¦ç´ ã®ä¸­ã®æœ€å°ã®ã‚‚ã®ã§ã™ã€‚'A', 'B', 'C' ãªã©ã¯å…¨ã¦ç•°ãªã‚‹æ–‡å­—ã§ã™ã€‚ 'Ãˆ' ã‚„ 'Ã' ã‚‚åŒæ§˜ã«ç•°ãªã‚‹æ–‡å­—ã§ã™ã€‚æ–‡å­—ã¯æŠ½è±¡çš„ãªæ¦‚å¿µã§ã€è¨€èªã‚„æ–‡è„ˆã«ä¾å­˜ã—ã¦ã•ã¾ã–ã¾ã«å¤‰åŒ–ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚ªãƒ¼ãƒ (â„¦) ã¯ãµã¤ã†å¤§æ–‡å­—ã‚®ãƒªã‚·ãƒ£æ–‡å­—ã®ã‚ªãƒ¡ã‚¬ (Î©) ã§æ›¸ã‹ã‚Œã¾ã™ãŒ (ã“ã‚Œã‚‰ã¯ã„ãã¤ã‹ã®ãƒ•ã‚©ãƒ³ãƒˆã§å…¨ãåŒã˜æ›¸ä½“ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“) ã—ã‹ã—ã€ã“ã‚Œã‚‰ã¯ç•°ãªã‚‹æ„å‘³ã‚’æŒã¤ç•°ãªã‚‹æ–‡å­—ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚"

#: ../../howto/unicode.rst:88
msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point is an integer value, usually denoted in base 16.  In"
" the standard, a code point is written using the notation U+12ca to mean the"
" character with value 0x12ca (4810 decimal).  The Unicode standard contains "
"a lot of tables listing characters and their corresponding code points::"
msgstr "Unicode æ¨™æº–ã¯æ–‡å­—ãŒ **ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ (code points)** ã§ã©ã†è¡¨ç¾ã™ã‚‹ã‹ã‚’è¨˜è¿°ã—ã¦ã„ã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯æ•´æ•°å€¤ã§ã€ãµã¤ã†16é€²è¡¨è¨˜ã§æ›¸ã‹ã‚Œã¾ã™ã€‚æ¨™æº–çš„ã«ã¯ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯ U+12ca ã®ã‚ˆã†ãªè¡¨è¨˜ã‚’ä½¿ã£ã¦æ›¸ã‹ã‚Œã¾ã™ã€ U+12ca ã¯ 0x12ca (10é€²è¡¨è¨˜ã§ 4810) ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€‚ Unicode æ¨™æº–ã¯æ–‡å­—ã¨ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å¯¾å¿œã•ã›ã‚‹å¤šãã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å«ã‚“ã§ã„ã¾ã™::"

#: ../../howto/unicode.rst:100
msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character U+12ca'.  U+12ca is a code point, which represents some particular"
" character; in this case, it represents the character 'ETHIOPIC SYLLABLE "
"WI'.  In informal contexts, this distinction between code points and "
"characters will sometimes be forgotten."
msgstr "å³å¯†ã«ã„ã†ã¨ã“ã‚Œã‚‰ã®å®šç¾©ã¯ã€Œã“ã®æ–‡å­—ã¯ U+12ca ã§ã™ã€ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã—ã¦ã„ã¾ã›ã‚“ã€‚ U+12ca ã¯ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ã€ç‰¹å®šã®æ–‡å­—ã‚’ç¤ºã—ã¦ã„ã¾ã™; ã“ã®å ´åˆã§ã¯ã€'ETHIOPIC SYLLABLE WI' ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ç´°ã‹ãæ°—ã«ã—ãªã„æ–‡è„ˆã®ä¸­ã§ã¯ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¨æ–‡å­—ã®åŒºåˆ¥ã¯å¿˜ã‚Œã‚‰ã‚Œã‚‹ã“ã¨ãŒã‚ˆãã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:106
msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the exact "
"details will depend on the font being used.  Most Python code doesn't need "
"to worry about glyphs; figuring out the correct glyph to display is "
"generally the job of a GUI toolkit or a terminal's font renderer."
msgstr "æ–‡å­—ã¯ç”»é¢ã‚„ç´™é¢ä¸Šã§ã¯ **ã‚°ãƒªãƒ• (glyph)** ã¨å‘¼ã°ã‚Œã‚‹ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯è¦ç´ ã®çµ„ã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚å¤§æ–‡å­—ã® A ã®ã‚°ãƒªãƒ•ã¯ä¾‹ãˆã°ã€å³å¯†ãªå½¢ã¯ä½¿ã£ã¦ã„ã‚‹ãƒ•ã‚©ãƒ³ãƒˆã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ãŒã€æ–œã‚ã®ç·šã¨æ°´å¹³ã®ç·šã§ã™ã€‚ãŸã„ã¦ã„ã® Python ã‚³ãƒ¼ãƒ‰ã§ã¯ã‚°ãƒªãƒ•ã®å¿ƒé…ã‚’ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“; ä¸€èˆ¬çš„ã«ã¯è¡¨ç¤ºã™ã‚‹æ­£ã—ã„ã‚°ãƒªãƒ•ã‚’è¦‹ä»˜ã‘ã‚‹ã“ã¨ã¯ GUI toolkit ã‚„ç«¯æœ«ã®ãƒ•ã‚©ãƒ³ãƒˆãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ä»•äº‹ã§ã™ã€‚"

#: ../../howto/unicode.rst:115
msgid "Encodings"
msgstr "ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°"

#: ../../howto/unicode.rst:117
msgid ""
"To summarize the previous section: a Unicode string is a sequence of code "
"points, which are numbers from 0 to 0x10ffff.  This sequence needs to be "
"represented as a set of bytes (meaning, values from 0--255) in memory.  The "
"rules for translating a Unicode string into a sequence of bytes are called "
"an **encoding**."
msgstr "å‰ã®ç¯€ã‚’ã¾ã¨ã‚ã‚‹ã¨: Unicode æ–‡å­—åˆ—ã¯ 0 ã‹ã‚‰ 0x10ffff ã¾ã§ã®æ•°å€¤ã§ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ãƒ¡ãƒ¢ãƒªä¸Šã§ãƒã‚¤ãƒˆ (0 ã‹ã‚‰ 255 ã¾ã§ã®å€¤) ã®çµ„ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒã‚¤ãƒˆåˆ—ã‚’ Unicode æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹è¦å‰‡ã‚’ **ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° (encoding)** ã¨å‘¼ã³ã¾ã™ã€‚"

#: ../../howto/unicode.rst:123
msgid ""
"The first encoding you might think of is an array of 32-bit integers.  In "
"this representation, the string \"Python\" would look like this::"
msgstr "æœ€åˆã«è€ƒãˆã‚‹ã§ã‚ã‚ã†ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ 32-bit æ•´æ•°ã®é…åˆ—ã§ã—ã‚‡ã†ã€‚ã“ã®è¡¨ç¤ºã§ã¯ã€\"Python\" ã¨ã„ã†æ–‡å­—åˆ—ã¯ã“ã†ã¿ãˆã¾ã™::"

#: ../../howto/unicode.rst:130
msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr "ã“ã®è¡¨ç¾ã¯ç›´æ¥çš„ã§ã‚ã‹ã‚Šã‚„ã™ã„æ–¹æ³•ã§ã™ãŒã€ã“ã®è¡¨ç¾ã‚’ä½¿ã†ã«ã¯ã„ãã¤ã‹ã®å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:133
msgid "It's not portable; different processors order the bytes differently."
msgstr "å¯æ¬æ€§ãŒãªã„; ãƒ—ãƒ­ã‚»ãƒƒã‚µãŒç•°ãªã‚‹ã¨ãƒã‚¤ãƒˆã®é †åºã¥ã‘ã‚‚å¤‰ã‚ã£ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:135
msgid ""
"It's very wasteful of space.  In most texts, the majority of the code points"
" are less than 127, or less than 255, so a lot of space is occupied by zero "
"bytes.  The above string takes 24 bytes compared to the 6 bytes needed for "
"an ASCII representation.  Increased RAM usage doesn't matter too much "
"(desktop computers have megabytes of RAM, and strings aren't usually that "
"large), but expanding our usage of disk and network bandwidth by a factor of"
" 4 is intolerable."
msgstr "ç©ºé–“ã‚’ç„¡é§„ã«ä½¿ã£ã¦ã—ã¾ã„ã¾ã™ã€‚å¤šãã®æ–‡æ›¸ã§ã¯ã€ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å¤šãã¯ 127 ã‹ 255 ã‚ˆã‚Šå°ã•ã„ãŸã‚å¤šãã®ç©ºé–“ãŒã‚¼ãƒ­ãƒã‚¤ãƒˆã«å æœ‰ã•ã‚Œã¾ã™ã€‚ä¸Šã®æ–‡å­—åˆ—ã¯ASCIIè¡¨ç¤ºã§ã¯6ãƒã‚¤ãƒˆã‚’å¿…è¦ã ã£ãŸã®ã«å¯¾ã—ã¦24ãƒã‚¤ãƒˆã‚’å¿…è¦ã¨ã—ã¦ã„ã¾ã™ã€‚ RAM ã®ä½¿ç”¨æ–™ã®å¢—åŠ ã¯ãŸã„ã—ãŸå•é¡Œã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒ (ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã¯ RAM ã‚’ãƒ¡ã‚¬ãƒã‚¤ãƒˆå˜ä½ã§æŒã£ã¦ã„ã¾ã™ã—ã€æ–‡å­—åˆ—ã¯ãã“ã¾ã§å¤§ãã„å®¹é‡ã«ã¯ãªã‚Šã¾ã›ã‚“)ã€ã—ã‹ã—ã€ãƒ‡ã‚£ã‚¹ã‚¯ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å¸¯åŸŸãŒ4å€å¢—ãˆã‚‹ã“ã¨ã¯ã¨ã¦ã‚‚æˆ‘æ…¢ã§ãã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../howto/unicode.rst:143
msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a new"
" family of wide string functions would need to be used."
msgstr "``strlen()`` ã®ã‚ˆã†ãªç¾å­˜ã™ã‚‹ C é–¢æ•°ã¨äº’æ›æ€§ãŒã‚ã‚Šã¾ã›ã‚“ã€ãã®ãŸã‚ãƒ¯ã‚¤ãƒ‰æ–‡å­—åˆ—é–¢æ•°ä¸€å¼ãŒæ–°ãŸã«å¿…è¦ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:146
msgid ""
"Many Internet standards are defined in terms of textual data, and can't "
"handle content with embedded zero bytes."
msgstr "å¤šãã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¨™æº–ãŒãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¦ã€ãã‚Œã‚‰ã¯ã‚¼ãƒ­ãƒã‚¤ãƒˆã®åŸ‹ã‚è¾¼ã¾ã‚ŒãŸå†…å®¹ã‚’æ‰±ã†ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚"

#: ../../howto/unicode.rst:149
msgid ""
"Generally people don't use this encoding, instead choosing other encodings "
"that are more efficient and convenient.  UTF-8 is probably the most commonly"
" supported encoding; it will be discussed below."
msgstr "ä¸€èˆ¬çš„ã«ã“ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ä½¿ã‚ãšã€å¤‰ã‚ã‚Šã«ã‚ˆã‚ŠåŠ¹ç‡çš„ã§ä¾¿åˆ©ãªä»–ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒé¸ã°ã‚Œã¦ã„ã¾ã™ã€‚ UTF-8 ã¯ãŸã¶ã‚“æœ€ã‚‚ä¸€èˆ¬çš„ã«ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã™ã€‚ã“ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«ã¤ã„ã¦ã¯å¾Œã§èª¬æ˜ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:153
msgid ""
"Encodings don't have to handle every possible Unicode character, and most "
"encodings don't.  For example, Python's default encoding is the 'ascii' "
"encoding.  The rules for converting a Unicode string into the ASCII encoding"
" are simple; for each code point:"
msgstr "ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯å…¨ã¦ã® Unicode æ–‡å­—ã‚’æ‰±ã†å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã—ã€å¤šãã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ãã‚Œã‚’ã—ã¾ã›ã‚“ã€‚ä¾‹ãˆã° Python ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã® 'ascii' ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã€‚ Unicode æ–‡å­—åˆ—ã‚’ ASCII ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«å¤‰æ›ã™ã‚‹è¦å‰‡ã¯å˜ç´”ã§ã™; ãã‚Œãã‚Œã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«å¯¾ã—ã¦:"

#: ../../howto/unicode.rst:158
msgid ""
"If the code point is < 128, each byte is the same as the value of the code "
"point."
msgstr "ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯128ã‚ˆã‚Šå°ã•ã„å ´åˆã€ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¨åŒã˜å€¤ã§ã™ã€‚"

#: ../../howto/unicode.rst:161
msgid ""
"If the code point is 128 or greater, the Unicode string can't be represented"
" in this encoding.  (Python raises a :exc:`UnicodeEncodeError` exception in "
"this case.)"
msgstr "ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒ128ä»¥ä¸Šã®å ´åˆã€Unicode æ–‡å­—åˆ—ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ (ã“ã®å ´åˆ Python ã¯ :exc:`UnicodeEncodeError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚)"

#: ../../howto/unicode.rst:165
msgid ""
"Latin-1, also known as ISO-8859-1, is a similar encoding.  Unicode code "
"points 0--255 are identical to the Latin-1 values, so converting to this "
"encoding simply requires converting code points to byte values; if a code "
"point larger than 255 is encountered, the string can't be encoded into "
"Latin-1."
msgstr "Latin-1, ISO-8859-1 ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚‚åŒæ§˜ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã™ã€‚Unicode ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã® 0--255 ã¯ Latin-1 ã®å€¤ã¨ç­‰ä¾¡ãªã®ã§ã€ã“ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®å¤‰æ›ã™ã‚‹ã«ã¯ã€å˜ç´”ã«ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ãƒã‚¤ãƒˆå€¤ã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™; ã‚‚ã—ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒ255ã‚ˆã‚Šå¤§ãã„å ´åˆã«é­é‡ã—ãŸå ´åˆã€æ–‡å­—åˆ—ã¯ Latin-1 ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ãã¾ã›ã‚“ã€‚"

#: ../../howto/unicode.rst:170
msgid ""
"Encodings don't have to be simple one-to-one mappings like Latin-1.  "
"Consider IBM's EBCDIC, which was used on IBM mainframes.  Letter values "
"weren't in one block: 'a' through 'i' had values from 129 to 137, but 'j' "
"through 'r' were 145 through 153.  If you wanted to use EBCDIC as an "
"encoding, you'd probably use some sort of lookup table to perform the "
"conversion, but this is largely an internal detail."
msgstr "ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ Latin-1 ã®ã‚ˆã†ã«å˜ç´”ãªä¸€å¯¾ä¸€å¯¾å¿œã‚’æŒã£ã¦ã„ã¾ã›ã‚“ã€‚ IBM ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ã§ä½¿ã‚ã‚Œã¦ã„ãŸ IBM ã® EBCDIC ã§è€ƒãˆã¦ã¿ã¾ã™ã€‚æ–‡å­—ã¯ä¸€ã¤ã®ãƒ–ãƒ­ãƒƒã‚¯ã«åã‚ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã§ã—ãŸ: 'a' ã‹ã‚‰ 'i' ã¯ 129 ã‹ã‚‰ 137 ã¾ã§ã§ã—ãŸãŒã€ 'j' ã‹ã‚‰ 'r' ã¾ã§ã¯ 145 ã‹ã‚‰ 153 ã¾ã§ã—ãŸã€‚ EBICIC ã‚’ä½¿ã„ãŸã„ã¨æ€ã£ãŸã‚‰ã€ãŠãã‚‰ãå¤‰æ›ã‚’å®Ÿè¡Œã™ã‚‹ãƒ«ãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ†ãƒ¼ãƒ–ãƒ«ã®é¡ã‚’ä½¿ã†å¿…è¦ãŒã‚ã‚‹ã§ã—ã‚‡ã†ã€ã“ã‚Œã¯å†…éƒ¨ã®è©³ç´°ã®ã“ã¨ã«ãªã‚Šã¾ã™ãŒã€‚"

#: ../../howto/unicode.rst:177
msgid ""
"UTF-8 is one of the most commonly used encodings.  UTF stands for \"Unicode "
"Transformation Format\", and the '8' means that 8-bit numbers are used in "
"the encoding.  (There's also a UTF-16 encoding, but it's less frequently "
"used than UTF-8.)  UTF-8 uses the following rules:"
msgstr "UTF-8 ã¯æœ€ã‚‚ã‚ˆãä½¿ã‚ã‚Œã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ä¸€ã¤ã§ã™. UTF ã¯ \"Unicode Transformation Format\" ã‹ã‚‰ã¨ã‚‰ã‚Œã¦ã„ã¦ã€ 8 ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã« 8-bit ã®æ•°å­—ã‚’ä½¿ã†ã“ã¨ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€‚ (åŒã˜ã UTF-16 ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚‚ã‚ã‚Šã¾ã™ã€ã—ã‹ã—ã“ã¡ã‚‰ã¯ UTF-8 ã»ã©é »ç¹ã«ä½¿ã‚ã‚Œã¦ã„ã¾ã›ã‚“ã€‚) UTF-8 ã¯ä»¥ä¸‹ã®è¦å‰‡ã‚’åˆ©ç”¨ã—ã¾ã™:"

#: ../../howto/unicode.rst:182
msgid ""
"If the code point is <128, it's represented by the corresponding byte value."
msgstr "ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒ128ã‚ˆã‚Šå°ã•ã„å ´åˆã€å¯¾å¿œã™ã‚‹ãƒã‚¤ãƒˆå€¤ã§è¡¨ç¾ã€‚"

#: ../../howto/unicode.rst:183
msgid ""
"If the code point is between 128 and 0x7ff, it's turned into two byte values"
" between 128 and 255."
msgstr "ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯128ã‹ã‚‰0x7ff ã®é–“ã®å ´åˆã€128ã‹ã‚‰255ã¾ã§ã®2ãƒã‚¤ãƒˆå€¤ã«å¤‰æ›ã€‚"

#: ../../howto/unicode.rst:185
msgid ""
"Code points >0x7ff are turned into three- or four-byte sequences, where each"
" byte of the sequence is between 128 and 255."
msgstr "0x7ff ã‚ˆã‚Šå¤§ãã„ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯3ã‹4ãƒã‚¤ãƒˆåˆ—ã«å¤‰æ›ã—ã€ãƒã‚¤ãƒˆåˆ—ã®ãã‚Œãã‚Œã®ãƒã‚¤ãƒˆã¯128ã‹ã‚‰255ã®é–“ã‚’ã¨ã‚‹ã€‚"

#: ../../howto/unicode.rst:188
msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8 ã¯ã„ãã¤ã‹ã®ä¾¿åˆ©ãªæ€§è³ªã‚’æŒã£ã¦ã„ã¾ã™:"

#: ../../howto/unicode.rst:190
msgid "It can handle any Unicode code point."
msgstr "ä»»æ„ã® Unicode ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’æ‰±ã†ã“ã¨ãŒã§ãã‚‹ã€‚"

#: ../../howto/unicode.rst:191
msgid ""
"A Unicode string is turned into a string of bytes containing no embedded "
"zero bytes.  This avoids byte-ordering issues, and means UTF-8 strings can "
"be processed by C functions such as ``strcpy()`` and sent through protocols "
"that can't handle zero bytes."
msgstr "Unicode æ–‡å­—åˆ—ã‚’ã‚¼ãƒ­ãƒã‚¤ãƒˆã§åŸ‹ã‚ãªã„ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹ã€‚ã“ã‚Œã«ã‚ˆã£ã¦ãƒã‚¤ãƒˆé †ã®å•é¡Œã‚’è§£æ±ºã—ã€UTF-8 æ–‡å­—åˆ—ã‚’ ``strcpy()`` ã®ã‚ˆã†ãª C é–¢æ•°ã§å‡¦ç†ã™ã‚‹ã“ã¨ãŒã§ãã€ãã—ã¦ã‚¼ãƒ­ãƒã‚¤ãƒˆã‚’æ‰±ã†ã“ã¨ãŒã§ããªã„ãƒ—ãƒ­ãƒˆã‚³ãƒ«çµŒç”±ã§é€ä¿¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../howto/unicode.rst:195
msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "ASCII ãƒ†ã‚­ã‚¹ãƒˆã®æ–‡å­—åˆ—ã¯ UTF-8 ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦ã‚‚æœ‰åŠ¹ã§ã™ã€‚"

#: ../../howto/unicode.rst:196
msgid ""
"UTF-8 is fairly compact; the majority of code points are turned into two "
"bytes, and values less than 128 occupy only a single byte."
msgstr "UTF-8 ã¯ã‹ãªã‚Šã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã§ã™; ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å¤šãã¯2ãƒã‚¤ãƒˆã«å¤‰æ›ã•ã‚Œã€å€¤ãŒ128ã‚ˆã‚Šå°ã•ã‘ã‚Œã°ã€1ãƒã‚¤ãƒˆã—ã‹å æœ‰ã—ã¾ã›ã‚“ã€‚"

#: ../../howto/unicode.rst:198
msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of the "
"next UTF-8-encoded code point and resynchronize.  It's also unlikely that "
"random 8-bit data will look like valid UTF-8."
msgstr "ãƒã‚¤ãƒˆãŒæ¬ è½ã—ãŸã‚Šã€å¤±ã‚ã‚ŒãŸå ´åˆã€æ¬¡ã® UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®é–‹å§‹ã‚’æ±ºå®šã—ã€å†åŒæœŸã™ã‚‹ã“ã¨ãŒã§ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚åŒæ§˜ã®ç†ç”±ã§ãƒ©ãƒ³ãƒ€ãƒ ãª 8-bit ãƒ‡ãƒ¼ã‚¿ã¯æ­£å½“ãª UTF-8 ã¨ã¿ãªã•ã‚Œã«ãããªã£ã¦ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:205 ../../howto/unicode.rst:492
#: ../../howto/unicode.rst:688
msgid "References"
msgstr "å‚è€ƒè³‡æ–™"

#: ../../howto/unicode.rst:207
msgid ""
"The Unicode Consortium site at <http://www.unicode.org> has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  <http://www.unicode.org/history/> is a"
" chronology of the origin and development of Unicode."
msgstr "Unicode ã‚³ãƒ³ã‚½ãƒ¼ã‚·ã‚¢ãƒ ã®ã‚µã‚¤ãƒˆ <http://www.unicode.org> ã«ã¯æ–‡å­—ã®å›³è¡¨ã‚„ç”¨èªè¾å…¸ã€ãã—ã¦ Unicode ä»•æ§˜ã® PDF ãŒã‚ã‚Šã¾ã™ã€‚èª­ã‚€ã®ã¯ç°¡å˜ã§ã¯ãªã„ã®ã§è¦šæ‚Ÿã—ã¦ä¸‹ã•ã„ã€‚ <http://www.unicode.org/history/> ã¯ Unicode ã®èµ·æºã¨ç™ºå±•ã®å¹´è¡¨ã§ã™ã€‚"

#: ../../howto/unicode.rst:212
msgid ""
"To help understand the standard, Jukka Korpela has written an introductory "
"guide to reading the Unicode character tables, available at "
"<https://www.cs.tut.fi/~jkorpela/unicode/guide.html>."
msgstr "æ¨™æº–ã«ã¤ã„ã¦ã®ç†è§£ã‚’åŠ©ã‘ã‚‹ãŸã‚ã« Jukka Korpela ãŒ Unicode ã®æ–‡å­—è¡¨ã‚’èª­ã‚€ãŸã‚ã®å°å…¥ã‚¬ã‚¤ãƒ‰ã‚’æ›¸ã„ã¦ã„ã¾ã™ã€ <https://www.cs.tut.fi/~jkorpela/unicode/guide.html> ã‹ã‚‰å…¥æ‰‹å¯èƒ½ã§ã™ã€‚"

#: ../../howto/unicode.rst:216
msgid ""
"Another good introductory article was written by Joel Spolsky "
"<http://www.joelonsoftware.com/articles/Unicode.html>. If this introduction "
"didn't make things clear to you, you should try reading this alternate "
"article before continuing."
msgstr "ã‚‚ã†ä¸€ã¤ã®ã‚ˆã„å…¥é–€è¨˜äº‹ <http://www.joelonsoftware.com/articles/Unicode.html> ã‚’ Joel Spolsky ãŒæ›¸ã„ã¦ã„ã¾ã™ã€‚ã‚‚ã—ã“ã® HOWTO ã®å…¥é–€ãŒæ˜è§£ã«æ„Ÿã˜ãªã‹ã£ãŸå ´åˆã«ã¯ã€ç¶šãã‚’èª­ã‚€å‰ã«ã“ã®è¨˜äº‹ã‚’èª­ã‚“ã§ã¿ã‚‹ã¹ãã§ã™ã€‚"

#: ../../howto/unicode.rst:223
msgid ""
"Wikipedia entries are often helpful; see the entries for \"character "
"encoding\" <http://en.wikipedia.org/wiki/Character_encoding> and UTF-8 "
"<http://en.wikipedia.org/wiki/UTF-8>, for example."
msgstr "Wikipedia ã®è¨˜äº‹ã¯ã—ã°ã—ã°å½¹ã«ç«‹ã¡ã¾ã™; è©¦ã—ã« \"character encoding\" <http://en.wikipedia.org/wiki/Character_encoding> ã®è¨˜äº‹ã¨ UTF-8 <http://en.wikipedia.org/wiki/UTF-8> ã®è¨˜äº‹ã‚’èª­ã‚“ã§ã¿ã¦ä¸‹ã•ã„ã€‚"

#: ../../howto/unicode.rst:229
msgid "Python 2.x's Unicode Support"
msgstr "Python 2.x ã® Unicode ã‚µãƒãƒ¼ãƒˆ"

#: ../../howto/unicode.rst:231
msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's "
"Unicode features."
msgstr "ã“ã“ã¾ã§ã§ Unicode ã®åŸºç¤ã‚’å­¦ã³ã¾ã—ãŸã€ã“ã“ã‹ã‚‰ Python ã® Unicode æ©Ÿèƒ½ã«è§¦ã‚Œã¾ã™ã€‚"

#: ../../howto/unicode.rst:236
msgid "The Unicode Type"
msgstr "Unicode å‹"

#: ../../howto/unicode.rst:238
msgid ""
"Unicode strings are expressed as instances of the :class:`unicode` type, one"
" of Python's repertoire of built-in types.  It derives from an abstract type"
" called :class:`basestring`, which is also an ancestor of the :class:`str` "
"type; you can therefore check if a value is a string type with "
"``isinstance(value, basestring)``.  Under the hood, Python represents "
"Unicode strings as either 16- or 32-bit integers, depending on how the "
"Python interpreter was compiled."
msgstr "Unicode æ–‡å­—åˆ—ã¯ Python ã®çµ„ã¿è¾¼ã¿å‹ã®ä¸€ã¤ :class:`unicode` å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¾ã™ã€‚ :class:`basestring` ã¨å‘¼ã°ã‚Œã‚‹æŠ½è±¡ã‚¯ãƒ©ã‚¹ã‹ã‚‰æ´¾ç”Ÿã—ã¦ã„ã¾ã™ã€ :class:`str` å‹ã®è¦ªæˆšã§ã‚‚ã‚ã‚Šã¾ã™; ãã®ãŸã‚ ``isinstance(value, basestring)`` ã§æ–‡å­—åˆ—å‹ã‹ã©ã†ã‹èª¿ã¹ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ Python å†…éƒ¨ã§ã¯ Unicode æ–‡å­—åˆ—ã¯16-bit, 32-bit æ•´æ•°ã®ã©ã¡ã‚‰ã‹ã§è¡¨ç¾ã•ã‚Œã€ã©ã¡ã‚‰ãŒä½¿ã‚ã‚Œã‚‹ã‹ã¯ Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒã©ã†ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸã‹ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:245
msgid ""
"The :func:`unicode` constructor has the signature ``unicode(string[, "
"encoding, errors])``.  All of its arguments should be 8-bit strings.  The "
"first argument is converted to Unicode using the specified encoding; if you "
"leave off the ``encoding`` argument, the ASCII encoding is used for the "
"conversion, so characters greater than 127 will be treated as errors::"
msgstr ":func:`unicode` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ ``unicode(string[, encoding, errors])`` ã¨ã„ã†ç”¨æ³•ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã“ã®å¼•æ•°ã¯å…¨ã¦ 8-bit æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚æœ€åˆã®å¼•æ•°ã¯æŒ‡å®šã—ãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã£ã¦ Unicode ã«å¤‰æ›ã•ã‚Œã¾ã™; ``encoding`` å¼•æ•°ã‚’æ¸¡ã•ãªã„å ´åˆã€å¤‰æ›ã«ã¯ ASCII ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒä½¿ã‚ã‚Œã¾ã™ã€ãã®ãŸã‚ 127 ã‚ˆã‚Šå¤§ãã„æ–‡å­—ã¯ã‚¨ãƒ©ãƒ¼ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™::"

#: ../../howto/unicode.rst:262
msgid ""
"The ``errors`` argument specifies the response when the input string can't "
"be converted according to the encoding's rules.  Legal values for this "
"argument are 'strict' (raise a ``UnicodeDecodeError`` exception), 'replace' "
"(add U+FFFD, 'REPLACEMENT CHARACTER'), or 'ignore' (just leave the character"
" out of the Unicode result).  The following examples show the differences::"
msgstr "``errors`` å¼•æ•°ã¯å…¥åŠ›æ–‡å­—åˆ—ãŒã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦å‰‡ã«å¾“ã£ã¦å¤‰æ›ã§ããªã„ã¨ãã®å¯¾å¿œã‚’æŒ‡å®šã—ã¾ã™ã€‚ã“ã®å¼•æ•°ã«æœ‰åŠ¹ãªå€¤ã¯ 'strict' (``UnicodeDecodeError`` ã‚’é€å‡ºã™ã‚‹)ã€ 'replace' (U+FFFD, 'REPLACEMENT CHARACTER' ã‚’è¿½åŠ ã™ã‚‹)ã€ã¾ãŸã¯ 'ignore' (çµæœã® Unicode æ–‡å­—åˆ—ã‹ã‚‰æ–‡å­—ã‚’é™¤ãã ã‘) ã§ã™ã€‚ä»¥ä¸‹ã®ä¾‹ã§é•ã„ã‚’ç¤ºã—ã¾ã™::"

#: ../../howto/unicode.rst:278
msgid ""
"Encodings are specified as strings containing the encoding's name.  Python "
"2.7 comes with roughly 100 different encodings; see the Python Library "
"Reference at :ref:`standard-encodings` for a list.  Some encodings have "
"multiple names; for example, 'latin-1', 'iso_8859_1' and '8859' are all "
"synonyms for the same encoding."
msgstr "ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°åã‚’å«ã‚€æ–‡å­—åˆ—ã«ã‚ˆã£ã¦æŒ‡å®šã•ã‚Œã¾ã™ã€‚ Python 2.7 ã§ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ãŠã‚ˆã100ã«åŠã³ã¾ã™; ä¸€è¦§ã¯ Python ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¬ãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã® :ref:`standard-encodings` ã‚’å‚ç…§ã—ã¦ä¸‹ã•ã„ã€‚ã„ãã¤ã‹ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯è¤‡æ•°ã®åå‰ã‚’æŒã£ã¦ã„ã¾ã™; ä¾‹ãˆã° 'latin-1', 'iso_8859_1', ãã—ã¦ '8859' ã“ã‚Œã‚‰ã¯å…¨ã¦åŒã˜ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®åˆ¥ç§°ã§ã™ã€‚"

#: ../../howto/unicode.rst:284
msgid ""
"One-character Unicode strings can also be created with the :func:`unichr` "
"built-in function, which takes integers and returns a Unicode string of "
"length 1 that contains the corresponding code point.  The reverse operation "
"is the built-in :func:`ord` function that takes a one-character Unicode "
"string and returns the code point value::"
msgstr "Unicode æ–‡å­—åˆ—ã®ä¸€ã¤ã®æ–‡å­—ã¯ :func:`unichr` çµ„ã¿è¾¼ã¿é–¢æ•°ã§ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€ã“ã®é–¢æ•°ã¯æ•´æ•°ã‚’å¼•æ•°ã«ã¨ã‚Šã€å¯¾å¿œã™ã‚‹ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å«ã‚€é•·ã•1ã® Unicode æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚é€†ã®æ“ä½œã¯ :func:`ord` çµ„ã¿è¾¼ã¿é–¢æ•°ã§ã™ã€ã“ã®é–¢æ•°ã¯ä¸€æ–‡å­—ã® Unicode æ–‡å­—åˆ—ã‚’å¼•æ•°ã«ã¨ã‚Šã€ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆå€¤ã‚’è¿”ã—ã¾ã™::"

#: ../../howto/unicode.rst:295
msgid ""
"Instances of the :class:`unicode` type have many of the same methods as the "
"8-bit string type for operations such as searching and formatting::"
msgstr ":class:`unicode` å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯å¤šãã® 8-bit æ–‡å­—åˆ—å‹ã¨åŒã˜æ¤œç´¢ã‚„æ›¸å¼æŒ‡å®šã®ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã™::"

#: ../../howto/unicode.rst:310
msgid ""
"Note that the arguments to these methods can be Unicode strings or 8-bit "
"strings.  8-bit strings will be converted to Unicode before carrying out the"
" operation; Python's default ASCII encoding will be used, so characters "
"greater than 127 will cause an exception::"
msgstr "ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å¼•æ•°ã¯ Unicode æ–‡å­—åˆ—ã¾ãŸã¯ 8-bit æ–‡å­—åˆ—ãŒä½¿ãˆã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚ 8-bit æ–‡å­—åˆ—ã¯æ“ä½œã«ä½¿ã‚ã‚Œã‚‹å‰ã« Unicode ã«å¤‰æ›ã•ã‚Œã¾ã™; Python ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® ASCII ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒåˆ©ç”¨ã•ã‚Œã‚‹ãŸã‚ã€127ã‚ˆã‚Šå¤§ãã„æ–‡å­—åˆ—ã¯ä¾‹å¤–ã‚’å¼•ãèµ·ã—ã¾ã™::"

#: ../../howto/unicode.rst:323
msgid ""
"Much Python code that operates on strings will therefore work with Unicode "
"strings without requiring any changes to the code.  (Input and output code "
"needs more updating for Unicode; more on this later.)"
msgstr "æ–‡å­—åˆ—æ“ä½œã‚’è¡Œãªã†å¤šãã® Python ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ¼ãƒ‰ã®å¤‰æ›´ç„¡ã—ã« Unicode æ–‡å­—åˆ—ã‚’æ‰±ã†ã“ã¨ãŒã§ãã‚‹ã§ã—ã‚‡ã†ã€‚ (å…¥å‡ºåŠ›ã«é–¢ã—ã¦ã¯ Unicode ã®ãŸã‚ã®æ›´æ–°ãŒå¿…è¦ã«ãªã‚Šã¾ã™; è©³ã—ãã¯å¾Œã§è¿°ã¹ã¾ã™ã€‚)"

#: ../../howto/unicode.rst:327
msgid ""
"Another important method is ``.encode([encoding], [errors='strict'])``, "
"which returns an 8-bit string version of the Unicode string, encoded in the "
"requested encoding.  The ``errors`` parameter is the same as the parameter "
"of the ``unicode()`` constructor, with one additional possibility; as well "
"as 'strict', 'ignore', and 'replace', you can also pass 'xmlcharrefreplace' "
"which uses XML's character references.  The following example shows the "
"different results::"
msgstr "åˆ¥ã®é‡è¦ãªãƒ¡ã‚½ãƒƒãƒ‰ã¯ ``.encode([encoding], [errors='strict'])`` ãŒã‚ã‚Šã¾ã™ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ Unicode æ–‡å­—åˆ—ã‚’è¦æ±‚ã—ãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸ 8-bit æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ ``errors`` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ ``unicode()`` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨åŒæ§˜ã§ã™ãŒã€ã‚‚ã†ä¸€ã¤å¯èƒ½æ€§ãŒè¿½åŠ ã•ã‚Œã¦ã„ã¾ã™; åŒæ§˜ã®ã‚‚ã®ã¨ã—ã¦ 'strict', 'ignore', ãã—ã¦ 'replace' ãŒã‚ã‚Šã€ã•ã‚‰ã« XML æ–‡å­—å‚ç…§ã‚’ä½¿ã† 'xmlcharrefreplace' ã‚’æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™::"

#: ../../howto/unicode.rst:349
msgid ""
"Python's 8-bit strings have a ``.decode([encoding], [errors])`` method that "
"interprets the string using the given encoding::"
msgstr "Python ã® 8-bit æ–‡å­—åˆ—ã¯ ``.decode([encoding], [errors])`` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã™ã€ã“ã‚Œã¯ä¸ãˆãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã£ã¦æ–‡å­—åˆ—ã‚’è§£é‡ˆã—ã¾ã™::"

#: ../../howto/unicode.rst:360
msgid ""
"The low-level routines for registering and accessing the available encodings"
" are found in the :mod:`codecs` module.  However, the encoding and decoding "
"functions returned by this module are usually more low-level than is "
"comfortable, so I'm not going to describe the :mod:`codecs` module here.  If"
" you need to implement a completely new encoding, you'll need to learn about"
" the :mod:`codecs` module interfaces, but implementing encodings is a "
"specialized task that also won't be covered here.  Consult the Python "
"documentation to learn more about this module."
msgstr ":mod:`codecs` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«åˆ©ç”¨å¯èƒ½ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ç™»éŒ²ã—ãŸã‚Šã€ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ä½ãƒ¬ãƒ™ãƒ«ãƒ«ãƒ¼ãƒãƒ³ãŒã‚ã‚Šã¾ã™ã€‚ã—ã‹ã—ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¿”ã™ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¨ãƒ‡ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é–¢æ•°ã¯ãµã¤ã†ä½ãƒ¬ãƒ™ãƒ«ã™ãã¦å¿«é©ã¨ã¯ã„ãˆã¾ã›ã‚“ã€ãã®ãŸã‚ã“ã“ã§ :mod:`codecs` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦è¿°ã¹ãªã„ã“ã¨ã«ã—ã¾ã™ã€‚ã‚‚ã—ã€å…¨ãæ–°ã—ã„ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Œã°ã€ :mod:`codecs` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã«ã¤ã„ã¦å­¦ã¶å¿…è¦ãŒã‚ã‚Šã¾ã™ã€ã—ã‹ã—ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®å®Ÿè£…ã¯ç‰¹æ®Šãªä½œæ¥­ãªã®ã§ã€ã“ã“ã§ã¯æ‰±ã„ã¾ã›ã‚“ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦å­¦ã¶ã«ã¯ Python ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../howto/unicode.rst:368
msgid ""
"The most commonly used part of the :mod:`codecs` module is the "
":func:`codecs.open` function which will be discussed in the section on input"
" and output."
msgstr ":mod:`codecs` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¸­ã§æœ€ã‚‚ä½¿ã‚ã‚Œã‚‹ã®ã¯ :func:`codecs.open` é–¢æ•°ã§ã™ã€ã“ã®é–¢æ•°ã¯å…¥å‡ºåŠ›ã®ç¯€ã§è­°é¡Œã«æŒ™ã’ã¾ã™ã€‚"

#: ../../howto/unicode.rst:374
msgid "Unicode Literals in Python Source Code"
msgstr "Python ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å†…ã® Unicode ãƒªãƒ†ãƒ©ãƒ«"

#: ../../howto/unicode.rst:376
msgid ""
"In Python source code, Unicode literals are written as strings prefixed with"
" the 'u' or 'U' character: ``u'abcdefghijk'``.  Specific code points can be "
"written using the ``\\u`` escape sequence, which is followed by four hex "
"digits giving the code point.  The ``\\U`` escape sequence is similar, but "
"expects 8 hex digits, not 4."
msgstr "Python ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å†…ã§ã¯ Unicode ãƒªãƒ†ãƒ©ãƒ«ã¯ 'u' ã¾ãŸã¯ 'U' ã®æ–‡å­—ã‚’æœ€åˆã«ä»˜ã‘ãŸæ–‡å­—åˆ—ã¨ã—ã¦æ›¸ã‹ã‚Œã¾ã™: ``u'abcdefghijk'`` ã€‚ç‰¹å®šã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ``\\u`` ã‚’ä½¿ã„ã€ç¶šã‘ã¦ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’4æ¡ã®16é€²æ•°ã‚’æ›¸ãã¾ã™ã€‚ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ``\\U`` ã‚‚åŒæ§˜ã§ã™ã€ãŸã ã—4æ¡ã§ã¯ãªã8æ¡ã®16é€²æ•°ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:382
msgid ""
"Unicode literals can also use the same escape sequences as 8-bit strings, "
"including ``\\x``, but ``\\x`` only takes two hex digits so it can't express"
" an arbitrary code point.  Octal escapes can go up to U+01ff, which is octal"
" 777."
msgstr "Unicode ãƒªãƒ†ãƒ©ãƒ«ã¯ 8-bit æ–‡å­—åˆ—ã¨åŒã˜ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€ä½¿ãˆã‚‹ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ã¯ ``\\x`` ã‚‚å«ã¿ã¾ã™ã€ãŸã ã— ``\\x`` ã¯2æ¡ã®16é€²æ•°ã—ã‹ã¨ã‚‹ã“ã¨ãŒã§ããªã„ã®ã§ä»»æ„ã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’è¡¨ç¾ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ 8é€²ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯8é€²æ•°ã®777ã‚’ç¤ºã™ U+01ff ã¾ã§ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../howto/unicode.rst:396
msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters, as"
" you would in a program with messages in French or some other accent-using "
"language.  You can also assemble strings using the :func:`unichr` built-in "
"function, but this is even more tedious."
msgstr "127 ã‚ˆã‚Šå¤§ãã„ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«å¯¾ã—ã¦ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ä½¿ã†ã®ã¯ã€ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒã‚ã¾ã‚Šå¤šããªã„ã†ã¡ã¯æœ‰åŠ¹ã§ã™ãŒã€ãƒ•ãƒ©ãƒ³ã‚¹èªç­‰ã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚’ä½¿ã†è¨€èªã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚ˆã†ãªå¤šãã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆæ–‡å­—ã‚’ä½¿ã†å ´åˆã«ã¯é‚ªé­”ã«ãªã‚Šã¾ã™ã€‚æ–‡å­—ã‚’ :func:`unichr` çµ„ã¿è¾¼ã¿é–¢æ•°ã‚’ä½¿ã£ã¦çµ„ã¿ä¸Šã’ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ãŒã€ãã‚Œã¯ã•ã‚‰ã«é•·ããªã£ã¦ã—ã¾ã†ã§ã—ã‚‡ã†ã€‚"

#: ../../howto/unicode.rst:402
msgid ""
"Ideally, you'd want to be able to write literals in your language's natural "
"encoding.  You could then edit Python source code with your favorite editor "
"which would display the accented characters naturally, and have the right "
"characters used at runtime."
msgstr "ç†æƒ³çš„ã«ã¯ã‚ãªãŸã®è¨€èªã®è‡ªç„¶ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ãƒªãƒ†ãƒ©ãƒ«ã‚’æ›¸ãã“ã¨ã§ã—ã‚‡ã†ã€‚ãã†ãªã‚Œã°ã€Python ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’ã‚¢ã‚¯ã‚»ãƒ³ãƒˆä»˜ãã®æ–‡å­—ã‚’è‡ªç„¶ã«è¡¨ç¤ºã™ã‚‹ãŠæ°—ã«å…¥ã‚Šã®ã‚¨ãƒ‡ã‚£ã‚¿ã§ç·¨é›†ã—ã€å®Ÿè¡Œæ™‚ã«æ­£ã—ã„æ–‡å­—ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../howto/unicode.rst:407
msgid ""
"Python supports writing Unicode literals in any encoding, but you have to "
"declare the encoding being used.  This is done by including a special "
"comment as either the first or second line of the source file::"
msgstr "Python ã¯ Unicode æ–‡å­—åˆ—ã‚’ä»»æ„ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€ãŸã ã—ã©ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã†ã‹ã‚’å®£è¨€ã—ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚ãã‚Œã¯ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸€è¡Œç›®ã‚„äºŒè¡Œç›®ã«ç‰¹åˆ¥ãªã‚³ãƒ¡ãƒ³ãƒˆã‚’å«ã‚ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã§ãã¾ã™::"

#: ../../howto/unicode.rst:417
msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local to"
" a file.  Emacs supports many different variables, but Python only supports "
"'coding'.  The ``-*-`` symbols indicate to Emacs that the comment is "
"special; they have no significance to Python but are a convention.  Python "
"looks for ``coding: name`` or ``coding=name`` in the comment."
msgstr "ã“ã®æ§‹æ–‡ã¯ Emacs ã®ãƒ•ã‚¡ã‚¤ãƒ«å›ºæœ‰ã®å¤‰æ•°ã‚’æŒ‡å®šã™ã‚‹è¡¨è¨˜ã‹ã‚‰å½±éŸ¿ã‚’å—ã‘ã¦ã„ã¾ã™ã€‚Emacs ã¯æ§˜ã€…ãªå¤‰æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ãŒã€Python ãŒã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã®ã¯ 'coding' ã®ã¿ã§ã™ã€‚ ``-*-`` ã®è¨˜æ³•ã¯ã‚³ãƒ¡ãƒ³ãƒˆãŒç‰¹åˆ¥ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™; ã“ã‚Œã¯ Python ã«ã¨ã£ã¦æ„å‘³ã¯ã‚ã‚Šã¾ã›ã‚“ãŒæ…£ç¿’ã§ã™ã€‚ Python ã¯ã‚³ãƒ¡ãƒ³ãƒˆä¸­ã« ``coding: name`` ã¾ãŸã¯ ``coding=name`` ã‚’æ¢ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:423
msgid ""
"If you don't include such a comment, the default encoding used will be "
"ASCII. Versions of Python before 2.4 were Euro-centric and assumed Latin-1 "
"as a default encoding for string literals; in Python 2.4, characters greater"
" than 127 still work but result in a warning.  For example, the following "
"program has no encoding declaration::"
msgstr "ã“ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å«ã¾ãªã„å ´åˆã«ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¨ã—ã¦ ASCII ãŒåˆ©ç”¨ã•ã‚Œã¾ã™ã€‚ Python ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒ 2.4 ã‚ˆã‚Šå‰ã®å ´åˆã«ã¯ Euro-centric ã¨ Latin-1 ãŒæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã‚ã‚‹ã¨ä»®å®šã•ã‚Œã¦ã„ã¾ã—ãŸ; Python 2.4 ã§ã¯ 127 ã‚ˆã‚Šå¤§ãã„æ–‡å­—ã§ã‚‚å‹•ä½œã—ã¾ã™ãŒã€è­¦å‘Šã‚’ç™ºã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å®£è¨€ã®ãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯::"

#: ../../howto/unicode.rst:433
msgid ""
"When you run it with Python 2.4, it will output the following warning::"
msgstr "ã“ã‚Œã‚’ Python 2.4 ã§å‹•ä½œã•ã›ãŸã¨ãã«ã¯ã€ä»¥ä¸‹ã®è­¦å‘ŠãŒå‡ºåŠ›ã•ã‚Œã¾ã™::"

#: ../../howto/unicode.rst:440
msgid "Python 2.5 and higher are stricter and will produce a syntax error::"
msgstr "Python 2.5 ä»¥é™ã§ã¯ã‚ˆã‚Šå³æ ¼ã«ãªã‚Šã€æ–‡æ³•ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™::"

#: ../../howto/unicode.rst:450
msgid "Unicode Properties"
msgstr "Unicode ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£"

#: ../../howto/unicode.rst:452
msgid ""
"The Unicode specification includes a database of information about code "
"points. For each code point that's defined, the information includes the "
"character's name, its category, the numeric value if applicable (Unicode has"
" characters representing the Roman numerals and fractions such as one-third "
"and four-fifths).  There are also properties related to the code point's use"
" in bidirectional text and other display-related properties."
msgstr "Unicode ä»•æ§˜ã¯ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«ã¤ã„ã¦ã®æƒ…å ±ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚å®šç¾©ã•ã‚ŒãŸå„ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«å¯¾ã—ã¦ã€æƒ…å ±ã¯æ–‡å­—ã®åå‰ã€ã‚«ãƒ†ã‚´ãƒªã€é©ç”¨å¯èƒ½ãªã‚‰ã°æ•°å€¤ (Unicode ã«ã¯ãƒ­ãƒ¼ãƒæ•°å­—ã‚„ 1/3 ã‚„ 4/5 ã®ã‚ˆã†ãªåˆ†æ•°ãªã©ã®æ–‡å­—ãŒã‚ã‚Šã¾ã™)ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å·¦å³ã©ã¡ã‚‰ã‹ã‚‰èª­ã‚€ã®ã‹ç­‰è¡¨ç¤ºã«é–¢é€£ã—ãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:459
msgid ""
"The following program displays some information about several characters, "
"and prints the numeric value of one particular character::"
msgstr "ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã„ãã¤ã‹ã®æ–‡å­—ã«å¯¾ã™ã‚‹æƒ…å ±ã‚’è¡¨ç¤ºã—ã€ç‰¹å®šã®æ–‡å­—ã®æ•°å€¤ã‚’å°å­—ã—ã¾ã™::"

#: ../../howto/unicode.rst:473
msgid "When run, this prints::"
msgstr "å®Ÿè¡Œæ™‚ã«ã¯ã€ã“ã®ã‚ˆã†ã«å°å­—ã•ã‚Œã¾ã™::"

#: ../../howto/unicode.rst:482
msgid ""
"The category codes are abbreviations describing the nature of the character."
" These are grouped into categories such as \"Letter\", \"Number\", "
"\"Punctuation\", or \"Symbol\", which in turn are broken up into "
"subcategories.  To take the codes from the above output, ``'Ll'`` means "
"'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is \"Mark, "
"nonspacing\", and ``'So'`` is \"Symbol, other\".  See "
"<http://www.unicode.org/reports/tr44/#General_Category_Values> for a list of"
" category codes."
msgstr "ã‚«ãƒ†ã‚´ãƒªã‚³ãƒ¼ãƒ‰ã¯æ–‡å­—ã®æ€§è³ªã‚’ç°¡å˜ã«èª¬æ˜ã™ã‚‹ã‚‚ã®ã§ã™ã€‚ã‚«ãƒ†ã‚´ãƒªã®åˆ†é¡ã¯ \"Letter\", \"Number\", \"Punctuation\" ã¾ãŸã¯ \"Symbol\" ã§ã€ã•ã‚‰ã«ã‚µãƒ–ã‚«ãƒ†ã‚´ãƒªã«åˆ†ã‹ã‚Œã¾ã™ã€‚ä¸Šã«å‡ºã¦ã„ã‚‹å‡ºåŠ›çµæœã‚’ä¾‹ã«ã¨ã‚‹ã¨ ``'Ll'`` ã¯ 'Letter, lowercase' ã‚’æ„å‘³ã—ã¦ã„ã¦ã€ ``'No'`` ã¯ \"Number, other\" ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€ ``'Mn'`` ã¯ \"Mark, nonspacing\" ã§ ``'So'`` ã¯ \"Symbol, other\" ã§ã™ã€‚ã‚«ãƒ†ã‚´ãƒªã‚³ãƒ¼ãƒ‰ã®ä¸€è¦§ã¯ <http://www.unicode.org/reports/tr44/#General_Category_Values> ã‚’å‚ç…§ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../howto/unicode.rst:494
msgid ""
"The Unicode and 8-bit string types are described in the Python library "
"reference at :ref:`typesseq`."
msgstr "Unicode ã¨ 8-bit æ–‡å­—å‹ã«ã¤ã„ã¦ã¯ Python ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¬ãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã® :ref:`typesseq` ã«è¨˜è¿°ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:497
msgid "The documentation for the :mod:`unicodedata` module."
msgstr ":mod:`unicodedata` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€‚"

#: ../../howto/unicode.rst:499
msgid "The documentation for the :mod:`codecs` module."
msgstr ":mod:`codecs` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€‚"

#: ../../howto/unicode.rst:501
msgid ""
"Marc-AndrÃ© Lemburg gave a presentation at EuroPython 2002 titled \"Python "
"and Unicode\".  A PDF version of his slides is available at "
"<https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>, and is an "
"excellent overview of the design of Python's Unicode features."
msgstr "Marc-AndrÃ© Lemburg ã¯ EuroPython 2002 ã§ \"Python and Unicode\" ã¨ã„ã†é¡Œã®ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¡Œãªã„ã¾ã—ãŸã€‚å½¼ã®ã‚¹ãƒ©ã‚¤ãƒ‰ã® PDF ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒ <https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf> ã‹ã‚‰å…¥æ‰‹ã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€Python ã® Unicode æ©Ÿèƒ½ã®ãƒ‡ã‚¶ã‚¤ãƒ³ã®ç´ æ™´ã—ã„æ¦‚è¦³ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:508
msgid "Reading and Writing Unicode Data"
msgstr "Unicode ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿æ›¸ãã™ã‚‹"

#: ../../howto/unicode.rst:510
msgid ""
"Once you've written some code that works with Unicode data, the next problem"
" is input/output.  How do you get Unicode strings into your program, and how"
" do you convert Unicode into a form suitable for storage or transmission?"
msgstr "ä¸€æ—¦ Unicode ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã‚³ãƒ¼ãƒ‰ãŒå‹•ä½œã™ã‚‹ã‚ˆã†ã«æ›¸ãçµ‚ãˆãŸã‚‰ã€æ¬¡ã®å•é¡Œã¯å…¥å‡ºåŠ›ã§ã™ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ Unicode æ–‡å­—åˆ—ã‚’ã©ã†å—ã‘ã¨ã‚Šã€ã©ã† Unicode ã‚’å¤–éƒ¨è¨˜æ†¶è£…ç½®ã‚„é€å—ä¿¡è£…ç½®ã«é©ã—ãŸå½¢å¼ã«å¤‰æ›ã™ã‚‹ã®ã§ã—ã‚‡ã†?"

#: ../../howto/unicode.rst:514
msgid ""
"It's possible that you may not need to do anything depending on your input "
"sources and output destinations; you should check whether the libraries used"
" in your application support Unicode natively.  XML parsers often return "
"Unicode data, for example.  Many relational databases also support Unicode-"
"valued columns and can return Unicode values from an SQL query."
msgstr "å…¥åŠ›ã‚½ãƒ¼ã‚¹ã¨å‡ºåŠ›å…ˆã«ä¾å­˜ã—ãªã„ã‚ˆã†ãªæ–¹æ³•ã¯å¯èƒ½ã§ã™; ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒ Unicode ã‚’ãã®ã¾ã¾ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ã‚’èª¿ã¹ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚ä¾‹ãˆã° XML ãƒ‘ãƒ¼ã‚µãƒ¼ã¯å¤§æŠµ Unicode ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚å¤šãã®ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒŠãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚‚ Unicode å€¤ã®å…¥ã£ãŸã‚³ãƒ©ãƒ ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã—ã€ SQL ã®å•ã„åˆã‚ã›ã§ Unicode å€¤ã‚’è¿”ã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../howto/unicode.rst:520
msgid ""
"Unicode data is usually converted to a particular encoding before it gets "
"written to disk or sent over a socket.  It's possible to do all the work "
"yourself: open a file, read an 8-bit string from it, and convert the string "
"with ``unicode(str, encoding)``.  However, the manual approach is not "
"recommended."
msgstr "Unicode ãƒ‡ãƒ¼ã‚¿ã¯å¤§æŠµã®å ´åˆã€ãƒ‡ã‚£ã‚¹ã‚¯ã«æ›¸ãè¾¼ã‚“ã ã‚Šã‚½ã‚±ãƒƒãƒˆã‚’é€šã—ã¦é€ã‚‰ã‚Œã‚‹å‰ã«ç‰¹å®šã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚ãã‚Œã‚‰ã‚’è‡ªåˆ†è‡ªèº«ã§è¡Œãªã†ã“ã¨ã¯å¯èƒ½ã§ã™: ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã„ã¦ã€8-bit æ–‡å­—åˆ—ã‚’èª­ã¿ã€æ–‡å­—åˆ—ã‚’ ``unicode(str, encoding)`` ã§å¤‰æ›ã—ã¾ã™ã€‚ã—ã‹ã—ã€ã“ã®æ‰‹å‹•ã§ã®æ“ä½œã¯æ¨å¥¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../howto/unicode.rst:525
msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character can"
" be represented by several bytes.  If you want to read the file in "
"arbitrary-sized chunks (say, 1K or 4K), you need to write error-handling "
"code to catch the case where only part of the bytes encoding a single "
"Unicode character are read at the end of a chunk.  One solution would be to "
"read the entire file into memory and then perform the decoding, but that "
"prevents you from working with files that are extremely large; if you need "
"to read a 2Gb file, you need 2Gb of RAM. (More, really, since for at least a"
" moment you'd need to have both the encoded string and its Unicode version "
"in memory.)"
msgstr "å•é¡Œã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒãƒãƒ«ãƒãƒã‚¤ãƒˆã§ã‚ã‚‹ã¨ã„ã†æ€§è³ªã‹ã‚‰ãã¦ã„ã¾ã™; ä¸€ã¤ã® Unicode æ–‡å­—ã¯æ•°ãƒã‚¤ãƒˆã§è¡¨ç¾ã•ã‚Œã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä»»æ„ã®ã‚µã‚¤ã‚º (1K ã¾ãŸã¯ 4K) ã‚’å˜ä½ (chunk) ã¨ã—ã¦èª­ã¿ãŸã„å ´åˆã€èª­ã¿è¾¼ã¿ã®å˜ä½ (chunk) ã®æœ€å¾Œã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã•ã‚ŒãŸä¸€ã¤ã® Unicode æ–‡å­—ã®ãƒã‚¤ãƒˆåˆ—ã®ä¸€éƒ¨ã®ã¿ã ã£ãŸçŠ¶æ³ã«å¯¾ã™ã‚‹ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãå¿…è¦ãŒã§ã¾ã™ã€‚ä¸€ã¤ã®è§£æ±ºç­–ã¨ã—ã¦ã¯ãƒ¡ãƒ¢ãƒªä¸Šã«ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“ã‚’èª­ã¿è¾¼ã‚“ã§ã‹ã‚‰ã€ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã„ã†æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€ã—ã‹ã—å·¨å¤§ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‰±ã†ã¨ãã«å•é¡ŒãŒèµ·ãã¾ã™; 2Gb ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€å ´åˆã€2Gb ã® RAM ãŒå¿…è¦ã§ã™ã€‚ (æ­£ç¢ºã«ã„ã†ã¨ã‚ˆã‚Šå¤šãã® RAM ãŒå¿…è¦ã§ã™ã€å°‘ãªãã¨ã‚‚ã‚ã‚‹æ™‚ç‚¹ã§ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹æ–‡å­—åˆ—ã¨ Unicode ã«å¤‰æ›ã—ãŸæ–‡å­—åˆ—ã®ä¸¡æ–¹ãŒãƒ¡ãƒ¢ãƒªä¸Šã«å¿…è¦ã¨ã•ã‚Œã‚‹ãŸã‚ã«)"

#: ../../howto/unicode.rst:535
msgid ""
"The solution would be to use the low-level decoding interface to catch the "
"case of partial coding sequences.  The work of implementing this has already"
" been done for you: the :mod:`codecs` module includes a version of the "
":func:`open` function that returns a file-like object that assumes the "
"file's contents are in a specified encoding and accepts Unicode parameters "
"for methods such as ``.read()`` and ``.write()``."
msgstr "è§£æ±ºç­–ã¯æ–‡å­—ã‚³ãƒ¼ãƒ‰ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒé€”ä¸­ã§åˆ‡ã‚Œã‚‹å•é¡Œã‚’æ‰ãˆã‚‹ä½ãƒ¬ãƒ™ãƒ«ã®ãƒ‡ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä½¿ã†ã“ã¨ã§ã™ã€‚ã“ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®å®Ÿè£…ã¯æ—¢ã«è¡Œãªã‚ã‚Œã¦ã„ã¾ã™: :mod:`codecs` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :func:`open` é–¢æ•°ã‚’å«ã‚“ã§ã„ã¾ã™ã€ã“ã®é–¢æ•°ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ãŒæŒ‡å®šã—ãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã‚ã‚‹ã¨ä»®å®šã•ã‚Œã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã€ ``.read()`` and ``.write()`` ã®ã‚ˆã†ãªãƒ¡ã‚½ãƒƒãƒ‰ã«å¯¾ã—ã¦ Unicode ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å—ã‘ã¤ã‘ã¾ã™ã€‚"

#: ../../howto/unicode.rst:542
msgid ""
"The function's parameters are ``open(filename, mode='rb', encoding=None, "
"errors='strict', buffering=1)``.  ``mode`` can be ``'r'``, ``'w'``, or "
"``'a'``, just like the corresponding parameter to the regular built-in "
"``open()`` function; add a ``'+'`` to update the file.  ``buffering`` is "
"similarly parallel to the standard function's parameter.  ``encoding`` is a "
"string giving the encoding to use; if it's left as ``None``, a regular "
"Python file object that accepts 8-bit strings is returned.  Otherwise, a "
"wrapper object is returned, and data written to or read from the wrapper "
"object will be converted as needed. ``errors`` specifies the action for "
"encoding errors and can be one of the usual values of 'strict', 'ignore', "
"and 'replace'."
msgstr "é–¢æ•°ã®å¼•æ•°ã¯ ``open(filename, mode='rb', encoding=None, errors='strict', buffering=1)`` ã§ã™ã€‚ ``mode`` ã¯ ``'r'``, ``'w'``, ã¾ãŸã¯ ``'a'`` ãŒå—ã‘ä»˜ã‘ã‚‰ã‚Œã€é€šå¸¸ã®çµ„ã¿è¾¼ã¿é–¢æ•° ``open()`` é–¢æ•°ã®å¼•æ•°ã¨åŒæ§˜ã§ã™; ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°ã™ã‚‹ã«ã¯ ``'+'`` ã‚’åŠ ãˆã¾ã™ã€‚ ``buffering`` ã¯æ¨™æº–ã®é–¢æ•°ã®å¼•æ•°ã¨åŒæ§˜ã§ã™ã€‚ ``encoding`` ã¯ä½¿ã†ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’æ–‡å­—åˆ—ã§ä¸ãˆã¾ã™; ã‚‚ã— ``None`` ã«ã—ãŸå ´åˆã¯ 8-bit æ–‡å­—åˆ—ã‚’å—ã‘ä»˜ã‘ã‚‹é€šå¸¸ã® Python ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¿”ã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å¼•æ•°ã®å ´åˆã«ã¯ã€ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¿”ã•ã‚Œã€ãƒ‡ãƒ¼ã‚¿ã¯å¿…è¦ã«å¿œã˜ã¦å¤‰æ›ã•ã‚ŒãŸãƒ©ãƒƒãƒ‘ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰èª­ã¿æ›¸ãã•ã‚Œã¾ã™ã€‚ ``errors`` ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ã‚¤ãƒ³ã‚°ã‚¨ãƒ©ãƒ¼ã«å¯¾ã™ã‚‹å‹•ä½œã‚’æŒ‡å®šã—ã¾ã™ã€ã“ã‚Œã¯ä¾‹ã®å¦‚ã 'strict', 'ignore' ãã—ã¦ 'replace' ã®ã†ã¡ã®ã©ã‚Œã‹ã‚’ã¨ã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:553
msgid "Reading Unicode from a file is therefore simple::"
msgstr "ãã®ãŸã‚ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ Unicode ã‚’èª­ã‚€ã®ã¯å˜ç´”ã§ã™::"

#: ../../howto/unicode.rst:560
msgid ""
"It's also possible to open files in update mode, allowing both reading and "
"writing::"
msgstr "èª­ã¿æ›¸ãã®ä¸¡æ–¹ãŒã§ãã‚‹ update ãƒ¢ãƒ¼ãƒ‰ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãã“ã¨ã‚‚å¯èƒ½ã§ã™::"

#: ../../howto/unicode.rst:569
msgid ""
"Unicode character U+FEFF is used as a byte-order mark (BOM), and is often "
"written as the first character of a file in order to assist with "
"autodetection of the file's byte ordering.  Some encodings, such as UTF-16, "
"expect a BOM to be present at the start of a file; when such an encoding is "
"used, the BOM will be automatically written as the first character and will "
"be silently dropped when the file is read.  There are variants of these "
"encodings, such as 'utf-16-le' and 'utf-16-be' for little-endian and big-"
"endian encodings, that specify one particular byte ordering and don't skip "
"the BOM."
msgstr "Unicode æ–‡å­— U+FEFF ã¯ byte-order-mark (BOM) ã¨ã—ã¦åˆ©ç”¨ã•ã‚Œã¾ã™ã€ãã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒã‚¤ãƒˆé †ã®è‡ªå‹•åˆ¤å®šã®å½¹ç«‹ã¦ã‚‹ãŸã‚ã«ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€åˆã®æ–‡å­—ã¨ã—ã¦æ›¸ã‹ã‚Œã¾ã™ã€‚ã„ãã¤ã‹ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã€ãŸã¨ãˆã° UTF-16 ã§ã¯ BOM ãŒãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€åˆã«å­˜åœ¨ã™ã‚‹ã“ã¨ã«ãªã£ã¦ã„ã¾ã™; ãã®ã‚ˆã†ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒåˆ©ç”¨ã•ã‚Œã‚‹ã¨ãã«ã¯ BOM ã¯æœ€åˆã®æ–‡å­—ã¨ã—ã¦è‡ªå‹•çš„ã«æ›¸ãè¾¼ã¾ã‚Œã€ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿æ™‚ã«ã¯æš—é»™ã®å†…ã«é™¤ã‹ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«ã¯ãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ (little-endian) ã¨ãƒ“ãƒƒã‚°ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ (big-endian) ã«å¯¾ã—ã¦ 'utf-16-le' ã¨ 'utf-16-be' ã®ã‚ˆã†ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®å¤‰ç¨®ãŒå­˜åœ¨ã—ã¾ã™ã€ã“ã‚Œã‚‰ã¯ç‰¹å®šã®ãƒã‚¤ãƒˆé †ã‚’ç¤ºã™ã‚‚ã®ã§ã€BOM ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã›ã‚“ã€‚"

#: ../../howto/unicode.rst:580
msgid "Unicode filenames"
msgstr "Unicode ãƒ•ã‚¡ã‚¤ãƒ«å"

#: ../../howto/unicode.rst:582
msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on "
"the system.  For example, Mac OS X uses UTF-8 while Windows uses a "
"configurable encoding; on Windows, Python uses the name \"mbcs\" to refer to"
" whatever the currently configured encoding is.  On Unix systems, there will"
" only be a filesystem encoding if you've set the ``LANG`` or ``LC_CTYPE`` "
"environment variables; if you haven't, the default encoding is ASCII."
msgstr "å¤šãã® OS ã§ã¯ç¾åœ¨ä»»æ„ã® Unicode æ–‡å­—ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚é€šå¸¸ Unicode æ–‡å­—åˆ—ã‚’ã‚·ã‚¹ãƒ†ãƒ ä¾å­˜ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«å¤‰æ›ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€Mac OS X ã¯ UTF-8 ã‚’åˆ©ç”¨ã—ã€Windows ã§ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒè¨­å®šã§å¤‰æ›´ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™; Windows ã§ã¯ Python ã¯ \"mbcs\" ã¨ã„ã†åå‰ã«ç¾åœ¨è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’å•ã„åˆã‚ã›ã¦åˆ©ç”¨ã—ã¾ã™ã€‚ Unix ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ ``LANG`` ã‚„ ``LC_CTYPE`` ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã—ã¦ã„ã‚Œã°ã€ãã‚Œã ã‘ãŒãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¨ãªã‚Šã¾ã™; ã‚‚ã—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¨­å®šã—ãªã‘ã‚Œã°ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ ASCII ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:591
msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to use "
"on your current system, in case you want to do the encoding manually, but "
"there's not much reason to bother.  When opening a file for reading or "
"writing, you can usually just provide the Unicode string as the filename, "
"and it will be automatically converted to the right encoding for you::"
msgstr ":func:`sys.getfilesystemencoding` é–¢æ•°ã¯ç¾åœ¨ã®ã‚·ã‚¹ãƒ†ãƒ ã§åˆ©ç”¨ã™ã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿”ã—ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’æ‰‹å‹•ã§è¨­å®šã—ãŸã„å ´åˆåˆ©ç”¨ã—ã¾ã™ã€ãŸã ã—ã‚ã–ã‚ã–ãã†ã™ã‚‹ç©æ¥µçš„ãªç†ç”±ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚èª­ã¿æ›¸ãã®ãŸã‚ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãæ™‚ã«ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ Unicode æ–‡å­—åˆ—ã¨ã—ã¦æ¸¡ã™ã ã‘ã§æ­£ã—ã„ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«è‡ªå‹•çš„ã«å¤‰æ›´ã•ã‚Œã¾ã™::"

#: ../../howto/unicode.rst:602
msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also accept "
"Unicode filenames."
msgstr ":func:`os.stat` ã®ã‚ˆã†ãª :mod:`os` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–¢æ•°ã‚‚ Unicode ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚"

#: ../../howto/unicode.rst:605
msgid ""
":func:`os.listdir`, which returns filenames, raises an issue: should it "
"return the Unicode version of filenames, or should it return 8-bit strings "
"containing the encoded versions?  :func:`os.listdir` will do both, depending"
" on whether you provided the directory path as an 8-bit string or a Unicode "
"string.  If you pass a Unicode string as the path, filenames will be decoded"
" using the filesystem's encoding and a list of Unicode strings will be "
"returned, while passing an 8-bit path will return the 8-bit versions of the "
"filenames.  For example, assuming the default filesystem encoding is UTF-8, "
"running the following program::"
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¿”ã™ :func:`os.listdir` ã¯å•é¡Œã‚’å¼•ãèµ·ã“ã—ã¾ã™: ã“ã®é–¢æ•°ã¯ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¿”ã™ã¹ãã§ã—ã‚‡ã†ã‹ã€ãã‚Œã¨ã‚‚ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸå†…å®¹ã® 8-bit æ–‡å­—åˆ—ã‚’è¿”ã™ã¹ãã§ã—ã‚‡ã†ã‹? :func:`os.listdir` ã¯ä¸ãˆã‚‰ã‚ŒãŸãƒ‡ã‚¤ãƒ¬ã‚¯ãƒˆãƒªã¸ã®ãƒ‘ã‚¹ãŒ 8-bit æ–‡å­—åˆ—ã‹ Unicode æ–‡å­—åˆ—ã§ä¸ãˆãŸã‹ã«å¿œã˜ã¦ãã®ä¸¡æ–¹ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ã‚¹ã‚’ Unicode æ–‡å­—åˆ—ã§ä¸ãˆãŸå ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«åã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’åˆ©ç”¨ã—ã¦ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚Œã€ Unicode æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆãŒè¿”ã•ã‚Œã¾ã™ã€8-bit ãƒ‘ã‚¹ã‚’ä¸ãˆã‚‹ã¨ãƒ•ã‚¡ã‚¤ãƒ«åã¯ 8-bit æ–‡å­—åˆ—ã§è¿”ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒ UTF-8 ã¨ä»®å®šã•ã‚Œã‚‹å ´åˆã€ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã™ã‚‹ã¨::"

#: ../../howto/unicode.rst:622
msgid "will produce the following output:"
msgstr "ä»¥ä¸‹ã®å‡ºåŠ›çµæœãŒç”Ÿæˆã•ã‚Œã¾ã™:"

#: ../../howto/unicode.rst:630
msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr "æœ€åˆã®ãƒªã‚¹ãƒˆã¯ UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«åã‚’å«ã¿ã€ç¬¬äºŒã®ãƒªã‚¹ãƒˆã¯ Unicode ç‰ˆã‚’å«ã‚“ã§ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:636
msgid "Tips for Writing Unicode-aware Programs"
msgstr "Unicode å¯¾å¿œã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ããŸã‚ã® Tips"

#: ../../howto/unicode.rst:638
msgid ""
"This section provides some suggestions on writing software that deals with "
"Unicode."
msgstr "ã“ã®ç« ã§ã¯ Unicode ã‚’æ‰±ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ããŸã‚ã®ã„ãã¤ã‹ã®ææ¡ˆã‚’ç´¹ä»‹ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:641
msgid "The most important tip is:"
msgstr "æœ€ã‚‚é‡è¦ãªåŠ©è¨€ã¨ã—ã¦ã¯:"

#: ../../howto/unicode.rst:643
msgid ""
"Software should only work with Unicode strings internally, converting to a "
"particular encoding on output."
msgstr "ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢å†…éƒ¨ã®å‹•ä½œã«ã¯ Unicode æ–‡å­—åˆ—ã®ã¿ã‚’åˆ©ç”¨ã—ã€å‡ºåŠ›æ™‚ã«ç‰¹å®šã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«å¤‰æ›ã™ã‚‹ã€‚"

#: ../../howto/unicode.rst:646
msgid ""
"If you attempt to write processing functions that accept both Unicode and "
"8-bit strings, you will find your program vulnerable to bugs wherever you "
"combine the two different kinds of strings.  Python's default encoding is "
"ASCII, so whenever a character with an ASCII value > 127 is in the input "
"data, you'll get a :exc:`UnicodeDecodeError` because that character can't be"
" handled by the ASCII encoding."
msgstr "UTF-8 ã¨ 8-bit æ–‡å­—åˆ—ã®ä¸¡æ–¹ã‚’å‡¦ç†ã™ã‚‹é–¢æ•°ã‚’æ›¸ã“ã†ã¨ã™ã‚‹ã¨ã€ç•°ãªã‚‹ç¨®é¡ã®æ–‡å­—åˆ—ã‚’çµåˆã™ã‚‹éš›ã«ãƒã‚°ãŒç”Ÿã˜ã‚„ã™ã„ã“ã¨ã«æ°—ã¥ãã§ã—ã‚‡ã†ã€‚ Python ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ ASCII ãªã®ã§ã€ ASCII ã®å€¤ 127 ã‚ˆã‚Šå¤§ãã„æ–‡å­—ãŒå…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã«ã‚ã£ãŸå ´åˆã€ã“ã‚Œã¯ ASCII ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§æ‰±ãˆãªã„ãŸã‚ã«ã€ :exc:`UnicodeDecodeError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:653
msgid ""
"It's easy to miss such problems if you only test your software with data "
"that doesn't contain any accents; everything will seem to work, but there's "
"actually a bug in your program waiting for the first user who attempts to "
"use characters > 127.  A second tip, therefore, is:"
msgstr "ã“ã®å•é¡Œã‚’è¦‹é€ƒãŒã™ã®ã¯ç°¡å˜ã§ã™ã€ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã«å¯¾ã—ã¦ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚’å«ã¾ãªã„ãƒ‡ãƒ¼ã‚¿ã®ã¿ã§ãƒ†ã‚¹ãƒˆã‚’è¡Œãªãˆã°ã‚ˆã„ã®ã§ã™; å…¨ã¦ã¯ã†ã¾ãå‹•ä½œã—ã¦ã„ã‚‹ã‚ˆã†ã«è¦‹ãˆã¾ã™ã€ã—ã‹ã—å®Ÿéš›ã«ã¯æœ€åˆã« 127 ã‚ˆã‚Šå¤§ãã„æ–‡å­—ã‚’è©¦ã¿ãŸãƒ¦ãƒ¼ã‚¶ã«ãƒã‚°ãŒå¾…ã¡æ§‹ãˆã¦ã„ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ç¬¬äºŒã®åŠ©è¨€ã¯:"

#: ../../howto/unicode.rst:658
msgid ""
"Include characters > 127 and, even better, characters > 255 in your test "
"data."
msgstr "ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã«ã¯ 127 ã‚ˆã‚Šå¤§ãã„æ–‡å­—ã‚’å«ã¿ã€ã•ã‚‰ã« 255 ã‚ˆã‚Šå¤§ãã„æ–‡å­—ã‚’å«ã‚€ã“ã¨ãŒæœ›ã¾ã—ã„ã€‚"

#: ../../howto/unicode.rst:661
msgid ""
"When using data coming from a web browser or some other untrusted source, a "
"common technique is to check for illegal characters in a string before using"
" the string in a generated command line or storing it in a database.  If "
"you're doing this, be careful to check the string once it's in the form that"
" will be used or stored; it's possible for encodings to be used to disguise "
"characters.  This is especially true if the input data also specifies the "
"encoding; many encodings leave the commonly checked-for characters alone, "
"but Python includes some encodings such as ``'base64'`` that modify every "
"single character."
msgstr "Web ãƒ–ãƒ©ã‚¦ã‚¶ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚„ãã®ä»–ã®ä¿¡ç”¨ã§ããªã„ã¨ã“ã‚ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã†å ´åˆã«ã¯ã€ã‚³ãƒãƒ³ãƒ‰è¡Œã®ç”Ÿæˆã‚„ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¸ã®è¨˜éŒ²ã®å‰ã«ä¸æ­£ãªæ–‡å­—ã«å¯¾ã™ã‚‹ãƒã‚§ãƒƒã‚¯ã‚’è¡Œãªã†ã“ã¨ãŒä¸€èˆ¬çš„ã§ã™ã€‚ã‚‚ã—ã‚³ãƒãƒ³ãƒ‰è¡Œç”Ÿæˆã‚„ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨˜éŒ²ã‚’è¡Œãªã†å ´åˆã«ã¯ã€æ–‡å­—åˆ—ãŒåˆ©ç”¨ã¾ãŸã¯ä¿å­˜ã§ãã‚‹å½¢å¼ã«ãªã£ã¦ã„ã‚‹ã‹ã‚’ä¸€åº¦ã¯æ³¨æ„æ·±ãç¢ºã‹ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™; æ–‡å­—ã‚’å½è£…ã™ã‚‹ãŸã‚ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã¯å¯èƒ½ã§ã™ã€‚ã“ã®ã“ã¨ã¯å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã‚‚å¯èƒ½ã§ã™; å¤šãã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ãƒã‚§ãƒƒã‚¯ç”¨ã®æ–‡å­—å˜ç‹¬ã‚’ãã®ã¾ã¾ã«ã—ã¦ãŠãã¾ã™ãŒã€ Python ã¯ ``'base64'`` ã®ã‚ˆã†ãªå˜ç‹¬ã®æ–‡å­—ã‚’å¤‰æ›´ã™ã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚‚å«ã‚“ã§ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:670
msgid ""
"For example, let's say you have a content management system that takes a "
"Unicode filename, and you want to disallow paths with a '/' character.  You "
"might write this code::"
msgstr "ä¾‹ãˆã°ã€Unicode ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å–ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ãŒã‚ã‚‹ã¨ã—ã¾ã™ã€ãã—ã¦ '/' æ–‡å­—ã‚’å«ã‚€ãƒ‘ã‚¹ã‚’æ‹’å¦ã—ãŸã„ã¨ã—ã¾ã™ã€‚ã™ã‚‹ã¨ã“ã®ã‚³ãƒ¼ãƒ‰ã®ã‚ˆã†ã«æ›¸ãã§ã—ã‚‡ã†::"

#: ../../howto/unicode.rst:681
msgid ""
"However, if an attacker could specify the ``'base64'`` encoding, they could "
"pass ``'L2V0Yy9wYXNzd2Q='``, which is the base-64 encoded form of the string"
" ``'/etc/passwd'``, to read a system file.  The above code looks for ``'/'``"
" characters in the encoded form and misses the dangerous character in the "
"resulting decoded form."
msgstr "ã—ã‹ã—ã€æ”»æ’ƒè€…ãŒ ``'base64'`` ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’æŒ‡å®šã§ãã‚‹å ´åˆã€æ”»æ’ƒè€…ã¯ã‚·ã‚¹ãƒ†ãƒ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€ãŸã‚ã« ``'/etc/passwd'`` ã®æ–‡å­—åˆ—ã‚’ base-64 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸ ``'L2V0Yy9wYXNzd2Q='`` ã‚’æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ä¸Šã®ã‚³ãƒ¼ãƒ‰ã¯æ–‡å­— ``'/'`` ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸå½¢å¼ã§æ¢ã—ã€ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ãŸçµæœãŒå±é™ºãªæ–‡å­—ã¨ãªã‚‹å ´åˆã‚’è¦‹é€ƒã—ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:690
msgid ""
"The PDF slides for Marc-AndrÃ© Lemburg's presentation \"Writing Unicode-aware"
" Applications in Python\" are available at "
"<https://downloads.egenix.com/python/LSM2005-Developing-Unicode-aware-"
"applications-in-Python.pdf> and discuss questions of character encodings as "
"well as how to internationalize and localize an application."
msgstr "Marc-AndrÃ© Lemburg ã®ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ \"Writing Unicode-aware Applications in Python\" ã® PDF ã‚¹ãƒ©ã‚¤ãƒ‰ãŒ <https://downloads.egenix.com/python/LSM2005-Developing-Unicode-aware-applications-in-Python.pdf> ã‹ã‚‰å…¥æ‰‹å¯èƒ½ã§ã™ã€ãã—ã¦æ–‡å­—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®å•é¡Œã¨åŒæ§˜ã«ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å›½éš›åŒ–ã‚„ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºã«ã¤ã„ã¦ã‚‚è­°è«–ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:698
msgid "Revision History and Acknowledgements"
msgstr "æ›´æ–°å±¥æ­´ã¨è¬è¾"

#: ../../howto/unicode.rst:700
msgid ""
"Thanks to the following people who have noted errors or offered suggestions "
"on this article: Nicholas Bastin, Marius Gedminas, Kent Johnson, Ken "
"Krugler, Marc-AndrÃ© Lemburg, Martin von LÃ¶wis, Chad Whitacre."
msgstr "ã“ã®è¨˜äº‹ä¸­ã®èª¤ã‚Šã®æŒ‡æ‘˜ã‚„ææ¡ˆã‚’ç”³ã—å‡ºã¦ãã‚ŒãŸä»¥ä¸‹ã®äººã€…ã«æ„Ÿè¬ã—ã¾ã™: Nicholas Bastin, Marius Gedminas, Kent Johnson, Ken Krugler, Marc-AndrÃ© Lemburg, Martin von LÃ¶wis, Chad Whitacre."

#: ../../howto/unicode.rst:704
msgid "Version 1.0: posted August 5 2005."
msgstr "Version 1.0: posted August 5 2005."

#: ../../howto/unicode.rst:706
msgid ""
"Version 1.01: posted August 7 2005.  Corrects factual and markup errors; "
"adds several links."
msgstr "Version 1.01: posted August 7 2005.  Corrects factual and markup errors; adds several links."

#: ../../howto/unicode.rst:709
msgid "Version 1.02: posted August 16 2005.  Corrects factual errors."
msgstr "Version 1.02: posted August 16 2005.  Corrects factual errors."

#: ../../howto/unicode.rst:711
msgid ""
"Version 1.03: posted June 20 2010.  Notes that Python 3.x is not covered, "
"and that the HOWTO only covers 2.x."
msgstr "Version 1.03: posted June 20 2010.  Notes that Python 3.x is not covered, and that the HOWTO only covers 2.x."
