# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-10 13:00+0900\n"
"PO-Revision-Date: 2018-06-29 17:46+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/unicode.rst:5
msgid "Unicode HOWTO"
msgstr "Unicode HOWTO"

#: ../../howto/unicode.rst:0
msgid "Release"
msgstr "ãƒªãƒªãƒ¼ã‚¹"

#: ../../howto/unicode.rst:7
msgid "1.12"
msgstr "1.12"

#: ../../howto/unicode.rst:9
msgid ""
"This HOWTO discusses Python support for Unicode, and explains various "
"problems that people commonly encounter when trying to work with Unicode."
msgstr ""
"ã“ã® HOWTO æ–‡æ›¸ã¯ Python ã® Unicode ã‚µãƒãƒ¼ãƒˆã«ã¤ã„ã¦è«–ã˜ã€ã•ã‚‰ã« Unicode "
"ã‚’ä½¿ãŠã†ã¨ã„ã†ã¨ãã«ã‚ˆãã§ãã‚ã™å¤šãã®å•é¡Œã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:14
msgid "Introduction to Unicode"
msgstr "Unicode å…¥é–€"

#: ../../howto/unicode.rst:17
msgid "History of Character Codes"
msgstr "æ–‡å­—ã‚³ãƒ¼ãƒ‰ã®æ­´å²"

#: ../../howto/unicode.rst:19
msgid ""
"In 1968, the American Standard Code for Information Interchange, better "
"known by its acronym ASCII, was standardized.  ASCII defined numeric codes "
"for various characters, with the numeric values running from 0 to 127.  For "
"example, the lowercase letter 'a' is assigned 97 as its code value."
msgstr ""
"1968å¹´ã« American Standard Code for Information Interchange ãŒæ¨™æº–åŒ–ã•ã‚Œã¾ã—ãŸã€‚ã“ã‚Œã¯é ­æ–‡å­—ã® "
"ASCII ã§ã‚ˆãçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ASCII ã¯0ã‹ã‚‰127ã¾ã§ã®ã€ç•°ãªã‚‹æ–‡å­—ã®æ•°å€¤ã‚³ãƒ¼ãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã¦ã€ä¾‹ãˆã°ã€å°æ–‡å­—ã® 'a' ã«ã¯ã‚³ãƒ¼ãƒ‰å€¤ 97 "
"ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:24
msgid ""
"ASCII was an American-developed standard, so it only defined unaccented "
"characters.  There was an 'e', but no 'Ã©' or 'Ã'.  This meant that languages"
" which required accented characters couldn't be faithfully represented in "
"ASCII. (Actually the missing accents matter for English, too, which contains"
" words such as 'naÃ¯ve' and 'cafÃ©', and some publications have house styles "
"which require spellings such as 'coÃ¶perate'.)"
msgstr ""
"ASCII ã¯ã‚¢ãƒ¡ãƒªã‚«ã®é–‹ç™ºæ¨™æº–ã ã£ãŸã®ã§ã‚¢ã‚¯ã‚»ãƒ³ãƒˆç„¡ã—ã®æ–‡å­—ã®ã¿ã‚’å®šç¾©ã—ã¦ã„ã¦ã€ 'e' ã¯ã‚ã‚Šã¾ã—ãŸãŒã€ 'Ã©' ã‚„ 'Ã' "
"ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã¤ã¾ã‚Šã€ã‚¢ã‚¯ã‚»ãƒ³ãƒˆä»˜ãã®æ–‡å­—ã‚’å¿…è¦ã¨ã™ã‚‹è¨€èªã¯ ASCII ã§ãã¡ã‚“ã¨è¡¨ç¾ã™ã‚‹ã¨ãŒã§ãã¾ã›ã‚“ã€‚ "
"(å®Ÿéš›ã«ã¯è‹±èªã§ã‚‚ã‚¢ã‚¯ã‚»ãƒ³ãƒˆãŒç„¡ã„ãŸã‚ã«èµ·ãã‚‹å•é¡ŒãŒã‚ã‚Šã¾ã—ãŸã€ 'naÃ¯ve' ã‚„ 'cafÃ©' ã®ã‚ˆã†ãªã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚’å«ã‚€å˜èªã‚„ã€ã„ãã¤ã‹ã®å‡ºç‰ˆç¤¾ã¯ "
"'coÃ¶perate' ã®ã‚ˆã†ãªç‹¬è‡ªã®ã‚¹ã‚¿ã‚¤ãƒ«ã®ã¤ã¥ã‚Šã‚’å¿…è¦ã¨ã™ã‚‹ãªã©)"

#: ../../howto/unicode.rst:31
msgid ""
"For a while people just wrote programs that didn't display accents. In the "
"mid-1980s an Apple II BASIC program written by a French speaker might have "
"lines like these:"
msgstr ""

#: ../../howto/unicode.rst:40
msgid ""
"Those messages should contain accents (terminÃ©e, paramÃ¨tre, enregistrÃ©s) and"
" they just look wrong to someone who can read French."
msgstr ""
"ã“ã‚Œã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚’å«ã‚“ã§ã„ã‚‹ã¯ãš (terminÃ©e, paramÃ¨tre, enregistrÃ©s) "
"ã§ã€ãƒ•ãƒ©ãƒ³ã‚¹èªãŒèª­ã‚ã‚‹äººã«ã¨ã£ã¦ã¯å˜ãªã‚‹é–“é•ã„ã®ã‚ˆã†ã«è¦‹ã‚‰ã‚Œã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:43
msgid ""
"In the 1980s, almost all personal computers were 8-bit, meaning that bytes "
"could hold values ranging from 0 to 255.  ASCII codes only went up to 127, "
"so some machines assigned values between 128 and 255 to accented characters."
"  Different machines had different codes, however, which led to problems "
"exchanging files. Eventually various commonly used sets of values for the "
"128--255 range emerged. Some were true standards, defined by the "
"International Organization for Standardization, and some were *de facto* "
"conventions that were invented by one company or another and managed to "
"catch on."
msgstr ""
"1980 å¹´ä»£ã«ã¯ã€ã»ã¼å…¨ã¦ã®ãƒ‘ãƒ¼ã‚½ãƒŠãƒ«ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã¯ 8-bit ã§ã€ã“ã‚Œã¯ 0 ã‹ã‚‰ 255 "
"ã¾ã§ã®ç¯„å›²ã®å€¤ã‚’ä¿æŒã§ãã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã—ãŸã€‚ASCII ã‚³ãƒ¼ãƒ‰ã¯æœ€å¤§ã§ 127 ã¾ã§ã ã£ãŸã®ã§ã€ã‚ã‚‹ãƒã‚·ãƒ³ã§ã¯ 128 ã‹ã‚‰ 255 "
"ã¾ã§ã®å€¤ã«ã‚¢ã‚¯ã‚»ãƒ³ãƒˆä»˜ãã®æ–‡å­—ã‚’å‰²ã‚Šå½“ã¦ã¦ã„ã¾ã—ãŸã€‚ã—ã‹ã—ã€ç•°ãªã‚‹ãƒã‚·ãƒ³ã¯ç•°ãªã‚‹æ–‡å­—ã‚³ãƒ¼ãƒ‰ã‚’æŒã£ã¦ã„ãŸãŸã‚ã€ãƒ•ã‚¡ã‚¤ãƒ«äº¤æ›ã§å•é¡ŒãŒèµ·ãã‚‹ã‚ˆã†ã«ãªã£ã¦ãã¾ã—ãŸã€‚çµå±€ã€128"
" ã‹ã‚‰ 255 ã¾ã§ç¯„å›²ã®å€¤ã®ã‚»ãƒƒãƒˆã§ã€ã‚ˆãä½¿ã‚ã‚Œã‚‹ã‚‚ã®ãŒè‰²ã€…ã¨ç¾ã‚Œã¾ã—ãŸã€‚ãã®ã†ã¡ã„ãã¤ã‹ã¯å›½éš›æ¨™æº–åŒ–æ©Ÿæ§‹ (International "
"Organization for Standardization) "
"ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚ŒãŸæœ¬ç‰©ã®æ¨™æº–ã«ãªã‚Šã€ã¾ãŸã„ãã¤ã‹ã¯ã‚ã¡ã“ã¡ã®ä¼šç¤¾ã§é–‹ç™ºã•ã‚Œã€ãªã‚“ã¨ã‹åºƒã¾ã£ãŸã‚‚ã®ãŒ *äº‹å®Ÿä¸Šã®* æ…£ç¿’ã¨ãªã£ã¦ã„ãã¾ã—ãŸã€‚"

#: ../../howto/unicode.rst:52
msgid ""
"255 characters aren't very many.  For example, you can't fit both the "
"accented characters used in Western Europe and the Cyrillic alphabet used "
"for Russian into the 128--255 range because there are more than 128 such "
"characters."
msgstr ""
"255æ–‡å­—ã¨ã„ã†ã®ã¯ååˆ†å¤šã„æ•°ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€è¥¿ãƒ¨ãƒ¼ãƒ­ãƒƒãƒ‘ã§ä½¿ã‚ã‚Œã‚‹ã‚¢ã‚¯ã‚»ãƒ³ãƒˆä»˜ãæ–‡å­—ã¨ãƒ­ã‚·ã‚¢ã§ä½¿ã‚ã‚Œã‚‹ã‚­ãƒªãƒ«ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã®ä¸¡æ–¹ã¯ "
"128æ–‡å­—ä»¥ä¸Šã‚ã‚‹ã®ã§ã€128--255ã®é–“ã«ãŠã•ã‚ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../howto/unicode.rst:56
msgid ""
"You could write files using different codes (all your Russian files in a "
"coding system called KOI8, all your French files in a different coding "
"system called Latin1), but what if you wanted to write a French document "
"that quotes some Russian text?  In the 1980s people began to want to solve "
"this problem, and the Unicode standardization effort began."
msgstr ""
"ç•°ãªã‚‹æ–‡å­—ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã™ã‚‹ã“ã¨ã¯å¯èƒ½ã§ã™ (æŒã£ã¦ã„ã‚‹ãƒ­ã‚·ã‚¢èªã®ãƒ•ã‚¡ã‚¤ãƒ«å…¨ã¦ã‚’ KOI8 "
"ã¨å‘¼ã°ã‚Œã‚‹ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã§ã€æŒã£ã¦ã„ã‚‹ãƒ•ãƒ©ãƒ³ã‚¹èªã®ãƒ•ã‚¡ã‚¤ãƒ«å…¨ã¦ã‚’åˆ¥ã® Latin1 "
"ã¨å‘¼ã°ã‚Œã‚‹ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã™ã‚‹ã“ã¨ã§)ã€ã—ã‹ã—ã€ãƒ­ã‚·ã‚¢èªã®æ–‡ç« ã‚’å¼•ç”¨ã™ã‚‹ãƒ•ãƒ©ãƒ³ã‚¹èªã®æ–‡ç« ã‚’æ›¸ããŸã„å ´åˆã«ã¯ã©ã†ã§ã—ã‚‡ã†? "
"1989å¹´ä»£ã«ã“ã®å•é¡Œã‚’è§£æ±ºã—ãŸã„ã¨ã„ã†è¦æœ›ãŒä¸Šã£ã¦ã€Unicode æ¨™æº–åŒ–ã®åŠªåŠ›ãŒå§‹ã¾ã‚Šã¾ã—ãŸã€‚"

#: ../../howto/unicode.rst:62
msgid ""
"Unicode started out using 16-bit characters instead of 8-bit characters.  16"
" bits means you have 2^16 = 65,536 distinct values available, making it "
"possible to represent many different characters from many different "
"alphabets; an initial goal was to have Unicode contain the alphabets for "
"every single human language. It turns out that even 16 bits isn't enough to "
"meet that goal, and the modern Unicode specification uses a wider range of "
"codes, 0 through 1,114,111 ( ``0x10FFFF`` in base 16)."
msgstr ""
"Unicord ã¯ 8-bit æ–‡å­—ã®ä»£ã‚ã‚Šã« 16-bit æ–‡å­—ã‚’ä½¿ã†ã“ã¨ã«å–ã‚Šæ›ã‹ã‚Šã¾ã—ãŸã€‚16 bit ã¨ã„ã†ã“ã¨ã¯ 2^16 = 65,536 "
"ã®ç•°ãªã£ãŸå€¤ãŒä½¿ãˆã€å¤šãã®æ§˜ã€…ãªã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã®æ§˜ã€…ãªæ–‡å­—ã‚’è¡¨ç¾ã§ãã‚‹ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã—ã¾ã™; æœ€åˆã®ç›®æ¨™ã¯ã€Unicode "
"ã«äººé–“ã®1ã¤1ã¤ã®è¨€èªã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã‚’å«ã‚ã‚‹ã“ã¨ã§ã—ãŸã€‚ã—ã‹ã— 16 bit ã§ã•ãˆã€ãã®ç›®æ¨™ã‚’é”æˆã™ã‚‹ãŸã‚ã«ã¯ä¸ååˆ†ã§ã‚ã‚‹ã“ã¨ãŒåˆ¤æ˜ã—ã€æœ€æ–°ã® "
"Unicode è¦æ ¼ã§ã¯ 0 ã‹ã‚‰ 1,114,111 (16é€²è¡¨è¨˜ã§ ``0x10FFFF`` ) ã¾ã§ã®ã‚ˆã‚Šåºƒã„ç¯„å›²ã®æ–‡å­—ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:70
msgid ""
"There's a related ISO standard, ISO 10646.  Unicode and ISO 10646 were "
"originally separate efforts, but the specifications were merged with the 1.1"
" revision of Unicode."
msgstr ""
"é–¢é€£ã™ã‚‹ ISO æ¨™æº–ã‚‚ ISO 10646 ãŒã‚ã‚Šã¾ã™ã€‚Unicode ã¨ ISO 10646 ã¯å…ƒã€…ç‹¬ç«‹ã—ãŸæˆæœã§ã—ãŸãŒã€ Unicode ã® "
"1.1 ãƒªãƒ“ã‚¸ãƒ§ãƒ³ã§ä»•æ§˜ã‚’ä½µåˆã—ã¾ã—ãŸã€‚"

#: ../../howto/unicode.rst:74
msgid ""
"(This discussion of Unicode's history is highly simplified.  The precise "
"historical details aren't necessary for understanding how to use Unicode "
"effectively, but if you're curious, consult the Unicode consortium site "
"listed in the References or the `Wikipedia entry for Unicode "
"<https://en.wikipedia.org/wiki/Unicode#History>`_ for more information.)"
msgstr ""
"(ã“ã® Unicode ã®æ­´å²ã«ã¤ã„ã¦ã®è§£èª¬ã¯éå¸¸ã«å˜ç´”åŒ–ã—ã¦ã‚ã‚Šã¾ã™ã€‚Unicode "
"ã®ä¸Šæ‰‹ã„ä½¿ã„æ–¹ã‚’ç†è§£ã™ã‚‹ã®ã«æ­´å²çš„ãªè©³ç´°ã‚’ç²¾å¯†ã«çŸ¥ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ã‚‚ã—èˆˆå‘³ãŒã‚ã‚Œã°ã€ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã¯å‚è€ƒæ–‡çŒ®ã«è¼‰ã›ãŸ Unicode "
"ã‚³ãƒ³ã‚½ãƒ¼ã‚·ã‚¢ãƒ ã®ã‚µã‚¤ãƒˆã‚„ `Wikipedia ã® Unicode ã®è¨˜äº‹ "
"<http://en.wikipedia.org/wiki/Unicode#History>`_ ã‚’èª¿ã¹ã¦ãã ã•ã„ã€‚)"

#: ../../howto/unicode.rst:83
msgid "Definitions"
msgstr "å®šç¾©"

#: ../../howto/unicode.rst:85
msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are 'Ãˆ' and 'Ã'.  Characters "
"are abstractions, and vary depending on the language or context you're "
"talking about.  For example, the symbol for ohms (â„¦) is usually drawn much "
"like the capital letter omega (Î©) in the Greek alphabet (they may even be "
"the same in some fonts), but these are two different characters that have "
"different meanings."
msgstr ""
"**æ–‡å­—** ã¯æ–‡ç« ã®æ§‹æˆè¦ç´ ã®ä¸­ã®æœ€å°ã®ã‚‚ã®ã§ã™ã€‚'A', 'B', 'C' ãªã©ã¯å…¨ã¦ç•°ãªã‚‹æ–‡å­—ã§ã™ã€‚ 'Ãˆ' ã‚„ 'Ã' "
"ã‚‚åŒæ§˜ã«ç•°ãªã‚‹æ–‡å­—ã§ã™ã€‚æ–‡å­—ã¯æŠ½è±¡çš„ãªæ¦‚å¿µã§ã€è¨€èªã‚„æ–‡è„ˆã«ä¾å­˜ã—ã¦ã•ã¾ã–ã¾ã«å¤‰åŒ–ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚ªãƒ¼ãƒ (â„¦) ã¯ãµã¤ã†å¤§æ–‡å­—ã‚®ãƒªã‚·ãƒ£æ–‡å­—ã®ã‚ªãƒ¡ã‚¬ (Î©)"
" ã§æ›¸ã‹ã‚Œã¾ã™ãŒ (ã“ã‚Œã‚‰ã¯ã„ãã¤ã‹ã®ãƒ•ã‚©ãƒ³ãƒˆã§å…¨ãåŒã˜æ›¸ä½“ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“) ã—ã‹ã—ã€ã“ã‚Œã‚‰ã¯ç•°ãªã‚‹æ„å‘³ã‚’æŒã¤ç•°ãªã‚‹æ–‡å­—ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚"

#: ../../howto/unicode.rst:93
msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point is an integer value, usually denoted in base 16.  In"
" the standard, a code point is written using the notation ``U+12CA`` to mean"
" the character with value ``0x12ca`` (4,810 decimal).  The Unicode standard "
"contains a lot of tables listing characters and their corresponding code "
"points:"
msgstr ""
"Unicode æ¨™æº–ã¯æ–‡å­—ã‚’ã©ã®ã‚ˆã†ã« **ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ (code points)** ã§è¡¨ç¾ã•ã‚Œã‚‹ã®ã‹ã‚’è¨˜è¿°ã—ã¦ã„ã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯é€šå¸¸ 16"
" é€²æ•°ã§è¡¨è¨˜ã•ã‚Œã‚‹æ•´æ•°å€¤ã§ã™ã€‚Unicode æ¨™æº–ã§ã¯ã€ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯ ``U+12CA`` ã¨ã„ã†è¡¨è¨˜ã‚’ä½¿ã£ã¦æ›¸ã‹ã‚Œã€ã“ã‚Œã¯ ``0x12ca`` "
"(10 é€²è¡¨è¨˜ã§ 4,810) ã¨ã„ã†å€¤ã‚’æŒã¤æ–‡å­—ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚Unicode "
"æ¨™æº–ã¯ã€æ–‡å­—ã¨ãã‚Œã«å¯¾å¿œã™ã‚‹ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’åˆ—æŒ™ã—ãŸå¤šãã®è¡¨ã‚’å«ã‚“ã§ã„ã¾ã™::"

#: ../../howto/unicode.rst:107
msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character ``U+12CA``'.  ``U+12CA`` is a code point, which represents some "
"particular character; in this case, it represents the character 'ETHIOPIC "
"SYLLABLE WI'.  In informal contexts, this distinction between code points "
"and characters will sometimes be forgotten."
msgstr ""
"å³å¯†ã«è¨€ã†ã¨ã€ã“ã®å®šç¾©ã‹ã‚‰ã€Œã“ã‚Œã¯æ–‡å­— ``U+12CA`` ã§ã™ã€ã¨è¨€ã†ã®ã¯æ„å‘³ã®ç„¡ã„ã“ã¨ã ã¨åˆ†ã‹ã‚Šã¾ã™ã€‚``U+12CA`` "
"ã¯ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ã‚ã‚Šã€ãã‚Œã¯ã‚ã‚‹ç‰¹å®šã®æ–‡å­—ã‚’è¡¨ã—ã¦ã„ã‚‹ã®ã§ã™; ã“ã®å ´åˆã§ã¯ã€'ETHIOPIC SYLLABLE WI' "
"ã¨ã„ã†æ–‡å­—ã‚’è¡¨ã—ã¦ã„ã¾ã™ã€‚å½¢å¼ã°ã‚‰ãªã„æ–‡è„ˆã§ã¯ã€ã“ã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¨æ–‡å­—ã®åŒºåˆ¥ã¯å¿˜ã‚Œå»ã‚‰ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:113
msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the exact "
"details will depend on the font being used.  Most Python code doesn't need "
"to worry about glyphs; figuring out the correct glyph to display is "
"generally the job of a GUI toolkit or a terminal's font renderer."
msgstr ""
"æ–‡å­—ã¯ç”»é¢ã‚„ç´™é¢ä¸Šã§ã¯ **ã‚°ãƒªãƒ• (glyph)** ã¨å‘¼ã°ã‚Œã‚‹ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯è¦ç´ ã®çµ„ã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚å¤§æ–‡å­—ã® A "
"ã®ã‚°ãƒªãƒ•ã¯ä¾‹ãˆã°ã€å³å¯†ãªå½¢ã¯ä½¿ã£ã¦ã„ã‚‹ãƒ•ã‚©ãƒ³ãƒˆã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ãŒã€æ–œã‚ã®ç·šã¨æ°´å¹³ã®ç·šã§ã™ã€‚ãŸã„ã¦ã„ã® Python "
"ã‚³ãƒ¼ãƒ‰ã§ã¯ã‚°ãƒªãƒ•ã®å¿ƒé…ã‚’ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“; ä¸€èˆ¬çš„ã«ã¯è¡¨ç¤ºã™ã‚‹æ­£ã—ã„ã‚°ãƒªãƒ•ã‚’è¦‹ä»˜ã‘ã‚‹ã“ã¨ã¯ GUI toolkit "
"ã‚„ç«¯æœ«ã®ãƒ•ã‚©ãƒ³ãƒˆãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ä»•äº‹ã§ã™ã€‚"

#: ../../howto/unicode.rst:122
msgid "Encodings"
msgstr "ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°"

#: ../../howto/unicode.rst:124
msgid ""
"To summarize the previous section: a Unicode string is a sequence of code "
"points, which are numbers from 0 through ``0x10FFFF`` (1,114,111 decimal).  "
"This sequence needs to be represented as a set of bytes (meaning, values "
"from 0 through 255) in memory.  The rules for translating a Unicode string "
"into a sequence of bytes are called an **encoding**."
msgstr ""
"å‰ã®ç¯€ã‚’ã¾ã¨ã‚ã‚‹ã¨: Unicode æ–‡å­—åˆ—ã¯ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã‚ã‚Šã€ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¨ã¯ 0 ã‹ã‚‰ ``0x10FFFF`` (10 é€²è¡¨è¨˜ã§"
" 1,114,111) ã¾ã§ã®æ•°å€¤ã§ã™ã€‚ã“ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ãƒ¡ãƒ¢ãƒªä¸Šã§ã¯ãƒã‚¤ãƒˆ (ã¤ã¾ã‚Š 0 ã‹ã‚‰ 255 ã¾ã§ã®å€¤) "
"ã®é›†ã¾ã‚Šã¨ã—ã¦è¡¨ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚Unicode æ–‡å­—åˆ—ã‚’ãƒã‚¤ãƒˆã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦ç¿»è¨³ã™ã‚‹è¦å‰‡ã‚’ **ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° (encoding)** "
"ã¨å‘¼ã³ã¾ã™ã€‚"

#: ../../howto/unicode.rst:130
msgid ""
"The first encoding you might think of is an array of 32-bit integers.  In "
"this representation, the string \"Python\" would look like this:"
msgstr "ã¾ãšè€ƒãˆä»˜ãã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ 32-bit æ•´æ•°ã®é…åˆ—ã§ã—ã‚‡ã†ã€‚ã“ã®è¡¨ç¾ã§ã¯ã€æ–‡å­—åˆ— \"Python\" ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚‹ã§ã—ã‚‡ã†:"

#: ../../howto/unicode.rst:139
msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr "ã“ã®è¡¨ç¾ã¯ç›´æ¥çš„ã§ã‚ã‹ã‚Šã‚„ã™ã„æ–¹æ³•ã§ã™ãŒã€ã“ã®è¡¨ç¾ã‚’ä½¿ã†ã«ã¯ã„ãã¤ã‹ã®å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:142
msgid "It's not portable; different processors order the bytes differently."
msgstr "å¯æ¬æ€§ãŒãªã„; ãƒ—ãƒ­ã‚»ãƒƒã‚µãŒç•°ãªã‚‹ã¨ãƒã‚¤ãƒˆã®é †åºã¥ã‘ã‚‚å¤‰ã‚ã£ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:144
msgid ""
"It's very wasteful of space.  In most texts, the majority of the code points"
" are less than 127, or less than 255, so a lot of space is occupied by "
"``0x00`` bytes.  The above string takes 24 bytes compared to the 6 bytes "
"needed for an ASCII representation.  Increased RAM usage doesn't matter too "
"much (desktop computers have gigabytes of RAM, and strings aren't usually "
"that large), but expanding our usage of disk and network bandwidth by a "
"factor of 4 is intolerable."
msgstr ""
"ç„¡é§„ãªé ˜åŸŸãŒå¤šã„ã§ã™ã€‚å¤šãã®æ–‡æ›¸ã§ã¯ã€ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯ 127 æœªæº€ã‚‚ã—ãã¯ 255 æœªæº€ãŒå¤šæ•°æ´¾ã‚’å ã‚ã€ãã®ãŸã‚å¤šãã®é ˜åŸŸãŒ ``0x00`` "
"ã¨ã„ã†ãƒã‚¤ãƒˆã§åŸ‹ã‚å°½ãã•ã‚Œã¾ã™ã€‚ä¸Šã®æ–‡å­—åˆ—ã¯ã€ASCII è¡¨ç¾ã§ã¯ 6 ãƒã‚¤ãƒˆãªã®ã«å¯¾ã—ã€24 ãƒã‚¤ãƒˆã®ã‚µã‚¤ã‚ºã«ãªã£ã¦ã„ã¾ã™ã€‚RAM "
"ã®ä½¿ç”¨é‡ãŒå¢—åŠ ã™ã‚‹ã®ã¯ãã‚Œã»ã©å•é¡Œã«ã¯ãªã‚Šã¾ã›ã‚“ (ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã¯ã‚®ã‚¬ãƒã‚¤ãƒˆå˜ä½ã® RAM "
"ã‚’æŒã£ã¦ãŠã‚Šã€é€šå¸¸ã€æ–‡å­—åˆ—ã¯ãã‚“ãªå¤§ãã•ã«ã¯ãªã‚Šã¾ã›ã‚“) ãŒã€ãƒ‡ã‚£ã‚¹ã‚¯ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å¤§åŸŸãŒ 4 å€å¤šãä½¿ã‚ã‚Œã¦ã—ã¾ã†ã®ã¯æˆ‘æ…¢ã§ãã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../howto/unicode.rst:152
msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a new"
" family of wide string functions would need to be used."
msgstr "``strlen()`` ã®ã‚ˆã†ãªç¾å­˜ã™ã‚‹ C é–¢æ•°ã¨äº’æ›æ€§ãŒã‚ã‚Šã¾ã›ã‚“ã€ãã®ãŸã‚ãƒ¯ã‚¤ãƒ‰æ–‡å­—åˆ—é–¢æ•°ä¸€å¼ãŒæ–°ãŸã«å¿…è¦ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:155
msgid ""
"Many Internet standards are defined in terms of textual data, and can't "
"handle content with embedded zero bytes."
msgstr "å¤šãã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¨™æº–ãŒãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¦ã€ãã‚Œã‚‰ã¯ã‚¼ãƒ­ãƒã‚¤ãƒˆã®åŸ‹ã‚è¾¼ã¾ã‚ŒãŸå†…å®¹ã‚’æ‰±ã†ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚"

#: ../../howto/unicode.rst:158
msgid ""
"Generally people don't use this encoding, instead choosing other encodings "
"that are more efficient and convenient.  UTF-8 is probably the most commonly"
" supported encoding; it will be discussed below."
msgstr ""
"ä¸€èˆ¬çš„ã«ã“ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ä½¿ã‚ãšã€å¤‰ã‚ã‚Šã«ã‚ˆã‚ŠåŠ¹ç‡çš„ã§ä¾¿åˆ©ãªä»–ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒé¸ã°ã‚Œã¦ã„ã¾ã™ã€‚ UTF-8 "
"ã¯ãŸã¶ã‚“æœ€ã‚‚ä¸€èˆ¬çš„ã«ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã™ã€‚ã“ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«ã¤ã„ã¦ã¯å¾Œã§èª¬æ˜ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:162
msgid ""
"Encodings don't have to handle every possible Unicode character, and most "
"encodings don't.  The rules for converting a Unicode string into the ASCII "
"encoding, for example, are simple; for each code point:"
msgstr ""
"ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯å…¨ã¦ã® Unicode æ–‡å­—ã‚’æ‰±ã†å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã—ã€å¤šãã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ãã‚Œã‚’ã—ã¾ã›ã‚“ã€‚Unicode æ–‡å­—åˆ—ã‚’ ASCII "
"ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«å¤‰æ›ã™ã‚‹è¦å‰‡ã¯å˜ç´”ã§ã™; ãã‚Œãã‚Œã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«å¯¾ã—ã¦:"

#: ../../howto/unicode.rst:166
msgid ""
"If the code point is < 128, each byte is the same as the value of the code "
"point."
msgstr "ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯128ã‚ˆã‚Šå°ã•ã„å ´åˆã€ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¨åŒã˜å€¤ã§ã™ã€‚"

#: ../../howto/unicode.rst:169
msgid ""
"If the code point is 128 or greater, the Unicode string can't be represented"
" in this encoding.  (Python raises a :exc:`UnicodeEncodeError` exception in "
"this case.)"
msgstr ""
"ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒ128ä»¥ä¸Šã®å ´åˆã€Unicode æ–‡å­—åˆ—ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ (ã“ã®å ´åˆ Python ã¯ "
":exc:`UnicodeEncodeError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚)"

#: ../../howto/unicode.rst:173
msgid ""
"Latin-1, also known as ISO-8859-1, is a similar encoding.  Unicode code "
"points 0--255 are identical to the Latin-1 values, so converting to this "
"encoding simply requires converting code points to byte values; if a code "
"point larger than 255 is encountered, the string can't be encoded into "
"Latin-1."
msgstr ""
"Latin-1, ISO-8859-1 ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚‚åŒæ§˜ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã™ã€‚Unicode ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã® 0--255 ã¯ "
"Latin-1 ã®å€¤ã¨ç­‰ä¾¡ãªã®ã§ã€ã“ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®å¤‰æ›ã™ã‚‹ã«ã¯ã€å˜ç´”ã«ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ãƒã‚¤ãƒˆå€¤ã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™; "
"ã‚‚ã—ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒ255ã‚ˆã‚Šå¤§ãã„å ´åˆã«é­é‡ã—ãŸå ´åˆã€æ–‡å­—åˆ—ã¯ Latin-1 ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ãã¾ã›ã‚“ã€‚"

#: ../../howto/unicode.rst:178
msgid ""
"Encodings don't have to be simple one-to-one mappings like Latin-1.  "
"Consider IBM's EBCDIC, which was used on IBM mainframes.  Letter values "
"weren't in one block: 'a' through 'i' had values from 129 to 137, but 'j' "
"through 'r' were 145 through 153.  If you wanted to use EBCDIC as an "
"encoding, you'd probably use some sort of lookup table to perform the "
"conversion, but this is largely an internal detail."
msgstr ""
"ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ Latin-1 ã®ã‚ˆã†ã«å˜ç´”ãªä¸€å¯¾ä¸€å¯¾å¿œã‚’æŒã£ã¦ã„ã¾ã›ã‚“ã€‚ IBM ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ã§ä½¿ã‚ã‚Œã¦ã„ãŸ IBM ã® EBCDIC "
"ã§è€ƒãˆã¦ã¿ã¾ã™ã€‚æ–‡å­—ã¯ä¸€ã¤ã®ãƒ–ãƒ­ãƒƒã‚¯ã«åã‚ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã§ã—ãŸ: 'a' ã‹ã‚‰ 'i' ã¯ 129 ã‹ã‚‰ 137 ã¾ã§ã§ã—ãŸãŒã€ 'j' ã‹ã‚‰ 'r' "
"ã¾ã§ã¯ 145 ã‹ã‚‰ 153 ã¾ã§ã—ãŸã€‚ EBICIC "
"ã‚’ä½¿ã„ãŸã„ã¨æ€ã£ãŸã‚‰ã€ãŠãã‚‰ãå¤‰æ›ã‚’å®Ÿè¡Œã™ã‚‹ãƒ«ãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ†ãƒ¼ãƒ–ãƒ«ã®é¡ã‚’ä½¿ã†å¿…è¦ãŒã‚ã‚‹ã§ã—ã‚‡ã†ã€ã“ã‚Œã¯å†…éƒ¨ã®è©³ç´°ã®ã“ã¨ã«ãªã‚Šã¾ã™ãŒã€‚"

#: ../../howto/unicode.rst:185
msgid ""
"UTF-8 is one of the most commonly used encodings.  UTF stands for \"Unicode "
"Transformation Format\", and the '8' means that 8-bit numbers are used in "
"the encoding.  (There are also a UTF-16 and UTF-32 encodings, but they are "
"less frequently used than UTF-8.)  UTF-8 uses the following rules:"
msgstr ""
"UTF-8 ã¯æœ€ã‚‚ã‚ˆãä½¿ã‚ã‚Œã¦ã„ã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®1ã¤ã§ã™ã€‚UTF ã¯ \"Unicode Transformation Format\" "
"ã‚’è¡¨ã—ã¦ã„ã¦ã€'8' ã¯ 8-bit æ•´æ•°ãŒã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€‚(UTF-16 ã‚„ UTF-32 "
"ã¨ã„ã†ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚‚ã‚ã‚Šã¾ã™ãŒã€ãã‚Œã‚‰ã¯ UTF-8 ã»ã©ã«ã¯é »ç¹ã«ä½¿ã‚ã‚Œã¾ã›ã‚“ã€‚) UTF-8 ã¯æ¬¡ã®ã‚ˆã†ãªãƒ«ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦ã„ã¾ã™:"

#: ../../howto/unicode.rst:190
msgid ""
"If the code point is < 128, it's represented by the corresponding byte "
"value."
msgstr "ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒ 128 æœªæº€ã ã£ãŸå ´åˆã€å¯¾å¿œã™ã‚‹ãƒã‚¤ãƒˆå€¤ã§è¡¨ç¾ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:191
msgid ""
"If the code point is >= 128, it's turned into a sequence of two, three, or "
"four bytes, where each byte of the sequence is between 128 and 255."
msgstr "ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒ 128 ä»¥ä¸Šã®å ´åˆã€128 ã‹ã‚‰ 255 ã¾ã§ã®ãƒã‚¤ãƒˆã‹ã‚‰ãªã‚‹ã€2ã€3 ã¾ãŸã¯ 4 ãƒã‚¤ãƒˆã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:194
msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8 ã¯ã„ãã¤ã‹ã®ä¾¿åˆ©ãªæ€§è³ªã‚’æŒã£ã¦ã„ã¾ã™:"

#: ../../howto/unicode.rst:196
msgid "It can handle any Unicode code point."
msgstr "ä»»æ„ã® Unicode ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’æ‰±ã†ã“ã¨ãŒã§ãã‚‹ã€‚"

#: ../../howto/unicode.rst:197
msgid ""
"A Unicode string is turned into a sequence of bytes containing no embedded "
"zero bytes.  This avoids byte-ordering issues, and means UTF-8 strings can "
"be processed by C functions such as ``strcpy()`` and sent through protocols "
"that can't handle zero bytes."
msgstr ""

#: ../../howto/unicode.rst:201
msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "ASCII ãƒ†ã‚­ã‚¹ãƒˆã®æ–‡å­—åˆ—ã¯ UTF-8 ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦ã‚‚æœ‰åŠ¹ã§ã™ã€‚"

#: ../../howto/unicode.rst:202
msgid ""
"UTF-8 is fairly compact; the majority of commonly used characters can be "
"represented with one or two bytes."
msgstr "UTF-8 ã¯ã‹ãªã‚Šã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã§ã™; ã‚ˆãä½¿ã‚ã‚Œã¦ã„ã‚‹æ–‡å­—ã®å¤§å¤šæ•°ã¯ 1 ãƒã‚¤ãƒˆã‹ 2 ãƒã‚¤ãƒˆã§è¡¨ç¾ã§ãã¾ã™ã€‚"

#: ../../howto/unicode.rst:204
msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of the "
"next UTF-8-encoded code point and resynchronize.  It's also unlikely that "
"random 8-bit data will look like valid UTF-8."
msgstr ""
"ãƒã‚¤ãƒˆãŒæ¬ è½ã—ãŸã‚Šã€å¤±ã‚ã‚ŒãŸå ´åˆã€æ¬¡ã® UTF-8 "
"ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®é–‹å§‹ã‚’æ±ºå®šã—ã€å†åŒæœŸã™ã‚‹ã“ã¨ãŒã§ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚åŒæ§˜ã®ç†ç”±ã§ãƒ©ãƒ³ãƒ€ãƒ ãª 8-bit ãƒ‡ãƒ¼ã‚¿ã¯æ­£å½“ãª UTF-8 "
"ã¨ã¿ãªã•ã‚Œã«ãããªã£ã¦ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:211 ../../howto/unicode.rst:485
#: ../../howto/unicode.rst:705
msgid "References"
msgstr "å‚è€ƒè³‡æ–™"

#: ../../howto/unicode.rst:213
msgid ""
"The `Unicode Consortium site <http://www.unicode.org>`_ has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  `A chronology "
"<http://www.unicode.org/history/>`_ of the origin and development of Unicode"
" is also available on the site."
msgstr ""
"`Unicode ã‚³ãƒ³ã‚½ãƒ¼ã‚·ã‚¢ãƒ ã®ã‚µã‚¤ãƒˆ <http://www.unicode.org>`_ ã«ã¯æ–‡å­—ã®å›³è¡¨ã€ç”¨èªè¾å…¸ã€PDF ç‰ˆã® Unicode "
"ä»•æ§˜ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œèª­ã‚€ã®ã¯ãã‚Œãªã‚Šã«é›£ã—ã„ã®ã§è¦šæ‚Ÿã—ã¦ãã ã•ã„ã€‚Unicode ã®èµ·æºã¨ç™ºå±•ã® `å¹´è¡¨ "
"<http://www.unicode.org/history/>`_ ã‚‚ã‚µã‚¤ãƒˆã«ã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:218
msgid ""
"To help understand the standard, Jukka Korpela has written `an introductory "
"guide <https://www.cs.tut.fi/~jkorpela/unicode/guide.html>`_ to reading the "
"Unicode character tables."
msgstr ""

#: ../../howto/unicode.rst:222
msgid ""
"Another `good introductory article "
"<http://www.joelonsoftware.com/articles/Unicode.html>`_ was written by Joel "
"Spolsky. If this introduction didn't make things clear to you, you should "
"try reading this alternate article before continuing."
msgstr ""
"ã¾ãŸåˆ¥ã® `è‰¯ã„å…¥é–€ã‚¬ã‚¤ãƒ‰ <http://www.joelonsoftware.com/articles/Unicode.html>`_ ã‚’ Joel"
" Spolsky ãŒæ›¸ã„ã¦ã„ã¾ã™ã€‚ã“ã® HOWTO ã®å…¥é–€ã‚’èª­ã‚“ã§ã‚‚ç†è§£ãŒæ˜ç¢ºã«ãªã‚‰ãªã‹ã£ãŸå ´åˆã¯ã€ç¶šãã‚’èª­ã‚€å‰ã«ã“ã®è¨˜äº‹ã‚’èª­ã‚“ã§ã¿ã‚‹ã¨ã‚ˆã„ã§ã™ã€‚"

#: ../../howto/unicode.rst:227
msgid ""
"Wikipedia entries are often helpful; see the entries for \"`character "
"encoding <https://en.wikipedia.org/wiki/Character_encoding>`_\" and `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_, for example."
msgstr ""

#: ../../howto/unicode.rst:233
msgid "Python's Unicode Support"
msgstr "Python ã® Unicode ã‚µãƒãƒ¼ãƒˆ"

#: ../../howto/unicode.rst:235
msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's "
"Unicode features."
msgstr "ã“ã“ã¾ã§ã§ Unicode ã®åŸºç¤ã‚’å­¦ã³ã¾ã—ãŸã€ã“ã“ã‹ã‚‰ Python ã® Unicode æ©Ÿèƒ½ã«è§¦ã‚Œã¾ã™ã€‚"

#: ../../howto/unicode.rst:239
msgid "The String Type"
msgstr "æ–‡å­—åˆ—å‹"

#: ../../howto/unicode.rst:241
msgid ""
"Since Python 3.0, the language features a :class:`str` type that contain "
"Unicode characters, meaning any string created using ``\"unicode rocks!\"``,"
" ``'unicode rocks!'``, or the triple-quoted string syntax is stored as "
"Unicode."
msgstr ""
"Python 3.0 ã‹ã‚‰ã€è¨€èªã¯ :class:`str` å‹ã‚’ Unicode æ–‡å­—ã‹ã‚‰æˆã‚‹ã‚‚ã®ã¨ã—ã¦ç‰¹å¾´ä»˜ã‘ã¦ã„ã¾ã™ã€ã¤ã¾ã‚Š "
"``\"unicode rocks!\"`` ã‚„ ``'unicode rocks!'`` ã‚„ä¸‰é‡ã‚¯ã‚ªãƒ¼ãƒˆæ–‡å­—åˆ—ã®æ§‹æ–‡ã‚’ä½¿ã£ã¦ä½œã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã¯ "
"Unicode ã¨ã—ã¦æ ¼ç´ã•ã‚Œã¾ã™ã€‚"

#: ../../howto/unicode.rst:245
msgid ""
"The default encoding for Python source code is UTF-8, so you can simply "
"include a Unicode character in a string literal::"
msgstr ""
"Python ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ UTF-8 ãªã®ã§ã€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã®ä¸­ã« Unicode "
"æ–‡å­—ã‚’ãã®ã¾ã¾å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../howto/unicode.rst:255
msgid ""
"You can use a different encoding from UTF-8 by putting a specially-formatted"
" comment as the first or second line of the source code::"
msgstr "ç‰¹æ®Šãªå½¢å¼ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®1è¡Œç›®ã‚‚ã—ãã¯2è¡Œç›®ã«é…ç½®ã™ã‚‹ã“ã¨ã§ã€UTF-8 ã§ã¯ãªã„ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™::"

#: ../../howto/unicode.rst:260
msgid ""
"Side note: Python 3 also supports using Unicode characters in identifiers::"
msgstr "è¿½è¨˜: Python3 ã¯ Unicode æ–‡å­—ã‚’ä½¿ã£ãŸè­˜åˆ¥å­ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™::"

#: ../../howto/unicode.rst:266
msgid ""
"If you can't enter a particular character in your editor or want to keep the"
" source code ASCII-only for some reason, you can also use escape sequences "
"in string literals. (Depending on your system, you may see the actual "
"capital-delta glyph instead of a \\u escape.) ::"
msgstr ""
"ã‚¨ãƒ‡ã‚£ã‚¿ã§ã‚ã‚‹ç‰¹å®šã®æ–‡å­—ãŒå…¥åŠ›ã§ããªã‹ã£ãŸã‚Šã€ã¨ã‚ã‚‹ç†ç”±ã§ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’ ASCII "
"ã®ã¿ã«ä¿ã¡ãŸã„å ´åˆã¯ã€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒä½¿ãˆã¾ã™ã€‚(ä½¿ã£ã¦ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ã¯ã€\\u "
"ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚ŒãŸæ–‡å­—åˆ—ã§ã¯ãªãã€å®Ÿç‰©ã®å¤§æ–‡å­—ã®ãƒ©ãƒ ãƒ€ã®ã‚°ãƒªãƒ•ãŒè¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚)::"

#: ../../howto/unicode.rst:278
msgid ""
"In addition, one can create a string using the :func:`~bytes.decode` method "
"of :class:`bytes`.  This method takes an *encoding* argument, such as "
"``UTF-8``, and optionally an *errors* argument."
msgstr ""
"åŠ ãˆã¦ã€ :class:`bytes` ã‚¯ãƒ©ã‚¹ã® :func:`~bytes.decode` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦æ–‡å­—åˆ—ã‚’ä½œã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯"
" ``UTF-8`` ã®ã‚ˆã†ãªå€¤ã‚’ *encoding* å¼•æ•°ã«å–ã‚Šã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ *errors* å¼•æ•°ã‚’å–ã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:282
msgid ""
"The *errors* argument specifies the response when the input string can't be "
"converted according to the encoding's rules.  Legal values for this argument"
" are ``'strict'`` (raise a :exc:`UnicodeDecodeError` exception), "
"``'replace'`` (use ``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` "
"(just leave the character out of the Unicode result), or "
"``'backslashreplace'`` (inserts a ``\\xNN`` escape sequence). The following "
"examples show the differences::"
msgstr ""
"*errors* å¼•æ•°ã¯ã€å…¥åŠ›æ–‡å­—åˆ—ã«å¯¾ã—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ«ãƒ¼ãƒ«ã«å¾“ã£ãŸå¤‰æ›ãŒã§ããªã‹ã£ãŸã¨ãã®å¯¾å¿œæ–¹æ³•ã‚’æŒ‡å®šã—ã¾ã™ã€‚ã“ã®å¼•æ•°ã«ä½¿ãˆã‚‹å€¤ã¯ "
"``'strict'`` (:exc:`UnicodeDecodeError` ã‚’é€å‡ºã™ã‚‹)ã€ ``'replace'`` (``REPLACEMENT"
" CHARACTER`` ã§ã‚ã‚‹ ``U+FFFD`` ã‚’ä½¿ã†)ã€ ``'ignore'`` (çµæœã¨ãªã‚‹ Unicode ã‹ã‚‰å˜ã«æ–‡å­—ã‚’é™¤ã) "
"ã€``'backslashreplace'`` (ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ``\\xNN`` ã‚’æŒ¿å…¥ã™ã‚‹) ã§ã™ã€‚æ¬¡ã®ä¾‹ã¯ã“ã‚Œã‚‰ã®é•ã„ã‚’ç¤ºã—ã¦ã„ã¾ã™::"

#: ../../howto/unicode.rst:302
msgid ""
"Encodings are specified as strings containing the encoding's name.  Python "
"3.2 comes with roughly 100 different encodings; see the Python Library "
"Reference at :ref:`standard-encodings` for a list.  Some encodings have "
"multiple names; for example, ``'latin-1'``, ``'iso_8859_1'`` and ``'8859``' "
"are all synonyms for the same encoding."
msgstr ""
"ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®åå‰ã‚’å«ã‚“ã æ–‡å­—åˆ—ã§æŒ‡å®šã•ã‚Œã¾ã™ã€‚ Python 3.2 ã¯ãŠã‚ˆã 100 "
"ã®ç•°ãªã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«å¯¾å¿œã—ã¦ã„ã¾ã™; ä¸€è¦§ã¯ Python ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã® :ref:`standard-encodings` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ã„ãã¤ã‹ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯è¤‡æ•°ã®åå‰ã‚’æŒã£ã¦ã„ã¾ã™; ä¾‹ãˆã°ã€ ``'latin-1'`` ã¨ ``'iso_8859_1'`` "
"ã¨ ``'8859'`` ã¯å…¨ã¦åŒã˜ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®åˆ¥åã§ã™ã€‚"

#: ../../howto/unicode.rst:308
msgid ""
"One-character Unicode strings can also be created with the :func:`chr` "
"built-in function, which takes integers and returns a Unicode string of "
"length 1 that contains the corresponding code point.  The reverse operation "
"is the built-in :func:`ord` function that takes a one-character Unicode "
"string and returns the code point value::"
msgstr ""
"Unicode æ–‡å­—åˆ—ã®ä¸€ã¤ã®æ–‡å­—ã¯ :func:`chr` "
"çµ„ã¿è¾¼ã¿é–¢æ•°ã§ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€ã“ã®é–¢æ•°ã¯æ•´æ•°ã‚’å¼•æ•°ã«ã¨ã‚Šã€å¯¾å¿œã™ã‚‹ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å«ã‚€é•·ã•1ã® Unicode æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚é€†ã®æ“ä½œã¯ "
":func:`ord` çµ„ã¿è¾¼ã¿é–¢æ•°ã§ã™ã€ã“ã®é–¢æ•°ã¯ä¸€æ–‡å­—ã® Unicode æ–‡å­—åˆ—ã‚’å¼•æ•°ã«ã¨ã‚Šã€ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆå€¤ã‚’è¿”ã—ã¾ã™::"

#: ../../howto/unicode.rst:320
msgid "Converting to Bytes"
msgstr "ãƒã‚¤ãƒˆåˆ—ã¸ã®å¤‰æ›"

#: ../../howto/unicode.rst:322
msgid ""
"The opposite method of :meth:`bytes.decode` is :meth:`str.encode`, which "
"returns a :class:`bytes` representation of the Unicode string, encoded in "
"the requested *encoding*."
msgstr ""
":meth:`bytes.decode` ã¨ã¯å‡¦ç†ãŒé€†å‘ãã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒ :meth:`str.encode` ã§ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ Unicode "
"æ–‡å­—åˆ—ã‚’æŒ‡å®šã•ã‚ŒãŸ *encoding* ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã¦ã€ :class:`bytes` ã«ã‚ˆã‚‹è¡¨ç¾ã§è¿”ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:326
msgid ""
"The *errors* parameter is the same as the parameter of the "
":meth:`~bytes.decode` method but supports a few more possible handlers. As "
"well as ``'strict'``, ``'ignore'``, and ``'replace'`` (which in this case "
"inserts a question mark instead of the unencodable character), there is also"
" ``'xmlcharrefreplace'`` (inserts an XML character reference), "
"``backslashreplace`` (inserts a ``\\uNNNN`` escape sequence) and "
"``namereplace`` (inserts a ``\\N{...}`` escape sequence)."
msgstr ""
"*errors* å¼•æ•°ã¯ :meth:`~bytes.decode` ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨åŒã˜ã‚‚ã®ã§ã™ãŒã€ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒãƒ³ãƒ‰ãƒ©ã®æ•°ãŒã‚‚ã†å°‘ã—å¤šã„ã§ã™ã€‚\n"
"``'strict'`` ã€ ``'ignore'`` ã€ ``'replace'`` (ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ããªã‹ã£ãŸæ–‡å­—ã®ä»£ã‚ã‚Šã«ç–‘å•ç¬¦ã‚’æŒ¿å…¥ã™ã‚‹) ã®ä»–ã«ã€ ``'xmlcharrefreplace'`` (XML æ–‡å­—å‚ç…§ã‚’æŒ¿å…¥ã™ã‚‹) ã¨ ``backslashreplace`` (ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ``\\nNNNN`` ã‚’æŒ¿å…¥ã™ã‚‹)ã€ ``namereplace`` (ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ``\\N{...}`` ã‚’æŒ¿å…¥ã™ã‚‹) ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:334
msgid "The following example shows the different results::"
msgstr "æ¬¡ã®ä¾‹ã§ã¯ã€ãã‚Œãã‚Œã®ç•°ãªã‚‹å‡¦ç†çµæœãŒç¤ºã•ã‚Œã¦ã„ã¾ã™::"

#: ../../howto/unicode.rst:355
msgid ""
"The low-level routines for registering and accessing the available encodings"
" are found in the :mod:`codecs` module.  Implementing new encodings also "
"requires understanding the :mod:`codecs` module. However, the encoding and "
"decoding functions returned by this module are usually more low-level than "
"is comfortable, and writing new encodings is a specialized task, so the "
"module won't be covered in this HOWTO."
msgstr ""
"åˆ©ç”¨å¯èƒ½ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ç™»éŒ²ã—ãŸã‚Šã€ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã‚Šã™ã‚‹ä½ãƒ¬ãƒ™ãƒ«ã®ãƒ«ãƒ¼ãƒãƒ³ã¯ :mod:`codecs` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ã‚Šã¾ã™ã€‚æ–°ã—ã„ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’å®Ÿè£…ã™ã‚‹ã«ã¯ã€ :mod:`codecs` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç†è§£ã—ã¦ã„ã‚‹ã“ã¨ã‚‚å¿…è¦ã«ãªã‚Šã¾ã™ã€‚ã—ã‹ã—ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚„ãƒ‡ã‚³ãƒ¼ãƒ‰ã®é–¢æ•°ã¯ã€ä½¿ã„å‹æ‰‹ãŒè‰¯ã„ã¨ã„ã†ã‚ˆã‚Šä½ãƒ¬ãƒ™ãƒ«ãªé–¢æ•°ã§ã€æ–°ã—ã„ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’æ›¸ãã®ã¯ç‰¹æ®Šãªä½œæ¥­ãªã®ã§ã€ã“ã®"
" HOWTO ã§ã¯æ‰±ã‚ãªã„ã“ã¨ã«ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:364
msgid "Unicode Literals in Python Source Code"
msgstr "Python ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å†…ã® Unicode ãƒªãƒ†ãƒ©ãƒ«"

#: ../../howto/unicode.rst:366
msgid ""
"In Python source code, specific Unicode code points can be written using the"
" ``\\u`` escape sequence, which is followed by four hex digits giving the "
"code point.  The ``\\U`` escape sequence is similar, but expects eight hex "
"digits, not four::"
msgstr ""
"Python ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å†…ã§ã¯ã€ç‰¹å®šã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ``\\u`` "
"ã‚’ä½¿ã„ã€ç¶šã‘ã¦ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’4æ¡ã®16é€²æ•°ã‚’æ›¸ãã¾ã™ã€‚ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ``\\U`` ã‚‚åŒæ§˜ã§ã™ã€ãŸã ã—4æ¡ã§ã¯ãªã8æ¡ã®16é€²æ•°ã‚’ä½¿ã„ã¾ã™::"

#: ../../howto/unicode.rst:378
msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters, as"
" you would in a program with messages in French or some other accent-using "
"language.  You can also assemble strings using the :func:`chr` built-in "
"function, but this is even more tedious."
msgstr ""
"127 "
"ã‚ˆã‚Šå¤§ãã„ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«å¯¾ã—ã¦ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ä½¿ã†ã®ã¯ã€ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒã‚ã¾ã‚Šå¤šããªã„ã†ã¡ã¯æœ‰åŠ¹ã§ã™ãŒã€ãƒ•ãƒ©ãƒ³ã‚¹èªç­‰ã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚’ä½¿ã†è¨€èªã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚ˆã†ãªå¤šãã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆæ–‡å­—ã‚’ä½¿ã†å ´åˆã«ã¯é‚ªé­”ã«ãªã‚Šã¾ã™ã€‚æ–‡å­—ã‚’"
" :func:`chr` çµ„ã¿è¾¼ã¿é–¢æ•°ã‚’ä½¿ã£ã¦çµ„ã¿ä¸Šã’ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ãŒã€ãã‚Œã¯ã•ã‚‰ã«é•·ããªã£ã¦ã—ã¾ã†ã§ã—ã‚‡ã†ã€‚"

#: ../../howto/unicode.rst:384
msgid ""
"Ideally, you'd want to be able to write literals in your language's natural "
"encoding.  You could then edit Python source code with your favorite editor "
"which would display the accented characters naturally, and have the right "
"characters used at runtime."
msgstr ""
"ç†æƒ³çš„ã«ã¯ã‚ãªãŸã®è¨€èªã®è‡ªç„¶ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ãƒªãƒ†ãƒ©ãƒ«ã‚’æ›¸ãã“ã¨ã§ã—ã‚‡ã†ã€‚ãã†ãªã‚Œã°ã€Python "
"ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’ã‚¢ã‚¯ã‚»ãƒ³ãƒˆä»˜ãã®æ–‡å­—ã‚’è‡ªç„¶ã«è¡¨ç¤ºã™ã‚‹ãŠæ°—ã«å…¥ã‚Šã®ã‚¨ãƒ‡ã‚£ã‚¿ã§ç·¨é›†ã—ã€å®Ÿè¡Œæ™‚ã«æ­£ã—ã„æ–‡å­—ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../howto/unicode.rst:389
msgid ""
"Python supports writing source code in UTF-8 by default, but you can use "
"almost any encoding if you declare the encoding being used.  This is done by"
" including a special comment as either the first or second line of the "
"source file::"
msgstr ""
"Python ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ UTF-8 "
"ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€ãŸã ã—ã©ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã†ã‹ã‚’å®£è¨€ã™ã‚Œã°ã»ã¨ã‚“ã©ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ãˆã¾ã™ã€‚ãã‚Œã¯ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸€è¡Œç›®ã‚„äºŒè¡Œç›®ã«ç‰¹åˆ¥ãªã‚³ãƒ¡ãƒ³ãƒˆã‚’å«ã‚ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã§ãã¾ã™::"

#: ../../howto/unicode.rst:399
msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local to"
" a file.  Emacs supports many different variables, but Python only supports "
"'coding'.  The ``-*-`` symbols indicate to Emacs that the comment is "
"special; they have no significance to Python but are a convention.  Python "
"looks for ``coding: name`` or ``coding=name`` in the comment."
msgstr ""
"ã“ã®æ§‹æ–‡ã¯ Emacs ã®ãƒ•ã‚¡ã‚¤ãƒ«å›ºæœ‰ã®å¤‰æ•°ã‚’æŒ‡å®šã™ã‚‹è¡¨è¨˜ã‹ã‚‰å½±éŸ¿ã‚’å—ã‘ã¦ã„ã¾ã™ã€‚Emacs ã¯æ§˜ã€…ãªå¤‰æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ãŒã€Python "
"ãŒã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã®ã¯ 'coding' ã®ã¿ã§ã™ã€‚ ``-*-`` ã®è¨˜æ³•ã¯ Emacs ã«å¯¾ã—ã¦ã‚³ãƒ¡ãƒ³ãƒˆãŒç‰¹åˆ¥ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã¯ "
"Python ã«ã¨ã£ã¦æ„å‘³ã¯ã‚ã‚Šã¾ã›ã‚“ãŒæ…£ç¿’ã§ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ Python ã¯ã‚³ãƒ¡ãƒ³ãƒˆä¸­ã« ``coding: name`` ã¾ãŸã¯ "
"``coding=name`` ã‚’æ¢ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:405
msgid ""
"If you don't include such a comment, the default encoding used will be UTF-8"
" as already mentioned.  See also :pep:`263` for more information."
msgstr ""
"ã“ã®ã‚ˆã†ãªã‚³ãƒ¡ãƒ³ãƒˆã‚’å«ã‚“ã§ã„ãªã„å ´åˆã€ã™ã§ã«è¿°ã¹ãŸé€šã‚Šã€ä½¿ã‚ã‚Œã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ UTF-8 ã«ãªã‚Šã¾ã™ã€‚ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã¯ "
":pep:`263` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../howto/unicode.rst:410
msgid "Unicode Properties"
msgstr "Unicode ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£"

#: ../../howto/unicode.rst:412
msgid ""
"The Unicode specification includes a database of information about code "
"points. For each defined code point, the information includes the "
"character's name, its category, the numeric value if applicable (Unicode has"
" characters representing the Roman numerals and fractions such as one-third "
"and four-fifths).  There are also properties related to the code point's use"
" in bidirectional text and other display-related properties."
msgstr ""
"Unicode "
"ä»•æ§˜ã¯ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«ã¤ã„ã¦ã®æƒ…å ±ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚‚å«ã‚“ã§ã„ã¾ã™ã€‚ãã‚Œãã‚Œã®å®šç¾©ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«å¯¾ã—ã¦ã€ãã®æƒ…å ±ã¯æ–‡å­—ã®åå‰ã€ã‚«ãƒ†ã‚´ãƒªã€é©ç”¨å¯èƒ½ã§ã‚ã‚Œã°æ•°å€¤"
" (Unicode ã«ã¯ãƒ­ãƒ¼ãƒæ•°å­—ã‚„ 1/3 ã‚„ 4/5 ã®ã‚ˆã†ãªåˆ†æ•°ã‚’è¡¨ã™æ–‡å­—ãŒã‚ã‚Šã¾ã™) "
"ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚ã¾ãŸã€å³ã‹ã‚‰èª­ã‚€ãƒ†ã‚­ã‚¹ãƒˆã¨å·¦ã‹ã‚‰èª­ã‚€ãƒ†ã‚­ã‚¹ãƒˆãŒæ··åœ¨ã—ã¦ã„ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã§ã®ãã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®èª­ã‚€æ–¹å‘ã‚„ã€ä»–ã®è¡¨ç¤ºã«é–¢é€£ã—ãŸç‰¹è³ªã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:419
msgid ""
"The following program displays some information about several characters, "
"and prints the numeric value of one particular character::"
msgstr "ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã„ãã¤ã‹ã®æ–‡å­—ã«å¯¾ã™ã‚‹æƒ…å ±ã‚’è¡¨ç¤ºã—ã€ç‰¹å®šã®æ–‡å­—ã®æ•°å€¤ã‚’å°å­—ã—ã¾ã™::"

#: ../../howto/unicode.rst:433
msgid "When run, this prints:"
msgstr "å®Ÿè¡Œã™ã‚‹ã¨ã€ã“ã®ã‚ˆã†ã«å‡ºåŠ›ã•ã‚Œã¾ã™::"

#: ../../howto/unicode.rst:444
msgid ""
"The category codes are abbreviations describing the nature of the character."
" These are grouped into categories such as \"Letter\", \"Number\", "
"\"Punctuation\", or \"Symbol\", which in turn are broken up into "
"subcategories.  To take the codes from the above output, ``'Ll'`` means "
"'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is \"Mark, "
"nonspacing\", and ``'So'`` is \"Symbol, other\".  See `the General Category "
"Values section of the Unicode Character Database documentation "
"<http://www.unicode.org/reports/tr44/#General_Category_Values>`_ for a list "
"of category codes."
msgstr ""
"ã‚«ãƒ†ã‚´ãƒªãƒ¼ã‚³ãƒ¼ãƒ‰ã¯æ–‡å­—ã®æ€§è³ªã‚’ç•¥è¨˜ã§è¡¨ã—ãŸã‚‚ã®ã§ã™ã€‚ã‚«ãƒ†ã‚´ãƒªãƒ¼ã‚³ãƒ¼ãƒ‰ã¯ "
"\"Letter\"ã€\"Number\"ã€\"Punctuation\"ã€\"Symbol\" "
"ãªã©ã®ã‚«ãƒ†ã‚´ãƒªãƒ¼ã«åˆ†é¡ã•ã‚Œã€ã•ã‚‰ã«ã‚µãƒ–ã‚«ãƒ†ã‚´ãƒªãƒ¼ã«ç´°åˆ†åŒ–ã•ã‚Œã¾ã™ã€‚ä¸Šè¨˜ã®å‡ºåŠ›ã‹ã‚‰ã‚³ãƒ¼ãƒ‰ã‚’æ‹¾ã†ã¨ã€``'Ll'`` ã¯ 'Letter, "
"lowercase'ã€``'No'`` ã¯ \"Number, other\"ã€``'Mn'`` ã¯ \"Mark, "
"nonspacing\"ã€``'So'`` ã¯ \"Symbol, other\" ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€‚ã‚«ãƒ†ã‚´ãƒªãƒ¼ã‚³ãƒ¼ãƒ‰ã®ä¸€è¦§ã¯ `Unicode "
"Character Database æ–‡æ›¸ã® General Category Values ç¯€ "
"<http://www.unicode.org/reports/tr44/#General_Category_Values>`_ ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../howto/unicode.rst:455
msgid "Unicode Regular Expressions"
msgstr "Unicode æ­£è¦è¡¨ç¾"

#: ../../howto/unicode.rst:457
msgid ""
"The regular expressions supported by the :mod:`re` module can be provided "
"either as bytes or strings.  Some of the special character sequences such as"
" ``\\d`` and ``\\w`` have different meanings depending on whether the "
"pattern is supplied as bytes or a string.  For example, ``\\d`` will match "
"the characters ``[0-9]`` in bytes but in strings will match any character "
"that's in the ``'Nd'`` category."
msgstr ""
":mod:`re` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹æ­£è¦è¡¨ç¾ã¯ãƒã‚¤ãƒˆåˆ—ã‚„æ–‡å­—åˆ—ã¨ã—ã¦ä¸ãˆã‚‰ã‚Œã¾ã™ã€‚ ``\\d`` ã‚„ ``\\w`` "
"ãªã©ã®ã„ãã¤ã‹ã®ç‰¹æ®Šãªæ–‡å­—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€ãã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒãƒã‚¤ãƒˆåˆ—ã¨ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸã®ã‹æ–‡å­—åˆ—ã¨ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸã®ã‹ã«ã‚ˆã£ã¦ã€ç•°ãªã‚‹æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚ä¾‹ãˆã°ã€ "
"``\\d`` ã¯ãƒã‚¤ãƒˆåˆ—ã§ã¯ ``[0-9]`` ã®ç¯„å›²ã®æ–‡å­—ã¨ä¸€è‡´ã—ã¾ã™ãŒã€æ–‡å­—åˆ—ã§ã¯ ``'Nd'`` ã‚«ãƒ†ã‚´ãƒªãƒ¼ã«ã‚ã‚‹ä»»æ„ã®æ–‡å­—ã¨ä¸€è‡´ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:464
msgid ""
"The string in this example has the number 57 written in both Thai and Arabic"
" numerals::"
msgstr "ã“ã®ä¾‹ã«ã‚ã‚‹æ–‡å­—åˆ—ã«ã¯ã€ã‚¿ã‚¤èªã®æ•°å­—ã¨ã‚¢ãƒ©ãƒ“ã‚¢æ•°å­—ã®ä¸¡æ–¹ã§æ•°å­—ã® 57 ãŒæ›¸ã„ã¦ã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:474
msgid ""
"When executed, ``\\d+`` will match the Thai numerals and print them out.  If"
" you supply the :const:`re.ASCII` flag to :func:`~re.compile`, ``\\d+`` will"
" match the substring \"57\" instead."
msgstr ""
"å®Ÿè¡Œã™ã‚‹ã¨ã€ ``\\d+`` ã¯ã‚¿ã‚¤èªã®æ•°å­—ã¨ä¸€è‡´ã—ã€ãã‚Œã‚’å‡ºåŠ›ã—ã¾ã™ã€‚ãƒ•ãƒ©ã‚° :const:`re.ASCII` ã‚’ "
":func:`~re.compile` ã«æ¸¡ã—ãŸå ´åˆã€ ``\\d+`` ã¯å…ˆç¨‹ã¨ã¯é•ã£ã¦éƒ¨åˆ†æ–‡å­—åˆ— \"57\" ã«ä¸€è‡´ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:478
msgid ""
"Similarly, ``\\w`` matches a wide variety of Unicode characters but only "
"``[a-zA-Z0-9_]`` in bytes or if :const:`re.ASCII` is supplied, and ``\\s`` "
"will match either Unicode whitespace characters or ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"åŒæ§˜ã«ã€ ``\\w`` ã¯éå¸¸ã«å¤šãã® Unicode æ–‡å­—ã«ä¸€è‡´ã—ã¾ã™ãŒã€ãƒã‚¤ãƒˆåˆ—ã®å ´åˆã‚‚ã—ãã¯ :const:`re.ASCII` "
"ãŒæ¸¡ã•ã‚ŒãŸå ´åˆã¯ ``[a-zA-Z0-9_]`` ã«ã—ã‹ä¸€è‡´ã—ã¾ã›ã‚“ã€‚ ``\\s`` ã¯æ–‡å­—åˆ—ã§ã¯ Unicode ç©ºç™½æ–‡å­—ã«ã€ãƒã‚¤ãƒˆåˆ—ã§ã¯ ``["
" \\t\\n\\r\\f\\v]`` ã«ä¸€è‡´ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:489
msgid "Some good alternative discussions of Python's Unicode support are:"
msgstr "Python ã® Unicode ã‚µãƒãƒ¼ãƒˆã«ã¤ã„ã¦ã®å‚è€ƒã«ãªã‚‹è­°è«–ã¯ä»¥ä¸‹ã®2ã¤ã§ã™:"

#: ../../howto/unicode.rst:491
msgid ""
"`Processing Text Files in Python 3 <http://python-"
"notes.curiousefficiency.org/en/latest/python3/text_file_processing.html>`_, "
"by Nick Coghlan."
msgstr ""
"Nick Coghlan ã«ã‚ˆã‚‹ `Processing Text Files in Python 3 <http://python-"
"notes.curiousefficiency.org/en/latest/python3/text_file_processing.html>`_"

#: ../../howto/unicode.rst:492
msgid ""
"`Pragmatic Unicode <http://nedbatchelder.com/text/unipain.html>`_, a PyCon "
"2012 presentation by Ned Batchelder."
msgstr ""
"Ned Batchelder ã«ã‚ˆã‚‹ PyCon 2012 ã§ã®ç™ºè¡¨ `Pragmatic Unicode "
"<http://nedbatchelder.com/text/unipain.html>`_"

#: ../../howto/unicode.rst:494
msgid ""
"The :class:`str` type is described in the Python library reference at "
":ref:`textseq`."
msgstr ":class:`str` å‹ã«ã¤ã„ã¦ã¯ Python ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã® :ref:`textseq` ã§è§£èª¬ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:497
msgid "The documentation for the :mod:`unicodedata` module."
msgstr ":mod:`unicodedata` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€‚"

#: ../../howto/unicode.rst:499
msgid "The documentation for the :mod:`codecs` module."
msgstr ":mod:`codecs` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€‚"

#: ../../howto/unicode.rst:501
msgid ""
"Marc-AndrÃ© Lemburg gave `a presentation titled \"Python and Unicode\" (PDF "
"slides) <https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>`_ at "
"EuroPython 2002.  The slides are an excellent overview of the design of "
"Python 2's Unicode features (where the Unicode string type is called "
"``unicode`` and literals start with ``u``)."
msgstr ""
"Marc-AndrÃ© Lemburg ã¯ EuroPython 2002 ã§ `\"Python and Unicode\" "
"ã¨ã„ã†ã‚¿ã‚¤ãƒˆãƒ«ã®ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ (PDF ã‚¹ãƒ©ã‚¤ãƒ‰) <https://downloads.egenix.com/python/Unicode-"
"EPC2002-Talk.pdf>`_ ã‚’è¡Œã„ã¾ã—ãŸã€‚ã“ã®ã‚¹ãƒ©ã‚¤ãƒ‰ã¯ Python 2 ã® Unicode æ©Ÿèƒ½ (Unicode æ–‡å­—åˆ—å‹ãŒ "
"``unicode`` ã¨å‘¼ã°ã‚Œã€ãƒªãƒ†ãƒ©ãƒ«ã¯ ``u`` ã§å§‹ã¾ã‚Šã¾ã™) ã®è¨­è¨ˆã«ã¤ã„ã¦æ¦‚è¦³ã™ã‚‹ç´ æ™´ã—ã„è³‡æ–™ã§ã™ã€‚"

#: ../../howto/unicode.rst:509
msgid "Reading and Writing Unicode Data"
msgstr "Unicode ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿æ›¸ãã™ã‚‹"

#: ../../howto/unicode.rst:511
msgid ""
"Once you've written some code that works with Unicode data, the next problem"
" is input/output.  How do you get Unicode strings into your program, and how"
" do you convert Unicode into a form suitable for storage or transmission?"
msgstr ""
"ä¸€æ—¦ Unicode ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã‚³ãƒ¼ãƒ‰ãŒå‹•ä½œã™ã‚‹ã‚ˆã†ã«æ›¸ãçµ‚ãˆãŸã‚‰ã€æ¬¡ã®å•é¡Œã¯å…¥å‡ºåŠ›ã§ã™ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ Unicode æ–‡å­—åˆ—ã‚’ã©ã†å—ã‘ã¨ã‚Šã€ã©ã† "
"Unicode ã‚’å¤–éƒ¨è¨˜æ†¶è£…ç½®ã‚„é€å—ä¿¡è£…ç½®ã«é©ã—ãŸå½¢å¼ã«å¤‰æ›ã™ã‚‹ã®ã§ã—ã‚‡ã†?"

#: ../../howto/unicode.rst:515
msgid ""
"It's possible that you may not need to do anything depending on your input "
"sources and output destinations; you should check whether the libraries used"
" in your application support Unicode natively.  XML parsers often return "
"Unicode data, for example.  Many relational databases also support Unicode-"
"valued columns and can return Unicode values from an SQL query."
msgstr ""
"å…¥åŠ›ã‚½ãƒ¼ã‚¹ã¨å‡ºåŠ›å…ˆã«ä¾å­˜ã—ãªã„ã‚ˆã†ãªæ–¹æ³•ã¯å¯èƒ½ã§ã™; ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒ Unicode "
"ã‚’ãã®ã¾ã¾ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ã‚’èª¿ã¹ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚ä¾‹ãˆã° XML ãƒ‘ãƒ¼ã‚µãƒ¼ã¯å¤§æŠµ Unicode "
"ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚å¤šãã®ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒŠãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚‚ Unicode å€¤ã®å…¥ã£ãŸã‚³ãƒ©ãƒ ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã—ã€ SQL ã®å•ã„åˆã‚ã›ã§ Unicode "
"å€¤ã‚’è¿”ã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../howto/unicode.rst:521
msgid ""
"Unicode data is usually converted to a particular encoding before it gets "
"written to disk or sent over a socket.  It's possible to do all the work "
"yourself: open a file, read an 8-bit bytes object from it, and convert the "
"bytes with ``bytes.decode(encoding)``.  However, the manual approach is not "
"recommended."
msgstr ""
"Unicode "
"ã®ãƒ‡ãƒ¼ã‚¿ã¯ãƒ‡ã‚£ã‚¹ã‚¯ã«æ›¸ãè¾¼ã¾ã‚Œã‚‹ã«ã‚ãŸã£ã¦é€šå¸¸ã€ç‰¹å®šã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚æ¨å¥¨ã¯ã•ã‚Œã¾ã›ã‚“ãŒã€ã“ã‚Œã‚’æ‰‹å‹•ã§è¡Œã†ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãã€8ãƒã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’èª­ã¿è¾¼ã¿ã€ãƒã‚¤ãƒˆåˆ—ã‚’"
" ``bytes.decode(encoding)`` ã§å¤‰æ›ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šå®Ÿç¾ã§ãã¾ã™ã€‚"

#: ../../howto/unicode.rst:526
msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character can"
" be represented by several bytes.  If you want to read the file in "
"arbitrary-sized chunks (say, 1024 or 4096 bytes), you need to write error-"
"handling code to catch the case where only part of the bytes encoding a "
"single Unicode character are read at the end of a chunk.  One solution would"
" be to read the entire file into memory and then perform the decoding, but "
"that prevents you from working with files that are extremely large; if you "
"need to read a 2 GiB file, you need 2 GiB of RAM. (More, really, since for "
"at least a moment you'd need to have both the encoded string and its Unicode"
" version in memory.)"
msgstr ""
"1ã¤ã®å•é¡Œã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ãƒãƒ«ãƒãƒã‚¤ãƒˆã¨ã„ã†æ€§è³ªã§ã™; 1ã¤ã® Unicode æ–‡å­—ã¯ã„ãã¤ã‹ã®ãƒã‚¤ãƒˆã§è¡¨ç¾ã•ã‚Œå¾—ã¾ã™ã€‚ä»»æ„ã®ã‚µã‚¤ã‚ºã®ãƒãƒ£ãƒ³ã‚¯ "
"(ä¾‹ãˆã°ã€1024 ã‚‚ã—ãã¯ 4096 ãƒã‚¤ãƒˆ) ã«ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’èª­ã¿è¾¼ã¿ãŸã„å ´åˆã€ã‚ã‚‹ 1 ã¤ã® Unicode "
"æ–‡å­—ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸãƒã‚¤ãƒˆåˆ—ãŒã€ãƒãƒ£ãƒ³ã‚¯ã®æœ«å°¾ã§ã®ä¸€éƒ¨åˆ†ã®ã¿èª­ã¿è¾¼ã¾ã‚Œã®å ´åˆã®ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®ãŸã‚ã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚1ã¤ã®è§£æ±ºç­–ã¯ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“ã‚’ãƒ¡ãƒ¢ãƒªã«èª­ã¿è¾¼ã¿ã€ãƒ‡ã‚³ãƒ¼ãƒ‰å‡¦ç†ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã™ãŒã€ã“ã†ã—ã¦ã—ã¾ã†ã¨éå¸¸ã«å¤§ããªãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†ã™ã‚‹ã¨ãã®å¦¨ã’ã«ãªã‚Šã¾ã™;"
" 2 GiB ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€å¿…è¦ãŒã‚ã‚‹å ´åˆã€2 GiB ã® RAM ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚(å®Ÿéš›ã«ã¯ã€å°‘ãªãã¨ã‚‚ã‚ã‚‹ç¬é–“ã§ã¯ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæ–‡å­—åˆ—ã¨"
" Unicode æ–‡å­—åˆ—ã®ä¸¡æ–¹ã‚’ãƒ¡ãƒ¢ãƒªã«ä¿æŒã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€ã‚ˆã‚Šå¤šãã®ãƒ¡ãƒ¢ãƒªãŒå¿…è¦ã§ã™ã€‚)"

#: ../../howto/unicode.rst:536
msgid ""
"The solution would be to use the low-level decoding interface to catch the "
"case of partial coding sequences.  The work of implementing this has already"
" been done for you: the built-in :func:`open` function can return a file-"
"like object that assumes the file's contents are in a specified encoding and"
" accepts Unicode parameters for methods such as :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.write`.  This works through :func:`open`\\'s "
"*encoding* and *errors* parameters which are interpreted just like those in "
":meth:`str.encode` and :meth:`bytes.decode`."
msgstr ""

#: ../../howto/unicode.rst:545
msgid "Reading Unicode from a file is therefore simple::"
msgstr "ãã®ãŸã‚ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ Unicode ã‚’èª­ã‚€ã®ã¯å˜ç´”ã§ã™::"

#: ../../howto/unicode.rst:551
msgid ""
"It's also possible to open files in update mode, allowing both reading and "
"writing::"
msgstr "èª­ã¿æ›¸ãã®ä¸¡æ–¹ãŒã§ãã‚‹ update ãƒ¢ãƒ¼ãƒ‰ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãã“ã¨ã‚‚å¯èƒ½ã§ã™::"

#: ../../howto/unicode.rst:559
msgid ""
"The Unicode character ``U+FEFF`` is used as a byte-order mark (BOM), and is "
"often written as the first character of a file in order to assist with "
"autodetection of the file's byte ordering.  Some encodings, such as UTF-16, "
"expect a BOM to be present at the start of a file; when such an encoding is "
"used, the BOM will be automatically written as the first character and will "
"be silently dropped when the file is read.  There are variants of these "
"encodings, such as 'utf-16-le' and 'utf-16-be' for little-endian and big-"
"endian encodings, that specify one particular byte ordering and don't skip "
"the BOM."
msgstr ""
"Unicode æ–‡å­— ``U+FEFF`` ã¯ byte-order mark (BOM) "
"ã¨ã—ã¦ä½¿ã‚ã‚Œã€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒã‚¤ãƒˆé †ã®è‡ªå‹•åˆ¤å®šã‚’æ”¯æ´ã™ã‚‹ãŸã‚ã«ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€åˆã®æ–‡å­—ã¨ã—ã¦æ›¸ã‹ã‚Œã¾ã™ã€‚UTF-16 "
"ã®ã‚ˆã†ãªã„ãã¤ã‹ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã« BOM ãŒã‚ã‚‹ã“ã¨ã‚’è¦æ±‚ã—ã¾ã™; ãã®ã‚ˆã†ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒä½¿ã‚ã‚Œã‚‹ã¨ãã€è‡ªå‹•çš„ã« BOM "
"ãŒæœ€åˆã®æ–‡å­—ã¨ã—ã¦æ›¸ã‹ã‚Œã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€ã¨ãã«æš—é»™ã®å†…ã«å–ã‚Šé™¤ã‹ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«ã¯ã€ãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ (little-endian)"
" ç”¨ã® 'utf-16-le' ã‚„ãƒ“ãƒƒã‚°ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ (big-endian) ç”¨ã® 'utf-16-be' "
"ã¨ã„ã†ã‚ˆã†ãªå¤‰ç¨®ãŒã‚ã‚Šã€ã“ã‚Œã‚‰ã¯ç‰¹å®šã®1ã¤ã®ãƒã‚¤ãƒˆé †ã‚’æŒ‡å®šã—ã¦ã„ã¦ BOM ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã›ã‚“ã€‚"

#: ../../howto/unicode.rst:568
msgid ""
"In some areas, it is also convention to use a \"BOM\" at the start of UTF-8 "
"encoded files; the name is misleading since UTF-8 is not byte-order "
"dependent. The mark simply announces that the file is encoded in UTF-8.  Use"
" the 'utf-8-sig' codec to automatically skip the mark if present for reading"
" such files."
msgstr ""
"ã„ãã¤ã‹ã®é ˜åŸŸã§ã¯ã€UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã« \"BOM\" ã‚’åˆ©ç”¨ã™ã‚‹ç¿’æ…£ãŒã‚ã‚Šã¾ã™; "
"ã“ã®åå‰ã¯ã‚ˆãèª¤è§£ã‚’æ‹›ãã¾ã™ãŒã€UTF-8 ã¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ã«ä¾å­˜ã—ã¾ã›ã‚“ã€‚\"BOM\" ã®å°ã¯å˜ã«ãƒ•ã‚¡ã‚¤ãƒ«ãŒ UTF-8 "
"ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’çŸ¥ã‚‰ã›ã‚‹ã‚‚ã®ã§ã™ã€‚ã‚‚ã—ã€ãã®ã‚ˆã†ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€å ´åˆã«ã¯ã€ã“ã®å°ã‚’è‡ªå‹•çš„ã«ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ãŸã‚ã« 'utf-8-sig' "
"ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ã‚’åˆ©ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../howto/unicode.rst:576
msgid "Unicode filenames"
msgstr "Unicode ãƒ•ã‚¡ã‚¤ãƒ«å"

#: ../../howto/unicode.rst:578
msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on "
"the system.  For example, Mac OS X uses UTF-8 while Windows uses a "
"configurable encoding; on Windows, Python uses the name \"mbcs\" to refer to"
" whatever the currently configured encoding is.  On Unix systems, there will"
" only be a filesystem encoding if you've set the ``LANG`` or ``LC_CTYPE`` "
"environment variables; if you haven't, the default encoding is UTF-8."
msgstr ""
"å¤šãã® OS ã§ã¯ç¾åœ¨ä»»æ„ã® Unicode æ–‡å­—ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚é€šå¸¸ Unicode "
"æ–‡å­—åˆ—ã‚’ã‚·ã‚¹ãƒ†ãƒ ä¾å­˜ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«å¤‰æ›ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€Mac OS X ã¯ UTF-8 ã‚’åˆ©ç”¨ã—ã€Windows "
"ã§ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒè¨­å®šã§å¤‰æ›´ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™; Windows ã§ã¯ Python ã¯ \"mbcs\" "
"ã¨ã„ã†åå‰ã«ç¾åœ¨è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’å•ã„åˆã‚ã›ã¦åˆ©ç”¨ã—ã¾ã™ã€‚Unix ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ ``LANG`` ã‚„ ``LC_CTYPE`` "
"ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã—ã¦ã„ã‚Œã°ã€ãã‚Œã ã‘ãŒãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¨ãªã‚Šã¾ã™; ã‚‚ã—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¨­å®šã—ãªã‘ã‚Œã°ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ "
"UTF-8 ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/unicode.rst:587
msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to use "
"on your current system, in case you want to do the encoding manually, but "
"there's not much reason to bother.  When opening a file for reading or "
"writing, you can usually just provide the Unicode string as the filename, "
"and it will be automatically converted to the right encoding for you::"
msgstr ""
":func:`sys.getfilesystemencoding` "
"é–¢æ•°ã¯ç¾åœ¨ã®ã‚·ã‚¹ãƒ†ãƒ ã§åˆ©ç”¨ã™ã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿”ã—ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’æ‰‹å‹•ã§è¨­å®šã—ãŸã„å ´åˆåˆ©ç”¨ã—ã¾ã™ã€ãŸã ã—ã‚ã–ã‚ã–ãã†ã™ã‚‹ç©æ¥µçš„ãªç†ç”±ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚èª­ã¿æ›¸ãã®ãŸã‚ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãæ™‚ã«ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«åã‚’"
" Unicode æ–‡å­—åˆ—ã¨ã—ã¦æ¸¡ã™ã ã‘ã§æ­£ã—ã„ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«è‡ªå‹•çš„ã«å¤‰æ›´ã•ã‚Œã¾ã™::"

#: ../../howto/unicode.rst:597
msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also accept "
"Unicode filenames."
msgstr ":func:`os.stat` ã®ã‚ˆã†ãª :mod:`os` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–¢æ•°ã‚‚ Unicode ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚"

#: ../../howto/unicode.rst:600
msgid ""
"The :func:`os.listdir` function returns filenames and raises an issue: "
"should it return the Unicode version of filenames, or should it return bytes"
" containing the encoded versions?  :func:`os.listdir` will do both, "
"depending on whether you provided the directory path as bytes or a Unicode "
"string.  If you pass a Unicode string as the path, filenames will be decoded"
" using the filesystem's encoding and a list of Unicode strings will be "
"returned, while passing a byte path will return the filenames as bytes.  For"
" example, assuming the default filesystem encoding is UTF-8, running the "
"following program::"
msgstr ""
":func:`os.listdir` é–¢æ•°ã¯ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¿”ã—ã¾ã™ãŒã€ã“ã“ã§å•é¡ŒãŒèµ·ãã¾ã™: ã“ã®é–¢æ•°ã¯ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ Unicode "
"ã§è¿”ã™ã¹ãã§ã—ã‚‡ã†ã‹? ãã‚Œã¨ã‚‚ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒã‚¤ãƒˆåˆ—ã§è¿”ã™ã¹ãã§ã—ã‚‡ã†ã‹? :func:`os.listdir` "
"ã¯ã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹ã‚’ãƒã‚¤ãƒˆåˆ—ã¨ã—ã¦æ¸¡ã—ãŸã‹ã€ Unicode æ–‡å­—åˆ—ã¨ã—ã¦æ¸¡ã—ãŸã‹ã«ã‚ˆã£ã¦ã€ã©ã¡ã‚‰ã®å½¢å¼ã§ã‚‚è¿”ã›ã¾ã™ã€‚ãƒ‘ã‚¹ã‚’ Unicode "
"æ–‡å­—åˆ—ã¨ã—ã¦æ¸¡ã—ãŸå ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«åã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã£ã¦ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚Œã€ Unicode "
"æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆãŒè¿”ã•ã‚Œã¾ã™ã€‚ãã®ä¸€æ–¹ã€ãƒã‚¤ãƒˆåˆ—ã®ãƒ‘ã‚¹ã‚’æ¸¡ã™ã¨ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ãƒã‚¤ãƒˆåˆ—ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒ "
"UTF-8 ã ã¨ä»®å®šã—ã¦ã€ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã™ã‚‹ã¨::"

#: ../../howto/unicode.rst:618
msgid "will produce the following output:"
msgstr "ä»¥ä¸‹ã®å‡ºåŠ›çµæœãŒç”Ÿæˆã•ã‚Œã¾ã™:"

#: ../../howto/unicode.rst:626
msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr "æœ€åˆã®ãƒªã‚¹ãƒˆã¯ UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«åã‚’å«ã¿ã€ç¬¬äºŒã®ãƒªã‚¹ãƒˆã¯ Unicode ç‰ˆã‚’å«ã‚“ã§ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:629
msgid ""
"Note that on most occasions, the Unicode APIs should be used.  The bytes "
"APIs should only be used on systems where undecodable file names can be "
"present, i.e. Unix systems."
msgstr ""
"ã»ã¼å…¨ã¦ã®çŠ¶æ³ã§ Unicode API ã‚’åˆ©ç”¨ã™ã¹ãã§ã™ã€‚bytes API ã¯ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«åãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ä¾‹ãˆã° "
"Unix ã‚·ã‚¹ãƒ†ãƒ ã€ã§ã®ã¿åˆ©ç”¨ã™ã¹ãã§ã™ã€‚"

#: ../../howto/unicode.rst:635
msgid "Tips for Writing Unicode-aware Programs"
msgstr "Unicode å¯¾å¿œã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ããŸã‚ã® Tips"

#: ../../howto/unicode.rst:637
msgid ""
"This section provides some suggestions on writing software that deals with "
"Unicode."
msgstr "ã“ã®ç« ã§ã¯ Unicode ã‚’æ‰±ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ããŸã‚ã®ã„ãã¤ã‹ã®ææ¡ˆã‚’ç´¹ä»‹ã—ã¾ã™ã€‚"

#: ../../howto/unicode.rst:640
msgid "The most important tip is:"
msgstr "æœ€ã‚‚é‡è¦ãªåŠ©è¨€ã¨ã—ã¦ã¯:"

#: ../../howto/unicode.rst:642
msgid ""
"Software should only work with Unicode strings internally, decoding the "
"input data as soon as possible and encoding the output only at the end."
msgstr "ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã¯å†…éƒ¨ã§ã¯ Unicode æ–‡å­—åˆ—ã®ã¿ã‚’åˆ©ç”¨ã—ã€å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã¯ã§ãã‚‹ã ã‘æ—©æœŸã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã€å‡ºåŠ›ã®ç›´å‰ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã¹ãã§ã™ã€‚"

#: ../../howto/unicode.rst:645
msgid ""
"If you attempt to write processing functions that accept both Unicode and "
"byte strings, you will find your program vulnerable to bugs wherever you "
"combine the two different kinds of strings.  There is no automatic encoding "
"or decoding: if you do e.g. ``str + bytes``, a :exc:`TypeError` will be "
"raised."
msgstr ""

#: ../../howto/unicode.rst:650
msgid ""
"When using data coming from a web browser or some other untrusted source, a "
"common technique is to check for illegal characters in a string before using"
" the string in a generated command line or storing it in a database.  If "
"you're doing this, be careful to check the decoded string, not the encoded "
"bytes data; some encodings may have interesting properties, such as not "
"being bijective or not being fully ASCII-compatible.  This is especially "
"true if the input data also specifies the encoding, since the attacker can "
"then choose a clever way to hide malicious text in the encoded bytestream."
msgstr ""
"web "
"ãƒ–ãƒ©ã‚¦ã‚¶ã‹ã‚‰æ¥ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚„ãã®ä»–ã®ä¿¡é ¼ã§ããªã„ã¨ã“ã‚ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆ©ç”¨ã™ã‚‹å ´åˆã€ãã‚Œã‚‰ã®æ–‡å­—åˆ—ã‹ã‚‰ç”Ÿæˆã—ãŸã‚³ãƒãƒ³ãƒ‰è¡Œã®å®Ÿè¡Œã‚„ã€ãã‚Œã‚‰ã®æ–‡å­—åˆ—ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«è“„ãˆã‚‹å‰ã«æ–‡å­—åˆ—ã®ä¸­ã«ä¸æ­£ãªæ–‡å­—ãŒå«ã¾ã‚Œã¦ã„ãªã„ã‹ç¢ºèªã™ã‚‹ã®ãŒä¸€èˆ¬çš„ã§ã™ã€‚ã‚‚ã—ãã†ã„ã†çŠ¶æ³ã«ãªã£ãŸå ´åˆã«ã¯ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã§ã¯ãªãã€ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæ–‡å­—åˆ—ã®ãƒã‚§ãƒƒã‚¯ã‚’å…¥å¿µã«è¡Œãªã£ã¦ä¸‹ã•ã„;"
" ã„ãã¤ã‹ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯å•é¡Œã¨ãªã‚‹æ€§è³ªã‚’æŒã£ã¦ã„ã¾ã™ã€ä¾‹ãˆã°å…¨å˜å°„ã§ãªã‹ã£ãŸã‚Šã€å®Œå…¨ã« ASCII "
"äº’æ›ã§ãªã„ãªã©ã€‚å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ãŒã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’æŒ‡å®šã—ã¦ã„ã‚‹å ´åˆã§ã‚‚ãã†ã—ã¦ä¸‹ã•ã„ã€ãªãœãªã‚‰æ”»æ’ƒè€…ã¯å·§ã¿ã«æ‚ªæ„ã‚ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸæ–‡å­—åˆ—ã®ä¸­ã«éš ã™ã“ã¨ãŒã§ãã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../howto/unicode.rst:661
msgid "Converting Between File Encodings"
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®å¤‰æ›"

#: ../../howto/unicode.rst:663
msgid ""
"The :class:`~codecs.StreamRecoder` class can transparently convert between "
"encodings, taking a stream that returns data in encoding #1 and behaving "
"like a stream returning data in encoding #2."
msgstr ""

#: ../../howto/unicode.rst:667
msgid ""
"For example, if you have an input file *f* that's in Latin-1, you can wrap "
"it with a :class:`~codecs.StreamRecoder` to return bytes encoded in UTF-8::"
msgstr ""

#: ../../howto/unicode.rst:681
msgid "Files in an Unknown Encoding"
msgstr "ä¸æ˜ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ãƒ•ã‚¡ã‚¤ãƒ«"

#: ../../howto/unicode.rst:683
msgid ""
"What can you do if you need to make a change to a file, but don't know the "
"file's encoding?  If you know the encoding is ASCII-compatible and only want"
" to examine or modify the ASCII parts, you can open the file with the "
"``surrogateescape`` error handler::"
msgstr ""

#: ../../howto/unicode.rst:697
msgid ""
"The ``surrogateescape`` error handler will decode any non-ASCII bytes as "
"code points in the Unicode Private Use Area ranging from U+DC80 to U+DCFF.  "
"These private code points will then be turned back into the same bytes when "
"the ``surrogateescape`` error handler is used when encoding the data and "
"writing it back out."
msgstr ""

#: ../../howto/unicode.rst:707
msgid ""
"One section of `Mastering Python 3 Input/Output "
"<http://pyvideo.org/video/289/pycon-2010--mastering-python-3-i-o>`_, a PyCon"
" 2010 talk by David Beazley, discusses text processing and binary data "
"handling."
msgstr ""

#: ../../howto/unicode.rst:711
msgid ""
"The `PDF slides for Marc-AndrÃ© Lemburg's presentation \"Writing Unicode-"
"aware Applications in Python\" <https://downloads.egenix.com/python/LSM2005"
"-Developing-Unicode-aware-applications-in-Python.pdf>`_ discuss questions of"
" character encodings as well as how to internationalize and localize an "
"application.  These slides cover Python 2.x only."
msgstr ""
"Marc-AndrÃ© Lemburg ã®ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ \"Writing Unicode-aware Applications in "
"Python\" ã® PDF ã‚¹ãƒ©ã‚¤ãƒ‰ãŒ <https://downloads.egenix.com/python/LSM2005"
"-Developing-Unicode-aware-applications-in-Python.pdf> "
"ã‹ã‚‰å…¥æ‰‹å¯èƒ½ã§ã™ã€ãã—ã¦æ–‡å­—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®å•é¡Œã¨åŒæ§˜ã«ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å›½éš›åŒ–ã‚„ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºã«ã¤ã„ã¦ã‚‚è­°è«–ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ã‚¹ãƒ©ã‚¤ãƒ‰ã¯ Python"
" 2.x ã®ã¿ã‚’ã‚«ãƒãƒ¼ã—ã¦ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:717
msgid ""
"`The Guts of Unicode in Python <http://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ is a PyCon 2013 talk by Benjamin Peterson that "
"discusses the internal Unicode representation in Python 3.3."
msgstr ""

#: ../../howto/unicode.rst:724
msgid "Acknowledgements"
msgstr "è¬è¾"

#: ../../howto/unicode.rst:726
msgid ""
"The initial draft of this document was written by Andrew Kuchling. It has "
"since been revised further by Alexander Belopolsky, Georg Brandl, Andrew "
"Kuchling, and Ezio Melotti."
msgstr ""
"ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æœ€åˆã®è‰ç¨¿ã¯ Andrew Kuchling ã«ã‚ˆã£ã¦æ›¸ã‹ã‚Œã¾ã—ãŸã€‚ãã‚Œã‹ã‚‰ã•ã‚‰ã« Alexander Belopolsky, "
"Georg Brandl, Andrew Kuchling, Ezio Melotti ã‚‰ã§æ”¹è¨‚ãŒé‡ã­ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../howto/unicode.rst:730
msgid ""
"Thanks to the following people who have noted errors or offered suggestions "
"on this article: Ã‰ric Araujo, Nicholas Bastin, Nick Coghlan, Marius "
"Gedminas, Kent Johnson, Ken Krugler, Marc-AndrÃ© Lemburg, Martin von LÃ¶wis, "
"Terry J. Reedy, Chad Whitacre."
msgstr ""
"ã“ã®è¨˜äº‹ä¸­ã®èª¤ã‚Šã®æŒ‡æ‘˜ã‚„ææ¡ˆã‚’ç”³ã—å‡ºã¦ãã‚ŒãŸä»¥ä¸‹ã®äººã€…ã«æ„Ÿè¬ã—ã¾ã™: Ã‰ric Araujo, Nicholas Bastin, Nick "
"Coghlan, Marius Gedminas, Kent Johnson, Ken Krugler, Marc-AndrÃ© Lemburg, "
"Martin von LÃ¶wis, Terry J. Reedy, Chad Whitacre."
