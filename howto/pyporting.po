# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2017
# ryosuke.mondo <ryosuke.mondo@gmail.com>, 2017
# Ikuru K <kanumaiku@gmail.com>, 2017
# Arihiro TAKASE, 2017
# Osamu NAKAMURA, 2017
# tomoğŸ§, 2017
# SHIMIZU Taku <shimizu.taku@gmail.com>, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-30 05:56+0900\n"
"PO-Revision-Date: 2017-02-16 17:45+0000\n"
"Last-Translator: ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/pyporting.rst:5
msgid "Porting Python 2 Code to Python 3"
msgstr "Python 2 ã‹ã‚‰ Python 3 ã¸ã®ç§»æ¤"

#: ../../howto/pyporting.rst:0
msgid "author"
msgstr "author"

#: ../../howto/pyporting.rst:7
msgid "Brett Cannon"
msgstr "Brett Cannon"

#: ../../howto/pyporting.rstNone
msgid "Abstract"
msgstr "æ¦‚è¦"

#: ../../howto/pyporting.rst:11
msgid ""
"With Python 3 being the future of Python while Python 2 is still in active "
"use, it is good to have your project available for both major releases of "
"Python. This guide is meant to help you figure out how best to support both "
"Python 2 & 3 simultaneously."
msgstr ""
"ç¾åœ¨ã¯ Python 3 ãŒæœ€æ–°ç‰ˆã® Python ã§ã™ãŒã€ Python 2 "
"ã‚‚ã¾ã æ´»ç™ºã«åˆ©ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚ãªã®ã§ã‚ãªãŸã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¸¡æ–¹ã®ãƒ¡ã‚¸ãƒ£ãƒ¼ãƒªãƒªãƒ¼ã‚¹ã«ãŠã„ã¦å‹•ä½œå¯èƒ½ã«ã—ã¦ãŠãã®ãŒã‚ˆã„ã§ã—ã‚‡ã†ã€‚ã“ã®ã‚¬ã‚¤ãƒ‰ã§ã¯ã€ "
"Python 2 ã¨ 3 ã‚’åŒæ™‚ã«ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã«ã¯ã©ã†ã™ã‚Œã°ã‚ˆã„ã‹ã‚’è§£èª¬ã—ã¾ã™ã€‚"

#: ../../howto/pyporting.rst:16
msgid ""
"If you are looking to port an extension module instead of pure Python code, "
"please see :ref:`cporting-howto`."
msgstr ""
"ã‚‚ã—ã‚ãªãŸãŒæ¨™æº– Python ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã¯ãªãæ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã®ç§»æ¤æ‰‹æ®µã‚’æ¢ã—ã¦ã„ã‚‹ãªã‚‰ã° :ref:`cporting-howto` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../howto/pyporting.rst:19
msgid ""
"If you would like to read one core Python developer's take on why Python 3 "
"came into existence, you can read Nick Coghlan's `Python 3 Q & A`_ or Brett "
"Cannon's `Why Python 3 exists`_."
msgstr ""
"ã‚³ã‚¢é–‹ç™ºè€…ã®è¦–ç‚¹ã‹ã‚‰ Python3 ãŒä¸–ã«å‡ºã¦ããŸãŒç†ç”±ã‚’èª­ã¿ãŸã„å ´åˆã¯ã€ Nick Coghlan ã® `Python 3 Q & A`_ ã¾ãŸã¯ "
"`Brett Cannonã«ã‚ˆã‚‹ `Why Python 3 exists`_ ãŒãŠã™ã™ã‚ã§ã™ã€‚"

#: ../../howto/pyporting.rst:23
msgid ""
"For help with porting, you can email the python-porting_ mailing list with "
"questions."
msgstr "ç§»æ¤ã«ã‚ãŸã£ã¦åŠ©ã‘ãŒå¿…è¦ãªå ´åˆã¯ python-porting_ ãƒ¡ãƒ¼ãƒªãƒ³ã‚°ãƒªã‚¹ãƒˆã«è³ªå•ã‚’æŠ•ç¨¿ã§ãã¾ã™ã€‚"

#: ../../howto/pyporting.rst:27
msgid "The Short Explanation"
msgstr "çŸ­ã„èª¬æ˜"

#: ../../howto/pyporting.rst:29
msgid ""
"To make your project be single-source Python 2/3 compatible, the basic steps"
" are:"
msgstr "ã‚ãªãŸã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€å˜ä¸€ã‚½ãƒ¼ã‚¹ã§ Python 2/3 ä¸¡æ–¹ã«å¯¾å¿œã•ã›ã‚‹åŸºæœ¬çš„ãªã‚¹ãƒ†ãƒƒãƒ—ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚"

#: ../../howto/pyporting.rst:32
msgid "Only worry about supporting Python 2.7"
msgstr "Python 2.7 ã ã‘ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã«æ°—ã‚’é…ã£ã¦ãã ã•ã„ã€‚"

#: ../../howto/pyporting.rst:33
msgid ""
"Make sure you have good test coverage (coverage.py_ can help; ``pip install "
"coverage``)"
msgstr "è‰¯ã„ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã‚’ç¢ºä¿ã—ã¦ãã ã•ã„ã€‚ (coverage.py_ ãŒæ¨å¥¨ã•ã‚Œã¾ã™; ``pip install coverage``)"

#: ../../howto/pyporting.rst:35 ../../howto/pyporting.rst:116
msgid "Learn the differences between Python 2 & 3"
msgstr "Python 2 ã¨ 3 ã®é•ã„ã‚’å­¦ã³ã¾ã—ã‚‡ã†ã€‚"

#: ../../howto/pyporting.rst:36
msgid ""
"Use Futurize_ (or Modernize_) to update your code (e.g. ``pip install "
"future``)"
msgstr ""
"Futurize_ (ã‚‚ã—ãã¯ Modernize_) ã‚’ä½¿ã£ã¦ã‚³ãƒ¼ãƒ‰ã‚’ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚ (ãŸã¨ãˆã° ``pip install "
"future``)"

#: ../../howto/pyporting.rst:37
msgid ""
"Use Pylint_ to help make sure you don't regress on your Python 3 support "
"(``pip install pylint``)"
msgstr "Python 3 ã‚µãƒãƒ¼ãƒˆã«é–¢ã—ã¦ãƒ‡ã‚°ãƒ¬ã‚’é˜²ããŸã‚ã« Pylint_ ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚(``pip install pylint``)"

#: ../../howto/pyporting.rst:39
msgid ""
"Use caniusepython3_ to find out which of your dependencies are blocking your"
" use of Python 3 (``pip install caniusepython3``)"
msgstr ""
"caniusepython3_ ã‚’ä½¿ã£ã¦ã©ã®ä¾å­˜æ€§ãŒã‚ãªãŸã® Python 3 ã®ä½¿ç”¨ã‚’å¦¨ã’ã¦ã„ã‚‹ã‹ã‚’æ¤œå‡ºã§ãã¾ã™ã€‚ (``pip install "
"caniusepython3``)"

#: ../../howto/pyporting.rst:41
msgid ""
"Once your dependencies are no longer blocking you, use continuous "
"integration to make sure you stay compatible with Python 2 & 3 (tox_ can "
"help test against multiple versions of Python; ``pip install tox``)"
msgstr ""
"ä¾å­˜æ€§ãŒã‚ãªãŸã‚’é‚ªé­”ã—ãªããªã£ã¦ã•ãˆã—ã¾ãˆã°ã€Python 2 & 3 ã¸ã®äº’æ›æ€§ã‚’ä¿ã¤ã®ã‚’ä¿éšœã™ã‚‹ãŸã‚ã«ã€ç¶™ç¶šçš„ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ã„ã¾ã—ã‚‡ã† "
"(tox_ ãŒè¤‡æ•°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ Python ç›¸æ‰‹ã®ãƒ†ã‚¹ãƒˆã®æ‰‹åŠ©ã‘ã‚’ã—ã¦ãã‚Œã¾ã™; ``pip install tox``)"

#: ../../howto/pyporting.rst:44
msgid ""
"Consider using optional static type checking to make sure your type usage "
"works in both Python 2 & 3 (e.g. use mypy_ to check your typing under both "
"Python 2 & Python 3)."
msgstr ""
" Python 2 ã¨ 3 ã®ä¸¡æ–¹ã§å‹ã®åˆ©ç”¨ãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã€ä»»æ„ã®é™çš„å‹æ¤œæŸ»ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚\n"
" (ãŸã¨ãˆã°ã€python 2 ã¨ 3ã®ä¸¡æ–¹ã§å‹ã‚’æ¤œæŸ»ã™ã‚‹ã®ã« mypy_ ã‚’åˆ©ç”¨ã—ã¾ã™)"

#: ../../howto/pyporting.rst:50
msgid "Details"
msgstr "è©³ç´°"

#: ../../howto/pyporting.rst:52
msgid ""
"A key point about supporting Python 2 & 3 simultaneously is that you can "
"start **today**! Even if your dependencies are not supporting Python 3 yet "
"that does not mean you can't modernize your code **now** to support Python "
"3. Most changes required to support Python 3 lead to cleaner code using "
"newer practices even in Python 2 code."
msgstr ""
"Python 2 ã¨ 3 ã®åŒæ™‚ã‚µãƒãƒ¼ãƒˆã«ã¤ã„ã¦ã®ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆã®ã²ã¨ã¤ã¯ã€ **ä»Šæ—¥ã‹ã‚‰** "
"é–‹å§‹å‡ºæ¥ã‚‹ã€ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚ãŸã¨ãˆã‚ãªãŸãŒæŒã£ã¦ã„ã‚‹ä¾å­˜ç‰©ãŒã¾ã  Python 3 ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªãã¨ã‚‚ã€ãã‚Œã¯ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã‚’ Python 3 "
"ã‚µãƒãƒ¼ãƒˆã®ãŸã‚ã« **ä»Šã™ã** ç¾ä»£åŒ–å‡ºæ¥ãªã„ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚Python 3 ã‚µãƒãƒ¼ãƒˆã®ãŸã‚ã«å¿…è¦ãªã»ã¨ã‚“ã©ã®å¤‰æ›´ã¯ã€Python "
"2 ã‚³ãƒ¼ãƒ‰å†…ã«ã‚ã£ã¦ã‚‚æ–°ã—ã„ãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’ä¼´ã†æ˜å¿«ãªã‚³ãƒ¼ãƒ‰ã«å°ã„ã¦ãã‚Œã¾ã™ã€‚"

#: ../../howto/pyporting.rst:58
msgid ""
"Another key point is that modernizing your Python 2 code to also support "
"Python 3 is largely automated for you. While you might have to make some API"
" decisions thanks to Python 3 clarifying text data versus binary data, the "
"lower-level work is now mostly done for you and thus can at least benefit "
"from the automated changes immediately."
msgstr ""
"ã‚‚ã†ã²ã¨ã¤ã®ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆã¯ã€ã‚ãªãŸã® Python 2 ã‚³ãƒ¼ãƒ‰ã® Python 3 "
"ã‚µãƒãƒ¼ãƒˆã‚’åŠ ãˆã‚‹ç¾ä»£åŒ–ã¯ã€ã‚ãªãŸã®ãŸã‚ã«å¤§éƒ¨åˆ†ã¯è‡ªå‹•åŒ–ã•ã‚Œã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚Python 3 "
"ã«ã‚ˆã‚‹ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã¨ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã®æ˜ç¢ºãªåŒºåˆ¥ã®ãŠã‹ã’ã§ã€ã‚ãªãŸã¯ã„ãã¤ã‹ã® API "
"ã«æ±ºæ–­ã‚’ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã‹ã‚‚ã—ã‚Œãªã„ä¸€æ–¹ã§ã€ä¸‹ä½ãƒ¬ãƒ™ãƒ«ã®ä»•äº‹ã¯ä»Šã‚„ã»ã¨ã‚“ã©æ¸ˆã‚“ã§ã„ã¦ã€ãã‚Œã‚†ãˆã«æœ€ä½ã§ã‚‚ãã®è‡ªå‹•åŒ–ã•ã‚ŒãŸä¿®æ­£ã‹ã‚‰ã®æ©æµã‚’ã™ãã•ã¾å—ã‘ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚"

#: ../../howto/pyporting.rst:64
msgid ""
"Keep those key points in mind while you read on about the details of porting"
" your code to support Python 2 & 3 simultaneously."
msgstr ""
"Python 2 ã¨ 3 ã®åŒæ™‚ã‚µãƒãƒ¼ãƒˆã®ãŸã‚ã«ã€ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã‚’ç§»æ¤ã™ã‚‹ãŸã‚ã®ä»¥é™ã®è©³ç´°ã‚’èª­ã‚€éš›ã«ã¯ã€ã“ã‚Œã‚‰ã®ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆã‚’å¿ƒã«ç•™ã‚ã¦ãŠã„ã¦ãã ã•ã„ã€‚"

#: ../../howto/pyporting.rst:69
msgid "Drop support for Python 2.6 and older"
msgstr "Python 2.6 ã¨ãã‚Œä»¥å‰ã®ã‚µãƒãƒ¼ãƒˆã‚’è½ã¨ã™"

#: ../../howto/pyporting.rst:71
msgid ""
"While you can make Python 2.5 work with Python 3, it is **much** easier if "
"you only have to work with Python 2.7. If dropping Python 2.5 is not an "
"option then the six_ project can help you support Python 2.5 & 3 "
"simultaneously (``pip install six``). Do realize, though, that nearly all "
"the projects listed in this HOWTO will not be available to you."
msgstr ""
"Python 2.5 ã¨ Python 3 ã§å‹•ãã‚‚ã®ã¯ä½œã‚Œã¾ã™ãŒã€Python 2.7 ä»¥ä¸Šã§ã®ã¿å‹•ãã‚ˆã†ã«ã™ã‚‹ã»ã†ãŒ **ã¨ã¦ã¤ã‚‚ãªã** "
"ç°¡å˜ã§ã™ã€‚Python 2.5 ã‚µãƒãƒ¼ãƒˆã‚’è½ã¨ã›ãªã„ãªã‚‰ã°ã€ six_ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ãªãŸã® Python 2.5 ã¨ 3 "
"åŒæ™‚ã‚µãƒãƒ¼ãƒˆã‚’æ‰‹åŠ©ã‘ã—ã¦ãã‚Œã¾ã™ (``pip install six``)ã€‚ã ã‘ã‚Œã©ã‚‚æ‚Ÿã£ã¦ãã ã•ã„ã€ã“ã® HOWTO "
"ã§ãƒªã‚¹ãƒˆã—ã¦ã„ã‚‹ã»ã¨ã‚“ã©å…¨ã¦ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ã„ãšã‚Œã‚ãªãŸã«ã¨ã£ã¦å…¥æ‰‹ä¸å¯èƒ½ã«ãªã‚‹ã§ã‚ã‚ã†ã“ã¨ã‚’ã€‚"

#: ../../howto/pyporting.rst:77
msgid ""
"If you are able to skip Python 2.5 and older, then the required changes to "
"your code should continue to look and feel like idiomatic Python code. At "
"worst you will have to use a function instead of a method in some instances "
"or have to import a function instead of using a built-in one, but otherwise "
"the overall transformation should not feel foreign to you."
msgstr ""
"Python 2.5 ä»¥ä¸‹ã®ã‚µãƒãƒ¼ãƒˆã‚’ã‚¹ã‚­ãƒƒãƒ—å‡ºæ¥ã‚‹ãªã‚‰ã°ã€ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã«å¿…è¦ãªå¤‰æ›´ã¯ Python "
"ã®å¸¸å¥—å¥ã®ã‚ˆã†ãªå¤–è¦³ã¨é›°å›²æ°—ã‚’å£Šã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æœ€æ‚ªã®å ´åˆã‚ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å†…ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ä»£ã‚ã‚Šã«é–¢æ•°ã‚’ä½¿ã†å¿…è¦ãŒã‚ã£ãŸã‚Šã€ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã‚’ä½¿ã†ä»£ã‚ã‚Šã«é–¢æ•°ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã§ã—ã‚‡ã†ãŒã€ãã†ã—ãªã„ãªã‚‰ã°ã€å…¨ä½“é€šã—ãŸå¤‰æ›ã¯ã‚ãªãŸã«ã¨ã£ã¦ç•°è³ªã«æ„Ÿã˜ã•ã›ãªã„ã‚‚ã®ã«é•ã„ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../howto/pyporting.rst:83
msgid ""
"But you should aim for only supporting Python 2.7. Python 2.6 is no longer "
"freely supported and thus is not receiving bugfixes. This means **you** will"
" have to work around any issues you come across with Python 2.6. There are "
"also some tools mentioned in this HOWTO which do not support Python 2.6 "
"(e.g., Pylint_), and this will become more commonplace as time goes on. It "
"will simply be easier for you if you only support the versions of Python "
"that you have to support."
msgstr ""
"ã§ã™ãŒã€Python 2.6 ä»¥ä¸Šã¨è¨€ã‚ãš Python 2.7 ã‚’ç›®æ¨™ã«ã—ã¦ãã ã•ã„ã€‚Python 2.6 "
"ã¯ã‚‚ã†ç©æ¥µçš„ã«ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã“ã‚Œã¯ **ã‚ãªãŸãŒ** Python 2.6 "
"ã«é–¢ä¿‚ã™ã‚‹ã‚ã‚‰ã‚†ã‚‹å•é¡Œã«å–ã‚Šçµ„ã¾ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ã“ã® HOWTO ã§è¨€åŠã—ã¦ã„ã‚‹ã„ãã¤ã‹ã®ãƒ„ãƒ¼ãƒ«ã‚‚ Python 2.6 "
"ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ (Pylint_ ãªã©)ã—ã€æ™‚ã«ã¤ã‚Œã“ã®ã‚ˆã†ãªã“ã¨ã¯ã‚‚ã£ã¨å½“ãŸã‚Šå‰ã«ãªã£ã¦ãã‚‹ã§ã—ã‚‡ã†ã€‚2.7 "
"ä»¥ä¸Šã ã‘ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã¨ã„ã†ã“ã¨ã¯ã€è©±ã‚’ã‚ˆã‚Šç°¡å˜ã«ã—ã¦ãã‚Œã¾ã™ã€‚"

#: ../../howto/pyporting.rst:92
msgid ""
"Make sure you specify the proper version support in your ``setup.py`` file"
msgstr "ã‚ãªãŸã® ``setup.py`` ãƒ•ã‚¡ã‚¤ãƒ«ã«ã€ç›¸å¿œã—ã„ã‚µãƒãƒ¼ãƒˆãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æ˜è¨˜ã™ã‚‹ã“ã¨ã‚’å¿˜ã‚Œãªã„ã“ã¨"

#: ../../howto/pyporting.rst:94
msgid ""
"In your ``setup.py`` file you should have the proper `trove classifier`_ "
"specifying what versions of Python you support. As your project does not "
"support Python 3 yet you should at least have ``Programming Language :: "
"Python :: 2 :: Only`` specified. Ideally you should also specify each "
"major/minor version of Python that you do support, e.g. ``Programming "
"Language :: Python :: 2.7``."
msgstr ""
"``setup.py`` ãƒ•ã‚¡ã‚¤ãƒ«ã«ã€ã‚ãªãŸãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹ Python ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ `trove classifier`_ "
"ã§æ­£ã—ãæ˜è¨˜ã™ã¹ãã§ã™ã€‚ã‚ãªãŸã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ã¾ã  Python 3 ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã®ã§ã€å°‘ãªãã¨ã‚‚ ``Programming Language"
" :: Python :: 2 :: Only`` ã¨æ˜è¨˜ã™ã¹ãã§ã™ã€‚ç†æƒ³çš„ã«ã¯ Python ã®ãƒ¡ã‚¸ãƒ£ãƒ¼/ãƒã‚¤ãƒŠãƒ¼ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚‚æŒ‡å®šã™ã¹ãã§ã™ã€‚ä¾‹ãˆã° "
"``Programming Language :: Python :: 2.7`` ã®ã‚ˆã†ã«ã€‚"

#: ../../howto/pyporting.rst:103
msgid "Have good test coverage"
msgstr "è‰¯ã„ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã‚’ç¢ºä¿ã™ã‚‹ã€‚"

#: ../../howto/pyporting.rst:105
msgid ""
"Once you have your code supporting the oldest version of Python 2 you want "
"it to, you will want to make sure your test suite has good coverage. A good "
"rule of thumb is that if you want to be confident enough in your test suite "
"that any failures that appear after having tools rewrite your code are "
"actual bugs in the tools and not in your code. If you want a number to aim "
"for, try to get over 80% coverage (and don't feel bad if you find it hard to"
" get better than 90% coverage). If you don't already have a tool to measure "
"test coverage then coverage.py_ is recommended."
msgstr ""
"ãã†ã—ãŸã„ä¸€ç•ªå¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python 2 "
"ã‚’ã‚µãƒãƒ¼ãƒˆå‡ºæ¥ã¦ã„ã‚‹ãªã‚‰ã°ã€ã‚ãªãŸã®ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆãŒååˆ†ãªç¶²ç¾…æ€§ã‹ã‚’ç¢ºèªã—ãŸã„ã§ã—ã‚‡ã†ã€‚ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã‚’ãƒ„ãƒ¼ãƒ«ã§æ›¸ãæ›ãˆãŸå¾Œã«ç¾ã‚Œã‚‹ã‚ã‚‰ã‚†ã‚‹å¤±æ•—ãŒå®Ÿéš›ã«ã¯ãƒ„ãƒ¼ãƒ«ã®ãƒã‚°ã§ã€ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã®ãƒã‚°ã§ã¯ãªã„ã¨ã™ã‚‹ã®ã«ååˆ†ãªã ã‘ã®ç¢ºä¿¡ã‚’ã‚ãªãŸã®ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã«æŒã¡ãŸã„ãªã‚‰ã°ã€è‰¯ã„çµŒé¨“å‰‡ãŒã“ã‚Œã§ã™ã€‚ç›®æ¨™ã¨ã™ã‚‹æ•°å€¤ã§è¨€ãˆã°ã€80%"
" ä»¥ä¸Šã®ç¶²ç¾…æ€§ã‚’ç›®æŒ‡ã—ã¦ã¿ã¦ãã ã•ã„ (ãã—ã¦ã‚«ãƒãƒ¬ãƒƒã‚¸ 90% "
"ã‚’è¶Šãˆã‚‹ã®ãŒé›£ã—ã‹ã£ãŸã¨ã—ã¦ã‚‚æ°—ã«ç—…ã‚€å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“)ã€‚ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã®è¨ˆæ¸¬ãƒ„ãƒ¼ãƒ«ã‚’æ‰‹æŒã¡ã§ãªã„ãªã‚‰ã°ã€ coverage.py_ ãŒãŠå¥¨ã‚ã§ã™ã€‚"

#: ../../howto/pyporting.rst:118
msgid ""
"Once you have your code well-tested you are ready to begin porting your code"
" to Python 3! But to fully understand how your code is going to change and "
"what you want to look out for while you code, you will want to learn what "
"changes Python 3 makes in terms of Python 2. Typically the two best ways of "
"doing that is reading the `\"What's New\"`_ doc for each release of Python 3"
" and the `Porting to Python 3`_ book (which is free online). There is also a"
" handy `cheat sheet`_ from the Python-Future project."
msgstr ""
"ååˆ†ã«ãƒ†ã‚¹ãƒˆå‡ºæ¥ãŸãªã‚‰ã°ã€ã„ã‚ˆã„ã‚ˆ Python 3 ã¸ã®ç§»æ¤ã‚’ã™ã‚‹æº–å‚™ãŒæ•´ã„ã¾ã—ãŸ! "
"ã§ã™ãŒã€ã©ã®ã‚ˆã†ã«ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã—ã¦ã„ã‘ã°è‰¯ã„ã®ã‹ã€ä½•ã«æ°—ã‚’ã¤ã‘ã¦ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã™ã‚Œã°è‰¯ã„ã®ã‹ã‚’å®Œå…¨ã«ç†è§£ã™ã‚‹ãŸã‚ã«ã€Python 2 ã‹ã‚‰ã®è¦–ç‚¹ã§"
" Python 3 ã®å¤‰æ›´ç‚¹ã¯ãªã‚“ãªã®ã‹ã‚’å­¦ã³ãŸã„ã§ã—ã‚‡ã†ã€‚å…¸å‹çš„ã«ã¯ã€ãã‚Œã‚’ã™ã‚‹ãŸã‚ã®æ‰‹æ®µã¨ã—ã¦æœ€è‰¯ã®ã‚‚ã®ãŒ 2 ã¤ã‚ã£ã¦ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ã€ "
"Python 3 ã®ãã‚Œãã‚Œã®ãƒªãƒªãƒ¼ã‚¹ã® `\"What's New\"`_ ã‚’èª­ã‚€ã“ã¨ã¨ã€ `Porting to Python 3`_ "
"(ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ç‰ˆãŒãƒ•ãƒªãƒ¼ã§èª­ã‚ã¾ã™) ã‚’èª­ã‚€ã“ã¨ã§ã™ã€‚ Python-Future ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã®ã€æ‰‹è»½ãª `cheat sheet`_ ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../howto/pyporting.rst:128
msgid "Update your code"
msgstr "ã‚³ãƒ¼ãƒ‰ã‚’ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã™ã‚‹ã€‚"

#: ../../howto/pyporting.rst:130
msgid ""
"Once you feel like you know what is different in Python 3 compared to Python"
" 2, it's time to update your code! You have a choice between two tools in "
"porting your code automatically: Futurize_ and Modernize_. Which tool you "
"choose will depend on how much like Python 3 you want your code to be. "
"Futurize_ does its best to make Python 3 idioms and practices exist in "
"Python 2, e.g. backporting the ``bytes`` type from Python 3 so that you have"
" semantic parity between the major versions of Python. Modernize_, on the "
"other hand, is more conservative and targets a Python 2/3 subset of Python, "
"directly relying on six_ to help provide compatibility. As Python 3 is the "
"future, it might be best to consider Futurize to begin adjusting to any new "
"practices that Python 3 introduces which you are not accustomed to yet."
msgstr ""
"Python 2 ã¨æ¯”è¼ƒã—ãŸ Python 3 ã®é•ã„ãŒã‚ã‹ã£ã¦ããŸã‚‰ã€ã„ã‚ˆã„ã‚ˆã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ã™ã‚‹ãã®ã¨ãã§ã™!\n"
"ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã®ç§»æ¤ã®è‡ªå‹•åŒ–ãƒ„ãƒ¼ãƒ«ã¨ã—ã¦ã¯ 2 ã¤ã®é¸æŠè‚¢ãŒã‚ã‚Šã¾ã™: Futurize_ ã¨ Modernize_ ã§ã™ã€‚\n"
"ã©ã¡ã‚‰ã®ãƒ„ãƒ¼ãƒ«ãŒè‰¯ã„ã‹ã¯ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã‚’ã©ã®ãã‚‰ã„ Python 3 å¯„ã‚Šã«è¿‘ä»˜ã‘ãŸã„ã‹ã«ã‚ˆã‚Šã¾ã™ã€‚\n"
"Futurize_ ã¯ã€ä¾‹ãˆã° Python ã®ãƒ¡ã‚¸ãƒ£ãƒ¼ãƒãƒ¼ã‚¸ãƒ§ãƒ³é–“ã®æ„å‘³è«–çš„ãªç­‰ä¾¡æ€§ã‚’æŒã¤ã‚ˆã†ã« Python 3 ã‹ã‚‰ãƒãƒƒã‚¯ãƒãƒ¼ãƒˆã•ã‚ŒãŸ ``bytes`` å‹ã®ã‚ˆã†ã«ã€Python 2 ã«å–ã‚Šè¾¼ã¾ã‚ŒãŸ Python 3 ã®ã‚¤ãƒ‡ã‚£ã‚ªãƒ ã¨æ…£ä¾‹ã‚’ç©æ¥µçš„ã«ä½¿ã„ã¾ã™ã€‚\n"
"ä»–æ–¹ Modernize_ ã¯ã‚ˆã‚Šä¿å®ˆçš„ã§ã€äº’æ›æ€§ä¿æŒã‚’ six_ ã«ã‚ˆã£ã¦æä¾›ã™ã‚‹ã“ã¨ã§ã€ Python 2/3 ã®ã‚µãƒ–ã‚»ãƒƒãƒˆã§ã‚ã‚‹ã“ã¨ã‚’ç›®æ¨™ã«ã—ã¾ã™ã€‚\n"
"Python 3 ã¯ç¢ºå®Ÿã«ã‚„ã£ã¦ãã‚‹æœªæ¥ãªã®ã§ã€ Python 3 ã§å°å…¥ã•ã‚ŒãŸã€ã¾ã æ…£ã‚Œã¦ã„ãªã„æ–°ã—ã„æ…£ä¾‹ã«åˆã‚ã›å§‹ã‚ã‚‹ãŸã‚ã«ã¯ Futurize ã‚’æ¤œè¨ã™ã‚‹ã®ãŒæœ€è‰¯ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../howto/pyporting.rst:142
msgid ""
"Regardless of which tool you choose, they will update your code to run under"
" Python 3 while staying compatible with the version of Python 2 you started "
"with. Depending on how conservative you want to be, you may want to run the "
"tool over your test suite first and visually inspect the diff to make sure "
"the transformation is accurate. After you have transformed your test suite "
"and verified that all the tests still pass as expected, then you can "
"transform your application code knowing that any tests which fail is a "
"translation failure."
msgstr ""
"ã©ã¡ã‚‰ã®ãƒ„ãƒ¼ãƒ«ã‚’é¸ã¶ã«ã›ã‚ˆã€ãã‚Œã‚‰ã¯ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã‚’ã€ã‚ãªãŸãŒé–‹å§‹ã—ãŸ Python 2 ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¸ã®äº’æ›æ€§ã‚’ä¿ã£ãŸã¾ã¾ã§ Python 3 "
"ã§å‹•ä½œã™ã‚‹ã‚ˆã†ã«æ›¸ãæ›ãˆã¾ã™ã€‚å¿µã«ã¯å¿µã‚’å…¥ã‚ŒãŸã‘ã‚Œã°ã€ã¾ãšã¯ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã«å¯¾ã—ã¦ãƒ„ãƒ¼ãƒ«ã‚’é©ç”¨ã—ã¦ã€å¤‰æ›ãŒæ­£ã—ã„ã‚‚ã®ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«å·®åˆ†ã‚’è¦–è¦šçš„ã«ç‚¹æ¤œã—ã¾ã—ã‚‡ã†ã€‚ã‚ãªãŸã®ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã‚’å¤‰æ›ã—ã¦ã€ãƒ†ã‚¹ãƒˆãŒãã‚Œã§ã‚‚ã¾ã æœŸå¾…é€šã‚Šã«ãƒ‘ã‚¹ã™ã‚‹ã“ã¨ãŒæ¤œè¨¼å‡ºæ¥ã¦ã—ã¾ãˆã°ã€ã‚ãªãŸã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’ã€å…¨ã¦ã®å¤±æ•—ã™ã‚‹ãƒ†ã‚¹ãƒˆã¯å¤‰æ›ã®å¤±æ•—ã‚’æ„å‘³ã™ã‚‹ã“ã¨ãŒã‚ã‹ã‚‹çŠ¶æ…‹ã§å¤‰æ›å‡ºæ¥ã¾ã™ã€‚"

#: ../../howto/pyporting.rst:150
msgid ""
"Unfortunately the tools can't automate everything to make your code work "
"under Python 3 and so there are a handful of things you will need to update "
"manually to get full Python 3 support (which of these steps are necessary "
"vary between the tools). Read the documentation for the tool you choose to "
"use to see what it fixes by default and what it can do optionally to know "
"what will (not) be fixed for you and what you may have to fix on your own "
"(e.g. using ``io.open()`` over the built-in ``open()`` function is off by "
"default in Modernize). Luckily, though, there are only a couple of things to"
" watch out for which can be considered large issues that may be hard to "
"debug if not watched for."
msgstr ""
"æ‚ªã„å ±ã›ã€‚ã“ã‚Œã‚‰ãƒ„ãƒ¼ãƒ«ã¯ Python 3 ã§ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã‚’å‹•ä½œã•ã›ã‚‹ãŸã‚ã«ã€å…¨ã¦ã®è‡ªå‹•åŒ–ãŒå‡ºæ¥ã¦ã„ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã®ã§ã€Python 3 "
"ã®ãƒ•ãƒ«ã‚µãƒãƒ¼ãƒˆã®ãŸã‚ã«ã¯æ‰‹å‹•ã§æ›´æ–°ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã‚ãšã‹ã°ã‹ã‚Šã®äº‹é …ãŒã‚ã‚Šã¾ã™(å¿…è¦ãªæ‰‹ä½œæ¥­ã¯ãƒ„ãƒ¼ãƒ«ã«ã‚ˆã£ã¦é•ã„ã¾ã™)ã€‚é¸ã‚“ã ãƒ„ãƒ¼ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’èª­ã‚“ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ä½•ãŒä¿®æ­£ã•ã‚Œã¦ã€é¸æŠçš„ã«ä½•ã‚’ä¿®æ­£ã™ã‚‹(ã—ãªã„)ã‚’é¸ã¹ã‚‹ã®ã‹ã€ãã—ã¦ä½•ã‚’è‡ªèº«ã§ä¿®æ­£ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã‹ã‚’ç†è§£ã—ã¦ãã ã•ã„"
" (ä¾‹ãˆã°ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã® ``open()`` ã§ã¯ãªã ``io.open()`` ã‚’ä½¿ã†ä¿®æ­£ã¯ã€Modernize "
"ã§ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚ªãƒ•ã§ã™)ã€‚è‰¯ã„å ±ã›ã€‚ã§ã™ãŒã€æ³¨æ„æ·±ãã¿ãªã‘ã‚Œã°ãƒ‡ãƒãƒƒã‚°ã‚’å›°é›£ã«ã™ã‚‹ã‚ˆã†ãªå¤§ããªå•é¡Œã¨ã—ã¦è€ƒãˆã‚‰ã‚Œã‚‹ã€è­¦æˆ’ã™ã‚‹ã‚ˆã†ãªã“ã¨ã¯ã€2 "
"ã¤ã ã‘ã§ã™ã€‚"

#: ../../howto/pyporting.rst:162
msgid "Division"
msgstr "é™¤ç®—"

#: ../../howto/pyporting.rst:164
msgid ""
"In Python 3, ``5 / 2 == 2.5`` and not ``2``; all division between ``int`` "
"values result in a ``float``. This change has actually been planned since "
"Python 2.2 which was released in 2002. Since then users have been encouraged"
" to add ``from __future__ import division`` to any and all files which use "
"the ``/`` and ``//`` operators or to be running the interpreter with the "
"``-Q`` flag. If you have not been doing this then you will need to go "
"through your code and do two things:"
msgstr ""
"Python 3 ã§ã¯ã€ ``5 / 2 == 2.5`` ã§ã‚ã‚Š ``2`` ã§ã¯ã‚ã‚Šã¾ã›ã‚“; ``int`` åŒå£«ã®å…¨ã¦ã®é™¤ç®—ã¯ ``float``"
" ã®çµæœã«ãªã‚Šã¾ã™ã€‚ã“ã®å¤‰æ›´ã«ã¤ã„ã¦ã¯å®Ÿéš›ã®ã¨ã“ã‚ã€ 2002 å¹´ã«ãƒªãƒªãƒ¼ã‚¹ã•ã‚ŒãŸ Python 2.2 ã‹ã‚‰è¨ˆç”»ã•ã‚Œã¾ã—ãŸã€‚ãã®ã‚ˆã†ãªã‚ã‘ã§ã€ "
"``/``, ``//`` æ¼”ç®—å­ã‚’ä½¿ã†ã©ã‚“ãªãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚‚ ``from __future__ import division`` "
"ã‚’è¿½åŠ ã™ã‚‹ã‹ã€ã‚ã‚‹ã„ã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ ``-Q`` "
"ãƒ•ãƒ©ã‚°ã¨ã¨ã‚‚ã«èµ·å‹•ã™ã‚‹ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã¾ã—ãŸã€‚ã“ã‚Œã‚’ã¾ã ã‚„ã£ãŸã“ã¨ãŒãªã‘ã‚Œã°ã€ã‚³ãƒ¼ãƒ‰ã‚’ãã¾ãªãèª¿ã¹ã¦å¯¾è±¡ç®‡æ‰€ã‚’è¦‹ã¤ã‘ã€ 2 ã¤ã®ã“ã¨ã‚’ã—ã¾ã™:"

#: ../../howto/pyporting.rst:172
msgid "Add ``from __future__ import division`` to your files"
msgstr "``from __future__ import division`` ã‚’ã‚ãªãŸã®ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ ã—ã¾ã™"

#: ../../howto/pyporting.rst:173
msgid ""
"Update any division operator as necessary to either use ``//`` to use floor "
"division or continue using ``/`` and expect a float"
msgstr ""
"floor division (è¨³æ³¨: float ã§ã®çµæœã« :func:`~math.floor` é©ç”¨ã—ãŸã®ã¨åŒã˜æŒ¯ã‚‹èˆã„ã‚’ã™ã‚‹é™¤ç®—) ã«å¯¾ã—ã¦ã¯"
" ``//`` ã‚’ã€æµ®å‹•å°æ•°ç‚¹æ•°ã®æ¼”ç®—ã‚’æœŸå¾…ã™ã‚‹ç®‡æ‰€ã§ã¯ãã®ã¾ã¾ ``/`` ã‚’ä½¿ã†ã‚ˆã†ã«ã€é™¤ç®—æ¼”ç®—å­ã‚’å¿…è¦ã«å¿œã˜ã¦å¤‰æ›´ã—ã¾ã™ã€‚"

#: ../../howto/pyporting.rst:176
msgid ""
"The reason that ``/`` isn't simply translated to ``//`` automatically is "
"that if an object defines a ``__truediv__`` method but not ``__floordiv__`` "
"then your code would begin to fail (e.g. a user-defined class that uses "
"``/`` to signify some operation but not ``//`` for the same thing or at "
"all)."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè‡ªèº«ã® ``__truediv__`` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã‚‹ã®ã« ``__floordiv__`` ã‚’æŒã£ã¦ã„ãªã„å ´åˆã«å£Šã‚Œã¦ã—ã¾ã†ã®ã§ã€"
" ``/`` ã‚’ ``//`` ã«å˜ç´”ã«è‡ªå‹•çš„ã«å¤‰æ›ã™ã‚‹ã“ã¨ã¯å‡ºæ¥ã¾ã›ã‚“(ä¾‹ãˆã°ãƒ¦ãƒ¼ã‚¶å®šç¾©ã‚¯ãƒ©ã‚¹ã§ ``/`` ã‚’ä½•ã‹ã®æ¼”ç®—ã«ä½¿ã£ã¦ã„ã¦ã€ ``//``"
" ã¯åŒã˜äº‹ã‚’ã—ãªã„ã‹ä½•ã‚‚ã—ãªã„ã‚ˆã†ãªå ´åˆ)ã€‚"

#: ../../howto/pyporting.rst:183
msgid "Text versus binary data"
msgstr "ãƒ†ã‚­ã‚¹ãƒˆå¯¾ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿"

#: ../../howto/pyporting.rst:185
msgid ""
"In Python 2 you could use the ``str`` type for both text and binary data. "
"Unfortunately this confluence of two different concepts could lead to "
"brittle code which sometimes worked for either kind of data, sometimes not. "
"It also could lead to confusing APIs if people didn't explicitly state that "
"something that accepted ``str`` accepted either text or binary data instead "
"of one specific type. This complicated the situation especially for anyone "
"supporting multiple languages as APIs wouldn't bother explicitly supporting "
"``unicode`` when they claimed text data support."
msgstr ""
"Python 2 ã§ã¯ ``str`` å‹ã‚’ãƒ†ã‚­ã‚¹ãƒˆã¨ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã®ã©ã¡ã‚‰ã«ã‚‚ä½¿ã†ã“ã¨ãŒå‡ºæ¥ã¦ã„ã¾ã—ãŸã€‚ä¸å¹¸ãªã“ã¨ã«ã“ã‚Œã¯ã€2 "
"ã¤ã®ç•°ãªã‚‹æ¦‚å¿µã‚’é‡ã­åˆã‚ã›ã¦ã„ã¦ã€ä¸¡æ–¹ã®ç¨®é¡ã®ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã€æ™‚ã€…å‹•ä½œã—ã¦æ™‚ã€…ã¯ãã†ã§ã¯ãªã„ã€ã¨ã„ã£ãŸå‚·ã¤ãã‚„ã™ã„ã‚³ãƒ¼ãƒ‰ã«ç¹‹ãŒã‚Šã‚„ã™ã„ã‚‚ã®ã§ã—ãŸã€‚äººã€…ãŒç‰¹å®šã®ä¸€ã¤ã®å‹ã®ä»£ã‚ã‚Šã«"
" ``str`` ã‚’å—ã‘ä»˜ã‘ã‚‹ä½•ã‹ãŒã€ãã‚ŒãŒè¨±å®¹ã™ã‚‹ã®ã¯ãƒ†ã‚­ã‚¹ãƒˆãªã®ã‹ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ãªã®ã‹ã‚’åè¨€ã—ãªã„ã¨ãã®ã€æ‚©ã¾ã—ã„ API "
"ã‚’ç”Ÿã¿å‡ºã—ã¦ã—ã¾ã†è¦å› ã§ã‚‚ã‚ã‚Šã¾ã—ãŸã€‚ã“ã‚Œã¯ã¨ã‚Šã‚ã‘ãƒãƒ«ãƒãƒªãƒ³ã‚¬ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã®çŠ¶æ³ã‚’ã€ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã¨ä¸»å¼µã—ã¦ã„ã‚‹ã®ã«æ˜ç¤ºçš„ã«"
" ``unicode`` ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã«æ³¨æ„ã‚’æ‰•ã‚ãªã„ APIã€ã¨ã„ã†å½¢ã§è¤‡é›‘ã«ã—ã¦ã„ã¾ã—ãŸã€‚"

#: ../../howto/pyporting.rst:194
msgid ""
"To make the distinction between text and binary data clearer and more "
"pronounced, Python 3 did what most languages created in the age of the "
"internet have done and made text and binary data distinct types that cannot "
"blindly be mixed together (Python predates widespread access to the "
"internet). For any code that deals only with text or only binary data, this "
"separation doesn't pose an issue. But for code that has to deal with both, "
"it does mean you might have to now care about when you are using text "
"compared to binary data, which is why this cannot be entirely automated."
msgstr ""
"ãƒ†ã‚­ã‚¹ãƒˆã¨ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã®åŒºåˆ¥ã‚’ã‚ˆã‚Šæ˜å¿«ã«ã€ã‚ˆã‚Šã¯ã£ãã‚Šå®£è¨€ã™ã‚‹ãŸã‚ã«ã€ Python 3 "
"ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ™‚ä»£ã«ä½œã‚‰ã‚ŒãŸã»ã¨ã‚“ã©ã®è¨€èªãŒã—ãŸã“ã¨ã€ã™ãªã‚ã¡ãƒ†ã‚­ã‚¹ãƒˆã¨ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚’åŒºåˆ¥ã§ãã‚‹åˆ¥ã€…ã®å‹ã¨ã—ã€ç„¡åˆ†åˆ¥ã«ãŠäº’ã„æ··ãœã“ãœã«ã¯å‡ºæ¥ãªã„ã‚ˆã†ã«ã—ã¾ã—ãŸ"
" (Python "
"ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãŒåºƒãæ™®åŠã™ã‚‹å‰ã‹ã‚‰ã‚ã‚Šã¾ã—ãŸ)ã€‚ãƒ†ã‚­ã‚¹ãƒˆã®ã¿ã‚’å–ã‚Šæ‰±ã†ã‚³ãƒ¼ãƒ‰ã€ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã®ã¿ã‚’æ‰±ã†ã‚³ãƒ¼ãƒ‰ã®ã„ãšã‚Œã«ã¨ã£ã¦ã‚‚ã€ã“ã®åˆ†é›¢ã¯å•é¡Œã‚’å¼•ãèµ·ã“ã—ã¾ã›ã‚“ã€‚ã§ã™ãŒä¸¡æ–¹ã‚’å‡¦ç†ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã«ã¨ã£ã¦ã¯ã€ãã‚Œã¯ãƒ†ã‚­ã‚¹ãƒˆã¨ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã®æ¯”è¼ƒã‚’ã™ã‚‹éš›ã«æ–°ãŸãªæ³¨æ„ç‚¹ãŒå¢—ãˆãŸã“ã¨ã‚’æ„å‘³ã—ã¦ã„ã¦ã€ã“ã‚ŒãŒå®Œå…¨ã«ã¯ç§»è¡Œã®è‡ªå‹•åŒ–ãŒå‡ºæ¥ãªã„ç†ç”±ãªã®ã§ã™ã€‚"

#: ../../howto/pyporting.rst:203
msgid ""
"To start, you will need to decide which APIs take text and which take binary"
" (it is **highly** recommended you don't design APIs that can take both due "
"to the difficulty of keeping the code working; as stated earlier it is "
"difficult to do well). In Python 2 this means making sure the APIs that take"
" text can work with ``unicode`` and those that work with binary data work "
"with the ``bytes`` type from Python 3 (which is a subset of ``str`` in "
"Python 2 and acts as an alias for ``bytes`` type in Python 2). Usually the "
"biggest issue is realizing which methods exist on which types in Python 2 & "
"3 simultaneously (for text that's ``unicode`` in Python 2 and ``str`` in "
"Python 3, for binary that's ``str``/``bytes`` in Python 2 and ``bytes`` in "
"Python 3). The following table lists the **unique** methods of each data "
"type across Python 2 & 3 (e.g., the ``decode()`` method is usable on the "
"equivalent binary data type in either Python 2 or 3, but it can't be used by"
" the textual data type consistently between Python 2 and 3 because ``str`` "
"in Python 3 doesn't have the method). Do note that as of Python 3.5 the "
"``__mod__`` method was added to the bytes type."
msgstr ""

#: ../../howto/pyporting.rst:220
msgid "**Text data**"
msgstr "**ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿**"

#: ../../howto/pyporting.rst:220
msgid "**Binary data**"
msgstr "**ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿**"

#: ../../howto/pyporting.rst:222
msgid "\\"
msgstr "\\"

#: ../../howto/pyporting.rst:222
msgid "decode"
msgstr "decode"

#: ../../howto/pyporting.rst:224
msgid "encode"
msgstr "encode"

#: ../../howto/pyporting.rst:226
msgid "format"
msgstr "format"

#: ../../howto/pyporting.rst:228
msgid "isdecimal"
msgstr "isdecimal"

#: ../../howto/pyporting.rst:230
msgid "isnumeric"
msgstr "isnumeric"

#: ../../howto/pyporting.rst:233
msgid ""
"Making the distinction easier to handle can be accomplished by encoding and "
"decoding between binary data and text at the edge of your code. This means "
"that when you receive text in binary data, you should immediately decode it."
" And if your code needs to send text as binary data then encode it as late "
"as possible. This allows your code to work with only text internally and "
"thus eliminates having to keep track of what type of data you are working "
"with."
msgstr ""
"å‡¦ç†ã®åŒºåˆ¥ã‚’ç°¡å˜ã«ã™ã‚‹ã«ã¯ã€ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã¨ãƒ†ã‚­ã‚¹ãƒˆã®é–“ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã¨ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚’ã€ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã®å¢ƒç•Œã§è¡Œã†ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ãƒ†ã‚­ã‚¹ãƒˆã‚’å—ã‘å–ã£ãŸãªã‚‰ã°ã€å³åº§ã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã€‚ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã«ã—ã¦é€ä¿¡ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸã‚‰ã€å‡ºæ¥ã‚‹ã ã‘ã‚ã¨ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã€‚ã“ã®ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã€ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã¯å†…éƒ¨çš„ã«ã¯ãƒ†ã‚­ã‚¹ãƒˆã ã‘ã§å‹•ä½œã—ã€ã§ã™ã‹ã‚‰ã€ä»Šå‡¦ç†ã—ã¦ã„ã‚‹ã®ãŒã©ã®å‹ãªã®ã‹ã‚’é€ä¸€è¿½è·¡ã—ãªãã¦ã‚‚è‰¯ããªã‚Šã¾ã™ã€‚"

#: ../../howto/pyporting.rst:240
msgid ""
"The next issue is making sure you know whether the string literals in your "
"code represent text or binary data. You should add a ``b`` prefix to any "
"literal that presents binary data. For text you should add a ``u`` prefix to"
" the text literal. (there is a :mod:`__future__` import to force all "
"unspecified literals to be Unicode, but usage has shown it isn't as "
"effective as adding a ``b`` or ``u`` prefix to all literals explicitly)"
msgstr ""

#: ../../howto/pyporting.rst:247
msgid ""
"As part of this dichotomy you also need to be careful about opening files. "
"Unless you have been working on Windows, there is a chance you have not "
"always bothered to add the ``b`` mode when opening a binary file (e.g., "
"``rb`` for binary reading).  Under Python 3, binary files and text files are"
" clearly distinct and mutually incompatible; see the :mod:`io` module for "
"details. Therefore, you **must** make a decision of whether a file will be "
"used for binary access (allowing binary data to be read and/or written) or "
"textual access (allowing text data to be read and/or written). You should "
"also use :func:`io.open` for opening files instead of the built-in "
":func:`open` function as the :mod:`io` module is consistent from Python 2 to"
" 3 while the built-in :func:`open` function is not (in Python 3 it's "
"actually :func:`io.open`). Do not bother with the outdated practice of using"
" :func:`codecs.open` as that's only necessary for keeping compatibility with"
" Python 2.5."
msgstr ""

#: ../../howto/pyporting.rst:261
msgid ""
"The constructors of both ``str`` and ``bytes`` have different semantics for "
"the same arguments between Python 2 & 3. Passing an integer to ``bytes`` in "
"Python 2 will give you the string representation of the integer: ``bytes(3) "
"== '3'``. But in Python 3, an integer argument to ``bytes`` will give you a "
"bytes object as long as the integer specified, filled with null bytes: "
"``bytes(3) == b'\\x00\\x00\\x00'``. A similar worry is necessary when "
"passing a bytes object to ``str``. In Python 2 you just get the bytes object"
" back: ``str(b'3') == b'3'``. But in Python 3 you get the string "
"representation of the bytes object: ``str(b'3') == \"b'3'\"``."
msgstr ""
"``str`` ã¨ ``bytes`` ã®ä¸¡æ–¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯åŒã˜å¼•æ•°ã‚’ä¸ãˆã¦ã‚‚ Python 2 ã¨ 3 ã§ç•°ãªã‚‹æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚Python 2 "
"ã§ ``bytes`` ã«æ•°å€¤ã‚’ä¸ãˆã‚‹ã¨ã€æ•´æ•°ã®æ–‡å­—åˆ—è¡¨ç¾ã‚’ç”Ÿæˆã—ã¾ã™: ``bytes(3) == '3'`` ã€‚ã§ã™ãŒ Python 3 ã§ã¯ã€ "
"``bytes`` ã«æ•´æ•°ã‚’ä¸ãˆã‚‹ã¨ã€æ•´æ•°å€¤ã§ä¸ãˆãŸã¶ã‚“ã®é•·ã•ã®ã€null ãƒã‚¤ãƒˆã§åŸ‹ã‚ã‚‰ã‚ŒãŸãƒã‚¤ãƒˆåˆ—ã‚’ç”Ÿæˆã—ã¾ã™: ``bytes(3) == "
"b'\\x00\\x00\\x00'`` ã€‚ä¼¼ãŸã‚ˆã†ãªè©±ã¯ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ ``str`` ã«ä¸ãˆã‚‹å ´åˆã«ã‚‚èµ·ã“ã‚Šã¾ã™ã€‚Python 2 "
"ã§ã¯ãƒã‚¤ãƒˆåˆ—ãŒæ¸¡ã—ãŸã‚‚ã®ãŒãã®ã¾ã¾æˆ»ã£ã¦ãã¾ã™: ``str(b'3') == b'3'`` ã€‚å¯¾ã—ã¦ Python 3 "
"ã§ã¯ã€ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ–‡å­—åˆ—è¡¨ç¾ã«ãªã£ã¦è¿”ã£ã¦ãã¾ã™: ``str(b'3') == \"b'3'\"`` ã€‚"

#: ../../howto/pyporting.rst:271
msgid ""
"Finally, the indexing of binary data requires careful handling (slicing does"
" **not** require any special handling). In Python 2, ``b'123'[1] == b'2'`` "
"while in Python 3 ``b'123'[1] == 50``. Because binary data is simply a "
"collection of binary numbers, Python 3 returns the integer value for the "
"byte you index on. But in Python 2 because ``bytes == str``, indexing "
"returns a one-item slice of bytes. The six_ project has a function named "
"``six.indexbytes()`` which will return an integer like in Python 3: "
"``six.indexbytes(b'123', 1)``."
msgstr ""
"æœ€å¾Œã«ã€ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹ã‚¤ãƒ³ãƒ‡ã‚¯ã‚·ãƒ³ã‚°ã«ã¯å–ã‚Šæ‰±ã„ã«æ³¨æ„ãŒå¿…è¦ã§ã™(ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ã«ã¯ç‰¹åˆ¥ãªå–ã‚Šæ‰±ã„ã¯ **ä¸è¦** ã§ã™)ã€‚Python 2 "
"ã§ã¯ã€ ``b'123'[1] == b'2'`` ã§ã™ãŒã€Python 3 ã§ã¯ ``b'123'[1] == 50`` "
"ã§ã™ã€‚ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã¯ãŸã ã®ãƒã‚¤ãƒŠãƒªæ•°å€¤ã®ç¾…åˆ—ã§ã™ã‹ã‚‰ã€Python 3 ã§ã¯æŒ‡ç¤ºã—ãŸä½ç½®ã®ãƒã‚¤ãƒˆã®æ•´æ•°å€¤ã‚’è¿”ã—ã¾ã™ã€‚ã§ã™ãŒ Python 2 ã®å ´åˆã€"
" ``bytes == str`` ã§ã‚ã‚‹ãŸã‚ã«ã€ã‚¤ãƒ³ãƒ‡ã‚¯ã‚·ãƒ³ã‚°ã¯ bytes ã®è¦ç´ ä¸€ã¤ã‚’å–ã‚Šå‡ºã™ã‚¹ãƒ©ã‚¤ã‚¹ã¨ã—ã¦æŒ¯èˆã„ã¾ã™ã€‚ six_ "
"ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ ``six.indexbytes()`` ã¨åä»˜ã‘ã‚‰ã‚ŒãŸé–¢æ•°ãŒã‚ã£ã¦ã€ã“ã‚Œã¯ Python 3 ãŒãã†ã™ã‚‹ã‚ˆã†ã«æ•´æ•°å€¤ã‚’è¿”ã—ã¾ã™: "
"``six.indexbytes(b'123', 1)`` ã€‚"

#: ../../howto/pyporting.rst:280
msgid "To summarize:"
msgstr "ã¾ã¨ã‚ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™:"

#: ../../howto/pyporting.rst:282
msgid "Decide which of your APIs take text and which take binary data"
msgstr "ã©ã® API ãŒãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å—ä»˜ã‘ã€ã©ã® API ãŒãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘ä»˜ã‘ã‚‹ã®ã‹ã‚’æ±ºã‚ã¦ãã ã•ã„ã€‚"

#: ../../howto/pyporting.rst:283
msgid ""
"Make sure that your code that works with text also works with ``unicode`` "
"and code for binary data works with ``bytes`` in Python 2 (see the table "
"above for what methods you cannot use for each type)"
msgstr ""
"ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ãŒ Python 2 ã§ç¢ºå®Ÿã«ã€ãƒ†ã‚­ã‚¹ãƒˆã§å‹•ãã‚‚ã®ã¯ ``unicode`` ã§ã‚‚å‹•ãã‚ˆã†ã«ã€ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã§å‹•ãã‚‚ã®ã¯ "
"``bytes`` ã§ã‚‚å‹•ãã‚ˆã†ã«ã—ã¦ãã ã•ã„(ã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒãã‚Œãã‚Œã®å‹ã§ä½¿ãˆãªã„ã®ã‹ã‚’ç¤ºã—ãŸä¸Šè¨˜ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ã¿ã¦ãã ã•ã„)ã€‚"

#: ../../howto/pyporting.rst:286
msgid ""
"Mark all binary literals with a ``b`` prefix, textual literals with a ``u`` "
"prefix"
msgstr ""

#: ../../howto/pyporting.rst:288
msgid ""
"Decode binary data to text as soon as possible, encode text as binary data "
"as late as possible"
msgstr "ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã™ã‚‹ã®ã¯å‡ºæ¥ã‚‹ã ã‘æ—©ãã€ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ã®ã¯å‡ºæ¥ã‚‹ã ã‘é…ãã€‚"

#: ../../howto/pyporting.rst:290
msgid ""
"Open files using :func:`io.open` and make sure to specify the ``b`` mode "
"when appropriate"
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã¯ :func:`io.open` ã‚’ä½¿ã£ã¦é–‹ãã€ãã†ã™ã¹ãã¨ãã«ã¯å¿…ãš ``b`` ãƒ¢ãƒ¼ãƒ‰ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚"

#: ../../howto/pyporting.rst:292
msgid "Be careful when indexing into binary data"
msgstr ""

#: ../../howto/pyporting.rst:296
msgid "Use feature detection instead of version detection"
msgstr "ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ¤œå‡ºã§ã¯ãªãæ©Ÿèƒ½æ¤œå‡ºã‚’ä½¿ã†"

#: ../../howto/pyporting.rst:298
msgid ""
"Inevitably you will have code that has to choose what to do based on what "
"version of Python is running. The best way to do this is with feature "
"detection of whether the version of Python you're running under supports "
"what you need. If for some reason that doesn't work then you should make the"
" version check be against Python 2 and not Python 3. To help explain this, "
"let's look at an example."
msgstr ""

#: ../../howto/pyporting.rst:305
msgid ""
"Let's pretend that you need access to a feature of importlib_ that is "
"available in Python's standard library since Python 3.3 and available for "
"Python 2 through importlib2_ on PyPI. You might be tempted to write code to "
"access e.g. the ``importlib.abc`` module by doing the following::"
msgstr ""
"importlib_ ã®æ©Ÿèƒ½ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ã—ã¾ã—ã‚‡ã†ã€‚\n"
"ã“ã‚Œã¯ Python 3.3 ã‹ã‚‰ä½¿ãˆã‚‹ Python ã®æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã€ãã®æ©Ÿèƒ½ã¯ Python 2 ã§ã¯ PyPI ã«ã‚ã‚‹ importlib2_ ã‹ã‚‰ä½¿ãˆã¾ã™ã€‚\n"
"ä¾‹ãˆã° ``importlib.abc`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã®ã«ã€æ¬¡ã®ã‚ˆã†ã«æ›¸ããŸããªã‚‹ã“ã¨ãŒã‚ã‚‹ã§ã—ã‚‡ã†::"

#: ../../howto/pyporting.rst:317
msgid ""
"The problem with this code is what happens when Python 4 comes out? It would"
" be better to treat Python 2 as the exceptional case instead of Python 3 and"
" assume that future Python versions will be more compatible with Python 3 "
"than Python 2::"
msgstr ""
"ã“ã®ã‚³ãƒ¼ãƒ‰ã®å•é¡Œã¯ã€ Python 4 ãŒå‡ºãŸã¨ãã«èµ·ãã¾ã™ã€‚\n"
"Python 3 ã§ã¯ãªã Python 2 ã‚’ä¾‹å¤–çš„ãªã‚±ãƒ¼ã‚¹ã¨ã—ã¦æ‰±ã„ã€å°†æ¥ã® Python ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ Python 2 ã‚ˆã‚Šã‚‚ Python 3 ã¨äº’æ›æ€§ãŒã‚ã‚‹ã¨ä»®å®šã™ã‚‹æ–¹ãŒè‰¯ã•ãã†ã§ã™::"

#: ../../howto/pyporting.rst:329
msgid ""
"The best solution, though, is to do no version detection at all and instead "
"rely on feature detection. That avoids any potential issues of getting the "
"version detection wrong and helps keep you future-compatible::"
msgstr ""
"ã¨ã“ã‚ãŒã€æœ€é©è§£ã¯ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ¤œå‡ºã‚’ä¸€åˆ‡ã›ãšã«ã€ä»£ã‚ã‚Šã«æ©Ÿèƒ½æ¤œå‡ºã«é ¼ã‚‹ã“ã¨ã§ã™ã€‚\n"
"æ©Ÿèƒ½æ¤œå‡ºã‚’ä½¿ã†ã“ã¨ã§ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ¤œå‡ºãŒä¸Šæ‰‹ãè¡Œã‹ãªããªã‚‹æ½œåœ¨çš„ãªå•é¡Œã‚’é¿ã‘ã‚‰ã‚Œã€æ©Ÿèƒ½ã®äº’æ›æ€§ã‚’ä¿ã¤åŠ©ã‘ã«ãªã‚Šã¾ã™::"

#: ../../howto/pyporting.rst:340
msgid "Prevent compatibility regressions"
msgstr "äº’æ›æ€§ã‚ªãƒ—ã‚·ãƒ§ãƒ³"

#: ../../howto/pyporting.rst:342
msgid ""
"Once you have fully translated your code to be compatible with Python 3, you"
" will want to make sure your code doesn't regress and stop working under "
"Python 3. This is especially true if you have a dependency which is blocking"
" you from actually running under Python 3 at the moment."
msgstr ""
"ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã‚’å®Œå…¨ã« Python 3 äº’æ›ã«å¤‰æ›ã§ããŸã‚‰ã€ä»Šåº¦ã¯ Python 3 "
"ã§ã®å‹•ä½œãŒé€€åŒ–ã—ãŸã‚Šæ­¢ã¾ã£ã¦ã—ã¾ã†ã“ã¨ãŒãªã„ã‚ˆã†ã«ã—ãŸã„ã§ã—ã‚‡ã†ã€‚ã“ã®æ™‚ç‚¹ã§ã¯ã¾ã å®Ÿéš›ã« Python 3 "
"ã§å‹•ä½œã•ã›ã‚‰ã‚Œãªã„é˜»å®³è¦å› ã¨ãªã‚‹ä¾å­˜ç‰©ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã«ã€ã“ã‚Œã¯ç‰¹ã«å½“ã¦ã¯ã¾ã‚Šã¾ã™ã€‚"

#: ../../howto/pyporting.rst:347
msgid ""
"To help with staying compatible, any new modules you create should have at "
"least the following block of code at the top of it::"
msgstr "äº’æ›æ€§ã‚’ä¿ã¡ç¶šã‘ã‚‹ãŸã‚ã«ã€ã‚ãªãŸãŒä½œã‚‹å…¨ã¦ã®æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€æœ€ä½ã§ã‚‚ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®å…ˆé ­ã«ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŒã¤ã¹ãã§ã™::"

#: ../../howto/pyporting.rst:354
msgid ""
"You can also run Python 2 with the ``-3`` flag to be warned about various "
"compatibility issues your code triggers during execution. If you turn "
"warnings into errors with ``-Werror`` then you can make sure that you don't "
"accidentally miss a warning."
msgstr ""
"å®Ÿè¡Œæ™‚ã«ç¨®ã€…ã®äº’æ›æ€§å•é¡Œã‚’è­¦å‘Šã—ã¦ã‚‚ã‚‰ã†ãŸã‚ã« Python 2 ã‚’ ``-3`` ãƒ•ãƒ©ã‚°ä»˜ãã§å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚‚å‡ºæ¥ã¾ã™ã€‚ ``-Werror`` "
"ã«ã™ã‚Œã°è­¦å‘Šã§ã¯ãªãã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã®ã§ã€ã†ã£ã‹ã‚Šè­¦å‘Šã‚’è¦‹é€ƒã™ã“ã¨ãŒãªããªã‚Šã¾ã™ã€‚"

#: ../../howto/pyporting.rst:359
msgid ""
"You can also use the Pylint_ project and its ``--py3k`` flag to lint your "
"code to receive warnings when your code begins to deviate from Python 3 "
"compatibility. This also prevents you from having to run Modernize_ or "
"Futurize_ over your code regularly to catch compatibility regressions. This "
"does require you only support Python 2.7 and Python 3.4 or newer as that is "
"Pylint's minimum Python version support."
msgstr ""
"Pylint_ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¨ãã® ``--py3k`` ãƒ•ãƒ©ã‚°ã‚’ä½¿ã£ã¦ã€Python 3 "
"äº’æ›æ€§ã‹ã‚‰ä¹–é›¢ã—å§‹ã‚ã¦ã„ã‚‹éš›ã®è­¦å‘Šã‚’å—ã‘å–ã‚‹ã“ã¨ã‚‚å‡ºæ¥ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ Modernize_ ã‚„ Futurize_ "
"ã‚’æ™®é€šã«å®Ÿè¡Œã—ã¦ã¿ã¦äº’æ›æ€§ã‚’å¤±ã£ã¦ã„ãªã„ã‹ã‚’ç¢ºèªã™ã‚‹ã€ã¨ã„ã†å¿…è¦ãŒãªããªã‚Šã¾ã™ã€‚ã“ã®å ´åˆ Python 2.7 ã¨ Python 3.4 "
"ä»¥ä¸Šã ã‘ã®ã‚µãƒãƒ¼ãƒˆã«ã™ã‚‹ã“ã¨ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚ãã‚ŒãŒ Pylint ãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹æœ€å°ã® Python ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã ã‹ã‚‰ã§ã™ã€‚"

#: ../../howto/pyporting.rst:368
msgid "Check which dependencies block your transition"
msgstr "ã©ã®ä¾å­˜æ€§ãŒã‚ãªãŸã®ç§»è¡Œã‚’é˜»ã‚“ã§ã„ã‚‹ã®ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹"

#: ../../howto/pyporting.rst:370
msgid ""
"**After** you have made your code compatible with Python 3 you should begin "
"to care about whether your dependencies have also been ported. The "
"caniusepython3_ project was created to help you determine which projects -- "
"directly or indirectly -- are blocking you from supporting Python 3. There "
"is both a command-line tool as well as a web interface at "
"https://caniusepython3.com."
msgstr ""

#: ../../howto/pyporting.rst:377
msgid ""
"The project also provides code which you can integrate into your test suite "
"so that you will have a failing test when you no longer have dependencies "
"blocking you from using Python 3. This allows you to avoid having to "
"manually check your dependencies and to be notified quickly when you can "
"start running on Python 3."
msgstr ""
"ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯åŒæ™‚ã«ã‚ãªãŸã®ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã«çµ„ã¿è¾¼ã‚€ã“ã¨ãŒå‡ºæ¥ã‚‹ã€ã‚‚ã† Python 3 "
"ä½¿ç”¨ã‚’å¦¨ã’ã‚‹ä¾å­˜ç‰©ãŒãªããªã£ãŸæ™‚ç‚¹ã§å¤±æ•—ã™ã‚‹ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚‚æä¾›ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€Python 3 "
"ã§ã®å‹•ä½œã‚’é–‹å§‹ã™ã‚‹éš›ã«ã€ä¾å­˜ç‰©ã‚’æ‰‹å‹•ã§ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã“ã¨ãªãå³åº§ã«æ°—ä»˜ãã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚"

#: ../../howto/pyporting.rst:384
msgid "Update your ``setup.py`` file to denote Python 3 compatibility"
msgstr "ã‚ãªãŸã® ``setup.py`` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°ã—ã¦ Python 3 äº’æ›ã‚’è¬³ã†"

#: ../../howto/pyporting.rst:386
msgid ""
"Once your code works under Python 3, you should update the classifiers in "
"your ``setup.py`` to contain ``Programming Language :: Python :: 3`` and to "
"not specify sole Python 2 support. This will tell anyone using your code "
"that you support Python 2 **and** 3. Ideally you will also want to add "
"classifiers for each major/minor version of Python you now support."
msgstr ""
"ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ãŒ Python 3 ã§å‹•ä½œã™ã‚‹ã‚ˆã†ã«ãªã£ãŸã‚‰ã€ ``setup.py`` ã® classifiers ã‚’ ``Programming "
"Language :: Python :: 3`` ã‚’å«ã‚ã‚‹ã‚ˆã†ã«æ›´æ–°ã—ã¦ã€Python 2 "
"ã ã‘ã®ã‚µãƒãƒ¼ãƒˆã§ã¯ãªã„ã“ã¨ã‚’æ˜è¨˜ã™ã¹ãã§ã™ã€‚ã“ã‚Œã«ã‚ˆã£ã¦ã€ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã‚’åˆ©ç”¨ã™ã‚‹äººã¯ã‚ãªãŸãŒ Python 2 *ã¨* 3 "
"ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã‚’çŸ¥ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚ç†æƒ³çš„ã«ã¯ã€ä»Šã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ Python ã®ãƒ¡ã‚¸ãƒ£ãƒ¼/ãƒã‚¤ãƒŠãƒ¼ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚‚ classifiers "
"ã«è¿½åŠ ã—ãŸã„ã§ã—ã‚‡ã†ã€‚"

#: ../../howto/pyporting.rst:394
msgid "Use continuous integration to stay compatible"
msgstr "ç¶™ç¶šçš„ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ã£ã¦äº’æ›æ€§ã‚’ç¶­æŒã—ç¶šã‘ã‚‹ã€‚"

#: ../../howto/pyporting.rst:396
msgid ""
"Once you are able to fully run under Python 3 you will want to make sure "
"your code always works under both Python 2 & 3. Probably the best tool for "
"running your tests under multiple Python interpreters is tox_. You can then "
"integrate tox with your continuous integration system so that you never "
"accidentally break Python 2 or 3 support."
msgstr ""
"Python 3 ã§å®Œå…¨ã«å‹•ä½œå‡ºæ¥ã¦ã—ã¾ã£ãŸã‚‰ã€ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ãŒ Python 2ã€3 "
"ã®ä¸¡æ–¹ã§ã„ã¤ã§ã‚‚å‹•ãã“ã¨ã‚’ä¿éšœã—ãŸã„ã§ã—ã‚‡ã†ã€‚ãŠãã‚‰ãã€è¤‡æ•°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã§ãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã™ã‚‹ã®ã«æœ€è‰¯ã®ãƒ„ãƒ¼ãƒ«ã¯ã€ tox_ "
"ã§ã™ã€‚ç¶™ç¶šçš„ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã« tox ã‚’çµ±åˆã—ã¦ã€ã†ã£ã‹ã‚Š Python 2 ã‹ 3 ã®ã‚µãƒãƒ¼ãƒˆã‚’å£Šã—ã¦ã—ã¾ã‚ãªã„ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚"

#: ../../howto/pyporting.rst:402
msgid ""
"You may also want to use the ``-bb`` flag with the Python 3 interpreter to "
"trigger an exception when you are comparing bytes to strings or bytes to an "
"int (the latter is available starting in Python 3.5). By default type-"
"differing comparisons simply return ``False``, but if you made a mistake in "
"your separation of text/binary data handling or indexing on bytes you "
"wouldn't easily find the mistake. This flag will raise an exception when "
"these kinds of comparisons occur, making the mistake much easier to track "
"down."
msgstr ""
"Python 3 ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã§ ``-bb`` ãƒ•ãƒ©ã‚°ã‚’ä½¿ã£ã¦ã€ bytes ã¨ string ã€ã‚‚ã—ãã¯ bytes ã¨ int ã‚’æ¯”è¼ƒã—ãŸã¨ãã«ä¾‹å¤–ã‚’å¼•ãèµ·ã“ã—ãŸã„ã¨æ€ã†ã§ã—ã‚‡ã† (å¾Œè€…ã¯ Python 3.5 ã‹ã‚‰ä½¿ãˆã¾ã™)ã€‚\n"
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯å‹ã®ç•°ãªã‚‹æ¯”è¼ƒã¯å˜ç´”ã« ``False`` ã‚’è¿”ã—ã¾ã™ãŒã€ãƒ†ã‚­ã‚¹ãƒˆ/ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿å‡¦ç†ã®åˆ†é›¢ã‚’èª¤ã£ãŸã‚Šã€ãƒã‚¤ãƒˆåˆ—ã¸ã®æ·»ãˆå­—æ“ä½œã‚’èª¤ã‚‹ã¨ã€ç°¡å˜ã«ã¯é–“é•ã„ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œã¾ã›ã‚“ã€‚\n"
"ã“ã®ãƒ•ãƒ©ã‚°ã¯ãã‚ŒãŒèµ·ã“ã£ãŸå ´åˆã«ä¾‹å¤–ã‚’èµ·ã“ã™ã“ã¨ã§ã€ãã®ç¨®ã®ã‚±ãƒ¼ã‚¹ã‚’è¿½è·¡ã™ã‚‹åŠ©ã‘ã«ãªã‚Šã¾ã™ã€‚"

#: ../../howto/pyporting.rst:410
msgid ""
"And that's mostly it! At this point your code base is compatible with both "
"Python 2 and 3 simultaneously. Your testing will also be set up so that you "
"don't accidentally break Python 2 or 3 compatibility regardless of which "
"version you typically run your tests under while developing."
msgstr ""
"ãã—ã¦ã“ã‚Œã§ã»ã¼å…¨ã¦ã§ã™! ä»Šã®æ™‚ç‚¹ã§ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã¯ Python 2 ã¨ 3 "
"ã®ä¸¡æ–¹ã«å¯¾ã—ã¦åŒæ™‚ã«äº’æ›ã§ã™ã€‚ã‚ãªãŸã®ãƒ†ã‚¹ãƒˆã¯ã€é–‹ç™ºæ™‚ç‚¹ã§ã¯ã©ã¡ã‚‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ãƒ†ã‚¹ãƒˆã™ã‚‹ã“ã¨ãŒå¤šã„ã®ã‹ã«ã‚ˆã‚‰ãšã«ã€èª¤ã£ã¦ Python 2 ã‹ 3 "
"ã®äº’æ›æ€§ã‚’ç ´å£Šã—ã¦ã—ã¾ã‚ãªã„ã‚ˆã†ã«ã‚‚çµ„ã¿ç«‹ã¦ã‚‰ã‚Œã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../howto/pyporting.rst:417
msgid "Consider using optional static type checking"
msgstr ""

#: ../../howto/pyporting.rst:419
msgid ""
"Another way to help port your code is to use a static type checker like "
"mypy_ or pytype_ on your code. These tools can be used to analyze your code "
"as if it's being run under Python 2, then you can run the tool a second time"
" as if your code is running under Python 3. By running a static type checker"
" twice like this you can discover if you're e.g. misusing binary data type "
"in one version of Python compared to another. If you add optional type hints"
" to your code you can also explicitly state whether your APIs use textual or"
" binary data, helping to make sure everything functions as expected in both "
"versions of Python."
msgstr ""
