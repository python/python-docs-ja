# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-29 13:25+0900\n"
"PO-Revision-Date: 2018-08-13 15:09+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../faq/programming.rst:5
msgid "Programming FAQ"
msgstr "ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° FAQ"

#: ../../faq/programming.rst:8
msgid "Contents"
msgstr "å†…å®¹"

#: ../../faq/programming.rst:12
msgid "General Questions"
msgstr "ä¸€èˆ¬çš„ãªè³ªå•"

#: ../../faq/programming.rst:15
msgid ""
"Is there a source code level debugger with breakpoints, single-stepping, "
"etc.?"
msgstr "ãƒ–ãƒ¬ãƒ¼ã‚¯ãƒã‚¤ãƒ³ãƒˆã‚„ã‚·ãƒ³ã‚°ãƒ«ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œãªã©ã‚’å‚™ãˆãŸã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒãƒƒã‚¬ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:17 ../../faq/programming.rst:60
msgid "Yes."
msgstr "ã¯ã„ã€‚"

#: ../../faq/programming.rst:19
msgid ""
"The pdb module is a simple but adequate console-mode debugger for Python. It"
" is part of the standard Python library, and is :mod:`documented in the "
"Library Reference Manual <pdb>`. You can also write your own debugger by "
"using the code for pdb as an example."
msgstr "pdb ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ç°¡ç´ ã«ã—ã¦ååˆ†ãª Python ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ¢ãƒ¼ãƒ‰ãƒ‡ãƒãƒƒã‚¬ã§ã™ã€‚ã“ã‚Œã¯ Python ã®æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å«ã¾ã‚Œã¦ã„ã‚‹ã‚‚ã®ã§ã€ :mod:`ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã«ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒã‚ã‚Šã¾ã™ <pdb>` ã€‚ pdb ã®ã‚³ãƒ¼ãƒ‰ã‚’æ‰‹æœ¬ã«ã—ã¦è‡ªåˆ†ç”¨ã®ãƒ‡ãƒãƒƒã‚¬ã‚’æ›¸ãã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../faq/programming.rst:24
msgid ""
"The IDLE interactive development environment, which is part of the standard "
"Python distribution (normally available as Tools/scripts/idle), includes a "
"graphical debugger."
msgstr "Python ã«åŒæ¢±ã•ã‚Œã¦ã„ã‚‹çµ±åˆé–‹ç™ºç’°å¢ƒã® IDLE ã¯é€šå¸¸ã® Python ã®é…å¸ƒå½¢æ…‹ã®ä¸€éƒ¨ (æ™®é€šã¯ Tools/scripts/idle ã‹ã‚‰åˆ©ç”¨å¯èƒ½) ã§ã‚ã‚Šã€ã‚°ãƒ©ãƒ•ã‚£ã‚«ãƒ«ãªãƒ‡ãƒãƒƒã‚¬ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:28
msgid ""
"PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The "
"Pythonwin debugger colors breakpoints and has quite a few cool features such"
" as debugging non-Pythonwin programs.  Pythonwin is available as part of the"
" `Python for Windows Extensions "
"<https://sourceforge.net/projects/pywin32/>`__ project and as a part of the "
"ActivePython distribution (see https://www.activestate.com/activepython\\ )."
msgstr "PythonWin ã¯ã€pdb ã‚’ãƒ™ãƒ¼ã‚¹ã¨ã—ãŸ GUI ãƒ‡ãƒãƒƒã‚¬ã‚’å«ã‚€ Python IDE ã§ã™ã€‚Pythonwin ãƒ‡ãƒãƒƒã‚¬ã¯ã€ãƒ–ãƒ¬ãƒ¼ã‚¯ãƒã‚¤ãƒ³ãƒˆã®è‰²ä»˜ã‘ã‚„é Pythonwin ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒ‡ãƒãƒƒã‚°ãªã©ã®ãŸãã•ã‚“ã®ç´ æ•µãªæ©Ÿèƒ½ã‚’æŒã£ã¦ã„ã¾ã™ã€‚Pythonwin ã¯ `Python for Windows Extensions <https://sourceforge.net/projects/pywin32/>`__ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ä¸€éƒ¨ã€ã‚ã‚‹ã„ã¯ ActivePython ãƒ‡ã‚£ã‚¹ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ (https://www.activestate.com/activepython ã‚’å‚ç…§) ã®ä¸€éƒ¨ã¨ã—ã¦åˆ©ç”¨å¯èƒ½ã§ã™ã€‚"

#: ../../faq/programming.rst:35
msgid ""
"`Boa Constructor <http://boa-constructor.sourceforge.net/>`_ is an IDE and "
"GUI builder that uses wxWidgets.  It offers visual frame creation and "
"manipulation, an object inspector, many views on the source like object "
"browsers, inheritance hierarchies, doc string generated html documentation, "
"an advanced debugger, integrated help, and Zope support."
msgstr "`Boa Constructor <http://boa-constructor.sourceforge.net/>`_ ã¯ã€wxWidgets ã‚’ä½¿ã£ãŸ IDE ã¨ GUI ãƒ“ãƒ«ãƒ€ãƒ¼ã§ã™ã€‚ã“ã‚Œã¯è¦–è¦šãƒ•ãƒ¬ãƒ¼ãƒ ã®ä½œæˆã¨æ“ä½œã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ¤œæŸ»ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚ˆã†ãªå¤šãã®ãƒ“ãƒ¥ãƒ¼ã€ç¶™æ‰¿æ§‹é€ ã€doc string ã‹ã‚‰ç”Ÿæˆã•ã‚Œã‚‹ html ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€é«˜åº¦ãªãƒ‡ãƒãƒƒã‚¬ã€ç·åˆãƒ˜ãƒ«ãƒ—ã€Zope ã®ã‚µãƒãƒ¼ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../faq/programming.rst:41
msgid ""
"`Eric <http://eric-ide.python-projects.org/>`_ is an IDE built on PyQt and "
"the Scintilla editing component."
msgstr "`Eric <http://eric-ide.python-projects.org/>`_ ã¯ PyQt ã‚„ Scintilla editing component ã‚’ã‚‚ã¨ã«ã—ãŸ IDE ã§ã™ã€‚"

#: ../../faq/programming.rst:44
msgid ""
"Pydb is a version of the standard Python debugger pdb, modified for use with"
" DDD (Data Display Debugger), a popular graphical debugger front end.  Pydb "
"can be found at http://bashdb.sourceforge.net/pydb/ and DDD can be found at "
"https://www.gnu.org/software/ddd."
msgstr "Pydb ã¯æ¨™æº–ã®ãƒ‡ãƒãƒƒã‚¬ã§ã‚ã‚‹ pdb ã‚’äººæ°—ã®ã‚°ãƒ©ãƒ•ã‚£ã‚«ãƒ«ãƒ‡ãƒãƒƒã‚¬ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã§ã‚ã‚‹ DDD (Data Display Debugger) ã¨ã¨ã‚‚ã«ä½¿ã†ãŸã‚ã«æ”¹å¤‰ã—ãŸã‚‚ã®ã§ã™ã€‚Pydb ã¯ http://bashdb.sourceforge.net/pydb/ ã«ã€ DDD ã¯ https://www.gnu.org/software/ddd ã«ã‚ã‚Šã¾ã™ã€‚ "

#: ../../faq/programming.rst:49
msgid ""
"There are a number of commercial Python IDEs that include graphical "
"debuggers. They include:"
msgstr "å•†æ¥­ã®ã‚°ãƒ©ãƒ•ã‚£ã‚«ãƒ«ãƒ‡ãƒãƒƒã‚¬ä»˜ã Python IDE ã‚‚ã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°:"

#: ../../faq/programming.rst:52
msgid "Wing IDE (https://wingware.com/)"
msgstr "Wing IDE (https://wingware.com/)"

#: ../../faq/programming.rst:53
msgid "Komodo IDE (https://komodoide.com/)"
msgstr "Komodo IDE (https://komodoide.com/)"

#: ../../faq/programming.rst:54
msgid "PyCharm (https://www.jetbrains.com/pycharm/)"
msgstr "PyCharm (https://www.jetbrains.com/pycharm/)"

#: ../../faq/programming.rst:58
msgid "Is there a tool to help find bugs or perform static analysis?"
msgstr "ãƒã‚°ã®ç™ºè¦‹ã‚„é™çš„åˆ†æã«å½¹ç«‹ã¤ãƒ„ãƒ¼ãƒ«ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:62
msgid ""
"PyChecker is a static analysis tool that finds bugs in Python source code "
"and warns about code complexity and style.  You can get PyChecker from "
"http://pychecker.sourceforge.net/."
msgstr "PyChecker ã¯ Python ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®ãƒã‚°ã‚’ç™ºè¦‹ã—ã‚³ãƒ¼ãƒ‰ã®è¤‡é›‘ã•ã¨ã‚¹ã‚¿ã‚¤ãƒ«ã«ã¤ã„ã¦è­¦å‘Šã™ã‚‹é™çš„è§£æãƒ„ãƒ¼ãƒ«ã§ã™ã€‚PyChecker ã¯ http://pychecker.sourceforge.net/ ã‹ã‚‰æ‰‹ã«å…¥ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:66
msgid ""
"`Pylint <https://www.pylint.org/>`_ is another tool that checks if a module "
"satisfies a coding standard, and also makes it possible to write plug-ins to"
" add a custom feature.  In addition to the bug checking that PyChecker "
"performs, Pylint offers some additional features such as checking line "
"length, whether variable names are well-formed according to your coding "
"standard, whether declared interfaces are fully implemented, and more. "
"https://docs.pylint.org/ provides a full list of Pylint's features."
msgstr "`Pylint <https://www.pylint.org/>`_ ã‚‚ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æ¨™æº–ã‚’æº€ãŸã™ã‹ã‚’èª¿ã¹ã€ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’æ›¸ã„ã¦ã‚«ã‚¹ã‚¿ãƒ æ©Ÿèƒ½ã‚’åŠ ãˆã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚PyChecker ãŒè¡Œã†ãƒã‚°ãƒã‚§ãƒƒã‚¯ã«åŠ ãˆã€ Pylint ã¯è¡Œã®é•·ã•ã€å¤‰æ•°åãŒä¸€è²«ã—ã¦ã„ã‚‹ã‹ã€å®£è¨€ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ãŒå®Œå…¨ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹ã€ãªã©ã‚’ç¢ºã‹ã‚ã‚‹è¿½åŠ ã®æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚ https://docs.pylint.org/ ã§ Pylint ã®æ©Ÿèƒ½ã®ä¸€è¦§ã‚’è¦‹ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../faq/programming.rst:76
msgid "How can I create a stand-alone binary from a Python script?"
msgstr "ã©ã†ã—ãŸã‚‰ Python ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‹ã‚‰ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ãƒã‚¤ãƒŠãƒªã‚’ä½œã‚Œã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:78
msgid ""
"You don't need the ability to compile Python to C code if all you want is a "
"stand-alone program that users can download and run without having to "
"install the Python distribution first.  There are a number of tools that "
"determine the set of modules required by a program and bind these modules "
"together with a Python binary to produce a single executable."
msgstr "ãƒ¦ãƒ¼ã‚¶ãŒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚„èµ·å‹•ã®ãŸã‚ã« Python ãƒ‡ã‚£ã‚¹ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ãªãã¦ã‚‚ã‚ˆã„ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãŸã‚ã ã‘ãªã‚‰ã€Python ã‚’ C ã‚³ãƒ¼ãƒ‰ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«å¯¾ã—ã¦å¿…è¦ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’é¸ã³ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ Python ãƒã‚¤ãƒŠãƒªã«æŸç¸›ã—ã¦ä¸€ã¤ã®å®Ÿè¡Œå¯èƒ½ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¾ã¨ã‚ã‚‹å¤šãã®ãƒ„ãƒ¼ãƒ«ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:84
msgid ""
"One is to use the freeze tool, which is included in the Python source tree "
"as ``Tools/freeze``. It converts Python byte code to C arrays; a C compiler "
"you can embed all your modules into a new program, which is then linked with"
" the standard Python modules."
msgstr "ä¸€ã¤ã¯ freeze ãƒ„ãƒ¼ãƒ«ã§ã€Python ã‚½ãƒ¼ã‚¹ãƒ„ãƒªãƒ¼ã« ``Tools/freeze`` ã¨ã—ã¦å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯ Python ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã‚’ C é…åˆ—ã«å¤‰æ›ã—ã¾ã™ã€‚ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¨™æº– Python ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ãƒªãƒ³ã‚¯ã•ã‚Œã‚‹æ–°ã—ã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«åŸ‹ã‚è¾¼ã‚€ C ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã§ã™ã€‚"

#: ../../faq/programming.rst:89
msgid ""
"It works by scanning your source recursively for import statements (in both "
"forms) and looking for the modules in the standard Python path as well as in"
" the source directory (for built-in modules).  It then turns the bytecode "
"for modules written in Python into C code (array initializers that can be "
"turned into code objects using the marshal module) and creates a custom-made"
" config file that only contains those built-in modules which are actually "
"used in the program.  It then compiles the generated C code and links it "
"with the rest of the Python interpreter to form a self-contained binary "
"which acts exactly like your script."
msgstr "ã“ã‚Œã¯ã‚ãªãŸã®ã‚½ãƒ¼ã‚¹ã® (ä¸¡æ–¹ã®å½¢å¼ã®) import æ–‡ã‚’å†å¸°çš„ã«ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ã€import ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¨™æº–ã® Python ãƒ‘ã‚¹ã¨ (çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚ã‚‹) ã‚½ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰æ¢ã—ã¾ã™ã€‚ãã—ã¦ Python ã§æ›¸ã‹ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã‚’ C ã‚³ãƒ¼ãƒ‰ (marshal ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã§ãã‚‹é…åˆ—) ã«å¤‰æ›ã—ã€å®Ÿéš›ã«ãã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã ã‘ãŒå«ã¾ã‚ŒãŸã‚«ã‚¹ã‚¿ãƒ ãƒ¡ã‚¤ãƒ‰ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã™ã€‚ãã—ã¦ç”Ÿæˆã•ã‚ŒãŸ C ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¦ Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®æ®‹ã‚Šã¨ãƒªãƒ³ã‚¯ã—ã€å…ƒã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨å…¨ãåŒã˜ã‚ˆã†ã«å‹•ä½œã™ã‚‹è‡ªå·±å……è¶³çš„ãªãƒã‚¤ãƒŠãƒªã‚’å½¢æˆã—ã¾ã™ã€‚"

#: ../../faq/programming.rst:98
msgid ""
"Obviously, freeze requires a C compiler.  There are several other utilities "
"which don't. One is Thomas Heller's py2exe (Windows only) at"
msgstr "ã‚‚ã¡ã‚ã‚“ã€å‡çµã«ã¯ C ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒå¿…è¦ã§ã™ã€‚C ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚’å¿…è¦ã¨ã—ãªã„é¸æŠè‚¢ã‚‚ã‚ã‚Šã¾ã™ã€‚ãã®ä¸€ã¤ã¯ã€Thomas Heller ã® py2exe (Windows å°‚ç”¨) ã§ã™"

#: ../../faq/programming.rst:101
msgid "http://www.py2exe.org/"
msgstr "http://www.py2exe.org/"

#: ../../faq/programming.rst:103
msgid ""
"Another tool is Anthony Tuininga's `cx_Freeze <http://cx-"
"freeze.sourceforge.net/>`_."
msgstr "ä»–ã«ã¯ Anthony Tuininga ã® `cx_Freeze <http://cx-freeze.sourceforge.net/>`_ ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:107
msgid "Are there coding standards or a style guide for Python programs?"
msgstr "Python ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãŸã‚ã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ã‚„ã‚¹ã‚¿ã‚¤ãƒ«ã‚¬ã‚¤ãƒ‰ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:109
msgid ""
"Yes.  The coding style required for standard library modules is documented "
"as :pep:`8`."
msgstr "ã¯ã„ã€‚æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æ±‚ã‚ã‚‰ã‚Œã‚‹ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚¿ã‚¤ãƒ«ã¯ :pep:`8` ã¨ã—ã¦æ–‡æ›¸åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:114
msgid "My program is too slow. How do I speed it up?"
msgstr "ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒé…ã™ãã¾ã™ã€‚ã©ã†ã—ãŸã‚‰é€Ÿããªã‚Šã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:116
msgid ""
"That's a tough one, in general.  There are many tricks to speed up Python "
"code; consider rewriting parts in C as a last resort."
msgstr "ä¸€èˆ¬ã«ã€ãã‚Œã¯é›£ã—ã„è³ªå•ã§ã™ã€‚Python ã‚³ãƒ¼ãƒ‰ã‚’é€Ÿãã™ã‚‹ãŸã‚ã«ã¯ã€ã„ã‚ã„ã‚ãªæ‰‹æ³•ãŒã‚ã‚Šã¾ã™ã€‚æœ€çµ‚æ‰‹æ®µã¨ã—ã¦ä¸€éƒ¨ã‚’ C ã§æ›¸ãç›´ã™äº‹ã‚‚è€ƒãˆã¦ãã ã•ã„ã€‚"

#: ../../faq/programming.rst:119
msgid ""
"In some cases it's possible to automatically translate Python to C or x86 "
"assembly language, meaning that you don't have to modify your code to gain "
"increased speed."
msgstr "Python ã‚’è‡ªå‹•çš„ã« C ã‚„ x86 ã‚¢ã‚»ãƒ³ãƒ–ãƒªè¨€èªã«å¤‰æ›ã§ãã‚‹å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚ã“ã®å ´åˆã€é€Ÿåº¦ã‚’ä¸Šã’ã‚‹ãŸã‚ã«ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../faq/programming.rst:125
msgid ""
"`Pyrex <http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/>`_ can compile "
"a slightly modified version of Python code into a C extension, and can be "
"used on many different platforms."
msgstr "`Pyrex <http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/>`_ ã¯Python ã‚³ãƒ¼ãƒ‰ã®å°‘ã—å¤‰åŒ–ã—ãŸç‰ˆã‚’ C æ‹¡å¼µã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã€å¤šæ§˜ãªãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ä½¿ãˆã¾ã™ã€‚(è¨³æ³¨ï¼š Pyrex ã¯ `Cython <https://pypi.python.org/pypi/Cython/>`_ ã«å–ã£ã¦ä»£ã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚)"

#: ../../faq/programming.rst:129
msgid ""
"`Psyco <http://psyco.sourceforge.net>`_ is a just-in-time compiler that "
"translates Python code into x86 assembly language.  If you can use it, Psyco"
" can provide dramatic speedups for critical functions."
msgstr "`Psyco <http://psyco.sourceforge.net>`_ ã¯ Python ã‚³ãƒ¼ãƒ‰ã‚’ x86 ã‚¢ã‚»ãƒ³ãƒ–ãƒªè¨€èªã«å¤‰æ›ã™ã‚‹å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã§ã™ã€‚ã“ã‚Œã‚’ä½¿ã†ã“ã¨ãŒå‡ºæ¥ã‚Œã°ã€é‡è¦ãªé–¢æ•°ã‚’åŠ‡çš„ã«ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—ã§ãã¾ã™ã€‚"

#: ../../faq/programming.rst:133
msgid ""
"The rest of this answer will discuss various tricks for squeezing a bit more"
" speed out of Python code.  *Never* apply any optimization tricks unless you"
" know you need them, after profiling has indicated that a particular "
"function is the heavily executed hot spot in the code.  Optimizations almost"
" always make the code less clear, and you shouldn't pay the costs of reduced"
" clarity (increased development time, greater likelihood of bugs) unless the"
" resulting performance benefit is worth it."
msgstr "ã‚ã¨ã¯ã€Python ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã‚‚ã†å°‘ã—é€Ÿåº¦ã‚’æ¾ã‚Šå‡ºã™ãŸã‚ã®æ§˜ã€…ãªæ‰‹æ³•ã«ã¤ã„ã¦è­°è«–ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ä¸­ã®ç‰¹å®šã®é–¢æ•°ãŒå‡¦ç†ãŒé›†ä¸­ã™ã‚‹ãƒ›ãƒƒãƒˆã‚¹ãƒãƒƒãƒˆã§ã€æœ€é©åŒ–ãŒå¿…è¦ã§ã‚ã‚‹ã¨èªã‚ã‚‰ã‚Œãªã„é™ã‚Šã€\\ *æ±ºã—ã¦* ã„ã‹ãªã‚‹æœ€é©åŒ–ã®æ‰‹æ³•ã‚‚ä½¿ã‚ãªã„ã§ãã ã•ã„ã€‚æœ€é©åŒ–ã¯ãŸã„ã¦ã„ã‚³ãƒ¼ãƒ‰ã‚’åˆ†ã‹ã‚Šã¥ã‚‰ãã™ã‚‹ã®ã§ã€åˆ†ã‹ã‚Šã¥ã‚‰ã•ã®ã‚³ã‚¹ãƒˆ (é–‹ç™ºæ™‚é–“ã®å»¶é•·ã¨ãƒã‚°ã®å¯èƒ½æ€§ã®å¢—å¤§) ãŒãã‚Œã«è¦‹åˆã£ãŸãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®å‘ä¸Šã«ã¤ãªãŒã‚‰ãªã„ã®ã§ã‚ã‚Œã°å…ƒãŒå–ã‚Œã¾ã›ã‚“ã€‚"

#: ../../faq/programming.rst:141
msgid ""
"There is a page on the wiki devoted to `performance tips "
"<https://wiki.python.org/moin/PythonSpeed/PerformanceTips>`_."
msgstr "`performance tips <http://wiki.python.org/moin/PythonSpeed/PerformanceTips>`_ ã«é–¢ã™ã‚‹ãƒšãƒ¼ã‚¸ãŒ wiki ã«ã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:144
msgid ""
"Guido van Rossum has written up an anecdote related to optimization at "
"https://www.python.org/doc/essays/list2str."
msgstr "Guido van Rossum ã¯ https://www.python.org/doc/essays/list2str ã§æœ€é©åŒ–ã«é–¢ã™ã‚‹é€¸è©±ã‚’è©³è¿°ã—ã¦ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:147
msgid ""
"One thing to notice is that function and (especially) method calls are "
"rather expensive; if you have designed a purely OO interface with lots of "
"tiny functions that don't do much more than get or set an instance variable "
"or call another method, you might consider using a more direct way such as "
"directly accessing instance variables.  Also see the standard module "
":mod:`profile` which makes it possible to find out where your program is "
"spending most of its time (if you have some patience -- the profiling itself"
" can slow your program down by an order of magnitude)."
msgstr "ãªãŠã€é–¢æ•°ã‚„(ç‰¹ã«)ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ã¯ã‹ãªã‚Šé«˜ä¾¡ã§ã™ã€‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‚’ get ã‚„ set ã—ãŸã‚Šä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ç¨‹åº¦ã®å°ã•ãªé–¢æ•°ãŒãŸãã•ã‚“ã‚ã‚‹ç´”ç²‹ OO ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ãƒ‡ã‚¶ã‚¤ãƒ³ã—ã¦ã„ã‚‹ãªã‚‰ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã‚ˆã†ãªã‚‚ã£ã¨ç›´æ¥çš„ãªæ–¹æ³•ã‚‚è€ƒãˆã¦ã¿ã¦ãã ã•ã„ã€‚ã¾ãŸã€ã©ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå®Ÿè¡Œæ™‚é–“ã®å¤§éƒ¨åˆ†ã‚’å ã‚ã¦ã„ã‚‹ã‹ã‚’è¦‹ã¤ã‘ã‚‹æ¨™æº–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`profile` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ (ã¡ã‚‡ã£ã¨å¿è€ã§ãã‚Œã°ã®è©±ã§ã™ãŒ - ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°ã¯ãã‚Œè‡ªä½“ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä¸€æ¡ã»ã©é…ãã—ã¦ã—ã¾ã„ã¾ã™)ã€‚"

#: ../../faq/programming.rst:156
msgid ""
"Remember that many standard optimization heuristics you may know from other "
"programming experience may well apply to Python.  For example it may be "
"faster to send output to output devices using larger writes rather than "
"smaller ones in order to reduce the overhead of kernel system calls.  Thus "
"CGI scripts that write all output in \"one shot\" may be faster than those "
"that write lots of small pieces of output."
msgstr "ã‚‚ã¡ã‚ã‚“ã€ä»–ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®çµŒé¨“ã‹ã‚‰å¾—ã‚‰ã‚ŒãŸå¤šãã®æ¨™æº–çš„ãªæœ€é©åŒ–ã®ç™ºè¦‹çš„æ‰‹æ³•ã¯ Python ã«ã‚‚ã‚ˆãå½“ã¦ã¯ã¾ã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚ãŸã¨ãˆã°ã€å‡ºåŠ›è£…ç½®ã«å‡ºåŠ›ã‚’é€ã‚‹ã¨ãã«ã€ä¸€åº¦ã«å°‘ãªãæ›¸ãã‚ˆã‚Šã‚‚ã‚€ã—ã‚å¤šãæ›¸ã„ãŸã»ã†ãŒã€ã‚«ãƒ¼ãƒãƒ«ã®ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚’æ¸›ã‚‰ã™ã“ã¨ãŒã§ãã¦ã€é€Ÿããªã‚‹ã§ã—ã‚‡ã†ã€‚ã—ãŸãŒã£ã¦ã€CGI ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ \"ä¸€ç™º\" ã§ã™ã¹ã¦æ›¸ãå‡ºã™ã‚‚ã®ã®ã»ã†ãŒå°ã•ãªãŸãã•ã‚“ã®å‡ºåŠ›ã«åˆ†ã‘ã¦æ›¸ãå‡ºã™ã‚‚ã®ã‚ˆã‚Šã‚‚é€Ÿããªã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/programming.rst:163
msgid ""
"Also, be sure to use Python's core features where appropriate.  For example,"
" slicing allows programs to chop up lists and other sequence objects in a "
"single tick of the interpreter's mainloop using highly optimized C "
"implementations. Thus to get the same effect as::"
msgstr "ã¾ãŸã€å¿…ãš Python ã®ã‚³ã‚¢ãªæ©Ÿèƒ½ã‚’é©åˆ‡ã«ä½¿ã£ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°ã€ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ãªã‚‰ã€ãƒªã‚¹ãƒˆã‚„ä»–ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€é«˜åº¦ã«æœ€é©åŒ–ã•ã‚ŒãŸ C å®Ÿè£…ã§ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ã®ä¸€åˆ»ã¿ã§ç´°åˆ‡ã‚Œã«ã§ãã¾ã™ã€‚ã“ã†ã—ã¦åŠ¹æœã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã‚‹ä¾‹ã¯::"

#: ../../faq/programming.rst:172
msgid "it is much shorter and far faster to use ::"
msgstr "ã“ã†ä½¿ãˆã°ãšã£ã¨çŸ­ãã€ãšã£ã¨é€Ÿãã§ãã¾ã™::"

#: ../../faq/programming.rst:176
msgid ""
"Note that the functionally-oriented built-in functions such as :func:`map`, "
":func:`zip`, and friends can be a convenient accelerator for loops that "
"perform a single task.  For example to pair the elements of two lists "
"together::"
msgstr "é–¢æ•°æŒ‡å‘çµ„ã¿è¾¼ã¿é–¢æ•° :func:`map` ã‚„ :func:`zip` ãªã©ã‚‚ä¸€ã¤ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã®ãƒ«ãƒ¼ãƒ—ã‚’åŠ é€Ÿã™ã‚‹ã®ã«ä¾¿åˆ©ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°ã€äºŒã¤ã®ãƒªã‚¹ãƒˆã®è¦ç´ ã‚’çµ„ã¿åˆã‚ã›ã‚‹ãŸã‚ã«ã¯::"

#: ../../faq/programming.rst:184
msgid "or to compute a number of sines::"
msgstr "ã¾ãŸã€æ­£å¼¦ã‚’ä¸€åº¦ã«è¨ˆç®—ã™ã‚‹ã«ã¯::"

#: ../../faq/programming.rst:189
msgid "The operation completes very quickly in such cases."
msgstr "ã“ã®ã‚ˆã†ãªå ´åˆã«ã¯ç´ æ—©ãæ¼”ç®—ãŒå®Œäº†ã—ã¾ã™ã€‚"

#: ../../faq/programming.rst:191
msgid ""
"Other examples include the ``join()`` and ``split()`` :ref:`methods of "
"string objects <string-methods>`. For example if s1..s7 are large (10K+) "
"strings then ``\"\".join([s1,s2,s3,s4,s5,s6,s7])`` may be far faster than "
"the more obvious ``s1+s2+s3+s4+s5+s6+s7``, since the \"summation\" will "
"compute many subexpressions, whereas ``join()`` does all the copying in one "
"pass.  For manipulating strings, use the ``replace()`` and the ``format()`` "
":ref:`methods on string objects <string-methods>`.  Use regular expressions "
"only when you're not dealing with constant string patterns.  You may still "
"use :ref:`the old % operations <string-formatting>` ``string % tuple`` and "
"``string % dictionary``."
msgstr "ãã®ä»–ã®ä¾‹ã«ã¯ã€ :ref:`æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ <string-methods>` ``join()`` ã€ ``split()`` ãªã©ãŒæŒ™ã’ã‚‰ã‚Œã¾ã™ã€‚ä¾‹ãˆã° s1..s7 ãŒå¤§ããª (10K+) æ–‡å­—åˆ—ã®æ™‚ã€ ``\"\".join([s1,s2,s3,s4,s5,s6,s7])`` ã¯å˜ç´”ã« ``s1+s2+s3+s4+s5+s6+s7`` ã¨ã™ã‚‹ã‚ˆã‚Šã‚‚ã¯ã‚‹ã‹ã«é€Ÿããªã‚‹ã§ã—ã‚‡ã†ã€‚ãªãœãªã‚‰ã€ ``join()`` ã¯ã™ã¹ã¦ã®ã‚³ãƒ”ãƒ¼ã‚’ä¸€æ‹¬ã—ã¦è¡Œã†ã®ã«å¯¾ã—ã€ã€Œè¶³ã—ç®—ã€ãŒå¤šãã®å‰¯æ¼”ç®—ã‚’è¡Œã†ã‹ã‚‰ã§ã™ã€‚æ–‡å­—åˆ—ã‚’æ‰±ã†ã«ã¯ã€ :ref:`æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ <string-methods>` ``replace()`` ã€ ``format()``  ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚æ­£è¦è¡¨ç¾ã‚’ä½¿ã†ã®ã¯ã€æ±ºã¾ã£ãŸæ–‡å­—åˆ—ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã‚ãªã„æ™‚ã ã‘ã«ã—ã¦ãã ã•ã„ã€‚ :ref:`æ—§å¼ã® % æ¼”ç®— <string-formatting>` ``string % tuple`` ã¨ ``string % dictionary`` ã‚‚ä½¿ãˆã¾ã™ã€‚"

#: ../../faq/programming.rst:202
msgid ""
"Be sure to use the :meth:`list.sort` built-in method to do sorting, and see "
"the `sorting mini-HOWTO <https://wiki.python.org/moin/HowTo/Sorting>`_ for "
"examples of moderately advanced usage.  :meth:`list.sort` beats other "
"techniques for sorting in all but the most extreme circumstances."
msgstr "ã‚½ãƒ¼ãƒˆã«ã¯å¿…ãšãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`list.sort` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ã¾ãŸã€ `sorting mini-HOWTO <https://wiki.python.org/moin/HowTo/Sorting>`_ ã®å°‘ã—é«˜åº¦ãªä½¿ã„æ–¹ã®ä¾‹ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ :meth:`list.sort` ã¯ã€ã‚ˆã»ã©æ¥µç«¯ãªçŠ¶æ³ã§ãªã„é™ã‚Šã€ä»–ã®ã‚½ãƒ¼ãƒˆã®æŠ€è¡“ã«å‹ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:207
msgid ""
"Another common trick is to \"push loops into functions or methods.\"  For "
"example suppose you have a program that runs slowly and you use the profiler"
" to determine that a Python function ``ff()`` is being called lots of times."
"  If you notice that ``ff()``::"
msgstr "ã€Œãƒ«ãƒ¼ãƒ—ã‚’é–¢æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸­ã«å…¥ã‚Œè¾¼ã‚€ã€ã¨ã„ã†ã®ã‚‚ä¸€èˆ¬çš„ãªæ‰‹æ³•ã§ã™ã€‚ä¾‹ãˆã°ã€é…ã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚ã£ã¦ã€Python ã® ``ff()`` é–¢æ•°ãŒä½•åº¦ã‚‚å‘¼ã°ã‚Œã¦ã„ã‚‹ã“ã¨ãŒãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ©ã§åˆ†ã‹ã£ãŸã¨ã—ã¾ã™ã€‚ã“ã® ``ff()`` ::"

#: ../../faq/programming.rst:216
msgid "tends to be called in loops like::"
msgstr "ãŒã“ã®ã‚ˆã†ãªãƒ«ãƒ¼ãƒ—ã§å‘¼ã°ã‚Œã‚‹å‚¾å‘ãŒã‚ã‚‹æ°—ä»˜ã„ãŸã¨ã—ã¦::"

#: ../../faq/programming.rst:220
msgid "or::"
msgstr "ã‚‚ã—ãã¯::"

#: ../../faq/programming.rst:226
msgid ""
"then you can often eliminate function call overhead by rewriting ``ff()`` "
"to::"
msgstr "``ff()`` ã‚’æ›¸ãæ›ãˆã¦::"

#: ../../faq/programming.rst:235
msgid "and rewrite the two examples to ``list = ffseq(oldlist)`` and to::"
msgstr "ã¾ãŸã€ä¸Šã®äºŒã¤ã®ä¾‹ã‚’ã€ ``list = ffseq(oldlist)`` ã¨::"

#: ../../faq/programming.rst:240
msgid ""
"Single calls to ``ff(x)`` translate to ``ffseq([x])[0]`` with little "
"penalty. Of course this technique is not always appropriate and there are "
"other variants which you can figure out."
msgstr "ã®ã‚ˆã†ã«æ›¸ãæ›ãˆã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€é–¢æ•°ã‚’å‘¼ã¶ãŸã‚ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚’çœã‘ã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚``ff(x)`` ã‚’ä¸€å›ã ã‘å‘¼ã¶å ´åˆã€ ``ffseq([x])[0]`` ã«ç›´ã—ã¦ã—ã¾ã†ã¨ã¡ã‚‡ã£ã¨ä¸åˆ©ã«ãªã‚Šã¾ã™ã€‚ ã‚‚ã¡ã‚ã‚“ã€ã“ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ãŒã„ã¤ã§ã‚‚é©åˆ‡ã§ã‚ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã—ã€è§£æ±ºã®ãŸã‚ã®ä»–ã®æ–¹æ³•ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:244
msgid ""
"You can gain some performance by explicitly storing the results of a "
"function or method lookup into a local variable.  A loop like::"
msgstr "é–¢æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã®æ¢ç´¢ã®çµæœã‚’ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã«æ˜ç¤ºçš„ã«ä¿å­˜ã™ã‚‹ã¨å°‘ã—ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒè‰¯ããªã‚Šã¾ã™ã€‚æ¬¡ã®ã‚ˆã†ãªãƒ«ãƒ¼ãƒ—::"

#: ../../faq/programming.rst:250
msgid ""
"resolves ``dict.get`` every iteration.  If the method isn't going to change,"
" a slightly faster implementation is::"
msgstr "ã¯ã€ç¹°ã‚Šè¿”ã—ã®ãŸã³ã« ``dict.get`` ã‚’æ±‚ã‚ã¦ã„ã¾ã™ã€‚ ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¤‰ã‚ã‚‹ã“ã¨ãŒãªã„ã®ãªã‚‰ã€å°‘ã—é€Ÿã„å®Ÿè£…ã¯::"

#: ../../faq/programming.rst:257
msgid ""
"Default arguments can be used to determine values once, at compile time "
"instead of at run time.  This can only be done for functions or objects "
"which will not be changed during program execution, such as replacing ::"
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°ã¯ã€å®Ÿè¡Œæ™‚ã§ãªãã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å€¤ã‚’ä¸€å›ã§æ±ºã‚ã¦ã—ã¾ã†ã®ã«ä½¿ãˆã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡Œä¸­ã«å¤‰åŒ–ã—ãªã„é–¢æ•°ã‚„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ä¾‹ãˆã°::"

#: ../../faq/programming.rst:264
msgid "with ::"
msgstr "ã‚’ã€æ¬¡ã®ã‚ˆã†ã«ç½®ãæ›ãˆã‚‹ã¨ãã«ã®ã¿è¡Œãˆã¾ã™::"

#: ../../faq/programming.rst:269
msgid ""
"Because this trick uses default arguments for terms which should not be "
"changed, it should only be used when you are not concerned with presenting a"
" possibly confusing API to your users."
msgstr "ã“ã®æ‰‹æ³•ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°ãŒå¤‰ãˆã‚‰ã‚Œãªã„ã“ã¨ã‚’å‰æã«ä½¿ã†ã®ã§ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ API ã§æ··ä¹±ã™ã‚‹ãŠãã‚ŒãŒãªã„ã¨ãã®ã¿ä½¿ãˆã¾ã™ã€‚"

#: ../../faq/programming.rst:275
msgid "Core Language"
msgstr "ã‚³ã‚¢è¨€èª"

#: ../../faq/programming.rst:278
msgid "Why am I getting an UnboundLocalError when the variable has a value?"
msgstr "ãªãœå¤‰æ•°ã«å€¤ãŒã‚ã‚‹ã®ã« UnboundLocalError ãŒå‡ºã‚‹ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:280
msgid ""
"It can be a surprise to get the UnboundLocalError in previously working code"
" when it is modified by adding an assignment statement somewhere in the body"
" of a function."
msgstr "ã‚‚ã¨ã‚‚ã¨å‹•ã„ã¦ã„ãŸã‚³ãƒ¼ãƒ‰ãŒã€é–¢æ•°ã®æœ¬ä½“ã®ã©ã“ã‹ã«ä»£å…¥æ–‡ã‚’åŠ ãˆã‚‹ã¨ã„ã†å¤‰æ›´ã‚’ã—ãŸã‚‰ UnboundLocalError ã‚’å‡ºã™ã®ã«ã¯é©šãã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../faq/programming.rst:284
msgid "This code:"
msgstr "ã“ã®ã‚³ãƒ¼ãƒ‰:"

#: ../../faq/programming.rst:292
msgid "works, but this code:"
msgstr "ã¯å‹•ãã¾ã™ãŒã€ã“ã®ã‚³ãƒ¼ãƒ‰:"

#: ../../faq/programming.rst:299
msgid "results in an UnboundLocalError:"
msgstr "ã¯ UnboundLocalError ã«ãªã‚Šã¾ã™:"

#: ../../faq/programming.rst:306
msgid ""
"This is because when you make an assignment to a variable in a scope, that "
"variable becomes local to that scope and shadows any similarly named "
"variable in the outer scope.  Since the last statement in foo assigns a new "
"value to ``x``, the compiler recognizes it as a local variable.  "
"Consequently when the earlier ``print x`` attempts to print the "
"uninitialized local variable and an error results."
msgstr "ã“ã‚Œã¯ã€ã‚ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ã®ä¸­ã§å¤‰æ•°ã«ä»£å…¥ã‚’è¡Œã†ã¨ãã€ãã®å¤‰æ•°ã¯ãã®ã‚¹ã‚³ãƒ¼ãƒ—ã«å¯¾ã—ã¦ãƒ­ãƒ¼ã‚«ãƒ«ã«ãªã‚Šã€å¤–ã®ã‚¹ã‚³ãƒ¼ãƒ—ã«ã‚ã‚‹åŒã˜åå‰ã®å¤‰æ•°ã‚’éš ã™ã‹ã‚‰ã§ã™ã€‚ foo ã®æœ€å¾Œã®æ–‡ãŒ ``x`` ã«æ–°ã—ã„å€¤ã‚’ä»£å…¥ã—ã¦ã„ã‚‹ã®ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã“ã‚Œã‚’ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã§ã‚ã‚‹ã¨èªè­˜ã—ã¾ã™ã€‚ãã®çµæœã€å…ˆã® ``print x`` ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã‚’è¡¨ç¤ºã—ã‚ˆã†ã¨ã—ã¦çµæœã¯ã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:313
msgid ""
"In the example above you can access the outer scope variable by declaring it"
" global:"
msgstr "ä¸Šã®ä¾‹ã§ã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§ã‚ã‚‹ã¨å®£è¨€ã™ã‚‹ã“ã¨ã§å¤–ã®ã‚¹ã‚³ãƒ¼ãƒ—ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™:"

#: ../../faq/programming.rst:324
msgid ""
"This explicit declaration is required in order to remind you that (unlike "
"the superficially analogous situation with class and instance variables) you"
" are actually modifying the value of the variable in the outer scope:"
msgstr "ã“ã®æ˜ç¤ºçš„ãªå®£è¨€ã¯ (è¡¨é¢çš„ã«ã¯ä¼¼ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã®ä¾‹ã¨ã¯é•ã£ã¦) ã‚ãªãŸã¯å®Ÿéš›ã¯ä»–ã®ã‚¹ã‚³ãƒ¼ãƒ—ã®å¤‰æ•°ã®å€¤ã‚’å¤‰ãˆã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã‚’çŸ¥ã‚‰ã›ã‚‹ã®ã«å¿…è¦ã§ã™:"

#: ../../faq/programming.rst:333
msgid "What are the rules for local and global variables in Python?"
msgstr "Python ã®ãƒ­ãƒ¼ã‚«ãƒ«ã¨ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®ãƒ«ãƒ¼ãƒ«ã¯ä½•ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:335
msgid ""
"In Python, variables that are only referenced inside a function are "
"implicitly global.  If a variable is assigned a value anywhere within the "
"function's body, it's assumed to be a local unless explicitly declared as "
"global."
msgstr "Python ã§ã¯ã€é–¢æ•°ã®ä¸­ã§å‚ç…§ã®ã¿ã•ã‚Œã‚‹å¤‰æ•°ã¯æš—é»™ã®ã†ã¡ã«ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ãªã‚Šã¾ã™ã€‚é–¢æ•°ã®æœ¬ä½“ã®ã©ã“ã‹ã§å€¤ãŒå¤‰æ•°ã«ä»£å…¥ã•ã‚ŒãŸãªã‚‰ã€ãã‚Œã¯æ˜ç¤ºçš„ã«ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§ã‚ã‚‹ã¨å®£è¨€ã•ã‚Œãªã„é™ã‚Šã€ãƒ­ãƒ¼ã‚«ãƒ«ã§ã‚ã‚‹ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚"

#: ../../faq/programming.rst:339
msgid ""
"Though a bit surprising at first, a moment's consideration explains this.  "
"On one hand, requiring :keyword:`global` for assigned variables provides a "
"bar against unintended side-effects.  On the other hand, if ``global`` was "
"required for all global references, you'd be using ``global`` all the time."
"  You'd have to declare as global every reference to a built-in function or "
"to a component of an imported module.  This clutter would defeat the "
"usefulness of the ``global`` declaration for identifying side-effects."
msgstr "æœ€åˆã¯ã¡ã‚‡ã£ã¨é©šãã§ã—ã‚‡ã†ãŒã€å°‘ã—è€ƒãˆã‚‹ã¨ç´å¾—ã§ãã¾ã™ã€‚ä¸€æ–¹ã§ã¯ã€ä»£å…¥ã•ã‚ŒãŸå¤‰æ•°ã« :keyword:`global` ã‚’è¦æ±‚ã™ã‚‹ã“ã¨ã§ã€æ„å›³ã—ãªã„å‰¯ä½œç”¨ã‚’é˜²ã’ã¾ã™ã€‚ä»–æ–¹ã§ã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªå‚ç…§ã®åº¦ã« ``global`` ãŒè¦æ±‚ã•ã‚Œã¦ã—ã¾ã†ã¨ã€ ``global`` ã‚’ä½¿ã£ã¦ã°ã‹ã‚Šã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•°ã‚„ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†…å®¹ã‚’å‚ç…§ã™ã‚‹ãŸã³ã«ã‚°ãƒ­ãƒ¼ãƒãƒ«å®£è¨€ã‚’ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã§ã™ã€‚ãã®ä¹±é›‘ã•ã¯å‰¯ä½œç”¨ã‚’ç‰¹å®šã™ã‚‹ãŸã‚ã® ``global`` å®£è¨€ã®ä¾¿åˆ©ã•ã‚ˆã‚Šã‚‚é‡å¤§ã§ã™ã€‚"

#: ../../faq/programming.rst:349
msgid ""
"Why do lambdas defined in a loop with different values all return the same "
"result?"
msgstr "ãƒ«ãƒ¼ãƒ—ã®ä¸­ã§ç•°ãªã‚‹å€¤ã§å®šç¾©ã•ã‚ŒãŸãƒ©ãƒ ãƒ€å¼ãŒã€åŒã˜å€¤ã‚’è¿”ã™ã®ã¯ãªãœã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:351
msgid ""
"Assume you use a for loop to define a few different lambdas (or even plain "
"functions), e.g.::"
msgstr "for ãƒ«ãƒ¼ãƒ—ã‚’ä½¿ã£ã¦ã€å°‘ã—ãšã¤ç•°ãªã‚‹ãƒ©ãƒ ãƒ€ã‚’å®šç¾© (ã‚‚ã—ãã¯ç°¡å˜ãªé–¢æ•°) ã™ã‚‹ã¨ã—ã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../faq/programming.rst:358
msgid ""
"This gives you a list that contains 5 lambdas that calculate ``x**2``.  You "
"might expect that, when called, they would return, respectively, ``0``, "
"``1``, ``4``, ``9``, and ``16``.  However, when you actually try you will "
"see that they all return ``16``::"
msgstr "ã“ã‚Œã§ ``x**2`` ã‚’è¨ˆç®—ã™ã‚‹ 5 ã¤ã®ãƒ©ãƒ ãƒ€ã®ãƒªã‚¹ãƒˆãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚ãã‚Œã‚‰ã‚’å‘¼ã³å‡ºã—ãŸã¨ãã€ãã‚Œãã‚Œ ``0``ã€``1``ã€``4``ã€``9``ã€``16`` ã‚’è¿”ã™ã¨äºˆæƒ³ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã—ã‹ã—å®Ÿéš›ã«ã‚„ã£ã¦ã¿ã‚‹ã¨ã€å…¨ã¦ ``16`` ãŒè¿”ã£ã¦ãã‚‹ã®ã‚’ç›®ã«ã™ã‚‹ã§ã—ã‚‡ã†::"

#: ../../faq/programming.rst:368
msgid ""
"This happens because ``x`` is not local to the lambdas, but is defined in "
"the outer scope, and it is accessed when the lambda is called --- not when "
"it is defined.  At the end of the loop, the value of ``x`` is ``4``, so all "
"the functions now return ``4**2``, i.e. ``16``.  You can also verify this by"
" changing the value of ``x`` and see how the results of the lambdas change::"
msgstr "ã“ã‚Œã¯ã€``x`` ãŒãƒ©ãƒ ãƒ€ã«ã¨ã£ã¦ã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã§ã¯ãªãå¤–å´ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§å®šç¾©ã•ã‚Œã¦ã„ã¦ã€ãƒ©ãƒ ãƒ€ãŒå®šç¾©ã•ã‚ŒãŸã¨ãã§ãªãå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã«ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ãŸã‚ã«èµ·ã“ã‚Šã¾ã™ã€‚ãƒ«ãƒ¼ãƒ—ãŒçµ‚ã‚ã£ãŸæ™‚ç‚¹ã§ã¯ ``x`` ã¯ ``4`` ã§ã‚ã‚Šã€å¾“ã£ã¦ã€å…¨ã¦ã®é–¢æ•°ã¯ ``4**2`` ã¤ã¾ã‚Š ``16`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ã“ã¨ã¯ ``x`` ã®å€¤ã‚’å¤‰ãˆã¦ã¿ã‚‹ã“ã¨ã§æ¤œè¨¼ã§ãã€ãƒ©ãƒ ãƒ€ã®è¿”ã‚Šå€¤ãŒã©ã®ã‚ˆã†ã«å¤‰ã‚ã‚‹ã®ã‹è¦³å¯Ÿã§ãã¾ã™::"

#: ../../faq/programming.rst:378
msgid ""
"In order to avoid this, you need to save the values in variables local to "
"the lambdas, so that they don't rely on the value of the global ``x``::"
msgstr "ã“ã‚Œã‚’é¿ã‘ã‚‹ãŸã‚ã«ã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ã® ``x`` ã®å€¤ã«ä¾å­˜ã—ãªã„ãŸã‚ã«ã€ãƒ©ãƒ ãƒ€ã«ã¨ã£ã¦ã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã«å€¤ã‚’ä¿å­˜ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™::"

#: ../../faq/programming.rst:385
msgid ""
"Here, ``n=x`` creates a new variable ``n`` local to the lambda and computed "
"when the lambda is defined so that it has the same value that ``x`` had at "
"that point in the loop.  This means that the value of ``n`` will be ``0`` in"
" the first lambda, ``1`` in the second, ``2`` in the third, and so on. "
"Therefore each lambda will now return the correct result::"
msgstr "ã“ã“ã§ã€``n=x`` ã¯æ–°ã—ã„ãƒ©ãƒ ãƒ€ã«ã¨ã£ã¦ã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•° ``n`` ã‚’ä½œæˆã—ã€ãƒ©ãƒ ãƒ€ãŒå®šç¾©ã•ã‚Œã‚‹ã¨ãã«è¨ˆç®—ã•ã‚Œã‚‹ã®ã§ã€ãƒ«ãƒ¼ãƒ—ã®ãã®æ™‚ç‚¹ã§ã® ``x`` ã¨åŒã˜å€¤ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯ã€1 ã¤ç›®ã®ãƒ©ãƒ ãƒ€ã§ã¯ ``n`` ã®å€¤ã¯ ``0`` ã«ãªã‚Šã€2 ã¤ç›®ã§ã¯ ``1``ã€3 ã¤ç›®ã§ã¯ ``2`` ä»¥ä¸‹åŒæ§˜ã€ã¨ãªã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚å¾“ã£ã¦ã€ãã‚Œãã‚Œã®ãƒ©ãƒ ãƒ€ã¯ä»Šã‚„æ­£ã—ã„å€¤ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸ::"

#: ../../faq/programming.rst:396
msgid ""
"Note that this behaviour is not peculiar to lambdas, but applies to regular "
"functions too."
msgstr "ã“ã®å‹•ä½œã¯ãƒ©ãƒ ãƒ€ã«ç‰¹æœ‰ãªã‚‚ã®ã§ã¯ãªãã€é€šå¸¸ã®é–¢æ•°ã«ã‚‚é©ç”¨ã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/programming.rst:401
msgid "How do I share global variables across modules?"
msgstr "ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“ã§å…±æœ‰ã™ã‚‹ã«ã¯ã©ã†ã—ãŸã‚‰ã„ã„ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:403
msgid ""
"The canonical way to share information across modules within a single "
"program is to create a special module (often called config or cfg).  Just "
"import the config module in all modules of your application; the module then"
" becomes available as a global name.  Because there is only one instance of "
"each module, any changes made to the module object get reflected everywhere."
"  For example:"
msgstr "ä¸€ã¤ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“ã§æƒ…å ±ã‚’å…±æœ‰ã™ã‚‹æ­£æº–ãªæ–¹æ³•ã¯ã€ç‰¹åˆ¥ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (ã—ã°ã—ã° config ã‚„ cfg ã¨å‘¼ã°ã‚Œã‚‹) ã‚’ä½œã‚‹ã“ã¨ã§ã™ã€‚å˜ã«è¨­å®šãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ã¨ã—ã¦ä½¿ãˆã¾ã™ã€‚ãã‚Œãã‚Œã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãŸã ä¸€ã¤ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã‚ã‚‹ã®ã§ã€è¨­å®šãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ã„ã‹ãªã‚‹å¤‰æ›´ã‚‚å…¨ä½“ã«åæ˜ ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°:"

#: ../../faq/programming.rst:409
msgid "config.py::"
msgstr "config.py::"

#: ../../faq/programming.rst:413
msgid "mod.py::"
msgstr "mod.py::"

#: ../../faq/programming.rst:418
msgid "main.py::"
msgstr "main.py::"

#: ../../faq/programming.rst:424
msgid ""
"Note that using a module is also the basis for implementing the Singleton "
"design pattern, for the same reason."
msgstr "ãªãŠã€åŒã˜ç†ç”±ã‹ã‚‰ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã†ã¨ã„ã†ã“ã¨ã¯ã€ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã®åŸºç¤ã§ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:429
msgid "What are the \"best practices\" for using import in a module?"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ import ã‚’ä½¿ã†éš›ã®ã€Œãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã€ã¯ä½•ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:431
msgid ""
"In general, don't use ``from modulename import *``.  Doing so clutters the "
"importer's namespace, and makes it much harder for linters to detect "
"undefined names."
msgstr "ä¸€èˆ¬çš„ã« ``from modulename import *`` ã‚’ä½¿ã£ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚ãã®ã‚ˆã†ã«ã™ã‚‹ã¨ã‚¤ãƒ³ãƒãƒ¼ã‚¿ã®åå‰ç©ºé–“ã¯æ±šæŸ“ã•ã‚Œã€linter ãŒæœªå®šç¾©ã®åå‰ã‚’ç™ºè¦‹ã™ã‚‹ã“ã¨ãŒé›£ã—ããªã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:435
msgid ""
"Import modules at the top of a file.  Doing so makes it clear what other "
"modules your code requires and avoids questions of whether the module name "
"is in scope. Using one import per line makes it easy to add and delete "
"module imports, but using multiple imports per line uses less screen space."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã«ã‚ˆã£ã¦ã‚³ãƒ¼ãƒ‰ãŒå¿…è¦ã¨ã™ã‚‹ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæ˜ç¢ºã«ãªã‚Šã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åãŒã‚¹ã‚³ãƒ¼ãƒ—ã«å«ã¾ã‚Œã‚‹ã‹ã©ã†ã‹ã«è¿·ã‚ãªããªã‚Šã¾ã™ã€‚è¡Œã«ä¸€ã¤ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«ã™ã‚‹ã¨ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®è¿½åŠ ã¨å‰Šé™¤ãŒå®¹æ˜“ã«ãªã‚Šã¾ã™ãŒã€è¡Œã«è¤‡æ•°ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«ã™ã‚‹ã¨ç”»é¢ã®é ˜åŸŸãŒå°‘ãªãæ¸ˆã¿ã¾ã™ã€‚"

#: ../../faq/programming.rst:440
msgid "It's good practice if you import modules in the following order:"
msgstr "æ¬¡ã®æ‰‹é †ã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã®ãŒã€è‰¯ã„ãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«ãªã‚Šã¾ã™:"

#: ../../faq/programming.rst:442
msgid "standard library modules -- e.g. ``sys``, ``os``, ``getopt``, ``re``"
msgstr "æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« -- ä¾‹ ``sys``ã€``os``ã€``getopt``ã€``re``"

#: ../../faq/programming.rst:443
msgid ""
"third-party library modules (anything installed in Python's site-packages "
"directory) -- e.g. mx.DateTime, ZODB, PIL.Image, etc."
msgstr "ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (Python ã® site-packages ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã‚ã‚‹ã‚‚ã®) -- ä¾‹ mx.DateTimeã€ZODBã€PIL.Imageã€ãªã©"

#: ../../faq/programming.rst:445
msgid "locally-developed modules"
msgstr "è‡ªå‰ã§é–‹ç™ºã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../faq/programming.rst:447
msgid ""
"Only use explicit relative package imports.  If you're writing code that's "
"in the ``package.sub.m1`` module and want to import ``package.sub.m2``, do "
"not just write ``import m2``, even though it's legal.  Write ``from "
"package.sub import m2`` or ``from . import m2`` instead."
msgstr "æ˜ç¤ºçš„ãªç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã ã‘ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ ``package.sub.m1`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ã„ã¦ã€ ``package.sub.m2`` ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã‚ˆã†ã¨ã™ã‚‹ã¨ãã« ``import m2`` ã ã‘ã§æ¸ˆã¾ã›ã‚‹ã®ã¯ã‚„ã‚ã¦ãã ã•ã„ã€‚ãŸã¨ãˆãã‚ŒãŒåˆæ³•ã§ã‚‚ã€‚ä»£ã‚ã‚Šã« ``from package.sub import m2`` ã¾ãŸã¯ ``from . import m2`` ã¨æ›¸ã„ã¦ãã ã•ã„ã€‚"

#: ../../faq/programming.rst:452
msgid ""
"It is sometimes necessary to move imports to a function or class to avoid "
"problems with circular imports.  Gordon McMillan says:"
msgstr "å¾ªç’°å‚ç…§ã®å•é¡Œã‚’é¿ã‘ã‚‹ãŸã‚ã«ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’é–¢æ•°ã‚„ã‚¯ãƒ©ã‚¹ã«ç§»ã™ã“ã¨ãŒå¿…è¦ãªã¨ãã‚‚ã‚ã‚Šã¾ã™ã€‚Gordon McMillan ã«ã‚ˆã‚Œã°:"

#: ../../faq/programming.rst:455
msgid ""
"Circular imports are fine where both modules use the \"import <module>\" "
"form of import.  They fail when the 2nd module wants to grab a name out of "
"the first (\"from module import name\") and the import is at the top level."
"  That's because names in the 1st are not yet available, because the first "
"module is busy importing the 2nd."
msgstr "å¾ªç’°å‚ç…§ã¯ä¸¡æ–¹ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ \"import <module>\" å½¢å¼ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ä½¿ã£ã¦ã„ã‚Œã°å¤§ä¸ˆå¤«ã§ã™ã€‚äºŒã¤ç›®ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæœ€åˆã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰åå‰ã‚’ç¢ºä¿ã—ã‚ˆã†ã¨ã—ã¦ (\"from module import name\")ã€ãã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã«ã‚ã‚‹ã¨é§„ç›®ã§ã™ã€‚æœ€åˆã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒäºŒã¤ç›®ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã®ã«å¿™ã—ãã¦ã€æœ€åˆã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ãŒåˆ©ç”¨å¯èƒ½ã«ãªã£ã¦ã„ãªã„ã‹ã‚‰ã§ã™ã€‚"

#: ../../faq/programming.rst:461
msgid ""
"In this case, if the second module is only used in one function, then the "
"import can easily be moved into that function.  By the time the import is "
"called, the first module will have finished initializing, and the second "
"module can do its import."
msgstr "ã“ã®çŠ¶æ³ã§ã¯ã€äºŒã¤ç›®ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä¸€ã¤ã®é–¢æ•°ã®ä¸­ã§ã®ã¿ä½¿ã‚ã‚Œã¦ã„ã‚‹ãªã‚‰ã°ã€ãã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¯ç°¡å˜ã«é–¢æ•°ã®ä¸­ã«ç§»ã›ã¾ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒå‘¼ã°ã‚ŒãŸã¨ãã€æœ€åˆã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯åˆæœŸåŒ–ã‚’å®Œäº†ã—ã¦ã„ã¦ã€äºŒã¤ç›®ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯è‡ªåˆ†ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ã§ãã¾ã™ã€‚"

#: ../../faq/programming.rst:466
msgid ""
"It may also be necessary to move imports out of the top level of code if "
"some of the modules are platform-specific.  In that case, it may not even be"
" possible to import all of the modules at the top of the file.  In this "
"case, importing the correct modules in the corresponding platform-specific "
"code is a good option."
msgstr "ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚ã‚‹ã¨ãã«ã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®å¤–ã«å‹•ã‹ã™ã“ã¨ã‚‚å¿…è¦ã§ã™ã€‚ã“ã®å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã§ã¯ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã•ãˆã§ããªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã®å ´åˆã¯ã€å¯¾å¿œã™ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«åˆã‚ã›ãŸã‚³ãƒ¼ãƒ‰ã§æ­£ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã‚’é¸ã¶ã¨è‰¯ã„ã§ã™ã€‚"

#: ../../faq/programming.rst:471
msgid ""
"Only move imports into a local scope, such as inside a function definition, "
"if it's necessary to solve a problem such as avoiding a circular import or "
"are trying to reduce the initialization time of a module.  This technique is"
" especially helpful if many of the imports are unnecessary depending on how "
"the program executes.  You may also want to move imports into a function if "
"the modules are only ever used in that function.  Note that loading a module"
" the first time may be expensive because of the one time initialization of "
"the module, but loading a module multiple times is virtually free, costing "
"only a couple of dictionary lookups.  Even if the module name has gone out "
"of scope, the module is probably available in :data:`sys.modules`."
msgstr "å¾ªç’°å‚ç…§ã®å•é¡Œã‚’é¿ã‘ãŸã‚Šãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–ã«ã‹ã‹ã‚‹æ™‚é–“ã‚’æ¸›ã‚‰ã—ãŸã‚Šã—ãŸã„ãªã‚‰ã€å˜ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’é–¢æ•°å®šç¾©ã®ä¸­ãªã©ã®ãƒ­ãƒ¼ã‚«ãƒ«ãªã‚¹ã‚³ãƒ¼ãƒ—ã«ç§»ã—ã¦ãã ã•ã„ã€‚ã“ã®æ‰‹æ³•ã¯å¤šãã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã©ã®ã‚ˆã†ã«å®Ÿè¡Œã•ã‚Œã‚‹ã‹ã«ä¾å­˜ã—ãªãã¦ã‚ˆã„ã¨ãã«ç‰¹ã«æœ‰åŠ¹ã§ã™ã€‚ã‚ã‚‹é–¢æ•°ã®ä¸­ã§ã®ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä½¿ã‚ã‚Œã‚‹ã®ãªã‚‰ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ãã®é–¢æ•°ã®ä¸­ã«ç§»ã™ã“ã¨ã‚’è€ƒãˆã¦ã‚‚ã„ã„ã§ã—ã‚‡ã†ã€‚ãªãŠã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã‚€æœ€åˆã®å›ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–ã®æ™‚é–“ã®ãŸã‚ã«é«˜ä¾¡ã«ãªã‚Šãˆã¾ã™ãŒã€è¤‡æ•°å›ç›®ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã‚€ã®ã¯äº‹å®Ÿä¸Šç„¡æ–™ã€è¾æ›¸æ¢ç´¢ã®æ•°å›ã®ã‚³ã‚¹ãƒˆã ã‘ã§æ¸ˆã¿ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åãŒã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å¤–ã‚Œã¦ã•ãˆã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãŠãã‚‰ã :data:`sys.modules` ã‹ã‚‰åˆ©ç”¨ã§ãã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/programming.rst:484
msgid "Why are default values shared between objects?"
msgstr "ãªãœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé–“ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒå…±æœ‰ã•ã‚Œã‚‹ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:486
msgid ""
"This type of bug commonly bites neophyte programmers.  Consider this "
"function::"
msgstr "ã“ã®ç¨®ã®ãƒã‚°ãŒã‚ˆãåˆå¿ƒè€…ãƒ—ãƒ­ã‚°ãƒ©ãƒã«å™›ã¿ä»˜ãã¾ã™ã€‚ã“ã®é–¢æ•°ã‚’è€ƒãˆã¦ã¿ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:493
msgid ""
"The first time you call this function, ``mydict`` contains a single item.  "
"The second time, ``mydict`` contains two items because when ``foo()`` begins"
" executing, ``mydict`` starts out with an item already in it."
msgstr "åˆã‚ã¦ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ãŸæ™‚ã€``mydict`` ã«ã¯ä¸€ã¤ã®è¦ç´ ãŒã‚ã‚Šã¾ã™ã€‚äºŒå›ç›®ã«ã¯ã€``foo()`` ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ãã« ``mydict`` ã«ã¯åˆã‚ã‹ã‚‰ä¸€ã¤ã®è¦ç´ ã‚’ã™ã§ã«æŒã£ã¦ã„ã‚‹ã®ã§ã€``mydict`` ã«ã¯äºŒã¤ã®è¦ç´ ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:497
msgid ""
"It is often expected that a function call creates new objects for default "
"values. This is not what happens. Default values are created exactly once, "
"when the function is defined.  If that object is changed, like the "
"dictionary in this example, subsequent calls to the function will refer to "
"this changed object."
msgstr "é–¢æ•°ã®å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å€¤ã«å¯¾ã™ã‚‹æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œã‚‰ã‚Œã‚‹ã®ã ã¨äºˆæƒ³ã—ãŒã¡ã§ã™ã€‚å®Ÿã¯ãã†ãªã‚Šã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ã€é–¢æ•°ãŒå®šç¾©ã•ã‚ŒãŸã¨ãã«ä¸€åº¦ã ã‘ç”Ÿæˆã•ã‚Œã¾ã™ã€‚ã“ã®ä¾‹ã®è¾æ›¸ã®ã‚ˆã†ã«ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã€ãã®å¾Œã®é–¢æ•°ã®å‘¼ã³å‡ºã—ã¯å¤‰æ›´å¾Œã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã—ã¾ã™ã€‚"

#: ../../faq/programming.rst:502
msgid ""
"By definition, immutable objects such as numbers, strings, tuples, and "
"``None``, are safe from change. Changes to mutable objects such as "
"dictionaries, lists, and class instances can lead to confusion."
msgstr "å®šç¾©ã®æ™‚ã«ã€æ•°ã€æ–‡å­—åˆ—ã€ã‚¿ãƒ—ãƒ«ã€``None`` ãªã©ã€ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã†ã¨å¤‰æ›´ã•ã‚Œã‚‹å±é™ºãŒã‚ã‚Šã¾ã›ã‚“ã€‚è¾æ›¸ã€ãƒªã‚¹ãƒˆã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãªã©ã®ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ··ä¹±ã®ã‚‚ã¨ã§ã™ã€‚"

#: ../../faq/programming.rst:506
msgid ""
"Because of this feature, it is good programming practice to not use mutable "
"objects as default values.  Instead, use ``None`` as the default value and "
"inside the function, check if the parameter is ``None`` and create a new "
"list/dictionary/whatever if it is.  For example, don't write::"
msgstr "ã“ã®æ€§è³ªã‹ã‚‰ã€ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ã—ã¦ä½¿ã‚ãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æ‰‹æ³•ãŒã„ã„ã§ã™ã€‚ä»£ã‚ã‚Šã«ã€``None`` ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã«ä½¿ã„ã€ãã®ãƒ‘ãƒ©ãƒ¡ã‚¿ãŒ ``None`` ã§ã‚ã‚‹æ™‚ã«ã ã‘ã€é–¢æ•°ã®å†…éƒ¨ã§æ–°ã—ã„ãƒªã‚¹ãƒˆ/è¾æ›¸/ãã®ä»–ã‚’ã¤ãã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°ã€ã“ã†æ›¸ã‹ãšã«::"

#: ../../faq/programming.rst:514
msgid "but::"
msgstr "ä»£ã‚ã‚Šã«::"

#: ../../faq/programming.rst:520
msgid ""
"This feature can be useful.  When you have a function that's time-consuming "
"to compute, a common technique is to cache the parameters and the resulting "
"value of each call to the function, and return the cached value if the same "
"value is requested again.  This is called \"memoizing\", and can be "
"implemented like this::"
msgstr "ã“ã®æ€§è³ªãŒä¾¿åˆ©ãªã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚æ™‚é–“ã®ã‹ã‹ã‚‹è¨ˆç®—ã‚’è¡Œã†é–¢æ•°ãŒã‚ã‚‹ã¨ãã«ä½¿ã‚ã‚Œã‚‹ä¸€èˆ¬çš„ãªæŠ€æ³•ã¯ã€é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã”ã¨ã«ãƒ‘ãƒ©ãƒ¡ã‚¿ã¨çµæœã®å€¤ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã€å†ã³åŒã˜å€¤ãŒè¦æ±‚ã•ã‚ŒãŸã‚‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸå€¤ã‚’è¿”ã™ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚ã“ã‚Œã¯ \"memoizing\" ã¨å‘¼ã°ã‚Œã€ã“ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¾ã™::"

#: ../../faq/programming.rst:535
msgid ""
"You could use a global variable containing a dictionary instead of the "
"default value; it's a matter of taste."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®ä»£ã‚ã‚Šã«ã€è¾æ›¸ã‚’å«ã‚€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚‚ä½¿ãˆã¾ã™ã€‚ã“ã‚Œã¯å¥½ã¿ã®å•é¡Œã§ã™ã€‚"

#: ../../faq/programming.rst:540
msgid ""
"How can I pass optional or keyword parameters from one function to another?"
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é–¢æ•°ã‹ã‚‰é–¢æ•°ã¸æ¸¡ã™ã«ã¯ã©ã†ã—ãŸã‚‰ã„ã„ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:542
msgid ""
"Collect the arguments using the ``*`` and ``**`` specifiers in the "
"function's parameter list; this gives you the positional arguments as a "
"tuple and the keyword arguments as a dictionary.  You can then pass these "
"arguments when calling another function by using ``*`` and ``**``::"
msgstr "é–¢æ•°ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆã«å¼•æ•°ã‚’ ``*`` ã¨ ``**`` æŒ‡å®šå­ (specifier) ã§é›†ã‚ã¦ãã ã•ã„ã€‚ãã†ã™ã‚Œã°ã€å›ºå®šå¼•æ•°ã‚’ã‚¿ãƒ—ãƒ«ã¨ã—ã¦ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’è¾æ›¸ã¨ã—ã¦å¾—ã‚‰ã‚Œã¾ã™ã€‚ã“ã‚Œã§ã€ä»–ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã¨ãã« ``*`` ã¨ ``**`` ã‚’ä½¿ã£ã¦ãã‚Œã‚‰ã®å¼•æ•°ã‚’æ¸¡ã›ã¾ã™::"

#: ../../faq/programming.rst:553
msgid ""
"In the unlikely case that you care about Python versions older than 2.0, use"
" :func:`apply`::"
msgstr "ã‚ã¾ã‚Šã‚ã‚Šã¾ã›ã‚“ãŒã€Python ã® 2.0 ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è€ƒæ…®ã™ã‚‹ã¨ãã¯ã€ä»£ã‚ã‚Šã« :func:`apply` ã‚’ä½¿ã£ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:570
msgid "What is the difference between arguments and parameters?"
msgstr "å®Ÿå¼•æ•°ã¨ä»®å¼•æ•°ã®é•ã„ã¯ä½•ã§ã™ã‹?"

#: ../../faq/programming.rst:572
msgid ""
":term:`Parameters <parameter>` are defined by the names that appear in a "
"function definition, whereas :term:`arguments <argument>` are the values "
"actually passed to a function when calling it.  Parameters define what types"
" of arguments a function can accept.  For example, given the function "
"definition::"
msgstr ":term:`ä»®å¼•æ•° (parameter) <parameter>` ã¯é–¢æ•°å®šç¾©ã«è¡¨ã‚Œã‚‹åå‰ã§å®šç¾©ã•ã‚Œã‚‹ã®ã«å¯¾ã—ã€ :term:`å®Ÿå¼•æ•° (argument) <argument>` ã¯é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã¨ãã«å®Ÿéš›ã«æ¸¡ã™å€¤ã®ã“ã¨ã§ã™ã€‚ä»®å¼•æ•°ã¯é–¢æ•°ãŒå—ã‘å–ã‚‹ã“ã¨ã®å‡ºæ¥ã‚‹å®Ÿå¼•æ•°ã®å‹ã‚’å®šç¾©ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ãªé–¢æ•°å®šç¾©ãŒã‚ã£ãŸã¨ã—ã¦::"

#: ../../faq/programming.rst:580
msgid ""
"*foo*, *bar* and *kwargs* are parameters of ``func``.  However, when calling"
" ``func``, for example::"
msgstr "*foo*ã€*bar*ã€*kwargs* ã¯ ``func`` ã®ä»®å¼•æ•°ã§ã™ã€‚ä¸€æ–¹ã€``func`` ã‚’å‘¼ã³å‡ºã™ã¨ãã«ã¯ã€ä¾‹ãˆã°::"

#: ../../faq/programming.rst:585
msgid "the values ``42``, ``314``, and ``somevar`` are arguments."
msgstr "``42``ã€``314``ã€``somevar`` ã¨ã„ã†å€¤ã¯å®Ÿå¼•æ•°ã§ã™ã€‚"

#: ../../faq/programming.rst:589
msgid "Why did changing list 'y' also change list 'x'?"
msgstr "ãªãœ list 'y' ã‚’å¤‰æ›´ã™ã‚‹ã¨ list 'x' ã‚‚å¤‰æ›´ã•ã‚Œã‚‹ã®ã§ã™ã‹?"

#: ../../faq/programming.rst:591
msgid "If you wrote code like::"
msgstr "æ¬¡ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ãŸã¨ã—ã¾ã™::"

#: ../../faq/programming.rst:601
msgid ""
"you might be wondering why appending an element to ``y`` changed ``x`` too."
msgstr "ã©ã†ã—ã¦ ``y`` ã¸ã®è¦ç´ ã®è¿½åŠ ãŒ ``x`` ã‚‚å¤‰æ›´ã—ã¦ã—ã¾ã†ã®ã‹ç–‘å•ã«æ€ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ "

#: ../../faq/programming.rst:603
msgid "There are two factors that produce this result:"
msgstr "ã“ã®ã‚ˆã†ãªçµæœã«ãªã‚‹2ã¤ã®è¦å› ãŒã‚ã‚Šã¾ã™:"

#: ../../faq/programming.rst:605
msgid ""
"Variables are simply names that refer to objects.  Doing ``y = x`` doesn't "
"create a copy of the list -- it creates a new variable ``y`` that refers to "
"the same object ``x`` refers to.  This means that there is only one object "
"(the list), and both ``x`` and ``y`` refer to it."
msgstr "å¤‰æ•°ã¨ã¯ã€å˜ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã™ã‚‹ãŸã‚ã®åå‰ã«éãã¾ã›ã‚“ã€‚ ``y = x`` ã¨ã™ã‚‹ã“ã¨ã¯ã€ãƒªã‚¹ãƒˆã®ã‚³ãƒ”ãƒ¼ã‚’ä½œã‚Šã¾ã›ã‚“ -- ãã‚Œã¯ ``x`` ãŒå‚ç…§ã™ã‚‹ã®ã¨åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã™ã‚‹æ–°ã—ã„å¤‰æ•° ``y`` ã‚’ä½œã‚Šã¾ã™ã€‚ã¤ã¾ã‚Šã€ã‚ã‚‹ã®ã¯ä¸€ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ(ã“ã®å ´åˆãƒªã‚¹ãƒˆ)ã ã‘ã§ã‚ã£ã¦ã€ ``x`` ã¨ ``y`` ã®ä¸¡æ–¹ãŒãã‚Œã‚’å‚ç…§ã—ã¦ã„ã‚‹ã®ã§ã™ã€‚"

#: ../../faq/programming.rst:609
msgid ""
"Lists are :term:`mutable`, which means that you can change their content."
msgstr "ãƒªã‚¹ãƒˆã¯ :term:`mutable` ã§ã™ã€‚å†…å®¹ã‚’å¤‰æ›´å‡ºæ¥ã‚‹ã€ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../faq/programming.rst:611
msgid ""
"After the call to :meth:`~list.append`, the content of the mutable object "
"has changed from ``[]`` to ``[10]``.  Since both the variables refer to the "
"same object, using either name accesses the modified value ``[10]``."
msgstr ":meth:`~list.append` å‘¼ã³å‡ºã—ã®å¾Œã€ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…å®¹ãŒ ``[]`` ã‹ã‚‰ ``[10]`` ã«å¤‰ã‚ã‚Šã¾ã™ã€‚ å¤‰æ•°ãŒåŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã—ã¦ã„ã‚‹ã®ã§ã€ã©ã¡ã‚‰ã®åå‰ã§ã‚ã£ã¦ã‚‚å¤‰æ›´ã•ã‚ŒãŸå€¤ ``[10]`` ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚"

#: ../../faq/programming.rst:615
msgid "If we instead assign an immutable object to ``x``::"
msgstr "ä»£ã‚ã‚Šã« ``x`` ã«ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã‚’ä»£å…¥ã™ã‚‹ã¨::"

#: ../../faq/programming.rst:625
msgid ""
"we can see that in this case ``x`` and ``y`` are not equal anymore.  This is"
" because integers are :term:`immutable`, and when we do ``x = x + 1`` we are"
" not mutating the int ``5`` by incrementing its value; instead, we are "
"creating a new object (the int ``6``) and assigning it to ``x`` (that is, "
"changing which object ``x`` refers to).  After this assignment we have two "
"objects (the ints ``6`` and ``5``) and two variables that refer to them "
"(``x`` now refers to ``6`` but ``y`` still refers to ``5``)."
msgstr "ã“ã®å ´åˆã”è¦§ã®é€šã‚Š ``x`` ã¨ ``y`` ã¯ã¾ã£ãŸãåŒã˜ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã­ã€‚ã“ã‚Œã¯æ•´æ•°ãŒ :term:`immutable` ã ã‹ã‚‰ã§ã€ ``x = x + 1`` ã¯æ•´æ•°ã® ``5`` ã®å€¤ã‚’å¤‰æ›´ã—ã¦ã„ã‚‹ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“; ä»£ã‚ã‚Šã«æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ(æ•´æ•° ``6``)ã‚’ä½œã£ã¦ ``x`` ã«ä»£å…¥ã—ã¦ã„ã¾ã™ (ã¤ã¾ã‚Š ``x`` ãŒå‚ç…§ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¤‰ã‚ã‚Šã¾ã™)ã€‚ã“ã®ä»£å…¥ã®å¾Œã§ã¯ç§ãŸã¡ã¯ 2 ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ(æ•´æ•°ã® ``6`` ã¨ ``5``)ã‚’æŒã£ã¦ã„ã¦ã€2 ã¤ã®å¤‰æ•°ã¯ãã‚Œã‚‰ã‚’å‚ç…§ã—ã¦ã„ã¾ã™(``x`` ã¯ã„ã¾ã‚„ ``6`` ã‚’å‚ç…§ã—ã¦ã„ã¾ã™ãŒ ``y`` ã¯ ``5`` ã‚’å‚ç…§ã—ãŸã¾ã¾ã§ã™)ã€‚"

#: ../../faq/programming.rst:633
msgid ""
"Some operations (for example ``y.append(10)`` and ``y.sort()``) mutate the "
"object, whereas superficially similar operations (for example ``y = y + "
"[10]`` and ``sorted(y)``) create a new object.  In general in Python (and in"
" all cases in the standard library) a method that mutates an object will "
"return ``None`` to help avoid getting the two types of operations confused."
"  So if you mistakenly write ``y.sort()`` thinking it will give you a sorted"
" copy of ``y``, you'll instead end up with ``None``, which will likely cause"
" your program to generate an easily diagnosed error."
msgstr "ã‚ã‚‹æ¼”ç®— (ãŸã¨ãˆã° ``y.append(10)``, ``y.sort()``) ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¤‰æ›´ã™ã‚‹ä¸€æ–¹ã§ã€å¤–è¦‹ä¸Šã¯ä¼¼ãŸæ¼”ç®— (ãŸã¨ãˆã° ``y = y + [10]``, ``sorted(y)``) ã¯æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚Šã¾ã™ã€‚Python ã§ã¯ä¸€èˆ¬ã« (ãã—ã¦æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å…¨ã¦ã®ã‚±ãƒ¼ã‚¹ã§)ã€ã“ã®ã‚ˆã†ãª 2 ã¤ã®ã‚¿ã‚¤ãƒ—ã®æ¼”ç®—ã«ã¾ã¤ã‚ã‚‹æ··ä¹±ã‚’é¿ã‘ã‚‹ãŸã‚ã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¤‰æ›´ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã¯ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ã§ã™ã‹ã‚‰ã‚‚ã—ã‚ãªãŸãŒèª¤ã£ã¦ ``y`` ã®è¤‡è£½ã®ä¸¦ã³æ›¿ãˆã‚’ã™ã‚‹ã¤ã‚‚ã‚Šã§ ``y.sort()`` ã¨æ›¸ã„ãŸå ´åˆã«çµæœæ‰‹ã«ã™ã‚‹ã®ã¯ ``None`` ã§ã—ã‚‡ã†ã‹ã‚‰ã€ã‚ãªãŸã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ç°¡å˜ã«è¨ºæ–­å‡ºæ¥ã‚‹ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã™ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/programming.rst:642
msgid ""
"However, there is one class of operations where the same operation sometimes"
" has different behaviors with different types:  the augmented assignment "
"operators.  For example, ``+=`` mutates lists but not tuples or ints "
"(``a_list += [1, 2, 3]`` is equivalent to ``a_list.extend([1, 2, 3])`` and "
"mutates ``a_list``, whereas ``some_tuple += (1, 2, 3)`` and ``some_int += "
"1`` create new objects)."
msgstr "ã—ã‹ã—ãªãŒã‚‰ã€åŒã˜æ“ä½œãŒå‹ã”ã¨ã«ç•°ãªã‚‹æŒ¯ã‚‹èˆã„ã‚’ã™ã‚‹æ¼”ç®—ã®ç¨®é¡ãŒä¸€ã¤ã‚ã‚Šã¾ã™: ç´¯ç®—ä»£å…¥æ¼”ç®—ã§ã™ã€‚ä¾‹ãˆã° ``+=`` ã¯ãƒªã‚¹ãƒˆã‚’å¤‰æ›´ã—ã¾ã™ãŒã€ã‚¿ãƒ—ãƒ«ã‚„æ•´æ•°ã¯å¤‰æ›´ã—ã¾ã›ã‚“(``a_list += [1, 2, 3]`` ã¯ ``a_list.extend([1, 2, 3])`` ã¨åŒã˜æ„å‘³ã§ã€ãã—ã¦ ``a_list`` ã‚’å¤‰æ›´ã—ã¾ã™ãŒã€ ``some_tuple += (1, 2, 3)`` ã¨ ``some_int += 1`` ã¯æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚Šã¾ã™)ã€‚"

#: ../../faq/programming.rst:649
msgid "In other words:"
msgstr "è¨€ã„æ›ãˆã‚‹ã¨:"

#: ../../faq/programming.rst:651
msgid ""
"If we have a mutable object (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), we can use some specific operations to mutate it and all the "
"variables that refer to it will see the change."
msgstr "ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ(:class:`list`, :class:`dict`, :class:`set`, ç­‰)ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã€ç§ãŸã¡ã¯ãã®å†…å®¹ã‚’å¤‰æ›´ã™ã‚‹ã‚ã‚‹ç¨®ã®æ¼”ç®—ã‚’ä½¿ã†ã“ã¨ãŒå‡ºæ¥ã€ãã‚Œã‚’å‚ç…§ã—ã¦ã„ã‚‹å…¨ã¦ã®å¤‰æ•°ã¯ãã®å¤‰åŒ–ã‚’è¦‹ã‚‹ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/programming.rst:654
msgid ""
"If we have an immutable object (:class:`str`, :class:`int`, :class:`tuple`, "
"etc.), all the variables that refer to it will always see the same value, "
"but operations that transform that value into a new value always return a "
"new object."
msgstr "ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ(:class:`str`, :class:`int`, :class:`tuple`, ç­‰)ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã€ãã‚Œã‚’å‚ç…§ã—ã¦ã„ã‚‹å…¨ã¦ã®å¤‰æ•°ã¯åŒã˜å€¤ã‚’å‚ç…§ã—ã¦ã„ã‚‹ã§ã—ã‚‡ã†ãŒã€æŒã£ã¦ã„ã‚‹å€¤ã‚’æ–°ã—ã„å€¤ã«å¤‰æ›ã™ã‚‹æ¼”ç®—ã¯ã„ã¤ã§ã‚‚æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../faq/programming.rst:659
msgid ""
"If you want to know if two variables refer to the same object or not, you "
"can use the :keyword:`is` operator, or the built-in function :func:`id`."
msgstr "2ã¤ã®å¤‰æ•°ãŒåŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ãŒçŸ¥ã‚ŠãŸã‘ã‚Œã°ã€ :keyword:`is` ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ã¾ãŸã¯çµ„ã¿è¾¼ã¿é–¢æ•° :func:`id` ãŒä½¿ãˆã¾ã™ã€‚"

#: ../../faq/programming.rst:664
msgid "How do I write a function with output parameters (call by reference)?"
msgstr "ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å‡ºåŠ›ã™ã‚‹é–¢æ•° (å‚ç…§æ¸¡ã—) ã¯ã©ã®ã‚ˆã†ã«æ›¸ãã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:666
msgid ""
"Remember that arguments are passed by assignment in Python.  Since "
"assignment just creates references to objects, there's no alias between an "
"argument name in the caller and callee, and so no call-by-reference per se."
"  You can achieve the desired effect in a number of ways."
msgstr "å‰æã¨ã—ã¦ã€Python ã§ã¯å¼•æ•°ã¯ä»£å…¥ã«ã‚ˆã£ã¦æ¸¡ã•ã‚Œã¾ã™ã€‚ä»£å…¥ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’ä½œã‚‹ã ã‘ãªã®ã§ã€å‘¼ã³å‡ºã—å…ƒã¨å‘¼ã³å‡ºã—å…ˆã«ã‚ã‚‹å¼•æ•°åã®é–“ã«ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã¯ã‚ã‚Šã¾ã›ã‚“ã—ã€å‚ç…§æ¸¡ã—ãã‚Œè‡ªä½“ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æœ›ã‚€åŠ¹æœã‚’å¾—ã‚‹ãŸã‚ã«ã¯å¹¾ã¤ã‹ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:671
msgid "By returning a tuple of the results::"
msgstr "çµæœã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã™ã“ã¨ã«ã‚ˆã£ã¦::"

#: ../../faq/programming.rst:682
msgid "This is almost always the clearest solution."
msgstr "ã“ã‚Œã¯ãŸã„ã¦ã„ä¸€ç•ªæ˜ç¢ºãªæ–¹æ³•ã§ã™ã€‚"

#: ../../faq/programming.rst:684
msgid ""
"By using global variables.  This isn't thread-safe, and is not recommended."
msgstr "ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’ä½¿ã£ã¦ã€‚ã“ã‚Œã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ãªã„ã®ã§ã€æ¨å¥¨ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../faq/programming.rst:686
msgid "By passing a mutable (changeable in-place) object::"
msgstr "ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãª (ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã«å¤‰æ›´å¯èƒ½ãª) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã™ã“ã¨ã«ã‚ˆã£ã¦::"

#: ../../faq/programming.rst:696
msgid "By passing in a dictionary that gets mutated::"
msgstr "å¤‰æ›´ã•ã‚Œã‚‹è¾æ›¸ã«æ¸¡ã™ã“ã¨ã«ã‚ˆã£ã¦::"

#: ../../faq/programming.rst:706
msgid "Or bundle up values in a class instance::"
msgstr "ã¾ãŸã¯ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å€¤ã‚’åŒæ¢±ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦::"

#: ../../faq/programming.rst:722
msgid "There's almost never a good reason to get this complicated."
msgstr "ã“ã®ã‚ˆã†ãªè¤‡é›‘ãªã“ã¨ã‚’ã™ã‚‹ç†ç”±ã¯ã‚ã£ãŸã«ç„¡ã„ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/programming.rst:724
msgid "Your best choice is to return a tuple containing the multiple results."
msgstr "ä¸€ç•ªã®é¸æŠã¯ã€è¤‡æ•°ã®çµæœã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã‚’è¿”ã™ã“ã¨ã§ã™ã€‚"

#: ../../faq/programming.rst:728
msgid "How do you make a higher order function in Python?"
msgstr "Python ã§é«˜æ¬¡é–¢æ•°ã¯ã©ã®ã‚ˆã†ã«ã¤ãã‚Šã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:730
msgid ""
"You have two choices: you can use nested scopes or you can use callable "
"objects. For example, suppose you wanted to define ``linear(a,b)`` which "
"returns a function ``f(x)`` that computes the value ``a*x+b``.  Using nested"
" scopes::"
msgstr "äºŒã¤ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™: ãƒã‚¹ãƒˆã•ã‚ŒãŸã‚¹ã‚³ãƒ¼ãƒ—ã‚’ä½¿ã†æ–¹æ³•ã¨ã€å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã†æ–¹æ³•ã§ã™ã€‚ä¾‹ãˆã°ã€``a*x+b`` ã®å€¤ã‚’è¨ˆç®—ã™ã‚‹ ``f(x)`` é–¢æ•°ã‚’è¿”ã™ ``linear(a,b)`` ã‚’å®šç¾©ã—ãŸã„ã¨ã—ã¾ã™ã€‚ãƒã‚¹ãƒˆã•ã‚ŒãŸã‚¹ã‚³ãƒ¼ãƒ—ã‚’ä½¿ã†ã¨::"

#: ../../faq/programming.rst:739
msgid "Or using a callable object::"
msgstr "ã¾ãŸã€å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã†ã¨::"

#: ../../faq/programming.rst:749
msgid "In both cases, ::"
msgstr "ã©ã¡ã‚‰ã®å ´åˆã§ã‚‚ã€ ::"

#: ../../faq/programming.rst:753
msgid "gives a callable object where ``taxes(10e6) == 0.3 * 10e6 + 2``."
msgstr "ã¨ã™ã‚Œã°ã€``taxes(10e6) == 0.3 * 10e6 + 2`` ã¨ãªã‚‹ã‚ˆã†ãªå‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¾—ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../faq/programming.rst:755
msgid ""
"The callable object approach has the disadvantage that it is a bit slower "
"and results in slightly longer code.  However, note that a collection of "
"callables can share their signature via inheritance::"
msgstr "å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã†æ–¹æ³•ã¯ã€å°‘ã—é…ããªã‚Šã€ã‚ãšã‹ã«ã‚³ãƒ¼ãƒ‰ãŒé•·ããªã‚‹ã¨ã„ã†çŸ­æ‰€ãŒã‚ã‚Šã¾ã™ã€‚ã§ã™ãŒã€ç¶™æ‰¿ã‚’ä½¿ã£ã¦ã‚³ãƒ¼ãƒ©ãƒ–ãƒ«åŒå£«ã§è¨˜å·ã‚’å…±æœ‰ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™::"

#: ../../faq/programming.rst:764
msgid "Object can encapsulate state for several methods::"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã„ãã¤ã‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«çŠ¶æ…‹ã‚’ã‚«ãƒ—ã‚»ãƒ«åŒ–ã§ãã¾ã™::"

#: ../../faq/programming.rst:782
msgid ""
"Here ``inc()``, ``dec()`` and ``reset()`` act like functions which share the"
" same counting variable."
msgstr "ã“ã“ã§ã€``inc()``ã€``dec()``ã€``reset()`` ã¯åŒã˜ã‚«ã‚¦ãƒ³ãƒˆå¤‰æ•°ã‚’å…±æœ‰ã™ã‚‹é–¢æ•°ã®ã‚ˆã†ã«ãµã‚‹ã¾ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:787
msgid "How do I copy an object in Python?"
msgstr "Python ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã©ã®ã‚ˆã†ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:789
msgid ""
"In general, try :func:`copy.copy` or :func:`copy.deepcopy` for the general "
"case. Not all objects can be copied, but most can."
msgstr "ä¸€èˆ¬çš„ã«ã€æ™®é€šã¯ :func:`copy.copy` ã‚„ :func:`copy.deepcopy` ã‚’è©¦ã—ã¦ãã ã•ã„ã€‚ä½•ã§ã‚‚ã‚³ãƒ”ãƒ¼ã§ãã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ãŒã€ãŸã„ã¦ã„ã¯ã§ãã¾ã™ã€‚"

#: ../../faq/programming.rst:792
msgid ""
"Some objects can be copied more easily.  Dictionaries have a "
":meth:`~dict.copy` method::"
msgstr "ã‚‚ã£ã¨ç°¡å˜ã«ã‚³ãƒ”ãƒ¼ã§ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ã‚ã‚Šã¾ã™ã€‚è¾æ›¸ã«ã¯ :meth:`~dict.copy` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™::"

#: ../../faq/programming.rst:797
msgid "Sequences can be copied by slicing::"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ã§ã‚³ãƒ”ãƒ¼ã§ãã¾ã™::"

#: ../../faq/programming.rst:803
msgid "How can I find the methods or attributes of an object?"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚„å±æ€§ã¯ã©ã®ã‚ˆã†ã«è¦‹ã¤ã‘ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:805
msgid ""
"For an instance x of a user-defined class, ``dir(x)`` returns an "
"alphabetized list of the names containing the instance attributes and "
"methods and attributes defined by its class."
msgstr "ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ x ã§ã€``dir(x)`` ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã¨ãã®ã‚¯ãƒ©ã‚¹ã§å®šç¾©ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã‚„å±æ€§ã‚’å«ã‚€åå‰ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆé †ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../faq/programming.rst:811
msgid "How can my code discover the name of an object?"
msgstr "ã‚³ãƒ¼ãƒ‰ã¯ã©ã®ã‚ˆã†ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åå‰ã‚’è¦‹ã¤ã‘ã‚‹ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:813
msgid ""
"Generally speaking, it can't, because objects don't really have names. "
"Essentially, assignment always binds a name to a value; The same is true of "
"``def`` and ``class`` statements, but in that case the value is a callable. "
"Consider the following code::"
msgstr "æ¦‚ã—ã¦ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æœ¬å½“ã¯åå‰ã‚’æŒãŸãªã„ã®ã§ã€è¦‹ã¤ã‘ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚æœ¬è³ªçš„ã«ã¯ã€ä»£å…¥ã¨ã¯ã„ã¤ã‚‚å€¤ã«åå‰ã‚’æŸç¸›ã™ã‚‹ã“ã¨ã§ã™ã€‚``def`` ã¨ ``class`` æ–‡ã‚‚åŒã˜ã§ã™ãŒã€ã“ã®å ´åˆã¯å€¤ã¯ã‚³ãƒ¼ãƒ©ãƒ–ãƒ«ã§ã™ã€‚ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†::"

#: ../../faq/programming.rst:829
msgid ""
"Arguably the class has a name: even though it is bound to two names and "
"invoked through the name B the created instance is still reported as an "
"instance of class A.  However, it is impossible to say whether the "
"instance's name is a or b, since both names are bound to the same value."
msgstr "ãŠãã‚‰ãã€ã“ã®ã‚¯ãƒ©ã‚¹ã«ã¯åå‰ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯äºŒã¤ã®åå‰ã«ç¸›ã‚‰ã‚Œã¦ã€åå‰ B ã‚’é€šã—ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ãŒã€ãã‚Œã§ã‚‚ã‚¯ãƒ©ã‚¹ A ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã—ã¦å ±å‘Šã•ã‚Œã‚‹ã®ã§ã™ã€‚ã—ã‹ã—ã€ä¸¡æ–¹ã®åå‰ãŒåŒã˜å€¤ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ä»¥ä¸Šã€ã“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®åå‰ãŒ a ã‹ b ã‹æ±ºã‚ã‚‹ã“ã¨ã¯ã§ããªã„ã®ã§ã™ã€‚"

#: ../../faq/programming.rst:834
msgid ""
"Generally speaking it should not be necessary for your code to \"know the "
"names\" of particular values. Unless you are deliberately writing "
"introspective programs, this is usually an indication that a change of "
"approach might be beneficial."
msgstr "æ¦‚ã—ã¦ã€ã‚³ãƒ¼ãƒ‰ã«ã¨ã£ã¦ã‚ã‚‹å€¤ã®ã€Œåå‰ã‚’çŸ¥ã£ã¦ã„ã‚‹ã€äº‹ã¯é‡è¦ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚ãªãŸãŒã‚ã–ã¨å†…çœçš„ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ã„ã‚‹ã®ã§ãªã„é™ã‚Šã€æ–¹é‡ã‚’å¤‰ãˆãŸæ–¹ãŒã„ã„ã‹ã‚‚ã—ã‚Œãªã„ã¨ã„ã†ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/programming.rst:839
msgid ""
"In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer "
"to this question:"
msgstr "comp.lang.python ã§ã€Fredrik Lundh ã¯ã“ã®å•é¡Œã®ç­”ãˆã¨ã—ã¦ç´ æ™´ã‚‰ã—ã„å–©ãˆã‚’ã—ã¦ãã‚Œã¾ã—ãŸ:"

#: ../../faq/programming.rst:842
msgid ""
"The same way as you get the name of that cat you found on your porch: the "
"cat (object) itself cannot tell you its name, and it doesn't really care -- "
"so the only way to find out what it's called is to ask all your neighbours "
"(namespaces) if it's their cat (object)..."
msgstr "ç„é–¢ã«ã„ãŸçŒ«ã®åå‰ã‚’çŸ¥ã‚‹ã®ã¨åŒã˜æ–¹æ³•ã§ã™: ãã®çŒ« (ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) è‡ªä½“ã¯ãã®åå‰ã‚’è¨€ã†ã“ã¨ãŒã§ããªã„ã—ã€ãã‚Œã¯å®Ÿã¯å•é¡Œã§ã¯ã‚ã‚Šã¾ã›ã‚“ -- ãã®çŒ«ãŒä½•ã¨å‘¼ã°ã‚Œã¦ã„ã‚‹ã‹ã‚’çŸ¥ã‚‹å”¯ä¸€ã®æ–¹æ³•ã¯ã€ã™ã¹ã¦ã®éš£äºº (åå‰ç©ºé–“) ã«ãã®çŒ« (ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) ãŒä½•ã¨å‘¼ã°ã‚Œã¦ã„ã‚‹ã‹ã‚’èãã“ã¨ã§ã™ã€‚"

#: ../../faq/programming.rst:847
msgid ""
"....and don't be surprised if you'll find that it's known by many names, or "
"no name at all!"
msgstr "â€¦â€¦ãã—ã¦ã€ãã®çŒ«ãŒæ²¢å±±ã®åå‰ã§çŸ¥ã‚‰ã‚Œã¦ã„ãŸã‚Šã€é€†ã«å…¨ãåå‰ãŒç„¡ã‹ã£ãŸã‚Šã—ã¦ã‚‚é©šã‹ãªã„ã§ãã ã•ã„ï¼"

#: ../../faq/programming.rst:852
msgid "What's up with the comma operator's precedence?"
msgstr "ã‚«ãƒ³ãƒæ¼”ç®—å­ã¯ãªãœå„ªå…ˆã•ã‚Œã‚‹ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:854
msgid "Comma is not an operator in Python.  Consider this session::"
msgstr "ã‚«ãƒ³ãƒã¯ Python ã§ã¯æ¼”ç®—å­ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’è€ƒãˆã¦ãã ã•ã„::"

#: ../../faq/programming.rst:859
msgid ""
"Since the comma is not an operator, but a separator between expressions the "
"above is evaluated as if you had entered::"
msgstr "ã‚«ãƒ³ãƒã¯æ¼”ç®—å­ã§ã¯ãªãã€å¼ã®åˆ†é›¢å­ãªã®ã§ã€ä¸Šã®å¼ã¯æ¬¡ã®å¼ã¨åŒã˜ã‚ˆã†ã«è©•ä¾¡ã•ã‚Œã¾ã™::"

#: ../../faq/programming.rst:864
msgid "not::"
msgstr "ã“ã†ã§ã¯ã‚ã‚Šã¾ã›ã‚“::"

#: ../../faq/programming.rst:868
msgid ""
"The same is true of the various assignment operators (``=``, ``+=`` etc).  "
"They are not truly operators but syntactic delimiters in assignment "
"statements."
msgstr "ä»–ã®ã•ã¾ã–ã¾ãªæ¼”ç®—å­(``=``ã€``+=`` ãªã©)ã‚‚åŒã˜ã§ã™ã€‚ã“ã‚Œã‚‰ã¯çœŸã®æ¼”ç®—å­ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ä»£å…¥æ–‡ã®æ§‹æ–‡ä¸Šã®ãƒ‡ãƒªãƒŸã‚¿ã§ã™ã€‚"

#: ../../faq/programming.rst:873
msgid "Is there an equivalent of C's \"?:\" ternary operator?"
msgstr "C ã® \"?:\" ä¸‰é …æ¼”ç®—å­ã¨ç­‰ä¾¡ãªã‚‚ã®ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:875
msgid ""
"Yes, this feature was added in Python 2.5. The syntax would be as follows::"
msgstr "ã¯ã„ã€ã“ã®æ©Ÿèƒ½ã¯ Python 2.5 ã§è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚æ§‹æ–‡ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../faq/programming.rst:883
msgid "For versions previous to 2.5 the answer would be 'No'."
msgstr "2.5 ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã¤ã„ã¦ã¯ã€ã“ã‚Œã®ç­”ãˆã¯ã€Œã„ã„ãˆã€ã§ã™ã€‚"

#: ../../faq/programming.rst:887
msgid "Is it possible to write obfuscated one-liners in Python?"
msgstr "Python ã§è§£ã—é›£ã„ãƒ¯ãƒ³ãƒ©ã‚¤ãƒŠãƒ¼ã‚’æ›¸ãã“ã¨ã¯ã§ãã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:889
msgid ""
"Yes.  Usually this is done by nesting :keyword:`lambda` within "
":keyword:`lambda`.  See the following three examples, due to Ulf Bartelt::"
msgstr "ã¯ã„ã€‚ãã†ã„ã†ã‚‚ã®ã¯ãŸã„ã¦ã„ã€ :keyword:`lambda` ã®ä¸­ã« :keyword:`lambda` ãŒãƒã‚¹ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚Ulf Bartelt ã«ã‚ˆã‚‹ä¸‹ã®ï¼“ã¤ã®ä¾‹ã‚’è¦‹ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:914
msgid "Don't try this at home, kids!"
msgstr "ã‚ˆã„å­ã¯ã¾ã­ã—ãªã„ã§ã­ï¼"

#: ../../faq/programming.rst:918
msgid "Numbers and strings"
msgstr "æ•°ã¨æ–‡å­—åˆ—"

#: ../../faq/programming.rst:921
msgid "How do I specify hexadecimal and octal integers?"
msgstr "åå…­é€²æ•°ã‚„å…«é€²æ•°ã‚’æŒ‡å®šã™ã‚‹ã«ã¯ã©ã†ã—ãŸã‚‰ã„ã„ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:923
msgid ""
"To specify an octal digit, precede the octal value with a zero, and then a "
"lower or uppercase \"o\".  For example, to set the variable \"a\" to the "
"octal value \"10\" (8 in decimal), type::"
msgstr "å…«é€²æ•°ã‚’æŒ‡å®šã™ã‚‹ã«ã¯ã€å…«é€²æ•°ã§ã®å€¤ã®å…ˆé ­ã« 0 ã¨ \"o\" (å°æ–‡å­—ã¾ãŸã¯å¤§æ–‡å­—) ã‚’åŠ ãˆã¦ãã ã•ã„ã€‚ãŸã¨ãˆã°ã€å¤‰æ•° \"a\" ã«å…«é€²æ•°ã§ã® \"10\" (åé€²æ•°ã§ã®\"8\") ã‚’ä»£å…¥ã™ã‚‹ã«ã¯ã€ã“ã†æ‰“ã£ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:931
msgid ""
"Hexadecimal is just as easy.  Simply precede the hexadecimal number with a "
"zero, and then a lower or uppercase \"x\".  Hexadecimal digits can be "
"specified in lower or uppercase.  For example, in the Python interpreter::"
msgstr "åå…­é€²æ•°ã‚‚ç°¡å˜ã§ã™ã€‚ãŸã åå…­é€²æ•°ã§ã®å€¤ã®å…ˆé ­ã« 0 ã¨ \"x\" (å°æ–‡å­—ã¾ãŸã¯å¤§æ–‡å­—) ã‚’åŠ ãˆã¦ãã ã•ã„ã€‚åå…­é€²æ•°ã¯å°æ–‡å­—ã§ã‚‚å¤§æ–‡å­—ã§ã‚‚æŒ‡å®šã§ãã¾ã™ã€‚ãŸã¨ãˆã°ã€Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã§::"

#: ../../faq/programming.rst:944
msgid "Why does -22 // 10 return -3?"
msgstr "ãªãœ -22 // 10 ã¯ -3 ã‚’è¿”ã™ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:946
msgid ""
"It's primarily driven by the desire that ``i % j`` have the same sign as "
"``j``. If you want that, and also want::"
msgstr "``i % j`` ãŒ ``j`` ã¨åŒã˜ç¬¦å·ã§ã‚ã£ã¦ã»ã—ã„ã“ã¨ã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚ãã‚Œã«åŠ ãˆã¦ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚‚ã—ãŸã„ã¨ã™ã‚‹ã¨::"

#: ../../faq/programming.rst:951
msgid ""
"then integer division has to return the floor.  C also requires that "
"identity to hold, and then compilers that truncate ``i // j`` need to make "
"``i % j`` have the same sign as ``i``."
msgstr "æ•´æ•°é™¤ç®—ã¯åºŠã‚’è¿”ã™ã“ã¨ã«ãªã‚Šã¾ã™ã€‚C ã«ã‚‚ C ã®ä¸€è²«æ€§ãŒã‚ã£ã¦ã€``i % j`` ãŒ ``i`` ã¨åŒã˜ç¬¦å·ã‚’æŒã¤ã‚ˆã†ã« ``i // j`` ã‚’ä¸¸ã‚ã¦ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:955
msgid ""
"There are few real use cases for ``i % j`` when ``j`` is negative.  When "
"``j`` is positive, there are many, and in virtually all of them it's more "
"useful for ``i % j`` to be ``>= 0``.  If the clock says 10 now, what did it "
"say 200 hours ago?  ``-190 % 12 == 2`` is useful; ``-190 % 12 == -10`` is a "
"bug waiting to bite."
msgstr "``i % j`` ã¯ã€``j`` ãŒè² ã®æ™‚ã«ã¯å®Ÿéš›ã«ã¯ã»ã¨ã‚“ã©ä½¿ã„ã¾ã›ã‚“ã€‚``j`` ãŒæ­£ãªã‚‰ã€ãŸãã•ã‚“ä½¿ã„ã¾ã™ã€‚ãã®äº‹å®Ÿä¸Šã™ã¹ã¦ã®å ´åˆã€``i % j`` ã¯ ``>= 0`` ã¨ãªã‚‹æ–¹ãŒä¾¿åˆ©ã§ã™ã€‚æ™‚è¨ˆãŒ 10 æ™‚ã‚’æŒ‡ã—ã¦ã„ã‚‹æ™‚ã€ãã® 200 æ™‚é–“å‰ã¯ä½•æ™‚ã§ã—ã‚‡ã†ã‹ã€‚``-190 % 12 == 2`` ã¨ãªã‚‹ã®ãŒä¾¿åˆ©ã§ã™ã€‚``-190 % 12 == -10`` ã¯å™›ã¿ä»˜ãã‹ã­ãªã„ãƒã‚°ã§ã™ã€‚"

#: ../../faq/programming.rst:963
msgid ""
"On Python 2, ``a / b`` returns the same as ``a // b`` if "
"``__future__.division`` is not in effect.  This is also known as \"classic\""
" division."
msgstr "Python 2 ã§ã¯ã€  ``__future__.division`` ãŒæœ‰åŠ¹ã§ãªã‘ã‚Œã°ã€``a / b`` ã¯ ``a // b`` ã¨åŒã˜çµæœã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯ \"å¤å…¸çš„ãª (classic)\" é™¤ç®—ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚"

#: ../../faq/programming.rst:969
msgid "How do I convert a string to a number?"
msgstr "æ–‡å­—åˆ—ã‚’æ•°ã«å¤‰æ›ã™ã‚‹ã«ã¯ã©ã†ã—ãŸã‚‰ã„ã„ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:971
msgid ""
"For integers, use the built-in :func:`int` type constructor, e.g. "
"``int('144') == 144``.  Similarly, :func:`float` converts to floating-point,"
" e.g. ``float('144') == 144.0``."
msgstr "æ•´æ•°ã«å¤‰æ›ã™ã‚‹ã«ã¯ã€çµ„ã¿è¾¼ã¿ã® :func:`int` å‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°ã€ ``int('144') == 144`` ã§ã™ã€‚åŒæ§˜ã«ã€ :func:`float` ã¯æµ®å‹•å°æ•°ç‚¹ã«å¤‰æ›ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``float('144') == 144.0`` ã§ã™ã€‚"

#: ../../faq/programming.rst:975
msgid ""
"By default, these interpret the number as decimal, so that ``int('0144') == "
"144`` and ``int('0x144')`` raises :exc:`ValueError`. ``int(string, base)`` "
"takes the base to convert from as a second optional argument, so "
"``int('0x144', 16) == 324``.  If the base is specified as 0, the number is "
"interpreted using Python's rules: a leading '0' indicates octal, and '0x' "
"indicates a hex number."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã“ã‚Œã‚‰ã¯æ•°ã‚’åé€²æ•°ã¨ã—ã¦è§£é‡ˆã™ã‚‹ã®ã§ã€ ``int('0o144')`` ã‚„ ``int('0x144')`` ã¯ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚ ``int(string, base)`` ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ç¬¬äºŒå¼•æ•°ã‚’ã¨ã£ã¦å¤‰æ›å…ƒã®åŸºæ•°ã«ã—ã¾ã™ã€‚ã¤ã¾ã‚Š ``int('0x144', 16) == 324`` ã§ã™ã€‚åŸºæ•°ãŒ 0 ã¨æŒ‡å®šã•ã‚ŒãŸå ´åˆã€ãã®æ•°ã¯ Python ã®åŸºæº–ã«ã‚ˆã£ã¦è§£é‡ˆã•ã‚Œã¾ã™ã€‚å…ˆé ­ãŒ '0o' ãªã‚‰å…«é€²æ•°ã§ã€'0x' ãªã‚‰åå…­é€²æ•°ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../faq/programming.rst:981
msgid ""
"Do not use the built-in function :func:`eval` if all you need is to convert "
"strings to numbers.  :func:`eval` will be significantly slower and it "
"presents a security risk: someone could pass you a Python expression that "
"might have unwanted side effects.  For example, someone could pass "
"``__import__('os').system(\"rm -rf $HOME\")`` which would erase your home "
"directory."
msgstr "æ–‡å­—åˆ—ã‚’æ•°ã«å¤‰æ›ã™ã‚‹ã ã‘ã®ãŸã‚ã« :func:`eval` ã‚’ä½¿ã‚ãªã„ã§ãã ã•ã„ã€‚ :func:`eval` ã¯ç‰¹ã«é…ã„ã§ã™ã—ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®ãƒªã‚¹ã‚¯ã‚‚ã‚ã‚Šã¾ã™ã€‚æ±‚ã‚ã‚‰ã‚Œãªã„å‰¯ä½œç”¨ã‚’æŒã¤ã‚ˆã†ãª Python ã®å¼ã‚’æ¸¡ãã†ã¨ã™ã‚‹äººãŒã„ã‚‹ã‹ã‚‚çŸ¥ã‚Œã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ã‚ãªãŸã®ãƒ›ãƒ¼ãƒ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æ¶ˆå»ã™ã‚‹ ``__import__('os').system(\"rm -rf $HOME\")`` ã‚’æ¸¡ãã†ã¨ã™ã‚‹äººãŒã„ã‚‹ã‹ã‚‚çŸ¥ã‚Œã¾ã›ã‚“ã€‚"

#: ../../faq/programming.rst:988
msgid ""
":func:`eval` also has the effect of interpreting numbers as Python "
"expressions, so that e.g. ``eval('09')`` gives a syntax error because Python"
" regards numbers starting with '0' as octal (base 8)."
msgstr ":func:`eval` ã«ã‚‚æ•°ã‚’ Python ã®å¼ã¨ã—ã¦è§£é‡ˆã™ã‚‹æ©Ÿèƒ½ãŒã‚ã‚Šã¾ã™ã€‚ã ã‹ã‚‰ä¾‹ãˆã°ã€ ``eval('09')`` ã¯æ§‹æ–‡ã‚¨ãƒ©ãƒ¼èµ·ã“ã—ã¾ã™ã€‚Python ã¯ '0' ã§å§‹ã¾ã‚‹æ•°ã‚’å…«é€²æ•° (åŸºæ•° 8) ã¨ã¿ãªã™ã‹ã‚‰ã§ã™ã€‚"

#: ../../faq/programming.rst:994
msgid "How do I convert a number to a string?"
msgstr "æ•°ã‚’æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹ã«ã¯ã©ã†ã—ãŸã‚‰ã„ã„ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:996
msgid ""
"To convert, e.g., the number 144 to the string '144', use the built-in type "
"constructor :func:`str`.  If you want a hexadecimal or octal representation,"
" use the built-in functions :func:`hex` or :func:`oct`.  For fancy "
"formatting, see the :ref:`formatstrings` section, e.g. "
"``\"{:04d}\".format(144)`` yields ``'0144'`` and ``\"{:.3f}\".format(1/3)`` "
"yields ``'0.333'``.  You may also use :ref:`the % operator <string-"
"formatting>` on strings.  See the library reference manual for details."
msgstr "ä¾‹ãˆã°ã€144 ã¨ã„ã†æ•°ã‚’ '144' ã¨ã„ã†æ–‡å­—åˆ—ã«å¤‰æ›ã—ãŸã„ãªã‚‰ã€çµ„ã¿è¾¼ã¿ã®å‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ :func:`str` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚åå…­é€²æ•°ã‚„å…«é€²æ•°ã«ã—ãŸã‘ã‚Œã°ã€çµ„ã¿è¾¼ã¿é–¢æ•°ã® :func:`hex` ã‚„ :func:`oct` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚è£…é£¾ã•ã‚ŒãŸå½¢å¼ã«ã™ã‚‹ã«ã¯ã€ :ref:`formatstrings` ã®é …ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°ã€ ``\"{:04d}\".format(144)`` ã¯ ``'0144'`` ã«ãªã‚Šã€ ``\"{:.3f}\".format(1/3)`` ã¯ ``'0.333'`` ã«ãªã‚Šã¾ã™ã€‚æ–‡å­—åˆ—ã« :ref:`% æ¼”ç®—å­ <string-formatting>` ã‚’ä½¿ã†ã“ã¨ã‚‚ã§ãã¾ã™ã€‚è©³ç´°ã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã®è§£èª¬ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/programming.rst:1006
msgid "How do I modify a string in place?"
msgstr "æ–‡å­—åˆ—ã‚’ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã«å¤‰æ›´ã™ã‚‹ã«ã¯ã©ã†ã—ãŸã‚‰ã„ã„ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1008
msgid ""
"You can't, because strings are immutable.  If you need an object with this "
"ability, try converting the string to a list or use the array module::"
msgstr "æ–‡å­—åˆ—ã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã®ã§ã€å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ãã‚ŒãŒã§ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚‹ã«ã¯ã€ãã®æ–‡å­—åˆ—ã‚’ãƒªã‚¹ãƒˆã«å¤‰æ›ã—ã¦ã¿ã‚‹ã‹ã€array ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:1031
msgid "How do I use strings to call functions/methods?"
msgstr "é–¢æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã¶ã®ã«æ–‡å­—åˆ—ã‚’ä½¿ã†ã«ã¯ã©ã†ã—ãŸã‚‰ã„ã„ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1033
msgid "There are various techniques."
msgstr "æ§˜ã€…ãªãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:1035
msgid ""
"The best is to use a dictionary that maps strings to functions.  The primary"
" advantage of this technique is that the strings do not need to match the "
"names of the functions.  This is also the primary technique used to emulate "
"a case construct::"
msgstr "ä¸€ç•ªã„ã„ã®ã¯ã€æ–‡å­—åˆ—ã‚’é–¢æ•°ã«å¯¾å¿œã•ã›ã‚‹è¾æ›¸ã‚’ä½¿ã†ã“ã¨ã§ã™ã€‚ã“ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã®ä¸€ç•ªã®åˆ©ç‚¹ã¯ã€æ–‡å­—åˆ—ãŒé–¢æ•°ã®åå‰ã¨åŒã˜å¿…è¦ãŒãªã„ã“ã¨ã§ã™ã€‚ã“ã®æ–¹æ³•ã¯ case æ§‹é€ ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ãŸã‚ã®ä¸€ç•ªã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã§ã‚‚ã‚ã‚Šã¾ã™::"

#: ../../faq/programming.rst:1050
msgid "Use the built-in function :func:`getattr`::"
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•°ã® :func:`getattr` ã‚’ä½¿ã†æ–¹æ³•::"

#: ../../faq/programming.rst:1055
msgid ""
"Note that :func:`getattr` works on any object, including classes, class "
"instances, modules, and so on."
msgstr "ãªãŠã€ :func:`getattr` ã¯ã‚¯ãƒ©ã‚¹ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãªã©ã€ã©ã‚“ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚‚ä½¿ãˆã¾ã™ã€‚"

#: ../../faq/programming.rst:1058
msgid "This is used in several places in the standard library, like this::"
msgstr "ã“ã‚Œã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã‚‚ä½•ç®‡æ‰€ã‹ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ã‚ˆã†ã«::"

#: ../../faq/programming.rst:1071
msgid "Use :func:`locals` or :func:`eval` to resolve the function name::"
msgstr ":func:`locals` ã‚„ :func:`eval` ã‚’ä½¿ã£ã¦é–¢æ•°åã‚’æ±ºã‚ã‚‹æ–¹æ³•::"

#: ../../faq/programming.rst:1084
msgid ""
"Note: Using :func:`eval` is slow and dangerous.  If you don't have absolute "
"control over the contents of the string, someone could pass a string that "
"resulted in an arbitrary function being executed."
msgstr "ãƒãƒ¼ãƒˆ: :func:`eval` ã®ä½¿ç”¨ã¯é…ã„ã—å±é™ºã§ã™ã€‚ã‚‚ã—ã‚ãªãŸãŒæ–‡å­—åˆ—ã®å†…å®¹ã‚’çµ¶å¯¾çš„ã«æ”¯é…ã§ããªã‘ã‚Œã°ã€ä»»æ„ã®é–¢æ•°ã‚’å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹æ–‡å­—åˆ—ã‚’æ¸¡ã™äººãŒã„ã‚‹ã‹ã‚‚çŸ¥ã‚Œã¾ã›ã‚“ã€‚"

#: ../../faq/programming.rst:1089
msgid ""
"Is there an equivalent to Perl's chomp() for removing trailing newlines from"
" strings?"
msgstr "æ–‡å­—åˆ—ã‹ã‚‰å¾Œç«¯ã®æ”¹è¡Œã‚’å–ã‚Šé™¤ã Perl ã® chomp() ã«ç›¸å½“ã™ã‚‹ã‚‚ã®ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1091
msgid ""
"Starting with Python 2.2, you can use ``S.rstrip(\"\\r\\n\")`` to remove all"
" occurrences of any line terminator from the end of the string ``S`` without"
" removing other trailing whitespace.  If the string ``S`` represents more "
"than one line, with several empty lines at the end, the line terminators for"
" all the blank lines will be removed::"
msgstr "Python 2.2 ã‹ã‚‰ã¯ã€ ``S.rstrip(\"\\r\\n\")`` ã‚’ä½¿ã£ã¦æ–‡å­—åˆ— ``S`` ã®çµ‚ç«¯ã‹ã‚‰ä»–ã®ç©ºç™½æ–‡å­—ã‚’å–ã‚Šé™¤ãã“ã¨ãªãã™ã¹ã¦ã®è¡Œæœ«è¨˜å·ã‚’å–ã‚Šé™¤ãã“ã¨ãŒã§ãã¾ã™ã€‚æ–‡å­—åˆ— ``S`` ãŒè¤‡æ•°è¡Œã‚’è¡¨ã—ã€çµ‚ç«¯ã«ç©ºè¡ŒãŒã‚ã‚‹ã¨ãã€ãã®ã™ã¹ã¦ã®ç©ºè¡Œã‚‚å–ã‚Šé™¤ã‹ã‚Œã¾ã™::"

#: ../../faq/programming.rst:1103
msgid ""
"Since this is typically only desired when reading text one line at a time, "
"using ``S.rstrip()`` this way works well."
msgstr "ã“ã‚Œã¯å…¸å‹çš„ã«ä¸€åº¦ã«ä¸€è¡Œãšã¤ãƒ†ã‚­ã‚¹ãƒˆã‚’èª­ã¿ãŸã„æ™‚ã«ã®ã¿ä½¿ã‚ã‚Œã‚‹ã®ã§ã€``S.rstrip()`` ã‚’ã“ã®æ–¹æ³•ã§ä½¿ã†ã¨ã†ã¾ãã„ãã¾ã™ã€‚"

#: ../../faq/programming.rst:1106
msgid "For older versions of Python, there are two partial substitutes:"
msgstr "å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã§ã¯ã€éƒ¨åˆ†çš„ãªä»£ç”¨å“ãŒäºŒã¤ã‚ã‚Šã¾ã™:"

#: ../../faq/programming.rst:1108
msgid ""
"If you want to remove all trailing whitespace, use the ``rstrip()`` method "
"of string objects.  This removes all trailing whitespace, not just a single "
"newline."
msgstr "ã™ã¹ã¦ã®çµ‚ç«¯ã®ç©ºç™½æ–‡å­—ã‚’å–ã‚Šé™¤ããŸã„ãªã‚‰ã€æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® ``rstrip()`` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ã“ã‚Œã¯æ”¹è¡Œè¨˜å·ä¸€ã¤ã ã‘ã§ãªãã€ã™ã¹ã¦ã®çµ‚ç«¯ã®ç©ºç™½æ–‡å­—ã‚’å–ã‚Šé™¤ãã¾ã™ã€‚"

#: ../../faq/programming.rst:1112
msgid ""
"Otherwise, if there is only one line in the string ``S``, use "
"``S.splitlines()[0]``."
msgstr "ãã†ã§ãªãã€æ–‡å­—åˆ— ``S`` ã«ä¸€è¡Œã—ã‹ç„¡ã„ãªã‚‰ã€``S.splitlines()[0]`` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../faq/programming.rst:1117
msgid "Is there a scanf() or sscanf() equivalent?"
msgstr "scanf() ã‚„ sscanf() ã¨åŒç­‰ãªã‚‚ã®ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1119
msgid "Not as such."
msgstr "ãã®ã‚ˆã†ãªã‚‚ã®ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../faq/programming.rst:1121
msgid ""
"For simple input parsing, the easiest approach is usually to split the line "
"into whitespace-delimited words using the :meth:`~str.split` method of "
"string objects and then convert decimal strings to numeric values using "
":func:`int` or :func:`float`.  ``split()`` supports an optional \"sep\" "
"parameter which is useful if the line uses something other than whitespace "
"as a separator."
msgstr "ç°¡å˜ãªå…¥åŠ›è§£æã§ã€å¤šãã®å ´åˆã«ä¸€ç•ªç°¡å˜ãªæ–¹æ³•ã¯ã€æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`~str.split` ãƒ¡ã‚½ãƒƒãƒ‰ã§è¡Œã‚’ç©ºç™½æ–‡å­—ã§åŒºåˆ‡ã‚‰ã‚ŒãŸå˜èªã«åˆ†ã‘ã€åé€²æ•°ã®æ–‡å­—åˆ—ã‚’ :func:`int` ã‚„ :func:`float` ã§æ•°å€¤ã«å¤‰æ›ã™ã‚‹ã“ã¨ã§ã™ã€‚ ``split()`` ã«ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® \"sep\" å¤‰æ•°ãŒã‚ã‚Šã€è¡Œã«ç©ºç™½æ–‡å­—ä»¥å¤–ã®åŒºåˆ‡ã‚Šã‚’ä½¿ã£ã¦ã„ã‚‹ã¨ãã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../faq/programming.rst:1127
msgid ""
"For more complicated input parsing, regular expressions are more powerful "
"than C's :c:func:`sscanf` and better suited for the task."
msgstr "ã‚‚ã£ã¨è¤‡é›‘ãªå…¥åŠ›è§£æã‚’ã—ãŸã„ãªã‚‰ã€C ã® :c:func:`sscanf` ã‚ˆã‚Šã‚‚æ­£è¦è¡¨ç¾ã®æ–¹ãŒä¾¿åˆ©ã§ã™ã—ã€ã“ã®å‡¦ç†ã«å‘ã„ã¦ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:1132
msgid ""
"What does 'UnicodeError: ASCII [decoding,encoding] error: ordinal not in "
"range(128)' mean?"
msgstr "'UnicodeError: ASCII [decoding,encoding] error: ordinal not in range(128)' ã¨ã¯ã©ã†ã„ã†æ„å‘³ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1134
msgid ""
"This error indicates that your Python installation can handle only 7-bit "
"ASCII strings.  There are a couple ways to fix or work around the problem."
msgstr "ã“ã®ã‚¨ãƒ©ãƒ¼ã¯ã€ã‚ãªãŸã® Python ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒ 7-bit ASCII æ–‡å­—åˆ—ã—ã‹æ‰±ãˆãªã„ã“ã¨ã‚’è¡¨ã—ã¾ã™ã€‚ã“ã®å•é¡Œã‚’æ‰±ã†ã«ã¯äºŒã¤ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:1137
msgid ""
"If your programs must handle data in arbitrary character set encodings, the "
"environment the application runs in will generally identify the encoding of "
"the data it is handing you.  You need to convert the input to Unicode data "
"using that encoding.  For example, a program that handles email or web input"
" will typically find character set encoding information in Content-Type "
"headers.  This can then be used to properly convert input data to Unicode. "
"Assuming the string referred to by ``value`` is encoded as UTF-8::"
msgstr "ã‚ãªãŸã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã€ä»»æ„ã®æ–‡å­—ã‚»ãƒƒãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã‚ãªã‘ã‚Œã°ãªã‚‰ãªã„ãªã‚‰ã€ä¸€èˆ¬ã«ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒèµ·å‹•ã™ã‚‹ç’°å¢ƒã«ã‚ˆã£ã¦ãƒ‡ãƒ¼ã‚¿ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒç‰¹å®šã•ã‚Œã¾ã™ã€‚å…¥åŠ›ã‚’ãã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã£ã¦ Unicode ã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€email ã‚„ web å…¥åŠ›ã‚’æ‰±ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€æ¦‚ã—ã¦æ–‡å­—ã‚»ãƒƒãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æƒ…å ±ã‚’ Content-Type ãƒ˜ãƒƒãƒ€ã‹ã‚‰è¦‹ã¤ã‘ã¾ã™ã€‚ã“ã‚Œã«ä½¿ã†ã“ã¨ã§ã€å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã‚’ Unicode ã«æ­£ã—ãå¤‰æ›ã§ãã¾ã™ã€‚ ``value`` ã«ã‚ˆã£ã¦å‚ç…§ã•ã‚Œã‚‹æ–‡å­—åˆ—ãŒ UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã‚‹ã¨ã™ã‚Œã°::"

#: ../../faq/programming.rst:1147
msgid ""
"will return a Unicode object.  If the data is not correctly encoded as "
"UTF-8, the above call will raise a :exc:`UnicodeError` exception."
msgstr "ã¯ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ãŒ UTF-8 ã«æ­£ã—ãå¤‰æ›ã•ã‚Œãªã„ãªã‚‰ã€ä¸Šè¨˜ã®å‘¼ã³å‡ºã—ã¯ :exc:`UnicodeError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../faq/programming.rst:1150
msgid ""
"If you only want strings converted to Unicode which have non-ASCII data, you"
" can try converting them first assuming an ASCII encoding, and then generate"
" Unicode objects if that fails::"
msgstr "é ASCII ãƒ‡ãƒ¼ã‚¿ã‚’æŒã¤æ–‡å­—åˆ—ã‚’ Unicode ã«å¤‰æ›ã™ã‚Œã°ã„ã„ã ã‘ãªã‚‰ã€ã¾ãš ASCII ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä»®å®šã—ã¦å¤‰æ›ã—ã€å¤±æ•—ã—ãŸã‚‰ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚Œã°ã„ã„ã§ã™::"

#: ../../faq/programming.rst:1162
msgid ""
"It's possible to set a default encoding in a file called "
"``sitecustomize.py`` that's part of the Python library.  However, this isn't"
" recommended because changing the Python-wide default encoding may cause "
"third-party extension modules to fail."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ã€Python ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ä¸€éƒ¨ã§ã‚ã‚‹ ``sitecustomize.py`` ã¨å‘¼ã°ã‚Œã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã§è¨­å®šã§ãã¾ã™ã€‚ã—ã‹ã—ã€Python å…¨ä½“ã«ãŠã‘ã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’å¤‰ãˆã¦ã—ã¾ã†ã“ã¨ã¯ã€ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å¤±æ•—ã«ã¤ãªãŒã‚‹ã®ã§ãŠå‹§ã‚ã§ãã¾ã›ã‚“ã€‚"

#: ../../faq/programming.rst:1167
msgid ""
"Note that on Windows, there is an encoding known as \"mbcs\", which uses an "
"encoding specific to your current locale.  In many cases, and particularly "
"when working with COM, this may be an appropriate default encoding to use."
msgstr "ãªãŠã€Windows ã«ã¯ã€ \"mbcs\" ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒã‚ã‚Šã€ã“ã‚Œã¯ã‚ãªãŸã®ãƒ­ã‚±ãƒ¼ãƒ«ã«ä¾å­˜ã™ã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ã‚¤ãƒ³ã‚°ã‚’ä½¿ã„ã¾ã™ã€‚å¤šãã®å ´åˆã€ç‰¹ã« COM ã§ä½œæ¥­ã‚’ã™ã‚‹ã¨ãã€ã“ã‚ŒãŒä½¿ã†ã®ã«é©ã—ãŸãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã™ã€‚"

#: ../../faq/programming.rst:1173
msgid "Sequences (Tuples/Lists)"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹(ã‚¿ãƒ—ãƒ«/ãƒªã‚¹ãƒˆ)"

#: ../../faq/programming.rst:1176
msgid "How do I convert between tuples and lists?"
msgstr "ã‚¿ãƒ—ãƒ«ã€ãƒªã‚¹ãƒˆé–“ã®å¤‰æ›´ã¯ã©ã®ã‚ˆã†ã«ã™ã‚‹ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1178
msgid ""
"The type constructor ``tuple(seq)`` converts any sequence (actually, any "
"iterable) into a tuple with the same items in the same order."
msgstr "å‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ ``tuple(seq)`` ã¯ã™ã¹ã¦ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ (å®Ÿéš›ã«ã¯ã€ã™ã¹ã¦ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«) ã‚’åŒã˜è¦ç´ ã€åŒã˜é †åºã®ã‚¿ãƒ—ãƒ«ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../faq/programming.rst:1181
msgid ""
"For example, ``tuple([1, 2, 3])`` yields ``(1, 2, 3)`` and ``tuple('abc')`` "
"yields ``('a', 'b', 'c')``.  If the argument is a tuple, it does not make a "
"copy but returns the same object, so it is cheap to call :func:`tuple` when "
"you aren't sure that an object is already a tuple."
msgstr "ä¾‹ãˆã°ã€ ``tuple([1, 2, 3])`` ã¯ ``(1, 2, 3)`` ã‚’ä¸ãˆã€ ``tuple('abc')`` ã¯ ``('a', 'b', 'c')`` ã‚’ä¸ãˆã¾ã™ã€‚å¼•æ•°ãŒã‚¿ãƒ—ãƒ«ãªã‚‰ã€ã‚³ãƒ”ãƒ¼ã‚’ä½œã‚‰ãšã«å¼•æ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãã®ã‚‚ã®ã‚’è¿”ã™ã®ã§ã€ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ—¢ã«ã‚¿ãƒ—ãƒ«ã«ãªã£ã¦ã„ã‚‹ã‹ç¢ºä¿¡ãŒæŒã¦ãªã„ã®ãªã‚‰ã€ :func:`tuple` ã‚’å‘¼ã¶ã®ãŒæ‰‹è»½ã§ã™ã€‚"

#: ../../faq/programming.rst:1186
msgid ""
"The type constructor ``list(seq)`` converts any sequence or iterable into a "
"list with the same items in the same order.  For example, ``list((1, 2, "
"3))`` yields ``[1, 2, 3]`` and ``list('abc')`` yields ``['a', 'b', 'c']``.  "
"If the argument is a list, it makes a copy just like ``seq[:]`` would."
msgstr "å‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ ``list(seq)`` ã¯ã™ã¹ã¦ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚ã‚‹ã„ã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’åŒã˜è¦ç´ ã€åŒã˜é †åºã®ãƒªã‚¹ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€``list((1, 2, 3))`` ã¯ ``[1, 2, 3]`` ã‚’ä¸ãˆã€``list('abc')`` ã¯ ``['a', 'b', 'c']`` ã‚’ä¸ãˆã¾ã™ã€‚å¼•æ•°ãŒãƒªã‚¹ãƒˆãªã‚‰ã€``seq[:]`` ã¨åŒæ§˜ã«ã‚³ãƒ”ãƒ¼ã‚’ä½œã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:1193
msgid "What's a negative index?"
msgstr "ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ãŒè² ã®å ´åˆã¯ã©ã†ãªã‚Šã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1195
msgid ""
"Python sequences are indexed with positive numbers and negative numbers.  "
"For positive numbers 0 is the first index 1 is the second index and so "
"forth.  For negative indices -1 is the last index and -2 is the penultimate "
"(next to last) index and so forth.  Think of ``seq[-n]`` as the same as "
"``seq[len(seq)-n]``."
msgstr "Python ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯æ­£ã®æ•°ã¨è² ã®æ•°ã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã•ã‚Œã¾ã™ã€‚æ­£ã®æ•°ã§ã¯ã€0 ãŒæœ€åˆã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã€1 ãŒ 2 ç•ªç›®ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã€ä»¥ä¸‹ã‚‚åŒæ§˜ã§ã™ã€‚è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã§ã¯ã€-1 ãŒæœ€å¾Œã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã€-2 ãŒæœ€å¾Œã‹ã‚‰ 2 ç•ªç›®ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã€ä»¥ä¸‹ã‚‚åŒæ§˜ã§ã™ã€‚``seq[-n]`` ã¯ ``seq[len(seq)-n]`` ã¨åŒã˜ã ã¨è€ƒãˆã¦ãã ã•ã„ã€‚"

#: ../../faq/programming.rst:1200
msgid ""
"Using negative indices can be very convenient.  For example ``S[:-1]`` is "
"all of the string except for its last character, which is useful for "
"removing the trailing newline from a string."
msgstr "è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã‚’ä½¿ã†ã¨ä¾¿åˆ©ãªã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€``S[:-1]`` ã¯æ–‡å­—åˆ—ã®æœ€å¾Œä»¥å¤–ã®ã™ã¹ã¦ã®æ–‡å­—ã‚’è¡¨ã™ã®ã§ã€æ–‡å­—åˆ—ã®æœ«å°¾ã®æ”¹è¡Œã‚’å–ã‚Šé™¤ãã¨ãã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../faq/programming.rst:1206
msgid "How do I iterate over a sequence in reverse order?"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’é€†é †ã«ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã«ã¯ã©ã†ã—ãŸã‚‰ã„ã„ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1208
msgid ""
"Use the :func:`reversed` built-in function, which is new in Python 2.4::"
msgstr "Python 2.4 ã§è¿½åŠ ã•ã‚ŒãŸ :func:`reversed` ã‚’ä½¿ã£ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:1213
msgid ""
"This won't touch your original sequence, but build a new copy with reversed "
"order to iterate over."
msgstr "ã“ã‚Œã¯å…ƒã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã„ã˜ã‚‹ã®ã§ã¯ãªãã€é€†é †ã®æ–°ã—ã„ã‚³ãƒ”ãƒ¼ã‚’ä½œã£ã¦ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã•ã›ã¾ã™ã€‚"

#: ../../faq/programming.rst:1216
msgid "With Python 2.3, you can use an extended slice syntax::"
msgstr "Python 2.3 ã§ã¯ã€æ‹¡å¼µã‚¹ãƒ©ã‚¤ã‚¹æ§‹æ–‡ã‚’ä½¿ã„ã¾ã™::"

#: ../../faq/programming.rst:1223
msgid "How do you remove duplicates from a list?"
msgstr "ãƒªã‚¹ãƒˆã‹ã‚‰é‡è¤‡ã‚’å–ã‚Šé™¤ãã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1225
msgid "See the Python Cookbook for a long discussion of many ways to do this:"
msgstr "Python Cookbook ã®é•·ã„è­°è«–ã«å¤šãã®æ–¹æ³•ãŒã‚ã‚‹ã®ã§å‚ç…§ã—ã¦ãã ã•ã„:"

#: ../../faq/programming.rst:1227
msgid "https://code.activestate.com/recipes/52560/"
msgstr "https://code.activestate.com/recipes/52560/"

#: ../../faq/programming.rst:1229
msgid ""
"If you don't mind reordering the list, sort it and then scan from the end of"
" the list, deleting duplicates as you go::"
msgstr "ãƒªã‚¹ãƒˆã‚’ä¸¦ã³æ›¿ãˆã¦æ§‹ã‚ãªã„ã®ãªã‚‰ã€ã‚½ãƒ¼ãƒˆã—ãŸä¸Šã§ãƒªã‚¹ãƒˆã®æœ€åˆã‹ã‚‰æœ€å¾Œã¾ã§ã‚’èª¿ã¹ã€æ¬¡ã®ã‚ˆã†ã«é‡è¤‡ã‚’å‰Šé™¤ã—ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:1241
msgid ""
"If all elements of the list may be used as dictionary keys (i.e. they are "
"all hashable) this is often faster ::"
msgstr "ãƒªã‚¹ãƒˆã®ã™ã¹ã¦ã®è¦ç´ ãŒè¾æ›¸ã®ã‚­ãƒ¼ã¨ã—ã¦ä½¿ãˆã‚‹ (ã¤ã¾ã‚Šã€ã™ã¹ã¦ã®è¦ç´ ãŒ hashable) ãªã‚‰ã€ãŠãã‚‰ãã“ã®ã»ã†ãŒé€Ÿã„ã§ã™::"

#: ../../faq/programming.rst:1249
msgid "In Python 2.5 and later, the following is possible instead::"
msgstr "Python 2.5 ä»¥ä¸Šã§ã¯ã€ä»¥ä¸‹ã‚’ä»£ã‚ã‚Šã«ä½¿ãˆã¾ã™::"

#: ../../faq/programming.rst:1253
msgid ""
"This converts the list into a set, thereby removing duplicates, and then "
"back into a list."
msgstr "ãƒªã‚¹ãƒˆã‚’é›†åˆã«å¤‰æ›ã™ã‚‹ã¨ãã«é‡è¤‡ã¯å–ã‚Šé™¤ã‹ã‚Œã‚‹ã®ã§ã€ãã‚Œã‚’ãƒªã‚¹ãƒˆã«æˆ»ã›ã°ã„ã„ã®ã§ã™ã€‚"

#: ../../faq/programming.rst:1258
msgid "How do you make an array in Python?"
msgstr "Python ã§é…åˆ—ã‚’ä½œã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1260
msgid "Use a list::"
msgstr "ãƒªã‚¹ãƒˆã‚’ä½¿ã£ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:1264
msgid ""
"Lists are equivalent to C or Pascal arrays in their time complexity; the "
"primary difference is that a Python list can contain objects of many "
"different types."
msgstr "ãƒªã‚¹ãƒˆã®æ™‚é–“è¨ˆç®—é‡ã¯ C ã‚„ Pascal ã®é…åˆ—ã¨åŒã˜ã§ã™ã€‚å¤§ããªé•ã„ã¯ã€Python ã®ãƒªã‚¹ãƒˆã¯å¤šãã®ç•°ãªã‚‹å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å«ã‚ã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../faq/programming.rst:1267
msgid ""
"The ``array`` module also provides methods for creating arrays of fixed "
"types with compact representations, but they are slower to index than lists."
"  Also note that the Numeric extensions and others define array-like "
"structures with various characteristics as well."
msgstr "``array`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚‚å›ºå®šã•ã‚ŒãŸå‹ã‚’ç°¡æ½”ã«è¡¨ç¾ã™ã‚‹é…åˆ—ã‚’ä½œã‚‹ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ãŒã€ãƒªã‚¹ãƒˆã‚ˆã‚Šã‚‚ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ãŒé…ã„ã§ã™ã€‚ã¾ãŸã€Numeric æ‹¡å¼µãã®ä»–ã§ã‚‚ã€æ§˜ã€…ãªç‰¹å¾´ã‚’ã‚‚ã¤é…åˆ—çš„ãªæ§‹é€ ä½“ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:1272
msgid ""
"To get Lisp-style linked lists, you can emulate cons cells using tuples::"
msgstr "Lisp æ–¹å¼ã®é€£çµãƒªã‚¹ãƒˆã‚’å¾—ã‚‹ã®ã«ã€ã‚¿ãƒ—ãƒ«ã‚’ä½¿ã£ã¦ã‚³ãƒ³ã‚¹ã‚»ãƒ«ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã§ãã¾ã™::"

#: ../../faq/programming.rst:1276
msgid ""
"If mutability is desired, you could use lists instead of tuples.  Here the "
"analogue of lisp car is ``lisp_list[0]`` and the analogue of cdr is "
"``lisp_list[1]``.  Only do this if you're sure you really need to, because "
"it's usually a lot slower than using Python lists."
msgstr "ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªå¿…è¦ãŒã‚ã‚‹ãªã‚‰ã€ã‚¿ãƒ—ãƒ«ã§ã¯ãªããƒªã‚¹ãƒˆã‚’ä½¿ã„ã¾ã—ã‚‡ã†ã€‚lisp ã® car ã«ã‚ãŸã‚‹ã‚‚ã®ãŒ ``lisp_list[0]`` ã§ã€cdr ã«ã‚ãŸã‚‹ã‚‚ã®ãŒ ``lisp_list[1]`` ã§ã™ã€‚æœ¬å½“ã«å¿…è¦ã ã¨ç¢ºä¿¡ã§ãã‚‹ã¨ãä»¥å¤–ã¯ã“ã‚Œã¯ã—ãªã„ã§ãã ã•ã„ã€‚ãŸã„ã¦ã„ã€ã“ã‚Œã¯ Python ã®ãƒªã‚¹ãƒˆã‚’ä½¿ã†ã‚ˆã‚Šã‚‚éå¸¸ã«é…ã„ã§ã™ã‹ã‚‰ã€‚"

#: ../../faq/programming.rst:1285
msgid "How do I create a multidimensional list?"
msgstr "å¤šæ¬¡å…ƒã®ãƒªã‚¹ãƒˆã‚’ä½œã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1287
msgid "You probably tried to make a multidimensional array like this::"
msgstr "ã“ã®ã‚ˆã†ã«ã—ã¦å¤šæ¬¡å…ƒã®é…åˆ—ã‚’ä½œã‚ã†ã¨ã—ã¦ã—ã¾ã£ãŸã“ã¨ãŒã‚ã‚‹ã§ã—ã‚‡ã†::"

#: ../../faq/programming.rst:1291
msgid "This looks correct if you print it::"
msgstr "ã“ã‚Œã‚’è¡¨ç¤ºã—ãŸã¨ãã«ã¯å•é¡Œãªã•ãã†ã«è¦‹ãˆã¾ã™::"

#: ../../faq/programming.rst:1296
msgid "But when you assign a value, it shows up in multiple places:"
msgstr "ã—ã‹ã—å€¤ã‚’ä»£å…¥ã™ã‚‹ã¨ã€ãã®å€¤ãŒè¤‡æ•°ã®å ´æ‰€ã«ç¾ã‚Œã¦ã—ã¾ã„ã¾ã™:"

#: ../../faq/programming.rst:1302
msgid ""
"The reason is that replicating a list with ``*`` doesn't create copies, it "
"only creates references to the existing objects.  The ``*3`` creates a list "
"containing 3 references to the same list of length two.  Changes to one row "
"will show in all rows, which is almost certainly not what you want."
msgstr "ã“ã‚Œã¯ã€``*`` ã‚’ä½¿ã£ãŸãƒªã‚¹ãƒˆã®è¤‡è£½ãŒã‚³ãƒ”ãƒ¼ã‚’ä½œã‚‰ãšã€å­˜åœ¨ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’ä½œã‚‹ã ã‘ã ã‹ã‚‰ã§ã™ã€‚ã“ã® ``*3`` ã¯é•·ã• 2 ã®åŒã˜ãƒªã‚¹ãƒˆã¸ã®å‚ç…§ã‚’å«ã‚€ãƒªã‚¹ãƒˆã‚’ä½œã‚Šã¾ã™ã€‚ä¸€ã¤ã®åˆ—ã«å¯¾ã™ã‚‹å¤‰æ›´ã¯ã™ã¹ã¦ã®åˆ—ã«ç¾ã‚Œã¾ã™ãŒã€ã“ã‚ŒãŒæœ›ã‚“ã çµæœã§ã‚ã‚‹ã“ã¨ã¯ã¾ãšãªã„ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/programming.rst:1307
msgid ""
"The suggested approach is to create a list of the desired length first and "
"then fill in each element with a newly created list::"
msgstr "ãŠã™ã™ã‚ã®æ–¹æ³•ã¯ã€æœ€åˆã«æœ›ã‚“ã é•·ã•ã®ãƒªã‚¹ãƒˆã‚’ä½œã‚Šã€ãã‚Œã‹ã‚‰æ–°ã—ãä½œã£ãŸãƒªã‚¹ãƒˆã§ãã‚Œãã‚Œã®è¦ç´ ã‚’åŸ‹ã‚ã¦ã„ãã“ã¨ã§ã™::"

#: ../../faq/programming.rst:1314
msgid ""
"This generates a list containing 3 different lists of length two.  You can "
"also use a list comprehension::"
msgstr "ã“ã‚Œã¯é•·ã• 2 ã®ç•°ãªã‚‹ãƒªã‚¹ãƒˆ 3 ã¤ã‚’å«ã‚€ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã‚‚ä½¿ãˆã¾ã™::"

#: ../../faq/programming.rst:1320
msgid ""
"Or, you can use an extension that provides a matrix datatype; `NumPy "
"<http://www.numpy.org/>`_ is the best known."
msgstr "ã‚ã‚‹ã„ã¯ã€è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿å‹ã‚’æä¾›ã—ã¦ã„ã‚‹æ‹¡å¼µã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™; `NumPy <http://www.numpy.org/>`_ ãŒæœ€ã‚‚ã‚ˆãçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:1325
msgid "How do I apply a method to a sequence of objects?"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ãƒ¡ã‚½ãƒƒãƒ‰ã‚’é©ç”¨ã™ã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1327
msgid "Use a list comprehension::"
msgstr "ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã‚’ä½¿ã£ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:1331
msgid "More generically, you can try the following function::"
msgstr "ã‚‚ã£ã¨ä¸€èˆ¬åŒ–ã—ãŸã‘ã‚Œã°ã€ä»¥ä¸‹ã®é–¢æ•°ã‚’è©¦ã—ã¦ã¿ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:1341
msgid ""
"Why does a_tuple[i] += ['item'] raise an exception when the addition works?"
msgstr "ãªãœåŠ ç®—ã¯ã•ã‚Œã‚‹ã®ã« a_tuple[i] += ['item'] ã¯ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ã®ã§ã™ã‹?"

#: ../../faq/programming.rst:1343
msgid ""
"This is because of a combination of the fact that augmented assignment "
"operators are *assignment* operators, and the difference between mutable and"
" immutable objects in Python."
msgstr "ã“ã‚Œã¯ã€æ‹¡å¼µä»£å…¥æ¼”ç®—å­ã¯ *ä»£å…¥* æ¼”ç®—å­ã ã€ã¨ã„ã†äº‹å®Ÿã¨ã€Python ã§ã®å¯å¤‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ä¸å¤‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é•ã„ãŒçµ„ã¿åˆã‚ã•ã£ã¦èµ·ãã‚‹ã®ã§ã™ã€‚"

#: ../../faq/programming.rst:1347
msgid ""
"This discussion applies in general when augmented assignment operators are "
"applied to elements of a tuple that point to mutable objects, but we'll use "
"a ``list`` and ``+=`` as our exemplar."
msgstr "ã“ã®è­°è«–ã¯ä¸€èˆ¬çš„ã«ã€å¯å¤‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã™ã‚¿ãƒ—ãƒ«ã®è¦ç´ ã«ã€æ‹¡å¼µä»£å…¥æ¼”ç®—å­ãŒé©ç”¨ã•ã‚ŒãŸã¨ãã«ã‚‚é©ç”¨ã§ãã¾ã™ãŒã€ä¾‹ã¨ã—ã¦ ``list`` ã¨ ``+=`` ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:1351
msgid "If you wrote::"
msgstr "æ¬¡ã®ã‚ˆã†ã«æ›¸ã„ãŸã¨ã—ã¾ã™::"

#: ../../faq/programming.rst:1359
msgid ""
"The reason for the exception should be immediately clear: ``1`` is added to "
"the object ``a_tuple[0]`` points to (``1``), producing the result object, "
"``2``, but when we attempt to assign the result of the computation, ``2``, "
"to element ``0`` of the tuple, we get an error because we can't change what "
"an element of a tuple points to."
msgstr "ä¾‹å¤–ãŒé€å‡ºã•ã‚ŒãŸç†ç”±ã¯æ˜ã‚‰ã‹ã§ã™: ``1`` ãŒ (``1``) ã‚’æŒ‡ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ``a_tuple[0]`` ã«åŠ ãˆã‚‰ã‚Œã€çµæœã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ``2`` ãŒç”Ÿæˆã•ã‚Œã¾ã™ãŒã€è¨ˆç®—çµæœ ``2`` ã‚’ã‚¿ãƒ—ãƒ«ã®ç¬¬ ``0`` è¦ç´ ã«ä»£å…¥ã—ã‚ˆã†ã¨ã—ãŸã¨ãã«ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚ãªãœãªã‚‰ã°ã€ã‚¿ãƒ—ãƒ«ã®è¦ç´ ãŒä½•ã‚’æŒ‡ã™ã‹ã¯å¤‰ãˆã‚‰ã‚Œãªã„ã‹ã‚‰ã§ã™ã€‚"

#: ../../faq/programming.rst:1365
msgid ""
"Under the covers, what this augmented assignment statement is doing is "
"approximately this::"
msgstr "ã“ã®ã‚ˆã†ãªè£äº‹æƒ…ã®å…ƒã€æ‹¡å¼µä»£å…¥æ–‡ã¯ã ã„ãŸã„æ¬¡ã®ã‚ˆã†ãªã“ã¨ã‚’ã—ã¦ã„ã¾ã™::"

#: ../../faq/programming.rst:1374
msgid ""
"It is the assignment part of the operation that produces the error, since a "
"tuple is immutable."
msgstr "ã‚¿ãƒ—ãƒ«ã¯ä¸å¤‰ãªã®ã§ã€ä¾‹å¤–ã‚’ç”Ÿã¿å‡ºã—ã¦ã„ã‚‹ã®ã¯æ“ä½œã®ä»£å…¥éƒ¨åˆ†ãªã®ã§ã™ã€‚"

#: ../../faq/programming.rst:1377
msgid "When you write something like::"
msgstr "æ¬¡ã®ã‚ˆã†ã«æ›¸ã„ãŸã¨ã—ã¾ã™::"

#: ../../faq/programming.rst:1385
msgid ""
"The exception is a bit more surprising, and even more surprising is the fact"
" that even though there was an error, the append worked::"
msgstr "ã“ã®ä¾‹å¤–ã«ã¯ã¡ã‚‡ã£ã¨é©šãã¾ã™ãŒã€ã‚‚ã£ã¨é©šãã¹ãã“ã¨ã¯ã€ã‚¨ãƒ©ãƒ¼ãŒã‚ã£ãŸã¨ã—ã¦ã‚‚è¿½è¨˜ã¯ãã¡ã‚“ã¨å‹•ã„ã¦ã„ã‚‹ã€ã¨ã„ã†äº‹å®Ÿã§ã™::"

#: ../../faq/programming.rst:1391
msgid ""
"To see why this happens, you need to know that (a) if an object implements "
"an ``__iadd__`` magic method, it gets called when the ``+=`` augmented "
"assignment is executed, and its return value is what gets used in the "
"assignment statement; and (b) for lists, ``__iadd__`` is equivalent to "
"calling ``extend`` on the list and returning the list.  That's why we say "
"that for lists, ``+=`` is a \"shorthand\" for ``list.extend``::"
msgstr "ãªãœã“ã‚ŒãŒèµ·ãã‚‹ã‹ã‚’èª¿ã¹ã‚‹ãŸã‚ã«ã¯ã€æ¬¡ã® 2 ç‚¹ã‚’çŸ¥ã£ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚(a) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã« ``__iadd__`` ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å ´åˆã€æ‹¡å¼µä»£å…¥ ``+=`` ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ãã«ãã‚ŒãŒå‘¼ã³å‡ºã•ã‚Œã€ãã®è¿”ã‚Šå€¤ãŒä»£å…¥æ–‡ã§ä½¿ã‚ã‚Œã¾ã™; (b) ãƒªã‚¹ãƒˆã§ã¯ã€``__iadd__`` ã¯ ``extend`` ã®å‘¼ã³å‡ºã—ã¨ç­‰ä¾¡ã§ã€ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚“ãªç†ç”±ã§ã€ãƒªã‚¹ãƒˆã§ã¯ ``+=`` ã¯ ``list.extend`` ã® \"ç•¥è¨˜\" ã ã¨è¨€ã£ãŸã®ã§ã—ãŸ::"

#: ../../faq/programming.rst:1403
msgid "This is equivalent to::"
msgstr "ã“ã‚Œã¯æ¬¡ã®ã¨ç­‰ä¾¡ã§ã™::"

#: ../../faq/programming.rst:1408
msgid ""
"The object pointed to by a_list has been mutated, and the pointer to the "
"mutated object is assigned back to ``a_list``.  The end result of the "
"assignment is a no-op, since it is a pointer to the same object that "
"``a_list`` was previously pointing to, but the assignment still happens."
msgstr "a_list ãŒæŒ‡ã—ã¦ã„ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ›´æ–°ã•ã‚Œã€æ›´æ–°ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã¯å†åº¦ ``a_list`` ã«ä»£å…¥ã•ã‚Œã¾ã™ã€‚ä»£å…¥ã—ã¦ã„ã‚‹ã®ã¯ã€``a_list`` ãŒæ›´æ–°å‰ã¾ã§æŒ‡ã—ã¦ã„ãŸåŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ãªã®ã§ã€ä»£å…¥ã¯æœ€çµ‚çš„ã«ã¯ä½•ã‚‚ã—ã¦ã„ãªã„ã®ã§ã™ãŒã€ä»£å…¥å‡¦ç†è‡ªä½“ã¯èµ·ãã¦ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:1413
msgid "Thus, in our tuple example what is happening is equivalent to::"
msgstr "å¾“ã£ã¦ã€ä»Šã®ã‚¿ãƒ—ãƒ«ã®ä¾‹ã§ã¯ã€æ¬¡ã®ã¨åŒã˜ã“ã¨ãŒèµ·ãã¦ã„ã¾ã™::"

#: ../../faq/programming.rst:1421
msgid ""
"The ``__iadd__`` succeeds, and thus the list is extended, but even though "
"``result`` points to the same object that ``a_tuple[0]`` already points to, "
"that final assignment still results in an error, because tuples are "
"immutable."
msgstr "``__iadd__`` ã¯æˆåŠŸã—ã€ãƒªã‚¹ãƒˆã¯æ‹¡å¼µ (extend) ã•ã‚Œã¾ã™ãŒã€``result`` ãŒ ``a_tuple[0]`` ãŒæ—¢ã«æŒ‡ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã—ã¦ã„ãŸã¨ã—ã¦ã‚‚ã€ã‚¿ãƒ—ãƒ«ã¯ä¸å¤‰ãªã®ã§ã€ãã®æœ€å¾Œã®ä»£å…¥ã¯ã‚„ã¯ã‚Šã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:1427
msgid "Dictionaries"
msgstr "è¾æ›¸"

#: ../../faq/programming.rst:1430
msgid "How can I get a dictionary to display its keys in a consistent order?"
msgstr "ä¸€è²«ã—ãŸé †åºã§ã‚­ãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹è¾æ›¸ã¯ã‚ã‚Šã¾ã™ã‹?"

#: ../../faq/programming.rst:1432
msgid ""
"You can't.  Dictionaries store their keys in an unpredictable order, so the "
"display order of a dictionary's elements will be similarly unpredictable."
msgstr "ã§ãã¾ã›ã‚“ã€‚è¾æ›¸ã¯ã‚­ãƒ¼ã‚’äºˆæ¸¬ã§ããªã„é †åºã§ä¿å­˜ã—ã¦ã„ã‚‹ã®ã§ã€è¾æ›¸ã®è¦ç´ ãŒè¡¨ç¤ºã•ã‚Œã‚‹é †åºã‚‚ã¾ãŸäºˆæ¸¬ã§ããªã„ã®ã§ã™ã€‚"

#: ../../faq/programming.rst:1435
msgid ""
"This can be frustrating if you want to save a printable version to a file, "
"make some changes and then compare it with some other printed dictionary.  "
"In this case, use the ``pprint`` module to pretty-print the dictionary; the "
"items will be presented in order sorted by the key."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã«å°å­—å¯èƒ½ãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä¿å­˜ã—ã€å¤‰æ›´ã‚’åŠ ãˆã¦ã‹ã‚‰ä»–ã®å°å­—ã•ã‚ŒãŸè¾æ›¸ã¨æ¯”è¼ƒã—ãŸã„æ™‚ã«è‹›ç«‹ãŸã—ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã®å ´åˆã¯ã€ ``pprint`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§è¾æ›¸ã‚’æ•´å½¢ã—ã¦è¡¨ç¤ºã—ã¦ãã ã•ã„ã€‚è¦ç´ ãŒã‚­ãƒ¼ã§ã‚½ãƒ¼ãƒˆã•ã‚Œã¦è¡¨ã•ã‚Œã¾ã™ã€‚"

#: ../../faq/programming.rst:1440
msgid ""
"A more complicated solution is to subclass ``dict`` to create a "
"``SortedDict`` class that prints itself in a predictable order.  Here's one "
"simpleminded implementation of such a class::"
msgstr "ã‚‚ã£ã¨è¤‡é›‘ãªè§£æ±ºç­–ã¯ã€ ``dict`` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã¨ã—ã¦ ``SortedDict`` ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚Šã€ãã‚Œã«äºˆæ¸¬å¯èƒ½ãªé †åºã§è‡ªèº«ã‚’è¡¨ç¤ºã•ã›ã‚‹ã“ã¨ã§ã™ã€‚ãã®ã‚ˆã†ãªã‚¯ãƒ©ã‚¹ã®å˜ç´”ãªå®Ÿè£…ã®ä¸€ã¤ã¯::"

#: ../../faq/programming.rst:1452
msgid ""
"This will work for many common situations you might encounter, though it's "
"far from a perfect solution. The largest flaw is that if some values in the "
"dictionary are also dictionaries, their values won't be presented in any "
"particular order."
msgstr "ã“ã‚Œã¯å®Œç’§ãªè§£æ³•ã¨ã¯ç¨‹é ã„ã§ã™ãŒã€å¤šãã®çŠ¶æ³ã§ã†ã¾ãåƒãã§ã—ã‚‡ã†ã€‚æœ€å¤§ã®æ¬ ç‚¹ã¯ã€è¾æ›¸å†…ã®ã©ã‚Œã‹ã®å€¤ãŒã¾ãŸè¾æ›¸ã§ã‚ã£ãŸå ´åˆã«ã€ãã‚Œã‚‰ã®å€¤ã¯ã©ã‚“ãªç‰¹å®šã®é †åºã§ã‚‚è¡¨ç¤ºã•ã‚Œãªã„ã“ã¨ã§ã™ã€‚"

#: ../../faq/programming.rst:1459
msgid ""
"I want to do a complicated sort: can you do a Schwartzian Transform in "
"Python?"
msgstr "è¤‡é›‘ãªã‚½ãƒ¼ãƒˆãŒã—ãŸã„ã®ã§ã™ãŒã€Python ã§ã‚·ãƒ¥ãƒ¯ãƒ«ãƒ„å¤‰æ›ã¯ã§ãã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1461
msgid ""
"The technique, attributed to Randal Schwartz of the Perl community, sorts "
"the elements of a list by a metric which maps each element to its \"sort "
"value\". In Python, use the ``key`` argument for the :func:`sort()` "
"function::"
msgstr "Perl ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã® Randal Schwartz ã®ä½œã¨ã•ã‚Œã‚‹ã“ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã¯ã€ãã‚Œãã‚Œã®è¦ç´ ã«ã€Œã‚½ãƒ¼ãƒˆå€¤ã€ã‚’å¯¾å¿œä»˜ã‘ã‚‹ã‚ã‚‹å°ºåº¦ã«ã‚ˆã£ã¦ã€ãƒªã‚¹ãƒˆã®è¦ç´ ã‚’ã‚½ãƒ¼ãƒˆã—ã¾ã™ã€‚\nPython ã§ã¯ã€ :func:`sort()` é–¢æ•°ã§ ``key`` å¼•æ•°ã‚’ä½¿ã£ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:1470
msgid "How can I sort one list by values from another list?"
msgstr "ãƒªã‚¹ãƒˆã‚’åˆ¥ã®ãƒªã‚¹ãƒˆã®å€¤ã«ã‚ˆã£ã¦ã‚½ãƒ¼ãƒˆã™ã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1472
msgid ""
"Merge them into a single list of tuples, sort the resulting list, and then "
"pick out the element you want. ::"
msgstr "äºŒã¤ã®ãƒªã‚¹ãƒˆã‚’æ··ãœã‚ã‚ã›ã¦ã‚¿ãƒ—ãƒ«ã®ãƒªã‚¹ãƒˆã«ã—ã¦ã‹ã‚‰ã€å¿…è¦ãªè¦ç´ ã‚’é¸ã‚“ã§ãã ã•ã„::"

#: ../../faq/programming.rst:1485
msgid "An alternative for the last step is::"
msgstr "æœ€å¾Œã®æ®µéšã®åˆ¥ã®ã‚„ã‚Šæ–¹ã¯::"

#: ../../faq/programming.rst:1490
msgid ""
"If you find this more legible, you might prefer to use this instead of the "
"final list comprehension.  However, it is almost twice as slow for long "
"lists.  Why? First, the ``append()`` operation has to reallocate memory, and"
" while it uses some tricks to avoid doing that each time, it still has to do"
" it occasionally, and that costs quite a bit.  Second, the expression "
"\"result.append\" requires an extra attribute lookup, and third, there's a "
"speed reduction from having to make all those function calls."
msgstr "ã“ã‚Œã®ã»ã†ãŒèª­ã¿ã‚„ã™ã„ã¨ã€æœ€å¾Œã®ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã§ã¯ãªãã“ã‚Œã‚’ä½¿ã„ãŸããªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ã“ã‚Œã¯é•·ã„ãƒªã‚¹ãƒˆã§ã¯ã»ã¼äºŒå€ã®æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™ã€‚ãªãœã§ã—ã‚‡ã†ã‹ã€‚ã¾ãšã€``append()`` æ¼”ç®—ã¯ãƒ¡ãƒ¢ãƒªã‚’å‰²ã‚Šå½“ã¦ç›´ã™å¿…è¦ãŒã‚ã‚Šã€ãã‚Œã‚’é¿ã‘ã‚‹ãŸã‚ã«æ¯å›ã¡ã‚‡ã£ã¨å·¥å¤«ã—ã¦ã„ã¾ã™ãŒã€ãã‚Œã§ã‚‚é¿ã‘ã‚‰ã‚Œãªã„ã“ã¨ãŒã‚ã‚‹ã®ã§ã€å°‘ã—æ™‚é–“ãŒã‹ã‹ã‚‹ã®ã§ã™ã€‚äºŒã¤ç›®ã«ã€\"result.append\" ã«ã¯å±æ€§æ¢ç´¢ãŒä½™è¨ˆã«å¿…è¦ã§ã€ä¸‰ã¤ç›®ã«ã€ã“ã‚Œã‚‰ã™ã¹ã¦ã®é–¢æ•°ã‚’å‘¼ã¶å¿…è¦ãŒã‚ã‚‹ã“ã¨ã§é€Ÿåº¦ãŒè½ã¡ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:1500
msgid "Objects"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../faq/programming.rst:1503
msgid "What is a class?"
msgstr "ã‚¯ãƒ©ã‚¹ã¨ã¯ä½•ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1505
msgid ""
"A class is the particular object type created by executing a class "
"statement. Class objects are used as templates to create instance objects, "
"which embody both the data (attributes) and code (methods) specific to a "
"datatype."
msgstr "ã‚¯ãƒ©ã‚¹ã¯ã€class æ–‡ã®å®Ÿè¡Œã§ç”Ÿæˆã•ã‚Œã‚‹ç‰¹æ®Šãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¨ã—ã¦ä½¿ã‚ã‚Œã€ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿å‹ã«ç‰¹æœ‰ã®ãƒ‡ãƒ¼ã‚¿ (attribute/å±æ€§) ã¨ã‚³ãƒ¼ãƒ‰ (ãƒ¡ã‚½ãƒƒãƒ‰) ã®ä¸¡æ–¹ã‚’å†…è”µã—ã¦ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:1509
msgid ""
"A class can be based on one or more other classes, called its base "
"class(es). It then inherits the attributes and methods of its base classes. "
"This allows an object model to be successively refined by inheritance.  You "
"might have a generic ``Mailbox`` class that provides basic accessor methods "
"for a mailbox, and subclasses such as ``MboxMailbox``, ``MaildirMailbox``, "
"``OutlookMailbox`` that handle various specific mailbox formats."
msgstr "æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚’ä¸€ã¤ä»¥ä¸Šã®ä»–ã®ã‚¯ãƒ©ã‚¹ (æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã¨å‘¼ã°ã‚Œã¾ã™) ã«åŸºã¥ã„ã¦ä½œã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã“ã®æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã¯ã€åŸºåº•ã‚¯ãƒ©ã‚¹ã‹ã‚‰å±æ€§ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ¢ãƒ‡ãƒ«ã‚’ç¶™æ‰¿ã§é€£ç¶šçš„ã«æ´—ç·´ã§ãã¾ã™ã€‚ãƒ¡ãƒ¼ãƒ«ãƒœãƒƒã‚¯ã‚¹ã¸ã®åŸºæœ¬çš„ãªã‚¢ã‚¯ã‚»ã‚µã‚’æä¾›ã™ã‚‹ä¸€èˆ¬çš„ãª ``Mailbox`` ã‚¯ãƒ©ã‚¹ã‚’ä½œã£ã¦ã€ãã‚Œã‹ã‚‰ã„ã‚ã„ã‚ãªç‰¹å®šã®ãƒ¡ãƒ¼ãƒ«ãƒœãƒƒã‚¯ã‚¹ã®å½¢å¼ã‚’æ‰±ã† ``MboxMailbox``ã€``MaildirMailbox``ã€``OutlookMailbox`` ã®ã‚ˆã†ãªã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚Œã‚‹ã®ã§ã™ã€‚"

#: ../../faq/programming.rst:1518
msgid "What is a method?"
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã¯ä½•ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1520
msgid ""
"A method is a function on some object ``x`` that you normally call as "
"``x.name(arguments...)``.  Methods are defined as functions inside the class"
" definition::"
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ``x`` ãŒæŒã¤é–¢æ•°ã§ã€é€šå¸¸ ``x.name(arguments...)`` ã¨ã—ã¦å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚‚ã®ã§ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¯ãƒ©ã‚¹å®šç¾©ã®ä¸­ã§é–¢æ•°ã¨ã—ã¦å®šç¾©ã•ã‚Œã¾ã™::"

#: ../../faq/programming.rst:1530
msgid "What is self?"
msgstr "self ã¨ã¯ä½•ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1532
msgid ""
"Self is merely a conventional name for the first argument of a method.  A "
"method defined as ``meth(self, a, b, c)`` should be called as ``x.meth(a, b,"
" c)`` for some instance ``x`` of the class in which the definition occurs; "
"the called method will think it is called as ``meth(x, a, b, c)``."
msgstr "self ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã®ç¬¬ä¸€å¼•æ•°ã«æ…£ç¿’çš„ã«ã¤ã‘ã‚‰ã‚Œã‚‹åå‰ã«ã™ãã¾ã›ã‚“ã€‚``meth(self, a, b, c)`` ã¨ã—ã¦å®šç¾©ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãã®å®šç¾©ãŒãªã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ ``x`` ã«å¯¾ã—ã¦ ``x.meth(a, b, c)`` ã¨ã—ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚å‘¼ã³å‡ºã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€``meth(x, a, b, c)`` ãŒå‘¼ã°ã‚ŒãŸã‚‚ã®ã¨è€ƒãˆã¾ã™ã€‚"

#: ../../faq/programming.rst:1537
msgid "See also :ref:`why-self`."
msgstr ":ref:`why-self` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/programming.rst:1541
msgid ""
"How do I check if an object is an instance of a given class or of a subclass"
" of it?"
msgstr "ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã€ä¸ãˆã‚‰ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚„ãã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹ã‹ã‚’èª¿ã¹ã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1543
msgid ""
"Use the built-in function ``isinstance(obj, cls)``.  You can check if an "
"object is an instance of any of a number of classes by providing a tuple "
"instead of a single class, e.g. ``isinstance(obj, (class1, class2, ...))``, "
"and can also check whether an object is one of Python's built-in types, e.g."
" ``isinstance(obj, str)`` or ``isinstance(obj, (int, long, float, "
"complex))``."
msgstr "ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•° ``isinstance(obj, cls)`` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ã‚¯ãƒ©ã‚¹ã®ã‚¿ãƒ—ãƒ«ã‚’ä¸ãˆã¦ ``isinstance(obj, (class1, class2, ...))`` ã®ã‚ˆã†ã«ã™ã‚Œã°ã€ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä»»æ„ã®æ•°ã®ã‚¯ãƒ©ã‚¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã‹ã‚’èª¿ã¹ã‚‰ã‚Œã¾ã™ã—ã€ ``isinstance(obj, str)`` ã‚„ ``isinstance(obj, (int, long, float, complex))`` ã®ã‚ˆã†ã«ã™ã‚Œã°ã€Python ã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã‹ã‚‚èª¿ã¹ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../faq/programming.rst:1549
msgid ""
"Note that most programs do not use :func:`isinstance` on user-defined "
"classes very often.  If you are developing the classes yourself, a more "
"proper object-oriented style is to define methods on the classes that "
"encapsulate a particular behaviour, instead of checking the object's class "
"and doing a different thing based on what class it is.  For example, if you "
"have a function that does something::"
msgstr "ãªãŠã€å¤§éƒ¨åˆ†ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã€ :func:`isinstance` ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ã®ã‚¯ãƒ©ã‚¹ã«ä½•åº¦ã‚‚ä½¿ã†ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¹ã‚’è‡ªåˆ†ã§é–‹ç™ºã™ã‚‹ã¨ãã«ã€é©åˆ‡ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã‚¹ã‚¿ã‚¤ãƒ«ã¯ã€ç‰¹å®šã®æŒ¯ã‚‹èˆã„ã‚’ã‚«ãƒ—ã‚»ãƒ«åŒ–ã™ã‚‹ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã™ã‚‹ã‚‚ã®ã§ã‚ã£ã¦ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¯ãƒ©ã‚¹ã‚’èª¿ã¹ã¦ãã®ã‚¯ãƒ©ã‚¹ã«å¿œã˜ã¦é•ã†ã“ã¨ã‚’ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ä½•ã‹ã‚’ã™ã‚‹é–¢æ•°ãŒã‚ã£ãŸã¨ã—ã¦::"

#: ../../faq/programming.rst:1563
msgid ""
"A better approach is to define a ``search()`` method on all the classes and "
"just call it::"
msgstr "ã‚ˆã‚Šã‚ˆã„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã€``search()`` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã™ã¹ã¦ã®ã‚¯ãƒ©ã‚¹ã«å®šç¾©ã—ã¦ã€ãã‚Œã‚’ãŸã å‘¼ã³å‡ºã™ã“ã¨ã§ã™::"

#: ../../faq/programming.rst:1578
msgid "What is delegation?"
msgstr "å§”è­²ã¨ã¯ä½•ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1580
msgid ""
"Delegation is an object oriented technique (also called a design pattern). "
"Let's say you have an object ``x`` and want to change the behaviour of just "
"one of its methods.  You can create a new class that provides a new "
"implementation of the method you're interested in changing and delegates all"
" other methods to the corresponding method of ``x``."
msgstr "å§”è­² (delegation) ã¨ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ (ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã‚‚å‘¼ã°ã‚Œã‚‹) ã®ä¸€ã¤ã§ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ``x`` ãŒã‚ã£ã¦ã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ã†ã¡ãŸã ä¸€ã¤ã®æŒ¯ã‚‹èˆã„ã‚’å¤‰ãˆãŸã„ã¨ã—ã¾ã—ã‚‡ã†ã€‚æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ã€å¤‰ãˆãŸã„ãƒ¡ã‚½ãƒƒãƒ‰ã ã‘ã‚’æ–°ã—ãå®Ÿè£…ã—ã€ä»–ã®ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ ``x`` ã®å¯¾å¿œã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã«å§”è­²ã™ã‚‹æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚Œã¾ã™ã€‚"

#: ../../faq/programming.rst:1586
msgid ""
"Python programmers can easily implement delegation.  For example, the "
"following class implements a class that behaves like a file but converts all"
" written data to uppercase::"
msgstr "Python ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ç°¡å˜ã«å§”è­²ã‚’å®Ÿè£…ã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ã®ã‚¯ãƒ©ã‚¹ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã„ãªãŒã‚‰ã™ã¹ã¦ã®æ–‡å­—ã‚’å¤§æ–‡å­—ã«å¤‰æ›ã™ã‚‹ã‚¯ãƒ©ã‚¹ã‚’å®Ÿè£…ã—ã¾ã™::"

#: ../../faq/programming.rst:1601
msgid ""
"Here the ``UpperOut`` class redefines the ``write()`` method to convert the "
"argument string to uppercase before calling the underlying "
"``self.__outfile.write()`` method.  All other methods are delegated to the "
"underlying ``self.__outfile`` object.  The delegation is accomplished via "
"the ``__getattr__`` method; consult :ref:`the language reference <attribute-"
"access>` for more information about controlling attribute access."
msgstr "ã“ã“ã§ ``UpperOut`` ã‚¯ãƒ©ã‚¹ã¯ ``write()`` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ãªãŠã—ã¦ã€å¼•æ•°ã®æ–‡å­—åˆ—ã‚’å¤§æ–‡å­—ã«å¤‰æ›ã—ã¦ã‹ã‚‰åŸºç¤ã¨ãªã‚‹ ``self.__outfile.write()`` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«ã—ã¾ã™ã€‚ãã®ä»–ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯åŸºç¤ã¨ãªã‚‹ ``self.__outfile`` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ç§»è­²ã•ã‚Œã¾ã™ã€‚ã“ã®å§”è­²ã¯ ``__getattr__`` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’é€šã—ã¦ãªã•ã‚Œã¾ã™ã€‚å±æ€§ã®åˆ¶å¾¡ã®è©³ç´°ã¯ :ref:`è¨€èªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ <attribute-access>` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/programming.rst:1608
msgid ""
"Note that for more general cases delegation can get trickier. When "
"attributes must be set as well as retrieved, the class must define a "
":meth:`__setattr__` method too, and it must do so carefully.  The basic "
"implementation of :meth:`__setattr__` is roughly equivalent to the "
"following::"
msgstr "ãªãŠã€ä¸€èˆ¬çš„ã«å§”è­²ã¯ãƒˆãƒªãƒƒã‚­ãƒ¼ã«ãªã‚ŠãŒã¡ã§ã™ã€‚å±æ€§ãŒè¨­å®šã•ã‚Œã‚‹æ™‚ã«ã¯èª­ã¿å‡ºã•ã‚Œã‚‹æ™‚ã¨åŒæ§˜ã«ã€ãã®ã‚¯ãƒ©ã‚¹ã« :meth:`__setattr__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€ãã‚Œã«ã¯ç´°å¿ƒã®æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚ :meth:`__setattr__` ã®åŸºæœ¬çš„ãªå®Ÿè£…ã¯ãŠãŠã‚ˆãä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../faq/programming.rst:1619
msgid ""
"Most :meth:`__setattr__` implementations must modify ``self.__dict__`` to "
"store local state for self without causing an infinite recursion."
msgstr "ãŸã„ã¦ã„ã€ :meth:`__setattr__` å®Ÿè£…ã¯ ``self.__dict__`` ã‚’å¤‰æ›´ã—ã¦ã€ç„¡é™å†å¸°ã‚’èµ·ã“ã™ã“ã¨ãªããƒ­ãƒ¼ã‚«ãƒ«ãªçŠ¶æ…‹ã‚’ä¿å­˜ã™ã‚‹ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../faq/programming.rst:1624
msgid ""
"How do I call a method defined in a base class from a derived class that "
"overrides it?"
msgstr "åŸºåº•ã‚¯ãƒ©ã‚¹ã§å®šç¾©ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã€ãã®ã‚¯ãƒ©ã‚¹ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ãŸæ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã‹ã‚‰å‘¼ã³å‡ºã™ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1626
msgid ""
"If you're using new-style classes, use the built-in :func:`super` function::"
msgstr "æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã£ã¦ã„ã‚‹å ´åˆã¯ã€çµ„ã¿è¾¼ã¿ã® :func:`super` é–¢æ•°ã‚’ä½¿ã£ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:1632
msgid ""
"If you're using classic classes: For a class definition such as ``class "
"Derived(Base): ...`` you can call method ``meth()`` defined in ``Base`` (or "
"one of ``Base``'s base classes) as ``Base.meth(self, arguments...)``.  Here,"
" ``Base.meth`` is an unbound method, so you need to provide the ``self`` "
"argument."
msgstr "æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã£ã¦ã„ã‚‹ãªã‚‰: ``class Derived(Base): ...`` ã®ã‚ˆã†ãªã‚¯ãƒ©ã‚¹å®šç¾©ã§ã€ ``Base.meth(self, arguments...)`` ã¨ã™ã‚Œã°ã€ ``Base`` (ã¾ãŸã¯ ``Base`` ã®åŸºåº•ã‚¯ãƒ©ã‚¹) ã§å®šç¾©ã•ã‚ŒãŸ ``meth()`` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã›ã¾ã™ã€‚ã“ã“ã§ã€ ``Base.meth`` ã¯æŸç¸›ã•ã‚Œã¦ã„ãªã„ãƒ¡ã‚½ãƒƒãƒ‰ãªã®ã§ã€ ``self`` å¼•æ•°ã‚’æ¸¡ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:1640
msgid "How can I organize my code to make it easier to change the base class?"
msgstr "åŸºåº•ã‚¯ãƒ©ã‚¹ã®åå‰ã‚’å¤‰ãˆã‚„ã™ã„ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1642
msgid ""
"You could define an alias for the base class, assign the real base class to "
"it before your class definition, and use the alias throughout your class.  "
"Then all you have to change is the value assigned to the alias.  "
"Incidentally, this trick is also handy if you want to decide dynamically "
"(e.g. depending on availability of resources) which base class to use.  "
"Example::"
msgstr "åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ (alias) ã‚’å®šç¾©ã—ã€å…ˆã«ãã‚Œã«æœ¬å½“ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’ä»£å…¥ã—ã¦ãŠã„ã¦ã‹ã‚‰ã€ã‚¯ãƒ©ã‚¹å®šç¾©ã®ä¸­ã§ãã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚’ä½¿ã†ã¨ã„ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãã†ã™ã‚Œã°ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã«ä»£å…¥ã™ã‚‹å€¤ã‚’å¤‰ãˆã‚‹ã ã‘ã§æ¸ˆã¿ã¾ã™ã€‚ã¡ãªã¿ã«ã€ã“ã®æ‰‹æ³•ã¯ä½¿ç”¨ã™ã‚‹åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’å‹•çš„ã«é¸ã³ãŸã„ã¨ãã€ä¾‹ãˆã°ä½¿ãˆã‚‹ãƒªã‚½ãƒ¼ã‚¹ã«ã‚ˆã£ã¦é¸ã³ãŸã„ã¨ããªã©ã«ã‚‚ä¾¿åˆ©ã§ã™ã€‚ä¾‹::"

#: ../../faq/programming.rst:1657
msgid "How do I create static class data and static class methods?"
msgstr "é™çš„ãªã‚¯ãƒ©ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚„é™çš„ãªã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½œã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1659
msgid ""
"Both static data and static methods (in the sense of C++ or Java) are "
"supported in Python."
msgstr "(C++ ã‚„ Java ã®æ„å‘³ã§) é™çš„ãªãƒ‡ãƒ¼ã‚¿ã‚‚é™çš„ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ Python ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:1662
msgid ""
"For static data, simply define a class attribute.  To assign a new value to "
"the attribute, you have to explicitly use the class name in the assignment::"
msgstr "é™çš„ãªãƒ‡ãƒ¼ã‚¿ã‚’ä½œã‚‹ã«ã¯ã€å˜ç´”ã«ã‚¯ãƒ©ã‚¹å±æ€§ã‚’å®šç¾©ã—ã¦ãã ã•ã„ã€‚ãã®å±æ€§ã«æ–°ã—ã„å€¤ã‚’ä»£å…¥ã™ã‚‹ã«ã¯ã€ä»£å…¥ã™ã‚‹ã‚¯ãƒ©ã‚¹åã‚’æ˜ç¤ºã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™::"

#: ../../faq/programming.rst:1674
msgid ""
"``c.count`` also refers to ``C.count`` for any ``c`` such that "
"``isinstance(c, C)`` holds, unless overridden by ``c`` itself or by some "
"class on the base-class search path from ``c.__class__`` back to ``C``."
msgstr "``c`` ãã®ã‚‚ã®ã‚„ ``c.__class__`` ã‹ã‚‰ ``C`` ã«ã„ãŸã‚‹ãƒ‘ã‚¹æ¢ç´¢çµŒè·¯ä¸Šã®ã‚¯ãƒ©ã‚¹ã«ã‚ˆã£ã¦ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã•ã‚Œãªã„é™ã‚Šã€``c.count`` ã‚‚ ``isinstance(c, C)`` ã§ã‚ã‚‹ã™ã¹ã¦ã® ``c`` ã«å¯¾ã™ã‚‹ ``C.count`` ã‚’å‚ç…§ã—ã¾ã™ã€‚"

#: ../../faq/programming.rst:1678
msgid ""
"Caution: within a method of C, an assignment like ``self.count = 42`` "
"creates a new and unrelated instance named \"count\" in ``self``'s own dict."
"  Rebinding of a class-static data name must always specify the class "
"whether inside a method or not::"
msgstr "æ³¨æ„: C ã®ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ã¯ã€``self.count = 42`` ã®ã‚ˆã†ãªä»£å…¥ã¯ ``self`` è‡ªèº«ã®è¾æ›¸ã« \"count\" ã¨ã„ã†åå‰ã®æ–°ã—ãã¦é–¢ä¿‚ãªã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚Šã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã®é™çš„ãªãƒ‡ãƒ¼ã‚¿ã®å†æŸç¸›ã«ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ã‚ã‚‹ã‹å¦ã‹ã«ã‹ã‹ã‚ã‚‰ãšã€ã„ã¤ã‚‚ã‚¯ãƒ©ã‚¹ã‚’æŒ‡å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“::"

#: ../../faq/programming.rst:1685
msgid "Static methods are possible since Python 2.2::"
msgstr "Python 2.2 ã‹ã‚‰ã¯ã€é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ãŒä½¿ãˆã¾ã™::"

#: ../../faq/programming.rst:1693
msgid "With Python 2.4's decorators, this can also be written as ::"
msgstr "Python 2.4 ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ã£ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚‚æ›¸ã‘ã¾ã™::"

#: ../../faq/programming.rst:1701
msgid ""
"However, a far more straightforward way to get the effect of a static method"
" is via a simple module-level function::"
msgstr "ã—ã‹ã—ã€é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã®åŠ¹æœã‚’å¾—ã‚‹ã‚‚ã£ã¨ç°¡å˜ãªæ–¹æ³•ã¯ã€å˜ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«é–¢æ•°ã‚’ä½¿ã†ã“ã¨ã§ã™::"

#: ../../faq/programming.rst:1707
msgid ""
"If your code is structured so as to define one class (or tightly related "
"class hierarchy) per module, this supplies the desired encapsulation."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ãŸã‚Šã«ä¸€ã¤ã®ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã™ã‚‹ã‚ˆã†ã« (ã‚ã‚‹ã„ã¯ã‚¯ãƒ©ã‚¹çµ„ç¹”ã‚’å³å¯†ã«é–¢é€£ã•ã›ã‚‹ã‚ˆã†ã«) ã‚³ãƒ¼ãƒ‰ãŒæ§‹æˆã•ã‚Œã¦ã„ã‚‹ãªã‚‰ã€ã“ã‚Œã§å¿…è¦ãªã‚«ãƒ—ã‚»ãƒ«åŒ–ãŒã§ãã¾ã™ã€‚"

#: ../../faq/programming.rst:1712
msgid "How can I overload constructors (or methods) in Python?"
msgstr "Python ã§ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿(ã‚„ãƒ¡ã‚½ãƒƒãƒ‰)ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã«ã¯ã©ã†ã—ãŸã‚‰ã„ã„ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1714
msgid ""
"This answer actually applies to all methods, but the question usually comes "
"up first in the context of constructors."
msgstr "ã“ã®è³ªå•ã®ç­”ãˆã¯ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¤ã„ã¦è¨€ãˆã‚‹ã“ã¨ã§ã™ãŒã€ã“ã®è³ªå•ã¯ã ã„ãŸã„ä»¥ä¸‹ã®æ§‹é€ ã®æ–‡è„ˆã‹ã‚‰å‡ºã¦ãã¾ã™ã€‚"

#: ../../faq/programming.rst:1717
msgid "In C++ you'd write"
msgstr "C++ ã§ã¯ã€ã“ã®ã‚ˆã†ã«æ›¸ã‘ã¾ã™"

#: ../../faq/programming.rst:1726
msgid ""
"In Python you have to write a single constructor that catches all cases "
"using default arguments.  For example::"
msgstr "Python ã§ã¯ã€ä¸€ã¤ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å¼•æ•°ã‚’ä½¿ã£ã¦ã™ã¹ã¦ã®å ´åˆã«å¯¾å¿œã™ã‚‹ã‚ˆã†ã«æ›¸ã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°::"

#: ../../faq/programming.rst:1736
msgid "This is not entirely equivalent, but close enough in practice."
msgstr "ã“ã‚Œã§å®Œå…¨ã«ç­‰ä¾¡ã¨ã¯è¨€ãˆã¾ã›ã‚“ãŒã€å®Ÿç”¨ä¸Šã¯ååˆ†ã«è¿‘ã„ã§ã™ã€‚"

#: ../../faq/programming.rst:1738
msgid "You could also try a variable-length argument list, e.g. ::"
msgstr "é•·ã•ãŒå¤‰ãˆã‚‰ã‚Œã‚‹å¼•æ•°ã®ãƒªã‚¹ãƒˆã‚’è©¦ã™ã«ã¯ã€ä¾‹ãˆã° ::"

#: ../../faq/programming.rst:1743
msgid "The same approach works for all method definitions."
msgstr "ã“ã‚Œã¨åŒã˜ã‚„ã‚Šæ–¹ãŒã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ã§ä½¿ãˆã¾ã™ã€‚"

#: ../../faq/programming.rst:1747
msgid "I try to use __spam and I get an error about _SomeClassName__spam."
msgstr "__spam ã‚’ä½¿ãŠã†ã¨ã—ãŸã‚‰ _SomeClassName__spam ã‹ã‚‰ã‚¨ãƒ©ãƒ¼ãŒã§ã¾ã—ãŸã€‚"

#: ../../faq/programming.rst:1749
msgid ""
"Variable names with double leading underscores are \"mangled\" to provide a "
"simple but effective way to define class private variables.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with any leading underscores "
"stripped."
msgstr "å…ˆé ­ã«ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ãŒäºŒã¤ä»˜ã„ãŸå¤‰æ•°åã¯ã€ã‚¯ãƒ©ã‚¹ã®ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªå¤‰æ•°ã‚’ã€\"ãƒãƒ³ã‚°ãƒ«åŒ–\"ã¨ã„ã†å˜ç´”ã‹ã¤åŠ¹ç‡ã®ã„ã„æ–¹æ³•ã§å®šç¾©ã—ã¾ã™ã€‚``__spam`` ã®ã‚ˆã†ãªå½¢å¼ (å…ˆé ­ã«äºŒã¤ä»¥ä¸Šã€æœ«å°¾ã«ã‚‚ã—ã‚ã£ã¦ã‚‚ä¸€ã¤ã®ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ãŒã‚ã‚‹) ã®ã™ã¹ã¦ã®è­˜åˆ¥å­ã¯ã€``classname`` ãŒå…ˆé ­ã®ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã‚’ã™ã¹ã¦å‰Šé™¤ã—ãŸç¾åœ¨ã®ã‚¯ãƒ©ã‚¹åã¨ã™ã‚Œã°ã€``_classname__spam`` ã®ã‚ˆã†ã«æ–‡å­—ä¸Šã§ç½®æ›ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../faq/programming.rst:1755
msgid ""
"This doesn't guarantee privacy: an outside user can still deliberately "
"access the \"_classname__spam\" attribute, and private values are visible in"
" the object's ``__dict__``.  Many Python programmers never bother to use "
"private variable names at all."
msgstr "ã“ã‚Œã¯ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã§ã‚‚å¤–éƒ¨ã®ãƒ¦ãƒ¼ã‚¶ãŒ \"_classname__spam\" å±æ€§ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã—ã€ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªå¤‰æ•°ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® ``__dict__`` ã‹ã‚‰è¦‹ãˆã¾ã™ã€‚å¤šãã® Python ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ã‚ã–ã‚ã–ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªå¤‰æ•°åã‚’ä½¿ãŠã†ã¨ãªã©è€ƒãˆã¾ã›ã‚“ã€‚"

#: ../../faq/programming.rst:1762
msgid ""
"My class defines __del__ but it is not called when I delete the object."
msgstr "ã‚¯ãƒ©ã‚¹ã« __del__ ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã®ã§ã™ãŒã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤ã—ãŸã¨ãã«å‘¼ã°ã‚Œã¾ã›ã‚“ã€‚"

#: ../../faq/programming.rst:1764
msgid "There are several possible reasons for this."
msgstr "ã„ãã¤ã‹ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:1766
msgid ""
"The del statement does not necessarily call :meth:`__del__` -- it simply "
"decrements the object's reference count, and if this reaches zero "
":meth:`__del__` is called."
msgstr "del æ–‡ã¯å¿…ãšã—ã‚‚ :meth:`__del__` ã‚’å‘¼ã³å‡ºã™ã¨ã¯é™ã‚Šã¾ã›ã‚“ -- ã“ã‚Œã¯å˜ç´”ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™ã‚‚ã®ã§ã€ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«ãªã£ãŸã¨ãã« :meth:`__del__` ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../faq/programming.rst:1770
msgid ""
"If your data structures contain circular links (e.g. a tree where each child"
" has a parent reference and each parent has a list of children) the "
"reference counts will never go back to zero.  Once in a while Python runs an"
" algorithm to detect such cycles, but the garbage collector might run some "
"time after the last reference to your data structure vanishes, so your "
":meth:`__del__` method may be called at an inconvenient and random time. "
"This is inconvenient if you're trying to reproduce a problem. Worse, the "
"order in which object's :meth:`__del__` methods are executed is arbitrary.  "
"You can run :func:`gc.collect` to force a collection, but there *are* "
"pathological cases where objects will never be collected."
msgstr "ãƒ‡ãƒ¼ã‚¿æ§‹é€ ãŒå¾ªç’°ãƒªãƒ³ã‚¯ (å­ã®ãã‚Œãã‚ŒãŒè¦ªã®å‚ç…§ã‚’æŒã¡ã€è¦ªã®ãã‚Œãã‚ŒãŒå­ã®ãƒªã‚¹ãƒˆã‚’æŒã¤ãƒ„ãƒªãƒ¼ãªã©) ã‚’å«ã‚€å ´åˆã€ãã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¯æ±ºã—ã¦ 0 ã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚æ™‚ã€…ã€Python ã¯ã“ã®ã‚ˆã†ãªã‚µã‚¤ã‚¯ãƒ«ã‚’æ¤œå‡ºã™ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè¡Œã—ã¾ã™ãŒã€ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¸ã®å‚ç…§ãŒãªããªã£ã¦ã‹ã‚‰ã“ã®ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¾ã§ã„ãã‚‰ã‹æ™‚é–“ãŒæ›ã‹ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã€ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä¸éƒ½åˆãªäºˆæœŸã§ããªã„ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å‘¼ã³å‡ºã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã¯å•é¡Œã‚’å†ç¾ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ãã«ä¸ä¾¿ã§ã™ã€‚ã•ã‚‰ã«æ‚ªã„ã“ã¨ã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®Ÿè¡Œã•ã‚Œã‚‹é †åºã¯ä»»æ„ã§ã™ã€‚ :func:`gc.collect` ã‚’èµ·å‹•ã—ã¦åé›†ã‚’å¼·åˆ¶ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ±ºã—ã¦å›åã•ã‚Œãªã„ã‚ˆã†ãªæœ¬å½“ã«ç—…çš„ãªå ´åˆã‚‚ *ã‚ã‚Šã¾ã™* ã€‚"

#: ../../faq/programming.rst:1781
msgid ""
"Despite the cycle collector, it's still a good idea to define an explicit "
"``close()`` method on objects to be called whenever you're done with them.  "
"The ``close()`` method can then remove attributes that refer to subobjecs.  "
"Don't call :meth:`__del__` directly -- :meth:`__del__` should call "
"``close()`` and ``close()`` should make sure that it can be called more than"
" once for the same object."
msgstr "å‘¨æœŸçš„ãªã‚³ãƒ¬ã‚¯ã‚¿ã«ã‹ã‹ã‚ã‚‰ãšã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã« ``close()`` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ˜ç¤ºçš„ã«å®šç¾©ã—ã€ä½¿ã„çµ‚ã‚ã£ãŸã‚‰ã„ã¤ã§ã‚‚å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ã™ã‚‹ã®ã¯ã„ã„ã“ã¨ã§ã™ã€‚ãã†ã™ã‚Œã° ``close()`` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’ã™ã‚‹å±æ€§ã‚’å–ã‚Šé™¤ã„ã¦ãã‚Œã¾ã™ã€‚ :meth:`__del__` ã‚’ç›´æ¥å‘¼ã³å‡ºã•ãªã„ã§ãã ã•ã„ -- :meth:`__del__` ã¯ ``close()`` ã‚’å‘¼ã³å‡ºã™ã§ã—ã‚‡ã†ã—ã€ ``close()`` ãªã‚‰åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦è¤‡æ•°å›å‘¼ã°ã‚Œã¦ã‚‚ã„ã„ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/programming.rst:1788
msgid ""
"Another way to avoid cyclical references is to use the :mod:`weakref` "
"module, which allows you to point to objects without incrementing their "
"reference count. Tree data structures, for instance, should use weak "
"references for their parent and sibling references (if they need them!)."
msgstr "å¾ªç’°å‚ç…§ã‚’é¿ã‘ã‚‹ä»–ã®æ–¹æ³•ã¯ã€ :mod:`weakref` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—ã‚„ã™ã“ã¨ãªãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç¤ºã™ã“ã¨ã§ã™ã€‚ä¾‹ãˆã°ãƒ„ãƒªãƒ¼æ§‹é€ ã¯ã€è¦ªã¨ (å¿…è¦ãªã‚‰ï¼) å…„å¼Ÿã«å¼±å‚ç…§ã‚’ä½¿ã†ã¹ãã§ã™ã€‚"

#: ../../faq/programming.rst:1793
msgid ""
"If the object has ever been a local variable in a function that caught an "
"expression in an except clause, chances are that a reference to the object "
"still exists in that function's stack frame as contained in the stack trace."
" Normally, calling :func:`sys.exc_clear` will take care of this by clearing "
"the last recorded exception."
msgstr "except ç¯€ã§ä¾‹å¤–ã‚’æ•ã¾ãˆãŸé–¢æ•°å†…ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã§ã‚ã£ãŸãŸãªã‚‰ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ãŒé–¢æ•°ã®ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã§ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹å†…ã«å«ã¾ã‚Œã‚‹ã“ã¨ã§å­˜åœ¨ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚é€šå¸¸ã€ :func:`sys.exc_clear` ã‚’å‘¼ã³å‡ºã›ã°ã€æœ€å¾Œã«è¨˜éŒ²ã•ã‚ŒãŸä¾‹å¤–ã‚’æ¶ˆå»ã™ã‚‹ã“ã¨ã§å¯¾å‡¦ã—ã¦ãã‚Œã¾ã™ã€‚"

#: ../../faq/programming.rst:1799
msgid ""
"Finally, if your :meth:`__del__` method raises an exception, a warning "
"message is printed to :data:`sys.stderr`."
msgstr "æœ€å¾Œã«ã€ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ãŸå ´åˆã€è­¦å‘Šã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒ :data:`sys.stderr` ã«æ›¸ãã“ã¾ã‚Œã¾ã™ã€‚"

#: ../../faq/programming.rst:1804
msgid "How do I get a list of all instances of a given class?"
msgstr "ä¸ãˆã‚‰ã‚ŒãŸã‚¯ãƒ©ã‚¹ã®ã™ã¹ã¦ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒªã‚¹ãƒˆã‚’å¾—ã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1806
msgid ""
"Python does not keep track of all instances of a class (or of a built-in "
"type). You can program the class's constructor to keep track of all "
"instances by keeping a list of weak references to each instance."
msgstr "Python ã¯ã‚¯ãƒ©ã‚¹ (ã‚„ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹) ã®ã™ã¹ã¦ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ãŸã©ã‚Šã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ãã‚Œãã‚Œã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ã®å¼±å‚ç…§ã®ãƒªã‚¹ãƒˆã‚’ä½œã‚‰ã›ã‚‹ã“ã¨ã§ã™ã¹ã¦ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ãŸã©ã‚‰ã›ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../faq/programming.rst:1812
msgid "Why does the result of ``id()`` appear to be not unique?"
msgstr "ãªãœ ``id()`` ã®çµæœã¯ä¸€æ„ã§ãªã„ã‚ˆã†ã«è¦‹ãˆã‚‹ã®ã§ã™ã‹?"

#: ../../faq/programming.rst:1814
msgid ""
"The :func:`id` builtin returns an integer that is guaranteed to be unique "
"during the lifetime of the object.  Since in CPython, this is the object's "
"memory address, it happens frequently that after an object is deleted from "
"memory, the next freshly created object is allocated at the same position in"
" memory.  This is illustrated by this example:"
msgstr "çµ„ã¿è¾¼ã¿ã® :func:`id` ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿãã¦ã„ã‚‹é–“ã¯ä¸€æ„ã§ã‚ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã‚‹æ•´æ•°å€¤ã‚’è¿”ã—ã¾ã™ã€‚ CPython ã§ã¯ã€ãã‚Œã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ãƒ¢ãƒªã‚¢ãƒ‰ãƒ¬ã‚¹ãªã®ã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰Šé™¤ã•ã‚ŒãŸå¾Œã«ã€æ¬¡ã«æ–°ã—ãç”Ÿæˆã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ¡ãƒ¢ãƒªã®åŒã˜å ´æ‰€ã«ãƒ¡ãƒ¢ãƒªé ˜åŸŸã‚’ç¢ºä¿ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã€ã—ã°ã—ã°èµ·ãã¾ã™ã€‚ã“ã®ç¾è±¡ã‚’æ¬¡ã®ä¾‹ã§ç¤ºã—ã¾ã—ã‚‡ã†:"

#: ../../faq/programming.rst:1825
msgid ""
"The two ids belong to different integer objects that are created before, and"
" deleted immediately after execution of the ``id()`` call.  To be sure that "
"objects whose id you want to examine are still alive, create another "
"reference to the object:"
msgstr "2 ã¤ã®åŒã˜å€¤ã‚’æŒã¤ id ã¯ ``id()`` ã®å®Ÿè¡Œã®å‰ã«ä½œã‚‰ã‚Œã¦ã™ãã•ã¾å‰Šé™¤ã•ã‚ŒãŸç•°ãªã‚‹æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã‚‹ã‚‚ã®ã§ã™ã€‚id ã‚’èª¿ã¹ãŸã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã¾ã ç”Ÿãã¦ã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ãŸã„ãªã‚‰ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®åˆ¥ã®å‚ç…§ã‚’ä½œã£ã¦ãã ã•ã„:"

#: ../../faq/programming.rst:1838
msgid "Modules"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../faq/programming.rst:1841
msgid "How do I create a .pyc file?"
msgstr ".pyc ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1843
msgid ""
"When a module is imported for the first time (or when the source is more "
"recent than the current compiled file) a ``.pyc`` file containing the "
"compiled code should be created in the same directory as the ``.py`` file."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæœ€åˆã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã‚‹ã¨ã (ã¾ãŸã¯ã‚½ãƒ¼ã‚¹ãŒç¾åœ¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚ˆã‚Šã‚‚æ–°ã—ã„ã¨ã)ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’å«ã‚€ ``.pyc`` ãƒ•ã‚¡ã‚¤ãƒ«ãŒ ``.py`` ãƒ•ã‚¡ã‚¤ãƒ«ã¨åŒã˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ä½œã‚‰ã‚Œã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/programming.rst:1847
msgid ""
"One reason that a ``.pyc`` file may not be created is permissions problems "
"with the directory. This can happen, for example, if you develop as one user"
" but run as another, such as if you are testing with a web server.  Creation"
" of a .pyc file is automatic if you're importing a module and Python has the"
" ability (permissions, free space, etc...) to write the compiled module back"
" to the directory."
msgstr "``.pyc`` ãƒ•ã‚¡ã‚¤ãƒ«ãŒä½œã‚‰ã‚Œãªã„ã¨ã—ãŸã‚‰ã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®æ¨©é™ã®å•é¡ŒãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãŸã¨ãˆã°ã“ã‚Œã¯ã€web ã‚µãƒ¼ãƒãªã©ã§ãƒ†ã‚¹ãƒˆã™ã‚‹ã¨ãã®ã‚ˆã†ã«ã€é–‹ç™ºã®ã¨ãã¨é•ã†ãƒ¦ãƒ¼ã‚¶ã¨ã—ã¦èµ·å‹•ã™ã‚‹ã¨ããªã©ã«èµ·ã“ã‚Šãˆã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ãŸã¨ãã« Python ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«æ›¸ãè¾¼ã‚€ãŸã‚ã®æ¡ä»¶ (æ¨©é™ã€å®¹é‡ã®ç©ºãã€etc...) ãŒæƒã£ã¦ã„ã‚Œã°ã€.pyc ãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆã¯è‡ªå‹•çš„ã«è¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../faq/programming.rst:1854
msgid ""
"Running Python on a top level script is not considered an import and no "
"``.pyc`` will be created.  For example, if you have a top-level module "
"``foo.py`` that imports another module ``xyz.py``, when you run ``foo``, "
"``xyz.pyc`` will be created since ``xyz`` is imported, but no ``foo.pyc`` "
"file will be created since ``foo.py`` isn't being imported."
msgstr "ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¨ã¯è¦‹åšã•ã‚Œãšã€ ``.pyc`` ã¯ç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« ``abc.py`` ãŒã‚ã£ã¦ã€ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« ``xyz.py`` ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã¨ãã€abc ã‚’èµ·å‹•ã™ã‚‹ã¨ã€xyz ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ™‚ã« ``xyz.pyc`` ãŒç”Ÿæˆã•ã‚Œã¾ã™ãŒã€ ``abc.py`` ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œãªã„ã®ã§ ``abc.pyc`` ãƒ•ã‚¡ã‚¤ãƒ«ã¯ç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../faq/programming.rst:1860
msgid ""
"If you need to create ``foo.pyc`` -- that is, to create a ``.pyc`` file for "
"a module that is not imported -- you can, using the :mod:`py_compile` and "
":mod:`compileall` modules."
msgstr "abc.pyc ãŒå¿…è¦ãªã‚‰ -- ã¤ã¾ã‚Šã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œãªã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``.pyc`` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ã¯ -- :mod:`py_compile` ã‚„ :mod:`compileall` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../faq/programming.rst:1864
msgid ""
"The :mod:`py_compile` module can manually compile any module.  One way is to"
" use the ``compile()`` function in that module interactively::"
msgstr ":mod:`py_compile` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯æ‰‹å‹•ã§ä»»æ„ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã™ã€‚ã‚„ã‚Šæ–¹ã®ä¸€ã¤ã¯ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``compile()`` é–¢æ•°ã‚’ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã«å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã™::"

#: ../../faq/programming.rst:1870
msgid ""
"This will write the ``.pyc`` to the same location as ``foo.py`` (or you can "
"override that with the optional parameter ``cfile``)."
msgstr "ã“ã®ã‚ˆã†ã«å®Ÿè¡Œã™ã‚‹ã¨ã€``foo.py`` ã¨åŒã˜å ´æ‰€ã« ``.pyc`` ãŒæ›¸ãå‡ºã•ã‚Œã¾ã™ (å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½ç½®ã¯ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° ``cfile`` ã§ä¸Šæ›¸ãã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™)ã€‚"

#: ../../faq/programming.rst:1873
msgid ""
"You can also automatically compile all files in a directory or directories "
"using the :mod:`compileall` module.  You can do it from the shell prompt by "
"running ``compileall.py`` and providing the path of a directory containing "
"Python files to compile::"
msgstr ":mod:`compileall` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ãˆã°è‡ªå‹•çš„ã«ä¸€ã¤ã‚„è¤‡æ•°ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã™ã€‚ã‚·ã‚§ãƒ«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‹ã‚‰ ``compileall.py`` ã‚’èµ·å‹•ã—ã¦ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å«ã‚€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹ã‚’æŒ‡å®šã—ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:1882
msgid "How do I find the current module name?"
msgstr "ç¾åœ¨ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’çŸ¥ã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1884
msgid ""
"A module can find out its own module name by looking at the predefined "
"global variable ``__name__``.  If this has the value ``'__main__'``, the "
"program is running as a script.  Many modules that are usually used by "
"importing them also provide a command-line interface or a self-test, and "
"only execute this code after checking ``__name__``::"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å‰ã‚‚ã£ã¦å®šç¾©ã•ã‚ŒãŸã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ``__name__`` ã‚’æ¤œç´¢ã™ã‚‹ã“ã¨ã§è‡ªèº«ã®åå‰ã‚’æ±ºå®šã§ãã¾ã™ã€‚ã“ã®å€¤ãŒ ``'__main__'`` ã§ã‚ã‚‹ã¨ãã€ãã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã¦ã„ã¾ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã‚‹ã“ã¨ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã‚‹å¤§æŠµã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚„è‡ªå·±ãƒ†ã‚¹ãƒˆã‚‚æä¾›ã—ã¦ã„ã¦ã€``__name__`` ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã‹ã‚‰ãã®ã‚³ãƒ¼ãƒ‰ã ã‘ã‚’å®Ÿè¡Œã—ã¾ã™::"

#: ../../faq/programming.rst:1899
msgid "How can I have modules that mutually import each other?"
msgstr "ç›¸äº’ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã‚ã†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œã‚‹ã«ã¯ã©ã†ã—ãŸã‚‰ã„ã„ã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1901
msgid "Suppose you have the following modules:"
msgstr "ä»¥ä¸‹ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚ã£ãŸã¨ã—ã¾ã—ã‚‡ã†:"

#: ../../faq/programming.rst:1903
msgid "foo.py::"
msgstr "foo.py::"

#: ../../faq/programming.rst:1908
msgid "bar.py::"
msgstr "bar.py::"

#: ../../faq/programming.rst:1913
msgid "The problem is that the interpreter will perform the following steps:"
msgstr "å•é¡Œã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒä»¥ä¸‹ã®æ®µéšã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã™:"

#: ../../faq/programming.rst:1915
msgid "main imports foo"
msgstr "main ãŒ foo ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹"

#: ../../faq/programming.rst:1916
msgid "Empty globals for foo are created"
msgstr "foo ã®ç©ºã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãŒç”Ÿæˆã•ã‚Œã‚‹"

#: ../../faq/programming.rst:1917
msgid "foo is compiled and starts executing"
msgstr "foo ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œå®Ÿè¡Œã‚’å§‹ã‚ã‚‹"

#: ../../faq/programming.rst:1918
msgid "foo imports bar"
msgstr "foo ãŒ bar ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹"

#: ../../faq/programming.rst:1919
msgid "Empty globals for bar are created"
msgstr "bar ã®ç©ºã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãŒç”Ÿæˆã•ã‚Œã‚‹"

#: ../../faq/programming.rst:1920
msgid "bar is compiled and starts executing"
msgstr "bar ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œå®Ÿè¡Œã‚’å§‹ã‚ã‚‹"

#: ../../faq/programming.rst:1921
msgid ""
"bar imports foo (which is a no-op since there already is a module named foo)"
msgstr "bar ãŒ foo ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹(ã™ã§ã« foo ã¨ã„ã†åå‰ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚ã‚‹ã®ã§ no-op ã¨ãªã‚‹)"

#: ../../faq/programming.rst:1922
msgid "bar.foo_var = foo.foo_var"
msgstr "bar.foo_var = foo.foo_var"

#: ../../faq/programming.rst:1924
msgid ""
"The last step fails, because Python isn't done with interpreting ``foo`` yet"
" and the global symbol dictionary for ``foo`` is still empty."
msgstr "ã“ã®æœ€å¾Œã®æ®µéšã¯å¤±æ•—ã—ã¾ã™ã€‚Python ãŒ ``foo`` ã‚’è§£é‡ˆã—çµ‚ã‚ã£ã¦ã„ãªãã¦ã€``foo`` ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚·ãƒ³ãƒœãƒ«ã®è¾æ›¸ã¯ã¾ã ç©ºã§ã™ã‹ã‚‰ã€‚"

#: ../../faq/programming.rst:1927
msgid ""
"The same thing happens when you use ``import foo``, and then try to access "
"``foo.foo_var`` in global code."
msgstr "``import foo`` ã‚’ä½¿ã£ã¦ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚³ãƒ¼ãƒ‰ã® ``foo.foo_var`` ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã‚ˆã†ã¨ã—ãŸã¨ãã«ã‚‚ã€ã“ã‚Œã¨åŒã˜ã“ã¨ãŒèµ·ã“ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:1930
msgid "There are (at least) three possible workarounds for this problem."
msgstr "ã“ã®å•é¡Œã«ã¯ (å°‘ãªãã¨ã‚‚) ä¸‰ã¤ã®è§£æ±ºç­–ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:1932
msgid ""
"Guido van Rossum recommends avoiding all uses of ``from <module> import "
"...``, and placing all code inside functions.  Initializations of global "
"variables and class variables should use constants or built-in functions "
"only.  This means everything from an imported module is referenced as "
"``<module>.<name>``."
msgstr "Guido van Rossum ã¯ ``from <module> import ...`` ã‚’å…¨ãä½¿ã‚ãªã„ã§ã€ã™ã¹ã¦ã®ã‚³ãƒ¼ãƒ‰ã‚’é–¢æ•°ã®ä¸­ã«å…¥ã‚Œã‚‹ã“ã¨ã‚’å‹§ã‚ã¦ã„ã¾ã™ã€‚ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã‚¯ãƒ©ã‚¹å¤‰æ•°ã®åˆæœŸåŒ–ã¯å®šæ•°ã¨ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•°ã®ã¿ã§è¡Œã‚ã‚Œã‚‹ã¹ãã§ã™ã€‚ã“ã‚Œã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ ``<module>.<name>`` ã¨ã—ã¦å‚ç…§ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../faq/programming.rst:1937
msgid ""
"Jim Roskind suggests performing steps in the following order in each module:"
msgstr "Jim Roskind ã¯ãã‚Œãã‚Œã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å¯¾ã—ã¦ä»¥ä¸‹ã®é †ã«é€²ã‚ã‚‹ã“ã¨ã‚’ææ¡ˆã—ã¦ã„ã¾ã™:"

#: ../../faq/programming.rst:1939
msgid ""
"exports (globals, functions, and classes that don't need imported base "
"classes)"
msgstr "ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ (ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸåŸºåº•ã‚¯ãƒ©ã‚¹ã‚’å¿…è¦ã¨ã—ãªã„ã‚°ãƒ­ãƒ¼ãƒãƒ«ã€é–¢æ•°ã€ã‚¯ãƒ©ã‚¹)"

#: ../../faq/programming.rst:1941
msgid "``import`` statements"
msgstr "``import`` æ–‡"

#: ../../faq/programming.rst:1942
msgid ""
"active code (including globals that are initialized from imported values)."
msgstr "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚³ãƒ¼ãƒ‰ (ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸå€¤ã«ã‚ˆã£ã¦åˆæœŸåŒ–ã•ã‚Œã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚’å«ã‚€)ã€‚"

#: ../../faq/programming.rst:1944
msgid ""
"van Rossum doesn't like this approach much because the imports appear in a "
"strange place, but it does work."
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒå¥‡å¦™ãªå ´æ‰€ã«ç¾ã‚Œã‚‹ã“ã¨ã‹ã‚‰ van Rossum ã¯ã“ã®æ–¹æ³•ã‚’ãã‚Œã»ã©å¥½ã¿ã¾ã›ã‚“ãŒã€ã“ã‚Œã¯æœ‰åŠ¹ã§ã™ã€‚"

#: ../../faq/programming.rst:1947
msgid ""
"Matthias Urlichs recommends restructuring your code so that the recursive "
"import is not necessary in the first place."
msgstr "Matthias Urlichs ã¯ç¬¬ä¸€ã«å†å¸°ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒå¿…è¦ãªã„ã‚ˆã†ã«ã‚³ãƒ¼ãƒ‰ã‚’æ§‹ç¯‰ã—ãªãŠã™ã“ã¨ã‚’æ¨å¥¨ã—ã¦ã„ã¾ã™ã€‚"

#: ../../faq/programming.rst:1950
msgid "These solutions are not mutually exclusive."
msgstr "ã“ã‚Œã‚‰ã®è§£æ±ºç­–ã¯ãã‚Œãã‚Œä¸¡ç«‹ã•ã›ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../faq/programming.rst:1954
msgid "__import__('x.y.z') returns <module 'x'>; how do I get z?"
msgstr "__import__('x.y.z') ã¯ <module 'x'> ã‚’è¿”ã—ã¾ã™ãŒã€z ã‚’å¾—ã‚‹ãŸã‚ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1956
msgid ""
"Consider using the convenience function :func:`~importlib.import_module` "
"from :mod:`importlib` instead::"
msgstr "mod:`importlib` ã« :func:`~importlib.import_module` ã¨ã„ã†ä¾¿åˆ©ãªé–¢æ•°ãŒã‚ã‚‹ã®ã§ã€ä»£ã‚ã‚Šã«ãã¡ã‚‰ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/programming.rst:1963
msgid ""
"When I edit an imported module and reimport it, the changes don't show up.  "
"Why does this happen?"
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç·¨é›†ã—ã¦ã‹ã‚‰å†ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸãŒã€å¤‰åŒ–ãŒç¾ã‚Œã¾ã›ã‚“ã€‚ãªãœã§ã™ã‹ï¼Ÿ"

#: ../../faq/programming.rst:1965
msgid ""
"For reasons of efficiency as well as consistency, Python only reads the "
"module file on the first time a module is imported.  If it didn't, in a "
"program consisting of many modules where each one imports the same basic "
"module, the basic module would be parsed and re-parsed many times.  To force"
" rereading of a changed module, do this::"
msgstr "åŠ¹ç‡ã¨ä¸€è²«æ€§ä¸Šã®ç†ç”±ã‹ã‚‰ã€Python ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæœ€åˆã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸæ™‚ã«ã®ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚ãã†ã—ãªã„ã¨ã€ãŸãã•ã‚“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã§ãã¦ã„ã¦ã€ãã‚Œãã‚ŒãŒåŒã˜åŸºæœ¬ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã€ãã®åŸºæœ¬ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è§£æã¨å†è§£æãŒç¹°ã‚Šè¿”ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚å¤‰æ›´ã•ã‚Œã•ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†èª­è¾¼ã‚’å¼·åˆ¶ã™ã‚‹ã«ã¯ã€ã“ã†ã—ã¦ãã ã•ã„::"

#: ../../faq/programming.rst:1974
msgid ""
"Warning: this technique is not 100% fool-proof.  In particular, modules "
"containing statements like ::"
msgstr "æ³¨æ„:ã“ã®æ‰‹æ³•ã¯ 100%å®‰å…¨ã¨ã¯è¨€ãˆã¾ã›ã‚“ã€‚ã¨ã‚Šã‚ã‘ ::"

#: ../../faq/programming.rst:1979
msgid ""
"will continue to work with the old version of the imported objects.  If the "
"module contains class definitions, existing class instances will *not* be "
"updated to use the new class definition.  This can result in the following "
"paradoxical behaviour:"
msgstr "ã®ã‚ˆã†ãªæ–‡ã‚’å«ã‚€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½¿ã„ç¶šã‘ã¾ã™ã€‚ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚¯ãƒ©ã‚¹å®šç¾©ãŒå«ã¾ã‚Œã¦ã„ãŸã‚‰ã€å­˜åœ¨ã™ã‚‹ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯æ–°ã—ã„ã‚¯ãƒ©ã‚¹å®šç¾©ã‚’ä½¿ã†ã‚ˆã†ã«ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ *ã•ã‚Œã¾ã›ã‚“*ã€‚ã“ã‚Œã«ã‚ˆã£ã¦ä»¥ä¸‹ã®çŸ›ç›¾ã—ãŸæŒ¯èˆã„ãŒãªã•ã‚Œãˆã¾ã™:"

#: ../../faq/programming.rst:1991
msgid ""
"The nature of the problem is made clear if you print out the class objects:"
msgstr "ã“ã®å•é¡Œã®æœ¬è³ªã¯ã€ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å°å­—ã™ã‚‹ã“ã¨ã§æ˜ã‚‰ã‹ã«ãªã‚Šã¾ã™::"
