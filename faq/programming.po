# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# cocoatomo, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2018-01-20 20:57+0000\n"
"Last-Translator: cocoatomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../faq/programming.rst:5
msgid "Programming FAQ"
msgstr "プログラミング FAQ"

#: ../../faq/programming.rst:12
msgid "General Questions"
msgstr "一般的な質問"

#: ../../faq/programming.rst:15
msgid ""
"Is there a source code level debugger with breakpoints, single-stepping, "
"etc.?"
msgstr "ブレークポイントやシングルステップ実行などを備えたソースコードレベルデバッガはありますか？"

#: ../../faq/programming.rst:17 ../../faq/programming.rst:60
msgid "Yes."
msgstr "はい。"

#: ../../faq/programming.rst:19
msgid ""
"The pdb module is a simple but adequate console-mode debugger for Python. It"
" is part of the standard Python library, and is :mod:`documented in the "
"Library Reference Manual <pdb>`. You can also write your own debugger by "
"using the code for pdb as an example."
msgstr "pdb モジュールは簡素にして十分な Python のコンソールモードデバッガです。これは Python の標準ライブラリに含まれているもので、 :mod:`ライブラリリファレンスマニュアルにドキュメントがあります <pdb>` 。 pdb のコードを手本にして自分用のデバッガを書くこともできます。"

#: ../../faq/programming.rst:24
msgid ""
"The IDLE interactive development environment, which is part of the standard "
"Python distribution (normally available as Tools/scripts/idle), includes a "
"graphical debugger."
msgstr "Python に同梱されている統合開発環境の IDLE は通常の Python の配布形態の一部 (普通は Tools/scripts/idle から利用可能) であり、グラフィカルなデバッガを含んでいます。"

#: ../../faq/programming.rst:28
msgid ""
"PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The "
"Pythonwin debugger colors breakpoints and has quite a few cool features such"
" as debugging non-Pythonwin programs.  Pythonwin is available as part of the"
" `Python for Windows Extensions "
"<https://sourceforge.net/projects/pywin32/>`__ project and as a part of the "
"ActivePython distribution (see https://www.activestate.com/activepython\\ )."
msgstr "PythonWin は、pdb をベースとした GUI デバッガを含む Python IDE です。Pythonwin デバッガは、ブレークポイントの色付けや非 Pythonwin プログラムのデバッグなどのたくさんの素敵な機能を持っています。Pythonwin は `Python for Windows Extensions <https://sourceforge.net/projects/pywin32/>`__ プロジェクトの一部、あるいは ActivePython ディストリビューション (https://www.activestate.com/activepython を参照) の一部として利用可能です。"

#: ../../faq/programming.rst:35
msgid ""
"`Boa Constructor <http://boa-constructor.sourceforge.net/>`_ is an IDE and "
"GUI builder that uses wxWidgets.  It offers visual frame creation and "
"manipulation, an object inspector, many views on the source like object "
"browsers, inheritance hierarchies, doc string generated html documentation, "
"an advanced debugger, integrated help, and Zope support."
msgstr "`Boa Constructor <http://boa-constructor.sourceforge.net/>`_ は、wxWidgets を使った IDE と GUI ビルダーです。これは視覚フレームの作成と操作、オブジェクト検査、オブジェクトブラウザのような多くのビュー、継承構造、doc string から生成される html ドキュメント、高度なデバッガ、総合ヘルプ、Zope のサポートを提供します。"

#: ../../faq/programming.rst:41
msgid ""
"`Eric <http://eric-ide.python-projects.org/>`_ is an IDE built on PyQt and "
"the Scintilla editing component."
msgstr "`Eric <http://eric-ide.python-projects.org/>`_ は PyQt や Scintilla editing component をもとにした IDE です。"

#: ../../faq/programming.rst:44
msgid ""
"Pydb is a version of the standard Python debugger pdb, modified for use with"
" DDD (Data Display Debugger), a popular graphical debugger front end.  Pydb "
"can be found at http://bashdb.sourceforge.net/pydb/ and DDD can be found at "
"https://www.gnu.org/software/ddd."
msgstr "Pydb は標準のデバッガである pdb を人気のグラフィカルデバッガフロントエンドである DDD (Data Display Debugger) とともに使うために改変したものです。Pydb は http://bashdb.sourceforge.net/pydb/ に、 DDD は https://www.gnu.org/software/ddd にあります。 "

#: ../../faq/programming.rst:49
msgid ""
"There are a number of commercial Python IDEs that include graphical "
"debuggers. They include:"
msgstr "商業のグラフィカルデバッガ付き Python IDE もあります。例えば:"

#: ../../faq/programming.rst:52
msgid "Wing IDE (https://wingware.com/)"
msgstr "Wing IDE (https://wingware.com/)"

#: ../../faq/programming.rst:53
msgid "Komodo IDE (https://komodoide.com/)"
msgstr "Komodo IDE (https://komodoide.com/)"

#: ../../faq/programming.rst:54
msgid "PyCharm (https://www.jetbrains.com/pycharm/)"
msgstr "PyCharm (https://www.jetbrains.com/pycharm/)"

#: ../../faq/programming.rst:58
msgid "Is there a tool to help find bugs or perform static analysis?"
msgstr "バグの発見や静的分析に役立つツールはありますか？"

#: ../../faq/programming.rst:62
msgid ""
"PyChecker is a static analysis tool that finds bugs in Python source code "
"and warns about code complexity and style.  You can get PyChecker from "
"http://pychecker.sourceforge.net/."
msgstr "PyChecker は Python ソースコードのバグを発見しコードの複雑さとスタイルについて警告する静的解析ツールです。PyChecker は http://pychecker.sourceforge.net/ から手に入ります。"

#: ../../faq/programming.rst:66
msgid ""
"`Pylint <https://www.pylint.org/>`_ is another tool that checks if a module "
"satisfies a coding standard, and also makes it possible to write plug-ins to"
" add a custom feature.  In addition to the bug checking that PyChecker "
"performs, Pylint offers some additional features such as checking line "
"length, whether variable names are well-formed according to your coding "
"standard, whether declared interfaces are fully implemented, and more. "
"https://docs.pylint.org/ provides a full list of Pylint's features."
msgstr "`Pylint <https://www.pylint.org/>`_ も、モジュールがコーディング標準を満たすかを調べ、プラグインを書いてカスタム機能を加えられるようにするツールです。PyChecker が行うバグチェックに加え、 Pylint は行の長さ、変数名が一貫しているか、宣言されたインタフェースが完全に実装されているか、などを確かめる追加の機能を提供します。 https://docs.pylint.org/ で Pylint の機能の一覧を見られます。"

#: ../../faq/programming.rst:76
msgid "How can I create a stand-alone binary from a Python script?"
msgstr "どうしたら Python スクリプトからスタンドアロンバイナリを作れますか？"

#: ../../faq/programming.rst:78
msgid ""
"You don't need the ability to compile Python to C code if all you want is a "
"stand-alone program that users can download and run without having to "
"install the Python distribution first.  There are a number of tools that "
"determine the set of modules required by a program and bind these modules "
"together with a Python binary to produce a single executable."
msgstr "ユーザがダウンロードや起動のために Python ディストリビューションをインストールしなくてもよいスタンドアロンプログラムのためだけなら、Python を C コードにコンパイルできる必要はありません。プログラムに対して必要なモジュールを選び、そのモジュールを Python バイナリに束縛して一つの実行可能ファイルにまとめる多くのツールがあります。"

#: ../../faq/programming.rst:84
msgid ""
"One is to use the freeze tool, which is included in the Python source tree "
"as ``Tools/freeze``. It converts Python byte code to C arrays; a C compiler "
"you can embed all your modules into a new program, which is then linked with"
" the standard Python modules."
msgstr "一つは freeze ツールで、Python ソースツリーに ``Tools/freeze`` として含まれています。これは Python バイトコードを C 配列に変換します。すべてのモジュールを標準 Python モジュールにリンクされる新しいプログラムに埋め込む C コンパイラです。"

#: ../../faq/programming.rst:89
msgid ""
"It works by scanning your source recursively for import statements (in both "
"forms) and looking for the modules in the standard Python path as well as in"
" the source directory (for built-in modules).  It then turns the bytecode "
"for modules written in Python into C code (array initializers that can be "
"turned into code objects using the marshal module) and creates a custom-made"
" config file that only contains those built-in modules which are actually "
"used in the program.  It then compiles the generated C code and links it "
"with the rest of the Python interpreter to form a self-contained binary "
"which acts exactly like your script."
msgstr "これはあなたのソースの (両方の形式の) import 文を再帰的にスキャンして、import されたモジュールを標準の Python パスと (組み込みモジュールのある) ソースディレクトリから探します。そして Python で書かれたモジュールのバイトコードを C コード (marshal モジュールでコードオブジェクトに変換できる配列) に変換し、実際にそのプログラム内で使われている組み込みモジュールだけが含まれたカスタムメイドの設定ファイルを作成します。そして生成された C コードをコンパイルして Python インタプリタの残りとリンクし、元のスクリプトと全く同じように動作する自己充足的なバイナリを形成します。"

#: ../../faq/programming.rst:98
msgid ""
"Obviously, freeze requires a C compiler.  There are several other utilities "
"which don't. One is Thomas Heller's py2exe (Windows only) at"
msgstr "もちろん、凍結には C コンパイラが必要です。C コンパイラを必要としない選択肢もあります。その一つは、Thomas Heller の py2exe (Windows 専用) です"

#: ../../faq/programming.rst:101
msgid "http://www.py2exe.org/"
msgstr "http://www.py2exe.org/"

#: ../../faq/programming.rst:103
msgid ""
"Another tool is Anthony Tuininga's `cx_Freeze <http://cx-"
"freeze.sourceforge.net/>`_."
msgstr "他には Anthony Tuininga の `cx_Freeze <http://cx-freeze.sourceforge.net/>`_ があります。"

#: ../../faq/programming.rst:107
msgid "Are there coding standards or a style guide for Python programs?"
msgstr "Python プログラムのためのコーディングスタンダードやスタイルガイドはありますか？"

#: ../../faq/programming.rst:109
msgid ""
"Yes.  The coding style required for standard library modules is documented "
"as :pep:`8`."
msgstr "はい。標準ライブラリモジュールに求められるコーディングスタイルは :pep:`8` として文書化されています。"

#: ../../faq/programming.rst:114
msgid "My program is too slow. How do I speed it up?"
msgstr "プログラムが遅すぎます。どうしたら速くなりますか？"

#: ../../faq/programming.rst:116
msgid ""
"That's a tough one, in general.  There are many tricks to speed up Python "
"code; consider rewriting parts in C as a last resort."
msgstr "一般に、それは難しい質問です。Python コードを速くするためには、いろいろな手法があります。最終手段として一部を C で書き直す事も考えてください。"

#: ../../faq/programming.rst:119
msgid ""
"In some cases it's possible to automatically translate Python to C or x86 "
"assembly language, meaning that you don't have to modify your code to gain "
"increased speed."
msgstr "Python を自動的に C や x86 アセンブリ言語に変換できる場合もあります。この場合、速度を上げるためにコードを変更する必要はありません。"

#: ../../faq/programming.rst:125
msgid ""
"`Pyrex <http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/>`_ can compile "
"a slightly modified version of Python code into a C extension, and can be "
"used on many different platforms."
msgstr "`Pyrex <http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/>`_ はPython コードの少し変化した版を C 拡張にコンパイルでき、多様なプラットフォームで使えます。(訳注： Pyrex は `Cython <https://pypi.python.org/pypi/Cython/>`_ に取って代わられています。)"

#: ../../faq/programming.rst:129
msgid ""
"`Psyco <http://psyco.sourceforge.net>`_ is a just-in-time compiler that "
"translates Python code into x86 assembly language.  If you can use it, Psyco"
" can provide dramatic speedups for critical functions."
msgstr "`Psyco <http://psyco.sourceforge.net>`_ は Python コードを x86 アセンブリ言語に変換する実行時コンパイラです。これを使うことが出来れば、重要な関数を劇的にスピードアップできます。"

#: ../../faq/programming.rst:133
msgid ""
"The rest of this answer will discuss various tricks for squeezing a bit more"
" speed out of Python code.  *Never* apply any optimization tricks unless you"
" know you need them, after profiling has indicated that a particular "
"function is the heavily executed hot spot in the code.  Optimizations almost"
" always make the code less clear, and you shouldn't pay the costs of reduced"
" clarity (increased development time, greater likelihood of bugs) unless the"
" resulting performance benefit is worth it."
msgstr "あとは、Python コードからもう少し速度を搾り出すための様々な手法について議論することになります。コード中の特定の関数が処理が集中するホットスポットで、最適化が必要であると認められない限り、\\ *決して* いかなる最適化の手法も使わないでください。最適化はたいていコードを分かりづらくするので、分かりづらさのコスト (開発時間の延長とバグの可能性の増大) がそれに見合ったパフォーマンスの向上につながらないのであれば元が取れません。"

#: ../../faq/programming.rst:141
msgid ""
"There is a page on the wiki devoted to `performance tips "
"<https://wiki.python.org/moin/PythonSpeed/PerformanceTips>`_."
msgstr "`performance tips <http://wiki.python.org/moin/PythonSpeed/PerformanceTips>`_ に関するページが wiki にあります。"

#: ../../faq/programming.rst:144
msgid ""
"Guido van Rossum has written up an anecdote related to optimization at "
"https://www.python.org/doc/essays/list2str."
msgstr "Guido van Rossum は https://www.python.org/doc/essays/list2str で最適化に関する逸話を詳述しています。"

#: ../../faq/programming.rst:147
msgid ""
"One thing to notice is that function and (especially) method calls are "
"rather expensive; if you have designed a purely OO interface with lots of "
"tiny functions that don't do much more than get or set an instance variable "
"or call another method, you might consider using a more direct way such as "
"directly accessing instance variables.  Also see the standard module "
":mod:`profile` which makes it possible to find out where your program is "
"spending most of its time (if you have some patience -- the profiling itself"
" can slow your program down by an order of magnitude)."
msgstr "なお、関数や(特に)メソッドの呼び出しはかなり高価です。インスタンス変数を get や set したり他のメソッドを呼び出す程度の小さな関数がたくさんある純粋 OO インタフェースをデザインしているなら、インスタンス変数に直接アクセスするようなもっと直接的な方法も考えてみてください。また、どのプログラムが実行時間の大部分を占めているかを見つける標準モジュール :mod:`profile` も参照してください (ちょっと忍耐できればの話ですが - プロファイリングはそれ自体がプログラムを一桁ほど遅くしてしまいます)。"

#: ../../faq/programming.rst:156
msgid ""
"Remember that many standard optimization heuristics you may know from other "
"programming experience may well apply to Python.  For example it may be "
"faster to send output to output devices using larger writes rather than "
"smaller ones in order to reduce the overhead of kernel system calls.  Thus "
"CGI scripts that write all output in \"one shot\" may be faster than those "
"that write lots of small pieces of output."
msgstr "もちろん、他のプログラミングの経験から得られた多くの標準的な最適化の発見的手法は Python にもよく当てはまることが多いです。たとえば、出力装置に出力を送るときに、一度に少なく書くよりもむしろ多く書いたほうが、カーネルのシステムコールのオーバーヘッドを減らすことができて、速くなるでしょう。したがって、CGI スクリプトは \"一発\" ですべて書き出すもののほうが小さなたくさんの出力に分けて書き出すものよりも速くなるでしょう。"

#: ../../faq/programming.rst:163
msgid ""
"Also, be sure to use Python's core features where appropriate.  For example,"
" slicing allows programs to chop up lists and other sequence objects in a "
"single tick of the interpreter's mainloop using highly optimized C "
"implementations. Thus to get the same effect as::"
msgstr "また、必ず Python のコアな機能を適切に使ってください。例えば、スライシングなら、リストや他のシーケンスオブジェクトを、高度に最適化された C 実装で、インタプリタのメインループの一刻みで細切れにできます。こうして効果を得ることができる例は::"

#: ../../faq/programming.rst:172
msgid "it is much shorter and far faster to use ::"
msgstr "こう使えばずっと短く、ずっと速くできます::"

#: ../../faq/programming.rst:176
msgid ""
"Note that the functionally-oriented built-in functions such as :func:`map`, "
":func:`zip`, and friends can be a convenient accelerator for loops that "
"perform a single task.  For example to pair the elements of two lists "
"together::"
msgstr "関数指向組み込み関数 :func:`map` や :func:`zip` なども一つのタスクを実行するためのループを加速するのに便利であることに注意してください。例えば、二つのリストの要素を組み合わせるためには::"

#: ../../faq/programming.rst:184
msgid "or to compute a number of sines::"
msgstr "また、正弦を一度に計算するには::"

#: ../../faq/programming.rst:189
msgid "The operation completes very quickly in such cases."
msgstr "このような場合には素早く演算が完了します。"

#: ../../faq/programming.rst:191
msgid ""
"Other examples include the ``join()`` and ``split()`` :ref:`methods of "
"string objects <string-methods>`. For example if s1..s7 are large (10K+) "
"strings then ``\"\".join([s1,s2,s3,s4,s5,s6,s7])`` may be far faster than "
"the more obvious ``s1+s2+s3+s4+s5+s6+s7``, since the \"summation\" will "
"compute many subexpressions, whereas ``join()`` does all the copying in one "
"pass.  For manipulating strings, use the ``replace()`` and the ``format()`` "
":ref:`methods on string objects <string-methods>`.  Use regular expressions "
"only when you're not dealing with constant string patterns.  You may still "
"use :ref:`the old % operations <string-formatting>` ``string % tuple`` and "
"``string % dictionary``."
msgstr "その他の例には、 :ref:`文字列オブジェクトのメソッド <string-methods>` ``join()`` 、 ``split()`` などが挙げられます。例えば s1..s7 が大きな (10K+) 文字列の時、 ``\"\".join([s1,s2,s3,s4,s5,s6,s7])`` は単純に ``s1+s2+s3+s4+s5+s6+s7`` とするよりもはるかに速くなるでしょう。なぜなら、 ``join()`` はすべてのコピーを一括して行うのに対し、「足し算」が多くの副演算を行うからです。文字列を扱うには、 :ref:`文字列オブジェクトのメソッド <string-methods>` ``replace()`` 、 ``format()``  を使ってください。正規表現を使うのは、決まった文字列のパターンを使わない時だけにしてください。 :ref:`旧式の % 演算 <string-formatting>` ``string % tuple`` と ``string % dictionary`` も使えます。"

#: ../../faq/programming.rst:202
msgid ""
"Be sure to use the :meth:`list.sort` built-in method to do sorting, and see "
"the `sorting mini-HOWTO <https://wiki.python.org/moin/HowTo/Sorting>`_ for "
"examples of moderately advanced usage.  :meth:`list.sort` beats other "
"techniques for sorting in all but the most extreme circumstances."
msgstr "ソートには必ずビルトインオブジェクトの :meth:`list.sort` を使ってください。また、 `sorting mini-HOWTO <https://wiki.python.org/moin/HowTo/Sorting>`_ の少し高度な使い方の例を参照してください。 :meth:`list.sort` は、よほど極端な状況でない限り、他のソートの技術に勝ります。"

#: ../../faq/programming.rst:207
msgid ""
"Another common trick is to \"push loops into functions or methods.\"  For "
"example suppose you have a program that runs slowly and you use the profiler"
" to determine that a Python function ``ff()`` is being called lots of times."
"  If you notice that ``ff()``::"
msgstr "「ループを関数やメソッドの中に入れ込む」というのも一般的な手法です。例えば、遅いプログラムがあって、Python の ``ff()`` 関数が何度も呼ばれていることがプロファイラで分かったとします。この ``ff()`` ::"

#: ../../faq/programming.rst:216
msgid "tends to be called in loops like::"
msgstr "がこのようなループで呼ばれる傾向がある気付いたとして::"

#: ../../faq/programming.rst:220
msgid "or::"
msgstr "もしくは::"

#: ../../faq/programming.rst:226
msgid ""
"then you can often eliminate function call overhead by rewriting ``ff()`` "
"to::"
msgstr "``ff()`` を書き換えて::"

#: ../../faq/programming.rst:235
msgid "and rewrite the two examples to ``list = ffseq(oldlist)`` and to::"
msgstr "また、上の二つの例を、 ``list = ffseq(oldlist)`` と::"

#: ../../faq/programming.rst:240
msgid ""
"Single calls to ``ff(x)`` translate to ``ffseq([x])[0]`` with little "
"penalty. Of course this technique is not always appropriate and there are "
"other variants which you can figure out."
msgstr "のように書き換えることによって、関数を呼ぶためのオーバーヘッドを省けることが多いです。``ff(x)`` を一回だけ呼ぶ場合、 ``ffseq([x])[0]`` に直してしまうとちょっと不利になります。 もちろん、このテクニックがいつでも適切であるわけではありませんし、解決のための他の方法もあります。"

#: ../../faq/programming.rst:244
msgid ""
"You can gain some performance by explicitly storing the results of a "
"function or method lookup into a local variable.  A loop like::"
msgstr "関数やメソッドの探索の結果をローカル変数に明示的に保存すると少しパフォーマンスが良くなります。次のようなループ::"

#: ../../faq/programming.rst:250
msgid ""
"resolves ``dict.get`` every iteration.  If the method isn't going to change,"
" a slightly faster implementation is::"
msgstr "は、繰り返しのたびに ``dict.get`` を求めています。 このメソッドが変わることがないのなら、少し速い実装は::"

#: ../../faq/programming.rst:257
msgid ""
"Default arguments can be used to determine values once, at compile time "
"instead of at run time.  This can only be done for functions or objects "
"which will not be changed during program execution, such as replacing ::"
msgstr "デフォルト引数は、実行時でなく、コンパイル時に値を一回で決めてしまうのに使えます。これは、プログラムの実行中に変化しない関数やオブジェクト、例えば::"

#: ../../faq/programming.rst:264
msgid "with ::"
msgstr "を、次のように置き換えるときにのみ行えます::"

#: ../../faq/programming.rst:269
msgid ""
"Because this trick uses default arguments for terms which should not be "
"changed, it should only be used when you are not concerned with presenting a"
" possibly confusing API to your users."
msgstr "この手法はデフォルト引数が変えられないことを前提に使うので、ユーザーが API で混乱するおそれがないときのみ使えます。"

#: ../../faq/programming.rst:275
msgid "Core Language"
msgstr "コア言語"

#: ../../faq/programming.rst:278
msgid "Why am I getting an UnboundLocalError when the variable has a value?"
msgstr "なぜ変数に値があるのに UnboundLocalError が出るのですか？"

#: ../../faq/programming.rst:280
msgid ""
"It can be a surprise to get the UnboundLocalError in previously working code"
" when it is modified by adding an assignment statement somewhere in the body"
" of a function."
msgstr "もともと動いていたコードが、関数の本体のどこかに代入文を加えるという変更をしたら UnboundLocalError を出すのには驚くかもしれません。"

#: ../../faq/programming.rst:284
msgid "This code:"
msgstr "このコード:"

#: ../../faq/programming.rst:292
msgid "works, but this code:"
msgstr "は動きますが、このコード:"

#: ../../faq/programming.rst:299
msgid "results in an UnboundLocalError:"
msgstr "は UnboundLocalError になります:"

#: ../../faq/programming.rst:306
msgid ""
"This is because when you make an assignment to a variable in a scope, that "
"variable becomes local to that scope and shadows any similarly named "
"variable in the outer scope.  Since the last statement in foo assigns a new "
"value to ``x``, the compiler recognizes it as a local variable.  "
"Consequently when the earlier ``print x`` attempts to print the "
"uninitialized local variable and an error results."
msgstr "これは、あるスコープの中で変数に代入を行うとき、その変数はそのスコープに対してローカルになり、外のスコープにある同じ名前の変数を隠すからです。 foo の最後の文が ``x`` に新しい値を代入しているので、コンパイラはこれをローカル変数であると認識します。その結果、先の ``print x`` が初期化されていないローカル変数を表示しようとして結果はエラーとなります。"

#: ../../faq/programming.rst:313
msgid ""
"In the example above you can access the outer scope variable by declaring it"
" global:"
msgstr "上の例では、グローバルであると宣言することで外のスコープにアクセスできます:"

#: ../../faq/programming.rst:324
msgid ""
"This explicit declaration is required in order to remind you that (unlike "
"the superficially analogous situation with class and instance variables) you"
" are actually modifying the value of the variable in the outer scope:"
msgstr "この明示的な宣言は (表面的には似ているクラスとインスタンス変数の例とは違って) あなたは実際は他のスコープの変数の値を変えようとしているのだ、ということを知らせるのに必要です:"

#: ../../faq/programming.rst:333
msgid "What are the rules for local and global variables in Python?"
msgstr "Python のローカルとグローバル変数のルールは何ですか？"

#: ../../faq/programming.rst:335
msgid ""
"In Python, variables that are only referenced inside a function are "
"implicitly global.  If a variable is assigned a value anywhere within the "
"function's body, it's assumed to be a local unless explicitly declared as "
"global."
msgstr "Python では、関数の中で参照のみされる変数は暗黙のうちにグローバルになります。関数の本体のどこかで値が変数に代入されたなら、それは明示的にグローバルであると宣言されない限り、ローカルであるとみなされます。"

#: ../../faq/programming.rst:339
msgid ""
"Though a bit surprising at first, a moment's consideration explains this.  "
"On one hand, requiring :keyword:`global` for assigned variables provides a "
"bar against unintended side-effects.  On the other hand, if ``global`` was "
"required for all global references, you'd be using ``global`` all the time."
"  You'd have to declare as global every reference to a built-in function or "
"to a component of an imported module.  This clutter would defeat the "
"usefulness of the ``global`` declaration for identifying side-effects."
msgstr "最初はちょっと驚くでしょうが、少し考えると納得できます。一方では、代入された変数に :keyword:`global` を要求することで、意図しない副作用を防げます。他方では、グローバルな参照の度に ``global`` が要求されてしまうと、 ``global`` を使ってばかりになってしまいます。ビルトイン関数やインポートされたモジュールの内容を参照するたびにグローバル宣言をしなければならないのです。その乱雑さは副作用を特定するための ``global`` 宣言の便利さよりも重大です。"

#: ../../faq/programming.rst:349
msgid ""
"Why do lambdas defined in a loop with different values all return the same "
"result?"
msgstr "ループの中で異なる値で定義されたラムダ式が、同じ値を返すのはなぜですか？"

#: ../../faq/programming.rst:351
msgid ""
"Assume you use a for loop to define a few different lambdas (or even plain "
"functions), e.g.::"
msgstr "for ループを使って、少しずつ異なるラムダを定義 (もしくは簡単な関数) するとします。例えば::"

#: ../../faq/programming.rst:358
msgid ""
"This gives you a list that contains 5 lambdas that calculate ``x**2``.  You "
"might expect that, when called, they would return, respectively, ``0``, "
"``1``, ``4``, ``9``, and ``16``.  However, when you actually try you will "
"see that they all return ``16``::"
msgstr "これで ``x**2`` を計算する 5 つのラムダのリストが得られます。それらを呼び出したとき、それぞれ ``0``、``1``、``4``、``9``、``16`` を返すと予想するかもしれません。しかし実際にやってみると、全て ``16`` が返ってくるのを目にするでしょう::"

#: ../../faq/programming.rst:368
msgid ""
"This happens because ``x`` is not local to the lambdas, but is defined in "
"the outer scope, and it is accessed when the lambda is called --- not when "
"it is defined.  At the end of the loop, the value of ``x`` is ``4``, so all "
"the functions now return ``4**2``, i.e. ``16``.  You can also verify this by"
" changing the value of ``x`` and see how the results of the lambdas change::"
msgstr "これは、``x`` がラムダにとってのローカル変数ではなく外側のスコープで定義されていて、ラムダが定義されたときでなく呼び出されたときにアクセスされるために起こります。ループが終わった時点では ``x`` は ``4`` であり、従って、全ての関数は ``4**2`` つまり ``16`` を返します。このことは ``x`` の値を変えてみることで検証でき、ラムダの返り値がどのように変わるのか観察できます::"

#: ../../faq/programming.rst:378
msgid ""
"In order to avoid this, you need to save the values in variables local to "
"the lambdas, so that they don't rely on the value of the global ``x``::"
msgstr "これを避けるためには、グローバルの ``x`` の値に依存しないために、ラムダにとってのローカル変数に値を保存する必要があります::"

#: ../../faq/programming.rst:385
msgid ""
"Here, ``n=x`` creates a new variable ``n`` local to the lambda and computed "
"when the lambda is defined so that it has the same value that ``x`` had at "
"that point in the loop.  This means that the value of ``n`` will be ``0`` in"
" the first lambda, ``1`` in the second, ``2`` in the third, and so on. "
"Therefore each lambda will now return the correct result::"
msgstr "ここで、``n=x`` は新しいラムダにとってのローカル変数 ``n`` を作成し、ラムダが定義されるときに計算されるので、ループのその時点での ``x`` と同じ値を持っています。これは、1 つ目のラムダでは ``n`` の値は ``0`` になり、2 つ目では ``1``、3 つ目では ``2`` 以下同様、となることを意味します。従って、それぞれのラムダは今や正しい値を返すようになりました::"

#: ../../faq/programming.rst:396
msgid ""
"Note that this behaviour is not peculiar to lambdas, but applies to regular "
"functions too."
msgstr "この動作はラムダに特有なものではなく、通常の関数にも適用されることに注意してください。"

#: ../../faq/programming.rst:401
msgid "How do I share global variables across modules?"
msgstr "グローバル変数をモジュール間で共有するにはどうしたらいいですか？"

#: ../../faq/programming.rst:403
msgid ""
"The canonical way to share information across modules within a single "
"program is to create a special module (often called config or cfg).  Just "
"import the config module in all modules of your application; the module then"
" becomes available as a global name.  Because there is only one instance of "
"each module, any changes made to the module object get reflected everywhere."
"  For example:"
msgstr "一つのプログラムのモジュール間で情報を共有する正準な方法は、特別なモジュール (しばしば config や cfg と呼ばれる) を作ることです。単に設定モジュールをアプリケーションのすべてのモジュールにインポートしてください。このモジュールはグローバルな名前として使えます。それぞれのモジュールのただ一つのインスタンスがあるので、設定モジュールオブジェクトに対するいかなる変更も全体に反映されます。例えば:"

#: ../../faq/programming.rst:409
msgid "config.py::"
msgstr "config.py::"

#: ../../faq/programming.rst:413
msgid "mod.py::"
msgstr "mod.py::"

#: ../../faq/programming.rst:418
msgid "main.py::"
msgstr "main.py::"

#: ../../faq/programming.rst:424
msgid ""
"Note that using a module is also the basis for implementing the Singleton "
"design pattern, for the same reason."
msgstr "なお、同じ理由から、モジュールを使うということは、シングルトンデザインパターンを実装することの基礎でもあります。"

#: ../../faq/programming.rst:429
msgid "What are the \"best practices\" for using import in a module?"
msgstr "モジュールで import を使う際の「ベストプラクティス」は何ですか？"

#: ../../faq/programming.rst:431
msgid ""
"In general, don't use ``from modulename import *``.  Doing so clutters the "
"importer's namespace, and makes it much harder for linters to detect "
"undefined names."
msgstr "一般的に ``from modulename import *`` を使ってはいけません。そのようにするとインポータの名前空間は汚染され、linter が未定義の名前を発見することが難しくなります。"

#: ../../faq/programming.rst:435
msgid ""
"Import modules at the top of a file.  Doing so makes it clear what other "
"modules your code requires and avoids questions of whether the module name "
"is in scope. Using one import per line makes it easy to add and delete "
"module imports, but using multiple imports per line uses less screen space."
msgstr "モジュールはファイルの先頭でインポートしてください。これによってコードが必要とする他のモジュールが明確になり、モジュール名がスコープに含まれるかどうかに迷わなくなります。行に一つのインポートにすると、モジュールのインポートの追加と削除が容易になりますが、行に複数のインポートにすると画面の領域が少なく済みます。"

#: ../../faq/programming.rst:440
msgid "It's good practice if you import modules in the following order:"
msgstr "次の手順でモジュールをインポートするのが、良いプラクティスになります:"

#: ../../faq/programming.rst:442
msgid "standard library modules -- e.g. ``sys``, ``os``, ``getopt``, ``re``"
msgstr "標準ライブラリモジュール -- 例 ``sys``、``os``、``getopt``、``re``"

#: ../../faq/programming.rst:443
msgid ""
"third-party library modules (anything installed in Python's site-packages "
"directory) -- e.g. mx.DateTime, ZODB, PIL.Image, etc."
msgstr "サードパーティのライブラリモジュール (Python の site-packages ディレクトリにあるもの) -- 例 mx.DateTime、ZODB、PIL.Image、など"

#: ../../faq/programming.rst:445
msgid "locally-developed modules"
msgstr "自前で開発したモジュール"

#: ../../faq/programming.rst:447
msgid ""
"Only use explicit relative package imports.  If you're writing code that's "
"in the ``package.sub.m1`` module and want to import ``package.sub.m2``, do "
"not just write ``import m2``, even though it's legal.  Write ``from "
"package.sub import m2`` or ``from . import m2`` instead."
msgstr "明示的な相対インポートだけを使ってください。 ``package.sub.m1`` モジュールのコードを書いていて、 ``package.sub.m2`` をインポートしようとするときに ``import m2`` だけで済ませるのはやめてください。たとえそれが合法でも。代わりに ``from package.sub import m2`` または ``from . import m2`` と書いてください。"

#: ../../faq/programming.rst:452
msgid ""
"It is sometimes necessary to move imports to a function or class to avoid "
"problems with circular imports.  Gordon McMillan says:"
msgstr "循環参照の問題を避けるために、インポートを関数やクラスに移すことが必要なときもあります。Gordon McMillan によれば:"

#: ../../faq/programming.rst:455
msgid ""
"Circular imports are fine where both modules use the \"import <module>\" "
"form of import.  They fail when the 2nd module wants to grab a name out of "
"the first (\"from module import name\") and the import is at the top level."
"  That's because names in the 1st are not yet available, because the first "
"module is busy importing the 2nd."
msgstr "循環参照は両方のモジュールが \"import <module>\" 形式のインポートを使っていれば大丈夫です。二つ目のモジュールが最初のモジュールから名前を確保しようとして (\"from module import name\")、そのインポートがトップレベルにあると駄目です。最初のモジュールが二つ目のモジュールをインポートするのに忙しくて、最初のモジュールの名前が利用可能になっていないからです。"

#: ../../faq/programming.rst:461
msgid ""
"In this case, if the second module is only used in one function, then the "
"import can easily be moved into that function.  By the time the import is "
"called, the first module will have finished initializing, and the second "
"module can do its import."
msgstr "この状況では、二つ目のモジュールが一つの関数の中でのみ使われているならば、そのインポートは簡単に関数の中に移せます。インポートが呼ばれたとき、最初のモジュールは初期化を完了していて、二つ目のモジュールは自分のインポートをできます。"

#: ../../faq/programming.rst:466
msgid ""
"It may also be necessary to move imports out of the top level of code if "
"some of the modules are platform-specific.  In that case, it may not even be"
" possible to import all of the modules at the top of the file.  In this "
"case, importing the correct modules in the corresponding platform-specific "
"code is a good option."
msgstr "プラットフォーム依存のモジュールがあるときには、インポートをトップレベルの外に動かすことも必要です。この場合、ファイルの先頭ではすべてのモジュールをインポートすることさえできないかもしれません。この場合は、対応するプラットフォームに合わせたコードで正しいモジュールをインポートすることを選ぶと良いです。"

#: ../../faq/programming.rst:471
msgid ""
"Only move imports into a local scope, such as inside a function definition, "
"if it's necessary to solve a problem such as avoiding a circular import or "
"are trying to reduce the initialization time of a module.  This technique is"
" especially helpful if many of the imports are unnecessary depending on how "
"the program executes.  You may also want to move imports into a function if "
"the modules are only ever used in that function.  Note that loading a module"
" the first time may be expensive because of the one time initialization of "
"the module, but loading a module multiple times is virtually free, costing "
"only a couple of dictionary lookups.  Even if the module name has gone out "
"of scope, the module is probably available in :data:`sys.modules`."
msgstr "循環参照の問題を避けたりモジュールの初期化にかかる時間を減らしたりしたいなら、単にインポートを関数定義の中などのローカルなスコープに移してください。この手法は多くのインポートがプログラムがどのように実行されるかに依存しなくてよいときに特に有効です。ある関数の中でのみモジュールが使われるのなら、インポートをその関数の中に移すことを考えてもいいでしょう。なお、モジュールを読み込む最初の回はモジュールの初期化の時間のために高価になりえますが、複数回目にモジュールを読み込むのは事実上無料、辞書探索の数回のコストだけで済みます。モジュール名がスコープから外れてさえ、そのモジュールはおそらく :data:`sys.modules` から利用できるでしょう。"

#: ../../faq/programming.rst:484
msgid "Why are default values shared between objects?"
msgstr "なぜオブジェクト間でデフォルト値が共有されるのですか？"

#: ../../faq/programming.rst:486
msgid ""
"This type of bug commonly bites neophyte programmers.  Consider this "
"function::"
msgstr "この種のバグがよく初心者プログラマに噛み付きます。この関数を考えてみてください::"

#: ../../faq/programming.rst:493
msgid ""
"The first time you call this function, ``mydict`` contains a single item.  "
"The second time, ``mydict`` contains two items because when ``foo()`` begins"
" executing, ``mydict`` starts out with an item already in it."
msgstr "初めてこの関数を呼び出した時、``mydict`` には一つの要素があります。二回目には、``foo()`` が実行されるときに ``mydict`` には初めから一つの要素をすでに持っているので、``mydict`` には二つの要素があります。"

#: ../../faq/programming.rst:497
msgid ""
"It is often expected that a function call creates new objects for default "
"values. This is not what happens. Default values are created exactly once, "
"when the function is defined.  If that object is changed, like the "
"dictionary in this example, subsequent calls to the function will refer to "
"this changed object."
msgstr "関数の呼び出しによって、デフォルトの値に対する新しいオブジェクトが作られるのだと予想しがちです。実はそうなりません。デフォルト値は、関数が定義されたときに一度だけ生成されます。この例の辞書のように、そのオブジェクトが変更されたとき、その後の関数の呼び出しは変更後のオブジェクトを参照します。"

#: ../../faq/programming.rst:502
msgid ""
"By definition, immutable objects such as numbers, strings, tuples, and "
"``None``, are safe from change. Changes to mutable objects such as "
"dictionaries, lists, and class instances can lead to confusion."
msgstr "定義の時に、数、文字列、タプル、``None`` など、イミュータブルなオブジェクトを使うと変更される危険がありません。辞書、リスト、クラスインスタンスなどのミュータブルなオブジェクトは混乱のもとです。"

#: ../../faq/programming.rst:506
msgid ""
"Because of this feature, it is good programming practice to not use mutable "
"objects as default values.  Instead, use ``None`` as the default value and "
"inside the function, check if the parameter is ``None`` and create a new "
"list/dictionary/whatever if it is.  For example, don't write::"
msgstr "この性質から、ミュータブルなオブジェクトをデフォルト値として使わないプログラミング手法がいいです。代わりに、``None`` をデフォルト値に使い、そのパラメタが ``None`` である時にだけ、関数の内部で新しいリスト/辞書/その他をつくるようにしてください。例えば、こう書かずに::"

#: ../../faq/programming.rst:514
msgid "but::"
msgstr "代わりに::"

#: ../../faq/programming.rst:520
msgid ""
"This feature can be useful.  When you have a function that's time-consuming "
"to compute, a common technique is to cache the parameters and the resulting "
"value of each call to the function, and return the cached value if the same "
"value is requested again.  This is called \"memoizing\", and can be "
"implemented like this::"
msgstr "この性質が便利なこともあります。時間のかかる計算を行う関数があるときに使われる一般的な技法は、関数が呼び出されるごとにパラメタと結果の値をキャッシュし、再び同じ値が要求されたらキャッシュされた値を返すというものです。これは \"memoizing\" と呼ばれ、このように実装されます::"

#: ../../faq/programming.rst:535
msgid ""
"You could use a global variable containing a dictionary instead of the "
"default value; it's a matter of taste."
msgstr "デフォルト値の代わりに、辞書を含むグローバル変数も使えます。これは好みの問題です。"

#: ../../faq/programming.rst:540
msgid ""
"How can I pass optional or keyword parameters from one function to another?"
msgstr "オプションパラメータやキーワードパラメータを関数から関数へ渡すにはどうしたらいいですか？"

#: ../../faq/programming.rst:542
msgid ""
"Collect the arguments using the ``*`` and ``**`` specifiers in the "
"function's parameter list; this gives you the positional arguments as a "
"tuple and the keyword arguments as a dictionary.  You can then pass these "
"arguments when calling another function by using ``*`` and ``**``::"
msgstr "関数のパラメータリストに引数を ``*`` と ``**`` 指定子 (specifier) で集めてください。そうすれば、固定引数をタプルとして、キーワード引数を辞書として得られます。これで、他の関数を呼び出すときに ``*`` と ``**`` を使ってそれらの引数を渡せます::"

#: ../../faq/programming.rst:553
msgid ""
"In the unlikely case that you care about Python versions older than 2.0, use"
" :func:`apply`::"
msgstr "あまりありませんが、Python の 2.0 以前のバージョンを考慮するときは、代わりに :func:`apply` を使ってください::"

#: ../../faq/programming.rst:570
msgid "What is the difference between arguments and parameters?"
msgstr "実引数と仮引数の違いは何ですか?"

#: ../../faq/programming.rst:572
msgid ""
":term:`Parameters <parameter>` are defined by the names that appear in a "
"function definition, whereas :term:`arguments <argument>` are the values "
"actually passed to a function when calling it.  Parameters define what types"
" of arguments a function can accept.  For example, given the function "
"definition::"
msgstr ":term:`仮引数 (parameter) <parameter>` は関数定義に表れる名前で定義されるのに対し、 :term:`実引数 (argument) <argument>` は関数を呼び出すときに実際に渡す値のことです。仮引数は関数が受け取ることの出来る実引数の型を定義します。例えば、以下のような関数定義があったとして::"

#: ../../faq/programming.rst:580
msgid ""
"*foo*, *bar* and *kwargs* are parameters of ``func``.  However, when calling"
" ``func``, for example::"
msgstr "*foo*、*bar*、*kwargs* は ``func`` の仮引数です。一方、``func`` を呼び出すときには、例えば::"

#: ../../faq/programming.rst:585
msgid "the values ``42``, ``314``, and ``somevar`` are arguments."
msgstr "``42``、``314``、``somevar`` という値は実引数です。"

#: ../../faq/programming.rst:589
msgid "Why did changing list 'y' also change list 'x'?"
msgstr "なぜ list 'y' を変更すると list 'x' も変更されるのですか?"

#: ../../faq/programming.rst:591
msgid "If you wrote code like::"
msgstr "次のようなコードを書いたとします::"

#: ../../faq/programming.rst:601
msgid ""
"you might be wondering why appending an element to ``y`` changed ``x`` too."
msgstr "どうして ``y`` への要素の追加が ``x`` も変更してしまうのか疑問に思うかもしれません。 "

#: ../../faq/programming.rst:603
msgid "There are two factors that produce this result:"
msgstr "このような結果になる2つの要因があります:"

#: ../../faq/programming.rst:605
msgid ""
"Variables are simply names that refer to objects.  Doing ``y = x`` doesn't "
"create a copy of the list -- it creates a new variable ``y`` that refers to "
"the same object ``x`` refers to.  This means that there is only one object "
"(the list), and both ``x`` and ``y`` refer to it."
msgstr "変数とは、単にオブジェクトを参照するための名前に過ぎません。 ``y = x`` とすることは、リストのコピーを作りません -- それは ``x`` が参照するのと同じオブジェクトを参照する新しい変数 ``y`` を作ります。つまり、あるのは一つのオブジェクト(この場合リスト)だけであって、 ``x`` と ``y`` の両方がそれを参照しているのです。"

#: ../../faq/programming.rst:609
msgid ""
"Lists are :term:`mutable`, which means that you can change their content."
msgstr "リストは :term:`mutable` です。内容を変更出来る、ということです。"

#: ../../faq/programming.rst:611
msgid ""
"After the call to :meth:`~list.append`, the content of the mutable object "
"has changed from ``[]`` to ``[10]``.  Since both the variables refer to the "
"same object, using either name accesses the modified value ``[10]``."
msgstr ":meth:`~list.append` 呼び出しの後、ミュータブルオブジェクトの内容が ``[]`` から ``[10]`` に変わります。 変数が同じオブジェクトを参照しているので、どちらの名前であっても変更された値 ``[10]`` にアクセスします。"

#: ../../faq/programming.rst:615
msgid "If we instead assign an immutable object to ``x``::"
msgstr "代わりに ``x`` にイミュータブルを代入すると::"

#: ../../faq/programming.rst:625
msgid ""
"we can see that in this case ``x`` and ``y`` are not equal anymore.  This is"
" because integers are :term:`immutable`, and when we do ``x = x + 1`` we are"
" not mutating the int ``5`` by incrementing its value; instead, we are "
"creating a new object (the int ``6``) and assigning it to ``x`` (that is, "
"changing which object ``x`` refers to).  After this assignment we have two "
"objects (the ints ``6`` and ``5``) and two variables that refer to them "
"(``x`` now refers to ``6`` but ``y`` still refers to ``5``)."
msgstr "この場合ご覧の通り ``x`` と ``y`` はまったく同じではありませんね。これは整数が :term:`immutable` だからで、 ``x = x + 1`` は整数の ``5`` の値を変更しているのではありません; 代わりに新しいオブジェクト(整数 ``6``)を作って ``x`` に代入しています (つまり ``x`` が参照するオブジェクトが変わります)。この代入の後では私たちは 2 つのオブジェクト(整数の ``6`` と ``5``)を持っていて、2 つの変数はそれらを参照しています(``x`` はいまや ``6`` を参照していますが ``y`` は ``5`` を参照したままです)。"

#: ../../faq/programming.rst:633
msgid ""
"Some operations (for example ``y.append(10)`` and ``y.sort()``) mutate the "
"object, whereas superficially similar operations (for example ``y = y + "
"[10]`` and ``sorted(y)``) create a new object.  In general in Python (and in"
" all cases in the standard library) a method that mutates an object will "
"return ``None`` to help avoid getting the two types of operations confused."
"  So if you mistakenly write ``y.sort()`` thinking it will give you a sorted"
" copy of ``y``, you'll instead end up with ``None``, which will likely cause"
" your program to generate an easily diagnosed error."
msgstr "ある演算 (たとえば ``y.append(10)``, ``y.sort()``) がオブジェクトを変更する一方で、外見上は似た演算 (たとえば ``y = y + [10]``, ``sorted(y)``) は新しいオブジェクトを作ります。Python では一般に (そして標準ライブラリの全てのケースで)、このような 2 つのタイプの演算にまつわる混乱を避けるために、オブジェクトを変更するメソッドは ``None`` を返します。ですからもしあなたが誤って ``y`` の複製の並び替えをするつもりで ``y.sort()`` と書いた場合に結果手にするのは ``None`` でしょうから、あなたのプログラムは簡単に診断出来るエラーを起こすでしょう。"

#: ../../faq/programming.rst:642
msgid ""
"However, there is one class of operations where the same operation sometimes"
" has different behaviors with different types:  the augmented assignment "
"operators.  For example, ``+=`` mutates lists but not tuples or ints "
"(``a_list += [1, 2, 3]`` is equivalent to ``a_list.extend([1, 2, 3])`` and "
"mutates ``a_list``, whereas ``some_tuple += (1, 2, 3)`` and ``some_int += "
"1`` create new objects)."
msgstr "しかしながら、同じ操作が型ごとに異なる振る舞いをする演算の種類が一つあります: 累算代入演算です。例えば ``+=`` はリストを変更しますが、タプルや整数は変更しません(``a_list += [1, 2, 3]`` は ``a_list.extend([1, 2, 3])`` と同じ意味で、そして ``a_list`` を変更しますが、 ``some_tuple += (1, 2, 3)`` と ``some_int += 1`` は新しいオブジェクトを作ります)。"

#: ../../faq/programming.rst:649
msgid "In other words:"
msgstr "言い換えると:"

#: ../../faq/programming.rst:651
msgid ""
"If we have a mutable object (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), we can use some specific operations to mutate it and all the "
"variables that refer to it will see the change."
msgstr "ミュータブルなオブジェクト(:class:`list`, :class:`dict`, :class:`set`, 等)を持っている場合、私たちはその内容を変更するある種の演算を使うことが出来、それを参照している全ての変数はその変化を見ることになるでしょう。"

#: ../../faq/programming.rst:654
msgid ""
"If we have an immutable object (:class:`str`, :class:`int`, :class:`tuple`, "
"etc.), all the variables that refer to it will always see the same value, "
"but operations that transform that value into a new value always return a "
"new object."
msgstr "イミュータブルなオブジェクト(:class:`str`, :class:`int`, :class:`tuple`, 等)を持っている場合、それを参照している全ての変数は同じ値を参照しているでしょうが、持っている値を新しい値に変換する演算はいつでも新しいオブジェクトを返します。"

#: ../../faq/programming.rst:659
msgid ""
"If you want to know if two variables refer to the same object or not, you "
"can use the :keyword:`is` operator, or the built-in function :func:`id`."
msgstr "2つの変数が同じオブジェクトを参照しているかどうかが知りたければ、 :keyword:`is` オペレータまたは組み込み関数 :func:`id` が使えます。"

#: ../../faq/programming.rst:664
msgid "How do I write a function with output parameters (call by reference)?"
msgstr "パラメータを出力する関数 (参照渡し) はどのように書きますか？"

#: ../../faq/programming.rst:666
msgid ""
"Remember that arguments are passed by assignment in Python.  Since "
"assignment just creates references to objects, there's no alias between an "
"argument name in the caller and callee, and so no call-by-reference per se."
"  You can achieve the desired effect in a number of ways."
msgstr "前提として、Python では引数は代入によって渡されます。代入はオブジェクトへの参照を作るだけなので、呼び出し元と呼び出し先にある引数名の間にエイリアスはありませんし、参照渡しそれ自体はありません。望む効果を得るためには幾つかの方法があります。"

#: ../../faq/programming.rst:671
msgid "By returning a tuple of the results::"
msgstr "結果のタプルを返すことによって::"

#: ../../faq/programming.rst:682
msgid "This is almost always the clearest solution."
msgstr "これはたいてい一番明確な方法です。"

#: ../../faq/programming.rst:684
msgid ""
"By using global variables.  This isn't thread-safe, and is not recommended."
msgstr "グローバル変数を使って。これはスレッドセーフでないので、推奨されません。"

#: ../../faq/programming.rst:686
msgid "By passing a mutable (changeable in-place) object::"
msgstr "ミュータブルな (インプレースに変更可能な) オブジェクトを渡すことによって::"

#: ../../faq/programming.rst:696
msgid "By passing in a dictionary that gets mutated::"
msgstr "変更される辞書に渡すことによって::"

#: ../../faq/programming.rst:706
msgid "Or bundle up values in a class instance::"
msgstr "または、クラスインスタンスに値を同梱することによって::"

#: ../../faq/programming.rst:722
msgid "There's almost never a good reason to get this complicated."
msgstr "このような複雑なことをする理由はめったに無いでしょう。"

#: ../../faq/programming.rst:724
msgid "Your best choice is to return a tuple containing the multiple results."
msgstr "一番の選択は、複数の結果を含むタプルを返すことです。"

#: ../../faq/programming.rst:728
msgid "How do you make a higher order function in Python?"
msgstr "Python で高次関数はどのようにつくりますか？"

#: ../../faq/programming.rst:730
msgid ""
"You have two choices: you can use nested scopes or you can use callable "
"objects. For example, suppose you wanted to define ``linear(a,b)`` which "
"returns a function ``f(x)`` that computes the value ``a*x+b``.  Using nested"
" scopes::"
msgstr "二つの方法があります: ネストされたスコープを使う方法と、呼び出し可能オブジェクトを使う方法です。例えば、``a*x+b`` の値を計算する ``f(x)`` 関数を返す ``linear(a,b)`` を定義したいとします。ネストされたスコープを使うと::"

#: ../../faq/programming.rst:739
msgid "Or using a callable object::"
msgstr "また、呼び出し可能オブジェクトを使うと::"

#: ../../faq/programming.rst:749
msgid "In both cases, ::"
msgstr "どちらの場合でも、 ::"

#: ../../faq/programming.rst:753
msgid "gives a callable object where ``taxes(10e6) == 0.3 * 10e6 + 2``."
msgstr "とすれば、``taxes(10e6) == 0.3 * 10e6 + 2`` となるような呼び出し可能オブジェクトを得られます。"

#: ../../faq/programming.rst:755
msgid ""
"The callable object approach has the disadvantage that it is a bit slower "
"and results in slightly longer code.  However, note that a collection of "
"callables can share their signature via inheritance::"
msgstr "呼び出し可能オブジェクトを使う方法は、少し遅くなり、わずかにコードが長くなるという短所があります。ですが、継承を使ってコーラブル同士で記号を共有することもできます::"

#: ../../faq/programming.rst:764
msgid "Object can encapsulate state for several methods::"
msgstr "オブジェクトはいくつかのメソッドに状態をカプセル化できます::"

#: ../../faq/programming.rst:782
msgid ""
"Here ``inc()``, ``dec()`` and ``reset()`` act like functions which share the"
" same counting variable."
msgstr "ここで、``inc()``、``dec()``、``reset()`` は同じカウント変数を共有する関数のようにふるまいます。"

#: ../../faq/programming.rst:787
msgid "How do I copy an object in Python?"
msgstr "Python のオブジェクトはどのようにコピーしますか？"

#: ../../faq/programming.rst:789
msgid ""
"In general, try :func:`copy.copy` or :func:`copy.deepcopy` for the general "
"case. Not all objects can be copied, but most can."
msgstr "一般的に、普通は :func:`copy.copy` や :func:`copy.deepcopy` を試してください。何でもコピーできるとは限りませんが、たいていはできます。"

#: ../../faq/programming.rst:792
msgid ""
"Some objects can be copied more easily.  Dictionaries have a "
":meth:`~dict.copy` method::"
msgstr "もっと簡単にコピーできるオブジェクトもあります。辞書には :meth:`~dict.copy` メソッドがあります::"

#: ../../faq/programming.rst:797
msgid "Sequences can be copied by slicing::"
msgstr "シーケンスはスライシングでコピーできます::"

#: ../../faq/programming.rst:803
msgid "How can I find the methods or attributes of an object?"
msgstr "オブジェクトのメソッドや属性はどのように見つけますか？"

#: ../../faq/programming.rst:805
msgid ""
"For an instance x of a user-defined class, ``dir(x)`` returns an "
"alphabetized list of the names containing the instance attributes and "
"methods and attributes defined by its class."
msgstr "ユーザー定義クラスのインスタンス x で、``dir(x)`` はインスタンス属性とそのクラスで定義されたメソッドや属性を含む名前のアルファベット順リストを返します。"

#: ../../faq/programming.rst:811
msgid "How can my code discover the name of an object?"
msgstr "コードはどのようにオブジェクトの名前を見つけるのですか？"

#: ../../faq/programming.rst:813
msgid ""
"Generally speaking, it can't, because objects don't really have names. "
"Essentially, assignment always binds a name to a value; The same is true of "
"``def`` and ``class`` statements, but in that case the value is a callable. "
"Consider the following code::"
msgstr "概して、オブジェクトは本当は名前を持たないので、見つけることはできません。本質的には、代入とはいつも値に名前を束縛することです。``def`` と ``class`` 文も同じですが、この場合は値はコーラブルです。以下のコードを考えてみましょう::"

#: ../../faq/programming.rst:829
msgid ""
"Arguably the class has a name: even though it is bound to two names and "
"invoked through the name B the created instance is still reported as an "
"instance of class A.  However, it is impossible to say whether the "
"instance's name is a or b, since both names are bound to the same value."
msgstr "おそらく、このクラスには名前があります。このクラスは二つの名前に縛られて、名前 B を通して呼び出されますが、それでもクラス A のインスタンスとして報告されるのです。しかし、両方の名前が同じ値に束縛されている以上、このインスタンスの名前が a か b か決めることはできないのです。"

#: ../../faq/programming.rst:834
msgid ""
"Generally speaking it should not be necessary for your code to \"know the "
"names\" of particular values. Unless you are deliberately writing "
"introspective programs, this is usually an indication that a change of "
"approach might be beneficial."
msgstr "概して、コードにとってある値の「名前を知っている」事は重要ではありません。あなたがわざと内省的なコードを書いているのでない限り、方針を変えた方がいいかもしれないということになるでしょう。"

#: ../../faq/programming.rst:839
msgid ""
"In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer "
"to this question:"
msgstr "comp.lang.python で、Fredrik Lundh はこの問題の答えとして素晴らしい喩えをしてくれました:"

#: ../../faq/programming.rst:842
msgid ""
"The same way as you get the name of that cat you found on your porch: the "
"cat (object) itself cannot tell you its name, and it doesn't really care -- "
"so the only way to find out what it's called is to ask all your neighbours "
"(namespaces) if it's their cat (object)..."
msgstr "玄関にいた猫の名前を知るのと同じ方法です: その猫 (オブジェクト) 自体はその名前を言うことができないし、それは実は問題ではありません -- その猫が何と呼ばれているかを知る唯一の方法は、すべての隣人 (名前空間) にその猫 (オブジェクト) が何と呼ばれているかを聞くことです。"

#: ../../faq/programming.rst:847
msgid ""
"....and don't be surprised if you'll find that it's known by many names, or "
"no name at all!"
msgstr "……そして、その猫が沢山の名前で知られていたり、逆に全く名前が無かったりしても驚かないでください！"

#: ../../faq/programming.rst:852
msgid "What's up with the comma operator's precedence?"
msgstr "カンマ演算子はなぜ優先されるのですか？"

#: ../../faq/programming.rst:854
msgid "Comma is not an operator in Python.  Consider this session::"
msgstr "カンマは Python では演算子ではありません。このセッションを考えてください::"

#: ../../faq/programming.rst:859
msgid ""
"Since the comma is not an operator, but a separator between expressions the "
"above is evaluated as if you had entered::"
msgstr "カンマは演算子ではなく、式の分離子なので、上の式は次の式と同じように評価されます::"

#: ../../faq/programming.rst:864
msgid "not::"
msgstr "こうではありません::"

#: ../../faq/programming.rst:868
msgid ""
"The same is true of the various assignment operators (``=``, ``+=`` etc).  "
"They are not truly operators but syntactic delimiters in assignment "
"statements."
msgstr "他のさまざまな演算子(``=``、``+=`` など)も同じです。これらは真の演算子ではありませんが、代入文の構文上のデリミタです。"

#: ../../faq/programming.rst:873
msgid "Is there an equivalent of C's \"?:\" ternary operator?"
msgstr "C の \"?:\" 三項演算子と等価なものはありますか？"

#: ../../faq/programming.rst:875
msgid ""
"Yes, this feature was added in Python 2.5. The syntax would be as follows::"
msgstr "はい、この機能は Python 2.5 で追加されました。構文は以下のようになります::"

#: ../../faq/programming.rst:883
msgid "For versions previous to 2.5 the answer would be 'No'."
msgstr "2.5 以前のバージョンについては、これの答えは「いいえ」です。"

#: ../../faq/programming.rst:887
msgid "Is it possible to write obfuscated one-liners in Python?"
msgstr "Python で解し難いワンライナーを書くことはできますか？"

#: ../../faq/programming.rst:889
msgid ""
"Yes.  Usually this is done by nesting :keyword:`lambda` within "
":keyword:`lambda`.  See the following three examples, due to Ulf Bartelt::"
msgstr "はい。そういうものはたいてい、 :keyword:`lambda` の中に :keyword:`lambda` がネストされています。Ulf Bartelt による下の３つの例を見てください::"

#: ../../faq/programming.rst:914
msgid "Don't try this at home, kids!"
msgstr "よい子はまねしないでね！"

#: ../../faq/programming.rst:918
msgid "Numbers and strings"
msgstr "数と文字列"

#: ../../faq/programming.rst:921
msgid "How do I specify hexadecimal and octal integers?"
msgstr "十六進数や八進数を指定するにはどうしたらいいですか？"

#: ../../faq/programming.rst:923
msgid ""
"To specify an octal digit, precede the octal value with a zero, and then a "
"lower or uppercase \"o\".  For example, to set the variable \"a\" to the "
"octal value \"10\" (8 in decimal), type::"
msgstr "八進数を指定するには、八進数での値の先頭に 0 と \"o\" (小文字または大文字) を加えてください。たとえば、変数 \"a\" に八進数での \"10\" (十進数での\"8\") を代入するには、こう打ってください::"

#: ../../faq/programming.rst:931
msgid ""
"Hexadecimal is just as easy.  Simply precede the hexadecimal number with a "
"zero, and then a lower or uppercase \"x\".  Hexadecimal digits can be "
"specified in lower or uppercase.  For example, in the Python interpreter::"
msgstr "十六進数も簡単です。ただ十六進数での値の先頭に 0 と \"x\" (小文字または大文字) を加えてください。十六進数は小文字でも大文字でも指定できます。たとえば、Python インタプリタで::"

#: ../../faq/programming.rst:944
msgid "Why does -22 // 10 return -3?"
msgstr "なぜ -22 // 10 は -3 を返すのですか？"

#: ../../faq/programming.rst:946
msgid ""
"It's primarily driven by the desire that ``i % j`` have the same sign as "
"``j``. If you want that, and also want::"
msgstr "``i % j`` が ``j`` と同じ符号であってほしいことに基づいています。それに加えて以下のようにもしたいとすると::"

#: ../../faq/programming.rst:951
msgid ""
"then integer division has to return the floor.  C also requires that "
"identity to hold, and then compilers that truncate ``i // j`` need to make "
"``i % j`` have the same sign as ``i``."
msgstr "整数除算は床を返すことになります。C にも C の一貫性があって、``i % j`` が ``i`` と同じ符号を持つように ``i // j`` を丸めています。"

#: ../../faq/programming.rst:955
msgid ""
"There are few real use cases for ``i % j`` when ``j`` is negative.  When "
"``j`` is positive, there are many, and in virtually all of them it's more "
"useful for ``i % j`` to be ``>= 0``.  If the clock says 10 now, what did it "
"say 200 hours ago?  ``-190 % 12 == 2`` is useful; ``-190 % 12 == -10`` is a "
"bug waiting to bite."
msgstr "``i % j`` は、``j`` が負の時には実際にはほとんど使いません。``j`` が正なら、たくさん使います。その事実上すべての場合、``i % j`` は ``>= 0`` となる方が便利です。時計が 10 時を指している時、その 200 時間前は何時でしょうか。``-190 % 12 == 2`` となるのが便利です。``-190 % 12 == -10`` は噛み付きかねないバグです。"

#: ../../faq/programming.rst:963
msgid ""
"On Python 2, ``a / b`` returns the same as ``a // b`` if "
"``__future__.division`` is not in effect.  This is also known as \"classic\""
" division."
msgstr "Python 2 では、  ``__future__.division`` が有効でなければ、``a / b`` は ``a // b`` と同じ結果を返します。これは \"古典的な (classic)\" 除算とも呼ばれます。"

#: ../../faq/programming.rst:969
msgid "How do I convert a string to a number?"
msgstr "文字列を数に変換するにはどうしたらいいですか？"

#: ../../faq/programming.rst:971
msgid ""
"For integers, use the built-in :func:`int` type constructor, e.g. "
"``int('144') == 144``.  Similarly, :func:`float` converts to floating-point,"
" e.g. ``float('144') == 144.0``."
msgstr "整数に変換するには、組み込みの :func:`int` 型コンストラクタを使ってください。例えば、 ``int('144') == 144`` です。同様に、 :func:`float` は浮動小数点に変換します。例えば、 ``float('144') == 144.0`` です。"

#: ../../faq/programming.rst:975
msgid ""
"By default, these interpret the number as decimal, so that ``int('0144') == "
"144`` and ``int('0x144')`` raises :exc:`ValueError`. ``int(string, base)`` "
"takes the base to convert from as a second optional argument, so "
"``int('0x144', 16) == 324``.  If the base is specified as 0, the number is "
"interpreted using Python's rules: a leading '0' indicates octal, and '0x' "
"indicates a hex number."
msgstr "デフォルトでは、これらは数を十進数として解釈するので、 ``int('0o144')`` や ``int('0x144')`` は :exc:`ValueError` を送出します。 ``int(string, base)`` はオプションの第二引数をとって変換元の基数にします。つまり ``int('0x144', 16) == 324`` です。基数が 0 と指定された場合、その数は Python の基準によって解釈されます。先頭が '0o' なら八進数で、'0x' なら十六進数を表します。"

#: ../../faq/programming.rst:981
msgid ""
"Do not use the built-in function :func:`eval` if all you need is to convert "
"strings to numbers.  :func:`eval` will be significantly slower and it "
"presents a security risk: someone could pass you a Python expression that "
"might have unwanted side effects.  For example, someone could pass "
"``__import__('os').system(\"rm -rf $HOME\")`` which would erase your home "
"directory."
msgstr "文字列を数に変換するだけのために :func:`eval` を使わないでください。 :func:`eval` は特に遅いですし、セキュリティ上のリスクもあります。求められない副作用を持つような Python の式を渡そうとする人がいるかも知れません。例えば、あなたのホームディレクトリを消去する ``__import__('os').system(\"rm -rf $HOME\")`` を渡そうとする人がいるかも知れません。"

#: ../../faq/programming.rst:988
msgid ""
":func:`eval` also has the effect of interpreting numbers as Python "
"expressions, so that e.g. ``eval('09')`` gives a syntax error because Python"
" regards numbers starting with '0' as octal (base 8)."
msgstr ":func:`eval` にも数を Python の式として解釈する機能があります。だから例えば、 ``eval('09')`` は構文エラー起こします。Python は '0' で始まる数を八進数 (基数 8) とみなすからです。"

#: ../../faq/programming.rst:994
msgid "How do I convert a number to a string?"
msgstr "数を文字列に変換するにはどうしたらいいですか？"

#: ../../faq/programming.rst:996
msgid ""
"To convert, e.g., the number 144 to the string '144', use the built-in type "
"constructor :func:`str`.  If you want a hexadecimal or octal representation,"
" use the built-in functions :func:`hex` or :func:`oct`.  For fancy "
"formatting, see the :ref:`formatstrings` section, e.g. "
"``\"{:04d}\".format(144)`` yields ``'0144'`` and ``\"{:.3f}\".format(1/3)`` "
"yields ``'0.333'``.  You may also use :ref:`the % operator <string-"
"formatting>` on strings.  See the library reference manual for details."
msgstr "例えば、144 という数を '144' という文字列に変換したいなら、組み込みの型コンストラクタ :func:`str` を使ってください。十六進数や八進数にしたければ、組み込み関数の :func:`hex` や :func:`oct` を使ってください。装飾された形式にするには、 :ref:`formatstrings` の項を参照してください。例えば、 ``\"{:04d}\".format(144)`` は ``'0144'`` になり、 ``\"{:.3f}\".format(1/3)`` は ``'0.333'`` になります。文字列に :ref:`% 演算子 <string-formatting>` を使うこともできます。詳細はライブラリリファレンスの解説を参照してください。"

#: ../../faq/programming.rst:1006
msgid "How do I modify a string in place?"
msgstr "文字列をインプレースに変更するにはどうしたらいいですか？"

#: ../../faq/programming.rst:1008
msgid ""
"You can't, because strings are immutable.  If you need an object with this "
"ability, try converting the string to a list or use the array module::"
msgstr "文字列はイミュータブルなので、変更することはできません。それができるオブジェクトを作るには、その文字列をリストに変換してみるか、array モジュールを使ってください::"

#: ../../faq/programming.rst:1031
msgid "How do I use strings to call functions/methods?"
msgstr "関数やメソッドを呼ぶのに文字列を使うにはどうしたらいいですか？"

#: ../../faq/programming.rst:1033
msgid "There are various techniques."
msgstr "様々なテクニックがあります。"

#: ../../faq/programming.rst:1035
msgid ""
"The best is to use a dictionary that maps strings to functions.  The primary"
" advantage of this technique is that the strings do not need to match the "
"names of the functions.  This is also the primary technique used to emulate "
"a case construct::"
msgstr "一番いいのは、文字列を関数に対応させる辞書を使うことです。このテクニックの一番の利点は、文字列が関数の名前と同じ必要がないことです。この方法は case 構造をエミュレートするための一番のテクニックでもあります::"

#: ../../faq/programming.rst:1050
msgid "Use the built-in function :func:`getattr`::"
msgstr "組み込み関数の :func:`getattr` を使う方法::"

#: ../../faq/programming.rst:1055
msgid ""
"Note that :func:`getattr` works on any object, including classes, class "
"instances, modules, and so on."
msgstr "なお、 :func:`getattr` はクラス、クラスインスタンス、モジュールなど、どんなオブジェクトにも使えます。"

#: ../../faq/programming.rst:1058
msgid "This is used in several places in the standard library, like this::"
msgstr "これは標準ライブラリでも何箇所か使われています。このように::"

#: ../../faq/programming.rst:1071
msgid "Use :func:`locals` or :func:`eval` to resolve the function name::"
msgstr ":func:`locals` や :func:`eval` を使って関数名を決める方法::"

#: ../../faq/programming.rst:1084
msgid ""
"Note: Using :func:`eval` is slow and dangerous.  If you don't have absolute "
"control over the contents of the string, someone could pass a string that "
"resulted in an arbitrary function being executed."
msgstr "ノート: :func:`eval` の使用は遅いし危険です。もしあなたが文字列の内容を絶対的に支配できなければ、任意の関数を実行されるようにする文字列を渡す人がいるかも知れません。"

#: ../../faq/programming.rst:1089
msgid ""
"Is there an equivalent to Perl's chomp() for removing trailing newlines from"
" strings?"
msgstr "文字列から後端の改行を取り除く Perl の chomp() に相当するものはありますか？"

#: ../../faq/programming.rst:1091
msgid ""
"Starting with Python 2.2, you can use ``S.rstrip(\"\\r\\n\")`` to remove all"
" occurrences of any line terminator from the end of the string ``S`` without"
" removing other trailing whitespace.  If the string ``S`` represents more "
"than one line, with several empty lines at the end, the line terminators for"
" all the blank lines will be removed::"
msgstr "Python 2.2 からは、 ``S.rstrip(\"\\r\\n\")`` を使って文字列 ``S`` の終端から他の空白文字を取り除くことなくすべての行末記号を取り除くことができます。文字列 ``S`` が複数行を表し、終端に空行があるとき、そのすべての空行も取り除かれます::"

#: ../../faq/programming.rst:1103
msgid ""
"Since this is typically only desired when reading text one line at a time, "
"using ``S.rstrip()`` this way works well."
msgstr "これは典型的に一度に一行ずつテキストを読みたい時にのみ使われるので、``S.rstrip()`` をこの方法で使うとうまくいきます。"

#: ../../faq/programming.rst:1106
msgid "For older versions of Python, there are two partial substitutes:"
msgstr "古いバージョンの Python では、部分的な代用品が二つあります:"

#: ../../faq/programming.rst:1108
msgid ""
"If you want to remove all trailing whitespace, use the ``rstrip()`` method "
"of string objects.  This removes all trailing whitespace, not just a single "
"newline."
msgstr "すべての終端の空白文字を取り除きたいなら、文字列オブジェクトの ``rstrip()`` メソッドを使ってください。これは改行記号一つだけでなく、すべての終端の空白文字を取り除きます。"

#: ../../faq/programming.rst:1112
msgid ""
"Otherwise, if there is only one line in the string ``S``, use "
"``S.splitlines()[0]``."
msgstr "そうでなく、文字列 ``S`` に一行しか無いなら、``S.splitlines()[0]`` を使ってください。"

#: ../../faq/programming.rst:1117
msgid "Is there a scanf() or sscanf() equivalent?"
msgstr "scanf() や sscanf() と同等なものはありますか？"

#: ../../faq/programming.rst:1119
msgid "Not as such."
msgstr "そのようなものはありません。"

#: ../../faq/programming.rst:1121
msgid ""
"For simple input parsing, the easiest approach is usually to split the line "
"into whitespace-delimited words using the :meth:`~str.split` method of "
"string objects and then convert decimal strings to numeric values using "
":func:`int` or :func:`float`.  ``split()`` supports an optional \"sep\" "
"parameter which is useful if the line uses something other than whitespace "
"as a separator."
msgstr "簡単な入力解析で、多くの場合に一番簡単な方法は、文字列オブジェクトの :meth:`~str.split` メソッドで行を空白文字で区切られた単語に分け、十進数の文字列を :func:`int` や :func:`float` で数値に変換することです。 ``split()`` にはオプションの \"sep\" 変数があり、行に空白文字以外の区切りを使っているときに便利です。"

#: ../../faq/programming.rst:1127
msgid ""
"For more complicated input parsing, regular expressions are more powerful "
"than C's :c:func:`sscanf` and better suited for the task."
msgstr "もっと複雑な入力解析をしたいなら、C の :c:func:`sscanf` よりも正規表現の方が便利ですし、この処理に向いています。"

#: ../../faq/programming.rst:1132
msgid ""
"What does 'UnicodeError: ASCII [decoding,encoding] error: ordinal not in "
"range(128)' mean?"
msgstr "'UnicodeError: ASCII [decoding,encoding] error: ordinal not in range(128)' とはどういう意味ですか？"

#: ../../faq/programming.rst:1134
msgid ""
"This error indicates that your Python installation can handle only 7-bit "
"ASCII strings.  There are a couple ways to fix or work around the problem."
msgstr "このエラーは、あなたの Python インストールが 7-bit ASCII 文字列しか扱えないことを表します。この問題を扱うには二つの方法があります。"

#: ../../faq/programming.rst:1137
msgid ""
"If your programs must handle data in arbitrary character set encodings, the "
"environment the application runs in will generally identify the encoding of "
"the data it is handing you.  You need to convert the input to Unicode data "
"using that encoding.  For example, a program that handles email or web input"
" will typically find character set encoding information in Content-Type "
"headers.  This can then be used to properly convert input data to Unicode. "
"Assuming the string referred to by ``value`` is encoded as UTF-8::"
msgstr "あなたのプログラムが、任意の文字セットエンコーディングのデータを扱わなければならないなら、一般に、アプリケーションが起動する環境によってデータのエンコーディングが特定されます。入力をそのエンコーディングを使って Unicode に変換する必要があります。例えば、email や web 入力を扱うプログラムは、概して文字セットエンコーディング情報を Content-Type ヘッダから見つけます。これに使うことで、入力データを Unicode に正しく変換できます。 ``value`` によって参照される文字列が UTF-8 でエンコードされているとすれば::"

#: ../../faq/programming.rst:1147
msgid ""
"will return a Unicode object.  If the data is not correctly encoded as "
"UTF-8, the above call will raise a :exc:`UnicodeError` exception."
msgstr "は Unicode オブジェクトを返します。データが UTF-8 に正しく変換されないなら、上記の呼び出しは :exc:`UnicodeError` 例外を送出します。"

#: ../../faq/programming.rst:1150
msgid ""
"If you only want strings converted to Unicode which have non-ASCII data, you"
" can try converting them first assuming an ASCII encoding, and then generate"
" Unicode objects if that fails::"
msgstr "非 ASCII データを持つ文字列を Unicode に変換すればいいだけなら、まず ASCII エンコーディングを仮定して変換し、失敗したら Unicode オブジェクトを生成すればいいです::"

#: ../../faq/programming.rst:1162
msgid ""
"It's possible to set a default encoding in a file called "
"``sitecustomize.py`` that's part of the Python library.  However, this isn't"
" recommended because changing the Python-wide default encoding may cause "
"third-party extension modules to fail."
msgstr "デフォルトのエンコーディングは、Python ライブラリの一部である ``sitecustomize.py`` と呼ばれるファイルで設定できます。しかし、Python 全体におけるデフォルトのエンコーディングを変えてしまうことは、サードパーティ拡張モジュールの失敗につながるのでお勧めできません。"

#: ../../faq/programming.rst:1167
msgid ""
"Note that on Windows, there is an encoding known as \"mbcs\", which uses an "
"encoding specific to your current locale.  In many cases, and particularly "
"when working with COM, this may be an appropriate default encoding to use."
msgstr "なお、Windows には、 \"mbcs\" として知られるエンコーディングがあり、これはあなたのロケールに依存するエンコーディイングを使います。多くの場合、特に COM で作業をするとき、これが使うのに適したデフォルトのエンコーディングです。"

#: ../../faq/programming.rst:1173
msgid "Sequences (Tuples/Lists)"
msgstr "シーケンス(タプル/リスト)"

#: ../../faq/programming.rst:1176
msgid "How do I convert between tuples and lists?"
msgstr "タプル、リスト間の変更はどのようにするのですか？"

#: ../../faq/programming.rst:1178
msgid ""
"The type constructor ``tuple(seq)`` converts any sequence (actually, any "
"iterable) into a tuple with the same items in the same order."
msgstr "型コンストラクタ ``tuple(seq)`` はすべてのシーケンス (実際には、すべてのイテラブル) を同じ要素、同じ順序のタプルに変換します。"

#: ../../faq/programming.rst:1181
msgid ""
"For example, ``tuple([1, 2, 3])`` yields ``(1, 2, 3)`` and ``tuple('abc')`` "
"yields ``('a', 'b', 'c')``.  If the argument is a tuple, it does not make a "
"copy but returns the same object, so it is cheap to call :func:`tuple` when "
"you aren't sure that an object is already a tuple."
msgstr "例えば、 ``tuple([1, 2, 3])`` は ``(1, 2, 3)`` を与え、 ``tuple('abc')`` は ``('a', 'b', 'c')`` を与えます。引数がタプルなら、コピーを作らずに引数のオブジェクトそのものを返すので、あるオブジェクトが既にタプルになっているか確信が持てないのなら、 :func:`tuple` を呼ぶのが手軽です。"

#: ../../faq/programming.rst:1186
msgid ""
"The type constructor ``list(seq)`` converts any sequence or iterable into a "
"list with the same items in the same order.  For example, ``list((1, 2, "
"3))`` yields ``[1, 2, 3]`` and ``list('abc')`` yields ``['a', 'b', 'c']``.  "
"If the argument is a list, it makes a copy just like ``seq[:]`` would."
msgstr "型コンストラクタ ``list(seq)`` はすべてのシーケンスあるいはイテラブルを同じ要素、同じ順序のリストに変換します。例えば、``list((1, 2, 3))`` は ``[1, 2, 3]`` を与え、``list('abc')`` は ``['a', 'b', 'c']`` を与えます。引数がリストなら、``seq[:]`` と同様にコピーを作ります。"

#: ../../faq/programming.rst:1193
msgid "What's a negative index?"
msgstr "インデクスが負の場合はどうなりますか？"

#: ../../faq/programming.rst:1195
msgid ""
"Python sequences are indexed with positive numbers and negative numbers.  "
"For positive numbers 0 is the first index 1 is the second index and so "
"forth.  For negative indices -1 is the last index and -2 is the penultimate "
"(next to last) index and so forth.  Think of ``seq[-n]`` as the same as "
"``seq[len(seq)-n]``."
msgstr "Python のシーケンスは正の数と負の数でインデクスされます。正の数では、0 が最初のインデクス、1 が 2 番目のインデクス、以下も同様です。負のインデクスでは、-1 が最後のインデクス、-2 が最後から 2 番目のインデクス、以下も同様です。``seq[-n]`` は ``seq[len(seq)-n]`` と同じだと考えてください。"

#: ../../faq/programming.rst:1200
msgid ""
"Using negative indices can be very convenient.  For example ``S[:-1]`` is "
"all of the string except for its last character, which is useful for "
"removing the trailing newline from a string."
msgstr "負のインデクスを使うと便利なことがあります。例えば、``S[:-1]`` は文字列の最後以外のすべての文字を表すので、文字列の末尾の改行を取り除くときに便利です。"

#: ../../faq/programming.rst:1206
msgid "How do I iterate over a sequence in reverse order?"
msgstr "シーケンスを逆順にイテレートするにはどうしたらいいですか？"

#: ../../faq/programming.rst:1208
msgid ""
"Use the :func:`reversed` built-in function, which is new in Python 2.4::"
msgstr "Python 2.4 で追加された :func:`reversed` を使ってください::"

#: ../../faq/programming.rst:1213
msgid ""
"This won't touch your original sequence, but build a new copy with reversed "
"order to iterate over."
msgstr "これは元のシーケンスをいじるのではなく、逆順の新しいコピーを作ってイテレートさせます。"

#: ../../faq/programming.rst:1216
msgid "With Python 2.3, you can use an extended slice syntax::"
msgstr "Python 2.3 では、拡張スライス構文を使います::"

#: ../../faq/programming.rst:1223
msgid "How do you remove duplicates from a list?"
msgstr "リストから重複を取り除くにはどうしますか？"

#: ../../faq/programming.rst:1225
msgid "See the Python Cookbook for a long discussion of many ways to do this:"
msgstr "Python Cookbook の長い議論に多くの方法があるので参照してください:"

#: ../../faq/programming.rst:1227
msgid "https://code.activestate.com/recipes/52560/"
msgstr "https://code.activestate.com/recipes/52560/"

#: ../../faq/programming.rst:1229
msgid ""
"If you don't mind reordering the list, sort it and then scan from the end of"
" the list, deleting duplicates as you go::"
msgstr "リストを並び替えて構わないのなら、ソートした上でリストの最初から最後までを調べ、次のように重複を削除してください::"

#: ../../faq/programming.rst:1241
msgid ""
"If all elements of the list may be used as dictionary keys (i.e. they are "
"all hashable) this is often faster ::"
msgstr "リストのすべての要素が辞書のキーとして使える (つまり、すべての要素が hashable) なら、おそらくこのほうが速いです::"

#: ../../faq/programming.rst:1249
msgid "In Python 2.5 and later, the following is possible instead::"
msgstr "Python 2.5 以上では、以下を代わりに使えます::"

#: ../../faq/programming.rst:1253
msgid ""
"This converts the list into a set, thereby removing duplicates, and then "
"back into a list."
msgstr "リストを集合に変換するときに重複は取り除かれるので、それをリストに戻せばいいのです。"

#: ../../faq/programming.rst:1258
msgid "How do you make an array in Python?"
msgstr "Python で配列を作るにはどうしますか？"

#: ../../faq/programming.rst:1260
msgid "Use a list::"
msgstr "リストを使ってください::"

#: ../../faq/programming.rst:1264
msgid ""
"Lists are equivalent to C or Pascal arrays in their time complexity; the "
"primary difference is that a Python list can contain objects of many "
"different types."
msgstr "リストの時間計算量は C や Pascal の配列と同じです。大きな違いは、Python のリストは多くの異なる型のオブジェクトを含めることです。"

#: ../../faq/programming.rst:1267
msgid ""
"The ``array`` module also provides methods for creating arrays of fixed "
"types with compact representations, but they are slower to index than lists."
"  Also note that the Numeric extensions and others define array-like "
"structures with various characteristics as well."
msgstr "``array`` モジュールにも固定された型を簡潔に表現する配列を作るためのメソッドがありますが、リストよりもインデクスが遅いです。また、Numeric 拡張その他でも、様々な特徴をもつ配列的な構造体が定義されています。"

#: ../../faq/programming.rst:1272
msgid ""
"To get Lisp-style linked lists, you can emulate cons cells using tuples::"
msgstr "Lisp 方式の連結リストを得るのに、タプルを使ってコンスセルをエミュレートできます::"

#: ../../faq/programming.rst:1276
msgid ""
"If mutability is desired, you could use lists instead of tuples.  Here the "
"analogue of lisp car is ``lisp_list[0]`` and the analogue of cdr is "
"``lisp_list[1]``.  Only do this if you're sure you really need to, because "
"it's usually a lot slower than using Python lists."
msgstr "ミュータブルな必要があるなら、タプルではなくリストを使いましょう。lisp の car にあたるものが ``lisp_list[0]`` で、cdr にあたるものが ``lisp_list[1]`` です。本当に必要だと確信できるとき以外はこれはしないでください。たいてい、これは Python のリストを使うよりも非常に遅いですから。"

#: ../../faq/programming.rst:1285
msgid "How do I create a multidimensional list?"
msgstr "多次元のリストを作るにはどうしますか？"

#: ../../faq/programming.rst:1287
msgid "You probably tried to make a multidimensional array like this::"
msgstr "このようにして多次元の配列を作ろうとしてしまったことがあるでしょう::"

#: ../../faq/programming.rst:1291
msgid "This looks correct if you print it::"
msgstr "これを表示したときには問題なさそうに見えます::"

#: ../../faq/programming.rst:1296
msgid "But when you assign a value, it shows up in multiple places:"
msgstr "しかし値を代入すると、その値が複数の場所に現れてしまいます:"

#: ../../faq/programming.rst:1302
msgid ""
"The reason is that replicating a list with ``*`` doesn't create copies, it "
"only creates references to the existing objects.  The ``*3`` creates a list "
"containing 3 references to the same list of length two.  Changes to one row "
"will show in all rows, which is almost certainly not what you want."
msgstr "これは、``*`` を使ったリストの複製がコピーを作らず、存在するオブジェクトへの参照を作るだけだからです。この ``*3`` は長さ 2 の同じリストへの参照を含むリストを作ります。一つの列に対する変更はすべての列に現れますが、これが望んだ結果であることはまずないでしょう。"

#: ../../faq/programming.rst:1307
msgid ""
"The suggested approach is to create a list of the desired length first and "
"then fill in each element with a newly created list::"
msgstr "おすすめの方法は、最初に望んだ長さのリストを作り、それから新しく作ったリストでそれぞれの要素を埋めていくことです::"

#: ../../faq/programming.rst:1314
msgid ""
"This generates a list containing 3 different lists of length two.  You can "
"also use a list comprehension::"
msgstr "これは長さ 2 の異なるリスト 3 つを含むリストを生成します。リスト内包表記も使えます::"

#: ../../faq/programming.rst:1320
msgid ""
"Or, you can use an extension that provides a matrix datatype; `NumPy "
"<http://www.numpy.org/>`_ is the best known."
msgstr "あるいは、行列データ型を提供している拡張を使用することもできます; `NumPy <http://www.numpy.org/>`_ が最もよく知られています。"

#: ../../faq/programming.rst:1325
msgid "How do I apply a method to a sequence of objects?"
msgstr "オブジェクトのシーケンスにメソッドを適用するにはどうしますか？"

#: ../../faq/programming.rst:1327
msgid "Use a list comprehension::"
msgstr "リスト内包表記を使ってください::"

#: ../../faq/programming.rst:1331
msgid "More generically, you can try the following function::"
msgstr "もっと一般化したければ、以下の関数を試してみてください::"

#: ../../faq/programming.rst:1341
msgid ""
"Why does a_tuple[i] += ['item'] raise an exception when the addition works?"
msgstr "なぜ加算はされるのに a_tuple[i] += ['item'] は例外を送出するのですか?"

#: ../../faq/programming.rst:1343
msgid ""
"This is because of a combination of the fact that augmented assignment "
"operators are *assignment* operators, and the difference between mutable and"
" immutable objects in Python."
msgstr "これは、拡張代入演算子は *代入* 演算子だ、という事実と、Python での可変オブジェクトと不変オブジェクトの違いが組み合わさって起きるのです。"

#: ../../faq/programming.rst:1347
msgid ""
"This discussion applies in general when augmented assignment operators are "
"applied to elements of a tuple that point to mutable objects, but we'll use "
"a ``list`` and ``+=`` as our exemplar."
msgstr "この議論は一般的に、可変オブジェクトを指すタプルの要素に、拡張代入演算子が適用されたときにも適用できますが、例として ``list`` と ``+=`` を使います。"

#: ../../faq/programming.rst:1351
msgid "If you wrote::"
msgstr "次のように書いたとします::"

#: ../../faq/programming.rst:1359
msgid ""
"The reason for the exception should be immediately clear: ``1`` is added to "
"the object ``a_tuple[0]`` points to (``1``), producing the result object, "
"``2``, but when we attempt to assign the result of the computation, ``2``, "
"to element ``0`` of the tuple, we get an error because we can't change what "
"an element of a tuple points to."
msgstr "例外が送出された理由は明らかです: ``1`` が (``1``) を指すオブジェクト ``a_tuple[0]`` に加えられ、結果のオブジェクト ``2`` が生成されますが、計算結果 ``2`` をタプルの第 ``0`` 要素に代入しようとしたときに、エラーが発生します。なぜならば、タプルの要素が何を指すかは変えられないからです。"

#: ../../faq/programming.rst:1365
msgid ""
"Under the covers, what this augmented assignment statement is doing is "
"approximately this::"
msgstr "このような裏事情の元、拡張代入文はだいたい次のようなことをしています::"

#: ../../faq/programming.rst:1374
msgid ""
"It is the assignment part of the operation that produces the error, since a "
"tuple is immutable."
msgstr "タプルは不変なので、例外を生み出しているのは操作の代入部分なのです。"

#: ../../faq/programming.rst:1377
msgid "When you write something like::"
msgstr "次のように書いたとします::"

#: ../../faq/programming.rst:1385
msgid ""
"The exception is a bit more surprising, and even more surprising is the fact"
" that even though there was an error, the append worked::"
msgstr "この例外にはちょっと驚きますが、もっと驚くべきことは、エラーがあったとしても追記はきちんと動いている、という事実です::"

#: ../../faq/programming.rst:1391
msgid ""
"To see why this happens, you need to know that (a) if an object implements "
"an ``__iadd__`` magic method, it gets called when the ``+=`` augmented "
"assignment is executed, and its return value is what gets used in the "
"assignment statement; and (b) for lists, ``__iadd__`` is equivalent to "
"calling ``extend`` on the list and returning the list.  That's why we say "
"that for lists, ``+=`` is a \"shorthand\" for ``list.extend``::"
msgstr "なぜこれが起きるかを調べるためには、次の 2 点を知っている必要があります。(a) オブジェクトに ``__iadd__`` 特殊メソッドが実装されている場合、拡張代入 ``+=`` が実行されるときにそれが呼び出され、その返り値が代入文で使われます; (b) リストでは、``__iadd__`` は ``extend`` の呼び出しと等価で、リストを返します。こんな理由で、リストでは ``+=`` は ``list.extend`` の \"略記\" だと言ったのでした::"

#: ../../faq/programming.rst:1403
msgid "This is equivalent to::"
msgstr "これは次のと等価です::"

#: ../../faq/programming.rst:1408
msgid ""
"The object pointed to by a_list has been mutated, and the pointer to the "
"mutated object is assigned back to ``a_list``.  The end result of the "
"assignment is a no-op, since it is a pointer to the same object that "
"``a_list`` was previously pointing to, but the assignment still happens."
msgstr "a_list が指していたオブジェクトは更新され、更新されたオブジェクトへのポインタは再度 ``a_list`` に代入されます。代入しているのは、``a_list`` が更新前まで指していた同じオブジェクトへのポインタなので、代入は最終的には何もしていないのですが、代入処理自体は起きています。"

#: ../../faq/programming.rst:1413
msgid "Thus, in our tuple example what is happening is equivalent to::"
msgstr "従って、今のタプルの例では、次のと同じことが起きています::"

#: ../../faq/programming.rst:1421
msgid ""
"The ``__iadd__`` succeeds, and thus the list is extended, but even though "
"``result`` points to the same object that ``a_tuple[0]`` already points to, "
"that final assignment still results in an error, because tuples are "
"immutable."
msgstr "``__iadd__`` は成功し、リストは拡張 (extend) されますが、``result`` が ``a_tuple[0]`` が既に指しているオブジェクトと同じオブジェクトを指していたとしても、タプルは不変なので、その最後の代入はやはりエラーとなります。"

#: ../../faq/programming.rst:1427
msgid "Dictionaries"
msgstr "辞書"

#: ../../faq/programming.rst:1430
msgid "How can I get a dictionary to display its keys in a consistent order?"
msgstr "一貫した順序でキーを表示する辞書はありますか?"

#: ../../faq/programming.rst:1432
msgid ""
"You can't.  Dictionaries store their keys in an unpredictable order, so the "
"display order of a dictionary's elements will be similarly unpredictable."
msgstr "できません。辞書はキーを予測できない順序で保存しているので、辞書の要素が表示される順序もまた予測できないのです。"

#: ../../faq/programming.rst:1435
msgid ""
"This can be frustrating if you want to save a printable version to a file, "
"make some changes and then compare it with some other printed dictionary.  "
"In this case, use the ``pprint`` module to pretty-print the dictionary; the "
"items will be presented in order sorted by the key."
msgstr "ファイルに印字可能なバージョンを保存し、変更を加えてから他の印字された辞書と比較したい時に苛立たしいかもしれません。この場合は、 ``pprint`` モジュールで辞書を整形して表示してください。要素がキーでソートされて表されます。"

#: ../../faq/programming.rst:1440
msgid ""
"A more complicated solution is to subclass ``dict`` to create a "
"``SortedDict`` class that prints itself in a predictable order.  Here's one "
"simpleminded implementation of such a class::"
msgstr "もっと複雑な解決策は、 ``dict`` のサブクラスとして ``SortedDict`` クラスを作り、それに予測可能な順序で自身を表示させることです。そのようなクラスの単純な実装の一つは::"

#: ../../faq/programming.rst:1452
msgid ""
"This will work for many common situations you might encounter, though it's "
"far from a perfect solution. The largest flaw is that if some values in the "
"dictionary are also dictionaries, their values won't be presented in any "
"particular order."
msgstr "これは完璧な解法とは程遠いですが、多くの状況でうまく働くでしょう。最大の欠点は、辞書内のどれかの値がまた辞書であった場合に、それらの値はどんな特定の順序でも表示されないことです。"

#: ../../faq/programming.rst:1459
msgid ""
"I want to do a complicated sort: can you do a Schwartzian Transform in "
"Python?"
msgstr "複雑なソートがしたいのですが、Python でシュワルツ変換はできますか？"

#: ../../faq/programming.rst:1461
msgid ""
"The technique, attributed to Randal Schwartz of the Perl community, sorts "
"the elements of a list by a metric which maps each element to its \"sort "
"value\". In Python, use the ``key`` argument for the :func:`sort()` "
"function::"
msgstr "Perl コミュニティの Randal Schwartz の作とされるこのテクニックは、それぞれの要素に「ソート値」を対応付けるある尺度によって、リストの要素をソートします。\nPython では、 :func:`sort()` 関数で ``key`` 引数を使ってください::"

#: ../../faq/programming.rst:1470
msgid "How can I sort one list by values from another list?"
msgstr "リストを別のリストの値によってソートするにはどうしますか？"

#: ../../faq/programming.rst:1472
msgid ""
"Merge them into a single list of tuples, sort the resulting list, and then "
"pick out the element you want. ::"
msgstr "二つのリストを混ぜあわせてタプルのリストにしてから、必要な要素を選んでください::"

#: ../../faq/programming.rst:1485
msgid "An alternative for the last step is::"
msgstr "最後の段階の別のやり方は::"

#: ../../faq/programming.rst:1490
msgid ""
"If you find this more legible, you might prefer to use this instead of the "
"final list comprehension.  However, it is almost twice as slow for long "
"lists.  Why? First, the ``append()`` operation has to reallocate memory, and"
" while it uses some tricks to avoid doing that each time, it still has to do"
" it occasionally, and that costs quite a bit.  Second, the expression "
"\"result.append\" requires an extra attribute lookup, and third, there's a "
"speed reduction from having to make all those function calls."
msgstr "これのほうが読みやすいと、最後のリスト内包表記ではなくこれを使いたくなるかもしれません。しかし、これは長いリストではほぼ二倍の時間がかかります。なぜでしょうか。まず、``append()`` 演算はメモリを割り当て直す必要があり、それを避けるために毎回ちょっと工夫していますが、それでも避けられないことがあるので、少し時間がかかるのです。二つ目に、\"result.append\" には属性探索が余計に必要で、三つ目に、これらすべての関数を呼ぶ必要があることで速度が落ちてしまいます。"

#: ../../faq/programming.rst:1500
msgid "Objects"
msgstr "オブジェクト"

#: ../../faq/programming.rst:1503
msgid "What is a class?"
msgstr "クラスとは何ですか？"

#: ../../faq/programming.rst:1505
msgid ""
"A class is the particular object type created by executing a class "
"statement. Class objects are used as templates to create instance objects, "
"which embody both the data (attributes) and code (methods) specific to a "
"datatype."
msgstr "クラスは、class 文の実行で生成される特殊なオブジェクトです。クラスオブジェクトはインスタンスオブジェクトを生成するためのテンプレートとして使われ、あるデータ型に特有のデータ (attribute/属性) とコード (メソッド) の両方を内蔵しています。"

#: ../../faq/programming.rst:1509
msgid ""
"A class can be based on one or more other classes, called its base "
"class(es). It then inherits the attributes and methods of its base classes. "
"This allows an object model to be successively refined by inheritance.  You "
"might have a generic ``Mailbox`` class that provides basic accessor methods "
"for a mailbox, and subclasses such as ``MboxMailbox``, ``MaildirMailbox``, "
"``OutlookMailbox`` that handle various specific mailbox formats."
msgstr "新しいクラスを一つ以上の他のクラス (新しいクラスの基底クラスと呼ばれます) に基づいて作ることもできます。この新しいクラスは、基底クラスから属性とメソッドを継承します。これにより、オブジェクトモデルを継承で連続的に洗練できます。メールボックスへの基本的なアクセサを提供する一般的な ``Mailbox`` クラスを作って、それからいろいろな特定のメールボックスの形式を扱う ``MboxMailbox``、``MaildirMailbox``、``OutlookMailbox`` のようなサブクラスを作れるのです。"

#: ../../faq/programming.rst:1518
msgid "What is a method?"
msgstr "メソッドとは何ですか？"

#: ../../faq/programming.rst:1520
msgid ""
"A method is a function on some object ``x`` that you normally call as "
"``x.name(arguments...)``.  Methods are defined as functions inside the class"
" definition::"
msgstr "メソッドは、オブジェクト ``x`` が持つ関数で、通常 ``x.name(arguments...)`` として呼び出されるものです。メソッドはクラス定義の中で関数として定義されます::"

#: ../../faq/programming.rst:1530
msgid "What is self?"
msgstr "self とは何ですか？"

#: ../../faq/programming.rst:1532
msgid ""
"Self is merely a conventional name for the first argument of a method.  A "
"method defined as ``meth(self, a, b, c)`` should be called as ``x.meth(a, b,"
" c)`` for some instance ``x`` of the class in which the definition occurs; "
"the called method will think it is called as ``meth(x, a, b, c)``."
msgstr "self はメソッドの第一引数に慣習的につけられる名前にすぎません。``meth(self, a, b, c)`` として定義されたメソッドは、その定義がなされたクラスのインスタンス ``x`` に対して ``x.meth(a, b, c)`` として呼び出されます。呼び出されたメソッドは、``meth(x, a, b, c)`` が呼ばれたものと考えます。"

#: ../../faq/programming.rst:1537
msgid "See also :ref:`why-self`."
msgstr ":ref:`why-self` も参照してください。"

#: ../../faq/programming.rst:1541
msgid ""
"How do I check if an object is an instance of a given class or of a subclass"
" of it?"
msgstr "あるオブジェクトが、与えられたクラスやそのサブクラスのインスタンスであるかを調べるにはどうしますか？"

#: ../../faq/programming.rst:1543
msgid ""
"Use the built-in function ``isinstance(obj, cls)``.  You can check if an "
"object is an instance of any of a number of classes by providing a tuple "
"instead of a single class, e.g. ``isinstance(obj, (class1, class2, ...))``, "
"and can also check whether an object is one of Python's built-in types, e.g."
" ``isinstance(obj, str)`` or ``isinstance(obj, (int, long, float, "
"complex))``."
msgstr "ビルトイン関数 ``isinstance(obj, cls)`` を使ってください。クラスのタプルを与えて ``isinstance(obj, (class1, class2, ...))`` のようにすれば、あるオブジェクトが任意の数のクラスのオブジェクトであるかを調べられますし、 ``isinstance(obj, str)`` や ``isinstance(obj, (int, long, float, complex))`` のようにすれば、Python のビルトイン型のオブジェクトであるかも調べられます。"

#: ../../faq/programming.rst:1549
msgid ""
"Note that most programs do not use :func:`isinstance` on user-defined "
"classes very often.  If you are developing the classes yourself, a more "
"proper object-oriented style is to define methods on the classes that "
"encapsulate a particular behaviour, instead of checking the object's class "
"and doing a different thing based on what class it is.  For example, if you "
"have a function that does something::"
msgstr "なお、大部分のプログラムでは、 :func:`isinstance` をユーザー定義のクラスに何度も使うべきではありません。クラスを自分で開発するときに、適切なオブジェクト指向スタイルは、特定の振る舞いをカプセル化するクラスのメソッドを定義するものであって、オブジェクトのクラスを調べてそのクラスに応じて違うことをするものではありません。例えば、何かをする関数があったとして::"

#: ../../faq/programming.rst:1563
msgid ""
"A better approach is to define a ``search()`` method on all the classes and "
"just call it::"
msgstr "よりよいアプローチは、``search()`` メソッドをすべてのクラスに定義して、それをただ呼び出すことです::"

#: ../../faq/programming.rst:1578
msgid "What is delegation?"
msgstr "委譲とは何ですか？"

#: ../../faq/programming.rst:1580
msgid ""
"Delegation is an object oriented technique (also called a design pattern). "
"Let's say you have an object ``x`` and want to change the behaviour of just "
"one of its methods.  You can create a new class that provides a new "
"implementation of the method you're interested in changing and delegates all"
" other methods to the corresponding method of ``x``."
msgstr "委譲 (delegation) とは、オブジェクト指向のテクニック (デザインパターンとも呼ばれる) の一つです。オブジェクト ``x`` があって、そのメソッドのうちただ一つの振る舞いを変えたいとしましょう。新しいクラスを作成し、変えたいメソッドだけを新しく実装し、他のすべてのメソッドを ``x`` の対応するメソッドに委譲する新しいクラスを作れます。"

#: ../../faq/programming.rst:1586
msgid ""
"Python programmers can easily implement delegation.  For example, the "
"following class implements a class that behaves like a file but converts all"
" written data to uppercase::"
msgstr "Python プログラマは簡単に委譲を実装できます。例えば、以下のクラスは、ファイルのように振る舞いながらすべての文字を大文字に変換するクラスを実装します::"

#: ../../faq/programming.rst:1601
msgid ""
"Here the ``UpperOut`` class redefines the ``write()`` method to convert the "
"argument string to uppercase before calling the underlying "
"``self.__outfile.write()`` method.  All other methods are delegated to the "
"underlying ``self.__outfile`` object.  The delegation is accomplished via "
"the ``__getattr__`` method; consult :ref:`the language reference <attribute-"
"access>` for more information about controlling attribute access."
msgstr "ここで ``UpperOut`` クラスは ``write()`` メソッドを定義しなおして、引数の文字列を大文字に変換してから基礎となる ``self.__outfile.write()`` メソッドを呼び出すようにします。その他すべてのメソッドは基礎となる ``self.__outfile`` オブジェクトに移譲されます。この委譲は ``__getattr__`` メソッドを通してなされます。属性の制御の詳細は :ref:`言語リファレンス <attribute-access>` を参照してください。"

#: ../../faq/programming.rst:1608
msgid ""
"Note that for more general cases delegation can get trickier. When "
"attributes must be set as well as retrieved, the class must define a "
":meth:`__setattr__` method too, and it must do so carefully.  The basic "
"implementation of :meth:`__setattr__` is roughly equivalent to the "
"following::"
msgstr "なお、一般的に委譲はトリッキーになりがちです。属性が設定される時には読み出される時と同様に、そのクラスに :meth:`__setattr__` メソッドを定義する必要があり、それには細心の注意が必要です。 :meth:`__setattr__` の基本的な実装はおおよそ以下のようになります::"

#: ../../faq/programming.rst:1619
msgid ""
"Most :meth:`__setattr__` implementations must modify ``self.__dict__`` to "
"store local state for self without causing an infinite recursion."
msgstr "たいてい、 :meth:`__setattr__` 実装は ``self.__dict__`` を変更して、無限再帰を起こすことなくローカルな状態を保存するようにしなければなりません。"

#: ../../faq/programming.rst:1624
msgid ""
"How do I call a method defined in a base class from a derived class that "
"overrides it?"
msgstr "基底クラスで定義されたメソッドを、そのクラスをオーバーライドした派生クラスから呼び出すにはどうしますか？"

#: ../../faq/programming.rst:1626
msgid ""
"If you're using new-style classes, use the built-in :func:`super` function::"
msgstr "新スタイルのクラスを使っている場合は、組み込みの :func:`super` 関数を使ってください::"

#: ../../faq/programming.rst:1632
msgid ""
"If you're using classic classes: For a class definition such as ``class "
"Derived(Base): ...`` you can call method ``meth()`` defined in ``Base`` (or "
"one of ``Base``'s base classes) as ``Base.meth(self, arguments...)``.  Here,"
" ``Base.meth`` is an unbound method, so you need to provide the ``self`` "
"argument."
msgstr "旧スタイルクラスを使っているなら: ``class Derived(Base): ...`` のようなクラス定義で、 ``Base.meth(self, arguments...)`` とすれば、 ``Base`` (または ``Base`` の基底クラス) で定義された ``meth()`` メソッドを呼び出せます。ここで、 ``Base.meth`` は束縛されていないメソッドなので、 ``self`` 引数を渡す必要があります。"

#: ../../faq/programming.rst:1640
msgid "How can I organize my code to make it easier to change the base class?"
msgstr "基底クラスの名前を変えやすいコードを書くにはどうしますか？"

#: ../../faq/programming.rst:1642
msgid ""
"You could define an alias for the base class, assign the real base class to "
"it before your class definition, and use the alias throughout your class.  "
"Then all you have to change is the value assigned to the alias.  "
"Incidentally, this trick is also handy if you want to decide dynamically "
"(e.g. depending on availability of resources) which base class to use.  "
"Example::"
msgstr "基底クラスのエイリアス (alias) を定義し、先にそれに本当の基底クラスを代入しておいてから、クラス定義の中でそのエイリアスを使うといいかもしれません。そうすればエイリアスに代入する値を変えるだけで済みます。ちなみに、この手法は使用する基底クラスを動的に選びたいとき、例えば使えるリソースによって選びたいときなどにも便利です。例::"

#: ../../faq/programming.rst:1657
msgid "How do I create static class data and static class methods?"
msgstr "静的なクラスデータや静的なクラスメソッドを作るにはどうしますか？"

#: ../../faq/programming.rst:1659
msgid ""
"Both static data and static methods (in the sense of C++ or Java) are "
"supported in Python."
msgstr "(C++ や Java の意味で) 静的なデータも静的なメソッドも Python でサポートされています。"

#: ../../faq/programming.rst:1662
msgid ""
"For static data, simply define a class attribute.  To assign a new value to "
"the attribute, you have to explicitly use the class name in the assignment::"
msgstr "静的なデータを作るには、単純にクラス属性を定義してください。その属性に新しい値を代入するには、代入するクラス名を明示する必要があります::"

#: ../../faq/programming.rst:1674
msgid ""
"``c.count`` also refers to ``C.count`` for any ``c`` such that "
"``isinstance(c, C)`` holds, unless overridden by ``c`` itself or by some "
"class on the base-class search path from ``c.__class__`` back to ``C``."
msgstr "``c`` そのものや ``c.__class__`` から ``C`` にいたるパス探索経路上のクラスによってオーバーライドされない限り、``c.count`` も ``isinstance(c, C)`` であるすべての ``c`` に対する ``C.count`` を参照します。"

#: ../../faq/programming.rst:1678
msgid ""
"Caution: within a method of C, an assignment like ``self.count = 42`` "
"creates a new and unrelated instance named \"count\" in ``self``'s own dict."
"  Rebinding of a class-static data name must always specify the class "
"whether inside a method or not::"
msgstr "注意: C のメソッド内では、``self.count = 42`` のような代入は ``self`` 自身の辞書に \"count\" という名前の新しくて関係ないインスタンスを作ります。クラスの静的なデータの再束縛には、メソッド内であるか否かにかかわらず、いつもクラスを指定しなければなりません::"

#: ../../faq/programming.rst:1685
msgid "Static methods are possible since Python 2.2::"
msgstr "Python 2.2 からは、静的メソッドが使えます::"

#: ../../faq/programming.rst:1693
msgid "With Python 2.4's decorators, this can also be written as ::"
msgstr "Python 2.4 のデコレータを使って、以下のようにも書けます::"

#: ../../faq/programming.rst:1701
msgid ""
"However, a far more straightforward way to get the effect of a static method"
" is via a simple module-level function::"
msgstr "しかし、静的メソッドの効果を得るもっと簡単な方法は、単にモジュールレベル関数を使うことです::"

#: ../../faq/programming.rst:1707
msgid ""
"If your code is structured so as to define one class (or tightly related "
"class hierarchy) per module, this supplies the desired encapsulation."
msgstr "モジュールあたりに一つのクラスを定義するように (あるいはクラス組織を厳密に関連させるように) コードが構成されているなら、これで必要なカプセル化ができます。"

#: ../../faq/programming.rst:1712
msgid "How can I overload constructors (or methods) in Python?"
msgstr "Python でコンストラクタ(やメソッド)をオーバーロードするにはどうしたらいいですか？"

#: ../../faq/programming.rst:1714
msgid ""
"This answer actually applies to all methods, but the question usually comes "
"up first in the context of constructors."
msgstr "この質問の答えはすべてのメソッドについて言えることですが、この質問はだいたい以下の構造の文脈から出てきます。"

#: ../../faq/programming.rst:1717
msgid "In C++ you'd write"
msgstr "C++ では、このように書けます"

#: ../../faq/programming.rst:1726
msgid ""
"In Python you have to write a single constructor that catches all cases "
"using default arguments.  For example::"
msgstr "Python では、一つのコンストラクタでデフォルトの引数を使ってすべての場合に対応するように書かなければなりません。例えば::"

#: ../../faq/programming.rst:1736
msgid "This is not entirely equivalent, but close enough in practice."
msgstr "これで完全に等価とは言えませんが、実用上は十分に近いです。"

#: ../../faq/programming.rst:1738
msgid "You could also try a variable-length argument list, e.g. ::"
msgstr "長さが変えられる引数のリストを試すには、例えば ::"

#: ../../faq/programming.rst:1743
msgid "The same approach works for all method definitions."
msgstr "これと同じやり方がすべてのメソッド定義で使えます。"

#: ../../faq/programming.rst:1747
msgid "I try to use __spam and I get an error about _SomeClassName__spam."
msgstr "__spam を使おうとしたら _SomeClassName__spam からエラーがでました。"

#: ../../faq/programming.rst:1749
msgid ""
"Variable names with double leading underscores are \"mangled\" to provide a "
"simple but effective way to define class private variables.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with any leading underscores "
"stripped."
msgstr "先頭にアンダースコアが二つ付いた変数名は、クラスのプライベートな変数を、\"マングル化\"という単純かつ効率のいい方法で定義します。``__spam`` のような形式 (先頭に二つ以上、末尾にもしあっても一つのアンダースコアがある) のすべての識別子は、``classname`` が先頭のアンダースコアをすべて削除した現在のクラス名とすれば、``_classname__spam`` のように文字上で置換えられます。"

#: ../../faq/programming.rst:1755
msgid ""
"This doesn't guarantee privacy: an outside user can still deliberately "
"access the \"_classname__spam\" attribute, and private values are visible in"
" the object's ``__dict__``.  Many Python programmers never bother to use "
"private variable names at all."
msgstr "これはプライベートであることを保証するものではありません。これでも外部のユーザが \"_classname__spam\" 属性に直接アクセスできますし、プライベートな変数はオブジェクトの ``__dict__`` から見えます。多くの Python プログラマはわざわざプライベートな変数名を使おうとなど考えません。"

#: ../../faq/programming.rst:1762
msgid ""
"My class defines __del__ but it is not called when I delete the object."
msgstr "クラスに __del__ メソッドを定義しているのですが、オブジェクトを削除したときに呼ばれません。"

#: ../../faq/programming.rst:1764
msgid "There are several possible reasons for this."
msgstr "いくつかの可能性があります。"

#: ../../faq/programming.rst:1766
msgid ""
"The del statement does not necessarily call :meth:`__del__` -- it simply "
"decrements the object's reference count, and if this reaches zero "
":meth:`__del__` is called."
msgstr "del 文は必ずしも :meth:`__del__` を呼び出すとは限りません -- これは単純にオブジェクトの参照カウントを減らすもので、カウントがゼロになったときに :meth:`__del__` が呼び出されます。"

#: ../../faq/programming.rst:1770
msgid ""
"If your data structures contain circular links (e.g. a tree where each child"
" has a parent reference and each parent has a list of children) the "
"reference counts will never go back to zero.  Once in a while Python runs an"
" algorithm to detect such cycles, but the garbage collector might run some "
"time after the last reference to your data structure vanishes, so your "
":meth:`__del__` method may be called at an inconvenient and random time. "
"This is inconvenient if you're trying to reproduce a problem. Worse, the "
"order in which object's :meth:`__del__` methods are executed is arbitrary.  "
"You can run :func:`gc.collect` to force a collection, but there *are* "
"pathological cases where objects will never be collected."
msgstr "データ構造が循環リンク (子のそれぞれが親の参照を持ち、親のそれぞれが子のリストを持つツリーなど) を含む場合、その参照カウントは決して 0 にはなりません。時々、Python はこのようなサイクルを検出するアルゴリズムを実行しますが、データ構造への参照がなくなってからこのガベージコレクタが実行されるまでいくらか時間が掛かるかもしれないので、 :meth:`__del__` メソッドは不都合な予期できないタイミングで呼び出されるかもしれません。これは問題を再現しようとするときに不便です。さらに悪いことに、オブジェクトの :meth:`__del__` メソッドが実行される順序は任意です。 :func:`gc.collect` を起動して収集を強制することができますが、オブジェクトが決して回収されないような本当に病的な場合も *あります* 。"

#: ../../faq/programming.rst:1781
msgid ""
"Despite the cycle collector, it's still a good idea to define an explicit "
"``close()`` method on objects to be called whenever you're done with them.  "
"The ``close()`` method can then remove attributes that refer to subobjecs.  "
"Don't call :meth:`__del__` directly -- :meth:`__del__` should call "
"``close()`` and ``close()`` should make sure that it can be called more than"
" once for the same object."
msgstr "周期的なコレクタにかかわらず、オブジェクトに ``close()`` メソッドを明示的に定義し、使い終わったらいつでも呼び出せるようにするのはいいことです。そうすれば ``close()`` メソッドはサブオブジェクトへの参照をする属性を取り除いてくれます。 :meth:`__del__` を直接呼び出さないでください -- :meth:`__del__` は ``close()`` を呼び出すでしょうし、 ``close()`` なら同じオブジェクトに対して複数回呼ばれてもいいことが保証されているでしょう。"

#: ../../faq/programming.rst:1788
msgid ""
"Another way to avoid cyclical references is to use the :mod:`weakref` "
"module, which allows you to point to objects without incrementing their "
"reference count. Tree data structures, for instance, should use weak "
"references for their parent and sibling references (if they need them!)."
msgstr "循環参照を避ける他の方法は、 :mod:`weakref` モジュールを使って、参照カウントを増やすことなくオブジェクトを示すことです。例えばツリー構造は、親と (必要なら！) 兄弟に弱参照を使うべきです。"

#: ../../faq/programming.rst:1793
msgid ""
"If the object has ever been a local variable in a function that caught an "
"expression in an except clause, chances are that a reference to the object "
"still exists in that function's stack frame as contained in the stack trace."
" Normally, calling :func:`sys.exc_clear` will take care of this by clearing "
"the last recorded exception."
msgstr "except 節で例外を捕まえた関数内でオブジェクトがローカル変数であったたなら、そのオブジェクトへの参照が関数のスタックフレーム内でスタックトレース内に含まれることで存在する可能性があります。通常、 :func:`sys.exc_clear` を呼び出せば、最後に記録された例外を消去することで対処してくれます。"

#: ../../faq/programming.rst:1799
msgid ""
"Finally, if your :meth:`__del__` method raises an exception, a warning "
"message is printed to :data:`sys.stderr`."
msgstr "最後に、 :meth:`__del__` メソッドが例外を発生させた場合、警告のメッセージが :data:`sys.stderr` に書きこまれます。"

#: ../../faq/programming.rst:1804
msgid "How do I get a list of all instances of a given class?"
msgstr "与えられたクラスのすべてのインスタンスのリストを得るにはどうしますか？"

#: ../../faq/programming.rst:1806
msgid ""
"Python does not keep track of all instances of a class (or of a built-in "
"type). You can program the class's constructor to keep track of all "
"instances by keeping a list of weak references to each instance."
msgstr "Python はクラス (やビルトイン型) のすべてのインスタンスをたどりません。クラスのコンストラクタにそれぞれのインスタンスへの弱参照のリストを作らせることですべてのインスタンスをたどらせられます。"

#: ../../faq/programming.rst:1812
msgid "Why does the result of ``id()`` appear to be not unique?"
msgstr "なぜ ``id()`` の結果は一意でないように見えるのですか?"

#: ../../faq/programming.rst:1814
msgid ""
"The :func:`id` builtin returns an integer that is guaranteed to be unique "
"during the lifetime of the object.  Since in CPython, this is the object's "
"memory address, it happens frequently that after an object is deleted from "
"memory, the next freshly created object is allocated at the same position in"
" memory.  This is illustrated by this example:"
msgstr "組み込みの :func:`id` は、オブジェクトが生きている間は一意であることが保証されている整数値を返します。 CPython では、それはオブジェクトのメモリアドレスなので、オブジェクトがメモリから削除された後に、次に新しく生成されたオブジェクトはメモリの同じ場所にメモリ領域を確保されていることが、しばしば起きます。この現象を次の例で示しましょう:"

#: ../../faq/programming.rst:1825
msgid ""
"The two ids belong to different integer objects that are created before, and"
" deleted immediately after execution of the ``id()`` call.  To be sure that "
"objects whose id you want to examine are still alive, create another "
"reference to the object:"
msgstr "2 つの同じ値を持つ id は ``id()`` の実行の前に作られてすぐさま削除された異なる整数オブジェクトによるものです。id を調べたいオブジェクトがまだ生きてることを保証したいなら、オブジェクトへの別の参照を作ってください:"

#: ../../faq/programming.rst:1838
msgid "Modules"
msgstr "モジュール"

#: ../../faq/programming.rst:1841
msgid "How do I create a .pyc file?"
msgstr ".pyc ファイルを作るにはどうしますか？"

#: ../../faq/programming.rst:1843
msgid ""
"When a module is imported for the first time (or when the source is more "
"recent than the current compiled file) a ``.pyc`` file containing the "
"compiled code should be created in the same directory as the ``.py`` file."
msgstr "モジュールが最初にインポートされるとき (またはソースが現在コンパイルされているファイルよりも新しいとき)、コンパイルされたコードを含む ``.pyc`` ファイルが ``.py`` ファイルと同じディレクトリに作られるでしょう。"

#: ../../faq/programming.rst:1847
msgid ""
"One reason that a ``.pyc`` file may not be created is permissions problems "
"with the directory. This can happen, for example, if you develop as one user"
" but run as another, such as if you are testing with a web server.  Creation"
" of a .pyc file is automatic if you're importing a module and Python has the"
" ability (permissions, free space, etc...) to write the compiled module back"
" to the directory."
msgstr "``.pyc`` ファイルが作られないとしたら、ディレクトリの権限の問題があるかもしれません。たとえばこれは、web サーバなどでテストするときのように、開発のときと違うユーザとして起動するときなどに起こりえます。モジュールをインポートしたときに Python がコンパイルされたモジュールをディレクトリに書き込むための条件 (権限、容量の空き、etc...) が揃っていれば、.pyc ファイルの生成は自動的に行われます。"

#: ../../faq/programming.rst:1854
msgid ""
"Running Python on a top level script is not considered an import and no "
"``.pyc`` will be created.  For example, if you have a top-level module "
"``foo.py`` that imports another module ``xyz.py``, when you run ``foo``, "
"``xyz.pyc`` will be created since ``xyz`` is imported, but no ``foo.pyc`` "
"file will be created since ``foo.py`` isn't being imported."
msgstr "トップレベルのスクリプトを実行することはインポートとは見做されず、 ``.pyc`` は生成されません。例えば、トップレベルモジュール ``abc.py`` があって、他のモジュール ``xyz.py`` をインポートするようになっているとき、abc を起動すると、xyz のインポート時に ``xyz.pyc`` が生成されますが、 ``abc.py`` はインポートされないので ``abc.pyc`` ファイルは生成されません。"

#: ../../faq/programming.rst:1860
msgid ""
"If you need to create ``foo.pyc`` -- that is, to create a ``.pyc`` file for "
"a module that is not imported -- you can, using the :mod:`py_compile` and "
":mod:`compileall` modules."
msgstr "abc.pyc が必要なら -- つまり、インポートされないモジュールの ``.pyc`` ファイルを生成するためには -- :mod:`py_compile` や :mod:`compileall` モジュールが利用できます。"

#: ../../faq/programming.rst:1864
msgid ""
"The :mod:`py_compile` module can manually compile any module.  One way is to"
" use the ``compile()`` function in that module interactively::"
msgstr ":mod:`py_compile` モジュールは手動で任意のモジュールをコンパイルできます。やり方の一つは、このモジュールの ``compile()`` 関数をインタラクティブに実行することです::"

#: ../../faq/programming.rst:1870
msgid ""
"This will write the ``.pyc`` to the same location as ``foo.py`` (or you can "
"override that with the optional parameter ``cfile``)."
msgstr "このように実行すると、``foo.py`` と同じ場所に ``.pyc`` が書き出されます (出力ファイルの位置は、オプション引数 ``cfile`` で上書きすることもできます)。"

#: ../../faq/programming.rst:1873
msgid ""
"You can also automatically compile all files in a directory or directories "
"using the :mod:`compileall` module.  You can do it from the shell prompt by "
"running ``compileall.py`` and providing the path of a directory containing "
"Python files to compile::"
msgstr ":mod:`compileall` モジュールを使えば自動的に一つや複数のディレクトリのすべてのファイルをコンパイルできます。シェルプロンプトから ``compileall.py`` を起動して、コンパイルしたいファイルを含むディレクトリのパスを指定してください::"

#: ../../faq/programming.rst:1882
msgid "How do I find the current module name?"
msgstr "現在のモジュール名を知るにはどうしますか？"

#: ../../faq/programming.rst:1884
msgid ""
"A module can find out its own module name by looking at the predefined "
"global variable ``__name__``.  If this has the value ``'__main__'``, the "
"program is running as a script.  Many modules that are usually used by "
"importing them also provide a command-line interface or a self-test, and "
"only execute this code after checking ``__name__``::"
msgstr "モジュールは前もって定義されたグローバル変数 ``__name__`` を検索することで自身の名前を決定できます。この値が ``'__main__'`` であるとき、そのプログラムはスクリプトとして実行されています。インポートされることによって使われる大抵のモジュールはコマンドラインインタフェースや自己テストも提供していて、``__name__`` をチェックしてからそのコードだけを実行します::"

#: ../../faq/programming.rst:1899
msgid "How can I have modules that mutually import each other?"
msgstr "相互にインポートしあうモジュールを作るにはどうしたらいいですか？"

#: ../../faq/programming.rst:1901
msgid "Suppose you have the following modules:"
msgstr "以下のモジュールがあったとしましょう:"

#: ../../faq/programming.rst:1903
msgid "foo.py::"
msgstr "foo.py::"

#: ../../faq/programming.rst:1908
msgid "bar.py::"
msgstr "bar.py::"

#: ../../faq/programming.rst:1913
msgid "The problem is that the interpreter will perform the following steps:"
msgstr "問題はインタプリタが以下の段階を実行することです:"

#: ../../faq/programming.rst:1915
msgid "main imports foo"
msgstr "main が foo をインポートする"

#: ../../faq/programming.rst:1916
msgid "Empty globals for foo are created"
msgstr "foo の空のグローバルが生成される"

#: ../../faq/programming.rst:1917
msgid "foo is compiled and starts executing"
msgstr "foo がコンパイルされ実行を始める"

#: ../../faq/programming.rst:1918
msgid "foo imports bar"
msgstr "foo が bar をインポートする"

#: ../../faq/programming.rst:1919
msgid "Empty globals for bar are created"
msgstr "bar の空のグローバルが生成される"

#: ../../faq/programming.rst:1920
msgid "bar is compiled and starts executing"
msgstr "bar がコンパイルされ実行を始める"

#: ../../faq/programming.rst:1921
msgid ""
"bar imports foo (which is a no-op since there already is a module named foo)"
msgstr "bar が foo をインポートする(すでに foo という名前のモジュールがあるので no-op となる)"

#: ../../faq/programming.rst:1922
msgid "bar.foo_var = foo.foo_var"
msgstr "bar.foo_var = foo.foo_var"

#: ../../faq/programming.rst:1924
msgid ""
"The last step fails, because Python isn't done with interpreting ``foo`` yet"
" and the global symbol dictionary for ``foo`` is still empty."
msgstr "この最後の段階は失敗します。Python が ``foo`` を解釈し終わっていなくて、``foo`` のグローバルなシンボルの辞書はまだ空ですから。"

#: ../../faq/programming.rst:1927
msgid ""
"The same thing happens when you use ``import foo``, and then try to access "
"``foo.foo_var`` in global code."
msgstr "``import foo`` を使って、グローバルコードの ``foo.foo_var`` にアクセスしようとしたときにも、これと同じことが起こります。"

#: ../../faq/programming.rst:1930
msgid "There are (at least) three possible workarounds for this problem."
msgstr "この問題には (少なくとも) 三つの解決策があります。"

#: ../../faq/programming.rst:1932
msgid ""
"Guido van Rossum recommends avoiding all uses of ``from <module> import "
"...``, and placing all code inside functions.  Initializations of global "
"variables and class variables should use constants or built-in functions "
"only.  This means everything from an imported module is referenced as "
"``<module>.<name>``."
msgstr "Guido van Rossum は ``from <module> import ...`` を全く使わないで、すべてのコードを関数の中に入れることを勧めています。グローバル変数とクラス変数の初期化は定数とビルトイン関数のみで行われるべきです。これでインポートされたすべてのモジュールは ``<module>.<name>`` として参照されることになります。"

#: ../../faq/programming.rst:1937
msgid ""
"Jim Roskind suggests performing steps in the following order in each module:"
msgstr "Jim Roskind はそれぞれのモジュールに対して以下の順に進めることを提案しています:"

#: ../../faq/programming.rst:1939
msgid ""
"exports (globals, functions, and classes that don't need imported base "
"classes)"
msgstr "エクスポート (インポートされた基底クラスを必要としないグローバル、関数、クラス)"

#: ../../faq/programming.rst:1941
msgid "``import`` statements"
msgstr "``import`` 文"

#: ../../faq/programming.rst:1942
msgid ""
"active code (including globals that are initialized from imported values)."
msgstr "アクティブなコード (インポートされた値によって初期化されるグローバルを含む)。"

#: ../../faq/programming.rst:1944
msgid ""
"van Rossum doesn't like this approach much because the imports appear in a "
"strange place, but it does work."
msgstr "インポートが奇妙な場所に現れることから van Rossum はこの方法をそれほど好みませんが、これは有効です。"

#: ../../faq/programming.rst:1947
msgid ""
"Matthias Urlichs recommends restructuring your code so that the recursive "
"import is not necessary in the first place."
msgstr "Matthias Urlichs は第一に再帰インポートが必要ないようにコードを構築しなおすことを推奨しています。"

#: ../../faq/programming.rst:1950
msgid "These solutions are not mutually exclusive."
msgstr "これらの解決策はそれぞれ両立させることもできます。"

#: ../../faq/programming.rst:1954
msgid "__import__('x.y.z') returns <module 'x'>; how do I get z?"
msgstr "__import__('x.y.z') は <module 'x'> を返しますが、z を得るためにはどうしますか？"

#: ../../faq/programming.rst:1956
msgid ""
"Consider using the convenience function :func:`~importlib.import_module` "
"from :mod:`importlib` instead::"
msgstr "mod:`importlib` に :func:`~importlib.import_module` という便利な関数があるので、代わりにそちらを使用することを検討してください。"

#: ../../faq/programming.rst:1963
msgid ""
"When I edit an imported module and reimport it, the changes don't show up.  "
"Why does this happen?"
msgstr "インポートされたモジュールを編集してから再インポートしましたが、変化が現れません。なぜですか？"

#: ../../faq/programming.rst:1965
msgid ""
"For reasons of efficiency as well as consistency, Python only reads the "
"module file on the first time a module is imported.  If it didn't, in a "
"program consisting of many modules where each one imports the same basic "
"module, the basic module would be parsed and re-parsed many times.  To force"
" rereading of a changed module, do this::"
msgstr "効率と一貫性上の理由から、Python はモジュールが最初にインポートされた時にのみモジュールファイルを読み込みます。そうしないと、たくさんのモジュールでできていて、それぞれが同じ基本モジュールをインポートしているようなプログラムでは、その基本モジュールの解析と再解析が繰り返されることになります。変更されさたモジュールの再読込を強制するには、こうしてください::"

#: ../../faq/programming.rst:1974
msgid ""
"Warning: this technique is not 100% fool-proof.  In particular, modules "
"containing statements like ::"
msgstr "注意:この手法は 100%安全とは言えません。とりわけ ::"

#: ../../faq/programming.rst:1979
msgid ""
"will continue to work with the old version of the imported objects.  If the "
"module contains class definitions, existing class instances will *not* be "
"updated to use the new class definition.  This can result in the following "
"paradoxical behaviour:"
msgstr "のような文を含むモジュールは、インポートされたオブジェクトの古いバージョンを使い続けます。そのモジュールにクラス定義が含まれていたら、存在するクラスインスタンスは新しいクラス定義を使うようにアップデート *されません*。これによって以下の矛盾した振舞いがなされえます:"

#: ../../faq/programming.rst:1991
msgid ""
"The nature of the problem is made clear if you print out the class objects:"
msgstr "この問題の本質は、クラスオブジェクトを印字することで明らかになります::"
