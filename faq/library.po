# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# mollinaca, 2021
# Shin Saito, 2021
# tomo, 2021
# 菊池 健志, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-17 14:14+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: 菊池 健志, 2023\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../faq/library.rst:5
msgid "Library and Extension FAQ"
msgstr "ライブラリと拡張 FAQ"

#: ../../faq/library.rst:8
msgid "Contents"
msgstr "内容"

#: ../../faq/library.rst:12
msgid "General Library Questions"
msgstr "ライブラリ一般の質問"

#: ../../faq/library.rst:15
msgid "How do I find a module or application to perform task X?"
msgstr ""
"作業 X を行うためのモジュールやアプリケーションを探すにはどうしますか？"

#: ../../faq/library.rst:17
msgid ""
"Check :ref:`the Library Reference <library-index>` to see if there's a "
"relevant standard library module.  (Eventually you'll learn what's in the "
"standard library and will be able to skip this step.)"
msgstr ""
":ref:`ライブラリリファンレス <library-index>` から関係がありそうな標準ライブ"
"ラリモジュールがあるかどうか調べてください。 (標準ライブラリに何があるかが分"
"かるようになると、この段階をスキップすることができます。)"

#: ../../faq/library.rst:21
msgid ""
"For third-party packages, search the `Python Package Index <https://pypi."
"org>`_ or try `Google <https://www.google.com>`_ or another web search "
"engine.  Searching for \"Python\" plus a keyword or two for your topic of "
"interest will usually find something helpful."
msgstr ""
"サードパーティのパッケージについては、`Python Package Index <https://pypi."
"org>`_ を探したり、`Google <https://www.google.com>`_ その他の web サーチエン"
"ジンを試してください。\"Python\" に加えて一つか二つのキーワードで興味のある話"
"題を検索すれば、たいてい役に立つものが見つかるでしょう。"

#: ../../faq/library.rst:28
msgid "Where is the math.py (socket.py, regex.py, etc.) source file?"
msgstr ""
"math.py (socket.py, regex.py, etc.) のソースファイルはどこにありますか？"

#: ../../faq/library.rst:30
msgid ""
"If you can't find a source file for a module it may be a built-in or "
"dynamically loaded module implemented in C, C++ or other compiled language. "
"In this case you may not have the source file or it may be something like :"
"file:`mathmodule.c`, somewhere in a C source directory (not on the Python "
"Path)."
msgstr ""
"モジュールのソースファイルが見付けられない場合は、それは C 、 C++ かもしくは"
"別のコンパイル言語で実装された、ビルトインもしくは動的に読み込まれるモジュー"
"ルかもしれません。この場合、ソースは手に入らないかもしれませんし、 :file:"
"`mathmodule.c` のようなものが (Python の読み込みパスに無い) C ソースディレク"
"トリのどこかにあるかもしれません。"

#: ../../faq/library.rst:35
msgid "There are (at least) three kinds of modules in Python:"
msgstr "Python のモジュールには、(少なくとも) 3 種類あります:"

#: ../../faq/library.rst:37
msgid "modules written in Python (.py);"
msgstr "Python で書かれたモジュール (.py)。"

#: ../../faq/library.rst:38
msgid ""
"modules written in C and dynamically loaded (.dll, .pyd, .so, .sl, etc);"
msgstr "C で書かれ、動的にロードされるモジュール (.dll, .pyd, .so, .sl, etc)。"

#: ../../faq/library.rst:39
msgid ""
"modules written in C and linked with the interpreter; to get a list of "
"these, type::"
msgstr ""
"C で書かれ、インタプリタにリンクされているモジュール。このリストを得るには、"
"こうタイプしてください::"

#: ../../faq/library.rst:47
msgid "How do I make a Python script executable on Unix?"
msgstr "Python のスクリプトを Unix で実行可能にするにはどうしますか？"

#: ../../faq/library.rst:49
msgid ""
"You need to do two things: the script file's mode must be executable and the "
"first line must begin with ``#!`` followed by the path of the Python "
"interpreter."
msgstr ""
"二つの条件があります :スクリプトファイルのモードが実行可能で、最初の行が ``#!"
"`` で始まり Python インタプリタのパスが続いていなければなりません。"

#: ../../faq/library.rst:53
msgid ""
"The first is done by executing ``chmod +x scriptfile`` or perhaps ``chmod "
"755 scriptfile``."
msgstr ""
"前者は、``chmod +x scriptfile`` 、場合によっては ``chmod 755 scriptfile`` を"
"実行すればできます。"

#: ../../faq/library.rst:56
msgid ""
"The second can be done in a number of ways.  The most straightforward way is "
"to write ::"
msgstr "後者は、いくつかの方法でできます。最も直接的な方法はこのように ::"

#: ../../faq/library.rst:61
msgid ""
"as the very first line of your file, using the pathname for where the Python "
"interpreter is installed on your platform."
msgstr ""
"のようにファイルの一番最初の行に、プラットフォーム上の Python がインストール"
"されているパス名を書くことです。"

#: ../../faq/library.rst:64
msgid ""
"If you would like the script to be independent of where the Python "
"interpreter lives, you can use the :program:`env` program.  Almost all Unix "
"variants support the following, assuming the Python interpreter is in a "
"directory on the user's :envvar:`PATH`::"
msgstr ""
"スクリプトを Python インタプリタの場所に依存させたくない場合は、 :program:"
"`env` プログラムが使えます。 Python インタプリタがユーザの :envvar:`PATH` の"
"ディレクトリにあることを前提とすれば、ほとんど全ての Unix 系 OS では次の書き"
"方をサポートしています::"

#: ../../faq/library.rst:71
msgid ""
"*Don't* do this for CGI scripts.  The :envvar:`PATH` variable for CGI "
"scripts is often very minimal, so you need to use the actual absolute "
"pathname of the interpreter."
msgstr ""
"CGI スクリプトでこれをやっては *いけません* 。 CGI スクリプトの :envvar:"
"`PATH` 変数はたいてい最小限のものになっているので、実際のインタプリタの絶対パ"
"スを使う必要があります。"

#: ../../faq/library.rst:75
msgid ""
"Occasionally, a user's environment is so full that the :program:`/usr/bin/"
"env` program fails; or there's no env program at all.  In that case, you can "
"try the following hack (due to Alex Rezinsky):"
msgstr ""
"ときおり、ユーザ環境に余裕が無く :program:`/usr/bin/env` プログラムが失敗する"
"ことがあります; もしくは、 env プログラム自体が無いことがあります。そのような"
"場合は、次の (Alex Rezinsky による) ハックが試せます:"

#: ../../faq/library.rst:86
msgid ""
"The minor disadvantage is that this defines the script's __doc__ string. "
"However, you can fix that by adding ::"
msgstr ""
"これには、スクリプトの __doc__ 文字列を定義するというちょっとした欠点がありま"
"す。しかし、これを付け足せば直せます::"

#: ../../faq/library.rst:94
msgid "Is there a curses/termcap package for Python?"
msgstr "Python には curses/termcap パッケージはありますか？"

#: ../../faq/library.rst:98
msgid ""
"For Unix variants: The standard Python source distribution comes with a "
"curses module in the :source:`Modules` subdirectory, though it's not "
"compiled by default. (Note that this is not available in the Windows "
"distribution -- there is no curses module for Windows.)"
msgstr ""
"Unix 系 OS において: 標準の Python ソースディストリビューションには :source:"
"`Modules` サブディレクトリに curses モジュールが付いてきますが、デフォルトで"
"はコンパイルされていません。 (これは Windows 用ディストリビューションでは利用"
"できないことに注意してください -- Windows には curses モジュールはありませ"
"ん。)"

#: ../../faq/library.rst:103
msgid ""
"The :mod:`curses` module supports basic curses features as well as many "
"additional functions from ncurses and SYSV curses such as colour, "
"alternative character set support, pads, and mouse support. This means the "
"module isn't compatible with operating systems that only have BSD curses, "
"but there don't seem to be any currently maintained OSes that fall into this "
"category."
msgstr ""
":mod:`curses` モジュールは基本的な curses の機能や、色付きの表示、別の文字集"
"合サポート、パッド、マウスサポートなどの ncurses や SYSV curses の多くの機能"
"をサポートしています。このことは、モジュールが BSD curses だけしか持っていな"
"い OS とは互換性が無いことを意味しますが、現在メンテナンスされている OS でそ"
"ういう類のものは無さそうです。"

#: ../../faq/library.rst:111
msgid "Is there an equivalent to C's onexit() in Python?"
msgstr "Python には C の onexit() に相当するものはありますか？"

#: ../../faq/library.rst:113
msgid ""
"The :mod:`atexit` module provides a register function that is similar to "
"C's :c:func:`onexit`."
msgstr ""
":mod:`atexit` モジュールは、 C の :c:func:`onexit` と同じような関数登録を提供"
"します。"

#: ../../faq/library.rst:118
msgid "Why don't my signal handlers work?"
msgstr "シグナルハンドラが動かないのですがなぜですか？"

#: ../../faq/library.rst:120
msgid ""
"The most common problem is that the signal handler is declared with the "
"wrong argument list.  It is called as ::"
msgstr ""
"最もありがちな問題は、シグナルハンドラが間違った引数リストで宣言されているこ"
"とです。これは次のように呼び出されます ::"

#: ../../faq/library.rst:125
msgid "so it should be declared with two parameters::"
msgstr "だから、これは二つの仮引数で宣言されるべきです:"

#: ../../faq/library.rst:132
msgid "Common tasks"
msgstr "よくある作業"

#: ../../faq/library.rst:135
msgid "How do I test a Python program or component?"
msgstr "Python のプログラムやコンポーネントをテストするにはどうしますか？"

#: ../../faq/library.rst:137
msgid ""
"Python comes with two testing frameworks.  The :mod:`doctest` module finds "
"examples in the docstrings for a module and runs them, comparing the output "
"with the expected output given in the docstring."
msgstr ""
"Python には二つのテストフレームワークがついています。:mod:`doctest` モジュー"
"ルは、モジュールの docstring から使用例を見つけてそれらを実行し、出力を "
"docstring によって与えられた望まれる出力と比較します。"

#: ../../faq/library.rst:141
msgid ""
"The :mod:`unittest` module is a fancier testing framework modelled on Java "
"and Smalltalk testing frameworks."
msgstr ""
":mod:`unittest` モジュールは、Java や Smalltalk のテストフレームワークを模し"
"た装飾されたテストフレームワークです。"

#: ../../faq/library.rst:144
msgid ""
"To make testing easier, you should use good modular design in your program. "
"Your program should have almost all functionality encapsulated in either "
"functions or class methods -- and this sometimes has the surprising and "
"delightful effect of making the program run faster (because local variable "
"accesses are faster than global accesses).  Furthermore the program should "
"avoid depending on mutating global variables, since this makes testing much "
"more difficult to do."
msgstr ""
"テスト作業を簡単にするために、プログラムにおいてモジュール性の良い設計を使う"
"べきです。プログラムでは、ほぼ全ての処理を関数やクラスのメソッドで包むべきで"
"す -- こうすることで、プログラムが速くなるという驚くような愉快な効果がときお"
"り得られることがあります (というのも、ローカル変数へのアクセスはグローバルな"
"アクセスよりも速いからです)。さらに言うと、テストを行うのがより難しくなってし"
"まうため、プログラムは可変なグローバル変数に依存するのを避けるべきです。"

#: ../../faq/library.rst:152
msgid "The \"global main logic\" of your program may be as simple as ::"
msgstr "プログラムの \"global main logic\" は ::"

#: ../../faq/library.rst:157
msgid "at the bottom of the main module of your program."
msgstr ""
"のように main モジュールの最後に出来る限りシンプルなものを書くのが良いでしょ"
"う。"

#: ../../faq/library.rst:159
msgid ""
"Once your program is organized as a tractable collection of function and "
"class behaviours, you should write test functions that exercise the "
"behaviours.  A test suite that automates a sequence of tests can be "
"associated with each module. This sounds like a lot of work, but since "
"Python is so terse and flexible it's surprisingly easy.  You can make coding "
"much more pleasant and fun by writing your test functions in parallel with "
"the \"production code\", since this makes it easy to find bugs and even "
"design flaws earlier."
msgstr ""
"プログラムが整理され、関数やクラスの動作が追いやすい状態になったら、その動作"
"を試すテスト関数を書くべきです。一連のテストを自動化するテストスイートは、そ"
"れぞれのモジュールに関連付けることができます。これは手間が掛かりそうに思えま"
"すが、Python は簡素で融通が効くので、驚くほど簡単です。\"製品コード "
"(production code)\" と並行でテスト関数を書くことで、バグや設計の不備でさえも"
"早い段階で簡単に見付かるようになるので、コーディング作業をより心地良く楽しい"
"ものにできます。"

#: ../../faq/library.rst:167
msgid ""
"\"Support modules\" that are not intended to be the main module of a program "
"may include a self-test of the module. ::"
msgstr ""
"プログラムのメインモジュールとして設計されたのではない \"補助モジュール\" に"
"は、モジュールの自己テストを含めるといいでしょう。 ::"

#: ../../faq/library.rst:173
msgid ""
"Even programs that interact with complex external interfaces may be tested "
"when the external interfaces are unavailable by using \"fake\" interfaces "
"implemented in Python."
msgstr ""
"複雑な外部インターフェースと作用し合うプログラムでさえ、外部インターフェース"
"が使えない時でも、Python で実装された \"fake\" インターフェースを使ってテスト"
"できます。"

#: ../../faq/library.rst:179
msgid "How do I create documentation from doc strings?"
msgstr ""
"Python のドキュメント文字列からドキュメントを生成するにはどうしますか？"

#: ../../faq/library.rst:181
msgid ""
"The :mod:`pydoc` module can create HTML from the doc strings in your Python "
"source code.  An alternative for creating API documentation purely from "
"docstrings is `epydoc <https://epydoc.sourceforge.net/>`_.  `Sphinx <https://"
"www.sphinx-doc.org>`_ can also include docstring content."
msgstr ""
":mod:`pydoc` モジュールで Python ソースコード内のドキュメント文字列から HTML "
"を生成できます。純粋に docstring から API ドキュメントを生成するには、他に "
"`epydoc <https://epydoc.sourceforge.net/>`_ という選択肢もあります。 `Sphinx "
"<https://www.sphinx-doc.org>`_ も docstring の内容を含めることができます。"

#: ../../faq/library.rst:188
msgid "How do I get a single keypress at a time?"
msgstr "一度に一つの押鍵を取得するにはどうしますか？"

#: ../../faq/library.rst:190
msgid ""
"For Unix variants there are several solutions.  It's straightforward to do "
"this using curses, but curses is a fairly large module to learn."
msgstr ""
"Unix 系 OS ではいくつか解決方法があります。curses を使うのが素直なやり方です"
"が、curses は学ぶには少し大き過ぎるモジュールです。"

#: ../../faq/library.rst:234
msgid "Threads"
msgstr "スレッド"

#: ../../faq/library.rst:237
msgid "How do I program using threads?"
msgstr "スレッドを使ったプログラムを書くにはどうしますか？"

#: ../../faq/library.rst:239
msgid ""
"Be sure to use the :mod:`threading` module and not the :mod:`_thread` "
"module. The :mod:`threading` module builds convenient abstractions on top of "
"the low-level primitives provided by the :mod:`_thread` module."
msgstr ""
":mod:`_thread` モジュールではなく、必ず :mod:`threading` モジュールを使ってく"
"ださい。 :mod:`threading` モジュールは、 :mod:`_thread` モジュールで提供され"
"る低レベルな基本要素の、便利な抽象化を構成します。"

#: ../../faq/library.rst:245
msgid "None of my threads seem to run: why?"
msgstr "スレッドが一つも実行されていないようです。なぜですか？"

#: ../../faq/library.rst:247
msgid ""
"As soon as the main thread exits, all threads are killed.  Your main thread "
"is running too quickly, giving the threads no time to do any work."
msgstr ""
"メインスレッドが終了するとともに、全てのスレッドは終了されます。メインスレッ"
"ドは速く働きすぎるので、スレッドには何をする時間も与えられません。"

#: ../../faq/library.rst:250
msgid ""
"A simple fix is to add a sleep to the end of the program that's long enough "
"for all the threads to finish::"
msgstr ""
"簡単な解決策は、プログラムの終わりに、スレッドが完了するのに十分な時間のス"
"リープを加えることです::"

#: ../../faq/library.rst:265
msgid ""
"But now (on many platforms) the threads don't run in parallel, but appear to "
"run sequentially, one at a time!  The reason is that the OS thread scheduler "
"doesn't start a new thread until the previous thread is blocked."
msgstr ""
"しかし、実際は (ほとんどのプラットフォームでは) スレッドは並行して実行される"
"のではなく、一つづつ実行されるのです！なぜなら、OS のスレッドスケジューラは、"
"前のスレッドがブロックされるまで新しいスレッドを開始しないからです。"

#: ../../faq/library.rst:269
msgid "A simple fix is to add a tiny sleep to the start of the run function::"
msgstr "簡単に直すには、関数の実行の最初にちょっとスリープを加えることです::"

#: ../../faq/library.rst:282
msgid ""
"Instead of trying to guess a good delay value for :func:`time.sleep`, it's "
"better to use some kind of semaphore mechanism.  One idea is to use the :mod:"
"`queue` module to create a queue object, let each thread append a token to "
"the queue when it finishes, and let the main thread read as many tokens from "
"the queue as there are threads."
msgstr ""
":func:`time.sleep` の良い遅延時間を推測しようとするよりも、セマフォのような仕"
"組みを使う方が良いでしょう。 1 つのアイディアは :mod:`queue` モジュールを使っ"
"て、キューオブジェクトを作り、各スレッドが完了したときにキューにトークンを追"
"加し、メインスレッドにスレッドと同じ数のトークンをキューから読み出させること"
"です。"

#: ../../faq/library.rst:290
msgid "How do I parcel out work among a bunch of worker threads?"
msgstr "たくさんのワーカースレッドに作業を割り振るにはどうしますか？"

#: ../../faq/library.rst:292
msgid ""
"The easiest way is to use the :mod:`concurrent.futures` module, especially "
"the :mod:`~concurrent.futures.ThreadPoolExecutor` class."
msgstr ""
"最も簡単な方法は、新しい :mod:`concurrent.futures` モジュール、特に :mod:"
"`~concurrent.futures.ThreadPoolExecutor` クラスを使うことです。"

#: ../../faq/library.rst:295
msgid ""
"Or, if you want fine control over the dispatching algorithm, you can write "
"your own logic manually.  Use the :mod:`queue` module to create a queue "
"containing a list of jobs.  The :class:`~queue.Queue` class maintains a list "
"of objects and has a ``.put(obj)`` method that adds items to the queue and a "
"``.get()`` method to return them.  The class will take care of the locking "
"necessary to ensure that each job is handed out exactly once."
msgstr ""
"もしくは、実行アルゴリズムを上手にコントロールしたい場合は、自身の手でロジッ"
"クを書くこともできます。 :mod:`queue` モジュールを使って、ジョブのリストを含"
"むキューを作ってください。 :class:`~queue.Queue` クラスはオブジェクトのリスト"
"を保持し、キューに要素を追加する ``.put(obj)`` メソッド、それら要素を返す ``."
"get()`` メソッドを持っています。このクラスは、それぞれのジョブがきっちり 1 回"
"だけ取り出されることを保証するのに必要なロック処理にも配慮します。"

#: ../../faq/library.rst:302
msgid "Here's a trivial example::"
msgstr "ここにちょっとした例があります::"

#: ../../faq/library.rst:340
msgid "When run, this will produce the following output:"
msgstr "実行時には、以下のように出力されます:"

#: ../../faq/library.rst:358
msgid ""
"Consult the module's documentation for more details; the :class:`~queue."
"Queue` class provides a featureful interface."
msgstr ""
"より詳しいことはモジュールのドキュメントを調べてください; :class:`~queue."
"Queue` クラスは多機能なインターフェースを提供しています。"

#: ../../faq/library.rst:363
msgid "What kinds of global value mutation are thread-safe?"
msgstr "グローバルな値のどんな種類の変更がスレッドセーフになるのですか？"

#: ../../faq/library.rst:365
msgid ""
"A :term:`global interpreter lock` (GIL) is used internally to ensure that "
"only one thread runs in the Python VM at a time.  In general, Python offers "
"to switch among threads only between bytecode instructions; how frequently "
"it switches can be set via :func:`sys.setswitchinterval`.  Each bytecode "
"instruction and therefore all the C implementation code reached from each "
"instruction is therefore atomic from the point of view of a Python program."
msgstr ""
":term:`global interpreter lock` (GIL) が内部で使われ、Python VM で一度に一つ"
"だけのスレッドが実行されることが保証されています。一般に、Python ではスレッド"
"間の切り替えをバイトコード命令の間でのみ行います。切り替えの周期は、 :func:"
"`sys.setswitchinterval` で設定できます。したがって、それぞれのバイトコード命"
"令、そしてそれぞれの命令が届く全ての C 実装コードは、 Python プログラムの観点"
"からは、アトミックです。"

#: ../../faq/library.rst:372
msgid ""
"In theory, this means an exact accounting requires an exact understanding of "
"the PVM bytecode implementation.  In practice, it means that operations on "
"shared variables of built-in data types (ints, lists, dicts, etc) that "
"\"look atomic\" really are."
msgstr ""
"このことから、理論上は、正確な勘定のためには PVM バイトコードの実装を理解する"
"ことが必要です。実際上は、組み込みデータ型(整数、リスト、辞書、等)の、変数を"
"共有する \"アトミックそうな\" 演算は、実際にアトミックです。"

#: ../../faq/library.rst:377
msgid ""
"For example, the following operations are all atomic (L, L1, L2 are lists, "
"D, D1, D2 are dicts, x, y are objects, i, j are ints)::"
msgstr ""
"例えば、以下の演算は全てアトミックです (L、L1、L2 はリスト、 D、D1、D2 は辞"
"書、x、y はオブジェクト、i、j は整数です)::"

#: ../../faq/library.rst:392
msgid "These aren't::"
msgstr "これらは、アトミックではありません::"

#: ../../faq/library.rst:399
msgid ""
"Operations that replace other objects may invoke those other objects' :meth:"
"`__del__` method when their reference count reaches zero, and that can "
"affect things.  This is especially true for the mass updates to dictionaries "
"and lists.  When in doubt, use a mutex!"
msgstr ""
"他のオブジェクトを置き換えるような演算は、そのオブジェクトの参照カウントがゼ"
"ロになったときに :meth:`__del__` メソッドを呼び出すことがあり、これが影響を及"
"ぼすかもしれません。これは特に、辞書やリストの大規模な更新に当てはまります。"
"疑わしければ、mutex を使ってください！"

#: ../../faq/library.rst:406
msgid "Can't we get rid of the Global Interpreter Lock?"
msgstr ""
"グローバルインタプリタロック (Global Interpreter Lock) を取り除くことはできな"
"いのですか？"

#: ../../faq/library.rst:410
msgid ""
"The :term:`global interpreter lock` (GIL) is often seen as a hindrance to "
"Python's deployment on high-end multiprocessor server machines, because a "
"multi-threaded Python program effectively only uses one CPU, due to the "
"insistence that (almost) all Python code can only run while the GIL is held."
msgstr ""
"マルチスレッド Python プログラムは事実上一つの CPU しか使えず、 (ほとんど) 全"
"ての Python コードが :term:`グローバルインタプリタロック <global interpreter "
"lock>`  (GIL)  が保持されている間しか作動しなくなるということで、GIL は、 "
"Python をハイエンドなマルチプロセッササーバマシン上に配備する上で邪魔であると"
"見なされがちです。"

#: ../../faq/library.rst:415
msgid ""
"Back in the days of Python 1.5, Greg Stein actually implemented a "
"comprehensive patch set (the \"free threading\" patches) that removed the "
"GIL and replaced it with fine-grained locking.  Adam Olsen recently did a "
"similar experiment in his `python-safethread <https://code.google.com/"
"archive/p/python-safethread>`_ project.  Unfortunately, both experiments "
"exhibited a sharp drop in single-thread performance (at least 30% slower), "
"due to the amount of fine-grained locking necessary to compensate for the "
"removal of the GIL."
msgstr ""
"Python 1.5 の時代、Greg Stein は実際に、GIL を取り除いてよりきめ細かいロッキ"
"ングで置き換える包括的なパッチセット (\"free threading\" パッチ) を実装しまし"
"た。Adam Olsen は最近、 `python-safethread <https://code.google.com/archive/"
"p/python-safethread>`_  プロジェクトで似たような実験を行いました。残念ながら"
"どちらの実験も、GIL の除去を補償するために必要なきめ細かいロッキングの量のた"
"め、シングルスレッドのパフォーマンスの極端な低下 (少なくとも 30% の遅れ) を示"
"しました。"

#: ../../faq/library.rst:423
msgid ""
"This doesn't mean that you can't make good use of Python on multi-CPU "
"machines! You just have to be creative with dividing the work up between "
"multiple *processes* rather than multiple *threads*.  The :class:"
"`~concurrent.futures.ProcessPoolExecutor` class in the new :mod:`concurrent."
"futures` module provides an easy way of doing so; the :mod:`multiprocessing` "
"module provides a lower-level API in case you want more control over "
"dispatching of tasks."
msgstr ""
"これは、マルチ CPU マシン上で Python を使いこなせないことを意味しません！タス"
"クを複数の *スレッド* ではなく複数の *プロセス* に分けることを考えればいいの"
"です。これは、新しい :mod:`concurrent.futures` モジュールの :class:"
"`~concurrent.futures.ProcessPoolExecutor` クラスを使えば簡単です。:mod:"
"`multiprocessing` モジュールは、タスクのディスパッチをより深く制御したいとき"
"のためのより低水準な API を提供します。"

#: ../../faq/library.rst:431
msgid ""
"Judicious use of C extensions will also help; if you use a C extension to "
"perform a time-consuming task, the extension can release the GIL while the "
"thread of execution is in the C code and allow other threads to get some "
"work done.  Some standard library modules such as :mod:`zlib` and :mod:"
"`hashlib` already do this."
msgstr ""
"C 拡張をうまく使うことも役立ちます。C 拡張を時間のかかるタスクの実行に使え"
"ば、その拡張は実行が C コードで行われている間 GIL を解放でき、その間に他のス"
"レッドで作業が進められます。 :mod:`zlib` や :mod:`hashlib` など、すでにこれを"
"行なっている標準ライブラリモジュールもあります。"

#: ../../faq/library.rst:437
msgid ""
"It has been suggested that the GIL should be a per-interpreter-state lock "
"rather than truly global; interpreters then wouldn't be able to share "
"objects. Unfortunately, this isn't likely to happen either.  It would be a "
"tremendous amount of work, because many object implementations currently "
"have global state. For example, small integers and short strings are cached; "
"these caches would have to be moved to the interpreter state.  Other object "
"types have their own free list; these free lists would have to be moved to "
"the interpreter state. And so on."
msgstr ""
"GIL を本当にグローバルにするより、インタプリタ状態ごとのロックにするべきとい"
"う提案もあります。そして、インタプリタはオブジェクトを共有するべきではないと"
"いうことです。残念ながら、どちらも実現しないでしょう。多くのオブジェクトの実"
"装は現在、グローバル状態を持っているので、実現はたいへんな大仕事になりそうで"
"す。例えば、小さな整数と短い文字列はキャッシュされます。このキャッシュはイン"
"タプリタ状態に動かされなくてはなりません。他のオブジェクト型は自身の自由変数"
"リストを持っています。これらの自由変数リストはインタプリタ状態に動かされなく"
"てはなりません。等々。"

#: ../../faq/library.rst:446
msgid ""
"And I doubt that it can even be done in finite time, because the same "
"problem exists for 3rd party extensions.  It is likely that 3rd party "
"extensions are being written at a faster rate than you can convert them to "
"store all their global state in the interpreter state."
msgstr ""
"それどころか、その作業が終わる時が来るかもわかりません。なぜなら、サードパー"
"ティ拡張にも問題があるからです。サードパーティ拡張が書かれるペースは、インタ"
"プリタ状態にすべてのグローバル状態を格納するように変換できるペースよりも速い"
"ことでしょう。"

#: ../../faq/library.rst:451
msgid ""
"And finally, once you have multiple interpreters not sharing any state, what "
"have you gained over running each interpreter in a separate process?"
msgstr ""
"そして最後に、状態を共有しないインタプリタを1プロセス上で複数作れたとして、各"
"インタプリタをそれぞれ別プロセスで動かすのに比べてどういう利点があるのでしょ"
"うか？"

#: ../../faq/library.rst:456
msgid "Input and Output"
msgstr "入力と出力"

#: ../../faq/library.rst:459
msgid "How do I delete a file? (And other file questions...)"
msgstr "ファイルを削除するにはどうしますか？ (その他、ファイルに関する質問...)"

#: ../../faq/library.rst:461
msgid ""
"Use ``os.remove(filename)`` or ``os.unlink(filename)``; for documentation, "
"see the :mod:`os` module.  The two functions are identical; :func:`~os."
"unlink` is simply the name of the Unix system call for this function."
msgstr ""
"``os.remove(filename)`` または ``os.unlink(filename)`` を使ってください。ド"
"キュメントは、 :mod:`os` モジュールを参照してください。この二つの関数は同じも"
"のです。 :func:`~os.unlink` は単に、この関数の Unix システムコールの名称で"
"す。"

#: ../../faq/library.rst:465
msgid ""
"To remove a directory, use :func:`os.rmdir`; use :func:`os.mkdir` to create "
"one. ``os.makedirs(path)`` will create any intermediate directories in "
"``path`` that don't exist. ``os.removedirs(path)`` will remove intermediate "
"directories as long as they're empty; if you want to delete an entire "
"directory tree and its contents, use :func:`shutil.rmtree`."
msgstr ""
"ディレクトリを削除するには、:func:`os.rmdir` を使ってください。作成には :"
"func:`os.mkdir` を使ってください。``os.makedirs(path)`` は ``path`` の中間の"
"ディレクトリの、存在しないものを作成します。``os.removedirs(path)`` は中間の"
"ディレクトリが空である限り、それらを削除します。ディレクトリツリー全体とその"
"中身全てを削除したいなら、:func:`shutil.rmtree` を使ってください。"

#: ../../faq/library.rst:471
msgid "To rename a file, use ``os.rename(old_path, new_path)``."
msgstr ""
"ファイルの名前を変更するには、``os.rename(old_path, new_path)`` を使ってくだ"
"さい。"

#: ../../faq/library.rst:473
msgid ""
"To truncate a file, open it using ``f = open(filename, \"rb+\")``, and use "
"``f.truncate(offset)``; offset defaults to the current seek position.  "
"There's also ``os.ftruncate(fd, offset)`` for files opened with :func:`os."
"open`, where *fd* is the file descriptor (a small integer)."
msgstr ""
"ファイルを切り詰めるには、 ``f = open(filename, \"rb+\")`` を使ってファイルを"
"開き、 ``f.truncate(offset)`` を使ってください; offset はデフォルトでは現在の"
"シーク位置です。 :func:`os.open` で開かれたファイル用の ``os.ftruncate(fd, "
"offset)`` もあります。 *fd* はファイルディスクリプタ (小さい整数値) です。"

#: ../../faq/library.rst:478
msgid ""
"The :mod:`shutil` module also contains a number of functions to work on "
"files including :func:`~shutil.copyfile`, :func:`~shutil.copytree`, and :"
"func:`~shutil.rmtree`."
msgstr ""
":mod:`shutil` モジュールにも、:func:`~shutil.copyfile`、 :func:`~shutil."
"copytree`、:func:`~shutil.rmtree` 等、ファイルに作用する関数がいくつか含まれ"
"ます。"

#: ../../faq/library.rst:484
msgid "How do I copy a file?"
msgstr "ファイルをコピーするにはどうしますか？"

#: ../../faq/library.rst:486
msgid ""
"The :mod:`shutil` module contains a :func:`~shutil.copyfile` function. Note "
"that on Windows NTFS volumes, it does not copy `alternate data streams "
"<https://en.wikipedia.org/wiki/NTFS#Alternate_data_stream_(ADS)>`_ nor "
"`resource forks <https://en.wikipedia.org/wiki/Resource_fork>`__ on macOS "
"HFS+ volumes, though both are now rarely used. It also doesn't copy file "
"permissions and metadata, though using :func:`shutil.copy2` instead will "
"preserve most (though not all) of it."
msgstr ""

#: ../../faq/library.rst:497
msgid "How do I read (or write) binary data?"
msgstr "バイナリデータを読み書きするにはどうしますか？"

#: ../../faq/library.rst:499
msgid ""
"To read or write complex binary data formats, it's best to use the :mod:"
"`struct` module.  It allows you to take a string containing binary data "
"(usually numbers) and convert it to Python objects; and vice versa."
msgstr ""
"複雑なバイナリデータ形式の読み書きには、:mod:`struct` モジュールを使うのが一"
"番です。これでバイナリデータ (通常は数) を含む文字列を取って、 Python オブ"
"ジェクトに変換することができますし、その逆もできます。"

#: ../../faq/library.rst:503
msgid ""
"For example, the following code reads two 2-byte integers and one 4-byte "
"integer in big-endian format from a file::"
msgstr ""
"例えば、以下のコードはファイルから 2 バイトの整数 2 個と 4 バイトの整数 1 個"
"をビッグエンディアンフォーマットで読み込みます::"

#: ../../faq/library.rst:512
msgid ""
"The '>' in the format string forces big-endian data; the letter 'h' reads "
"one \"short integer\" (2 bytes), and 'l' reads one \"long integer\" (4 "
"bytes) from the string."
msgstr ""
"フォーマット中の '>' はデータを強制的にビッグエンディアンにします。ファイルか"
"ら、文字 'h' は一つの\"整数\"(2 バイト)を読み込み、文字 'l' は一つの\"long 整"
"数\"を読み込みます。"

#: ../../faq/library.rst:516
msgid ""
"For data that is more regular (e.g. a homogeneous list of ints or floats), "
"you can also use the :mod:`array` module."
msgstr ""
"より規則的なデータ (例えば、整数や浮動小数点数の中身の型が揃ったリスト) に対"
"しては、 :mod:`array` モジュールを使うこともできます。"

#: ../../faq/library.rst:521
msgid ""
"To read and write binary data, it is mandatory to open the file in binary "
"mode (here, passing ``\"rb\"`` to :func:`open`).  If you use ``\"r\"`` "
"instead (the default), the file will be open in text mode and ``f.read()`` "
"will return :class:`str` objects rather than :class:`bytes` objects."
msgstr ""
"バイナリデータを読み書きするには、 (ここにあるように ``\"rb\"`` を :func:"
"`open` に渡して) ファイルをバイナリモードで開く義務があります。代わりに (デ"
"フォルトの) ``\"r\"`` を使った場合は、ファイルはテキストモードで開かれ、 ``f."
"read()`` は :class:`bytes` オブジェクトではなく :class:`str` オブジェクトを返"
"します。"

#: ../../faq/library.rst:529
msgid "I can't seem to use os.read() on a pipe created with os.popen(); why?"
msgstr ""
"os.popen() によって作られたパイプで os.read() が使われていないようです。なぜ"
"ですか？"

#: ../../faq/library.rst:531
msgid ""
":func:`os.read` is a low-level function which takes a file descriptor, a "
"small integer representing the opened file.  :func:`os.popen` creates a high-"
"level file object, the same type returned by the built-in :func:`open` "
"function. Thus, to read *n* bytes from a pipe *p* created with :func:`os."
"popen`, you need to use ``p.read(n)``."
msgstr ""
":func:`os.read` は、開かれたファイルを表す小さな整数、ファイルディスクリプタ"
"を引数に取る、低レベルの関数です。 :func:`os.popen` は、組み込みの :func:"
"`open` 関数の返り値と同じ型の、高レベルなファイルオブジェクトを作成します。"
"従って、 :func:`os.popen` によって作成されたパイプ *p* から *n* バイト分だけ"
"読み取るには、 ``p.read(n)`` を使う必要があります。"

#: ../../faq/library.rst:618
msgid "How do I access the serial (RS232) port?"
msgstr "シリアル (RS232) ポートにアクセスするにはどうしますか？"

#: ../../faq/library.rst:620
msgid "For Win32, OSX, Linux, BSD, Jython, IronPython:"
msgstr ""

#: ../../faq/library.rst:622
msgid "https://pypi.org/project/pyserial/"
msgstr ""

#: ../../faq/library.rst:624
msgid "For Unix, see a Usenet post by Mitch Chapman:"
msgstr "Unix では、Mitch Chapman による Usenet の投稿を参照してください:"

#: ../../faq/library.rst:626
msgid "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"
msgstr "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"

#: ../../faq/library.rst:630
msgid "Why doesn't closing sys.stdout (stdin, stderr) really close it?"
msgstr ""
"sys.stdout (stdin, stderr) を閉じようとしても実際に閉じられないのはなぜです"
"か？"

#: ../../faq/library.rst:632
msgid ""
"Python :term:`file objects <file object>` are a high-level layer of "
"abstraction on low-level C file descriptors."
msgstr ""
"Python の :term:`file object <file object>` は、低水準の C ファイルディスクリ"
"プタ上の、抽象の高水準レイヤです。"

#: ../../faq/library.rst:635
msgid ""
"For most file objects you create in Python via the built-in :func:`open` "
"function, ``f.close()`` marks the Python file object as being closed from "
"Python's point of view, and also arranges to close the underlying C file "
"descriptor.  This also happens automatically in ``f``'s destructor, when "
"``f`` becomes garbage."
msgstr ""
"組み込みの :func:`open` 関数によって生成されたほとんどのファイルオブジェクト"
"では、 ``f.close()`` は Python ファイルオブジェクトが Python の視点からは閉じ"
"られているものとする印をつけ、その下にある C ファイルディスクリプタを閉じるよ"
"うに手配します。これは、 ``f`` がガベージとなったときにも、 ``f`` のデストラ"
"クタで自動的に起こります。"

#: ../../faq/library.rst:641
msgid ""
"But stdin, stdout and stderr are treated specially by Python, because of the "
"special status also given to them by C.  Running ``sys.stdout.close()`` "
"marks the Python-level file object as being closed, but does *not* close the "
"associated C file descriptor."
msgstr ""
"しかし、stdin、stdout、stderr は C で特別な立場が与えられていることから、"
"Python でも同様に特別に扱われます。``sys.stdout.close()`` を実行すると、"
"Python レベルのファイルオブジェクトには閉じられているものとする印がつけられま"
"すが、C ファイルディスクリプタは *閉じられません*。"

#: ../../faq/library.rst:646
msgid ""
"To close the underlying C file descriptor for one of these three, you should "
"first be sure that's what you really want to do (e.g., you may confuse "
"extension modules trying to do I/O).  If it is, use :func:`os.close`::"
msgstr ""
"下にある C ファイルディスクリプタのうち、この三つのどれかを閉じるには、まず本"
"当に閉じる必要があることを確かめるべきです (例えば、拡張モジュールの I/O を混"
"乱させてしまうかもしれません)。本当に必要ならば、 :func:`os.close` を使ってく"
"ださい::"

#: ../../faq/library.rst:654
msgid "Or you can use the numeric constants 0, 1 and 2, respectively."
msgstr "または、数の定数としてそれぞれ 0, 1, 2 も使えます。"

#: ../../faq/library.rst:658
msgid "Network/Internet Programming"
msgstr "ネットワーク/インターネットプログラミング"

#: ../../faq/library.rst:661
msgid "What WWW tools are there for Python?"
msgstr "Python の WWW ツールには何がありますか？"

#: ../../faq/library.rst:663
msgid ""
"See the chapters titled :ref:`internet` and :ref:`netdata` in the Library "
"Reference Manual.  Python has many modules that will help you build server-"
"side and client-side web systems."
msgstr ""
"ライブラリリファレンスマニュアルの :ref:`internet` と :ref:`netdata` という章"
"を参照してください。Python には、サーバサイドとクライアントサイドの web シス"
"テムを構築するのに便利な多くのモジュールがあります。"

#: ../../faq/library.rst:669
msgid ""
"A summary of available frameworks is maintained by Paul Boddie at https://"
"wiki.python.org/moin/WebProgramming\\ ."
msgstr ""
"利用可能なフレームワークの概要は Paul Boddie によって、 https://wiki.python."
"org/moin/WebProgramming でメンテナンスされています。"

#: ../../faq/library.rst:672
msgid ""
"Cameron Laird maintains a useful set of pages about Python web technologies "
"at https://web.archive.org/web/20210224183619/http://phaseit.net/claird/comp."
"lang.python/web_python."
msgstr ""
"Cameron Laird は、https://web.archive.org/web/20210224183619/http://phaseit."
"net/claird/comp.lang.python/web_python で Python のウェブ技術に関する便利な"
"ページ群を整備しています。"

#: ../../faq/library.rst:677
msgid "How can I mimic CGI form submission (METHOD=POST)?"
msgstr "CGI フォームの発信 (METHOD=POST) を模倣するにはどうしますか？"

#: ../../faq/library.rst:679
msgid ""
"I would like to retrieve web pages that are the result of POSTing a form. Is "
"there existing code that would let me do this easily?"
msgstr ""
"フォームを POST した結果のウェブページを取得したいです。簡単に取得するための"
"コードはあるでしょうか？"

#: ../../faq/library.rst:682
msgid "Yes. Here's a simple example that uses :mod:`urllib.request`::"
msgstr "あります。これは :mod:`urllib.request` を利用した簡単な例です::"

#: ../../faq/library.rst:697
msgid ""
"Note that in general for percent-encoded POST operations, query strings must "
"be quoted using :func:`urllib.parse.urlencode`.  For example, to send "
"``name=Guy Steele, Jr.``::"
msgstr ""
"一般的には、パーセント記号でエンコードされた POST 操作では、クエリ文字列は :"
"func:`urllib.parse.urlencode` を使って処理されなければならないことに注意して"
"ください。例えば、 ``name=Guy Steele, Jr.`` を送信するには::"

#: ../../faq/library.rst:705
msgid ":ref:`urllib-howto` for extensive examples."
msgstr ":ref:`urllib-howto` に多くの例があります。"

#: ../../faq/library.rst:709
msgid "What module should I use to help with generating HTML?"
msgstr "どのモジュールが HTML の生成の役に立ちますか？"

#: ../../faq/library.rst:713
msgid ""
"You can find a collection of useful links on the `Web Programming wiki page "
"<https://wiki.python.org/moin/WebProgramming>`_."
msgstr ""
"`Web Programming についての wiki のページ <https://wiki.python.org/moin/"
"WebProgramming>`_ から役に立つリンクが見付けられます。"

#: ../../faq/library.rst:718
msgid "How do I send mail from a Python script?"
msgstr "Python のスクリプトからメールを送るにはどうしますか？"

#: ../../faq/library.rst:720
msgid "Use the standard library module :mod:`smtplib`."
msgstr "標準ライブラリモジュール :mod:`smtplib` を使ってください。"

#: ../../faq/library.rst:722
msgid ""
"Here's a very simple interactive mail sender that uses it.  This method will "
"work on any host that supports an SMTP listener. ::"
msgstr ""
"以下に示すのが、これを使ったごく単純な対話型のメール送信器です。このメソッド"
"は SMTP リスナをサポートするホストならどこででも作動します。 ::"

#: ../../faq/library.rst:742
msgid ""
"A Unix-only alternative uses sendmail.  The location of the sendmail program "
"varies between systems; sometimes it is ``/usr/lib/sendmail``, sometimes ``/"
"usr/sbin/sendmail``.  The sendmail manual page will help you out.  Here's "
"some sample code::"
msgstr ""
"Unix 限定の代わりの選択肢は sendmail を使うことです。sendmail プログラムの場"
"所はシステムによって様々です; あるときは ``/usr/lib/sendmail`` だったり、ある"
"ときは ``/usr/sbin/sendmail`` だったり。sendmail のマニュアルページが助けにな"
"るでしょう。サンプルコードはこのようになります::"

#: ../../faq/library.rst:762
msgid "How do I avoid blocking in the connect() method of a socket?"
msgstr ""
"ソケットの connect() メソッドでブロッキングされなくするにはどうしますか？"

#: ../../faq/library.rst:764
msgid ""
"The :mod:`select` module is commonly used to help with asynchronous I/O on "
"sockets."
msgstr ""
"主に :mod:`select` モジュールがソケットの非同期の I/O を扱うのに使われます。"

#: ../../faq/library.rst:767
msgid ""
"To prevent the TCP connect from blocking, you can set the socket to non-"
"blocking mode.  Then when you do the :meth:`socket.connect`, you will either "
"connect immediately (unlikely) or get an exception that contains the error "
"number as ``.errno``. ``errno.EINPROGRESS`` indicates that the connection is "
"in progress, but hasn't finished yet.  Different OSes will return different "
"values, so you're going to have to check what's returned on your system."
msgstr ""
"TCP 接続がブロッキングされないようにするために、ソケットをノンブロッキング"
"モードに設定することが出来ます。そして :meth:`socket.connect` したときに、即"
"座に接続できるか、エラー番号を ``.errno`` として含む例外を受け取るかのどちら"
"かになります。``errno.EINPROGRESS`` は、接続が進行中であるが、まだ完了してい"
"ないということを示します。異なる OS では異なる値が返されるので、あなたのシス"
"テムで何が返されるかを確かめておく必要があります。"

#: ../../faq/library.rst:774
msgid ""
"You can use the :meth:`socket.connect_ex` method to avoid creating an "
"exception.  It will just return the errno value.  To poll, you can call :"
"meth:`socket.connect_ex` again later -- ``0`` or ``errno.EISCONN`` indicate "
"that you're connected -- or you can pass this socket to :meth:`select."
"select` to check if it's writable."
msgstr ""
":meth:`socket.connect_ex` メソッドを使えば例外を生成しなくて済みます。これは"
"単に errno の値を返すでしょう。ポーリングのためには、後でまた :meth:`socket."
"connect_ex` を呼び出すことができます -- ``0`` または ``errno.EISCONN`` は接続"
"されたことを表します -- または、選択するソケットにこれを渡して書き込み可能か"
"調べることができます。"

#: ../../faq/library.rst:780
msgid ""
"The :mod:`asyncio` module provides a general purpose single-threaded and "
"concurrent asynchronous library, which can be used for writing non-blocking "
"network code. The third-party `Twisted <https://twistedmatrix.com/trac/>`_ "
"library is a popular and feature-rich alternative."
msgstr ""
":mod:`asyncio` モジュールは、ノンブロッキングのネットワークコードを書く作業の"
"ためにフレームワークのような方法を提供します。その他の選択肢として、`Twisted "
"<https://twistedmatrix.com/trac/>`_ は多機能で著名なサードパーティのライブラ"
"リです。"

#: ../../faq/library.rst:788
msgid "Databases"
msgstr "データベース"

#: ../../faq/library.rst:791
msgid "Are there any interfaces to database packages in Python?"
msgstr "Python にはデータベースパッケージへのインターフェースはありますか？"

#: ../../faq/library.rst:793
msgid "Yes."
msgstr "はい。"

#: ../../faq/library.rst:795
msgid ""
"Interfaces to disk-based hashes such as :mod:`DBM <dbm.ndbm>` and :mod:`GDBM "
"<dbm.gnu>` are also included with standard Python.  There is also the :mod:"
"`sqlite3` module, which provides a lightweight disk-based relational "
"database."
msgstr ""
"標準の Python には、 :mod:`DBM <dbm.ndbm>` や :mod:`GDBM <dbm.gnu>` などの、"
"ディスクベースのハッシュへのインターフェースも含まれています。また、 :mod:"
"`sqlite3` モジュールは、軽量なディスクベースの関係データベースを提供します。"

#: ../../faq/library.rst:800
msgid ""
"Support for most relational databases is available.  See the "
"`DatabaseProgramming wiki page <https://wiki.python.org/moin/"
"DatabaseProgramming>`_ for details."
msgstr ""
"ほとんどの関係データベースがサポートされています。詳細は "
"`DatabaseProgramming wiki page <https://wiki.python.org/moin/"
"DatabaseProgramming>`_ を参照してください。"

#: ../../faq/library.rst:806
msgid "How do you implement persistent objects in Python?"
msgstr "Python で永続的なオブジェクトを実装するにはどうしますか？"

#: ../../faq/library.rst:808
msgid ""
"The :mod:`pickle` library module solves this in a very general way (though "
"you still can't store things like open files, sockets or windows), and the :"
"mod:`shelve` library module uses pickle and (g)dbm to create persistent "
"mappings containing arbitrary Python objects."
msgstr ""
":mod:`pickle` ライブラリモジュールで、ごく一般的な方法でこれを解決できます "
"(開かれたファイル、ソケット、ウィンドウのようなものを保管することはできません"
"が)。 :mod:`shelve` ライブラリモジュールは pickle と (g)dbm を使い、任意の "
"Python オブジェクトを含む永続的なマッピングを生成します。"

#: ../../faq/library.rst:815
msgid "Mathematics and Numerics"
msgstr "数学と数"

#: ../../faq/library.rst:818
msgid "How do I generate random numbers in Python?"
msgstr "Python で乱数を生成するにはどうしますか？"

#: ../../faq/library.rst:820
msgid ""
"The standard module :mod:`random` implements a random number generator.  "
"Usage is simple::"
msgstr ""
"標準モジュールの :mod:`random` が乱数生成器を実装しています。使い方は単純で"
"す::"

#: ../../faq/library.rst:826
msgid "This returns a random floating point number in the range [0, 1)."
msgstr "これは区間 [0, 1) 内のランダムな浮動小数点数を返します。"

#: ../../faq/library.rst:828
msgid ""
"There are also many other specialized generators in this module, such as:"
msgstr "このモジュールにはその他多くの特化した生成器もあります。例えば:"

#: ../../faq/library.rst:830
msgid "``randrange(a, b)`` chooses an integer in the range [a, b)."
msgstr "``randrange(a, b)`` は区間 [a, b) から整数を選びます。"

#: ../../faq/library.rst:831
msgid "``uniform(a, b)`` chooses a floating point number in the range [a, b)."
msgstr "``uniform(a, b)`` は区間 [a, b) から浮動小数点数を選びます。"

#: ../../faq/library.rst:832
msgid ""
"``normalvariate(mean, sdev)`` samples the normal (Gaussian) distribution."
msgstr ""
"``normalvariate(mean, sdev)`` は正規 (ガウス) 分布をサンプリングします。"

#: ../../faq/library.rst:834
msgid "Some higher-level functions operate on sequences directly, such as:"
msgstr "シーケンスに直接作用する高水準な関数もあります。例えば:"

#: ../../faq/library.rst:836
msgid "``choice(S)`` chooses a random element from a given sequence."
msgstr "``choice(S)`` は与えられたシーケンスからランダムな要素を選びます。"

#: ../../faq/library.rst:837
msgid "``shuffle(L)`` shuffles a list in-place, i.e. permutes it randomly."
msgstr ""
"``shuffle(L)`` はリストをインプレースにシャッフルします。すなわち、ランダムに"
"並び替えます。"

#: ../../faq/library.rst:839
msgid ""
"There's also a ``Random`` class you can instantiate to create independent "
"multiple random number generators."
msgstr ""
"``Random`` クラスのインスタンスを生成して、複数の独立な乱数生成器をつくること"
"もできます。"
