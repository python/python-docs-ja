# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト)
# This file is distributed under the same license as the Python package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: 2017-06-22 11:57+0000\n"
"Last-Translator: cocoatomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../faq/library.rst:5
msgid "Library and Extension FAQ"
msgstr "ライブラリと拡張 FAQ"

#: ../../faq/library.rst:12
msgid "General Library Questions"
msgstr "ライブラリ一般の質問"

#: ../../faq/library.rst:15
msgid "How do I find a module or application to perform task X?"
msgstr "作業 X を行うためのモジュールやアプリケーションを探すにはどうしますか？"

#: ../../faq/library.rst:17
msgid ""
"Check :ref:`the Library Reference <library-index>` to see if there's a "
"relevant standard library module.  (Eventually you'll learn what's in the "
"standard library and will be able to skip this step.)"
msgstr ":ref:`ライブラリリファンレス <library-index>` から関係がありそうな標準ライブラリモジュールがあるかどうか調べてください。 (標準ライブラリに何があるかが分かるようになると、この段階をスキップすることができます。)"

#: ../../faq/library.rst:21
msgid ""
"For third-party packages, search the `Python Package Index "
"<https://pypi.python.org/pypi>`_ or try `Google <https://www.google.com>`_ "
"or another Web search engine.  Searching for \"Python\" plus a keyword or "
"two for your topic of interest will usually find something helpful."
msgstr "サードパーティのパッケージについては、`Python Package Index <https://pypi.python.org/pypi>`_ を探したり、`Google <https://www.google.com>`_ その他の Web サーチエンジンを試してください。\"Python\" に加えて一つか二つのキーワードで興味のある話題を検索すれば、たいてい役に立つものが見つかるでしょう。"

#: ../../faq/library.rst:28
msgid "Where is the math.py (socket.py, regex.py, etc.) source file?"
msgstr "math.py (socket.py, regex.py, etc.) のソースファイルはどこにありますか？"

#: ../../faq/library.rst:30
msgid ""
"If you can't find a source file for a module it may be a built-in or "
"dynamically loaded module implemented in C, C++ or other compiled language. "
"In this case you may not have the source file or it may be something like "
":file:`mathmodule.c`, somewhere in a C source directory (not on the Python "
"Path)."
msgstr "モジュールのソースファイルが見付けられない場合は、それは C 、 C++ かもしくは別のコンパイル言語で実装された、ビルトインもしくは動的に読み込まれるモジュールかもしれません。この場合、ソースは手に入らないかもしれませんし、 :file:`mathmodule.c` のようなものが (Python の読み込みパスに無い) C ソースディレクトリのどこかにあるかもしれません。"

#: ../../faq/library.rst:35
msgid "There are (at least) three kinds of modules in Python:"
msgstr "Python のモジュールには、(少なくとも) 3 種類あります:"

#: ../../faq/library.rst:37
msgid "modules written in Python (.py);"
msgstr "Python で書かれたモジュール (.py)。"

#: ../../faq/library.rst:38
msgid ""
"modules written in C and dynamically loaded (.dll, .pyd, .so, .sl, etc);"
msgstr "C で書かれ、動的にロードされるモジュール (.dll, .pyd, .so, .sl, etc)。"

#: ../../faq/library.rst:39
msgid ""
"modules written in C and linked with the interpreter; to get a list of "
"these, type::"
msgstr "C で書かれ、インタプリタにリンクされているモジュール。このリストを得るには、こうタイプしてください::"

#: ../../faq/library.rst:47
msgid "How do I make a Python script executable on Unix?"
msgstr "Python のスクリプトを Unix で実行可能にするにはどうしますか？"

#: ../../faq/library.rst:49
msgid ""
"You need to do two things: the script file's mode must be executable and the"
" first line must begin with ``#!`` followed by the path of the Python "
"interpreter."
msgstr "二つの条件があります :スクリプトファイルのモードが実行可能で、最初の行が ``#!`` で始まり Python インタプリタのパスが続いていなければなりません。"

#: ../../faq/library.rst:53
msgid ""
"The first is done by executing ``chmod +x scriptfile`` or perhaps ``chmod "
"755 scriptfile``."
msgstr "前者は、``chmod +x scriptfile`` 、場合によっては ``chmod 755 scriptfile`` を実行すればできます。"

#: ../../faq/library.rst:56
msgid ""
"The second can be done in a number of ways.  The most straightforward way is"
" to write ::"
msgstr "後者は、いくつかの方法でできます。最も直接的な方法はこのように ::"

#: ../../faq/library.rst:61
msgid ""
"as the very first line of your file, using the pathname for where the Python"
" interpreter is installed on your platform."
msgstr "のようにファイルの一番最初の行に、プラットフォーム上の Python がインストールされているパス名を書くことです。"

#: ../../faq/library.rst:64
msgid ""
"If you would like the script to be independent of where the Python "
"interpreter lives, you can use the :program:`env` program.  Almost all Unix "
"variants support the following, assuming the Python interpreter is in a "
"directory on the user's :envvar:`PATH`::"
msgstr "スクリプトを Python インタプリタの場所に依存させたくない場合は、 :program:`env` プログラムが使えます。 Python インタプリタがユーザの :envvar:`PATH` のディレクトリにあることを前提とすれば、ほとんど全ての Unix 系 OS では次の書き方をサポートしています::"

#: ../../faq/library.rst:71
msgid ""
"*Don't* do this for CGI scripts.  The :envvar:`PATH` variable for CGI "
"scripts is often very minimal, so you need to use the actual absolute "
"pathname of the interpreter."
msgstr "CGI スクリプトでこれをやっては *いけません* 。 CGI スクリプトの :envvar:`PATH` 変数はたいてい最小限のものになっているので、実際のインタプリタの絶対パスを使う必要があります。"

#: ../../faq/library.rst:75
msgid ""
"Occasionally, a user's environment is so full that the "
":program:`/usr/bin/env` program fails; or there's no env program at all.  In"
" that case, you can try the following hack (due to Alex Rezinsky)::"
msgstr "ときおり、ユーザ環境に余裕が無く :program:`/usr/bin/env` プログラムが失敗することがあります; もしくは、 env プログラム自体が無いことがあります。そのような場合は、次の (Alex Rezinsky による) ハックが試せます::"

#: ../../faq/library.rst:84
msgid ""
"The minor disadvantage is that this defines the script's __doc__ string. "
"However, you can fix that by adding ::"
msgstr "これには、スクリプトの __doc__ 文字列を定義するというちょっとした欠点があります。しかし、これを付け足せば直せます::"

#: ../../faq/library.rst:92
msgid "Is there a curses/termcap package for Python?"
msgstr "Python には curses/termcap パッケージはありますか？"

#: ../../faq/library.rst:96
msgid ""
"For Unix variants the standard Python source distribution comes with a "
"curses module in the :source:`Modules` subdirectory, though it's not "
"compiled by default. (Note that this is not available in the Windows "
"distribution -- there is no curses module for Windows.)"
msgstr "Unix 系では、標準の Python ソース配布には、 :source:`Modules` サブディレクトリに curses モジュールが同梱されていますが、デフォルトではコンパイルされていません (なお、Windows ディストリビューションでは使えません -- Windows 用の curses モジュールはありません)"

#: ../../faq/library.rst:101
msgid ""
"The :mod:`curses` module supports basic curses features as well as many "
"additional functions from ncurses and SYSV curses such as colour, "
"alternative character set support, pads, and mouse support. This means the "
"module isn't compatible with operating systems that only have BSD curses, "
"but there don't seem to be any currently maintained OSes that fall into this"
" category."
msgstr ":mod:`curses` モジュールは基本的な curses の機能や、色付きの表示、別の文字集合サポート、パッド、マウスサポートなどの ncurses や SYSV curses の多くの機能をサポートしています。このことは、モジュールが BSD curses だけしか持っていない OS とは互換性が無いことを意味しますが、現在メンテナンスされている OS でそういう類のものは無さそうです。"

#: ../../faq/library.rst:107
msgid ""
"For Windows: use `the consolelib module <http://effbot.org/zone/console-"
"index.htm>`_."
msgstr "Windows では: `the consolelib module <http://effbot.org/zone/console-index.htm>`_ を使ってください。"

#: ../../faq/library.rst:112
msgid "Is there an equivalent to C's onexit() in Python?"
msgstr "Python には C の onexit() に相当するものはありますか？"

#: ../../faq/library.rst:114
msgid ""
"The :mod:`atexit` module provides a register function that is similar to C's"
" :c:func:`onexit`."
msgstr ":mod:`atexit` モジュールは、 C の :c:func:`onexit` と同じような関数登録を提供します。"

#: ../../faq/library.rst:119
msgid "Why don't my signal handlers work?"
msgstr "シグナルハンドラが動かないのですがなぜですか？"

#: ../../faq/library.rst:121
msgid ""
"The most common problem is that the signal handler is declared with the "
"wrong argument list.  It is called as ::"
msgstr "最もありがちな問題は、シグナルハンドラが間違った引数リストで宣言されていることです。これは次のように呼び出されます ::"

#: ../../faq/library.rst:126
msgid "so it should be declared with two arguments::"
msgstr "だから、これは二つの引数で宣言されるべきです::"

#: ../../faq/library.rst:133
msgid "Common tasks"
msgstr "よくある作業"

#: ../../faq/library.rst:136
msgid "How do I test a Python program or component?"
msgstr "Python のプログラムやコンポーネントをテストするにはどうしますか？"

#: ../../faq/library.rst:138
msgid ""
"Python comes with two testing frameworks.  The :mod:`doctest` module finds "
"examples in the docstrings for a module and runs them, comparing the output "
"with the expected output given in the docstring."
msgstr "Python には二つのテストフレームワークがついています。:mod:`doctest` モジュールは、モジュールの docstring から使用例を見つけてそれらを実行し、出力を docstring によって与えられた望まれる出力と比較します。"

#: ../../faq/library.rst:142
msgid ""
"The :mod:`unittest` module is a fancier testing framework modelled on Java "
"and Smalltalk testing frameworks."
msgstr ":mod:`unittest` モジュールは、Java や Smalltalk のテストフレームワークを模した装飾されたテストフレームワークです。"

#: ../../faq/library.rst:145
msgid ""
"To make testing easier, you should use good modular design in your program. "
"Your program should have almost all functionality encapsulated in either "
"functions or class methods -- and this sometimes has the surprising and "
"delightful effect of making the program run faster (because local variable "
"accesses are faster than global accesses).  Furthermore the program should "
"avoid depending on mutating global variables, since this makes testing much "
"more difficult to do."
msgstr "テスト作業を簡単にするために、プログラムにおいてモジュール性の良い設計を使うべきです。プログラムでは、ほぼ全ての処理を関数やクラスのメソッドで包むべきです -- こうすることで、プログラムが速くなるという驚くような愉快な効果がときおり得られることがあります (というのも、ローカル変数へのアクセスはグローバルなアクセスよりも速いからです)。さらに言うと、テストを行うのがより難しくなってしまうため、プログラムは可変なグローバル変数に依存するのを避けるべきです。"

#: ../../faq/library.rst:153
msgid "The \"global main logic\" of your program may be as simple as ::"
msgstr "プログラムの \"global main logic\" は ::"

#: ../../faq/library.rst:158
msgid "at the bottom of the main module of your program."
msgstr "のように main モジュールの最後に出来る限りシンプルなものを書くのが良いでしょう。"

#: ../../faq/library.rst:160
msgid ""
"Once your program is organized as a tractable collection of functions and "
"class behaviours you should write test functions that exercise the "
"behaviours.  A test suite that automates a sequence of tests can be "
"associated with each module. This sounds like a lot of work, but since "
"Python is so terse and flexible it's surprisingly easy.  You can make coding"
" much more pleasant and fun by writing your test functions in parallel with "
"the \"production code\", since this makes it easy to find bugs and even "
"design flaws earlier."
msgstr "プログラムが整理され、関数やクラスの動作が追いやすい状態になったら、その動作を試すテスト関数を書くべきです。一連のテストを自動化するテストスイートは、それぞれのモジュールに関連付けることができます。これは手間が掛かりそうに思えますが、Python は簡素で融通が効くので、驚くほど簡単です。\"製品コード (production code)\" と並行でテスト関数を書くことで、バグや設計の不備でさえも早い段階で簡単に見付かるようになるので、コーディング作業をより心地良く楽しいものにできます。"

#: ../../faq/library.rst:168
msgid ""
"\"Support modules\" that are not intended to be the main module of a program"
" may include a self-test of the module. ::"
msgstr "プログラムのメインモジュールとして設計されたのではない \"補助モジュール\" には、モジュールの自己テストを含めるといいでしょう。 ::"

#: ../../faq/library.rst:174
msgid ""
"Even programs that interact with complex external interfaces may be tested "
"when the external interfaces are unavailable by using \"fake\" interfaces "
"implemented in Python."
msgstr "複雑な外部インタフェースと作用し合うプログラムでさえ、外部インタフェースが使えない時でも、Python で実装された \"fake\" インタフェースを使ってテストできます。"

#: ../../faq/library.rst:180
msgid "How do I create documentation from doc strings?"
msgstr "Python のドキュメント文字列からドキュメントを生成するにはどうしますか？"

#: ../../faq/library.rst:182
msgid ""
"The :mod:`pydoc` module can create HTML from the doc strings in your Python "
"source code.  An alternative for creating API documentation purely from "
"docstrings is `epydoc <http://epydoc.sourceforge.net/>`_.  `Sphinx <http"
"://sphinx-doc.org>`_ can also include docstring content."
msgstr ":mod:`pydoc` モジュールで Python ソースコード内のドキュメント文字列から HTML を生成できます。純粋に docstring から API ドキュメントを生成するには、他に `epydoc <http://epydoc.sourceforge.net/>`_ という選択肢もあります。 `Sphinx <http://sphinx-doc.org>`_ も docstring の内容を含めることができます。"

#: ../../faq/library.rst:189
msgid "How do I get a single keypress at a time?"
msgstr "一度に一つの押鍵を取得するにはどうしますか？"

#: ../../faq/library.rst:191
msgid ""
"For Unix variants there are several solutions.  It's straightforward to do "
"this using curses, but curses is a fairly large module to learn.  Here's a "
"solution without curses::"
msgstr "Unix 系では、いくつかの方法があります。curses を使えば簡単ですが、 curses はかなり大きいモジュールなので習得するのが難しいです。ここに curses を使わない解決策を挙げます::"

#: ../../faq/library.rst:216
msgid ""
"You need the :mod:`termios` and the :mod:`fcntl` module for any of this to "
"work, and I've only tried it on Linux, though it should work elsewhere.  In "
"this code, characters are read and printed one at a time."
msgstr "これを動かすためには、:mod:`termios` と :mod:`fcntl` モジュールが必要です。また、多分他でも動きますが、Linux でしかこれを試していません。このコードでは、文字は一文字づつ読みこまれ、印字されます。"

#: ../../faq/library.rst:220
msgid ""
":func:`termios.tcsetattr` turns off stdin's echoing and disables canonical "
"mode. :func:`fcntl.fnctl` is used to obtain stdin's file descriptor flags "
"and modify them for non-blocking mode.  Since reading stdin when it is empty"
" results in an :exc:`IOError`, this error is caught and ignored."
msgstr ":func:`termios.tcsetattr` は stdin の反響を止め、標準モードを使えなくします。 :func:`fcntl.fnctl` は、stdin のファイルディスクリプタフラグを取得し、それらをノンブロッキングモードに変えるのに使われます。stdin が空の時に読み込むのは :exc:`IOError` になるので、このエラーは補足され、無視されます。"

#: ../../faq/library.rst:227
msgid "Threads"
msgstr "スレッド"

#: ../../faq/library.rst:230
msgid "How do I program using threads?"
msgstr "スレッドを使ったプログラムを書くにはどうしますか？"

#: ../../faq/library.rst:234
msgid ""
"Be sure to use the :mod:`threading` module and not the :mod:`thread` module."
" The :mod:`threading` module builds convenient abstractions on top of the "
"low-level primitives provided by the :mod:`thread` module."
msgstr ":mod:`thread` モジュールではなく、必ず :mod:`threading` モジュールを使ってください。:mod:`threading` モジュールは、:mod:`thread` モジュールで提供される低レベルな基本要素の、便利な抽象化を構成します。"

#: ../../faq/library.rst:238
msgid ""
"Aahz has a set of slides from his threading tutorial that are helpful; see "
"http://www.pythoncraft.com/OSCON2001/."
msgstr "Aahz は、役立つスレッディングのチュートリアルから成るスライドを揃えています。 http://www.pythoncraft.com/OSCON2001/ を参照してください。"

#: ../../faq/library.rst:243
msgid "None of my threads seem to run: why?"
msgstr "スレッドが一つも実行されていないようです。なぜですか？"

#: ../../faq/library.rst:245
msgid ""
"As soon as the main thread exits, all threads are killed.  Your main thread "
"is running too quickly, giving the threads no time to do any work."
msgstr "メインスレッドが終了するとともに、全てのスレッドは終了されます。メインスレッドは速く働きすぎるので、スレッドには何をする時間も与えられません。"

#: ../../faq/library.rst:248
msgid ""
"A simple fix is to add a sleep to the end of the program that's long enough "
"for all the threads to finish::"
msgstr "簡単な解決策は、プログラムの終わりに、スレッドが完了するのに十分な時間のスリープを加えることです::"

#: ../../faq/library.rst:262
msgid ""
"But now (on many platforms) the threads don't run in parallel, but appear to"
" run sequentially, one at a time!  The reason is that the OS thread "
"scheduler doesn't start a new thread until the previous thread is blocked."
msgstr "しかし、実際は (ほとんどのプラットフォームでは) スレッドは並行して実行されるのではなく、一つづつ実行されるのです！なぜなら、OS のスレッドスケジューラは、前のスレッドがブロックされるまで新しいスレッドを開始しないからです。"

#: ../../faq/library.rst:266
msgid "A simple fix is to add a tiny sleep to the start of the run function::"
msgstr "簡単に直すには、関数の実行の最初にちょっとスリープを加えることです::"

#: ../../faq/library.rst:278
msgid ""
"Instead of trying to guess a good delay value for :func:`time.sleep`, it's "
"better to use some kind of semaphore mechanism.  One idea is to use the "
":mod:`Queue` module to create a queue object, let each thread append a token"
" to the queue when it finishes, and let the main thread read as many tokens "
"from the queue as there are threads."
msgstr ":func:`time.sleep` による遅延をどれくらいとれば十分かを考えるより、セマフォ構造を使ったほうがいいです。一つのやり方は、 :mod:`Queue` モジュールでキューオブジェクトを作り、それぞれのスレッドが終了するごとにキューにトークンを加えさせ、メインスレッドにスレッドがあるのと同じ数のトークンをキューから読み込ませるようにすることです。"

#: ../../faq/library.rst:286
msgid "How do I parcel out work among a bunch of worker threads?"
msgstr "たくさんのワーカースレッドに作業を割り振るにはどうしますか？"

#: ../../faq/library.rst:288
msgid ""
"Use the :mod:`Queue` module to create a queue containing a list of jobs.  "
"The :class:`~Queue.Queue` class maintains a list of objects and has a "
"``.put(obj)`` method that adds items to the queue and a ``.get()`` method to"
" return them. The class will take care of the locking necessary to ensure "
"that each job is handed out exactly once."
msgstr ":class:`Queue` モジュールで、作業のリストを含むキューを作ってください。:class:`~Queue.Queue` クラスはオブジェクトのリストを保持し、 ``.put(obj)`` で要素を加え、``.get()`` で要素を返すことができます。ロッキングを引き受けるクラスは、全ての作業がちょうど一回づつ行われることを確実にしなければなりません。"

#: ../../faq/library.rst:294
msgid "Here's a trivial example::"
msgstr "ここにちょっとした例があります::"

#: ../../faq/library.rst:332
msgid "When run, this will produce the following output:"
msgstr "実行時には、以下のように出力されます:"

#: ../../faq/library.rst:350
msgid ""
"Consult the module's documentation for more details; the "
":class:`~Queue.Queue` class provides a featureful interface."
msgstr "詳細はモジュールのドキュメントを参照してください。 :class:`~Queue.Queue` クラスで多機能なインタフェースを使えます。"

#: ../../faq/library.rst:355
msgid "What kinds of global value mutation are thread-safe?"
msgstr "グローバルな値のどんな種類の変更がスレッドセーフになるのですか？"

#: ../../faq/library.rst:357
msgid ""
"A :term:`global interpreter lock` (GIL) is used internally to ensure that "
"only one thread runs in the Python VM at a time.  In general, Python offers "
"to switch among threads only between bytecode instructions; how frequently "
"it switches can be set via :func:`sys.setcheckinterval`.  Each bytecode "
"instruction and therefore all the C implementation code reached from each "
"instruction is therefore atomic from the point of view of a Python program."
msgstr "グローバルインタプリタロック (:term:`GIL`) が内部で使われ、Python VM で一度に一つだけのスレッドが実行されることが保証されています。一般に、Python ではスレッド間の切り替えをバイトコード命令の間でのみ行います。切り替えの周期は、 :func:`sys.setcheckinterval` で設定できます。したがって、それぞれのバイトコード命令、そしてそれぞれの命令が届く全ての C 実装コードは、 Python プログラムの観点からは、アトミックです。"

#: ../../faq/library.rst:364
msgid ""
"In theory, this means an exact accounting requires an exact understanding of"
" the PVM bytecode implementation.  In practice, it means that operations on "
"shared variables of built-in data types (ints, lists, dicts, etc) that "
"\"look atomic\" really are."
msgstr "このことから、理論上は、正確な勘定のためには PVM バイトコードの実装を理解することが必要です。実際上は、組み込みデータ型(整数、リスト、辞書、等)の、変数を共有する\"アトミックそうな\"演算は、実際にアトミックです。"

#: ../../faq/library.rst:369
msgid ""
"For example, the following operations are all atomic (L, L1, L2 are lists, "
"D, D1, D2 are dicts, x, y are objects, i, j are ints)::"
msgstr "例えば、以下の演算は全てアトミックです (L、L1、L2 はリスト、 D、D1、D2 は辞書、x、y はオブジェクト、i、j は整数です)::"

#: ../../faq/library.rst:384
msgid "These aren't::"
msgstr "これらは、アトミックではありません::"

#: ../../faq/library.rst:391
msgid ""
"Operations that replace other objects may invoke those other objects' "
":meth:`__del__` method when their reference count reaches zero, and that can"
" affect things.  This is especially true for the mass updates to "
"dictionaries and lists.  When in doubt, use a mutex!"
msgstr "他のオブジェクトを置き換えるような演算は、そのオブジェクトの参照カウントがゼロになったときに :meth:`__del__` メソッドを呼び出すことがあり、これが影響を及ぼすかもしれません。これは特に、辞書やリストの大規模な更新に当てはまります。疑わしければ、mutex を使ってください！"

#: ../../faq/library.rst:398
msgid "Can't we get rid of the Global Interpreter Lock?"
msgstr "グローバルインタプリタロック (Global Interpreter Lock) を取り除くことはできないのですか？"

#: ../../faq/library.rst:403
msgid ""
"The :term:`global interpreter lock` (GIL) is often seen as a hindrance to "
"Python's deployment on high-end multiprocessor server machines, because a "
"multi-threaded Python program effectively only uses one CPU, due to the "
"insistence that (almost) all Python code can only run while the GIL is held."
msgstr "マルチスレッド Python プログラムは事実上一つの CPU しか使えず、 (ほとんど) 全ての Python コードがグローバルインタプリタロック (:term:`GIL`) が保持されている間しか作動しなくなるということで、GIL は、 Python をハイエンドなマルチプロセッササーバマシン上に配備する上で邪魔であると見なされがちです。"

#: ../../faq/library.rst:408
msgid ""
"Back in the days of Python 1.5, Greg Stein actually implemented a "
"comprehensive patch set (the \"free threading\" patches) that removed the "
"GIL and replaced it with fine-grained locking.  Unfortunately, even on "
"Windows (where locks are very efficient) this ran ordinary Python code about"
" twice as slow as the interpreter using the GIL.  On Linux the performance "
"loss was even worse because pthread locks aren't as efficient."
msgstr "Python 1.5 の時代に、Greg Stein は GIL をきめ細かいロッキングで置き換える総合パッチ (\"free threading\" パッチ) セットを実装しました。残念ながら、(ロックがとても効率的な) Windows でさえ、標準的な Python コードが、GIL を使ったインタプリタの 2 倍くらい遅くなりました。 Linux では、pthread ロックが効率的でないので、パフォーマンスの損失が更に酷いです。"

#: ../../faq/library.rst:415
msgid ""
"Since then, the idea of getting rid of the GIL has occasionally come up but "
"nobody has found a way to deal with the expected slowdown, and users who "
"don't use threads would not be happy if their code ran at half the speed.  "
"Greg's free threading patch set has not been kept up-to-date for later "
"Python versions."
msgstr "その後、GIL を取り除くという案はたまに出てきますが、だれも予期される減速に対処する方法を見つけられず、スレッドを使わないユーザはこーどが半分の速度でしか動作しないのでは幸せではありません。Greg の free threading パッチは、以降の Python バージョンには更新されていません。"

#: ../../faq/library.rst:420
msgid ""
"This doesn't mean that you can't make good use of Python on multi-CPU "
"machines! You just have to be creative with dividing the work up between "
"multiple *processes* rather than multiple *threads*.  Judicious use of C "
"extensions will also help; if you use a C extension to perform a time-"
"consuming task, the extension can release the GIL while the thread of "
"execution is in the C code and allow other threads to get some work done."
msgstr "これは、Python をマルチ CPU マシンで使いこなせないことを意味しません！作業を複数の *スレッド* ではなく、複数の *プロセッサ* に分けることを考えればいいのです。 C 拡張をうまく使うことも役に立ちます。C 拡張を使ってに時間のかかる作業を行わせれば、その実行のスレッドが C のコードにある間その拡張は GIL を解放でき、他のスレッドに作業させることができます。"

#: ../../faq/library.rst:427
msgid ""
"It has been suggested that the GIL should be a per-interpreter-state lock "
"rather than truly global; interpreters then wouldn't be able to share "
"objects. Unfortunately, this isn't likely to happen either.  It would be a "
"tremendous amount of work, because many object implementations currently "
"have global state. For example, small integers and short strings are cached;"
" these caches would have to be moved to the interpreter state.  Other object"
" types have their own free list; these free lists would have to be moved to "
"the interpreter state. And so on."
msgstr "GIL を本当にグローバルにするより、インタプリタ状態ごとのロックにするべきという提案もあります。そして、インタプリタはオブジェクトを共有するべきではないということです。残念ながら、どちらも実現しないでしょう。多くのオブジェクトの実装は現在、グローバル状態を持っているので、実現はたいへんな大仕事になりそうです。例えば、小さな整数と短い文字列はキャッシュされます。このキャッシュはインタプリタ状態に動かされなくてはなりません。他のオブジェクト型は自身の自由変数リストを持っています。これらの自由変数リストはインタプリタ状態に動かされなくてはなりません。等々。"

#: ../../faq/library.rst:436
msgid ""
"And I doubt that it can even be done in finite time, because the same "
"problem exists for 3rd party extensions.  It is likely that 3rd party "
"extensions are being written at a faster rate than you can convert them to "
"store all their global state in the interpreter state."
msgstr "それどころか、その作業が終わる時が来るかもわかりません。なぜなら、サードパーティ拡張にも問題があるからです。サードパーティ拡張が書かれるペースは、インタプリタ状態にすべてのグローバル状態を格納するように変換できるペースよりも速いことでしょう。"

#: ../../faq/library.rst:441
msgid ""
"And finally, once you have multiple interpreters not sharing any state, what"
" have you gained over running each interpreter in a separate process?"
msgstr "そして最後に、一旦複数のインタプリタを状態を全く共有しないようにしたとして、それぞれのインタプリタを独立したプロセス上で動かしてなにが得られるというのでしょうか？"

#: ../../faq/library.rst:446
msgid "Input and Output"
msgstr "入力と出力"

#: ../../faq/library.rst:449
msgid "How do I delete a file? (And other file questions...)"
msgstr "ファイルを削除するにはどうしますか？ (その他、ファイルに関する質問...)"

#: ../../faq/library.rst:451
msgid ""
"Use ``os.remove(filename)`` or ``os.unlink(filename)``; for documentation, "
"see the :mod:`os` module.  The two functions are identical; :func:`unlink` "
"is simply the name of the Unix system call for this function."
msgstr "``os.remove(filename)`` または ``os.unlink(filename)`` を使ってください。ドキュメントは、:mod:`os` モジュールを参照してください。この二つの関数は同じものです。:func:`unlink` は単に、この関数の Unix システムコールの名称です。"

#: ../../faq/library.rst:455
msgid ""
"To remove a directory, use :func:`os.rmdir`; use :func:`os.mkdir` to create "
"one. ``os.makedirs(path)`` will create any intermediate directories in "
"``path`` that don't exist. ``os.removedirs(path)`` will remove intermediate "
"directories as long as they're empty; if you want to delete an entire "
"directory tree and its contents, use :func:`shutil.rmtree`."
msgstr "ディレクトリを削除するには、:func:`os.rmdir` を使ってください。作成には :func:`os.mkdir` を使ってください。``os.makedirs(path)`` は ``path`` の中間のディレクトリの、存在しないものを作成します。``os.removedirs(path)`` は中間のディレクトリが空である限り、それらを削除します。ディレクトリツリー全体とその中身全てを削除したいなら、:func:`shutil.rmtree` を使ってください。"

#: ../../faq/library.rst:461
msgid "To rename a file, use ``os.rename(old_path, new_path)``."
msgstr "ファイルの名前を変更するには、``os.rename(old_path, new_path)`` を使ってください。"

#: ../../faq/library.rst:463
msgid ""
"To truncate a file, open it using ``f = open(filename, \"r+\")``, and use "
"``f.truncate(offset)``; offset defaults to the current seek position.  "
"There's also ``os.ftruncate(fd, offset)`` for files opened with "
":func:`os.open`, where *fd* is the file descriptor (a small integer)."
msgstr "ファイルを切り詰めるには、``f = open(filename, \"r+\")`` でファイルを開いてから、 ``f.truncate(offset)`` を使ってください。offset はデフォルトでは現在のシーク位置です。:func:`os.open` で開かれたファイルのために、 ``os.ftruncate(fd, offset)`` もあります。 *fd* はファイルディスクリプタ (小さな整数) です。"

#: ../../faq/library.rst:468
msgid ""
"The :mod:`shutil` module also contains a number of functions to work on "
"files including :func:`~shutil.copyfile`, :func:`~shutil.copytree`, and "
":func:`~shutil.rmtree`."
msgstr ":mod:`shutil` モジュールにも、:func:`~shutil.copyfile`、 :func:`~shutil.copytree`、:func:`~shutil.rmtree` 等、ファイルに作用する関数がいくつか含まれます。"

#: ../../faq/library.rst:474
msgid "How do I copy a file?"
msgstr "ファイルをコピーするにはどうしますか？"

#: ../../faq/library.rst:476
msgid ""
"The :mod:`shutil` module contains a :func:`~shutil.copyfile` function.  Note"
" that on MacOS 9 it doesn't copy the resource fork and Finder info."
msgstr ":mod:`shutil` モジュールには :func:`~shutil.copyfile` 関数があります。なお、MacOS 9 ではリソースフォークやファインダー情報をコピーしません。"

#: ../../faq/library.rst:481
msgid "How do I read (or write) binary data?"
msgstr "バイナリデータを読み書きするにはどうしますか？"

#: ../../faq/library.rst:483
msgid ""
"To read or write complex binary data formats, it's best to use the "
":mod:`struct` module.  It allows you to take a string containing binary data"
" (usually numbers) and convert it to Python objects; and vice versa."
msgstr "複雑なバイナリデータ形式の読み書きには、:mod:`struct` モジュールを使うのが一番です。これでバイナリデータ (通常は数) を含む文字列を取って、 Python オブジェクトに変換することができますし、その逆もできます。"

#: ../../faq/library.rst:487
msgid ""
"For example, the following code reads two 2-byte integers and one 4-byte "
"integer in big-endian format from a file::"
msgstr "例えば、以下のコードはファイルから 2 バイトの整数 2 個と 4 バイトの整数 1 個をビッグエンディアンフォーマットで読み込みます::"

#: ../../faq/library.rst:496
msgid ""
"The '>' in the format string forces big-endian data; the letter 'h' reads "
"one \"short integer\" (2 bytes), and 'l' reads one \"long integer\" (4 "
"bytes) from the string."
msgstr "フォーマット中の '>' はデータを強制的にビッグエンディアンにします。ファイルから、文字 'h' は一つの\"整数\"(2 バイト)を読み込み、文字 'l' は一つの\"long 整数\"を読み込みます。"

#: ../../faq/library.rst:500
msgid ""
"For data that is more regular (e.g. a homogeneous list of ints or floats), "
"you can also use the :mod:`array` module."
msgstr "より規則的なデータ (例えば、整数や浮動小数点数の中身の型が揃ったリスト) に対しては、 :mod:`array` モジュールを使うこともできます。"

#: ../../faq/library.rst:505
msgid "I can't seem to use os.read() on a pipe created with os.popen(); why?"
msgstr "os.popen() によって作られたパイプで os.read() が使われていないようです。なぜですか？"

#: ../../faq/library.rst:507
msgid ""
":func:`os.read` is a low-level function which takes a file descriptor, a "
"small integer representing the opened file.  :func:`os.popen` creates a "
"high-level file object, the same type returned by the built-in :func:`open` "
"function. Thus, to read *n* bytes from a pipe *p* created with "
":func:`os.popen`, you need to use ``p.read(n)``."
msgstr ":func:`os.read` は、開かれたファイルを表す小さな整数、ファイルディスクリプタを引数に取る、低レベルの関数です。 :func:`os.popen` は、組み込みの :func:`open` 関数の返り値と同じ型の、高レベルなファイルオブジェクトを作成します。従って、 :func:`os.popen` によって作成されたパイプ *p* から *n* バイト分だけ読み取るには、 ``p.read(n)`` を使う必要があります。"

#: ../../faq/library.rst:515
msgid ""
"How do I run a subprocess with pipes connected to both input and output?"
msgstr "パイプを入力と出力の両方に接続してサブプロセスを動かすにはどうしますか？"

#: ../../faq/library.rst:519
msgid "Use the :mod:`popen2` module.  For example::"
msgstr ":mod:`popen2` モジュールを使ってください。例えば::"

#: ../../faq/library.rst:527
msgid ""
"Warning: in general it is unwise to do this because you can easily cause a "
"deadlock where your process is blocked waiting for output from the child "
"while the child is blocked waiting for input from you.  This can be caused "
"by the parent expecting the child to output more text than it does or by "
"data being stuck in stdio buffers due to lack of flushing.  The Python "
"parent can of course explicitly flush the data it sends to the child before "
"it reads any output, but if the child is a naive C program it may have been "
"written to never explicitly flush its output, even if it is interactive, "
"since flushing is normally automatic."
msgstr "警告: 一般的に、これをするのは賢くありません。子があなたからの入力を待ってブロックされている間、プロセスが子からの入力を待ってブロックされているというようなデッドロックを引き起こしやすいからです。これは、親が子がそれよりも多くのテキストを出力することを期待することにより、あるいはデータが書きださされないことで標準入出力バッファがスタックにあることにより起こります。Python の親はもちろん子に送るデータを出力を読み込む前に明示的に書きだすことができますが、子が素朴な C プログラムであると、それが対話的なものであってさえ、書き出しが通常自動的なものであるがゆえ、明示的に出力を書き出さないように書かれていることがあります。"

#: ../../faq/library.rst:537
msgid ""
"Note that a deadlock is also possible if you use :func:`popen3` to read "
"stdout and stderr. If one of the two is too large for the internal buffer "
"(increasing the buffer size does not help) and you ``read()`` the other one "
"first, there is a deadlock, too."
msgstr "なお、デッドロックは :func:`popen3` を使って標準出力や標準エラー出力を読み込むときにも起こりえます。これらのどちらかが内部バッファにとって大きすぎる (バッファサイズを増やしても役に立ちません) とき、もう片方を先に ``read()`` すると、同じくデッドロックが起こります。"

#: ../../faq/library.rst:542
msgid ""
"Note on a bug in popen2: unless your program calls ``wait()`` or "
"``waitpid()``, finished child processes are never removed, and eventually "
"calls to popen2 will fail because of a limit on the number of child "
"processes.  Calling :func:`os.waitpid` with the :data:`os.WNOHANG` option "
"can prevent this; a good place to insert such a call would be before calling"
" ``popen2`` again."
msgstr "popen2 におけるバグの注釈: プログラムが ``wait()`` や ``waitpid()`` を呼び出さないかぎり、終了されていない子プロセスは取り除かれることがなく、いずれ popen2 を呼び出すときに、子プロセス数の制限のために失敗することがあります。:func:`os.waitpid` を :data:`os.WNOHANG` オプションをつけて呼び出すことで、これを防げます。このような呼び出しをする場所は、 ``popen2`` を再び呼びだす前がいいです。"

#: ../../faq/library.rst:548
msgid ""
"In many cases, all you really need is to run some data through a command and"
" get the result back.  Unless the amount of data is very large, the easiest "
"way to do this is to write it to a temporary file and run the command with "
"that temporary file as input.  The standard module :mod:`tempfile` exports a"
" :func:`~tempfile.mktemp` function to generate unique temporary file names. "
"::"
msgstr "多くの場合、本当にやるべきことは、コマンドを通して少しのデータを実行し、結果を戻させることだけです。データの量がとても多いのでない限り、最も簡単な方法は、それを一時ファイルに書きこみ、一時ファイルと入力としてコマンドを実行することです。標準モジュール :mod:`tempfile` は、一意の一時ファイル名を生成する :func:`~tempfile.mktemp` 関数をエクスポートします::"

#: ../../faq/library.rst:583
msgid ""
"Note that many interactive programs (e.g. vi) don't work well with pipes "
"substituted for standard input and output.  You will have to use pseudo ttys"
" (\"ptys\") instead of pipes. Or you can use a Python interface to Don "
"Libes' \"expect\" library.  A Python extension that interfaces to expect is "
"called \"expy\" and available from http://expectpy.sourceforge.net.  A pure "
"Python solution that works like expect is `pexpect "
"<https://pypi.python.org/pypi/pexpect/>`_."
msgstr "なお、多くの対話的プログラム (vi など) は、パイプで標準入出力を置き換えることがうまくいきません。このようなときは、パイプの代わりに擬似 tty (\"pty\") を使わなければなりません。または、Don Libes の \"expect\" ライブラリへの Python インタフェースを使うこともできます。expect へのインタフェースをする Python 拡張は \"expy\" と呼ばれ、 http://expectpy.sourceforge.net から利用できます。expect のように働く pure Python な解決法は、 `pexpect <https://pypi.python.org/pypi/pexpect/>`_ です。"

#: ../../faq/library.rst:592
msgid "How do I access the serial (RS232) port?"
msgstr "シリアル (RS232) ポートにアクセスするにはどうしますか？"

#: ../../faq/library.rst:594
msgid "For Win32, POSIX (Linux, BSD, etc.), Jython:"
msgstr "Win32、POSIX (Linux、BSD、など)、Jythonでは:"

#: ../../faq/library.rst:596
msgid "http://pyserial.sourceforge.net"
msgstr "http://pyserial.sourceforge.net"

#: ../../faq/library.rst:598
msgid "For Unix, see a Usenet post by Mitch Chapman:"
msgstr "Unix では、Mitch Chapman による Usenet の投稿を参照してください:"

#: ../../faq/library.rst:600
msgid "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"
msgstr "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"

#: ../../faq/library.rst:604
msgid "Why doesn't closing sys.stdout (stdin, stderr) really close it?"
msgstr "sys.stdout (stdin, stderr) を閉じようとしても実際に閉じられないのはなぜですか？"

#: ../../faq/library.rst:606
msgid ""
"Python file objects are a high-level layer of abstraction on top of C "
"streams, which in turn are a medium-level layer of abstraction on top of "
"(among other things) low-level C file descriptors."
msgstr "Python のファイルオブジェクトは、 (ここで説明する中では) 低レベルな C ファイルディスクリプタの上にある、中レベルな抽象のレイヤである C ストリームのそのまた上にある、高レベルな抽象のレイヤです。"

#: ../../faq/library.rst:610
msgid ""
"For most file objects you create in Python via the built-in ``file`` "
"constructor, ``f.close()`` marks the Python file object as being closed from"
" Python's point of view, and also arranges to close the underlying C stream."
" This also happens automatically in ``f``'s destructor, when ``f`` becomes "
"garbage."
msgstr "組み込みの ``open`` 関数によって生成されたほとんどのファイルオブジェクトでは、``f.close()`` は Python ファイルオブジェクトが Python の視点からは閉じられているものとする印をつけ、その下にある C ファイルディスクリプタを閉じるように手配します。これは、``f`` がガベージとなったときにも、``f`` のデストラクタで自動的に起こります。"

#: ../../faq/library.rst:616
msgid ""
"But stdin, stdout and stderr are treated specially by Python, because of the"
" special status also given to them by C.  Running ``sys.stdout.close()`` "
"marks the Python-level file object as being closed, but does *not* close the"
" associated C stream."
msgstr "しかし、stdin、stdout、stderr は C で特別な立場が与えられていることから、 Python でも同様に特別に扱われます。``sys.stdout.close()`` を実行すると、 Python レベルのファイルオブジェクトには閉じられているものとする印がつけられますが、C ファイルディスクリプタは *閉じられません*。"

#: ../../faq/library.rst:621
msgid ""
"To close the underlying C stream for one of these three, you should first be"
" sure that's what you really want to do (e.g., you may confuse extension "
"modules trying to do I/O).  If it is, use os.close::"
msgstr "下にある C ファイルディスクリプタのうち、この三つのどれかを閉じるには、まず本当に閉じる必要があることを確かめるべきです (例えば、拡張モジュールの I/O を混乱させてしまうかもしれません)。本当に必要ならば、 ``os.close`` を使ってください::"

#: ../../faq/library.rst:631
msgid "Network/Internet Programming"
msgstr "ネットワーク/インターネットプログラミング"

#: ../../faq/library.rst:634
msgid "What WWW tools are there for Python?"
msgstr "Python の WWW ツールには何がありますか？"

#: ../../faq/library.rst:636
msgid ""
"See the chapters titled :ref:`internet` and :ref:`netdata` in the Library "
"Reference Manual.  Python has many modules that will help you build server-"
"side and client-side web systems."
msgstr "ライブラリリファレンスマニュアルの :ref:`internet` と :ref:`netdata` という章を参照してください。Python には、サーバーサイドとクライアントサイドの web システムを構築するのに便利な多くのモジュールがあります。"

#: ../../faq/library.rst:642
msgid ""
"A summary of available frameworks is maintained by Paul Boddie at "
"https://wiki.python.org/moin/WebProgramming\\ ."
msgstr "利用可能なフレームワークの概要は Paul Boddie によって、https://wiki.python.org/moin/WebProgramming でメンテナンスされています。"

#: ../../faq/library.rst:645
msgid ""
"Cameron Laird maintains a useful set of pages about Python web technologies "
"at http://phaseit.net/claird/comp.lang.python/web_python."
msgstr "Cameron Laird は、http://phaseit.net/claird/comp.lang.python/web_python で Python のウェブ技術に関する便利なページ群を整備しています。"

#: ../../faq/library.rst:650
msgid "How can I mimic CGI form submission (METHOD=POST)?"
msgstr "CGI フォームの発信 (METHOD=POST) を模倣するにはどうしますか？"

#: ../../faq/library.rst:652
msgid ""
"I would like to retrieve web pages that are the result of POSTing a form. Is"
" there existing code that would let me do this easily?"
msgstr "フォームを POST した結果のウェブページを取得したいです。簡単に取得するためのコードはあるでしょうか？"

#: ../../faq/library.rst:655
msgid "Yes. Here's a simple example that uses httplib::"
msgstr "あります。これは urllib.request を利用した簡単な例です::"

#: ../../faq/library.rst:679
msgid ""
"Note that in general for percent-encoded POST operations, query strings must"
" be quoted using :func:`urllib.urlencode`.  For example, to send ``name=Guy "
"Steele, Jr.``::"
msgstr "なお、一般にパーセントエンコードされた POST 演算では、クエリ文字列は必ず :func:`urllib.urlencode` で引用されなくてはなりません。例えば name ``Guy Steele, Jr.`` を送信するには::"

#: ../../faq/library.rst:689
msgid "What module should I use to help with generating HTML?"
msgstr "どのモジュールが HTML の生成の役に立ちますか？"

#: ../../faq/library.rst:693
msgid ""
"You can find a collection of useful links on the `Web Programming wiki page "
"<https://wiki.python.org/moin/WebProgramming>`_."
msgstr "`Web Programming についての wiki のページ <https://wiki.python.org/moin/WebProgramming>`_ から役に立つリンクが見付けられます。"

#: ../../faq/library.rst:698
msgid "How do I send mail from a Python script?"
msgstr "Python のスクリプトからメールを送るにはどうしますか？"

#: ../../faq/library.rst:700
msgid "Use the standard library module :mod:`smtplib`."
msgstr "標準ライブラリモジュール :mod:`smtplib` を使ってください。"

#: ../../faq/library.rst:702
msgid ""
"Here's a very simple interactive mail sender that uses it.  This method will"
" work on any host that supports an SMTP listener. ::"
msgstr "以下に示すのが、これを使ったごく単純な対話型のメール送信器です。このメソッドは SMTP リスナをサポートするホストならどこででも作動します。 ::"

#: ../../faq/library.rst:722
msgid ""
"A Unix-only alternative uses sendmail.  The location of the sendmail program"
" varies between systems; sometimes it is ``/usr/lib/sendmail``, sometimes "
"``/usr/sbin/sendmail``.  The sendmail manual page will help you out.  Here's"
" some sample code::"
msgstr "Unix 限定の代わりの選択肢は sendmail を使うことです。sendmail プログラムの場所はシステムによって様々です; あるときは ``/usr/lib/sendmail`` だったり、あるときは ``/usr/sbin/sendmail`` だったり。sendmail のマニュアルページが助けになるでしょう。サンプルコードはこのようになります::"

#: ../../faq/library.rst:742
msgid "How do I avoid blocking in the connect() method of a socket?"
msgstr "ソケットの connect() メソッドでブロッキングされなくするにはどうしますか？"

#: ../../faq/library.rst:744
msgid ""
"The select module is commonly used to help with asynchronous I/O on sockets."
msgstr "主に select モジュールがソケットの非同期の I/O を扱うのに使われます。"

#: ../../faq/library.rst:746
msgid ""
"To prevent the TCP connect from blocking, you can set the socket to non-"
"blocking mode.  Then when you do the ``connect()``, you will either connect "
"immediately (unlikely) or get an exception that contains the error number as"
" ``.errno``. ``errno.EINPROGRESS`` indicates that the connection is in "
"progress, but hasn't finished yet.  Different OSes will return different "
"values, so you're going to have to check what's returned on your system."
msgstr "TCP 接続がブロッキングされないようにするために、ソケットをノンブロッキングモードに設定することが出来ます。そして ``connect()`` したときに、即座に接続できるか、エラー番号を ``.errno`` として含む例外を受け取るかのどちらかになります。``errno.EINPROGRESS`` は、接続が進行中であるが、まだ完了していないということを示します。異なる OS では異なる値が返されるので、あなたのシステムで何が返されるかを確かめておく必要があります。"

#: ../../faq/library.rst:753
msgid ""
"You can use the ``connect_ex()`` method to avoid creating an exception.  It "
"will just return the errno value.  To poll, you can call ``connect_ex()`` "
"again later -- 0 or ``errno.EISCONN`` indicate that you're connected -- or "
"you can pass this socket to select to check if it's writable."
msgstr "``connect_ex()`` メソッドを使えば例外を生成しなくて済みます。これは単に errno の値を返すでしょう。ポーリングのためには、後でまた ``connect_ex()`` を呼び出すことができます -- 0 または ``errno.EISCONN`` は接続されたことを表します -- または、選択するソケットにこれを渡して書き込み可能か調べることができます。"

#: ../../faq/library.rst:760
msgid "Databases"
msgstr "データベース"

#: ../../faq/library.rst:763
msgid "Are there any interfaces to database packages in Python?"
msgstr "Python にはデータベースパッケージへのインタフェースはありますか？"

#: ../../faq/library.rst:765
msgid "Yes."
msgstr "はい。"

#: ../../faq/library.rst:769
msgid ""
"Python 2.3 includes the :mod:`bsddb` package which provides an interface to "
"the BerkeleyDB library.  Interfaces to disk-based hashes such as :mod:`DBM "
"<dbm>` and :mod:`GDBM <gdbm>` are also included with standard Python."
msgstr ":mod:`DBM <dbm.ndbm>` や :mod:`GDBM <dbm.gnu>` のような、ディスクに基づくハッシュへのインタフェースも標準の Python に含まれています。ディスクに基づく軽量なリレーショナルデータベースを提供する :mod:`sqlite3` モジュールもあります。"

#: ../../faq/library.rst:773
msgid ""
"Support for most relational databases is available.  See the "
"`DatabaseProgramming wiki page "
"<https://wiki.python.org/moin/DatabaseProgramming>`_ for details."
msgstr "ほとんどの相対データベースがサポートされています。詳細は `DatabaseProgramming wiki page <https://wiki.python.org/moin/DatabaseProgramming>`_ を参照してください。"

#: ../../faq/library.rst:779
msgid "How do you implement persistent objects in Python?"
msgstr "Python で永続的なオブジェクトを実装するにはどうしますか？"

#: ../../faq/library.rst:781
msgid ""
"The :mod:`pickle` library module solves this in a very general way (though "
"you still can't store things like open files, sockets or windows), and the "
":mod:`shelve` library module uses pickle and (g)dbm to create persistent "
"mappings containing arbitrary Python objects.  For better performance, you "
"can use the :mod:`cPickle` module."
msgstr ":mod:`pickle` ライブラリモジュールで、ごく一般的な方法でこれを解決できます (開かれたファイル、ソケット、ウィンドウのようなものを保管することはできませんが)。:mod:`shelve` ライブラリモジュールは pickle と (g)dbm を使い、任意の Python オブジェクトを含む永続的なマッピングを生成します。パフォーマンスを良くするために、:mod:`cPickle` モジュールを使うこともできます。"

#: ../../faq/library.rst:787
msgid ""
"A more awkward way of doing things is to use pickle's little sister, "
"marshal. The :mod:`marshal` module provides very fast ways to store "
"noncircular basic Python types to files and strings, and back again.  "
"Although marshal does not do fancy things like store instances or handle "
"shared references properly, it does run extremely fast.  For example, "
"loading a half megabyte of data may take less than a third of a second.  "
"This often beats doing something more complex and general such as using gdbm"
" with pickle/shelve."
msgstr "もっと不器用な方法は、pickle の妹分である marshal を使うことです。 :mod:`marshal` モジュールは、再帰的でない標準の Python 型を、ファイルや文字列にとても高速に保存したり、元に戻したりする方法を提供します。 marshal では、インスタンスの保存や共有される参照の適切な処理などの派手なことはできませんが、極端に速く動作します。例えば、半メガバイトのデータに 3 分の 1 秒も掛からないでしょう。これは多くの場合、 pickle/shelve で gdbm を使うというような、複雑な一般の方法に勝ります。"

#: ../../faq/library.rst:797
msgid "Why is cPickle so slow?"
msgstr "なぜ cPickle はこんなに遅いのですか？"

#: ../../faq/library.rst:801
msgid ""
"By default :mod:`pickle` uses a relatively old and slow format for backward "
"compatibility.  You can however specify other protocol versions that are "
"faster::"
msgstr ":mod:`pickle` モジュールは後方互換性のために、ちょっと古くて遅いフォーマットをデフォルトで使います。ですが速いほかのプロトコルバージョンを指定出来ます::"

#: ../../faq/library.rst:810
msgid ""
"If my program crashes with a bsddb (or anydbm) database open, it gets "
"corrupted. How come?"
msgstr "bsddb (or anydbm) データベースが開かれたままプログラムがクラッシュすると、だめになってしまいます。なぜですか？"

#: ../../faq/library.rst:812
msgid ""
"Databases opened for write access with the bsddb module (and often by the "
"anydbm module, since it will preferentially use bsddb) must explicitly be "
"closed using the ``.close()`` method of the database.  The underlying "
"library caches database contents which need to be converted to on-disk form "
"and written."
msgstr "bsddb モジュール (やしばしば anydbm モジュール。優先的に bsddb を使うでしょうから) で書き込みのために開かれたデータベースは、データベースの ``.close()`` メソッドで明示的に閉じられなければなりません。その基礎にあるライブラリは、ディスク上の形式に変換されて書き込まれるべきデータベースの中身を、キャッシュします。"

#: ../../faq/library.rst:817
msgid ""
"If you have initialized a new bsddb database but not written anything to it "
"before the program crashes, you will often wind up with a zero-length file "
"and encounter an exception the next time the file is opened."
msgstr "新しい bsddb データベースを初期化したけれどプログラムのクラッシュ時までに何も書き込まれていないとき、長さ 0 のファイルで終わることになり、次にそのファイルが開かれたときに例外に出くわすでしょう。"

#: ../../faq/library.rst:823
msgid ""
"I tried to open Berkeley DB file, but bsddb produces bsddb.error: (22, "
"'Invalid argument'). Help! How can I restore my data?"
msgstr "Berkeley DB ファイルを開こうとしましたが、bsddb が bsddb.error: (22, 'Invalid argument') を生じます。助けてください！データを復元するにはどうしたら良いですか？"

#: ../../faq/library.rst:825
msgid ""
"Don't panic! Your data is probably intact. The most frequent cause for the "
"error is that you tried to open an earlier Berkeley DB file with a later "
"version of the Berkeley DB library."
msgstr "慌てないでください！あなたのデータはおそらく無事です。このエラーの一番ありがちな原因は、新しいバージョンの Berkeley DB ライブラリから古い Berkeley DB ファイルを開こうとすることです。"

#: ../../faq/library.rst:829
msgid ""
"Many Linux systems now have all three versions of Berkeley DB available.  If"
" you are migrating from version 1 to a newer version use db_dump185 to dump "
"a plain text version of the database.  If you are migrating from version 2 "
"to version 3 use db2_dump to create a plain text version of the database.  "
"In either case, use db_load to create a new native database for the latest "
"version installed on your computer.  If you have version 3 of Berkeley DB "
"installed, you should be able to use db2_load to create a native version 2 "
"database."
msgstr "多くの Linux システムで、今では 3 種類全てのバージョンの Berkeley DB が利用できます。バージョン 1 から新しいバージョンに移行するには、 db_dump185 でデータベースのプレーンテキスト版をダンプしてください。バージョン 2 からバージョン 3 に移行するには、db_2dump でデータベースのプレーンテキスト版を生成してください。そのどちらの場合でも、db_load でコンピュータにインストールされている最新バージョンの新しいネイティブデータベースを生成してください。バージョン 3 の Berkeley DB がインストールされているなら、db2_load でネイティブのバージョン 2 のデータベースを生成できるでしょう。"

#: ../../faq/library.rst:837
msgid ""
"You should move away from Berkeley DB version 1 files because the hash file "
"code contains known bugs that can corrupt your data."
msgstr "Berkeley DB バージョン 1 のハッシュファイルコードにはデータを破壊する既知のバグがありますから、使うのをやめるべきです。"

#: ../../faq/library.rst:842
msgid "Mathematics and Numerics"
msgstr "数学と数"

#: ../../faq/library.rst:845
msgid "How do I generate random numbers in Python?"
msgstr "Python でランダムな数を生成するにはどうしますか？"

#: ../../faq/library.rst:847
msgid ""
"The standard module :mod:`random` implements a random number generator.  "
"Usage is simple::"
msgstr "標準モジュールの :mod:`random` がランダムな数の生成器を実装しています。使い方は単純です::"

#: ../../faq/library.rst:853
msgid "This returns a random floating point number in the range [0, 1)."
msgstr "これは区間 [0, 1) 内のランダムな浮動小数点数を返します。"

#: ../../faq/library.rst:855
msgid ""
"There are also many other specialized generators in this module, such as:"
msgstr "このモジュールにはその他多くの特化した生成器もあります。例えば:"

#: ../../faq/library.rst:857
msgid "``randrange(a, b)`` chooses an integer in the range [a, b)."
msgstr "``randrange(a, b)`` は区間 [a, b) から整数を選びます。"

#: ../../faq/library.rst:858
msgid "``uniform(a, b)`` chooses a floating point number in the range [a, b)."
msgstr "``uniform(a, b)`` は区間 [a, b) から浮動小数点数を選びます。"

#: ../../faq/library.rst:859
msgid ""
"``normalvariate(mean, sdev)`` samples the normal (Gaussian) distribution."
msgstr "``normalvariate(mean, sdev)`` は正規(ガウス)分布をサンプリングします。"

#: ../../faq/library.rst:861
msgid "Some higher-level functions operate on sequences directly, such as:"
msgstr "シーケンスに直接作用する高水準な関数もあります。例えば:"

#: ../../faq/library.rst:863
msgid "``choice(S)`` chooses random element from a given sequence"
msgstr "``choice(S)`` は与えられたシーケンスからランダムな要素を選びます。"

#: ../../faq/library.rst:864
msgid "``shuffle(L)`` shuffles a list in-place, i.e. permutes it randomly"
msgstr "``shuffle(L)`` はリストをインプレースにシャッフルします。すなわち、ランダムに並び替えます。"

#: ../../faq/library.rst:866
msgid ""
"There's also a ``Random`` class you can instantiate to create independent "
"multiple random number generators."
msgstr "``Random`` クラスのインスタンスを生成して、複数の独立なランダムな数の生成器をつくることもできます。"
