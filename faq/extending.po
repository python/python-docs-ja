# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-29 13:25+0900\n"
"PO-Revision-Date: 2018-05-29 04:30+0000\n"
"Last-Translator: Arihiro TAKASE\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../faq/extending.rst:3
msgid "Extending/Embedding FAQ"
msgstr "æ‹¡å¼µã¨åŸ‹ã‚è¾¼ã¿ FAQ"

#: ../../faq/extending.rst:6
msgid "Contents"
msgstr "å†…å®¹"

#: ../../faq/extending.rst:13
msgid "Can I create my own functions in C?"
msgstr "C ã§ç‹¬è‡ªã®é–¢æ•°ã‚’ä½œã‚‹ã“ã¨ã¯ã§ãã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:15
msgid ""
"Yes, you can create built-in modules containing functions, variables, "
"exceptions and even new types in C.  This is explained in the document :ref"
":`extending-index`."
msgstr "ã¯ã„ã€‚é–¢æ•°ã€å¤‰æ•°ã€ä¾‹å¤–ã€ãã—ã¦æ–°ã—ã„ã‚¿ã‚¤ãƒ—ã¾ã§å«ã‚“ã ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ C ã§ä½œã‚Œã¾ã™ã€‚ã“ã‚Œã¯ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ :ref:`extending-index` ã§èª¬æ˜ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../faq/extending.rst:19
msgid "Most intermediate or advanced Python books will also cover this topic."
msgstr "ã»ã¨ã‚“ã©ã®ä¸­ç´šã‹ã‚‰ä¸Šç´šã® Python æœ¬ã‚‚ã“ã®è©±é¡Œã‚’æ‰±ã£ã¦ã„ã¾ã™ã€‚"

#: ../../faq/extending.rst:23
msgid "Can I create my own functions in C++?"
msgstr "C++ ã§ç‹¬è‡ªã®é–¢æ•°ã‚’ä½œã‚‹ã“ã¨ã¯ã§ãã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:25
msgid ""
"Yes, using the C compatibility features found in C++.  Place ``extern \"C\" "
"{ ... }`` around the Python include files and put ``extern \"C\"`` before "
"each function that is going to be called by the Python interpreter.  Global "
"or static C++ objects with constructors are probably not a good idea."
msgstr "ã¯ã„ã€‚C++ å†…ã«ã‚ã‚‹ C äº’æ›æ©Ÿèƒ½ã‚’ä½¿ã£ã¦ã§ãã¾ã™ã€‚ ``extern \"C\" { ... }`` ã§ Python ã®ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å›²ã¿ã€ ``extern \"C\"`` ã‚’ Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‹ã‚‰å‘¼ã¶å„é–¢æ•°ã®å‰ã«ç½®ã„ã¦ãã ã•ã„ã€‚ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚„é™çš„ãª C++ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ§‹é€ ä½“ã‚’æŒã¤ã‚‚ã®ã¯è‰¯ããªã„ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/extending.rst:34
msgid "Writing C is hard; are there any alternatives?"
msgstr "C ã‚’æ›¸ãã®ã¯å¤§å¤‰ã§ã™ã€‚ä»–ã®æ–¹æ³•ã¯ã‚ã‚Šã¾ã›ã‚“ã‹ï¼Ÿ"

#: ../../faq/extending.rst:36
msgid ""
"There are a number of alternatives to writing your own C extensions, "
"depending on what you're trying to do."
msgstr "ç‹¬è‡ªã® C æ‹¡å¼µã‚’æ›¸ããŸã‚ã®åˆ¥ã®ã‚„ã‚Šæ–¹ã¯ã€ç›®çš„ã«ã‚ˆã£ã¦ã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/extending.rst:41
msgid ""
"If you need more speed, `Psyco <http://psyco.sourceforge.net/>`_ generates "
"x86 assembly code from Python bytecode.  You can use Psyco to compile the "
"most time-critical functions in your code, and gain a significant "
"improvement with very little effort, as long as you're running on a machine "
"with an x86-compatible processor."
msgstr "é€Ÿåº¦ãŒå¿…è¦ãªã‚‰ã€ `Psyco <http://psyco.sourceforge.net/>`_ ã¯ Python ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã‹ã‚‰ x86 ã‚¢ã‚»ãƒ³ãƒ–ãƒªã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ Psyco ã§ã‚³ãƒ¼ãƒ‰ã®æœ€ã‚‚æ™‚é–“åˆ¶ç´„ãŒå³ã—ã„é–¢æ•°ç¾¤ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚Œã°ã€ x-86 äº’æ›ã®ãƒ—ãƒ­ã‚»ãƒƒã‚µä¸Šã§å‹•ã‹ã™é™ã‚Šã€ã‚ãšã‹ãªæ‰‹é–“ã§è‘—ã—ã„æ”¹å–„ãŒã§ãã¾ã™ã€‚"

#: ../../faq/extending.rst:47
msgid ""
"`Cython <http://cython.org>`_ and its relative `Pyrex "
"<https://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/>`_ are compilers"
" that accept a slightly modified form of Python and generate the "
"corresponding C code.  Pyrex makes it possible to write an extension without"
" having to learn Python's C API."
msgstr "`Cython <http://cython.org>`_ ã¨ãã®è¦ªæˆš `Pyrex <https://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/>`_ ã¯ã€ã‚ãšã‹ã«ä¿®æ­£ã•ã‚ŒãŸ Python ã‚’å—ã‘å–ã‚Šã€å¯¾å¿œã™ã‚‹ C ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¾ã™ã€‚\nPyrex ã‚’ä½¿ãˆã° Python ã® C API ã‚’ç¿’å¾—ã™ã‚‹ã“ã¨ãªã—ã«æ‹¡å¼µã‚’æ›¸ã‘ã¾ã™ã€‚"

#: ../../faq/extending.rst:53
msgid ""
"If you need to interface to some C or C++ library for which no Python "
"extension currently exists, you can try wrapping the library's data types "
"and functions with a tool such as `SWIG <http://www.swig.org>`_.  `SIP "
"<https://riverbankcomputing.com/software/sip/intro>`__, `CXX "
"<http://cxx.sourceforge.net/>`_ `Boost "
"<http://www.boost.org/libs/python/doc/index.html>`_, or `Weave "
"<https://github.com/scipy/weave>`_ are also alternatives for wrapping C++ "
"libraries."
msgstr "ä»Šã®ã¨ã“ã‚ Python æ‹¡å¼µãŒå­˜åœ¨ã—ãªã„ã‚ˆã†ãª C ã‚„ C++ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¸ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ãŒå¿…è¦ãªå ´åˆã€`SWIG <http://www.swig.org>`_ ã®ã‚ˆã†ãªãƒ„ãƒ¼ãƒ«ã§ã€ãã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ‡ãƒ¼ã‚¿å‹ã®ãƒ©ãƒƒãƒ”ãƒ³ã‚°ã‚’å›³ã‚Œã¾ã™ã€‚\n`SIP <https://riverbankcomputing.com/software/sip/intro>`_ã€`CXX <http://cxx.sourceforge.net/>`_ã€`Boost <http://www.boost.org/libs/python/doc/index.html>`_ã€`Weave <https://github.com/scipy/weave>`_ ã§ã‚‚ C++ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ãƒ©ãƒƒãƒ”ãƒ³ã‚°ã§ãã¾ã™ã€‚"

#: ../../faq/extending.rst:64
msgid "How can I execute arbitrary Python statements from C?"
msgstr "C ã‹ã‚‰ä»»æ„ã® Python æ–‡ã‚’å®Ÿè¡Œã™ã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:66
msgid ""
"The highest-level function to do this is :c:func:`PyRun_SimpleString` which "
"takes a single string argument to be executed in the context of the module "
"``__main__`` and returns 0 for success and -1 when an exception occurred "
"(including ``SyntaxError``).  If you want more control, use "
":c:func:`PyRun_String`; see the source for :c:func:`PyRun_SimpleString` in "
"``Python/pythonrun.c``."
msgstr "ã“ã‚Œã‚’è¡Œã†æœ€é«˜æ°´æº–ã®é–¢æ•°ã¯ :c:func:`PyRun_SimpleString` ã§ã€ä¸€ã¤ã®æ–‡å­—åˆ—å¼•æ•°ã‚’å–ã‚Šã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« ``__main__`` ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ãã‚Œã‚’å®Ÿè¡Œã—ã€æˆåŠŸãªã‚‰ 0ã€ä¾‹å¤– (``SyntaxError`` ã‚’å«ã‚€) ãŒç™ºç”Ÿã—ãŸã‚‰ -1 ã‚’è¿”ã—ã¾ã™ã€‚æ›´ã«åˆ¶å¾¡ã—ãŸã‘ã‚Œã°ã€ :c:func:`PyRun_String`  ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ã‚½ãƒ¼ã‚¹ã¯ ``Python/pythonrun.c`` ã® ':c:func:`PyRun_SimpleString` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/extending.rst:75
msgid "How can I evaluate an arbitrary Python expression from C?"
msgstr "C ã‹ã‚‰ä»»æ„ã® Python å¼ã‚’è©•ä¾¡ã™ã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:77
msgid ""
"Call the function :c:func:`PyRun_String` from the previous question with the"
" start symbol :c:data:`Py_eval_input`; it parses an expression, evaluates it"
" and returns its value."
msgstr "å…ˆã®è³ªå•ã® :c:func:`PyRun_String` ã‚’ã€ã‚¹ã‚¿ãƒ¼ãƒˆã‚·ãƒ³ãƒœãƒ« :c:data:`Py_eval_input` ã‚’æ¸¡ã—ã¦å‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã¯å¼ã‚’è§£æã—ã€è©•ä¾¡ã—ã¦ãã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../faq/extending.rst:83
msgid "How do I extract C values from a Python object?"
msgstr "Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ C ã®å€¤ã‚’å–ã‚Šå‡ºã™ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:85
msgid ""
"That depends on the object's type.  If it's a tuple, :c:func:`PyTuple_Size` "
"returns its length and :c:func:`PyTuple_GetItem` returns the item at a "
"specified index.  Lists have similar functions, :c:func:`PyListSize` and "
":c:func:`PyList_GetItem`."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã«ä¾ã‚Šã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ãªã‚‰ã€ :c:func:`PyTuple_Size` ãŒé•·ã•ã‚’è¿”ã—ã€ :c:func:`PyTuple_GetItem` ãŒæŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®è¦ç´ ã‚’è¿”ã—ã¾ã™ã€‚ãƒªã‚¹ãƒˆã«ã‚‚åŒæ§˜ã®é–¢æ•° :c:func:`PyList_Size` ã¨ :c:func:`PyList_GetItem` ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/extending.rst:90
msgid ""
"For strings, :c:func:`PyString_Size` returns its length and "
":c:func:`PyString_AsString` a pointer to its value.  Note that Python "
"strings may contain null bytes so C's :c:func:`strlen` should not be used."
msgstr "æ–‡å­—åˆ—ãªã‚‰ã€ :c:func:`PyString_Size` ãŒé•·ã•ã‚’ã€ :c:func:`PyString_AsString` ãŒãã®å€¤ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ãªãŠã€Python ã®æ–‡å­—åˆ—ã«ã¯ null ãƒã‚¤ãƒˆãŒå«ã¾ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã€C ã® :c:func:`strlen` ã¯ä½¿ã†ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../faq/extending.rst:94
msgid ""
"To test the type of an object, first make sure it isn't *NULL*, and then use"
" :c:func:`PyString_Check`, :c:func:`PyTuple_Check`, :c:func:`PyList_Check`, "
"etc."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’æ¤œæŸ»ã™ã‚‹ã«ã¯ã€ã¾ãšæœ€åˆã«ãã‚ŒãŒ *NULL* ã§ãªã„ã“ã¨ã‚’ç¢ºã‹ã‚ãŸä¸Šã§ã€ :c:func:`PyString_Check` ã€ :c:func:`PyTuple_Check` ã€ :c:func:`PyList_Check` ãªã©ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../faq/extending.rst:97
msgid ""
"There is also a high-level API to Python objects which is provided by the "
"so-called 'abstract' interface -- read ``Include/abstract.h`` for further "
"details.  It allows interfacing with any kind of Python sequence using calls"
" like :c:func:`PySequence_Length`, :c:func:`PySequence_GetItem`, etc.)  as "
"well as many other useful protocols."
msgstr "Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®é«˜ãƒ¬ãƒ™ãƒ«ãª API ã«ã¯ã€ã„ã‚ã‚†ã‚‹ 'abstract' ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ãŒæä¾›ã™ã‚‹ã‚‚ã®ã‚‚ã‚ã‚Šã¾ã™ã€‚æ©Ÿèƒ½ã®è©³ç´°ã¯ ``Include/abstract.h`` ã‚’èª­ã‚“ã§ãã ã•ã„ã€‚ã“ã‚Œã§ã€ :c:func:`PySequence_Length` ã‚„ :c:func:`PySequence_GetItem` ãªã©ã®å‘¼ã³å‡ºã—ã§ã‚ã‚‰ã‚†ã‚‹ã‚¿ã‚¤ãƒ—ã® Python ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ãŒã§ãã¾ã™ã—ã€ãã®ä»–å¤šãã®å½¹ç«‹ã¤ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚‚ã§ãã¾ã™ã€‚"

#: ../../faq/extending.rst:105
msgid "How do I use Py_BuildValue() to create a tuple of arbitrary length?"
msgstr "Py_BuildValue() ã§ä»»æ„é•·ã®ã‚¿ãƒ—ãƒ«ã‚’ä½œã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:107
msgid ""
"You can't.  Use ``t = PyTuple_New(n)`` instead, and fill it with objects "
"using ``PyTuple_SetItem(t, i, o)`` -- note that this \"eats\" a reference "
"count of ``o``, so you have to :c:func:`Py_INCREF` it.  Lists have similar "
"functions ``PyList_New(n)`` and ``PyList_SetItem(l, i, o)``.  Note that you "
"*must* set all the tuple items to some value before you pass the tuple to "
"Python code -- ``PyTuple_New(n)`` initializes them to NULL, which isn't a "
"valid Python value."
msgstr "ã§ãã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã« ``t = PyTuple_New(n)`` ã‚’ä½¿ã„ã€ ``PyTuple_SetItem(t, i, o)`` ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åŸ‹ã‚ã¦ãã ã•ã„ -- ãªãŠã€ã“ã‚Œã¯ ``o`` ã®ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã‚«ã‚¦ãƒ³ãƒˆã‚’ \"é£Ÿã†\" ã®ã§ã€ :c:func:`Py_INCREF` ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒªã‚¹ãƒˆã«ã‚‚åŒæ§˜ã®é–¢æ•° ``PyList_New(n)`` ã¨ ``PyList_SetItem(l, i, o)`` ãŒã‚ã‚Šã¾ã™ã€‚ãªãŠã€ã‚¿ãƒ—ãƒ«ã¯ Python ã‚³ãƒ¼ãƒ‰ã«æ¸¡ã•ã‚Œã‚‹å‰ã« *å¿…ãš* ã™ã¹ã¦ã®å€¤ãŒè¨­å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªãƒªã¾ã›ã‚“ -- ``PyTuple_New(n)`` ã¯å„è¦ç´ ã‚’åˆæœŸåŒ–ã—ã¦ NULL ã«ã—ã¾ã™ãŒã€ã“ã‚Œã¯ Python ã®é©åˆ‡ãªå€¤ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../faq/extending.rst:116
msgid "How do I call an object's method from C?"
msgstr "C ã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:118
msgid ""
"The :c:func:`PyObject_CallMethod` function can be used to call an arbitrary "
"method of an object.  The parameters are the object, the name of the method "
"to call, a format string like that used with :c:func:`Py_BuildValue`, and "
"the argument values::"
msgstr ":c:func:`PyObject_CallMethod` é–¢æ•°ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»»æ„ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã›ã¾ã™ã€‚ãƒ‘ãƒ©ãƒ¡ã‚¿ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€å‘¼ã³å‡ºã™ãƒ¡ã‚½ãƒƒãƒ‰ã®åå‰ã€ :c:func:`Py_BuildValue` ã§ä½¿ã‚ã‚Œã‚‹ã‚ˆã†ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ã€ãã—ã¦å¼•æ•°ã§ã™::"

#: ../../faq/extending.rst:127
msgid ""
"This works for any object that has methods -- whether built-in or user-"
"defined. You are responsible for eventually :c:func:`Py_DECREF`\\ 'ing the "
"return value."
msgstr "ã“ã‚Œã¯ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã„ã‹ãªã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚‚æœ‰åŠ¹ã§ã€çµ„ã¿è¾¼ã¿ã‹ãƒ¦ãƒ¼ã‚¶å®šç¾©ã‹ã¯é–¢ä¿‚ã‚ã‚Šã¾ã›ã‚“ã€‚è¿”ã‚Šå€¤ã«å¯¾ã—ã¦ :c:func:`Py_DECREF` ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/extending.rst:130
msgid ""
"To call, e.g., a file object's \"seek\" method with arguments 10, 0 "
"(assuming the file object pointer is \"f\")::"
msgstr "ä¾‹ãˆã°ã€ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® \"seek\" ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ 10, 0 ã‚’å¼•æ•°ã¨ã—ã¦å‘¼ã¶ã¨ã (ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒã‚¤ãƒ³ã‚¿ã‚’ \"f\" ã¨ã—ã¾ã™)::"

#: ../../faq/extending.rst:141
msgid ""
"Note that since :c:func:`PyObject_CallObject` *always* wants a tuple for the"
" argument list, to call a function without arguments, pass \"()\" for the "
"format, and to call a function with one argument, surround the argument in "
"parentheses, e.g. \"(i)\"."
msgstr "ãªãŠã€ :c:func:`PyObject_CallObject` ã®å¼•æ•°ãƒªã‚¹ãƒˆã«ã¯ *å¸¸ã«* ã‚¿ãƒ—ãƒ«ãŒå¿…è¦ã§ã™ã€‚é–¢æ•°ã‚’å¼•æ•°ãªã—ã§å‘¼ã³å‡ºã™ã«ã¯ã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã« \"()\" ã‚’æ¸¡ã—ã€é–¢æ•°ã‚’ä¸€ã¤ã®å¼•æ•°ã§å‘¼ã³å‡ºã™ã«ã¯ã€é–¢æ•°ã‚’æ‹¬å¼§ã§ããã£ã¦ä¾‹ãˆã° \"(i)\" ã¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/extending.rst:148
msgid ""
"How do I catch the output from PyErr_Print() (or anything that prints to "
"stdout/stderr)?"
msgstr "PyErr_Print() (ãã®ä»– stdout/stderr ã«å°å­—ã™ã‚‹ã‚‚ã®) ã‹ã‚‰ã®å‡ºåŠ›ã‚’å—ã‘å–ã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:150
msgid ""
"In Python code, define an object that supports the ``write()`` method.  "
"Assign this object to :data:`sys.stdout` and :data:`sys.stderr`.  Call "
"print_error, or just allow the standard traceback mechanism to work. Then, "
"the output will go wherever your ``write()`` method sends it."
msgstr "Python ã‚³ãƒ¼ãƒ‰å†…ã§ã€ ``write()`` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®šç¾©ã—ã¦ãã ã•ã„ã€‚ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :data:`sys.stdout` ã¨ :data:`sys.stderr` ã«ä»£å…¥ã—ã¦ãã ã•ã„ã€‚print_error ã‚’å‘¼ã³å‡ºã™ã‹ã€å˜ã«æ¨™æº–ã®ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯æ©Ÿæ§‹ã‚’ä½œå‹•ã•ã›ã¦ãã ã•ã„ã€‚ãã†ã™ã‚Œã°ã€å‡ºåŠ›ã¯ ``write()`` ãŒé€ã‚‹ä»»æ„ã®æ‰€ã«è¡Œãã¾ã™ã€‚"

#: ../../faq/extending.rst:155
msgid ""
"The easiest way to do this is to use the StringIO class in the standard "
"library."
msgstr "æœ€ã‚‚ç°¡å˜ãªæ–¹æ³•ã¯ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® StringIO ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã†ã“ã¨ã§ã™ã€‚"

#: ../../faq/extending.rst:157
msgid "Sample code and use for catching stdout:"
msgstr "ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã¨å‡ºåŠ›ã®å—ã‘å–ã‚Šä¾‹:"

#: ../../faq/extending.rst:177
msgid "How do I access a module written in Python from C?"
msgstr "C ã‹ã‚‰ Python ã§æ›¸ã‹ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:179
msgid "You can get a pointer to the module object as follows::"
msgstr "ä»¥ä¸‹ã®ã‚ˆã†ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å¾—ã‚‰ã‚Œã¾ã™::"

#: ../../faq/extending.rst:183
msgid ""
"If the module hasn't been imported yet (i.e. it is not yet present in "
":data:`sys.modules`), this initializes the module; otherwise it simply "
"returns the value of ``sys.modules[\"<modulename>\"]``.  Note that it "
"doesn't enter the module into any namespace -- it only ensures it has been "
"initialized and is stored in :data:`sys.modules`."
msgstr "ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã¾ã ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ (ã¤ã¾ã‚Šã€ã¾ã  :data:`sys.modules` ã«ç¾ã‚Œã¦ã„ãªã„) ãªã‚‰ã€ã“ã‚Œã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€å˜ç´”ã« ``sys.modules[\"<modulename>\"]`` ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚ãªãŠã€ã“ã‚Œã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã„ã‹ãªã‚‹åå‰ç©ºé–“ã«ã‚‚ä»£å…¥ã—ã¾ã›ã‚“ã€‚ã“ã‚Œã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆæœŸåŒ–ã•ã‚Œã¦ ':data:`sys.modules` ã«ä¿ç®¡ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã ã‘ã§ã™ã€‚"

#: ../../faq/extending.rst:189
msgid ""
"You can then access the module's attributes (i.e. any name defined in the "
"module) as follows::"
msgstr "ã“ã‚Œã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å±æ€§ (ã¤ã¾ã‚Šã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚ŒãŸä»»æ„ã®åå‰) ã«ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../faq/extending.rst:194
msgid ""
"Calling :c:func:`PyObject_SetAttrString` to assign to variables in the "
"module also works."
msgstr ":c:func:`PyObject_SetAttrString` ã‚’å‘¼ã‚“ã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å¤‰æ•°ã«ä»£å…¥ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../faq/extending.rst:199
msgid "How do I interface to C++ objects from Python?"
msgstr "Python ã‹ã‚‰ C++ ã¸ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã™ã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:201
msgid ""
"Depending on your requirements, there are many approaches.  To do this "
"manually, begin by reading :ref:`the \"Extending and Embedding\" document "
"<extending-index>`.  Realize that for the Python run-time system, there "
"isn't a whole lot of difference between C and C++ -- so the strategy of "
"building a new Python type around a C structure (pointer) type will also "
"work for C++ objects."
msgstr "ã‚„ã‚ŠãŸã„ã“ã¨ã«å¿œã˜ã¦ã€ã„ã‚ã„ã‚ãªæ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚æ‰‹å‹•ã§ã‚„ã‚‹ãªã‚‰ã€ :ref:`\"æ‹¡å¼µã¨åŸ‹ã‚è¾¼ã¿\" ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ <extending-index>` ã‚’èª­ã‚€ã“ã¨ã‹ã‚‰å§‹ã‚ã¦ãã ã•ã„ã€‚ãªãŠã€Python ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚·ã‚¹ãƒ†ãƒ ã«ã¨ã£ã¦ã¯ã€ C ã¨ C++ ã¯ã‚ã¾ã‚Šå¤‰ã‚ã‚Šã¾ã›ã‚“ã€‚ã ã‹ã‚‰ã€C æ§‹é€ ä½“ (ãƒã‚¤ãƒ³ã‚¿)å‹ã«åŸºã¥ã„ã¦æ–°ã—ã„ Python ã®å‹ã‚’æ§‹ç¯‰ã™ã‚‹æ–¹é‡ã¯ C++ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã‚‚æœ‰åŠ¹ã§ã™ã€‚"

#: ../../faq/extending.rst:207
msgid "For C++ libraries, see :ref:`c-wrapper-software`."
msgstr "C++ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«é–¢ã—ã¦ã¯ã€ :ref:`c-wrapper-software` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/extending.rst:211
msgid "I added a module using the Setup file and the make fails; why?"
msgstr "ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿½åŠ ã—ã‚ˆã†ã¨ã—ãŸã‚‰ãƒ¡ã‚¤ã‚¯ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãªãœã§ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:213
msgid ""
"Setup must end in a newline, if there is no newline there, the build process"
" fails.  (Fixing this requires some ugly shell script hackery, and this bug "
"is so minor that it doesn't seem worth the effort.)"
msgstr "ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¯æ”¹è¡Œã§çµ‚ã‚ã‚‰ãªã‘ã‚Œã°ãªã‚‰ãªãã¦ã€æ”¹è¡ŒãŒãªã„ã¨ã€ãƒ“ãƒ«ãƒ‰å·¥ç¨‹ã¯å¤±æ•—ã—ã¾ã™ã€‚(ã“ã‚Œã‚’ç›´ã™ã«ã¯ã€ã‚ã‚‹ç¨®ã®é†œã„ã‚·ã‚§ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒãƒƒã‚¯ãŒå¿…è¦ã§ã™ãŒã€ã“ã®ãƒã‚°ã¯å°ã•ã„ã‚‚ã®ã§ã™ã‹ã‚‰åŠªåŠ›ã«è¦‹åˆã†ä¾¡å€¤ã¯ãªã„ã§ã—ã‚‡ã†ã€‚)"

#: ../../faq/extending.rst:219
msgid "How do I debug an extension?"
msgstr "æ‹¡å¼µã‚’ãƒ‡ãƒãƒƒã‚°ã™ã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:221
msgid ""
"When using GDB with dynamically loaded extensions, you can't set a "
"breakpoint in your extension until your extension is loaded."
msgstr "å‹•çš„ã«ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸæ‹¡å¼µã« GDB ã‚’ä½¿ã†ã¨ãã€æ‹¡å¼µãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã¾ã§ãƒ–ãƒ¬ãƒ¼ã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’è¨­å®šã—ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../faq/extending.rst:224
msgid "In your ``.gdbinit`` file (or interactively), add the command:"
msgstr "``.gdbinit`` ãƒ•ã‚¡ã‚¤ãƒ«ã«(ã¾ãŸã¯å¯¾è©±çš„ã«)ã€ã“ã®ã‚³ãƒãƒ³ãƒ‰ã‚’åŠ ãˆã¦ãã ã•ã„:"

#: ../../faq/extending.rst:230
msgid "Then, when you run GDB:"
msgstr "ãã—ã¦ã€GDB ã‚’èµ·å‹•ã™ã‚‹ã¨ãã«:"

#: ../../faq/extending.rst:242
msgid ""
"I want to compile a Python module on my Linux system, but some files are "
"missing. Why?"
msgstr "Linux ã‚·ã‚¹ãƒ†ãƒ ã§ Python ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ãŸã„ã®ã§ã™ãŒã€è¦‹ã¤ã‹ã‚‰ãªã„ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã™ã€‚ãªãœã§ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:244
msgid ""
"Most packaged versions of Python don't include the "
":file:`/usr/lib/python2.{x}/config/` directory, which contains various files"
" required for compiling Python extensions."
msgstr "Python ã®å¤šãã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã¯ã€Python æ‹¡å¼µã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã®ã«å¿…è¦ãªæ§˜ã€…ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚’å«ã‚€ :file:`/usr/lib/python2.{x}/config/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../faq/extending.rst:248
msgid "For Red Hat, install the python-devel RPM to get the necessary files."
msgstr "Red Hat ã§ã¯ã€Python RPM ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦å¿…è¦ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾—ã¦ãã ã•ã„ã€‚"

#: ../../faq/extending.rst:250
msgid "For Debian, run ``apt-get install python-dev``."
msgstr "Debian ã§ã¯ã€ ``apt-get install python-dev`` ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/extending.rst:254
msgid ""
"What does \"SystemError: _PyImport_FixupExtension: module yourmodule not "
"loaded\" mean?"
msgstr "\"SystemError: _PyImport_FixupExtension: module yourmodule not loaded\" ã¨ã¯ã©ã†ã„ã†æ„å‘³ã§ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:256
msgid ""
"This means that you have created an extension module named \"yourmodule\", "
"but your module init function does not initialize with that name."
msgstr "ã“ã‚Œã¯ã€\"yourmodule\" ã¨ã„ã†åå‰ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒç”Ÿæˆã•ã‚ŒãŸã‘ã‚Œã©ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® init é–¢æ•°ãŒãã®åå‰ã§åˆæœŸåŒ–ã—ãªã„ã¨ã„ã†æ„å‘³ã§ã™ã€‚"

#: ../../faq/extending.rst:259
msgid "Every module init function will have a line similar to::"
msgstr "å…¨ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® init é–¢æ•°ã«ã¯æ¬¡ã®ã‚ˆã†ãªè¡ŒãŒã‚ã‚‹ã§ã—ã‚‡ã†::"

#: ../../faq/extending.rst:263
msgid ""
"If the string passed to this function is not the same name as your extension"
" module, the :exc:`SystemError` exception will be raised."
msgstr "ã“ã®é–¢æ•°ã«æ¸¡ã•ã‚ŒãŸæ–‡å­—åˆ—ãŒæ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨åŒã˜åå‰ã§ãªã„å ´åˆã€ :exc:`SystemError` ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../faq/extending.rst:268
msgid "How do I tell \"incomplete input\" from \"invalid input\"?"
msgstr "\"ä¸å®Œå…¨ (incomplete) ãªå…¥åŠ›\" ã‚’ \"ä¸é©åˆ‡ (invalid) ãªå…¥åŠ›\" ã‹ã‚‰åŒºåˆ¥ã™ã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:270
msgid ""
"Sometimes you want to emulate the Python interactive interpreter's behavior,"
" where it gives you a continuation prompt when the input is incomplete (e.g."
" you typed the start of an \"if\" statement or you didn't close your "
"parentheses or triple string quotes), but it gives you a syntax error "
"message immediately when the input is invalid."
msgstr "Python ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã§ã¯ã€å…¥åŠ›ãŒä¸å®Œå…¨ãªã¨ã (ä¾‹ãˆã°ã€ \"if\" æ–‡ã®å§‹ã¾ã‚Šã‚’ã‚¿ã‚¤ãƒ—ã—ãŸæ™‚ã‚„ã€ã‚«ãƒƒã‚³ã‚„ä¸‰é‡æ–‡å­—åˆ—å¼•ç”¨ç¬¦ã‚’é–‰ã˜ã¦ã„ãªã„æ™‚ãªã©) ã«ã¯ç¶™ç¶šãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ä¸ãˆã‚‰ã‚Œã¾ã™ãŒã€å…¥åŠ›ãŒä¸é©åˆ‡ã§ã‚ã‚‹ã¨ãã«ã¯å³åº§ã«æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒä¸ãˆã‚‰ã‚Œã¾ã™ã€‚ã“ã®ã‚ˆã†ãªãµã‚‹ã¾ã„ã‚’æ¨¡å€£ã—ãŸã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/extending.rst:276
msgid ""
"In Python you can use the :mod:`codeop` module, which approximates the "
"parser's behavior sufficiently.  IDLE uses this, for example."
msgstr "Python ã§ã¯æ§‹æ–‡è§£æå™¨ã®ãµã‚‹ã¾ã„ã«ååˆ†ã«è¿‘ã„ :mod:`codeop` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä½¿ãˆã¾ã™ã€‚ä¾‹ãˆã° IDLE ãŒã“ã‚Œã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚"

#: ../../faq/extending.rst:279
msgid ""
"The easiest way to do it in C is to call :c:func:`PyRun_InteractiveLoop` "
"(perhaps in a separate thread) and let the Python interpreter handle the "
"input for you. You can also set the :c:func:`PyOS_ReadlineFunctionPointer` "
"to point at your custom input function. See ``Modules/readline.c`` and "
"``Parser/myreadline.c`` for more hints."
msgstr "ã“ã‚Œã‚’ C ã§è¡Œã†æœ€ã‚‚ç°¡å˜ãªæ–¹æ³•ã¯ã€ :c:func:`PyRun_InteractiveLoop` ã‚’ (å¿…è¦ãªã‚‰ã°åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§) å‘¼ã³å‡ºã—ã€Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ãªãŸã®å…¥åŠ›ã‚’æ‰±ã‚ã›ã‚‹ã“ã¨ã§ã™ã€‚ç‹¬è‡ªã®å…¥åŠ›é–¢æ•°ã‚’æŒ‡å®šã™ã‚‹ã®ã« :c:func:`PyOS_ReadlineFunctionPointer` ã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚è©³ã—ã„ãƒ’ãƒ³ãƒˆã¯ã€ ``Modules/readline.c`` ã‚„ ``Parser/myreadline.c`` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/extending.rst:285
msgid ""
"However sometimes you have to run the embedded Python interpreter in the "
"same thread as your rest application and you can't allow the "
":c:func:`PyRun_InteractiveLoop` to stop while waiting for user input.  The "
"one solution then is to call :c:func:`PyParser_ParseString` and test for "
"``e.error`` equal to ``E_EOF``, which means the input is incomplete).  "
"Here's a sample code fragment, untested, inspired by code from Alex Farber::"
msgstr "ã—ã‹ã—ã€çµ„ã¿è¾¼ã¿ã® Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ä»–ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¨åŒã˜ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒå¿…è¦ã§ã€ :c:func:`PyRun_InteractiveLoop` ã§ãƒ¦ãƒ¼ã‚¶ã®å…¥åŠ›ã‚’å¾…ã£ã¦ã„ã‚‹é–“æ­¢ã‚ã‚‰ã‚Œãªã„ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚ˆã†ãªå ´åˆã®è§£æ±ºç­–ã®ä¸€ã¤ã¯ã€ :c:func:`PyParser_ParseString` ã‚’å‘¼ã‚“ã§ ``e.error`` ã¨ ``E_EOF`` ãŒç­‰ã—ã„ã“ã¨ã€ã¤ã¾ã‚Šå…¥åŠ›ãŒä¸å®Œå…¨ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã¯ã€Alex Farber ã®ã‚³ãƒ¼ãƒ‰ã‚’å‚è€ƒã«ã—ãŸã€ã‚³ãƒ¼ãƒ‰ç‰‡ã®ä¾‹ã§ã™::"

#: ../../faq/extending.rst:318
msgid ""
"Another solution is trying to compile the received string with "
":c:func:`Py_CompileString`. If it compiles without errors, try to execute "
"the returned code object by calling :c:func:`PyEval_EvalCode`. Otherwise "
"save the input for later. If the compilation fails, find out if it's an "
"error or just more input is required - by extracting the message string from"
" the exception tuple and comparing it to the string \"unexpected EOF while "
"parsing\".  Here is a complete example using the GNU readline library (you "
"may want to ignore **SIGINT** while calling readline())::"
msgstr "åˆ¥ã®è§£æ±ºç­–ã¯ã€å—ã‘å–ã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã‚’ :c:func:`Py_CompileString` ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã‚‹ã“ã¨ã§ã™ã€‚ã‚¨ãƒ©ãƒ¼ç„¡ãã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸã‚‰ã€è¿”ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :c:func:`PyEval_EvalCode` ã‚’å‘¼ã‚“ã§å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã¦ãã ã•ã„ã€‚ãã†ã§ãªã‘ã‚Œã°ã€å…¥åŠ›ã‚’å¾Œã®ãŸã‚ã«ä¿å­˜ã—ã¦ãã ã•ã„ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒå¤±æ•—ã—ãŸãªã‚‰ã€ãã‚ŒãŒã‚¨ãƒ©ãƒ¼ãªã®ã‹å…¥åŠ›ã®ç¶šããŒæ±‚ã‚ã‚‰ã‚Œã¦ã„ã‚‹ã ã‘ãªã®ã‹èª¿ã¹ã¦ãã ã•ã„ã€‚ãã®ãŸã‚ã«ã¯ã€ä¾‹å¤–ã‚¿ãƒ—ãƒ«ã‹ã‚‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ–‡å­—åˆ—ã‚’å±•é–‹ã—ã€ãã‚Œã‚’æ–‡å­—åˆ— \"unexpected EOF while parsing\" ã¨æ¯”è¼ƒã—ã¾ã™ã€‚ã“ã“ã« GNU readline library ã‚’ä½¿ã£ãŸå®Œå…¨ãªä¾‹ãŒã‚ã‚Šã¾ã™ (readline() ã‚’èª­ã‚“ã§ã„ã‚‹é–“ã¯ **SIGINT** ã‚’ç„¡è¦–ã—ãŸã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“)::"

#: ../../faq/extending.rst:439
msgid "How do I find undefined g++ symbols __builtin_new or __pure_virtual?"
msgstr "æœªå®šç¾©ã® g++ ã‚·ãƒ³ãƒœãƒ« __builtin_new ã‚„ __pure_virtual ã‚’è¦‹ã¤ã‘ã‚‹ã«ã¯ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:441
msgid ""
"To dynamically load g++ extension modules, you must recompile Python, relink"
" it using g++ (change LINKCC in the Python Modules Makefile), and link your "
"extension module using g++ (e.g., ``g++ -shared -o mymodule.so "
"mymodule.o``)."
msgstr "g++ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‹•çš„ã«ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã«ã¯ã€Python ã‚’å†ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã€ãã‚Œã‚’ g++ ã§å†ãƒªãƒ³ã‚¯ (Python Modules Makefile å†…ã® LINKCC ã‚’å¤‰æ›´) ã—ã€æ‹¡å¼µã‚’ g++ ã§ãƒªãƒ³ã‚¯ (ä¾‹ãˆã° ``g++ -shared -o mymodule.so mymodule.o``) ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../faq/extending.rst:447
msgid ""
"Can I create an object class with some methods implemented in C and others "
"in Python (e.g. through inheritance)?"
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰ã®ã„ãã¤ã‹ã¯ C ã§ã€ãã®ä»–ã¯ Python ã§å®Ÿè£…ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ã‚’ (ç¶™æ‰¿ãªã©ã§) ä½œã‚‹ã“ã¨ã¯ã§ãã¾ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:449
msgid ""
"Yes, you can inherit from built-in classes such as :class:`int`, "
":class:`list`, :class:`dict`, etc."
msgstr "ã¯ã„ã€ :class:`int` ã€ :class:`list` ã€ :class:`dict` ãªã©ã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã‚¯ãƒ©ã‚¹ã‹ã‚‰ç¶™æ‰¿ã§ãã¾ã™ã€‚"

#: ../../faq/extending.rst:452
msgid ""
"The Boost Python Library (BPL, "
"http://www.boost.org/libs/python/doc/index.html) provides a way of doing "
"this from C++ (i.e. you can inherit from an extension class written in C++ "
"using the BPL)."
msgstr "The Boost Python Library (BPL, http://www.boost.org/libs/python/doc/index.html) ã‚’ä½¿ãˆã°ã€ã“ã‚Œã‚’ C++ ã‹ã‚‰ã§ãã¾ã™ã€‚ (ã™ãªã‚ã¡ã€BPL ã‚’ä½¿ã£ã¦ C++ ã§æ›¸ã‹ã‚ŒãŸæ‹¡å¼µã‚¯ãƒ©ã‚¹ã‚’ç¶™æ‰¿ã§ãã¾ã™)."

#: ../../faq/extending.rst:458
msgid ""
"When importing module X, why do I get \"undefined symbol: PyUnicodeUCS2*\"?"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« X ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ãŸæ™‚ã« \"undefined symbol: PyUnicodeUCS2*\" ã¨è¨€ã‚ã‚Œã‚‹ã®ã¯ãªãœã§ã™ã‹ï¼Ÿ"

#: ../../faq/extending.rst:460
msgid ""
"You are using a version of Python that uses a 4-byte representation for "
"Unicode characters, but some C extension module you are importing was "
"compiled using a Python that uses a 2-byte representation for Unicode "
"characters (the default)."
msgstr "ã‚ãªãŸã¯ Unicode æ–‡å­—ã« 4 ãƒã‚¤ãƒˆè¡¨ç¾ã‚’ä½¿ã† Python ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½¿ã£ã¦ã„ã¾ã™ãŒã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸ C æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã« Unicode æ–‡å­—ã« (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®) 2 ãƒã‚¤ãƒˆè¡¨ç¾ã‚’ä½¿ã† Python ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/extending.rst:464
msgid ""
"If instead the name of the undefined symbol starts with ``PyUnicodeUCS4``, "
"the problem is the reverse: Python was built using 2-byte Unicode "
"characters, and the extension module was compiled using a Python with 4-byte"
" Unicode characters."
msgstr "æœªå®šç¾©ã®ã‚·ãƒ³ãƒœãƒ«ã®åå‰ãŒ ``PyUnicodeUCS4`` ã§å§‹ã¾ã‚‹ã®ãªã‚‰ã€é€†ã®å•é¡Œã§ã™: Python ã¯ 2 ãƒã‚¤ãƒˆ Unicode æ–‡å­—ã§ãƒ“ãƒ«ãƒˆã•ã‚Œã¦ã„ã¦ã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ 4 ãƒã‚¤ãƒˆ Unicode æ–‡å­—ã® Python ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../faq/extending.rst:468
msgid ""
"This can easily occur when using pre-built extension packages.  RedHat Linux"
" 7.x, in particular, provided a \"python2\" binary that is compiled with "
"4-byte Unicode.  This only causes the link failure if the extension uses any"
" of the ``PyUnicode_*()`` functions.  It is also a problem if an extension "
"uses any of the Unicode-related format specifiers for "
":c:func:`Py_BuildValue` (or similar) or parameter specifications for "
":c:func:`PyArg_ParseTuple`."
msgstr "ã“ã‚Œã¯ã‚ã‚‰ã‹ã˜ã‚ãƒ“ãƒ«ãƒ‰ã•ã‚ŒãŸæ‹¡å¼µãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ä½¿ã£ã¦ã„ã‚‹ã¨ãã«èµ·ã“ã‚Šã‚„ã™ã„ã§ã™ã€‚ã¨ã‚Šã‚ã‘ã€RedHat Linux 7.x ã¯ 4 ãƒã‚¤ãƒˆãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸ \"python2\" ãƒã‚¤ãƒŠãƒªã‚’æä¾›ã—ã¾ã—ãŸã€‚ã“ã‚Œã¯æ‹¡å¼µãŒ ``PyUnicode_*()`` é–¢æ•°ã®ã©ã‚Œã‹ã‚’ä½¿ã£ã¦ã„ã‚‹ã¨ãƒªãƒ³ã‚¯ã®å¤±æ•—ã‚’èµ·ã“ã™ã ã‘ã§ã™ã€‚æ‹¡å¼µãŒ Unicode ã«é–¢é€£ã™ã‚‹ :c:func:`Py_BuildValue` (ç­‰)ã¸ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæŒ‡å®šã‚„ :c:func:`PyArg_ParseTuple` ã¸ã®ãƒ‘ãƒ©ãƒ¡ã‚¿æŒ‡å®šã‚’ä½•ã‹ã—ã‚‰å«ã‚“ã§ã„ã¦ã‚‚å•é¡Œã«ãªã‚Šã¾ã™ã€‚"

#: ../../faq/extending.rst:475
msgid ""
"You can check the size of the Unicode character a Python interpreter is "
"using by checking the value of sys.maxunicode:"
msgstr "Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒä½¿ã£ã¦ã„ã‚‹ Unicode æ–‡å­—ã®ã‚µã‚¤ã‚ºã¯ã€ sys.maxunicode ã®å€¤ã‚’èª¿ã¹ã‚‹ã“ã¨ã§ç¢ºã‹ã‚ã‚‰ã‚Œã¾ã™:"

#: ../../faq/extending.rst:486
msgid ""
"The only way to solve this problem is to use extension modules compiled with"
" a Python binary built using the same size for Unicode characters."
msgstr "ã“ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹å”¯ä¸€ã®æ–¹æ³•ã¯ã€Unicode æ–‡å­—ã«åŒã˜ã‚µã‚¤ã‚ºã‚’ä½¿ã£ã¦ãƒ“ãƒ«ãƒ‰ã•ã‚ŒãŸ Python ãƒã‚¤ãƒŠãƒªã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸæ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã†ã“ã¨ã§ã™ã€‚"
