# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-08-01 14:01+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../faq/design.rst:3
msgid "Design and History FAQ"
msgstr "ãƒ‡ã‚¶ã‚¤ãƒ³ã¨æ­´å² FAQ"

#: ../../faq/design.rst:6
msgid "Contents"
msgstr "å†…å®¹"

#: ../../faq/design.rst:11
msgid "Why does Python use indentation for grouping of statements?"
msgstr "Python ã¯ãªãœæ–‡ã®ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã«ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ä½¿ã†ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:13
msgid ""
"Guido van Rossum believes that using indentation for grouping is extremely "
"elegant and contributes a lot to the clarity of the average Python program. "
"Most people learn to love this feature after a while."
msgstr ""
"Guido van Rossum ã®ä¿¡ã˜ã‚‹ã¨ã“ã‚ã«ã‚ˆã‚Œã°ã€ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã«ã‚ˆã‚‹ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã¯éå¸¸ã«ã‚¨ãƒ¬ã‚¬ãƒ³ãƒˆã§ã€æ™®é€šã® Python "
"ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å¤§ã„ã«èª­ã¿ã‚„ã™ãã—ã¾ã™ã€‚ã—ã°ã‚‰ãã™ã‚Œã°ã»ã¨ã‚“ã©ã®äººã¯ã“ã®ä»•æ§˜ã‚’æ°—ã«å…¥ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../faq/design.rst:17
msgid ""
"Since there are no begin/end brackets there cannot be a disagreement between"
" grouping perceived by the parser and the human reader.  Occasionally C "
"programmers will encounter a fragment of code like this::"
msgstr ""
"é–‹å§‹/çµ‚äº†ã®æ‹¬å¼§ãŒãªã„ã®ã§ã€æ§‹æ–‡è§£æå™¨ã¨äººé–“ã®èª­è€…ã®é–“ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã®è§£é‡ˆã®é•ã„ã¯èµ·ã“ã‚Šãˆã¾ã›ã‚“ã€‚æ™‚æŠ˜ã€C "
"ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ã“ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ç‰‡ã«å‡ºãã‚ã—ã¾ã™::"

#: ../../faq/design.rst:26
msgid ""
"Only the ``x++`` statement is executed if the condition is true, but the "
"indentation leads you to believe otherwise.  Even experienced C programmers "
"will sometimes stare at it a long time wondering why ``y`` is being "
"decremented even for ``x > y``."
msgstr ""
"ã“ã®æ¡ä»¶æ–‡ãŒçœŸã®æ™‚ã®ã¿å®Ÿè¡Œã•ã‚Œã‚‹ã®ã¯ ``x++`` æ–‡ã ã‘ã§ã™ãŒã€ã“ã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã§ã¯èª¤è§£ã‚’æ‹›ãã¾ã™ã€‚çµŒé¨“ã‚’ç©ã‚“ã  C ãƒ—ãƒ­ã‚°ãƒ©ãƒã§ã•ãˆã€ ``y`` "
"ãŒ ``x > y`` ã®æ™‚ã«ã‚‚ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œã‚‹ã®ã¯ãªãœã‹åˆ†ã‹ã‚‰ãšé•·ã„ã“ã¨ç«‹ã¡æ­¢ã¾ã‚‹ã“ã¨ãŒã‚ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/design.rst:31
msgid ""
"Because there are no begin/end brackets, Python is much less prone to "
"coding-style conflicts.  In C there are many different ways to place the "
"braces. If you're used to reading and writing code that uses one style, you "
"will feel at least slightly uneasy when reading (or being required to write)"
" another style."
msgstr ""
"é–‹å§‹/çµ‚äº†ã®æ‹¬å¼§ãŒãªã„ã®ã§ã€Python ã¯ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚¿ã‚¤ãƒ«ã®å¯¾ç«‹ãŒéå¸¸ã«èµ·ã“ã‚Šã«ãããªã‚Šã¾ã™ã€‚C "
"ã§ã¯å¤šæ§˜ãªã‚«ãƒƒã‚³ã®ç½®ãæ–¹ãŒã‚ã‚Šã¾ã™ã€‚ä¸€ã¤ã®ã‚¹ã‚¿ã‚¤ãƒ«ã§ã®ã‚³ãƒ¼ãƒ‰ã®èª­ã¿æ›¸ãã«æ…£ã‚Œã¦ã—ã¾ã†ã¨ã€ä»–ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’èª­ã‚€ (ã‚ã‚‹ã„ã¯æ›¸ãå¿…è¦ãŒã‚ã‚‹) "
"ã¨ãã«ã‚€ãšã‚€ãšã™ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/design.rst:36
msgid ""
"Many coding styles place begin/end brackets on a line by themselves.  This "
"makes programs considerably longer and wastes valuable screen space, making "
"it harder to get a good overview of a program.  Ideally, a function should "
"fit on one screen (say, 20--30 lines).  20 lines of Python can do a lot more"
" work than 20 lines of C.  This is not solely due to the lack of begin/end "
"brackets -- the lack of declarations and the high-level data types are also "
"responsible -- but the indentation-based syntax certainly helps."
msgstr ""
"å¤šãã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚¿ã‚¤ãƒ«ã¯ begin/end "
"ã®æ‹¬å¼§ã«ãã‚Œãã‚Œä¸€è¡Œã‚’ä½¿ã„ã¾ã™ã€‚ã“ã‚Œã§ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯å†—é•·ã«ãªã£ã¦ç”»é¢ã‚’æµªè²»ã—ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®è¦‹é€šã—ãŒæ‚ªããªã‚Šã¾ã™ã€‚ä¸€ã¤ã®é–¢æ•°ã¯ä¸€ç”»é¢ (ä¾‹ãˆã° 20 ã‹ã‚‰"
" 30 è¡Œ) ã«åã‚ã‚‹ã®ãŒç†æƒ³ã§ã™ã€‚20 è¡Œã® Python ã¯ 20 è¡Œã® C ã‚ˆã‚Šã‚‚ã¯ã‚‹ã‹ã«å¤šãã®ä½œæ¥­ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ begin/end "
"ã®æ‹¬å¼§ãŒãªã„ã‹ã‚‰ã ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ -- å®£è¨€ãŒä¸è¦ãªã“ã¨ã‚„é«˜ãƒ¬ãƒ™ãƒ«ãªãƒ‡ãƒ¼ã‚¿å‹ã‚‚ãã®ç†ç”±ã§ã™ -- ãŒã€ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã«åŸºã¥ãæ§‹æ–‡ã¯ç¢ºã‹ã«å½¹ã«ç«‹ã£ã¦ã„ã¾ã™ã€‚"

#: ../../faq/design.rst:46
msgid "Why am I getting strange results with simple arithmetic operations?"
msgstr "ãªãœå˜ç´”ãªç®—è¡“æ¼”ç®—ãŒå¥‡å¦™ãªçµæœã«ãªã‚‹ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:48
msgid "See the next question."
msgstr "æ¬¡ã®è³ªå•ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/design.rst:52
msgid "Why are floating-point calculations so inaccurate?"
msgstr "ãªã‚“ã§æµ®å‹•å°æ•°ç‚¹æ•°ã®è¨ˆç®—ã¯ã“ã‚“ãªã«ä¸æ­£ç¢ºãªã‚“ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:54
msgid "Users are often surprised by results like this::"
msgstr "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã‚ˆãæ¬¡ã®ã‚ˆã†ãªçµæœã«é©šãã¾ã™::"

#: ../../faq/design.rst:59
msgid ""
"and think it is a bug in Python.  It's not.  This has little to do with "
"Python, and much more to do with how the underlying platform handles "
"floating-point numbers."
msgstr ""
"ãã—ã¦ã“ã‚ŒãŒ Python ã®ãƒã‚°ã ã¨è€ƒãˆã¾ã™ã€‚ãŒã€ã“ã‚Œã¯ãƒã‚°ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®çµæœã« Python "
"ã¯ã»ã¨ã‚“ã©é–¢ä¸ã—ã¦ãŠã‚‰ãšã€ã‚€ã—ã‚åŸºåº•ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ã‚ˆã‚‹æµ®å‹•å°æ•°ç‚¹æ•°ã®æ‰±ã„æ–¹ãŒé–¢ä¸ã—ã¦ã„ã¾ã™ã€‚"

#: ../../faq/design.rst:63
msgid ""
"The :class:`float` type in CPython uses a C ``double`` for storage.  A "
":class:`float` object's value is stored in binary floating-point with a "
"fixed precision (typically 53 bits) and Python uses C operations, which in "
"turn rely on the hardware implementation in the processor, to perform "
"floating-point operations. This means that as far as floating-point "
"operations are concerned, Python behaves like many popular languages "
"including C and Java."
msgstr ""
"CPython ã«ãŠã‘ã‚‹ :class:`float` å‹ã¯è¨˜æ†¶ã« C è¨€èªã® ``double`` å‹ã‚’ä½¿ã„ã¾ã™ã€‚ :class:`float` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã¯å›ºå®šç²¾åº¦ (å…¸å‹çš„ã«ã¯ 53 bit) ã® 2 é€²æµ®å‹•å°æ•°ç‚¹æ•°ã¨ã—ã¦æ ¼ç´ã•ã‚Œã€ Python ã¯ãƒ—ãƒ­ã‚»ãƒƒã‚µã®ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãŒå®Ÿè£…ã—ã¦ã„ã‚‹"
" C è¨€èªä¸Šã®æ¼”ç®—ã‚’ä½¿ã„ã¾ã™ã€‚ã¤ã¾ã‚Šã€æµ®å‹•å°æ•°ç‚¹æ•°ã«é–¢ã—ã¦ Python ã¯ C è¨€èªã‚„ Java ã®ã‚ˆã†ãªå¤šãã®ä¸€èˆ¬çš„ãªè¨€èªã¨åŒã˜ã‚ˆã†ã«æŒ¯ã‚‹èˆã„ã¾ã™ã€‚"

#: ../../faq/design.rst:70
msgid ""
"Many numbers that can be written easily in decimal notation cannot be "
"expressed exactly in binary floating-point.  For example, after::"
msgstr "10 é€²æ•°ã§ç°¡å˜ã«æ›¸ã‘ã‚‹å¤šãã®æ•°ãŒã€2 é€²æµ®å‹•å°æ•°ç‚¹æ•°ã§ã¯æ­£ç¢ºã«è¡¨ã™ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã“ã†ã™ã‚‹ã¨::"

#: ../../faq/design.rst:75
msgid ""
"the value stored for ``x`` is a (very good) approximation to the decimal "
"value ``1.2``, but is not exactly equal to it.  On a typical machine, the "
"actual stored value is::"
msgstr ""
"``x`` ã«ä¿å­˜ã•ã‚ŒãŸå€¤ã¯ 10 é€²æ•°ã® ``1.2`` ã® (ã¨ã¦ã‚‚é«˜ã„ç²¾åº¦ã®) è¿‘ä¼¼å€¤ã§ã‚ã£ã¦ã€å³å¯†ãª ``1.2`` "
"ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¸€èˆ¬çš„ãªã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã§ã¯ã€å®Ÿéš›ã«æ ¼ç´ã•ã‚Œã‚‹å€¤ã¯::"

#: ../../faq/design.rst:81
msgid "which is exactly::"
msgstr "ã§ã€æ­£ç¢ºã«ã¯æ¬¡ã®å€¤ã§ã™::"

#: ../../faq/design.rst:85
msgid ""
"The typical precision of 53 bits provides Python floats with 15--16 decimal "
"digits of accuracy."
msgstr "53bit ã®å…¸å‹çš„ãªç²¾åº¦ã¯ã€Python ã® float ã« 10 é€²æ•°ã§ 15ã€œ16æ¡ã®ç²¾åº¦ã‚’ä¸ãˆã¾ã™ã€‚"

#: ../../faq/design.rst:88
msgid ""
"For a fuller explanation, please see the :ref:`floating point arithmetic "
"<tut-fp-issues>` chapter in the Python tutorial."
msgstr ""
"è©³ã—ãã¯ã€Python ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã® :ref:`floating point arithmetic <tut-fp-issues>` "
"ã®ç« ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/design.rst:93
msgid "Why are Python strings immutable?"
msgstr "ãªãœ Python ã®æ–‡å­—åˆ—ã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:95
msgid "There are several advantages."
msgstr "ã“ã‚Œã«ã¯ã„ãã¤ã‹ã®åˆ©ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/design.rst:97
msgid ""
"One is performance: knowing that a string is immutable means we can allocate"
" space for it at creation time, and the storage requirements are fixed and "
"unchanging.  This is also one of the reasons for the distinction between "
"tuples and lists."
msgstr ""
"ä¸€ã¤ã¯ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã§ã™ã€‚æ–‡å­—åˆ—ãŒã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚‰ã€ç”Ÿæˆæ™‚ã«é ˜åŸŸã‚’å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã€å¿…è¦ãªè¨˜æ†¶åŸŸã¯å›ºå®šã•ã‚Œã¦ã€å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã‚¿ãƒ—ãƒ«ã¨ãƒªã‚¹ãƒˆã‚’åŒºåˆ¥ã™ã‚‹ç†ç”±ã®ä¸€ã¤ã§ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/design.rst:102
msgid ""
"Another advantage is that strings in Python are considered as \"elemental\" "
"as numbers.  No amount of activity will change the value 8 to anything else,"
" and in Python, no amount of activity will change the string \"eight\" to "
"anything else."
msgstr ""
"ä»–ã®åˆ©ç‚¹ã¯ã€Python ã®æ–‡å­—åˆ—ã¯æ•°ã¨åŒã˜ãã‚‰ã„ \"åŸºæœ¬çš„\" ãªã‚‚ã®ã¨è€ƒãˆã‚‰ã‚Œã‚‹ã“ã¨ã§ã™ã€‚8 ã¨ã„ã†å€¤ã‚’ä»–ã®ä½•ã‹ã«å¤‰ãˆã‚‹æ‰‹æ®µãŒç„¡ã„ã‚ˆã†ã«ã€æ–‡å­—åˆ— "
"\"eight\" ã‚’ä»–ã®ä½•ã‹ã«å¤‰ãˆã‚‹æ‰‹æ®µã‚‚ç„¡ã„ã®ã§ã™ã€‚"

#: ../../faq/design.rst:110
msgid "Why must 'self' be used explicitly in method definitions and calls?"
msgstr "ãªãœãƒ¡ã‚½ãƒƒãƒ‰ã®å®šç¾©ã‚„å‘¼ã³å‡ºã—ã«ãŠã„ã¦ 'self' ã‚’æ˜ç¤ºã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:112
msgid ""
"The idea was borrowed from Modula-3.  It turns out to be very useful, for a "
"variety of reasons."
msgstr "ã“ã®ã‚¢ã‚¤ãƒ‡ã‚¢ã¯ Modula-3 ã‹ã‚‰å–ã‚Šå…¥ã‚Œã‚‰ã‚Œã¾ã—ãŸã€‚ã“ã‚Œã¯æ§˜ã€…ãªç†ç”±ã‹ã‚‰ã¨ã¦ã‚‚ä¾¿åˆ©ã ã¨è¨€ãˆã¾ã™ã€‚"

#: ../../faq/design.rst:115
msgid ""
"First, it's more obvious that you are using a method or instance attribute "
"instead of a local variable.  Reading ``self.x`` or ``self.meth()`` makes it"
" absolutely clear that an instance variable or method is used even if you "
"don't know the class definition by heart.  In C++, you can sort of tell by "
"the lack of a local variable declaration (assuming globals are rare or "
"easily recognizable) -- but in Python, there are no local variable "
"declarations, so you'd have to look up the class definition to be sure.  "
"Some C++ and Java coding standards call for instance attributes to have an "
"``m_`` prefix, so this explicitness is still useful in those languages, too."
msgstr ""
"ã¾ãšã€ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã§ã¯ãªãã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã‚’æ‰±ã£ã¦ã„ã‚‹ã“ã¨ãŒã‚ˆã‚Šæ˜ç¢ºã«ãªã‚Šã¾ã™ã€‚ ``self.x`` ã‚„ ``self.meth()`` "
"ã¨æ›¸ã„ã¦ã‚ã‚Œã°ã€ãã®ã‚¯ãƒ©ã‚¹ã®å®šç¾©ã‚’æ†¶ãˆã¦ã„ãªãã¦ã‚‚ã€ãã‚ŒãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚ã‚‹ã“ã¨ã¯æ˜ã‚‰ã‹ã§ã™ã€‚C++ "
"ã§ã¯ã€(ã‚°ãƒ­ãƒ¼ãƒãƒ«ãŒæ»…å¤šã«ãªã‹ã£ãŸã‚Šã€ç°¡å˜ã«è¦‹åˆ†ã‘ãŒã¤ããªã‚‰) ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°å®£è¨€ãŒãªã„ã“ã¨ã‹ã‚‰ã‚ã‚‹ç¨‹åº¦ã‚ã‹ã‚‹ã§ã—ã‚‡ã†ã€‚-- ã—ã‹ã— Python "
"ã«ã¯ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°å®£è¨€ãŒãªã„ã®ã§ã€ã‚¯ãƒ©ã‚¹å®šç¾©ã‚’èª¿ã¹ã¦ç¢ºã‹ã‚ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚C++ ã‚„ Java ã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ã«ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã« "
"``m_`` æ¥é ­è¾ã‚’ã¤ã‘ã‚‹ã‚‚ã®ãŒã‚ã‚‹ã®ã§ã€ã“ã®æ˜ç¤ºæ€§ã¯ãã‚Œã‚‰ã®è¨€èªã«ãŠã„ã¦ã‚‚æœ‰ç”¨ã§ã™ã€‚"

#: ../../faq/design.rst:125
msgid ""
"Second, it means that no special syntax is necessary if you want to "
"explicitly reference or call the method from a particular class.  In C++, if"
" you want to use a method from a base class which is overridden in a derived"
" class, you have to use the ``::`` operator -- in Python you can write "
"``baseclass.methodname(self, <argument list>)``.  This is particularly "
"useful for :meth:`__init__` methods, and in general in cases where a derived"
" class method wants to extend the base class method of the same name and "
"thus has to call the base class method somehow."
msgstr ""
"ç¬¬äºŒã«ã€ç‰¹å®šã®ã‚¯ãƒ©ã‚¹ã‹ã‚‰ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ˜ç¤ºçš„ã«å‚ç…§ã¾ãŸã¯å‘¼ã³å‡ºã—ã—ãŸã„æ™‚ã«ã€ç‰¹åˆ¥ãªæ§‹æ–‡ãŒå¿…è¦ãªããªã‚Šã¾ã™ã€‚C++ "
"ã§ã¯ã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã•ã‚ŒãŸåŸºåº•ã‚¯ãƒ©ã‚¹ã‹ã‚‰ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã«ã¯ã€ ``::`` æ¼”ç®—å­ã‚’ä½¿ã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ -- Python ã§ã¯ã€ "
"``baseclass.methodname(self, <argument list>)`` ã¨æ›¸ã‘ã¾ã™ã€‚ã“ã‚Œã¯ç‰¹ã«ã€ "
":meth:`__init__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã«ä¾¿åˆ©ã§ã™ã—ã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã€åŸºåº•ã‚¯ãƒ©ã‚¹ã«ã‚ã‚‹åŒã˜åå‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ‹¡å¼µã™ã‚‹ãŸã‚ã«ã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã©ã†ã«ã‹ã—ã¦å‘¼ã³å‡ºã—ãŸã„æ™‚ã«ã‚‚ä¾¿åˆ©ã§ã™ã€‚"

#: ../../faq/design.rst:134
msgid ""
"Finally, for instance variables it solves a syntactic problem with "
"assignment: since local variables in Python are (by definition!) those "
"variables to which a value is assigned in a function body (and that aren't "
"explicitly declared global), there has to be some way to tell the "
"interpreter that an assignment was meant to assign to an instance variable "
"instead of to a local variable, and it should preferably be syntactic (for "
"efficiency reasons).  C++ does this through declarations, but Python doesn't"
" have declarations and it would be a pity having to introduce them just for "
"this purpose.  Using the explicit ``self.var`` solves this nicely.  "
"Similarly, for using instance variables, having to write ``self.var`` means "
"that references to unqualified names inside a method don't have to search "
"the instance's directories.  To put it another way, local variables and "
"instance variables live in two different namespaces, and you need to tell "
"Python which namespace to use."
msgstr ""
"æœ€å¾Œã«ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã«å¯¾ã™ã‚‹ã€ä»£å…¥ã®æ§‹æ–‡ã®å•é¡Œã‚’è§£æ±ºã§ãã¾ã™ã€‚Python ã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã¯ã€é–¢æ•°ã®ä¸­ã§ (global "
"ãŒæ˜ç¤ºçš„ã«å®£è¨€ã•ã‚Œã‚‹ã“ã¨ãªã) å€¤ãŒä»£å…¥ã•ã‚ŒãŸå¤‰æ•° (ã¨å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ï¼) "
"ã§ã™ã€‚ãªã®ã§ã€ã‚ã‚‹ä»£å…¥ãŒæ„å›³ã™ã‚‹ã®ãŒã€ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã¸ã§ã¯ãªãã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã¸ã®ä»£å…¥ã§ã‚ã‚‹ã¨ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒåˆ¤æ–­ã™ã‚‹æ‰‹æ®µãŒå¿…è¦ã§ã™ã€‚ãã—ã¦ãã‚Œã¯æ§‹æ–‡ã‚’è¦‹ã‚‹ã ã‘ã§åˆ†ã‹ã‚‹æ–¹ãŒ"
" (åŠ¹ç‡ãŒ) è‰¯ã„ã®ã§ã™ã€‚C++ ã§ã¯ãã®åŒºåˆ¥ã‚’å®£è¨€æ™‚ã«è¡Œã„ã¾ã™ãŒã€Python ã§ã¯å®£è¨€ãŒãªã„ã®ã§ã€ã“ã®æ–¹æ³•ã§ã—ã‹åŒºåˆ¥ã§ããªã‹ã£ãŸã‚‰æ®‹å¿µã§ã™ã€‚ "
"``self.var`` ã‚’æ˜ç¤ºã™ã‚Œã°ã†ã¾ãè§£æ±ºã§ãã¾ã™ã€‚åŒæ§˜ã«ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‚’ä½¿ã†ã®ã«ã‚‚ ``self.var`` "
"ã¨æ›¸ã‹ãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã§ã€ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸­ã® self "
"ãŒä»˜ã„ã¦ã„ãªã„åå‰ã¸ã®å‚ç…§ã¯ã€ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æ¤œç´¢ã™ã‚‹ã¾ã§ã‚‚ãªããƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã¨ã‚ã‹ã‚Šã¾ã™ã€‚åˆ¥ã®è¨€ã„æ–¹ã‚’ã™ã‚Œã°ã€ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã¯äºŒã¤ã®ç•°ãªã‚‹åå‰ç©ºé–“ã«å­˜åœ¨ã—ã€Python"
" ã«ã©ã¡ã‚‰ã®åå‰ç©ºé–“ã‚’ä½¿ã†ã‹ã‚’ä¼ãˆãªãã¦ã¯ãªã‚‰ãªã„ã®ã§ã™ã€‚"

#: ../../faq/design.rst:150
msgid "Why can't I use an assignment in an expression?"
msgstr "å¼ä¸­ã§ä»£å…¥ãŒã§ããªã„ã®ã¯ãªãœã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:152
msgid ""
"Many people used to C or Perl complain that they want to use this C idiom:"
msgstr "C ã‚„ Perl ã«æ…£ã‚ŒãŸå¤šãã®äººã¯ã€C ã®ã“ã®æ…£ç”¨å¥ã‚’ä½¿ã„ãŸã„ã¨è¨´ãˆã¾ã™:"

#: ../../faq/design.rst:160
msgid "where in Python you're forced to write this::"
msgstr "Python ã§ã¯ã“ã†æ›¸ã‹ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“::"

#: ../../faq/design.rst:168
msgid ""
"The reason for not allowing assignment in Python expressions is a common, "
"hard-to-find bug in those other languages, caused by this construct:"
msgstr "Python ã®å¼ä¸­ã§ã®ä»£å…¥ã‚’è¨±ã•ãªã„ç†ç”±ã¯ã€ã“ã®æ§‹é€ ã«ã‚ˆã£ã¦èµ·ã“ã‚‹ã€ä»–ã®è¨€èªã§ã¯ã‚ã‚ŠãŒã¡ã§è¦‹ã¤ã‘ã¥ã‚‰ã„ãƒã‚°ã§ã™:"

#: ../../faq/design.rst:180
msgid ""
"The error is a simple typo: ``x = 0``, which assigns 0 to the variable "
"``x``, was written while the comparison ``x == 0`` is certainly what was "
"intended."
msgstr ""
"ã“ã®ã‚¨ãƒ©ãƒ¼ã¯å˜ç´”ãªã‚¿ã‚¤ãƒ—ãƒŸã‚¹ã§ã€æœ¬å½“ã«ã‚„ã‚ŠãŸã‹ã£ãŸã®ã¯ ``x == 0`` ã®æ¯”è¼ƒã§ã™ãŒã€ ``x = 0`` ã¨æ›¸ã„ã¦ã—ã¾ã„ã€å¤‰æ•° ``x`` ã« "
"0 ã‚’ä»£å…¥ã—ã¦ã„ã¾ã™ã€‚"

#: ../../faq/design.rst:183
msgid ""
"Many alternatives have been proposed.  Most are hacks that save some typing "
"but use arbitrary or cryptic syntax or keywords, and fail the simple "
"criterion for language change proposals: it should intuitively suggest the "
"proper meaning to a human reader who has not yet been introduced to the "
"construct."
msgstr ""
"ææ¡ˆã•ã‚ŒãŸä»£æ›¿æ¡ˆã¯ãŸãã•ã‚“ã‚ã‚Šã¾ã™ã€‚å¤šãã®æ¡ˆã¯ã‚¿ã‚¤ãƒ—æ•°ã‚’å°‘ã—ç¯€ç´„ã—ã¾ã™ãŒã€å‹æ‰‹ã ã£ãŸã‚Šæ„å‘³ä¸æ˜ã ã£ãŸã‚Šã™ã‚‹æ§‹æ–‡ã‚„äºˆç´„èªã‚’ä½¿ã„ã€è¨€èªå¤‰æ›´ã®ææ¡ˆã®ç°¡æ½”ã•ã®åŸºæº–ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“ã€‚æ§‹é€ ã®èª¬æ˜ã‚’ã•ã‚Œã¦ã„ãªã„äººé–“ã®èª­è€…ã«ã€æ­£ã—ã„æ„å‘³ã‚’ç›´æ„Ÿçš„ã«ç¤ºã™ç‰©ã§ã‚ã‚‹ã¹ãã§ã™ã€‚"

#: ../../faq/design.rst:188
msgid ""
"An interesting phenomenon is that most experienced Python programmers "
"recognize the ``while True`` idiom and don't seem to be missing the "
"assignment in expression construct much; it's only newcomers who express a "
"strong desire to add this to the language."
msgstr ""
"é¢ç™½ã„ã“ã¨ã«ã€ç†Ÿç·´ã—ãŸ Python ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ ``while True`` "
"ã‚¤ãƒ‡ã‚£ã‚ªãƒ ã‚’å—ã‘å…¥ã‚Œã¦ã„ã¦ã€å¼æ§‹é€ ä¸­ã®ä»£å…¥ãŒãªãã¦ã‚‚ãã‚Œã»ã©è‹¦åŠ´ã—ãªã„ã‚ˆã†ã§ã™ã€‚Python ã«ãã‚Œã‚’å¼·ãæ±‚ã‚ã‚‹ã®ã¯æ–°äººã ã‘ã§ã™ã€‚"

#: ../../faq/design.rst:193
msgid ""
"There's an alternative way of spelling this that seems attractive but is "
"generally less robust than the \"while True\" solution::"
msgstr "ä»¥ä¸‹ã®æ–¹æ³•ã§ã‚‚ã“ã‚Œã‚’ç¶´ã‚‹ã“ã¨ãŒã§ãã¦ã€é­…åŠ›çš„ãã†ã§ã™ãŒã€å …ç‰¢ã•ã§ã¯ \"while True\" ã‚’ä½¿ã†æ–¹æ³•ã«åŠ£ã‚‹ã“ã¨ãŒå¤šã„ã§ã™::"

#: ../../faq/design.rst:201
msgid ""
"The problem with this is that if you change your mind about exactly how you "
"get the next line (e.g. you want to change it into ``sys.stdin.readline()``)"
" you have to remember to change two places in your program -- the second "
"occurrence is hidden at the bottom of the loop."
msgstr ""
"ã“ã®æ–¹æ³•ã®å•é¡Œã¯ã€æ¬¡ã®è¡Œã‚’å–å¾—ã™ã‚‹æ–¹æ³•ã‚’å¤‰ãˆãŸããªã£ãŸã¨ã (``sys.stdin.readline()`` ã«å¤‰æ›´ã—ãŸã„æ™‚ãªã©) "
"ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®äºŒç®‡æ‰€ã‚’å¤‰ãˆãªãã¦ã¯ãªã‚‰ãªã„ã“ã¨ã§ã™ -- äºŒã¤ç›®ã®å ´æ‰€ã¯ãƒ«ãƒ¼ãƒ—ã®æœ€å¾Œã«éš ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../faq/design.rst:206
msgid ""
"The best approach is to use iterators, making it possible to loop through "
"objects using the ``for`` statement.  For example, :term:`file objects <file"
" object>` support the iterator protocol, so you can write simply::"
msgstr ""
"ä¸€ç•ªã„ã„æ–¹æ³•ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ã£ã¦ã€ ``for`` æ–‡ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é€šã—ã¦ãƒ«ãƒ¼ãƒ—ã•ã›ã‚‹ã“ã¨ã§ã™ã€‚ä¾‹ãˆã°ã€ :term:`ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ "
"<file object>` ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã®ã§ã€å˜ç´”ã«ã“ã†æ›¸ã‘ã¾ã™::"

#: ../../faq/design.rst:216
msgid ""
"Why does Python use methods for some functionality (e.g. list.index()) but "
"functions for other (e.g. len(list))?"
msgstr "Python ã«ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†æ©Ÿèƒ½ (list.index() ç­‰) ã¨é–¢æ•°ã‚’ä½¿ã†æ©Ÿèƒ½ (len(list) ç­‰) ãŒã‚ã‚‹ã®ã¯ãªãœã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:218
msgid "As Guido said:"
msgstr ""

#: ../../faq/design.rst:220
msgid ""
"(a) For some operations, prefix notation just reads better than postfix -- "
"prefix (and infix!) operations have a long tradition in mathematics which "
"likes notations where the visuals help the mathematician thinking about a "
"problem. Compare the easy with which we rewrite a formula like x*(a+b) into "
"x*a + x*b to the clumsiness of doing the same thing using a raw OO notation."
msgstr ""

#: ../../faq/design.rst:227
msgid ""
"(b) When I read code that says len(x) I *know* that it is asking for the "
"length of something. This tells me two things: the result is an integer, and"
" the argument is some kind of container. To the contrary, when I read "
"x.len(), I have to already know that x is some kind of container "
"implementing an interface or inheriting from a class that has a standard "
"len(). Witness the confusion we occasionally have when a class that is not "
"implementing a mapping has a get() or keys() method, or something that isn't"
" a file has a write() method."
msgstr ""

#: ../../faq/design.rst:254
msgid ""
"https://mail.python.org/pipermail/python-3000/2006-November/004643.html"
msgstr ""

#: ../../faq/design.rst:240
msgid "Why is join() a string method instead of a list or tuple method?"
msgstr "join() ãŒãƒªã‚¹ãƒˆã‚„ã‚¿ãƒ—ãƒ«ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ãªãæ–‡å­—åˆ—ã®ãƒ¡ã‚½ãƒƒãƒ‰ãªã®ã¯ãªãœã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:242
msgid ""
"Strings became much more like other standard types starting in Python 1.6, "
"when methods were added which give the same functionality that has always "
"been available using the functions of the string module.  Most of these new "
"methods have been widely accepted, but the one which appears to make some "
"programmers feel uncomfortable is::"
msgstr ""
"æ–‡å­—åˆ—ã¯ Python 1.6 ã‹ã‚‰ä»–ã®æ¨™æº–å‹ã«å¤§ããè¿‘ã¥ãã¾ã—ãŸã€‚ãã‚Œä»¥å‰ã¯å¸¸ã« string "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–¢æ•°ã‚’ä½¿ã£ã¦ã§ãã¦ã„ãŸã“ã¨ã¨åŒç­‰ã®æ©Ÿèƒ½ã‚’æŒã¤ãƒ¡ã‚½ãƒƒãƒ‰ãŒã“ã®æ™‚ã«è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ãã®æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã®å¤šãã¯åºƒãå—ã‘å…¥ã‚Œã‚‰ã‚Œã¾ã—ãŸãŒã€ä¸€éƒ¨ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒã«ä¸å¿«ã‚’æ„Ÿã˜ã•ã›ã¦ã„ã‚‹ã¨æ€ã‚ã‚Œã‚‹ã‚‚ã®ãŒã“ã‚Œã§::"

#: ../../faq/design.rst:250
msgid "which gives the result::"
msgstr "çµæœã¯ã“ã†ãªã‚Šã¾ã™::"

#: ../../faq/design.rst:254
msgid "There are two common arguments against this usage."
msgstr "ã“ã®ä½¿ã„æ–¹ã«ã¯äºŒã¤ã®è­°è«–ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/design.rst:256
msgid ""
"The first runs along the lines of: \"It looks really ugly using a method of "
"a string literal (string constant)\", to which the answer is that it might, "
"but a string literal is just a fixed value. If the methods are to be allowed"
" on names bound to strings there is no logical reason to make them "
"unavailable on literals."
msgstr ""
"ä¸€ã¤ç›®ã¯ã€ã€Œæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ« (æ–‡å­—åˆ—å®šæ•°) "
"ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã®ã¯é†œã™ãã‚‹ã€ã¨ã„ã†ã‚ˆã†ãªã‚‚ã®ã§ã™ã€‚ç¢ºã‹ã«ãã†ã‹ã‚‚çŸ¥ã‚Œã¾ã›ã‚“ãŒã€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¯å˜ãªã‚‹å›ºå®šã•ã‚ŒãŸå€¤ã«éããªã„ã¨ã„ã†ã®ãŒç­”ãˆã§ã™ã€‚æ–‡å­—åˆ—ã«æŸç¸›ã•ã‚ŒãŸåå‰ã«ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¨±ã•ã‚Œã‚‹ãªã‚‰ã€ãƒªãƒ†ãƒ©ãƒ«ã«ä½¿ãˆãªã„ã‚ˆã†ã«ã™ã‚‹è«–ç†çš„ãªç†ç”±ã¯ãªã„ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/design.rst:262
msgid ""
"The second objection is typically cast as: \"I am really telling a sequence "
"to join its members together with a string constant\".  Sadly, you aren't.  "
"For some reason there seems to be much less difficulty with having "
":meth:`~str.split` as a string method, since in that case it is easy to see "
"that ::"
msgstr ""
"äºŒã¤ç›®ã®åå¯¾ç†ç”±ã¯ã€å…¸å‹çš„ã«ã¯ã€Œç§ã¯å®Ÿéš›ã€è¦ç´ ã‚’æ–‡å­—åˆ—å®šæ•°ã¨ã¨ã‚‚ã«çµåˆã•ã›ã‚‹ã‚ˆã†ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«å‘½ã˜ã¦ã„ã‚‹ã®ã ã€ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚æ®‹å¿µãªãŒã‚‰ã€ãã†ã§ã¯ãªã„ã®ã§ã™ã€‚ã„ãã¤ã‹ã®ç†ç”±ã‹ã‚‰"
" :meth:`~str.split` ã‚’æ–‡å­—åˆ—ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦ãŠã„ãŸæ–¹ãŒã¯ã‚‹ã‹ã«ç°¡å˜ã§ã™ã€‚ã“ã‚Œã‚’è¦‹ã‚‹ã¨åˆ†ã‹ã‚Šã‚„ã™ã„ã§ã—ã‚‡ã† ::"

#: ../../faq/design.rst:269
msgid ""
"is an instruction to a string literal to return the substrings delimited by "
"the given separator (or, by default, arbitrary runs of white space)."
msgstr ""
"ã“ã‚Œã¯æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«å¯¾ã™ã‚‹ã€ä¸ãˆã‚‰ã‚ŒãŸã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ (ã¾ãŸã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ä»»æ„ã®ç©ºç™½æ–‡å­—ã®é€£ç¶š) ã§åŒºåˆ‡ã‚‰ã‚ŒãŸéƒ¨åˆ†æ–‡å­—åˆ—ã‚’è¿”ã›ã¨ã„ã†æŒ‡ç¤ºã§ã™ã€‚"

#: ../../faq/design.rst:272
msgid ""
":meth:`~str.join` is a string method because in using it you are telling the"
" separator string to iterate over a sequence of strings and insert itself "
"between adjacent elements.  This method can be used with any argument which "
"obeys the rules for sequence objects, including any new classes you might "
"define yourself. Similar methods exist for bytes and bytearray objects."
msgstr ""
":meth:`~str.join` "
"ã¯ã€ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿æ–‡å­—åˆ—ã«ã€æ–‡å­—åˆ—ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã—ã¦éš£ã‚Šåˆã†è¦ç´ ã®é–“ã«è‡ªèº«ã‚’æŒ¿å…¥ã™ã‚‹ã‚ˆã†ã«æŒ‡ç¤ºã—ã¦ã„ã‚‹ã®ã§ã€æ–‡å­—åˆ—ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ç‹¬è‡ªã«å®šç¾©ã•ã‚ŒãŸæ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚’å«ã‚ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®è¦å‰‡ã‚’æº€ãŸã™ã„ã‹ãªã‚‹å¼•æ•°ã«ã‚‚ä½¿ãˆã¾ã™ã€‚ãƒã‚¤ãƒˆåˆ—ã‚„ãƒã‚¤ãƒˆé…åˆ—ã«ã‚‚åŒæ§˜ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/design.rst:280
msgid "How fast are exceptions?"
msgstr "ä¾‹å¤–ã¯ã©ã‚Œãã‚‰ã„é€Ÿã„ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:282
msgid ""
"A try/except block is extremely efficient if no exceptions are raised.  "
"Actually catching an exception is expensive.  In versions of Python prior to"
" 2.0 it was common to use this idiom::"
msgstr ""
"try/except ãƒ–ãƒ­ãƒƒã‚¯ã¯ä¾‹å¤–ãŒé€å‡ºã•ã‚Œãªã‘ã‚Œã°æ¥µç«¯ã«åŠ¹ç‡çš„ã§ã™ã€‚å®Ÿéš›ã«ä¾‹å¤–ã‚’æ•æ‰ã™ã‚‹ã®ã¯é«˜ä¾¡ã§ã™ã€‚Python 2.0 "
"ã‚ˆã‚Šå‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ã“ã®ã‚¤ãƒ‡ã‚£ã‚ªãƒ ã‚’ä½¿ã†ã®ãŒä¸€èˆ¬çš„ã§ã—ãŸ::"

#: ../../faq/design.rst:292
msgid ""
"This only made sense when you expected the dict to have the key almost all "
"the time.  If that wasn't the case, you coded it like this::"
msgstr "ã“ã‚Œã¯ã€è¾æ›¸ãŒã»ã¨ã‚“ã©ã®å ´åˆã«ã‚­ãƒ¼ã‚’æŒã£ã¦ã„ã‚‹ã¨äºˆæƒ³ã§ãã‚‹ã¨ãã«ã®ã¿æ„å‘³ã‚’ãªã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ã“ã®ã‚ˆã†ã«æ›¸ãã¾ã™::"

#: ../../faq/design.rst:300
msgid ""
"For this specific case, you could also use ``value = dict.setdefault(key, "
"getvalue(key))``, but only if the ``getvalue()`` call is cheap enough "
"because it is evaluated in all cases."
msgstr ""
"ã“ã®ç‰¹æ®Šãªå ´åˆã§ã¯ ``value = dict.setdefault(key, getvalue(key))`` ã‚‚ä½¿ãˆã¾ã™ãŒã€ã“ã‚Œã¯ "
"``getvalue()`` å‘¼ã³å‡ºã—ãŒååˆ†å®‰ä¾¡ãªå ´åˆã«é™ã‚Šã¾ã™ã€‚ãªãœãªã‚‰ãã‚ŒãŒå…¨ã¦ã®å ´åˆã«è©•ä¾¡ã•ã‚Œã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../faq/design.rst:306
msgid "Why isn't there a switch or case statement in Python?"
msgstr "Python ã« switch ã‚„ case æ–‡ãŒãªã„ã®ã¯ãªãœã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:308
msgid ""
"You can do this easily enough with a sequence of ``if... elif... elif... "
"else``. There have been some proposals for switch statement syntax, but "
"there is no consensus (yet) on whether and how to do range tests.  See "
":pep:`275` for complete details and the current status."
msgstr ""
"``if... elif... elif... else`` ã®ç¹°ã‚Šè¿”ã—ã§ç°¡å˜ã«åŒã˜ã“ã¨ãŒã§ãã¾ã™ã€‚switch "
"æ–‡ã®æ§‹æ–‡ã«é–¢ã™ã‚‹ææ¡ˆãŒã„ãã¤ã‹ã‚ã‚Šã¾ã—ãŸãŒã€ç¯„å›²åˆ¤å®šã‚’ã™ã‚‹ã¹ãã‹ã€ã‚ã‚‹ã„ã¯ã©ã®ã‚ˆã†ã«ã™ã‚‹ã¹ãã‹ã«ã¤ã„ã¦ã®åˆæ„ã¯ (ã¾ã ) "
"å¾—ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ç¾åœ¨ã®çŠ¶æ³ã®å®Œå…¨ãªè©³ç´°ã¯ :pep:`275` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/design.rst:313
msgid ""
"For cases where you need to choose from a very large number of "
"possibilities, you can create a dictionary mapping case values to functions "
"to call.  For example::"
msgstr "éå¸¸ã«å¤§ããªæ•°ã®é¸æŠè‚¢ã‹ã‚‰é¸ã¶ã¨ãã€å€¤ã‚’å‘¼ã³å‡ºã™é–¢æ•°ã«å¯¾å¿œã¥ã‘ã‚‹è¾æ›¸ã‚’ä½œã‚Œã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../faq/design.rst:327
msgid ""
"For calling methods on objects, you can simplify yet further by using the "
":func:`getattr` built-in to retrieve methods with a particular name::"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã«ã¯ã€ã•ã‚‰ã«å˜ç´”ã« :func:`getattr` çµ„ã¿è¾¼ã¿é–¢æ•°ã§ç‰¹å®šã®åå‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ¤œç´¢ã§ãã¾ã™::"

#: ../../faq/design.rst:339
msgid ""
"It's suggested that you use a prefix for the method names, such as "
"``visit_`` in this example.  Without such a prefix, if values are coming "
"from an untrusted source, an attacker would be able to call any method on "
"your object."
msgstr ""
"ãƒ¡ã‚½ãƒƒãƒ‰ã®åå‰ã«ã“ã®ä¾‹ã® ``visit_`` "
"ã®ã‚ˆã†ãªæ¥é ­è¾ã‚’ä½¿ã†ã“ã¨ã‚’å‹§ã‚ã¾ã™ã€‚ã“ã®ã‚ˆã†ãªæ¥é ­è¾ãŒãªã„ã¨ã€ä¿¡é ¼ã§ããªã„ã‚½ãƒ¼ã‚¹ã‹ã‚‰å€¤ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»»æ„ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™æ”»æ’ƒã‚’ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/design.rst:345
msgid ""
"Can't you emulate threads in the interpreter instead of relying on an OS-"
"specific thread implementation?"
msgstr "OS ç‰¹æœ‰ã®ã‚¹ãƒ¬ãƒƒãƒ‰å®Ÿè£…ã«ä¾ã‚‰ãšã«ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã§ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã“ã¨ã¯ã§ããªã„ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:347
msgid ""
"Answer 1: Unfortunately, the interpreter pushes at least one C stack frame "
"for each Python stack frame.  Also, extensions can call back into Python at "
"almost random moments.  Therefore, a complete threads implementation "
"requires thread support for C."
msgstr ""
"ç­” 1: æ®‹å¿µãªã“ã¨ã«ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ Python ã®ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«å°‘ãªãã¨ã‚‚ä¸€ã¤ã® C ã®ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ push "
"ã—ã¾ã™ã€‚åŒæ§˜ã«ã€æ‹¡å¼µã‚‚ã»ã¨ã‚“ã©ãƒ©ãƒ³ãƒ€ãƒ ãªã¨ãã« Python ã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã‚ˆã£ã¦ã€å®Œå…¨ãªã‚¹ãƒ¬ãƒƒãƒ‰å®Ÿè£…ã«ã¯ C "
"ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚µãƒãƒ¼ãƒˆãŒå¿…è¦ã§ã™ã€‚"

#: ../../faq/design.rst:352
msgid ""
"Answer 2: Fortunately, there is `Stackless Python "
"<http://www.stackless.com>`_, which has a completely redesigned interpreter "
"loop that avoids the C stack."
msgstr ""
"ç­” 2: å¹¸é‹ãªã“ã¨ã«ã€å®Œå…¨ã«å†è¨­è¨ˆã•ã‚ŒãŸ C ã‚¹ã‚¿ãƒƒã‚¯ã‚’ä½¿ã‚ãªã„ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãƒ«ãƒ¼ãƒ—ã‚’æŒã¤ã€ `Stackless Python "
"<http://www.stackless.com>`_ ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/design.rst:357
msgid "Why can't lambda expressions contain statements?"
msgstr "ãªãœãƒ©ãƒ ãƒ€å¼ã¯æ–‡ã‚’å«ã‚€ã“ã¨ãŒã§ããªã„ã®ã§ã™ã‹?"

#: ../../faq/design.rst:359
msgid ""
"Python lambda expressions cannot contain statements because Python's "
"syntactic framework can't handle statements nested inside expressions.  "
"However, in Python, this is not a serious problem.  Unlike lambda forms in "
"other languages, where they add functionality, Python lambdas are only a "
"shorthand notation if you're too lazy to define a function."
msgstr ""
"Python ã®ãƒ©ãƒ ãƒ€å¼ãŒæ–‡ã‚’å«ã‚€ã“ã¨ãŒã§ããªã„ã®ã¯ã€Python "
"ã®æ–‡æ³•çš„ãªæ çµ„ã¿ãŒå¼ã®ä¸­ã«ãƒã‚¹ãƒˆã•ã‚ŒãŸæ–‡ã‚’æ‰±ã†ã“ã¨ãŒã§ããªã„ã‹ã‚‰ã§ã™ã€‚ã—ã‹ã—ã€Python "
"ã§ã¯ã€ã“ã‚Œã¯æ·±åˆ»ãªå•é¡Œã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä»–ã®è¨€èªã®ãƒ©ãƒ ãƒ€ã«æ©Ÿèƒ½ãŒè¿½åŠ ã•ã‚Œã¦ã„ã‚‹ã®ã¨é•ã„ã€Python "
"ã®ãƒ©ãƒ ãƒ€ã¯å˜ãªã‚‹ã€é–¢æ•°ã‚’å®šç¾©ã™ã‚‹ã®ãŒé¢å€’ã™ãã‚‹å ´åˆã®ãŸã‚ã®ç°¡ç•¥ãªè¨˜æ³•ã«éããªã„ã®ã§ã™ã€‚"

#: ../../faq/design.rst:365
msgid ""
"Functions are already first class objects in Python, and can be declared in "
"a local scope.  Therefore the only advantage of using a lambda instead of a "
"locally-defined function is that you don't need to invent a name for the "
"function -- but that's just a local variable to which the function object "
"(which is exactly the same type of object that a lambda expression yields) "
"is assigned!"
msgstr ""
"é–¢æ•°ã¯æ—¢ã« Python "
"ã®ç¬¬ä¸€ç´šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—å†…ã§å®£è¨€ã§ãã¾ã™ã€‚å¾“ã£ã¦ã€ãƒ­ãƒ¼ã‚«ãƒ«ã§å®šç¾©ã•ã‚ŒãŸé–¢æ•°ã§ã¯ãªããƒ©ãƒ ãƒ€ã‚’ä½¿ã†åˆ©ç‚¹ã¯ã€é–¢æ•°ã®åå‰ã‚’è€ƒãˆã‚‹å¿…è¦ãŒç„¡ã„ã“ã¨ã ã‘ã§ã™"
" -- ã—ã‹ã—ã€(ãƒ©ãƒ ãƒ€å¼ãŒç”Ÿã¿å‡ºã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨å³å¯†ã«åŒã˜å‹ã®) é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä»£å…¥ã•ã‚Œã‚‹å…ˆã¯ãŸã ã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã§ã™ï¼"

#: ../../faq/design.rst:373
msgid "Can Python be compiled to machine code, C or some other language?"
msgstr "Python ã¯ C ã‚„ãã®ä»–ã®è¨€èªã®ã‚ˆã†ã«æ©Ÿæ¢°èªã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:375
msgid ""
"`Cython <http://cython.org/>`_ compiles a modified version of Python with "
"optional annotations into C extensions.  `Nuitka <http://www.nuitka.net/>`_ "
"is an up-and-coming compiler of Python into C++ code, aiming to support the "
"full Python language. For compiling to Java you can consider `VOC "
"<https://voc.readthedocs.io>`_."
msgstr ""
"`Cython <http://cython.org/>`_ ã¯ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãã®Pythonã®ä¿®æ­£ç‰ˆã‚’ "
"Cæ‹¡å¼µã¸å¤‰æ›ã—ã¾ã™ã€‚`Nuitka <http://www.nuitka.net/>`_ "
"ã¯Pythonã‚’C++ã‚³ãƒ¼ãƒ‰ã¸å¤‰æ›ã™ã‚‹å°†æ¥æœ‰æœ›ãªPythonã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã§ã€å®Œå…¨ãªPythonè¨€èªã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã‚’ç›®çš„ã¨ã—ã¦ã„ã¾ã™ã€‚Javaã¸ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã™ã‚‹ã«ã¯ã€"
" `VOC <https://voc.readthedocs.io>`_ ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/design.rst:383
msgid "How does Python manage memory?"
msgstr "Python ã¯ãƒ¡ãƒ¢ãƒªã‚’ã©ã®ã‚ˆã†ã«ç®¡ç†ã™ã‚‹ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:385
msgid ""
"The details of Python memory management depend on the implementation.  The "
"standard implementation of Python, :term:`CPython`, uses reference counting "
"to detect inaccessible objects, and another mechanism to collect reference "
"cycles, periodically executing a cycle detection algorithm which looks for "
"inaccessible cycles and deletes the objects involved. The :mod:`gc` module "
"provides functions to perform a garbage collection, obtain debugging "
"statistics, and tune the collector's parameters."
msgstr ""
"Python ã®ãƒ¡ãƒ¢ãƒªç®¡ç†ã®è©³ç´°ã¯å®Ÿè£…ã«ä¾ã‚Šã¾ã™ã€‚Python ã®æ¨™æº–ã® C å®Ÿè£… :term:`CPython` "
"ã¯å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½¿ã£ã¦ã€ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¢ã—ã¾ã™ã€‚ã¾ãŸåˆ¥ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’ä½¿ã£ã¦å‚ç…§ã‚µã‚¤ã‚¯ãƒ«ã‚’é›†ã‚ã¾ã™ã€‚ã“ã‚Œã¯ã‚µã‚¤ã‚¯ãƒ«æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®šæœŸçš„ã«å®Ÿè¡Œã—ã€ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„ã‚µã‚¤ã‚¯ãƒ«ã‚’æ¢ã—ã€å·»ãè¾¼ã¾ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã€‚"
" :mod:`gc` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–¢æ•°ã§ã€ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã€ãƒ‡ãƒãƒƒã‚°çµ±è¨ˆã‚’å–å¾—ã—ã€ã‚³ãƒ¬ã‚¯ã‚¿ã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚"

#: ../../faq/design.rst:393
msgid ""
"Other implementations (such as `Jython <http://www.jython.org>`_ or `PyPy "
"<http://www.pypy.org>`_), however, can rely on a different mechanism such as"
" a full-blown garbage collector.  This difference can cause some subtle "
"porting problems if your Python code depends on the behavior of the "
"reference counting implementation."
msgstr ""
"ãŸã ã—ã€ä»–ã®å®Ÿè£… (ä¾‹ãˆã° `Jython <http://www.jython.org>`_ ã‚„ `PyPy "
"<http://www.pypy.org>`_) ã¯æœ¬æ ¼çš„ (full-blown) "
"ãªã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ã®ã‚ˆã†ãªåˆ¥ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã«ä¾å­˜ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚ãªãŸã® Python "
"ã‚³ãƒ¼ãƒ‰ãŒå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã®å®Ÿè£…ã®æŒ¯ã‚‹èˆã„ã«ä¾å­˜ã™ã‚‹å ´åˆã€ã“ã®é•ã„ãŒå¾®å¦™ãªç§»æ¤ä¸Šã®å•é¡Œã‚’å¼•ãèµ·ã“ã™ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/design.rst:399
msgid ""
"In some Python implementations, the following code (which is fine in "
"CPython) will probably run out of file descriptors::"
msgstr "Python ã®å®Ÿè£…ã«ã‚ˆã£ã¦ã¯ã€ä»¥ä¸‹ã® (CPython ã§ã¯é€šã‚‹) ã‚³ãƒ¼ãƒ‰ã¯ãŠãã‚‰ãã€ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’ä½¿ã„æœãŸã™ã§ã—ã‚‡ã†::"

#: ../../faq/design.rst:406
msgid ""
"Indeed, using CPython's reference counting and destructor scheme, each new "
"assignment to *f* closes the previous file.  With a traditional GC, however,"
" those file objects will only get collected (and closed) at varying and "
"possibly long intervals."
msgstr ""
"å®Ÿéš›ã€CPython ã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¨ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ã‚¹ã‚­ãƒ¼ãƒ ã‚’ä½¿ãˆã° *f* ã¸ã®æ–°ã—ã„ä»£å…¥ã”ã¨ã«ãƒ•ã‚¡ã‚¤ãƒ«ã¯é–‰ã˜ã‚‰ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€ä¼çµ±çš„ãª GC "
"ã‚’ä½¿ã†ã¨ã€ã“ã‚Œã‚‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå›åã•ã‚Œ (ã¦é–‰ã˜ã‚‰ã‚Œã‚‹) ã¾ã§ã«ä¸å®šãªã€å ´åˆã«ã‚ˆã£ã¦ã¯é•·ã„ã€é–“éš”ãŒç©ºãã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/design.rst:411
msgid ""
"If you want to write code that will work with any Python implementation, you"
" should explicitly close the file or use the :keyword:`with` statement; this"
" will work regardless of memory management scheme::"
msgstr ""
"Python ã®å®Ÿè£…ã«ä¾ã‚‰ãšã«å‹•ãã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã«ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ˜ç¤ºçš„ã«é–‰ã˜ã‚‹ã‹ã€ :keyword:`with` "
"æ–‡ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ã“ã‚Œã§ãƒ¡ãƒ¢ãƒªç®¡ç†ã®ã‚¹ã‚­ãƒ¼ãƒ ã«é–¢ä¿‚ãªãå‹•ãã¾ã™::"

#: ../../faq/design.rst:421
msgid "Why doesn't CPython use a more traditional garbage collection scheme?"
msgstr "CPython ã¯ãªãœä¼çµ±çš„ãªã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚¹ã‚­ãƒ¼ãƒ ã‚’ä½¿ã‚ãªã„ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:423
msgid ""
"For one thing, this is not a C standard feature and hence it's not portable."
" (Yes, we know about the Boehm GC library.  It has bits of assembler code "
"for *most* common platforms, not for all of them, and although it is mostly "
"transparent, it isn't completely transparent; patches are required to get "
"Python to work with it.)"
msgstr ""
"ã¾ãšã€ãã‚Œã¯ C ã®æ¨™æº–çš„ãªæ©Ÿèƒ½ã§ã¯ãªã„ã®ã§ãƒãƒ¼ã‚¿ãƒ–ãƒ«ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚(ç¢ºã‹ã« Boehm GC "
"ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã‚ã‚Šã¾ã™ã€‚ã—ã‹ã—ã€ã“ã‚Œã«ã¯ã‚¢ã‚»ãƒ³ãƒ–ãƒªã‚³ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã€*ã»ã¨ã‚“ã©ã®* "
"æœ‰åãªãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«å¯¾å¿œã—ã¦ã„ã¾ã™ãŒå…¨ã¦ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãŸã€ã»ã¨ã‚“ã©é€éçš„ã§ã™ãŒã€å®Œå…¨ã«é€éçš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚Python "
"ã‚’å¯¾å¿œã•ã›ã‚‹ã«ã¯ãƒ‘ãƒƒãƒãŒå¿…è¦ã§ã™ã€‚)"

#: ../../faq/design.rst:429
msgid ""
"Traditional GC also becomes a problem when Python is embedded into other "
"applications.  While in a standalone Python it's fine to replace the "
"standard malloc() and free() with versions provided by the GC library, an "
"application embedding Python may want to have its *own* substitute for "
"malloc() and free(), and may not want Python's.  Right now, CPython works "
"with anything that implements malloc() and free() properly."
msgstr ""
"ä¼çµ±çš„ãª GC ã¯ Python ãŒä»–ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«çµ„ã¿è¾¼ã¾ã‚Œã‚‹ã¨ãã«ã‚‚å•é¡Œã¨ãªã‚Šã¾ã™ã€‚ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ã® Python ã§å‹•ãé™ã‚Šã§ã¯ã€æ¨™æº–ã® "
"malloc() ã¨ free() ã‚’ GC ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‹ã‚‰æä¾›ã•ã‚Œã‚‹ã‚‚ã®ã«ç½®ãæ›ãˆã¦ã‚‚å•é¡Œã‚ã‚Šã¾ã›ã‚“ãŒã€Python ã‚’å®Ÿè£…ã—ãŸã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ "
"Python ã®ã‚‚ã®ã§ã¯ãªã„ *ç‹¬è‡ªã®* ä»£æ›¿å“ã‚’ä½¿ãŠã†ã¨ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ç¾åœ¨ã®ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã€CPython ã¯ malloc() ã¨ "
"free() ãŒé©åˆ‡ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹é™ã‚Šã©ã‚“ãªã‚‚ã®ã«ã‚‚å¯¾å¿œã•ã›ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../faq/design.rst:438
msgid "Why isn't all memory freed when CPython exits?"
msgstr "ãªãœ CPython ã®çµ‚äº†æ™‚ã«ã™ã¹ã¦ã®ãƒ¡ãƒ¢ãƒªãŒè§£æ”¾ã•ã‚Œã‚‹ã‚ã‘ã§ã¯ãªã„ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:440
msgid ""
"Objects referenced from the global namespaces of Python modules are not "
"always deallocated when Python exits.  This may happen if there are circular"
" references.  There are also certain bits of memory that are allocated by "
"the C library that are impossible to free (e.g. a tool like Purify will "
"complain about these).  Python is, however, aggressive about cleaning up "
"memory on exit and does try to destroy every single object."
msgstr ""
"Python ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰ç©ºé–“ã‹ã‚‰å‚ç…§ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€Python "
"ã®çµ‚äº†æ™‚ã«ãƒ¡ãƒ¢ãƒªã®å‰²ã‚Šå½“ã¦ã‚’è§£é™¤ã•ã‚Œã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€å¾ªç’°å‚ç…§ãŒã‚ã‚‹ã¨ãã«èµ·ã“ã‚Šãˆã¾ã™ã€‚è§£æ”¾ã§ããªã„ C ãƒ©ã‚¤ãƒ–ãƒ©ãƒª (ä¾‹ãˆã°ã€Purify "
"ã®ã‚ˆã†ãªãƒ„ãƒ¼ãƒ«ãªã©ãŒå½“ã¦ã¯ã¾ã‚Šã¾ã™) ã«ã‚ˆã£ã¦å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸã„ãã‚‰ã‹ã®ãƒ¡ãƒ¢ãƒªã‚‚å«ã¾ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€Python "
"ã¯çµ‚äº†æ™‚ã«ãƒ¡ãƒ¢ãƒªã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹ã“ã¨ã«ã¯ç©æ¥µçš„ã§ã€å…¨ã¦ã®å˜ä¸€ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç ´æ£„ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚"

#: ../../faq/design.rst:447
msgid ""
"If you want to force Python to delete certain things on deallocation use the"
" :mod:`atexit` module to run a function that will force those deletions."
msgstr ""
"å†å‰²ã‚Šå½“ã¦æ™‚ã« Python ãŒç‰¹å®šã®ã‚‚ã®ã‚’å‰Šé™¤ã™ã‚‹ã‚ˆã†ã«å¼·åˆ¶ã—ãŸã„ã¨ãã¯ã€ :mod:`atexit` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦å‰Šé™¤ã‚’å¼·åˆ¶ã™ã‚‹é–¢æ•°ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚"

#: ../../faq/design.rst:452
msgid "Why are there separate tuple and list data types?"
msgstr "ãªãœã‚¿ãƒ—ãƒ«ã¨ãƒªã‚¹ãƒˆã¨ã„ã†åˆ¥ã®ãƒ‡ãƒ¼ã‚¿å‹ãŒç”¨æ„ã•ã‚Œã¦ã„ã‚‹ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:454
msgid ""
"Lists and tuples, while similar in many respects, are generally used in "
"fundamentally different ways.  Tuples can be thought of as being similar to "
"Pascal records or C structs; they're small collections of related data which"
" may be of different types which are operated on as a group.  For example, a"
" Cartesian coordinate is appropriately represented as a tuple of two or "
"three numbers."
msgstr ""
"ãƒªã‚¹ãƒˆã¨ã‚¿ãƒ—ãƒ«ã¯ã€å¤šãã®ç‚¹ã§ä¼¼ã¦ã„ã¾ã™ãŒã€ä¸€èˆ¬ã«ã¯æœ¬è³ªçš„ã«ç•°ãªã‚‹æ–¹æ³•ã§ä½¿ã‚ã‚Œã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã¯ã€Pascal ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚„ C "
"ã®æ§‹é€ ä½“ã¨åŒæ§˜ãªã‚‚ã®ã¨è€ƒãˆã‚‰ã‚Œã¾ã™ã€‚å‹ãŒç•°ãªã£ã¦ã‚‚è‰¯ã„é–¢é€£ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®å°ã•ãªé›†åˆã§ã€ã‚°ãƒ«ãƒ¼ãƒ—ã¨ã—ã¦æ¼”ç®—ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒ‡ã‚«ãƒ«ãƒˆåº§æ¨™ã¯ 2 ã¤ã‚„ 3 "
"ã¤ã®æ•°ã®ã‚¿ãƒ—ãƒ«ã¨ã—ã¦é©åˆ‡ã«è¡¨ã›ã¾ã™ã€‚"

#: ../../faq/design.rst:461
msgid ""
"Lists, on the other hand, are more like arrays in other languages.  They "
"tend to hold a varying number of objects all of which have the same type and"
" which are operated on one-by-one.  For example, ``os.listdir('.')`` returns"
" a list of strings representing the files in the current directory.  "
"Functions which operate on this output would generally not break if you "
"added another file or two to the directory."
msgstr ""
"ä¸€æ–¹ã€ãƒªã‚¹ãƒˆã¯ã€ã‚‚ã£ã¨ä»–ã®è¨€èªã®é…åˆ—ã«è¿‘ã„ã‚‚ã®ã§ã™ã€‚å…¨ã¦åŒã˜å‹ã®å¯å¤‰æ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒã¡ã€ãã‚Œã‚‰ãŒä¸€ã¤ä¸€ã¤æ¼”ç®—ã•ã‚Œã‚‹å‚¾å‘ã«ã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ "
"``os.listdir('.')`` "
"ã¯ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã«ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®æ–‡å­—åˆ—è¡¨ç¾ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã®å‡ºåŠ›ã‚’æ¼”ç®—ã™ã‚‹é–¢æ•°ã¯ä¸€èˆ¬ã«ã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ä¸€ã¤ã‚„äºŒã¤ã®åˆ¥ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åŠ ãˆã¦ã‚‚å£Šã‚Œã¾ã›ã‚“ã€‚"

#: ../../faq/design.rst:468
msgid ""
"Tuples are immutable, meaning that once a tuple has been created, you can't "
"replace any of its elements with a new value.  Lists are mutable, meaning "
"that you can always change a list's elements.  Only immutable elements can "
"be used as dictionary keys, and hence only tuples and not lists can be used "
"as keys."
msgstr ""
"ã‚¿ãƒ—ãƒ«ã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã®ã§ã€ä¸€åº¦ã‚¿ãƒ—ãƒ«ãŒç”Ÿæˆã•ã‚ŒãŸã‚‰ã€ãã®ã©ã®è¦ç´ ã‚‚æ–°ã—ã„å€¤ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã›ã‚“ã€‚ãƒªã‚¹ãƒˆã¯ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã®ã§ã€ãƒªã‚¹ãƒˆã®è¦ç´ ã¯ã„ã¤ã§ã‚‚å¤‰æ›´ã§ãã¾ã™ã€‚ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªè¦ç´ ã ã‘ãŒè¾æ›¸ã®ã‚­ãƒ¼ã¨ã—ã¦ä½¿ãˆã‚‹ã®ã§ã€ãƒªã‚¹ãƒˆã§ã¯ãªãã‚¿ãƒ—ãƒ«ã ã‘ãŒã‚­ãƒ¼ã¨ã—ã¦ä½¿ãˆã¾ã™ã€‚"

#: ../../faq/design.rst:475
msgid "How are lists implemented in CPython?"
msgstr ""

#: ../../faq/design.rst:477
msgid ""
"CPython's lists are really variable-length arrays, not Lisp-style linked "
"lists. The implementation uses a contiguous array of references to other "
"objects, and keeps a pointer to this array and the array's length in a list "
"head structure."
msgstr ""

#: ../../faq/design.rst:481
msgid ""
"This makes indexing a list ``a[i]`` an operation whose cost is independent "
"of the size of the list or the value of the index."
msgstr "ã“ã‚Œã«ã‚ˆã‚Šã€ãƒªã‚¹ãƒˆã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚·ãƒ³ã‚° ``a[i]`` ã¯ã€ãƒªã‚¹ãƒˆã®å¤§ãã•ã‚„ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã®å€¤ã«ä¾å­˜ã—ãªã„ã‚³ã‚¹ãƒˆã§æ¼”ç®—ã§ãã¾ã™ã€‚"

#: ../../faq/design.rst:484
msgid ""
"When items are appended or inserted, the array of references is resized.  "
"Some cleverness is applied to improve the performance of appending items "
"repeatedly; when the array must be grown, some extra space is allocated so "
"the next few times don't require an actual resize."
msgstr ""
"è¦ç´ ãŒè¿½åŠ ã¾ãŸã¯æŒ¿å…¥ã•ã‚Œã‚‹ã¨ãã€ã“ã®å‚ç…§ã®é…åˆ—ã¯å¤§ãã•ãŒå¤‰æ›´ã•ã‚Œã¾ã™ã€‚è¦ç´ è¿½åŠ ã®ç¹°ã‚Šè¿”ã—ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’ä¸Šã’ã‚‹ãŸã‚ã«ã€å°‘ã—å·¥å¤«ã•ã‚Œã¦ã„ã¾ã™ã€‚é…åˆ—ãŒå¤§ãããªã‚‹ã¨ãã€æ¬¡ã®ä½•å›ã‹ã¯å®Ÿéš›ã«å¤§ãã•ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ãŒãªã„ã‚ˆã†ã«ã€ã„ãã‚‰ã‹ã®è¿½åŠ ã®é ˜åŸŸãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../faq/design.rst:491
msgid "How are dictionaries implemented in CPython?"
msgstr ""

#: ../../faq/design.rst:493
msgid ""
"CPython's dictionaries are implemented as resizable hash tables.  Compared "
"to B-trees, this gives better performance for lookup (the most common "
"operation by far) under most circumstances, and the implementation is "
"simpler."
msgstr ""

#: ../../faq/design.rst:497
msgid ""
"Dictionaries work by computing a hash code for each key stored in the "
"dictionary using the :func:`hash` built-in function.  The hash code varies "
"widely depending on the key and a per-process seed; for example, \"Python\" "
"could hash to -539294296 while \"python\", a string that differs by a single"
" bit, could hash to 1142331976.  The hash code is then used to calculate a "
"location in an internal array where the value will be stored.  Assuming that"
" you're storing keys that all have different hash values, this means that "
"dictionaries take constant time -- O(1), in computer science notation -- to "
"retrieve a key.  It also means that no sorted order of the keys is "
"maintained, and traversing the array as the ``.keys()`` and ``.items()`` do "
"will output the dictionary's content in some arbitrary jumbled order that "
"can change with every invocation of a program."
msgstr ""
"è¾æ›¸ã¯ã€ :func:`hash` "
"çµ„ã¿è¾¼ã¿é–¢æ•°ã§ã€è¾æ›¸ã«ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ãã‚Œãã‚Œã®ã‚­ãƒ¼ã«å¯¾å¿œã™ã‚‹ãƒãƒƒã‚·ãƒ¥ã‚³ãƒ¼ãƒ‰ã‚’è¨ˆç®—ã—ã¦åƒãã¾ã™ã€‚ã“ã®ãƒãƒƒã‚·ãƒ¥ã‚³ãƒ¼ãƒ‰ã¯ã‚­ãƒ¼ã‚„ãƒ—ãƒ­ã‚»ã‚¹ã”ã¨ã®ã‚·ãƒ¼ãƒ‰ã«å¤§ããä¾å­˜ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€\"Python\""
" ã®ãƒãƒƒã‚·ãƒ¥å€¤ã¯ -539294296 ã§ã™ãŒã€ãƒ“ãƒƒãƒˆãŒä¸€ã¤é•ã†ã ã‘ã®æ–‡å­—åˆ— \"python\" ã®ãƒãƒƒã‚·ãƒ¥å€¤ã¯ 1142331976 "
"ã§ã™ã€‚ãã—ã¦ã“ã®ãƒãƒƒã‚·ãƒ¥ã‚³ãƒ¼ãƒ‰ã¯ã€å†…éƒ¨é…åˆ—ã§ã®å€¤ãŒä¿å­˜ã•ã‚Œã‚‹ä½ç½®ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ä¿å­˜ã—ã¦ã„ã‚‹ã‚­ãƒ¼ã®ãƒãƒƒã‚·ãƒ¥å€¤ãŒå…¨ã¦ç•°ãªã‚‹ã¨ã™ã‚Œã°ã€ä¸€å®šã®æ™‚é–“"
" - ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚µã‚¤ã‚¨ãƒ³ã‚¹ã®è¨˜æ³•ã§è¨€ãˆã° O(1) - "
"ã§ã‚­ãƒ¼ã‚’æ¤œç´¢ã§ãã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸã€ã‚­ãƒ¼ã®ã„ã‹ãªã‚‹ä¸¦ã³é †ã‚‚ä¿ãŸã‚Œã¦ã„ãªã„ã“ã¨ã«ã‚‚ãªã‚Šã€é…åˆ—ã‚’ ``.keys()`` ã‚„ ``.items()`` "
"ã¨ã—ã¦æ¨ªæ–­ã™ã‚‹ã¨ã€è¾æ›¸ã®å†…å®¹ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®èµ·å‹•æ¯ã«å¤‰ã‚ã‚‹ä»»æ„ã®æ··ä¹±ã—ãŸé †åºã§å‡ºåŠ›ã•ã‚Œã¾ã™ã€‚"

#: ../../faq/design.rst:512
msgid "Why must dictionary keys be immutable?"
msgstr "ãªãœè¾æ›¸ã®ã‚­ãƒ¼ã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã§ãªãã¦ã¯ãªã‚‰ãªã„ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:514
msgid ""
"The hash table implementation of dictionaries uses a hash value calculated "
"from the key value to find the key.  If the key were a mutable object, its "
"value could change, and thus its hash could also change.  But since whoever "
"changes the key object can't tell that it was being used as a dictionary "
"key, it can't move the entry around in the dictionary.  Then, when you try "
"to look up the same object in the dictionary it won't be found because its "
"hash value is different. If you tried to look up the old value it wouldn't "
"be found either, because the value of the object found in that hash bin "
"would be different."
msgstr ""
"è¾æ›¸ã®ãƒãƒƒã‚·ãƒ¥ãƒ†ãƒ¼ãƒ–ãƒ«ã®å®Ÿè£…ã¯ã€ã‚­ãƒ¼ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ã€ã‚­ãƒ¼å€¤ã‹ã‚‰è¨ˆç®—ã•ã‚ŒãŸãƒãƒƒã‚·ãƒ¥å€¤ã‚’ä½¿ã„ã¾ã™ã€‚ã‚‚ã—ã‚­ãƒ¼ãŒãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã ã£ãŸã‚‰ã€ãã®å€¤ã¯å¤‰ãˆã‚‰ã‚Œã€ãã‚Œã«ã‚ˆã‚Šãƒãƒƒã‚·ãƒ¥å€¤ã‚‚å¤‰ã‚ã£ã¦ã—ã¾ã„ã¾ã™ã€‚ã—ã‹ã—ã€ã‚­ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¤‰æ›´ã—ãŸã®ãŒä½•è€…ã§ã‚ã‚Œã€å€¤ãŒè¾æ›¸ã®ã‚­ãƒ¼ã¨ã—ã¦ä½¿ã‚ã‚Œã¦ã„ãŸã¨æ°—ä»˜ã‘ãªã„ã®ã§ã€è¾æ›¸ã®ä¸­ã®ã‚¨ãƒ³ãƒˆãƒªã‚’é©åˆ‡ãªå ´æ‰€ã«å‹•ã‹ã›ã¾ã›ã‚“ã€‚ãã—ã¦ã€åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¢ãã†ã¨ã—ã¦ã‚‚ã€ãƒãƒƒã‚·ãƒ¥å€¤ãŒé•ã†ãŸã‚è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚å¤ã„å€¤ã‚’æ¢ãã†ã¨ã—ã¦ã‚‚ã€ãã®ãƒãƒƒã‚·ãƒ¥ãƒã‚¤ãƒŠãƒªã‹ã‚‰è¦‹ã¤ã‹ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã¯ç•°ãªã‚‹ã§ã—ã‚‡ã†ã‹ã‚‰ã€ã“ã‚Œã‚‚è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"

#: ../../faq/design.rst:523
msgid ""
"If you want a dictionary indexed with a list, simply convert the list to a "
"tuple first; the function ``tuple(L)`` creates a tuple with the same entries"
" as the list ``L``.  Tuples are immutable and can therefore be used as "
"dictionary keys."
msgstr ""
"ãƒªã‚¹ãƒˆã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚·ãƒ³ã‚°ã•ã‚ŒãŸè¾æ›¸ãŒå¿…è¦ãªã‚‰ã€ã¾ãšå˜ç´”ã«ãƒªã‚¹ãƒˆã‚’ã‚¿ãƒ—ãƒ«ã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚é–¢æ•° ``tuple(L)`` ã¯ã€ãƒªã‚¹ãƒˆ ``L`` "
"ã¨åŒã˜ã‚¨ãƒ³ãƒˆãƒªã®ã‚¿ãƒ—ãƒ«ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã®ã§ã€è¾æ›¸ã®ã‚­ãƒ¼ã¨ã—ã¦ä½¿ãˆã¾ã™ã€‚"

#: ../../faq/design.rst:527
msgid "Some unacceptable solutions that have been proposed:"
msgstr "ã„ãã¤ã‹ã®å—ã‘å…¥ã‚Œã‚‰ã‚Œãªã‹ã£ãŸææ¡ˆ:"

#: ../../faq/design.rst:529
msgid ""
"Hash lists by their address (object ID).  This doesn't work because if you "
"construct a new list with the same value it won't be found; e.g.::"
msgstr "ã‚¢ãƒ‰ãƒ¬ã‚¹ (ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ID) ã®ãƒãƒƒã‚·ãƒ¥ãƒªã‚¹ãƒˆã€‚ã“ã‚Œã¯ã€åŒã˜å€¤ã®æ–°ã—ã„ãƒªã‚¹ãƒˆã‚’ä½œã£ã¦ã‚‚è¦‹ã¤ã‹ã‚‰ãªã„ã®ã§é§„ç›®ã§ã™ã€‚ä¾‹ãˆã°::"

#: ../../faq/design.rst:535
msgid ""
"would raise a KeyError exception because the id of the ``[1, 2]`` used in "
"the second line differs from that in the first line.  In other words, "
"dictionary keys should be compared using ``==``, not using :keyword:`is`."
msgstr ""
"ã¯ã€2 è¡Œç›®ã® ``[1, 2]`` ã® id ãŒ 1 è¡Œç›®ã®ã‚‚ã®ã¨é•ã†ãŸã‚ã€ KeyError ä¾‹å¤–ã‚’èµ·ã“ã—ã¾ã™ã€‚è¦ã™ã‚‹ã«ã€è¾æ›¸ã®ã‚­ãƒ¼ã¯ "
":keyword:`is` ã§ã¯ãªãã€ ``==`` ã§æ¯”è¼ƒã•ã‚Œã‚‹ã¹ãã§ã™ã€‚"

#: ../../faq/design.rst:539
msgid ""
"Make a copy when using a list as a key.  This doesn't work because the list,"
" being a mutable object, could contain a reference to itself, and then the "
"copying code would run into an infinite loop."
msgstr ""
"ãƒªã‚¹ãƒˆã‚’ã‚­ãƒ¼ã¨ã—ã¦ä½¿ã†ã¨ãã«ã‚³ãƒ”ãƒ¼ã‚’ä½œã‚‹ã€‚ãƒªã‚¹ãƒˆã¯ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã®ã§ã€è‡ªåˆ†è‡ªèº«ã¸ã®å‚ç…§ã‚’å«ã‚€ã“ã¨ãŒã§ãã€ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã¨ãã«ç„¡é™ãƒ«ãƒ¼ãƒ—ã«ãƒãƒã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã€ã“ã‚Œã¯é§„ç›®ã§ã™ã€‚"

#: ../../faq/design.rst:543
msgid ""
"Allow lists as keys but tell the user not to modify them.  This would allow "
"a class of hard-to-track bugs in programs when you forgot or modified a list"
" by accident. It also invalidates an important invariant of dictionaries: "
"every value in ``d.keys()`` is usable as a key of the dictionary."
msgstr ""
"ãƒªã‚¹ãƒˆã‚’ã‚­ãƒ¼ã¨ã—ã¦ä½¿ã†ã“ã¨ã‚’èªã‚ã‚‹ãŒã€ãƒ¦ãƒ¼ã‚¶ã«ãã‚Œã‚’å¤‰æ›´ã•ã›ãªã„ã‚ˆã†ã«ä¼ãˆã‚‹ã€‚ã‚‚ã—ãƒ¦ãƒ¼ã‚¶ãŒå¿˜ã‚ŒãŸã‚Šã€å¶ç„¶ã«ãƒªã‚¹ãƒˆãŒå¤‰æ›´ã•ã‚Œã¦ã—ã¾ã£ãŸã‚Šã—ãŸã‚‰ã€è¿½è·¡å›°é›£ãªãƒã‚°ã®å¯èƒ½æ€§ã‚’ç”Ÿã˜ã¦ã—ã¾ã„ã¾ã™ã€‚ã¾ãŸã“ã‚Œã¯ã€"
" ``d.keys()`` ã®ã™ã¹ã¦ã®å€¤ã¯è¾æ›¸ã®ã‚­ãƒ¼ã¨ã—ã¦ä½¿ãˆã‚‹ã¨ã„ã†ã€è¾æ›¸ã®é‡è¦ãªä¸å¤‰æ€§ã‚‚æ½°ã—ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../faq/design.rst:548
msgid ""
"Mark lists as read-only once they are used as a dictionary key.  The problem"
" is that it's not just the top-level object that could change its value; you"
" could use a tuple containing a list as a key.  Entering anything as a key "
"into a dictionary would require marking all objects reachable from there as "
"read-only -- and again, self-referential objects could cause an infinite "
"loop."
msgstr ""
"ãƒªã‚¹ãƒˆãŒä¸€æ—¦è¾æ›¸ã®ã‚­ãƒ¼ã¨ã—ã¦ä½¿ã‚ã‚ŒãŸã‚‰ã€èª­ã¿å‡ºã—å°‚ç”¨ã®ãƒãƒ¼ã‚¯ã‚’ä»˜ã‘ã‚‹ã€‚å•é¡Œã¯ã€å€¤ã‚’å¤‰ãˆã‚‰ã‚Œã‚‹ã®ã¯ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã ã‘ã§ã¯ãªã„ã“ã¨ã§ã™ã€‚ãƒªã‚¹ãƒˆã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã‚‚ã‚­ãƒ¼ã¨ã—ã¦ä½¿ãˆã¾ã™ã€‚å…¨ã¦ã‚’è¾æ›¸ã®ã‚­ãƒ¼ã¨ã—ã¦å°å…¥ã™ã‚‹ã¨ã€ãã“ã‹ã‚‰åˆ°é”å¯èƒ½ãªå…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«èª­ã¿å‡ºã—å°‚ç”¨ã®ãƒãƒ¼ã‚¯ã‚’ä»˜ã‘ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™"
" -- ãã—ã¦å†ã³ã€è‡ªå·±å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚"

#: ../../faq/design.rst:554
msgid ""
"There is a trick to get around this if you need to, but use it at your own "
"risk: You can wrap a mutable structure inside a class instance which has "
"both a :meth:`__eq__` and a :meth:`__hash__` method.  You must then make "
"sure that the hash value for all such wrapper objects that reside in a "
"dictionary (or other hash based structure), remain fixed while the object is"
" in the dictionary (or other structure). ::"
msgstr ""
"å¿…è¦ãªã‚‰ã°ã“ã‚Œã‚’å›é¿ã™ã‚‹æ–¹æ³•ãŒã‚ã‚Šã¾ã™ãŒã€è‡ªå·±è²¬ä»»ã®ã‚‚ã¨ã§è¡Œã£ã¦ãã ã•ã„ã€‚ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªæ§‹é€ ã‚’ã€ :meth:`__eq__` ã¨ "
":meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸¡æ–¹ã‚’æŒã¤ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãã®æ™‚ã€è¾æ›¸ (ã¾ãŸã¯ãƒãƒƒã‚·ãƒ¥ã«åŸºã¥ãåˆ¥ã®æ§‹é€ ä½“) "
"ã«å±ã™ã‚‹ã‚ˆã†ãªå…¨ã¦ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒƒã‚·ãƒ¥å€¤ãŒã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¾æ›¸ (ãã®ä»–ã®æ§‹é€ ä½“) ä¸­ã«ã‚ã‚‹é–“å›ºå®šã•ã‚Œç¶šã‘ã‚‹ã“ã¨ã‚’ç¢ºå®Ÿã«ã—ã¦ãã ã•ã„ã€‚ "
"::"

#: ../../faq/design.rst:578
msgid ""
"Note that the hash computation is complicated by the possibility that some "
"members of the list may be unhashable and also by the possibility of "
"arithmetic overflow."
msgstr "ãªãŠã€ãƒªã‚¹ãƒˆã®ãƒ¡ãƒ³ãƒãƒ¼ã®ä¸­ã«ãƒãƒƒã‚·ãƒ¥åŒ–ã§ããªã„ã‚‚ã®ãŒã‚ã‚‹å¯èƒ½æ€§ã‚„ã€ç®—è¡“ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®å¯èƒ½æ€§ã‹ã‚‰ã€ãƒãƒƒã‚·ãƒ¥è¨ˆç®—ã¯è¤‡é›‘ã«ãªã‚Šã¾ã™ã€‚"

#: ../../faq/design.rst:582
msgid ""
"Furthermore it must always be the case that if ``o1 == o2`` (ie "
"``o1.__eq__(o2) is True``) then ``hash(o1) == hash(o2)`` (ie, "
"``o1.__hash__() == o2.__hash__()``), regardless of whether the object is in "
"a dictionary or not.  If you fail to meet these restrictions dictionaries "
"and other hash based structures will misbehave."
msgstr ""
"ã•ã‚‰ã«ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¾æ›¸ã«å«ã¾ã‚Œã‚‹ã‹å¦ã‹ã«ã‹ã‹ã‚ã‚‰ãšã€ ``o1 == o2`` (ã™ãªã‚ã¡ ``o1.__eq__(o2) is True``)"
" ãªã‚‰ã°ã„ã¤ã§ã‚‚ ``hash(o1) == hash(o2)`` (ã™ãªã‚ã¡ ``o1.__hash__() == o2.__hash__()``) "
"ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ãã®åˆ¶é™ã«é©åˆã§ããªã‘ã‚Œã°ã€è¾æ›¸ã‚„ãã®ä»–ã®ãƒãƒƒã‚·ãƒ¥ã«åŸºã¥ãæ§‹é€ ä½“ã¯é–“é•ã„ã‚’èµ·ã“ã—ã¾ã™ã€‚"

#: ../../faq/design.rst:587
msgid ""
"In the case of ListWrapper, whenever the wrapper object is in a dictionary "
"the wrapped list must not change to avoid anomalies.  Don't do this unless "
"you are prepared to think hard about the requirements and the consequences "
"of not meeting them correctly.  Consider yourself warned."
msgstr ""
"ã“ã® ListWrapper "
"ã®ä¾‹ã§ã¯ã€ç•°å¸¸ã‚’é¿ã‘ã‚‹ãŸã‚ã€ãƒ©ãƒƒãƒ‘ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¾æ›¸å†…ã«ã‚ã‚‹é™ã‚Šãƒ©ãƒƒãƒ—ã•ã‚ŒãŸãƒªã‚¹ãƒˆãŒå¤‰æ›´ã•ã‚Œã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®æ¡ä»¶ã¨æº€ãŸã›ãªã‹ã£ãŸæ™‚ã®çµæœã«ã¤ã„ã¦çŸ¥æµã‚’çµã‚‹è¦šæ‚ŸãŒãªã„é™ã‚Šã€ã“ã‚Œã‚’ã—ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚ã‚ˆãè€ƒãˆã¦ãã ã•ã„ã€‚"

#: ../../faq/design.rst:594
msgid "Why doesn't list.sort() return the sorted list?"
msgstr "ãªãœ list.sort() ã¯ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸãƒªã‚¹ãƒˆã‚’è¿”ã•ãªã„ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:596
msgid ""
"In situations where performance matters, making a copy of the list just to "
"sort it would be wasteful. Therefore, :meth:`list.sort` sorts the list in "
"place. In order to remind you of that fact, it does not return the sorted "
"list.  This way, you won't be fooled into accidentally overwriting a list "
"when you need a sorted copy but also need to keep the unsorted version "
"around."
msgstr ""
"ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒå•é¡Œã¨ãªã‚‹çŠ¶æ³ã§ã¯ã€ã‚½ãƒ¼ãƒˆã™ã‚‹ãŸã‚ã ã‘ã«ãƒªã‚¹ãƒˆã®ã‚³ãƒ”ãƒ¼ã‚’ä½œã‚‹ã®ã¯ç„¡é§„ãŒå¤šã„ã§ã™ã€‚ãã“ã§ã€ :meth:`list.sort` "
"ã¯ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã«ãƒªã‚¹ãƒˆã‚’ã‚½ãƒ¼ãƒˆã—ã¾ã™ã€‚ã“ã®ã“ã¨ã‚’å¿˜ã‚Œãªã„ãŸã‚ã€ã“ã®é–¢æ•°ã¯ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã›ã‚“ã€‚ã“ã†ã™ã‚‹ã“ã¨ã§ã€ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸã‚³ãƒ”ãƒ¼ãŒå¿…è¦ã§ã€ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã‚‚ã®ã‚‚æ®‹ã—ã¦ãŠããŸã„ã¨ãã«ã€ã†ã£ã‹ã‚Šä¸Šæ›¸ãã—ã¦ã—ã¾ã†ã‚ˆã†ãªã“ã¨ãŒãªããªã‚Šã¾ã™ã€‚"

#: ../../faq/design.rst:602
msgid ""
"If you want to return a new list, use the built-in :func:`sorted` function "
"instead.  This function creates a new list from a provided iterable, sorts "
"it and returns it.  For example, here's how to iterate over the keys of a "
"dictionary in sorted order::"
msgstr ""
"æ–°ã—ã„ãƒªã‚¹ãƒˆã‚’è¿”ã—ãŸã„ãªã‚‰ã€ä»£ã‚ã‚Šã«çµ„ã¿è¾¼ã¿ã® :func:`sorted` "
"é–¢æ•°ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ã“ã®é–¢æ•°ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰æ–°ã—ã„ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆã—ã€ã‚½ãƒ¼ãƒˆã—ã¦è¿”ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€è¾æ›¸ã®ã‚­ãƒ¼ã‚’ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸé †åºã§ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹æ–¹æ³•ã¯::"

#: ../../faq/design.rst:612
msgid "How do you specify and enforce an interface spec in Python?"
msgstr "Python ã§ã¯ã©ã®ã‚ˆã†ã«ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ä»•æ§˜ã‚’ç‰¹å®šã—é©ç”¨ã™ã‚‹ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:614
msgid ""
"An interface specification for a module as provided by languages such as C++"
" and Java describes the prototypes for the methods and functions of the "
"module.  Many feel that compile-time enforcement of interface specifications"
" helps in the construction of large programs."
msgstr ""
"C++ ã‚„ Java "
"ã®ã‚ˆã†ãªè¨€èªãŒæä¾›ã™ã‚‹ã‚ˆã†ãªã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å¯¾ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ä»•æ§˜ã®ç‰¹å®šã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚„é–¢æ•°ã®åŸå‹ã‚’è¡¨ç¾ã—ã¾ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã®ç‰¹å®šãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«é©ç”¨ã•ã‚Œã‚‹ã“ã¨ãŒã€å¤§ããªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ§‹æˆã«å½¹ç«‹ã¤ã¨ã€åºƒãæ„Ÿã˜ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../faq/design.rst:619
msgid ""
"Python 2.6 adds an :mod:`abc` module that lets you define Abstract Base "
"Classes (ABCs).  You can then use :func:`isinstance` and :func:`issubclass` "
"to check whether an instance or a class implements a particular ABC.  The "
":mod:`collections.abc` module defines a set of useful ABCs such as "
":class:`~collections.abc.Iterable`, :class:`~collections.abc.Container`, and"
" :class:`~collections.abc.MutableMapping`."
msgstr ""
"Python 2.6 ã§ã€æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ (Abstract Base Class, ABC) ãŒå®šç¾©ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ :mod:`abc` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ãªã®ã§ :func:`isinstance` ã¨ :func:`issubclass` "
"ã‚’ä½¿ã£ã¦ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚„ã‚¯ãƒ©ã‚¹ãŒã€ã‚ã‚‹ ABC ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ã§ãã¾ã™ã€‚:mod:`collections.abc` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ "
":class:`~collections.abc.Iterable` ã€ :class:`~collections.abc.Container` ã€ "
":class:`~collections.abc.MutableMapping` ãªã©ã®ä¾¿åˆ©ãª ABC ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../faq/design.rst:626
msgid ""
"For Python, many of the advantages of interface specifications can be "
"obtained by an appropriate test discipline for components.  There is also a "
"tool, PyChecker, which can be used to find problems due to subclassing."
msgstr ""
"Python "
"ã§ã¯ã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®é©åˆ‡ãªãƒ†ã‚¹ãƒˆè¦å¾‹ã«ã‚ˆã£ã¦ã€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ä»•æ§˜ã®å¤šãã®å¼·ã¿ã‚’æ´»ã‹ã›ã¾ã™ã€‚ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã«ã‚ˆã‚‹å•é¡Œã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ä½¿ãˆã‚‹ãƒ„ãƒ¼ãƒ« "
"PyChecker ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/design.rst:630
msgid ""
"A good test suite for a module can both provide a regression test and serve "
"as a module interface specification and a set of examples.  Many Python "
"modules can be run as a script to provide a simple \"self test.\"  Even "
"modules which use complex external interfaces can often be tested in "
"isolation using trivial \"stub\" emulations of the external interface.  The "
":mod:`doctest` and :mod:`unittest` modules or third-party test frameworks "
"can be used to construct exhaustive test suites that exercise every line of "
"code in a module."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãŸã‚ã®é©åˆ‡ãªãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã¯ã€å›å¸°ãƒ†ã‚¹ãƒˆã‚’æä¾›ã—ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ä»•æ§˜ã‚„ç”¨ä¾‹é›†ã¨ã—ã¦ã‚‚å½¹ç«‹ã¡ã¾ã™ã€‚å¤šãã® Python "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ç°¡å˜ãªã€Œè‡ªå·±ãƒ†ã‚¹ãƒˆã€ã‚’æä¾›ã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨ã—ã¦å®Ÿè¡Œã§ãã¾ã™ã€‚è¤‡é›‘ãªå¤–éƒ¨ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä½¿ã†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ãˆã€å¤–éƒ¨ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã®ç´°ã‹ã„ã€Œã‚¹ã‚¿ãƒ–ã€ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§å˜ç‹¬ã«ãƒ†ã‚¹ãƒˆã§ãã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚"
" :mod:`doctest` ã‚„ :mod:`unittest` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã€ã‚ã‚‹ã„ã¯ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã®ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã®å…¨ã¦ã®è¡Œã«åŠã¶å¾¹åº•çš„ãªãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã‚’æ§‹æˆã§ãã¾ã™ã€‚"

#: ../../faq/design.rst:638
msgid ""
"An appropriate testing discipline can help build large complex applications "
"in Python as well as having interface specifications would.  In fact, it can"
" be better because an interface specification cannot test certain properties"
" of a program.  For example, the :meth:`append` method is expected to add "
"new elements to the end of some internal list; an interface specification "
"cannot test that your :meth:`append` implementation will actually do this "
"correctly, but it's trivial to check this property in a test suite."
msgstr ""
"Python "
"ã§å¤§ããã¦è¤‡é›‘ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã™ã‚‹ã¨ãã€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ä»•æ§˜ã¨åŒæ§˜ã«ã€é©åˆ‡ãªãƒ†ã‚¹ãƒˆè¦å¾‹ã‚‚å½¹ç«‹ã¡ã¾ã™ã€‚å®Ÿéš›ã«ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ä»•æ§˜ã§ã¯ãƒ†ã‚¹ãƒˆã§ããªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å±æ€§ã‚‚ã‚ã‚‹ã®ã§ã€ãã‚Œä»¥ä¸Šã«ã‚‚ãªã‚Šãˆã¾ã™ã€‚ä¾‹ãˆã°ã€"
" :meth:`append` ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ–°ã—ã„è¦ç´ ã‚’ã‚ã‚‹å†…éƒ¨ãƒªã‚¹ãƒˆã®çµ‚ã‚ã‚Šã«åŠ ãˆã¾ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ä»•æ§˜ã§ã¯ã“ã® :meth:`append` "
"ã®å®Ÿè£…ãŒå®Ÿéš›ã«ã“ã‚Œã‚’è¡Œã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã§ãã¾ã›ã‚“ãŒã€ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆãªã‚‰ã“ã®æ©Ÿèƒ½ã‚’ç°¡å˜ã«ç¢ºã‹ã‚ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../faq/design.rst:646
msgid ""
"Writing test suites is very helpful, and you might want to design your code "
"with an eye to making it easily tested.  One increasingly popular technique,"
" test-directed development, calls for writing parts of the test suite first,"
" before you write any of the actual code.  Of course Python allows you to be"
" sloppy and not write test cases at all."
msgstr ""
"ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã‚’æ›¸ãã“ã¨ã¯ã¨ã¦ã‚‚å½¹ã«ç«‹ã¡ã¾ã™ã—ã€ãƒ†ã‚¹ãƒˆã®ã—ã‚„ã™ã•ã¨ã„ã†è¦–ç‚¹ã§ã‚³ãƒ¼ãƒ‰ã‚’è¨­è¨ˆã™ã‚‹ã“ã¨ã«ã‚‚ã¤ãªãŒã‚Šã¾ã™ã€‚ãƒ†ã‚¹ãƒˆæŒ‡å‘é–‹ç™ºã¯ã€äººæ°—ã‚’å¢—ã—ã¤ã¤ã‚ã‚‹æŠ€æ³•ã§ã€å®Ÿéš›ã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãå§‹ã‚ã‚‹å‰ã«ã€æœ€åˆã‹ã‚‰ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã®éƒ¨å“ã‚’æ›¸ãã“ã¨ã‚’æ±‚ã‚ã¾ã™ã€‚ã‚‚ã¡ã‚ã‚“ã€"
" Python ã§ç²—é›‘ã«ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’å…¨ãæ›¸ã‹ãªã„ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../faq/design.rst:654
msgid "Why is there no goto?"
msgstr "ãªãœ goto ãŒç„¡ã„ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:656
msgid ""
"You can use exceptions to provide a \"structured goto\" that even works "
"across function calls.  Many feel that exceptions can conveniently emulate "
"all reasonable uses of the \"go\" or \"goto\" constructs of C, Fortran, and "
"other languages.  For example::"
msgstr ""
"é–¢æ•°ã®å‘¼ã³å‡ºã—ã‚’ã¾ãŸã„ã§ã‚‚å‹•ä½œã™ã‚‹ \"æ§‹é€ åŒ–ã•ã‚ŒãŸ goto\" ã‚’ã¾ã‹ãªã†ã‚‚ã®ã¨ã—ã¦ä¾‹å¤–ã‚’ä½¿ãˆã¾ã™ã€‚Cã€Fortranã€ãã®ä»–ã®è¨€èªã§ã® "
"\"go\" ã‚ã‚‹ã„ã¯ \"goto\" æ§‹é€ ã®é©åˆ‡ãªç”¨é€”ã¯å…¨ã¦ã€ä¾‹å¤–ã§åŒã˜ã‚ˆã†ãªã“ã¨ã‚’ã‚’ã™ã‚Œã°ä¾¿åˆ©ã§ã‚ã‚‹ã¨ã€åºƒãæ„Ÿã˜ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../faq/design.rst:671
msgid ""
"This doesn't allow you to jump into the middle of a loop, but that's usually"
" considered an abuse of goto anyway.  Use sparingly."
msgstr "ä¾‹å¤–ã§ã¯ãƒ«ãƒ¼ãƒ—å†…ã¸è·³ã¶ã“ã¨ã¯ã§ãã¾ã›ã‚“ãŒã€ã©ã¡ã‚‰ã«ã—ã¦ã‚‚ãã‚Œã¯ goto ã®ä¹±ç”¨ã¨è¦‹ãªã•ã‚Œã‚‹ã‚‚ã®ã§ã™ã€‚ä½¿ã†ã®ã¯æ§ãˆã¦ãã ã•ã„ã€‚"

#: ../../faq/design.rst:676
msgid "Why can't raw strings (r-strings) end with a backslash?"
msgstr "ãªãœ raw æ–‡å­—åˆ— (r-strings) ã¯ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§çµ‚ã‚ã£ã¦ã¯ã„ã‘ãªã„ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:678
msgid ""
"More precisely, they can't end with an odd number of backslashes: the "
"unpaired backslash at the end escapes the closing quote character, leaving "
"an unterminated string."
msgstr ""
"æ­£ç¢ºã«ã¯ã€å¥‡æ•°å€‹ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§çµ‚ã‚ã£ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚çµ‚ã‚ã‚Šã®å¯¾ã«ãªã£ã¦ã„ãªã„ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¯ã€é–‰ã˜å¼•ç”¨æ–‡å­—ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã—ã€çµ‚ã£ã¦ã„ãªã„æ–‡å­—åˆ—ã‚’æ®‹ã—ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../faq/design.rst:682
msgid ""
"Raw strings were designed to ease creating input for processors (chiefly "
"regular expression engines) that want to do their own backslash escape "
"processing. Such processors consider an unmatched trailing backslash to be "
"an error anyway, so raw strings disallow that.  In return, they allow you to"
" pass on the string quote character by escaping it with a backslash.  These "
"rules work well when r-strings are used for their intended purpose."
msgstr ""
"raw æ–‡å­—åˆ—ã¯ã€ç‹¬è‡ªã«ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã®å‡¦ç†ã‚’ã—ã‚ˆã†ã¨ã™ã‚‹ãƒ—ãƒ­ã‚»ãƒƒã‚µ (ä¸»ã«æ­£è¦è¡¨ç¾ã‚¨ãƒ³ã‚¸ãƒ³) "
"ã¸ã®å…¥åŠ›ã‚’ç”Ÿæˆã—ã‚„ã™ã„ã‚ˆã†ã«è¨­è¨ˆã•ã‚ŒãŸã‚‚ã®ã§ã™ã€‚ã“ã®ã‚ˆã†ãªãƒ—ãƒ­ã‚»ãƒƒã‚µã¯ã€çµ‚ç«¯ã®å¯¾ã«ãªã£ã¦ã„ãªã„ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’çµå±€ã‚¨ãƒ©ãƒ¼ã¨ã¿ãªã™ã®ã§ã€raw "
"æ–‡å­—åˆ—ã¯ãã‚Œã‚’èªã‚ã¾ã›ã‚“ã€‚ãã®ä»£ã‚ã‚Šã«ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹ã“ã¨ã§ã€å¼•ç”¨æ–‡å­—ã‚’æ–‡å­—åˆ—ã¨ã—ã¦æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚r-string "
"ãŒæ„å›³ã•ã‚ŒãŸç›®çš„ã«ä½¿ã‚ã‚Œã‚‹ã¨ãã«ã€ã“ã®è¦å‰‡ãŒå½¹ã«ç«‹ã¤ã®ã§ã™ã€‚"

#: ../../faq/design.rst:689
msgid ""
"If you're trying to build Windows pathnames, note that all Windows system "
"calls accept forward slashes too::"
msgstr "Windows ã®ãƒ‘ã‚¹åã‚’æ§‹ç¯‰ã™ã‚‹ã¨ãã«ã¯ã€Windows ã®ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã¯æ™®é€šã®ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚‚å—ã‘ä»˜ã‘ã‚‹ã“ã¨ã‚’æ†¶ãˆã¦ãŠã„ã¦ãã ã•ã„::"

#: ../../faq/design.rst:694
msgid ""
"If you're trying to build a pathname for a DOS command, try e.g. one of ::"
msgstr "DOS ã‚³ãƒãƒ³ãƒ‰ã®ãƒ‘ã‚¹åã‚’æ§‹ç¯‰ã™ã‚‹ã¨ãã«ã¯ã€ä¾‹ãˆã°ã“ã®ä¸­ã®ã©ã‚Œã‹ã‚’è©¦ã—ã¦ãã ã•ã„::"

#: ../../faq/design.rst:702
msgid "Why doesn't Python have a \"with\" statement for attribute assignments?"
msgstr "å±æ€§ã®ä»£å…¥ã« \"with\" æ–‡ãŒä½¿ãˆãªã„ã®ã¯ãªãœã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:704
msgid ""
"Python has a 'with' statement that wraps the execution of a block, calling "
"code on the entrance and exit from the block.  Some language have a "
"construct that looks like this::"
msgstr ""
"Python ã«ã¯ã€ãƒ–ãƒ­ãƒƒã‚¯ã®å®Ÿè¡Œã‚’åŒ…ã‚€ 'with' "
"æ–‡ãŒã‚ã‚Šã€ãƒ–ãƒ­ãƒƒã‚¯ã«å…¥ã‚‹ã¨ãã¨ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰å‡ºã‚‹ã¨ãã«ã€ã‚³ãƒ¼ãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ä»¥ä¸‹ã®ã‚ˆã†ãªæ§‹é€ ã‚’æŒã¤è¨€èªãŒã‚ã‚Šã¾ã™::"

#: ../../faq/design.rst:712
msgid "In Python, such a construct would be ambiguous."
msgstr "Python ã§ã¯ã€ã“ã®ã‚ˆã†ãªæ§‹é€ ã¯æ›–æ˜§ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../faq/design.rst:714
msgid ""
"Other languages, such as Object Pascal, Delphi, and C++, use static types, "
"so it's possible to know, in an unambiguous way, what member is being "
"assigned to. This is the main point of static typing -- the compiler "
"*always* knows the scope of every variable at compile time."
msgstr ""
"Object "
"Pascalã€Delphiã€C++ã®ã‚ˆã†ãªä»–ã®è¨€èªã§ã¯ã€é™çš„ãªå‹ã‚’ä½¿ã†ã®ã§ã€æ›–æ˜§ãªæ–¹æ³•ã§ã‚‚ã€ã©ã®ãƒ¡ãƒ³ãƒã«ä»£å…¥ã•ã‚Œã¦ã„ã‚‹ã®ã‹åˆ†ã‹ã‚Šã¾ã™ã€‚ã“ã‚ŒãŒé™çš„å‹ä»˜ã‘ã®è¦ç‚¹ã§ã™"
" -- ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ *ã„ã¤ã§ã‚‚* ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã™ã¹ã¦ã®å¤‰æ•°ã®ã‚¹ã‚³ãƒ¼ãƒ—ã‚’çŸ¥ã‚‹ã®ã§ã™ã€‚"

#: ../../faq/design.rst:719
msgid ""
"Python uses dynamic types. It is impossible to know in advance which "
"attribute will be referenced at runtime. Member attributes may be added or "
"removed from objects on the fly. This makes it impossible to know, from a "
"simple reading, what attribute is being referenced: a local one, a global "
"one, or a member attribute?"
msgstr ""
"Python "
"ã¯å‹•çš„ãªå‹ã‚’ä½¿ã„ã¾ã™ã€‚å®Ÿè¡Œæ™‚ã«ã©ã®å±æ€§ãŒå‚ç…§ã•ã‚Œã‚‹ã‹äº‹å‰ã«åˆ†ã‹ã‚Šã¾ã›ã‚“ã€‚å‹•ä½œä¸­ã«ãƒ¡ãƒ³ãƒå±æ€§ãŒè¿½åŠ ã‚ã‚‹ã„ã¯é™¤å»ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã§ã¯ã€å˜ç´”ã«èª­ã‚€ã ã‘ã§ã¯ã©ã®ã‚¢ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ãƒˆãŒå‚ç…§ã•ã‚Œã¦ã„ã‚‹ã‹åˆ†ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ­ãƒ¼ã‚«ãƒ«ãªã®ã‹ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã®ã‹ã€ãƒ¡ãƒ³ãƒå±æ€§ãªã®ã‹ï¼Ÿ"

#: ../../faq/design.rst:725
msgid "For instance, take the following incomplete snippet::"
msgstr "ä¾‹ãˆã°ã€ä»¥ä¸‹ã®ä¸å®Œå…¨ãªã‚³ãƒ¼ãƒ‰ç‰‡ã‚’è€ƒãˆã¾ã—ã‚‡ã†::"

#: ../../faq/design.rst:731
msgid ""
"The snippet assumes that \"a\" must have a member attribute called \"x\".  "
"However, there is nothing in Python that tells the interpreter this. What "
"should happen if \"a\" is, let us say, an integer?  If there is a global "
"variable named \"x\", will it be used inside the with block?  As you see, "
"the dynamic nature of Python makes such choices much harder."
msgstr ""
"ã“ã®ã‚³ãƒ¼ãƒ‰ç‰‡ã§ã¯ã€\"a\" ã¯ \"x\" ã¨ã„ã†ãƒ¡ãƒ³ãƒå±æ€§ã‚’æŒã£ã¦ã„ã‚‹ã¨ä»®å®šã•ã‚Œã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€Python "
"ã§ã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã¯ã“ã®ä»®å®šã‚’ä¼ãˆã‚‰ã‚Œã‚‹ä»•çµ„ã¿ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ \"a\" ãŒã€ä¾‹ãˆã°æ•´æ•°ã ã£ãŸã‚‰ã€ã©ã†ãªã£ã¦ã—ã¾ã†ã§ã—ã‚‡ã†ã‹ã€‚ \"x\" "
"ã¨ã„ã†åå‰ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãŒã‚ã£ãŸã‚‰ã€ãã‚ŒãŒ with ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­ã§ä½¿ã‚ã‚Œã‚‹ã®ã§ã—ã‚‡ã†ã‹ã€‚ã“ã®é€šã‚Šã€Python "
"ã®å‹•çš„ãªç‰¹è³ªã‹ã‚‰ã€ã“ã®ã‚ˆã†ãªé¸æŠã¯ã¨ã¦ã‚‚é›£ã—ã„ç‰©ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../faq/design.rst:737
msgid ""
"The primary benefit of \"with\" and similar language features (reduction of "
"code volume) can, however, easily be achieved in Python by assignment.  "
"Instead of::"
msgstr "ã—ã‹ã—ã€\"with\" ã‚„ãã‚Œã«é¡ã™ã‚‹è¨€èªã®æ©Ÿèƒ½ã®ä¸€ç•ªã®åˆ©ç‚¹ (ã‚³ãƒ¼ãƒ‰é‡ã®å‰Šæ¸›) ã¯ã€ Python ã§ã¯ä»£å…¥ã«ã‚ˆã‚Šç°¡å˜ã«æ‰‹ã«å…¥ã‚Œã‚‰ã‚Œã¾ã™::"

#: ../../faq/design.rst:744
msgid "write this::"
msgstr "ã“ã†æ›¸ã„ã¦ãã ã•ã„::"

#: ../../faq/design.rst:751
msgid ""
"This also has the side-effect of increasing execution speed because name "
"bindings are resolved at run-time in Python, and the second version only "
"needs to perform the resolution once."
msgstr "Python ã§ã¯å®Ÿè¡Œæ™‚ã«åå‰æŸç¸›ãŒè§£æ±ºã•ã‚Œã€å¾Œè€…ã¯ãã®è§£æ±ºãŒä¸€åº¦ã§æ¸ˆã‚€ãŸã‚ã€ã“ã‚Œã«ã¯å®Ÿè¡Œé€Ÿåº¦ã‚’ã‚ã’ã‚‹å‰¯ä½œç”¨ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/design.rst:757
msgid "Why are colons required for the if/while/def/class statements?"
msgstr "if/while/def/class æ–‡ã«ã‚³ãƒ­ãƒ³ãŒå¿…è¦ãªã®ã¯ãªãœã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:759
msgid ""
"The colon is required primarily to enhance readability (one of the results "
"of the experimental ABC language).  Consider this::"
msgstr "ä¸»ã«å¯èª­æ€§ã‚’é«˜ã‚ã‚‹ãŸã‚ (å®Ÿé¨“çš„ãª ABC è¨€èªã®çµæœã®ä¸€ã¤) ã«ã€ã‚³ãƒ­ãƒ³ãŒå¿…è¦ã§ã™::"

#: ../../faq/design.rst:765
msgid "versus ::"
msgstr "ã¨::"

#: ../../faq/design.rst:770
msgid ""
"Notice how the second one is slightly easier to read.  Notice further how a "
"colon sets off the example in this FAQ answer; it's a standard usage in "
"English."
msgstr ""
"ã‚’è€ƒãˆã‚Œã°ã€å¾Œè€…ã®ã»ã†ãŒå°‘ã—èª­ã¿ã‚„ã™ã„ã§ã—ã‚‡ã†ã€‚ã•ã‚‰ã«è¨€ãˆã°ã€ã“ã® FAQ ã®è§£ç­”ä¾‹ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚ã“ã‚Œã¯ã€è‹±èªã®æ¨™æº–çš„ãªç”¨æ³•ã§ã™ã€‚"

#: ../../faq/design.rst:773
msgid ""
"Another minor reason is that the colon makes it easier for editors with "
"syntax highlighting; they can look for colons to decide when indentation "
"needs to be increased instead of having to do a more elaborate parsing of "
"the program text."
msgstr ""
"ä»–ã®å°ã•ãªç†ç”±ã¯ã€ã‚³ãƒ­ãƒ³ã«ã‚ˆã£ã¦ã‚¨ãƒ‡ã‚£ã‚¿ãŒã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã—ã‚„ã™ããªã‚‹ã“ã¨ã§ã™ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ†ã‚­ã‚¹ãƒˆã®æ‰‹ã®è¾¼ã‚“ã è§£æã‚’ã—ãªãã¦ã‚‚ã€ã‚³ãƒ­ãƒ³ã‚’æ¢ã›ã°ã„ã¤ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’å¢—ã‚„ã™ã¹ãã‹ã‚’æ±ºã‚ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../faq/design.rst:779
msgid "Why does Python allow commas at the end of lists and tuples?"
msgstr "ãªãœ Python ã§ã¯ãƒªã‚¹ãƒˆã‚„ã‚¿ãƒ—ãƒ«ã®æœ€å¾Œã«ã‚«ãƒ³ãƒãŒã‚ã£ã¦ã‚‚è‰¯ã„ã®ã§ã™ã‹ï¼Ÿ"

#: ../../faq/design.rst:781
msgid ""
"Python lets you add a trailing comma at the end of lists, tuples, and "
"dictionaries::"
msgstr "Python ã§ã¯ã€ãƒªã‚¹ãƒˆã€ã‚¿ãƒ—ãƒ«ã€è¾æ›¸ã®æœ€å¾Œã®è¦ç´ ã®å¾Œç«¯ã«ã‚«ãƒ³ãƒã‚’ã¤ã‘ã¦ã‚‚è‰¯ã„ã“ã¨ã«ãªã£ã¦ã„ã¾ã™::"

#: ../../faq/design.rst:792
msgid "There are several reasons to allow this."
msgstr "ã“ã‚Œã‚’è¨±ã™ã®ã«ã¯ã€ã„ãã¤ã‹ã®ç†ç”±ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../faq/design.rst:794
msgid ""
"When you have a literal value for a list, tuple, or dictionary spread across"
" multiple lines, it's easier to add more elements because you don't have to "
"remember to add a comma to the previous line.  The lines can also be "
"reordered without creating a syntax error."
msgstr ""
"ãƒªã‚¹ãƒˆã‚„ã‚¿ãƒ—ãƒ«ã‚„è¾æ›¸ã®ãƒªãƒ†ãƒ©ãƒ«ãŒè¤‡æ•°è¡Œã«æ¸¡ã£ã¦ã„ã‚‹ã¨ãã«ã€å‰ã®è¡Œã«ã‚«ãƒ³ãƒã‚’è¿½åŠ ã™ã‚‹ã®ã‚’è¦šãˆã¦ãŠãå¿…è¦ãŒç„¡ã„ãŸã‚ã€è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ã®ãŒæ¥½ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸã€æ–‡æ³•ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã™ã“ã¨ç„¡ãã€è¡Œã®ä¸¦ã¹æ›¿ãˆã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../faq/design.rst:799
msgid ""
"Accidentally omitting the comma can lead to errors that are hard to "
"diagnose. For example::"
msgstr "é–“é•ãˆã¦ã‚«ãƒ³ãƒã‚’è½ã¨ã—ã¦ã—ã¾ã†ã¨ã€è¨ºæ–­ã—ã¥ã‚‰ã„ã‚¨ãƒ©ãƒ¼ã«ã¤ãªãŒã‚Šã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../faq/design.rst:809
msgid ""
"This list looks like it has four elements, but it actually contains three: "
"\"fee\", \"fiefoo\" and \"fum\".  Always adding the comma avoids this source"
" of error."
msgstr ""
"ã“ã®ãƒªã‚¹ãƒˆã«ã¯4ã¤ã®è¦ç´ ãŒã‚ã‚‹ã‚ˆã†ã«è¦‹ãˆã¾ã™ãŒã€å®Ÿéš›ã«ã¯3ã¤ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚\n"
"\"fee\"ã€\"fiefoo\"ã€\"fum\" ã§ã™ã€‚\n"
"å¸¸ã«ã‚«ãƒ³ãƒã‚’ä»˜ã‘ã‚‹ã‚ˆã†ã«ã™ã‚Œã°ã€ã“ã®ç¨®ã®ã‚¨ãƒ©ãƒ¼ãŒé¿ã‘ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../faq/design.rst:812
msgid ""
"Allowing the trailing comma may also make programmatic code generation "
"easier."
msgstr "å¾Œç«¯ã«ã‚«ãƒ³ãƒã‚’ã¤ã‘ã¦ã‚‚è‰¯ã„ã“ã¨ã«ã™ã‚Œã°ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã‚ˆã‚‹ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã‚‚ç°¡å˜ã«ãªã‚Šã¾ã™ã€‚"
