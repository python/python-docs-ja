# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-03-21 12:49+0900\n"
"PO-Revision-Date: 2018-06-29 17:28+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/zipapp.rst:2
msgid ":mod:`zipapp` --- Manage executable python zip archives"
msgstr ":mod:`zipapp` --- å®Ÿè¡Œå¯èƒ½ãª python zip æ›¸åº«ã‚’ç®¡ç†ã™ã‚‹"

#: ../../library/zipapp.rst:9
msgid "**Source code:** :source:`Lib/zipapp.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/zipapp.py`"

#: ../../library/zipapp.rst:16
msgid ""
"This module provides tools to manage the creation of zip files containing "
"Python code, which can be  :ref:`executed directly by the Python interpreter"
" <using-on-interface-options>`.  The module provides both a :ref:`zipapp-"
"command-line-interface` and a :ref:`zipapp-python-api`."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ Python ã‚³ãƒ¼ãƒ‰ã‚’å«ã‚€ zip ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆã‚’è¡Œã†ãƒ„ãƒ¼ãƒ«ã‚’æä¾›ã—ã¾ã™ã€‚\n"
"zip ãƒ•ã‚¡ã‚¤ãƒ«ã¯ :ref:`Python ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã§ç›´æ¥å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ <using-on-interface-options>`ã€‚\n"
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :ref:`zipapp-command-line-interface` ã¨ :ref:`zipapp-python-api` ã®ä¸¡æ–¹ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/zipapp.rst:23
msgid "Basic Example"
msgstr "åŸºæœ¬çš„ãªä¾‹"

#: ../../library/zipapp.rst:25
msgid ""
"The following example shows how the :ref:`zipapp-command-line-interface` can"
" be used to create an executable archive from a directory containing Python "
"code.  When run, the archive will execute the ``main`` function from the "
"module ``myapp`` in the archive."
msgstr ""
"å®Ÿè¡Œå¯èƒ½ãªã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’ Python ã‚³ãƒ¼ãƒ‰ã‚’å«ã‚€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ä½œæˆã™ã‚‹ç‚ºã« :ref:`zipapp-command-line-interface`"
" ã‚’ã©ã®ã‚ˆã†ã«åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã‚’ä»¥ä¸‹ã«ä¾‹ç¤ºã—ã¾ã™ã€‚ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¯å®Ÿè¡Œæ™‚ã«ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å†…ã® ``myapp`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ ``main`` "
"é–¢æ•°ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../library/zipapp.rst:40
msgid "Command-Line Interface"
msgstr "ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹"

#: ../../library/zipapp.rst:42
msgid ""
"When called as a program from the command line, the following form is used:"
msgstr "ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‹ã‚‰ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã—ã¦å‘¼ã³å‡ºã™å ´åˆã¯ã€æ¬¡ã®å½¢å¼ã‚’ä½¿ç”¨ã„ã¾ã™:"

#: ../../library/zipapp.rst:48
msgid ""
"If *source* is a directory, this will create an archive from the contents of"
" *source*.  If *source* is a file, it should be an archive, and it will be "
"copied to the target archive (or the contents of its shebang line will be "
"displayed if the --info option is specified)."
msgstr ""
"*source* ãŒãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã‚ã‚‹å ´åˆã€ *source* ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å†…å®¹ã‹ã‚‰ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’ä½œæˆã—ã¾ã™ã€‚\n"
"*source* ãŒãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚ã‚‹å ´åˆã€ *source* ãƒ•ã‚¡ã‚¤ãƒ«è‡ªèº«ã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åŒ–ã—ã€ä¿å­˜å…ˆã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¸ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚(ã¾ãŸã¯ --info ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚·ã‚§ãƒãƒ³è¡ŒãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚)"

#: ../../library/zipapp.rst:53
msgid "The following options are understood:"
msgstr "ä»¥ä¸‹ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒè§£é‡ˆã•ã‚Œã¾ã™:"

#: ../../library/zipapp.rst:59
msgid ""
"Write the output to a file named *output*.  If this option is not specified,"
" the output filename will be the same as the input *source*, with the "
"extension ``.pyz`` added.  If an explicit filename is given, it is used as "
"is (so a ``.pyz`` extension should be included if required)."
msgstr ""
"å‡ºåŠ›ã‚’ *output* ã«æŒ‡å®šã—ãŸåå‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¸æ›¸è¾¼ã¿ã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€å‡ºåŠ›å…ˆãƒ•ã‚¡ã‚¤ãƒ«åã¯å…¥åŠ›å…ƒ *source* ã¨åŒã˜ã«ãªã‚Šã€ ``.pyz`` æ‹¡å¼µå­ãŒä»˜ä¸ã•ã‚Œã¾ã™ã€‚\n"
"ãƒ•ã‚¡ã‚¤ãƒ«åãŒæ˜ç¤ºçš„ã«æŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«åã‚’ä½¿ç”¨ã—ã¾ã™ã€‚(å¿…è¦ã§ã‚ã‚Œã° ``.pyz`` æ‹¡å¼µå­ãŒå«ã¾ã‚Œã¾ã™ã€‚)"

#: ../../library/zipapp.rst:64
msgid ""
"An output filename must be specified if the *source* is an archive (and in "
"that case, *output* must not be the same as *source*)."
msgstr ""
"*source* ãŒã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã§ã‚ã‚‹å ´åˆã¯ã€å‡ºåŠ›å…ˆãƒ•ã‚¡ã‚¤ãƒ«åã‚’å¿…ãšæŒ‡å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"(*source* ãŒã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã§ã‚ã‚‹å ´åˆã¯ *output* ã‚’å¿…ãš *source* ã¨ã¯åˆ¥ã®åå‰ã«ã—ã¦ãã ã•ã„ã€‚)"

#: ../../library/zipapp.rst:69
msgid ""
"Add a ``#!`` line to the archive specifying *interpreter* as the command to "
"run.  Also, on POSIX, make the archive executable.  The default is to write "
"no ``#!`` line, and not make the file executable."
msgstr ""
"å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰ã¨ã—ã¦ã® *interpreter* ã‚’æŒ‡å®šã™ã‚‹ ``#!`` è¡Œã‚’æ›¸åº«ã«è¿½åŠ ã—ã¾ã™ã€‚\n"
"ã¾ãŸã€POSIX ã§ã¯æ›¸åº«ã‚’å®Ÿè¡Œå¯èƒ½ã«ã—ã¾ã™ã€‚\n"
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``#!`` è¡Œã‚’æ›¸ã‹ãšã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å®Ÿè¡Œå¯èƒ½ã«ã¯ã—ã¾ã›ã‚“ã€‚"

#: ../../library/zipapp.rst:75
msgid ""
"Write a ``__main__.py`` file to the archive that executes *mainfn*.  The "
"*mainfn* argument should have the form \"pkg.mod:fn\", where \"pkg.mod\" is "
"a package/module in the archive, and \"fn\" is a callable in the given "
"module. The ``__main__.py`` file will execute that callable."
msgstr ""
"*mainfn* ã‚’å®Ÿè¡Œã™ã‚‹ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¸ ``__main__.py`` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸è¾¼ã‚“ã§ãã ã•ã„ã€‚\n"
"*mainfn* å¼•æ•°ã¯ \"pkg.mod:fn\" ã®å½¢å¼ã§æŒ‡å®šã—ã¾ã™ã€‚\n"
"\"pkg.mod\" ã®å ´æ‰€ã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å†…ã® package/module ã§ã™ã€‚\n"
"\"fn\" ã¯æŒ‡å®šã—ãŸ module ã‹ã‚‰å‘¼å‡ºã™ã“ã¨ã®ã§ãã‚‹é–¢æ•°ã§ã™ã€‚\n"
"``__main__.py`` ãƒ•ã‚¡ã‚¤ãƒ«ãŒ module ã‹ã‚‰å‘¼å‡ºã™ã“ã¨ã®ã§ãã‚‹é–¢æ•°ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../library/zipapp.rst:80
msgid ":option:`--main` cannot be specified when copying an archive."
msgstr "æ›¸åº«ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹éš›ã€ :option:`--main` ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã¯å‡ºæ¥ã¾ã›ã‚“ã€‚"

#: ../../library/zipapp.rst:84
msgid ""
"Display the interpreter embedded in the archive, for diagnostic purposes.  "
"In this case, any other options are ignored and SOURCE must be an archive, "
"not a directory."
msgstr ""
"è¨ºæ–­ã™ã‚‹ãŸã‚ã«æ›¸åº«ã«åŸ‹ã‚è¾¼ã¾ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚\n"
"ã“ã®å ´åˆã€ä»–ã®å…¨ã¦ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ç„¡è¦–ã•ã‚Œã€SOURCE ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã¯ãªãæ›¸åº«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/zipapp.rst:90
msgid "Print a short usage message and exit."
msgstr "ç°¡å˜ãªä½¿ç”¨æ³•ã‚’è¡¨ç¤ºã—ã¦çµ‚äº†ã—ã¾ã™ã€‚"

#: ../../library/zipapp.rst:96
msgid "Python API"
msgstr "Python API"

#: ../../library/zipapp.rst:98
msgid "The module defines two convenience functions:"
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ 2 ã¤ã®ç°¡ä¾¿é–¢æ•°ã‚’å®šç¾©ã—ã¦ã„ã¾ã™:"

#: ../../library/zipapp.rst:103
msgid ""
"Create an application archive from *source*.  The source can be any of the "
"following:"
msgstr ""
"*source* ã‹ã‚‰ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³æ›¸åº«ã‚’ä½œæˆã—ã¾ã™ã€‚\n"
"ã‚½ãƒ¼ã‚¹ã¯ä»¥ä¸‹ã®ã„ãšã‚Œã‹ã§ã™:"

#: ../../library/zipapp.rst:106
msgid ""
"The name of a directory, or a :class:`pathlib.Path` object referring to a "
"directory, in which case a new application archive will be created from the "
"content of that directory."
msgstr ""
"ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã€ã¾ãŸã¯\n"
"æ–°ã—ã„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãŒãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‹ã‚‰ä½œæˆã•ã‚Œã‚‹å ´åˆã«\n"
":class:`pathlib.Path` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‚ç…§ã™ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã€‚"

#: ../../library/zipapp.rst:109
msgid ""
"The name of an existing application archive file, or a :class:`pathlib.Path`"
" object referring to such a file, in which case the file is copied to the "
"target (modifying it to reflect the value given for the *interpreter* "
"argument).  The file name should include the ``.pyz`` extension, if "
"required."
msgstr ""
"æ—¢å­˜ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ã€\n"
"ã¾ãŸã¯(*interpreter* å¼•æ•°ã«æŒ‡å®šã—ãŸå€¤ã‚’åæ˜ ã—ã€ä¿®æ­£ã™ã‚‹)ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¸\n"
"ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚³ãƒ”ãƒ¼ã•ã‚Œã‚‹å ´åˆã« :class:`pathlib.Path` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‚ç…§ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã€‚"

#: ../../library/zipapp.rst:113
msgid ""
"A file object open for reading in bytes mode.  The content of the file "
"should be an application archive, and the file object is assumed to be "
"positioned at the start of the archive."
msgstr ""
"ãƒã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ã®èª­è¾¼ã¿ã§é–‹ããƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚\n"
"ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ãŒã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¨ãªã‚Šã€\n"
"ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã®èµ·ç‚¹ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/zipapp.rst:117
msgid ""
"The *target* argument determines where the resulting archive will be "
"written:"
msgstr "*target* å¼•æ•°ã¯ä½œæˆã•ã‚Œã‚‹æ›¸åº«ãŒæ›¸ãè¾¼ã¾ã‚Œã‚‹å ´æ‰€ã‚’æ±ºã‚ã¾ã™:"

#: ../../library/zipapp.rst:120
msgid ""
"If it is the name of a file, or a :class:`pathlb.Path` object, the archive "
"will be written to that file."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«åã€ã¾ãŸã¯ :class:`pathlb.Path` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã—ãŸå ´åˆã€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¯æŒ‡å®šã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã¸æ›¸è¾¼ã¾ã‚Œã¾ã™ã€‚"

#: ../../library/zipapp.rst:122
msgid ""
"If it is an open file object, the archive will be written to that file "
"object, which must be open for writing in bytes mode."
msgstr ""
"é–‹ã„ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã—ãŸå ´åˆã€\n"
"ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¯ãã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸æ›¸è¾¼ã¿ã‚’è¡Œãªã„ã¾ã™ã€‚ \n"
"ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¿…ãšãƒã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ã®æ›¸è¾¼ã¿ã§é–‹ã„ã¦ãã ã•ã„ã€‚"

#: ../../library/zipapp.rst:124
msgid ""
"If the target is omitted (or ``None``), the source must be a directory and "
"the target will be a file with the same name as the source, with a ``.pyz`` "
"extension added."
msgstr ""
"target ã‚’æŒ‡å®šã—ãªã„ã‹ ``None`` ã‚’æ¸¡ã—ãŸå ´åˆã€ source ã¯å¿…ãšãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ãªã‘ã‚Œã°ãªã‚‰ãšã€target ã¯ source "
"ã®ãƒ•ã‚¡ã‚¤ãƒ«åã« ``.pyz`` æ‹¡å¼µå­ã‚’ä»˜ä¸ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«åã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/zipapp.rst:128
msgid ""
"The *interpreter* argument specifies the name of the Python interpreter with"
" which the archive will be executed.  It is written as a \"shebang\" line at"
" the start of the archive.  On POSIX, this will be interpreted by the OS, "
"and on Windows it will be handled by the Python launcher.  Omitting the "
"*interpreter* results in no shebang line being written.  If an interpreter "
"is specified, and the target is a filename, the executable bit of the target"
" file will be set."
msgstr ""
"*interpreter* å¼•æ•°ã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãŒå®Ÿè¡Œæ™‚ã«ä½¿ç”¨ã™ã‚‹ Python ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã®åå‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚\n"
"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿åã¯ \"ã‚·ã‚§ãƒãƒ³\" è¡Œã¨ã—ã¦ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã®èµ·ç‚¹ã«æ›¸è¾¼ã¾ã‚Œã¾ã™ã€‚\n"
"POSIX ã§ã¯ OS ã«ã‚ˆã£ã¦ã‚·ã‚§ãƒãƒ³ãŒè§£é‡ˆã•ã‚Œã€\n"
"Windows ã§ã¯ Python ãƒ©ãƒ³ãƒãƒ£ãƒ¼ã«ã‚ˆã£ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚\n"
"ã‚·ã‚§ãƒãƒ³è¡ŒãŒæ›¸è¾¼ã¾ã‚Œã¦ã„ãªã„å ´åˆã¯ *interpreter* ã®çµæœã‚’ç„¡è¦–ã—ã¾ã™ã€‚\n"
"interpreter ãŒæŒ‡å®šã•ã‚Œã¦ãŠã‚Šã€ target ãŒãƒ•ã‚¡ã‚¤ãƒ«åã§ã‚ã‚‹å ´åˆã€\n"
"target ãƒ•ã‚¡ã‚¤ãƒ«ã®å®Ÿè¡Œå¯èƒ½ãƒ“ãƒƒãƒˆãŒè¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/zipapp.rst:136
msgid ""
"The *main* argument specifies the name of a callable which will be used as "
"the main program for the archive.  It can only be specified if the source is"
" a directory, and the source does not already contain a ``__main__.py`` "
"file.  The *main* argument should take the form \"pkg.module:callable\" and "
"the archive will be run by importing \"pkg.module\" and executing the given "
"callable with no arguments.  It is an error to omit *main* if the source is "
"a directory and does not contain a ``__main__.py`` file, as otherwise the "
"resulting archive would not be executable."
msgstr ""
"*main* å¼•æ•°ã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã®ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ callable ã®åå‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚\n"
"*main* å¼•æ•°ã¯ source ãŒãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã‚ã‚Šã€ source ãŒæ—¢ã« ``__main__.py`` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿æŒã—ã¦ã„ãªã„å ´åˆã«é™ã‚Šã€æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚\n"
"*main* å¼•æ•°ã¯ \"pkg.module:callable\" ã®å½¢å¼ã‚’å–ã‚Šã€\n"
"ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¯ \"pkg.module\" ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦å®Ÿè¡Œã•ã‚Œã€\n"
"æŒ‡å®šã—ãŸ callable ã‚’å¼•æ•°ãªã—ã§å®Ÿè¡Œã—ã¾ã™ã€‚\n"
"source ãŒãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã‚ã‚Šã€ ``__main__.py`` ãŒå«ã¾ã‚Œã¦ã„ãªã„å ´åˆã€\n"
"*main* ã¯ç„¡è¦–ã™ã¹ãã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã€\n"
"ä½œæˆã•ã‚ŒãŸã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«ã¯å®Ÿè¡Œå¯èƒ½ãƒ“ãƒƒãƒˆãŒè¨­å®šã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/zipapp.rst:146
msgid ""
"If a file object is specified for *source* or *target*, it is the caller's "
"responsibility to close it after calling create_archive."
msgstr ""
"*source* ã¾ãŸã¯ *target* ã¸ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã—ãŸå ´åˆã€\n"
"caller ãŒ create_archive ã®å‘¼å‡ºã—å¾Œã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é–‰ã˜ã¾ã™ã€‚"

#: ../../library/zipapp.rst:149
msgid ""
"When copying an existing archive, file objects supplied only need ``read`` "
"and ``readline``, or ``write`` methods.  When creating an archive from a "
"directory, if the target is a file object it will be passed to the "
"``zipfile.ZipFile`` class, and must supply the methods needed by that class."
msgstr ""
"æ—¢å­˜ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹éš›ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ ``read`` , ``readline`` , ``write`` ãƒ¡ã‚½ãƒƒãƒ‰ã®ã¿ã‚’æä¾›ã—ã¾ã™ã€‚\n"
"ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ä½œæˆã™ã‚‹éš›ã€ target ãŒãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹å ´åˆã¯ã€\n"
"``zipfile.ZipFile`` ã‚¯ãƒ©ã‚¹ã¸æ¸¡ã•ã‚Œã¾ã™ã€‚å¿…ãšã‚¯ãƒ©ã‚¹ãŒå¿…è¦ã¨ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/zipapp.rst:157
msgid ""
"Return the interpreter specified in the ``#!`` line at the start of the "
"archive.  If there is no ``#!`` line, return :const:`None`. The *archive* "
"argument can be a filename or a file-like object open for reading in bytes "
"mode.  It is assumed to be at the start of the archive."
msgstr ""
"ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã®æœ€åˆã®è¡Œã® ``#!`` ã«æŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã‚’è¿”ã—ã¾ã™ã€‚\n"
"``#!`` ãŒç„¡ã„å ´åˆã¯ :const:`None` ã‚’è¿”ã—ã¾ã™ã€‚\n"
"*archive* å¼•æ•°ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«åã¾ãŸã¯ãƒã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ã®èª­è¾¼ã¿ã§é–‹ã„ãŸ\n"
"ãƒ•ã‚¡ã‚¤ãƒ«ã«æº–ã˜ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã®èµ·ç‚¹ã§æ±ºå®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/zipapp.rst:166
msgid "Examples"
msgstr "ä½¿ç”¨ä¾‹"

#: ../../library/zipapp.rst:168
msgid "Pack up a directory into an archive, and run it."
msgstr "ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æ›¸åº«ã«åœ§ç¸®ã—ã€å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../library/zipapp.rst:176
msgid "The same can be done using the :func:`create_archive` functon::"
msgstr "åŒã˜ã“ã¨ã‚’ :func:`create_archive` é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦è¡Œã†ã“ã¨ãŒå‡ºæ¥ã¾ã™::"

#: ../../library/zipapp.rst:181
msgid ""
"To make the application directly executable on POSIX, specify an interpreter"
" to use."
msgstr "POSIX ã§ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç›´æ¥å®Ÿè¡Œå¯èƒ½ã«ã™ã‚‹ã«ã¯ä½¿ç”¨ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã‚’æŒ‡å®šã—ã¾ã™ã€‚"

#: ../../library/zipapp.rst:190
msgid ""
"To replace the shebang line on an existing archive, create a modified "
"archive using the :func:`create_archive` function::"
msgstr ""
"ã‚·ãƒãƒ³è¡Œã‚’æ—¢å­˜ã®æ›¸åº«ã§ç½®æ›ã™ã‚‹ã«ã¯ã€ :func:`create_archive` function: ã‚’ä½¿ç”¨ã—ã¦å¤‰æ›´ã•ã‚ŒãŸæ›¸åº«ã‚’ä½œæˆã—ã¾ã™:"

#: ../../library/zipapp.rst:196
msgid ""
"To update the file in place, do the replacement in memory using a "
":class:`BytesIO` object, and then overwrite the source afterwards.  Note "
"that there is a risk when overwriting a file in place that an error will "
"result in the loss of the original file.  This code does not protect against"
" such errors, but production code should do so.  Also, this method will only"
" work if the archive fits in memory::"
msgstr ""
"ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°ã™ã‚‹ã«ã¯ :class:`BytesIO` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã—ã¦ãƒ¡ãƒ¢ãƒªãƒ¼ã¸æ ¼ç´ã—ã€\n"
"å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸Šæ›¸ãã—ã¦ç½®æ›ã—ã¦ãã ã•ã„ã€‚\n"
"ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸Šæ›¸ãã™ã‚‹éš›ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã€å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒå¤±ã‚ã‚Œã‚‹å±é™ºæ€§ãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚\n"
"ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ä¸Šè¨˜ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿è­·ã—ã¾ã›ã‚“ãŒã€ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ‰ã¯ä¿è­·ã™ã‚‹ã¹ãã§ã™ã€‚\n"
"ã“ã®æ–¹æ³•ã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãŒãƒ¡ãƒ¢ãƒªãƒ¼ã«åã¾ã‚‹å ´åˆã«ã®ã¿å‹•ä½œã—ã¾ã™::"

#: ../../library/zipapp.rst:214
msgid "Specifying the Interpreter"
msgstr "ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã®æŒ‡å®š"

#: ../../library/zipapp.rst:216
msgid ""
"Note that if you specify an interpreter and then distribute your application"
" archive, you need to ensure that the interpreter used is portable.  The "
"Python launcher for Windows supports most common forms of POSIX ``#!`` line,"
" but there are other issues to consider:"
msgstr ""

#: ../../library/zipapp.rst:221
msgid ""
"If you use \"/usr/bin/env python\" (or other forms of the \"python\" "
"command, such as \"/usr/bin/python\"), you need to consider that your users "
"may have either Python 2 or Python 3 as their default, and write your code "
"to work under both versions."
msgstr ""

#: ../../library/zipapp.rst:225
msgid ""
"If you use an explicit version, for example \"/usr/bin/env python3\" your "
"application will not work for users who do not have that version.  (This may"
" be what you want if you have not made your code Python 2 compatible)."
msgstr ""

#: ../../library/zipapp.rst:228
msgid ""
"There is no way to say \"python X.Y or later\", so be careful of using an "
"exact version like \"/usr/bin/env python3.4\" as you will need to change "
"your shebang line for users of Python 3.5, for example."
msgstr ""

#: ../../library/zipapp.rst:232
msgid ""
"Typically, you should use an \"/usr/bin/env python2\" or \"/usr/bin/env "
"python3\", depending on whether your code is written for Python 2 or 3."
msgstr ""

#: ../../library/zipapp.rst:237
msgid "Creating Standalone Applications with zipapp"
msgstr ""

#: ../../library/zipapp.rst:239
msgid ""
"Using the :mod:`zipapp` module, it is possible to create self-contained "
"Python programs, which can be distributed to end users who only need to have"
" a suitable version of Python installed on their system.  The key to doing "
"this is to bundle all of the application's dependencies into the archive, "
"along with the application code."
msgstr ""

#: ../../library/zipapp.rst:245
msgid "The steps to create a standalone archive are as follows:"
msgstr ""

#: ../../library/zipapp.rst:247
msgid ""
"Create your application in a directory as normal, so you have a ``myapp`` "
"directory containing a ``__main__.py`` file, and any supporting application "
"code."
msgstr ""

#: ../../library/zipapp.rst:251
msgid ""
"Install all of your application's dependencies into the ``myapp`` directory,"
" using pip:"
msgstr ""

#: ../../library/zipapp.rst:258
msgid ""
"(this assumes you have your project requirements in a ``requirements.txt`` "
"file - if not, you can just list the dependencies manually on the pip "
"command line)."
msgstr ""

#: ../../library/zipapp.rst:262
msgid ""
"Optionally, delete the ``.dist-info`` directories created by pip in the "
"``myapp`` directory. These hold metadata for pip to manage the packages, and"
" as you won't be making any further use of pip they aren't required - "
"although it won't do any harm if you leave them."
msgstr ""

#: ../../library/zipapp.rst:267
msgid "Package the application using:"
msgstr ""

#: ../../library/zipapp.rst:273
msgid ""
"This will produce a standalone executable, which can be run on any machine "
"with the appropriate interpreter available. See :ref:`zipapp-specifying-the-"
"interpreter` for details. It can be shipped to users as a single file."
msgstr ""

#: ../../library/zipapp.rst:277
msgid ""
"On Unix, the ``myapp.pyz`` file is executable as it stands.  You can rename "
"the file to remove the ``.pyz`` extension if you prefer a \"plain\" command "
"name.  On Windows, the ``myapp.pyz[w]`` file is executable by virtue of the "
"fact that the Python interpreter registers the ``.pyz`` and ``.pyzw`` file "
"extensions when installed."
msgstr ""

#: ../../library/zipapp.rst:285
msgid "Making a Windows executable"
msgstr ""

#: ../../library/zipapp.rst:287
msgid ""
"On Windows, registration of the ``.pyz`` extension is optional, and "
"furthermore, there are certain places that don't recognise registered "
"extensions \"transparently\" (the simplest example is that "
"``subprocess.run(['myapp'])`` won't find your application - you need to "
"explicitly specify the extension)."
msgstr ""

#: ../../library/zipapp.rst:293
msgid ""
"On Windows, therefore, it is often preferable to create an executable from "
"the zipapp.  This is relatively easy, although it does require a C compiler."
"  The basic approach relies on the fact that zipfiles can have arbitrary "
"data prepended, and Windows exe files can have arbitrary data appended.  So "
"by creating a suitable launcher and tacking the ``.pyz`` file onto the end "
"of it, you end up with a single-file executable that runs your application."
msgstr ""

#: ../../library/zipapp.rst:300
msgid "A suitable launcher can be as simple as the following::"
msgstr ""

#: ../../library/zipapp.rst:325
msgid ""
"If you define the ``WINDOWS`` preprocessor symbol, this will generate a GUI "
"executable, and without it, a console executable."
msgstr ""

#: ../../library/zipapp.rst:328
msgid ""
"To compile the executable, you can either just use the standard MSVC command"
" line tools, or you can take advantage of the fact that distutils knows how "
"to compile Python source::"
msgstr ""

#: ../../library/zipapp.rst:355
msgid ""
"The resulting launcher uses the \"Limited ABI\", so it will run unchanged "
"with any version of Python 3.x.  All it needs is for Python "
"(``python3.dll``) to be on the user's ``PATH``."
msgstr ""

#: ../../library/zipapp.rst:359
msgid ""
"For a fully standalone distribution, you can distribute the launcher with "
"your application appended, bundled with the Python \"embedded\" "
"distribution.  This will run on any PC with the appropriate architecture (32"
" bit or 64 bit)."
msgstr ""

#: ../../library/zipapp.rst:365
msgid "Caveats"
msgstr ""

#: ../../library/zipapp.rst:367
msgid ""
"There are some limitations to the process of bundling your application into "
"a single file.  In most, if not all, cases they can be addressed without "
"needing major changes to your application."
msgstr ""

#: ../../library/zipapp.rst:371
msgid ""
"If your application depends on a package that includes a C extension, that "
"package cannot be run from a zip file (this is an OS limitation, as "
"executable code must be present in the filesystem for the OS loader to load "
"it). In this case, you can exclude that dependency from the zipfile, and "
"either require your users to have it installed, or ship it alongside your "
"zipfile and add code to your ``__main__.py`` to include the directory "
"containing the unzipped module in ``sys.path``. In this case, you will need "
"to make sure to ship appropriate binaries for your target architecture(s) "
"(and potentially pick the correct version to add to ``sys.path`` at runtime,"
" based on the user's machine)."
msgstr ""

#: ../../library/zipapp.rst:381
msgid ""
"If you are shipping a Windows executable as described above, you either need"
" to ensure that your users have ``python3.dll`` on their PATH (which is not "
"the default behaviour of the installer) or you should bundle your "
"application with the embedded distribution."
msgstr ""

#: ../../library/zipapp.rst:386
msgid ""
"The suggested launcher above uses the Python embedding API.  This means that"
" in your application, ``sys.executable`` will be your application, and *not*"
" a conventional Python interpreter.  Your code and its dependencies need to "
"be prepared for this possibility.  For example, if your application uses the"
" :mod:`multiprocessing` module, it will need to call "
":func:`multiprocessing.set_executable` to let the module know where to find "
"the standard Python interpreter."
msgstr ""

#: ../../library/zipapp.rst:396
msgid "The Python Zip Application Archive Format"
msgstr ""

#: ../../library/zipapp.rst:398
msgid ""
"Python has been able to execute zip files which contain a ``__main__.py`` "
"file since version 2.6.  In order to be executed by Python, an application "
"archive simply has to be a standard zip file containing a ``__main__.py`` "
"file which will be run as the entry point for the application.  As usual for"
" any Python script, the parent of the script (in this case the zip file) "
"will be placed on :data:`sys.path` and thus further modules can be imported "
"from the zip file."
msgstr ""

#: ../../library/zipapp.rst:405
msgid ""
"The zip file format allows arbitrary data to be prepended to a zip file.  "
"The zip application format uses this ability to prepend a standard POSIX "
"\"shebang\" line to the file (``#!/path/to/interpreter``)."
msgstr ""

#: ../../library/zipapp.rst:409
msgid "Formally, the Python zip application format is therefore:"
msgstr ""

#: ../../library/zipapp.rst:411
msgid ""
"An optional shebang line, containing the characters ``b'#!'`` followed by an"
" interpreter name, and then a newline (``b'\\n'``) character.  The "
"interpreter name can be anything acceptable to the OS \"shebang\" "
"processing, or the Python launcher on Windows.  The interpreter should be "
"encoded in UTF-8 on Windows, and in :func:`sys.getfilesystemencoding()` on "
"POSIX."
msgstr ""

#: ../../library/zipapp.rst:416
msgid ""
"Standard zipfile data, as generated by the :mod:`zipfile` module.  The "
"zipfile content *must* include a file called ``__main__.py`` (which must be "
"in the \"root\" of the zipfile - i.e., it cannot be in a subdirectory).  The"
" zipfile data can be compressed or uncompressed."
msgstr ""

#: ../../library/zipapp.rst:421
msgid ""
"If an application archive has a shebang line, it may have the executable bit"
" set on POSIX systems, to allow it to be executed directly."
msgstr ""

#: ../../library/zipapp.rst:424
msgid ""
"There is no requirement that the tools in this module are used to create "
"application archives - the module is a convenience, but archives in the "
"above format created by any means are acceptable to Python."
msgstr ""
