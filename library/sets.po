# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2017-09-22 17:57+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/sets.rst:3
msgid ":mod:`sets` --- Unordered collections of unique elements"
msgstr ":mod:`sets` --- é‡è¤‡ã®ãªã„è¦ç´ ã®é †åºãªã—ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³"

#: ../../library/sets.rst:16
msgid ""
"The built-in :class:`set`/:class:`frozenset` types replace this module."
msgstr "çµ„ã¿è¾¼ã¿ã® :class:`set`/:class:`frozenset` å‹ãŒã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç½®ãæ›ãˆã¾ã™ã€‚"

#: ../../library/sets.rst:19
msgid ""
"The :mod:`sets` module provides classes for constructing and manipulating "
"unordered collections of unique elements.  Common uses include membership "
"testing, removing duplicates from a sequence, and computing standard math "
"operations on sets such as intersection, union, difference, and symmetric "
"difference."
msgstr ":mod:`sets` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªè¦ç´ ã®é †åºãªã—ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã—ã€æ“ä½œã™ã‚‹ãŸã‚ã®ã‚¯ãƒ©ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚å¸°å±é–¢ä¿‚ã®ãƒ†ã‚¹ãƒˆã‚„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‹ã‚‰é‡è¤‡ã‚’å–ã‚Šé™¤ã„ãŸã‚Šã€ç©é›†åˆãƒ»å’Œé›†åˆãƒ»å·®é›†åˆãƒ»å¯¾ç§°å·®é›†åˆã®ã‚ˆã†ãªæ¨™æº–çš„ãªæ•°å­¦æ“ä½œãªã©ã‚’å«ã¿ã¾ã™ã€‚"

#: ../../library/sets.rst:25
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x"
" in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr "é›†åˆã¯ã€ä»–ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¨åŒæ§˜ã€ ``x in set``, ``len(set)``, ``for x in set`` ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ã¯é †åºãŒãªã„ã®ã§ã€é›†åˆã¯æŒ¿å…¥ã®é †åºã‚„è¦ç´ ã®ä½ç½®ã‚’è¨˜éŒ²ã—ã¾ã›ã‚“ã€‚å¾“ã£ã¦ã€é›†åˆã¯ã‚¤ãƒ³ãƒ‡ã‚¯ã‚·ãƒ³ã‚°ã€ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ã€ãã®ä»–ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹çš„ãªæŒ¯èˆã„ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚"

#: ../../library/sets.rst:30
msgid ""
"Most set applications use the :class:`Set` class which provides every set "
"method except for :meth:`__hash__`. For advanced applications requiring a "
"hash method, the :class:`ImmutableSet` class adds a :meth:`__hash__` method "
"but omits methods which alter the contents of the set. Both :class:`Set` and"
" :class:`ImmutableSet` derive from :class:`BaseSet`, an abstract class "
"useful for determining whether something is a set: ``isinstance(obj, "
"BaseSet)``."
msgstr "ã»ã¨ã‚“ã©ã®é›†åˆã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ :meth:`__hash__` ã‚’é™¤ã„ã¦ã™ã¹ã¦ã®é›†åˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã™ã‚‹ :class:`Set` ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ãƒãƒƒã‚·ãƒ¥ã‚’è¦æ±‚ã™ã‚‹é«˜åº¦ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ã¤ã„ã¦ã¯ã€ :class:`ImmutableSet` ã‚¯ãƒ©ã‚¹ãŒ :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’åŠ ãˆã¦ã„ã‚‹ãŒã€é›†åˆã®å†…å®¹ã‚’å¤‰æ›´ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã¯çœç•¥ã•ã‚Œã¾ã™ã€‚ :class:`Set` ã¨ :class:`ImmutableSet` ã¯ã€ä½•ãŒé›†åˆã§ã‚ã‚‹ã‹æ±ºã‚ã‚‹ã®ã«å½¹ç«‹ã¤ (``isinstance(obj, BaseSet)``) æŠ½è±¡ã‚¯ãƒ©ã‚¹ :class:`BaseSet` ã‹ã‚‰æ´¾ç”Ÿã—ã¾ã™ã€‚"

#: ../../library/sets.rst:37
msgid ""
"The set classes are implemented using dictionaries.  Accordingly, the "
"requirements for set elements are the same as those for dictionary keys; "
"namely, that the element defines both :meth:`__eq__` and :meth:`__hash__`. "
"As a result, sets cannot contain mutable elements such as lists or "
"dictionaries. However, they can contain immutable collections such as tuples"
" or instances of :class:`ImmutableSet`.  For convenience in implementing "
"sets of sets, inner sets are automatically converted to immutable form, for "
"example, ``Set([Set(['dog'])])`` is transformed to "
"``Set([ImmutableSet(['dog'])])``."
msgstr "é›†åˆã‚¯ãƒ©ã‚¹ã¯è¾æ›¸ã‚’ä½¿ç”¨ã—ã¦å®Ÿè£…ã•ã‚Œã¾ã™ã€‚ã“ã®ã“ã¨ã‹ã‚‰ã€é›†åˆã®è¦ç´ ã«ã™ã‚‹ã«ã¯è¾æ›¸ã®ã‚­ãƒ¼ã¨åŒæ§˜ã®è¦ä»¶ã‚’æº€ãŸã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å…·ä½“çš„ã«ã¯ã€è¦ç´ ã«ãªã‚‹ã‚‚ã®ã«ã¯ :meth:`__eq__` ã¨ :meth:`__hash__` ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã¨ã„ã†æ¡ä»¶ã§ã™ã€‚ãã®çµæœã€é›†åˆã¯ãƒªã‚¹ãƒˆã‚„è¾æ›¸ã®ã‚ˆã†ãªå¤‰æ›´å¯èƒ½ãªè¦ç´ ã‚’å«ã‚€ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ã—ã‹ã—ãã‚Œã‚‰ã¯ã€ã‚¿ãƒ—ãƒ«ã‚„ :class:`ImmutableSet` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚ˆã†ãªä¸å¤‰ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å«ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚é›†åˆã®é›†åˆã®å®Ÿè£…ä¸­ã®ä¾¿å®œã«ã¤ã„ã¦ã¯ã€å†…éƒ¨é›†åˆãŒè‡ªå‹•çš„ã«å¤‰æ›´ä¸å¯èƒ½ãªå½¢å¼ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ``Set([Set(['dog'])])`` ã¯ ``Set([ImmutableSet(['dog'])])`` ã¸å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/sets.rst:49
msgid ""
"Constructs a new empty :class:`Set` object.  If the optional *iterable* "
"parameter is supplied, updates the set with elements obtained from "
"iteration. All of the elements in *iterable* should be immutable or be "
"transformable to an immutable using the protocol described in section :ref"
":`immutable-transforms`."
msgstr "æ–°ã—ã„ç©ºã® :class:`Set` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚ã‚‚ã—ã‚ªãƒ—ã‚·ãƒ§ãƒ³ *iterable* ãŒä¸ãˆã‚‰ã‚ŒãŸã‚‰ã€ã‚¤ã‚¿ãƒ¬ãƒ¼ã‚¿ã‹ã‚‰å¾—ã‚‰ã‚ŒãŸè¦ç´ ã‚’å‚™ãˆãŸé›†åˆã¨ã—ã¦æ›´æ–°ã—ã¾ã™ã€‚ *iterable* ä¸­ã®å…¨ã¦ã®è¦ç´ ã¯ã€å¤‰æ›´ä¸å¯èƒ½ã§ã‚ã‚‹ã‹ã€ã¾ãŸã¯ :ref:`immutable-transforms` ã§è¨˜è¿°ã•ã‚ŒãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ä½¿ã£ã¦å¤‰æ›´ä¸å¯èƒ½ãªã‚‚ã®ã«å¤‰æ›å¯èƒ½ã§ã‚ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/sets.rst:57
msgid ""
"Constructs a new empty :class:`ImmutableSet` object.  If the optional "
"*iterable* parameter is supplied, updates the set with elements obtained "
"from iteration. All of the elements in *iterable* should be immutable or be "
"transformable to an immutable using the protocol described in section :ref"
":`immutable-transforms`."
msgstr "æ–°ã—ã„ç©ºã® :class:`ImmutableSet` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚ã‚‚ã—ã‚ªãƒ—ã‚·ãƒ§ãƒ³ *iterable* ãŒä¸ãˆã‚‰ã‚ŒãŸã‚‰ã€ã‚¤ã‚¿ãƒ¬ãƒ¼ã‚¿ã‹ã‚‰å¾—ã‚‰ã‚ŒãŸè¦ç´ ã‚’å‚™ãˆãŸé›†åˆã¨ã—ã¦æ›´æ–°ã—ã¾ã™ã€‚ *iterable* ä¸­ã®å…¨ã¦ã®è¦ç´ ã¯ã€å¤‰æ›´ä¸å¯èƒ½ã§ã‚ã‚‹ã‹ã€ã¾ãŸã¯ :ref:`immutable-transforms` ã§è¨˜è¿°ã•ã‚ŒãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ä½¿ã£ã¦å¤‰æ›´ä¸å¯èƒ½ãªã‚‚ã®ã«å¤‰æ›å¯èƒ½ã§ã‚ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/sets.rst:62
msgid ""
"Because :class:`ImmutableSet` objects provide a :meth:`__hash__` method, "
"they can be used as set elements or as dictionary keys.  "
":class:`ImmutableSet` objects do not have methods for adding or removing "
"elements, so all of the elements must be known when the constructor is "
"called."
msgstr ":class:`ImmutableSet` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‚™ãˆã¦ã„ã‚‹ã®ã§ã€é›†åˆè¦ç´ ã¾ãŸã¯è¾æ›¸ã‚­ãƒ¼ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ :class:`ImmutableSet` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è¦ç´ ã‚’åŠ ãˆãŸã‚Šå–ã‚Šé™¤ã„ãŸã‚Šã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã›ã‚“ã€‚ã—ãŸãŒã£ã¦ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã°ã‚ŒãŸã¨ãè¦ç´ ã¯ã™ã¹ã¦çŸ¥ã‚‰ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/sets.rst:71
msgid "Set Objects"
msgstr "Set ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/sets.rst:73
msgid ""
"Instances of :class:`Set` and :class:`ImmutableSet` both provide the "
"following operations:"
msgstr ":class:`Set` ã¨ :class:`ImmutableSet` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã¨ã‚‚ã«ã€ä»¥ä¸‹ã®æ“ä½œã‚’å‚™ãˆã¦ã„ã¾ã™:"

#: ../../library/sets.rst:77 ../../library/sets.rst:139
#: ../../library/sets.rst:148
msgid "Operation"
msgstr "æ¼”ç®—"

#: ../../library/sets.rst:77 ../../library/sets.rst:148
msgid "Equivalent"
msgstr "ç­‰ä¾¡ãªæ¼”ç®—"

#: ../../library/sets.rst:77 ../../library/sets.rst:139
#: ../../library/sets.rst:148
msgid "Result"
msgstr "çµæœ"

#: ../../library/sets.rst:79
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../library/sets.rst:79
msgid "number of elements in set *s* (cardinality)"
msgstr "é›†åˆ *s* ã®è¦ç´ æ•° (æ¿ƒåº¦)"

#: ../../library/sets.rst:82
msgid "``x in s``"
msgstr "``x in s``"

#: ../../library/sets.rst:82
msgid "test *x* for membership in *s*"
msgstr "*x* ãŒ *s* ã«å¸°å±ã—ã¦ã„ã‚Œã°çœŸã‚’è¿”ã™"

#: ../../library/sets.rst:84
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../../library/sets.rst:84
msgid "test *x* for non-membership in *s*"
msgstr "*x* ãŒ *s* ã«å¸°å±ã—ã¦ã„ãªã‘ã‚Œã°çœŸã‚’è¿”ã™"

#: ../../library/sets.rst:87
msgid "``s.issubset(t)``"
msgstr "``s.issubset(t)``"

#: ../../library/sets.rst:87
msgid "``s <= t``"
msgstr "``s <= t``"

#: ../../library/sets.rst:87
msgid "test whether every element in *s* is in *t*"
msgstr "*s* ã®ã™ã¹ã¦ã®è¦ç´ ãŒ *t* ã«å¸°å±ã—ã¦ã„ã‚Œã°çœŸã‚’è¿”ã™"

#: ../../library/sets.rst:90
msgid "``s.issuperset(t)``"
msgstr "``s.issuperset(t)``"

#: ../../library/sets.rst:90
msgid "``s >= t``"
msgstr "``s >= t``"

#: ../../library/sets.rst:90
msgid "test whether every element in *t* is in *s*"
msgstr "*t* ã®ã™ã¹ã¦ã®è¦ç´ ãŒ *s* ã«å¸°å±ã—ã¦ã„ã‚Œã°çœŸã‚’è¿”ã™"

#: ../../library/sets.rst:93
msgid "``s.union(t)``"
msgstr "``s.union(t)``"

#: ../../library/sets.rst:93
msgid "``s | t``"
msgstr "``s | t``"

#: ../../library/sets.rst:93
msgid "new set with elements from both *s* and *t*"
msgstr "*s* ã¨ *t* ã®ä¸¡æ–¹ã®è¦ç´ ã‹ã‚‰ãªã‚‹æ–°ã—ã„é›†åˆ"

#: ../../library/sets.rst:96
msgid "``s.intersection(t)``"
msgstr "``s.intersection(t)``"

#: ../../library/sets.rst:96
msgid "``s & t``"
msgstr "``s & t``"

#: ../../library/sets.rst:96
msgid "new set with elements common to *s* and *t*"
msgstr "*s* ã¨ *t* ã§å…±é€šã™ã‚‹è¦ç´ ã‹ã‚‰ãªã‚‹æ–°ã—ã„é›†åˆ"

#: ../../library/sets.rst:99
msgid "``s.difference(t)``"
msgstr "``s.difference(t)``"

#: ../../library/sets.rst:99
msgid "``s - t``"
msgstr "``s - t``"

#: ../../library/sets.rst:99
msgid "new set with elements in *s* but not in *t*"
msgstr "*s* ã«ã‚ã‚‹ãŒ *t* ã«ãªã„è¦ç´ ã‹ã‚‰ãªã‚‹æ–°ã—ã„é›†åˆ"

#: ../../library/sets.rst:102
msgid "``s.symmetric_difference(t)``"
msgstr "``s.symmetric_difference(t)``"

#: ../../library/sets.rst:102
msgid "``s ^ t``"
msgstr "``s ^ t``"

#: ../../library/sets.rst:102
msgid "new set with elements in either *s* or *t* but not both"
msgstr "*s* ã¨ *t* ã®ã©ã¡ã‚‰ã‹ä¸€æ–¹ã ã‘ã«å±ã™ã‚‹è¦ç´ ã‹ã‚‰ãªã‚‹é›†åˆ"

#: ../../library/sets.rst:105
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../../library/sets.rst:105
msgid "new set with a shallow copy of *s*"
msgstr "*s* ã®æµ…ã„ã‚³ãƒ”ãƒ¼ã‹ã‚‰ãªã‚‹é›†åˆ"

#: ../../library/sets.rst:109
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, "
":meth:`difference`, and :meth:`symmetric_difference` will accept any "
"iterable as an argument. In contrast, their operator based counterparts "
"require their arguments to be sets.  This precludes error-prone "
"constructions like ``Set('abc') & 'cbs'`` in favor of the more readable "
"``Set('abc').intersection('cbs')``."
msgstr "æ¼”ç®—å­ã‚’ä½¿ã‚ãªã„æ›¸ãæ–¹ã§ã‚ã‚‹ :meth:`union`, :meth:`intersection`, :meth:`difference`, ãŠã‚ˆã³ :meth:`symmetric_difference` ã¯ä»»æ„ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚‹ã®ã«å¯¾ã—ã€æ¼”ç®—å­ã‚’ä½¿ã£ãŸæ›¸ãæ–¹ã®æ–¹ã§ã¯å¼•æ•°ã¯é›†åˆå‹ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã¯ã‚¨ãƒ©ãƒ¼ã®å…ƒã¨ãªã‚‹ ``Set('abc') & 'cbs'`` ã®ã‚ˆã†ãªæ›¸ãæ–¹ã‚’æ’é™¤ã—ã€ã‚ˆã‚Šå¯èª­æ€§ã®ã‚ã‚‹ ``Set('abc').intersection('cbs')`` ã‚’é¸ã°ã›ã‚‹ãŸã‚ã®ä»•æ§˜ã§ã™ã€‚"

#: ../../library/sets.rst:116 ../../library/sets.rst:182
msgid "Formerly all arguments were required to be sets."
msgstr "ä»¥å‰ã¯å…¨ã¦ã®å¼•æ•°ãŒé›†åˆå‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚"

#: ../../library/sets.rst:119
msgid ""
"In addition, both :class:`Set` and :class:`ImmutableSet` support set to set "
"comparisons.  Two sets are equal if and only if every element of each set is"
" contained in the other (each is a subset of the other). A set is less than "
"another set if and only if the first set is a proper subset of the second "
"set (is a subset, but is not equal). A set is greater than another set if "
"and only if the first set is a proper superset of the second set (is a "
"superset, but is not equal)."
msgstr "åŠ ãˆã¦ã€ :class:`Set` ã¨ :class:`ImmutableSet` ã¯é›†åˆé–“ã®æ¯”è¼ƒã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚äºŒã¤ã®é›†åˆã¯ã€å„ã€…ã®é›†åˆã®ã™ã¹ã¦ã®è¦ç´ ãŒä»–æ–¹ã«å«ã¾ã‚Œã¦ (å„ã€…ãŒä»–æ–¹ã®éƒ¨åˆ†é›†åˆ) ã„ã‚‹å ´åˆã€ã‹ã¤ãã®å ´åˆã«é™ã‚Šç­‰ä¾¡ã«ãªã‚Šã¾ã™ã€‚ã‚ã‚‹é›†åˆã¯ã€ä»–æ–¹ã®é›†åˆã®çœŸã®éƒ¨åˆ†é›†åˆ (proper subsetã€éƒ¨åˆ†é›†åˆã§ã‚ã‚‹ãŒéç­‰ä¾¡) ã§ã‚ã‚‹å ´åˆã€ã‹ã¤ãã®å ´åˆã«é™ã‚Šã€ä»–æ–¹ã®é›†åˆã‚ˆã‚Šå°ã•ããªã‚Šã¾ã™ã€‚ã‚ã‚‹é›†åˆã¯ã€ä»–æ–¹ã®é›†åˆã®çœŸã®ä¸Šä½é›†åˆ (proper supersetã€ä¸Šä½é›†åˆã§ã‚ã‚‹ãŒéç­‰ä¾¡) ã§ã‚ã‚‹å ´åˆã€ã‹ã¤ãã®å ´åˆã«é™ã‚Šã€ä»–æ–¹ã®é›†åˆã‚ˆã‚Šå¤§ãããªã‚Šã¾ã™ã€‚"

#: ../../library/sets.rst:127
msgid ""
"The subset and equality comparisons do not generalize to a complete ordering"
" function.  For example, any two disjoint sets are not equal and are not "
"subsets of each other, so *all* of the following return ``False``:  ``a<b``,"
" ``a==b``, or ``a>b``. Accordingly, sets do not implement the "
":meth:`__cmp__` method."
msgstr "éƒ¨åˆ†é›†åˆæ¯”è¼ƒã‚„ã¨ç­‰å€¤æ¯”è¼ƒã§ã¯ã€å®Œå…¨ãªé †åºæ±ºå®šé–¢æ•°ã‚’ä¸€èˆ¬åŒ–ã§ãã¾ã›ã‚“ã€‚ãŸã¨ãˆã°ã€äº’ã„ã«ç´ ãª 2 ã¤ã®é›†åˆã¯ç­‰ã—ãã‚ã‚Šã¾ã›ã‚“ã—ã€äº’ã„ã®éƒ¨åˆ†é›†åˆã§ã‚‚ãªã„ã®ã§ã€ ``a<b``, ``a==b``, ``a>b`` ã¯ *ã™ã¹ã¦* ``False`` ã‚’è¿”ã—ã¾ã™ã€‚ã—ãŸãŒã£ã¦é›†åˆã¯ :meth:`__cmp__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã›ã‚“ã€‚"

#: ../../library/sets.rst:132
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr "é›†åˆã¯åŠé †åºï¼ˆéƒ¨åˆ†é›†åˆé–¢ä¿‚ï¼‰ã—ã‹å®šç¾©ã—ãªã„ã®ã§ã€é›†åˆã®ãƒªã‚¹ãƒˆã«ãŠã‘ã‚‹ :meth:`list.sort` ãƒ¡ã‚½ãƒƒãƒ‰ã®å‡ºåŠ›ã¯æœªå®šç¾©ã§ã™ã€‚"

#: ../../library/sets.rst:135
msgid ""
"The following table lists operations available in :class:`ImmutableSet` but "
"not found in :class:`Set`:"
msgstr "ä»¥ä¸‹ã¯ :class:`ImmutableSet` ã§åˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ãŒ :class:`Set` ã«ã¯ãªã„æ“ä½œã§ã™:"

#: ../../library/sets.rst:141
msgid "``hash(s)``"
msgstr "``hash(s)``"

#: ../../library/sets.rst:141
msgid "returns a hash value for *s*"
msgstr "*s* ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¿”ã™"

#: ../../library/sets.rst:144
msgid ""
"The following table lists operations available in :class:`Set` but not found"
" in :class:`ImmutableSet`:"
msgstr "ä»¥ä¸‹ã¯ :class:`Set` ã§åˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ãŒ :class:`ImmutableSet` ã«ã¯ãªã„æ“ä½œã§ã™:"

#: ../../library/sets.rst:150
msgid "``s.update(t)``"
msgstr "``s.update(t)``"

#: ../../library/sets.rst:150
msgid "*s* \\|= *t*"
msgstr "*s* \\|= *t*"

#: ../../library/sets.rst:150
msgid "return set *s* with elements added from *t*"
msgstr "*t* ã‚’åŠ ãˆãŸè¦ç´ ã‹ã‚‰ãªã‚‹é›†åˆ *s* ã‚’è¿”ã—ã¾ã™"

#: ../../library/sets.rst:153
msgid "``s.intersection_update(t)``"
msgstr "``s.intersection_update(t)``"

#: ../../library/sets.rst:153
msgid "*s* &= *t*"
msgstr "*s* &= *t*"

#: ../../library/sets.rst:153
msgid "return set *s* keeping only elements also found in *t*"
msgstr "*t* ã§ã‚‚è¦‹ã¤ã‹ã£ãŸè¦ç´ ã ã‘ã‚’æŒã¤é›†åˆ *s* ã‚’è¿”ã—ã¾ã™"

#: ../../library/sets.rst:156
msgid "``s.difference_update(t)``"
msgstr "``s.difference_update(t)``"

#: ../../library/sets.rst:156
msgid "*s* -= *t*"
msgstr "*s* -= *t*"

#: ../../library/sets.rst:156
msgid "return set *s* after removing elements found in *t*"
msgstr "*t* ã«ã‚ã£ãŸè¦ç´ ã‚’å–ã‚Šé™¤ã„ãŸå¾Œã®é›†åˆ *s* ã‚’è¿”ã—ã¾ã™"

#: ../../library/sets.rst:159
msgid "``s.symmetric_difference_update(t)``"
msgstr "``s.symmetric_difference_update(t)``"

#: ../../library/sets.rst:159
msgid "*s* ^= *t*"
msgstr "*s* ^= *t*"

#: ../../library/sets.rst:159
msgid "return set *s* with elements from *s* or *t* but not both"
msgstr "*s* ã¨ *t* ã®ã©ã¡ã‚‰ã‹ä¸€æ–¹ã ã‘ã«å±ã™ã‚‹è¦ç´ ã‹ã‚‰ãªã‚‹é›†åˆ *s* ã‚’è¿”ã—ã¾ã™"

#: ../../library/sets.rst:162
msgid "``s.add(x)``"
msgstr "``s.add(x)``"

#: ../../library/sets.rst:162
msgid "add element *x* to set *s*"
msgstr "è¦ç´  *x* ã‚’é›†åˆ *s* ã«åŠ ãˆã¾ã™"

#: ../../library/sets.rst:164
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/sets.rst:164
msgid "remove *x* from set *s*; raises :exc:`KeyError` if not present"
msgstr "è¦ç´  *x* ã‚’é›†åˆ *s* ã‹ã‚‰å–ã‚Šé™¤ãã¾ã™; *x* ãŒãªã‘ã‚Œã° :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™"

#: ../../library/sets.rst:167
msgid "``s.discard(x)``"
msgstr "``s.discard(x)``"

#: ../../library/sets.rst:167
msgid "removes *x* from set *s* if present"
msgstr "è¦ç´  *x* ãŒå­˜åœ¨ã™ã‚Œã°ã€é›†åˆ *s* ã‹ã‚‰å–ã‚Šé™¤ãã¾ã™"

#: ../../library/sets.rst:170
msgid "``s.pop()``"
msgstr "``s.pop()``"

#: ../../library/sets.rst:170
msgid ""
"remove and return an arbitrary element from *s*; raises :exc:`KeyError` if "
"empty"
msgstr "*s* ã‹ã‚‰ä»»æ„ã«è¦ç´ ã‚’å–ã‚Šé™¤ãã€ãã‚Œã‚’è¿”ã—ã¾ã™; é›†åˆãŒç©ºãªã‚‰ :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™"

#: ../../library/sets.rst:174
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../../library/sets.rst:174
msgid "remove all elements from set *s*"
msgstr "é›†åˆ *s* ã‹ã‚‰ã™ã¹ã¦ã®è¦ç´ ã‚’å–ã‚Šé™¤ãã¾ã™"

#: ../../library/sets.rst:178
msgid ""
"Note, the non-operator versions of :meth:`update`, "
":meth:`intersection_update`, :meth:`difference_update`, and "
":meth:`symmetric_difference_update` will accept any iterable as an argument."
msgstr "æ¼”ç®—å­ã‚’ä½¿ã‚ãªã„æ›¸ãæ–¹ã§ã‚ã‚‹ :meth:`update`, :meth:`intersection_update`, :meth:`difference_update`, ãŠã‚ˆã³ :meth:`symmetric_difference_update` ã¯ä»»æ„ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚‹ã“ã¨ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/sets.rst:185
msgid ""
"Also note, the module also includes a :meth:`union_update` method which is "
"an alias for :meth:`update`.  The method is included for backwards "
"compatibility. Programmers should prefer the :meth:`update` method because "
"it is supported by the built-in :class:`set()` and :class:`frozenset()` "
"types."
msgstr "ã‚‚ã†ä¸€ã¤æ³¨æ„ã‚’è¿°ã¹ã¾ã™ãŒã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ :meth:`union_update` ãŒ :meth:`update` ã®åˆ¥åã¨ã—ã¦å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã«æ®‹ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã§ã™ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯çµ„ã¿è¾¼ã¿ã® :class:`set()` ãŠã‚ˆã³ :class:`frozenset()` ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ :meth:`update` ã‚’é¸ã¶ã¹ãã§ã™ã€‚"

#: ../../library/sets.rst:194
msgid "Example"
msgstr "ä½¿ç”¨ä¾‹"

#: ../../library/sets.rst:224
msgid "Protocol for automatic conversion to immutable"
msgstr "ä¸å¤‰ã«è‡ªå‹•å¤‰æ›ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«"

#: ../../library/sets.rst:226
msgid ""
"Sets can only contain immutable elements.  For convenience, mutable "
":class:`Set` objects are automatically copied to an :class:`ImmutableSet` "
"before being added as a set element."
msgstr "é›†åˆã¯å¤‰æ›´ä¸å¯èƒ½ãªè¦ç´ ã ã‘ã‚’å«ã‚€ã“ã¨ã§ãã¾ã™ã€‚éƒ½åˆä¸Šã€å¤‰æ›´å¯èƒ½ãª :class:`Set` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€é›†åˆè¦ç´ ã¨ã—ã¦åŠ ãˆã‚‰ã‚Œã‚‹å‰ã«ã€è‡ªå‹•çš„ã« :class:`ImmutableSet` ã¸ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚"

#: ../../library/sets.rst:230
msgid ""
"The mechanism is to always add a :term:`hashable` element, or if it is not "
"hashable, the element is checked to see if it has an "
":meth:`__as_immutable__` method which returns an immutable equivalent."
msgstr "ãã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã¯ãƒãƒƒã‚·ãƒ¥å¯èƒ½ãª (:term:`hashable`) è¦ç´ ã‚’å¸¸ã«åŠ ãˆã‚‹ã“ã¨ã§ã™ãŒã€ã‚‚ã—ãƒãƒƒã‚·ãƒ¥ä¸å¯èƒ½ãªå ´åˆã¯ã€ãã®è¦ç´ ã¯å¤‰æ›´ä¸å¯èƒ½ãªç­‰ä¾¡ç‰©ã‚’è¿”ã™ :meth:`__as_immutable__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã‚‹ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚"

#: ../../library/sets.rst:234
msgid ""
"Since :class:`Set` objects have a :meth:`__as_immutable__` method returning "
"an instance of :class:`ImmutableSet`, it is possible to construct sets of "
"sets."
msgstr ":class:`Set` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ :class:`ImmutableSet` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™ :meth:`__as_immutable__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã‚‹ã®ã§ã€é›†åˆã®é›†åˆã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚"

#: ../../library/sets.rst:237
msgid ""
"A similar mechanism is needed by the :meth:`__contains__` and :meth:`remove`"
" methods which need to hash an element to check for membership in a set.  "
"Those methods check an element for hashability and, if not, check for a "
":meth:`__as_temporarily_immutable__` method which returns the element "
"wrapped by a class that provides temporary methods for :meth:`__hash__`, "
":meth:`__eq__`, and :meth:`__ne__`."
msgstr "é›†åˆå†…ã®ãƒ¡ãƒ³ãƒãƒ¼ã§ã‚ã‚‹ã“ã¨ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãŸã‚ã«ã€è¦ç´ ã‚’ãƒãƒƒã‚·ãƒ¥ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ :meth:`__contains__` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ :meth:`remove` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã€åŒæ§˜ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’å¿…è¦ã¨ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯è¦ç´ ãŒãƒãƒƒã‚·ãƒ¥ã§ãã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚ã‚‚ã—å‡ºæ¥ãªã‘ã‚Œã°-- :meth:`__hash__`, :meth:`__eq__`, :meth:`__ne__` ã®ãŸã‚ã®ä¸€æ™‚çš„ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‚™ãˆãŸã‚¯ãƒ©ã‚¹ã«ã‚ˆã£ã¦ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸè¦ç´ ã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰-- :meth:`__as_temporarily_immutable__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/sets.rst:244
msgid ""
"The alternate mechanism spares the need to build a separate copy of the "
"original mutable object."
msgstr "ä»£ç†ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã¯ã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã®å¯å¤‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰åˆ†ã‹ã‚ŒãŸã‚³ãƒ”ãƒ¼ã‚’çµ„ã¿ä¸Šã’ã‚‹æ‰‹é–“ã‚’åŠ©ã‘ã¦ãã‚Œã¾ã™ã€‚"

#: ../../library/sets.rst:247
msgid ""
":class:`Set` objects implement the :meth:`__as_temporarily_immutable__` "
"method which returns the :class:`Set` object wrapped by a new class "
":class:`_TemporarilyImmutableSet`."
msgstr ":class:`Set` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€æ–°ã—ã„ã‚¯ãƒ©ã‚¹ :class:`_TemporarilyImmutableSet` ã«ã‚ˆã£ã¦ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸ :class:`Set` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã€ :meth:`__as_temporarily_immutable__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../library/sets.rst:251
msgid ""
"The two mechanisms for adding hashability are normally invisible to the "
"user; however, a conflict can arise in a multi-threaded environment where "
"one thread is updating a set while another has temporarily wrapped it in "
":class:`_TemporarilyImmutableSet`.  In other words, sets of mutable sets are"
" not thread-safe."
msgstr "ãƒãƒƒã‚·ãƒ¥å¯èƒ½ã‚’ä¸ãˆã‚‹ãŸã‚ã® 2 ã¤ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã¯é€šå¸¸ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è¦‹ãˆã¾ã›ã‚“ã€‚ã—ã‹ã—ãªãŒã‚‰ã€ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ç’°å¢ƒä¸‹ã«ãŠã„ã¦ã¯ã€ :class:`_TemporarilyImmutableSet` ã«ã‚ˆã£ã¦ä¸€æ™‚çš„ã«ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸã‚‚ã®ã‚’æŒã£ã¦ã„ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚ã‚‹ã¨ãã«ã€ã‚‚ã†ä¸€ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒé›†åˆã‚’æ›´æ–°ã™ã‚‹ã“ã¨ã§ã€è¡çªã‚’ç™ºç”Ÿã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚è¨€ã„ã‹ãˆã‚Œã°ã€å¤‰æ›´å¯èƒ½ãªé›†åˆã®é›†åˆã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/sets.rst:261
msgid "Comparison to the built-in :class:`set` types"
msgstr "çµ„ã¿è¾¼ã¿ :class:`set` å‹ã¨ã®æ¯”è¼ƒ"

#: ../../library/sets.rst:263
msgid ""
"The built-in :class:`set` and :class:`frozenset` types were designed based "
"on lessons learned from the :mod:`sets` module.  The key differences are:"
msgstr "çµ„ã¿è¾¼ã¿ã® :class:`set` ãŠã‚ˆã³ :class:`frozenset` å‹ã¯ã“ã® :mod:`sets` ã§å­¦ã‚“ã ã“ã¨ã‚’ç”Ÿã‹ã—ã¦è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚ä¸»ãªé•ã„ã¯æ¬¡ã®é€šã‚Šã§ã™ã€‚"

#: ../../library/sets.rst:266
msgid ""
":class:`Set` and :class:`ImmutableSet` were renamed to :class:`set` and "
":class:`frozenset`."
msgstr ":class:`Set` ã¨ :class:`ImmutableSet` ã¯ :class:`set` ã¨ :class:`frozenset` ã«æ”¹åã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/sets.rst:269
msgid ""
"There is no equivalent to :class:`BaseSet`.  Instead, use ``isinstance(x, "
"(set, frozenset))``."
msgstr ":class:`BaseSet` ã«ç›¸å½“ã™ã‚‹ã‚‚ã®ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã« ``isinstance(x, (set, frozenset))`` ã‚’ä½¿ã£ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/sets.rst:272
msgid ""
"The hash algorithm for the built-ins performs significantly better (fewer "
"collisions) for most datasets."
msgstr "çµ„ã¿è¾¼ã¿ã®ã‚‚ã®ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ãƒãƒƒã‚·ãƒ¥ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€å¤šãã®ãƒ‡ãƒ¼ã‚¿é›†åˆã«å¯¾ã—ã¦ãšã£ã¨è‰¯ã„æ€§èƒ½ (å°‘ãªã„è¡çª) ã‚’å®Ÿç¾ã—ã¾ã™ã€‚"

#: ../../library/sets.rst:275
msgid "The built-in versions have more space efficient pickles."
msgstr "çµ„ã¿è¾¼ã¿ã®ã‚‚ã®ã¯ã‚ˆã‚Šç©ºé–“åŠ¹ç‡è‰¯ã pickle åŒ–ã§ãã¾ã™ã€‚"

#: ../../library/sets.rst:277
msgid ""
"The built-in versions do not have a :meth:`union_update` method. Instead, "
"use the :meth:`update` method which is equivalent."
msgstr "çµ„ã¿è¾¼ã¿ã®ã‚‚ã®ã«ã¯ :meth:`union_update` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«åŒã˜æ©Ÿèƒ½ã® :meth:`update` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/sets.rst:280
msgid ""
"The built-in versions do not have a ``_repr(sorted=True)`` method. Instead, "
"use the built-in :func:`repr` and :func:`sorted` functions: "
"``repr(sorted(s))``."
msgstr "çµ„ã¿è¾¼ã¿ã®ã‚‚ã®ã«ã¯ `_repr(sorted=True)` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«çµ„ã¿è¾¼ã¿é–¢æ•°ã® :func:`repr` ã¨ :func:`sorted` ã‚’ä½¿ã£ã¦ ``repr(sorted(s))`` ã¨ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/sets.rst:284
msgid ""
"The built-in version does not have a protocol for automatic conversion to "
"immutable.  Many found this feature to be confusing and no one in the "
"community reported having found real uses for it."
msgstr "çµ„ã¿è¾¼ã¿ã®ã‚‚ã®ã¯å¤‰æ›´ä¸å¯èƒ½ãªã‚‚ã®ã«è‡ªå‹•ã§å¤‰æ›ã™ã‚‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®æ©Ÿèƒ½ã¯å¤šãã®äººãŒå›°æƒ‘ã‚’è¦šãˆã‚‹ã‚ã‚Šã«ã€ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã®èª°ã‹ã‚‰ã‚‚å®Ÿéš›çš„ãªä½¿ç”¨ä¾‹ã®å ±å‘ŠãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚"
