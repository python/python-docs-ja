# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト)
# This file is distributed under the same license as the Python package.
# 
# Translators:
# cocoatomo, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: 2017-09-22 17:57+0000\n"
"Last-Translator: cocoatomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/sets.rst:3
msgid ":mod:`sets` --- Unordered collections of unique elements"
msgstr ":mod:`sets` --- 重複のない要素の順序なしコレクション"

#: ../../library/sets.rst:16
msgid ""
"The built-in :class:`set`/:class:`frozenset` types replace this module."
msgstr "組み込みの :class:`set`/:class:`frozenset` 型がこのモジュールを置き換えます。"

#: ../../library/sets.rst:19
msgid ""
"The :mod:`sets` module provides classes for constructing and manipulating "
"unordered collections of unique elements.  Common uses include membership "
"testing, removing duplicates from a sequence, and computing standard math "
"operations on sets such as intersection, union, difference, and symmetric "
"difference."
msgstr ":mod:`sets` モジュールは、ユニークな要素の順序なしコレクションを構築し、操作するためのクラスを提供します。帰属関係のテストやシーケンスから重複を取り除いたり、積集合・和集合・差集合・対称差集合のような標準的な数学操作などを含みます。"

#: ../../library/sets.rst:25
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x"
" in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr "集合は、他のコレクションと同様、 ``x in set``, ``len(set)``, ``for x in set`` をサポートします。コレクションには順序がないので、集合は挿入の順序や要素の位置を記録しません。従って、集合はインデクシング、スライシング、その他のシーケンス的な振舞いをサポートしません。"

#: ../../library/sets.rst:30
msgid ""
"Most set applications use the :class:`Set` class which provides every set "
"method except for :meth:`__hash__`. For advanced applications requiring a "
"hash method, the :class:`ImmutableSet` class adds a :meth:`__hash__` method "
"but omits methods which alter the contents of the set. Both :class:`Set` and"
" :class:`ImmutableSet` derive from :class:`BaseSet`, an abstract class "
"useful for determining whether something is a set: ``isinstance(obj, "
"BaseSet)``."
msgstr "ほとんどの集合のアプリケーションは、 :meth:`__hash__` を除いてすべての集合のメソッドを提供する :class:`Set` クラスを使用します。ハッシュを要求する高度なアプリケーションについては、 :class:`ImmutableSet` クラスが :meth:`__hash__` メソッドを加えているが、集合の内容を変更するメソッドは省略されます。 :class:`Set` と :class:`ImmutableSet` は、何が集合であるか決めるのに役立つ (``isinstance(obj, BaseSet)``) 抽象クラス :class:`BaseSet` から派生します。"

#: ../../library/sets.rst:37
msgid ""
"The set classes are implemented using dictionaries.  Accordingly, the "
"requirements for set elements are the same as those for dictionary keys; "
"namely, that the element defines both :meth:`__eq__` and :meth:`__hash__`. "
"As a result, sets cannot contain mutable elements such as lists or "
"dictionaries. However, they can contain immutable collections such as tuples"
" or instances of :class:`ImmutableSet`.  For convenience in implementing "
"sets of sets, inner sets are automatically converted to immutable form, for "
"example, ``Set([Set(['dog'])])`` is transformed to "
"``Set([ImmutableSet(['dog'])])``."
msgstr "集合クラスは辞書を使用して実装されます。このことから、集合の要素にするには辞書のキーと同様の要件を満たさなければなりません。具体的には、要素になるものには :meth:`__eq__` と :meth:`__hash__` が定義されているという条件です。その結果、集合はリストや辞書のような変更可能な要素を含むことができません。しかしそれらは、タプルや :class:`ImmutableSet` のインスタンスのような不変コレクションを含むことができます。集合の集合の実装中の便宜については、内部集合が自動的に変更不可能な形式に変換されます。例えば、 ``Set([Set(['dog'])])`` は ``Set([ImmutableSet(['dog'])])`` へ変換されます。"

#: ../../library/sets.rst:49
msgid ""
"Constructs a new empty :class:`Set` object.  If the optional *iterable* "
"parameter is supplied, updates the set with elements obtained from "
"iteration. All of the elements in *iterable* should be immutable or be "
"transformable to an immutable using the protocol described in section :ref"
":`immutable-transforms`."
msgstr "新しい空の :class:`Set` オブジェクトを構築します。もしオプション *iterable* が与えられたら、イタレータから得られた要素を備えた集合として更新します。 *iterable* 中の全ての要素は、変更不可能であるか、または :ref:`immutable-transforms` で記述されたプロトコルを使って変更不可能なものに変換可能であるべきです。"

#: ../../library/sets.rst:57
msgid ""
"Constructs a new empty :class:`ImmutableSet` object.  If the optional "
"*iterable* parameter is supplied, updates the set with elements obtained "
"from iteration. All of the elements in *iterable* should be immutable or be "
"transformable to an immutable using the protocol described in section :ref"
":`immutable-transforms`."
msgstr "新しい空の :class:`ImmutableSet` オブジェクトを構築します。もしオプション *iterable* が与えられたら、イタレータから得られた要素を備えた集合として更新します。 *iterable* 中の全ての要素は、変更不可能であるか、または :ref:`immutable-transforms` で記述されたプロトコルを使って変更不可能なものに変換可能であるべきです。"

#: ../../library/sets.rst:62
msgid ""
"Because :class:`ImmutableSet` objects provide a :meth:`__hash__` method, "
"they can be used as set elements or as dictionary keys.  "
":class:`ImmutableSet` objects do not have methods for adding or removing "
"elements, so all of the elements must be known when the constructor is "
"called."
msgstr ":class:`ImmutableSet` オブジェクトは :meth:`__hash__` メソッドを備えているので、集合要素または辞書キーとして使用することができます。 :class:`ImmutableSet` オブジェクトは要素を加えたり取り除いたりするメソッドを持っていません。したがって、コンストラクタが呼ばれたとき要素はすべて知られていなければなりません。"

#: ../../library/sets.rst:71
msgid "Set Objects"
msgstr "Set オブジェクト"

#: ../../library/sets.rst:73
msgid ""
"Instances of :class:`Set` and :class:`ImmutableSet` both provide the "
"following operations:"
msgstr ":class:`Set` と :class:`ImmutableSet` のインスタンスはともに、以下の操作を備えています:"

#: ../../library/sets.rst:77 ../../library/sets.rst:139
#: ../../library/sets.rst:148
msgid "Operation"
msgstr "演算"

#: ../../library/sets.rst:77 ../../library/sets.rst:148
msgid "Equivalent"
msgstr "等価な演算"

#: ../../library/sets.rst:77 ../../library/sets.rst:139
#: ../../library/sets.rst:148
msgid "Result"
msgstr "結果"

#: ../../library/sets.rst:79
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../library/sets.rst:79
msgid "number of elements in set *s* (cardinality)"
msgstr "集合 *s* の要素数 (濃度)"

#: ../../library/sets.rst:82
msgid "``x in s``"
msgstr "``x in s``"

#: ../../library/sets.rst:82
msgid "test *x* for membership in *s*"
msgstr "*x* が *s* に帰属していれば真を返す"

#: ../../library/sets.rst:84
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../../library/sets.rst:84
msgid "test *x* for non-membership in *s*"
msgstr "*x* が *s* に帰属していなければ真を返す"

#: ../../library/sets.rst:87
msgid "``s.issubset(t)``"
msgstr "``s.issubset(t)``"

#: ../../library/sets.rst:87
msgid "``s <= t``"
msgstr "``s <= t``"

#: ../../library/sets.rst:87
msgid "test whether every element in *s* is in *t*"
msgstr "*s* のすべての要素が *t* に帰属していれば真を返す"

#: ../../library/sets.rst:90
msgid "``s.issuperset(t)``"
msgstr "``s.issuperset(t)``"

#: ../../library/sets.rst:90
msgid "``s >= t``"
msgstr "``s >= t``"

#: ../../library/sets.rst:90
msgid "test whether every element in *t* is in *s*"
msgstr "*t* のすべての要素が *s* に帰属していれば真を返す"

#: ../../library/sets.rst:93
msgid "``s.union(t)``"
msgstr "``s.union(t)``"

#: ../../library/sets.rst:93
msgid "``s | t``"
msgstr "``s | t``"

#: ../../library/sets.rst:93
msgid "new set with elements from both *s* and *t*"
msgstr "*s* と *t* の両方の要素からなる新しい集合"

#: ../../library/sets.rst:96
msgid "``s.intersection(t)``"
msgstr "``s.intersection(t)``"

#: ../../library/sets.rst:96
msgid "``s & t``"
msgstr "``s & t``"

#: ../../library/sets.rst:96
msgid "new set with elements common to *s* and *t*"
msgstr "*s* と *t* で共通する要素からなる新しい集合"

#: ../../library/sets.rst:99
msgid "``s.difference(t)``"
msgstr "``s.difference(t)``"

#: ../../library/sets.rst:99
msgid "``s - t``"
msgstr "``s - t``"

#: ../../library/sets.rst:99
msgid "new set with elements in *s* but not in *t*"
msgstr "*s* にあるが *t* にない要素からなる新しい集合"

#: ../../library/sets.rst:102
msgid "``s.symmetric_difference(t)``"
msgstr "``s.symmetric_difference(t)``"

#: ../../library/sets.rst:102
msgid "``s ^ t``"
msgstr "``s ^ t``"

#: ../../library/sets.rst:102
msgid "new set with elements in either *s* or *t* but not both"
msgstr "*s* と *t* のどちらか一方だけに属する要素からなる集合"

#: ../../library/sets.rst:105
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../../library/sets.rst:105
msgid "new set with a shallow copy of *s*"
msgstr "*s* の浅いコピーからなる集合"

#: ../../library/sets.rst:109
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, "
":meth:`difference`, and :meth:`symmetric_difference` will accept any "
"iterable as an argument. In contrast, their operator based counterparts "
"require their arguments to be sets.  This precludes error-prone "
"constructions like ``Set('abc') & 'cbs'`` in favor of the more readable "
"``Set('abc').intersection('cbs')``."
msgstr "演算子を使わない書き方である :meth:`union`, :meth:`intersection`, :meth:`difference`, および :meth:`symmetric_difference` は任意のイテレート可能オブジェクトを引数として受け取るのに対し、演算子を使った書き方の方では引数は集合型でなければならないので注意してください。これはエラーの元となる ``Set('abc') & 'cbs'`` のような書き方を排除し、より可読性のある ``Set('abc').intersection('cbs')`` を選ばせるための仕様です。"

#: ../../library/sets.rst:116 ../../library/sets.rst:182
msgid "Formerly all arguments were required to be sets."
msgstr "以前は全ての引数が集合型でなければなりませんでした。"

#: ../../library/sets.rst:119
msgid ""
"In addition, both :class:`Set` and :class:`ImmutableSet` support set to set "
"comparisons.  Two sets are equal if and only if every element of each set is"
" contained in the other (each is a subset of the other). A set is less than "
"another set if and only if the first set is a proper subset of the second "
"set (is a subset, but is not equal). A set is greater than another set if "
"and only if the first set is a proper superset of the second set (is a "
"superset, but is not equal)."
msgstr "加えて、 :class:`Set` と :class:`ImmutableSet` は集合間の比較をサポートしています。二つの集合は、各々の集合のすべての要素が他方に含まれて (各々が他方の部分集合) いる場合、かつその場合に限り等価になります。ある集合は、他方の集合の真の部分集合 (proper subset、部分集合であるが非等価) である場合、かつその場合に限り、他方の集合より小さくなります。ある集合は、他方の集合の真の上位集合 (proper superset、上位集合であるが非等価) である場合、かつその場合に限り、他方の集合より大きくなります。"

#: ../../library/sets.rst:127
msgid ""
"The subset and equality comparisons do not generalize to a complete ordering"
" function.  For example, any two disjoint sets are not equal and are not "
"subsets of each other, so *all* of the following return ``False``:  ``a<b``,"
" ``a==b``, or ``a>b``. Accordingly, sets do not implement the "
":meth:`__cmp__` method."
msgstr "部分集合比較やと等値比較では、完全な順序決定関数を一般化できません。たとえば、互いに素な 2 つの集合は等しくありませんし、互いの部分集合でもないので、 ``a<b``, ``a==b``, ``a>b`` は *すべて* ``False`` を返します。したがって集合は :meth:`__cmp__` メソッドを実装しません。"

#: ../../library/sets.rst:132
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr "集合は半順序（部分集合関係）しか定義しないので、集合のリストにおける :meth:`list.sort` メソッドの出力は未定義です。"

#: ../../library/sets.rst:135
msgid ""
"The following table lists operations available in :class:`ImmutableSet` but "
"not found in :class:`Set`:"
msgstr "以下は :class:`ImmutableSet` で利用可能であるが :class:`Set` にはない操作です:"

#: ../../library/sets.rst:141
msgid "``hash(s)``"
msgstr "``hash(s)``"

#: ../../library/sets.rst:141
msgid "returns a hash value for *s*"
msgstr "*s* のハッシュ値を返す"

#: ../../library/sets.rst:144
msgid ""
"The following table lists operations available in :class:`Set` but not found"
" in :class:`ImmutableSet`:"
msgstr "以下は :class:`Set` で利用可能であるが :class:`ImmutableSet` にはない操作です:"

#: ../../library/sets.rst:150
msgid "``s.update(t)``"
msgstr "``s.update(t)``"

#: ../../library/sets.rst:150
msgid "*s* \\|= *t*"
msgstr "*s* \\|= *t*"

#: ../../library/sets.rst:150
msgid "return set *s* with elements added from *t*"
msgstr "*t* を加えた要素からなる集合 *s* を返します"

#: ../../library/sets.rst:153
msgid "``s.intersection_update(t)``"
msgstr "``s.intersection_update(t)``"

#: ../../library/sets.rst:153
msgid "*s* &= *t*"
msgstr "*s* &= *t*"

#: ../../library/sets.rst:153
msgid "return set *s* keeping only elements also found in *t*"
msgstr "*t* でも見つかった要素だけを持つ集合 *s* を返します"

#: ../../library/sets.rst:156
msgid "``s.difference_update(t)``"
msgstr "``s.difference_update(t)``"

#: ../../library/sets.rst:156
msgid "*s* -= *t*"
msgstr "*s* -= *t*"

#: ../../library/sets.rst:156
msgid "return set *s* after removing elements found in *t*"
msgstr "*t* にあった要素を取り除いた後の集合 *s* を返します"

#: ../../library/sets.rst:159
msgid "``s.symmetric_difference_update(t)``"
msgstr "``s.symmetric_difference_update(t)``"

#: ../../library/sets.rst:159
msgid "*s* ^= *t*"
msgstr "*s* ^= *t*"

#: ../../library/sets.rst:159
msgid "return set *s* with elements from *s* or *t* but not both"
msgstr "*s* と *t* のどちらか一方だけに属する要素からなる集合 *s* を返します"

#: ../../library/sets.rst:162
msgid "``s.add(x)``"
msgstr "``s.add(x)``"

#: ../../library/sets.rst:162
msgid "add element *x* to set *s*"
msgstr "要素 *x* を集合 *s* に加えます"

#: ../../library/sets.rst:164
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/sets.rst:164
msgid "remove *x* from set *s*; raises :exc:`KeyError` if not present"
msgstr "要素 *x* を集合 *s* から取り除きます; *x* がなければ :exc:`KeyError` を送出します"

#: ../../library/sets.rst:167
msgid "``s.discard(x)``"
msgstr "``s.discard(x)``"

#: ../../library/sets.rst:167
msgid "removes *x* from set *s* if present"
msgstr "要素 *x* が存在すれば、集合 *s* から取り除きます"

#: ../../library/sets.rst:170
msgid "``s.pop()``"
msgstr "``s.pop()``"

#: ../../library/sets.rst:170
msgid ""
"remove and return an arbitrary element from *s*; raises :exc:`KeyError` if "
"empty"
msgstr "*s* から任意に要素を取り除き、それを返します; 集合が空なら :exc:`KeyError` を送出します"

#: ../../library/sets.rst:174
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../../library/sets.rst:174
msgid "remove all elements from set *s*"
msgstr "集合 *s* からすべての要素を取り除きます"

#: ../../library/sets.rst:178
msgid ""
"Note, the non-operator versions of :meth:`update`, "
":meth:`intersection_update`, :meth:`difference_update`, and "
":meth:`symmetric_difference_update` will accept any iterable as an argument."
msgstr "演算子を使わない書き方である :meth:`update`, :meth:`intersection_update`, :meth:`difference_update`, および :meth:`symmetric_difference_update` は任意のイテレート可能オブジェクトを引数として受け取ることに注目してください。"

#: ../../library/sets.rst:185
msgid ""
"Also note, the module also includes a :meth:`union_update` method which is "
"an alias for :meth:`update`.  The method is included for backwards "
"compatibility. Programmers should prefer the :meth:`update` method because "
"it is supported by the built-in :class:`set()` and :class:`frozenset()` "
"types."
msgstr "もう一つ注意を述べますが、このモジュールでは :meth:`union_update` が :meth:`update` の別名として含まれています。このメソッドは後方互換性のために残されているものです。プログラマは組み込みの :class:`set()` および :class:`frozenset()` でサポートされている :meth:`update` を選ぶべきです。"

#: ../../library/sets.rst:194
msgid "Example"
msgstr "使用例"

#: ../../library/sets.rst:224
msgid "Protocol for automatic conversion to immutable"
msgstr "不変に自動変換するためのプロトコル"

#: ../../library/sets.rst:226
msgid ""
"Sets can only contain immutable elements.  For convenience, mutable "
":class:`Set` objects are automatically copied to an :class:`ImmutableSet` "
"before being added as a set element."
msgstr "集合は変更不可能な要素だけを含むことできます。都合上、変更可能な :class:`Set` オブジェクトは、集合要素として加えられる前に、自動的に :class:`ImmutableSet` へコピーします。"

#: ../../library/sets.rst:230
msgid ""
"The mechanism is to always add a :term:`hashable` element, or if it is not "
"hashable, the element is checked to see if it has an "
":meth:`__as_immutable__` method which returns an immutable equivalent."
msgstr "そのメカニズムはハッシュ可能な (:term:`hashable`) 要素を常に加えることですが、もしハッシュ不可能な場合は、その要素は変更不可能な等価物を返す :meth:`__as_immutable__` メソッドを持っているかどうかチェックされます。"

#: ../../library/sets.rst:234
msgid ""
"Since :class:`Set` objects have a :meth:`__as_immutable__` method returning "
"an instance of :class:`ImmutableSet`, it is possible to construct sets of "
"sets."
msgstr ":class:`Set` オブジェクトは、 :class:`ImmutableSet` のインスタンスを返す :meth:`__as_immutable__` メソッドを持っているので、集合の集合を構築することが可能です。"

#: ../../library/sets.rst:237
msgid ""
"A similar mechanism is needed by the :meth:`__contains__` and :meth:`remove`"
" methods which need to hash an element to check for membership in a set.  "
"Those methods check an element for hashability and, if not, check for a "
":meth:`__as_temporarily_immutable__` method which returns the element "
"wrapped by a class that provides temporary methods for :meth:`__hash__`, "
":meth:`__eq__`, and :meth:`__ne__`."
msgstr "集合内のメンバーであることをチェックするために、要素をハッシュする必要がある :meth:`__contains__` メソッドと :meth:`remove` メソッドが、同様のメカニズムを必要としています。これらのメソッドは要素がハッシュできるかチェックします。もし出来なければ-- :meth:`__hash__`, :meth:`__eq__`, :meth:`__ne__` のための一時的なメソッドを備えたクラスによってラップされた要素を返すメソッド-- :meth:`__as_temporarily_immutable__` メソッドをチェックします。"

#: ../../library/sets.rst:244
msgid ""
"The alternate mechanism spares the need to build a separate copy of the "
"original mutable object."
msgstr "代理メカニズムは、オリジナルの可変オブジェクトから分かれたコピーを組み上げる手間を助けてくれます。"

#: ../../library/sets.rst:247
msgid ""
":class:`Set` objects implement the :meth:`__as_temporarily_immutable__` "
"method which returns the :class:`Set` object wrapped by a new class "
":class:`_TemporarilyImmutableSet`."
msgstr ":class:`Set` オブジェクトは、新しいクラス :class:`_TemporarilyImmutableSet` によってラップされた :class:`Set` オブジェクトを返す、 :meth:`__as_temporarily_immutable__` メソッドを実装します。"

#: ../../library/sets.rst:251
msgid ""
"The two mechanisms for adding hashability are normally invisible to the "
"user; however, a conflict can arise in a multi-threaded environment where "
"one thread is updating a set while another has temporarily wrapped it in "
":class:`_TemporarilyImmutableSet`.  In other words, sets of mutable sets are"
" not thread-safe."
msgstr "ハッシュ可能を与えるための 2 つのメカニズムは通常ユーザーに見えません。しかしながら、マルチスレッド環境下においては、 :class:`_TemporarilyImmutableSet` によって一時的にラップされたものを持っているスレッドがあるときに、もう一つのスレッドが集合を更新することで、衝突を発生させることができます。言いかえれば、変更可能な集合の集合はスレッドセーフではありません。"

#: ../../library/sets.rst:261
msgid "Comparison to the built-in :class:`set` types"
msgstr "組み込み :class:`set` 型との比較"

#: ../../library/sets.rst:263
msgid ""
"The built-in :class:`set` and :class:`frozenset` types were designed based "
"on lessons learned from the :mod:`sets` module.  The key differences are:"
msgstr "組み込みの :class:`set` および :class:`frozenset` 型はこの :mod:`sets` で学んだことを生かして設計されています。主な違いは次の通りです。"

#: ../../library/sets.rst:266
msgid ""
":class:`Set` and :class:`ImmutableSet` were renamed to :class:`set` and "
":class:`frozenset`."
msgstr ":class:`Set` と :class:`ImmutableSet` は :class:`set` と :class:`frozenset` に改名されました。"

#: ../../library/sets.rst:269
msgid ""
"There is no equivalent to :class:`BaseSet`.  Instead, use ``isinstance(x, "
"(set, frozenset))``."
msgstr ":class:`BaseSet` に相当するものはありません。代わりに ``isinstance(x, (set, frozenset))`` を使って下さい。"

#: ../../library/sets.rst:272
msgid ""
"The hash algorithm for the built-ins performs significantly better (fewer "
"collisions) for most datasets."
msgstr "組み込みのものに使われているハッシュアルゴリズムは、多くのデータ集合に対してずっと良い性能 (少ない衝突) を実現します。"

#: ../../library/sets.rst:275
msgid "The built-in versions have more space efficient pickles."
msgstr "組み込みのものはより空間効率良く pickle 化できます。"

#: ../../library/sets.rst:277
msgid ""
"The built-in versions do not have a :meth:`union_update` method. Instead, "
"use the :meth:`update` method which is equivalent."
msgstr "組み込みのものには :meth:`union_update` メソッドがありません。代わりに同じ機能の :meth:`update` メソッドを使って下さい。"

#: ../../library/sets.rst:280
msgid ""
"The built-in versions do not have a ``_repr(sorted=True)`` method. Instead, "
"use the built-in :func:`repr` and :func:`sorted` functions: "
"``repr(sorted(s))``."
msgstr "組み込みのものには `_repr(sorted=True)` メソッドがありません。代わりに組み込み関数の :func:`repr` と :func:`sorted` を使って ``repr(sorted(s))`` として下さい。"

#: ../../library/sets.rst:284
msgid ""
"The built-in version does not have a protocol for automatic conversion to "
"immutable.  Many found this feature to be confusing and no one in the "
"community reported having found real uses for it."
msgstr "組み込みのものは変更不可能なものに自動で変換するプロトコルがありません。この機能は多くの人が困惑を覚えるわりに、コミュニティの誰からも実際的な使用例の報告がありませんでした。"
