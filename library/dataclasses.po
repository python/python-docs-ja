# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Osamu NAKAMURA, 2018
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-08-25 08:59+0900\n"
"PO-Revision-Date: 2018-06-29 21:06+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/dataclasses.rst:2
msgid ":mod:`dataclasses` --- Data Classes"
msgstr ":mod:`dataclasses` --- ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹"

#: ../../library/dataclasses.rst:10
msgid "**Source code:** :source:`Lib/dataclasses.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/dataclasses.py`"

#: ../../library/dataclasses.rst:14
msgid ""
"This module provides a decorator and functions for automatically adding "
"generated :term:`special method`\\s such as :meth:`__init__` and "
":meth:`__repr__` to user-defined classes.  It was originally described in "
":pep:`557`."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€:meth:`__init__` ã‚„ :meth:`__repr__` ã®ã‚ˆã†ãª :term:`special method` "
"ã‚’ç”Ÿæˆã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ã®ã‚¯ãƒ©ã‚¹ã«è‡ªå‹•çš„ã«è¿½åŠ ã™ã‚‹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã‚„é–¢æ•°ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :pep:`557` ã«è¨˜è¼‰ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/dataclasses.rst:19
msgid ""
"The member variables to use in these generated methods are defined using "
":pep:`526` type annotations.  For example this code::"
msgstr ""
"ã“ã‚Œã‚‰ã®ç”Ÿæˆã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã§åˆ©ç”¨ã•ã‚Œã‚‹ãƒ¡ãƒ³ãƒãƒ¼å¤‰æ•°ã¯ :pep:`526` å‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç”¨ã„ã¦å®šç¾©ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯::"

#: ../../library/dataclasses.rst:32
msgid "Will add, among other things, a :meth:`__init__` that looks like::"
msgstr "ã¨ã‚Šã‚ã‘ã€ä»¥ä¸‹ã®ã‚ˆã†ãª :meth:`__init__` ãŒè¿½åŠ ã•ã‚Œã¾ã™::"

#: ../../library/dataclasses.rst:39
msgid ""
"Note that this method is automatically added to the class: it is not "
"directly specified in the ``InventoryItem`` definition shown above."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯è‡ªå‹•çš„ã«ã‚¯ãƒ©ã‚¹ã«è¿½åŠ ã•ã‚Œã‚‹ç‚¹ã«ç•™æ„ã—ã¦ä¸‹ã•ã„ã€‚ä¸Šè¨˜ã® ``InventoryItem`` "
"ã‚¯ãƒ©ã‚¹ã®å®šç¾©ä¸­ã«ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒç›´æ¥æ˜è¨˜ã•ã‚Œã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:45
msgid "Module-level decorators, classes, and functions"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã€ã‚¯ãƒ©ã‚¹ã€é–¢æ•°"

#: ../../library/dataclasses.rst:49
msgid ""
"This function is a :term:`decorator` that is used to add generated "
":term:`special method`\\s to classes, as described below."
msgstr "ã“ã®é–¢æ•°ã¯ã€å¾Œè¿°ã™ã‚‹ :term:`special method` ã‚’ç”Ÿæˆã—ã€ã‚¯ãƒ©ã‚¹ã«è¿½åŠ ã™ã‚‹ :term:`decorator` ã§ã™ã€‚"

#: ../../library/dataclasses.rst:52
msgid ""
"The :func:`dataclass` decorator examines the class to find ``field``\\s.  A "
"``field`` is defined as class variable that has a type annotation.  With two"
" exceptions described below, nothing in :func:`dataclass` examines the type "
"specified in the variable annotation."
msgstr ""
":func:`dataclass` ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¯ã€``ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰`` ã‚’æ¢ã™ãŸã‚ã«ã‚¯ãƒ©ã‚¹ã‚’æ¤œæŸ»ã—ã¾ã™ã€‚``ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰`` "
"ã®å®šç¾©ã¯å‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æŒã¤ã‚¯ãƒ©ã‚¹å¤‰æ•°ã§ã™ã€‚å¾Œè¿°ã™ã‚‹ï¼’ã¤ã®ä¾‹å¤–ã‚’é™¤ãã€:func:`dataclass` "
"ã¯ã€å¤‰æ•°ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã§æŒ‡å®šã—ãŸå‹ã‚’æ¤œæŸ»ã—ã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:58
msgid ""
"The order of the fields in all of the generated methods is the order in "
"which they appear in the class definition."
msgstr "ç”Ÿæˆã•ã‚Œã‚‹ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸­ã§ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®é †åºã¯ã€ãã‚Œã‚‰ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚¯ãƒ©ã‚¹å®šç¾©ã«ç¾ã‚ŒãŸé †åºã§ã™ã€‚"

#: ../../library/dataclasses.rst:61
msgid ""
"The :func:`dataclass` decorator will add various \"dunder\" methods to the "
"class, described below.  If any of the added methods already exist on the "
"class, the behavior depends on the parameter, as documented below. The "
"decorator returns the same class that is called on; no new class is created."
msgstr ""
":func:`dataclass` ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¯ã€å¾Œè¿°ã™ã‚‹æ§˜ã€…ãª \"ãƒ€ãƒ³ãƒ€ãƒ¼\" ãƒ¡ã‚½ãƒƒãƒ‰ (è¨³æ³¨ï¼šdunderã¯double "
"underscoreã®ç•¥ã§ã€ãƒ¡ã‚½ãƒƒãƒ‰åã®å‰å¾Œã«ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ãŒ2ã¤ä»˜ã„ã¦ã„ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰) "
"ã‚’ã‚¯ãƒ©ã‚¹ã«è¿½åŠ ã—ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã«æ—¢ã«ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®å‹•ä½œã¯ã€å¾Œè¿°ã™ã‚‹å¼•æ•°ã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ã€‚ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¯å‘¼ã³å‡ºã—ãŸéš›ã«æŒ‡å®šã—ãŸã‚¯ãƒ©ã‚¹ã¨åŒã˜ã‚¯ãƒ©ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã¯ç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:67
msgid ""
"If :func:`dataclass` is used just as a simple decorator with no parameters, "
"it acts as if it has the default values documented in this signature.  That "
"is, these three uses of :func:`dataclass` are equivalent::"
msgstr ""
":func:`dataclass` "
"ãŒå¼•æ•°ã‚’æŒ‡å®šã—ãªã„å˜ç´”ãªãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦ä½¿ç”¨ã•ã‚ŒãŸå ´åˆã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹ã‚·ã‚°ãƒãƒãƒ£ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®ã¨ãŠã‚Šã«å‹•ä½œã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ä»¥ä¸‹ã®ï¼“ã¤ã® "
":func:`dataclass` ã®ç”¨ä¾‹ã¯åŒç­‰ã§ã™::"

#: ../../library/dataclasses.rst:84
msgid "The parameters to :func:`dataclass` are:"
msgstr ":func:`dataclass` ã®å¼•æ•°ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™::"

#: ../../library/dataclasses.rst:86
msgid ""
"``init``: If true (the default), a :meth:`__init__` method will be "
"generated."
msgstr "``init``: (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®)çœŸã®å ´åˆã€ :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/dataclasses.rst:89
msgid ""
"If the class already defines :meth:`__init__`, this parameter is ignored."
msgstr "ã‚‚ã—ã‚¯ãƒ©ã‚¹ã« :meth:`__init__` ãŒæ—¢ã«å®šç¾©ã•ã‚Œã¦ã„ãŸå ´åˆã¯ã€ã“ã®å¼•æ•°ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/dataclasses.rst:92
msgid ""
"``repr``: If true (the default), a :meth:`__repr__` method will be "
"generated.  The generated repr string will have the class name and the name "
"and repr of each field, in the order they are defined in the class.  Fields "
"that are marked as being excluded from the repr are not included.  For "
"example: ``InventoryItem(name='widget', unit_price=3.0, "
"quantity_on_hand=10)``."
msgstr ""
"``repr``: (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®)çœŸã®å ´åˆã€ :meth:`__repr__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚\n"
"ç”Ÿæˆã•ã‚ŒãŸ repr æ–‡å­—åˆ—ã«ã¯ã€ã‚¯ãƒ©ã‚¹åã€å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®åå‰ãŠã‚ˆã³ repr æ–‡å­—åˆ—ãŒã€ã‚¯ãƒ©ã‚¹ä¸Šã§ã®å®šç¾©ã•ã‚ŒãŸé †åºã§ä¸¦ã³ã¾ã™ã€‚\n"
"repr ã‹ã‚‰é™¤å¤–ã™ã‚‹ã‚ˆã†ã«å°ãŒä»˜ã‘ã‚‰ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã€ repr æ–‡å­—åˆ—ã«ã¯å«ã¾ã‚Œã¾ã›ã‚“ã€‚\n"
"ä¾‹ãˆã°ã€ã“ã®ã‚ˆã†ã«ãªã‚Šã¾ã™: ``InventoryItem(name='widget', unit_price=3.0, quantity_on_hand=10)`` ã€‚"

#: ../../library/dataclasses.rst:99
msgid ""
"If the class already defines :meth:`__repr__`, this parameter is ignored."
msgstr "ã‚‚ã—ã‚¯ãƒ©ã‚¹ã« :meth:`__repr__` ãŒæ—¢ã«å®šç¾©ã•ã‚Œã¦ã„ãŸå ´åˆã¯ã€ã“ã®å¼•æ•°ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/dataclasses.rst:102
msgid ""
"``eq``: If true (the default), an :meth:`__eq__` method will be generated.  "
"This method compares the class as if it were a tuple of its fields, in "
"order.  Both instances in the comparison must be of the identical type."
msgstr ""
"``eq``: (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®)çœŸã®å ´åˆã€ :meth:`__eq__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¯ãƒ©ã‚¹ã®æ¯”è¼ƒã‚’ã€ãã®ã‚¯ãƒ©ã‚¹ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã‚’æ¯”è¼ƒã™ã‚‹ã‚ˆã†ã«è¡Œã„ã¾ã™ã€‚æ¯”è¼ƒã™ã‚‹2ã¤ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¯ãƒ©ã‚¹ã¯åŒä¸€ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:107
msgid ""
"If the class already defines :meth:`__eq__`, this parameter is ignored."
msgstr "ã‚‚ã—ã‚¯ãƒ©ã‚¹ã« :meth:`__eq__` ãŒæ—¢ã«å®šç¾©ã•ã‚Œã¦ã„ãŸå ´åˆã¯ã€ã“ã®å¼•æ•°ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/dataclasses.rst:110
msgid ""
"``order``: If true (the default is ``False``), :meth:`__lt__`, "
":meth:`__le__`, :meth:`__gt__`, and :meth:`__ge__` methods will be "
"generated.  These compare the class as if it were a tuple of its fields, in "
"order.  Both instances in the comparison must be of the identical type.  If "
"``order`` is true and ``eq`` is false, a :exc:`ValueError` is raised."
msgstr ""
"``order``: çœŸ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ ``False``) ã®å ´åˆã€ "
":meth:`__lt__`ã€:meth:`__le__`ã€:meth:`__gt__`ã€:meth:`__ge__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®æ¯”è¼ƒã¯ã€ã‚¯ãƒ©ã‚¹ã‚’ãã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«å–ã‚Šæ‰±ã„ã¾ã™ã€‚æ¯”è¼ƒã•ã‚Œã‚‹2ã¤ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€åŒä¸€ã®å‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—"
" ``order`` ãŒ true ã§ã€ ``eq`` ã« falseã‚’æŒ‡å®šã™ã™ã‚‹ã¨ã€:exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/dataclasses.rst:117
msgid ""
"If the class already defines any of :meth:`__lt__`, :meth:`__le__`, "
":meth:`__gt__`, or :meth:`__ge__`, then :exc:`TypeError` is raised."
msgstr ""
"ã‚‚ã—ã€ã‚¯ãƒ©ã‚¹ã§æ—¢ã« :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, :meth:`__ge__` "
"ã®ã†ã¡ã„ãšã‚Œã‹ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã¨ :exc:`TypeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/dataclasses.rst:121
msgid ""
"``unsafe_hash``: If ``False`` (the default), a :meth:`__hash__` method is "
"generated according to how ``eq`` and ``frozen`` are set."
msgstr ""
"``unsafe_hash``: (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®)``False`` ã®å ´åˆã€ ``eq`` ã¨ ``frozen`` ãŒã©ã†è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ã«å¾“ã£ã¦ "
":meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/dataclasses.rst:124
msgid ""
":meth:`__hash__` is used by built-in :meth:`hash()`, and when objects are "
"added to hashed collections such as dictionaries and sets.  Having a "
":meth:`__hash__` implies that instances of the class are immutable. "
"Mutability is a complicated property that depends on the programmer's "
"intent, the existence and behavior of :meth:`__eq__`, and the values of the "
"``eq`` and ``frozen`` flags in the :func:`dataclass` decorator."
msgstr ""
":meth:`__hash__` ã¯ã€çµ„ã¿è¾¼ã¿ã® :meth:`hash()` ã‹ã‚‰ä½¿ã‚ã‚ŒãŸã‚Šã€ dict ã‚„ set ã®ã‚ˆã†ãªãƒãƒƒã‚·ãƒ¥åŒ–ã•ã‚ŒãŸã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿½åŠ ã™ã‚‹ã¨ãã«ä½¿ã‚ã‚Œã¾ã™ã€‚\n"
":meth:`__hash__` ãŒã‚ã‚‹ã¨ã„ã†ã“ã¨ã¯ãã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒä¸å¤‰ (ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«) ã§ã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚\n"
"å¯å¤‰æ€§ã¨ã„ã†ã®ã¯è¤‡é›‘ãªæ€§è³ªã§ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒã®æ„å›³ã€ :meth:`__eq__` ãŒå­˜åœ¨ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã¨ãã®æŒ¯ã‚‹èˆã„ã€ :func:`dataclass` ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã® ``eq`` ãƒ•ãƒ©ã‚°ã¨ ``frozen`` ãƒ•ãƒ©ã‚°ã®å€¤ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/dataclasses.rst:131
msgid ""
"By default, :func:`dataclass` will not implicitly add a :meth:`__hash__` "
"method unless it is safe to do so.  Neither will it add or change an "
"existing explicitly defined :meth:`__hash__` method.  Setting the class "
"attribute ``__hash__ = None`` has a specific meaning to Python, as described"
" in the :meth:`__hash__` documentation."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ :func:`dataclass` ã¯è¿½åŠ ã—ã¦ã‚‚å®‰å…¨ã§ãªã„é™ã‚Š :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æš—é»™çš„ã«ã¯è¿½åŠ ã—ã¾ã›ã‚“ã€‚\n"
"ã¾ãŸã€æ˜ç¤ºçš„ã«å®šç¾©ã•ã‚Œå­˜åœ¨ã—ã¦ã„ã‚‹ :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã«è¿½åŠ ã—ãŸã‚Šå¤‰æ›´ã—ãŸã‚Šã¯ã—ã¾ã›ã‚“ã€‚\n"
"ã‚¯ãƒ©ã‚¹ã®å±æ€§ã® ``__hash__ = None`` ã¨ã„ã†è¨­å®šã¯ã€ Python ã«ã¨ã£ã¦ :meth:`__hash__` ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚ã‚‹ã‚ˆã†ãªç‰¹åˆ¥ãªæ„å‘³ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/dataclasses.rst:137
msgid ""
"If :meth:`__hash__` is not explicit defined, or if it is set to ``None``, "
"then :func:`dataclass` *may* add an implicit :meth:`__hash__` method. "
"Although not recommended, you can force :func:`dataclass` to create a "
":meth:`__hash__` method with ``unsafe_hash=True``. This might be the case if"
" your class is logically immutable but can nonetheless be mutated. This is a"
" specialized use case and should be considered carefully."
msgstr ""
":meth:`__hash__` ãŒæ˜ç¤ºçš„ã«å®šç¾©ã•ã‚Œã¦ã„ãªã‹ã£ãŸã‚Šã€ ``None`` ã«è¨­å®šã•ã‚Œã¦ã„ãŸå ´åˆã¯ã€ :func:`dataclass` ã¯æš—é»™çš„ã« :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã™ã‚‹ *ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“* ã€‚\n"
"æ¨å¥¨ã¯ã§ãã¾ã›ã‚“ãŒã€ ``unsafe_hash=True`` ã¨ã™ã‚‹ã“ã¨ã§ :func:`dataclass` ã« :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½œæˆã•ã›ã‚‰ã‚Œã¾ã™ã€‚\n"
"ã“ã†ã—ã¦ã—ã¾ã†ã¨ã€ã‚¯ãƒ©ã‚¹ãŒè«–ç†çš„ã«ã¯ä¸å¤‰ã ãŒãã‚Œã«ã‚‚ã‹ã‹ã‚ã‚‰ãšå¤‰æ›´ã§ãã¦ã—ã¾ã†å ´åˆã€å•é¡Œã«ãªã‚Šå¾—ã¾ã™ã€‚\n"
"ã“ã†ã™ã‚‹ã®ã¯ç‰¹åˆ¥ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã§ã€æ…é‡ã«æ¤œè¨ã™ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/dataclasses.rst:144
msgid ""
"Here are the rules governing implicit creation of a :meth:`__hash__` method."
"  Note that you cannot both have an explicit :meth:`__hash__` method in your"
" dataclass and set ``unsafe_hash=True``; this will result in a "
":exc:`TypeError`."
msgstr ""
":meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒæš—é»™çš„ã«ä½œã‚‰ã‚Œã‚‹ã‹ã©ã†ã‹ã‚’æ±ºå®šã™ã‚‹è¦å‰‡ã¯æ¬¡ã®é€šã‚Šã§ã™ã€‚\n"
"ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã«æ˜ç¤ºçš„ãª :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒãŸã›ãŸä¸Šã§ã€ ``unsafe_hash=True`` ã¨è¨­å®šã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“; ã“ã†ã™ã‚‹ã¨ :exc:`TypeError` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/dataclasses.rst:149
msgid ""
"If ``eq`` and ``frozen`` are both true, by default :func:`dataclass` will "
"generate a :meth:`__hash__` method for you.  If ``eq`` is true and "
"``frozen`` is false, :meth:`__hash__` will be set to ``None``, marking it "
"unhashable (which it is, since it is mutable).  If ``eq`` is false, "
":meth:`__hash__` will be left untouched meaning the :meth:`__hash__` method "
"of the superclass will be used (if the superclass is :class:`object`, this "
"means it will fall back to id-based hashing)."
msgstr ""
"``eq`` ã¨ ``frozen`` ãŒä¸¡æ–¹ã¨ã‚‚çœŸã ã£ãŸå ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ :func:`dataclass` ã¯ :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç”Ÿæˆã—ã¾ã™ã€‚\n"
"``eq`` ãŒçœŸã§ ``frozen`` ãŒå½ã®å ´åˆã€:meth:`__hash__` ã¯ ``None`` ã«è¨­å®šã•ã‚Œã€(å¯å¤‰ãªã®ã§) ãƒãƒƒã‚·ãƒ¥åŒ–ä¸å¯èƒ½ã¨ã•ã‚Œã¾ã™ã€‚\n"
"``eq`` ãŒå½ã®å ´åˆã¯ã€ :meth:`__hash__` ã¯æ‰‹ã‚’ä»˜ã‘ãªã„ã¾ã¾ã€ã¤ã¾ã‚Šã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹ã® :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒä½¿ã‚ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ (ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹ãŒ :class:`object` ã ã£ãŸå ´åˆã¯ã€ id ã«åŸºã¥ã„ãŸãƒãƒƒã‚·ãƒ¥åŒ–ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã™ã‚‹ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™)ã€‚"

#: ../../library/dataclasses.rst:157
msgid ""
"``frozen``: If true (the default is False), assigning to fields will "
"generate an exception.  This emulates read-only frozen instances.  If "
":meth:`__setattr__` or :meth:`__delattr__` is defined in the class, then "
":exc:`TypeError` is raised.  See the discussion below."
msgstr ""
"``frozen``: çœŸ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯å½) ã®å ´åˆã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¸ã®ä»£å…¥ã¯ä¾‹å¤–ã‚’ç”Ÿæˆã—ã¾ã™ã€‚\n"
"ã“ã‚Œã«ã‚ˆã‚Šèª­ã¿å‡ºã—å°‚ç”¨ã®å‡çµã•ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ¨¡å€£ã—ã¾ã™ã€‚\n"
":meth:`__setattr__` ã‚ã‚‹ã„ã¯ :meth:`__delattr__` ãŒã‚¯ãƒ©ã‚¹ã«å®šç¾©ã•ã‚Œã¦ã„ãŸå ´åˆã¯ã€ :exc:`TypeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚\n"
"å¾Œã«ã‚ã‚‹è­°è«–ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/dataclasses.rst:162
msgid ""
"``field``\\s may optionally specify a default value, using normal Python "
"syntax::"
msgstr "``ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰`` ã«ã¯ã€é€šå¸¸ã® Python ã®æ–‡æ³•ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒ‡å®šã§ãã¾ã™ã€‚"

#: ../../library/dataclasses.rst:170
msgid ""
"In this example, both ``a`` and ``b`` will be included in the added "
":meth:`__init__` method, which will be defined as::"
msgstr ""
"ã“ã®ä¾‹ã§ã¯ã€ç”Ÿæˆã•ã‚ŒãŸ :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯ ``a`` ã¨ ``b`` ã®ä¸¡æ–¹ãŒå«ã¾ã‚Œã€ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¾ã™::"

#: ../../library/dataclasses.rst:175
msgid ""
":exc:`TypeError` will be raised if a field without a default value follows a"
" field with a default value.  This is true either when this occurs in a "
"single class, or as a result of class inheritance."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒ‡å®šã—ãªã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒ‡å®šã—ãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å¾Œã‚ã«å®šç¾©ã™ã‚‹ã¨ã€ :exc:`TypeError` "
"ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€å˜ä¸€ã®ã‚¯ãƒ©ã‚¹ã§ã‚ã£ã¦ã‚‚ã€ã‚¯ãƒ©ã‚¹ç¶™æ‰¿ã®çµæœã§ã‚‚èµ·ããˆã¾ã™ã€‚"

#: ../../library/dataclasses.rst:181
msgid ""
"For common and simple use cases, no other functionality is required.  There "
"are, however, some dataclass features that require additional per-field "
"information.  To satisfy this need for additional information, you can "
"replace the default field value with a call to the provided :func:`field` "
"function.  For example::"
msgstr ""
"é€šå¸¸ã®å˜ç´”ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã§ã¯ã€ã“ã®ä»–ã®æ©Ÿèƒ½ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚\n"
"ã—ã‹ã—ã€ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã«ã¯ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã”ã¨ã®æƒ…å ±ã‚’å¿…è¦ã¨ã™ã‚‹æ©Ÿèƒ½ã‚‚ã‚ã‚Šã¾ã™ã€‚\n"
"è¿½åŠ ã®æƒ…å ±ã®å¿…è¦æ€§ã«å¿œãˆã‚‹ãŸã‚ã«ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰æä¾›ã•ã‚Œã¦ã„ã‚‹ :func:`field` é–¢æ•°ã®å‘¼ã³å‡ºã—ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚\n"
"ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/dataclasses.rst:194
msgid ""
"As shown above, the ``MISSING`` value is a sentinel object used to detect if"
" the ``default`` and ``default_factory`` parameters are provided.  This "
"sentinel is used because ``None`` is a valid value for ``default``.  No code"
" should directly use the ``MISSING`` value."
msgstr ""
"ä¸Šã«ã‚ã‚‹ã‚ˆã†ã«ã€ ``MISSING`` å€¤ã¯ ``default`` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ ``default_factory`` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒæä¾›ã•ã‚ŒãŸã‹ã©ã†ã‹ã‚’æ¤œå‡ºã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹ç•ªå…µã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚\n"
"ã“ã®ç•ªå…µãŒä½¿ã‚ã‚Œã‚‹ã®ã¯ã€ ``None`` ãŒ ``default`` ã®æœ‰åŠ¹ãªå€¤ã ã‹ã‚‰ã§ã™ã€‚\n"
"ã©ã‚“ãªã‚³ãƒ¼ãƒ‰ã§ã‚‚ ``MISSING`` å€¤ã‚’ç›´æ¥ä½¿ã†ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:200
msgid "The parameters to :func:`field` are:"
msgstr ":func:`field` ã®å¼•æ•°ã¯æ¬¡ã®é€šã‚Šã§ã™:"

#: ../../library/dataclasses.rst:202
msgid ""
"``default``: If provided, this will be the default value for this field.  "
"This is needed because the :meth:`field` call itself replaces the normal "
"position of the default value."
msgstr ""
"``default``: ä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã«ãªã‚Šã¾ã™ã€‚\n"
"ã“ã‚ŒãŒå¿…è¦ãªã®ã¯ã€ :meth:`field` ã®å‘¼ã³å‡ºã—ãã®ã‚‚ã®ãŒé€šå¸¸ã§ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒã„ã‚‹ä½ç½®ã‚’æ¨ªå–ã‚Šã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/dataclasses.rst:206
msgid ""
"``default_factory``: If provided, it must be a zero-argument callable that "
"will be called when a default value is needed for this field.  Among other "
"purposes, this can be used to specify fields with mutable default values, as"
" discussed below.  It is an error to specify both ``default`` and "
"``default_factory``."
msgstr ""
"``default_factory``: æä¾›ã•ã‚Œã¦ã„ãŸå ´åˆã€0 å¼•æ•°ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®åˆæœŸå€¤ãŒå¿…è¦ã«ãªã£ãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
"ä»–ã®ç›®çš„ã‚‚å«ã‚ã¦ã€ä¸‹ã§è­°è«–ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å¯å¤‰ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒ‡å®šã™ã‚‹ã®ã«ä½¿ãˆã¾ã™ã€‚\n"
"``default`` ã¨ ``default_factory`` ã®ä¸¡æ–¹ã‚’æŒ‡å®šã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/dataclasses.rst:212
msgid ""
"``init``: If true (the default), this field is included as a parameter to "
"the generated :meth:`__init__` method."
msgstr "``init``: (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®)çœŸã®å ´åˆã€ ç”Ÿæˆã•ã‚Œã‚‹ :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã®å¼•æ•°ã«ã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å«ã‚ã¾ã™ã€‚"

#: ../../library/dataclasses.rst:215
msgid ""
"``repr``: If true (the default), this field is included in the string "
"returned by the generated :meth:`__repr__` method."
msgstr ""
"``repr``: (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®)çœŸã®å ´åˆã€ç”Ÿæˆã•ã‚Œã‚‹ :meth:`__repr__` ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹æ–‡å­—åˆ—ã«ã€ã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å«ã‚ã¾ã™ã€‚"

#: ../../library/dataclasses.rst:218
msgid ""
"``compare``: If true (the default), this field is included in the generated "
"equality and comparison methods (:meth:`__eq__`, :meth:`__gt__`, et al.)."
msgstr ""
"``compare``: (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®) çœŸã®å ´åˆã€ç”Ÿæˆã•ã‚Œã‚‹ç­‰ä¾¡é–¢æ•°ã¨æ¯”è¼ƒé–¢æ•°( :meth:`__eq__` ã€:meth:`__gt__` "
"ãªã©)ã«ã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å«ã‚ã¾ã™ã€‚"

#: ../../library/dataclasses.rst:222
msgid ""
"``hash``: This can be a bool or ``None``.  If true, this field is included "
"in the generated :meth:`__hash__` method.  If ``None`` (the default), use "
"the value of ``compare``: this would normally be the expected behavior.  A "
"field should be considered in the hash if it's used for comparisons.  "
"Setting this value to anything other than ``None`` is discouraged."
msgstr ""
"``hash``: ã“ã‚Œã¯çœŸå½å€¤ã‚ã‚‹ã„ã¯ ``None`` ã«è¨­å®šã§ãã¾ã™ã€‚\n"
"çœŸã®å ´åˆã€ã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã€ç”Ÿæˆã•ã‚ŒãŸ :meth:`__hash__` ãƒ¡ã‚½ãƒƒãƒ‰ã«å«ã¾ã‚Œã¾ã™ã€‚\n"
"(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®) ``None`` ã®å ´åˆã€ ``compare`` ã®å€¤ã‚’ä½¿ã„ã¾ã™: ã“ã†ã™ã‚‹ã“ã¨ã¯æ™®é€šã¯æœŸå¾…é€šã‚Šã®æŒ¯ã‚‹èˆã„ã«ãªã‚Šã¾ã™ã€‚\n"
"æ¯”è¼ƒã§ä½¿ã‚ã‚Œã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ãƒãƒƒã‚·ãƒ¥ã«å«ã¾ã‚Œã‚‹ã‚‚ã®ã¨è€ƒãˆã‚‹ã¹ãã§ã™ã€‚\n"
"ã“ã®å€¤ã‚’ ``None`` ä»¥å¤–ã«è¨­å®šã™ã‚‹ã“ã¨ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:229
msgid ""
"One possible reason to set ``hash=False`` but ``compare=True`` would be if a"
" field is expensive to compute a hash value for, that field is needed for "
"equality testing, and there are other fields that contribute to the type's "
"hash value.  Even if a field is excluded from the hash, it will still be "
"used for comparisons."
msgstr ""
"ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¨ˆç®—ã™ã‚‹ã‚³ã‚¹ãƒˆãŒé«˜ã„å ´åˆã«ã€ ``hash=False`` ã ãŒ ``compare=True`` ã¨è¨­å®šã™ã‚‹ç†ç”±ãŒ 1 ã¤ã‚ã‚‹ã¨ã™ã‚Œã°ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒç­‰ä¾¡æ¤œæŸ»ã«å¿…è¦ã‹ã¤ã€ãã®å‹ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¨ˆç®—ã™ã‚‹ã®ã«ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚‚ä½¿ã‚ã‚Œã‚‹ã“ã¨ã§ã™ã€‚\n"
"ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒãƒãƒƒã‚·ãƒ¥ã‹ã‚‰é™¤å¤–ã•ã‚Œã¦ã„ãŸã¨ã—ã¦ã‚‚ã€æ¯”è¼ƒã«ã¯ä½¿ãˆã¾ã™ã€‚"

#: ../../library/dataclasses.rst:235
msgid ""
"``metadata``: This can be a mapping or None. None is treated as an empty "
"dict.  This value is wrapped in :func:`~types.MappingProxyType` to make it "
"read-only, and exposed on the :class:`Field` object. It is not used at all "
"by Data Classes, and is provided as a third-party extension mechanism. "
"Multiple third-parties can each have their own key, to use as a namespace in"
" the metadata."
msgstr ""
"``metadata``: ã“ã‚Œã¯ãƒãƒƒãƒ”ãƒ³ã‚°ã‚ã‚‹ã„ã¯ ``None`` ã«è¨­å®šã§ãã¾ã™ã€‚\n"
"``None`` ã¯ç©ºã®è¾æ›¸ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚\n"
"ã“ã®å€¤ã¯ :func:`~types.MappingProxyType` ã§ãƒ©ãƒƒãƒ—ã•ã‚Œã€èª­ã¿å‡ºã—å°‚ç”¨ã«ãªã‚Šã€ :class:`Field` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å…¬é–‹ã•ã‚Œã¾ã™ã€‚\n"
"ã“ã‚Œã¯ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã‹ã‚‰ä½¿ã‚ã‚Œã‚‹ã“ã¨ã¯ãªãã€ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¼ã®æ‹¡å¼µæ©Ÿæ§‹ã¨ã—ã¦æä¾›ã•ã‚Œã¾ã™ã€‚\n"
"è¤‡æ•°ã®ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¼ãŒå„ã€…ã®ã‚­ãƒ¼ã‚’æŒã¦ã€ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®åå‰ç©ºé–“ã¨ã—ã¦ä½¿ãˆã¾ã™ã€‚"

#: ../../library/dataclasses.rst:243
msgid ""
"If the default value of a field is specified by a call to :func:`field()`, "
"then the class attribute for this field will be replaced by the specified "
"``default`` value.  If no ``default`` is provided, then the class attribute "
"will be deleted.  The intent is that after the :func:`dataclass` decorator "
"runs, the class attributes will all contain the default values for the "
"fields, just as if the default value itself were specified.  For example, "
"after::"
msgstr ""
":func:`field()` ã®å‘¼ã³å‡ºã—ã§ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚¯ãƒ©ã‚¹å±æ€§ã¯ã€ãã®æŒ‡å®šã•ã‚ŒãŸ ``default`` å€¤ã§ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚\n"
"``default`` ãŒæä¾›ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ãã®ã‚¯ãƒ©ã‚¹å±æ€§ã¯å‰Šé™¤ã•ã‚Œã¾ã™ã€‚\n"
"ã“ã†ã™ã‚‹æ„å›³ã¯ã€ :func:`dataclass` ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãŒå®Ÿè¡Œã•ã‚ŒãŸå¾Œã«ã¯ã€ã¡ã‚‡ã†ã©ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãã®ã‚‚ã®ãŒæŒ‡å®šã•ã‚ŒãŸã‹ã®ã‚ˆã†ã«ã€ã‚¯ãƒ©ã‚¹å±æ€§ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’å…¨ã¦æŒã£ã¦ã„ã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚\n"
"ä¾‹ãˆã°ã€æ¬¡ã®ã‚ˆã†ãªå ´åˆ::"

#: ../../library/dataclasses.rst:259
msgid ""
"The class attribute ``C.z`` will be ``10``, the class attribute ``C.t`` will"
" be ``20``, and the class attributes ``C.x`` and ``C.y`` will not be set."
msgstr ""
"ã‚¯ãƒ©ã‚¹å±æ€§ ``C.z`` ã¯ ``10`` ã€ã‚¯ãƒ©ã‚¹å±æ€§ ``C.t`` ã¯ ``20`` ã«ãªã‚Šã€ã‚¯ãƒ©ã‚¹å±æ€§ ``C.x`` ã¨ ``C.y`` "
"ã«ã¯å€¤ãŒè¨­å®šã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:265
msgid ""
":class:`Field` objects describe each defined field. These objects are "
"created internally, and are returned by the :func:`fields` module-level "
"method (see below).  Users should never instantiate a :class:`Field` object "
"directly.  Its documented attributes are:"
msgstr ""
":class:`Field` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã‚Œãã‚Œã®å®šç¾©ã•ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¨˜è¿°ã—ã¾ã™ã€‚\n"
"ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å†…éƒ¨ã§ä½œã‚‰ã‚Œã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«é–¢æ•°ã® :func:`fields` ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã¾ã™ (ä¸‹ã®è§£èª¬ã‚’è¦‹ã¦ãã ã•ã„)ã€‚\n"
"ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯çµ¶å¯¾ã« :class:`Field` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç›´æ¥ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚\n"
"ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŒ–ã•ã‚Œã¦ã„ã‚‹å±æ€§ã¯æ¬¡ã®é€šã‚Šã§ã™:"

#: ../../library/dataclasses.rst:270
msgid "``name``: The name of the field."
msgstr "``name``: ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å"

#: ../../library/dataclasses.rst:272
msgid "``type``: The type of the field."
msgstr "``type``: ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‹"

#: ../../library/dataclasses.rst:274
msgid ""
"``default``, ``default_factory``, ``init``, ``repr``, ``hash``, ``compare``,"
" and ``metadata`` have the identical meaning and values as they do in the "
":func:`field` declaration."
msgstr ""
"``default``, ``default_factory``, ``init``, ``repr``, ``hash``, ``compare``,"
" ``metadata`` ã¯ :func:`field` ã®å®£è¨€ã¨åŒã˜æ„å‘³ã¨å€¤ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/dataclasses.rst:278
msgid ""
"Other attributes may exist, but they are private and must not be inspected "
"or relied on."
msgstr "ä»–ã®å±æ€§ãŒã‚ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ãŒã€ãã‚Œã‚‰ã¯ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã§ã‚ã‚Šã€èª¿ã¹ãŸã‚Šã€ä¾å­˜ã—ãŸã‚Šã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:283
msgid ""
"Returns a tuple of :class:`Field` objects that define the fields for this "
"dataclass.  Accepts either a dataclass, or an instance of a dataclass. "
"Raises :exc:`TypeError` if not passed a dataclass or instance of one. Does "
"not return pseudo-fields which are ``ClassVar`` or ``InitVar``."
msgstr ""
"ã“ã®ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å®šç¾©ã™ã‚‹ :class:`Field` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¿ãƒ—ãƒ«ã§è¿”ã—ã¾ã™ã€‚\n"
"ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã‚ã‚‹ã„ã¯ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚\n"
"ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã‚„ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒæ¸¡ã•ã‚Œãªã‹ã£ãŸå ´åˆã¯ã€ :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚\n"
"``ClassVar`` ã‚„ ``InitVar`` ã¨ã„ã£ãŸç–‘ä¼¼ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯è¿”ã—ã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:290
msgid ""
"Converts the dataclass ``instance`` to a dict (by using the factory function"
" ``dict_factory``).  Each dataclass is converted to a dict of its fields, as"
" ``name: value`` pairs.  dataclasses, dicts, lists, and tuples are recursed "
"into.  For example::"
msgstr ""
"ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã® ``instance`` ã‚’ (ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•° ``dict_factory`` ã‚’ä½¿ã„) è¾æ›¸ã«å¤‰æ›ã—ã¾ã™ã€‚\n"
"ãã‚Œãã‚Œã®ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã¯ã€ ``name: value`` ã¨ã„ã†çµ„ã«ãªã£ã¦ã„ã‚‹ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®è¾æ›¸ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚\n"
"ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã€è¾æ›¸ã€ãƒªã‚¹ãƒˆã€ã‚¿ãƒ—ãƒ«ã¯å†å¸°çš„ã«å‡¦ç†ã•ã‚Œã¾ã™ã€‚\n"
"ä¾‹ãˆã°ã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/dataclasses.rst:310 ../../library/dataclasses.rst:324
msgid "Raises :exc:`TypeError` if ``instance`` is not a dataclass instance."
msgstr "``instance`` ãŒãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãªã‹ã£ãŸå ´åˆã€ :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/dataclasses.rst:314
msgid ""
"Converts the dataclass ``instance`` to a tuple (by using the factory "
"function ``tuple_factory``).  Each dataclass is converted to a tuple of its "
"field values.  dataclasses, dicts, lists, and tuples are recursed into."
msgstr ""
"ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã® ``instance`` ã‚’ (ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•° ``tuple_factory`` ã‚’ä½¿ã„) ã‚¿ãƒ—ãƒ«ã«å¤‰æ›ã—ã¾ã™ã€‚\n"
"ãã‚Œãã‚Œã®ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã¯ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤ã®ã‚¿ãƒ—ãƒ«ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚\n"
"ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã€è¾æ›¸ã€ãƒªã‚¹ãƒˆã€ã‚¿ãƒ—ãƒ«ã¯å†å¸°çš„ã«å‡¦ç†ã•ã‚Œã¾ã™ã€‚"

#: ../../library/dataclasses.rst:319
msgid "Continuing from the previous example::"
msgstr "1ã¤å‰ã®ä¾‹ã®ç¶šãã§ã™::"

#: ../../library/dataclasses.rst:328
msgid ""
"Creates a new dataclass with name ``cls_name``, fields as defined in "
"``fields``, base classes as given in ``bases``, and initialized with a "
"namespace as given in ``namespace``.  ``fields`` is an iterable whose "
"elements are each either ``name``, ``(name, type)``, or ``(name, type, "
"Field)``.  If just ``name`` is supplied, ``typing.Any`` is used for "
"``type``.  The values of ``init``, ``repr``, ``eq``, ``order``, "
"``unsafe_hash``, and ``frozen`` have the same meaning as they do in "
":func:`dataclass`."
msgstr ""
"``cls_name`` ã¨ã„ã†åå‰ã€ ``fields`` ã§å®šç¾©ã•ã‚Œã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã€ ``bases`` ã§ä¸ãˆã‚‰ã‚ŒãŸåŸºåº•ã‚¯ãƒ©ã‚¹ã€ ``namespace`` ã§ä¸ãˆã‚‰ã‚ŒãŸåå‰ç©ºé–“ä»˜ãã§åˆæœŸåŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚\n"
"``fields`` ã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã§ã€è¦ç´ ãŒ ``name``, ``(name, type)``, ``(name, type, Field)`` ã®ã†ã¡ã®ã©ã‚Œã‹ã§ã™ã€‚\n"
"å˜ã« ``name`` ã ã‘ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã¯ã€ ``typing.Any`` ãŒ ``type`` ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚\n"
"``init``, ``repr``, ``eq``, ``order``, ``unsafe_hash``, ``frozen`` ã®å€¤ã¯ã€ :func:`dataclass` ã®ã¨ãã¨åŒã˜æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/dataclasses.rst:337
msgid ""
"This function is not strictly required, because any Python mechanism for "
"creating a new class with ``__annotations__`` can then apply the "
":func:`dataclass` function to convert that class to a dataclass.  This "
"function is provided as a convenience.  For example::"
msgstr ""
"å³å¯†ã«ã¯ã“ã®é–¢æ•°ã¯å¿…é ˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¨ã„ã†ã®ã¯ã€ ``__annotations__`` ä»˜ãã®ã‚¯ãƒ©ã‚¹ã‚’æ–°ã—ãä½œæˆã™ã‚‹ã©ã® Python ã®æ©Ÿæ§‹ã§ã‚‚ã€ :func:`dataclass` é–¢æ•°ã‚’é©ç”¨ã—ã¦ãã®ã‚¯ãƒ©ã‚¹ã‚’ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã«å¤‰æ›ã§ãã‚‹ã‹ã‚‰ã§ã™ã€‚\n"
"ã“ã®é–¢æ•°ã¯ä¾¿åˆ©ã•ã®ãŸã‚ã«æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚\n"
"ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ä½¿ã„ã¾ã™::"

#: ../../library/dataclasses.rst:349
msgid "Is equivalent to::"
msgstr "ã¯ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¨ç­‰ã—ã„ã§ã™::"

#: ../../library/dataclasses.rst:362
msgid ""
"Creates a new object of the same type of ``instance``, replacing fields with"
" values from ``changes``.  If ``instance`` is not a Data Class, raises "
":exc:`TypeError`.  If values in ``changes`` do not specify fields, raises "
":exc:`TypeError`."
msgstr ""
"``instance`` ã¨åŒã˜å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ–°ã—ãä½œæˆã—ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ ``changes`` ã«ã‚ã‚‹å€¤ã§ç½®ãæ›ãˆã¾ã™ã€‚\n"
"``instance`` ãŒãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã§ã¯ãªã‹ã£ãŸå ´åˆã€ :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚\n"
"``changes`` ã«ã‚ã‚‹å€¤ãŒãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒ‡å®šã—ã¦ã„ãªã‹ã£ãŸå ´åˆã‚‚ã€ :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/dataclasses.rst:367
msgid ""
"The newly returned object is created by calling the :meth:`__init__` method "
"of the dataclass.  This ensures that :meth:`__post_init__`, if present, is "
"also called."
msgstr ""
"æ–°ã—ãè¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã® :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ä½œæˆã•ã‚Œã¾ã™ã€‚\n"
"ã“ã‚Œã«ã‚ˆã‚Šã€ã‚‚ã—ã‚ã‚Œã° :meth:`__post_init__` ã‚‚å‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚"

#: ../../library/dataclasses.rst:371
msgid ""
"Init-only variables without default values, if any exist, must be specified "
"on the call to :func:`replace` so that they can be passed to "
":meth:`__init__` and :meth:`__post_init__`."
msgstr ""
"åˆæœŸåŒ–é™å®šå¤‰æ•°ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒãŸãªã„ã‚‚ã®ãŒã‚‚ã—ã‚ã‚Œã°ã€ :func:`replace` ã®å‘¼ã³å‡ºã—æ™‚ã«åˆæœŸå€¤ãŒæŒ‡å®šã•ã‚Œã€ "
":meth:`__init__` ã¨ :meth:`__post_init__` ã«æ¸¡ã›ã‚‹ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:375
msgid ""
"It is an error for ``changes`` to contain any fields that are defined as "
"having ``init=False``.  A :exc:`ValueError` will be raised in this case."
msgstr ""
"``changes`` ã«ã€ ``init=False`` ã¨å®šç¾©ã•ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã¨ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚\n"
"ã“ã®å ´åˆ :exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/dataclasses.rst:379
msgid ""
"Be forewarned about how ``init=False`` fields work during a call to "
":func:`replace`.  They are not copied from the source object, but rather are"
" initialized in :meth:`__post_init__`, if they're initialized at all.  It is"
" expected that ``init=False`` fields will be rarely and judiciously used.  "
"If they are used, it might be wise to have alternate class constructors, or "
"perhaps a custom ``replace()`` (or similarly named) method which handles "
"instance copying."
msgstr ""
":func:`replace` ã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã¨ãã« ``init=False`` ã§ã‚ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã©ã®ã‚ˆã†ã«åƒãã‹ã«æ°—ã‚’ä»˜ã‘ã¦ãã ã•ã„ã€‚\n"
"ãã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã‚³ãƒ”ãƒ¼ã•ã‚Œã‚‹ã®ã§ã¯ãªãã€ä»®ã«åˆæœŸåŒ–ã•ã‚ŒãŸã¨ã—ã¦ã‚‚çµå±€ã¯ :meth:`__post_init__` ã§åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚\n"
"``init=False`` ã§ã‚ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯æ»…å¤šã«ä½¿ã„ã¾ã›ã‚“ã—ã€ä½¿ã†ã¨ã—ãŸã‚‰æ³¨æ„æ·±ãä½¿ç”¨ã—ã¾ã™ã€‚\n"
"ãã®ã‚ˆã†ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ä»£ã‚ã‚Šã®ã‚¯ãƒ©ã‚¹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ã‚ã‚‹ã„ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚³ãƒ”ãƒ¼å‡¦ç†ã‚’ã™ã‚‹ç‹¬è‡ªå®Ÿè£…ã® ``replace()`` (ã‚‚ã—ãã¯ä¼¼ãŸåå‰ã®) ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒãŸã›ã‚‹ã®ãŒè³¢æ˜ã§ã—ã‚‡ã†ã€‚"

#: ../../library/dataclasses.rst:390
msgid ""
"Returns True if its parameter is a dataclass or an instance of one, "
"otherwise returns False."
msgstr "å¼•æ•°ãŒãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã‹ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã ã£ãŸå ´åˆã« True ã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ False ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/dataclasses.rst:393
msgid ""
"If you need to know if a class is an instance of a dataclass (and not a "
"dataclass itself), then add a further check for ``not isinstance(obj, "
"type)``::"
msgstr ""
"å¼•æ•°ãŒãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹ (ãã—ã¦ã€ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ãã®ã‚‚ã®ã§ã¯ãªã„) ã‹ã©ã†ã‹ã‚’çŸ¥ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã¯ã€ ``not "
"isinstance(obj, type)`` ã§è¿½åŠ ã®ãƒã‚§ãƒƒã‚¯ã‚’ã—ã¦ãã ã•ã„::"

#: ../../library/dataclasses.rst:401
msgid "Post-init processing"
msgstr "åˆæœŸåŒ–å¾Œã®å‡¦ç†"

#: ../../library/dataclasses.rst:403
msgid ""
"The generated :meth:`__init__` code will call a method named "
":meth:`__post_init__`, if :meth:`__post_init__` is defined on the class.  It"
" will normally be called as ``self.__post_init__()``. However, if any "
"``InitVar`` fields are defined, they will also be passed to "
":meth:`__post_init__` in the order they were defined in the class.  If no "
":meth:`__init__` method is generated, then :meth:`__post_init__` will not "
"automatically be called."
msgstr ""
"ç”Ÿæˆã•ã‚ŒãŸ :meth:`__init__` ã®ã‚³ãƒ¼ãƒ‰ã¯ã€ :meth:`__post_init__` ã¨ã„ã†åå‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚¯ãƒ©ã‚¹ã«å®šç¾©ã•ã‚Œã¦ã„ãŸã‚‰ã€ãã‚Œã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚\n"
"é€šå¸¸ã¯ ``self.__post_init__()`` ã®ã‚ˆã†ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
"ã—ã‹ã— ``InitVar`` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãŸå ´åˆã€ãã‚Œã‚‰ã‚‚ã‚¯ãƒ©ã‚¹ã«å®šç¾©ã•ã‚ŒãŸé †åºã§ :meth:`__post_init__` ã«æ¸¡ã•ã‚Œã¾ã™ã€‚\n"
":meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒç”Ÿæˆã•ã‚Œãªã‹ã£ãŸå ´åˆã¯ã€ :meth:`__post_init__` ã¯è‡ªå‹•çš„ã«ã¯å‘¼ã³å‡ºã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:411
msgid ""
"Among other uses, this allows for initializing field values that depend on "
"one or more other fields.  For example::"
msgstr ""
"ä»–ã®æ©Ÿèƒ½ã¨çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ä»–ã® 1 ã¤ä»¥ä¸Šã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ä¾å­˜ã—ã¦ã„ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒåˆæœŸåŒ–ã§ãã¾ã™ã€‚\n"
"ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ã§ãã¾ã™::"

#: ../../library/dataclasses.rst:423
msgid ""
"See the section below on init-only variables for ways to pass parameters to "
":meth:`__post_init__`.  Also see the warning about how :func:`replace` "
"handles ``init=False`` fields."
msgstr ""
"ä¸‹ã«ã‚ã‚‹åˆæœŸåŒ–é™å®šå¤‰æ•°ã«ã¤ã„ã¦ã®ç¯€ã§ã€ :meth:`__post_init__` ã«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ¸¡ã™æ–¹æ³•ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚\n"
":func:`replace` ãŒ ``init=False`` ã§ã‚ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã©ã†å–ã‚Šæ‰±ã†ã‹ã«ã¤ã„ã¦ã®è­¦å‘Šã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/dataclasses.rst:428
msgid "Class variables"
msgstr "ã‚¯ãƒ©ã‚¹å¤‰æ•°"

#: ../../library/dataclasses.rst:430
msgid ""
"One of two places where :func:`dataclass` actually inspects the type of a "
"field is to determine if a field is a class variable as defined in "
":pep:`526`.  It does this by checking if the type of the field is "
"``typing.ClassVar``.  If a field is a ``ClassVar``, it is excluded from "
"consideration as a field and is ignored by the dataclass mechanisms.  Such "
"``ClassVar`` pseudo-fields are not returned by the module-level "
":func:`fields` function."
msgstr ""
":func:`dataclass` ãŒå®Ÿéš›ã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‹ã®æ¤œæŸ»ã‚’è¡Œã† 2 ç®‡æ‰€ã®ã†ã¡ 1 ã¤ã¯ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ :pep:`526` ã§å®šç¾©ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹å¤‰æ•°ã‹ã©ã†ã‹ã®åˆ¤å®šã§ã™ã€‚\n"
"ãã®åˆ¤å®šã¯ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‹ãŒ ``typing.ClassVar`` ã‹ã©ã†ã‹ã§è¡Œã„ã¾ã™ã€‚\n"
"ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ ``ClassVar`` ã®å ´åˆã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨ã¯è¦‹ãªã•ã‚Œãªããªã‚Šã€ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã®æ©Ÿæ§‹ã‹ã‚‰ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚\n"
"ãã®ã‚ˆã†ãª ``ClassVar`` ç–‘ä¼¼ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«é–¢æ•° :func:`fields` ã®è¿”ã‚Šå€¤ã«ã¯å«ã¾ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:439
msgid "Init-only variables"
msgstr "åˆæœŸåŒ–é™å®šå¤‰æ•°"

#: ../../library/dataclasses.rst:441
msgid ""
"The other place where :func:`dataclass` inspects a type annotation is to "
"determine if a field is an init-only variable.  It does this by seeing if "
"the type of a field is of type ``dataclasses.InitVar``.  If a field is an "
"``InitVar``, it is considered a pseudo-field called an init-only field.  As "
"it is not a true field, it is not returned by the module-level "
":func:`fields` function.  Init-only fields are added as parameters to the "
"generated :meth:`__init__` method, and are passed to the optional "
":meth:`__post_init__` method.  They are not otherwise used by dataclasses."
msgstr ""
":func:`dataclass` ãŒå‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®æ¤œæŸ»ã‚’è¡Œã†ã‚‚ã† 1 ã¤ã®ç®‡æ‰€ã¯ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒåˆæœŸåŒ–é™å®šå¤‰æ•°ã‹ã©ã†ã‹ã®åˆ¤å®šã§ã™ã€‚\n"
"ãã®åˆ¤å®šã¯ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‹ãŒ ``dataclasses.InitVar`` å‹ã§ã‚ã‚‹ã‹ã©ã†ã‹ã§è¡Œã„ã¾ã™ã€‚\n"
"ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ ``InitVar`` ã®å ´åˆã€åˆæœŸåŒ–é™å®šãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨å‘¼ã°ã‚Œã‚‹ç–‘ä¼¼ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨è¦‹ãªã•ã‚Œã¾ã™ã€‚\n"
"ã“ã‚Œã¯æœ¬ç‰©ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ã¯ãªã„ã®ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«é–¢æ•° :func:`fields` ã®è¿”ã‚Šå€¤ã«ã¯å«ã¾ã‚Œã¾ã›ã‚“ã€‚\n"
"åˆæœŸåŒ–é™å®šãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ç”Ÿæˆã•ã‚ŒãŸ :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã«å¼•æ•°ã¨ã—ã¦è¿½åŠ ã•ã‚Œã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® :meth:`__post_init__` ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚‚æ¸¡ã•ã‚Œã¾ã™ã€‚\n"
"åˆæœŸåŒ–é™å®šãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã‹ã‚‰ã¯ãã‚Œä»¥å¤–ã§ã¯ä½¿ã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:451
msgid ""
"For example, suppose a field will be initialized from a database, if a value"
" is not provided when creating the class::"
msgstr "ä¾‹ãˆã°ã€ã‚ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰åˆæœŸåŒ–ã•ã‚Œã‚‹ã¨ä»®å®šã—ã¦ã€ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã™ã‚‹ã¨ãã«ã¯å€¤ãŒä¸ãˆã‚‰ã‚Œãªã„æ¬¡ã®å ´åˆã‚’è€ƒãˆã¾ã™::"

#: ../../library/dataclasses.rst:466
msgid ""
"In this case, :func:`fields` will return :class:`Field` objects for ``i`` "
"and ``j``, but not for ``database``."
msgstr ""
"ã“ã®ã‚±ãƒ¼ã‚¹ã§ã¯ã€ :func:`fields` ã¯ ``i`` ã¨ ``j`` ã® :class:`Field` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è¿”ã—ã¾ã™ãŒã€ "
"``database`` ã® :class:`Field` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è¿”ã—ã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:470
msgid "Frozen instances"
msgstr "å‡çµã•ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹"

#: ../../library/dataclasses.rst:472
msgid ""
"It is not possible to create truly immutable Python objects.  However, by "
"passing ``frozen=True`` to the :meth:`dataclass` decorator you can emulate "
"immutability.  In that case, dataclasses will add :meth:`__setattr__` and "
":meth:`__delattr__` methods to the class.  These methods will raise a "
":exc:`FrozenInstanceError` when invoked."
msgstr ""
"çœŸã«ä¸å¤‰ãª Python ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã®ã¯ä¸å¯èƒ½ã§ã™ã€‚\n"
"ã—ã‹ã—ã€ ``frozen=True`` ã‚’ :meth:`dataclass` ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã«æ¸¡ã™ã“ã¨ã§ã€ä¸å¤‰æ€§ã®æ¨¡å€£ã¯ã§ãã¾ã™ã€‚\n"
"ã“ã®ã‚±ãƒ¼ã‚¹ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã¯ :meth:`__setattr__` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ :meth:`__delattr__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚¯ãƒ©ã‚¹ã«è¿½åŠ ã—ã¾ã™ã€‚\n"
"ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯èµ·å‹•ã™ã‚‹ã¨ :exc:`FrozenInstanceError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/dataclasses.rst:478
msgid ""
"There is a tiny performance penalty when using ``frozen=True``: "
":meth:`__init__` cannot use simple assignment to initialize fields, and must"
" use :meth:`object.__setattr__`."
msgstr ""
"``frozen=True`` ã‚’ä½¿ã†ã¨ãã€å®Ÿè¡Œã™ã‚‹ä¸Šã§ã®ã‚ãšã‹ãªä»£å„ŸãŒã‚ã‚Šã¾ã™: :meth:`__init__` "
"ã§ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åˆæœŸåŒ–ã™ã‚‹ã®ã«å˜ç´”ã«å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ã¯ã§ããšã€ :meth:`object.__setattr__` ã‚’ä½¿ã‚ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/dataclasses.rst:483
msgid "Inheritance"
msgstr "ç¶™æ‰¿"

#: ../../library/dataclasses.rst:485
msgid ""
"When the dataclass is being created by the :meth:`dataclass` decorator, it "
"looks through all of the class's base classes in reverse MRO (that is, "
"starting at :class:`object`) and, for each dataclass that it finds, adds the"
" fields from that base class to an ordered mapping of fields. After all of "
"the base class fields are added, it adds its own fields to the ordered "
"mapping.  All of the generated methods will use this combined, calculated "
"ordered mapping of fields.  Because the fields are in insertion order, "
"derived classes override base classes.  An example::"
msgstr ""
"ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ãŒ :meth:`dataclass` ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã§ä½œæˆã•ã‚Œã‚‹ã¨ãã€ MRO ã‚’é€†å‘ãã« (ã™ãªã‚ã¡ã€ :class:`object` ã‚’å‡ºç™ºç‚¹ã¨ã—ã¦) å…¨ã¦ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’èª¿ã¹ã¦ã„ãã€è¦‹ä»˜ã‹ã£ãŸãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ãã‚Œãã‚Œã«ã¤ã„ã¦ã€ãã®åŸºåº•ã‚¯ãƒ©ã‚¹ãŒæŒã£ã¦ã„ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’é †åºä»˜ããƒãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¿½åŠ ã—ã¾ã™ã€‚\n"
"å…¨ã¦ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¿½åŠ ã—çµ‚ã‚ã£ãŸã‚‰ã€è‡ªåˆ†è‡ªèº«ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’é †åºä»˜ããƒãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¿½åŠ ã—ã¾ã™ã€‚\n"
"ç”Ÿæˆã•ã‚ŒãŸå…¨ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒé›†ã‚ã‚‰ã‚Œæ•´åˆ—ã•ã‚ŒãŸé †åºä»˜ãã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆ©ç”¨ã—ã¾ã™ã€‚\n"
"ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯æŒ¿å…¥é †åºã§ä¸¦ã‚“ã§ã„ã‚‹ã®ã§ã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã¯åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¾ã™ã€‚\n"
"ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/dataclasses.rst:505
msgid ""
"The final list of fields is, in order, ``x``, ``y``, ``z``.  The final type "
"of ``x`` is ``int``, as specified in class ``C``."
msgstr ""
"æœ€çµ‚çš„ã«å‡ºæ¥ä¸ŠãŒã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒªã‚¹ãƒˆã¯ ``x``, ``y``, ``z`` ã®é †ç•ªã«ãªã‚Šã¾ã™ã€‚\n"
"æœ€çµ‚çš„ãª ``x`` ã®å‹ã¯ã€ ã‚¯ãƒ©ã‚¹ ``C`` ã§æŒ‡å®šã•ã‚Œã¦ã„ã‚‹é€šã‚Š ``int`` ã§ã™ã€‚"

#: ../../library/dataclasses.rst:508
msgid "The generated :meth:`__init__` method for ``C`` will look like::"
msgstr "``C`` ã®ç”Ÿæˆã•ã‚ŒãŸ :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/dataclasses.rst:513
msgid "Default factory functions"
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°"

#: ../../library/dataclasses.rst:515
msgid ""
"If a :func:`field` specifies a ``default_factory``, it is called with zero "
"arguments when a default value for the field is needed.  For example, to "
"create a new instance of a list, use::"
msgstr ""
":func:`field` ã« ``default_factory`` ã‚’æŒ‡å®šã—ãŸå ´åˆã€ãã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒå¿…è¦ã¨ã•ã‚ŒãŸã¨ãã«ã€å¼•æ•°ç„¡ã—ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
"ã“ã‚Œã¯ä¾‹ãˆã°ã€ãƒªã‚¹ãƒˆã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ä½¿ã„ã¾ã™::"

#: ../../library/dataclasses.rst:521
msgid ""
"If a field is excluded from :meth:`__init__` (using ``init=False``) and the "
"field also specifies ``default_factory``, then the default factory function "
"will always be called from the generated :meth:`__init__` function.  This "
"happens because there is no other way to give the field an initial value."
msgstr ""
"ã‚ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ (``init=False`` ã‚’ä½¿ã£ã¦) :meth:`__init__` ã‹ã‚‰é™¤å¤–ã•ã‚Œã€ã‹ã¤ã€ ``default_factory`` ãŒæŒ‡å®šã•ã‚Œã¦ã„ãŸå ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã¯ç”Ÿæˆã•ã‚ŒãŸ :meth:`__init__` é–¢æ•°ã‹ã‚‰å¸¸ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\n"
"ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«åˆæœŸå€¤ã‚’ä¸ãˆã‚‹æ–¹æ³•ãŒä»–ã«ç„¡ã„ã®ã§ã€ã“ã®ã‚ˆã†ãªå‹•ãã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/dataclasses.rst:528
msgid "Mutable default values"
msgstr "å¯å¤‰ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤"

#: ../../library/dataclasses.rst:530
msgid ""
"Python stores default member variable values in class attributes. Consider "
"this example, not using dataclasses::"
msgstr ""
"Python ã¯ãƒ¡ãƒ³ãƒå¤‰æ•°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ã‚¯ãƒ©ã‚¹å±æ€§ã«ä¿æŒã—ã¾ã™ã€‚\n"
"ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã£ã¦ã„ãªã„ã€ã“ã®ä¾‹ã‚’è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†::"

#: ../../library/dataclasses.rst:545
msgid ""
"Note that the two instances of class ``C`` share the same class variable "
"``x``, as expected."
msgstr "ã‚¯ãƒ©ã‚¹ ``C`` ã® 2 ã¤ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã€äºˆæƒ³é€šã‚ŠåŒã˜ã‚¯ãƒ©ã‚¹å¤‰æ•° ``x`` ã‚’å…±æœ‰ã—ã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/dataclasses.rst:548
msgid "Using dataclasses, *if* this code was valid::"
msgstr "ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã£ã¦ã„ã‚‹ã“ã®ã‚³ãƒ¼ãƒ‰ãŒ *ã‚‚ã—ä»®ã«* æœ‰åŠ¹ãªã‚‚ã®ã ã¨ã—ãŸã‚‰::"

#: ../../library/dataclasses.rst:556
msgid "it would generate code similar to::"
msgstr "ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã¯æ¬¡ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã™ã‚‹ã§ã—ã‚‡ã†::"

#: ../../library/dataclasses.rst:567
msgid ""
"This has the same issue as the original example using class ``C``. That is, "
"two instances of class ``D`` that do not specify a value for ``x`` when "
"creating a class instance will share the same copy of ``x``.  Because "
"dataclasses just use normal Python class creation they also share this "
"behavior.  There is no general way for Data Classes to detect this "
"condition.  Instead, dataclasses will raise a :exc:`TypeError` if it detects"
" a default parameter of type ``list``, ``dict``, or ``set``.  This is a "
"partial solution, but it does protect against many common errors."
msgstr ""
"ã“ã‚Œã«ã¯ã€ã‚¯ãƒ©ã‚¹ ``C`` ã‚’ä½¿ã£ãŸã•ã£ãã®ä¾‹ã¨åŒã˜å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚\n"
"ã™ãªã‚ã¡ã€ã‚¯ãƒ©ã‚¹ ``D`` ã® 2 ã¤ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ã¨ãã« ``x`` ã®å…·ä½“çš„ãªå€¤ã‚’æŒ‡å®šã—ã¦ãŠã‚‰ãšã€åŒã˜ ``x`` ã®ã‚³ãƒ”ãƒ¼ã‚’å…±æœ‰ã—ã¾ã™ã€‚\n"
"ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã¯ Python ã®é€šå¸¸ã®ã‚¯ãƒ©ã‚¹ä½œæˆã®ä»•çµ„ã¿ã‚’ä½¿ã£ã¦ã„ã‚‹ã ã‘ãªã®ã§ã€ã“ã®åŒã˜å•é¡Œã‚’æŠ±ãˆã¦ã„ã¾ã™ã€‚\n"
"ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ãŒã“ã®å•é¡Œã‚’æ¤œå‡ºã™ã‚‹ä¸€èˆ¬çš„ãªæ–¹æ³•ã‚’æŒãŸãªã„ä»£ã‚ã‚Šã«ã€ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã¯å‹ãŒ ``list`` ã‚„ ``dict`` ã‚„ ``set`` ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’æ¤œå‡ºã—ãŸå ´åˆã€ :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚\n"
"ã“ã‚Œã¯å®Œå…¨ã§ã¯ãªã„è§£æ±ºæ³•ã§ã™ãŒã€ã‚ˆãã‚ã‚‹ã‚¨ãƒ©ãƒ¼ã®å¤šãã‚’é˜²ã’ã¾ã™ã€‚"

#: ../../library/dataclasses.rst:577
msgid ""
"Using default factory functions is a way to create new instances of mutable "
"types as default values for fields::"
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã‚’ä½¿ã†ã®ãŒã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ã—ã¦å¯å¤‰ãªå‹ã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹æ‰‹æ®µã§ã™::"

#: ../../library/dataclasses.rst:587
msgid "Exceptions"
msgstr "ä¾‹å¤–"

#: ../../library/dataclasses.rst:591
msgid ""
"Raised when an implicitly defined :meth:`__setattr__` or :meth:`__delattr__`"
" is called on a dataclass which was defined with ``frozen=True``."
msgstr ""
"``frozen=True`` ä»˜ãã§å®šç¾©ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã§ã€æš—é»™çš„ã«å®šç¾©ã•ã‚ŒãŸ :meth:`__setattr__` ã¾ãŸã¯ "
":meth:`__delattr__` ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã«é€å‡ºã•ã‚Œã¾ã™ã€‚"
