# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017-2018
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-26 13:42+0900\n"
"PO-Revision-Date: 2018-06-26 04:55+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "çµ„ã¿è¾¼ã¿å‹"

#: ../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr "ä»¥ä¸‹ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹æ¨™æº–å‹ã«ã¤ã„ã¦è¨˜è¿°ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:15
msgid ""
"Historically (until release 2.2), Python's built-in types have differed from"
" user-defined types because it was not possible to use the built-in types as"
" the basis for object-oriented inheritance. This limitation no longer "
"exists."
msgstr "ã“ã‚Œã¾ã§ã® (ãƒªãƒªãƒ¼ã‚¹ 2.2 ã¾ã§ã®) Python ã®æ­´å²ã§ã¯ã€çµ„ã¿è¾¼ã¿å‹ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã«ãŠã‘ã‚‹ç¶™æ‰¿ã‚’è¡Œã†éš›ã«é››å‹ã«ã§ããªã„ã¨ã„ã†ç‚¹ã§ã€ãƒ¦ãƒ¼ã‚¶å®šç¾©å‹ã¨ã¯ç•°ãªã£ã¦ã„ã¾ã—ãŸã€‚ã„ã¾ã§ã¯ã“ã®ã‚ˆã†ãªåˆ¶é™ã¯ãªããªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:22
msgid ""
"The principal built-in types are numerics, sequences, mappings, files, "
"classes, instances and exceptions."
msgstr "ä¸»è¦ãªçµ„ã¿è¾¼ã¿å‹ã¯æ•°å€¤å‹ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã€ãƒãƒƒãƒ”ãƒ³ã‚°å‹ã€ãƒ•ã‚¡ã‚¤ãƒ«ã€ã‚¯ãƒ©ã‚¹ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å‹ã€ãŠã‚ˆã³ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/stdtypes.rst:27
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared, tested for truth value, and "
"converted to a string (with the :ref:`repr() <func-repr>` function or the "
"slightly different :func:`str` function).  The latter function is implicitly"
" used when an object is written by the :func:`print` function."
msgstr "æ¼”ç®—ã«ã‚ˆã£ã¦ã¯ã€è¤‡æ•°ã®å‹ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã™; ç‰¹ã«ã€ã»ã¼å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã€æ¯”è¼ƒã€çœŸç†å€¤ãƒ†ã‚¹ãƒˆã€ (:ref:`repr() <func-repr>` é–¢æ•°ã‚„ã€ã‚ãšã‹ã«ç•°ãªã‚‹ :func:`str` é–¢æ•°ã«ã‚ˆã‚‹) æ–‡å­—åˆ—ã¸ã®å¤‰æ›ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ :func:`print` é–¢æ•°ã§å°å­—ã•ã‚Œã‚‹ã¨ãã€æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹é–¢æ•°ãŒæš—é»™ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:37
msgid "Truth Value Testing"
msgstr "çœŸç†å€¤åˆ¤å®š"

#: ../../library/stdtypes.rst:46
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or "
":keyword:`while` condition or as operand of the Boolean operations below. "
"The following values are considered false:"
msgstr "ã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚çœŸç†å€¤ã‚’åˆ¤å®šã§ãã€ :keyword:`if` ã‚„ :keyword:`while` æ¡ä»¶ã«ã€ã¾ãŸã¯ä»¥ä¸‹ã®ãƒ–ãƒ¼ãƒ«æ¼”ç®—ã®è¢«æ¼”ç®—å­ã«ä½¿ãˆã¾ã™ã€‚ä»¥ä¸‹ã®å€¤ã¯å½ã¨è¦‹ãªã•ã‚Œã¾ã™:"

#: ../../library/stdtypes.rst:52
msgid "``None``"
msgstr "``None``"

#: ../../library/stdtypes.rst:56
msgid "``False``"
msgstr "``False``"

#: ../../library/stdtypes.rst:58
msgid "zero of any numeric type, for example, ``0``, ``0L``, ``0.0``, ``0j``."
msgstr "æ•°å€¤å‹ã«ãŠã‘ã‚‹ã‚¼ãƒ­ã€‚ä¾‹ãˆã° ``0``, ``0L``, ``0.0``, ``0j`` ã€‚"

#: ../../library/stdtypes.rst:60
msgid "any empty sequence, for example, ``''``, ``()``, ``[]``."
msgstr "ç©ºã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã€‚ä¾‹ãˆã° ``''``, ``()``, ``[]`` ã€‚"

#: ../../library/stdtypes.rst:62
msgid "any empty mapping, for example, ``{}``."
msgstr "ç©ºã®ãƒãƒƒãƒ”ãƒ³ã‚°ã€‚ä¾‹ãˆã° ``{}`` ã€‚"

#: ../../library/stdtypes.rst:64
msgid ""
"instances of user-defined classes, if the class defines a "
":meth:`__nonzero__` or :meth:`__len__` method, when that method returns the "
"integer zero or :class:`bool` value ``False``. [1]_"
msgstr "ãƒ¦ãƒ¼ã‚¶å®šç¾©ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã€ãã®ã‚¯ãƒ©ã‚¹ãŒ :meth:`__nonzero__` ã¾ãŸã¯ :meth:`__len__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã‚Œã°ã€ãã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒæ•´æ•° 0 ã¾ãŸã¯ :class:`bool` å€¤ ``False`` ã‚’è¿”ã™ã¨ãã€‚ [1]_"

#: ../../library/stdtypes.rst:70
msgid ""
"All other values are considered true --- so objects of many types are always"
" true."
msgstr "ãã‚Œä»¥å¤–ã®å…¨ã¦ã®å€¤ã¯çœŸã¨è¦‹ãªã•ã‚Œã¾ã™ --- å¾“ã£ã¦ã€å¤šãã®å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¸¸ã«çœŸã§ã™ã€‚"

#: ../../library/stdtypes.rst:79
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr "ãƒ–ãƒ¼ãƒ«å€¤ã®çµæœã‚’è¿”ã™æ¼”ç®—ãŠã‚ˆã³çµ„ã¿è¾¼ã¿é–¢æ•°ã¯ã€ç‰¹ã«æ³¨é‡ˆã®ãªã„é™ã‚Šå¸¸ã«å½å€¤ã¨ã—ã¦ ``0`` ã¾ãŸã¯ ``False`` ã‚’è¿”ã—ã€çœŸå€¤ã¨ã—ã¦ ``1`` ã¾ãŸã¯ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ (é‡è¦ãªä¾‹å¤–: ãƒ–ãƒ¼ãƒ«æ¼”ç®— ``or`` ãŠã‚ˆã³ ``and`` ã¯å¸¸ã«è¢«æ¼”ç®—å­ã®ã†ã¡ã®ä¸€ã¤ã‚’è¿”ã—ã¾ã™ã€‚)"

#: ../../library/stdtypes.rst:88
msgid "Boolean Operations --- :keyword:`and`, :keyword:`or`, :keyword:`not`"
msgstr "ãƒ–ãƒ¼ãƒ«æ¼”ç®— --- :keyword:`and`, :keyword:`or`, :keyword:`not`"

#: ../../library/stdtypes.rst:92
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "ä»¥ä¸‹ã«ãƒ–ãƒ¼ãƒ«æ¼”ç®—ã‚’ã€å„ªå…ˆé †ä½ãŒä½ã„é †ã«ç¤ºã—ã¾ã™:"

#: ../../library/stdtypes.rst:95 ../../library/stdtypes.rst:153
#: ../../library/stdtypes.rst:299 ../../library/stdtypes.rst:397
#: ../../library/stdtypes.rst:444 ../../library/stdtypes.rst:733
#: ../../library/stdtypes.rst:1657
msgid "Operation"
msgstr "æ¼”ç®—"

#: ../../library/stdtypes.rst:95 ../../library/stdtypes.rst:299
#: ../../library/stdtypes.rst:397 ../../library/stdtypes.rst:444
#: ../../library/stdtypes.rst:733 ../../library/stdtypes.rst:1657
msgid "Result"
msgstr "çµæœ"

#: ../../library/stdtypes.rst:95 ../../library/stdtypes.rst:153
#: ../../library/stdtypes.rst:299 ../../library/stdtypes.rst:444
#: ../../library/stdtypes.rst:733 ../../library/stdtypes.rst:1508
#: ../../library/stdtypes.rst:1657
msgid "Notes"
msgstr "æ³¨é‡ˆ"

#: ../../library/stdtypes.rst:97
msgid "``x or y``"
msgstr "``x or y``"

#: ../../library/stdtypes.rst:97
msgid "if *x* is false, then *y*, else *x*"
msgstr "*x* ãŒå½ãªã‚‰ *y*, ãã†ã§ãªã‘ã‚Œã° *x*"

#: ../../library/stdtypes.rst:97 ../../library/stdtypes.rst:165
#: ../../library/stdtypes.rst:307 ../../library/stdtypes.rst:735
#: ../../library/stdtypes.rst:738 ../../library/stdtypes.rst:1514
#: ../../library/stdtypes.rst:1668
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/stdtypes.rst:100
msgid "``x and y``"
msgstr "``x and y``"

#: ../../library/stdtypes.rst:100
msgid "if *x* is false, then *x*, else *y*"
msgstr "*x* ãŒå½ãªã‚‰ *x*, ãã†ã§ãªã‘ã‚Œã° *y*"

#: ../../library/stdtypes.rst:100 ../../library/stdtypes.rst:321
#: ../../library/stdtypes.rst:323 ../../library/stdtypes.rst:744
#: ../../library/stdtypes.rst:1518 ../../library/stdtypes.rst:1520
#: ../../library/stdtypes.rst:1674
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/stdtypes.rst:103
msgid "``not x``"
msgstr "``not x``"

#: ../../library/stdtypes.rst:103
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "*x* ãŒå½ãªã‚‰ ``True``, ãã†ã§ãªã‘ã‚Œã° ``False``"

#: ../../library/stdtypes.rst:103 ../../library/stdtypes.rst:318
#: ../../library/stdtypes.rst:747 ../../library/stdtypes.rst:1522
#: ../../library/stdtypes.rst:1524 ../../library/stdtypes.rst:1526
#: ../../library/stdtypes.rst:1528 ../../library/stdtypes.rst:1677
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/stdtypes.rst:112 ../../library/stdtypes.rst:172
#: ../../library/stdtypes.rst:345 ../../library/stdtypes.rst:462
#: ../../library/stdtypes.rst:787 ../../library/stdtypes.rst:1551
#: ../../library/stdtypes.rst:1704
msgid "Notes:"
msgstr "æ³¨é‡ˆ:"

#: ../../library/stdtypes.rst:115
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr "ã“ã®æ¼”ç®—å­ã¯çŸ­çµ¡è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šç¬¬ä¸€å¼•æ•°ãŒå½ã®ã¨ãã«ã®ã¿ã€ç¬¬äºŒå¼•æ•°ãŒè©•ä¾¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:119
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr "ã“ã®æ¼”ç®—å­ã¯çŸ­çµ¡è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šç¬¬ä¸€å¼•æ•°ãŒçœŸã®ã¨ãã«ã®ã¿ã€ç¬¬äºŒå¼•æ•°ãŒè©•ä¾¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:123
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr "``not`` ã¯éãƒ–ãƒ¼ãƒ«æ¼”ç®—å­ã‚ˆã‚Šã‚‚å„ªå…ˆåº¦ãŒä½ã„ã®ã§ã€ ``not a == b`` ã¯ ``not (a == b)`` ã¨è§£é‡ˆã•ã‚Œã€ ``a == not b`` ã¯æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã§ã™ã€‚"

#: ../../library/stdtypes.rst:130
msgid "Comparisons"
msgstr "æ¯”è¼ƒ"

#: ../../library/stdtypes.rst:144
msgid ""
"Comparison operations are supported by all objects.  They all have the same "
"priority (which is higher than that of the Boolean operations). Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x"
" < y and y <= z``, except that *y* is evaluated only once (but in both cases"
" *z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr "æ¯”è¼ƒæ¼”ç®—ã¯å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚æ¯”è¼ƒæ¼”ç®—å­ã¯å…¨ã¦åŒã˜æ¼”ç®—å„ªå…ˆåº¦ã‚’æŒã£ã¦ã„ã¾ã™ (ãƒ–ãƒ¼ãƒ«æ¼”ç®—ã‚ˆã‚Šé«˜ã„æ¼”ç®—å„ªå…ˆåº¦ã§ã™)ã€‚æ¯”è¼ƒã¯ä»»æ„ã®å½¢ã§é€£é–ã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™; ä¾‹ãˆã°ã€ ``x < y <= z`` ã¯ ``x < y and y <= z`` ã¨ç­‰ä¾¡ã§ã€é•ã†ã®ã¯ *y* ãŒä¸€åº¦ã ã‘ã—ã‹è©•ä¾¡ã•ã‚Œãªã„ã¨ã„ã†ã“ã¨ã§ã™ (ã©ã¡ã‚‰ã®å ´åˆã§ã‚‚ã€ ``x < y`` ãŒå½ã¨ãªã£ãŸå ´åˆã«ã¯ *z* ã¯è©•ä¾¡ã•ã‚Œã¾ã›ã‚“)ã€‚"

#: ../../library/stdtypes.rst:150
msgid "This table summarizes the comparison operations:"
msgstr "ä»¥ä¸‹ã®è¡¨ã«æ¯”è¼ƒæ¼”ç®—ã‚’ã¾ã¨ã‚ã¾ã™:"

#: ../../library/stdtypes.rst:153 ../../library/stdtypes.rst:1485
#: ../../library/stdtypes.rst:1508
msgid "Meaning"
msgstr "æ„å‘³"

#: ../../library/stdtypes.rst:155
msgid "``<``"
msgstr "``<``"

#: ../../library/stdtypes.rst:155
msgid "strictly less than"
msgstr "ã‚ˆã‚Šå°ã•ã„"

#: ../../library/stdtypes.rst:157
msgid "``<=``"
msgstr "``<=``"

#: ../../library/stdtypes.rst:157
msgid "less than or equal"
msgstr "ä»¥ä¸‹"

#: ../../library/stdtypes.rst:159
msgid "``>``"
msgstr "``>``"

#: ../../library/stdtypes.rst:159
msgid "strictly greater than"
msgstr "ã‚ˆã‚Šå¤§ãã„"

#: ../../library/stdtypes.rst:161
msgid "``>=``"
msgstr "``>=``"

#: ../../library/stdtypes.rst:161
msgid "greater than or equal"
msgstr "ä»¥ä¸Š"

#: ../../library/stdtypes.rst:163
msgid "``==``"
msgstr "``==``"

#: ../../library/stdtypes.rst:163
msgid "equal"
msgstr "ç­‰ã—ã„"

#: ../../library/stdtypes.rst:165
msgid "``!=``"
msgstr "``!=``"

#: ../../library/stdtypes.rst:165
msgid "not equal"
msgstr "ç­‰ã—ããªã„"

#: ../../library/stdtypes.rst:167
msgid "``is``"
msgstr "``is``"

#: ../../library/stdtypes.rst:167
msgid "object identity"
msgstr "åŒä¸€ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹"

#: ../../library/stdtypes.rst:169
msgid "``is not``"
msgstr "``is not``"

#: ../../library/stdtypes.rst:169
msgid "negated object identity"
msgstr "åŒä¸€ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã„"

#: ../../library/stdtypes.rst:175
msgid ""
"``!=`` can also be written ``<>``, but this is an obsolete usage kept for "
"backwards compatibility only. New code should always use ``!=``."
msgstr "``!=`` ã¯ ``<>`` ã¨ã‚‚æ›¸ã‘ã¾ã™ãŒã“ã‚Œã¯æ™‚ä»£é…ã‚Œã®æ›¸ãæ–¹ã§ã€å¾Œæ–¹äº’æ›æ€§ç¶­æŒã®ãŸã‚ã ã‘ã«æ®‹ã•ã‚Œã¦ã„ã¾ã™ã€‚æ–°ã—ã„ã‚³ãƒ¼ãƒ‰ã§ã¯å¸¸ã« ``!=`` ã‚’ä½¿ã†ã¹ãã§ã™ã€‚"

#: ../../library/stdtypes.rst:183
msgid ""
"Objects of different types, except different numeric types and different "
"string types, never compare equal; such objects are ordered consistently but"
" arbitrarily (so that sorting a heterogeneous array yields a consistent "
"result). Furthermore, some types (for example, file objects) support only a "
"degenerate notion of comparison where any two objects of that type are "
"unequal.  Again, such objects are ordered arbitrarily but consistently. The "
"``<``, ``<=``, ``>`` and ``>=`` operators will raise a :exc:`TypeError` "
"exception when any operand is a complex number."
msgstr "æ•°å€¤å‹é–“ã®æ¯”è¼ƒã‹æ–‡å­—åˆ—é–“ã®æ¯”è¼ƒã§ãªã„ã‹ãã‚Šã€ç•°ãªã‚‹å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¯”è¼ƒã—ã¦ã‚‚ç­‰ä¾¡ã«ãªã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“; ã“ã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é †ç•ªä»˜ã‘ã¯ä¸€è²«ã—ã¦ã¯ã„ã¾ã™ãŒä»»æ„ã®ã‚‚ã®ã§ã™ (å¾“ã£ã¦è¦ç´ ã®å‹ãŒä¸€æ§˜ã§ãªã„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã‚½ãƒ¼ãƒˆã—ãŸçµæœã¯ä¸€è²«ã—ãŸã‚‚ã®ã«ãªã‚Šã¾ã™)ã€‚ã•ã‚‰ã«ã€ (ä¾‹ãˆã°ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚ˆã†ã«) å‹ã«ã‚ˆã£ã¦ã¯ã€ãã®å‹ã® 2 ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸ç­‰æ€§ã ã‘ã®ã€ç¸®é€€ã—ãŸæ¯”è¼ƒã®æ¦‚å¿µã—ã‹ã‚µãƒãƒ¼ãƒˆã—ãªã„ã‚‚ã®ã‚‚ã‚ã‚Šã¾ã™ã€‚ç¹°ã‚Šè¿”ã—ã¾ã™ãŒã€ãã®ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ä»»æ„ã®é †ç•ªä»˜ã‘ã‚’ã•ã‚Œã¦ã„ã¾ã™ãŒã€ãã‚Œã¯ä¸€è²«ã—ãŸã‚‚ã®ã§ã™ã€‚è¢«æ¼”ç®—å­ãŒè¤‡ç´ æ•°ã®å ´åˆã€æ¼”ç®—å­ ``<``, ``<=``, ``>`` ãŠã‚ˆã³ ``>=`` ã¯ä¾‹å¤– :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:201
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`__eq__` method or the :meth:`__cmp__` method."
msgstr "ã‚ã‚‹ã‚¯ãƒ©ã‚¹ã®åŒä¸€ã§ãªã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€é€šå¸¸ç­‰ä¾¡ã§ãªã„ã¨ã•ã‚Œã¾ã™ãŒã€ãã®ã‚¯ãƒ©ã‚¹ãŒ :meth:`__eq__` ãƒ¡ã‚½ãƒƒãƒ‰ã‹ :meth:`__cmp__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã‚‹å ´åˆã¯é™¤ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:204
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines either "
"enough of the rich comparison methods (:meth:`__lt__`, :meth:`__le__`, "
":meth:`__gt__`, and :meth:`__ge__`) or the :meth:`__cmp__` method."
msgstr "ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ãã®ã‚¯ãƒ©ã‚¹ãŒååˆ†ãªã ã‘ã®æ‹¡å¼µæ¯”è¼ƒãƒ¡ã‚½ãƒƒãƒ‰ (:meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, :meth:`__ge__`) ã¾ãŸã¯ :meth:`__cmp__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ãªã„é™ã‚Šã€åŒã˜ã‚¯ãƒ©ã‚¹ã®åˆ¥ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚„ä»–ã®å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¯é †åºä»˜ã‘ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:211
msgid ""
"Objects of different types except numbers are ordered by their type names; "
"objects of the same types that don't support proper comparison are ordered "
"by their address."
msgstr "æ•°å€¤å‹ã‚’é™¤ãã€ç•°ãªã‚‹å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å‹ã®åå‰ã§é †ç•ªä»˜ã‘ã•ã‚Œã¾ã™; é©å½“ãªæ¯”è¼ƒã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã‚ã‚‹å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ã‚ˆã£ã¦é †ç•ªä»˜ã‘ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:219
msgid ""
"Two more operations with the same syntactic priority, ``in`` and ``not in``,"
" are supported only by sequence types (below)."
msgstr "åŒã˜å„ªå…ˆåº¦ã‚’æŒã¤æ¼”ç®—å­ã¨ã—ã¦ã•ã‚‰ã« 2 ã¤ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã§ã®ã¿ ``in`` ãŠã‚ˆã³ ``not in`` ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ (ä»¥ä¸‹ã‚’å‚ç…§)ã€‚"

#: ../../library/stdtypes.rst:226
msgid ""
"Numeric Types --- :class:`int`, :class:`float`, :class:`long`, "
":class:`complex`"
msgstr "æ•°å€¤å‹ :class:`int`, :class:`float`, :class:`long`, :class:`complex`"

#: ../../library/stdtypes.rst:237
msgid ""
"There are four distinct numeric types: :dfn:`plain integers`, :dfn:`long "
"integers`, :dfn:`floating point numbers`, and :dfn:`complex numbers`. In "
"addition, Booleans are a subtype of plain integers. Plain integers (also "
"just called :dfn:`integers`) are implemented using :c:type:`long` in C, "
"which gives them at least 32 bits of precision (``sys.maxint`` is always set"
" to the maximum plain integer value for the current platform, the minimum "
"value is ``-sys.maxint - 1``).  Long integers have unlimited precision.  "
"Floating point numbers are usually implemented using :c:type:`double` in C; "
"information about the precision and internal representation of floating "
"point numbers for the machine on which your program is running is available "
"in :data:`sys.float_info`.  Complex numbers have a real and imaginary part, "
"which are each a floating point number.  To extract these parts from a "
"complex number *z*, use ``z.real`` and ``z.imag``. (The standard library "
"includes additional numeric types, :mod:`fractions` that hold rationals, and"
" :mod:`decimal` that hold floating-point numbers with user-definable "
"precision.)"
msgstr "4 ã¤ã®ç•°ãªã‚‹æ•°å€¤å‹ãŒã‚ã‚Šã¾ã™: :dfn:`é€šå¸¸ã®æ•´æ•°å‹`, :dfn:`é•·æ•´æ•°å‹`, :dfn:`æµ®å‹•å°æ•°ç‚¹å‹`, :dfn:`è¤‡ç´ æ•°å‹` ã§ã™ã€‚ã•ã‚‰ã«ã€çœŸå½å€¤(Boolean)å‹ã‚‚é€šå¸¸ã®æ•´æ•°å‹ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ã™ã€‚é€šå¸¸ã®æ•´æ•° (å˜ã« :dfn:`æ•´æ•°å‹` ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™) ã¯ Cè¨€èªã® :c:type:`long` å‹ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã¦ãŠã‚Šã€å°‘ãªãã¨ã‚‚ 32 ãƒ“ãƒƒãƒˆã®ç²¾åº¦ãŒã‚ã‚Šã¾ã™ (``sys.maxint`` ã¯å¸¸ã«é€šå¸¸ã®æ•´æ•°ã®å„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ãŠã‘ã‚‹æœ€å¤§å€¤ã«ã‚»ãƒƒãƒˆã•ã‚Œã¦ãŠã‚Šã€æœ€å°å€¤ã¯ ``-sys.maxint - 1`` ã«ãªã‚Šã¾ã™)ã€‚é•·æ•´æ•°å‹ã«ã¯ç²¾åº¦ã®åˆ¶é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚æµ®å‹•å°æ•°ç‚¹å‹ã¯ãŸã„ã¦ã„ã¯ C ã® :c:type:`double` ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™; ã‚ãªãŸã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå‹•ä½œã™ã‚‹ãƒã‚·ãƒ³ã§ã®æµ®å‹•å°æ•°ç‚¹å‹ã®ç²¾åº¦ã¨å†…éƒ¨è¡¨ç¾ã¯ã€ :data:`sys.float_info` ã‹ã‚‰åˆ©ç”¨ã§ãã¾ã™ã€‚è¤‡ç´ æ•°å‹ã¯å®Ÿéƒ¨ã¨è™šéƒ¨ã‚’æŒã¡ã€ãã‚Œãã‚Œæµ®å‹•å°æ•°ç‚¹æ•°ã§ã™ã€‚è¤‡ç´ æ•° *z* ã‹ã‚‰å®Ÿéƒ¨ãŠã‚ˆã³è™šéƒ¨ã‚’å–ã‚Šå‡ºã™ã«ã¯ã€ ``z.real`` ãŠã‚ˆã³ ``z.imag`` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ (æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã¯ã€è¿½åŠ ã®æ•°å€¤å‹ã€åˆ†æ•°ã‚’ä¿æŒã™ã‚‹ :mod:`fractions` ã‚„ã€ãƒ¦ãƒ¼ã‚¶å®šç¾©ã®ç²¾åº¦ã®æµ®å‹•å°æ•°ç‚¹æ•°ã‚’ä¿æŒã™ã‚‹ :mod:`decimal` ãŒã‚ã‚Šã¾ã™ã€‚)"

#: ../../library/stdtypes.rst:262
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including binary, hex,"
" and octal numbers) yield plain integers unless the value they denote is too"
" large to be represented as a plain integer, in which case they yield a long"
" integer. Integer literals with an ``'L'`` or ``'l'`` suffix yield long "
"integers (``'L'`` is preferred because ``1l`` looks too much like eleven!)."
"  Numeric literals containing a decimal point or an exponent sign yield "
"floating point numbers. Appending ``'j'`` or ``'J'`` to a numeric literal "
"yields an imaginary number (a complex number with a zero real part) which "
"you can add to an integer or float to get a complex number with real and "
"imaginary parts."
msgstr "æ•°å€¤ã¯ã€æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã‚„çµ„ã¿è¾¼ã¿é–¢æ•°ã‚„æ¼”ç®—å­ã®æˆ»ã‚Šå€¤ã¨ã—ã¦ç”Ÿæˆã•ã‚Œã¾ã™ã€‚\nä¿®é£¾ã®ãªã„æ•´æ•°ãƒªãƒ†ãƒ©ãƒ« ( 2 é€²è¡¨ç¾ã‚„ã€ 16 é€²è¡¨ç¾ã‚„ 8 é€²è¡¨ç¾ã®å€¤ã‚‚å«ã¿ã¾ã™) ã¯ã€é€šå¸¸ã®æ•´æ•°å€¤ã‚’è¡¨ã—ã¾ã™ã€‚\nå€¤ãŒé€šå¸¸ã®æ•´æ•°ã§è¡¨ã™ã«ã¯å¤§ãã™ãã‚‹å ´åˆã€ ``'L'`` ã¾ãŸã¯ ``'l'`` ãŒæœ«å°¾ã«ã¤ãæ•´æ•°ãƒªãƒ†ãƒ©ãƒ«ã¯é•·æ•´æ•°å‹ã‚’è¡¨ã—ã¾ã™ (``'L'`` ãŒæœ›ã¾ã—ã„ã§ã™ã€‚ã¨ã„ã†ã®ã¯ ``1l`` ã¯ 11 ã¨éå¸¸ã«ç´›ã‚‰ã‚ã—ã„ã‹ã‚‰ã§ã™!)ã€‚\nå°æ•°ç‚¹ã¾ãŸã¯æŒ‡æ•°è¡¨è¨˜ã®ã‚ã‚‹æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã¯æµ®å‹•å°æ•°ç‚¹æ•°ã‚’è¡¨ã—ã¾ã™ã€‚\næ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã« ``'j'`` ã¾ãŸã¯ ``'J'`` ã‚’ã¤ã‘ã‚‹ã¨è™šæ•° (å®Ÿæ•°éƒ¨ãŒã‚¼ãƒ­ã®è¤‡ç´ æ•°) ã‚’è¡¨ã—ã€ãã‚Œã¨æ•´æ•°ã‚„æµ®å‹•å°æ•°ç‚¹æ•°ã‚’è¶³ã™ã¨å®Ÿéƒ¨ã¨è™šéƒ¨ã‚’æŒã¤è¤‡ç´ æ•°ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:287
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where plain integer is narrower than "
"long integer is narrower than floating point is narrower than complex. "
"Comparisons between numbers of mixed type use the same rule. [2]_ The "
"constructors :func:`int`, :func:`long`, :func:`float`, and :func:`complex` "
"can be used to produce numbers of a specific type."
msgstr "Python ã¯å‹æ··åˆã®æ¼”ç®—ã‚’å®Œå…¨ã«ã‚µãƒãƒ¼ãƒˆã—ã¾ã™: ã‚ã‚‹ 2 é …æ¼”ç®—å­ãŒäº’ã„ã«ç•°ãªã‚‹æ•°å€¤å‹ã®è¢«æ¼”ç®—å­ã‚’æŒã¤å ´åˆã€ã‚ˆã‚Š \"åˆ¶é™ã•ã‚ŒãŸ\" å‹ã®è¢«æ¼”ç®—å­ã¯ä»–æ–¹ã®å‹ã«åˆã‚ã›ã¦åºƒã’ã‚‰ã‚Œã¾ã™ã€‚ã“ã“ã§é€šå¸¸ã®æ•´æ•°ã¯é•·æ•´æ•°ã‚ˆã‚Šåˆ¶é™ã•ã‚Œã¦ãŠã‚Šã€é•·æ•´æ•°ã¯æµ®å‹•å°æ•°ç‚¹æ•°ã‚ˆã‚Šåˆ¶é™ã•ã‚Œã¦ãŠã‚Šã€æµ®å‹•å°æ•°ç‚¹ã¯è¤‡ç´ æ•°ã‚ˆã‚Šåˆ¶é™ã•ã‚Œã¦ã„ã¾ã™ã€‚å‹æ··åˆã®æ•°å€¤é–“ã§ã®æ¯”è¼ƒã‚‚åŒã˜è¦å‰‡ã«å¾“ã„ã¾ã™ã€‚ [2]_ ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ :func:`int`, :func:`long`, :func:`float`, ãŠã‚ˆã³ :func:`complex` ã‚’ä½¿ã£ã¦ã€ç‰¹å®šã®å‹ã®æ•°ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:295
msgid ""
"All built-in numeric types support the following operations. See "
":ref:`power` and later sections for the operators' priorities."
msgstr "å…¨ã¦ã®çµ„ã¿è¾¼ã¿æ•°å€¤å‹ã¯ä»¥ä¸‹ã®æ¼”ç®—ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚æ¼”ç®—å­ã®å„ªå…ˆåº¦ã«ã¤ã„ã¦ã¯ã€ :ref:`power`,ãŠã‚ˆã³ã€ã‚ã¨ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:301
msgid "``x + y``"
msgstr "``x + y``"

#: ../../library/stdtypes.rst:301
msgid "sum of *x* and *y*"
msgstr "*x* ã¨ *y* ã®å’Œ"

#: ../../library/stdtypes.rst:303
msgid "``x - y``"
msgstr "``x - y``"

#: ../../library/stdtypes.rst:303
msgid "difference of *x* and *y*"
msgstr "*x* ã¨ *y* ã®å·®"

#: ../../library/stdtypes.rst:305
msgid "``x * y``"
msgstr "``x * y``"

#: ../../library/stdtypes.rst:305
msgid "product of *x* and *y*"
msgstr "*x* ã¨ *y* ã®ç©"

#: ../../library/stdtypes.rst:307
msgid "``x / y``"
msgstr "``x / y``"

#: ../../library/stdtypes.rst:307
msgid "quotient of *x* and *y*"
msgstr "*x* ã¨ *y* ã®å•†"

#: ../../library/stdtypes.rst:309
msgid "``x // y``"
msgstr "``x // y``"

#: ../../library/stdtypes.rst:309
msgid "(floored) quotient of *x* and *y*"
msgstr "*x* ã¨ *y* ã®å•† (ã‚’åˆ‡ã‚Šä¸‹ã’ãŸã‚‚ã®)"

#: ../../library/stdtypes.rst:309
msgid "(4)(5)"
msgstr "(4)(5)"

#: ../../library/stdtypes.rst:312
msgid "``x % y``"
msgstr "``x % y``"

#: ../../library/stdtypes.rst:312
msgid "remainder of ``x / y``"
msgstr "``x / y`` ã®å‰°ä½™"

#: ../../library/stdtypes.rst:312 ../../library/stdtypes.rst:1530
#: ../../library/stdtypes.rst:1534 ../../library/stdtypes.rst:1686
#: ../../library/stdtypes.rst:1695
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/stdtypes.rst:314
msgid "``-x``"
msgstr "``-x``"

#: ../../library/stdtypes.rst:314
msgid "*x* negated"
msgstr "*x* ã®ç¬¦å·åè»¢"

#: ../../library/stdtypes.rst:316
msgid "``+x``"
msgstr "``+x``"

#: ../../library/stdtypes.rst:316
msgid "*x* unchanged"
msgstr "*x* ãã®ã¾ã¾"

#: ../../library/stdtypes.rst:318
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../library/stdtypes.rst:318
msgid "absolute value or magnitude of *x*"
msgstr "*x* ã®çµ¶å¯¾å€¤ã¾ãŸã¯å¤§ãã•"

#: ../../library/stdtypes.rst:321
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../library/stdtypes.rst:321
msgid "*x* converted to integer"
msgstr "*x* ã®æ•´æ•°ã¸ã®å¤‰æ›"

#: ../../library/stdtypes.rst:323
msgid "``long(x)``"
msgstr "``long(x)``"

#: ../../library/stdtypes.rst:323
msgid "*x* converted to long integer"
msgstr "*x* ã®é•·æ•´æ•°ã¸ã®å¤‰æ›"

#: ../../library/stdtypes.rst:325
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../library/stdtypes.rst:325
msgid "*x* converted to floating point"
msgstr "*x* ã®æµ®å‹•å°æ•°ç‚¹æ•°ã¸ã®å¤‰æ›"

#: ../../library/stdtypes.rst:325 ../../library/stdtypes.rst:741
#: ../../library/stdtypes.rst:1544 ../../library/stdtypes.rst:1692
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/stdtypes.rst:327
msgid "``complex(re,im)``"
msgstr "``complex(re,im)``"

#: ../../library/stdtypes.rst:327
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr "å®Ÿéƒ¨ *re*, è™šéƒ¨ *im* ã®è¤‡ç´ æ•°ã€‚ *im* ã®æ—¢å®šå€¤ã¯ã‚¼ãƒ­ã€‚"

#: ../../library/stdtypes.rst:331
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../../library/stdtypes.rst:331
msgid "conjugate of the complex number *c*. (Identity on real numbers)"
msgstr "è¤‡ç´ æ•° *c* ã®å…±å½¹è¤‡ç´ æ•° (å®Ÿæ•°ã«å¯¾ã—ã¦ã¯åŒã˜å€¤ã‚’è¿”ã™)"

#: ../../library/stdtypes.rst:334
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../library/stdtypes.rst:334
msgid "the pair ``(x // y, x % y)``"
msgstr "``(x // y, x % y)`` ã‹ã‚‰ãªã‚‹ãƒšã‚¢"

#: ../../library/stdtypes.rst:334 ../../library/stdtypes.rst:749
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../../library/stdtypes.rst:336
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../../library/stdtypes.rst:336 ../../library/stdtypes.rst:338
msgid "*x* to the power *y*"
msgstr "*x* ã® *y* ä¹—"

#: ../../library/stdtypes.rst:336
msgid "(3)(7)"
msgstr "(3)(7)"

#: ../../library/stdtypes.rst:338
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../../library/stdtypes.rst:338 ../../library/stdtypes.rst:1516
#: ../../library/stdtypes.rst:1697
msgid "\\(7)"
msgstr "\\(7)"

#: ../../library/stdtypes.rst:352
msgid ""
"For (plain or long) integer division, the result is an integer. The result "
"is always rounded towards minus infinity: 1/2 is 0, (-1)/2 is -1, 1/(-2) is "
"-1, and (-1)/(-2) is 0.  Note that the result is a long integer if either "
"operand is a long integer, regardless of the numeric value."
msgstr "(é€šå¸¸ãŠã‚ˆã³é•·) æ•´æ•°ã®å‰²ã‚Šç®—ã§ã¯ã€çµæœã¯æ•´æ•°ã«ãªã‚Šã¾ã™ã€‚ã“ã®å ´åˆå€¤ã¯å¸¸ã«ãƒã‚¤ãƒŠã‚¹ç„¡é™å¤§ã®æ–¹å‘ã«ä¸¸ã‚ã‚‰ã‚Œã¾ã™: ã¤ã¾ã‚Šã€1/2 ã¯ 0ã€ (-1)/2 ã¯ -1ã€1/(-1) ã¯ -1ã€ãã—ã¦ (-1)/(-2) ã¯ 0 ã«ãªã‚Šã¾ã™ã€‚è¢«æ¼”ç®—å­ã®ä¸¡æ–¹ãŒé•·æ•´æ•°ã®å ´åˆã€è¨ˆç®—å€¤ã«é–¢ã‚ã‚‰ãšçµæœã¯é•·æ•´æ•°ã§è¿”ã•ã‚Œã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:365
msgid ""
"Conversion from floats using :func:`int` or :func:`long` truncates toward "
"zero like the related function, :func:`math.trunc`.  Use the function "
":func:`math.floor` to round downward and :func:`math.ceil` to round upward."
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã‹ã‚‰ :func:`int`,ã¾ãŸã¯ã€ :func:`long` ã‚’ä½¿ã£ãŸå¤‰æ›ã§ã¯ã€é–¢é€£ã™ã‚‹é–¢æ•°ã€ :func:`math.trunc` ã®ã‚ˆã†ã«ã‚¼ãƒ­æ–¹å‘ã¸ä¸¸ã‚ã‚‰ã‚Œã¾ã™ã€‚ä¸‹æ–¹å‘ã¸ã®ä¸¸ã‚ã«ã¯ :func:`math.floor` ã‚’ä½¿ã„ã€ä¸Šæ–¹å‘ã¸ã®ä¸¸ã‚ã«ã¯ :func:`math.ceil` ã‚’ä½¿ã£ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:371
msgid "See :ref:`built-in-funcs` for a full description."
msgstr "å®Œå…¨ãªè¨˜è¿°ã«ã¤ã„ã¦ã¯ã€ :ref:`built-in-funcs`,ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:374
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are no longer defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr "åˆ‡ã‚Šæ¨ã¦é™¤ç®—æ¼”ç®—å­ã€ãƒ¢ã‚¸ãƒ¥ãƒ­æ¼”ç®—å­ã€ãŠã‚ˆã³ :func:`divmod` é–¢æ•°ã¯ã€è¤‡ç´ æ•°ã«å¯¾ã—ã¦ã¯ã‚‚ã¯ã‚„å®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ç›®çš„ã«åˆã†ãªã‚‰ã°ã€ä»£ã‚ã‚Šã« :func:`abs` ã‚’ä½¿ã£ã¦æµ®å‹•å°æ•°ç‚¹ã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:380
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int."
msgstr "æ•´æ•°ã®é™¤ç®—ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚çµæœã®å‹ã¯æ•´æ•°å‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ãŒã€çµæœã®å€¤ã¯æ•´æ•°ã§ã™ã€‚"

#: ../../library/stdtypes.rst:384
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã¯ã€æ–‡å­—åˆ— \"nan\" ã¨ \"inf\" ã‚’ã€å¿…è¦ãªã‚‰æ¥é ­è¾ \"+\" ã¾ãŸã¯ \"-\" ã¨å…±ã«ã€éæ•° (Not a Number (NaN)) ã‚„æ­£ã€è² ã®ç„¡é™å¤§ã¨ã—ã¦å—ã‘ä»˜ã‘ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:390
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr "Python ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨€èªä¸€èˆ¬ã§ãã†ã§ã‚ã‚‹ã‚ˆã†ã«ã€ ``pow(0, 0)`` ãŠã‚ˆã³ ``0 ** 0`` ã‚’ ``1`` ã¨å®šç¾©ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:393
msgid ""
"All :class:`numbers.Real` types (:class:`int`, :class:`long`, and "
":class:`float`) also include the following operations:"
msgstr "å…¨ã¦ã® :class:`numbers.Real` å‹ (:class:`int`, :class:`long`,ãŠã‚ˆã³ã€ :class:`float`) ã¯ä»¥ä¸‹ã®æ¼”ç®—ã‚’å«ã¿ã¾ã™ã€‚ :"

#: ../../library/stdtypes.rst:399
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../../library/stdtypes.rst:399
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* ã‚’ :class:`~numbers.Integral` (æ•´æ•°) ã«åˆ‡ã‚Šæ¨ã¦ã¾ã™"

#: ../../library/stdtypes.rst:402
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../../library/stdtypes.rst:402
msgid ""
"*x* rounded to *n* digits, rounding ties away from zero. If *n* is omitted, "
"it defaults to 0."
msgstr "*x* ã‚’ *n* æ¡ã«ä¸¸ã‚ã¾ã™ã€‚ä¸¸ã‚æ–¹ã¯å››æ¨äº”å…¥ã§ã™ã€‚ *n* ãŒçœç•¥ã•ã‚Œã‚Œã° 0 ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ãªã‚Šã¾ã™ã€‚(--è¨³æ³¨: Python 3 ã¨ä»•æ§˜ãŒé•ã†ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚1.5 ã¨ 2.5 ã® round ã¯ã€Python 2 ã§ã¯ãã‚Œãã‚Œ 2ã€3 ã¨ãªã‚Šã€Python 3 ã§ã¯ 2ã€2 ã¨ãªã‚Šã¾ã™ã€‚å¾Œè€…ã®ä¸¸ã‚ã¯ .5 ã‚’ä¸¸ã‚ã‚‹éš›ã«å¶æ•°ã«ãªã‚‹æ–¹ã¸ä¸¸ã‚ã‚‹ã®ã§ã€ã€Œå¶æ•°ä¸¸ã‚ã€ã¨è¨€ã„ã¾ã™ã€‚--)"

#: ../../library/stdtypes.rst:406
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../../library/stdtypes.rst:406
msgid "the greatest integer as a float <= *x*"
msgstr "*x* ä»¥ä¸‹ã®æœ€å¤§ã®æ•´æ•°ã‚’æµ®å‹•å°æ•°ç‚¹æ•°ã¨ã—ã¦è¿”ã—ã¾ã™"

#: ../../library/stdtypes.rst:409
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../../library/stdtypes.rst:409
msgid "the least integer as a float >= *x*"
msgstr "*x* ä»¥ä¸Šã®æœ€å°ã®æ•´æ•°ã‚’æµ®å‹•å°æ•°ç‚¹æ•°ã¨ã—ã¦è¿”ã—ã¾ã™"

#: ../../library/stdtypes.rst:419
msgid "Bitwise Operations on Integer Types"
msgstr "æ•´æ•°å‹ã«ãŠã‘ã‚‹ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—"

#: ../../library/stdtypes.rst:433
msgid ""
"Bitwise operations only make sense for integers.  Negative numbers are "
"treated as their 2's complement value (this assumes a sufficiently large "
"number of bits that no overflow occurs during the operation)."
msgstr "ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—ã¯ã€æ•´æ•°ã«å¯¾ã—ã¦ã®ã¿æ„å‘³ãŒã‚ã‚Šã¾ã™ã€‚è² ã®æ•°ã¯ã€ãã® 2 ã®è£œæ•°ã®å€¤ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ (æ¼”ç®—ä¸­ã«ã‚ªãƒ¼ãƒãƒ•ãƒ­ãƒ¼ãŒèµ·ã“ã‚‰ãªã„ã‚ˆã†ã«ååˆ†ãªãƒ“ãƒƒãƒˆæ•°ãŒã‚ã‚‹ã‚‚ã®ã¨ä»®å®šã—ã¾ã™) ã€‚"

#: ../../library/stdtypes.rst:437
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and"
" ``-``)."
msgstr "äºŒé …ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—ã®å„ªå…ˆé †ä½ã¯å…¨ã¦ã€æ•°å€¤æ¼”ç®—ã‚ˆã‚Šã‚‚ä½ãã€æ¯”è¼ƒã‚ˆã‚Šã‚‚é«˜ã„ã§ã™; å˜é …æ¼”ç®— ``~`` ã®å„ªå…ˆé †ä½ã¯ä»–ã®å˜é …æ•°å€¤æ¼”ç®— (``+`` ãŠã‚ˆã³ ``-``) ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/stdtypes.rst:441
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr "ä»¥ä¸‹ã®è¡¨ã§ã¯ã€ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—ã‚’å„ªå…ˆé †ä½ãŒä½ã„é †ã«ä¸¦ã¹ã¦ã„ã¾ã™:"

#: ../../library/stdtypes.rst:446
msgid "``x | y``"
msgstr "``x | y``"

#: ../../library/stdtypes.rst:446
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "*x* ã¨ *y* ã®ãƒ“ãƒƒãƒˆå˜ä½ :dfn:`è«–ç†å’Œ`"

#: ../../library/stdtypes.rst:449
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../../library/stdtypes.rst:449
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "*x* ã¨ *y* ã®ãƒ“ãƒƒãƒˆå˜ä½ :dfn:`æ’ä»–çš„è«–ç†å’Œ`"

#: ../../library/stdtypes.rst:452
msgid "``x & y``"
msgstr "``x & y``"

#: ../../library/stdtypes.rst:452
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "*x* ã¨ *y* ã®ãƒ“ãƒƒãƒˆå˜ä½ :dfn:`è«–ç†ç©`"

#: ../../library/stdtypes.rst:455
msgid "``x << n``"
msgstr "``x << n``"

#: ../../library/stdtypes.rst:455
msgid "*x* shifted left by *n* bits"
msgstr "*x* ã® *n* ãƒ“ãƒƒãƒˆå·¦ã‚·ãƒ•ãƒˆ"

#: ../../library/stdtypes.rst:455
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:457
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../../library/stdtypes.rst:457
msgid "*x* shifted right by *n* bits"
msgstr "*x* ã® *n* ãƒ“ãƒƒãƒˆå³ã‚·ãƒ•ãƒˆ"

#: ../../library/stdtypes.rst:457
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../../library/stdtypes.rst:459
msgid "``~x``"
msgstr "``~x``"

#: ../../library/stdtypes.rst:459
msgid "the bits of *x* inverted"
msgstr "*x* ã®ãƒ“ãƒƒãƒˆåè»¢"

#: ../../library/stdtypes.rst:465
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be "
"raised."
msgstr "è² å€¤ã®ã‚·ãƒ•ãƒˆæ•°ã¯ä¸æ­£ã§ã‚ã‚Šã€ :exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:468
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``.  "
"A long integer is returned if the result exceeds the range of plain "
"integers."
msgstr "*n* ãƒ“ãƒƒãƒˆã®å·¦ã‚·ãƒ•ãƒˆã¯ã€ ``pow(2, n)`` ã«ã‚ˆã‚‹ä¹—ç®—ã¨ç­‰ä¾¡ã§ã™ã€‚é€šå¸¸æ•´æ•°ã®ç¯„å›²ã‚’è¶…ãˆã‚‹çµæœã«ãªã‚‹å ´åˆã¯é•·æ•´æ•°ã§è¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:472
msgid "A right shift by *n* bits is equivalent to division by ``pow(2, n)``."
msgstr "*n* ãƒ“ãƒƒãƒˆã®å³ã‚·ãƒ•ãƒˆã¯ã€ ``pow(2, n)`` ã«ã‚ˆã‚‹é™¤ç®—ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/stdtypes.rst:476
msgid "Additional Methods on Integer Types"
msgstr "æ•´æ•°å‹ã«ãŠã‘ã‚‹è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../library/stdtypes.rst:478
msgid ""
"The integer types implement the :class:`numbers.Integral` :term:`abstract "
"base class`. In addition, they provide one more method:"
msgstr "æ•´æ•°å‹ã¯ :class:`numbers.Integral` :term:`abstract base class` ã‚’å®Ÿè£…ã—ã¾ã™ã€‚ã•ã‚‰ã«ã€è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¸€ã¤æä¾›ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:484
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr "æ•´æ•°ã‚’ã€ç¬¦å·ã¨å…ˆé ­ã® 0 ã¯é™¤ã„ã¦äºŒé€²æ³•ã§è¡¨ã™ãŸã‚ã«å¿…è¦ãªãƒ“ãƒƒãƒˆã®æ•°ã‚’è¿”ã—ã¾ã™::"

#: ../../library/stdtypes.rst:493
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then "
"``x.bit_length()`` returns ``0``."
msgstr "æ­£ç¢ºã«ã¯ã€ ``x`` ãŒé 0 ãªã‚‰ã€ ``x.bit_length()`` ã¯ ``2**(k-1) <= abs(x) < 2**k`` ã‚’æº€ãŸã™å”¯ä¸€ã®æ­£ã®æ•´æ•° ``k`` ã§ã™ã€‚åŒæ§˜ã«ã€ ``abs(x)`` ãŒååˆ†å°ã•ãã¦å¯¾æ•°ã‚’é©åˆ‡ã«ä¸¸ã‚ã‚‰ã‚Œã‚‹ã¨ãã€ ``k = 1 + int(log(abs(x), 2))`` ã§ã™ã€‚ ``x`` ãŒ 0 ãªã‚‰ã€ ``x.bit_length()`` ã¯ ``0`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:499
msgid "Equivalent to::"
msgstr "æ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/stdtypes.rst:510
msgid "Additional Methods on Float"
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã«å¯¾ã™ã‚‹è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../library/stdtypes.rst:512
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°å‹ã¯ã€ :class:`numbers.Real` æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ (:term:`abstract base class`) ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚æµ®å‹•å°æ•°ç‚¹å‹ã¯ã¾ãŸã€ä»¥ä¸‹ã®è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:517
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float"
" and with a positive denominator.  Raises :exc:`OverflowError` on infinities"
" and a :exc:`ValueError` on NaNs."
msgstr "æ¯”ãŒå…ƒã®æµ®å‹•å°æ•°ç‚¹æ•°ã¨ã¡ã‚‡ã†ã©åŒã˜ã§åˆ†æ¯ãŒæ­£ã§ã‚ã‚‹ã€ä¸€å¯¾ã®æ•´æ•°ã‚’è¿”ã—ã¾ã™ã€‚ç„¡é™å¤§ã«å¯¾ã—ã¦ã¯ :exc:`OverflowError` ã‚’ã€éæ•° (NaN) ã«å¯¾ã—ã¦ã¯ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:526
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒæœ‰é™ã®æ•´æ•°å€¤ãªã‚‰ ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™::"

#: ../../library/stdtypes.rst:536
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr "16 é€²è¡¨è¨˜ã®æ–‡å­—åˆ—ã¸ã€ã¾ãŸã¯ã€ 16 é€²è¡¨è¨˜ã‹ã‚‰ã®å¤‰æ›ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹äºŒã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚ Python ã®æµ®å‹•å°æ•°ç‚¹æ•°ã¯å†…éƒ¨çš„ã«ã¯2é€²æ•°ã§ä¿æŒã•ã‚Œã‚‹ã®ã§ã€æµ®å‹•å°æ•°ç‚¹æ•°ã® *10é€²æ•°* ã¸ã¾ãŸã¯ *10é€²æ•°* ã‹ã‚‰å¤‰æ›ã«ã¯è‹¥å¹²ã®ä¸¸ã‚èª¤å·®ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã«å¯¾ã—ã€16 é€²è¡¨è¨˜ã§ã¯ã€æµ®å‹•å°æ•°ç‚¹æ•°ã‚’æ­£ç¢ºã«è¡¨ç¾ã§ãã¾ã™ã€‚ã“ã‚Œã¯ãƒ‡ãƒãƒƒã‚°ã®ã¨ãã‚„ã€æ•°å­¦çš„ãªç”¨é€” (numerical work) ã«ä¾¿åˆ©ã§ã—ã‚‡ã†ã€‚"

#: ../../library/stdtypes.rst:547
msgid ""
"Return a representation of a floating-point number as a hexadecimal string."
"  For finite floating-point numbers, this representation will always include"
" a leading ``0x`` and a trailing ``p`` and exponent."
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã® 16 é€²æ–‡å­—åˆ—è¡¨ç¾ã‚’è¿”ã—ã¾ã™ã€‚æœ‰é™ã®æµ®å‹•å°æ•°ç‚¹æ•°ã«å¯¾ã—ã€ã“ã®è¡¨ç¾ã¯å¸¸ã« ``0x`` ã§å§‹ã¾ã‚Š ``p`` ã¨æŒ‡æ•°ãŒç¶šãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:557
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr "16 é€²æ–‡å­—åˆ—è¡¨ç¾ *s* ã§è¡¨ã•ã‚Œã‚‹ã€æµ®å‹•å°æ•°ç‚¹æ•°ã‚’è¿”ã™ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚æ–‡å­—åˆ— *s* ã¯ã€å‰ã‚„å¾Œã«ãƒ›ãƒ¯ã‚¤ãƒˆã‚¹ãƒšãƒ¼ã‚¹ã‚’å«ã‚“ã§ã„ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:564
msgid ""
"Note that :meth:`float.hex` is an instance method, while "
":meth:`float.fromhex` is a class method."
msgstr ":meth:`float.fromhex` ã¯ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ãŒã€ :meth:`float.hex` ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:567
msgid "A hexadecimal string takes the form::"
msgstr "16 é€²æ–‡å­—åˆ—è¡¨ç¾ã¯ä»¥ä¸‹ã®æ›¸å¼ã¨ãªã‚Šã¾ã™::"

#: ../../library/stdtypes.rst:571
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and"
" there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2"
" of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted"
" by :meth:`float.fromhex`."
msgstr "``sign`` ã¯å¿…é ˆã§ã¯ãªãã€ ``+`` ã¨ ``-`` ã®ã©ã¡ã‚‰ã‹ã§ã™ã€‚ ``integer`` ã¨ ``fraction`` ã¯ 16 é€²æ•°ã®æ–‡å­—åˆ—ã§ã€ ``exponent`` ã¯ 10 é€²æ•°ã§ç¬¦å·ã‚‚ã¤ã‘ã‚‰ã‚Œã¾ã™ã€‚å¤§æ–‡å­—ãƒ»å°æ–‡å­—ã¯åŒºåˆ¥ã•ã‚Œãšã€æœ€ä½ã§ã‚‚ 1 ã¤ã® 16 é€²æ•°æ–‡å­—ã‚’æ•´æ•°éƒ¨ã‚‚ã—ãã¯å°æ•°éƒ¨ã«å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®åˆ¶é™ã¯ C99 è¦æ ¼ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ 6.4.4.2 ã§è¦å®šã•ã‚Œã¦ã„ã¦ã€ Java 1.5 ä»¥é™ã§ã‚‚ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ç‰¹ã«ã€ :meth:`float.hex` ã®å‡ºåŠ›ã¯ C ã‚„ Java ã‚³ãƒ¼ãƒ‰ä¸­ã§ã€æµ®å‹•å°æ•°ç‚¹æ•°ã® 16 é€²è¡¨è¨˜ã¨ã—ã¦å½¹ã«ç«‹ã¤ã§ã—ã‚‡ã†ã€‚ã¾ãŸã€ C ã® ``%a`` æ›¸å¼ã‚„ã€ Java ã® ``Double.toHexString`` ã§æ›¸ãã ã•ã‚ŒãŸæ–‡å­—åˆ—ã¯ :meth:`float.fromhex` ã§å—ã‘ä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:584
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr "ãªãŠã€æŒ‡æ•°éƒ¨ã¯ 16 é€²æ•°ã§ã¯ãªã 10 é€²æ•°ã§æ›¸ã‹ã‚Œã€ä¿‚æ•°ã«æ›ã‘ã‚‰ã‚Œã‚‹ 2 ã®ç´¯ä¹—ã‚’ä¸ãˆã¾ã™ã€‚ä¾‹ãˆã°ã€16 é€²æ–‡å­—åˆ— ``0x3.a7p10`` ã¯æµ®å‹•å°æ•°ç‚¹æ•° ``(3 + 10./16 + 7./16**2) * 2.0**10`` ã™ãªã‚ã¡ ``3740.0`` ã‚’è¡¨ã—ã¾ã™::"

#: ../../library/stdtypes.rst:594
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr "é€†å¤‰æ›ã‚’ ``3740.0`` ã«é©ç”¨ã™ã‚‹ã¨ã€åŒã˜æ•°ã‚’è¡¨ã™ç•°ãªã‚‹ 16 é€²æ–‡å­—åˆ—è¡¨ç¾ã‚’è¿”ã—ã¾ã™::"

#: ../../library/stdtypes.rst:604
msgid "Iterator Types"
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿å‹"

#: ../../library/stdtypes.rst:614
msgid ""
"Python supports a concept of iteration over containers.  This is implemented"
" using two distinct methods; these are used to allow user-defined classes to"
" support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr "Python ã¯ã‚³ãƒ³ãƒ†ãƒŠã§ã®åå¾©å‡¦ç†ã®æ¦‚å¿µã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã“ã®æ¦‚å¿µã¯ 2 ã¤ã®åˆ¥ã€…ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™; ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ãƒ¦ãƒ¼ã‚¶å®šç¾©ã®ã‚¯ãƒ©ã‚¹ã§åå¾©ã‚’è¡Œãˆã‚‹ã‚ˆã†ã«ã§ãã¾ã™ã€‚å¾Œã«è©³ã—ãè¿°ã¹ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€å¿…ãšåå¾©å‡¦ç†ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:619
msgid ""
"One method needs to be defined for container objects to provide iteration "
"support:"
msgstr "ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åå¾©å‡¦ç†ã‚’ã‚µãƒãƒ¼ãƒˆã•ã›ã‚‹ãŸã‚ã«ã¯ã€ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“:"

#: ../../library/stdtypes.rst:626
msgid ""
"Return an iterator object.  The object is required to support the iterator "
"protocol described below.  If a container supports different types of "
"iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the "
":c:member:`~PyTypeObject.tp_iter` slot of the type structure for Python "
"objects in the Python/C API."
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¾Œè¿°ã™ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã‚‚ã—ã‚³ãƒ³ãƒ†ãƒŠãŒç•°ãªã‚‹å‹ã®åå¾©å‡¦ç†ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãªã‚‰ã€ãã‚Œã‚‰ã®åå¾©å‡¦ç†æ¯ã«è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ (è¤‡æ•°ã®å½¢å¼ã®åå¾©å‡¦ç†ã‚’æä¾›ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¾‹ã¨ã—ã¦ã€å¹…å„ªå…ˆæ¢ç´¢ã¨æ·±ã•å„ªå…ˆæ¢ç´¢ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹æœ¨æ§‹é€ ãŒæŒ™ã’ã‚‰ã‚Œã¾ã™)ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ Python/C API ã§ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹æ§‹é€ ä½“ã® :c:member:`~PyTypeObject.tp_iter` ã‚¹ãƒ­ãƒƒãƒˆã«å¯¾å¿œã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:635
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã¯ä»¥ä¸‹ã® 2 ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ 2 ã¤åˆã‚ã›ã¦ :dfn:`ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«` ã‚’æˆã—ã¾ã™:"

#: ../../library/stdtypes.rst:641
msgid ""
"Return the iterator object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and "
":keyword:`in` statements. This method corresponds to the "
":c:member:`~PyTypeObject.tp_iter` slot of the type structure for Python "
"objects in the Python/C API."
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚³ãƒ³ãƒ†ãƒŠã¨ã‚¤ãƒ† ãƒ¬ãƒ¼ã‚¿ã®ä¸¡æ–¹ã‚’ :keyword:`for` ãŠã‚ˆã³ :keyword:`in` æ–‡ã§ä½¿ãˆã‚‹ã‚ˆã†ã« ã™ã‚‹ãŸã‚ã«å¿…è¦ã§ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ Python/C API ã«ãŠã„ã¦ Python ã‚ª ãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã™å‹æ§‹é€ ä½“ã® :c:member:`~PyTypeObject.tp_iter` ã‚¹ãƒ­ãƒƒãƒˆã«å¯¾å¿œã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:649
msgid ""
"Return the next item from the container.  If there are no further items, "
"raise the :exc:`StopIteration` exception.  This method corresponds to the "
":c:member:`~PyTypeObject.tp_iternext` slot of the type structure for Python "
"objects in the Python/C API."
msgstr "ã‚³ãƒ³ãƒ†ãƒŠã®æ¬¡ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—ãã‚Œä»¥ä¸Šã‚¢ã‚¤ãƒ†ãƒ ç„¡ã‘ã‚Œã° :exc:`StopIteration` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚ ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ Python/C APIã§ã®Pythonã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹æ§‹é€ ä½“ã® :c:member:`~PyTypeObject.tp_iternext` ã‚¹ãƒ­ãƒƒãƒˆã«å¯¾å¿œã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:654
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized forms."
"  The specific types are not important beyond their implementation of the "
"iterator protocol."
msgstr "Python ã§ã¯ã€ã„ãã¤ã‹ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã¯ä¸€èˆ¬ã®ãŠã‚ˆã³ç‰¹æ®Šãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã€è¾æ›¸å‹ã€ãã—ã¦ä»–ã®ã•ã‚‰ã«ç‰¹æ®ŠåŒ–ã•ã‚ŒãŸå½¢å¼ã«æ¸¡ã‚‹åå¾©ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ç‰¹æ®Šå‹ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®å®Ÿè£…ä»¥å¤–ã¯é‡è¦ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:659
msgid ""
"The intention of the protocol is that once an iterator's "
":meth:`~iterator.next` method raises :exc:`StopIteration`, it will continue "
"to do so on subsequent calls. Implementations that do not obey this property"
" are deemed broken.  (This constraint was added in Python 2.3; in Python "
"2.2, various iterators are broken according to this rule.)"
msgstr "ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã® :meth:`~iterator.next` ãƒ¡ã‚½ãƒƒãƒ‰ãŒä¸€æ—¦ :exc:`StopIteration` ã‚’é€å‡ºã—ãŸãªã‚‰ã€ä»¥é™ã®å‘¼ã³å‡ºã—ã§ã‚‚ä¾‹å¤–ã‚’é€å‡ºã—ç¶šã‘ã‚‹ã“ã¨ã‚’æœŸå¾…ã—ã¾ã™ã€‚ã“ã®ç‰¹æ€§ã«å¾“ã‚ãªã„å®Ÿè£…ã¯å£Šã‚Œã¦ã„ã‚‹ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚(ã“ã®åˆ¶ç´„ã¯ Python 2.3 ã§è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚Python 2.2 ã§ã¯è‰²ã€…ãªã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒã€ã“ã®ãƒ«ãƒ¼ãƒ«ã«ã‚ˆã‚Œã°å£Šã‚Œã¦ã„ã¾ã™ã€‚)"

#: ../../library/stdtypes.rst:669
msgid "Generator Types"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å‹"

#: ../../library/stdtypes.rst:671
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`~iterator.__iter__` "
"and :meth:`~iterator.next` methods.  More information about generators can "
"be found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr "Python ã«ãŠã‘ã‚‹ :term:`generator` (ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿) ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®Ÿè£…ã™ã‚‹ä¾¿åˆ©ãªæ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`__iter__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚Œã°ã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :meth:`~iterator.__iter__` ãŠã‚ˆã³ :meth:`~iterator.next` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã™ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (å³å¯†ã«ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) ã‚’è‡ªå‹•çš„ã«è¿”ã—ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã«é–¢ã™ã‚‹è©³ç´°ãªæƒ…å ±ã¯ã€ :ref:`yield å¼ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ <yieldexpr>` ã«ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:682
msgid ""
"Sequence Types --- :class:`str`, :class:`unicode`, :class:`list`, "
":class:`tuple`, :class:`bytearray`, :class:`buffer`, :class:`xrange`"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ --- :class:`str`, :class:`unicode`, :class:`list`, :class:`tuple`, :class:`bytearray`, :class:`buffer`, :class:`xrange`"

#: ../../library/stdtypes.rst:684
msgid ""
"There are seven sequence types: strings, Unicode strings, lists, tuples, "
"bytearrays, buffers, and xrange objects."
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã«ã¯ 7 ã¤ã‚ã‚Šã¾ã™: æ–‡å­—åˆ—ã€Unicode æ–‡å­—åˆ—ã€ãƒªã‚¹ãƒˆã€ã‚¿ãƒ—ãƒ«ã€ã€ãƒã‚¤ãƒˆé…åˆ— (bytearray)ã€ãƒãƒƒãƒ•ã‚¡ã€ãã—ã¦ xrange ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/stdtypes.rst:687
msgid ""
"For other containers see the built in :class:`dict` and :class:`set` "
"classes, and the :mod:`collections` module."
msgstr "ä»–ã®ã‚³ãƒ³ãƒ†ãƒŠå‹ã«ã¤ã„ã¦ã¯ã€çµ„ã¿è¾¼ã¿ã‚¯ãƒ©ã‚¹ã® :class:`dict` ãŠã‚ˆã³ :class:`set` ã‚’å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:701
msgid ""
"String literals are written in single or double quotes: ``'xyzzy'``, "
"``\"frobozz\"``.  See :ref:`strings` for more about string literals. Unicode"
" strings are much like strings, but are specified in the syntax using a "
"preceding ``'u'`` character: ``u'abc'``, ``u\"def\"``. In addition to the "
"functionality described here, there are also string-specific methods "
"described in the :ref:`string-methods` section. Lists are constructed with "
"square brackets, separating items with commas: ``[a, b, c]``. Tuples are "
"constructed by the comma operator (not within square brackets), with or "
"without enclosing parentheses, but an empty tuple must have the enclosing "
"parentheses, such as ``a, b, c`` or ``()``.  A single item tuple must have a"
" trailing comma, such as ``(d,)``."
msgstr "æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¯ ``'xyzzy'`` , ``\"frobozz\"`` ã¨ã„ã£ãŸã‚ˆã†ã«ã€å˜å¼•ç”¨ç¬¦ã¾ãŸã¯äºŒé‡å¼•ç”¨ç¬¦ã®ä¸­ã«æ›¸ã‹ã‚Œã¾ã™ã€‚æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«ã¤ã„ã¦ã®è©³ç´°ã¯ã€ :ref:`strings` ã‚’å‚ç…§ä¸‹ã•ã„ã€‚ Unicode æ–‡å­—åˆ—ã¯ã»ã¨ã‚“ã©æ–‡å­—åˆ—ã¨åŒã˜ã§ã™ãŒã€ ``u'abc'`` , ``u\"def\"`` ã¨ã„ã£ãŸã‚ˆã†ã«å…ˆé ­ã«æ–‡å­— ``'u'`` ã‚’ä»˜ã‘ã¦æŒ‡å®šã—ã¾ã™ã€‚ãƒªã‚¹ãƒˆã¯ ``[a, b, c]`` ã®ã‚ˆã†ã«è¦ç´ ã‚’ã‚³ãƒ³ãƒã§åŒºåˆ‡ã‚Šè§’æ‹¬å¼§ã§å›²ã£ã¦ç”Ÿæˆã—ã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã¯ ``a, b, c`` ã®ã‚ˆã†ã«ã‚³ãƒ³ãƒæ¼”ç®—å­ã§åŒºåˆ‡ã£ã¦ç”Ÿæˆã—ã¾ã™ (è§’æ‹¬å¼§ã®ä¸­ã«ã¯å…¥ã‚Œã¾ã›ã‚“)ã€‚ä¸¸æ‹¬å¼§ã§å›²ã£ã¦ã‚‚å›²ã‚ãªãã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ãŒã€ç©ºã®ã‚¿ãƒ—ãƒ«ã¯ ``()`` ã®ã‚ˆã†ã«ä¸¸æ‹¬å¼§ã§å›²ã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚è¦ç´ ãŒä¸€ã¤ã®ã‚¿ãƒ—ãƒ«ã§ã¯ã€ä¾‹ãˆã° ``(d,)`` ã®ã‚ˆã†ã«ã€è¦ç´ ã®å¾Œã‚ã«ã‚³ãƒ³ãƒã‚’ã¤ã‘ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:713
msgid ""
"Bytearray objects are created with the built-in function :func:`bytearray`."
msgstr "ãƒã‚¤ãƒˆé…åˆ—ã¯ã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`bytearray` ã§æ§‹æˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:715
msgid ""
"Buffer objects are not directly supported by Python syntax, but can be "
"created by calling the built-in function :func:`buffer`.  They don't support"
" concatenation or repetition."
msgstr "ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ Python ã®æ§‹æ–‡ä¸Šã§ã¯ç›´æ¥ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ãŒã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`buffer` ã§ç”Ÿæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµåˆã‚„åå¾©ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:719
msgid ""
"Objects of type xrange are similar to buffers in that there is no specific "
"syntax to create them, but they are created using the :func:`xrange` "
"function.  They don't support slicing, concatenation or repetition, and "
"using ``in``, ``not in``, :func:`min` or :func:`max` on them is inefficient."
msgstr "xrange ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã®ç‰¹æ®Šãªæ§‹æ–‡ãŒãªã„ç‚¹ã§ãƒãƒƒãƒ•ã‚¡ã«ä¼¼ã¦ã„ã¦ã€é–¢æ•° :func:`xrange` ã§ç”Ÿæˆã—ã¾ã™ã€‚ xrange ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¹ãƒ©ã‚¤ã‚¹ã€çµåˆã€åå¾©ã‚’ã‚µãƒãƒ¼ãƒˆã›ãšã€ ``in`` , ``not in`` , :func:`min` ã¾ãŸã¯ :func:`max` ã¯åŠ¹ç‡çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:724
msgid ""
"Most sequence types support the following operations.  The ``in`` and ``not "
"in`` operations have the same priorities as the comparison operations.  The "
"``+`` and ``*`` operations have the same priority as the corresponding "
"numeric operations. [3]_ Additional methods are provided for :ref:`typesseq-"
"mutable`."
msgstr "ã»ã¨ã‚“ã©ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã¯ä»¥ä¸‹ã®æ¼”ç®—æ“ä½œã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ ``in`` ãŠã‚ˆã³ ``not in`` ã¯æ¯”è¼ƒæ¼”ç®—ã¨ãŠãªã˜å„ªå…ˆåº¦ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ ``+`` ãŠã‚ˆã³ ``*`` ã¯å¯¾å¿œã™ã‚‹æ•°å€¤æ¼”ç®—ã¨ãŠãªã˜å„ªå…ˆåº¦ã§ã™ã€‚ [3]_ :ref:`typesseq-mutable` ã§è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:729
msgid ""
"This table lists the sequence operations sorted in ascending priority. In "
"the table, *s* and *t* are sequences of the same type; *n*, *i* and *j* are "
"integers:"
msgstr "ä»¥ä¸‹ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã®æ¼”ç®—ã‚’å„ªå…ˆåº¦ã®ä½ã„ã‚‚ã®ã‹ã‚‰é †ã«æŒ™ã’ãŸã‚‚ã®ã§ã™ã€‚ãƒ†ãƒ¼ãƒ–ãƒ«å†…ã® *s* ãŠã‚ˆã³ *t* ã¯åŒã˜å‹ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã™; *n* , *i* ãŠã‚ˆã³ *j* ã¯æ•´æ•°ã§ã™:"

#: ../../library/stdtypes.rst:735
msgid "``x in s``"
msgstr "``x in s``"

#: ../../library/stdtypes.rst:735
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "*s* ã®ã‚ã‚‹è¦ç´ ãŒ *x* ã¨ç­‰ã—ã‘ã‚Œã° ``True`` , ãã†ã§ãªã‘ã‚Œã° ``False``"

#: ../../library/stdtypes.rst:738
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../../library/stdtypes.rst:738
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "*s* ã®ã‚ã‚‹è¦ç´ ãŒ *x* ã¨ç­‰ã—ã‘ã‚Œã° ``False``, ãã†ã§ãªã‘ã‚Œã° ``True``"

#: ../../library/stdtypes.rst:741
msgid "``s + t``"
msgstr "``s + t``"

#: ../../library/stdtypes.rst:741
msgid "the concatenation of *s* and *t*"
msgstr "*s* ã¨ *t* ã®çµåˆ"

#: ../../library/stdtypes.rst:744
msgid "``s * n, n * s``"
msgstr "``s * n`` ã¾ãŸã¯ ``n * s``"

#: ../../library/stdtypes.rst:744
msgid "equivalent to adding *s* to itself *n* times"
msgstr "*s* è‡ªèº«ã‚’ *n* å›è¶³ã™ã®ã¨åŒã˜"

#: ../../library/stdtypes.rst:747
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../library/stdtypes.rst:747
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*s* ã® 0 ã‹ã‚‰æ•°ãˆã¦ *i* ç•ªç›®ã®è¦ç´ "

#: ../../library/stdtypes.rst:749
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../../library/stdtypes.rst:749
msgid "slice of *s* from *i* to *j*"
msgstr "*s* ã® *i* ã‹ã‚‰ *j* ã¾ã§ã®ã‚¹ãƒ©ã‚¤ã‚¹"

#: ../../library/stdtypes.rst:751
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../../library/stdtypes.rst:751
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "*s* ã® *i* ã‹ã‚‰ *j* ã¾ã§ã€ *k* æ¯ã®ã‚¹ãƒ©ã‚¤ã‚¹"

#: ../../library/stdtypes.rst:751
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../../library/stdtypes.rst:754
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../library/stdtypes.rst:754
msgid "length of *s*"
msgstr "*s* ã®é•·ã•"

#: ../../library/stdtypes.rst:756
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../../library/stdtypes.rst:756
msgid "smallest item of *s*"
msgstr "*s* ã®æœ€å°ã®è¦ç´ "

#: ../../library/stdtypes.rst:758
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../library/stdtypes.rst:758
msgid "largest item of *s*"
msgstr "*s* ã®æœ€å¤§ã®è¦ç´ "

#: ../../library/stdtypes.rst:760
msgid "``s.index(x)``"
msgstr "``s.index(x)``"

#: ../../library/stdtypes.rst:760
msgid "index of the first occurrence of *x* in *s*"
msgstr "*s* ä¸­ã§ *x* ãŒæœ€åˆã«å‡ºç¾ã™ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹"

#: ../../library/stdtypes.rst:763 ../../library/stdtypes.rst:1683
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../library/stdtypes.rst:763
msgid "total number of occurrences of *x* in *s*"
msgstr "*s* ä¸­ã« *x* ãŒå‡ºç¾ã™ã‚‹å›æ•°"

#: ../../library/stdtypes.rst:767
msgid ""
"Sequence types also support comparisons. In particular, tuples and lists are"
" compared lexicographically by comparing corresponding elements. This means "
"that to compare equal, every element must compare equal and the two "
"sequences must be of the same type and have the same length. (For full "
"details see :ref:`comparisons` in the language reference.)"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã¯æ¯”è¼ƒæ¼”ç®—å­ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ç‰¹ã«ã‚¿ãƒ—ãƒ«ã¨ãƒªã‚¹ãƒˆã¯ç›¸å½“ã™ã‚‹è¦ç´ ã«ã‚ˆã‚‹è¾æ›¸ç·¨é›†æ–¹å¼çš„ã«æ¯”è¼ƒã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šã€ç­‰ã—ã„ã¨ã„ã†ã“ã¨ã¯ã€ãµãŸã¤ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã€å‹ãŒåŒã˜ã§ã‚ã‚Šã€å…¨ã¦ã®è¦ç´ ãŒç­‰ã—ã„ã¨ã„ã†ã“ã¨ã§ã™ (è©³ç´°ã¯è¨€èªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã® :ref:`comparisons` ã‚’å‚ç…§ä¸‹ã•ã„) ã€‚"

#: ../../library/stdtypes.rst:790
msgid ""
"When *s* is a string or Unicode string object the ``in`` and ``not in`` "
"operations act like a substring test.  In Python versions before 2.3, *x* "
"had to be a string of length 1. In Python 2.3 and beyond, *x* may be a "
"string of any length."
msgstr "*s* ãŒæ–‡å­—åˆ—ã¾ãŸã¯ Unicode æ–‡å­—åˆ—ã®å ´åˆã€æ¼”ç®—æ“ä½œ ``in`` ãŠã‚ˆã³ ``not in`` ã¯éƒ¨åˆ†æ–‡å­—åˆ—ã®ä¸€è‡´ãƒ†ã‚¹ãƒˆã¨åŒã˜ã‚ˆã†ã«å‹•ä½œã—ã¾ã™ã€‚ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 2.3 ä»¥å‰ã® Python ã§ã¯ã€ *x* ã¯é•·ã• 1 ã®æ–‡å­—åˆ—ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã—ãŸã€‚ Python 2.3 ä»¥é™ã§ã¯ã€ *x* ã¯ã©ã‚“ãªé•·ã•ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:796
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider:"
msgstr "*n* ãŒ ``0`` ä»¥ä¸‹ã®å€¤ã®å ´åˆã€ ``0`` ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ (ã“ã‚Œã¯ *s* ã¨åŒã˜å‹ã®ç©ºã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è¡¨ã—ã¾ã™)ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *s* ã®è¦ç´ ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œãªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„; ã‚³ãƒ”ãƒ¼ã§ã¯ãªãè¦ç´ ã«å¯¾ã™ã‚‹å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒå¢—ãˆã¾ã™ã€‚ã“ã‚Œã¯ Python ã«æ…£ã‚Œã¦ã„ãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒã‚’ã‚ˆãæ‚©ã¾ã›ã¾ã™ã€‚ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’è€ƒãˆã¾ã™:"

#: ../../library/stdtypes.rst:808
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty"
" list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single"
" list. You can create a list of different lists this way:"
msgstr "ã“ã“ã§ã€``[[]]`` ãŒç©ºãƒªã‚¹ãƒˆã‚’å«ã‚€ 1 è¦ç´ ã®ãƒªã‚¹ãƒˆãªã®ã§ã€``[[]] * 3`` ã® 3 è¦ç´ ã¯ã“ã®ä¸€ã¤ã®ç©ºãƒªã‚¹ãƒˆã¸ã®å‚ç…§ã§ã™ã€‚``lists`` ã®ã„ãšã‚Œã‹ã®è¦ç´ ã‚’å¤‰æ›´ã™ã‚‹ã¨ã€ãã®ä¸€ã¤ã®ãƒªã‚¹ãƒˆãŒå¤‰æ›´ã•ã‚Œã¾ã™ã€‚åˆ¥ã€…ã®ãƒªã‚¹ãƒˆã®ãƒªã‚¹ãƒˆã‚’ä½œã‚‹ã«ã¯ã“ã†ã—ã¾ã™::"

#: ../../library/stdtypes.rst:820
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-"
"multidimensional-list`."
msgstr "åˆ¥ã®èª¬æ˜ãŒ FAQ ã‚¨ãƒ³ãƒˆãƒª :ref:`faq-multidimensional-list` ã«ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:824
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*:"
" ``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr "*i* ã¾ãŸã¯ *j* ãŒè² ã®æ•°ã®å ´åˆã€ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®æœ«ç«¯ã‹ã‚‰ã®ç›¸å¯¾ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã«ãªã‚Šã¾ã™: ``len(s) + i`` ã¾ãŸã¯ ``len(s) + j`` ãŒä»£ã‚ã‚Šã«ä½¿ã‚ã‚Œã¾ã™ã€‚\nãŸã ã— ``-0`` ã¯ã‚„ã¯ã‚Š ``0`` ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:829
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal"
" to *j*, the slice is empty."
msgstr "*s* ã® *i* ã‹ã‚‰ *j* ã¸ã®ã‚¹ãƒ©ã‚¤ã‚¹ã¯ ``i <= k < j`` ã¨ãªã‚‹ã‚ˆã†ãªã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ *k* ã‚’æŒã¤è¦ç´ ã‹ã‚‰ãªã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦å®šç¾©ã•ã‚Œã¾ã™ã€‚ *i* ã¾ãŸã¯ *j* ãŒ ``len(s)`` ã‚ˆã‚Šã‚‚å¤§ãã„å ´åˆã€ ``len(s)`` ã‚’ä½¿ã„ã¾ã™ã€‚ *i* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ ``None`` ã ã£ãŸå ´åˆã€ ``0`` ã‚’ä½¿ã„ã¾ã™ã€‚ *j* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ ``None`` ã ã£ãŸå ´åˆã€ ``len(s)`` ã‚’ä½¿ã„ã¾ã™ã€‚ *i* ãŒ *j* ä»¥ä¸Šã®å ´åˆã€ã‚¹ãƒ©ã‚¤ã‚¹ã¯ç©ºã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:836
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of"
" items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other"
" words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is"
" ``None``, it is treated like ``1``."
msgstr "*s* ã®ã€Œ *i* ã‹ã‚‰ *j* ã¾ã§ã§ã‚¹ãƒ†ãƒƒãƒ—ãŒ *k* ã®ã‚¹ãƒ©ã‚¤ã‚¹ã€ã¯ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ ``x = i + n*k`` ï¼ˆãŸã ã— n ã¯ ``0 <= n < (j-i)/k`` ã‚’æº€ãŸã™ä»»æ„ã®æ•´æ•°ï¼‰ã‚’æŒã¤è¦ç´ ã‹ã‚‰ãªã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦å®šç¾©ã•ã‚Œã¾ã™ã€‚è¨€ã„æ›ãˆã‚‹ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯ ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` ã¨ç¶šãã€ *j* ã«é”ã—ãŸã¨ã“ã‚ã§ã‚¹ãƒˆãƒƒãƒ—ã—ã¾ã™ (ãŸã ã— *j* ã¯å«ã¿ã¾ã›ã‚“)ã€‚ *k* ãŒæ­£ã®æ•°ã§ã‚ã‚‹å ´åˆã€ *i* ã¾ãŸã¯ *j* ãŒ ``len(s)`` ã‚ˆã‚Šå¤§ãã‘ã‚Œã° ``len(s)`` ã‚’ä»£ã‚ã‚Šã«ä½¿ç”¨ã—ã¾ã™ã€‚ *k* ãŒè² ã®æ•°ã§ã‚ã‚‹å ´åˆã€ *i* ã¾ãŸã¯ *j* ãŒ ``len(s) - 1`` ã‚ˆã‚Šå¤§ãã‘ã‚Œã° ``len(s) - 1`` ã‚’ä»£ã‚ã‚Šã«ä½¿ç”¨ã—ã¾ã™ã€‚ *i* ã¾ãŸã¯ *j* ã‚’çœç•¥ã¾ãŸã¯ ``None`` ã‚’æŒ‡å®šã™ã‚‹ã¨ã€ \"ç«¯\" (ã©ã¡ã‚‰ã®ç«¯ã‹ã¯ *k* ã®ç¬¦å·ã«ä¾å­˜) ã®å€¤ã‚’ä»£ã‚ã‚Šã«ä½¿ç”¨ã—ã¾ã™ã€‚ãªãŠ *k* ã¯ã‚¼ãƒ­ã«ã§ããªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã¾ãŸ *k* ã« ``None`` ã‚’æŒ‡å®šã™ã‚‹ã¨ã€ ``1`` ãŒæŒ‡å®šã•ã‚ŒãŸã‚‚ã®ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:849
msgid ""
"If *s* and *t* are both strings, some Python implementations such as CPython"
" can usually perform an in-place optimization for assignments of the form "
"``s = s + t`` or ``s += t``.  When applicable, this optimization makes "
"quadratic run-time much less likely.  This optimization is both version and "
"implementation dependent.  For performance sensitive code, it is preferable "
"to use the :meth:`str.join` method which assures consistent linear "
"concatenation performance across versions and implementations."
msgstr "*s* ã¨ *t* ã®ä¸¡è€…ãŒæ–‡å­—åˆ—ã§ã‚ã‚‹ã¨ãã€ CPython ã®ã‚ˆã†ãªã„ãã¤ã‹ã® Python å®Ÿè£…ã§ã¯ã€ ``s = s + t`` ã‚„ ``s += t`` ã¨ã„ã†æ›¸å¼ã§ä»£å…¥ã‚’ã™ã‚‹ã®ã« in-place optimization ãŒåƒãã¾ã™ã€‚ã“ã®ã‚ˆã†ãªæ™‚ã€æœ€é©åŒ–ã¯äºŒä¹—ã®å®Ÿè¡Œæ™‚é–“ã®ä½æ¸›ã‚’ã‚‚ãŸã‚‰ã—ã¾ã™ã€‚ã“ã®æœ€é©åŒ–ã¯ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚„å®Ÿè£…ã«ä¾å­˜ã—ã¾ã™ã€‚å®Ÿè¡ŒåŠ¹ç‡ãŒå¿…è¦ãªã‚³ãƒ¼ãƒ‰ã§ã¯ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨å®Ÿè£…ãŒå¤‰ã‚ã£ã¦ã‚‚ã€é€£çµã®ç·šå½¢çš„å®Ÿè¡ŒåŠ¹ç‡ã‚’ä¿è¨¼ã™ã‚‹ :meth:`str.join` ã‚’ä½¿ã†ã®ãŒã‚ˆã‚Šæœ›ã¾ã—ã„ã§ã—ã‚‡ã†ã€‚"

#: ../../library/stdtypes.rst:857
msgid "Formerly, string concatenation never occurred in-place."
msgstr "ä»¥å‰ã€æ–‡å­—åˆ—ã®é€£çµã¯in-placeã§å†å¸°ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ."

#: ../../library/stdtypes.rst:864
msgid "String Methods"
msgstr "æ–‡å­—åˆ—ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../library/stdtypes.rst:868
msgid ""
"Below are listed the string methods which both 8-bit strings and Unicode "
"objects support.  Some of them are also available on :class:`bytearray` "
"objects."
msgstr "8-bit æ–‡å­—åˆ—ã¨ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã©ã¡ã‚‰ã‚‚ä»¥ä¸‹ã«æŒ™ã’ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚ã“ã®ä¸­ã«ã¯ã€ :class:`bytearray` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ä½¿ãˆã‚‹ã‚‚ã®ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:872
msgid ""
"In addition, Python's strings support the sequence type methods described in"
" the :ref:`typesseq` section. To output formatted strings use template "
"strings or the ``%`` operator described in the :ref:`string-formatting` "
"section. Also, see the :mod:`re` module for string functions based on "
"regular expressions."
msgstr "ã•ã‚‰ã«ã€ Python ã®æ–‡å­—åˆ—ã¯ :ref:`typesseq` ã«è¨˜è¼‰ã•ã‚Œã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚æ›¸å¼æŒ‡å®šã—ã¦æ–‡å­—åˆ—ã‚’å‡ºåŠ›ã™ã‚‹ãŸã‚ã«ã¯ã€ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ–‡å­—åˆ—ã‚’ä½¿ã†ã‹ã€ :ref:`string-formatting` ã«è¨˜è¼‰ã•ã‚Œã‚‹ ``%`` æ¼”ç®—å­ã‚’ä½¿ã„ã¾ã™ã€‚æ­£è¦è¡¨ç¾ã«åŸºã¥ãæ–‡å­—åˆ—æ“ä½œé–¢æ•°ã«ã¤ã„ã¦ã¯ã€ :mod:`re` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:880
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr "æœ€åˆã®æ–‡å­—ã‚’å¤§æ–‡å­—ã«ã—ã€æ®‹ã‚Šã‚’å°æ–‡å­—ã«ã—ãŸæ–‡å­—åˆ—ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:883 ../../library/stdtypes.rst:1019
#: ../../library/stdtypes.rst:1027 ../../library/stdtypes.rst:1035
#: ../../library/stdtypes.rst:1043 ../../library/stdtypes.rst:1051
#: ../../library/stdtypes.rst:1060 ../../library/stdtypes.rst:1068
#: ../../library/stdtypes.rst:1095 ../../library/stdtypes.rst:1323
#: ../../library/stdtypes.rst:1351 ../../library/stdtypes.rst:1388
msgid "For 8-bit strings, this method is locale-dependent."
msgstr "8ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã§ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ­ã‚±ãƒ¼ãƒ«ä¾å­˜ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:888
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is a space)."
msgstr "*width* ã®é•·ã•ã‚’ã‚‚ã¤ä¸­å¤®å¯„ã›ã•ã‚ŒãŸæ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã«ã¯ *fillchar* ã§æŒ‡å®šã•ã‚ŒãŸå€¤ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã‚¹ãƒšãƒ¼ã‚¹) ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:891 ../../library/stdtypes.rst:1086
#: ../../library/stdtypes.rst:1150
msgid "Support for the *fillchar* argument."
msgstr "å¼•æ•° *fillchar* ã«å¯¾å¿œ."

#: ../../library/stdtypes.rst:897
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr "[*start*, *end*] ã®ç¯„å›²ã«ã€éƒ¨åˆ†æ–‡å­—åˆ— *sub* ãŒé‡è¤‡ã›ãšå‡ºç¾ã™ã‚‹å›æ•°ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *start* ãŠã‚ˆã³ *end* ã¯ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã¨åŒã˜ã‚ˆã†ã«è§£é‡ˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:904
msgid ""
"Decodes the string using the codec registered for *encoding*. *encoding* "
"defaults to the default string encoding.  *errors* may be given to set a "
"different error handling scheme.  The default is ``'strict'``, meaning that "
"encoding errors raise :exc:`UnicodeError`.  Other possible values are "
"``'ignore'``, ``'replace'`` and any other name registered via "
":func:`codecs.register_error`, see section :ref:`codec-base-classes`."
msgstr "codec ã«ç™»éŒ²ã•ã‚ŒãŸæ–‡å­—ã‚³ãƒ¼ãƒ‰ç³» *encoding* ã‚’ä½¿ã£ã¦æ–‡å­—åˆ—ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ *encoding* ã¯æ¨™æº–ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ–‡å­—åˆ—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«ãªã‚Šã¾ã™ã€‚æ¨™æº–ã¨ã¯ç•°ãªã‚‹ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚’è¡Œã†ãŸã‚ã« *errors* ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ¨™æº–ã®ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¯ ``'strict'`` ã§ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã«é–¢ã™ã‚‹ã‚¨ãƒ©ãƒ¼ã¯ :exc:`UnicodeError` ã‚’é€å‡ºã—ã¾ã™ã€‚ä»–ã«åˆ©ç”¨ã§ãã‚‹å€¤ã¯ ``'ignore'``, ``'replace'`` ãŠã‚ˆã³é–¢æ•° :func:`codecs.register_error` ã«ã‚ˆã£ã¦ç™»éŒ²ã•ã‚ŒãŸåå‰ã§ã™ã€‚ã“ã‚Œã«ã¤ã„ã¦ã¯ã‚»ã‚¯ã‚·ãƒ§ãƒ³ :ref:`codec-base-classes` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:913
msgid "Support for other error handling schemes added."
msgstr "ãã®ä»–ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚¹ã‚­ãƒ¼ãƒãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã—ãŸ."

#: ../../library/stdtypes.rst:916 ../../library/stdtypes.rst:936
msgid "Support for keyword arguments added."
msgstr "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®ã‚µãƒãƒ¼ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:921
msgid ""
"Return an encoded version of the string.  Default encoding is the current "
"default string encoding.  *errors* may be given to set a different error "
"handling scheme.  The default for *errors* is ``'strict'``, meaning that "
"encoding errors raise a :exc:`UnicodeError`.  Other possible values are "
"``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'``"
" and any other name registered via :func:`codecs.register_error`, see "
"section :ref:`codec-base-classes`. For a list of possible encodings, see "
"section :ref:`standard-encodings`."
msgstr "æ–‡å­—åˆ—ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ç¾åœ¨ã®æ–‡å­—åˆ—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã™ã€‚æ¨™æº–ã¨ã¯ç•°ãªã‚‹ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚’è¡Œã†ãŸã‚ã« *errors* ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ¨™æº–ã®ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¯ ``'strict'`` ã§ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã«é–¢ã™ã‚‹ã‚¨ãƒ©ãƒ¼ã¯ :exc:`UnicodeError` ã‚’é€å‡ºã—ã¾ã™ã€‚ä»–ã«åˆ©ç”¨ã§ãã‚‹å€¤ã¯ ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` ãŠã‚ˆã³é–¢æ•° :func:`codecs.register_error` ã«ã‚ˆã£ã¦ç™»éŒ²ã•ã‚ŒãŸåå‰ã§ã™ã€‚ã“ã‚Œã«ã¤ã„ã¦ã¯ã‚»ã‚¯ã‚·ãƒ§ãƒ³ :ref:`codec-base-classes` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚åˆ©ç”¨å¯èƒ½ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ä¸€è¦§ã¯ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ :ref:`standard-encodings` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:932
msgid ""
"Support for ``'xmlcharrefreplace'`` and ``'backslashreplace'`` and other "
"error handling schemes added."
msgstr "``'xmlcharrefreplace'``, ``'backslashreplace'`` ãŠã‚ˆã³ãã®ä»–ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚¹ã‚­ãƒ¼ãƒãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã—ãŸ."

#: ../../library/stdtypes.rst:941
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr "æ–‡å­—åˆ—ãŒæŒ‡å®šã•ã‚ŒãŸ *suffix* ã§çµ‚ã‚ã‚‹ãªã‚‰ ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™ã€‚ *suffix* ã¯è¦‹ã¤ã‘ãŸã„è¤‡æ•°ã®æ¥å°¾èªã®ã‚¿ãƒ—ãƒ«ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *start* ãŒã‚ã‚Œã°ã€ãã®ä½ç½®ã‹ã‚‰åˆ¤å®šã‚’å§‹ã‚ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *end* ãŒã‚ã‚Œã°ã€ãã®ä½ç½®ã§æ¯”è¼ƒã‚’æ­¢ã‚ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:946
msgid "Accept tuples as *suffix*."
msgstr "*suffix* ã§ã‚¿ãƒ—ãƒ«ã‚’å—ã‘ä»˜ã‘ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸ."

#: ../../library/stdtypes.rst:952
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current"
" column is set to zero and the string is examined character by character.  "
"If the character is a tab (``\\t``), one or more space characters are "
"inserted in the result until the current column is equal to the next tab "
"position. (The tab character itself is not copied.)  If the character is a "
"newline (``\\n``) or return (``\\r``), it is copied and the current column "
"is reset to zero.  Any other character is copied unchanged and the current "
"column is incremented by one regardless of how the character is represented "
"when printed."
msgstr "æ–‡å­—åˆ—å†…ã®å…¨ã¦ã®ã‚¿ãƒ–æ–‡å­—ãŒ 1 ã¤ä»¥ä¸Šã®ã‚¹ãƒšãƒ¼ã‚¹ã§ç½®æ›ã•ã‚ŒãŸã€æ–‡å­—åˆ—ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ã‚¹ãƒšãƒ¼ã‚¹ã®æ•°ã¯ç¾åœ¨ã®æ¡ (column) ä½ç½®ã¨ *tabsize* ã«ä¾å­˜ã—ã¾ã™ã€‚ã‚¿ãƒ–ä½ç½®ã¯ *tabsize* æ–‡å­—æ¯ã«å­˜åœ¨ã—ã¾ã™ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§ã‚ã‚‹ 8 ã®å ´åˆã€ã‚¿ãƒ–ä½ç½®ã¯ 0, 8, 16 ãªã©ã«ãªã‚Šã¾ã™)ã€‚æ–‡å­—åˆ—ã‚’å±•é–‹ã™ã‚‹ãŸã‚ã€ã¾ãšç¾æ¡ä½ç½®ãŒã‚¼ãƒ­ã«ã‚»ãƒƒãƒˆã•ã‚Œã€æ–‡å­—åˆ—ãŒ 1 æ–‡å­—ãšã¤èª¿ã¹ã‚‰ã‚Œã¾ã™ã€‚æ–‡å­—ãŒã‚¿ãƒ–æ–‡å­— (``\\t``) ã§ã‚ã‚Œã°ã€ç¾æ¡ä½ç½®ãŒæ¬¡ã®ã‚¿ãƒ–ä½ç½®ã¨ä¸€è‡´ã™ã‚‹ã¾ã§ã€1 ã¤ä»¥ä¸Šã®ã‚¹ãƒšãƒ¼ã‚¹ãŒçµæœã®æ–‡å­—åˆ—ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚(ã‚¿ãƒ–æ–‡å­—è‡ªä½“ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã›ã‚“ã€‚) æ–‡å­—ãŒæ”¹è¡Œæ–‡å­— (``\\n`` ã‚‚ã—ãã¯ ``\\r``) ã®å ´åˆã€æ–‡å­—ãŒã‚³ãƒ”ãƒ¼ã•ã‚Œã€ç¾æ¡ä½ç½®ã¯ 0 ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚ãã®ä»–ã®æ–‡å­—ã¯å¤‰æ›´ã•ã‚Œãšã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã€ç¾æ¡ä½ç½®ã¯ã€ãã®æ–‡å­—ã®è¡¨ç¤ºã®ã•ã‚Œæ–¹ (è¨³æ³¨: å…¨è§’ã€åŠè§’ãªã©) ã«é–¢ä¿‚ãªãã€1 ãšã¤å¢—åŠ ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:973
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr "æ–‡å­—åˆ—ã®ã‚¹ãƒ©ã‚¤ã‚¹ ``s[start:end]`` ã«éƒ¨åˆ†æ–‡å­—åˆ— *sub* ãŒå«ã¾ã‚Œã‚‹å ´åˆã€ãã®æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *start* ãŠã‚ˆã³ *end* ã¯ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã¨åŒæ§˜ã«è§£é‡ˆã•ã‚Œã¾ã™ã€‚ *sub* ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ ``-1`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:979
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the "
":keyword:`in` operator::"
msgstr ":meth:`~str.find` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ *sub* ã®ä½ç½®ã‚’çŸ¥ã‚ŠãŸã„ã¨ãã«ã®ã¿ä½¿ã†ã¹ãã§ã™ã€‚ *sub* ãŒéƒ¨åˆ†æ–‡å­—åˆ—ã§ã‚ã‚‹ã‹ã©ã†ã‹ã®ã¿ã‚’èª¿ã¹ã‚‹ã«ã¯ã€ :keyword:`in` æ¼”ç®—å­ã‚’ä½¿ã£ã¦ãã ã•ã„::"

#: ../../library/stdtypes.rst:989
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of"
" the corresponding argument."
msgstr "æ–‡å­—åˆ—ã®æ›¸å¼åŒ–æ“ä½œã‚’è¡Œã„ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™æ–‡å­—åˆ—ã¯é€šå¸¸ã®æ–‡å­—ã€ã¾ãŸã¯ã€ ``{}`` ã§åŒºåˆ‡ã‚‰ã‚ŒãŸç½®æ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å«ã¿ã¾ã™ã€‚ãã‚Œãã‚Œã®ç½®æ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ä½ç½®å¼•æ•°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒŠãƒ³ãƒãƒ¼ã€ã¾ãŸã¯ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®åå‰ã‚’å«ã¿ã¾ã™ã€‚è¿”ã‚Šå€¤ã¯ã€ãã‚Œãã‚Œã®ç½®æ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå¯¾å¿œã™ã‚‹å¼•æ•°ã®æ–‡å­—åˆ—å€¤ã§ç½®æ›ã•ã‚ŒãŸæ–‡å­—åˆ—ã®ã‚³ãƒ”ãƒ¼ã§ã™ã€‚"

#: ../../library/stdtypes.rst:999
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options"
" that can be specified in format strings."
msgstr "æ›¸å¼æŒ‡å®šã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«ã¤ã„ã¦ã¯ã€æ›¸å¼æŒ‡å®šæ–‡å­—åˆ—ã‚’è¦å®šã™ã‚‹ :ref:`formatstrings` ã‚’å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:1002
msgid ""
"This method of string formatting is the new standard in Python 3, and should"
" be preferred to the ``%`` formatting described in :ref:`string-formatting` "
"in new code."
msgstr "ã“ã®æ–‡å­—åˆ—æ›¸å¼æŒ‡å®šã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ Python 3 ã§ã®æ–°ã—ã„æ¨™æº–ã§ã‚ã‚Šã€æ–°ã—ã„ã‚³ãƒ¼ãƒ‰ã§ã¯ã€ :ref:`string-formatting` ã§è¦å®šã•ã‚Œã‚‹ ``%`` ã‚’ä½¿ã£ãŸæ›¸å¼æŒ‡å®šã‚ˆã‚Šå¥½ã¾ã—ã„æ›¸ãæ–¹ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1011
msgid ""
"Like :meth:`find`, but raise :exc:`ValueError` when the substring is not "
"found."
msgstr ":meth:`find` ã¨åŒæ§˜ã§ã™ãŒã€ *sub* ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1016
msgid ""
"Return true if all characters in the string are alphanumeric and there is at"
" least one character, false otherwise."
msgstr "æ–‡å­—åˆ—ä¸­ã®å…¨ã¦ã®æ–‡å­—ãŒè‹±æ•°æ–‡å­—ã§ã€ã‹ã¤ 1 æ–‡å­—ä»¥ä¸Šã‚ã‚‹å ´åˆã«ã¯çœŸã‚’è¿”ã—ã€ãã†ã§ãªã„å ´åˆã¯å½ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1024
msgid ""
"Return true if all characters in the string are alphabetic and there is at "
"least one character, false otherwise."
msgstr "æ–‡å­—åˆ—ä¸­ã®å…¨ã¦ã®æ–‡å­—ãŒè‹±æ–‡å­—ã§ã€ã‹ã¤ 1 æ–‡å­—ä»¥ä¸Šã‚ã‚‹å ´åˆã«ã¯çœŸã‚’è¿”ã—ã€ãã†ã§ãªã„å ´åˆã¯å½ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1032
msgid ""
"Return true if all characters in the string are digits and there is at least"
" one character, false otherwise."
msgstr "æ–‡å­—åˆ—ä¸­ã«æ•°å­—ã—ã‹ãªã„å ´åˆã«ã¯çœŸã‚’è¿”ã—ã€ãã®ä»–ã®å ´åˆã¯å½ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1040
msgid ""
"Return true if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, false otherwise."
msgstr "æ–‡å­—åˆ—ä¸­ã®å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­— [4]_ å…¨ã¦ãŒå°æ–‡å­—ã§ã€ã‹ã¤å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­—ãŒ 1 æ–‡å­—ä»¥ä¸Šã‚ã‚‹ãªã‚‰çœŸã‚’ã€ãã†ã§ãªã‘ã‚Œã°å½ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1048
msgid ""
"Return true if there are only whitespace characters in the string and there "
"is at least one character, false otherwise."
msgstr "æ–‡å­—åˆ—ãŒç©ºç™½æ–‡å­—ã ã‘ã‹ã‚‰ãªã‚Šã€ã‹ã¤ 1 æ–‡å­—ä»¥ä¸Šã‚ã‚‹å ´åˆã«ã¯çœŸã‚’è¿”ã—ã€ãã†ã§ãªã„å ´åˆã¯å½ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1056
msgid ""
"Return true if the string is a titlecased string and there is at least one "
"character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return false "
"otherwise."
msgstr "æ–‡å­—åˆ—ãŒã‚¿ã‚¤ãƒˆãƒ«ã‚±ãƒ¼ã‚¹æ–‡å­—åˆ—ã§ã‚ã‚Šã€ã‹ã¤ 1 æ–‡å­—ä»¥ä¸Šã‚ã‚‹å ´åˆã€ä¾‹ãˆã°å¤§æ–‡å­—ã¯å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ãªã„æ–‡å­—ã®å¾Œã«ã®ã¿ç¶šãã€å°æ–‡å­—ã¯å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­—ã®å¾Œã‚ã«ã®ã¿ç¶šãå ´åˆã«ã¯çœŸã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã„å ´åˆã¯å½ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1065
msgid ""
"Return true if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, false otherwise."
msgstr "æ–‡å­—åˆ—ä¸­ã®å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­— [4]_ å…¨ã¦ãŒå¤§æ–‡å­—ã§ã€ã‹ã¤å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­—ãŒ 1 æ–‡å­—ä»¥ä¸Šã‚ã‚‹ãªã‚‰çœŸã‚’ã€ãã†ã§ãªã‘ã‚Œã°å½ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1073
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. If "
"there is any Unicode object in *iterable*, return a Unicode instead. A "
":exc:`TypeError` will be raised if there are any non-string or non Unicode "
"object values in *iterable*.  The separator between elements is the string "
"providing this method."
msgstr "*ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«* ä¸­ã®æ–‡å­—åˆ—ã‚’çµåˆã—ãŸæ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚\n*iterable* ã« Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚‹å ´åˆã¯ã€ä»£ã‚ã‚Šã« Unicode ã‚’è¿”ã—ã¾ã™ã€‚\næ–‡å­—åˆ—ã§ãªã„ã‚ã‚‹ã„ã¯ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã„å€¤ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ã€ :exc:`TypeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚\nè¦ç´ é–“ã®åŒºåˆ‡ã‚Šæ–‡å­—åˆ—ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã™ã‚‹æ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1082
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is a space).  The original "
"string is returned if *width* is less than or equal to ``len(s)``."
msgstr "é•·ã• *width* ã®å·¦æƒãˆã—ãŸæ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã¯æŒ‡å®šã•ã‚ŒãŸ *fillchar* (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã‚¹ãƒšãƒ¼ã‚¹) ã‚’ä½¿ã£ã¦è¡Œã‚ã‚Œã¾ã™ã€‚ *width* ãŒ ``len(s)`` ä»¥ä¸‹ãªã‚‰ã°ã€å…ƒã®æ–‡å­—åˆ—ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1092
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr "å…¨ã¦ã®å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­— [4]_ ãŒå°æ–‡å­—ã«å¤‰æ›ã•ã‚ŒãŸã€æ–‡å­—åˆ—ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1100
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values"
" are stripped:"
msgstr "æ–‡å­—åˆ—ã®å…ˆé ­ã®æ–‡å­—ã‚’é™¤å»ã—ãŸã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•° *chars* ã¯é™¤å»ã•ã‚Œã‚‹æ–‡å­—ã®é›†åˆã‚’æŒ‡å®šã™ã‚‹æ–‡å­—åˆ—ã§ã™ã€‚ *chars* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ ``None`` ã®å ´åˆã€ç©ºç™½æ–‡å­—ãŒé™¤å»ã•ã‚Œã¾ã™ã€‚ *chars* æ–‡å­—åˆ—ã¯æ¥é ­è¾ã§ã¯ãªãã€ãã®å€¤ã«å«ã¾ã‚Œã‚‹æ–‡å­—ã®çµ„ã¿åˆã‚ã›å…¨ã¦ãŒã¯ãå–ã‚‰ã‚Œã¾ã™ã€‚ :"

#: ../../library/stdtypes.rst:1110 ../../library/stdtypes.rst:1187
#: ../../library/stdtypes.rst:1314
msgid "Support for the *chars* argument."
msgstr "å¼•æ•° *chars* ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã—ãŸ."

#: ../../library/stdtypes.rst:1116
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part"
" after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr "æ–‡å­—åˆ—ã‚’ *sep* ã®æœ€åˆã®å‡ºç¾ä½ç½®ã§åŒºåˆ‡ã‚Šã€ 3 è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã®å†…å®¹ã¯ã€åŒºåˆ‡ã‚Šã®å‰ã®éƒ¨åˆ†ã€åŒºåˆ‡ã‚Šæ–‡å­—åˆ—ãã®ã‚‚ã®ã€ãã—ã¦åŒºåˆ‡ã‚Šã®å¾Œã‚ã®éƒ¨åˆ†ã§ã™ã€‚ã‚‚ã—åŒºåˆ‡ã‚Œãªã‘ã‚Œã°ã€ã‚¿ãƒ—ãƒ«ã«ã¯å…ƒã®æ–‡å­—åˆ—ãã®ã‚‚ã®ã¨ãã®å¾Œã‚ã«äºŒã¤ã®ç©ºæ–‡å­—åˆ—ãŒå…¥ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1126
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced"
" by *new*.  If the optional argument *count* is given, only the first "
"*count* occurrences are replaced."
msgstr "æ–‡å­—åˆ—ã‚’ã‚³ãƒ”ãƒ¼ã—ã€ç¾ã‚Œã‚‹éƒ¨åˆ†æ–‡å­—åˆ— *old* å…¨ã¦ã‚’ *new* ã«ç½®æ›ã—ã¦è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *count* ãŒä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹å ´åˆã€å…ˆé ­ã‹ã‚‰ *count* å€‹ã® *old* ã ã‘ã‚’ç½®æ›ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1133
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start*"
" and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr "æ–‡å­—åˆ—ä¸­ã®é ˜åŸŸ ``s[start:end]`` ã« *sub* ãŒå«ã¾ã‚Œã‚‹å ´åˆã€ãã®æœ€å¤§ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *start* ãŠã‚ˆã³ *end* ã¯ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã¨åŒæ§˜ã«è§£é‡ˆã•ã‚Œã¾ã™ã€‚ *sub* ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ ``-1``  ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1140
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ":meth:`rfind` ã¨åŒæ§˜ã§ã™ãŒã€ *sub* ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1146
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is a space). The original "
"string is returned if *width* is less than or equal to ``len(s)``."
msgstr "*width* ã®é•·ã•ã‚’ã‚‚ã¤å³å¯„ã›ã—ãŸæ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã«ã¯ *fillchar* ã§æŒ‡å®šã•ã‚ŒãŸæ–‡å­—(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã‚¹ãƒšãƒ¼ã‚¹)ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ *width* ãŒ ``len(s)`` ä»¥ä¸‹ã®å ´åˆã€å…ƒã®æ–‡å­—åˆ—ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1156
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part"
" after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr "æ–‡å­—åˆ—ã‚’ *sep* ã®æœ€å¾Œã®å‡ºç¾ä½ç½®ã§åŒºåˆ‡ã‚Šã€ 3 è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã®å†…å®¹ã¯ã€åŒºåˆ‡ã‚Šã®å‰ã®éƒ¨åˆ†ã€åŒºåˆ‡ã‚Šæ–‡å­—åˆ—ãã®ã‚‚ã®ã€ãã—ã¦åŒºåˆ‡ã‚Šã®å¾Œã‚ã®éƒ¨åˆ†ã§ã™ã€‚ã‚‚ã—åŒºåˆ‡ã‚Œãªã‘ã‚Œã°ã€ã‚¿ãƒ—ãƒ«ã«ã¯äºŒã¤ã®ç©ºæ–‡å­—åˆ—ã¨ãã®å¾Œã‚ã«å…ƒã®æ–‡å­—åˆ—ãã®ã‚‚ã®ãŒå…¥ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1166
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr "*sep* ã‚’åŒºåˆ‡ã‚Šæ–‡å­—ã¨ã—ãŸã€æ–‡å­—åˆ—ä¸­ã®å˜èªã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ *maxsplit* ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€æ–‡å­—åˆ—ã® *å³ç«¯* ã‹ã‚‰æœ€å¤§ *maxsplit* å›åˆ†å‰²ã‚’è¡Œã„ã¾ã™ã€‚*sep* ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ã€ã‚ã‚‹ã„ã¯ ``None`` ã®ã¨ãã€å…¨ã¦ã®ç©ºç™½æ–‡å­—ãŒåŒºåˆ‡ã‚Šæ–‡å­—ã¨ãªã‚Šã¾ã™ã€‚å³ã‹ã‚‰åˆ†å‰²ã—ã¦ã„ãã“ã¨ã‚’é™¤ã‘ã°ã€ :meth:`rsplit` ã¯å¾Œã»ã©è©³ã—ãè¿°ã¹ã‚‹ :meth:`split` ã¨åŒæ§˜ã«æŒ¯ã‚‹èˆã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1177
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values"
" are stripped:"
msgstr "æ–‡å­—åˆ—ã®æœ«å°¾éƒ¨åˆ†ã‚’é™¤å»ã—ãŸã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•° *chars* ã¯é™¤å»ã•ã‚Œã‚‹æ–‡å­—é›†åˆã‚’æŒ‡å®šã™ã‚‹æ–‡å­—åˆ—ã§ã™ã€‚ *chars* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ ``None`` ã®å ´åˆã€ç©ºç™½æ–‡å­—ãŒé™¤å»ã•ã‚Œã¾ã™ã€‚ *chars* æ–‡å­—åˆ—ã¯æ¥å°¾èªã§ã¯ãªãã€ãã“ã«å«ã¾ã‚Œã‚‹æ–‡å­—ã®çµ„ã¿åˆã‚ã›å…¨ã¦ãŒã¯ãå–ã‚‰ã‚Œã¾ã™:"

#: ../../library/stdtypes.rst:1193
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr "æ–‡å­—åˆ—ã‚’ *sep* ã‚’ãƒ‡ãƒªãƒŸã‚¿æ–‡å­—åˆ—ã¨ã—ã¦åŒºåˆ‡ã£ãŸå˜èªã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚*maxsplit* ãŒä¸ãˆã‚‰ã‚Œã¦ã„ã‚Œã°ã€æœ€å¤§ã§ *maxsplit* å›åˆ†å‰²ã•ã‚Œã¾ã™ (ã¤ã¾ã‚Šã€ãƒªã‚¹ãƒˆã¯æœ€å¤§ ``maxsplit+1`` è¦ç´ ã«ãªã‚Šã¾ã™)ã€‚ *maxsplit* ãŒä¸ãˆã‚‰ã‚Œãªã„ã‹ ``-1`` ãªã‚‰ã€åˆ†å‰²ã®å›æ•°ã«åˆ¶é™ã¯ã‚ã‚Šã¾ã›ã‚“ (å¯èƒ½ãªã ã‘åˆ†å‰²ã•ã‚Œã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:1199
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr "*sep* ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€é€£ç¶šã—ãŸåŒºåˆ‡ã‚Šæ–‡å­—ã¯ã¾ã¨ã‚ã‚‰ã‚Œãšã€ç©ºã®æ–‡å­—åˆ—ã‚’åŒºåˆ‡ã£ã¦ã„ã‚‹ã¨åˆ¤æ–­ã•ã‚Œã¾ã™(ä¾‹ãˆã° ``'1,,2'.split(',')`` ã¯ ``['1', '', '2']`` ã‚’è¿”ã—ã¾ã™)ã€‚å¼•æ•° *sep* ã¯è¤‡æ•°ã®æ–‡å­—ã«ã‚‚ã§ãã¾ã™ (ä¾‹ãˆã° ``'1<>2<>3'.split('<>')`` ã¯ ``['1', '2', '3']`` ã‚’è¿”ã—ã¾ã™)ã€‚åŒºåˆ‡ã‚Šæ–‡å­—ã‚’æŒ‡å®šã—ã¦ç©ºã®æ–‡å­—åˆ—ã‚’åˆ†å‰²ã™ã‚‹ã¨ã€ ``['']`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1205
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is"
" applied: runs of consecutive whitespace are regarded as a single separator,"
" and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty"
" string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr "*sep* ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ã‹ ``None`` ã§ã‚ã‚Œã°ã€ç•°ãªã‚‹åˆ†å‰²ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚ : é€£ç¶šã™ã‚‹ç©ºç™½æ–‡å­—ã¯ã²ã¨ã¤ã®ãƒ‡ãƒªãƒŸã‚¿ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚ã¾ãŸã€æ–‡å­—åˆ—ã®å…ˆé ­ã‚„æœ«å°¾ã«ç©ºç™½ãŒã‚ã£ã¦ã‚‚ã€çµæœã®æœ€åˆã‚„æœ€å¾Œã«ç©ºæ–‡å­—åˆ—ã¯å«ã¾ã‚Œã¾ã›ã‚“ã€‚ã‚ˆã£ã¦ã€ç©ºæ–‡å­—åˆ—ã‚„ç©ºç™½ã ã‘ã®æ–‡å­—åˆ—ã‚’ ``None`` ãƒ‡ãƒªãƒŸã‚¿ã§åˆ†å‰²ã™ã‚‹ã¨ ``[]`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1212
msgid ""
"For example, ``' 1  2   3  '.split()`` returns ``['1', '2', '3']``, and ``'"
"  1  2   3  '.split(None, 1)`` returns ``['1', '2   3  ']``."
msgstr "ä¾‹ãˆã°ã€ ``' 1  2   3  '.split()`` ã¯ ``['1', '2', '3']`` ã‚’è¿”ã—ã€ ``'  1  2   3  '.split(None, 1)`` ã¯ ``['1', '2   3  ']`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1221
msgid ""
"Return a list of the lines in the string, breaking at line boundaries. This "
"method uses the :term:`universal newlines` approach to splitting lines. Line"
" breaks are not included in the resulting list unless *keepends* is given "
"and true."
msgstr "æ–‡å­—åˆ—ã‚’æ”¹è¡Œéƒ¨åˆ†ã§åˆ†è§£ã—ã€å„è¡Œã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€è¡Œã®åˆ†å‰²ã« :term:`universal newlines` ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’ä½¿ã„ã¾ã™ã€‚*keepends* ã«çœŸãŒä¸ãˆã‚‰ãªã„é™ã‚Šã€è¿”ã•ã‚Œã‚‹ãƒªã‚¹ãƒˆã«æ”¹è¡Œã¯å«ã¾ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1226
msgid ""
"Python recognizes ``\"\\r\"``, ``\"\\n\"``, and ``\"\\r\\n\"`` as line "
"boundaries for 8-bit strings."
msgstr "Python ã¯ ``\"\\r\"``, ``\"\\n\"``, ``\"\\r\\n\"`` ã‚’ 8-bit æ–‡å­—åˆ—ã®è¡Œã®å¢ƒç•Œã¨ã—ã¦èªè­˜ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1229
msgid "For example::"
msgstr "ä¾‹ãˆã°::"

#: ../../library/stdtypes.rst:1236
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break"
" does not result in an extra line::"
msgstr ":meth:`~str.split` ã¨ã¯é•ã£ã¦ã€ãƒ‡ãƒªãƒŸã‚¿æ–‡å­—åˆ— *sep* ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ç©ºæ–‡å­—åˆ—ã«ç©ºãƒªã‚¹ãƒˆã‚’è¿”ã—ã€çµ‚æœ«ã®æ”¹è¡Œã¯çµæœã«è¡Œã‚’è¿½åŠ ã—ã¾ã›ã‚“::"

#: ../../library/stdtypes.rst:1245
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "æ¯”è¼ƒã®ãŸã‚ã« ``split('\\n')`` ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/stdtypes.rst:1254
msgid ""
"Return a list of the lines in the string, like :meth:`str.splitlines`. "
"However, the Unicode method splits on the following line boundaries, which "
"are a superset of the :term:`universal newlines` recognized for 8-bit "
"strings."
msgstr ":meth:`str.splitlines` ã®ã‚ˆã†ã«ã€æ–‡å­—åˆ—ã‚’è¡Œã®ãƒªã‚¹ãƒˆã«ã—ã¦è¿”ã—ã¾ã™ã€‚\nãŸã ã— Unicode ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ã€8-bit æ–‡å­—åˆ—ã®è¡Œã®å¢ƒç•Œã¨ã—ã¦èªè­˜ã•ã‚Œã‚‹ :term:`universal newlines` ã‚ˆã‚Šã‚‚å¤šãã®æ¬¡ã«æŒ™ã’ã‚‹è¡Œã®å¢ƒç•Œã§åˆ†å‰²ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1260
msgid "Representation"
msgstr "è¡¨ç¾"

#: ../../library/stdtypes.rst:1260
msgid "Description"
msgstr "èª¬æ˜"

#: ../../library/stdtypes.rst:1262
msgid "``\\n``"
msgstr "``\\n``"

#: ../../library/stdtypes.rst:1262
msgid "Line Feed"
msgstr "æ”¹è¡Œ"

#: ../../library/stdtypes.rst:1264
msgid "``\\r``"
msgstr "``\\r``"

#: ../../library/stdtypes.rst:1264
msgid "Carriage Return"
msgstr "å¾©å¸°"

#: ../../library/stdtypes.rst:1266
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../../library/stdtypes.rst:1266
msgid "Carriage Return + Line Feed"
msgstr "æ”¹è¡Œ + å¾©å¸°"

#: ../../library/stdtypes.rst:1268
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` or ``\\x0b``"

#: ../../library/stdtypes.rst:1268
msgid "Line Tabulation"
msgstr "å‚ç›´ã‚¿ãƒ–"

#: ../../library/stdtypes.rst:1270
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` or ``\\x0c``"

#: ../../library/stdtypes.rst:1270
msgid "Form Feed"
msgstr "æ”¹ãƒšãƒ¼ã‚¸"

#: ../../library/stdtypes.rst:1272
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../../library/stdtypes.rst:1272
msgid "File Separator"
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«åŒºåˆ‡ã‚Š"

#: ../../library/stdtypes.rst:1274
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../../library/stdtypes.rst:1274
msgid "Group Separator"
msgstr "ã‚°ãƒ«ãƒ¼ãƒ—åŒºåˆ‡ã‚Š"

#: ../../library/stdtypes.rst:1276
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../../library/stdtypes.rst:1276
msgid "Record Separator"
msgstr "ãƒ¬ã‚³ãƒ¼ãƒ‰åŒºåˆ‡ã‚Š"

#: ../../library/stdtypes.rst:1278
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../../library/stdtypes.rst:1278
msgid "Next Line (C1 Control Code)"
msgstr "æ”¹è¡Œ (C1 åˆ¶å¾¡ã‚³ãƒ¼ãƒ‰)"

#: ../../library/stdtypes.rst:1280
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../../library/stdtypes.rst:1280
msgid "Line Separator"
msgstr "è¡ŒåŒºåˆ‡ã‚Š"

#: ../../library/stdtypes.rst:1282
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../../library/stdtypes.rst:1282
msgid "Paragraph Separator"
msgstr "æ®µè½åŒºåˆ‡ã‚Š"

#: ../../library/stdtypes.rst:1287
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` ã¨ ``\\f`` ãŒè¡Œå¢ƒç•Œã®ãƒªã‚¹ãƒˆã«è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:1292
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr "æ–‡å­—åˆ—ãŒæŒ‡å®šã•ã‚ŒãŸ *prefix* ã§å§‹ã¾ã‚‹ãªã‚‰ ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™ã€‚ *prefix* ã¯è¦‹ã¤ã‘ãŸã„è¤‡æ•°ã®æ¥é ­èªã®ã‚¿ãƒ—ãƒ«ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *start* ãŒã‚ã‚Œã°ã€ãã®ä½ç½®ã‹ã‚‰åˆ¤å®šã‚’å§‹ã‚ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *end* ãŒã‚ã‚Œã°ã€ãã®ä½ç½®ã§æ¯”è¼ƒã‚’æ­¢ã‚ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1297
msgid "Accept tuples as *prefix*."
msgstr "*prefix* ã§ã‚¿ãƒ—ãƒ«ã‚’å—ã‘ä»˜ã‘ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸ."

#: ../../library/stdtypes.rst:1303
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather,"
" all combinations of its values are stripped:"
msgstr "æ–‡å­—åˆ—ã®å…ˆé ­ãŠã‚ˆã³æœ«å°¾éƒ¨åˆ†ã‚’é™¤å»ã—ãŸã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•° *chars* ã¯é™¤å»ã•ã‚Œã‚‹æ–‡å­—é›†åˆã‚’æŒ‡å®šã™ã‚‹æ–‡å­—åˆ—ã§ã™ã€‚ *chars* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ ``None`` ã®å ´åˆã€ç©ºç™½æ–‡å­—ãŒé™¤å»ã•ã‚Œã¾ã™ã€‚ *chars* æ–‡å­—åˆ—ã¯æ¥é ­èªã§ã‚‚æ¥å°¾èªã§ã‚‚ãªãã€ãã“ã«å«ã¾ã‚Œã‚‹æ–‡å­—ã®çµ„ã¿åˆã‚ã›å…¨ã¦ãŒã¯ãå–ã‚‰ã‚Œã¾ã™ã€‚ :"

#: ../../library/stdtypes.rst:1320
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase"
" and vice versa."
msgstr "æ–‡å­—åˆ—ã‚’ã‚³ãƒ”ãƒ¼ã—ã€å¤§æ–‡å­—ã¯å°æ–‡å­—ã«ã€å°æ–‡å­—ã¯å¤§æ–‡å­—ã«å¤‰æ›ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1328
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr "æ–‡å­—åˆ—ã‚’ã€å˜èªã”ã¨ã«å¤§æ–‡å­—ã‹ã‚‰å§‹ã¾ã‚Šã€æ®‹ã‚Šã®æ–‡å­—ã®ã†ã¡å¤§å°æ–‡å­—ã®åŒºåˆ¥ãŒã‚ã‚‹ã‚‚ã®ã¯å…¨ã¦å°æ–‡å­—ã«ã™ã‚‹ã€ã‚¿ã‚¤ãƒˆãƒ«ã‚±ãƒ¼ã‚¹ã«ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1331
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it"
" means that apostrophes in contractions and possessives form word "
"boundaries, which may not be the desired result::"
msgstr "ã“ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€é€£ç¶šã—ãŸæ–‡å­—ã®é›†ã¾ã‚Šã¨ã„ã†ã€è¨€èªã‹ã‚‰ç‹¬ç«‹ã—ãŸå˜ç´”ãªå˜èªã®å®šç¾©ã‚’ä½¿ã„ã¾ã™ã€‚ã“ã®å®šç¾©ã¯å¤šãã®çŠ¶æ³ã§ã¯ã†ã¾ãæ©Ÿèƒ½ã—ã¾ã™ãŒã€çŸ­ç¸®å½¢ã‚„æ‰€æœ‰æ ¼ã®ã‚¢ãƒã‚¹ãƒˆãƒ­ãƒ•ã‚£ãŒå˜èªã®å¢ƒç•Œã«ãªã£ã¦ã—ã¾ã„ã€æœ›ã¿ã®çµæœã‚’å¾—ã‚‰ã‚Œãªã„å ´åˆãŒã‚ã‚Šã¾ã™::"

#: ../../library/stdtypes.rst:1339
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr "æ­£è¦è¡¨ç¾ã‚’ä½¿ã†ã“ã¨ã§ã‚¢ãƒã‚¹ãƒˆãƒ­ãƒ•ã‚£ã«å¯¾å¿œã§ãã¾ã™::"

#: ../../library/stdtypes.rst:1356
msgid ""
"Return a copy of the string where all characters occurring in the optional "
"argument *deletechars* are removed, and the remaining characters have been "
"mapped through the given translation table, which must be a string of length"
" 256."
msgstr "æ–‡å­—åˆ—ã‚’ã‚³ãƒ”ãƒ¼ã—ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•°ã®æ–‡å­—åˆ— *deletechars* ã®ä¸­ã«å«ã¾ã‚Œã‚‹æ–‡å­—ã‚’å…¨ã¦é™¤å»ã—ã¾ã™ã€‚ãã®å¾Œã€æ®‹ã£ãŸæ–‡å­—ã‚’å¤‰æ›ãƒ†ãƒ¼ãƒ–ãƒ« *table* ã«å¾“ã£ã¦ãƒãƒƒãƒ—ã—ã¦è¿”ã—ã¾ã™ã€‚å¤‰æ›ãƒ†ãƒ¼ãƒ–ãƒ«ã¯é•·ã• 256 ã®æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1361
msgid ""
"You can use the :func:`~string.maketrans` helper function in the "
":mod:`string` module to create a translation table. For string objects, set "
"the *table* argument to ``None`` for translations that only delete "
"characters:"
msgstr "ãƒˆãƒ©ãƒ³ã‚¹ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆã®ãŸã‚ã«ã€ :mod:`string` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :func:`~string.maketrans` è£œåŠ©é–¢æ•°ã‚’ä½¿ã†ã“ã¨ã‚‚ã§ãã¾ã™ã€‚æ–‡å­—åˆ—å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã¯ã€ *table* å¼•æ•°ã« ``None`` ã‚’ä¸ãˆã‚‹ã“ã¨ã§ã€æ–‡å­—ã®å‰Šé™¤ã ã‘ã‚’å®Ÿæ–½ã—ã¾ã™ã€‚:"

#: ../../library/stdtypes.rst:1368
msgid "Support for a ``None`` *table* argument."
msgstr "``None`` ã® *table* å¼•æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:1371
msgid ""
"For Unicode objects, the :meth:`translate` method does not accept the "
"optional *deletechars* argument.  Instead, it returns a copy of the *s* "
"where all characters have been mapped through the given translation table "
"which must be a mapping of Unicode ordinals to Unicode ordinals, Unicode "
"strings or ``None``. Unmapped characters are left untouched. Characters "
"mapped to ``None`` are deleted.  Note, a more flexible approach is to create"
" a custom character mapping codec using the :mod:`codecs` module (see "
":mod:`encodings.cp1251` for an example)."
msgstr "Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€ :meth:`translate` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *deletechars* å¼•æ•°ã‚’å—ç†ã—ã¾ã›ã‚“ã€‚ãã®ä»£ã‚ã‚Šã€ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã™ã¹ã¦ã®æ–‡å­—ãŒä¸ãˆã‚‰ã‚ŒãŸå¤‰æ›ãƒ†ãƒ¼ãƒ–ãƒ«ã§å¯¾å¿œä»˜ã‘ã•ã‚Œã¦ã„ã‚‹ *s* ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®å¤‰æ›ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ Unicode é † (ordinal) ã‹ã‚‰ Unicode é †ã€ Unicode æ–‡å­—åˆ—ã€ã¾ãŸã¯ ``None`` ã¸ã®å¯¾å¿œä»˜ã‘ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚å¯¾å¿œä»˜ã‘ã•ã‚Œã¦ã„ãªã„æ–‡å­—ã¯ä½•ã‚‚ã›ãšæ”¾ç½®ã•ã‚Œã¾ã™ã€‚ ``None`` ã«å¯¾å¿œä»˜ã‘ã‚‰ã‚ŒãŸæ–‡å­—ã¯å‰Šé™¤ã•ã‚Œã¾ã™ã€‚ã¡ãªã¿ã«ã€ã‚ˆã‚ŠæŸ”è»Ÿæ€§ã®ã‚ã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã€è‡ªä½œã®æ–‡å­—å¯¾å¿œä»˜ã‘ã‚’è¡Œã† codec ã‚’ :mod:`codecs` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦ä½œæˆã™ã‚‹ã“ã¨ã§ã™ (ä¾‹ãˆã° :mod:`encodings.cp1251` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚)"

#: ../../library/stdtypes.rst:1383
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""

#: ../../library/stdtypes.rst:1393
msgid ""
"Return the numeric string left filled with zeros in a string of length "
"*width*.  A sign prefix is handled correctly.  The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr "æ•°å€¤æ–‡å­—åˆ—ã®å·¦å´ã‚’ã‚¼ãƒ­è©°ã‚ã—ã€å¹… *width* ã®æ–‡å­—åˆ—ã§è¿”ã—ã¾ã™ã€‚ç¬¦å·æ¥é ­è¾ã‚‚æ­£ã—ãæ‰±ã‚ã‚Œã¾ã™ã€‚ *width* ãŒ ``len(s)`` ä»¥ä¸‹ã®å ´åˆã‚‚ã¨ã®æ–‡å­—åˆ—è‡ªä½“ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1400
msgid "The following methods are present only on unicode objects:"
msgstr "ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã®ã¿å®Ÿè£…ã•ã‚Œã¾ã™:"

#: ../../library/stdtypes.rst:1404
msgid ""
"Return ``True`` if there are only numeric characters in S, ``False`` "
"otherwise. Numeric characters include digit characters, and all characters "
"that have the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION "
"ONE FIFTH."
msgstr "æ•°å­—ã‚’è¡¨ã™æ–‡å­—ã®ã¿ã§æ§‹æˆã•ã‚Œã‚‹å ´åˆã€ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ ``False`` ã‚’è¿”ã—ã¾ã™ã€‚æ•°å­—ã‚’è¡¨ã™æ–‡å­—ã«ã¯ã€ 0 ã‹ã‚‰ 9 ã¾ã§ã®æ•°å­—ã¨ã€ Unicode ã®æ•°å­—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã¤å…¨ã¦ã®æ–‡å­—ãŒå«ã¾ã‚Œã¾ã™ã€‚ (e.g. U+2155, VULGAR FRACTION ONE FIFTH)"

#: ../../library/stdtypes.rst:1411
msgid ""
"Return ``True`` if there are only decimal characters in S, ``False`` "
"otherwise. Decimal characters include digit characters, and all characters "
"that can be used to form decimal-radix numbers, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO."
msgstr "10 é€²æ•°æ–‡å­—ã®ã¿ã§æ§‹æˆã•ã‚Œã‚‹å ´åˆã€ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€ ``False`` ã‚’è¿”ã—ã¾ã™ã€‚ 10 é€²æ•°æ–‡å­—ã«ã¯ 0 ã‹ã‚‰ 9 ã¾ã§ã®æ•°å­—ã¨ã€ 10 é€²åŸºæ•°è¡¨è¨˜ã«ä½¿ã‚ã‚Œã‚‹å…¨ã¦ã®æ–‡å­—ãŒå«ã¾ã‚Œã¾ã™ã€‚ (e.g. U+0660, ARABIC-INDIC DIGIT ZERO)"

#: ../../library/stdtypes.rst:1420
msgid "String Formatting Operations"
msgstr "æ–‡å­—åˆ—ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ“ä½œ"

#: ../../library/stdtypes.rst:1432
msgid ""
"String and Unicode objects have one unique built-in operation: the ``%`` "
"operator (modulo).  This is also known as the string *formatting* or "
"*interpolation* operator.  Given ``format % values`` (where *format* is a "
"string or Unicode object), ``%`` conversion specifications in *format* are "
"replaced with zero or more elements of *values*.  The effect is similar to "
"the using :c:func:`sprintf` in the C language.  If *format* is a Unicode "
"object, or if any of the objects being converted using the ``%s`` conversion"
" are Unicode objects, the result will also be a Unicode object."
msgstr "æ–‡å­—åˆ—ãŠã‚ˆã³ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯å›ºæœ‰ã®æ“ä½œ: ``%`` æ¼”ç®—å­ (ãƒ¢ã‚¸ãƒ¥ãƒ­) ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®æ¼”ç®—å­ã¯æ–‡å­—åˆ— *ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆåŒ–* ã¾ãŸã¯ *è£œé–“* æ¼”ç®—ã¨ã—ã¦ã‚‚çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ ``format % values`` (*format* ã¯æ–‡å­—åˆ—ã¾ãŸã¯ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) ã¨ã™ã‚‹ã¨ã€ *format* ä¸­ã® ``%`` å¤‰æ›æŒ‡å®šã¯ *values* ä¸­ã®ã‚¼ãƒ­å€‹ã¾ãŸã¯ãã‚Œä»¥ä¸Šã®è¦ç´ ã§ç½®æ›ã•ã‚Œã¾ã™ã€‚ã“ã®å‹•ä½œã¯ C è¨€èªã«ãŠã‘ã‚‹ :c:func:`sprintf` ã«ä¼¼ã¦ã„ã¾ã™ã€‚ *format* ãŒ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã‹ã€ã¾ãŸã¯ ``%s`` å¤‰æ›ã‚’ä½¿ã£ã¦ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¤‰æ›ã•ã‚Œã‚‹å ´åˆã€ãã®çµæœã‚‚ Unicode ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1441
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of"
" items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr "*format* ãŒå˜ä¸€ã®å¼•æ•°ã—ã‹è¦æ±‚ã—ãªã„å ´åˆã€ *values* ã¯ã‚¿ãƒ—ãƒ«ã§ãªã„å˜ä¸€ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚ [5]_ ãã‚Œä»¥å¤–ã®å ´åˆã€ *values* ã¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ä¸­ã§æŒ‡å®šã•ã‚ŒãŸé …ç›®ã¨æ­£ç¢ºã«åŒã˜æ•°ã®è¦ç´ ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã‹ã€å˜ä¸€ã®ãƒãƒƒãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1446
msgid ""
"A conversion specifier contains two or more characters and has the following"
" components, which must occur in this order:"
msgstr "ä¸€ã¤ã®å¤‰æ›æŒ‡å®šå­ã¯ 2 ã¾ãŸã¯ãã‚Œä»¥ä¸Šã®æ–‡å­—ã‚’å«ã¿ã€ãã®æ§‹æˆè¦ç´ ã¯ä»¥ä¸‹ã‹ã‚‰ãªã‚Šã¾ã™ãŒã€ç¤ºã—ãŸé †ã«å‡ºç¾ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“:"

#: ../../library/stdtypes.rst:1449
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "æŒ‡å®šå­ã®é–‹å§‹ã‚’ç¤ºã™æ–‡å­— ``'%'`` ã€‚"

#: ../../library/stdtypes.rst:1451
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters"
" (for example, ``(somename)``)."
msgstr "ãƒãƒƒãƒ—ã‚­ãƒ¼ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)ã€‚ä¸¸æ‹¬å¼§ã§å›²ã£ãŸæ–‡å­—åˆ—ã‹ã‚‰ãªã‚Šã¾ã™ (ä¾‹ãˆã° ``(somename)``) ã€‚"

#: ../../library/stdtypes.rst:1454
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr "å¤‰æ›ãƒ•ãƒ©ã‚° (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)ã€‚ä¸€éƒ¨ã®å¤‰æ›å‹ã®çµæœã«å½±éŸ¿ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1457
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the"
" object to convert comes after the minimum field width and optional "
"precision."
msgstr "æœ€å°ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¹… (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)ã€‚ ``'*'`` (ã‚¢ã‚¹ã‚¿ãƒªã‚¹ã‚¯) ã‚’æŒ‡å®šã—ãŸå ´åˆã€å®Ÿéš›ã®æ–‡å­—åˆ—å¹…ãŒ *values* ã‚¿ãƒ—ãƒ«ã®æ¬¡ã®è¦ç´ ã‹ã‚‰èª­ã¿å‡ºã•ã‚Œã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã«ã¯æœ€å°ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¹…ã‚„ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ç²¾åº¦æŒ‡å®šã®å¾Œã«å¤‰æ›ã—ãŸã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1461
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual width is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr "ç²¾åº¦ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)ã€‚ ``'.'`` (ãƒ‰ãƒƒãƒˆ) ã¨ãã®å¾Œã«ç¶šãç²¾åº¦ã§ä¸ãˆã‚‰ã‚Œã¾ã™ã€‚ ``'*'`` (ã‚¢ã‚¹ã‚¿ãƒªã‚¹ã‚¯) ã‚’æŒ‡å®šã—ãŸå ´åˆã€ç²¾åº¦ã®æ¡æ•°ã¯ *values* ã‚¿ãƒ—ãƒ«ã®æ¬¡ã®è¦ç´ ã‹ã‚‰èª­ã¿å‡ºã•ã‚Œã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã«ã¯ç²¾åº¦æŒ‡å®šã®å¾Œã«å¤‰æ›ã—ãŸã„å€¤ãŒãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1466
msgid "Length modifier (optional)."
msgstr "ç²¾åº¦é•·å¤‰æ›å­ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)ã€‚"

#: ../../library/stdtypes.rst:1468
msgid "Conversion type."
msgstr "å¤‰æ›å‹ã€‚"

#: ../../library/stdtypes.rst:1470
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key"
" selects the value to be formatted from the mapping.  For example:"
msgstr "``%`` æ¼”ç®—å­ã®å³å´ã®å¼•æ•°ãŒè¾æ›¸ã®å ´åˆ (ã¾ãŸã¯ãã®ä»–ã®ãƒãƒƒãƒ—å‹ã®å ´åˆ), æ–‡å­—åˆ—ä¸­ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ã¯ã€è¾æ›¸ã«æŒ¿å…¥ã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¼ã‚’ä¸¸æ‹¬å¼§ã§å›²ã„ã€æ–‡å­— ``'%'`` ã®ç›´å¾Œã«ãã‚‹ã‚ˆã†ã«ã—ãŸã‚‚ã®ãŒå«ã¾ã‚Œã¦ã„ãªã‘ã‚Œã° *ãªã‚Šã¾ã›ã‚“* ã€‚ãƒãƒƒãƒ—ã‚­ãƒ¼ã¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆåŒ–ã—ãŸã„å€¤ã‚’ãƒãƒƒãƒ—ã‹ã‚‰é¸ã³å‡ºã—ã¾ã™ã€‚ä¾‹ãˆã°:"

#: ../../library/stdtypes.rst:1479
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a"
" sequential parameter list)."
msgstr "ã“ã®å ´åˆã€ ``*`` æŒ‡å®šå­ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å«ã‚ã¦ã¯ã„ã‘ã¾ã›ã‚“ (``*`` æŒ‡å®šå­ã¯é †ç•ªä»˜ã‘ã•ã‚ŒãŸãƒ‘ãƒ©ãƒ¡ã‚¿ã®ãƒªã‚¹ãƒˆãŒå¿…è¦ã ã‹ã‚‰ã§ã™)ã€‚"

#: ../../library/stdtypes.rst:1482
msgid "The conversion flag characters are:"
msgstr "å¤‰æ›ãƒ•ãƒ©ã‚°æ–‡å­—ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™:"

#: ../../library/stdtypes.rst:1485
msgid "Flag"
msgstr "ãƒ•ãƒ©ã‚°"

#: ../../library/stdtypes.rst:1487
msgid "``'#'``"
msgstr "``'#'``"

#: ../../library/stdtypes.rst:1487
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr "å€¤ã®å¤‰æ›ã« (ä¸‹ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹) \"åˆ¥ã®å½¢å¼\" ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1490
msgid "``'0'``"
msgstr "``'0'``"

#: ../../library/stdtypes.rst:1490
msgid "The conversion will be zero padded for numeric values."
msgstr "æ•°å€¤å‹ã«å¯¾ã—ã¦ã‚¼ãƒ­ã«ã‚ˆã‚‹ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1492
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/stdtypes.rst:1492
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr "å¤‰æ›ã•ã‚ŒãŸå€¤ã‚’å·¦å¯„ã›ã«ã—ã¾ã™ (``'0'`` ã¨åŒæ™‚ã«ä¸ãˆãŸå ´åˆã€ ``'0'`` ã‚’ä¸Šæ›¸ãã—ã¾ã™) ã€‚"

#: ../../library/stdtypes.rst:1495
msgid "``' '``"
msgstr "``' '``"

#: ../../library/stdtypes.rst:1495
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr "(ã‚¹ãƒšãƒ¼ã‚¹) ç¬¦å·ä»˜ãã®å¤‰æ›ã§æ­£ã®æ•°ã®å ´åˆã€å‰ã«ä¸€ã¤ã‚¹ãƒšãƒ¼ã‚¹ã‚’ç©ºã‘ã¾ã™ (ãã†ã§ãªã„å ´åˆã¯ç©ºæ–‡å­—ã«ãªã‚Šã¾ã™) ã€‚"

#: ../../library/stdtypes.rst:1498
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/stdtypes.rst:1498
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides"
" a \"space\" flag)."
msgstr "å¤‰æ›ã®å…ˆé ­ã«ç¬¦å·æ–‡å­— (``'+'`` ã¾ãŸã¯ ``'-'``) ã‚’ä»˜ã‘ã¾ã™(\"ã‚¹ãƒšãƒ¼ã‚¹\" ãƒ•ãƒ©ã‚°ã‚’ä¸Šæ›¸ãã—ã¾ã™) ã€‚"

#: ../../library/stdtypes.rst:1502
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as"
" it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr "ç²¾åº¦é•·å¤‰æ›å­(``h``, ``l``,ã¾ãŸã¯ ``L``) ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ãŒã€ Python ã§ã¯å¿…è¦ãªã„ãŸã‚ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ -- ã¤ã¾ã‚Šã€ä¾‹ãˆã° ``%ld`` ã¯ ``%d`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1505
msgid "The conversion types are:"
msgstr "å¤‰æ›å‹ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™:"

#: ../../library/stdtypes.rst:1508
msgid "Conversion"
msgstr "å¤‰æ›"

#: ../../library/stdtypes.rst:1510
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/stdtypes.rst:1510 ../../library/stdtypes.rst:1512
msgid "Signed integer decimal."
msgstr "ç¬¦å·ä»˜ã 10 é€²æ•´æ•°ã€‚"

#: ../../library/stdtypes.rst:1512
msgid "``'i'``"
msgstr "``'i'``"

#: ../../library/stdtypes.rst:1514
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/stdtypes.rst:1514
msgid "Signed octal value."
msgstr "ç¬¦å·ä»˜ã 8 é€²æ•°ã€‚"

#: ../../library/stdtypes.rst:1516
msgid "``'u'``"
msgstr "``'u'``"

#: ../../library/stdtypes.rst:1516
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "æ—§å¼ã®å‹ -- ``'d'`` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1518
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/stdtypes.rst:1518
msgid "Signed hexadecimal (lowercase)."
msgstr "ç¬¦å·ä»˜ã 16 é€²æ•° (å°æ–‡å­—)ã€‚"

#: ../../library/stdtypes.rst:1520
msgid "``'X'``"
msgstr "``'X'``"

#: ../../library/stdtypes.rst:1520
msgid "Signed hexadecimal (uppercase)."
msgstr "ç¬¦å·ä»˜ã 16 é€²æ•° (å¤§æ–‡å­—)ã€‚"

#: ../../library/stdtypes.rst:1522
msgid "``'e'``"
msgstr "``'e'``"

#: ../../library/stdtypes.rst:1522
msgid "Floating point exponential format (lowercase)."
msgstr "æŒ‡æ•°è¡¨è¨˜ã®æµ®å‹•å°æ•°ç‚¹æ•° (å°æ–‡å­—)ã€‚"

#: ../../library/stdtypes.rst:1524
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/stdtypes.rst:1524
msgid "Floating point exponential format (uppercase)."
msgstr "æŒ‡æ•°è¡¨è¨˜ã®æµ®å‹•å°æ•°ç‚¹æ•° (å¤§æ–‡å­—)ã€‚"

#: ../../library/stdtypes.rst:1526
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/stdtypes.rst:1526 ../../library/stdtypes.rst:1528
msgid "Floating point decimal format."
msgstr "10 é€²æµ®å‹•å°æ•°ç‚¹æ•°ã€‚"

#: ../../library/stdtypes.rst:1528
msgid "``'F'``"
msgstr "``'F'``"

#: ../../library/stdtypes.rst:1530
msgid "``'g'``"
msgstr "``'g'``"

#: ../../library/stdtypes.rst:1530
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less"
" than -4 or not less than precision, decimal format otherwise."
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã€‚æŒ‡æ•°éƒ¨ãŒ -4 ä»¥ä¸Šã¾ãŸã¯ç²¾åº¦ä»¥ä¸‹ã®å ´åˆã«ã¯å°æ–‡å­—æŒ‡æ•°è¡¨è¨˜ã€ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯10é€²è¡¨è¨˜ã€‚"

#: ../../library/stdtypes.rst:1534
msgid "``'G'``"
msgstr "``'G'``"

#: ../../library/stdtypes.rst:1534
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less"
" than -4 or not less than precision, decimal format otherwise."
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã€‚æŒ‡æ•°éƒ¨ãŒ -4 ä»¥ä¸Šã¾ãŸã¯ç²¾åº¦ä»¥ä¸‹ã®å ´åˆã«ã¯å¤§æ–‡å­—æŒ‡æ•°è¡¨è¨˜ã€ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯10é€²è¡¨è¨˜ã€‚"

#: ../../library/stdtypes.rst:1538
msgid "``'c'``"
msgstr "``'c'``"

#: ../../library/stdtypes.rst:1538
msgid "Single character (accepts integer or single character string)."
msgstr "æ–‡å­—ä¸€æ–‡å­— (æ•´æ•°ã¾ãŸã¯ä¸€æ–‡å­—ã‹ã‚‰ãªã‚‹æ–‡å­—åˆ—ã‚’å—ç†ã—ã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:1541
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/stdtypes.rst:1541
msgid "String (converts any Python object using :ref:`repr() <func-repr>`)."
msgstr "æ–‡å­—åˆ— (Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :ref:`repr() <func-repr>` ã§å¤‰æ›ã—ã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:1541 ../../library/stdtypes.rst:1690
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/stdtypes.rst:1544
msgid "``'s'``"
msgstr "``'s'``"

#: ../../library/stdtypes.rst:1544
msgid "String (converts any Python object using :func:`str`)."
msgstr "æ–‡å­—åˆ— (Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :func:`str` ã§å¤‰æ›ã—ã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:1547
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/stdtypes.rst:1547
msgid ""
"No argument is converted, results in a ``'%'`` character in the result."
msgstr "å¼•æ•°ã‚’å¤‰æ›ã›ãšã€è¿”ã•ã‚Œã‚‹æ–‡å­—åˆ—ä¸­ã§ã¯æ–‡å­— ``'%'`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1554
msgid ""
"The alternate form causes a leading zero (``'0'``) to be inserted between "
"left-hand padding and the formatting of the number if the leading character "
"of the result is not already a zero."
msgstr "ã“ã®å½¢å¼ã®å‡ºåŠ›ã«ã—ãŸå ´åˆã€å¤‰æ›çµæœã®å…ˆé ­ã®æ•°å­—ãŒã‚¼ãƒ­ (``'0'``) ã§ãªã„ã¨ãã«ã¯ã€æ•°å­—ã®å…ˆé ­ã¨å·¦å´ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã¨ã®é–“ã«ã‚¼ãƒ­ã‚’æŒ¿å…¥ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1559
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr "åˆ¥ã®å½¢å¼ã‚’æŒ‡å®šï¼ˆè¨³æ³¨: å¤‰æ›ãƒ•ãƒ©ã‚° ``#`` ã‚’ä½¿ç”¨ï¼‰ã™ã‚‹ã¨ 16 é€²æ•°ã‚’è¡¨ã™æ¥é ­è¾ ``'0x'`` ã¾ãŸã¯ ``'0X'`` (ä½¿ç”¨ã™ã‚‹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—ãŒ ``'x'`` ã‹ ``'X'`` ã«ä¾å­˜ã—ã¾ã™) ãŒæœ€åˆã®æ•°å­—ã®å‰ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1563
msgid ""
"The alternate form causes the result to always contain a decimal point, even"
" if no digits follow it."
msgstr "ã“ã®å½¢å¼ã«ã—ãŸå ´åˆã€å¤‰æ›çµæœã«ã¯å¸¸ã«å°æ•°ç‚¹ãŒå«ã¾ã‚Œã€ãã‚Œã¯ãã®å¾Œã‚ã«æ•°å­—ãŒç¶šã‹ãªã„å ´åˆã«ã‚‚é©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1566
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr "æŒ‡å®šç²¾åº¦ã¯å°æ•°ç‚¹ã®å¾Œã®æ¡æ•°ã‚’æ±ºå®šã—ã€ãã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ 6 ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1570
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr "ã“ã®å½¢å¼ã«ã—ãŸå ´åˆã€å¤‰æ›çµæœã«ã¯å¸¸ã«å°æ•°ç‚¹ãŒå«ã¾ã‚Œä»–ã®å½¢å¼ã¨ã¯é•ã£ã¦æœ«å°¾ã® 0 ã¯å–ã‚Šé™¤ã‹ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1573
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr "æŒ‡å®šç²¾åº¦ã¯å°æ•°ç‚¹ã®å‰å¾Œã®æœ‰åŠ¹æ¡æ•°ã‚’æ±ºå®šã—ã€ãã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ 6 ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1577
msgid "The ``%r`` conversion was added in Python 2.0."
msgstr "``%r`` å¤‰æ›ã¯ Python 2.0 ã§è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:1579 ../../library/stdtypes.rst:1585
msgid "The precision determines the maximal number of characters used."
msgstr "æŒ‡å®šç²¾åº¦ã¯æœ€å¤§æ–‡å­—æ•°ã‚’æ±ºå®šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1582
msgid ""
"If the object or format provided is a :class:`unicode` string, the resulting"
" string will also be :class:`unicode`."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„ä¸ãˆã‚‰ã‚ŒãŸæ›¸å¼ãŒ :class:`unicode` æ–‡å­—åˆ—ã®å ´åˆã€å¤‰æ›å¾Œã®æ–‡å­—åˆ—ã‚‚ :class:`unicode` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1588
msgid "See :pep:`237`."
msgstr ":pep:`237` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:1590
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr "Python æ–‡å­—åˆ—ã«ã¯æ˜ç¤ºçš„ãªé•·ã•æƒ…å ±ãŒã‚ã‚‹ã®ã§ã€ ``%s`` å¤‰æ›ã«ãŠã„ã¦ ``'\\0'`` ã‚’æ–‡å­—åˆ—ã®æœ«ç«¯ã¨ä»®å®šã—ãŸã‚Šã¯ã—ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1595
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr "çµ¶å¯¾å€¤ãŒ 1e50 ã‚’è¶…ãˆã‚‹æ•°å€¤ã® ``%f`` å¤‰æ›ãŒ ``%g`` å¤‰æ›ã«ç½®ãæ›ãˆã‚‰ã‚Œãªããªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:1603
msgid ""
"Additional string operations are defined in standard modules :mod:`string` "
"and :mod:`re`."
msgstr "ãã®ä»–ã®æ–‡å­—åˆ—æ“ä½œã¯æ¨™æº–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`string` ãŠã‚ˆã³ :mod:`re` ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1610
msgid "XRange Type"
msgstr "XRange å‹"

#: ../../library/stdtypes.rst:1614
msgid ""
"The :class:`xrange` type is an immutable sequence which is commonly used for"
" looping.  The advantage of the :class:`xrange` type is that an "
":class:`xrange` object will always take the same amount of memory, no matter"
" the size of the range it represents.  There are no consistent performance "
"advantages."
msgstr ":class:`xrange` å‹ã¯å€¤ã®å¤‰æ›´ä¸èƒ½ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã€åºƒç¯„ãªãƒ«ãƒ¼ãƒ—å‡¦ç†ã«ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ :class:`xrange` å‹ã®åˆ©ç‚¹ã¯ã€ :class:`xrange` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è¡¨ç¾ã™ã‚‹å€¤åŸŸã®å¤§ãã•ã«ã‹ã‹ã‚ã‚‰ãšå¸¸ã«åŒã˜é‡ã®ãƒ¡ãƒ¢ãƒªã—ã‹å ã‚ãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚ã¯ã£ãã‚Šã—ãŸãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä¸Šã®åˆ©ç‚¹ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1619
msgid ""
"XRange objects have very little behavior: they only support indexing, "
"iteration, and the :func:`len` function."
msgstr "XRange ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯éå¸¸ã«é™ã‚‰ã‚ŒãŸæŒ¯ã‚‹èˆã„ã€ã™ãªã‚ã¡ã€ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹æ¤œç´¢ã€åå¾©ã€ :func:`len` é–¢æ•°ã®ã¿ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1626
msgid "Mutable Sequence Types"
msgstr "ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹"

#: ../../library/stdtypes.rst:1632
msgid ""
"List and :class:`bytearray` objects support additional operations that allow"
" in-place modification of the object. Other mutable sequence types (when "
"added to the language) should also support these operations. Strings and "
"tuples are immutable sequence types: such objects cannot be modified once "
"created. The following operations are defined on mutable sequence types "
"(where *x* is an arbitrary object):"
msgstr "ãƒªã‚¹ãƒˆã¨ãƒã‚¤ãƒˆé…åˆ— (:class:`bytearray`) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã«å¤‰æ›´ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹è¿½åŠ ã®æ“ä½œã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ä»–ã®ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ (ã‚’è¨€èªã«è¿½åŠ ã™ã‚‹ã¨ã) ã‚‚ã€ãã‚Œã‚‰ã®æ“ä½œã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã¹ãã§ã™ã€‚æ–‡å­—åˆ—ãŠã‚ˆã³ã‚¿ãƒ—ãƒ«ã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã§ã™: ã“ã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸€åº¦ç”Ÿæˆã•ã‚ŒãŸã‚‰å¤‰æ›´ã§ãã¾ã›ã‚“ã€‚ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã§ã¯ä»¥ä¸‹ã®æ“ä½œãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™ (ã“ã“ã§ *x* ã¯ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:1659
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../library/stdtypes.rst:1659
msgid "item *i* of *s* is replaced by *x*"
msgstr "*s* ã®è¦ç´  *i* ã‚’ *x* ã¨å…¥ã‚Œæ›¿ãˆã¾ã™"

#: ../../library/stdtypes.rst:1662
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../library/stdtypes.rst:1662
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr "*s* ã® *i* ã‹ã‚‰ *j* ç•ªç›®ã¾ã§ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ã‚¤ãƒ†ãƒ©ãƒ–ãƒ« *t* ã®å†…å®¹ã«å…¥ã‚Œæ›¿ãˆã¾ã™"

#: ../../library/stdtypes.rst:1666
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../library/stdtypes.rst:1666
msgid "same as ``s[i:j] = []``"
msgstr "``s[i:j] = []`` ã¨åŒã˜ã§ã™"

#: ../../library/stdtypes.rst:1668
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../library/stdtypes.rst:1668
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "``s[i:j:k]`` ã®è¦ç´ ã‚’ *t* ã®è¦ç´ ã¨å…¥ã‚Œæ›¿ãˆã¾ã™"

#: ../../library/stdtypes.rst:1671
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../library/stdtypes.rst:1671
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "ãƒªã‚¹ãƒˆã‹ã‚‰ ``s[i:j:k]`` ã®è¦ç´ ã‚’å‰Šé™¤ã—ã¾ã™"

#: ../../library/stdtypes.rst:1674
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../library/stdtypes.rst:1674
msgid "same as ``s[len(s):len(s)] = [x]``"
msgstr "``s[len(s):len(s)] = [x]`` ã¨åŒã˜ã§ã™"

#: ../../library/stdtypes.rst:1677
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` ã¾ãŸã¯ ``s += t``"

#: ../../library/stdtypes.rst:1677
msgid "for the most part the same as ``s[len(s):len(s)] = t``"
msgstr "``s[len(s):len(s)] = t`` ã¨ã»ã¨ã‚“ã©åŒã˜ã§ã™"

#: ../../library/stdtypes.rst:1680
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../../library/stdtypes.rst:1680
msgid "updates *s* with its contents repeated *n* times"
msgstr "*s* ã‚’ãã®å†…å®¹ã‚’ *n*  å›ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã§æ›´æ–°"

#: ../../library/stdtypes.rst:1680
msgid "\\(11)"
msgstr "\\(11)"

#: ../../library/stdtypes.rst:1683
msgid "return number of *i*'s for which ``s[i] == x``"
msgstr "``s[i] == x`` ã¨ãªã‚‹ *i* ã®å€‹æ•°ã‚’è¿”ã—ã¾ã™"

#: ../../library/stdtypes.rst:1686
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../../library/stdtypes.rst:1686
msgid "return smallest *k* such that ``s[k] == x`` and ``i <= k < j``"
msgstr "``s[k] == x`` ã‹ã¤ ``i <= k < j`` ã¨ãªã‚‹æœ€å°ã® *k* ã‚’è¿”ã—ã¾ã™"

#: ../../library/stdtypes.rst:1690
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../library/stdtypes.rst:1690
msgid "same as ``s[i:i] = [x]``"
msgstr "``s[i:i] = [x]`` ã¨åŒã˜ã§ã™"

#: ../../library/stdtypes.rst:1692
msgid "``s.pop([i])``"
msgstr "``s.pop([i])``"

#: ../../library/stdtypes.rst:1692
msgid "same as ``x = s[i]; del s[i]; return x``"
msgstr "``x = s[i]; del s[i]; return x`` ã¨åŒã˜ã§ã™"

#: ../../library/stdtypes.rst:1695
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/stdtypes.rst:1695
msgid "same as ``del s[s.index(x)]``"
msgstr "``del s[s.index(x)]`` ã¨åŒã˜ã§ã™"

#: ../../library/stdtypes.rst:1697
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../library/stdtypes.rst:1697
msgid "reverses the items of *s* in place"
msgstr "*s* ã‚’ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã«é€†è»¢ã•ã›ã¾ã™"

#: ../../library/stdtypes.rst:1700
msgid "``s.sort([cmp[, key[, reverse]]])``"
msgstr "``s.sort([cmp[, key[, reverse]]])``"

#: ../../library/stdtypes.rst:1700
msgid "sort the items of *s* in place"
msgstr "*s* ã®è¦ç´ ã‚’ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã«ä¸¦ã¹æ›¿ãˆã¾ã™"

#: ../../library/stdtypes.rst:1700
msgid "(7)(8)(9)(10)"
msgstr "(7)(8)(9)(10)"

#: ../../library/stdtypes.rst:1707
msgid "*t* must have the same length as the slice it is  replacing."
msgstr "*t* ã¯ç½®ãæ›ãˆã‚‹ã‚¹ãƒ©ã‚¤ã‚¹ã¨åŒã˜é•·ã•ã§ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1710
msgid ""
"The C implementation of Python has historically accepted multiple parameters"
" and implicitly joined them into a tuple; this no longer works in Python "
"2.0.  Use of this misfeature has been deprecated since Python 1.4."
msgstr "ã‹ã¤ã¦ã® Python ã® C å®Ÿè£…ã§ã¯ã€è¤‡æ•°ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’å—ç†ã—ã€æš—é»™ã«ãã‚Œã‚‰ã‚’ã‚¿ãƒ—ãƒ«ã«çµåˆã—ã¦ã„ã¾ã—ãŸã€‚ã“ã®é–“é•ã£ãŸæ©Ÿèƒ½ã¯ Python 1.4 ã§æ’¤å»ƒã•ã‚Œã€ Python 2.0 ã®å°å…¥ã¨ã¨ã‚‚ã«ã‚¨ãƒ©ãƒ¼ã«ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:1715
msgid "*t* can be any iterable object."
msgstr "*x* ã¯ä»»æ„ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1718
msgid ""
"Raises :exc:`ValueError` when *x* is not found in *s*. When a negative index"
" is passed as the second or third parameter to the :meth:`index` method, the"
" list length is added, as for slice indices.  If it is still negative, it is"
" truncated to zero, as for slice indices."
msgstr "*x* ãŒ *s* ä¸­ã«è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ãŒäºŒç•ªç›®ã¾ãŸã¯ä¸‰ç•ªç›®ã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã¨ã—ã¦ :meth:`index` ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã•ã‚Œã‚‹ã¨ã€ã“ã‚Œã‚‰ã®å€¤ã«ã¯ã‚¹ãƒ©ã‚¤ã‚¹ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã¨åŒæ§˜ã«ãƒªã‚¹ãƒˆã®é•·ã•ãŒåŠ ç®—ã•ã‚Œã¾ã™ã€‚åŠ ç®—å¾Œã‚‚ã¾ã è² ã®å ´åˆã€ãã®å€¤ã¯ã‚¹ãƒ©ã‚¤ã‚¹ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã¨åŒæ§˜ã«ã‚¼ãƒ­ã«åˆ‡ã‚Šè©°ã‚ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1723
msgid ""
"Previously, :meth:`index` didn't have arguments for specifying start and "
"stop positions."
msgstr "ä»¥å‰ã¯ :meth:`index` ã«ã¯é–‹å§‹ã¨çµ‚äº†ä½ç½®ã‚’æŒ‡å®šã™ã‚‹å¼•æ•°ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚"

#: ../../library/stdtypes.rst:1728
msgid ""
"When a negative index is passed as the first parameter to the :meth:`insert`"
" method, the list length is added, as for slice indices.  If it is still "
"negative, it is truncated to zero, as for slice indices."
msgstr ":meth:`insert` ã®æœ€åˆã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã¨ã—ã¦è² ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ãŒæ¸¡ã•ã‚ŒãŸå ´åˆã€ã‚¹ãƒ©ã‚¤ã‚¹ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã¨åŒã˜ãã€ãƒªã‚¹ãƒˆã®é•·ã•ãŒåŠ ç®—ã•ã‚Œã¾ã™ã€‚ãã‚Œã§ã‚‚è² ã®å€¤ã‚’å–ã‚‹å ´åˆã€ã‚¹ãƒ©ã‚¤ã‚¹ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã¨åŒã˜ãã€ 0 ã«ä¸¸ã‚ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1732
msgid "Previously, all negative indices were truncated to zero."
msgstr "ä»¥å‰ã¯ã€ã™ã¹ã¦ã®è² å€¤ã¯ 0 ã«ä¸¸ã‚ã‚‰ã‚Œã¦ã„ã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:1736
msgid ""
"The :meth:`pop` method's optional argument *i* defaults to ``-1``, so that "
"by default the last item is removed and returned."
msgstr ":meth:`pop` ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *i* ã¯æ¨™æº–ã§ ``-1`` ãªã®ã§ã€æ¨™æº–ã§ã¯æœ€å¾Œã®è¦ç´ ã‚’ãƒªã‚¹ãƒˆã‹ã‚‰é™¤å»ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1740
msgid ""
"The :meth:`sort` and :meth:`reverse` methods modify the list in place for "
"economy of space when sorting or reversing a large list.  To remind you that"
" they operate by side effect, they don't return the sorted or reversed list."
msgstr ":meth:`sort` ãŠã‚ˆã³ :meth:`reverse` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¤§ããªãƒªã‚¹ãƒˆã‚’ä¸¦ã¹æ›¿ãˆãŸã‚Šåè»¢ã—ãŸã‚Šã™ã‚‹éš›ã€å®¹é‡ã®ç¯€ç´„ã®ãŸã‚ã«ãƒªã‚¹ãƒˆã‚’ç›´æ¥å¤‰æ›´ã—ã¾ã™ã€‚å‰¯ä½œç”¨ãŒã‚ã‚‹ã“ã¨ã‚’ãƒ¦ãƒ¼ã‚¶ã«æ€ã„å‡ºã•ã›ã‚‹ãŸã‚ã«ã€ã“ã‚Œã‚‰ã®æ“ä½œã¯ä¸¦ã¹æ›¿ãˆã¾ãŸã¯åè»¢ã•ã‚ŒãŸãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1745
msgid ""
"The :meth:`sort` method takes optional arguments for controlling the "
"comparisons."
msgstr ":meth:`sort` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æ¯”è¼ƒã‚’åˆ¶å¾¡ã™ã‚‹ãŸã‚ã«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•°ã‚’ã¨ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1748
msgid ""
"*cmp* specifies a custom comparison function of two arguments (list items) "
"which should return a negative, zero or positive number depending on whether"
" the first argument is considered smaller than, equal to, or larger than the"
" second argument: ``cmp=lambda x,y: cmp(x.lower(), y.lower())``.  The "
"default value is ``None``."
msgstr "*cmp* ã¯2ã¤ã®å¼•æ•° (ãƒªã‚¹ãƒˆã®è¦ç´ ) ã‹ã‚‰ãªã‚‹ã‚«ã‚¹ã‚¿ãƒ ã®æ¯”è¼ƒé–¢æ•°ã‚’æŒ‡å®šã—ã¾ã™ã€‚ ã“ã‚Œã¯å§‹ã‚ã®å¼•æ•°ãŒ 2 ã¤ç›®ã®å¼•æ•°ã«æ¯”ã¹ã¦å°ã•ã„ã€ç­‰ã—ã„ã€å¤§ãã„ã‹ã«å¿œã˜ã¦è² æ•°ã€ã‚¼ãƒ­ã€æ­£æ•°ã‚’è¿”ã—ã¾ã™ã€‚ ``cmp=lambda x,y: cmp(x.lower(), y.lower())`` ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ ``None`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1754
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element: ``key=str.lower``.  The default value"
" is ``None``."
msgstr "*key* ã¯ 1 ã¤ã®å¼•æ•°ã‹ã‚‰ãªã‚‹é–¢æ•°ã‚’æŒ‡å®šã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒªã‚¹ãƒˆã®å„è¦ç´ ã‹ã‚‰æ¯”è¼ƒã®ã‚­ãƒ¼ã‚’å–ã‚Šå‡ºã™ã®ã«ä½¿ã‚ã‚Œã¾ã™: ``key=str.lower``ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ ``None`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1757
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr "*reverse* ã¯ãƒ–ãƒ¼ãƒ«å€¤ã§ã™ã€‚``True`` ã«è¨­å®šã•ã‚ŒãŸå ´åˆã€ãƒªã‚¹ãƒˆã®è¦ç´ ã¯å„æ¯”è¼ƒãŒåè»¢ã—ãŸã‚ˆã†ã«ä¸¦ã³æ›¿ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1760
msgid ""
"In general, the *key* and *reverse* conversion processes are much faster "
"than specifying an equivalent *cmp* function.  This is because *cmp* is "
"called multiple times for each list element while *key* and *reverse* touch "
"each element only once.  Use :func:`functools.cmp_to_key` to convert an old-"
"style *cmp* function to a *key* function."
msgstr "ä¸€èˆ¬çš„ã«ã€ *key* ãŠã‚ˆã³ *reverse* ã®å¤‰æ›ãƒ—ãƒ­ã‚»ã‚¹ã¯åŒç­‰ã® *cmp* é–¢æ•°ã‚’æŒ‡å®šã™ã‚‹ã‚ˆã‚Šæ—©ãå‹•ä½œã—ã¾ã™ã€‚ã“ã‚Œã¯ *key* ãŠã‚ˆã³ *reverse* ãŒãã‚Œãã‚Œã®è¦ç´ ã«ä¸€åº¦ã ã‘è§¦ã‚Œã‚‹é–“ã«ã€ *cmp* ã¯ãƒªã‚¹ãƒˆã®ãã‚Œãã‚Œã®è¦ç´ ã«å¯¾ã—ã¦è¤‡æ•°å›å‘¼ã°ã‚Œã‚‹ã“ã¨ã«ã‚ˆã‚‹ã‚‚ã®ã§ã™ã€‚æ—§å¼ã® *cmp* é–¢æ•°ã‚’ *key* é–¢æ•°ã«å¤‰æ›ã™ã‚‹ã«ã¯ :func:`functools.cmp_to_key` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:1766
msgid "Support for ``None`` as an equivalent to omitting *cmp* was added."
msgstr "``None`` ã‚’æ¸¡ã™ã®ã¨ã€ *cmp* ã‚’çœç•¥ã—ãŸå ´åˆã¨ã§ã€åŒç­‰ã«æ‰±ã†ã‚µãƒãƒ¼ãƒˆã‚’è¿½åŠ ."

#: ../../library/stdtypes.rst:1769
msgid "Support for *key* and *reverse* was added."
msgstr "*key* ãŠã‚ˆã³ *reverse* ã®ã‚µãƒãƒ¼ãƒˆã‚’è¿½åŠ ."

#: ../../library/stdtypes.rst:1773
msgid ""
"Starting with Python 2.3, the :meth:`sort` method is guaranteed to be "
"stable.  A sort is stable if it guarantees not to change the relative order "
"of elements that compare equal --- this is helpful for sorting in multiple "
"passes (for example, sort by department, then by salary grade)."
msgstr "Python 2.3 ã‚ˆã‚Šã€ :meth:`sort` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å®‰å®šã—ã¦ã„ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã¾ã™ã€‚ã‚½ãƒ¼ãƒˆã¯ã€ç­‰ã—ã„è¦ç´ ã®ç›¸å¯¾é †åºãŒå¤‰æ›´ã•ã‚Œãªã„ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã‚Œã°ã€å®‰å®šã—ã¦ã„ã¾ã™ --- ã“ã‚Œã¯è¤‡åˆçš„ãªãƒ‘ã‚¹ã§ã‚½ãƒ¼ãƒˆã‚’è¡Œãªã†ï¼ˆä¾‹ãˆã°éƒ¨ç½²ã§ã‚½ãƒ¼ãƒˆã—ã¦ã€ãã‚Œã‹ã‚‰çµ¦ä¸ã®ç­‰ç´šã§ã‚½ãƒ¼ãƒˆã™ã‚‹ï¼‰ã®ã«å½¹ç«‹ã¡ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1781
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python 2.3 and "
"newer makes the list appear empty for the duration, and raises "
":exc:`ValueError` if it can detect that the list has been mutated during a "
"sort."
msgstr "ãƒªã‚¹ãƒˆãŒã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹é–“ã€ã¾ãŸã¯å¤‰æ›´ã—ã‚ˆã†ã¨ã™ã‚‹è©¦ã¿ã®å½±éŸ¿ä¸­ã€ã‚ã‚‹ã„ã¯æ¤œæŸ»ä¸­ã§ã•ãˆã€ãƒªã‚¹ãƒˆã¯æœªå®šç¾©ã§ã™ã€‚Python 2.3 ã¨ãã‚Œä»¥é™ã® C å®Ÿè£…ã§ã¯ã€ãã‚Œã‚‰ãŒç¶šã„ã¦ã„ã‚‹é–“ã€ãƒªã‚¹ãƒˆã¯ç©ºã¨ã—ã¦å‡ºåŠ›ã•ã‚Œã€ãƒªã‚¹ãƒˆãŒã‚½ãƒ¼ãƒˆä¸­ã«å¤‰æ›´ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’æ¤œçŸ¥ã§ããŸã‚‰ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1788
msgid ""
"The value *n* is an integer, or an object implementing "
":meth:`~object.__index__`.  Zero and negative values of *n* clear the "
"sequence.  Items in the sequence are not copied; they are referenced "
"multiple times, as explained for ``s * n`` under :ref:`typesseq`."
msgstr "å€¤ *n* ã¯æ•´æ•°ã¾ãŸã¯ :meth:`~object.__index__` ã‚’å®Ÿè£…ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ *n* ã«ã‚¼ãƒ­ã‚„è² æ•°ã‚’ä¸ãˆã‚‹ã¨ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å†…ã®è¦ç´ ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã›ã‚“; ã‚³ãƒ”ãƒ¼ã§ã¯ãªãè¦ç´ ã«å¯¾ã™ã‚‹å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒå¢—ãˆã¾ã™ã€‚ ``s * n`` ã«ã¤ã„ã¦ :ref:`typesseq` ã§èª¬æ˜ã—ãŸã¨ãŠã‚Šã§ã™ã€‚"

#: ../../library/stdtypes.rst:1797
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "setï¼ˆé›†åˆï¼‰å‹ --- :class:`set`, :class:`frozenset`"

#: ../../library/stdtypes.rst:1801
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union,"
" difference, and symmetric difference. (For other containers see the built "
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the "
":mod:`collections` module.)"
msgstr ":dfn:`set` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é †åºä»˜ã‘ã•ã‚Œã¦ã„ãªã„ :term:`hashable` (ãƒãƒƒã‚·ãƒ¥å¯èƒ½ãª) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚ã‚ˆãã‚ã‚‹ä½¿ã„æ–¹ã«ã¯ã€ãƒ¡ãƒ³ãƒãƒ¼ã‚·ãƒƒãƒ—ã®ãƒ†ã‚¹ãƒˆã€æ•°åˆ—ã‹ã‚‰é‡è¤‡ã‚’å‰Šé™¤ã™ã‚‹ã€ãã—ã¦è«–ç†ç©ã€è«–ç†å’Œã€å·®é›†åˆã€å¯¾ç§°å·®ãªã©æ•°å­¦çš„æ¼”ç®—ã®è¨ˆç®—ãŒå«ã¾ã‚Œã¾ã™ã€‚ (ä»–ã®ã‚³ãƒ³ãƒ†ãƒŠå‹ã«ã¤ã„ã¦ã¯ã€çµ„ã¿è¾¼ã¿ã‚¯ãƒ©ã‚¹ã® :class:`dict`, :class:`list`, :class:`tuple`,ãŠã‚ˆã³ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`collections` ã‚’å‚ç…§ä¸‹ã•ã„)"

#: ../../library/stdtypes.rst:1811
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x"
" in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr "é›†åˆã¯ã€ä»–ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¨åŒæ§˜ã€ ``x in set``, ``len(set)``, ``for x in set`` ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ã¯é †åºãŒãªã„ã®ã§ã€é›†åˆã¯æŒ¿å…¥ã®é †åºã‚„è¦ç´ ã®ä½ç½®ã‚’è¨˜éŒ²ã—ã¾ã›ã‚“ã€‚å¾“ã£ã¦ã€é›†åˆã¯ã‚¤ãƒ³ãƒ‡ã‚¯ã‚·ãƒ³ã‚°ã€ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ã€ãã®ä»–ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹çš„ãªæŒ¯èˆã„ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1816
msgid ""
"There are currently two built-in set types, :class:`set` and "
":class:`frozenset`. The :class:`set` type is mutable --- the contents can be"
" changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since"
" it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type"
" is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element"
" of another set."
msgstr ":class:`set` ãŠã‚ˆã³ :class:`frozenset` ã¨ã„ã†ã€2ã¤ã®çµ„ã¿è¾¼ã¿ã®é›†åˆå‹ãŒã‚ã‚Šã¾ã™ã€‚ :class:`set` ã¯ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã§ã€:meth:`~set.add` ã‚„ :meth:`~set.remove` ã®ã‚ˆã†ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦å†…å®¹ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªãŸã‚ã€ãƒãƒƒã‚·ãƒ¥å€¤ã‚’æŒãŸãšã€ã¾ãŸè¾æ›¸ã®ã‚­ãƒ¼ã‚„ä»–ã®é›†åˆã®è¦ç´ ã¨ã—ã¦ç”¨ã„ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ä¸€æ–¹ã€:class:`frozenset` å‹ã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã§ã€:term:`ãƒãƒƒã‚·ãƒ¥å¯èƒ½<hashable>` ã§ã™ã€‚ä½œæˆå¾Œã«å†…å®¹ã‚’æ”¹å¤‰ã§ããªã„ãŸã‚ã€è¾æ›¸ã®ã‚­ãƒ¼ã‚„ä»–ã®é›†åˆã®è¦ç´ ã¨ã—ã¦ç”¨ã„ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1824
msgid ""
"As of Python 2.7, non-empty sets (not frozensets) can be created by placing "
"a comma-separated list of elements within braces, for example: ``{'jack', "
"'sjoerd'}``, in addition to the :class:`set` constructor."
msgstr "Python 2.7 ã§ã¯ã€ç©ºã§ãªã„ set (frozenset ã§ã¯ãªã„) ã¯ã€ :class:`set` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«åŠ ãˆã€è¦ç´ ã‚’æ³¢ã‚«ãƒƒã‚³ä¸­ã«ã‚«ãƒ³ãƒã§åŒºåˆ‡ã£ã¦åˆ—æŒ™ã™ã‚‹ã“ã¨ã§ã‚‚ç”Ÿæˆã§ãã¾ã™ã€‚ä¾‹: ``{'jack', 'sjoerd'}``."

#: ../../library/stdtypes.rst:1828
msgid "The constructors for both classes work the same:"
msgstr "ã©ã¡ã‚‰ã®ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚‚åŒæ§˜ã«åƒãã¾ã™:"

#: ../../library/stdtypes.rst:1833
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr "*iterable* ã‹ã‚‰è¦ç´ ã‚’å–ã‚Šè¾¼ã‚“ã ã€æ–°ã—ã„ :class:`set` ã‚‚ã—ãã¯ :class:`frozenset` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ é›†åˆã®è¦ç´ ã¯ :term:`ãƒãƒƒã‚·ãƒ¥å¯èƒ½ <hashable>` ãªã‚‚ã®ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚é›†åˆã®é›†åˆã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ã¯ã€å†…å´ã®é›†åˆã¯ :class:`frozenset` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚*iterable* ãŒæŒ‡å®šã•ã‚Œãªã„å ´åˆã€æ–°ã—ã„ç©ºã®é›†åˆãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1839
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ":class:`set` ãŠã‚ˆã³ :class:`frozenset` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ä»¥ä¸‹ã®æ“ä½œã‚’æä¾›ã—ã¾ã™:"

#: ../../library/stdtypes.rst:1844
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "é›†åˆ *s* ã®è¦ç´ æ•° (*s* ã®æ¿ƒåº¦) ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1848
msgid "Test *x* for membership in *s*."
msgstr "*x* ãŒ *s* ã®ãƒ¡ãƒ³ãƒãƒ¼ã«å«ã¾ã‚Œã‚‹ã‹åˆ¤å®šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1852
msgid "Test *x* for non-membership in *s*."
msgstr "*x* ãŒ *s* ã®ãƒ¡ãƒ³ãƒãƒ¼ã«å«ã¾ã‚Œã¦ã„ãªã„ã“ã¨ã‚’åˆ¤å®šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1856
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are"
" disjoint if and only if their intersection is the empty set."
msgstr "é›†åˆãŒ *other* ã¨å…±é€šã®è¦ç´ ã‚’æŒãŸãªã„ã¨ãã€``True`` ã‚’è¿”ã—ã¾ã™ã€‚é›†åˆã¯ãã‚Œã‚‰ã®ç©é›†åˆãŒç©ºé›†åˆã¨ãªã‚‹ã¨ãã®ã¿ã€äº’ã„ã«ç´  (disjoint) ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1864
msgid "Test whether every element in the set is in *other*."
msgstr "set ã®å…¨ã¦ã®è¦ç´ ãŒ *other* ã«å«ã¾ã‚Œã‚‹ã‹åˆ¤å®šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1868
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr "set ãŒ *other* ã®çœŸéƒ¨åˆ†é›†åˆã§ã‚ã‚‹ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ ``set <= other and set != other`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1874
msgid "Test whether every element in *other* is in the set."
msgstr "*other* ã®å…¨ã¦ã®è¦ç´ ãŒ set ã«å«ã¾ã‚Œã‚‹ã‹åˆ¤å®šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1878
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr "set ãŒ *other* ã®çœŸä¸Šä½é›†åˆã§ã‚ã‚‹ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ ``set >= other and set != other`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1884
msgid "Return a new set with elements from the set and all others."
msgstr "set ã¨å…¨ã¦ã® other ã®è¦ç´ ã‹ã‚‰ãªã‚‹æ–°ã—ã„é›†åˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1886 ../../library/stdtypes.rst:1894
#: ../../library/stdtypes.rst:1902 ../../library/stdtypes.rst:1956
#: ../../library/stdtypes.rst:1964 ../../library/stdtypes.rst:1972
msgid "Accepts multiple input iterables."
msgstr "è¤‡æ•°ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‹ã‚‰ã®å…¥åŠ›ã‚’å—ã‘å…¥ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:1892
msgid "Return a new set with elements common to the set and all others."
msgstr "set ã¨å…¨ã¦ã® other ã«å…±é€šã™ã‚‹è¦ç´ ã‚’æŒã¤ã€æ–°ã—ã„é›†åˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1900
msgid "Return a new set with elements in the set that are not in the others."
msgstr "set ã«å«ã¾ã‚Œã¦ã€ã‹ã¤ã€å…¨ã¦ã® other ã«å«ã¾ã‚Œãªã„è¦ç´ ã‚’æŒã¤ã€æ–°ã—ã„é›†åˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1908
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr "set ã¨ *other* ã®ã„ãšã‚Œã‹ä¸€æ–¹ã ã‘ã«å«ã¾ã‚Œã‚‹è¦ç´ ã‚’æŒã¤æ–°ã—ã„é›†åˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1912
msgid "Return a new set with a shallow copy of *s*."
msgstr "*s* ã®æµ…ã„ã‚³ãƒ”ãƒ¼ã‚’æ–°ã—ã„é›†åˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1915
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, "
":meth:`difference`, and :meth:`symmetric_difference`, :meth:`issubset`, and "
":meth:`issuperset` methods will accept any iterable as an argument.  In "
"contrast, their operator based counterparts require their arguments to be "
"sets.  This precludes error-prone constructions like ``set('abc') & 'cbs'`` "
"in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr "ãªãŠã€æ¼”ç®—å­ã§ãªã„ç‰ˆã® :meth:`union`, :meth:`intersection`, :meth:`difference`, :meth:`symmetric_difference`, :meth:`issubset`, :meth:`issuperset` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä»»æ„ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’å¼•æ•°ã¨ã—ã¦å—ã‘ä»˜ã‘ã¾ã™ã€‚å¯¾ã—ã¦ã€æ¼”ç®—å­ã‚’ä½¿ã†ç‰ˆã§ã¯ã€å¼•æ•°ã¯é›†åˆã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€``set('abc') & 'cbs'`` ã®ã‚ˆã†ãªèª¤ã‚ŠãŒã¡ãªæ§‹æ–‡ã‚’äºˆé˜²ã—ã€ã‚ˆã‚Šèª­ã¿ã‚„ã™ã„ ``set('abc').intersection('cbs')`` ã‚’æ”¯æŒã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1922
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two"
" sets are equal if and only if every element of each set is contained in the"
" other (each is a subset of the other). A set is less than another set if "
"and only if the first set is a proper subset of the second set (is a subset,"
" but is not equal). A set is greater than another set if and only if the "
"first set is a proper superset of the second set (is a superset, but is not "
"equal)."
msgstr ":class:`set` ã¨ :class:`frozenset` ã®ã©ã¡ã‚‰ã‚‚ã€é›†åˆåŒå£«ã®æ¯”è¼ƒã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚äºŒã¤ã®é›†åˆã¯ã€ãã‚Œãã‚Œã®é›†åˆã®è¦ç´ å…¨ã¦ãŒä»–æ–¹ã«ã‚‚å«ã¾ã‚Œã¦ã„ã‚‹ (äº’ã„ã«ä»–æ–¹ã®éƒ¨åˆ†é›†åˆã§ã‚ã‚‹) ã¨ãã€ã‹ã¤ãã®ã¨ãã«é™ã‚Šç­‰ã—ã„ã§ã™ã€‚ä¸€æ–¹ã®é›†åˆãŒä»–æ–¹ã®é›†åˆã®çœŸéƒ¨åˆ†é›†åˆã§ã‚ã‚‹ (éƒ¨åˆ†é›†åˆã§ã‚ã‚‹ãŒç­‰ã—ããªã„) ã¨ãã€ã‹ã¤ãã®ã¨ãã«é™ã‚Šä¸€æ–¹ã®é›†åˆã¯ä»–æ–¹ã®é›†åˆã‚ˆã‚Šå°ã•ã„ã§ã™ã€‚ä¸€æ–¹ã®é›†åˆãŒä»–æ–¹ã®é›†åˆã®çœŸä¸Šä½é›†åˆã§ã‚ã‚‹ (ä¸Šä½é›†åˆã§ã‚ã‚‹ãŒç­‰ã—ããªã„) ã¨ãã€ã‹ã¤ãã®ã¨ãã«é™ã‚Šä¸€æ–¹ã®é›†åˆã¯ä»–æ–¹ã®é›†åˆã‚ˆã‚Šå¤§ãã„ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1929
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ":class:`set` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ :class:`frozenset` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã€è¦ç´ ã«åŸºã¥ã„ã¦æ¯”è¼ƒã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ``set('abc') == frozenset('abc')`` ã‚„ ``set('abc') in set([frozenset('abc')])`` ã¯ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1933
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two non-empty disjoint sets are not equal and "
"are not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``. Accordingly, sets do not implement the "
":meth:`__cmp__` method."
msgstr "éƒ¨åˆ†é›†åˆã¨ç­‰ä¾¡æ€§ã®æ¯”è¼ƒã¯å…¨é †åºä»˜ã‘ã‚’è¡Œã†é–¢æ•°ã¸ã¨ä¸€èˆ¬åŒ–ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€äº’ã„ã«ç´ ã§ã‚ã‚‹äºŒã¤ã®éç©ºé›†åˆã¯ã€ç­‰ã—ããªãã€ä»–æ–¹ã®éƒ¨åˆ†é›†åˆã§ã‚‚ã‚ã‚Šã¾ã›ã‚“ã‹ã‚‰ã€ä»¥ä¸‹ã® *ã™ã¹ã¦* ã« ``False`` ã‚’è¿”ã—ã¾ã™: ``a<b``, ``a==b``, ãã—ã¦ ``a>b`` ã€‚ãã®ãŸã‚ã€ set ã¯ :meth:`__cmp__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1939
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr "é›†åˆã¯åŠé †åºï¼ˆéƒ¨åˆ†é›†åˆé–¢ä¿‚ï¼‰ã—ã‹å®šç¾©ã—ãªã„ã®ã§ã€é›†åˆã®ãƒªã‚¹ãƒˆã«ãŠã‘ã‚‹ :meth:`list.sort` ãƒ¡ã‚½ãƒƒãƒ‰ã®å‡ºåŠ›ã¯æœªå®šç¾©ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1942
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr "é›†åˆã®è¦ç´ ã¯ã€è¾æ›¸ã®ã‚­ãƒ¼ã®ã‚ˆã†ã«ã€ãƒãƒƒã‚·ãƒ¥å¯èƒ½ (:term:`hashable`) ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1944
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ":class:`set` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ :class:`frozenset` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–ã‚Šæ··ãœã¦ã®äºŒé …æ¼”ç®—ã¯ã€ç¬¬ä¸€è¢«æ¼”ç®—å­ã®å‹ã‚’è¿”ã—ã¾ã™ã€‚ä¾‹ãˆã°: ``frozenset('ab') | set('bc')`` ã¯ :class:`frozenset` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1948
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr "ä»¥ä¸‹ã®è¡¨ã«æŒ™ã’ã‚‹æ¼”ç®—ã¯ :class:`set` ã«é©ç”¨ã•ã‚Œã¾ã™ãŒã€:class:`frozenset` ã®ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã¯é©ç”¨ã•ã‚Œã¾ã›ã‚“:"

#: ../../library/stdtypes.rst:1954
msgid "Update the set, adding elements from all others."
msgstr "å…¨ã¦ã® other ã®è¦ç´ ã‚’è¿½åŠ ã—ã€ set ã‚’æ›´æ–°ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1962
msgid "Update the set, keeping only elements found in it and all others."
msgstr "å…ƒã® set ã¨å…¨ã¦ã® other ã«å…±é€šã™ã‚‹è¦ç´ ã ã‘ã‚’æ®‹ã—ã¦ set ã‚’æ›´æ–°ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1970
msgid "Update the set, removing elements found in others."
msgstr "*other* ã«å«ã¾ã‚Œã‚‹è¦ç´ ã‚’å–ã‚Šé™¤ãã€ set ã‚’æ›´æ–°ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1978
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr "ã©ã¡ã‚‰ã‹ã«ã®ã¿å«ã¾ã‚Œã¦ã€å…±é€šã«ã¯æŒãŸãªã„è¦ç´ ã®ã¿ã§ set ã‚’æ›´æ–°ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1982
msgid "Add element *elem* to the set."
msgstr "è¦ç´  *elem* ã‚’ set ã«è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1986
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not"
" contained in the set."
msgstr "è¦ç´  *elem* ã‚’ set ã‹ã‚‰å–ã‚Šé™¤ãã¾ã™ã€‚*elem* ãŒ set ã«å«ã¾ã‚Œã¦ã„ãªã‘ã‚Œã° :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1991
msgid "Remove element *elem* from the set if it is present."
msgstr "è¦ç´  *elem* ãŒ set ã«å«ã¾ã‚Œã¦ã„ã‚Œã°ã€å–ã‚Šé™¤ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1995
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError`"
" if the set is empty."
msgstr "ä»»æ„ã«è¦ç´ ã‚’ã‹ã‚‰è¿”ã—ã€ãã‚Œã‚’ set ã‹ã‚‰å–ã‚Šé™¤ãã¾ã™ã€‚set ãŒç©ºã§ã‚ã‚Œã°ã€ :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2000
msgid "Remove all elements from the set."
msgstr "set ã®å…¨ã¦ã®è¦ç´ ã‚’å–ã‚Šé™¤ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2003
msgid ""
"Note, the non-operator versions of the :meth:`update`, "
":meth:`intersection_update`, :meth:`difference_update`, and "
":meth:`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr "ãªãŠã€æ¼”ç®—å­ã§ãªã„ç‰ˆã® :meth:`update`, :meth:`intersection_update`, :meth:`difference_update`, ãŠã‚ˆã³ :meth:`symmetric_difference_update` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä»»æ„ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’å¼•æ•°ã¨ã—ã¦å—ã‘ä»˜ã‘ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2008
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and "
":meth:`discard` methods may be a set.  To support searching for an "
"equivalent frozenset, a temporary one is created from *elem*."
msgstr ":meth:`__contains__`, :meth:`remove`, :meth:`discard` ãƒ¡ã‚½ãƒƒãƒ‰ã®å¼•æ•° *elem* ã¯é›†åˆã‹ã‚‚ã—ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚\nãã®é›†åˆã¨ç­‰ä¾¡ãª :class:`frozenset` ã®æ¤œç´¢ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ã€ *elem* ã‹ã‚‰ä¸€æ™‚çš„ãª frozenset ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2015
msgid ":ref:`comparison-to-builtin-set`"
msgstr ":ref:`comparison-to-builtin-set`"

#: ../../library/stdtypes.rst:2016
msgid "Differences between the :mod:`sets` module and the built-in set types."
msgstr ":mod:`sets` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨çµ„ã¿è¾¼ã¿ set å‹ã®é•ã„"

#: ../../library/stdtypes.rst:2022
msgid "Mapping Types --- :class:`dict`"
msgstr "ãƒãƒƒãƒ”ãƒ³ã‚°å‹ --- :class:`dict`"

#: ../../library/stdtypes.rst:2032
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built in "
":class:`list`, :class:`set`, and :class:`tuple` classes, and the "
":mod:`collections` module.)"
msgstr "ãƒãƒƒãƒ”ãƒ³ã‚° (:term:`mapping`) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒãƒƒã‚·ãƒ¥å¯èƒ½ (:term:`hashable`) ãªå€¤ã‚’ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾å¿œä»˜ã‘ã¾ã™ã€‚ãƒãƒƒãƒ”ãƒ³ã‚°ã¯ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ç¾åœ¨ã€æ¨™æº–ãƒãƒƒãƒ”ãƒ³ã‚°å‹ã¯è¾æ›¸ (:dfn:`dictionary`) ã ã‘ã§ã™ã€‚ (ä»–ã®ã‚³ãƒ³ãƒ†ãƒŠã«ã¤ã„ã¦ã¯çµ„ã¿è¾¼ã¿ã® :class:`list`, :class:`set`, ãŠã‚ˆã³ :class:`tuple` ã‚¯ãƒ©ã‚¹ã¨ã€ :mod:`collections` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ä¸‹ã•ã„ã€‚)"

#: ../../library/stdtypes.rst:2038
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not "
":term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys.  Numeric types used for keys obey the normal rules "
"for numeric comparison: if two numbers compare equal (such as ``1`` and "
"``1.0``) then they can be used interchangeably to index the same dictionary "
"entry.  (Note however, that since computers store floating-point numbers as "
"approximations it is usually unwise to use them as dictionary keys.)"
msgstr "è¾æ›¸ã®ã‚­ãƒ¼ã¯ *ã»ã¼* ä»»æ„ã®å€¤ã§ã™ã€‚ãƒãƒƒã‚·ãƒ¥å¯èƒ½ (:term:`hashable`) ã§ãªã„å€¤ã€ã¤ã¾ã‚Šã€ãƒªã‚¹ãƒˆã‚„è¾æ›¸ãã®ä»–ã®ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªå‹ (ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŒä¸€æ€§ã§ã¯ãªãå€¤ã§æ¯”è¼ƒã•ã‚Œã‚‹ã‚‚ã®) ã¯ã‚­ãƒ¼ã¨ã—ã¦ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚ã‚­ãƒ¼ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹æ•°å€¤å‹ã¯é€šå¸¸ã®æ•°å€¤æ¯”è¼ƒã®ãƒ«ãƒ¼ãƒ«ã«å¾“ã„ã¾ã™: ã‚‚ã—ãµãŸã¤ã®æ•°å€¤ãŒ (ä¾‹ãˆã° ``1`` ã¨ ``1.0`` ã®ã‚ˆã†ã«) ç­‰ã—ã‘ã‚Œã°ã€åŒã˜è¾æ›¸ã®é …ç›®ã¨ã—ã¦äº’æ›çš„ã«ä½¿ç”¨ã§ãã¾ã™ã€‚ (ãŸã ã—ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã¯æµ®å‹•å°æ•°ç‚¹æ•°ã‚’è¿‘ä¼¼å€¤ã¨ã—ã¦ä¿ç®¡ã™ã‚‹ã®ã§ã€è¾æ›¸å‹ã®ã‚­ãƒ¼ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ã®ã¯ãŸã„ã¦ã„è³¢ãã‚ã‚Šã¾ã›ã‚“ã€‚)"

#: ../../library/stdtypes.rst:2047
msgid ""
"Dictionaries can be created by placing a comma-separated list of ``key: "
"value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}``"
" or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` constructor."
msgstr "è¾æ›¸ã¯ ``key: value`` å¯¾ã®ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã®ãƒªã‚¹ãƒˆã‚’æ³¢æ‹¬å¼§ã§ããã‚‹ã“ã¨ã§ä½œæˆã§ãã¾ã™ã€‚ä¾‹ãˆã°: ``{'jack': 4098, 'sjoerd': 4127}`` ã‚ã‚‹ã„ã¯ ``{4098: 'jack', 4127: 'sjoerd'}`` ã€‚ã‚ã‚‹ã„ã¯ã€ :class:`dict` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã‚‚ä½œæˆã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2055
msgid ""
"Return a new dictionary initialized from an optional positional argument and"
" a possibly empty set of keyword arguments."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ä½ç½®å¼•æ•°ã¨ç©ºé›†åˆã®å¯èƒ½æ€§ã‚‚ã‚ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‹ã‚‰åˆæœŸåŒ–ã•ã‚ŒãŸæ–°ã—ã„è¾æ›¸ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2058
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the"
" positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr "ä½ç½®å¼•æ•°ãŒä½•ã‚‚ä¸ãˆã‚‰ã‚Œãªã‹ã£ãŸå ´åˆã€ç©ºã®è¾æ›¸ãŒä½œæˆã•ã‚Œã¾ã™ã€‚ä½ç½®å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œã€ãã‚ŒãŒãƒãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã ã£ãŸå ´åˆã€ãã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒã˜ã‚­ãƒ¼ã¨å€¤ã®ãƒšã‚¢ã‚’æŒã¤è¾æ›¸ãŒä½œæˆã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã€ä½ç½®å¼•æ•°ã¯ :term:`iterable` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚iterable ã®ãã‚Œãã‚Œã®è¦ç´ è‡ªèº«ã¯ã€ã¡ã‚‡ã†ã© 2 å€‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒã¤ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã‚Œãã‚Œã®è¦ç´ ã®æœ€åˆã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ–°ã—ã„è¾æ›¸ã®ã‚­ãƒ¼ã«ãªã‚Šã€2 ç•ªç›®ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã‚Œã«å¯¾å¿œã™ã‚‹å€¤ã«ãªã‚Šã¾ã™ã€‚åŒä¸€ã®ã‚­ãƒ¼ãŒ 2 å›ä»¥ä¸Šç¾ã‚ŒãŸå ´åˆã¯ã€ãã®ã‚­ãƒ¼ã®æœ€å¾Œã®å€¤ãŒæ–°ã—ã„è¾æ›¸ã§ã®å¯¾å¿œã™ã‚‹å€¤ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2068
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces"
" the value from the positional argument."
msgstr "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ãã®å€¤ãŒä½ç½®å¼•æ•°ã‹ã‚‰ä½œã‚‰ã‚ŒãŸè¾æ›¸ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚æ—¢ã«å­˜åœ¨ã—ã¦ã„ã‚‹ã‚­ãƒ¼ãŒè¿½åŠ ã•ã‚ŒãŸå ´åˆã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®å€¤ã¯ä½ç½®å¼•æ•°ã®å€¤ã‚’ç½®ãæ›ãˆã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2073
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr "ä¾‹ã‚’å‡ºã™ã¨ã€æ¬¡ã®ä¾‹ã¯å…¨ã¦ ``{\"one\": 1, \"two\": 2, \"three\": 3}`` ã«ç­‰ã—ã„è¾æ›¸ã‚’è¿”ã—ã¾ã™::"

#: ../../library/stdtypes.rst:2084
msgid ""
"Providing keyword arguments as in the first example only works for keys that"
" are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr "æœ€åˆã®ä¾‹ã®ã‚ˆã†ã«ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ä¸ãˆã‚‹æ–¹æ³•ã§ã¯ã€ã‚­ãƒ¼ã¯æœ‰åŠ¹ãª Python ã®è­˜åˆ¥å­ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã®æ–¹æ³•ã§ã¯ã€è¾æ›¸ã®ã‚­ãƒ¼ã¨ã—ã¦æœ‰åŠ¹ãªã©ã‚“ãªã‚­ãƒ¼ã§ã‚‚ä½¿ãˆã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2089
msgid "Support for building a dictionary from keyword arguments added."
msgstr "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‹ã‚‰ã®è¾æ›¸å‹ã®ä½œæˆã®ã‚µãƒãƒ¼ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:2093
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr "ä»¥ä¸‹ã¯è¾æ›¸å‹ãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹æ“ä½œã§ã™ (ãã‚Œã‚†ãˆã€ã‚«ã‚¹ã‚¿ãƒ ã®ãƒãƒƒãƒ—å‹ã‚‚ã“ã‚Œã‚‰ã®æ“ä½œã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã¹ãã§ã™):"

#: ../../library/stdtypes.rst:2098
msgid "Return the number of items in the dictionary *d*."
msgstr "è¾æ›¸ *d* ã®é …ç›®æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2102
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is"
" not in the map."
msgstr "*d* ã®ã‚­ãƒ¼ *key* ã®é …ç›®ã‚’è¿”ã—ã¾ã™ã€‚ãƒãƒƒãƒ—ã« *key* ãŒå­˜åœ¨ã—ãªã‘ã‚Œã°ã€ :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2107
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, "
":exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot "
"be an instance variable::"
msgstr "è¾æ›¸ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒ :meth:`__missing__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ãŠã‚‰ãšã€ *key* ãŒå­˜åœ¨ã—ãªã„ãªã‚‰ã€ ``d[key]`` æ¼”ç®—ã¯ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚­ãƒ¼ *key* ã‚’å¼•æ•°ã¨ã—ã¦å‘¼ã³å‡ºã—ã¾ã™ã€‚çµæœã¨ã—ã¦ã€ ``d[key]`` æ¼”ç®—ã¯ã€ã‚­ãƒ¼ãŒå­˜åœ¨ã—ãªã‘ã‚Œã°ã€ ``__missing__(key)`` ã®å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã¾ãŸã¯é€å‡ºã•ã‚ŒãŸã‚‚ã®ã‚’ä½•ã§ã‚‚ã€è¿”ã—ã¾ãŸã¯é€å‡ºã—ã¾ã™ã€‚ä»–ã®æ¼”ç®—ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :meth:`__missing__` ã‚’å‘¼ã³å‡ºã—ã¾ã›ã‚“ã€‚ :meth:`__missing__` ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ :exc:`KeyError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ :meth:`__missing__` ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã§ã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“::"

#: ../../library/stdtypes.rst:2125
msgid ""
"The example above shows part of the implementation of "
":class:`collections.Counter`.  A different ``__missing__`` method is used by"
" :class:`collections.defaultdict`."
msgstr "ã“ã“ã§ãŠè¦‹ã›ã—ãŸä¾‹ã¯ :class:`collections.Counter` å®Ÿè£…ã®ä¸€éƒ¨ã§ã™ã€‚ã“ã‚Œã¨ã¯é•ã£ãŸ ``__missing__`` ãŒ:class:`collections.defaultdict` ã§ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2129
msgid "Recognition of __missing__ methods of dict subclasses."
msgstr "è¾æ›¸ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ __missing__ ãƒ¡ã‚½ãƒƒãƒ‰ã‚’èªè­˜ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:2134
msgid "Set ``d[key]`` to *value*."
msgstr "``d[key]`` ã« *value* ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2138
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the"
" map."
msgstr "*d* ã‹ã‚‰ ``d[key]`` ã‚’å‰Šé™¤ã—ã¾ã™ã€‚ãƒãƒƒãƒ—ã« *key* ãŒå­˜åœ¨ã—ãªã‘ã‚Œã°ã€ :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2143
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "*d* ãŒã‚­ãƒ¼ *key* ã‚’æŒã£ã¦ã„ã‚Œã° ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã°ã€ ``False`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2149
msgid "Equivalent to ``not key in d``."
msgstr "``not key in d`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2155
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
":meth:`iterkeys`."
msgstr "è¾æ›¸ã®ã‚­ãƒ¼ã«æ¸¡ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯  :meth:`iterkeys` ã¸ã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã§ã™ã€‚"

#: ../../library/stdtypes.rst:2160
msgid "Remove all items from the dictionary."
msgstr "è¾æ›¸ã®å…¨ã¦ã®é …ç›®ã‚’æ¶ˆå»ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2164
msgid "Return a shallow copy of the dictionary."
msgstr "è¾æ›¸ã®æµ…ã„ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2168
msgid ""
"Create a new dictionary with keys from *seq* and values set to *value*."
msgstr "*seq* ã‹ã‚‰ã‚­ãƒ¼ã‚’å–ã‚Šã€å€¤ã‚’ *value* ã«è¨­å®šã—ãŸã€æ–°ã—ã„è¾æ›¸ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2170
msgid ""
":func:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``."
msgstr ":func:`fromkeys` ã¯æ–°ã—ã„è¾æ›¸ã‚’è¿”ã™ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ *value* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ ``None`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2177
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If"
" *default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr "*key* ãŒè¾æ›¸ã«ã‚ã‚Œã° *key* ã«å¯¾ã™ã‚‹å€¤ã‚’ã€ãã†ã§ãªã‘ã‚Œã° *default* ã‚’è¿”ã—ã¾ã™ã€‚ *default* ãŒä¸ãˆã‚‰ã‚Œãªã‹ã£ãŸå ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``None`` ã¨ãªã‚Šã¾ã™ã€‚ãã®ãŸã‚ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :exc:`KeyError` ã‚’é€å‡ºã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2183
msgid ""
"Test for the presence of *key* in the dictionary.  :meth:`has_key` is "
"deprecated in favor of ``key in d``."
msgstr "è¾æ›¸ã« *key* ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚ ``key in d`` ãŒå¯èƒ½ã«ãªã£ã¦ã„ã‚‹ã®ã§ã€ :meth:`has_key` ã¯å»ƒã‚ŒãŸç”¨æ³•ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2188
msgid "Return a copy of the dictionary's list of ``(key, value)`` pairs."
msgstr "è¾æ›¸ã®ã‚³ãƒ”ãƒ¼ã‚’ ``(key, value)`` ã®å¯¾ã®ãƒªã‚¹ãƒˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2192
msgid ""
"Keys and values are listed in an arbitrary order which is non-random, varies"
" across Python implementations, and depends on the dictionary's history of "
"insertions and deletions."
msgstr "ã‚­ãƒ¼ã¨å€¤ã®ãƒªã‚¹ãƒˆã¯ä»»æ„ã®é †åºã§è¿”ã•ã‚Œã¾ã™ãŒã€ãƒ©ãƒ³ãƒ€ãƒ ã§ã¯ãªãã€ Python ã®å®Ÿè£…ã¨ã€è¾æ›¸ã¸ã®æŒ¿å…¥ã€ãŠã‚ˆã³ã€å‰Šé™¤æ“ä½œã®æ¥æ­´ã«ã‚ˆã£ã¦æ±ºã¾ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2196
msgid ""
"If :meth:`items`, :meth:`keys`, :meth:`values`, :meth:`iteritems`, "
":meth:`iterkeys`, and :meth:`itervalues` are called with no intervening "
"modifications to the dictionary, the lists will directly correspond.  This "
"allows the creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = "
"zip(d.values(), d.keys())``.  The same relationship holds for the "
":meth:`iterkeys` and :meth:`itervalues` methods: ``pairs = "
"zip(d.itervalues(), d.iterkeys())`` provides the same value for ``pairs``. "
"Another way to create the same list is ``pairs = [(v, k) for (k, v) in "
"d.iteritems()]``."
msgstr ":meth:`items`, :meth:`keys`, :meth:`values`, :meth:`iteritems`, :meth:`iterkeys` ãŠã‚ˆã³ :meth:`itervalues` ã¯è¾æ›¸ã«å¹²æ¸‰ã—ã¦æ›´æ–°ã—ãªã‘ã‚Œã°ã€è¿”å´é †ã¯ç›´æ¥å¯¾å¿œé–¢ä¿‚ã«ã‚ã‚Šã¾ã™ã€‚ã¤ã¾ã‚Š ``(value, key)`` ã®å¯¾ã‚’ :func:`zip` ã‚’ä½¿ã£ã¦ç”Ÿæˆã™ã‚‹ã¨ãŒã§ãã¾ã™: ``pairs = zip(d.values(), d.keys())`` ã€‚ :meth:`iterkeys` ã¨ :meth:`itervalues` ã§ã‚‚åŒã˜ã§ã™: ``pairs = zip(d.itervalues(), d.iterkeys())`` ã¯å…ˆã¨åŒã˜å€¤ã‚’è¿”ã—ã¾ã™ã€‚åŒã˜ãƒªã‚¹ãƒˆã‚’å¾—ã‚‹ã«ã¯ ``pairs = [(v, k) for (k, v) in d.iteritems()]`` ã¨ã—ã¦ã‚‚å‡ºæ¥ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2208
msgid ""
"Return an iterator over the dictionary's ``(key, value)`` pairs.  See the "
"note for :meth:`dict.items`."
msgstr "è¾æ›¸ã® ``(key, value)`` ã®å¯¾ã‚’ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã§è¿”ã—ã¾ã™ã€‚ :meth:`dict.items` ã®è¨˜è¿°ã‚‚å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2211
msgid ""
"Using :meth:`iteritems` while adding or deleting entries in the dictionary "
"may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ":meth:`iteritems` ã‚’è¾æ›¸ã®é …ç›®ã®è¿½åŠ ã‚„å‰Šé™¤ã¨åŒæ™‚ã«è¡Œã†ã¨ã€ :exc:`RuntimeError` ã‚’é€å‡ºã•ã‚Œã‚‹ã‹å…¨ã¦ã®é …ç›®ã«å¯¾ã™ã‚‹åå¾©ã«å¤±æ•—ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2218
msgid ""
"Return an iterator over the dictionary's keys.  See the note for "
":meth:`dict.items`."
msgstr "è¾æ›¸ã®ã‚­ãƒ¼ã‚’ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã§è¿”ã—ã¾ã™ã€‚ :meth:`dict.items` ã®è¨˜è¿°ã‚‚å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2221
msgid ""
"Using :meth:`iterkeys` while adding or deleting entries in the dictionary "
"may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ":meth:`iterkeys` ã‚’è¾æ›¸ã®é …ç›®ã®è¿½åŠ ã‚„å‰Šé™¤ã¨åŒæ™‚ã«è¡Œã†ã¨ã€ :exc:`RuntimeError` ã‚’é€å‡ºã•ã‚Œã‚‹ã‹å…¨ã¦ã®é …ç›®ã«å¯¾ã™ã‚‹åå¾©ã«å¤±æ•—ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2228
msgid ""
"Return an iterator over the dictionary's values.  See the note for "
":meth:`dict.items`."
msgstr "è¾æ›¸ã®å€¤ã‚’ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã§è¿”ã—ã¾ã™ã€‚ :meth:`dict.items` ã®è¨˜è¿°ã‚‚å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2231
msgid ""
"Using :meth:`itervalues` while adding or deleting entries in the dictionary "
"may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ":meth:`itervalues` ã‚’è¾æ›¸ã®é …ç›®ã®è¿½åŠ ã‚„å‰Šé™¤ã¨åŒæ™‚ã«è¡Œã†ã¨ã€ :exc:`RuntimeError` ã‚’é€å‡ºã•ã‚Œã‚‹ã‹å…¨ã¦ã®é …ç›®ã«å¯¾ã™ã‚‹åå¾©ã«å¤±æ•—ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2239
msgid ""
"Return a copy of the dictionary's list of keys.  See the note for "
":meth:`dict.items`."
msgstr "è¾æ›¸ã®ã‚­ãƒ¼ã®ãƒªã‚¹ãƒˆã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ :meth:`dict.items` ã®è¨˜è¿°ã‚‚å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2244
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a "
":exc:`KeyError` is raised."
msgstr "*key* ãŒè¾æ›¸ã«å­˜åœ¨ã™ã‚Œã°ãã®å€¤ã‚’è¾æ›¸ã‹ã‚‰æ¶ˆå»ã—ã¦è¿”ã—ã€ãã†ã§ãªã‘ã‚Œã° *default* ã‚’è¿”ã—ã¾ã™ã€‚ *default* ãŒä¸ãˆã‚‰ãšã€ã‹ã¤ *key* ãŒè¾æ›¸ã«å­˜åœ¨ã—ãªã‘ã‚Œã° :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2252
msgid ""
"Remove and return an arbitrary ``(key, value)`` pair from the dictionary."
msgstr "ä»»æ„ã® ``(key, value)`` å¯¾ã‚’è¾æ›¸ã‹ã‚‰æ¶ˆå»ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2254
msgid ""
":func:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling "
":func:`popitem` raises a :exc:`KeyError`."
msgstr "é›†åˆã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ä½¿ã‚ã‚Œã‚‹ã®ã¨åŒã˜ã‚ˆã†ã«ã€ :func:`popitem` ã¯è¾æ›¸ã‚’ç ´å£Šçš„ã«ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã®ã«ä¾¿åˆ©ã§ã™ã€‚è¾æ›¸ãŒç©ºã§ã‚ã‚Œã°ã€ :func:`popitem` ã®å‘¼ã³å‡ºã—ã¯ :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2260
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr "ã‚‚ã—ã€ *key* ãŒè¾æ›¸ã«å­˜åœ¨ã™ã‚Œã°ã€ãã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€å€¤ã‚’ *default* ã¨ã—ã¦ *key* ã‚’æŒ¿å…¥ã—ã€ *default* ã‚’è¿”ã—ã¾ã™ã€‚ *default* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``None`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2266
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr "è¾æ›¸ã®å†…å®¹ã‚’ *other* ã®ã‚­ãƒ¼ã¨å€¤ã§æ›´æ–°ã—ã¾ã™ã€‚æ—¢å­˜ã®ã‚­ãƒ¼ã¯ä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚è¿”ã‚Šå€¤ã¯ ``None`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2269
msgid ""
":func:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value"
" pairs: ``d.update(red=1, blue=2)``."
msgstr ":func:`update` ã¯ã€ä»–ã®è¾æ›¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚ã‚­ãƒ¼/å€¤ã®å¯¾ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ« (ã‚¿ãƒ—ãƒ«ã€ã‚‚ã—ãã¯ã€é•·ã•ãŒ2ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«) ã§ã‚‚ã€ã©ã¡ã‚‰ã§ã‚‚å—ã‘ä»˜ã‘ã¾ã™ã€‚ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ãŒæŒ‡å®šã•ã‚Œã‚Œã°ã€ãã®ã‚­ãƒ¼/å€¤ã®å¯¾ã§è¾æ›¸ã‚’æ›´æ–°ã—ã¾ã™: ``d.update(red=1, blue=2)``ã€‚"

#: ../../library/stdtypes.rst:2274
msgid ""
"Allowed the argument to be an iterable of key/value pairs and allowed "
"keyword arguments."
msgstr "ã‚­ãƒ¼ã¨å€¤ã®å¯¾ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã€ãŠã‚ˆã³ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’å¼•æ•°ã¨ã—ã¦ä¸ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:2280
msgid ""
"Return a copy of the dictionary's list of values.  See the note for "
":meth:`dict.items`."
msgstr "è¾æ›¸ã®å€¤ã®ãƒªã‚¹ãƒˆã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ :meth:`dict.items` ã®è¨˜è¿°ã‚‚å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2285
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs).  See "
"below for documentation of view objects."
msgstr "è¾æ›¸ã®ã‚¢ã‚¤ãƒ†ãƒ  (``(key, value)`` ã®ãƒšã‚¢) ã®æ–°ã—ã„ãƒ“ãƒ¥ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ãƒ“ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã¯ä¸‹ã«èª¬æ˜ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2292
msgid ""
"Return a new view of the dictionary's keys.  See below for documentation of "
"view objects."
msgstr "è¾æ›¸ã®ã‚­ãƒ¼ã®æ–°ã—ã„ãƒ“ãƒ¥ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ãƒ“ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã¯ä¸‹ã«èª¬æ˜ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2299
msgid ""
"Return a new view of the dictionary's values.  See below for documentation "
"of view objects."
msgstr "è¾æ›¸ã®å€¤ã®æ–°ã—ã„ãƒ“ãƒ¥ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ãƒ“ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã¯ä¸‹ã«èª¬æ˜ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2304
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs."
msgstr "è¾æ›¸ã¯ã€åŒã˜ ``(key, value)`` ã®å¯¾ã‚’æŒã¤ã¨ãã®ã¿ç­‰ã—ããªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2311
msgid "Dictionary view objects"
msgstr "è¾æ›¸ãƒ“ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:2313
msgid ""
"The objects returned by :meth:`dict.viewkeys`, :meth:`dict.viewvalues` and "
":meth:`dict.viewitems` are *view objects*.  They provide a dynamic view on "
"the dictionary's entries, which means that when the dictionary changes, the "
"view reflects these changes."
msgstr ":meth:`dict.viewkeys`, :meth:`dict.viewvalues`, :meth:`dict.viewitems` ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ *ãƒ“ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ* ã§ã™ã€‚ã“ã‚Œã‚‰ã¯ã€è¾æ›¸ã®é …ç›®ã®å‹•çš„ãªãƒ“ãƒ¥ãƒ¼ã‚’æä¾›ã—ã€è¾æ›¸ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚ã€ãƒ“ãƒ¥ãƒ¼ã¯ãã®å¤‰æ›´ã‚’åæ˜ ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2318
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr "è¾æ›¸ãƒ“ãƒ¥ãƒ¼ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã“ã¨ã§å¯¾å¿œã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’ yield ã§ãã¾ã™ã€‚ã¾ãŸã€å¸°å±åˆ¤å®šã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™:"

#: ../../library/stdtypes.rst:2323
msgid "Return the number of entries in the dictionary."
msgstr "è¾æ›¸ã®é …ç›®æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2327
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr "è¾æ›¸ã®ã‚­ãƒ¼ã€å€¤ã€ã¾ãŸã¯ (``(key, value)`` ã®ã‚¿ãƒ—ãƒ«ã¨ã—ã¦è¡¨ã•ã‚Œã‚‹) é …ç›®ã«æ¸¡ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2330
msgid ""
"Keys and values are iterated over in an arbitrary order which is non-random,"
" varies across Python implementations, and depends on the dictionary's "
"history of insertions and deletions. If keys, values and items views are "
"iterated over with no intervening modifications to the dictionary, the order"
" of items will directly correspond.  This allows the creation of ``(value, "
"key)`` pairs using :func:`zip`: ``pairs = zip(d.values(), d.keys())``.  "
"Another way to create the same list is ``pairs = [(v, k) for (k, v) in "
"d.items()]``."
msgstr "ã‚­ãƒ¼ã¨å€¤ã®ãƒªã‚¹ãƒˆã¯ã‚ã‚‹ä»»æ„ã®é †åºã§ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã•ã‚Œã¾ã™ãŒã€ãƒ©ãƒ³ãƒ€ãƒ ã§ã¯ãªãã€ Python ã®å®Ÿè£…ã«ã‚ˆã£ã¦å¤‰ã‚ã‚Šã€è¾æ›¸ã¸ã®æŒ¿å…¥ã‚„å‰Šé™¤ã®å±¥æ­´ã«ä¾å­˜ã—ã¾ã™ã€‚ã‚­ãƒ¼ã€å€¤ã€è¦ç´ ã®ãƒ“ãƒ¥ãƒ¼ã‚’é€šã—ã¦ã€è¾æ›¸ã®å¤‰æ›´ã‚’æŒŸã¾ãšã«ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã•ã‚ŒãŸã‚‰ã€ãã®è¦ç´ ã®é †åºã¯å®Œå…¨ã«ä¸€è‡´ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ ``(value, key)`` ã®å¯¾ã‚’ :func:`zip` ã§ä½œæˆã§ãã¾ã™: ``pairs = zip(d.values(), d.keys())`` ã€‚åŒã˜ãƒªã‚¹ãƒˆã‚’ä½œæˆã™ã‚‹ä»–ã®æ–¹æ³•ã¯ã€ ``pairs = [(v, k) for (k, v) in d.items()]`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2338
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise"
" a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr "è¾æ›¸ã®é …ç›®ã®è¿½åŠ ã‚„å‰Šé™¤ä¸­ã«ãƒ“ãƒ¥ãƒ¼ã‚’ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã¨ã€ :exc:`RuntimeError` ã‚’é€å‡ºã—ãŸã‚Šã€ã™ã¹ã¦ã®é …ç›®ã«æ¸¡ã£ã¦ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã§ããªã‹ã£ãŸã‚Šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2343
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr "*x* ãŒä¸‹ã«ã‚ã‚‹è¾æ›¸ã®ã‚­ãƒ¼ã€å€¤ã€ã¾ãŸã¯é …ç›® (é …ç›®ã®å ´åˆã€ *x* ã¯ ``(key, value)`` ã‚¿ãƒ—ãƒ«ã§ã‚ã‚‹ã¹ãã§ã™) ã«ã‚ã‚‹ã¨ã ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2347
msgid ""
"Keys views are set-like since their entries are unique and hashable.  If all"
" values are hashable, so that (key, value) pairs are unique and hashable, "
"then the items view is also set-like.  (Values views are not treated as set-"
"like since the entries are generally not unique.)  Then these set operations"
" are available (\"other\" refers either to another view or a set):"
msgstr "ã‚­ãƒ¼ã®ãƒ“ãƒ¥ãƒ¼ã¯ã€é …ç›®ãŒä¸€æ„çš„ã§ãƒãƒƒã‚·ãƒ¥å¯èƒ½ã§ã‚ã‚‹ã¨ã„ã†ç‚¹ã§ã€é›†åˆã«ä¼¼ã¦ã„ã¾ã™ã€‚ã™ã¹ã¦ã®å€¤ãŒãƒãƒƒã‚·ãƒ¥å¯èƒ½ãªã‚‰ã€ ``(key, value)`` å¯¾ã‚‚ä¸€æ„çš„ã§ãƒãƒƒã‚·ãƒ¥å¯èƒ½ãªã®ã§ã€è¦ç´ ã®ãƒ“ãƒ¥ãƒ¼ã‚‚é›†åˆã«ä¼¼ã¦ã„ã¾ã™ã€‚(å€¤ã®ãƒ“ãƒ¥ãƒ¼ã¯ã€è¦ç´ ãŒä¸€èˆ¬ã«ä¸€æ„çš„ã§ãªã„ã“ã¨ã‹ã‚‰ã€é›†åˆã«ä¼¼ã¦ã„ã‚‹ã¨ã¯è€ƒãˆã‚‰ã‚Œã¾ã›ã‚“ã€‚) ã“ã‚Œã«ã‚ˆã‚Šã“ã‚Œã‚‰ã¸ã®é›†åˆæ¼”ç®—ãŒåˆ©ç”¨å‡ºæ¥ã¾ã™ (\"other\" ã¯ã‚‚ã†ä¸€ã¤ã®ãƒ“ãƒ¥ãƒ¼ã‹é›†åˆã§ã™):"

#: ../../library/stdtypes.rst:2355
msgid ""
"Return the intersection of the dictview and the other object as a new set."
msgstr "è¾æ›¸ãƒ“ãƒ¥ãƒ¼ã¨åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å…±é€šéƒ¨åˆ†ã‚’æ–°ã—ã„é›†åˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2359
msgid "Return the union of the dictview and the other object as a new set."
msgstr "è¾æ›¸ãƒ“ãƒ¥ãƒ¼ã¨åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åˆä½µé›†åˆã‚’æ–°ã—ã„é›†åˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2363
msgid ""
"Return the difference between the dictview and the other object (all "
"elements in *dictview* that aren't in *other*) as a new set."
msgstr "è¾æ›¸ãƒ“ãƒ¥ãƒ¼ã¨åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å·®é›†åˆ (*dictview* ã«å±ã—ã¦ *other* ã«å±ã•ãªã„ã™ã¹ã¦ã®è¦ç´ ) ã‚’æ–°ã—ã„é›†åˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2368
msgid ""
"Return the symmetric difference (all elements either in *dictview* or "
"*other*, but not in both) of the dictview and the other object as a new set."
msgstr "è¾æ›¸ãƒ“ãƒ¥ãƒ¼ã¨åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¯¾ç§°å·® (*dictview* ã¨ *other* ã®ã©ã¡ã‚‰ã‹ã«å±ã™ãŒä¸¡æ–¹ã«ã¯å±ã•ãªã„ã™ã¹ã¦ã®è¦ç´ ) ã‚’æ–°ã—ã„é›†åˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2372
msgid "An example of dictionary view usage::"
msgstr "è¾æ›¸ãƒ“ãƒ¥ãƒ¼ã®ä½¿ç”¨æ³•ã®ä¾‹::"

#: ../../library/stdtypes.rst:2405
msgid "File Objects"
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:2413
msgid ""
"File objects are implemented using C's ``stdio`` package and can be created "
"with the built-in :func:`open` function.  File objects are also returned by "
"some other built-in functions and methods, such as :func:`os.popen` and "
":func:`os.fdopen` and the :meth:`makefile` method of socket objects. "
"Temporary files can be created using the :mod:`tempfile` module, and high-"
"level file operations such as copying, moving, and deleting files and "
"directories can be achieved with the :mod:`shutil` module."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ C ã® ``stdio`` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã¦ãŠã‚Šã€çµ„ã¿è¾¼ã¿é–¢æ•°ã® :func:`open` ã§ç”Ÿæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã¾ãŸã€ :func:`os.popen` ã‚„ :func:`os.fdopen`, ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`makefile` ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚ˆã†ãªã€ä»–ã®çµ„ã¿è¾¼ã¿é–¢æ•°ãŠã‚ˆã³ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦ã‚‚è¿”ã•ã‚Œã¾ã™ã€‚ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã¯ :mod:`tempfile` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦ç”Ÿæˆã§ãã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ã‚³ãƒ”ãƒ¼ã€ç§»å‹•ã€æ¶ˆå»ãªã©ã®é«˜æ¬¡ã®æ“ä½œã¯ :mod:`shutil` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§è¡Œãˆã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2422
msgid ""
"When a file operation fails for an I/O-related reason, the exception "
":exc:`IOError` is raised.  This includes situations where the operation is "
"not defined for some reason, like :meth:`seek` on a tty device or writing a "
"file opened for reading."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œãŒ I/O é–¢é€£ã®ç†ç”±ã§å¤±æ•—ã—ãŸå ´åˆä¾‹å¤– :exc:`IOError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®ç†ç”±ã«ã¯ä¾‹ãˆã° :meth:`seek` ã‚’ç«¯æœ«ãƒ‡ãƒã‚¤ã‚¹ã«è¡Œã£ãŸã‚Šã€èª­ã¿å‡ºã—å°‚ç”¨ã§é–‹ã„ãŸãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿ã‚’è¡Œã†ã¨ã„ã£ãŸã€ä½•ã‚‰ã‹ã®ç†ç”±ã«ã‚ˆã£ã¦ãã®ãƒ•ã‚¡ã‚¤ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ãªã„æ“ä½œã‚’è¡Œã£ãŸã‚ˆã†ãªå ´åˆã‚‚å«ã¾ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2427
msgid "Files have the following methods:"
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¡ã¾ã™:"

#: ../../library/stdtypes.rst:2432
msgid ""
"Close the file.  A closed file cannot be read or written any more. Any "
"operation which requires that the file be open will raise a "
":exc:`ValueError` after the file has been closed.  Calling :meth:`close` "
"more than once is allowed."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ã¾ã™ã€‚é–‰ã˜ã‚‰ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯ãã‚Œä»¥å¾Œèª­ã¿æ›¸ãã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‹ã‚Œã¦ã„ã‚‹ã“ã¨ãŒå¿…è¦ãªæ“ä½œã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‰ã˜ã‚‰ã‚ŒãŸå¾Œã¯ã™ã¹ã¦ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚ :meth:`close` ã‚’ä¸€åº¦ä»¥ä¸Šå‘¼ã³å‡ºã—ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2436
msgid ""
"As of Python 2.5, you can avoid having to call this method explicitly if you"
" use the :keyword:`with` statement.  For example, the following code will "
"automatically close *f* when the :keyword:`with` block is exited::"
msgstr "Python 2.5 ã‹ã‚‰ :keyword:`with` æ–‡ã‚’ä½¿ãˆã°ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç›´æ¥å‘¼ã³å‡ºã™å¿…è¦ã¯ãªããªã‚Šã¾ã—ãŸã€‚ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯ *f* ã‚’ :keyword:`with` ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠœã‘ã‚‹éš›ã«è‡ªå‹•çš„ã«é–‰ã˜ã¾ã™ã€‚ ::"

#: ../../library/stdtypes.rst:2446
msgid ""
"In older versions of Python, you would have needed to do this to get the "
"same effect::"
msgstr "å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã§ã¯åŒã˜åŠ¹æœã‚’å¾—ã‚‹ãŸã‚ã«æ¬¡ã®ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã§ã—ãŸã€‚ ::"

#: ../../library/stdtypes.rst:2458
msgid ""
"Not all \"file-like\" types in Python support use as a context manager for "
"the :keyword:`with` statement.  If your code is intended to work with any "
"file-like object, you can use the function :func:`contextlib.closing` "
"instead of using the object directly."
msgstr "å…¨ã¦ã® Python ã® \\\"ãƒ•ã‚¡ã‚¤ãƒ«çš„\\\" å‹ãŒ :keyword:`with` æ–‡ç”¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¨ã—ã¦ä½¿ãˆã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—ã€å…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§å‹•ãã‚ˆã†ã«ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ããŸã„ã®ãªã‚‰ã°ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç›´æ¥ä½¿ã†ã®ã§ã¯ãªã :mod:`contextlib` ã«ã‚ã‚‹ :func:`contextlib.closing` é–¢æ•°ã‚’ä½¿ã†ã¨è‰¯ã„ã§ã—ã‚‡ã†ã€‚"

#: ../../library/stdtypes.rst:2466
msgid ""
"Flush the internal buffer, like ``stdio``'s :c:func:`fflush`.  This may be a"
" no-op on some file-like objects."
msgstr "``stdio`` ã® :c:func:`fflush` ã®ã‚ˆã†ã«ã€å†…éƒ¨ãƒãƒƒãƒ•ã‚¡ã‚’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«é¡ä¼¼ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã£ã¦ã¯ã€ã“ã®æ“ä½œã¯ä½•ã‚‚è¡Œã„ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2471
msgid ""
":meth:`flush` does not necessarily write the file's data to disk.  Use "
":meth:`flush` followed by :func:`os.fsync` to ensure this behavior."
msgstr ":meth:`flush` ã¯å¿…ãšã—ã‚‚ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‡ã‚£ã‚¹ã‚¯ã«æ›¸ãè¾¼ã‚€ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚ãã®ã‚ˆã†ãªæŒ™å‹•ã‚’ä¿è¨¼ã™ã‚‹ã«ã¯ :meth:`flush` ã®å¾Œã« :func:`os.fsync` ã‚’ä½¿ã£ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2481
msgid ""
"Return the integer \"file descriptor\" that is used by the underlying "
"implementation to request I/O operations from the operating system.  This "
"can be useful for other, lower level interfaces that use file descriptors, "
"such as the :mod:`fcntl` module or :func:`os.read` and friends."
msgstr "èƒŒå¾Œã«ã‚ã‚‹å®Ÿè£…ç³»ãŒã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã« I/O æ“ä½œã‚’è¦æ±‚ã™ã‚‹ãŸã‚ã«ç”¨ã„ã‚‹ã€æ•´æ•°ã® \\\"ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­\\\" (ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿) ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®å€¤ã¯ä»–ã®ç”¨é€”ã¨ã—ã¦ã€ :mod:`fcntl` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ :func:`os.read` ã‚„ãã®ä»²é–“ã®ã‚ˆã†ãªã€ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’å¿…è¦ã¨ã™ã‚‹ä½ãƒ¬ãƒ™ãƒ«ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§å½¹ã«ç«‹ã¡ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2488
msgid ""
"File-like objects which do not have a real file descriptor should *not* "
"provide this method!"
msgstr "æœ¬ç‰©ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’æŒãŸãªã„ãƒ•ã‚¡ã‚¤ãƒ«é¡ä¼¼ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã™ã¹ãã§ã¯ *ã‚ã‚Šã¾ã›ã‚“* ã€‚"

#: ../../library/stdtypes.rst:2494
msgid ""
"Return ``True`` if the file is connected to a tty(-like) device, else "
"``False``."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ãŒ tty (ã¾ãŸã¯é¡ä¼¼ã®) ãƒ‡ãƒã‚¤ã‚¹ã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹å ´åˆ ``True`` ã‚’è¿”ã—ã€ãã†ã§ãªã„å ´åˆ ``False`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2498
msgid ""
"If a file-like object is not associated with a real file, this method should"
" *not* be implemented."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«é¡ä¼¼ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ãªã„å ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã¹ãã§ã¯ *ã‚ã‚Šã¾ã›ã‚“* ã€‚"

#: ../../library/stdtypes.rst:2504
msgid ""
"A file object is its own iterator, for example ``iter(f)`` returns *f* "
"(unless *f* is closed).  When a file is used as an iterator, typically in a "
":keyword:`for` loop (for example, ``for line in f: print line.strip()``), "
"the :meth:`~file.next` method is called repeatedly.  This method returns the"
" next input line, or raises :exc:`StopIteration` when EOF is hit when the "
"file is open for reading (behavior is undefined when the file is open for "
"writing).  In order to make a :keyword:`for` loop the most efficient way of "
"looping over the lines of a file (a very common operation), the "
":meth:`~file.next` method uses a hidden read-ahead buffer.  As a consequence"
" of using a read-ahead buffer, combining :meth:`~file.next` with other file "
"methods (like :meth:`~file.readline`) does not work right.  However, using "
":meth:`seek` to reposition the file to an absolute position will flush the "
"read-ahead buffer."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã‚Œè‡ªèº«ãŒã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã§ã™ã€‚ã™ãªã‚ã¡ã€ ``iter(f)`` ã¯ (*f* ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ãªã„é™ã‚Š) *f* ã‚’è¿”ã—ã¾ã™ã€‚ :keyword:`for` ãƒ«ãƒ¼ãƒ— (ä¾‹ãˆã° ``for line in f: print line.strip()``) ã®ã‚ˆã†ã«ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦ä½¿ã‚ã‚ŒãŸå ´åˆã€ :meth:`~file.next` ãƒ¡ã‚½ãƒƒãƒ‰ãŒç¹°ã‚Šè¿”ã—å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã¿ã®ãŸã‚ã«é–‹ã‹ã‚Œã¦ã„ã‚‹å ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ¬¡ã®å…¥åŠ›è¡Œã‚’è¿”ã™ã‹ã€ã¾ãŸã¯ã€ EOF ã«åˆ°é”ã—ãŸã¨ãã« :exc:`StopIteration` ã‚’é€å‡ºã—ã¾ã™ (ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ›¸ãè¾¼ã¿ãƒ¢ãƒ¼ãƒ‰ã§é–‹ã‹ã‚Œã¦ã„ã‚‹å ´åˆã€å‹•ä½œã¯æœªå®šç¾©ã§ã™) ã€‚ãƒ•ã‚¡ã‚¤ãƒ«å†…ã®å„è¡Œã«å¯¾ã™ã‚‹ :keyword:`for` ãƒ«ãƒ¼ãƒ— (éå¸¸ã«ã‚ˆãã‚ã‚‹æ“ä½œã§ã™) ã‚’åŠ¹ç‡çš„ãªæ–¹æ³•ã§è¡Œã†ãŸã‚ã«ã€ :meth:`~file.next` ãƒ¡ã‚½ãƒƒãƒ‰ã¯éš è”½ã•ã‚ŒãŸå…ˆèª­ã¿ãƒãƒƒãƒ•ã‚¡ã‚’ä½¿ã„ã¾ã™ã€‚å…ˆèª­ã¿ãƒãƒƒãƒ•ã‚¡ã‚’ä½¿ã£ãŸçµæœã¨ã—ã¦ã€ (:meth:`~file.readline` ã®ã‚ˆã†ãª) ä»–ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ã‚½ãƒƒãƒ‰ã¨ :meth:`~file.next` ã‚’çµ„ã¿åˆã‚ã›ã¦ä½¿ã†ã¨ã†ã¾ãå‹•ä½œã—ã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ :meth:`seek` ã‚’ä½¿ã£ã¦ãƒ•ã‚¡ã‚¤ãƒ«ä½ç½®ã‚’çµ¶å¯¾æŒ‡å®šã—ãªãŠã™ã¨ã€å…ˆèª­ã¿ãƒãƒƒãƒ•ã‚¡ã¯æ¶ˆå»ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2522
msgid ""
"Read at most *size* bytes from the file (less if the read hits EOF before "
"obtaining *size* bytes).  If the *size* argument is negative or omitted, "
"read all data until EOF is reached.  The bytes are returned as a string "
"object.  An empty string is returned when EOF is encountered immediately.  "
"(For certain files, like ttys, it makes sense to continue reading after an "
"EOF is hit.)  Note that this method may call the underlying C function "
":c:func:`fread` more than once in an effort to acquire as close to *size* "
"bytes as possible. Also note that when in non-blocking mode, less data than "
"was requested may be returned, even if no *size* parameter was given."
msgstr "æœ€å¤§ã§ *size* ãƒã‚¤ãƒˆã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿ã¾ã™ (*size* ãƒã‚¤ãƒˆã‚’å–å¾—ã™ã‚‹å‰ã« EOF ã«åˆ°é”ã—ãŸå ´åˆã€ãã‚Œä»¥ä¸‹ã®é•·ã•ã«ãªã‚Šã¾ã™) ã€‚ *size* å¼•æ•°ãŒè² ã§ã‚ã‚‹ã‹çœç•¥ã•ã‚ŒãŸå ´åˆã€ EOF ã«åˆ°é”ã™ã‚‹ã¾ã§ã®å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚èª­ã¿å‡ºã•ã‚ŒãŸãƒã‚¤ãƒˆåˆ—ã¯æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚ç›´å¾Œã« EOF ã«åˆ°é”ã—ãŸå ´åˆã€ç©ºã®æ–‡å­—åˆ—ãŒè¿”ã•ã‚Œã¾ã™ã€‚ (ç«¯æœ«ã®ã‚ˆã†ãªã‚ã‚‹ç¨®ã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ã€ EOF ã«åˆ°é”ã—ãŸå¾Œã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿ã¤ã¥ã‘ã‚‹ã“ã¨ã«ã‚‚æ„å‘³ãŒã‚ã‚Šã¾ã™) ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ *size* ãƒã‚¤ãƒˆã«å¯èƒ½ãªé™ã‚Šè¿‘ããƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ã€èƒŒå¾Œã® C é–¢æ•° :c:func:`fread` ã‚’ 1 åº¦ä»¥ä¸Šå‘¼ã³å‡ºã™ã‹ã‚‚ã—ã‚Œãªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã¾ãŸã€éãƒ–ãƒ­ãƒƒã‚¯ãƒ»ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€ *size* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒä¸ãˆã‚‰ã‚Œãªãã¦ã‚‚ã€è¦æ±‚ã•ã‚ŒãŸã‚ˆã‚Šã‚‚å°‘ãªã„ãƒ‡ãƒ¼ã‚¿ãŒè¿”ã•ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2533
msgid ""
"This function is simply a wrapper for the underlying :c:func:`fread` C "
"function, and will behave the same in corner cases, such as whether the EOF "
"value is cached."
msgstr "ã“ã®é–¢æ•°ã¯å˜ç´”ã«ã€èƒŒå¾Œã® C é–¢æ•° :c:func:`fread` ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã§ã™ã€‚ãã®ãŸã‚ã€ EOF ãŒäºˆæœŸã›ãšæ¤œå‡ºã•ã‚ŒãŸã‚Šã•ã‚Œãªã‹ã£ãŸã‚Šã¨ã„ã£ãŸå€‹åˆ¥ã®äº‹æƒ…ãŒã‚ã£ã¦ã‚‚åŒã˜ã‚ˆã†ã«æŒ¯èˆã†ã ã‘ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2540
msgid ""
"Read one entire line from the file.  A trailing newline character is kept in"
" the string (but may be absent when a file ends with an incomplete line). "
"[6]_ If the *size* argument is present and non-negative, it is a maximum "
"byte count (including the trailing newline) and an incomplete line may be "
"returned. When *size* is not 0, an empty string is returned *only* when EOF "
"is encountered immediately."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ä¸€è¡Œå…¨éƒ¨ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚è¡Œæœ«ã®æ”¹è¡Œæ–‡å­—ã¯æ–‡å­—åˆ—ã«æ®‹ã‚Šã¾ã™ (ã ã ã—ã€ãƒ•ã‚¡ã‚¤ãƒ«ãŒä¸å®Œå…¨ãªè¡Œã§çµ‚ã‚ã£ã¦ã„ãŸã‚‰ã€å­˜åœ¨ã—ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“)ã€‚ [6]_ *size* å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œã€è² ã§ãªã‘ã‚Œã°ã€ãã‚ŒãŒ (è¡Œæœ«ã®æ”¹è¡Œæ–‡å­—ã‚’å«ã‚€) æœ€å¤§ãƒã‚¤ãƒˆæ•°ã¨ãªã‚Šã€ä¸å®Œå…¨ãªè¡Œã§ã‚‚è¿”ã•ã‚Œã¾ã™ã€‚ *size* ãŒ 0 ã§ãªã‘ã‚Œã°ã€ç©ºã®æ–‡å­—åˆ—ãŒè¿”ã•ã‚Œã‚‹ã®ã¯ã€å³åº§ã« EOF ã«åˆ°é”ã—ãŸã¨ã *ã ã‘* ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2549
msgid ""
"Unlike ``stdio``'s :c:func:`fgets`, the returned string contains null "
"characters (``'\\0'``) if they occurred in the input."
msgstr "C ``stdio`` ã® :c:func:`fgets` ã¨é•ã„ã€å…¥åŠ›ä¸­ã«ãƒŒãƒ«æ–‡å­— (``'\\0'``) ãŒå«ã¾ã‚Œã¦ã„ã‚Œã°ã€ãƒŒãƒ«æ–‡å­—ã‚’å«ã‚“ã æ–‡å­—åˆ—ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2555
msgid ""
"Read until EOF using :meth:`~file.readline` and return a list containing the"
" lines thus read.  If the optional *sizehint* argument is present, instead "
"of reading up to EOF, whole lines totalling approximately *sizehint* bytes "
"(possibly after rounding up to an internal buffer size) are read.  Objects "
"implementing a file-like interface may choose to ignore *sizehint* if it "
"cannot be implemented, or cannot be implemented efficiently."
msgstr ":meth:`~file.readline` ã‚’ä½¿ã£ã¦ã«åˆ°é”ã™ã‚‹ã¾ã§èª­ã¿å‡ºã—ã€ EOF èª­ã¿å‡ºã•ã‚ŒãŸè¡Œã‚’å«ã‚€ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *sizehint* å¼•æ•°ãŒå­˜åœ¨ã™ã‚Œã°ã€ EOF ã¾ã§èª­ã¿å‡ºã™ä»£ã‚ã‚Šã«å®Œå…¨ãªè¡Œã‚’å…¨ä½“ã§å¤§ä½“ *sizehint* ãƒã‚¤ãƒˆã«ãªã‚‹ã‚ˆã†ã« (ãŠãã‚‰ãå†…éƒ¨ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã‚’åˆ‡ã‚Šè©°ã‚ã¦) èª­ã¿å‡ºã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«é¡ä¼¼ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ *sizehint* ã‚’å®Ÿè£…ã§ããªã„ã‹åŠ¹ç‡çš„ã«å®Ÿè£…ã§ããªã„å ´åˆã«ã¯ç„¡è¦–ã—ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2565
msgid "This method returns the same thing as ``iter(f)``."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ ``iter(f)`` ã¨åŒã˜çµæœã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2569
msgid "Use ``for line in file`` instead."
msgstr "ä»£ã‚ã‚Šã« ``for line in file`` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2575
msgid ""
"Set the file's current position, like ``stdio``'s :c:func:`fseek`. The "
"*whence* argument is optional and defaults to  ``os.SEEK_SET`` or ``0`` "
"(absolute file positioning); other values are ``os.SEEK_CUR`` or ``1`` (seek"
" relative to the current position) and ``os.SEEK_END`` or ``2``  (seek "
"relative to the file's end).  There is no return value."
msgstr "C ``stdio`` ã® :c:func:`fseek` ãŒè¡Œã†ã‚ˆã†ã«ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®ç¾åœ¨ä½ç½®ã‚’è¨­å®šã—ã¾ã™ã€‚ *whence* å¼•æ•°ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã€æ¨™æº–ã®å€¤ã¯ ``os.SEEK_SET`` ã‚‚ã—ãã¯ ``0`` (çµ¶å¯¾ä½ç½®æŒ‡å®š) ã§ã™; ä»–ã«å–ã‚Šå¾—ã‚‹å€¤ã¯ ``os.SEEK_CUR`` ã‚‚ã—ãã¯ ``1`` (ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ä½ç½®ã‹ã‚‰ç›¸å¯¾çš„ã« seek ã™ã‚‹) ãŠã‚ˆã³ ``os.SEEK_END`` ã‚‚ã—ãã¯ ``2`` (ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ«ç«¯ã‹ã‚‰ç›¸å¯¾çš„ã« seek ã™ã‚‹) ã§ã™ã€‚æˆ»ã‚Šå€¤ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2581
msgid ""
"For example, ``f.seek(2, os.SEEK_CUR)`` advances the position by two and "
"``f.seek(-3, os.SEEK_END)`` sets the position to the third to last."
msgstr "ä¾‹ãˆã°ã€ ``f.seek(2, os.SEEK_CUR)`` ä½ç½®ã‚’2ã¤é€²ã‚ã¾ã™ã€‚ ``f.seek(-3, os.SEEK_END)`` ã§ã¯çµ‚ç«¯ã®3ã¤æ‰‹å‰ã«è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2584
msgid ""
"Note that if the file is opened for appending (mode ``'a'`` or ``'a+'``), "
"any :meth:`seek` operations will be undone at the next write.  If the file "
"is only opened for writing in append mode (mode ``'a'``), this method is "
"essentially a no-op, but it remains useful for files opened in append mode "
"with reading enabled (mode ``'a+'``).  If the file is opened in text mode "
"(without ``'b'``), only offsets returned by :meth:`tell` are legal.  Use of "
"other offsets causes undefined behavior."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½è¨˜ãƒ¢ãƒ¼ãƒ‰ (ãƒ¢ãƒ¼ãƒ‰ ``'a'`` ã¾ãŸã¯ ``'a+'``) ã§é–‹ã„ãŸå ´åˆã€æ›¸ãè¾¼ã¿ã‚’è¡Œã†ã¾ã§ã«è¡Œã£ãŸ :meth:`seek` æ“ä½œã¯ã™ã¹ã¦å…ƒã«æˆ»ã•ã‚Œã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¿½è¨˜ã®ã¿ã®æ›¸ãè¾¼ã¿ãƒ¢ãƒ¼ãƒ‰ (``'a'``) ã§é–‹ã‹ã‚ŒãŸå ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å®Ÿè³ªä½•ã‚‚è¡Œã„ã¾ã›ã‚“ãŒã€èª­ã¿è¾¼ã¿ãŒå¯èƒ½ãªè¿½è¨˜ãƒ¢ãƒ¼ãƒ‰ (``'a+'``) ã§é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯å½¹ã«ç«‹ã¡ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ (``'b'`` ãªã—ã§) é–‹ã„ãŸå ´åˆã€ :meth:`tell` ãŒè¿”ã™ã‚ªãƒ•ã‚»ãƒƒãƒˆã®ã¿ãŒæ­£ã—ã„å€¤ã«ãªã‚Šã¾ã™ã€‚ä»–ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆå€¤ã‚’ä½¿ã£ãŸå ´åˆã€ãã®æŒ¯ã‚‹èˆã„ã¯æœªå®šç¾©ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2592
msgid "Note that not all file objects are seekable."
msgstr "å…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ seek ã§ãã‚‹ã¨ã¯é™ã‚‰ãªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2594
msgid "Passing float values as offset has been deprecated."
msgstr "ã‚ªãƒ•ã‚»ãƒƒãƒˆã«æµ®å‹•å°æ•°ç‚¹æ•°ã‚’æ¸¡ã™ã“ã¨ã¯éæ¨å¥¨ã¨ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:2600
msgid "Return the file's current position, like ``stdio``'s :c:func:`ftell`."
msgstr "C ã® ``stdio`` ã® :c:func:`ftell` ã®ã‚ˆã†ã«ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®ç¾åœ¨ä½ç½®ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2604
msgid ""
"On Windows, :meth:`tell` can return illegal values (after an "
":c:func:`fgets`) when reading files with Unix-style line-endings. Use binary"
" mode (``'rb'``) to circumvent this problem."
msgstr "Windows ã§ã¯ã€(:c:func:`fgets` ã®å¾Œã§) Unix ã‚¹ã‚¿ã‚¤ãƒ«ã®æ”¹è¡Œã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€ã¨ãã« :meth:`tell` ãŒä¸æ­£ãªå€¤ã‚’è¿”ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®å•é¡Œã«é­é‡ã—ãªã„ãŸã‚ã«ã¯ãƒã‚¤ãƒŠãƒªãƒ¼ãƒ¢ãƒ¼ãƒ‰ (``'rb'``) ã‚’ä½¿ã†ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2611
msgid ""
"Truncate the file's size.  If the optional *size* argument is present, the "
"file is truncated to (at most) that size.  The size defaults to the current "
"position. The current file position is not changed.  Note that if a "
"specified size exceeds the file's current size, the result is platform-"
"dependent:  possibilities include that the file may remain unchanged, "
"increase to the specified size as if zero-filled, or increase to the "
"specified size with undefined new content. Availability:  Windows, many Unix"
" variants."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚µã‚¤ã‚ºã‚’åˆ‡ã‚Šè©°ã‚ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *size* ãŒå­˜åœ¨ã™ã‚Œã°ã€ãƒ•ã‚¡ã‚¤ãƒ«ã¯ (æœ€å¤§ã§) æŒ‡å®šã•ã‚ŒãŸã‚µã‚¤ã‚ºã«åˆ‡ã‚Šè©°ã‚ã‚‰ã‚Œã¾ã™ã€‚æ¨™æº–è¨­å®šã®ã‚µã‚¤ã‚ºã®å€¤ã¯ã€ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ä½ç½®ã¾ã§ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã§ã™ã€‚ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ä½ç½®ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚æŒ‡å®šã•ã‚ŒãŸã‚µã‚¤ã‚ºãŒãƒ•ã‚¡ã‚¤ãƒ«ã®ç¾åœ¨ã®ã‚µã‚¤ã‚ºã‚’è¶Šãˆã‚‹å ´åˆã€ãã®çµæœã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ãªã®ã§æ³¨æ„ã—ã¦ãã ã•ã„: å¯èƒ½æ€§ã¨ã—ã¦ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã¯å¤‰æ›´ã•ã‚Œãªã„ã‹ã€æŒ‡å®šã•ã‚ŒãŸã‚µã‚¤ã‚ºã¾ã§ã‚¼ãƒ­ã§åŸ‹ã‚ã‚‰ã‚Œã‚‹ã‹ã€æŒ‡å®šã•ã‚ŒãŸã‚µã‚¤ã‚ºã¾ã§æœªå®šç¾©ã®æ–°ãŸãªå†…å®¹ã§åŸ‹ã‚ã‚‰ã‚Œã‚‹ã‹ã€ãŒã‚ã‚Šã¾ã™ã€‚åˆ©ç”¨å¯èƒ½ãªç’°å¢ƒ: Windows, å¤šãã® Unix ç³»ã€‚"

#: ../../library/stdtypes.rst:2622
msgid ""
"Write a string to the file.  There is no return value.  Due to buffering, "
"the string may not actually show up in the file until the :meth:`flush` or "
":meth:`close` method is called."
msgstr "æ–‡å­—åˆ—ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿ã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã«ã‚ˆã£ã¦ã€ :meth:`flush` ã¾ãŸã¯ :meth:`close` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¾ã§å®Ÿéš›ã«ãƒ•ã‚¡ã‚¤ãƒ«ä¸­ã«æ–‡å­—åˆ—ãŒæ›¸ãè¾¼ã¾ã‚Œãªã„ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2629
msgid ""
"Write a sequence of strings to the file.  The sequence can be any iterable "
"object producing strings, typically a list of strings. There is no return "
"value. (The name is intended to match :meth:`readlines`; :meth:`writelines` "
"does not add line separators.)"
msgstr "æ–‡å­—åˆ—ã‹ã‚‰ãªã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿ã¾ã™ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯æ–‡å­—åˆ—ã‚’ç”Ÿæˆã™ã‚‹åå¾©å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã‚‰ä½•ã§ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚ã‚ˆãã‚ã‚‹ã®ã¯æ–‡å­—åˆ—ã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã§ã™ã€‚æˆ»ã‚Šå€¤ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ (é–¢æ•°ã®åå‰ã¯ :meth:`readlines` ã¨å¯¾å¿œã¥ã‘ã¦ã¤ã‘ã‚‰ã‚Œã¾ã—ãŸ; :meth:`writelines` ã¯è¡Œé–“ã®åŒºåˆ‡ã‚Šã‚’è¿½åŠ ã—ã¾ã›ã‚“ã€‚)"

#: ../../library/stdtypes.rst:2634
msgid ""
"Files support the iterator protocol.  Each iteration returns the same result"
" as :meth:`~file.readline`, and iteration ends when the "
":meth:`~file.readline` method returns an empty string."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚å„åå¾©æ“ä½œã§ã¯ :meth:`~file.readline` ã¨åŒã˜çµæœã‚’è¿”ã—ã€åå¾©ã¯ :meth:`~file.readline` ãƒ¡ã‚½ãƒƒãƒ‰ãŒç©ºæ–‡å­—åˆ—ã‚’è¿”ã—ãŸéš›ã«çµ‚äº†ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2638
msgid ""
"File objects also offer a number of other interesting attributes. These are "
"not required for file-like objects, but should be implemented if they make "
"sense for the particular object."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã¾ãŸã€å¤šãã®èˆˆå‘³æ·±ã„å±æ€§ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã¯ãƒ•ã‚¡ã‚¤ãƒ«é¡ä¼¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯å¿…è¦ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ç‰¹å®šã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¨ã£ã¦æ„å‘³ã‚’æŒãŸã›ãŸã„ãªã‚‰å®Ÿè£…ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2645
msgid ""
"bool indicating the current state of the file object.  This is a read-only "
"attribute; the :meth:`close` method changes the value. It may not be "
"available on all file-like objects."
msgstr "ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®çŠ¶æ…‹ã‚’ç¤ºã™ãƒ–ãƒ¼ãƒ«å€¤ã§ã™ã€‚ã“ã®å€¤ã¯èª­ã¿å‡ºã—å°‚ç”¨ã®å±æ€§ã§ã™; :meth:`close` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã“ã®å€¤ã‚’å¤‰æ›´ã—ã¾ã™ã€‚å…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«é¡ä¼¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§åˆ©ç”¨å¯èƒ½ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2652
msgid ""
"The encoding that this file uses. When Unicode strings are written to a "
"file, they will be converted to byte strings using this encoding. In "
"addition, when the file is connected to a terminal, the attribute gives the "
"encoding that the terminal is likely to use (that  information might be "
"incorrect if the user has misconfigured the  terminal). The attribute is "
"read-only and may not be present on all file-like objects. It may also be "
"``None``, in which case the file uses the system default encoding for "
"converting Unicode strings."
msgstr "ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒä½¿ã£ã¦ã„ã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã™ã€‚ Unicode æ–‡å­—åˆ—ãŒãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¾ã‚Œã‚‹éš›ã€ Unicode æ–‡å­—åˆ—ã¯ã“ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã£ã¦ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚ã•ã‚‰ã«ã€ãƒ•ã‚¡ã‚¤ãƒ«ãŒç«¯æœ«ã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ã“ã®å±æ€§ã¯ç«¯æœ«ãŒä½¿ã£ã¦ã„ã‚‹ã¨ãŠã¼ã—ãã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° (ã“ã®æƒ…å ±ã¯ç«¯æœ«ãŒã†ã¾ãè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã«ã¯ä¸æ­£ç¢ºãªã“ã¨ã‚‚ã‚ã‚Šã¾ã™) ã‚’ä¸ãˆã¾ã™ã€‚ã“ã®å±æ€§ã¯èª­ã¿å‡ºã—å°‚ç”¨ã§ã€ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«é¡ä¼¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚ã¾ãŸã“ã®å€¤ã¯ ``None`` ã®ã“ã¨ã‚‚ã‚ã‚Šã€ã“ã®å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«ã¯ Unicode æ–‡å­—åˆ—ã®å¤‰æ›ã®ãŸã‚ã«ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2665
msgid "The Unicode error handler used along with the encoding."
msgstr "ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«ç”¨ã„ã‚‰ã‚Œã‚‹ã€ Unicode ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2672
msgid ""
"The I/O mode for the file.  If the file was created using the :func:`open` "
"built-in function, this will be the value of the *mode* parameter.  This is "
"a read-only attribute and may not be present on all file-like objects."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã® I/O ãƒ¢ãƒ¼ãƒ‰ã§ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒçµ„ã¿è¾¼ã¿é–¢æ•° :func:`open` ã§ä½œæˆã•ã‚ŒãŸå ´åˆã€ã“ã®å€¤ã¯å¼•æ•° *mode* ã®å€¤ã«ãªã‚Šã¾ã™ã€‚ã“ã®å€¤ã¯èª­ã¿å‡ºã—å°‚ç”¨ã®å±æ€§ã§ã€å…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«é¡ä¼¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å­˜åœ¨ã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2679
msgid ""
"If the file object was created using :func:`open`, the name of the file. "
"Otherwise, some string that indicates the source of the file object, of the "
"form ``<...>``.  This is a read-only attribute and may not be present on all"
" file-like objects."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ :func:`open` ã‚’ä½¿ã£ã¦ç”Ÿæˆã•ã‚ŒãŸå ´åˆã¯ã€ãã®ãƒ•ã‚¡ã‚¤ãƒ«åã§ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆã®èµ·æºã‚’ç¤ºã™ä½•ã‚‰ã‹ã®æ–‡å­—åˆ—ã«ãªã‚Šã€ ``<...>`` ã®å½¢å¼ã‚’ã¨ã‚Šã¾ã™ã€‚ã“ã®å€¤ã¯èª­ã¿å‡ºã—å°‚ç”¨ã®å±æ€§ã§ã€å…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«é¡ä¼¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å­˜åœ¨ã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2690
msgid ""
"If Python was built with :term:`universal newlines` enabled (the default) "
"this read-only attribute exists, and for files opened in universal newline "
"read mode it keeps track of the types of newlines encountered while reading "
"the file. The values it can take are ``'\\r'``, ``'\\n'``, ``'\\r\\n'``, "
"``None`` (unknown, no newlines read yet) or a tuple containing all the "
"newline types seen, to indicate that multiple newline conventions were "
"encountered. For files not opened in universal newlines read mode the value "
"of this attribute will be ``None``."
msgstr "Python ãŒ :term:`universal newlines` ã‚’ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã©ãŠã‚Š) æœ‰åŠ¹ã«ã—ã¦ãƒ“ãƒ«ãƒ‰ã•ã‚Œã¦ã„ã‚‹ãªã‚‰ã€ã“ã®èª­ã¿è¾¼ã¿å°‚ç”¨å±æ€§ãŒå­˜åœ¨ã—ã€ãƒ•ã‚¡ã‚¤ãƒ«ãŒ universal newlines ã§é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã§ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚ã£ãŸæ”¹è¡Œã®ç¨®é¡ã‚’è¨˜éŒ²ã—ã¾ã™ã€‚å–ã‚Šå¾—ã‚‹å€¤ã¯ ``'\\r'``, ``'\\n'``, ``'\\r\\n'``, ``None`` (ä¸æ˜ã§ã‚ã‚‹ã‹ã€ã¾ã æ”¹è¡Œã‚’èª­ã¿è¾¼ã‚“ã§ã„ãªã„)ã€ã¾ãŸã¯ã€è¤‡æ•°ã®æ”¹è¡Œæ–¹å¼ã®ç¨®é¡ãŒå­˜åœ¨ã—ãŸã“ã¨ã‚’è¡¨ã™ã€è¦‹ã¤ã‹ã£ãŸã™ã¹ã¦ã®æ”¹è¡Œã®ç¨®é¡ã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã§ã™ã€‚ universal newlines ã§é–‹ã‹ã‚ŒãŸã®ã§ãªã„ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦ã¯ã€ã“ã®å±æ€§ã®å€¤ã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2702
msgid ""
"Boolean that indicates whether a space character needs to be printed before "
"another value when using the :keyword:`print` statement. Classes that are "
"trying to simulate a file object should also have a writable "
":attr:`softspace` attribute, which should be initialized to zero.  This will"
" be automatic for most classes implemented in Python (care may be needed for"
" objects that override attribute access); types implemented in C will have "
"to provide a writable :attr:`softspace` attribute."
msgstr ":keyword:`print` æ–‡ã‚’ä½¿ã£ãŸå ´åˆã€ä»–ã®å€¤ã‚’å‡ºåŠ›ã™ã‚‹å‰ã«ã‚¹ãƒšãƒ¼ã‚¹æ–‡å­—ã‚’å‡ºåŠ›ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™ãƒ–ãƒ¼ãƒ«å€¤ã§ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆä»•æ§˜ã¨ã™ã‚‹ã‚¯ãƒ©ã‚¹ã¯æ›¸ãè¾¼ã¿å¯èƒ½ãª :attr:`softspace` å±æ€§ã‚’æŒãŸãªã‘ã‚Œã°ãªã‚‰ãšã€ã“ã®å€¤ã¯ã‚¼ãƒ­ã«åˆæœŸåŒ–ã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®å€¤ã¯ Python ã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã»ã¨ã‚“ã©ã®ã‚¯ãƒ©ã‚¹ã§è‡ªå‹•çš„ã«åˆæœŸåŒ–ã•ã‚Œã¾ã™ (å±æ€§ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ‰‹æ®µã‚’ä¸Šæ›¸ãã™ã‚‹ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯æ³¨æ„ãŒå¿…è¦ã§ã™); C ã§å®Ÿè£…ã•ã‚ŒãŸå‹ã§ã¯ã€æ›¸ãè¾¼ã¿å¯èƒ½ãª :attr:`softspace` å±æ€§ã‚’æä¾›ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2712
msgid ""
"This attribute is not used to control the :keyword:`print` statement, but to"
" allow the implementation of :keyword:`print` to keep track of its internal "
"state."
msgstr "ã“ã®å±æ€§ã¯ :keyword:`print` æ–‡ã‚’åˆ¶å¾¡ã™ã‚‹ãŸã‚ã«ç”¨ã„ã‚‰ã‚Œã‚‹ã®ã§ã¯ãªãã€ :keyword:`print` ã®å®Ÿè£…ã«ãã®å†…éƒ¨çŠ¶æ…‹ã‚’è¿½è·¡ã•ã›ã‚‹ãŸã‚ã«ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2720
msgid "memoryview type"
msgstr "ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼å‹"

#: ../../library/stdtypes.rst:2724
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of"
" an object that supports the buffer protocol without copying.  Memory is "
"generally interpreted as simple bytes."
msgstr ":class:`memoryview` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€Python ã‚³ãƒ¼ãƒ‰ãŒã€ãƒãƒƒãƒ•ã‚¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…éƒ¨ãƒ‡ãƒ¼ã‚¿ã¸ã€ã‚³ãƒ”ãƒ¼ã™ã‚‹ã“ã¨ãªãã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚ãƒ¡ãƒ¢ãƒªã¯é€šå¸¸ã€å˜ç´”ãªãƒã‚¤ãƒˆåˆ—ã¨ã—ã¦è§£é‡ˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2730
msgid ""
"Create a :class:`memoryview` that references *obj*.  *obj* must support the "
"buffer protocol.  Built-in objects that support the buffer protocol include "
":class:`str` and :class:`bytearray` (but not :class:`unicode`)."
msgstr "*obj* ã‚’å‚ç…§ã™ã‚‹ :class:`memoryview` ã‚’ä½œæˆã—ã¾ã™ã€‚ *obj* ã¯ãƒãƒƒãƒ•ã‚¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ•ã‚¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹çµ„ã¿è¾¼ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€ :class:`str` ã€ :class:`bytearray` ãªã©ãŒã‚ã‚Šã¾ã™ (ãŸã ã—ã€ :class:`unicode` ã¯é•ã„ã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:2734
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating object *obj*.  For many simple types "
"such as :class:`str` and :class:`bytearray`, an element is a single byte, "
"but other third-party types may expose larger elements."
msgstr ":class:`memoryview` ã«ã¯ *è¦ç´ * ã®æ¦‚å¿µãŒã‚ã‚Šã€ãã‚ŒãŒèµ·æºã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *obj* ã«ã‚ˆã£ã¦æ‰±ã‚ã‚Œã‚‹åŸå­çš„ãªãƒ¡ãƒ¢ãƒªã®å˜ä½ã«ãªã‚Šã¾ã™ã€‚å¤šãã®å˜ç´”ãªå‹ã€ä¾‹ãˆã° :class:`str` ã‚„ :class:`bytearray` ã§ã¯ã€è¦ç´ ã¯å˜ãƒã‚¤ãƒˆã«ãªã‚Šã¾ã™ãŒã€ä»–ã®ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã®å‹ã§ã¯ã€è¦ç´ ã¯ã‚ˆã‚Šå¤§ãããªã‚Šãˆã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2739
msgid ""
"``len(view)`` returns the total number of elements in the memoryview, "
"*view*.  The :class:`~memoryview.itemsize` attribute will give you the "
"number of bytes in a single element."
msgstr "``len(view)`` ã¯ã€ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ *view* ã®è¦ç´ ã®ç·æ•°ã‚’è¿”ã—ã¾ã™ã€‚ :class:`~memoryview.itemsize` å±æ€§ã§ä¸€ã¤ã®è¦ç´ å†…ã®ãƒã‚¤ãƒˆæ•°ã‚’å–å¾—ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2743
msgid ""
"A :class:`memoryview` supports slicing to expose its data.  Taking a single "
"index will return a single element as a :class:`str` object.  Full slicing "
"will result in a subview::"
msgstr ":class:`memoryview` ã¯ã‚¹ãƒ©ã‚¤ã‚¹ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’æ™’ã™ã“ã¨ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚ä¸€ã¤ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã‚’æ¸¡ã™ã¨ä¸€ã¤ã®è¦ç´ ã‚’ :class:`str` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚å®Œå…¨ãªã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ã¯éƒ¨åˆ†ãƒ“ãƒ¥ãƒ¼ã«ãªã‚Šã¾ã™::"

#: ../../library/stdtypes.rst:2757
msgid ""
"If the object the memoryview is over supports changing its data, the "
"memoryview supports slice assignment::"
msgstr "ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ãŒåŸºã«ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒ‡ãƒ¼ã‚¿ã®å¤‰æ›´ã«å¯¾å¿œã—ã¦ã„ã‚Œã°ã€ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ã¯ã‚¹ãƒ©ã‚¤ã‚¹ä»£å…¥ã«å¯¾å¿œã—ã¾ã™::"

#: ../../library/stdtypes.rst:2775
msgid "Notice how the size of the memoryview object cannot be changed."
msgstr "ã“ã®é€šã‚Šã€ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é•·ã•ã¯å¤‰ãˆã‚‰ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2777
msgid ":class:`memoryview` has two methods:"
msgstr ":class:`memoryview` ã«ã¯ 2 ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2781
msgid ""
"Return the data in the buffer as a bytestring (an object of class "
":class:`str`). ::"
msgstr "ãƒãƒƒãƒ•ã‚¡ä¸­ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒã‚¤ãƒˆæ–‡å­—åˆ— (ã‚¯ãƒ©ã‚¹ :class:`str` ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) ã¨ã—ã¦è¿”ã—ã¾ã™::"

#: ../../library/stdtypes.rst:2790
msgid "Return the data in the buffer as a list of integers. ::"
msgstr "ãƒãƒƒãƒ•ã‚¡ä¸­ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ•´æ•°ã®ãƒªã‚¹ãƒˆã¨ã—ã¦è¿”ã—ã¾ã™::"

#: ../../library/stdtypes.rst:2795
msgid "There are also several readonly attributes available:"
msgstr "èª­ã¿è¾¼ã¿å°‚ç”¨ã®å±æ€§ã‚‚ã„ãã¤ã‹ä½¿ãˆã¾ã™:"

#: ../../library/stdtypes.rst:2799
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view.  This defaults to ``'B'``, a simple bytestring."
msgstr "ãƒ“ãƒ¥ãƒ¼ã®ãã‚Œãã‚Œã®è¦ç´ ã«å¯¾ã™ã‚‹ã€(:mod:`struct` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¹ã‚¿ã‚¤ãƒ«ã§ã®) ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’å«ã‚€æ–‡å­—åˆ—ã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``'B'`` ã§ã€å˜ç´”ãªãƒã‚¤ãƒˆæ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2804
msgid "The size in bytes of each element of the memoryview."
msgstr "ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ã®ãã‚Œãã‚Œã®è¦ç´ ã®ãƒã‚¤ãƒˆæ•°ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2808
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr "ãƒ¡ãƒ¢ãƒªã®å½¢çŠ¶ã‚’ N æ¬¡å…ƒé…åˆ—ã¨ã—ã¦ä¸ãˆã‚‹ã€é•·ã• :attr:`ndim` ã®æ•´æ•°ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2813
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr "ãƒ¡ãƒ¢ãƒªãŒè¡¨ã™å¤šæ¬¡å…ƒé…åˆ—ãŒä½•æ¬¡å…ƒã‹ã‚’ç¤ºã™æ•´æ•°ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2818
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr "é…åˆ—ã®ãã‚Œãã‚Œã®æ¬¡å…ƒã«å¯¾ã—ã¦ã€ãã‚Œãã‚Œã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ã«å¿…è¦ãªãƒã‚¤ãƒˆæ•°ã‚’è¡¨ã™ã€é•·ã• :attr:`ndim` ã®æ•´æ•°ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2823
msgid "A bool indicating whether the memory is read only."
msgstr "ãƒ¡ãƒ¢ãƒªãŒèª­ã¿è¾¼ã¿å°‚ç”¨ã‹ã‚’è¡¨ã™ãƒ–ãƒ¼ãƒ«ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2831
msgid "Context Manager Types"
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£å‹"

#: ../../library/stdtypes.rst:2840
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context"
" defined by a context manager.  This is implemented using two separate "
"methods that allow user-defined classes to define a runtime context that is "
"entered before the statement body is executed and exited when the statement "
"ends."
msgstr "Python ã® :keyword:`with` æ–‡ã¯ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚Œã‚‹å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ¦‚å¿µã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒ¦ãƒ¼ã‚¶å®šç¾©ã‚¯ãƒ©ã‚¹ãŒæ–‡ã®æœ¬ä½“ãŒå®Ÿè¡Œã•ã‚Œã‚‹å‰ã«é€²å…¥ã—æ–‡ã®çµ‚ã‚ã‚Šã§è„±å‡ºã™ã‚‹å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å®šç¾©ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ä¸€å¯¾ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã¾ã™:"

#: ../../library/stdtypes.rst:2845
msgid ""
"The :dfn:`context management protocol` consists of a pair of methods that "
"need to be provided for a context manager object to define a runtime "
"context:"
msgstr ":dfn:`ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†ãƒ—ãƒ­ãƒˆã‚³ãƒ«` (:dfn:`context management protocol`) ã¯å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å®šç¾©ã™ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæä¾›ã™ã¹ãä¸€å¯¾ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰æˆã‚Šã¾ã™:"

#: ../../library/stdtypes.rst:2851
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`as` clause of :keyword:`with` statements "
"using this context manager."
msgstr "å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å…¥ã‚Šã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ä»–ã®å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«é–¢é€£ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿”ã™å€¤ã¯ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’ä½¿ã† :keyword:`with` æ–‡ã® :keyword:`as` ç¯€ã®è­˜åˆ¥å­ã«æŸç¸›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2856
msgid ""
"An example of a context manager that returns itself is a file object. File "
"objects return themselves from __enter__() to allow :func:`open` to be used "
"as the context expression in a :keyword:`with` statement."
msgstr "è‡ªåˆ†è‡ªèº«ã‚’è¿”ã™ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®ä¾‹ã¨ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚Šã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :meth:`__enter__` ã‹ã‚‰è‡ªåˆ†è‡ªèº«ã‚’è¿”ã—ã¦ :func:`open` ãŒ :keyword:`with` æ–‡ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå¼ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2860
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside the"
" :keyword:`with` statement."
msgstr "é–¢é€£ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®ä¾‹ã¨ã—ã¦ã¯ :func:`decimal.localcontext` ãŒè¿”ã™ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ãƒãƒãƒ¼ã‚¸ãƒ£ã¯ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãª10é€²æ•°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ã‚³ãƒ”ãƒ¼ã«ã‚»ãƒƒãƒˆã—ã¦ãã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ã“ã†ã™ã‚‹ã“ã¨ã§, :keyword:`with` æ–‡ã®æœ¬ä½“ã®å†…éƒ¨ã§ã€å¤–å´ã®ã‚³ãƒ¼ãƒ‰ã«å½±éŸ¿ã‚’ä¸ãˆãšã«ã€ 10é€²æ•°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å¤‰æ›´ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2870
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while"
" executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr "å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰æŠœã‘ã€ä¾‹å¤– (ãŒã‚‚ã—èµ·ã“ã£ã¦ã„ãŸã¨ã—ã¦ã‚‚) ã‚’æŠ‘åˆ¶ã™ã‚‹ã“ã¨ã‚’ç¤ºã™ãƒ–ãƒ¼ãƒ«å€¤ãƒ•ãƒ©ã‚°ã‚’è¿”ã—ã¾ã™ã€‚ :keyword:`with` æ–‡ã®æœ¬ä½“ã‚’å®Ÿè¡Œä¸­ã«ä¾‹å¤–ãŒèµ·ã“ã£ãŸãªã‚‰ã°ã€å¼•æ•°ã«ã¯ãã®ä¾‹å¤–ã®å‹ã¨å€¤ã¨ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯æƒ…å ±ã‚’æ¸¡ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€å¼•æ•°ã¯å…¨ã¦ ``None`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2875
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`with` statement. Otherwise the"
" exception continues propagating after this method has finished executing. "
"Exceptions that occur during execution of this method will replace any "
"exception that occurred in the body of the :keyword:`with` statement."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰çœŸå€¤ãŒè¿”ã•ã‚Œã‚‹ã¨ :keyword:`with` æ–‡ã¯ä¾‹å¤–ã®ç™ºç”Ÿã‚’æŠ‘ãˆã€ :keyword:`with` æ–‡ã®ç›´å¾Œã®æ–‡ã«å®Ÿè¡Œã‚’ç¶šã‘ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè¡Œã‚’çµ‚ãˆã‚‹ã¨ä¾‹å¤–ã®ä¼æ’­ãŒç¶šãã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè¡Œä¸­ã«èµ·ããŸä¾‹å¤–ã¯ :keyword:`with` æ–‡ã®æœ¬ä½“ã®å®Ÿè¡Œä¸­ã«èµ·ã“ã£ãŸä¾‹å¤–ã‚’ç½®ãæ›ãˆã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2882
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows"
" context management code (such as ``contextlib.nested``) to easily detect "
"whether or not an :meth:`__exit__` method has actually failed."
msgstr "æ¸¡ã•ã‚ŒãŸä¾‹å¤–ã‚’æ˜ç¤ºçš„ã«å†é€å‡ºã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã®ä»£ã‚ã‚Šã«ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå½ã®å€¤ã‚’è¿”ã™ã“ã¨ã§ãƒ¡ã‚½ãƒƒãƒ‰ã®æ­£å¸¸çµ‚äº†ã¨é€å‡ºã•ã‚ŒãŸä¾‹å¤–ã‚’æŠ‘åˆ¶ã—ãªã„ã“ã¨ã‚’ä¼ãˆã‚‹ã¹ãã§ã™ã€‚ã“ã®ã‚ˆã†ã«ã™ã‚Œã° (``contextlib.nested`` ã®ã‚ˆã†ãª) ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¯ :meth:`__exit__` ãƒ¡ã‚½ãƒƒãƒ‰è‡ªä½“ãŒå¤±æ•—ã—ãŸã®ã‹ã©ã†ã‹ã‚’ç°¡å˜ã«è¦‹åˆ†ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2888
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr "Python ã¯å¹¾ã¤ã‹ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’ã€æ˜“ã—ã„ã‚¹ãƒ¬ãƒƒãƒ‰åŒæœŸãƒ»ãƒ•ã‚¡ã‚¤ãƒ«ãªã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å³æ™‚ã‚¯ãƒ­ãƒ¼ã‚ºãƒ»å˜ç´”åŒ–ã•ã‚ŒãŸã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãª10é€²ç®—è¡“ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ã‚µãƒãƒ¼ãƒˆã®ãŸã‚ã«ç”¨æ„ã—ã¦ã„ã¾ã™ã€‚å„å‹ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã¨ã„ã†ä»¥ä¸Šã®ç‰¹åˆ¥ã®å–ã‚Šæ‰±ã„ã‚’å—ã‘ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¾‹ã«ã¤ã„ã¦ã¯ :mod:`contextlib` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2894
msgid ""
"Python's :term:`generator`\\s and the ``contextlib.contextmanager`` "
":term:`decorator` provide a convenient way to implement these protocols.  If"
" a generator function is decorated with the ``contextlib.contextmanager`` "
"decorator, it will return a context manager implementing the necessary "
":meth:`__enter__` and :meth:`__exit__` methods, rather than the iterator "
"produced by an undecorated generator function."
msgstr "Python ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ (:term:`generator`) ã¨ ``contextlib.contextmanager`` ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ (:term:`decorator`) ã¯ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ç°¡ä¾¿ãªå®Ÿè£…æ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã‚’ ``contextlib.contextmanager`` ã§ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã¨ã€ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã—ãªã‘ã‚Œã°è¿”ã•ã‚Œã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã™ä»£ã‚ã‚Šã«ã€å¿…è¦ãª :meth:`__enter__` ãŠã‚ˆã³ :meth:`__exit__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2901
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to"
" define these methods must provide them as a normal Python accessible "
"method. Compared to the overhead of setting up the runtime context, the "
"overhead of a single class dictionary lookup is negligible."
msgstr "ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ãŸã‚ã« Python/C API ã®ä¸­ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹æ§‹é€ ä½“ã«ç‰¹åˆ¥ãªã‚¹ãƒ­ãƒƒãƒˆãŒä½œã‚‰ã‚ŒãŸã‚ã‘ã§ã¯ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ãŸã„æ‹¡å¼µå‹ã¯ã“ã‚Œã‚‰ã‚’é€šå¸¸ã® Python ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦æä¾›ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æº–å‚™ã™ã‚‹ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã«æ¯”ã¹ãŸã‚‰ã€ä¸€å›ã®ã‚¯ãƒ©ã‚¹è¾æ›¸ã®æ¢ç´¢ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã¯ç„¡è¦–ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2911
msgid "Other Built-in Types"
msgstr "ãã®ä»–ã®çµ„ã¿è¾¼ã¿å‹"

#: ../../library/stdtypes.rst:2913
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr "ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€ãã®ä»–ã„ãã¤ã‹ã®ç¨®é¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã»ã¨ã‚“ã©ã¯ 1 ã¾ãŸã¯ 2 ã¤ã®æ¼”ç®—ã ã‘ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2920
msgid "Modules"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/stdtypes.rst:2922
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the "
":keyword:`import` statement is not, strictly speaking, an operation on a "
"module object; ``import foo`` does not require a module object named *foo* "
"to exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å¯¾ã™ã‚‹å”¯ä¸€ã®ç‰¹æ®Šãªæ¼”ç®—ã¯å±æ€§ã‚¢ã‚¯ã‚»ã‚¹: ``m.name`` ã§ã™ã€‚ã“ã“ã§ *m* ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã€ *name* ã¯ *m* ã®ã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ä¸Šã«å®šç¾©ã•ã‚ŒãŸåå‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å±æ€§ã«ä»£å…¥ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ (ãªãŠã€:keyword:`import` æ–‡ã¯ã€å³å¯†ã«ã„ãˆã°ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹æ¼”ç®—ã§ã¯ã‚ã‚Šã¾ã›ã‚“; ``import foo`` ã¯ *foo* ã¨åã¥ã‘ã‚‰ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å­˜åœ¨ã‚’å¿…è¦ã¨ã¯ã›ãšã€*foo* ã¨åã¥ã‘ã‚‰ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® (å¤–éƒ¨ã®) *å®šç¾©* ã‚’å¿…è¦ã¨ã—ã¾ã™ã€‚)"

#: ../../library/stdtypes.rst:2929
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the"
" dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to the"
" :attr:`~object.__dict__` attribute is not possible (you can write "
"``m.__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't "
"write ``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is "
"not recommended."
msgstr "å…¨ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ã‚‹ç‰¹æ®Šå±æ€§ãŒ :attr:`~object.__dict__` ã§ã™ã€‚ã“ã‚Œã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å«ã‚€è¾æ›¸ã§ã™ã€‚ã“ã®è¾æ›¸ã‚’æ›¸ãæ›ãˆã‚‹ã¨å®Ÿéš›ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€:attr:`~object.__dict__` å±æ€§ã‚’ç›´æ¥ä»£å…¥ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ (``m.__dict__['a'] = 1`` ã¨æ›¸ã„ã¦ ``m.a`` ã‚’ ``1`` ã«å®šç¾©ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã™ãŒã€``m.__dict__ = {}`` ã¨æ›¸ãã“ã¨ã¯ã§ãã¾ã›ã‚“)ã€‚ :attr:`~object.__dict__` ã‚’ç›´æ¥æ›¸ãæ›ãˆã‚‹ã“ã¨ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2937
msgid ""
"Modules built into the interpreter are written like this: ``<module 'sys' "
"(built-in)>``.  If loaded from a file, they are written as ``<module 'os' "
"from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr "ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å†…ã«çµ„ã¿è¾¼ã¾ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ ``<module 'sys' (built-in)>`` ã®ã‚ˆã†ã«æ›¸ã‹ã‚Œã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿å‡ºã•ã‚ŒãŸå ´åˆã€ ``<module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>`` ã¨æ›¸ã‹ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2945
msgid "Classes and Class Instances"
msgstr "ã‚¯ãƒ©ã‚¹ãŠã‚ˆã³ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹"

#: ../../library/stdtypes.rst:2947
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "ã“ã‚Œã‚‰ã«ã¤ã„ã¦ã¯ :ref:`objects` ãŠã‚ˆã³ :ref:`class` ã‚’å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2953
msgid "Functions"
msgstr "é–¢æ•°"

#: ../../library/stdtypes.rst:2955
msgid ""
"Function objects are created by function definitions.  The only operation on"
" a function object is to call it: ``func(argument-list)``."
msgstr "é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é–¢æ•°å®šç¾©ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã¾ã™ã€‚é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å”¯ä¸€ã®æ“ä½œã¯ã€ãã‚Œã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã™: ``func(argument-list)`` ã€‚"

#: ../../library/stdtypes.rst:2958
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr "é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯å®Ÿéš›ã«ã¯äºŒç¨®é¡ã‚ã‚Šã¾ã™: çµ„ã¿è¾¼ã¿é–¢æ•°ã¨ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã§ã™ã€‚ã©ã¡ã‚‰ã‚‚åŒã˜æ“ä½œ (é–¢æ•°ã®å‘¼ã³å‡ºã—) ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ãŒã€å®Ÿè£…ã¯ç•°ãªã‚‹ã®ã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚‚ç•°ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2962
msgid "See :ref:`function` for more information."
msgstr "è©³ç´°ã¯ã€ :ref:`function` ã‚’å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2968
msgid "Methods"
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../library/stdtypes.rst:2972
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰ã¯å±æ€§è¡¨è¨˜ã‚’ä½¿ã£ã¦å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°ã§ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯äºŒç¨®é¡ã‚ã‚Šã¾ã™: (ãƒªã‚¹ãƒˆã® :meth:`append` ã®ã‚ˆã†ãª) çµ„ã¿è¾¼ã¿ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚çµ„ã¿è¾¼ã¿ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãã‚Œã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å‹ã¨ä¸€ç·’ã«è¨˜è¿°ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2977
msgid ""
"The implementation adds two special read-only attributes to class instance "
"methods: ``m.im_self`` is the object on which the method operates, and "
"``m.im_func`` is the function implementing the method.  Calling ``m(arg-1, "
"arg-2, ..., arg-n)`` is completely equivalent to calling "
"``m.im_func(m.im_self, arg-1, arg-2, ..., arg-n)``."
msgstr "å®Ÿè£…ã§ã¯ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã« 2 ã¤ã®èª­ã¿è¾¼ã¿å°‚ç”¨ã®å±æ€§ã‚’è¿½åŠ ã—ã¦ã„ã¾ã™: ``m.im_self`` ã¯ãƒ¡ã‚½ãƒƒãƒ‰ãŒæ“ä½œã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ ``m.im_func`` ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹é–¢æ•°ã§ã™ã€‚ ``m(arg-1, arg-2, ..., arg-n)`` ã®å‘¼ã³å‡ºã—ã¯ã€ ``m.im_func(m.im_self, arg-1, arg-2, ..., arg-n)`` ã®å‘¼ã³å‡ºã—ã¨å®Œå…¨ã«ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2983
msgid ""
"Class instance methods are either *bound* or *unbound*, referring to whether"
" the method was accessed through an instance or a class, respectively.  When"
" a method is unbound, its ``im_self`` attribute will be ``None`` and if "
"called, an explicit ``self`` object must be passed as the first argument.  "
"In this case, ``self`` must be an instance of the unbound method's class (or"
" a subclass of that class), otherwise a :exc:`TypeError` is raised."
msgstr "ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ã‹ã‚¯ãƒ©ã‚¹ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ã‹ã«ã‚ˆã£ã¦ã€ãã‚Œãã‚Œ *ãƒã‚¤ãƒ³ãƒ‰* (æŸç¸›) ã¾ãŸã¯ *éãƒã‚¤ãƒ³ãƒ‰* (éæŸç¸›) ãŒã‚ã‚Šã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ãŒéãƒã‚¤ãƒ³ãƒ‰ãƒ¡ã‚½ãƒƒãƒ‰ã®å ´åˆã€ ``im_self`` å±æ€§ã¯ ``None`` ã«ãªã‚‹ãŸã‚ã€å‘¼ã³å‡ºã™éš›ã«ã¯ ``self`` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ˜ç¤ºçš„ã«ç¬¬ä¸€å¼•æ•°ã¨ã—ã¦æŒ‡å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®å ´åˆã€ ``self`` ã¯éãƒã‚¤ãƒ³ãƒ‰ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚¯ãƒ©ã‚¹ (ã¾ãŸã¯ãã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹) ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ãã†ã§ãªã‘ã‚Œã° :exc:`TypeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2990
msgid ""
"Like function objects, methods objects support getting arbitrary attributes."
" However, since method attributes are actually stored on the underlying "
"function object (``meth.im_func``), setting method attributes on either "
"bound or unbound methods is disallowed.  Attempting to set an attribute on a"
" method results in an :exc:`AttributeError` being raised.  In order to set a"
" method attribute, you need to explicitly set it on the underlying function "
"object::"
msgstr "é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒã˜ãã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»»æ„ã®å±æ€§ã‚’å–å¾—ã§ãã¾ã™ã€‚ã—ã‹ã—ã€ãƒ¡ã‚½ãƒƒãƒ‰å±æ€§ã¯å®Ÿéš›ã«ã¯èƒŒå¾Œã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (``meth.im_func``) ã«è¨˜æ†¶ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ãƒã‚¤ãƒ³ãƒ‰ãƒ¡ã‚½ãƒƒãƒ‰ã€éãƒã‚¤ãƒ³ãƒ‰ãƒ¡ã‚½ãƒƒãƒ‰ã¸ã®ãƒ¡ã‚½ãƒƒãƒ‰å±æ€§ã®è¨­å®šã¯è¨±ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã¸ã®å±æ€§ã®è¨­å®šã‚’è©¦ã¿ã‚‹ã¨ :exc:`AttributeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰å±æ€§ã‚’è¨­å®šã™ã‚‹ãŸã‚ã«ã¯ã€ãã®èƒŒå¾Œã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§æ˜ç¤ºçš„ã«ã‚»ãƒƒãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™::"

#: ../../library/stdtypes.rst:3011 ../../library/stdtypes.rst:3039
msgid "See :ref:`types` for more information."
msgstr "è©³ç´°ã¯ã€ :ref:`types` ã‚’å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:3019
msgid "Code Objects"
msgstr "ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:3025
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\""
" executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their "
":attr:`func_code` attribute. See also the :mod:`code` module."
msgstr "ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€é–¢æ•°æœ¬ä½“ã®ã‚ˆã†ãª \"æ“¬ä¼¼ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸ\" Python ã®å®Ÿè¡Œå¯èƒ½ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ã™ãŸã‚ã«å®Ÿè£…ç³»ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªå®Ÿè¡Œç’°å¢ƒã¸ã®å‚ç…§ã‚’æŒãŸãªã„ç‚¹ã§é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¯ç•°ãªã‚Šã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿é–¢æ•° :func:`compile` ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã€ã¾ãŸé–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :attr:`func_code` å±æ€§ã¨ã—ã¦å–ã‚Šå‡ºã›ã¾ã™ã€‚ :mod:`code` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:3036
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :keyword:`exec` statement or the built-in :func:`eval`"
" function."
msgstr "ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ :func:`exec` æ–‡ã‚„çµ„ã¿è¾¼ã¿é–¢æ•° :func:`eval` ã« (ã‚½ãƒ¼ã‚¹æ–‡å­—åˆ—ã®ä»£ã‚ã‚Šã«) æ¸¡ã™ã“ã¨ã§ã€å®Ÿè¡Œã‚„è©•ä¾¡ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3045
msgid "Type Objects"
msgstr "å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:3051
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all"
" standard built-in types."
msgstr "å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ§˜ã€…ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã‚’è¡¨ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã¯çµ„ã¿è¾¼ã¿é–¢æ•° :func:`type` ã§ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã¾ã™ã€‚å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ç‰¹æœ‰ã®æ“ä½œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æ¨™æº–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`types` ã«ã¯å…¨ã¦ã®çµ„ã¿è¾¼ã¿å‹åãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3056
msgid "Types are written like this: ``<type 'int'>``."
msgstr "å‹ã¯ã“ã®ã‚ˆã†ã«æ›¸ãè¡¨ã•ã‚Œã¾ã™: ``<type 'int'>`` ã€‚"

#: ../../library/stdtypes.rst:3062
msgid "The Null Object"
msgstr "ãƒŒãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:3064
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name)."
msgstr "ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ˜ç¤ºçš„ã«å€¤ã‚’è¿”ã•ãªã„é–¢æ•°ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ç‰¹æœ‰ã®æ“ä½œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒŒãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸€ã¤ã ã‘ã§ã€ ``None`` (çµ„ã¿è¾¼ã¿å) ã¨åã¥ã‘ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3068
msgid "It is written as ``None``."
msgstr "``None`` ã¨æ›¸ãè¡¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3074
msgid "The Ellipsis Object"
msgstr "Ellipsis ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:3076
msgid ""
"This object is used by extended slice notation (see :ref:`slicings`).  It "
"supports no special operations.  There is exactly one ellipsis object, named"
" :const:`Ellipsis` (a built-in name)."
msgstr "ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ‹¡å¼µã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã¾ã™ (:ref:`slicings` ã‚’å‚ç…§ä¸‹ã•ã„)ã€‚ç‰¹æ®Šãªæ“ä½œã¯ä½•ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚çœç•¥è¡¨è¨˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸€ã¤ã ã‘ã§ã€ãã®åå‰ã¯ :const:`Ellipsis` (çµ„ã¿è¾¼ã¿å) ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3080
msgid ""
"It is written as ``Ellipsis``.  When in a subscript, it can also be written "
"as ``...``, for example ``seq[...]``."
msgstr "``Ellipsis`` ã¨æ›¸ãè¡¨ã•ã‚Œã¾ã™ã€‚æ·»ãˆå­—ã¨ã—ã¦ä½¿ã†å ´åˆ ``...`` ã¨ã‚‚æ›¸ã‘ã¾ã™ã€‚ä¾‹ãˆã° ``seq[...]`` ã®ã‚ˆã†ã«ã€‚"

#: ../../library/stdtypes.rst:3085
msgid "The NotImplemented Object"
msgstr "NotImplemented ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:3087
msgid ""
"This object is returned from comparisons and binary operations when they are"
" asked to operate on types they don't support. See :ref:`comparisons` for "
"more information."
msgstr "ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€å¯¾å¿œã—ã¦ã„ãªã„å‹ã®æ¼”ç®—ã‚’æ±‚ã‚ã‚‰ã‚ŒãŸã¨ãã€æ¯”è¼ƒã‚„äºŒé …æ¼”ç®—ã‹ã‚‰è¿”ã•ã‚Œã¾ã™ã€‚è©³ç´°ã¯ :ref:`comparisons` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:3091
msgid "It is written as ``NotImplemented``."
msgstr "``NotImplemented`` ã¨æ›¸ãè¡¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3095
msgid "Boolean Values"
msgstr "ãƒ–ãƒ¼ãƒ«å€¤"

#: ../../library/stdtypes.rst:3097
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and"
" 1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr "ãƒ–ãƒ¼ãƒ«å€¤ã¯äºŒã¤ã®å®šæ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ``False`` ãŠã‚ˆã³ ``True`` ã§ã™ã€‚ã“ã‚Œã‚‰ã¯çœŸç†å€¤ã‚’è¡¨ã™ã®ã«ä½¿ã‚ã‚Œã¾ã™ (ãŸã ã—ä»–ã®å€¤ã‚‚å½ã‚„çœŸã¨ã¿ãªã•ã‚Œã¾ã™)ã€‚ æ•°å€¤å‡¦ç†ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ (ä¾‹ãˆã°ç®—è¡“æ¼”ç®—å­ã®å¼•æ•°ã¨ã—ã¦ä½¿ã‚ã‚ŒãŸå ´åˆ) ã§ã¯ã€ã“ã‚Œã‚‰ã¯ãã‚Œãã‚Œ 0 ãŠã‚ˆã³ 1 ã¨åŒæ§˜ã«æŒ¯èˆã„ã¾ã™ã€‚ä»»æ„ã®å€¤ã«å¯¾ã—ã¦ã€çœŸç†å€¤ã¨è§£é‡ˆã§ãã‚‹å ´åˆã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`bool` ã¯å€¤ã‚’ãƒ–ãƒ¼ãƒ«å€¤ã«å¤‰æ›ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã¾ã™ (ä¸Šè¿°ã® :ref:`truth` ã®ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../library/stdtypes.rst:3110
msgid "They are written as ``False`` and ``True``, respectively."
msgstr "ãã‚Œãã‚Œ ``False`` ãŠã‚ˆã³ ``True`` ã¨æ›¸ãè¡¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3116
msgid "Internal Objects"
msgstr "å†…éƒ¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:3118
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr "ã“ã®æƒ…å ±ã¯ :ref:`types` ã‚’å‚ç…§ä¸‹ã•ã„ã€‚ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦è¨˜è¿°ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3125
msgid "Special Attributes"
msgstr "ç‰¹æ®Šå±æ€§"

#: ../../library/stdtypes.rst:3127
msgid ""
"The implementation adds a few special read-only attributes to several object"
" types, where they are relevant.  Some of these are not reported by the "
":func:`dir` built-in function."
msgstr "å®Ÿè£…ã¯ã€ã„ãã¤ã‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã«å¯¾ã—ã¦ã€é©åˆ‡ãªå ´åˆã«ã¯ç‰¹æ®Šãªèª­ã¿å‡ºã—å°‚ç”¨ã®å±æ€§ã‚’è¿½åŠ ã—ã¾ã™ã€‚ãã®ã†ã¡ã„ãã¤ã‹ã¯ :func:`dir` çµ„è¾¼ã¿é–¢æ•°ã§å ±å‘Šã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:3134
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® (æ›¸ãè¾¼ã¿å¯èƒ½ãª) å±æ€§ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹è¾æ›¸ã¾ãŸã¯ãã®ä»–ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/stdtypes.rst:3140 ../../library/stdtypes.rst:3147
msgid ""
"Use the built-in function :func:`dir` to get a list of an object's "
"attributes. This attribute is no longer available."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§ã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã‚’å–å¾—ã™ã‚‹ã«ã¯ã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`dir` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ã“ã®å±æ€§ã¯ã‚‚ã†åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:3154
msgid "The class to which a class instance belongs."
msgstr "ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒå±ã—ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3159
msgid "The tuple of base classes of a class object."
msgstr "ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3164
msgid ""
"The name of the class, type, function, method, descriptor, or generator "
"instance."
msgstr "ã‚¯ãƒ©ã‚¹ã€å‹ã€é–¢æ•°ã€ãƒ¡ã‚½ãƒƒãƒ‰ã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®åå‰ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3168
msgid ""
"The following attributes are only supported by :term:`new-style class`\\ es."
msgstr "ä»¥ä¸‹ã®å±æ€§ã¯ã€æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ (:term:`new-style class`) ã§ã®ã¿ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3172
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr "ã“ã®å±æ€§ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã®è§£æ±ºæ™‚ã«åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’æ¢ç´¢ã™ã‚‹ã¨ãã«è€ƒæ…®ã•ã‚Œã‚‹ã‚¯ãƒ©ã‚¹ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3178
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã«ã‚ˆã£ã¦ã€ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰è§£æ±ºã®é †åºã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ãŸã‚ã«ã€ä¸Šæ›¸ãã•ã‚Œã‚‹ã‹ã‚‚çŸ¥ã‚Œã¾ã›ã‚“ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–æ™‚ã«å‘¼ã°ã‚Œã€ãã®çµæœã¯ :attr:`~class.__mro__` ã«æ ¼ç´ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3185
msgid ""
"Each new-style class keeps a list of weak references to its immediate "
"subclasses.  This method returns a list of all those references still alive."
" Example::"
msgstr "ãã‚Œãã‚Œã®æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã¯ã€ãã‚Œè‡ªèº«ã®ç›´æ¥ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã¸ã®å¼±å‚ç…§ã‚’ä¿æŒã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãã‚Œã‚‰ã®å‚ç…§ã®ã†ã¡ã€ç”Ÿå­˜ã—ã¦ã„ã‚‹ã‚‚ã®ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ä¾‹::"

#: ../../library/stdtypes.rst:3194
msgid "Footnotes"
msgstr "æ³¨è¨˜"

#: ../../library/stdtypes.rst:3195
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr "ã“ã‚Œã‚‰ã®ç‰¹æ®Šãªãƒ¡ã‚½ãƒƒãƒ‰ã®ã•ã‚‰ãªã‚‹æƒ…å ±ã¯ã€ Python ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ« (:ref:`customization`) ã‚’å‚ç…§ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:3198
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``,"
" and similarly for tuples."
msgstr "ã“ã®çµæœã¨ã—ã¦ã€ãƒªã‚¹ãƒˆ ``[1, 2]`` ã¯ ``[1.0, 2.0]`` ã¨ç­‰ã—ã„ã¨è¦‹ãªã•ã‚Œã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã®å ´åˆã‚‚åŒæ§˜ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3201
msgid "They must have since the parser can't tell the type of the operands."
msgstr "ãƒ‘ãƒ¼ã‚¶ãŒæ¼”ç®—å¯¾è±¡ã®å‹ã‚’è­˜åˆ¥ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€ã“ã®ã‚ˆã†ãªå„ªå…ˆé †ä½ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3203
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr "å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­—ã¨ã¯ã€ä¸€èˆ¬ã‚«ãƒ†ã‚´ãƒªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒ \"Lu\" (Letter, uppercase (å¤§æ–‡å­—))ã€ \"Ll\" (Letter, lowercase (å°æ–‡å­—))ã€ \"Lt\" (Letterã€titlecase (å…ˆé ­ãŒå¤§æ–‡å­—)) ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹ã‚‚ã®ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3206
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr "å¾“ã£ã¦ã€ä¸€å€‹ã®ã‚¿ãƒ—ãƒ«ã ã‘ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå‡ºåŠ›ã—ãŸã„å ´åˆã«ã¯å‡ºåŠ›ã—ãŸã„ã‚¿ãƒ—ãƒ«ã‚’å”¯ä¸€ã®è¦ç´ ã¨ã™ã‚‹å˜ä¸€ã®ã‚¿ãƒ—ãƒ«ã‚’ *values* ã«ä¸ãˆãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:3209
msgid ""
"The advantage of leaving the newline on is that returning an empty string is"
" then an unambiguous EOF indication.  It is also possible (in cases where it"
" might matter, for example, if you want to make an exact copy of a file "
"while scanning its lines) to tell whether the last line of a file ended in a"
" newline or not (yes this happens!)."
msgstr "æ”¹è¡Œã‚’æ®‹ã™åˆ©ç‚¹ã¯ã€ç©ºã®æ–‡å­—åˆ—ãŒè¿”ã‚‹ã¨ EOF ã‚’ç¤ºã—ã€ç´›ã‚‰ã‚ã—ããªããªã‚‹ã‹ã‚‰ã§ã™ã€‚ã¾ãŸã€ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€å¾Œã®è¡ŒãŒæ”¹è¡Œã§çµ‚ã‚ã£ã¦ã„ã‚‹ã‹ãã†ã§ãªã„ (ã‚ã‚Šãˆã‚‹ã“ã¨ã§ã™!) ã‹ (ä¾‹ãˆã°ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¡Œå˜ä½ã§èª­ã¿ãªãŒã‚‰ãã®å®Œå…¨ãªã‚³ãƒ”ãƒ¼ã‚’ä½œæˆã—ãŸå ´åˆã«ã¯å•é¡Œã«ãªã‚Šã¾ã™) ã‚’èª¿ã¹ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"
