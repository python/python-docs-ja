# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-29 13:58+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "çµ„ã¿è¾¼ã¿å‹"

#: ../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr "ä»¥ä¸‹ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹æ¨™æº–å‹ã«ã¤ã„ã¦è¨˜è¿°ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr "ä¸»è¦ãªçµ„ã¿è¾¼ã¿å‹ã¯ã€æ•°å€¤ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã€ãƒãƒƒãƒ”ãƒ³ã‚°ã€ã‚¯ãƒ©ã‚¹ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€ãŠã‚ˆã³ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹ã«ã¯ã€ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ¡ãƒ³ãƒã‚’ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã«è¶³ã—ã€å¼•ãã€ã¾ãŸã¯ä¸¦ã¹æ›¿ãˆã¦ã€ç‰¹å®šã®è¦ç´ ã‚’è¿”ã•ãªã„ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³è‡ªèº«ã§ã¯ãªã"
" ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared, tested for truth value, and "
"converted to a string (with the :func:`repr` function or the slightly "
"different :func:`str` function).  The latter function is implicitly used "
"when an object is written by the :func:`print` function."
msgstr ""
"æ¼”ç®—ã«ã¯ã€è¤‡æ•°ã®å‹ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã™; ç‰¹ã«ã€ã»ã¼å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€æ¯”è¼ƒã§ãã€çœŸç†å€¤ã‚’åˆ¤å®šã§ãã€ (:func:`repr` "
"é–¢æ•°ã‚„ã€ã‚ãšã‹ã«ç•°ãªã‚‹ :func:`str` é–¢æ•°ã«ã‚ˆã£ã¦) æ–‡å­—åˆ—ã«å¤‰æ›ã§ãã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ :func:`print` "
"é–¢æ•°ã§å°å­—ã•ã‚Œã‚‹ã¨ãã€æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹é–¢æ•°ãŒæš—é»™ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "çœŸç†å€¤åˆ¤å®š"

#: ../../library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or "
":keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"ã©ã®ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚çœŸç†å€¤ã¨ã—ã¦åˆ¤å®šã§ãã€ :keyword:`if` ã‚„ :keyword:`while` "
"ã®æ¡ä»¶ã‚ã‚‹ã„ã¯ä»¥ä¸‹ã®ãƒ–ãƒ¼ãƒ«æ¼”ç®—ã®è¢«æ¼”ç®—å­ã¨ã—ã¦ä½¿ãˆã¾ã™ã€‚"

#: ../../library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a "
":meth:`__bool__` method that returns ``False`` or a :meth:`__len__` method "
"that returns zero, when called with the object. [1]_  Here are most of the "
"built-in objects considered false:"
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯çœŸã¨åˆ¤å®šã•ã‚Œã¾ã™ã€‚ãŸã ã—ãã®ã‚¯ãƒ©ã‚¹ãŒ :meth:`__bool__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã¦ã€ãã‚ŒãŒ ``False``"
" ã‚’è¿”ã™å ´åˆã€ã¾ãŸã¯ :meth:`__len__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã¦ã€ãã‚ŒãŒ 0 ã‚’è¿”ã™å ´åˆã¯å½ã¨åˆ¤å®šã•ã‚Œã¾ã™ã€‚ [1]_ "
"ä¸»ãªçµ„ã¿è¾¼ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§å½ã¨åˆ¤å®šã•ã‚Œã‚‹ã‚‚ã®ã‚’æ¬¡ã«ç¤ºã—ã¾ã™:"

#: ../../library/stdtypes.rst:55
msgid "constants defined to be false: ``None`` and ``False``."
msgstr "å½ã§ã‚ã‚‹ã¨å®šç¾©ã•ã‚Œã¦ã„ã‚‹å®šæ•°: ``None`` ã¨ ``False``"

#: ../../library/stdtypes.rst:57
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr "æ•°å€¤å‹ã«ãŠã‘ã‚‹ã‚¼ãƒ­: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, ``Fraction(0, 1)``"

#: ../../library/stdtypes.rst:60
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"ç©ºã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¾ãŸã¯ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³: ``''``, ``()``, ``[]``, ``{}``, ``set()``, ``range(0)``"

#: ../../library/stdtypes.rst:69
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"ãƒ–ãƒ¼ãƒ«å€¤ã®çµæœã‚’è¿”ã™æ¼”ç®—ãŠã‚ˆã³çµ„ã¿è¾¼ã¿é–¢æ•°ã¯ã€ç‰¹ã«æ³¨é‡ˆã®ãªã„é™ã‚Šå¸¸ã«å½å€¤ã¨ã—ã¦ ``0`` ã¾ãŸã¯ ``False`` ã‚’è¿”ã—ã€çœŸå€¤ã¨ã—ã¦ ``1`` "
"ã¾ãŸã¯ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ (é‡è¦ãªä¾‹å¤–: ãƒ–ãƒ¼ãƒ«æ¼”ç®— ``or`` ãŠã‚ˆã³ ``and`` ã¯å¸¸ã«è¢«æ¼”ç®—å­ã®ã†ã¡ã®ä¸€ã¤ã‚’è¿”ã—ã¾ã™ã€‚)"

#: ../../library/stdtypes.rst:78
msgid "Boolean Operations --- :keyword:`and`, :keyword:`or`, :keyword:`not`"
msgstr "ãƒ–ãƒ¼ãƒ«æ¼”ç®— --- :keyword:`and`, :keyword:`or`, :keyword:`not`"

#: ../../library/stdtypes.rst:82
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "ä»¥ä¸‹ã«ãƒ–ãƒ¼ãƒ«æ¼”ç®—ã‚’ã€å„ªå…ˆé †ä½ãŒä½ã„é †ã«ç¤ºã—ã¾ã™:"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:143
#: ../../library/stdtypes.rst:271 ../../library/stdtypes.rst:360
#: ../../library/stdtypes.rst:410 ../../library/stdtypes.rst:852
#: ../../library/stdtypes.rst:1047
msgid "Operation"
msgstr "æ¼”ç®—"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:271
#: ../../library/stdtypes.rst:360 ../../library/stdtypes.rst:410
#: ../../library/stdtypes.rst:852 ../../library/stdtypes.rst:1047
msgid "Result"
msgstr "çµæœ"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:271
#: ../../library/stdtypes.rst:410 ../../library/stdtypes.rst:852
#: ../../library/stdtypes.rst:1047 ../../library/stdtypes.rst:2174
#: ../../library/stdtypes.rst:3278
msgid "Notes"
msgstr "æ³¨é‡ˆ"

#: ../../library/stdtypes.rst:87
msgid "``x or y``"
msgstr "``x or y``"

#: ../../library/stdtypes.rst:87
msgid "if *x* is false, then *y*, else *x*"
msgstr "*x* ãŒå½ãªã‚‰ *y*, ãã†ã§ãªã‘ã‚Œã° *x*"

#: ../../library/stdtypes.rst:87 ../../library/stdtypes.rst:281
#: ../../library/stdtypes.rst:854 ../../library/stdtypes.rst:857
#: ../../library/stdtypes.rst:1058 ../../library/stdtypes.rst:2180
#: ../../library/stdtypes.rst:3284
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/stdtypes.rst:90
msgid "``x and y``"
msgstr "``x and y``"

#: ../../library/stdtypes.rst:90
msgid "if *x* is false, then *x*, else *y*"
msgstr "*x* ãŒå½ãªã‚‰ *x*, ãã†ã§ãªã‘ã‚Œã° *y*"

#: ../../library/stdtypes.rst:90 ../../library/stdtypes.rst:284
#: ../../library/stdtypes.rst:304 ../../library/stdtypes.rst:1086
#: ../../library/stdtypes.rst:2184 ../../library/stdtypes.rst:2186
#: ../../library/stdtypes.rst:3288 ../../library/stdtypes.rst:3290
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/stdtypes.rst:93
msgid "``not x``"
msgstr "``not x``"

#: ../../library/stdtypes.rst:93
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "*x* ãŒå½ãªã‚‰ ``True``, ãã†ã§ãªã‘ã‚Œã° ``False``"

#: ../../library/stdtypes.rst:93 ../../library/stdtypes.rst:866
#: ../../library/stdtypes.rst:1089 ../../library/stdtypes.rst:2188
#: ../../library/stdtypes.rst:2190 ../../library/stdtypes.rst:2192
#: ../../library/stdtypes.rst:2194 ../../library/stdtypes.rst:3292
#: ../../library/stdtypes.rst:3294 ../../library/stdtypes.rst:3296
#: ../../library/stdtypes.rst:3298
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/stdtypes.rst:102 ../../library/stdtypes.rst:315
#: ../../library/stdtypes.rst:428 ../../library/stdtypes.rst:893
#: ../../library/stdtypes.rst:1097 ../../library/stdtypes.rst:2220
#: ../../library/stdtypes.rst:3328
msgid "Notes:"
msgstr "æ³¨é‡ˆ:"

#: ../../library/stdtypes.rst:105
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr "ã“ã®æ¼”ç®—å­ã¯çŸ­çµ¡è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šç¬¬ä¸€å¼•æ•°ãŒå½ã®ã¨ãã«ã®ã¿ã€ç¬¬äºŒå¼•æ•°ãŒè©•ä¾¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:109
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr "ã“ã®æ¼”ç®—å­ã¯çŸ­çµ¡è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šç¬¬ä¸€å¼•æ•°ãŒçœŸã®ã¨ãã«ã®ã¿ã€ç¬¬äºŒå¼•æ•°ãŒè©•ä¾¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:113
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` ã¯éãƒ–ãƒ¼ãƒ«æ¼”ç®—å­ã‚ˆã‚Šã‚‚å„ªå…ˆåº¦ãŒä½ã„ã®ã§ã€ ``not a == b`` ã¯ ``not (a == b)`` ã¨è§£é‡ˆã•ã‚Œã€ ``a =="
" not b`` ã¯æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã§ã™ã€‚"

#: ../../library/stdtypes.rst:120
msgid "Comparisons"
msgstr "æ¯”è¼ƒ"

#: ../../library/stdtypes.rst:134
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons"
" can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to "
"``x < y and y <= z``, except that *y* is evaluated only once (but in both "
"cases *z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Python ã«ã¯ 8 ç¨®ã®æ¯”è¼ƒæ¼”ç®—ãŒã‚ã‚Šã¾ã™ã€‚æ¯”è¼ƒæ¼”ç®—ã®å„ªå…ˆé †ä½ã¯å…¨ã¦åŒã˜ã§ã™ (ãƒ–ãƒ¼ãƒ«æ¼”ç®—ã‚ˆã‚Šé«˜ã„å„ªå…ˆé †ä½ã§ã™)ã€‚æ¯”è¼ƒã¯ä»»æ„ã«é€£é–ã§ãã¾ã™; "
"ä¾‹ãˆã°ã€ ``x < y <= z`` ã¯ ``x < y and y <= z`` ã¨ã»ã¼ç­‰ä¾¡ã§ã™ãŒã€ã“ã® *y* ã¯ä¸€åº¦ã ã‘ã—ã‹è©•ä¾¡ã•ã‚Œã¾ã›ã‚“ "
"(ã©ã¡ã‚‰ã«ã—ã¦ã‚‚ã€ ``x < y`` ãŒå½ã¨ãªã‚Œã° *z* ã¯è©•ä¾¡ã•ã‚Œã¾ã›ã‚“)ã€‚"

#: ../../library/stdtypes.rst:140
msgid "This table summarizes the comparison operations:"
msgstr "ä»¥ä¸‹ã®è¡¨ã«æ¯”è¼ƒæ¼”ç®—ã‚’ã¾ã¨ã‚ã¾ã™:"

#: ../../library/stdtypes.rst:143 ../../library/stdtypes.rst:2151
#: ../../library/stdtypes.rst:2174 ../../library/stdtypes.rst:3255
#: ../../library/stdtypes.rst:3278
msgid "Meaning"
msgstr "æ„å‘³"

#: ../../library/stdtypes.rst:145
msgid "``<``"
msgstr "``<``"

#: ../../library/stdtypes.rst:145
msgid "strictly less than"
msgstr "ã‚ˆã‚Šå°ã•ã„"

#: ../../library/stdtypes.rst:147
msgid "``<=``"
msgstr "``<=``"

#: ../../library/stdtypes.rst:147
msgid "less than or equal"
msgstr "ä»¥ä¸‹"

#: ../../library/stdtypes.rst:149
msgid "``>``"
msgstr "``>``"

#: ../../library/stdtypes.rst:149
msgid "strictly greater than"
msgstr "ã‚ˆã‚Šå¤§ãã„"

#: ../../library/stdtypes.rst:151
msgid "``>=``"
msgstr "``>=``"

#: ../../library/stdtypes.rst:151
msgid "greater than or equal"
msgstr "ä»¥ä¸Š"

#: ../../library/stdtypes.rst:153
msgid "``==``"
msgstr "``==``"

#: ../../library/stdtypes.rst:153
msgid "equal"
msgstr "ç­‰ã—ã„"

#: ../../library/stdtypes.rst:155
msgid "``!=``"
msgstr "``!=``"

#: ../../library/stdtypes.rst:155
msgid "not equal"
msgstr "ç­‰ã—ããªã„"

#: ../../library/stdtypes.rst:157
msgid "``is``"
msgstr "``is``"

#: ../../library/stdtypes.rst:157
msgid "object identity"
msgstr "åŒä¸€ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹"

#: ../../library/stdtypes.rst:159
msgid "``is not``"
msgstr "``is not``"

#: ../../library/stdtypes.rst:159
msgid "negated object identity"
msgstr "åŒä¸€ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã„"

#: ../../library/stdtypes.rst:166
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. Furthermore, some types (for example, function objects) support only "
"a degenerate notion of comparison where any two objects of that type are "
"unequal.  The ``<``, ``<=``, ``>`` and ``>=`` operators will raise a "
":exc:`TypeError` exception when comparing a complex number with another "
"built-in numeric type, when the objects are of different types that cannot "
"be compared, or in other cases where there is no defined ordering."
msgstr ""
"ç•°ãªã‚‹å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ç•°ãªã‚‹æ•°å€¤å‹ã‚’é™¤ãã€æ±ºã—ã¦ç­‰ä¾¡ã«ãªã‚Šã¾ã›ã‚“ã€‚ã•ã‚‰ã«ã€å‹ã«ã¯ã€ (ä¾‹ãˆã°é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚ˆã†ã«) ãã®å‹ã®ã©ã® 2 "
"ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ç­‰ã—ããªã„ã¨ã„ã†ã€é€€åŒ–ã—ãŸæ¯”è¼ƒã®æ¦‚å¿µã—ã‹ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã‚‚ã®ã‚‚ã‚ã‚Šã¾ã™ã€‚è¤‡ç´ æ•°ã¨ãã®ä»–ã®çµ„ã¿è¾¼ã¿æ•°å€¤å‹ã‚’æ¯”è¼ƒã™ã‚‹ã¨ãã‚„ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåŒå£«ãŒç•°ãªã‚‹å‹ã§æ¯”è¼ƒã§ããªã„ã¨ãã‚„ã€ãã®ä»–é †åºã¥ã‘ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„ã¨ãã€æ¼”ç®—å­"
" ``<`` ã€ ``<=`` ã€ ``>`` ã€ ``>=`` ã¯ :exc:`TypeError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:182
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`__eq__` method."
msgstr ""
"ã‚ã‚‹ã‚¯ãƒ©ã‚¹ã®åŒä¸€ã§ãªã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€é€šå¸¸ç­‰ä¾¡ã§ãªã„ã¨ã•ã‚Œã¾ã™ãŒã€ãã®ã‚¯ãƒ©ã‚¹ãŒ :meth:`__eq__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã‚‹å ´åˆã¯é™¤ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:185
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of"
" the methods :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, and "
":meth:`__ge__` (in general, :meth:`__lt__` and :meth:`__eq__` are "
"sufficient, if you want the conventional meanings of the comparison "
"operators)."
msgstr ""
"ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ãã®ã‚¯ãƒ©ã‚¹ãŒãƒ¡ã‚½ãƒƒãƒ‰ :meth:`__lt__` ã€ :meth:`__le__` ã€ :meth:`__gt__` ã€ "
":meth:`__ge__` ã®ã†ã¡ååˆ†ãªã‚‚ã®ã‚’å®šç¾©ã—ã¦ã„ãªã„é™ã‚Šã€åŒã˜ã‚¯ãƒ©ã‚¹ã®åˆ¥ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚„ä»–ã®å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¯é †åºä»˜ã‘ã§ãã¾ã›ã‚“ "
"(ä¸€èˆ¬ã«ã€æ¯”è¼ƒæ¼”ç®—å­ã®é€šå¸¸ã®æ„å‘³ã‚’æ±‚ã‚ã‚‹ãªã‚‰ã€ :meth:`__lt__` ã¨ :meth:`__eq__` ã ã‘ã§ååˆ†ã§ã™)ã€‚"

#: ../../library/stdtypes.rst:191
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
":keyword:`is` ãŠã‚ˆã³ :keyword:`is not` æ¼”ç®—å­ã®æŒ¯ã‚‹èˆã„ã¯ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã›ã‚“ã€‚ã¾ãŸã€ã“ã‚Œã‚‰ã¯ã„ã‹ãªã‚‹ 2 "
"ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚‚é©ç”¨ã§ãã€æ±ºã—ã¦ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:199
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and "
":keyword:`not in`, are supported only by sequence types (below)."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ (ä»¥ä¸‹ã‚’å‚ç…§) ã§ã®ã¿ã€æ§‹æ–‡ä¸ŠåŒã˜å„ªå…ˆé †ä½ã‚’æŒã¤ã•ã‚‰ã« 2 ã¤ã®æ¼”ç®—å­ :keyword:`in` ãŠã‚ˆã³ :keyword:`not "
"in` ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:206
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "æ•°å€¤å‹ :class:`int`, :class:`float`, :class:`complex`"

#: ../../library/stdtypes.rst:216
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:type:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in "
":data:`sys.float_info`.  Complex numbers have a real and imaginary part, "
"which are each a floating point number.  To extract these parts from a "
"complex number *z*, use ``z.real`` and ``z.imag``. (The standard library "
"includes additional numeric types, :mod:`fractions` that hold rationals, and"
" :mod:`decimal` that hold floating-point numbers with user-definable "
"precision.)"
msgstr ""
"æ•°å€¤å‹ã«ã¯ 3 ç¨®é¡ã‚ã‚Šã¾ã™: :dfn:`æ•´æ•°` ã€ :dfn:`æµ®å‹•å°æ•°ç‚¹æ•°` ã€ :dfn:`è¤‡ç´ æ•°` "
"ã§ã™ã€‚ã•ã‚‰ã«ã€ãƒ–ãƒ¼ãƒ«å‹ã¯æ•´æ•°ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ã™ã€‚æ•´æ•°ã«ã¯ç²¾åº¦ã®åˆ¶é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚æµ®å‹•å°æ•°ç‚¹å‹ã¯ãŸã„ã¦ã„ã¯ C ã® :c:type:`double` "
"ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™; ã‚ãªãŸã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå‹•ä½œã™ã‚‹ãƒã‚·ãƒ³ã§ã®æµ®å‹•å°æ•°ç‚¹å‹ã®ç²¾åº¦ã¨å†…éƒ¨è¡¨ç¾ã¯ã€ :data:`sys.float_info` "
"ã‹ã‚‰åˆ©ç”¨ã§ãã¾ã™ã€‚è¤‡ç´ æ•°ã¯å®Ÿéƒ¨ã¨è™šéƒ¨ã‚’æŒã¡ã€ãã‚Œãã‚Œæµ®å‹•å°æ•°ç‚¹æ•°ã§ã™ã€‚è¤‡ç´ æ•° *z* ã‹ã‚‰å®Ÿéƒ¨ãŠã‚ˆã³è™šéƒ¨ã‚’å–ã‚Šå‡ºã™ã«ã¯ã€ ``z.real`` ãŠã‚ˆã³ "
"``z.imag`` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ (æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã¯ã€ãã®ä»–ã®æ•°å€¤å‹ã€åˆ†æ•°ã‚’ä¿æŒã™ã‚‹ :mod:`fractions` "
"ã‚„ã€ãƒ¦ãƒ¼ã‚¶å®šç¾©ã®ç²¾åº¦ã®æµ®å‹•å°æ•°ç‚¹æ•°ã‚’ä¿æŒã™ã‚‹ :mod:`decimal` ãŒã‚ã‚Šã¾ã™ã€‚)"

#: ../../library/stdtypes.rst:238
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number"
" with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"æ•°å€¤ã¯ã€æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã«ã‚ˆã£ã¦ã€ã‚ã‚‹ã„ã¯çµ„ã¿è¾¼ã¿é–¢æ•°ã‚„æ¼”ç®—å­ã®æˆ»ã‚Šå€¤ã¨ã—ã¦ç”Ÿæˆã•ã‚Œã¾ã™ã€‚ (åå…­é€²ã€å…«é€²ã€äºŒé€²æ•°ã‚’å«ã‚€) "
"ä¿®é£¾ã®ãªã„æ•´æ•°ãƒªãƒ†ãƒ©ãƒ«ã¯ã€æ•´æ•°ã‚’ä¸ãˆã¾ã™ã€‚å°æ•°ç‚¹ã¾ãŸã¯æŒ‡æ•°è¡¨è¨˜ã‚’å«ã‚€æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã¯æµ®å‹•å°æ•°ç‚¹æ•°ã‚’ä¸ãˆã¾ã™ã€‚æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã« ``'j'`` ã¾ãŸã¯ "
"``'J'`` ã‚’ã¤ã‘ã‚‹ã¨è™šæ•° (å®Ÿéƒ¨ãŒã‚¼ãƒ­ã®è¤‡ç´ æ•°) ã‚’ä¸ãˆã€ãã‚Œã«æ•´æ•°ã‚„æµ®å‹•å°æ•°ç‚¹æ•°ã‚’åŠ ãˆã¦å®Ÿéƒ¨ã¨è™šéƒ¨ã‚’æŒã¤è¤‡ç´ æ•°ã‚’å¾—ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:259
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex.  Comparisons between numbers"
" of mixed type use the same rule. [2]_ The constructors :func:`int`, "
":func:`float`, and :func:`complex` can be used to produce numbers of a "
"specific type."
msgstr ""
"Python ã¯å‹æ··åˆã®ç®—è¡“æ¼”ç®—ã«å®Œå…¨ã«å¯¾å¿œã—ã¦ã„ã¾ã™: ã‚ã‚‹äºŒé …ç®—è¡“æ¼”ç®—å­ã®è¢«æ¼”ç®—å­ã®æ•°å€¤å‹ãŒäº’ã„ã«ç•°ãªã‚‹ã¨ãã€ã‚ˆã‚Š \"åˆ¶é™ã•ã‚ŒãŸ\" "
"å‹ã®è¢«æ¼”ç®—å­ã¯ä»–æ–¹ã®å‹ã«åˆã‚ã›ã¦åºƒã’ã‚‰ã‚Œã¾ã™ã€‚ã“ã“ã§æ•´æ•°ã¯æµ®å‹•å°æ•°ç‚¹æ•°ã‚ˆã‚Šåˆ¶é™ã•ã‚Œã¦ãŠã‚Šã€æµ®å‹•å°æ•°ç‚¹æ•°ã¯è¤‡ç´ æ•°ã‚ˆã‚Šåˆ¶é™ã•ã‚Œã¦ã„ã¾ã™ã€‚å‹æ··åˆã®æ•°å€¤é–“ã§ã®æ¯”è¼ƒã‚‚åŒã˜è¦å‰‡ã«å¾“ã„ã¾ã™ã€‚"
" [2]_ ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ :func:`int` ã€ :func:`float` ã€ :func:`complex` ã§ã€ç‰¹å®šã®å‹ã®æ•°ã‚’ç”Ÿæˆã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:266
msgid ""
"All numeric types (except complex) support the following operations, sorted "
"by ascending priority (all numeric operations have a higher priority than "
"comparison operations):"
msgstr ""
"å…¨ã¦ã® (è¤‡ç´ æ•°ã‚’é™¤ã) çµ„ã¿è¾¼ã¿æ•°å€¤å‹ã¯ä»¥ä¸‹ã®æ¼”ç®—ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã¯å„ªå…ˆé †ä½ãŒä½ã„é †ã§ä¸¦ã‚“ã§ã„ã¾ã™ "
"(å…¨ã¦ã®æ•°å€¤æ¼”ç®—ã¯æ¯”è¼ƒæ¼”ç®—ã‚ˆã‚Šã‚‚é«˜ã„å„ªå…ˆé †ä½ã§ã™):"

#: ../../library/stdtypes.rst:271
msgid "Full documentation"
msgstr "å®Œå…¨ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ"

#: ../../library/stdtypes.rst:273
msgid "``x + y``"
msgstr "``x + y``"

#: ../../library/stdtypes.rst:273
msgid "sum of *x* and *y*"
msgstr "*x* ã¨ *y* ã®å’Œ"

#: ../../library/stdtypes.rst:275
msgid "``x - y``"
msgstr "``x - y``"

#: ../../library/stdtypes.rst:275
msgid "difference of *x* and *y*"
msgstr "*x* ã¨ *y* ã®å·®"

#: ../../library/stdtypes.rst:277
msgid "``x * y``"
msgstr "``x * y``"

#: ../../library/stdtypes.rst:277
msgid "product of *x* and *y*"
msgstr "*x* ã¨ *y* ã®ç©"

#: ../../library/stdtypes.rst:279
msgid "``x / y``"
msgstr "``x / y``"

#: ../../library/stdtypes.rst:279
msgid "quotient of *x* and *y*"
msgstr "*x* ã¨ *y* ã®å•†"

#: ../../library/stdtypes.rst:281
msgid "``x // y``"
msgstr "``x // y``"

#: ../../library/stdtypes.rst:281
msgid "floored quotient of *x* and *y*"
msgstr "*x* ã¨ *y* ã®å•†ã‚’åˆ‡ã‚Šä¸‹ã’ãŸã‚‚ã®"

#: ../../library/stdtypes.rst:284
msgid "``x % y``"
msgstr "``x % y``"

#: ../../library/stdtypes.rst:284
msgid "remainder of ``x / y``"
msgstr "``x / y`` ã®å‰°ä½™"

#: ../../library/stdtypes.rst:286
msgid "``-x``"
msgstr "``-x``"

#: ../../library/stdtypes.rst:286
msgid "*x* negated"
msgstr "*x* ã®ç¬¦å·åè»¢"

#: ../../library/stdtypes.rst:288
msgid "``+x``"
msgstr "``+x``"

#: ../../library/stdtypes.rst:288
msgid "*x* unchanged"
msgstr "*x* ãã®ã¾ã¾"

#: ../../library/stdtypes.rst:290
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../library/stdtypes.rst:290
msgid "absolute value or magnitude of *x*"
msgstr "*x* ã®çµ¶å¯¾å€¤ã¾ãŸã¯å¤§ãã•"

#: ../../library/stdtypes.rst:290
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/stdtypes.rst:293
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../library/stdtypes.rst:293
msgid "*x* converted to integer"
msgstr "*x* ã®æ•´æ•°ã¸ã®å¤‰æ›"

#: ../../library/stdtypes.rst:293
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../../library/stdtypes.rst:293
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/stdtypes.rst:295
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../library/stdtypes.rst:295
msgid "*x* converted to floating point"
msgstr "*x* ã®æµ®å‹•å°æ•°ç‚¹æ•°ã¸ã®å¤‰æ›"

#: ../../library/stdtypes.rst:295
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../../library/stdtypes.rst:295
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/stdtypes.rst:297
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../../library/stdtypes.rst:297
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr "å®Ÿéƒ¨ *re*, è™šéƒ¨ *im* ã®è¤‡ç´ æ•°ã€‚ *im* ã®æ—¢å®šå€¤ã¯ã‚¼ãƒ­ã€‚"

#: ../../library/stdtypes.rst:297 ../../library/stdtypes.rst:1079
#: ../../library/stdtypes.rst:2182 ../../library/stdtypes.rst:3315
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/stdtypes.rst:297
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/stdtypes.rst:301
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../../library/stdtypes.rst:301
msgid "conjugate of the complex number *c*"
msgstr "è¤‡ç´ æ•° *c* ã®å…±å½¹è¤‡ç´ æ•°"

#: ../../library/stdtypes.rst:304
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../library/stdtypes.rst:304
msgid "the pair ``(x // y, x % y)``"
msgstr "``(x // y, x % y)`` ã‹ã‚‰ãªã‚‹ãƒšã‚¢"

#: ../../library/stdtypes.rst:304
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/stdtypes.rst:306
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../../library/stdtypes.rst:306 ../../library/stdtypes.rst:308
msgid "*x* to the power *y*"
msgstr "*x* ã® *y* ä¹—"

#: ../../library/stdtypes.rst:306 ../../library/stdtypes.rst:308
#: ../../library/stdtypes.rst:1068 ../../library/stdtypes.rst:1071
#: ../../library/stdtypes.rst:2207 ../../library/stdtypes.rst:2210
#: ../../library/stdtypes.rst:2213 ../../library/stdtypes.rst:3311
#: ../../library/stdtypes.rst:3318
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/stdtypes.rst:306
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/stdtypes.rst:308
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../../library/stdtypes.rst:318
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"æ•´æ•°ã®é™¤ç®—ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚çµæœã®å‹ã¯æ•´æ•°å‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ãŒã€çµæœã®å€¤ã¯æ•´æ•°ã§ã™ã€‚çµæœã¯å¸¸ã«è² ã®ç„¡é™å¤§ã®æ–¹å‘ã«ä¸¸ã‚ã‚‰ã‚Œã¾ã™: ``1//2`` ã¯ "
"``0`` ã€ ``(-1)//2`` ã¯ ``-1`` ã€ ``1//(-2)`` ã¯ ``-1`` ã€ãã—ã¦ ``(-1)//(-2)`` ã¯ "
"``0`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:324
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr "è¤‡ç´ æ•°å‹ã«ã¯ä½¿ãˆã¾ã›ã‚“ã€‚é©ç”¨å¯èƒ½ãªå ´åˆã«ã¯ä»£ã‚ã‚Šã« :func:`abs` ã§æµ®å‹•å°æ•°ç‚¹å‹ã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:336
msgid ""
"Conversion from floating point to integer may round or truncate as in C; see"
" functions :func:`math.floor` and :func:`math.ceil` for well-defined "
"conversions."
msgstr ""
"æµ®å‹•å°æ•°ç‚¹æ•°ã‹ã‚‰æ•´æ•°ã¸ã®å¤‰æ›ã¯Cè¨€èªã¨åŒæ§˜ã®æ–¹æ³•ã§ä¸¸ã‚ã€ã¾ãŸã¯åˆ‡ã‚Šæ¨ã¦ã‚‰ã‚Œã¾ã™; ã‚ˆã‚Šæ˜ç¢ºã«å®šç¾©ã•ã‚ŒãŸå¤‰æ›ã‚’è¡Œã†å ´åˆã¯ã€ "
":func:`math.floor` ã¨ :func:`math.ceil` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:341
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"æµ®å‹•å°æ•°ç‚¹æ•°ã¯ã€æ–‡å­—åˆ— \"nan\" ã¨ \"inf\" ã‚’ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ¥é ­è¾ \"+\" ã¾ãŸã¯ \"-\" ã¨å…±ã«ã€éæ•° (Not a "
"Number (NaN)) ã‚„æ­£ã€è² ã®ç„¡é™å¤§ã¨ã—ã¦å—ã‘ä»˜ã‘ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:345
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨€èªä¸€èˆ¬ã§ãã†ã§ã‚ã‚‹ã‚ˆã†ã«ã€ ``pow(0, 0)`` ãŠã‚ˆã³ ``0 ** 0`` ã‚’ ``1`` ã¨å®šç¾©ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:349
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"å—ã‘ä»˜ã‘ã‚‰ã‚Œã‚‹æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã¯æ•°å­— ``0`` ã‹ã‚‰ ``9`` ã¾ãŸã¯ç­‰ä¾¡ãª Unicode (``Nd`` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã¤ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ) "
"ã‚’å«ã¿ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:352
msgid ""
"See http://www.unicode.org/Public/9.0.0/ucd/extracted/DerivedNumericType.txt"
" for a complete list of code points with the ``Nd`` property."
msgstr ""
"``Nd`` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã¤ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å®Œå…¨ãªãƒªã‚¹ãƒˆã¯ "
"http://www.unicode.org/Public/9.0.0/ucd/extracted/DerivedNumericType.txt "
"ã‚’ã”è¦§ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:356
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"å…¨ã¦ã® :class:`numbers.Real` å‹ (:class:`int` ã€ :class:`float`) ã¯ä»¥ä¸‹ã®æ¼”ç®—ã‚‚å«ã¿ã¾ã™:"

#: ../../library/stdtypes.rst:362
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../../library/stdtypes.rst:362
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* ã‚’ :class:`~numbers.Integral` (æ•´æ•°) ã«åˆ‡ã‚Šæ¨ã¦ã¾ã™"

#: ../../library/stdtypes.rst:365
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../../library/stdtypes.rst:365
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr "*x* ã‚’ *n* æ¡ã«ä¸¸ã‚ã¾ã™ã€‚ä¸¸ã‚æ–¹ã¯å¶æ•°ä¸¸ã‚ã§ã™ã€‚ *n* ãŒçœç•¥ã•ã‚Œã‚Œã° 0 ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:369
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../../library/stdtypes.rst:369
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "*x* ä»¥ä¸‹ã®æœ€å¤§ã® :class:`~numbers.Integral` (æ•´æ•°) ã‚’è¿”ã—ã¾ã™"

#: ../../library/stdtypes.rst:372
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../../library/stdtypes.rst:372
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "*x* ä»¥ä¸Šã®æœ€å°ã® :class:`~numbers.Integral` (æ•´æ•°) ã‚’è¿”ã—ã¾ã™"

#: ../../library/stdtypes.rst:376
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr "ãã®ä»–ã®æ•°å€¤æ¼”ç®—ã¯ã€ :mod:`math` ã‚„ :mod:`cmath` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã”è¦§ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:385
msgid "Bitwise Operations on Integer Types"
msgstr "æ•´æ•°å‹ã«ãŠã‘ã‚‹ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—"

#: ../../library/stdtypes.rst:399
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""

#: ../../library/stdtypes.rst:403
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and"
" ``-``)."
msgstr ""
"äºŒé …ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—ã®å„ªå…ˆé †ä½ã¯å…¨ã¦ã€æ•°å€¤æ¼”ç®—ã‚ˆã‚Šã‚‚ä½ãã€æ¯”è¼ƒã‚ˆã‚Šã‚‚é«˜ããªã£ã¦ã„ã¾ã™; å˜é …æ¼”ç®— ``~`` ã®å„ªå…ˆé †ä½ã¯ä»–ã®å˜é …æ•°å€¤æ¼”ç®— (``+`` "
"ãŠã‚ˆã³ ``-``) ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/stdtypes.rst:407
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr "ä»¥ä¸‹ã®è¡¨ã§ã¯ã€ãƒ“ãƒƒãƒˆå˜ä½æ¼”ç®—ã‚’å„ªå…ˆé †ä½ãŒä½ã„é †ã«ä¸¦ã¹ã¦ã„ã¾ã™:"

#: ../../library/stdtypes.rst:412
msgid "``x | y``"
msgstr "``x | y``"

#: ../../library/stdtypes.rst:412
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "*x* ã¨ *y* ã®ãƒ“ãƒƒãƒˆå˜ä½ :dfn:`è«–ç†å’Œ`"

#: ../../library/stdtypes.rst:415
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../../library/stdtypes.rst:415
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "*x* ã¨ *y* ã®ãƒ“ãƒƒãƒˆå˜ä½ :dfn:`æ’ä»–çš„è«–ç†å’Œ`"

#: ../../library/stdtypes.rst:418
msgid "``x & y``"
msgstr "``x & y``"

#: ../../library/stdtypes.rst:418
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "*x* ã¨ *y* ã®ãƒ“ãƒƒãƒˆå˜ä½ :dfn:`è«–ç†ç©`"

#: ../../library/stdtypes.rst:421
msgid "``x << n``"
msgstr "``x << n``"

#: ../../library/stdtypes.rst:421
msgid "*x* shifted left by *n* bits"
msgstr "*x* ã® *n* ãƒ“ãƒƒãƒˆå·¦ã‚·ãƒ•ãƒˆ"

#: ../../library/stdtypes.rst:421
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:423
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../../library/stdtypes.rst:423
msgid "*x* shifted right by *n* bits"
msgstr "*x* ã® *n* ãƒ“ãƒƒãƒˆå³ã‚·ãƒ•ãƒˆ"

#: ../../library/stdtypes.rst:423
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../../library/stdtypes.rst:425
msgid "``~x``"
msgstr "``~x``"

#: ../../library/stdtypes.rst:425
msgid "the bits of *x* inverted"
msgstr "*x* ã®ãƒ“ãƒƒãƒˆåè»¢"

#: ../../library/stdtypes.rst:431
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be "
"raised."
msgstr "è² å€¤ã®ã‚·ãƒ•ãƒˆæ•°ã¯ä¸æ­£ã§ã‚ã‚Šã€ :exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:434
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)`` "
"without overflow check."
msgstr "*n* ãƒ“ãƒƒãƒˆã®å·¦ã‚·ãƒ•ãƒˆã¯ã€ ``pow(2, n)`` ã«ã‚ˆã‚‹ä¹—ç®—ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ãƒã‚§ãƒƒã‚¯ã‚’ã—ãªã„ã‚‚ã®ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/stdtypes.rst:438
msgid ""
"A right shift by *n* bits is equivalent to division by ``pow(2, n)`` without"
" overflow check."
msgstr "*n* ãƒ“ãƒƒãƒˆã®å³ã‚·ãƒ•ãƒˆã¯ã€ ``pow(2, n)`` ã«ã‚ˆã‚‹é™¤ç®—ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ãƒã‚§ãƒƒã‚¯ã‚’ã—ãªã„ã‚‚ã®ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/stdtypes.rst:442
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + "
"max(x.bit_length(), y.bit_length()`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""

#: ../../library/stdtypes.rst:449
msgid "Additional Methods on Integer Types"
msgstr "æ•´æ•°å‹ã«ãŠã‘ã‚‹è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../library/stdtypes.rst:451
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"æ•´æ•°å‹ã¯ :class:`numbers.Integral` æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ (:term:`abstract base class`) "
"ã‚’å®Ÿè£…ã—ã¾ã™ã€‚ã•ã‚‰ã«ã€è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã„ãã¤ã‹æä¾›ã—ã¾ã™:"

#: ../../library/stdtypes.rst:456
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr "æ•´æ•°ã‚’ã€ç¬¦å·ã¨å…ˆé ­ã® 0 ã¯é™¤ã„ã¦äºŒé€²æ³•ã§è¡¨ã™ãŸã‚ã«å¿…è¦ãªãƒ“ãƒƒãƒˆã®æ•°ã‚’è¿”ã—ã¾ã™::"

#: ../../library/stdtypes.rst:465
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then "
"``x.bit_length()`` returns ``0``."
msgstr ""
"æ­£ç¢ºã«ã¯ã€ ``x`` ãŒé 0 ãªã‚‰ã€ ``x.bit_length()`` ã¯ ``2**(k-1) <= abs(x) < 2**k`` "
"ã‚’æº€ãŸã™å”¯ä¸€ã®æ­£ã®æ•´æ•° ``k`` ã§ã™ã€‚åŒæ§˜ã«ã€ ``abs(x)`` ãŒååˆ†å°ã•ãã¦å¯¾æ•°ã‚’é©åˆ‡ã«ä¸¸ã‚ã‚‰ã‚Œã‚‹ã¨ãã€ ``k = 1 + "
"int(log(abs(x), 2))`` ã§ã™ã€‚ ``x`` ãŒ 0 ãªã‚‰ã€ ``x.bit_length()`` ã¯ ``0`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:471
msgid "Equivalent to::"
msgstr "æ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/stdtypes.rst:482
msgid "Return an array of bytes representing an integer."
msgstr "æ•´æ•°ã‚’è¡¨ã™ãƒã‚¤ãƒˆåˆ—ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:494
msgid ""
"The integer is represented using *length* bytes.  An :exc:`OverflowError` is"
" raised if the integer is not representable with the given number of bytes."
msgstr ""
"æ•´æ•°ã¯ *length* ãƒã‚¤ãƒˆã§è¡¨ã•ã‚Œã¾ã™ã€‚æ•´æ•°ãŒä¸ãˆã‚‰ã‚ŒãŸæ•°ã®ãƒã‚¤ãƒˆã§è¡¨ã›ãªã‘ã‚Œã°ã€ :exc:`OverflowError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:498 ../../library/stdtypes.rst:530
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer.  If *byteorder* is ``\"big\"``, the most significant byte is at the"
" beginning of the byte array.  If *byteorder* is ``\"little\"``, the most "
"significant byte is at the end of the byte array.  To request the native "
"byte order of the host system, use :data:`sys.byteorder` as the byte order "
"value."
msgstr ""
"*byteorder* å¼•æ•°ã¯ã€æ•´æ•°ã‚’è¡¨ã™ã®ã«ä½¿ã‚ã‚Œã‚‹ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ã‚’æ±ºå®šã—ã¾ã™ã€‚ *byteorder* ãŒ ``\"big\"`` "
"ãªã‚‰ã€æœ€ä¸Šä½ã®ãƒã‚¤ãƒˆãŒãƒã‚¤ãƒˆé…åˆ—ã®æœ€åˆã«æ¥ã¾ã™ã€‚ *byteorder* ãŒ ``\"little\"`` "
"ãªã‚‰ã€æœ€ä¸Šä½ã®ãƒã‚¤ãƒˆãŒãƒã‚¤ãƒˆé…åˆ—ã®æœ€å¾Œã«æ¥ã¾ã™ã€‚ãƒ›ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ ã«ãƒã‚¤ãƒ†ã‚£ãƒ–ã®ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ã‚’è¦æ±‚ã™ã‚‹ã«ã¯ã€ :data:`sys.byteorder` "
"ã‚’ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ã®å€¤ã¨ã—ã¦ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:505
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"*signed* å¼•æ•°ã¯ã€æ•´æ•°ã‚’è¡¨ã™ã®ã« 2 ã®è£œæ•°ã‚’ä½¿ã†ã‹ã©ã†ã‹ã‚’æ±ºå®šã—ã¾ã™ã€‚ *signed* ãŒ ``False`` "
"ã§ã€è² ã®æ•´æ•°ãŒä¸ãˆã‚‰ã‚ŒãŸãªã‚‰ã€ :exc:`OverflowError`  ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ *signed* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ ``False`` "
"ã§ã™ã€‚"

#: ../../library/stdtypes.rst:514
msgid "Return the integer represented by the given array of bytes."
msgstr "ä¸ãˆã‚‰ã‚ŒãŸãƒã‚¤ãƒˆåˆ—ã®æ•´æ•°è¡¨ç¾ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:527
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"å¼•æ•° *bytes* ã¯ :term:`bytes-like object` ã‹ã€ã¾ãŸã¯ bytes ã‚’ç”Ÿæˆã™ã‚‹ iterable "
"ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:537
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr "*signed* å¼•æ•°ã¯ã€æ•´æ•°ã‚’è¡¨ã™ã®ã« 2 ã®è£œæ•°ã‚’ä½¿ã†ã‹ã©ã†ã‹ã‚’æ±ºå®šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:544
msgid "Additional Methods on Float"
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã«å¯¾ã™ã‚‹è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../library/stdtypes.rst:546
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"æµ®å‹•å°æ•°ç‚¹æ•°å‹ã¯ã€ :class:`numbers.Real` æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ (:term:`abstract base class`) "
"ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚æµ®å‹•å°æ•°ç‚¹å‹ã¯ã¾ãŸã€ä»¥ä¸‹ã®è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:551
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float"
" and with a positive denominator.  Raises :exc:`OverflowError` on infinities"
" and a :exc:`ValueError` on NaNs."
msgstr ""
"æ¯”ãŒå…ƒã®æµ®å‹•å°æ•°ç‚¹æ•°ã¨ã¡ã‚‡ã†ã©åŒã˜ã§åˆ†æ¯ãŒæ­£ã§ã‚ã‚‹ã€ä¸€å¯¾ã®æ•´æ•°ã‚’è¿”ã—ã¾ã™ã€‚ç„¡é™å¤§ã«å¯¾ã—ã¦ã¯ :exc:`OverflowError` ã‚’ã€éæ•° "
"(NaN) ã«å¯¾ã—ã¦ã¯ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:558
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒæœ‰é™ã®æ•´æ•°å€¤ãªã‚‰ ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™::"

#: ../../library/stdtypes.rst:566
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"16 é€²è¡¨è¨˜ã®æ–‡å­—åˆ—ã¸ã€ã¾ãŸã¯ã€ 16 é€²è¡¨è¨˜ã‹ã‚‰ã®å¤‰æ›ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹äºŒã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚ Python "
"ã®æµ®å‹•å°æ•°ç‚¹æ•°ã¯å†…éƒ¨çš„ã«ã¯2é€²æ•°ã§ä¿æŒã•ã‚Œã‚‹ã®ã§ã€æµ®å‹•å°æ•°ç‚¹æ•°ã® *10é€²æ•°* ã¸ã¾ãŸã¯ *10é€²æ•°* "
"ã‹ã‚‰ã®å¤‰æ›ã«ã¯è‹¥å¹²ã®ä¸¸ã‚èª¤å·®ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã«å¯¾ã—ã€16 é€²è¡¨è¨˜ã§ã¯ã€æµ®å‹•å°æ•°ç‚¹æ•°ã‚’æ­£ç¢ºã«è¡¨ç¾ã§ãã¾ã™ã€‚ã“ã‚Œã¯ãƒ‡ãƒãƒƒã‚°ã®ã¨ãã‚„ã€æ•°å­¦çš„ãªç”¨é€” "
"(numerical work) ã«ä¾¿åˆ©ã§ã—ã‚‡ã†ã€‚"

#: ../../library/stdtypes.rst:577
msgid ""
"Return a representation of a floating-point number as a hexadecimal string."
"  For finite floating-point numbers, this representation will always include"
" a leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"æµ®å‹•å°æ•°ç‚¹æ•°ã® 16 é€²æ–‡å­—åˆ—è¡¨ç¾ã‚’è¿”ã—ã¾ã™ã€‚æœ‰é™ã®æµ®å‹•å°æ•°ç‚¹æ•°ã«å¯¾ã—ã€ã“ã®è¡¨ç¾ã¯å¸¸ã« ``0x`` ã§å§‹ã¾ã‚Š ``p`` ã¨æŒ‡æ•°ãŒç¶šãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:585
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"16 é€²æ–‡å­—åˆ—è¡¨ç¾ *s* ã§è¡¨ã•ã‚Œã‚‹ã€æµ®å‹•å°æ•°ç‚¹æ•°ã‚’è¿”ã™ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚æ–‡å­—åˆ— *s* ã¯ã€å‰ã‚„å¾Œã«ãƒ›ãƒ¯ã‚¤ãƒˆã‚¹ãƒšãƒ¼ã‚¹ã‚’å«ã‚“ã§ã„ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:590
msgid ""
"Note that :meth:`float.hex` is an instance method, while "
":meth:`float.fromhex` is a class method."
msgstr ""
":meth:`float.fromhex` ã¯ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ãŒã€ :meth:`float.hex` "
"ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/stdtypes.rst:593
msgid "A hexadecimal string takes the form::"
msgstr "16 é€²æ–‡å­—åˆ—è¡¨ç¾ã¯ä»¥ä¸‹ã®æ›¸å¼ã¨ãªã‚Šã¾ã™::"

#: ../../library/stdtypes.rst:597
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and"
" there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2"
" of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted"
" by :meth:`float.fromhex`."
msgstr ""
"``sign`` ã¯å¿…é ˆã§ã¯ãªãã€ ``+`` ã¨ ``-`` ã®ã©ã¡ã‚‰ã‹ã§ã™ã€‚ ``integer`` ã¨ ``fraction`` ã¯ 16 "
"é€²æ•°ã®æ–‡å­—åˆ—ã§ã€ ``exponent`` ã¯ 10 é€²æ•°ã§ç¬¦å·ã‚‚ã¤ã‘ã‚‰ã‚Œã¾ã™ã€‚å¤§æ–‡å­—ãƒ»å°æ–‡å­—ã¯åŒºåˆ¥ã•ã‚Œãšã€æœ€ä½ã§ã‚‚ 1 ã¤ã® 16 "
"é€²æ•°æ–‡å­—ã‚’æ•´æ•°éƒ¨ã‚‚ã—ãã¯å°æ•°éƒ¨ã«å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®åˆ¶é™ã¯ C99 è¦æ ¼ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ 6.4.4.2 ã§è¦å®šã•ã‚Œã¦ã„ã¦ã€ Java 1.5 "
"ä»¥é™ã§ã‚‚ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ç‰¹ã«ã€ :meth:`float.hex` ã®å‡ºåŠ›ã¯ C ã‚„ Java ã‚³ãƒ¼ãƒ‰ä¸­ã§ã€æµ®å‹•å°æ•°ç‚¹æ•°ã® 16 "
"é€²è¡¨è¨˜ã¨ã—ã¦å½¹ã«ç«‹ã¤ã§ã—ã‚‡ã†ã€‚ã¾ãŸã€ C ã® ``%a`` æ›¸å¼ã‚„ã€ Java ã® ``Double.toHexString`` ã§æ›¸ãã ã•ã‚ŒãŸæ–‡å­—åˆ—ã¯"
" :meth:`float.fromhex` ã§å—ã‘ä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:610
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"ãªãŠã€æŒ‡æ•°éƒ¨ã¯ 16 é€²æ•°ã§ã¯ãªã 10 é€²æ•°ã§æ›¸ã‹ã‚Œã€ä¿‚æ•°ã«æ›ã‘ã‚‰ã‚Œã‚‹ 2 ã®ç´¯ä¹—ã‚’ä¸ãˆã¾ã™ã€‚ä¾‹ãˆã°ã€16 é€²æ–‡å­—åˆ— ``0x3.a7p10`` "
"ã¯æµ®å‹•å°æ•°ç‚¹æ•° ``(3 + 10./16 + 7./16**2) * 2.0**10`` ã™ãªã‚ã¡ ``3740.0`` ã‚’è¡¨ã—ã¾ã™::"

#: ../../library/stdtypes.rst:620
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr "é€†å¤‰æ›ã‚’ ``3740.0`` ã«é©ç”¨ã™ã‚‹ã¨ã€åŒã˜æ•°ã‚’è¡¨ã™ç•°ãªã‚‹ 16 é€²æ–‡å­—åˆ—è¡¨ç¾ã‚’è¿”ã—ã¾ã™::"

#: ../../library/stdtypes.rst:630
msgid "Hashing of numeric types"
msgstr "æ•°å€¤å‹ã®ãƒãƒƒã‚·ãƒ¥åŒ–"

#: ../../library/stdtypes.rst:632
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement"
" that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`__hash__` "
"method documentation for more details).  For ease of implementation and "
"efficiency across a variety of numeric types (including :class:`int`, "
":class:`float`, :class:`decimal.Decimal` and :class:`fractions.Fraction`) "
"Python's hash for numeric types is based on a single mathematical function "
"that's defined for any rational number, and hence applies to all instances "
"of :class:`int` and :class:`fractions.Fraction`, and all finite instances of"
" :class:`float` and :class:`decimal.Decimal`.  Essentially, this function is"
" given by reduction modulo ``P`` for a fixed prime ``P``.  The value of "
"``P`` is made available to Python as the :attr:`modulus` attribute of "
":data:`sys.hash_info`."
msgstr ""
"æ•° ``x`` ã¨ ``y`` ã«å¯¾ã—ã¦ã€å‹ãŒç•°ãªã£ã¦ã„ãŸã¨ã—ã¦ã‚‚ã€ ``x == y`` ã§ã‚ã‚Œã°å¿…ãš ``hash(x) == hash(y)`` "
"ã§ã‚ã‚‹ã“ã¨ãŒè¦è«‹ã•ã‚Œã¾ã™ (è©³ç´°ã¯ :meth:`__hash__`  ãƒ¡ã‚½ãƒƒãƒ‰ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚å®Ÿè£…ã®ç°¡å˜ã•ã¨ è¤‡æ•°ã®æ•°å€¤å‹ "
"(:class:`int` ã€ :class:`float` ã€ :class:`decimal.Decimal` ã€ "
":class:`fractions.Fraction` ã‚’å«ã¿ã¾ã™) é–“ã®åŠ¹ç‡ã®ãŸã‚ã€Python ã® "
"æ•°å€¤å‹ã«å¯¾ã™ã‚‹ãƒãƒƒã‚·ãƒ¥å€¤ã¯ã‚ã‚‹å˜ä¸€ã®æ•°å­¦çš„é–¢æ•°ã«åŸºã¥ã„ã¦ã„ã¦ã€ ãã®é–¢æ•°ã¯ã™ã¹ã¦ã®æœ‰ç†æ•°ã«å¯¾ã—å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ :class:`int` ã¨ "
":class:`fractions.Fraction` ã®ã™ã¹ã¦ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã€ :class:`float` ã¨ "
":class:`decimal.Decimal` ã®ã™ã¹ã¦ã®æœ‰é™ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã« å¯¾ã—ã¦é©ç”¨ã•ã‚Œã¾ã™ã€‚æœ¬è³ªçš„ã«ã¯ã€ã“ã®é–¢æ•°ã¯å®šæ•°ã®ç´ æ•° ``P`` "
"ã«å¯¾ã—ã¦ ``P`` ã‚’æ³•ã¨ã™ã‚‹é‚„å…ƒã§ä¸ãˆã‚‰ã‚Œã¾ã™ã€‚ å€¤ ``P`` ã¯ã€ :data:`sys.hash_info` ã® "
":attr:`modulus` å±æ€§ã¨ã—ã¦ Python ã§åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:647
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"ç¾åœ¨ä½¿ã‚ã‚Œã¦ã„ã‚‹ç´ æ•°ã¯ã€32 bit C long ã®ãƒã‚·ãƒ³ã§ã¯ ``P = 2**31 - 1`` ã€ 64-bit C long ã®ãƒã‚·ãƒ³ã§ã¯ "
"``P = 2**61 - 1`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:650
msgid "Here are the rules in detail:"
msgstr "è©³ç´°ãªè¦å‰‡ã¯ã“ã†ã§ã™:"

#: ../../library/stdtypes.rst:652
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible"
" by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n,"
" P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"``x = m / n`` ãŒéè² ã®æœ‰ç†æ•°ã§ã€ ``n`` ãŒ ``P`` ã§å‰²ã‚Šåˆ‡ã‚Œãªã„ãªã‚‰ã€ ``invmod(n, P)`` ã‚’ ``n`` ã‚’ "
"``P`` ã§å‰²ã£ãŸå‰°ä½™ã® (å‰°ä½™æ¼”ç®—ã®æ„å‘³ã§ã®) é€†æ•°ã‚’ä¸ãˆã‚‹ã‚‚ã®ã¨ã—ã¦ã€ ``hash(x)`` ã‚’ ``m * invmod(n, P) % "
"P`` ã¨å®šç¾©ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:656
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule"
" above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"``x = m / n`` ãŒéè² ã®æœ‰ç†æ•°ã§ã€ ``n`` ãŒ ``P`` ã§å‰²ã‚Šåˆ‡ã‚Œã‚‹ (ãŒ ``m`` ã¯å‰²ã‚Šåˆ‡ã‚Œãªã„) ãªã‚‰ã€ ``n`` ã¯ "
"``P`` ã§å‰²ã£ãŸä½™ã‚Šã®é€†æ•°ã‚’æŒãŸãšã€ä¸Šã®è¦å‰‡ã¯é©ç”¨ã§ãã¾ã›ã‚“ã€‚ã“ã®å ´åˆã€ ``hash(x)`` ã‚’å®šæ•° ``sys.hash_info.inf``"
" ã¨å®šç¾©ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:661
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as "
"``-hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"``x = m / n`` ãŒè² ã®æœ‰ç†æ•°ãªã‚‰ã€ ``hash(x)`` ã‚’ ``-hash(-x)`` ã¨å®šç¾©ã—ã¾ã™ã€‚ãã®çµæœã®ãƒãƒƒã‚·ãƒ¥ãŒ ``-1``"
" ãªã‚‰ã€ ``-2`` ã«ç½®ãæ›ãˆã¾ã™ã€‚"

#: ../../library/stdtypes.rst:665
msgid ""
"The particular values ``sys.hash_info.inf``, ``-sys.hash_info.inf`` and "
"``sys.hash_info.nan`` are used as hash values for positive infinity, "
"negative infinity, or nans (respectively).  (All hashable nans have the same"
" hash value.)"
msgstr ""
"ç‰¹å®šã®å€¤ ``sys.hash_info.inf`` ã€ ``-sys.hash_info.inf`` ã€ ``sys.hash_info.nan`` "
"ã¯ã€æ­£ã®ç„¡é™å¤§ã€è² ã®ç„¡é™å¤§ã€nan ã‚’ (ãã‚Œãã‚Œ) è¡¨ã™ã®ã«ä½¿ã‚ã‚Œã¾ã™ã€‚(ã™ã¹ã¦ã®ãƒãƒƒã‚·ãƒ¥å¯èƒ½ãª nan ã¯åŒã˜ãƒãƒƒã‚·ãƒ¥å€¤ã‚’æŒã¡ã¾ã™ã€‚)"

#: ../../library/stdtypes.rst:670
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + "
"sys.hash_info.imag * hash(z.imag)``, reduced modulo "
"``2**sys.hash_info.width`` so that it lies in "
"``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))``.  "
"Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"è¤‡ç´  (:class:`complex`) æ•° ``z`` ã«å¯¾ã—ã¦ã€å®Ÿéƒ¨ã¨è™šéƒ¨ã®ãƒãƒƒã‚·ãƒ¥å€¤ã¯ã€ ``hash(z.real) + "
"sys.hash_info.imag * hash(z.imag)`` ã® ``2**sys.hash_info.width`` "
"ã‚’æ³•ã¨ã™ã‚‹é‚„å…ƒã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šçµ„ã¿åˆã‚ã›ã‚‰ã‚Œã€ã‚ˆã£ã¦ã“ã‚Œã¯ ``range(-2**(sys.hash_info.width - 1), "
"2**(sys.hash_info.width - 1))`` ã«åã¾ã‚Šã¾ã™ã€‚å†ã³ã€çµæœãŒ ``-1`` ãªã‚‰ã€ ``-2`` ã§ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:678
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, "
":class:`float`, or :class:`complex`::"
msgstr ""
"ä¸Šè¿°ã®è¦å‰‡ã‚’ã‚ã‹ã‚Šã‚„ã™ãã™ã‚‹ãŸã‚ã€æœ‰ç†æ•° :class:`float` ã‚„ã€ :class:`complex` "
"ã®ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—ã™ã‚‹çµ„ã¿è¾¼ã¿ã®ãƒãƒƒã‚·ãƒ¥ã¨ç­‰ä¾¡ãª Python ã‚³ãƒ¼ãƒ‰ã®ä¾‹ã‚’æŒ™ã’ã¾ã™::"

#: ../../library/stdtypes.rst:733
msgid "Iterator Types"
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿å‹"

#: ../../library/stdtypes.rst:741
msgid ""
"Python supports a concept of iteration over containers.  This is implemented"
" using two distinct methods; these are used to allow user-defined classes to"
" support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python ã¯ã‚³ãƒ³ãƒ†ãƒŠã§ã®åå¾©å‡¦ç†ã®æ¦‚å¿µã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã“ã®æ¦‚å¿µã¯ 2 ã¤ã®åˆ¥ã€…ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™; "
"ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ãƒ¦ãƒ¼ã‚¶å®šç¾©ã®ã‚¯ãƒ©ã‚¹ã§åå¾©ã‚’è¡Œãˆã‚‹ã‚ˆã†ã«ã§ãã¾ã™ã€‚å¾Œã«è©³ã—ãè¿°ã¹ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€å¿…ãšåå¾©å‡¦ç†ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:746
msgid ""
"One method needs to be defined for container objects to provide iteration "
"support:"
msgstr "ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åå¾©å‡¦ç†ã‚’ã‚µãƒãƒ¼ãƒˆã•ã›ã‚‹ãŸã‚ã«ã¯ã€ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“:"

#: ../../library/stdtypes.rst:753
msgid ""
"Return an iterator object.  The object is required to support the iterator "
"protocol described below.  If a container supports different types of "
"iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the "
":c:member:`~PyTypeObject.tp_iter` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¾Œè¿°ã™ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã‚‚ã—ã‚³ãƒ³ãƒ†ãƒŠãŒç•°ãªã‚‹å‹ã®åå¾©å‡¦ç†ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãªã‚‰ã€ãã‚Œã‚‰ã®åå¾©å‡¦ç†æ¯ã«è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“"
" (è¤‡æ•°ã®å½¢å¼ã®åå¾©å‡¦ç†ã‚’æä¾›ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¾‹ã¨ã—ã¦ã€å¹…å„ªå…ˆæ¢ç´¢ã¨æ·±ã•å„ªå…ˆæ¢ç´¢ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹æœ¨æ§‹é€ ãŒæŒ™ã’ã‚‰ã‚Œã¾ã™)ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ Python/C"
" API ã§ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹æ§‹é€ ä½“ã® :c:member:`~PyTypeObject.tp_iter` ã‚¹ãƒ­ãƒƒãƒˆã«å¯¾å¿œã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:762
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã¯ä»¥ä¸‹ã® 2 ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ 2 ã¤åˆã‚ã›ã¦ :dfn:`iterator "
"protocol`: (ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«) ã‚’æˆã—ã¾ã™:"

#: ../../library/stdtypes.rst:768
msgid ""
"Return the iterator object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and "
":keyword:`in` statements. This method corresponds to the "
":c:member:`~PyTypeObject.tp_iter` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚³ãƒ³ãƒ†ãƒŠã¨ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®ä¸¡æ–¹ã‚’ :keyword:`for` ãŠã‚ˆã³ :keyword:`in` "
"æ–‡ã§ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«å¿…è¦ã§ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ Python/C API ã«ãŠã„ã¦ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã™å‹æ§‹é€ ä½“ã® "
":c:member:`~PyTypeObject.tp_iter` ã‚¹ãƒ­ãƒƒãƒˆã«å¯¾å¿œã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:776
msgid ""
"Return the next item from the container.  If there are no further items, "
"raise the :exc:`StopIteration` exception.  This method corresponds to the "
":c:member:`~PyTypeObject.tp_iternext` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""
"ã‚³ãƒ³ãƒ†ãƒŠã®æ¬¡ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—ãã‚Œä»¥ä¸Šã‚¢ã‚¤ãƒ†ãƒ ãŒç„¡ã‘ã‚Œã° :exc:`StopIteration` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚ ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ "
"Python/C APIã§ã®Pythonã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹æ§‹é€ ä½“ã® :c:member:`~PyTypeObject.tp_iternext` "
"ã‚¹ãƒ­ãƒƒãƒˆã«å¯¾å¿œã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:781
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized forms."
"  The specific types are not important beyond their implementation of the "
"iterator protocol."
msgstr ""
"Python "
"ã§ã¯ã€ã„ãã¤ã‹ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®šç¾©ã—ã¦ã€ä¸€èˆ¬ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã€ç‰¹æ®Šãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã€è¾æ›¸å‹ã€ãã®ä»–ã®ç‰¹æ®Šãªå½¢å¼ã«æ¸¡ã£ã¦åå¾©ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ç‰¹æ®Šå‹ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®å®Ÿè£…ä»¥å¤–ã§ã¯é‡è¦ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:786
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises "
":exc:`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã® :meth:`~iterator.__next__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒä¸€æ—¦ :exc:`StopIteration` "
"ã‚’é€å‡ºã—ãŸãªã‚‰ã€ä»¥é™ã®å‘¼ã³å‡ºã—ã§ã‚‚ä¾‹å¤–ã‚’é€å‡ºã—ç¶šã‘ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ç‰¹æ€§ã«å¾“ã‚ãªã„å®Ÿè£…ã¯å£Šã‚Œã¦ã„ã‚‹ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:794
msgid "Generator Types"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å‹"

#: ../../library/stdtypes.rst:796
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and "
":meth:`~generator.__next__` methods. More information about generators can "
"be found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""
"Python ã«ãŠã‘ã‚‹ :term:`generator` (ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿) "
"ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®Ÿè£…ã™ã‚‹ä¾¿åˆ©ãªæ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`__iter__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚Œã°ã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :meth:`__iter__` ãŠã‚ˆã³ "
":meth:`~generator.__next__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã™ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (å³å¯†ã«ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) "
"ã‚’è‡ªå‹•çš„ã«è¿”ã—ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã«é–¢ã™ã‚‹è©³ç´°ãªæƒ…å ±ã¯ã€ :ref:`yield å¼ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ <yieldexpr>` ã«ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:808
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ --- :class:`list`, :class:`tuple`, :class:`range`"

#: ../../library/stdtypes.rst:810
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"åŸºæœ¬çš„ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã¯ 3 ã¤ã‚ã‚Šã¾ã™: ãƒªã‚¹ãƒˆã€ã‚¿ãƒ—ãƒ«ã€range ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚:ref:`ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ <binaryseq>` ã‚„ "
":ref:`ãƒ†ã‚­ã‚¹ãƒˆæ–‡å­—åˆ— <textseq>` ã‚’å‡¦ç†ã™ã‚‹ã‚ˆã†ã«ä»•ç«‹ã¦ã‚‰ã‚ŒãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã¯ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‰²ã„ã¦è§£èª¬ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:819
msgid "Common Sequence Operations"
msgstr "å…±é€šã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹æ¼”ç®—"

#: ../../library/stdtypes.rst:823
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom"
" sequence types."
msgstr ""
"ä»¥ä¸‹ã®è¡¨ã«ã‚ã‚‹æ¼”ç®—ã¯ã€ã»ã¨ã‚“ã©ã®ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã€ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ä¸¡æ–¹ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚ã‚«ã‚¹ã‚¿ãƒ ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã«ã“ã‚Œã‚‰ã®æ¼”ç®—ã‚’å®Œå…¨ã«å®Ÿè£…ã™ã‚‹ã®ãŒç°¡å˜ã«ãªã‚‹ã‚ˆã†ã«ã€"
" :class:`collections.abc.Sequence` ABC ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:828
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k*"
" are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"ä»¥ä¸‹ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã§ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹æ¼”ç®—ã‚’å„ªå…ˆé †ä½ãŒä½ã„é †ã«æŒ™ã’ã¾ã™ã€‚è¡¨å†…ã§ã€ *s* ã¨ *t* ã¯åŒã˜å‹ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã€ *n*ã€ *i*ã€ *j* ã€ "
"*k* ã¯æ•´æ•°ã€*x* ã¯ *s* ã«èª²ã•ã‚ŒãŸå‹ã¨å€¤ã®æ¡ä»¶ã‚’æº€ãŸã™ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/stdtypes.rst:833
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"``in`` ãŠã‚ˆã³ ``not in`` æ¼”ç®—ã®å„ªå…ˆé †ä½ã¯æ¯”è¼ƒæ¼”ç®—ã¨åŒã˜ã§ã™ã€‚``+`` (çµåˆ) ãŠã‚ˆã³ ``*`` "
"(ç¹°ã‚Šè¿”ã—)ã®å„ªå…ˆé †ä½ã¯å¯¾å¿œã™ã‚‹æ•°å€¤æ¼”ç®—ã¨åŒã˜ã§ã™ã€‚ [3]_"

#: ../../library/stdtypes.rst:854
msgid "``x in s``"
msgstr "``x in s``"

#: ../../library/stdtypes.rst:854
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "*s* ã®ã‚ã‚‹è¦ç´ ãŒ *x* ã¨ç­‰ã—ã‘ã‚Œã° ``True`` , ãã†ã§ãªã‘ã‚Œã° ``False``"

#: ../../library/stdtypes.rst:857
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../../library/stdtypes.rst:857
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "*s* ã®ã‚ã‚‹è¦ç´ ãŒ *x* ã¨ç­‰ã—ã‘ã‚Œã° ``False``, ãã†ã§ãªã‘ã‚Œã° ``True``"

#: ../../library/stdtypes.rst:860
msgid "``s + t``"
msgstr "``s + t``"

#: ../../library/stdtypes.rst:860
msgid "the concatenation of *s* and *t*"
msgstr "*s* ã¨ *t* ã®çµåˆ"

#: ../../library/stdtypes.rst:860
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../../library/stdtypes.rst:863
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` ã¾ãŸã¯ ``n * s``"

#: ../../library/stdtypes.rst:863
msgid "equivalent to adding *s* to itself *n* times"
msgstr "*s* è‡ªèº«ã‚’ *n* å›è¶³ã™ã®ã¨åŒã˜"

#: ../../library/stdtypes.rst:863
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../../library/stdtypes.rst:866
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../library/stdtypes.rst:866
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*s* ã® 0 ã‹ã‚‰æ•°ãˆã¦ *i* ç•ªç›®ã®è¦ç´ "

#: ../../library/stdtypes.rst:868
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../../library/stdtypes.rst:868
msgid "slice of *s* from *i* to *j*"
msgstr "*s* ã® *i* ã‹ã‚‰ *j* ã¾ã§ã®ã‚¹ãƒ©ã‚¤ã‚¹"

#: ../../library/stdtypes.rst:868
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../../library/stdtypes.rst:870
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../../library/stdtypes.rst:870
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "*s* ã® *i* ã‹ã‚‰ *j* ã¾ã§ã€ *k* æ¯ã®ã‚¹ãƒ©ã‚¤ã‚¹"

#: ../../library/stdtypes.rst:870
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../../library/stdtypes.rst:873
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../library/stdtypes.rst:873
msgid "length of *s*"
msgstr "*s* ã®é•·ã•"

#: ../../library/stdtypes.rst:875
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../../library/stdtypes.rst:875
msgid "smallest item of *s*"
msgstr "*s* ã®æœ€å°ã®è¦ç´ "

#: ../../library/stdtypes.rst:877
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../library/stdtypes.rst:877
msgid "largest item of *s*"
msgstr "*s* ã®æœ€å¤§ã®è¦ç´ "

#: ../../library/stdtypes.rst:879
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../../library/stdtypes.rst:879
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr "*s* ä¸­ã§ *x* ãŒæœ€åˆã«å‡ºç¾ã™ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ (ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ *i* ä»¥é™ã‹ã‚‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ *j* ã¾ã§ã®ç¯„å›²)"

#: ../../library/stdtypes.rst:879 ../../library/stdtypes.rst:3286
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/stdtypes.rst:883
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../library/stdtypes.rst:883
msgid "total number of occurrences of *x* in *s*"
msgstr "*s* ä¸­ã« *x* ãŒå‡ºç¾ã™ã‚‹å›æ•°"

#: ../../library/stdtypes.rst:887
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal"
" and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"åŒã˜å‹ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯æ¯”è¼ƒã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ç‰¹ã«ã€ã‚¿ãƒ—ãƒ«ã¨ãƒªã‚¹ãƒˆã¯å¯¾å¿œã™ã‚‹è¦ç´ ã‚’æ¯”è¼ƒã™ã‚‹ã“ã¨ã§è¾æ›¸å¼é †åºã§æ¯”è¼ƒã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šã€ç­‰ã—ã„ã¨ã•ã‚Œã‚‹ãŸã‚ã«ã¯ã€ã™ã¹ã¦ã®è¦ç´ ãŒç­‰ã—ãã€ä¸¡ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å‹ã‚‚é•·ã•ã‚‚ç­‰ã—ããªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚(å®Œå…¨ãªè©³ç´°ã¯è¨€èªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã®"
" :ref:`comparisons` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚)"

#: ../../library/stdtypes.rst:896
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such as"
" :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"``in`` ãŠã‚ˆã³ ``not in`` æ¼”ç®—ã¯ã€ä¸€èˆ¬ã«å˜ç´”ãªåŒ…å«åˆ¤å®šã«ã®ã¿ä½¿ã‚ã‚Œã¾ã™ãŒã€(:class:`str`, :class:`bytes`,"
" :class:`bytearray` ã®ã‚ˆã†ãª) ç‰¹æ®Šãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã¯éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹åˆ¤å®šã«ã‚‚ä½¿ã‚ã‚Œã¾ã™::"

#: ../../library/stdtypes.rst:905
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"``0`` æœªæº€ã®å€¤ *n* ã¯ ``0`` ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ (ã“ã‚Œã¯ *s* ã¨åŒã˜å‹ã®ç©ºã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è¡¨ã—ã¾ã™)ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *s* "
"ã®è¦ç´ ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œãªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„; ã‚³ãƒ”ãƒ¼ã§ã¯ãªãè¦ç´ ã«å¯¾ã™ã‚‹å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒå¢—ãˆã¾ã™ã€‚ã“ã‚Œã¯ Python "
"ã«æ…£ã‚Œã¦ã„ãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒã‚’ã‚ˆãæ‚©ã¾ã›ã¾ã™ã€‚ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’è€ƒãˆã¾ã™:"

#: ../../library/stdtypes.rst:917
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty"
" list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single"
" list. You can create a list of different lists this way::"
msgstr ""
"ã“ã“ã§ã€``[[]]`` ãŒç©ºãƒªã‚¹ãƒˆã‚’å«ã‚€ 1 è¦ç´ ã®ãƒªã‚¹ãƒˆãªã®ã§ã€``[[]] * 3`` ã® 3 è¦ç´ ã¯ã“ã®ä¸€ã¤ã®ç©ºãƒªã‚¹ãƒˆ (ã¸ã®å‚ç…§) "
"ã§ã™ã€‚``lists`` ã®ã„ãšã‚Œã‹ã®è¦ç´ ã‚’å¤‰æ›´ã™ã‚‹ã¨ã€ãã®ä¸€ã¤ã®ãƒªã‚¹ãƒˆãŒå¤‰æ›´ã•ã‚Œã¾ã™ã€‚åˆ¥ã€…ã®ãƒªã‚¹ãƒˆã®ãƒªã‚¹ãƒˆã‚’ä½œã‚‹ã«ã¯ã“ã†ã—ã¾ã™::"

#: ../../library/stdtypes.rst:929
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-"
"multidimensional-list`."
msgstr "åˆ¥ã®èª¬æ˜ãŒ FAQ ã‚¨ãƒ³ãƒˆãƒª :ref:`faq-multidimensional-list` ã«ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:933
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*:"
" ``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"*i* ã¾ãŸã¯ *j* ãŒè² ã®æ•°ã®å ´åˆã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®æœ«ç«¯ã‹ã‚‰ã®ç›¸å¯¾ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ãªã‚Šã¾ã™: ``len(s) + i`` ã¾ãŸã¯ ``len(s) + j`` ãŒä»£ã‚ã‚Šã«ä½¿ã‚ã‚Œã¾ã™ã€‚\n"
"ãŸã ã— ``-0`` ã¯ã‚„ã¯ã‚Š ``0`` ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:938
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal"
" to *j*, the slice is empty."
msgstr ""
"*s* ã® *i* ã‹ã‚‰ *j* ã¸ã®ã‚¹ãƒ©ã‚¤ã‚¹ã¯ ``i <= k < j`` ã¨ãªã‚‹ã‚ˆã†ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ *k* "
"ã‚’æŒã¤è¦ç´ ã‹ã‚‰ãªã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦å®šç¾©ã•ã‚Œã¾ã™ã€‚ *i* ã¾ãŸã¯ *j* ãŒ ``len(s)`` ã‚ˆã‚Šã‚‚å¤§ãã„å ´åˆã€ ``len(s)`` "
"ã‚’ä½¿ã„ã¾ã™ã€‚ *i* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ ``None`` ã ã£ãŸå ´åˆã€ ``0`` ã‚’ä½¿ã„ã¾ã™ã€‚ *j* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ ``None`` ã ã£ãŸå ´åˆã€ "
"``len(s)`` ã‚’ä½¿ã„ã¾ã™ã€‚ *i* ãŒ *j* ä»¥ä¸Šã®å ´åˆã€ã‚¹ãƒ©ã‚¤ã‚¹ã¯ç©ºã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:945
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of"
" items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other"
" words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is"
" ``None``, it is treated like ``1``."
msgstr ""
"*s* ã®ã€Œ *i* ã‹ã‚‰ *j* ã¾ã§ã§ã‚¹ãƒ†ãƒƒãƒ—ãŒ *k* ã®ã‚¹ãƒ©ã‚¤ã‚¹ã€ã¯ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ ``x = i + n*k`` ï¼ˆãŸã ã— n ã¯ ``0 "
"<= n < (j-i)/k`` ã‚’æº€ãŸã™ä»»æ„ã®æ•´æ•°ï¼‰ã‚’æŒã¤è¦ç´ ã‹ã‚‰ãªã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦å®šç¾©ã•ã‚Œã¾ã™ã€‚è¨€ã„æ›ãˆã‚‹ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯ ``i``, "
"``i+k``, ``i+2*k``, ``i+3*k`` ã¨ç¶šãã€ *j* ã«é”ã—ãŸã¨ã“ã‚ã§ã‚¹ãƒˆãƒƒãƒ—ã—ã¾ã™ (ãŸã ã— *j* ã¯å«ã¿ã¾ã›ã‚“)ã€‚ *k*"
" ãŒæ­£ã®æ•°ã§ã‚ã‚‹å ´åˆã€ *i* ã¾ãŸã¯ *j* ãŒ ``len(s)`` ã‚ˆã‚Šå¤§ãã‘ã‚Œã° ``len(s)`` ã‚’ä»£ã‚ã‚Šã«ä½¿ç”¨ã—ã¾ã™ã€‚ *k* "
"ãŒè² ã®æ•°ã§ã‚ã‚‹å ´åˆã€ *i* ã¾ãŸã¯ *j* ãŒ ``len(s) - 1`` ã‚ˆã‚Šå¤§ãã‘ã‚Œã° ``len(s) - 1`` ã‚’ä»£ã‚ã‚Šã«ä½¿ç”¨ã—ã¾ã™ã€‚ "
"*i* ã¾ãŸã¯ *j* ã‚’çœç•¥ã¾ãŸã¯ ``None`` ã‚’æŒ‡å®šã™ã‚‹ã¨ã€ \"ç«¯\" (ã©ã¡ã‚‰ã®ç«¯ã‹ã¯ *k* ã®ç¬¦å·ã«ä¾å­˜) "
"ã®å€¤ã‚’ä»£ã‚ã‚Šã«ä½¿ç”¨ã—ã¾ã™ã€‚ãªãŠ *k* ã¯ã‚¼ãƒ­ã«ã§ããªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã¾ãŸ *k* ã« ``None`` ã‚’æŒ‡å®šã™ã‚‹ã¨ã€ ``1`` "
"ãŒæŒ‡å®šã•ã‚ŒãŸã‚‚ã®ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:956
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®çµåˆã¯ã€å¸¸ã«æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€çµåˆã®ç¹°ã‚Šè¿”ã—ã§ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’æ§‹ç¯‰ã™ã‚‹å®Ÿè¡Œæ™‚é–“ã‚³ã‚¹ãƒˆãŒã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ã®åˆè¨ˆã®äºŒæ¬¡å¼ã«ãªã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚å®Ÿè¡Œæ™‚é–“ã‚³ã‚¹ãƒˆã‚’ç·šå½¢ã«ã™ã‚‹ã«ã¯ã€ä»£ã‚ã‚Šã«ä»¥ä¸‹ã®ã„ãšã‚Œã‹ã«ã—ã¦ãã ã•ã„:"

#: ../../library/stdtypes.rst:961
msgid ""
"if concatenating :class:`str` objects, you can build a list and use "
":meth:`str.join` at the end or else write to an :class:`io.StringIO` "
"instance and retrieve its value when complete"
msgstr ""
":class:`str` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’çµåˆã™ã‚‹ã«ã¯ã€ãƒªã‚¹ãƒˆã‚’æ§‹ç¯‰ã—ã¦æœ€å¾Œã« :meth:`str.join` ã‚’ä½¿ã†ã‹ã€ "
":class:`io.StringIO` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«æ›¸ãè¾¼ã‚“ã§å®Œæˆã—ã¦ã‹ã‚‰å€¤ã‚’å–å¾—ã—ã¦ãã ã•ã„"

#: ../../library/stdtypes.rst:965
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use "
":meth:`bytes.join` or :class:`io.BytesIO`, or you can do in-place "
"concatenation with a :class:`bytearray` object.  :class:`bytearray` objects "
"are mutable and have an efficient overallocation mechanism"
msgstr ""
":class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’çµåˆã™ã‚‹ãªã‚‰ã€åŒæ§˜ã« :meth:`bytes.join` ã‚„ :class:`io.BytesIO` "
"ã‚’ä½¿ã†ã‹ã€ :class:`bytearray` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã«çµåˆã§ãã¾ã™ã€‚ :class:`bytearray` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã§ã€åŠ¹ç‡ã®ã„ã„å‰²ã‚Šå½“ã¦è¶…éæ©Ÿæ§‹ã‚’å‚™ãˆã¦ã„ã¾ã™"

#: ../../library/stdtypes.rst:970
msgid ""
"if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ":class:`tuple` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’çµåˆã™ã‚‹ãªã‚‰ã€ä»£ã‚ã‚Šã« :class:`list` ã‚’æ‹¡å¼µã—ã¦ãã ã•ã„"

#: ../../library/stdtypes.rst:972
msgid "for other types, investigate the relevant class documentation"
msgstr "ãã®ä»–ã®å‹ã«ã¤ã„ã¦ã¯ã€é–¢é€£ã™ã‚‹ã‚¯ãƒ©ã‚¹ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’èª¿ã¹ã¦ãã ã•ã„"

#: ../../library/stdtypes.rst:976
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã«ã¯ã€ (:class:`range` ã®ã‚ˆã†ã«) "
"ç‰¹æ®Šãªãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¾“ã†é …ç›®ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã¿ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚‚ã®ãŒã‚ã‚Šã€ãã‚Œã‚‰ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®çµåˆã‚„ç¹°ã‚Šè¿”ã—ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:981
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only"
" without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"``index`` ã¯ *x* ãŒ *s* ä¸­ã«è¦‹ã¤ã‹ã‚‰ãªã„ã¨ã :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚è¿½åŠ ã®å¼•æ•° *i* ã¨ *j* "
"ã¯ã€ã™ã¹ã¦ã®å®Ÿè£…ãŒã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è¿½åŠ ã®å¼•æ•°ã‚’æ¸¡ã™ã®ã¯ã€ãŠãŠã‚ˆã ``s[i:j].index(x)`` "
"ã‚’ä½¿ã†ã®ã¨ç­‰ä¾¡ã§ã™ãŒã€ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ã—ãªãã¦æ¸ˆã‚€ã—ã€è¿”ã•ã‚Œã‚‹ã®ã¯ã‚¹ãƒ©ã‚¤ã‚¹ã®æœ€åˆã§ã¯ãªãã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®æœ€åˆã‹ã‚‰ã®ç›¸å¯¾ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã§ã™ã€‚"

#: ../../library/stdtypes.rst:992
msgid "Immutable Sequence Types"
msgstr "ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹"

#: ../../library/stdtypes.rst:999
msgid ""
"The only operation that immutable sequence types generally implement that is"
" not also implemented by mutable sequence types is support for the "
":func:`hash` built-in."
msgstr ""
"ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ãŒä¸€èˆ¬ã«å®Ÿè£…ã—ã¦ã„ã‚‹æ¼”ç®—ã®ã†ã¡ã€ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ãŒã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã®ã¯ã€çµ„ã¿è¾¼ã¿ã® :func:`hash` "
"ã ã‘ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1003
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and "
":class:`frozenset` instances."
msgstr ""
"ã“ã®ã‚µãƒãƒ¼ãƒˆã«ã‚ˆã‚Šã€:class:`tuple` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚ˆã†ãªã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€ :class:`dict` ã®ã‚­ãƒ¼ã¨ã—ã¦ä½¿ãˆã€ "
":class:`set` ã‚„ :class:`frozenset` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ä¿å­˜ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1007
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr "ãƒãƒƒã‚·ãƒ¥ä¸å¯èƒ½ãªå€¤ã‚’å«ã‚€ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ :exc:`TypeError` ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1014
msgid "Mutable Sequence Types"
msgstr "ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹"

#: ../../library/stdtypes.rst:1021
msgid ""
"The operations in the following table are defined on mutable sequence types."
" The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"ä»¥ä¸‹ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã«ã‚ã‚‹æ¼”ç®—ã¯ã€ã»ã¨ã‚“ã©ã®ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚ã‚«ã‚¹ã‚¿ãƒ ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã«ã“ã‚Œã‚‰ã®æ¼”ç®—ã‚’å®Œå…¨ã«å®Ÿè£…ã™ã‚‹ã®ãŒç°¡å˜ã«ãªã‚‹ã‚ˆã†ã«ã€"
" :class:`collections.abc.MutableSequence` ABC ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1025
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value"
" restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"ã“ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã§ã€ *s* ã¯ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€ *t* ã¯ä»»æ„ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ *x* ã¯ *s* "
"ã«èª²ã•ã‚ŒãŸå‹ã¨å€¤ã®æ¡ä»¶ã‚’æº€ãŸã™ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ä¾‹ãˆã°ã€ :class:`bytearray` ã¯å€¤ã®åˆ¶é™ ``0 <= x <= 255`` "
"ã«åˆã†æ•´æ•°ã®ã¿ã‚’å—ã‘ä»˜ã‘ã¾ã™) ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1049
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../library/stdtypes.rst:1049
msgid "item *i* of *s* is replaced by *x*"
msgstr "*s* ã®è¦ç´  *i* ã‚’ *x* ã¨å…¥ã‚Œæ›¿ãˆã¾ã™"

#: ../../library/stdtypes.rst:1052
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../library/stdtypes.rst:1052
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr "*s* ã® *i* ã‹ã‚‰ *j* ç•ªç›®ã¾ã§ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ã‚¤ãƒ†ãƒ©ãƒ–ãƒ« *t* ã®å†…å®¹ã«å…¥ã‚Œæ›¿ãˆã¾ã™"

#: ../../library/stdtypes.rst:1056
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../library/stdtypes.rst:1056
msgid "same as ``s[i:j] = []``"
msgstr "``s[i:j] = []`` ã¨åŒã˜ã§ã™"

#: ../../library/stdtypes.rst:1058
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../library/stdtypes.rst:1058
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "``s[i:j:k]`` ã®è¦ç´ ã‚’ *t* ã®è¦ç´ ã¨å…¥ã‚Œæ›¿ãˆã¾ã™"

#: ../../library/stdtypes.rst:1061
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../library/stdtypes.rst:1061
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "ãƒªã‚¹ãƒˆã‹ã‚‰ ``s[i:j:k]`` ã®è¦ç´ ã‚’å‰Šé™¤ã—ã¾ã™"

#: ../../library/stdtypes.rst:1064
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../library/stdtypes.rst:1064
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr "*x* ã‚’ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®æœ€å¾Œã«åŠ ãˆã¾ã™ (``s[len(s):len(s)] = [x]`` ã¨åŒã˜)"

#: ../../library/stdtypes.rst:1068
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../../library/stdtypes.rst:1068
msgid "removes all items from ``s`` (same as ``del s[:]``)"
msgstr "``s`` ã‹ã‚‰å…¨ã¦ã®è¦ç´ ã‚’å–ã‚Šé™¤ãã¾ã™ (``del s[:]`` ã¨åŒã˜)"

#: ../../library/stdtypes.rst:1071
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../../library/stdtypes.rst:1071
msgid "creates a shallow copy of ``s`` (same as ``s[:]``)"
msgstr "``s`` ã®æµ…ã„ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆã—ã¾ã™ (``s[:]`` ã¨åŒã˜)"

#: ../../library/stdtypes.rst:1074
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` ã¾ãŸã¯ ``s += t``"

#: ../../library/stdtypes.rst:1074
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr "*s* ã‚’ *t* ã®å†…å®¹ã§æ‹¡å¼µã—ã¾ã™ (ã»ã¨ã‚“ã© ``s[len(s):len(s)] = t`` ã¨åŒã˜)"

#: ../../library/stdtypes.rst:1079
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../../library/stdtypes.rst:1079
msgid "updates *s* with its contents repeated *n* times"
msgstr "*s* ã‚’ãã®å†…å®¹ã‚’ *n* å›ç¹°ã‚Šè¿”ã—ãŸã‚‚ã®ã§æ›´æ–°"

#: ../../library/stdtypes.rst:1082
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../library/stdtypes.rst:1082
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr "*s* ã® *i* ã§ä¸ãˆã‚‰ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã« *x* ã‚’æŒ¿å…¥ã—ã¾ã™ã€‚ (``s[i:i] = [x]`` ã¨åŒã˜)"

#: ../../library/stdtypes.rst:1086
msgid "``s.pop([i])``"
msgstr "``s.pop([i])``"

#: ../../library/stdtypes.rst:1086
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "*s* ã‹ã‚‰ *i* ç•ªç›®ã®è¦ç´ ã‚’å–ã‚Šå‡ºã—ã€ã¾ãŸå–ã‚Šé™¤ãã¾ã™"

#: ../../library/stdtypes.rst:1089
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/stdtypes.rst:1089
msgid "remove the first item from *s* where ``s[i] == x``"
msgstr "*s* ã‹ã‚‰ ``s[i] == x`` ã¨ãªã‚‹æœ€åˆã®è¦ç´ ã‚’å–ã‚Šé™¤ãã¾ã™"

#: ../../library/stdtypes.rst:1092
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../library/stdtypes.rst:1092
msgid "reverses the items of *s* in place"
msgstr "*s* ã‚’ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã«é€†è»¢ã•ã›ã¾ã™"

#: ../../library/stdtypes.rst:1092 ../../library/stdtypes.rst:2196
#: ../../library/stdtypes.rst:2200 ../../library/stdtypes.rst:3300
#: ../../library/stdtypes.rst:3304
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/stdtypes.rst:1100
msgid "*t* must have the same length as the slice it is replacing."
msgstr "*t* ã¯ç½®ãæ›ãˆã‚‹ã‚¹ãƒ©ã‚¤ã‚¹ã¨åŒã˜é•·ã•ã§ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1103
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *i* ã¯æ¨™æº–ã§ ``-1`` ãªã®ã§ã€æ¨™æº–ã§ã¯æœ€å¾Œã®è¦ç´ ã‚’ãƒªã‚¹ãƒˆã‹ã‚‰é™¤å»ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1107
msgid "``remove`` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr "``remove`` ã¯ *s* ã« *x* ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã° :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1110
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
":meth:`reverse` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å¤§ããªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’åè»¢ã™ã‚‹ã¨ãã®å®¹é‡ã®ç¯€ç´„ã®ãŸã‚ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã«å¤‰åŒ–ã•ã›ã¾ã™ã€‚å‰¯ä½œç”¨ã¨ã—ã¦ã“ã®æ¼”ç®—ãŒè¡Œã‚ã‚Œã‚‹ã“ã¨ã‚’ãƒ¦ãƒ¼ã‚¶ã«æ°—ã¥ã‹ã›ã‚‹ãŸã‚ã«ã€ã“ã‚Œã¯åè»¢ã—ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1115
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such"
" as :class:`dict` and :class:`set`)"
msgstr ""
":meth:`clear` ãŠã‚ˆã³ :meth:`!copy` ã¯ã€ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°æ“ä½œã‚’ã‚µãƒãƒ¼ãƒˆã—ãªã„ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚³ãƒ³ãƒ†ãƒŠ (:class:`dict`"
" ã‚„ :class:`set` ãªã©) ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¨ã®ä¸€è²«æ€§ã®ãŸã‚ã«å«ã¾ã‚Œã¦ã„ã¾ã™"

#: ../../library/stdtypes.rst:1119
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr ":meth:`clear` ãŠã‚ˆã³ :meth:`!copy` ãƒ¡ã‚½ãƒƒãƒ‰ã€‚"

#: ../../library/stdtypes.rst:1123
msgid ""
"The value *n* is an integer, or an object implementing "
":meth:`~object.__index__`.  Zero and negative values of *n* clear the "
"sequence.  Items in the sequence are not copied; they are referenced "
"multiple times, as explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"å€¤ *n* ã¯æ•´æ•°ã§ã‚ã‚‹ã‹ã€:meth:`~object.__index__` ã‚’å®Ÿè£…ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ *n* "
"ã®å€¤ãŒã‚¼ãƒ­ã¾ãŸã¯è² æ•°ã®å ´åˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã€‚:ref:`typesseq-common` ã§ ``s * n`` "
"ã«ã¤ã„ã¦èª¬æ˜ã—ãŸã¨ãŠã‚Šã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®è¦ç´ ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œãªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„; ã‚³ãƒ”ãƒ¼ã§ã¯ãªãè¦ç´ ã«å¯¾ã™ã‚‹å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒå¢—ãˆã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1132
msgid "Lists"
msgstr "ãƒªã‚¹ãƒˆå‹ (list)"

#: ../../library/stdtypes.rst:1136
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"ãƒªã‚¹ãƒˆã¯ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã€ä¸€èˆ¬çš„ã«åŒç¨®ã®é …ç›®ã®é›†ã¾ã‚Šã‚’æ ¼ç´ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ "
"(å³å¯†ãªé¡ä¼¼ã®åº¦åˆã„ã¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚ˆã£ã¦ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:1142
msgid "Lists may be constructed in several ways:"
msgstr "ãƒªã‚¹ãƒˆã®æ§‹æˆã«ã¯ã„ãã¤ã‹ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™:"

#: ../../library/stdtypes.rst:1144
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr "è§’æ‹¬å¼§ã®å¯¾ã‚’ä½¿ã„ã€ç©ºã®ãƒªã‚¹ãƒˆã‚’è¡¨ã™: ``[]``"

#: ../../library/stdtypes.rst:1145
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr "è§’æ‹¬å¼§ã‚’ä½¿ã„ã€é …ç›®ã‚’ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‹: ``[a]``ã€``[a, b, c]``"

#: ../../library/stdtypes.rst:1146
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã‚’ä½¿ã†: ``[x for x in iterable]``"

#: ../../library/stdtypes.rst:1147
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "å‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½¿ã†: ``list()`` ã¾ãŸã¯ ``list(iterable)``"

#: ../../library/stdtypes.rst:1149
msgid ""
"The constructor builds a list whose items are the same and in the same order"
" as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€ *iterable* ã®é …ç›®ã¨åŒã˜é …ç›®ã§åŒã˜é †ã®ãƒªã‚¹ãƒˆã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚ *iterable* "
"ã¯ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚³ãƒ³ãƒ†ãƒŠã€ã¾ãŸã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ *iterable* ãŒæ—¢ã«ãƒªã‚¹ãƒˆãªã‚‰ã€ "
"``iterable[:]`` ã¨åŒæ§˜ã«ã‚³ãƒ”ãƒ¼ãŒä½œã‚‰ã‚Œã¦è¿”ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ``list('abc')`` ã¯ ``['a', 'b', 'c']``"
" ã‚’ã€ ``list( (1, 2, 3) )`` ã¯ ``[1, 2, 3]`` "
"ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œãªã‘ã‚Œã°ã€ã“ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯æ–°ã—ã„ç©ºã®ãƒªã‚¹ãƒˆ ``[]`` ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1158
msgid ""
"Many other operations also produce lists, including the :func:`sorted` "
"built-in."
msgstr "ãƒªã‚¹ãƒˆã‚’ä½œã‚‹æ–¹æ³•ã¯ã€ä»–ã«ã‚‚çµ„ã¿è¾¼ã¿é–¢æ•° :func:`sorted` ãªã©ã„ã‚ã„ã‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1161
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable"
" <typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"ãƒªã‚¹ãƒˆã¯ :ref:`å…±é€šã® <typesseq-common>` ãŠã‚ˆã³ :ref:`ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã® <typesseq-mutable>` "
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹æ¼”ç®—ã‚’ã™ã¹ã¦å®Ÿè£…ã—ã¾ã™ã€‚ãƒªã‚¹ãƒˆã¯ã€æ›´ã«ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚æä¾›ã—ã¾ã™:"

#: ../../library/stdtypes.rst:1167
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€é …ç›®é–“ã® ``<`` "
"æ¯”è¼ƒã®ã¿ã‚’ç”¨ã„ã¦ãƒªã‚¹ãƒˆã‚’ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã«ã‚½ãƒ¼ãƒˆã—ã¾ã™ã€‚ä¾‹å¤–ã¯æŠ‘åˆ¶ã•ã‚Œã¾ã›ã‚“ã€‚æ¯”è¼ƒæ¼”ç®—ãŒã©ã“ã‹ã§å¤±æ•—ã—ãŸã‚‰ã€ã‚½ãƒ¼ãƒˆæ¼”ç®—è‡ªä½“ãŒå¤±æ•—ã—ã¾ã™ "
"(ãã—ã¦ãƒªã‚¹ãƒˆã¯éƒ¨åˆ†çš„ã«å¤‰æ›´ã•ã‚ŒãŸçŠ¶æ…‹ã§æ®‹ã•ã‚Œã‚‹ã§ã—ã‚‡ã†)ã€‚"

#: ../../library/stdtypes.rst:1172
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref"
":`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` ã«ã¯ï¼’ã¤ã®å¼•æ•°ã‚’ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•° (:ref:`keyword-only arguments <keyword-"
"only_parameter>`) ã¨ã—ã¦ã®ã¿æ¸¡ã›ã¾ã™ :"

#: ../../library/stdtypes.rst:1175
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key* ã¯ä¸€å¼•æ•°ã‚’ã¨ã‚‹é–¢æ•°ã‚’æŒ‡å®šã—ã€ãƒªã‚¹ãƒˆã®ãã‚Œãã‚Œã®è¦ç´ ã‹ã‚‰æ¯”è¼ƒã‚­ãƒ¼ã‚’å–ã‚Šå‡ºã™ã®ã«ä½¿ã„ã¾ã™ (ä¾‹ãˆã°ã€ "
"``key=str.lower``)ã€‚ãã‚Œãã‚Œã®é …ç›®ã«å¯¾å¿œã™ã‚‹ã‚­ãƒ¼ã¯ä¸€åº¦è¨ˆç®—ã•ã‚Œã€ã‚½ãƒ¼ãƒˆå‡¦ç†å…¨ä½“ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å€¤ ``None`` "
"ã¯ã€åˆ¥ã®ã‚­ãƒ¼å€¤ã‚’è¨ˆç®—ã›ãšã€ãƒªã‚¹ãƒˆã®å€¤ãŒç›´æ¥ã‚½ãƒ¼ãƒˆã•ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1182
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style"
" *cmp* function to a *key* function."
msgstr ""
"2.x å½¢å¼ã® *cmp* é–¢æ•°ã‚’ *key* é–¢æ•°ã«å¤‰æ›ã™ã‚‹ãŸã‚ã«ã€:func:`functools.cmp_to_key` "
"ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãŒåˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1185
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr "*reverse* ã¯çœŸå½å€¤ã§ã™ã€‚ ``True`` ãŒã‚»ãƒƒãƒˆã•ã‚ŒãŸå ´åˆã€ãƒªã‚¹ãƒˆã®è¦ç´ ã¯å€‹ã€…ã®æ¯”è¼ƒãŒåè»¢ã—ãŸã‚‚ã®ã¨ã—ã¦ä¸¦ã³æ›¿ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1188
msgid ""
"This method modifies the sequence in place for economy of space when sorting"
" a large sequence.  To remind users that it operates by side effect, it does"
" not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å¤§ããªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã‚½ãƒ¼ãƒˆã™ã‚‹ã¨ãã®å®¹é‡ã®ç¯€ç´„ã®ãŸã‚ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã«å¤‰åŒ–ã•ã›ã¾ã™ã€‚å‰¯ä½œç”¨ã¨ã—ã¦ã“ã®æ¼”ç®—ãŒè¡Œã‚ã‚Œã‚‹ã“ã¨ã‚’ãƒ¦ãƒ¼ã‚¶ã«æ°—ã¥ã‹ã›ã‚‹ãŸã‚ã«ã€ã“ã‚Œã¯ã‚½ãƒ¼ãƒˆã—ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã›ã‚“"
" (æ–°ã—ã„ãƒªã‚¹ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ˜ç¤ºçš„ã«è¦æ±‚ã™ã‚‹ã«ã¯ :func:`sorted` ã‚’ä½¿ã£ã¦ãã ã•ã„)ã€‚"

#: ../../library/stdtypes.rst:1193
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
":meth:`sort` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯å®‰å®šã—ã¦ã„ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã¾ã™ã€‚ã‚½ãƒ¼ãƒˆã¯ã€ç­‰ã—ã„è¦ç´ ã®ç›¸å¯¾é †åºãŒå¤‰æ›´ã•ã‚Œãªã„ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã‚Œã°ã€å®‰å®šã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯è¤‡æ•°ãƒ‘ã‚¹ã®ã‚½ãƒ¼ãƒˆã‚’è¡Œãªã†"
" (ä¾‹ãˆã°éƒ¨ç½²ã§ã‚½ãƒ¼ãƒˆã—ã¦ã€ãã‚Œã‹ã‚‰çµ¦ä¸ã®ç­‰ç´šã§ã‚½ãƒ¼ãƒˆã™ã‚‹) ã®ã«å½¹ç«‹ã¡ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1200
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"ãƒªã‚¹ãƒˆãŒã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹é–“ã€ã¾ãŸã¯å¤‰æ›´ã—ã‚ˆã†ã¨ã™ã‚‹è©¦ã¿ã®å½±éŸ¿ä¸­ã€ã‚ã‚‹ã„ã¯æ¤œæŸ»ä¸­ã§ã•ãˆã€ãƒªã‚¹ãƒˆã¯æœªå®šç¾©ã§ã™ã€‚Python ã® C "
"å®Ÿè£…ã§ã¯ã€ãã‚Œã‚‰ãŒç¶šã„ã¦ã„ã‚‹é–“ã€ãƒªã‚¹ãƒˆã¯ç©ºã¨ã—ã¦å‡ºåŠ›ã•ã‚Œã€ãƒªã‚¹ãƒˆãŒã‚½ãƒ¼ãƒˆä¸­ã«å¤‰æ›´ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’æ¤œçŸ¥ã§ããŸã‚‰ :exc:`ValueError` "
"ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1209
msgid "Tuples"
msgstr "ã‚¿ãƒ—ãƒ«å‹ (tuple)"

#: ../../library/stdtypes.rst:1213
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or "
":class:`dict` instance)."
msgstr ""
"ã‚¿ãƒ—ãƒ«ã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã€ä¸€èˆ¬çš„ã«ç•°ç¨®ã®ãƒ‡ãƒ¼ã‚¿ã®é›†ã¾ã‚Š (çµ„ã¿è¾¼ã¿ã® :func:`enumerate` ã§ä½œã‚‰ã‚ŒãŸ 2-ã‚¿ãƒ—ãƒ«ãªã©) "
"ã‚’æ ¼ç´ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã¯ã¾ãŸã€åŒç¨®ã®ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒå¿…è¦ãªå ´åˆ (:class:`set` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚„ "
":class:`dict` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ä¿å­˜ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ãªã©) ã«ã‚‚ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1221
msgid "Tuples may be constructed in a number of ways:"
msgstr "ã‚¿ãƒ—ãƒ«ã®æ§‹æˆã«ã¯ã„ãã¤ã‹ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™:"

#: ../../library/stdtypes.rst:1223
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr "ä¸¸æ‹¬å¼§ã®å¯¾ã‚’ä½¿ã„ã€ç©ºã®ã‚¿ãƒ—ãƒ«ã‚’è¡¨ã™: ``()``"

#: ../../library/stdtypes.rst:1224
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr "ã‚«ãƒ³ãƒã‚’ä½¿ã„ã€å˜è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã‚’è¡¨ã™: ``a,`` ã¾ãŸã¯ ``(a,)``"

#: ../../library/stdtypes.rst:1225
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "é …ç›®ã‚’ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‹: ``a, b, c`` ã¾ãŸã¯ ``(a, b, c)``"

#: ../../library/stdtypes.rst:1226
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr "çµ„ã¿è¾¼ã¿ã® :func:`tuple` ã‚’ä½¿ã†: ``tuple()`` ã¾ãŸã¯ ``tuple(iterable)``"

#: ../../library/stdtypes.rst:1228
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€ *iterable* ã®é …ç›®ã¨åŒã˜é …ç›®ã§åŒã˜é †ã®ã‚¿ãƒ—ãƒ«ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚ *iterable* "
"ã¯ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚³ãƒ³ãƒ†ãƒŠã€ã¾ãŸã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ *iterable* "
"ãŒæ—¢ã«ã‚¿ãƒ—ãƒ«ãªã‚‰ã€ãã®ã¾ã¾è¿”ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ ``tuple('abc')`` ã¯ ``('a', 'b', 'c')`` ã‚’ã€ ``tuple( "
"[1, 2, 3] )`` ã¯ ``(1, 2, 3)`` ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œãªã‘ã‚Œã°ã€ã“ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯æ–°ã—ã„ç©ºã®ã‚¿ãƒ—ãƒ« ``()`` "
"ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1236
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses."
" The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"ãªãŠã€ã‚¿ãƒ—ãƒ«ã‚’ä½œã‚‹ã®ã¯ã‚«ãƒ³ãƒã§ã‚ã‚Šã€ä¸¸æ‹¬å¼§ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¸¸æ‹¬å¼§ã¯çœç•¥å¯èƒ½ã§ã™ãŒã€ç©ºã®ã‚¿ãƒ—ãƒ«ã®å ´åˆã‚„æ§‹æ–‡ä¸Šã®æ›–æ˜§ã•ã‚’é¿ã‘ã‚‹ã®ã«å¿…è¦ãªæ™‚ã¯ä¾‹å¤–ã§ã™ã€‚ä¾‹ãˆã°ã€"
" ``f(a, b, c)`` ã¯ä¸‰å¼•æ•°ã®é–¢æ•°å‘¼ã³å‡ºã—ã§ã™ãŒã€``f((a, b, c))`` ã¯ 3-ã‚¿ãƒ—ãƒ«ã‚’å”¯ä¸€ã®å¼•æ•°ã¨ã™ã‚‹é–¢æ•°ã®å‘¼ã³å‡ºã—ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1242
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr "ã‚¿ãƒ—ãƒ«ã¯ :ref:`å…±é€šã® <typesseq-common>` ã‚·ãƒ¼ã‚±ãƒ³ã‚¹æ¼”ç®—ã‚’ã™ã¹ã¦å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1245
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"ç•°ç¨®ã®ãƒ‡ãƒ¼ã‚¿ã®é›†ã¾ã‚Šã§ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ã‚ˆã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã‚ˆã‚Šã‚‚åå‰ã«ã‚ˆã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã»ã†ãŒæ˜ç¢ºã«ãªã‚‹ã‚‚ã®ã«ã¯ã€å˜ç´”ãªã‚¿ãƒ—ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚ˆã‚Šã‚‚ "
":func:`collections.namedtuple` ãŒå‘ã„ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1253
msgid "Ranges"
msgstr "range"

#: ../../library/stdtypes.rst:1257
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` "
"loops."
msgstr ""
":class:`range` å‹ã¯ã€æ•°ã®ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è¡¨ã—ã€ä¸€èˆ¬ã« :keyword:`for` "
"ãƒ«ãƒ¼ãƒ—ã«ãŠã„ã¦ç‰¹å®šã®å›æ•°ã®ãƒ«ãƒ¼ãƒ—ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1264
msgid ""
"The arguments to the range constructor must be integers (either built-in "
":class:`int` or any object that implements the ``__index__`` special "
"method).  If the *step* argument is omitted, it defaults to ``1``. If the "
"*start* argument is omitted, it defaults to ``0``. If *step* is zero, "
":exc:`ValueError` is raised."
msgstr ""
"range ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å¼•æ•°ã¯æ•´æ•° (çµ„ã¿è¾¼ã¿ã® :class:`int` ã¾ãŸã¯ ``__index__`` ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ)"
" ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚*step* å¼•æ•°ãŒçœç•¥ã•ã‚ŒãŸå ´åˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ ``1`` ã§ã™ã€‚*start* å¼•æ•°ãŒçœç•¥ã•ã‚ŒãŸå ´åˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯  "
"``0`` ã§ã™ã€‚ *step* ãŒ 0 ã®å ´åˆã€:exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1270
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"*step* ãŒæ­£ã®å ´åˆã€range ``r`` ã®å†…å®¹ã¯å¼ ``r[i] = start + step*i`` ã§æ±ºå®šã•ã‚Œã¾ã™ã€‚ã“ã“ã§ã€ ``i >="
" 0`` ã‹ã¤ ``r[i] < stop`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1274
msgid ""
"For a negative *step*, the contents of the range are still determined by the"
" formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"*step* ãŒè² ã®å ´åˆã‚‚ã€range ``r`` ã®å†…å®¹ã¯å¼ ``r[i] = start + step*i`` ã§æ±ºå®šã•ã‚Œã¾ã™ã€‚ãŸã ã—ã€åˆ¶ç´„æ¡ä»¶ã¯ "
"``i >= 0`` ã‹ã¤ ``r[i] > stop`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1278
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint."
" Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"``r[0]`` ãŒå€¤ã®åˆ¶ç´„ã‚’æº€ãŸã•ãªã„å ´åˆã€range ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ç©ºã«ãªã‚Šã¾ã™ã€‚range "
"ã¯è² ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ãŒã€ã“ã‚Œã‚‰ã¯æ­£ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ã‚ˆã‚Šæ±ºå®šã•ã‚Œã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®æœ«å°¾ã‹ã‚‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã¨ã—ã¦è§£é‡ˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1283
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise "
":exc:`OverflowError`."
msgstr ""
"range ã¯ :data:`sys.maxsize` ã‚ˆã‚Šå¤§ãã„çµ¶å¯¾å€¤ã‚’å«ã‚€ã“ã¨ãŒã§ãã¾ã™ãŒã€ã„ãã¤ã‹ã®æ©Ÿèƒ½ (:func:`len` ãªã©) ã¯ "
":exc:`OverflowError` ã‚’é€å‡ºã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1287
msgid "Range examples::"
msgstr "range ã®ä¾‹::"

#: ../../library/stdtypes.rst:1304
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"range ã¯ :ref:`å…±é€šã® <typesseq-common>` ã‚·ãƒ¼ã‚±ãƒ³ã‚¹æ¼”ç®—ã‚’ã€çµåˆã¨ç¹°ã‚Šè¿”ã—ä»¥å¤–ã™ã¹ã¦å®Ÿè£…ã—ã¾ã™ (range "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å³æ ¼ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¾“ã†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã¿ã‚’è¡¨ã›ã€ç¹°ã‚Šè¿”ã—ã¨çµåˆã¯ãŸã„ã¦ã„ãã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç ´ã‚‹ã¨ã„ã†äº‹å®Ÿã«ã‚ˆã‚Šã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:1311
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr "å¼•æ•° *start* ã®å€¤ (ã“ã®å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œã¦ã„ãªã„å ´åˆã¯ ``0``)"

#: ../../library/stdtypes.rst:1316
msgid "The value of the *stop* parameter"
msgstr "å¼•æ•° *stop* ã®å€¤"

#: ../../library/stdtypes.rst:1320
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr "å¼•æ•° *step* ã®å€¤ (ã“ã®å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œã¦ã„ãªã„å ´åˆã¯ ``1``)"

#: ../../library/stdtypes.rst:1323
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or "
":class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
":class:`range` å‹ãŒé€šå¸¸ã® :class:`list` ã‚„ :class:`tuple` ã«ã¾ã•ã‚‹ç‚¹ã¯ã€:class:`range` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚µã‚¤ã‚ºã‚„è¡¨ã™ç¯„å›²ã«ã‹ã‹ã‚ã‚‰ãšå¸¸ã«ä¸€å®šã® (å°ã•ãª) é‡ã®ãƒ¡ãƒ¢ãƒªã‚’ä½¿ã†ã“ã¨ã§ã™ (``start``ã€``stop``ã€``step`` "
"ã®å€¤ã®ã¿ã‚’ä¿å­˜ã—ã€å¾Œã¯å¿…è¦ã«å¿œã˜ã¦å€‹ã€…ã®é …ç›®ã‚„éƒ¨åˆ† range ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã§ã™)ã€‚"

#: ../../library/stdtypes.rst:1329
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"range ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :class:`collections.abc.Sequence` ABC "
"ã‚’å®Ÿè£…ã—ã€åŒ…å«åˆ¤å®šã€è¦ç´ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ¤œç´¢ã€ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ã®ã‚ˆã†ãªæ©Ÿèƒ½ã‚’æä¾›ã—ã€è² ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ (:ref:`typesseq` "
"ã‚’å‚ç…§):"

#: ../../library/stdtypes.rst:1349
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop`"
" and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"``==`` ãŠã‚ˆã³ ``!=`` ã«ã‚ˆã‚‹ range ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç­‰ä¾¡æ€§ã®åˆ¤å®šã¯ã€ã“ã‚Œã‚‰ã‚’ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦æ¯”è¼ƒã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€äºŒã¤ã® range "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯åŒã˜å€¤ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è¡¨ã™ãªã‚‰ç­‰ã—ã„ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚(ãªãŠã€äºŒã¤ã®ç­‰ã—ã„ã¨ã•ã‚Œã‚‹ range ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç•°ãªã‚‹  "
":attr:`~range.start`, :attr:`~range.stop` ãŠã‚ˆã³ :attr:`~range.step` "
"å±æ€§ã‚’æŒã¤ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã° ``range(0) == range(2, 1, 3)`` ã‚„ ``range(0, 3, 2) == "
"range(0, 4, 2)``ã€‚)"

#: ../../library/stdtypes.rst:1356
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test "
":class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ABC ã‚’å®Ÿè£…ã€‚ã‚¹ãƒ©ã‚¤ã‚¹ã¨è² ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ã‚µãƒãƒ¼ãƒˆã€‚:class:`int` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¸°å±åˆ¤å®šã‚’ã€ã™ã¹ã¦ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ä»£ã‚ã‚Šã«ã€å®šæ•°æ™‚é–“ã§è¡Œã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1362
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"(ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŒä¸€æ€§ã«åŸºã¥ã„ã¦æ¯”è¼ƒã™ã‚‹ä»£ã‚ã‚Šã«) range ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãã‚Œã‚‰ãŒå®šç¾©ã™ã‚‹å€¤ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«åŸºã¥ã„ã¦æ¯”è¼ƒã™ã‚‹ã‚ˆã†ã« '==' ã¨ "
"'!=' ã‚’å®šç¾©ã—ã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:1367
msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr "å±æ€§ :attr:`~range.start`, :attr:`~range.stop` ãŠã‚ˆã³ :attr:`~range.step`ã€‚"

#: ../../library/stdtypes.rst:1373
msgid ""
"The `linspace recipe <http://code.activestate.com/recipes/579000/>`_ shows "
"how to implement a lazy version of range that suitable for floating point "
"applications."
msgstr ""
"é…å»¶è©•ä¾¡ã•ã‚Œã‚‹æµ®å‹•å°æ•°ç‚¹ç‰ˆã® range ã®ä½œã‚Šæ–¹ã¯ `linspace ãƒ¬ã‚·ãƒ” "
"<http://code.activestate.com/recipes/579000/>`_ ã§ç¤ºã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1385
msgid "Text Sequence Type --- :class:`str`"
msgstr "ãƒ†ã‚­ã‚¹ãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ --- :class:`str`"

#: ../../library/stdtypes.rst:1387
msgid ""
"Textual data in Python is handled with :class:`str` objects, or "
":dfn:`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode"
" code points.  String literals are written in a variety of ways:"
msgstr ""
"Python ã®ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã¯ :class:`str` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã™ãªã‚ã¡ :dfn:`æ–‡å­—åˆ—` ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚æ–‡å­—åˆ—ã¯ Unicode "
"ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãª :ref:`ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ <typesseq>` ã§ã™ã€‚æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«ã¯æ§˜ã€…ãªè¨˜è¿°æ–¹æ³•ãŒã‚ã‚Šã¾ã™:"

#: ../../library/stdtypes.rst:1392
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "ã‚·ãƒ³ã‚°ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆ: ``'\"ãƒ€ãƒ–ãƒ«\" ã‚¯ã‚©ãƒ¼ãƒˆã‚’åŸ‹ã‚è¾¼ã‚€ã“ã¨ãŒã§ãã¾ã™'``"

#: ../../library/stdtypes.rst:1393
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``."
msgstr "ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆ: ``\"'ã‚·ãƒ³ã‚°ãƒ«' ã‚¯ã‚©ãƒ¼ãƒˆã‚’åŸ‹ã‚è¾¼ã‚€ã“ã¨ãŒã§ãã¾ã™\"``ã€‚"

#: ../../library/stdtypes.rst:1394
msgid "Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double quotes\"\"\"``"
msgstr "ä¸‰é‡å¼•ç”¨ç¬¦: ``'''ä¸‰ã¤ã®ã‚·ãƒ³ã‚°ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆ'''``, ``\"\"\"ä¸‰ã¤ã®ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆ\"\"\"``"

#: ../../library/stdtypes.rst:1396
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr "ä¸‰é‡å¼•ç”¨ç¬¦æ–‡å­—åˆ—ã¯ã€è¤‡æ•°è¡Œã«åˆ†ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚é–¢é€£ä»˜ã‘ã‚‰ã‚Œã‚‹ç©ºç™½ã¯ã™ã¹ã¦æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«å«ã¾ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1399
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"å˜å¼ã®ä¸€éƒ¨ã§ã‚ã‚Šé–“ã«ç©ºç™½ã®ã¿ã‚’å«ã‚€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¯ã€ä¸€ã¤ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«æš—é»™ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šã€``(\"spam \" \"eggs\") =="
" \"spam eggs\"`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1403
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported escape sequences, and the ``r`` (\"raw\") prefix that "
"disables most escape sequence processing."
msgstr ""
"ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’å«ã‚€æ–‡å­—åˆ—ã‚„ã€ã»ã¨ã‚“ã©ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‡¦ç†ã‚’ç„¡åŠ¹ã«ã™ã‚‹ ``r`` (\"raw\") "
"æ¥é ­è¾ãªã©ã®ã€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã®æ§˜ã€…ãªå½¢å¼ã¯ã€:ref:`strings` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:1407
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr "æ–‡å­—åˆ—ã¯ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã« :class:`str` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½¿ã†ã“ã¨ã§ã‚‚ç”Ÿæˆã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1410
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == "
"s[0:1]``."
msgstr ""
"\"character\" å‹ãŒç‰¹åˆ¥ã«ç”¨æ„ã•ã‚Œã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ã®ã§ã€æ–‡å­—åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã‚’è¡Œã†ã¨é•·ã• 1 "
"ã®æ–‡å­—åˆ—ã‚’ä½œæˆã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ç©ºã§ãªã„æ–‡å­—åˆ— *s* ã«å¯¾ã—ã€``s[0] == s[0:1]`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1416
msgid ""
"There is also no mutable string type, but :meth:`str.join` or "
":class:`io.StringIO` can be used to efficiently construct strings from "
"multiple fragments."
msgstr ""
"ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªæ–‡å­—åˆ—å‹ã‚‚ã‚ã‚Šã¾ã›ã‚“ãŒã€ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªæ–­ç‰‡ã‹ã‚‰åŠ¹ç‡ã‚ˆãæ–‡å­—åˆ—ã‚’æ§‹æˆã™ã‚‹ã®ã« :meth:`str.join` ã‚„ "
":class:`io.StringIO` ãŒä½¿ãˆã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1420
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Python 2 ã‚·ãƒªãƒ¼ã‚ºã¨ã®å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã® ``u`` "
"æ¥é ­è¾ãŒæ”¹ã‚ã¦è¨±å¯ã•ã‚Œã¾ã—ãŸã€‚ãã‚Œã¯æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¨ã—ã¦ã®æ„å‘³ã«ã¯å½±éŸ¿ãŒãªãã€ ``r`` æ¥é ­è¾ã¨çµåˆã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1432
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"*object* ã® :ref:`æ–‡å­—åˆ— <textseq>` ç‰ˆã‚’è¿”ã—ã¾ã™ã€‚ *object* "
"ãŒä¸ãˆã‚‰ã‚Œãªã‹ã£ãŸå ´åˆã€ç©ºæ–‡å­—åˆ—ãŒè¿”ã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆ ``str()`` ã®å‹•ä½œã¯ã€ *encoding* ã‚„ *errors* "
"ãŒä¸ãˆã‚‰ã‚ŒãŸã‹ã©ã†ã‹ã«ã‚ˆã£ã¦æ¬¡ã®ã‚ˆã†ã«å¤‰ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1436
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns "
":meth:`object.__str__() <object.__str__>`, which is the \"informal\" or "
"nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a "
":meth:`~object.__str__` method, then :func:`str` falls back to returning "
":meth:`repr(object) <repr>`."
msgstr ""
"*encoding* ã‚‚ *errors* ã‚‚ä¸ãˆã‚‰ã‚Œãªã„å ´åˆã€ ``str(object)`` ã¯ :meth:`object.__str__() "
"<object.__str__>` ã®çµæœã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯ \"ç•¥å¼ã®\" ã¤ã¾ã‚Šèª­ã¿æ˜“ã„ *object* "
"ã®æ–‡å­—åˆ—è¡¨ç¾ã§ã™ã€‚æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã¯ãã®æ–‡å­—åˆ—è‡ªä½“ã‚’è¿”ã—ã¾ã™ã€‚ *object* ãŒ :meth:`~object.__str__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒãŸãªã„å ´åˆã€:func:`str` ã¯ä»£ã‚ã‚Šã« :meth:`repr(object) <repr>` ã®çµæœã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1447
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a "
":term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to "
":meth:`bytes.decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes"
" object underlying the buffer object is obtained before calling "
":meth:`bytes.decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for "
"information on buffer objects."
msgstr ""
"*encoding* ã‹ *errors* ã®å°‘ãªãã¨ã‚‚ä¸€æ–¹ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ *object* ã¯ :term:`bytes-like object`"
" (ãŸã¨ãˆã° :class:`bytes` ã‚„ :class:`bytearray`) ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚*object* ãŒ "
":class:`bytes` (ã‚‚ã—ãã¯ :class:`bytearray`) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹å ´åˆã¯ã€ ``str(bytes, "
"encoding, errors)`` ã¯ :meth:`bytes.decode(encoding, errors) <bytes.decode>` "
"ã¨ç­‰ä¾¡ã§ã™ã€‚ãã†ã§ãªã„å ´åˆã¯ã€ :meth:`bytes.decode` ãŒå‘¼ã°ã‚Œã‚‹å‰ã« buffer ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸‹å±¤ã«ã‚ã‚‹ bytes "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå–å¾—ã•ã‚Œã¾ã™ã€‚ buffer ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦è©³ã—ã„æƒ…å ±ã¯ã€ :ref:`binaryseq` ã‚„ "
":ref:`bufferobjects` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:1456
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"*encoding* å¼•æ•°ã‚„ *errors* å¼•æ•°ç„¡ã—ã« :class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :func:`str` "
"ã«æ¸¡ã™ã¨ã€ç•¥å¼ã®æ–‡å­—åˆ—è¡¨ç¾ã‚’è¿”ã™ 1 ã¤ç›®ã®å ´åˆã«è©²å½“ã—ã¾ã™ã€‚(Python ã®ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‚ªãƒ—ã‚·ãƒ§ãƒ³ :option:`-b` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„)"
" ä¾‹ãˆã°::"

#: ../../library/stdtypes.rst:1464
msgid ""
"For more information on the ``str`` class and its methods, see "
":ref:`textseq` and the :ref:`string-methods` section below.  To output "
"formatted strings, see the :ref:`f-strings` and :ref:`formatstrings` "
"sections.  In addition, see the :ref:`stringservices` section."
msgstr ""
"``str`` ã‚¯ãƒ©ã‚¹ã¨ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¤ã„ã¦è©³ã—ãã¯ã€ :ref:`ãƒ†ã‚­ã‚¹ãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ â€” str <textseq>` ã‚„ :ref"
":`string-methods` ã®ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã•ã‚ŒãŸæ–‡å­—åˆ—ã‚’å‡ºåŠ›ã™ã‚‹ã«ã¯ã€ :ref:`f-strings` ã¨ :ref"
":`string-formatting` ã®ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚åŠ ãˆã¦ã€ :ref:`stringservices` ã®ç¯€ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:1476
msgid "String Methods"
msgstr "æ–‡å­—åˆ—ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../library/stdtypes.rst:1481
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr "æ–‡å­—åˆ—ã¯ :ref:`å…±é€šã® <typesseq-common>` ã‚·ãƒ¼ã‚±ãƒ³ã‚¹æ¼”ç®—å…¨ã¦ã«åŠ ãˆã€ä»¥ä¸‹ã«è¿°ã¹ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1484
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, "
":ref:`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"æ–‡å­—åˆ—ã¯ã€äºŒå½¢å¼ã®æ–‡å­—åˆ—æ›¸å¼åŒ–ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ä¸€æ–¹ã¯æŸ”è»Ÿã•ãŒé«˜ãã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ (:meth:`str.format`ã€ "
":ref:`formatstrings` ã€ãŠã‚ˆã³ :ref:`string-formatting` ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚ä»–æ–¹ã¯ C è¨€èªã® "
"``printf`` å½¢å¼ã®æ›¸å¼åŒ–ã«åŸºã¥ã„ã¦ã‚ˆã‚Šç‹­ã„ç¯„å›²ã¨å‹ã‚’æ‰±ã†ã‚‚ã®ã§ã€æ­£ã—ãæ‰±ã†ã®ã¯å°‘ã—é›£ã—ã„ã§ã™ãŒã€æ‰±ãˆã‚‹å ´åˆã§ã¯ãŸã„ã¦ã„ã“ã¡ã‚‰ã®ã»ã†ãŒé«˜é€Ÿã§ã™ "
"(:ref:`old-string-formatting`)ã€‚"

#: ../../library/stdtypes.rst:1491
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular"
" expression support in the :mod:`re` module)."
msgstr ""
"æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® :ref:`textservices` ç¯€ã¯ã€ãã®ä»–ãƒ†ã‚­ã‚¹ãƒˆã«é–¢ã™ã‚‹æ§˜ã€…ãªãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ (:mod:`re` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ˆã‚‹æ­£è¦è¡¨ç¾ã‚µãƒãƒ¼ãƒˆãªã©) ã‚’æä¾›ã™ã‚‹ã„ãã¤ã‹ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚«ãƒãƒ¼ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1497
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr "æœ€åˆã®æ–‡å­—ã‚’å¤§æ–‡å­—ã«ã—ã€æ®‹ã‚Šã‚’å°æ–‡å­—ã«ã—ãŸæ–‡å­—åˆ—ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1503
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr "æ–‡å­—åˆ—ã® casefold ã•ã‚ŒãŸã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚casefold ã•ã‚ŒãŸæ–‡å­—åˆ—ã¯ã€å¤§æ–‡å­—å°æ–‡å­—ã«é–¢ä¿‚ãªã„ãƒãƒƒãƒã«ä½¿ãˆã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1506
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ÃŸ'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ÃŸ'``; "
":meth:`casefold` converts it to ``\"ss\"``."
msgstr ""
"casefold "
"ã¯ã€å°æ–‡å­—åŒ–ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€ã‚ˆã‚Šç©æ¥µçš„ã§ã™ã€‚ã“ã‚Œã¯æ–‡å­—åˆ—ã®å¤§æ–‡å­—å°æ–‡å­—ã®åŒºåˆ¥ã‚’ã™ã¹ã¦å–ã‚Šå»ã‚‹ã“ã¨ã‚’æ„å›³ã—ã¦ã„ã‚‹ãŸã‚ã§ã™ã€‚ä¾‹ãˆã°ã€ãƒ‰ã‚¤ãƒ„èªã®å°æ–‡å­— "
"``'ÃŸ'`` ã¯ ``\"ss\"`` ã¨åŒã˜ã§ã™ã€‚ã“ã‚Œã¯æ—¢ã«å°æ–‡å­—ãªã®ã§ã€:meth:`lower` ã¯ ``'ÃŸ'`` "
"ã«ä½•ã‚‚ã—ã¾ã›ã‚“ãŒã€:meth:`casefold` ã¯ã“ã‚Œã‚’ ``\"ss\"`` ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1512
msgid ""
"The casefolding algorithm is described in section 3.13 of the Unicode "
"Standard."
msgstr "casefold ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ Unicode Standard ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ 3.13 ã«è¨˜è¿°ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1520
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"*width* ã®é•·ã•ã‚’ã‚‚ã¤ä¸­å¤®å¯„ã›ã•ã‚ŒãŸæ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã«ã¯ *fillchar* ã§æŒ‡å®šã•ã‚ŒãŸå€¤ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ASCII "
"ã‚¹ãƒšãƒ¼ã‚¹) ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ *width* ãŒ ``len(s)`` ä»¥ä¸‹ãªã‚‰å…ƒã®æ–‡å­—åˆ—ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1528
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"[*start*, *end*] ã®ç¯„å›²ã«ã€éƒ¨åˆ†æ–‡å­—åˆ— *sub* ãŒé‡è¤‡ã›ãšå‡ºç¾ã™ã‚‹å›æ•°ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *start* ãŠã‚ˆã³ *end*"
" ã¯ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã¨åŒã˜ã‚ˆã†ã«è§£é‡ˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1535
msgid ""
"Return an encoded version of the string as a bytes object. Default encoding "
"is ``'utf-8'``. *errors* may be given to set a different error handling "
"scheme. The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`. Other possible values are ``'ignore'``, "
"``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` and any other"
" name registered via :func:`codecs.register_error`, see section :ref:`error-"
"handlers`. For a list of possible encodings, see section :ref:`standard-"
"encodings`."
msgstr ""
"æ–‡å­—åˆ—ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚æ¨™æº–ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ ``'utf-8'`` "
"ã§ã™ã€‚æ¨™æº–ã¨ã¯ç•°ãªã‚‹ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚’è¡Œã†ãŸã‚ã« *errors* ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ¨™æº–ã®ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¯ ``'strict'`` "
"ã§ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã«é–¢ã™ã‚‹ã‚¨ãƒ©ãƒ¼ã¯ :exc:`UnicodeError` ã‚’é€å‡ºã—ã¾ã™ã€‚ä»–ã«åˆ©ç”¨ã§ãã‚‹å€¤ã¯ ``'ignore'``, "
"``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` ãŠã‚ˆã³é–¢æ•° "
":func:`codecs.register_error` ã«ã‚ˆã£ã¦ç™»éŒ²ã•ã‚ŒãŸåå‰ã§ã™ã€‚ã“ã‚Œã«ã¤ã„ã¦ã¯ã‚»ã‚¯ã‚·ãƒ§ãƒ³ :ref:`error-"
"handlers` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚åˆ©ç”¨å¯èƒ½ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ä¸€è¦§ã¯ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ :ref:`standard-encodings` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:1544
msgid "Support for keyword arguments added."
msgstr "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®ã‚µãƒãƒ¼ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:1550
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"æ–‡å­—åˆ—ãŒæŒ‡å®šã•ã‚ŒãŸ *suffix* ã§çµ‚ã‚ã‚‹ãªã‚‰ ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™ã€‚ *suffix* "
"ã¯è¦‹ã¤ã‘ãŸã„è¤‡æ•°ã®æ¥å°¾èªã®ã‚¿ãƒ—ãƒ«ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *start* ãŒã‚ã‚Œã°ã€ãã®ä½ç½®ã‹ã‚‰åˆ¤å®šã‚’å§‹ã‚ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *end* "
"ãŒã‚ã‚Œã°ã€ãã®ä½ç½®ã§æ¯”è¼ƒã‚’æ­¢ã‚ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1558
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current"
" column is set to zero and the string is examined character by character.  "
"If the character is a tab (``\\t``), one or more space characters are "
"inserted in the result until the current column is equal to the next tab "
"position. (The tab character itself is not copied.)  If the character is a "
"newline (``\\n``) or return (``\\r``), it is copied and the current column "
"is reset to zero.  Any other character is copied unchanged and the current "
"column is incremented by one regardless of how the character is represented "
"when printed."
msgstr ""
"æ–‡å­—åˆ—å†…ã®å…¨ã¦ã®ã‚¿ãƒ–æ–‡å­—ãŒ 1 ã¤ä»¥ä¸Šã®ã‚¹ãƒšãƒ¼ã‚¹ã§ç½®æ›ã•ã‚ŒãŸã€æ–‡å­—åˆ—ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ã‚¹ãƒšãƒ¼ã‚¹ã®æ•°ã¯ç¾åœ¨ã®æ¡ (column) ä½ç½®ã¨ "
"*tabsize* ã«ä¾å­˜ã—ã¾ã™ã€‚ã‚¿ãƒ–ä½ç½®ã¯ *tabsize* æ–‡å­—æ¯ã«å­˜åœ¨ã—ã¾ã™ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§ã‚ã‚‹ 8 ã®å ´åˆã€ã‚¿ãƒ–ä½ç½®ã¯ 0, 8, 16 "
"ãªã©ã«ãªã‚Šã¾ã™)ã€‚æ–‡å­—åˆ—ã‚’å±•é–‹ã™ã‚‹ãŸã‚ã€ã¾ãšç¾æ¡ä½ç½®ãŒã‚¼ãƒ­ã«ã‚»ãƒƒãƒˆã•ã‚Œã€æ–‡å­—åˆ—ãŒ 1 æ–‡å­—ãšã¤èª¿ã¹ã‚‰ã‚Œã¾ã™ã€‚æ–‡å­—ãŒã‚¿ãƒ–æ–‡å­— (``\\t``) "
"ã§ã‚ã‚Œã°ã€ç¾æ¡ä½ç½®ãŒæ¬¡ã®ã‚¿ãƒ–ä½ç½®ã¨ä¸€è‡´ã™ã‚‹ã¾ã§ã€1 ã¤ä»¥ä¸Šã®ã‚¹ãƒšãƒ¼ã‚¹ãŒçµæœã®æ–‡å­—åˆ—ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚(ã‚¿ãƒ–æ–‡å­—è‡ªä½“ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã›ã‚“ã€‚) æ–‡å­—ãŒæ”¹è¡Œæ–‡å­— "
"(``\\n`` ã‚‚ã—ãã¯ ``\\r``) ã®å ´åˆã€æ–‡å­—ãŒã‚³ãƒ”ãƒ¼ã•ã‚Œã€ç¾æ¡ä½ç½®ã¯ 0 "
"ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚ãã®ä»–ã®æ–‡å­—ã¯å¤‰æ›´ã•ã‚Œãšã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã€ç¾æ¡ä½ç½®ã¯ã€ãã®æ–‡å­—ã®è¡¨ç¤ºã®ã•ã‚Œæ–¹ (è¨³æ³¨: å…¨è§’ã€åŠè§’ãªã©) ã«é–¢ä¿‚ãªãã€1 "
"ãšã¤å¢—åŠ ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1579
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"æ–‡å­—åˆ—ã®ã‚¹ãƒ©ã‚¤ã‚¹ ``s[start:end]`` ã«éƒ¨åˆ†æ–‡å­—åˆ— *sub* ãŒå«ã¾ã‚Œã‚‹å ´åˆã€ãã®æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° "
"*start* ãŠã‚ˆã³ *end* ã¯ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã¨åŒæ§˜ã«è§£é‡ˆã•ã‚Œã¾ã™ã€‚ *sub* ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ ``-1`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1585
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the "
":keyword:`in` operator::"
msgstr ""
":meth:`~str.find` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ *sub* ã®ä½ç½®ã‚’çŸ¥ã‚ŠãŸã„ã¨ãã«ã®ã¿ä½¿ã†ã¹ãã§ã™ã€‚ *sub* "
"ãŒéƒ¨åˆ†æ–‡å­—åˆ—ã§ã‚ã‚‹ã‹ã©ã†ã‹ã®ã¿ã‚’èª¿ã¹ã‚‹ã«ã¯ã€ :keyword:`in` æ¼”ç®—å­ã‚’ä½¿ã£ã¦ãã ã•ã„::"

#: ../../library/stdtypes.rst:1595
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of"
" the corresponding argument."
msgstr ""
"æ–‡å­—åˆ—ã®æ›¸å¼åŒ–æ“ä½œã‚’è¡Œã„ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™æ–‡å­—åˆ—ã¯é€šå¸¸ã®æ–‡å­—ã€ã¾ãŸã¯ã€ ``{}`` "
"ã§åŒºåˆ‡ã‚‰ã‚ŒãŸç½®æ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å«ã¿ã¾ã™ã€‚ãã‚Œãã‚Œã®ç½®æ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ä½ç½®å¼•æ•°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒŠãƒ³ãƒãƒ¼ã€ã¾ãŸã¯ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®åå‰ã‚’å«ã¿ã¾ã™ã€‚è¿”ã‚Šå€¤ã¯ã€ãã‚Œãã‚Œã®ç½®æ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå¯¾å¿œã™ã‚‹å¼•æ•°ã®æ–‡å­—åˆ—å€¤ã§ç½®æ›ã•ã‚ŒãŸæ–‡å­—åˆ—ã®ã‚³ãƒ”ãƒ¼ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1605
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options"
" that can be specified in format strings."
msgstr "æ›¸å¼æŒ‡å®šã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«ã¤ã„ã¦ã¯ã€æ›¸å¼æŒ‡å®šæ–‡å­—åˆ—ã‚’è¦å®šã™ã‚‹ :ref:`formatstrings` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:1609
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`float` and "
"subclasses) with the ``n`` type (ex: ``'{:n}'.format(1234)``), the function "
"sets temporarily the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale to "
"decode ``decimal_point`` and ``thousands_sep`` fields of "
":c:func:`localeconv` if they are non-ASCII or longer than 1 byte, and the "
"``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale. This "
"temporary change affects other threads."
msgstr ""
"æ•°å€¤ (:class:`int`, :class:`float`, :class:`float` ã¨ã‚µãƒ–ã‚¯ãƒ©ã‚¹) ã‚’ ``n`` ã®æ•´æ•°è¡¨ç¾å‹ (ä¾‹: "
"``'{:n}'.format(1234)``) ã§ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã™ã‚‹ã¨ãã€``LC_CTYPE`` ãƒ­ã‚±ãƒ¼ãƒ«ã¨ ``LC_NUMERIC`` "
"ãƒ­ã‚±ãƒ¼ãƒ«ã®ä¸€æ–¹ã¾ãŸã¯ä¸¡æ–¹ãŒ 1 ãƒã‚¤ãƒˆã‚ˆã‚Šé•·ã„é ASCII æ–‡å­—ã§ã‚ã‚‹ã¨åŒæ™‚ã«ç•°ãªã‚‹å€¤ã§ã‚ã‚‹å ´åˆã€ã“ã®é–¢æ•°ã¯ :c:func:`localeconv`"
" ã® ``decimal_point`` ã¨ ``thousands_sep`` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’èª­ã¿å–ã‚‹ãŸã‚ä¸€æ™‚çš„ã« ``LC_CTYPE`` ãƒ­ã‚±ãƒ¼ãƒ«ã«"
" ``LC_NUMERIC`` ã®ãƒ­ã‚±ãƒ¼ãƒ«å€¤ã‚’è¨­å®šã—ã¾ã™ã€‚ã“ã®ä¸€æ™‚çš„ãªå¤‰æ›´ã¯ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®å‹•ä½œã«å½±éŸ¿ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1617
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"æ•°å€¤ã‚’ ``n`` ã®æ•´æ•°è¡¨ç¾å‹ã§ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã™ã‚‹ã¨ãã€ã“ã®é–¢æ•°ã¯ä¸€æ™‚çš„ã« ``LC_CTYPE`` ãƒ­ã‚±ãƒ¼ãƒ«ã« ``LC_NUMERIC`` "
"ã®ãƒ­ã‚±ãƒ¼ãƒ«å€¤ã‚’è¨­å®šã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1625
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"``str.format(**mapping)`` ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€ ``mapping`` ã¯ :class:`dict`  "
"ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œãšã€ç›´æ¥ä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ä¾‹ãˆã° ``mapping`` ãŒ dict ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ã¨ãã«ä¾¿åˆ©ã§ã™:"

#: ../../library/stdtypes.rst:1641
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ":meth:`~str.find` ã¨åŒæ§˜ã§ã™ãŒã€éƒ¨åˆ†æ–‡å­—åˆ—ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã¨ã :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1647
msgid ""
"Return true if all characters in the string are alphanumeric and there is at"
" least one character, false otherwise.  A character ``c`` is alphanumeric if"
" one of the following returns ``True``: ``c.isalpha()``, ``c.isdecimal()``, "
"``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"æ–‡å­—åˆ—ä¸­ã®å…¨ã¦ã®æ–‡å­—ãŒè‹±æ•°å­—ã§ã€ã‹ã¤ 1 æ–‡å­—ä»¥ä¸Šã‚ã‚‹ãªã‚‰çœŸã‚’ã€ãã†ã§ãªã‘ã‚Œã°å½ã‚’è¿”ã—ã¾ã™ã€‚æ–‡å­— ``c`` ã¯ä»¥ä¸‹ã®ã„ãšã‚Œã‹ãŒ ``True`` "
"ã‚’è¿”ã›ã°è‹±æ•°å­—ã§ã™: ``c.isalpha()`` ã€ ``c.isdecimal()`` ã€ ``c.isdigit()`` ã€ "
"``c.isnumeric()`` ã€‚"

#: ../../library/stdtypes.rst:1655
msgid ""
"Return true if all characters in the string are alphabetic and there is at "
"least one character, false otherwise.  Alphabetic characters are those "
"characters defined in the Unicode character database as \"Letter\", i.e., "
"those with general category property being one of \"Lm\", \"Lt\", \"Lu\", "
"\"Ll\", or \"Lo\".  Note that this is different from the \"Alphabetic\" "
"property defined in the Unicode Standard."
msgstr ""
"æ–‡å­—åˆ—ä¸­ã®å…¨ã¦ã®æ–‡å­—ãŒè‹±å­—ã§ã€ã‹ã¤ 1 æ–‡å­—ä»¥ä¸Šã‚ã‚‹ãªã‚‰çœŸã‚’ã€ãã†ã§ãªã‘ã‚Œã°å½ã‚’è¿”ã—ã¾ã™ã€‚è‹±å­—ã¯ã€Unicode æ–‡å­—ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ "
"\"Letter\" ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã§ã€ã™ãªã‚ã¡ã€ä¸€èˆ¬ã‚«ãƒ†ã‚´ãƒªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ \"Lm\"ã€ \"Lt\"ã€ \"Lu\"ã€ \"Ll\"ã€ "
"\"Lo\" ã®ã„ãšã‚Œã‹ã‚’ã‚‚ã¤ã‚‚ã®ã§ã™ã€‚ãªãŠã€ã“ã‚Œã¯ Unicode æ¨™æº–ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ \"Alphabetic\" ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨ã¯ç•°ãªã‚‹ã‚‚ã®ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1664
msgid ""
"Return true if all characters in the string are decimal characters and there"
" is at least one character, false otherwise. Decimal characters are those "
"that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT"
" ZERO.  Formally a decimal character is a character in the Unicode General "
"Category \"Nd\"."
msgstr ""
"æ–‡å­—åˆ—ä¸­ã®å…¨ã¦ã®æ–‡å­—ãŒåé€²æ•°å­—ã§ã€ã‹ã¤ 1 æ–‡å­—ä»¥ä¸Šã‚ã‚‹ãªã‚‰çœŸã‚’ã€ãã†ã§ãªã‘ã‚Œã°å½ã‚’è¿”ã—ã¾ã™ã€‚åé€²æ•°å­—ã¨ã¯åé€²æ•°ã‚’æ›¸ãã®ã«ä½¿ã‚ã‚Œã‚‹æ–‡å­—ã®ã“ã¨ã§ã€ãŸã¨ãˆã°"
" U+0660 (ARABIC-INDIC DIGIT ZERO) ãªã©ã‚‚å«ã¿ã¾ã™ã€‚æ­£å¼ã«ã¯ã€Unicode ã®ä¸€èˆ¬ã‚«ãƒ†ã‚´ãƒª \"Nd\" "
"ã«å«ã¾ã‚Œã‚‹æ–‡å­—ã‚’æŒ‡ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1674
msgid ""
"Return true if all characters in the string are digits and there is at least"
" one character, false otherwise.  Digits include decimal characters and "
"digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"æ–‡å­—åˆ—ä¸­ã®å…¨ã¦ã®æ–‡å­—ãŒæ•°å­—ã§ã€ã‹ã¤ 1 "
"æ–‡å­—ä»¥ä¸Šã‚ã‚‹ãªã‚‰çœŸã‚’ã€ãã†ã§ãªã‘ã‚Œã°å½ã‚’è¿”ã—ã¾ã™ã€‚ã“ã“ã§ã®æ•°å­—ã¨ã¯ã€åé€²æ•°å­—ã«åŠ ãˆã¦ã€äº’æ›ä¸Šä»˜ãæ•°å­—ã®ã‚ˆã†ãªç‰¹æ®Šæ“ä½œã‚’å¿…è¦ã¨ã™ã‚‹æ•°å­—ã‚’å«ã¿ã¾ã™ã€‚ã¾ãŸ "
"10 ã‚’åŸºæ•°ã¨ã—ãŸè¡¨ç¾ãŒã§ããªã„ã‚«ãƒ­ãƒ¼ã‚·ãƒ¥ãƒ†ã‚£ãƒ¼æ•°å­—ã®ã‚ˆã†ãªä½“ç³»ã®æ–‡å­—ã‚‚å«ã¿ã¾ã™ã€‚æ­£å¼ã«ã¯ã€æ•°å­—ã¨ã¯ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å€¤ Numeric_Type=Digit"
" ã¾ãŸã¯ Numeric_Type=Decimal ã‚’æŒã¤æ–‡å­—ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1684
msgid ""
"Return true if the string is a valid identifier according to the language "
"definition, section :ref:`identifiers`."
msgstr "æ–‡å­—åˆ—ãŒã€ :ref:`identifiers` ç¯€ã®è¨€èªå®šç¾©ã«ãŠã‘ã‚‹æœ‰åŠ¹ãªè­˜åˆ¥å­ã§ã‚ã‚Œã°çœŸã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1687
msgid ""
"Use :func:`keyword.iskeyword` to test for reserved identifiers such as "
":keyword:`def` and :keyword:`class`."
msgstr ""
":keyword:`def` ã‚„ :keyword:`class` "
"ã®ã‚ˆã†ãªäºˆç´„æ¸ˆã¿ã®è­˜åˆ¥å­ã‹åˆ¤å®šã™ã‚‹ã«ã¯ã€:func:`keyword.iskeyword` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:1692
msgid ""
"Return true if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, false otherwise."
msgstr ""
"æ–‡å­—åˆ—ä¸­ã®å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­— [4]_ å…¨ã¦ãŒå°æ–‡å­—ã§ã€ã‹ã¤å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­—ãŒ 1 æ–‡å­—ä»¥ä¸Šã‚ã‚‹ãªã‚‰çœŸã‚’ã€ãã†ã§ãªã‘ã‚Œã°å½ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1698
msgid ""
"Return true if all characters in the string are numeric characters, and "
"there is at least one character, false otherwise. Numeric characters include"
" digit characters, and all characters that have the Unicode numeric value "
"property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"æ–‡å­—åˆ—ä¸­ã®å…¨ã¦ã®æ–‡å­—ãŒæ•°ã‚’è¡¨ã™æ–‡å­—ã§ã€ã‹ã¤ 1 æ–‡å­—ä»¥ä¸Šã‚ã‚‹ãªã‚‰çœŸã‚’ã€ãã†ã§ãªã‘ã‚Œã°å½ã‚’è¿”ã—ã¾ã™ã€‚æ•°ã‚’è¡¨ã™æ–‡å­—ã¯ã€æ•°å­—ã¨ã€Unicode "
"ã®æ•°å€¤ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã¤å…¨ã¦ã®æ–‡å­—ã‚’å«ã¿ã¾ã™ã€‚ãŸã¨ãˆã°  U+2155 (VULGAR FRACTION ONE "
"FIFTH)ã€‚æ­£å¼ã«ã¯ã€æ•°ã‚’è¡¨ã™æ–‡å­—ã¯ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å€¤ Numeric_Type=Digitã€ Numeric_Type=Decimal ã¾ãŸã¯ "
"Numeric_Type=Numeric ã‚’æŒã¤ã‚‚ã®ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1708
msgid ""
"Return true if all characters in the string are printable or the string is "
"empty, false otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling"
" of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"æ–‡å­—åˆ—ä¸­ã®ã™ã¹ã¦ã®æ–‡å­—ãŒå°å­—å¯èƒ½ã§ã‚ã‚‹ã‹ã€æ–‡å­—åˆ—ãŒç©ºã§ã‚ã‚Œã°çœŸã‚’ã€ãã†ã§ãªã‘ã‚Œã°å½ã‚’è¿”ã—ã¾ã™ã€‚éå°å­—å¯èƒ½æ–‡å­—ã¯ã€ Unicode æ–‡å­—ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ "
"\"Other\" ã¾ãŸã¯ \"Separator\" ã¨å®šç¾©ã•ã‚Œã¦ã„ã‚‹æ–‡å­—ã®ã€å°å­—å¯èƒ½ã¨è¦‹ãªã•ã‚Œã‚‹ ASCII space (0x20) "
"ä»¥å¤–ã®ã‚‚ã®ã§ã™ã€‚(ãªãŠã€ã“ã®æ–‡è„ˆã§ã®å°å­—å¯èƒ½æ–‡å­—ã¯ã€æ–‡å­—åˆ—ã« :func:`repr` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ãã«ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã¹ãã§ãªã„æ–‡å­—ã®ã“ã¨ã§ã™ã€‚ã“ã‚Œã¯"
" :data:`sys.stdout` ã‚„ :data:`sys.stderr` ã«æ›¸ãè¾¼ã¾ã‚Œã‚‹æ–‡å­—åˆ—ã®æ“ä½œã¨ã¯é–¢ä¿‚ã‚ã‚Šã¾ã›ã‚“ã€‚)"

#: ../../library/stdtypes.rst:1719
msgid ""
"Return true if there are only whitespace characters in the string and there "
"is at least one character, false otherwise.  Whitespace characters  are "
"those characters defined in the Unicode character database as \"Other\" or "
"\"Separator\" and those with bidirectional property being one of \"WS\", "
"\"B\", or \"S\"."
msgstr ""
"æ–‡å­—åˆ—ãŒç©ºç™½æ–‡å­—ã®ã¿ã§æ§‹æˆã•ã‚Œã€ã‹ã¤ 1 æ–‡å­—ä»¥ä¸Šã‚ã‚‹å ´åˆã«ã¯çœŸã‚’ã€ãã†ã§ãªã‘ã‚Œã°å½ã‚’è¿”ã—ã¾ã™ã€‚ç©ºç™½æ–‡å­—ã¯ã€Unicode æ–‡å­—ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ "
"\"Other\" ã¾ãŸã¯ \"Separator\" ã¨å®šç¾©ã•ã‚Œã¦ã„ã¦ã€åŒæ–¹å‘ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒ \"WS\"ã€ \"B\"ã€ \"S\" "
"ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹æ–‡å­—ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1726
msgid ""
"Return true if the string is a titlecased string and there is at least one "
"character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return false "
"otherwise."
msgstr ""
"æ–‡å­—åˆ—ãŒã‚¿ã‚¤ãƒˆãƒ«ã‚±ãƒ¼ã‚¹æ–‡å­—åˆ—ã§ã‚ã‚Šã€ã‹ã¤ 1 "
"æ–‡å­—ä»¥ä¸Šã‚ã‚‹å ´åˆã€ä¾‹ãˆã°å¤§æ–‡å­—ã¯å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ãªã„æ–‡å­—ã®å¾Œã«ã®ã¿ç¶šãã€å°æ–‡å­—ã¯å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­—ã®å¾Œã‚ã«ã®ã¿ç¶šãå ´åˆã«ã¯çœŸã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã„å ´åˆã¯å½ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1733
msgid ""
"Return true if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, false otherwise."
msgstr ""
"æ–‡å­—åˆ—ä¸­ã®å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­— [4]_ å…¨ã¦ãŒå¤§æ–‡å­—ã§ã€ã‹ã¤å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­—ãŒ 1 æ–‡å­—ä»¥ä¸Šã‚ã‚‹ãªã‚‰çœŸã‚’ã€ãã†ã§ãªã‘ã‚Œã°å½ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1739
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A "
":exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"*iterable* ä¸­ã®æ–‡å­—åˆ—ã‚’çµåˆã—ãŸæ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ *iterable* ã« :class:`bytes` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚ˆã†ãªéæ–‡å­—åˆ—ã®å€¤ãŒå­˜åœ¨ã™ã‚‹ãªã‚‰ã€ :exc:`TypeError` "
"ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚è¦ç´ é–“ã®ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã™ã‚‹æ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/stdtypes.rst:1747
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"é•·ã• *width* ã®å·¦æƒãˆã—ãŸæ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã¯æŒ‡å®šã•ã‚ŒãŸ *fillchar* (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ASCII ã‚¹ãƒšãƒ¼ã‚¹) "
"ã‚’ä½¿ã£ã¦è¡Œã‚ã‚Œã¾ã™ã€‚ *width* ãŒ ``len(s)`` ä»¥ä¸‹ãªã‚‰ã°ã€å…ƒã®æ–‡å­—åˆ—ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1754
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr "å…¨ã¦ã®å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­— [4]_ ãŒå°æ–‡å­—ã«å¤‰æ›ã•ã‚ŒãŸã€æ–‡å­—åˆ—ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1757
msgid ""
"The lowercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr "ä½¿ã‚ã‚Œã‚‹å°æ–‡å­—åŒ–ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ Unicode Standard ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ 3.13 ã«è¨˜è¿°ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1763
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values"
" are stripped::"
msgstr ""
"æ–‡å­—åˆ—ã®å…ˆé ­ã®æ–‡å­—ã‚’é™¤å»ã—ãŸã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•° *chars* ã¯é™¤å»ã•ã‚Œã‚‹æ–‡å­—ã®é›†åˆã‚’æŒ‡å®šã™ã‚‹æ–‡å­—åˆ—ã§ã™ã€‚ *chars* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ "
"``None`` ã®å ´åˆã€ç©ºç™½æ–‡å­—ãŒé™¤å»ã•ã‚Œã¾ã™ã€‚ *chars* æ–‡å­—åˆ—ã¯æ¥é ­è¾ã§ã¯ãªãã€ãã®å€¤ã«å«ã¾ã‚Œã‚‹æ–‡å­—ã®çµ„ã¿åˆã‚ã›å…¨ã¦ãŒã¯ãå–ã‚‰ã‚Œã¾ã™::"

#: ../../library/stdtypes.rst:1776
msgid ""
"This static method returns a translation table usable for "
":meth:`str.translate`."
msgstr "ã“ã®é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :meth:`str.translate` ã«ä½¿ãˆã‚‹å¤‰æ›ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1778
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals,"
" strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"å¼•æ•°ã‚’ 1 ã¤ã ã‘ä¸ãˆã‚‹å ´åˆã€ãã‚Œã¯ Unicode åºæ•° (æ•´æ•°) ã¾ãŸã¯æ–‡å­—  (é•·ã• 1 ã®æ–‡å­—åˆ—) ã‚’ã€Unicode åºæ•°ã€(ä»»æ„é•·ã®) "
"æ–‡å­—åˆ—ã€ã¾ãŸã¯ ``None`` ã«å¯¾å¿œã¥ã‘ã‚‹è¾æ›¸ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ã¨ãã€æ–‡å­—ã§æŒ‡å®šã—ãŸã‚­ãƒ¼ã¯åºæ•°ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1783
msgid ""
"If there are two arguments, they must be strings of equal length, and in the"
" resulting dictionary, each character in x will be mapped to the character "
"at the same position in y.  If there is a third argument, it must be a "
"string, whose characters will be mapped to ``None`` in the result."
msgstr ""
"å¼•æ•°ã‚’ 2 ã¤æŒ‡å®šã™ã‚‹å ´åˆã€ãã‚Œã‚‰ã¯åŒã˜é•·ã•ã®æ–‡å­—åˆ—ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã€çµæœã®è¾æ›¸ã§ã¯ã€x ã®ãã‚Œãã‚Œã®æ–‡å­—ãŒ y ã®åŒã˜ä½ç½®ã®æ–‡å­—ã«å¯¾å¿œä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚ç¬¬"
" 3 å¼•æ•°ã‚’æŒ‡å®šã™ã‚‹å ´åˆã€æ–‡å­—åˆ—ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€ãã‚Œã«å«ã¾ã‚Œã‚‹æ–‡å­—ãŒ ``None`` ã«å¯¾å¿œä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1791
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part"
" after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"æ–‡å­—åˆ—ã‚’ *sep* ã®æœ€åˆã®å‡ºç¾ä½ç½®ã§åŒºåˆ‡ã‚Šã€ 3 "
"è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã®å†…å®¹ã¯ã€åŒºåˆ‡ã‚Šã®å‰ã®éƒ¨åˆ†ã€åŒºåˆ‡ã‚Šæ–‡å­—åˆ—ãã®ã‚‚ã®ã€ãã—ã¦åŒºåˆ‡ã‚Šã®å¾Œã‚ã®éƒ¨åˆ†ã§ã™ã€‚ã‚‚ã—åŒºåˆ‡ã‚Œãªã‘ã‚Œã°ã€ã‚¿ãƒ—ãƒ«ã«ã¯å…ƒã®æ–‡å­—åˆ—ãã®ã‚‚ã®ã¨ãã®å¾Œã‚ã«äºŒã¤ã®ç©ºæ–‡å­—åˆ—ãŒå…¥ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1799
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced"
" by *new*.  If the optional argument *count* is given, only the first "
"*count* occurrences are replaced."
msgstr ""
"æ–‡å­—åˆ—ã‚’ã‚³ãƒ”ãƒ¼ã—ã€ç¾ã‚Œã‚‹éƒ¨åˆ†æ–‡å­—åˆ— *old* å…¨ã¦ã‚’ *new* ã«ç½®æ›ã—ã¦è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *count* ãŒä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹å ´åˆã€å…ˆé ­ã‹ã‚‰ "
"*count* å€‹ã® *old* ã ã‘ã‚’ç½®æ›ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1806
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start*"
" and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"æ–‡å­—åˆ—ä¸­ã®é ˜åŸŸ ``s[start:end]`` ã« *sub* ãŒå«ã¾ã‚Œã‚‹å ´åˆã€ãã®æœ€å¤§ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *start* "
"ãŠã‚ˆã³ *end* ã¯ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã¨åŒæ§˜ã«è§£é‡ˆã•ã‚Œã¾ã™ã€‚ *sub* ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ ``-1``  ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1813
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ":meth:`rfind` ã¨åŒæ§˜ã§ã™ãŒã€ *sub* ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1819
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"*width* ã®é•·ã•ã‚’ã‚‚ã¤å³å¯„ã›ã—ãŸæ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã«ã¯ *fillchar* ã§æŒ‡å®šã•ã‚ŒãŸæ–‡å­—(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ASCII "
"ã‚¹ãƒšãƒ¼ã‚¹)ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ *width* ãŒ ``len(s)`` ä»¥ä¸‹ã®å ´åˆã€å…ƒã®æ–‡å­—åˆ—ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1826
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part"
" after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"æ–‡å­—åˆ—ã‚’ *sep* ã®æœ€å¾Œã®å‡ºç¾ä½ç½®ã§åŒºåˆ‡ã‚Šã€ 3 "
"è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã®å†…å®¹ã¯ã€åŒºåˆ‡ã‚Šã®å‰ã®éƒ¨åˆ†ã€åŒºåˆ‡ã‚Šæ–‡å­—åˆ—ãã®ã‚‚ã®ã€ãã—ã¦åŒºåˆ‡ã‚Šã®å¾Œã‚ã®éƒ¨åˆ†ã§ã™ã€‚ã‚‚ã—åŒºåˆ‡ã‚Œãªã‘ã‚Œã°ã€ã‚¿ãƒ—ãƒ«ã«ã¯äºŒã¤ã®ç©ºæ–‡å­—åˆ—ã¨ãã®å¾Œã‚ã«å…ƒã®æ–‡å­—åˆ—ãã®ã‚‚ã®ãŒå…¥ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1834
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"*sep* ã‚’åŒºåˆ‡ã‚Šæ–‡å­—ã¨ã—ãŸã€æ–‡å­—åˆ—ä¸­ã®å˜èªã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ *maxsplit* ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€æ–‡å­—åˆ—ã® *å³ç«¯* ã‹ã‚‰æœ€å¤§ "
"*maxsplit* å›åˆ†å‰²ã‚’è¡Œã„ã¾ã™ã€‚*sep* ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ã€ã‚ã‚‹ã„ã¯ ``None`` "
"ã®ã¨ãã€å…¨ã¦ã®ç©ºç™½æ–‡å­—ãŒåŒºåˆ‡ã‚Šæ–‡å­—ã¨ãªã‚Šã¾ã™ã€‚å³ã‹ã‚‰åˆ†å‰²ã—ã¦ã„ãã“ã¨ã‚’é™¤ã‘ã°ã€ :meth:`rsplit` ã¯å¾Œã»ã©è©³ã—ãè¿°ã¹ã‚‹ "
":meth:`split` ã¨åŒæ§˜ã«æŒ¯ã‚‹èˆã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1843
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values"
" are stripped::"
msgstr ""
"æ–‡å­—åˆ—ã®æœ«å°¾éƒ¨åˆ†ã‚’é™¤å»ã—ãŸã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•° *chars* ã¯é™¤å»ã•ã‚Œã‚‹æ–‡å­—é›†åˆã‚’æŒ‡å®šã™ã‚‹æ–‡å­—åˆ—ã§ã™ã€‚ *chars* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ "
"``None`` ã®å ´åˆã€ç©ºç™½æ–‡å­—ãŒé™¤å»ã•ã‚Œã¾ã™ã€‚ *chars* æ–‡å­—åˆ—ã¯æ¥å°¾èªã§ã¯ãªãã€ãã“ã«å«ã¾ã‚Œã‚‹æ–‡å­—ã®çµ„ã¿åˆã‚ã›å…¨ã¦ãŒã¯ãå–ã‚‰ã‚Œã¾ã™::"

#: ../../library/stdtypes.rst:1856
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"æ–‡å­—åˆ—ã‚’ *sep* ã‚’ãƒ‡ãƒªãƒŸã‚¿æ–‡å­—åˆ—ã¨ã—ã¦åŒºåˆ‡ã£ãŸå˜èªã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚*maxsplit* ãŒä¸ãˆã‚‰ã‚Œã¦ã„ã‚Œã°ã€æœ€å¤§ã§ *maxsplit* "
"å›åˆ†å‰²ã•ã‚Œã¾ã™ (ã¤ã¾ã‚Šã€ãƒªã‚¹ãƒˆã¯æœ€å¤§ ``maxsplit+1`` è¦ç´ ã«ãªã‚Šã¾ã™)ã€‚ *maxsplit* ãŒä¸ãˆã‚‰ã‚Œãªã„ã‹ ``-1`` "
"ãªã‚‰ã€åˆ†å‰²ã®å›æ•°ã«åˆ¶é™ã¯ã‚ã‚Šã¾ã›ã‚“ (å¯èƒ½ãªã ã‘åˆ†å‰²ã•ã‚Œã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:1862
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""
"*sep* ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€é€£ç¶šã—ãŸåŒºåˆ‡ã‚Šæ–‡å­—ã¯ã¾ã¨ã‚ã‚‰ã‚Œãšã€ç©ºã®æ–‡å­—åˆ—ã‚’åŒºåˆ‡ã£ã¦ã„ã‚‹ã¨åˆ¤æ–­ã•ã‚Œã¾ã™(ä¾‹ãˆã° "
"``'1,,2'.split(',')`` ã¯ ``['1', '', '2']`` ã‚’è¿”ã—ã¾ã™)ã€‚å¼•æ•° *sep* ã¯è¤‡æ•°ã®æ–‡å­—ã«ã‚‚ã§ãã¾ã™ (ä¾‹ãˆã°"
" ``'1<>2<>3'.split('<>')`` ã¯ ``['1', '2', '3']`` "
"ã‚’è¿”ã—ã¾ã™)ã€‚åŒºåˆ‡ã‚Šæ–‡å­—ã‚’æŒ‡å®šã—ã¦ç©ºã®æ–‡å­—åˆ—ã‚’åˆ†å‰²ã™ã‚‹ã¨ã€ ``['']`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1868 ../../library/stdtypes.rst:1884
#: ../../library/stdtypes.rst:1936 ../../library/stdtypes.rst:2004
#: ../../library/stdtypes.rst:2068 ../../library/stdtypes.rst:2810
#: ../../library/stdtypes.rst:2826 ../../library/stdtypes.rst:2917
#: ../../library/stdtypes.rst:2933 ../../library/stdtypes.rst:2948
#: ../../library/stdtypes.rst:2962 ../../library/stdtypes.rst:2990
#: ../../library/stdtypes.rst:3004 ../../library/stdtypes.rst:3022
#: ../../library/stdtypes.rst:3049 ../../library/stdtypes.rst:3072
#: ../../library/stdtypes.rst:3099 ../../library/stdtypes.rst:3141
#: ../../library/stdtypes.rst:3165
msgid "For example::"
msgstr "ä¾‹ãˆã°::"

#: ../../library/stdtypes.rst:1877
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is"
" applied: runs of consecutive whitespace are regarded as a single separator,"
" and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty"
" string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"*sep* ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ã‹ ``None`` "
"ã®å ´åˆã€ç•°ãªã‚‹åˆ†å‰²ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚é€£ç¶šã™ã‚‹ç©ºç™½æ–‡å­—ã¯ã²ã¨ã¤ã®ãƒ‡ãƒªãƒŸã‚¿ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚ã¾ãŸã€æ–‡å­—åˆ—ã®å…ˆé ­ã‚„æœ«å°¾ã«ç©ºç™½ãŒã‚ã£ã¦ã‚‚ã€çµæœã®æœ€åˆã‚„æœ€å¾Œã«ç©ºæ–‡å­—åˆ—ã¯å«ã¾ã‚Œã¾ã›ã‚“ã€‚ã‚ˆã£ã¦ã€ç©ºæ–‡å­—åˆ—ã‚„ç©ºç™½ã ã‘ã®æ–‡å­—åˆ—ã‚’"
" ``None`` ãƒ‡ãƒªãƒŸã‚¿ã§åˆ†å‰²ã™ã‚‹ã¨ ``[]`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1899
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line"
" breaks are not included in the resulting list unless *keepends* is given "
"and true."
msgstr "æ–‡å­—åˆ—ã‚’æ”¹è¡Œéƒ¨åˆ†ã§åˆ†è§£ã—ã€å„è¡Œã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ *keepends* ã«çœŸãŒä¸ãˆã‚‰ãªã„é™ã‚Šã€è¿”ã•ã‚Œã‚‹ãƒªã‚¹ãƒˆã«æ”¹è¡Œã¯å«ã¾ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:1903
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä»¥ä¸‹ã®è¡Œå¢ƒç•Œã§åˆ†è§£ã—ã¾ã™ã€‚ç‰¹ã«ã€ä»¥ä¸‹ã®å¢ƒç•Œã¯ :term:`universal newlines` ã®ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚»ãƒƒãƒˆã§ã™ã€‚"

#: ../../library/stdtypes.rst:1907
msgid "Representation"
msgstr "è¡¨ç¾"

#: ../../library/stdtypes.rst:1907
msgid "Description"
msgstr "èª¬æ˜"

#: ../../library/stdtypes.rst:1909
msgid "``\\n``"
msgstr "``\\n``"

#: ../../library/stdtypes.rst:1909
msgid "Line Feed"
msgstr "æ”¹è¡Œ"

#: ../../library/stdtypes.rst:1911
msgid "``\\r``"
msgstr "``\\r``"

#: ../../library/stdtypes.rst:1911
msgid "Carriage Return"
msgstr "å¾©å¸°"

#: ../../library/stdtypes.rst:1913
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../../library/stdtypes.rst:1913
msgid "Carriage Return + Line Feed"
msgstr "æ”¹è¡Œ + å¾©å¸°"

#: ../../library/stdtypes.rst:1915
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` or ``\\x0b``"

#: ../../library/stdtypes.rst:1915
msgid "Line Tabulation"
msgstr "å‚ç›´ã‚¿ãƒ–"

#: ../../library/stdtypes.rst:1917
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` or ``\\x0c``"

#: ../../library/stdtypes.rst:1917
msgid "Form Feed"
msgstr "æ”¹ãƒšãƒ¼ã‚¸"

#: ../../library/stdtypes.rst:1919
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../../library/stdtypes.rst:1919
msgid "File Separator"
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«åŒºåˆ‡ã‚Š"

#: ../../library/stdtypes.rst:1921
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../../library/stdtypes.rst:1921
msgid "Group Separator"
msgstr "ã‚°ãƒ«ãƒ¼ãƒ—åŒºåˆ‡ã‚Š"

#: ../../library/stdtypes.rst:1923
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../../library/stdtypes.rst:1923
msgid "Record Separator"
msgstr "ãƒ¬ã‚³ãƒ¼ãƒ‰åŒºåˆ‡ã‚Š"

#: ../../library/stdtypes.rst:1925
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../../library/stdtypes.rst:1925
msgid "Next Line (C1 Control Code)"
msgstr "æ”¹è¡Œ (C1 åˆ¶å¾¡ã‚³ãƒ¼ãƒ‰)"

#: ../../library/stdtypes.rst:1927
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../../library/stdtypes.rst:1927
msgid "Line Separator"
msgstr "è¡ŒåŒºåˆ‡ã‚Š"

#: ../../library/stdtypes.rst:1929
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../../library/stdtypes.rst:1929
msgid "Paragraph Separator"
msgstr "æ®µè½åŒºåˆ‡ã‚Š"

#: ../../library/stdtypes.rst:1934
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` ã¨ ``\\f`` ãŒè¡Œå¢ƒç•Œã®ãƒªã‚¹ãƒˆã«è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:1943
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break"
" does not result in an extra line::"
msgstr ""
":meth:`~str.split` ã¨ã¯é•ã£ã¦ã€ãƒ‡ãƒªãƒŸã‚¿æ–‡å­—åˆ— *sep* "
"ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ç©ºæ–‡å­—åˆ—ã«ç©ºãƒªã‚¹ãƒˆã‚’è¿”ã—ã€çµ‚æœ«ã®æ”¹è¡Œã¯çµæœã«è¡Œã‚’è¿½åŠ ã—ã¾ã›ã‚“::"

#: ../../library/stdtypes.rst:1952
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "æ¯”è¼ƒã®ãŸã‚ã« ``split('\\n')`` ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/stdtypes.rst:1962
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"æ–‡å­—åˆ—ãŒæŒ‡å®šã•ã‚ŒãŸ *prefix* ã§å§‹ã¾ã‚‹ãªã‚‰ ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™ã€‚ *prefix* "
"ã¯è¦‹ã¤ã‘ãŸã„è¤‡æ•°ã®æ¥é ­èªã®ã‚¿ãƒ—ãƒ«ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *start* ãŒã‚ã‚Œã°ã€ãã®ä½ç½®ã‹ã‚‰åˆ¤å®šã‚’å§‹ã‚ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *end* "
"ãŒã‚ã‚Œã°ã€ãã®ä½ç½®ã§æ¯”è¼ƒã‚’æ­¢ã‚ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:1970
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather,"
" all combinations of its values are stripped::"
msgstr ""
"æ–‡å­—åˆ—ã®å…ˆé ­ãŠã‚ˆã³æœ«å°¾éƒ¨åˆ†ã‚’é™¤å»ã—ãŸã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•° *chars* ã¯é™¤å»ã•ã‚Œã‚‹æ–‡å­—é›†åˆã‚’æŒ‡å®šã™ã‚‹æ–‡å­—åˆ—ã§ã™ã€‚ *chars* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ "
"``None`` ã®å ´åˆã€ç©ºç™½æ–‡å­—ãŒé™¤å»ã•ã‚Œã¾ã™ã€‚ *chars* "
"æ–‡å­—åˆ—ã¯æ¥é ­èªã§ã‚‚æ¥å°¾èªã§ã‚‚ãªãã€ãã“ã«å«ã¾ã‚Œã‚‹æ–‡å­—ã®çµ„ã¿åˆã‚ã›å…¨ã¦ãŒã¯ãå–ã‚‰ã‚Œã¾ã™::"

#: ../../library/stdtypes.rst:1981
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from"
" the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"æ–‡å­—åˆ—ã®æœ€ã‚‚å¤–å´ã®å…ˆé ­ãŠã‚ˆã³æœ«å°¾ã‹ã‚‰ã€å¼•æ•° *chars* å€¤ãŒã¯ãå–ã‚‰ã‚Œã¾ã™ã€‚æ–‡å­—åˆ—ã®å…ˆé ­ã‹ã‚‰ *chars* "
"ã®æ–‡å­—é›†åˆã«å«ã¾ã‚Œãªã„æ–‡å­—ã«é”ã™ã‚‹ã¾ã§ã€æ–‡å­—ãŒå‰Šé™¤ã•ã‚Œã¾ã™ã€‚æ–‡å­—åˆ—ã®æœ«å°¾ã«å¯¾ã—ã¦ã‚‚åŒæ§˜ã®æ“ä½œãŒè¡Œã‚ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/stdtypes.rst:1994
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase"
" and vice versa. Note that it is not necessarily true that "
"``s.swapcase().swapcase() == s``."
msgstr ""
"å¤§æ–‡å­—ãŒå°æ–‡å­—ã«ã€å°æ–‡å­—ãŒå¤§æ–‡å­—ã«å¤‰æ›ã•ã‚ŒãŸã€æ–‡å­—åˆ—ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ãªãŠã€ ``s.swapcase().swapcase() == s`` "
"ãŒçœŸã§ã‚ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2001
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr "æ–‡å­—åˆ—ã‚’ã€å˜èªã”ã¨ã«å¤§æ–‡å­—ã‹ã‚‰å§‹ã¾ã‚Šã€æ®‹ã‚Šã®æ–‡å­—ã®ã†ã¡å¤§å°æ–‡å­—ã®åŒºåˆ¥ãŒã‚ã‚‹ã‚‚ã®ã¯å…¨ã¦å°æ–‡å­—ã«ã™ã‚‹ã€ã‚¿ã‚¤ãƒˆãƒ«ã‚±ãƒ¼ã‚¹ã«ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2009 ../../library/stdtypes.rst:3109
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it"
" means that apostrophes in contractions and possessives form word "
"boundaries, which may not be the desired result::"
msgstr ""
"ã“ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€é€£ç¶šã—ãŸæ–‡å­—ã®é›†ã¾ã‚Šã¨ã„ã†ã€è¨€èªã‹ã‚‰ç‹¬ç«‹ã—ãŸå˜ç´”ãªå˜èªã®å®šç¾©ã‚’ä½¿ã„ã¾ã™ã€‚ã“ã®å®šç¾©ã¯å¤šãã®çŠ¶æ³ã§ã¯ã†ã¾ãæ©Ÿèƒ½ã—ã¾ã™ãŒã€çŸ­ç¸®å½¢ã‚„æ‰€æœ‰æ ¼ã®ã‚¢ãƒã‚¹ãƒˆãƒ­ãƒ•ã‚£ãŒå˜èªã®å¢ƒç•Œã«ãªã£ã¦ã—ã¾ã„ã€æœ›ã¿ã®çµæœã‚’å¾—ã‚‰ã‚Œãªã„å ´åˆãŒã‚ã‚Šã¾ã™::"

#: ../../library/stdtypes.rst:2017 ../../library/stdtypes.rst:3117
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr "æ­£è¦è¡¨ç¾ã‚’ä½¿ã†ã“ã¨ã§ã‚¢ãƒã‚¹ãƒˆãƒ­ãƒ•ã‚£ã«å¯¾å¿œã§ãã¾ã™::"

#: ../../library/stdtypes.rst:2032
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`__getitem__`, typically a :term:`mapping` or "
":term:`sequence`.  When indexed by a Unicode ordinal (an integer), the table"
" object can do any of the following: return a Unicode ordinal or a string, "
"to map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"ä¸ãˆã‚‰ã‚ŒãŸå¤‰æ›ãƒ†ãƒ¼ãƒ–ãƒ«ã«åŸºã¥ã„ã¦æ–‡å­—åˆ—ã‚’æ§‹æˆã™ã‚‹å„æ–‡å­—ã‚’ãƒãƒƒãƒ”ãƒ³ã‚°ã—ã€ãƒãƒƒãƒ”ãƒ³ã‚°å¾Œã®æ–‡å­—åˆ—ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å¤‰æ›ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã€:meth:`__getitem__`"
" ã«ã‚ˆã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã‚’å®Ÿè£…ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¸€èˆ¬çš„ã«ã¯ã€ :term:`mapping` ã¾ãŸã¯ "
":term:`sequence` ã§ã™ã€‚Unicode åºæ•° (æ•´æ•°) "
"ã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã™ã‚‹å ´åˆã€å¤‰æ›ãƒ†ãƒ¼ãƒ–ãƒ«ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ¬¡ã®ã„ãšã‚Œã‚‚è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚Unicode åºæ•°ã¾ãŸã¯æ–‡å­—åˆ—ã‚’è¿”ã—ã¦æ–‡å­—ã‚’ 1 "
"æ–‡å­—ä»¥ä¸Šã®åˆ¥ã®æ–‡å­—ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ã“ã¨ã€``None`` ã‚’è¿”ã—ã¦è¿”ã‚Šå€¤ã®æ–‡å­—åˆ—ã‹ã‚‰æŒ‡å®šã—ãŸæ–‡å­—ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã€ä¾‹å¤– "
":exc:`LookupError` ã‚’é€å‡ºã—ã¦æ–‡å­—ã‚’ãã®æ–‡å­—è‡ªèº«ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ã“ã¨ã€‚"

#: ../../library/stdtypes.rst:2041
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from "
"character-to-character mappings in different formats."
msgstr "æ–‡å­—ã‹ã‚‰æ–‡å­—ã¸ã®ç•°ãªã‚‹å½¢å¼ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‹ã‚‰å¤‰æ›ãƒãƒƒãƒ—ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ã€ :meth:`str.maketrans` ãŒä½¿ãˆã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2044
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr "æ–‡å­—ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’å¥½ã¿ã«åˆã‚ã›ã¦ã‚ˆã‚ŠæŸ”è»Ÿã«å¤‰æ›´ã™ã‚‹æ–¹æ³•ã«ã¤ã„ã¦ã¯ã€:mod:`codecs` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2050
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""

#: ../../library/stdtypes.rst:2056
msgid ""
"The uppercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr "ä½¿ã‚ã‚Œã‚‹å¤§æ–‡å­—åŒ–ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ Unicode Standard ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ 3.13 ã«è¨˜è¿°ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2062
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled"
" by inserting the padding *after* the sign character rather than before. The"
" original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"é•·ã•ãŒ *width* ã«ãªã‚‹ã‚ˆã† ASCII ``'0'`` ã§å·¦è©°ã‚ã—ãŸæ–‡å­—åˆ—ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å…ˆé ­ãŒç¬¦å·æ¥é ­è¾ "
"(``'+'``/``'-'``) ã ã£ãŸå ´åˆã€ ``'0'`` ã¯ç¬¦å·ã®å‰ã§ã¯ãªã *å¾Œ* ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚*width* ãŒ ``len(s)`` "
"ä»¥ä¸‹ã®å ´åˆå…ƒã®æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2080
msgid "``printf``-style String Formatting"
msgstr "``printf`` å½¢å¼ã®æ–‡å­—åˆ—æ›¸å¼åŒ–"

#: ../../library/stdtypes.rst:2094
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals "
"<f-strings>` or the :meth:`str.format` interface helps avoid these errors.  "
"These alternatives also provide more powerful, flexible and extensible "
"approaches to formatting text."
msgstr ""
"ã“ã“ã§è¿°ã¹ã‚‹æ›¸å¼åŒ–æ¼”ç®—ã«ã¯æ§˜ã€…ãªç™–ãŒã‚ã‚Šã€ã‚ˆãé–“é•ã„ã®å…ƒã«ãªã£ã¦ã„ã¾ã™ (ã‚¿ãƒ—ãƒ«ã‚„è¾æ›¸ã‚’æ­£ã—ãè¡¨ç¤ºã§ããªã„ãªã©)ã€‚æ–°ã—ã„ "
":ref:`ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ« <f-strings>` ã‚„ :meth:`str.format` "
"ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã®æ–¹ãŒé–“é•ã„ã«ããã€ã‚ˆã‚Šå¼·åŠ›ã§ã€æŸ”è»Ÿã§ã€ã•ã‚‰ã«æ‹¡å¼µå¯èƒ½ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2101
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""
"æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯å›ºæœ‰ã®æ“ä½œ: ``%`` æ¼”ç®—å­ (ãƒ¢ã‚¸ãƒ¥ãƒ­) ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®æ¼”ç®—å­ã¯æ–‡å­—åˆ— *æ›¸å¼åŒ–* ã¾ãŸã¯ *è£œé–“* "
"æ¼”ç®—å­ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚``format % values`` (*format* ã¯æ–‡å­—åˆ—) ã¨ã™ã‚‹ã¨ã€*format* ä¸­ã® ``%`` å¤‰æ›æŒ‡å®šã¯ "
"*values* ä¸­ã®ã‚¼ãƒ­å€‹ã¾ãŸã¯ãã‚Œä»¥ä¸Šã®è¦ç´ ã§ç½®æ›ã•ã‚Œã¾ã™ã€‚ã“ã®å‹•ä½œã¯ C è¨€èªã«ãŠã‘ã‚‹ :c:func:`sprintf` ã«ä¼¼ã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2107
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of"
" items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"*format* ãŒå˜ä¸€ã®å¼•æ•°ã—ã‹è¦æ±‚ã—ãªã„å ´åˆã€ *values* ã¯ã‚¿ãƒ—ãƒ«ã§ãªã„å˜ä¸€ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚ [5]_ ãã‚Œä»¥å¤–ã®å ´åˆã€ "
"*values* ã¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ä¸­ã§æŒ‡å®šã•ã‚ŒãŸé …ç›®ã¨æ­£ç¢ºã«åŒã˜æ•°ã®è¦ç´ ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã‹ã€å˜ä¸€ã®ãƒãƒƒãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2112 ../../library/stdtypes.rst:3216
msgid ""
"A conversion specifier contains two or more characters and has the following"
" components, which must occur in this order:"
msgstr "ä¸€ã¤ã®å¤‰æ›æŒ‡å®šå­ã¯ 2 ã¾ãŸã¯ãã‚Œä»¥ä¸Šã®æ–‡å­—ã‚’å«ã¿ã€ãã®æ§‹æˆè¦ç´ ã¯ä»¥ä¸‹ã‹ã‚‰ãªã‚Šã¾ã™ãŒã€ç¤ºã—ãŸé †ã«å‡ºç¾ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“:"

#: ../../library/stdtypes.rst:2115 ../../library/stdtypes.rst:3219
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "æŒ‡å®šå­ã®é–‹å§‹ã‚’ç¤ºã™æ–‡å­— ``'%'`` ã€‚"

#: ../../library/stdtypes.rst:2117 ../../library/stdtypes.rst:3221
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters"
" (for example, ``(somename)``)."
msgstr "ãƒãƒƒãƒ—ã‚­ãƒ¼ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)ã€‚ä¸¸æ‹¬å¼§ã§å›²ã£ãŸæ–‡å­—åˆ—ã‹ã‚‰ãªã‚Šã¾ã™ (ä¾‹ãˆã° ``(somename)``) ã€‚"

#: ../../library/stdtypes.rst:2120 ../../library/stdtypes.rst:3224
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr "å¤‰æ›ãƒ•ãƒ©ã‚° (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)ã€‚ä¸€éƒ¨ã®å¤‰æ›å‹ã®çµæœã«å½±éŸ¿ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2123 ../../library/stdtypes.rst:3227
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the"
" object to convert comes after the minimum field width and optional "
"precision."
msgstr ""
"æœ€å°ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¹… (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)ã€‚ ``'*'`` (ã‚¢ã‚¹ã‚¿ãƒªã‚¹ã‚¯) ã‚’æŒ‡å®šã—ãŸå ´åˆã€å®Ÿéš›ã®æ–‡å­—åˆ—å¹…ãŒ *values* "
"ã‚¿ãƒ—ãƒ«ã®æ¬¡ã®è¦ç´ ã‹ã‚‰èª­ã¿å‡ºã•ã‚Œã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã«ã¯æœ€å°ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¹…ã‚„ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ç²¾åº¦æŒ‡å®šã®å¾Œã«å¤‰æ›ã—ãŸã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2127 ../../library/stdtypes.rst:3231
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the"
" next element of the tuple in *values*, and the value to convert comes after"
" the precision."
msgstr ""
"ç²¾åº¦ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)ã€‚ ``'.'`` (ãƒ‰ãƒƒãƒˆ) ã¨ãã®å¾Œã«ç¶šãç²¾åº¦ã§ä¸ãˆã‚‰ã‚Œã¾ã™ã€‚ ``'*'`` (ã‚¢ã‚¹ã‚¿ãƒªã‚¹ã‚¯) ã‚’æŒ‡å®šã—ãŸå ´åˆã€ç²¾åº¦ã®æ¡æ•°ã¯ "
"*values* ã‚¿ãƒ—ãƒ«ã®æ¬¡ã®è¦ç´ ã‹ã‚‰èª­ã¿å‡ºã•ã‚Œã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã«ã¯ç²¾åº¦æŒ‡å®šã®å¾Œã«å¤‰æ›ã—ãŸã„å€¤ãŒãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2132 ../../library/stdtypes.rst:3236
msgid "Length modifier (optional)."
msgstr "ç²¾åº¦é•·å¤‰æ›å­ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)ã€‚"

#: ../../library/stdtypes.rst:2134 ../../library/stdtypes.rst:3238
msgid "Conversion type."
msgstr "å¤‰æ›å‹ã€‚"

#: ../../library/stdtypes.rst:2136
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key"
" selects the value to be formatted from the mapping.  For example:"
msgstr ""
"``%`` æ¼”ç®—å­ã®å³å´ã®å¼•æ•°ãŒè¾æ›¸ã®å ´åˆ (ã¾ãŸã¯ãã®ä»–ã®ãƒãƒƒãƒ—å‹ã®å ´åˆ), æ–‡å­—åˆ—ä¸­ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ã¯ã€è¾æ›¸ã«æŒ¿å…¥ã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¼ã‚’ä¸¸æ‹¬å¼§ã§å›²ã„ã€æ–‡å­—"
" ``'%'`` ã®ç›´å¾Œã«ãã‚‹ã‚ˆã†ã«ã—ãŸã‚‚ã®ãŒå«ã¾ã‚Œã¦ã„ãªã‘ã‚Œã° *ãªã‚Šã¾ã›ã‚“* ã€‚ãƒãƒƒãƒ—ã‚­ãƒ¼ã¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆåŒ–ã—ãŸã„å€¤ã‚’ãƒãƒƒãƒ—ã‹ã‚‰é¸ã³å‡ºã—ã¾ã™ã€‚ä¾‹ãˆã°:"

#: ../../library/stdtypes.rst:2145 ../../library/stdtypes.rst:3249
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a"
" sequential parameter list)."
msgstr "ã“ã®å ´åˆã€ ``*`` æŒ‡å®šå­ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å«ã‚ã¦ã¯ã„ã‘ã¾ã›ã‚“ (``*`` æŒ‡å®šå­ã¯é †ç•ªä»˜ã‘ã•ã‚ŒãŸãƒ‘ãƒ©ãƒ¡ã‚¿ã®ãƒªã‚¹ãƒˆãŒå¿…è¦ã ã‹ã‚‰ã§ã™)ã€‚"

#: ../../library/stdtypes.rst:2148 ../../library/stdtypes.rst:3252
msgid "The conversion flag characters are:"
msgstr "å¤‰æ›ãƒ•ãƒ©ã‚°æ–‡å­—ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™:"

#: ../../library/stdtypes.rst:2151 ../../library/stdtypes.rst:3255
msgid "Flag"
msgstr "Flag"

#: ../../library/stdtypes.rst:2153 ../../library/stdtypes.rst:3257
msgid "``'#'``"
msgstr "``'#'``"

#: ../../library/stdtypes.rst:2153 ../../library/stdtypes.rst:3257
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr "å€¤ã®å¤‰æ›ã« (ä¸‹ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹) \"åˆ¥ã®å½¢å¼\" ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2156 ../../library/stdtypes.rst:3260
msgid "``'0'``"
msgstr "``'0'``"

#: ../../library/stdtypes.rst:2156 ../../library/stdtypes.rst:3260
msgid "The conversion will be zero padded for numeric values."
msgstr "æ•°å€¤å‹ã«å¯¾ã—ã¦ã‚¼ãƒ­ã«ã‚ˆã‚‹ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2158 ../../library/stdtypes.rst:3262
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/stdtypes.rst:2158 ../../library/stdtypes.rst:3262
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr "å¤‰æ›ã•ã‚ŒãŸå€¤ã‚’å·¦å¯„ã›ã«ã—ã¾ã™ (``'0'`` ã¨åŒæ™‚ã«ä¸ãˆãŸå ´åˆã€ ``'0'`` ã‚’ä¸Šæ›¸ãã—ã¾ã™) ã€‚"

#: ../../library/stdtypes.rst:2161 ../../library/stdtypes.rst:3265
msgid "``' '``"
msgstr "``' '``"

#: ../../library/stdtypes.rst:2161 ../../library/stdtypes.rst:3265
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr "(ã‚¹ãƒšãƒ¼ã‚¹) ç¬¦å·ä»˜ãã®å¤‰æ›ã§æ­£ã®æ•°ã®å ´åˆã€å‰ã«ä¸€ã¤ã‚¹ãƒšãƒ¼ã‚¹ã‚’ç©ºã‘ã¾ã™ (ãã†ã§ãªã„å ´åˆã¯ç©ºæ–‡å­—ã«ãªã‚Šã¾ã™) ã€‚"

#: ../../library/stdtypes.rst:2164 ../../library/stdtypes.rst:3268
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/stdtypes.rst:2164 ../../library/stdtypes.rst:3268
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides"
" a \"space\" flag)."
msgstr "å¤‰æ›ã®å…ˆé ­ã«ç¬¦å·æ–‡å­— (``'+'`` ã¾ãŸã¯ ``'-'``) ã‚’ä»˜ã‘ã¾ã™(\"ã‚¹ãƒšãƒ¼ã‚¹\" ãƒ•ãƒ©ã‚°ã‚’ä¸Šæ›¸ãã—ã¾ã™) ã€‚"

#: ../../library/stdtypes.rst:2168 ../../library/stdtypes.rst:3272
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as"
" it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"ç²¾åº¦é•·å¤‰æ›å­(``h``, ``l``,ã¾ãŸã¯ ``L``) ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ãŒã€ Python ã§ã¯å¿…è¦ãªã„ãŸã‚ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ -- "
"ã¤ã¾ã‚Šã€ä¾‹ãˆã° ``%ld`` ã¯ ``%d`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2171 ../../library/stdtypes.rst:3275
msgid "The conversion types are:"
msgstr "å¤‰æ›å‹ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™:"

#: ../../library/stdtypes.rst:2174 ../../library/stdtypes.rst:3278
msgid "Conversion"
msgstr "å¤‰æ›"

#: ../../library/stdtypes.rst:2176 ../../library/stdtypes.rst:3280
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/stdtypes.rst:2176 ../../library/stdtypes.rst:2178
#: ../../library/stdtypes.rst:3280 ../../library/stdtypes.rst:3282
msgid "Signed integer decimal."
msgstr "ç¬¦å·ä»˜ã 10 é€²æ•´æ•°ã€‚"

#: ../../library/stdtypes.rst:2178 ../../library/stdtypes.rst:3282
msgid "``'i'``"
msgstr "``'i'``"

#: ../../library/stdtypes.rst:2180 ../../library/stdtypes.rst:3284
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/stdtypes.rst:2180 ../../library/stdtypes.rst:3284
msgid "Signed octal value."
msgstr "ç¬¦å·ä»˜ã 8 é€²æ•°ã€‚"

#: ../../library/stdtypes.rst:2182 ../../library/stdtypes.rst:3286
msgid "``'u'``"
msgstr "``'u'``"

#: ../../library/stdtypes.rst:2182 ../../library/stdtypes.rst:3286
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "æ—§å¼ã®å‹ -- ``'d'`` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2184 ../../library/stdtypes.rst:3288
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/stdtypes.rst:2184 ../../library/stdtypes.rst:3288
msgid "Signed hexadecimal (lowercase)."
msgstr "ç¬¦å·ä»˜ã 16 é€²æ•° (å°æ–‡å­—)ã€‚"

#: ../../library/stdtypes.rst:2186 ../../library/stdtypes.rst:3290
msgid "``'X'``"
msgstr "``'X'``"

#: ../../library/stdtypes.rst:2186 ../../library/stdtypes.rst:3290
msgid "Signed hexadecimal (uppercase)."
msgstr "ç¬¦å·ä»˜ã 16 é€²æ•° (å¤§æ–‡å­—)ã€‚"

#: ../../library/stdtypes.rst:2188 ../../library/stdtypes.rst:3292
msgid "``'e'``"
msgstr "``'e'``"

#: ../../library/stdtypes.rst:2188 ../../library/stdtypes.rst:3292
msgid "Floating point exponential format (lowercase)."
msgstr "æŒ‡æ•°è¡¨è¨˜ã®æµ®å‹•å°æ•°ç‚¹æ•° (å°æ–‡å­—)ã€‚"

#: ../../library/stdtypes.rst:2190 ../../library/stdtypes.rst:3294
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/stdtypes.rst:2190 ../../library/stdtypes.rst:3294
msgid "Floating point exponential format (uppercase)."
msgstr "æŒ‡æ•°è¡¨è¨˜ã®æµ®å‹•å°æ•°ç‚¹æ•° (å¤§æ–‡å­—)ã€‚"

#: ../../library/stdtypes.rst:2192 ../../library/stdtypes.rst:3296
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/stdtypes.rst:2192 ../../library/stdtypes.rst:2194
#: ../../library/stdtypes.rst:3296 ../../library/stdtypes.rst:3298
msgid "Floating point decimal format."
msgstr "10 é€²æµ®å‹•å°æ•°ç‚¹æ•°ã€‚"

#: ../../library/stdtypes.rst:2194 ../../library/stdtypes.rst:3298
msgid "``'F'``"
msgstr "``'F'``"

#: ../../library/stdtypes.rst:2196 ../../library/stdtypes.rst:3300
msgid "``'g'``"
msgstr "``'g'``"

#: ../../library/stdtypes.rst:2196 ../../library/stdtypes.rst:3300
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less"
" than -4 or not less than precision, decimal format otherwise."
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã€‚æŒ‡æ•°éƒ¨ãŒ -4 ä»¥ä¸Šã¾ãŸã¯ç²¾åº¦ä»¥ä¸‹ã®å ´åˆã«ã¯å°æ–‡å­—æŒ‡æ•°è¡¨è¨˜ã€ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯10é€²è¡¨è¨˜ã€‚"

#: ../../library/stdtypes.rst:2200 ../../library/stdtypes.rst:3304
msgid "``'G'``"
msgstr "``'G'``"

#: ../../library/stdtypes.rst:2200 ../../library/stdtypes.rst:3304
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less"
" than -4 or not less than precision, decimal format otherwise."
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã€‚æŒ‡æ•°éƒ¨ãŒ -4 ä»¥ä¸Šã¾ãŸã¯ç²¾åº¦ä»¥ä¸‹ã®å ´åˆã«ã¯å¤§æ–‡å­—æŒ‡æ•°è¡¨è¨˜ã€ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯10é€²è¡¨è¨˜ã€‚"

#: ../../library/stdtypes.rst:2204 ../../library/stdtypes.rst:3308
msgid "``'c'``"
msgstr "``'c'``"

#: ../../library/stdtypes.rst:2204
msgid "Single character (accepts integer or single character string)."
msgstr "æ–‡å­—ä¸€æ–‡å­— (æ•´æ•°ã¾ãŸã¯ä¸€æ–‡å­—ã‹ã‚‰ãªã‚‹æ–‡å­—åˆ—ã‚’å—ç†ã—ã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:2207 ../../library/stdtypes.rst:3321
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/stdtypes.rst:2207
msgid "String (converts any Python object using :func:`repr`)."
msgstr "æ–‡å­—åˆ— (Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :func:`repr` ã§å¤‰æ›ã—ã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:2210 ../../library/stdtypes.rst:3315
msgid "``'s'``"
msgstr "``'s'``"

#: ../../library/stdtypes.rst:2210
msgid "String (converts any Python object using :func:`str`)."
msgstr "æ–‡å­—åˆ— (Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :func:`str` ã§å¤‰æ›ã—ã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:2213 ../../library/stdtypes.rst:3318
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/stdtypes.rst:2213
msgid "String (converts any Python object using :func:`ascii`)."
msgstr "æ–‡å­—åˆ— (Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :func:`ascii` ã§å¤‰æ›ã—ã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:2216 ../../library/stdtypes.rst:3324
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/stdtypes.rst:2216 ../../library/stdtypes.rst:3324
msgid ""
"No argument is converted, results in a ``'%'`` character in the result."
msgstr "å¼•æ•°ã‚’å¤‰æ›ã›ãšã€è¿”ã•ã‚Œã‚‹æ–‡å­—åˆ—ä¸­ã§ã¯æ–‡å­— ``'%'`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2223 ../../library/stdtypes.rst:3331
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""
"åˆ¥ã®å½¢å¼ã‚’æŒ‡å®šï¼ˆè¨³æ³¨: å¤‰æ›ãƒ•ãƒ©ã‚° ``#`` ã‚’ä½¿ç”¨ï¼‰ã™ã‚‹ã¨ 8 é€²æ•°ã‚’è¡¨ã™æ¥é ­è¾ (``'0o'``) ãŒæœ€åˆã®æ•°å­—ã®å‰ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2227 ../../library/stdtypes.rst:3335
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"åˆ¥ã®å½¢å¼ã‚’æŒ‡å®šï¼ˆè¨³æ³¨: å¤‰æ›ãƒ•ãƒ©ã‚° ``#`` ã‚’ä½¿ç”¨ï¼‰ã™ã‚‹ã¨ 16 é€²æ•°ã‚’è¡¨ã™æ¥é ­è¾ ``'0x'`` ã¾ãŸã¯ ``'0X'`` "
"(ä½¿ç”¨ã™ã‚‹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—ãŒ ``'x'`` ã‹ ``'X'`` ã«ä¾å­˜ã—ã¾ã™) ãŒæœ€åˆã®æ•°å­—ã®å‰ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2231 ../../library/stdtypes.rst:3339
msgid ""
"The alternate form causes the result to always contain a decimal point, even"
" if no digits follow it."
msgstr "ã“ã®å½¢å¼ã«ã—ãŸå ´åˆã€å¤‰æ›çµæœã«ã¯å¸¸ã«å°æ•°ç‚¹ãŒå«ã¾ã‚Œã€ãã‚Œã¯ãã®å¾Œã‚ã«æ•°å­—ãŒç¶šã‹ãªã„å ´åˆã«ã‚‚é©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2234 ../../library/stdtypes.rst:3342
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr "æŒ‡å®šç²¾åº¦ã¯å°æ•°ç‚¹ã®å¾Œã®æ¡æ•°ã‚’æ±ºå®šã—ã€ãã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ 6 ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2238 ../../library/stdtypes.rst:3346
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr "ã“ã®å½¢å¼ã«ã—ãŸå ´åˆã€å¤‰æ›çµæœã«ã¯å¸¸ã«å°æ•°ç‚¹ãŒå«ã¾ã‚Œä»–ã®å½¢å¼ã¨ã¯é•ã£ã¦æœ«å°¾ã® 0 ã¯å–ã‚Šé™¤ã‹ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2241 ../../library/stdtypes.rst:3349
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr "æŒ‡å®šç²¾åº¦ã¯å°æ•°ç‚¹ã®å‰å¾Œã®æœ‰åŠ¹æ¡æ•°ã‚’æ±ºå®šã—ã€ãã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ 6 ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2245 ../../library/stdtypes.rst:3353
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "ç²¾åº¦ãŒ ``N`` ãªã‚‰ã€å‡ºåŠ›ã¯ ``N`` æ–‡å­—ã«åˆ‡ã‚Šè©°ã‚ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2248 ../../library/stdtypes.rst:3362
msgid "See :pep:`237`."
msgstr ":pep:`237` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2250
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr "Python æ–‡å­—åˆ—ã«ã¯æ˜ç¤ºçš„ãªé•·ã•æƒ…å ±ãŒã‚ã‚‹ã®ã§ã€ ``%s`` å¤‰æ›ã«ãŠã„ã¦ ``'\\0'`` ã‚’æ–‡å­—åˆ—ã®æœ«ç«¯ã¨ä»®å®šã—ãŸã‚Šã¯ã—ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2255
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr "çµ¶å¯¾å€¤ãŒ 1e50 ã‚’è¶…ãˆã‚‹æ•°å€¤ã® ``%f`` å¤‰æ›ãŒ ``%g`` å¤‰æ›ã«ç½®ãæ›ãˆã‚‰ã‚Œãªããªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:2266
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, "
":class:`memoryview`"
msgstr ""
"ãƒã‚¤ãƒŠãƒªã‚·ãƒ¼ã‚±ãƒ³ã‚¹å‹ --- :class:`bytes`, :class:`bytearray`, :class:`memoryview`"

#: ../../library/stdtypes.rst:2274
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and "
":class:`bytearray`. They are supported by :class:`memoryview` which uses the"
" :ref:`buffer protocol <bufferobjects>` to access the memory of other binary"
" objects without needing to make a copy."
msgstr ""
"ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ã‚³ã‚¢çµ„ã¿è¾¼ã¿å‹ã¯ :class:`bytes` ãŠã‚ˆã³ :class:`bytearray` "
"ã§ã™ã€‚ã“ã‚Œã‚‰ã¯ã€åˆ¥ã®ãƒã‚¤ãƒŠãƒªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ãƒ¢ãƒªã«ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆã™ã‚‹ã“ã¨ç„¡ãã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã® :ref:`ãƒãƒƒãƒ•ã‚¡ãƒ—ãƒ­ãƒˆã‚³ãƒ« "
"<bufferobjects>` ã‚’åˆ©ç”¨ã™ã‚‹ :class:`memoryview` ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2279
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""
":mod:`array` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€32 ãƒ“ãƒƒãƒˆæ•´æ•°ã‚„ IEEE754 å€ç²¾åº¦æµ®å‹•å°æ•°ç‚¹å€¤ã®ã‚ˆã†ãªåŸºæœ¬ãƒ‡ãƒ¼ã‚¿å‹ã®ã€åŠ¹ç‡çš„ãªä¿å­˜ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2285
msgid "Bytes Objects"
msgstr "ãƒã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:2289
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"bytes ã¯ãƒã‚¤ãƒˆã®ä¸å¤‰ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã™ã€‚å¤šãã®ãƒ¡ã‚¸ãƒ£ãƒ¼ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒASCIIãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ãƒ™ãƒ¼ã‚¹ã«ã—ã¦ã„ã‚‹ã®ã§ã€ bytes "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ ASCII äº’æ›ã®ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã®ã¿å‹•ä½œã™ã‚‹å¹¾ã¤ã‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¦ã„ã¦ã€æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ä»–ã®å¤šãã®ç‚¹ã§è¿‘ã„ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2296
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr "ã¾ãšã€ bytes ãƒªãƒ†ãƒ©ãƒ«ã®æ§‹æ–‡ã¯æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¨ã»ã¼åŒã˜ã§ã€ ``b`` ã¨ã„ã†ãƒ—ãƒªãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’ä»˜ã‘ã¾ã™:"

#: ../../library/stdtypes.rst:2299
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr "ã‚·ãƒ³ã‚°ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆ: ``b'still allows embedded \"double\" quotes'``"

#: ../../library/stdtypes.rst:2300
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``."
msgstr "ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆ: ``b\"still allows embedded 'single' quotes\"``."

#: ../../library/stdtypes.rst:2301
msgid "Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr "3é‡ã‚¯ã‚©ãƒ¼ãƒˆ: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"

#: ../../library/stdtypes.rst:2303
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"bytes ãƒªãƒ†ãƒ©ãƒ«ã§ã¯ (ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«é–¢ä¿‚ãªã) ASCIIæ–‡å­—ã®ã¿ãŒè¨±å¯ã•ã‚Œã¦ã„ã¾ã™ã€‚ 127ã‚ˆã‚Šå¤§ãã„å€¤ã‚’ bytes "
"ãƒªãƒ†ãƒ©ãƒ«ã«è¨˜è¿°ã™ã‚‹å ´åˆã¯é©åˆ‡ãªã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’æ›¸ãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2307
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¨åŒã˜ãã€ bytes ãƒªãƒ†ãƒ©ãƒ«ã§ã‚‚ ``r`` ãƒ—ãƒªãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’ç”¨ã„ã¦ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å‡¦ç†ã‚’ç„¡åŠ¹ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ bytes"
" ãƒªãƒ†ãƒ©ãƒ«ã®æ§˜ã€…ãªå½¢å¼ã‚„ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ã¤ã„ã¦ã¯ :ref:`strings` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2311
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based"
" elements and can be usefully manipulated with some text-oriented "
"algorithms, this is not generally the case for arbitrary binary data "
"(blindly applying text processing algorithms to binary data formats that are"
" not ASCII compatible will usually lead to data corruption)."
msgstr ""

#: ../../library/stdtypes.rst:2321
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr "ãƒªãƒ†ãƒ©ãƒ«ä»¥å¤–ã«ã€å¹¾ã¤ã‹ã®æ–¹æ³•ã§ bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚‹ã“ã¨ãŒã§ãã¾ã™:"

#: ../../library/stdtypes.rst:2324
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr "æŒ‡å®šã•ã‚ŒãŸé•·ã•ã®ã€0ã§åŸ‹ã‚ã‚‰ã‚ŒãŸ bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ: ``bytes(10)``"

#: ../../library/stdtypes.rst:2325
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "æ•´æ•°ã® iterable ã‹ã‚‰: ``bytes(range(20))``"

#: ../../library/stdtypes.rst:2326
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr "æ—¢å­˜ã®ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒãƒƒãƒ•ã‚¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã‚³ãƒ”ãƒ¼ã™ã‚‹: ``bytes(obj)``"

#: ../../library/stdtypes.rst:2328
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr ":ref:`bytes <func-bytes>` ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•°ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2330
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"16 é€²æ•°ã§ 2 æ¡ã®æ•°ã¯æ­£ç¢ºã« 1 ãƒã‚¤ãƒˆã«ç›¸å½“ã™ã‚‹ãŸã‚ã€16 é€²æ•´ã¯ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¾ã™ã‚‹å½¢å¼ã¨ã—ã¦åºƒãä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ å¾“ã£ã¦ã€ bytes "
"å‹ã«ã¯ãã®å½¢å¼ã§ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å–ã‚‹ãŸã‚ã®è¿½åŠ ã®ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2336
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"ã“ã® :class:`bytes` ã®ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã¦ bytes "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œãã‚Œã®ãƒã‚¤ãƒˆã‚’ 16 é€²æ•° 2 æ¡ã§è¡¨ç¾ã—ãŸæ–‡å­—åˆ—ã‚’æŒ‡å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ASCII ç©ºç™½æ–‡å­—ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2343
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr "bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãã® 16 é€²è¡¨è¨˜ã«å¤‰æ›ã™ã‚‹ãŸã‚ã®ã€åå¯¾å‘ãã®å¤‰æ›é–¢æ•°ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2348 ../../library/stdtypes.rst:2420
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å†…ã® 1 ãƒã‚¤ãƒˆã«ã¤ã 2 ã¤ã® 16 é€²æ•°ã‚’å«ã‚€ã€æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2356
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes"
" object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ (ã‚¿ãƒ—ãƒ«ã«ä¼¼ãŸ) æ•´æ•°ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãªã®ã§ã€ bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *b* ã«ã¤ã„ã¦ã€ ``b[0]`` ã¯æ•´æ•°ã«ãªã‚Šã€ "
"``b[0:1]`` ã¯é•·ã• 1 ã® bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚ (ã“ã®å‹•ä½œã¯ã€æ–‡å­—åˆ—ã«å¯¾ã™ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã‚‚ã‚¹ãƒ©ã‚¤ã‚¹ã‚‚é•·ã• 1 "
"ã®æ–‡å­—åˆ—ã‚’è¿”ã™ã®ã¨å¯¾ç…§çš„ã§ã™ã€‚)"

#: ../../library/stdtypes.rst:2361
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® repr å‡ºåŠ›ã¯ãƒªãƒ†ãƒ©ãƒ«å½¢å¼ (``b'...'``) ã«ãªã‚Šã¾ã™ã€‚ ``bytes([46, 46, 46])`` "
"ãªã©ã®å½¢å¼ã‚ˆã‚Šã‚‚ä¾¿åˆ©ãªäº‹ãŒå¤šã„ã‹ã‚‰ã§ã™ã€‚ bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã„ã¤ã§ã‚‚ ``list(b)`` ã§æ•´æ•°ã®ãƒªã‚¹ãƒˆã«å¤‰æ›ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2366
msgid ""
"For Python 2.x users: In the Python 2.x series, a variety of implicit "
"conversions between 8-bit strings (the closest thing 2.x offers to a built-"
"in binary data type) and Unicode strings were permitted. This was a "
"backwards compatibility workaround to account for the fact that Python "
"originally only supported 8-bit text, and Unicode text was a later addition."
" In Python 3.x, those implicit conversions are gone - conversions between "
"8-bit binary data and Unicode text must be explicit, and bytes and string "
"objects will always compare unequal."
msgstr ""
"Python 2.x ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸: Python 2.x ã§ã¯å¤šãã®å ´é¢ã§ 8bit æ–‡å­—åˆ— (2.x ãŒæä¾›ã—ã¦ã„ã‚‹ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã®ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿å‹) ã¨"
" Unicode æ–‡å­—åˆ—ã®é–“ã®æš—é»™ã®å¤‰æ›ãŒè¨±å¯ã•ã‚Œã¦ã„ã¾ã—ãŸã€‚ã“ã‚Œã¯ Python ãŒã‚‚ã¨ã‚‚ã¨ 8bit æ–‡å­—åˆ—ã—ã‹æŒã£ã¦ã„ãªãã¦ã€ã‚ã¨ã‹ã‚‰ "
"Unicode ãƒ†ã‚­ã‚¹ãƒˆãŒè¿½åŠ ã•ã‚ŒãŸã®ã§ã€å¾Œæ–¹äº’æ›æ€§ã‚’ç¶­æŒã™ã‚‹ãŸã‚ã®ãƒ¯ãƒ¼ã‚¯ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰ã§ã—ãŸã€‚ Python 3.x "
"ã§ã¯ã“ã‚Œã‚‰ã®æš—é»™ã®å¤‰æ›ã¯ãªããªã‚Šã¾ã—ãŸã€‚ 8-bit ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã¨ Unicode ãƒ†ã‚­ã‚¹ãƒˆã¯æ˜ç¢ºã«é•ã†ã‚‚ã®ã§ã€ bytes "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¯”è¼ƒã™ã‚‹ã¨å¸¸ã«ç­‰ã—ããªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2379
msgid "Bytearray Objects"
msgstr "bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:2383
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ":class:`bytearray` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¯å¤‰ãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2388
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are"
" always created by calling the constructor:"
msgstr "bytearray ã«å°‚ç”¨ã®ãƒªãƒ†ãƒ©ãƒ«æ§‹æ–‡ã¯ãªã„ã®ã§ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½¿ã£ã¦ä½œæˆã—ã¾ã™:"

#: ../../library/stdtypes.rst:2391
msgid "Creating an empty instance: ``bytearray()``"
msgstr "ç©ºã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚‹: ``bytearray()``"

#: ../../library/stdtypes.rst:2392
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr "æŒ‡å®šã•ã‚ŒãŸé•·ã•ã®0ã§åŸ‹ã‚ã‚‰ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚‹: ``bytearray(10)``"

#: ../../library/stdtypes.rst:2393
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "æ•´æ•°ã® iterable ã‹ã‚‰: ``bytearray(range(20))``"

#: ../../library/stdtypes.rst:2394
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr "æ—¢å­˜ã®ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒãƒƒãƒ•ã‚¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’é€šã—ã¦ã‚³ãƒ”ãƒ¼ã™ã‚‹: ``bytearray(b'Hi!')``"

#: ../../library/stdtypes.rst:2396
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¯å¤‰ãªã®ã§ã€ :ref:`bytes-methods` ã§è§£èª¬ã•ã‚Œã¦ã„ã‚‹ bytes "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨å…±é€šã®æ“ä½œã«åŠ ãˆã¦ã€ :ref:`mutable <typesseq-mutable>` ã‚·ãƒ¼ã‚±ãƒ³ã‚¹æ“ä½œã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2400
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr ":ref:`bytearray <func-bytearray>` ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•°ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2402
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"16 é€²æ•°ã§ 2 æ¡ã®æ•°ã¯æ­£ç¢ºã« 1 ãƒã‚¤ãƒˆã«ç›¸å½“ã™ã‚‹ãŸã‚ã€16 é€²æ•´ã¯ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¾ã™ã‚‹å½¢å¼ã¨ã—ã¦åºƒãä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ å¾“ã£ã¦ã€ "
"bytearray å‹ã«ã¯ãã®å½¢å¼ã§ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å–ã‚‹ãŸã‚ã®è¿½åŠ ã®ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2408
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"ã“ã® :class:`bytearray` ã®ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã¦ bytearray "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œãã‚Œã®ãƒã‚¤ãƒˆã‚’ 16 é€²æ•° 2 æ¡ã§è¡¨ç¾ã—ãŸæ–‡å­—åˆ—ã‚’æŒ‡å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ASCII ç©ºç™½æ–‡å­—ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2415
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr "bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãã® 16 é€²è¡¨è¨˜ã«å¤‰æ›ã™ã‚‹ãŸã‚ã®ã€åå¯¾å‘ãã®å¤‰æ›é–¢æ•°ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2428
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ•´æ•°ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ (ãƒªã‚¹ãƒˆã®ã‚ˆã†ãªã‚‚ã®) ãªã®ã§ã€ bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *b* ã«ã¤ã„ã¦ã€ "
"``b[0]`` ã¯æ•´æ•°ã«ãªã‚Šã€ ``b[0:1]`` ã¯é•·ã• 1 ã® bytearray "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚(ã“ã‚Œã¯ã€æ–‡å­—åˆ—ã«ãŠã„ã¦ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã‚‚ã‚¹ãƒ©ã‚¤ã‚¹ã‚‚é•·ã• 1 ã®æ–‡å­—åˆ—ã‚’è¿”ã™ã®ã¨å¯¾ç…§çš„ã§ã™ã€‚)"

#: ../../library/stdtypes.rst:2433
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into"
" a list of integers using ``list(b)``."
msgstr ""
"bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¡¨è¨˜ã¯ãƒã‚¤ãƒˆã®ãƒªãƒ†ãƒ©ãƒ«å½¢å¼ (``bytearray(b'...')``) ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã‚Œã¯ ``bytearray([46, 46, 46])`` ãªã©ã®å½¢å¼ã‚ˆã‚Šã‚‚ä¾¿åˆ©ãªäº‹ãŒå¤šã„ãŸã‚ã§ã™ã€‚\n"
"bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã„ã¤ã§ã‚‚ ``list(b)`` ã§æ•´æ•°ã®ãƒªã‚¹ãƒˆã«å¤‰æ›ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2442
msgid "Bytes and Bytearray Operations"
msgstr "bytes ã¨ bytearray ã®æ“ä½œ"

#: ../../library/stdtypes.rst:2447
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>`"
" sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"bytes ã¨ bytearray ã¯ä¸¡æ–¹å…± :ref:`ä¸€èˆ¬ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹æ“ä½œ <typesseq-common>` "
"ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã¾ãŸã€ä¸¡æ–¹ã¨ã‚‚ :term:`bytes-like object` "
"ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¯¾è±¡ã«æ“ä½œã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã“ã®æŸ”è»Ÿæ€§ã«ã‚ˆã‚Š bytes ã¨ bytearray "
"ã‚’è‡ªç”±ã«æ··ãœã¦ã‚‚ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã™ã“ã¨ãªãæ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ãŸã ã—ã€æ“ä½œã®çµæœã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã®æ“ä½œã®é †åºã«ä¾å­˜ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2455
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"æ–‡å­—åˆ—ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¼•æ•°ã¨ã—ã¦ bytes ã‚’å—ã‘ä»˜ã‘ãªã„ã®ã¨åŒæ§˜ã€bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ bytearray "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¼•æ•°ã¨ã—ã¦æ–‡å­—åˆ—ã‚’å—ã‘ä»˜ã‘ã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“::"

#: ../../library/stdtypes.rst:2462
msgid "and::"
msgstr "ãŠã‚ˆã³::"

#: ../../library/stdtypes.rst:2467
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"ã„ãã¤ã‹ã® bytes ã¨ bytearray ã®æ“ä½œã¯ ASCII "
"ã¨äº’æ›æ€§ã®ã‚ã‚‹ãƒã‚¤ãƒŠãƒªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ã¨ä»®å®šã—ã¦ã„ã¾ã™ã®ã§ã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ä¸æ˜ãªãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ä½¿ã†ã“ã¨ã¯é¿ã‘ã‚‹ã¹ãã§ã™ã€‚ã“ã†ã—ãŸåˆ¶ç´„ã«ã¤ã„ã¦ã¯ä»¥ä¸‹ã§èª¬æ˜ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2472
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr "ã“ã‚Œã‚‰ã® ASCII ãƒ™ãƒ¼ã‚¹ã®æ¼”ç®—ã‚’ä½¿ã£ã¦ ASCII ãƒ™ãƒ¼ã‚¹ã§ã¯ãªã„ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚’æ“ä½œã™ã‚‹ã¨ã€ãƒ‡ãƒ¼ã‚¿ã‚’ç ´å£Šã™ã‚‹æã‚ŒãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2475
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr "ä»¥ä¸‹ã® bytes ãŠã‚ˆã³ bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä»»æ„ã®ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ä½¿ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2481
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the"
" range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"[*start*, *end*] ã®ç¯„å›²ã«ã€éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *sub* ãŒé‡è¤‡ã›ãšå‡ºç¾ã™ã‚‹å›æ•°ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *start* ãŠã‚ˆã³ "
"*end* ã¯ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã¨åŒã˜ã‚ˆã†ã«è§£é‡ˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2485 ../../library/stdtypes.rst:2532
#: ../../library/stdtypes.rst:2554 ../../library/stdtypes.rst:2620
#: ../../library/stdtypes.rst:2633
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""
"æ¤œç´¢å¯¾è±¡ã®éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€ä»»æ„ã® :term:`bytes-like object` ã¾ãŸã¯  0 ã‹ã‚‰ 255 ã®ç¯„å›²ã®æ•´æ•°ã«ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2488 ../../library/stdtypes.rst:2544
#: ../../library/stdtypes.rst:2557 ../../library/stdtypes.rst:2623
#: ../../library/stdtypes.rst:2636
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr "éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦ 0 ã‹ã‚‰ 255 ã®ç¯„å›²ã®æ•´æ•°ã‚‚å—ã‘å–ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:2495
msgid ""
"Return a string decoded from the given bytes.  Default encoding is "
"``'utf-8'``. *errors* may be given to set a different error handling scheme."
"  The default for *errors* is ``'strict'``, meaning that encoding errors "
"raise a :exc:`UnicodeError`.  Other possible values are ``'ignore'``, "
"``'replace'`` and any other name registered via "
":func:`codecs.register_error`, see section :ref:`error-handlers`. For a list"
" of possible encodings, see section :ref:`standard-encodings`."
msgstr ""
"ä¸ãˆã‚‰ã‚ŒãŸãƒã‚¤ãƒˆåˆ—ã‹ã‚‰ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ ``'utf-8'`` ã§ã™ã€‚ *errors* "
"ã‚’ä¸ãˆã¦ç•°ãªã‚‹ã‚¨ãƒ©ãƒ¼å‡¦ç†æ³•ã‚’è¨­å®šã§ãã¾ã™ã€‚ *errors* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``'strict'`` ã§ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ©ãƒ¼ãŒ "
":exc:`UnicodeError` ã‚’é€å‡ºã—ã¾ã™ã€‚è¨­å®šã§ãã‚‹ä»–ã®å€¤ã¯ã€ ``'ignore'`` ã€ ``'replace'`` ã€ãã®ä»–ã® "
":func:`codecs.register_error` ã‚’é€šã—ã¦ç™»éŒ²ã•ã‚ŒãŸåå‰ã§ã€ç¯€ :ref:`error-handlers` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚å¯èƒ½ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ãƒªã‚¹ãƒˆã¯ã€ :ref:`standard-encodings` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:2505
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term"
":`bytes-like object` directly, without needing to make a temporary bytes or "
"bytearray object."
msgstr ""
"å¼•æ•° *encoding* ã‚’ :class:`str` ã«æ¸¡ã™ã¨ :term:`bytes-like object` "
"ã‚’ç›´æ¥ãƒ‡ã‚³ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã¤ã¾ã‚Šã€ä¸€æ™‚çš„ãª bytes ã‚„ bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2509
msgid "Added support for keyword arguments."
msgstr "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®ã‚µãƒãƒ¼ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:2516
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ãŒæŒ‡å®šã•ã‚ŒãŸ *suffix* ã§çµ‚ã‚ã‚‹å ´åˆã¯ ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™ã€‚ *suffix* "
"ã¯è¦‹ã¤ã‘ãŸã„è¤‡æ•°ã®æ¥å°¾èªã®ã‚¿ãƒ—ãƒ«ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *start* ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®ä½ç½®ã‹ã‚‰åˆ¤å®šã‚’é–‹å§‹ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® "
"*end* ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®ä½ç½®ã§æ¯”è¼ƒã‚’çµ‚äº†ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2521
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr "æ¤œç´¢å¯¾è±¡ã®æ¥å°¾èª (è¤‡æ•°ã‚‚å¯) ã¯ã€ä»»æ„ã® :term:`bytes-like object` ã«ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2527
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"ã‚¹ãƒ©ã‚¤ã‚¹ ``s[start:end]`` ã«éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *sub* ãŒå«ã¾ã‚Œã‚‹å ´åˆã€ãƒ‡ãƒ¼ã‚¿ä¸­ã®ãã® *sub* "
"ã®æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *start* ãŠã‚ˆã³ *end* ã¯ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã¨åŒæ§˜ã«è§£é‡ˆã•ã‚Œã¾ã™ã€‚ *sub* "
"ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã€ ``-1`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2537
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the "
":keyword:`in` operator::"
msgstr ""
":meth:`~bytes.find` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ *sub* ã®ä½ç½®ã‚’çŸ¥ã‚ŠãŸã„ã¨ãã«ã®ã¿ä½¿ã†ã¹ãã§ã™ã€‚ *sub* ãŒéƒ¨åˆ†æ–‡å­—åˆ— (è¨³æ³¨: "
"ãŠãã‚‰ãåŸæ–‡ã®èª¤ã‚Šã€æ­£ã—ãã¯éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹) ã§ã‚ã‚‹ã‹ã©ã†ã‹ã®ã¿ã‚’èª¿ã¹ã‚‹ã«ã¯ã€ :keyword:`in` æ¼”ç®—å­ã‚’ä½¿ã£ã¦ãã ã•ã„::"

#: ../../library/stdtypes.rst:2551
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""
":meth:`~bytes.find` ã¨åŒæ§˜ã§ã™ãŒã€éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2564
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"*iterable* ä¸­ã®ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚’çµåˆã—ãŸ bytes ã¾ãŸã¯ bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ *iterable* ã« "
":class:`str` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã© :term:`bytes-like objects <bytes-like object>` "
"ã§ã¯ãªã„å€¤ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€ :exc:`TypeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ãªãŠè¦ç´ é–“ã®ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã™ã‚‹ bytes ã¾ãŸã¯ "
"bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2575
msgid ""
"This static method returns a translation table usable for "
":meth:`bytes.translate` that will map each character in *from* into the "
"character at the same position in *to*; *from* and *to* must both be :term"
":`bytes-like objects <bytes-like object>` and have the same length."
msgstr ""
"ã“ã®é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ :func:`bytes.translate` ã«æ¸¡ã™ã®ã«é©ã—ãŸå¤‰æ›ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã€ *from* "
"ä¸­ã®å„ãƒã‚¤ãƒˆã‚’ *to* ã®åŒã˜ä½ç½®ã«ã‚ã‚‹ãƒã‚¤ãƒˆã«ãƒãƒƒãƒ”ãƒ³ã‚°ã—ã¾ã™ã€‚ *from* ã¨ *to* ã¯ä¸¡æ–¹ã¨ã‚‚åŒã˜é•·ã•ã® :term:`bytes-"
"like objects <bytes-like object>` ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2586
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed"
" by two empty bytes or bytearray objects."
msgstr ""
"åŒºåˆ‡ã‚Š *sep* ãŒæœ€åˆã«å‡ºç¾ã™ã‚‹ä½ç½®ã§ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’åˆ†å‰²ã—ã€ 3 "
"è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã®å†…å®¹ã¯ã€åŒºåˆ‡ã‚Šã®å‰ã®éƒ¨åˆ†ã€ãã®åŒºåˆ‡ã‚Šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ãã® bytearray "
"å‹ã®ã‚³ãƒ”ãƒ¼ã€ãã—ã¦åŒºåˆ‡ã‚Šã®å¾Œã‚ã®éƒ¨åˆ†ã§ã™ã€‚ã‚‚ã—åŒºåˆ‡ã‚Œãªã‘ã‚Œã°ã€ã‚¿ãƒ—ãƒ«ã«ã¯å…ƒã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ”ãƒ¼ã¨ã€ãã®å¾Œã‚ã«äºŒã¤ã®ç©ºã® bytes ã¾ãŸã¯ "
"bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå…¥ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2593 ../../library/stdtypes.rst:2650
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr "æ¤œç´¢ã™ã‚‹åŒºåˆ‡ã‚Šã¨ã—ã¦ã¯ã€ä»»æ„ã® :term:`bytes-like object` ã‚’æŒ‡å®šã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2599
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *old* ã‚’å…¨ã¦ *new* ã«ç½®æ›ã—ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *count* ãŒä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹å ´åˆã€å…ˆé ­ã‹ã‚‰ "
"*count* å€‹ã® *old* ã ã‘ã‚’ç½®æ›ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2603
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr "æ¤œç´¢ã™ã‚‹éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŠã‚ˆã³ç½®æ›å¾Œã®éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦ã¯ã€ä»»æ„ã® :term:`bytes-like object` ã‚’æŒ‡å®šã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2608 ../../library/stdtypes.rst:2701
#: ../../library/stdtypes.rst:2715 ../../library/stdtypes.rst:2739
#: ../../library/stdtypes.rst:2753 ../../library/stdtypes.rst:2788
#: ../../library/stdtypes.rst:2858 ../../library/stdtypes.rst:2876
#: ../../library/stdtypes.rst:2904 ../../library/stdtypes.rst:3033
#: ../../library/stdtypes.rst:3088 ../../library/stdtypes.rst:3131
#: ../../library/stdtypes.rst:3152 ../../library/stdtypes.rst:3174
#: ../../library/stdtypes.rst:3366
msgid ""
"The bytearray version of this method does *not* operate in place - it always"
" produces a new object, even if no changes were made."
msgstr "bytearray ã®ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã§ã¯å‹•ä½œ *ã—ã¾ã›ã‚“* -- ä¸€åˆ‡å¤‰åŒ–ãŒç„¡ã„å ´åˆã§ã‚‚ã€å¸¸ã«æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2615
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ä¸­ã®é ˜åŸŸ ``s[start:end]`` ã« *sub* ãŒå«ã¾ã‚Œã‚‹å ´åˆã€ãã®æœ€å¤§ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *start* "
"ãŠã‚ˆã³ *end* ã¯ã‚¹ãƒ©ã‚¤ã‚¹è¡¨è¨˜ã¨åŒæ§˜ã«è§£é‡ˆã•ã‚Œã¾ã™ã€‚ *sub* ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ ``-1``  ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2630
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
":meth:`~bytes.rfind` ã¨åŒæ§˜ã§ã™ãŒã€éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *sub* ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ :exc:`ValueError` "
"ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2643
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed"
" by two empty bytes or bytearray objects."
msgstr ""
"åŒºåˆ‡ã‚Š *sep* ãŒæœ€å¾Œã«å‡ºç¾ã™ã‚‹ä½ç½®ã§ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’åˆ†å‰²ã—ã€ 3 "
"è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã®å†…å®¹ã¯ã€åŒºåˆ‡ã‚Šã®å‰ã®éƒ¨åˆ†ã€ãã®åŒºåˆ‡ã‚Šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ãã® bytearray "
"å‹ã®ã‚³ãƒ”ãƒ¼ã€ãã—ã¦åŒºåˆ‡ã‚Šã®å¾Œã‚ã®éƒ¨åˆ†ã§ã™ã€‚ã‚‚ã—åŒºåˆ‡ã‚Œãªã‘ã‚Œã°ã€ã‚¿ãƒ—ãƒ«ã«ã¯å…ƒã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ”ãƒ¼ã¨ã€ãã®å¾Œã‚ã«äºŒã¤ã®ç©ºã® bytes ã¾ãŸã¯ "
"bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå…¥ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2656
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ãŒæŒ‡å®šã•ã‚ŒãŸ *prefix* ã§å§‹ã¾ã‚‹å ´åˆã¯ ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™ã€‚ *prefix* "
"ã¯è¦‹ã¤ã‘ãŸã„è¤‡æ•°ã®æ¥é ­èªã®ã‚¿ãƒ—ãƒ«ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *start* ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®ä½ç½®ã‹ã‚‰åˆ¤å®šã‚’é–‹å§‹ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® "
"*end* ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®ä½ç½®ã§æ¯”è¼ƒã‚’çµ‚äº†ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2661
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr "æ¤œç´¢å¯¾è±¡ã®æ¥é ­èª (è¤‡æ•°ã‚‚å¯) ã¯ã€ä»»æ„ã® :term:`bytes-like object` ã«ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2667
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *delete* "
"ã«ç¾ã‚Œã‚‹ã™ã¹ã¦ã®ãƒã‚¤ãƒˆã‚’é™¤å»ã—ã€æ®‹ã£ãŸãƒã‚¤ãƒˆã‚’ä¸ãˆã‚‰ã‚ŒãŸå¤‰æ›ãƒ†ãƒ¼ãƒ–ãƒ«ã«å¾“ã£ã¦ãƒãƒƒãƒ—ã—ãŸã€ãƒã‚¤ãƒˆåˆ—ã‚„ãƒã‚¤ãƒˆé…åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å¤‰æ›ãƒ†ãƒ¼ãƒ–ãƒ«ã¯é•·ã•"
" 256 ã®ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2672
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation "
"table."
msgstr "å¤‰æ›ãƒ†ãƒ¼ãƒ–ãƒ«ã®ä½œæˆã«ã€ :func:`bytes.maketrans` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2675
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr "æ–‡å­—ã‚’å‰Šé™¤ã™ã‚‹ã ã‘ã®å¤‰æ›ã«ã¯ã€ *table* å¼•æ•°ã‚’ ``None`` ã«è¨­å®šã—ã¦ãã ã•ã„::"

#: ../../library/stdtypes.rst:2681
msgid "*delete* is now supported as a keyword argument."
msgstr "*delete* ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ã—ã¦æŒ‡å®šå¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:2685
msgid ""
"The following methods on bytes and bytearray objects have default behaviours"
" that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"ä»¥ä¸‹ã® bytes ãŠã‚ˆã³ bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ ASCII "
"ã¨äº’æ›æ€§ã®ã‚ã‚‹ãƒã‚¤ãƒŠãƒªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ã¨ä»®å®šã—ã¦ã„ã¾ã™ãŒã€é©åˆ‡ãªå¼•æ•°ã‚’æŒ‡å®šã™ã‚Œã°ä»»æ„ã®ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã«ä½¿ç”¨ã§ãã¾ã™ã€‚ãªãŠã€ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ç´¹ä»‹ã™ã‚‹"
" bytearray ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã™ã¹ã¦ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã§å‹•ä½œ *ã›ãš* ã€æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2694
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"é•·ã• *width* ã®ä¸­å¤®å¯„ã›ã•ã‚ŒãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã«ã¯ *fillbyte* ã§æŒ‡å®šã•ã‚ŒãŸå€¤ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ASCII "
"ã‚¹ãƒšãƒ¼ã‚¹) ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ :class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€ *width* ãŒ ``len(s)`` "
"ä»¥ä¸‹ãªã‚‰å…ƒã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2708
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"é•·ã• *width* ã®å·¦å¯„ã›ã•ã‚ŒãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã«ã¯ *fillbyte* ã§æŒ‡å®šã•ã‚ŒãŸå€¤ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ASCII "
"ã‚¹ãƒšãƒ¼ã‚¹) ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ :class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€ *width* ãŒ ``len(s)`` "
"ä»¥ä¸‹ãªã‚‰å…ƒã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2722
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"å…ˆé ­ã‹ã‚‰ç‰¹å®šã®ãƒã‚¤ãƒˆå€¤ã‚’é™¤å»ã—ãŸã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•° *chars* ã¯é™¤å»ã•ã‚Œã‚‹ãƒã‚¤ãƒˆå€¤ã®é›†åˆã‚’æŒ‡å®šã™ã‚‹ãƒã‚¤ãƒŠãƒªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã™ ï¼ "
"ã“ã®åå‰ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒé€šå¸¸ã¯ ASCII æ–‡å­—åˆ—ã«å¯¾ã—ã¦ä½¿ã‚ã‚Œã‚‹ã“ã¨ã«ç”±æ¥ã—ã¦ã„ã¾ã™ã€‚ *chars* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ ``None`` ã®å ´åˆã€ "
"ASCII ã®ç©ºç™½æ–‡å­—ï¼ˆè¨³æ³¨: åŠè§’ã‚¹ãƒšãƒ¼ã‚¹ï¼‰ãŒé™¤å»ã•ã‚Œã¾ã™ã€‚ãªãŠ *chars* "
"å¼•æ•°ã¨ä¸€è‡´ã™ã‚‹æ¥é ­è¾ãŒé™¤å»ã•ã‚Œã‚‹ã®ã§ã¯ãªãã€ãã‚Œã«å«ã¾ã‚Œã‚‹ãƒã‚¤ãƒˆã®çµ„ã¿åˆã‚ã›å…¨ã¦ãŒé™¤å»ã•ã‚Œã¾ã™::"

#: ../../library/stdtypes.rst:2734 ../../library/stdtypes.rst:2783
#: ../../library/stdtypes.rst:2853
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr "é™¤å»å¯¾è±¡ã®ãƒã‚¤ãƒˆå€¤ã‚’å«ã‚€ãƒã‚¤ãƒŠãƒªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ã¯ã€ä»»æ„ã® :term:`bytes-like object` ã‚’æŒ‡å®šã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2746
msgid ""
"Return a copy of the object right justified in a sequence of length *width*."
" Padding is done using the specified *fillbyte* (default is an ASCII space)."
" For :class:`bytes` objects, the original sequence is returned if *width* is"
" less than or equal to ``len(s)``."
msgstr ""
"é•·ã• *width* ã®å³å¯„ã›ã•ã‚ŒãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã«ã¯ *fillbyte* ã§æŒ‡å®šã•ã‚ŒãŸå€¤ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ASCII "
"ã‚¹ãƒšãƒ¼ã‚¹) ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ :class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€ *width* ãŒ ``len(s)`` "
"ä»¥ä¸‹ãªã‚‰å…ƒã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2760
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as"
" the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are"
" done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for"
" splitting from the right, :meth:`rsplit` behaves like :meth:`split` which "
"is described in detail below."
msgstr ""
"*sep* ã‚’åŒºåˆ‡ã‚Šã¨ã—ã¦ã€åŒã˜å‹ã®éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«åˆ†å‰²ã—ã¾ã™ã€‚ *maxsplit* ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã® *å³ç«¯* ã‹ã‚‰æœ€å¤§ "
"*maxsplit* å›ã ã‘åˆ†å‰²ã‚’è¡Œã„ã¾ã™ã€‚ *sep* ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ã‹ ``None`` ã®ã¨ãã€ ASCII "
"ç©ºç™½æ–‡å­—ã®çµ„ã¿åˆã‚ã›ã§ä½œã‚‰ã‚Œã‚‹éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã™ã¹ã¦ãŒåŒºåˆ‡ã‚Šã¨ãªã‚Šã¾ã™ã€‚å³ã‹ã‚‰åˆ†å‰²ã—ã¦ã„ãã“ã¨ã‚’é™¤ã‘ã°ã€ :meth:`rsplit` "
"ã¯å¾Œã»ã©è©³ã—ãè¿°ã¹ã‚‹ :meth:`split` ã¨åŒæ§˜ã«æŒ¯ã‚‹èˆã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2771
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"æœ«å°¾ã‹ã‚‰ç‰¹å®šã®ãƒã‚¤ãƒˆå€¤ã‚’é™¤å»ã—ãŸã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•° *chars* ã¯é™¤å»ã•ã‚Œã‚‹ãƒã‚¤ãƒˆå€¤ã®é›†åˆã‚’æŒ‡å®šã™ã‚‹ãƒã‚¤ãƒŠãƒªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã™ ï¼ "
"ã“ã®åå‰ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒé€šå¸¸ã¯ ASCII æ–‡å­—åˆ—ã«å¯¾ã—ã¦ä½¿ã‚ã‚Œã‚‹ã“ã¨ã«ç”±æ¥ã—ã¦ã„ã¾ã™ã€‚ *chars* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ ``None`` ã®å ´åˆã€ "
"ASCII ã®ç©ºç™½æ–‡å­—ï¼ˆè¨³æ³¨: åŠè§’ã‚¹ãƒšãƒ¼ã‚¹ï¼‰ãŒé™¤å»ã•ã‚Œã¾ã™ã€‚ãªãŠ *chars* "
"å¼•æ•°ã¨ä¸€è‡´ã™ã‚‹æ¥å°¾è¾ãŒé™¤å»ã•ã‚Œã‚‹ã®ã§ã¯ãªãã€ãã‚Œã«å«ã¾ã‚Œã‚‹ãƒã‚¤ãƒˆã®çµ„ã¿åˆã‚ã›å…¨ã¦ãŒé™¤å»ã•ã‚Œã¾ã™::"

#: ../../library/stdtypes.rst:2795
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as"
" the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"*sep* ã‚’åŒºåˆ‡ã‚Šã¨ã—ã¦ã€åŒã˜å‹ã®éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«åˆ†å‰²ã—ã¾ã™ã€‚ *maxsplit* ãŒä¸ãˆã‚‰ã‚Œã€ã‹ã¤è² ã®æ•°ã§ãªã„å ´åˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã® *å·¦ç«¯* "
"ã‹ã‚‰æœ€å¤§ *maxsplit* å›ã ã‘åˆ†å‰²ã‚’è¡Œã„ã¾ã™ (ã—ãŸãŒã£ã¦çµæœã®ãƒªã‚¹ãƒˆã®è¦ç´ æ•°ã¯æœ€å¤§ã§ ``maxsplit+1`` ã«ãªã‚Šã¾ã™)ã€‚ "
"*maxsplit* ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ã‹ ``-1`` ã®ã¨ãã€åˆ†å‰²ã®å›æ•°ã«åˆ¶é™ã¯ã‚ã‚Šã¾ã›ã‚“ (å¯èƒ½ãªã ã‘åˆ†å‰²ã•ã‚Œã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:2801
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns "
"``[b'1', b'2', b'3']``). Splitting an empty sequence with a specified "
"separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on the type of"
" object being split.  The *sep* argument may be any :term:`bytes-like "
"object`."
msgstr ""
"*sep* ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€é€£ç¶šã—ãŸåŒºåˆ‡ã‚Šç”¨ãƒã‚¤ãƒˆå€¤ã¯ã¾ã¨ã‚ã‚‰ã‚Œãšã€ç©ºã®éƒ¨åˆ†ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’åŒºåˆ‡ã£ã¦ã„ã‚‹ã¨åˆ¤æ–­ã•ã‚Œã¾ã™(ä¾‹ãˆã° "
"``b'1,,2'.split(b',')`` ã¯ ``[b'1', b'', b'2']`` ã‚’è¿”ã—ã¾ã™)ã€‚å¼•æ•° *sep* "
"ã¯è¤‡æ•°ãƒã‚¤ãƒˆã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ã‚‚ã§ãã¾ã™ (ä¾‹ãˆã° ``b'1<>2<>3'.split(b'<>')`` ã¯ ``[b'1', b'2', b'3']``"
" ã‚’è¿”ã—ã¾ã™)ã€‚ç©ºã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’åˆ†å‰²ã™ã‚‹ã¨ã€åˆ†å‰²ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã«ã‚ˆã£ã¦ ``[b'']`` ã¾ãŸã¯ ``[bytearray(b'')]`` "
"ãŒè¿”ã‚Šã¾ã™ã€‚å¼•æ•° *sep* ã«ã¯ã€ã‚ã‚‰ã‚†ã‚‹ :term:`bytes-like object` ã‚’æŒ‡å®šã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2819
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is"
" applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting"
" an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"*sep* ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ã‹ ``None`` ã®å ´åˆã€ç•°ãªã‚‹åˆ†å‰²ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚é€£ç¶šã™ã‚‹ ASCII "
"ç©ºç™½æ–‡å­—ã¯ã²ã¨ã¤ã®åŒºåˆ‡ã‚Šã¨ã¿ãªã•ã‚Œã€ã¾ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å…ˆé ­ã‚„æœ«å°¾ã«ç©ºç™½ãŒã‚ã£ã¦ã‚‚ã€çµæœã®æœ€åˆã‚„æœ€å¾Œã«ç©ºã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯å«ã¾ã‚Œã¾ã›ã‚“ã€‚ã—ãŸãŒã£ã¦åŒºåˆ‡ã‚Šã‚’æŒ‡å®šã›ãšã«ç©ºã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚„"
" ASCII ç©ºç™½æ–‡å­—ã ã‘ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’åˆ†å‰²ã™ã‚‹ã¨ã€ ``[]`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2840
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"å…ˆé ­ãŠã‚ˆã³æœ«å°¾ã‹ã‚‰ç‰¹å®šã®ãƒã‚¤ãƒˆå€¤ã‚’é™¤å»ã—ãŸã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•° *chars* ã¯é™¤å»ã•ã‚Œã‚‹ãƒã‚¤ãƒˆå€¤ã®é›†åˆã‚’æŒ‡å®šã™ã‚‹ãƒã‚¤ãƒŠãƒªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã™ ï¼ "
"ã“ã®åå‰ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒé€šå¸¸ã¯ ASCII æ–‡å­—åˆ—ã«å¯¾ã—ã¦ä½¿ã‚ã‚Œã‚‹ã“ã¨ã«ç”±æ¥ã—ã¦ã„ã¾ã™ã€‚ *chars* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ ``None`` ã®å ´åˆã€ "
"ASCII ã®ç©ºç™½æ–‡å­—ï¼ˆè¨³æ³¨: åŠè§’ã‚¹ãƒšãƒ¼ã‚¹ï¼‰ãŒé™¤å»ã•ã‚Œã¾ã™ã€‚ãªãŠ *chars* "
"å¼•æ•°ã¨ä¸€è‡´ã™ã‚‹æ¥é ­è¾ãŠã‚ˆã³æ¥å°¾è¾ãŒé™¤å»ã•ã‚Œã‚‹ã®ã§ã¯ãªãã€ãã‚Œã«å«ã¾ã‚Œã‚‹ãƒã‚¤ãƒˆã®çµ„ã¿åˆã‚ã›å…¨ã¦ãŒé™¤å»ã•ã‚Œã¾ã™::"

#: ../../library/stdtypes.rst:2862
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII"
" compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"ä»¥ä¸‹ã® bytes ãŠã‚ˆã³ bytearray ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ ASCII "
"ã¨äº’æ›æ€§ã®ã‚ã‚‹ãƒã‚¤ãƒŠãƒªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ã¨ä»®å®šã—ã¦ãŠã‚Šã€ä»»æ„ã®ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ä½¿ç”¨ã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãªãŠã€ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ç´¹ä»‹ã™ã‚‹ "
"bytearray ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã™ã¹ã¦ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã§å‹•ä½œ *ã›ãš* ã€æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2870
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII"
" byte values are passed through unchanged."
msgstr ""
"å„ãƒã‚¤ãƒˆã‚’ ASCII æ–‡å­—ã¨è§£é‡ˆã—ã¦ã€æœ€åˆã®ãƒã‚¤ãƒˆã‚’å¤§æ–‡å­—ã«ã—ã€æ®‹ã‚Šã‚’å°æ–‡å­—ã«ã—ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ ASCII "
"æ–‡å­—ã¨è§£é‡ˆã§ããªã„ãƒã‚¤ãƒˆå€¤ã¯ã€å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:2883
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by"
" one or more ASCII spaces, depending on the current column and the given tab"
" size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If"
" the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"æ¡ (column) ä½ç½®ã¨æŒ‡å®šã•ã‚ŒãŸã‚¿ãƒ–å¹… (tab size) ã«å¿œã˜ã¦ã€å…¨ã¦ã® ASCII ã‚¿ãƒ–æ–‡å­—ã‚’ 1 ã¤ä»¥ä¸Šã® ASCII "
"ã‚¹ãƒšãƒ¼ã‚¹æ–‡å­—ã«ç½®æ›ã—ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ã“ã“ã§ *tabsize* ãƒã‚¤ãƒˆã”ã¨ã®æ¡ä½ç½®ã‚’ã‚¿ãƒ–ä½ç½®ã¨ã—ã¾ã™ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§ã‚ã‚‹ 8 "
"ã®å ´åˆã€ã‚¿ãƒ–ä½ç½®ã¯ 0 æ¡ç›®ã€ 8 æ¡ç›®ã€ 16 æ¡ç›®ã€ã¨ç¶šã„ã¦ã„ãã¾ã™)ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’å±•é–‹ã™ã‚‹ã«ã‚ãŸã£ã¦ã€ã¾ãšç¾æ¡ä½ç½®ã‚’ã‚¼ãƒ­ã«è¨­å®šã—ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ 1"
" ãƒã‚¤ãƒˆãšã¤èª¿ã¹ã¦ã„ãã¾ã™ã€‚ã‚‚ã—ãƒã‚¤ãƒˆå€¤ãŒ ASCII ã‚¿ãƒ–æ–‡å­— (``b'\\t'``) ã§ã‚ã‚Œã°ã€ç¾æ¡ä½ç½®ãŒæ¬¡ã®ã‚¿ãƒ–ä½ç½®ã¨ä¸€è‡´ã™ã‚‹ã¾ã§ 1 ã¤ä»¥ä¸Šã®"
" ASCII ã‚¹ãƒšãƒ¼ã‚¹æ–‡å­—ã‚’çµæœã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«æŒ¿å…¥ã—ã¦ã„ãã¾ã™ï¼ˆASCII ã‚¿ãƒ–æ–‡å­—è‡ªä½“ã¯ã‚³ãƒ”ãƒ¼ã—ã¾ã›ã‚“ï¼‰ã€‚ã‚‚ã—ãƒã‚¤ãƒˆå€¤ãŒ ASCII æ”¹è¡Œæ–‡å­— "
"(``b'\\n'`` ã‚‚ã—ãã¯ ``b'\\r'``) ã§ã‚ã‚Œã°ã€ãã®ã¾ã¾ã‚³ãƒ”ãƒ¼ã—ãŸä¸Šã§ç¾æ¡ä½ç½®ã‚’ 0 "
"ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚ãã®ä»–ã®ãƒã‚¤ãƒˆå€¤ã«ã¤ã„ã¦ã¯å¤‰æ›´ã›ãšã«ã‚³ãƒ”ãƒ¼ã—ã€ãã®ãƒã‚¤ãƒˆå€¤ã®è¡¨ç¤ºã®ã•ã‚Œæ–¹ï¼ˆè¨³æ³¨: å…¨è§’ã€åŠè§’ãªã©ï¼‰ã«é–¢ã‚ã‚‰ãšç¾æ¡ä½ç½®ã‚’ 1 "
"ã¤å¢—åŠ ã•ã›ã¾ã™::"

#: ../../library/stdtypes.rst:2911
msgid ""
"Return true if all bytes in the sequence are alphabetical ASCII characters "
"or ASCII decimal digits and the sequence is not empty, false otherwise. "
"Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒç©ºã§ãªãã€ã‹ã¤å…¨ã¦ã®ãƒã‚¤ãƒˆå€¤ãŒ ASCII æ–‡å­—ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã¾ãŸã¯æ•°å­—ã§ã‚ã‚‹å ´åˆã¯ true ã‚’ã€ãã†ã§ãªã‘ã‚Œã° false "
"ã‚’è¿”ã—ã¾ã™ã€‚ã“ã“ã§ã® ASCII æ–‡å­—ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã¨ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`` ã«å«ã¾ã‚Œã‚‹ãƒã‚¤ãƒˆå€¤ã§ã™ã€‚ "
"ASCII æ–‡å­—ã®æ•°å­—ã¨ã¯ ``b'0123456789'`` ã«å«ã¾ã‚Œã‚‹ãƒã‚¤ãƒˆå€¤ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2928
msgid ""
"Return true if all bytes in the sequence are alphabetic ASCII characters and"
" the sequence is not empty, false otherwise.  Alphabetic ASCII characters "
"are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒç©ºã§ãªãã€ã‹ã¤å…¨ã¦ã®ãƒã‚¤ãƒˆå€¤ãŒ ASCII æ–‡å­—ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã§ã‚ã‚‹å ´åˆã¯ true ã‚’ã€ãã†ã§ãªã‘ã‚Œã° false ã‚’è¿”ã—ã¾ã™ã€‚ã“ã“ã§ã®"
" ASCII æ–‡å­—ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã¨ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`` ã«å«ã¾ã‚Œã‚‹ãƒã‚¤ãƒˆå€¤ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2944
msgid ""
"Return true if all bytes in the sequence are ASCII decimal digits and the "
"sequence is not empty, false otherwise. ASCII decimal digits are those byte "
"values in the sequence ``b'0123456789'``."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒç©ºã§ãªãã€ã‹ã¤å…¨ã¦ã®ãƒã‚¤ãƒˆå€¤ãŒ ASCII æ–‡å­—ã®æ•°å­—ã§ã‚ã‚‹å ´åˆã¯ true ã‚’ã€ãã†ã§ãªã‘ã‚Œã° false ã‚’è¿”ã—ã¾ã™ã€‚ã“ã“ã§ã® "
"ASCII æ–‡å­—ã®æ•°å­—ã¨ã¯ ``b'0123456789'`` ã«å«ã¾ã‚Œã‚‹ãƒã‚¤ãƒˆå€¤ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2959
msgid ""
"Return true if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, false otherwise."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ä¸­ã«å°æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã® ASCII æ–‡å­—ãŒä¸€ã¤ä»¥ä¸Šã‚ã‚Šã€ã‹ã¤å¤§æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã® ASCII æ–‡å­—ãŒä¸€ã¤ã‚‚ç„¡ã„å ´åˆã« true "
"ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° false ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:2969 ../../library/stdtypes.rst:3011
#: ../../library/stdtypes.rst:3027 ../../library/stdtypes.rst:3077
#: ../../library/stdtypes.rst:3146
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte"
" values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"ã“ã“ã§ã®å°æ–‡å­—ã® ASCII æ–‡å­—ã¨ã¯ ``b'abcdefghijklmnopqrstuvwxyz'`` ã«å«ã¾ã‚Œã‚‹ãƒã‚¤ãƒˆå€¤ã§ã™ã€‚ã¾ãŸå¤§æ–‡å­—ã® "
"ASCII æ–‡å­—ã¨ã¯ ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`` ã«å«ã¾ã‚Œã‚‹ãƒã‚¤ãƒˆå€¤ã§ã™ã€‚"

#: ../../library/stdtypes.rst:2977
msgid ""
"Return true if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, false otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒç©ºã§ãªãã€ã‹ã¤å…¨ã¦ã®ãƒã‚¤ãƒˆå€¤ãŒ ASCII ç©ºç™½æ–‡å­—ã§ã‚ã‚‹å ´åˆã¯ true ã‚’ã€ãã†ã§ãªã‘ã‚Œã° false ã‚’è¿”ã—ã¾ã™ã€‚ã“ã“ã§ã® ASCII"
" ç©ºç™½æ–‡å­—ã¨ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ``b' \\t\\n\\r\\x0b\\f'`` ã«å«ã¾ã‚Œã‚‹ãƒã‚¤ãƒˆå€¤ã§ã™ "
"(åŠè§’ã‚¹ãƒšãƒ¼ã‚¹ã€ã‚¿ãƒ–ã€ãƒ©ã‚¤ãƒ³ãƒ•ã‚£ãƒ¼ãƒ‰ã€ã‚­ãƒ£ãƒªãƒƒã‚¸ãƒªã‚¿ãƒ¼ãƒ³ã€å‚ç›´ã‚¿ãƒ–ã€ãƒ•ã‚©ãƒ¼ãƒ ãƒ•ã‚£ãƒ¼ãƒ‰) ã€‚"

#: ../../library/stdtypes.rst:2986
msgid ""
"Return true if the sequence is ASCII titlecase and the sequence is not "
"empty, false otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒç©ºã§ãªãã€ã‹ã¤ ASCII ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚±ãƒ¼ã‚¹æ–‡å­—åˆ—ã«ãªã£ã¦ã„ã‚‹å ´åˆã¯ true ã‚’ã€ãã†ã§ãªã‘ã‚Œã° false "
"ã‚’è¿”ã—ã¾ã™ã€‚ã€Œã‚¿ã‚¤ãƒˆãƒ«ã‚±ãƒ¼ã‚¹æ–‡å­—åˆ—ã€ã®å®šç¾©ã«ã¤ã„ã¦ã¯ :meth:`bytes.title` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:3001
msgid ""
"Return true if there is at least one uppercase alphabetic ASCII character in"
" the sequence and no lowercase ASCII characters, false otherwise."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ä¸­ã«å¤§æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã® ASCII æ–‡å­—ãŒä¸€ã¤ä»¥ä¸Šã‚ã‚Šã€ã‹ã¤å°æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã® ASCII æ–‡å­—ãŒä¸€ã¤ã‚‚ç„¡ã„å ´åˆã« true "
"ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° false ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3019
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«å«ã¾ã‚Œã‚‹å¤§æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã® ASCII æ–‡å­—ã‚’å…¨ã¦å°æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã«å¤‰æ›ã—ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3044
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"ãƒã‚¤ãƒŠãƒªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ ASCII ã®æ”¹è¡Œã‚³ãƒ¼ãƒ‰ã§åˆ†å‰²ã—ã€å„è¡Œã‚’ãƒªã‚¹ãƒˆã«ã—ã¦è¿”ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :term:`universal newlines`"
" ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§è¡Œã‚’åˆ†å‰²ã—ã¾ã™ã€‚ *keepends* å¼•æ•°ã«çœŸã‚’ä¸ãˆãŸå ´åˆã‚’é™¤ãã€æ”¹è¡Œã‚³ãƒ¼ãƒ‰ã¯çµæœã®ãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:3056
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break"
" does not result in an extra line::"
msgstr ""
":meth:`~bytes.split` ã¨ã¯é•ã£ã¦ã€ç©ºã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«å¯¾ã—ã¦åŒºåˆ‡ã‚Š *sep* "
"ã‚’ä¸ãˆã¦å‘¼ã³å‡ºã™ã¨ç©ºã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã¾ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹æœ«å°¾ã«æ”¹è¡Œã‚³ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆã€ï¼ˆè¨³è¨»: "
"ãã®å¾Œã‚ã«ç©ºè¡ŒãŒã‚ã‚‹ã¨ã¯åˆ¤æ–­ã›ãšï¼‰ä½™åˆ†ãªè¡Œã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“::"

#: ../../library/stdtypes.rst:3069
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«å«ã¾ã‚Œã‚‹å°æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã® ASCII "
"æ–‡å­—ã‚’å…¨ã¦å¤§æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã«å¤‰æ›ã—ã€ã•ã‚‰ã«å¤§æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã‚’åŒæ§˜ã«å°æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã«å¤‰æ›ã—ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3081
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that "
"``bin.swapcase().swapcase() == bin`` for the binary versions. Case "
"conversions are symmetrical in ASCII, even though that is not generally true"
" for arbitrary Unicode code points."
msgstr ""
":func:`str.swapcase()` ã¨ã¯é•ã„ã€ãƒã‚¤ãƒŠãƒªãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã“ã¡ã‚‰ã§ã¯ ``bin.swapcase().swapcase() == "
"bin`` ãŒå¸¸ã«æˆã‚Šç«‹ã¡ã¾ã™ã€‚ä¸€èˆ¬çš„ã« Unicode æ–‡å­—ã®å¤§æ–‡å­—å°æ–‡å­—å¤‰æ›ã¯å¯¾ç§°çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ ASCII æ–‡å­—ã®å ´åˆã¯å¯¾ç§°çš„ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3095
msgid ""
"Return a titlecased version of the binary sequence where words start with an"
" uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""
"ã‚¿ã‚¤ãƒˆãƒ«ã‚±ãƒ¼ã‚¹åŒ–ã—ãŸãƒã‚¤ãƒŠãƒªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚å…·ä½“çš„ã«ã¯ã€å„å˜èªãŒå¤§æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã® ASCII "
"æ–‡å­—ã§å§‹ã¾ã‚Šã€ã‹ã¤æ®‹ã‚Šã®æ–‡å­—ãŒå°æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã«ãªã£ã¦ã„ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒè¿”ã‚Šã¾ã™ã€‚å¤§æ–‡å­—å°æ–‡å­—ã®åŒºåˆ¥ãŒç„¡ã„ãƒã‚¤ãƒˆå€¤ã«ã¤ã„ã¦ã¯å¤‰æ›´ã•ã‚Œãšãã®ã¾ã¾ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3104
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte"
" values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"ã“ã“ã§ã®å°æ–‡å­—ã® ASCII æ–‡å­—ã¨ã¯ ``b'abcdefghijklmnopqrstuvwxyz'`` ã«å«ã¾ã‚Œã‚‹ãƒã‚¤ãƒˆå€¤ã§ã™ã€‚ã¾ãŸå¤§æ–‡å­—ã® "
"ASCII æ–‡å­—ã¨ã¯ ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`` "
"ã«å«ã¾ã‚Œã‚‹ãƒã‚¤ãƒˆå€¤ã§ã™ã€‚ãã®ä»–ã®ãƒã‚¤ãƒˆå€¤ã«ã¤ã„ã¦ã¯ã€å¤§æ–‡å­—å°æ–‡å­—ã®åŒºåˆ¥ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:3138
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«å«ã¾ã‚Œã‚‹å°æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã® ASCII æ–‡å­—ã‚’å…¨ã¦å¤§æ–‡å­—ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã«å¤‰æ›ã—ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3159
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make"
" a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'`` is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"é•·ã•ãŒ *width* ã«ãªã‚‹ã‚ˆã† ASCII ``b'0'`` ã§å·¦è©°ã‚ã—ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å…ˆé ­ãŒç¬¦å·æ¥é ­è¾ "
"(``b'+'``/``b'-'``) ã ã£ãŸå ´åˆã€ ``b'0'`` ã¯ç¬¦å·ã®å‰ã§ã¯ãªã *å¾Œ* ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚ :class:`bytes` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€ *width* ãŒ ``len(seq)`` ä»¥ä¸‹ã§ã‚ã‚Œã°å…ƒã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒè¿”ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3181
msgid "``printf``-style Bytes Formatting"
msgstr "``printf`` å½¢å¼ã§ã® bytes ã®æ›¸å¼åŒ–"

#: ../../library/stdtypes.rst:3199
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"ã“ã“ã§è¿°ã¹ã‚‹æ›¸å¼åŒ–æ¼”ç®—ã«ã¯æ§˜ã€…ãªç™–ãŒã‚ã‚Šã€ã‚ˆãé–“é•ã„ã®å…ƒã«ãªã£ã¦ã„ã¾ã™ "
"(ã‚¿ãƒ—ãƒ«ã‚„è¾æ›¸ã‚’æ­£ã—ãè¡¨ç¤ºã§ããªã„ãªã©)ã€‚ã‚‚ã—è¡¨ç¤ºã™ã‚‹å€¤ãŒã‚¿ãƒ—ãƒ«ã‚„è¾æ›¸ã‹ã‚‚ã—ã‚Œãªã„å ´åˆã€ãã‚Œã‚’ã‚¿ãƒ—ãƒ«ã«åŒ…ã‚€ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:3204
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or"
" *interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with"
" zero or more elements of *values*. The effect is similar to using the "
":c:func:`sprintf` in the C language."
msgstr ""
"bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (``bytes``/``bytearray``) ã«ã¯å›ºæœ‰ã®æ“ä½œ: ``%`` æ¼”ç®—å­ (ãƒ¢ã‚¸ãƒ¥ãƒ­) "
"ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®æ¼”ç®—å­ã¯ bytes ã® *æ›¸å¼åŒ–* ã¾ãŸã¯ *è£œé–“* æ¼”ç®—å­ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚``format % values`` (*format*"
" ã¯ bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) ã¨ã™ã‚‹ã¨ã€*format* ä¸­ã® ``%`` å¤‰æ›æŒ‡å®šã¯ *values* "
"ä¸­ã®ã‚¼ãƒ­å€‹ã¾ãŸã¯ãã‚Œä»¥ä¸Šã®è¦ç´ ã§ç½®æ›ã•ã‚Œã¾ã™ã€‚ã“ã®å‹•ä½œã¯ C è¨€èªã«ãŠã‘ã‚‹ :c:func:`sprintf` ã«ä¼¼ã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3211
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of"
" items specified by the format bytes object, or a single mapping object (for"
" example, a dictionary)."
msgstr ""
"*format* ãŒå˜ä¸€ã®å¼•æ•°ã—ã‹è¦æ±‚ã—ãªã„å ´åˆã€ *values* ã¯ã‚¿ãƒ—ãƒ«ã§ã¯ãªã„å˜ä¸€ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚ [5]_ ãã‚Œä»¥å¤–ã®å ´åˆã€ "
"*values* ã¯æ›¸å¼ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ï¼ˆè¨³è¨»: å…ˆã®ä¾‹ã§ã® *format* "
"ï¼‰ä¸­ã§æŒ‡å®šã•ã‚ŒãŸé …ç›®ã¨æ­£ç¢ºã«åŒã˜æ•°ã®è¦ç´ ã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã‹ã€å˜ä¸€ã®ãƒãƒƒãƒ”ãƒ³ã‚°å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ãŸã¨ãˆã°è¾æ›¸) ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:3240
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For "
"example:"
msgstr ""
"``%`` æ¼”ç®—å­ã®å³å´ã®å¼•æ•°ãŒè¾æ›¸ã®å ´åˆ (ã¾ãŸã¯ãã®ä»–ã®ãƒãƒƒãƒ”ãƒ³ã‚°å‹ã®å ´åˆ) ã€ bytes "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸­ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ã¯ã€è¾æ›¸ã®ã‚­ãƒ¼ã‚’ä¸¸æ‹¬å¼§ã§å›²ã£ã¦æ–‡å­— ``'%'`` ã®ç›´å¾Œã«æ›¸ã„ãŸã‚‚ã®ãŒå«ã¾ã‚Œã¦ã„ãªã‘ã‚Œã° *ãªã‚Šã¾ã›ã‚“* "
"ã€‚ãƒãƒƒãƒ—ã‚­ãƒ¼ã¯æ›¸å¼åŒ–ã—ãŸã„å€¤ã‚’ãƒãƒƒãƒ”ãƒ³ã‚°ã‹ã‚‰é¸ã³å‡ºã—ã¾ã™ã€‚ä¾‹ãˆã°:"

#: ../../library/stdtypes.rst:3308
msgid "Single byte (accepts integer or single byte objects)."
msgstr "1 ãƒã‚¤ãƒˆ (æ•´æ•°ã¾ãŸã¯è¦ç´  1 ã¤ã® ``bytes``/``bytearray`` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ç†ã—ã¾ã™)"

#: ../../library/stdtypes.rst:3311
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/stdtypes.rst:3311
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or"
" has :meth:`__bytes__`)."
msgstr ""
"ãƒã‚¤ãƒŠãƒªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ (:ref:`buffer protocol <bufferobjects>` ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‹ã€ "
":meth:`__bytes__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ)"

#: ../../library/stdtypes.rst:3315
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr "``'s'`` ã¯ ``'b'`` ã®åˆ¥åã§ã™ã€‚Python 2/3 ã®ä¸¡æ–¹ã‚’å¯¾è±¡ã¨ã—ãŸã‚³ãƒ¼ãƒ‰ã§ã®ã¿ä½¿ç”¨ã™ã¹ãã§ã™ã€‚"

#: ../../library/stdtypes.rst:3318
msgid ""
"Bytes (converts any Python object using "
"``repr(obj).encode('ascii','backslashreplace)``)."
msgstr ""
"ãƒã‚¤ãƒŠãƒªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ (Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ ``repr(obj).encode('ascii','backslashreplace)`` "
"ã§å¤‰æ›ã—ã¾ã™)ã€‚"

#: ../../library/stdtypes.rst:3321
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr "``'r'`` ã¯ ``'a'`` ã®åˆ¥åã§ã™ã€‚Python 2/3 ã®ä¸¡æ–¹ã‚’å¯¾è±¡ã¨ã—ãŸã‚³ãƒ¼ãƒ‰ã§ã®ã¿ä½¿ç”¨ã™ã¹ãã§ã™ã€‚"

#: ../../library/stdtypes.rst:3321
msgid "\\(7)"
msgstr "\\(7)"

#: ../../library/stdtypes.rst:3356
msgid ""
"``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s'`` ã¯éæ¨å¥¨ã§ã™ãŒã€3.x ç³»ã§ã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:3359
msgid ""
"``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r'`` ã¯éæ¨å¥¨ã§ã™ãŒã€3.x ç³»ã§ã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:3371
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ""

#: ../../library/stdtypes.rst:3378
msgid "Memory Views"
msgstr "ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼"

#: ../../library/stdtypes.rst:3380
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of"
" an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
":class:`memoryview` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€Python ã‚³ãƒ¼ãƒ‰ãŒ :ref:`ãƒãƒƒãƒ•ã‚¡ãƒ—ãƒ­ãƒˆã‚³ãƒ« <bufferobjects>` "
"ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…éƒ¨ãƒ‡ãƒ¼ã‚¿ã¸ã€ã‚³ãƒ”ãƒ¼ã™ã‚‹ã“ã¨ãªãã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3386
msgid ""
"Create a :class:`memoryview` that references *obj*.  *obj* must support the "
"buffer protocol.  Built-in objects that support the buffer protocol include "
":class:`bytes` and :class:`bytearray`."
msgstr ""
"*obj* ã‚’å‚ç…§ã™ã‚‹ :class:`memoryview` ã‚’ä½œæˆã—ã¾ã™ã€‚ *obj* "
"ã¯ãƒãƒƒãƒ•ã‚¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ•ã‚¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹çµ„ã¿è¾¼ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€ :class:`bytes` ã€ "
":class:`bytearray` ãªã©ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3390
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating object *obj*.  For many simple types "
"such as :class:`bytes` and :class:`bytearray`, an element is a single byte, "
"but other types such as :class:`array.array` may have bigger elements."
msgstr ""
":class:`memoryview` ã¯å…ƒã¨ãªã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *obj* ãŒæ‰±ã†ãƒ¡ãƒ¢ãƒªãƒ¼ã®æœ€å°å˜ä½ã‚’ *è¦ç´ * "
"ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚å¤šãã®å˜ç´”ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ä¾‹ãˆã° :class:`bytes` ã‚„ :class:`bytearray` "
"ã§ã¯ã€è¦ç´ ã¯å˜ãƒã‚¤ãƒˆã«ãªã‚Šã¾ã™ãŒã€ä»–ã® :class:`array.array` ç­‰ã®å‹ã§ã¯ã€è¦ç´ ã¯ã‚ˆã‚Šå¤§ãããªã‚Šãˆã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3396
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`. If "
"``view.ndim = 0``, the length is 1. If ``view.ndim = 1``, the length is "
"equal to the number of elements in the view. For higher dimensions, the "
"length is equal to the length of the nested list representation of the view."
" The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""
"ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ã®é•·ã• ``len(view)`` ã¯ã€ :class:`~memoryview.tolist` "
"ã§å¾—ã‚‰ã‚Œã‚‹ãƒªã‚¹ãƒˆã®é•·ã•ã¨ãªã‚Šã¾ã™ã€‚``view.ndim = 0`` ãªã‚‰ã€é•·ã•ã¯ 1 ã§ã™ã€‚``view.ndim = 1`` "
"ãªã‚‰ã€é•·ã•ã¯ãƒ“ãƒ¥ãƒ¼ã®è¦ç´ æ•°ã¨ç­‰ã—ã„ã§ã™ã€‚ã‚ˆã‚Šé«˜æ¬¡å…ƒã§ã¯ã€é•·ã•ã¯ãƒ“ãƒ¥ãƒ¼ã®ãƒã‚¹ãƒˆã•ã‚ŒãŸãƒªã‚¹ãƒˆè¡¨ç¾ã®é•·ã•ã¨ç­‰ã—ã„ã§ã™ã€‚è¦ç´ ä¸€ã¤ã‚ãŸã‚Šã®ãƒã‚¤ãƒˆæ•°ã¯ "
":class:`~memoryview.itemsize` å±æ€§ã‹ã‚‰å–å¾—ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3403
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ":class:`memoryview` ã¯ã‚¹ãƒ©ã‚¤ã‚¹ãŠã‚ˆã³ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã§å†…å®¹ã‚’å–å¾—ã§ãã¾ã™ã€‚ä¸€æ¬¡å…ƒã®ã‚¹ãƒ©ã‚¤ã‚¹ã¯éƒ¨åˆ†ãƒ“ãƒ¥ãƒ¼ã«ãªã‚Šã¾ã™::"

#: ../../library/stdtypes.rst:3416
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is"
" also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"ã‚‚ã—ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ã® :class:`~memoryview.format` ãŒ :mod:`struct` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒã‚¤ãƒ†ã‚£ãƒ–ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæŒ‡å®šå­ã§ã‚ã‚Œã°ã€æ•´æ•°ã¾ãŸã¯æ•´æ•°ã®ã‚¿ãƒ—ãƒ«ã§ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã«ã‚ˆã‚Šé©åˆ‡ãªå‹ã® *è¦ç´ 1ã¤* "
"ã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¸€æ¬¡å…ƒã®ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ã§ã¯ã€æ•´æ•°ã¾ãŸã¯æ•´æ•° 1 ã¤ã®ã‚¿ãƒ—ãƒ«ã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã§ãã¾ã™ã€‚å¤šæ¬¡å…ƒã®ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ã§ã¯ã€ãã®æ¬¡å…ƒæ•°ã‚’ "
"*ndim* ã¨ã—ãŸã¨ãã€ã¡ã‚‡ã†ã© *ndim* "
"å€‹ã®æ•´æ•°ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã§ãã¾ã™ã€‚ã‚¼ãƒ­æ¬¡å…ƒã®ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ã§ã¯ã€ç©ºã®ã‚¿ãƒ—ãƒ«ã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3425
msgid "Here is an example with a non-byte format::"
msgstr ":class:`~memoryview.format` ãŒå˜ãƒã‚¤ãƒˆå˜ä½ã§ã¯ãªã„ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../library/stdtypes.rst:3437
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr "ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ã®å‚ç…§ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ›¸ãè¾¼ã¿å¯èƒ½ã§ã‚ã‚Œã°ã€ä¸€æ¬¡å…ƒã‚¹ãƒ©ã‚¤ã‚¹ã§ã®ä»£å…¥ãŒå¯èƒ½ã§ã™ã€‚ãŸã ã—ã‚µã‚¤ã‚ºã®å¤‰æ›´ã¯ã§ãã¾ã›ã‚“::"

#: ../../library/stdtypes.rst:3458
msgid ""
"One-dimensional memoryviews of hashable (read-only) types with formats 'B', "
"'b' or 'c' are also hashable. The hash is defined as ``hash(m) == "
"hash(m.tobytes())``::"
msgstr ""
"'B', 'b', 'c' ã„ãšã‚Œã‹ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ãƒãƒƒã‚·ãƒ¥å¯èƒ½ãª (èª­ã¿å‡ºã—å°‚ç”¨ã®) å‹ã®1æ¬¡å…ƒãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ã‚‚ã¾ãŸã€ãƒãƒƒã‚·ãƒ¥å¯èƒ½ã§ã™ã€‚ãƒãƒƒã‚·ãƒ¥ã¯ "
"``hash(m) == hash(m.tobytes())`` ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™::"

#: ../../library/stdtypes.rst:3470
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now hashable."
msgstr ""
"1 æ¬¡å…ƒã®ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ãŒã‚¹ãƒ©ã‚¤ã‚¹å¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚ 'B', 'b', 'c' ã„ãšã‚Œã‹ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã® 1 "
"æ¬¡å…ƒã®ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ãŒãƒãƒƒã‚·ãƒ¥å¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:3474
msgid ""
"memoryview is now registered automatically with "
":class:`collections.abc.Sequence`"
msgstr "memoryview ã¯è‡ªå‹•çš„ã« :class:`collections.abc.Sequence` ã¸ç™»éŒ²ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:3478
msgid "memoryviews can now be indexed with tuple of integers."
msgstr "ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ã¯æ•´æ•°ã®ã‚¿ãƒ—ãƒ«ã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:3481
msgid ":class:`memoryview` has several methods:"
msgstr ":class:`memoryview` ã«ã¯ã„ãã¤ã‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™:"

#: ../../library/stdtypes.rst:3485
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"memoryview ã¨ :pep:`3118` ã‚¨ã‚¯ã‚¹ãƒãƒ¼ã‚¿ãƒ¼ã¯ã€ shape ãŒåŒã˜ã§ã€ :mod:`struct` "
"ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§è§£é‡ˆã—ãŸã¨ãã®å€¤ãŒåŒã˜å ´åˆã«åŒå€¤ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3489
msgid ""
"For the subset of :mod:`struct` format strings currently supported by "
":meth:`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
":meth:`tolist` ãŒã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ :mod:`struct` ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ä¸€éƒ¨ã§ã¯ã€ ``v.tolist() == "
"w.tolist()`` ãŒæˆã‚Šç«‹ã¤ã¨ãã« ``v`` == ``w`` ã«ãªã‚Šã¾ã™::"

#: ../../library/stdtypes.rst:3508
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""
"ã©ã¡ã‚‰ã‹ã®æ›¸å¼æ–‡å­—åˆ—ãŒ :mod:`struct` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ (æ›¸å¼æ–‡å­—åˆ—ã¨ãƒãƒƒãƒ•ã‚¡ã®å†…å®¹ãŒåŒä¸€ã§ã‚‚) "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¸¸ã«ç­‰ã—ããªã„ã‚‚ã®ã¨ã—ã¦æ¯”è¼ƒã•ã‚Œã¾ã™::"

#: ../../library/stdtypes.rst:3524
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""
"æµ®å‹•å°æ•°ç‚¹æ•°ã®å ´åˆã¨åŒæ§˜ memoryview ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ ``v is w`` ã¯ ``v == w`` "
"ã‚’æ„å‘³ã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:3527
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr "ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ã€è¦ç´ ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¨è«–ç†çš„ãªé…åˆ—æ§‹é€ ã‚’ç„¡è¦–ã—ã¦ç”Ÿã®ãƒ¡ãƒ¢ãƒªã‚’æ¯”è¼ƒã—ã¦ã„ã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:3533
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"ãƒãƒƒãƒ•ã‚¡ä¸­ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒ¡ãƒ¢ãƒªãƒ“ãƒ¥ãƒ¼ã«å¯¾ã—ã¦ :class:`bytes` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å‘¼ã³å‡ºã™ã®ã¨åŒç­‰ã§ã™ã€‚ ::"

#: ../../library/stdtypes.rst:3542
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"é€£ç¶šã§ãªã„é…åˆ—ã«ã¤ã„ã¦ã¯ã€çµæœã¯ã™ã¹ã¦ã®è¦ç´ ãŒãƒã‚¤ãƒˆã«å¤‰æ›ã•ã‚ŒãŸã‚‚ã®ã‚’å«ã‚€ãƒ•ãƒ©ãƒƒãƒˆãªãƒªã‚¹ãƒˆè¡¨ç¾ã«ç­‰ã—ããªã‚Šã¾ã™ã€‚ :meth:`tobytes` ã¯ã€ "
":mod:`struct` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ–‡æ³•ã«ãªã„ã‚‚ã®ã‚’å«ã‚€ã™ã¹ã¦ã®æ›¸å¼æ–‡å­—åˆ—ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3549
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr "ãƒãƒƒãƒ•ã‚¡ä¸­ã®å„ãƒã‚¤ãƒˆã‚’ 2 ã¤ã® 16 é€²æ•°ã§è¡¨ã—ãŸæ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™::"

#: ../../library/stdtypes.rst:3560
msgid "Return the data in the buffer as a list of elements. ::"
msgstr "ãƒãƒƒãƒ•ã‚¡ä¸­ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¦ç´ ã®ãƒªã‚¹ãƒˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ ::"

#: ../../library/stdtypes.rst:3570
msgid ""
":meth:`tolist` now supports all single character native formats in "
":mod:`struct` module syntax as well as multi-dimensional representations."
msgstr ""
":meth:`tolist` ãŒ :mod:`struct` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ–‡æ³•ã«å«ã¾ã‚Œã‚‹ã™ã¹ã¦ã®å˜ä¸€æ–‡å­—ã® native "
"ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¨å¤šæ¬¡å…ƒã®è¡¨ç¾ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:3577
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a "
":class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"memoryview "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã£ã¦æ™’ã•ã‚Œã¦ã„ã‚‹ã€å…ƒã«ãªã‚‹ãƒãƒƒãƒ•ã‚¡ã‚’è§£æ”¾ã—ã¾ã™ã€‚å¤šãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ“ãƒ¥ãƒ¼ã«æ”¯é…ã•ã‚Œã¦ã„ã‚‹ã¨ãã«ç‰¹æ®Šãªãµã‚‹ã¾ã„ã‚’ã—ã¾ã™ (ä¾‹ãˆã°ã€ "
":class:`bytearray` ã¯å¤§ãã•ã®å¤‰æ›´ã‚’ä¸€æ™‚çš„ã«ç¦æ­¢ã—ã¾ã™)ã€‚ã§ã™ã‹ã‚‰ã€release() "
"ã‚’å‘¼ã³å‡ºã™ã“ã¨ã¯ã€ã“ã‚Œã‚‰ã®åˆ¶ç´„ã‚’ã§ãã‚‹ã ã‘æ—©ãå–ã‚Šé™¤ã (ãã—ã¦ã¶ã‚‰ä¸‹ãŒã£ãŸãƒªã‚½ãƒ¼ã‚¹ã‚’ã™ã¹ã¦è§£æ”¾ã™ã‚‹) ã®ã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3583
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚ŒãŸå¾Œã€ã“ã®ãƒ“ãƒ¥ãƒ¼ä¸Šã®ãã‚Œä»¥ä¸Šã®æ¼”ç®—ã¯ :class:`ValueError` ã‚’é€å‡ºã—ã¾ã™ (è¤‡æ•°å›å‘¼ã°ã‚Œãˆã‚‹ "
":meth:`release()` è‡ªèº«ã¯é™¤ãã¾ã™)::"

#: ../../library/stdtypes.rst:3594
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ã€ ``with`` æ–‡ã‚’ä½¿ã£ã¦åŒæ§˜ã®åŠ¹æœã‚’å¾—ã‚‹ã®ã«ä½¿ãˆã¾ã™::"

#: ../../library/stdtypes.rst:3610
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself"
" is not copied. Supported casts are 1D -> C-:term:`contiguous` and "
"C-contiguous -> 1D."
msgstr ""
"memoryview ã‚’æ–°ã—ã„ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‹ shape ã«ã‚­ãƒ£ã‚¹ãƒˆã—ã¾ã™ã€‚ *shape* ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ "
"``[byte_length//new_itemsize]`` ã§ã€ 1æ¬¡å…ƒé…åˆ—ã«ãªã‚Šã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ memoryview "
"ã§ã™ãŒã€ãƒãƒƒãƒ•ã‚¡ãƒ¼è‡ªä½“ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã›ã‚“ã€‚ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹å¤‰æ›ã¯ 1æ¬¡å…ƒé…åˆ— -> Cè¨€èªå‹ã®é€£ç¶šé…åˆ— ã¨ Cè¨€èªå‹ã®é€£ç¶šé…åˆ— -> 1æ¬¡å…ƒé…åˆ— "
"ã§ã™ï¼ˆå‚è€ƒ: :term:`contiguous`ï¼‰ã€‚"

#: ../../library/stdtypes.rst:3616
msgid ""
"The destination format is restricted to a single element native format in "
":mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length."
msgstr ""
"ã‚­ãƒ£ã‚¹ãƒˆå¾Œã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ :mod:`struct` æ–‡æ³•ã®å˜ä¸€è¦ç´ ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«åˆ¶é™ã•ã‚Œã¾ã™ã€‚ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ã†ã¡ã®ä¸€ã¤ã¯ãƒã‚¤ãƒˆãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"
" ('B', 'b', 'c') ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚çµæœã®ãƒã‚¤ãƒˆé•·ã¯ã‚ªãƒªã‚¸ãƒŠãƒ«ã®é•·ã•ã¨åŒã˜ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:3621
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "1D/long ã‹ã‚‰ 1D/unsigned byte ã¸ã®ã‚­ãƒ£ã‚¹ãƒˆ::"

#: ../../library/stdtypes.rst:3644
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "1D/unsigned byte ã‹ã‚‰ 1D/char ã¸ã®ã‚­ãƒ£ã‚¹ãƒˆ::"

#: ../../library/stdtypes.rst:3657
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "1D/byte ã‹ã‚‰ 3D/int ã¸ã€ãã—ã¦ 1D/signed char ã¸ã®ã‚­ãƒ£ã‚¹ãƒˆ::"

#: ../../library/stdtypes.rst:3683
msgid "Cast 1D/unsigned char to 2D/unsigned long::"
msgstr "1D/unsigned char ã‹ã‚‰ 2D/unsigned long ã¸ã®ã‚­ãƒ£ã‚¹ãƒˆ::"

#: ../../library/stdtypes.rst:3697
msgid "The source format is no longer restricted when casting to a byte view."
msgstr "å˜ãƒã‚¤ãƒˆã®ãƒ“ãƒ¥ãƒ¼ã¸ã‚­ãƒ£ã‚¹ãƒˆã™ã‚‹å ´åˆã€ã‚­ãƒ£ã‚¹ãƒˆå…ƒã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ã¤ã„ã¦åˆ¶ç´„ã¯ç„¡ããªã‚Šã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:3700
msgid "There are also several readonly attributes available:"
msgstr "èª­ã¿å‡ºã—å°‚ç”¨ã®å±æ€§ã‚‚ã„ãã¤ã‹ä½¿ãˆã¾ã™:"

#: ../../library/stdtypes.rst:3704
msgid "The underlying object of the memoryview::"
msgstr "memoryview ãŒå‚ç…§ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ::"

#: ../../library/stdtypes.rst:3715
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to len(m)::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. "
"ãã®é…åˆ—ãŒé€£ç¶šè¡¨ç¾ã«ãŠã„ã¦åˆ©ç”¨ã™ã‚‹ã‚¹ãƒšãƒ¼ã‚¹ã§ã™ã€‚ã“ã‚Œã¯ len(m) ã¨ä¸€è‡´ã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“::"

#: ../../library/stdtypes.rst:3734
msgid "Multi-dimensional arrays::"
msgstr "å¤šæ¬¡å…ƒé…åˆ—::"

#: ../../library/stdtypes.rst:3751
msgid "A bool indicating whether the memory is read only."
msgstr "ãƒ¡ãƒ¢ãƒªãŒèª­ã¿å‡ºã—å°‚ç”¨ã‹ã©ã†ã‹ã‚’ç¤ºã™çœŸå½å€¤ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3755
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"ãƒ“ãƒ¥ãƒ¼ã®ä¸­ã®å„è¦ç´ ã«å¯¾ã™ã‚‹ (:mod:`struct` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚¿ã‚¤ãƒ«ã®) ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’å«ã‚€æ–‡å­—åˆ—ã€‚ memoryview "
"ã¯ã€ä»»æ„ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ã‚’ä½¿ã£ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ã‚¿ãƒ¼ã‹ã‚‰ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã—ã‹ã—ã€ã„ãã¤ã‹ã®ãƒ¡ã‚½ãƒƒãƒ‰(ä¾‹ãˆã° :meth:`tolist`) "
"ã¯ãƒã‚¤ãƒ†ã‚£ãƒ–ã®å˜ä¸€è¦ç´ ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«åˆ¶é™ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3760
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ ``'B'`` ã¯ struct ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹æ–‡ã§æ‰±ã‚ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ã“ã‚Œã¯ ``memoryview(b'abc')[0] == "
"b'abc'[0] == 97`` ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3766
msgid "The size in bytes of each element of the memoryview::"
msgstr "memoryview ã®å„è¦ç´ ã®ãƒã‚¤ãƒˆå˜ä½ã®å¤§ãã•::"

#: ../../library/stdtypes.rst:3779
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr "ãƒ¡ãƒ¢ãƒªãŒè¡¨ã™å¤šæ¬¡å…ƒé…åˆ—ãŒä½•æ¬¡å…ƒã‹ã‚’ç¤ºã™æ•´æ•°ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3784
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr "ãƒ¡ãƒ¢ãƒªãŒè¡¨ã—ã¦ã„ã‚‹ N æ¬¡å…ƒé…åˆ—ã®å½¢çŠ¶ã‚’è¡¨ã™ã€é•·ã• :attr:`ndim` ã®æ•´æ•°ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3787 ../../library/stdtypes.rst:3795
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "ndim = 0 ã®å ´åˆã¯ ``None`` ã§ã¯ãªãç©ºã®ã‚¿ãƒ—ãƒ«ã¨ãªã‚‹ã‚ˆã†å¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/stdtypes.rst:3792
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr "é…åˆ—ã®ãã‚Œãã‚Œã®æ¬¡å…ƒã«å¯¾ã—ã¦ã€ãã‚Œãã‚Œã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ã«å¿…è¦ãªãƒã‚¤ãƒˆæ•°ã‚’è¡¨ã™ã€é•·ã• :attr:`ndim` ã®æ•´æ•°ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3800
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr "PILã‚¹ã‚¿ã‚¤ãƒ«ã®é…åˆ—ã®å†…éƒ¨ã§åˆ©ç”¨ã—ã¦ã„ã‚‹å€¤ã€‚ã“ã®å€¤ã¯ãŸã ã®æƒ…å ±ã¨ã—ã¦å…¬é–‹ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3804
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "ãƒ¡ãƒ¢ãƒªãƒ¼ãŒ C å½¢å¼ã®é †åºã§é€£ç¶šã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™çœŸå½å€¤ï¼ˆå‚è€ƒ: :term:`contiguous` ï¼‰ã€‚"

#: ../../library/stdtypes.rst:3810
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "ãƒ¡ãƒ¢ãƒªãƒ¼ãŒFortranå½¢å¼ã®é †åºã§é€£ç¶šã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™çœŸå½å€¤ï¼ˆå‚è€ƒ: :term:`contiguous` ï¼‰ã€‚"

#: ../../library/stdtypes.rst:3816
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "ãƒ¡ãƒ¢ãƒªãƒ¼ãŒé€£ç¶šã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™çœŸå½å€¤ï¼ˆå‚è€ƒ: :term:`contiguous` ï¼‰ã€‚"

#: ../../library/stdtypes.rst:3824
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "setï¼ˆé›†åˆï¼‰å‹ --- :class:`set`, :class:`frozenset`"

#: ../../library/stdtypes.rst:3828
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union,"
" difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the "
":mod:`collections` module.)"
msgstr ""
":dfn:`set` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€å›ºæœ‰ã® :term:`hashable` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é †åºãªã—ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚é€šå¸¸ã®ç”¨é€”ã«ã¯ã€å¸°å±ãƒ†ã‚¹ãƒˆã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‹ã‚‰ã®é‡è¤‡é™¤å»ã€ç©é›†åˆã€å’Œé›†åˆã€å·®é›†åˆã€å¯¾ç§°å·® (æ’ä»–çš„è«–ç†å’Œ) "
"ã®ã‚ˆã†ãªæ•°å­¦çš„æ¼”ç®—ã®è¨ˆç®—ãŒå«ã¾ã‚Œã¾ã™ã€‚(ä»–ã®ã‚³ãƒ³ãƒ†ãƒŠã«ã¤ã„ã¦ã¯çµ„ã¿è¾¼ã¿ã® :class:`dict`, :class:`list`, "
":class:`tuple` ã‚¯ãƒ©ã‚¹ã‚„ :mod:`collections` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚)"

#: ../../library/stdtypes.rst:3835
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x"
" in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"é›†åˆã¯ã€ä»–ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¨åŒæ§˜ã€ ``x in set``, ``len(set)``, ``for x in set`` "
"ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ã¯é †åºãŒãªã„ã®ã§ã€é›†åˆã¯æŒ¿å…¥ã®é †åºã‚„è¦ç´ ã®ä½ç½®ã‚’è¨˜éŒ²ã—ã¾ã›ã‚“ã€‚å¾“ã£ã¦ã€é›†åˆã¯ã‚¤ãƒ³ãƒ‡ã‚¯ã‚·ãƒ³ã‚°ã€ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ã€ãã®ä»–ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹çš„ãªæŒ¯èˆã„ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:3840
msgid ""
"There are currently two built-in set types, :class:`set` and "
":class:`frozenset`. The :class:`set` type is mutable --- the contents can be"
" changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since"
" it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type"
" is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element"
" of another set."
msgstr ""
":class:`set` ãŠã‚ˆã³ :class:`frozenset` ã¨ã„ã†ã€2ã¤ã®çµ„ã¿è¾¼ã¿ã®é›†åˆå‹ãŒã‚ã‚Šã¾ã™ã€‚ :class:`set` "
"ã¯ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã§ã€:meth:`~set.add` ã‚„ :meth:`~set.remove` "
"ã®ã‚ˆã†ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦å†…å®¹ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªãŸã‚ã€ãƒãƒƒã‚·ãƒ¥å€¤ã‚’æŒãŸãšã€ã¾ãŸè¾æ›¸ã®ã‚­ãƒ¼ã‚„ä»–ã®é›†åˆã®è¦ç´ ã¨ã—ã¦ç”¨ã„ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ä¸€æ–¹ã€:class:`frozenset`"
" å‹ã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã§ã€:term:`ãƒãƒƒã‚·ãƒ¥å¯èƒ½<hashable>` "
"ã§ã™ã€‚ä½œæˆå¾Œã«å†…å®¹ã‚’æ”¹å¤‰ã§ããªã„ãŸã‚ã€è¾æ›¸ã®ã‚­ãƒ¼ã‚„ä»–ã®é›†åˆã®è¦ç´ ã¨ã—ã¦ç”¨ã„ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3848
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"ç©ºã§ãªã„ :class:`set` (:class:`frozenset` ã§ã¯ãªã„) ã¯ã€:class:`set` "
"ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«åŠ ãˆã€è¦ç´ ã‚’æ³¢æ‹¬å¼§ä¸­ã«ã‚«ãƒ³ãƒã§åŒºåˆ‡ã£ã¦åˆ—æŒ™ã™ã‚‹ã“ã¨ã§ã‚‚ç”Ÿæˆã§ãã¾ã™ã€‚ä¾‹: ``{'jack', 'sjoerd'}``ã€‚"

#: ../../library/stdtypes.rst:3852
msgid "The constructors for both classes work the same:"
msgstr "ã©ã¡ã‚‰ã®ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚‚åŒæ§˜ã«åƒãã¾ã™:"

#: ../../library/stdtypes.rst:3857
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"*iterable* ã‹ã‚‰è¦ç´ ã‚’å–ã‚Šè¾¼ã‚“ã ã€æ–°ã—ã„ :class:`set` ã‚‚ã—ãã¯ :class:`frozenset` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ "
"é›†åˆã®è¦ç´ ã¯ :term:`ãƒãƒƒã‚·ãƒ¥å¯èƒ½ <hashable>` ãªã‚‚ã®ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚é›†åˆã®é›†åˆã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ã¯ã€å†…å´ã®é›†åˆã¯ "
":class:`frozenset` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚*iterable* ãŒæŒ‡å®šã•ã‚Œãªã„å ´åˆã€æ–°ã—ã„ç©ºã®é›†åˆãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3863
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ":class:`set` ãŠã‚ˆã³ :class:`frozenset` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ä»¥ä¸‹ã®æ“ä½œã‚’æä¾›ã—ã¾ã™:"

#: ../../library/stdtypes.rst:3868
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "é›†åˆ *s* ã®è¦ç´ æ•° (*s* ã®æ¿ƒåº¦) ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3872
msgid "Test *x* for membership in *s*."
msgstr "*x* ãŒ *s* ã®ãƒ¡ãƒ³ãƒãƒ¼ã«å«ã¾ã‚Œã‚‹ã‹åˆ¤å®šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3876
msgid "Test *x* for non-membership in *s*."
msgstr "*x* ãŒ *s* ã®ãƒ¡ãƒ³ãƒãƒ¼ã«å«ã¾ã‚Œã¦ã„ãªã„ã“ã¨ã‚’åˆ¤å®šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3880
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are"
" disjoint if and only if their intersection is the empty set."
msgstr ""
"é›†åˆãŒ *other* ã¨å…±é€šã®è¦ç´ ã‚’æŒãŸãªã„ã¨ãã€``True`` ã‚’è¿”ã—ã¾ã™ã€‚é›†åˆã¯ãã‚Œã‚‰ã®ç©é›†åˆãŒç©ºé›†åˆã¨ãªã‚‹ã¨ãã®ã¿ã€äº’ã„ã«ç´  "
"(disjoint) ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3886
msgid "Test whether every element in the set is in *other*."
msgstr "set ã®å…¨ã¦ã®è¦ç´ ãŒ *other* ã«å«ã¾ã‚Œã‚‹ã‹åˆ¤å®šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3890
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"set ãŒ *other* ã®çœŸéƒ¨åˆ†é›†åˆã§ã‚ã‚‹ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ ``set <= other and set != other`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3896
msgid "Test whether every element in *other* is in the set."
msgstr "*other* ã®å…¨ã¦ã®è¦ç´ ãŒ set ã«å«ã¾ã‚Œã‚‹ã‹åˆ¤å®šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3900
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"set ãŒ *other* ã®çœŸä¸Šä½é›†åˆã§ã‚ã‚‹ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ ``set >= other and set != other`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3906
msgid "Return a new set with elements from the set and all others."
msgstr "set ã¨å…¨ã¦ã® other ã®è¦ç´ ã‹ã‚‰ãªã‚‹æ–°ã—ã„é›†åˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3911
msgid "Return a new set with elements common to the set and all others."
msgstr "set ã¨å…¨ã¦ã® other ã«å…±é€šã™ã‚‹è¦ç´ ã‚’æŒã¤ã€æ–°ã—ã„é›†åˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3916
msgid "Return a new set with elements in the set that are not in the others."
msgstr "set ã«å«ã¾ã‚Œã¦ã€ã‹ã¤ã€å…¨ã¦ã® other ã«å«ã¾ã‚Œãªã„è¦ç´ ã‚’æŒã¤ã€æ–°ã—ã„é›†åˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3921
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr "set ã¨ *other* ã®ã„ãšã‚Œã‹ä¸€æ–¹ã ã‘ã«å«ã¾ã‚Œã‚‹è¦ç´ ã‚’æŒã¤æ–°ã—ã„é›†åˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3925
msgid "Return a new set with a shallow copy of *s*."
msgstr "*s* ã®æµ…ã„ã‚³ãƒ”ãƒ¼ã‚’æ–°ã—ã„é›†åˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3928
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, "
":meth:`difference`, and :meth:`symmetric_difference`, :meth:`issubset`, and "
":meth:`issuperset` methods will accept any iterable as an argument.  In "
"contrast, their operator based counterparts require their arguments to be "
"sets.  This precludes error-prone constructions like ``set('abc') & 'cbs'`` "
"in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"ãªãŠã€æ¼”ç®—å­ã§ãªã„ç‰ˆã® :meth:`union`, :meth:`intersection`, :meth:`difference`, "
":meth:`symmetric_difference`, :meth:`issubset`, :meth:`issuperset` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä»»æ„ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’å¼•æ•°ã¨ã—ã¦å—ã‘ä»˜ã‘ã¾ã™ã€‚å¯¾ã—ã¦ã€æ¼”ç®—å­ã‚’ä½¿ã†ç‰ˆã§ã¯ã€å¼•æ•°ã¯é›†åˆã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€``set('abc') & "
"'cbs'`` ã®ã‚ˆã†ãªèª¤ã‚ŠãŒã¡ãªæ§‹æ–‡ã‚’äºˆé˜²ã—ã€ã‚ˆã‚Šèª­ã¿ã‚„ã™ã„ ``set('abc').intersection('cbs')`` ã‚’æ”¯æŒã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3935
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two"
" sets are equal if and only if every element of each set is contained in the"
" other (each is a subset of the other). A set is less than another set if "
"and only if the first set is a proper subset of the second set (is a subset,"
" but is not equal). A set is greater than another set if and only if the "
"first set is a proper superset of the second set (is a superset, but is not "
"equal)."
msgstr ""
":class:`set` ã¨ :class:`frozenset` "
"ã®ã©ã¡ã‚‰ã‚‚ã€é›†åˆåŒå£«ã®æ¯”è¼ƒã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚äºŒã¤ã®é›†åˆã¯ã€ãã‚Œãã‚Œã®é›†åˆã®è¦ç´ å…¨ã¦ãŒä»–æ–¹ã«ã‚‚å«ã¾ã‚Œã¦ã„ã‚‹ (äº’ã„ã«ä»–æ–¹ã®éƒ¨åˆ†é›†åˆã§ã‚ã‚‹) "
"ã¨ãã€ã‹ã¤ãã®ã¨ãã«é™ã‚Šç­‰ã—ã„ã§ã™ã€‚ä¸€æ–¹ã®é›†åˆãŒä»–æ–¹ã®é›†åˆã®çœŸéƒ¨åˆ†é›†åˆã§ã‚ã‚‹ (éƒ¨åˆ†é›†åˆã§ã‚ã‚‹ãŒç­‰ã—ããªã„) "
"ã¨ãã€ã‹ã¤ãã®ã¨ãã«é™ã‚Šä¸€æ–¹ã®é›†åˆã¯ä»–æ–¹ã®é›†åˆã‚ˆã‚Šå°ã•ã„ã§ã™ã€‚ä¸€æ–¹ã®é›†åˆãŒä»–æ–¹ã®é›†åˆã®çœŸä¸Šä½é›†åˆã§ã‚ã‚‹ (ä¸Šä½é›†åˆã§ã‚ã‚‹ãŒç­‰ã—ããªã„) "
"ã¨ãã€ã‹ã¤ãã®ã¨ãã«é™ã‚Šä¸€æ–¹ã®é›†åˆã¯ä»–æ–¹ã®é›†åˆã‚ˆã‚Šå¤§ãã„ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3942
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
":class:`set` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ :class:`frozenset` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã€è¦ç´ ã«åŸºã¥ã„ã¦æ¯”è¼ƒã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ "
"``set('abc') == frozenset('abc')`` ã‚„ ``set('abc') in "
"set([frozenset('abc')])`` ã¯ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3946
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are"
" not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"éƒ¨åˆ†é›†åˆã¨ç­‰ä¾¡æ€§ã®æ¯”è¼ƒã¯å…¨é †åºä»˜ã‘ã‚’è¡Œã†é–¢æ•°ã¸ã¨ä¸€èˆ¬åŒ–ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€äº’ã„ã«ç´ ã§ã‚ã‚‹äºŒã¤ã®éç©ºé›†åˆã¯ã€ç­‰ã—ããªãã€ä»–æ–¹ã®éƒ¨åˆ†é›†åˆã§ã‚‚ã‚ã‚Šã¾ã›ã‚“ã‹ã‚‰ã€ä»¥ä¸‹ã®"
" *ã™ã¹ã¦* ã« ``False`` ã‚’è¿”ã—ã¾ã™: ``a<b``, ``a==b``, ãã—ã¦ ``a>b``."

#: ../../library/stdtypes.rst:3951
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr "é›†åˆã¯åŠé †åºï¼ˆéƒ¨åˆ†é›†åˆé–¢ä¿‚ï¼‰ã—ã‹å®šç¾©ã—ãªã„ã®ã§ã€é›†åˆã®ãƒªã‚¹ãƒˆã«ãŠã‘ã‚‹ :meth:`list.sort` ãƒ¡ã‚½ãƒƒãƒ‰ã®å‡ºåŠ›ã¯æœªå®šç¾©ã§ã™ã€‚"

#: ../../library/stdtypes.rst:3954
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr "é›†åˆã®è¦ç´ ã¯ã€è¾æ›¸ã®ã‚­ãƒ¼ã®ã‚ˆã†ã«ã€ãƒãƒƒã‚·ãƒ¥å¯èƒ½ (:term:`hashable`) ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:3956
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
":class:`set` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ :class:`frozenset` "
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–ã‚Šæ··ãœã¦ã®äºŒé …æ¼”ç®—ã¯ã€ç¬¬ä¸€è¢«æ¼”ç®—å­ã®å‹ã‚’è¿”ã—ã¾ã™ã€‚ä¾‹ãˆã°: ``frozenset('ab') | set('bc')`` ã¯ "
":class:`frozenset` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3960
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"ä»¥ä¸‹ã®è¡¨ã«æŒ™ã’ã‚‹æ¼”ç®—ã¯ :class:`set` ã«é©ç”¨ã•ã‚Œã¾ã™ãŒã€:class:`frozenset` "
"ã®ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã¯é©ç”¨ã•ã‚Œã¾ã›ã‚“:"

#: ../../library/stdtypes.rst:3966
msgid "Update the set, adding elements from all others."
msgstr "å…¨ã¦ã® other ã®è¦ç´ ã‚’è¿½åŠ ã—ã€ set ã‚’æ›´æ–°ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3971
msgid "Update the set, keeping only elements found in it and all others."
msgstr "å…ƒã® set ã¨å…¨ã¦ã® other ã«å…±é€šã™ã‚‹è¦ç´ ã ã‘ã‚’æ®‹ã—ã¦ set ã‚’æ›´æ–°ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3976
msgid "Update the set, removing elements found in others."
msgstr "*other* ã«å«ã¾ã‚Œã‚‹è¦ç´ ã‚’å–ã‚Šé™¤ãã€ set ã‚’æ›´æ–°ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3981
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr "ã©ã¡ã‚‰ã‹ã«ã®ã¿å«ã¾ã‚Œã¦ã€å…±é€šã«ã¯æŒãŸãªã„è¦ç´ ã®ã¿ã§ set ã‚’æ›´æ–°ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3985
msgid "Add element *elem* to the set."
msgstr "è¦ç´  *elem* ã‚’ set ã«è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3989
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not"
" contained in the set."
msgstr ""
"è¦ç´  *elem* ã‚’ set ã‹ã‚‰å–ã‚Šé™¤ãã¾ã™ã€‚*elem* ãŒ set ã«å«ã¾ã‚Œã¦ã„ãªã‘ã‚Œã° :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3994
msgid "Remove element *elem* from the set if it is present."
msgstr "è¦ç´  *elem* ãŒ set ã«å«ã¾ã‚Œã¦ã„ã‚Œã°ã€å–ã‚Šé™¤ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:3998
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError`"
" if the set is empty."
msgstr "*s* ã‹ã‚‰ä»»æ„ã®è¦ç´ ã‚’å–ã‚Šé™¤ãã€ãã‚Œã‚’è¿”ã—ã¾ã™ã€‚é›†åˆãŒç©ºã®å ´åˆã€ :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™"

#: ../../library/stdtypes.rst:4003
msgid "Remove all elements from the set."
msgstr "set ã®å…¨ã¦ã®è¦ç´ ã‚’å–ã‚Šé™¤ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4006
msgid ""
"Note, the non-operator versions of the :meth:`update`, "
":meth:`intersection_update`, :meth:`difference_update`, and "
":meth:`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"ãªãŠã€æ¼”ç®—å­ã§ãªã„ç‰ˆã® :meth:`update`, :meth:`intersection_update`, "
":meth:`difference_update`, ãŠã‚ˆã³ :meth:`symmetric_difference_update` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä»»æ„ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’å¼•æ•°ã¨ã—ã¦å—ã‘ä»˜ã‘ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4011
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and "
":meth:`discard` methods may be a set.  To support searching for an "
"equivalent frozenset, a temporary one is created from *elem*."
msgstr ""
":meth:`__contains__`, :meth:`remove`, :meth:`discard` ãƒ¡ã‚½ãƒƒãƒ‰ã®å¼•æ•° *elem* ã¯é›†åˆã‹ã‚‚ã—ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚\n"
"ãã®é›†åˆã¨ç­‰ä¾¡ãª :class:`frozenset` ã®æ¤œç´¢ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ã€ *elem* ã‹ã‚‰ä¸€æ™‚çš„ãª frozenset ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4019
msgid "Mapping Types --- :class:`dict`"
msgstr "ãƒãƒƒãƒ”ãƒ³ã‚°å‹ --- :class:`dict`"

#: ../../library/stdtypes.rst:4029
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in "
":class:`list`, :class:`set`, and :class:`tuple` classes, and the "
":mod:`collections` module.)"
msgstr ""
"ãƒãƒƒãƒ”ãƒ³ã‚° (:term:`mapping`) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒãƒƒã‚·ãƒ¥å¯èƒ½ (:term:`hashable`) "
"ãªå€¤ã‚’ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾å¿œä»˜ã‘ã¾ã™ã€‚ãƒãƒƒãƒ”ãƒ³ã‚°ã¯ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ç¾åœ¨ã€æ¨™æº–ãƒãƒƒãƒ”ãƒ³ã‚°å‹ã¯è¾æ›¸ (:dfn:`dictionary`)"
" ã ã‘ã§ã™ã€‚ (ä»–ã®ã‚³ãƒ³ãƒ†ãƒŠã«ã¤ã„ã¦ã¯çµ„ã¿è¾¼ã¿ã® :class:`list`, :class:`set`, ãŠã‚ˆã³ :class:`tuple` "
"ã‚¯ãƒ©ã‚¹ã¨ã€ :mod:`collections` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚)"

#: ../../library/stdtypes.rst:4035
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not "
":term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys.  Numeric types used for keys obey the normal rules "
"for numeric comparison: if two numbers compare equal (such as ``1`` and "
"``1.0``) then they can be used interchangeably to index the same dictionary "
"entry.  (Note however, that since computers store floating-point numbers as "
"approximations it is usually unwise to use them as dictionary keys.)"
msgstr ""
"è¾æ›¸ã®ã‚­ãƒ¼ã¯ *ã»ã¼* ä»»æ„ã®å€¤ã§ã™ã€‚ãƒãƒƒã‚·ãƒ¥å¯èƒ½ (:term:`hashable`) ã§ãªã„å€¤ã€ã¤ã¾ã‚Šã€ãƒªã‚¹ãƒˆã‚„è¾æ›¸ãã®ä»–ã®ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªå‹ "
"(ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŒä¸€æ€§ã§ã¯ãªãå€¤ã§æ¯”è¼ƒã•ã‚Œã‚‹ã‚‚ã®) ã¯ã‚­ãƒ¼ã¨ã—ã¦ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚ã‚­ãƒ¼ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹æ•°å€¤å‹ã¯é€šå¸¸ã®æ•°å€¤æ¯”è¼ƒã®ãƒ«ãƒ¼ãƒ«ã«å¾“ã„ã¾ã™: "
"ã‚‚ã—ãµãŸã¤ã®æ•°å€¤ãŒ (ä¾‹ãˆã° ``1`` ã¨ ``1.0`` ã®ã‚ˆã†ã«) ç­‰ã—ã‘ã‚Œã°ã€åŒã˜è¾æ›¸ã®é …ç›®ã¨ã—ã¦äº’æ›çš„ã«ä½¿ç”¨ã§ãã¾ã™ã€‚ "
"(ãŸã ã—ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã¯æµ®å‹•å°æ•°ç‚¹æ•°ã‚’è¿‘ä¼¼å€¤ã¨ã—ã¦ä¿ç®¡ã™ã‚‹ã®ã§ã€è¾æ›¸å‹ã®ã‚­ãƒ¼ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ã®ã¯ãŸã„ã¦ã„è³¢ãã‚ã‚Šã¾ã›ã‚“ã€‚)"

#: ../../library/stdtypes.rst:4044
msgid ""
"Dictionaries can be created by placing a comma-separated list of ``key: "
"value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}``"
" or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` constructor."
msgstr ""
"è¾æ›¸ã¯ ``key: value`` å¯¾ã®ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã®ãƒªã‚¹ãƒˆã‚’æ³¢æ‹¬å¼§ã§ããã‚‹ã“ã¨ã§ä½œæˆã§ãã¾ã™ã€‚ä¾‹ãˆã°: ``{'jack': 4098, "
"'sjoerd': 4127}`` ã‚ã‚‹ã„ã¯ ``{4098: 'jack', 4127: 'sjoerd'}`` ã€‚ã‚ã‚‹ã„ã¯ã€ "
":class:`dict` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã‚‚ä½œæˆã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4052
msgid ""
"Return a new dictionary initialized from an optional positional argument and"
" a possibly empty set of keyword arguments."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ä½ç½®å¼•æ•°ã¨ç©ºã®å¯èƒ½æ€§ã‚‚ã‚ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®é›†åˆã«ã‚ˆã‚ŠåˆæœŸåŒ–ã•ã‚ŒãŸæ–°ã—ã„è¾æ›¸ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4055
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the"
" positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""
"ä½ç½®å¼•æ•°ãŒä½•ã‚‚ä¸ãˆã‚‰ã‚Œãªã‹ã£ãŸå ´åˆã€ç©ºã®è¾æ›¸ãŒä½œæˆã•ã‚Œã¾ã™ã€‚ä½ç½®å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œã€ãã‚ŒãŒãƒãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã ã£ãŸå ´åˆã€ãã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒã˜ã‚­ãƒ¼ã¨å€¤ã®ãƒšã‚¢ã‚’æŒã¤è¾æ›¸ãŒä½œæˆã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã€ä½ç½®å¼•æ•°ã¯"
" :term:`iterable` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚iterable ã®ãã‚Œãã‚Œã®è¦ç´ è‡ªèº«ã¯ã€ã¡ã‚‡ã†ã© 2 "
"å€‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒã¤ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã‚Œãã‚Œã®è¦ç´ ã®æœ€åˆã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ–°ã—ã„è¾æ›¸ã®ã‚­ãƒ¼ã«ãªã‚Šã€2 "
"ç•ªç›®ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã‚Œã«å¯¾å¿œã™ã‚‹å€¤ã«ãªã‚Šã¾ã™ã€‚åŒä¸€ã®ã‚­ãƒ¼ãŒ 2 å›ä»¥ä¸Šç¾ã‚ŒãŸå ´åˆã¯ã€ãã®ã‚­ãƒ¼ã®æœ€å¾Œã®å€¤ãŒæ–°ã—ã„è¾æ›¸ã§ã®å¯¾å¿œã™ã‚‹å€¤ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4065
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces"
" the value from the positional argument."
msgstr ""
"ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ãã®å€¤ãŒä½ç½®å¼•æ•°ã‹ã‚‰ä½œã‚‰ã‚ŒãŸè¾æ›¸ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚æ—¢ã«å­˜åœ¨ã—ã¦ã„ã‚‹ã‚­ãƒ¼ãŒè¿½åŠ ã•ã‚ŒãŸå ´åˆã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®å€¤ã¯ä½ç½®å¼•æ•°ã®å€¤ã‚’ç½®ãæ›ãˆã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4070
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr "ä¾‹ã‚’å‡ºã™ã¨ã€æ¬¡ã®ä¾‹ã¯å…¨ã¦ ``{\"one\": 1, \"two\": 2, \"three\": 3}`` ã«ç­‰ã—ã„è¾æ›¸ã‚’è¿”ã—ã¾ã™::"

#: ../../library/stdtypes.rst:4081
msgid ""
"Providing keyword arguments as in the first example only works for keys that"
" are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"æœ€åˆã®ä¾‹ã®ã‚ˆã†ã«ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ä¸ãˆã‚‹æ–¹æ³•ã§ã¯ã€ã‚­ãƒ¼ã¯æœ‰åŠ¹ãª Python "
"ã®è­˜åˆ¥å­ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã®æ–¹æ³•ã§ã¯ã€è¾æ›¸ã®ã‚­ãƒ¼ã¨ã—ã¦æœ‰åŠ¹ãªã©ã‚“ãªã‚­ãƒ¼ã§ã‚‚ä½¿ãˆã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4085
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr "ä»¥ä¸‹ã¯è¾æ›¸å‹ãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹æ“ä½œã§ã™ (ãã‚Œã‚†ãˆã€ã‚«ã‚¹ã‚¿ãƒ ã®ãƒãƒƒãƒ—å‹ã‚‚ã“ã‚Œã‚‰ã®æ“ä½œã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã¹ãã§ã™):"

#: ../../library/stdtypes.rst:4090
msgid "Return the number of items in the dictionary *d*."
msgstr "è¾æ›¸ *d* ã®é …ç›®æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4094
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is"
" not in the map."
msgstr "*d* ã®ã‚­ãƒ¼ *key* ã®é …ç›®ã‚’è¿”ã—ã¾ã™ã€‚ãƒãƒƒãƒ—ã« *key* ãŒå­˜åœ¨ã—ãªã‘ã‚Œã°ã€ :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4099
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, "
":exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot "
"be an instance variable::"
msgstr ""
"è¾æ›¸ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒ :meth:`__missing__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã¦ã€ *key* ãŒå­˜åœ¨ã—ãªã„å ´åˆã€ ``d[key]`` "
"æ¼”ç®—ã¯ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚­ãƒ¼ *key* ã‚’å¼•æ•°ã¨ã—ã¦å‘¼ã³å‡ºã—ã¾ã™ã€‚ ``d[key]`` æ¼”ç®—ã¯ã€ ``__missing__(key)`` "
"ã®å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦è¿”ã•ã‚ŒãŸå€¤ã‚’ãã®ã¾ã¾è¿”ã™ã‹ã€é€å‡ºã•ã‚ŒãŸã‚‚ã®ã‚’ãã®ã¾ã¾é€å‡ºã—ã¾ã™ã€‚ä»–ã®æ¼”ç®—ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :meth:`__missing__` "
"ã‚’å‘¼ã³å‡ºã—ã¾ã›ã‚“ã€‚ :meth:`__missing__` ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ :exc:`KeyError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ "
":meth:`__missing__` ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã§ã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“::"

#: ../../library/stdtypes.rst:4117
msgid ""
"The example above shows part of the implementation of "
":class:`collections.Counter`.  A different ``__missing__`` method is used by"
" :class:`collections.defaultdict`."
msgstr ""
"ã“ã“ã§ãŠè¦‹ã›ã—ãŸä¾‹ã¯ :class:`collections.Counter` å®Ÿè£…ã®ä¸€éƒ¨ã§ã™ã€‚ã“ã‚Œã¨ã¯é•ã£ãŸ ``__missing__`` ãŒ "
":class:`collections.defaultdict` ã§ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4123
msgid "Set ``d[key]`` to *value*."
msgstr "``d[key]`` ã« *value* ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4127
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the"
" map."
msgstr "*d* ã‹ã‚‰ ``d[key]`` ã‚’å‰Šé™¤ã—ã¾ã™ã€‚ãƒãƒƒãƒ—ã« *key* ãŒå­˜åœ¨ã—ãªã‘ã‚Œã°ã€ :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4132
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "*d* ãŒã‚­ãƒ¼ *key* ã‚’æŒã£ã¦ã„ã‚Œã° ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã°ã€ ``False`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4136
msgid "Equivalent to ``not key in d``."
msgstr "``not key in d`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4140
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr "è¾æ›¸ã®ã‚­ãƒ¼ã«æ¸¡ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯ ``iter(d.keys())`` ã¸ã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã§ã™ã€‚"

#: ../../library/stdtypes.rst:4145
msgid "Remove all items from the dictionary."
msgstr "è¾æ›¸ã®å…¨ã¦ã®é …ç›®ã‚’æ¶ˆå»ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4149
msgid "Return a shallow copy of the dictionary."
msgstr "è¾æ›¸ã®æµ…ã„ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4153
msgid ""
"Create a new dictionary with keys from *seq* and values set to *value*."
msgstr "*seq* ã‹ã‚‰ã‚­ãƒ¼ã‚’å–ã‚Šã€å€¤ã‚’ *value* ã«è¨­å®šã—ãŸã€æ–°ã—ã„è¾æ›¸ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4155
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``."
msgstr ":meth:`fromkeys` ã¯æ–°ã—ã„è¾æ›¸ã‚’è¿”ã™ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ *value* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ ``None`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4160
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If"
" *default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"*key* ãŒè¾æ›¸ã«ã‚ã‚Œã° *key* ã«å¯¾ã™ã‚‹å€¤ã‚’ã€ãã†ã§ãªã‘ã‚Œã° *default* ã‚’è¿”ã—ã¾ã™ã€‚ *default* "
"ãŒä¸ãˆã‚‰ã‚Œãªã‹ã£ãŸå ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``None`` ã¨ãªã‚Šã¾ã™ã€‚ãã®ãŸã‚ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :exc:`KeyError` "
"ã‚’é€å‡ºã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:4166
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"è¾æ›¸ã®é …ç›® (``(key, value)`` å¯¾) ã®æ–°ã—ã„ãƒ“ãƒ¥ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚:ref:`ãƒ“ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ <dict-views>`"
" ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:4171
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr "è¾æ›¸ã®ã‚­ãƒ¼ã®æ–°ã—ã„ãƒ“ãƒ¥ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚:ref:`ãƒ“ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ <dict-views>` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:4176
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a "
":exc:`KeyError` is raised."
msgstr ""
"*key* ãŒè¾æ›¸ã«å­˜åœ¨ã™ã‚Œã°ãã®å€¤ã‚’è¾æ›¸ã‹ã‚‰æ¶ˆå»ã—ã¦è¿”ã—ã€ãã†ã§ãªã‘ã‚Œã° *default* ã‚’è¿”ã—ã¾ã™ã€‚ *default* ãŒä¸ãˆã‚‰ãšã€ã‹ã¤ "
"*key* ãŒè¾æ›¸ã«å­˜åœ¨ã—ãªã‘ã‚Œã° :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4182
msgid ""
"Remove and return an arbitrary ``(key, value)`` pair from the dictionary."
msgstr "ä»»æ„ã® ``(key, value)`` å¯¾ã‚’è¾æ›¸ã‹ã‚‰æ¶ˆå»ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4184
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling "
":meth:`popitem` raises a :exc:`KeyError`."
msgstr ""
"é›†åˆã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ä½¿ã‚ã‚Œã‚‹ã®ã¨åŒã˜ã‚ˆã†ã«ã€ :meth:`popitem` ã¯è¾æ›¸ã«ç¹°ã‚Šè¿”ã—é©ç”¨ã—ã¦æ¶ˆå»ã™ã‚‹ã®ã«ä¾¿åˆ©ã§ã™ã€‚è¾æ›¸ãŒç©ºã§ã‚ã‚Œã°ã€ "
":meth:`popitem` ã®å‘¼ã³å‡ºã—ã¯ :exc:`KeyError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4190
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"ã‚‚ã—ã€ *key* ãŒè¾æ›¸ã«å­˜åœ¨ã™ã‚Œã°ã€ãã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€å€¤ã‚’ *default* ã¨ã—ã¦ *key* ã‚’æŒ¿å…¥ã—ã€ *default* "
"ã‚’è¿”ã—ã¾ã™ã€‚ *default* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``None`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4196
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr "è¾æ›¸ã®å†…å®¹ã‚’ *other* ã®ã‚­ãƒ¼ã¨å€¤ã§æ›´æ–°ã—ã¾ã™ã€‚æ—¢å­˜ã®ã‚­ãƒ¼ã¯ä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚è¿”ã‚Šå€¤ã¯ ``None`` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4199
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value"
" pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":meth:`update` ã¯ã€ä»–ã®è¾æ›¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚ã‚­ãƒ¼/å€¤ã®å¯¾ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ« (ã‚¿ãƒ—ãƒ«ã€ã‚‚ã—ãã¯ã€é•·ã•ãŒ2ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«) "
"ã§ã‚‚ã€ã©ã¡ã‚‰ã§ã‚‚å—ã‘ä»˜ã‘ã¾ã™ã€‚ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ãŒæŒ‡å®šã•ã‚Œã‚Œã°ã€ãã®ã‚­ãƒ¼/å€¤ã®å¯¾ã§è¾æ›¸ã‚’æ›´æ–°ã—ã¾ã™: ``d.update(red=1, "
"blue=2)``ã€‚"

#: ../../library/stdtypes.rst:4206
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr "è¾æ›¸ã®å€¤ã®æ–°ã—ã„ãƒ“ãƒ¥ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚:ref:`ãƒ“ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ <dict-views>` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:4209
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs. Order comparisons ('<', '<=', '>=', '>') raise "
":exc:`TypeError`."
msgstr ""
"è¤‡æ•°ã®è¾æ›¸ã¯ã€åŒã˜ ``(key, value)`` ã®å¯¾ã‚’æŒã¤å ´åˆã«ã€ãã—ã¦ãã®å ´åˆã«ã®ã¿ç­‰ã—ããªã‚Šã¾ã™ã€‚é †åºæ¯”è¼ƒ ('<', '<=', '>=',"
" '>') ã¯ :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4214
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a "
":class:`dict`."
msgstr ""
":class:`dict` ã®èª­ã¿å‡ºã—å°‚ç”¨ãƒ“ãƒ¥ãƒ¼ã‚’ä½œã‚‹ãŸã‚ã« :class:`types.MappingProxyType` ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4221
msgid "Dictionary view objects"
msgstr "è¾æ›¸ãƒ“ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:4223
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and "
":meth:`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view"
" reflects these changes."
msgstr ""
":meth:`dict.keys`, :meth:`dict.values`, :meth:`dict.items` ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ "
"*ãƒ“ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ* ã§ã™ã€‚ã“ã‚Œã‚‰ã¯ã€è¾æ›¸ã®é …ç›®ã®å‹•çš„ãªãƒ“ãƒ¥ãƒ¼ã‚’æä¾›ã—ã€è¾æ›¸ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚ã€ãƒ“ãƒ¥ãƒ¼ã¯ãã®å¤‰æ›´ã‚’åæ˜ ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4228
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr "è¾æ›¸ãƒ“ãƒ¥ãƒ¼ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã“ã¨ã§å¯¾å¿œã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’ yield ã§ãã¾ã™ã€‚ã¾ãŸã€å¸°å±åˆ¤å®šã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™:"

#: ../../library/stdtypes.rst:4233
msgid "Return the number of entries in the dictionary."
msgstr "è¾æ›¸ã®é …ç›®æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4237
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr "è¾æ›¸ã®ã‚­ãƒ¼ã€å€¤ã€ã¾ãŸã¯ (``(key, value)`` ã®ã‚¿ãƒ—ãƒ«ã¨ã—ã¦è¡¨ã•ã‚Œã‚‹) é …ç›®ã«æ¸¡ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4240
msgid ""
"Keys and values are iterated over in an arbitrary order which is non-random,"
" varies across Python implementations, and depends on the dictionary's "
"history of insertions and deletions. If keys, values and items views are "
"iterated over with no intervening modifications to the dictionary, the order"
" of items will directly correspond.  This allows the creation of ``(value, "
"key)`` pairs using :func:`zip`: ``pairs = zip(d.values(), d.keys())``.  "
"Another way to create the same list is ``pairs = [(v, k) for (k, v) in "
"d.items()]``."
msgstr ""
"ã‚­ãƒ¼ã¨å€¤ã®ãƒªã‚¹ãƒˆã¯ã‚ã‚‹ä»»æ„ã®é †åºã§ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã•ã‚Œã¾ã™ãŒã€ãƒ©ãƒ³ãƒ€ãƒ ã§ã¯ãªãã€ Python "
"ã®å®Ÿè£…ã«ã‚ˆã£ã¦å¤‰ã‚ã‚Šã€è¾æ›¸ã¸ã®æŒ¿å…¥ã‚„å‰Šé™¤ã®å±¥æ­´ã«ä¾å­˜ã—ã¾ã™ã€‚ã‚­ãƒ¼ã€å€¤ã€è¦ç´ ã®ãƒ“ãƒ¥ãƒ¼ã‚’é€šã—ã¦ã€è¾æ›¸ã®å¤‰æ›´ã‚’æŒŸã¾ãšã«ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã•ã‚ŒãŸã‚‰ã€ãã®è¦ç´ ã®é †åºã¯å®Œå…¨ã«ä¸€è‡´ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€"
" ``(value, key)`` ã®å¯¾ã‚’ :func:`zip` ã§ä½œæˆã§ãã¾ã™: ``pairs = zip(d.values(), "
"d.keys())`` ã€‚åŒã˜ãƒªã‚¹ãƒˆã‚’ä½œæˆã™ã‚‹ä»–ã®æ–¹æ³•ã¯ã€ ``pairs = [(v, k) for (k, v) in d.items()]`` "
"ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4248
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise"
" a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"è¾æ›¸ã®é …ç›®ã®è¿½åŠ ã‚„å‰Šé™¤ä¸­ã«ãƒ“ãƒ¥ãƒ¼ã‚’ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã¨ã€ :exc:`RuntimeError` "
"ã‚’é€å‡ºã—ãŸã‚Šã€ã™ã¹ã¦ã®é …ç›®ã«æ¸¡ã£ã¦ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã§ããªã‹ã£ãŸã‚Šã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4253
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"*x* ãŒå…ƒã®è¾æ›¸ã®ã‚­ãƒ¼ã€å€¤ã€ã¾ãŸã¯é …ç›® (é …ç›®ã®å ´åˆã€ *x* ã¯ ``(key, value)`` ã‚¿ãƒ—ãƒ«ã§ã™) ã«ã‚ã‚‹ã¨ã ``True`` "
"ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4257
msgid ""
"Keys views are set-like since their entries are unique and hashable.  If all"
" values are hashable, so that ``(key, value)`` pairs are unique and "
"hashable, then the items view is also set-like.  (Values views are not "
"treated as set-like since the entries are generally not unique.)  For set-"
"like views, all of the operations defined for the abstract base class "
":class:`collections.abc.Set` are available (for example, ``==``, ``<``, or "
"``^``)."
msgstr ""
"ã‚­ãƒ¼ã®ãƒ“ãƒ¥ãƒ¼ã¯ã€é …ç›®ãŒä¸€æ„çš„ã§ãƒãƒƒã‚·ãƒ¥å¯èƒ½ã§ã‚ã‚‹ã¨ã„ã†ç‚¹ã§ã€é›†åˆã«ä¼¼ã¦ã„ã¾ã™ã€‚ã™ã¹ã¦ã®å€¤ãŒãƒãƒƒã‚·ãƒ¥å¯èƒ½ãªã‚‰ã€ ``(key, value)`` "
"å¯¾ã‚‚ä¸€æ„çš„ã§ãƒãƒƒã‚·ãƒ¥å¯èƒ½ãªã®ã§ã€è¦ç´ ã®ãƒ“ãƒ¥ãƒ¼ã‚‚é›†åˆã«ä¼¼ã¦ã„ã¾ã™ã€‚(å€¤ã®ãƒ“ãƒ¥ãƒ¼ã¯ã€è¦ç´ ãŒä¸€èˆ¬ã«ä¸€æ„çš„ã§ãªã„ã“ã¨ã‹ã‚‰ã€é›†åˆã«ä¼¼ã¦ã„ã‚‹ã¨ã¯è€ƒãˆã‚‰ã‚Œã¾ã›ã‚“ã€‚) "
"é›†åˆã«ä¼¼ã¦ã„ã‚‹ãƒ“ãƒ¥ãƒ¼ã«å¯¾ã—ã¦ã€æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ :class:`collections.abc.Set` ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹å…¨ã¦ã®æ¼”ç®— (ä¾‹ãˆã°ã€ "
"``==``ã€``<``ã€``^``) ãŒåˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4264
msgid "An example of dictionary view usage::"
msgstr "è¾æ›¸ãƒ“ãƒ¥ãƒ¼ã®ä½¿ç”¨æ³•ã®ä¾‹::"

#: ../../library/stdtypes.rst:4299
msgid "Context Manager Types"
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£å‹"

#: ../../library/stdtypes.rst:4306
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context"
" defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"Python ã® :keyword:`with` "
"æ–‡ã¯ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚Œã‚‹å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ¦‚å¿µã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ã“ã‚Œã¯ã€æ–‡ã®æœ¬ä½“ãŒå®Ÿè¡Œã•ã‚Œã‚‹å‰ã«é€²å…¥ã—æ–‡ã®çµ‚ã‚ã‚Šã§è„±å‡ºã™ã‚‹å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ã€ãƒ¦ãƒ¼ã‚¶å®šç¾©ã‚¯ãƒ©ã‚¹ãŒå®šç¾©ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ä¸€å¯¾ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§å®Ÿè£…ã•ã‚Œã¾ã™:"

#: ../../library/stdtypes.rst:4314
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å…¥ã‚Šã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ä»–ã®å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«é–¢é€£ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿”ã™å€¤ã¯ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã«ã‚ˆã£ã¦"
" :keyword:`with` æ–‡ã® :keyword:`as` ç¯€ã®è­˜åˆ¥å­ã«æŸç¸›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4319
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow "
":func:`open` to be used as the context expression in a :keyword:`with` "
"statement."
msgstr ""
"è‡ªåˆ†è‡ªèº«ã‚’è¿”ã™ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®ä¾‹ã¨ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (:term:`file object`) ãŒã‚ã‚Šã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ "
"__enter__() ã‹ã‚‰è‡ªåˆ†è‡ªèº«ã‚’è¿”ã—ã€ :func:`open` ãŒ :keyword:`with` "
"æ–‡ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå¼ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4323
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside the"
" :keyword:`with` statement."
msgstr ""
"é–¢é€£ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®ä¾‹ã¨ã—ã¦ã¯ :func:`decimal.localcontext` "
"ãŒè¿”ã™ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ãƒãƒãƒ¼ã‚¸ãƒ£ã¯ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãª10é€²æ•°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ã‚³ãƒ”ãƒ¼ã«ã‚»ãƒƒãƒˆã—ã¦ãã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ã“ã†ã™ã‚‹ã“ã¨ã§,"
" :keyword:`with` æ–‡ã®æœ¬ä½“ã®å†…éƒ¨ã§ã€å¤–å´ã®ã‚³ãƒ¼ãƒ‰ã«å½±éŸ¿ã‚’ä¸ãˆãšã«ã€ 10é€²æ•°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å¤‰æ›´ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4333
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while"
" executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰æŠœã‘ã€(ç™ºç”Ÿã—ã¦ã„ãŸå ´åˆ) ä¾‹å¤–ã‚’æŠ‘åˆ¶ã™ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™ãƒ–ãƒ¼ãƒ«å€¤ãƒ•ãƒ©ã‚°ã‚’è¿”ã—ã¾ã™ã€‚ :keyword:`with` "
"æ–‡ã®æœ¬ä½“ã®å®Ÿè¡Œä¸­ã«ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸå ´åˆã€å¼•æ•°ã«ã¯ãã®ä¾‹å¤–ã®å‹ã¨å€¤ã¨ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯æƒ…å ±ã‚’æ¸¡ã—ã¾ã™ã€‚ãã†ã§ãªã„å ´åˆã€å¼•æ•°ã¯å…¨ã¦ ``None`` ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4338
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`with` statement. Otherwise the"
" exception continues propagating after this method has finished executing. "
"Exceptions that occur during execution of this method will replace any "
"exception that occurred in the body of the :keyword:`with` statement."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰çœŸå€¤ãŒè¿”ã•ã‚Œã‚‹ã¨ :keyword:`with` æ–‡ã¯ä¾‹å¤–ã®ç™ºç”Ÿã‚’æŠ‘ãˆã€ :keyword:`with` "
"æ–‡ã®ç›´å¾Œã®æ–‡ã«å®Ÿè¡Œã‚’ç¶šã‘ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè¡Œã‚’çµ‚ãˆã‚‹ã¨ä¾‹å¤–ã®ä¼æ’­ãŒç¶šãã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè¡Œä¸­ã«èµ·ããŸä¾‹å¤–ã¯ "
":keyword:`with` æ–‡ã®æœ¬ä½“ã®å®Ÿè¡Œä¸­ã«èµ·ã“ã£ãŸä¾‹å¤–ã‚’ç½®ãæ›ãˆã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4345
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows"
" context management code to easily detect whether or not an :meth:`__exit__`"
" method has actually failed."
msgstr ""
"æ¸¡ã•ã‚ŒãŸä¾‹å¤–ã‚’æ˜ç¤ºçš„ã«å†é€å‡ºã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã®ä»£ã‚ã‚Šã«ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå½ã®å€¤ã‚’è¿”ã™ã“ã¨ã§ãƒ¡ã‚½ãƒƒãƒ‰ã®æ­£å¸¸çµ‚äº†ã¨é€å‡ºã•ã‚ŒãŸä¾‹å¤–ã‚’æŠ‘åˆ¶ã—ãªã„ã“ã¨ã‚’ä¼ãˆã‚‹ã¹ãã§ã™ã€‚ã“ã®ã‚ˆã†ã«ã™ã‚Œã°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¯"
" :meth:`__exit__` ãƒ¡ã‚½ãƒƒãƒ‰è‡ªä½“ãŒå¤±æ•—ã—ãŸã®ã‹ã©ã†ã‹ã‚’ç°¡å˜ã«è¦‹åˆ†ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4351
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python "
"ã¯ã€æ˜“ã—ã„ã‚¹ãƒ¬ãƒƒãƒ‰åŒæœŸã€ãƒ•ã‚¡ã‚¤ãƒ«ãªã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å³æ™‚ã‚¯ãƒ­ãƒ¼ã‚ºã€ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå°æ•°ç®—è¡“ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®å˜ç´”ãªæ“ä½œã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ã€ã„ãã¤ã‹ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’ç”¨æ„ã—ã¦ã„ã¾ã™ã€‚å„å‹ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã¨ã„ã†ä»¥ä¸Šã®ç‰¹åˆ¥ã®å–ã‚Šæ‰±ã„ã‚’å—ã‘ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¾‹ã«ã¤ã„ã¦ã¯"
" :mod:`contextlib` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:4357
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary "
":meth:`__enter__` and :meth:`__exit__` methods, rather than the iterator "
"produced by an undecorated generator function."
msgstr ""
"Python ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ (:term:`generator`) ã¨ :class:`contextlib.contextmanager` "
"ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ (:term:`decorator`) ã¯ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ç°¡ä¾¿ãªå®Ÿè£…æ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ã‚’ "
":class:`contextlib.contextmanager` "
"ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã§ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã¨ã€ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã•ã‚Œãªã„ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿é–¢æ•°ãŒä½œæˆã™ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®ä»£ã‚ã‚Šã«ã€å¿…è¦ãª :meth:`__enter__` ãŠã‚ˆã³ "
":meth:`__exit__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4364
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to"
" define these methods must provide them as a normal Python accessible "
"method. Compared to the overhead of setting up the runtime context, the "
"overhead of a single class dictionary lookup is negligible."
msgstr ""
"ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ãŸã‚ã« Python/C API ã®ä¸­ã® Python "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹æ§‹é€ ä½“ã«ç‰¹åˆ¥ãªã‚¹ãƒ­ãƒƒãƒˆãŒä½œã‚‰ã‚ŒãŸã‚ã‘ã§ã¯ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ãŸã„æ‹¡å¼µå‹ã¯ã“ã‚Œã‚‰ã‚’é€šå¸¸ã® Python "
"ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦æä¾›ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å®Ÿè¡Œæ™‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æº–å‚™ã™ã‚‹ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã«æ¯”ã¹ãŸã‚‰ã€ä¸€å›ã®ã‚¯ãƒ©ã‚¹è¾æ›¸ã®æ¢ç´¢ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã¯ç„¡è¦–ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4374
msgid "Other Built-in Types"
msgstr "ãã®ä»–ã®çµ„ã¿è¾¼ã¿å‹"

#: ../../library/stdtypes.rst:4376
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€ãã®ä»–ã„ãã¤ã‹ã®ç¨®é¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã»ã¨ã‚“ã©ã¯ 1 ã¤ã¾ãŸã¯ 2 ã¤ã®æ¼”ç®—ã ã‘ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4383
msgid "Modules"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (module)"

#: ../../library/stdtypes.rst:4385
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the "
":keyword:`import` statement is not, strictly speaking, an operation on a "
"module object; ``import foo`` does not require a module object named *foo* "
"to exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å¯¾ã™ã‚‹å”¯ä¸€ã®ç‰¹æ®Šãªæ¼”ç®—ã¯å±æ€§ã‚¢ã‚¯ã‚»ã‚¹: ``m.name`` ã§ã™ã€‚ã“ã“ã§ *m* ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã€ *name* ã¯ *m* "
"ã®ã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ä¸Šã«å®šç¾©ã•ã‚ŒãŸåå‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å±æ€§ã«ä»£å…¥ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ (ãªãŠã€:keyword:`import` "
"æ–‡ã¯ã€å³å¯†ã«ã„ãˆã°ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹æ¼”ç®—ã§ã¯ã‚ã‚Šã¾ã›ã‚“; ``import foo`` ã¯ *foo* "
"ã¨åã¥ã‘ã‚‰ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å­˜åœ¨ã‚’å¿…è¦ã¨ã¯ã›ãšã€*foo* ã¨åã¥ã‘ã‚‰ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® (å¤–éƒ¨ã®) *å®šç¾©* ã‚’å¿…è¦ã¨ã—ã¾ã™ã€‚)"

#: ../../library/stdtypes.rst:4392
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the"
" dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to the"
" :attr:`~object.__dict__` attribute is not possible (you can write "
"``m.__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't "
"write ``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is "
"not recommended."
msgstr ""
"å…¨ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ã‚‹ç‰¹æ®Šå±æ€§ãŒ :attr:`~object.__dict__` "
"ã§ã™ã€‚ã“ã‚Œã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å«ã‚€è¾æ›¸ã§ã™ã€‚ã“ã®è¾æ›¸ã‚’æ›¸ãæ›ãˆã‚‹ã¨å®Ÿéš›ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚·ãƒ³ãƒœãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€:attr:`~object.__dict__`"
" å±æ€§ã‚’ç›´æ¥ä»£å…¥ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ (``m.__dict__['a'] = 1`` ã¨æ›¸ã„ã¦ ``m.a`` ã‚’ ``1`` "
"ã«å®šç¾©ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã™ãŒã€``m.__dict__ = {}`` ã¨æ›¸ãã“ã¨ã¯ã§ãã¾ã›ã‚“)ã€‚ :attr:`~object.__dict__` "
"ã‚’ç›´æ¥æ›¸ãæ›ãˆã‚‹ã“ã¨ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:4400
msgid ""
"Modules built into the interpreter are written like this: ``<module 'sys' "
"(built-in)>``.  If loaded from a file, they are written as ``<module 'os' "
"from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å†…ã«çµ„ã¿è¾¼ã¾ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ ``<module 'sys' (built-in)>`` "
"ã®ã‚ˆã†ã«æ›¸ã‹ã‚Œã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿å‡ºã•ã‚ŒãŸå ´åˆã€ ``<module 'os' from "
"'/usr/local/lib/pythonX.Y/os.pyc'>`` ã¨æ›¸ã‹ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4408
msgid "Classes and Class Instances"
msgstr "ã‚¯ãƒ©ã‚¹ãŠã‚ˆã³ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹"

#: ../../library/stdtypes.rst:4410
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "ã“ã‚Œã‚‰ã«ã¤ã„ã¦ã¯ :ref:`objects` ãŠã‚ˆã³ :ref:`class` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:4416
msgid "Functions"
msgstr "é–¢æ•°"

#: ../../library/stdtypes.rst:4418
msgid ""
"Function objects are created by function definitions.  The only operation on"
" a function object is to call it: ``func(argument-list)``."
msgstr ""
"é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é–¢æ•°å®šç¾©ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã¾ã™ã€‚é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å”¯ä¸€ã®æ“ä½œã¯ã€ãã‚Œã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã™: ``func(argument-"
"list)`` ã€‚"

#: ../../library/stdtypes.rst:4421
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯å®Ÿéš›ã«ã¯äºŒç¨®é¡ã‚ã‚Šã¾ã™: çµ„ã¿è¾¼ã¿é–¢æ•°ã¨ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã§ã™ã€‚ã©ã¡ã‚‰ã‚‚åŒã˜æ“ä½œ (é–¢æ•°ã®å‘¼ã³å‡ºã—) "
"ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ãŒã€å®Ÿè£…ã¯ç•°ãªã‚‹ã®ã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚‚ç•°ãªã‚Šã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4425
msgid "See :ref:`function` for more information."
msgstr "è©³ç´°ã¯ã€ :ref:`function` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:4431
msgid "Methods"
msgstr "ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../library/stdtypes.rst:4435
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯å±æ€§è¡¨è¨˜ã‚’ä½¿ã£ã¦å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°ã§ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯äºŒç¨®é¡ã‚ã‚Šã¾ã™: (ãƒªã‚¹ãƒˆã® :meth:`append` ã®ã‚ˆã†ãª) "
"çµ„ã¿è¾¼ã¿ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚çµ„ã¿è¾¼ã¿ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãã‚Œã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å‹ã¨ä¸€ç·’ã«è¨˜è¿°ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4440
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called "
":dfn:`instance method`) object. When called, it will add the ``self`` "
"argument to the argument list.  Bound methods have two special read-only "
"attributes: ``m.__self__`` is the object on which the method operates, and "
"``m.__func__`` is the function implementing the method.  Calling ``m(arg-1, "
"arg-2, ..., arg-n)`` is completely equivalent to calling "
"``m.__func__(m.__self__, arg-1, arg-2, ..., arg-n)``."
msgstr ""
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’é€šã—ã¦ãƒ¡ã‚½ãƒƒãƒ‰ (ã‚¯ãƒ©ã‚¹ã®åå‰ç©ºé–“å†…ã§å®šç¾©ã•ã‚ŒãŸé–¢æ•°) ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ã€ç‰¹æ®Šãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚ãã‚Œã¯æŸç¸›ãƒ¡ã‚½ãƒƒãƒ‰ "
"(:dfn:`bound method`) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ (:dfn:`instance method`) "
"ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚å‘¼ã³å‡ºã•ã‚ŒãŸæ™‚ã€å¼•æ•°ãƒªã‚¹ãƒˆã« ``self`` å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚æŸç¸›ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯ 2 ã¤ã®ç‰¹æ®Šèª­ã¿å‡ºã—å°‚ç”¨å±æ€§ãŒã‚ã‚Šã¾ã™ã€‚ "
"``m.__self__`` ã¯ãã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒæ“ä½œã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ ``m.__func__`` ã¯ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹é–¢æ•°ã§ã™ã€‚ "
"``m(arg-1, arg-2, ..., arg-n)`` ã®å‘¼ã³å‡ºã—ã¯ã€ ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)`` ã®å‘¼ã³å‡ºã—ã¨å®Œå…¨ã«ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4449
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on"
" bound methods is disallowed.  Attempting to set an attribute on a method "
"results in an :exc:`AttributeError` being raised.  In order to set a method "
"attribute, you need to explicitly set it on the underlying function object::"
msgstr ""
"é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒæ§˜ã«ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»»æ„ã®å±æ€§ã®å–å¾—ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€ãƒ¡ã‚½ãƒƒãƒ‰å±æ€§ã¯å®Ÿéš›ã«ã¯ä¸‹å±¤ã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ "
"(``meth.__func__``) "
"ã«è¨˜æ†¶ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã«ãƒ¡ã‚½ãƒƒãƒ‰å±æ€§ã‚’è¨­å®šã™ã‚‹ã“ã¨ã¯è¨±ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã«å±æ€§ã‚’è¨­å®šã—ã‚ˆã†ã¨ã™ã‚‹ã¨ "
":exc:`AttributeError` "
"ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã®å±æ€§ã‚’è¨­å®šã™ã‚‹ãŸã‚ã«ã¯ã€æ¬¡ã®ã‚ˆã†ã«ãã®ä¸‹å±¤ã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æ˜ç¤ºçš„ã«è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™::"

#: ../../library/stdtypes.rst:4469 ../../library/stdtypes.rst:4497
msgid "See :ref:`types` for more information."
msgstr "è©³ç´°ã¯ã€ :ref:`types` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:4477
msgid "Code Objects"
msgstr "ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:4483
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\""
" executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their "
":attr:`__code__` attribute. See also the :mod:`code` module."
msgstr ""
"ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€é–¢æ•°æœ¬ä½“ã®ã‚ˆã†ãª \"æ“¬ä¼¼ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸ\" Python "
"ã®å®Ÿè¡Œå¯èƒ½ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ã™ãŸã‚ã«å®Ÿè£…ç³»ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªå®Ÿè¡Œç’°å¢ƒã¸ã®å‚ç…§ã‚’æŒãŸãªã„ç‚¹ã§é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¯ç•°ãªã‚Šã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿é–¢æ•°"
" :func:`compile` ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã€ã¾ãŸé–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :attr:`__code__` å±æ€§ã¨ã—ã¦å–ã‚Šå‡ºã›ã¾ã™ã€‚ "
":mod:`code` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:4494
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`exec` ã‚„ :func:`eval` ã« (ã‚½ãƒ¼ã‚¹æ–‡å­—åˆ—ã®ä»£ã‚ã‚Šã«) "
"æ¸¡ã™ã“ã¨ã§ã€å®Ÿè¡Œã‚„è©•ä¾¡ã§ãã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4503
msgid "Type Objects"
msgstr "å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:4509
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all"
" standard built-in types."
msgstr ""
"å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ§˜ã€…ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã‚’è¡¨ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã¯çµ„ã¿è¾¼ã¿é–¢æ•° :func:`type` "
"ã§ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã¾ã™ã€‚å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ç‰¹æœ‰ã®æ“ä½œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æ¨™æº–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`types` ã«ã¯å…¨ã¦ã®çµ„ã¿è¾¼ã¿å‹åãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4514
msgid "Types are written like this: ``<class 'int'>``."
msgstr "å‹ã¯ã“ã®ã‚ˆã†ã«æ›¸ãè¡¨ã•ã‚Œã¾ã™: ``<class 'int'>`` ã€‚"

#: ../../library/stdtypes.rst:4520
msgid "The Null Object"
msgstr "ãƒŒãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:4522
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ˜ç¤ºçš„ã«å€¤ã‚’è¿”ã•ãªã„é–¢æ•°ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ç‰¹æœ‰ã®æ“ä½œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒŒãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸€ã¤ã ã‘ã§ã€ "
"``None`` (çµ„ã¿è¾¼ã¿å) ã¨åã¥ã‘ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ ``type(None)()`` ã¯åŒã˜ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4526
msgid "It is written as ``None``."
msgstr "``None`` ã¨æ›¸ãè¡¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4532
msgid "The Ellipsis Object"
msgstr "Ellipsis ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:4534
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named "
":const:`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the "
":const:`Ellipsis` singleton."
msgstr ""
"ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸€èˆ¬ã«ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã¾ã™ (:ref:`slicings` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚ç‰¹æ®Šãªæ¼”ç®—ã¯ä½•ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚Ellipsis ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸€ã¤ã ã‘ã§ã€ãã®åå‰ã¯ :const:`Ellipsis` "
"(çµ„ã¿è¾¼ã¿å) ã§ã™ã€‚``type(Ellipsis)()`` ã¯å˜ä¸€ã® :const:`Ellipsis` ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4539
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "``Ellipsis`` ã¾ãŸã¯ ``...`` ã¨æ›¸ãè¡¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4545
msgid "The NotImplemented Object"
msgstr "NotImplemented ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:4547
msgid ""
"This object is returned from comparisons and binary operations when they are"
" asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""
"ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€å¯¾å¿œã—ã¦ã„ãªã„å‹ã«å¯¾ã—ã¦æ¯”è¼ƒæ¼”ç®—ã‚„äºŒé …æ¼”ç®—ãŒæ±‚ã‚ã‚‰ã‚ŒãŸã¨ãã€ãã‚Œã‚‰ã®æ¼”ç®—ã‹ã‚‰è¿”ã•ã‚Œã¾ã™ã€‚è©³ç´°ã¯ :ref:`comparisons`"
" ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ ``NotImplemented`` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸€ã¤ã ã‘ã§ã™ã€‚ ``type(NotImplemented)()`` "
"ã¯ã“ã®å˜ä¸€ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4552
msgid "It is written as ``NotImplemented``."
msgstr "``NotImplemented`` ã¨æ›¸ãè¡¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4558
msgid "Boolean Values"
msgstr "ãƒ–ãƒ¼ãƒ«å€¤"

#: ../../library/stdtypes.rst:4560
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and"
" 1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""
"ãƒ–ãƒ¼ãƒ«å€¤ã¯äºŒã¤ã®å®šæ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ``False`` ãŠã‚ˆã³ ``True`` ã§ã™ã€‚ã“ã‚Œã‚‰ã¯çœŸç†å€¤ã‚’è¡¨ã™ã®ã«ä½¿ã‚ã‚Œã¾ã™ "
"(ãŸã ã—ä»–ã®å€¤ã‚‚å½ã‚„çœŸã¨ã¿ãªã•ã‚Œã¾ã™)ã€‚ æ•°å€¤å‡¦ç†ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ (ä¾‹ãˆã°ç®—è¡“æ¼”ç®—å­ã®å¼•æ•°ã¨ã—ã¦ä½¿ã‚ã‚ŒãŸå ´åˆ) ã§ã¯ã€ã“ã‚Œã‚‰ã¯ãã‚Œãã‚Œ 0 ãŠã‚ˆã³ 1 "
"ã¨åŒæ§˜ã«æŒ¯èˆã„ã¾ã™ã€‚ä»»æ„ã®å€¤ã«å¯¾ã—ã¦ã€çœŸç†å€¤ã¨è§£é‡ˆã§ãã‚‹å ´åˆã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`bool` ã¯å€¤ã‚’ãƒ–ãƒ¼ãƒ«å€¤ã«å¤‰æ›ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã¾ã™ (ä¸Šè¿°ã® "
":ref:`truth` ã®ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../library/stdtypes.rst:4573
msgid "They are written as ``False`` and ``True``, respectively."
msgstr "ãã‚Œãã‚Œ ``False`` ãŠã‚ˆã³ ``True`` ã¨æ›¸ãè¡¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4579
msgid "Internal Objects"
msgstr "å†…éƒ¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/stdtypes.rst:4581
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""
"ã“ã®æƒ…å ±ã¯ :ref:`types` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦è¨˜è¿°ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4588
msgid "Special Attributes"
msgstr "ç‰¹æ®Šå±æ€§"

#: ../../library/stdtypes.rst:4590
msgid ""
"The implementation adds a few special read-only attributes to several object"
" types, where they are relevant.  Some of these are not reported by the "
":func:`dir` built-in function."
msgstr ""
"å®Ÿè£…ã¯ã€ã„ãã¤ã‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã«å¯¾ã—ã¦ã€é©åˆ‡ãªå ´åˆã«ã¯ç‰¹æ®Šãªèª­ã¿å‡ºã—å°‚ç”¨ã®å±æ€§ã‚’è¿½åŠ ã—ã¾ã™ã€‚ãã®ã†ã¡ã„ãã¤ã‹ã¯ :func:`dir` "
"çµ„è¾¼ã¿é–¢æ•°ã§å ±å‘Šã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/stdtypes.rst:4597
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® (æ›¸ãè¾¼ã¿å¯èƒ½ãª) å±æ€§ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹è¾æ›¸ã¾ãŸã¯ãã®ä»–ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/stdtypes.rst:4603
msgid "The class to which a class instance belongs."
msgstr "ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒå±ã—ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4608
msgid "The tuple of base classes of a class object."
msgstr "ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4613
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr "ã‚¯ãƒ©ã‚¹ã€é–¢æ•°ã€ãƒ¡ã‚½ãƒƒãƒ‰ã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®åå‰ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4619
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr "ã‚¯ãƒ©ã‚¹ã€é–¢æ•°ã€ãƒ¡ã‚½ãƒƒãƒ‰ã€ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® :term:`ä¿®é£¾å <qualified name>` ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4627
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr "ã“ã®å±æ€§ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã®è§£æ±ºæ™‚ã«åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’æ¢ç´¢ã™ã‚‹ã¨ãã«è€ƒæ…®ã•ã‚Œã‚‹ã‚¯ãƒ©ã‚¹ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4633
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã«ã‚ˆã£ã¦ã€ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰è§£æ±ºã®é †åºã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ãŸã‚ã«ã€ä¸Šæ›¸ãã•ã‚Œã‚‹ã‹ã‚‚çŸ¥ã‚Œã¾ã›ã‚“ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–æ™‚ã«å‘¼ã°ã‚Œã€ãã®çµæœã¯"
" :attr:`~class.__mro__` ã«æ ¼ç´ã•ã‚Œã¾ã™ã€‚"

#: ../../library/stdtypes.rst:4640
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive. Example::"
msgstr ""
"ãã‚Œãã‚Œã®ã‚¯ãƒ©ã‚¹ã¯ã€ãã‚Œè‡ªèº«ã®ç›´æ¥ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã¸ã®å¼±å‚ç…§ã‚’ä¿æŒã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãã‚Œã‚‰ã®å‚ç…§ã®ã†ã¡ã€ç”Ÿå­˜ã—ã¦ã„ã‚‹ã‚‚ã®ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ä¾‹::"

#: ../../library/stdtypes.rst:4649
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../library/stdtypes.rst:4650
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"ã“ã‚Œã‚‰ã®ç‰¹æ®Šãªãƒ¡ã‚½ãƒƒãƒ‰ã®ã•ã‚‰ãªã‚‹æƒ…å ±ã«ã¤ã„ã¦ã¯ã€ Python ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ« (:ref:`customization`) "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/stdtypes.rst:4653
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``,"
" and similarly for tuples."
msgstr "ã“ã®çµæœã¨ã—ã¦ã€ãƒªã‚¹ãƒˆ ``[1, 2]`` ã¯ ``[1.0, 2.0]`` ã¨ç­‰ã—ã„ã¨è¦‹ãªã•ã‚Œã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã®å ´åˆã‚‚åŒæ§˜ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4656
msgid "They must have since the parser can't tell the type of the operands."
msgstr "ãƒ‘ãƒ¼ã‚¶ãŒæ¼”ç®—å¯¾è±¡ã®å‹ã‚’è­˜åˆ¥ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€ã“ã®ã‚ˆã†ãªå„ªå…ˆé †ä½ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4658
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"å¤§å°æ–‡å­—ã®åŒºåˆ¥ã®ã‚ã‚‹æ–‡å­—ã¨ã¯ã€ä¸€èˆ¬ã‚«ãƒ†ã‚´ãƒªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒ \"Lu\" (Letter, uppercase (å¤§æ–‡å­—))ã€ \"Ll\" "
"(Letter, lowercase (å°æ–‡å­—))ã€ \"Lt\" (Letterã€titlecase (å…ˆé ­ãŒå¤§æ–‡å­—)) ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹ã‚‚ã®ã§ã™ã€‚"

#: ../../library/stdtypes.rst:4661
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"å¾“ã£ã¦ã€ä¸€å€‹ã®ã‚¿ãƒ—ãƒ«ã ã‘ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå‡ºåŠ›ã—ãŸã„å ´åˆã«ã¯å‡ºåŠ›ã—ãŸã„ã‚¿ãƒ—ãƒ«ã‚’å”¯ä¸€ã®è¦ç´ ã¨ã™ã‚‹å˜ä¸€ã®ã‚¿ãƒ—ãƒ«ã‚’ *values* ã«ä¸ãˆãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"
