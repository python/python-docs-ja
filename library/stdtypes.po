# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# tomo, 2017-2018
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2020-03-09 16:15+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "組み込み型"

#: ../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"以下のセクションでは、インタプリタに組み込まれている標準型について記述しま"
"す。"

#: ../../library/stdtypes.rst:15
msgid ""
"Historically (until release 2.2), Python's built-in types have differed from "
"user-defined types because it was not possible to use the built-in types as "
"the basis for object-oriented inheritance. This limitation no longer exists."
msgstr ""
"これまでの (リリース 2.2 までの) Python の歴史では、組み込み型はオブジェクト"
"指向における継承を行う際に雛型にできないという点で、ユーザ定義型とは異なって"
"いました。いまではこのような制限はなくなっています。"

#: ../../library/stdtypes.rst:22
msgid ""
"The principal built-in types are numerics, sequences, mappings, files, "
"classes, instances and exceptions."
msgstr ""
"主要な組み込み型は数値型、シーケンス型、マッピング型、ファイル、クラス、イン"
"スタンス型、および例外です。"

#: ../../library/stdtypes.rst:27
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared, tested for truth value, and "
"converted to a string (with the :ref:`repr() <func-repr>` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"演算によっては、複数の型でサポートされているものがあります; 特に、ほぼ全ての"
"オブジェクトについて、比較、真理値テスト、 (:ref:`repr() <func-repr>` 関数"
"や、わずかに異なる :func:`str` 関数による) 文字列への変換を行うことができま"
"す。オブジェクトが :func:`print` 関数で印字されるとき、文字列に変換する関数が"
"暗黙に使われます。"

#: ../../library/stdtypes.rst:37
msgid "Truth Value Testing"
msgstr "真理値判定"

#: ../../library/stdtypes.rst:46
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below. The "
"following values are considered false:"
msgstr ""
"どのオブジェクトも真理値を判定でき、 :keyword:`if` や :keyword:`while` 条件"
"に、または以下のブール演算の被演算子に使えます。以下の値は偽と見なされます:"

#: ../../library/stdtypes.rst:52
msgid "``None``"
msgstr "``None``"

#: ../../library/stdtypes.rst:56
msgid "``False``"
msgstr "``False``"

#: ../../library/stdtypes.rst:58
msgid "zero of any numeric type, for example, ``0``, ``0L``, ``0.0``, ``0j``."
msgstr "数値型におけるゼロ。例えば ``0``, ``0L``, ``0.0``, ``0j`` 。"

#: ../../library/stdtypes.rst:60
msgid "any empty sequence, for example, ``''``, ``()``, ``[]``."
msgstr "空のシーケンス。例えば ``''``, ``()``, ``[]`` 。"

#: ../../library/stdtypes.rst:62
msgid "any empty mapping, for example, ``{}``."
msgstr "空のマッピング。例えば ``{}`` 。"

#: ../../library/stdtypes.rst:64
msgid ""
"instances of user-defined classes, if the class defines a :meth:"
"`__nonzero__` or :meth:`__len__` method, when that method returns the "
"integer zero or :class:`bool` value ``False``. [1]_"
msgstr ""
"ユーザ定義クラスのインスタンスで、そのクラスが :meth:`__nonzero__` または :"
"meth:`__len__` メソッドを定義していれば、それらのメソッドが整数 0 または :"
"class:`bool` 値 ``False`` を返すとき。 [1]_"

#: ../../library/stdtypes.rst:70
msgid ""
"All other values are considered true --- so objects of many types are always "
"true."
msgstr ""
"それ以外の全ての値は真と見なされます --- 従って、多くの型のオブジェクトは常に"
"真です。"

#: ../../library/stdtypes.rst:79
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"ブール値の結果を返す演算および組み込み関数は、特に注釈のない限り常に偽値とし"
"て ``0`` または ``False`` を返し、真値として ``1`` または ``True`` を返しま"
"す。 (重要な例外: ブール演算 ``or`` および ``and`` は常に被演算子のうちの一つ"
"を返します。)"

#: ../../library/stdtypes.rst:88
msgid "Boolean Operations --- :keyword:`and`, :keyword:`or`, :keyword:`not`"
msgstr "ブール演算 --- :keyword:`and`, :keyword:`or`, :keyword:`not`"

#: ../../library/stdtypes.rst:92
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "以下にブール演算を、優先順位が低い順に示します:"

#: ../../library/stdtypes.rst:95 ../../library/stdtypes.rst:153
#: ../../library/stdtypes.rst:299 ../../library/stdtypes.rst:397
#: ../../library/stdtypes.rst:444 ../../library/stdtypes.rst:733
#: ../../library/stdtypes.rst:1657
msgid "Operation"
msgstr "演算"

#: ../../library/stdtypes.rst:95 ../../library/stdtypes.rst:299
#: ../../library/stdtypes.rst:397 ../../library/stdtypes.rst:444
#: ../../library/stdtypes.rst:733 ../../library/stdtypes.rst:1657
msgid "Result"
msgstr "結果"

#: ../../library/stdtypes.rst:95 ../../library/stdtypes.rst:153
#: ../../library/stdtypes.rst:299 ../../library/stdtypes.rst:444
#: ../../library/stdtypes.rst:733 ../../library/stdtypes.rst:1508
#: ../../library/stdtypes.rst:1657
msgid "Notes"
msgstr "注釈"

#: ../../library/stdtypes.rst:97
msgid "``x or y``"
msgstr "``x or y``"

#: ../../library/stdtypes.rst:97
msgid "if *x* is false, then *y*, else *x*"
msgstr "*x* が偽なら *y*, そうでなければ *x*"

#: ../../library/stdtypes.rst:97 ../../library/stdtypes.rst:165
#: ../../library/stdtypes.rst:307 ../../library/stdtypes.rst:735
#: ../../library/stdtypes.rst:738 ../../library/stdtypes.rst:1514
#: ../../library/stdtypes.rst:1668
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/stdtypes.rst:100
msgid "``x and y``"
msgstr "``x and y``"

#: ../../library/stdtypes.rst:100
msgid "if *x* is false, then *x*, else *y*"
msgstr "*x* が偽なら *x*, そうでなければ *y*"

#: ../../library/stdtypes.rst:100 ../../library/stdtypes.rst:321
#: ../../library/stdtypes.rst:323 ../../library/stdtypes.rst:744
#: ../../library/stdtypes.rst:1518 ../../library/stdtypes.rst:1520
#: ../../library/stdtypes.rst:1674
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/stdtypes.rst:103
msgid "``not x``"
msgstr "``not x``"

#: ../../library/stdtypes.rst:103
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "*x* が偽なら ``True``, そうでなければ ``False``"

#: ../../library/stdtypes.rst:103 ../../library/stdtypes.rst:318
#: ../../library/stdtypes.rst:747 ../../library/stdtypes.rst:1522
#: ../../library/stdtypes.rst:1524 ../../library/stdtypes.rst:1526
#: ../../library/stdtypes.rst:1528 ../../library/stdtypes.rst:1677
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/stdtypes.rst:112 ../../library/stdtypes.rst:172
#: ../../library/stdtypes.rst:345 ../../library/stdtypes.rst:462
#: ../../library/stdtypes.rst:787 ../../library/stdtypes.rst:1551
#: ../../library/stdtypes.rst:1704
msgid "Notes:"
msgstr "注釈:"

#: ../../library/stdtypes.rst:115
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"この演算子は短絡評価されます。つまり第一引数が偽のときにのみ、第二引数が評価"
"されます。"

#: ../../library/stdtypes.rst:119
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"この演算子は短絡評価されます。つまり第一引数が真のときにのみ、第二引数が評価"
"されます。"

#: ../../library/stdtypes.rst:123
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` は非ブール演算子よりも優先度が低いので、 ``not a == b`` は ``not (a "
"== b)`` と解釈され、 ``a == not b`` は構文エラーです。"

#: ../../library/stdtypes.rst:130
msgid "Comparisons"
msgstr "比較"

#: ../../library/stdtypes.rst:144
msgid ""
"Comparison operations are supported by all objects.  They all have the same "
"priority (which is higher than that of the Boolean operations). Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"比較演算は全てのオブジェクトでサポートされています。比較演算子は全て同じ演算"
"優先度を持っています (ブール演算より高い演算優先度です)。比較は任意の形で連鎖"
"させることができます; 例えば、 ``x < y <= z`` は ``x < y and y <= z`` と等価"
"で、違うのは *y* が一度だけしか評価されないということです (どちらの場合で"
"も、 ``x < y`` が偽となった場合には *z* は評価されません)。"

#: ../../library/stdtypes.rst:150
msgid "This table summarizes the comparison operations:"
msgstr "以下の表に比較演算をまとめます:"

#: ../../library/stdtypes.rst:153 ../../library/stdtypes.rst:1485
#: ../../library/stdtypes.rst:1508
msgid "Meaning"
msgstr "意味"

#: ../../library/stdtypes.rst:155
msgid "``<``"
msgstr "``<``"

#: ../../library/stdtypes.rst:155
msgid "strictly less than"
msgstr "より小さい"

#: ../../library/stdtypes.rst:157
msgid "``<=``"
msgstr "``<=``"

#: ../../library/stdtypes.rst:157
msgid "less than or equal"
msgstr "以下"

#: ../../library/stdtypes.rst:159
msgid "``>``"
msgstr "``>``"

#: ../../library/stdtypes.rst:159
msgid "strictly greater than"
msgstr "より大きい"

#: ../../library/stdtypes.rst:161
msgid "``>=``"
msgstr "``>=``"

#: ../../library/stdtypes.rst:161
msgid "greater than or equal"
msgstr "以上"

#: ../../library/stdtypes.rst:163
msgid "``==``"
msgstr "``==``"

#: ../../library/stdtypes.rst:163
msgid "equal"
msgstr "等しい"

#: ../../library/stdtypes.rst:165
msgid "``!=``"
msgstr "``!=``"

#: ../../library/stdtypes.rst:165
msgid "not equal"
msgstr "等しくない"

#: ../../library/stdtypes.rst:167
msgid "``is``"
msgstr "``is``"

#: ../../library/stdtypes.rst:167
msgid "object identity"
msgstr "同一のオブジェクトである"

#: ../../library/stdtypes.rst:169
msgid "``is not``"
msgstr "``is not``"

#: ../../library/stdtypes.rst:169
msgid "negated object identity"
msgstr "同一のオブジェクトでない"

#: ../../library/stdtypes.rst:175
msgid ""
"``!=`` can also be written ``<>``, but this is an obsolete usage kept for "
"backwards compatibility only. New code should always use ``!=``."
msgstr ""
"``!=`` は ``<>`` とも書けますがこれは時代遅れの書き方で、後方互換性維持のため"
"だけに残されています。新しいコードでは常に ``!=`` を使うべきです。"

#: ../../library/stdtypes.rst:183
msgid ""
"Objects of different types, except different numeric types and different "
"string types, never compare equal; such objects are ordered consistently but "
"arbitrarily (so that sorting a heterogeneous array yields a consistent "
"result). Furthermore, some types (for example, file objects) support only a "
"degenerate notion of comparison where any two objects of that type are "
"unequal.  Again, such objects are ordered arbitrarily but consistently. The "
"``<``, ``<=``, ``>`` and ``>=`` operators will raise a :exc:`TypeError` "
"exception when any operand is a complex number."
msgstr ""
"数値型間の比較か文字列間の比較でないかぎり、異なる型のオブジェクトを比較して"
"も等価になることはありません; これらのオブジェクトの順番付けは一貫してはいま"
"すが任意のものです (従って要素の型が一様でないシーケンスをソートした結果は一"
"貫したものになります)。さらに、 (例えばファイルオブジェクトのように) 型によっ"
"ては、その型の 2 つのオブジェクトの不等性だけの、縮退した比較の概念しかサポー"
"トしないものもあります。繰り返しますが、そのようなオブジェクトも任意の順番付"
"けをされていますが、それは一貫したものです。被演算子が複素数の場合、演算子 "
"``<``, ``<=``, ``>`` および ``>=`` は例外 :exc:`TypeError` を送出します。"

#: ../../library/stdtypes.rst:201
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`__eq__` method or the :meth:`__cmp__` method."
msgstr ""
"あるクラスの同一でないインスタンスは、通常等価でないとされますが、そのクラス"
"が :meth:`__eq__` メソッドか :meth:`__cmp__` メソッドを定義している場合は除き"
"ます。"

#: ../../library/stdtypes.rst:204
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines either "
"enough of the rich comparison methods (:meth:`__lt__`, :meth:`__le__`, :meth:"
"`__gt__`, and :meth:`__ge__`) or the :meth:`__cmp__` method."
msgstr ""
"クラスのインスタンスは、そのクラスが十分なだけの拡張比較メソッド (:meth:"
"`__lt__`, :meth:`__le__`, :meth:`__gt__`, :meth:`__ge__`) または :meth:"
"`__cmp__` メソッドを定義していない限り、同じクラスの別のインスタンスや他の型"
"のオブジェクトとは順序付けできません。"

#: ../../library/stdtypes.rst:211
msgid ""
"Objects of different types except numbers are ordered by their type names; "
"objects of the same types that don't support proper comparison are ordered "
"by their address."
msgstr ""
"数値型を除き、異なる型のオブジェクトは型の名前で順番付けされます; 適当な比較"
"をサポートしていないある型のオブジェクトはアドレスによって順番付けされます。"

#: ../../library/stdtypes.rst:219
msgid ""
"Two more operations with the same syntactic priority, ``in`` and ``not in``, "
"are supported only by sequence types (below)."
msgstr ""
"同じ優先度を持つ演算子としてさらに 2 つ、シーケンス型でのみ ``in`` および "
"``not in`` がサポートされています (以下を参照)。"

#: ../../library/stdtypes.rst:226
msgid ""
"Numeric Types --- :class:`int`, :class:`float`, :class:`long`, :class:"
"`complex`"
msgstr "数値型 :class:`int`, :class:`float`, :class:`long`, :class:`complex`"

#: ../../library/stdtypes.rst:237
msgid ""
"There are four distinct numeric types: :dfn:`plain integers`, :dfn:`long "
"integers`, :dfn:`floating point numbers`, and :dfn:`complex numbers`. In "
"addition, Booleans are a subtype of plain integers. Plain integers (also "
"just called :dfn:`integers`) are implemented using :c:type:`long` in C, "
"which gives them at least 32 bits of precision (``sys.maxint`` is always set "
"to the maximum plain integer value for the current platform, the minimum "
"value is ``-sys.maxint - 1``).  Long integers have unlimited precision.  "
"Floating point numbers are usually implemented using :c:type:`double` in C; "
"information about the precision and internal representation of floating "
"point numbers for the machine on which your program is running is available "
"in :data:`sys.float_info`.  Complex numbers have a real and imaginary part, "
"which are each a floating point number.  To extract these parts from a "
"complex number *z*, use ``z.real`` and ``z.imag``. (The standard library "
"includes additional numeric types, :mod:`fractions` that hold rationals, "
"and :mod:`decimal` that hold floating-point numbers with user-definable "
"precision.)"
msgstr ""
"4 つの異なる数値型があります: :dfn:`通常の整数型`, :dfn:`長整数型`, :dfn:`浮"
"動小数点型`, :dfn:`複素数型` です。さらに、真偽値(Boolean)型も通常の整数型の"
"サブタイプです。通常の整数 (単に :dfn:`整数型` とも呼ばれます) は C言語の :c:"
"type:`long` 型を使って実装されており、少なくとも 32 ビットの精度があります "
"(``sys.maxint`` は常に通常の整数の各プラットフォームにおける最大値にセットさ"
"れており、最小値は ``-sys.maxint - 1`` になります)。長整数型には精度の制限が"
"ありません。浮動小数点型はたいていは C の :c:type:`double` を使って実装されて"
"います; あなたのプログラムが動作するマシンでの浮動小数点型の精度と内部表現"
"は、 :data:`sys.float_info` から利用できます。複素数型は実部と虚部を持ち、そ"
"れぞれ浮動小数点数です。複素数 *z* から実部および虚部を取り出すには、 ``z."
"real`` および ``z.imag`` を使ってください。 (標準ライブラリには、追加の数値"
"型、分数を保持する :mod:`fractions` や、ユーザ定義の精度の浮動小数点数を保持"
"する :mod:`decimal` があります。)"

#: ../../library/stdtypes.rst:262
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including binary, hex, "
"and octal numbers) yield plain integers unless the value they denote is too "
"large to be represented as a plain integer, in which case they yield a long "
"integer. Integer literals with an ``'L'`` or ``'l'`` suffix yield long "
"integers (``'L'`` is preferred because ``1l`` looks too much like eleven!).  "
"Numeric literals containing a decimal point or an exponent sign yield "
"floating point numbers. Appending ``'j'`` or ``'J'`` to a numeric literal "
"yields an imaginary number (a complex number with a zero real part) which "
"you can add to an integer or float to get a complex number with real and "
"imaginary parts."
msgstr ""
"数値は、数値リテラルや組み込み関数や演算子の戻り値として生成されます。\n"
"修飾のない整数リテラル ( 2 進表現や、 16 進表現や 8 進表現の値も含みます) "
"は、通常の整数値を表します。\n"
"値が通常の整数で表すには大きすぎる場合、 ``'L'`` または ``'l'`` が末尾につく"
"整数リテラルは長整数型を表します (``'L'`` が望ましいです。というのは ``1l`` "
"は 11 と非常に紛らわしいからです!)。\n"
"小数点または指数表記のある数値リテラルは浮動小数点数を表します。\n"
"数値リテラルに ``'j'`` または ``'J'`` をつけると虚数 (実数部がゼロの複素数) "
"を表し、それと整数や浮動小数点数を足すと実部と虚部を持つ複素数が得られます。"

#: ../../library/stdtypes.rst:287
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where plain integer is narrower than "
"long integer is narrower than floating point is narrower than complex. "
"Comparisons between numbers of mixed type use the same rule. [2]_ The "
"constructors :func:`int`, :func:`long`, :func:`float`, and :func:`complex` "
"can be used to produce numbers of a specific type."
msgstr ""
"Python は型混合の演算を完全にサポートします: ある 2 項演算子が互いに異なる数"
"値型の被演算子を持つ場合、より \"制限された\" 型の被演算子は他方の型に合わせ"
"て広げられます。ここで通常の整数は長整数より制限されており、長整数は浮動小数"
"点数より制限されており、浮動小数点は複素数より制限されています。型混合の数値"
"間での比較も同じ規則に従います。 [2]_ コンストラクタ :func:`int`, :func:"
"`long`, :func:`float`, および :func:`complex` を使って、特定の型の数を生成す"
"ることができます。"

#: ../../library/stdtypes.rst:295
msgid ""
"All built-in numeric types support the following operations. See :ref:"
"`power` and later sections for the operators' priorities."
msgstr ""
"全ての組み込み数値型は以下の演算をサポートします。演算子の優先度について"
"は、 :ref:`power`,および、あとのセクションを参照下さい。"

#: ../../library/stdtypes.rst:301
msgid "``x + y``"
msgstr "``x + y``"

#: ../../library/stdtypes.rst:301
msgid "sum of *x* and *y*"
msgstr "*x* と *y* の和"

#: ../../library/stdtypes.rst:303
msgid "``x - y``"
msgstr "``x - y``"

#: ../../library/stdtypes.rst:303
msgid "difference of *x* and *y*"
msgstr "*x* と *y* の差"

#: ../../library/stdtypes.rst:305
msgid "``x * y``"
msgstr "``x * y``"

#: ../../library/stdtypes.rst:305
msgid "product of *x* and *y*"
msgstr "*x* と *y* の積"

#: ../../library/stdtypes.rst:307
msgid "``x / y``"
msgstr "``x / y``"

#: ../../library/stdtypes.rst:307
msgid "quotient of *x* and *y*"
msgstr "*x* と *y* の商"

#: ../../library/stdtypes.rst:309
msgid "``x // y``"
msgstr "``x // y``"

#: ../../library/stdtypes.rst:309
msgid "(floored) quotient of *x* and *y*"
msgstr "*x* と *y* の商 (を切り下げたもの)"

#: ../../library/stdtypes.rst:309
msgid "(4)(5)"
msgstr "(4)(5)"

#: ../../library/stdtypes.rst:312
msgid "``x % y``"
msgstr "``x % y``"

#: ../../library/stdtypes.rst:312
msgid "remainder of ``x / y``"
msgstr "``x / y`` の剰余"

#: ../../library/stdtypes.rst:312 ../../library/stdtypes.rst:1530
#: ../../library/stdtypes.rst:1534 ../../library/stdtypes.rst:1686
#: ../../library/stdtypes.rst:1695
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/stdtypes.rst:314
msgid "``-x``"
msgstr "``-x``"

#: ../../library/stdtypes.rst:314
msgid "*x* negated"
msgstr "*x* の符号反転"

#: ../../library/stdtypes.rst:316
msgid "``+x``"
msgstr "``+x``"

#: ../../library/stdtypes.rst:316
msgid "*x* unchanged"
msgstr "*x* そのまま"

#: ../../library/stdtypes.rst:318
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../library/stdtypes.rst:318
msgid "absolute value or magnitude of *x*"
msgstr "*x* の絶対値または大きさ"

#: ../../library/stdtypes.rst:321
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../library/stdtypes.rst:321
msgid "*x* converted to integer"
msgstr "*x* の整数への変換"

#: ../../library/stdtypes.rst:323
msgid "``long(x)``"
msgstr "``long(x)``"

#: ../../library/stdtypes.rst:323
msgid "*x* converted to long integer"
msgstr "*x* の長整数への変換"

#: ../../library/stdtypes.rst:325
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../library/stdtypes.rst:325
msgid "*x* converted to floating point"
msgstr "*x* の浮動小数点数への変換"

#: ../../library/stdtypes.rst:325 ../../library/stdtypes.rst:741
#: ../../library/stdtypes.rst:1544 ../../library/stdtypes.rst:1692
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/stdtypes.rst:327
msgid "``complex(re,im)``"
msgstr "``complex(re,im)``"

#: ../../library/stdtypes.rst:327
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr "実部 *re*, 虚部 *im* の複素数。 *im* の既定値はゼロ。"

#: ../../library/stdtypes.rst:331
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../../library/stdtypes.rst:331
msgid "conjugate of the complex number *c*. (Identity on real numbers)"
msgstr "複素数 *c* の共役複素数 (実数に対しては同じ値を返す)"

#: ../../library/stdtypes.rst:334
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../library/stdtypes.rst:334
msgid "the pair ``(x // y, x % y)``"
msgstr "``(x // y, x % y)`` からなるペア"

#: ../../library/stdtypes.rst:334 ../../library/stdtypes.rst:749
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../../library/stdtypes.rst:336
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../../library/stdtypes.rst:336 ../../library/stdtypes.rst:338
msgid "*x* to the power *y*"
msgstr "*x* の *y* 乗"

#: ../../library/stdtypes.rst:336
msgid "(3)(7)"
msgstr "(3)(7)"

#: ../../library/stdtypes.rst:338
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../../library/stdtypes.rst:338 ../../library/stdtypes.rst:1516
#: ../../library/stdtypes.rst:1697
msgid "\\(7)"
msgstr "\\(7)"

#: ../../library/stdtypes.rst:352
msgid ""
"For (plain or long) integer division, the result is an integer. The result "
"is always rounded towards minus infinity: 1/2 is 0, (-1)/2 is -1, 1/(-2) is "
"-1, and (-1)/(-2) is 0.  Note that the result is a long integer if either "
"operand is a long integer, regardless of the numeric value."
msgstr ""
"(通常および長) 整数の割り算では、結果は整数になります。この場合値は常にマイナ"
"ス無限大の方向に丸められます: つまり、1/2 は 0、 (-1)/2 は -1、1/(-1) は -1、"
"そして (-1)/(-2) は 0 になります。被演算子の両方が長整数の場合、計算値に関わ"
"らず結果は長整数で返されるので注意してください。"

#: ../../library/stdtypes.rst:365
msgid ""
"Conversion from floats using :func:`int` or :func:`long` truncates toward "
"zero like the related function, :func:`math.trunc`.  Use the function :func:"
"`math.floor` to round downward and :func:`math.ceil` to round upward."
msgstr ""
"浮動小数点数から :func:`int`,または、 :func:`long` を使った変換では、関連する"
"関数、 :func:`math.trunc` のようにゼロ方向へ丸められます。下方向への丸めに"
"は :func:`math.floor` を使い、上方向への丸めには :func:`math.ceil` を使って下"
"さい。"

#: ../../library/stdtypes.rst:371
msgid "See :ref:`built-in-funcs` for a full description."
msgstr "完全な記述については、 :ref:`built-in-funcs`,を参照してください。"

#: ../../library/stdtypes.rst:374
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are no longer defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""
"切り捨て除算演算子、モジュロ演算子、および :func:`divmod` 関数は、複素数に対"
"してはもはや定義されていません。目的に合うならば、代わりに :func:`abs` を使っ"
"て浮動小数点に変換してください。"

#: ../../library/stdtypes.rst:380
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int."
msgstr ""
"整数の除算とも呼ばれます。結果の型は整数型とは限りませんが、結果の値は整数で"
"す。"

#: ../../library/stdtypes.rst:384
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"浮動小数点数は、文字列 \"nan\" と \"inf\" を、必要なら接頭辞 \"+\" または \"-"
"\" と共に、非数 (Not a Number (NaN)) や正、負の無限大として受け付けます。"

#: ../../library/stdtypes.rst:390
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python は、プログラム言語一般でそうであるように、 ``pow(0, 0)`` および ``0 "
"** 0`` を ``1`` と定義します。"

#: ../../library/stdtypes.rst:393
msgid ""
"All :class:`numbers.Real` types (:class:`int`, :class:`long`, and :class:"
"`float`) also include the following operations:"
msgstr ""
"全ての :class:`numbers.Real` 型 (:class:`int`, :class:`long`,および、 :class:"
"`float`) は以下の演算を含みます。 :"

#: ../../library/stdtypes.rst:399
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../../library/stdtypes.rst:399
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* を :class:`~numbers.Integral` (整数) に切り捨てます"

#: ../../library/stdtypes.rst:402
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../../library/stdtypes.rst:402
msgid ""
"*x* rounded to *n* digits, rounding ties away from zero. If *n* is omitted, "
"it defaults to 0."
msgstr ""
"*x* を *n* 桁に丸めます。丸め方は四捨五入です。 *n* が省略されれば 0 がデフォ"
"ルトとなります。(--訳注: Python 3 と仕様が違うので注意してください。1.5 と "
"2.5 の round は、Python 2 ではそれぞれ 2、3 となり、Python 3 では 2、2 となり"
"ます。後者の丸めは .5 を丸める際に偶数になる方へ丸めるので、「偶数丸め」と言"
"います。--)"

#: ../../library/stdtypes.rst:406
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../../library/stdtypes.rst:406
msgid "the greatest integer as a float <= *x*"
msgstr "*x* 以下の最大の整数を浮動小数点数として返します"

#: ../../library/stdtypes.rst:409
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../../library/stdtypes.rst:409
msgid "the least integer as a float >= *x*"
msgstr "*x* 以上の最小の整数を浮動小数点数として返します"

#: ../../library/stdtypes.rst:419
msgid "Bitwise Operations on Integer Types"
msgstr "整数型におけるビット単位演算"

#: ../../library/stdtypes.rst:433
msgid ""
"Bitwise operations only make sense for integers.  Negative numbers are "
"treated as their 2's complement value (this assumes a sufficiently large "
"number of bits that no overflow occurs during the operation)."
msgstr ""
"ビット単位演算は、整数に対してのみ意味があります。負の数は、その 2 の補数の値"
"として扱われます (演算中にオーバフローが起こらないように十分なビット数がある"
"ものと仮定します) 。"

#: ../../library/stdtypes.rst:437
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"二項ビット単位演算の優先順位は全て、数値演算よりも低く、比較よりも高いです; "
"単項演算 ``~`` の優先順位は他の単項数値演算 (``+`` および ``-``) と同じです。"

#: ../../library/stdtypes.rst:441
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr "以下の表では、ビット単位演算を優先順位が低い順に並べています:"

#: ../../library/stdtypes.rst:446
msgid "``x | y``"
msgstr "``x | y``"

#: ../../library/stdtypes.rst:446
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "*x* と *y* のビット単位 :dfn:`論理和`"

#: ../../library/stdtypes.rst:449
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../../library/stdtypes.rst:449
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "*x* と *y* のビット単位 :dfn:`排他的論理和`"

#: ../../library/stdtypes.rst:452
msgid "``x & y``"
msgstr "``x & y``"

#: ../../library/stdtypes.rst:452
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "*x* と *y* のビット単位 :dfn:`論理積`"

#: ../../library/stdtypes.rst:455
msgid "``x << n``"
msgstr "``x << n``"

#: ../../library/stdtypes.rst:455
msgid "*x* shifted left by *n* bits"
msgstr "*x* の *n* ビット左シフト"

#: ../../library/stdtypes.rst:455
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:457
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../../library/stdtypes.rst:457
msgid "*x* shifted right by *n* bits"
msgstr "*x* の *n* ビット右シフト"

#: ../../library/stdtypes.rst:457
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../../library/stdtypes.rst:459
msgid "``~x``"
msgstr "``~x``"

#: ../../library/stdtypes.rst:459
msgid "the bits of *x* inverted"
msgstr "*x* のビット反転"

#: ../../library/stdtypes.rst:465
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr "負値のシフト数は不正であり、 :exc:`ValueError` が送出されます。"

#: ../../library/stdtypes.rst:468
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``.  "
"A long integer is returned if the result exceeds the range of plain integers."
msgstr ""
"*n* ビットの左シフトは、 ``pow(2, n)`` による乗算と等価です。通常整数の範囲を"
"超える結果になる場合は長整数で返されます。"

#: ../../library/stdtypes.rst:472
msgid "A right shift by *n* bits is equivalent to division by ``pow(2, n)``."
msgstr "*n* ビットの右シフトは、 ``pow(2, n)`` による除算と等価です。"

#: ../../library/stdtypes.rst:476
msgid "Additional Methods on Integer Types"
msgstr "整数型における追加のメソッド"

#: ../../library/stdtypes.rst:478
msgid ""
"The integer types implement the :class:`numbers.Integral` :term:`abstract "
"base class`. In addition, they provide one more method:"
msgstr ""
"整数型は :class:`numbers.Integral` :term:`abstract base class` を実装します。"
"さらに、追加のメソッドを一つ提供します。"

#: ../../library/stdtypes.rst:484
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"整数を、符号と先頭の 0 は除いて二進法で表すために必要なビットの数を返します::"

#: ../../library/stdtypes.rst:493
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"正確には、 ``x`` が非 0 なら、 ``x.bit_length()`` は ``2**(k-1) <= abs(x) < "
"2**k`` を満たす唯一の正の整数 ``k`` です。同様に、 ``abs(x)`` が十分小さくて"
"対数を適切に丸められるとき、 ``k = 1 + int(log(abs(x), 2))`` です。 ``x`` が "
"0 なら、 ``x.bit_length()`` は ``0`` を返します。"

#: ../../library/stdtypes.rst:499
msgid "Equivalent to::"
msgstr "次と等価です::"

#: ../../library/stdtypes.rst:510
msgid "Additional Methods on Float"
msgstr "浮動小数点数に対する追加のメソッド"

#: ../../library/stdtypes.rst:512
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"浮動小数点数型は、 :class:`numbers.Real` 抽象基底クラス (:term:`abstract "
"base class`) を実装しています。浮動小数点型はまた、以下の追加のメソッドを持ち"
"ます。"

#: ../../library/stdtypes.rst:517
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float "
"and with a positive denominator.  Raises :exc:`OverflowError` on infinities "
"and a :exc:`ValueError` on NaNs."
msgstr ""
"比が元の浮動小数点数とちょうど同じで分母が正である、一対の整数を返します。無"
"限大に対しては :exc:`OverflowError` を、非数 (NaN) に対しては :exc:"
"`ValueError` を送出します。"

#: ../../library/stdtypes.rst:526
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"浮動小数点数インスタンスが有限の整数値なら ``True`` を、そうでなければ "
"``False`` を返します::"

#: ../../library/stdtypes.rst:536
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"16 進表記の文字列へ、または、 16 進表記からの変換をサポートする二つのメソッド"
"があります。 Python の浮動小数点数は内部的には2進数で保持されるので、浮動小数"
"点数の *10進数* へまたは *10進数* から変換には若干の丸め誤差があります。それ"
"に対し、16 進表記では、浮動小数点数を正確に表現できます。これはデバッグのとき"
"や、数学的な用途 (numerical work) に便利でしょう。"

#: ../../library/stdtypes.rst:547
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"浮動小数点数の 16 進文字列表現を返します。有限の浮動小数点数に対し、この表現"
"は常に ``0x`` で始まり ``p`` と指数が続きます。"

#: ../../library/stdtypes.rst:557
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"16 進文字列表現 *s* で表される、浮動小数点数を返すクラスメソッドです。文字列 "
"*s* は、前や後にホワイトスペースを含んでいても構いません。"

#: ../../library/stdtypes.rst:564
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
":meth:`float.fromhex` はクラスメソッドですが、 :meth:`float.hex` はインスタン"
"スメソッドであることに注意して下さい。"

#: ../../library/stdtypes.rst:567
msgid "A hexadecimal string takes the form::"
msgstr "16 進文字列表現は以下の書式となります::"

#: ../../library/stdtypes.rst:571
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"``sign`` は必須ではなく、 ``+`` と ``-`` のどちらかです。 ``integer`` と "
"``fraction`` は 16 進数の文字列で、 ``exponent`` は 10 進数で符号もつけられま"
"す。大文字・小文字は区別されず、最低でも 1 つの 16 進数文字を整数部もしくは小"
"数部に含む必要があります。この制限は C99 規格のセクション 6.4.4.2 で規定され"
"ていて、 Java 1.5 以降でも使われています。特に、 :meth:`float.hex` の出力は "
"C や Java コード中で、浮動小数点数の 16 進表記として役に立つでしょう。また、 "
"C の ``%a`` 書式や、 Java の ``Double.toHexString`` で書きだされた文字列は :"
"meth:`float.fromhex` で受け付けられます。"

#: ../../library/stdtypes.rst:584
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"なお、指数部は 16 進数ではなく 10 進数で書かれ、係数に掛けられる 2 の累乗を与"
"えます。例えば、16 進文字列 ``0x3.a7p10`` は浮動小数点数 ``(3 + 10./16 + "
"7./16**2) * 2.0**10`` すなわち ``3740.0`` を表します::"

#: ../../library/stdtypes.rst:594
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"逆変換を ``3740.0`` に適用すると、同じ数を表す異なる 16 進文字列表現を返しま"
"す::"

#: ../../library/stdtypes.rst:604
msgid "Iterator Types"
msgstr "イテレータ型"

#: ../../library/stdtypes.rst:614
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python はコンテナでの反復処理の概念をサポートしています。この概念は 2 つの"
"別々のメソッドを使って実装されています; これらのメソッドを使ってユーザ定義の"
"クラスで反復を行えるようにできます。後に詳しく述べるシーケンスは、必ず反復処"
"理メソッドをサポートしています。"

#: ../../library/stdtypes.rst:619
msgid ""
"One method needs to be defined for container objects to provide iteration "
"support:"
msgstr ""
"コンテナオブジェクトに反復処理をサポートさせるためには、以下のメソッドを定義"
"しなければなりません:"

#: ../../library/stdtypes.rst:626
msgid ""
"Return an iterator object.  The object is required to support the iterator "
"protocol described below.  If a container supports different types of "
"iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"イテレータオブジェクトを返します。オブジェクトは後述するイテレータプロトコル"
"をサポートする必要があります。もしコンテナが異なる型の反復処理をサポートする"
"なら、それらの反復処理毎に追加のメソッドを提供しても構いません (複数の形式の"
"反復処理を提供するオブジェクトの例として、幅優先探索と深さ優先探索をサポート"
"する木構造が挙げられます)。このメソッドは Python/C API での Python オブジェク"
"トの型構造体の :c:member:`~PyTypeObject.tp_iter` スロットに対応します。"

#: ../../library/stdtypes.rst:635
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"イテレータオブジェクト自体は以下の 2 のメソッドをサポートする必要があります。"
"これらのメソッドは 2 つ合わせて :dfn:`イテレータプロトコル` を成します:"

#: ../../library/stdtypes.rst:641
msgid ""
"Return the iterator object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements. This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"イテレータオブジェクト自体を返します。このメソッドはコンテナとイテ レータの両"
"方を :keyword:`for` および :keyword:`in` 文で使えるように するために必要で"
"す。このメソッドは Python/C API において Python オ ブジェクトを表す型構造体"
"の :c:member:`~PyTypeObject.tp_iter` スロットに対応します。"

#: ../../library/stdtypes.rst:649
msgid ""
"Return the next item from the container.  If there are no further items, "
"raise the :exc:`StopIteration` exception.  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iternext` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""
"コンテナの次のアイテムを返します。もしそれ以上アイテム無ければ :exc:"
"`StopIteration` 例外を送出します。 このメソッドは Python/C APIでのPythonオブ"
"ジェクトの型構造体の :c:member:`~PyTypeObject.tp_iternext` スロットに対応しま"
"す。"

#: ../../library/stdtypes.rst:654
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Python では、いくつかのイテレータオブジェクトを定義しています。これらは一般の"
"および特殊なシーケンス型、辞書型、そして他のさらに特殊化された形式に渡る反復"
"をサポートします。特殊型は、イテレータプロトコルの実装以外は重要ではありませ"
"ん。"

#: ../../library/stdtypes.rst:659
msgid ""
"The intention of the protocol is that once an iterator's :meth:`~iterator."
"next` method raises :exc:`StopIteration`, it will continue to do so on "
"subsequent calls. Implementations that do not obey this property are deemed "
"broken.  (This constraint was added in Python 2.3; in Python 2.2, various "
"iterators are broken according to this rule.)"
msgstr ""
"このプロトコルでは、イテレータの :meth:`~iterator.next` メソッドが一旦 :exc:"
"`StopIteration` を送出したなら、以降の呼び出しでも例外を送出し続けることを期"
"待します。この特性に従わない実装は壊れているとみなされます。(この制約は "
"Python 2.3 で追加されました。Python 2.2 では色々なイテレータが、このルールに"
"よれば壊れています。)"

#: ../../library/stdtypes.rst:669
msgid "Generator Types"
msgstr "ジェネレータ型"

#: ../../library/stdtypes.rst:671
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`~iterator.__iter__` "
"and :meth:`~iterator.next` methods.  More information about generators can "
"be found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""
"Python における :term:`generator` (ジェネレータ) は、イテレータプロトコルを実"
"装する便利な方法を提供します。コンテナオブジェクトの :meth:`__iter__` メソッ"
"ドがジェネレータとして実装されていれば、そのメソッドは :meth:`~iterator."
"__iter__` および :meth:`~iterator.next` メソッドを提供するイテレータオブジェ"
"クト (厳密にはジェネレータオブジェクト) を自動的に返します。ジェネレータに関"
"する詳細な情報は、 :ref:`yield 式のドキュメント <yieldexpr>` にあります。"

#: ../../library/stdtypes.rst:682
msgid ""
"Sequence Types --- :class:`str`, :class:`unicode`, :class:`list`, :class:"
"`tuple`, :class:`bytearray`, :class:`buffer`, :class:`xrange`"
msgstr ""
"シーケンス型 --- :class:`str`, :class:`unicode`, :class:`list`, :class:"
"`tuple`, :class:`bytearray`, :class:`buffer`, :class:`xrange`"

#: ../../library/stdtypes.rst:684
msgid ""
"There are seven sequence types: strings, Unicode strings, lists, tuples, "
"bytearrays, buffers, and xrange objects."
msgstr ""
"シーケンス型には 7 つあります: 文字列、Unicode 文字列、リスト、タプル、、バイ"
"ト配列 (bytearray)、バッファ、そして xrange オブジェクトです。"

#: ../../library/stdtypes.rst:687
msgid ""
"For other containers see the built in :class:`dict` and :class:`set` "
"classes, and the :mod:`collections` module."
msgstr ""
"他のコンテナ型については、組み込みクラスの :class:`dict` および :class:`set` "
"を参照下さい。"

#: ../../library/stdtypes.rst:701
msgid ""
"String literals are written in single or double quotes: ``'xyzzy'``, "
"``\"frobozz\"``.  See :ref:`strings` for more about string literals. Unicode "
"strings are much like strings, but are specified in the syntax using a "
"preceding ``'u'`` character: ``u'abc'``, ``u\"def\"``. In addition to the "
"functionality described here, there are also string-specific methods "
"described in the :ref:`string-methods` section. Lists are constructed with "
"square brackets, separating items with commas: ``[a, b, c]``. Tuples are "
"constructed by the comma operator (not within square brackets), with or "
"without enclosing parentheses, but an empty tuple must have the enclosing "
"parentheses, such as ``a, b, c`` or ``()``.  A single item tuple must have a "
"trailing comma, such as ``(d,)``."
msgstr ""
"文字列リテラルは ``'xyzzy'`` , ``\"frobozz\"`` といったように、単引用符または"
"二重引用符の中に書かれます。文字列リテラルについての詳細は、 :ref:`strings` "
"を参照下さい。 Unicode 文字列はほとんど文字列と同じですが、 ``u'abc'`` , "
"``u\"def\"`` といったように先頭に文字 ``'u'`` を付けて指定します。リストは "
"``[a, b, c]`` のように要素をコンマで区切り角括弧で囲って生成します。タプルは "
"``a, b, c`` のようにコンマ演算子で区切って生成します (角括弧の中には入れませ"
"ん)。丸括弧で囲っても囲わなくてもかまいませんが、空のタプルは ``()`` のように"
"丸括弧で囲わなければなりません。要素が一つのタプルでは、例えば ``(d,)`` のよ"
"うに、要素の後ろにコンマをつけなければなりません。"

#: ../../library/stdtypes.rst:713
msgid ""
"Bytearray objects are created with the built-in function :func:`bytearray`."
msgstr "バイト配列は、組み込み関数 :func:`bytearray` で構成されます。"

#: ../../library/stdtypes.rst:715
msgid ""
"Buffer objects are not directly supported by Python syntax, but can be "
"created by calling the built-in function :func:`buffer`.  They don't support "
"concatenation or repetition."
msgstr ""
"バッファオブジェクトは Python の構文上では直接サポートされていませんが、組み"
"込み関数 :func:`buffer` で生成することができます。バッファオブジェクトは結合"
"や反復をサポートしていません。"

#: ../../library/stdtypes.rst:719
msgid ""
"Objects of type xrange are similar to buffers in that there is no specific "
"syntax to create them, but they are created using the :func:`xrange` "
"function.  They don't support slicing, concatenation or repetition, and "
"using ``in``, ``not in``, :func:`min` or :func:`max` on them is inefficient."
msgstr ""
"xrange オブジェクトは、オブジェクトを生成するための特殊な構文がない点でバッ"
"ファに似ていて、関数 :func:`xrange` で生成します。 xrange オブジェクトはスラ"
"イス、結合、反復をサポートせず、 ``in`` , ``not in`` , :func:`min` または :"
"func:`max` は効率的ではありません。"

#: ../../library/stdtypes.rst:724
msgid ""
"Most sequence types support the following operations.  The ``in`` and ``not "
"in`` operations have the same priorities as the comparison operations.  The "
"``+`` and ``*`` operations have the same priority as the corresponding "
"numeric operations. [3]_ Additional methods are provided for :ref:`typesseq-"
"mutable`."
msgstr ""
"ほとんどのシーケンス型は以下の演算操作をサポートします。 ``in`` および ``not "
"in`` は比較演算とおなじ優先度を持っています。 ``+`` および ``*`` は対応する数"
"値演算とおなじ優先度です。 [3]_ :ref:`typesseq-mutable` で追加のメソッドが提"
"供されています。"

#: ../../library/stdtypes.rst:729
msgid ""
"This table lists the sequence operations sorted in ascending priority. In "
"the table, *s* and *t* are sequences of the same type; *n*, *i* and *j* are "
"integers:"
msgstr ""
"以下のテーブルはシーケンス型の演算を優先度の低いものから順に挙げたものです。"
"テーブル内の *s* および *t* は同じ型のシーケンスです; *n* , *i* および *j* は"
"整数です:"

#: ../../library/stdtypes.rst:735
msgid "``x in s``"
msgstr "``x in s``"

#: ../../library/stdtypes.rst:735
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "*s* のある要素が *x* と等しければ ``True`` , そうでなければ ``False``"

#: ../../library/stdtypes.rst:738
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../../library/stdtypes.rst:738
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "*s* のある要素が *x* と等しければ ``False``, そうでなければ ``True``"

#: ../../library/stdtypes.rst:741
msgid "``s + t``"
msgstr "``s + t``"

#: ../../library/stdtypes.rst:741
msgid "the concatenation of *s* and *t*"
msgstr "*s* と *t* の結合"

#: ../../library/stdtypes.rst:744
msgid "``s * n, n * s``"
msgstr "``s * n`` または ``n * s``"

#: ../../library/stdtypes.rst:744
msgid "equivalent to adding *s* to itself *n* times"
msgstr "*s* 自身を *n* 回足すのと同じ"

#: ../../library/stdtypes.rst:747
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../library/stdtypes.rst:747
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*s* の 0 から数えて *i* 番目の要素"

#: ../../library/stdtypes.rst:749
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../../library/stdtypes.rst:749
msgid "slice of *s* from *i* to *j*"
msgstr "*s* の *i* から *j* までのスライス"

#: ../../library/stdtypes.rst:751
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../../library/stdtypes.rst:751
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "*s* の *i* から *j* まで、 *k* 毎のスライス"

#: ../../library/stdtypes.rst:751
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../../library/stdtypes.rst:754
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../library/stdtypes.rst:754
msgid "length of *s*"
msgstr "*s* の長さ"

#: ../../library/stdtypes.rst:756
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../../library/stdtypes.rst:756
msgid "smallest item of *s*"
msgstr "*s* の最小の要素"

#: ../../library/stdtypes.rst:758
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../library/stdtypes.rst:758
msgid "largest item of *s*"
msgstr "*s* の最大の要素"

#: ../../library/stdtypes.rst:760
msgid "``s.index(x)``"
msgstr "``s.index(x)``"

#: ../../library/stdtypes.rst:760
msgid "index of the first occurrence of *x* in *s*"
msgstr "*s* 中で *x* が最初に出現するインデックス"

#: ../../library/stdtypes.rst:763 ../../library/stdtypes.rst:1683
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../library/stdtypes.rst:763
msgid "total number of occurrences of *x* in *s*"
msgstr "*s* 中に *x* が出現する回数"

#: ../../library/stdtypes.rst:767
msgid ""
"Sequence types also support comparisons. In particular, tuples and lists are "
"compared lexicographically by comparing corresponding elements. This means "
"that to compare equal, every element must compare equal and the two "
"sequences must be of the same type and have the same length. (For full "
"details see :ref:`comparisons` in the language reference.)"
msgstr ""
"シーケンス型は比較演算子もサポートします。特にタプルとリストは相当する要素に"
"よる辞書編集方式的に比較されます。つまり、等しいということは、ふたつのシーケ"
"ンスの長さ、型が同じであり、全ての要素が等しいということです (詳細は言語リ"
"ファレンスの :ref:`comparisons` を参照下さい) 。"

#: ../../library/stdtypes.rst:790
msgid ""
"When *s* is a string or Unicode string object the ``in`` and ``not in`` "
"operations act like a substring test.  In Python versions before 2.3, *x* "
"had to be a string of length 1. In Python 2.3 and beyond, *x* may be a "
"string of any length."
msgstr ""
"*s* が文字列または Unicode 文字列の場合、演算操作 ``in`` および ``not in`` は"
"部分文字列の一致テストと同じように動作します。バージョン 2.3 以前の Python で"
"は、 *x* は長さ 1 の文字列である必要がありました。 Python 2.3 以降では、 *x* "
"はどんな長さでも構いません。"

#: ../../library/stdtypes.rst:796
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider:"
msgstr ""
"*n* が ``0`` 以下の値の場合、 ``0`` として扱われます (これは *s* と同じ型の空"
"のシーケンスを表します)。シーケンス *s* の要素はコピーされないので注意してく"
"ださい; コピーではなく要素に対する参照カウントが増えます。これは Python に慣"
"れていないプログラマをよく悩ませます。例えば以下のコードを考えます:"

#: ../../library/stdtypes.rst:808
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way:"
msgstr ""
"ここで、``[[]]`` が空リストを含む 1 要素のリストなので、``[[]] * 3`` の 3 要"
"素はこの一つの空リストへの参照です。``lists`` のいずれかの要素を変更すると、"
"その一つのリストが変更されます。別々のリストのリストを作るにはこうします::"

#: ../../library/stdtypes.rst:820
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr "別の説明が FAQ エントリ :ref:`faq-multidimensional-list` にあります。"

#: ../../library/stdtypes.rst:824
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"*i* または *j* が負の数の場合、インデクスはシーケンスの末端からの相対インデク"
"スになります: ``len(s) + i`` または ``len(s) + j`` が代わりに使われます。\n"
"ただし ``-0`` はやはり ``0`` であることに注意してください。"

#: ../../library/stdtypes.rst:829
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"*s* の *i* から *j* へのスライスは ``i <= k < j`` となるようなインデクス *k* "
"を持つ要素からなるシーケンスとして定義されます。 *i* または *j* が "
"``len(s)`` よりも大きい場合、 ``len(s)`` を使います。 *i* が省略されるか "
"``None`` だった場合、 ``0`` を使います。 *j* が省略されるか ``None`` だった場"
"合、 ``len(s)`` を使います。 *i* が *j* 以上の場合、スライスは空のシーケンス"
"になります。"

#: ../../library/stdtypes.rst:836
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"*s* の「 *i* から *j* まででステップが *k* のスライス」は、インデックス ``x "
"= i + n*k`` （ただし n は ``0 <= n < (j-i)/k`` を満たす任意の整数）を持つ要素"
"からなるシーケンスとして定義されます。言い換えるとインデックスは ``i``, "
"``i+k``, ``i+2*k``, ``i+3*k`` と続き、 *j* に達したところでストップします (た"
"だし *j* は含みません)。 *k* が正の数である場合、 *i* または *j* が "
"``len(s)`` より大きければ ``len(s)`` を代わりに使用します。 *k* が負の数であ"
"る場合、 *i* または *j* が ``len(s) - 1`` より大きければ ``len(s) - 1`` を代"
"わりに使用します。 *i* または *j* を省略または ``None`` を指定すると、 \"端"
"\" (どちらの端かは *k* の符号に依存) の値を代わりに使用します。なお *k* はゼ"
"ロにできないので注意してください。また *k* に ``None`` を指定すると、 ``1`` "
"が指定されたものとして扱われます。"

#: ../../library/stdtypes.rst:849
msgid ""
"If *s* and *t* are both strings, some Python implementations such as CPython "
"can usually perform an in-place optimization for assignments of the form ``s "
"= s + t`` or ``s += t``.  When applicable, this optimization makes quadratic "
"run-time much less likely.  This optimization is both version and "
"implementation dependent.  For performance sensitive code, it is preferable "
"to use the :meth:`str.join` method which assures consistent linear "
"concatenation performance across versions and implementations."
msgstr ""
"*s* と *t* の両者が文字列であるとき、 CPython のようないくつかの Python 実装"
"では、 ``s = s + t`` や ``s += t`` という書式で代入をするのに in-place "
"optimization が働きます。このような時、最適化は二乗の実行時間の低減をもたらし"
"ます。この最適化はバージョンや実装に依存します。実行効率が必要なコードでは、"
"バージョンと実装が変わっても、連結の線形的実行効率を保証する :meth:`str."
"join` を使うのがより望ましいでしょう。"

#: ../../library/stdtypes.rst:857
msgid "Formerly, string concatenation never occurred in-place."
msgstr "以前、文字列の連結はin-placeで再帰されませんでした."

#: ../../library/stdtypes.rst:864
msgid "String Methods"
msgstr "文字列メソッド"

#: ../../library/stdtypes.rst:868
msgid ""
"Below are listed the string methods which both 8-bit strings and Unicode "
"objects support.  Some of them are also available on :class:`bytearray` "
"objects."
msgstr ""
"8-bit 文字列と Unicode オブジェクトは、どちらも以下に挙げるメソッドに対応して"
"います。この中には、 :class:`bytearray` オブジェクトで使えるものもあります。"

#: ../../library/stdtypes.rst:872
msgid ""
"In addition, Python's strings support the sequence type methods described in "
"the :ref:`typesseq` section. To output formatted strings use template "
"strings or the ``%`` operator described in the :ref:`string-formatting` "
"section. Also, see the :mod:`re` module for string functions based on "
"regular expressions."
msgstr ""
"さらに、 Python の文字列は :ref:`typesseq` に記載されるシーケンス型のメソッド"
"もサポートします。書式指定して文字列を出力するためには、テンプレート文字列を"
"使うか、 :ref:`string-formatting` に記載される ``%`` 演算子を使います。正規表"
"現に基づく文字列操作関数については、 :mod:`re` モジュールを参照下さい。"

#: ../../library/stdtypes.rst:880
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr "最初の文字を大文字にし、残りを小文字にした文字列のコピーを返します。"

#: ../../library/stdtypes.rst:883 ../../library/stdtypes.rst:1019
#: ../../library/stdtypes.rst:1027 ../../library/stdtypes.rst:1035
#: ../../library/stdtypes.rst:1043 ../../library/stdtypes.rst:1051
#: ../../library/stdtypes.rst:1060 ../../library/stdtypes.rst:1068
#: ../../library/stdtypes.rst:1095 ../../library/stdtypes.rst:1323
#: ../../library/stdtypes.rst:1351 ../../library/stdtypes.rst:1388
msgid "For 8-bit strings, this method is locale-dependent."
msgstr "8ビット文字列では、メソッドはロケール依存になります。"

#: ../../library/stdtypes.rst:888
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is a space)."
msgstr ""
"*width* の長さをもつ中央寄せされた文字列を返します。パディングには "
"*fillchar* で指定された値 (デフォルトではスペース) が使われます。"

#: ../../library/stdtypes.rst:891 ../../library/stdtypes.rst:1086
#: ../../library/stdtypes.rst:1150
msgid "Support for the *fillchar* argument."
msgstr "引数 *fillchar* に対応."

#: ../../library/stdtypes.rst:897
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"[*start*, *end*] の範囲に、部分文字列 *sub* が重複せず出現する回数を返しま"
"す。オプション引数 *start* および *end* はスライス表記と同じように解釈されま"
"す。"

#: ../../library/stdtypes.rst:904
msgid ""
"Decodes the string using the codec registered for *encoding*. *encoding* "
"defaults to the default string encoding.  *errors* may be given to set a "
"different error handling scheme.  The default is ``'strict'``, meaning that "
"encoding errors raise :exc:`UnicodeError`.  Other possible values are "
"``'ignore'``, ``'replace'`` and any other name registered via :func:`codecs."
"register_error`, see section :ref:`codec-base-classes`."
msgstr ""
"codec に登録された文字コード系 *encoding* を使って文字列をデコードします。 "
"*encoding* は標準でデフォルトの文字列エンコーディングになります。標準とは異な"
"るエラー処理を行うために *errors* を与えることができます。標準のエラー処理は "
"``'strict'`` で、エンコードに関するエラーは :exc:`UnicodeError` を送出しま"
"す。他に利用できる値は ``'ignore'``, ``'replace'`` および関数 :func:`codecs."
"register_error` によって登録された名前です。これについてはセクション :ref:"
"`codec-base-classes` 節を参照してください。"

#: ../../library/stdtypes.rst:913
msgid "Support for other error handling schemes added."
msgstr "その他のエラーハンドリングスキーマがサポートされました."

#: ../../library/stdtypes.rst:916 ../../library/stdtypes.rst:936
msgid "Support for keyword arguments added."
msgstr "キーワード引数のサポートが追加されました。"

#: ../../library/stdtypes.rst:921
msgid ""
"Return an encoded version of the string.  Default encoding is the current "
"default string encoding.  *errors* may be given to set a different error "
"handling scheme.  The default for *errors* is ``'strict'``, meaning that "
"encoding errors raise a :exc:`UnicodeError`.  Other possible values are "
"``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` "
"and any other name registered via :func:`codecs.register_error`, see "
"section :ref:`codec-base-classes`. For a list of possible encodings, see "
"section :ref:`standard-encodings`."
msgstr ""
"文字列のエンコードされたバージョンを返します。デフォルトのエンコーディングは"
"現在の文字列エンコーディングのデフォルトです。標準とは異なるエラー処理を行う"
"ために *errors* を与えることができます。標準のエラー処理は ``'strict'`` で、"
"エンコードに関するエラーは :exc:`UnicodeError` を送出します。他に利用できる値"
"は ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` および関数 :func:`codecs.register_error` によって登録"
"された名前です。これについてはセクション :ref:`codec-base-classes` を参照して"
"ください。利用可能なエンコーディングの一覧は、セクション :ref:`standard-"
"encodings` を参照してください。"

#: ../../library/stdtypes.rst:932
msgid ""
"Support for ``'xmlcharrefreplace'`` and ``'backslashreplace'`` and other "
"error handling schemes added."
msgstr ""
"``'xmlcharrefreplace'``, ``'backslashreplace'`` およびその他のエラーハンドリ"
"ングスキーマがサポートされました."

#: ../../library/stdtypes.rst:941
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"文字列が指定された *suffix* で終わるなら ``True`` を、そうでなければ "
"``False`` を返します。 *suffix* は見つけたい複数の接尾語のタプルでも構いませ"
"ん。オプションの *start* があれば、その位置から判定を始めます。オプションの "
"*end* があれば、その位置で比較を止めます。"

#: ../../library/stdtypes.rst:946
msgid "Accept tuples as *suffix*."
msgstr "*suffix* でタプルを受け付けるようになりました."

#: ../../library/stdtypes.rst:952
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline "
"(``\\n``) or return (``\\r``), it is copied and the current column is reset "
"to zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""
"文字列内の全てのタブ文字が 1 つ以上のスペースで置換された、文字列のコピーを返"
"します。スペースの数は現在の桁 (column) 位置と *tabsize* に依存します。タブ位"
"置は *tabsize* 文字毎に存在します (デフォルト値である 8 の場合、タブ位置は "
"0, 8, 16 などになります)。文字列を展開するため、まず現桁位置がゼロにセットさ"
"れ、文字列が 1 文字ずつ調べられます。文字がタブ文字 (``\\t``) であれば、現桁"
"位置が次のタブ位置と一致するまで、1 つ以上のスペースが結果の文字列に挿入され"
"ます。(タブ文字自体はコピーされません。) 文字が改行文字 (``\\n`` もしくは "
"``\\r``) の場合、文字がコピーされ、現桁位置は 0 にリセットされます。その他の"
"文字は変更されずにコピーされ、現桁位置は、その文字の表示のされ方 (訳注: 全"
"角、半角など) に関係なく、1 ずつ増加します。"

#: ../../library/stdtypes.rst:973
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"文字列のスライス ``s[start:end]`` に部分文字列 *sub* が含まれる場合、その最小"
"のインデックスを返します。オプション引数 *start* および *end* はスライス表記"
"と同様に解釈されます。 *sub* が見つからなかった場合 ``-1`` を返します。"

#: ../../library/stdtypes.rst:979
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
":meth:`~str.find` メソッドは、 *sub* の位置を知りたいときにのみ使うべきで"
"す。 *sub* が部分文字列であるかどうかのみを調べるには、 :keyword:`in` 演算子"
"を使ってください::"

#: ../../library/stdtypes.rst:989
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"文字列の書式化操作を行います。このメソッドを呼び出す文字列は通常の文字、また"
"は、 ``{}`` で区切られた置換フィールドを含みます。それぞれの置換フィールドは"
"位置引数のインデックスナンバー、または、キーワード引数の名前を含みます。返り"
"値は、それぞれの置換フィールドが対応する引数の文字列値で置換された文字列のコ"
"ピーです。"

#: ../../library/stdtypes.rst:999
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"書式指定のオプションについては、書式指定文字列を規定する :ref:"
"`formatstrings` を参照下さい。"

#: ../../library/stdtypes.rst:1002
msgid ""
"This method of string formatting is the new standard in Python 3, and should "
"be preferred to the ``%`` formatting described in :ref:`string-formatting` "
"in new code."
msgstr ""
"この文字列書式指定のメソッドは Python 3 での新しい標準であり、新しいコードで"
"は、 :ref:`string-formatting` で規定される ``%`` を使った書式指定より好ましい"
"書き方です。"

#: ../../library/stdtypes.rst:1011
msgid ""
"Like :meth:`find`, but raise :exc:`ValueError` when the substring is not "
"found."
msgstr ""
":meth:`find` と同様ですが、 *sub* が見つからなかった場合 :exc:`ValueError` を"
"送出します。"

#: ../../library/stdtypes.rst:1016
msgid ""
"Return true if all characters in the string are alphanumeric and there is at "
"least one character, false otherwise."
msgstr ""
"文字列中の全ての文字が英数文字で、かつ 1 文字以上ある場合には真を返し、そうで"
"ない場合は偽を返します。"

#: ../../library/stdtypes.rst:1024
msgid ""
"Return true if all characters in the string are alphabetic and there is at "
"least one character, false otherwise."
msgstr ""
"文字列中の全ての文字が英文字で、かつ 1 文字以上ある場合には真を返し、そうでな"
"い場合は偽を返します。"

#: ../../library/stdtypes.rst:1032
msgid ""
"Return true if all characters in the string are digits and there is at least "
"one character, false otherwise."
msgstr "文字列中に数字しかない場合には真を返し、その他の場合は偽を返します。"

#: ../../library/stdtypes.rst:1040
msgid ""
"Return true if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, false otherwise."
msgstr ""
"文字列中の大小文字の区別のある文字 [4]_ 全てが小文字で、かつ大小文字の区別の"
"ある文字が 1 文字以上あるなら真を、そうでなければ偽を返します。"

#: ../../library/stdtypes.rst:1048
msgid ""
"Return true if there are only whitespace characters in the string and there "
"is at least one character, false otherwise."
msgstr ""
"文字列が空白文字だけからなり、かつ 1 文字以上ある場合には真を返し、そうでない"
"場合は偽を返します。"

#: ../../library/stdtypes.rst:1056
msgid ""
"Return true if the string is a titlecased string and there is at least one "
"character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return false otherwise."
msgstr ""
"文字列がタイトルケース文字列であり、かつ 1 文字以上ある場合、例えば大文字は大"
"小文字の区別のない文字の後にのみ続き、小文字は大小文字の区別のある文字の後ろ"
"にのみ続く場合には真を返します。そうでない場合は偽を返します。"

#: ../../library/stdtypes.rst:1065
msgid ""
"Return true if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, false otherwise."
msgstr ""
"文字列中の大小文字の区別のある文字 [4]_ 全てが大文字で、かつ大小文字の区別の"
"ある文字が 1 文字以上あるなら真を、そうでなければ偽を返します。"

#: ../../library/stdtypes.rst:1073
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. If "
"there is any Unicode object in *iterable*, return a Unicode instead. A :exc:"
"`TypeError` will be raised if there are any non-string or non Unicode object "
"values in *iterable*.  The separator between elements is the string "
"providing this method."
msgstr ""
"*イテラブル* 中の文字列を結合した文字列オブジェクトを返します。\n"
"*iterable* に Unicode オブジェクトがある場合は、代わりに Unicode を返しま"
"す。\n"
"文字列でないあるいは Unicode オブジェクトでない値が存在する場合は、 :exc:"
"`TypeError` が送出されます。\n"
"要素間の区切り文字列は、このメソッドを提供する文字列です。"

#: ../../library/stdtypes.rst:1082
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is a space).  The original "
"string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"長さ *width* の左揃えした文字列を返します。パディングは指定された *fillchar* "
"(デフォルトではスペース) を使って行われます。 *width* が ``len(s)`` 以下なら"
"ば、元の文字列が返されます。"

#: ../../library/stdtypes.rst:1092
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"全ての大小文字の区別のある文字 [4]_ が小文字に変換された、文字列のコピーを返"
"します。"

#: ../../library/stdtypes.rst:1100
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped:"
msgstr ""
"文字列の先頭の文字を除去したコピーを返します。引数 *chars* は除去される文字の"
"集合を指定する文字列です。 *chars* が省略されるか ``None`` の場合、空白文字が"
"除去されます。 *chars* 文字列は接頭辞ではなく、その値に含まれる文字の組み合わ"
"せ全てがはぎ取られます。 :"

#: ../../library/stdtypes.rst:1110 ../../library/stdtypes.rst:1187
#: ../../library/stdtypes.rst:1314
msgid "Support for the *chars* argument."
msgstr "引数 *chars* をサポートしました."

#: ../../library/stdtypes.rst:1116
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"文字列を *sep* の最初の出現位置で区切り、 3 要素のタプルを返します。タプルの"
"内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分で"
"す。もし区切れなければ、タプルには元の文字列そのものとその後ろに二つの空文字"
"列が入ります。"

#: ../../library/stdtypes.rst:1126
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""
"文字列をコピーし、現れる部分文字列 *old* 全てを *new* に置換して返します。オ"
"プション引数 *count* が与えられている場合、先頭から *count* 個の *old* だけを"
"置換します。"

#: ../../library/stdtypes.rst:1133
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"文字列中の領域 ``s[start:end]`` に *sub* が含まれる場合、その最大のインデクス"
"を返します。オプション引数 *start* および *end* はスライス表記と同様に解釈さ"
"れます。 *sub* が見つからなかった場合 ``-1``  を返します。"

#: ../../library/stdtypes.rst:1140
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
":meth:`rfind` と同様ですが、 *sub* が見つからなかった場合 :exc:`ValueError` "
"を送出します。"

#: ../../library/stdtypes.rst:1146
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is a space). The original "
"string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"*width* の長さをもつ右寄せした文字列を返します。パディングには *fillchar* で"
"指定された文字(デフォルトではスペース)が使われます。 *width* が ``len(s)`` 以"
"下の場合、元の文字列が返されます。"

#: ../../library/stdtypes.rst:1156
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"文字列を *sep* の最後の出現位置で区切り、 3 要素のタプルを返します。タプルの"
"内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分で"
"す。もし区切れなければ、タプルには二つの空文字列とその後ろに元の文字列そのも"
"のが入ります。"

#: ../../library/stdtypes.rst:1166
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"*sep* を区切り文字とした、文字列中の単語のリストを返します。 *maxsplit* が与"
"えられた場合、文字列の *右端* から最大 *maxsplit* 回分割を行います。*sep* が"
"指定されていない、あるいは ``None`` のとき、全ての空白文字が区切り文字となり"
"ます。右から分割していくことを除けば、 :meth:`rsplit` は後ほど詳しく述べる :"
"meth:`split` と同様に振る舞います。"

#: ../../library/stdtypes.rst:1177
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped:"
msgstr ""
"文字列の末尾部分を除去したコピーを返します。引数 *chars* は除去される文字集合"
"を指定する文字列です。 *chars* が省略されるか ``None`` の場合、空白文字が除去"
"されます。 *chars* 文字列は接尾語ではなく、そこに含まれる文字の組み合わせ全て"
"がはぎ取られます:"

#: ../../library/stdtypes.rst:1193
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"文字列を *sep* をデリミタ文字列として区切った単語のリストを返します。"
"*maxsplit* が与えられていれば、最大で *maxsplit* 回分割されます (つまり、リス"
"トは最大 ``maxsplit+1`` 要素になります)。 *maxsplit* が与えられないか ``-1`` "
"なら、分割の回数に制限はありません (可能なだけ分割されます)。"

#: ../../library/stdtypes.rst:1199
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""
"*sep* が与えられた場合、連続した区切り文字はまとめられず、空の文字列を区切っ"
"ていると判断されます(例えば ``'1,,2'.split(',')`` は ``['1', '', '2']`` を返"
"します)。引数 *sep* は複数の文字にもできます (例えば ``'1<>2<>3'."
"split('<>')`` は ``['1', '2', '3']`` を返します)。区切り文字を指定して空の文"
"字列を分割すると、 ``['']`` を返します。"

#: ../../library/stdtypes.rst:1205
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"*sep* が指定されていないか ``None`` であれば、異なる分割アルゴリズムが適用さ"
"れます。 : 連続する空白文字はひとつのデリミタとみなされます。また、文字列の先"
"頭や末尾に空白があっても、結果の最初や最後に空文字列は含まれません。よって、"
"空文字列や空白だけの文字列を ``None`` デリミタで分割すると ``[]`` が返されま"
"す。"

#: ../../library/stdtypes.rst:1212
msgid ""
"For example, ``' 1  2   3  '.split()`` returns ``['1', '2', '3']``, and ``'  "
"1  2   3  '.split(None, 1)`` returns ``['1', '2   3  ']``."
msgstr ""
"例えば、 ``' 1  2   3  '.split()`` は ``['1', '2', '3']`` を返し、 ``'  1  "
"2   3  '.split(None, 1)`` は ``['1', '2   3  ']`` を返します。"

#: ../../library/stdtypes.rst:1221
msgid ""
"Return a list of the lines in the string, breaking at line boundaries. This "
"method uses the :term:`universal newlines` approach to splitting lines. Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"文字列を改行部分で分解し、各行からなるリストを返します。 このメソッドは、行の"
"分割に :term:`universal newlines` アプローチを使います。*keepends* に真が与え"
"らない限り、返されるリストに改行は含まれません。"

#: ../../library/stdtypes.rst:1226
msgid ""
"Python recognizes ``\"\\r\"``, ``\"\\n\"``, and ``\"\\r\\n\"`` as line "
"boundaries for 8-bit strings."
msgstr ""
"Python は ``\"\\r\"``, ``\"\\n\"``, ``\"\\r\\n\"`` を 8-bit 文字列の行の境界"
"として認識します。"

#: ../../library/stdtypes.rst:1229
msgid "For example::"
msgstr "例えば::"

#: ../../library/stdtypes.rst:1236
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
":meth:`~str.split` とは違って、デリミタ文字列 *sep* が与えられたとき、このメ"
"ソッドは空文字列に空リストを返し、終末の改行は結果に行を追加しません::"

#: ../../library/stdtypes.rst:1245
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "比較のために ``split('\\n')`` は以下のようになります::"

#: ../../library/stdtypes.rst:1254
msgid ""
"Return a list of the lines in the string, like :meth:`str.splitlines`. "
"However, the Unicode method splits on the following line boundaries, which "
"are a superset of the :term:`universal newlines` recognized for 8-bit "
"strings."
msgstr ""
":meth:`str.splitlines` のように、文字列を行のリストにして返します。\n"
"ただし Unicode のメソッドでは、8-bit 文字列の行の境界として認識される :term:"
"`universal newlines` よりも多くの次に挙げる行の境界で分割します。"

#: ../../library/stdtypes.rst:1260
msgid "Representation"
msgstr "表現"

#: ../../library/stdtypes.rst:1260
msgid "Description"
msgstr "説明"

#: ../../library/stdtypes.rst:1262
msgid "``\\n``"
msgstr "``\\n``"

#: ../../library/stdtypes.rst:1262
msgid "Line Feed"
msgstr "改行"

#: ../../library/stdtypes.rst:1264
msgid "``\\r``"
msgstr "``\\r``"

#: ../../library/stdtypes.rst:1264
msgid "Carriage Return"
msgstr "復帰"

#: ../../library/stdtypes.rst:1266
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../../library/stdtypes.rst:1266
msgid "Carriage Return + Line Feed"
msgstr "改行 + 復帰"

#: ../../library/stdtypes.rst:1268
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` or ``\\x0b``"

#: ../../library/stdtypes.rst:1268
msgid "Line Tabulation"
msgstr "垂直タブ"

#: ../../library/stdtypes.rst:1270
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` or ``\\x0c``"

#: ../../library/stdtypes.rst:1270
msgid "Form Feed"
msgstr "改ページ"

#: ../../library/stdtypes.rst:1272
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../../library/stdtypes.rst:1272
msgid "File Separator"
msgstr "ファイル区切り"

#: ../../library/stdtypes.rst:1274
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../../library/stdtypes.rst:1274
msgid "Group Separator"
msgstr "グループ区切り"

#: ../../library/stdtypes.rst:1276
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../../library/stdtypes.rst:1276
msgid "Record Separator"
msgstr "レコード区切り"

#: ../../library/stdtypes.rst:1278
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../../library/stdtypes.rst:1278
msgid "Next Line (C1 Control Code)"
msgstr "改行 (C1 制御コード)"

#: ../../library/stdtypes.rst:1280
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../../library/stdtypes.rst:1280
msgid "Line Separator"
msgstr "行区切り"

#: ../../library/stdtypes.rst:1282
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../../library/stdtypes.rst:1282
msgid "Paragraph Separator"
msgstr "段落区切り"

#: ../../library/stdtypes.rst:1287
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` と ``\\f`` が行境界のリストに追加されました。"

#: ../../library/stdtypes.rst:1292
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"文字列が指定された *prefix* で始まるなら ``True`` を、そうでなければ "
"``False`` を返します。 *prefix* は見つけたい複数の接頭語のタプルでも構いませ"
"ん。オプションの *start* があれば、その位置から判定を始めます。オプションの "
"*end* があれば、その位置で比較を止めます。"

#: ../../library/stdtypes.rst:1297
msgid "Accept tuples as *prefix*."
msgstr "*prefix* でタプルを受け付けるようになりました."

#: ../../library/stdtypes.rst:1303
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped:"
msgstr ""
"文字列の先頭および末尾部分を除去したコピーを返します。引数 *chars* は除去され"
"る文字集合を指定する文字列です。 *chars* が省略されるか ``None`` の場合、空白"
"文字が除去されます。 *chars* 文字列は接頭語でも接尾語でもなく、そこに含まれる"
"文字の組み合わせ全てがはぎ取られます。 :"

#: ../../library/stdtypes.rst:1320
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa."
msgstr "文字列をコピーし、大文字は小文字に、小文字は大文字に変換して返します。"

#: ../../library/stdtypes.rst:1328
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"文字列を、単語ごとに大文字から始まり、残りの文字のうち大小文字の区別があるも"
"のは全て小文字にする、タイトルケースにして返します。"

#: ../../library/stdtypes.rst:1331
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"このアルゴリズムは、連続した文字の集まりという、言語から独立した単純な単語の"
"定義を使います。この定義は多くの状況ではうまく機能しますが、短縮形や所有格の"
"アポストロフィが単語の境界になってしまい、望みの結果を得られない場合がありま"
"す::"

#: ../../library/stdtypes.rst:1339
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr "正規表現を使うことでアポストロフィに対応できます::"

#: ../../library/stdtypes.rst:1356
msgid ""
"Return a copy of the string where all characters occurring in the optional "
"argument *deletechars* are removed, and the remaining characters have been "
"mapped through the given translation table, which must be a string of length "
"256."
msgstr ""
"文字列をコピーし、オプション引数の文字列 *deletechars* の中に含まれる文字を全"
"て除去します。その後、残った文字を変換テーブル *table* に従ってマップして返し"
"ます。変換テーブルは長さ 256 の文字列でなければなりません。"

#: ../../library/stdtypes.rst:1361
msgid ""
"You can use the :func:`~string.maketrans` helper function in the :mod:"
"`string` module to create a translation table. For string objects, set the "
"*table* argument to ``None`` for translations that only delete characters:"
msgstr ""
"トランスレーションテーブル作成のために、 :mod:`string` モジュールの :func:"
"`~string.maketrans` 補助関数を使うこともできます。文字列型オブジェクトに対し"
"ては、 *table* 引数に ``None`` を与えることで、文字の削除だけを実施します。:"

#: ../../library/stdtypes.rst:1368
msgid "Support for a ``None`` *table* argument."
msgstr "``None`` の *table* 引数をサポートしました。"

#: ../../library/stdtypes.rst:1371
msgid ""
"For Unicode objects, the :meth:`translate` method does not accept the "
"optional *deletechars* argument.  Instead, it returns a copy of the *s* "
"where all characters have been mapped through the given translation table "
"which must be a mapping of Unicode ordinals to Unicode ordinals, Unicode "
"strings or ``None``. Unmapped characters are left untouched. Characters "
"mapped to ``None`` are deleted.  Note, a more flexible approach is to create "
"a custom character mapping codec using the :mod:`codecs` module (see :mod:"
"`encodings.cp1251` for an example)."
msgstr ""
"Unicode オブジェクトの場合、 :meth:`translate` メソッドはオプションの "
"*deletechars* 引数を受理しません。その代わり、メソッドはすべての文字が与えら"
"れた変換テーブルで対応付けされている *s* のコピーを返します。この変換テーブル"
"は Unicode 順 (ordinal) から Unicode 順、 Unicode 文字列、または ``None`` へ"
"の対応付けでなくてはなりません。対応付けされていない文字は何もせず放置されま"
"す。 ``None`` に対応付けられた文字は削除されます。ちなみに、より柔軟性のある"
"アプローチは、自作の文字対応付けを行う codec を :mod:`codecs` モジュールを"
"使って作成することです (例えば :mod:`encodings.cp1251` を参照してください。)"

#: ../../library/stdtypes.rst:1383
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"全ての大小文字の区別のある文字 [4]_ が大文字に変換された、文字列のコピーを返"
"します。なお ``s.upper().isupper()`` は、 ``s`` が大小文字の区別のある文字を"
"含まなかったり、結果の文字の Unicode カテゴリが \"Lu\" ではなく例えば "
"\"Lt\" (Letter, titlecase) などであったら、 ``False`` になりえます。"

#: ../../library/stdtypes.rst:1393
msgid ""
"Return the numeric string left filled with zeros in a string of length "
"*width*.  A sign prefix is handled correctly.  The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"数値文字列の左側をゼロ詰めし、幅 *width* の文字列で返します。符号接頭辞も正し"
"く扱われます。 *width* が ``len(s)`` 以下の場合もとの文字列自体が返されます。"

#: ../../library/stdtypes.rst:1400
msgid "The following methods are present only on unicode objects:"
msgstr "以下のメソッドは、 Unicode オブジェクトにのみ実装されます:"

#: ../../library/stdtypes.rst:1404
msgid ""
"Return ``True`` if there are only numeric characters in S, ``False`` "
"otherwise. Numeric characters include digit characters, and all characters "
"that have the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION "
"ONE FIFTH."
msgstr ""
"数字を表す文字のみで構成される場合、 ``True`` を返します。それ以外の場合は "
"``False`` を返します。数字を表す文字には、 0 から 9 までの数字と、 Unicode の"
"数字プロパティを持つ全ての文字が含まれます。 (e.g. U+2155, VULGAR FRACTION "
"ONE FIFTH)"

#: ../../library/stdtypes.rst:1411
msgid ""
"Return ``True`` if there are only decimal characters in S, ``False`` "
"otherwise. Decimal characters include digit characters, and all characters "
"that can be used to form decimal-radix numbers, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO."
msgstr ""
"10 進数文字のみで構成される場合、 ``True`` を返します。それ以外の場合は、 "
"``False`` を返します。 10 進数文字には 0 から 9 までの数字と、 10 進基数表記"
"に使われる全ての文字が含まれます。 (e.g. U+0660, ARABIC-INDIC DIGIT ZERO)"

#: ../../library/stdtypes.rst:1420
msgid "String Formatting Operations"
msgstr "文字列フォーマット操作"

#: ../../library/stdtypes.rst:1432
msgid ""
"String and Unicode objects have one unique built-in operation: the ``%`` "
"operator (modulo).  This is also known as the string *formatting* or "
"*interpolation* operator.  Given ``format % values`` (where *format* is a "
"string or Unicode object), ``%`` conversion specifications in *format* are "
"replaced with zero or more elements of *values*.  The effect is similar to "
"the using :c:func:`sprintf` in the C language.  If *format* is a Unicode "
"object, or if any of the objects being converted using the ``%s`` conversion "
"are Unicode objects, the result will also be a Unicode object."
msgstr ""
"文字列および Unicode オブジェクトには固有の操作: ``%`` 演算子 (モジュロ) があ"
"ります。この演算子は文字列 *フォーマット化* または *補間* 演算としても知られ"
"ています。 ``format % values`` (*format* は文字列または Unicode オブジェク"
"ト) とすると、 *format* 中の ``%`` 変換指定は *values* 中のゼロ個またはそれ以"
"上の要素で置換されます。この動作は C 言語における :c:func:`sprintf` に似てい"
"ます。 *format* が Unicode オブジェクトであるか、または ``%s`` 変換を使って "
"Unicode オブジェクトが変換される場合、その結果も Unicode オブジェクトになりま"
"す。"

#: ../../library/stdtypes.rst:1441
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"*format* が単一の引数しか要求しない場合、 *values* はタプルでない単一のオブ"
"ジェクトでもかまいません。 [5]_ それ以外の場合、 *values* はフォーマット文字"
"列中で指定された項目と正確に同じ数の要素からなるタプルか、単一のマップオブ"
"ジェクトでなければなりません。"

#: ../../library/stdtypes.rst:1446
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"一つの変換指定子は 2 またはそれ以上の文字を含み、その構成要素は以下からなりま"
"すが、示した順に出現しなければなりません:"

#: ../../library/stdtypes.rst:1449
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "指定子の開始を示す文字 ``'%'`` 。"

#: ../../library/stdtypes.rst:1451
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"マップキー (オプション)。丸括弧で囲った文字列からなります (例えば "
"``(somename)``) 。"

#: ../../library/stdtypes.rst:1454
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr "変換フラグ (オプション)。一部の変換型の結果に影響します。"

#: ../../library/stdtypes.rst:1457
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"最小のフィールド幅 (オプション)。 ``'*'`` (アスタリスク) を指定した場合、実際"
"の文字列幅が *values* タプルの次の要素から読み出されます。タプルには最小"
"フィールド幅やオプションの精度指定の後に変換したいオブジェクトがくるようにし"
"ます。"

#: ../../library/stdtypes.rst:1461
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual width is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"精度 (オプション)。 ``'.'`` (ドット) とその後に続く精度で与えられます。 "
"``'*'`` (アスタリスク) を指定した場合、精度の桁数は *values* タプルの次の要素"
"から読み出されます。タプルには精度指定の後に変換したい値がくるようにします。"

#: ../../library/stdtypes.rst:1466
msgid "Length modifier (optional)."
msgstr "精度長変換子 (オプション)。"

#: ../../library/stdtypes.rst:1468
msgid "Conversion type."
msgstr "変換型。"

#: ../../library/stdtypes.rst:1470
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"``%`` 演算子の右側の引数が辞書の場合 (またはその他のマップ型の場合), 文字列中"
"のフォーマットには、辞書に挿入されているキーを丸括弧で囲い、文字 ``'%'`` の直"
"後にくるようにしたものが含まれていなければ *なりません* 。マップキーはフォー"
"マット化したい値をマップから選び出します。例えば:"

#: ../../library/stdtypes.rst:1479
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"この場合、 ``*`` 指定子をフォーマットに含めてはいけません (``*`` 指定子は順番"
"付けされたパラメタのリストが必要だからです)。"

#: ../../library/stdtypes.rst:1482
msgid "The conversion flag characters are:"
msgstr "変換フラグ文字を以下に示します:"

#: ../../library/stdtypes.rst:1485
msgid "Flag"
msgstr "フラグ"

#: ../../library/stdtypes.rst:1487
msgid "``'#'``"
msgstr "``'#'``"

#: ../../library/stdtypes.rst:1487
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr "値の変換に (下で定義されている) \"別の形式\" を使います。"

#: ../../library/stdtypes.rst:1490
msgid "``'0'``"
msgstr "``'0'``"

#: ../../library/stdtypes.rst:1490
msgid "The conversion will be zero padded for numeric values."
msgstr "数値型に対してゼロによるパディングを行います。"

#: ../../library/stdtypes.rst:1492
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/stdtypes.rst:1492
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"変換された値を左寄せにします (``'0'`` と同時に与えた場合、 ``'0'`` を上書きし"
"ます) 。"

#: ../../library/stdtypes.rst:1495
msgid "``' '``"
msgstr "``' '``"

#: ../../library/stdtypes.rst:1495
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(スペース) 符号付きの変換で正の数の場合、前に一つスペースを空けます (そうでな"
"い場合は空文字になります) 。"

#: ../../library/stdtypes.rst:1498
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/stdtypes.rst:1498
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""
"変換の先頭に符号文字 (``'+'`` または ``'-'``) を付けます(\"スペース\" フラグ"
"を上書きします) 。"

#: ../../library/stdtypes.rst:1502
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"精度長変換子(``h``, ``l``,または ``L``) を使うことができますが、 Python では"
"必要ないため無視されます。 -- つまり、例えば ``%ld`` は ``%d`` と等価です。"

#: ../../library/stdtypes.rst:1505
msgid "The conversion types are:"
msgstr "変換型を以下に示します:"

#: ../../library/stdtypes.rst:1508
msgid "Conversion"
msgstr "変換"

#: ../../library/stdtypes.rst:1510
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/stdtypes.rst:1510 ../../library/stdtypes.rst:1512
msgid "Signed integer decimal."
msgstr "符号付き 10 進整数。"

#: ../../library/stdtypes.rst:1512
msgid "``'i'``"
msgstr "``'i'``"

#: ../../library/stdtypes.rst:1514
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/stdtypes.rst:1514
msgid "Signed octal value."
msgstr "符号付き 8 進数。"

#: ../../library/stdtypes.rst:1516
msgid "``'u'``"
msgstr "``'u'``"

#: ../../library/stdtypes.rst:1516
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "旧式の型 -- ``'d'`` と同じです。"

#: ../../library/stdtypes.rst:1518
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/stdtypes.rst:1518
msgid "Signed hexadecimal (lowercase)."
msgstr "符号付き 16 進数 (小文字)。"

#: ../../library/stdtypes.rst:1520
msgid "``'X'``"
msgstr "``'X'``"

#: ../../library/stdtypes.rst:1520
msgid "Signed hexadecimal (uppercase)."
msgstr "符号付き 16 進数 (大文字)。"

#: ../../library/stdtypes.rst:1522
msgid "``'e'``"
msgstr "``'e'``"

#: ../../library/stdtypes.rst:1522
msgid "Floating point exponential format (lowercase)."
msgstr "指数表記の浮動小数点数 (小文字)。"

#: ../../library/stdtypes.rst:1524
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/stdtypes.rst:1524
msgid "Floating point exponential format (uppercase)."
msgstr "指数表記の浮動小数点数 (大文字)。"

#: ../../library/stdtypes.rst:1526
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/stdtypes.rst:1526 ../../library/stdtypes.rst:1528
msgid "Floating point decimal format."
msgstr "10 進浮動小数点数。"

#: ../../library/stdtypes.rst:1528
msgid "``'F'``"
msgstr "``'F'``"

#: ../../library/stdtypes.rst:1530
msgid "``'g'``"
msgstr "``'g'``"

#: ../../library/stdtypes.rst:1530
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"浮動小数点数。指数部が -4 以上または精度以下の場合には小文字指数表記、それ以"
"外の場合には10進表記。"

#: ../../library/stdtypes.rst:1534
msgid "``'G'``"
msgstr "``'G'``"

#: ../../library/stdtypes.rst:1534
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"浮動小数点数。指数部が -4 以上または精度以下の場合には大文字指数表記、それ以"
"外の場合には10進表記。"

#: ../../library/stdtypes.rst:1538
msgid "``'c'``"
msgstr "``'c'``"

#: ../../library/stdtypes.rst:1538
msgid "Single character (accepts integer or single character string)."
msgstr "文字一文字 (整数または一文字からなる文字列を受理します)。"

#: ../../library/stdtypes.rst:1541
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/stdtypes.rst:1541
msgid "String (converts any Python object using :ref:`repr() <func-repr>`)."
msgstr ""
"文字列 (Python オブジェクトを :ref:`repr() <func-repr>` で変換します)。"

#: ../../library/stdtypes.rst:1541 ../../library/stdtypes.rst:1690
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/stdtypes.rst:1544
msgid "``'s'``"
msgstr "``'s'``"

#: ../../library/stdtypes.rst:1544
msgid "String (converts any Python object using :func:`str`)."
msgstr "文字列 (Python オブジェクトを :func:`str` で変換します)。"

#: ../../library/stdtypes.rst:1547
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/stdtypes.rst:1547
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr "引数を変換せず、返される文字列中では文字 ``'%'`` になります。"

#: ../../library/stdtypes.rst:1554
msgid ""
"The alternate form causes a leading zero (``'0'``) to be inserted between "
"left-hand padding and the formatting of the number if the leading character "
"of the result is not already a zero."
msgstr ""
"この形式の出力にした場合、変換結果の先頭の数字がゼロ (``'0'``) でないときに"
"は、数字の先頭と左側のパディングとの間にゼロを挿入します。"

#: ../../library/stdtypes.rst:1559
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"別の形式を指定（訳注: 変換フラグ ``#`` を使用）すると 16 進数を表す接頭辞 "
"``'0x'`` または ``'0X'`` (使用するフォーマット文字が ``'x'`` か ``'X'`` に依"
"存します) が最初の数字の前に挿入されます。"

#: ../../library/stdtypes.rst:1563
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""
"この形式にした場合、変換結果には常に小数点が含まれ、それはその後ろに数字が続"
"かない場合にも適用されます。"

#: ../../library/stdtypes.rst:1566
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr "指定精度は小数点の後の桁数を決定し、そのデフォルトは 6 です。"

#: ../../library/stdtypes.rst:1570
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"この形式にした場合、変換結果には常に小数点が含まれ他の形式とは違って末尾の 0 "
"は取り除かれません。"

#: ../../library/stdtypes.rst:1573
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr "指定精度は小数点の前後の有効桁数を決定し、そのデフォルトは 6 です。"

#: ../../library/stdtypes.rst:1577
msgid "The ``%r`` conversion was added in Python 2.0."
msgstr "``%r`` 変換は Python 2.0 で追加されました。"

#: ../../library/stdtypes.rst:1579 ../../library/stdtypes.rst:1585
msgid "The precision determines the maximal number of characters used."
msgstr "指定精度は最大文字数を決定します。"

#: ../../library/stdtypes.rst:1582
msgid ""
"If the object or format provided is a :class:`unicode` string, the resulting "
"string will also be :class:`unicode`."
msgstr ""
"オブジェクトや与えられた書式が :class:`unicode` 文字列の場合、変換後の文字列"
"も :class:`unicode` になります。"

#: ../../library/stdtypes.rst:1588
msgid "See :pep:`237`."
msgstr ":pep:`237` を参照してください。"

#: ../../library/stdtypes.rst:1590
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Python 文字列には明示的な長さ情報があるので、 ``%s`` 変換において ``'\\0'`` "
"を文字列の末端と仮定したりはしません。"

#: ../../library/stdtypes.rst:1595
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"絶対値が 1e50 を超える数値の ``%f`` 変換が ``%g`` 変換に置き換えられなくなり"
"ました。"

#: ../../library/stdtypes.rst:1603
msgid ""
"Additional string operations are defined in standard modules :mod:`string` "
"and :mod:`re`."
msgstr ""
"その他の文字列操作は標準モジュール :mod:`string` および :mod:`re` で定義され"
"ています。"

#: ../../library/stdtypes.rst:1610
msgid "XRange Type"
msgstr "XRange 型"

#: ../../library/stdtypes.rst:1614
msgid ""
"The :class:`xrange` type is an immutable sequence which is commonly used for "
"looping.  The advantage of the :class:`xrange` type is that an :class:"
"`xrange` object will always take the same amount of memory, no matter the "
"size of the range it represents.  There are no consistent performance "
"advantages."
msgstr ""
":class:`xrange` 型は値の変更不能なシーケンスで、広範なループ処理に使われてい"
"ます。 :class:`xrange` 型の利点は、 :class:`xrange` オブジェクトは表現する値"
"域の大きさにかかわらず常に同じ量のメモリしか占めないということです。はっきり"
"したパフォーマンス上の利点はありません。"

#: ../../library/stdtypes.rst:1619
msgid ""
"XRange objects have very little behavior: they only support indexing, "
"iteration, and the :func:`len` function."
msgstr ""
"XRange オブジェクトは非常に限られた振る舞い、すなわち、インデクス検索、反"
"復、 :func:`len` 関数のみをサポートしています。"

#: ../../library/stdtypes.rst:1626
msgid "Mutable Sequence Types"
msgstr "ミュータブルなシーケンス型"

#: ../../library/stdtypes.rst:1632
msgid ""
"List and :class:`bytearray` objects support additional operations that allow "
"in-place modification of the object. Other mutable sequence types (when "
"added to the language) should also support these operations. Strings and "
"tuples are immutable sequence types: such objects cannot be modified once "
"created. The following operations are defined on mutable sequence types "
"(where *x* is an arbitrary object):"
msgstr ""
"リストとバイト配列 (:class:`bytearray`) オブジェクトは、オブジェクトをインプ"
"レースに変更できるようにする追加の操作をサポートします。他のミュータブルな"
"シーケンス型 (を言語に追加するとき) も、それらの操作をサポートするべきです。"
"文字列およびタプルはイミュータブルなシーケンス型です: これらのオブジェクトは"
"一度生成されたら変更できません。ミュータブルなシーケンス型では以下の操作が定"
"義されています (ここで *x* は任意のオブジェクトとします)。"

#: ../../library/stdtypes.rst:1659
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../library/stdtypes.rst:1659
msgid "item *i* of *s* is replaced by *x*"
msgstr "*s* の要素 *i* を *x* と入れ替えます"

#: ../../library/stdtypes.rst:1662
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../library/stdtypes.rst:1662
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""
"*s* の *i* から *j* 番目までのスライスをイテラブル *t* の内容に入れ替えます"

#: ../../library/stdtypes.rst:1666
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../library/stdtypes.rst:1666
msgid "same as ``s[i:j] = []``"
msgstr "``s[i:j] = []`` と同じです"

#: ../../library/stdtypes.rst:1668
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../library/stdtypes.rst:1668
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "``s[i:j:k]`` の要素を *t* の要素と入れ替えます"

#: ../../library/stdtypes.rst:1671
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../library/stdtypes.rst:1671
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "リストから ``s[i:j:k]`` の要素を削除します"

#: ../../library/stdtypes.rst:1674
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../library/stdtypes.rst:1674
msgid "same as ``s[len(s):len(s)] = [x]``"
msgstr "``s[len(s):len(s)] = [x]`` と同じです"

#: ../../library/stdtypes.rst:1677
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` または ``s += t``"

#: ../../library/stdtypes.rst:1677
msgid "for the most part the same as ``s[len(s):len(s)] = t``"
msgstr "``s[len(s):len(s)] = t`` とほとんど同じです"

#: ../../library/stdtypes.rst:1680
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../../library/stdtypes.rst:1680
msgid "updates *s* with its contents repeated *n* times"
msgstr "*s* をその内容を *n*  回繰り返したもので更新"

#: ../../library/stdtypes.rst:1680
msgid "\\(11)"
msgstr "\\(11)"

#: ../../library/stdtypes.rst:1683
msgid "return number of *i*'s for which ``s[i] == x``"
msgstr "``s[i] == x`` となる *i* の個数を返します"

#: ../../library/stdtypes.rst:1686
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../../library/stdtypes.rst:1686
msgid "return smallest *k* such that ``s[k] == x`` and ``i <= k < j``"
msgstr "``s[k] == x`` かつ ``i <= k < j`` となる最小の *k* を返します"

#: ../../library/stdtypes.rst:1690
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../library/stdtypes.rst:1690
msgid "same as ``s[i:i] = [x]``"
msgstr "``s[i:i] = [x]`` と同じです"

#: ../../library/stdtypes.rst:1692
msgid "``s.pop([i])``"
msgstr "``s.pop([i])``"

#: ../../library/stdtypes.rst:1692
msgid "same as ``x = s[i]; del s[i]; return x``"
msgstr "``x = s[i]; del s[i]; return x`` と同じです"

#: ../../library/stdtypes.rst:1695
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/stdtypes.rst:1695
msgid "same as ``del s[s.index(x)]``"
msgstr "``del s[s.index(x)]`` と同じです"

#: ../../library/stdtypes.rst:1697
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../library/stdtypes.rst:1697
msgid "reverses the items of *s* in place"
msgstr "*s* をインプレースに逆転させます"

#: ../../library/stdtypes.rst:1700
msgid "``s.sort([cmp[, key[, reverse]]])``"
msgstr "``s.sort([cmp[, key[, reverse]]])``"

#: ../../library/stdtypes.rst:1700
msgid "sort the items of *s* in place"
msgstr "*s* の要素をインプレースに並べ替えます"

#: ../../library/stdtypes.rst:1700
msgid "(7)(8)(9)(10)"
msgstr "(7)(8)(9)(10)"

#: ../../library/stdtypes.rst:1707
msgid "*t* must have the same length as the slice it is  replacing."
msgstr "*t* は置き換えるスライスと同じ長さでなければいけません。"

#: ../../library/stdtypes.rst:1710
msgid ""
"The C implementation of Python has historically accepted multiple parameters "
"and implicitly joined them into a tuple; this no longer works in Python "
"2.0.  Use of this misfeature has been deprecated since Python 1.4."
msgstr ""
"かつての Python の C 実装では、複数パラメタを受理し、暗黙にそれらをタプルに結"
"合していました。この間違った機能は Python 1.4 で撤廃され、 Python 2.0 の導入"
"とともにエラーにするようになりました。"

#: ../../library/stdtypes.rst:1715
msgid "*t* can be any iterable object."
msgstr "*x* は任意のイテラブルオブジェクトにできます。"

#: ../../library/stdtypes.rst:1718
msgid ""
"Raises :exc:`ValueError` when *x* is not found in *s*. When a negative index "
"is passed as the second or third parameter to the :meth:`index` method, the "
"list length is added, as for slice indices.  If it is still negative, it is "
"truncated to zero, as for slice indices."
msgstr ""
"*x* が *s* 中に見つからなかった場合 :exc:`ValueError` を送出します。負のイン"
"デクスが二番目または三番目のパラメタとして :meth:`index` メソッドに渡される"
"と、これらの値にはスライスのインデクスと同様にリストの長さが加算されます。加"
"算後もまだ負の場合、その値はスライスのインデクスと同様にゼロに切り詰められま"
"す。"

#: ../../library/stdtypes.rst:1723
msgid ""
"Previously, :meth:`index` didn't have arguments for specifying start and "
"stop positions."
msgstr ""
"以前は :meth:`index` には開始と終了位置を指定する引数がありませんでした。"

#: ../../library/stdtypes.rst:1728
msgid ""
"When a negative index is passed as the first parameter to the :meth:`insert` "
"method, the list length is added, as for slice indices.  If it is still "
"negative, it is truncated to zero, as for slice indices."
msgstr ""
":meth:`insert` の最初のパラメタとして負のインデクスが渡された場合、スライスの"
"インデクスと同じく、リストの長さが加算されます。それでも負の値を取る場合、ス"
"ライスのインデクスと同じく、 0 に丸められます。"

#: ../../library/stdtypes.rst:1732
msgid "Previously, all negative indices were truncated to zero."
msgstr "以前は、すべての負値は 0 に丸められていました。"

#: ../../library/stdtypes.rst:1736
msgid ""
"The :meth:`pop` method's optional argument *i* defaults to ``-1``, so that "
"by default the last item is removed and returned."
msgstr ""
":meth:`pop` メソッドのオプションの引数 *i* は標準で ``-1`` なので、標準では最"
"後の要素をリストから除去して返します。"

#: ../../library/stdtypes.rst:1740
msgid ""
"The :meth:`sort` and :meth:`reverse` methods modify the list in place for "
"economy of space when sorting or reversing a large list.  To remind you that "
"they operate by side effect, they don't return the sorted or reversed list."
msgstr ""
":meth:`sort` および :meth:`reverse` メソッドは大きなリストを並べ替えたり反転"
"したりする際、容量の節約のためにリストを直接変更します。副作用があることを"
"ユーザに思い出させるために、これらの操作は並べ替えまたは反転されたリストを返"
"しません。"

#: ../../library/stdtypes.rst:1745
msgid ""
"The :meth:`sort` method takes optional arguments for controlling the "
"comparisons."
msgstr ""
":meth:`sort` メソッドは、比較を制御するためにオプションの引数をとります。"

#: ../../library/stdtypes.rst:1748
msgid ""
"*cmp* specifies a custom comparison function of two arguments (list items) "
"which should return a negative, zero or positive number depending on whether "
"the first argument is considered smaller than, equal to, or larger than the "
"second argument: ``cmp=lambda x,y: cmp(x.lower(), y.lower())``.  The default "
"value is ``None``."
msgstr ""
"*cmp* は2つの引数 (リストの要素) からなるカスタムの比較関数を指定します。 こ"
"れは始めの引数が 2 つ目の引数に比べて小さい、等しい、大きいかに応じて負数、ゼ"
"ロ、正数を返します。 ``cmp=lambda x,y: cmp(x.lower(), y.lower())`` 。デフォル"
"ト値は ``None`` です。"

#: ../../library/stdtypes.rst:1754
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element: ``key=str.lower``.  The default value "
"is ``None``."
msgstr ""
"*key* は 1 つの引数からなる関数を指定します。これはリストの各要素から比較の"
"キーを取り出すのに使われます: ``key=str.lower``。デフォルト値は ``None`` で"
"す。"

#: ../../library/stdtypes.rst:1757
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* はブール値です。``True`` に設定された場合、リストの要素は各比較が反"
"転したように並び替えられます。"

#: ../../library/stdtypes.rst:1760
msgid ""
"In general, the *key* and *reverse* conversion processes are much faster "
"than specifying an equivalent *cmp* function.  This is because *cmp* is "
"called multiple times for each list element while *key* and *reverse* touch "
"each element only once.  Use :func:`functools.cmp_to_key` to convert an old-"
"style *cmp* function to a *key* function."
msgstr ""
"一般的に、 *key* および *reverse* の変換プロセスは同等の *cmp* 関数を指定する"
"より早く動作します。これは *key* および *reverse* がそれぞれの要素に一度だけ"
"触れる間に、 *cmp* はリストのそれぞれの要素に対して複数回呼ばれることによるも"
"のです。旧式の *cmp* 関数を *key* 関数に変換するには :func:`functools."
"cmp_to_key` を使用してください。"

#: ../../library/stdtypes.rst:1766
msgid "Support for ``None`` as an equivalent to omitting *cmp* was added."
msgstr ""
"``None`` を渡すのと、 *cmp* を省略した場合とで、同等に扱うサポートを追加."

#: ../../library/stdtypes.rst:1769
msgid "Support for *key* and *reverse* was added."
msgstr "*key* および *reverse* のサポートを追加."

#: ../../library/stdtypes.rst:1773
msgid ""
"Starting with Python 2.3, the :meth:`sort` method is guaranteed to be "
"stable.  A sort is stable if it guarantees not to change the relative order "
"of elements that compare equal --- this is helpful for sorting in multiple "
"passes (for example, sort by department, then by salary grade)."
msgstr ""
"Python 2.3 より、 :meth:`sort` メソッドは安定していることが保証されています。"
"ソートは、等しい要素の相対順序が変更されないことが保証されていれば、安定して"
"います --- これは複合的なパスでソートを行なう（例えば部署でソートして、それか"
"ら給与の等級でソートする）のに役立ちます。"

#: ../../library/stdtypes.rst:1781
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python 2.3 and "
"newer makes the list appear empty for the duration, and raises :exc:"
"`ValueError` if it can detect that the list has been mutated during a sort."
msgstr ""
"リストがソートされている間、または変更しようとする試みの影響中、あるいは検査"
"中でさえ、リストは未定義です。Python 2.3 とそれ以降の C 実装では、それらが続"
"いている間、リストは空として出力され、リストがソート中に変更されていることを"
"検知できたら :exc:`ValueError` を送出します。"

#: ../../library/stdtypes.rst:1788
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq`."
msgstr ""
"値 *n* は整数または :meth:`~object.__index__` を実装したオブジェクトです。 "
"*n* にゼロや負数を与えると、シーケンスをクリアします。シーケンス内の要素はコ"
"ピーされません; コピーではなく要素に対する参照カウントが増えます。 ``s * n`` "
"について :ref:`typesseq` で説明したとおりです。"

#: ../../library/stdtypes.rst:1797
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "set（集合）型 --- :class:`set`, :class:`frozenset`"

#: ../../library/stdtypes.rst:1801
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built "
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
":dfn:`set` オブジェクトは順序付けされていない :term:`hashable` (ハッシュ可能"
"な) オブジェクトのコレクションです。よくある使い方には、メンバーシップのテス"
"ト、数列から重複を削除する、そして論理積、論理和、差集合、対称差など数学的演"
"算の計算が含まれます。 (他のコンテナ型については、組み込みクラスの :class:"
"`dict`, :class:`list`, :class:`tuple`,および、モジュール :mod:`collections` "
"を参照下さい)"

#: ../../library/stdtypes.rst:1811
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"集合は、他のコレクションと同様、 ``x in set``, ``len(set)``, ``for x in "
"set`` をサポートします。コレクションには順序がないので、集合は挿入の順序や要"
"素の位置を記録しません。従って、集合はインデクシング、スライシング、その他の"
"シーケンス的な振舞いをサポートしません。"

#: ../../library/stdtypes.rst:1816
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
":class:`set` および :class:`frozenset` という、2つの組み込みの集合型がありま"
"す。 :class:`set` はミュータブルで、:meth:`~set.add` や :meth:`~set.remove` "
"のようなメソッドを使って内容を変更できます。ミュータブルなため、ハッシュ値を"
"持たず、また辞書のキーや他の集合の要素として用いることができません。一方、:"
"class:`frozenset` 型はイミュータブルで、:term:`ハッシュ可能<hashable>` です。"
"作成後に内容を改変できないため、辞書のキーや他の集合の要素として用いることが"
"できます。"

#: ../../library/stdtypes.rst:1824
msgid ""
"As of Python 2.7, non-empty sets (not frozensets) can be created by placing "
"a comma-separated list of elements within braces, for example: ``{'jack', "
"'sjoerd'}``, in addition to the :class:`set` constructor."
msgstr ""
"Python 2.7 では、空でない set (frozenset ではない) は、 :class:`set` コンスト"
"ラクタに加え、要素を波カッコ中にカンマで区切って列挙することでも生成できま"
"す。例: ``{'jack', 'sjoerd'}``."

#: ../../library/stdtypes.rst:1828
msgid "The constructors for both classes work the same:"
msgstr "どちらのクラスのコンストラクタも同様に働きます:"

#: ../../library/stdtypes.rst:1833
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"*iterable* から要素を取り込んだ、新しい :class:`set` もしくは :class:"
"`frozenset` オブジェクトを返します。 集合の要素は :term:`ハッシュ可能 "
"<hashable>` なものでなくてはなりません。集合の集合を表現するためには、内側の"
"集合は :class:`frozenset` オブジェクトでなくてはなりません。*iterable* が指定"
"されない場合、新しい空の集合が返されます。"

#: ../../library/stdtypes.rst:1839
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
":class:`set` および :class:`frozenset` のインスタンスは以下の操作を提供しま"
"す:"

#: ../../library/stdtypes.rst:1844
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "集合 *s* の要素数 (*s* の濃度) を返します。"

#: ../../library/stdtypes.rst:1848
msgid "Test *x* for membership in *s*."
msgstr "*x* が *s* のメンバーに含まれるか判定します。"

#: ../../library/stdtypes.rst:1852
msgid "Test *x* for non-membership in *s*."
msgstr "*x* が *s* のメンバーに含まれていないことを判定します。"

#: ../../library/stdtypes.rst:1856
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"集合が *other* と共通の要素を持たないとき、``True`` を返します。集合はそれら"
"の積集合が空集合となるときのみ、互いに素 (disjoint) となります。"

#: ../../library/stdtypes.rst:1864
msgid "Test whether every element in the set is in *other*."
msgstr "set の全ての要素が *other* に含まれるか判定します。"

#: ../../library/stdtypes.rst:1868
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"set が *other* の真部分集合であるかを判定します。つまり、 ``set <= other and "
"set != other`` と等価です。"

#: ../../library/stdtypes.rst:1874
msgid "Test whether every element in *other* is in the set."
msgstr "*other* の全ての要素が set に含まれるか判定します。"

#: ../../library/stdtypes.rst:1878
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"set が *other* の真上位集合であるかを判定します。つまり、 ``set >= other and "
"set != other`` と等価です。"

#: ../../library/stdtypes.rst:1884
msgid "Return a new set with elements from the set and all others."
msgstr "set と全ての other の要素からなる新しい集合を返します。"

#: ../../library/stdtypes.rst:1886 ../../library/stdtypes.rst:1894
#: ../../library/stdtypes.rst:1902 ../../library/stdtypes.rst:1956
#: ../../library/stdtypes.rst:1964 ../../library/stdtypes.rst:1972
msgid "Accepts multiple input iterables."
msgstr "複数のイテラブルからの入力を受け入れるようになりました。"

#: ../../library/stdtypes.rst:1892
msgid "Return a new set with elements common to the set and all others."
msgstr "set と全ての other に共通する要素を持つ、新しい集合を返します。"

#: ../../library/stdtypes.rst:1900
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""
"set に含まれて、かつ、全ての other に含まれない要素を持つ、新しい集合を返しま"
"す。"

#: ../../library/stdtypes.rst:1908
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"set と *other* のいずれか一方だけに含まれる要素を持つ新しい集合を返します。"

#: ../../library/stdtypes.rst:1912
msgid "Return a shallow copy of the set."
msgstr "集合の浅いコピーを返します。"

#: ../../library/stdtypes.rst:1915
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, and :meth:`symmetric_difference`, :meth:`issubset`, and :"
"meth:`issuperset` methods will accept any iterable as an argument.  In "
"contrast, their operator based counterparts require their arguments to be "
"sets.  This precludes error-prone constructions like ``set('abc') & 'cbs'`` "
"in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"なお、演算子でない版の :meth:`union`, :meth:`intersection`, :meth:"
"`difference`, :meth:`symmetric_difference`, :meth:`issubset`, :meth:"
"`issuperset` メソッドは、任意のイテラブルを引数として受け付けます。対して、演"
"算子を使う版では、引数は集合でなくてはなりません。これは、``set('abc') & "
"'cbs'`` のような誤りがちな構文を予防し、より読みやすい ``set('abc')."
"intersection('cbs')`` を支持します。"

#: ../../library/stdtypes.rst:1922
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
":class:`set` と :class:`frozenset` のどちらも、集合同士の比較をサポートしま"
"す。二つの集合は、それぞれの集合の要素全てが他方にも含まれている (互いに他方"
"の部分集合である) とき、かつそのときに限り等しいです。一方の集合が他方の集合"
"の真部分集合である (部分集合であるが等しくない) とき、かつそのときに限り一方"
"の集合は他方の集合より小さいです。一方の集合が他方の集合の真上位集合である "
"(上位集合であるが等しくない) とき、かつそのときに限り一方の集合は他方の集合よ"
"り大きいです。"

#: ../../library/stdtypes.rst:1929
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
":class:`set` のインスタンスは、 :class:`frozenset` のインスタンスと、要素に基"
"づいて比較されます。例えば、 ``set('abc') == frozenset('abc')`` や "
"``set('abc') in set([frozenset('abc')])`` は ``True`` を返します。"

#: ../../library/stdtypes.rst:1933
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two non-empty disjoint sets are not equal and "
"are not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``. Accordingly, sets do not implement the :meth:"
"`__cmp__` method."
msgstr ""
"部分集合と等価性の比較は全順序付けを行う関数へと一般化することはできません。"
"例えば、互いに素である二つの非空集合は、等しくなく、他方の部分集合でもありま"
"せんから、以下の *すべて* に ``False`` を返します: ``a<b``, ``a==b``, そして "
"``a>b`` 。そのため、 set は :meth:`__cmp__` メソッドを実装しません。"

#: ../../library/stdtypes.rst:1939
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"集合は半順序（部分集合関係）しか定義しないので、集合のリストにおける :meth:"
"`list.sort` メソッドの出力は未定義です。"

#: ../../library/stdtypes.rst:1942
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""
"集合の要素は、辞書のキーのように、ハッシュ可能 (:term:`hashable`) でなければ"
"なりません。"

#: ../../library/stdtypes.rst:1944
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
":class:`set` インスタンスと :class:`frozenset` インスタンスを取り混ぜての二項"
"演算は、第一被演算子の型を返します。例えば: ``frozenset('ab') | set('bc')`` "
"は :class:`frozenset` インスタンスを返します。"

#: ../../library/stdtypes.rst:1948
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"以下の表に挙げる演算は :class:`set` に適用されますが、:class:`frozenset` のイ"
"ミュータブルなインスタンスには適用されません:"

#: ../../library/stdtypes.rst:1954
msgid "Update the set, adding elements from all others."
msgstr "全ての other の要素を追加し、 set を更新します。"

#: ../../library/stdtypes.rst:1962
msgid "Update the set, keeping only elements found in it and all others."
msgstr "元の set と全ての other に共通する要素だけを残して set を更新します。"

#: ../../library/stdtypes.rst:1970
msgid "Update the set, removing elements found in others."
msgstr "*other* に含まれる要素を取り除き、 set を更新します。"

#: ../../library/stdtypes.rst:1978
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr "どちらかにのみ含まれて、共通には持たない要素のみで set を更新します。"

#: ../../library/stdtypes.rst:1982
msgid "Add element *elem* to the set."
msgstr "要素 *elem* を set に追加します。"

#: ../../library/stdtypes.rst:1986
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"要素 *elem* を set から取り除きます。*elem* が set に含まれていなければ :exc:"
"`KeyError` を送出します。"

#: ../../library/stdtypes.rst:1991
msgid "Remove element *elem* from the set if it is present."
msgstr "要素 *elem* が set に含まれていれば、取り除きます。"

#: ../../library/stdtypes.rst:1995
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"任意に要素をから返し、それを set から取り除きます。set が空であれば、 :exc:"
"`KeyError` を送出します。"

#: ../../library/stdtypes.rst:2000
msgid "Remove all elements from the set."
msgstr "set の全ての要素を取り除きます。"

#: ../../library/stdtypes.rst:2003
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"なお、演算子でない版の :meth:`update`, :meth:`intersection_update`, :meth:"
"`difference_update`, および :meth:`symmetric_difference_update` メソッドは、"
"任意のイテラブルを引数として受け付けます。"

#: ../../library/stdtypes.rst:2008
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :"
"meth:`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, a temporary one is created from *elem*."
msgstr ""
":meth:`__contains__`, :meth:`remove`, :meth:`discard` メソッドの引数 *elem* "
"は集合かもしれないことに注意してください。\n"
"その集合と等価な :class:`frozenset` の検索をサポートするために、 *elem* から"
"一時的な frozenset を作成します。"

#: ../../library/stdtypes.rst:2015
msgid ":ref:`comparison-to-builtin-set`"
msgstr ":ref:`comparison-to-builtin-set`"

#: ../../library/stdtypes.rst:2016
msgid "Differences between the :mod:`sets` module and the built-in set types."
msgstr ":mod:`sets` モジュールと組み込み set 型の違い"

#: ../../library/stdtypes.rst:2022
msgid "Mapping Types --- :class:`dict`"
msgstr "マッピング型 --- :class:`dict`"

#: ../../library/stdtypes.rst:2032
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"マッピング (:term:`mapping`) オブジェクトは、ハッシュ可能 (:term:`hashable`) "
"な値を任意のオブジェクトに対応付けます。マッピングはミュータブルなオブジェク"
"トです。現在、標準マッピング型は辞書 (:dfn:`dictionary`) だけです。 (他のコン"
"テナについては組み込みの :class:`list`, :class:`set`, および :class:`tuple` "
"クラスと、 :mod:`collections` モジュールを参照下さい。)"

#: ../../library/stdtypes.rst:2038
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys.  Numeric types used for keys obey the normal rules "
"for numeric comparison: if two numbers compare equal (such as ``1`` and "
"``1.0``) then they can be used interchangeably to index the same dictionary "
"entry.  (Note however, that since computers store floating-point numbers as "
"approximations it is usually unwise to use them as dictionary keys.)"
msgstr ""
"辞書のキーは *ほぼ* 任意の値です。ハッシュ可能 (:term:`hashable`) でない値、"
"つまり、リストや辞書その他のミュータブルな型 (オブジェクトの同一性ではなく値"
"で比較されるもの) はキーとして使用できません。キーとして使われる数値型は通常"
"の数値比較のルールに従います: もしふたつの数値が (例えば ``1`` と ``1.0`` の"
"ように) 等しければ、同じ辞書の項目として互換的に使用できます。 (ただし、コン"
"ピュータは浮動小数点数を近似値として保管するので、辞書型のキーとして使用する"
"のはたいてい賢くありません。)"

#: ../../library/stdtypes.rst:2047
msgid ""
"Dictionaries can be created by placing a comma-separated list of ``key: "
"value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}`` "
"or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` constructor."
msgstr ""
"辞書は ``key: value`` 対のカンマ区切りのリストを波括弧でくくることで作成でき"
"ます。例えば: ``{'jack': 4098, 'sjoerd': 4127}`` あるいは ``{4098: 'jack', "
"4127: 'sjoerd'}`` 。あるいは、 :class:`dict` コンストラクタでも作成できます。"

#: ../../library/stdtypes.rst:2055
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"オプションの位置引数と空集合の可能性もあるキーワード引数から初期化された新し"
"い辞書を返します。"

#: ../../library/stdtypes.rst:2058
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""
"位置引数が何も与えられなかった場合、空の辞書が作成されます。位置引数が与えら"
"れ、それがマッピングオブジェクトだった場合、そのマッピングオブジェクトと同じ"
"キーと値のペアを持つ辞書が作成されます。それ以外の場合、位置引数は :term:"
"`iterable` オブジェクトでなければなりません。iterable のそれぞれの要素自身"
"は、ちょうど 2 個のオブジェクトを持つイテラブルでなければなりません。それぞれ"
"の要素の最初のオブジェクトは新しい辞書のキーになり、2 番目のオブジェクトはそ"
"れに対応する値になります。同一のキーが 2 回以上現れた場合は、そのキーの最後の"
"値が新しい辞書での対応する値になります。"

#: ../../library/stdtypes.rst:2068
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""
"キーワード引数が与えられた場合、キーワード引数とその値が位置引数から作られた"
"辞書に追加されます。既に存在しているキーが追加された場合、キーワード引数の値"
"は位置引数の値を置き換えます。"

#: ../../library/stdtypes.rst:2073
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"例を出すと、次の例は全て ``{\"one\": 1, \"two\": 2, \"three\": 3}`` に等しい"
"辞書を返します::"

#: ../../library/stdtypes.rst:2084
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"最初の例のようにキーワード引数を与える方法では、キーは有効な Python の識別子"
"でなければなりません。それ以外の方法では、辞書のキーとして有効などんなキーで"
"も使えます。"

#: ../../library/stdtypes.rst:2089
msgid "Support for building a dictionary from keyword arguments added."
msgstr "キーワード引数からの辞書型の作成のサポートが追加されました。"

#: ../../library/stdtypes.rst:2093
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"以下は辞書型がサポートする操作です (それゆえ、カスタムのマップ型もこれらの操"
"作をサポートするべきです):"

#: ../../library/stdtypes.rst:2098
msgid "Return the number of items in the dictionary *d*."
msgstr "辞書 *d* の項目数を返します。"

#: ../../library/stdtypes.rst:2102
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""
"*d* のキー *key* の項目を返します。マップに *key* が存在しなければ、 :exc:"
"`KeyError` を送出します。"

#: ../../library/stdtypes.rst:2107
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""
"辞書のサブクラスが :meth:`__missing__` メソッドを定義しておらず、 *key* が存"
"在しないなら、 ``d[key]`` 演算はこのメソッドをキー *key* を引数として呼び出し"
"ます。結果として、 ``d[key]`` 演算は、キーが存在しなければ、 "
"``__missing__(key)`` の呼び出しによって返されまたは送出されたものを何でも、返"
"しまたは送出します。他の演算やメソッドは :meth:`__missing__` を呼び出しませ"
"ん。 :meth:`__missing__` が定義されていなければ、 :exc:`KeyError` が送出され"
"ます。 :meth:`__missing__` はメソッドでなければならず、インスタンス変数であっ"
"てはなりません::"

#: ../../library/stdtypes.rst:2125
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"ここでお見せした例は :class:`collections.Counter` 実装の一部です。これとは"
"違った ``__missing__`` が:class:`collections.defaultdict` で使われています。"

#: ../../library/stdtypes.rst:2129
msgid "Recognition of __missing__ methods of dict subclasses."
msgstr "辞書のサブクラスで __missing__ メソッドを認識するようになりました。"

#: ../../library/stdtypes.rst:2134
msgid "Set ``d[key]`` to *value*."
msgstr "``d[key]`` に *value* を設定します。"

#: ../../library/stdtypes.rst:2138
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""
"*d* から ``d[key]`` を削除します。マップに *key* が存在しなければ、 :exc:"
"`KeyError` を送出します。"

#: ../../library/stdtypes.rst:2143
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr ""
"*d* がキー *key* を持っていれば ``True`` を、そうでなければ、 ``False`` を返"
"します。"

#: ../../library/stdtypes.rst:2149
msgid "Equivalent to ``not key in d``."
msgstr "``not key in d`` と等価です。"

#: ../../library/stdtypes.rst:2155
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for :"
"meth:`iterkeys`."
msgstr ""
"辞書のキーに渡るイテレータを返します。これは  :meth:`iterkeys` へのショート"
"カットです。"

#: ../../library/stdtypes.rst:2160
msgid "Remove all items from the dictionary."
msgstr "辞書の全ての項目を消去します。"

#: ../../library/stdtypes.rst:2164
msgid "Return a shallow copy of the dictionary."
msgstr "辞書の浅いコピーを返します。"

#: ../../library/stdtypes.rst:2168
msgid "Create a new dictionary with keys from *seq* and values set to *value*."
msgstr ""
"*seq* からキーを取り、値を *value* に設定した、新しい辞書を作成します。"

#: ../../library/stdtypes.rst:2170
msgid ""
":func:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``."
msgstr ""
":func:`fromkeys` は新しい辞書を返すクラスメソッドです。 *value* のデフォルト"
"値は ``None`` です。"

#: ../../library/stdtypes.rst:2177
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"*key* が辞書にあれば *key* に対する値を、そうでなければ *default* を返しま"
"す。 *default* が与えられなかった場合、デフォルトでは ``None`` となります。そ"
"のため、このメソッドは :exc:`KeyError` を送出することはありません。"

#: ../../library/stdtypes.rst:2183
msgid ""
"Test for the presence of *key* in the dictionary.  :meth:`has_key` is "
"deprecated in favor of ``key in d``."
msgstr ""
"辞書に *key* が存在するかを確認します。 ``key in d`` が可能になっているの"
"で、 :meth:`has_key` は廃れた用法です。"

#: ../../library/stdtypes.rst:2188
msgid "Return a copy of the dictionary's list of ``(key, value)`` pairs."
msgstr "辞書のコピーを ``(key, value)`` の対のリストとして返します。"

#: ../../library/stdtypes.rst:2192
msgid ""
"Keys and values are listed in an arbitrary order which is non-random, varies "
"across Python implementations, and depends on the dictionary's history of "
"insertions and deletions."
msgstr ""
"キーと値のリストは任意の順序で返されますが、ランダムではなく、 Python の実装"
"と、辞書への挿入、および、削除操作の来歴によって決まります。"

#: ../../library/stdtypes.rst:2196
msgid ""
"If :meth:`items`, :meth:`keys`, :meth:`values`, :meth:`iteritems`, :meth:"
"`iterkeys`, and :meth:`itervalues` are called with no intervening "
"modifications to the dictionary, the lists will directly correspond.  This "
"allows the creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = "
"zip(d.values(), d.keys())``.  The same relationship holds for the :meth:"
"`iterkeys` and :meth:`itervalues` methods: ``pairs = zip(d.itervalues(), d."
"iterkeys())`` provides the same value for ``pairs``. Another way to create "
"the same list is ``pairs = [(v, k) for (k, v) in d.iteritems()]``."
msgstr ""
":meth:`items`, :meth:`keys`, :meth:`values`, :meth:`iteritems`, :meth:"
"`iterkeys` および :meth:`itervalues` は辞書に干渉して更新しなければ、返却順は"
"直接対応関係にあります。つまり ``(value, key)`` の対を :func:`zip` を使って生"
"成するとができます: ``pairs = zip(d.values(), d.keys())`` 。 :meth:"
"`iterkeys` と :meth:`itervalues` でも同じです: ``pairs = zip(d.itervalues(), "
"d.iterkeys())`` は先と同じ値を返します。同じリストを得るには ``pairs = [(v, "
"k) for (k, v) in d.iteritems()]`` としても出来ます。"

#: ../../library/stdtypes.rst:2208
msgid ""
"Return an iterator over the dictionary's ``(key, value)`` pairs.  See the "
"note for :meth:`dict.items`."
msgstr ""
"辞書の ``(key, value)`` の対をイテレータで返します。 :meth:`dict.items` の記"
"述も参照下さい。"

#: ../../library/stdtypes.rst:2211
msgid ""
"Using :meth:`iteritems` while adding or deleting entries in the dictionary "
"may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
":meth:`iteritems` を辞書の項目の追加や削除と同時に行うと、 :exc:"
"`RuntimeError` を送出されるか全ての項目に対する反復に失敗することになります。"

#: ../../library/stdtypes.rst:2218
msgid ""
"Return an iterator over the dictionary's keys.  See the note for :meth:`dict."
"items`."
msgstr ""
"辞書のキーをイテレータで返します。 :meth:`dict.items` の記述も参照下さい。"

#: ../../library/stdtypes.rst:2221
msgid ""
"Using :meth:`iterkeys` while adding or deleting entries in the dictionary "
"may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
":meth:`iterkeys` を辞書の項目の追加や削除と同時に行うと、 :exc:"
"`RuntimeError` を送出されるか全ての項目に対する反復に失敗することになります。"

#: ../../library/stdtypes.rst:2228
msgid ""
"Return an iterator over the dictionary's values.  See the note for :meth:"
"`dict.items`."
msgstr ""
"辞書の値をイテレータで返します。 :meth:`dict.items` の記述も参照下さい。"

#: ../../library/stdtypes.rst:2231
msgid ""
"Using :meth:`itervalues` while adding or deleting entries in the dictionary "
"may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
":meth:`itervalues` を辞書の項目の追加や削除と同時に行うと、 :exc:"
"`RuntimeError` を送出されるか全ての項目に対する反復に失敗することになります。"

#: ../../library/stdtypes.rst:2239
msgid ""
"Return a copy of the dictionary's list of keys.  See the note for :meth:"
"`dict.items`."
msgstr ""
"辞書のキーのリストのコピーを返します。 :meth:`dict.items` の記述も参照下さ"
"い。"

#: ../../library/stdtypes.rst:2244
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"*key* が辞書に存在すればその値を辞書から消去して返し、そうでなければ "
"*default* を返します。 *default* が与えらず、かつ *key* が辞書に存在しなけれ"
"ば :exc:`KeyError` を送出します。"

#: ../../library/stdtypes.rst:2252
msgid ""
"Remove and return an arbitrary ``(key, value)`` pair from the dictionary."
msgstr "任意の ``(key, value)`` 対を辞書から消去して返します。"

#: ../../library/stdtypes.rst:2254
msgid ""
":func:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :func:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
"集合のアルゴリズムで使われるのと同じように、 :func:`popitem` は辞書を破壊的に"
"イテレートするのに便利です。辞書が空であれば、 :func:`popitem` の呼び出しは :"
"exc:`KeyError` を送出します。"

#: ../../library/stdtypes.rst:2260
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"もし、 *key* が辞書に存在すれば、その値を返します。そうでなければ、値を "
"*default* として *key* を挿入し、 *default* を返します。 *default* のデフォル"
"トは ``None`` です。"

#: ../../library/stdtypes.rst:2266
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"辞書の内容を *other* のキーと値で更新します。既存のキーは上書きされます。返り"
"値は ``None`` です。"

#: ../../library/stdtypes.rst:2269
msgid ""
":func:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":func:`update` は、他の辞書オブジェクトでもキー/値の対のイテラブル (タプル、"
"もしくは、長さが2のイテラブル) でも、どちらでも受け付けます。キーワード引数が"
"指定されれば、そのキー/値の対で辞書を更新します: ``d.update(red=1, "
"blue=2)``。"

#: ../../library/stdtypes.rst:2274
msgid ""
"Allowed the argument to be an iterable of key/value pairs and allowed "
"keyword arguments."
msgstr ""
"キーと値の対のイテラブル、および、キーワード引数を引数として与えることができ"
"るようになりました。"

#: ../../library/stdtypes.rst:2280
msgid ""
"Return a copy of the dictionary's list of values.  See the note for :meth:"
"`dict.items`."
msgstr ""
"辞書の値のリストのコピーを返します。 :meth:`dict.items` の記述も参照下さい。"

#: ../../library/stdtypes.rst:2285
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs).  See "
"below for documentation of view objects."
msgstr ""
"辞書のアイテム (``(key, value)`` のペア) の新しいビューを返します。ビューオブ"
"ジェクトについては下に説明があります。"

#: ../../library/stdtypes.rst:2292
msgid ""
"Return a new view of the dictionary's keys.  See below for documentation of "
"view objects."
msgstr ""
"辞書のキーの新しいビューを返します。ビューオブジェクトについては下に説明があ"
"ります。"

#: ../../library/stdtypes.rst:2299
msgid ""
"Return a new view of the dictionary's values.  See below for documentation "
"of view objects."
msgstr ""
"辞書の値の新しいビューを返します。ビューオブジェクトについては下に説明があり"
"ます。"

#: ../../library/stdtypes.rst:2304
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs."
msgstr "辞書は、同じ ``(key, value)`` の対を持つときのみ等しくなります。"

#: ../../library/stdtypes.rst:2311
msgid "Dictionary view objects"
msgstr "辞書ビューオブジェクト"

#: ../../library/stdtypes.rst:2313
msgid ""
"The objects returned by :meth:`dict.viewkeys`, :meth:`dict.viewvalues` and :"
"meth:`dict.viewitems` are *view objects*.  They provide a dynamic view on "
"the dictionary's entries, which means that when the dictionary changes, the "
"view reflects these changes."
msgstr ""
":meth:`dict.viewkeys`, :meth:`dict.viewvalues`, :meth:`dict.viewitems` によっ"
"て返されるオブジェクトは、 *ビューオブジェクト* です。これらは、辞書の項目の"
"動的なビューを提供し、辞書が変更された時、ビューはその変更を反映します。"

#: ../../library/stdtypes.rst:2318
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"辞書ビューは、イテレートすることで対応するデータを yield できます。また、帰属"
"判定をサポートします:"

#: ../../library/stdtypes.rst:2323
msgid "Return the number of entries in the dictionary."
msgstr "辞書の項目数を返します。"

#: ../../library/stdtypes.rst:2327
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"辞書のキー、値、または (``(key, value)`` のタプルとして表される) 項目に渡るイ"
"テレータを返します。"

#: ../../library/stdtypes.rst:2330
msgid ""
"Keys and values are iterated over in an arbitrary order which is non-random, "
"varies across Python implementations, and depends on the dictionary's "
"history of insertions and deletions. If keys, values and items views are "
"iterated over with no intervening modifications to the dictionary, the order "
"of items will directly correspond.  This allows the creation of ``(value, "
"key)`` pairs using :func:`zip`: ``pairs = zip(d.values(), d.keys())``.  "
"Another way to create the same list is ``pairs = [(v, k) for (k, v) in d."
"items()]``."
msgstr ""
"キーと値のリストはある任意の順序でイテレートされますが、ランダムではなく、 "
"Python の実装によって変わり、辞書への挿入や削除の履歴に依存します。キー、値、"
"要素のビューを通して、辞書の変更を挟まずにイテレートされたら、その要素の順序"
"は完全に一致します。これにより、 ``(value, key)`` の対を :func:`zip` で作成で"
"きます: ``pairs = zip(d.values(), d.keys())`` 。同じリストを作成する他の方法"
"は、 ``pairs = [(v, k) for (k, v) in d.items()]`` です。"

#: ../../library/stdtypes.rst:2338
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"辞書の項目の追加や削除中にビューをイテレートすると、 :exc:`RuntimeError` を送"
"出したり、すべての項目に渡ってイテレートできなかったりします。"

#: ../../library/stdtypes.rst:2343
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"*x* が下にある辞書のキー、値、または項目 (項目の場合、 *x* は ``(key, "
"value)`` タプルであるべきです) にあるとき ``True`` を返します。"

#: ../../library/stdtypes.rst:2347
msgid ""
"Keys views are set-like since their entries are unique and hashable.  If all "
"values are hashable, so that (key, value) pairs are unique and hashable, "
"then the items view is also set-like.  (Values views are not treated as set-"
"like since the entries are generally not unique.)  Then these set operations "
"are available (\"other\" refers either to another view or a set):"
msgstr ""
"キーのビューは、項目が一意的でハッシュ可能であるという点で、集合に似ていま"
"す。すべての値がハッシュ可能なら、 ``(key, value)`` 対も一意的でハッシュ可能"
"なので、要素のビューも集合に似ています。(値のビューは、要素が一般に一意的でな"
"いことから、集合に似ているとは考えられません。) これによりこれらへの集合演算"
"が利用出来ます (\"other\" はもう一つのビューか集合です):"

#: ../../library/stdtypes.rst:2355
msgid ""
"Return the intersection of the dictview and the other object as a new set."
msgstr "辞書ビューと別のオブジェクトの共通部分を新しい集合として返します。"

#: ../../library/stdtypes.rst:2359
msgid "Return the union of the dictview and the other object as a new set."
msgstr "辞書ビューと別のオブジェクトの合併集合を新しい集合として返します。"

#: ../../library/stdtypes.rst:2363
msgid ""
"Return the difference between the dictview and the other object (all "
"elements in *dictview* that aren't in *other*) as a new set."
msgstr ""
"辞書ビューと別のオブジェクトの差集合 (*dictview* に属して *other* に属さない"
"すべての要素) を新しい集合として返します。"

#: ../../library/stdtypes.rst:2368
msgid ""
"Return the symmetric difference (all elements either in *dictview* or "
"*other*, but not in both) of the dictview and the other object as a new set."
msgstr ""
"辞書ビューと別のオブジェクトの対称差 (*dictview* と *other* のどちらかに属す"
"が両方には属さないすべての要素) を新しい集合として返します。"

#: ../../library/stdtypes.rst:2372
msgid "An example of dictionary view usage::"
msgstr "辞書ビューの使用法の例::"

#: ../../library/stdtypes.rst:2405
msgid "File Objects"
msgstr "ファイルオブジェクト"

#: ../../library/stdtypes.rst:2413
msgid ""
"File objects are implemented using C's ``stdio`` package and can be created "
"with the built-in :func:`open` function.  File objects are also returned by "
"some other built-in functions and methods, such as :func:`os.popen` and :"
"func:`os.fdopen` and the :meth:`makefile` method of socket objects. "
"Temporary files can be created using the :mod:`tempfile` module, and high-"
"level file operations such as copying, moving, and deleting files and "
"directories can be achieved with the :mod:`shutil` module."
msgstr ""
"ファイルオブジェクトは C の ``stdio`` パッケージを使って実装されており、組み"
"込み関数の :func:`open` で生成することができます。ファイルオブジェクトはま"
"た、 :func:`os.popen` や :func:`os.fdopen`, ソケットオブジェクトの :meth:"
"`makefile` メソッドのような、他の組み込み関数およびメソッドによっても返されま"
"す。一時ファイルは :mod:`tempfile` モジュールを使って生成でき、ファイルやディ"
"レクトリのコピー、移動、消去などの高次の操作は :mod:`shutil` モジュールで行え"
"ます。"

#: ../../library/stdtypes.rst:2422
msgid ""
"When a file operation fails for an I/O-related reason, the exception :exc:"
"`IOError` is raised.  This includes situations where the operation is not "
"defined for some reason, like :meth:`seek` on a tty device or writing a file "
"opened for reading."
msgstr ""
"ファイル操作が I/O 関連の理由で失敗した場合例外 :exc:`IOError` が送出されま"
"す。この理由には例えば :meth:`seek` を端末デバイスに行ったり、読み出し専用で"
"開いたファイルに書き込みを行うといった、何らかの理由によってそのファイルで定"
"義されていない操作を行ったような場合も含まれます。"

#: ../../library/stdtypes.rst:2427
msgid "Files have the following methods:"
msgstr "ファイルは以下のメソッドを持ちます:"

#: ../../library/stdtypes.rst:2432
msgid ""
"Close the file.  A closed file cannot be read or written any more. Any "
"operation which requires that the file be open will raise a :exc:"
"`ValueError` after the file has been closed.  Calling :meth:`close` more "
"than once is allowed."
msgstr ""
"ファイルを閉じます。閉じられたファイルはそれ以後読み書きすることはできませ"
"ん。ファイルが開かれていることが必要な操作は、ファイルが閉じられた後はすべ"
"て :exc:`ValueError` を送出します。 :meth:`close` を一度以上呼び出してもかま"
"いません。"

#: ../../library/stdtypes.rst:2436
msgid ""
"As of Python 2.5, you can avoid having to call this method explicitly if you "
"use the :keyword:`with` statement.  For example, the following code will "
"automatically close *f* when the :keyword:`with` block is exited::"
msgstr ""
"Python 2.5 から :keyword:`with` 文を使えばこのメソッドを直接呼び出す必要はな"
"くなりました。たとえば、以下のコードは *f* を :keyword:`with` ブロックを抜け"
"る際に自動的に閉じます。 ::"

#: ../../library/stdtypes.rst:2446
msgid ""
"In older versions of Python, you would have needed to do this to get the "
"same effect::"
msgstr ""
"古いバージョンの Python では同じ効果を得るために次のようにしなければいけませ"
"んでした。 ::"

#: ../../library/stdtypes.rst:2458
msgid ""
"Not all \"file-like\" types in Python support use as a context manager for "
"the :keyword:`with` statement.  If your code is intended to work with any "
"file-like object, you can use the function :func:`contextlib.closing` "
"instead of using the object directly."
msgstr ""
"全ての Python の \\\"ファイル的\\\" 型が :keyword:`with` 文用のコンテキストマ"
"ネージャとして使えるわけではありません。もし、全てのファイル的オブジェクトで"
"動くようにコードを書きたいのならば、オブジェクトを直接使うのではなく :mod:"
"`contextlib` にある :func:`contextlib.closing` 関数を使うと良いでしょう。"

#: ../../library/stdtypes.rst:2466
msgid ""
"Flush the internal buffer, like ``stdio``'s :c:func:`fflush`.  This may be a "
"no-op on some file-like objects."
msgstr ""
"``stdio`` の :c:func:`fflush` のように、内部バッファをフラッシュします。ファ"
"イル類似のオブジェクトによっては、この操作は何も行いません。"

#: ../../library/stdtypes.rst:2471
msgid ""
":meth:`flush` does not necessarily write the file's data to disk.  Use :meth:"
"`flush` followed by :func:`os.fsync` to ensure this behavior."
msgstr ""
":meth:`flush` は必ずしもファイルのデータをディスクに書き込むとは限りません。"
"そのような挙動を保証するには :meth:`flush` の後に :func:`os.fsync` を使って下"
"さい。"

#: ../../library/stdtypes.rst:2481
msgid ""
"Return the integer \"file descriptor\" that is used by the underlying "
"implementation to request I/O operations from the operating system.  This "
"can be useful for other, lower level interfaces that use file descriptors, "
"such as the :mod:`fcntl` module or :func:`os.read` and friends."
msgstr ""
"背後にある実装系がオペレーティングシステムに I/O 操作を要求するために用いる、"
"整数の \\\"ファイル記述子\\\" (ファイルデスクリプタ) を返します。この値は他の"
"用途として、 :mod:`fcntl` モジュールや :func:`os.read` やその仲間のような、"
"ファイル記述子を必要とする低レベルのインタフェースで役に立ちます。"

#: ../../library/stdtypes.rst:2488
msgid ""
"File-like objects which do not have a real file descriptor should *not* "
"provide this method!"
msgstr ""
"本物のファイルデスクリプタを持たないファイル類似のオブジェクトは、このメソッ"
"ドを提供すべきでは *ありません* 。"

#: ../../library/stdtypes.rst:2494
msgid ""
"Return ``True`` if the file is connected to a tty(-like) device, else "
"``False``."
msgstr ""
"ファイルが tty (または類似の) デバイスに接続されている場合 ``True`` を返し、"
"そうでない場合 ``False`` を返します。"

#: ../../library/stdtypes.rst:2498
msgid ""
"If a file-like object is not associated with a real file, this method should "
"*not* be implemented."
msgstr ""
"ファイル類似のオブジェクトが実際のファイルに関連付けられていない場合、このメ"
"ソッドを実装すべきでは *ありません* 。"

#: ../../library/stdtypes.rst:2504
msgid ""
"A file object is its own iterator, for example ``iter(f)`` returns *f* "
"(unless *f* is closed).  When a file is used as an iterator, typically in a :"
"keyword:`for` loop (for example, ``for line in f: print line.strip()``), "
"the :meth:`~file.next` method is called repeatedly.  This method returns the "
"next input line, or raises :exc:`StopIteration` when EOF is hit when the "
"file is open for reading (behavior is undefined when the file is open for "
"writing).  In order to make a :keyword:`for` loop the most efficient way of "
"looping over the lines of a file (a very common operation), the :meth:`~file."
"next` method uses a hidden read-ahead buffer.  As a consequence of using a "
"read-ahead buffer, combining :meth:`~file.next` with other file methods "
"(like :meth:`~file.readline`) does not work right.  However, using :meth:"
"`seek` to reposition the file to an absolute position will flush the read-"
"ahead buffer."
msgstr ""
"ファイルオブジェクトはそれ自身がイテレータです。すなわち、 ``iter(f)`` は "
"(*f* が閉じられていない限り) *f* を返します。 :keyword:`for` ループ (例えば "
"``for line in f: print line.strip()``) のようにファイルがイテレータとして使わ"
"れた場合、 :meth:`~file.next` メソッドが繰り返し呼び出されます。ファイルが読"
"み込みのために開かれている場合、このメソッドは次の入力行を返すか、または、 "
"EOF に到達したときに :exc:`StopIteration` を送出します (ファイルが書き込み"
"モードで開かれている場合、動作は未定義です) 。ファイル内の各行に対する :"
"keyword:`for` ループ (非常によくある操作です) を効率的な方法で行うために、 :"
"meth:`~file.next` メソッドは隠蔽された先読みバッファを使います。先読みバッ"
"ファを使った結果として、 (:meth:`~file.readline` のような) 他のファイルメソッ"
"ドと :meth:`~file.next` を組み合わせて使うとうまく動作しません。しかし、 :"
"meth:`seek` を使ってファイル位置を絶対指定しなおすと、先読みバッファは消去さ"
"れます。"

#: ../../library/stdtypes.rst:2522
msgid ""
"Read at most *size* bytes from the file (less if the read hits EOF before "
"obtaining *size* bytes).  If the *size* argument is negative or omitted, "
"read all data until EOF is reached.  The bytes are returned as a string "
"object.  An empty string is returned when EOF is encountered immediately.  "
"(For certain files, like ttys, it makes sense to continue reading after an "
"EOF is hit.)  Note that this method may call the underlying C function :c:"
"func:`fread` more than once in an effort to acquire as close to *size* bytes "
"as possible. Also note that when in non-blocking mode, less data than was "
"requested may be returned, even if no *size* parameter was given."
msgstr ""
"最大で *size* バイトをファイルから読み込みます (*size* バイトを取得する前に "
"EOF に到達した場合、それ以下の長さになります) 。 *size* 引数が負であるか省略"
"された場合、 EOF に到達するまでの全てのデータを読み込みます。読み出されたバイ"
"ト列は文字列オブジェクトとして返されます。直後に EOF に到達した場合、空の文字"
"列が返されます。 (端末のようなある種のファイルでは、 EOF に到達した後でファイ"
"ルを読みつづけることにも意味があります) 。このメソッドは、 *size* バイトに可"
"能な限り近くデータを取得するために、背後の C 関数 :c:func:`fread` を 1 度以上"
"呼び出すかもしれないので注意してください。また、非ブロック・モードでは、 "
"*size* パラメータが与えられなくても、要求されたよりも少ないデータが返される場"
"合があることに注意してください。"

#: ../../library/stdtypes.rst:2533
msgid ""
"This function is simply a wrapper for the underlying :c:func:`fread` C "
"function, and will behave the same in corner cases, such as whether the EOF "
"value is cached."
msgstr ""
"この関数は単純に、背後の C 関数 :c:func:`fread` のラッパーです。そのため、 "
"EOF が予期せず検出されたりされなかったりといった個別の事情があっても同じよう"
"に振舞うだけです。"

#: ../../library/stdtypes.rst:2540
msgid ""
"Read one entire line from the file.  A trailing newline character is kept in "
"the string (but may be absent when a file ends with an incomplete line). "
"[6]_ If the *size* argument is present and non-negative, it is a maximum "
"byte count (including the trailing newline) and an incomplete line may be "
"returned. When *size* is not 0, an empty string is returned *only* when EOF "
"is encountered immediately."
msgstr ""
"ファイルから一行全部を読み込みます。行末の改行文字は文字列に残ります (だだ"
"し、ファイルが不完全な行で終わっていたら、存在しないかもしれません)。 [6]_ "
"*size* 引数が与えられ、負でなければ、それが (行末の改行文字を含む) 最大バイト"
"数となり、不完全な行でも返されます。 *size* が 0 でなければ、空の文字列が返さ"
"れるのは、即座に EOF に到達したとき *だけ* です。"

#: ../../library/stdtypes.rst:2549
msgid ""
"Unlike ``stdio``'s :c:func:`fgets`, the returned string contains null "
"characters (``'\\0'``) if they occurred in the input."
msgstr ""
"C ``stdio`` の :c:func:`fgets` と違い、入力中にヌル文字 (``'\\0'``) が含まれ"
"ていれば、ヌル文字を含んだ文字列が返されます。"

#: ../../library/stdtypes.rst:2555
msgid ""
"Read until EOF using :meth:`~file.readline` and return a list containing the "
"lines thus read.  If the optional *sizehint* argument is present, instead of "
"reading up to EOF, whole lines totalling approximately *sizehint* bytes "
"(possibly after rounding up to an internal buffer size) are read.  Objects "
"implementing a file-like interface may choose to ignore *sizehint* if it "
"cannot be implemented, or cannot be implemented efficiently."
msgstr ""
":meth:`~file.readline` を使ってに到達するまで読み出し、 EOF 読み出された行を"
"含むリストを返します。オプションの *sizehint* 引数が存在すれば、 EOF まで読み"
"出す代わりに完全な行を全体で大体 *sizehint* バイトになるように (おそらく内部"
"バッファサイズを切り詰めて) 読み出します。ファイル類似のインタフェースを実装"
"しているオブジェクトは、 *sizehint* を実装できないか効率的に実装できない場合"
"には無視してもかまいません。"

#: ../../library/stdtypes.rst:2565
msgid "This method returns the same thing as ``iter(f)``."
msgstr "このメソッドは ``iter(f)`` と同じ結果を返します。"

#: ../../library/stdtypes.rst:2569
msgid "Use ``for line in file`` instead."
msgstr "代わりに ``for line in file`` を使ってください。"

#: ../../library/stdtypes.rst:2575
msgid ""
"Set the file's current position, like ``stdio``'s :c:func:`fseek`. The "
"*whence* argument is optional and defaults to  ``os.SEEK_SET`` or ``0`` "
"(absolute file positioning); other values are ``os.SEEK_CUR`` or ``1`` (seek "
"relative to the current position) and ``os.SEEK_END`` or ``2``  (seek "
"relative to the file's end).  There is no return value."
msgstr ""
"C ``stdio`` の :c:func:`fseek` が行うように、ファイルの現在位置を設定しま"
"す。 *whence* 引数はオプションで、標準の値は ``os.SEEK_SET`` もしくは ``0`` "
"(絶対位置指定) です; 他に取り得る値は ``os.SEEK_CUR`` もしくは ``1`` (現在の"
"ファイル位置から相対的に seek する) および ``os.SEEK_END`` もしくは ``2`` "
"(ファイルの末端から相対的に seek する) です。戻り値はありません。"

#: ../../library/stdtypes.rst:2581
msgid ""
"For example, ``f.seek(2, os.SEEK_CUR)`` advances the position by two and ``f."
"seek(-3, os.SEEK_END)`` sets the position to the third to last."
msgstr ""
"例えば、 ``f.seek(2, os.SEEK_CUR)`` 位置を2つ進めます。 ``f.seek(-3, os."
"SEEK_END)`` では終端の3つ手前に設定します。"

#: ../../library/stdtypes.rst:2584
msgid ""
"Note that if the file is opened for appending (mode ``'a'`` or ``'a+'``), "
"any :meth:`seek` operations will be undone at the next write.  If the file "
"is only opened for writing in append mode (mode ``'a'``), this method is "
"essentially a no-op, but it remains useful for files opened in append mode "
"with reading enabled (mode ``'a+'``).  If the file is opened in text mode "
"(without ``'b'``), only offsets returned by :meth:`tell` are legal.  Use of "
"other offsets causes undefined behavior."
msgstr ""
"ファイルを追記モード (モード ``'a'`` または ``'a+'``) で開いた場合、書き込み"
"を行うまでに行った :meth:`seek` 操作はすべて元に戻されるので注意してくださ"
"い。ファイルが追記のみの書き込みモード (``'a'``) で開かれた場合、このメソッド"
"は実質何も行いませんが、読み込みが可能な追記モード (``'a+'``) で開かれたファ"
"イルでは役に立ちます。ファイルをテキストモードで (``'b'`` なしで) 開いた場"
"合、 :meth:`tell` が返すオフセットのみが正しい値になります。他のオフセット値"
"を使った場合、その振る舞いは未定義です。"

#: ../../library/stdtypes.rst:2592
msgid "Note that not all file objects are seekable."
msgstr ""
"全てのファイルオブジェクトが seek できるとは限らないので注意してください。"

#: ../../library/stdtypes.rst:2594
msgid "Passing float values as offset has been deprecated."
msgstr "オフセットに浮動小数点数を渡すことは非推奨となりました。"

#: ../../library/stdtypes.rst:2600
msgid "Return the file's current position, like ``stdio``'s :c:func:`ftell`."
msgstr ""
"C の ``stdio`` の :c:func:`ftell` のように、ファイルの現在位置を返します。"

#: ../../library/stdtypes.rst:2604
msgid ""
"On Windows, :meth:`tell` can return illegal values (after an :c:func:"
"`fgets`) when reading files with Unix-style line-endings. Use binary mode "
"(``'rb'``) to circumvent this problem."
msgstr ""
"Windows では、(:c:func:`fgets` の後で) Unix スタイルの改行のファイルを読むと"
"きに :meth:`tell` が不正な値を返すことがあります。この問題に遭遇しないために"
"はバイナリーモード (``'rb'``) を使うようにしてください。"

#: ../../library/stdtypes.rst:2611
msgid ""
"Truncate the file's size.  If the optional *size* argument is present, the "
"file is truncated to (at most) that size.  The size defaults to the current "
"position. The current file position is not changed.  Note that if a "
"specified size exceeds the file's current size, the result is platform-"
"dependent:  possibilities include that the file may remain unchanged, "
"increase to the specified size as if zero-filled, or increase to the "
"specified size with undefined new content. Availability:  Windows, many Unix "
"variants."
msgstr ""
"ファイルのサイズを切り詰めます。オプションの *size* が存在すれば、ファイルは "
"(最大で) 指定されたサイズに切り詰められます。標準設定のサイズの値は、現在の"
"ファイル位置までのファイルサイズです。現在のファイル位置は変更されません。指"
"定されたサイズがファイルの現在のサイズを越える場合、その結果はプラットフォー"
"ム依存なので注意してください: 可能性としては、ファイルは変更されないか、指定"
"されたサイズまでゼロで埋められるか、指定されたサイズまで未定義の新たな内容で"
"埋められるか、があります。利用可能な環境: Windows, 多くの Unix 系。"

#: ../../library/stdtypes.rst:2622
msgid ""
"Write a string to the file.  There is no return value.  Due to buffering, "
"the string may not actually show up in the file until the :meth:`flush` or :"
"meth:`close` method is called."
msgstr ""
"文字列をファイルに書き込みます。戻り値はありません。バッファリングによっ"
"て、 :meth:`flush` または :meth:`close` が呼び出されるまで実際にファイル中に"
"文字列が書き込まれないこともあります。"

#: ../../library/stdtypes.rst:2629
msgid ""
"Write a sequence of strings to the file.  The sequence can be any iterable "
"object producing strings, typically a list of strings. There is no return "
"value. (The name is intended to match :meth:`readlines`; :meth:`writelines` "
"does not add line separators.)"
msgstr ""
"文字列からなるシーケンスをファイルに書き込みます。シーケンスは文字列を生成す"
"る反復可能なオブジェクトなら何でもかまいません。よくあるのは文字列からなるリ"
"ストです。戻り値はありません。 (関数の名前は :meth:`readlines` と対応づけてつ"
"けられました; :meth:`writelines` は行間の区切りを追加しません。)"

#: ../../library/stdtypes.rst:2634
msgid ""
"Files support the iterator protocol.  Each iteration returns the same result "
"as :meth:`~file.readline`, and iteration ends when the :meth:`~file."
"readline` method returns an empty string."
msgstr ""
"ファイルはイテレータプロトコルをサポートします。各反復操作では :meth:`~file."
"readline` と同じ結果を返し、反復は :meth:`~file.readline` メソッドが空文字列"
"を返した際に終了します。"

#: ../../library/stdtypes.rst:2638
msgid ""
"File objects also offer a number of other interesting attributes. These are "
"not required for file-like objects, but should be implemented if they make "
"sense for the particular object."
msgstr ""
"ファイルオブジェクトはまた、多くの興味深い属性を提供します。これらはファイル"
"類似オブジェクトでは必要ではありませんが、特定のオブジェクトにとって意味を持"
"たせたいなら実装しなければなりません。"

#: ../../library/stdtypes.rst:2645
msgid ""
"bool indicating the current state of the file object.  This is a read-only "
"attribute; the :meth:`close` method changes the value. It may not be "
"available on all file-like objects."
msgstr ""
"現在のファイルオブジェクトの状態を示すブール値です。この値は読み出し専用の属"
"性です; :meth:`close` メソッドがこの値を変更します。全てのファイル類似オブ"
"ジェクトで利用可能とは限りません。"

#: ../../library/stdtypes.rst:2652
msgid ""
"The encoding that this file uses. When Unicode strings are written to a "
"file, they will be converted to byte strings using this encoding. In "
"addition, when the file is connected to a terminal, the attribute gives the "
"encoding that the terminal is likely to use (that  information might be "
"incorrect if the user has misconfigured the  terminal). The attribute is "
"read-only and may not be present on all file-like objects. It may also be "
"``None``, in which case the file uses the system default encoding for "
"converting Unicode strings."
msgstr ""
"このファイルが使っているエンコーディングです。 Unicode 文字列がファイルに書き"
"込まれる際、 Unicode 文字列はこのエンコーディングを使ってバイト文字列に変換さ"
"れます。さらに、ファイルが端末に接続されている場合、この属性は端末が使ってい"
"るとおぼしきエンコーディング (この情報は端末がうまく設定されていない場合には"
"不正確なこともあります) を与えます。この属性は読み出し専用で、すべてのファイ"
"ル類似オブジェクトにあるとは限りません。またこの値は ``None`` のこともあり、"
"この場合、ファイルは Unicode 文字列の変換のためにシステムのデフォルトエンコー"
"ディングを使います。"

#: ../../library/stdtypes.rst:2665
msgid "The Unicode error handler used along with the encoding."
msgstr "エンコーディングに用いられる、 Unicode エラーハンドラです。"

#: ../../library/stdtypes.rst:2672
msgid ""
"The I/O mode for the file.  If the file was created using the :func:`open` "
"built-in function, this will be the value of the *mode* parameter.  This is "
"a read-only attribute and may not be present on all file-like objects."
msgstr ""
"ファイルの I/O モードです。ファイルが組み込み関数 :func:`open` で作成された場"
"合、この値は引数 *mode* の値になります。この値は読み出し専用の属性で、全ての"
"ファイル類似オブジェクトに存在するとは限りません。"

#: ../../library/stdtypes.rst:2679
msgid ""
"If the file object was created using :func:`open`, the name of the file. "
"Otherwise, some string that indicates the source of the file object, of the "
"form ``<...>``.  This is a read-only attribute and may not be present on all "
"file-like objects."
msgstr ""
"ファイルオブジェクトが :func:`open` を使って生成された場合は、そのファイル名"
"です。そうでなければ、ファイルオブジェクト生成の起源を示す何らかの文字列にな"
"り、 ``<...>`` の形式をとります。この値は読み出し専用の属性で、全てのファイル"
"類似オブジェクトに存在するとは限りません。"

#: ../../library/stdtypes.rst:2690
msgid ""
"If Python was built with :term:`universal newlines` enabled (the default) "
"this read-only attribute exists, and for files opened in universal newline "
"read mode it keeps track of the types of newlines encountered while reading "
"the file. The values it can take are ``'\\r'``, ``'\\n'``, ``'\\r\\n'``, "
"``None`` (unknown, no newlines read yet) or a tuple containing all the "
"newline types seen, to indicate that multiple newline conventions were "
"encountered. For files not opened in universal newlines read mode the value "
"of this attribute will be ``None``."
msgstr ""
"Python が :term:`universal newlines` を (デフォルトどおり) 有効にしてビルドさ"
"れているなら、この読み込み専用属性が存在し、ファイルが universal newlines で"
"開かれたファイルで、ファイルの読み込み中にあった改行の種類を記録します。取り"
"得る値は ``'\\r'``, ``'\\n'``, ``'\\r\\n'``, ``None`` (不明であるか、まだ改行"
"を読み込んでいない)、または、複数の改行方式の種類が存在したことを表す、見つ"
"かったすべての改行の種類を含むタプルです。 universal newlines で開かれたので"
"ないファイルに対しては、この属性の値は ``None`` になります。"

#: ../../library/stdtypes.rst:2702
msgid ""
"Boolean that indicates whether a space character needs to be printed before "
"another value when using the :keyword:`print` statement. Classes that are "
"trying to simulate a file object should also have a writable :attr:"
"`softspace` attribute, which should be initialized to zero.  This will be "
"automatic for most classes implemented in Python (care may be needed for "
"objects that override attribute access); types implemented in C will have to "
"provide a writable :attr:`softspace` attribute."
msgstr ""
":keyword:`print` 文を使った場合、他の値を出力する前にスペース文字を出力する必"
"要があるかどうかを示すブール値です。ファイルオブジェクトをシミュレート仕様と"
"するクラスは書き込み可能な :attr:`softspace` 属性を持たなければならず、この値"
"はゼロに初期化されなければなりません。この値は Python で実装されているほとん"
"どのクラスで自動的に初期化されます (属性へのアクセス手段を上書きするようなオ"
"ブジェクトでは注意が必要です); C で実装された型では、書き込み可能な :attr:"
"`softspace` 属性を提供しなければなりません。"

#: ../../library/stdtypes.rst:2712
msgid ""
"This attribute is not used to control the :keyword:`print` statement, but to "
"allow the implementation of :keyword:`print` to keep track of its internal "
"state."
msgstr ""
"この属性は :keyword:`print` 文を制御するために用いられるのではなく、 :"
"keyword:`print` の実装にその内部状態を追跡させるためにあります。"

#: ../../library/stdtypes.rst:2720
msgid "memoryview type"
msgstr "メモリビュー型"

#: ../../library/stdtypes.rst:2724
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the buffer protocol without copying.  Memory is "
"generally interpreted as simple bytes."
msgstr ""
":class:`memoryview` オブジェクトは、Python コードが、バッファプロトコルをサ"
"ポートするオブジェクトの内部データへ、コピーすることなくアクセスすることを可"
"能にします。メモリは通常、単純なバイト列として解釈されます。"

#: ../../library/stdtypes.rst:2730
msgid ""
"Create a :class:`memoryview` that references *obj*.  *obj* must support the "
"buffer protocol.  Built-in objects that support the buffer protocol include :"
"class:`str` and :class:`bytearray` (but not :class:`unicode`)."
msgstr ""
"*obj* を参照する :class:`memoryview` を作成します。 *obj* はバッファプロトコ"
"ルをサポートしていなければなりません。バッファプロトコルをサポートする組み込"
"みオブジェクトには、 :class:`str` 、 :class:`bytearray` などがあります (ただ"
"し、 :class:`unicode` は違います)。"

#: ../../library/stdtypes.rst:2734
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating object *obj*.  For many simple types "
"such as :class:`str` and :class:`bytearray`, an element is a single byte, "
"but other third-party types may expose larger elements."
msgstr ""
":class:`memoryview` には *要素* の概念があり、それが起源のオブジェクト *obj* "
"によって扱われる原子的なメモリの単位になります。多くの単純な型、例えば :"
"class:`str` や :class:`bytearray` では、要素は単バイトになりますが、他のサー"
"ドパーティの型では、要素はより大きくなりえます。"

#: ../../library/stdtypes.rst:2739
msgid ""
"``len(view)`` returns the total number of elements in the memoryview, "
"*view*.  The :class:`~memoryview.itemsize` attribute will give you the "
"number of bytes in a single element."
msgstr ""
"``len(view)`` は、メモリビュー *view* の要素の総数を返します。 :class:"
"`~memoryview.itemsize` 属性で一つの要素内のバイト数を取得できます。"

#: ../../library/stdtypes.rst:2743
msgid ""
"A :class:`memoryview` supports slicing to expose its data.  Taking a single "
"index will return a single element as a :class:`str` object.  Full slicing "
"will result in a subview::"
msgstr ""
":class:`memoryview` はスライスしてデータを晒すことに対応しています。一つのイ"
"ンデクスを渡すと一つの要素を :class:`str` オブジェクトとして返します。完全な"
"スライシングは部分ビューになります::"

#: ../../library/stdtypes.rst:2757
msgid ""
"If the object the memoryview is over supports changing its data, the "
"memoryview supports slice assignment::"
msgstr ""
"メモリビューが基にしているオブジェクトがデータの変更に対応していれば、メモリ"
"ビューはスライス代入に対応します::"

#: ../../library/stdtypes.rst:2775
msgid "Notice how the size of the memoryview object cannot be changed."
msgstr "この通り、メモリビューオブジェクトの長さは変えられません。"

#: ../../library/stdtypes.rst:2777
msgid ":class:`memoryview` has two methods:"
msgstr ":class:`memoryview` には 2 つのメソッドがあります。"

#: ../../library/stdtypes.rst:2781
msgid ""
"Return the data in the buffer as a bytestring (an object of class :class:"
"`str`). ::"
msgstr ""
"バッファ中のデータをバイト文字列 (クラス :class:`str` のオブジェクト) として"
"返します::"

#: ../../library/stdtypes.rst:2790
msgid "Return the data in the buffer as a list of integers. ::"
msgstr "バッファ中のデータを整数のリストとして返します::"

#: ../../library/stdtypes.rst:2795
msgid "There are also several readonly attributes available:"
msgstr "読み込み専用の属性もいくつか使えます:"

#: ../../library/stdtypes.rst:2799
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view.  This defaults to ``'B'``, a simple bytestring."
msgstr ""
"ビューのそれぞれの要素に対する、(:mod:`struct` モジュールのスタイルでの) "
"フォーマットを含む文字列です。デフォルトは ``'B'`` で、単純なバイト文字列で"
"す。"

#: ../../library/stdtypes.rst:2804
msgid "The size in bytes of each element of the memoryview."
msgstr "メモリビューのそれぞれの要素のバイト数です。"

#: ../../library/stdtypes.rst:2808
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"メモリの形状を N 次元配列として与える、長さ :attr:`ndim` の整数のタプルです。"

#: ../../library/stdtypes.rst:2813
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr "メモリが表す多次元配列が何次元かを示す整数です。"

#: ../../library/stdtypes.rst:2818
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"配列のそれぞれの次元に対して、それぞれの要素にアクセスするのに必要なバイト数"
"を表す、長さ :attr:`ndim` の整数のタプルです。"

#: ../../library/stdtypes.rst:2823
msgid "A bool indicating whether the memory is read only."
msgstr "メモリが読み込み専用かを表すブールです。"

#: ../../library/stdtypes.rst:2831
msgid "Context Manager Types"
msgstr "コンテキストマネージャ型"

#: ../../library/stdtypes.rst:2840
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using two separate "
"methods that allow user-defined classes to define a runtime context that is "
"entered before the statement body is executed and exited when the statement "
"ends."
msgstr ""
"Python の :keyword:`with` 文は、コンテキストマネージャによって定義される実行"
"時コンテキストの概念をサポートします。これは、ユーザ定義クラスが文の本体が実"
"行される前に進入し文の終わりで脱出する実行時コンテキストを定義できるようにす"
"る一対のメソッドを使って実装されます:"

#: ../../library/stdtypes.rst:2845
msgid ""
"The :dfn:`context management protocol` consists of a pair of methods that "
"need to be provided for a context manager object to define a runtime context:"
msgstr ""
":dfn:`コンテキスト管理プロトコル` (:dfn:`context management protocol`) は実行"
"時コンテキストを定義するコンテキストマネージャオブジェクトが提供すべき一対の"
"メソッドから成ります:"

#: ../../library/stdtypes.rst:2851
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"実行時コンテキストに入り、このオブジェクトまたは他の実行時コンテキストに関連"
"したオブジェクトを返します。このメソッドが返す値はこのコンテキストマネージャ"
"を使う :keyword:`with` 文の :keyword:`as` 節の識別子に束縛されます。"

#: ../../library/stdtypes.rst:2856
msgid ""
"An example of a context manager that returns itself is a file object. File "
"objects return themselves from __enter__() to allow :func:`open` to be used "
"as the context expression in a :keyword:`with` statement."
msgstr ""
"自分自身を返すコンテキストマネージャの例としてファイルオブジェクトがありま"
"す。ファイルオブジェクトは :meth:`__enter__` から自分自身を返して :func:"
"`open` が :keyword:`with` 文のコンテキスト式として使われるようにします。"

#: ../../library/stdtypes.rst:2860
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`with` statement."
msgstr ""
"関連オブジェクトを返すコンテキストマネージャの例としては :func:`decimal."
"localcontext` が返すものがあります。このマネージャはアクティブな10進数コンテ"
"キストをオリジナルのコンテキストのコピーにセットしてそのコピーを返します。こ"
"うすることで, :keyword:`with` 文の本体の内部で、外側のコードに影響を与えず"
"に、 10進数コンテキストを変更できます。"

#: ../../library/stdtypes.rst:2870
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"実行時コンテキストから抜け、例外 (がもし起こっていたとしても) を抑制すること"
"を示すブール値フラグを返します。 :keyword:`with` 文の本体を実行中に例外が起"
"こったならば、引数にはその例外の型と値とトレースバック情報を渡します。そうで"
"なければ、引数は全て ``None`` です。"

#: ../../library/stdtypes.rst:2875
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`with` statement. Otherwise the "
"exception continues propagating after this method has finished executing. "
"Exceptions that occur during execution of this method will replace any "
"exception that occurred in the body of the :keyword:`with` statement."
msgstr ""
"このメソッドから真値が返されると :keyword:`with` 文は例外の発生を抑え、 :"
"keyword:`with` 文の直後の文に実行を続けます。そうでなければ、このメソッドの実"
"行を終えると例外の伝播が続きます。このメソッドの実行中に起きた例外は :"
"keyword:`with` 文の本体の実行中に起こった例外を置き換えてしまいます。"

#: ../../library/stdtypes.rst:2882
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code (such as ``contextlib.nested``) to easily detect "
"whether or not an :meth:`__exit__` method has actually failed."
msgstr ""
"渡された例外を明示的に再送出すべきではありません。その代わりに、このメソッド"
"が偽の値を返すことでメソッドの正常終了と送出された例外を抑制しないことを伝え"
"るべきです。このようにすれば (``contextlib.nested`` のような) コンテキストマ"
"ネージャは :meth:`__exit__` メソッド自体が失敗したのかどうかを簡単に見分ける"
"ことができます。"

#: ../../library/stdtypes.rst:2888
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python は幾つかのコンテキストマネージャを、易しいスレッド同期・ファイルなどの"
"オブジェクトの即時クローズ・単純化されたアクティブな10進算術コンテキストのサ"
"ポートのために用意しています。各型はコンテキスト管理プロトコルを実装している"
"という以上の特別の取り扱いを受けるわけではありません。例については :mod:"
"`contextlib` モジュールを参照下さい。"

#: ../../library/stdtypes.rst:2894
msgid ""
"Python's :term:`generator`\\s and the ``contextlib.contextmanager`` :term:"
"`decorator` provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the ``contextlib.contextmanager`` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`__enter__` and :meth:`__exit__` methods, rather than the iterator produced "
"by an undecorated generator function."
msgstr ""
"Python のジェネレータ (:term:`generator`) と ``contextlib.contextmanager`` デ"
"コレータ (:term:`decorator`) はこのプロトコルの簡便な実装方法を提供します。"
"ジェネレータ関数を ``contextlib.contextmanager`` でデコレートすると、デコレー"
"トしなければ返されるイテレータを返す代わりに、必要な :meth:`__enter__` およ"
"び :meth:`__exit__` メソッドを実装したコンテキストマネージャを返すようになり"
"ます。"

#: ../../library/stdtypes.rst:2901
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"これらのメソッドのために Python/C API の中の Python オブジェクトの型構造体に"
"特別なスロットが作られたわけではないことに注意してください。これらのメソッド"
"を定義したい拡張型はこれらを通常の Python からアクセスできるメソッドとして提"
"供しなければなりません。実行時コンテキストを準備するオーバーヘッドに比べた"
"ら、一回のクラス辞書の探索のオーバーヘッドは無視できます。"

#: ../../library/stdtypes.rst:2911
msgid "Other Built-in Types"
msgstr "その他の組み込み型"

#: ../../library/stdtypes.rst:2913
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"インタプリタは、その他いくつかの種類のオブジェクトをサポートします。これらの"
"ほとんどは 1 または 2 つの演算だけをサポートします。"

#: ../../library/stdtypes.rst:2920
msgid "Modules"
msgstr "モジュール"

#: ../../library/stdtypes.rst:2922
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"モジュールに対する唯一の特殊な演算は属性アクセス: ``m.name`` です。ここで "
"*m* はモジュールで、 *name* は *m* のシンボルテーブル上に定義された名前にアク"
"セスします。モジュール属性に代入することもできます。 (なお、:keyword:"
"`import` 文は、厳密にいえば、モジュールオブジェクトに対する演算ではありませ"
"ん; ``import foo`` は *foo* と名づけられたモジュールオブジェクトの存在を必要"
"とはせず、*foo* と名づけられたモジュールの (外部の) *定義* を必要とします。)"

#: ../../library/stdtypes.rst:2929
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"全てのモジュールにある特殊属性が :attr:`~object.__dict__` です。これはモ"
"ジュールのシンボルテーブルを含む辞書です。この辞書を書き換えると実際にモ"
"ジュールのシンボルテーブルを変更することができますが、:attr:`~object."
"__dict__` 属性を直接代入することはできません (``m.__dict__['a'] = 1`` と書い"
"て ``m.a`` を ``1`` に定義することはできますが、``m.__dict__ = {}`` と書くこ"
"とはできません)。 :attr:`~object.__dict__` を直接書き換えることは推奨されませ"
"ん。"

#: ../../library/stdtypes.rst:2937
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"インタプリタ内に組み込まれたモジュールは、 ``<module 'sys' (built-in)>`` のよ"
"うに書かれます。ファイルから読み出された場合、 ``<module 'os' from '/usr/"
"local/lib/pythonX.Y/os.pyc'>`` と書かれます。"

#: ../../library/stdtypes.rst:2945
msgid "Classes and Class Instances"
msgstr "クラスおよびクラスインスタンス"

#: ../../library/stdtypes.rst:2947
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "これらについては :ref:`objects` および :ref:`class` を参照下さい。"

#: ../../library/stdtypes.rst:2953
msgid "Functions"
msgstr "関数"

#: ../../library/stdtypes.rst:2955
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"関数オブジェクトは関数定義によって生成されます。関数オブジェクトに対する唯一"
"の操作は、それを呼び出すことです: ``func(argument-list)`` 。"

#: ../../library/stdtypes.rst:2958
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"関数オブジェクトには実際には二種類あります: 組み込み関数とユーザ定義関数で"
"す。どちらも同じ操作 (関数の呼び出し) をサポートしますが、実装は異なるので、"
"オブジェクトの型も異なります。"

#: ../../library/stdtypes.rst:2962
msgid "See :ref:`function` for more information."
msgstr "詳細は、 :ref:`function` を参照下さい。"

#: ../../library/stdtypes.rst:2968
msgid "Methods"
msgstr "メソッド"

#: ../../library/stdtypes.rst:2972
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""
"メソッドは属性表記を使って呼び出される関数です。メソッドには二種類あります: "
"(リストの :meth:`append` のような) 組み込みメソッドと、クラスインスタンスのメ"
"ソッドです。組み込みメソッドは、それをサポートする型と一緒に記述されていま"
"す。"

#: ../../library/stdtypes.rst:2977
msgid ""
"The implementation adds two special read-only attributes to class instance "
"methods: ``m.im_self`` is the object on which the method operates, and ``m."
"im_func`` is the function implementing the method.  Calling ``m(arg-1, "
"arg-2, ..., arg-n)`` is completely equivalent to calling ``m.im_func(m."
"im_self, arg-1, arg-2, ..., arg-n)``."
msgstr ""
"実装では、クラスインスタンスのメソッドに 2 つの読み込み専用の属性を追加してい"
"ます: ``m.im_self`` はメソッドが操作するオブジェクトで、 ``m.im_func`` はメ"
"ソッドを実装している関数です。 ``m(arg-1, arg-2, ..., arg-n)`` の呼び出し"
"は、 ``m.im_func(m.im_self, arg-1, arg-2, ..., arg-n)`` の呼び出しと完全に等"
"価です。"

#: ../../library/stdtypes.rst:2983
msgid ""
"Class instance methods are either *bound* or *unbound*, referring to whether "
"the method was accessed through an instance or a class, respectively.  When "
"a method is unbound, its ``im_self`` attribute will be ``None`` and if "
"called, an explicit ``self`` object must be passed as the first argument.  "
"In this case, ``self`` must be an instance of the unbound method's class (or "
"a subclass of that class), otherwise a :exc:`TypeError` is raised."
msgstr ""
"クラスインスタンスメソッドには、メソッドがインスタンスからアクセスされるかク"
"ラスからアクセスされるかによって、それぞれ *バインド* (束縛) または *非バイン"
"ド* (非束縛) があります。メソッドが非バインドメソッドの場合、 ``im_self`` 属"
"性は ``None`` になるため、呼び出す際には ``self`` オブジェクトを明示的に第一"
"引数として指定しなければなりません。この場合、 ``self`` は非バインドメソッド"
"のクラス (またはそのサブクラス) のインスタンスでなければならず、そうでなけれ"
"ば :exc:`TypeError` が送出されます。"

#: ../../library/stdtypes.rst:2990
msgid ""
"Like function objects, methods objects support getting arbitrary attributes. "
"However, since method attributes are actually stored on the underlying "
"function object (``meth.im_func``), setting method attributes on either "
"bound or unbound methods is disallowed.  Attempting to set an attribute on a "
"method results in an :exc:`AttributeError` being raised.  In order to set a "
"method attribute, you need to explicitly set it on the underlying function "
"object::"
msgstr ""
"関数オブジェクトと同じく、メソッドオブジェクトは任意の属性を取得できます。し"
"かし、メソッド属性は実際には背後の関数オブジェクト (``meth.im_func``) に記憶"
"されているので、バインドメソッド、非バインドメソッドへのメソッド属性の設定は"
"許されていません。メソッドへの属性の設定を試みると :exc:`AttributeError` が送"
"出されます。メソッド属性を設定するためには、その背後の関数オブジェクトで明示"
"的にセットする必要があります::"

#: ../../library/stdtypes.rst:3011 ../../library/stdtypes.rst:3039
msgid "See :ref:`types` for more information."
msgstr "詳細は、 :ref:`types` を参照下さい。"

#: ../../library/stdtypes.rst:3019
msgid "Code Objects"
msgstr "コードオブジェクト"

#: ../../library/stdtypes.rst:3025
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`func_code` attribute. See also the :mod:`code` module."
msgstr ""
"コードオブジェクトは、関数本体のような \"擬似コンパイルされた\" Python の実行"
"可能コードを表すために実装系によって使われます。コードオブジェクトはグローバ"
"ルな実行環境への参照を持たない点で関数オブジェクトとは異なります。コードオブ"
"ジェクトは組み込み関数 :func:`compile` によって返され、また関数オブジェクト"
"の :attr:`func_code` 属性として取り出せます。 :mod:`code` モジュールも参照下"
"さい。"

#: ../../library/stdtypes.rst:3036
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :keyword:`exec` statement or the built-in :func:`eval` "
"function."
msgstr ""
"コードオブジェクトは、 :func:`exec` 文や組み込み関数 :func:`eval` に (ソース"
"文字列の代わりに) 渡すことで、実行や評価できます。"

#: ../../library/stdtypes.rst:3045
msgid "Type Objects"
msgstr "型オブジェクト"

#: ../../library/stdtypes.rst:3051
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"型オブジェクトは様々なオブジェクト型を表します。オブジェクトの型は組み込み関"
"数 :func:`type` でアクセスされます。型オブジェクトには特有の操作はありませ"
"ん。標準モジュール :mod:`types` には全ての組み込み型名が定義されています。"

#: ../../library/stdtypes.rst:3056
msgid "Types are written like this: ``<type 'int'>``."
msgstr "型はこのように書き表されます: ``<type 'int'>`` 。"

#: ../../library/stdtypes.rst:3062
msgid "The Null Object"
msgstr "ヌルオブジェクト"

#: ../../library/stdtypes.rst:3064
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name)."
msgstr ""
"このオブジェクトは明示的に値を返さない関数によって返されます。このオブジェク"
"トには特有の操作はありません。ヌルオブジェクトは一つだけで、 ``None`` (組み込"
"み名) と名づけられています。"

#: ../../library/stdtypes.rst:3068
msgid "It is written as ``None``."
msgstr "``None`` と書き表されます。"

#: ../../library/stdtypes.rst:3074
msgid "The Ellipsis Object"
msgstr "Ellipsis オブジェクト"

#: ../../library/stdtypes.rst:3076
msgid ""
"This object is used by extended slice notation (see :ref:`slicings`).  It "
"supports no special operations.  There is exactly one ellipsis object, "
"named :const:`Ellipsis` (a built-in name)."
msgstr ""
"このオブジェクトは拡張スライス表記によって使われます (:ref:`slicings` を参照"
"下さい)。特殊な操作は何もサポートしていません。省略表記オブジェクトは一つだけ"
"で、その名前は :const:`Ellipsis` (組み込み名) です。"

#: ../../library/stdtypes.rst:3080
msgid ""
"It is written as ``Ellipsis``.  When in a subscript, it can also be written "
"as ``...``, for example ``seq[...]``."
msgstr ""
"``Ellipsis`` と書き表されます。添え字として使う場合 ``...`` とも書けます。例"
"えば ``seq[...]`` のように。"

#: ../../library/stdtypes.rst:3085
msgid "The NotImplemented Object"
msgstr "NotImplemented オブジェクト"

#: ../../library/stdtypes.rst:3087
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information."
msgstr ""
"このオブジェクトは、対応していない型の演算を求められたとき、比較や二項演算か"
"ら返されます。詳細は :ref:`comparisons` を参照してください。"

#: ../../library/stdtypes.rst:3091
msgid "It is written as ``NotImplemented``."
msgstr "``NotImplemented`` と書き表されます。"

#: ../../library/stdtypes.rst:3095
msgid "Boolean Values"
msgstr "ブール値"

#: ../../library/stdtypes.rst:3097
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and "
"1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""
"ブール値は二つの定数オブジェクト ``False`` および ``True`` です。これらは真理"
"値を表すのに使われます (ただし他の値も偽や真とみなされます)。 数値処理のコン"
"テキスト (例えば算術演算子の引数として使われた場合) では、これらはそれぞれ 0 "
"および 1 と同様に振舞います。任意の値に対して、真理値と解釈できる場合、組み込"
"み関数 :func:`bool` は値をブール値に変換するのに使われます (上述の :ref:"
"`truth` の節を参照してください)。"

#: ../../library/stdtypes.rst:3110
msgid "They are written as ``False`` and ``True``, respectively."
msgstr "それぞれ ``False`` および ``True`` と書き表されます。"

#: ../../library/stdtypes.rst:3116
msgid "Internal Objects"
msgstr "内部オブジェクト"

#: ../../library/stdtypes.rst:3118
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""
"この情報は :ref:`types` を参照下さい。スタックフレームオブジェクト、トレース"
"バックオブジェクト、スライスオブジェクトについて記述されています。"

#: ../../library/stdtypes.rst:3125
msgid "Special Attributes"
msgstr "特殊属性"

#: ../../library/stdtypes.rst:3127
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"実装は、いくつかのオブジェクト型に対して、適切な場合には特殊な読み出し専用の"
"属性を追加します。そのうちいくつかは :func:`dir` 組込み関数で報告されません。"

#: ../../library/stdtypes.rst:3134
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""
"オブジェクトの (書き込み可能な) 属性を保存するために使われる辞書またはその他"
"のマッピングオブジェクトです。"

#: ../../library/stdtypes.rst:3140 ../../library/stdtypes.rst:3147
msgid ""
"Use the built-in function :func:`dir` to get a list of an object's "
"attributes. This attribute is no longer available."
msgstr ""
"オブジェクトの属性からなるリストを取得するには、組み込み関数 :func:`dir` を"
"使ってください。この属性はもう利用できません。"

#: ../../library/stdtypes.rst:3154
msgid "The class to which a class instance belongs."
msgstr "クラスインスタンスが属しているクラスです。"

#: ../../library/stdtypes.rst:3159
msgid "The tuple of base classes of a class object."
msgstr "クラスオブジェクトの基底クラスのタプルです。"

#: ../../library/stdtypes.rst:3164
msgid ""
"The name of the class, type, function, method, descriptor, or generator "
"instance."
msgstr ""
"クラス、型、関数、メソッド、デスクリプタ、ジェネレータインスタンスの名前で"
"す。"

#: ../../library/stdtypes.rst:3168
msgid ""
"The following attributes are only supported by :term:`new-style class`\\ es."
msgstr ""
"以下の属性は、新スタイルクラス (:term:`new-style class`) でのみサポートされま"
"す。"

#: ../../library/stdtypes.rst:3172
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""
"この属性はメソッドの解決時に基底クラスを探索するときに考慮されるクラスのタプ"
"ルです。"

#: ../../library/stdtypes.rst:3178
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"このメソッドは、メタクラスによって、そのインスタンスのメソッド解決の順序をカ"
"スタマイズするために、上書きされるかも知れません。このメソッドはクラスのイン"
"スタンス化時に呼ばれ、その結果は :attr:`~class.__mro__` に格納されます。"

#: ../../library/stdtypes.rst:3185
msgid ""
"Each new-style class keeps a list of weak references to its immediate "
"subclasses.  This method returns a list of all those references still alive. "
"Example::"
msgstr ""
"それぞれの新スタイルクラスは、それ自身の直接のサブクラスへの弱参照を保持しま"
"す。このメソッドはそれらの参照のうち、生存しているもののリストを返します。"
"例::"

#: ../../library/stdtypes.rst:3194
msgid "Footnotes"
msgstr "注記"

#: ../../library/stdtypes.rst:3195
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"これらの特殊なメソッドのさらなる情報は、 Python リファレンスマニュアル (:ref:"
"`customization`) を参照下さい。"

#: ../../library/stdtypes.rst:3198
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"この結果として、リスト ``[1, 2]`` は ``[1.0, 2.0]`` と等しいと見なされます。"
"タプルの場合も同様です。"

#: ../../library/stdtypes.rst:3201
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""
"パーザが演算対象の型を識別できるようにするために、このような優先順位でなけれ"
"ばならないのです。"

#: ../../library/stdtypes.rst:3203
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"大小文字の区別のある文字とは、一般カテゴリプロパティが \"Lu\" (Letter, "
"uppercase (大文字))、 \"Ll\" (Letter, lowercase (小文字))、 \"Lt\" (Letter、"
"titlecase (先頭が大文字)) のいずれかであるものです。"

#: ../../library/stdtypes.rst:3206
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"従って、一個のタプルだけをフォーマット出力したい場合には出力したいタプルを唯"
"一の要素とする単一のタプルを *values* に与えなくてはなりません。"

#: ../../library/stdtypes.rst:3209
msgid ""
"The advantage of leaving the newline on is that returning an empty string is "
"then an unambiguous EOF indication.  It is also possible (in cases where it "
"might matter, for example, if you want to make an exact copy of a file while "
"scanning its lines) to tell whether the last line of a file ended in a "
"newline or not (yes this happens!)."
msgstr ""
"改行を残す利点は、空の文字列が返ると EOF を示し、紛らわしくなくなるからです。"
"また、ファイルの最後の行が改行で終わっているかそうでない (ありえることです!) "
"か (例えば、ファイルを行単位で読みながらその完全なコピーを作成した場合には問"
"題になります) を調べることができます。"
