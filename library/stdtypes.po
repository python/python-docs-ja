# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-30 14:59+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "組み込み型"

#: ../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"以下のセクションでは、インタプリタに組み込まれている標準型について記述しま"
"す。"

#: ../../library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"主要な組み込み型は、数値、シーケンス、マッピング、クラス、インスタンス、およ"
"び例外です。"

#: ../../library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"コレクションクラスには、ミュータブルなものがあります。コレクションのメンバを"
"インプレースに足し、引き、または並べ替えて、特定の要素を返さないメソッドは、"
"コレクション自身ではなく ``None`` を返します。"

#: ../../library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"演算には、複数の型でサポートされているものがあります; 特に、ほぼ全てのオブ"
"ジェクトは、等価比較でき、真理値を判定でき、 (:func:`repr` 関数や、わずかに異"
"なる :func:`str` 関数によって) 文字列に変換できます。オブジェクトが :func:"
"`print` 関数で印字されるとき、文字列に変換する関数が暗黙に使われます。"

#: ../../library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "真理値判定"

#: ../../library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"どのようなオブジェクトでも真理値として判定でき、 :keyword:`if` や :keyword:"
"`while` の条件あるいは以下のブール演算の被演算子として使えます。"

#: ../../library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`__bool__` method that returns ``False`` or a :meth:`__len__` method "
"that returns zero, when called with the object. [1]_  Here are most of the "
"built-in objects considered false:"
msgstr ""
"オブジェクトは、デフォルトでは真と判定されます。ただしそのクラスが :meth:"
"`__bool__` メソッドを定義していて、それが ``False`` を返す場合、または :meth:"
"`__len__` メソッドを定義していて、それが 0 を返す場合は偽と判定されます。 "
"[1]_ 主な組み込みオブジェクトで偽と判定されるものを次に示します:"

#: ../../library/stdtypes.rst:55
msgid "constants defined to be false: ``None`` and ``False``."
msgstr "偽であると定義されている定数: ``None`` と ``False``"

#: ../../library/stdtypes.rst:57
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"数値型におけるゼロ: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, ``Fraction(0, "
"1)``"

#: ../../library/stdtypes.rst:60
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"空のシーケンスまたはコレクション: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"

#: ../../library/stdtypes.rst:69
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"ブール値の結果を返す演算および組み込み関数は、特に注釈のない限り常に偽値とし"
"て ``0`` または ``False`` を返し、真値として ``1`` または ``True`` を返しま"
"す。 (重要な例外: ブール演算 ``or`` および ``and`` は常に被演算子のうちの一つ"
"を返します。)"

#: ../../library/stdtypes.rst:78
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr "ブール演算 --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

#: ../../library/stdtypes.rst:82
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "以下にブール演算を、優先順位が低い順に示します:"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:143
#: ../../library/stdtypes.rst:275 ../../library/stdtypes.rst:364
#: ../../library/stdtypes.rst:414 ../../library/stdtypes.rst:883
#: ../../library/stdtypes.rst:1088
msgid "Operation"
msgstr "演算"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:275
#: ../../library/stdtypes.rst:364 ../../library/stdtypes.rst:414
#: ../../library/stdtypes.rst:883 ../../library/stdtypes.rst:1088
msgid "Result"
msgstr "結果"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:275
#: ../../library/stdtypes.rst:414 ../../library/stdtypes.rst:883
#: ../../library/stdtypes.rst:1088 ../../library/stdtypes.rst:2331
#: ../../library/stdtypes.rst:3549
msgid "Notes"
msgstr "注釈"

#: ../../library/stdtypes.rst:87
msgid "``x or y``"
msgstr "``x or y``"

#: ../../library/stdtypes.rst:87
msgid "if *x* is false, then *y*, else *x*"
msgstr "*x* が偽なら *y*, そうでなければ *x*"

#: ../../library/stdtypes.rst:87 ../../library/stdtypes.rst:285
#: ../../library/stdtypes.rst:885 ../../library/stdtypes.rst:888
#: ../../library/stdtypes.rst:1099 ../../library/stdtypes.rst:2337
#: ../../library/stdtypes.rst:3555
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/stdtypes.rst:90
msgid "``x and y``"
msgstr "``x and y``"

#: ../../library/stdtypes.rst:90
msgid "if *x* is false, then *x*, else *y*"
msgstr "*x* が偽なら *x*, そうでなければ *y*"

#: ../../library/stdtypes.rst:90 ../../library/stdtypes.rst:288
#: ../../library/stdtypes.rst:308 ../../library/stdtypes.rst:1127
#: ../../library/stdtypes.rst:2341 ../../library/stdtypes.rst:2343
#: ../../library/stdtypes.rst:3559 ../../library/stdtypes.rst:3561
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/stdtypes.rst:93
msgid "``not x``"
msgstr "``not x``"

#: ../../library/stdtypes.rst:93
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "*x* が偽なら ``True``, そうでなければ ``False``"

#: ../../library/stdtypes.rst:93 ../../library/stdtypes.rst:897
#: ../../library/stdtypes.rst:1130 ../../library/stdtypes.rst:2345
#: ../../library/stdtypes.rst:2347 ../../library/stdtypes.rst:2349
#: ../../library/stdtypes.rst:2351 ../../library/stdtypes.rst:3563
#: ../../library/stdtypes.rst:3565 ../../library/stdtypes.rst:3567
#: ../../library/stdtypes.rst:3569
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/stdtypes.rst:102 ../../library/stdtypes.rst:319
#: ../../library/stdtypes.rst:432 ../../library/stdtypes.rst:934
#: ../../library/stdtypes.rst:1138 ../../library/stdtypes.rst:2377
#: ../../library/stdtypes.rst:3599
msgid "Notes:"
msgstr "注釈:"

#: ../../library/stdtypes.rst:105
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"この演算子は短絡評価されます。つまり第一引数が偽のときにのみ、第二引数が評価"
"されます。"

#: ../../library/stdtypes.rst:109
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"この演算子は短絡評価されます。つまり第一引数が真のときにのみ、第二引数が評価"
"されます。"

#: ../../library/stdtypes.rst:113
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` は非ブール演算子よりも優先度が低いので、 ``not a == b`` は ``not (a "
"== b)`` と解釈され、 ``a == not b`` は構文エラーです。"

#: ../../library/stdtypes.rst:120
msgid "Comparisons"
msgstr "比較"

#: ../../library/stdtypes.rst:134
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Python には 8 種の比較演算があります。比較演算の優先順位は全て同じです (ブー"
"ル演算より高い優先順位です)。比較は任意に連鎖できます; 例えば、 ``x < y <= "
"z`` は ``x < y and y <= z`` とほぼ等価ですが、この *y* は一度だけしか評価され"
"ません (どちらにしても、 ``x < y`` が偽となれば *z* は評価されません)。"

#: ../../library/stdtypes.rst:140
msgid "This table summarizes the comparison operations:"
msgstr "以下の表に比較演算をまとめます:"

#: ../../library/stdtypes.rst:143 ../../library/stdtypes.rst:2308
#: ../../library/stdtypes.rst:2331 ../../library/stdtypes.rst:3526
#: ../../library/stdtypes.rst:3549
msgid "Meaning"
msgstr "意味"

#: ../../library/stdtypes.rst:145
msgid "``<``"
msgstr "``<``"

#: ../../library/stdtypes.rst:145
msgid "strictly less than"
msgstr "より小さい"

#: ../../library/stdtypes.rst:147
msgid "``<=``"
msgstr "``<=``"

#: ../../library/stdtypes.rst:147
msgid "less than or equal"
msgstr "以下"

#: ../../library/stdtypes.rst:149
msgid "``>``"
msgstr "``>``"

#: ../../library/stdtypes.rst:149
msgid "strictly greater than"
msgstr "より大きい"

#: ../../library/stdtypes.rst:151
msgid "``>=``"
msgstr "``>=``"

#: ../../library/stdtypes.rst:151
msgid "greater than or equal"
msgstr "以上"

#: ../../library/stdtypes.rst:153
msgid "``==``"
msgstr "``==``"

#: ../../library/stdtypes.rst:153
msgid "equal"
msgstr "等しい"

#: ../../library/stdtypes.rst:155
msgid "``!=``"
msgstr "``!=``"

#: ../../library/stdtypes.rst:155
msgid "not equal"
msgstr "等しくない"

#: ../../library/stdtypes.rst:157
msgid "``is``"
msgstr "``is``"

#: ../../library/stdtypes.rst:157
msgid "object identity"
msgstr "同一のオブジェクトである"

#: ../../library/stdtypes.rst:159
msgid "``is not``"
msgstr "``is not``"

#: ../../library/stdtypes.rst:159
msgid "negated object identity"
msgstr "同一のオブジェクトでない"

#: ../../library/stdtypes.rst:166
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. The ``==`` operator is always defined but for some object types (for "
"example, class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, "
"``>`` and ``>=`` operators are only defined where they make sense; for "
"example, they raise a :exc:`TypeError` exception when one of the arguments "
"is a complex number."
msgstr ""
"異なる数値型の場合を除き、異なる型のオブジェクト同士は等価になることはありま"
"せん。 ``==`` 演算子は常に定義されていますが、いくつかのオブジェクト型 (たと"
"えばクラスオブジェクト) では :keyword:`is` と同等になります。 ``<``, ``<=``, "
"``>`` および ``>=`` 演算子は、それらの意味が明快である場合に限って定義されま"
"す; たとえば、オペランドのいずれかが複素数である場合、これらの演算子は :exc:"
"`TypeError` 例外を送出します。"

#: ../../library/stdtypes.rst:180
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`~object.__eq__` method."
msgstr ""
"あるクラスの同一でないインスタンスは、通常等価でないとされますが、そのクラス"
"が :meth:`~object.__eq__` メソッドを定義している場合は除きます。"

#: ../../library/stdtypes.rst:183
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object."
"__gt__`, and :meth:`~object.__ge__` (in general, :meth:`~object.__lt__` and :"
"meth:`~object.__eq__` are sufficient, if you want the conventional meanings "
"of the comparison operators)."
msgstr ""
"クラスのインスタンスは、そのクラスがメソッド :meth:`~object.__lt__` 、 :meth:"
"`~object.__le__` 、 :meth:`~object.__gt__` 、 :meth:`~object.__ge__` のうち十"
"分なものを定義していない限り、同じクラスの別のインスタンスや他の型のオブジェ"
"クトとは順序付けできません (一般に、比較演算子の通常の意味を求めるなら、 :"
"meth:`~object.__lt__` と :meth:`~object.__eq__` だけで十分です)。"

#: ../../library/stdtypes.rst:190
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
":keyword:`is` および :keyword:`is not` 演算子の振る舞いはカスタマイズできませ"
"ん。また、これらはいかなる 2 つのオブジェクトにも適用でき、決して例外を送出し"
"ません。"

#: ../../library/stdtypes.rst:198
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`__contains__` method."
msgstr ""
":keyword:`in` と :keyword:`not in` という構文上で同じ優先度を持つ演算子がさら"
"に 2 つあり、 :term:`iterable` または :meth:`__contains__` を実装した型でサ"
"ポートされています。"

#: ../../library/stdtypes.rst:205
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "数値型 :class:`int`, :class:`float`, :class:`complex`"

#: ../../library/stdtypes.rst:215
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:expr:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes the additional "
"numeric types :mod:`fractions.Fraction`, for rationals, and :mod:`decimal."
"Decimal`, for floating-point numbers with user-definable precision.)"
msgstr ""
"数値型には 3 種類あります: :dfn:`整数` 、 :dfn:`浮動小数点数` 、 :dfn:`複素数"
"` です。さらに、ブール型は整数のサブタイプです。整数には精度の制限がありませ"
"ん。浮動小数点型はたいていは C の :c:expr:`double` を使って実装されています; "
"あなたのプログラムが動作するマシンでの浮動小数点型の精度と内部表現は、 :data:"
"`sys.float_info` から利用できます。複素数は実部と虚部を持ち、それぞれ浮動小数"
"点数です。複素数 *z* から実部および虚部を取り出すには、 ``z.real`` および "
"``z.imag`` を使ってください。 (標準ライブラリには、さらに分数のための数値型 :"
"mod:`fractions.Fraction` や、ユーザによる精度の定義が可能な浮動小数点数のため"
"の :mod:`decimal.Decimal` があります。)"

#: ../../library/stdtypes.rst:237
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"数値は、数値リテラルによって、あるいは組み込み関数や演算子の戻り値として生成"
"されます。 (十六進、八進、二進数を含む) 修飾のない整数リテラルは、整数を与え"
"ます。小数点または指数表記を含む数値リテラルは浮動小数点数を与えます。数値リ"
"テラルに ``'j'`` または ``'J'`` をつけると虚数 (実部がゼロの複素数) を与え、"
"それに整数や浮動小数点数を加えて実部と虚部を持つ複素数を得られます。"

#: ../../library/stdtypes.rst:262
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex. A comparison between numbers "
"of different types behaves as though the exact values of those numbers were "
"being compared. [2]_"
msgstr ""
"Python は型混合の算術演算に完全に対応しています: ある二項算術演算子の被演算子"
"の数値型が互いに異なるとき、\"より狭い方\" の型の被演算子はもう片方の型に合わ"
"せて広げられます。ここで整数は浮動小数点数より狭く、浮動小数点数は複素数より"
"狭いです。\n"
"たくさんの異なる型の数値間での比較は、それらの厳密な数で比較したかのように振"
"る舞います。 [2]_"

#: ../../library/stdtypes.rst:268
msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used "
"to produce numbers of a specific type."
msgstr ""
"コンストラクタ :func:`int` 、 :func:`float` 、 :func:`complex` で、特定の型の"
"数を生成できます。"

#: ../../library/stdtypes.rst:271
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr ""
"全ての (複素数を除く) 組み込み数値型は以下の演算に対応しています (演算の優先"
"順位については、 :ref:`operator-summary` を参照してください):"

#: ../../library/stdtypes.rst:275
msgid "Full documentation"
msgstr "完全なドキュメント"

#: ../../library/stdtypes.rst:277
msgid "``x + y``"
msgstr "``x + y``"

#: ../../library/stdtypes.rst:277
msgid "sum of *x* and *y*"
msgstr "*x* と *y* の和"

#: ../../library/stdtypes.rst:279
msgid "``x - y``"
msgstr "``x - y``"

#: ../../library/stdtypes.rst:279
msgid "difference of *x* and *y*"
msgstr "*x* と *y* の差"

#: ../../library/stdtypes.rst:281
msgid "``x * y``"
msgstr "``x * y``"

#: ../../library/stdtypes.rst:281
msgid "product of *x* and *y*"
msgstr "*x* と *y* の積"

#: ../../library/stdtypes.rst:283
msgid "``x / y``"
msgstr "``x / y``"

#: ../../library/stdtypes.rst:283
msgid "quotient of *x* and *y*"
msgstr "*x* と *y* の商"

#: ../../library/stdtypes.rst:285
msgid "``x // y``"
msgstr "``x // y``"

#: ../../library/stdtypes.rst:285
msgid "floored quotient of *x* and *y*"
msgstr "*x* と *y* の商を切り下げたもの"

#: ../../library/stdtypes.rst:288
msgid "``x % y``"
msgstr "``x % y``"

#: ../../library/stdtypes.rst:288
msgid "remainder of ``x / y``"
msgstr "``x / y`` の剰余"

#: ../../library/stdtypes.rst:290
msgid "``-x``"
msgstr "``-x``"

#: ../../library/stdtypes.rst:290
msgid "*x* negated"
msgstr "*x* の符号反転"

#: ../../library/stdtypes.rst:292
msgid "``+x``"
msgstr "``+x``"

#: ../../library/stdtypes.rst:292
msgid "*x* unchanged"
msgstr "*x* そのまま"

#: ../../library/stdtypes.rst:294
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../library/stdtypes.rst:294
msgid "absolute value or magnitude of *x*"
msgstr "*x* の絶対値または大きさ"

#: ../../library/stdtypes.rst:294
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/stdtypes.rst:297
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../library/stdtypes.rst:297
msgid "*x* converted to integer"
msgstr "*x* の整数への変換"

#: ../../library/stdtypes.rst:297
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../../library/stdtypes.rst:297
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/stdtypes.rst:299
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../library/stdtypes.rst:299
msgid "*x* converted to floating point"
msgstr "*x* の浮動小数点数への変換"

#: ../../library/stdtypes.rst:299
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../../library/stdtypes.rst:299
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/stdtypes.rst:301
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../../library/stdtypes.rst:301
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr "実部 *re*, 虚部 *im* の複素数。 *im* の既定値はゼロ。"

#: ../../library/stdtypes.rst:301 ../../library/stdtypes.rst:1120
#: ../../library/stdtypes.rst:2339 ../../library/stdtypes.rst:3586
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/stdtypes.rst:301
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/stdtypes.rst:305
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../../library/stdtypes.rst:305
msgid "conjugate of the complex number *c*"
msgstr "複素数 *c* の共役複素数"

#: ../../library/stdtypes.rst:308
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../library/stdtypes.rst:308
msgid "the pair ``(x // y, x % y)``"
msgstr "``(x // y, x % y)`` からなるペア"

#: ../../library/stdtypes.rst:308
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/stdtypes.rst:310
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../../library/stdtypes.rst:310 ../../library/stdtypes.rst:312
msgid "*x* to the power *y*"
msgstr "*x* の *y* 乗"

#: ../../library/stdtypes.rst:310 ../../library/stdtypes.rst:312
#: ../../library/stdtypes.rst:1109 ../../library/stdtypes.rst:1112
#: ../../library/stdtypes.rst:2364 ../../library/stdtypes.rst:2367
#: ../../library/stdtypes.rst:2370 ../../library/stdtypes.rst:3582
#: ../../library/stdtypes.rst:3589
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/stdtypes.rst:310
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/stdtypes.rst:312
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../../library/stdtypes.rst:322
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"整数の除算とも呼ばれます。結果の型は整数型とは限りませんが、結果の値は整数で"
"す。結果は常に負の無限大の方向に丸められます: ``1//2`` は ``0`` 、 "
"``(-1)//2`` は ``-1`` 、 ``1//(-2)`` は ``-1`` 、そして ``(-1)//(-2)`` は "
"``0`` です。"

#: ../../library/stdtypes.rst:328
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"複素数型には使えません。適用可能な場合には代わりに :func:`abs` で浮動小数点型"
"に変換してください。"

#: ../../library/stdtypes.rst:340
msgid ""
"Conversion from floating point to integer may round or truncate as in C; see "
"functions :func:`math.floor` and :func:`math.ceil` for well-defined "
"conversions."
msgstr ""
"浮動小数点数から整数への変換はC言語と同様の方法で丸め、または切り捨てられま"
"す; より明確に定義された変換を行う場合は、 :func:`math.floor` と :func:`math."
"ceil` を参照してください。"

#: ../../library/stdtypes.rst:345
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"浮動小数点数は、文字列 \"nan\" と \"inf\" を、オプションの接頭辞 \"+\" また"
"は \"-\" と共に、非数 (Not a Number (NaN)) や正、負の無限大として受け付けま"
"す。"

#: ../../library/stdtypes.rst:349
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python は、プログラム言語一般でそうであるように、 ``pow(0, 0)`` および ``0 "
"** 0`` を ``1`` と定義します。"

#: ../../library/stdtypes.rst:353
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"受け付けられる数値リテラルは数字 ``0`` から ``9`` または等価な Unicode "
"(``Nd`` プロパティを持つコードポイント) を含みます。"

#: ../../library/stdtypes.rst:356
msgid ""
"See https://www.unicode.org/Public/13.0.0/ucd/extracted/DerivedNumericType."
"txt for a complete list of code points with the ``Nd`` property."
msgstr ""
"``Nd`` プロパティを持つコードポイントの完全なリストは https://www.unicode."
"org/Public/13.0.0/ucd/extracted/DerivedNumericType.txt をご覧ください。"

#: ../../library/stdtypes.rst:360
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"全ての :class:`numbers.Real` 型 (:class:`int` 、 :class:`float`) は以下の演算"
"も含みます:"

#: ../../library/stdtypes.rst:366
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../../library/stdtypes.rst:366
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* を :class:`~numbers.Integral` (整数) に切り捨てます"

#: ../../library/stdtypes.rst:369
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../../library/stdtypes.rst:369
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr ""
"*x* を *n* 桁に丸めます。丸め方は偶数丸めです。 *n* が省略されれば 0 がデフォ"
"ルトとなります。"

#: ../../library/stdtypes.rst:373
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../../library/stdtypes.rst:373
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "*x* 以下の最大の :class:`~numbers.Integral` (整数) を返します"

#: ../../library/stdtypes.rst:376
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../../library/stdtypes.rst:376
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "*x* 以上の最小の :class:`~numbers.Integral` (整数) を返します"

#: ../../library/stdtypes.rst:380
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""
"その他の数値演算は、 :mod:`math` や :mod:`cmath` モジュールをご覧ください。"

#: ../../library/stdtypes.rst:389
msgid "Bitwise Operations on Integer Types"
msgstr "整数型におけるビット単位演算"

#: ../../library/stdtypes.rst:403
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"ビット単位演算は整数についてのみ意味を持ちます。\n"
"ビット単位演算の結果は、あたかも両方の値の先頭を無限個の符号ビットで埋めたも"
"のに対して計算したかのような値になります。"

#: ../../library/stdtypes.rst:407
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"二項ビット単位演算の優先順位は全て、数値演算よりも低く、比較よりも高くなって"
"います; 単項演算 ``~`` の優先順位は他の単項数値演算 (``+`` および ``-``) と同"
"じです。"

#: ../../library/stdtypes.rst:411
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr "以下の表では、ビット単位演算を優先順位が低い順に並べています:"

#: ../../library/stdtypes.rst:416
msgid "``x | y``"
msgstr "``x | y``"

#: ../../library/stdtypes.rst:416
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "*x* と *y* のビット単位 :dfn:`論理和`"

#: ../../library/stdtypes.rst:416 ../../library/stdtypes.rst:419
#: ../../library/stdtypes.rst:422 ../../library/stdtypes.rst:1133
#: ../../library/stdtypes.rst:2353 ../../library/stdtypes.rst:2357
#: ../../library/stdtypes.rst:3571 ../../library/stdtypes.rst:3575
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/stdtypes.rst:419
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../../library/stdtypes.rst:419
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "*x* と *y* のビット単位 :dfn:`排他的論理和`"

#: ../../library/stdtypes.rst:422
msgid "``x & y``"
msgstr "``x & y``"

#: ../../library/stdtypes.rst:422
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "*x* と *y* のビット単位 :dfn:`論理積`"

#: ../../library/stdtypes.rst:425
msgid "``x << n``"
msgstr "``x << n``"

#: ../../library/stdtypes.rst:425
msgid "*x* shifted left by *n* bits"
msgstr "*x* の *n* ビット左シフト"

#: ../../library/stdtypes.rst:425
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:427
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../../library/stdtypes.rst:427
msgid "*x* shifted right by *n* bits"
msgstr "*x* の *n* ビット右シフト"

#: ../../library/stdtypes.rst:427
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../../library/stdtypes.rst:429
msgid "``~x``"
msgstr "``~x``"

#: ../../library/stdtypes.rst:429
msgid "the bits of *x* inverted"
msgstr "*x* のビット反転"

#: ../../library/stdtypes.rst:435
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr "負値のシフト数は不正であり、 :exc:`ValueError` が送出されます。"

#: ../../library/stdtypes.rst:438
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr "*n* ビットの左シフトは、 ``pow(2, n)`` による乗算と等価です。"

#: ../../library/stdtypes.rst:441
msgid ""
"A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr "*n* ビットの右シフトは、 ``pow(2, n)`` による切り捨て除算と等価です。"

#: ../../library/stdtypes.rst:444
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"桁の長い方の値に少なくとも 1 つ余計に符号ビットを付け加えた幅 (計算するビット"
"幅は ``1 + max(x.bit_length(), y.bit_length())`` かそれ以上) でこれらの計算を"
"行えば、無限個の符号ビットがあるかのように計算したのと同じ結果を得るのに十分"
"です。"

#: ../../library/stdtypes.rst:451
msgid "Additional Methods on Integer Types"
msgstr "整数型における追加のメソッド"

#: ../../library/stdtypes.rst:453
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"整数型は :class:`numbers.Integral` :term:`抽象基底クラス <abstract base "
"class>` を実装します。さらに、追加のメソッドをいくつか提供します:"

#: ../../library/stdtypes.rst:458
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"整数を、符号と先頭の 0 は除いて二進法で表すために必要なビットの数を返します::"

#: ../../library/stdtypes.rst:467
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"正確には、 ``x`` が非 0 なら、 ``x.bit_length()`` は ``2**(k-1) <= abs(x) < "
"2**k`` を満たす唯一の正の整数 ``k`` です。同様に、 ``abs(x)`` が十分小さくて"
"対数を適切に丸められるとき、 ``k = 1 + int(log(abs(x), 2))`` です。 ``x`` が "
"0 なら、 ``x.bit_length()`` は ``0`` を返します。"

#: ../../library/stdtypes.rst:473 ../../library/stdtypes.rst:496
msgid "Equivalent to::"
msgstr "次と等価です::"

#: ../../library/stdtypes.rst:484
msgid ""
"Return the number of ones in the binary representation of the absolute value "
"of the integer. This is also known as the population count. Example::"
msgstr ""
"整数の絶対値の二進数表現における 1 の数を返します。これは population count と"
"しても知られています。 例::"

#: ../../library/stdtypes.rst:505
msgid "Return an array of bytes representing an integer."
msgstr "整数を表すバイト列を返します。"

#: ../../library/stdtypes.rst:517
msgid ""
"The integer is represented using *length* bytes.  An :exc:`OverflowError` is "
"raised if the integer is not representable with the given number of bytes."
msgstr ""
"整数は *length* バイトで表されます。整数が与えられた数のバイトで表せなけれ"
"ば、 :exc:`OverflowError` が送出されます。"

#: ../../library/stdtypes.rst:521 ../../library/stdtypes.rst:553
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer.  If *byteorder* is ``\"big\"``, the most significant byte is at the "
"beginning of the byte array.  If *byteorder* is ``\"little\"``, the most "
"significant byte is at the end of the byte array.  To request the native "
"byte order of the host system, use :data:`sys.byteorder` as the byte order "
"value."
msgstr ""
"*byteorder* 引数は、整数を表すのに使われるバイトオーダーを決定します。 "
"*byteorder* が ``\"big\"`` なら、最上位のバイトがバイト配列の最初に来ます。 "
"*byteorder* が ``\"little\"`` なら、最上位のバイトがバイト配列の最後に来ま"
"す。ホストシステムにネイティブのバイトオーダーを要求するには、 :data:`sys."
"byteorder` をバイトオーダーの値として使ってください。"

#: ../../library/stdtypes.rst:528
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"*signed* 引数は、整数を表すのに 2 の補数を使うかどうかを決定します。 "
"*signed* が ``False`` で、負の整数が与えられたなら、 :exc:`OverflowError`  が"
"送出されます。 *signed* のデフォルト値は ``False`` です。"

#: ../../library/stdtypes.rst:537
msgid "Return the integer represented by the given array of bytes."
msgstr "与えられたバイト列の整数表現を返します。"

#: ../../library/stdtypes.rst:550
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"引数 *bytes* は :term:`bytes-like object` か、または bytes を生成する "
"iterable でなければなりません。"

#: ../../library/stdtypes.rst:560
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr "*signed* 引数は、整数を表すのに 2 の補数を使うかどうかを決定します。"

#: ../../library/stdtypes.rst:567
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"integer and with a positive denominator. The integer ratio of integers "
"(whole numbers) is always the integer as the numerator and ``1`` as the "
"denominator."
msgstr ""

#: ../../library/stdtypes.rst:575
msgid "Additional Methods on Float"
msgstr "浮動小数点数に対する追加のメソッド"

#: ../../library/stdtypes.rst:577
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"浮動小数点数型は、 :class:`numbers.Real` :term:`抽象基底クラス <abstract "
"base class>` を実装しています。浮動小数点型はまた、以下の追加のメソッドを持ち"
"ます。"

#: ../../library/stdtypes.rst:582
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float "
"and with a positive denominator.  Raises :exc:`OverflowError` on infinities "
"and a :exc:`ValueError` on NaNs."
msgstr ""
"比が元の浮動小数点数とちょうど同じで分母が正である、一対の整数を返します。無"
"限大に対しては :exc:`OverflowError` を、非数 (NaN) に対しては :exc:"
"`ValueError` を送出します。"

#: ../../library/stdtypes.rst:589
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"浮動小数点数インスタンスが有限の整数値なら ``True`` を、そうでなければ "
"``False`` を返します::"

#: ../../library/stdtypes.rst:597
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"16 進表記の文字列へ、または、 16 進表記からの変換をサポートする二つのメソッド"
"があります。 Python の浮動小数点数は内部的には2進数で保持されるので、浮動小数"
"点数の *10進数* へまたは *10進数* からの変換には若干の丸め誤差があります。そ"
"れに対し、16 進表記では、浮動小数点数を正確に表現できます。これはデバッグのと"
"きや、数学的な用途 (numerical work) に便利でしょう。"

#: ../../library/stdtypes.rst:608
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"浮動小数点数の 16 進文字列表現を返します。有限の浮動小数点数に対し、この表現"
"は常に ``0x`` で始まり ``p`` と指数が続きます。"

#: ../../library/stdtypes.rst:616
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"16 進文字列表現 *s* で表される、浮動小数点数を返すクラスメソッドです。文字列 "
"*s* は、前や後にホワイトスペースを含んでいても構いません。"

#: ../../library/stdtypes.rst:621
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
":meth:`float.fromhex` はクラスメソッドですが、 :meth:`float.hex` はインスタン"
"スメソッドであることに注意して下さい。"

#: ../../library/stdtypes.rst:624
msgid "A hexadecimal string takes the form::"
msgstr "16 進文字列表現は以下の書式となります::"

#: ../../library/stdtypes.rst:628
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"``sign`` は必須ではなく、 ``+`` と ``-`` のどちらかです。 ``integer`` と "
"``fraction`` は 16 進数の文字列で、 ``exponent`` は 10 進数で符号もつけられま"
"す。大文字・小文字は区別されず、最低でも 1 つの 16 進数文字を整数部もしくは小"
"数部に含む必要があります。この制限は C99 規格のセクション 6.4.4.2 で規定され"
"ていて、 Java 1.5 以降でも使われています。特に、 :meth:`float.hex` の出力は "
"C や Java コード中で、浮動小数点数の 16 進表記として役に立つでしょう。また、 "
"C の ``%a`` 書式や、 Java の ``Double.toHexString`` で書きだされた文字列は :"
"meth:`float.fromhex` で受け付けられます。"

#: ../../library/stdtypes.rst:641
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"なお、指数部は 16 進数ではなく 10 進数で書かれ、係数に掛けられる 2 の累乗を与"
"えます。例えば、16 進文字列 ``0x3.a7p10`` は浮動小数点数 ``(3 + 10./16 + "
"7./16**2) * 2.0**10`` すなわち ``3740.0`` を表します::"

#: ../../library/stdtypes.rst:651
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"逆変換を ``3740.0`` に適用すると、同じ数を表す異なる 16 進文字列表現を返しま"
"す::"

#: ../../library/stdtypes.rst:661
msgid "Hashing of numeric types"
msgstr "数値型のハッシュ化"

#: ../../library/stdtypes.rst:663
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`~object."
"__hash__` method documentation for more details).  For ease of "
"implementation and efficiency across a variety of numeric types (including :"
"class:`int`, :class:`float`, :class:`decimal.Decimal` and :class:`fractions."
"Fraction`) Python's hash for numeric types is based on a single mathematical "
"function that's defined for any rational number, and hence applies to all "
"instances of :class:`int` and :class:`fractions.Fraction`, and all finite "
"instances of :class:`float` and :class:`decimal.Decimal`.  Essentially, this "
"function is given by reduction modulo ``P`` for a fixed prime ``P``.  The "
"value of ``P`` is made available to Python as the :attr:`modulus` attribute "
"of :data:`sys.hash_info`."
msgstr ""
"数 ``x`` と ``y`` に対して、型が異なっていたとしても、 ``x == y`` であれば必"
"ず ``hash(x) == hash(y)`` であることが要請されます (詳細は :meth:`~object."
"__hash__`  メソッドドキュメントを参照してください)。実装の簡単さと 複数の数値"
"型 (:class:`int` 、 :class:`float` 、 :class:`decimal.Decimal` 、 :class:"
"`fractions.Fraction` を含みます) 間の効率のため、Python の 数値型に対するハッ"
"シュ値はある単一の数学的関数に基づいていて、 その関数はすべての有理数に対し定"
"義されているため、 :class:`int` と :class:`fractions.Fraction` のすべてのイン"
"スタンスと、 :class:`float` と :class:`decimal.Decimal` のすべての有限なイン"
"スタンスに 対して適用されます。本質的には、この関数は定数の素数 ``P`` に対し"
"て ``P`` を法とする還元で与えられます。 値 ``P`` は、 :data:`sys.hash_info` "
"の :attr:`modulus` 属性として Python で利用できます。"

#: ../../library/stdtypes.rst:678
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"現在使われている素数は、32 bit C long のマシンでは ``P = 2**31 - 1`` 、 64-"
"bit C long のマシンでは ``P = 2**61 - 1`` です。"

#: ../../library/stdtypes.rst:681
msgid "Here are the rules in detail:"
msgstr "詳細な規則はこうです:"

#: ../../library/stdtypes.rst:683
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"``x = m / n`` が非負の有理数で、 ``n`` が ``P`` で割り切れないなら、 "
"``invmod(n, P)`` を ``n`` を ``P`` で割った剰余の (剰余演算の意味での) 逆数を"
"与えるものとして、 ``hash(x)`` を ``m * invmod(n, P) % P`` と定義します。"

#: ../../library/stdtypes.rst:687
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"``x = m / n`` が非負の有理数で、 ``n`` が ``P`` で割り切れる (が ``m`` は割り"
"切れない) なら、 ``n`` は ``P`` で割った余りの逆数を持たず、上の規則は適用で"
"きません。この場合、 ``hash(x)`` を定数 ``sys.hash_info.inf`` と定義します。"

#: ../../library/stdtypes.rst:692
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"``x = m / n`` が負の有理数なら、 ``hash(x)`` を ``-hash(-x)`` と定義します。"
"その結果のハッシュが ``-1`` なら、 ``-2`` に置き換えます。"

#: ../../library/stdtypes.rst:696
msgid ""
"The particular values ``sys.hash_info.inf`` and ``-sys.hash_info.inf`` are "
"used as hash values for positive infinity or negative infinity "
"(respectively)."
msgstr ""
"特定の値 ``sys.hash_info.inf`` 、 ``-sys.hash_info.inf`` は、正の無限大、負の"
"無限大のハッシュ値を (それぞれ) 表すのに使われます。"

#: ../../library/stdtypes.rst:700
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"複素 (:class:`complex`) 数 ``z`` に対して、実部と虚部のハッシュ値は、 "
"``hash(z.real) + sys.hash_info.imag * hash(z.imag)`` の ``2**sys.hash_info."
"width`` を法とする還元を計算することにより組み合わせられ、よってこれは "
"``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))`` に収ま"
"ります。再び、結果が ``-1`` なら、 ``-2`` で置き換えられます。"

#: ../../library/stdtypes.rst:708
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"上述の規則をわかりやすくするため、有理数 :class:`float` や、 :class:"
"`complex` のハッシュを計算する組み込みのハッシュと等価な Python コードの例を"
"挙げます::"

#: ../../library/stdtypes.rst:763
msgid "Iterator Types"
msgstr "イテレータ型"

#: ../../library/stdtypes.rst:771
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python はコンテナでの反復処理の概念をサポートしています。この概念は 2 つの"
"別々のメソッドを使って実装されています; これらのメソッドを使ってユーザ定義の"
"クラスで反復を行えるようにできます。後に詳しく述べるシーケンスは、必ず反復処"
"理メソッドをサポートしています。"

#: ../../library/stdtypes.rst:776
msgid ""
"One method needs to be defined for container objects to provide :term:"
"`iterable` support:"
msgstr ""
"コンテナオブジェクトが :term:`イテラブル <iterable>` のサポートを提供するため"
"には、一つのメソッドが定義されていなければなりません:"

#: ../../library/stdtypes.rst:783
msgid ""
"Return an :term:`iterator` object.  The object is required to support the "
"iterator protocol described below.  If a container supports different types "
"of iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
":term:`iterator` オブジェクトを返します。オブジェクトは後述するイテレータプロ"
"トコルをサポートする必要があります。もしコンテナが異なる種類の反復処理をサ"
"ポートするなら、それぞれの反復処理のためのイテレータを要求するメソッドをそれ"
"ぞれ提供しても構いません 。(複数の形式の反復処理を提供するオブジェクトの例と"
"して、幅優先探索と深さ優先探索をサポートする木構造が挙げられます。)このメソッ"
"ドは Python/C API での Python オブジェクトの型構造体の :c:member:"
"`~PyTypeObject.tp_iter` スロットに対応します。"

#: ../../library/stdtypes.rst:792
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"イテレータオブジェクト自体は以下の 2 つのメソッドをサポートする必要がありま"
"す。これらのメソッドは 2 つ合わせて :dfn:`iterator protocol`: (イテレータプロ"
"トコル) を成します:"

#: ../../library/stdtypes.rst:798
msgid ""
"Return the :term:`iterator` object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements.  This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
":term:`iterator` オブジェクト自体を返します。このメソッドはコンテナとイテレー"
"タの両方を :keyword:`for` および :keyword:`in` 文で使えるようにするために必要"
"です。このメソッドは Python/C API において Python オブジェクトを表す型構造体"
"の :c:member:`~PyTypeObject.tp_iter` スロットに対応します。"

#: ../../library/stdtypes.rst:807
msgid ""
"Return the next item from the :term:`iterator`.  If there are no further "
"items, raise the :exc:`StopIteration` exception.  This method corresponds to "
"the :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for "
"Python objects in the Python/C API."
msgstr ""
":term:`iterator` の次のアイテムを返します。もしそれ以上アイテムが無ければ :"
"exc:`StopIteration` 例外を送出します。 このメソッドは Python/C APIでのPython"
"オブジェクトの型構造体の :c:member:`~PyTypeObject.tp_iternext` スロットに対応"
"します。"

#: ../../library/stdtypes.rst:812
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Python では、いくつかのイテレータオブジェクトを定義して、一般のシーケンス型、"
"特殊なシーケンス型、辞書型、その他の特殊な形式に渡って反復をサポートしていま"
"す。特殊型は、イテレータプロトコルの実装以外では重要ではありません。"

#: ../../library/stdtypes.rst:817
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"イテレータの :meth:`~iterator.__next__` メソッドが一旦 :exc:`StopIteration` "
"を送出したなら、以降の呼び出しでも例外を送出し続けなければなりません。この特"
"性に従わない実装は壊れているとみなされます。"

#: ../../library/stdtypes.rst:825
msgid "Generator Types"
msgstr "ジェネレータ型"

#: ../../library/stdtypes.rst:827
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and :meth:"
"`~generator.__next__` methods. More information about generators can be "
"found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""
"Python における :term:`generator` (ジェネレータ) は、イテレータプロトコルを実"
"装する便利な方法を提供します。コンテナオブジェクトの :meth:`__iter__` メソッ"
"ドがジェネレータとして実装されていれば、そのメソッドは :meth:`__iter__` およ"
"び :meth:`~generator.__next__` メソッドを提供するイテレータオブジェクト (厳密"
"にはジェネレータオブジェクト) を自動的に返します。ジェネレータに関する詳細な"
"情報は、 :ref:`yield 式のドキュメント <yieldexpr>` にあります。"

#: ../../library/stdtypes.rst:839
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "シーケンス型 --- :class:`list`, :class:`tuple`, :class:`range`"

#: ../../library/stdtypes.rst:841
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"基本的なシーケンス型は 3 つあります: リスト、タプル、range オブジェクトで"
"す。:ref:`バイナリデータ <binaryseq>` や :ref:`テキスト文字列 <textseq>` を処"
"理するように仕立てられたシーケンス型は、セクションを割いて解説します。"

#: ../../library/stdtypes.rst:850
msgid "Common Sequence Operations"
msgstr "共通のシーケンス演算"

#: ../../library/stdtypes.rst:854
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"以下の表にある演算は、ほとんどのミュータブル、イミュータブル両方のシーケンス"
"でサポートされています。カスタムのシーケンス型にこれらの演算を完全に実装する"
"のが簡単になるように、 :class:`collections.abc.Sequence` ABC が提供されていま"
"す。"

#: ../../library/stdtypes.rst:859
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"以下のテーブルで、シーケンス演算を優先順位が低い順に挙げます。表内で、 *s* "
"と *t* は同じ型のシーケンス、 *n*、 *i*、 *j* 、 *k* は整数、*x* は *s* に課"
"された型と値の条件を満たす任意のオブジェクトです。"

#: ../../library/stdtypes.rst:864
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"``in`` および ``not in`` 演算の優先順位は比較演算と同じです。``+`` (結合) お"
"よび ``*`` (繰り返し)の優先順位は対応する数値演算と同じです。 [3]_"

#: ../../library/stdtypes.rst:885
msgid "``x in s``"
msgstr "``x in s``"

#: ../../library/stdtypes.rst:885
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "*s* のある要素が *x* と等しければ ``True`` , そうでなければ ``False``"

#: ../../library/stdtypes.rst:888
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../../library/stdtypes.rst:888
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "*s* のある要素が *x* と等しければ ``False``, そうでなければ ``True``"

#: ../../library/stdtypes.rst:891
msgid "``s + t``"
msgstr "``s + t``"

#: ../../library/stdtypes.rst:891
msgid "the concatenation of *s* and *t*"
msgstr "*s* と *t* の結合"

#: ../../library/stdtypes.rst:891
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../../library/stdtypes.rst:894
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` または ``n * s``"

#: ../../library/stdtypes.rst:894
msgid "equivalent to adding *s* to itself *n* times"
msgstr "*s* 自身を *n* 回足すのと同じ"

#: ../../library/stdtypes.rst:894
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../../library/stdtypes.rst:897
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../library/stdtypes.rst:897
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*s* の 0 から数えて *i* 番目の要素"

#: ../../library/stdtypes.rst:899
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../../library/stdtypes.rst:899
msgid "slice of *s* from *i* to *j*"
msgstr "*s* の *i* から *j* までのスライス"

#: ../../library/stdtypes.rst:899
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../../library/stdtypes.rst:901
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../../library/stdtypes.rst:901
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "*s* の *i* から *j* まで、 *k* 毎のスライス"

#: ../../library/stdtypes.rst:901
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../../library/stdtypes.rst:904
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../library/stdtypes.rst:904
msgid "length of *s*"
msgstr "*s* の長さ"

#: ../../library/stdtypes.rst:906
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../../library/stdtypes.rst:906
msgid "smallest item of *s*"
msgstr "*s* の最小の要素"

#: ../../library/stdtypes.rst:908
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../library/stdtypes.rst:908
msgid "largest item of *s*"
msgstr "*s* の最大の要素"

#: ../../library/stdtypes.rst:910
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../../library/stdtypes.rst:910
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""
"*s* 中で *x* が最初に出現するインデックス (インデックス *i* 以降からインデッ"
"クス *j* までの範囲)"

#: ../../library/stdtypes.rst:910 ../../library/stdtypes.rst:3557
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/stdtypes.rst:914
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../library/stdtypes.rst:914
msgid "total number of occurrences of *x* in *s*"
msgstr "*s* 中に *x* が出現する回数"

#: ../../library/stdtypes.rst:918
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"同じ型のシーケンスは比較もサポートしています。特に、タプルとリストは対応する"
"要素を比較することで辞書式順序で比較されます。つまり、等しいとされるために"
"は、すべての要素が等しく、両シーケンスの型も長さも等しくなければなりません。"
"(完全な詳細は言語リファレンスの :ref:`comparisons` を参照してください。)"

#: ../../library/stdtypes.rst:928
msgid ""
"Forward and reversed iterators over mutable sequences access values using an "
"index.  That index will continue to march forward (or backward) even if the "
"underlying sequence is mutated.  The iterator terminates only when an :exc:"
"`IndexError` or a :exc:`StopIteration` is encountered (or when the index "
"drops below zero)."
msgstr ""
"ミュータブルなシーケンスに対する前方および逆方向イテレータはインデックスを"
"使って要素にアクセスします。インデックスは、仮に参照するシーケンスが変化した"
"としても前方 (または後方) に進み続けます。イテレータは :exc:`IndexError` また"
"は :exc:`StopIteration` に出会った場合 (またはインデックスがゼロより小さく"
"なった場合) にのみ終了します。"

#: ../../library/stdtypes.rst:937
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"``in`` および ``not in`` 演算は、一般に単純な包含判定にのみ使われますが、(:"
"class:`str`, :class:`bytes`, :class:`bytearray` のような) 特殊なシーケンスで"
"は部分シーケンス判定にも使われます::"

#: ../../library/stdtypes.rst:946
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"``0`` 未満の値 *n* は ``0`` として扱われます (これは *s* と同じ型の空のシーケ"
"ンスを表します)。シーケンス *s* の要素はコピーされないので注意してください; "
"コピーではなく要素に対する参照カウントが増えます。これは Python に慣れていな"
"いプログラマをよく悩ませます。例えば以下のコードを考えます:"

#: ../../library/stdtypes.rst:958
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"ここで、``[[]]`` が空リストを含む 1 要素のリストなので、``[[]] * 3`` の 3 要"
"素はこの一つの空リスト (への参照) です。``lists`` のいずれかの要素を変更する"
"と、その一つのリストが変更されます。別々のリストのリストを作るにはこうしま"
"す::"

#: ../../library/stdtypes.rst:970
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr "別の説明が FAQ エントリ :ref:`faq-multidimensional-list` にあります。"

#: ../../library/stdtypes.rst:974
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"*i* または *j* が負の数の場合、インデックスはシーケンスの末端からの相対イン"
"デックスになります: ``len(s) + i`` または ``len(s) + j`` が代わりに使われま"
"す。\n"
"ただし ``-0`` はやはり ``0`` であることに注意してください。"

#: ../../library/stdtypes.rst:979
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"*s* の *i* から *j* へのスライスは ``i <= k < j`` となるようなインデックス "
"*k* を持つ要素からなるシーケンスとして定義されます。 *i* または *j* が "
"``len(s)`` よりも大きい場合、 ``len(s)`` を使います。 *i* が省略されるか "
"``None`` だった場合、 ``0`` を使います。 *j* が省略されるか ``None`` だった場"
"合、 ``len(s)`` を使います。 *i* が *j* 以上の場合、スライスは空のシーケンス"
"になります。"

#: ../../library/stdtypes.rst:986
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"*s* の「 *i* から *j* まででステップが *k* のスライス」は、インデックス ``x "
"= i + n*k`` （ただし n は ``0 <= n < (j-i)/k`` を満たす任意の整数）を持つ要素"
"からなるシーケンスとして定義されます。言い換えるとインデックスは ``i``, "
"``i+k``, ``i+2*k``, ``i+3*k`` と続き、 *j* に達したところでストップします (た"
"だし *j* は含みません)。 *k* が正の数である場合、 *i* または *j* が "
"``len(s)`` より大きければ ``len(s)`` を代わりに使用します。 *k* が負の数であ"
"る場合、 *i* または *j* が ``len(s) - 1`` より大きければ ``len(s) - 1`` を代"
"わりに使用します。 *i* または *j* を省略または ``None`` を指定すると、 \"端"
"\" (どちらの端かは *k* の符号に依存) の値を代わりに使用します。なお *k* はゼ"
"ロにできないので注意してください。また *k* に ``None`` を指定すると、 ``1`` "
"が指定されたものとして扱われます。"

#: ../../library/stdtypes.rst:997
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"イミュータブルなシーケンスの結合は、常に新しいオブジェクトを返します。これ"
"は、結合の繰り返しでシーケンスを構築する実行時間コストがシーケンスの長さの合"
"計の二次式になることを意味します。実行時間コストを線形にするには、代わりに以"
"下のいずれかにしてください:"

#: ../../library/stdtypes.rst:1002
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
":class:`str` オブジェクトを結合するには、リストを構築して最後に :meth:`str."
"join` を使うか、 :class:`io.StringIO` インスタンスに書き込んで完成してから値"
"を取得してください"

#: ../../library/stdtypes.rst:1006
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
":class:`bytes` オブジェクトを結合するなら、同様に :meth:`bytes.join` や :"
"class:`io.BytesIO` を使うか、 :class:`bytearray` オブジェクトでインプレースに"
"結合できます。 :class:`bytearray` オブジェクトはミュータブルで、効率のいい割"
"り当て超過機構を備えています"

#: ../../library/stdtypes.rst:1011
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
":class:`tuple` オブジェクトを結合するなら、代わりに :class:`list` を拡張して"
"ください"

#: ../../library/stdtypes.rst:1013
msgid "for other types, investigate the relevant class documentation"
msgstr "その他の型については、関連するクラスのドキュメントを調べてください"

#: ../../library/stdtypes.rst:1017
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"シーケンス型には、 (:class:`range` のように) 特殊なパターンに従う項目のシーケ"
"ンスのみをサポートするものがあり、それらはシーケンスの結合や繰り返しをサポー"
"トしません。"

#: ../../library/stdtypes.rst:1022
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only "
"without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"``index`` は *x* が *s* 中に見つからないとき :exc:`ValueError` を送出します。"
"追加の引数 *i* と *j* は、すべての実装がサポートしているわけではありません。"
"追加の引数を渡すのは、おおよそ ``s[i:j].index(x)`` を使うのと等価ですが、デー"
"タをコピーしなくて済むし、返されるのはスライスの最初ではなくシーケンスの最初"
"からの相対インデクスです。"

#: ../../library/stdtypes.rst:1033
msgid "Immutable Sequence Types"
msgstr "イミュータブルなシーケンス型"

#: ../../library/stdtypes.rst:1040
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""
"イミュータブルなシーケンス型が一般に実装している演算のうち、ミュータブルな"
"シーケンス型がサポートしていないのは、組み込みの :func:`hash` だけです。"

#: ../../library/stdtypes.rst:1044
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""
"このサポートにより、:class:`tuple` インスタンスのようなイミュータブルなシーケ"
"ンスは、 :class:`dict` のキーとして使え、 :class:`set` や :class:`frozenset` "
"インスタンスに保存できます。"

#: ../../library/stdtypes.rst:1048
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""
"ハッシュ不可能な値を含むイミュータブルなシーケンスをハッシュ化しようとする"
"と、 :exc:`TypeError` となります。"

#: ../../library/stdtypes.rst:1055
msgid "Mutable Sequence Types"
msgstr "ミュータブルなシーケンス型"

#: ../../library/stdtypes.rst:1062
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"以下のテーブルにある演算は、ほとんどのミュータブルなシーケンスでサポートされ"
"ています。カスタムのシーケンス型にこれらの演算を完全に実装するのが簡単になる"
"ように、 :class:`collections.abc.MutableSequence` ABC が提供されています。"

#: ../../library/stdtypes.rst:1066
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"このテーブルで、 *s* はミュータブルなシーケンス型のインスタンス、 *t* は任意"
"のイテラブルオブジェクト、 *x* は *s* に課された型と値の条件を満たす任意のオ"
"ブジェクト (例えば、 :class:`bytearray` は値の制限 ``0 <= x <= 255`` に合う整"
"数のみを受け付けます) です。"

#: ../../library/stdtypes.rst:1090
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../library/stdtypes.rst:1090
msgid "item *i* of *s* is replaced by *x*"
msgstr "*s* の要素 *i* を *x* と入れ替えます"

#: ../../library/stdtypes.rst:1093
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../library/stdtypes.rst:1093
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""
"*s* の *i* から *j* 番目までのスライスをイテラブル *t* の内容に入れ替えます"

#: ../../library/stdtypes.rst:1097
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../library/stdtypes.rst:1097
msgid "same as ``s[i:j] = []``"
msgstr "``s[i:j] = []`` と同じです"

#: ../../library/stdtypes.rst:1099
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../library/stdtypes.rst:1099
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "``s[i:j:k]`` の要素を *t* の要素と入れ替えます"

#: ../../library/stdtypes.rst:1102
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../library/stdtypes.rst:1102
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "リストから ``s[i:j:k]`` の要素を削除します"

#: ../../library/stdtypes.rst:1105
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../library/stdtypes.rst:1105
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr "*x* をシーケンスの最後に加えます (``s[len(s):len(s)] = [x]`` と同じ)"

#: ../../library/stdtypes.rst:1109
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../../library/stdtypes.rst:1109
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "*s* から全ての要素を取り除きます (``del s[:]`` と同じ)"

#: ../../library/stdtypes.rst:1112
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../../library/stdtypes.rst:1112
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "*s* の浅いコピーを作成します (``s[:]`` と同じ)"

#: ../../library/stdtypes.rst:1115
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` または ``s += t``"

#: ../../library/stdtypes.rst:1115
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr ""
"*s* を *t* の内容で拡張します (ほとんど ``s[len(s):len(s)] = t`` と同じ)"

#: ../../library/stdtypes.rst:1120
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../../library/stdtypes.rst:1120
msgid "updates *s* with its contents repeated *n* times"
msgstr "*s* をその内容を *n* 回繰り返したもので更新"

#: ../../library/stdtypes.rst:1123
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../library/stdtypes.rst:1123
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr ""
"*s* の *i* で与えられたインデックスに *x* を挿入します。 (``s[i:i] = [x]`` と"
"同じ)"

#: ../../library/stdtypes.rst:1127
msgid "``s.pop()`` or ``s.pop(i)``"
msgstr "``s.pop()`` または ``s.pop(i)`` "

#: ../../library/stdtypes.rst:1127
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "*s* から *i* 番目の要素を取り出し、また取り除きます"

#: ../../library/stdtypes.rst:1130
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/stdtypes.rst:1130
msgid "remove the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "*s* から ``s[i]`` が ``x`` が等価となる最初の要素を取り除きます"

#: ../../library/stdtypes.rst:1133
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../library/stdtypes.rst:1133
msgid "reverses the items of *s* in place"
msgstr "*s* をインプレースに逆転させます"

#: ../../library/stdtypes.rst:1141
msgid "*t* must have the same length as the slice it is replacing."
msgstr "*t* は置き換えるスライスと同じ長さでなければいけません。"

#: ../../library/stdtypes.rst:1144
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""
"オプションの引数 *i* は標準で ``-1`` なので、標準では最後の要素をリストから除"
"去して返します。"

#: ../../library/stdtypes.rst:1148
msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ""
":meth:`remove` は *s* に *x* が見つからなければ :exc:`ValueError` を送出しま"
"す。"

#: ../../library/stdtypes.rst:1151
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
":meth:`reverse` メソッドは、大きなシーケンスを反転するときの容量の節約のた"
"め、シーケンスをインプレースに変化させます。副作用としてこの演算が行われるこ"
"とをユーザに気づかせるために、これは反転したシーケンスを返しません。"

#: ../../library/stdtypes.rst:1156
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`). :meth:`!copy` is not part of the :class:"
"`collections.abc.MutableSequence` ABC, but most concrete mutable sequence "
"classes provide it."
msgstr ""
":meth:`clear` および :meth:`!copy` は、スライシング操作をサポートしないミュー"
"タブルなコンテナ (:class:`dict` や :class:`set` など) のインターフェースとの"
"一貫性のために含まれています。\n"
":meth:`!copy` は :class:`collections.abc.MutableSequence` ABC の一部ではあり"
"ませんが、ほとんどのミュータブルなシーケンスクラスが提供しています。"

#: ../../library/stdtypes.rst:1162
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr ":meth:`clear` および :meth:`!copy` メソッド。"

#: ../../library/stdtypes.rst:1166
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"値 *n* は整数であるか、:meth:`~object.__index__` を実装したオブジェクトで"
"す。 *n* の値がゼロまたは負数の場合、シーケンスをクリアします。:ref:"
"`typesseq-common` で ``s * n`` について説明したとおり、シーケンスの要素はコ"
"ピーされないので注意してください; コピーではなく要素に対する参照カウントが増"
"えます。"

#: ../../library/stdtypes.rst:1175
msgid "Lists"
msgstr "リスト型 (list)"

#: ../../library/stdtypes.rst:1179
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"リストはミュータブルなシーケンスで、一般的に同種の項目の集まりを格納するため"
"に使われます (厳密な類似の度合いはアプリケーションによって異なる場合がありま"
"す)。"

#: ../../library/stdtypes.rst:1185
msgid "Lists may be constructed in several ways:"
msgstr "リストの構成にはいくつかの方法があります:"

#: ../../library/stdtypes.rst:1187
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr "角括弧の対を使い、空のリストを表す: ``[]``"

#: ../../library/stdtypes.rst:1188
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr "角括弧を使い、項目をカンマで区切る: ``[a]``、``[a, b, c]``"

#: ../../library/stdtypes.rst:1189
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "リスト内包表記を使う: ``[x for x in iterable]``"

#: ../../library/stdtypes.rst:1190
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "型コンストラクタを使う: ``list()`` または ``list(iterable)``"

#: ../../library/stdtypes.rst:1192
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"コンストラクタは、 *iterable* の項目と同じ項目で同じ順のリストを構築します。 "
"*iterable* は、シーケンス、イテレートをサポートするコンテナ、またはイテレータ"
"オブジェクトです。 *iterable* が既にリストなら、 ``iterable[:]`` と同様にコ"
"ピーが作られて返されます。例えば、 ``list('abc')`` は ``['a', 'b', 'c']`` "
"を、 ``list( (1, 2, 3) )`` は ``[1, 2, 3]`` を返します。引数が与えられなけれ"
"ば、このコンストラクタは新しい空のリスト ``[]`` を作成します。"

#: ../../library/stdtypes.rst:1201
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""
"リストを作る方法は、他にも組み込み関数 :func:`sorted` などいろいろあります。"

#: ../../library/stdtypes.rst:1204
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"リストは :ref:`共通の <typesseq-common>` および :ref:`ミュータブルの "
"<typesseq-mutable>` シーケンス演算をすべて実装します。リストは、更に以下のメ"
"ソッドも提供します:"

#: ../../library/stdtypes.rst:1210
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"このメソッドは、項目間の ``<`` 比較のみを用いてリストをインプレースにソートし"
"ます。例外は抑制されません。比較演算がどこかで失敗したら、ソート演算自体が失"
"敗します (そしてリストは部分的に変更された状態で残されるでしょう)。"

#: ../../library/stdtypes.rst:1215
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` は、キーワードでしか渡せない 2 つの引数 (:ref:`キーワード専用引"
"数 <keyword-only_parameter>`) を受け付けます:"

#: ../../library/stdtypes.rst:1218
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key* は一引数をとる関数を指定し、リストのそれぞれの要素から比較キーを取り出"
"すのに使います (例えば、 ``key=str.lower``)。それぞれの項目に対応するキーは一"
"度計算され、ソート処理全体に使われます。デフォルトの値 ``None`` は、別のキー"
"値を計算せず、リストの値が直接ソートされることを意味します。"

#: ../../library/stdtypes.rst:1225
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
"2.x 形式の *cmp* 関数を *key* 関数に変換するために、:func:`functools."
"cmp_to_key` ユーティリティが利用できます。"

#: ../../library/stdtypes.rst:1228
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* は真偽値です。 ``True`` がセットされた場合、リストの要素は個々の比"
"較が反転したものとして並び替えられます。"

#: ../../library/stdtypes.rst:1231
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"このメソッドは、大きなシーケンスをソートするときの容量の節約のため、シーケン"
"スをインプレースに変化させます。副作用としてこの演算が行われることをユーザに"
"気づかせるために、これはソートしたシーケンスを返しません (新しいリストインス"
"タンスを明示的に要求するには :func:`sorted` を使ってください)。"

#: ../../library/stdtypes.rst:1236
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
":meth:`sort` メソッドは安定していることが保証されています。ソートは、等しい要"
"素の相対順序が変更されないことが保証されていれば、安定しています。これは複数"
"パスのソートを行なう (例えば部署でソートして、それから給与の等級でソートす"
"る) のに役立ちます。"

#: ../../library/stdtypes.rst:1241
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"ソートの例と簡単なチュートリアルは :ref:`sortinghowto` を参照して下さい。"

#: ../../library/stdtypes.rst:1245
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"リストがソートされている間、または変更しようとする試みの影響中、あるいは検査"
"中でさえ、リストは未定義です。Python の C 実装では、それらが続いている間、リ"
"ストは空として出力され、リストがソート中に変更されていることを検知できたら :"
"exc:`ValueError` を送出します。"

#: ../../library/stdtypes.rst:1254
msgid "Tuples"
msgstr "タプル型 (tuple)"

#: ../../library/stdtypes.rst:1258
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"タプルはイミュータブルなシーケンスで、一般的に異種のデータの集まり (組み込み"
"の :func:`enumerate` で作られた 2-タプルなど) を格納するために使われます。タ"
"プルはまた、同種のデータのイミュータブルなシーケンスが必要な場合 (:class:"
"`set` インスタンスや :class:`dict` インスタンスに保存できるようにするためな"
"ど) にも使われます。"

#: ../../library/stdtypes.rst:1266
msgid "Tuples may be constructed in a number of ways:"
msgstr "タプルの構成にはいくつかの方法があります:"

#: ../../library/stdtypes.rst:1268
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr "丸括弧の対を使い、空のタプルを表す: ``()``"

#: ../../library/stdtypes.rst:1269
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr "カンマを使い、単要素のタプルを表す: ``a,`` または ``(a,)``"

#: ../../library/stdtypes.rst:1270
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "項目をカンマで区切る: ``a, b, c`` または ``(a, b, c)``"

#: ../../library/stdtypes.rst:1271
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr ""
"組み込みの :func:`tuple` を使う: ``tuple()`` または ``tuple(iterable)``"

#: ../../library/stdtypes.rst:1273
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"コンストラクタは、 *iterable* の項目と同じ項目で同じ順のタプルを構築します。 "
"*iterable* は、シーケンス、イテレートをサポートするコンテナ、またはイテレータ"
"オブジェクトです。 *iterable* が既にタプルなら、そのまま返されます。例えば、 "
"``tuple('abc')`` は ``('a', 'b', 'c')`` を、 ``tuple( [1, 2, 3] )`` は ``(1, "
"2, 3)`` を返します。引数が与えられなければ、このコンストラクタは新しい空のタ"
"プル ``()`` を作成します。"

#: ../../library/stdtypes.rst:1281
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"なお、タプルを作るのはカンマであり、丸括弧ではありません。丸括弧は省略可能で"
"すが、空のタプルの場合や構文上の曖昧さを避けるのに必要な時は例外です。例え"
"ば、 ``f(a, b, c)`` は三引数の関数呼び出しですが、``f((a, b, c))`` は 3-タプ"
"ルを唯一の引数とする関数の呼び出しです。"

#: ../../library/stdtypes.rst:1287
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""
"タプルは :ref:`共通の <typesseq-common>` シーケンス演算をすべて実装します。"

#: ../../library/stdtypes.rst:1290
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"異種のデータの集まりで、インデックスによってアクセスするよりも名前によってア"
"クセスしたほうが明確になるものには、単純なタプルオブジェクトよりも :func:"
"`collections.namedtuple` が向いているかもしれません。"

#: ../../library/stdtypes.rst:1298
msgid "Ranges"
msgstr "range"

#: ../../library/stdtypes.rst:1302
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
":class:`range` 型は、数のイミュータブルなシーケンスを表し、一般に :keyword:"
"`for` ループにおいて特定の回数のループに使われます。"

#: ../../library/stdtypes.rst:1309
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the :meth:`~object.__index__` "
"special method).  If the *step* argument is omitted, it defaults to ``1``. "
"If the *start* argument is omitted, it defaults to ``0``. If *step* is "
"zero, :exc:`ValueError` is raised."
msgstr ""
"range コンストラクタの引数は整数 (組み込みの :class:`int` または :meth:"
"`~object.__index__` 特殊メソッドを実装するオブジェクト) でなければなりませ"
"ん。*step* 引数が省略された場合のデフォルト値は ``1`` です。*start* 引数が省"
"略された場合のデフォルト値は  ``0`` です。 *step* が 0 の場合、:exc:"
"`ValueError` が送出されます。"

#: ../../library/stdtypes.rst:1315
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"*step* が正の場合、range ``r`` の内容は式 ``r[i] = start + step*i`` で決定さ"
"れます。ここで、 ``i >= 0`` かつ ``r[i] < stop`` です。"

#: ../../library/stdtypes.rst:1319
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"*step* が負の場合も、range ``r`` の内容は式 ``r[i] = start + step*i`` で決定"
"されます。ただし、制約条件は ``i >= 0`` かつ ``r[i] > stop`` です。"

#: ../../library/stdtypes.rst:1323
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"``r[0]`` が値の制約を満たさない場合、range オブジェクトは空になります。range "
"は負のインデックスをサポートしますが、これらは正のインデックスにより決定され"
"るシーケンスの末尾からのインデックス指定として解釈されます。"

#: ../../library/stdtypes.rst:1328
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
"range は :data:`sys.maxsize` より大きい絶対値を含むことができますが、いくつか"
"の機能 (:func:`len` など) は :exc:`OverflowError` を送出することがあります。"

#: ../../library/stdtypes.rst:1332
msgid "Range examples::"
msgstr "range の例::"

#: ../../library/stdtypes.rst:1349
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"range は :ref:`共通の <typesseq-common>` シーケンス演算を、結合と繰り返し以外"
"すべて実装します (range オブジェクトは厳格なパターンに従うシーケンスのみを表"
"せ、繰り返しと結合はたいていそのパターンを破るという事実によります)。"

#: ../../library/stdtypes.rst:1356
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr "引数 *start* の値 (この引数が与えられていない場合は ``0``)"

#: ../../library/stdtypes.rst:1361
msgid "The value of the *stop* parameter"
msgstr "引数 *stop* の値"

#: ../../library/stdtypes.rst:1365
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr "引数 *step* の値 (この引数が与えられていない場合は ``1``)"

#: ../../library/stdtypes.rst:1368
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
":class:`range` 型が通常の :class:`list` や :class:`tuple` にまさる点は、:"
"class:`range` オブジェクトがサイズや表す範囲にかかわらず常に一定の (小さな) "
"量のメモリを使うことです (``start``、``stop``、``step`` の値のみを保存し、後"
"は必要に応じて個々の項目や部分 range を計算するためです)。"

#: ../../library/stdtypes.rst:1374
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"range オブジェクトは :class:`collections.abc.Sequence` ABC を実装し、包含判"
"定、要素インデックス検索、スライシングのような機能を提供し、負のインデックス"
"をサポートします (:ref:`typesseq` を参照):"

#: ../../library/stdtypes.rst:1394
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"``==`` および ``!=`` による range オブジェクトの等価性の判定は、これらをシー"
"ケンスとして比較します。つまり、二つの range オブジェクトは同じ値のシーケンス"
"を表すなら等しいとみなされます。(なお、二つの等しいとされる range オブジェク"
"トが異なる  :attr:`~range.start`, :attr:`~range.stop` および :attr:`~range."
"step` 属性を持つことがあります。例えば ``range(0) == range(2, 1, 3)`` や "
"``range(0, 3, 2) == range(0, 4, 2)``。)"

#: ../../library/stdtypes.rst:1401
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"シーケンス ABC を実装。スライスと負のインデックスのサポート。:class:`int` オ"
"ブジェクトの帰属判定を、すべてのアイテムをイテレートする代わりに、定数時間で"
"行います。"

#: ../../library/stdtypes.rst:1407
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"(オブジェクトの同一性に基づいて比較する代わりに) range オブジェクトをそれらが"
"定義する値のシーケンスに基づいて比較するように '==' と '!=' を定義しました。"

#: ../../library/stdtypes.rst:1412
msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""
"属性 :attr:`~range.start`, :attr:`~range.stop` および :attr:`~range.step`。"

#: ../../library/stdtypes.rst:1418
msgid ""
"The `linspace recipe <https://code.activestate.com/recipes/579000/>`_ shows "
"how to implement a lazy version of range suitable for floating point "
"applications."
msgstr ""
"`linspace レシピ <https://code.activestate.com/recipes/579000/>`_ には、遅延"
"評価される浮動小数点版の range の実装方法が載っています。"

#: ../../library/stdtypes.rst:1430
msgid "Text Sequence Type --- :class:`str`"
msgstr "テキストシーケンス型 --- :class:`str`"

#: ../../library/stdtypes.rst:1432
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"Python のテキストデータは :class:`str` オブジェクト、すなわち :dfn:`文字列` "
"として扱われます。文字列は Unicode コードポイントのイミュータブルな :ref:`"
"シーケンス <typesseq>` です。文字列リテラルには様々な記述方法があります:"

#: ../../library/stdtypes.rst:1437
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "シングルクォート: ``'\"ダブル\" クォートを埋め込むことができます'``"

#: ../../library/stdtypes.rst:1438
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``"
msgstr "ダブルクォート: ``\"'シングル' クォートを埋め込むことができます\"``。"

#: ../../library/stdtypes.rst:1439
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"
msgstr ""
"三重引用符: ``'''三つのシングルクォート'''``, ``\"\"\"三つのダブルクォート"
"\"\"\"``"

#: ../../library/stdtypes.rst:1441
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""
"三重引用符文字列は、複数行に分けることができます。関連付けられる空白はすべて"
"文字列リテラルに含まれます。"

#: ../../library/stdtypes.rst:1444
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"単式の一部であり間に空白のみを含む文字列リテラルは、一つの文字列リテラルに暗"
"黙に変換されます。つまり、``(\"spam \" \"eggs\") == \"spam eggs\"`` です。"

#: ../../library/stdtypes.rst:1448
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported escape sequences, and the ``r`` (\"raw\") prefix that "
"disables most escape sequence processing."
msgstr ""
"エスケープシーケンスを含む文字列や、ほとんどのエスケープシーケンス処理を無効"
"にする ``r`` (\"raw\") 接頭辞などの、文字列リテラルの様々な形式は、:ref:"
"`strings` を参照してください。"

#: ../../library/stdtypes.rst:1452
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"文字列は他のオブジェクトに :class:`str` コンストラクタを使うことでも生成でき"
"ます。"

#: ../../library/stdtypes.rst:1455
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"\"character\" 型が特別に用意されているわけではないので、文字列のインデックス"
"指定を行うと長さ 1 の文字列を作成します。つまり、空でない文字列 *s* に対し、"
"``s[0] == s[0:1]`` です。"

#: ../../library/stdtypes.rst:1461
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""
"ミュータブルな文字列型もありませんが、ミュータブルな断片から効率よく文字列を"
"構成するのに :meth:`str.join` や :class:`io.StringIO` が使えます。"

#: ../../library/stdtypes.rst:1465
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Python 2 シリーズとの後方互換性のため、文字列リテラルの ``u`` 接頭辞が改めて"
"許可されました。それは文字列リテラルとしての意味には影響がなく、 ``r`` 接頭辞"
"と結合することはできません。"

#: ../../library/stdtypes.rst:1477
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"*object* の :ref:`文字列 <textseq>` 版を返します。 *object* が与えられなかっ"
"た場合、空文字列が返されます。それ以外の場合 ``str()`` の動作は、 *encoding* "
"や *errors* が与えられたかどうかによって次のように変わります。"

#: ../../library/stdtypes.rst:1481
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`type(object).__str__(object) <object.__str__>`, which is the \"informal\" "
"or nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a :meth:`~object."
"__str__` method, then :func:`str` falls back to returning :meth:"
"`repr(object) <repr>`."
msgstr ""
"*encoding* も *errors* も与えられない場合、 ``str(object)`` は :meth:"
"`type(object).__str__(object) <object.__str__>` の結果を返します。これは \"略"
"式の\" つまり読み易い *object* の文字列表現です。文字列オブジェクトに対しては"
"その文字列自体を返します。 *object* が :meth:`~object.__str__` メソッドを持た"
"ない場合、:func:`str` は代わりに :meth:`repr(object) <repr>` の結果を返しま"
"す。"

#: ../../library/stdtypes.rst:1493
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"*encoding* か *errors* の少なくとも一方が与えられた場合、 *object* は :term:"
"`bytes-like object` (たとえば :class:`bytes` や :class:`bytearray`) でなくて"
"はなりません。*object* が :class:`bytes` (もしくは :class:`bytearray`) オブ"
"ジェクトである場合は、 ``str(bytes, encoding, errors)`` は :meth:`bytes."
"decode(encoding, errors) <bytes.decode>` と等価です。そうでない場合は、 :"
"meth:`bytes.decode` が呼ばれる前に buffer オブジェクトの下層にある bytes オブ"
"ジェクトが取得されます。 buffer オブジェクトについて詳しい情報は、 :ref:"
"`binaryseq` や :ref:`bufferobjects` を参照してください。"

#: ../../library/stdtypes.rst:1502
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"*encoding* 引数や *errors* 引数無しに :class:`bytes` オブジェクトを :func:"
"`str` に渡すと、略式の文字列表現を返す 1 つ目の場合に該当します。(Python のコ"
"マンドラインオプション :option:`-b` も参照してください) 例えば::"

#: ../../library/stdtypes.rst:1510
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"``str`` クラスとそのメソッドについて詳しくは、 :ref:`テキストシーケンス型 — "
"str <textseq>` や :ref:`string-methods` の節を参照してください。フォーマット"
"された文字列を出力するには、 :ref:`f-strings` と :ref:`string-formatting` の"
"節を参照してください。加えて、 :ref:`stringservices` の節も参照してください。"

#: ../../library/stdtypes.rst:1522
msgid "String Methods"
msgstr "文字列メソッド"

#: ../../library/stdtypes.rst:1527
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"文字列は :ref:`共通の <typesseq-common>` シーケンス演算全てに加え、以下に述べ"
"るメソッドを実装します。"

#: ../../library/stdtypes.rst:1530
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"文字列は、二形式の文字列書式化をサポートします。一方は柔軟さが高くカスタマイ"
"ズできます (:meth:`str.format`、 :ref:`formatstrings` 、および :ref:`string-"
"formatting` を参照してください)。他方は C 言語の ``printf`` 形式の書式化に基"
"づいてより狭い範囲と型を扱うもので、正しく扱うのは少し難しいですが、扱える場"
"合ではたいていこちらのほうが高速です (:ref:`old-string-formatting`)。"

#: ../../library/stdtypes.rst:1537
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"標準ライブラリの :ref:`textservices` 節は、その他テキストに関する様々なユー"
"ティリティ (:mod:`re` モジュールによる正規表現サポートなど) を提供するいくつ"
"かのモジュールをカバーしています。"

#: ../../library/stdtypes.rst:1543
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr "最初の文字を大文字にし、残りを小文字にした文字列のコピーを返します。"

#: ../../library/stdtypes.rst:1546
msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr ""
"最初の文字が大文字ではなくタイトルケースに置き換えられるようになりました。つ"
"まり二重音字のような文字はすべての文字が大文字にされるのではなく、最初の文字"
"だけ大文字にされるようになります。"

#: ../../library/stdtypes.rst:1553
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"文字列の casefold されたコピーを返します。casefold された文字列は、大文字小文"
"字に関係ないマッチに使えます。"

#: ../../library/stdtypes.rst:1556
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"casefold は、小文字化と似ていますが、より積極的です。これは文字列の大文字小文"
"字の区別をすべて取り去ることを意図しているためです。例えば、ドイツ語の小文字 "
"``'ß'`` は ``\"ss\"`` と同じです。これは既に小文字なので、:meth:`lower` は "
"``'ß'`` に何もしませんが、:meth:`casefold` はこれを ``\"ss\"`` に変換します。"

#: ../../library/stdtypes.rst:1562
msgid ""
"The casefolding algorithm is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"casefold のアルゴリズムは Unicode Standard のセクション 3.13 に記述されていま"
"す。"

#: ../../library/stdtypes.rst:1570
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"*width* の長さをもつ中央寄せされた文字列を返します。パディングには "
"*fillchar* で指定された値 (デフォルトでは ASCII スペース) が使われます。 "
"*width* が ``len(s)`` 以下なら元の文字列が返されます。"

#: ../../library/stdtypes.rst:1578
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"[*start*, *end*] の範囲に、部分文字列 *sub* が重複せず出現する回数を返しま"
"す。オプション引数 *start* および *end* はスライス表記と同じように解釈されま"
"す。"

#: ../../library/stdtypes.rst:1582
msgid ""
"If *sub* is empty, returns the number of empty strings between characters "
"which is the length of the string plus one."
msgstr ""
"*sub* が空の場合は、文字と文字の間にある空文字列の数、すなわち文字列の長さに1"
"を加えたものを返します。"

#: ../../library/stdtypes.rst:1588
msgid "Return the string encoded to :class:`bytes`."
msgstr ":class:`bytes` にエンコードされた文字列を返します。"

#: ../../library/stdtypes.rst:1590 ../../library/stdtypes.rst:2723
msgid ""
"*encoding* defaults to ``'utf-8'``; see :ref:`standard-encodings` for "
"possible values."
msgstr ""
"*encoding* のデフォルト値は ``'utf-8'`` です; 指定可能な値については :ref:"
"`standard-encodings` を参照してください。"

#: ../../library/stdtypes.rst:1593
msgid ""
"*errors* controls how encoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` and any other name registered via :func:`codecs."
"register_error`. See :ref:`error-handlers` for details."
msgstr ""
"*errors* はエンコーディングエラーをどのように取り扱うかを制御します。 "
"``'strict'`` (デフォルト) では :exc:`UnicodeError` 例外が送出されます。そのほ"
"かに指定可能な値は ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` と、そして :func:`codecs.register_error` で登録された"
"名前です。詳しくは :ref:`error-handlers` を参照してください。"

#: ../../library/stdtypes.rst:1600
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless an encoding error actually occurs, :ref:`devmode` is enabled or a :"
"ref:`debug build <debug-build>` is used."
msgstr ""
"パフォーマンス上の理由から、 *errors* の値の妥当性は、エンコーディングエラー"
"が実際に発生するか、 :ref:`devmode` が有効になっているか、もしくは :ref:`デ"
"バッグビルド <debug-build>` が使われていない限りチェックされません。"

#: ../../library/stdtypes.rst:1605 ../../library/stdtypes.rst:2742
msgid "Added support for keyword arguments."
msgstr "キーワード引数のサポートが追加されました。"

#: ../../library/stdtypes.rst:1608 ../../library/stdtypes.rst:2745
msgid ""
"The value of the *errors* argument is now checked in :ref:`devmode` and in :"
"ref:`debug mode <debug-build>`."
msgstr ""
"*errors* 引数の値は :ref:`devmode` と :ref:`デバッグモード <debug-build>` で"
"チェックされるようになりました。"

#: ../../library/stdtypes.rst:1615
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"文字列が指定された *suffix* で終わるなら ``True`` を、そうでなければ "
"``False`` を返します。 *suffix* は見つけたい複数の接尾語のタプルでも構いませ"
"ん。オプションの *start* があれば、その位置から判定を始めます。オプションの "
"*end* があれば、その位置で比較を止めます。"

#: ../../library/stdtypes.rst:1623
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline "
"(``\\n``) or return (``\\r``), it is copied and the current column is reset "
"to zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""
"文字列内の全てのタブ文字が 1 つ以上のスペースで置換された、文字列のコピーを返"
"します。スペースの数は現在の桁 (column) 位置と *tabsize* に依存します。タブ位"
"置は *tabsize* 文字毎に存在します (デフォルト値である 8 の場合、タブ位置は "
"0, 8, 16 などになります)。文字列を展開するため、まず現桁位置がゼロにセットさ"
"れ、文字列が 1 文字ずつ調べられます。文字がタブ文字 (``\\t``) であれば、現桁"
"位置が次のタブ位置と一致するまで、1 つ以上のスペースが結果の文字列に挿入され"
"ます。(タブ文字自体はコピーされません。) 文字が改行文字 (``\\n`` もしくは "
"``\\r``) の場合、文字がコピーされ、現桁位置は 0 にリセットされます。その他の"
"文字は変更されずにコピーされ、現桁位置は、その文字の表示のされ方 (訳注: 全"
"角、半角など) に関係なく、1 ずつ増加します。"

#: ../../library/stdtypes.rst:1644
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"文字列のスライス ``s[start:end]`` に部分文字列 *sub* が含まれる場合、その最小"
"のインデックスを返します。オプション引数 *start* および *end* はスライス表記"
"と同様に解釈されます。 *sub* が見つからなかった場合 ``-1`` を返します。"

#: ../../library/stdtypes.rst:1650
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
":meth:`~str.find` メソッドは、 *sub* の位置を知りたいときにのみ使うべきで"
"す。 *sub* が部分文字列であるかどうかのみを調べるには、 :keyword:`in` 演算子"
"を使ってください::"

#: ../../library/stdtypes.rst:1660
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"文字列の書式化操作を行います。このメソッドを呼び出す文字列は通常の文字、また"
"は、 ``{}`` で区切られた置換フィールドを含みます。それぞれの置換フィールドは"
"位置引数のインデックスナンバー、または、キーワード引数の名前を含みます。返り"
"値は、それぞれの置換フィールドが対応する引数の文字列値で置換された文字列のコ"
"ピーです。"

#: ../../library/stdtypes.rst:1670
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"書式指定のオプションについては、書式指定文字列を規定する :ref:"
"`formatstrings` を参照してください。"

#: ../../library/stdtypes.rst:1674
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""
"数値 (:class:`int`, :class:`float`, :class:`complex`, :class:`decimal."
"Decimal` とサブクラス) を ``n`` の整数表現型 (例: ``'{:n}'.format(1234)``) で"
"フォーマットするとき、``LC_CTYPE`` ロケールと ``LC_NUMERIC`` ロケールの一方ま"
"たは両方が 1 バイトより長い非 ASCII 文字であると同時に異なる値である場合、こ"
"の関数は :c:func:`localeconv` の ``decimal_point`` と ``thousands_sep`` "
"フィールドを読み取るため一時的に ``LC_CTYPE`` ロケールに ``LC_NUMERIC`` のロ"
"ケール値を設定します。この一時的な変更は他のスレッドの動作に影響します。"

#: ../../library/stdtypes.rst:1683
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"数値を ``n`` の整数表現型でフォーマットするとき、この関数は一時的に "
"``LC_CTYPE`` ロケールに ``LC_NUMERIC`` のロケール値を設定する場合があります。"

#: ../../library/stdtypes.rst:1691
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"``str.format(**mapping)`` と似ていますが、 ``mapping`` は :class:`dict`  にコ"
"ピーされず、直接使われます。これは例えば ``mapping`` が dict のサブクラスであ"
"るときに便利です:"

#: ../../library/stdtypes.rst:1707
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""
":meth:`~str.find` と同様ですが、部分文字列が見つからなかったとき :exc:"
"`ValueError` を送出します。"

#: ../../library/stdtypes.rst:1713
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"文字列中の全ての文字が英数字で、かつ 1 文字以上あるなら ``True`` を、そうでな"
"ければ ``False`` を返します。文字 ``c`` は以下のいずれかが ``True`` を返せば"
"英数字です: ``c.isalpha()`` 、 ``c.isdecimal()`` 、 ``c.isdigit()`` 、 ``c."
"isnumeric()`` 。"

#: ../../library/stdtypes.rst:1721
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", i."
"e., those with general category property being one of \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", or \"Lo\".  Note that this is different from the "
"\"Alphabetic\" property defined in the Unicode Standard."
msgstr ""
"文字列中の全ての文字が英字で、かつ 1 文字以上あるなら ``True`` を、そうでなけ"
"れば ``False`` を返します。英字は、Unicode 文字データベースで \"Letter\" とし"
"て定義されているもので、すなわち、一般カテゴリプロパティ \"Lm\"、 \"Lt\"、 "
"\"Lu\"、 \"Ll\"、 \"Lo\" のいずれかをもつものです。なお、これは Unicode 標準"
"で定義されている \"Alphabetic\" プロパティとは異なるものです。"

#: ../../library/stdtypes.rst:1730
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""
"文字列が空であるか、文字列の全ての文字が ASCII である場合に ``True`` を、それ"
"以外の場合に ``False`` を返します。\n"
"ASCII 文字のコードポイントは U+0000-U+007F の範囲にあります。"

#: ../../library/stdtypes.rst:1739
msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO.  Formally a decimal character is a character in the Unicode "
"General Category \"Nd\"."
msgstr ""
"文字列中の全ての文字が十進数字で、かつ 1 文字以上あるなら ``True`` を、そうで"
"なければ ``False`` を返します。十進数字とは十進数を書くのに使われる文字のこと"
"で、たとえば U+0660 (ARABIC-INDIC DIGIT ZERO) なども含みます。正式には、"
"Unicode の一般カテゴリ \"Nd\" に含まれる文字を指します。"

#: ../../library/stdtypes.rst:1749
msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"文字列中の全ての文字が数字で、かつ 1 文字以上あるなら ``True`` を、そうでなけ"
"れば ``False`` を返します。ここでの数字とは、十進数字に加えて、互換上付き数字"
"のような特殊操作を必要とする数字を含みます。また 10 を基数とした表現ができな"
"いカローシュティー数字のような体系の文字も含みます。正式には、数字とは、プロ"
"パティ値 Numeric_Type=Digit または Numeric_Type=Decimal を持つ文字です。"

#: ../../library/stdtypes.rst:1759
msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr ""
"文字列が、 :ref:`identifiers` 節の言語定義における有効な識別子であれば "
"``True`` を返します。"

#: ../../library/stdtypes.rst:1762
msgid ""
"Call :func:`keyword.iskeyword` to test whether string ``s`` is a reserved "
"identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""
"文字列 ``s`` が :keyword:`def` や :keyword:`class` のような予約済みの識別子か"
"判定するには :func:`keyword.iskeyword` を呼び出してください。"

#: ../../library/stdtypes.rst:1765
msgid "Example: ::"
msgstr "例: ::"

#: ../../library/stdtypes.rst:1778
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"文字列中の大小文字の区別のある文字 [4]_ 全てが小文字で、かつ大小文字の区別の"
"ある文字が 1 文字以上あるなら ``True`` を、そうでなければ ``False`` を返しま"
"す。"

#: ../../library/stdtypes.rst:1784
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"文字列中の全ての文字が数を表す文字で、かつ 1 文字以上あるなら ``True`` を、そ"
"うでなければ ``False`` を返します。数を表す文字は、数字と、Unicode の数値プロ"
"パティを持つ全ての文字を含みます。たとえば  U+2155 (VULGAR FRACTION ONE "
"FIFTH)。正式には、数を表す文字は、プロパティ値 Numeric_Type=Digit、 "
"Numeric_Type=Decimal または Numeric_Type=Numeric を持つものです。"

#: ../../library/stdtypes.rst:1794
msgid ""
"Return ``True`` if all characters in the string are printable or the string "
"is empty, ``False`` otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling "
"of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"文字列中のすべての文字が印字可能であるか、文字列が空であれば ``True`` を、そ"
"うでなければ ``False`` を返します。非印字可能文字は、 Unicode 文字データベー"
"スで \"Other\" または \"Separator\" と定義されている文字の、印字可能と見なさ"
"れる ASCII space (0x20) 以外のものです。(なお、この文脈での印字可能文字は、文"
"字列に :func:`repr` が呼び出されるときにエスケープすべきでない文字のことで"
"す。これは :data:`sys.stdout` や :data:`sys.stderr` に書き込まれる文字列の操"
"作とは関係ありません。)"

#: ../../library/stdtypes.rst:1805
msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr ""
"文字列が空白文字だけからなり、かつ 1 文字以上ある場合には ``True`` を返し、そ"
"うでない場合は ``False`` を返します。"

#: ../../library/stdtypes.rst:1808
msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, "
"space\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""
"Unicode 文字データベース (:mod:`unicodedata` を参照) で一般カテゴリが ``Zs`` "
"(\"Seperator, space\") であるか、 双方向クラスが　``WS``、``B``、 ``S`` のい"
"ずれかである場合、その文字は *空白文字(whitespace)* です。 "

#: ../../library/stdtypes.rst:1816
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""
"文字列がタイトルケース文字列であり、かつ 1 文字以上ある場合、例えば大文字は大"
"小文字の区別のない文字の後にのみ続き、小文字は大小文字の区別のある文字の後ろ"
"にのみ続く場合には ``True`` を返します。そうでない場合は ``False`` を返しま"
"す。"

#: ../../library/stdtypes.rst:1823
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"文字列中の大小文字の区別のある文字 [4]_ 全てが大文字で、かつ大小文字の区別の"
"ある文字が 1 文字以上あるなら ``True`` を、そうでなければ ``False`` を返しま"
"す。"

#: ../../library/stdtypes.rst:1839
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"*iterable* 中の文字列を結合した文字列を返します。 *iterable* に :class:"
"`bytes` オブジェクトのような非文字列の値が存在するなら、 :exc:`TypeError` が"
"送出されます。要素間のセパレータは、このメソッドを提供する文字列です。"

#: ../../library/stdtypes.rst:1847
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"長さ *width* の左揃えした文字列を返します。パディングは指定された *fillchar* "
"(デフォルトでは ASCII スペース) を使って行われます。 *width* が ``len(s)`` 以"
"下ならば、元の文字列が返されます。"

#: ../../library/stdtypes.rst:1854
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"全ての大小文字の区別のある文字 [4]_ が小文字に変換された、文字列のコピーを返"
"します。"

#: ../../library/stdtypes.rst:1857
msgid ""
"The lowercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"使われる小文字化のアルゴリズムは Unicode Standard のセクション 3.13 に記述さ"
"れています。"

#: ../../library/stdtypes.rst:1863
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"文字列の先頭の文字を除去したコピーを返します。引数 *chars* は除去される文字の"
"集合を指定する文字列です。 *chars* が省略されるか ``None`` の場合、空白文字が"
"除去されます。 *chars* 文字列は接頭辞ではなく、その値に含まれる文字の組み合わ"
"せ全てがはぎ取られます::"

#: ../../library/stdtypes.rst:1873
msgid ""
"See :meth:`str.removeprefix` for a method that will remove a single prefix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"文字の集合全てではなく、指定した文字列そのものを接頭辞として削除するメソッド"
"については、 :meth:`str.removeprefix` を参照してください。使用例::"

#: ../../library/stdtypes.rst:1884
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""
"この静的メソッドは :meth:`str.translate` に使える変換テーブルを返します。"

#: ../../library/stdtypes.rst:1886
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"引数を 1 つだけ与える場合、それは Unicode 序数 (整数) または文字  (長さ 1 の"
"文字列) を、Unicode 序数、(任意長の) 文字列、または ``None`` に対応づける辞書"
"でなければなりません。このとき、文字で指定したキーは序数に変換されます。"

#: ../../library/stdtypes.rst:1891
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""
"引数を 2 つ指定する場合、それらは同じ長さの文字列である必要があり、結果の辞書"
"では、x のそれぞれの文字が y の同じ位置の文字に対応付けられます。第 3 引数を"
"指定する場合、文字列を指定する必要があり、それに含まれる文字が ``None`` に対"
"応付けられます。"

#: ../../library/stdtypes.rst:1899
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"文字列を *sep* の最初の出現位置で区切り、 3 要素のタプルを返します。タプルの"
"内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分で"
"す。もし区切れなければ、タプルには元の文字列そのものとその後ろに二つの空文字"
"列が入ります。"

#: ../../library/stdtypes.rst:1907
msgid ""
"If the string starts with the *prefix* string, return "
"``string[len(prefix):]``. Otherwise, return a copy of the original string::"
msgstr ""
"文字列が *prefix* で始まる場合、  ``string[len(prefix):]`` を返します。それ以"
"外の場合、元の文字列のコピーを返します::"

#: ../../library/stdtypes.rst:1921
msgid ""
"If the string ends with the *suffix* string and that *suffix* is not empty, "
"return ``string[:-len(suffix)]``. Otherwise, return a copy of the original "
"string::"
msgstr ""
"文字列が *suffix* で終わる場合、 ``string[:-len(suffix)]`` を返します。それ以"
"外の場合、元の文字列のコピーを返します::"

#: ../../library/stdtypes.rst:1935
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""
"文字列をコピーし、現れる部分文字列 *old* 全てを *new* に置換して返します。オ"
"プション引数 *count* が与えられている場合、先頭から *count* 個の *old* だけを"
"置換します。"

#: ../../library/stdtypes.rst:1942
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"文字列中の領域 ``s[start:end]`` に *sub* が含まれる場合、その最大のインデック"
"スを返します。オプション引数 *start* および *end* はスライス表記と同様に解釈"
"されます。 *sub* が見つからなかった場合 ``-1``  を返します。"

#: ../../library/stdtypes.rst:1949
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
":meth:`rfind` と同様ですが、 *sub* が見つからなかった場合 :exc:`ValueError` "
"を送出します。"

#: ../../library/stdtypes.rst:1955
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"*width* の長さをもつ右寄せした文字列を返します。パディングには *fillchar* で"
"指定された文字(デフォルトでは ASCII スペース)が使われます。 *width* が "
"``len(s)`` 以下の場合、元の文字列が返されます。"

#: ../../library/stdtypes.rst:1962
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"文字列を *sep* の最後の出現位置で区切り、 3 要素のタプルを返します。タプルの"
"内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分で"
"す。もし区切れなければ、タプルには二つの空文字列とその後ろに元の文字列そのも"
"のが入ります。"

#: ../../library/stdtypes.rst:1970
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"*sep* を区切り文字とした、文字列中の単語のリストを返します。 *maxsplit* が与"
"えられた場合、文字列の *右端* から最大 *maxsplit* 回分割を行います。*sep* が"
"指定されていない、あるいは ``None`` のとき、全ての空白文字が区切り文字となり"
"ます。右から分割していくことを除けば、 :meth:`rsplit` は後ほど詳しく述べる :"
"meth:`split` と同様に振る舞います。"

#: ../../library/stdtypes.rst:1979
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"文字列の末尾部分を除去したコピーを返します。引数 *chars* は除去される文字集合"
"を指定する文字列です。 *chars* が省略されるか ``None`` の場合、空白文字が除去"
"されます。 *chars* 文字列は接尾語ではなく、そこに含まれる文字の組み合わせ全て"
"がはぎ取られます::"

#: ../../library/stdtypes.rst:1989
msgid ""
"See :meth:`str.removesuffix` for a method that will remove a single suffix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"文字の集合全てではなく、指定した文字列そのものを接尾辞として削除するメソッド"
"については :meth:`str.removesuffix` を参照してください。使用例::"

#: ../../library/stdtypes.rst:1999
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"文字列を *sep* をデリミタ文字列として区切った単語のリストを返します。"
"*maxsplit* が与えられていれば、最大で *maxsplit* 回分割されます (つまり、リス"
"トは最大 ``maxsplit+1`` 要素になります)。 *maxsplit* が与えられないか ``-1`` "
"なら、分割の回数に制限はありません (可能なだけ分割されます)。"

#: ../../library/stdtypes.rst:2005
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""
"*sep* が与えられた場合、連続した区切り文字はまとめられず、空の文字列を区切っ"
"ていると判断されます(例えば ``'1,,2'.split(',')`` は ``['1', '', '2']`` を返"
"します)。引数 *sep* は複数の文字にもできます (例えば ``'1<>2<>3'."
"split('<>')`` は ``['1', '2', '3']`` を返します)。区切り文字を指定して空の文"
"字列を分割すると、 ``['']`` を返します。"

#: ../../library/stdtypes.rst:2011 ../../library/stdtypes.rst:2027
#: ../../library/stdtypes.rst:2079 ../../library/stdtypes.rst:2147
#: ../../library/stdtypes.rst:2214 ../../library/stdtypes.rst:3061
#: ../../library/stdtypes.rst:3077 ../../library/stdtypes.rst:3168
#: ../../library/stdtypes.rst:3184 ../../library/stdtypes.rst:3209
#: ../../library/stdtypes.rst:3223 ../../library/stdtypes.rst:3251
#: ../../library/stdtypes.rst:3265 ../../library/stdtypes.rst:3283
#: ../../library/stdtypes.rst:3310 ../../library/stdtypes.rst:3333
#: ../../library/stdtypes.rst:3360 ../../library/stdtypes.rst:3402
#: ../../library/stdtypes.rst:3426
msgid "For example::"
msgstr "例えば::"

#: ../../library/stdtypes.rst:2020
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"*sep* が指定されていないか ``None`` の場合、異なる分割アルゴリズムが適用され"
"ます。連続する空白文字はひとつのデリミタとみなされます。また、文字列の先頭や"
"末尾に空白があっても、結果の最初や最後に空文字列は含まれません。よって、空文"
"字列や空白だけの文字列を ``None`` デリミタで分割すると ``[]`` が返されます。"

#: ../../library/stdtypes.rst:2042
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"文字列を改行部分で分解し、各行からなるリストを返します。 *keepends* に真が与"
"えらない限り、返されるリストに改行は含まれません。"

#: ../../library/stdtypes.rst:2046
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"このメソッドは以下の行境界で分解します。特に、以下の境界は :term:`universal "
"newlines` のスーパーセットです。"

#: ../../library/stdtypes.rst:2050
msgid "Representation"
msgstr "表現"

#: ../../library/stdtypes.rst:2050
msgid "Description"
msgstr "説明"

#: ../../library/stdtypes.rst:2052
msgid "``\\n``"
msgstr "``\\n``"

#: ../../library/stdtypes.rst:2052
msgid "Line Feed"
msgstr "改行"

#: ../../library/stdtypes.rst:2054
msgid "``\\r``"
msgstr "``\\r``"

#: ../../library/stdtypes.rst:2054
msgid "Carriage Return"
msgstr "復帰"

#: ../../library/stdtypes.rst:2056
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../../library/stdtypes.rst:2056
msgid "Carriage Return + Line Feed"
msgstr "改行 + 復帰"

#: ../../library/stdtypes.rst:2058
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` or ``\\x0b``"

#: ../../library/stdtypes.rst:2058
msgid "Line Tabulation"
msgstr "垂直タブ"

#: ../../library/stdtypes.rst:2060
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` or ``\\x0c``"

#: ../../library/stdtypes.rst:2060
msgid "Form Feed"
msgstr "改ページ"

#: ../../library/stdtypes.rst:2062
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../../library/stdtypes.rst:2062
msgid "File Separator"
msgstr "ファイル区切り"

#: ../../library/stdtypes.rst:2064
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../../library/stdtypes.rst:2064
msgid "Group Separator"
msgstr "グループ区切り"

#: ../../library/stdtypes.rst:2066
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../../library/stdtypes.rst:2066
msgid "Record Separator"
msgstr "レコード区切り"

#: ../../library/stdtypes.rst:2068
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../../library/stdtypes.rst:2068
msgid "Next Line (C1 Control Code)"
msgstr "改行 (C1 制御コード)"

#: ../../library/stdtypes.rst:2070
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../../library/stdtypes.rst:2070
msgid "Line Separator"
msgstr "行区切り"

#: ../../library/stdtypes.rst:2072
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../../library/stdtypes.rst:2072
msgid "Paragraph Separator"
msgstr "段落区切り"

#: ../../library/stdtypes.rst:2077
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` と ``\\f`` が行境界のリストに追加されました。"

#: ../../library/stdtypes.rst:2086
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
":meth:`~str.split` とは違って、デリミタ文字列 *sep* が与えられたとき、このメ"
"ソッドは空文字列に空リストを返し、終末の改行は結果に行を追加しません::"

#: ../../library/stdtypes.rst:2095
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "比較のために ``split('\\n')`` は以下のようになります::"

#: ../../library/stdtypes.rst:2105
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"文字列が指定された *prefix* で始まるなら ``True`` を、そうでなければ "
"``False`` を返します。 *prefix* は見つけたい複数の接頭語のタプルでも構いませ"
"ん。オプションの *start* があれば、その位置から判定を始めます。オプションの "
"*end* があれば、その位置で比較を止めます。"

#: ../../library/stdtypes.rst:2113
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"文字列の先頭および末尾部分を除去したコピーを返します。引数 *chars* は除去され"
"る文字集合を指定する文字列です。 *chars* が省略されるか ``None`` の場合、空白"
"文字が除去されます。 *chars* 文字列は接頭語でも接尾語でもなく、そこに含まれる"
"文字の組み合わせ全てがはぎ取られます::"

#: ../../library/stdtypes.rst:2124
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"文字列の最も外側の先頭および末尾から、引数 *chars* 値がはぎ取られます。文字列"
"の先頭から *chars* の文字集合に含まれない文字に達するまで、文字が削除されま"
"す。文字列の末尾に対しても同様の操作が行われます。例えば、次のようになりま"
"す::"

#: ../../library/stdtypes.rst:2137
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""
"大文字が小文字に、小文字が大文字に変換された、文字列のコピーを返します。な"
"お、 ``s.swapcase().swapcase() == s`` が真であるとは限りません。"

#: ../../library/stdtypes.rst:2144
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"文字列を、単語ごとに大文字から始まり、残りの文字のうち大小文字の区別があるも"
"のは全て小文字にする、タイトルケースにして返します。"

#: ../../library/stdtypes.rst:2152 ../../library/stdtypes.rst:3370
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"このアルゴリズムは、連続した文字の集まりという、言語から独立した単純な単語の"
"定義を使います。この定義は多くの状況ではうまく機能しますが、短縮形や所有格の"
"アポストロフィが単語の境界になってしまい、望みの結果を得られない場合がありま"
"す::"

#: ../../library/stdtypes.rst:2160
msgid ""
"The :func:`string.capwords` function does not have this problem, as it "
"splits words on spaces only."
msgstr ""
":func:`string.capwords` 関数は単語をスペースでのみ分割するため、この問題はあ"
"りません。"

#: ../../library/stdtypes.rst:2163
msgid ""
"Alternatively, a workaround for apostrophes can be constructed using regular "
"expressions::"
msgstr "または、正規表現を使うことでアポストロフィに対応できます::"

#: ../../library/stdtypes.rst:2178
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`__getitem__`, typically a :term:`mapping` or :term:"
"`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"与えられた変換テーブルに基づいて文字列を構成する各文字をマッピングし、マッピ"
"ング後の文字列のコピーを返します。変換テーブルは、:meth:`__getitem__` による"
"インデックス指定を実装するオブジェクトである必要があります。一般的には、 :"
"term:`mapping` または :term:`sequence` です。Unicode 序数 (整数) でインデック"
"ス指定する場合、変換テーブルのオブジェクトは次のいずれも行うことができます。"
"Unicode 序数または文字列を返して文字を 1 文字以上の別の文字にマッピングするこ"
"と、``None`` を返して返り値の文字列から指定した文字を削除すること、例外 :exc:"
"`LookupError` を送出して文字をその文字自身にマッピングすること。"

#: ../../library/stdtypes.rst:2187
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""
"文字から文字への異なる形式のマッピングから変換マップを作成するために、 :meth:"
"`str.maketrans` が使えます。"

#: ../../library/stdtypes.rst:2190
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""
"文字のマッピングを好みに合わせてより柔軟に変更する方法については、:mod:"
"`codecs` モジュールも参照してください。"

#: ../../library/stdtypes.rst:2196
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"全ての大小文字の区別のある文字 [4]_ が大文字に変換された、文字列のコピーを返"
"します。なお ``s.upper().isupper()`` は、 ``s`` が大小文字の区別のある文字を"
"含まなかったり、結果の文字の Unicode カテゴリが \"Lu\" ではなく例えば "
"\"Lt\" (Letter, titlecase) などであったら、 ``False`` になりえます。"

#: ../../library/stdtypes.rst:2202
msgid ""
"The uppercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"使われる大文字化のアルゴリズムは Unicode Standard のセクション 3.13 に記述さ"
"れています。"

#: ../../library/stdtypes.rst:2208
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"長さが *width* になるよう ASCII ``'0'`` で左詰めした文字列のコピーを返しま"
"す。先頭が符号接頭辞 (``'+'``/``'-'``) だった場合、 ``'0'`` は符号の前ではな"
"く *後* に挿入されます。*width* が ``len(s)`` 以下の場合元の文字列を返しま"
"す。"

#: ../../library/stdtypes.rst:2226
msgid "``printf``-style String Formatting"
msgstr "``printf`` 形式の文字列書式化"

#: ../../library/stdtypes.rst:2239
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives "
"provides their own trade-offs and benefits of simplicity, flexibility, and/"
"or extensibility."
msgstr ""
"ここで解説されているフォーマット操作には、(タプルや辞書を正しく表示するのに失"
"敗するなどの) よくある多くの問題を引き起こす、様々な欠陥が出現します。\n"
"新しい :ref:`フォーマット済み文字列リテラル <f-strings>` や :meth:`str."
"format` インターフェースや :ref:`テンプレート文字列 <template-strings>` が、"
"これらの問題を回避する助けになるでしょう。\n"
"これらの代替手段には、それ自身に、トレードオフや、簡潔さ、柔軟さ、拡張性と"
"いった利点があります。"

#: ../../library/stdtypes.rst:2247
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""
"文字列オブジェクトには固有の操作: ``%`` 演算子 (モジュロ) があります。この演"
"算子は文字列 *書式化* または *補間* 演算子とも呼ばれます。``format % "
"values`` (*format* は文字列) とすると、*format* 中の ``%`` 変換指定は "
"*values* 中のゼロ個またはそれ以上の要素で置換されます。この動作は C 言語にお"
"ける :c:func:`sprintf` に似ています。"

#: ../../library/stdtypes.rst:2253
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"*format* が単一の引数しか要求しない場合、 *values* はタプルでない単一のオブ"
"ジェクトでもかまいません。 [5]_ それ以外の場合、 *values* はフォーマット文字"
"列中で指定された項目と正確に同じ数の要素からなるタプルか、単一のマップオブ"
"ジェクトでなければなりません。"

#: ../../library/stdtypes.rst:2263 ../../library/stdtypes.rst:3481
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"一つの変換指定子は 2 またはそれ以上の文字を含み、その構成要素は以下からなりま"
"すが、示した順に出現しなければなりません:"

#: ../../library/stdtypes.rst:2266 ../../library/stdtypes.rst:3484
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "指定子の開始を示す文字 ``'%'`` 。"

#: ../../library/stdtypes.rst:2268 ../../library/stdtypes.rst:3486
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"マップキー (オプション)。丸括弧で囲った文字列からなります (例えば "
"``(somename)``) 。"

#: ../../library/stdtypes.rst:2271 ../../library/stdtypes.rst:3489
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr "変換フラグ (オプション)。一部の変換型の結果に影響します。"

#: ../../library/stdtypes.rst:2274 ../../library/stdtypes.rst:3492
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"最小のフィールド幅 (オプション)。 ``'*'`` (アスタリスク) を指定した場合、実際"
"の文字列幅が *values* タプルの次の要素から読み出されます。タプルには最小"
"フィールド幅やオプションの精度指定の後に変換したいオブジェクトがくるようにし"
"ます。"

#: ../../library/stdtypes.rst:2278 ../../library/stdtypes.rst:3496
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"精度 (オプション)。 ``'.'`` (ドット) とその後に続く精度で与えられます。 "
"``'*'`` (アスタリスク) を指定した場合、精度の桁数は *values* タプルの次の要素"
"から読み出されます。タプルには精度指定の後に変換したい値がくるようにします。"

#: ../../library/stdtypes.rst:2283 ../../library/stdtypes.rst:3501
msgid "Length modifier (optional)."
msgstr "精度長変換子 (オプション)。"

#: ../../library/stdtypes.rst:2285 ../../library/stdtypes.rst:3503
msgid "Conversion type."
msgstr "変換型。"

#: ../../library/stdtypes.rst:2287
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"``%`` 演算子の右側の引数が辞書の場合 (またはその他のマップ型の場合), 文字列中"
"のフォーマットには、辞書に挿入されているキーを丸括弧で囲い、文字 ``'%'`` の直"
"後にくるようにしたものが含まれていなければ *なりません* 。マップキーはフォー"
"マット化したい値をマップから選び出します。例えば:"

#: ../../library/stdtypes.rst:2296 ../../library/stdtypes.rst:3514
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"この場合、 ``*`` 指定子をフォーマットに含めてはいけません (``*`` 指定子は順番"
"付けされたパラメタのリストが必要だからです)。"

#: ../../library/stdtypes.rst:2299 ../../library/stdtypes.rst:3517
msgid "The conversion flag characters are:"
msgstr "変換フラグ文字を以下に示します:"

#: ../../library/stdtypes.rst:2308 ../../library/stdtypes.rst:3526
msgid "Flag"
msgstr "Flag"

#: ../../library/stdtypes.rst:2310 ../../library/stdtypes.rst:3528
msgid "``'#'``"
msgstr "``'#'``"

#: ../../library/stdtypes.rst:2310 ../../library/stdtypes.rst:3528
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr "値の変換に (下で定義されている) \"別の形式\" を使います。"

#: ../../library/stdtypes.rst:2313 ../../library/stdtypes.rst:3531
msgid "``'0'``"
msgstr "``'0'``"

#: ../../library/stdtypes.rst:2313 ../../library/stdtypes.rst:3531
msgid "The conversion will be zero padded for numeric values."
msgstr "数値型に対してゼロによるパディングを行います。"

#: ../../library/stdtypes.rst:2315 ../../library/stdtypes.rst:3533
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/stdtypes.rst:2315 ../../library/stdtypes.rst:3533
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"変換された値を左寄せにします (``'0'`` と同時に与えた場合、 ``'0'`` を上書きし"
"ます) 。"

#: ../../library/stdtypes.rst:2318 ../../library/stdtypes.rst:3536
msgid "``' '``"
msgstr "``' '``"

#: ../../library/stdtypes.rst:2318 ../../library/stdtypes.rst:3536
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(スペース) 符号付きの変換で正の数の場合、前に一つスペースを空けます (そうでな"
"い場合は空文字になります) 。"

#: ../../library/stdtypes.rst:2321 ../../library/stdtypes.rst:3539
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/stdtypes.rst:2321 ../../library/stdtypes.rst:3539
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""
"変換の先頭に符号文字 (``'+'`` または ``'-'``) を付けます(\"スペース\" フラグ"
"を上書きします) 。"

#: ../../library/stdtypes.rst:2325 ../../library/stdtypes.rst:3543
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"精度長変換子(``h``, ``l``,または ``L``) を使うことができますが、 Python では"
"必要ないため無視されます。 -- つまり、例えば ``%ld`` は ``%d`` と等価です。"

#: ../../library/stdtypes.rst:2328 ../../library/stdtypes.rst:3546
msgid "The conversion types are:"
msgstr "変換型を以下に示します:"

#: ../../library/stdtypes.rst:2331 ../../library/stdtypes.rst:3549
msgid "Conversion"
msgstr "変換"

#: ../../library/stdtypes.rst:2333 ../../library/stdtypes.rst:3551
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/stdtypes.rst:2333 ../../library/stdtypes.rst:2335
#: ../../library/stdtypes.rst:3551 ../../library/stdtypes.rst:3553
msgid "Signed integer decimal."
msgstr "符号付き 10 進整数。"

#: ../../library/stdtypes.rst:2335 ../../library/stdtypes.rst:3553
msgid "``'i'``"
msgstr "``'i'``"

#: ../../library/stdtypes.rst:2337 ../../library/stdtypes.rst:3555
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/stdtypes.rst:2337 ../../library/stdtypes.rst:3555
msgid "Signed octal value."
msgstr "符号付き 8 進数。"

#: ../../library/stdtypes.rst:2339 ../../library/stdtypes.rst:3557
msgid "``'u'``"
msgstr "``'u'``"

#: ../../library/stdtypes.rst:2339 ../../library/stdtypes.rst:3557
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "旧式の型 -- ``'d'`` と同じです。"

#: ../../library/stdtypes.rst:2341 ../../library/stdtypes.rst:3559
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/stdtypes.rst:2341 ../../library/stdtypes.rst:3559
msgid "Signed hexadecimal (lowercase)."
msgstr "符号付き 16 進数 (小文字)。"

#: ../../library/stdtypes.rst:2343 ../../library/stdtypes.rst:3561
msgid "``'X'``"
msgstr "``'X'``"

#: ../../library/stdtypes.rst:2343 ../../library/stdtypes.rst:3561
msgid "Signed hexadecimal (uppercase)."
msgstr "符号付き 16 進数 (大文字)。"

#: ../../library/stdtypes.rst:2345 ../../library/stdtypes.rst:3563
msgid "``'e'``"
msgstr "``'e'``"

#: ../../library/stdtypes.rst:2345 ../../library/stdtypes.rst:3563
msgid "Floating point exponential format (lowercase)."
msgstr "指数表記の浮動小数点数 (小文字)。"

#: ../../library/stdtypes.rst:2347 ../../library/stdtypes.rst:3565
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/stdtypes.rst:2347 ../../library/stdtypes.rst:3565
msgid "Floating point exponential format (uppercase)."
msgstr "指数表記の浮動小数点数 (大文字)。"

#: ../../library/stdtypes.rst:2349 ../../library/stdtypes.rst:3567
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/stdtypes.rst:2349 ../../library/stdtypes.rst:2351
#: ../../library/stdtypes.rst:3567 ../../library/stdtypes.rst:3569
msgid "Floating point decimal format."
msgstr "10 進浮動小数点数。"

#: ../../library/stdtypes.rst:2351 ../../library/stdtypes.rst:3569
msgid "``'F'``"
msgstr "``'F'``"

#: ../../library/stdtypes.rst:2353 ../../library/stdtypes.rst:3571
msgid "``'g'``"
msgstr "``'g'``"

#: ../../library/stdtypes.rst:2353 ../../library/stdtypes.rst:3571
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"浮動小数点数。指数部が -4 以上または精度以下の場合には小文字指数表記、それ以"
"外の場合には10進表記。"

#: ../../library/stdtypes.rst:2357 ../../library/stdtypes.rst:3575
msgid "``'G'``"
msgstr "``'G'``"

#: ../../library/stdtypes.rst:2357 ../../library/stdtypes.rst:3575
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"浮動小数点数。指数部が -4 以上または精度以下の場合には大文字指数表記、それ以"
"外の場合には10進表記。"

#: ../../library/stdtypes.rst:2361 ../../library/stdtypes.rst:3579
msgid "``'c'``"
msgstr "``'c'``"

#: ../../library/stdtypes.rst:2361
msgid "Single character (accepts integer or single character string)."
msgstr "文字一文字 (整数または一文字からなる文字列を受理します)。"

#: ../../library/stdtypes.rst:2364 ../../library/stdtypes.rst:3592
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/stdtypes.rst:2364
msgid "String (converts any Python object using :func:`repr`)."
msgstr "文字列 (Python オブジェクトを :func:`repr` で変換します)。"

#: ../../library/stdtypes.rst:2367 ../../library/stdtypes.rst:3586
msgid "``'s'``"
msgstr "``'s'``"

#: ../../library/stdtypes.rst:2367
msgid "String (converts any Python object using :func:`str`)."
msgstr "文字列 (Python オブジェクトを :func:`str` で変換します)。"

#: ../../library/stdtypes.rst:2370 ../../library/stdtypes.rst:3589
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/stdtypes.rst:2370
msgid "String (converts any Python object using :func:`ascii`)."
msgstr "文字列 (Python オブジェクトを :func:`ascii` で変換します)。"

#: ../../library/stdtypes.rst:2373 ../../library/stdtypes.rst:3595
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/stdtypes.rst:2373 ../../library/stdtypes.rst:3595
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr "引数を変換せず、返される文字列中では文字 ``'%'`` になります。"

#: ../../library/stdtypes.rst:2380 ../../library/stdtypes.rst:3602
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""
"別の形式を指定（訳注: 変換フラグ ``#`` を使用）すると 8 進数を表す接頭辞 "
"(``'0o'``) が最初の数字の前に挿入されます。"

#: ../../library/stdtypes.rst:2384 ../../library/stdtypes.rst:3606
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"別の形式を指定（訳注: 変換フラグ ``#`` を使用）すると 16 進数を表す接頭辞 "
"``'0x'`` または ``'0X'`` (使用するフォーマット文字が ``'x'`` か ``'X'`` に依"
"存します) が最初の数字の前に挿入されます。"

#: ../../library/stdtypes.rst:2388 ../../library/stdtypes.rst:3610
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""
"この形式にした場合、変換結果には常に小数点が含まれ、それはその後ろに数字が続"
"かない場合にも適用されます。"

#: ../../library/stdtypes.rst:2391 ../../library/stdtypes.rst:3613
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr "指定精度は小数点の後の桁数を決定し、そのデフォルトは 6 です。"

#: ../../library/stdtypes.rst:2395 ../../library/stdtypes.rst:3617
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"この形式にした場合、変換結果には常に小数点が含まれ他の形式とは違って末尾の 0 "
"は取り除かれません。"

#: ../../library/stdtypes.rst:2398 ../../library/stdtypes.rst:3620
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr "指定精度は小数点の前後の有効桁数を決定し、そのデフォルトは 6 です。"

#: ../../library/stdtypes.rst:2402 ../../library/stdtypes.rst:3624
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "精度が ``N`` なら、出力は ``N`` 文字に切り詰められます。"

#: ../../library/stdtypes.rst:2405 ../../library/stdtypes.rst:3633
msgid "See :pep:`237`."
msgstr ":pep:`237` を参照してください。"

#: ../../library/stdtypes.rst:2407
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Python 文字列には明示的な長さ情報があるので、 ``%s`` 変換において ``'\\0'`` "
"を文字列の末端と仮定したりはしません。"

#: ../../library/stdtypes.rst:2412
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"絶対値が 1e50 を超える数値の ``%f`` 変換が ``%g`` 変換に置き換えられなくなり"
"ました。"

#: ../../library/stdtypes.rst:2423
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""
"バイナリシーケンス型 --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"

#: ../../library/stdtypes.rst:2431
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""
"バイナリデータを操作するためのコア組み込み型は :class:`bytes` および :class:"
"`bytearray` です。これらは、別のバイナリオブジェクトのメモリにコピーを作成す"
"ること無くアクセスするための :ref:`バッファプロトコル <bufferobjects>` を利用"
"する :class:`memoryview` でサポートされています。"

#: ../../library/stdtypes.rst:2436
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""
":mod:`array` モジュールは、32 ビット整数や IEEE754 倍精度浮動小数点値のような"
"基本データ型の、効率的な保存をサポートしています。"

#: ../../library/stdtypes.rst:2442
msgid "Bytes Objects"
msgstr "バイトオブジェクト"

#: ../../library/stdtypes.rst:2446
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"bytes はバイトの不変なシーケンスです。多くのメジャーなプロトコルがASCIIテキス"
"トエンコーディングをベースにしているので、 bytes オブジェクトは ASCII 互換の"
"データに対してのみ動作する幾つかのメソッドを提供していて、文字列オブジェクト"
"と他の多くの点で近いです。"

#: ../../library/stdtypes.rst:2453
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""
"まず、 bytes リテラルの構文は文字列リテラルとほぼ同じで、 ``b`` というプリ"
"フィックスを付けます:"

#: ../../library/stdtypes.rst:2456
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr "シングルクォート: ``b'still allows embedded \"double\" quotes'``"

#: ../../library/stdtypes.rst:2457
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``"
msgstr "ダブルクォート: ``b\"still allows embedded 'single' quotes\"``."

#: ../../library/stdtypes.rst:2458
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""
"3重クォート: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"

#: ../../library/stdtypes.rst:2460
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"bytes リテラルでは (ソースコードのエンコーディングに関係なく) ASCII文字のみが"
"許可されています。 127より大きい値を bytes リテラルに記述する場合は適切なエス"
"ケープシーケンスを書く必要があります。"

#: ../../library/stdtypes.rst:2464
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"文字列リテラルと同じく、 bytes リテラルでも ``r`` プリフィックスを用いてエス"
"ケープシーケンスの処理を無効にすることができます。 bytes リテラルの様々な形式"
"やサポートされているエスケープシーケンスについては :ref:`strings` を参照して"
"ください。"

#: ../../library/stdtypes.rst:2468
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""
"bytesリテラルと repr 出力は ASCII テキストをベースにしたものですが、 bytes オ"
"ブジェクトは、各値が ``0 <= x < 256`` の範囲に収まるような整数  (この制限に違"
"反しようとすると :exc:`ValueError` が発生します) の不変なシーケンスとして振る"
"舞います。多くのバイナリフォーマットがASCIIテキストを元にした要素を持っていた"
"り何らかのテキスト操作アルゴリズムによって操作されるものの、任意のバイナリ"
"データが一般にテキストになっているわけではないことを強調するためにこのように"
"設計されました (何も考えずにテキスト操作アルゴリズムをASCII非互換なバイナリ"
"データフォーマットに対して行うとデータを破壊することがあります)。"

#: ../../library/stdtypes.rst:2478
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr "リテラル以外に、幾つかの方法で bytes オブジェクトを作ることができます:"

#: ../../library/stdtypes.rst:2481
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr "指定された長さの、0で埋められた bytes オブジェクト: ``bytes(10)``"

#: ../../library/stdtypes.rst:2482
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "整数の iterable から: ``bytes(range(20))``"

#: ../../library/stdtypes.rst:2483
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr "既存のバイナリデータからバッファプロトコルでコピーする: ``bytes(obj)``"

#: ../../library/stdtypes.rst:2485
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr ":ref:`bytes <func-bytes>` ビルトイン関数も参照してください。"

#: ../../library/stdtypes.rst:2487
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"16 進数で 2 桁の数は正確に 1 バイトに相当するため、16 進整はバイナリデータを"
"表現する形式として広く使われています。 従って、 bytes 型にはその形式でデータ"
"を読み取るための追加のクラスメソッドがあります。"

#: ../../library/stdtypes.rst:2493
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"この :class:`bytes` のクラスメソッドは、与えられた文字列オブジェクトをデコー"
"ドして bytes オブジェクトを返します。それぞれのバイトを 16 進数 2 桁で表現し"
"た文字列を指定しなければなりません。ASCII 空白文字は無視されます。"

#: ../../library/stdtypes.rst:2500
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""
":meth:`bytes.fromhex` は文字列にある空白だけでなく、 ASCII の空白文字全てをス"
"キップするようになりました。"

#: ../../library/stdtypes.rst:2504
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""
"bytes オブジェクトをその 16 進表記に変換するための、反対向きの変換関数があり"
"ます。"

#: ../../library/stdtypes.rst:2509 ../../library/stdtypes.rst:2594
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""
"インスタンス内の 1 バイトにつき 2 つの 16 進数を含む、文字列オブジェクトを返"
"します。"

#: ../../library/stdtypes.rst:2515
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default, "
"this separator will be included between each byte. A second optional "
"*bytes_per_sep* parameter controls the spacing. Positive values calculate "
"the separator position from the right, negative values from the left."
msgstr ""
"16進数文字列を読みやすく表示したい場合、単一文字パラメータ  *sep* を指定して"
"セパレータを出力に含めることができます。デフォルトでは、セパレータはバイトご"
"とに表示が区切られるように追加されます。2つ目のオプションパラメータ "
"*bytes_per_sep* はセパレータを入れる間隔を制御します。正の整数値はセパレータ"
"の位置を右から計算し、負の整数値は左から計算します。"

#: ../../library/stdtypes.rst:2532
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters "
"to insert separators between bytes in the hex output."
msgstr ""
":meth:`bytes.hex` が、16進数出力の各バイトを分割するセパレータを挿入するため"
"のオプションパラメータ *sep* と *bytes_per_sep* をサポートするようになりまし"
"た。"

#: ../../library/stdtypes.rst:2536
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"bytes オブジェクトは (タプルに似た) 整数のシーケンスなので、 bytes オブジェク"
"ト *b* について、 ``b[0]`` は整数になり、 ``b[0:1]`` は長さ 1 の bytes オブ"
"ジェクトになります。 (この動作は、文字列に対するインデックス指定もスライスも"
"長さ 1 の文字列を返すのと対照的です。)"

#: ../../library/stdtypes.rst:2541
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"bytes オブジェクトの repr 出力はリテラル形式 (``b'...'``) になります。 "
"``bytes([46, 46, 46])`` などの形式よりも便利な事が多いからです。 bytes オブ"
"ジェクトはいつでも ``list(b)`` で整数のリストに変換できます。"

#: ../../library/stdtypes.rst:2549
msgid "Bytearray Objects"
msgstr "bytearray オブジェクト"

#: ../../library/stdtypes.rst:2553
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""
":class:`bytearray` オブジェクトは :class:`bytes` オブジェクトの可変なバージョ"
"ンです。"

#: ../../library/stdtypes.rst:2558
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""
"bytearray に専用のリテラル構文はないので、コンストラクタを使って作成します:"

#: ../../library/stdtypes.rst:2561
msgid "Creating an empty instance: ``bytearray()``"
msgstr "空のインスタンスを作る: ``bytearray()``"

#: ../../library/stdtypes.rst:2562
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr "指定された長さの0で埋められたインスタンスを作る: ``bytearray(10)``"

#: ../../library/stdtypes.rst:2563
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "整数の iterable から: ``bytearray(range(20))``"

#: ../../library/stdtypes.rst:2564
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""
"既存のバイナリデータからバッファプロトコルを通してコピーする: "
"``bytearray(b'Hi!')``"

#: ../../library/stdtypes.rst:2566
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"bytearray オブジェクトは可変なので、 :ref:`bytes-methods` で解説されている "
"bytes オブジェクトと共通の操作に加えて、 :ref:`mutable <typesseq-mutable>` "
"シーケンス操作もサポートしています。"

#: ../../library/stdtypes.rst:2570
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr ":ref:`bytearray <func-bytearray>` ビルトイン関数も参照してください。"

#: ../../library/stdtypes.rst:2572
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"16 進数で 2 桁の数は正確に 1 バイトに相当するため、16 進整はバイナリデータを"
"表現する形式として広く使われています。 従って、 bytearray 型にはその形式で"
"データを読み取るための追加のクラスメソッドがあります。"

#: ../../library/stdtypes.rst:2578
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"この :class:`bytearray` のクラスメソッドは、与えられた文字列オブジェクトをデ"
"コードして bytearray オブジェクトを返します。それぞれのバイトを 16 進数 2 桁"
"で表現した文字列を指定しなければなりません。ASCII 空白文字は無視されます。"

#: ../../library/stdtypes.rst:2585
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""
":meth:`bytearray.fromhex` は文字列にある空白だけでなく、 ASCII の空白文字全て"
"をスキップするようになりました。"

#: ../../library/stdtypes.rst:2589
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""
"bytearray オブジェクトをその 16 進表記に変換するための、反対向きの変換関数が"
"あります。"

#: ../../library/stdtypes.rst:2602
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
":meth:`bytes.hex` と同様に、 :meth:`bytearray.hex` が、16進数出力の各バイトを"
"分割するセパレータを挿入するためのオプションパラメータ *sep* と "
"*bytes_per_sep* をサポートするようになりました。"

#: ../../library/stdtypes.rst:2607
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"bytearray オブジェクトは整数のシーケンス (リストのようなもの) なので、 "
"bytearray オブジェクト *b* について、 ``b[0]`` は整数になり、 ``b[0:1]`` は長"
"さ 1 の bytearray オブジェクトになります。(これは、文字列においてインデックス"
"指定もスライスも長さ 1 の文字列を返すのと対照的です。)"

#: ../../library/stdtypes.rst:2612
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""
"bytearray オブジェクトの表記はバイトのリテラル形式 (``bytearray(b'...')``) を"
"使用します。これは ``bytearray([46, 46, 46])`` などの形式よりも便利な事が多い"
"ためです。\n"
"bytearray オブジェクトはいつでも ``list(b)`` で整数のリストに変換できます。"

#: ../../library/stdtypes.rst:2621
msgid "Bytes and Bytearray Operations"
msgstr "bytes と bytearray の操作"

#: ../../library/stdtypes.rst:2626
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"bytes と bytearray は両方共 :ref:`一般のシーケンス操作 <typesseq-common>` を"
"サポートしています。また、両方とも :term:`bytes-like object` をサポートしてい"
"る任意のオブジェクトを対象に操作することもできます。この柔軟性により bytes "
"と bytearray を自由に混ぜてもエラーを起こすことなく扱うことができます。ただ"
"し、操作の結果のオブジェクトはその操作の順序に依存することになります。"

#: ../../library/stdtypes.rst:2634
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"文字列のメソッドが引数として bytes を受け付けないのと同様、bytes オブジェクト"
"と bytearray オブジェクトのメソッドは引数として文字列を受け付けません。例え"
"ば、以下のように書かなければなりません::"

#: ../../library/stdtypes.rst:2641
msgid "and::"
msgstr "および::"

#: ../../library/stdtypes.rst:2646
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"いくつかの bytes と bytearray の操作は ASCII と互換性のあるバイナリフォーマッ"
"トが使われていると仮定していますので、フォーマットの不明なバイナリデータに対"
"して使うことは避けるべきです。こうした制約については以下で説明します。"

#: ../../library/stdtypes.rst:2651
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""
"これらの ASCII ベースの演算を使って ASCII ベースではないバイナリデータを操作"
"すると、データを破壊する恐れがあります。"

#: ../../library/stdtypes.rst:2654
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""
"以下の bytes および bytearray オブジェクトのメソッドは、任意のバイナリデータ"
"に対して使用できます。"

#: ../../library/stdtypes.rst:2660
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"[*start*, *end*] の範囲に、部分シーケンス *sub* が重複せず出現する回数を返し"
"ます。オプション引数 *start* および *end* はスライス表記と同じように解釈され"
"ます。"

#: ../../library/stdtypes.rst:2664 ../../library/stdtypes.rst:2769
#: ../../library/stdtypes.rst:2791 ../../library/stdtypes.rst:2857
#: ../../library/stdtypes.rst:2870
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""
"検索対象の部分シーケンスは、任意の :term:`bytes-like object` または  0 から "
"255 の範囲の整数にできます。"

#: ../../library/stdtypes.rst:2667
msgid ""
"If *sub* is empty, returns the number of empty slices between characters "
"which is the length of the bytes object plus one."
msgstr ""
"*sub* が空の場合は、文字と文字の間にある空のスライスの数、すなわちbytesオブ"
"ジェクトの長さに1を加えたものを返します。"

#: ../../library/stdtypes.rst:2670 ../../library/stdtypes.rst:2781
#: ../../library/stdtypes.rst:2794 ../../library/stdtypes.rst:2860
#: ../../library/stdtypes.rst:2873
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr ""
"部分シーケンスとして 0 から 255 の範囲の整数も受け取れるようになりました。"

#: ../../library/stdtypes.rst:2677
msgid ""
"If the binary data starts with the *prefix* string, return "
"``bytes[len(prefix):]``. Otherwise, return a copy of the original binary "
"data::"
msgstr ""
"バリナリーデータが文字列 *prefix* で始まる場合、  ``bytes[len(prefix):]`` を"
"返します。それ以外の場合、元のバイナリーデータのコピーを返します::"

#: ../../library/stdtypes.rst:2686
msgid "The *prefix* may be any :term:`bytes-like object`."
msgstr "*prefix* は、任意の :term:`bytes-like object` にできます。"

#: ../../library/stdtypes.rst:2690 ../../library/stdtypes.rst:2712
#: ../../library/stdtypes.rst:2845 ../../library/stdtypes.rst:2938
#: ../../library/stdtypes.rst:2952 ../../library/stdtypes.rst:2983
#: ../../library/stdtypes.rst:2997 ../../library/stdtypes.rst:3039
#: ../../library/stdtypes.rst:3109 ../../library/stdtypes.rst:3127
#: ../../library/stdtypes.rst:3155 ../../library/stdtypes.rst:3294
#: ../../library/stdtypes.rst:3349 ../../library/stdtypes.rst:3392
#: ../../library/stdtypes.rst:3413 ../../library/stdtypes.rst:3435
#: ../../library/stdtypes.rst:3637
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""
"bytearray のこのメソッドはインプレースでは動作 *しません* -- 一切変化が無い場"
"合でも、常に新しいオブジェクトを生成します。"

#: ../../library/stdtypes.rst:2699
msgid ""
"If the binary data ends with the *suffix* string and that *suffix* is not "
"empty, return ``bytes[:-len(suffix)]``.  Otherwise, return a copy of the "
"original binary data::"
msgstr ""
"バイナリーデータが文字列 *suffix* で終わり、 *suffix* が空でない場合、 "
"``bytes[:-len(suffix)]`` を返します。それ以外の場合、元のバイナリーデータのコ"
"ピーを返します::"

#: ../../library/stdtypes.rst:2708
msgid "The *suffix* may be any :term:`bytes-like object`."
msgstr "*suffix* は、任意の :term:`bytes-like object` にできます。"

#: ../../library/stdtypes.rst:2721
msgid "Return the bytes decoded to a :class:`str`."
msgstr ":class:`str` にデコードされたbytesを返します。"

#: ../../library/stdtypes.rst:2726
msgid ""
"*errors* controls how decoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, and any other name registered via :func:"
"`codecs.register_error`. See :ref:`error-handlers` for details."
msgstr ""
"*errors* はデコーディングエラーをどのように取り扱うかを制御します。 "
"``'strict'`` (デフォルト) では :exc:`UnicodeError` 例外が送出されます。そのほ"
"かに指定可能な値は ``'ignore'``, ``'replace'`` と、そして :func:`codecs."
"register_error` で登録された名前です。詳しくは :ref:`error-handlers` を参照し"
"てください。"

#: ../../library/stdtypes.rst:2732
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless a decoding error actually occurs, :ref:`devmode` is enabled or a :ref:"
"`debug build <debug-build>` is used."
msgstr ""
"パフォーマンス上の理由から、 *errors* の値の妥当性は、デコーディングエラーが"
"実際に発生するか、 :ref:`devmode` が有効になっているか、もしくは :ref:`デバッ"
"グビルド <debug-build>` が使われていない限りチェックされません。"

#: ../../library/stdtypes.rst:2738
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary :class:`!"
"bytes` or :class:`!bytearray` object."
msgstr ""
"引数 *encoding* を :class:`str` に渡すと :term:`bytes-like object` を直接デ"
"コードすることができます。つまり、一時的な :class:`!bytes` や :class:`!"
"bytearray` オブジェクトを作成する必要はありません。"

#: ../../library/stdtypes.rst:2753
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"バイナリデータが指定された *suffix* で終わる場合は ``True`` を、そうでなけれ"
"ば ``False`` を返します。 *suffix* は見つけたい複数の接尾語のタプルでも構いま"
"せん。オプションの *start* が指定されている場合、その位置から判定を開始しま"
"す。オプションの *end* が指定されている場合、その位置で比較を終了します。"

#: ../../library/stdtypes.rst:2758
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"検索対象の接尾語 (複数も可) は、任意の :term:`bytes-like object` にできます。"

#: ../../library/stdtypes.rst:2764
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"スライス ``s[start:end]`` に部分シーケンス *sub* が含まれる場合、データ中のそ"
"の *sub* の最小のインデックスを返します。オプション引数 *start* および *end* "
"はスライス表記と同様に解釈されます。 *sub* が見つからなかった場合、 ``-1`` を"
"返します。"

#: ../../library/stdtypes.rst:2774
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
":meth:`~bytes.find` メソッドは、 *sub* の位置を知りたいときにのみ使うべきで"
"す。 *sub* が部分文字列 (訳注: おそらく原文の誤り、正しくは部分シーケンス) で"
"あるかどうかのみを調べるには、 :keyword:`in` 演算子を使ってください::"

#: ../../library/stdtypes.rst:2788
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""
":meth:`~bytes.find` と同様ですが、部分シーケンスが見つからなかった場合 :exc:"
"`ValueError` を送出します。"

#: ../../library/stdtypes.rst:2801
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"*iterable* 中のバイナリデータを結合した bytes または bytearray オブジェクトを"
"返します。 *iterable* に :class:`str` オブジェクトなど :term:`bytes-like "
"objects <bytes-like object>` ではない値が含まれている場合、 :exc:`TypeError` "
"が送出されます。なお要素間のセパレータは、このメソッドを提供する bytes また"
"は bytearray オブジェクトとなります。"

#: ../../library/stdtypes.rst:2812
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""
"この静的メソッドは、 :func:`bytes.translate` に渡すのに適した変換テーブルを返"
"します。このテーブルは、 *from* 中の各バイトを *to* の同じ位置にあるバイトに"
"マッピングします。 *from* と *to* は両方とも同じ長さの :term:`bytes-like "
"objects <bytes-like object>` でなければなりません。"

#: ../../library/stdtypes.rst:2823
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""
"区切り *sep* が最初に出現する位置でシーケンスを分割し、 3 要素のタプルを返し"
"ます。タプルの内容は、区切りの前の部分、その区切りオブジェクトまたはその "
"bytearray 型のコピー、そして区切りの後ろの部分です。もし区切りが見つからなけ"
"れば、タプルには元のシーケンスのコピーと、その後ろに二つの空の bytes または "
"bytearray オブジェクトが入ります。"

#: ../../library/stdtypes.rst:2830 ../../library/stdtypes.rst:2887
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr ""
"検索する区切りとしては、任意の :term:`bytes-like object` を指定できます。"

#: ../../library/stdtypes.rst:2836
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"部分シーケンス *old* を全て *new* に置換したシーケンスを返します。オプション"
"引数 *count* が与えられている場合、先頭から *count* 個の *old* だけを置換しま"
"す。"

#: ../../library/stdtypes.rst:2840
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""
"検索する部分シーケンスおよび置換後の部分シーケンスとしては、任意の :term:"
"`bytes-like object` を指定できます。"

#: ../../library/stdtypes.rst:2852
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"シーケンス中の領域 ``s[start:end]`` に *sub* が含まれる場合、その最大のイン"
"デックスを返します。オプション引数 *start* および *end* はスライス表記と同様"
"に解釈されます。 *sub* が見つからなかった場合 ``-1``  を返します。"

#: ../../library/stdtypes.rst:2867
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
":meth:`~bytes.rfind` と同様ですが、部分シーケンス *sub* が見つからなかった場"
"合 :exc:`ValueError` を送出します。"

#: ../../library/stdtypes.rst:2880
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""
"区切り *sep* が最後に出現する位置でシーケンスを分割し、 3 要素のタプルを返し"
"ます。タプルの内容は、区切りの前の部分、その区切りオブジェクトまたはその "
"bytearray 型のコピー、そして区切りの後ろの部分です。もし区切れなければ、タプ"
"ルには二つの空の bytes または bytearray オブジェクトと、その後ろに元のシーケ"
"ンスのコピーが入ります。"

#: ../../library/stdtypes.rst:2893
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"バイナリデータが指定された *prefix* で始まる場合は ``True`` を、そうでなけれ"
"ば ``False`` を返します。 *prefix* は見つけたい複数の接頭語のタプルでも構いま"
"せん。オプションの *start* が指定されている場合、その位置から判定を開始しま"
"す。オプションの *end* が指定されている場合、その位置で比較を終了します。"

#: ../../library/stdtypes.rst:2898
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"検索対象の接頭語 (複数も可) は、任意の :term:`bytes-like object` にできます。"

#: ../../library/stdtypes.rst:2904
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"オプション引数 *delete* に現れるすべてのバイトを除去し、残ったバイトを与えら"
"れた変換テーブルに従ってマップした、バイト列やバイト配列オブジェクトのコピー"
"を返します。変換テーブルは長さ 256 のバイト列オブジェクトでなければなりませ"
"ん。"

#: ../../library/stdtypes.rst:2909
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""
"変換テーブルの作成に、 :func:`bytes.maketrans` メソッドを使うこともできます。"

#: ../../library/stdtypes.rst:2912
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""
"文字を削除するだけの変換には、 *table* 引数を ``None`` に設定してください::"

#: ../../library/stdtypes.rst:2918
msgid "*delete* is now supported as a keyword argument."
msgstr "*delete* はキーワード引数として指定可能になりました。"

#: ../../library/stdtypes.rst:2922
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"以下の bytes および bytearray オブジェクトのメソッドは、 ASCII と互換性のある"
"バイナリフォーマットが使われていると仮定していますが、適切な引数を指定すれば"
"任意のバイナリデータに使用できます。なお、このセクションで紹介する bytearray "
"のメソッドはすべてインプレースで動作 *せず* 、新しいオブジェクトを生成しま"
"す。"

#: ../../library/stdtypes.rst:2931
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"長さ *width* の中央寄せされたシーケンスのコピーを返します。パディングには "
"*fillbyte* で指定された値 (デフォルトでは ASCII スペース) が使われます。 :"
"class:`bytes` オブジェクトの場合、 *width* が ``len(s)`` 以下なら元のシーケン"
"スが返されます。"

#: ../../library/stdtypes.rst:2945
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"長さ *width* の左寄せされたシーケンスのコピーを返します。パディングには "
"*fillbyte* で指定された値 (デフォルトでは ASCII スペース) が使われます。 :"
"class:`bytes` オブジェクトの場合、 *width* が ``len(s)`` 以下なら元のシーケン"
"スが返されます。"

#: ../../library/stdtypes.rst:2959
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"先頭から特定のバイト値を除去したコピーを返します。引数 *chars* は除去されるバ"
"イト値の集合を指定するバイナリシーケンスです － この名前は、このメソッドが通"
"常は ASCII 文字列に対して使われることに由来しています。 *chars* が省略される"
"か ``None`` の場合、 ASCII の空白文字 (訳注: 空白文字の定義については :meth:"
"`bytearray.isspace` を参照) が除去されます。なお *chars* 引数と一致する接頭辞"
"が除去されるのではなく、それに含まれるバイトの組み合わせ全てが除去されます::"

#: ../../library/stdtypes.rst:2971
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removeprefix` for a method that will remove a "
"single prefix string rather than all of a set of characters.  For example::"
msgstr ""
"削除したいバイト値のバイナリシーケンスには、 :term:`bytes-like object` を指定"
"することができます。バイナリシーケンスで指定した文字の集合全てではなく、指定"
"した文字列そのものを接頭辞として削除するメソッドについては、 :meth:`~bytes."
"removeprefix` を参照してください。使用例::"

#: ../../library/stdtypes.rst:2990
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"長さ *width* の右寄せされたシーケンスのコピーを返します。パディングには "
"*fillbyte* で指定された値 (デフォルトでは ASCII スペース) が使われます。 :"
"class:`bytes` オブジェクトの場合、 *width* が ``len(s)`` 以下なら元のシーケン"
"スが返されます。"

#: ../../library/stdtypes.rst:3004
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""
"*sep* を区切りとして、同じ型の部分シーケンスに分割します。 *maxsplit* が与え"
"られた場合、シーケンスの *右端* から最大 *maxsplit* 回だけ分割を行います。 "
"*sep* が指定されていないか ``None`` のとき、 ASCII 空白文字の組み合わせで作ら"
"れる部分シーケンスすべてが区切りとなります。右から分割していくことを除け"
"ば、 :meth:`rsplit` は後ほど詳しく述べる :meth:`split` と同様に振る舞います。"

#: ../../library/stdtypes.rst:3015
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"末尾から特定のバイト値を除去したコピーを返します。引数 *chars* は除去されるバ"
"イト値の集合を指定するバイナリシーケンスです － この名前は、このメソッドが通"
"常は ASCII 文字列に対して使われることに由来しています。 *chars* が省略される"
"か ``None`` の場合、 ASCII の空白文字 (訳注: 空白文字の定義については :meth:"
"`bytearray.isspace` を参照) が除去されます。なお *chars* 引数と一致する接尾辞"
"が除去されるのではなく、それに含まれるバイトの組み合わせ全てが除去されます::"

#: ../../library/stdtypes.rst:3027
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removesuffix` for a method that will remove a "
"single suffix string rather than all of a set of characters.  For example::"
msgstr ""
"削除したいバイト値のバイナリシーケンスには、 :term:`bytes-like object` を指定"
"することができます。バイナリシーケンスで指定した文字の集合全てではなく、指定"
"した文字列そのものを接尾辞として削除するメソッドについては、 :meth:`~bytes."
"removesuffix` を参照してください。使用例::"

#: ../../library/stdtypes.rst:3046
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"*sep* を区切りとして、同じ型の部分シーケンスに分割します。 *maxsplit* が与え"
"られ、かつ負の数でない場合、シーケンスの *左端* から最大 *maxsplit* 回だけ分"
"割を行います (したがって結果のリストの要素数は最大で ``maxsplit+1`` になりま"
"す)。 *maxsplit* が指定されていないか ``-1`` のとき、分割の回数に制限はありま"
"せん (可能なだけ分割されます)。"

#: ../../library/stdtypes.rst:3052
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns "
"``[b'1', b'2', b'3']``). Splitting an empty sequence with a specified "
"separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on the type of "
"object being split.  The *sep* argument may be any :term:`bytes-like object`."
msgstr ""
"*sep* が与えられた場合、連続した区切り用バイト値はまとめられず、空の部分シー"
"ケンスを区切っていると判断されます(例えば ``b'1,,2'.split(b',')`` は "
"``[b'1', b'', b'2']`` を返します)。引数 *sep* は複数バイトのシーケンスにもで"
"きます (例えば ``b'1<>2<>3'.split(b'<>')`` は ``[b'1', b'2', b'3']`` を返しま"
"す)。空のシーケンスを分割すると、分割するオブジェクトの型によって ``[b'']`` "
"または ``[bytearray(b'')]`` が返ります。引数 *sep* には、あらゆる :term:"
"`bytes-like object` を指定できます。"

#: ../../library/stdtypes.rst:3070
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"*sep* が指定されていないか ``None`` の場合、異なる分割アルゴリズムが適用され"
"ます。連続する ASCII 空白文字はひとつの区切りとみなされ、またシーケンスの先頭"
"や末尾に空白があっても、結果の最初や最後に空のシーケンスは含まれません。した"
"がって区切りを指定せずに空のシーケンスや ASCII 空白文字だけのシーケンスを分割"
"すると、 ``[]`` が返されます。"

#: ../../library/stdtypes.rst:3091
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"先頭および末尾から特定のバイト値を除去したコピーを返します。引数 *chars* は除"
"去されるバイト値の集合を指定するバイナリシーケンスです － この名前は、このメ"
"ソッドが通常は ASCII 文字列に対して使われることに由来しています。 *chars* が"
"省略されるか ``None`` の場合、 ASCII の空白文字 (訳注: 空白文字の定義について"
"は :meth:`bytearray.isspace` を参照) が除去されます。なお *chars* 引数と一致"
"する接頭辞および接尾辞が除去されるのではなく、それに含まれるバイトの組み合わ"
"せ全てが除去されます::"

#: ../../library/stdtypes.rst:3104
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""
"除去対象のバイト値を含むバイナリシーケンスには、任意の :term:`bytes-like "
"object` を指定できます。"

#: ../../library/stdtypes.rst:3113
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"以下の bytes および bytearray オブジェクトのメソッドは、 ASCII と互換性のある"
"バイナリフォーマットが使われていると仮定しており、任意のバイナリデータに対し"
"て使用すべきではありません。なお、このセクションで紹介する bytearray のメソッ"
"ドはすべてインプレースで動作 *せず* 、新しいオブジェクトを生成します。"

#: ../../library/stdtypes.rst:3121
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""
"各バイトを ASCII 文字と解釈して、最初のバイトを大文字にし、残りを小文字にした"
"シーケンスのコピーを返します。 ASCII 文字と解釈できないバイト値は、変更されま"
"せん。"

#: ../../library/stdtypes.rst:3134
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"桁 (column) 位置と指定されたタブ幅 (tab size) に応じて、全ての ASCII タブ文字"
"を 1 つ以上の ASCII スペース文字に置換したシーケンスのコピーを返します。ここ"
"で *tabsize* バイトごとの桁位置をタブ位置とします (デフォルト値である 8 の場"
"合、タブ位置は 0 桁目、 8 桁目、 16 桁目、と続いていきます)。シーケンスを展開"
"するにあたって、まず現桁位置をゼロに設定し、シーケンスを 1 バイトずつ調べてい"
"きます。もしバイト値が ASCII タブ文字 (``b'\\t'``) であれば、現桁位置が次のタ"
"ブ位置と一致するまで 1 つ以上の ASCII スペース文字を結果のシーケンスに挿入し"
"ていきます（ASCII タブ文字自体はコピーしません）。もしバイト値が ASCII 改行文"
"字 (``b'\\n'`` もしくは ``b'\\r'``) であれば、そのままコピーした上で現桁位置"
"を 0 にリセットします。その他のバイト値については変更せずにコピーし、そのバイ"
"ト値の表示のされ方（訳注: 全角、半角など）に関わらず現桁位置を 1 つ増加させま"
"す::"

#: ../../library/stdtypes.rst:3162
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"シーケンスが空でなく、かつ全てのバイト値が ASCII 文字のアルファベットまたは数"
"字である場合は ``True`` を、そうでなければ ``False`` を返します。ここでの "
"ASCII 文字のアルファベットとはシーケンス "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`` に含まれるバイト"
"値です。 ASCII 文字の数字とは ``b'0123456789'`` に含まれるバイト値です。"

#: ../../library/stdtypes.rst:3179
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"シーケンスが空でなく、かつ全てのバイト値が ASCII 文字のアルファベットである場"
"合は ``True`` を、そうでなければ ``False`` を返します。ここでの ASCII 文字の"
"アルファベットとはシーケンス "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`` に含まれるバイト"
"値です。"

#: ../../library/stdtypes.rst:3195
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""
"シーケンスが空であるか、シーケンスの全てのバイトが ASCII である場合に "
"``True`` を、それ以外の場合に ``False`` を返します。\n"
"ASCII バイトは 0-0x7F の範囲にあります。"

#: ../../library/stdtypes.rst:3205
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""
"シーケンスが空でなく、かつ全てのバイト値が ASCII 文字の数字である場合は "
"``True`` を、そうでなければ ``False`` を返します。ここでの ASCII 文字の数字と"
"は ``b'0123456789'`` に含まれるバイト値です。"

#: ../../library/stdtypes.rst:3220
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr ""
"シーケンス中に小文字アルファベットの ASCII 文字が一つ以上あり、かつ大文字アル"
"ファベットの ASCII 文字が一つも無い場合に ``True`` を返します。そうでなけれ"
"ば ``False`` を返します。"

#: ../../library/stdtypes.rst:3230 ../../library/stdtypes.rst:3272
#: ../../library/stdtypes.rst:3288 ../../library/stdtypes.rst:3338
#: ../../library/stdtypes.rst:3407
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"ここでの小文字の ASCII 文字とは ``b'abcdefghijklmnopqrstuvwxyz'`` に含まれる"
"バイト値です。また大文字の ASCII 文字とは ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`` "
"に含まれるバイト値です。"

#: ../../library/stdtypes.rst:3238
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"シーケンスが空でなく、かつ全てのバイト値が ASCII 空白文字である場合は "
"``True`` を、そうでなければ ``False`` を返します。ここでの ASCII 空白文字とは"
"シーケンス ``b' \\t\\n\\r\\x0b\\f'`` に含まれるバイト値です (半角スペース、タ"
"ブ、ラインフィード、キャリッジリターン、垂直タブ、フォームフィード) 。"

#: ../../library/stdtypes.rst:3247
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"シーケンスが空でなく、かつ ASCII のタイトルケース文字列になっている場合は "
"``True`` を、そうでなければ ``False`` を返します。「タイトルケース文字列」の"
"定義については :meth:`bytes.title` を参照してください。"

#: ../../library/stdtypes.rst:3262
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr ""
"シーケンス中に大文字アルファベットの ASCII 文字が一つ以上あり、かつ小文字アル"
"ファベットの ASCII 文字が一つも無い場合に ``True`` を返します。そうでなけれ"
"ば ``False`` を返します。"

#: ../../library/stdtypes.rst:3280
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""
"シーケンスに含まれる大文字アルファベットの ASCII 文字を全て小文字アルファベッ"
"トに変換したシーケンスのコピーを返します。"

#: ../../library/stdtypes.rst:3305
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"バイナリシーケンスを ASCII の改行コードで分割し、各行をリストにして返します。"
"このメソッドは :term:`universal newlines` アプローチで行を分割します。 "
"*keepends* 引数に真を与えた場合を除き、改行コードは結果のリストに含まれませ"
"ん。"

#: ../../library/stdtypes.rst:3317
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
":meth:`~bytes.split` とは違って、空シーケンスに対して区切り *sep* を与えて呼"
"び出すと空のリストを返します。またシーケンス末尾に改行コードがある場合、（訳"
"註: その後ろに空行があるとは判断せず）余分な行を生成することはありません::"

#: ../../library/stdtypes.rst:3330
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"シーケンスに含まれる小文字アルファベットの ASCII 文字を全て大文字アルファベッ"
"トに変換し、さらに大文字アルファベットを同様に小文字アルファベットに変換した"
"シーケンスのコピーを返します。"

#: ../../library/stdtypes.rst:3342
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""
":func:`str.swapcase()` とは違い、バイナリバージョンのこちらでは ``bin."
"swapcase().swapcase() == bin`` が常に成り立ちます。一般的に Unicode 文字の大"
"文字小文字変換は対称的ではありませんが、 ASCII 文字の場合は対称的です。"

#: ../../library/stdtypes.rst:3356
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""
"タイトルケース化したバイナリシーケンスを返します。具体的には、各単語が大文字"
"アルファベットの ASCII 文字で始まり、かつ残りの文字が小文字アルファベットに"
"なっているシーケンスが返ります。大文字小文字の区別が無いバイト値については変"
"更されずそのままになります。"

#: ../../library/stdtypes.rst:3365
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"ここでの小文字の ASCII 文字とは ``b'abcdefghijklmnopqrstuvwxyz'`` に含まれる"
"バイト値です。また大文字の ASCII 文字とは ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`` "
"に含まれるバイト値です。その他のバイト値については、大文字小文字の区別はあり"
"ません。"

#: ../../library/stdtypes.rst:3378
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr "正規表現を使うことでアポストロフィに対応できます::"

#: ../../library/stdtypes.rst:3399
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""
"シーケンスに含まれる小文字アルファベットの ASCII 文字を全て大文字アルファベッ"
"トに変換したシーケンスのコピーを返します。"

#: ../../library/stdtypes.rst:3420
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"長さが *width* になるよう ASCII ``b'0'`` で左詰めしたシーケンスのコピーを返し"
"ます。先頭が符号接頭辞 (``b'+'``/``b'-'``) だった場合、 ``b'0'`` は符号の前で"
"はなく *後* に挿入されます。 :class:`bytes` オブジェクトの場合、 *width* が "
"``len(seq)`` 以下であれば元のシーケンスが返ります。"

#: ../../library/stdtypes.rst:3442
msgid "``printf``-style Bytes Formatting"
msgstr "``printf`` 形式での bytes の書式化"

#: ../../library/stdtypes.rst:3459
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"ここで述べる書式化演算には様々な癖があり、よく間違いの元になっています (タプ"
"ルや辞書を正しく表示できないなど)。もし表示する値がタプルや辞書かもしれない場"
"合、それをタプルに包むようにしてください。"

#: ../../library/stdtypes.rst:3464
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""
"bytes オブジェクト (``bytes``/``bytearray``) には固有の操作: ``%`` 演算子 (モ"
"ジュロ) があります。この演算子は bytes の *書式化* または *補間* 演算子とも呼"
"ばれます。``format % values`` (*format* は bytes オブジェクト) とすると、"
"*format* 中の ``%`` 変換指定は *values* 中のゼロ個またはそれ以上の要素で置換"
"されます。この動作は C 言語における :c:func:`sprintf` に似ています。"

#: ../../library/stdtypes.rst:3471
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"*format* が単一の引数しか要求しない場合、 *values* はタプルではない単一のオブ"
"ジェクトで問題ありません。 [5]_ それ以外の場合、 *values* は書式シーケンス"
"（訳註: 先の例での *format* ）中で指定された項目と正確に同じ数の要素を含むタ"
"プルか、単一のマッピング型のオブジェクト (たとえば辞書) でなければなりませ"
"ん。"

#: ../../library/stdtypes.rst:3505
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""
"``%`` 演算子の右側の引数が辞書の場合 (またはその他のマッピング型の場合) 、 "
"bytes オブジェクト中のフォーマットには、辞書のキーを丸括弧で囲って文字 "
"``'%'`` の直後に書いたものが含まれていなければ *なりません* 。マップキーは書"
"式化したい値をマッピングから選び出します。例えば:"

#: ../../library/stdtypes.rst:3579
msgid "Single byte (accepts integer or single byte objects)."
msgstr ""
"1 バイト (整数または要素 1 つの ``bytes``/``bytearray`` オブジェクトを受理し"
"ます)"

#: ../../library/stdtypes.rst:3582
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/stdtypes.rst:3582
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`__bytes__`)."
msgstr ""
"バイナリシーケンス (:ref:`buffer protocol <bufferobjects>` をサポートする"
"か、 :meth:`__bytes__` メソッドがあるオブジェクト)"

#: ../../library/stdtypes.rst:3586
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'s'`` は ``'b'`` の別名です。Python 2/3 の両方を対象としたコードでのみ使用"
"すべきです。"

#: ../../library/stdtypes.rst:3589
msgid ""
"Bytes (converts any Python object using ``repr(obj).encode('ascii', "
"'backslashreplace')``)."
msgstr ""
"バイナリシーケンス (Python オブジェクトを ``repr(obj).encode('ascii', "
"'backslashreplace')`` で変換します)。"

#: ../../library/stdtypes.rst:3592
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'r'`` は ``'a'`` の別名です。Python 2/3 の両方を対象としたコードでのみ使用"
"すべきです。"

#: ../../library/stdtypes.rst:3592
msgid "\\(7)"
msgstr "\\(7)"

#: ../../library/stdtypes.rst:3627
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s'`` は非推奨ですが、3.x 系では削除されません。"

#: ../../library/stdtypes.rst:3630
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r'`` は非推奨ですが、3.x 系では削除されません。"

#: ../../library/stdtypes.rst:3642
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` - bytes と bytearray への % 書式化の追加"

#: ../../library/stdtypes.rst:3649
msgid "Memory Views"
msgstr "メモリビュー"

#: ../../library/stdtypes.rst:3651
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
":class:`memoryview` オブジェクトは、Python コードが :ref:`バッファプロトコル "
"<bufferobjects>` をサポートするオブジェクトの内部データへ、コピーすることなく"
"アクセスすることを可能にします。"

#: ../../library/stdtypes.rst:3657
msgid ""
"Create a :class:`memoryview` that references *object*.  *object* must "
"support the buffer protocol.  Built-in objects that support the buffer "
"protocol include :class:`bytes` and :class:`bytearray`."
msgstr ""
"*object* を参照する :class:`memoryview` を作成します。 *object* はバッファプ"
"ロトコルをサポートしていなければなりません。バッファプロトコルをサポートする"
"組み込みオブジェクトには、 :class:`bytes` 、 :class:`bytearray` などがありま"
"す。"

#: ../../library/stdtypes.rst:3661
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating *object*.  For many simple types such "
"as :class:`bytes` and :class:`bytearray`, an element is a single byte, but "
"other types such as :class:`array.array` may have bigger elements."
msgstr ""
":class:`memoryview` は元となる *object* が扱うメモリーの最小単位を *要素* と"
"して扱います。多くの単純なオブジェクト、例えば :class:`bytes` や :class:"
"`bytearray` では、要素は単バイトになりますが、他の :class:`array.array` 等の"
"型では、要素はより大きくなりえます。"

#: ../../library/stdtypes.rst:3666
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`. If "
"``view.ndim = 0``, the length is 1. If ``view.ndim = 1``, the length is "
"equal to the number of elements in the view. For higher dimensions, the "
"length is equal to the length of the nested list representation of the view. "
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""
"メモリビューの長さ ``len(view)`` は、 :class:`~memoryview.tolist` で得られる"
"リストの長さとなります。``view.ndim = 0`` なら、長さは 1 です。``view.ndim = "
"1`` なら、長さはビューの要素数と等しいです。より高次元では、長さはビューのネ"
"ストされたリスト表現の長さと等しいです。要素一つあたりのバイト数は :class:"
"`~memoryview.itemsize` 属性から取得できます。"

#: ../../library/stdtypes.rst:3673
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""
":class:`memoryview` はスライスおよびインデックス指定で内容を取得できます。一"
"次元のスライスは部分ビューになります::"

#: ../../library/stdtypes.rst:3686
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"もしメモリビューの :class:`~memoryview.format` が :mod:`struct` モジュールに"
"よって定義されているネイティブのフォーマット指定子であれば、整数または整数の"
"タプルでのインデックス指定により適切な型の *要素1つ* を得ることができます。一"
"次元のメモリビューでは、整数または整数 1 つのタプルでインデックス指定できま"
"す。多次元のメモリビューでは、その次元数を *ndim* としたとき、ちょうど "
"*ndim* 個の整数からなるタプルでインデックス指定できます。ゼロ次元のメモリ"
"ビューでは、空のタプルでインデックス指定できます。"

#: ../../library/stdtypes.rst:3695
msgid "Here is an example with a non-byte format::"
msgstr ":class:`~memoryview.format` が単バイト単位ではない例を示します::"

#: ../../library/stdtypes.rst:3707
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""
"メモリビューの参照しているオブジェクトが書き込み可能であれば、一次元スライス"
"での代入が可能です。ただしサイズの変更はできません::"

#: ../../library/stdtypes.rst:3728
msgid ""
"One-dimensional memoryviews of hashable (read-only) types with formats 'B', "
"'b' or 'c' are also hashable. The hash is defined as ``hash(m) == hash(m."
"tobytes())``::"
msgstr ""
"'B', 'b', 'c' いずれかのフォーマットのハッシュ可能な (読み出し専用の) 型の1次"
"元メモリビューもまた、ハッシュ可能です。ハッシュは ``hash(m) == hash(m."
"tobytes())`` として定義されています::"

#: ../../library/stdtypes.rst:3740
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now hashable."
msgstr ""
"1 次元のメモリビューがスライス可能になりました。 'B', 'b', 'c' いずれかの"
"フォーマットの 1 次元のメモリビューがハッシュ可能になりました。"

#: ../../library/stdtypes.rst:3744
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""
"memoryview は自動的に :class:`collections.abc.Sequence` へ登録されるようにな"
"りました。"

#: ../../library/stdtypes.rst:3748
msgid "memoryviews can now be indexed with tuple of integers."
msgstr "メモリビューは整数のタプルでインデックス指定できるようになりました。"

#: ../../library/stdtypes.rst:3751
msgid ":class:`memoryview` has several methods:"
msgstr ":class:`memoryview` にはいくつかのメソッドがあります:"

#: ../../library/stdtypes.rst:3755
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"memoryview と :pep:`3118` エクスポーターは、 shape が同じで、 :mod:`struct` "
"のフォーマットで解釈したときの値が同じ場合に同値になります。"

#: ../../library/stdtypes.rst:3759
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
":meth:`tolist` がサポートしている :mod:`struct` フォーマットの一部では、 ``v."
"tolist() == w.tolist()`` が成り立つときに ``v`` == ``w`` になります::"

#: ../../library/stdtypes.rst:3778
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""
"どちらかの書式文字列が :mod:`struct` モジュールにサポートされていなければ、 "
"(書式文字列とバッファの内容が同一でも) オブジェクトは常に等しくないものとして"
"比較されます::"

#: ../../library/stdtypes.rst:3794
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""
"浮動小数点数の場合と同様 memoryview オブジェクトに対する ``v is w`` は ``v "
"== w`` を意味しないことに注意してください。"

#: ../../library/stdtypes.rst:3797
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""
"以前のバージョンは、要素フォーマットと論理的な配列構造を無視して生のメモリを"
"比較していました。"

#: ../../library/stdtypes.rst:3803
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"バッファ中のデータをバイト文字列として返します。これはメモリビューに対して :"
"class:`bytes` コンストラクタを呼び出すのと同等です。 ::"

#: ../../library/stdtypes.rst:3812
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"連続でない配列については、結果はすべての要素がバイトに変換されたものを含むフ"
"ラットなリスト表現に等しくなります。 :meth:`tobytes` は、 :mod:`struct` モ"
"ジュール文法にないものを含むすべての書式文字列をサポートします。"

#: ../../library/stdtypes.rst:3817
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""
"*order* は {'C', 'F', 'A'} のいずれかを取ることができます。 *order* が 'C' "
"か 'F' の場合、元の配列は C または Fortran のデータ並びにそれぞれ変換されま"
"す。連続したデータに対するビューの場合、 'A' は物理メモリ上のデータの正確なコ"
"ピーを返します。特に、メモリ上における Fortran のデータ並びは保存されます。不"
"連続なデータに対するビューの場合、データはまず C のデータ並びに変換されま"
"す。 *order=None* は *order='C'* と同じです。"

#: ../../library/stdtypes.rst:3826
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr "バッファ中の各バイトを 2 つの 16 進数で表した文字列を返します::"

#: ../../library/stdtypes.rst:3835
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
":meth:`bytes.hex` と同様に、 :meth:`memoryview.hex` は、16進数出力のバイト文"
"字列を分割するセパレータを挿入するためのオプションパラメータ *sep* と "
"*bytes_per_sep* をサポートするようになりました。"

#: ../../library/stdtypes.rst:3842
msgid "Return the data in the buffer as a list of elements. ::"
msgstr "バッファ中のデータを要素のリストとして返します。 ::"

#: ../../library/stdtypes.rst:3852
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""
":meth:`tolist` が :mod:`struct` モジュール文法に含まれるすべての単一文字の "
"native フォーマットと多次元の表現をサポートするようになりました。"

#: ../../library/stdtypes.rst:3859
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr ""
"読み込み専用のメモリビューオブジェクトを返します。元のメモリビューオブジェク"
"トは変更されません。 ::"

#: ../../library/stdtypes.rst:3878
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"memoryview オブジェクトによって晒されている、元になるバッファを解放します。多"
"くのオブジェクトはビューに支配されているときに特殊なふるまいをします (例え"
"ば、 :class:`bytearray` は大きさの変更を一時的に禁止します)。ですから、"
"release() を呼び出すことは、これらの制約をできるだけ早く取り除く (そしてぶら"
"下がったリソースをすべて解放する) のに便利です。"

#: ../../library/stdtypes.rst:3884
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""
"このメソッドが呼ばれた後、このビュー上のそれ以上の演算は :class:`ValueError` "
"を送出します (複数回呼ばれえる :meth:`release()` 自身は除きます)::"

#: ../../library/stdtypes.rst:3895
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""
"コンテキストマネージャプロトコルは、 ``with`` 文を使って同様の効果を得るのに"
"使えます::"

#: ../../library/stdtypes.rst:3911
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""
"memoryview を新しいフォーマットか shape にキャストします。 *shape* はデフォル"
"トで ``[byte_length//new_itemsize]`` で、 1次元配列になります。戻り値は "
"memoryview ですが、バッファー自体はコピーされません。サポートされている変換"
"は 1次元配列 -> C言語型の連続配列 と C言語型の連続配列 -> 1次元配列 です（参"
"考: :term:`contiguous`）。"

#: ../../library/stdtypes.rst:3917
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length."
msgstr ""
"キャスト後のフォーマットは :mod:`struct` 文法の単一要素ネイティブフォーマット"
"に制限されます。フォーマットのうちの一つはバイトフォーマット ('B', 'b', 'c') "
"でなければなりません。結果のバイト長はオリジナルの長さと同じでなければなりま"
"せん。"

#: ../../library/stdtypes.rst:3922
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "1次元 long から 1次元 unsigned byte へのキャスト::"

#: ../../library/stdtypes.rst:3945
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "1次元 unsigned byte から 1次元 char へのキャスト::"

#: ../../library/stdtypes.rst:3958
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "1次元 byte から 3次元 int へ、そして 1次元 signed char へのキャスト::"

#: ../../library/stdtypes.rst:3984
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr "1次元 unsigned long から 2次元 unsigned long へのキャスト::"

#: ../../library/stdtypes.rst:3998
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""
"単バイトのビューへキャストする場合、キャスト元のフォーマットについて制約は無"
"くなりました。"

#: ../../library/stdtypes.rst:4001
msgid "There are also several readonly attributes available:"
msgstr "読み出し専用の属性もいくつか使えます:"

#: ../../library/stdtypes.rst:4005
msgid "The underlying object of the memoryview::"
msgstr "memoryview が参照しているオブジェクト::"

#: ../../library/stdtypes.rst:4016
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. その配列が連続表"
"現において利用するスペースです。これは ``len(m)`` と一致するとは限りません::"

#: ../../library/stdtypes.rst:4035
msgid "Multi-dimensional arrays::"
msgstr "多次元配列::"

#: ../../library/stdtypes.rst:4052
msgid "A bool indicating whether the memory is read only."
msgstr "メモリが読み出し専用かどうかを示す真偽値です。"

#: ../../library/stdtypes.rst:4056
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"ビューの中の各要素に対する (:mod:`struct` モジュールスタイルの) フォーマット"
"を含む文字列。 memoryview は、任意のフォーマット文字列を使ってエクスポーター"
"から作成することができます。しかし、いくつかのメソッド(例えば :meth:"
"`tolist`) はネイティブの単一要素フォーマットに制限されます。"

#: ../../library/stdtypes.rst:4061
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"フォーマット ``'B'`` は struct モジュール構文で扱われるようになりました。これ"
"は ``memoryview(b'abc')[0] == b'abc'[0] == 97`` ということを意味します。"

#: ../../library/stdtypes.rst:4067
msgid "The size in bytes of each element of the memoryview::"
msgstr "memoryview の各要素のバイト単位の大きさ::"

#: ../../library/stdtypes.rst:4080
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr "メモリが表す多次元配列が何次元かを示す整数です。"

#: ../../library/stdtypes.rst:4085
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"メモリが表している N 次元配列の形状を表す、長さ :attr:`ndim` の整数のタプルで"
"す。"

#: ../../library/stdtypes.rst:4088 ../../library/stdtypes.rst:4096
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr ""
"ndim = 0 の場合は ``None`` ではなく空のタプルとなるよう変更されました。"

#: ../../library/stdtypes.rst:4093
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"配列のそれぞれの次元に対して、それぞれの要素にアクセスするのに必要なバイト数"
"を表す、長さ :attr:`ndim` の整数のタプルです。"

#: ../../library/stdtypes.rst:4101
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""
"PILスタイルの配列の内部で利用している値。この値はただの情報として公開されてい"
"ます。"

#: ../../library/stdtypes.rst:4105
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr ""
"メモリーが C 形式の順序で連続しているかどうかを示す真偽値（参考: :term:"
"`contiguous` ）。"

#: ../../library/stdtypes.rst:4111
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr ""
"メモリーがFortran形式の順序で連続しているかどうかを示す真偽値（参考: :term:"
"`contiguous` ）。"

#: ../../library/stdtypes.rst:4117
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr ""
"メモリーが連続しているかどうかを示す真偽値（参考: :term:`contiguous` ）。"

#: ../../library/stdtypes.rst:4125
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "set（集合）型 --- :class:`set`, :class:`frozenset`"

#: ../../library/stdtypes.rst:4129
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
":dfn:`set` オブジェクトは、固有の :term:`hashable` オブジェクトの順序なしコレ"
"クションです。通常の用途には、帰属テスト、シーケンスからの重複除去、積集合、"
"和集合、差集合、対称差 (排他的論理和) のような数学的演算の計算が含まれます。"
"(他のコンテナについては組み込みの :class:`dict`, :class:`list`, :class:"
"`tuple` クラスや :mod:`collections` モジュールを参照してください。)"

#: ../../library/stdtypes.rst:4136
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"集合は、他のコレクションと同様、 ``x in set``, ``len(set)``, ``for x in "
"set`` をサポートします。コレクションには順序がないので、集合は挿入の順序や要"
"素の位置を記録しません。従って、集合はインデクシング、スライシング、その他の"
"シーケンス的な振舞いをサポートしません。"

#: ../../library/stdtypes.rst:4141
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
":class:`set` および :class:`frozenset` という、2つの組み込みの集合型がありま"
"す。 :class:`set` はミュータブルで、:meth:`~set.add` や :meth:`~set.remove` "
"のようなメソッドを使って内容を変更できます。ミュータブルなため、ハッシュ値を"
"持たず、また辞書のキーや他の集合の要素として用いることができません。一方、:"
"class:`frozenset` 型はイミュータブルで、:term:`ハッシュ可能<hashable>` です。"
"作成後に内容を改変できないため、辞書のキーや他の集合の要素として用いることが"
"できます。"

#: ../../library/stdtypes.rst:4149
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"空でない :class:`set` (:class:`frozenset` ではない) は、:class:`set` コンスト"
"ラクタに加え、要素を波括弧中にカンマで区切って列挙することでも生成できます。"
"例: ``{'jack', 'sjoerd'}``。"

#: ../../library/stdtypes.rst:4153
msgid "The constructors for both classes work the same:"
msgstr "どちらのクラスのコンストラクタも同様に働きます:"

#: ../../library/stdtypes.rst:4158
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"*iterable* から要素を取り込んだ、新しい :class:`set` もしくは :class:"
"`frozenset` オブジェクトを返します。 集合の要素は :term:`ハッシュ可能 "
"<hashable>` なものでなくてはなりません。集合の集合を表現するためには、内側の"
"集合は :class:`frozenset` オブジェクトでなくてはなりません。*iterable* が指定"
"されない場合、新しい空の集合が返されます。"

#: ../../library/stdtypes.rst:4164
msgid "Sets can be created by several means:"
msgstr "集合はいくつかの方法で生成できます:"

#: ../../library/stdtypes.rst:4166
msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr "波括弧内にカンマ区切りで要素を列挙する: ``{'jack', 'sjoerd'}``"

#: ../../library/stdtypes.rst:4167
msgid ""
"Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr "集合内包表記を使う: ``{c for c in 'abracadabra' if c not in 'abc'}``"

#: ../../library/stdtypes.rst:4168
msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr ""
"型コンストラクタを使う: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"

#: ../../library/stdtypes.rst:4170
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
":class:`set` および :class:`frozenset` のインスタンスは以下の操作を提供しま"
"す:"

#: ../../library/stdtypes.rst:4175
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "集合 *s* の要素数 (*s* の濃度) を返します。"

#: ../../library/stdtypes.rst:4179
msgid "Test *x* for membership in *s*."
msgstr "*x* が *s* のメンバーに含まれるか判定します。"

#: ../../library/stdtypes.rst:4183
msgid "Test *x* for non-membership in *s*."
msgstr "*x* が *s* のメンバーに含まれていないことを判定します。"

#: ../../library/stdtypes.rst:4187
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"集合が *other* と共通の要素を持たないとき、``True`` を返します。集合はそれら"
"の積集合が空集合となるときのみ、互いに素 (disjoint) となります。"

#: ../../library/stdtypes.rst:4193
msgid "Test whether every element in the set is in *other*."
msgstr "set の全ての要素が *other* に含まれるか判定します。"

#: ../../library/stdtypes.rst:4197
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"set が *other* の真部分集合であるかを判定します。つまり、 ``set <= other and "
"set != other`` と等価です。"

#: ../../library/stdtypes.rst:4203
msgid "Test whether every element in *other* is in the set."
msgstr "*other* の全ての要素が set に含まれるか判定します。"

#: ../../library/stdtypes.rst:4207
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"set が *other* の真上位集合であるかを判定します。つまり、 ``set >= other and "
"set != other`` と等価です。"

#: ../../library/stdtypes.rst:4213
msgid "Return a new set with elements from the set and all others."
msgstr "set と全ての other の要素からなる新しい集合を返します。"

#: ../../library/stdtypes.rst:4218
msgid "Return a new set with elements common to the set and all others."
msgstr "set と全ての other に共通する要素を持つ、新しい集合を返します。"

#: ../../library/stdtypes.rst:4223
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""
"set に含まれて、かつ、全ての other に含まれない要素を持つ、新しい集合を返しま"
"す。"

#: ../../library/stdtypes.rst:4228
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"set と *other* のいずれか一方だけに含まれる要素を持つ新しい集合を返します。"

#: ../../library/stdtypes.rst:4232
msgid "Return a shallow copy of the set."
msgstr "集合の浅いコピーを返します。"

#: ../../library/stdtypes.rst:4235
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, :meth:`symmetric_difference`, :meth:`issubset`, and :meth:"
"`issuperset` methods will accept any iterable as an argument.  In contrast, "
"their operator based counterparts require their arguments to be sets.  This "
"precludes error-prone constructions like ``set('abc') & 'cbs'`` in favor of "
"the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"なお、演算子でない版の :meth:`union`, :meth:`intersection`, :meth:"
"`difference`, :meth:`symmetric_difference`, :meth:`issubset`, :meth:"
"`issuperset` メソッドは、任意のイテラブルを引数として受け付けます。対して、演"
"算子を使う版では、引数は集合でなくてはなりません。これは、``set('abc') & "
"'cbs'`` のような誤りがちな構文を予防し、より読みやすい ``set('abc')."
"intersection('cbs')`` を支持します。"

#: ../../library/stdtypes.rst:4242
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
":class:`set` と :class:`frozenset` のどちらも、集合同士の比較をサポートしま"
"す。二つの集合は、それぞれの集合の要素全てが他方にも含まれている (互いに他方"
"の部分集合である) とき、かつそのときに限り等しいです。一方の集合が他方の集合"
"の真部分集合である (部分集合であるが等しくない) とき、かつそのときに限り一方"
"の集合は他方の集合より小さいです。一方の集合が他方の集合の真上位集合である "
"(上位集合であるが等しくない) とき、かつそのときに限り一方の集合は他方の集合よ"
"り大きいです。"

#: ../../library/stdtypes.rst:4249
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
":class:`set` のインスタンスは、 :class:`frozenset` のインスタンスと、要素に基"
"づいて比較されます。例えば、 ``set('abc') == frozenset('abc')`` や "
"``set('abc') in set([frozenset('abc')])`` は ``True`` を返します。"

#: ../../library/stdtypes.rst:4253
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"部分集合と等価性の比較は全順序付けを行う関数へと一般化することはできません。"
"例えば、互いに素である二つの非空集合は、等しくなく、他方の部分集合でもありま"
"せんから、以下の *すべて* に ``False`` を返します: ``a<b``, ``a==b``, そして "
"``a>b``."

#: ../../library/stdtypes.rst:4258
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"集合は半順序（部分集合関係）しか定義しないので、集合のリストにおける :meth:"
"`list.sort` メソッドの出力は未定義です。"

#: ../../library/stdtypes.rst:4261
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""
"集合の要素は、辞書のキーのように、 :term:`ハッシュ可能 <hashable>` でなければ"
"なりません。"

#: ../../library/stdtypes.rst:4263
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
":class:`set` インスタンスと :class:`frozenset` インスタンスを取り混ぜての二項"
"演算は、第一被演算子の型を返します。例えば: ``frozenset('ab') | set('bc')`` "
"は :class:`frozenset` インスタンスを返します。"

#: ../../library/stdtypes.rst:4267
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"以下の表に挙げる演算は :class:`set` に適用されますが、:class:`frozenset` のイ"
"ミュータブルなインスタンスには適用されません:"

#: ../../library/stdtypes.rst:4273
msgid "Update the set, adding elements from all others."
msgstr "全ての other の要素を追加し、 set を更新します。"

#: ../../library/stdtypes.rst:4278
msgid "Update the set, keeping only elements found in it and all others."
msgstr "元の set と全ての other に共通する要素だけを残して set を更新します。"

#: ../../library/stdtypes.rst:4283
msgid "Update the set, removing elements found in others."
msgstr "*other* に含まれる要素を取り除き、 set を更新します。"

#: ../../library/stdtypes.rst:4288
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr "どちらかにのみ含まれて、共通には持たない要素のみで set を更新します。"

#: ../../library/stdtypes.rst:4292
msgid "Add element *elem* to the set."
msgstr "要素 *elem* を set に追加します。"

#: ../../library/stdtypes.rst:4296
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"要素 *elem* を set から取り除きます。*elem* が set に含まれていなければ :exc:"
"`KeyError` を送出します。"

#: ../../library/stdtypes.rst:4301
msgid "Remove element *elem* from the set if it is present."
msgstr "要素 *elem* が set に含まれていれば、取り除きます。"

#: ../../library/stdtypes.rst:4305
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"*s* から任意の要素を取り除き、それを返します。集合が空の場合、 :exc:"
"`KeyError` を送出します"

#: ../../library/stdtypes.rst:4310
msgid "Remove all elements from the set."
msgstr "set の全ての要素を取り除きます。"

#: ../../library/stdtypes.rst:4313
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"なお、演算子でない版の :meth:`update`, :meth:`intersection_update`, :meth:"
"`difference_update`, および :meth:`symmetric_difference_update` メソッドは、"
"任意のイテラブルを引数として受け付けます。"

#: ../../library/stdtypes.rst:4318
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :"
"meth:`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, a temporary one is created from *elem*."
msgstr ""
":meth:`__contains__`, :meth:`remove`, :meth:`discard` メソッドの引数 *elem* "
"は集合かもしれないことに注意してください。\n"
"その集合と等価な :class:`frozenset` の検索をサポートするために、 *elem* から"
"一時的な frozenset を作成します。"

#: ../../library/stdtypes.rst:4326
msgid "Mapping Types --- :class:`dict`"
msgstr "マッピング型 --- :class:`dict`"

#: ../../library/stdtypes.rst:4336
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
":term:`マッピング <mapping>` オブジェクトは、 :term:`ハッシュ可能 "
"<hashable>` な値を任意のオブジェクトに対応付けます。マッピングはミュータブル"
"なオブジェクトです。現在、標準のマッピング型は辞書 (:dfn:`dictionary`) だけで"
"す。 (他のコンテナについては組み込みの :class:`list`, :class:`set`, および :"
"class:`tuple` クラスと、 :mod:`collections` モジュールを参照してください。)"

#: ../../library/stdtypes.rst:4342
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys. Values that compare equal (such as ``1``, ``1.0``, "
"and ``True``) can be used interchangeably to index the same dictionary entry."
msgstr ""
"辞書のキーには、*ほぼ*どんな値も使うことができます。\n"
"キーとして使えないのは、 :term:`hashable` (ハッシュ可能) でない値、すなわちリ"
"ストや辞書のようなミュータブルな型 (内包する値ではなくオブジェクト自体が同一"
"であるかによって比較が行われるような型)です。\n"
"比較した際に等しいとみなされる値 (例えば ``1`` と ``1.0`` と ``True``) は、ど"
"れを使っても同じエントリーに関連付けられます。"

#: ../../library/stdtypes.rst:4353
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"オプションの位置引数と空の可能性もあるキーワード引数の集合により初期化された"
"新しい辞書を返します。"

#: ../../library/stdtypes.rst:4356
msgid "Dictionaries can be created by several means:"
msgstr "辞書はいくつかの方法で生成できます:"

#: ../../library/stdtypes.rst:4358
msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack': "
"4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""
"波括弧内にカンマ区切りで ``key: value`` 対を列挙する: ``{'jack': 4098, "
"'sjoerd': 4127}`` あるいは ``{4098: 'jack', 4127: 'sjoerd'}``"

#: ../../library/stdtypes.rst:4360
msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr "辞書内包表記を使う: ``{}``, ``{x: x ** 2 for x in range(10)}``"

#: ../../library/stdtypes.rst:4361
msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"
msgstr ""
"型コンストラクタを使う: ``dict()``, ``dict([('foo', 100), ('bar', 200)])``, "
"``dict(foo=100, bar=200)``"

#: ../../library/stdtypes.rst:4364
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""
"位置引数が何も与えられなかった場合、空の辞書が作成されます。位置引数が与えら"
"れ、それがマッピングオブジェクトだった場合、そのマッピングオブジェクトと同じ"
"キーと値のペアを持つ辞書が作成されます。それ以外の場合、位置引数は :term:"
"`iterable` オブジェクトでなければなりません。iterable のそれぞれの要素自身"
"は、ちょうど 2 個のオブジェクトを持つイテラブルでなければなりません。それぞれ"
"の要素の最初のオブジェクトは新しい辞書のキーになり、2 番目のオブジェクトはそ"
"れに対応する値になります。同一のキーが 2 回以上現れた場合は、そのキーの最後の"
"値が新しい辞書での対応する値になります。"

#: ../../library/stdtypes.rst:4374
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""
"キーワード引数が与えられた場合、キーワード引数とその値が位置引数から作られた"
"辞書に追加されます。既に存在しているキーが追加された場合、キーワード引数の値"
"は位置引数の値を置き換えます。"

#: ../../library/stdtypes.rst:4379
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"例を出すと、次の例は全て ``{\"one\": 1, \"two\": 2, \"three\": 3}`` に等しい"
"辞書を返します::"

#: ../../library/stdtypes.rst:4391
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"最初の例のようにキーワード引数を与える方法では、キーは有効な Python の識別子"
"でなければなりません。それ以外の方法では、辞書のキーとして有効などんなキーで"
"も使えます。"

#: ../../library/stdtypes.rst:4395
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"以下は辞書型がサポートする操作です (それゆえ、カスタムのマップ型もこれらの操"
"作をサポートするべきです):"

#: ../../library/stdtypes.rst:4400
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr "辞書 *d* で使われている全てのキーのリストを返します。"

#: ../../library/stdtypes.rst:4404
msgid "Return the number of items in the dictionary *d*."
msgstr "辞書 *d* の項目数を返します。"

#: ../../library/stdtypes.rst:4408
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""
"*d* のキー *key* の項目を返します。マップに *key* が存在しなければ、 :exc:"
"`KeyError` を送出します。"

#: ../../library/stdtypes.rst:4413
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""
"辞書のサブクラスが :meth:`__missing__` メソッドを定義していて、 *key* が存在"
"しない場合、 ``d[key]`` 演算はこのメソッドをキー *key* を引数として呼び出しま"
"す。 ``d[key]`` 演算は、 ``__missing__(key)`` の呼び出しによって返された値を"
"そのまま返すか、送出されたものをそのまま送出します。他の演算やメソッドは :"
"meth:`__missing__` を呼び出しません。 :meth:`__missing__` が定義されていない"
"場合、 :exc:`KeyError` が送出されます。 :meth:`__missing__` はメソッドでなけ"
"ればならず、インスタンス変数であってはなりません::"

#: ../../library/stdtypes.rst:4431
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"ここでお見せした例は :class:`collections.Counter` 実装の一部です。これとは"
"違った ``__missing__`` が :class:`collections.defaultdict` で使われています。"

#: ../../library/stdtypes.rst:4437
msgid "Set ``d[key]`` to *value*."
msgstr "``d[key]`` に *value* を設定します。"

#: ../../library/stdtypes.rst:4441
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""
"*d* から ``d[key]`` を削除します。マップに *key* が存在しなければ、 :exc:"
"`KeyError` を送出します。"

#: ../../library/stdtypes.rst:4446
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr ""
"*d* がキー *key* を持っていれば ``True`` を、そうでなければ、 ``False`` を返"
"します。"

#: ../../library/stdtypes.rst:4450
msgid "Equivalent to ``not key in d``."
msgstr "``not key in d`` と等価です。"

#: ../../library/stdtypes.rst:4454
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""
"辞書のキーに渡るイテレータを返します。これは ``iter(d.keys())`` へのショート"
"カットです。"

#: ../../library/stdtypes.rst:4459
msgid "Remove all items from the dictionary."
msgstr "辞書の全ての項目を消去します。"

#: ../../library/stdtypes.rst:4463
msgid "Return a shallow copy of the dictionary."
msgstr "辞書の浅いコピーを返します。"

#: ../../library/stdtypes.rst:4467
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""
"*iterable* からキーを取り、値を *value* に設定した、新しい辞書を作成します。"

#: ../../library/stdtypes.rst:4469
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so "
"it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""
":meth:`fromkeys` は新しい辞書を返すクラスメソッドです。\n"
"*value* はデフォルトで ``None`` となります。\n"
"作られる辞書内のすべての値が同一のインスタンスを指すことになるため、*value* "
"にミュータブルなオブジェクト (例えば空のリスト) を指定しても通常意味はありま"
"せん。\n"
"別々の値を指すようにしたい場合は、代わりに :ref:`辞書内包表記 <dict>` を使用"
"してください。"

#: ../../library/stdtypes.rst:4477
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"*key* が辞書にあれば *key* に対する値を、そうでなければ *default* を返しま"
"す。 *default* が与えられなかった場合、デフォルトでは ``None`` となります。そ"
"のため、このメソッドは :exc:`KeyError` を送出することはありません。"

#: ../../library/stdtypes.rst:4483
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"辞書の項目 (``(key, value)`` 対) の新しいビューを返します。:ref:`ビューオブ"
"ジェクトのドキュメント <dict-views>` を参照してください。"

#: ../../library/stdtypes.rst:4488
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""
"辞書のキーの新しいビューを返します。:ref:`ビューオブジェクトのドキュメント "
"<dict-views>` を参照してください。"

#: ../../library/stdtypes.rst:4493
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"*key* が辞書に存在すればその値を辞書から消去して返し、そうでなければ "
"*default* を返します。 *default* が与えられず、かつ *key* が辞書に存在しなけ"
"れば :exc:`KeyError` を送出します。"

#: ../../library/stdtypes.rst:4499
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""
"任意の ``(key, value)`` 対を辞書から消去して返します。\n"
"対は :abbr:`LIFO (後入れ、先出し)` の順序で返却されます。"

#: ../../library/stdtypes.rst:4502
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
"集合のアルゴリズムで使われるのと同じように、 :meth:`popitem` は辞書に繰り返し"
"適用して消去するのに便利です。辞書が空であれば、 :meth:`popitem` の呼び出し"
"は :exc:`KeyError` を送出します。"

#: ../../library/stdtypes.rst:4506
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""
"LIFO 順序が保証されるようになりました。\n"
"以前のバージョンでは、 :meth:`popitem` は任意の key/value 対を返していまし"
"た。"

#: ../../library/stdtypes.rst:4512
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr ""
"辞書のキーに渡る逆イテレータを返します。これは ``reversed(d.keys())`` への"
"ショートカットです。"

#: ../../library/stdtypes.rst:4519
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"もし、 *key* が辞書に存在すれば、その値を返します。そうでなければ、値を "
"*default* として *key* を挿入し、 *default* を返します。 *default* のデフォル"
"トは ``None`` です。"

#: ../../library/stdtypes.rst:4525
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"辞書の内容を *other* のキーと値で更新します。既存のキーは上書きされます。返り"
"値は ``None`` です。"

#: ../../library/stdtypes.rst:4528
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":meth:`update` は、他の辞書オブジェクトでもキー/値の対のイテラブル (タプル、"
"もしくは、長さが2のイテラブル) でも、どちらでも受け付けます。キーワード引数が"
"指定されれば、そのキー/値の対で辞書を更新します: ``d.update(red=1, "
"blue=2)``。"

#: ../../library/stdtypes.rst:4535
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""
"辞書の値の新しいビューを返します。:ref:`ビューオブジェクトのドキュメント "
"<dict-views>` を参照してください。"

#: ../../library/stdtypes.rst:4538
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""
"``dict.values()`` で得られた２つのビューの等しさを比較すると、必ず ``False`` "
"が返ります。\n"
"``dict.values()`` どうしを比較したときも同様です::"

#: ../../library/stdtypes.rst:4548
msgid ""
"Create a new dictionary with the merged keys and values of *d* and *other*, "
"which must both be dictionaries. The values of *other* take priority when "
"*d* and *other* share keys."
msgstr ""
"*d* と *other* のキーと値を統合した新しい辞書を作成します。\n"
"*d* と *other* のキーに重複がある場合は、 *other* の方の値が優先されます。"

#: ../../library/stdtypes.rst:4556
msgid ""
"Update the dictionary *d* with keys and values from *other*, which may be "
"either a :term:`mapping` or an :term:`iterable` of key/value pairs. The "
"values of *other* take priority when *d* and *other* share keys."
msgstr ""
"辞書 *d* のキーと値を *other* で更新します。\n"
"*other* は :term:`マッピング <mapping>` か、またはキーと値のペアの :term:`イ"
"テラブル <iterable>` です。\n"
"*d* と *other* のキーに重複がある場合は、 *other* の方の値が優先されます。"

#: ../../library/stdtypes.rst:4562
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', "
"'>') raise :exc:`TypeError`."
msgstr ""
"複数の辞書は、(順序に関係なく) 同じ ``(key, value)`` の対を持つ場合に、そして"
"その場合にのみ等しくなります。順序比較 ('<', '<=', '>=', '>') は :exc:"
"`TypeError` を送出します。"

#: ../../library/stdtypes.rst:4566
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""
"辞書は挿入順序を保存するようになりました。\n"
"キーの更新は順序には影響が無いことに注意してください。\n"
"いったん削除されてから再度追加されたキーは末尾に挿入されます。::"

#: ../../library/stdtypes.rst:4584
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""
"辞書の順序が挿入順序であることが保証されるようになりました。この振る舞いは "
"CPython 3.6 の実装詳細でした。"

#: ../../library/stdtypes.rst:4588
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr "辞書と辞書のビューは ``reversed()`` で順序を逆にすることができます::"

#: ../../library/stdtypes.rst:4600
msgid "Dictionaries are now reversible."
msgstr "辞書がリバース可能になりました。"

#: ../../library/stdtypes.rst:4605
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""
":class:`dict` の読み出し専用ビューを作るために :class:`types."
"MappingProxyType` を使うことができます。"

#: ../../library/stdtypes.rst:4612
msgid "Dictionary view objects"
msgstr "辞書ビューオブジェクト"

#: ../../library/stdtypes.rst:4614
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""
":meth:`dict.keys`, :meth:`dict.values`, :meth:`dict.items` によって返されるオ"
"ブジェクトは、 *ビューオブジェクト* です。これらは、辞書の項目の動的なビュー"
"を提供し、辞書が変更された時、ビューはその変更を反映します。"

#: ../../library/stdtypes.rst:4619
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"辞書ビューは、イテレートすることで対応するデータを yield できます。また、帰属"
"判定をサポートします:"

#: ../../library/stdtypes.rst:4624
msgid "Return the number of entries in the dictionary."
msgstr "辞書の項目数を返します。"

#: ../../library/stdtypes.rst:4628
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"辞書のキー、値、または (``(key, value)`` のタプルとして表される) 項目に渡るイ"
"テレータを返します。"

#: ../../library/stdtypes.rst:4631
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""
"キーと値は挿入順序で反復されます。\n"
"これにより、 ``(value, key)`` の対の列を ``pairs = zip(d.values(), d."
"keys())`` のように :func:`zip` で作成できます。\n"
"同じリストを作成する他の方法は、 ``pairs = [(v, k) for (k, v) in d."
"items()]`` です。 "

#: ../../library/stdtypes.rst:4636
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"辞書の項目の追加や削除中にビューをイテレートすると、 :exc:`RuntimeError` を送"
"出したり、すべての項目に渡ってイテレートできなかったりします。"

#: ../../library/stdtypes.rst:4639
msgid "Dictionary order is guaranteed to be insertion order."
msgstr "辞書の順序が挿入順序であると保証されるようになりました。"

#: ../../library/stdtypes.rst:4644
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"*x* が元の辞書のキー、値、または項目 (項目の場合、 *x* は ``(key, value)`` タ"
"プルです) にあるとき ``True`` を返します。"

#: ../../library/stdtypes.rst:4649
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr ""
"辞書のキーもしくは値、項目の順序を逆にしたイテレーターを返します。\n"
"戻り値のビューは、挿入された順とは逆の順でイテレートします。"

#: ../../library/stdtypes.rst:4652
msgid "Dictionary views are now reversible."
msgstr "辞書のビューがリバース可能になりました。"

#: ../../library/stdtypes.rst:4657
msgid ""
"Return a :class:`types.MappingProxyType` that wraps the original dictionary "
"to which the view refers."
msgstr ""
"ビューの参照先の辞書をラップする :class:`types.MappingProxyType` オブジェク"
"ト を返します。"

#: ../../library/stdtypes.rst:4662
msgid ""
"Keys views are set-like since their entries are unique and hashable.  If all "
"values are hashable, so that ``(key, value)`` pairs are unique and hashable, "
"then the items view is also set-like.  (Values views are not treated as set-"
"like since the entries are generally not unique.)  For set-like views, all "
"of the operations defined for the abstract base class :class:`collections."
"abc.Set` are available (for example, ``==``, ``<``, or ``^``)."
msgstr ""
"キーのビューは、項目が一意的でハッシュ可能であるという点で、集合に似ていま"
"す。すべての値がハッシュ可能なら、 ``(key, value)`` 対も一意的でハッシュ可能"
"なので、要素のビューも集合に似ています。(値のビューは、要素が一般に一意的でな"
"いことから、集合に似ているとは考えられません。) 集合に似ているビューに対し"
"て、抽象基底クラス :class:`collections.abc.Set` で定義されている全ての演算 "
"(例えば、 ``==``、``<``、``^``) が利用できます。"

#: ../../library/stdtypes.rst:4669
msgid "An example of dictionary view usage::"
msgstr "辞書ビューの使用法の例::"

#: ../../library/stdtypes.rst:4710
msgid "Context Manager Types"
msgstr "コンテキストマネージャ型"

#: ../../library/stdtypes.rst:4717
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"Python の :keyword:`with` 文は、コンテキストマネージャによって定義される実行"
"時コンテキストの概念をサポートします。これは、文の本体が実行される前に進入し"
"文の終わりで脱出する実行時コンテキストを、ユーザ定義クラスが定義できるように"
"する一対のメソッドで実装されます:"

#: ../../library/stdtypes.rst:4725
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"実行時コンテキストに入り、このオブジェクトまたは他の実行時コンテキストに関連"
"したオブジェクトを返します。このメソッドが返す値はこのコンテキストマネージャ"
"を使う :keyword:`with` 文の :keyword:`!as` 節の識別子に束縛されます。"

#: ../../library/stdtypes.rst:4730
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"自分自身を返すコンテキストマネージャの例として :term:`ファイルオブジェクト "
"<file object>` があります。ファイルオブジェクトは __enter__() から自分自身を"
"返し、 :func:`open` が :keyword:`with` 文のコンテキスト式として使われるように"
"します。"

#: ../../library/stdtypes.rst:4734
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""
"関連オブジェクトを返すコンテキストマネージャの例としては :func:`decimal."
"localcontext` が返すものがあります。このマネージャはアクティブな10進数コンテ"
"キストをオリジナルのコンテキストのコピーにセットしてそのコピーを返します。こ"
"うすることで, :keyword:`with` 文の本体の内部で、:keyword:`!with` 文の外側の"
"コードに影響を与えずに、 10進数コンテキストを変更できます。"

#: ../../library/stdtypes.rst:4744
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"実行時コンテキストから抜け、(発生していた場合) 例外を抑制するかどうかを示す"
"ブール値フラグを返します。 :keyword:`with` 文の本体の実行中に例外が発生した場"
"合、引数にはその例外の型と値とトレースバック情報を渡します。そうでない場合、"
"引数は全て ``None`` となります。"

#: ../../library/stdtypes.rst:4749
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""
"このメソッドから真値が返されると :keyword:`with` 文は例外の発生を抑え、 :"
"keyword:`!with` 文の直後の文に実行を続けます。そうでなければ、このメソッドの"
"実行を終えると例外の伝播が続きます。このメソッドの実行中に起きた例外は :"
"keyword:`!with` 文の本体の実行中に起こった例外を置き換えてしまいます。"

#: ../../library/stdtypes.rst:4756
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`__exit__` "
"method has actually failed."
msgstr ""
"渡された例外を明示的に再送出すべきではありません。その代わりに、このメソッド"
"が偽の値を返すことでメソッドの正常終了と送出された例外を抑制しないことを伝え"
"るべきです。このようにすればコンテキストマネージャは :meth:`__exit__` メソッ"
"ド自体が失敗したのかどうかを簡単に見分けることができます。"

#: ../../library/stdtypes.rst:4762
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python は、易しいスレッド同期、ファイルなどのオブジェクトの即時クローズ、アク"
"ティブな小数算術コンテキストの単純な操作をサポートするために、いくつかのコン"
"テキストマネージャを用意しています。各型はコンテキスト管理プロトコルを実装し"
"ているという以上の特別の取り扱いを受けるわけではありません。例については :"
"mod:`contextlib` モジュールを参照してください。"

#: ../../library/stdtypes.rst:4768
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`~contextmanager.__enter__` and :meth:`~contextmanager.__exit__` methods, "
"rather than the iterator produced by an undecorated generator function."
msgstr ""
"Python の :term:`ジェネレータ <generator>` と :class:`contextlib."
"contextmanager`  :term:`デコレータ <decorator>` はこのプロトコルの簡便な実装"
"方法を提供します。ジェネレータ関数を :class:`contextlib.contextmanager` デコ"
"レータでデコレートすると、デコレートされないジェネレータ関数が作成するイテ"
"レータの代わりに、必要な :meth:`~contextmanager.__enter__` および :meth:"
"`~contextmanager.__exit__` メソッドを実装したコンテキストマネージャを返すよう"
"になります。"

#: ../../library/stdtypes.rst:4775
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"これらのメソッドのために Python/C API の中の Python オブジェクトの型構造体に"
"特別なスロットが作られたわけではないことに注意してください。これらのメソッド"
"を定義したい拡張型はこれらを通常の Python からアクセスできるメソッドとして提"
"供しなければなりません。実行時コンテキストを準備するオーバーヘッドに比べた"
"ら、一回のクラス辞書の探索のオーバーヘッドは無視できます。"

#: ../../library/stdtypes.rst:4783
msgid ""
"Type Annotation Types --- :ref:`Generic Alias <types-genericalias>`, :ref:"
"`Union <types-union>`"
msgstr ""
"型アノテーション型 --- :ref:`ジェネリックエイリアス <types-"
"genericalias>` 、 :ref:`ユニオン <types-union>`"

#: ../../library/stdtypes.rst:4788
msgid ""
"The core built-in types for :term:`type annotations <annotation>` are :ref:"
"`Generic Alias <types-genericalias>` and :ref:`Union <types-union>`."
msgstr ""
":term:`型アノテーション <annotation>` の中心となる組み込みの型は :ref:`ジェネ"
"リックエイリアス <types-genericalias>` と :ref:`ユニオン <types-union>` で"
"す。"

#: ../../library/stdtypes.rst:4795
msgid "Generic Alias Type"
msgstr "ジェネリックエイリアス型"

#: ../../library/stdtypes.rst:4801
msgid ""
"``GenericAlias`` objects are generally created by :ref:`subscripting "
"<subscriptions>` a class. They are most often used with :ref:`container "
"classes <sequence-types>`, such as :class:`list` or :class:`dict`. For "
"example, ``list[int]`` is a ``GenericAlias`` object created by subscripting "
"the ``list`` class with the argument :class:`int`. ``GenericAlias`` objects "
"are intended primarily for use with :term:`type annotations <annotation>`."
msgstr ""
"``GenericAlias`` オブジェクトは一般的に、クラスに :ref:`添字表記 "
"<subscriptions>` をすることで作られます。\n"
":class:`list` や :class:`dict` のような :ref:`コンテナ系のクラス <sequence-"
"types>` に対して使われることがほとんどです。\n"
"例えば、 ``list[int]`` は ``list`` クラスに :class:`int` という引数を与えた添"
"字表記をすることで作られる ``GenericAlias`` オブジェクトです。\n"
"``GenericAlias`` オブジェクトは主に :term:`型アノテーション <annotation>` の"
"用途で使われます。"

#: ../../library/stdtypes.rst:4811
msgid ""
"It is generally only possible to subscript a class if the class implements "
"the special method :meth:`~object.__class_getitem__`."
msgstr ""
"一般に、クラスへの添字表記は、そのクラスが特殊メソッド :meth:`~object."
"__class_getitem__` を実装しているときに限り可能です。"

#: ../../library/stdtypes.rst:4814
msgid ""
"A ``GenericAlias`` object acts as a proxy for a :term:`generic type`, "
"implementing *parameterized generics*."
msgstr ""
"``GenericAlias`` オブジェクトは *パラメータ付きジェネリック型* を実装したジェ"
"ネリック型 (:term:`generic type`) の代用として振る舞います。"

#: ../../library/stdtypes.rst:4817
msgid ""
"For a container class, the argument(s) supplied to a :ref:`subscription "
"<subscriptions>` of the class may indicate the type(s) of the elements an "
"object contains. For example, ``set[bytes]`` can be used in type annotations "
"to signify a :class:`set` in which all the elements are of type :class:"
"`bytes`."
msgstr ""
"コンテナクラスに対してクラスの :ref:`添字表記 <subscriptions>` に与えられた単"
"一または複数の引数は、そのオブジェクトが包含する要素の型をあらわします。たと"
"えば ``set[bytes]`` という表記は、全ての要素が :class:`bytes` であるような :"
"class:`set` をあらわす型アノテーションとして使うことができます。"

#: ../../library/stdtypes.rst:4823
msgid ""
"For a class which defines :meth:`~object.__class_getitem__` but is not a "
"container, the argument(s) supplied to a subscription of the class will "
"often indicate the return type(s) of one or more methods defined on an "
"object. For example, :mod:`regular expressions <re>` can be used on both "
"the :class:`str` data type and the :class:`bytes` data type:"
msgstr ""
":meth:`~object.__class_getitem__` メソッドを定義しているけれどもコンテナでな"
"いクラスに対しては、クラスの添字表記に与えられた単一または複数の引数は、しば"
"しばオブジェクトに定義された単一または複数のメソッドの戻り値の型をあらわしま"
"す。たとえば、 :mod:`正規表現操作 <re>` は :class:`str` と :class:`bytes` の"
"両方のデータ型に対して使うことができます:"

#: ../../library/stdtypes.rst:4829
msgid ""
"If ``x = re.search('foo', 'foo')``, ``x`` will be a :ref:`re.Match <match-"
"objects>` object where the return values of ``x.group(0)`` and ``x[0]`` will "
"both be of type :class:`str`. We can represent this kind of object in type "
"annotations with the ``GenericAlias`` ``re.Match[str]``."
msgstr ""
"``x = re.search('foo', 'foo')`` とした場合、 ``x`` は :ref:`re.Match <match-"
"objects>` オブジェクトとなり、 ``x.group(0)`` と ``x[0]`` の戻り値はどちら"
"も :class:`str` となります。このようなオブジェクトは、 ``GenericAlias`` を"
"使った型アノテーション ``re.Match[str]`` で表現することができます。"

#: ../../library/stdtypes.rst:4835
msgid ""
"If ``y = re.search(b'bar', b'bar')``, (note the ``b`` for :class:`bytes`), "
"``y`` will also be an instance of ``re.Match``, but the return values of ``y."
"group(0)`` and ``y[0]`` will both be of type :class:`bytes`. In type "
"annotations, we would represent this variety of :ref:`re.Match <match-"
"objects>` objects with ``re.Match[bytes]``."
msgstr ""
"``y = re.search(b'bar', b'bar')`` (ここで ``b`` は :class:`bytes` 型をあらわ"
"します) とした場合、``y`` もまた ``re.Match`` のインスタンスとなりますが、 "
"``y.group(0)`` と ``y[0]`` の戻り値はどちらも :class:`bytes` 型になります。型"
"アノテーションでは、このような :ref:`re.Match <match-objects>` オブジェクト"
"は ``re.Match[bytes]`` と表現することになるでしょう。"

#: ../../library/stdtypes.rst:4841
msgid ""
"``GenericAlias`` objects are instances of the class :class:`types."
"GenericAlias`, which can also be used to create ``GenericAlias`` objects "
"directly."
msgstr ""
"``GenericAlias`` オブジェクトは :class:`types.GenericAlias` クラスのインスタ"
"ンスです。このクラスは直接 ``GenericAlias`` オブジェクトを生成するのに使うこ"
"ともできます。"

#: ../../library/stdtypes.rst:4847
msgid ""
"Creates a ``GenericAlias`` representing a type ``T`` parameterized by types "
"*X*, *Y*, and more depending on the ``T`` used. For example, a function "
"expecting a :class:`list` containing :class:`float` elements::"
msgstr ""
"型 \"X\", \"Y\", またはさらに多くの引数でパラメータ化される型 ``T`` を表現す"
"る ``GenericAlias`` を生成します。引数の数は ``T`` の使われ方によって決まりま"
"す。たとえば、 :class:`float` 型の要素を含む :class:`list` を引数にとる関数の"
"型アノテーションは次のようになります::"

#: ../../library/stdtypes.rst:4855
msgid ""
"Another example for :term:`mapping` objects, using a :class:`dict`, which is "
"a generic type expecting two type parameters representing the key type and "
"the value type.  In this example, the function expects a ``dict`` with keys "
"of type :class:`str` and values of type :class:`int`::"
msgstr ""
"もうひとつの例として :term:`mapping` オブジェクトの場合を示します。ここでは"
"キーと値の2つの型をパラメータとするジェネリック型である :class:`dict` を使っ"
"ています。この例では、関数はキーが :class:`str` 型、値が :class:`int` 型であ"
"るような ``dict`` を引数にとります::"

#: ../../library/stdtypes.rst:4863
msgid ""
"The builtin functions :func:`isinstance` and :func:`issubclass` do not "
"accept ``GenericAlias`` types for their second argument::"
msgstr ""
"組み込み関数 :func:`isinstance` と :func:`issubclass` は第二引数として "
"``GenericAlias`` 型を指定することはできません::"

#: ../../library/stdtypes.rst:4871
msgid ""
"The Python runtime does not enforce :term:`type annotations <annotation>`. "
"This extends to generic types and their type parameters. When creating a "
"container object from a ``GenericAlias``, the elements in the container are "
"not checked against their type. For example, the following code is "
"discouraged, but will run without errors::"
msgstr ""
"Python 実行時には :term:`型アノテーション <annotation>` は強制されません。こ"
"の性質はジェネリック型とその型パラメータにもおよびます。 ``GenericAlias`` か"
"らコンテナオブジェクトを生成した場合、コンテナ内の要素は型のチェックを受けま"
"せん。たとえば、以下のコードは推奨されませんが、エラーになることなく実行でき"
"ます::"

#: ../../library/stdtypes.rst:4881
msgid ""
"Furthermore, parameterized generics erase type parameters during object "
"creation::"
msgstr ""
"しかも、パラメータ付きジェネリック型は、オブジェクト生成時にパラメータの型情"
"報を削除します::"

#: ../../library/stdtypes.rst:4892
msgid ""
"Calling :func:`repr` or :func:`str` on a generic shows the parameterized "
"type::"
msgstr ""
":func:`repr` や :func:`str` のジェネリック型に対する呼び出しは、パラメータ型"
"を表示します::"

#: ../../library/stdtypes.rst:4900
msgid ""
"The :meth:`~object.__getitem__` method of generic containers will raise an "
"exception to disallow mistakes like ``dict[str][str]``::"
msgstr ""
"ジェネリックコンテナ型の :meth:`~object.__getitem__` メソッドは、 ``dict[str]"
"[str]`` のようなミスを許さないように、例外を送出します::"

#: ../../library/stdtypes.rst:4908
msgid ""
"However, such expressions are valid when :ref:`type variables <generics>` "
"are used.  The index must have as many elements as there are type variable "
"items in the ``GenericAlias`` object's :attr:`~genericalias.__args__`. ::"
msgstr ""
"一方で、同様の式は :ref:`型変数 <generics>` が使われた場合は有効です。添字の"
"数は``GenericAlias`` オブジェクトの :attr:`~genericalias.__args__` 属性におけ"
"る型変数の数と同じでなければなりません::"

#: ../../library/stdtypes.rst:4919
msgid "Standard Generic Classes"
msgstr "標準ジェネリッククラス"

#: ../../library/stdtypes.rst:4921
msgid ""
"The following standard library classes support parameterized generics. This "
"list is non-exhaustive."
msgstr ""

#: ../../library/stdtypes.rst:4924
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../../library/stdtypes.rst:4925
msgid ":class:`list`"
msgstr ":class:`list`"

#: ../../library/stdtypes.rst:4926
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../../library/stdtypes.rst:4927
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../../library/stdtypes.rst:4928
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../../library/stdtypes.rst:4929
msgid ":class:`type`"
msgstr ":class:`type`"

#: ../../library/stdtypes.rst:4930
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../../library/stdtypes.rst:4931
msgid ":class:`collections.defaultdict`"
msgstr ":class:`collections.defaultdict`"

#: ../../library/stdtypes.rst:4932
msgid ":class:`collections.OrderedDict`"
msgstr ":class:`collections.OrderedDict`"

#: ../../library/stdtypes.rst:4933
msgid ":class:`collections.Counter`"
msgstr ":class:`collections.Counter`"

#: ../../library/stdtypes.rst:4934
msgid ":class:`collections.ChainMap`"
msgstr ":class:`collections.ChainMap`"

#: ../../library/stdtypes.rst:4935
msgid ":class:`collections.abc.Awaitable`"
msgstr "’’:class:`collections.abc.Awaitable`"

#: ../../library/stdtypes.rst:4936
msgid ":class:`collections.abc.Coroutine`"
msgstr ":class:`collections.abc.Coroutine`"

#: ../../library/stdtypes.rst:4937
msgid ":class:`collections.abc.AsyncIterable`"
msgstr ":class:`collections.abc.AsyncIterable`"

#: ../../library/stdtypes.rst:4938
msgid ":class:`collections.abc.AsyncIterator`"
msgstr ":class:`collections.abc.AsyncIterator`"

#: ../../library/stdtypes.rst:4939
msgid ":class:`collections.abc.AsyncGenerator`"
msgstr ":class:`collections.abc.AsyncGenerator`"

#: ../../library/stdtypes.rst:4940
msgid ":class:`collections.abc.Iterable`"
msgstr ":class:`collections.abc.Iterable`"

#: ../../library/stdtypes.rst:4941
msgid ":class:`collections.abc.Iterator`"
msgstr ":class:`collections.abc.Iterator`"

#: ../../library/stdtypes.rst:4942
msgid ":class:`collections.abc.Generator`"
msgstr ":class:`collections.abc.Generator`"

#: ../../library/stdtypes.rst:4943
msgid ":class:`collections.abc.Reversible`"
msgstr ":class:`collections.abc.Reversible`"

#: ../../library/stdtypes.rst:4944
msgid ":class:`collections.abc.Container`"
msgstr ":class:`collections.abc.Container`"

#: ../../library/stdtypes.rst:4945
msgid ":class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection`"

#: ../../library/stdtypes.rst:4946
msgid ":class:`collections.abc.Callable`"
msgstr ":class:`collections.abc.Callable`"

#: ../../library/stdtypes.rst:4947
msgid ":class:`collections.abc.Set`"
msgstr ":class:`collections.abc.Set`"

#: ../../library/stdtypes.rst:4948
msgid ":class:`collections.abc.MutableSet`"
msgstr ":class:`collections.abc.MutableSet`"

#: ../../library/stdtypes.rst:4949
msgid ":class:`collections.abc.Mapping`"
msgstr ":class:`collections.abc.Mapping`"

#: ../../library/stdtypes.rst:4950
msgid ":class:`collections.abc.MutableMapping`"
msgstr ":class:`collections.abc.MutableMapping`"

#: ../../library/stdtypes.rst:4951
msgid ":class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence`"

#: ../../library/stdtypes.rst:4952
msgid ":class:`collections.abc.MutableSequence`"
msgstr ":class:`collections.abc.MutableSequence`"

#: ../../library/stdtypes.rst:4953
msgid ":class:`collections.abc.ByteString`"
msgstr ":class:`collections.abc.ByteString`"

#: ../../library/stdtypes.rst:4954
msgid ":class:`collections.abc.MappingView`"
msgstr ":class:`collections.abc.MappingView`"

#: ../../library/stdtypes.rst:4955
msgid ":class:`collections.abc.KeysView`"
msgstr ":class:`collections.abc.KeysView`"

#: ../../library/stdtypes.rst:4956
msgid ":class:`collections.abc.ItemsView`"
msgstr ":class:`collections.abc.ItemsView`"

#: ../../library/stdtypes.rst:4957
msgid ":class:`collections.abc.ValuesView`"
msgstr ":class:`collections.abc.ValuesView`"

#: ../../library/stdtypes.rst:4958
msgid ":class:`contextlib.AbstractContextManager`"
msgstr ":class:`contextlib.AbstractContextManager`"

#: ../../library/stdtypes.rst:4959
msgid ":class:`contextlib.AbstractAsyncContextManager`"
msgstr ":class:`contextlib.AbstractAsyncContextManager`"

#: ../../library/stdtypes.rst:4960
msgid ":class:`dataclasses.Field`"
msgstr ":class:`dataclasses.Field`"

#: ../../library/stdtypes.rst:4961
msgid ":class:`functools.cached_property`"
msgstr ":class:`functools.cached_property`"

#: ../../library/stdtypes.rst:4962
msgid ":class:`functools.partialmethod`"
msgstr ":class:`functools.partialmethod`"

#: ../../library/stdtypes.rst:4963
msgid ":class:`os.PathLike`"
msgstr ":class:`os.PathLike`"

#: ../../library/stdtypes.rst:4964
msgid ":class:`queue.LifoQueue`"
msgstr ":class:`queue.LifoQueue`"

#: ../../library/stdtypes.rst:4965
msgid ":class:`queue.Queue`"
msgstr ":class:`queue.Queue`"

#: ../../library/stdtypes.rst:4966
msgid ":class:`queue.PriorityQueue`"
msgstr ":class:`queue.PriorityQueue`"

#: ../../library/stdtypes.rst:4967
msgid ":class:`queue.SimpleQueue`"
msgstr ":class:`queue.SimpleQueue`"

#: ../../library/stdtypes.rst:4968
msgid ":ref:`re.Pattern <re-objects>`"
msgstr ":ref:`re.Pattern <re-objects>`"

#: ../../library/stdtypes.rst:4969
msgid ":ref:`re.Match <match-objects>`"
msgstr ":ref:`re.Match <match-objects>`"

#: ../../library/stdtypes.rst:4970
msgid ":class:`shelve.BsdDbShelf`"
msgstr ":class:`shelve.BsdDbShelf`"

#: ../../library/stdtypes.rst:4971
msgid ":class:`shelve.DbfilenameShelf`"
msgstr ":class:`shelve.DbfilenameShelf`"

#: ../../library/stdtypes.rst:4972
msgid ":class:`shelve.Shelf`"
msgstr ":class:`shelve.Shelf`"

#: ../../library/stdtypes.rst:4973
msgid ":class:`types.MappingProxyType`"
msgstr ":class:`types.MappingProxyType`"

#: ../../library/stdtypes.rst:4974
msgid ":class:`weakref.WeakKeyDictionary`"
msgstr ":class:`weakref.WeakKeyDictionary`"

#: ../../library/stdtypes.rst:4975
msgid ":class:`weakref.WeakMethod`"
msgstr ":class:`weakref.WeakMethod`"

#: ../../library/stdtypes.rst:4976
msgid ":class:`weakref.WeakSet`"
msgstr ":class:`weakref.WeakSet`"

#: ../../library/stdtypes.rst:4977
msgid ":class:`weakref.WeakValueDictionary`"
msgstr ":class:`weakref.WeakValueDictionary`"

#: ../../library/stdtypes.rst:4982
msgid "Special Attributes of ``GenericAlias`` objects"
msgstr ""

#: ../../library/stdtypes.rst:4984
msgid "All parameterized generics implement special read-only attributes."
msgstr ""

#: ../../library/stdtypes.rst:4988
msgid "This attribute points at the non-parameterized generic class::"
msgstr ""

#: ../../library/stdtypes.rst:4996
msgid ""
"This attribute is a :class:`tuple` (possibly of length 1) of generic types "
"passed to the original :meth:`~object.__class_getitem__` of the generic "
"class::"
msgstr ""

#: ../../library/stdtypes.rst:5006
msgid ""
"This attribute is a lazily computed tuple (possibly empty) of unique type "
"variables found in ``__args__``::"
msgstr ""

#: ../../library/stdtypes.rst:5017
msgid ""
"A ``GenericAlias`` object with :class:`typing.ParamSpec` parameters may not "
"have correct ``__parameters__`` after substitution because :class:`typing."
"ParamSpec` is intended primarily for static type checking."
msgstr ""

#: ../../library/stdtypes.rst:5024
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - 型ヒント"

#: ../../library/stdtypes.rst:5024
msgid "Introducing Python's framework for type annotations."
msgstr ""

#: ../../library/stdtypes.rst:5029
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ""
":pep:`585` - 標準コレクション型の型ヒントにおける総称型 (generics) の使用"

#: ../../library/stdtypes.rst:5027
msgid ""
"Introducing the ability to natively parameterize standard-library classes, "
"provided they implement the special class method :meth:`~object."
"__class_getitem__`."
msgstr ""

#: ../../library/stdtypes.rst:5032
msgid ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""

#: ../../library/stdtypes.rst:5032
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""

#: ../../library/stdtypes.rst:5041
msgid "Union Type"
msgstr "Union 型"

#: ../../library/stdtypes.rst:5047
msgid ""
"A union object holds the value of the ``|`` (bitwise or) operation on "
"multiple :ref:`type objects <bltin-type-objects>`.  These types are intended "
"primarily for :term:`type annotations <annotation>`. The union type "
"expression enables cleaner type hinting syntax compared to :data:`typing."
"Union`."
msgstr ""

#: ../../library/stdtypes.rst:5054
msgid ""
"Defines a union object which holds types *X*, *Y*, and so forth. ``X | Y`` "
"means either X or Y.  It is equivalent to ``typing.Union[X, Y]``. For "
"example, the following function expects an argument of type :class:`int` or :"
"class:`float`::"
msgstr ""

#: ../../library/stdtypes.rst:5064
msgid ""
"Union objects can be tested for equality with other union objects.  Details:"
msgstr ""

#: ../../library/stdtypes.rst:5066
msgid "Unions of unions are flattened::"
msgstr ""

#: ../../library/stdtypes.rst:5070
msgid "Redundant types are removed::"
msgstr ""

#: ../../library/stdtypes.rst:5074
msgid "When comparing unions, the order is ignored::"
msgstr ""

#: ../../library/stdtypes.rst:5078
msgid "It is compatible with :data:`typing.Union`::"
msgstr ""

#: ../../library/stdtypes.rst:5082
msgid "Optional types can be spelled as a union with ``None``::"
msgstr ""

#: ../../library/stdtypes.rst:5089
msgid ""
"Calls to :func:`isinstance` and :func:`issubclass` are also supported with a "
"union object::"
msgstr ""

#: ../../library/stdtypes.rst:5095
msgid ""
"However, union objects containing :ref:`parameterized generics <types-"
"genericalias>` cannot be used::"
msgstr ""

#: ../../library/stdtypes.rst:5103
msgid ""
"The user-exposed type for the union object can be accessed from :data:`types."
"UnionType` and used for :func:`isinstance` checks.  An object cannot be "
"instantiated from the type::"
msgstr ""

#: ../../library/stdtypes.rst:5116
msgid ""
"The :meth:`__or__` method for type objects was added to support the syntax "
"``X | Y``.  If a metaclass implements :meth:`__or__`, the Union may override "
"it::"
msgstr ""

#: ../../library/stdtypes.rst:5134
msgid ":pep:`604` -- PEP proposing the ``X | Y`` syntax and the Union type."
msgstr ":pep:`604` -- ``X | Y`` 構文とUnion型を提案しているPEP"

#: ../../library/stdtypes.rst:5142
msgid "Other Built-in Types"
msgstr "その他の組み込み型"

#: ../../library/stdtypes.rst:5144
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"インタプリタは、その他いくつかの種類のオブジェクトをサポートしています。これ"
"らのほとんどは 1 つまたは 2 つの演算だけをサポートしています。"

#: ../../library/stdtypes.rst:5151
msgid "Modules"
msgstr "モジュール"

#: ../../library/stdtypes.rst:5153
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"モジュールに対する唯一の特殊な演算は属性アクセス: ``m.name`` です。ここで "
"*m* はモジュールで、 *name* は *m* のシンボルテーブル上に定義された名前にアク"
"セスします。モジュール属性に代入することもできます。 (なお、:keyword:"
"`import` 文は、厳密にいえば、モジュールオブジェクトに対する演算ではありませ"
"ん; ``import foo`` は *foo* と名づけられたモジュールオブジェクトの存在を必要"
"とはせず、*foo* と名づけられたモジュールの (外部の) *定義* を必要とします。)"

#: ../../library/stdtypes.rst:5160
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"全てのモジュールにある特殊属性が :attr:`~object.__dict__` です。これはモ"
"ジュールのシンボルテーブルを含む辞書です。この辞書を書き換えると実際にモ"
"ジュールのシンボルテーブルを変更することができますが、:attr:`~object."
"__dict__` 属性を直接代入することはできません (``m.__dict__['a'] = 1`` と書い"
"て ``m.a`` を ``1`` に定義することはできますが、``m.__dict__ = {}`` と書くこ"
"とはできません)。 :attr:`~object.__dict__` を直接書き換えることは推奨されませ"
"ん。"

#: ../../library/stdtypes.rst:5168
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"インタプリタ内に組み込まれたモジュールは、 ``<module 'sys' (built-in)>`` のよ"
"うに書かれます。ファイルから読み出された場合、 ``<module 'os' from '/usr/"
"local/lib/pythonX.Y/os.pyc'>`` と書かれます。"

#: ../../library/stdtypes.rst:5176
msgid "Classes and Class Instances"
msgstr "クラスおよびクラスインスタンス"

#: ../../library/stdtypes.rst:5178
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr ""
"これらについては :ref:`objects` および :ref:`class` を参照してください。"

#: ../../library/stdtypes.rst:5184
msgid "Functions"
msgstr "関数"

#: ../../library/stdtypes.rst:5186
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"関数オブジェクトは関数定義によって生成されます。関数オブジェクトに対する唯一"
"の操作は、それを呼び出すことです: ``func(argument-list)`` 。"

#: ../../library/stdtypes.rst:5189
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"関数オブジェクトには実際には二種類あります: 組み込み関数とユーザ定義関数で"
"す。どちらも同じ操作 (関数の呼び出し) をサポートしますが、実装は異なるので、"
"オブジェクトの型も異なります。"

#: ../../library/stdtypes.rst:5193
msgid "See :ref:`function` for more information."
msgstr "詳細は、 :ref:`function` を参照してください。"

#: ../../library/stdtypes.rst:5199
msgid "Methods"
msgstr "メソッド"

#: ../../library/stdtypes.rst:5203
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""
"メソッドは属性表記を使って呼び出される関数です。メソッドには二種類あります: "
"(リストの :meth:`append` のような) 組み込みメソッドと、クラスインスタンスのメ"
"ソッドです。組み込みメソッドは、それをサポートする型と一緒に記述されていま"
"す。"

#: ../../library/stdtypes.rst:5208
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :dfn:"
"`instance method`) object. When called, it will add the ``self`` argument to "
"the argument list.  Bound methods have two special read-only attributes: ``m."
"__self__`` is the object on which the method operates, and ``m.__func__`` is "
"the function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-"
"n)`` is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""
"インスタンスを通してメソッド (クラスの名前空間内で定義された関数) にアクセス"
"すると、特殊なオブジェクトが得られます。それは束縛メソッド (:dfn:`bound "
"method`) オブジェクトで、インスタンスメソッド (:dfn:`instance method`) とも呼"
"ばれます。呼び出された時、引数リストに ``self`` 引数が追加されます。束縛メ"
"ソッドには 2 つの特殊読み出し専用属性があります。 ``m.__self__`` はそのメソッ"
"ドが操作するオブジェクトで、 ``m.__func__`` はそのメソッドを実装している関数"
"です。 ``m(arg-1, arg-2, ..., arg-n)`` の呼び出しは、 ``m.__func__(m."
"__self__, arg-1, arg-2, ..., arg-n)`` の呼び出しと完全に等価です。"

#: ../../library/stdtypes.rst:5217
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on "
"bound methods is disallowed.  Attempting to set an attribute on a method "
"results in an :exc:`AttributeError` being raised.  In order to set a method "
"attribute, you need to explicitly set it on the underlying function object::"
msgstr ""
"関数オブジェクトと同様に、メソッドオブジェクトは任意の属性の取得をサポートし"
"ています。しかし、メソッド属性は実際には下層の関数オブジェクト (``meth."
"__func__``) に記憶されているので、バインドされるメソッドにメソッド属性を設定"
"することは許されていません。メソッドに属性を設定しようとすると :exc:"
"`AttributeError` が送出されます。メソッドの属性を設定するためには、次のように"
"その下層の関数オブジェクトに明示的に設定する必要があります::"

#: ../../library/stdtypes.rst:5237 ../../library/stdtypes.rst:5268
msgid "See :ref:`types` for more information."
msgstr "詳細は、 :ref:`types` を参照してください。"

#: ../../library/stdtypes.rst:5245
msgid "Code Objects"
msgstr "コードオブジェクト"

#: ../../library/stdtypes.rst:5251
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`__code__` attribute. See also the :mod:`code` module."
msgstr ""
"コードオブジェクトは、関数本体のような \"擬似コンパイルされた\" Python の実行"
"可能コードを表すために実装系によって使われます。コードオブジェクトはグローバ"
"ルな実行環境への参照を持たない点で関数オブジェクトとは異なります。コードオブ"
"ジェクトは組み込み関数 :func:`compile` によって返され、また関数オブジェクト"
"の :attr:`__code__` 属性として取り出せます。 :mod:`code` モジュールも参照して"
"ください。"

#: ../../library/stdtypes.rst:5258
msgid ""
"Accessing ``__code__`` raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"__code__\"``."
msgstr ""
"``__code__`` へのアクセスは ``object.__getattr__`` に ``obj`` と "
"``\"__code__\"`` を渡して行いますが、 :ref:`監査イベント <auditing>` を送出し"
"ます。"

#: ../../library/stdtypes.rst:5265
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"コードオブジェクトは、組み込み関数 :func:`exec` や :func:`eval` に (ソース文"
"字列の代わりに) 渡すことで、実行や評価できます。"

#: ../../library/stdtypes.rst:5274
msgid "Type Objects"
msgstr "型オブジェクト"

#: ../../library/stdtypes.rst:5280
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"型オブジェクトは様々なオブジェクト型を表します。オブジェクトの型は組み込み関"
"数 :func:`type` でアクセスされます。型オブジェクトには特有の操作はありませ"
"ん。標準モジュール :mod:`types` には全ての組み込み型名が定義されています。"

#: ../../library/stdtypes.rst:5285
msgid "Types are written like this: ``<class 'int'>``."
msgstr "型はこのように書き表されます: ``<class 'int'>`` 。"

#: ../../library/stdtypes.rst:5291
msgid "The Null Object"
msgstr "ヌルオブジェクト"

#: ../../library/stdtypes.rst:5293
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"このオブジェクトは明示的に値を返さない関数によって返されます。このオブジェク"
"トには特有の操作はありません。ヌルオブジェクトは一つだけで、 ``None`` (組み込"
"み名) と名づけられています。 ``type(None)()`` は同じシングルトンを作成しま"
"す。"

#: ../../library/stdtypes.rst:5297
msgid "It is written as ``None``."
msgstr "``None`` と書き表されます。"

#: ../../library/stdtypes.rst:5304
msgid "The Ellipsis Object"
msgstr "Ellipsis オブジェクト"

#: ../../library/stdtypes.rst:5306
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"このオブジェクトは一般にスライシングによって使われます (:ref:`slicings` を参"
"照してください)。特殊な演算は何もサポートしていません。Ellipsis オブジェクト"
"は一つだけで、その名前は :const:`Ellipsis` (組み込み名) です。"
"``type(Ellipsis)()`` は単一の :const:`Ellipsis` を作成します。"

#: ../../library/stdtypes.rst:5311
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "``Ellipsis`` または ``...`` と書き表されます。"

#: ../../library/stdtypes.rst:5317
msgid "The NotImplemented Object"
msgstr "NotImplemented オブジェクト"

#: ../../library/stdtypes.rst:5319
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""
"このオブジェクトは、対応していない型に対して比較演算や二項演算が求められたと"
"き、それらの演算から返されます。詳細は :ref:`comparisons` を参照してくださ"
"い。 ``NotImplemented`` オブジェクトは一つだけです。 ``type(NotImplemented)"
"()`` はこの単一のインスタンスを作成します。"

#: ../../library/stdtypes.rst:5324
msgid "It is written as ``NotImplemented``."
msgstr "``NotImplemented`` と書き表されます。"

#: ../../library/stdtypes.rst:5330
msgid "Boolean Values"
msgstr "ブール値"

#: ../../library/stdtypes.rst:5332
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and "
"1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""
"ブール値は二つの定数オブジェクト ``False`` および ``True`` です。これらは真理"
"値を表すのに使われます (ただし他の値も偽や真とみなされます)。 数値処理のコン"
"テキスト (例えば算術演算子の引数として使われた場合) では、これらはそれぞれ 0 "
"および 1 と同様に振舞います。任意の値に対して、真理値と解釈できる場合、組み込"
"み関数 :func:`bool` は値をブール値に変換するのに使われます (上述の :ref:"
"`truth` の節を参照してください)。"

#: ../../library/stdtypes.rst:5345
msgid "They are written as ``False`` and ``True``, respectively."
msgstr "それぞれ ``False`` および ``True`` と書き表されます。"

#: ../../library/stdtypes.rst:5351
msgid "Internal Objects"
msgstr "内部オブジェクト"

#: ../../library/stdtypes.rst:5353
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""
"この情報は :ref:`types` を参照してください。スタックフレームオブジェクト、ト"
"レースバックオブジェクト、スライスオブジェクトについて記述されています。"

#: ../../library/stdtypes.rst:5360
msgid "Special Attributes"
msgstr "特殊属性"

#: ../../library/stdtypes.rst:5362
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"実装は、いくつかのオブジェクト型に対して、適切な場合には特殊な読み出し専用の"
"属性を追加します。そのうちいくつかは :func:`dir` 組込み関数で報告されません。"

#: ../../library/stdtypes.rst:5369
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""
"オブジェクトの (書き込み可能な) 属性を保存するために使われる辞書またはその他"
"のマッピングオブジェクトです。"

#: ../../library/stdtypes.rst:5375
msgid "The class to which a class instance belongs."
msgstr "クラスインスタンスが属しているクラスです。"

#: ../../library/stdtypes.rst:5380
msgid "The tuple of base classes of a class object."
msgstr "クラスオブジェクトの基底クラスのタプルです。"

#: ../../library/stdtypes.rst:5385
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr ""
"クラス、関数、メソッド、デスクリプタ、ジェネレータインスタンスの名前です。"

#: ../../library/stdtypes.rst:5391
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
"クラス、関数、メソッド、デスクリプタ、ジェネレータインスタンスの :term:`修飾"
"名 <qualified name>` です。"

#: ../../library/stdtypes.rst:5399
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""
"この属性はメソッドの解決時に基底クラスを探索するときに考慮されるクラスのタプ"
"ルです。"

#: ../../library/stdtypes.rst:5405
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"このメソッドは、メタクラスによって、そのインスタンスのメソッド解決の順序をカ"
"スタマイズするために、上書きされるかも知れません。このメソッドはクラスのイン"
"スタンス化時に呼ばれ、その結果は :attr:`~class.__mro__` に格納されます。"

#: ../../library/stdtypes.rst:5412
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive.  The list is "
"in definition order.  Example::"
msgstr ""
"それぞれのクラスは、それ自身の直接のサブクラスへの弱参照を保持します。このメ"
"ソッドはそれらの参照のうち、生存しているもののリストを返します。リストは定義"
"順です。例::"

#: ../../library/stdtypes.rst:5423
msgid "Integer string conversion length limitation"
msgstr ""

#: ../../library/stdtypes.rst:5425
msgid ""
"CPython has a global limit for converting between :class:`int` and :class:"
"`str` to mitigate denial of service attacks. This limit *only* applies to "
"decimal or other non-power-of-two number bases. Hexadecimal, octal, and "
"binary conversions are unlimited. The limit can be configured."
msgstr ""

#: ../../library/stdtypes.rst:5430
msgid ""
"The :class:`int` type in CPython is an arbitrary length number stored in "
"binary form (commonly known as a \"bignum\"). There exists no algorithm that "
"can convert a string to a binary integer or a binary integer to a string in "
"linear time, *unless* the base is a power of 2. Even the best known "
"algorithms for base 10 have sub-quadratic complexity. Converting a large "
"value such as ``int('1' * 500_000)`` can take over a second on a fast CPU."
msgstr ""

#: ../../library/stdtypes.rst:5437
msgid ""
"Limiting conversion size offers a practical way to avoid `CVE-2020-10735 "
"<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10735>`_."
msgstr ""

#: ../../library/stdtypes.rst:5440
msgid ""
"The limit is applied to the number of digit characters in the input or "
"output string when a non-linear conversion algorithm would be involved.  "
"Underscores and the sign are not counted towards the limit."
msgstr ""

#: ../../library/stdtypes.rst:5444
msgid ""
"When an operation would exceed the limit, a :exc:`ValueError` is raised:"
msgstr ""

#: ../../library/stdtypes.rst:5466
msgid ""
"The default limit is 4300 digits as provided in :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. The lowest limit that can be "
"configured is 640 digits as provided in :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."
msgstr ""

#: ../../library/stdtypes.rst:5471
msgid "Verification:"
msgstr ""

#: ../../library/stdtypes.rst:5486
msgid "Affected APIs"
msgstr ""

#: ../../library/stdtypes.rst:5488
msgid ""
"The limitation only applies to potentially slow conversions between :class:"
"`int` and :class:`str` or :class:`bytes`:"
msgstr ""

#: ../../library/stdtypes.rst:5491
msgid "``int(string)`` with default base 10."
msgstr ""

#: ../../library/stdtypes.rst:5492
msgid "``int(string, base)`` for all bases that are not a power of 2."
msgstr ""

#: ../../library/stdtypes.rst:5493
msgid "``str(integer)``."
msgstr "``str(integer)``."

#: ../../library/stdtypes.rst:5494
msgid "``repr(integer)``."
msgstr "``repr(integer)``."

#: ../../library/stdtypes.rst:5495
msgid ""
"any other string conversion to base 10, for example ``f\"{integer}\"``, "
"``\"{}\".format(integer)``, or ``b\"%d\" % integer``."
msgstr ""

#: ../../library/stdtypes.rst:5498
msgid "The limitations do not apply to functions with a linear algorithm:"
msgstr ""

#: ../../library/stdtypes.rst:5500
msgid "``int(string, base)`` with base 2, 4, 8, 16, or 32."
msgstr ""

#: ../../library/stdtypes.rst:5501
msgid ":func:`int.from_bytes` and :func:`int.to_bytes`."
msgstr ":func:`int.from_bytes` と :func:`int.to_bytes` 。"

#: ../../library/stdtypes.rst:5502
msgid ":func:`hex`, :func:`oct`, :func:`bin`."
msgstr ":func:`hex`, :func:`oct`, :func:`bin`."

#: ../../library/stdtypes.rst:5503
msgid ":ref:`formatspec` for hex, octal, and binary numbers."
msgstr ""

#: ../../library/stdtypes.rst:5504
msgid ":class:`str` to :class:`float`."
msgstr ""

#: ../../library/stdtypes.rst:5505
msgid ":class:`str` to :class:`decimal.Decimal`."
msgstr ""

#: ../../library/stdtypes.rst:5508
msgid "Configuring the limit"
msgstr ""

#: ../../library/stdtypes.rst:5510
msgid ""
"Before Python starts up you can use an environment variable or an "
"interpreter command line flag to configure the limit:"
msgstr ""

#: ../../library/stdtypes.rst:5513
msgid ""
":envvar:`PYTHONINTMAXSTRDIGITS`, e.g. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"to set the limit to 640 or ``PYTHONINTMAXSTRDIGITS=0 python3`` to disable "
"the limitation."
msgstr ""

#: ../../library/stdtypes.rst:5516
msgid ""
":option:`-X int_max_str_digits <-X>`, e.g. ``python3 -X "
"int_max_str_digits=640``"
msgstr ""

#: ../../library/stdtypes.rst:5518
msgid ""
":data:`sys.flags.int_max_str_digits` contains the value of :envvar:"
"`PYTHONINTMAXSTRDIGITS` or :option:`-X int_max_str_digits <-X>`. If both the "
"env var and the ``-X`` option are set, the ``-X`` option takes precedence. A "
"value of *-1* indicates that both were unset, thus a value of :data:`sys."
"int_info.default_max_str_digits` was used during initialization."
msgstr ""

#: ../../library/stdtypes.rst:5524
msgid ""
"From code, you can inspect the current limit and set a new one using these :"
"mod:`sys` APIs:"
msgstr ""

#: ../../library/stdtypes.rst:5527
msgid ""
":func:`sys.get_int_max_str_digits` and :func:`sys.set_int_max_str_digits` "
"are a getter and setter for the interpreter-wide limit. Subinterpreters have "
"their own limit."
msgstr ""

#: ../../library/stdtypes.rst:5531
msgid ""
"Information about the default and minimum can be found in :attr:`sys."
"int_info`:"
msgstr ""

#: ../../library/stdtypes.rst:5533
msgid ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-"
"in default limit."
msgstr ""

#: ../../library/stdtypes.rst:5535
msgid ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` is the lowest "
"accepted value for the limit (other than 0 which disables it)."
msgstr ""

#: ../../library/stdtypes.rst:5542
msgid ""
"Setting a low limit *can* lead to problems. While rare, code exists that "
"contains integer constants in decimal in their source that exceed the "
"minimum threshold. A consequence of setting the limit is that Python source "
"code containing decimal integer literals longer than the limit will "
"encounter an error during parsing, usually at startup time or import time or "
"even at installation time - anytime an up to date ``.pyc`` does not already "
"exist for the code. A workaround for source that contains such large "
"constants is to convert them to ``0x`` hexadecimal form as it has no limit."
msgstr ""

#: ../../library/stdtypes.rst:5551
msgid ""
"Test your application thoroughly if you use a low limit. Ensure your tests "
"run with the limit set early via the environment or flag so that it applies "
"during startup and even during any installation step that may invoke Python "
"to precompile ``.py`` sources to ``.pyc`` files."
msgstr ""

#: ../../library/stdtypes.rst:5557
msgid "Recommended configuration"
msgstr ""

#: ../../library/stdtypes.rst:5559
msgid ""
"The default :data:`sys.int_info.default_max_str_digits` is expected to be "
"reasonable for most applications. If your application requires a different "
"limit, set it from your main entry point using Python version agnostic code "
"as these APIs were added in security patch releases in versions before 3.11."
msgstr ""

#: ../../library/stdtypes.rst:5564
msgid "Example::"
msgstr "以下はプログラム例です::"

#: ../../library/stdtypes.rst:5576
msgid "If you need to disable it entirely, set it to ``0``."
msgstr ""

#: ../../library/stdtypes.rst:5580
msgid "Footnotes"
msgstr "脚注"

#: ../../library/stdtypes.rst:5581
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"これらの特殊なメソッドのさらなる情報については、 Python リファレンスマニュア"
"ル (:ref:`customization`) を参照してください。"

#: ../../library/stdtypes.rst:5584
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"この結果として、リスト ``[1, 2]`` は ``[1.0, 2.0]`` と等しいと見なされます。"
"タプルの場合も同様です。"

#: ../../library/stdtypes.rst:5587
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""
"パーザが演算対象の型を識別できるようにするために、このような優先順位でなけれ"
"ばならないのです。"

#: ../../library/stdtypes.rst:5589
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"大小文字の区別のある文字とは、一般カテゴリプロパティが \"Lu\" (Letter, "
"uppercase (大文字))、 \"Ll\" (Letter, lowercase (小文字))、 \"Lt\" (Letter、"
"titlecase (先頭が大文字)) のいずれかであるものです。"

#: ../../library/stdtypes.rst:5592
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"従って、一個のタプルだけをフォーマット出力したい場合には出力したいタプルを唯"
"一の要素とする単一のタプルを *values* に与えなくてはなりません。"
