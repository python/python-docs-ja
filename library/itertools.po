# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-03 12:56+0900\n"
"PO-Revision-Date: 2018-07-29 01:58+0000\n"
"Last-Translator: Atsuo Ishimoto <atsuoishimoto@gmail.com>\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/itertools.rst:3
msgid ""
":mod:`itertools` --- Functions creating iterators for efficient looping"
msgstr ":mod:`itertools` --- åŠ¹ç‡çš„ãªãƒ«ãƒ¼ãƒ—å®Ÿè¡Œã®ãŸã‚ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ç”Ÿæˆé–¢æ•°"

#: ../../library/itertools.rst:17
msgid ""
"This module implements a number of :term:`iterator` building blocks inspired"
" by constructs from APL, Haskell, and SML.  Each has been recast in a form "
"suitable for Python."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿(:term:`iterator`)ã‚’æ§‹ç¯‰ã™ã‚‹éƒ¨å“ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨€èª APL, Haskell, SML ã‹ã‚‰ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’å¾—ã¦ã„ã¾ã™ãŒã€ Python ã«é©ã—ãŸå½¢ã«ä¿®æ­£ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/itertools.rst:21
msgid ""
"The module standardizes a core set of fast, memory efficient tools that are "
"useful by themselves or in combination.  Together, they form an \"iterator "
"algebra\" making it possible to construct specialized tools succinctly and "
"efficiently in pure Python."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€é«˜é€Ÿã§ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ã«å„ªã‚Œã€å˜ç‹¬ã§ã‚‚çµ„åˆã›ã¦ã‚‚ä½¿ç”¨ã™ã‚‹ã“ã¨ã®ã§ãã‚‹ãƒ„ãƒ¼ãƒ«ã‚’æ¨™æº–åŒ–ã—ãŸã‚‚ã®ã§ã™ã€‚åŒæ™‚ã«ã€ã“ã®ãƒ„ãƒ¼ãƒ«ç¾¤ã¯ \"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®ä»£æ•°\" ã‚’æ§‹æˆã—ã¦ã„ã¦ã€pure Python ã§ç°¡æ½”ã‹ã¤åŠ¹ç‡çš„ãªãƒ„ãƒ¼ãƒ«ã‚’ä½œã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/itertools.rst:26
msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which produces"
" a sequence ``f(0), f(1), ...``.  The same effect can be achieved in Python "
"by combining :func:`imap` and :func:`count` to form ``imap(f, count())``."
msgstr "ä¾‹ãˆã°ã€SML ã®ä½œè¡¨ãƒ„ãƒ¼ãƒ« ``tabulate(f)`` ã¯ ``f(0), f(1), ...`` ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚åŒã˜ã“ã¨ã‚’ Python ã§ã¯ :func:`imap` ã¨ :func:`count` ã‚’çµ„åˆã›ã¦ ``imap(f, count())`` ã¨ã„ã†å½¢ã§å®Ÿç¾ã§ãã¾ã™ã€‚"

#: ../../library/itertools.rst:30
msgid ""
"These tools and their built-in counterparts also work well with the high-"
"speed functions in the :mod:`operator` module.  For example, the "
"multiplication operator can be mapped across two vectors to form an "
"efficient dot-product: ``sum(imap(operator.mul, vector1, vector2))``."
msgstr "ã“ã‚Œã‚‰ã®ãƒ„ãƒ¼ãƒ«ã¨çµ„ã¿è¾¼ã¿é–¢æ•°ã¯ :mod:`operator` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã®é«˜é€Ÿãªé–¢æ•°ã¨ã¨ã‚‚ã«ä½¿ã†ã“ã¨ã§è¦‹äº‹ã«å‹•ä½œã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ä¹—ç®—æ¼”ç®—å­ã‚’2ã¤ã®ãƒ™ã‚¯ã‚¿ã«ã¾ãŸãŒã£ã¦ãƒãƒƒãƒ—ã—ã¦åŠ¹ç‡çš„ãªå†…ç©è¨ˆç®—ãŒå®Ÿç¾ã§ãã¾ã™: ``sum(imap(operator.mul, vector1, vector2))`` ã€‚"

#: ../../library/itertools.rst:36
msgid "**Infinite Iterators:**"
msgstr "**ç„¡é™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿:**"

#: ../../library/itertools.rst:39 ../../library/itertools.rst:49
#: ../../library/itertools.rst:69
msgid "Iterator"
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿"

#: ../../library/itertools.rst:39 ../../library/itertools.rst:49
#: ../../library/itertools.rst:69
msgid "Arguments"
msgstr "å¼•æ•°"

#: ../../library/itertools.rst:39 ../../library/itertools.rst:49
#: ../../library/itertools.rst:69
msgid "Results"
msgstr "çµæœ"

#: ../../library/itertools.rst:39 ../../library/itertools.rst:49
msgid "Example"
msgstr "ä¾‹"

#: ../../library/itertools.rst:41
msgid ":func:`count`"
msgstr ":func:`count`"

#: ../../library/itertools.rst:41
msgid "start, [step]"
msgstr "start, [step]"

#: ../../library/itertools.rst:41
msgid "start, start+step, start+2*step, ..."
msgstr "start, start+step, start+2*step, ..."

#: ../../library/itertools.rst:41
msgid "``count(10) --> 10 11 12 13 14 ...``"
msgstr "``count(10) --> 10 11 12 13 14 ...``"

#: ../../library/itertools.rst:42
msgid ":func:`cycle`"
msgstr ":func:`cycle`"

#: ../../library/itertools.rst:42
msgid "p"
msgstr "p"

#: ../../library/itertools.rst:42
msgid "p0, p1, ... plast, p0, p1, ..."
msgstr "p0, p1, ... plast, p0, p1, ..."

#: ../../library/itertools.rst:42
msgid "``cycle('ABCD') --> A B C D A B C D ...``"
msgstr "``cycle('ABCD') --> A B C D A B C D ...``"

#: ../../library/itertools.rst:43
msgid ":func:`repeat`"
msgstr ":func:`repeat`"

#: ../../library/itertools.rst:43
msgid "elem [,n]"
msgstr "elem [,n]"

#: ../../library/itertools.rst:43
msgid "elem, elem, elem, ... endlessly or up to n times"
msgstr "elem, elem, elem, ... ç„¡é™ã‚‚ã—ãã¯ n å›"

#: ../../library/itertools.rst:43
msgid "``repeat(10, 3) --> 10 10 10``"
msgstr "``repeat(10, 3) --> 10 10 10``"

#: ../../library/itertools.rst:46
msgid "**Iterators terminating on the shortest input sequence:**"
msgstr "**ä¸€ç•ªçŸ­ã„å…¥åŠ›ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§æ­¢ã¾ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿:**"

#: ../../library/itertools.rst:51
msgid ":func:`chain`"
msgstr ":func:`chain`"

#: ../../library/itertools.rst:51 ../../library/itertools.rst:62
#: ../../library/itertools.rst:63
msgid "p, q, ..."
msgstr "p, q, ..."

#: ../../library/itertools.rst:51
msgid "p0, p1, ... plast, q0, q1, ..."
msgstr "p0, p1, ... plast, q0, q1, ..."

#: ../../library/itertools.rst:51
msgid "``chain('ABC', 'DEF') --> A B C D E F``"
msgstr "``chain('ABC', 'DEF') --> A B C D E F``"

#: ../../library/itertools.rst:52
msgid ":func:`compress`"
msgstr ":func:`compress`"

#: ../../library/itertools.rst:52
msgid "data, selectors"
msgstr "data, selectors"

#: ../../library/itertools.rst:52
msgid "(d[0] if s[0]), (d[1] if s[1]), ..."
msgstr "(d[0] if s[0]), (d[1] if s[1]), ..."

#: ../../library/itertools.rst:52
msgid "``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"
msgstr "``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"

#: ../../library/itertools.rst:53
msgid ":func:`dropwhile`"
msgstr ":func:`dropwhile`"

#: ../../library/itertools.rst:53 ../../library/itertools.rst:55
#: ../../library/itertools.rst:56 ../../library/itertools.rst:61
msgid "pred, seq"
msgstr "pred, seq"

#: ../../library/itertools.rst:53
msgid "seq[n], seq[n+1], starting when pred fails"
msgstr "seq[n], seq[n+1], pred ãŒå½ã®å ´æ‰€ã‹ã‚‰å§‹ã¾ã‚‹"

#: ../../library/itertools.rst:53
msgid "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"
msgstr "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"

#: ../../library/itertools.rst:54
msgid ":func:`groupby`"
msgstr ":func:`groupby`"

#: ../../library/itertools.rst:54
msgid "iterable[, keyfunc]"
msgstr "iterable[, keyfunc]"

#: ../../library/itertools.rst:54
msgid "sub-iterators grouped by value of keyfunc(v)"
msgstr "keyfunc(v) ã®å€¤ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ãŸã‚µãƒ–ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿"

#: ../../library/itertools.rst:55
msgid ":func:`ifilter`"
msgstr ":func:`ifilter`"

#: ../../library/itertools.rst:55
msgid "elements of seq where pred(elem) is true"
msgstr "pred(elem) ãŒçœŸã«ãªã‚‹seqã®è¦ç´ "

#: ../../library/itertools.rst:55
msgid "``ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9``"
msgstr "``ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9``"

#: ../../library/itertools.rst:56
msgid ":func:`ifilterfalse`"
msgstr ":func:`ifilterfalse`"

#: ../../library/itertools.rst:56
msgid "elements of seq where pred(elem) is false"
msgstr "pred(elem) ãŒå½ã«ãªã‚‹seqã®è¦ç´ "

#: ../../library/itertools.rst:56
msgid "``ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"
msgstr "``ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"

#: ../../library/itertools.rst:57
msgid ":func:`islice`"
msgstr ":func:`islice`"

#: ../../library/itertools.rst:57
msgid "seq, [start,] stop [, step]"
msgstr "seq, [start,] stop [, step]"

#: ../../library/itertools.rst:57
msgid "elements from seq[start:stop:step]"
msgstr "seq[start:stop:step]"

#: ../../library/itertools.rst:57
msgid "``islice('ABCDEFG', 2, None) --> C D E F G``"
msgstr "``islice('ABCDEFG', 2, None) --> C D E F G``"

#: ../../library/itertools.rst:58
msgid ":func:`imap`"
msgstr ":func:`imap`"

#: ../../library/itertools.rst:58
msgid "func, p, q, ..."
msgstr "func, p, q, ..."

#: ../../library/itertools.rst:58
msgid "func(p0, q0), func(p1, q1), ..."
msgstr "func(p0, q0), func(p1, q1), ..."

#: ../../library/itertools.rst:58
msgid "``imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000``"
msgstr "``imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000``"

#: ../../library/itertools.rst:59
msgid ":func:`starmap`"
msgstr ":func:`starmap`"

#: ../../library/itertools.rst:59
msgid "func, seq"
msgstr "func, seq"

#: ../../library/itertools.rst:59
msgid "func(\\*seq[0]), func(\\*seq[1]), ..."
msgstr "func(\\*seq[0]), func(\\*seq[1]), ..."

#: ../../library/itertools.rst:59
msgid "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"
msgstr "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"

#: ../../library/itertools.rst:60
msgid ":func:`tee`"
msgstr ":func:`tee`"

#: ../../library/itertools.rst:60
msgid "it, n"
msgstr "it, n"

#: ../../library/itertools.rst:60
msgid "it1, it2, ... itn  splits one iterator into n"
msgstr "it1, it2 , ... itn ä¸€ã¤ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ n å€‹ã«åˆ†ã‘ã‚‹"

#: ../../library/itertools.rst:61
msgid ":func:`takewhile`"
msgstr ":func:`takewhile`"

#: ../../library/itertools.rst:61
msgid "seq[0], seq[1], until pred fails"
msgstr "seq[0], seq[1], pred ãŒå½ã«ãªã‚‹ã¾ã§"

#: ../../library/itertools.rst:61
msgid "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"
msgstr "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"

#: ../../library/itertools.rst:62
msgid ":func:`izip`"
msgstr ":func:`izip`"

#: ../../library/itertools.rst:62 ../../library/itertools.rst:63
msgid "(p[0], q[0]), (p[1], q[1]), ..."
msgstr "(p[0], q[0]), (p[1], q[1]), ..."

#: ../../library/itertools.rst:62
msgid "``izip('ABCD', 'xy') --> Ax By``"
msgstr "``izip('ABCD', 'xy') --> Ax By``"

#: ../../library/itertools.rst:63
msgid ":func:`izip_longest`"
msgstr ":func:`izip_longest`"

#: ../../library/itertools.rst:63
msgid "``izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"
msgstr "``izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"

#: ../../library/itertools.rst:66
msgid "**Combinatoric generators:**"
msgstr "**çµ„åˆã›ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿:**"

#: ../../library/itertools.rst:71
msgid ":func:`product`"
msgstr ":func:`product`"

#: ../../library/itertools.rst:71
msgid "p, q, ... [repeat=1]"
msgstr "p, q, ... [repeat=1]"

#: ../../library/itertools.rst:71
msgid "cartesian product, equivalent to a nested for-loop"
msgstr "ãƒ‡ã‚«ãƒ«ãƒˆç©ã€ãƒã‚¹ãƒˆã—ãŸforãƒ«ãƒ¼ãƒ—ã¨ç­‰ä¾¡"

#: ../../library/itertools.rst:72
msgid ":func:`permutations`"
msgstr ":func:`permutations`"

#: ../../library/itertools.rst:72
msgid "p[, r]"
msgstr "p[, r]"

#: ../../library/itertools.rst:72
msgid "r-length tuples, all possible orderings, no repeated elements"
msgstr "é•·ã•rã®ã‚¿ãƒ—ãƒ«åˆ—, ç¹°ã‚Šè¿”ã—ã‚’è¨±ã•ãªã„é †åˆ—"

#: ../../library/itertools.rst:73
msgid ":func:`combinations`"
msgstr ":func:`combinations`"

#: ../../library/itertools.rst:73 ../../library/itertools.rst:74
msgid "p, r"
msgstr "p, r"

#: ../../library/itertools.rst:73
msgid "r-length tuples, in sorted order, no repeated elements"
msgstr "é•·ã•rã®ã‚¿ãƒ—ãƒ«åˆ—, ç¹°ã‚Šè¿”ã—ã‚’è¨±ã•ãªã„çµ„åˆã›"

#: ../../library/itertools.rst:74
msgid ":func:`combinations_with_replacement`"
msgstr ":func:`combinations_with_replacement`"

#: ../../library/itertools.rst:74
msgid "r-length tuples, in sorted order, with repeated elements"
msgstr "é•·ã•rã®ã‚¿ãƒ—ãƒ«åˆ—, ç¹°ã‚Šè¿”ã—ã‚’è¨±ã—ãŸçµ„åˆã›"

#: ../../library/itertools.rst:75
msgid "``product('ABCD', repeat=2)``"
msgstr "``product('ABCD', repeat=2)``"

#: ../../library/itertools.rst:75
msgid "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"
msgstr "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"

#: ../../library/itertools.rst:76
msgid "``permutations('ABCD', 2)``"
msgstr "``permutations('ABCD', 2)``"

#: ../../library/itertools.rst:76
msgid "``AB AC AD BA BC BD CA CB CD DA DB DC``"
msgstr "``AB AC AD BA BC BD CA CB CD DA DB DC``"

#: ../../library/itertools.rst:77
msgid "``combinations('ABCD', 2)``"
msgstr "``combinations('ABCD', 2)``"

#: ../../library/itertools.rst:77
msgid "``AB AC AD BC BD CD``"
msgstr "``AB AC AD BC BD CD``"

#: ../../library/itertools.rst:78
msgid "``combinations_with_replacement('ABCD', 2)``"
msgstr "``combinations_with_replacement('ABCD', 2)``"

#: ../../library/itertools.rst:78
msgid "``AA AB AC AD BB BC BD CC CD DD``"
msgstr "``AA AB AC AD BB BC BD CC CD DD``"

#: ../../library/itertools.rst:85
msgid "Itertool functions"
msgstr "Itertoolé–¢æ•°"

#: ../../library/itertools.rst:87
msgid ""
"The following module functions all construct and return iterators. Some "
"provide streams of infinite length, so they should only be accessed by "
"functions or loops that truncate the stream."
msgstr "ä»¥ä¸‹ã®é–¢æ•°ã¯å…¨ã¦ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¦è¿”ã—ã¾ã™ã€‚ç„¡é™é•·ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã™é–¢æ•°ã‚‚ã‚ã‚Šã€ã“ã®å ´åˆã«ã¯ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä¸­æ–­ã™ã‚‹ã‚ˆã†ãªé–¢æ•°ã‹ãƒ«ãƒ¼ãƒ—å‡¦ç†ã‹ã‚‰ä½¿ç”¨ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/itertools.rst:94
msgid ""
"Make an iterator that returns elements from the first iterable until it is "
"exhausted, then proceeds to the next iterable, until all of the iterables "
"are exhausted.  Used for treating consecutive sequences as a single "
"sequence. Roughly equivalent to::"
msgstr "å…ˆé ­ã® iterable ã®å…¨è¦ç´ ã‚’è¿”ã—ã€æ¬¡ã«2ç•ªç›®ã® iterable ã®å…¨è¦ç´ ã‚’è¿”ã—ã€ã¨å…¨ iterable ã®è¦ç´ ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚é€£ç¶šã—ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ä¸€ã¤ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦æ‰±ã†å ´åˆã«ä½¿ç”¨ã—ã¾ã™ã€‚ãŠã‚ˆãæ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/itertools.rst:108
msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a single "
"iterable argument that is evaluated lazily.  Roughly equivalent to::"
msgstr ":func:`chain` ã®ãŸã‚ã®ã‚‚ã†ä¸€ã¤ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã™ã€‚é…å»¶è©•ä¾¡ã•ã‚Œã‚‹å”¯ä¸€ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«å¼•æ•°ã‹ã‚‰é€£é–ã—ãŸå…¥åŠ›ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¨ã»ã¼ç­‰ä¾¡ã§ã™::"

#: ../../library/itertools.rst:122
msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr "å…¥åŠ› *iterable* ã®è¦ç´ ã‹ã‚‰ãªã‚‹é•·ã• *r* ã®éƒ¨åˆ†åˆ—ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/itertools.rst:124 ../../library/itertools.rst:175
msgid ""
"Combinations are emitted in lexicographic sort order.  So, if the input "
"*iterable* is sorted, the combination tuples will be produced in sorted "
"order."
msgstr "çµ„åˆã›(combination)ã¯è¾æ›¸å¼é †åºã§å‡ºåŠ›ã•ã‚Œã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€å…¥åŠ› *iterable* ãŒã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚Œã°ã€çµ„åˆã›ã®ã‚¿ãƒ—ãƒ«ã¯æ•´åˆ—ã•ã‚ŒãŸå½¢ã§ç”Ÿæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/itertools.rst:128
msgid ""
"Elements are treated as unique based on their position, not on their value."
"  So if the input elements are unique, there will be no repeat values in "
"each combination."
msgstr "å„è¦ç´ ã¯å ´æ‰€ã«åŸºã¥ã„ã¦ä¸€æ„ã«å–ã‚Šæ‰±ã‚ã‚Œã€å€¤ã«ã¯ä¾ã‚Šã¾ã›ã‚“ã€‚å…¥åŠ›ã•ã‚ŒãŸè¦ç´ ãŒãƒãƒ©ãƒãƒ©ãªã‚‰ã°ã€å„çµ„åˆã›ã®ä¸­ã«é‡è¤‡ã—ãŸå€¤ã¯ç¾ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/itertools.rst:132 ../../library/itertools.rst:183
#: ../../library/itertools.rst:514
msgid "Roughly equivalent to::"
msgstr "ãŠã‚ˆãæ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/itertools.rst:154
msgid ""
"The code for :func:`combinations` can be also expressed as a subsequence of "
":func:`permutations` after filtering entries where the elements are not in "
"sorted order (according to their position in the input pool)::"
msgstr ":func:`combinations` ã®ã‚³ãƒ¼ãƒ‰ã¯ :func:`permutations` ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‹ã‚‰ (å…¥åŠ›ãƒ—ãƒ¼ãƒ«ã§ã®ä½ç½®ã«å¿œã˜ãŸé †åºã§) è¦ç´ ãŒã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã‚‚ã®ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã—ãŸã‚ˆã†ã«ã‚‚è¡¨ç¾ã§ãã¾ã™::"

#: ../../library/itertools.rst:165
msgid ""
"The number of items returned is ``n! / r! / (n-r)!`` when ``0 <= r <= n`` or"
" zero when ``r > n``."
msgstr "è¿”ã•ã‚Œã‚‹è¦ç´ ã®æ•°ã¯ã€``0 <= r <= n`` ã®å ´åˆã¯ã€``n! / r! / (n-r)!`` ã§ã€``r > n`` ã®å ´åˆã¯ 0 ã§ã™ã€‚"

#: ../../library/itertools.rst:172
msgid ""
"Return *r* length subsequences of elements from the input *iterable* "
"allowing individual elements to be repeated more than once."
msgstr "å…¥åŠ› *iterable* ã‹ã‚‰ã€ãã‚Œãã‚Œã®è¦ç´ ãŒè¤‡æ•°å›ç¾ã‚Œã‚‹ã“ã¨ã‚’è¨±ã—ã¦ã€é•·ã• *r* ã®è¦ç´ ã®éƒ¨åˆ†åˆ—ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/itertools.rst:179
msgid ""
"Elements are treated as unique based on their position, not on their value."
"  So if the input elements are unique, the generated combinations will also "
"be unique."
msgstr "è¦ç´ ã¯ã€å€¤ã§ã¯ãªãä½ç½®ã«åŸºã¥ã„ã¦ä¸€æ„ã«æ‰±ã‚ã‚Œã¾ã™ã€‚ã§ã™ã‹ã‚‰ã€å…¥åŠ›ã®è¦ç´ ãŒä¸€æ„ã§ã‚ã‚Œã°ã€ç”Ÿæˆã•ã‚ŒãŸçµ„åˆã›ã‚‚ä¸€æ„ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/itertools.rst:202
msgid ""
"The code for :func:`combinations_with_replacement` can be also expressed as "
"a subsequence of :func:`product` after filtering entries where the elements "
"are not in sorted order (according to their position in the input pool)::"
msgstr ":func:`combinations_with_replacement` ã®ã‚³ãƒ¼ãƒ‰ã¯ã€ :func:`product` ã®éƒ¨åˆ†åˆ—ã‹ã‚‰ã€è¦ç´ ãŒ (å…¥åŠ›ãƒ—ãƒ¼ãƒ«ã®ä½ç½®ã«å¾“ã£ã¦) ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸé †ã«ãªã£ã¦ã„ãªã„é …ç›®ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ãŸã‚‚ã®ã¨ã—ã¦ã‚‚è¡¨ã›ã¾ã™::"

#: ../../library/itertools.rst:213
msgid ""
"The number of items returned is ``(n+r-1)! / r! / (n-1)!`` when ``n > 0``."
msgstr "è¿”ã•ã‚Œã‚‹è¦ç´ ã®æ•°ã¯ã€``n > 0`` ã®ã¨ã ``(n+r-1)! / r! / (n-1)!`` ã§ã™ã€‚"

#: ../../library/itertools.rst:219
msgid ""
"Make an iterator that filters elements from *data* returning only those that"
" have a corresponding element in *selectors* that evaluates to ``True``. "
"Stops when either the *data* or *selectors* iterables has been exhausted. "
"Roughly equivalent to::"
msgstr "*data* ã®è¦ç´ ã‹ã‚‰ *selectors* ã®å¯¾å¿œã™ã‚‹è¦ç´ ãŒ ``True`` ã¨è©•ä¾¡ã•ã‚Œã‚‹ã‚‚ã®ã ã‘ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã—ãŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œã‚Šã¾ã™ã€‚*data* ã¨ *selectors* ã®ã„ãšã‚Œã‹ãŒå°½ããŸã¨ãã«æ­¢ã¾ã‚Šã¾ã™ã€‚ãŠã‚ˆãæ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/itertools.rst:233
msgid ""
"Make an iterator that returns evenly spaced values starting with *n*. Often "
"used as an argument to :func:`imap` to generate consecutive data points. "
"Also, used with :func:`izip` to add sequence numbers.  Equivalent to::"
msgstr "æ•°å€¤ *n* ã§å§‹ã¾ã‚‹ã€ç­‰é–“éš”ã®å€¤ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚ :func:`imap` ã§é€£ç¶šã—ãŸãƒ‡ãƒ¼ã‚¿ã®ç”Ÿæˆã«ã‚ˆãä½¿ã‚ã‚Œã¾ã™ã€‚ ã¾ãŸã€ :func:`izip` ã«ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ç•ªå·ã‚’è¿½åŠ ã™ã‚‹ã®ã«ã‚‚ä½¿ã‚ã‚Œã¾ã™ã€‚ ã“ã®é–¢æ•°ã¯ä»¥ä¸‹ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨åŒç­‰ã§ã™::"

#: ../../library/itertools.rst:245
msgid ""
"When counting with floating point numbers, better accuracy can sometimes be "
"achieved by substituting multiplicative code such as: ``(start + step * i "
"for i in count())``."
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã§æ•°ãˆã‚‹ã¨ãã¯ã€``(start + step * i for i in count())`` ã®ã‚ˆã†ã«ã€æ›ã‘ç®—ã‚’ä½¿ã£ãŸã‚³ãƒ¼ãƒ‰ã«ç½®ãæ›ãˆãŸã»ã†ãŒæ­£ç¢ºã«ã§ãã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/itertools.rst:249
msgid "added *step* argument and allowed non-integer arguments."
msgstr "*step* å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã€éæ•´æ•°ã®å¼•æ•°ãŒå¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/itertools.rst:254
msgid ""
"Make an iterator returning elements from the iterable and saving a copy of "
"each. When the iterable is exhausted, return elements from the saved copy.  "
"Repeats indefinitely.  Roughly equivalent to::"
msgstr "ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‹ã‚‰è¦ç´ ã‚’å–å¾—ã—ã€ãã®ã‚³ãƒ”ãƒ¼ã‚’ä¿å­˜ã™ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã®å…¨è¦ç´ ã‚’è¿”ã™ã¨ã€ã‚»ãƒ¼ãƒ–ã•ã‚ŒãŸã‚³ãƒ”ãƒ¼ã‹ã‚‰è¦ç´ ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã‚’ç„¡é™ã«ç¹°ã‚Šè¿”ã—ã¾ã™ã€‚ãŠã‚ˆãæ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/itertools.rst:268
msgid ""
"Note, this member of the toolkit may require significant auxiliary storage "
"(depending on the length of the iterable)."
msgstr ":func:`cycle` ã¯å¤§ããªãƒ¡ãƒ¢ãƒªé ˜åŸŸã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ä½¿ç”¨ã™ã‚‹ãƒ¡ãƒ¢ãƒªé‡ã¯ iterable ã®å¤§ãã•ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/itertools.rst:274
msgid ""
"Make an iterator that drops elements from the iterable as long as the "
"predicate is true; afterwards, returns every element.  Note, the iterator "
"does not produce *any* output until the predicate first becomes false, so it"
" may have a lengthy start-up time.  Roughly equivalent to::"
msgstr "predicate (è¿°èª) ãŒçœŸã§ã‚ã‚‹é–“ã¯è¦ç´ ã‚’é£›ã°ã—ã€ãã®å¾Œã¯å…¨ã¦ã®è¦ç´ ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚ã“ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€predicate ãŒæœ€åˆã«å½ã«ãªã‚‹ã¾ã§ *å…¨ã* è¦ç´ ã‚’è¿”ã•ãªã„ãŸã‚ã€è¦ç´ ã‚’è¿”ã—å§‹ã‚ã‚‹ã¾ã§ã«é•·ã„æ™‚é–“ãŒã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ãŠã‚ˆãæ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/itertools.rst:292
msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each element."
"  If not specified or is ``None``, *key* defaults to an identity function "
"and returns the element unchanged.  Generally, the iterable needs to already"
" be sorted on the same key function."
msgstr "åŒã˜ã‚­ãƒ¼ã‚’ã‚‚ã¤ã‚ˆã†ãªè¦ç´ ã‹ã‚‰ãªã‚‹ *iterable* ä¸­ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«å¯¾ã—ã¦ã€ã‚­ãƒ¼ã¨ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¿”ã™ã‚ˆã†ãªã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚*key* ã¯å„è¦ç´ ã«å¯¾ã™ã‚‹ã‚­ãƒ¼å€¤ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã§ã™ã€‚ã‚­ãƒ¼ã‚’æŒ‡å®šã—ãªã„å ´åˆã‚„ ``None`` ã«ã—ãŸå ´åˆã€*key* é–¢æ•°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ’ç­‰é–¢æ•°ã«ãªã‚Šè¦ç´ ã‚’ãã®ã¾ã¾è¿”ã—ã¾ã™ã€‚é€šå¸¸ã€*iterable* ã¯åŒã˜ã‚­ãƒ¼é–¢æ•°ã§ä¸¦ã¹æ›¿ãˆæ¸ˆã¿ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/itertools.rst:298
msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in Unix."
"  It generates a break or new group every time the value of the key function"
" changes (which is why it is usually necessary to have sorted the data using"
" the same key function).  That behavior differs from SQL's GROUP BY which "
"aggregates common elements regardless of their input order."
msgstr ":func:`groupby` ã®æ“ä½œã¯ Unix ã® ``uniq`` ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã¨ä¼¼ã¦ã„ã¾ã™ã€‚ key é–¢æ•°ã®å€¤ãŒå¤‰ã‚ã‚‹ãŸã³ã«ä¼‘æ­¢ã¾ãŸã¯æ–°ã—ã„ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ç”Ÿæˆã—ã¾ã™ (ã“ã®ãŸã‚ã«é€šå¸¸åŒã˜ key é–¢æ•°ã§ã‚½ãƒ¼ãƒˆã—ã¦ãŠãå¿…è¦ãŒã‚ã‚‹ã®ã§ã™)ã€‚ã“ã®å‹•ä½œã¯ SQL ã®å…¥åŠ›é †ã«é–¢ä¿‚ãªãå…±é€šã®è¦ç´ ã‚’é›†ç´„ã™ã‚‹ GROUP BY ã¨ã¯é•ã¾ã™ã€‚"

#: ../../library/itertools.rst:304
msgid ""
"The returned group is itself an iterator that shares the underlying iterable"
" with :func:`groupby`.  Because the source is shared, when the "
":func:`groupby` object is advanced, the previous group is no longer visible."
"  So, if that data is needed later, it should be stored as a list::"
msgstr "è¿”ã•ã‚Œã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã¯ãã‚Œè‡ªä½“ãŒã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã§ã€ :func:`groupby` ã¨ *iterable* ã‚’å…±æœ‰ã—ã¦ã„ã¾ã™ã€‚ã‚‚ã¨ã¨ãªã‚‹ *iterable* ã‚’å…±æœ‰ã—ã¦ã„ã‚‹ãŸã‚ã€ :func:`groupby` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¦ç´ å–ã‚Šå‡ºã—ã‚’å…ˆã«é€²ã‚ã‚‹ã¨ã€ãã‚Œä»¥å‰ã®è¦ç´ ã§ã‚ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã¯è¦‹ãˆãªããªã£ã¦ã—ã¾ã„ã¾ã™ã€‚å¾“ã£ã¦ã€ãƒ‡ãƒ¼ã‚¿ãŒå¾Œã§å¿…è¦ãªå ´åˆã«ã¯ãƒªã‚¹ãƒˆã®å½¢ã§ä¿å­˜ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™::"

#: ../../library/itertools.rst:316
msgid ":func:`groupby` is roughly equivalent to::"
msgstr ":func:`groupby` ã¯ãŠã‚ˆãæ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/itertools.rst:346
msgid ""
"Make an iterator that filters elements from iterable returning only those "
"for which the predicate is ``True``. If *predicate* is ``None``, return the "
"items that are true. Roughly equivalent to::"
msgstr "iteable ã‹ã‚‰ predicate ãŒ ``True`` ã¨ãªã‚‹è¦ç´ ã ã‘ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚*predicate* ãŒ ``None`` ã®å ´åˆã€çœŸã®è¦ç´ ã ã‘ã‚’è¿”ã—ã¾ã™ã€‚ãŠã‚ˆãæ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/itertools.rst:361
msgid ""
"Make an iterator that filters elements from iterable returning only those "
"for which the predicate is ``False``. If *predicate* is ``None``, return the"
" items that are false. Roughly equivalent to::"
msgstr "iteable ã‹ã‚‰ predicate ãŒ ``False`` ã¨ãªã‚‹è¦ç´ ã ã‘ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚*predicate* ãŒ ``None`` ã®å ´åˆã€å½ã®è¦ç´ ã ã‘ã‚’è¿”ã—ã¾ã™ã€‚ãŠã‚ˆãæ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/itertools.rst:376
msgid ""
"Make an iterator that computes the function using arguments from each of the"
" iterables.  If *function* is set to ``None``, then :func:`imap` returns the"
" arguments as a tuple.  Like :func:`map` but stops when the shortest "
"iterable is exhausted instead of filling in ``None`` for shorter iterables."
"  The reason for the difference is that infinite iterator arguments are "
"typically an error for :func:`map` (because the output is fully evaluated) "
"but represent a common and useful way of supplying arguments to "
":func:`imap`. Roughly equivalent to::"
msgstr "iterables ã®å„è¦ç´ ã‚’å¼•æ•°ã¨ã—ã¦ funtion ã‚’å‘¼ã³å‡ºã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚\n*function* ãŒ ``None`` ã®å ´åˆã€ :func:`imap` ã¯å¼•æ•°ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚\n:func:`map` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€æœ€çŸ­ã® iterable ã®æœ«å°¾ã¾ã§åˆ°é”ã—ãŸå¾Œã¯ãã“ã§çµ‚äº†ã—ã¾ã™ã€‚çŸ­ã„ iterable ã®ã¨ã“ã‚ã‚’ ``None`` ã§è£œã£ãŸã‚Šã¯ã—ã¾ã›ã‚“ã€‚\nã“ã®é•ã„ã¯ã€ :func:`map` ã«ç„¡é™é•·ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’æŒ‡å®šã™ã‚‹ã®ã¯ãŸã„ã¦ã„ã¯èª¤ã‚Š (å…¨å‡ºåŠ›ãŒè©•ä¾¡ã•ã‚Œã¦ã—ã¾ã†ãŸã‚) ãªã®ã§ã™ãŒã€ :func:`imap` ã®å ´åˆã«ã¯ä¸€èˆ¬çš„ã§å½¹ã«ç«‹ã¤æ–¹æ³•ã§ã‚ã‚‹ãŸã‚ã§ã™ã€‚\nã“ã®é–¢æ•°ã¯ãŠã‚ˆãä»¥ä¸‹ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨åŒç­‰ã§ã™::"

#: ../../library/itertools.rst:398
msgid ""
"Make an iterator that returns selected elements from the iterable. If "
"*start* is non-zero, then elements from the iterable are skipped until start"
" is reached. Afterward, elements are returned consecutively unless *step* is"
" set higher than one which results in items being skipped.  If *stop* is "
"``None``, then iteration continues until the iterator is exhausted, if at "
"all; otherwise, it stops at the specified position.  Unlike regular slicing,"
" :func:`islice` does not support negative values for *start*, *stop*, or "
"*step*.  Can be used to extract related fields from data where the internal "
"structure has been flattened (for example, a multi-line report may list a "
"name field on every third line).  Roughly equivalent to::"
msgstr "iterable ã‹ã‚‰è¦ç´ ã‚’é¸æŠã—ã¦è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚ *start* ãŒ0ã§ãªã„å ´åˆã€iterable ã®è¦ç´ ã¯ start ã«é”ã™ã‚‹ã¾ã§ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚ãã®å¾Œã€\nè¦ç´ ãŒé †ã«è¿”ã•ã‚Œã¾ã™ã€‚\n *step* ãŒ1ä»¥ä¸‹ãªã‚‰é€£ç¶šã—ãŸè¦ç´ ã‚’è¿”ã—ã€ 1ä»¥ä¸Šãªã‚‰æŒ‡å®šã•ã‚ŒãŸå€¤åˆ†ã®è¦ç´ ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚\n\n*stop* ãŒ ``None`` ã®å ´åˆã€iterable ãŒå°½ãã‚‹ã¾ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯ç¶šãã¾ã™ã€‚\nãã‚Œä»¥å¤–ã®å ´åˆã€æŒ‡å®šã•ã‚ŒãŸä½ç½®ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯åœæ­¢ã—ã¾ã™ã€‚\né€šå¸¸ã®ã‚¹ãƒ©ã‚¤ã‚¹ã¨ã¯ç•°ãªã‚Šã€:func:`islice` ã¯è² ã® *start*ã€*stop*ã€*step* ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚å†…éƒ¨æ§‹é€ ãŒå¹³æ»‘åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é–¢é€£ã™ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŠ½å‡ºã™ã‚‹ã®ã«ã«ä½¿ç”¨ã§ãã¾ã™ (ãŸã¨ãˆã°ã€ä¸‰è¡Œã”ã¨ã«åå‰ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åˆ—æŒ™ã—ã¦ã„ã‚‹è¤‡æ•°è¡Œã®ãƒ¬ãƒãƒ¼ãƒˆ)ã€‚ãŠã‚ˆãæ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/itertools.rst:433
msgid ""
"If *start* is ``None``, then iteration starts at zero. If *step* is "
"``None``, then the step defaults to one."
msgstr "*start* ãŒ ``None`` ãªã‚‰ã°ã€ç¹°è¿”ã—ã¯0ã‹ã‚‰å§‹ã¾ã‚Šã¾ã™ã€‚*step* ãŒ ``None`` ãªã‚‰ã°ã€ã‚¹ãƒ†ãƒƒãƒ—ã¯1ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/itertools.rst:436
msgid "accept ``None`` values for default *start* and *step*."
msgstr "*start* ã¨ *step* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ã—ã¦ ``None`` ã‚’å—ã‘ä»˜ã‘ã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚"

#: ../../library/itertools.rst:442
msgid ""
"Make an iterator that aggregates elements from each of the iterables. Like "
":func:`zip` except that it returns an iterator instead of a list.  Used for "
"lock-step iteration over several iterables at a time.  Roughly equivalent "
"to::"
msgstr "å„ iterable ã®è¦ç´ ã‚’ã¾ã¨ã‚ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚ :func:`zip` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ãƒªã‚¹ãƒˆã§ã¯ãªãã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚è¤‡æ•°ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã€ä¸€åº¦ã« lock-step (æ¨ªä¸¦ã³) ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¡Œã†å ´åˆã«ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ãŠã‚ˆãä»¥ä¸‹ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨åŒç­‰ã§ã™::"

#: ../../library/itertools.rst:452
msgid ""
"When no iterables are specified, returns a zero length iterator instead of "
"raising a :exc:`TypeError` exception."
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã—ãªã„å ´åˆã€ :exc:`TypeError` ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ä»£ã‚ã‚Šã«é•·ã•ã‚¼ãƒ­ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/itertools.rst:456
msgid ""
"The left-to-right evaluation order of the iterables is guaranteed. This "
"makes possible an idiom for clustering a data series into n-length groups "
"using ``izip(*[iter(s)]*n)``."
msgstr "ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã®å·¦ã‹ã‚‰å³ã¸ã®è©•ä¾¡é †åºãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚ãã®ãŸã‚ ``izip(*[iter(s)]*n)`` ã‚’ä½¿ã£ã¦ãƒ‡ãƒ¼ã‚¿ç³»åˆ—ã‚’ n é•·ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ã§ãã¾ã™ã€‚"

#: ../../library/itertools.rst:460
msgid ""
":func:`izip` should only be used with unequal length inputs when you don't "
"care about trailing, unmatched values from the longer iterables.  If those "
"values are important, use :func:`izip_longest` instead."
msgstr ":func:`izip` ã¯ã€ç­‰ã—ããªã„é•·ã•ã®å…¥åŠ›ã«å¯¾ã—ã¦ã¯ã€é•·ã„æ–¹ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã®ã€çµ‚ç«¯ã®å¯¾ã«ãªã‚‰ãªã„å€¤ã‚’æ°—ã«ã—ãªã„ã®ã§ãªã‘ã‚Œã°ã€ä½¿ã†ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã®ã‚ˆã†ãªå€¤ãŒé‡è¦ãªã‚‰ã€ã‹ã‚ã‚Šã« :func:`izip_longest` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/itertools.rst:467
msgid ""
"Make an iterator that aggregates elements from each of the iterables. If the"
" iterables are of uneven length, missing values are filled-in with "
"*fillvalue*. Iteration continues until the longest iterable is exhausted.  "
"Roughly equivalent to::"
msgstr "å„ iterable ã®è¦ç´ ã‚’ã¾ã¨ã‚ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚iterable ã®é•·ã•ãŒé•ã†å ´åˆã€è¶³ã‚Šãªã„å€¤ã¯ *fillvalue* ã§åŸ‹ã‚ã‚‰ã‚Œã¾ã™ã€‚æœ€ã‚‚é•·ã„ itarable ãŒå°½ãã‚‹ã¾ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¾ã™ã€‚ãŠã‚ˆãæ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/itertools.rst:491
msgid ""
"If one of the iterables is potentially infinite, then the "
":func:`izip_longest` function should be wrapped with something that limits "
"the number of calls (for example :func:`islice` or :func:`takewhile`).  If "
"not specified, *fillvalue* defaults to ``None``."
msgstr "iterables ã®1ã¤ãŒç„¡é™ã«ãªã‚Šã†ã‚‹å ´åˆ :func:`izip_longest` ã¯å‘¼ã³å‡ºã—å›æ•°ã‚’åˆ¶é™ã™ã‚‹ã‚ˆã†ãªä½•ã‹ã§ãƒ©ãƒƒãƒ—ã—ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“(ä¾‹ãˆã° :func:`islice` or :func:`takewhile`)ã€‚ *fillvalue* ã¯æŒ‡å®šã—ãªã„å ´åˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯  ``None`` ã§ã™ã€‚"

#: ../../library/itertools.rst:500
msgid ""
"Return successive *r* length permutations of elements in the *iterable*."
msgstr "*iterable* ã®è¦ç´ ã‹ã‚‰ãªã‚‹é•·ã• *r* ã®ç½®æ›(permutation)ã‚’æ¬¡ã€…ã¨è¿”ã—ã¾ã™ã€‚"

#: ../../library/itertools.rst:502
msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length of "
"the *iterable* and all possible full-length permutations are generated."
msgstr "*r* ãŒæŒ‡å®šã•ã‚Œãªã„ã‹ã¾ãŸã¯ ``None`` ã§ã‚ã‚‹ãªã‚‰ã°ã€*r* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ *iterable* ã®é•·ã•ã¨ãªã‚Šå…¨ã¦ã®å¯èƒ½ãªæœ€é•·ã®ç½®æ›ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/itertools.rst:506
msgid ""
"Permutations are emitted in lexicographic sort order.  So, if the input "
"*iterable* is sorted, the permutation tuples will be produced in sorted "
"order."
msgstr "ç½®æ›ã¯è¾æ›¸å¼ã«ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸé †åºã§åãå‡ºã•ã‚Œã¾ã™ã€‚ã—ãŸãŒã£ã¦å…¥åŠ›ã® *iterable* ãŒã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ãŸãªã‚‰ã°ã€ç½®æ›ã®ã‚¿ãƒ—ãƒ«ã¯ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸçŠ¶æ…‹ã§å‡ºåŠ›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/itertools.rst:510
msgid ""
"Elements are treated as unique based on their position, not on their value."
"  So if the input elements are unique, there will be no repeat values in "
"each permutation."
msgstr "è¦ç´ ã¯ä½ç½®ã«åŸºã¥ã„ã¦ä¸€æ„çš„ã«æ‰±ã‚ã‚Œã€å€¤ã«åŸºã¥ã„ã¦ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã—ãŸãŒã£ã¦å…¥åŠ›ã•ã‚ŒãŸè¦ç´ ãŒå…¨ã¦ç•°ãªã£ã¦ã„ã‚‹ãªã‚‰ã°ã€ãã‚Œãã‚Œã®ç½®æ›ã«é‡è¤‡ã—ãŸè¦ç´ ãŒç¾ã‚Œãªã„ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/itertools.rst:541
msgid ""
"The code for :func:`permutations` can be also expressed as a subsequence of "
":func:`product`, filtered to exclude entries with repeated elements (those "
"from the same position in the input pool)::"
msgstr ":func:`permutations` ã®ã‚³ãƒ¼ãƒ‰ã¯ :func:`product` ã®åˆ—ã‹ã‚‰é‡è¤‡ã®ã‚ã‚‹ã‚‚ã® (ãã‚Œã‚‰ã¯å…¥åŠ›ãƒ—ãƒ¼ãƒ«ã®åŒã˜ä½ç½®ã‹ã‚‰å–ã‚‰ã‚ŒãŸã‚‚ã®ã§ã™) ã‚’é™¤å¤–ã™ã‚‹ã‚ˆã†ã«ãƒ•ã‚£ãƒ«ã‚¿ã‚’æ›ã‘ãŸã‚‚ã®ã¨ã—ã¦ã‚‚è¡¨ç¾ã§ãã¾ã™::"

#: ../../library/itertools.rst:553
msgid ""
"The number of items returned is ``n! / (n-r)!`` when ``0 <= r <= n`` or zero"
" when ``r > n``."
msgstr "è¿”ã•ã‚Œã‚‹è¦ç´ ã®æ•°ã¯ã€``0 <= r <= n`` ã®å ´åˆ ``n! / (n-r)!`` ã§ã€``r > n`` ã®å ´åˆã¯ 0 ã§ã™ã€‚"

#: ../../library/itertools.rst:560
msgid "Cartesian product of input iterables."
msgstr "å…¥åŠ›ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã®ç›´ç©(Cartesian product)ã§ã™ã€‚"

#: ../../library/itertools.rst:562
msgid ""
"Roughly equivalent to nested for-loops in a generator expression. For "
"example, ``product(A, B)`` returns the same as ``((x,y) for x in A for y in "
"B)``."
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å¼ã®å…¥ã‚Œå­ã«ãªã£ãŸ for ãƒ«ãƒ¼ãƒ—ã¨ãŠã‚ˆãç­‰ä¾¡ã§ã™ã€‚ãŸã¨ãˆã° ``product(A, B)`` ã¯ ``((x,y) for x in A for y in B)`` ã¨åŒã˜ã‚‚ã®ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/itertools.rst:565
msgid ""
"The nested loops cycle like an odometer with the rightmost element advancing"
" on every iteration.  This pattern creates a lexicographic ordering so that "
"if the input's iterables are sorted, the product tuples are emitted in "
"sorted order."
msgstr "å…¥ã‚Œå­ãƒ«ãƒ¼ãƒ—ã¯èµ°è¡Œè·é›¢è¨ˆã¨åŒã˜ã‚ˆã†ã«å³ç«¯ã®è¦ç´ ãŒã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã”ã¨ã«æ›´æ–°ã•ã‚Œã¦ã„ãã¾ã™ã€‚ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯è¾æ›¸å¼é †åºã‚’ä½œã‚Šå‡ºã—ã€å…¥åŠ›ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŸã¡ãŒã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚Œã°ã€ç›´ç©ã‚¿ãƒ—ãƒ«ã‚‚ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸé †ã«åãå‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/itertools.rst:570
msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr "ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«è‡ªèº«ã¨ã®ç›´ç©ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«ã¯ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *repeat* ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã«ç¹°ã‚Šè¿”ã—å›æ•°ã‚’æŒ‡å®šã—ã¾ã™ã€‚ãŸã¨ãˆã° ``product(A, repeat=4)`` ã¯  ``product(A, A, A, A)`` ã¨åŒã˜æ„å‘³ã§ã™ã€‚"

#: ../../library/itertools.rst:574
msgid ""
"This function is roughly equivalent to the following code, except that the "
"actual implementation does not build up intermediate results in memory::"
msgstr "ã“ã®é–¢æ•°ã¯ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¨ãŠã‚ˆãç­‰ä¾¡ã§ã™ãŒã€å®Ÿéš›ã®å®Ÿè£…ã§ã¯ãƒ¡ãƒ¢ãƒªä¸­ã«ä¸­é–“çµæœã‚’ä½œã‚Šã¾ã›ã‚“::"

#: ../../library/itertools.rst:591
msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified. Used as argument to "
":func:`imap` for invariant function parameters.  Also used with :func:`izip`"
" to create constant fields in a tuple record.  Roughly equivalent to::"
msgstr "ç¹°ã‚Šè¿”ã— *object* ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚ *times* ã‚’æŒ‡å®šã—ãªã„å ´åˆã€ç„¡é™ã«å€¤ã‚’è¿”ã—ç¶šã‘ã¾ã™ã€‚ :func:`imap` ã§å¸¸ã«åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é–¢æ•°ã®å¼•æ•°ã¨ã—ã¦æŒ‡å®šã™ã‚‹å ´åˆã«ä½¿ç”¨ã—ã¾ã™ã€‚ã¾ãŸã€ :func:`izip` ã§ä½œæˆã™ã‚‹ã‚¿ãƒ—ãƒ«ã®å®šæ•°éƒ¨åˆ†ã‚’æŒ‡å®šã™ã‚‹å ´åˆã«ã‚‚ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ãŠã‚ˆãä»¥ä¸‹ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨åŒç­‰ã§ã™::"

#: ../../library/itertools.rst:605
msgid ""
"A common use for *repeat* is to supply a stream of constant values to *imap*"
" or *zip*::"
msgstr "*repeat* ã¯ *imap* ã‚„ *zip* ã«å®šæ•°ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä¸ãˆã‚‹ãŸã‚ã«ã‚ˆãåˆ©ç”¨ã•ã‚Œã¾ã™::"

#: ../../library/itertools.rst:613
msgid ""
"Make an iterator that computes the function using arguments obtained from "
"the iterable.  Used instead of :func:`imap` when argument parameters are "
"already grouped in tuples from a single iterable (the data has been \"pre-"
"zipped\").  The difference between :func:`imap` and :func:`starmap` "
"parallels the distinction between ``function(a,b)`` and ``function(*c)``. "
"Roughly equivalent to::"
msgstr "iterable ã®è¦ç´ ã‚’å¼•æ•°ã¨ã—ã¦ function ã‚’è¨ˆç®—ã™ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚\nfunction ã®å¼•æ•°ãŒä¸€ã¤ã® iterable ã‹ã‚‰ã‚¿ãƒ—ãƒ«ã«æ—¢ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã•ã‚Œã¦ã„ã‚‹ (ãƒ‡ãƒ¼ã‚¿ãŒ \"zipæ¸ˆã¿\") å ´åˆã€:func:`imap` ã®ä»£ã‚ã‚Šã«ä½¿ç”¨ã—ã¾ã™ã€‚\n:func:`imap` ã¨ :func:`starmap` ã®é•ã„ã¯ ``function(a,b)`` ã¨ ``function(*c)`` ã®å·®ã«ä¼¼ã¦ã„ã¾ã™ã€‚ãŠã‚ˆãæ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/itertools.rst:624
msgid ""
"Previously, :func:`starmap` required the function arguments to be tuples. "
"Now, any iterable is allowed."
msgstr "ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ :func:`starmap` ã¯é–¢æ•°ã®å¼•æ•°ãŒã‚¿ãƒ—ãƒ«ã§ã‚ã‚‹ã“ã¨ãŒå¿…è¦ã§ã—ãŸã€‚ä»Šã§ã¯ä»»æ„ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ãˆã¾ã™ã€‚"

#: ../../library/itertools.rst:630
msgid ""
"Make an iterator that returns elements from the iterable as long as the "
"predicate is true.  Roughly equivalent to::"
msgstr "predicate ãŒçœŸã§ã‚ã‚‹é™ã‚Š iterable ã‹ã‚‰è¦ç´ ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚ãŠã‚ˆãæ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/itertools.rst:644
msgid ""
"Return *n* independent iterators from a single iterable.  Roughly equivalent"
" to::"
msgstr "ä¸€ã¤ã® *iterable* ã‹ã‚‰ *n* å€‹ã®ç‹¬ç«‹ã—ãŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ç”Ÿæˆã—ã¦è¿”ã—ã¾ã™ã€‚ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¨ãŠã‚ˆãç­‰ä¾¡ã«ãªã‚Šã¾ã™::"

#: ../../library/itertools.rst:658
msgid ""
"Once :func:`tee` has made a split, the original *iterable* should not be "
"used anywhere else; otherwise, the *iterable* could get advanced without the"
" tee objects being informed."
msgstr "ä¸€åº¦ :func:`tee` ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’åˆ†å‰²ã™ã‚‹ã¨ã€ã‚‚ã¨ã® *iterable* ã‚’ä»–ã§ä½¿ã£ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚ã•ã‚‚ãªã‘ã‚Œã°ã€ :func:`tee` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®çŸ¥ã‚‰ãªã„é–“ã« *iterable* ãŒå…ˆã®è¦ç´ ã«é€²ã‚“ã§ã—ã¾ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/itertools.rst:662
msgid ""
"This itertool may require significant auxiliary storage (depending on how "
"much temporary data needs to be stored). In general, if one iterator uses "
"most or all of the data before another iterator starts, it is faster to use "
":func:`list` instead of :func:`tee`."
msgstr ":func:`tee` ã¯ã‹ãªã‚Šå¤§ããªãƒ¡ãƒ¢ãƒªé ˜åŸŸã‚’ä½¿ç”¨ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ (ä½¿ç”¨ã™ã‚‹ãƒ¡ãƒ¢ãƒªé‡ã¯iterableã®å¤§ãã•ã«ä¾å­˜ã—ã¾ã™)ã€‚ä¸€èˆ¬ã«ã¯ã€ä¸€ã¤ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒä»–ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚ˆã‚Šã‚‚å…ˆã«ã»ã¨ã‚“ã©ã¾ãŸã¯å…¨ã¦ã®è¦ç´ ã‚’æ¶ˆè²»ã™ã‚‹ã‚ˆã†ãªå ´åˆã«ã¯ã€ :func:`tee` ã‚ˆã‚Šã‚‚ :func:`list` ã‚’ä½¿ã£ãŸæ–¹ãŒé«˜é€Ÿã§ã™ã€‚"

#: ../../library/itertools.rst:673
msgid "Recipes"
msgstr "ãƒ¬ã‚·ãƒ”"

#: ../../library/itertools.rst:675
msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr "ã“ã®ç¯€ã§ã¯ã€æ—¢å­˜ã® itertools ã‚’ç´ æã¨ã—ã¦ãƒ„ãƒ¼ãƒ«ã‚»ãƒƒãƒˆã‚’æ‹¡å¼µã™ã‚‹ãŸã‚ã®ãƒ¬ã‚·ãƒ”ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/itertools.rst:678
msgid ""
"The extended tools offer the same high performance as the underlying "
"toolset. The superior memory performance is kept by processing elements one "
"at a time rather than bringing the whole iterable into memory all at once. "
"Code volume is kept small by linking the tools together in a functional "
"style which helps eliminate temporary variables.  High speed is retained by "
"preferring \"vectorized\" building blocks over the use of for-loops and "
":term:`generator`\\s which incur interpreter overhead."
msgstr "iterable å…¨ä½“ã‚’ä¸€åº¦ã«ãƒ¡ãƒ¢ãƒªä¸Šã«ç½®ãã‚ˆã‚Šã‚‚ã€è¦ç´ ã‚’ä¸€ã¤ã¥ã¤å‡¦ç†ã™ã‚‹æ–¹ãŒãƒ¡ãƒ¢ãƒªåŠ¹ç‡ä¸Šã®æœ‰åˆ©ã•ã‚’ä¿ã¦ã¾ã™ã€‚é–¢æ•°å½¢å¼ã®ã¾ã¾ãƒ„ãƒ¼ãƒ«ã‚’ãƒªãƒ³ã‚¯ã—ã¦ã‚†ãã¨ã€ã‚³ãƒ¼ãƒ‰ã®ã‚µã‚¤ã‚ºã‚’æ¸›ã‚‰ã—ã€ä¸€æ™‚å¤‰æ•°ã‚’æ¸›ã‚‰ã™åŠ©ã‘ã«ãªã‚Šã¾ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ã‚ªãƒ¼ãƒãƒ˜ãƒƒãƒ‰ã‚’ã‚‚ãŸã‚‰ã™ for ãƒ«ãƒ¼ãƒ—ã‚„ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿(:term:`generator`) ã‚’ä½¿ã‚ãšã«ã€ \"ãƒ™ã‚¯ãƒˆãƒ«åŒ–ã•ã‚ŒãŸ\" ãƒ“ãƒ«ãƒ‡ã‚£ãƒ³ã‚°ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½¿ã†ã¨ã€é«˜é€Ÿãªå‡¦ç†ã‚’å®Ÿç¾ã§ãã¾ã™ã€‚"

#: ../../library/itertools.rst:860
msgid ""
"Note, many of the above recipes can be optimized by replacing global lookups"
" with local variables defined as default values.  For example, the "
"*dotproduct* recipe can be written as::"
msgstr "ä¸Šè¨˜ã®ãƒ¬ã‚·ãƒ”ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒ‡å®šã—ã¦ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªåå‰æ¤œç´¢ã‚’ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®æ¤œç´¢ã«å¤‰ãˆã‚‹ã“ã¨ã§ã€ã‚ˆã‚ŠåŠ¹ç‡ã‚’ä¸Šã’ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€*dotproduct* ã®ãƒ¬ã‚·ãƒ”ã‚’æ›¸ãæ›ãˆã‚‹ã¨ã™ã‚Œã°ã“ã‚“ãªå…·åˆã§ã™::"
