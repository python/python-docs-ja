# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト)
# This file is distributed under the same license as the Python package.
# 
# Translators:
# cocoatomo, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: 2017-03-22 19:25+0000\n"
"Last-Translator: cocoatomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/itertools.rst:3
msgid ""
":mod:`itertools` --- Functions creating iterators for efficient looping"
msgstr ":mod:`itertools` --- 効率的なループ実行のためのイテレータ生成関数"

#: ../../library/itertools.rst:17
msgid ""
"This module implements a number of :term:`iterator` building blocks inspired"
" by constructs from APL, Haskell, and SML.  Each has been recast in a form "
"suitable for Python."
msgstr "このモジュールではイテレータ(:term:`iterator`)を構築する部品を実装しています。プログラム言語 APL, Haskell, SML からアイデアを得ていますが、 Python に適した形に修正されています。"

#: ../../library/itertools.rst:21
msgid ""
"The module standardizes a core set of fast, memory efficient tools that are "
"useful by themselves or in combination.  Together, they form an \"iterator "
"algebra\" making it possible to construct specialized tools succinctly and "
"efficiently in pure Python."
msgstr "このモジュールは、高速でメモリ効率に優れ、単独でも組合せても使用することのできるツールを標準化したものです。同時に、このツール群は \"イテレータの代数\" を構成していて、pure Python で簡潔かつ効率的なツールを作れるようにしています。"

#: ../../library/itertools.rst:26
msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which produces"
" a sequence ``f(0), f(1), ...``.  The same effect can be achieved in Python "
"by combining :func:`imap` and :func:`count` to form ``imap(f, count())``."
msgstr "例えば、SML の作表ツール ``tabulate(f)`` は ``f(0), f(1), ...`` のシーケンスを作成します。同じことを Python では :func:`imap` と :func:`count` を組合せて ``imap(f, count())`` という形で実現できます。"

#: ../../library/itertools.rst:30
msgid ""
"These tools and their built-in counterparts also work well with the high-"
"speed functions in the :mod:`operator` module.  For example, the "
"multiplication operator can be mapped across two vectors to form an "
"efficient dot-product: ``sum(imap(operator.mul, vector1, vector2))``."
msgstr "これらのツールと組み込み関数は :mod:`operator` モジュール内の高速な関数とともに使うことで見事に動作します。例えば、乗算演算子を2つのベクタにまたがってマップして効率的な内積計算が実現できます: ``sum(imap(operator.mul, vector1, vector2))`` 。"

#: ../../library/itertools.rst:36
msgid "**Infinite Iterators:**"
msgstr "**無限イテレータ:**"

#: ../../library/itertools.rst:39 ../../library/itertools.rst:49
#: ../../library/itertools.rst:69
msgid "Iterator"
msgstr "イテレータ"

#: ../../library/itertools.rst:39 ../../library/itertools.rst:49
#: ../../library/itertools.rst:69
msgid "Arguments"
msgstr "引数"

#: ../../library/itertools.rst:39 ../../library/itertools.rst:49
#: ../../library/itertools.rst:69
msgid "Results"
msgstr "結果"

#: ../../library/itertools.rst:39 ../../library/itertools.rst:49
msgid "Example"
msgstr "例"

#: ../../library/itertools.rst:41
msgid ":func:`count`"
msgstr ":func:`count`"

#: ../../library/itertools.rst:41
msgid "start, [step]"
msgstr "start, [step]"

#: ../../library/itertools.rst:41
msgid "start, start+step, start+2*step, ..."
msgstr "start, start+step, start+2*step, ..."

#: ../../library/itertools.rst:41
msgid "``count(10) --> 10 11 12 13 14 ...``"
msgstr "``count(10) --> 10 11 12 13 14 ...``"

#: ../../library/itertools.rst:42
msgid ":func:`cycle`"
msgstr ":func:`cycle`"

#: ../../library/itertools.rst:42
msgid "p"
msgstr "p"

#: ../../library/itertools.rst:42
msgid "p0, p1, ... plast, p0, p1, ..."
msgstr "p0, p1, ... plast, p0, p1, ..."

#: ../../library/itertools.rst:42
msgid "``cycle('ABCD') --> A B C D A B C D ...``"
msgstr "``cycle('ABCD') --> A B C D A B C D ...``"

#: ../../library/itertools.rst:43
msgid ":func:`repeat`"
msgstr ":func:`repeat`"

#: ../../library/itertools.rst:43
msgid "elem [,n]"
msgstr "elem [,n]"

#: ../../library/itertools.rst:43
msgid "elem, elem, elem, ... endlessly or up to n times"
msgstr "elem, elem, elem, ... 無限もしくは n 回"

#: ../../library/itertools.rst:43
msgid "``repeat(10, 3) --> 10 10 10``"
msgstr "``repeat(10, 3) --> 10 10 10``"

#: ../../library/itertools.rst:46
msgid "**Iterators terminating on the shortest input sequence:**"
msgstr "**一番短い入力シーケンスで止まるイテレータ:**"

#: ../../library/itertools.rst:51
msgid ":func:`chain`"
msgstr ":func:`chain`"

#: ../../library/itertools.rst:51 ../../library/itertools.rst:62
#: ../../library/itertools.rst:63
msgid "p, q, ..."
msgstr "p, q, ..."

#: ../../library/itertools.rst:51
msgid "p0, p1, ... plast, q0, q1, ..."
msgstr "p0, p1, ... plast, q0, q1, ..."

#: ../../library/itertools.rst:51
msgid "``chain('ABC', 'DEF') --> A B C D E F``"
msgstr "``chain('ABC', 'DEF') --> A B C D E F``"

#: ../../library/itertools.rst:52
msgid ":func:`compress`"
msgstr ":func:`compress`"

#: ../../library/itertools.rst:52
msgid "data, selectors"
msgstr "data, selectors"

#: ../../library/itertools.rst:52
msgid "(d[0] if s[0]), (d[1] if s[1]), ..."
msgstr "(d[0] if s[0]), (d[1] if s[1]), ..."

#: ../../library/itertools.rst:52
msgid "``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"
msgstr "``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"

#: ../../library/itertools.rst:53
msgid ":func:`dropwhile`"
msgstr ":func:`dropwhile`"

#: ../../library/itertools.rst:53 ../../library/itertools.rst:55
#: ../../library/itertools.rst:56 ../../library/itertools.rst:61
msgid "pred, seq"
msgstr "pred, seq"

#: ../../library/itertools.rst:53
msgid "seq[n], seq[n+1], starting when pred fails"
msgstr "seq[n], seq[n+1], pred が偽の場所から始まる"

#: ../../library/itertools.rst:53
msgid "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"
msgstr "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"

#: ../../library/itertools.rst:54
msgid ":func:`groupby`"
msgstr ":func:`groupby`"

#: ../../library/itertools.rst:54
msgid "iterable[, keyfunc]"
msgstr "iterable[, keyfunc]"

#: ../../library/itertools.rst:54
msgid "sub-iterators grouped by value of keyfunc(v)"
msgstr "keyfunc(v) の値でグループ化したサブイテレータ"

#: ../../library/itertools.rst:55
msgid ":func:`ifilter`"
msgstr ":func:`ifilter`"

#: ../../library/itertools.rst:55
msgid "elements of seq where pred(elem) is true"
msgstr "pred(elem) が真になるseqの要素"

#: ../../library/itertools.rst:55
msgid "``ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9``"
msgstr "``ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9``"

#: ../../library/itertools.rst:56
msgid ":func:`ifilterfalse`"
msgstr ":func:`ifilterfalse`"

#: ../../library/itertools.rst:56
msgid "elements of seq where pred(elem) is false"
msgstr "pred(elem) が偽になるseqの要素"

#: ../../library/itertools.rst:56
msgid "``ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"
msgstr "``ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"

#: ../../library/itertools.rst:57
msgid ":func:`islice`"
msgstr ":func:`islice`"

#: ../../library/itertools.rst:57
msgid "seq, [start,] stop [, step]"
msgstr "seq, [start,] stop [, step]"

#: ../../library/itertools.rst:57
msgid "elements from seq[start:stop:step]"
msgstr "seq[start:stop:step]"

#: ../../library/itertools.rst:57
msgid "``islice('ABCDEFG', 2, None) --> C D E F G``"
msgstr "``islice('ABCDEFG', 2, None) --> C D E F G``"

#: ../../library/itertools.rst:58
msgid ":func:`imap`"
msgstr ":func:`imap`"

#: ../../library/itertools.rst:58
msgid "func, p, q, ..."
msgstr "func, p, q, ..."

#: ../../library/itertools.rst:58
msgid "func(p0, q0), func(p1, q1), ..."
msgstr "func(p0, q0), func(p1, q1), ..."

#: ../../library/itertools.rst:58
msgid "``imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000``"
msgstr "``imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000``"

#: ../../library/itertools.rst:59
msgid ":func:`starmap`"
msgstr ":func:`starmap`"

#: ../../library/itertools.rst:59
msgid "func, seq"
msgstr "func, seq"

#: ../../library/itertools.rst:59
msgid "func(\\*seq[0]), func(\\*seq[1]), ..."
msgstr "func(\\*seq[0]), func(\\*seq[1]), ..."

#: ../../library/itertools.rst:59
msgid "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"
msgstr "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"

#: ../../library/itertools.rst:60
msgid ":func:`tee`"
msgstr ":func:`tee`"

#: ../../library/itertools.rst:60
msgid "it, n"
msgstr "it, n"

#: ../../library/itertools.rst:60
msgid "it1, it2, ... itn  splits one iterator into n"
msgstr "it1, it2 , ... itn 一つのイテレータを n 個に分ける"

#: ../../library/itertools.rst:61
msgid ":func:`takewhile`"
msgstr ":func:`takewhile`"

#: ../../library/itertools.rst:61
msgid "seq[0], seq[1], until pred fails"
msgstr "seq[0], seq[1], pred が偽になるまで"

#: ../../library/itertools.rst:61
msgid "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"
msgstr "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"

#: ../../library/itertools.rst:62
msgid ":func:`izip`"
msgstr ":func:`izip`"

#: ../../library/itertools.rst:62 ../../library/itertools.rst:63
msgid "(p[0], q[0]), (p[1], q[1]), ..."
msgstr "(p[0], q[0]), (p[1], q[1]), ..."

#: ../../library/itertools.rst:62
msgid "``izip('ABCD', 'xy') --> Ax By``"
msgstr "``izip('ABCD', 'xy') --> Ax By``"

#: ../../library/itertools.rst:63
msgid ":func:`izip_longest`"
msgstr ":func:`izip_longest`"

#: ../../library/itertools.rst:63
msgid "``izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"
msgstr "``izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"

#: ../../library/itertools.rst:66
msgid "**Combinatoric generators:**"
msgstr "**組合せジェネレータ:**"

#: ../../library/itertools.rst:71
msgid ":func:`product`"
msgstr ":func:`product`"

#: ../../library/itertools.rst:71
msgid "p, q, ... [repeat=1]"
msgstr "p, q, ... [repeat=1]"

#: ../../library/itertools.rst:71
msgid "cartesian product, equivalent to a nested for-loop"
msgstr "デカルト積、ネストしたforループと等価"

#: ../../library/itertools.rst:72
msgid ":func:`permutations`"
msgstr ":func:`permutations`"

#: ../../library/itertools.rst:72
msgid "p[, r]"
msgstr "p[, r]"

#: ../../library/itertools.rst:72
msgid "r-length tuples, all possible orderings, no repeated elements"
msgstr "長さrのタプル列, 繰り返しを許さない順列"

#: ../../library/itertools.rst:73
msgid ":func:`combinations`"
msgstr ":func:`combinations`"

#: ../../library/itertools.rst:73 ../../library/itertools.rst:74
msgid "p, r"
msgstr "p, r"

#: ../../library/itertools.rst:73
msgid "r-length tuples, in sorted order, no repeated elements"
msgstr "長さrのタプル列, 繰り返しを許さない組合せ"

#: ../../library/itertools.rst:74
msgid ":func:`combinations_with_replacement`"
msgstr ":func:`combinations_with_replacement`"

#: ../../library/itertools.rst:74
msgid "r-length tuples, in sorted order, with repeated elements"
msgstr "長さrのタプル列, 繰り返しを許した組合せ"

#: ../../library/itertools.rst:75
msgid "``product('ABCD', repeat=2)``"
msgstr "``product('ABCD', repeat=2)``"

#: ../../library/itertools.rst:75
msgid "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"
msgstr "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"

#: ../../library/itertools.rst:76
msgid "``permutations('ABCD', 2)``"
msgstr "``permutations('ABCD', 2)``"

#: ../../library/itertools.rst:76
msgid "``AB AC AD BA BC BD CA CB CD DA DB DC``"
msgstr "``AB AC AD BA BC BD CA CB CD DA DB DC``"

#: ../../library/itertools.rst:77
msgid "``combinations('ABCD', 2)``"
msgstr "``combinations('ABCD', 2)``"

#: ../../library/itertools.rst:77
msgid "``AB AC AD BC BD CD``"
msgstr "``AB AC AD BC BD CD``"

#: ../../library/itertools.rst:78
msgid "``combinations_with_replacement('ABCD', 2)``"
msgstr "``combinations_with_replacement('ABCD', 2)``"

#: ../../library/itertools.rst:78
msgid "``AA AB AC AD BB BC BD CC CD DD``"
msgstr "``AA AB AC AD BB BC BD CC CD DD``"

#: ../../library/itertools.rst:85
msgid "Itertool functions"
msgstr "Itertool関数"

#: ../../library/itertools.rst:87
msgid ""
"The following module functions all construct and return iterators. Some "
"provide streams of infinite length, so they should only be accessed by "
"functions or loops that truncate the stream."
msgstr "以下の関数は全て、イテレータを作成して返します。無限長のストリームのイテレータを返す関数もあり、この場合にはストリームを中断するような関数かループ処理から使用しなければなりません。"

#: ../../library/itertools.rst:94
msgid ""
"Make an iterator that returns elements from the first iterable until it is "
"exhausted, then proceeds to the next iterable, until all of the iterables "
"are exhausted.  Used for treating consecutive sequences as a single "
"sequence. Roughly equivalent to::"
msgstr "先頭の iterable の全要素を返し、次に2番目の iterable の全要素を返し、と全 iterable の要素を返すイテレータを作成します。連続したシーケンスを一つのシーケンスとして扱う場合に使用します。およそ次と等価です::"

#: ../../library/itertools.rst:108
msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a single "
"iterable argument that is evaluated lazily.  Roughly equivalent to::"
msgstr ":func:`chain` のためのもう一つのコンストラクタです。遅延評価される唯一のイテラブル引数から連鎖した入力を受け取ります。この関数は、以下のコードとほぼ等価です::"

#: ../../library/itertools.rst:122
msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr "入力 *iterable* の要素からなる長さ *r* の部分列を返します。"

#: ../../library/itertools.rst:124 ../../library/itertools.rst:175
msgid ""
"Combinations are emitted in lexicographic sort order.  So, if the input "
"*iterable* is sorted, the combination tuples will be produced in sorted "
"order."
msgstr "組合せ(combination)は辞書式順序で出力されます。したがって、入力 *iterable* がソートされていれば、組合せのタプルは整列された形で生成されます。"

#: ../../library/itertools.rst:128
msgid ""
"Elements are treated as unique based on their position, not on their value."
"  So if the input elements are unique, there will be no repeat values in "
"each combination."
msgstr "各要素は場所に基づいて一意に取り扱われ、値には依りません。入力された要素がバラバラならば、各組合せの中に重複した値は現れません。"

#: ../../library/itertools.rst:132 ../../library/itertools.rst:183
#: ../../library/itertools.rst:502
msgid "Roughly equivalent to::"
msgstr "およそ次と等価です::"

#: ../../library/itertools.rst:154
msgid ""
"The code for :func:`combinations` can be also expressed as a subsequence of "
":func:`permutations` after filtering entries where the elements are not in "
"sorted order (according to their position in the input pool)::"
msgstr ":func:`combinations` のコードは :func:`permutations` のシーケンスから (入力プールでの位置に応じた順序で) 要素がソートされていないものをフィルターしたようにも表現できます::"

#: ../../library/itertools.rst:165
msgid ""
"The number of items returned is ``n! / r! / (n-r)!`` when ``0 <= r <= n`` or"
" zero when ``r > n``."
msgstr "返される要素の数は、``0 <= r <= n`` の場合は、``n! / r! / (n-r)!`` で、``r > n`` の場合は 0 です。"

#: ../../library/itertools.rst:172
msgid ""
"Return *r* length subsequences of elements from the input *iterable* "
"allowing individual elements to be repeated more than once."
msgstr "入力 *iterable* から、それぞれの要素が複数回現れることを許して、長さ *r* の要素の部分列を返します。"

#: ../../library/itertools.rst:179
msgid ""
"Elements are treated as unique based on their position, not on their value."
"  So if the input elements are unique, the generated combinations will also "
"be unique."
msgstr "要素は、値ではなく位置に基づいて一意に扱われます。ですから、入力の要素が一意であれば、生成された組合せも一意になります。"

#: ../../library/itertools.rst:202
msgid ""
"The code for :func:`combinations_with_replacement` can be also expressed as "
"a subsequence of :func:`product` after filtering entries where the elements "
"are not in sorted order (according to their position in the input pool)::"
msgstr ":func:`combinations_with_replacement` のコードは、 :func:`product` の部分列から、要素が (入力プールの位置に従って) ソートされた順になっていない項目をフィルタリングしたものとしても表せます::"

#: ../../library/itertools.rst:213
msgid ""
"The number of items returned is ``(n+r-1)! / r! / (n-1)!`` when ``n > 0``."
msgstr "返される要素の数は、``n > 0`` のとき ``(n+r-1)! / r! / (n-1)!`` です。"

#: ../../library/itertools.rst:219
msgid ""
"Make an iterator that filters elements from *data* returning only those that"
" have a corresponding element in *selectors* that evaluates to ``True``. "
"Stops when either the *data* or *selectors* iterables has been exhausted. "
"Roughly equivalent to::"
msgstr "*data* の要素から *selectors* の対応する要素が ``True`` と評価されるものだけをフィルタしたイテレータを作ります。*data* と *selectors* のいずれかが尽きたときに止まります。およそ次と等価です::"

#: ../../library/itertools.rst:233
msgid ""
"Make an iterator that returns evenly spaced values starting with *n*. Often "
"used as an argument to :func:`imap` to generate consecutive data points. "
"Also, used with :func:`izip` to add sequence numbers.  Equivalent to::"
msgstr "数値 *n* で始まる、等間隔の値を返すイテレータを作成します。 :func:`imap` で連続したデータの生成によく使われます。 また、 :func:`izip` にシーケンス番号を追加するのにも使われます。 この関数は以下のスクリプトと同等です::"

#: ../../library/itertools.rst:245
msgid ""
"When counting with floating point numbers, better accuracy can sometimes be "
"achieved by substituting multiplicative code such as: ``(start + step * i "
"for i in count())``."
msgstr "浮動小数点数で数えるときは、``(start + step * i for i in count())`` のように、掛け算を使ったコードに置き換えたほうが正確にできることがあります。"

#: ../../library/itertools.rst:249
msgid "added *step* argument and allowed non-integer arguments."
msgstr "*step* 引数が追加され、非整数の引数が可能になりました。"

#: ../../library/itertools.rst:254
msgid ""
"Make an iterator returning elements from the iterable and saving a copy of "
"each. When the iterable is exhausted, return elements from the saved copy.  "
"Repeats indefinitely.  Roughly equivalent to::"
msgstr "イテラブルから要素を取得し、そのコピーを保存するイテレータを作成します。イテラブルの全要素を返すと、セーブされたコピーから要素を返します。これを無限に繰り返します。およそ次と等価です::"

#: ../../library/itertools.rst:268
msgid ""
"Note, this member of the toolkit may require significant auxiliary storage "
"(depending on the length of the iterable)."
msgstr ":func:`cycle` は大きなメモリ領域を使用します。使用するメモリ量は iterable の大きさに依存します。"

#: ../../library/itertools.rst:274
msgid ""
"Make an iterator that drops elements from the iterable as long as the "
"predicate is true; afterwards, returns every element.  Note, the iterator "
"does not produce *any* output until the predicate first becomes false, so it"
" may have a lengthy start-up time.  Roughly equivalent to::"
msgstr "predicate (述語) が真である間は要素を飛ばし、その後は全ての要素を返すイテレータを作成します。このイテレータは、predicate が最初に偽になるまで *全く* 要素を返さないため、要素を返し始めるまでに長い時間がかかる場合があります。およそ次と等価です::"

#: ../../library/itertools.rst:292
msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each element."
"  If not specified or is ``None``, *key* defaults to an identity function "
"and returns the element unchanged.  Generally, the iterable needs to already"
" be sorted on the same key function."
msgstr "同じキーをもつような要素からなる *iterable* 中のグループに対して、キーとグループを返すようなイテレータを作成します。*key* は各要素に対するキー値を計算する関数です。キーを指定しない場合や ``None`` にした場合、*key* 関数のデフォルトは恒等関数になり要素をそのまま返します。通常、*iterable* は同じキー関数で並べ替え済みである必要があります。"

#: ../../library/itertools.rst:298
msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in Unix."
"  It generates a break or new group every time the value of the key function"
" changes (which is why it is usually necessary to have sorted the data using"
" the same key function).  That behavior differs from SQL's GROUP BY which "
"aggregates common elements regardless of their input order."
msgstr ":func:`groupby` の操作は Unix の ``uniq`` フィルターと似ています。 key 関数の値が変わるたびに休止または新しいグループを生成します (このために通常同じ key 関数でソートしておく必要があるのです)。この動作は SQL の入力順に関係なく共通の要素を集約する GROUP BY とは違ます。"

#: ../../library/itertools.rst:304
msgid ""
"The returned group is itself an iterator that shares the underlying iterable"
" with :func:`groupby`.  Because the source is shared, when the "
":func:`groupby` object is advanced, the previous group is no longer visible."
"  So, if that data is needed later, it should be stored as a list::"
msgstr "返されるグループはそれ自体がイテレータで、 :func:`groupby` と *iterable* を共有しています。もととなる *iterable* を共有しているため、 :func:`groupby` オブジェクトの要素取り出しを先に進めると、それ以前の要素であるグループは見えなくなってしまいます。従って、データが後で必要な場合にはリストの形で保存しておく必要があります::"

#: ../../library/itertools.rst:316
msgid ":func:`groupby` is roughly equivalent to::"
msgstr ":func:`groupby` はおよそ次と等価です::"

#: ../../library/itertools.rst:346
msgid ""
"Make an iterator that filters elements from iterable returning only those "
"for which the predicate is ``True``. If *predicate* is ``None``, return the "
"items that are true. Roughly equivalent to::"
msgstr "iteable から predicate が ``True`` となる要素だけを返すイテレータを作成します。*predicate* が ``None`` の場合、真の要素だけを返します。およそ次と等価です::"

#: ../../library/itertools.rst:361
msgid ""
"Make an iterator that filters elements from iterable returning only those "
"for which the predicate is ``False``. If *predicate* is ``None``, return the"
" items that are false. Roughly equivalent to::"
msgstr "iteable から predicate が ``False`` となる要素だけを返すイテレータを作成します。*predicate* が ``None`` の場合、偽の要素だけを返します。およそ次と等価です::"

#: ../../library/itertools.rst:376
msgid ""
"Make an iterator that computes the function using arguments from each of the"
" iterables.  If *function* is set to ``None``, then :func:`imap` returns the"
" arguments as a tuple.  Like :func:`map` but stops when the shortest "
"iterable is exhausted instead of filling in ``None`` for shorter iterables."
"  The reason for the difference is that infinite iterator arguments are "
"typically an error for :func:`map` (because the output is fully evaluated) "
"but represent a common and useful way of supplying arguments to "
":func:`imap`. Roughly equivalent to::"
msgstr "iterables の各要素を引数として funtion を呼び出すイテレータを作成します。\n*function* が ``None`` の場合、 :func:`imap` は引数のタプルを返します。\n:func:`map` に似ていますが、最短の iterable の末尾まで到達した後はそこで終了します。短い iterable のところを ``None`` で補ったりはしません。\nこの違いは、 :func:`map` に無限長のイテレータを指定するのはたいていは誤り (全出力が評価されてしまうため) なのですが、 :func:`imap` の場合には一般的で役に立つ方法であるためです。\nこの関数はおよそ以下のスクリプトと同等です::"

#: ../../library/itertools.rst:398
msgid ""
"Make an iterator that returns selected elements from the iterable. If "
"*start* is non-zero, then elements from the iterable are skipped until start"
" is reached. Afterward, elements are returned consecutively unless *step* is"
" set higher than one which results in items being skipped.  If *stop* is "
"``None``, then iteration continues until the iterator is exhausted, if at "
"all; otherwise, it stops at the specified position.  Unlike regular slicing,"
" :func:`islice` does not support negative values for *start*, *stop*, or "
"*step*.  Can be used to extract related fields from data where the internal "
"structure has been flattened (for example, a multi-line report may list a "
"name field on every third line).  Roughly equivalent to::"
msgstr "iterable から要素を選択して返すイテレータを作成します。 *start* が0でない場合、iterable の要素は start に達するまでスキップされます。その後、\n要素が順に返されます。\n *step* が1以下なら連続した要素を返し、 1以上なら指定された値分の要素をスキップします。\n\n*stop* が ``None`` の場合、iterable が尽きるまでイテレーションは続きます。\nそれ以外の場合、指定された位置でイテレーションは停止します。\n通常のスライスとは異なり、:func:`islice` は負の *start*、*stop*、*step* をサポートしません。内部構造が平滑化されたデータから関連するフィールドを抽出するのにに使用できます (たとえば、三行ごとに名前フィールドを列挙している複数行のレポート)。およそ次と等価です::"

#: ../../library/itertools.rst:421
msgid ""
"If *start* is ``None``, then iteration starts at zero. If *step* is "
"``None``, then the step defaults to one."
msgstr "*start* が ``None`` ならば、繰返しは0から始まります。*step* が ``None`` ならば、ステップは1となります。"

#: ../../library/itertools.rst:424
msgid "accept ``None`` values for default *start* and *step*."
msgstr "*start* と *step* のデフォルト値として ``None`` を受け付けるようにしました。"

#: ../../library/itertools.rst:430
msgid ""
"Make an iterator that aggregates elements from each of the iterables. Like "
":func:`zip` except that it returns an iterator instead of a list.  Used for "
"lock-step iteration over several iterables at a time.  Roughly equivalent "
"to::"
msgstr "各 iterable の要素をまとめるイテレータを作成します。 :func:`zip` に似ていますが、リストではなくイテレータを返します。複数のイテレート可能オブジェクトに対して、一度に lock-step (横並び) イテレーションを行う場合に使用します。この関数はおよそ以下のスクリプトと同等です::"

#: ../../library/itertools.rst:440
msgid ""
"When no iterables are specified, returns a zero length iterator instead of "
"raising a :exc:`TypeError` exception."
msgstr "イテレート可能オブジェクトを指定しない場合、 :exc:`TypeError` 例外を送出する代わりに長さゼロのイテレータを返します。"

#: ../../library/itertools.rst:444
msgid ""
"The left-to-right evaluation order of the iterables is guaranteed. This "
"makes possible an idiom for clustering a data series into n-length groups "
"using ``izip(*[iter(s)]*n)``."
msgstr "イテラブルの左から右への評価順序が保証されます。そのため ``izip(*[iter(s)]*n)`` を使ってデータ系列を n 長のグループにクラスタリングできます。"

#: ../../library/itertools.rst:448
msgid ""
":func:`izip` should only be used with unequal length inputs when you don't "
"care about trailing, unmatched values from the longer iterables.  If those "
"values are important, use :func:`izip_longest` instead."
msgstr ":func:`izip` は、等しくない長さの入力に対しては、長い方のイテラブルの、終端の対にならない値を気にしないのでなければ、使うべきではありません。そのような値が重要なら、かわりに :func:`izip_longest` を使ってください。"

#: ../../library/itertools.rst:455
msgid ""
"Make an iterator that aggregates elements from each of the iterables. If the"
" iterables are of uneven length, missing values are filled-in with "
"*fillvalue*. Iteration continues until the longest iterable is exhausted.  "
"Roughly equivalent to::"
msgstr "各 iterable の要素をまとめるイテレータを作成します。iterable の長さが違う場合、足りない値は *fillvalue* で埋められます。最も長い itarable が尽きるまでイテレーションします。およそ次と等価です::"

#: ../../library/itertools.rst:479
msgid ""
"If one of the iterables is potentially infinite, then the "
":func:`izip_longest` function should be wrapped with something that limits "
"the number of calls (for example :func:`islice` or :func:`takewhile`).  If "
"not specified, *fillvalue* defaults to ``None``."
msgstr "iterables の1つが無限になりうる場合 :func:`izip_longest` は呼び出し回数を制限するような何かでラップしなければいけません(例えば :func:`islice` or :func:`takewhile`)。 *fillvalue* は指定しない場合のデフォルトは  ``None`` です。"

#: ../../library/itertools.rst:488
msgid ""
"Return successive *r* length permutations of elements in the *iterable*."
msgstr "*iterable* の要素からなる長さ *r* の置換(permutation)を次々と返します。"

#: ../../library/itertools.rst:490
msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length of "
"the *iterable* and all possible full-length permutations are generated."
msgstr "*r* が指定されないかまたは ``None`` であるならば、*r* のデフォルトは *iterable* の長さとなり全ての可能な最長の置換が生成されます。"

#: ../../library/itertools.rst:494
msgid ""
"Permutations are emitted in lexicographic sort order.  So, if the input "
"*iterable* is sorted, the permutation tuples will be produced in sorted "
"order."
msgstr "置換は辞書式にソートされた順序で吐き出されます。したがって入力の *iterable* がソートされていたならば、置換のタプルはソートされた状態で出力されます。"

#: ../../library/itertools.rst:498
msgid ""
"Elements are treated as unique based on their position, not on their value."
"  So if the input elements are unique, there will be no repeat values in "
"each permutation."
msgstr "要素は位置に基づいて一意的に扱われ、値に基づいてではありません。したがって入力された要素が全て異なっているならば、それぞれの置換に重複した要素が現れないことになります。"

#: ../../library/itertools.rst:529
msgid ""
"The code for :func:`permutations` can be also expressed as a subsequence of "
":func:`product`, filtered to exclude entries with repeated elements (those "
"from the same position in the input pool)::"
msgstr ":func:`permutations` のコードは :func:`product` の列から重複のあるもの (それらは入力プールの同じ位置から取られたものです) を除外するようにフィルタを掛けたものとしても表現できます::"

#: ../../library/itertools.rst:541
msgid ""
"The number of items returned is ``n! / (n-r)!`` when ``0 <= r <= n`` or zero"
" when ``r > n``."
msgstr "返される要素の数は、``0 <= r <= n`` の場合 ``n! / (n-r)!`` で、``r > n`` の場合は 0 です。"

#: ../../library/itertools.rst:548
msgid "Cartesian product of input iterables."
msgstr "入力イテラブルの直積(Cartesian product)です。"

#: ../../library/itertools.rst:550
msgid ""
"Roughly equivalent to nested for-loops in a generator expression. For "
"example, ``product(A, B)`` returns the same as ``((x,y) for x in A for y in "
"B)``."
msgstr "ジェネレータ式の入れ子になった for ループとおよそ等価です。たとえば ``product(A, B)`` は ``((x,y) for x in A for y in B)`` と同じものを返します。"

#: ../../library/itertools.rst:553
msgid ""
"The nested loops cycle like an odometer with the rightmost element advancing"
" on every iteration.  This pattern creates a lexicographic ordering so that "
"if the input's iterables are sorted, the product tuples are emitted in "
"sorted order."
msgstr "入れ子ループは走行距離計と同じように右端の要素がイテレーションごとに更新されていきます。このパターンは辞書式順序を作り出し、入力のイテレート可能オブジェクトたちがソートされていれば、直積タプルもソートされた順に吐き出されます。"

#: ../../library/itertools.rst:558
msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr "イテラブル自身との直積を計算するためには、オプションの *repeat* キーワード引数に繰り返し回数を指定します。たとえば ``product(A, repeat=4)`` は  ``product(A, A, A, A)`` と同じ意味です。"

#: ../../library/itertools.rst:562
msgid ""
"This function is roughly equivalent to the following code, except that the "
"actual implementation does not build up intermediate results in memory::"
msgstr "この関数は以下のコードとおよそ等価ですが、実際の実装ではメモリ中に中間結果を作りません::"

#: ../../library/itertools.rst:579
msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified. Used as argument to "
":func:`imap` for invariant function parameters.  Also used with :func:`izip`"
" to create constant fields in a tuple record.  Roughly equivalent to::"
msgstr "繰り返し *object* を返すイテレータを作成します。 *times* を指定しない場合、無限に値を返し続けます。 :func:`imap` で常に同じオブジェクトを関数の引数として指定する場合に使用します。また、 :func:`izip` で作成するタプルの定数部分を指定する場合にも使用することもできます。この関数はおよそ以下のスクリプトと同等です::"

#: ../../library/itertools.rst:593
msgid ""
"A common use for *repeat* is to supply a stream of constant values to *imap*"
" or *zip*::"
msgstr "*repeat* は *imap* や *zip* に定数のストリームを与えるためによく利用されます::"

#: ../../library/itertools.rst:601
msgid ""
"Make an iterator that computes the function using arguments obtained from "
"the iterable.  Used instead of :func:`imap` when argument parameters are "
"already grouped in tuples from a single iterable (the data has been \"pre-"
"zipped\").  The difference between :func:`imap` and :func:`starmap` "
"parallels the distinction between ``function(a,b)`` and ``function(*c)``. "
"Roughly equivalent to::"
msgstr "iterable の要素を引数として function を計算するイテレータを作成します。\nfunction の引数が一つの iterable からタプルに既にグループ化されている (データが \"zip済み\") 場合、:func:`imap` の代わりに使用します。\n:func:`imap` と :func:`starmap` の違いは ``function(a,b)`` と ``function(*c)`` の差に似ています。およそ次と等価です::"

#: ../../library/itertools.rst:612
msgid ""
"Previously, :func:`starmap` required the function arguments to be tuples. "
"Now, any iterable is allowed."
msgstr "以前のバージョンでは、 :func:`starmap` は関数の引数がタプルであることが必要でした。今では任意のイテレート可能オブジェクトを使えます。"

#: ../../library/itertools.rst:618
msgid ""
"Make an iterator that returns elements from the iterable as long as the "
"predicate is true.  Roughly equivalent to::"
msgstr "predicate が真である限り iterable から要素を返すイテレータを作成します。およそ次と等価です::"

#: ../../library/itertools.rst:632
msgid ""
"Return *n* independent iterators from a single iterable.  Roughly equivalent"
" to::"
msgstr "一つの *iterable* から *n* 個の独立したイテレータを生成して返します。以下のコードとおよそ等価になります::"

#: ../../library/itertools.rst:646
msgid ""
"Once :func:`tee` has made a split, the original *iterable* should not be "
"used anywhere else; otherwise, the *iterable* could get advanced without the"
" tee objects being informed."
msgstr "一度 :func:`tee` でイテレータを分割すると、もとの *iterable* を他で使ってはいけません。さもなければ、 :func:`tee` オブジェクトの知らない間に *iterable* が先の要素に進んでしまうことになります。"

#: ../../library/itertools.rst:650
msgid ""
"This itertool may require significant auxiliary storage (depending on how "
"much temporary data needs to be stored). In general, if one iterator uses "
"most or all of the data before another iterator starts, it is faster to use "
":func:`list` instead of :func:`tee`."
msgstr ":func:`tee` はかなり大きなメモリ領域を使用するかもしれません (使用するメモリ量はiterableの大きさに依存します)。一般には、一つのイテレータが他のイテレータよりも先にほとんどまたは全ての要素を消費するような場合には、 :func:`tee` よりも :func:`list` を使った方が高速です。"

#: ../../library/itertools.rst:661
msgid "Recipes"
msgstr "レシピ"

#: ../../library/itertools.rst:663
msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr "この節では、既存の itertools を素材としてツールセットを拡張するためのレシピを示します。"

#: ../../library/itertools.rst:666
msgid ""
"The extended tools offer the same high performance as the underlying "
"toolset. The superior memory performance is kept by processing elements one "
"at a time rather than bringing the whole iterable into memory all at once. "
"Code volume is kept small by linking the tools together in a functional "
"style which helps eliminate temporary variables.  High speed is retained by "
"preferring \"vectorized\" building blocks over the use of for-loops and "
":term:`generator`\\s which incur interpreter overhead."
msgstr "iterable 全体を一度にメモリ上に置くよりも、要素を一つづつ処理する方がメモリ効率上の有利さを保てます。関数形式のままツールをリンクしてゆくと、コードのサイズを減らし、一時変数を減らす助けになります。インタプリタのオーバヘッドをもたらす for ループやジェネレータ(:term:`generator`) を使わずに、 \"ベクトル化された\" ビルディングブロックを使うと、高速な処理を実現できます。"

#: ../../library/itertools.rst:848
msgid ""
"Note, many of the above recipes can be optimized by replacing global lookups"
" with local variables defined as default values.  For example, the "
"*dotproduct* recipe can be written as::"
msgstr "上記のレシピはデフォルト値を指定してグローバルな名前検索をローカル変数の検索に変えることで、より効率を上げることができます。例えば、*dotproduct* のレシピを書き換えるとすればこんな具合です::"
