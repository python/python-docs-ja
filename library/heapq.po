# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2017-09-22 17:57+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/heapq.rst:2
msgid ":mod:`heapq` --- Heap queue algorithm"
msgstr ":mod:`heapq` --- ãƒ’ãƒ¼ãƒ—ã‚­ãƒ¥ãƒ¼ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ "

#: ../../library/heapq.rst:13
msgid "**Source code:** :source:`Lib/heapq.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/heapq.py`"

#: ../../library/heapq.rst:17
msgid ""
"This module provides an implementation of the heap queue algorithm, also "
"known as the priority queue algorithm."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ãƒ’ãƒ¼ãƒ—ã‚­ãƒ¥ãƒ¼ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ä¸€å®Ÿè£…ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚å„ªå…ˆåº¦ã‚­ãƒ¥ãƒ¼ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨ã—ã¦ã‚‚çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/heapq.rst:20
msgid ""
"Heaps are binary trees for which every parent node has a value less than or "
"equal to any of its children.  This implementation uses arrays for which "
"``heap[k] <= heap[2*k+1]`` and ``heap[k] <= heap[2*k+2]`` for all *k*, "
"counting elements from zero.  For the sake of comparison, non-existing "
"elements are considered to be infinite.  The interesting property of a heap "
"is that its smallest element is always the root, ``heap[0]``."
msgstr "ãƒ’ãƒ¼ãƒ—ã¨ã¯ã€å…¨ã¦ã®è¦ªãƒãƒ¼ãƒ‰ã®å€¤ãŒã€ãã®å…¨ã¦ã®å­ã®å€¤ä»¥ä¸‹ã§ã‚ã‚‹ã‚ˆã†ãªãƒã‚¤ãƒŠãƒªãƒ„ãƒªãƒ¼ã§ã™ã€‚ã“ã®å®Ÿè£…ã¯ã€å…¨ã¦ã® *k* ã«å¯¾ã—ã¦ã€ã‚¼ãƒ­ã‹ã‚‰è¦ç´ ã‚’æ•°ãˆã¦ã„ã£ãŸéš›ã«ã€``heap[k] <= heap[2*k+1]`` ã‹ã¤ ``heap[k] <= heap[2*k+2]`` ã¨ãªã‚‹é…åˆ—ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚æ¯”è¼ƒã®ãŸã‚ã«ã€å­˜åœ¨ã—ãªã„è¦ç´ ã¯ç„¡é™å¤§ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚ãƒ’ãƒ¼ãƒ—ã®èˆˆå‘³æ·±ã„æ€§è³ªã¯ã€æœ€å°ã®è¦ç´ ãŒå¸¸ã«ãƒ«ãƒ¼ãƒˆã€ã¤ã¾ã‚Š ``heap[0]`` ã«ãªã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../library/heapq.rst:27
msgid ""
"The API below differs from textbook heap algorithms in two aspects: (a) We "
"use zero-based indexing.  This makes the relationship between the index for "
"a node and the indexes for its children slightly less obvious, but is more "
"suitable since Python uses zero-based indexing. (b) Our pop method returns "
"the smallest item, not the largest (called a \"min heap\" in textbooks; a "
"\"max heap\" is more common in texts because of its suitability for in-place"
" sorting)."
msgstr "ä»¥ä¸‹ã® API ã¯æ•™ç§‘æ›¸ã«ãŠã‘ã‚‹ãƒ’ãƒ¼ãƒ—ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨ã¯ 2 ã¤ã®å´é¢ã§ç•°ãªã£ã¦ã„ã¾ã™: (a) ã‚¼ãƒ­ãƒ™ãƒ¼ã‚¹ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹åŒ–ã‚’è¡Œã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒãƒ¼ãƒ‰ã«å¯¾ã™ã‚‹ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã¨ãã®å­ãƒãƒ¼ãƒ‰ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã®é–¢ä¿‚ãŒã‚„ã‚„æ˜ç­ã§ãªããªã‚Šã¾ã™ãŒã€Python ã¯ã‚¼ãƒ­ãƒ™ãƒ¼ã‚¹ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹åŒ–ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã§ã‚ˆã‚Šã—ã£ãã‚Šãã¾ã™ã€‚(b) ã‚ã‚Œã‚ã‚Œã® pop ãƒ¡ã‚½ãƒƒãƒ‰ã¯æœ€å¤§ã®è¦ç´ ã§ã¯ãªãæœ€å°ã®è¦ç´  (æ•™ç§‘æ›¸ã§ã¯ \"min heap:æœ€å°ãƒ’ãƒ¼ãƒ—\" ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™; æ•™ç§‘æ›¸ã§ã¯ä¸¦ã¹æ›¿ãˆã‚’ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã§è¡Œã†ã®ã«é©ã—ãŸ \"max heap:æœ€å¤§ãƒ’ãƒ¼ãƒ—\" ãŒä¸€èˆ¬çš„ã§ã™)ã€‚"

#: ../../library/heapq.rst:34
msgid ""
"These two make it possible to view the heap as a regular Python list without"
" surprises: ``heap[0]`` is the smallest item, and ``heap.sort()`` maintains "
"the heap invariant!"
msgstr "ã“ã‚Œã‚‰ã® 2 ç‚¹ã«ã‚ˆã£ã¦ã€ãƒ¦ãƒ¼ã‚¶ã«æˆ¸æƒ‘ã„ã‚’ä¸ãˆã‚‹ã“ã¨ãªãã€ãƒ’ãƒ¼ãƒ—ã‚’é€šå¸¸ã® Python ãƒªã‚¹ãƒˆã¨ã—ã¦è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™: ``heap[0]`` ãŒæœ€å°ã®è¦ç´ ã¨ãªã‚Šã€``heap.sort()`` ã¯ãƒ’ãƒ¼ãƒ—ä¸å¤‰å¼ã‚’ä¿ã¡ã¾ã™!"

#: ../../library/heapq.rst:38
msgid ""
"To create a heap, use a list initialized to ``[]``, or you can transform a "
"populated list into a heap via function :func:`heapify`."
msgstr "ãƒ’ãƒ¼ãƒ—ã‚’ä½œæˆã™ã‚‹ã«ã¯ã€ ``[]`` ã«åˆæœŸåŒ–ã•ã‚ŒãŸãƒªã‚¹ãƒˆã‚’ä½¿ã†ã‹ã€ :func:`heapify` ã‚’ç”¨ã„ã¦è¦ç´ ã®å…¥ã£ãŸãƒªã‚¹ãƒˆã‚’å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../library/heapq.rst:41
msgid "The following functions are provided:"
msgstr "æ¬¡ã®é–¢æ•°ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™:"

#: ../../library/heapq.rst:46
msgid "Push the value *item* onto the *heap*, maintaining the heap invariant."
msgstr "*item* ã‚’ *heap* ã« push ã—ã¾ã™ã€‚ãƒ’ãƒ¼ãƒ—ä¸å¤‰å¼ã‚’ä¿ã¡ã¾ã™ã€‚"

#: ../../library/heapq.rst:51
msgid ""
"Pop and return the smallest item from the *heap*, maintaining the heap "
"invariant.  If the heap is empty, :exc:`IndexError` is raised.  To access "
"the smallest item without popping it, use ``heap[0]``."
msgstr "pop ã‚’è¡Œã„ã€ *heap* ã‹ã‚‰æœ€å°ã®è¦ç´ ã‚’è¿”ã—ã¾ã™ã€‚ãƒ’ãƒ¼ãƒ—ä¸å¤‰å¼ã¯ä¿ãŸã‚Œã¾ã™ã€‚ãƒ’ãƒ¼ãƒ—ãŒç©ºã®å ´åˆã€ :exc:`IndexError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚pop ã›ãšã«æœ€å°ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ã€ ``heap[0]`` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/heapq.rst:57
msgid ""
"Push *item* on the heap, then pop and return the smallest item from the "
"*heap*.  The combined action runs more efficiently than :func:`heappush` "
"followed by a separate call to :func:`heappop`."
msgstr "*item* ã‚’ *heap* ã« push ã—ãŸå¾Œã€pop ã‚’è¡Œã£ã¦ *heap* ã‹ã‚‰æœ€åˆã®è¦ç´ ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ä¸€ç¶šãã®å‹•ä½œã‚’ :func:`heappush` ã«å¼•ãç¶šã„ã¦ :func:`heappop` ã‚’åˆ¥ã€…ã«å‘¼ã³å‡ºã™ã‚ˆã‚Šã‚‚åŠ¹ç‡çš„ã«å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../library/heapq.rst:65
msgid "Transform list *x* into a heap, in-place, in linear time."
msgstr "ãƒªã‚¹ãƒˆ *x* ã‚’ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹å‡¦ç†ã—ã€ç·šå½¢æ™‚é–“ã§ãƒ’ãƒ¼ãƒ—ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../library/heapq.rst:70
msgid ""
"Pop and return the smallest item from the *heap*, and also push the new "
"*item*. The heap size doesn't change. If the heap is empty, "
":exc:`IndexError` is raised."
msgstr "*heap* ã‹ã‚‰æœ€å°ã®è¦ç´ ã‚’ pop ã—ã¦è¿”ã—ã€æ–°ãŸã« *item* ã‚’ push ã—ã¾ã™ã€‚ãƒ’ãƒ¼ãƒ—ã®ã‚µã‚¤ã‚ºã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚ãƒ’ãƒ¼ãƒ—ãŒç©ºã®å ´åˆã€ :exc:`IndexError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/heapq.rst:73
msgid ""
"This one step operation is more efficient than a :func:`heappop` followed by"
" :func:`heappush` and can be more appropriate when using a fixed-size heap. "
"The pop/push combination always returns an element from the heap and "
"replaces it with *item*."
msgstr "ã“ã®ä¸€æ¯ã®æ¼”ç®—ã¯ :func:`heappop` ã«æ¬¡ã„ã§ :func:`heappush` ã‚’é€å‡ºã™ã‚‹ã‚ˆã‚Šã‚‚åŠ¹ç‡çš„ã§ã€å›ºå®šã‚µã‚¤ã‚ºã®ãƒ’ãƒ¼ãƒ—ã‚’ç”¨ã„ã¦ã„ã‚‹å ´åˆã«ã¯ã‚ˆã‚Šé©ã—ã¦ã„ã¾ã™ã€‚ pop/push ã®çµ„ã¿åˆã‚ã›ã¯å¿…ãšãƒ’ãƒ¼ãƒ—ã‹ã‚‰è¦ç´ ã‚’ä¸€ã¤è¿”ã—ã€ãã‚Œã‚’ *item* ã¨ç½®ãæ›ãˆã¾ã™ã€‚"

#: ../../library/heapq.rst:78
msgid ""
"The value returned may be larger than the *item* added.  If that isn't "
"desired, consider using :func:`heappushpop` instead.  Its push/pop "
"combination returns the smaller of the two values, leaving the larger value "
"on the heap."
msgstr "è¿”ã•ã‚Œã‚‹å€¤ã¯åŠ ãˆã‚‰ã‚ŒãŸ *item* ã‚ˆã‚Šã‚‚å¤§ãããªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãã‚Œã‚’æœ›ã¾ãªã„ãªã‚‰ã€ä»£ã‚ã‚Šã« :func:`heappushpop` ã‚’ä½¿ã†ã“ã¨ã‚’è€ƒãˆã¦ãã ã•ã„ã€‚ã“ã® push/pop ã®çµ„ã¿åˆã‚ã›ã¯äºŒã¤ã®å€¤ã®å°ã•ã„æ–¹ã‚’è¿”ã—ã€å¤§ãã„æ–¹ã®å€¤ã‚’ãƒ’ãƒ¼ãƒ—ã«æ®‹ã—ã¾ã™ã€‚"

#: ../../library/heapq.rst:84
msgid "The module also offers three general purpose functions based on heaps."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã•ã‚‰ã«3ã¤ã®ãƒ’ãƒ¼ãƒ—ã«åŸºãæ±ç”¨é–¢æ•°ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/heapq.rst:89
msgid ""
"Merge multiple sorted inputs into a single sorted output (for example, merge"
" timestamped entries from multiple log files).  Returns an :term:`iterator` "
"over the sorted values."
msgstr "è¤‡æ•°ã®ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸå…¥åŠ›ã‚’ãƒãƒ¼ã‚¸(merge)ã—ã¦ä¸€ã¤ã®ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸå‡ºåŠ›ã«ã—ã¾ã™ (ãŸã¨ãˆã°ã€è¤‡æ•°ã®ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®æ™‚åˆ»ã®å…¥ã£ãŸã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’ãƒãƒ¼ã‚¸ã—ã¾ã™)ã€‚ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸå€¤ã«ã‚ãŸã‚‹ :term:`iterator` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/heapq.rst:93
msgid ""
"Similar to ``sorted(itertools.chain(*iterables))`` but returns an iterable, "
"does not pull the data into memory all at once, and assumes that each of the"
" input streams is already sorted (smallest to largest)."
msgstr "``sorted(itertools.chain(*iterables))`` ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã€ä¸€åº¦ã«ã¯ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ¡ãƒ¢ãƒªã«èª­ã¿è¾¼ã¿ã¾ãšã€ãã‚Œãã‚Œã®å…¥åŠ›ãŒ(æœ€å°ã‹ã‚‰æœ€å¤§ã¸)ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ä»®å®šã—ã¾ã™ã€‚"

#: ../../library/heapq.rst:102
msgid ""
"Return a list with the *n* largest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in the iterable: "
"``key=str.lower`` Equivalent to:  ``sorted(iterable, key=key, "
"reverse=True)[:n]``"
msgstr "*iterable* ã§å®šç¾©ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®ã†ã¡ã€æœ€å¤§å€¤ã‹ã‚‰é™é †ã« *n* å€‹ã®å€¤ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚(ã‚ãŸãˆã‚‰ã‚ŒãŸå ´åˆ) *key* ã¯ã€å¼•æ•°ã‚’ä¸€ã¤ã¨ã‚‹ã€*iterable* ã®ãã‚Œãã‚Œã®è¦ç´ ã‹ã‚‰æ¯”è¼ƒã‚­ãƒ¼ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°ã‚’æŒ‡å®šã—ã¾ã™: ``key=str.lower`` ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¨åŒç­‰ã§ã™: ``sorted(iterable, key=key, reverse=True)[:n]``"

#: ../../library/heapq.rst:110 ../../library/heapq.rst:123
msgid "Added the optional *key* argument."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *key* å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸ."

#: ../../library/heapq.rst:116
msgid ""
"Return a list with the *n* smallest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in the iterable: "
"``key=str.lower`` Equivalent to:  ``sorted(iterable, key=key)[:n]``"
msgstr "*iterable* ã§å®šç¾©ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®ã†ã¡ã€æœ€å°å€¤ã‹ã‚‰æ˜‡é †ã« *n* å€‹ã®å€¤ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚(ã‚ãŸãˆã‚‰ã‚ŒãŸå ´åˆ) *key* ã¯ã€å¼•æ•°ã‚’ä¸€ã¤ã¨ã‚‹ã€*iterable* ã®ãã‚Œãã‚Œã®è¦ç´ ã‹ã‚‰æ¯”è¼ƒã‚­ãƒ¼ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°ã‚’æŒ‡å®šã—ã¾ã™: ``key=str.lower`` ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¨åŒç­‰ã§ã™: ``sorted(iterable, key=key)[:n]``"

#: ../../library/heapq.rst:126
msgid ""
"The latter two functions perform best for smaller values of *n*.  For larger"
" values, it is more efficient to use the :func:`sorted` function.  Also, "
"when ``n==1``, it is more efficient to use the built-in :func:`min` and "
":func:`max` functions.  If repeated usage of these functions is required, "
"consider turning the iterable into an actual heap."
msgstr "å¾Œã‚äºŒã¤ã®é–¢æ•°ã¯ *n* ã®å€¤ãŒå°ã•ãªå ´åˆã«æœ€é©ãªå‹•ä½œã‚’ã—ã¾ã™ã€‚å¤§ããªå€¤ã®æ™‚ã«ã¯ :func:`sorted` é–¢æ•°ã®æ–¹ãŒåŠ¹ç‡çš„ã§ã™ã€‚ã•ã‚‰ã«ã€ ``n==1`` ã®æ™‚ã«ã¯ :func:`min` ãŠã‚ˆã³ :func:`max` é–¢æ•°ã®æ–¹ãŒåŠ¹ç‡çš„ã§ã™ã€‚ã“ã®é–¢æ•°ã‚’ç¹°ã‚Šè¿”ã—ä½¿ã†ã“ã¨ãŒå¿…è¦ãªã‚‰ã€iterable ã‚’å®Ÿéš›ã®ãƒ’ãƒ¼ãƒ—ã«å¤‰ãˆã‚‹ã“ã¨ã‚’è€ƒãˆã¦ãã ã•ã„ã€‚"

#: ../../library/heapq.rst:134
msgid "Basic Examples"
msgstr "åŸºæœ¬çš„ãªä¾‹"

#: ../../library/heapq.rst:136
msgid ""
"A `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_ can be implemented by"
" pushing all values onto a heap and then popping off the smallest values one"
" at a time::"
msgstr "ã™ã¹ã¦ã®å€¤ã‚’ãƒ’ãƒ¼ãƒ—ã« push ã—ã¦ã‹ã‚‰æœ€å°å€¤ã‚’ 1 ã¤ãšã¤ pop ã™ã‚‹ã“ã¨ã§ã€`ãƒ’ãƒ¼ãƒ—ã‚½ãƒ¼ãƒˆ <https://ja.wikipedia.org/wiki/%E3%83%92%E3%83%BC%E3%83%97%E3%82%BD%E3%83%BC%E3%83%88>`_ ã‚’å®Ÿè£…ã§ãã¾ã™::"

#: ../../library/heapq.rst:149
msgid ""
"This is similar to ``sorted(iterable)``, but unlike :func:`sorted`, this "
"implementation is not stable."
msgstr "ã“ã‚Œã¯ ``sorted(iterable)`` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ :func:`sorted` ã¨ã¯ç•°ãªã‚Šã€ã“ã®å®Ÿè£…ã¯ã‚¹ãƒ†ãƒ¼ãƒ–ãƒ«ã‚½ãƒ¼ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/heapq.rst:152
msgid ""
"Heap elements can be tuples.  This is useful for assigning comparison values"
" (such as task priorities) alongside the main record being tracked::"
msgstr "ãƒ’ãƒ¼ãƒ—ã®è¦ç´ ã¯ã‚¿ãƒ—ãƒ«ã«å‡ºæ¥ã¾ã™ã€‚ã“ã‚Œã¯ã€è¿½è·¡ã•ã‚Œã‚‹ä¸»ãƒ¬ã‚³ãƒ¼ãƒ‰ã¨ã¯åˆ¥ã« (ã‚¿ã‚¹ã‚¯ã®å„ªå…ˆåº¦ã®ã‚ˆã†ãª) æ¯”è¼ƒå€¤ã‚’æŒ‡å®šã™ã‚‹ã¨ãã«ä¾¿åˆ©ã§ã™::"

#: ../../library/heapq.rst:165
msgid "Priority Queue Implementation Notes"
msgstr "å„ªå…ˆåº¦ã‚­ãƒ¥ãƒ¼å®Ÿè£…ã®æ³¨é‡ˆ"

#: ../../library/heapq.rst:167
msgid ""
"A `priority queue <https://en.wikipedia.org/wiki/Priority_queue>`_ is common"
" use for a heap, and it presents several implementation challenges:"
msgstr "`å„ªå…ˆåº¦ã¤ãã‚­ãƒ¥ãƒ¼ <https://ja.wikipedia.org/wiki/%E5%84%AA%E5%85%88%E5%BA%A6%E3%81%A4%E3%81%8D%E3%82%AD%E3%83%A5%E3%83%BC>`_ ã¯ã€ãƒ’ãƒ¼ãƒ—ã®ä¸€èˆ¬çš„ãªä½¿ã„æ–¹ã§ã€å®Ÿè£…ã«ã¯ã„ãã¤ã‹å›°é›£ãªç‚¹ãŒã‚ã‚Šã¾ã™:"

#: ../../library/heapq.rst:170
msgid ""
"Sort stability:  how do you get two tasks with equal priorities to be "
"returned in the order they were originally added?"
msgstr "ã‚½ãƒ¼ãƒˆå®‰å®šæ€§: å„ªå…ˆåº¦ãŒç­‰ã—ã„äºŒã¤ã®ã‚¿ã‚¹ã‚¯ãŒã€ã‚‚ã¨ã‚‚ã¨è¿½åŠ ã•ã‚ŒãŸé †åºã§è¿”ã•ã‚Œã‚‹ãŸã‚ã«ã¯ã©ã†ã—ãŸã‚‰ã„ã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ"

#: ../../library/heapq.rst:173
msgid ""
"In the future with Python 3, tuple comparison breaks for (priority, task) "
"pairs if the priorities are equal and the tasks do not have a default "
"comparison order."
msgstr "Python 3 ã§ã¯ã€ (priority, task) ãƒšã‚¢ã«å¯¾ã™ã‚‹ã‚¿ãƒ—ãƒ«ã®æ¯”è¼ƒã¯ã€priority ãŒåŒã˜ã§ task ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ¯”è¼ƒé †ã‚’æŒãŸãªã„ã¨ãã«ç ´ç¶»ã—ã¾ã™ã€‚"

#: ../../library/heapq.rst:177
msgid ""
"If the priority of a task changes, how do you move it to a new position in "
"the heap?"
msgstr "ã‚ã‚‹ã‚¿ã‚¹ã‚¯ã®å„ªå…ˆåº¦ãŒå¤‰åŒ–ã—ãŸã‚‰ã€ã©ã†ã‚„ã£ã¦ãã‚Œã‚’ãƒ’ãƒ¼ãƒ—ã®æ–°ã—ã„ä½ç½®ã«ç§»å‹•ã•ã›ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ"

#: ../../library/heapq.rst:180
msgid ""
"Or if a pending task needs to be deleted, how do you find it and remove it "
"from the queue?"
msgstr "æœªè§£æ±ºã®ã‚¿ã‚¹ã‚¯ãŒå‰Šé™¤ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ãã€ã©ã®ã‚ˆã†ã«ãã‚Œã‚’ã‚­ãƒ¥ãƒ¼ã‹ã‚‰æ¢ã—ã¦å‰Šé™¤ã™ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ"

#: ../../library/heapq.rst:183
msgid ""
"A solution to the first two challenges is to store entries as 3-element list"
" including the priority, an entry count, and the task.  The entry count "
"serves as a tie-breaker so that two tasks with the same priority are "
"returned in the order they were added. And since no two entry counts are the"
" same, the tuple comparison will never attempt to directly compare two "
"tasks."
msgstr "æœ€åˆã®äºŒã¤ã®å›°é›£ã®è§£æ±ºç­–ã¯ã€é …ç›®ã‚’å„ªå…ˆåº¦ã€é …ç›®ç•ªå·ã€ãã—ã¦ã‚¿ã‚¹ã‚¯ã‚’å«ã‚€ 3 è¦ç´ ã®ãƒªã‚¹ãƒˆã¨ã—ã¦ä¿å­˜ã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã®é …ç›®ç•ªå·ã¯ã€åŒã˜å„ªå…ˆåº¦ã®äºŒã¤ã®ã‚¿ã‚¹ã‚¯ãŒã€è¿½åŠ ã•ã‚ŒãŸé †åºã§è¿”ã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®åŒç‚¹æ±ºå‹æˆ¦ã¨ã—ã¦åƒãã¾ã™ã€‚ãã—ã¦äºŒã¤ã®é …ç›®ç•ªå·ãŒç­‰ã—ããªã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã®ã§ã€ã‚¿ãƒ—ãƒ«ã®æ¯”è¼ƒãŒäºŒã¤ã®ã‚¿ã‚¹ã‚¯ã‚’ç›´æ¥æ¯”ã¹ã‚ˆã†ã¨ã™ã‚‹ã“ã¨ã¯ã‚ã‚Šãˆã¾ã›ã‚“ã€‚"

#: ../../library/heapq.rst:189
msgid ""
"The remaining challenges revolve around finding a pending task and making "
"changes to its priority or removing it entirely.  Finding a task can be done"
" with a dictionary pointing to an entry in the queue."
msgstr "æ®‹ã‚Šã®å›°é›£ã¯ä¸»ã«ã€æœªè§£æ±ºã®ã‚¿ã‚¹ã‚¯ã‚’æ¢ã—ã¦ã€ãã®å„ªå…ˆåº¦ã‚’å¤‰æ›´ã—ãŸã‚Šã€å®Œå…¨ã«å‰Šé™¤ã™ã‚‹ã“ã¨ã§ã™ã€‚ã‚¿ã‚¹ã‚¯ã‚’æ¢ã™ã“ã¨ã¯ã€ã‚­ãƒ¥ãƒ¼å†…ã®é …ç›®ã‚’æŒ‡ã—ç¤ºã™è¾æ›¸ã«ã‚ˆã£ã¦ãªã•ã‚Œã¾ã™ã€‚"

#: ../../library/heapq.rst:193
msgid ""
"Removing the entry or changing its priority is more difficult because it "
"would break the heap structure invariants.  So, a possible solution is to "
"mark the existing entry as removed and add a new entry with the revised "
"priority::"
msgstr "é …ç›®ã‚’å‰Šé™¤ã—ãŸã‚Šã€å„ªå…ˆåº¦ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ã€ãƒ’ãƒ¼ãƒ—æ§‹é€ ã®ä¸å¤‰é–¢ä¿‚ã‚’å£Šã™ã“ã¨ã«ãªã‚‹ã®ã§ã€ã‚‚ã£ã¨é›£ã—ã„ã§ã™ã€‚ã§ã™ã‹ã‚‰ã€å¯èƒ½ãªè§£æ±ºç­–ã¯ã€ãã®é …ç›®ãŒç„¡åŠ¹ã§ã‚ã‚‹ã‚‚ã®ã¨ã—ã¦ãƒãƒ¼ã‚¯ã—ã€å¿…è¦ãªã‚‰å¤‰æ›´ã•ã‚ŒãŸå„ªå…ˆåº¦ã®é …ç›®ã‚’åŠ ãˆã‚‹ã“ã¨ã§ã™::"

#: ../../library/heapq.rst:227
msgid "Theory"
msgstr "ç†è«–"

#: ../../library/heapq.rst:229
msgid ""
"Heaps are arrays for which ``a[k] <= a[2*k+1]`` and ``a[k] <= a[2*k+2]`` for"
" all *k*, counting elements from 0.  For the sake of comparison, non-"
"existing elements are considered to be infinite.  The interesting property "
"of a heap is that ``a[0]`` is always its smallest element."
msgstr "ãƒ’ãƒ¼ãƒ—ã¨ã¯ã€å…¨ã¦ã® *k* ã«ã¤ã„ã¦ã€è¦ç´ ã‚’ 0 ã‹ã‚‰æ•°ãˆãŸã¨ãã«ã€``a[k] <= a[2*k+1]`` ã‹ã¤  ``a[k] <= a[2*k+2]`` ã¨ãªã‚‹é…åˆ—ã§ã™ã€‚æ¯”è¼ƒã®ãŸã‚ã«ã€å­˜åœ¨ã—ãªã„è¦ç´ ã‚’ç„¡é™å¤§ã¨è€ƒãˆã¾ã™ã€‚ãƒ’ãƒ¼ãƒ—ã®èˆˆå‘³æ·±ã„å±æ€§ã¯ ``a[0]`` ãŒå¸¸ã«æœ€å°ã®è¦ç´ ã«ãªã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../library/heapq.rst:234
msgid ""
"The strange invariant above is meant to be an efficient memory "
"representation for a tournament.  The numbers below are *k*, not ``a[k]``::"
msgstr "ä¸Šè¨˜ã®å¥‡å¦™ãªä¸å¤‰å¼ã¯ã€å‹ã¡æŠœãæˆ¦åˆ¤å®šã®éš›ã«åŠ¹ç‡çš„ãªãƒ¡ãƒ¢ãƒªè¡¨ç¾ã‚’è¡Œã†ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚ä»¥ä¸‹ã®ç•ªå·ã¯ ``a[k]`` ã§ã¯ãªã *k* ã¨ã—ã¾ã™::"

#: ../../library/heapq.rst:247
msgid ""
"In the tree above, each cell *k* is topping ``2*k+1`` and ``2*k+2``. In a "
"usual binary tournament we see in sports, each cell is the winner over the "
"two cells it tops, and we can trace the winner down the tree to see all "
"opponents s/he had.  However, in many computer applications of such "
"tournaments, we do not need to trace the history of a winner. To be more "
"memory efficient, when a winner is promoted, we try to replace it by "
"something else at a lower level, and the rule becomes that a cell and the "
"two cells it tops contain three different items, but the top cell \"wins\" "
"over the two topped cells."
msgstr "ä¸Šã®æœ¨æ§‹é€ ã§ã¯ã€å„ã‚»ãƒ« *k* ã¯ ``2*k+1`` ãŠã‚ˆã³ ``2*k+2`` ã‚’æœ€å¤§å€¤ã¨ã—ã¦ã„ã¾ã™ã€‚ã‚¹ãƒãƒ¼ãƒ„ã«è¦‹ã‚‰ã‚Œã‚‹ã‚ˆã†ãªé€šå¸¸ã® 2 ã¤çµ„å‹ã¡æŠœãæˆ¦ã§ã¯ã€å„ã‚»ãƒ«ã¯ãã®ä¸‹ã«ã‚ã‚‹äºŒã¤ã®ã‚»ãƒ«ã«å¯¾ã™ã‚‹å‹è€…ã¨ãªã£ã¦ã„ã¦ã€å€‹ã€…ã®ã‚»ãƒ«ã®å‹è€…ã‚’è¿½è·¡ã—ã¦ã„ãã“ã¨ã«ã‚ˆã‚Šã€ãã®ã‚»ãƒ«ã«å¯¾ã™ã‚‹å…¨ã¦ã®ç›¸æ‰‹ã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã—ã‹ã—ãªãŒã‚‰ã€ã“ã®ã‚ˆã†ãªå‹ã¡æŠœãæˆ¦ã‚’ä½¿ã†è¨ˆç®—æ©Ÿã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å¤šãã§ã¯ã€å‹æ­´ã‚’è¿½è·¡ã™ã‚‹å¿…è¦ã¯ã‚Šã¾ã›ã‚“ã€‚ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ã‚’ã‚ˆã‚Šé«˜ã‚ã‚‹ãŸã‚ã«ã€å‹è€…ãŒä¸Šä½ã«é€²ç´šã—ãŸéš›ã€ä¸‹ã®ãƒ¬ãƒ™ãƒ«ã‹ã‚‰æŒã£ã¦ãã¦ç½®ãæ›ãˆã‚‹ã“ã¨ã«ã™ã‚‹ã¨ã€ã‚ã‚‹ã‚»ãƒ«ã¨ãã®ä¸‹ä½ã«ã‚ã‚‹äºŒã¤ã®ã‚»ãƒ«ã¯ç•°ãªã‚‹ä¸‰ã¤ã®è¦ç´ ã‚’å«ã¿ã€ã‹ã¤ä¸Šä½ã®ã‚»ãƒ«ã¯äºŒã¤ã®ä¸‹ä½ã®ã‚»ãƒ«ã«å¯¾ã—ã¦ \"å‹è€…ã¨\" ãªã‚Šã¾ã™ã€‚"

#: ../../library/heapq.rst:256
msgid ""
"If this heap invariant is protected at all time, index 0 is clearly the "
"overall winner.  The simplest algorithmic way to remove it and find the "
"\"next\" winner is to move some loser (let's say cell 30 in the diagram "
"above) into the 0 position, and then percolate this new 0 down the tree, "
"exchanging values, until the invariant is re-established. This is clearly "
"logarithmic on the total number of items in the tree. By iterating over all "
"items, you get an O(n log n) sort."
msgstr "ã“ã®ãƒ’ãƒ¼ãƒ—ä¸å¤‰å¼ãŒå¸¸ã«å®ˆã‚‰ã‚Œã‚Œã°ã€ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ 0 ã¯æ˜ã‚‰ã‹ã«æœ€å‹è€…ã¨ãªã‚Šã¾ã™ã€‚æœ€å‹è€…ã®è¦ç´ ã‚’é™¤å»ã—ã€\"æ¬¡ã®\" å‹è€…ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã®æœ€ã‚‚å˜ç´”ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ çš„æ‰‹æ³•ã¯ã€ã‚ã‚‹æ•—è€…è¦ç´  (ã“ã“ã§ã¯ä¸Šå›³ã®ã‚»ãƒ« 30 ã¨ã—ã¾ã™) ã‚’ 0 ã®å ´æ‰€ã«æŒã£ã¦ã„ãã€ã“ã®æ–°ã—ã„ 0 ã‚’æ¿¾éã™ã‚‹ã‚ˆã†ã«ã—ã¦ãƒ„ãƒªãƒ¼ã‚’ä¸‹ã‚‰ã›ã¦å€¤ã‚’äº¤æ›ã—ã¦ã‚†ãã¾ã™ã€‚ä¸å¤‰é–¢ä¿‚ãŒå†æ§‹ç¯‰ã•ã‚Œã‚‹ã¾ã§ã“ã‚Œã‚’ç¶šã‘ã¾ã™ã€‚ã“ã®æ“ä½œã¯æ˜ã‚‰ã‹ã«ã€ãƒ„ãƒªãƒ¼å†…ã®å…¨ã¦ã®è¦ç´ æ•°ã«å¯¾ã—ã¦å¯¾æ•°çš„ãªè¨ˆç®—é‡ã¨ãªã‚Šã¾ã™ã€‚å…¨ã¦ã®è¦ç´ ã«ã¤ã„ã¦ç¹°ã‚Šè¿”ã™ã¨ã€O(n log n) ã®ã‚½ãƒ¼ãƒˆ(ä¸¦ã¹æ›¿ãˆ)ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/heapq.rst:263
msgid ""
"A nice feature of this sort is that you can efficiently insert new items "
"while the sort is going on, provided that the inserted items are not "
"\"better\" than the last 0'th element you extracted.  This is especially "
"useful in simulation contexts, where the tree holds all incoming events, and"
" the \"win\" condition means the smallest scheduled time.  When an event "
"schedules other events for execution, they are scheduled into the future, so"
" they can easily go into the heap.  So, a heap is a good structure for "
"implementing schedulers (this is what I used for my MIDI sequencer :-)."
msgstr "ã“ã®ã‚½ãƒ¼ãƒˆã®è‰¯ã„ç‚¹ã¯ã€æ–°ãŸã«æŒ¿å…¥ã™ã‚‹è¦ç´ ãŒã€ãã®æœ€ã«å–ã‚Šå‡ºã™ 0 ç•ªç›®ã®è¦ç´ ã‚ˆã‚Šã‚‚ \"è‰¯ã„å€¤\" ã§ãªã„é™ã‚Šã€ã‚½ãƒ¼ãƒˆã‚’è¡Œã£ã¦ã„ã‚‹æœ€ä¸­ã«æ–°ãŸãªè¦ç´ ã‚’åŠ¹ç‡çš„ã«è¿½åŠ ã§ãã‚‹ã¨ã„ã†ã¨ã“ã‚ã§ã™ã€‚ã“ã®æ€§è³ªã¯ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çš„ãªçŠ¶æ³ã§ã€ãƒ„ãƒªãƒ¼ã§å…¨ã¦ã®å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä¿æŒã—ã€\"å‹è€…ã¨ãªã‚‹çŠ¶æ³\" ã‚’æœ€å°ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ™‚åˆ»ã«ã™ã‚‹ã‚ˆã†ãªå ´åˆã«ç‰¹ã«ä¾¿åˆ©ã§ã™ã€‚ã‚ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆãŒä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆç¾¤ã®å®Ÿè¡Œã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã™ã‚‹éš›ã€ãã‚Œã‚‰ã¯æœªæ¥ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã®ã§ã€ãã‚Œã‚‰ã®ã‚¤ãƒ™ãƒ³ãƒˆç¾¤ã‚’å®¹æ˜“ã«ãƒ’ãƒ¼ãƒ—ã«ç©ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚ã™ãªã‚ã¡ã€ãƒ’ãƒ¼ãƒ—ã¯ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ã‚’å®Ÿè£…ã™ã‚‹ä¸Šã§è‰¯ã„ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã‚ã‚‹ã¨ã„ãˆã¾ã™ (ç§ã¯ MIDI ã‚·ãƒ¼ã‚±ãƒ³ã‚µã§ä½¿ã£ã¦ã„ã‚‹ã‚‚ã®ã§ã™ :-)ã€‚"

#: ../../library/heapq.rst:272
msgid ""
"Various structures for implementing schedulers have been extensively "
"studied, and heaps are good for this, as they are reasonably speedy, the "
"speed is almost constant, and the worst case is not much different than the "
"average case. However, there are other representations which are more "
"efficient overall, yet the worst cases might be terrible."
msgstr "ã“ã‚Œã¾ã§ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®æ§˜ã€…ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ãŒåºƒç¯„ã«ç ”ç©¶ã•ã‚Œã¦ã„ã¾ã™ã€‚ãƒ’ãƒ¼ãƒ—ã¯ååˆ†é«˜é€Ÿã§ã€é€Ÿåº¦ã‚‚ãŠãŠã‚€ã­ä¸€å®šã§ã‚ã‚Šã€æœ€æ‚ªã®å ´åˆã§ã‚‚å¹³å‡çš„ãªé€Ÿåº¦ã¨ã•ã»ã©å¤‰ã‚ã‚‰ãªã„ãŸã‚è‰¯ã„ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¨ã„ãˆã¾ã™ã€‚ã—ã‹ã—ã€æœ€æ‚ªã®å ´åˆãŒã²ã©ã„é€Ÿåº¦ã«ãªã‚‹ã“ã¨ã‚’é™¤ãã€ãŸã„ã¦ã„ã§ã‚ˆã‚ŠåŠ¹ç‡ã®é«˜ã„ä»–ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ è¡¨ç¾ã‚‚å­˜åœ¨ã—ã¾ã™ã€‚"

#: ../../library/heapq.rst:278
msgid ""
"Heaps are also very useful in big disk sorts.  You most probably all know "
"that a big sort implies producing \"runs\" (which are pre-sorted sequences, "
"whose size is usually related to the amount of CPU memory), followed by a "
"merging passes for these runs, which merging is often very cleverly "
"organised [#]_. It is very important that the initial sort produces the "
"longest runs possible.  Tournaments are a good way to achieve that.  If, "
"using all the memory available to hold a tournament, you replace and "
"percolate items that happen to fit the current run, you'll produce runs "
"which are twice the size of the memory for random input, and much better for"
" input fuzzily ordered."
msgstr "ãƒ’ãƒ¼ãƒ—ã¯ã¾ãŸã€å·¨å¤§ãªãƒ‡ã‚£ã‚¹ã‚¯ã®ã‚½ãƒ¼ãƒˆã§ã‚‚éå¸¸ã«æœ‰ç”¨ã§ã™ã€‚ãŠãã‚‰ãã”å­˜çŸ¥ã®ã‚ˆã†ã«ã€å·¨å¤§ãªã‚½ãƒ¼ãƒˆã‚’è¡Œã†ã¨ã€è¤‡æ•°ã® \"ãƒ©ãƒ³ (run)\" (äºˆã‚ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸé…åˆ—ã§ã€ãã®ã‚µã‚¤ã‚ºã¯é€šå¸¸ CPU ãƒ¡ãƒ¢ãƒªã®é‡ã«é–¢ä¿‚ã—ã¦ã„ã¾ã™) ãŒç”Ÿæˆã•ã‚Œã€ç¶šã„ã¦çµ±åˆå‡¦ç† (merging) ãŒã“ã‚Œã‚‰ã®ãƒ©ãƒ³ã‚’åˆ¤å®šã—ã¾ã™ã€‚ã“ã®çµ±åˆå‡¦ç†ã¯ã—ã°ã—ã°éå¸¸ã«å·§å¦™ã«çµ„ç¹”ã•ã‚Œã¦ã„ã¾ã™ [#]_ã€‚é‡è¦ãªã®ã¯ã€æœ€åˆã®ã‚½ãƒ¼ãƒˆãŒå¯èƒ½ãªé™ã‚Šé•·ã„ãƒ©ãƒ³ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã§ã™ã€‚å‹ã¡æŠœãæˆ¦ã¯ã“ã‚Œã‚’é”æˆã™ã‚‹ãŸã‚ã®è‰¯ã„æ–¹æ³•ã§ã™ã€‚ã‚‚ã—åˆ©ç”¨å¯èƒ½ãªå…¨ã¦ã®ãƒ¡ãƒ¢ãƒªã‚’ä½¿ã£ã¦å‹ã¡æŠœãæˆ¦ã‚’è¡Œã„ã€è¦ç´ ã‚’ç½®æ›ãŠã‚ˆã³æ¿¾éå‡¦ç†ã—ã¦ç¾åœ¨ã®ãƒ©ãƒ³ã«åã‚ã‚Œã°ã€ãƒ©ãƒ³ãƒ€ãƒ ãªå…¥åŠ›ã«å¯¾ã—ã¦ãƒ¡ãƒ¢ãƒªã®äºŒå€ã®ã‚µã‚¤ã‚ºã®ãƒ©ãƒ³ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã«ãªã‚Šã€å¤§ä½“é †åºã¥ã‘ãŒãªã•ã‚Œã¦ã„ã‚‹å…¥åŠ›ã«å¯¾ã—ã¦ã¯ã‚‚ã£ã¨é«˜ã„åŠ¹ç‡ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/heapq.rst:288
msgid ""
"Moreover, if you output the 0'th item on disk and get an input which may not"
" fit in the current tournament (because the value \"wins\" over the last "
"output value), it cannot fit in the heap, so the size of the heap decreases."
"  The freed memory could be cleverly reused immediately for progressively "
"building a second heap, which grows at exactly the same rate the first heap "
"is melting.  When the first heap completely vanishes, you switch heaps and "
"start a new run.  Clever and quite effective!"
msgstr "ã•ã‚‰ã«ã€ãƒ‡ã‚£ã‚¹ã‚¯ä¸Šã® 0 ç•ªç›®ã®è¦ç´ ã‚’å‡ºåŠ›ã—ã¦ã€ç¾åœ¨ã®å‹ã¡æŠœãæˆ¦ã« (æœ€å¾Œã«å‡ºåŠ›ã—ãŸå€¤ã« \"å‹ã£ã¦\" ã—ã¾ã†ãŸã‚ã«) åã‚ã‚‰ã‚Œãªã„å…¥åŠ›ã‚’å¾—ãŸãªã‚‰ã€ãƒ’ãƒ¼ãƒ—ã«ã¯åã¾ã‚‰ãªã„ãŸã‚ã€ãƒ’ãƒ¼ãƒ—ã®ã‚µã‚¤ã‚ºã¯æ¸›å°‘ã—ã¾ã™ã€‚è§£æ”¾ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã¯äºŒã¤ç›®ã®ãƒ’ãƒ¼ãƒ—ã‚’æ®µéšçš„ã«æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«å·§å¦™ã«å†åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã€ã“ã®äºŒã¤ç›®ã®ãƒ’ãƒ¼ãƒ—ã¯æœ€åˆã®ãƒ’ãƒ¼ãƒ—ãŒå´©å£Šã—ã¦ã„ãã®ã¨åŒã˜é€Ÿåº¦ã§æˆé•·ã—ã¾ã™ã€‚æœ€åˆã®ãƒ’ãƒ¼ãƒ—ãŒå®Œå…¨ã«æ¶ˆæ»…ã—ãŸã‚‰ã€ãƒ’ãƒ¼ãƒ—ã‚’åˆ‡ã‚Šæ›¿ãˆã¦æ–°ãŸãªãƒ©ãƒ³ã‚’é–‹å§‹ã—ã¾ã™ã€‚ãªã‚“ã¨å·§å¦™ã§åŠ¹ç‡çš„ãªã®ã§ã—ã‚‡ã†ï¼"

#: ../../library/heapq.rst:296
msgid ""
"In a word, heaps are useful memory structures to know.  I use them in a few "
"applications, and I think it is good to keep a 'heap' module around. :-)"
msgstr "ä¸€è¨€ã§è¨€ã†ã¨ã€ãƒ’ãƒ¼ãƒ—ã¯çŸ¥ã£ã¦å¾—ã™ã‚‹ãƒ¡ãƒ¢ãƒªæ§‹é€ ã§ã™ã€‚ç§ã¯ã„ãã¤ã‹ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ãƒ’ãƒ¼ãƒ—ã‚’ä½¿ã£ã¦ã„ã¦ã€'ãƒ’ãƒ¼ãƒ—' ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å¸¸å‚™ã™ã‚‹ã®ã¯ã„ã„äº‹ã ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚:-)"

#: ../../library/heapq.rst:300
msgid "Footnotes"
msgstr "æ³¨è¨˜"

#: ../../library/heapq.rst:301
msgid ""
"The disk balancing algorithms which are current, nowadays, are more annoying"
" than clever, and this is a consequence of the seeking capabilities of the "
"disks. On devices which cannot seek, like big tape drives, the story was "
"quite different, and one had to be very clever to ensure (far in advance) "
"that each tape movement will be the most effective possible (that is, will "
"best participate at \"progressing\" the merge).  Some tapes were even able "
"to read backwards, and this was also used to avoid the rewinding time. "
"Believe me, real good tape sorts were quite spectacular to watch! From all "
"times, sorting has always been a Great Art! :-)"
msgstr "ç¾åœ¨ä½¿ã‚ã‚Œã¦ã„ã‚‹ãƒ‡ã‚£ã‚¹ã‚¯ãƒãƒ©ãƒ³ã‚¹åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€æœ€è¿‘ã¯ã‚‚ã¯ã‚„å·§å¦™ã¨ã„ã†ã‚ˆã‚Šã‚‚ç›®éšœã‚Šã§ã‚ã‚Šã€ã“ã®ãŸã‚ã«ãƒ‡ã‚£ã‚¹ã‚¯ã«å¯¾ã™ã‚‹ã‚·ãƒ¼ã‚¯æ©Ÿèƒ½ãŒé‡è¦ã«ãªã£ã¦ã„ã¾ã™ã€‚å·¨å¤§ãªå®¹é‡ã‚’æŒã¤ãƒ†ãƒ¼ãƒ—ã®ã‚ˆã†ã«ã‚·ãƒ¼ã‚¯ä¸èƒ½ãªãƒ‡ãƒã‚¤ã‚¹ã§ã¯ã€äº‹æƒ…ã¯å…¨ãç•°ãªã‚Šã€å€‹ã€…ã®ãƒ†ãƒ¼ãƒ—ä¸Šã®ç§»å‹•ãŒå¯èƒ½ãªé™ã‚ŠåŠ¹ç‡çš„ã«è¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«éå¸¸ã«å·§å¦™ãªå‡¦ç†ã‚’ (ç›¸å½“å‰ã‚‚ã£ã¦) è¡Œã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ (ã™ãªã‚ã¡ã€ã‚‚ã£ã¨ã‚‚çµ±åˆå‡¦ç†ã® \"é€²è¡Œ\" ã«é–¢ä¿‚ãŒã‚ã‚Šã¾ã™)ã€‚ãƒ†ãƒ¼ãƒ—ã«ã‚ˆã£ã¦ã¯é€†æ–¹å‘ã«èª­ã‚€ã“ã¨ã•ãˆã§ãã€å·»ãæˆ»ã—ã«æ™‚é–“ã‚’å–ã‚‰ã‚Œã‚‹ã®ã‚’é¿ã‘ã‚‹ãŸã‚ã«ä½¿ã†ã“ã¨ã‚‚ã§ãã¾ã™ã€‚æ­£ç›´ã€æœ¬å½“ã«è‰¯ã„ãƒ†ãƒ¼ãƒ—ã‚½ãƒ¼ãƒˆã¯è¦‹ã¦ã„ã¦ç´ æ™´ã‚‰ã—ãé©šç•°çš„ãªã‚‚ã®ã§ã™ï¼ã‚½ãƒ¼ãƒˆã¨ã„ã†ã®ã¯å¸¸ã«å‰å¤§ãªèŠ¸è¡“ãªã®ã§ã™ï¼:-)"
