# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/configparser.rst:2
msgid ":mod:`ConfigParser` --- Configuration file parser"
msgstr ":mod:`ConfigParser` --- 設定ファイルの構文解析器"

#: ../../library/configparser.rst:14
msgid ""
"The :mod:`ConfigParser` module has been renamed to :mod:`configparser` in "
"Python 3.  The :term:`2to3` tool will automatically adapt imports when "
"converting your sources to Python 3."
msgstr ""
":mod:`ConfigParser` モジュールは Python 3 で :mod:`configparser` に改名されま"
"した。 :term:`2to3` ツールが自動的にソース内の import を修正します。"

#: ../../library/configparser.rst:24
msgid ""
"This module defines the class :class:`~ConfigParser.ConfigParser`.   The :"
"class:`~ConfigParser.ConfigParser` class implements a basic configuration "
"file parser language which provides a structure similar to what you would "
"find on Microsoft Windows INI files.  You can use this to write Python "
"programs which can be customized by end users easily."
msgstr ""

#: ../../library/configparser.rst:32
msgid ""
"This library does *not* interpret or write the value-type prefixes used in "
"the Windows Registry extended version of INI syntax."
msgstr ""
"このライブラリでは、Windowsのレジストリ用に拡張された INI 文法はサポート *し"
"ていません* 。"

#: ../../library/configparser.rst:39 ../../library/configparser.rst:224
msgid "Module :mod:`shlex`"
msgstr ":mod:`shlex` モジュール"

#: ../../library/configparser.rst:38
msgid ""
"Support for creating Unix shell-like mini-languages which can be used as an "
"alternate format for application configuration files."
msgstr ""
"アプリケーション設定ファイルのフォーマットとして使える、Unix シェルに似たミニ"
"言語の作成を支援します。"

#: ../../library/configparser.rst:42
msgid "Module :mod:`json`"
msgstr ":mod:`json` モジュール"

#: ../../library/configparser.rst:42
msgid ""
"The json module implements a subset of JavaScript syntax which can also be "
"used for this purpose."
msgstr ""
"json モジュールは、同じ目的に利用できる JavaScript の文法のサブセットを実装し"
"ています。"

#: ../../library/configparser.rst:45
msgid ""
"The configuration file consists of sections, led by a ``[section]`` header "
"and followed by ``name: value`` entries, with continuations in the style of :"
"rfc:`822` (see section 3.1.1, \"LONG HEADER FIELDS\"); ``name=value`` is "
"also accepted.  Note that leading whitespace is removed from values. The "
"optional values can contain format strings which refer to other values in "
"the same section, or values in a special ``DEFAULT`` section.  Additional "
"defaults can be provided on initialization and retrieval.  Lines beginning "
"with ``'#'`` or ``';'`` are ignored and may be used to provide comments."
msgstr ""
"設定ファイルは 1 つ以上のセクションからなり、セクションは ``[section]`` ヘッ"
"ダとそれに続く :rfc:`822` 形式の ``name: value`` エントリからなっています。"
"(section 3.1.1 \"LONG HEADER FIELDS\" を参照) ``name=value`` という形式も使え"
"ます。値の先頭にある空白文字は削除されるので注意してください。オプションの値"
"には、同じセクションか ``DEFAULT`` セクションにある値を参照するような書式化文"
"字列を含めることができます。初期化時や検索時に別のデフォルト値を与えることも"
"できます。 ``'#'`` か ``';'`` ではじまる行は無視され、コメントを書くために利"
"用できます。"

#: ../../library/configparser.rst:54
msgid ""
"Configuration files may include comments, prefixed by specific characters "
"(``#`` and ``;``).  Comments may appear on their own in an otherwise empty "
"line, or may be entered in lines holding values or section names.  In the "
"latter case, they need to be preceded by a whitespace character to be "
"recognized as a comment. (For backwards compatibility, only ``;`` starts an "
"inline comment, while ``#`` does not.)"
msgstr ""
"設定ファイルは、特定の文字 (``#`` と ``;``) で始まるコメントを含んでいること"
"があります。コメントはある行の中に単独で書かれる場合もありますし、値やセク"
"ション名のある行に書かれる場合もあります。後者がコメントとして認識されるため"
"には、その前に空白文字が入っている必要があります。 (後方互換性のために、 "
"``#`` ではなく ``;`` で一行コメントを書いてください。)"

#: ../../library/configparser.rst:61
msgid ""
"On top of the core functionality, :class:`SafeConfigParser` supports "
"interpolation.  This means values can contain format strings which refer to "
"other values in the same section, or values in a special ``DEFAULT`` "
"section. Additional defaults can be provided on initialization."
msgstr ""
"最も高機能なクラス :class:`SafeConfigParser` は置換機能をサポートします。これ"
"は同じセクション内の値や ``DEFAULT`` という特別なセクションの値を参照する"
"フォーマット文字列を使うことができるという意味です。さらに初期化のときにデ"
"フォルトの値を追加することもできます。"

#: ../../library/configparser.rst:66
msgid "For example::"
msgstr "例えば::"

#: ../../library/configparser.rst:74
msgid ""
"would resolve the ``%(dir)s`` to the value of ``dir`` (``frob`` in this "
"case). All reference expansions are done on demand."
msgstr ""
"この場合 ``%(dir)s`` は変数 ``dir`` (この場合は ``frob``)に展開されます。参照"
"の展開は必要に応じて実行されます。"

#: ../../library/configparser.rst:77
msgid ""
"Default values can be specified by passing them into the :class:"
"`~ConfigParser.ConfigParser` constructor as a dictionary.  Additional "
"defaults  may be passed into the :meth:`get` method which will override all "
"others."
msgstr ""

#: ../../library/configparser.rst:81
msgid ""
"Sections are normally stored in a built-in dictionary. An alternative "
"dictionary type can be passed to the :class:`~ConfigParser.ConfigParser` "
"constructor. For example, if a dictionary type is passed that sorts its "
"keys, the sections will be sorted on write-back, as will be the keys within "
"each section."
msgstr ""

#: ../../library/configparser.rst:89
msgid ""
"The basic configuration object.  When *defaults* is given, it is initialized "
"into the dictionary of intrinsic defaults.  When *dict_type* is given, it "
"will be used to create the dictionary objects for the list of sections, for "
"the options within a section, and for the default values.  When "
"*allow_no_value* is true (default: ``False``), options without values are "
"accepted; the value presented for these is ``None``."
msgstr ""
"基本的な設定オブジェクトです。 *defaults* が与えられた場合、オブジェクトに固"
"有のデフォルト値がその値で初期化されます。 *dict_type* が与えられた場合、それ"
"が、セクションのリストの格納、セクション内のオプションの格納、デフォルト値の"
"ために利用されます。 *allow_no_value* (デフォルト: ``False``) が真の時、値の"
"ないオプションが許可されます。この場合の値は ``None`` になります。"

#: ../../library/configparser.rst:96
msgid "This class does not support the magical interpolation behavior."
msgstr "このクラスは値の置換をサポートしません。"

#: ../../library/configparser.rst:99
msgid ""
"All option names are passed through the :meth:`optionxform` method.  Its "
"default implementation converts option names to lower case."
msgstr ""
"全てのオプション名が :meth:`optionxform` メソッドに渡されます。このメソッドの"
"デフォルトの実装では、オプション名を小文字に変換します。"

#: ../../library/configparser.rst:104 ../../library/configparser.rst:128
#: ../../library/configparser.rst:147
msgid "*dict_type* was added."
msgstr "*dict_type* が追加されました。"

#: ../../library/configparser.rst:107 ../../library/configparser.rst:131
#: ../../library/configparser.rst:150
msgid ""
"The default *dict_type* is :class:`collections.OrderedDict`. "
"*allow_no_value* was added."
msgstr ""
"*dict_type* のデフォルトが :class:`collections.OrderedDict` になりました。 "
"*allow_no_value* が追加されました。"

#: ../../library/configparser.rst:114
msgid ""
"Derived class of :class:`RawConfigParser` that implements the magical "
"interpolation feature and adds optional arguments to the :meth:`get` and :"
"meth:`items` methods.  The values in *defaults* must be appropriate for the "
"``%()s`` string interpolation.  Note that *__name__* is an intrinsic "
"default; its value is the section name, and will override any value provided "
"in *defaults*."
msgstr ""
":class:`RawConfigParser` の派生クラスで値の置換を実装しており、 :meth:`get` "
"メソッドと :meth:`items` メソッドに省略可能な引数を追加しています。 "
"*defaults* に含まれる値は ``%()s`` による値の置換に適当なものである必要があり"
"ます。 *__name__* は組み込みのデフォルト値で、セクション名が含まれるので "
"*defaults* で設定してもオーバーライドされます。"

#: ../../library/configparser.rst:121
msgid ""
"All option names used in interpolation will be passed through the :meth:"
"`optionxform` method just like any other option name reference.  Using the "
"default implementation of :meth:`optionxform`, the values ``foo %(bar)s`` "
"and ``foo %(BAR)s`` are equivalent."
msgstr ""
"置換で使われるすべてのオプション名は、ほかのオプション名への参照と同様に :"
"meth:`optionxform` メソッドを介して渡されます。 :meth:`optionxform` のデフォ"
"ルト実装を使うと、値 ``foo %(bar)s`` および ``foo %(BAR)s`` は同一になりま"
"す。"

#: ../../library/configparser.rst:138
msgid ""
"Derived class of :class:`~ConfigParser.ConfigParser` that implements a more-"
"sane variant of the magical interpolation feature.  This implementation is "
"more predictable as well. New applications should prefer this version if "
"they don't need to be compatible with older versions of Python."
msgstr ""

#: ../../library/configparser.rst:157
msgid "Base class for all other configparser exceptions."
msgstr "他の全ての configparser の例外の基底クラスです。"

#: ../../library/configparser.rst:162
msgid "Exception raised when a specified section is not found."
msgstr "指定したセクションが見つからなかった時に起きる例外です。"

#: ../../library/configparser.rst:167
msgid ""
"Exception raised if :meth:`add_section` is called with the name of a section "
"that is already present."
msgstr ""
"すでに存在するセクション名に対して :meth:`add_section` が呼び出された際に起き"
"る例外です。"

#: ../../library/configparser.rst:173
msgid ""
"Exception raised when a specified option is not found in the specified  "
"section."
msgstr ""
"指定したオプションが指定したセクションに存在しなかった時に起きる例外です。"

#: ../../library/configparser.rst:178
msgid ""
"Base class for exceptions raised when problems occur performing string "
"interpolation."
msgstr "文字列の置換中に問題が起きた時に発生する例外の基底クラスです。"

#: ../../library/configparser.rst:184
msgid ""
"Exception raised when string interpolation cannot be completed because the "
"number of iterations exceeds :const:`MAX_INTERPOLATION_DEPTH`. Subclass of :"
"exc:`InterpolationError`."
msgstr ""
":exc:`InterpolationError` の派生クラスで、文字列の置換回数が :const:"
"`MAX_INTERPOLATION_DEPTH` を越えたために完了しなかった場合に発生する例外で"
"す。"

#: ../../library/configparser.rst:191
msgid ""
"Exception raised when an option referenced from a value does not exist. "
"Subclass of :exc:`InterpolationError`."
msgstr ""
":exc:`InterpolationError` の派生クラスで、値が参照しているオプションが見つか"
"らない場合に発生する例外です。"

#: ../../library/configparser.rst:199
msgid ""
"Exception raised when the source text into which substitutions are made does "
"not conform to the required syntax. Subclass of :exc:`InterpolationError`."
msgstr ""
":exc:`InterpolationError` の派生クラスで、指定された構文で値を置換することが"
"できなかった場合に発生する例外です。"

#: ../../library/configparser.rst:207
msgid ""
"Exception raised when attempting to parse a file which has no section "
"headers."
msgstr ""
"セクションヘッダを持たないファイルを構文解析しようとした時に起きる例外です。"

#: ../../library/configparser.rst:212
msgid "Exception raised when errors occur attempting to parse a file."
msgstr "ファイルの構文解析中にエラーが起きた場合に発生する例外です。"

#: ../../library/configparser.rst:217
msgid ""
"The maximum depth for recursive interpolation for :meth:`get` when the *raw* "
"parameter is false.  This is relevant only for the :class:`~ConfigParser."
"ConfigParser` class."
msgstr ""

#: ../../library/configparser.rst:224
msgid ""
"Support for a creating Unix shell-like mini-languages which can be used as "
"an alternate format for application configuration files."
msgstr ""
"アプリケーション用の設定ファイルフォーマットとして使える、 Unix シェルライク"
"なミニ言語の作成を支援します。"

#: ../../library/configparser.rst:231
msgid "RawConfigParser Objects"
msgstr "RawConfigParser オブジェクト"

#: ../../library/configparser.rst:233
msgid ":class:`RawConfigParser` instances have the following methods:"
msgstr ""
":class:`RawConfigParser` クラスのインスタンスは以下のメソッドを持ちます:"

#: ../../library/configparser.rst:238
msgid "Return a dictionary containing the instance-wide defaults."
msgstr "インスタンス全体で使われるデフォルト値の辞書を返します。"

#: ../../library/configparser.rst:243
msgid ""
"Return a list of the sections available; ``DEFAULT`` is not included in the "
"list."
msgstr ""
"利用可能なセクションのリストを返します。 ``DEFAULT`` はこのリストに含まれませ"
"ん。"

#: ../../library/configparser.rst:249
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised. If the name "
"``DEFAULT`` (or any of it's case-insensitive variants) is passed, :exc:"
"`ValueError` is raised."
msgstr ""
"*section* という名前のセクションをインスタンスに追加します。同名のセクション"
"が存在した場合、 :exc:`DuplicateSectionError` が発生します。 ``DEFAULT`` (も"
"しくは大文字小文字が違うもの)が渡された場合、 :exc:`ValueError` が発生しま"
"す。"

#: ../../library/configparser.rst:256
msgid ""
"Indicates whether the named section is present in the configuration. The "
"``DEFAULT`` section is not acknowledged."
msgstr ""
"指定したセクションがコンフィグレーションファイルに存在するかを返します。 "
"``DEFAULT`` セクションは存在するとみなされません。"

#: ../../library/configparser.rst:262
msgid "Returns a list of options available in the specified *section*."
msgstr ""
"*section* で指定したセクションで利用できるオプションのリストを返します。"

#: ../../library/configparser.rst:267
msgid ""
"If the given section exists, and contains the given option, return :const:"
"`True`; otherwise return :const:`False`."
msgstr ""
"与えられたセクションが存在してかつオプションが与えられていれば :const:`True` "
"を返し、そうでなければ :const:`False` を返します。"

#: ../../library/configparser.rst:275
msgid ""
"Attempt to read and parse a list of filenames, returning a list of filenames "
"which were successfully parsed.  If *filenames* is a string or Unicode "
"string, it is treated as a single filename. If a file named in *filenames* "
"cannot be opened, that file will be ignored.  This is designed so that you "
"can specify a list of potential configuration file locations (for example, "
"the current directory, the user's home directory, and some system-wide "
"directory), and all existing configuration files in the list will be read.  "
"If none of the named files exist, the :class:`~ConfigParser.ConfigParser` "
"instance will contain an empty dataset. An application which requires "
"initial values to be loaded from a file should load the required file or "
"files using :meth:`readfp` before calling :meth:`read` for any optional "
"files::"
msgstr ""

#: ../../library/configparser.rst:293
msgid "Returns list of successfully parsed filenames."
msgstr "解析に成功したファイル名のリストを返します。"

#: ../../library/configparser.rst:299
msgid ""
"Read and parse configuration data from the file or file-like object in *fp* "
"(only the :meth:`readline` method is used).  If *filename* is omitted and "
"*fp* has a :attr:`name` attribute, that is used for *filename*; the default "
"is ``<???>``."
msgstr ""
"*fp* で与えられるファイルかファイルのようなオブジェクトを読み込んで構文解析し"
"ます(:meth:`readline` メソッドだけを使います)。もし *filename* が省略されて "
"*fp* が :attr:`name` 属性を持っていれば *filename* の代わりに使われます。ファ"
"イル名の初期値は ``<???>`` です。"

#: ../../library/configparser.rst:307
msgid "Get an *option* value for the named *section*."
msgstr "*section* の *option* 変数を取得します。"

#: ../../library/configparser.rst:312
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to an integer."
msgstr "*section* の *option* を整数として評価する関数です。"

#: ../../library/configparser.rst:318
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a floating point number."
msgstr "*section* の *option* を浮動小数点数として評価する関数です。"

#: ../../library/configparser.rst:324
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a Boolean value.  Note that the accepted values for the option are "
"``\"1\"``, ``\"yes\"``, ``\"true\"``, and ``\"on\"``, which cause this "
"method to return ``True``, and ``\"0\"``, ``\"no\"``, ``\"false\"``, and "
"``\"off\"``, which cause it to return ``False``.  These string values are "
"checked in a case-insensitive manner.  Any other value will cause it to "
"raise :exc:`ValueError`."
msgstr ""
"指定した *section* の *option* 値をブール値に型強制する便宜メソッドです。 "
"*option* として受理できる値は、真 (True) としては ``\"1\"`` 、 "
"``\"yes\"`` 、 ``\"true\"`` 、 ``\"on\"`` 、偽 (False) としては ``\"0\"`` 、 "
"``\"no\"`` 、 ``\"false\"`` 、 ``\"off\"`` です。これらの文字列値に対しては大"
"文字小文字の区別をしません。その他の値の場合には :exc:`ValueError` を送出しま"
"す。"

#: ../../library/configparser.rst:334
msgid ""
"Return a list of ``(name, value)`` pairs for each option in the given "
"*section*."
msgstr ""
"与えられた *section* のそれぞれのオプションについて ``(name, value)`` ペアの"
"リストを返します。"

#: ../../library/configparser.rst:339
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  While it is possible to use :class:"
"`RawConfigParser` (or :class:`~ConfigParser.ConfigParser` with *raw* "
"parameters set to true) for *internal* storage of non-string values, full "
"functionality (including interpolation and output to files) can only be "
"achieved using string values."
msgstr ""

#: ../../library/configparser.rst:350
msgid ""
"Write a representation of the configuration to the specified file object.  "
"This representation can be parsed by a future :meth:`read` call."
msgstr ""
"設定を文字列表現に変換してファイルオブジェクトに書き出します。この文字列表現"
"は :meth:`read` で読み込むことができます。"

#: ../../library/configparser.rst:358
msgid ""
"Remove the specified *option* from the specified *section*. If the section "
"does not exist, raise :exc:`NoSectionError`.  If the option existed to be "
"removed, return :const:`True`; otherwise return :const:`False`."
msgstr ""
"指定された *section* から指定された *option* を削除します。セクションが存在し"
"なければ、 :exc:`NoSectionError` を起こします。存在するオプションを削除した時"
"は :const:`True` を、そうでない時は :const:`False` を返します。"

#: ../../library/configparser.rst:367
msgid ""
"Remove the specified *section* from the configuration. If the section in "
"fact existed, return ``True``. Otherwise return ``False``."
msgstr ""
"指定された *section* を設定から削除します。もし指定されたセクションが存在すれ"
"ば ``True`` 、そうでなければ ``False`` を返します。"

#: ../../library/configparser.rst:373
msgid ""
"Transforms the option name *option* as found in an input file or as passed "
"in by client code to the form that should be used in the internal "
"structures. The default implementation returns a lower-case version of "
"*option*; subclasses may override this or client code can set an attribute "
"of this name on instances to affect this behavior."
msgstr ""
"入力ファイル中に見つかったオプション名か、クライアントコードから渡されたオプ"
"ション名 *option* を、内部で利用する形式に変換します。デフォルトでは "
"*option* を全て小文字に変換した名前が返されます。サブルクラスではこの関数を"
"オーバーライドすることでこの振舞いを替えることができます。"

#: ../../library/configparser.rst:379
msgid ""
"You don't necessarily need to subclass a ConfigParser to use this method, "
"you can also re-set it on an instance, to a function that takes a string "
"argument.  Setting it to ``str``, for example, would make option names case "
"sensitive::"
msgstr ""
"振舞いを替えるために ConfigParser を継承して新たにクラスを作る必要はありませ"
"ん、あるインスタンスのメソッドを文字列を引数に取る関数で置き換えることもでき"
"ます。たとえば、このメソッドを :func:`str` に設定することで大小文字の差を区別"
"するように変更することができます::"

#: ../../library/configparser.rst:388
msgid ""
"Note that when reading configuration files, whitespace around the option "
"names are stripped before :meth:`optionxform` is called."
msgstr ""
"設定ファイルを読み込むときには、 :meth:`optionxform` が呼ばれる前にオプション"
"名の前後の空白文字が取り除かれることに注意してください。"

#: ../../library/configparser.rst:395
msgid "ConfigParser Objects"
msgstr "ConfigParser オブジェクト"

#: ../../library/configparser.rst:397
msgid ""
"The :class:`~ConfigParser.ConfigParser` class extends some methods of the :"
"class:`RawConfigParser` interface, adding some optional arguments."
msgstr ""

#: ../../library/configparser.rst:403
msgid ""
"Get an *option* value for the named *section*.  If *vars* is provided, it "
"must be a dictionary.  The *option* is looked up in *vars* (if provided), "
"*section*, and in *defaults* in that order."
msgstr ""
"*section* の *option* 変数を取得します。このメソッドに渡される *vars* は辞書"
"でなくてはいけません。 (もし渡されているならば) *vars* 、 *section* 、 "
"*defaults* の順に *option* が探されます。"

#: ../../library/configparser.rst:407
msgid ""
"All the ``'%'`` interpolations are expanded in the return values, unless the "
"*raw* argument is true.  Values for interpolation keys are looked up in the "
"same manner as the option."
msgstr ""
"*raw* が真でない時には、全ての ``'%'`` 置換は展開されてから返されます。置換後"
"の値はオプションと同じ順序で探されます。"

#: ../../library/configparser.rst:413
msgid ""
"Return a list of ``(name, value)`` pairs for each option in the given "
"*section*. Optional arguments have the same meaning as for the :meth:`get` "
"method."
msgstr ""
"指定した *section* 内の各オプションに対して、 ``(name, value)`` のペアからな"
"るリストを返します。省略可能な引数は ``get()`` メソッドと同じ意味を持ちます。"

#: ../../library/configparser.rst:422
msgid "SafeConfigParser Objects"
msgstr "SafeConfigParser オブジェクト"

#: ../../library/configparser.rst:424
msgid ""
"The :class:`SafeConfigParser` class implements the same extended interface "
"as :class:`~ConfigParser.ConfigParser`, with the following addition:"
msgstr ""

#: ../../library/configparser.rst:430
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  *value* must be a string (:class:"
"`str` or :class:`unicode`); if not, :exc:`TypeError` is raised."
msgstr ""
"もし与えられたセクションが存在している場合は、指定された値を与えられたオプ"
"ションに設定します。そうでない場合は :exc:`NoSectionError` を発生させます。 "
"*value* は文字列 (:class:`str` または :class:`unicode`) でなければならず、そ"
"うでない場合には :exc:`TypeError` が発生します。"

#: ../../library/configparser.rst:438
msgid "Examples"
msgstr "使用例"

#: ../../library/configparser.rst:440
msgid "An example of writing to a configuration file::"
msgstr "設定ファイルを書き出す例::"

#: ../../library/configparser.rst:465
msgid "An example of reading the configuration file again::"
msgstr "設定ファイルを読み込む例::"

#: ../../library/configparser.rst:483
msgid ""
"To get interpolation, you will need to use a :class:`~ConfigParser."
"ConfigParser` or :class:`SafeConfigParser`::"
msgstr ""

#: ../../library/configparser.rst:500
msgid ""
"Defaults are available in all three types of ConfigParsers. They are used in "
"interpolation if an option used is not defined elsewhere. ::"
msgstr ""
"3 種類全ての ConfigParser クラスで、デフォルト値を利用できます。別にオプショ"
"ンが指定されていなかった場合、このデフォルト値は置換機能でも利用されます::"

#: ../../library/configparser.rst:514
msgid ""
"The function ``opt_move`` below can be used to move options between "
"sections::"
msgstr ""
"``opt_move`` 関数は、オプションをセクション間で移動することができます::"

#: ../../library/configparser.rst:526
msgid ""
"Some configuration files are known to include settings without values, but "
"which otherwise conform to the syntax supported by :mod:`ConfigParser`.  The "
"*allow_no_value* parameter to the constructor can be used to indicate that "
"such values should be accepted:"
msgstr ""
"いくつかの設定ファイルでは、値のない設定項目がある以外は :mod:`ConfigParser` "
"の文法と同じ文法になっています。コンストラクタの *allow_no_value* 引数で、そ"
"のような値を許可することができます。"
