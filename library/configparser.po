# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-27 14:46+0900\n"
"PO-Revision-Date: 2018-06-29 17:34+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/configparser.rst:2
msgid ":mod:`configparser` --- Configuration file parser"
msgstr ":mod:`configparser` --- è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ãƒ¼ã‚µãƒ¼"

#: ../../library/configparser.rst:14
msgid "**Source code:** :source:`Lib/configparser.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/configparser.py`"

#: ../../library/configparser.rst:24
msgid ""
"This module provides the :class:`ConfigParser` class which implements a "
"basic configuration language which provides a structure similar to what's "
"found in Microsoft Windows INI files.  You can use this to write Python "
"programs which can be customized by end users easily."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ Microsoft Windows ã® INI ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¼¼ãŸæ§‹é€ ã‚’æŒã£ãŸãƒ™ãƒ¼ã‚·ãƒƒã‚¯ãªè¨­å®šç”¨è¨€èªã‚’å®Ÿè£…ã—ãŸ "
":class:`ConfigParser` ã‚¯ãƒ©ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã£ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç°¡å˜ã«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹ Python "
"ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/configparser.rst:31
msgid ""
"This library does *not* interpret or write the value-type prefixes used in "
"the Windows Registry extended version of INI syntax."
msgstr "ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã¯ã€Windowsã®ãƒ¬ã‚¸ã‚¹ãƒˆãƒªç”¨ã«æ‹¡å¼µã•ã‚ŒãŸ INI æ–‡æ³•ã¯ã‚µãƒãƒ¼ãƒˆ *ã—ã¦ã„ã¾ã›ã‚“* ã€‚"

#: ../../library/configparser.rst:38
msgid "Module :mod:`shlex`"
msgstr ":mod:`shlex` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/configparser.rst:37
msgid ""
"Support for creating Unix shell-like mini-languages which can be used as an "
"alternate format for application configuration files."
msgstr "ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¨ã—ã¦ä½¿ãˆã‚‹ã€Unix ã‚·ã‚§ãƒ«ã«ä¼¼ãŸãƒŸãƒ‹è¨€èªã®ä½œæˆã‚’æ”¯æ´ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:41
msgid "Module :mod:`json`"
msgstr ":mod:`json` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/configparser.rst:41
msgid ""
"The json module implements a subset of JavaScript syntax which can also be "
"used for this purpose."
msgstr "json ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€åŒã˜ç›®çš„ã«åˆ©ç”¨ã§ãã‚‹ JavaScript ã®æ–‡æ³•ã®ã‚µãƒ–ã‚»ãƒƒãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/configparser.rst:46
msgid "Quick Start"
msgstr "ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ"

#: ../../library/configparser.rst:48
msgid "Let's take a very basic configuration file that looks like this:"
msgstr "æ¬¡ã®ã‚ˆã†ãªã€éå¸¸ã«ç°¡å˜ãªè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¾‹ã«è€ƒãˆã¾ã—ã‚‡ã†:"

#: ../../library/configparser.rst:65
msgid ""
"The structure of INI files is described `in the following section "
"<#supported-ini-file-structure>`_.  Essentially, the file consists of "
"sections, each of which contains keys with values. :mod:`configparser` "
"classes can read and write such files.  Let's start by creating the above "
"configuration file programmatically."
msgstr ""
"INI ãƒ•ã‚¡ã‚¤ãƒ«ã®æ§‹é€ ã¯ `ä¸‹ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ <#supported-ini-file-structure>`_ ã§è§£èª¬ã—ã¾ã™ã€‚\n"
"åŸºæœ¬çš„ã«ã€ãƒ•ã‚¡ã‚¤ãƒ«ã¯è¤‡æ•°ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰ãªã‚Šã€å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯è¤‡æ•°ã®ã‚­ãƒ¼ã¨å€¤ã‚’æŒã¡ã¾ã™ã€‚\n"
":mod:`configparser` ã®ã‚¯ãƒ©ã‚¹ç¾¤ã¯ãã‚Œã‚‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿æ›¸ãã§ãã¾ã™ã€‚\n"
"ã¾ãšã¯ä¸Šã®ã‚ˆã†ãªè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰ä½œæˆã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚"

#: ../../library/configparser.rst:89
msgid ""
"As you can see, we can treat a config parser much like a dictionary. There "
"are differences, `outlined later <#mapping-protocol-access>`_, but the "
"behavior is very close to what you would expect from a dictionary."
msgstr ""
"ã“ã®ä¾‹ã§ã‚ã‹ã‚‹ã‚ˆã†ã«ã€config parser ã¯è¾æ›¸ã®ã‚ˆã†ã«æ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚è¾æ›¸ã¨ã®é•ã„ã¯ `å¾Œã« <#mapping-protocol-"
"access>`_ èª¬æ˜ã—ã¾ã™ãŒã€ã“ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¯è¾æ›¸ã«å¯¾ã—ã¦æœŸå¾…ã™ã‚‹ã®ã¨ã¨ã¦ã‚‚è¿‘ã„å‹•ä½œã‚’ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:93
msgid ""
"Now that we have created and saved a configuration file, let's read it back "
"and explore the data it holds."
msgstr "ã“ã‚Œã§è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¦ä¿å­˜ã§ãã¾ã—ãŸã€‚æ¬¡ã¯ã“ã‚Œã‚’èª­ã¿è¾¼ã¿ç›´ã—ã¦ã€ä¸­ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Šå‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚"

#: ../../library/configparser.rst:129
msgid ""
"As we can see above, the API is pretty straightforward.  The only bit of "
"magic involves the ``DEFAULT`` section which provides default values for all"
" other sections [1]_.  Note also that keys in sections are case-insensitive "
"and stored in lowercase [1]_."
msgstr ""
"ä¸Šã®ä¾‹ã‹ã‚‰ã‚ã‹ã‚‹ã‚ˆã†ã«ã€API ã¯ã¨ã¦ã‚‚ç›´æ„Ÿçš„ã§ã™ã€‚å”¯ä¸€ã®é­”è¡“ã¯ã€``DEFAULT`` "
"ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒä»–ã®å…¨ã¦ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãŸã‚ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æä¾›ã—ã¦ã„ã‚‹ã“ã¨ã§ã™ [1]_ã€‚ "
"ã¾ãŸã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…ã®å„ã‚­ãƒ¼ã¯å¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã›ãšã€å…¨ã¦å°æ–‡å­—ã§ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã«ã‚‚æ³¨æ„ã—ã¦ãã ã•ã„ [1]_ã€‚"

#: ../../library/configparser.rst:136
msgid "Supported Datatypes"
msgstr "ã‚µãƒãƒ¼ãƒˆã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿å‹"

#: ../../library/configparser.rst:138
msgid ""
"Config parsers do not guess datatypes of values in configuration files, "
"always storing them internally as strings.  This means that if you need "
"other datatypes, you should convert on your own:"
msgstr ""
"Config parser "
"ã¯å€¤ã®ãƒ‡ãƒ¼ã‚¿å‹ã«ã¤ã„ã¦ä½•ã‚‚æ¨è«–ã›ãšã€å¸¸ã«æ–‡å­—åˆ—ã®ã¾ã¾å†…éƒ¨ã«ä¿å­˜ã—ã¾ã™ã€‚ä»–ã®ãƒ‡ãƒ¼ã‚¿å‹ãŒå¿…è¦ãªå ´åˆã¯è‡ªåˆ†ã§å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™:"

#: ../../library/configparser.rst:149
msgid ""
"Since this task is so common, config parsers provide a range of handy getter"
" methods to handle integers, floats and booleans.  The last one is the most "
"interesting because simply passing the value to ``bool()`` would do no good "
"since ``bool('False')`` is still ``True``.  This is why config parsers also "
"provide :meth:`~ConfigParser.getboolean`.  This method is case-insensitive "
"and recognizes Boolean values from ``'yes'``/``'no'``, ``'on'``/``'off'``, "
"``'true'``/``'false'`` and ``'1'``/``'0'`` [1]_.  For example:"
msgstr ""
"ã“ã®ã‚¿ã‚¹ã‚¯ã¯ã¨ã¦ã‚‚ä¸€èˆ¬çš„ãªãŸã‚ã€è¨­å®šãƒ‘ãƒ¼ã‚µãƒ¼ã§ã¯æ•´æ•°ã€æµ®å‹•å°æ•°ç‚¹æ•°ã€çœŸå½å€¤ã‚’æ‰±ã†ãŸã‚ã®æ‰‹é ƒãªã‚²ãƒƒã‚¿ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚çœŸå½å€¤ã®æ‰±ã„ã¯ä¸€ç­‹ç¸„ã§ã¯ã„ãã¾ã›ã‚“ã€‚æ–‡å­—åˆ—ã‚’"
" ``bool()`` ã«æ¸¡ã—ã¦ã‚‚ã€ ``bool('False')`` ãŒ ``True`` ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚ãã“ã§ config parser "
"ã¯ :meth:`~ConfigParser.getboolean` ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã›ãšã€ "
"``'yes'``/``'no'``ã€``'on'``/``'off'``ã€``'true'``/``'false'``ã€``'1'``/``'0'``"
" ã‚’çœŸå½å€¤ã¨ã—ã¦èªè­˜ã—ã¾ã™ [1]_ã€‚ä¾‹ãˆã°:"

#: ../../library/configparser.rst:166
msgid ""
"Apart from :meth:`~ConfigParser.getboolean`, config parsers also provide "
"equivalent :meth:`~ConfigParser.getint` and :meth:`~ConfigParser.getfloat` "
"methods.  You can register your own converters and customize the provided "
"ones. [1]_"
msgstr ""
"config parser ã§ã¯ã€ :meth:`~ConfigParser.getboolean` ä»¥å¤–ã« "
":meth:`~ConfigParser.getint` ã¨ :meth:`~ConfigParser.getfloat` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚ç‹¬è‡ªã®ã‚³ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã®ç™»éŒ²ã€æä¾›ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚‚ã§ãã¾ã™ã€‚ [1]_"

#: ../../library/configparser.rst:172
msgid "Fallback Values"
msgstr "ä»£æ›¿å€¤"

#: ../../library/configparser.rst:174
msgid ""
"As with a dictionary, you can use a section's :meth:`get` method to provide "
"fallback values:"
msgstr "è¾æ›¸ã¨åŒã˜ã‚ˆã†ã«ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã® :meth:`get` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä»£æ›¿å€¤ã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/configparser.rst:187
msgid ""
"Please note that default values have precedence over fallback values. For "
"instance, in our example the ``'CompressionLevel'`` key was specified only "
"in the ``'DEFAULT'`` section.  If we try to get it from the section "
"``'topsecret.server.com'``, we will always get the default, even if we "
"specify a fallback:"
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ä»£æ›¿å€¤ã‚ˆã‚Šã‚‚å„ªå…ˆã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°ä¸Šã®ä¾‹ã§ã¯ã€``'CompressionLevel'`` ã‚­ãƒ¼ã¯ "
"``'DEFAULT'`` ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã—ã‹å­˜åœ¨ã—ã¾ã›ã‚“ã€‚ãã®å€¤ã‚’ ``'topsecret.server.com'`` "
"ã‹ã‚‰å–å¾—ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã€ä»£æ›¿å€¤ã‚’æŒ‡å®šã—ã¦ã‚‚å¸¸ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã—ã¾ã™:"

#: ../../library/configparser.rst:198
msgid ""
"One more thing to be aware of is that the parser-level :meth:`get` method "
"provides a custom, more complex interface, maintained for backwards "
"compatibility.  When using this method, a fallback value can be provided via"
" the ``fallback`` keyword-only argument:"
msgstr ""
"ã‚‚ã†ä¸€ã¤æ³¨æ„ã™ã¹ãç‚¹ã¯ã€ãƒ‘ãƒ¼ã‚µãƒ¼ãƒ¬ãƒ™ãƒ«ã®(è¨³æ³¨: ConfigParserã‚¯ãƒ©ã‚¹ã®) :meth:`get` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã«ã€ã‚«ã‚¹ã‚¿ãƒ ã®ã‚ˆã‚Šè¤‡é›‘ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹éš›ã«ã¯ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å€¤ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ã—ã¦ã®ã¿æŒ‡å®šã§ãã‚‹"
" ``fallback`` å¼•æ•°ã‚’ä»‹ã—ã¦æä¾›ã•ã‚Œã¾ã™:"

#: ../../library/configparser.rst:209
msgid ""
"The same ``fallback`` argument can be used with the "
":meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat` and "
":meth:`~ConfigParser.getboolean` methods, for example:"
msgstr ""
"åŒæ§˜ã® ``fallback`` å¼•æ•°ã‚’ã€:meth:`~ConfigParser.getint` ã€ "
":meth:`~ConfigParser.getfloat` ã¨ :meth:`~ConfigParser.getboolean` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚‚ä½¿ãˆã¾ã™ã€‚ä¾‹ãˆã°:"

#: ../../library/configparser.rst:225
msgid "Supported INI File Structure"
msgstr "ã‚µãƒãƒ¼ãƒˆã™ã‚‹INI ãƒ•ã‚¡ã‚¤ãƒ«ã®æ§‹é€ "

#: ../../library/configparser.rst:227
msgid ""
"A configuration file consists of sections, each led by a ``[section]`` "
"header, followed by key/value entries separated by a specific string (``=`` "
"or ``:`` by default [1]_).  By default, section names are case sensitive but"
" keys are not [1]_.  Leading and trailing whitespace is removed from keys "
"and values. Values can be omitted, in which case the key/value delimiter may"
" also be left out.  Values can also span multiple lines, as long as they are"
" indented deeper than the first line of the value.  Depending on the "
"parser's mode, blank lines may be treated as parts of multiline values or "
"ignored."
msgstr ""
"è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã¯è¤‡æ•°ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰æ§‹æˆã•ã‚Œã¾ã™ã€‚ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€``[section]`` ãƒ˜ãƒƒãƒ€ã«ç¶šã„ãŸã€ç‰¹å®šã®æ–‡å­—åˆ—(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``=`` "
"ã¾ãŸã¯ ``:`` [1]_ )ã§åŒºåˆ‡ã‚‰ã‚ŒãŸã‚­ãƒ¼ã¨å€¤ã®ã‚¨ãƒ³ãƒˆãƒªã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³åã¯å¤§æ–‡å­—ã¨å°æ–‡å­—ã‚’åŒºåˆ¥ã—ã¾ã™ãŒã€ã‚­ãƒ¼ã¯ãã†ã§ã¯ã‚ã‚Šã¾ã›ã‚“"
" "
"[1]_ã€‚ã‚­ãƒ¼ã¨å€¤ã€ãã‚Œãã‚Œã®å…ˆé ­ã¨æœ«å°¾ã®ç©ºç™½ã¯å–ã‚Šé™¤ã‹ã‚Œã¾ã™ã€‚å€¤ã¯çœç•¥ã™ã‚‹ã“ã¨ãŒã§ãã€ãã®éš›ã§ã‚‚ã€ã‚­ãƒ¼ã¨å€¤ã®åŒºåˆ‡ã‚Šæ–‡å­—ã¯æ®‹ã—ã¦ãŠã‘ã¾ã™ã€‚å€¤ã¯ã¾ãŸã€å€¤ã®å…ˆé ­ã®è¡Œã‚ˆã‚Šæ·±ãã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã•ã‚Œã¦ã„ã‚Œã°ã€è¤‡æ•°ã®è¡Œã«ã¾ãŸãŒã£ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ãƒ‘ãƒ¼ã‚µãƒ¼ã®ãƒ¢ãƒ¼ãƒ‰ã«ã‚ˆã£ã¦ã€ç©ºç™½è¡Œã¯ã€è¤‡æ•°è¡Œã‹ã‚‰ãªã‚‹å€¤ã®ä¸€éƒ¨ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ã‹ã€ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:236
msgid ""
"Configuration files may include comments, prefixed by specific characters "
"(``#`` and ``;`` by default [1]_).  Comments may appear on their own on an "
"otherwise empty line, possibly indented. [1]_"
msgstr ""
"è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯å…ˆé ­ã«ç‰¹å®šã®æ–‡å­— (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``#`` ãŠã‚ˆã³ ``;`` [1]_) "
"ã‚’ã¤ã‘ã¦ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚³ãƒ¡ãƒ³ãƒˆã¯ã€ä»–ã®å†…å®¹ãŒãªã„è¡Œã«ç½®ãã“ã¨ãŒã§ãã€ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã•ã‚Œã¦ã„ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚[1]_"

#: ../../library/configparser.rst:240 ../../library/configparser.rst:303
msgid "For example:"
msgstr "ä¾‹ãˆã°:"

#: ../../library/configparser.rst:288
msgid "Interpolation of values"
msgstr "å€¤ã®è£œé–“"

#: ../../library/configparser.rst:290
msgid ""
"On top of the core functionality, :class:`ConfigParser` supports "
"interpolation.  This means values can be preprocessed before returning them "
"from ``get()`` calls."
msgstr ""
"ã‚³ã‚¢æ©Ÿèƒ½ã«åŠ ãˆã¦ã€ :class:`ConfigParser` ã¯è£œé–“(interpolation, å†…æŒ¿ã¨ã‚‚)ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ã“ã‚Œã¯ "
"``get()`` ã‚³ãƒ¼ãƒ«ãŒå€¤ã‚’è¿”ã™å‰ã«ã€ãã®å€¤ã«å¯¾ã—ã¦å‰å‡¦ç†ã‚’è¡Œãˆã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:298
msgid ""
"The default implementation used by :class:`ConfigParser`.  It enables values"
" to contain format strings which refer to other values in the same section, "
"or values in the special default section [1]_.  Additional default values "
"can be provided on initialization."
msgstr ""
":class:`ConfigParser` ãŒä½¿ç”¨ã™ã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ã™ã€‚å€¤ã«ã€åŒã˜ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‹ç‰¹åˆ¥ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ä¸­ [1]_ "
"ã®ä»–ã®å€¤ã‚’å‚ç…§ã™ã‚‹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ã‚’å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚è¿½åŠ ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’åˆæœŸåŒ–æ™‚ã«æä¾›ã§ãã¾ã™ã€‚"

#: ../../library/configparser.rst:313
msgid ""
"In the example above, :class:`ConfigParser` with *interpolation* set to "
"``BasicInterpolation()`` would resolve ``%(home_dir)s`` to the value of "
"``home_dir`` (``/Users`` in this case).  ``%(my_dir)s`` in effect would "
"resolve to ``/Users/lumberjack``.  All interpolations are done on demand so "
"keys used in the chain of references do not have to be specified in any "
"specific order in the configuration file."
msgstr ""
"ä¸Šã®ä¾‹ã§ã¯ã€ *interpolation* ã« ``BasicInterpolation()`` ã‚’è¨­å®šã—ãŸ "
":class:`ConfigParser` ãŒ ``%(home_dir)s`` ã‚’ ``home_dir`` ã®å€¤(ã“ã®ã‚±ãƒ¼ã‚¹ã§ã¯ "
"``/Users`` )ã¨ã—ã¦è§£æ±ºã—ã¦ã„ã¾ã™ã€ãã®çµæœ ``%(my_dir)s`` ã¯ ``/Users/lumberjack`` "
"ã«ãªã‚Šã¾ã™ã€‚å…¨ã¦ã®è£œé–“ã¯å¿…è¦ã«å¿œã˜ã¦å®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã€è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä¸­ã§å‚ç…§ã®é€£é–ã‚’ã‚‚ã¤ã‚­ãƒ¼ã‚’ç‰¹å®šã®é †åºã§è¨˜è¿°ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/configparser.rst:320
msgid ""
"With ``interpolation`` set to ``None``, the parser would simply return "
"``%(my_dir)s/Pictures`` as the value of ``my_pictures`` and "
"``%(home_dir)s/lumberjack`` as the value of ``my_dir``."
msgstr ""
"``interpolation`` ã« ``None`` ã‚’è¨­å®šã™ã‚Œã°ã€ãƒ‘ãƒ¼ã‚µãƒ¼ã¯å˜ã« ``my_pictures`` ã®å€¤ã¨ã—ã¦  "
"``%(my_dir)s/Pictures`` ã‚’è¿”ã—ã€``my_dir`` ã®å€¤ã¨ã—ã¦ ``%(home_dir)s/lumberjack`` "
"ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:328
msgid ""
"An alternative handler for interpolation which implements a more advanced "
"syntax, used for instance in ``zc.buildout``.  Extended interpolation is "
"using ``${section:option}`` to denote a value from a foreign section. "
"Interpolation can span multiple levels.  For convenience, if the "
"``section:`` part is omitted, interpolation defaults to the current section "
"(and possibly the default values from the special section)."
msgstr ""
"``zc.buildout`` "
"ã§ä½¿ç”¨ã•ã‚Œã‚‹ã‚ˆã†ãªã€ã‚ˆã‚Šé«˜åº¦ãªæ–‡æ³•ã‚’å®Ÿè£…ã—ãŸè£œé–“ãƒãƒ³ãƒ‰ãƒ©ã®åˆ¥ã®é¸æŠè‚¢ã§ã™ã€‚æ‹¡å¼µã•ã‚ŒãŸè£œé–“ã¯ã€ä»–ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ä¸­ã®å€¤ã‚’ç¤ºã™ã®ã« "
"``${section:option}`` ã¨æ›¸ã‘ã¾ã™ã€‚è£œé–“ã¯è¤‡æ•°ã®ãƒ¬ãƒ™ãƒ«ã«åŠã¹ã¾ã™ã€åˆ©ä¾¿æ€§ã®ãŸã‚ã«ã€ã‚‚ã— ``section:`` "
"ã®éƒ¨åˆ†ãŒçœç•¥ã•ã‚Œã‚‹ã¨ã€ç¾åœ¨ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ãªã‚Šã¾ã™(ã‚¹ãƒšã‚·ãƒ£ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ä¸­ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™)ã€‚"

#: ../../library/configparser.rst:335
msgid ""
"For example, the configuration specified above with basic interpolation, "
"would look like this with extended interpolation:"
msgstr ""
"ãŸã¨ãˆã°ã€ä¸Šè¨˜ã® basic interpolation ã§æŒ‡å®šã—ãŸè¨­å®šã¯ã€extended interpolation ã‚’ä½¿ã†ã¨ä¸‹è¨˜ã®ã‚ˆã†ã«ãªã‚Šã¾ã™:"

#: ../../library/configparser.rst:345
msgid "Values from other sections can be fetched as well:"
msgstr "ä»–ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰å€¤ã‚’æŒã£ã¦ãã‚‹ã“ã¨ã‚‚ã§ãã¾ã™:"

#: ../../library/configparser.rst:367
msgid "Mapping Protocol Access"
msgstr "ãƒãƒƒãƒ—å‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¢ã‚¯ã‚»ã‚¹"

#: ../../library/configparser.rst:371
msgid ""
"Mapping protocol access is a generic name for functionality that enables "
"using custom objects as if they were dictionaries.  In case of "
":mod:`configparser`, the mapping interface implementation is using the "
"``parser['section']['option']`` notation."
msgstr ""
"ãƒãƒƒãƒ—å‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¢ã‚¯ã‚»ã‚¹ã¯ã€ã‚«ã‚¹ã‚¿ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¾æ›¸ã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«ä½¿ã†ãŸã‚ã®æ©Ÿèƒ½ã®ç·ç§°ã§ã™ã€‚ :mod:`configparser` "
"ã®å ´åˆã€ãƒãƒƒãƒ—å‹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã®å®Ÿè£…ã¯ ``parser['section']['option']`` è¡¨è¨˜ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/configparser.rst:376
msgid ""
"``parser['section']`` in particular returns a proxy for the section's data "
"in the parser.  This means that the values are not copied but they are taken"
" from the original parser on demand.  What's even more important is that "
"when values are changed on a section proxy, they are actually mutated in the"
" original parser."
msgstr ""
"ã¨ãã«ã€``parser['section']`` "
"ã¯ãƒ‘ãƒ¼ã‚µãƒ¼å†…ã®ãã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ‡ãƒ¼ã‚¿ã¸ã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€å€¤ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œã‚‹ã®ã§ã¯ãªãå¿…è¦ã«å¿œã˜ã¦ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ãƒ‘ãƒ¼ã‚µãƒ¼ã‹ã‚‰å–ã‚‰ã‚Œã¾ã™ã€‚ã•ã‚‰ã«é‡è¦ãªã“ã¨ã«ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ—ãƒ­ã‚­ã‚·ã®å€¤ãŒå¤‰æ›´ã•ã‚Œã‚‹ã¨ã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ãƒ‘ãƒ¼ã‚µãƒ¼ä¸­ã®å€¤ãŒå®Ÿéš›ã«å¤‰æ›´ã•ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:382
msgid ""
":mod:`configparser` objects behave as close to actual dictionaries as "
"possible. The mapping interface is complete and adheres to the "
":class:`~collections.abc.MutableMapping` ABC. However, there are a few "
"differences that should be taken into account:"
msgstr ""
":mod:`configparser` ã¯å¯èƒ½ãªé™ã‚Šå®Ÿéš›ã®è¾æ›¸ã¨è¿‘ã„æŒ¯ã‚‹èˆã„ã‚’ã—ã¾ã™ã€‚ãƒãƒƒãƒ—å‹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¯ "
":class:`~collections.abc.MutableMapping` ã‚’çŸ›ç›¾ãªãå®Œæˆã—ã¾ã™ã€‚ã—ã‹ã—ã€è€ƒæ…®ã™ã‚‹ã¹ãé•ã„ãŒã„ãã¤ã‹ã‚ã‚Šã¾ã™:"

#: ../../library/configparser.rst:387
msgid ""
"By default, all keys in sections are accessible in a case-insensitive manner"
" [1]_.  E.g. ``for option in parser[\"section\"]`` yields only "
"``optionxform``'ed option key names.  This means lowercased keys by default."
"  At the same time, for a section that holds the key ``'a'``, both "
"expressions return ``True``::"
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…ã®å…¨ã¦ã®ã‚­ãƒ¼ã¯å¤§æ–‡å­—å°æ–‡å­—ã®åŒºåˆ¥ãªãã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ [1]_ã€‚ä¾‹ãˆã°ã€``for option in "
"parser[\"section\"]`` ã¯ ``optionxform`` ã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚­ãƒ¼åã®ã¿ã‚’ yield "
"ã—ã¾ã™ã€‚ã¤ã¾ã‚Šå°æ–‡å­—ã®ã‚­ãƒ¼ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã™ã€‚åŒæ™‚ã«ã€ã‚­ãƒ¼ ``'a'`` ã‚’å«ã‚€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ãŠã„ã¦ã€ã©ã¡ã‚‰ã®å¼ã‚‚ ``True`` ã‚’è¿”ã—ã¾ã™::"

#: ../../library/configparser.rst:395
msgid ""
"All sections include ``DEFAULTSECT`` values as well which means that "
"``.clear()`` on a section may not leave the section visibly empty.  This is "
"because default values cannot be deleted from the section (because "
"technically they are not there).  If they are overridden in the section, "
"deleting causes the default value to be visible again.  Trying to delete a "
"default value causes a ``KeyError``."
msgstr ""
"å…¨ã¦ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ ``DEFAULTSECT`` å€¤ã‚’æŒã¡ã€ã™ãªã‚ã¡ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ ``.clear()`` "
"ã—ã¦ã‚‚ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯è¦‹ãŸç›®ä¸Šç©ºã«ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ (æŠ€è¡“çš„ã«ã¯ãã“ã«ãªã„ã®ã§) "
"ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰å‰Šé™¤ã§ããªã„ãŸã‚ã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒä¸Šæ›¸ãã•ã‚ŒãŸå ´åˆã€ãã‚ŒãŒå‰Šé™¤ã•ã‚Œã‚‹ã¨ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒå†ã³è¦‹ãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’å‰Šé™¤ã—ã‚ˆã†ã¨ã™ã‚‹ã¨"
" ``KeyError`` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:402
msgid "``DEFAULTSECT`` cannot be removed from the parser:"
msgstr "``DEFAULTSECT`` ã¯ãƒ‘ãƒ¼ã‚µãƒ¼ã‹ã‚‰å–ã‚Šé™¤ã‘ã¾ã›ã‚“:"

#: ../../library/configparser.rst:404
msgid "trying to delete it raises ``ValueError``,"
msgstr "å‰Šé™¤ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ ``ValueError`` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:406
msgid "``parser.clear()`` leaves it intact,"
msgstr "``parser.clear()`` ã¯ã“ã‚Œã‚’ãã®ã¾ã¾æ®‹ã—ã€"

#: ../../library/configparser.rst:408
msgid "``parser.popitem()`` never returns it."
msgstr "``parser.popitem()`` ãŒã“ã‚Œã‚’è¿”ã™ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/configparser.rst:410
msgid ""
"``parser.get(section, option, **kwargs)`` - the second argument is **not** a"
" fallback value.  Note however that the section-level ``get()`` methods are "
"compatible both with the mapping protocol and the classic configparser API."
msgstr ""
"``parser.get(section, option, **kwargs)`` - ç¬¬äºŒå¼•æ•°ã¯ä»£æ›¿å€¤ã§ã¯ *ã‚ã‚Šã¾ã›ã‚“*ã€‚ãŸã ã—ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã”ã¨ã® "
"``get()`` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒãƒƒãƒ—å‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨æ—§å¼ã® configparser API ã®ä¸¡æ–¹ã«äº’æ›ã§ã™ã€‚"

#: ../../library/configparser.rst:414
msgid ""
"``parser.items()`` is compatible with the mapping protocol (returns a list "
"of *section_name*, *section_proxy* pairs including the DEFAULTSECT).  "
"However, this method can also be invoked with arguments: "
"``parser.items(section, raw, vars)``.  The latter call returns a list of "
"*option*, *value* pairs for a specified ``section``, with all interpolations"
" expanded (unless ``raw=True`` is provided)."
msgstr ""
"``parser.items()`` ã¯ãƒãƒƒãƒ—å‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨äº’æ›ã§ã™ (DEFAULTSECT ã‚’å«ã‚€ *section_name*, "
"*section_proxy* å¯¾ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™)ã€‚ãŸã ã—ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ ``parser.items(section, raw, vars)``"
" ã®ã‚ˆã†ã«ã—ã¦å¼•æ•°ã‚’ä¸ãˆã‚‹ã“ã¨ã§ã‚‚å‘¼ã³å‡ºã›ã¾ã™ã€‚å¾Œè€…ã®å‘¼ã³å‡ºã—ã¯æŒ‡å®šã•ã‚ŒãŸ ``section`` ã®  *option*, *value* "
"å¯¾ã®ãƒªã‚¹ãƒˆã‚’ã€(``raw=True`` ãŒä¸ãˆã‚‰ã‚Œãªã„é™ã‚Š) å…¨ã¦ã®è£œé–“ã‚’å±•é–‹ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:421
msgid ""
"The mapping protocol is implemented on top of the existing legacy API so "
"that subclasses overriding the original interface still should have mappings"
" working as expected."
msgstr ""
"ãƒãƒƒãƒ—å‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ã€æ—¢å­˜ã®ãƒ¬ã‚¬ã‚·ãƒ¼ãª API "
"ã®ä¸Šã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä¸Šæ›¸ãã™ã‚‹æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã‚‚ã¾ãŸã¯æœŸå¾…ã©ãŠã‚Šã«ã¯ãŸã‚‰ãã¾ã™ã€‚"

#: ../../library/configparser.rst:427
msgid "Customizing Parser Behaviour"
msgstr "ãƒ‘ãƒ¼ã‚µãƒ¼ã®æŒ¯ã‚‹èˆã„ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹"

#: ../../library/configparser.rst:429
msgid ""
"There are nearly as many INI format variants as there are applications using"
" it. :mod:`configparser` goes a long way to provide support for the largest "
"sensible set of INI styles available.  The default functionality is mainly "
"dictated by historical background and it's very likely that you will want to"
" customize some of the features."
msgstr ""
"INI ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®å¤‰ç¨®ã¯ã€ãã‚Œã‚’ä½¿ã†ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®æ•°ã¨åŒã˜ãã‚‰ã„å¤šãå­˜åœ¨ã—ã¾ã™ã€‚ :mod:`configparser` "
"ã¯ã€å¯èƒ½ãªé™ã‚Šåºƒã„ç¯„å›²ã® INI "
"ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é›†ã‚ãŸé›†åˆã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ã€éå¸¸ã«å½¹ç«‹ã¡ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ©Ÿèƒ½ã¯ä¸»ã«æ­´å²çš„èƒŒæ™¯ã«ã‚ˆã£ã¦æ±ºã‚ã‚‰ã‚ŒãŸã®ã§ã€æ©Ÿèƒ½ã«ã‚ˆã£ã¦ã¯ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ã¦ãŠä½¿ã„ãã ã•ã„ã€‚"

#: ../../library/configparser.rst:435
msgid ""
"The most common way to change the way a specific config parser works is to "
"use the :meth:`__init__` options:"
msgstr "ç‰¹å®šã®è¨­å®šãƒ‘ãƒ¼ã‚µãƒ¼ã®ã¯ãŸã‚‰ãã‚’å¤‰ãˆã‚‹æœ€ã‚‚ä¸€èˆ¬çš„ãªæ–¹æ³•ã¯ :meth:`__init__` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ä½¿ã†ã“ã¨ã§ã™:"

#: ../../library/configparser.rst:438
msgid "*defaults*, default value: ``None``"
msgstr "*defaults*, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: ``None``"

#: ../../library/configparser.rst:440
msgid ""
"This option accepts a dictionary of key-value pairs which will be initially "
"put in the ``DEFAULT`` section.  This makes for an elegant way to support "
"concise configuration files that don't specify values which are the same as "
"the documented default."
msgstr "ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯æœ€åˆã« ``DEFAULT`` ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«åŠ ãˆã‚‰ã‚Œã‚‹ã‚­ãƒ¼-å€¤ã®å¯¾ã®è¾æ›¸ã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚"

#: ../../library/configparser.rst:445
msgid ""
"Hint: if you want to specify default values for a specific section, use "
":meth:`read_dict` before you read the actual file."
msgstr ""
"ãƒ’ãƒ³ãƒˆ: ç‰¹å®šã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒ‡å®šã—ãŸã„ãªã‚‰ã€å®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€å‰ã« :meth:`read_dict` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/configparser.rst:448
msgid "*dict_type*, default value: :class:`collections.OrderedDict`"
msgstr "*dict_type*, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: :class:`collections.OrderedDict`"

#: ../../library/configparser.rst:450
msgid ""
"This option has a major impact on how the mapping protocol will behave and "
"how the written configuration files look.  With the default ordered "
"dictionary, every section is stored in the order they were added to the "
"parser.  Same goes for options within sections."
msgstr ""
"ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ãƒãƒƒãƒ—å‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®æŒ¯ã‚‹èˆã„æ–¹ã‚„æ›¸ãè¾¼ã¾ã‚Œã‚‹è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®è¦‹ãŸç›®ã«å¤§ããå½±éŸ¿ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®é †åºä»˜ãè¾æ›¸ã§ã¯ã€å…¨ã¦ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ãƒ‘ãƒ¼ã‚µãƒ¼ã«åŠ ãˆã‚‰ã‚ŒãŸé †ã«ä¸¦ã³ã¾ã™ã€‚åŒã˜ã“ã¨ãŒã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«ã‚‚è¨€ãˆã¾ã™ã€‚"

#: ../../library/configparser.rst:455
msgid ""
"An alternative dictionary type can be used for example to sort sections and "
"options on write-back.  You can also use a regular dictionary for "
"performance reasons."
msgstr ""
"ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ãƒ©ã‚¤ãƒˆãƒãƒƒã‚¯æ™‚ã«ã‚½ãƒ¼ãƒˆã™ã‚‹ãŸã‚ãªã©ã«ã€åˆ¥ã®è¾æ›¸å‹ã‚‚ä½¿ãˆã¾ã™ã€‚ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ç†ç”±ã®ãŸã‚ã«æ™®é€šã®è¾æ›¸ã‚’ä½¿ã†ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../library/configparser.rst:459
msgid ""
"Please note: there are ways to add a set of key-value pairs in a single "
"operation.  When you use a regular dictionary in those operations, the order"
" of the keys may be random.  For example:"
msgstr ""
"æ³¨æ„: ä¸€åº¦ã®æ“ä½œã§ã‚­ãƒ¼-å€¤ã®å¯¾ã‚’è¤‡æ•°è¿½åŠ ã™ã‚‹æ–¹æ³•ã‚‚ã‚ã‚Šã¾ã™ã€‚ãã®ã‚ˆã†ãªæ“ä½œã«æ™®é€šã®è¾æ›¸ã‚’ä½¿ã†ã¨ã€ã‚­ãƒ¼ã®ä¸¦ã³é †ã¯ãƒ©ãƒ³ãƒ€ãƒ ã«ãªã‚Šã¾ã™ã€‚ä¾‹ãˆã°:"

#: ../../library/configparser.rst:481
msgid "In these operations you need to use an ordered dictionary as well:"
msgstr "ã“ã®ã‚ˆã†ãªæ“ä½œã«ã¯ã€é †åºä»˜ãè¾æ›¸ã‚’ä½¿ç”¨ã™ã‚‹æ–¹ãŒã‚ˆã„ã§ã™:"

#: ../../library/configparser.rst:512
msgid "*allow_no_value*, default value: ``False``"
msgstr "*allow_no_value*, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: ``False``"

#: ../../library/configparser.rst:514
msgid ""
"Some configuration files are known to include settings without values, but "
"which otherwise conform to the syntax supported by :mod:`configparser`.  The"
" *allow_no_value* parameter to the constructor can be used to indicate that "
"such values should be accepted:"
msgstr ""
"ä¸€éƒ¨ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯å€¤ã®ãªã„è¨­å®šé …ç›®ãŒã‚ã‚Šã¾ã™ãŒã€ãã‚Œä»¥å¤–ã¯ :mod:`ConfigParser` ãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹æ–‡æ³•ã«å¾“ã„ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã® "
"*allow_no_value* å¼•æ•°ã§ã€ãã®ã‚ˆã†ãªå€¤ã‚’è¨±å¯ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/configparser.rst:549
msgid "*delimiters*, default value: ``('=', ':')``"
msgstr "*delimiters*, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: ``('=', ':')``"

#: ../../library/configparser.rst:551
msgid ""
"Delimiters are substrings that delimit keys from values within a section. "
"The first occurrence of a delimiting substring on a line is considered a "
"delimiter.  This means values (but not keys) can contain the delimiters."
msgstr ""
"ãƒ‡ãƒªãƒŸã‚¿ã¯ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…ã§ã‚­ãƒ¼ã‚’å€¤ã‹ã‚‰åŒºåˆ‡ã‚‹éƒ¨åˆ†æ–‡å­—åˆ—ã§ã™ã€‚è¡Œä¸­ã§æœ€åˆã«ç¾ã‚ŒãŸåŒºåˆ‡ã‚Šéƒ¨åˆ†æ–‡å­—åˆ—ãŒãƒ‡ãƒªãƒŸã‚¿ã¨è¦‹ãªã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šå€¤ã«ã¯ãƒ‡ãƒªãƒŸã‚¿ã‚’å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™"
" (ã‚­ãƒ¼ã«ã¯å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“)ã€‚"

#: ../../library/configparser.rst:555
msgid ""
"See also the *space_around_delimiters* argument to "
":meth:`ConfigParser.write`."
msgstr ":meth:`ConfigParser.write` ã® *space_around_delimiters* å¼•æ•°ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/configparser.rst:558
msgid "*comment_prefixes*, default value: ``('#', ';')``"
msgstr "*comment_prefixes*, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: ``('#', ';')``"

#: ../../library/configparser.rst:560
msgid "*inline_comment_prefixes*, default value: ``None``"
msgstr "*inline_comment_prefixes*, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: ``None``"

#: ../../library/configparser.rst:562
msgid ""
"Comment prefixes are strings that indicate the start of a valid comment "
"within a config file. *comment_prefixes* are used only on otherwise empty "
"lines (optionally indented) whereas *inline_comment_prefixes* can be used "
"after every valid value (e.g. section names, options and empty lines as "
"well).  By default inline comments are disabled and ``'#'`` and ``';'`` are "
"used as prefixes for whole line comments."
msgstr ""
"ã‚³ãƒ¡ãƒ³ãƒˆæ¥é ­è¾ã¯è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä¸­ã§æœ‰åŠ¹ãªã‚³ãƒ¡ãƒ³ãƒˆã®é–‹å§‹ã‚’ç¤ºã™æ–‡å­—åˆ—ã§ã™ã€‚*comment_prefixes* ã¯ä»–ã®å†…å®¹ãŒãªã„è¡Œ (ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã¯è‡ªç”±) "
"ã«ã®ã¿ä½¿ç”¨ã§ãã€*inline_comment_prefixes* ã¯ä»»æ„ã®æœ‰åŠ¹ãªå€¤ (ä¾‹ãˆã°ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³åã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€ç©ºè¡Œã‚‚å¯èƒ½) "
"ã®å¾Œã«ä½¿ãˆã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚³ãƒ¡ãƒ³ãƒˆã¯ç„¡åŠ¹åŒ–ã•ã‚Œã¦ã„ã¦ã€``'#'`` ã¨ ``';'`` ã‚’è¡Œå…¨ä½“ã®ã‚³ãƒ¡ãƒ³ãƒˆã«ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:569
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``comment_prefixes=('#',';')`` and ``inline_comment_prefixes=(';',)``."
msgstr ""
"ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® :mod:`configparser` ã®æŒ¯ã‚‹èˆã„ã¯ ``comment_prefixes=('#',';')`` ãŠã‚ˆã³ "
"``inline_comment_prefixes=(';',)`` ã«è©²å½“ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:573
msgid ""
"Please note that config parsers don't support escaping of comment prefixes "
"so using *inline_comment_prefixes* may prevent users from specifying option "
"values with characters used as comment prefixes.  When in doubt, avoid "
"setting *inline_comment_prefixes*.  In any circumstances, the only way of "
"storing comment prefix characters at the beginning of a line in multiline "
"values is to interpolate the prefix, for example::"
msgstr ""
"è¨­å®šãƒ‘ãƒ¼ã‚µãƒ¼ã¯ã‚³ãƒ¡ãƒ³ãƒˆæ¥é ­è¾ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚’ã‚µãƒãƒ¼ãƒˆã—ãªã„ã®ã§ã€*inline_comment_prefixes* "
"ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚³ãƒ¡ãƒ³ãƒˆæ¥é ­è¾ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹æ–‡å­—ã‚’å«ã‚€ã‚ªãƒ—ã‚·ãƒ§ãƒ³å€¤ã‚’æŒ‡å®šã™ã‚‹ã®ã‚’å¦¨ã’ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ç–‘ã‚ã—ã„å ´åˆã«ã¯ã€*inline_comment_prefixes*"
" "
"ã‚’è¨­å®šã—ãªã„ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚ã©ã®ã‚ˆã†ãªçŠ¶æ³ã§ã‚‚ã€è¤‡æ•°è¡Œã«ã‚ãŸã‚‹å€¤ã§ã€è¡Œã®å…ˆé ­ã«ã‚³ãƒ¡ãƒ³ãƒˆæ¥é ­è¾æ–‡å­—ã‚’ä¿å­˜ã™ã‚‹å”¯ä¸€ã®æ–¹æ³•ã¯ã€æ¬¡ã®ä¾‹ã®ã‚ˆã†ã«æ¥é ­è¾ã‚’è£œé–“ã™ã‚‹ã“ã¨ã§ã™::"

#: ../../library/configparser.rst:619
msgid "*strict*, default value: ``True``"
msgstr "*strict*, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: ``True``"

#: ../../library/configparser.rst:621
msgid ""
"When set to ``True``, the parser will not allow for any section or option "
"duplicates while reading from a single source (using :meth:`read_file`, "
":meth:`read_string` or :meth:`read_dict`).  It is recommended to use strict "
"parsers in new applications."
msgstr ""
"``True`` ã«è¨­å®šã•ã‚ŒãŸå ´åˆã€ãƒ‘ãƒ¼ã‚µãƒ¼ã¯å˜ä¸€ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰ (:meth:`read_file`, :meth:`read_string` ã¾ãŸã¯ "
":meth:`read_dict` ã‚’ä½¿ã£ã¦) èª­ã¿è¾¼ã‚€ã¨ãã«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚„ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®é‡è¤‡ã‚’è¨±ã•ãªããªã‚Šã¾ã™ã€‚æ–°ã—ã„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ã¯ strict "
"ãªãƒ‘ãƒ¼ã‚µãƒ¼ã‚’ä½¿ã†ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:626
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``strict=False``."
msgstr "ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® :mod:`configparser` ã®æŒ¯ã‚‹èˆã„ã¯ ``strict=False`` ã«è©²å½“ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:630
msgid "*empty_lines_in_values*, default value: ``True``"
msgstr "*empty_lines_in_values*, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: ``True``"

#: ../../library/configparser.rst:632
msgid ""
"In config parsers, values can span multiple lines as long as they are "
"indented more than the key that holds them.  By default parsers also let "
"empty lines to be parts of values.  At the same time, keys can be "
"arbitrarily indented themselves to improve readability.  In consequence, "
"when configuration files get big and complex, it is easy for the user to "
"lose track of the file structure.  Take for instance:"
msgstr ""
"è¨­å®šãƒ‘ãƒ¼ã‚µãƒ¼ã§ã¯ã€ã‚­ãƒ¼ã‚ˆã‚Šã‚‚ãã®å€¤ã‚’æ·±ãã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã™ã‚‹ã‹ãã‚Šã€è¤‡æ•°è¡Œã«ã¾ãŸãŒã‚‹å€¤ã‚’ä½¿ãˆã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ‘ãƒ¼ã‚µãƒ¼ã¯ã•ã‚‰ã«ãã®å€¤ã®é–“ã«ç©ºè¡Œã‚’ç½®ã‘ã¾ã™ã€‚åŒæ™‚ã«ã€ã‚­ãƒ¼ã¯èª­ã¿ã‚„ã™ãã™ã‚‹ãŸã‚ä»»æ„ã«ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã§ãã¾ã™ã€‚çµæœã¨ã—ã¦ã€è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒå¤§ããè¤‡é›‘ã«ãªã£ãŸã¨ãã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ ã‚’è¦‹å¤±ã„ã‚„ã™ã„ã§ã™ã€‚ã“ã®ä¾‹ã‚’ã”è¦§ãã ã•ã„:"

#: ../../library/configparser.rst:647
msgid ""
"This can be especially problematic for the user to see if she's using a "
"proportional font to edit the file.  That is why when your application does "
"not need values with empty lines, you should consider disallowing them.  "
"This will make empty lines split keys every time.  In the example above, it "
"would produce two keys, ``key`` and ``this``."
msgstr ""
"ã“ã‚Œã¯ç‰¹ã«ãƒ—ãƒ­ãƒãƒ¼ã‚·ãƒ§ãƒŠãƒ«ãƒ•ã‚©ãƒ³ãƒˆã‚’ä½¿ã£ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç·¨é›†ã—ã¦ã„ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¨ã£ã¦å•é¡Œã«ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã ã‹ã‚‰ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å€¤ã«ç©ºè¡ŒãŒå¿…è¦ãªã„ãªã‚‰ã€ç©ºè¡Œã‚’èªã‚ãªã„ã¹ãã§ã™ã€‚ã“ã‚Œã«ã‚ˆã£ã¦ç©ºè¡Œã§å¿…ãšã‚­ãƒ¼ãŒåˆ†ã‹ã‚Œã¾ã™ã€‚ä¸Šã®ä¾‹ã§ã¯ã€2"
" ã¤ã®ã‚­ãƒ¼ã€``key`` ãŠã‚ˆã³ ``this`` ãŒä½œã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:653
msgid ""
"*default_section*, default value: ``configparser.DEFAULTSECT`` (that is: "
"``\"DEFAULT\"``)"
msgstr ""
"*default_section*, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: ``configparser.DEFAULTSECT`` (ã™ãªã‚ã¡: "
"``\"DEFAULT\"``)"

#: ../../library/configparser.rst:656
msgid ""
"The convention of allowing a special section of default values for other "
"sections or interpolation purposes is a powerful concept of this library, "
"letting users create complex declarative configurations.  This section is "
"normally called ``\"DEFAULT\"`` but this can be customized to point to any "
"other valid section name.  Some typical values include: ``\"general\"`` or "
"``\"common\"``.  The name provided is used for recognizing default sections "
"when reading from any source and is used when writing configuration back to "
"a file.  Its current value can be retrieved using the "
"``parser_instance.default_section`` attribute and may be modified at runtime"
" (i.e. to convert files from one format to another)."
msgstr ""
"ä»–ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚„è£œé–“ç›®çš„ã§ã®ç‰¹åˆ¥ãªã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’èªã‚ã‚‹æ…£è¡Œã¯ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æ˜ç¢ºãªã‚³ãƒ³ã‚»ãƒ—ãƒˆã®ä¸€ã¤ã§ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è¤‡é›‘ã§å®£è¨€çš„ãªè¨­å®šã‚’ä½œæˆã§ãã¾ã™ã€‚ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯é€šå¸¸"
" ``\"DEFAULT\"`` ã¨å‘¼ã°ã‚Œã¾ã™ãŒã€ä»»æ„ã®æœ‰åŠ¹ãªã‚»ã‚¯ã‚·ãƒ§ãƒ³åã‚’æŒ‡ã™ã‚ˆã†ã«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚å…¸å‹çš„ãªå€¤ã«ã¯ "
"``\"general\"`` ã‚„ ``\"common\"`` "
"ãŒã‚ã‚Šã¾ã™ã€‚ä¸ãˆã‚‰ã‚ŒãŸåå‰ã¯ã‚½ãƒ¼ã‚¹ã‚’èª­ã¿è¾¼ã‚€éš›ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’èªè­˜ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã€è¨­å®šã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãæˆ»ã™ã¨ãã«ã‚‚ä½¿ã‚ã‚Œã¾ã™ã€‚ç¾åœ¨ã®å€¤ã¯ "
"``parser_instance.default_section`` å±æ€§ã‹ã‚‰å–ã‚Šå‡ºã™ã“ã¨ãŒã§ãã€å®Ÿè¡Œæ™‚ "
"(ã™ãªã‚ã¡ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ¥ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å¤‰æ›ã™ã‚‹ã¨ã) ã«å¤‰æ›´ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../library/configparser.rst:667
msgid "*interpolation*, default value: ``configparser.BasicInterpolation``"
msgstr "*interpolation*, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: ``configparser.BasicInterpolation``"

#: ../../library/configparser.rst:669
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_. "
":class:`RawConfigParser` has a default value of ``None``."
msgstr ""
"è£œé–“ã®æŒ¯ã‚‹èˆã„ã¯ã€ *interpolation* å¼•æ•°ã‚’é€šã—ã¦ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ³ãƒ‰ãƒ©ã‚’ä¸ãˆã‚‹ã“ã¨ã§ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚ ``None`` "
"å¼•æ•°ã‚’ä½¿ã†ã¨è£œé–“ã‚’å®Œå…¨ã«ç„¡åŠ¹ã«ã§ãã¾ã™ã€‚ ``ExtendedInterpolation()`` ã¯ã€ ``zc.buildout`` "
"ã«å½±éŸ¿ã‚’å—ã‘ãŸã‚ˆã‚Šé«˜åº¦ãªè£œé–“ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã®è©±é¡Œã« `ç‰¹åŒ–ã—ãŸãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ <#interpolation-of-values>`_ "
"ã‚’ã”è¦§ãã ã•ã„ã€‚ :class:`RawConfigParser` ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ ``None`` ã§ã™ã€‚"

#: ../../library/configparser.rst:676
msgid "*converters*, default value: not set"
msgstr "*converters*, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: æœªè¨­å®š"

#: ../../library/configparser.rst:678
msgid ""
"Config parsers provide option value getters that perform type conversion.  "
"By default :meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat`, and"
" :meth:`~ConfigParser.getboolean` are implemented.  Should other getters be "
"desirable, users may define them in a subclass or pass a dictionary where "
"each key is a name of the converter and each value is a callable "
"implementing said conversion.  For instance, passing ``{'decimal': "
"decimal.Decimal}`` would add :meth:`getdecimal` on both the parser object "
"and all section proxies.  In other words, it will be possible to write both "
"``parser_instance.getdecimal('section', 'key', fallback=0)`` and "
"``parser_instance['section'].getdecimal('key', 0)``."
msgstr ""
"è¨­å®šãƒ‘ãƒ¼ã‚µãƒ¼ã¯ã€å‹å¤‰æ›ã‚’å®Ÿè¡Œã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å€¤ã‚²ãƒƒã‚¿ãƒ¼ã‚’æä¾›ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ :meth:`~ConfigParser.getint`ã€ "
":meth:`~ConfigParser.getfloat`ã€ :meth:`~ConfigParser.getboolean` "
"ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚ä»–ã®ã‚²ãƒƒã‚¿ãƒ¼ãŒå¿…è¦ãªå ´åˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ãã‚Œã‚‰ã‚’ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®šç¾©ã™ã‚‹ã‹ã€è¾æ›¸ã‚’æ¸¡ã—ã¾ã™ã€‚è¾æ›¸ã‚’æ¸¡ã™å ´åˆã€å„ã‚­ãƒ¼ã¯ã‚³ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã®åå‰ã§ã€å€¤ã¯å½“è©²å¤‰æ›ã‚’å®Ÿè£…ã™ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ä¾‹ãˆã°ã€"
" ``{'decimal': decimal.Decimal}`` ã‚’æ¸¡ã™ã¨ã€ãƒ‘ãƒ¼ã‚µãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã™ã¹ã¦ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ­ã‚­ã‚·ã®ä¸¡æ–¹ã«ã€ "
":meth:`getdecimal` ãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šã€``parser_instance.getdecimal('section', "
"'key', fallback=0)`` ã¨ ``parser_instance['section'].getdecimal('key', 0)`` "
"ã®ä¸¡æ–¹ã®æ–¹æ³•ã§æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/configparser.rst:689
msgid ""
"If the converter needs to access the state of the parser, it can be "
"implemented as a method on a config parser subclass.  If the name of this "
"method starts with ``get``, it will be available on all section proxies, in "
"the dict-compatible form (see the ``getdecimal()`` example above)."
msgstr ""
"ã‚³ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ãŒãƒ‘ãƒ¼ã‚µãƒ¼ã®çŠ¶æ…‹ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã€è¨­å®šãƒ‘ãƒ¼ã‚µãƒ¼ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®åå‰ãŒ "
"``get`` ã‹ã‚‰å§‹ã¾ã‚‹å ´åˆã€ã™ã¹ã¦ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ­ã‚­ã‚·ã§ã€è¾æ›¸ã¨äº’æ›æ€§ã®ã‚ã‚‹å½¢å¼ã§åˆ©ç”¨ã§ãã¾ã™ (ä¸Šè¨˜ã® ``getdecimal()``  "
"ã®ä¾‹ã‚’å‚ç…§)ã€‚"

#: ../../library/configparser.rst:694
msgid ""
"More advanced customization may be achieved by overriding default values of "
"these parser attributes.  The defaults are defined on the classes, so they "
"may be overridden by subclasses or by attribute assignment."
msgstr ""
"ã“ã‚Œã‚‰ã®ãƒ‘ãƒ¼ã‚µãƒ¼å¼•æ•°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä¸Šæ›¸ãã™ã‚Œã°ã€ã•ã‚‰ã«é€²ã‚“ã ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒã§ãã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã‚¯ãƒ©ã‚¹ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã‚„å±æ€§ã®ä»£å…¥ã§ä¸Šæ›¸ãã§ãã¾ã™ã€‚"

#: ../../library/configparser.rst:700
msgid ""
"By default when using :meth:`~ConfigParser.getboolean`, config parsers "
"consider the following values ``True``: ``'1'``, ``'yes'``, ``'true'``, "
"``'on'`` and the following values ``False``: ``'0'``, ``'no'``, ``'false'``,"
" ``'off'``.  You can override this by specifying a custom dictionary of "
"strings and their Boolean outcomes. For example:"
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ :meth:`~ConfigParser.getboolean` ã‚’ä½¿ã†ã“ã¨ã§ã€è¨­å®šãƒ‘ãƒ¼ã‚µãƒ¼ã¯ä»¥ä¸‹ã®å€¤ã‚’ ``True`` "
"ã¨è¦‹ãªã—ã¾ã™: ``'1'``, ``'yes'``, ``'true'``, ``'on'`` ã€‚ä»¥ä¸‹ã®å€¤ã‚’ ``False`` ã¨è¦‹ãªã—ã¾ã™: "
"``'0'``, ``'no'``, ``'false'``, ``'off'`` "
"ã€‚æ–‡å­—åˆ—ã¨å¯¾å¿œã™ã‚‹ãƒ–ãƒ¼ãƒ«å€¤ã®ã‚«ã‚¹ã‚¿ãƒ è¾æ›¸ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ã“ã‚Œã‚’ä¸Šæ›¸ãã§ãã¾ã™ã€‚ãŸã¨ãˆã°:"

#: ../../library/configparser.rst:718
msgid ""
"Other typical Boolean pairs include ``accept``/``reject`` or "
"``enabled``/``disabled``."
msgstr ""
"ã»ã‹ã®å…¸å‹çš„ãªãƒ–ãƒ¼ãƒ«å€¤ãƒšã‚¢ã«ã¯ ``accept``/``reject`` ã‚„ ``enabled``/``disabled`` ãªã©ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/configparser.rst:723
msgid ""
"This method transforms option names on every read, get, or set operation.  "
"The default converts the name to lowercase.  This also means that when a "
"configuration file gets written, all keys will be lowercase.  Override this "
"method if that's unsuitable. For example:"
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯èª­ã¿è¾¼ã¿ã€å–å¾—ã€è¨­å®šæ“ä½œã®ãŸã³ã«ã‚ªãƒ—ã‚·ãƒ§ãƒ³åã‚’å¤‰æ›ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯åå‰ã‚’å°æ–‡å­—ã«å¤‰æ›ã—ã¾ã™ã€‚å¾“ã£ã¦è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒæ›¸ãè¾¼ã¾ã‚Œã‚‹ã¨ãã€ã™ã¹ã¦ã®ã‚­ãƒ¼ã¯å°æ–‡å­—ã«ãªã‚Šã¾ã™ã€‚ãã‚ŒãŒãµã•ã‚ã—ããªã‘ã‚Œã°ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¸Šæ›¸ãã—ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°:"

#: ../../library/configparser.rst:754
msgid ""
"A compiled regular expression used to parse section headers.  The default "
"matches ``[section]`` to the name ``\"section\"``.  Whitespace is considered"
" part of the section name, thus ``[  larch  ]`` will be read as a section of"
" name ``\"  larch  \"``.  Override this attribute if that's unsuitable.  For"
" example:"
msgstr ""
"ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãƒ˜ãƒƒãƒ€ã‚’è§£æã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸæ­£è¦è¡¨ç¾ã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``[section]`` ãŒ ``\"section\"`` "
"ã¨ã„ã†åå‰ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ç©ºç™½ã¯ã‚»ã‚¯ã‚·ãƒ§ãƒ³åã®ä¸€éƒ¨ã¨è¦‹ãªã•ã‚Œã‚‹ã®ã§ã€``[  larch  ]`` ã¯ ``\"  larch  \"`` "
"ã¨ã„ã†åã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨ã—ã¦èª­ã¿è¾¼ã¾ã‚Œã¾ã™ã€‚ã“ã‚ŒãŒãµã•ã‚ã—ããªã„å ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¸Šæ›¸ãã—ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°:"

#: ../../library/configparser.rst:781
msgid ""
"While ConfigParser objects also use an ``OPTCRE`` attribute for recognizing "
"option lines, it's not recommended to override it because that would "
"interfere with constructor options *allow_no_value* and *delimiters*."
msgstr ""
"ConfigParser ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³è¡Œã®èªè­˜ã« ``OPTCRE`` "
"å±æ€§ã‚‚ä½¿ã„ã¾ã™ãŒã€ã“ã‚Œã‚’ä¸Šæ›¸ãã™ã‚‹ã“ã¨ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“ã€‚ä¸Šæ›¸ãã™ã‚‹ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚ªãƒ—ã‚·ãƒ§ãƒ³ *allow_no_value* ãŠã‚ˆã³ "
"*delimiters* ã«å¹²æ¸‰ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:787
msgid "Legacy API Examples"
msgstr "ãƒ¬ã‚¬ã‚·ãƒ¼ãª API ã®ä¾‹"

#: ../../library/configparser.rst:789
msgid ""
"Mainly because of backwards compatibility concerns, :mod:`configparser` "
"provides also a legacy API with explicit ``get``/``set`` methods.  While "
"there are valid use cases for the methods outlined below, mapping protocol "
"access is preferred for new projects.  The legacy API is at times more "
"advanced, low-level and downright counterintuitive."
msgstr ""
"ä¸»ã«å¾Œæ–¹äº’æ›æ€§å•é¡Œã®ç†ç”±ã‹ã‚‰ã€ :mod:`configparser` ã¯ ``get``/``set`` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ˜ç¤ºã™ã‚‹ãƒ¬ã‚¬ã‚·ãƒ¼ãª API "
"ã‚‚æä¾›ã—ã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä»¥ä¸‹ã«ç¤ºã™ã‚ˆã†ã«ä½¿ã†ã“ã¨ã‚‚ã§ãã¾ã™ãŒã€æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãƒãƒƒãƒ—å‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ãŒæœ›ã¾ã—ã„ã§ã™ã€‚ãƒ¬ã‚¬ã‚·ãƒ¼ãª API"
" ã¯æ™‚æŠ˜é«˜åº¦ã§ã€ä½ãƒ¬ãƒ™ãƒ«ã§ã€ã¾ã£ãŸãç›´æ„Ÿçš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/configparser.rst:795
msgid "An example of writing to a configuration file::"
msgstr "è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸ãå‡ºã™ä¾‹::"

#: ../../library/configparser.rst:818
msgid "An example of reading the configuration file again::"
msgstr "è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€ä¾‹::"

#: ../../library/configparser.rst:836
msgid "To get interpolation, use :class:`ConfigParser`::"
msgstr "è£œé–“ã™ã‚‹ã«ã¯ã€ :class:`ConfigParser` ã‚’ä½¿ã£ã¦ãã ã•ã„::"

#: ../../library/configparser.rst:869
msgid ""
"Default values are available in both types of ConfigParsers.  They are used "
"in interpolation if an option used is not defined elsewhere. ::"
msgstr ""
"ã©ã¡ã‚‰ã®å‹ã® ConfigParsers "
"ã§ã‚‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒåˆ©ç”¨ã§ãã¾ã™ã€‚ä½¿ã‚ã‚Œã¦ã„ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒã©ã“ã«ã‚‚å®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ãã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒè£œé–“ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ ::"

#: ../../library/configparser.rst:887
msgid "ConfigParser Objects"
msgstr "ConfigParser ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/configparser.rst:891
msgid ""
"The main configuration parser.  When *defaults* is given, it is initialized "
"into the dictionary of intrinsic defaults.  When *dict_type* is given, it "
"will be used to create the dictionary objects for the list of sections, for "
"the options within a section, and for the default values."
msgstr ""
"ä¸»è¦ãªè¨­å®šãƒ‘ãƒ¼ã‚µãƒ¼ã§ã™ã€‚*defaults* ãŒä¸ãˆã‚‰ã‚Œã‚Œã°ã€ãã®è¾æ›¸ã®æŒã¤åˆæœŸå€¤ã§åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚*dict_type* "
"ãŒä¸ãˆã‚‰ã‚Œã‚Œã°ã€ãã‚ŒãŒã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸€è¦§ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ä¸­ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€ãŠã‚ˆã³ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®è¾æ›¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:896
msgid ""
"When *delimiters* is given, it is used as the set of substrings that divide "
"keys from values.  When *comment_prefixes* is given, it will be used as the "
"set of substrings that prefix comments in otherwise empty lines. Comments "
"can be indented.  When *inline_comment_prefixes* is given, it will be used "
"as the set of substrings that prefix comments in non-empty lines."
msgstr ""
"*delimiters* ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ã‚­ãƒ¼ã¨å€¤ã‚’åˆ†å‰²ã™ã‚‹éƒ¨åˆ†æ–‡å­—åˆ—ã®çµ„ã¿åˆã‚ã›ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚*comment_prefixes* "
"ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ä»–ã®å†…å®¹ãŒãªã„è¡Œã®ã‚³ãƒ¡ãƒ³ãƒˆã«æ¥é ­ã™ã‚‹éƒ¨åˆ†æ–‡å­—åˆ—ã®çµ„ã¿åˆã‚ã›ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚ã‚³ãƒ¡ãƒ³ãƒˆã¯ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã§ãã¾ã™ã€‚*inline_comment_prefixes*"
" ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€éç©ºè¡Œã®ã‚³ãƒ¡ãƒ³ãƒˆã«æ¥é ­ã™ã‚‹éƒ¨åˆ†æ–‡å­—åˆ—ã¨ã—ã¦ã®çµ„ã¿åˆã‚ã›ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:902
msgid ""
"When *strict* is ``True`` (the default), the parser won't allow for any "
"section or option duplicates while reading from a single source (file, "
"string or dictionary), raising :exc:`DuplicateSectionError` or "
":exc:`DuplicateOptionError`.  When *empty_lines_in_values* is ``False`` "
"(default: ``True``), each empty line marks the end of an option.  Otherwise,"
" internal empty lines of a multiline option are kept as part of the value. "
"When *allow_no_value* is ``True`` (default: ``False``), options without "
"values are accepted; the value held for these is ``None`` and they are "
"serialized without the trailing delimiter."
msgstr ""
"*strict* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã§ã‚ã‚Œã°ã€ãƒ‘ãƒ¼ã‚µãƒ¼ã¯å˜ä¸€ã®ã‚½ãƒ¼ã‚¹ (ãƒ•ã‚¡ã‚¤ãƒ«ã€æ–‡å­—åˆ—ã€è¾æ›¸) "
"ä¸­ã«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚„ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®é‡è¤‡ã‚’èªã‚ãšã€ :exc:`DuplicateSectionError` ã‚„ "
":exc:`DuplicateOptionError` ã‚’é€å‡ºã—ã¾ã™ã€‚ *empty_lines_in_values* ãŒ ``False`` "
"(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ``True``) ãªã‚‰ã€ç©ºè¡Œã¯ãã‚Œãã‚Œã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®çµ‚ã‚ã‚Šã‚’ç¤ºã—ã¾ã™ã€‚ *allow_no_value* ãŒ ``True`` "
"(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ``False``) ãªã‚‰ã€å€¤ã®ãªã„ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒå—ã‘ä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚ãã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å€¤ã¯ ``None`` "
"ã¨ãªã‚Šã€å¾Œç«¯ã®ãƒ‡ãƒªãƒŸã‚¿ã‚’é™¤ã„ã¦ã‚·ãƒªã‚¢ãƒ«åŒ–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:912
msgid ""
"When *default_section* is given, it specifies the name for the special "
"section holding default values for other sections and interpolation purposes"
" (normally named ``\"DEFAULT\"``).  This value can be retrieved and changed "
"on runtime using the ``default_section`` instance attribute."
msgstr ""
"*default_section* "
"ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ä»–ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¸ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚„è£œé–“ã®ãŸã‚ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä¿æŒã™ã‚‹ç‰¹åˆ¥ãªã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®åå‰ã‚’æŒ‡å®šã—ã¾ã™ (é€šå¸¸ã¯ "
"``\"DEFAULT\"`` ã¨ã„ã†åå‰ã§ã™)ã€‚ã“ã®å€¤ã¯å®Ÿè¡Œæ™‚ã« ``default_section`` "
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å±æ€§ã‚’ä½¿ã£ã¦å–å¾—ã‚„å¤‰æ›´ãŒã§ãã¾ã™ã€‚"

#: ../../library/configparser.rst:917
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_."
msgstr ""
"è£œé–“ã®å‹•ä½œã¯ã€ *interpolation* å¼•æ•°ã‚’é€šã—ã¦ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ³ãƒ‰ãƒ©ã‚’ä¸ãˆã‚‹ã“ã¨ã§ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚ ``None`` "
"å¼•æ•°ã‚’ä½¿ã†ã¨è£œé–“ã‚’å®Œå…¨ã«ç„¡åŠ¹ã«ã§ãã¾ã™ã€‚ ``ExtendedInterpolation()`` ã¯ã€ ``zc.buildout`` "
"ã«å½±éŸ¿ã‚’å—ã‘ãŸã‚ˆã‚Šé«˜åº¦ãªè£œé–“ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã®ä»¶ã« `ç‰¹åŒ–ã—ãŸãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ <#interpolation-of-values>`_ "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/configparser.rst:923
msgid ""
"All option names used in interpolation will be passed through the "
":meth:`optionxform` method just like any other option name reference.  For "
"example, using the default implementation of :meth:`optionxform` (which "
"converts option names to lower case), the values ``foo %(bar)s`` and ``foo "
"%(BAR)s`` are equivalent."
msgstr ""
"è£œé–“ã«ä½¿ã‚ã‚Œã‚‹ã™ã¹ã¦ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³åã¯ã€ä»–ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³åå‚ç…§ã¨åŒæ§˜ã«ã€ :meth:`optionxform` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’é€šã—ã¦æ¸¡ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ "
":meth:`optionxform` ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè£…ã‚’ä½¿ã†ã¨ã€å€¤ ``foo %(bar)s`` ã¨ ``foo %(BAR)s`` "
"ã¯ç­‰ã—ããªã‚Šã¾ã™ã€‚"

#: ../../library/configparser.rst:929
msgid ""
"When *converters* is given, it should be a dictionary where each key "
"represents the name of a type converter and each value is a callable "
"implementing the conversion from string to the desired datatype.  Every "
"converter gets its own corresponding :meth:`get*()` method on the parser "
"object and section proxies."
msgstr ""
"*converters* "
"ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€å„ã‚­ãƒ¼ãŒå‹ã‚³ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã®åå‰ã‚’è¡¨ã—ã€å„å€¤ãŒæ–‡å­—åˆ—ã‹ã‚‰ç›®çš„ã®ãƒ‡ãƒ¼ã‚¿å‹ã¸ã®å¤‰æ›ã‚’å®Ÿè£…ã™ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚å„ã‚³ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã¯ã€è‡ªèº«ã®å¯¾å¿œã™ã‚‹"
" :meth:`get*()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒ‘ãƒ¼ã‚µãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ­ã‚­ã‚·ã§å–å¾—ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:935
msgid "The default *dict_type* is :class:`collections.OrderedDict`."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® *dict_type* ã¯ :class:`collections.OrderedDict` ã§ã™ã€‚"

#: ../../library/configparser.rst:938
msgid ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* and *interpolation* were added."
msgstr ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* ãŠã‚ˆã³ *interpolation* ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/configparser.rst:943
msgid "The *converters* argument was added."
msgstr "*converters* å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/configparser.rst:949
msgid "Return a dictionary containing the instance-wide defaults."
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å…¨ä½“ã§ä½¿ã‚ã‚Œã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®è¾æ›¸ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:954
msgid ""
"Return a list of the sections available; the *default section* is not "
"included in the list."
msgstr "åˆ©ç”¨ã§ãã‚‹ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚*default section* ã¯ãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/configparser.rst:960
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised.  The name of "
"the section must be a string; if not, :exc:`TypeError` is raised."
msgstr ""
"*section* ã¨ã„ã†åã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«è¿½åŠ ã—ã¾ã™ã€‚ä¸ãˆã‚‰ã‚ŒãŸåå‰ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³åãŒã™ã§ã«å­˜åœ¨ã—ãŸã‚‰ã€ "
":exc:`DuplicateSectionError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ *default section* åãŒæ¸¡ã•ã‚ŒãŸã‚‰ã€ "
":exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®åå‰ã¯æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ :exc:`TypeError` "
"ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:965
msgid "Non-string section names raise :exc:`TypeError`."
msgstr "æ–‡å­—åˆ—ã§ãªã„ã‚»ã‚¯ã‚·ãƒ§ãƒ³åã¯ :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:971
msgid ""
"Indicates whether the named *section* is present in the configuration. The "
"*default section* is not acknowledged."
msgstr "æŒ‡åã•ã‚ŒãŸ *section* ãŒè¨­å®šä¸­ã«å­˜åœ¨ã™ã‚‹ã‹ã‚’ç¤ºã—ã¾ã™ã€‚*default section* ã¯èªè­˜ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/configparser.rst:977
msgid "Return a list of options available in the specified *section*."
msgstr "æŒ‡å®šã•ã‚ŒãŸ *section* ä¸­ã§åˆ©ç”¨ã§ãã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:982
msgid ""
"If the given *section* exists, and contains the given *option*, return "
":const:`True`; otherwise return :const:`False`.  If the specified *section* "
"is :const:`None` or an empty string, DEFAULT is assumed."
msgstr ""
"ä¸ãˆã‚‰ã‚ŒãŸ *section* ãŒå­˜åœ¨ã—ã€ä¸ãˆã‚‰ã‚ŒãŸ *option* ã‚’å«ã‚€å ´åˆã€ :const:`True` ã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€ "
":const:`False` ã‚’è¿”ã—ã¾ã™ã€‚æŒ‡å®šã•ã‚ŒãŸ *section* ãŒ :const:`None` ã¾ãŸã¯ç©ºæ–‡å­—åˆ—ã®å ´åˆã€ DEFAULT "
"ãŒä»®å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:989
msgid ""
"Attempt to read and parse an iterable of filenames, returning a list of "
"filenames which were successfully parsed."
msgstr ""

#: ../../library/configparser.rst:992
msgid ""
"If *filenames* is a string or :term:`path-like object`, it is treated as a "
"single filename.  If a file named in *filenames* cannot be opened, that file"
" will be ignored.  This is designed so that you can specify an iterable of "
"potential configuration file locations (for example, the current directory, "
"the user's home directory, and some system-wide directory), and all existing"
" configuration files in the iterable will be read."
msgstr ""

#: ../../library/configparser.rst:1000
msgid ""
"If none of the named files exist, the :class:`ConfigParser` instance will "
"contain an empty dataset.  An application which requires initial values to "
"be loaded from a file should load the required file or files using "
":meth:`read_file` before calling :meth:`read` for any optional files::"
msgstr ""
"ã©ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚‚å­˜åœ¨ã—ãªã‹ã£ãŸå ´åˆã€ :class:`ConfigParser` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ "
"ç©ºã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’æŒã¡ã¾ã™ã€‚åˆæœŸå€¤ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’å…ˆã«èª­ã¿è¾¼ã‚“ã§ãŠãå¿…è¦ãŒã‚ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€ãŸã‚ã« "
":meth:`read` ã‚’å‘¼ã¶å‰ã« ã€ã¾ãš :meth:`read_file` ã‚’ç”¨ã„ã¦å¿…è¦ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„::"

#: ../../library/configparser.rst:1013
msgid ""
"The *encoding* parameter.  Previously, all files were read using the default"
" encoding for :func:`open`."
msgstr "*encoding* å¼•æ•°ã€‚ä»¥å‰ã¯ã€ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒ :func:`open` ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã£ã¦èª­ã¾ã‚Œã¦ã„ã¾ã—ãŸã€‚"

#: ../../library/configparser.rst:1017
msgid "The *filenames* parameter accepts a :term:`path-like object`."
msgstr "*filenames* å¼•æ•°ãŒ :term:`path-like object` ã‚’å—ã‘å…¥ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/configparser.rst:1023
msgid ""
"Read and parse configuration data from *f* which must be an iterable "
"yielding Unicode strings (for example files opened in text mode)."
msgstr ""
"è¨­å®šãƒ‡ãƒ¼ã‚¿ã‚’ *f* ã‹ã‚‰èª­ã¿è¾¼ã‚“ã§è§£æã—ã¾ã™ã€‚*f* ã¯ Unicode æ–‡å­—åˆ—ã‚’ yield ã™ã‚‹ã‚¤ãƒ†ãƒ©ãƒ–ãƒ« "
"(ä¾‹ãˆã°ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«) ã§ã™ã€‚"

#: ../../library/configparser.rst:1026
msgid ""
"Optional argument *source* specifies the name of the file being read.  If "
"not given and *f* has a :attr:`name` attribute, that is used for *source*; "
"the default is ``'<???>'``."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *source* ã¯èª­ã¿è¾¼ã¾ã‚Œã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚ä¸ãˆã‚‰ã‚Œãšã€ *f* ã« :attr:`name` å±æ€§ãŒã‚ã‚Œã°ã€ãã‚ŒãŒ "
"*source* ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``'<???>'`` ã§ã™ã€‚"

#: ../../library/configparser.rst:1030
msgid "Replaces :meth:`readfp`."
msgstr ":meth:`readfp` ã‚’ç½®ãæ›ãˆã¾ã™ã€‚"

#: ../../library/configparser.rst:1035
msgid "Parse configuration data from a string."
msgstr "è¨­å®šãƒ‡ãƒ¼ã‚¿ã‚’æ–‡å­—åˆ—ã‹ã‚‰è§£æã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:1037
msgid ""
"Optional argument *source* specifies a context-specific name of the string "
"passed.  If not given, ``'<string>'`` is used.  This should commonly be a "
"filesystem path or a URL."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *source* ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ãŠã‘ã‚‹æ¸¡ã•ã‚ŒãŸæ–‡å­—åˆ—ã®åå‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚ä¸ãˆã‚‰ã‚Œãªã‘ã‚Œã°ã€``'<string>'`` "
"ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ä¸€èˆ¬ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ãƒ‘ã‚¹ã‚„ URL ã«ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:1046
msgid ""
"Load configuration from any object that provides a dict-like ``items()`` "
"method.  Keys are section names, values are dictionaries with keys and "
"values that should be present in the section.  If the used dictionary type "
"preserves order, sections and their keys will be added in order. Values are "
"automatically converted to strings."
msgstr ""
"è¾æ›¸çš„ãª ``items()`` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã™ã‚‹ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰è¨­å®šã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚ã‚­ãƒ¼ã¯ã‚»ã‚¯ã‚·ãƒ§ãƒ³åã§ã€å€¤ã¯ãã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ç¾ã‚Œã‚‹ã‚­ãƒ¼ã¨å€¤ã‚’ã‚‚ã¤è¾æ›¸ã§ã™ã€‚ä½¿ã‚ã‚ŒãŸè¾æ›¸å‹ãŒé †åºã‚’ä¿å­˜ã™ã‚‹ãªã‚‰ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŠã‚ˆã³ãã®ã‚­ãƒ¼ã¯é †ã«åŠ ãˆã‚‰ã‚Œã¾ã™ã€‚å€¤ã¯è‡ªå‹•ã§æ–‡å­—åˆ—ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:1052
msgid ""
"Optional argument *source* specifies a context-specific name of the "
"dictionary passed.  If not given, ``<dict>`` is used."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *source* ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ãŠã‘ã‚‹æ¸¡ã•ã‚ŒãŸè¾æ›¸ã®åå‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚ä¸ãˆã‚‰ã‚Œãªã‘ã‚Œã°ã€``<dict>`` ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:1055
msgid "This method can be used to copy state between parsers."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ãƒ‘ãƒ¼ã‚µãƒ¼é–“ã§çŠ¶æ…‹ã‚’ã‚³ãƒ”ãƒ¼ã§ãã¾ã™ã€‚"

#: ../../library/configparser.rst:1062
msgid ""
"Get an *option* value for the named *section*.  If *vars* is provided, it "
"must be a dictionary.  The *option* is looked up in *vars* (if provided), "
"*section*, and in *DEFAULTSECT* in that order.  If the key is not found and "
"*fallback* is provided, it is used as a fallback value.  ``None`` can be "
"provided as a *fallback* value."
msgstr ""
"æŒ‡åã•ã‚ŒãŸ *section* ã® *option* ã®å€¤ã‚’å–å¾—ã—ã¾ã™ã€‚*vars* ãŒæä¾›ã•ã‚Œã‚‹ãªã‚‰ã€ãã‚Œã¯è¾æ›¸ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€(ä¸ãˆã‚‰ã‚ŒãŸãªã‚‰) "
"*vars*, *section*, *DEFAULTSECT* å†…ã‹ã‚‰ã“ã®é †ã§ *option* ãŒæ¢ç´¢ã•ã‚Œã¾ã™ã€‚*fallback* ã®å€¤ã¨ã—ã¦ "
"``None`` ã‚’ä¸ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:1068
msgid ""
"All the ``'%'`` interpolations are expanded in the return values, unless the"
" *raw* argument is true.  Values for interpolation keys are looked up in the"
" same manner as the option."
msgstr "*raw* ãŒçœŸã§ãªã„æ™‚ã«ã¯ã€å…¨ã¦ã® ``'%'`` ç½®æ›ã¯å±•é–‹ã•ã‚Œã¦ã‹ã‚‰è¿”ã•ã‚Œã¾ã™ã€‚ç½®æ›å¾Œã®å€¤ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨åŒã˜é †åºã§æ¢ã•ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:1072
msgid ""
"Arguments *raw*, *vars* and *fallback* are keyword only to protect users "
"from trying to use the third argument as the *fallback* fallback (especially"
" when using the mapping protocol)."
msgstr ""
"å¼•æ•° *raw*, *vars* ãŠã‚ˆã³ *fallback* ã¯ã€(ç‰¹ã«ãƒãƒƒãƒ”ãƒ³ã‚°ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã¨ãã«) ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç¬¬ 3 å¼•æ•°ã‚’ "
"*fallback* ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦ä½¿ãŠã†ã¨ã—ãªã„ã‚ˆã†ã«ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å°‚ç”¨ã¨ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/configparser.rst:1080
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to an integer.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸ *section* ä¸­ã® *option* ã‚’æ•´æ•°ã«å‹å¼·åˆ¶ã™ã‚‹è£œåŠ©ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ *raw*, *vars* ãŠã‚ˆã³ *fallback* "
"ã®èª¬æ˜ã¯ :meth:`get` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/configparser.rst:1087
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a floating point number.  See :meth:`get` for explanation of *raw*, "
"*vars* and *fallback*."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸ *section* ä¸­ã® *option* ã‚’æµ®å‹•å°æ•°ç‚¹æ•°ã«å‹å¼·åˆ¶ã™ã‚‹è£œåŠ©ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ *raw*, *vars* ãŠã‚ˆã³ "
"*fallback* ã®èª¬æ˜ã¯ :meth:`get` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/configparser.rst:1094
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a Boolean value.  Note that the accepted values for the option are "
"``'1'``, ``'yes'``, ``'true'``, and ``'on'``, which cause this method to "
"return ``True``, and ``'0'``, ``'no'``, ``'false'``, and ``'off'``, which "
"cause it to return ``False``.  These string values are checked in a case-"
"insensitive manner.  Any other value will cause it to raise "
":exc:`ValueError`.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸ *section* ä¸­ã® *option* ã‚’ãƒ–ãƒ¼ãƒ«å€¤ã«å‹å¼·åˆ¶ã™ã‚‹è£œåŠ©ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ãªãŠã€ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§å—ã‘ä»˜ã‘ã‚‰ã‚Œã‚‹å€¤ã¯ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒ "
"``True`` ã‚’è¿”ã™ ``'1'``, ``'yes'``, ``'true'``, ãŠã‚ˆã³ ``'on'``,ã¨ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒ "
"``False`` ã‚’è¿”ã™ ``'0'``, ``'no'``, ``'false'``, and ``'off'`` ã§ã™ã€‚ãã®ä»–ã®ã„ã‹ãªã‚‹å€¤ã‚‚ "
":exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚ *raw*, *vars* ãŠã‚ˆã³ *fallback* ã®èª¬æ˜ã¯ :meth:`get` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/configparser.rst:1107
msgid ""
"When *section* is not given, return a list of *section_name*, "
"*section_proxy* pairs, including DEFAULTSECT."
msgstr ""
"*section* ãŒä¸ãˆã‚‰ã‚Œãªã‘ã‚Œã°ã€DEFAULTSECT ã‚’å«ã‚ãŸ *section_name*, *section_proxy* "
"ã®å¯¾ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:1110
msgid ""
"Otherwise, return a list of *name*, *value* pairs for the options in the "
"given *section*.  Optional arguments have the same meaning as for the "
":meth:`get` method."
msgstr ""
"ä¸ãˆã‚‰ã‚Œã‚Œã°ã€ä¸ãˆã‚‰ã‚ŒãŸ *section* ä¸­ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *name*, *value* ã®å¯¾ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•°ã¯ "
":meth:`get` ãƒ¡ã‚½ãƒƒãƒ‰ã«ä¸ãˆã‚‹ã‚‚ã®ã¨åŒã˜æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/configparser.rst:1117
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  *option* and *value* must be "
"strings; if not, :exc:`TypeError` is raised."
msgstr ""
"ä¸ãˆã‚‰ã‚ŒãŸã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå­˜åœ¨ã™ã‚Œã°ã€ä¸ãˆã‚‰ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æŒ‡å®šã•ã‚ŒãŸå€¤ã«è¨­å®šã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° :exc:`NoSectionError` "
"ã‚’é€å‡ºã—ã¾ã™ã€‚ *option* ãŠã‚ˆã³ *value* ã¯æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã†ã§ãªã‘ã‚Œã° :exc:`TypeError` "
"ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:1124
msgid ""
"Write a representation of the configuration to the specified :term:`file "
"object`, which must be opened in text mode (accepting strings).  This "
"representation can be parsed by a future :meth:`read` call.  If "
"*space_around_delimiters* is true, delimiters between keys and values are "
"surrounded by spaces."
msgstr ""
"è¨­å®šã®è¡¨ç¾ã‚’æŒ‡å®šã•ã‚ŒãŸ :term:`file object` ã«æ›¸ãè¾¼ã¿ã¾ã™ã€‚ *fileobject* ã¯ (æ–‡å­—åˆ—ã‚’å—ã‘ä»˜ã‘ã‚‹) "
"ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§é–‹ã‹ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®è¡¨ç¾ã¯å¾Œã§ :meth:`read` ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ãƒ‘ãƒ¼ã‚¹ã§ãã¾ã™ã€‚ "
"*space_around_delimiters* ãŒçœŸãªã‚‰ã€ã‚­ãƒ¼ã¨å€¤ã®é–“ã®ãƒ‡ãƒªãƒŸã‚¿ã¯ã‚¹ãƒšãƒ¼ã‚¹ã§å›²ã¾ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:1133
msgid ""
"Remove the specified *option* from the specified *section*.  If the section "
"does not exist, raise :exc:`NoSectionError`.  If the option existed to be "
"removed, return :const:`True`; otherwise return :const:`False`."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸ *option* ã‚’æŒ‡å®šã•ã‚ŒãŸ *section* ã‹ã‚‰å‰Šé™¤ã—ã¾ã™ã€‚ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå­˜åœ¨ã—ãªã‘ã‚Œã°ã€ :exc:`NoSectionError`"
" ã‚’é€å‡ºã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒå­˜åœ¨ã—ã¦å‰Šé™¤ã•ã‚Œã‚Œã°ã€ :const:`True` ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° :const:`False` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:1141
msgid ""
"Remove the specified *section* from the configuration.  If the section in "
"fact existed, return ``True``.  Otherwise return ``False``."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸ *section* ã‚’è¨­å®šã‹ã‚‰å‰Šé™¤ã—ã¾ã™ã€‚ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå®Ÿéš›ã«å­˜åœ¨ã™ã‚Œã°ã€``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° ``False`` "
"ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:1147
msgid ""
"Transforms the option name *option* as found in an input file or as passed "
"in by client code to the form that should be used in the internal "
"structures.  The default implementation returns a lower-case version of "
"*option*; subclasses may override this or client code can set an attribute "
"of this name on instances to affect this behavior."
msgstr ""
"å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã«ç¾ã‚ŒãŸã€ã¾ãŸã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚³ãƒ¼ãƒ‰ã§æ¸¡ã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³å *option* ã‚’å†…éƒ¨æ§‹é€ ã§å®Ÿéš›ã«ä½¿ã‚ã‚Œã‚‹å½¢å¼ã«å¤‰æ›ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè£…ã§ã¯"
" *option* "
"ã®å°æ–‡å­—ç‰ˆã‚’è¿”ã—ã¾ã™ã€‚æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã§ã“ã‚Œã‚’ä¸Šæ›¸ãã™ã‚‹ã‹ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚³ãƒ¼ãƒ‰ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä¸Šã®ã“ã®åå‰ã®å±æ€§ã‚’è¨­å®šã—ã¦ã€ã“ã®å‹•ä½œã«å½±éŸ¿ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/configparser.rst:1153
msgid ""
"You don't need to subclass the parser to use this method, you can also set "
"it on an instance, to a function that takes a string argument and returns a "
"string.  Setting it to ``str``, for example, would make option names case "
"sensitive::"
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ãŸã‚ã«ãƒ‘ãƒ¼ã‚µãƒ¼ã‚’æ´¾ç”Ÿã‚¯ãƒ©ã‚¹åŒ–ã•ã›ã‚‹å¿…è¦ã¯ãªãã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä¸Šã§ã€ã“ã‚Œã‚’æ–‡å­—åˆ—å¼•æ•°ã‚’ã¨ã£ã¦æ–‡å­—åˆ—ã‚’è¿”ã™é–¢æ•°ã«è¨­å®šã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ã“ã‚Œã‚’"
" ``str`` ã«è¨­å®šã™ã‚‹ã¨ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³åã«å¤§æ–‡å­—å°æ–‡å­—ã®åŒºåˆ¥ã‚’ã¤ã‘ã‚‰ã‚Œã¾ã™::"

#: ../../library/configparser.rst:1161
msgid ""
"Note that when reading configuration files, whitespace around the option "
"names is stripped before :meth:`optionxform` is called."
msgstr "ãªãŠã€è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€ã¨ãã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³åã®å‘¨ã‚Šã®ç©ºç™½ã¯ :meth:`optionxform` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹å‰ã«å–ã‚Šé™¤ã‹ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:1167
msgid "Use :meth:`read_file` instead."
msgstr "ä»£ã‚ã‚Šã« :meth:`read_file` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/configparser.rst:1170
msgid ""
":meth:`readfp` now iterates on *fp* instead of calling ``fp.readline()``."
msgstr ":meth:`readfp` ã¯ ``fp.readline()`` ã‚’å‘¼ã³å‡ºã™ä»£ã‚ã‚Šã« *fp* ã‚’ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/configparser.rst:1173
msgid ""
"For existing code calling :meth:`readfp` with arguments which don't support "
"iteration, the following generator may be used as a wrapper around the file-"
"like object::"
msgstr ""
":meth:`readfp` "
"ã‚’ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã—ãªã„å¼•æ•°ã§å‘¼ã³å‡ºã™æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã«ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«çš„ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ã‚ã‚Šã®ãƒ©ãƒƒãƒ‘ãƒ¼ã¨ã—ã¦ä»¥ä¸‹ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒä½¿ãˆã¾ã™::"

#: ../../library/configparser.rst:1183
msgid ""
"Instead of ``parser.readfp(fp)`` use "
"``parser.read_file(readline_generator(fp))``."
msgstr ""
"``parser.readfp(fp)`` ã®ä»£ã‚ã‚Šã« ``parser.read_file(readline_generator(fp))`` "
"ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/configparser.rst:1189
msgid ""
"The maximum depth for recursive interpolation for :meth:`get` when the *raw*"
" parameter is false.  This is relevant only when the default *interpolation*"
" is used."
msgstr ""
":meth:`get` ã® *raw* ãŒå½ã§ã‚ã‚‹ã¨ãã®å†å¸°çš„ãªè£œé–“ã®æœ€å¤§ã®æ·±ã•ã§ã™ã€‚ã“ã‚Œã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® *interpolation* "
"ã‚’ä½¿ã†ã¨ãã®ã¿é–¢ä¿‚ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:1197
msgid "RawConfigParser Objects"
msgstr "RawConfigParser ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/configparser.rst:1207
msgid ""
"Legacy variant of the :class:`ConfigParser` with interpolation disabled by "
"default and unsafe ``add_section`` and ``set`` methods."
msgstr ""
"è£œé–“ã‚„ä¸å®‰å…¨ ãª ``add_section`` ãŠã‚ˆã³ ``set`` ãƒ¡ã‚½ãƒƒãƒ‰ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ç„¡åŠ¹åŒ–ã•ã‚Œã¦ã„ã‚‹ã€ãƒ¬ã‚¬ã‚·ãƒ¼ãª "
":class:`ConfigParser` ã®åˆ¥å‹ã§ã™ã€‚"

#: ../../library/configparser.rst:1211
msgid ""
"Consider using :class:`ConfigParser` instead which checks types of the "
"values to be stored internally.  If you don't want interpolation, you can "
"use ``ConfigParser(interpolation=None)``."
msgstr ""
"ä»£ã‚ã‚Šã«å†…éƒ¨ã«ä¿å­˜ã™ã‚‹å€¤ã®å‹ã‚’æ¤œæŸ»ã™ã‚‹ :class:`ConfigParser` ã‚’ä½¿ã†ã“ã¨ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚è£œé–“ã‚’æœ›ã¾ãªã„å ´åˆã€  "
"``ConfigParser(interpolation=None)`` ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/configparser.rst:1218
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised."
msgstr ""
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã« *section* ã¨ã„ã†åã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã—ã¾ã™ã€‚ä¸ãˆã‚‰ã‚ŒãŸåå‰ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒã™ã§ã«å­˜åœ¨ã™ã‚Œã°ã€ "
":exc:`DuplicateSectionError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ *default section* åãŒæ¸¡ã•ã‚Œã‚‹ã¨ã€ "
":exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/configparser.rst:1222
msgid ""
"Type of *section* is not checked which lets users create non-string named "
"sections.  This behaviour is unsupported and may cause internal errors."
msgstr ""
"*section* "
"ã®å‹ã¯æ¤œæŸ»ã•ã‚Œãªã„ãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯éæ–‡å­—åˆ—ã®åå‰ä»˜ãã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®æŒ¯ã‚‹èˆã„ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ãŠã‚‰ãšã€å†…éƒ¨ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã™å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/configparser.rst:1228
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  While it is possible to use "
":class:`RawConfigParser` (or :class:`ConfigParser` with *raw* parameters set"
" to true) for *internal* storage of non-string values, full functionality "
"(including interpolation and output to files) can only be achieved using "
"string values."
msgstr ""
"ä¸ãˆã‚‰ã‚ŒãŸã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå­˜åœ¨ã—ã¦ã„ã‚Œã°ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æŒ‡å®šã•ã‚ŒãŸå€¤ã«è¨­å®šã—ã¾ã™ã€‚ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå­˜åœ¨ã—ãªã‘ã‚Œã° :exc:`NoSectionError` "
"ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚ :class:`RawConfigParser` (ã‚ã‚‹ã„ã¯ *raw* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã‚»ãƒƒãƒˆã—ãŸ "
":class:`ConfigParser`) ã‚’æ–‡å­—åˆ—å‹ã§ãªã„å€¤ã® *å†…éƒ¨çš„ãª* æ ¼ç´å ´æ‰€ã¨ã—ã¦ä½¿ã†ã“ã¨ã¯å¯èƒ½ã§ã™ãŒã€ã™ã¹ã¦ã®æ©Ÿèƒ½ "
"(ç½®æ›ã‚„ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®å‡ºåŠ›ã‚’å«ã‚€) ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã‚‹ã®ã¯æ–‡å­—åˆ—ã‚’å€¤ã¨ã—ã¦ä½¿ã£ãŸå ´åˆã ã‘ã§ã™ã€‚"

#: ../../library/configparser.rst:1235
msgid ""
"This method lets users assign non-string values to keys internally.  This "
"behaviour is unsupported and will cause errors when attempting to write to a"
" file or get it in non-raw mode.  **Use the mapping protocol API** which "
"does not allow such assignments to take place."
msgstr ""
"ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦éæ–‡å­—åˆ—ã®å€¤ã‚’ã‚­ãƒ¼ã«ä»£å…¥ã§ãã¾ã™ã€‚ã“ã®æŒ¯ã‚‹èˆã„ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ãŠã‚‰ãšã€érawãƒ¢ãƒ¼ãƒ‰ã§ã®å€¤ã®å–å¾—ã‚„ã€ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®æ›¸ãå‡ºã—ã‚’è©¦ã¿ãŸéš›ã«ã‚¨ãƒ©ãƒ¼ã®åŸå› ã¨ãªã‚Šãˆã¾ã™ã€‚ã“ã®ã‚ˆã†ãªä»£å…¥ã‚’è¨±ã•ãªã„"
"  **ãƒãƒƒãƒ”ãƒ³ã‚°ãƒ—ãƒ­ãƒˆã‚³ãƒ«APIã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„**ã€‚"

#: ../../library/configparser.rst:1242
msgid "Exceptions"
msgstr "ä¾‹å¤–"

#: ../../library/configparser.rst:1246
msgid "Base class for all other :mod:`configparser` exceptions."
msgstr "ä»–ã®å…¨ã¦ã® :mod:`configparser` ä¾‹å¤–ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/configparser.rst:1251
msgid "Exception raised when a specified section is not found."
msgstr "æŒ‡å®šã—ãŸã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸæ™‚ã«èµ·ãã‚‹ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/configparser.rst:1256
msgid ""
"Exception raised if :meth:`add_section` is called with the name of a section"
" that is already present or in strict parsers when a section if found more "
"than once in a single input file, string or dictionary."
msgstr ""
":meth:`add_section` ãŒã™ã§ã«å­˜åœ¨ã™ã‚‹ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®åå‰ã§å‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆã‚„ã€strict "
"ãªãƒ‘ãƒ¼ã‚µãƒ¼ã§å˜ä¸€ã®å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã€æ–‡å­—åˆ—ã€è¾æ›¸ä¸­ã«åŒã˜ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒè¤‡æ•°å›ç¾ã‚ŒãŸã¨ãã«é€å‡ºã•ã‚Œã‚‹ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/configparser.rst:1260
msgid ""
"Optional ``source`` and ``lineno`` attributes and arguments to "
":meth:`__init__` were added."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® ``source`` ã¨ ``lineno`` ãŒå±æ€§ãŠã‚ˆã³ :meth:`__init__` ã¸ã®å¼•æ•°ã¨ã—ã¦åŠ ãˆã‚‰ã‚Œã¾ã—ãŸã€‚"

#: ../../library/configparser.rst:1267
msgid ""
"Exception raised by strict parsers if a single option appears twice during "
"reading from a single file, string or dictionary. This catches misspellings "
"and case sensitivity-related errors, e.g. a dictionary may have two keys "
"representing the same case-insensitive configuration key."
msgstr ""
"strict "
"ãªãƒ‘ãƒ¼ã‚µãƒ¼ã§ã€å˜ä¸€ã®å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã€æ–‡å­—åˆ—ã€è¾æ›¸ä¸­ã«åŒã˜ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒè¤‡æ•°å›ç¾ã‚ŒãŸã¨ãã«é€å‡ºã•ã‚Œã‚‹ä¾‹å¤–ã§ã™ã€‚ã“ã‚Œã¯ãƒŸã‚¹ã‚¹ãƒšãƒ«ã‚„å¤§æ–‡å­—å°æ–‡å­—ã®åŒºåˆ¥ã«é–¢ä¿‚ã™ã‚‹ã‚¨ãƒ©ãƒ¼ã€ä¾‹ãˆã°è¾æ›¸ã®äºŒã¤ã®ã‚­ãƒ¼ãŒåŒã˜å¤§æ–‡å­—å°æ–‡å­—ã®åŒºåˆ¥ã®ãªã„è¨­å®šã‚­ãƒ¼ã‚’è¡¨ã™ã“ã¨ã€ã‚’æ•æ‰ã—ã¾ã™ã€‚"

#: ../../library/configparser.rst:1275
msgid ""
"Exception raised when a specified option is not found in the specified "
"section."
msgstr "æŒ‡å®šã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒæŒ‡å®šã•ã‚ŒãŸã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«è¦‹ã¤ã‹ã‚‰ãªã„ã¨ãã«é€å‡ºã•ã‚Œã‚‹ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/configparser.rst:1281
msgid ""
"Base class for exceptions raised when problems occur performing string "
"interpolation."
msgstr "æ–‡å­—åˆ—ã®è£œé–“ä¸­ã«å•é¡ŒãŒèµ·ããŸæ™‚ã«ç™ºç”Ÿã™ã‚‹ä¾‹å¤–ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/configparser.rst:1287
msgid ""
"Exception raised when string interpolation cannot be completed because the "
"number of iterations exceeds :const:`MAX_INTERPOLATION_DEPTH`.  Subclass of "
":exc:`InterpolationError`."
msgstr ""
"ç¹°ã‚Šè¿”ã—ã®å›æ•°ãŒ :const:`MAX_INTERPOLATION_DEPTH` ã‚’è¶…ãˆãŸãŸã‚ã«æ–‡å­—åˆ—è£œé–“ãŒå®Œäº†ã—ãªã‹ã£ãŸã¨ãã«é€å‡ºã•ã‚Œã‚‹ä¾‹å¤–ã§ã™ã€‚ "
":exc:`InterpolationError` ã®æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/configparser.rst:1294
msgid ""
"Exception raised when an option referenced from a value does not exist. "
"Subclass of :exc:`InterpolationError`."
msgstr ":exc:`InterpolationError` ã®æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã§ã€å€¤ãŒå‚ç…§ã—ã¦ã„ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã«ç™ºç”Ÿã™ã‚‹ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/configparser.rst:1300
msgid ""
"Exception raised when the source text into which substitutions are made does"
" not conform to the required syntax.  Subclass of :exc:`InterpolationError`."
msgstr ""
"ç½®æ›ãŒãªã•ã‚Œã‚‹ã‚½ãƒ¼ã‚¹ãƒ†ã‚­ã‚¹ãƒˆãŒè¦æ±‚ã•ã‚ŒãŸæ–‡æ³•ã‚’æº€ãŸã•ãªã„ã¨ãã«é€å‡ºã•ã‚Œã‚‹ä¾‹å¤–ã§ã™ã€‚ :exc:`InterpolationError` "
"ã®æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/configparser.rst:1306
msgid ""
"Exception raised when attempting to parse a file which has no section "
"headers."
msgstr "ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãƒ˜ãƒƒãƒ€ã‚’æŒãŸãªã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ§‹æ–‡è§£æã—ã‚ˆã†ã¨ã—ãŸæ™‚ã«èµ·ãã‚‹ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/configparser.rst:1312
msgid "Exception raised when errors occur attempting to parse a file."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã®æ§‹æ–‡è§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒèµ·ããŸå ´åˆã«ç™ºç”Ÿã™ã‚‹ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/configparser.rst:1314
msgid ""
"The ``filename`` attribute and :meth:`__init__` argument were renamed to "
"``source`` for consistency."
msgstr "``filename`` ã¨ã„ã†å±æ€§ãŠã‚ˆã³ :meth:`__init__` ã®å¼•æ•°ã¯ ``source`` ã«åå‰ãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/configparser.rst:1320
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../library/configparser.rst:1321
msgid ""
"Config parsers allow for heavy customization.  If you are interested in "
"changing the behaviour outlined by the footnote reference, consult the "
"`Customizing Parser Behaviour`_ section."
msgstr ""
"è¨­å®šãƒ‘ãƒ¼ã‚µãƒ¼ã¯å¤§ã€…çš„ã«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚è„šæ³¨ã®å‚ç…§ã§æ¦‚èª¬ã•ã‚ŒãŸæŒ™å‹•ã®å¤‰æ›´ã«é–¢å¿ƒãŒã‚ã‚‹å ´åˆã€`Customizing Parser "
"Behaviour`_ ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"
