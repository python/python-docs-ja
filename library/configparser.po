# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-12-31 18:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: cocoatomo <cocoatomo77@gmail.com>, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/configparser.rst:2
msgid ":mod:`configparser` --- Configuration file parser"
msgstr ":mod:`configparser` --- 設定ファイルのパーサー"

#: ../../library/configparser.rst:14
msgid "**Source code:** :source:`Lib/configparser.py`"
msgstr "**ソースコード:** :source:`Lib/configparser.py`"

#: ../../library/configparser.rst:24
msgid ""
"This module provides the :class:`ConfigParser` class which implements a "
"basic configuration language which provides a structure similar to what's "
"found in Microsoft Windows INI files.  You can use this to write Python "
"programs which can be customized by end users easily."
msgstr ""
"このモジュールは、 Microsoft Windows の INI ファイルに似た構造を持ったベーシックな設定用言語を実装した "
":class:`ConfigParser` クラスを提供します。このクラスを使ってユーザーが簡単にカスタマイズできる Python "
"プログラムを作ることができます。"

#: ../../library/configparser.rst:31
msgid ""
"This library does *not* interpret or write the value-type prefixes used in "
"the Windows Registry extended version of INI syntax."
msgstr "このライブラリでは、Windowsのレジストリ用に拡張された INI 文法はサポート *していません* 。"

#: ../../library/configparser.rst:38
msgid "Module :mod:`shlex`"
msgstr ":mod:`shlex` モジュール"

#: ../../library/configparser.rst:37
msgid ""
"Support for creating Unix shell-like mini-languages which can be used as an "
"alternate format for application configuration files."
msgstr "アプリケーション設定ファイルのフォーマットとして使える、Unix シェルに似たミニ言語の作成を支援します。"

#: ../../library/configparser.rst:41
msgid "Module :mod:`json`"
msgstr ":mod:`json` モジュール"

#: ../../library/configparser.rst:41
msgid ""
"The json module implements a subset of JavaScript syntax which can also be "
"used for this purpose."
msgstr "json モジュールは、同じ目的に利用できる JavaScript の文法のサブセットを実装しています。"

#: ../../library/configparser.rst:46
msgid "Quick Start"
msgstr "クイックスタート"

#: ../../library/configparser.rst:48
msgid "Let's take a very basic configuration file that looks like this:"
msgstr "次のような、非常に簡単な設定ファイルを例に考えましょう:"

#: ../../library/configparser.rst:65
msgid ""
"The structure of INI files is described `in the following section "
"<#supported-ini-file-structure>`_.  Essentially, the file consists of "
"sections, each of which contains keys with values. :mod:`configparser` "
"classes can read and write such files.  Let's start by creating the above "
"configuration file programmatically."
msgstr ""
"INI ファイルの構造は `下のセクション <#supported-ini-file-structure>`_ で解説します。\n"
"基本的に、ファイルは複数のセクションからなり、各セクションは複数のキーと値を持ちます。\n"
":mod:`configparser` のクラス群はそれらのファイルを読み書きできます。\n"
"まずは上のような設定ファイルをプログラムから作成してみましょう。"

#: ../../library/configparser.rst:89
msgid ""
"As you can see, we can treat a config parser much like a dictionary. There "
"are differences, `outlined later <#mapping-protocol-access>`_, but the "
"behavior is very close to what you would expect from a dictionary."
msgstr ""
"この例でわかるように、config parser は辞書のように扱うことができます。辞書との違いは `後に <#mapping-protocol-"
"access>`_ 説明しますが、このインターフェイスは辞書に対して期待するのととても近い動作をします。"

#: ../../library/configparser.rst:93
msgid ""
"Now that we have created and saved a configuration file, let's read it back "
"and explore the data it holds."
msgstr "これで設定ファイルを作成して保存できました。次はこれを読み込み直して、中のデータを取り出してみましょう。"

#: ../../library/configparser.rst:129
msgid ""
"As we can see above, the API is pretty straightforward.  The only bit of "
"magic involves the ``DEFAULT`` section which provides default values for all"
" other sections [1]_.  Note also that keys in sections are case-insensitive "
"and stored in lowercase [1]_."
msgstr ""
"上の例からわかるように、API はとても直感的です。唯一の魔術は、``DEFAULT`` "
"セクションが他の全てのセクションのためのデフォルト値を提供していることです [1]_。 "
"また、セクション内の各キーは大文字小文字を区別せず、全て小文字で保存されていることにも注意してください [1]_。"

#: ../../library/configparser.rst:136
msgid "Supported Datatypes"
msgstr "サポートされるデータ型"

#: ../../library/configparser.rst:138
msgid ""
"Config parsers do not guess datatypes of values in configuration files, "
"always storing them internally as strings.  This means that if you need "
"other datatypes, you should convert on your own:"
msgstr ""
"Config parser "
"は値のデータ型について何も推論せず、常に文字列のまま内部に保存します。他のデータ型が必要な場合は自分で変換する必要があります:"

#: ../../library/configparser.rst:149
msgid ""
"Since this task is so common, config parsers provide a range of handy getter"
" methods to handle integers, floats and booleans.  The last one is the most "
"interesting because simply passing the value to ``bool()`` would do no good "
"since ``bool('False')`` is still ``True``.  This is why config parsers also "
"provide :meth:`~ConfigParser.getboolean`.  This method is case-insensitive "
"and recognizes Boolean values from ``'yes'``/``'no'``, ``'on'``/``'off'``, "
"``'true'``/``'false'`` and ``'1'``/``'0'`` [1]_.  For example:"
msgstr ""
"このタスクはとても一般的なため、設定パーサーでは整数、浮動小数点数、真偽値を扱うための手頃なゲッターメソッドが提供されています。真偽値の扱いは一筋縄ではいきません。文字列を"
" ``bool()`` に渡しても、 ``bool('False')`` が ``True`` になってしまいます。そこで config parser "
"は :meth:`~ConfigParser.getboolean` を提供しています。このメソッドは大文字小文字を区別せず、 "
"``'yes'``/``'no'``、``'on'``/``'off'``、``'true'``/``'false'``、``'1'``/``'0'``"
" を真偽値として認識します [1]_。例えば:"

#: ../../library/configparser.rst:166
msgid ""
"Apart from :meth:`~ConfigParser.getboolean`, config parsers also provide "
"equivalent :meth:`~ConfigParser.getint` and :meth:`~ConfigParser.getfloat` "
"methods.  You can register your own converters and customize the provided "
"ones. [1]_"
msgstr ""
"config parser では、 :meth:`~ConfigParser.getboolean` 以外に "
":meth:`~ConfigParser.getint` と :meth:`~ConfigParser.getfloat` "
"メソッドも提供されています。独自のコンバーターの登録、提供されたメソッドのカスタマイズもできます。 [1]_"

#: ../../library/configparser.rst:172
msgid "Fallback Values"
msgstr "代替値"

#: ../../library/configparser.rst:174
msgid ""
"As with a dictionary, you can use a section's :meth:`get` method to provide "
"fallback values:"
msgstr "辞書と同じように、セクションの :meth:`get` メソッドは代替値を提供しています:"

#: ../../library/configparser.rst:187
msgid ""
"Please note that default values have precedence over fallback values. For "
"instance, in our example the ``'CompressionLevel'`` key was specified only "
"in the ``'DEFAULT'`` section.  If we try to get it from the section "
"``'topsecret.server.com'``, we will always get the default, even if we "
"specify a fallback:"
msgstr ""
"デフォルト値は代替値よりも優先されることに注意してください。例えば上の例では、``'CompressionLevel'`` キーは "
"``'DEFAULT'`` セクションにしか存在しません。その値を ``'topsecret.server.com'`` "
"から取得しようとした場合、代替値を指定しても常にデフォルト値を返します:"

#: ../../library/configparser.rst:198
msgid ""
"One more thing to be aware of is that the parser-level :meth:`get` method "
"provides a custom, more complex interface, maintained for backwards "
"compatibility.  When using this method, a fallback value can be provided via"
" the ``fallback`` keyword-only argument:"
msgstr ""
"もう一つ注意すべき点は、パーサーレベルの(訳注: ConfigParserクラスの) :meth:`get` "
"メソッドは、後方互換性のために、カスタムのより複雑なインターフェースを提供します。このメソッドを使用する際には、フォールバック値はキーワード引数としてのみ指定できる"
" ``fallback`` 引数を介して提供されます:"

#: ../../library/configparser.rst:209
msgid ""
"The same ``fallback`` argument can be used with the "
":meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat` and "
":meth:`~ConfigParser.getboolean` methods, for example:"
msgstr ""
"同様の ``fallback`` 引数を、:meth:`~ConfigParser.getint` 、 "
":meth:`~ConfigParser.getfloat` と :meth:`~ConfigParser.getboolean` "
"メソッドでも使えます。例えば:"

#: ../../library/configparser.rst:225
msgid "Supported INI File Structure"
msgstr "サポートするINI ファイルの構造"

#: ../../library/configparser.rst:227
msgid ""
"A configuration file consists of sections, each led by a ``[section]`` "
"header, followed by key/value entries separated by a specific string (``=`` "
"or ``:`` by default [1]_).  By default, section names are case sensitive but"
" keys are not [1]_.  Leading and trailing whitespace is removed from keys "
"and values. Values can be omitted, in which case the key/value delimiter may"
" also be left out.  Values can also span multiple lines, as long as they are"
" indented deeper than the first line of the value.  Depending on the "
"parser's mode, blank lines may be treated as parts of multiline values or "
"ignored."
msgstr ""
"設定ファイルは複数のセクションから構成されます。セクションは、``[section]`` ヘッダに続いた、特定の文字列(デフォルトでは ``=`` "
"または ``:`` [1]_ )で区切られたキーと値のエントリです。デフォルトでは、セクション名は大文字と小文字を区別しますが、キーはそうではありません"
" "
"[1]_。キーと値、それぞれの先頭と末尾の空白は取り除かれます。値は省略することができ、その際でも、キーと値の区切り文字は残しておけます。値はまた、値の先頭の行より深くインデントされていれば、複数の行にまたがっても構いません。パーサーのモードによって、空白行は、複数行からなる値の一部として扱われるか、無視されます。"

#: ../../library/configparser.rst:236
msgid ""
"Configuration files may include comments, prefixed by specific characters "
"(``#`` and ``;`` by default [1]_).  Comments may appear on their own on an "
"otherwise empty line, possibly indented. [1]_"
msgstr ""
"設定ファイルには先頭に特定の文字 (デフォルトでは ``#`` および ``;`` [1]_) "
"をつけてコメントをつけることができます。コメントは、他の内容がない行に置くことができ、インデントされていても構いません。[1]_"

#: ../../library/configparser.rst:240 ../../library/configparser.rst:301
msgid "For example:"
msgstr "例えば:"

#: ../../library/configparser.rst:288
msgid "Interpolation of values"
msgstr "値の補間"

#: ../../library/configparser.rst:290
msgid ""
"On top of the core functionality, :class:`ConfigParser` supports "
"interpolation.  This means values can be preprocessed before returning them "
"from ``get()`` calls."
msgstr ""
"コア機能に加えて、 :class:`ConfigParser` は補間(interpolation, 内挿とも)をサポートします。これは "
"``get()`` コールが値を返す前に、その値に対して前処理を行えることを意味します。"

#: ../../library/configparser.rst:296
msgid ""
"The default implementation used by :class:`ConfigParser`.  It enables values"
" to contain format strings which refer to other values in the same section, "
"or values in the special default section [1]_.  Additional default values "
"can be provided on initialization."
msgstr ""
":class:`ConfigParser` が使用するデフォルト実装です。値に、同じセクションか特別なデフォルトセクション中 [1]_ "
"の他の値を参照するフォーマット文字列を含めることができます。追加のデフォルト値を初期化時に提供できます。"

#: ../../library/configparser.rst:311
msgid ""
"In the example above, :class:`ConfigParser` with *interpolation* set to "
"``BasicInterpolation()`` would resolve ``%(home_dir)s`` to the value of "
"``home_dir`` (``/Users`` in this case).  ``%(my_dir)s`` in effect would "
"resolve to ``/Users/lumberjack``.  All interpolations are done on demand so "
"keys used in the chain of references do not have to be specified in any "
"specific order in the configuration file."
msgstr ""
"上の例では、 *interpolation* に ``BasicInterpolation()`` を設定した "
":class:`ConfigParser` が ``%(home_dir)s`` を ``home_dir`` の値(このケースでは "
"``/Users`` )として解決しています、その結果 ``%(my_dir)s`` は ``/Users/lumberjack`` "
"になります。全ての補間は必要に応じて実行されるため、設定ファイル中で参照の連鎖をもつキーを特定の順序で記述する必要はありません。"

#: ../../library/configparser.rst:318
msgid ""
"With ``interpolation`` set to ``None``, the parser would simply return "
"``%(my_dir)s/Pictures`` as the value of ``my_pictures`` and "
"``%(home_dir)s/lumberjack`` as the value of ``my_dir``."
msgstr ""
"``interpolation`` に ``None`` を設定すれば、パーサーは単に ``my_pictures`` の値として  "
"``%(my_dir)s/Pictures`` を返し、``my_dir`` の値として ``%(home_dir)s/lumberjack`` "
"を返します。"

#: ../../library/configparser.rst:324
msgid ""
"An alternative handler for interpolation which implements a more advanced "
"syntax, used for instance in ``zc.buildout``.  Extended interpolation is "
"using ``${section:option}`` to denote a value from a foreign section. "
"Interpolation can span multiple levels.  For convenience, if the "
"``section:`` part is omitted, interpolation defaults to the current section "
"(and possibly the default values from the special section)."
msgstr ""
"``zc.buildout`` "
"で使用されるような、より高度な文法を実装した補間ハンドラの別の選択肢です。拡張された補間は、他のセクション中の値を示すのに "
"``${section:option}`` と書けます。補間は複数のレベルに及べます、利便性のために、もし ``section:`` "
"の部分が省略されると、現在のセクションがデフォルト値となります(スペシャルセクション中のデフォルト値を使用することもできます)。"

#: ../../library/configparser.rst:331
msgid ""
"For example, the configuration specified above with basic interpolation, "
"would look like this with extended interpolation:"
msgstr ""
"たとえば、上記の basic interpolation で指定した設定は、extended interpolation を使うと下記のようになります:"

#: ../../library/configparser.rst:341
msgid "Values from other sections can be fetched as well:"
msgstr "他のセクションから値を持ってくることもできます:"

#: ../../library/configparser.rst:363
msgid "Mapping Protocol Access"
msgstr "マップ型プロトコルアクセス"

#: ../../library/configparser.rst:367
msgid ""
"Mapping protocol access is a generic name for functionality that enables "
"using custom objects as if they were dictionaries.  In case of "
":mod:`configparser`, the mapping interface implementation is using the "
"``parser['section']['option']`` notation."
msgstr ""
"マップ型プロトコルアクセスは、カスタムオブジェクトを辞書であるかのように使うための機能の総称です。 :mod:`configparser` "
"の場合、マップ型インタフェースの実装は ``parser['section']['option']`` 表記を使います。"

#: ../../library/configparser.rst:372
msgid ""
"``parser['section']`` in particular returns a proxy for the section's data "
"in the parser.  This means that the values are not copied but they are taken"
" from the original parser on demand.  What's even more important is that "
"when values are changed on a section proxy, they are actually mutated in the"
" original parser."
msgstr ""
"とくに、``parser['section']`` "
"はパーサー内のそのセクションのデータへのプロキシを返します。つまり、値はコピーされるのではなく必要に応じてオリジナルのパーサーから取られます。さらに重要なことに、セクションのプロキシの値が変更されると、オリジナルのパーサー中の値が実際に変更されます。"

#: ../../library/configparser.rst:378
msgid ""
":mod:`configparser` objects behave as close to actual dictionaries as "
"possible. The mapping interface is complete and adheres to the "
":class:`~collections.abc.MutableMapping` ABC. However, there are a few "
"differences that should be taken into account:"
msgstr ""
":mod:`configparser` は可能な限り実際の辞書と近い振る舞いをします。マップ型インタフェースは "
":class:`~collections.abc.MutableMapping` を矛盾なく完成します。しかし、考慮するべき違いがいくつかあります:"

#: ../../library/configparser.rst:383
msgid ""
"By default, all keys in sections are accessible in a case-insensitive manner"
" [1]_.  E.g. ``for option in parser[\"section\"]`` yields only "
"``optionxform``'ed option key names.  This means lowercased keys by default."
"  At the same time, for a section that holds the key ``'a'``, both "
"expressions return ``True``::"
msgstr ""
"デフォルトでは、セクション内の全てのキーは大文字小文字の区別なくアクセスできます [1]_。例えば、``for option in "
"parser[\"section\"]`` は ``optionxform`` されたオプションキー名のみを yield "
"します。つまり小文字のキーがデフォルトです。同時に、キー ``'a'`` を含むセクションにおいて、どちらの式も ``True`` を返します::"

#: ../../library/configparser.rst:391
msgid ""
"All sections include ``DEFAULTSECT`` values as well which means that "
"``.clear()`` on a section may not leave the section visibly empty.  This is "
"because default values cannot be deleted from the section (because "
"technically they are not there).  If they are overridden in the section, "
"deleting causes the default value to be visible again.  Trying to delete a "
"default value causes a ``KeyError``."
msgstr ""
"全てのセクションは ``DEFAULTSECT`` 値を持ち、すなわちセクションで ``.clear()`` "
"してもセクションは見た目上空になりません。これは、デフォルト値は (技術的にはそこにないので) "
"セクションから削除できないためです。デフォルト値が上書きされた場合、それが削除されるとデフォルト値が再び見えるようになります。デフォルト値を削除しようとすると"
" ``KeyError`` が発生します。"

#: ../../library/configparser.rst:398
msgid "``DEFAULTSECT`` cannot be removed from the parser:"
msgstr "``DEFAULTSECT`` はパーサーから取り除けません:"

#: ../../library/configparser.rst:400
msgid "trying to delete it raises ``ValueError``,"
msgstr "削除しようとすると ``ValueError`` が発生します。"

#: ../../library/configparser.rst:402
msgid "``parser.clear()`` leaves it intact,"
msgstr "``parser.clear()`` はこれをそのまま残し、"

#: ../../library/configparser.rst:404
msgid "``parser.popitem()`` never returns it."
msgstr "``parser.popitem()`` がこれを返すことはありません。"

#: ../../library/configparser.rst:406
msgid ""
"``parser.get(section, option, **kwargs)`` - the second argument is **not** a"
" fallback value.  Note however that the section-level ``get()`` methods are "
"compatible both with the mapping protocol and the classic configparser API."
msgstr ""
"``parser.get(section, option, **kwargs)`` - 第二引数は代替値では *ありません*。ただし、セクションごとの "
"``get()`` メソッドはマップ型プロトコルと旧式の configparser API の両方に互換です。"

#: ../../library/configparser.rst:410
msgid ""
"``parser.items()`` is compatible with the mapping protocol (returns a list "
"of *section_name*, *section_proxy* pairs including the DEFAULTSECT).  "
"However, this method can also be invoked with arguments: "
"``parser.items(section, raw, vars)``.  The latter call returns a list of "
"*option*, *value* pairs for a specified ``section``, with all interpolations"
" expanded (unless ``raw=True`` is provided)."
msgstr ""
"``parser.items()`` はマップ型プロトコルと互換です (DEFAULTSECT を含む *section_name*, "
"*section_proxy* 対のリストを返します)。ただし、このメソッドは ``parser.items(section, raw, vars)``"
" のようにして引数を与えることでも呼び出せます。後者の呼び出しは指定された ``section`` の  *option*, *value* "
"対のリストを、(``raw=True`` が与えられない限り) 全ての補間を展開して返します。"

#: ../../library/configparser.rst:417
msgid ""
"The mapping protocol is implemented on top of the existing legacy API so "
"that subclasses overriding the original interface still should have mappings"
" working as expected."
msgstr ""
"マップ型プロトコルは、既存のレガシーな API "
"の上に実装されているので、オリジナルのインタフェースを上書きする派生クラスもまたは期待どおりにはたらきます。"

#: ../../library/configparser.rst:423
msgid "Customizing Parser Behaviour"
msgstr "パーサーの振る舞いをカスタマイズする"

#: ../../library/configparser.rst:425
msgid ""
"There are nearly as many INI format variants as there are applications using"
" it. :mod:`configparser` goes a long way to provide support for the largest "
"sensible set of INI styles available.  The default functionality is mainly "
"dictated by historical background and it's very likely that you will want to"
" customize some of the features."
msgstr ""
"INI フォーマットの変種は、それを使うアプリケーションの数と同じくらい多く存在します。 :mod:`configparser` "
"は、可能な限り広い範囲の INI "
"スタイルを集めた集合をサポートするために、非常に役立ちます。デフォルトの機能は主に歴史的背景によって決められたので、機能によってはカスタマイズしてお使いください。"

#: ../../library/configparser.rst:431
msgid ""
"The most common way to change the way a specific config parser works is to "
"use the :meth:`__init__` options:"
msgstr "特定の設定パーサーのはたらきを変える最も一般的な方法は :meth:`__init__` オプションを使うことです:"

#: ../../library/configparser.rst:434
msgid "*defaults*, default value: ``None``"
msgstr "*defaults*, デフォルト値: ``None``"

#: ../../library/configparser.rst:436
msgid ""
"This option accepts a dictionary of key-value pairs which will be initially "
"put in the ``DEFAULT`` section.  This makes for an elegant way to support "
"concise configuration files that don't specify values which are the same as "
"the documented default."
msgstr "このオプションは最初に ``DEFAULT`` セクションに加えられるキー-値の対の辞書を受け付けます。"

#: ../../library/configparser.rst:441
msgid ""
"Hint: if you want to specify default values for a specific section, use "
":meth:`read_dict` before you read the actual file."
msgstr ""
"ヒント: 特定のセクションにデフォルト値を指定したいなら、実際のファイルを読み込む前に :meth:`read_dict` を使ってください。"

#: ../../library/configparser.rst:444
msgid "*dict_type*, default value: :class:`collections.OrderedDict`"
msgstr "*dict_type*, デフォルト値: :class:`collections.OrderedDict`"

#: ../../library/configparser.rst:446
msgid ""
"This option has a major impact on how the mapping protocol will behave and "
"how the written configuration files look.  With the default ordered "
"dictionary, every section is stored in the order they were added to the "
"parser.  Same goes for options within sections."
msgstr ""
"このオプションはマップ型プロトコルの振る舞い方や書き込まれる設定ファイルの見た目に大きく影響します。デフォルトの順序付き辞書では、全てのセクションはパーサーに加えられた順に並びます。同じことがセクション内のオプションにも言えます。"

#: ../../library/configparser.rst:451
msgid ""
"An alternative dictionary type can be used for example to sort sections and "
"options on write-back.  You can also use a regular dictionary for "
"performance reasons."
msgstr ""
"セクションとオプションをライトバック時にソートするためなどに、別の辞書型も使えます。パフォーマンスの理由のために普通の辞書を使うこともできます。"

#: ../../library/configparser.rst:455
msgid ""
"Please note: there are ways to add a set of key-value pairs in a single "
"operation.  When you use a regular dictionary in those operations, the order"
" of the keys may be random.  For example:"
msgstr ""
"注意: 一度の操作でキー-値の対を複数追加する方法もあります。そのような操作に普通の辞書を使うと、キーの並び順はランダムになります。例えば:"

#: ../../library/configparser.rst:477
msgid "In these operations you need to use an ordered dictionary as well:"
msgstr "このような操作には、順序付き辞書を使用する方がよいです:"

#: ../../library/configparser.rst:508
msgid "*allow_no_value*, default value: ``False``"
msgstr "*allow_no_value*, デフォルト値: ``False``"

#: ../../library/configparser.rst:510
msgid ""
"Some configuration files are known to include settings without values, but "
"which otherwise conform to the syntax supported by :mod:`configparser`.  The"
" *allow_no_value* parameter to the constructor can be used to indicate that "
"such values should be accepted:"
msgstr ""
"一部の設定ファイルには値のない設定項目がありますが、それ以外は :mod:`ConfigParser` がサポートする文法に従います。コンストラクタの "
"*allow_no_value* 引数で、そのような値を許可することができます。"

#: ../../library/configparser.rst:545
msgid "*delimiters*, default value: ``('=', ':')``"
msgstr "*delimiters*, デフォルト値: ``('=', ':')``"

#: ../../library/configparser.rst:547
msgid ""
"Delimiters are substrings that delimit keys from values within a section. "
"The first occurrence of a delimiting substring on a line is considered a "
"delimiter.  This means values (but not keys) can contain the delimiters."
msgstr ""
"デリミタはセクション内でキーを値から区切る部分文字列です。行中で最初に現れた区切り部分文字列がデリミタと見なされます。つまり値にはデリミタを含めることができます"
" (キーには含めることができません)。"

#: ../../library/configparser.rst:551
msgid ""
"See also the *space_around_delimiters* argument to "
":meth:`ConfigParser.write`."
msgstr ":meth:`ConfigParser.write` の *space_around_delimiters* 引数も参照してください。"

#: ../../library/configparser.rst:554
msgid "*comment_prefixes*, default value: ``('#', ';')``"
msgstr "*comment_prefixes*, デフォルト値: ``('#', ';')``"

#: ../../library/configparser.rst:556
msgid "*inline_comment_prefixes*, default value: ``None``"
msgstr "*inline_comment_prefixes*, デフォルト値: ``None``"

#: ../../library/configparser.rst:558
msgid ""
"Comment prefixes are strings that indicate the start of a valid comment "
"within a config file. *comment_prefixes* are used only on otherwise empty "
"lines (optionally indented) whereas *inline_comment_prefixes* can be used "
"after every valid value (e.g. section names, options and empty lines as "
"well).  By default inline comments are disabled and ``'#'`` and ``';'`` are "
"used as prefixes for whole line comments."
msgstr ""
"コメント接頭辞は設定ファイル中で有効なコメントの開始を示す文字列です。*comment_prefixes* は他の内容がない行 (インデントは自由) "
"にのみ使用でき、*inline_comment_prefixes* は任意の有効な値 (例えば、セクション名、オプション、空行も可能) "
"の後に使えます。デフォルトではインラインコメントは無効化されていて、``'#'`` と ``';'`` を行全体のコメントに使用します。"

#: ../../library/configparser.rst:565
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``comment_prefixes=('#',';')`` and ``inline_comment_prefixes=(';',)``."
msgstr ""
"以前のバージョンの :mod:`configparser` の振る舞いは ``comment_prefixes=('#',';')`` および "
"``inline_comment_prefixes=(';',)`` に該当します。"

#: ../../library/configparser.rst:569
msgid ""
"Please note that config parsers don't support escaping of comment prefixes "
"so using *inline_comment_prefixes* may prevent users from specifying option "
"values with characters used as comment prefixes.  When in doubt, avoid "
"setting *inline_comment_prefixes*.  In any circumstances, the only way of "
"storing comment prefix characters at the beginning of a line in multiline "
"values is to interpolate the prefix, for example::"
msgstr ""
"設定パーサーはコメント接頭辞のエスケープをサポートしないので、*inline_comment_prefixes* "
"はユーザーがコメント接頭辞として使われる文字を含むオプション値を指定するのを妨げる可能性があります。疑わしい場合には、*inline_comment_prefixes*"
" "
"を設定しないようにしてください。どのような状況でも、複数行にわたる値で、行の先頭にコメント接頭辞文字を保存する唯一の方法は、次の例のように接頭辞を補間することです::"

#: ../../library/configparser.rst:615
msgid "*strict*, default value: ``True``"
msgstr "*strict*, デフォルト値: ``True``"

#: ../../library/configparser.rst:617
msgid ""
"When set to ``True``, the parser will not allow for any section or option "
"duplicates while reading from a single source (using :meth:`read_file`, "
":meth:`read_string` or :meth:`read_dict`).  It is recommended to use strict "
"parsers in new applications."
msgstr ""
"``True`` に設定された場合、パーサーは単一のソースから (:meth:`read_file`, :meth:`read_string` または "
":meth:`read_dict` を使って) 読み込むときにセクションやオプションの重複を許さなくなります。新しいアプリケーションには strict "
"なパーサーを使うことが推奨されます。"

#: ../../library/configparser.rst:622
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``strict=False``."
msgstr "以前のバージョンの :mod:`configparser` の振る舞いは ``strict=False`` に該当します。"

#: ../../library/configparser.rst:626
msgid "*empty_lines_in_values*, default value: ``True``"
msgstr "*empty_lines_in_values*, デフォルト値: ``True``"

#: ../../library/configparser.rst:628
msgid ""
"In config parsers, values can span multiple lines as long as they are "
"indented more than the key that holds them.  By default parsers also let "
"empty lines to be parts of values.  At the same time, keys can be "
"arbitrarily indented themselves to improve readability.  In consequence, "
"when configuration files get big and complex, it is easy for the user to "
"lose track of the file structure.  Take for instance:"
msgstr ""
"設定パーサーでは、キーよりもその値を深くインデントするかぎり、複数行にまたがる値を使えます。デフォルトのパーサーはさらにその値の間に空行を置けます。同時に、キーは読みやすくするため任意にインデントできます。結果として、設定ファイルが大きく複雑になったとき、ユーザーがファイル構造を見失いやすいです。この例をご覧ください:"

#: ../../library/configparser.rst:643
msgid ""
"This can be especially problematic for the user to see if she's using a "
"proportional font to edit the file.  That is why when your application does "
"not need values with empty lines, you should consider disallowing them.  "
"This will make empty lines split keys every time.  In the example above, it "
"would produce two keys, ``key`` and ``this``."
msgstr ""
"これは特にプロポーショナルフォントを使ってファイルを編集しているユーザーにとって問題になることがあります。だから、アプリケーションの値に空行が必要ないなら、空行を認めないべきです。これによって空行で必ずキーが分かれます。上の例では、2"
" つのキー、``key`` および ``this`` が作られます。"

#: ../../library/configparser.rst:649
msgid ""
"*default_section*, default value: ``configparser.DEFAULTSECT`` (that is: "
"``\"DEFAULT\"``)"
msgstr ""
"*default_section*, デフォルト値: ``configparser.DEFAULTSECT`` (すなわち: "
"``\"DEFAULT\"``)"

#: ../../library/configparser.rst:652
msgid ""
"The convention of allowing a special section of default values for other "
"sections or interpolation purposes is a powerful concept of this library, "
"letting users create complex declarative configurations.  This section is "
"normally called ``\"DEFAULT\"`` but this can be customized to point to any "
"other valid section name.  Some typical values include: ``\"general\"`` or "
"``\"common\"``.  The name provided is used for recognizing default sections "
"when reading from any source and is used when writing configuration back to "
"a file.  Its current value can be retrieved using the "
"``parser_instance.default_section`` attribute and may be modified at runtime"
" (i.e. to convert files from one format to another)."
msgstr ""
"他のセクションのデフォルト値や補間目的での特別なセクションを認める慣行はこのライブラリの明確なコンセプトの一つで、ユーザーは複雑で宣言的な設定を作成できます。このセクションは通常"
" ``\"DEFAULT\"`` と呼ばれますが、任意の有効なセクション名を指すようにカスタマイズできます。典型的な値には "
"``\"general\"`` や ``\"common\"`` "
"があります。与えられた名前はソースを読み込む際にデフォルトセクションを認識するのに使われ、設定をファイルに書き戻すときにも使われます。現在の値は "
"``parser_instance.default_section`` 属性から取り出すことができ、実行時 "
"(すなわちファイルを別のフォーマットに変換するとき) に変更することもできます。"

#: ../../library/configparser.rst:663
msgid "*interpolation*, default value: ``configparser.BasicInterpolation``"
msgstr "*interpolation*, デフォルト値: ``configparser.BasicInterpolation``"

#: ../../library/configparser.rst:665
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_. "
":class:`RawConfigParser` has a default value of ``None``."
msgstr ""
"補間の振る舞いは、 *interpolation* 引数を通してカスタムハンドラを与えることでカスタマイズできます。 ``None`` "
"引数を使うと補間を完全に無効にできます。 ``ExtendedInterpolation()`` は、 ``zc.buildout`` "
"に影響を受けたより高度な補間を提供します。この話題に `特化したドキュメントのセクション <#interpolation-of-values>`_ "
"をご覧ください。 :class:`RawConfigParser` のデフォルト値は ``None`` です。"

#: ../../library/configparser.rst:672
msgid "*converters*, default value: not set"
msgstr "*converters*, デフォルト値: 未設定"

#: ../../library/configparser.rst:674
msgid ""
"Config parsers provide option value getters that perform type conversion.  "
"By default :meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat`, and"
" :meth:`~ConfigParser.getboolean` are implemented.  Should other getters be "
"desirable, users may define them in a subclass or pass a dictionary where "
"each key is a name of the converter and each value is a callable "
"implementing said conversion.  For instance, passing ``{'decimal': "
"decimal.Decimal}`` would add :meth:`getdecimal` on both the parser object "
"and all section proxies.  In other words, it will be possible to write both "
"``parser_instance.getdecimal('section', 'key', fallback=0)`` and "
"``parser_instance['section'].getdecimal('key', 0)``."
msgstr ""
"設定パーサーは、型変換を実行するオプションの値ゲッターを提供します。デフォルトでは、 :meth:`~ConfigParser.getint`、 "
":meth:`~ConfigParser.getfloat`、 :meth:`~ConfigParser.getboolean` "
"が実装されています。他のゲッターが必要な場合、ユーザーはそれらをサブクラスで定義するか、辞書を渡します。辞書を渡す場合、各キーはコンバーターの名前で、値は当該変換を実装する呼び出し可能オブジェクトです。例えば、"
" ``{'decimal': decimal.Decimal}`` を渡すと、パーサーオブジェクトとすべてのセクションプロキシの両方に、 "
":meth:`getdecimal` が追加されます。つまり、``parser_instance.getdecimal('section', "
"'key', fallback=0)`` と ``parser_instance['section'].getdecimal('key', 0)`` "
"の両方の方法で書くことができます。"

#: ../../library/configparser.rst:685
msgid ""
"If the converter needs to access the state of the parser, it can be "
"implemented as a method on a config parser subclass.  If the name of this "
"method starts with ``get``, it will be available on all section proxies, in "
"the dict-compatible form (see the ``getdecimal()`` example above)."
msgstr ""
"コンバーターがパーサーの状態にアクセスする必要がある場合、設定パーサーサブクラスでメソッドとして実装することができます。このメソッドの名前が "
"``get`` から始まる場合、すべてのセクションプロキシで、辞書と互換性のある形式で利用できます (上記の ``getdecimal()``  "
"の例を参照)。"

#: ../../library/configparser.rst:690
msgid ""
"More advanced customization may be achieved by overriding default values of "
"these parser attributes.  The defaults are defined on the classes, so they "
"may be overridden by subclasses or by attribute assignment."
msgstr ""
"これらのパーサー引数のデフォルト値を上書きすれば、さらに進んだカスタマイズができます。デフォルトはクラスで定義されているので、派生クラスや属性の代入で上書きできます。"

#: ../../library/configparser.rst:696
msgid ""
"By default when using :meth:`~ConfigParser.getboolean`, config parsers "
"consider the following values ``True``: ``'1'``, ``'yes'``, ``'true'``, "
"``'on'`` and the following values ``False``: ``'0'``, ``'no'``, ``'false'``,"
" ``'off'``.  You can override this by specifying a custom dictionary of "
"strings and their Boolean outcomes. For example:"
msgstr ""
"デフォルトでは、 :meth:`~ConfigParser.getboolean` を使うことで、設定パーサーは以下の値を ``True`` "
"と見なします: ``'1'``, ``'yes'``, ``'true'``, ``'on'`` 。以下の値を ``False`` と見なします: "
"``'0'``, ``'no'``, ``'false'``, ``'off'`` "
"。文字列と対応するブール値のカスタム辞書を指定することでこれを上書きできます。たとえば:"

#: ../../library/configparser.rst:714
msgid ""
"Other typical Boolean pairs include ``accept``/``reject`` or "
"``enabled``/``disabled``."
msgstr ""
"ほかの典型的なブール値ペアには ``accept``/``reject`` や ``enabled``/``disabled`` などがあります。"

#: ../../library/configparser.rst:719
msgid ""
"This method transforms option names on every read, get, or set operation.  "
"The default converts the name to lowercase.  This also means that when a "
"configuration file gets written, all keys will be lowercase.  Override this "
"method if that's unsuitable. For example:"
msgstr ""
"このメソッドは読み込み、取得、設定操作のたびにオプション名を変換します。デフォルトでは名前を小文字に変換します。従って設定ファイルが書き込まれるとき、すべてのキーは小文字になります。それがふさわしくなければ、このメソッドを上書きしてください。例えば:"

#: ../../library/configparser.rst:750
msgid ""
"A compiled regular expression used to parse section headers.  The default "
"matches ``[section]`` to the name ``\"section\"``.  Whitespace is considered"
" part of the section name, thus ``[  larch  ]`` will be read as a section of"
" name ``\"  larch  \"``.  Override this attribute if that's unsuitable.  For"
" example:"
msgstr ""
"セクションヘッダを解析するのに使われる、コンパイルされた正規表現です。デフォルトでは ``[section]`` が ``\"section\"`` "
"という名前にマッチします。空白はセクション名の一部と見なされるので、``[  larch  ]`` は ``\"  larch  \"`` "
"という名のセクションとして読み込まれます。これがふさわしくない場合、このメソッドを上書きしてください。例えば:"

#: ../../library/configparser.rst:777
msgid ""
"While ConfigParser objects also use an ``OPTCRE`` attribute for recognizing "
"option lines, it's not recommended to override it because that would "
"interfere with constructor options *allow_no_value* and *delimiters*."
msgstr ""
"ConfigParser オブジェクトはオプション行の認識に ``OPTCRE`` "
"属性も使いますが、これを上書きすることは推奨されません。上書きするとコンストラクタオプション *allow_no_value* および "
"*delimiters* に干渉します。"

#: ../../library/configparser.rst:783
msgid "Legacy API Examples"
msgstr "レガシーな API の例"

#: ../../library/configparser.rst:785
msgid ""
"Mainly because of backwards compatibility concerns, :mod:`configparser` "
"provides also a legacy API with explicit ``get``/``set`` methods.  While "
"there are valid use cases for the methods outlined below, mapping protocol "
"access is preferred for new projects.  The legacy API is at times more "
"advanced, low-level and downright counterintuitive."
msgstr ""
"主に後方互換性問題の理由から、 :mod:`configparser` は ``get``/``set`` メソッドを明示するレガシーな API "
"も提供します。メソッドを以下に示すように使うこともできますが、新しいプロジェクトではマップ型プロトコルでアクセスするのが望ましいです。レガシーな API"
" は時折高度で、低レベルで、まったく直感的ではありません。"

#: ../../library/configparser.rst:791
msgid "An example of writing to a configuration file::"
msgstr "設定ファイルを書き出す例::"

#: ../../library/configparser.rst:814
msgid "An example of reading the configuration file again::"
msgstr "設定ファイルを読み込む例::"

#: ../../library/configparser.rst:832
msgid "To get interpolation, use :class:`ConfigParser`::"
msgstr "補間するには、 :class:`ConfigParser` を使ってください::"

#: ../../library/configparser.rst:865
msgid ""
"Default values are available in both types of ConfigParsers.  They are used "
"in interpolation if an option used is not defined elsewhere. ::"
msgstr ""
"どちらの型の ConfigParsers "
"でもデフォルト値が利用できます。使われているオプションがどこにも定義されていなければ、そのデフォルト値が補間に使われます。 ::"

#: ../../library/configparser.rst:883
msgid "ConfigParser Objects"
msgstr "ConfigParser オブジェクト"

#: ../../library/configparser.rst:887
msgid ""
"The main configuration parser.  When *defaults* is given, it is initialized "
"into the dictionary of intrinsic defaults.  When *dict_type* is given, it "
"will be used to create the dictionary objects for the list of sections, for "
"the options within a section, and for the default values."
msgstr ""
"主要な設定パーサーです。*defaults* が与えられれば、その辞書の持つ初期値で初期化されます。*dict_type* "
"が与えられれば、それがセクションの一覧、セクション中のオプション、およびデフォルト値の辞書オブジェクトを作成するのに使われます。"

#: ../../library/configparser.rst:892
msgid ""
"When *delimiters* is given, it is used as the set of substrings that divide "
"keys from values.  When *comment_prefixes* is given, it will be used as the "
"set of substrings that prefix comments in otherwise empty lines. Comments "
"can be indented.  When *inline_comment_prefixes* is given, it will be used "
"as the set of substrings that prefix comments in non-empty lines."
msgstr ""
"*delimiters* が与えられた場合、キーと値を分割する部分文字列の組み合わせとして使われます。*comment_prefixes* "
"が与えられた場合、他の内容がない行のコメントに接頭する部分文字列の組み合わせとして使われます。コメントはインデントできます。*inline_comment_prefixes*"
" が与えられた場合、非空行のコメントに接頭する部分文字列としての組み合わせとして使われます。"

#: ../../library/configparser.rst:898
msgid ""
"When *strict* is ``True`` (the default), the parser won't allow for any "
"section or option duplicates while reading from a single source (file, "
"string or dictionary), raising :exc:`DuplicateSectionError` or "
":exc:`DuplicateOptionError`.  When *empty_lines_in_values* is ``False`` "
"(default: ``True``), each empty line marks the end of an option.  Otherwise,"
" internal empty lines of a multiline option are kept as part of the value. "
"When *allow_no_value* is ``True`` (default: ``False``), options without "
"values are accepted; the value held for these is ``None`` and they are "
"serialized without the trailing delimiter."
msgstr ""
"*strict* が ``True`` (デフォルト) であれば、パーサーは単一のソース (ファイル、文字列、辞書) "
"中にセクションやオプションの重複を認めず、 :exc:`DuplicateSectionError` や "
":exc:`DuplicateOptionError` を送出します。 *empty_lines_in_values* が ``False`` "
"(デフォルト: ``True``) なら、空行はそれぞれオプションの終わりを示します。 *allow_no_value* が ``True`` "
"(デフォルト: ``False``) なら、値のないオプションが受け付けられます。そのオプションの値は ``None`` "
"となり、後端のデリミタを除いてシリアル化されます。"

#: ../../library/configparser.rst:908
msgid ""
"When *default_section* is given, it specifies the name for the special "
"section holding default values for other sections and interpolation purposes"
" (normally named ``\"DEFAULT\"``).  This value can be retrieved and changed "
"on runtime using the ``default_section`` instance attribute."
msgstr ""
"*default_section* "
"が与えられた場合、他のセクションへのデフォルト値や補間のためのデフォルト値を保持する特別なセクションの名前を指定します (通常は "
"``\"DEFAULT\"`` という名前です)。この値は実行時に ``default_section`` "
"インスタンス属性を使って取得や変更ができます。"

#: ../../library/configparser.rst:913
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_."
msgstr ""
"補間の動作は、 *interpolation* 引数を通してカスタムハンドラを与えることでカスタマイズできます。 ``None`` "
"引数を使うと補間を完全に無効にできます。 ``ExtendedInterpolation()`` は、 ``zc.buildout`` "
"に影響を受けたより高度な補間を提供します。この件に `特化したドキュメントのセクション <#interpolation-of-values>`_ "
"を参照してください。"

#: ../../library/configparser.rst:919
msgid ""
"All option names used in interpolation will be passed through the "
":meth:`optionxform` method just like any other option name reference.  For "
"example, using the default implementation of :meth:`optionxform` (which "
"converts option names to lower case), the values ``foo %(bar)s`` and ``foo "
"%(BAR)s`` are equivalent."
msgstr ""
"補間に使われるすべてのオプション名は、他のオプション名参照と同様に、 :meth:`optionxform` メソッドを通して渡されます。例えば、 "
":meth:`optionxform` のデフォルトの実装を使うと、値 ``foo %(bar)s`` と ``foo %(BAR)s`` "
"は等しくなります。"

#: ../../library/configparser.rst:925
msgid ""
"When *converters* is given, it should be a dictionary where each key "
"represents the name of a type converter and each value is a callable "
"implementing the conversion from string to the desired datatype.  Every "
"converter gets its own corresponding :meth:`get*()` method on the parser "
"object and section proxies."
msgstr ""
"*converters* "
"が与えられた場合、各キーが型コンバーターの名前を表し、各値が文字列から目的のデータ型への変換を実装する呼び出し可能オブジェクトです。各コンバーターは、自身の対応する"
" :meth:`get*()` メソッドをパーサーオブジェクトとセクションプロキシで取得します。"

#: ../../library/configparser.rst:931
msgid "The default *dict_type* is :class:`collections.OrderedDict`."
msgstr "デフォルトの *dict_type* は :class:`collections.OrderedDict` です。"

#: ../../library/configparser.rst:934
msgid ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* and *interpolation* were added."
msgstr ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* および *interpolation* が追加されました。"

#: ../../library/configparser.rst:939
msgid "The *converters* argument was added."
msgstr "*converters* 引数が追加されました。"

#: ../../library/configparser.rst:945
msgid "Return a dictionary containing the instance-wide defaults."
msgstr "インスタンス全体で使われるデフォルト値の辞書を返します。"

#: ../../library/configparser.rst:950
msgid ""
"Return a list of the sections available; the *default section* is not "
"included in the list."
msgstr "利用できるセクションのリストを返します。*default section* はリストに含まれません。"

#: ../../library/configparser.rst:956
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised.  The name of "
"the section must be a string; if not, :exc:`TypeError` is raised."
msgstr ""
"*section* という名のセクションをインスタンスに追加します。与えられた名前のセクション名がすでに存在したら、 "
":exc:`DuplicateSectionError` が送出されます。 *default section* 名が渡されたら、 "
":exc:`ValueError` が送出されます。セクションの名前は文字列でなければなりません。そうでなければ、 :exc:`TypeError` "
"が送出されます。"

#: ../../library/configparser.rst:961
msgid "Non-string section names raise :exc:`TypeError`."
msgstr "文字列でないセクション名は :exc:`TypeError` を送出します。"

#: ../../library/configparser.rst:967
msgid ""
"Indicates whether the named *section* is present in the configuration. The "
"*default section* is not acknowledged."
msgstr "指名された *section* が設定中に存在するかを示します。*default section* は認識されません。"

#: ../../library/configparser.rst:973
msgid "Return a list of options available in the specified *section*."
msgstr "指定された *section* 中で利用できるオプションのリストを返します。"

#: ../../library/configparser.rst:978
msgid ""
"If the given *section* exists, and contains the given *option*, return "
":const:`True`; otherwise return :const:`False`.  If the specified *section* "
"is :const:`None` or an empty string, DEFAULT is assumed."
msgstr ""
"与えられた *section* が存在し、与えられた *option* を含む場合、 :const:`True` を返します。それ以外の場合には、 "
":const:`False` を返します。指定された *section* が :const:`None` または空文字列の場合、 DEFAULT "
"が仮定されます。"

#: ../../library/configparser.rst:985
msgid ""
"Attempt to read and parse a list of filenames, returning a list of filenames"
" which were successfully parsed."
msgstr "ファイル名のリストを読み込んでパースしようと試みます。正常にパースできたファイル名のリストを返します。"

#: ../../library/configparser.rst:988
msgid ""
"If *filenames* is a string or :term:`path-like object`, it is treated as a "
"single filename.  If a file named in *filenames* cannot be opened, that file"
" will be ignored.  This is designed so that you can specify a list of "
"potential configuration file locations (for example, the current directory, "
"the user's home directory, and some system-wide directory), and all existing"
" configuration files in the list will be read."
msgstr ""
"もし *filenames* が文字列か :term:`path-like object` なら、この引数は1つのファイル名として扱われます。 "
"*filenames* 中に開けないファイルがある場合、そのファイルは無視されます。この挙動は、設定ファイルが置かれる可能性のある場所(例えば、 "
"カレントディレクトリ、ホームディレクトリ、システム全体の設定を行うディレクトリ)のリストを指定して、リストの中で存在する全ての設定ファイルを読むことを想定して設計されています。"
" "

#: ../../library/configparser.rst:995
msgid ""
"If none of the named files exist, the :class:`ConfigParser` instance will "
"contain an empty dataset.  An application which requires initial values to "
"be loaded from a file should load the required file or files using "
":meth:`read_file` before calling :meth:`read` for any optional files::"
msgstr ""
"どの設定ファイルも存在しなかった場合、 :class:`ConfigParser` のインスタンスは "
"空のデータセットを持ちます。初期値の設定ファイルを先に読み込んでおく必要があるアプリケーションでは、 オプションのファイルを読み込むために "
":meth:`read` を呼ぶ前に 、まず :meth:`read_file` を用いて必要なファイルを読み込んでください::"

#: ../../library/configparser.rst:1008
msgid ""
"The *encoding* parameter.  Previously, all files were read using the default"
" encoding for :func:`open`."
msgstr "*encoding* 引数。以前は、すべてのファイルが :func:`open` のデフォルトエンコーディングを使って読まれていました。"

#: ../../library/configparser.rst:1012
msgid "The *filenames* parameter accepts a :term:`path-like object`."
msgstr "*filenames* 引数が :term:`path-like object` を受け入れるようになりました。"

#: ../../library/configparser.rst:1018
msgid ""
"Read and parse configuration data from *f* which must be an iterable "
"yielding Unicode strings (for example files opened in text mode)."
msgstr ""
"設定データを *f* から読み込んで解析します。*f* は Unicode 文字列を yield するイテラブル "
"(例えばテキストモードで開かれたファイル) です。"

#: ../../library/configparser.rst:1021
msgid ""
"Optional argument *source* specifies the name of the file being read.  If "
"not given and *f* has a :attr:`name` attribute, that is used for *source*; "
"the default is ``'<???>'``."
msgstr ""
"オプションの引数 *source* は読み込まれるファイルの名前を指定します。与えられず、 *f* に :attr:`name` 属性があれば、それが "
"*source* として使われます。デフォルトは ``'<???>'`` です。"

#: ../../library/configparser.rst:1025
msgid "Replaces :meth:`readfp`."
msgstr ":meth:`readfp` を置き換えます。"

#: ../../library/configparser.rst:1030
msgid "Parse configuration data from a string."
msgstr "設定データを文字列から解析します。"

#: ../../library/configparser.rst:1032
msgid ""
"Optional argument *source* specifies a context-specific name of the string "
"passed.  If not given, ``'<string>'`` is used.  This should commonly be a "
"filesystem path or a URL."
msgstr ""
"オプションの引数 *source* はコンテキストにおける渡された文字列の名前を指定します。与えられなければ、``'<string>'`` "
"が使われます。これは一般にファイルシステムパスや URL にします。"

#: ../../library/configparser.rst:1041
msgid ""
"Load configuration from any object that provides a dict-like ``items()`` "
"method.  Keys are section names, values are dictionaries with keys and "
"values that should be present in the section.  If the used dictionary type "
"preserves order, sections and their keys will be added in order. Values are "
"automatically converted to strings."
msgstr ""
"辞書的な ``items()`` "
"メソッドを提供する任意のオブジェクトから設定を読み込みます。キーはセクション名で、値はそのセクションに現れるキーと値をもつ辞書です。使われた辞書型が順序を保存するなら、セクションおよびそのキーは順に加えられます。値は自動で文字列に変換されます。"

#: ../../library/configparser.rst:1047
msgid ""
"Optional argument *source* specifies a context-specific name of the "
"dictionary passed.  If not given, ``<dict>`` is used."
msgstr ""
"オプションの引数 *source* はコンテキストにおける渡された辞書の名前を指定します。与えられなければ、``<dict>`` が使われます。"

#: ../../library/configparser.rst:1050
msgid "This method can be used to copy state between parsers."
msgstr "このメソッドを使ってパーサー間で状態をコピーできます。"

#: ../../library/configparser.rst:1057
msgid ""
"Get an *option* value for the named *section*.  If *vars* is provided, it "
"must be a dictionary.  The *option* is looked up in *vars* (if provided), "
"*section*, and in *DEFAULTSECT* in that order.  If the key is not found and "
"*fallback* is provided, it is used as a fallback value.  ``None`` can be "
"provided as a *fallback* value."
msgstr ""
"指名された *section* の *option* の値を取得します。*vars* が提供されるなら、それは辞書でなければならず、(与えられたなら) "
"*vars*, *section*, *DEFAULTSECT* 内からこの順で *option* が探索されます。*fallback* の値として "
"``None`` を与えられます。"

#: ../../library/configparser.rst:1063
msgid ""
"All the ``'%'`` interpolations are expanded in the return values, unless the"
" *raw* argument is true.  Values for interpolation keys are looked up in the"
" same manner as the option."
msgstr "*raw* が真でない時には、全ての ``'%'`` 置換は展開されてから返されます。置換後の値はオプションと同じ順序で探されます。"

#: ../../library/configparser.rst:1067
msgid ""
"Arguments *raw*, *vars* and *fallback* are keyword only to protect users "
"from trying to use the third argument as the *fallback* fallback (especially"
" when using the mapping protocol)."
msgstr ""
"引数 *raw*, *vars* および *fallback* は、(特にマッピングプロトコルを使用するときに) ユーザーが第 3 引数を "
"*fallback* フォールバックとして使おうとしないように、キーワード専用となりました。"

#: ../../library/configparser.rst:1075
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to an integer.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"指定された *section* 中の *option* を整数に型強制する補助メソッドです。 *raw*, *vars* および *fallback* "
"の説明は :meth:`get` を参照してください。"

#: ../../library/configparser.rst:1082
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a floating point number.  See :meth:`get` for explanation of *raw*, "
"*vars* and *fallback*."
msgstr ""
"指定された *section* 中の *option* を浮動小数点数に型強制する補助メソッドです。 *raw*, *vars* および "
"*fallback* の説明は :meth:`get` を参照してください。"

#: ../../library/configparser.rst:1089
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a Boolean value.  Note that the accepted values for the option are "
"``'1'``, ``'yes'``, ``'true'``, and ``'on'``, which cause this method to "
"return ``True``, and ``'0'``, ``'no'``, ``'false'``, and ``'off'``, which "
"cause it to return ``False``.  These string values are checked in a case-"
"insensitive manner.  Any other value will cause it to raise "
":exc:`ValueError`.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"指定された *section* 中の *option* をブール値に型強制する補助メソッドです。なお、このオプションで受け付けられる値はこのメソッドが "
"``True`` を返す ``'1'``, ``'yes'``, ``'true'``, および ``'on'``,と、このメソッドが "
"``False`` を返す ``'0'``, ``'no'``, ``'false'``, and ``'off'`` です。その他のいかなる値も "
":exc:`ValueError` を送出します。 *raw*, *vars* および *fallback* の説明は :meth:`get` "
"を参照してください。"

#: ../../library/configparser.rst:1102
msgid ""
"When *section* is not given, return a list of *section_name*, "
"*section_proxy* pairs, including DEFAULTSECT."
msgstr ""
"*section* が与えられなければ、DEFAULTSECT を含めた *section_name*, *section_proxy* "
"の対のリストを返します。"

#: ../../library/configparser.rst:1105
msgid ""
"Otherwise, return a list of *name*, *value* pairs for the options in the "
"given *section*.  Optional arguments have the same meaning as for the "
":meth:`get` method."
msgstr ""
"与えられれば、与えられた *section* 中のオプションの *name*, *value* の対のリストを返します。オプションの引数は "
":meth:`get` メソッドに与えるものと同じ意味を持ちます。"

#: ../../library/configparser.rst:1109
msgid ""
"Items present in *vars* no longer appear in the result.  The previous "
"behaviour mixed actual parser options with variables provided for "
"interpolation."
msgstr ""
"*vars* に現れる項目は結果に表れなくなりました。以前の挙動は、実際のパーサーオプションを補間のために与えられた変数と混合していました。"

#: ../../library/configparser.rst:1116
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  *option* and *value* must be "
"strings; if not, :exc:`TypeError` is raised."
msgstr ""
"与えられたセクションが存在すれば、与えられたオプションを指定された値に設定します。そうでなければ :exc:`NoSectionError` "
"を送出します。 *option* および *value* は文字列でなければなりません。そうでなければ :exc:`TypeError` "
"が送出されます。"

#: ../../library/configparser.rst:1123
msgid ""
"Write a representation of the configuration to the specified :term:`file "
"object`, which must be opened in text mode (accepting strings).  This "
"representation can be parsed by a future :meth:`read` call.  If "
"*space_around_delimiters* is true, delimiters between keys and values are "
"surrounded by spaces."
msgstr ""
"設定の表現を指定された :term:`file object` に書き込みます。 *fileobject* は (文字列を受け付ける) "
"テキストモードで開かれていなければなりません。この表現は後で :meth:`read` を呼び出すことでパースできます。 "
"*space_around_delimiters* が真なら、キーと値の間のデリミタはスペースで囲まれます。"

#: ../../library/configparser.rst:1132
msgid ""
"Remove the specified *option* from the specified *section*.  If the section "
"does not exist, raise :exc:`NoSectionError`.  If the option existed to be "
"removed, return :const:`True`; otherwise return :const:`False`."
msgstr ""
"指定された *option* を指定された *section* から削除します。セクションが存在しなければ、 :exc:`NoSectionError`"
" を送出します。オプションが存在して削除されれば、 :const:`True` を返します。そうでなければ :const:`False` を返します。"

#: ../../library/configparser.rst:1140
msgid ""
"Remove the specified *section* from the configuration.  If the section in "
"fact existed, return ``True``.  Otherwise return ``False``."
msgstr ""
"指定された *section* を設定から削除します。セクションが実際に存在すれば、``True`` を返します。そうでなければ ``False`` "
"を返します。"

#: ../../library/configparser.rst:1146
msgid ""
"Transforms the option name *option* as found in an input file or as passed "
"in by client code to the form that should be used in the internal "
"structures.  The default implementation returns a lower-case version of "
"*option*; subclasses may override this or client code can set an attribute "
"of this name on instances to affect this behavior."
msgstr ""
"入力ファイルに現れた、またはクライアントコードで渡されたオプション名 *option* を内部構造で実際に使われる形式に変換します。デフォルトの実装では"
" *option* "
"の小文字版を返します。派生クラスでこれを上書きするか、クライアントコードでインスタンス上のこの名前の属性を設定して、この動作に影響を与えることができます。"

#: ../../library/configparser.rst:1152
msgid ""
"You don't need to subclass the parser to use this method, you can also set "
"it on an instance, to a function that takes a string argument and returns a "
"string.  Setting it to ``str``, for example, would make option names case "
"sensitive::"
msgstr ""
"このメソッドを使うためにパーサーを派生クラス化させる必要はなく、インスタンス上で、これを文字列引数をとって文字列を返す関数に設定できます。例えば、これを"
" ``str`` に設定すると、オプション名に大文字小文字の区別をつけられます::"

#: ../../library/configparser.rst:1160
msgid ""
"Note that when reading configuration files, whitespace around the option "
"names is stripped before :meth:`optionxform` is called."
msgstr "なお、設定ファイルを読み込むとき、オプション名の周りの空白は :meth:`optionxform` が呼び出される前に取り除かれます。"

#: ../../library/configparser.rst:1166
msgid "Use :meth:`read_file` instead."
msgstr "代わりに :meth:`read_file` を使ってください。"

#: ../../library/configparser.rst:1169
msgid ""
":meth:`readfp` now iterates on *fp* instead of calling ``fp.readline()``."
msgstr ":meth:`readfp` は ``fp.readline()`` を呼び出す代わりに *fp* をイテレートするようになりました。"

#: ../../library/configparser.rst:1172
msgid ""
"For existing code calling :meth:`readfp` with arguments which don't support "
"iteration, the following generator may be used as a wrapper around the file-"
"like object::"
msgstr ""
":meth:`readfp` "
"をイテレーションをサポートしない引数で呼び出す既存のコードには、ファイル的なオブジェクトまわりのラッパーとして以下のジェネレーターが使えます::"

#: ../../library/configparser.rst:1182
msgid ""
"Instead of ``parser.readfp(fp)`` use "
"``parser.read_file(readline_generator(fp))``."
msgstr ""
"``parser.readfp(fp)`` の代わりに ``parser.read_file(readline_generator(fp))`` "
"を使ってください。"

#: ../../library/configparser.rst:1188
msgid ""
"The maximum depth for recursive interpolation for :meth:`get` when the *raw*"
" parameter is false.  This is relevant only when the default *interpolation*"
" is used."
msgstr ""
":meth:`get` の *raw* が偽であるときの再帰的な補間の最大の深さです。これはデフォルトの *interpolation* "
"を使うときのみ関係します。"

#: ../../library/configparser.rst:1196
msgid "RawConfigParser Objects"
msgstr "RawConfigParser オブジェクト"

#: ../../library/configparser.rst:1206
msgid ""
"Legacy variant of the :class:`ConfigParser` with interpolation disabled by "
"default and unsafe ``add_section`` and ``set`` methods."
msgstr ""
"補間や不安全 な ``add_section`` および ``set`` メソッドがデフォルトで無効化されている、レガシーな "
":class:`ConfigParser` の別型です。"

#: ../../library/configparser.rst:1210
msgid ""
"Consider using :class:`ConfigParser` instead which checks types of the "
"values to be stored internally.  If you don't want interpolation, you can "
"use ``ConfigParser(interpolation=None)``."
msgstr ""
"代わりに内部に保存する値の型を検査する :class:`ConfigParser` を使うことを検討してください。補間を望まない場合、  "
"``ConfigParser(interpolation=None)`` を使用できます。"

#: ../../library/configparser.rst:1217
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised."
msgstr ""
"インスタンスに *section* という名のセクションを追加します。与えられた名前のセクションがすでに存在すれば、 "
":exc:`DuplicateSectionError` が送出されます。 *default section* 名が渡されると、 "
":exc:`ValueError` が送出されます。"

#: ../../library/configparser.rst:1221
msgid ""
"Type of *section* is not checked which lets users create non-string named "
"sections.  This behaviour is unsupported and may cause internal errors."
msgstr ""
"*section* "
"の型は検査されないため、ユーザーは非文字列の名前付きセクションを作ることができます。この振る舞いはサポートされておらず、内部エラーを起こす可能性があります。"

#: ../../library/configparser.rst:1227
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  While it is possible to use "
":class:`RawConfigParser` (or :class:`ConfigParser` with *raw* parameters set"
" to true) for *internal* storage of non-string values, full functionality "
"(including interpolation and output to files) can only be achieved using "
"string values."
msgstr ""
"与えられたセクションが存在していれば、オプションを指定された値に設定します。セクションが存在しなければ :exc:`NoSectionError` "
"を発生させます。 :class:`RawConfigParser` (あるいは *raw* パラメータをセットした "
":class:`ConfigParser`) を文字列型でない値の *内部的な* 格納場所として使うことは可能ですが、すべての機能 "
"(置換やファイルへの出力を含む) がサポートされるのは文字列を値として使った場合だけです。"

#: ../../library/configparser.rst:1234
msgid ""
"This method lets users assign non-string values to keys internally.  This "
"behaviour is unsupported and will cause errors when attempting to write to a"
" file or get it in non-raw mode.  **Use the mapping protocol API** which "
"does not allow such assignments to take place."
msgstr ""
"ユーザーは、このメソッドを使って非文字列の値をキーに代入できます。この振る舞いはサポートされておらず、非rawモードでの値の取得や、ファイルへの書き出しを試みた際にエラーの原因となりえます。このような代入を許さない"
"  **マッピングプロトコルAPIを使用してください**。"

#: ../../library/configparser.rst:1241
msgid "Exceptions"
msgstr "例外"

#: ../../library/configparser.rst:1245
msgid "Base class for all other :mod:`configparser` exceptions."
msgstr "他の全ての :mod:`configparser` 例外の基底クラスです。"

#: ../../library/configparser.rst:1250
msgid "Exception raised when a specified section is not found."
msgstr "指定したセクションが見つからなかった時に起きる例外です。"

#: ../../library/configparser.rst:1255
msgid ""
"Exception raised if :meth:`add_section` is called with the name of a section"
" that is already present or in strict parsers when a section if found more "
"than once in a single input file, string or dictionary."
msgstr ""
":meth:`add_section` がすでに存在するセクションの名前で呼び出された場合や、strict "
"なパーサーで単一の入力ファイル、文字列、辞書中に同じセクションが複数回現れたときに送出される例外です。"

#: ../../library/configparser.rst:1259
msgid ""
"Optional ``source`` and ``lineno`` attributes and arguments to "
":meth:`__init__` were added."
msgstr ""
"オプションの ``source`` と ``lineno`` が属性および :meth:`__init__` への引数として加えられました。"

#: ../../library/configparser.rst:1266
msgid ""
"Exception raised by strict parsers if a single option appears twice during "
"reading from a single file, string or dictionary. This catches misspellings "
"and case sensitivity-related errors, e.g. a dictionary may have two keys "
"representing the same case-insensitive configuration key."
msgstr ""
"strict "
"なパーサーで、単一の入力ファイル、文字列、辞書中に同じオプションが複数回現れたときに送出される例外です。これはミススペルや大文字小文字の区別に関係するエラー、例えば辞書の二つのキーが同じ大文字小文字の区別のない設定キーを表すこと、を捕捉します。"

#: ../../library/configparser.rst:1274
msgid ""
"Exception raised when a specified option is not found in the specified "
"section."
msgstr "指定されたオプションが指定されたセクションに見つからないときに送出される例外です。"

#: ../../library/configparser.rst:1280
msgid ""
"Base class for exceptions raised when problems occur performing string "
"interpolation."
msgstr "文字列の補間中に問題が起きた時に発生する例外の基底クラスです。"

#: ../../library/configparser.rst:1286
msgid ""
"Exception raised when string interpolation cannot be completed because the "
"number of iterations exceeds :const:`MAX_INTERPOLATION_DEPTH`.  Subclass of "
":exc:`InterpolationError`."
msgstr ""
"繰り返しの回数が :const:`MAX_INTERPOLATION_DEPTH` を超えたために文字列補間が完了しなかったときに送出される例外です。 "
":exc:`InterpolationError` の派生クラスです。"

#: ../../library/configparser.rst:1293
msgid ""
"Exception raised when an option referenced from a value does not exist. "
"Subclass of :exc:`InterpolationError`."
msgstr ":exc:`InterpolationError` の派生クラスで、値が参照しているオプションが見つからない場合に発生する例外です。"

#: ../../library/configparser.rst:1299
msgid ""
"Exception raised when the source text into which substitutions are made does"
" not conform to the required syntax.  Subclass of :exc:`InterpolationError`."
msgstr ""
"置換がなされるソーステキストが要求された文法を満たさないときに送出される例外です。 :exc:`InterpolationError` "
"の派生クラスです。"

#: ../../library/configparser.rst:1305
msgid ""
"Exception raised when attempting to parse a file which has no section "
"headers."
msgstr "セクションヘッダを持たないファイルを構文解析しようとした時に起きる例外です。"

#: ../../library/configparser.rst:1311
msgid "Exception raised when errors occur attempting to parse a file."
msgstr "ファイルの構文解析中にエラーが起きた場合に発生する例外です。"

#: ../../library/configparser.rst:1313
msgid ""
"The ``filename`` attribute and :meth:`__init__` argument were renamed to "
"``source`` for consistency."
msgstr "``filename`` という属性および :meth:`__init__` の引数は ``source`` に名前が変更されました。"

#: ../../library/configparser.rst:1319
msgid "Footnotes"
msgstr "脚注"

#: ../../library/configparser.rst:1320
msgid ""
"Config parsers allow for heavy customization.  If you are interested in "
"changing the behaviour outlined by the footnote reference, consult the "
"`Customizing Parser Behaviour`_ section."
msgstr ""
"設定パーサーは大々的にカスタマイズできます。脚注の参照で概説された挙動の変更に関心がある場合、`Customizing Parser "
"Behaviour`_ セクションを参照してください。"
