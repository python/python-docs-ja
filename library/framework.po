# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2017-09-22 17:56+0000\n"
"Last-Translator: 秘湯 <xwhhsprings@gmail.com>\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/framework.rst:3
msgid ":mod:`FrameWork` --- Interactive application framework"
msgstr ":mod:`FrameWork` --- 対話型アプリケーション・フレームワーク"

#: ../../library/framework.rst:11
msgid ""
"The :mod:`FrameWork` module contains classes that together provide a "
"framework for an interactive Macintosh application. The programmer builds an "
"application by creating subclasses that override various methods of the "
"bases classes, thereby implementing the functionality wanted. Overriding "
"functionality can often be done on various different levels, i.e. to handle "
"clicks in a single dialog window in a non-standard way it is not necessary "
"to override the complete event handling."
msgstr ""
":mod:`FrameWork` モジュールは、対話型 Macintosh アプリケーションのクラスで、"
"同時にフレームワークを提供します。プログラマは、サブクラスを作って基底クラス"
"の様々なメソッドをオーバーライドし、必要な機能を実装することでアプリケーショ"
"ンを組み立てられます。機能のオーバーライドは、時によって様々な異なるレベルで"
"行われます。つまり、ある一つのダイアログウィンドウでクリックの処理を普段と違"
"う方法で行うには、完全なイベント処理をオーバーライドする必要はありません。"

#: ../../library/framework.rst:21
msgid "This module has been removed in Python 3.x."
msgstr "このモジュールは Python 3.x で削除されました。"

#: ../../library/framework.rst:23
msgid ""
"Work on the :mod:`FrameWork` has pretty much stopped, now that :mod:`PyObjC` "
"is available for full Cocoa access from Python, and the documentation "
"describes only the most important functionality, and not in the most logical "
"manner at that. Examine the source or the examples for more details.  The "
"following are some comments posted on the MacPython newsgroup about the "
"strengths and limitations of :mod:`FrameWork`:"
msgstr ""
":mod:`FrameWork` の開発は事実上停止しています。現在では :mod:`PyObjC` を使用"
"すれば Python から Cocoa の全機能を使用することができます。このドキュメントで"
"は最も重要な機能だけしか記述していませんし、それさえも論理的な形で書かれても"
"いません。ソースか例題を詳しく見てください。次にあげるのは、MacPython ニュー"
"スグループにポストされたコメントで、 :mod:`FrameWork` の強力さと限界について"
"述べています。"

#: ../../library/framework.rst:33
msgid ""
"The strong point of :mod:`FrameWork` is that it allows you to break into the "
"control-flow at many different places. :mod:`W`, for instance, uses a "
"different way to enable/disable menus and that plugs right in leaving the "
"rest intact. The weak points of :mod:`FrameWork` are that it has no abstract "
"command interface (but that shouldn't be difficult), that its dialog support "
"is minimal and that its control/toolbar support is non-existent."
msgstr ""
":mod:`FrameWork` の最大の強みは、制御の流れをたくさんの異なる部分に分割できる"
"ことです。例えば :mod:`W` を使って、いろいろな方法でメニューをオン/オフした"
"り、残りをいじらずにうまくプラグインさせることができます。 :mod:`FrameWork` "
"の弱点は、コマンドインタフェースが抽象化されていないこと (といっても難しいわ"
"けではないですが)、ダイアログサポートが最低限しかないこと、それからコントロー"
"ル/ツールバーサポートが全くないことです。"

#: ../../library/framework.rst:40
msgid "The :mod:`FrameWork` module defines the following functions:"
msgstr ":mod:`FrameWork` モジュールは以下の関数を定義しています:"

#: ../../library/framework.rst:45
msgid ""
"An object representing the complete application. See below for a description "
"of the methods. The default :meth:`__init__` routine creates an empty window "
"dictionary and a menu bar with an apple menu."
msgstr ""
"アプリケーション全体を表現しているオブジェクト。メソッドについての詳細は以下"
"の記述を参照してください。デフォルト :meth:`__init__` ルーチンは、空のウィン"
"ドウ辞書とアップルメニューつきのメニューバーを作成します。"

#: ../../library/framework.rst:52
msgid ""
"An object representing the menubar. This object is usually not created by "
"the user."
msgstr ""
"メニューバーを表現するオブジェクト。このオブジェクトは普通はユーザは作成しま"
"せん。"

#: ../../library/framework.rst:58
msgid ""
"An object representing a menu. Upon creation you pass the ``MenuBar`` the "
"menu appears in, the *title* string and a position (1-based) *after* where "
"the menu should appear (default: at the end)."
msgstr ""
"メニューを表現するオブジェクト。生成時には、メニューが現われる ``MenuBar`` "
"と、 *title* 文字列、メニューが表示されるべき (1 から始まる) 位置 *after* (デ"
"フォルトは末尾) を渡します。"

#: ../../library/framework.rst:65
msgid ""
"Create a menu item object. The arguments are the menu to create, the item "
"title string and optionally the keyboard shortcut and a callback routine. "
"The callback is called with the arguments menu-id, item number within menu "
"(1-based), current front window and the event record."
msgstr ""
"メニューアイテムオブジェクトを作成します。引数は作成するメニューと、アイテム"
"のタイトル文字列、オプションのキーボードショートカット、コールバックルーチン"
"です。コールバックは、メニュー ID、メニュー内のアイテム番号 (1 から数える)、"
"現在のフロントウィンドウ、イベントレコードを引数に呼ばれます。"

#: ../../library/framework.rst:70
msgid ""
"Instead of a callable object the callback can also be a string. In this case "
"menu selection causes the lookup of a method in the topmost window and the "
"application. The method name is the callback string with ``'domenu_'`` "
"prepended."
msgstr ""
"呼び出し可能なオブジェクトのかわりに、コールバックは文字列でも良いです。この"
"場合、メニューの選択は、最前面のウィンドウとアプリケーションの中でメソッド探"
"索を引き起こします。メソッド名は、コールバック文字列の前に ``'domenu_'`` を付"
"けたものです。"

#: ../../library/framework.rst:75
msgid ""
"Calling the ``MenuBar`` :meth:`fixmenudimstate` method sets the correct "
"dimming for all menu items based on the current front window."
msgstr ""
"``MenuBar`` の :meth:`fixmenudimstate` メソッドを呼びだすと、現在のフロント"
"ウィンドウにもとづいて、適切なディム化を全てのメニューアイテムに対して施しま"
"す。"

#: ../../library/framework.rst:81
msgid "Add a separator to the end of a menu."
msgstr "メニューの最後にセパレータを追加します。"

#: ../../library/framework.rst:86
msgid ""
"Create a submenu named *label* under menu *menu*. The menu object is "
"returned."
msgstr ""
"*label* の名前のサブメニューを、メニュー *menu* の下に作成します。メニューオ"
"ブジェクトが返されます。"

#: ../../library/framework.rst:91
msgid ""
"Creates a (modeless) window. *Parent* is the application object to which the "
"window belongs. The window is not displayed until later."
msgstr ""
"(モードレス) ウィンドウを作成します。 *Parent* は、ウィンドウが属するアプリ"
"ケーションオブジェクトです。作成されたウィンドウはまだ表示されません。"

#: ../../library/framework.rst:97
msgid "Creates a modeless dialog window."
msgstr "モードレスダイアログウィンドウを作成します。"

#: ../../library/framework.rst:102
msgid ""
"Return a ``(left, top, right, bottom)`` tuple suitable for creation of a "
"window of given width and height. The window will be staggered with respect "
"to previous windows, and an attempt is made to keep the whole window on-"
"screen. However, the window will however always be the exact size given, so "
"parts may be offscreen."
msgstr ""
"与えた幅と高さのウィンドウを作成するのに必要な、 ``(left, top, right, "
"bottom)`` からなるタプルを返します。ウィンドウは以前のウィンドウに対して位置"
"をずらして作成され、全体のウィンドウが画面からなるべく外れないようにします。"
"しかし、ウィンドウはいつでも与えたのと全く同じサイズで、そのため一部は画面か"
"ら隠れる場合もあります。"

#: ../../library/framework.rst:110
msgid "Set the mouse cursor to a watch."
msgstr "マウスカーソルを時計型に設定します。"

#: ../../library/framework.rst:115
msgid "Set the mouse cursor to an arrow."
msgstr "マウスカーソルを矢印型に設定します。"

#: ../../library/framework.rst:121
msgid "Application Objects"
msgstr "Application オブジェクト"

#: ../../library/framework.rst:123
msgid "Application objects have the following methods, among others:"
msgstr ""
"Application オブジェクトのメソッドは各種ありますが、次のメソッドをあげておき"
"ます。"

#: ../../library/framework.rst:128
msgid ""
"Override this method if you need menus in your application. Append the menus "
"to the attribute :attr:`menubar`."
msgstr ""
"アプリケーションでメニューを使う必要がある場合、このメソッドをオーバーライド"
"します。属性 :attr:`menubar` にメニューを追加します。"

#: ../../library/framework.rst:134
msgid ""
"Override this method to return a text string describing your application. "
"Alternatively, override the :meth:`do_about` method for more elaborate "
"\"about\" messages."
msgstr ""
"このメソッドをオーバーライドすることで、アプリケーションの説明を記述するテキ"
"スト文字列を返します。代わりに、 :meth:`do_about` メソッドをオーバーライドす"
"れば、もっと凝った \"about\" (…について) メッセージを出す事ができます。"

#: ../../library/framework.rst:141
msgid ""
"This routine is the main event loop, call it to set your application "
"rolling. *Mask* is the mask of events you want to handle, *wait* is the "
"number of ticks you want to leave to other concurrent application (default "
"0, which is probably not a good idea). While raising *self* to exit the "
"mainloop is still supported it is not recommended: call ``self._quit()`` "
"instead."
msgstr ""
"このルーチンがメインイベントループで、作成したアプリケーションが動き出すため"
"にはこれを呼ぶことになります。 *Mask* は操作したいイベントを選択するマスクで"
"す。 *wait* は並行に動作しているアプリケーションに割り当てたいティック数 "
"(1/60 秒) です (デフォルトで 0 ですが、あまり良い値ではありません)。 *self* "
"フラグを立ててメインループを抜ける方法はまだサポートされていますが、これはお"
"勧めできません。代わりに ``self._quit()`` を呼んでください。"

#: ../../library/framework.rst:147
msgid ""
"The event loop is split into many small parts, each of which can be "
"overridden. The default methods take care of dispatching events to windows "
"and dialogs, handling drags and resizes, Apple Events, events for non-"
"FrameWork windows, etc."
msgstr ""
"イベントループは小さなパーツに分割されていて、各々をオーバーライドできるよう"
"になっています。これらのメソッドは、デフォルトでウィンドウとダイアログや、ド"
"ラッグとリサイズの操作、 AppleEvent、非 FrameWork のウィンドウに関するウィン"
"ドウの操作などに関するイベントをディスパッチすることなどまで面倒をみてくれま"
"す。"

#: ../../library/framework.rst:151
msgid ""
"In general, all event handlers should return ``1`` if the event is fully "
"handled and ``0`` otherwise (because the front window was not a FrameWork "
"window, for instance). This is needed so that update events and such can be "
"passed on to other windows like the Sioux console window. Calling :func:"
"`MacOS.HandleEvent` is not allowed within *our_dispatch* or its callees, "
"since this may result in an infinite loop if the code is called through the "
"Python inner-loop event handler."
msgstr ""
"原則として、全てのイベントハンドラは、イベントが完全に取り扱われた場合は "
"``1`` を返さなくてはいけませんし、それ以外では ``0`` を返さなくてはいけませ"
"ん (例えば、前面のウィンドウは FrameWork ウィンドウではない場合を考えてくださ"
"い)。こうしなくてはいけない理由は、アップデートイベントなどが Sioux コンソー"
"ルウィンドウなどの他のウィンドウにきちんと渡されるようにするためです。 "
"*our_dispatch* やその呼び出し元の内部から :func:`MacOS.HandleEvent` を呼んで"
"はいけません。そうしたコードが Python の内部ループのイベントハンドラを経由し"
"て呼ばれると、無限ループになりかねないからです。"

#: ../../library/framework.rst:161
msgid ""
"Call this method with a nonzero parameter to enable asynchronous event "
"handling. This will tell the inner interpreter loop to call the application "
"event handler *async_dispatch* whenever events are available. This will "
"cause FrameWork window updates and the user interface to remain working "
"during long computations, but will slow the interpreter down and may cause "
"surprising results in non-reentrant code (such as FrameWork itself). By "
"default *async_dispatch* will immediately call *our_dispatch* but you may "
"override this to handle only certain events asynchronously. Events you do "
"not handle will be passed to Sioux and such."
msgstr ""
"非同期でイベント操作をしたい場合は、非ゼロの引数でこのメソッドを呼んでくださ"
"い。こうすることで、イベントが生じた時に、内部のインタプリタのループで、アプ"
"リケーションイベントハンドラ *async_dispatch* が呼ばれることになります。する"
"と、長時間の計算を行っている場合でも、FrameWork ウィンドウがアップデートさ"
"れ、ユーザーインターフェースが動き続けるようになります。ただし、インタプリタ"
"の動作が減速し、非リエントラントのコード (例えば FrameWork 自身など) に奇妙な"
"動作が見られるかもしれません。デフォルトでは *async_dispatch* はすぐに "
"*our_dispatch* を呼びますが、このメソッドをオーバーライドすると、特定のイベン"
"トを非同期で操作しても良くなります。処理しないイベントは Sioux などに渡される"
"ことになります。"

#: ../../library/framework.rst:170
msgid "The old on/off value is returned."
msgstr "戻り値は以前の on あるいは off 値です。"

#: ../../library/framework.rst:175
msgid ""
"Terminate the running :meth:`mainloop` call at the next convenient moment."
msgstr ""
"実行中の :meth:`mainloop` 呼び出しを、次の適当なタイミングで終了させます。"

#: ../../library/framework.rst:180
msgid ""
"The user typed character *c*. The complete details of the event can be found "
"in the *event* structure. This method can also be provided in a ``Window`` "
"object, which overrides the application-wide handler if the window is "
"frontmost."
msgstr ""
"ユーザーが文字 *c* をタイプした時に呼ばれます。イベントの全詳細は event 構造"
"体の中にあります。このメソッドは \"Window\" オブジェクト内で使うためにも提供"
"されています。このオブジェクトのウィンドウが最前面にある場合にアプリケーショ"
"ン全体としてのハンドラとして使われます。"

#: ../../library/framework.rst:187
msgid ""
"Called early in the event loop to handle modeless dialog events. The default "
"method simply dispatches the event to the relevant dialog (not through the "
"``DialogWindow`` object involved). Override if you need special handling of "
"dialog events (keyboard shortcuts, etc)."
msgstr ""
"イベントループ内部で最初のほうで呼ばれて、モードレスダイアログイベントを処理"
"します。デフォルトではメソッドは単にイベントを適切なダイアログにディスパッチ"
"するだけです (関連した ``DialogWindow`` オブジェクトを経由してではありませ"
"ん)。特別にダイアログイベント (キーボードショートカットなど) を処理する必要が"
"ある場合にオーバーライドしてください。"

#: ../../library/framework.rst:195
msgid ""
"Called by the main event loop when no events are available. The null-event "
"is passed (so you can look at mouse position, etc)."
msgstr ""
"イベントが無い場合にメインイベントループから呼ばれます。 null イベントも渡さ"
"れます (つまりマウス位置などを監視することができます)。"

#: ../../library/framework.rst:202
msgid "Window Objects"
msgstr "Window オブジェクト"

#: ../../library/framework.rst:204
msgid "Window objects have the following methods, among others:"
msgstr "Window オブジェクトは特に次のメソッドを持ちます:"

#: ../../library/framework.rst:209
msgid ""
"Override this method to open a window. Store the Mac OS window-id in :attr:"
"`self.wid` and call the :meth:`do_postopen` method to register the window "
"with the parent application."
msgstr ""
"ウィンドウを開く時はこのメソッドをオーバーライドします。Mac OS ウィンドウ ID "
"を :attr:`self.wid` に入れて :meth:`do_postopen` メソッドを呼ぶと、親アプリ"
"ケーションにウィンドウを登録します。"

#: ../../library/framework.rst:216
msgid ""
"Override this method to do any special processing on window close. Call the :"
"meth:`do_postclose` method to cleanup the parent state."
msgstr ""
"ウィンドウを閉じるときに特別な処理をする場合はこのメソッドをオーバーライドし"
"ます。親アプリケーション状態をクリーンアップするには、 :meth:`do_postclose` "
"を呼びます。"

#: ../../library/framework.rst:222
msgid ""
"Called after the window is resized. Override if more needs to be done than "
"calling ``InvalRect``."
msgstr ""
"ウィンドウがリサイズされた後に呼ばれます。 ``InvalRect`` を呼び出す以外にもす"
"ることがある場合はこれをオーバーライドします。"

#: ../../library/framework.rst:228
msgid ""
"The user clicked in the content part of a window. The arguments are the "
"coordinates (window-relative), the key modifiers and the raw event."
msgstr ""
"ウィンドウのコンテント部分をユーザーがクリックすると呼ばれます。引数は位置座"
"標 (ウィンドウを基準)、キーモディファイア、生のイベントです。"

#: ../../library/framework.rst:234
msgid "An update event for the window was received. Redraw the window."
msgstr ""
"ウィンドウの更新イベントが受信された時に呼ばれます。ウィンドウを再描画しま"
"す。"

#: ../../library/framework.rst:239
msgid ""
"The window was activated (``activate == 1``) or deactivated (``activate == "
"0``). Handle things like focus highlighting, etc."
msgstr ""
"ウィンドウがアクティブ化( ``activate == 1``)、非アクティブ化 (``activate == "
"0``) する際に呼ばれます。フォーカスのハイライトなどを処理します。"

#: ../../library/framework.rst:246
msgid "ControlsWindow Object"
msgstr "ControlsWindow オブジェクト"

#: ../../library/framework.rst:248
msgid ""
"ControlsWindow objects have the following methods besides those of "
"``Window`` objects:"
msgstr ""
"ControlsWindow オブジェクトには ``Window`` オブジェクトのメソッドの他に次のメ"
"ソッドがあります:"

#: ../../library/framework.rst:254
msgid ""
"Part *pcode* of control *control* was hit by the user. Tracking and such has "
"already been taken care of."
msgstr ""
"コントロール *control* のパートコード *pcode* がユーザにヒットされた場合に呼"
"ばれます。トラッキングなどは任せておいてかまいません。"

#: ../../library/framework.rst:261
msgid "ScrolledWindow Object"
msgstr "ScrolledWindow オブジェクト"

#: ../../library/framework.rst:263
msgid ""
"ScrolledWindow objects are ControlsWindow objects with the following extra "
"methods:"
msgstr ""
"ScrolledWindow オブジェクトは、次のメソッドを追加した ControlsWindow オブジェ"
"クトです。"

#: ../../library/framework.rst:269
msgid ""
"Create (or destroy) horizontal and vertical scrollbars. The arguments "
"specify which you want (default: both). The scrollbars always have minimum "
"``0`` and maximum ``32767``."
msgstr ""
"水平スクロールバーと垂直スクロールバーを作成します (あるいは破棄します)。引数"
"はどちらが欲しいか指定します (デフォルトは両方)。スクロールバーは常に最小値 "
"``0`` 、最大値 ``32767`` です。"

#: ../../library/framework.rst:276
msgid ""
"You must supply this method. It should return a tuple ``(x, y)`` giving the "
"current position of the scrollbars (between ``0`` and ``32767``). You can "
"return ``None`` for either to indicate the whole document is visible in that "
"direction."
msgstr ""
"このメソッドは必ず作っておかなくてはいけません。現在のスクロールバーの位置を"
"与えるタプル ``(x, y)`` を (``0`` の ``32767`` 間で) 返してください。バーの方"
"向について文書全体が可視状態であること知らせるため ``None`` を返す事もできま"
"す。"

#: ../../library/framework.rst:283
msgid ""
"Call this method when the document has changed. It will call :meth:"
"`getscrollbarvalues` and update the scrollbars."
msgstr ""
"文書に変更があった場合はこのメソッドを呼びます。このメソッドは :meth:"
"`getscrollbarvalues` を呼んでスクロールバーを更新します。"

#: ../../library/framework.rst:289
msgid ""
"Supplied by you and called after user interaction. *which* will be ``'x'`` "
"or ``'y'``, *what* will be ``'-'``, ``'--'``, ``'set'``, ``'++'`` or "
"``'+'``. For ``'set'``, *value* will contain the new scrollbar position."
msgstr ""
"あらかじめ与えておくメソッドで、ユーザーとの対話により呼ばれます。 *which* "
"は ``'x'`` か ``'y'`` 、 *what* は ``'-'``, ``'--'``, ``'set'``, ``'++'``, "
"``'+'`` のどれかです。 ``'set'`` の場合は、 *value* に新しいスクロールバー位"
"置を入れておきます。"

#: ../../library/framework.rst:296
msgid ""
"Auxiliary method to help you calculate values to return from :meth:"
"`getscrollbarvalues`. You pass document minimum and maximum value and "
"topmost (leftmost) and bottommost (rightmost) visible values and it returns "
"the correct number or ``None``."
msgstr ""
":meth:`getscrollbarvalues` の結果から値を計算するのを助ける補助的なメソッドで"
"す。文書の最小値と最大値、可視部分に関する上端値 (左端値) と下端値 (右端値) "
"を渡すと、正しい数か ``None`` を返します。"

#: ../../library/framework.rst:304
msgid ""
"Takes care of dimming/highlighting scrollbars when a window becomes "
"frontmost. If you override this method, call this one at the end of your "
"method."
msgstr ""
"ウィンドウが最前面になった時、スクロールバーのディム (dimming)/ハイライトの面"
"倒をみます。このメソッドをオーバーライドするなら、オーバーライドしたメソッド"
"の最後でオリジナルのメソッドを呼んでください。"

#: ../../library/framework.rst:310
msgid ""
"Moves scrollbars to the correct position. Call this method initially if you "
"override it."
msgstr ""
"スクロールバーを正しい位置に移動させます。オーバーライドする時は、オーバーラ"
"イドしたメソッドの一番最初でオリジナルのメソッドを呼んでください。"

#: ../../library/framework.rst:316
msgid ""
"Handles scrollbar interaction. If you override it call this method first, a "
"nonzero return value indicates the hit was in the scrollbars and has been "
"handled."
msgstr ""
"スクロールバーのインタラクションを処理します。これをオーバーライドする時は、"
"オリジナルのメソッドを最初に呼び出してください。非ゼロの返り値はスクロール"
"バー内がヒットされたことを意味し、実際に処理が進むことになります。"

#: ../../library/framework.rst:324
msgid "DialogWindow Objects"
msgstr "DialogWindow オブジェクト"

#: ../../library/framework.rst:326
msgid ""
"DialogWindow objects have the following methods besides those of ``Window`` "
"objects:"
msgstr ""
"DialogWindow オブジェクトには、 ``Window`` オブジェクトのメソッドの他に次のメ"
"ソッドがあります:"

#: ../../library/framework.rst:332
msgid ""
"Create the dialog window, from the DLOG resource with id *resid*. The dialog "
"object is stored in :attr:`self.wid`."
msgstr ""
"ID *resid* の DLOG リソースからダイアログウィンドウを作成します。ダイアログオ"
"ブジェクトは :attr:`self.wid` に保存されます。"

#: ../../library/framework.rst:338
msgid ""
"Item number *item* was hit. You are responsible for redrawing toggle "
"buttons, etc."
msgstr ""
"アイテム番号 *item* がヒットされた時に呼ばれます。トグルボタンなどの再描画は"
"自分で処理してください。"
