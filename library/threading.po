# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2019
# Takanori Suzuki <takanori@takanory.net>, 2021
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-02-26 16:37+0000\n"
"PO-Revision-Date: 2019-09-01 03:32+0000\n"
"Last-Translator: Takanori Suzuki <takanori@takanory.net>, 2021\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/threading.rst:2
msgid ":mod:`threading` --- Thread-based parallelism"
msgstr ":mod:`threading` --- スレッドベースの並列処理"

#: ../../library/threading.rst:7
msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**ソースコード:** :source:`Lib/threading.py`"

#: ../../library/threading.rst:11
msgid ""
"This module constructs higher-level threading interfaces on top of the lower "
"level :mod:`_thread` module.  See also the :mod:`queue` module."
msgstr ""
"このモジュールでは、高水準のスレッドインタフェースをより低水準 な :mod:"
"`_thread` モジュールの上に構築しています。 :mod:`queue` モジュールのドキュメ"
"ントも参照してください。"

#: ../../library/threading.rst:14
msgid "This module used to be optional, it is now always available."
msgstr ""
"このモジュールは以前はオプションでしたが、常に利用可能なモジュールとなりまし"
"た。"

#: ../../library/threading.rst:19
msgid ""
"While they are not listed below, the ``camelCase`` names used for some "
"methods and functions in this module in the Python 2.x series are still "
"supported by this module."
msgstr ""
"ここには載っていませんが、Python 2.x シリーズでこのモジュールの一部のメソッド"
"や関数に使われていた ``camelCase`` 名は、まだこのモジュールでサポートされま"
"す。"

#: ../../library/threading.rst:26
msgid ""
"In CPython, due to the :term:`Global Interpreter Lock`, only one thread can "
"execute Python code at once (even though certain performance-oriented "
"libraries might overcome this limitation). If you want your application to "
"make better use of the computational resources of multi-core machines, you "
"are advised to use :mod:`multiprocessing` or :class:`concurrent.futures."
"ProcessPoolExecutor`. However, threading is still an appropriate model if "
"you want to run multiple I/O-bound tasks simultaneously."
msgstr ""
"CPython は :term:`Global Interpreter Lock` のため、ある時点で Python コードを"
"実行できるスレッドは1つに限られます (ただし、いくつかのパフォーマンスが強く求"
"められるライブラリはこの制限を克服しています)。アプリケーションにマルチコアマ"
"シンの計算能力をより良く利用させたい場合は、 :mod:`multiprocessing` モジュー"
"ルや :class:`concurrent.futures.ProcessPoolExecutor` の利用をお勧めします。 "
"ただし、I/Oバウンドなタスクを並行して複数走らせたい場合においては、 マルチス"
"レッドは正しい選択肢です。"

#: ../../library/threading.rst:36
msgid "This module defines the following functions:"
msgstr "このモジュールは以下の関数を定義しています:"

#: ../../library/threading.rst:41
msgid ""
"Return the number of :class:`Thread` objects currently alive.  The returned "
"count is equal to the length of the list returned by :func:`.enumerate`."
msgstr ""
"生存中の :class:`Thread` オブジェクトの数を返します。この数は :func:`."
"enumerate` の返すリストの長さと同じです。"

#: ../../library/threading.rst:47
msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""
"関数を呼び出している処理のスレッドに対応する :class:`Thread` オブジェクトを返"
"します。関数を呼び出している処理のスレッドが :mod:`threading` モジュールで生"
"成したものでない場合、限定的な機能しかもたないダミースレッドオブジェクトを返"
"します。"

#: ../../library/threading.rst:55
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"現在のスレッドの 'スレッドID' を返します。非ゼロの整数です。この値は直接の意"
"味を持っていません; 例えばスレッド特有のデータの辞書に索引をつけるためのよう"
"な、マジッククッキーとして意図されています。スレッドが終了し、他のスレッドが"
"作られたとき、スレッド ID は再利用されるかもしれません。"

#: ../../library/threading.rst:66
msgid ""
"Return a list of all :class:`Thread` objects currently alive.  The list "
"includes daemonic threads, dummy thread objects created by :func:"
"`current_thread`, and the main thread.  It excludes terminated threads and "
"threads that have not yet been started."
msgstr ""
"現在、生存中の :class:`Thread` オブジェクト全てのリストを返します。リストに"
"は、デーモンスレッド (daemonic thread)、 :func:`current_thread` の生成するダ"
"ミースレッドオブジェクト、そして主スレッドが入ります。終了したスレッドとまだ"
"開始していないスレッドは入りません。"

#: ../../library/threading.rst:74
msgid ""
"Return the main :class:`Thread` object.  In normal conditions, the main "
"thread is the thread from which the Python interpreter was started."
msgstr ""
"main :class:`Thread` オブジェクトを返します。通常の条件では、メインスレッドは"
"Pythonインタプリタが起動したスレッドを指します。"

#: ../../library/threading.rst:85
msgid ""
"Set a trace function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""
":mod:`threading` モジュールを使って開始した全てのスレッドにトレース関数を設定"
"します。 *func* は各スレッドの :meth:`~Thread.run` を呼び出す前にスレッドの :"
"func:`sys.settrace` に渡されます。"

#: ../../library/threading.rst:94
msgid ""
"Set a profile function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""
":mod:`threading` モジュールを使って開始した全てのスレッドにプロファイル関数を"
"設定します。 *func* は各スレッドの :meth:`~Thread.run` を呼び出す前にスレッド"
"の :func:`sys.setprofile` に渡されます。"

#: ../../library/threading.rst:101
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"新しいスレッドを作るときのスレッドスタックサイズを返します。オプションの "
"*size* 引数にはこれ以降に作成するスレッドのスタックサイズを指定し、0 (プラッ"
"トフォームのデフォルト値または設定されたデフォルト値) か、 32,768 (32 KiB) 以"
"上の正の整数でなければなりません。*size* が指定されない場合 0 が使われます。"
"スレッドのスタックサイズの変更がサポートされていない場合、 :exc:"
"`RuntimeError` を送出します。不正なスタックサイズが指定された場合、 :exc:"
"`ValueError` を送出して、スタックサイズは変更されません。32 KiB は現在のイン"
"タープリタ自身のために十分であると保証された最小のスタックサイズです。いくつ"
"かのプラットフォームではスタックサイズに対して制限があることに注意してくださ"
"い。例えば最小のスタックサイズが 32 KiB より大きかったり、システムのメモリ"
"ページサイズ の整数倍の必要があるなどです。この制限についてはプラットフォーム"
"のドキュメントを参照してください (一般的なページサイズは 4 KiB なので、プラッ"
"トフォームに関する情報がない場合は 4096 の整数倍のスタックサイズを選ぶといい"
"かもしれません)。"

#: ../../library/threading.rst:116
msgid ""
":ref:`Availability <availability>`: Windows, systems with POSIX threads."
msgstr ""

#: ../../library/threading.rst:119
msgid "This module also defines the following constant:"
msgstr "このモジュールでは以下の定数も定義しています:"

#: ../../library/threading.rst:123
msgid ""
"The maximum value allowed for the *timeout* parameter of blocking functions "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.). "
"Specifying a timeout greater than this value will raise an :exc:"
"`OverflowError`."
msgstr ""
"ブロックする関数 (:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:"
"`Condition.wait` など) の *timeout* 引数に許される最大値。これ以上の値を "
"timeout に指定すると :exc:`OverflowError` が発生します。"

#: ../../library/threading.rst:131
msgid ""
"This module defines a number of classes, which are detailed in the sections "
"below."
msgstr ""
"このモジュールは多くのクラスを定義しています。それらは下記のセクションで詳し"
"く説明されます。"

#: ../../library/threading.rst:134
msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of "
"every object, they are separate objects in Python.  Python's :class:`Thread` "
"class supports a subset of the behavior of Java's Thread class; currently, "
"there are no priorities, no thread groups, and threads cannot be destroyed, "
"stopped, suspended, resumed, or interrupted.  The static methods of Java's "
"Thread class, when implemented, are mapped to module-level functions."
msgstr ""
"このモジュールのおおまかな設計は Java のスレッドモデルに基づいています。とは"
"いえ、 Java がロックと条件変数を全てのオブジェクトの基本的な挙動にしているの"
"に対し、 Python ではこれらを別個のオブジェクトに分けています。 Python の :"
"class:`Thread` クラスがサポートしているのは Java の Thread クラスの挙動のサブ"
"セットにすぎません; 現状では、優先度 (priority)やスレッドグループがなく、ス"
"レッドの破壊 (destroy)、中断 (stop)、一時停止 (suspend)、復帰 (resume)、割り"
"込み (interrupt) は行えません。 Java の Thread クラスにおける静的メソッドに対"
"応する機能が実装されている場合にはモジュールレベルの関数になっています。"

#: ../../library/threading.rst:142
msgid "All of the methods described below are executed atomically."
msgstr "以下に説明するメソッドは全て原子的 (atomic) に実行されます。"

#: ../../library/threading.rst:146
msgid "Thread-Local Data"
msgstr "スレッドローカルデータ"

#: ../../library/threading.rst:148
msgid ""
"Thread-local data is data whose values are thread specific.  To manage "
"thread-local data, just create an instance of :class:`local` (or a subclass) "
"and store attributes on it::"
msgstr ""
"スレッドローカルデータは、その値がスレッド固有のデータです。スレッドローカル"
"データを管理するには、単に :class:`local` (あるいはそのサブクラス) のインスタ"
"ンスを作成して、その属性に値を設定してください::"

#: ../../library/threading.rst:155
msgid "The instance's values will be different for separate threads."
msgstr "インスタンスの値はスレッドごとに違った値になります。"

#: ../../library/threading.rst:160
msgid "A class that represents thread-local data."
msgstr "スレッドローカルデータを表現するクラス。"

#: ../../library/threading.rst:162
msgid ""
"For more details and extensive examples, see the documentation string of "
"the :mod:`_threading_local` module."
msgstr ""
"詳細と例題については、 :mod:`_threading_local` モジュールのドキュメンテーショ"
"ン文字列を参照してください。"

#: ../../library/threading.rst:169
msgid "Thread Objects"
msgstr "Thread オブジェクト"

#: ../../library/threading.rst:171
msgid ""
"The :class:`Thread` class represents an activity that is run in a separate "
"thread of control.  There are two ways to specify the activity: by passing a "
"callable object to the constructor, or by overriding the :meth:`~Thread.run` "
"method in a subclass.  No other methods (except for the constructor) should "
"be overridden in a subclass.  In other words, *only*  override the :meth:"
"`~Thread.__init__` and :meth:`~Thread.run` methods of this class."
msgstr ""
":class:`Thread` クラスは個別のスレッド中で実行されるアクティビティを表現しま"
"す。活動を決める方法は 2 つあり、一つは呼び出し可能オブジェクトをコンストラク"
"タへ渡す方法、もう一つはサブクラスで :meth:`~Thread.run` メソッドをオーバライ"
"ドする方法です。 (コンストラクタを除く) その他のメソッドは一切サブクラスで"
"オーバライドしてはなりません。言い換えるならば、このクラスの :meth:`~Thread."
"__init__` と :meth:`~Thread.run` メソッド *だけ* をオーバライドするということ"
"です。"

#: ../../library/threading.rst:178
msgid ""
"Once a thread object is created, its activity must be started by calling the "
"thread's :meth:`~Thread.start` method.  This invokes the :meth:`~Thread.run` "
"method in a separate thread of control."
msgstr ""
"ひとたびスレッドオブジェクトを生成すると、スレッドの :meth:`~Thread.start` メ"
"ソッドを呼び出してアクティビティを開始しなければなりません。 :meth:`start` メ"
"ソッド はそれぞれのスレッドの :meth:`~Thread.run` メソッドを起動します。"

#: ../../library/threading.rst:182
msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. It "
"stops being alive when its :meth:`~Thread.run` method terminates -- either "
"normally, or by raising an unhandled exception.  The :meth:`~Thread."
"is_alive` method tests whether the thread is alive."
msgstr ""
"スレッドのアクティビティが始まると、スレッドは '生存中 (alive)' とみなされま"
"す。 スレッドは、通常 :meth:`~Thread.run` メソッドが終了するまで、もしくは捕"
"捉されない例外が送出されるまで生存中となります。 :meth:`~Thread.is_alive` メ"
"ソッドは、スレッドが生存中であるかどうか調べます。"

#: ../../library/threading.rst:187
msgid ""
"Other threads can call a thread's :meth:`~Thread.join` method.  This blocks "
"the calling thread until the thread whose :meth:`~Thread.join` method is "
"called is terminated."
msgstr ""
"スレッドは他のスレッドの :meth:`~Thread.join` メソッドを呼び出すことができま"
"す。このメソッドは、 :meth:`~Thread.join` メソッドを呼ばれたスレッドが終了す"
"るまでメソッドの呼び出し元のスレッドをブロックします。"

#: ../../library/threading.rst:191
msgid ""
"A thread has a name.  The name can be passed to the constructor, and read or "
"changed through the :attr:`~Thread.name` attribute."
msgstr ""
"スレッドは名前を持っています。名前はコンストラクタに渡すことができ、 :attr:"
"`~Thread.name` 属性を通して読み出したり変更したりできます。"

#: ../../library/threading.rst:194
msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this "
"flag is that the entire Python program exits when only daemon threads are "
"left.  The initial value is inherited from the creating thread.  The flag "
"can be set through the :attr:`~Thread.daemon` property or the *daemon* "
"constructor argument."
msgstr ""
"スレッドには \"デーモンスレッド (daemon thread)\" であるというフラグを立てら"
"れます。 このフラグには、残っているスレッドがデーモンスレッドだけになった時"
"に Python プログラム全体を終了させるという意味があります。フラグの初期値はス"
"レッドを生成したスレッドから継承します。フラグの値は :attr:`~Thread.daemon` "
"プロパティまたは *daemon* コンストラクタ引数を通して設定できます。"

#: ../../library/threading.rst:201
msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such as "
"open files, database transactions, etc.) may not be released properly. If "
"you want your threads to stop gracefully, make them non-daemonic and use a "
"suitable signalling mechanism such as an :class:`Event`."
msgstr ""
"デーモンスレッドは終了時にいきなり停止されます。デーモンスレッドで使われたリ"
"ソース (開いているファイル、データベースのトランザクションなど) は適切に解放"
"されないかもしれません。きちんと (gracefully) スレッドを停止したい場合は、ス"
"レッドを非デーモンスレッドにして、:class:`Event` のような適切なシグナル送信機"
"構を使用してください。"

#: ../../library/threading.rst:206
msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread of "
"control in the Python program.  It is not a daemon thread."
msgstr ""
"スレッドには \"主スレッド (main thread)\" オブジェクトがあります。主スレッド"
"は Python プログラムを最初に制御していたスレッドです。主スレッドはデーモンス"
"レッドではありません。"

#: ../../library/threading.rst:209
msgid ""
"There is the possibility that \"dummy thread objects\" are created. These "
"are thread objects corresponding to \"alien threads\", which are threads of "
"control started outside the threading module, such as directly from C code.  "
"Dummy thread objects have limited functionality; they are always considered "
"alive and daemonic, and cannot be :meth:`~Thread.join`\\ ed.  They are never "
"deleted, since it is impossible to detect the termination of alien threads."
msgstr ""
"\"ダミースレッド (dummy thread)\" オブジェクトを作成することができます。 ダ"
"ミースレッドは、 \"外来スレッド (alien thread)\" に対応するスレッドオブジェク"
"トです。ダミースレッドは、 C コードから直接生成されたスレッドのような、 :mod:"
"`threading` モジュールの外で開始された処理スレッドです。 ダミースレッドオブ"
"ジェクトには限られた機能しかなく、常に生存中、かつデーモンスレッドであるとみ"
"なされ、 :meth:`~Thread.join` できません。また、外来スレッドの終了を検出する"
"のは不可能なので、ダミースレッドは削除できません。"

#: ../../library/threading.rst:220
msgid ""
"This constructor should always be called with keyword arguments.  Arguments "
"are:"
msgstr ""
"コンストラクタは常にキーワード引数を使って呼び出さなければなりません。各引数"
"は以下の通りです:"

#: ../../library/threading.rst:223
msgid ""
"*group* should be ``None``; reserved for future extension when a :class:"
"`ThreadGroup` class is implemented."
msgstr ""
"*group* は ``None`` でなければなりません。将来 :class:`ThreadGroup` クラスが"
"実装されたときの拡張用に予約されている引数です。"

#: ../../library/threading.rst:226
msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr ""
"*target* は :meth:`run` メソッドによって起動される呼び出し可能オブジェクトで"
"す。デフォルトでは何も呼び出さないことを示す ``None`` になっています。"

#: ../../library/threading.rst:229
msgid ""
"*name* is the thread name.  By default, a unique name is constructed of the "
"form \"Thread-*N*\" where *N* is a small decimal number."
msgstr ""
"*name* はスレッドの名前です。デフォルトでは、 *N* を小さな 10 進数として、 "
"\"Thread- *N*\" という形式の一意な名前を生成します。"

#: ../../library/threading.rst:232
msgid ""
"*args* is the argument tuple for the target invocation.  Defaults to ``()``."
msgstr ""
"*args* は *target* を呼び出すときの引数タプルです。デフォルトは ``()`` です。"

#: ../../library/threading.rst:234
msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr ""
"*kwargs* は *target* を呼び出すときのキーワード引数の辞書です。デフォルトは "
"``{}`` です。"

#: ../../library/threading.rst:237
msgid ""
"If not ``None``, *daemon* explicitly sets whether the thread is daemonic. If "
"``None`` (the default), the daemonic property is inherited from the current "
"thread."
msgstr ""
"``None`` でない場合、*daemon* はスレッドがデーモンかどうかを明示的に設定しま"
"す。``None`` の場合 (デフォルト)、デーモン属性は現在のスレッドから継承されま"
"す。"

#: ../../library/threading.rst:241
msgid ""
"If the subclass overrides the constructor, it must make sure to invoke the "
"base class constructor (``Thread.__init__()``) before doing anything else to "
"the thread."
msgstr ""
"サブクラスでコンストラクタをオーバライドした場合、必ずスレッドが何かを始める"
"前に基底クラスのコンストラクタ (``Thread.__init__()``) を呼び出しておかなくて"
"はなりません。"

#: ../../library/threading.rst:245
msgid "Added the *daemon* argument."
msgstr "*daemon* 引数が追加されました。"

#: ../../library/threading.rst:250
msgid "Start the thread's activity."
msgstr "スレッドのアクティビティの開始処理を行います。"

#: ../../library/threading.rst:252
msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`~Thread.run` method to be invoked in a separate thread of "
"control."
msgstr ""
"このメソッドは、スレッドオブジェクトあたり一度しか呼び出してはなりません。 :"
"meth:`~Thread.start` は、オブジェクトの :meth:`~Thread.run` メソッドが個別の"
"処理スレッド中で呼び出されるように調整します。"

#: ../../library/threading.rst:256
msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on the "
"same thread object."
msgstr ""
"同じスレッドオブジェクトに対し、このメソッドを2回以上呼び出した場合、 :exc:"
"`RuntimeError` を送出します。"

#: ../../library/threading.rst:261
msgid "Method representing the thread's activity."
msgstr "スレッドのアクティビティに相当するメソッドです。"

#: ../../library/threading.rst:263
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the "
"*target* argument, if any, with positional and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"このメソッドはサブクラスでオーバライドできます。標準の :meth:`run` メソッドで"
"は、オブジェクトのコンストラクタの *target* 引数に呼び出し可能オブジェクトを"
"指定した場合、 *args* および *kwargs* の位置引数およびキーワード引数とともに"
"呼び出します。"

#: ../../library/threading.rst:270
msgid ""
"Wait until the thread terminates. This blocks the calling thread until the "
"thread whose :meth:`~Thread.join` method is called terminates -- either "
"normally or through an unhandled exception -- or until the optional timeout "
"occurs."
msgstr ""
"スレッドが終了するまで待機します。\n"
"このメソッドは、 :meth:`~Thread.join` を呼ばれたスレッドが正常終了あるいは処"
"理されない例外によって終了するか、オプションのタイムアウトが発生するまで、メ"
"ソッドの呼び出し元のスレッドをブロックします。"

#: ../../library/threading.rst:275
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof). As :meth:`~Thread.join` always returns ``None``, you "
"must call :meth:`~Thread.is_alive` after :meth:`~Thread.join` to decide "
"whether a timeout happened -- if the thread is still alive, the :meth:"
"`~Thread.join` call timed out."
msgstr ""
"*timeout* 引数が存在して ``None`` 以外の場合、それは操作に対するタイムアウト"
"秒 (あるいは秒未満の端数) を表す浮動小数点数でなければなりません。 :meth:"
"`~Thread.join` は常に ``None`` を返すので、 :meth:`~Thread.join` の後に :"
"meth:`~Thread.is_alive` を呼び出してタイムアウトしたかどうかを確認しなければ"
"なりません。もしスレッドがまだ生存中であれば、 :meth:`~Thread.join` はタイム"
"アウトしています。"

#: ../../library/threading.rst:282
msgid ""
"When the *timeout* argument is not present or ``None``, the operation will "
"block until the thread terminates."
msgstr ""
"*timeout* が指定されないかまたは ``None`` であるときは、この操作はスレッドが"
"終了するまでブロックします。"

#: ../../library/threading.rst:285
msgid "A thread can be :meth:`~Thread.join`\\ ed many times."
msgstr "一つのスレッドに対して何度でも :meth:`~Thread.join` できます。"

#: ../../library/threading.rst:287
msgid ""
":meth:`~Thread.join` raises a :exc:`RuntimeError` if an attempt is made to "
"join the current thread as that would cause a deadlock. It is also an error "
"to :meth:`~Thread.join` a thread before it has been started and attempts to "
"do so raise the same exception."
msgstr ""
"現在のスレッドに対して :meth:`~Thread.join` を呼び出そうとすると、デッドロッ"
"クを引き起こすため :exc:`RuntimeError` が送出されます。 スレッドが開始される"
"前に :meth:`~Thread.join` を呼び出すことも同様のエラーのため、同じ例外が送出"
"されます。"

#: ../../library/threading.rst:294
msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by the "
"constructor."
msgstr ""
"識別のためにのみ用いられる文字列です。名前には機能上の意味づけ (semantics) は"
"ありません。複数のスレッドに同じ名前をつけてもかまいません。名前の初期値はコ"
"ンストラクタで設定されます。"

#: ../../library/threading.rst:301
msgid ""
"Old getter/setter API for :attr:`~Thread.name`; use it directly as a "
"property instead."
msgstr ""
":attr:`~Thread.name` に対する古い getter/setter API; 代わりにプロパティを直接"
"使用してください。"

#: ../../library/threading.rst:306
msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`get_ident` "
"function.  Thread identifiers may be recycled when a thread exits and "
"another thread is created.  The identifier is available even after the "
"thread has exited."
msgstr ""
"'スレッド識別子' 、または、スレッドが開始されていなければ ``None`` です。非ゼ"
"ロの整数です。 :func:`get_ident` 関数を参照下さい。スレッド識別子は、スレッド"
"が終了した後、新たなスレッドが生成された場合、再利用され得ます。スレッド識別"
"子は、スレッドが終了した後でも利用できます。"

#: ../../library/threading.rst:314
msgid "Return whether the thread is alive."
msgstr "スレッドが生存中かどうかを返します。"

#: ../../library/threading.rst:316
msgid ""
"This method returns ``True`` just before the :meth:`~Thread.run` method "
"starts until just after the :meth:`~Thread.run` method terminates.  The "
"module function :func:`.enumerate` returns a list of all alive threads."
msgstr ""
"このメソッドは、 :meth:`~Thread.run` メソッドが起動する直前から :meth:"
"`~Thread.run` メソッドが終了する直後までの間 ``True`` を返します。モジュール"
"関数 :func:`.enumerate` は、全ての生存中のスレッドのリストを返します。"

#: ../../library/threading.rst:322
msgid ""
"A boolean value indicating whether this thread is a daemon thread (True) or "
"not (False).  This must be set before :meth:`~Thread.start` is called, "
"otherwise :exc:`RuntimeError` is raised.  Its initial value is inherited "
"from the creating thread; the main thread is not a daemon thread and "
"therefore all threads created in the main thread default to :attr:`~Thread."
"daemon` = ``False``."
msgstr ""
"このスレッドがデーモンスレッドか (True) か否か (False) を示すブール値。この値"
"は :meth:`~Thread.start` の呼び出し前に設定されなければなりません。さもなけれ"
"ば :exc:`RuntimeError` が送出されます。初期値は生成側のスレッドから継承されま"
"す; メインスレッドはデーモンスレッドではないので、メインスレッドで作成された"
"すべてのスレッドは、デフォルトで :attr:`~Thread.daemon` = ``False`` になりま"
"す。"

#: ../../library/threading.rst:329
msgid ""
"The entire Python program exits when no alive non-daemon threads are left."
msgstr ""
"デーモンでない生存中のスレッドが全てなくなると、 Python プログラム全体が終了"
"します。"

#: ../../library/threading.rst:334
msgid ""
"Old getter/setter API for :attr:`~Thread.daemon`; use it directly as a "
"property instead."
msgstr ""
":attr:`~Thread.daemon` に対する古い getter/setter API; 代わりにプロパティを直"
"接使用してください。"

#: ../../library/threading.rst:341
msgid "Lock Objects"
msgstr "Lock オブジェクト"

#: ../../library/threading.rst:343
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest level "
"synchronization primitive available, implemented directly by the :mod:"
"`_thread` extension module."
msgstr ""
"プリミティブロックとは、ロックが生じた際に特定のスレッドによって所有されない"
"同期プリミティブです。 Python では現在のところ拡張モジュール :mod:`_thread` "
"で直接実装されている最も低水準の同期プリミティブを使えます。"

#: ../../library/threading.rst:348
msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It is "
"created in the unlocked state.  It has two basic methods, :meth:`~Lock."
"acquire` and :meth:`~Lock.release`.  When the state is unlocked, :meth:"
"`~Lock.acquire` changes the state to locked and returns immediately.  When "
"the state is locked, :meth:`~Lock.acquire` blocks until a call to :meth:"
"`~Lock.release` in another thread changes it to unlocked, then the :meth:"
"`~Lock.acquire` call resets it to locked and returns.  The :meth:`~Lock."
"release` method should only be called in the locked state; it changes the "
"state to unlocked and returns immediately. If an attempt is made to release "
"an unlocked lock, a :exc:`RuntimeError` will be raised."
msgstr ""
"プリミティブロックは2つの状態、 \"ロック\" または \"アンロック\" があります。"
"ロックはアンロック状態で作成されます。ロックには基本となる二つのメソッド、 :"
"meth:`~Lock.acquire` と :meth:`~Lock.release` があります。ロックの状態がアン"
"ロックである場合、 :meth:`~Lock.acquire` は状態をロックに変更して即座に処理を"
"戻します。 状態がロックの場合、 :meth:`~Lock.acquire` は他のスレッドが :meth:"
"`~Lock.release` を呼び出してロックの状態をアンロックに変更するまでブロックし"
"ます。その後、 :meth:`~Lock.acquire` 呼び出しは状態を再度ロックに設定してから"
"処理を戻します。 :meth:`~Lock.release` メソッドを呼び出すのはロック状態のとき"
"でなければなりません; このメソッドはロックの状態をアンロックに変更して、即座"
"に処理を戻します。 アンロックの状態のロックを解放しようとすると :exc:"
"`RuntimeError` が送出されます。"

#: ../../library/threading.rst:359
msgid "Locks also support the :ref:`context management protocol <with-locks>`."
msgstr ""
"ロックは :ref:`コンテキストマネージメントプロトコル <with-locks>` もサポート"
"します。"

#: ../../library/threading.rst:361
msgid ""
"When more than one thread is blocked in :meth:`~Lock.acquire` waiting for "
"the state to turn to unlocked, only one thread proceeds when a :meth:`~Lock."
"release` call resets the state to unlocked; which one of the waiting threads "
"proceeds is not defined, and may vary across implementations."
msgstr ""
"複数のスレッドにおいて :meth:`~Lock.acquire` がアンロック状態への遷移を待って"
"いるためにブロックが起きている時に :meth:`~Lock.release` を呼び出してロックの"
"状態をアンロックにすると、一つのスレッドだけが処理を進行できます。 どのスレッ"
"ドが処理を進行できるのかは定義されておらず、実装によって異なるかもしれませ"
"ん。"

#: ../../library/threading.rst:366
msgid "All methods are executed atomically."
msgstr "全てのメソッドはアトミックに実行されます。"

#: ../../library/threading.rst:371
msgid ""
"The class implementing primitive lock objects.  Once a thread has acquired a "
"lock, subsequent attempts to acquire it block, until it is released; any "
"thread may release it."
msgstr ""
"プリミティブロック (primitive lock) オブジェクトを実装しているクラスです。ス"
"レッドが一度ロックを獲得すると、それ以後のロック獲得の試みはロックが解放され"
"るまでブロックします。どのスレッドでもロックを解放できます。"

#: ../../library/threading.rst:375
msgid ""
"Note that ``Lock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete Lock class that is supported "
"by the platform."
msgstr ""
"``Lock`` は実際にはファクトリ関数で、プラットフォームでサポートされる最も効率"
"的なバージョンの具体的な Lock クラスのインスタンスを返すことに注意してくださ"
"い。"

#: ../../library/threading.rst:382 ../../library/threading.rst:462
msgid "Acquire a lock, blocking or non-blocking."
msgstr "ブロックあり、またはブロックなしでロックを獲得します。"

#: ../../library/threading.rst:384
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return ``True``."
msgstr ""
"引数 *blocking* を ``True`` (デフォルト) に設定して呼び出した場合、ロックがア"
"ンロック状態になるまでブロックします。そしてそれをロック状態にしてから "
"``True`` を返します。"

#: ../../library/threading.rst:387
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block. If "
"a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""
"引数 *blocking* の値を ``False`` にして呼び出すとブロックしません。"
"*blocking* を ``True`` にして呼び出した場合にブロックするような状況では、直ち"
"に ``False`` を返します。それ以外の場合には、ロックをロック状態にして "
"``True`` を返します。"

#: ../../library/threading.rst:391
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  A *timeout* argument of ``-1`` "
"specifies an unbounded wait.  It is forbidden to specify a *timeout* when "
"*blocking* is false."
msgstr ""
"正の値に設定された浮動小数点の *timeout* 引数とともに起動された場合、ロックを"
"得られなければ最大で *timeout* によって指定された秒数だけブロックします。"
"*timeout* 引数の ``-1`` は無制限の待機を指定します。*blocking* が false の場"
"合に *timeout* を指定することは禁止されています。"

#: ../../library/threading.rst:397
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not (for example if the *timeout* expired)."
msgstr ""
"ロックを獲得すると ``True`` を、ロックを獲得できなかったとき (例えば "
"*timeout* が過ぎた場合) には ``False`` を返します。"

#: ../../library/threading.rst:400 ../../library/threading.rst:484
#: ../../library/threading.rst:729
msgid "The *timeout* parameter is new."
msgstr "新しい *timeout* 引数。"

#: ../../library/threading.rst:403
msgid ""
"Lock acquisition can now be interrupted by signals on POSIX if the "
"underlying threading implementation supports it."
msgstr ""

#: ../../library/threading.rst:410
msgid ""
"Release a lock.  This can be called from any thread, not only the thread "
"which has acquired the lock."
msgstr ""
"ロックを解放します。これはロックを獲得したスレッドだけでなく、任意のスレッド"
"から呼ぶことができます。"

#: ../../library/threading.rst:413
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow exactly "
"one of them to proceed."
msgstr ""
"ロックの状態がロックのとき、状態をアンロックにリセットして処理を戻します。他"
"のスレッドがロックがアンロック状態になるのを待ってブロックしている場合、ただ"
"一つのスレッドだけが処理を継続できるようにします。"

#: ../../library/threading.rst:417
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr ""
"アンロック状態のロックに対して呼び出された場合、:exc:`RuntimeError` が送出さ"
"れます。"

#: ../../library/threading.rst:419 ../../library/threading.rst:500
msgid "There is no return value."
msgstr "戻り値はありません。"

#: ../../library/threading.rst:423
msgid "Return true if the lock is acquired."
msgstr "ロック状態のときに真を返します。"

#: ../../library/threading.rst:430
msgid "RLock Objects"
msgstr "RLock オブジェクト"

#: ../../library/threading.rst:432
msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the locked/unlocked "
"state used by primitive locks.  In the locked state, some thread owns the "
"lock; in the unlocked state, no thread owns it."
msgstr ""
"再入可能ロック (reentrant lock) とは、同じスレッドが複数回獲得できるような同"
"期プリミティブです。再入可能ロックの内部では、プリミティブロックの使うロック"
"／アンロック状態に加え、 \"所有スレッド (owning thread)\" と \"再帰レベル "
"(recursion level)\" という概念を用いています。ロック状態では何らかのスレッド"
"がロックを所有しており、アンロック状態ではいかなるスレッドもロックを所有して"
"いません。"

#: ../../library/threading.rst:438
msgid ""
"To lock the lock, a thread calls its :meth:`~RLock.acquire` method; this "
"returns once the thread owns the lock.  To unlock the lock, a thread calls "
"its :meth:`~Lock.release` method. :meth:`~Lock.acquire`/:meth:`~Lock."
"release` call pairs may be nested; only the final :meth:`~Lock.release` "
"(the :meth:`~Lock.release` of the outermost pair) resets the lock to "
"unlocked and allows another thread blocked in :meth:`~Lock.acquire` to "
"proceed."
msgstr ""
"このロックの状態をロックにするには、スレッドがロックの :meth:`~RLock."
"acquire` メソッドを呼び出します。このメソッドはスレッドがロックを所有すると処"
"理を戻します。ロックの状態をアンロックにするには :meth:`~Lock.release` メソッ"
"ドを呼び出します。 :meth:`~Lock.acquire` / :meth:`~Lock.release` からなるペア"
"の呼び出しはネストできます; 最後に呼び出した :meth:`~Lock.release` (最も外側"
"の呼び出しペアの :meth:`~Lock.release`) だけがロックの状態をアンロックにリ"
"セットして、 :meth:`~Lock.acquire` でブロック中の別のスレッドの処理を進行させ"
"ることができます。"

#: ../../library/threading.rst:445
msgid ""
"Reentrant locks also support the :ref:`context management protocol <with-"
"locks>`."
msgstr ""
"再入可能ロックは :ref:`コンテキストマネージメントプロトコル <with-locks>` も"
"サポートします。"

#: ../../library/threading.rst:450
msgid ""
"This class implements reentrant lock objects.  A reentrant lock must be "
"released by the thread that acquired it.  Once a thread has acquired a "
"reentrant lock, the same thread may acquire it again without blocking; the "
"thread must release it once for each time it has acquired it."
msgstr ""
"このクラスは再入可能ロックオブジェクトを実装します。再入可能ロックはそれを獲"
"得したスレッドによって解放されなければなりません。いったんスレッドが再入可能"
"ロックを獲得すると、同じスレッドはブロックされずにもう一度それを獲得できま"
"す ; そのスレッドは獲得した回数だけ解放しなければいけません。"

#: ../../library/threading.rst:455
msgid ""
"Note that ``RLock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete RLock class that is supported "
"by the platform."
msgstr ""
"``RLock`` は実際にはファクトリ関数で、プラットフォームでサポートされる最も効"
"率的なバージョンの具体的な RLock クラスのインスタンスを返すことに注意してくだ"
"さい。"

#: ../../library/threading.rst:464
msgid ""
"When invoked without arguments: if this thread already owns the lock, "
"increment the recursion level by one, and return immediately.  Otherwise, if "
"another thread owns the lock, block until the lock is unlocked.  Once the "
"lock is unlocked (not owned by any thread), then grab ownership, set the "
"recursion level to one, and return.  If more than one thread is blocked "
"waiting until the lock is unlocked, only one at a time will be able to grab "
"ownership of the lock. There is no return value in this case."
msgstr ""
"引数なしで呼び出した場合: スレッドが既にロックを所有している場合、再帰レベル"
"をインクリメントして即座に処理を戻します。それ以外の場合、他のスレッドがロッ"
"クを所有していれば、そのロックの状態がアンロックになるまでブロックします。そ"
"の後、ロックの状態がアンロックになる (いかなるスレッドもロックを所有しない状"
"態になる) と、ロックの所有権を獲得し、再帰レベルを 1 にセットして処理を戻しま"
"す。ロックの状態がアンロックになるのを待っているスレッドが複数ある場合、その"
"中の一つだけがロックの所有権を獲得できます。この場合、戻り値はありません。"

#: ../../library/threading.rst:472
msgid ""
"When invoked with the *blocking* argument set to true, do the same thing as "
"when called without arguments, and return ``True``."
msgstr ""
"引数 *blocking* の値を true にして呼び出した場合、引数なしで呼び出したときと"
"同じことを行ない、 ``True`` を返します。"

#: ../../library/threading.rst:475
msgid ""
"When invoked with the *blocking* argument set to false, do not block.  If a "
"call without an argument would block, return ``False`` immediately; "
"otherwise, do the same thing as when called without arguments, and return "
"``True``."
msgstr ""
"引数 *blocking* の値を false にして呼び出すとブロックしません。引数なしで呼び"
"出した場合にブロックするような状況であった場合には直ちに ``False`` を返しま"
"す。それ以外の場合には、引数なしで呼び出したときと同じ処理を行い ``True`` を"
"返します。"

#: ../../library/threading.rst:479
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  Return ``True`` if the lock has been "
"acquired, false if the timeout has elapsed."
msgstr ""
"正の値に設定された浮動小数点の *timeout* 引数とともに起動された場合、ロックを"
"得られなければ最大で *timeout* によって指定された秒数だけブロックします。ロッ"
"クを獲得した場合 ``True`` を返し、タイムアウトが過ぎた場合は false を返しま"
"す。"

#: ../../library/threading.rst:490
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement it "
"is zero, reset the lock to unlocked (not owned by any thread), and if any "
"other threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed.  If after the decrement the recursion level "
"is still nonzero, the lock remains locked and owned by the calling thread."
msgstr ""
"再帰レベルをデクリメントしてロックを解放します。デクリメント後に再帰レベルが"
"ゼロになった場合、ロックの状態をアンロック (いかなるスレッドにも所有されてい"
"ない状態) にリセットし、ロックの状態がアンロックになるのを待ってブロックして"
"いるスレッドがある場合にはその中のただ一つだけが処理を進行できるようにしま"
"す。デクリメント後も再帰レベルがゼロでない場合、ロックの状態はロックのまま"
"で、呼び出し側のスレッドに所有されたままになります。"

#: ../../library/threading.rst:496
msgid ""
"Only call this method when the calling thread owns the lock. A :exc:"
"`RuntimeError` is raised if this method is called when the lock is unlocked."
msgstr ""
"呼び出し側のスレッドがロックを所有しているときにのみこのメソッドを呼び出して"
"ください。ロックの状態がアンロックの時にこのメソッドを呼び出すと、 :exc:"
"`RuntimeError` が送出されます。"

#: ../../library/threading.rst:506
msgid "Condition Objects"
msgstr "Condition オブジェクト"

#: ../../library/threading.rst:508
msgid ""
"A condition variable is always associated with some kind of lock; this can "
"be passed in or one will be created by default.  Passing one in is useful "
"when several condition variables must share the same lock.  The lock is part "
"of the condition object: you don't have to track it separately."
msgstr ""
"条件変数 (condition variable) は、常にある種のロックに関連付けられています; "
"このロックは明示的に渡すことも、デフォルトで生成させることもできます。複数の"
"条件変数で同じロックを共有しなければならない場合には、引渡しによる関連付けが"
"便利です。ロックは条件オブジェクトの一部です: それを別々に扱う必要はありませ"
"ん。"

#: ../../library/threading.rst:513
msgid ""
"A condition variable obeys the :ref:`context management protocol <with-"
"locks>`: using the ``with`` statement acquires the associated lock for the "
"duration of the enclosed block.  The :meth:`~Condition.acquire` and :meth:"
"`~Condition.release` methods also call the corresponding methods of the "
"associated lock."
msgstr ""
"条件変数は :ref:`コンテキスト管理プロトコル <with-locks>` に従います: "
"``with`` 文を使って囲まれたブロックの間だけ関連付けられたロックを獲得すること"
"ができます。 :meth:`~Condition.acquire` メソッドと :meth:`~Condition."
"release` メソッドは、さらに関連付けられたロックの対応するメソッドを呼び出しま"
"す。"

#: ../../library/threading.rst:519
msgid ""
"Other methods must be called with the associated lock held.  The :meth:"
"`~Condition.wait` method releases the lock, and then blocks until another "
"thread awakens it by calling :meth:`~Condition.notify` or :meth:`~Condition."
"notify_all`.  Once awakened, :meth:`~Condition.wait` re-acquires the lock "
"and returns.  It is also possible to specify a timeout."
msgstr ""
"他のメソッドは、関連付けられたロックを保持した状態で呼び出さなければなりませ"
"ん。 :meth:`~Condition.wait` メソッドはロックを解放します。そして別のスレッド"
"が :meth:`~Condition.notify` または :meth:`~Condition.notify_all` を呼ぶこと"
"によってスレッドを起こすまでブロックします。一旦起こされたなら、 :meth:"
"`~Condition.wait` は再びロックを得て戻ります。タイムアウトを指定することも可"
"能です。"

#: ../../library/threading.rst:525
msgid ""
"The :meth:`~Condition.notify` method wakes up one of the threads waiting for "
"the condition variable, if any are waiting.  The :meth:`~Condition."
"notify_all` method wakes up all threads waiting for the condition variable."
msgstr ""
":meth:`~Condition.notify` メソッドは条件変数待ちのスレッドを1つ起こします。 :"
"meth:`~Condition.notify_all` メソッドは条件変数待ちの全てのスレッドを起こしま"
"す。"

#: ../../library/threading.rst:529
msgid ""
"Note: the :meth:`~Condition.notify` and :meth:`~Condition.notify_all` "
"methods don't release the lock; this means that the thread or threads "
"awakened will not return from their :meth:`~Condition.wait` call "
"immediately, but only when the thread that called :meth:`~Condition.notify` "
"or :meth:`~Condition.notify_all` finally relinquishes ownership of the lock."
msgstr ""
"注意: :meth:`~Condition.notify` と :meth:`~Condition.notify_all` はロックを解"
"放しません; 従って、スレッドが起こされたとき、 :meth:`~Condition.wait` の呼び"
"出しは即座に処理を戻すわけではなく、 :meth:`~Condition.notify` または :meth:"
"`~Condition.notify_all` を呼び出したスレッドが最終的にロックの所有権を放棄し"
"たときに初めて処理を返すのです。"

#: ../../library/threading.rst:535
msgid ""
"The typical programming style using condition variables uses the lock to "
"synchronize access to some shared state; threads that are interested in a "
"particular change of state call :meth:`~Condition.wait` repeatedly until "
"they see the desired state, while threads that modify the state call :meth:"
"`~Condition.notify` or :meth:`~Condition.notify_all` when they change the "
"state in such a way that it could possibly be a desired state for one of the "
"waiters.  For example, the following code is a generic producer-consumer "
"situation with unlimited buffer capacity::"
msgstr ""
"条件変数を使う典型的なプログラミングスタイルでは、何らかの共有された状態変数"
"へのアクセスを同期させるためにロックを使います; 状態変数が特定の状態に変化し"
"たことを知りたいスレッドは、自分の望む状態になるまで繰り返し :meth:"
"`~Condition.wait` を呼び出します。その一方で、状態変更を行うスレッドは、前者"
"のスレッドが待ち望んでいる状態であるかもしれないような状態へ変更を行ったとき"
"に :meth:`~Condition.notify` や :meth:`~Condition.notify_all` を呼び出しま"
"す。例えば、以下のコードは無制限のバッファ容量のときの一般的な生産者-消費者問"
"題です::"

#: ../../library/threading.rst:555
msgid ""
"The ``while`` loop checking for the application's condition is necessary "
"because :meth:`~Condition.wait` can return after an arbitrary long time, and "
"the condition which prompted the :meth:`~Condition.notify` call may no "
"longer hold true.  This is inherent to multi-threaded programming.  The :"
"meth:`~Condition.wait_for` method can be used to automate the condition "
"checking, and eases the computation of timeouts::"
msgstr ""
"アプリケーションの条件をチェックする ``while`` ループは必須です。なぜなら、 :"
"meth:`~Condition.wait` が任意の長時間の後で返り、 :meth:`~Condition.notify` "
"呼び出しを促した条件がもはや真でないことがありえるからです。これはマルチス"
"レッドプログラミングに固有です。条件チェックを自動化するために :meth:"
"`~Condition.wait_for` メソッドを使うことができ、それはタイムアウトの計算を簡"
"略化します::"

#: ../../library/threading.rst:567
msgid ""
"To choose between :meth:`~Condition.notify` and :meth:`~Condition."
"notify_all`, consider whether one state change can be interesting for only "
"one or several waiting threads.  E.g. in a typical producer-consumer "
"situation, adding one item to the buffer only needs to wake up one consumer "
"thread."
msgstr ""
":meth:`~Condition.notify` と :meth:`~Condition.notify_all` のどちらを使うか"
"は、その状態の変化に興味を持っている待ちスレッドが一つだけなのか、あるいは複"
"数なのかで考えます。例えば、典型的な生産者-消費者問題では、バッファに1つの要"
"素を加えた場合には消費者スレッドを 1 つしか起こさなくてかまいません。"

#: ../../library/threading.rst:575
msgid ""
"This class implements condition variable objects.  A condition variable "
"allows one or more threads to wait until they are notified by another thread."
msgstr ""
"このクラスは条件変数 (condition variable) オブジェクトを実装します。条件変数"
"を使うと、1つ以上のスレッドを別のスレッドの通知があるまで待機させておけます。"

#: ../../library/threading.rst:578
msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock` "
"or :class:`RLock` object, and it is used as the underlying lock.  Otherwise, "
"a new :class:`RLock` object is created and used as the underlying lock."
msgstr ""
"*lock* に ``None`` でない値を指定した場合、その値は :class:`Lock` または :"
"class:`RLock` オブジェクトでなければなりません。\n"
"この場合、 *lock* は根底にあるロックオブジェクトとして使われます。\n"
"それ以外の場合には、 :class:`RLock` オブジェクトを新しく作成して使います。"

#: ../../library/threading.rst:582 ../../library/threading.rst:704
#: ../../library/threading.rst:747 ../../library/threading.rst:799
#: ../../library/threading.rst:868
msgid "changed from a factory function to a class."
msgstr "ファクトリ関数からクラスに変更されました。"

#: ../../library/threading.rst:587
msgid ""
"Acquire the underlying lock. This method calls the corresponding method on "
"the underlying lock; the return value is whatever that method returns."
msgstr ""
"根底にあるロックを獲得します。このメソッドは根底にあるロックの対応するメソッ"
"ドを呼び出します。そのメソッドの戻り値を返します。"

#: ../../library/threading.rst:592
msgid ""
"Release the underlying lock. This method calls the corresponding method on "
"the underlying lock; there is no return value."
msgstr ""
"根底にあるロックを解放します。このメソッドは根底にあるロックの対応するメソッ"
"ドを呼び出します。戻り値はありません。"

#: ../../library/threading.rst:597
msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has not "
"acquired the lock when this method is called, a :exc:`RuntimeError` is "
"raised."
msgstr ""
"通知 (notify) を受けるか、タイムアウトするまで待機します。呼び出し側のスレッ"
"ドがロックを獲得していないときにこのメソッドを呼び出すと :exc:`RuntimeError` "
"が送出されます。"

#: ../../library/threading.rst:601
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another thread, or until the optional timeout occurs.  "
"Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""
"このメソッドは根底にあるロックを解放し、他のスレッドが同じ条件変数に対して :"
"meth:`notify` または :meth:`notify_all` を呼び出して現在のスレッドを起こす"
"か、オプションのタイムアウトが発生するまでブロックします。一度スレッドが起こ"
"されると、再度ロックを獲得して処理を戻します。"

#: ../../library/threading.rst:606
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""
"*timeout* 引数を指定して、 ``None`` 以外の値にする場合、タイムアウトを秒 (ま"
"たは端数秒) を表す浮動小数点数でなければなりません。"

#: ../../library/threading.rst:610
msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using its :"
"meth:`release` method, since this may not actually unlock the lock when it "
"was acquired multiple times recursively.  Instead, an internal interface of "
"the :class:`RLock` class is used, which really unlocks it even when it has "
"been recursively acquired several times. Another internal interface is then "
"used to restore the recursion level when the lock is reacquired."
msgstr ""
"根底にあるロックが :class:`RLock` である場合、 :meth:`release` メソッドでは"
"ロックは解放されません。というのも、ロックが再帰的に複数回獲得されている場合"
"には、 :meth:`release` によって実際にアンロックが行われないかもしれないからで"
"す。その代わり、ロックが再帰的に複数回獲得されていても確実にアンロックを行え"
"る :class:`RLock` クラスの内部インタフェースを使います。その後ロックを再獲得"
"する時に、もう一つの内部インタフェースを使ってロックの再帰レベルを復帰しま"
"す。"

#: ../../library/threading.rst:618
msgid ""
"The return value is ``True`` unless a given *timeout* expired, in which case "
"it is ``False``."
msgstr ""
"与えられた *timeout* が過ぎていなければ返り値は ``True`` です。タイムアウトし"
"た場合には ``False`` が返ります。"

#: ../../library/threading.rst:621 ../../library/threading.rst:833
msgid "Previously, the method always returned ``None``."
msgstr "以前は、このメソッドは常に ``None`` を返していました。"

#: ../../library/threading.rst:626
msgid ""
"Wait until a condition evaluates to true.  *predicate* should be a callable "
"which result will be interpreted as a boolean value. A *timeout* may be "
"provided giving the maximum time to wait."
msgstr ""
"条件が真と判定されるまで待ちます。\n"
"*predicate* は呼び出し可能オブジェクトでなければならず、その結果はブール値と"
"して解釈されます。\n"
"最大の待ち時間を指定する *timeout* を与えることができます。"

#: ../../library/threading.rst:630
msgid ""
"This utility method may call :meth:`wait` repeatedly until the predicate is "
"satisfied, or until a timeout occurs. The return value is the last return "
"value of the predicate and will evaluate to ``False`` if the method timed "
"out."
msgstr ""
"このユーティリティメソッドは、述語が満たされるかタイムアウトが発生するまで :"
"meth:`wait` を繰り返し呼び出す場合があります。戻り値は述語の最後の戻り値で、"
"もしメソッドがタイムアウトすれば、 ``False`` と評価されます。"

#: ../../library/threading.rst:635
msgid ""
"Ignoring the timeout feature, calling this method is roughly equivalent to "
"writing::"
msgstr ""
"タイムアウト機能を無視すれば、このメソッドの呼び出しは以下のように書くのとほ"
"ぼ等価です::"

#: ../../library/threading.rst:641
msgid ""
"Therefore, the same rules apply as with :meth:`wait`: The lock must be held "
"when called and is re-acquired on return.  The predicate is evaluated with "
"the lock held."
msgstr ""
"したがって、 :meth:`wait` と同じルールが適用されます: 呼び出された時にロック"
"を保持していなければならず、戻るときにロックが再度獲得されます。述語はロック"
"を保持した状態で評価されます。"

#: ../../library/threading.rst:649
msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the "
"calling thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"デフォルトで、この条件変数を待っている1つのスレッドを起こします。 呼び出し側"
"のスレッドがロックを獲得していないときにこのメソッドを呼び出すと :exc:"
"`RuntimeError` が送出されます。"

#: ../../library/threading.rst:653
msgid ""
"This method wakes up at most *n* of the threads waiting for the condition "
"variable; it is a no-op if no threads are waiting."
msgstr ""
"何らかの待機中スレッドがある場合、そのうち *n* スレッドを起こします。待機中の"
"スレッドがなければ何もしません。"

#: ../../library/threading.rst:656
msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""
"現在の実装では、少なくとも *n* スレッドが待機中であれば、ちょうど *n* スレッ"
"ドを起こします。とはいえ、この挙動に依存するのは安全ではありません。将来、実"
"装の最適化によって、複数のスレッドを起こすようになるかもしれないからです。"

#: ../../library/threading.rst:661
msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` call "
"until it can reacquire the lock.  Since :meth:`notify` does not release the "
"lock, its caller should."
msgstr ""
"注意: 起こされたスレッドは実際にロックを再獲得できるまで :meth:`wait` 呼び出"
"しから戻りません。 :meth:`notify` はロックを解放しないので、 :meth:`notify` "
"呼び出し側は明示的にロックを解放しなければなりません。"

#: ../../library/threading.rst:667
msgid ""
"Wake up all threads waiting on this condition.  This method acts like :meth:"
"`notify`, but wakes up all waiting threads instead of one. If the calling "
"thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"この条件を待っているすべてのスレッドを起こします。このメソッドは :meth:"
"`notify` のように動作しますが、 1 つではなくすべての待ちスレッドを起こしま"
"す。呼び出し側のスレッドがロックを獲得していない場合、 :exc:`RuntimeError` が"
"送出されます。"

#: ../../library/threading.rst:676
msgid "Semaphore Objects"
msgstr "Semaphore オブジェクト"

#: ../../library/threading.rst:678
msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger W. "
"Dijkstra (he used the names ``P()`` and ``V()`` instead of :meth:`~Semaphore."
"acquire` and :meth:`~Semaphore.release`)."
msgstr ""
"セマフォ (semaphore) は、計算機科学史上最も古い同期プリミティブの一つ で、草"
"創期のオランダ計算機科学者 Edsger W. Dijkstra によって発明されました (彼は :"
"meth:`~Semaphore.acquire` と :meth:`~Semaphore.release` の代わりに ``P()`` "
"と ``V()`` を使いました)。"

#: ../../library/threading.rst:683
msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`~Semaphore.acquire` call and incremented by each :meth:`~Semaphore.release` "
"call.  The counter can never go below zero; when :meth:`~Semaphore.acquire` "
"finds that it is zero, it blocks, waiting until some other thread calls :"
"meth:`~Semaphore.release`."
msgstr ""
"セマフォは :meth:`~Semaphore.acquire` でデクリメントされ :meth:`~Semaphore."
"release` でインクリメントされるような内部カウンタを管理します。 カウンタは決"
"してゼロより小さくはなりません; :meth:`~Semaphore.acquire` は、カウンタがゼロ"
"になっている場合、他のスレッドが :meth:`~Semaphore.release` を呼び出すまでブ"
"ロックします。"

#: ../../library/threading.rst:689
msgid ""
"Semaphores also support the :ref:`context management protocol <with-locks>`."
msgstr ""
"セマフォは :ref:`コンテキストマネージメントプロトコル <with-locks>` もサポー"
"トします。"

#: ../../library/threading.rst:694
msgid ""
"This class implements semaphore objects.  A semaphore manages an atomic "
"counter representing the number of :meth:`release` calls minus the number "
"of :meth:`acquire` calls, plus an initial value.  The :meth:`acquire` method "
"blocks if necessary until it can return without making the counter negative. "
"If not given, *value* defaults to 1."
msgstr ""

#: ../../library/threading.rst:700
msgid ""
"The optional argument gives the initial *value* for the internal counter; it "
"defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` is "
"raised."
msgstr ""
"オプションの引数には、内部カウンタの初期値を指定します。デフォルトは ``1`` で"
"す。与えられた *value* が 0 より小さい場合、 :exc:`ValueError` が送出されま"
"す。"

#: ../../library/threading.rst:709
msgid "Acquire a semaphore."
msgstr "セマフォを獲得します。"

#: ../../library/threading.rst:711
msgid "When invoked without arguments:"
msgstr ""

#: ../../library/threading.rst:713
msgid ""
"If the internal counter is larger than zero on entry, decrement it by one "
"and return ``True`` immediately."
msgstr ""

#: ../../library/threading.rst:715
msgid ""
"If the internal counter is zero on entry, block until awoken by a call to :"
"meth:`~Semaphore.release`.  Once awoken (and the counter is greater than 0), "
"decrement the counter by 1 and return ``True``.  Exactly one thread will be "
"awoken by each call to :meth:`~Semaphore.release`.  The order in which "
"threads are awoken should not be relied on."
msgstr ""

#: ../../library/threading.rst:721
msgid ""
"When invoked with *blocking* set to false, do not block.  If a call without "
"an argument would block, return ``False`` immediately; otherwise, do the "
"same thing as when called without arguments, and return ``True``."
msgstr ""
"*blocking* を false にして呼び出すとブロックしません。引数なしで呼び出した場"
"合にブロックするような状況であった場合には直ちに ``False`` を返します。それ以"
"外の場合には、引数なしで呼び出したときと同じ処理を行い ``True`` を返します。"

#: ../../library/threading.rst:725
msgid ""
"When invoked with a *timeout* other than ``None``, it will block for at most "
"*timeout* seconds.  If acquire does not complete successfully in that "
"interval, return ``False``.  Return ``True`` otherwise."
msgstr ""
"``None`` 以外の *timeout* で起動された場合、最大で *timeout* 秒ブロックしま"
"す。\n"
"acquire が その間隔の間で完了しなかった場合は ``False`` が返ります。そうでな"
"ければ ``True`` が返ります。"

#: ../../library/threading.rst:734
msgid ""
"Release a semaphore, incrementing the internal counter by one.  When it was "
"zero on entry and another thread is waiting for it to become larger than "
"zero again, wake up that thread."
msgstr ""
"内部カウンタを 1 インクリメントして、セマフォを解放します。 :meth:`release` "
"処理に入ったときにカウンタがゼロであり、カウンタの値がゼロより大きくなるのを"
"待っている別のスレッドがあった場合、そのスレッドを起こします。"

#: ../../library/threading.rst:741
msgid ""
"Class implementing bounded semaphore objects.  A bounded semaphore checks to "
"make sure its current value doesn't exceed its initial value.  If it does, :"
"exc:`ValueError` is raised. In most situations semaphores are used to guard "
"resources with limited capacity.  If the semaphore is released too many "
"times it's a sign of a bug.  If not given, *value* defaults to 1."
msgstr ""
"有限セマフォ (bounded semaphore) オブジェクトを実装しているクラスです。有限セ"
"マフォは、現在の値が初期値を超過しないようチェックを行います。超過を起こした"
"場合、 :exc:`ValueError` を送出します。たいていの場合、セマフォは限られた容量"
"のリソースを保護するために使われるものです。従って、あまりにも頻繁なセマフォ"
"の解放はバグが生じているしるしです。 *value* を指定しない場合、デフォルトの値"
"は 1 になります。"

#: ../../library/threading.rst:754
msgid ":class:`Semaphore` Example"
msgstr ":class:`Semaphore` の例"

#: ../../library/threading.rst:756
msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the resource "
"is fixed, you should use a bounded semaphore.  Before spawning any worker "
"threads, your main thread would initialize the semaphore::"
msgstr ""
"セマフォはしばしば、容量に限りのある資源、例えばデータベースサーバなどを保護"
"するために使われます。リソースが固定の状況では、常に有限セマフォを使わなけれ"
"ばなりません。主スレッドは、作業スレッドを立ち上げる前にセマフォを初期化しま"
"す::"

#: ../../library/threading.rst:765
msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr ""
"作業スレッドは、ひとたび立ち上がると、サーバへ接続する必要が生じたときにセマ"
"フォの :meth:`acquire` および :meth:`release` メソッドを呼び出します::"

#: ../../library/threading.rst:775
msgid ""
"The use of a bounded semaphore reduces the chance that a programming error "
"which causes the semaphore to be released more than it's acquired will go "
"undetected."
msgstr ""
"有限セマフォを使うと、セマフォを獲得回数以上に解放してしまうというプログラム"
"上の間違いを見逃しにくくします。"

#: ../../library/threading.rst:782
msgid "Event Objects"
msgstr "Event オブジェクト"

#: ../../library/threading.rst:784
msgid ""
"This is one of the simplest mechanisms for communication between threads: "
"one thread signals an event and other threads wait for it."
msgstr ""
"イベントは、あるスレッドがイベントを発信し、他のスレッドはそれを待つという、"
"スレッド間で通信を行うための最も単純なメカニズムの一つです。"

#: ../../library/threading.rst:787
msgid ""
"An event object manages an internal flag that can be set to true with the :"
"meth:`~Event.set` method and reset to false with the :meth:`~Event.clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is true."
msgstr ""
"イベントオブジェクトは内部フラグを管理します。このフラグは :meth:`~Event."
"set` メソッドで値を true に、 :meth:`~Event.clear` メソッドで値を false にリ"
"セットします。 :meth:`~Event.wait` メソッドはフラグが true になるまでブロック"
"します。"

#: ../../library/threading.rst:794
msgid ""
"Class implementing event objects.  An event manages a flag that can be set "
"to true with the :meth:`~Event.set` method and reset to false with the :meth:"
"`clear` method.  The :meth:`wait` method blocks until the flag is true. The "
"flag is initially false."
msgstr ""
"イベントオブジェクトを実装しているクラスです。イベントは :meth:`~Event.set` "
"メソッドを使うと :const:`True` に、 :meth:`clear` メソッドを使うと :const:"
"`False` にセットされるようなフラグを管理します。 :meth:`wait` メソッドは、全"
"てのフラグが true になるまでブロックするようになっています。フラグの初期値は "
"false です。"

#: ../../library/threading.rst:804
msgid "Return ``True`` if and only if the internal flag is true."
msgstr "内部フラグが真のとき ``True`` を返します。"

#: ../../library/threading.rst:808
msgid ""
"Set the internal flag to true. All threads waiting for it to become true are "
"awakened. Threads that call :meth:`wait` once the flag is true will not "
"block at all."
msgstr ""
"内部フラグの値を true にセットします。フラグの値が true になるのを待っている"
"全てのスレッドを起こします。一旦フラグが true になると、スレッドが :meth:"
"`wait` を呼び出しても全くブロックしなくなります。"

#: ../../library/threading.rst:814
msgid ""
"Reset the internal flag to false. Subsequently, threads calling :meth:`wait` "
"will block until :meth:`.set` is called to set the internal flag to true "
"again."
msgstr ""
"内部フラグの値を false にリセットします。以降は、 :meth:`.set` を呼び出して再"
"び内部フラグの値を true にセットするまで、 :meth:`wait` を呼び出したスレッド"
"はブロックするようになります。"

#: ../../library/threading.rst:820
msgid ""
"Block until the internal flag is true.  If the internal flag is true on "
"entry, return immediately.  Otherwise, block until another thread calls :"
"meth:`.set` to set the flag to true, or until the optional timeout occurs."
msgstr ""
"内部フラグの値が true になるまでブロックします。 :meth:`wait` 処理に入った時"
"点で内部フラグの値が true であれば、直ちに処理を戻します。そうでない場合、他"
"のスレッドが :meth:`.set` を呼び出してフラグの値を true にセットするか、オプ"
"ションのタイムアウトが発生するまでブロックします。"

#: ../../library/threading.rst:824
msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""
"*timeout* 引数を指定して、 ``None`` 以外の値にする場合、タイムアウトを秒 (ま"
"たは端数秒) を表す浮動小数点数でなければなりません。"

#: ../../library/threading.rst:828
msgid ""
"This method returns ``True`` if and only if the internal flag has been set "
"to true, either before the wait call or after the wait starts, so it will "
"always return ``True`` except if a timeout is given and the operation times "
"out."
msgstr ""
"このメソッドは、wait 呼び出しの前あるいは wait が開始した後に、内部フラグが "
"true にセットされている場合に限り ``True`` を返します。したがって、タイムアウ"
"トが与えられて操作がタイムアウトした場合を除き常に ``True`` を返します。"

#: ../../library/threading.rst:840
msgid "Timer Objects"
msgstr "Timer オブジェクト"

#: ../../library/threading.rst:842
msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of :"
"class:`Thread` and as such also functions as an example of creating custom "
"threads."
msgstr ""
"このクラスは、一定時間経過後に実行される活動、すなわちタイマ活動を表現しま"
"す。 :class:`Timer` は :class:`Thread` のサブクラスであり、自作のスレッドを構"
"築した一例でもあります。"

#: ../../library/threading.rst:846
msgid ""
"Timers are started, as with threads, by calling their :meth:`~Timer.start` "
"method.  The timer can be stopped (before its action has begun) by calling "
"the :meth:`~Timer.cancel` method.  The interval the timer will wait before "
"executing its action may not be exactly the same as the interval specified "
"by the user."
msgstr ""
"タイマは :meth:`~Timer.start` メソッドを呼び出すとスレッドとして作動し始めし"
"ます。 (活動を開始する前に) :meth:`~Timer.cancel` メソッドを呼び出すと、タイ"
"マを停止できます。タイマが活動を実行するまでの待ち時間は、ユーザが指定した待"
"ち時間と必ずしも厳密には一致しません。"

#: ../../library/threading.rst:852
msgid "For example::"
msgstr "例えば::"

#: ../../library/threading.rst:863
msgid ""
"Create a timer that will run *function* with arguments *args* and  keyword "
"arguments *kwargs*, after *interval* seconds have passed. If *args* is "
"``None`` (the default) then an empty list will be used. If *kwargs* is "
"``None`` (the default) then an empty dict will be used."
msgstr ""
"*interval* 秒後に引数 *args* キーワード引数 *kwargs* で *function* を実行する"
"ようなタイマを生成します。*args*が ``None`` (デフォルト) なら空のリストが使用"
"されます。*kwargs* が ``None`` (デフォルト) なら空の辞書が使用されます。"

#: ../../library/threading.rst:873
msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This will "
"only work if the timer is still in its waiting stage."
msgstr ""
"タイマをストップして、その動作の実行をキャンセルします。このメソッドはタイマ"
"がまだ活動待ち状態にある場合にのみ動作します。"

#: ../../library/threading.rst:878
msgid "Barrier Objects"
msgstr "バリアオブジェクト"

#: ../../library/threading.rst:882
msgid ""
"This class provides a simple synchronization primitive for use by a fixed "
"number of threads that need to wait for each other.  Each of the threads "
"tries to pass the barrier by calling the :meth:`~Barrier.wait` method and "
"will block until all of the threads have made their :meth:`~Barrier.wait` "
"calls. At this point, the threads are released simultaneously."
msgstr ""

#: ../../library/threading.rst:888
msgid ""
"The barrier can be reused any number of times for the same number of threads."
msgstr "バリアは同じ数のスレッドに対して何度でも再利用することができます。"

#: ../../library/threading.rst:890
msgid ""
"As an example, here is a simple way to synchronize a client and server "
"thread::"
msgstr ""
"例として、クライアントとサーバの間でスレッドを同期させる単純な方法を紹介しま"
"す::"

#: ../../library/threading.rst:910
msgid ""
"Create a barrier object for *parties* number of threads.  An *action*, when "
"provided, is a callable to be called by one of the threads when they are "
"released.  *timeout* is the default timeout value if none is specified for "
"the :meth:`wait` method."
msgstr ""
"*parties* 個のスレッドのためのバリアオブジェクトを作成します。 *action* は、"
"もし提供されるなら呼び出し可能オブジェクトで、スレッドが解放される時にそのう"
"ちの1つによって呼ばれます。 *timeout* は、 :meth:`wait` メソッドに対して "
"none が指定された場合のデフォルトのタイムアウト値です。"

#: ../../library/threading.rst:917
msgid ""
"Pass the barrier.  When all the threads party to the barrier have called "
"this function, they are all released simultaneously.  If a *timeout* is "
"provided, it is used in preference to any that was supplied to the class "
"constructor."
msgstr ""
"バリアを通ります。バリアに対するすべてのスレッドがこの関数を呼んだ時に、それ"
"らは同時にすべて解放されます。*timeout* が提供される場合、それはクラスコンス"
"トラクタに渡された値に優先して使用されます。"

#: ../../library/threading.rst:922
msgid ""
"The return value is an integer in the range 0 to *parties* -- 1, different "
"for each thread.  This can be used to select a thread to do some special "
"housekeeping, e.g.::"
msgstr ""
"返り値は 0 から *parties* -- 1 の範囲の整数で、それぞれのスレッドに対して異な"
"ります。これは、特別な後始末 (housekeeping) を行うスレッドを選択するために使"
"用することができます。例えば::"

#: ../../library/threading.rst:931
msgid ""
"If an *action* was provided to the constructor, one of the threads will have "
"called it prior to being released.  Should this call raise an error, the "
"barrier is put into the broken state."
msgstr ""
"*action* がコンストラクタに渡されていれば、スレッドのうちの1つが解放される前"
"にそれを呼び出します。万一この呼び出しでエラーが発生した場合、バリアは "
"broken な状態に陥ります。"

#: ../../library/threading.rst:935
msgid "If the call times out, the barrier is put into the broken state."
msgstr "この呼び出しがタイムアウトする場合、バリアは broken な状態に陥ります。"

#: ../../library/threading.rst:937
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a thread is waiting."
msgstr ""
"スレッドが待っている間にバリアが broken になるかリセットされた場合、このメ"
"ソッドは :class:`BrokenBarrierError` 例外を送出するかもしれません。"

#: ../../library/threading.rst:942
msgid ""
"Return the barrier to the default, empty state.  Any threads waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""
"バリアをデフォルトの空の状態に戻します。そのバリアの上で待っているすべてのス"
"レッドは :class:`BrokenBarrierError` 例外を受け取ります。"

#: ../../library/threading.rst:945
msgid ""
"Note that using this function may can require some external synchronization "
"if there are other threads whose state is unknown.  If a barrier is broken "
"it may be better to just leave it and create a new one."
msgstr ""
"状態が未知の他のスレッドがある場合、この関数を使用するのに何らかの外部同期を"
"必要とするかもしれないことに注意してください。バリアが broken な場合、単にそ"
"れをそのままにして新しいものを作成する方がよいでしょう。"

#: ../../library/threading.rst:951
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`wait` to fail with the :class:`BrokenBarrierError`.  Use this for "
"example if one of the needs to abort, to avoid deadlocking the application."
msgstr ""
"バリアを broken な状態にします。これによって、現在または将来の :meth:`wait` "
"呼び出しが :class:`BrokenBarrierError` とともに失敗するようになります。これを"
"使うと、例えば異常終了する必要がある場合にアプリケーションがデッドロックする"
"のを避けることができます。"

#: ../../library/threading.rst:956
msgid ""
"It may be preferable to simply create the barrier with a sensible *timeout* "
"value to automatically guard against one of the threads going awry."
msgstr ""
"スレッドのうちの1つが返ってこないことに対して自動的に保護するように、単純に常"
"識的な *timeout* 値でバリアを作成することは望ましいかもしれません。"

#: ../../library/threading.rst:962
msgid "The number of threads required to pass the barrier."
msgstr "バリアを通るために要求されるスレッドの数。"

#: ../../library/threading.rst:966
msgid "The number of threads currently waiting in the barrier."
msgstr "現在バリアの中で待っているスレッドの数。"

#: ../../library/threading.rst:970
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr "バリアが broken な状態である場合に ``True`` となるブール値。"

#: ../../library/threading.rst:975
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr ""
":class:`Barrier` オブジェクトがリセットされるか broken な場合に、この例外 (:"
"exc:`RuntimeError` のサブクラス) が送出されます。"

#: ../../library/threading.rst:982
msgid ""
"Using locks, conditions, and semaphores in the :keyword:`!with` statement"
msgstr ":keyword:`!with` 文でのロック・条件変数・セマフォの使い方"

#: ../../library/threading.rst:984
msgid ""
"All of the objects provided by this module that have :meth:`acquire` and :"
"meth:`release` methods can be used as context managers for a :keyword:`with` "
"statement.  The :meth:`acquire` method will be called when the block is "
"entered, and :meth:`release` will be called when the block is exited.  "
"Hence, the following snippet::"
msgstr ""
"このモジュールのオブジェクトのうち :meth:`acquire` メソッドと :meth:"
"`release` メソッドを備えているものは全て :keyword:`with` 文のコンテキストマ"
"ネージャ として使うことができます。 :keyword:`with` 文のブロックに入るとき"
"に :meth:`acquire` メソッドが 呼び出され、ブロック脱出時には :meth:`release` "
"メソッドが呼ばれます。したがって、次のコード::"

#: ../../library/threading.rst:993
msgid "is equivalent to::"
msgstr "は、以下と同じです ::"

#: ../../library/threading.rst:1001
msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, :class:"
"`Semaphore`, and :class:`BoundedSemaphore` objects may be used as :keyword:"
"`with` statement context managers."
msgstr ""
"現在のところ、 :class:`Lock` 、 :class:`RLock` 、 :class:`Condition` 、 :"
"class:`Semaphore` 、 :class:`BoundedSemaphore` を :keyword:`with` 文のコンテ"
"キストマネージャとして使うことができます。"
