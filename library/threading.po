# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/threading.rst:2
msgid ":mod:`threading` --- Higher-level threading interface"
msgstr ":mod:`threading` --- 高水準のスレッドインタフェース"

#: ../../library/threading.rst:7
msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**ソースコード:** :source:`Lib/threading.py`"

#: ../../library/threading.rst:11
msgid ""
"This module constructs higher-level threading interfaces on top of the  "
"lower level :mod:`thread` module. See also the :mod:`mutex` and :mod:`Queue` "
"modules."
msgstr ""
"このモジュールでは、高水準のスレッドインタフェースをより低水準な :mod:"
"`thread` モジュールの上に構築しています。 :mod:`mutex` と :mod:`Queue` モ"
"ジュールのドキュメントも参照下さい。"

#: ../../library/threading.rst:15
msgid ""
"The :mod:`dummy_threading` module is provided for situations where :mod:"
"`threading` cannot be used because :mod:`thread` is missing."
msgstr ""
"また、 :mod:`thread` がないために :mod:`threading` を使えないような状況向け"
"に :mod:`dummy_threading` を提供しています。"

#: ../../library/threading.rst:20
msgid ""
"Starting with Python 2.6, this module provides :pep:`8` compliant aliases "
"and properties to replace the ``camelCase`` names that were inspired by "
"Java's threading API. This updated API is compatible with that of the :mod:"
"`multiprocessing` module. However, no schedule has been set for the "
"deprecation of the ``camelCase`` names and they remain fully supported in "
"both Python 2.x and 3.x."
msgstr ""
"Python 2.6 からこのモジュールは Java のスレッディング API の影響を受けた "
"``camelCase`` のプロパティを置き換える :pep:`8` に準拠したエイリアスを提供し"
"ます。この更新された API は :mod:`multiprocessing` モジュールのものと互換で"
"す。しかしながら、 ``camelCase`` の名称の廃止の予定は決まっておらず、 Python "
"2.x と 3.x の両方でサポートされ続けます。"

#: ../../library/threading.rst:29
msgid ""
"Starting with Python 2.5, several Thread methods raise :exc:`RuntimeError` "
"instead of :exc:`AssertionError` if called erroneously."
msgstr ""
"Python 2.5 から, 幾つかの Thread のメソッドは間違った呼び出しに対して :exc:"
"`AssertionError` の代わりに :exc:`RuntimeError` を返します。"

#: ../../library/threading.rst:34
msgid ""
"In CPython, due to the :term:`Global Interpreter Lock`, only one thread can "
"execute Python code at once (even though certain performance-oriented "
"libraries might overcome this limitation). If you want your application to "
"make better use of the computational resources of multi-core machines, you "
"are advised to use :mod:`multiprocessing`. However, threading is still an "
"appropriate model if you want to run multiple I/O-bound tasks simultaneously."
msgstr ""
"CPython は :term:`Global Interpreter Lock` のため、ある時点で Python コードを"
"実行できるスレッドは1つに限られます (ただし、いくつかのパフォーマンスが強く求"
"められるライブラリはこの制限を克服しています)。アプリケーションにマルチコアマ"
"シンの計算能力をより良く利用させたい場合は、 :mod:`multiprocessing` モジュー"
"ルの利用をお勧めします。 ただし、I/Oバウンドなタスクを並行して複数走らせたい"
"場合においては、 マルチスレッドは正しい選択肢です。"

#: ../../library/threading.rst:43
msgid "This module defines the following functions and objects:"
msgstr "このモジュールでは以下のような関数とオブジェクトを定義しています:"

#: ../../library/threading.rst:48
msgid ""
"Return the number of :class:`Thread` objects currently alive.  The returned "
"count is equal to the length of the list returned by :func:`.enumerate`."
msgstr ""
"生存中の :class:`Thread` オブジェクトの数を返します。この数は :func:`."
"enumerate` の返すリストの長さと同じです。"

#: ../../library/threading.rst:51
msgid "Added ``active_count()`` spelling."
msgstr "新たに ``active_count()`` として使えるようになりました。"

#: ../../library/threading.rst:58
msgid ""
"A factory function that returns a new condition variable object. A condition "
"variable allows one or more threads to wait until they are notified by "
"another thread."
msgstr ""
"新しい条件変数 (condition variable) オブジェクトを返すファクトリ関数です。条"
"件変数を使うと、ある複数のスレッドを別のスレッドの通知があるまで待機させられ"
"ます。"

#: ../../library/threading.rst:62
msgid "See :ref:`condition-objects`."
msgstr ":ref:`condition-objects` を参照してください。"

#: ../../library/threading.rst:68
msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""
"関数を呼び出している処理のスレッドに対応する :class:`Thread` オブジェクトを返"
"します。関数を呼び出している処理のスレッドが :mod:`threading` モジュールで生"
"成したものでない場合、限定的な機能しかもたないダミースレッドオブジェクトを返"
"します。"

#: ../../library/threading.rst:73
msgid "Added ``current_thread()`` spelling."
msgstr "新たに ``current_thread()`` として使えるようになりました。"

#: ../../library/threading.rst:79
msgid ""
"Return a list of all :class:`Thread` objects currently alive.  The list "
"includes daemonic threads, dummy thread objects created by :func:"
"`current_thread`, and the main thread.  It excludes terminated threads and "
"threads that have not yet been started."
msgstr ""
"現在、生存中の :class:`Thread` オブジェクト全てのリストを返します。リストに"
"は、デーモンスレッド (daemonic thread)、 :func:`current_thread` の生成するダ"
"ミースレッドオブジェクト、そして主スレッドが入ります。終了したスレッドとまだ"
"開始していないスレッドは入りません。"

#: ../../library/threading.rst:88
msgid ""
"A factory function that returns a new event object.  An event manages a flag "
"that can be set to true with the :meth:`~Event.set` method and reset to "
"false with the :meth:`clear` method.  The :meth:`wait` method blocks until "
"the flag is true."
msgstr ""
"新たなイベントオブジェクトを返すファクトリ関数です。イベントは :meth:`~Event."
"set` メソッドを使うと :const:`True` に、 :meth:`clear` メソッドを使うと :"
"const:`False` にセットされるようなフラグを管理します。 :meth:`wait` メソッド"
"は、全てのフラグが真になるまでブロックするようになっています。"

#: ../../library/threading.rst:93
msgid "See :ref:`event-objects`."
msgstr ":ref:`event-objects` を参照してください。"

#: ../../library/threading.rst:98
msgid ""
"A class that represents thread-local data.  Thread-local data are data whose "
"values are thread specific.  To manage thread-local data, just create an "
"instance of :class:`local` (or a subclass) and store attributes on it::"
msgstr ""
"スレッドローカルデータ (thread-local data) を表現するためのクラスです。スレッ"
"ドローカルデータとは、値が各スレッド固有になるようなデータです。スレッドロー"
"カルデータを管理するには、 :class:`local` (または :class:`local` のサブクラ"
"ス) のインスタンスを作成して、その属性に値を代入します ::"

#: ../../library/threading.rst:105
msgid "The instance's values will be different for separate threads."
msgstr "インスタンスの値はスレッドごとに違った値になります。"

#: ../../library/threading.rst:107
msgid ""
"For more details and extensive examples, see the documentation string of "
"the :mod:`_threading_local` module."
msgstr ""
"詳細と例題については、 :mod:`_threading_local` モジュールのドキュメンテーショ"
"ン文字列を参照してください。"

#: ../../library/threading.rst:115
msgid ""
"A factory function that returns a new primitive lock object.  Once a thread "
"has acquired it, subsequent attempts to acquire it block, until it is "
"released; any thread may release it."
msgstr ""
"新しいプリミティブロック (primitive lock) オブジェクトを返すファクトリ関数で"
"す。スレッドが一度プリミティブロックを獲得すると、それ以後のロック獲得の試み"
"はロックが解放されるまでブロックします。どのスレッドでもロックを解放できま"
"す。"

#: ../../library/threading.rst:119
msgid "See :ref:`lock-objects`."
msgstr ":ref:`lock-objects` を参照してください。"

#: ../../library/threading.rst:124
msgid ""
"A factory function that returns a new reentrant lock object. A reentrant "
"lock must be released by the thread that acquired it. Once a thread has "
"acquired a reentrant lock, the same thread may acquire it again without "
"blocking; the thread must release it once for each time it has acquired it."
msgstr ""
"新しい再入可能ロックオブジェクトを返すファクトリ関数です。再入可能ロックはそ"
"れを獲得したスレッドによって解放されなければなりません。いったんスレッドが再"
"入可能ロックを獲得すると、同じスレッドはブロックされずにもう一度それを獲得で"
"きます ; そのスレッドは獲得した回数だけ解放しなければいけません。"

#: ../../library/threading.rst:129
msgid "See :ref:`rlock-objects`."
msgstr ":ref:`rlock-objects` を参照してください。"

#: ../../library/threading.rst:135
msgid ""
"A factory function that returns a new semaphore object.  A semaphore manages "
"a counter representing the number of :meth:`release` calls minus the number "
"of :meth:`acquire` calls, plus an initial value. The :meth:`acquire` method "
"blocks if necessary until it can return without making the counter "
"negative.  If not given, *value* defaults to 1."
msgstr ""
"新しいセマフォ (semaphore) オブジェクトを返すファクトリ関数です。セマフォ"
"は、 :meth:`release` を呼び出した数から :meth:`acquire` を呼び出した数を引"
"き、初期値を足した値を表すカウンタを管理します。 :meth:`acquire` メソッドは、"
"カウンタの値を負にせずに処理を戻せるまで必要ならば処理をブロックします。 "
"*value* を指定しない場合、デフォルトの値は 1 になります。"

#: ../../library/threading.rst:141
msgid "See :ref:`semaphore-objects`."
msgstr ":ref:`semaphore-objects` を参照してください。"

#: ../../library/threading.rst:146
msgid ""
"A factory function that returns a new bounded semaphore object.  A bounded "
"semaphore checks to make sure its current value doesn't exceed its initial "
"value.  If it does, :exc:`ValueError` is raised. In most situations "
"semaphores are used to guard resources with limited capacity.  If the "
"semaphore is released too many times it's a sign of a bug.  If not given, "
"*value* defaults to 1."
msgstr ""
"新しい有限セマフォ (bounded semaphore) オブジェクトを返すファクトリ関数です。"
"有限セマフォは、現在の値が初期値を超過しないようチェックを行います。超過を起"
"こした場合、 :exc:`ValueError` を送出します。たいていの場合、セマフォは限られ"
"た容量のリソースを保護するために使われるものです。従って、あまりにも頻繁なセ"
"マフォの解放はバグが生じているしるしです。 *value* を指定しない場合、デフォル"
"トの値は 1 になります。"

#: ../../library/threading.rst:156
msgid ""
"A class that represents a thread of control.  This class can be safely "
"subclassed in a limited fashion."
msgstr ""
"処理中のスレッドを表すクラスです。このクラスは制限のある範囲内で安全にサブク"
"ラス化できます。"

#: ../../library/threading.rst:159
msgid "See :ref:`thread-objects`."
msgstr ":ref:`thread-objects` を参照してください。"

#: ../../library/threading.rst:165
msgid ""
"A thread that executes a function after a specified interval has passed."
msgstr "指定時間経過後に関数を実行するスレッドです。"

#: ../../library/threading.rst:167
msgid "See :ref:`timer-objects`."
msgstr ":ref:`timer-objects` を参照してください。"

#: ../../library/threading.rst:174
msgid ""
"Set a trace function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""
":mod:`threading` モジュールを使って開始した全てのスレッドにトレース関数を設定"
"します。 *func* は各スレッドの :meth:`~Thread.run` を呼び出す前にスレッドの :"
"func:`sys.settrace` に渡されます。"

#: ../../library/threading.rst:185
msgid ""
"Set a profile function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""
":mod:`threading` モジュールを使って開始した全てのスレッドにプロファイル関数を"
"設定します。 *func* は各スレッドの :meth:`~Thread.run` を呼び出す前にスレッド"
"の :func:`sys.setprofile` に渡されます。"

#: ../../library/threading.rst:194
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`ThreadError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32kB is currently "
"the minimum supported stack size value to guarantee sufficient stack space "
"for the interpreter itself.  Note that some platforms may have particular "
"restrictions on values for the stack size, such as requiring a minimum stack "
"size > 32kB or requiring allocation in multiples of the system memory page "
"size - platform documentation should be referred to for more information "
"(4kB pages are common; using multiples of 4096 for the stack size is the "
"suggested approach in the absence of more specific information). "
"Availability: Windows, systems with POSIX threads."
msgstr ""
"新しいスレッドを作るときのスレッドスタックサイズを返します。オプションの "
"*size* 引数は、これ以降に作成するスレッドのスタックサイズを指定するもので、 "
"0 (プラットフォームか設定されたデフォルト値) か、 32,768 (32 KiB) 以上の正の"
"整数である必要があります。 *size* を指定しない場合、0 が使われます。スレッド"
"のスタックサイズの変更がサポートされていない場合、 :exc:`ThreadError` を発生"
"させます。不正なスタックサイズが指定された場合、 :exc:`ValueError` を発生させ"
"て、スタックサイズを変更しません。 32 KiB が現在のインタープリター自体のため"
"に十分であると保証された最小のスタックサイズです。いくつかのプラットフォーム"
"ではスタックサイズに対して制限があることに注意してください。例えば最小のス"
"タックサイズが 32 KiB より大きかったり、システムのメモリページサイズ の整数倍"
"の必要があるなどです。この制限についてはプラットフォームのドキュメントを参照"
"する必要があります。 (一般的なページサイズは 4 KiB なので、プラットフォームに"
"関する情報がない場合は 4096 の整数倍のスタックサイズを選ぶといいかもしれませ"
"ん)。利用可能な環境: Windows, POSIX スレッドに対応したシステム。"

#: ../../library/threading.rst:215
msgid ""
"Raised for various threading-related errors as described below.  Note that "
"many interfaces use :exc:`RuntimeError` instead of :exc:`ThreadError`."
msgstr ""
"下記で記述するスレッド関連の様々なエラーで送出されます。多くのインターフェイ"
"スが :exc:`ThreadError` ではなく :exc:`RuntimeError` を使っていることに注意し"
"てください。"

#: ../../library/threading.rst:219
msgid "Detailed interfaces for the objects are documented below."
msgstr "オブジェクトの詳細なインターフェースを以下に説明します。"

#: ../../library/threading.rst:221
msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of "
"every object, they are separate objects in Python.  Python's :class:`Thread` "
"class supports a subset of the behavior of Java's Thread class; currently, "
"there are no priorities, no thread groups, and threads cannot be destroyed, "
"stopped, suspended, resumed, or interrupted.  The static methods of Java's "
"Thread class, when implemented, are mapped to module-level functions."
msgstr ""
"このモジュールのおおまかな設計は Java のスレッドモデルに基づいています。とは"
"いえ、 Java がロックと条件変数を全てのオブジェクトの基本的な挙動にしているの"
"に対し、 Python ではこれらを別個のオブジェクトに分けています。 Python の :"
"class:`Thread` クラスがサポートしているのは Java の Thread クラスの挙動のサブ"
"セットにすぎません; 現状では、優先度 (priority)やスレッドグループがなく、ス"
"レッドの破壊 (destroy)、中断 (stop)、一時停止 (suspend)、復帰 (resume)、割り"
"込み (interrupt) は行えません。 Java の Thread クラスにおける静的メソッドに対"
"応する機能が実装されている場合にはモジュールレベルの関数になっています。"

#: ../../library/threading.rst:229
msgid "All of the methods described below are executed atomically."
msgstr "以下に説明するメソッドは全て原子的 (atomic) に実行されます。"

#: ../../library/threading.rst:235
msgid "Thread Objects"
msgstr "Thread オブジェクト"

#: ../../library/threading.rst:237
msgid ""
"This class represents an activity that is run in a separate thread of "
"control. There are two ways to specify the activity: by passing a callable "
"object to the constructor, or by overriding the :meth:`run` method in a "
"subclass.  No other methods (except for the constructor) should be "
"overridden in a subclass.  In other words,  *only*  override the :meth:"
"`__init__` and :meth:`run` methods of this class."
msgstr ""
"このクラスは個別のスレッド中で実行される活動 (activity) を表現します。活動を"
"決める方法は 2 つあり、一つは呼出し可能オブジェクトをコンストラクタへ渡す方"
"法、もう一つはサブクラスで :meth:`run` メソッドをオーバライドする方法です。 "
"(コンストラクタを除く) その他のメソッドは一切サブクラスでオーバライドしてはな"
"りません。言い換えるならば、このクラスの :meth:`__init__` と :meth:`run` メ"
"ソッド *だけ* をオーバライドしてくださいということです。"

#: ../../library/threading.rst:244
msgid ""
"Once a thread object is created, its activity must be started by calling the "
"thread's :meth:`start` method.  This invokes the :meth:`run` method in a "
"separate thread of control."
msgstr ""
"ひとたびスレッドオブジェクトを生成すると、スレッドの :meth:`start` メソッドを"
"呼び出して活動を開始せねばなりません。 :meth:`start` メソッドはそれぞれのス"
"レッドの :meth:`run` メソッドを起動します。"

#: ../../library/threading.rst:248
msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. It "
"stops being alive when its :meth:`run` method terminates -- either normally, "
"or by raising an unhandled exception.  The :meth:`is_alive` method tests "
"whether the thread is alive."
msgstr ""
"スレッドの活動が始まると、スレッドは '生存中 (alive)' とみなされます。スレッ"
"ドは通常 :meth:`run` メソッドが終了するまで生存中となります。もしくは、捕捉さ"
"れない例外が送出されるまでです。 :meth:`is_alive` メソッドはスレッドが生存中"
"であるかどうか調べます。"

#: ../../library/threading.rst:253
msgid ""
"Other threads can call a thread's :meth:`join` method.  This blocks the "
"calling thread until the thread whose :meth:`join` method is called is "
"terminated."
msgstr ""
"他のスレッドはスレッドの :meth:`join` メソッドを呼び出せます。このメソッド"
"は、 :meth:`join` を呼び出されたスレッドが終了するまで、メソッドの呼び出し手"
"となるスレッドをブロックします。"

#: ../../library/threading.rst:256
msgid ""
"A thread has a name.  The name can be passed to the constructor, and read or "
"changed through the :attr:`name` attribute."
msgstr ""
"スレッドには名前があります。名前はコンストラクタに渡したり、または、 :attr:"
"`name` 属性を通して読み出したり、変更したりできます。"

#: ../../library/threading.rst:259
msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this "
"flag is that the entire Python program exits when only daemon threads are "
"left.  The initial value is inherited from the creating thread.  The flag "
"can be set through the :attr:`daemon` property."
msgstr ""
"スレッドには \"デーモンスレッド (daemon thread)\" であるというフラグを立てら"
"れます。このフラグには、残っているスレッドがデーモンスレッドだけになった時に "
"Python プログラム全体を終了させるという意味があります。フラグの初期値はスレッ"
"ドを生成する側のスレッドから継承します。フラグの値は :attr:`daemon` 属性を通"
"して設定できます。"

#: ../../library/threading.rst:265
msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such as "
"open files, database transactions, etc.) may not be released properly. If "
"you want your threads to stop gracefully, make them non-daemonic and use a "
"suitable signalling mechanism such as an :class:`Event`."
msgstr ""
"デーモンスレッドは終了時にいきなり停止されます。デーモンスレッドで使われたリ"
"ソース (開いているファイル、データベースのトランザクションなど) は適切に解放"
"されないかもしれません。きちんと (gracefully) スレッドを停止したい場合は、ス"
"レッドを非デーモンスレッドにして、:class:`Event` のような適切なシグナル送信機"
"構を使用してください。"

#: ../../library/threading.rst:270
msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread of "
"control in the Python program.  It is not a daemon thread."
msgstr ""
"スレッドには \"主スレッド (main thread)\" オブジェクトがあります。主スレッド"
"は Python プログラムを最初に制御していたスレッドです。主スレッドはデーモンス"
"レッドではありません。"

#: ../../library/threading.rst:273
msgid ""
"There is the possibility that \"dummy thread objects\" are created. These "
"are thread objects corresponding to \"alien threads\", which are threads of "
"control started outside the threading module, such as directly from C code.  "
"Dummy thread objects have limited functionality; they are always considered "
"alive and daemonic, and cannot be :meth:`join`\\ ed.  They are never "
"deleted, since it is impossible to detect the termination of alien threads."
msgstr ""
"\"ダミースレッド (dummy thread)\" オブジェクトを作成できる場合があります。ダ"
"ミースレッドは、 \"外来スレッド (alien thread)\" に相当するスレッドオブジェク"
"トです。ダミースレッドは、C コードから直接生成されたスレッドのような、 :mod:"
"`threading` モジュールの外で開始された処理スレッドです。ダミースレッドオブ"
"ジェクトには限られた機能しかなく、常に生存中、かつデーモンスレッドであるとみ"
"なされ、 :meth:`join` できません。また、外来スレッドの終了を検出するのは不可"
"能なので、ダミースレッドは削除できません。"

#: ../../library/threading.rst:283
msgid ""
"This constructor should always be called with keyword arguments.  Arguments "
"are:"
msgstr ""
"コンストラクタは常にキーワード引数を使って呼び出さなければなりません。各引数"
"は以下の通りです:"

#: ../../library/threading.rst:286
msgid ""
"*group* should be ``None``; reserved for future extension when a :class:"
"`ThreadGroup` class is implemented."
msgstr ""
"*group* は ``None`` でなければなりません。将来 :class:`ThreadGroup` クラスが"
"実装されたときの拡張用に予約されている引数です。"

#: ../../library/threading.rst:289
msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr ""
"*target* は :meth:`run` メソッドによって起動される呼び出し可能オブジェクトで"
"す。デフォルトでは何も呼び出さないことを示す ``None`` になっています。"

#: ../../library/threading.rst:292
msgid ""
"*name* is the thread name.  By default, a unique name is constructed of the "
"form \"Thread-*N*\" where *N* is a small decimal number."
msgstr ""
"*name* はスレッドの名前です。デフォルトでは、 *N* を小さな 10 進数として、 "
"\"Thread- *N*\" という形式の一意な名前を生成します。"

#: ../../library/threading.rst:295
msgid ""
"*args* is the argument tuple for the target invocation.  Defaults to ``()``."
msgstr ""
"*args* は *target* を呼び出すときの引数タプルです。デフォルトは ``()`` です。"

#: ../../library/threading.rst:297
msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr ""
"*kwargs* は *target* を呼び出すときのキーワード引数の辞書です。デフォルトは "
"``{}`` です。"

#: ../../library/threading.rst:300
msgid ""
"If the subclass overrides the constructor, it must make sure to invoke the "
"base class constructor (``Thread.__init__()``) before doing anything else to "
"the thread."
msgstr ""
"サブクラスでコンストラクタをオーバライドした場合、必ずスレッドが何かを始める"
"前に基底クラスのコンストラクタ (``Thread.__init__()``) を呼び出しておかなくて"
"はなりません。"

#: ../../library/threading.rst:306
msgid "Start the thread's activity."
msgstr "スレッドの活動を開始します。"

#: ../../library/threading.rst:308
msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate thread of control."
msgstr ""
"このメソッドは、スレッドオブジェクトあたり一度しか呼び出してはなりません。 :"
"meth:`start` は、オブジェクトの :meth:`run` メソッドが個別の処理スレッド中で"
"呼び出されるように調整します。"

#: ../../library/threading.rst:311
msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on the "
"same thread object."
msgstr ""
"同じスレッドオブジェクトに対し、このメソッドを2回以上呼び出した場合、 :exc:"
"`RuntimeError` を送出します。"

#: ../../library/threading.rst:316
msgid "Method representing the thread's activity."
msgstr "スレッドの活動をもたらすメソッドです。"

#: ../../library/threading.rst:318
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the "
"*target* argument, if any, with sequential and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"このメソッドはサブクラスでオーバライドできます。標準の :meth:`run` メソッドで"
"は、オブジェクトのコンストラクタの *target* 引数に呼び出し可能オブジェクトを"
"指定した場合、 *args* および *kwargs* の引数列およびキーワード引数とともに呼"
"び出します。"

#: ../../library/threading.rst:325
msgid ""
"Wait until the thread terminates. This blocks the calling thread until the "
"thread whose :meth:`join` method is called terminates -- either normally or "
"through an unhandled exception -- or until the optional timeout occurs."
msgstr ""
"スレッドが終了するまで待機します。このメソッドは、 :meth:`join` を呼び出され"
"たスレッドが、正常終了あるいは処理されない例外によって終了するか、オプション"
"のタイムアウトが発生するまで、メソッドの呼び出し手となるスレッドをブロックし"
"ます。"

#: ../../library/threading.rst:329
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof). As :meth:`join` always returns ``None``, you must call :"
"meth:`isAlive` after :meth:`join` to decide whether a timeout happened -- if "
"the thread is still alive, the :meth:`join` call timed out."
msgstr ""
"*timeout* 引数を指定して、 ``None`` 以外の値にする場合、タイムアウトを秒 (ま"
"たは端数秒) を表す浮動小数点数でなければなりません。 :meth:`join` はいつでも "
"``None`` を返すので、 :meth:`isAlive` を呼び出してタイムアウトしたかどうかを"
"確認しなければなりません。もしスレッドがまだ生存中であれば、 :meth:`join` は"
"タイムアウトしています。"

#: ../../library/threading.rst:335
msgid ""
"When the *timeout* argument is not present or ``None``, the operation will "
"block until the thread terminates."
msgstr ""
"*timeout* が指定されないかまたは ``None`` であるときは、この操作はスレッドが"
"終了するまでブロックします。"

#: ../../library/threading.rst:338
msgid "A thread can be :meth:`join`\\ ed many times."
msgstr "一つのスレッドに対して何度でも :meth:`join` できます。"

#: ../../library/threading.rst:340
msgid ""
":meth:`join` raises a :exc:`RuntimeError` if an attempt is made to join the "
"current thread as that would cause a deadlock. It is also an error to :meth:"
"`join` a thread before it has been started and attempts to do so raises the "
"same exception."
msgstr ""
"実行中のスレッドに対し、 :meth:`join` を呼び出そうとすると、デッドロックを引"
"き起こすため、 :exc:`RuntimeError` が送出されます。スレッドが開始される前に :"
"meth:`join` を呼び出そうとしても、同じ例外が送出されます。"

#: ../../library/threading.rst:347
msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by the "
"constructor."
msgstr ""
"識別のためにのみ用いられる文字列です。名前には機能上の意味づけ (semantics) は"
"ありません。複数のスレッドに同じ名前をつけてもかまいません。名前の初期値はコ"
"ンストラクタで設定されます。"

#: ../../library/threading.rst:356
msgid "Pre-2.6 API for :attr:`~Thread.name`."
msgstr ":attr:`~Thread.name` の、Python 2.6 以前の API です。"

#: ../../library/threading.rst:360
msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`thread."
"get_ident()` function.  Thread identifiers may be recycled when a thread "
"exits and another thread is created.  The identifier is available even after "
"the thread has exited."
msgstr ""
"'スレッド識別子' 、または、スレッドが開始されていなければ ``None`` です。非ゼ"
"ロの整数です。 :func:`thread.get_ident()` 関数を参照下さい。スレッド識別子"
"は、スレッドが終了した後、新たなスレッドが生成された場合、再利用され得ます。"
"スレッド識別子は、スレッドが終了した後でも利用できます。"

#: ../../library/threading.rst:371
msgid "Return whether the thread is alive."
msgstr "スレッドが生存中かどうかを返します。"

#: ../../library/threading.rst:373
msgid ""
"This method returns ``True`` just before the :meth:`run` method starts until "
"just after the :meth:`run` method terminates.  The module function :func:`."
"enumerate` returns a list of all alive threads."
msgstr ""
"このメソッドは :meth:`run` メソッドが起動した直後からその :meth:`run` メソッ"
"ドが終了するまでの間 ``True`` を返します。モジュール関数、 :func:`enumerate` "
"は、全ての生存中のスレッドのリストを返します。"

#: ../../library/threading.rst:377
msgid "Added ``is_alive()`` spelling."
msgstr "新たに ``is_alive()`` として使えるようになりました。"

#: ../../library/threading.rst:382
msgid ""
"A boolean value indicating whether this thread is a daemon thread (True) or "
"not (False).  This must be set before :meth:`start` is called, otherwise :"
"exc:`RuntimeError` is raised.  Its initial value is inherited from the "
"creating thread; the main thread is not a daemon thread and therefore all "
"threads created in the main thread default to :attr:`daemon` = ``False``."
msgstr ""
"スレッドのデーモンフラグです。このフラグは :meth:`start` の呼び出し前に設定さ"
"れなければなりません。さもなくば、 :exc:`RuntimeError` が送出されます。初期値"
"は生成側のスレッドから継承されます。メインスレッドはデーモンスレッドではない"
"ので、メインスレッドから生成するスレッドはデフォルトで :attr:`daemon` = "
"``False`` です。"

#: ../../library/threading.rst:389
msgid ""
"The entire Python program exits when no alive non-daemon threads are left."
msgstr ""
"デーモンでない生存中のスレッドが全てなくなると、 Python プログラム全体が終了"
"します。"

#: ../../library/threading.rst:396
msgid "Pre-2.6 API for :attr:`~Thread.daemon`."
msgstr ":attr:`~Thread.daemon` の、Python 2.6 以前の API です。"

#: ../../library/threading.rst:402
msgid "Lock Objects"
msgstr "Lock オブジェクト"

#: ../../library/threading.rst:404
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest level "
"synchronization primitive available, implemented directly by the :mod:"
"`thread` extension module."
msgstr ""
"プリミティブロックとは、ロックが生じた際に特定のスレッドによって所有されない"
"同期プリミティブです。 Python では現在のところ拡張モジュール :mod:`thread` で"
"直接実装されている最も低水準の同期プリミティブを使えます。"

#: ../../library/threading.rst:409
msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It is "
"created in the unlocked state.  It has two basic methods, :meth:`acquire` "
"and :meth:`release`.  When the state is unlocked, :meth:`acquire` changes "
"the state to locked and returns immediately.  When the state is locked, :"
"meth:`acquire` blocks until a call to :meth:`release` in another thread "
"changes it to unlocked, then the :meth:`acquire` call resets it to locked "
"and returns.  The :meth:`release` method should only be called in the locked "
"state; it changes the state to unlocked and returns immediately. If an "
"attempt is made to release an unlocked lock, a :exc:`ThreadError` will be "
"raised."
msgstr ""
"プリミティブロックは2つの状態、 \"ロック\" または \"アンロック\" があります。"
"このロックはアンロック状態で作成されます。ロックには基本となる二つのメソッ"
"ド、 :meth:`acquire` と :meth:`release` があります。ロックの状態がアンロック"
"である場合、 :meth:`acquire` は状態をロックに変更して即座に処理を戻します。状"
"態がロックの場合、 :meth:`acquire` は他のスレッドが :meth:`release` を呼出し"
"てロックの状態をアンロックに変更するまでブロックします。その後、状態をロック"
"に再度設定してから処理を戻します。 :meth:`release` メソッドを呼び出すのはロッ"
"ク状態のときでなければなりません; このメソッドはロックの状態をアンロックに変"
"更し、即座に処理を戻します。アンロックの状態のロックを解放しようとすると :"
"exc:`ThreadError` が送出されます。"

#: ../../library/threading.rst:419
msgid ""
"When more than one thread is blocked in :meth:`acquire` waiting for the "
"state to turn to unlocked, only one thread proceeds when a :meth:`release` "
"call resets the state to unlocked; which one of the waiting threads proceeds "
"is not defined, and may vary across implementations."
msgstr ""
"複数のスレッドにおいて :meth:`acquire` がアンロック状態への遷移を待っているた"
"めにブロックが起きている時に :meth:`release` を呼び出してロックの状態をアン"
"ロックにすると、一つのスレッドだけが処理を進行できます。どのスレッドが処理を"
"進行できるのかは定義されておらず、実装によって異なるかもしれません。"

#: ../../library/threading.rst:424
msgid "All methods are executed atomically."
msgstr "全てのメソッドはアトミックに実行されます。"

#: ../../library/threading.rst:429 ../../library/threading.rst:477
msgid "Acquire a lock, blocking or non-blocking."
msgstr "ブロックあり、またはブロックなしでロックを獲得します。"

#: ../../library/threading.rst:431
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return ``True``."
msgstr ""
"引数 *blocking* を ``True`` (デフォルト) に設定して呼び出した場合、ロックがア"
"ンロック状態になるまでブロックします。そしてそれをロック状態にしてから "
"``True`` を返します。"

#: ../../library/threading.rst:434
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block. If "
"a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""
"引数 *blocking* の値を ``False`` にして呼び出すとブロックしません。"
"*blocking* を ``True`` にして呼び出した場合にブロックするような状況では、直ち"
"に ``False`` を返します。それ以外の場合には、ロックをロック状態にして "
"``True`` を返します。"

#: ../../library/threading.rst:441
msgid "Release a lock."
msgstr "ロックを解放します。"

#: ../../library/threading.rst:443
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow exactly "
"one of them to proceed."
msgstr ""
"ロックの状態がロックのとき、状態をアンロックにリセットして処理を戻します。他"
"のスレッドがロックがアンロック状態になるのを待ってブロックしている場合、ただ"
"一つのスレッドだけが処理を継続できるようにします。"

#: ../../library/threading.rst:447
msgid "When invoked on an unlocked lock, a :exc:`ThreadError` is raised."
msgstr ""
"アンロック状態のロックに対して起動された場合、 :exc:`ThreadError` が送出され"
"ます。"

#: ../../library/threading.rst:449 ../../library/threading.rst:507
msgid "There is no return value."
msgstr "戻り値はありません。"

#: ../../library/threading.rst:459
msgid "RLock Objects"
msgstr "RLock オブジェクト"

#: ../../library/threading.rst:461
msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the locked/unlocked "
"state used by primitive locks.  In the locked state, some thread owns the "
"lock; in the unlocked state, no thread owns it."
msgstr ""
"再入可能ロック (reentrant lock) とは、同じスレッドが複数回獲得できるような同"
"期プリミティブです。再入可能ロックの内部では、プリミティブロックの使うロック"
"／アンロック状態に加え、 \"所有スレッド (owning thread)\" と \"再帰レベル "
"(recursion level)\" という概念を用いています。ロック状態では何らかのスレッド"
"がロックを所有しており、アンロック状態ではいかなるスレッドもロックを所有して"
"いません。"

#: ../../library/threading.rst:467
msgid ""
"To lock the lock, a thread calls its :meth:`acquire` method; this returns "
"once the thread owns the lock.  To unlock the lock, a thread calls its :meth:"
"`release` method. :meth:`acquire`/:meth:`release` call pairs may be nested; "
"only the final :meth:`release` (the :meth:`release` of the outermost pair) "
"resets the lock to unlocked and allows another thread blocked in :meth:"
"`acquire` to proceed."
msgstr ""
"スレッドがこのロックの状態をロックにするには、ロックの :meth:`acquire` メソッ"
"ドを呼び出します。このメソッドは、スレッドがロックを所有すると処理を戻しま"
"す。ロックの状態をアンロックにするには :meth:`release` メソッドを呼び出しま"
"す。 :meth:`acquire` / :meth:`release` からなるペアの呼び出しはネストできま"
"す; 最後に呼び出した :meth:`release` (最も外側の呼び出しペア) だけが、ロック"
"の状態をアンロックにリセットし、 :meth:`acquire` でブロック中の別のスレッドの"
"処理を進行させられます。"

#: ../../library/threading.rst:479
msgid ""
"When invoked without arguments: if this thread already owns the lock, "
"increment the recursion level by one, and return immediately.  Otherwise, if "
"another thread owns the lock, block until the lock is unlocked.  Once the "
"lock is unlocked (not owned by any thread), then grab ownership, set the "
"recursion level to one, and return.  If more than one thread is blocked "
"waiting until the lock is unlocked, only one at a time will be able to grab "
"ownership of the lock. There is no return value in this case."
msgstr ""
"引数なしで呼び出した場合: スレッドが既にロックを所有している場合、再帰レベル"
"をインクリメントして即座に処理を戻します。それ以外の場合、他のスレッドがロッ"
"クを所有していれば、そのロックの状態がアンロックになるまでブロックします。そ"
"の後、ロックの状態がアンロックになる (いかなるスレッドもロックを所有しない状"
"態になる) と、ロックの所有権を獲得し、再帰レベルを 1 にセットして処理を戻しま"
"す。ロックの状態がアンロックになるのを待っているスレッドが複数ある場合、その"
"中の一つだけがロックの所有権を獲得できます。この場合、戻り値はありません。"

#: ../../library/threading.rst:487
msgid ""
"When invoked with the *blocking* argument set to true, do the same thing as "
"when called without arguments, and return true."
msgstr ""
"引数 *blocking* の値を true にして呼び出した場合、引数なしで呼び出したときと"
"同じことを行ない、true を返します。"

#: ../../library/threading.rst:490
msgid ""
"When invoked with the *blocking* argument set to false, do not block.  If a "
"call without an argument would block, return false immediately; otherwise, "
"do the same thing as when called without arguments, and return true."
msgstr ""
"引数 *blocking* の値を false にして呼び出すとブロックしません。引数なしで呼び"
"出した場合にブロックするような状況であった場合には直ちに false を返します。そ"
"れ以外の場合には、引数なしで呼び出したときと同じ処理を行い true を返します。"

#: ../../library/threading.rst:497
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement it "
"is zero, reset the lock to unlocked (not owned by any thread), and if any "
"other threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed.  If after the decrement the recursion level "
"is still nonzero, the lock remains locked and owned by the calling thread."
msgstr ""
"再帰レベルをデクリメントしてロックを解放します。デクリメント後に再帰レベルが"
"ゼロになった場合、ロックの状態をアンロック (いかなるスレッドにも所有されてい"
"ない状態) にリセットし、ロックの状態がアンロックになるのを待ってブロックして"
"いるスレッドがある場合にはその中のただ一つだけが処理を進行できるようにしま"
"す。デクリメント後も再帰レベルがゼロでない場合、ロックの状態はロックのまま"
"で、呼び出し側のスレッドに所有されたままになります。"

#: ../../library/threading.rst:503
msgid ""
"Only call this method when the calling thread owns the lock. A :exc:"
"`RuntimeError` is raised if this method is called when the lock is unlocked."
msgstr ""
"呼び出し側のスレッドがロックを所有しているときにのみこのメソッドを呼び出して"
"ください。ロックの状態がアンロックの時にこのメソッドを呼び出すと、 :exc:"
"`RuntimeError` が送出されます。"

#: ../../library/threading.rst:513
msgid "Condition Objects"
msgstr "Condition オブジェクト"

#: ../../library/threading.rst:515
msgid ""
"A condition variable is always associated with some kind of lock; this can "
"be passed in or one will be created by default.  (Passing one in is useful "
"when several condition variables must share the same lock.)"
msgstr ""
"条件変数 (condition variable) は常にある種のロックに関連付けられています; 条"
"件変数に関連付けるロックは明示的に引き渡したり、デフォルトで生成させたりでき"
"ます。 (複数の条件変数で同じロックを共有するような場合には、引渡しによる関連"
"付けが便利です。)"

#: ../../library/threading.rst:519
msgid ""
"A condition variable has :meth:`acquire` and :meth:`release` methods that "
"call the corresponding methods of the associated lock. It also has a :meth:"
"`wait` method, and :meth:`notify` and :meth:`notifyAll` methods.  These "
"three must only be called when the calling thread has acquired the lock, "
"otherwise a :exc:`RuntimeError` is raised."
msgstr ""
"条件変数には、 :meth:`acquire` メソッドおよび :meth:`release` があり、関連付"
"けされているロックの対応するメソッドを呼び出すようになっています。また、 :"
"meth:`wait`, :meth:`notify`, :meth:`notifyAll` といったメソッドがあります。こ"
"れら三つのメソッドを呼び出せるのは、呼び出し手のスレッドがロックを獲得してい"
"る時だけです。そうでない場合は :exc:`RuntimeError` が送出されます。"

#: ../../library/threading.rst:525
msgid ""
"The :meth:`wait` method releases the lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notifyAll` call for the same "
"condition variable in another thread.  Once awakened, it re-acquires the "
"lock and returns.  It is also possible to specify a timeout."
msgstr ""
":meth:`wait` メソッドは現在のスレッドのロックを解放し、他のスレッドが同じ条件"
"変数に対して :meth:`notify` または :meth:`notifyAll` を呼び出して現在のスレッ"
"ドを起こすまでブロックします。一度起こされると、再度ロックを獲得して処理を戻"
"します。 :meth:`wait` にはタイムアウトも設定できます。"

#: ../../library/threading.rst:530
msgid ""
"The :meth:`notify` method wakes up one of the threads waiting for the "
"condition variable, if any are waiting.  The :meth:`notifyAll` method wakes "
"up all threads waiting for the condition variable."
msgstr ""
":meth:`notify` メソッドは条件変数待ちのスレッドを1つ起こします。 :meth:"
"`notifyAll` メソッドは条件変数待ちの全てのスレッドを起こします。"

#: ../../library/threading.rst:534
msgid ""
"Note: the :meth:`notify` and :meth:`notifyAll` methods don't release the "
"lock; this means that the thread or threads awakened will not return from "
"their :meth:`wait` call immediately, but only when the thread that called :"
"meth:`notify` or :meth:`notifyAll` finally relinquishes ownership of the "
"lock."
msgstr ""
"注意: :meth:`notify` と :meth:`notifyAll` はロックを解放しません; 従って、ス"
"レッドが起こされたとき、 :meth:`wait` の呼び出しは即座に処理を戻すわけではな"
"く、 :meth:`notify` または :meth:`notifyAll` を呼び出したスレッドが最終的に"
"ロックの所有権を放棄したときに初めて処理を返すのです。"

#: ../../library/threading.rst:539
msgid ""
"Tip: the typical programming style using condition variables uses the lock "
"to synchronize access to some shared state; threads that are interested in a "
"particular change of state call :meth:`wait` repeatedly until they see the "
"desired state, while threads that modify the state call :meth:`notify` or :"
"meth:`notifyAll` when they change the state in such a way that it could "
"possibly be a desired state for one of the waiters.  For example, the "
"following code is a generic producer-consumer situation with unlimited "
"buffer capacity::"
msgstr ""
"豆知識: 条件変数を使う典型的なプログラミングスタイルでは、何らかの共有された"
"状態変数へのアクセスを同期させるためにロックを使います; 状態変数が特定の状態"
"に変化したことを知りたいスレッドは、自分の望む状態になるまで繰り返し :meth:"
"`wait` を呼び出します。その一方で、状態変更を行うスレッドは、前者のスレッドが"
"待ち望んでいる状態であるかもしれないような状態へ変更を行ったときに :meth:"
"`notify` や :meth:`notifyAll` を呼び出します。例えば、以下のコードは無制限の"
"バッファ容量のときの一般的な生産者-消費者問題です::"

#: ../../library/threading.rst:560
msgid ""
"To choose between :meth:`notify` and :meth:`notifyAll`, consider whether one "
"state change can be interesting for only one or several waiting threads.  E."
"g. in a typical producer-consumer situation, adding one item to the buffer "
"only needs to wake up one consumer thread."
msgstr ""
":meth:`notify` と :meth:`notifyAll` のどちらを使うかは、その状態の変化に興味"
"を持っている待ちスレッドが一つだけなのか、あるいは複数なのかで考えます。例え"
"ば、典型的な生産者-消費者問題では、バッファに 1 つの要素を加えた場合には消費"
"者スレッドを 1 つしか起こさなくてかまいません。"

#: ../../library/threading.rst:568
msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock` "
"or :class:`RLock` object, and it is used as the underlying lock.  Otherwise, "
"a new :class:`RLock` object is created and used as the underlying lock."
msgstr ""
"*lock* を指定して、 ``None`` の値にする場合、 :class:`Lock` または :class:"
"`RLock` オブジェクトでなければなりません。この場合、 *lock* は根底にあるロッ"
"クオブジェクトとして使われます。それ以外の場合には新しい :class:`RLock` オブ"
"ジェクトを生成して使います。"

#: ../../library/threading.rst:574
msgid ""
"Acquire the underlying lock. This method calls the corresponding method on "
"the underlying lock; the return value is whatever that method returns."
msgstr ""
"根底にあるロックを獲得します。このメソッドは根底にあるロックの対応するメソッ"
"ドを呼び出します。そのメソッドの戻り値を返します。"

#: ../../library/threading.rst:579
msgid ""
"Release the underlying lock. This method calls the corresponding method on "
"the underlying lock; there is no return value."
msgstr ""
"根底にあるロックを解放します。このメソッドは根底にあるロックの対応するメソッ"
"ドを呼び出します。戻り値はありません。"

#: ../../library/threading.rst:584
msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has not "
"acquired the lock when this method is called, a :exc:`RuntimeError` is "
"raised."
msgstr ""
"通知 (notify) を受けるか、タイムアウトするまで待機します。呼び出し側のスレッ"
"ドがロックを獲得していないときにこのメソッドを呼び出すと :exc:`RuntimeError` "
"が送出されます。"

#: ../../library/threading.rst:587
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notifyAll` call for the same "
"condition variable in another thread, or until the optional timeout occurs.  "
"Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""
"このメソッドは根底にあるロックを解放し、他のスレッドが同じ条件変数に対して :"
"meth:`notify` または :meth:`notifyAll` を呼び出して現在のスレッドを起こすか、"
"オプションのタイムアウトが発生するまでブロックします。一度スレッドが起こされ"
"ると、再度ロックを獲得して処理を戻します。"

#: ../../library/threading.rst:592
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""
"*timeout* 引数を指定して、 ``None`` 以外の値にする場合、タイムアウトを秒 (ま"
"たは端数秒) を表す浮動小数点数でなければなりません。"

#: ../../library/threading.rst:596
msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using its :"
"meth:`release` method, since this may not actually unlock the lock when it "
"was acquired multiple times recursively.  Instead, an internal interface of "
"the :class:`RLock` class is used, which really unlocks it even when it has "
"been recursively acquired several times. Another internal interface is then "
"used to restore the recursion level when the lock is reacquired."
msgstr ""
"根底にあるロックが :class:`RLock` である場合、 :meth:`release` メソッドでは"
"ロックは解放されません。というのも、ロックが再帰的に複数回獲得されている場合"
"には、 :meth:`release` によって実際にアンロックが行われないかもしれないからで"
"す。その代わり、ロックが再帰的に複数回獲得されていても確実にアンロックを行え"
"る :class:`RLock` クラスの内部インタフェースを使います。その後ロックを再獲得"
"する時に、もう一つの内部インタフェースを使ってロックの再帰レベルを復帰しま"
"す。"

#: ../../library/threading.rst:606
msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the "
"calling thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"デフォルトで、この条件変数を待っている1つのスレッドを起こします。 呼び出し側"
"のスレッドがロックを獲得していないときにこのメソッドを呼び出すと :exc:"
"`RuntimeError` が送出されます。"

#: ../../library/threading.rst:610
msgid ""
"This method wakes up at most *n* of the threads waiting for the condition "
"variable; it is a no-op if no threads are waiting."
msgstr ""
"何らかの待機中スレッドがある場合、そのうち *n* スレッドを起こします。待機中の"
"スレッドがなければ何もしません。"

#: ../../library/threading.rst:613
msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""
"現在の実装では、少なくとも *n* スレッドが待機中であれば、ちょうど *n* スレッ"
"ドを起こします。とはいえ、この挙動に依存するのは安全ではありません。将来、実"
"装の最適化によって、複数のスレッドを起こすようになるかもしれないからです。"

#: ../../library/threading.rst:618
msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` call "
"until it can reacquire the lock.  Since :meth:`notify` does not release the "
"lock, its caller should."
msgstr ""
"注意: 起こされたスレッドは実際にロックを再獲得できるまで :meth:`wait` 呼び出"
"しから戻りません。 :meth:`notify` はロックを解放しないので、 :meth:`notify` "
"呼び出し側は明示的にロックを解放しなければなりません。"

#: ../../library/threading.rst:625
msgid ""
"Wake up all threads waiting on this condition.  This method acts like :meth:"
"`notify`, but wakes up all waiting threads instead of one. If the calling "
"thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"この条件を待っているすべてのスレッドを起こします。このメソッドは :meth:"
"`notify` のように動作しますが、 1 つではなくすべての待ちスレッドを起こしま"
"す。呼び出し側のスレッドがロックを獲得していない場合、 :exc:`RuntimeError` が"
"送出されます。"

#: ../../library/threading.rst:630
msgid "Added ``notify_all()`` spelling."
msgstr "新たに ``notify_all()`` として使えるようになりました。"

#: ../../library/threading.rst:637
msgid "Semaphore Objects"
msgstr "Semaphore オブジェクト"

#: ../../library/threading.rst:639
msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger W. "
"Dijkstra (he used :meth:`P` and :meth:`V` instead of :meth:`acquire` and :"
"meth:`release`)."
msgstr ""
"セマフォ (semaphore) は、計算機科学史上最も古い同期プリミティブの一つで、草創"
"期のオランダ計算機科学者 Edsger W. Dijkstra によって発明されました (彼は :"
"meth:`acquire` と :meth:`release` の代わりに :meth:`P` と :meth:`V` を使いま"
"した)。"

#: ../../library/threading.rst:643
msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`acquire` call and incremented by each :meth:`release` call.  The counter "
"can never go below zero; when :meth:`acquire` finds that it is zero, it "
"blocks, waiting until some other thread calls :meth:`release`."
msgstr ""
"セマフォは :meth:`acquire` でデクリメントされ :meth:`release` でインクリメン"
"トされるような内部カウンタを管理します。カウンタは決してゼロより小さくはなり"
"ません; :meth:`acquire` は、カウンタがゼロになっている場合、他のスレッドが :"
"meth:`release` を呼び出すまでブロックします。"

#: ../../library/threading.rst:651
msgid ""
"The optional argument gives the initial *value* for the internal counter; it "
"defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` is "
"raised."
msgstr ""
"オプションの引数には、内部カウンタの初期値を指定します。デフォルトは ``1`` で"
"す。与えられた *value* が 0 より小さい場合、 :exc:`ValueError` が送出されま"
"す。"

#: ../../library/threading.rst:657
msgid "Acquire a semaphore."
msgstr "セマフォを獲得します。"

#: ../../library/threading.rst:659
msgid ""
"When invoked without arguments: if the internal counter is larger than zero "
"on entry, decrement it by one and return immediately.  If it is zero on "
"entry, block, waiting until some other thread has called :meth:`release` to "
"make it larger than zero.  This is done with proper interlocking so that if "
"multiple :meth:`acquire` calls are blocked, :meth:`release` will wake "
"exactly one of them up.  The implementation may pick one at random, so the "
"order in which blocked threads are awakened should not be relied on.  There "
"is no return value in this case."
msgstr ""
"引数なしで呼び出した場合: :meth:`acqure` 処理に入ったときに内部カウンタがゼロ"
"より大きければ、カウンタを 1 デクリメントして即座に処理を戻します。 :meth:"
"`acqure` 処理に入ったときに内部カウンタがゼロの場合、他のスレッドが :meth:"
"`release` を呼び出してカウンタをゼロより大きくするまでブロックします。この処"
"理は、適切なインターロック (interlock) を介して行い、複数の :meth:`acquire` "
"呼び出しがブロックされた場合、 :meth:`release` が正確に一つだけを起こせるよう"
"にします。この実装はランダムに一つ選択するだけでもよいので、ブロックされたス"
"レッドがどの起こされる順番に依存してはなりません。この場合、戻り値はありませ"
"ん。"

#: ../../library/threading.rst:668
msgid ""
"When invoked with *blocking* set to true, do the same thing as when called "
"without arguments, and return true."
msgstr ""
"*blocking* 引数の値を真にした場合、引数なしで呼び出した場合と同じ処理を行って"
"真を返します。"

#: ../../library/threading.rst:671
msgid ""
"When invoked with *blocking* set to false, do not block.  If a call without "
"an argument would block, return false immediately; otherwise, do the same "
"thing as when called without arguments, and return true."
msgstr ""
"*blocking* を false にして呼び出すとブロックしません。引数なしで呼び出した場"
"合にブロックするような状況であった場合には直ちに false を返します。それ以外の"
"場合には、引数なしで呼び出したときと同じ処理を行い true を返します。"

#: ../../library/threading.rst:677
msgid ""
"Release a semaphore, incrementing the internal counter by one.  When it was "
"zero on entry and another thread is waiting for it to become larger than "
"zero again, wake up that thread."
msgstr ""
"内部カウンタを 1 インクリメントして、セマフォを解放します。 :meth:`release` "
"処理に入ったときにカウンタがゼロであり、カウンタの値がゼロより大きくなるのを"
"待っている別のスレッドがあった場合、そのスレッドを起こします。"

#: ../../library/threading.rst:685
msgid ":class:`Semaphore` Example"
msgstr ":class:`Semaphore` の例"

#: ../../library/threading.rst:687
msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the resource "
"is fixed, you should use a bounded semaphore.  Before spawning any worker "
"threads, your main thread would initialize the semaphore::"
msgstr ""
"セマフォはしばしば、容量に限りのある資源、例えばデータベースサーバなどを保護"
"するために使われます。リソースが固定の状況では、常に有限セマフォを使わなけれ"
"ばなりません。主スレッドは、作業スレッドを立ち上げる前にセマフォを初期化しま"
"す::"

#: ../../library/threading.rst:696
msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr ""
"作業スレッドは、ひとたび立ち上がると、サーバへ接続する必要が生じたときにセマ"
"フォの :meth:`acquire` および :meth:`release` メソッドを呼び出します::"

#: ../../library/threading.rst:705
msgid ""
"The use of a bounded semaphore reduces the chance that a programming error "
"which causes the semaphore to be released more than it's acquired will go "
"undetected."
msgstr ""
"有限セマフォを使うと、セマフォを獲得回数以上に解放してしまうというプログラム"
"上の間違いを見逃しにくくします。"

#: ../../library/threading.rst:712
msgid "Event Objects"
msgstr "Event オブジェクト"

#: ../../library/threading.rst:714
msgid ""
"This is one of the simplest mechanisms for communication between threads: "
"one thread signals an event and other threads wait for it."
msgstr ""
"イベントは、あるスレッドがイベントを発信し、他のスレッドはそれを待つという、"
"スレッド間で通信を行うための最も単純なメカニズムの一つです。"

#: ../../library/threading.rst:717
msgid ""
"An event object manages an internal flag that can be set to true with the :"
"meth:`~Event.set` method and reset to false with the :meth:`~Event.clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is true."
msgstr ""
"イベントオブジェクトは内部フラグを管理します。このフラグは :meth:`~Event."
"set` メソッドで値を true に、 :meth:`~Event.clear` メソッドで値を false にリ"
"セットします。 :meth:`~Event.wait` メソッドはフラグが true になるまでブロック"
"します。"

#: ../../library/threading.rst:724
msgid "The internal flag is initially false."
msgstr "内部フラグの初期値は偽です。"

#: ../../library/threading.rst:729
msgid "Return true if and only if the internal flag is true."
msgstr "内部フラグの値が true である場合にのみ true を返します。"

#: ../../library/threading.rst:731
msgid "Added ``is_set()`` spelling."
msgstr "新たに ``is_set()`` として使えるようになりました。"

#: ../../library/threading.rst:736
msgid ""
"Set the internal flag to true. All threads waiting for it to become true are "
"awakened. Threads that call :meth:`wait` once the flag is true will not "
"block at all."
msgstr ""
"内部フラグの値を true にセットします。フラグの値が true になるのを待っている"
"全てのスレッドを起こします。一旦フラグが true になると、スレッドが :meth:"
"`wait` を呼び出しても全くブロックしなくなります。"

#: ../../library/threading.rst:742
msgid ""
"Reset the internal flag to false. Subsequently, threads calling :meth:`wait` "
"will block until :meth:`.set` is called to set the internal flag to true "
"again."
msgstr ""
"内部フラグの値を false にリセットします。以降は、 :meth:`.set` を呼び出して再"
"び内部フラグの値を true にセットするまで、 :meth:`wait` を呼び出したスレッド"
"はブロックするようになります。"

#: ../../library/threading.rst:748
msgid ""
"Block until the internal flag is true.  If the internal flag is true on "
"entry, return immediately.  Otherwise, block until another thread calls :"
"meth:`.set` to set the flag to true, or until the optional timeout occurs."
msgstr ""
"内部フラグの値が true になるまでブロックします。 :meth:`wait` 処理に入った時"
"点で内部フラグの値が true であれば、直ちに処理を戻します。そうでない場合、他"
"のスレッドが :meth:`.set` を呼び出してフラグの値を true にセットするか、オプ"
"ションのタイムアウトが発生するまでブロックします。"

#: ../../library/threading.rst:753
msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""
"*timeout* 引数を指定して、 ``None`` 以外の値にする場合、タイムアウトを秒 (ま"
"たは端数秒) を表す浮動小数点数でなければなりません。"

#: ../../library/threading.rst:757
msgid ""
"This method returns the internal flag on exit, so it will always return "
"``True`` except if a timeout is given and the operation times out."
msgstr ""
"このメソッドは終了時の内部フラグを返します。 timeout が指定されて、操作がタイ"
"ムアウトしたとき以外は、 ``True`` を返すはずです。"

#: ../../library/threading.rst:760
msgid "Previously, the method always returned ``None``."
msgstr "以前は、このメソッドは常に ``None`` を返していました。"

#: ../../library/threading.rst:767
msgid "Timer Objects"
msgstr "Timer オブジェクト"

#: ../../library/threading.rst:769
msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of :"
"class:`Thread` and as such also functions as an example of creating custom "
"threads."
msgstr ""
"このクラスは、一定時間経過後に実行される活動、すなわちタイマ活動を表現しま"
"す。 :class:`Timer` は :class:`Thread` のサブクラスであり、自作のスレッドを構"
"築した一例でもあります。"

#: ../../library/threading.rst:773
msgid ""
"Timers are started, as with threads, by calling their :meth:`~Timer.start` "
"method.  The timer can be stopped (before its action has begun) by calling "
"the :meth:`~Timer.cancel` method.  The interval the timer will wait before "
"executing its action may not be exactly the same as the interval specified "
"by the user."
msgstr ""
"タイマは :meth:`~Timer.start` メソッドを呼び出すとスレッドとして作動し始めし"
"ます。 (活動を開始する前に) :meth:`~Timer.cancel` メソッドを呼び出すと、タイ"
"マを停止できます。タイマが活動を実行するまでの待ち時間は、ユーザが指定した待"
"ち時間と必ずしも厳密には一致しません。"

#: ../../library/threading.rst:779
msgid "For example::"
msgstr "例えば::"

#: ../../library/threading.rst:790
msgid ""
"Create a timer that will run *function* with arguments *args* and  keyword "
"arguments *kwargs*, after *interval* seconds have passed."
msgstr ""
"*interval* 秒後に *function* を引数 *args* 、キーワード引数 *kwargs* つきで実"
"行するようなタイマを生成します。"

#: ../../library/threading.rst:795
msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This will "
"only work if the timer is still in its waiting stage."
msgstr ""
"タイマをストップして、その動作の実行をキャンセルします。このメソッドはタイマ"
"がまだ活動待ち状態にある場合にのみ動作します。"

#: ../../library/threading.rst:802
msgid ""
"Using locks, conditions, and semaphores in the :keyword:`with` statement"
msgstr ":keyword:`with` 文でのロック・条件変数・セマフォの使い方"

#: ../../library/threading.rst:804
msgid ""
"All of the objects provided by this module that have :meth:`acquire` and :"
"meth:`release` methods can be used as context managers for a :keyword:`with` "
"statement.  The :meth:`acquire` method will be called when the block is "
"entered, and :meth:`release` will be called when the block is exited."
msgstr ""
"このモジュールのオブジェクトで :meth:`acquire` と :meth:`release` 両メソッド"
"を具えているものは全て :keyword:`with` 文のコンテキストマネージャとして使うこ"
"とができます。 :meth:`acquire` メソッドが :keyword:`with` 文のブロックに入る"
"ときに呼び出され、ブロック脱出時には :meth:`release` メソッドが呼ばれます。"

#: ../../library/threading.rst:809
msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, :class:"
"`Semaphore`, and :class:`BoundedSemaphore` objects may be used as :keyword:"
"`with` statement context managers.  For example::"
msgstr ""
"現在のところ、 :class:`Lock` 、 :class:`RLock` 、 :class:`Condition` 、 :"
"class:`Semaphore` 、 :class:`BoundedSemaphore` を :keyword:`with` 文のコンテ"
"キストマネージャとして使うことができます。以下の例を見てください。 ::"

#: ../../library/threading.rst:824
msgid "Importing in threaded code"
msgstr "スレッド化されたコード中でのImport"

#: ../../library/threading.rst:826
msgid ""
"While the import machinery is thread-safe, there are two key restrictions on "
"threaded imports due to inherent limitations in the way that thread-safety "
"is provided:"
msgstr ""
"スレッドセーフなimportのためには、継承の制限に起因する、ふたつの重要な制約が"
"あります。"

#: ../../library/threading.rst:830
msgid ""
"Firstly, other than in the main module, an import should not have the side "
"effect of spawning a new thread and then waiting for that thread in any way. "
"Failing to abide by this restriction can lead to a deadlock if the spawned "
"thread directly or indirectly attempts to import a module."
msgstr ""
"ひとつ目は、主とするモジュール以外では、importが新しいスレッドを生成しないよ"
"うになっていなければなりません。そして、そのスレッドを待たなければなりませ"
"ん。この制約を守らない場合、生成されたスレッドが直接的、または、間接的にモ"
"ジュールをimportしようとした際に、デッドロックを引き起こす可能性があります。"

#: ../../library/threading.rst:834
msgid ""
"Secondly, all import attempts must be completed before the interpreter "
"starts shutting itself down. This can be most easily achieved by only "
"performing imports from non-daemon threads created through the threading "
"module. Daemon threads and threads created directly with the thread module "
"will require some other form of synchronization to ensure they do not "
"attempt imports after system shutdown has commenced. Failure to abide by "
"this restriction will lead to intermittent exceptions and crashes during "
"interpreter shutdown (as the late imports attempt to access machinery which "
"is no longer in a valid state)."
msgstr ""
"ふたつ目は、全てのimportが、インタープリターが自身を終了させる前に完了しなけ"
"ればなりません。これは、最も簡単な方法としては、threadingモジュールを通して生"
"成される非デーモンからのみimportを実行することで達成できます。デーモンスレッ"
"ド、および、直接、threadモジュールから生成されたスレッドは、インタープリター"
"終了後にimportを実行しないようにする、別の同期の仕組みを必要とします。この制"
"約を守らない場合、 intermittent (間歇) 例外を引き起こし、インタープリターの"
"シャットダウン中にクラッシュする可能性があります。 (後から実行されるimport"
"は、すでにアクセス可能でなくなった領域にアクセスしようとするためです)"
