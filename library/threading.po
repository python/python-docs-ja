# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Masato HASHIMOTO <cabezon.hashimoto@gmail.com>, 2017
# Shun Sakurai, 2017
# Ikuru K <kanumaiku@gmail.com>, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2017
# Hano, 2017
# E. Kawashima, 2017
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2017
# Arihiro TAKASE, 2017
# tomoğŸ§, 2017
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-08 09:41+0900\n"
"PO-Revision-Date: 2017-02-16 23:30+0000\n"
"Last-Translator: tomoğŸ§, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/threading.rst:2
msgid ":mod:`threading` --- Thread-based parallelism"
msgstr ":mod:`threading` --- ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ™ãƒ¼ã‚¹ã®ä¸¦åˆ—å‡¦ç†"

#: ../../library/threading.rst:7
msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/threading.py`"

#: ../../library/threading.rst:11
msgid ""
"This module constructs higher-level threading interfaces on top of the lower"
" level :mod:`_thread` module.  See also the :mod:`queue` module."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€é«˜æ°´æº–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ã‚ˆã‚Šä½æ°´æº– ãª :mod:`_thread` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¸Šã«æ§‹ç¯‰ã—ã¦ã„ã¾ã™ã€‚ "
":mod:`queue` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/threading.rst:14
msgid "This module used to be optional, it is now always available."
msgstr ""

#: ../../library/threading.rst:19
msgid ""
"While they are not listed below, the ``camelCase`` names used for some "
"methods and functions in this module in the Python 2.x series are still "
"supported by this module."
msgstr ""
"ã“ã“ã«ã¯è¼‰ã£ã¦ã„ã¾ã›ã‚“ãŒã€Python 2.x ã‚·ãƒªãƒ¼ã‚ºã§ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¸€éƒ¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚„é–¢æ•°ã«ä½¿ã‚ã‚Œã¦ã„ãŸ ``camelCase`` "
"åã¯ã€ã¾ã ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:24
msgid "This module defines the following functions:"
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ä»¥ä¸‹ã®é–¢æ•°ã‚’å®šç¾©ã—ã¦ã„ã¾ã™:"

#: ../../library/threading.rst:29
msgid ""
"Return the number of :class:`Thread` objects currently alive.  The returned "
"count is equal to the length of the list returned by :func:`.enumerate`."
msgstr ""
"ç”Ÿå­˜ä¸­ã® :class:`Thread` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ•°ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®æ•°ã¯ :func:`.enumerate` ã®è¿”ã™ãƒªã‚¹ãƒˆã®é•·ã•ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/threading.rst:35
msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""
"é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹å‡¦ç†ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾å¿œã™ã‚‹ :class:`Thread` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹å‡¦ç†ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒ "
":mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ç”Ÿæˆã—ãŸã‚‚ã®ã§ãªã„å ´åˆã€é™å®šçš„ãªæ©Ÿèƒ½ã—ã‹ã‚‚ãŸãªã„ãƒ€ãƒŸãƒ¼ã‚¹ãƒ¬ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:43
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"ç¾åœ¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã® 'ã‚¹ãƒ¬ãƒƒãƒ‰ID' ã‚’è¿”ã—ã¾ã™ã€‚éã‚¼ãƒ­ã®æ•´æ•°ã§ã™ã€‚ã“ã®å€¤ã¯ç›´æ¥ã®æ„å‘³ã‚’æŒã£ã¦ã„ã¾ã›ã‚“; "
"ä¾‹ãˆã°ã‚¹ãƒ¬ãƒƒãƒ‰ç‰¹æœ‰ã®ãƒ‡ãƒ¼ã‚¿ã®è¾æ›¸ã«ç´¢å¼•ã‚’ã¤ã‘ã‚‹ãŸã‚ã®ã‚ˆã†ãªã€ãƒã‚¸ãƒƒã‚¯ã‚¯ãƒƒã‚­ãƒ¼ã¨ã—ã¦æ„å›³ã•ã‚Œã¦ã„ã¾ã™ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã—ã€ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒä½œã‚‰ã‚ŒãŸã¨ãã€ã‚¹ãƒ¬ãƒƒãƒ‰"
" ID ã¯å†åˆ©ç”¨ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:54
msgid ""
"Return a list of all :class:`Thread` objects currently alive.  The list "
"includes daemonic threads, dummy thread objects created by "
":func:`current_thread`, and the main thread.  It excludes terminated threads"
" and threads that have not yet been started."
msgstr ""
"ç¾åœ¨ã€ç”Ÿå­˜ä¸­ã® :class:`Thread` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…¨ã¦ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ãƒªã‚¹ãƒˆã«ã¯ã€ãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ (daemonic thread)ã€ "
":func:`current_thread` "
"ã®ç”Ÿæˆã™ã‚‹ãƒ€ãƒŸãƒ¼ã‚¹ãƒ¬ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ãã—ã¦ä¸»ã‚¹ãƒ¬ãƒƒãƒ‰ãŒå…¥ã‚Šã¾ã™ã€‚çµ‚äº†ã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¨ã¾ã é–‹å§‹ã—ã¦ã„ãªã„ã‚¹ãƒ¬ãƒƒãƒ‰ã¯å…¥ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:62
msgid ""
"Return the main :class:`Thread` object.  In normal conditions, the main "
"thread is the thread from which the Python interpreter was started."
msgstr ""
"main :class:`Thread` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚é€šå¸¸ã®æ¡ä»¶ã§ã¯ã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã¯Pythonã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒèµ·å‹•ã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã‚’æŒ‡ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:73
msgid ""
"Set a trace function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""
":mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦é–‹å§‹ã—ãŸå…¨ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒˆãƒ¬ãƒ¼ã‚¹é–¢æ•°ã‚’è¨­å®šã—ã¾ã™ã€‚ *func* ã¯å„ã‚¹ãƒ¬ãƒƒãƒ‰ã® "
":meth:`~Thread.run` ã‚’å‘¼ã³å‡ºã™å‰ã«ã‚¹ãƒ¬ãƒƒãƒ‰ã® :func:`sys.settrace` ã«æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:82
msgid ""
"Set a profile function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""
":mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦é–‹å§‹ã—ãŸå…¨ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«é–¢æ•°ã‚’è¨­å®šã—ã¾ã™ã€‚ *func* ã¯å„ã‚¹ãƒ¬ãƒƒãƒ‰ã® "
":meth:`~Thread.run` ã‚’å‘¼ã³å‡ºã™å‰ã«ã‚¹ãƒ¬ãƒƒãƒ‰ã® :func:`sys.setprofile` ã«æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:89
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created"
" threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a "
":exc:`RuntimeError` is raised.  If the specified stack size is invalid, a "
":exc:`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""

#: ../../library/threading.rst:104
msgid ""
":ref:`Availability <availability>`: Windows, systems with POSIX threads."
msgstr ""

#: ../../library/threading.rst:107
msgid "This module also defines the following constant:"
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ä»¥ä¸‹ã®å®šæ•°ã‚‚å®šç¾©ã—ã¦ã„ã¾ã™:"

#: ../../library/threading.rst:111
msgid ""
"The maximum value allowed for the *timeout* parameter of blocking functions "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.)."
" Specifying a timeout greater than this value will raise an "
":exc:`OverflowError`."
msgstr ""
"ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹é–¢æ•° (:meth:`Lock.acquire`, :meth:`RLock.acquire`, "
":meth:`Condition.wait` ãªã©) ã® *timeout* å¼•æ•°ã«è¨±ã•ã‚Œã‚‹æœ€å¤§å€¤ã€‚ã“ã‚Œä»¥ä¸Šã®å€¤ã‚’ timeout ã«æŒ‡å®šã™ã‚‹ã¨ "
":exc:`OverflowError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/threading.rst:119
msgid ""
"This module defines a number of classes, which are detailed in the sections "
"below."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å¤šãã®ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ãã‚Œã‚‰ã¯ä¸‹è¨˜ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§è©³ã—ãèª¬æ˜ã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:122
msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of "
"every object, they are separate objects in Python.  Python's :class:`Thread`"
" class supports a subset of the behavior of Java's Thread class; currently, "
"there are no priorities, no thread groups, and threads cannot be destroyed, "
"stopped, suspended, resumed, or interrupted.  The static methods of Java's "
"Thread class, when implemented, are mapped to module-level functions."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãŠãŠã¾ã‹ãªè¨­è¨ˆã¯ Java ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ¢ãƒ‡ãƒ«ã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚ã¨ã¯ã„ãˆã€ Java "
"ãŒãƒ­ãƒƒã‚¯ã¨æ¡ä»¶å¤‰æ•°ã‚’å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŸºæœ¬çš„ãªæŒ™å‹•ã«ã—ã¦ã„ã‚‹ã®ã«å¯¾ã—ã€ Python ã§ã¯ã“ã‚Œã‚‰ã‚’åˆ¥å€‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åˆ†ã‘ã¦ã„ã¾ã™ã€‚ Python ã®"
" :class:`Thread` ã‚¯ãƒ©ã‚¹ãŒã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã®ã¯ Java ã® Thread ã‚¯ãƒ©ã‚¹ã®æŒ™å‹•ã®ã‚µãƒ–ã‚»ãƒƒãƒˆã«ã™ãã¾ã›ã‚“; ç¾çŠ¶ã§ã¯ã€å„ªå…ˆåº¦ "
"(priority)ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ãŒãªãã€ã‚¹ãƒ¬ãƒƒãƒ‰ã®ç ´å£Š (destroy)ã€ä¸­æ–­ (stop)ã€ä¸€æ™‚åœæ­¢ (suspend)ã€å¾©å¸° "
"(resume)ã€å‰²ã‚Šè¾¼ã¿ (interrupt) ã¯è¡Œãˆã¾ã›ã‚“ã€‚ Java ã® Thread "
"ã‚¯ãƒ©ã‚¹ã«ãŠã‘ã‚‹é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã«å¯¾å¿œã™ã‚‹æ©Ÿèƒ½ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®é–¢æ•°ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/threading.rst:130
msgid "All of the methods described below are executed atomically."
msgstr "ä»¥ä¸‹ã«èª¬æ˜ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã¯å…¨ã¦åŸå­çš„ (atomic) ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:134
msgid "Thread-Local Data"
msgstr "ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿"

#: ../../library/threading.rst:136
msgid ""
"Thread-local data is data whose values are thread specific.  To manage "
"thread-local data, just create an instance of :class:`local` (or a subclass)"
" and store attributes on it::"
msgstr ""
"ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã¯ã€ãã®å€¤ãŒã‚¹ãƒ¬ãƒƒãƒ‰å›ºæœ‰ã®ãƒ‡ãƒ¼ã‚¿ã§ã™ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ç®¡ç†ã™ã‚‹ã«ã¯ã€å˜ã« :class:`local` "
"(ã‚ã‚‹ã„ã¯ãã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹) ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¦ã€ãã®å±æ€§ã«å€¤ã‚’è¨­å®šã—ã¦ãã ã•ã„::"

#: ../../library/threading.rst:143
msgid "The instance's values will be different for separate threads."
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å€¤ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã”ã¨ã«é•ã£ãŸå€¤ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/threading.rst:148
msgid "A class that represents thread-local data."
msgstr "ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¾ã™ã‚‹ã‚¯ãƒ©ã‚¹ã€‚"

#: ../../library/threading.rst:150
msgid ""
"For more details and extensive examples, see the documentation string of the"
" :mod:`_threading_local` module."
msgstr "è©³ç´°ã¨ä¾‹é¡Œã«ã¤ã„ã¦ã¯ã€ :mod:`_threading_local` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/threading.rst:157
msgid "Thread Objects"
msgstr "Thread ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/threading.rst:159
msgid ""
"The :class:`Thread` class represents an activity that is run in a separate "
"thread of control.  There are two ways to specify the activity: by passing a"
" callable object to the constructor, or by overriding the "
":meth:`~Thread.run` method in a subclass.  No other methods (except for the "
"constructor) should be overridden in a subclass.  In other words, *only*  "
"override the :meth:`~Thread.__init__` and :meth:`~Thread.run` methods of "
"this class."
msgstr ""
":class:`Thread` ã‚¯ãƒ©ã‚¹ã¯å€‹åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ä¸­ã§å®Ÿè¡Œã•ã‚Œã‚‹æ´»å‹• (activity) ã‚’è¡¨ç¾ã—ã¾ã™ã€‚æ´»å‹•ã‚’æ±ºã‚ã‚‹æ–¹æ³•ã¯ 2 "
"ã¤ã‚ã‚Šã€ä¸€ã¤ã¯å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¸æ¸¡ã™æ–¹æ³•ã€ã‚‚ã†ä¸€ã¤ã¯ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ :meth:`~Thread.run` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã™ã‚‹æ–¹æ³•ã§ã™ã€‚ (ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’é™¤ã) "
"ãã®ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä¸€åˆ‡ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚è¨€ã„æ›ãˆã‚‹ãªã‚‰ã°ã€ã“ã®ã‚¯ãƒ©ã‚¹ã® :meth:`~Thread.__init__` ã¨ "
":meth:`~Thread.run` ãƒ¡ã‚½ãƒƒãƒ‰ *ã ã‘* ã‚’ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã—ã¦ãã ã•ã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../library/threading.rst:166
msgid ""
"Once a thread object is created, its activity must be started by calling the"
" thread's :meth:`~Thread.start` method.  This invokes the "
":meth:`~Thread.run` method in a separate thread of control."
msgstr ""
"ã²ã¨ãŸã³ã‚¹ãƒ¬ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹ã¨ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã® :meth:`~Thread.start` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦æ´»å‹•ã‚’é–‹å§‹ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ "
":meth:`start` ãƒ¡ã‚½ãƒƒãƒ‰ ã¯ãã‚Œãã‚Œã®ã‚¹ãƒ¬ãƒƒãƒ‰ã® :meth:`~Thread.run` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’èµ·å‹•ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:170
msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. It "
"stops being alive when its :meth:`~Thread.run` method terminates -- either "
"normally, or by raising an unhandled exception.  The "
":meth:`~Thread.is_alive` method tests whether the thread is alive."
msgstr ""
"ã‚¹ãƒ¬ãƒƒãƒ‰ã®æ´»å‹•ãŒå§‹ã¾ã‚‹ã¨ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ 'ç”Ÿå­˜ä¸­ (alive)' ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚ ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€é€šå¸¸ :meth:`~Thread.run` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ã¾ã§ã€ã‚‚ã—ãã¯æ•æ‰ã•ã‚Œãªã„ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã‚‹ã¾ã§ç”Ÿå­˜ä¸­ã¨ãªã‚Šã¾ã™ã€‚ :meth:`~Thread.is_alive` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãŒç”Ÿå­˜ä¸­ã§ã‚ã‚‹ã‹ã©ã†ã‹èª¿ã¹ã¾ã™ã€‚"

#: ../../library/threading.rst:175
msgid ""
"Other threads can call a thread's :meth:`~Thread.join` method.  This blocks "
"the calling thread until the thread whose :meth:`~Thread.join` method is "
"called is terminated."
msgstr ""
"ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã® :meth:`~Thread.join` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ "
":meth:`~Thread.join` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã°ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ã¾ã§ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—å…ƒã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:179
msgid ""
"A thread has a name.  The name can be passed to the constructor, and read or"
" changed through the :attr:`~Thread.name` attribute."
msgstr ""
"ã‚¹ãƒ¬ãƒƒãƒ‰ã¯åå‰ã‚’æŒã£ã¦ã„ã¾ã™ã€‚åå‰ã¯ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«æ¸¡ã™ã“ã¨ãŒã§ãã€ :attr:`~Thread.name` "
"å±æ€§ã‚’é€šã—ã¦èª­ã¿å‡ºã—ãŸã‚Šå¤‰æ›´ã—ãŸã‚Šã§ãã¾ã™ã€‚"

#: ../../library/threading.rst:182
msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this "
"flag is that the entire Python program exits when only daemon threads are "
"left.  The initial value is inherited from the creating thread.  The flag "
"can be set through the :attr:`~Thread.daemon` property or the *daemon* "
"constructor argument."
msgstr ""
"ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã¯ \"ãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ (daemon thread)\" ã§ã‚ã‚‹ã¨ã„ã†ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‰ã‚Œã¾ã™ã€‚ "
"ã“ã®ãƒ•ãƒ©ã‚°ã«ã¯ã€æ®‹ã£ã¦ã„ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã ã‘ã«ãªã£ãŸæ™‚ã« Python "
"ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ã‚’çµ‚äº†ã•ã›ã‚‹ã¨ã„ã†æ„å‘³ãŒã‚ã‚Šã¾ã™ã€‚ãƒ•ãƒ©ã‚°ã®åˆæœŸå€¤ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ç”Ÿæˆã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ç¶™æ‰¿ã—ã¾ã™ã€‚ãƒ•ãƒ©ã‚°ã®å€¤ã¯ "
":attr:`~Thread.daemon` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¾ãŸã¯ *daemon* ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å¼•æ•°ã‚’é€šã—ã¦è¨­å®šã§ãã¾ã™ã€‚"

#: ../../library/threading.rst:189
msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such as "
"open files, database transactions, etc.) may not be released properly. If "
"you want your threads to stop gracefully, make them non-daemonic and use a "
"suitable signalling mechanism such as an :class:`Event`."
msgstr ""
"ãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã¯çµ‚äº†æ™‚ã«ã„ããªã‚Šåœæ­¢ã•ã‚Œã¾ã™ã€‚ãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§ä½¿ã‚ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ (é–‹ã„ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãªã©) "
"ã¯é©åˆ‡ã«è§£æ”¾ã•ã‚Œãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãã¡ã‚“ã¨ (gracefully) "
"ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’åœæ­¢ã—ãŸã„å ´åˆã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’éãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã—ã¦ã€:class:`Event` ã®ã‚ˆã†ãªé©åˆ‡ãªã‚·ã‚°ãƒŠãƒ«é€ä¿¡æ©Ÿæ§‹ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/threading.rst:194
msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread of"
" control in the Python program.  It is not a daemon thread."
msgstr ""
"ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã¯ \"ä¸»ã‚¹ãƒ¬ãƒƒãƒ‰ (main thread)\" ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚Šã¾ã™ã€‚ä¸»ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ Python "
"ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æœ€åˆã«åˆ¶å¾¡ã—ã¦ã„ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã§ã™ã€‚ä¸»ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:197
msgid ""
"There is the possibility that \"dummy thread objects\" are created. These "
"are thread objects corresponding to \"alien threads\", which are threads of "
"control started outside the threading module, such as directly from C code."
"  Dummy thread objects have limited functionality; they are always "
"considered alive and daemonic, and cannot be :meth:`~Thread.join`\\ ed.  "
"They are never deleted, since it is impossible to detect the termination of "
"alien threads."
msgstr ""
"\"ãƒ€ãƒŸãƒ¼ã‚¹ãƒ¬ãƒƒãƒ‰ (dummy thread)\" ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ ãƒ€ãƒŸãƒ¼ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ \"å¤–æ¥ã‚¹ãƒ¬ãƒƒãƒ‰ (alien "
"thread)\" ã«å¯¾å¿œã™ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ãƒ€ãƒŸãƒ¼ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ C ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ç›´æ¥ç”Ÿæˆã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚ˆã†ãªã€ "
":mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å¤–ã§é–‹å§‹ã•ã‚ŒãŸå‡¦ç†ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã™ã€‚ "
"ãƒ€ãƒŸãƒ¼ã‚¹ãƒ¬ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯é™ã‚‰ã‚ŒãŸæ©Ÿèƒ½ã—ã‹ãªãã€å¸¸ã«ç”Ÿå­˜ä¸­ã€ã‹ã¤ãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã‚ã‚‹ã¨ã¿ãªã•ã‚Œã€ :meth:`~Thread.join` "
"ã§ãã¾ã›ã‚“ã€‚ã¾ãŸã€å¤–æ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã®çµ‚äº†ã‚’æ¤œå‡ºã™ã‚‹ã®ã¯ä¸å¯èƒ½ãªã®ã§ã€ãƒ€ãƒŸãƒ¼ã‚¹ãƒ¬ãƒƒãƒ‰ã¯å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:208
msgid ""
"This constructor should always be called with keyword arguments.  Arguments "
"are:"
msgstr "ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯å¸¸ã«ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ä½¿ã£ã¦å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å„å¼•æ•°ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™:"

#: ../../library/threading.rst:211
msgid ""
"*group* should be ``None``; reserved for future extension when a "
":class:`ThreadGroup` class is implemented."
msgstr ""
"*group* ã¯ ``None`` ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å°†æ¥ :class:`ThreadGroup` "
"ã‚¯ãƒ©ã‚¹ãŒå®Ÿè£…ã•ã‚ŒãŸã¨ãã®æ‹¡å¼µç”¨ã«äºˆç´„ã•ã‚Œã¦ã„ã‚‹å¼•æ•°ã§ã™ã€‚"

#: ../../library/threading.rst:214
msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr ""
"*target* ã¯ :meth:`run` ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦èµ·å‹•ã•ã‚Œã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ä½•ã‚‚å‘¼ã³å‡ºã•ãªã„ã“ã¨ã‚’ç¤ºã™ "
"``None`` ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/threading.rst:217
msgid ""
"*name* is the thread name.  By default, a unique name is constructed of the "
"form \"Thread-*N*\" where *N* is a small decimal number."
msgstr ""
"*name* ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã®åå‰ã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ *N* ã‚’å°ã•ãª 10 é€²æ•°ã¨ã—ã¦ã€ \"Thread- *N*\" "
"ã¨ã„ã†å½¢å¼ã®ä¸€æ„ãªåå‰ã‚’ç”Ÿæˆã—ã¾ã™ã€‚"

#: ../../library/threading.rst:220
msgid ""
"*args* is the argument tuple for the target invocation.  Defaults to ``()``."
msgstr "*args* ã¯ *target* ã‚’å‘¼ã³å‡ºã™ã¨ãã®å¼•æ•°ã‚¿ãƒ—ãƒ«ã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``()`` ã§ã™ã€‚"

#: ../../library/threading.rst:222
msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr "*kwargs* ã¯ *target* ã‚’å‘¼ã³å‡ºã™ã¨ãã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®è¾æ›¸ã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``{}`` ã§ã™ã€‚"

#: ../../library/threading.rst:225
msgid ""
"If not ``None``, *daemon* explicitly sets whether the thread is daemonic. If"
" ``None`` (the default), the daemonic property is inherited from the current"
" thread."
msgstr ""
"``None`` ã§ãªã„å ´åˆã€*daemon* ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ‡ãƒ¼ãƒ¢ãƒ³ã‹ã©ã†ã‹ã‚’æ˜ç¤ºçš„ã«è¨­å®šã—ã¾ã™ã€‚``None`` ã®å ´åˆ "
"(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)ã€ãƒ‡ãƒ¼ãƒ¢ãƒ³å±æ€§ã¯ç¾åœ¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ç¶™æ‰¿ã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:229
msgid ""
"If the subclass overrides the constructor, it must make sure to invoke the "
"base class constructor (``Thread.__init__()``) before doing anything else to"
" the thread."
msgstr ""
"ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã—ãŸå ´åˆã€å¿…ãšã‚¹ãƒ¬ãƒƒãƒ‰ãŒä½•ã‹ã‚’å§‹ã‚ã‚‹å‰ã«åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ "
"(``Thread.__init__()``) ã‚’å‘¼ã³å‡ºã—ã¦ãŠã‹ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:233
msgid "Added the *daemon* argument."
msgstr "*daemon* å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/threading.rst:238
msgid "Start the thread's activity."
msgstr "ã‚¹ãƒ¬ãƒƒãƒ‰ã®æ´»å‹•ã‚’é–‹å§‹ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:240
msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`~Thread.run` method to be invoked in a separate thread of "
"control."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚ãŸã‚Šä¸€åº¦ã—ã‹å‘¼ã³å‡ºã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ :meth:`~Thread.start` ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® "
":meth:`~Thread.run` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå€‹åˆ¥ã®å‡¦ç†ã‚¹ãƒ¬ãƒƒãƒ‰ä¸­ã§å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚ˆã†ã«èª¿æ•´ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:244
msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on the"
" same thread object."
msgstr "åŒã˜ã‚¹ãƒ¬ãƒƒãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’2å›ä»¥ä¸Šå‘¼ã³å‡ºã—ãŸå ´åˆã€ :exc:`RuntimeError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/threading.rst:249
msgid "Method representing the thread's activity."
msgstr "ã‚¹ãƒ¬ãƒƒãƒ‰ã®æ´»å‹•ã‚’ã‚‚ãŸã‚‰ã™ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚"

#: ../../library/threading.rst:251
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method"
" invokes the callable object passed to the object's constructor as the "
"*target* argument, if any, with sequential and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã§ãã¾ã™ã€‚æ¨™æº–ã® :meth:`run` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã® *target* "
"å¼•æ•°ã«å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã—ãŸå ´åˆã€ *args* ãŠã‚ˆã³ *kwargs* ã®å¼•æ•°åˆ—ãŠã‚ˆã³ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ã¨ã‚‚ã«å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/threading.rst:258
msgid ""
"Wait until the thread terminates. This blocks the calling thread until the "
"thread whose :meth:`~Thread.join` method is called terminates -- either "
"normally or through an unhandled exception -- or until the optional timeout "
"occurs."
msgstr ""
"ã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚\n"
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ :meth:`~Thread.join` ã‚’å‘¼ã°ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ãŒæ­£å¸¸çµ‚äº†ã‚ã‚‹ã„ã¯å‡¦ç†ã•ã‚Œãªã„ä¾‹å¤–ã«ã‚ˆã£ã¦çµ‚äº†ã™ã‚‹ã‹ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç™ºç”Ÿã™ã‚‹ã¾ã§ã€ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—å…ƒã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:263
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof). As :meth:`~Thread.join` always returns ``None``, you "
"must call :meth:`~Thread.is_alive` after :meth:`~Thread.join` to decide "
"whether a timeout happened -- if the thread is still alive, the "
":meth:`~Thread.join` call timed out."
msgstr ""
"*timeout* å¼•æ•°ãŒå­˜åœ¨ã—ã¦ ``None`` ä»¥å¤–ã®å ´åˆã€ãã‚Œã¯æ“ä½œã«å¯¾ã™ã‚‹ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç§’ (ã‚ã‚‹ã„ã¯ç§’æœªæº€ã®ç«¯æ•°) "
"ã‚’è¡¨ã™æµ®å‹•å°æ•°ç‚¹æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ :meth:`~Thread.join` ã¯å¸¸ã« ``None`` ã‚’è¿”ã™ã®ã§ã€ "
":meth:`~Thread.join` ã®å¾Œã« :meth:`~Thread.is_alive` "
"ã‚’å‘¼ã³å‡ºã—ã¦ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸã‹ã©ã†ã‹ã‚’ç¢ºèªã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã¾ã ç”Ÿå­˜ä¸­ã§ã‚ã‚Œã°ã€ :meth:`~Thread.join` "
"ã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/threading.rst:270
msgid ""
"When the *timeout* argument is not present or ``None``, the operation will "
"block until the thread terminates."
msgstr "*timeout* ãŒæŒ‡å®šã•ã‚Œãªã„ã‹ã¾ãŸã¯ ``None`` ã§ã‚ã‚‹ã¨ãã¯ã€ã“ã®æ“ä½œã¯ã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:273
msgid "A thread can be :meth:`~Thread.join`\\ ed many times."
msgstr "ä¸€ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾ã—ã¦ä½•åº¦ã§ã‚‚ :meth:`~Thread.join` ã§ãã¾ã™ã€‚"

#: ../../library/threading.rst:275
msgid ""
":meth:`~Thread.join` raises a :exc:`RuntimeError` if an attempt is made to "
"join the current thread as that would cause a deadlock. It is also an error "
"to :meth:`~Thread.join` a thread before it has been started and attempts to "
"do so raise the same exception."
msgstr ""
"ç¾åœ¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾ã—ã¦ :meth:`~Thread.join` ã‚’å‘¼ã³å‡ºãã†ã¨ã™ã‚‹ã¨ã€ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’å¼•ãèµ·ã“ã™ãŸã‚ "
":exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ ã‚¹ãƒ¬ãƒƒãƒ‰ãŒé–‹å§‹ã•ã‚Œã‚‹å‰ã« :meth:`~Thread.join` "
"ã‚’å‘¼ã³å‡ºã™ã“ã¨ã‚‚åŒæ§˜ã®ã‚¨ãƒ©ãƒ¼ã®ãŸã‚ã€åŒã˜ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:282
msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by the"
" constructor."
msgstr ""
"è­˜åˆ¥ã®ãŸã‚ã«ã®ã¿ç”¨ã„ã‚‰ã‚Œã‚‹æ–‡å­—åˆ—ã§ã™ã€‚åå‰ã«ã¯æ©Ÿèƒ½ä¸Šã®æ„å‘³ã¥ã‘ (semantics) "
"ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«åŒã˜åå‰ã‚’ã¤ã‘ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚åå‰ã®åˆæœŸå€¤ã¯ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§è¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:289
msgid ""
"Old getter/setter API for :attr:`~Thread.name`; use it directly as a "
"property instead."
msgstr ":attr:`~Thread.name` ã«å¯¾ã™ã‚‹å¤ã„ getter/setter API; ä»£ã‚ã‚Šã«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ç›´æ¥ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/threading.rst:294
msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`get_ident` "
"function.  Thread identifiers may be recycled when a thread exits and "
"another thread is created.  The identifier is available even after the "
"thread has exited."
msgstr ""

#: ../../library/threading.rst:302
msgid "Return whether the thread is alive."
msgstr "ã‚¹ãƒ¬ãƒƒãƒ‰ãŒç”Ÿå­˜ä¸­ã‹ã©ã†ã‹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:304
msgid ""
"This method returns ``True`` just before the :meth:`~Thread.run` method "
"starts until just after the :meth:`~Thread.run` method terminates.  The "
"module function :func:`.enumerate` returns a list of all alive threads."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ :meth:`~Thread.run` ãƒ¡ã‚½ãƒƒãƒ‰ãŒèµ·å‹•ã™ã‚‹ç›´å‰ã‹ã‚‰ :meth:`~Thread.run` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ç›´å¾Œã¾ã§ã®é–“ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–¢æ•° :func:`.enumerate` "
"ã¯ã€å…¨ã¦ã®ç”Ÿå­˜ä¸­ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:310
msgid ""
"A boolean value indicating whether this thread is a daemon thread (True) or "
"not (False).  This must be set before :meth:`~Thread.start` is called, "
"otherwise :exc:`RuntimeError` is raised.  Its initial value is inherited "
"from the creating thread; the main thread is not a daemon thread and "
"therefore all threads created in the main thread default to "
":attr:`~Thread.daemon` = ``False``."
msgstr ""
"ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ (True) ã‹å¦ã‹ (False) ã‚’ç¤ºã™ãƒ–ãƒ¼ãƒ«å€¤ã€‚ã“ã®å€¤ã¯ :meth:`~Thread.start` "
"ã®å‘¼ã³å‡ºã—å‰ã«è¨­å®šã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã•ã‚‚ãªã‘ã‚Œã° :exc:`RuntimeError` "
"ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚åˆæœŸå€¤ã¯ç”Ÿæˆå´ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ç¶™æ‰¿ã•ã‚Œã¾ã™; "
"ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã¯ãªã„ã®ã§ã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§ä½œæˆã•ã‚ŒãŸã™ã¹ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ :attr:`~Thread.daemon` "
"= ``False`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/threading.rst:317
msgid ""
"The entire Python program exits when no alive non-daemon threads are left."
msgstr "ãƒ‡ãƒ¼ãƒ¢ãƒ³ã§ãªã„ç”Ÿå­˜ä¸­ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒå…¨ã¦ãªããªã‚‹ã¨ã€ Python ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ãŒçµ‚äº†ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:322
msgid ""
"Old getter/setter API for :attr:`~Thread.daemon`; use it directly as a "
"property instead."
msgstr ""
":attr:`~Thread.daemon` ã«å¯¾ã™ã‚‹å¤ã„ getter/setter API; ä»£ã‚ã‚Šã«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ç›´æ¥ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/threading.rst:328
msgid ""
"In CPython, due to the :term:`Global Interpreter Lock`, only one thread can "
"execute Python code at once (even though certain performance-oriented "
"libraries might overcome this limitation). If you want your application to "
"make better use of the computational resources of multi-core machines, you "
"are advised to use :mod:`multiprocessing` or "
":class:`concurrent.futures.ProcessPoolExecutor`. However, threading is still"
" an appropriate model if you want to run multiple I/O-bound tasks "
"simultaneously."
msgstr ""
"CPython ã¯ :term:`Global Interpreter Lock` ã®ãŸã‚ã€ã‚ã‚‹æ™‚ç‚¹ã§ Python "
"ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã§ãã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã¯1ã¤ã«é™ã‚‰ã‚Œã¾ã™ "
"(ãŸã ã—ã€ã„ãã¤ã‹ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒå¼·ãæ±‚ã‚ã‚‰ã‚Œã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã“ã®åˆ¶é™ã‚’å…‹æœã—ã¦ã„ã¾ã™)ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ãƒãƒ«ãƒã‚³ã‚¢ãƒã‚·ãƒ³ã®è¨ˆç®—èƒ½åŠ›ã‚’ã‚ˆã‚Šè‰¯ãåˆ©ç”¨ã•ã›ãŸã„å ´åˆã¯ã€"
" :mod:`multiprocessing` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ "
":class:`concurrent.futures.ProcessPoolExecutor` ã®åˆ©ç”¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚ "
"ãŸã ã—ã€I/Oãƒã‚¦ãƒ³ãƒ‰ãªã‚¿ã‚¹ã‚¯ã‚’ä¸¦è¡Œã—ã¦è¤‡æ•°èµ°ã‚‰ã›ãŸã„å ´åˆã«ãŠã„ã¦ã¯ã€ ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã¯æ­£ã—ã„é¸æŠè‚¢ã§ã™ã€‚"

#: ../../library/threading.rst:341
msgid "Lock Objects"
msgstr "Lock ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/threading.rst:343
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest level "
"synchronization primitive available, implemented directly by the "
":mod:`_thread` extension module."
msgstr ""
"ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒ­ãƒƒã‚¯ã¨ã¯ã€ãƒ­ãƒƒã‚¯ãŒç”Ÿã˜ãŸéš›ã«ç‰¹å®šã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚ˆã£ã¦æ‰€æœ‰ã•ã‚Œãªã„åŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã§ã™ã€‚ Python ã§ã¯ç¾åœ¨ã®ã¨ã“ã‚æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« "
":mod:`_thread` ã§ç›´æ¥å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹æœ€ã‚‚ä½æ°´æº–ã®åŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’ä½¿ãˆã¾ã™ã€‚"

#: ../../library/threading.rst:348
msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It is "
"created in the unlocked state.  It has two basic methods, "
":meth:`~Lock.acquire` and :meth:`~Lock.release`.  When the state is "
"unlocked, :meth:`~Lock.acquire` changes the state to locked and returns "
"immediately.  When the state is locked, :meth:`~Lock.acquire` blocks until a"
" call to :meth:`~Lock.release` in another thread changes it to unlocked, "
"then the :meth:`~Lock.acquire` call resets it to locked and returns.  The "
":meth:`~Lock.release` method should only be called in the locked state; it "
"changes the state to unlocked and returns immediately. If an attempt is made"
" to release an unlocked lock, a :exc:`RuntimeError` will be raised."
msgstr ""
"ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒ­ãƒƒã‚¯ã¯2ã¤ã®çŠ¶æ…‹ã€ \"ãƒ­ãƒƒã‚¯\" ã¾ãŸã¯ \"ã‚¢ãƒ³ãƒ­ãƒƒã‚¯\" "
"ãŒã‚ã‚Šã¾ã™ã€‚ãƒ­ãƒƒã‚¯ã¯ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã§ä½œæˆã•ã‚Œã¾ã™ã€‚ãƒ­ãƒƒã‚¯ã«ã¯åŸºæœ¬ã¨ãªã‚‹äºŒã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ã€ :meth:`~Lock.acquire` ã¨ "
":meth:`~Lock.release` ãŒã‚ã‚Šã¾ã™ã€‚ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã§ã‚ã‚‹å ´åˆã€ :meth:`~Lock.acquire` "
"ã¯çŠ¶æ…‹ã‚’ãƒ­ãƒƒã‚¯ã«å¤‰æ›´ã—ã¦å³åº§ã«å‡¦ç†ã‚’æˆ»ã—ã¾ã™ã€‚ çŠ¶æ…‹ãŒãƒ­ãƒƒã‚¯ã®å ´åˆã€ :meth:`~Lock.acquire` ã¯ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒ "
":meth:`~Lock.release` ã‚’å‘¼ã³å‡ºã—ã¦ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã«å¤‰æ›´ã™ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ãã®å¾Œã€ "
":meth:`~Lock.acquire` å‘¼ã³å‡ºã—ã¯çŠ¶æ…‹ã‚’å†åº¦ãƒ­ãƒƒã‚¯ã«è¨­å®šã—ã¦ã‹ã‚‰å‡¦ç†ã‚’æˆ»ã—ã¾ã™ã€‚ :meth:`~Lock.release` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã®ã¯ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ã¨ãã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã«å¤‰æ›´ã—ã¦ã€å³åº§ã«å‡¦ç†ã‚’æˆ»ã—ã¾ã™ã€‚ "
"ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã®ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ :exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:359
msgid ""
"Locks also support the :ref:`context management protocol <with-locks>`."
msgstr "ãƒ­ãƒƒã‚¯ã¯ :ref:`ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ« <with-locks>` ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../library/threading.rst:361
msgid ""
"When more than one thread is blocked in :meth:`~Lock.acquire` waiting for "
"the state to turn to unlocked, only one thread proceeds when a "
":meth:`~Lock.release` call resets the state to unlocked; which one of the "
"waiting threads proceeds is not defined, and may vary across "
"implementations."
msgstr ""
"è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãŠã„ã¦ :meth:`~Lock.acquire` ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã¸ã®é·ç§»ã‚’å¾…ã£ã¦ã„ã‚‹ãŸã‚ã«ãƒ–ãƒ­ãƒƒã‚¯ãŒèµ·ãã¦ã„ã‚‹æ™‚ã« "
":meth:`~Lock.release` ã‚’å‘¼ã³å‡ºã—ã¦ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã«ã™ã‚‹ã¨ã€ä¸€ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã ã‘ãŒå‡¦ç†ã‚’é€²è¡Œã§ãã¾ã™ã€‚ "
"ã©ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒå‡¦ç†ã‚’é€²è¡Œã§ãã‚‹ã®ã‹ã¯å®šç¾©ã•ã‚Œã¦ãŠã‚‰ãšã€å®Ÿè£…ã«ã‚ˆã£ã¦ç•°ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:366
msgid "All methods are executed atomically."
msgstr "å…¨ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¢ãƒˆãƒŸãƒƒã‚¯ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:371
msgid ""
"The class implementing primitive lock objects.  Once a thread has acquired a"
" lock, subsequent attempts to acquire it block, until it is released; any "
"thread may release it."
msgstr ""
"ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒ­ãƒƒã‚¯ (primitive lock) "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰ãŒä¸€åº¦ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã™ã‚‹ã¨ã€ãã‚Œä»¥å¾Œã®ãƒ­ãƒƒã‚¯ç²å¾—ã®è©¦ã¿ã¯ãƒ­ãƒƒã‚¯ãŒè§£æ”¾ã•ã‚Œã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ã©ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã‚‚ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã§ãã¾ã™ã€‚"

#: ../../library/threading.rst:375
msgid ""
"Note that ``Lock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete Lock class that is supported "
"by the platform."
msgstr ""

#: ../../library/threading.rst:382 ../../library/threading.rst:457
msgid "Acquire a lock, blocking or non-blocking."
msgstr "ãƒ–ãƒ­ãƒƒã‚¯ã‚ã‚Šã€ã¾ãŸã¯ãƒ–ãƒ­ãƒƒã‚¯ãªã—ã§ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:384
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return ``True``."
msgstr ""
"å¼•æ•° *blocking* ã‚’ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) "
"ã«è¨­å®šã—ã¦å‘¼ã³å‡ºã—ãŸå ´åˆã€ãƒ­ãƒƒã‚¯ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ãã—ã¦ãã‚Œã‚’ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ã—ã¦ã‹ã‚‰ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:387
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block. If"
" a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""
"å¼•æ•° *blocking* ã®å€¤ã‚’ ``False`` ã«ã—ã¦å‘¼ã³å‡ºã™ã¨ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚*blocking* ã‚’ ``True`` "
"ã«ã—ã¦å‘¼ã³å‡ºã—ãŸå ´åˆã«ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã‚ˆã†ãªçŠ¶æ³ã§ã¯ã€ç›´ã¡ã« ``False`` ã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€ãƒ­ãƒƒã‚¯ã‚’ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ã—ã¦ ``True``"
" ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:391
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as"
" long as the lock cannot be acquired.  A *timeout* argument of ``-1`` "
"specifies an unbounded wait.  It is forbidden to specify a *timeout* when "
"*blocking* is false."
msgstr ""
"æ­£ã®å€¤ã«è¨­å®šã•ã‚ŒãŸæµ®å‹•å°æ•°ç‚¹ã® *timeout* å¼•æ•°ã¨ã¨ã‚‚ã«èµ·å‹•ã•ã‚ŒãŸå ´åˆã€ãƒ­ãƒƒã‚¯ã‚’å¾—ã‚‰ã‚Œãªã‘ã‚Œã°æœ€å¤§ã§ *timeout* "
"ã«ã‚ˆã£ã¦æŒ‡å®šã•ã‚ŒãŸç§’æ•°ã ã‘ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚*timeout* å¼•æ•°ã® ``-1`` ã¯ç„¡åˆ¶é™ã®å¾…æ©Ÿã‚’æŒ‡å®šã—ã¾ã™ã€‚*blocking* ãŒ false "
"ã®å ´åˆã« *timeout* ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/threading.rst:397
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False``"
" if not (for example if the *timeout* expired)."
msgstr ""
"ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã™ã‚‹ã¨ ``True`` ã‚’ã€ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã§ããªã‹ã£ãŸã¨ã (ä¾‹ãˆã° *timeout* ãŒéããŸå ´åˆ) ã«ã¯ ``False`` "
"ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:400 ../../library/threading.rst:479
#: ../../library/threading.rst:724
msgid "The *timeout* parameter is new."
msgstr "æ–°ã—ã„ *timeout* å¼•æ•°ã€‚"

#: ../../library/threading.rst:403
msgid ""
"Lock acquisition can now be interrupted by signals on POSIX if the "
"underlying threading implementation supports it."
msgstr ""

#: ../../library/threading.rst:410
msgid ""
"Release a lock.  This can be called from any thread, not only the thread "
"which has acquired the lock."
msgstr "ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã ã‘ã§ãªãã€ä»»æ„ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰å‘¼ã¶ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/threading.rst:413
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow exactly "
"one of them to proceed."
msgstr ""
"ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ãŒãƒ­ãƒƒã‚¯ã®ã¨ãã€çŠ¶æ…‹ã‚’ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã«ãƒªã‚»ãƒƒãƒˆã—ã¦å‡¦ç†ã‚’æˆ»ã—ã¾ã™ã€‚ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ãªã‚‹ã®ã‚’å¾…ã£ã¦ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã„ã‚‹å ´åˆã€ãŸã ä¸€ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã ã‘ãŒå‡¦ç†ã‚’ç¶™ç¶šã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:417
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr "ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ãƒ­ãƒƒã‚¯ã«å¯¾ã—ã¦å‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆã€:exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:419 ../../library/threading.rst:495
msgid "There is no return value."
msgstr "æˆ»ã‚Šå€¤ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:425
msgid "RLock Objects"
msgstr "RLock ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/threading.rst:427
msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the locked/unlocked"
" state used by primitive locks.  In the locked state, some thread owns the "
"lock; in the unlocked state, no thread owns it."
msgstr ""
"å†å…¥å¯èƒ½ãƒ­ãƒƒã‚¯ (reentrant lock) "
"ã¨ã¯ã€åŒã˜ã‚¹ãƒ¬ãƒƒãƒ‰ãŒè¤‡æ•°å›ç²å¾—ã§ãã‚‹ã‚ˆã†ãªåŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã§ã™ã€‚å†å…¥å¯èƒ½ãƒ­ãƒƒã‚¯ã®å†…éƒ¨ã§ã¯ã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒ­ãƒƒã‚¯ã®ä½¿ã†ãƒ­ãƒƒã‚¯ï¼ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«åŠ ãˆã€ "
"\"æ‰€æœ‰ã‚¹ãƒ¬ãƒƒãƒ‰ (owning thread)\" ã¨ \"å†å¸°ãƒ¬ãƒ™ãƒ« (recursion level)\" "
"ã¨ã„ã†æ¦‚å¿µã‚’ç”¨ã„ã¦ã„ã¾ã™ã€‚ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã§ã¯ä½•ã‚‰ã‹ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã‚’æ‰€æœ‰ã—ã¦ãŠã‚Šã€ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã§ã¯ã„ã‹ãªã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã‚‚ãƒ­ãƒƒã‚¯ã‚’æ‰€æœ‰ã—ã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:433
msgid ""
"To lock the lock, a thread calls its :meth:`~RLock.acquire` method; this "
"returns once the thread owns the lock.  To unlock the lock, a thread calls "
"its :meth:`~Lock.release` method. "
":meth:`~Lock.acquire`/:meth:`~Lock.release` call pairs may be nested; only "
"the final :meth:`~Lock.release` (the :meth:`~Lock.release` of the outermost "
"pair) resets the lock to unlocked and allows another thread blocked in "
":meth:`~Lock.acquire` to proceed."
msgstr ""
"ã“ã®ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’ãƒ­ãƒƒã‚¯ã«ã™ã‚‹ã«ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã® :meth:`~RLock.acquire` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã‚’æ‰€æœ‰ã™ã‚‹ã¨å‡¦ç†ã‚’æˆ»ã—ã¾ã™ã€‚ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã«ã™ã‚‹ã«ã¯ "
":meth:`~Lock.release` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ :meth:`~Lock.acquire` / "
":meth:`~Lock.release` ã‹ã‚‰ãªã‚‹ãƒšã‚¢ã®å‘¼ã³å‡ºã—ã¯ãƒã‚¹ãƒˆã§ãã¾ã™; æœ€å¾Œã«å‘¼ã³å‡ºã—ãŸ :meth:`~Lock.release` "
"(æœ€ã‚‚å¤–å´ã®å‘¼ã³å‡ºã—ãƒšã‚¢ã® :meth:`~Lock.release`) ã ã‘ãŒãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã«ãƒªã‚»ãƒƒãƒˆã—ã¦ã€ "
":meth:`~Lock.acquire` ã§ãƒ–ãƒ­ãƒƒã‚¯ä¸­ã®åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®å‡¦ç†ã‚’é€²è¡Œã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/threading.rst:440
msgid ""
"Reentrant locks also support the :ref:`context management protocol <with-"
"locks>`."
msgstr "å†å…¥å¯èƒ½ãƒ­ãƒƒã‚¯ã¯ :ref:`ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ« <with-locks>` ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../library/threading.rst:445
msgid ""
"This class implements reentrant lock objects.  A reentrant lock must be "
"released by the thread that acquired it.  Once a thread has acquired a "
"reentrant lock, the same thread may acquire it again without blocking; the "
"thread must release it once for each time it has acquired it."
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹ã¯å†å…¥å¯èƒ½ãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿè£…ã—ã¾ã™ã€‚å†å…¥å¯èƒ½ãƒ­ãƒƒã‚¯ã¯ãã‚Œã‚’ç²å¾—ã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚ˆã£ã¦è§£æ”¾ã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã„ã£ãŸã‚“ã‚¹ãƒ¬ãƒƒãƒ‰ãŒå†å…¥å¯èƒ½ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã™ã‚‹ã¨ã€åŒã˜ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œãšã«ã‚‚ã†ä¸€åº¦ãã‚Œã‚’ç²å¾—ã§ãã¾ã™"
" ; ãã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ç²å¾—ã—ãŸå›æ•°ã ã‘è§£æ”¾ã—ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:450
msgid ""
"Note that ``RLock`` is actually a factory function which returns an instance"
" of the most efficient version of the concrete RLock class that is supported"
" by the platform."
msgstr ""
"``RLock`` ã¯å®Ÿéš›ã«ã¯ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã§ã€ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã‚‹æœ€ã‚‚åŠ¹ç‡çš„ãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®å…·ä½“çš„ãª RLock "
"ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/threading.rst:459
msgid ""
"When invoked without arguments: if this thread already owns the lock, "
"increment the recursion level by one, and return immediately.  Otherwise, if"
" another thread owns the lock, block until the lock is unlocked.  Once the "
"lock is unlocked (not owned by any thread), then grab ownership, set the "
"recursion level to one, and return.  If more than one thread is blocked "
"waiting until the lock is unlocked, only one at a time will be able to grab "
"ownership of the lock. There is no return value in this case."
msgstr ""
"å¼•æ•°ãªã—ã§å‘¼ã³å‡ºã—ãŸå ´åˆ: "
"ã‚¹ãƒ¬ãƒƒãƒ‰ãŒæ—¢ã«ãƒ­ãƒƒã‚¯ã‚’æ‰€æœ‰ã—ã¦ã„ã‚‹å ´åˆã€å†å¸°ãƒ¬ãƒ™ãƒ«ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦å³åº§ã«å‡¦ç†ã‚’æˆ»ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã€ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã‚’æ‰€æœ‰ã—ã¦ã„ã‚Œã°ã€ãã®ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ãã®å¾Œã€ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã«ãªã‚‹"
" (ã„ã‹ãªã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã‚‚ãƒ­ãƒƒã‚¯ã‚’æ‰€æœ‰ã—ãªã„çŠ¶æ…‹ã«ãªã‚‹) ã¨ã€ãƒ­ãƒƒã‚¯ã®æ‰€æœ‰æ¨©ã‚’ç²å¾—ã—ã€å†å¸°ãƒ¬ãƒ™ãƒ«ã‚’ 1 "
"ã«ã‚»ãƒƒãƒˆã—ã¦å‡¦ç†ã‚’æˆ»ã—ã¾ã™ã€‚ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã«ãªã‚‹ã®ã‚’å¾…ã£ã¦ã„ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ãŒè¤‡æ•°ã‚ã‚‹å ´åˆã€ãã®ä¸­ã®ä¸€ã¤ã ã‘ãŒãƒ­ãƒƒã‚¯ã®æ‰€æœ‰æ¨©ã‚’ç²å¾—ã§ãã¾ã™ã€‚ã“ã®å ´åˆã€æˆ»ã‚Šå€¤ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:467
msgid ""
"When invoked with the *blocking* argument set to true, do the same thing as "
"when called without arguments, and return true."
msgstr "å¼•æ•° *blocking* ã®å€¤ã‚’ true ã«ã—ã¦å‘¼ã³å‡ºã—ãŸå ´åˆã€å¼•æ•°ãªã—ã§å‘¼ã³å‡ºã—ãŸã¨ãã¨åŒã˜ã“ã¨ã‚’è¡Œãªã„ã€true ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:470
msgid ""
"When invoked with the *blocking* argument set to false, do not block.  If a "
"call without an argument would block, return false immediately; otherwise, "
"do the same thing as when called without arguments, and return true."
msgstr ""
"å¼•æ•° *blocking* ã®å€¤ã‚’ false ã«ã—ã¦å‘¼ã³å‡ºã™ã¨ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚å¼•æ•°ãªã—ã§å‘¼ã³å‡ºã—ãŸå ´åˆã«ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã‚ˆã†ãªçŠ¶æ³ã§ã‚ã£ãŸå ´åˆã«ã¯ç›´ã¡ã«"
" false ã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€å¼•æ•°ãªã—ã§å‘¼ã³å‡ºã—ãŸã¨ãã¨åŒã˜å‡¦ç†ã‚’è¡Œã„ true ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:474
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as"
" long as the lock cannot be acquired.  Return true if the lock has been "
"acquired, false if the timeout has elapsed."
msgstr ""
"æ­£ã®å€¤ã«è¨­å®šã•ã‚ŒãŸæµ®å‹•å°æ•°ç‚¹ã® *timeout* å¼•æ•°ã¨ã¨ã‚‚ã«èµ·å‹•ã•ã‚ŒãŸå ´åˆã€ãƒ­ãƒƒã‚¯ã‚’å¾—ã‚‰ã‚Œãªã‘ã‚Œã°æœ€å¤§ã§ *timeout* "
"ã«ã‚ˆã£ã¦æŒ‡å®šã•ã‚ŒãŸç§’æ•°ã ã‘ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ãŸå ´åˆ true ã‚’è¿”ã—ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒéããŸå ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:485
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement it"
" is zero, reset the lock to unlocked (not owned by any thread), and if any "
"other threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed.  If after the decrement the recursion level "
"is still nonzero, the lock remains locked and owned by the calling thread."
msgstr ""
"å†å¸°ãƒ¬ãƒ™ãƒ«ã‚’ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã¾ã™ã€‚ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆå¾Œã«å†å¸°ãƒ¬ãƒ™ãƒ«ãŒã‚¼ãƒ­ã«ãªã£ãŸå ´åˆã€ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ "
"(ã„ã‹ãªã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚‚æ‰€æœ‰ã•ã‚Œã¦ã„ãªã„çŠ¶æ…‹) "
"ã«ãƒªã‚»ãƒƒãƒˆã—ã€ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã«ãªã‚‹ã®ã‚’å¾…ã£ã¦ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã„ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚ã‚‹å ´åˆã«ã¯ãã®ä¸­ã®ãŸã ä¸€ã¤ã ã‘ãŒå‡¦ç†ã‚’é€²è¡Œã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆå¾Œã‚‚å†å¸°ãƒ¬ãƒ™ãƒ«ãŒã‚¼ãƒ­ã§ãªã„å ´åˆã€ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã¯ãƒ­ãƒƒã‚¯ã®ã¾ã¾ã§ã€å‘¼ã³å‡ºã—å´ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«æ‰€æœ‰ã•ã‚ŒãŸã¾ã¾ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/threading.rst:491
msgid ""
"Only call this method when the calling thread owns the lock. A "
":exc:`RuntimeError` is raised if this method is called when the lock is "
"unlocked."
msgstr ""
"å‘¼ã³å‡ºã—å´ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã‚’æ‰€æœ‰ã—ã¦ã„ã‚‹ã¨ãã«ã®ã¿ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã®æ™‚ã«ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¨ã€ "
":exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:501
msgid "Condition Objects"
msgstr "Condition ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/threading.rst:503
msgid ""
"A condition variable is always associated with some kind of lock; this can "
"be passed in or one will be created by default.  Passing one in is useful "
"when several condition variables must share the same lock.  The lock is part"
" of the condition object: you don't have to track it separately."
msgstr ""
"æ¡ä»¶å¤‰æ•° (condition variable) ã¯ã€å¸¸ã«ã‚ã‚‹ç¨®ã®ãƒ­ãƒƒã‚¯ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã¾ã™; "
"ã“ã®ãƒ­ãƒƒã‚¯ã¯æ˜ç¤ºçš„ã«æ¸¡ã™ã“ã¨ã‚‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ç”Ÿæˆã•ã›ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚è¤‡æ•°ã®æ¡ä»¶å¤‰æ•°ã§åŒã˜ãƒ­ãƒƒã‚¯ã‚’å…±æœ‰ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„å ´åˆã«ã¯ã€å¼•æ¸¡ã—ã«ã‚ˆã‚‹é–¢é€£ä»˜ã‘ãŒä¾¿åˆ©ã§ã™ã€‚ãƒ­ãƒƒã‚¯ã¯æ¡ä»¶ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸€éƒ¨ã§ã™:"
" ãã‚Œã‚’åˆ¥ã€…ã«æ‰±ã†å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:508
msgid ""
"A condition variable obeys the :ref:`context management protocol <with-"
"locks>`: using the ``with`` statement acquires the associated lock for the "
"duration of the enclosed block.  The :meth:`~Condition.acquire` and "
":meth:`~Condition.release` methods also call the corresponding methods of "
"the associated lock."
msgstr ""
"æ¡ä»¶å¤‰æ•°ã¯ :ref:`ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†ãƒ—ãƒ­ãƒˆã‚³ãƒ« <with-locks>` ã«å¾“ã„ã¾ã™: ``with`` "
"æ–‡ã‚’ä½¿ã£ã¦å›²ã¾ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ã®é–“ã ã‘é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ :meth:`~Condition.acquire` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ "
":meth:`~Condition.release` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã•ã‚‰ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸãƒ­ãƒƒã‚¯ã®å¯¾å¿œã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/threading.rst:514
msgid ""
"Other methods must be called with the associated lock held.  The "
":meth:`~Condition.wait` method releases the lock, and then blocks until "
"another thread awakens it by calling :meth:`~Condition.notify` or "
":meth:`~Condition.notify_all`.  Once awakened, :meth:`~Condition.wait` re-"
"acquires the lock and returns.  It is also possible to specify a timeout."
msgstr ""
"ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸãƒ­ãƒƒã‚¯ã‚’ä¿æŒã—ãŸçŠ¶æ…‹ã§å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ :meth:`~Condition.wait` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã¾ã™ã€‚ãã—ã¦åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒ :meth:`~Condition.notify` ã¾ãŸã¯ "
":meth:`~Condition.notify_all` ã‚’å‘¼ã¶ã“ã¨ã«ã‚ˆã£ã¦ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èµ·ã“ã™ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ä¸€æ—¦èµ·ã“ã•ã‚ŒãŸãªã‚‰ã€ "
":meth:`~Condition.wait` ã¯å†ã³ãƒ­ãƒƒã‚¯ã‚’å¾—ã¦æˆ»ã‚Šã¾ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚"

#: ../../library/threading.rst:520
msgid ""
"The :meth:`~Condition.notify` method wakes up one of the threads waiting for"
" the condition variable, if any are waiting.  The "
":meth:`~Condition.notify_all` method wakes up all threads waiting for the "
"condition variable."
msgstr ""
":meth:`~Condition.notify` ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ¡ä»¶å¤‰æ•°å¾…ã¡ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’1ã¤èµ·ã“ã—ã¾ã™ã€‚ "
":meth:`~Condition.notify_all` ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ¡ä»¶å¤‰æ•°å¾…ã¡ã®å…¨ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èµ·ã“ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:524
msgid ""
"Note: the :meth:`~Condition.notify` and :meth:`~Condition.notify_all` "
"methods don't release the lock; this means that the thread or threads "
"awakened will not return from their :meth:`~Condition.wait` call "
"immediately, but only when the thread that called :meth:`~Condition.notify` "
"or :meth:`~Condition.notify_all` finally relinquishes ownership of the lock."
msgstr ""
"æ³¨æ„: :meth:`~Condition.notify` ã¨ :meth:`~Condition.notify_all` ã¯ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã¾ã›ã‚“; "
"å¾“ã£ã¦ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãŒèµ·ã“ã•ã‚ŒãŸã¨ãã€ :meth:`~Condition.wait` ã®å‘¼ã³å‡ºã—ã¯å³åº§ã«å‡¦ç†ã‚’æˆ»ã™ã‚ã‘ã§ã¯ãªãã€ "
":meth:`~Condition.notify` ã¾ãŸã¯ :meth:`~Condition.notify_all` "
"ã‚’å‘¼ã³å‡ºã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ãŒæœ€çµ‚çš„ã«ãƒ­ãƒƒã‚¯ã®æ‰€æœ‰æ¨©ã‚’æ”¾æ£„ã—ãŸã¨ãã«åˆã‚ã¦å‡¦ç†ã‚’è¿”ã™ã®ã§ã™ã€‚"

#: ../../library/threading.rst:530
msgid ""
"The typical programming style using condition variables uses the lock to "
"synchronize access to some shared state; threads that are interested in a "
"particular change of state call :meth:`~Condition.wait` repeatedly until "
"they see the desired state, while threads that modify the state call "
":meth:`~Condition.notify` or :meth:`~Condition.notify_all` when they change "
"the state in such a way that it could possibly be a desired state for one of"
" the waiters.  For example, the following code is a generic producer-"
"consumer situation with unlimited buffer capacity::"
msgstr ""
"æ¡ä»¶å¤‰æ•°ã‚’ä½¿ã†å…¸å‹çš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚¹ã‚¿ã‚¤ãƒ«ã§ã¯ã€ä½•ã‚‰ã‹ã®å…±æœ‰ã•ã‚ŒãŸçŠ¶æ…‹å¤‰æ•°ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’åŒæœŸã•ã›ã‚‹ãŸã‚ã«ãƒ­ãƒƒã‚¯ã‚’ä½¿ã„ã¾ã™; "
"çŠ¶æ…‹å¤‰æ•°ãŒç‰¹å®šã®çŠ¶æ…‹ã«å¤‰åŒ–ã—ãŸã“ã¨ã‚’çŸ¥ã‚ŠãŸã„ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€è‡ªåˆ†ã®æœ›ã‚€çŠ¶æ…‹ã«ãªã‚‹ã¾ã§ç¹°ã‚Šè¿”ã— :meth:`~Condition.wait` "
"ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ãã®ä¸€æ–¹ã§ã€çŠ¶æ…‹å¤‰æ›´ã‚’è¡Œã†ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€å‰è€…ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒå¾…ã¡æœ›ã‚“ã§ã„ã‚‹çŠ¶æ…‹ã§ã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‚ˆã†ãªçŠ¶æ…‹ã¸å¤‰æ›´ã‚’è¡Œã£ãŸã¨ãã« "
":meth:`~Condition.notify` ã‚„ :meth:`~Condition.notify_all` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ä¾‹ãˆã°"
"ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯ç„¡åˆ¶é™ã®ãƒãƒƒãƒ•ã‚¡å®¹é‡ã®ã¨ãã®ä¸€èˆ¬çš„ãªç”Ÿç”£è€…-æ¶ˆè²»è€…å•é¡Œã§ã™::"

#: ../../library/threading.rst:550
msgid ""
"The ``while`` loop checking for the application's condition is necessary "
"because :meth:`~Condition.wait` can return after an arbitrary long time, and"
" the condition which prompted the :meth:`~Condition.notify` call may no "
"longer hold true.  This is inherent to multi-threaded programming.  The "
":meth:`~Condition.wait_for` method can be used to automate the condition "
"checking, and eases the computation of timeouts::"
msgstr ""
"ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ ``while`` ãƒ«ãƒ¼ãƒ—ã¯å¿…é ˆã§ã™ã€‚ãªãœãªã‚‰ã€ :meth:`~Condition.wait` "
"ãŒä»»æ„ã®é•·æ™‚é–“ã®å¾Œã§è¿”ã‚Šã€ :meth:`~Condition.notify` "
"å‘¼ã³å‡ºã—ã‚’ä¿ƒã—ãŸæ¡ä»¶ãŒã‚‚ã¯ã‚„çœŸã§ãªã„ã“ã¨ãŒã‚ã‚Šãˆã‚‹ã‹ã‚‰ã§ã™ã€‚ã“ã‚Œã¯ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«å›ºæœ‰ã§ã™ã€‚æ¡ä»¶ãƒã‚§ãƒƒã‚¯ã‚’è‡ªå‹•åŒ–ã™ã‚‹ãŸã‚ã« "
":meth:`~Condition.wait_for` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã“ã¨ãŒã§ãã€ãã‚Œã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®è¨ˆç®—ã‚’ç°¡ç•¥åŒ–ã—ã¾ã™::"

#: ../../library/threading.rst:562
msgid ""
"To choose between :meth:`~Condition.notify` and "
":meth:`~Condition.notify_all`, consider whether one state change can be "
"interesting for only one or several waiting threads.  E.g. in a typical "
"producer-consumer situation, adding one item to the buffer only needs to "
"wake up one consumer thread."
msgstr ""
":meth:`~Condition.notify` ã¨ :meth:`~Condition.notify_all` "
"ã®ã©ã¡ã‚‰ã‚’ä½¿ã†ã‹ã¯ã€ãã®çŠ¶æ…‹ã®å¤‰åŒ–ã«èˆˆå‘³ã‚’æŒã£ã¦ã„ã‚‹å¾…ã¡ã‚¹ãƒ¬ãƒƒãƒ‰ãŒä¸€ã¤ã ã‘ãªã®ã‹ã€ã‚ã‚‹ã„ã¯è¤‡æ•°ãªã®ã‹ã§è€ƒãˆã¾ã™ã€‚ä¾‹ãˆã°ã€å…¸å‹çš„ãªç”Ÿç”£è€…-"
"æ¶ˆè²»è€…å•é¡Œã§ã¯ã€ãƒãƒƒãƒ•ã‚¡ã«1ã¤ã®è¦ç´ ã‚’åŠ ãˆãŸå ´åˆã«ã¯æ¶ˆè²»è€…ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ 1 ã¤ã—ã‹èµ·ã“ã•ãªãã¦ã‹ã¾ã„ã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:570
msgid ""
"This class implements condition variable objects.  A condition variable "
"allows one or more threads to wait until they are notified by another "
"thread."
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹ã¯æ¡ä»¶å¤‰æ•° (condition variable) "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿè£…ã—ã¾ã™ã€‚æ¡ä»¶å¤‰æ•°ã‚’ä½¿ã†ã¨ã€1ã¤ä»¥ä¸Šã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®é€šçŸ¥ãŒã‚ã‚‹ã¾ã§å¾…æ©Ÿã•ã›ã¦ãŠã‘ã¾ã™ã€‚"

#: ../../library/threading.rst:573
msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock`"
" or :class:`RLock` object, and it is used as the underlying lock.  "
"Otherwise, a new :class:`RLock` object is created and used as the underlying"
" lock."
msgstr ""
"*lock* ã« ``None`` ã§ãªã„å€¤ã‚’æŒ‡å®šã—ãŸå ´åˆã€ãã®å€¤ã¯ :class:`Lock` ã¾ãŸã¯ :class:`RLock` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"ã“ã®å ´åˆã€ *lock* ã¯æ ¹åº•ã«ã‚ã‚‹ãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚\n"
"ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€ :class:`RLock` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ–°ã—ãä½œæˆã—ã¦ä½¿ã„ã¾ã™ã€‚"

#: ../../library/threading.rst:577 ../../library/threading.rst:699
#: ../../library/threading.rst:742 ../../library/threading.rst:794
#: ../../library/threading.rst:863
msgid "changed from a factory function to a class."
msgstr "ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã‹ã‚‰ã‚¯ãƒ©ã‚¹ã«å¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/threading.rst:582
msgid ""
"Acquire the underlying lock. This method calls the corresponding method on "
"the underlying lock; the return value is whatever that method returns."
msgstr "æ ¹åº•ã«ã‚ã‚‹ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ ¹åº•ã«ã‚ã‚‹ãƒ­ãƒƒã‚¯ã®å¯¾å¿œã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã®æˆ»ã‚Šå€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:587
msgid ""
"Release the underlying lock. This method calls the corresponding method on "
"the underlying lock; there is no return value."
msgstr "æ ¹åº•ã«ã‚ã‚‹ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ ¹åº•ã«ã‚ã‚‹ãƒ­ãƒƒã‚¯ã®å¯¾å¿œã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:592
msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has not"
" acquired the lock when this method is called, a :exc:`RuntimeError` is "
"raised."
msgstr ""
"é€šçŸ¥ (notify) ã‚’å—ã‘ã‚‹ã‹ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã™ã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚å‘¼ã³å‡ºã—å´ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¦ã„ãªã„ã¨ãã«ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¨ "
":exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:596
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another thread, or until the optional timeout occurs."
"  Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ ¹åº•ã«ã‚ã‚‹ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã€ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŒã˜æ¡ä»¶å¤‰æ•°ã«å¯¾ã—ã¦ :meth:`notify` ã¾ãŸã¯ :meth:`notify_all` "
"ã‚’å‘¼ã³å‡ºã—ã¦ç¾åœ¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èµ·ã“ã™ã‹ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç™ºç”Ÿã™ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ä¸€åº¦ã‚¹ãƒ¬ãƒƒãƒ‰ãŒèµ·ã“ã•ã‚Œã‚‹ã¨ã€å†åº¦ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¦å‡¦ç†ã‚’æˆ»ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:601
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""
"*timeout* å¼•æ•°ã‚’æŒ‡å®šã—ã¦ã€ ``None`` ä»¥å¤–ã®å€¤ã«ã™ã‚‹å ´åˆã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ç§’ (ã¾ãŸã¯ç«¯æ•°ç§’) ã‚’è¡¨ã™æµ®å‹•å°æ•°ç‚¹æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:605
msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using its "
":meth:`release` method, since this may not actually unlock the lock when it "
"was acquired multiple times recursively.  Instead, an internal interface of "
"the :class:`RLock` class is used, which really unlocks it even when it has "
"been recursively acquired several times. Another internal interface is then "
"used to restore the recursion level when the lock is reacquired."
msgstr ""
"æ ¹åº•ã«ã‚ã‚‹ãƒ­ãƒƒã‚¯ãŒ :class:`RLock` ã§ã‚ã‚‹å ´åˆã€ :meth:`release` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ãƒ­ãƒƒã‚¯ã¯è§£æ”¾ã•ã‚Œã¾ã›ã‚“ã€‚ã¨ã„ã†ã®ã‚‚ã€ãƒ­ãƒƒã‚¯ãŒå†å¸°çš„ã«è¤‡æ•°å›ç²å¾—ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯ã€ :meth:`release` "
"ã«ã‚ˆã£ã¦å®Ÿéš›ã«ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ãŒè¡Œã‚ã‚Œãªã„ã‹ã‚‚ã—ã‚Œãªã„ã‹ã‚‰ã§ã™ã€‚ãã®ä»£ã‚ã‚Šã€ãƒ­ãƒƒã‚¯ãŒå†å¸°çš„ã«è¤‡æ•°å›ç²å¾—ã•ã‚Œã¦ã„ã¦ã‚‚ç¢ºå®Ÿã«ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã‚’è¡Œãˆã‚‹ "
":class:`RLock` "
"ã‚¯ãƒ©ã‚¹ã®å†…éƒ¨ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä½¿ã„ã¾ã™ã€‚ãã®å¾Œãƒ­ãƒƒã‚¯ã‚’å†ç²å¾—ã™ã‚‹æ™‚ã«ã€ã‚‚ã†ä¸€ã¤ã®å†…éƒ¨ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä½¿ã£ã¦ãƒ­ãƒƒã‚¯ã®å†å¸°ãƒ¬ãƒ™ãƒ«ã‚’å¾©å¸°ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:613
msgid ""
"The return value is ``True`` unless a given *timeout* expired, in which case"
" it is ``False``."
msgstr ""
"ä¸ãˆã‚‰ã‚ŒãŸ *timeout* ãŒéãã¦ã„ãªã‘ã‚Œã°è¿”ã‚Šå€¤ã¯ ``True`` ã§ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸå ´åˆã«ã¯ ``False`` ãŒè¿”ã‚Šã¾ã™ã€‚"

#: ../../library/threading.rst:616 ../../library/threading.rst:828
msgid "Previously, the method always returned ``None``."
msgstr "ä»¥å‰ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¸¸ã« ``None`` ã‚’è¿”ã—ã¦ã„ã¾ã—ãŸã€‚"

#: ../../library/threading.rst:621
msgid ""
"Wait until a condition evaluates to true.  *predicate* should be a callable "
"which result will be interpreted as a boolean value. A *timeout* may be "
"provided giving the maximum time to wait."
msgstr ""
"æ¡ä»¶ãŒçœŸã¨åˆ¤å®šã•ã‚Œã‚‹ã¾ã§å¾…ã¡ã¾ã™ã€‚\n"
"*predicate* ã¯å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ãã®çµæœã¯ãƒ–ãƒ¼ãƒ«å€¤ã¨ã—ã¦è§£é‡ˆã•ã‚Œã¾ã™ã€‚\n"
"æœ€å¤§ã®å¾…ã¡æ™‚é–“ã‚’æŒ‡å®šã™ã‚‹ *timeout* ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/threading.rst:625
msgid ""
"This utility method may call :meth:`wait` repeatedly until the predicate is "
"satisfied, or until a timeout occurs. The return value is the last return "
"value of the predicate and will evaluate to ``False`` if the method timed "
"out."
msgstr ""
"ã“ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€è¿°èªãŒæº€ãŸã•ã‚Œã‚‹ã‹ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç™ºç”Ÿã™ã‚‹ã¾ã§ :meth:`wait` "
"ã‚’ç¹°ã‚Šè¿”ã—å‘¼ã³å‡ºã™å ´åˆãŒã‚ã‚Šã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯è¿°èªã®æœ€å¾Œã®æˆ»ã‚Šå€¤ã§ã€ã‚‚ã—ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã™ã‚Œã°ã€ ``False`` ã¨è©•ä¾¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:630
msgid ""
"Ignoring the timeout feature, calling this method is roughly equivalent to "
"writing::"
msgstr "ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ©Ÿèƒ½ã‚’ç„¡è¦–ã™ã‚Œã°ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ãã®ã¨ã»ã¼ç­‰ä¾¡ã§ã™::"

#: ../../library/threading.rst:636
msgid ""
"Therefore, the same rules apply as with :meth:`wait`: The lock must be held "
"when called and is re-acquired on return.  The predicate is evaluated with "
"the lock held."
msgstr ""
"ã—ãŸãŒã£ã¦ã€ :meth:`wait` ã¨åŒã˜ãƒ«ãƒ¼ãƒ«ãŒé©ç”¨ã•ã‚Œã¾ã™: "
"å‘¼ã³å‡ºã•ã‚ŒãŸæ™‚ã«ãƒ­ãƒƒã‚¯ã‚’ä¿æŒã—ã¦ã„ãªã‘ã‚Œã°ãªã‚‰ãšã€æˆ»ã‚‹ã¨ãã«ãƒ­ãƒƒã‚¯ãŒå†åº¦ç²å¾—ã•ã‚Œã¾ã™ã€‚è¿°èªã¯ãƒ­ãƒƒã‚¯ã‚’ä¿æŒã—ãŸçŠ¶æ…‹ã§è©•ä¾¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:644
msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the "
"calling thread has not acquired the lock when this method is called, a "
":exc:`RuntimeError` is raised."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã€ã“ã®æ¡ä»¶å¤‰æ•°ã‚’å¾…ã£ã¦ã„ã‚‹1ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èµ·ã“ã—ã¾ã™ã€‚ å‘¼ã³å‡ºã—å´ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¦ã„ãªã„ã¨ãã«ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¨ "
":exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:648
msgid ""
"This method wakes up at most *n* of the threads waiting for the condition "
"variable; it is a no-op if no threads are waiting."
msgstr "ä½•ã‚‰ã‹ã®å¾…æ©Ÿä¸­ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚ã‚‹å ´åˆã€ãã®ã†ã¡ *n* ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èµ·ã“ã—ã¾ã™ã€‚å¾…æ©Ÿä¸­ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãªã‘ã‚Œã°ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:651
msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""
"ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€å°‘ãªãã¨ã‚‚ *n* ã‚¹ãƒ¬ãƒƒãƒ‰ãŒå¾…æ©Ÿä¸­ã§ã‚ã‚Œã°ã€ã¡ã‚‡ã†ã© *n* "
"ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èµ·ã“ã—ã¾ã™ã€‚ã¨ã¯ã„ãˆã€ã“ã®æŒ™å‹•ã«ä¾å­˜ã™ã‚‹ã®ã¯å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å°†æ¥ã€å®Ÿè£…ã®æœ€é©åŒ–ã«ã‚ˆã£ã¦ã€è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èµ·ã“ã™ã‚ˆã†ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/threading.rst:656
msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` call"
" until it can reacquire the lock.  Since :meth:`notify` does not release the"
" lock, its caller should."
msgstr ""
"æ³¨æ„: èµ·ã“ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯å®Ÿéš›ã«ãƒ­ãƒƒã‚¯ã‚’å†ç²å¾—ã§ãã‚‹ã¾ã§ :meth:`wait` å‘¼ã³å‡ºã—ã‹ã‚‰æˆ»ã‚Šã¾ã›ã‚“ã€‚ :meth:`notify` "
"ã¯ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ãªã„ã®ã§ã€ :meth:`notify` å‘¼ã³å‡ºã—å´ã¯æ˜ç¤ºçš„ã«ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:662
msgid ""
"Wake up all threads waiting on this condition.  This method acts like "
":meth:`notify`, but wakes up all waiting threads instead of one. If the "
"calling thread has not acquired the lock when this method is called, a "
":exc:`RuntimeError` is raised."
msgstr ""
"ã“ã®æ¡ä»¶ã‚’å¾…ã£ã¦ã„ã‚‹ã™ã¹ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èµ·ã“ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :meth:`notify` ã®ã‚ˆã†ã«å‹•ä½œã—ã¾ã™ãŒã€ 1 "
"ã¤ã§ã¯ãªãã™ã¹ã¦ã®å¾…ã¡ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èµ·ã“ã—ã¾ã™ã€‚å‘¼ã³å‡ºã—å´ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¦ã„ãªã„å ´åˆã€ :exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:671
msgid "Semaphore Objects"
msgstr "Semaphore ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/threading.rst:673
msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger W. "
"Dijkstra (he used the names ``P()`` and ``V()`` instead of "
":meth:`~Semaphore.acquire` and :meth:`~Semaphore.release`)."
msgstr ""
"ã‚»ãƒãƒ•ã‚© (semaphore) ã¯ã€è¨ˆç®—æ©Ÿç§‘å­¦å²ä¸Šæœ€ã‚‚å¤ã„åŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®ä¸€ã¤ ã§ã€è‰å‰µæœŸã®ã‚ªãƒ©ãƒ³ãƒ€è¨ˆç®—æ©Ÿç§‘å­¦è€… Edsger W. "
"Dijkstra ã«ã‚ˆã£ã¦ç™ºæ˜ã•ã‚Œã¾ã—ãŸ (å½¼ã¯ :meth:`~Semaphore.acquire` ã¨ "
":meth:`~Semaphore.release` ã®ä»£ã‚ã‚Šã« ``P()`` ã¨ ``V()`` ã‚’ä½¿ã„ã¾ã—ãŸ)ã€‚"

#: ../../library/threading.rst:678
msgid ""
"A semaphore manages an internal counter which is decremented by each "
":meth:`~Semaphore.acquire` call and incremented by each "
":meth:`~Semaphore.release` call.  The counter can never go below zero; when "
":meth:`~Semaphore.acquire` finds that it is zero, it blocks, waiting until "
"some other thread calls :meth:`~Semaphore.release`."
msgstr ""
"ã‚»ãƒãƒ•ã‚©ã¯ :meth:`~Semaphore.acquire` ã§ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œ :meth:`~Semaphore.release` "
"ã§ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œã‚‹ã‚ˆã†ãªå†…éƒ¨ã‚«ã‚¦ãƒ³ã‚¿ã‚’ç®¡ç†ã—ã¾ã™ã€‚ ã‚«ã‚¦ãƒ³ã‚¿ã¯æ±ºã—ã¦ã‚¼ãƒ­ã‚ˆã‚Šå°ã•ãã¯ãªã‚Šã¾ã›ã‚“; "
":meth:`~Semaphore.acquire` ã¯ã€ã‚«ã‚¦ãƒ³ã‚¿ãŒã‚¼ãƒ­ã«ãªã£ã¦ã„ã‚‹å ´åˆã€ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒ "
":meth:`~Semaphore.release` ã‚’å‘¼ã³å‡ºã™ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:684
msgid ""
"Semaphores also support the :ref:`context management protocol <with-locks>`."
msgstr "ã‚»ãƒãƒ•ã‚©ã¯ :ref:`ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ« <with-locks>` ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../library/threading.rst:689
msgid ""
"This class implements semaphore objects.  A semaphore manages an atomic "
"counter representing the number of :meth:`release` calls minus the number of"
" :meth:`acquire` calls, plus an initial value.  The :meth:`acquire` method "
"blocks if necessary until it can return without making the counter negative."
" If not given, *value* defaults to 1."
msgstr ""

#: ../../library/threading.rst:695
msgid ""
"The optional argument gives the initial *value* for the internal counter; it"
" defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` "
"is raised."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•°ã«ã¯ã€å†…éƒ¨ã‚«ã‚¦ãƒ³ã‚¿ã®åˆæœŸå€¤ã‚’æŒ‡å®šã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``1`` ã§ã™ã€‚ä¸ãˆã‚‰ã‚ŒãŸ *value* ãŒ 0 ã‚ˆã‚Šå°ã•ã„å ´åˆã€ "
":exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:704
msgid "Acquire a semaphore."
msgstr "ã‚»ãƒãƒ•ã‚©ã‚’ç²å¾—ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:706
msgid "When invoked without arguments:"
msgstr ""

#: ../../library/threading.rst:708
msgid ""
"If the internal counter is larger than zero on entry, decrement it by one "
"and return true immediately."
msgstr ""

#: ../../library/threading.rst:710
msgid ""
"If the internal counter is zero on entry, block until awoken by a call to "
":meth:`~Semaphore.release`.  Once awoken (and the counter is greater than "
"0), decrement the counter by 1 and return true.  Exactly one thread will be "
"awoken by each call to :meth:`~Semaphore.release`.  The order in which "
"threads are awoken should not be relied on."
msgstr ""

#: ../../library/threading.rst:716
msgid ""
"When invoked with *blocking* set to false, do not block.  If a call without "
"an argument would block, return false immediately; otherwise, do the same "
"thing as when called without arguments, and return true."
msgstr ""
"*blocking* ã‚’ false ã«ã—ã¦å‘¼ã³å‡ºã™ã¨ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚å¼•æ•°ãªã—ã§å‘¼ã³å‡ºã—ãŸå ´åˆã«ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã‚ˆã†ãªçŠ¶æ³ã§ã‚ã£ãŸå ´åˆã«ã¯ç›´ã¡ã« "
"false ã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€å¼•æ•°ãªã—ã§å‘¼ã³å‡ºã—ãŸã¨ãã¨åŒã˜å‡¦ç†ã‚’è¡Œã„ true ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:720
msgid ""
"When invoked with a *timeout* other than ``None``, it will block for at most"
" *timeout* seconds.  If acquire does not complete successfully in that "
"interval, return false.  Return true otherwise."
msgstr ""
"``None`` ä»¥å¤–ã® *timeout* ã§èµ·å‹•ã•ã‚ŒãŸå ´åˆã€æœ€å¤§ã§ *timeout* ç§’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚\n"
"acquire ãŒ ãã®é–“éš”ã®é–“ã§å®Œäº†ã—ãªã‹ã£ãŸå ´åˆã¯ false ãŒè¿”ã‚Šã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° true ãŒè¿”ã‚Šã¾ã™ã€‚"

#: ../../library/threading.rst:729
msgid ""
"Release a semaphore, incrementing the internal counter by one.  When it was "
"zero on entry and another thread is waiting for it to become larger than "
"zero again, wake up that thread."
msgstr ""
"å†…éƒ¨ã‚«ã‚¦ãƒ³ã‚¿ã‚’ 1 ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦ã€ã‚»ãƒãƒ•ã‚©ã‚’è§£æ”¾ã—ã¾ã™ã€‚ :meth:`release` "
"å‡¦ç†ã«å…¥ã£ãŸã¨ãã«ã‚«ã‚¦ãƒ³ã‚¿ãŒã‚¼ãƒ­ã§ã‚ã‚Šã€ã‚«ã‚¦ãƒ³ã‚¿ã®å€¤ãŒã‚¼ãƒ­ã‚ˆã‚Šå¤§ãããªã‚‹ã®ã‚’å¾…ã£ã¦ã„ã‚‹åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚ã£ãŸå ´åˆã€ãã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èµ·ã“ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:736
msgid ""
"Class implementing bounded semaphore objects.  A bounded semaphore checks to"
" make sure its current value doesn't exceed its initial value.  If it does, "
":exc:`ValueError` is raised. In most situations semaphores are used to guard"
" resources with limited capacity.  If the semaphore is released too many "
"times it's a sign of a bug.  If not given, *value* defaults to 1."
msgstr ""
"æœ‰é™ã‚»ãƒãƒ•ã‚© (bounded semaphore) "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã§ã™ã€‚æœ‰é™ã‚»ãƒãƒ•ã‚©ã¯ã€ç¾åœ¨ã®å€¤ãŒåˆæœŸå€¤ã‚’è¶…éã—ãªã„ã‚ˆã†ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã„ã¾ã™ã€‚è¶…éã‚’èµ·ã“ã—ãŸå ´åˆã€ "
":exc:`ValueError` "
"ã‚’é€å‡ºã—ã¾ã™ã€‚ãŸã„ã¦ã„ã®å ´åˆã€ã‚»ãƒãƒ•ã‚©ã¯é™ã‚‰ã‚ŒãŸå®¹é‡ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ä¿è­·ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹ã‚‚ã®ã§ã™ã€‚å¾“ã£ã¦ã€ã‚ã¾ã‚Šã«ã‚‚é »ç¹ãªã‚»ãƒãƒ•ã‚©ã®è§£æ”¾ã¯ãƒã‚°ãŒç”Ÿã˜ã¦ã„ã‚‹ã—ã‚‹ã—ã§ã™ã€‚"
" *value* ã‚’æŒ‡å®šã—ãªã„å ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å€¤ã¯ 1 ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/threading.rst:749
msgid ":class:`Semaphore` Example"
msgstr ":class:`Semaphore` ã®ä¾‹"

#: ../../library/threading.rst:751
msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the resource"
" is fixed, you should use a bounded semaphore.  Before spawning any worker "
"threads, your main thread would initialize the semaphore::"
msgstr ""
"ã‚»ãƒãƒ•ã‚©ã¯ã—ã°ã—ã°ã€å®¹é‡ã«é™ã‚Šã®ã‚ã‚‹è³‡æºã€ä¾‹ãˆã°ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚µãƒ¼ãƒãªã©ã‚’ä¿è­·ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ãƒªã‚½ãƒ¼ã‚¹ãŒå›ºå®šã®çŠ¶æ³ã§ã¯ã€å¸¸ã«æœ‰é™ã‚»ãƒãƒ•ã‚©ã‚’ä½¿ã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¸»ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ä½œæ¥­ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ç«‹ã¡ä¸Šã’ã‚‹å‰ã«ã‚»ãƒãƒ•ã‚©ã‚’åˆæœŸåŒ–ã—ã¾ã™::"

#: ../../library/threading.rst:760
msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr ""
"ä½œæ¥­ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ã²ã¨ãŸã³ç«‹ã¡ä¸ŠãŒã‚‹ã¨ã€ã‚µãƒ¼ãƒã¸æ¥ç¶šã™ã‚‹å¿…è¦ãŒç”Ÿã˜ãŸã¨ãã«ã‚»ãƒãƒ•ã‚©ã® :meth:`acquire` ãŠã‚ˆã³ "
":meth:`release` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™::"

#: ../../library/threading.rst:770
msgid ""
"The use of a bounded semaphore reduces the chance that a programming error "
"which causes the semaphore to be released more than it's acquired will go "
"undetected."
msgstr "æœ‰é™ã‚»ãƒãƒ•ã‚©ã‚’ä½¿ã†ã¨ã€ã‚»ãƒãƒ•ã‚©ã‚’ç²å¾—å›æ•°ä»¥ä¸Šã«è§£æ”¾ã—ã¦ã—ã¾ã†ã¨ã„ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸Šã®é–“é•ã„ã‚’è¦‹é€ƒã—ã«ããã—ã¾ã™ã€‚"

#: ../../library/threading.rst:777
msgid "Event Objects"
msgstr "Event ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/threading.rst:779
msgid ""
"This is one of the simplest mechanisms for communication between threads: "
"one thread signals an event and other threads wait for it."
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆã¯ã€ã‚ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºä¿¡ã—ã€ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãã‚Œã‚’å¾…ã¤ã¨ã„ã†ã€ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§é€šä¿¡ã‚’è¡Œã†ãŸã‚ã®æœ€ã‚‚å˜ç´”ãªãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã®ä¸€ã¤ã§ã™ã€‚"

#: ../../library/threading.rst:782
msgid ""
"An event object manages an internal flag that can be set to true with the "
":meth:`~Event.set` method and reset to false with the :meth:`~Event.clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is true."
msgstr ""
"ã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å†…éƒ¨ãƒ•ãƒ©ã‚°ã‚’ç®¡ç†ã—ã¾ã™ã€‚ã“ã®ãƒ•ãƒ©ã‚°ã¯ :meth:`~Event.set` ãƒ¡ã‚½ãƒƒãƒ‰ã§å€¤ã‚’ true ã«ã€ "
":meth:`~Event.clear` ãƒ¡ã‚½ãƒƒãƒ‰ã§å€¤ã‚’ false ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚ :meth:`~Event.wait` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ•ãƒ©ã‚°ãŒ "
"true ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:789
msgid ""
"Class implementing event objects.  An event manages a flag that can be set "
"to true with the :meth:`~Event.set` method and reset to false with the "
":meth:`clear` method.  The :meth:`wait` method blocks until the flag is "
"true. The flag is initially false."
msgstr ""
"ã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ã‚¤ãƒ™ãƒ³ãƒˆã¯ :meth:`~Event.set` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã¨ :const:`True` ã«ã€ "
":meth:`clear` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã¨ :const:`False` ã«ã‚»ãƒƒãƒˆã•ã‚Œã‚‹ã‚ˆã†ãªãƒ•ãƒ©ã‚°ã‚’ç®¡ç†ã—ã¾ã™ã€‚ :meth:`wait` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å…¨ã¦ã®ãƒ•ãƒ©ã‚°ãŒ true ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚ãƒ•ãƒ©ã‚°ã®åˆæœŸå€¤ã¯ false ã§ã™ã€‚"

#: ../../library/threading.rst:799
msgid "Return true if and only if the internal flag is true."
msgstr "å†…éƒ¨ãƒ•ãƒ©ã‚°ã®å€¤ãŒ true ã§ã‚ã‚‹å ´åˆã«ã®ã¿ true ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:803
msgid ""
"Set the internal flag to true. All threads waiting for it to become true are"
" awakened. Threads that call :meth:`wait` once the flag is true will not "
"block at all."
msgstr ""
"å†…éƒ¨ãƒ•ãƒ©ã‚°ã®å€¤ã‚’ true ã«ã‚»ãƒƒãƒˆã—ã¾ã™ã€‚ãƒ•ãƒ©ã‚°ã®å€¤ãŒ true ã«ãªã‚‹ã®ã‚’å¾…ã£ã¦ã„ã‚‹å…¨ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èµ·ã“ã—ã¾ã™ã€‚ä¸€æ—¦ãƒ•ãƒ©ã‚°ãŒ true "
"ã«ãªã‚‹ã¨ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãŒ :meth:`wait` ã‚’å‘¼ã³å‡ºã—ã¦ã‚‚å…¨ããƒ–ãƒ­ãƒƒã‚¯ã—ãªããªã‚Šã¾ã™ã€‚"

#: ../../library/threading.rst:809
msgid ""
"Reset the internal flag to false. Subsequently, threads calling :meth:`wait`"
" will block until :meth:`.set` is called to set the internal flag to true "
"again."
msgstr ""
"å†…éƒ¨ãƒ•ãƒ©ã‚°ã®å€¤ã‚’ false ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚ä»¥é™ã¯ã€ :meth:`.set` ã‚’å‘¼ã³å‡ºã—ã¦å†ã³å†…éƒ¨ãƒ•ãƒ©ã‚°ã®å€¤ã‚’ true ã«ã‚»ãƒƒãƒˆã™ã‚‹ã¾ã§ã€ "
":meth:`wait` ã‚’å‘¼ã³å‡ºã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/threading.rst:815
msgid ""
"Block until the internal flag is true.  If the internal flag is true on "
"entry, return immediately.  Otherwise, block until another thread calls "
":meth:`.set` to set the flag to true, or until the optional timeout occurs."
msgstr ""
"å†…éƒ¨ãƒ•ãƒ©ã‚°ã®å€¤ãŒ true ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ :meth:`wait` å‡¦ç†ã«å…¥ã£ãŸæ™‚ç‚¹ã§å†…éƒ¨ãƒ•ãƒ©ã‚°ã®å€¤ãŒ true "
"ã§ã‚ã‚Œã°ã€ç›´ã¡ã«å‡¦ç†ã‚’æˆ»ã—ã¾ã™ã€‚ãã†ã§ãªã„å ´åˆã€ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒ :meth:`.set` ã‚’å‘¼ã³å‡ºã—ã¦ãƒ•ãƒ©ã‚°ã®å€¤ã‚’ true "
"ã«ã‚»ãƒƒãƒˆã™ã‚‹ã‹ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç™ºç”Ÿã™ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:819
msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""
"*timeout* å¼•æ•°ã‚’æŒ‡å®šã—ã¦ã€ ``None`` ä»¥å¤–ã®å€¤ã«ã™ã‚‹å ´åˆã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ç§’ (ã¾ãŸã¯ç«¯æ•°ç§’) ã‚’è¡¨ã™æµ®å‹•å°æ•°ç‚¹æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:823
msgid ""
"This method returns true if and only if the internal flag has been set to "
"true, either before the wait call or after the wait starts, so it will "
"always return ``True`` except if a timeout is given and the operation times "
"out."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€wait å‘¼ã³å‡ºã—ã®å‰ã‚ã‚‹ã„ã¯ wait ãŒé–‹å§‹ã—ãŸå¾Œã«ã€å†…éƒ¨ãƒ•ãƒ©ã‚°ãŒ true ã«ã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã«é™ã‚Š *true* "
"ã‚’è¿”ã—ã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒä¸ãˆã‚‰ã‚Œã¦æ“ä½œãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸå ´åˆã‚’é™¤ãå¸¸ã« ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/threading.rst:835
msgid "Timer Objects"
msgstr "Timer ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/threading.rst:837
msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of "
":class:`Thread` and as such also functions as an example of creating custom "
"threads."
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹ã¯ã€ä¸€å®šæ™‚é–“çµŒéå¾Œã«å®Ÿè¡Œã•ã‚Œã‚‹æ´»å‹•ã€ã™ãªã‚ã¡ã‚¿ã‚¤ãƒæ´»å‹•ã‚’è¡¨ç¾ã—ã¾ã™ã€‚ :class:`Timer` ã¯ :class:`Thread` "
"ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€è‡ªä½œã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’æ§‹ç¯‰ã—ãŸä¸€ä¾‹ã§ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/threading.rst:841
msgid ""
"Timers are started, as with threads, by calling their :meth:`~Timer.start` "
"method.  The timer can be stopped (before its action has begun) by calling "
"the :meth:`~Timer.cancel` method.  The interval the timer will wait before "
"executing its action may not be exactly the same as the interval specified "
"by the user."
msgstr ""
"ã‚¿ã‚¤ãƒã¯ :meth:`~Timer.start` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¨ã‚¹ãƒ¬ãƒƒãƒ‰ã¨ã—ã¦ä½œå‹•ã—å§‹ã‚ã—ã¾ã™ã€‚ (æ´»å‹•ã‚’é–‹å§‹ã™ã‚‹å‰ã«) "
":meth:`~Timer.cancel` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¨ã€ã‚¿ã‚¤ãƒã‚’åœæ­¢ã§ãã¾ã™ã€‚ã‚¿ã‚¤ãƒãŒæ´»å‹•ã‚’å®Ÿè¡Œã™ã‚‹ã¾ã§ã®å¾…ã¡æ™‚é–“ã¯ã€ãƒ¦ãƒ¼ã‚¶ãŒæŒ‡å®šã—ãŸå¾…ã¡æ™‚é–“ã¨å¿…ãšã—ã‚‚å³å¯†ã«ã¯ä¸€è‡´ã—ã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:847
msgid "For example::"
msgstr "ä¾‹ãˆã°::"

#: ../../library/threading.rst:858
msgid ""
"Create a timer that will run *function* with arguments *args* and  keyword "
"arguments *kwargs*, after *interval* seconds have passed. If *args* is "
"``None`` (the default) then an empty list will be used. If *kwargs* is "
"``None`` (the default) then an empty dict will be used."
msgstr ""
"*interval* ç§’å¾Œã«å¼•æ•° *args* ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•° *kwargs* ã§ *function* "
"ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ãªã‚¿ã‚¤ãƒã‚’ç”Ÿæˆã—ã¾ã™ã€‚*args*ãŒ ``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ç©ºã®ãƒªã‚¹ãƒˆãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚*kwargs* ãŒ "
"``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ç©ºã®è¾æ›¸ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:868
msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This will "
"only work if the timer is still in its waiting stage."
msgstr "ã‚¿ã‚¤ãƒã‚’ã‚¹ãƒˆãƒƒãƒ—ã—ã¦ã€ãã®å‹•ä½œã®å®Ÿè¡Œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¿ã‚¤ãƒãŒã¾ã æ´»å‹•å¾…ã¡çŠ¶æ…‹ã«ã‚ã‚‹å ´åˆã«ã®ã¿å‹•ä½œã—ã¾ã™ã€‚"

#: ../../library/threading.rst:873
msgid "Barrier Objects"
msgstr "ãƒãƒªã‚¢ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/threading.rst:877
msgid ""
"This class provides a simple synchronization primitive for use by a fixed "
"number of threads that need to wait for each other.  Each of the threads "
"tries to pass the barrier by calling the :meth:`~Barrier.wait` method and "
"will block until all of the threads have made their :meth:`~Barrier.wait` "
"calls. At this point, the threads are released simultaneously."
msgstr ""

#: ../../library/threading.rst:883
msgid ""
"The barrier can be reused any number of times for the same number of "
"threads."
msgstr "ãƒãƒªã‚¢ã¯åŒã˜æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾ã—ã¦ä½•åº¦ã§ã‚‚å†åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/threading.rst:885
msgid ""
"As an example, here is a simple way to synchronize a client and server "
"thread::"
msgstr "ä¾‹ã¨ã—ã¦ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚µãƒ¼ãƒã®é–“ã§ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’åŒæœŸã•ã›ã‚‹å˜ç´”ãªæ–¹æ³•ã‚’ç´¹ä»‹ã—ã¾ã™::"

#: ../../library/threading.rst:905
msgid ""
"Create a barrier object for *parties* number of threads.  An *action*, when "
"provided, is a callable to be called by one of the threads when they are "
"released.  *timeout* is the default timeout value if none is specified for "
"the :meth:`wait` method."
msgstr ""
"*parties* å€‹ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®ãŸã‚ã®ãƒãƒªã‚¢ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚ *action* "
"ã¯ã€ã‚‚ã—æä¾›ã•ã‚Œã‚‹ãªã‚‰å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãŒè§£æ”¾ã•ã‚Œã‚‹æ™‚ã«ãã®ã†ã¡ã®1ã¤ã«ã‚ˆã£ã¦å‘¼ã°ã‚Œã¾ã™ã€‚ *timeout* ã¯ã€ "
":meth:`wait` ãƒ¡ã‚½ãƒƒãƒ‰ã«å¯¾ã—ã¦ none ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ã§ã™ã€‚"

#: ../../library/threading.rst:912
msgid ""
"Pass the barrier.  When all the threads party to the barrier have called "
"this function, they are all released simultaneously.  If a *timeout* is "
"provided, it is used in preference to any that was supplied to the class "
"constructor."
msgstr ""
"ãƒãƒªã‚¢ã‚’é€šã‚Šã¾ã™ã€‚ãƒãƒªã‚¢ã«å¯¾ã™ã‚‹ã™ã¹ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã“ã®é–¢æ•°ã‚’å‘¼ã‚“ã æ™‚ã«ã€ãã‚Œã‚‰ã¯åŒæ™‚ã«ã™ã¹ã¦è§£æ”¾ã•ã‚Œã¾ã™ã€‚*timeout* "
"ãŒæä¾›ã•ã‚Œã‚‹å ´åˆã€ãã‚Œã¯ã‚¯ãƒ©ã‚¹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«æ¸¡ã•ã‚ŒãŸå€¤ã«å„ªå…ˆã—ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:917
msgid ""
"The return value is an integer in the range 0 to *parties* -- 1, different "
"for each thread.  This can be used to select a thread to do some special "
"housekeeping, e.g.::"
msgstr ""
"è¿”ã‚Šå€¤ã¯ 0 ã‹ã‚‰ *parties* -- 1 ã®ç¯„å›²ã®æ•´æ•°ã§ã€ãã‚Œãã‚Œã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾ã—ã¦ç•°ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€ç‰¹åˆ¥ãªå¾Œå§‹æœ« "
"(housekeeping) ã‚’è¡Œã†ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é¸æŠã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/threading.rst:926
msgid ""
"If an *action* was provided to the constructor, one of the threads will have"
" called it prior to being released.  Should this call raise an error, the "
"barrier is put into the broken state."
msgstr ""
"*action* "
"ãŒã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«æ¸¡ã•ã‚Œã¦ã„ã‚Œã°ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã†ã¡ã®1ã¤ãŒè§£æ”¾ã•ã‚Œã‚‹å‰ã«ãã‚Œã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ä¸‡ä¸€ã“ã®å‘¼ã³å‡ºã—ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã€ãƒãƒªã‚¢ã¯ broken"
" ãªçŠ¶æ…‹ã«é™¥ã‚Šã¾ã™ã€‚"

#: ../../library/threading.rst:930
msgid "If the call times out, the barrier is put into the broken state."
msgstr "ã“ã®å‘¼ã³å‡ºã—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã™ã‚‹å ´åˆã€ãƒãƒªã‚¢ã¯ broken ãªçŠ¶æ…‹ã«é™¥ã‚Šã¾ã™ã€‚"

#: ../../library/threading.rst:932
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier"
" is broken or reset while a thread is waiting."
msgstr ""
"ã‚¹ãƒ¬ãƒƒãƒ‰ãŒå¾…ã£ã¦ã„ã‚‹é–“ã«ãƒãƒªã‚¢ãŒ broken ã«ãªã‚‹ã‹ãƒªã‚»ãƒƒãƒˆã•ã‚ŒãŸå ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :class:`BrokenBarrierError` "
"ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:937
msgid ""
"Return the barrier to the default, empty state.  Any threads waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""
"ãƒãƒªã‚¢ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ç©ºã®çŠ¶æ…‹ã«æˆ»ã—ã¾ã™ã€‚ãã®ãƒãƒªã‚¢ã®ä¸Šã§å¾…ã£ã¦ã„ã‚‹ã™ã¹ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ :class:`BrokenBarrierError` "
"ä¾‹å¤–ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚"

#: ../../library/threading.rst:940
msgid ""
"Note that using this function may can require some external synchronization "
"if there are other threads whose state is unknown.  If a barrier is broken "
"it may be better to just leave it and create a new one."
msgstr ""
"çŠ¶æ…‹ãŒæœªçŸ¥ã®ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚ã‚‹å ´åˆã€ã“ã®é–¢æ•°ã‚’ä½¿ç”¨ã™ã‚‹ã®ã«ä½•ã‚‰ã‹ã®å¤–éƒ¨åŒæœŸã‚’å¿…è¦ã¨ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãƒãƒªã‚¢ãŒ broken "
"ãªå ´åˆã€å˜ã«ãã‚Œã‚’ãã®ã¾ã¾ã«ã—ã¦æ–°ã—ã„ã‚‚ã®ã‚’ä½œæˆã™ã‚‹æ–¹ãŒã‚ˆã„ã§ã—ã‚‡ã†ã€‚"

#: ../../library/threading.rst:946
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls"
" to :meth:`wait` to fail with the :class:`BrokenBarrierError`.  Use this for"
" example if one of the needs to abort, to avoid deadlocking the application."
msgstr ""
"ãƒãƒªã‚¢ã‚’ broken ãªçŠ¶æ…‹ã«ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã£ã¦ã€ç¾åœ¨ã¾ãŸã¯å°†æ¥ã® :meth:`wait` å‘¼ã³å‡ºã—ãŒ "
":class:`BrokenBarrierError` "
"ã¨ã¨ã‚‚ã«å¤±æ•—ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã‚’ä½¿ã†ã¨ã€ä¾‹ãˆã°ç•°å¸¸çµ‚äº†ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã«ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã™ã‚‹ã®ã‚’é¿ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/threading.rst:951
msgid ""
"It may be preferable to simply create the barrier with a sensible *timeout* "
"value to automatically guard against one of the threads going awry."
msgstr ""
"ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã†ã¡ã®1ã¤ãŒè¿”ã£ã¦ã“ãªã„ã“ã¨ã«å¯¾ã—ã¦è‡ªå‹•çš„ã«ä¿è­·ã™ã‚‹ã‚ˆã†ã«ã€å˜ç´”ã«å¸¸è­˜çš„ãª *timeout* "
"å€¤ã§ãƒãƒªã‚¢ã‚’ä½œæˆã™ã‚‹ã“ã¨ã¯æœ›ã¾ã—ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/threading.rst:957
msgid "The number of threads required to pass the barrier."
msgstr "ãƒãƒªã‚¢ã‚’é€šã‚‹ãŸã‚ã«è¦æ±‚ã•ã‚Œã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã®æ•°ã€‚"

#: ../../library/threading.rst:961
msgid "The number of threads currently waiting in the barrier."
msgstr "ç¾åœ¨ãƒãƒªã‚¢ã®ä¸­ã§å¾…ã£ã¦ã„ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã®æ•°ã€‚"

#: ../../library/threading.rst:965
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr "ãƒãƒªã‚¢ãŒ broken ãªçŠ¶æ…‹ã§ã‚ã‚‹å ´åˆã« ``True`` ã¨ãªã‚‹ãƒ–ãƒ¼ãƒ«å€¤ã€‚"

#: ../../library/threading.rst:970
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the "
":class:`Barrier` object is reset or broken."
msgstr ""
":class:`Barrier` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹ã‹ broken ãªå ´åˆã«ã€ã“ã®ä¾‹å¤– (:exc:`RuntimeError` "
"ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹) ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/threading.rst:977
msgid ""
"Using locks, conditions, and semaphores in the :keyword:`with` statement"
msgstr ":keyword:`with` æ–‡ã§ã®ãƒ­ãƒƒã‚¯ãƒ»æ¡ä»¶å¤‰æ•°ãƒ»ã‚»ãƒãƒ•ã‚©ã®ä½¿ã„æ–¹"

#: ../../library/threading.rst:979
msgid ""
"All of the objects provided by this module that have :meth:`acquire` and "
":meth:`release` methods can be used as context managers for a "
":keyword:`with` statement.  The :meth:`acquire` method will be called when "
"the block is entered, and :meth:`release` will be called when the block is "
"exited.  Hence, the following snippet::"
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã†ã¡ :meth:`acquire` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ :meth:`release` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‚™ãˆã¦ã„ã‚‹ã‚‚ã®ã¯å…¨ã¦ "
":keyword:`with` æ–‡ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ ã¨ã—ã¦ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ :keyword:`with` æ–‡ã®ãƒ–ãƒ­ãƒƒã‚¯ã«å…¥ã‚‹ã¨ãã« "
":meth:`acquire` ãƒ¡ã‚½ãƒƒãƒ‰ãŒ å‘¼ã³å‡ºã•ã‚Œã€ãƒ–ãƒ­ãƒƒã‚¯è„±å‡ºæ™‚ã«ã¯ :meth:`release` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰::"

#: ../../library/threading.rst:988
msgid "is equivalent to::"
msgstr "ã¯ã€ä»¥ä¸‹ã¨åŒã˜ã§ã™ ::"

#: ../../library/threading.rst:996
msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, "
":class:`Semaphore`, and :class:`BoundedSemaphore` objects may be used as "
":keyword:`with` statement context managers."
msgstr ""
"ç¾åœ¨ã®ã¨ã“ã‚ã€ :class:`Lock` ã€ :class:`RLock` ã€ :class:`Condition` ã€ "
":class:`Semaphore` ã€ :class:`BoundedSemaphore` ã‚’ :keyword:`with` "
"æ–‡ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¨ã—ã¦ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"
