# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Takeshi Nakazato, 2023
# HIdeo Haga, 2023
# tomo, 2024
# 石井明久, 2024
# Takanori Suzuki <takanori@takanory.net>, 2024
# Arihiro TAKASE, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-11 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: Arihiro TAKASE, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/sqlite3.rst:2
msgid ":mod:`!sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ""
":mod:`!sqlite3` --- SQLite データベース用の DB-API 2.0 インターフェース"

#: ../../library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**ソースコード:** :source:`Lib/sqlite3/`"

#: ../../library/sqlite3.rst:25
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can "
"use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as "
"PostgreSQL or Oracle."
msgstr ""
"SQLite は、軽量なディスク上のデータベースを提供する C ライブラリです。別の"
"サーバプロセスを用意する必要なく、 SQL クエリー言語の非標準的な一種を使用して"
"データベースにアクセスできます。一部のアプリケーションは内部データ保存に "
"SQLite を使えます。また、SQLite を使ってアプリケーションのプロトタイプを作"
"り、その後そのコードを PostgreSQL や Oracle のような大規模データベースに移植"
"するということも可能です。"

#: ../../library/sqlite3.rst:32
msgid ""
"The :mod:`!sqlite3` module was written by Gerhard Häring.  It provides an "
"SQL interface compliant with the DB-API 2.0 specification described by :pep:"
"`249`, and requires SQLite 3.15.2 or newer."
msgstr ""

#: ../../library/sqlite3.rst:36
msgid "This document includes four main sections:"
msgstr "この文書には大きく分けて 4 つの節があります:"

#: ../../library/sqlite3.rst:38
msgid ":ref:`sqlite3-tutorial` teaches how to use the :mod:`!sqlite3` module."
msgstr ":ref:`sqlite3-tutorial` :mod:`!sqlite3` モジュールの使い方を学びます。"

#: ../../library/sqlite3.rst:39
msgid ""
":ref:`sqlite3-reference` describes the classes and functions this module "
"defines."
msgstr ""
":ref:`sqlite3-reference` このモジュールが定義するクラスと関数について説明しま"
"す。"

#: ../../library/sqlite3.rst:41
msgid ":ref:`sqlite3-howtos` details how to handle specific tasks."
msgstr ":ref:`sqlite3-howtos` 特定のタスクの処理方法について詳しく説明します。"

#: ../../library/sqlite3.rst:42
msgid ""
":ref:`sqlite3-explanation` provides in-depth background on transaction "
"control."
msgstr ""
":ref:`sqlite3-explanation` トランザクション制御の背景をより深く掘り下げて説明"
"します。"

#: ../../library/sqlite3.rst:47
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../library/sqlite3.rst:48
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr ""
"SQLite のウェブページ。ここの文書ではサポートされる SQL 方言の文法と使える"
"データ型を説明しています。"

#: ../../library/sqlite3.rst:51
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: ../../library/sqlite3.rst:52
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "SQL 学習に効くチュートリアル、リファレンス、実例集。"

#: ../../library/sqlite3.rst:54
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - Database API Specification 2.0"

#: ../../library/sqlite3.rst:55
msgid "PEP written by Marc-André Lemburg."
msgstr "Marc-Andre Lemburg により書かれた PEP。"

#: ../../library/sqlite3.rst:68
msgid "Tutorial"
msgstr "チュートリアル"

#: ../../library/sqlite3.rst:70
msgid ""
"In this tutorial, you will create a database of Monty Python movies using "
"basic :mod:`!sqlite3` functionality. It assumes a fundamental understanding "
"of database concepts, including `cursors`_ and `transactions`_."
msgstr ""
"このチュートリアルでは、あなたは基本的な :mod:`!sqlite3` 機能を使用して、 例"
"としてモンティ・パイソンの映画のデータベースを作成します。 あなたがカーソル"
"(`cursors`_)やトランザクション(`transactions`_)を含むデータベースの基本概念を"
"理解していることを前提としています。"

#: ../../library/sqlite3.rst:75
msgid ""
"First, we need to create a new database and open a database connection to "
"allow :mod:`!sqlite3` to work with it. Call :func:`sqlite3.connect` to "
"create a connection to the database :file:`tutorial.db` in the current "
"working directory, implicitly creating it if it does not exist:"
msgstr ""
"最初に、新しいデータベースを作成し、データベース接続(connection)を開いて :"
"mod:`!sqlite3` が動作できるようにする必要があります。 :func:`sqlite3."
"connect` を呼び出して、データベース :file:`tutorial.db` への接続を現在の作業"
"ディレクトリに作成します。存在しない場合は暗黙的に作成します。"

#: ../../library/sqlite3.rst:81
msgid ""
"import sqlite3\n"
"con = sqlite3.connect(\"tutorial.db\")"
msgstr ""

#: ../../library/sqlite3.rst:86
msgid ""
"The returned :class:`Connection` object ``con`` represents the connection to "
"the on-disk database."
msgstr ""
"返された :class:`Connection` オブジェクト ``con`` は、ディスク上のデータベー"
"スへの接続を表します。"

#: ../../library/sqlite3.rst:89
msgid ""
"In order to execute SQL statements and fetch results from SQL queries, we "
"will need to use a database cursor. Call :meth:`con.cursor() <Connection."
"cursor>` to create the :class:`Cursor`:"
msgstr ""
"SQL 文を実行し、SQL クエリから結果を取得するには、データベース・カーソルを使"
"用する必要があります。 :meth:`con.cursor() <Connection.cursor>` を呼び出し"
"て :class:`Cursor` を作成してください:"

#: ../../library/sqlite3.rst:93
msgid "cur = con.cursor()"
msgstr ""

#: ../../library/sqlite3.rst:97
msgid ""
"Now that we've got a database connection and a cursor, we can create a "
"database table ``movie`` with columns for title, release year, and review "
"score. For simplicity, we can just use column names in the table declaration "
"-- thanks to the `flexible typing`_ feature of SQLite, specifying the data "
"types is optional. Execute the ``CREATE TABLE`` statement by calling :meth:"
"`cur.execute(...) <Cursor.execute>`:"
msgstr ""
"さて、今やデータベース接続とカーソルを取得したので、タイトル(title)とリリース"
"年(year)と、レビュー・スコア(score)の列(columns)を持つデータベース・テーブル "
"``movie`` を作成できます。 簡単にするために、テーブル宣言では列名だけを使用で"
"きます。SQLite の 柔軟な型付け(`flexible typing`_)機能のおかげで、データ型の"
"指定はオプションになっています。 :meth:`cur.execute(...) <Cursor.execute>` を"
"呼び出して ``CREATE TABLE`` 文を実行してください:"

#: ../../library/sqlite3.rst:106
msgid "cur.execute(\"CREATE TABLE movie(title, year, score)\")"
msgstr ""

#: ../../library/sqlite3.rst:113
msgid ""
"We can verify that the new table has been created by querying the "
"``sqlite_master`` table built-in to SQLite, which should now contain an "
"entry for the ``movie`` table definition (see `The Schema Table`_ for "
"details). Execute that query by calling :meth:`cur.execute(...) <Cursor."
"execute>`, assign the result to ``res``, and call :meth:`res.fetchone() "
"<Cursor.fetchone>` to fetch the resulting row:"
msgstr ""
"SQLite に組み込みの ``sqlite_master`` テーブルに対してクエリを実行すること"
"で、新しいテーブルが作成されたことを確認できます。このテーブルには、 "
"``movie`` テーブル定義のエントリが含まれているはずです(詳細は `The Schema "
"Table`_ 参照)。 :meth:`cur.execute(...) <Cursor.execute>` を呼び出してクエリ"
"を実行して、その結果を ``res`` に代入し、結果の行(row)を取得するために :meth:"
"`res.fetchone() <Cursor.fetchone>` を呼び出します:"

#: ../../library/sqlite3.rst:121
msgid ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master\")\n"
">>> res.fetchone()\n"
"('movie',)"
msgstr ""

#: ../../library/sqlite3.rst:127
msgid ""
"We can see that the table has been created, as the query returns a :class:"
"`tuple` containing the table's name. If we query ``sqlite_master`` for a non-"
"existent table ``spam``, :meth:`!res.fetchone` will return ``None``:"
msgstr ""

#: ../../library/sqlite3.rst:132
msgid ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master WHERE name='spam'\")\n"
">>> res.fetchone() is None\n"
"True"
msgstr ""

#: ../../library/sqlite3.rst:138
msgid ""
"Now, add two rows of data supplied as SQL literals by executing an "
"``INSERT`` statement, once again by calling :meth:`cur.execute(...) <Cursor."
"execute>`:"
msgstr ""
"ここで、 INSERT 文を実行して SQL のリテラルとして提供された 2 行のデータを追"
"加し、 再度 :meth:`cur.execute(...) <Cursor.execute>` を呼び出して追加します:"

#: ../../library/sqlite3.rst:142
msgid ""
"cur.execute(\"\"\"\n"
"    INSERT INTO movie VALUES\n"
"        ('Monty Python and the Holy Grail', 1975, 8.2),\n"
"        ('And Now for Something Completely Different', 1971, 7.5)\n"
"\"\"\")"
msgstr ""

#: ../../library/sqlite3.rst:150
msgid ""
"The ``INSERT`` statement implicitly opens a transaction, which needs to be "
"committed before changes are saved in the database (see :ref:`sqlite3-"
"controlling-transactions` for details). Call :meth:`con.commit() <Connection."
"commit>` on the connection object to commit the transaction:"
msgstr ""
"``INSERT`` 文は、変更がデータベースに保存される前にコミットする必要がある、ト"
"ランザクションを暗黙的に開きます(詳細は、 :ref:`sqlite3-controlling-"
"transactions` 参照)。 トランザクションをコミットするために接続オブジェクト"
"(connection object)の :meth:`con.commit() <Connection.commit>` を呼び出して下"
"さい:"

#: ../../library/sqlite3.rst:156
msgid "con.commit()"
msgstr ""

#: ../../library/sqlite3.rst:160
msgid ""
"We can verify that the data was inserted correctly by executing a ``SELECT`` "
"query. Use the now-familiar :meth:`cur.execute(...) <Cursor.execute>` to "
"assign the result to ``res``, and call :meth:`res.fetchall() <Cursor."
"fetchall>` to return all resulting rows:"
msgstr ""
"``SELECT`` クエリを実行することで、データが正しく挿入されたことを確認できま"
"す。 結果のすべての行を返すには、おなじみの :meth:`cur.execute(...) <Cursor."
"execute>` を使用して結果を ``res`` に代入し、 :meth:`res.fetchall() <Cursor."
"fetchall>` を呼び出して下さい:"

#: ../../library/sqlite3.rst:166
msgid ""
">>> res = cur.execute(\"SELECT score FROM movie\")\n"
">>> res.fetchall()\n"
"[(8.2,), (7.5,)]"
msgstr ""

#: ../../library/sqlite3.rst:172
msgid ""
"The result is a :class:`list` of two :class:`!tuple`\\s, one per row, each "
"containing that row's ``score`` value."
msgstr ""
"結果は、2 つの :class:`タプル <!tuple>` の :class:`リスト <list>` で、 それぞ"
"れのタプルにその行の ``score`` 値が含まれています。"

#: ../../library/sqlite3.rst:175
msgid ""
"Now, insert three more rows by calling :meth:`cur.executemany(...) <Cursor."
"executemany>`:"
msgstr ""
"ここで、 :meth:`cur.executemany(...) <Cursor.executemany>` を呼び出して、さら"
"に 3 行挿入します:"

#: ../../library/sqlite3.rst:178
msgid ""
"data = [\n"
"    (\"Monty Python Live at the Hollywood Bowl\", 1982, 7.9),\n"
"    (\"Monty Python's The Meaning of Life\", 1983, 7.5),\n"
"    (\"Monty Python's Life of Brian\", 1979, 8.0),\n"
"]\n"
"cur.executemany(\"INSERT INTO movie VALUES(?, ?, ?)\", data)\n"
"con.commit()  # Remember to commit the transaction after executing INSERT."
msgstr ""

#: ../../library/sqlite3.rst:188
msgid ""
"Notice that ``?`` placeholders are used to bind ``data`` to the query. "
"Always use placeholders instead of :ref:`string formatting <tut-formatting>` "
"to bind Python values to SQL statements, to avoid `SQL injection attacks`_ "
"(see :ref:`sqlite3-placeholders` for more details)."
msgstr ""
"``data`` をクエリに結び付け(bind)するために ``?`` プレースホルダが使用されて"
"いることに注意してください。 SQL インジェクション攻撃(`SQL injection "
"attacks`_)を避けるために、Python の値を SQL 文に結び付けするには、常に :ref:`"
"文字列フォーマット <tut-formatting>` の代わりにプレースホルダを使用してくださ"
"い(詳細は :ref:`sqlite3-placeholders` 参照)。"

#: ../../library/sqlite3.rst:194
msgid ""
"We can verify that the new rows were inserted by executing a ``SELECT`` "
"query, this time iterating over the results of the query:"
msgstr ""
"``SELECT`` クエリを実行することで、新しい行が挿入されたことを確認できます。今"
"回は、クエリの結果を反復処理します:"

#: ../../library/sqlite3.rst:198
msgid ""
">>> for row in cur.execute(\"SELECT year, title FROM movie ORDER BY "
"year\"):\n"
"...     print(row)\n"
"(1971, 'And Now for Something Completely Different')\n"
"(1975, 'Monty Python and the Holy Grail')\n"
"(1979, \"Monty Python's Life of Brian\")\n"
"(1982, 'Monty Python Live at the Hollywood Bowl')\n"
"(1983, \"Monty Python's The Meaning of Life\")"
msgstr ""

#: ../../library/sqlite3.rst:208
msgid ""
"Each row is a two-item :class:`tuple` of ``(year, title)``, matching the "
"columns selected in the query."
msgstr ""
"各行(row)は :class:`タプル <tuple>` の ``(year, title)`` の 2 つの項目であ"
"り、クエリで選択された列(columns)にマッチします。"

#: ../../library/sqlite3.rst:211
msgid ""
"Finally, verify that the database has been written to disk by calling :meth:"
"`con.close() <Connection.close>` to close the existing connection, opening a "
"new one, creating a new cursor, then querying the database:"
msgstr ""
"最後に、 :meth:`con.close() <Connection.close>` を呼び出して既存の接続"
"(connection)を閉じ、新しい接続を開き、新しいカーソルを作成してから、データ"
"ベースに対してクエリを実行して、データベースがディスクに書き込まれたことを確"
"認します:"

#: ../../library/sqlite3.rst:216
msgid ""
">>> con.close()\n"
">>> new_con = sqlite3.connect(\"tutorial.db\")\n"
">>> new_cur = new_con.cursor()\n"
">>> res = new_cur.execute(\"SELECT title, year FROM movie ORDER BY score "
"DESC\")\n"
">>> title, year = res.fetchone()\n"
">>> print(f'The highest scoring Monty Python movie is {title!r}, released in "
"{year}')\n"
"The highest scoring Monty Python movie is 'Monty Python and the Holy Grail', "
"released in 1975\n"
">>> new_con.close()"
msgstr ""

#: ../../library/sqlite3.rst:227
msgid ""
"You've now created an SQLite database using the :mod:`!sqlite3` module, "
"inserted data and retrieved values from it in multiple ways."
msgstr ""
"これで、あなたは、 :mod:`!sqlite3` モジュールを使用して SQLite データベースを"
"作成し、複数の方法でデータを挿入し、そこから値を取得することができるようにな"
"りました。"

#: ../../library/sqlite3.rst:239
msgid ":ref:`sqlite3-howtos` for further reading:"
msgstr ":ref:`sqlite3-howtos` も参考にしてください:"

#: ../../library/sqlite3.rst:241
msgid ":ref:`sqlite3-placeholders`"
msgstr ":ref:`sqlite3-placeholders`"

#: ../../library/sqlite3.rst:242
msgid ":ref:`sqlite3-adapters`"
msgstr ":ref:`sqlite3-adapters`"

#: ../../library/sqlite3.rst:243
msgid ":ref:`sqlite3-converters`"
msgstr ":ref:`sqlite3-converters`"

#: ../../library/sqlite3.rst:244 ../../library/sqlite3.rst:615
msgid ":ref:`sqlite3-connection-context-manager`"
msgstr ":ref:`sqlite3-connection-context-manager`"

#: ../../library/sqlite3.rst:245
msgid ":ref:`sqlite3-howto-row-factory`"
msgstr ":ref:`sqlite3-howto-row-factory`"

#: ../../library/sqlite3.rst:247
msgid ""
":ref:`sqlite3-explanation` for in-depth background on transaction control."
msgstr ""
":ref:`トランザクション制御 <sqlite3-explanation>` トランザクション制御の背景"
"についてより深く掘り下げた説明。"

#: ../../library/sqlite3.rst:252
msgid "Reference"
msgstr "リファレンス"

#: ../../library/sqlite3.rst:260
msgid "Module functions"
msgstr "モジュール関数"

#: ../../library/sqlite3.rst:268
msgid "Open a connection to an SQLite database."
msgstr "SQLite データベースとの接続(connection)を開きます。"

#: ../../library/sqlite3.rst:0
msgid "Parameters"
msgstr "パラメーター"

#: ../../library/sqlite3.rst:270
msgid ""
"The path to the database file to be opened. You can pass ``\":memory:\"`` to "
"create an `SQLite database existing only in memory <https://sqlite.org/"
"inmemorydb.html>`_, and open a connection to it."
msgstr ""

#: ../../library/sqlite3.rst:277
msgid ""
"How many seconds the connection should wait before raising an :exc:"
"`OperationalError` when a table is locked. If another connection opens a "
"transaction to modify a table, that table will be locked until the "
"transaction is committed. Default five seconds."
msgstr ""
"テーブルがロックされている場合、 :exc:`OperationalError` を送出する前に接続を"
"待機する秒数。 別の接続がテーブルを変更するためにトランザクションを開くと、そ"
"のテーブルはトランザクションがコミットされるまでロックされます。 デフォルト"
"は 5 秒です。"

#: ../../library/sqlite3.rst:284
msgid ""
"Control whether and how data types not :ref:`natively supported by SQLite "
"<sqlite3-types>` are looked up to be converted to Python types, using the "
"converters registered with :func:`register_converter`. Set it to any "
"combination (using ``|``, bitwise or) of :const:`PARSE_DECLTYPES` and :const:"
"`PARSE_COLNAMES` to enable this. Column names takes precedence over declared "
"types if both flags are set. Types cannot be detected for generated fields "
"(for example ``max(data)``), even when the *detect_types* parameter is set; :"
"class:`str` will be returned instead. By default (``0``), type detection is "
"disabled."
msgstr ""
":func:`register_converter` で登録された変換関数を使用して、 :ref:`SQLite でネ"
"イティブにサポートされている型 <sqlite3-types>` 以外のデータ型を検出して、 "
"Python 型に変換するかどうか、そして、その変換方法を制御します。 これは、 :"
"const:`PARSE_DECLTYPES` と :const:`PARSE_COLNAMES` を(ビット論理和 ``|`` を使"
"用して)任意の組み合わせで設定することで有効になります。 両方のフラグが設定さ"
"れている場合、宣言された型よりも列名が優先されます。 *detect_types* パラメー"
"タが設定されている場合でも、 生成されたフィールド(たとえば ``max(data)``)の型"
"は検出できず、代わりに :class:`str` が返されます。デフォルト (``0``) では、"
"データ型検出は無効になっています。"

#: ../../library/sqlite3.rst:298
msgid ""
"Control legacy transaction handling behaviour. See :attr:`Connection."
"isolation_level` and :ref:`sqlite3-transaction-control-isolation-level` for "
"more information. Can be ``\"DEFERRED\"`` (default), ``\"EXCLUSIVE\"`` or "
"``\"IMMEDIATE\"``; or ``None`` to disable opening transactions implicitly. "
"Has no effect unless :attr:`Connection.autocommit` is set to :const:"
"`~sqlite3.LEGACY_TRANSACTION_CONTROL` (the default)."
msgstr ""

#: ../../library/sqlite3.rst:308
msgid ""
"If ``True`` (default), :exc:`ProgrammingError` will be raised if the "
"database connection is used by a thread other than the one that created it. "
"If ``False``, the connection may be accessed in multiple threads; write "
"operations may need to be serialized by the user to avoid data corruption. "
"See :attr:`threadsafety` for more information."
msgstr ""
"``True`` (これがデフォルトです)なら、データベース接続を作成したスレッド以外の"
"スレッドがデータベース接続を使用すると、 :exc:`ProgrammingError` が送出されま"
"す。 ``False`` なら、接続は複数のスレッドからアクセスできます。ただし、データ"
"の破損を避けるために、ユーザーによる書き込み操作の直列化が必要になることがあ"
"ります。詳細は :attr:`threadsafety`  を参照してください。"

#: ../../library/sqlite3.rst:317
msgid ""
"A custom subclass of :class:`Connection` to create the connection with, if "
"not the default :class:`Connection` class."
msgstr ""
"デフォルトの :class:`Connection` クラスでない場合に接続(connection)を作成す"
"る :class:`Connection` のカスタム・サブクラスです。"

#: ../../library/sqlite3.rst:321
msgid ""
"The number of statements that :mod:`!sqlite3` should internally cache for "
"this connection, to avoid parsing overhead. By default, 128 statements."
msgstr ""
":mod:`!sqlite3` がこの接続(connection)のために内部的にキャッシュするSQL文"
"(statements)の数で、 パース時のオーバーヘッドを回避します。 デフォルトでは、"
"128 文(statements)です。"

#: ../../library/sqlite3.rst:326
msgid ""
"If set to ``True``, *database* is interpreted as a :abbr:`URI (Uniform "
"Resource Identifier)` with a file path and an optional query string. The "
"scheme part *must* be ``\"file:\"``, and the path can be relative or "
"absolute. The query string allows passing parameters to SQLite, enabling "
"various :ref:`sqlite3-uri-tricks`."
msgstr ""
"``True`` に設定すると、 *database* は、ファイル・パス(path)とオプションのクエ"
"リ文字列を含む :abbr:`URI (Uniform Resource Identifier)` として解釈されま"
"す。 スキームの部分は ``\"file:\"`` でなければならず、パス(path)は相対パスま"
"たは絶対パスにすることができます。 クエリ文字列により、 パラメーターを "
"SQLite に渡すことができ、さまざまな :ref:`sqlite3-uri-tricks` が有効になりま"
"す。"

#: ../../library/sqlite3.rst:335
msgid ""
"Control :pep:`249` transaction handling behaviour. See :attr:`Connection."
"autocommit` and :ref:`sqlite3-transaction-control-autocommit` for more "
"information. *autocommit* currently defaults to :const:`~sqlite3."
"LEGACY_TRANSACTION_CONTROL`. The default will change to ``False`` in a "
"future Python release."
msgstr ""

#: ../../library/sqlite3.rst:0
msgid "Return type"
msgstr "戻り値型"

#: ../../library/sqlite3.rst:346
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument "
"``database``."
msgstr ""
"引数 ``database`` を指定して :ref:`監査イベント <auditing>` ``sqlite3."
"connect`` を送出します。 "

#: ../../library/sqlite3.rst:347
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` with "
"argument ``connection_handle``."
msgstr ""
"引数 ``connection_handle`` を指定して :ref:`監査イベント <auditing>` "
"``sqlite3.connect/handle`` を送出します。 "

#: ../../library/sqlite3.rst:349
msgid "Added the *uri* parameter."
msgstr "``uri`` パラメータが追加されました。"

#: ../../library/sqlite3.rst:352
msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr ""
"*database* は、文字列だけでなく、 :term:`path-like object` にすることもできる"
"ようになりました。"

#: ../../library/sqlite3.rst:355
msgid "Added the ``sqlite3.connect/handle`` auditing event."
msgstr ""

#: ../../library/sqlite3.rst:358
msgid "Added the *autocommit* parameter."
msgstr ""

#: ../../library/sqlite3.rst:361
msgid ""
"Positional use of the parameters *timeout*, *detect_types*, "
"*isolation_level*, *check_same_thread*, *factory*, *cached_statements*, and "
"*uri* is deprecated. They will become keyword-only parameters in Python 3.15."
msgstr ""

#: ../../library/sqlite3.rst:369
msgid ""
"Return ``True`` if the string *statement* appears to contain one or more "
"complete SQL statements. No syntactic verification or parsing of any kind is "
"performed, other than checking that there are no unclosed string literals "
"and the statement is terminated by a semicolon."
msgstr ""
"文字列 *statement* が 1 つ以上の完全な SQL 文を含んでいるように見える場合、 "
"``True`` を返します。 閉じられていない文字列リテラルがないことと、文がセミコ"
"ロンで終了していることを確認する以外の、構文の検証やパースは行われません。"

#: ../../library/sqlite3.rst:375
msgid "For example:"
msgstr "例えば:"

#: ../../library/sqlite3.rst:377
msgid ""
">>> sqlite3.complete_statement(\"SELECT foo FROM bar;\")\n"
"True\n"
">>> sqlite3.complete_statement(\"SELECT foo\")\n"
"False"
msgstr ""

#: ../../library/sqlite3.rst:384
msgid ""
"This function may be useful during command-line input to determine if the "
"entered text seems to form a complete SQL statement, or if additional input "
"is needed before calling :meth:`~Cursor.execute`."
msgstr ""
"この関数は、コマンドライン入力時に便利で、入力されたテキストが完全な SQL 文を"
"形成しているように見えるかどうか、または :meth:`~Cursor.execute` を呼び出す前"
"に追加の入力が必要かどうかを判断するのに使えます。"

#: ../../library/sqlite3.rst:388
msgid ""
"See :func:`!runsource` in :source:`Lib/sqlite3/__main__.py` for real-world "
"use."
msgstr ""
"実際の使用例については、 :source:`Lib/sqlite3/__main__.py` の :func:`!"
"runsource` を参照してください。"

#: ../../library/sqlite3.rst:393
msgid ""
"Enable or disable callback tracebacks. By default you will not get any "
"tracebacks in user-defined functions, aggregates, converters, authorizer "
"callbacks etc. If you want to debug them, you can call this function with "
"*flag* set to ``True``. Afterwards, you will get tracebacks from callbacks "
"on :data:`sys.stderr`. Use ``False`` to disable the feature again."
msgstr ""
"コールバックのトレースバックを有効または無効にします。  デフォルトでは、ユー"
"ザー定義関数や集計関数や変換関数や authorizer コールバックなどではトレース"
"バックを取得しません。それらをデバッグしたい場合は、 *flag* を ``True`` に設"
"定してこの関数を呼び出し。その後、 :data:`sys.stderr` のコールバックからト"
"レースバックを取得します。 機能を再び無効にするには ``False`` を使用します。"

#: ../../library/sqlite3.rst:402
msgid ""
"Errors in user-defined function callbacks are logged as unraisable "
"exceptions. Use an :func:`unraisable hook handler <sys.unraisablehook>` for "
"introspection of the failed callback."
msgstr ""

#: ../../library/sqlite3.rst:408
msgid ""
"Register an *adapter* :term:`callable` to adapt the Python type *type* into "
"an SQLite type. The adapter is called with a Python object of type *type* as "
"its sole argument, and must return a value of a :ref:`type that SQLite "
"natively understands <sqlite3-types>`."
msgstr ""
"*adapter* :term:`呼び出し可能オブジェクト <callable>` を登録して、 Python 型"
"の *type* を SQLite の型に適合させます。適合関数(adapter)アダプターは、 "
"Python 型 *type* の Python オブジェクトを唯一の引数として使用して呼び出さ"
"れ、 :ref:`SQLite がネイティブに理解する型 <sqlite3-types>` の値を返す必要が"
"あります。"

#: ../../library/sqlite3.rst:416
msgid ""
"Register the *converter* :term:`callable` to convert SQLite objects of type "
"*typename* into a Python object of a specific type. The converter is invoked "
"for all SQLite values of type *typename*; it is passed a :class:`bytes` "
"object and should return an object of the desired Python type. Consult the "
"parameter *detect_types* of :func:`connect` for information regarding how "
"type detection works."
msgstr ""
"*converter* :term:`呼び出し可能オブジェクト <callable>` を登録して、 "
"*typename* 型の SQLite オブジェクトを指定の型の Python オブジェクトに変換しま"
"す。変換関数(converter)、 *typename* 型のすべての SQLite 値に対して呼び出され"
"ます。 変換関数には :class:`bytes` オブジェクトが渡され、目的の Python 型のオ"
"ブジェクトを返す必要があります。型検出の仕組みについては、 :func:`connect` の"
"パラメーター *detect_types* を参照してください。"

#: ../../library/sqlite3.rst:424
msgid ""
"Note: *typename* and the name of the type in your query are matched case-"
"insensitively."
msgstr ""
"注釈: *typename* とクエリ内の型の名前は、大文字小文字を区別せずにマッチングさ"
"れます。"

#: ../../library/sqlite3.rst:431
msgid "Module constants"
msgstr "モジュール定数"

#: ../../library/sqlite3.rst:435
msgid ""
"Set :attr:`~Connection.autocommit` to this constant to select old style (pre-"
"Python 3.12) transaction control behaviour. See :ref:`sqlite3-transaction-"
"control-isolation-level` for more information."
msgstr ""
"古いスタイル (Python 3.12 より前) のトランザクション制御の振る舞いを選択する"
"には、 :attr:`~Connection.autocommit` に、この定数を設定します。詳細について"
"は :ref:`sqlite3-transaction-control-isolation-level` を参照してください。"

#: ../../library/sqlite3.rst:441
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function by using the type name, parsed from the query "
"column name, as the converter dictionary key. The type name must be wrapped "
"in square brackets (``[]``)."
msgstr ""
"このフラグ値を :func:`connect` の *detect_types* パラメーターに渡し、クエリの"
"列(column)名からパースされた型名を変換関数辞書(converter dictionary)のキーと"
"して使用して変換関数を探します。型名は角括弧(``[]``)で囲む必要があります。"

#: ../../library/sqlite3.rst:447
msgid ""
"SELECT p as \"p [point]\" FROM test;  ! will look up converter \"point\""
msgstr ""

#: ../../library/sqlite3.rst:451
msgid ""
"This flag may be combined with :const:`PARSE_DECLTYPES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"このフラグは ``|`` (ビット論理和)演算子を使用して :const:`PARSE_DECLTYPES` と"
"組み合わせることができます。"

#: ../../library/sqlite3.rst:456
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function using the declared types for each column. The "
"types are declared when the database table is created. :mod:`!sqlite3` will "
"look up a converter function using the first word of the declared type as "
"the converter dictionary key. For example:"
msgstr ""
"このフラグ値を :func:`connect` の *detect_types* パラメーターに渡して、各列"
"(column)で宣言した型を使用して変換関数を探します。型は、データベース・テーブ"
"ルの作成時に宣言します。 :mod:`!sqlite3` は、宣言された型の、最初の単語を、変"
"換関数辞書(converter dictionary)のキーとして使用して、変換関数を探します。例"
"えば:"

#: ../../library/sqlite3.rst:464
msgid ""
"CREATE TABLE test(\n"
"   i integer primary key,  ! will look up a converter named \"integer\"\n"
"   p point,                ! will look up a converter named \"point\"\n"
"   n number(10)            ! will look up a converter named \"number\"\n"
" )"
msgstr ""

#: ../../library/sqlite3.rst:472
msgid ""
"This flag may be combined with :const:`PARSE_COLNAMES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"このフラグは ``|`` (ビット論理和)演算子を使用して :const:`PARSE_COLNAMES` と"
"組み合わせることができます。"

#: ../../library/sqlite3.rst:479
msgid ""
"Flags that should be returned by the *authorizer_callback* :term:`callable` "
"passed to :meth:`Connection.set_authorizer`, to indicate whether:"
msgstr ""
":meth:`Connection.set_authorizer` に渡す :term:`呼び出し可能オブジェクト "
"<callable>` が返す必要のあるフラグ。これらは以下の意味です:"

#: ../../library/sqlite3.rst:482
msgid "Access is allowed (:const:`!SQLITE_OK`),"
msgstr "アクセスは許可されました(:const:`!SQLITE_OK`)"

#: ../../library/sqlite3.rst:483
msgid ""
"The SQL statement should be aborted with an error (:const:`!SQLITE_DENY`)"
msgstr ""
"当該SQL文全体の実行をエラーで中止(abort)する必要があります(:const:`!"
"SQLITE_DENY`)"

#: ../../library/sqlite3.rst:484
msgid ""
"The column should be treated as a ``NULL`` value (:const:`!SQLITE_IGNORE`)"
msgstr ""
"列(column)は ``NULL`` 値として扱う必要がありますが、当該SQL文の実行は続行する"
"必要があります(:const:`!SQLITE_IGNORE`)"

#: ../../library/sqlite3.rst:488
msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr ""
"サポートされている DB-API レベルを示す文字列定数。 DB-API で必要です。 "
"``\"2.0\"`` とハードコーディングされています。"

#: ../../library/sqlite3.rst:493
msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`!sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr ""
":mod:`!sqlite3` モジュールが期待するパラメータ・マーカーのフォーマットの種類"
"をあらわす文字列定数です。 DB-API で必要です。 ``\"qmark\"`` とハードコーディ"
"ングされています。"

#: ../../library/sqlite3.rst:499
msgid "The ``named`` DB-API parameter style is also supported."
msgstr "``named`` DB-API パラメータ・スタイルもサポートされています。"

#: ../../library/sqlite3.rst:503
msgid ""
"Version number of the runtime SQLite library as a :class:`string <str>`."
msgstr ""
":class:`文字列 <str>` としての、ランタイム SQLite ライブラリのバージョン番"
"号。"

#: ../../library/sqlite3.rst:507
msgid ""
"Version number of the runtime SQLite library as a :class:`tuple` of :class:"
"`integers <int>`."
msgstr ""
":class:`整数 <int>` の :class:`タプル <tuple>` としての、ランタイム SQLite ラ"
"イブラリのバージョン番号。"

#: ../../library/sqlite3.rst:512
msgid ""
"Integer constant required by the DB-API 2.0, stating the level of thread "
"safety the :mod:`!sqlite3` module supports. This attribute is set based on "
"the default `threading mode <https://sqlite.org/threadsafe.html>`_ the "
"underlying SQLite library is compiled with. The SQLite threading modes are:"
msgstr ""
":mod:`!sqlite3` モジュールがサポートするスレッドセーフのレベルを示す、DB-API "
"2.0 で必要な整数定数。 この属性は、背後の SQLite ライブラリのコンパイル時のデ"
"フォルトの SQLite スレッド・モード (`threading mode <https://sqlite.org/"
"threadsafe.html>`_)に基づいて設定されます。 SQLite のスレッド・モードは以下の"
"とおりです:"

#: ../../library/sqlite3.rst:517
msgid ""
"**Single-thread**: In this mode, all mutexes are disabled and SQLite is "
"unsafe to use in more than a single thread at once."
msgstr ""
"**シングル・スレッド**: このモードでは、すべてのミューテックスが無効になり、"
"一度に複数のスレッドで SQLite を使用するのは安全ではありません。"

#: ../../library/sqlite3.rst:519
msgid ""
"**Multi-thread**: In this mode, SQLite can be safely used by multiple "
"threads provided that no single database connection is used simultaneously "
"in two or more threads."
msgstr ""
"**マルチ・スレッド**: このモードでは、 1 つのデータベース接続が 2 つ以上のス"
"レッドで同時に使用されない限り、複数のスレッドで SQLite を安全に使用できま"
"す。"

#: ../../library/sqlite3.rst:522
msgid ""
"**Serialized**: In serialized mode, SQLite can be safely used by multiple "
"threads with no restriction."
msgstr ""
"**直列化**: 直列化(serialized)モードでは、 SQLite を複数のスレッドで制限なく"
"安全に使用できます。"

#: ../../library/sqlite3.rst:525
msgid ""
"The mappings from SQLite threading modes to DB-API 2.0 threadsafety levels "
"are as follows:"
msgstr ""
"SQLite スレッド・モードと、 DB-API 2.0 のスレッドセーフ・レベルとの対応は以下"
"のとおりです:"

#: ../../library/sqlite3.rst:529
msgid "SQLite threading mode"
msgstr "SQLite スレッド・モード"

#: ../../library/sqlite3.rst:529
msgid ":pep:`threadsafety <0249#threadsafety>`"
msgstr ""

#: ../../library/sqlite3.rst:529
msgid "`SQLITE_THREADSAFE`_"
msgstr "`SQLITE_THREADSAFE`_"

#: ../../library/sqlite3.rst:529
msgid "DB-API 2.0 meaning"
msgstr "DB-API 2.0 での意味"

#: ../../library/sqlite3.rst:532
msgid "single-thread"
msgstr "シングル・スレッド"

#: ../../library/sqlite3.rst:532
msgid "0"
msgstr "0"

#: ../../library/sqlite3.rst:532
msgid "Threads may not share the module"
msgstr "スレッドはモジュールを共有できません"

#: ../../library/sqlite3.rst:535
msgid "multi-thread"
msgstr "マルチ・スレッド"

#: ../../library/sqlite3.rst:535 ../../library/sqlite3.rst:538
msgid "1"
msgstr "1"

#: ../../library/sqlite3.rst:535
msgid "2"
msgstr "2"

#: ../../library/sqlite3.rst:535
msgid "Threads may share the module, but not connections"
msgstr "スレッドはモジュールを共有できますが、接続は共有できません"

#: ../../library/sqlite3.rst:538
msgid "serialized"
msgstr "直列化"

#: ../../library/sqlite3.rst:538
msgid "3"
msgstr "3"

#: ../../library/sqlite3.rst:538
msgid "Threads may share the module, connections and cursors"
msgstr "スレッドは、モジュールや接続やカーソルを共有できます"

#: ../../library/sqlite3.rst:544
msgid "Set *threadsafety* dynamically instead of hard-coding it to ``1``."
msgstr ""
"``1`` とハード・コーディングする代わりに *threadsafety* を動的に設定します。"

#: ../../library/sqlite3.rst:549
msgid ""
"Version number of this module as a :class:`string <str>`. This is not the "
"version of the SQLite library."
msgstr ""
":class:`文字列 <str>` としての、このモジュールのバージョン番号。これは "
"SQLite ライブラリのバージョン番号ではありません。"

#: ../../library/sqlite3.rst:552 ../../library/sqlite3.rst:562
msgid ""
"This constant used to reflect the version number of the ``pysqlite`` "
"package, a third-party library which used to upstream changes to :mod:`!"
"sqlite3`. Today, it carries no meaning or practical value."
msgstr ""
"この定数は、 :mod:`!sqlite3` へのアップストリーム変更に使用されていたサード"
"パーティ・ライブラリである、 ``pysqlite`` パッケージのバージョン番号を反映し"
"ていました。今やこれには何の意味も無いし実用的な価値もありません。"

#: ../../library/sqlite3.rst:559
msgid ""
"Version number of this module as a :class:`tuple` of :class:`integers "
"<int>`. This is not the version of the SQLite library."
msgstr ""
":class:`整数 <int>` の :class:`タプル <tuple>` としての、このモジュールのバー"
"ジョン番号。これは SQLite ライブラリのバージョン番号ではありません。"

#: ../../library/sqlite3.rst:586
msgid ""
"These constants are used for the :meth:`Connection.setconfig` and :meth:"
"`~Connection.getconfig` methods."
msgstr ""
"これらの定数は、 :meth:`Connection.setconfig` メソッド や :meth:`~Connection."
"getconfig` メソッドで使用されます。"

#: ../../library/sqlite3.rst:589
msgid ""
"The availability of these constants varies depending on the version of "
"SQLite Python was compiled with."
msgstr ""
"これらの定数が利用できるかどうかは、 Python にコンパイルされた SQLite のバー"
"ジョンによって異なります。"

#: ../../library/sqlite3.rst:596
msgid "https://www.sqlite.org/c3ref/c_dbconfig_defensive.html"
msgstr ""

#: ../../library/sqlite3.rst:597
msgid "SQLite docs: Database Connection Configuration Options"
msgstr ""

#: ../../library/sqlite3.rst:603
msgid "Connection objects"
msgstr "Connection オブジェクト"

#: ../../library/sqlite3.rst:607
msgid ""
"Each open SQLite database is represented by a ``Connection`` object, which "
"is created using :func:`sqlite3.connect`. Their main purpose is creating :"
"class:`Cursor` objects, and :ref:`sqlite3-controlling-transactions`."
msgstr ""
"開いた SQLite データベースの各々は、 :func:`sqlite3.connect` を使用して作成さ"
"れる ``Connection`` オブジェクトによって表されます。``Connection`` オブジェク"
"トの主な目的は :class:`Cursor` オブジェクトの作成と :ref:`sqlite3-"
"controlling-transactions` です。"

#: ../../library/sqlite3.rst:614
msgid ":ref:`sqlite3-connection-shortcuts`"
msgstr ":ref:`sqlite3-connection-shortcuts`"

#: ../../library/sqlite3.rst:620
msgid ""
"A :exc:`ResourceWarning` is emitted if :meth:`close` is not called before a :"
"class:`!Connection` object is deleted."
msgstr ""

#: ../../library/sqlite3.rst:623
msgid "An SQLite database connection has the following attributes and methods:"
msgstr ""
"SQLite データベース接続(connection)には、以下の属性とメソッドがあります:"

#: ../../library/sqlite3.rst:627
msgid ""
"Create and return a :class:`Cursor` object. The cursor method accepts a "
"single optional parameter *factory*. If supplied, this must be a :term:"
"`callable` returning an instance of :class:`Cursor` or its subclasses."
msgstr ""
":class:`Cursor` オブジェクトを作成して返します。 cursor メソッドは、単一のオ"
"プション・パラメーター *factory* を受け入れます。 *factory* を指定する場合、"
"これは :class:`Cursor` またはそのサブクラスのインスタンスを返す :term:`呼び出"
"し可能オブジェクト <callable>` である必要があります。"

#: ../../library/sqlite3.rst:634
msgid ""
"Open a :class:`Blob` handle to an existing :abbr:`BLOB (Binary Large "
"OBject)`."
msgstr ""
"既存の :abbr:`BLOB (Binary Large OBject)` への :class:`Blob` ハンドルを開きま"
"す。"

#: ../../library/sqlite3.rst:637
msgid "The name of the table where the blob is located."
msgstr "当該 BLOB が配置されているテーブルの名前。"

#: ../../library/sqlite3.rst:640
msgid "The name of the column where the blob is located."
msgstr "当該 BLOB が配置されている列(column)の名前。"

#: ../../library/sqlite3.rst:643
msgid "The name of the row where the blob is located."
msgstr "当該 BLOB が配置されている行(row)の名前。"

#: ../../library/sqlite3.rst:646
msgid ""
"Set to ``True`` if the blob should be opened without write permissions. "
"Defaults to ``False``."
msgstr ""
"書き込み権限なしで BLOB を開く必要がある場合は、 ``True`` に設定します。 デ"
"フォルトは ``False`` です。"

#: ../../library/sqlite3.rst:651
msgid ""
"The name of the database where the blob is located. Defaults to ``\"main\"``."
msgstr ""
"当該 BLOB が配置されているデータベース名。 デフォルトは ``\"main\"`` です。"

#: ../../library/sqlite3.rst:0
msgid "Raises"
msgstr ""

#: ../../library/sqlite3.rst:655
msgid "When trying to open a blob in a ``WITHOUT ROWID`` table."
msgstr "``WITHOUT ROWID`` テーブルで BLOB を開こうとしたとき。"

#: ../../library/sqlite3.rst:662
msgid ""
"The blob size cannot be changed using the :class:`Blob` class. Use the SQL "
"function ``zeroblob`` to create a blob with a fixed size."
msgstr ""
":class:`Blob` クラスを使用して BLOB のサイズを変更することはできません。 SQL "
"関数 ``zeroblob`` を使用すると、固定サイズのブロブを作成します。"

#: ../../library/sqlite3.rst:669
msgid ""
"Commit any pending transaction to the database. If :attr:`autocommit` is "
"``True``, or there is no open transaction, this method does nothing. If :"
"attr:`!autocommit` is ``False``, a new transaction is implicitly opened if a "
"pending transaction was committed by this method."
msgstr ""
"保留中のトランザクションをデータベースにコミットします。  :attr:`autocommit` "
"が ``True`` または開いているトランザクションがない場合、このメソッドは何も行"
"いません。 :attr:`!autocommit` が ``False`` の場合に保留中のトランザクション"
"がこのメソッドによってコミットされた場合、新しいトランザクションが暗黙に開か"
"れます。"

#: ../../library/sqlite3.rst:677
msgid ""
"Roll back to the start of any pending transaction. If :attr:`autocommit` is "
"``True``, or there is no open transaction, this method does nothing. If :"
"attr:`!autocommit` is ``False``, a new transaction is implicitly opened if a "
"pending transaction was rolled back by this method."
msgstr ""
"保留中のトランザクションの先頭にロールバックします。 :attr:`autocommit` が "
"``True`` または開いているトランザクションがない場合、このメソッドは何も行いま"
"せん。 :attr:`!autocommit` が ``False`` の場合に保留中のトランザクションがこ"
"のメソッドによってロールバックされた場合、新しいトランザクションが暗黙に開か"
"れます。"

#: ../../library/sqlite3.rst:685
msgid ""
"Close the database connection. If :attr:`autocommit` is ``False``, any "
"pending transaction is implicitly rolled back. If :attr:`!autocommit` is "
"``True`` or :data:`LEGACY_TRANSACTION_CONTROL`, no implicit transaction "
"control is executed. Make sure to :meth:`commit` before closing to avoid "
"losing pending changes."
msgstr ""
"データベース接続を閉じます。 :attr:`autocommit` が ``False`` の場合、保留中の"
"トランザクションは暗黙にロールバックされます。 :attr:`!autocommit` が "
"``True`` または :data:`LEGACY_TRANSACTION_CONTROL` の場合、暗黙のトランザク"
"ション制御は実行されませんので、保留中の変更が失われないように、データベース"
"接続を閉じる前に必ず :meth:`commit` を行ってください。"

#: ../../library/sqlite3.rst:695
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"新しい :class:`Cursor` オブジェクトを作成し、指定の *sql* と *parameters* "
"で :meth:`~Cursor.execute` を呼び出します。新しいカーソル・オブジェクトを返し"
"ます。"

#: ../../library/sqlite3.rst:701
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"新しい :class:`Cursor` オブジェクトを作成し、与えられた *sql* と "
"*parameters* で :meth:`~Cursor.executemany` を呼び出します。新しいカーソル・"
"オブジェクトを返します。"

#: ../../library/sqlite3.rst:707
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""
"新しい :class:`Cursor` オブジェクトを作成し、指定された *sql_script* で :"
"meth:`~Cursor.executescript` を呼び出します。新しいカーソル・オブジェクトを返"
"します。"

#: ../../library/sqlite3.rst:713
msgid "Create or remove a user-defined SQL function."
msgstr "ユーザ定義 SQL 関数を作成または削除します。"

#: ../../library/sqlite3.rst:715
msgid "The name of the SQL function."
msgstr "SQL 関数の名前。"

#: ../../library/sqlite3.rst:718
msgid ""
"The number of arguments the SQL function can accept. If ``-1``, it may take "
"any number of arguments."
msgstr ""
"SQL 関数が受け入れることができる引数の数。 ``-1`` を指定すると、任意の数の引"
"数を取ることができます。"

#: ../../library/sqlite3.rst:722
msgid ""
"A :term:`callable` that is called when the SQL function is invoked. The "
"callable must return :ref:`a type natively supported by SQLite <sqlite3-"
"types>`. Set to ``None`` to remove an existing SQL function."
msgstr ""
"この SQL 関数が呼び出されたときに起動される :term:`呼び出し可能オブジェクト "
"<callable>` 。 この呼び出し可能オブジェクトは、 :ref:`SQLite によってネイティ"
"ブにサポートされる型 <sqlite3-types>` を返すす必要があります。 既存の SQL 関"
"数を削除するには、 ``None`` に設定します。"

#: ../../library/sqlite3.rst:729
msgid ""
"If ``True``, the created SQL function is marked as `deterministic <https://"
"sqlite.org/deterministic.html>`_, which allows SQLite to perform additional "
"optimizations."
msgstr ""
"``True`` の場合、作成された SQL 関数は決定論的(`deterministic <https://"
"sqlite.org/deterministic.html>`_ : 入力が同一なら常に同一の答えを返す)として"
"マークされ、SQLite が追加の最適化を実行できるようになります。"

#: ../../library/sqlite3.rst:734
msgid "Added the *deterministic* parameter."
msgstr ""

#: ../../library/sqlite3.rst:737 ../../library/sqlite3.rst:781
#: ../../library/sqlite3.rst:849 ../../library/sqlite3.rst:1128
#: ../../library/sqlite3.rst:1550 ../../library/sqlite3.rst:1593
msgid "Example:"
msgstr "例:"

#: ../../library/sqlite3.rst:739
msgid ""
">>> import hashlib\n"
">>> def md5sum(t):\n"
"...     return hashlib.md5(t).hexdigest()\n"
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.create_function(\"md5\", 1, md5sum)\n"
">>> for row in con.execute(\"SELECT md5(?)\", (b\"foo\",)):\n"
"...     print(row)\n"
"('acbd18db4cc2f85cedef654fccc4a4d8',)\n"
">>> con.close()"
msgstr ""

#: ../../library/sqlite3.rst:753
msgid ""
"Passing *name*, *narg*, and *func* as keyword arguments is deprecated. These "
"parameters will become positional-only in Python 3.15."
msgstr ""

#: ../../library/sqlite3.rst:759
msgid "Create or remove a user-defined SQL aggregate function."
msgstr "ユーザ定義集計関数を作成または削除します。"

#: ../../library/sqlite3.rst:761
msgid "The name of the SQL aggregate function."
msgstr "SQL 集計関数の名前。"

#: ../../library/sqlite3.rst:764
msgid ""
"The number of arguments the SQL aggregate function can accept. If ``-1``, it "
"may take any number of arguments."
msgstr ""
"SQL 集計関数が受け入れることができる引数の数。 ``-1`` を指定すると、任意の数"
"の引数を取ることができます。"

#: ../../library/sqlite3.rst:768
msgid ""
"A class must implement the following methods:  * ``step()``: Add a row to "
"the aggregate. * ``finalize()``: Return the final result of the aggregate "
"as   :ref:`a type natively supported by SQLite <sqlite3-types>`.  The number "
"of arguments that the ``step()`` method must accept is controlled by "
"*n_arg*.  Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""

#: ../../library/sqlite3.rst:769
msgid "A class must implement the following methods:"
msgstr "クラスは以下のメソッドを実装する必要があります:"

#: ../../library/sqlite3.rst:771
msgid "``step()``: Add a row to the aggregate."
msgstr "``step()``: 集計に行(row)を足し込みます。"

#: ../../library/sqlite3.rst:772 ../../library/sqlite3.rst:833
msgid ""
"``finalize()``: Return the final result of the aggregate as :ref:`a type "
"natively supported by SQLite <sqlite3-types>`."
msgstr ""
"``finalize()``: 集計の最終結果を :ref:`SQLite でネイティブにサポートされてい"
"る型 <sqlite3-types>` として返します。"

#: ../../library/sqlite3.rst:775
msgid ""
"The number of arguments that the ``step()`` method must accept is controlled "
"by *n_arg*."
msgstr ""
"``step()`` メソッドが受け入れなければならない引数の数は *n_arg* によって制御"
"されます。"

#: ../../library/sqlite3.rst:778
msgid "Set to ``None`` to remove an existing SQL aggregate function."
msgstr "既存の SQL 集計関数を削除するには、 ``None`` に設定します。"

#: ../../library/sqlite3.rst:783
msgid ""
"class MySum:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        self.count += value\n"
"\n"
"    def finalize(self):\n"
"        return self.count\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_aggregate(\"mysum\", 1, MySum)\n"
"cur = con.execute(\"CREATE TABLE test(i)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(1)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(2)\")\n"
"cur.execute(\"SELECT mysum(i) FROM test\")\n"
"print(cur.fetchone()[0])\n"
"\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:812
msgid ""
"Passing *name*, *n_arg*, and *aggregate_class* as keyword arguments is "
"deprecated. These parameters will become positional-only in Python 3.15."
msgstr ""

#: ../../library/sqlite3.rst:818
msgid "Create or remove a user-defined aggregate window function."
msgstr "ユーザー定義の集計ウインドウ関数を作成または削除します。"

#: ../../library/sqlite3.rst:820
msgid "The name of the SQL aggregate window function to create or remove."
msgstr "作成または削除する SQL 集計ウインドウ関数の名前。"

#: ../../library/sqlite3.rst:823
msgid ""
"The number of arguments the SQL aggregate window function can accept. If "
"``-1``, it may take any number of arguments."
msgstr ""
"SQL 集計ウィンドウ関数が受け入れることができる引数の数。 ``-1`` を指定した場"
"合、任意の数の引数を取ることができます。"

#: ../../library/sqlite3.rst:827
msgid ""
"A class that must implement the following methods:  * ``step()``: Add a row "
"to the current window. * ``value()``: Return the current value of the "
"aggregate. * ``inverse()``: Remove a row from the current window. * "
"``finalize()``: Return the final result of the aggregate as   :ref:`a type "
"natively supported by SQLite <sqlite3-types>`.  The number of arguments that "
"the ``step()`` and ``value()`` methods must accept is controlled by "
"*num_params*.  Set to ``None`` to remove an existing SQL aggregate window "
"function."
msgstr ""

#: ../../library/sqlite3.rst:828
msgid "A class that must implement the following methods:"
msgstr "クラスは以下のメソッドを実装する必要があります:"

#: ../../library/sqlite3.rst:830
msgid "``step()``: Add a row to the current window."
msgstr "``step()``: 現在のウィンドウに行を足し込みます。"

#: ../../library/sqlite3.rst:831
msgid "``value()``: Return the current value of the aggregate."
msgstr "``value()``: 集計の現在の値を返します。"

#: ../../library/sqlite3.rst:832
msgid "``inverse()``: Remove a row from the current window."
msgstr "``inverse()``: 現在のウインドウから指定の行(row)の分を削除します。"

#: ../../library/sqlite3.rst:836
msgid ""
"The number of arguments that the ``step()`` and ``value()`` methods must "
"accept is controlled by *num_params*."
msgstr ""
"``step()`` メソッドと ``value()`` メソッドが受け入れなければならない引数の数"
"は *num_params* によって制御されます。"

#: ../../library/sqlite3.rst:839
msgid "Set to ``None`` to remove an existing SQL aggregate window function."
msgstr "``None`` に設定すると、既存の SQL 集計ウィンドウ関数が削除されます。"

#: ../../library/sqlite3.rst:841
msgid ""
"If used with a version of SQLite older than 3.25.0, which does not support "
"aggregate window functions."
msgstr ""
"集計ウィンドウ関数をサポートしていない 3.25.0 より古いバージョンの SQLite で"
"使用した場合に送出されます。"

#: ../../library/sqlite3.rst:851
msgid ""
"# Example taken from https://www.sqlite.org/windowfunctions.html#udfwinfunc\n"
"class WindowSumInt:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        \"\"\"Add a row to the current window.\"\"\"\n"
"        self.count += value\n"
"\n"
"    def value(self):\n"
"        \"\"\"Return the current value of the aggregate.\"\"\"\n"
"        return self.count\n"
"\n"
"    def inverse(self, value):\n"
"        \"\"\"Remove a row from the current window.\"\"\"\n"
"        self.count -= value\n"
"\n"
"    def finalize(self):\n"
"        \"\"\"Return the final value of the aggregate.\n"
"\n"
"        Any clean-up actions should be placed here.\n"
"        \"\"\"\n"
"        return self.count\n"
"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE test(x, y)\")\n"
"values = [\n"
"    (\"a\", 4),\n"
"    (\"b\", 5),\n"
"    (\"c\", 3),\n"
"    (\"d\", 8),\n"
"    (\"e\", 1),\n"
"]\n"
"cur.executemany(\"INSERT INTO test VALUES(?, ?)\", values)\n"
"con.create_window_function(\"sumint\", 1, WindowSumInt)\n"
"cur.execute(\"\"\"\n"
"    SELECT x, sumint(y) OVER (\n"
"        ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n"
"    ) AS sum_y\n"
"    FROM test ORDER BY x\n"
"\"\"\")\n"
"print(cur.fetchall())\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:905
msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""
"照合関数(collating function) *callable* を使用して *name* という名前の照合"
"(collation)を作成します。 *callable* には 2 つの :class:`文字列 <str>` 引数が"
"渡され、:class:`整数 <int>` を返す必要があります:"

#: ../../library/sqlite3.rst:909
msgid "``1`` if the first is ordered higher than the second"
msgstr "1 番目の文字列が 2 番目の文字列よりも高い順位ならば ``1`` を返す"

#: ../../library/sqlite3.rst:910
msgid "``-1`` if the first is ordered lower than the second"
msgstr "1 番目の文字列が 2 番目の文字列よりも低い順位ならば ``-1``  を返す"

#: ../../library/sqlite3.rst:911
msgid "``0`` if they are ordered equal"
msgstr "1 番目の文字列と 2 番目の文字列が同じ順位ならば ``0``  を返す"

#: ../../library/sqlite3.rst:913
msgid "The following example shows a reverse sorting collation:"
msgstr "以下は逆順での照合例です:"

#: ../../library/sqlite3.rst:915
msgid ""
"def collate_reverse(string1, string2):\n"
"    if string1 == string2:\n"
"        return 0\n"
"    elif string1 < string2:\n"
"        return 1\n"
"    else:\n"
"        return -1\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_collation(\"reverse\", collate_reverse)\n"
"\n"
"cur = con.execute(\"CREATE TABLE test(x)\")\n"
"cur.executemany(\"INSERT INTO test(x) VALUES(?)\", [(\"a\",), (\"b\",)])\n"
"cur.execute(\"SELECT x FROM test ORDER BY x COLLATE reverse\")\n"
"for row in cur:\n"
"    print(row)\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:941
msgid "Remove a collation function by setting *callable* to ``None``."
msgstr "照合関数を削除するには *callable* を ``None`` に設定します。"

#: ../../library/sqlite3.rst:943
msgid ""
"The collation name can contain any Unicode character.  Earlier, only ASCII "
"characters were allowed."
msgstr ""
"照合の名前には任意のユニコード文字を含めることができます。 以前は ASCII 文字"
"のみが許可されていました。"

#: ../../library/sqlite3.rst:950
msgid ""
"Call this method from a different thread to abort any queries that might be "
"executing on the connection. Aborted queries will raise an :exc:"
"`OperationalError`."
msgstr ""
"このメソッドを別のスレッドから呼び出して、この接続(connection)で、実行中のす"
"べてのクエリを中止(abort)させます。 中止(abort)させられたクエリは :exc:"
"`OperationalError` を送出します。"

#: ../../library/sqlite3.rst:957
msgid ""
"Register :term:`callable` *authorizer_callback* to be invoked for each "
"attempt to access a column of a table in the database. The callback should "
"return one of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or :const:"
"`SQLITE_IGNORE` to signal how access to the column should be handled by the "
"underlying SQLite library."
msgstr ""
"データベース内のテーブルの列(column)にアクセスしようとするたびに起動される :"
"term:`呼び出し可能オブジェクト <callable>` *authorizer_callback* を登録しま"
"す。 このコールバックは背後の SQLite ライブラリによって列(column)へのアクセス"
"がどのように処理されるかを通知するために、 :const:`SQLITE_OK` または :const:"
"`SQLITE_DENY` または :const:`SQLITE_IGNORE` のいずれかを返さなければなりませ"
"ん。"

#: ../../library/sqlite3.rst:964
msgid ""
"The first argument to the callback signifies what kind of operation is to be "
"authorized. The second and third argument will be arguments or ``None`` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or ``None`` if this access attempt is directly from input SQL code."
msgstr ""
"コールバックの最初の引数は、承認(authorize)される操作の種類を示します。 2 番"
"目と 3 番目の引数は、最初の引数に応じて、引数または ``None`` になります。 4 "
"番目の引数は、該当する場合、データベースの名前(\"main\" や \"temp\" 等)で"
"す。 5 番目の引数は、 アクセス試行を担当する最も内側のトリガーまたはビューの"
"名前です。このアクセス試行が入力 SQL コードから直接行われた場合は ``None`` で"
"す。"

#: ../../library/sqlite3.rst:971
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on "
"the first one. All necessary constants are available in the :mod:`!sqlite3` "
"module."
msgstr ""
"最初の引数に指定可能な値と、 最初の引数に応じた 2 番目と 3 番目の引数の意味に"
"ついては、 SQLite のドキュメントを参照してください。 必要なすべての定数は :"
"mod:`!sqlite3` モジュールで利用できます。"

#: ../../library/sqlite3.rst:975
msgid "Passing ``None`` as *authorizer_callback* will disable the authorizer."
msgstr ""
"*authorizer_callback* として ``None`` を渡すと、承認機構(authorizer)が無効に"
"なります。"

#: ../../library/sqlite3.rst:977
msgid "Added support for disabling the authorizer using ``None``."
msgstr ""
"``None`` を使用して承認機構(authorizer)を無効にするサポートが追加されました。"

#: ../../library/sqlite3.rst:980
msgid ""
"Passing *authorizer_callback* as a keyword argument is deprecated. The "
"parameter will become positional-only in Python 3.15."
msgstr ""

#: ../../library/sqlite3.rst:987
msgid ""
"Register :term:`callable` *progress_handler* to be invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update "
"a GUI."
msgstr ""
"SQLite 仮想マシンの命令を *n* 個実行するごとに呼び出されるように、 :term:`呼"
"び出し可能オブジェクト <callable>` *progress_handler* を登録します。これは、 "
"GUI の更新など、長時間実行される操作中に SQLite から呼び出されるようにしたい"
"場合に便利です。"

#: ../../library/sqlite3.rst:992
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with ``None`` for *progress_handler*."
msgstr ""
"以前にインストールした progress ハンドラーをクリアしたい場合は、 "
"*progress_handler* に ``None`` を指定してメソッドを呼び出します。"

#: ../../library/sqlite3.rst:995
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise a :exc:`DatabaseError` "
"exception."
msgstr ""
"ハンドラー関数からゼロ以外の値を返すと、現在実行中のクエリを終了(terminate)"
"し、 :exc:`DatabaseError` 例外を送出します。"

#: ../../library/sqlite3.rst:999
msgid ""
"Passing *progress_handler* as a keyword argument is deprecated. The "
"parameter will become positional-only in Python 3.15."
msgstr ""

#: ../../library/sqlite3.rst:1006
msgid ""
"Register :term:`callable` *trace_callback* to be invoked for each SQL "
"statement that is actually executed by the SQLite backend."
msgstr ""
"SQLite バックエンドによって実際に実行される SQL 文ごとに起動される :term:`呼"
"び出し可能オブジェクト <callable>` *trace_callback* を登録します。"

#: ../../library/sqlite3.rst:1009
msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the :meth:`Cursor."
"execute` methods.  Other sources include the :ref:`transaction management "
"<sqlite3-controlling-transactions>` of the :mod:`!sqlite3` module and the "
"execution of triggers defined in the current database."
msgstr ""
"コールバックに渡される唯一の引数は、(:class:`str` として渡される)実行中のSQL"
"文です。 コールバックの戻り値は無視されます。 バックエンドは、 :meth:`Cursor."
"execute` メソッドに渡されたSQL文を実行するだけではないことに注意してくださ"
"い。 :mod:`!sqlite3` モジュールの :ref:`トランザクション管理 <sqlite3-"
"controlling-transactions>` や、現在のデータベース内で定義されたトリガーの実行"
"その他も行います。"

#: ../../library/sqlite3.rst:1017
msgid "Passing ``None`` as *trace_callback* will disable the trace callback."
msgstr ""
"*trace_callback* として ``None`` を渡すと、トレース・コールバックが無効になり"
"ます。"

#: ../../library/sqlite3.rst:1020
msgid ""
"Exceptions raised in the trace callback are not propagated. As a development "
"and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to enable "
"printing tracebacks from exceptions raised in the trace callback."
msgstr ""
"トレース・コールバックで送出した例外は伝播されません。 開発およびデバッグの補"
"助として、 :meth:`~sqlite3.enable_callback_tracebacks` を使用して、トレース・"
"コールバックで送出した例外からのトレースバックの出力を有効にします。"

#: ../../library/sqlite3.rst:1027
msgid ""
"Passing *trace_callback* as a keyword argument is deprecated. The parameter "
"will become positional-only in Python 3.15."
msgstr ""

#: ../../library/sqlite3.rst:1034
msgid ""
"Enable the SQLite engine to load SQLite extensions from shared libraries if "
"*enabled* is ``True``; else, disallow loading SQLite extensions. SQLite "
"extensions can define new functions, aggregates or whole new virtual table "
"implementations.  One well-known extension is the fulltext-search extension "
"distributed with SQLite."
msgstr ""
"*enabled* が ``True`` の場合、 SQLite エンジンが共有ライブラリから SQLite 拡"
"張機能をロードできるようにします。 ``True`` 以外の場合は、 SQLite 拡張機能の"
"読み込みを許可しません。 SQLite 拡張機能では、新しい関数の定義、または集計の"
"定義、またはまったく新しい仮想テーブルの実装を定義できます。 よく知られている"
"拡張機能の 1 つは、SQLite と共に配布される全文検索拡張機能です。"

#: ../../library/sqlite3.rst:1043
msgid ""
"The :mod:`!sqlite3` module is not built with loadable extension support by "
"default, because some platforms (notably macOS) have SQLite libraries which "
"are compiled without this feature. To get loadable extension support, you "
"must pass the :option:`--enable-loadable-sqlite-extensions` option to :"
"program:`configure`."
msgstr ""
":mod:`!sqlite3` モジュールは、デフォルトではロード可能な拡張機能をサポートす"
"るようにビルドされていません。一部のプラットフォーム(特に macOS)には、この機"
"能なしでコンパイルされた SQLite ライブラリがあるためです。 ロード可能な拡張機"
"能のサポートを得るには、 :program:`configure` に :option:`--enable-loadable-"
"sqlite-extensions` オプションを渡す必要があります。"

#: ../../library/sqlite3.rst:1050
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.enable_load_extension`` "
"with arguments ``connection``, ``enabled``."
msgstr ""
"引数 ``connection``, ``enabled`` を指定して :ref:`監査イベント <auditing>` "
"``sqlite3.enable_load_extension`` を送出します。 "

#: ../../library/sqlite3.rst:1054
msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr "``sqlite3.enable_load_extension`` 監査イベントを追加しました。"

#: ../../library/sqlite3.rst:1060
msgid ""
"con.enable_load_extension(True)\n"
"\n"
"# Load the fulltext search extension\n"
"con.execute(\"select load_extension('./fts3.so')\")\n"
"\n"
"# alternatively you can load the extension using an API call:\n"
"# con.load_extension(\"./fts3.so\")\n"
"\n"
"# disable extension loading again\n"
"con.enable_load_extension(False)\n"
"\n"
"# example from SQLite wiki\n"
"con.execute(\"CREATE VIRTUAL TABLE recipe USING fts3(name, ingredients)\")\n"
"con.executescript(\"\"\"\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli stew', 'broccoli "
"peppers cheese tomatoes');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin stew', 'pumpkin "
"onions garlic celery');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli pie', 'broccoli "
"cheese onions flour');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin pie', 'pumpkin "
"sugar flour butter');\n"
"    \"\"\")\n"
"for row in con.execute(\"SELECT rowid, name, ingredients FROM recipe WHERE "
"name MATCH 'pie'\"):\n"
"    print(row)"
msgstr ""

#: ../../library/sqlite3.rst:1086
msgid ""
"Load an SQLite extension from a shared library. Enable extension loading "
"with :meth:`enable_load_extension` before calling this method."
msgstr ""
"共有ライブラリから SQLite 拡張機能(extension)をロードします。このメソッドを呼"
"び出す前に :meth:`enable_load_extension` で拡張機能の読み込みを有効にしてくだ"
"さい。"

#: ../../library/sqlite3.rst:1090
msgid "The path to the SQLite extension."
msgstr "SQLite 拡張機能(extension)へのパス(path)。"

#: ../../library/sqlite3.rst:1094
msgid ""
"Entry point name. If ``None`` (the default), SQLite will come up with an "
"entry point name of its own; see the SQLite docs `Loading an Extension`_ for "
"details."
msgstr ""
"エントリ・ポイント名。 ``None`` (デフォルト) の場合、 SQLite は自分自身でエン"
"トリ・ポイント名を推測します。 詳細については、SQLite ドキュメント `Loading "
"an Extension`_ を参照してください。"

#: ../../library/sqlite3.rst:1103
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` with "
"arguments ``connection``, ``path``."
msgstr ""
"引数 ``connection``, ``path`` を指定して :ref:`監査イベント <auditing>` "
"``sqlite3.load_extension`` を送出します。 "

#: ../../library/sqlite3.rst:1107
msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr "``sqlite3.load_extension`` 監査イベントを追加しました。"

#: ../../library/sqlite3.rst:1110
msgid "Added the *entrypoint* parameter."
msgstr ""

#: ../../library/sqlite3.rst:1117
msgid ""
"Return an :term:`iterator` to dump the database as SQL source code. Useful "
"when saving an in-memory database for later restoration. Similar to the ``."
"dump`` command in the :program:`sqlite3` shell."
msgstr ""
"データベースを SQL ソース・コードとしてダンプする :term:`iterator` を返しま"
"す。 後で復元するためにメモリ内データベースを保存する場合に便利です。 :"
"program:`sqlite3` シェルの ``.dump`` コマンドに似ています。"

#: ../../library/sqlite3.rst:1121
msgid ""
"An optional ``LIKE`` pattern for database objects to dump, e.g. "
"``prefix_%``. If ``None`` (the default), all database objects will be "
"included."
msgstr ""

#: ../../library/sqlite3.rst:1130
msgid ""
"# Convert file example.db to SQL dump file dump.sql\n"
"con = sqlite3.connect('example.db')\n"
"with open('dump.sql', 'w') as f:\n"
"    for line in con.iterdump():\n"
"        f.write('%s\\n' % line)\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:1141 ../../library/sqlite3.rst:1215
msgid ":ref:`sqlite3-howto-encoding`"
msgstr ""

#: ../../library/sqlite3.rst:1143
msgid "Added the *filter* parameter."
msgstr "*filter* パラメータが追加されました。"

#: ../../library/sqlite3.rst:1148
msgid "Create a backup of an SQLite database."
msgstr "SQLite データベースのバックアップを作成します。"

#: ../../library/sqlite3.rst:1150
msgid ""
"Works even if the database is being accessed by other clients or "
"concurrently by the same connection."
msgstr ""
"データベースが他のクライアントによってアクセスされている場合、または同一の接"
"続によって並行にアクセスされている場合でも機能します。"

#: ../../library/sqlite3.rst:1153
msgid "The database connection to save the backup to."
msgstr "バックアップ先のデータベース接続(connection)。"

#: ../../library/sqlite3.rst:1156
msgid ""
"The number of pages to copy at a time. If equal to or less than ``0``, the "
"entire database is copied in a single step. Defaults to ``-1``."
msgstr ""
"一度にコピーするページ数。 ``0`` 以下の場合、データベース全体がワンステップで"
"コピーされます。 デフォルトは ``-1`` です。"

#: ../../library/sqlite3.rst:1162
msgid ""
"If set to a :term:`callable`, it is invoked with three integer arguments for "
"every backup iteration: the *status* of the last iteration, the *remaining* "
"number of pages still to be copied, and the *total* number of pages. "
"Defaults to ``None``."
msgstr ""
":term:`呼び出し可能オブジェクト <callable>` を設定すると、バックアップの指定"
"ページ数単位の反復ごとに 3 つの整数引数で呼び出されます。 *status* は、最後の"
"反復時のステータスで、 *remaining* はまだコピーされていない残りのページ数"
"で、 *total* はコピーされるページの合計です。 デフォルトは ``None`` です。"

#: ../../library/sqlite3.rst:1171
msgid ""
"The name of the database to back up. Either ``\"main\"`` (the default) for "
"the main database, ``\"temp\"`` for the temporary database, or the name of a "
"custom database as attached using the ``ATTACH DATABASE`` SQL statement."
msgstr ""
"バックアップするデータベース名。 ``\"main\"`` (メイン・データベース。これがデ"
"フォルトです)、または ``\"temp\"`` (一時データベース)、 または ``ATTACH "
"DATABASE`` SQL文を使用して取り付けられたカスタム・データベース名の、いずれか"
"です。"

#: ../../library/sqlite3.rst:1178
msgid ""
"The number of seconds to sleep between successive attempts to back up "
"remaining pages."
msgstr "バックアップの指定ページ数単位の反復ごとにスリープする秒数。"

#: ../../library/sqlite3.rst:1182
msgid "Example 1, copy an existing database into another:"
msgstr "例 1. 既存のデータベースを別のデータベースにコピーします:"

#: ../../library/sqlite3.rst:1184
msgid ""
"def progress(status, remaining, total):\n"
"    print(f'Copied {total-remaining} of {total} pages...')\n"
"\n"
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect('backup.db')\n"
"with dst:\n"
"    src.backup(dst, pages=1, progress=progress)\n"
"dst.close()\n"
"src.close()"
msgstr ""

#: ../../library/sqlite3.rst:1201
msgid "Example 2, copy an existing database into a transient copy:"
msgstr "例 2. 既存のデータベースを臨時コピー(transient copy)にコピーします。"

#: ../../library/sqlite3.rst:1203
msgid ""
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect(':memory:')\n"
"src.backup(dst)\n"
"dst.close()\n"
"src.close()"
msgstr ""

#: ../../library/sqlite3.rst:1219
msgid "Get a connection runtime limit."
msgstr "接続(connection)の実行時制限を取得します。"

#: ../../library/sqlite3.rst:1221
msgid "The `SQLite limit category`_ to be queried."
msgstr "問い合わせを行う実行時制限カテゴリー(`SQLite limit category`_)。"

#: ../../library/sqlite3.rst:1226 ../../library/sqlite3.rst:1263
msgid "If *category* is not recognised by the underlying SQLite library."
msgstr ""
"*category* に、 背後の SQLite ライブラリが認識できないカテゴリーを指定した場"
"合に送出されます。"

#: ../../library/sqlite3.rst:1229
msgid ""
"Example, query the maximum length of an SQL statement for :class:"
"`Connection` ``con`` (the default is 1000000000):"
msgstr ""
"例: :class:`Connection` の ``con`` の SQL 文の最大長を照会します (デフォルト"
"は 1000000000 です):"

#: ../../library/sqlite3.rst:1239
msgid ""
">>> con.getlimit(sqlite3.SQLITE_LIMIT_SQL_LENGTH)\n"
"1000000000"
msgstr ""

#: ../../library/sqlite3.rst:1249
msgid ""
"Set a connection runtime limit. Attempts to increase a limit above its hard "
"upper bound are silently truncated to the hard upper bound. Regardless of "
"whether or not the limit was changed, the prior value of the limit is "
"returned."
msgstr ""
"接続の実行時制限を設定します。 コンパイル時上限を超えて制限を増やそうとする"
"と、 暗黙のうちにコンパイル時上限に切り捨てられます。 制限が変更されたかどう"
"かに関係なく、 制限の以前の値が返されます。"

#: ../../library/sqlite3.rst:1254
msgid "The `SQLite limit category`_ to be set."
msgstr "`SQLite limit category`_ を設定する。"

#: ../../library/sqlite3.rst:1257
msgid ""
"The value of the new limit. If negative, the current limit is unchanged."
msgstr "新しい制限の値。 負数の場合、 現在の制限は変更されません。"

#: ../../library/sqlite3.rst:1266
msgid ""
"Example, limit the number of attached databases to 1 for :class:`Connection` "
"``con`` (the default limit is 10):"
msgstr ""
":class:`Connection` の ``con`` に対して、取り付けられるデータベース(attached "
"databases)の数を 1 に制限します (デフォルトの制限は 10 です):"

#: ../../library/sqlite3.rst:1269
msgid ""
">>> con.setlimit(sqlite3.SQLITE_LIMIT_ATTACHED, 1)\n"
"10\n"
">>> con.getlimit(sqlite3.SQLITE_LIMIT_ATTACHED)\n"
"1"
msgstr ""

#: ../../library/sqlite3.rst:1287
msgid "Query a boolean connection configuration option."
msgstr "ブール値の接続構成オプションを問い合わせます。"

#: ../../library/sqlite3.rst:1289 ../../library/sqlite3.rst:1300
msgid "A :ref:`SQLITE_DBCONFIG code <sqlite3-dbconfig-constants>`."
msgstr ""
":ref:`SQLITE_DBCONFIG code <sqlite3-dbconfig-constants>` を指定します。"

#: ../../library/sqlite3.rst:1298
msgid "Set a boolean connection configuration option."
msgstr "ブール値の接続構成オプションを設定します。"

#: ../../library/sqlite3.rst:1303
msgid ""
"``True`` if the configuration option should be enabled (default); ``False`` "
"if it should be disabled."
msgstr ""
"設定オプションを有効にする必要がある場合は ``True`` (デフォルト)。 無効にする"
"場合は ``False`` を指定します。"

#: ../../library/sqlite3.rst:1311
msgid ""
"Serialize a database into a :class:`bytes` object.  For an ordinary on-disk "
"database file, the serialization is just a copy of the disk file.  For an in-"
"memory database or a \"temp\" database, the serialization is the same "
"sequence of bytes which would be written to disk if that database were "
"backed up to disk."
msgstr ""
"データベースを :class:`bytes` オブジェクトに直列化(serialize)します。 通常の"
"ディスク上のデータベース・ファイルの場合、 直列化はディスク・ファイルの単なる"
"コピーです。 インメモリ・データベースまたは \"temp\" データベースの場合、 直"
"列化は、 そのデータベースがディスクにバックアップされた場合にディスクに書き込"
"まれるバイト・シーケンスと同じです。"

#: ../../library/sqlite3.rst:1317
msgid "The database name to be serialized. Defaults to ``\"main\"``."
msgstr "直列化するデータベース名。 デフォルトは ``\"main\"`` です。"

#: ../../library/sqlite3.rst:1325
msgid ""
"This method is only available if the underlying SQLite library has the "
"serialize API."
msgstr ""
"このメソッドは、 背後の SQLite ライブラリに直列化 API がある場合にのみ使用で"
"きます。"

#: ../../library/sqlite3.rst:1333
msgid ""
"Deserialize a :meth:`serialized <serialize>` database into a :class:"
"`Connection`. This method causes the database connection to disconnect from "
"database *name*, and reopen *name* as an in-memory database based on the "
"serialization contained in *data*."
msgstr ""
":meth:`直列化 <serialize>` されたデータベースを :class:`Connection` に、 脱直"
"列化(deserialize)します。 このメソッドにより、 データベース接続はデータベー"
"ス *name* から切断され、そして、  *data* に含まれる直列化データに基づいて、 "
"データベース *name* がインメモリ・データベースとして再度開かれます。"

#: ../../library/sqlite3.rst:1339
msgid "A serialized database."
msgstr "直列化されたデータベース。"

#: ../../library/sqlite3.rst:1342
msgid "The database name to deserialize into. Defaults to ``\"main\"``."
msgstr ""
"脱直列化(deserialize)したデータを入れるデータベース名。 デフォルトは "
"``\"main\"`` です。"

#: ../../library/sqlite3.rst:1346
msgid ""
"If the database connection is currently involved in a read transaction or a "
"backup operation."
msgstr "データベース接続が読み取りトランザクションやバックアップ操作中の場合。"

#: ../../library/sqlite3.rst:1350
msgid "If *data* does not contain a valid SQLite database."
msgstr "*data* に有効な SQLite データベースが含まれていない場合。"

#: ../../library/sqlite3.rst:1353
msgid "If :func:`len(data) <len>` is larger than ``2**63 - 1``."
msgstr ":func:`len(data) <len>` が ``2**63 - 1`` より大きい場合。"

#: ../../library/sqlite3.rst:1358
msgid ""
"This method is only available if the underlying SQLite library has the "
"deserialize API."
msgstr ""
"このメソッドは、 背後の SQLite ライブラリに脱直列化 API がある場合にのみ使用"
"できます。"

#: ../../library/sqlite3.rst:1365
msgid ""
"This attribute controls :pep:`249`-compliant transaction behaviour. :attr:`!"
"autocommit` has three allowed values:"
msgstr ""
"この属性は、 :pep:`249` 対応のトランザクションの振る舞いを制御します。 :attr:"
"`!auto​​commit` には以下の 3 つの値が指定できます:"

#: ../../library/sqlite3.rst:1368
msgid ""
"``False``: Select :pep:`249`-compliant transaction behaviour, implying that :"
"mod:`!sqlite3` ensures a transaction is always open. Use :meth:`commit` and :"
"meth:`rollback` to close transactions."
msgstr ""
"``False``: :pep:`249` 対応のトランザクションの振る舞いを選びます。 これは、 :"
"mod:`!sqlite3` が、 トランザクションが常に開いていることを保証することを意味"
"します。トランザクションを閉じるには、 :meth:`commit` や :meth:`rollback` を"
"使用します。"

#: ../../library/sqlite3.rst:1372
msgid "This is the recommended value of :attr:`!autocommit`."
msgstr "これが :attr:`!auto​​commit` の推奨値です。"

#: ../../library/sqlite3.rst:1374
msgid ""
"``True``: Use SQLite's `autocommit mode`_. :meth:`commit` and :meth:"
"`rollback` have no effect in this mode."
msgstr ""
"``True``: SQLite の `autocommit mode`_ を使用します。このモードでは :meth:"
"`commit` や :meth:`rollback` は効果がありません。"

#: ../../library/sqlite3.rst:1377
msgid ""
":data:`LEGACY_TRANSACTION_CONTROL`: Pre-Python 3.12 (non-:pep:`249`-"
"compliant) transaction control. See :attr:`isolation_level` for more details."
msgstr ""
":data:`LEGACY_TRANSACTION_CONTROL`: Python 3.12 より前(:pep:`249` 非対応)のト"
"ランザクション制御。 詳細については :attr:`isolation_level` を参照してくださ"
"い。"

#: ../../library/sqlite3.rst:1381
msgid "This is currently the default value of :attr:`!autocommit`."
msgstr "これが、今のところは、 :attr:`!auto​​commit` のデフォルト値です。"

#: ../../library/sqlite3.rst:1383
msgid ""
"Changing :attr:`!autocommit` to ``False`` will open a new transaction, and "
"changing it to ``True`` will commit any pending transaction."
msgstr ""
":attr:`!auto​​commit` を ``False`` に変更すると新しいトランザクションが開き、 "
"``True`` に変更すると保留中のトランザクションがコミットされます。"

#: ../../library/sqlite3.rst:1386
msgid "See :ref:`sqlite3-transaction-control-autocommit` for more details."
msgstr ""
"詳細は :ref:`sqlite3-transaction-control-autocommit` を参照してください。"

#: ../../library/sqlite3.rst:1390
msgid ""
"The :attr:`isolation_level` attribute has no effect unless :attr:"
"`autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`."
msgstr ""
":attr:`isolation_level` 属性は、 :attr:`autocommit` の値が :data:"
"`LEGACY_TRANSACTION_CONTROL` でない限り、効果がありません。"

#: ../../library/sqlite3.rst:1397
msgid ""
"This read-only attribute corresponds to the low-level SQLite `autocommit "
"mode`_."
msgstr ""
"この読み取り専用属性は、低レベルの SQLite `autocommit mode`_ に対応します。"

#: ../../library/sqlite3.rst:1400
msgid ""
"``True`` if a transaction is active (there are uncommitted changes), "
"``False`` otherwise."
msgstr ""
"トランザクションがアクティブな場合 (コミットされていない変更がある場合) は "
"``True`` 、それ以外の場合は ``False`` です。"

#: ../../library/sqlite3.rst:1407
msgid ""
"Controls the :ref:`legacy transaction handling mode <sqlite3-transaction-"
"control-isolation-level>` of :mod:`!sqlite3`. If set to ``None``, "
"transactions are never implicitly opened. If set to one of ``\"DEFERRED\"``, "
"``\"IMMEDIATE\"``, or ``\"EXCLUSIVE\"``, corresponding to the underlying "
"`SQLite transaction behaviour`_, :ref:`implicit transaction management "
"<sqlite3-transaction-control-isolation-level>` is performed."
msgstr ""
":mod:`!sqlite3` の :ref:`旧来のトランザクション処理モード <sqlite3-"
"transaction-control-isolation-level>` を制御します。 ``None`` に設定すると、"
"トランザクションは暗黙に開かれることはありません。背後の SQLite の `SQLite "
"transaction behaviour`_ に対応する ``\"DEFERRED\"`` または ``\"IMMEDIATE\"`` "
"または ``\"EXCLUSIVE\"`` のいずれかに設定すると、 :ref:`暗黙のトランザクショ"
"ン管理 <sqlite3-transaction-control-isolation-level>` が実行されます。"

#: ../../library/sqlite3.rst:1415
msgid ""
"If not overridden by the *isolation_level* parameter of :func:`connect`, the "
"default is ``\"\"``, which is an alias for ``\"DEFERRED\"``."
msgstr ""
":func:`connect` の *isolation_level* パラメーターでオーバーライドされない場"
"合、 デフォルトは ``\"\"`` で、 これは ``\"DEFERRED\"`` の別名です。"

#: ../../library/sqlite3.rst:1420
msgid ""
"Using :attr:`autocommit` to control transaction handling is recommended over "
"using :attr:`!isolation_level`. :attr:`!isolation_level` has no effect "
"unless :attr:`autocommit` is set to :data:`LEGACY_TRANSACTION_CONTROL` (the "
"default)."
msgstr ""
"トランザクション処理を制御するには、 :attr:`!isolation_level` を使用するより"
"も :attr:`autocommit` を使用することをお勧めします。 :attr:`autocommit` が :"
"data:`LEGACY_TRANSACTION_CONTROL` (これがデフォルトです)に設定されていない限"
"り、 :attr:`!isolation_level` は効果がありません。"

#: ../../library/sqlite3.rst:1427
msgid ""
"The initial :attr:`~Cursor.row_factory` for :class:`Cursor` objects created "
"from this connection. Assigning to this attribute does not affect the :attr:"
"`!row_factory` of existing cursors belonging to this connection, only new "
"ones. Is ``None`` by default, meaning each row is returned as a :class:"
"`tuple`."
msgstr ""
"この接続から作成された :class:`Cursor` オブジェクトの初期 :attr:`~Cursor."
"row_factory` 。この属性に割り当てを行っても、 この接続に属する、すでに存在す"
"るカーソルの :attr:`!row_factory` には影響せず、 この属性に割り当てを行った後"
"に作成する新しいカーソルのみに影響します。 デフォルトでは ``None`` です。つま"
"り、各行は :class:`タプル <tuple>` として返されます。"

#: ../../library/sqlite3.rst:1434 ../../library/sqlite3.rst:1720
#: ../../library/sqlite3.rst:1743
msgid "See :ref:`sqlite3-howto-row-factory` for more details."
msgstr "詳細は :ref:`sqlite3-howto-row-factory` をご覧下さい。"

#: ../../library/sqlite3.rst:1438
msgid ""
"A :term:`callable` that accepts a :class:`bytes` parameter and returns a "
"text representation of it. The callable is invoked for SQLite values with "
"the ``TEXT`` data type. By default, this attribute is set to :class:`str`."
msgstr ""
":class:`bytes` のパラメータを受け取り、そのテキスト表現を返す :term:`呼び出し"
"可能オブジェクト <callable>` です。呼び出し可能オブジェクトは ``TEXT`` データ"
"型である SQLite 値に対して呼び出されます。 デフォルトでは、 この属性は :"
"class:`str` に設定されています。"

#: ../../library/sqlite3.rst:1443
msgid "See :ref:`sqlite3-howto-encoding` for more details."
msgstr ""

#: ../../library/sqlite3.rst:1447
msgid ""
"Return the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr ""
"データベース接続が開かれてから、変更または挿入または削除されたデータベース行"
"の総数を返します。"

#: ../../library/sqlite3.rst:1454
msgid "Cursor objects"
msgstr "Cursor オブジェクト"

#: ../../library/sqlite3.rst:1456
msgid ""
"A ``Cursor`` object represents a `database cursor`_ which is used to execute "
"SQL statements, and manage the context of a fetch operation. Cursors are "
"created using :meth:`Connection.cursor`, or by using any of the :ref:"
"`connection shortcut methods <sqlite3-connection-shortcuts>`."
msgstr ""
"``Cursor`` オブジェクトは、 SQL 文を実行し、 取得操作(fetch operation)のコン"
"テキストを管理するために使用されるデータベース・カーソル(`database cursor`_)"
"を表します。カーソルは、 :meth:`Connection.cursor` または :ref:`接続"
"(connection)ショートカット・メソッド <sqlite3-connection-shortcuts>` の、いず"
"れかを使用して作成されます。"

#: ../../library/sqlite3.rst:1463
msgid ""
"Cursor objects are :term:`iterators <iterator>`, meaning that if you :meth:"
"`~Cursor.execute` a ``SELECT`` query, you can simply iterate over the cursor "
"to fetch the resulting rows:"
msgstr ""
"カーソル・オブジェクトは :term:`イテレータ <iterator>` です。つまり、 "
"``SELECT`` クエリに対して :meth:`~Cursor.execute` した場合、結果の行(rows)を"
"取得するためには、カーソルを単純に反復(iterate)できます:"

#: ../../library/sqlite3.rst:1474
msgid ""
"for row in cur.execute(\"SELECT t FROM data\"):\n"
"    print(row)"
msgstr ""

#: ../../library/sqlite3.rst:1488
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr ":class:`Cursor` インスタンスは以下の属性やメソッドを持ちます。"

#: ../../library/sqlite3.rst:1495
msgid ""
"Execute a single SQL statement, optionally binding Python values using :ref:"
"`placeholders <sqlite3-placeholders>`."
msgstr ""

#: ../../library/sqlite3.rst:1499
msgid "A single SQL statement."
msgstr "単一の SQL 文。"

#: ../../library/sqlite3.rst:1502
msgid ""
"Python values to bind to placeholders in *sql*. A :class:`!dict` if named "
"placeholders are used. A :term:`!sequence` if unnamed placeholders are used. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"*sql* のプレースホルダに結び付け(bind)する Python 値。 名前付きプレースホルダ"
"が使用されている場合は :class:`!dict` です。 名前のないプレースホルダが使用さ"
"れている場合は :term:`!sequence` です。 :ref:`sqlite3-placeholders` を参照し"
"てください。"

#: ../../library/sqlite3.rst:1509
msgid "If *sql* contains more than one SQL statement."
msgstr "*sql* に複数の SQL 文が含まれている場合。"

#: ../../library/sqlite3.rst:1512
msgid ""
"If :attr:`~Connection.autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`, :"
"attr:`~Connection.isolation_level` is not ``None``, *sql* is an ``INSERT``, "
"``UPDATE``, ``DELETE``, or ``REPLACE`` statement, and there is no open "
"transaction, a transaction is implicitly opened before executing *sql*."
msgstr ""
":attr:`~Connection.autocommit` が :data:`LEGACY_TRANSACTION_CONTROL` で、か"
"つ、 :attr:`~Connection.isolation_level` が ``None`` で無く、 かつ、 *sql* "
"が ``INSERT`` または ``UPDATE`` または ``DELETE`` または ``REPLACE`` 文で、か"
"つ、開いているトランザクションがない場合、 *sql* を実行する前にトランザクショ"
"ンが暗黙に開かれます。"

#: ../../library/sqlite3.rst:1521
msgid ""
":exc:`DeprecationWarning` is emitted if :ref:`named placeholders <sqlite3-"
"placeholders>` are used and *parameters* is a sequence instead of a :class:"
"`dict`. Starting with Python 3.14, :exc:`ProgrammingError` will be raised "
"instead."
msgstr ""
":ref:`名前付きプレースホルダー<sqlite3-placeholders>` が使用され、かつ、パラ"
"メーターが :class:`dict` ではなくシーケンスである場合、 :exc:"
"`DeprecationWarning` を送出します。 Python 3.14 以降では、代わりに :exc:"
"`ProgrammingError` を送出します。"

#: ../../library/sqlite3.rst:1527
msgid "Use :meth:`executescript` to execute multiple SQL statements."
msgstr "複数の SQL 文を実行するには :meth:`executescript` を使用します。"

#: ../../library/sqlite3.rst:1531
msgid ""
"For every item in *parameters*, repeatedly execute the :ref:`parameterized "
"<sqlite3-placeholders>` :abbr:`DML (Data Manipulation Language)` SQL "
"statement *sql*."
msgstr ""
"*parameters* のすべての item に対して、 :ref:`パラメーター化 <sqlite3-"
"placeholders>` された :abbr:`DML (Data Manipulation Language)` SQL 文である "
"*sql* を繰り返し実行します。"

#: ../../library/sqlite3.rst:1535
msgid "Uses the same implicit transaction handling as :meth:`~Cursor.execute`."
msgstr ""
":meth:`~Cursor.execute` と同一の暗黙のトランザクション処理を使用します。"

#: ../../library/sqlite3.rst:1537
msgid "A single SQL DML statement."
msgstr "単一の DML 文。"

#: ../../library/sqlite3.rst:1540
msgid ""
"An :term:`!iterable` of parameters to bind with the placeholders in *sql*. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"*sql* のプレースホルダに結び付け(bind)するためのパラメータの :term:`!"
"iterable` 。 :ref:`sqlite3-placeholders` 参照。"

#: ../../library/sqlite3.rst:1546
msgid ""
"If *sql* contains more than one SQL statement, or is not a DML statement."
msgstr ""

#: ../../library/sqlite3.rst:1552
msgid ""
"rows = [\n"
"    (\"row1\",),\n"
"    (\"row2\",),\n"
"]\n"
"# cur is an sqlite3.Cursor object\n"
"cur.executemany(\"INSERT INTO data VALUES(?)\", rows)"
msgstr ""

#: ../../library/sqlite3.rst:1567
msgid ""
"Any resulting rows are discarded, including DML statements with `RETURNING "
"clauses`_."
msgstr ""
"RETURNING 句(`RETURNING clauses`_)を含むDML文を含め、結果の行はすべて破棄され"
"ます。"

#: ../../library/sqlite3.rst:1574
msgid ""
":exc:`DeprecationWarning` is emitted if :ref:`named placeholders <sqlite3-"
"placeholders>` are used and the items in *parameters* are sequences instead "
"of :class:`dict`\\s. Starting with Python 3.14, :exc:`ProgrammingError` will "
"be raised instead."
msgstr ""
":ref:`名前付きプレースホルダー<sqlite3-placeholders>` が使用され、かつ、パラ"
"メーターが :class:`dict` ではなくシーケンスである場合、 :exc:"
"`DeprecationWarning` を送出します。 Python 3.14 以降では、代わりに :exc:"
"`ProgrammingError` を送出します。"

#: ../../library/sqlite3.rst:1583
msgid ""
"Execute the SQL statements in *sql_script*. If the :attr:`~Connection."
"autocommit` is :data:`LEGACY_TRANSACTION_CONTROL` and there is a pending "
"transaction, an implicit ``COMMIT`` statement is executed first. No other "
"implicit transaction control is performed; any transaction control must be "
"added to *sql_script*."
msgstr ""
"*sql_script* 内の複数のSQL文を実行します。 :attr:`~Connection.autocommit` "
"が :data:`LEGACY_TRANSACTION_CONTROL` で、かつ、保留中のトランザクションがあ"
"る場合、暗黙の ``COMMIT`` 文が最初に実行されます。その他の暗黙のトランザク"
"ション制御は実行されませんので、トランザクション制御を *sql_script* に追加し"
"なければなりません。"

#: ../../library/sqlite3.rst:1591
msgid "*sql_script* must be a :class:`string <str>`."
msgstr "*sql_script* は :class:`文字列 <str>` でなければなりません。"

#: ../../library/sqlite3.rst:1595
msgid ""
"# cur is an sqlite3.Cursor object\n"
"cur.executescript(\"\"\"\n"
"    BEGIN;\n"
"    CREATE TABLE person(firstname, lastname, age);\n"
"    CREATE TABLE book(title, author, published);\n"
"    CREATE TABLE publisher(name, address);\n"
"    COMMIT;\n"
"\"\"\")"
msgstr ""

#: ../../library/sqlite3.rst:1608
msgid ""
"If :attr:`~Cursor.row_factory` is ``None``, return the next row query result "
"set as a :class:`tuple`. Else, pass it to the row factory and return its "
"result. Return ``None`` if no more data is available."
msgstr ""
":attr:`~Cursor.row_factory` が ``None`` の場合、 次の行のクエリ結果セットを :"
"class:`タプル <tuple>` として返します。それ以外の場合は、 それを行工場(row "
"factory)に渡し、 その結果を返します。 これ以上データが無い場合は ``None`` を"
"返します。"

#: ../../library/sqlite3.rst:1616
msgid ""
"Return the next set of rows of a query result as a :class:`list`. Return an "
"empty list if no more rows are available."
msgstr ""
"クエリ結果の次の行セットを :class:`list` として返します。行がそれ以上ない場合"
"は、空のリストを返します。"

#: ../../library/sqlite3.rst:1619
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If *size* is not given, :attr:`arraysize` determines the number of rows to "
"be fetched. If fewer than *size* rows are available, as many rows as are "
"available are returned."
msgstr ""
"呼び出しごとに取得する行数は、*size* パラメーターで指定されます。 *size* が指"
"定されていない場合、 :attr:`arraysize` が取得する行数を決定します。有効な行の"
"数が *size* 未満の場合は、有効な数の行が返されます。"

#: ../../library/sqlite3.rst:1625
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain "
"the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"*size* 引数とパフォーマンスの関係についての注意です。パフォーマンスを最適化す"
"るためには、大抵、 arraysize 属性を利用するのがベストです。 *size* 引数を利用"
"したのであれば、次回の :meth:`fetchmany` の呼び出しでも *size* 引数に同一の値"
"を指定するのがのがベストです。"

#: ../../library/sqlite3.rst:1632
msgid ""
"Return all (remaining) rows of a query result as a :class:`list`. Return an "
"empty list if no rows are available. Note that the :attr:`arraysize` "
"attribute can affect the performance of this operation."
msgstr ""
"クエリ結果の(残りの)すべての行を :class:`list` として返します。 有効な行がな"
"い場合は、空のリストを返します。 :attr:`arraysize` 属性は、この操作のパフォー"
"マンスに影響を与える可能性があることに注意してください。"

#: ../../library/sqlite3.rst:1639
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "(``__del__`` が呼び出される時ではなく、) 今すぐカーソルを閉じます。"

#: ../../library/sqlite3.rst:1641
msgid ""
"The cursor will be unusable from this point forward; a :exc:"
"`ProgrammingError` exception will be raised if any operation is attempted "
"with the cursor."
msgstr ""
"この時点から、このカーソルは使用できなくなります。今後、このカーソルで何らか"
"の操作を試みると、 :exc:`ProgrammingError` 例外が送出されます。"

#: ../../library/sqlite3.rst:1646 ../../library/sqlite3.rst:1650
msgid "Required by the DB-API. Does nothing in :mod:`!sqlite3`."
msgstr "DB-API で必要です。 :mod:`!sqlite3` では何もしません。"

#: ../../library/sqlite3.rst:1654
msgid ""
"Read/write attribute that controls the number of rows returned by :meth:"
"`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr ""
":meth:`fetchmany` によって返される行(row)数を制御する、読み取りと書き込みが可"
"能な属性。 デフォルト値は 1 で、これは呼び出しごとに 1 行が取得されることを意"
"味します。"

#: ../../library/sqlite3.rst:1659
msgid ""
"Read-only attribute that provides the SQLite database :class:`Connection` "
"belonging to the cursor.  A :class:`Cursor` object created by calling :meth:"
"`con.cursor() <Connection.cursor>` will have a :attr:`connection` attribute "
"that refers to *con*:"
msgstr ""
"カーソルが属する SQLite データベース :class:`Connection` を提供する読み取り専"
"用属性。 :meth:`con.cursor() <Connection.cursor>` と呼び出して作成した :"
"class:`Cursor` オブジェクトには、*con* を参照する :attr:`connection` 属性があ"
"ります:"

#: ../../library/sqlite3.rst:1664
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> cur = con.cursor()\n"
">>> cur.connection == con\n"
"True\n"
">>> con.close()"
msgstr ""

#: ../../library/sqlite3.rst:1674
msgid ""
"Read-only attribute that provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are ``None``."
msgstr ""
"最後のクエリの列(column)名を提供する読み取り専用属性。 Python DB API との互換"
"性を維持するために、各列ごとに 7 項目のタプルで、先頭の項目が列名、残りの6項"
"目が ``None`` です。"

#: ../../library/sqlite3.rst:1678
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr ""
"この属性は ``SELECT`` 文にマッチする行(row)が1つもなかった場合でもセットされ"
"ます。"

#: ../../library/sqlite3.rst:1682
msgid ""
"Read-only attribute that provides the row id of the last inserted row. It is "
"only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany` "
"or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is "
"``None``."
msgstr ""
"最後に挿入された行の行 ID (row id) を提供する読み取り専用属性。 :meth:"
"`execute`  で ``INSERT`` または ``REPLACE`` 文が成功した後にのみ更新されま"
"す。他のSQL文や、 :meth:`executemany` の後や、 :meth:`executescript` の後"
"や、 挿入が失敗した場合、 ``lastrowid`` の値は変更されません。``lastrowid`` "
"の初期値は ``None`` です。"

#: ../../library/sqlite3.rst:1690
msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr "``WITHOUT ROWID`` テーブルへの挿入(insert)は記録されません。"

#: ../../library/sqlite3.rst:1692
msgid "Added support for the ``REPLACE`` statement."
msgstr "``REPLACE`` 文のサポートが追加されました。"

#: ../../library/sqlite3.rst:1697
msgid ""
"Read-only attribute that provides the number of modified rows for "
"``INSERT``, ``UPDATE``, ``DELETE``, and ``REPLACE`` statements; is ``-1`` "
"for other statements, including :abbr:`CTE (Common Table Expression)` "
"queries. It is only updated by the :meth:`execute` and :meth:`executemany` "
"methods, after the statement has run to completion. This means that any "
"resulting rows must be fetched in order for :attr:`!rowcount` to be updated."
msgstr ""
"``INSERT`` や ``UPDATE`` や ``DELETE`` や ``REPLACE`` 文で変更された行数を提"
"供する読み取り専用属性。 :abbr:`CTE (共通テーブル式)` クエリを含む他のSQL文"
"は ``-1`` です。 :meth:`execute` と :meth:`executemany` メソッドのみにおい"
"て、 SQL文(statement)実行の完了後に更新されます。 なぜなら :attr:`!rowcount` "
"を更新するためには、結果の行を取得(fetch)しなければならないからです。"

#: ../../library/sqlite3.rst:1708
msgid ""
"Control how a row fetched from this :class:`!Cursor` is represented. If "
"``None``, a row is represented as a :class:`tuple`. Can be set to the "
"included :class:`sqlite3.Row`; or a :term:`callable` that accepts two "
"arguments, a :class:`Cursor` object and the :class:`!tuple` of row values, "
"and returns a custom object representing an SQLite row."
msgstr ""
"この :class:`カーソル <!Cursor>` から取得された行の表現方法を制御します。 "
"``None`` の場合、行は :class:`タプル <tuple>` として表されます。 :class:"
"`sqlite3.Row` に設定することもできます。 そしてまた、 :class:`Cursor` オブ"
"ジェクトと、 行の値の :class:`タプル <!tuple>` の、 2 つの引数を受け取り、 "
"SQLite の行(row)を表すカスタム・オブジェクトを返す、 :term:`呼び出し可能オブ"
"ジェクト <callable>` に設定することもできます。"

#: ../../library/sqlite3.rst:1715
msgid ""
"Defaults to what :attr:`Connection.row_factory` was set to when the :class:`!"
"Cursor` was created. Assigning to this attribute does not affect :attr:"
"`Connection.row_factory` of the parent connection."
msgstr ""
":class:`カーソル・オブジェクト <!Cursor>` の作成時に :attr:`Connection."
"row_factory` の値をこの属性のデフォルト値として設定します。この属性に割り当て"
"ても、親接続(parent connection)の :attr:`Connection.row_factory` には影響しま"
"せん。"

#: ../../library/sqlite3.rst:1731
msgid "Row objects"
msgstr "Row オブジェクト"

#: ../../library/sqlite3.rst:1735
msgid ""
"A :class:`!Row` instance serves as a highly optimized :attr:`~Connection."
"row_factory` for :class:`Connection` objects. It supports iteration, "
"equality testing, :func:`len`, and :term:`mapping` access by column name and "
"index."
msgstr ""
":class:`!Row` インスタンスは、 :class:`Connection` オブジェクトの、高度に最適"
"化された :attr:`~Connection.row_factory` の役割をします。 反復(iteration)や、"
"等しいかどうかのテスト(equality testing)や、 :func:`len` 関数や 、 列名"
"(column name)とインデックスによる :term:`マッピング <mapping>` のアクセスを、"
"サポートします。"

#: ../../library/sqlite3.rst:1740
msgid ""
"Two :class:`!Row` objects compare equal if they have identical column names "
"and values."
msgstr ""
"列名(column names)と値(values)が全く同一である 2 つの :class:`!Row`  オブジェ"
"クトを比較すると、等しいと見なされます。"

#: ../../library/sqlite3.rst:1747
msgid ""
"Return a :class:`list` of column names as :class:`strings <str>`. "
"Immediately after a query, it is the first member of each tuple in :attr:"
"`Cursor.description`."
msgstr ""
"列名(column names)の :class:`リスト <list>` を :class:`文字列 <str>` として返"
"します。 クエリの直後であれば、それは :attr:`Cursor.description` の各タプルの"
"最初のメンバーです。"

#: ../../library/sqlite3.rst:1751
msgid "Added support of slicing."
msgstr "スライスがサポートされました。"

#: ../../library/sqlite3.rst:1758
msgid "Blob objects"
msgstr "Blob オブジェクト"

#: ../../library/sqlite3.rst:1764
msgid ""
"A :class:`Blob` instance is a :term:`file-like object` that can read and "
"write data in an SQLite :abbr:`BLOB (Binary Large OBject)`. Call :func:"
"`len(blob) <len>` to get the size (number of bytes) of the blob. Use indices "
"and :term:`slices <slice>` for direct access to the blob data."
msgstr ""
":class:`Blob` インスタンスは、 SQLite の :abbr:`BLOB (Binary Large OBject)` "
"とデータを読み書きできる :term:`file-like object` です。 :func:`len(blob) "
"<len>` を呼び出して、 Blob のサイズ (バイト数) を取得します。 Blob データに直"
"接アクセスするには、インデックスと :term:`スライス <slice>` を使用します。"

#: ../../library/sqlite3.rst:1769
msgid ""
"Use the :class:`Blob` as a :term:`context manager` to ensure that the blob "
"handle is closed after use."
msgstr ""
":class:`Blob` を :term:`コンテキストマネージャ <context manager>` として使用"
"して、 使用後に Blob ハンドルが確実に閉じられるようにします。"

#: ../../library/sqlite3.rst:1772
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE test(blob_col blob)\")\n"
"con.execute(\"INSERT INTO test(blob_col) VALUES(zeroblob(13))\")\n"
"\n"
"# Write to our blob, using two write operations:\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    blob.write(b\"hello, \")\n"
"    blob.write(b\"world.\")\n"
"    # Modify the first and last bytes of our blob\n"
"    blob[0] = ord(\"H\")\n"
"    blob[-1] = ord(\"!\")\n"
"\n"
"# Read the contents of our blob\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    greeting = blob.read()\n"
"\n"
"print(greeting)  # outputs \"b'Hello, world!'\"\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:1800
msgid "Close the blob."
msgstr "Blob を閉じます。"

#: ../../library/sqlite3.rst:1802
msgid ""
"The blob will be unusable from this point onward.  An :class:`~sqlite3."
"Error` (or subclass) exception will be raised if any further operation is "
"attempted with the blob."
msgstr ""
"この時点から、 BLOB は使用できなくなります。 BLOB に対してさらに操作を試みる"
"と、 :class:`~sqlite3.Error` (またはそのサブクラスの) 例外を送出します。"

#: ../../library/sqlite3.rst:1808
msgid ""
"Read *length* bytes of data from the blob at the current offset position. If "
"the end of the blob is reached, the data up to :abbr:`EOF (End of File)` "
"will be returned.  When *length* is not specified, or is negative, :meth:"
"`~Blob.read` will read until the end of the blob."
msgstr ""
"BLOB の現在のオフセット位置から *length* バイトのデータを読み取り返ます。 "
"BLOB の現在のオフセット位置から末尾までの残りが *length* バイトよりも少ない場"
"合、末尾までのデータを読み取ります。 *length* が指定されていない場合、 または"
"負数の場合、 :meth:`~Blob.read` は BLOB の現在のオフセット位置から末尾までの"
"データを読み取ります。"

#: ../../library/sqlite3.rst:1816
msgid ""
"Write *data* to the blob at the current offset.  This function cannot change "
"the blob length.  Writing beyond the end of the blob will raise :exc:"
"`ValueError`."
msgstr ""
"BLOB の現在のオフセット位置から *data* を書き込みます。 この関数では BLOB の"
"長さを変更できません。 BLOB の末尾を超えて書き込もうとすると :exc:"
"`ValueError` を送出します。"

#: ../../library/sqlite3.rst:1822
msgid "Return the current access position of the blob."
msgstr "BLOBの現在のオフセット位置(current access position)を返します。"

#: ../../library/sqlite3.rst:1826
msgid ""
"Set the current access position of the blob to *offset*.  The *origin* "
"argument defaults to :const:`os.SEEK_SET` (absolute blob positioning). Other "
"values for *origin* are :const:`os.SEEK_CUR` (seek relative to the current "
"position) and :const:`os.SEEK_END` (seek relative to the blob’s end)."
msgstr ""

#: ../../library/sqlite3.rst:1834
msgid "PrepareProtocol objects"
msgstr "PrepareProtocol オブジェクト"

#: ../../library/sqlite3.rst:1838
msgid ""
"The PrepareProtocol type's single purpose is to act as a :pep:`246` style "
"adaption protocol for objects that can :ref:`adapt themselves <sqlite3-"
"conform>` to :ref:`native SQLite types <sqlite3-types>`."
msgstr ""
"PrepareProtocol 型の唯一の目的は、 :ref:`SQLite でネイティブにサポートされて"
"いる型 <sqlite3-types>` に :ref:`オブジェクト自身で適合(adapt) <sqlite3-"
"conform>` できるオブジェクトの  :pep:`246` スタイルの適合プロトコルとして機能"
"することです。"

#: ../../library/sqlite3.rst:1846
msgid "Exceptions"
msgstr "例外"

#: ../../library/sqlite3.rst:1848
msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr "例外の階層は DB-API 2.0 (:pep:`249`) で定義されています。"

#: ../../library/sqlite3.rst:1852
msgid ""
"This exception is not currently raised by the :mod:`!sqlite3` module, but "
"may be raised by applications using :mod:`!sqlite3`, for example if a user-"
"defined function truncates data while inserting. ``Warning`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"この例外は、現在 :mod:`!sqlite3` モジュールでは送出しませんが、ユーザー定義関"
"数が挿入処理中にデータを切り捨てる場合など、:mod:`!sqlite3` を使用するアプリ"
"ケーションによって送出されるる可能性があります。 ``Warning`` は :exc:"
"`Exception` のサブクラスです。"

#: ../../library/sqlite3.rst:1859
msgid ""
"The base class of the other exceptions in this module. Use this to catch all "
"errors with one single :keyword:`except` statement. ``Error`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"このモジュールの他の例外の基底となるクラス。 これを使用すると、1 つの :"
"keyword:`except` 文ですべてのエラーをキャッチできます。 ``Error`` は :exc:"
"`Exception` のサブクラスです。"

#: ../../library/sqlite3.rst:1863
msgid ""
"If the exception originated from within the SQLite library, the following "
"two attributes are added to the exception:"
msgstr ""
"例外が SQLite ライブラリ内で発生した場合、 以下の 2 つの属性が例外に追加され"
"ます:"

#: ../../library/sqlite3.rst:1868
msgid ""
"The numeric error code from the `SQLite API <https://sqlite.org/rescode."
"html>`_"
msgstr ""
"`SQLite API <https://sqlite.org/rescode.html>`_ からの数値エラー・コード"

#: ../../library/sqlite3.rst:1875
msgid ""
"The symbolic name of the numeric error code from the `SQLite API <https://"
"sqlite.org/rescode.html>`_"
msgstr ""
"`SQLite API <https://sqlite.org/rescode.html>`_ からの数値エラー・コードの記"
"号名"

#: ../../library/sqlite3.rst:1882
msgid ""
"Exception raised for misuse of the low-level SQLite C API. In other words, "
"if this exception is raised, it probably indicates a bug in the :mod:`!"
"sqlite3` module. ``InterfaceError`` is a subclass of :exc:`Error`."
msgstr ""
"低レベルの SQLite C API の誤用により送出される例外。 つまり、この例外が送出さ"
"れた場合、おそらく :mod:`!sqlite3` モジュールのバグを示しています。 "
"``InterfaceError`` は :exc:`Error` のサブクラスです。"

#: ../../library/sqlite3.rst:1889
msgid ""
"Exception raised for errors that are related to the database. This serves as "
"the base exception for several types of database errors. It is only raised "
"implicitly through the specialised subclasses. ``DatabaseError`` is a "
"subclass of :exc:`Error`."
msgstr ""
"データベースに関連するエラーに対して送出される例外。 これは、いくつかの種類の"
"データベース・エラーの基底の例外として機能します。 これを特殊化(specialise)し"
"たサブクラスを介して暗黙的にのみ送出されます。 ``DatabaseError`` は :exc:"
"`Error` のサブクラスです。"

#: ../../library/sqlite3.rst:1896
msgid ""
"Exception raised for errors caused by problems with the processed data, like "
"numeric values out of range, and strings which are too long. ``DataError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""
"範囲外の数値や長すぎる文字列など、処理されたデータの問題によって発生したエ"
"ラーに対して送出される例外。 ``DataError`` は :exc:`DatabaseError` のサブクラ"
"スです。"

#: ../../library/sqlite3.rst:1902
msgid ""
"Exception raised for errors that are related to the database's operation, "
"and not necessarily under the control of the programmer. For example, the "
"database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"データベースの操作に関連し、必ずしもプログラマの制御下にないエラーに対して発"
"生する例外。 たとえば、データベース・パスが見つからないとか、トランザクション"
"を処理できませんでした等。 ``OperationalError`` は :exc:`DatabaseError` のサ"
"ブクラスです。"

#: ../../library/sqlite3.rst:1910
msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr ""
"データベースの参照整合性が影響を受ける場合に発生する例外。 たとえば外部キーの"
"チェック(foreign key check)が失敗したとき。 :exc:`DatabaseError` のサブクラス"
"です。"

#: ../../library/sqlite3.rst:1915
msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"SQLite が内部エラーに遭遇したときに発生する例外。 これが送出された場合、ラン"
"タイム SQLite ライブラリに問題があることを示している可能性があります。 "
"``InternalError`` は :exc:`DatabaseError` のサブクラスです。"

#: ../../library/sqlite3.rst:1922
msgid ""
"Exception raised for :mod:`!sqlite3` API programming errors, for example "
"supplying the wrong number of bindings to a query, or trying to operate on a "
"closed :class:`Connection`. ``ProgrammingError`` is a subclass of :exc:"
"`DatabaseError`."
msgstr ""
":mod:`!sqlite3` API プログラミング・エラーに対して送出される例外。たとえば、"
"クエリに間違った数のバインディング(結び付け)を指定したり、閉じた後の :class:"
"`Connection` を操作しようとしたりしたとき。 ``ProgrammingError`` は :exc:"
"`DatabaseError` のサブクラスです。"

#: ../../library/sqlite3.rst:1929
msgid ""
"Exception raised in case a method or database API is not supported by the "
"underlying SQLite library. For example, setting *deterministic* to ``True`` "
"in :meth:`~Connection.create_function`, if the underlying SQLite library "
"does not support deterministic functions. ``NotSupportedError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""
"メソッドまたはデータベース API が 背後の SQLite ライブラリでサポートしていな"
"い場合に送出される例外。たとえば、背後の SQLite ライブラリが決定論的関数"
"(deterministic functions)をサポートしていない場合に、:meth:`~Connection."
"create_function` で *deterministic* を ``True`` に設定したとき。 "
"``NotSupportedError``  は :exc:`DatabaseError` のサブクラスです。"

#: ../../library/sqlite3.rst:1939
msgid "SQLite and Python types"
msgstr "SQLite と Python の型"

#: ../../library/sqlite3.rst:1941
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr ""
"SQLite は以下の型をネイティブにサポートします: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``。"

#: ../../library/sqlite3.rst:1944
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr "したがって、次の Python の型は問題なく SQLite に送り込めます:"

#: ../../library/sqlite3.rst:1947 ../../library/sqlite3.rst:1964
msgid "Python type"
msgstr "Python の型"

#: ../../library/sqlite3.rst:1947 ../../library/sqlite3.rst:1964
msgid "SQLite type"
msgstr "SQLite の型"

#: ../../library/sqlite3.rst:1949 ../../library/sqlite3.rst:1966
msgid "``None``"
msgstr "``None``"

#: ../../library/sqlite3.rst:1949 ../../library/sqlite3.rst:1966
msgid "``NULL``"
msgstr "``NULL``"

#: ../../library/sqlite3.rst:1951 ../../library/sqlite3.rst:1968
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/sqlite3.rst:1951 ../../library/sqlite3.rst:1968
msgid "``INTEGER``"
msgstr "``INTEGER``"

#: ../../library/sqlite3.rst:1953 ../../library/sqlite3.rst:1970
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/sqlite3.rst:1953 ../../library/sqlite3.rst:1970
msgid "``REAL``"
msgstr "``REAL``"

#: ../../library/sqlite3.rst:1955
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/sqlite3.rst:1955 ../../library/sqlite3.rst:1972
msgid "``TEXT``"
msgstr "``TEXT``"

#: ../../library/sqlite3.rst:1957 ../../library/sqlite3.rst:1975
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/sqlite3.rst:1957 ../../library/sqlite3.rst:1975
msgid "``BLOB``"
msgstr "``BLOB``"

#: ../../library/sqlite3.rst:1961
msgid "This is how SQLite types are converted to Python types by default:"
msgstr "SQLite の型から Python の型へのデフォルトでの変換は以下の通りです:"

#: ../../library/sqlite3.rst:1972
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr ""
":attr:`~Connection.text_factory` に依存する。デフォルトでは :class:`str` 。"

#: ../../library/sqlite3.rst:1978
msgid ""
"The type system of the :mod:`!sqlite3` module is extensible in two ways: you "
"can store additional Python types in an SQLite database via :ref:`object "
"adapters <sqlite3-adapters>`, and you can let the :mod:`!sqlite3` module "
"convert SQLite types to Python types via :ref:`converters <sqlite3-"
"converters>`."
msgstr ""
":mod:`!sqlite3` モジュールの型システムは 2 つの方法で拡張可能です。 :ref:`オ"
"ブジェクト適合関数(adapter) <sqlite3-adapters>` を介して SQLite データベース"
"に追加の Python 型を格納できます。 または、 :ref:`変換関数(converter) "
"<sqlite3-converters>` を介して :mod:`!sqlite3` モジュールが SQLite 型を "
"Python 型に変換できます。"

#: ../../library/sqlite3.rst:1988
msgid "Default adapters and converters (deprecated)"
msgstr ""
"デフォルトの適合関数(adapters)とデフォルトの変換関数(converters)(非推奨)"

#: ../../library/sqlite3.rst:1992
msgid ""
"The default adapters and converters are deprecated as of Python 3.12. "
"Instead, use the :ref:`sqlite3-adapter-converter-recipes` and tailor them to "
"your needs."
msgstr ""
"デフォルトの適合関数(adapters)とデフォルトの変換関数(converters)は、 Python "
"3.12 以降非推奨になりました。代わりに、 :ref:`sqlite3-adapter-converter-"
"recipes` を利用して、あなたのニーズに合わせて仕立てて下さい。"

#: ../../library/sqlite3.rst:1996
msgid "The deprecated default adapters and converters consist of:"
msgstr ""
"非推奨の、デフォルトの適合関数(adapters)とデフォルトの変換関数(converters)は"
"以下のもので構成されています:"

#: ../../library/sqlite3.rst:1998
msgid ""
"An adapter for :class:`datetime.date` objects to :class:`strings <str>` in "
"`ISO 8601`_ format."
msgstr ""
":class:`datetime.date` オブジェクトを `ISO 8601`_ 形式の :class:`文字列 "
"<str>` にする適合関数(adapter)。"

#: ../../library/sqlite3.rst:2000
msgid ""
"An adapter for :class:`datetime.datetime` objects to strings in ISO 8601 "
"format."
msgstr ""
":class:`datetime.datetime` オブジェクトを ISO 8601 形式の文字列にする適合関数"
"(adapter)。"

#: ../../library/sqlite3.rst:2002
msgid ""
"A converter for :ref:`declared <sqlite3-converters>` \"date\" types to :"
"class:`datetime.date` objects."
msgstr ""
"\"date\" と :ref:`宣言された <sqlite3-converters>` 型を :class:`datetime."
"date` オブジェクトにする変換関数(converter)。"

#: ../../library/sqlite3.rst:2004
msgid ""
"A converter for declared \"timestamp\" types to :class:`datetime.datetime` "
"objects. Fractional parts will be truncated to 6 digits (microsecond "
"precision)."
msgstr ""
"\"timestamp\" と宣言された型を :class:`datetime.datetime` オブジェクトにする"
"変換関数(converter)。小数部分は 6 桁 (マイクロ秒の精度) に切り捨てられます。"

#: ../../library/sqlite3.rst:2010
msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""
"デフォルトの \"timestamp\" 変換関数は、データベース内の UTC オフセットを無視"
"し、常に素朴(naive)な :class:`datetime.datetime` オブジェクトを返します。 "
"timestamp で UTC オフセットを保持するには、変換関数を無効のままにするか、ある"
"いは、オフセット対応の変換関数を :func:`register_converter` に登録します。"

#: ../../library/sqlite3.rst:2023
msgid "Command-line interface"
msgstr "コマンドライン・インターフェース"

#: ../../library/sqlite3.rst:2025
msgid ""
"The :mod:`!sqlite3` module can be invoked as a script, using the "
"interpreter's :option:`-m` switch, in order to provide a simple SQLite "
"shell. The argument signature is as follows::"
msgstr ""
":mod:`!sqlite3` モジュールは、単純な SQLite シェルを提供するために、インタプ"
"リタで :option:`-m` スイッチを使用してスクリプトとして呼び出すことができま"
"す。引数は以下のとおりです::"

#: ../../library/sqlite3.rst:2030
msgid "python -m sqlite3 [-h] [-v] [filename] [sql]"
msgstr ""

#: ../../library/sqlite3.rst:2032
msgid "Type ``.quit`` or CTRL-D to exit the shell."
msgstr "``.quit`` または CTRL-D を入力するとシェルを終了(exit)します。"

#: ../../library/sqlite3.rst:2038
msgid "Print CLI help."
msgstr "CLI ヘルプを表示。"

#: ../../library/sqlite3.rst:2042
msgid "Print underlying SQLite library version."
msgstr "背後の SQLite ライブラリのバージョンを出力します。"

#: ../../library/sqlite3.rst:2050
msgid "How-to guides"
msgstr "ハウツー・ガイド"

#: ../../library/sqlite3.rst:2055
msgid "How to use placeholders to bind values in SQL queries"
msgstr "プレースホルダを使用して SQL クエリに値を結び付ける方法"

#: ../../library/sqlite3.rst:2057
msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to `SQL injection attacks`_. For example, an attacker can simply "
"close the single quote and inject ``OR TRUE`` to select all rows::"
msgstr ""
"たいてい、SQL 操作は Python 変数の値を使う必要があります。しかし、 Python の"
"文字列操作を使用してクエリを組み立てるのはSQLインジェクション攻撃(`SQL "
"injection attacks`_)に対して脆弱なので注意が必要です。たとえば、攻撃者は以下"
"のように単純にシングルクォートを閉じて ``OR TRUE`` を挿入してすべての行を選択"
"できます::"

#: ../../library/sqlite3.rst:2062
msgid ""
">>> # Never do this -- insecure!\n"
">>> symbol = input()\n"
"' OR TRUE; --\n"
">>> sql = \"SELECT * FROM stocks WHERE symbol = '%s'\" % symbol\n"
">>> print(sql)\n"
"SELECT * FROM stocks WHERE symbol = '' OR TRUE; --'\n"
">>> cur.execute(sql)"
msgstr ""

#: ../../library/sqlite3.rst:2070
msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the "
"second argument of the cursor's :meth:`~Cursor.execute` method."
msgstr ""
"代わりに、DB-API のパラメータ割り当てを使います。クエリ文字列にPythonの変数を"
"挿入するには、クエリ文字列中でプレースホルダを使用し、 かつ、 カーソルの :"
"meth:`~Cursor.execute` メソッドの 2 番目の引数にPythonの変数を値の :class:`タ"
"プル <tuple>` として指定することにより、 実際の値をクエリに割り当てます。"

#: ../../library/sqlite3.rst:2075
msgid ""
"An SQL statement may use one of two kinds of placeholders: question marks "
"(qmark style) or named placeholders (named style). For the qmark style, "
"*parameters* must be a :term:`sequence` whose length must match the number "
"of placeholders, or a :exc:`ProgrammingError` is raised. For the named "
"style, *parameters* must be an instance of a :class:`dict` (or a subclass), "
"which must contain keys for all named parameters; any extra items are "
"ignored. Here's an example of both styles:"
msgstr ""
"SQL 文では、疑問符 (qmark スタイル) または名前付きプレースホルダー (名前付き"
"スタイル) の 2 種類のプレースホルダーのいずれかを使用できます。 qmark スタイ"
"ルの場合、*parameters* は、 :term:`シーケンス <sequence>` でなければならず、"
"シーケンスの長さがプレースホルダーの数と一致する必要があります。そうでなけれ"
"ば、 :exc:`ProgrammingError` を送出します。名前付きスタイルの場合、 "
"*parameters* は :class:`dict` (またはそのサブクラス) のインスタンスである必要"
"があり、すべての名前付きパラメーターのキーが含まれている必要があります。余分"
"な項目は無視されます。両方のスタイルの例を以下に示します。"

#: ../../library/sqlite3.rst:2086
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"\n"
"# This is the named style used with executemany():\n"
"data = (\n"
"    {\"name\": \"C\", \"year\": 1972},\n"
"    {\"name\": \"Fortran\", \"year\": 1957},\n"
"    {\"name\": \"Python\", \"year\": 1991},\n"
"    {\"name\": \"Go\", \"year\": 2009},\n"
")\n"
"cur.executemany(\"INSERT INTO lang VALUES(:name, :year)\", data)\n"
"\n"
"# This is the qmark style used in a SELECT query:\n"
"params = (1972,)\n"
"cur.execute(\"SELECT * FROM lang WHERE first_appeared = ?\", params)\n"
"print(cur.fetchall())\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2113
msgid ""
":pep:`249` numeric placeholders are *not* supported. If used, they will be "
"interpreted as named placeholders."
msgstr ""
":pep:`249` numeric プレースホルダは *サポートされていません* 。 使用すると、"
"名前付きプレースホルダとして解釈されます。"

#: ../../library/sqlite3.rst:2120
msgid "How to adapt custom Python types to SQLite values"
msgstr "カスタム Python 型を SQLite 値に適合させる方法"

#: ../../library/sqlite3.rst:2122
msgid ""
"SQLite supports only a limited set of data types natively. To store custom "
"Python types in SQLite databases, *adapt* them to one of the :ref:`Python "
"types SQLite natively understands <sqlite3-types>`."
msgstr ""
"SQLite は、 限られたデータ型のみをネイティブにサポートします。 カスタム "
"Python 型を SQLite データベースに保存するには、 :ref:`SQLite がネイティブに理"
"解できる Python 型 <sqlite3-types>` のいずれかに *適合* (adapt)させます。"

#: ../../library/sqlite3.rst:2126
msgid ""
"There are two ways to adapt Python objects to SQLite types: letting your "
"object adapt itself, or using an *adapter callable*. The latter will take "
"precedence above the former. For a library that exports a custom type, it "
"may make sense to enable that type to adapt itself. As an application "
"developer, it may make more sense to take direct control by registering "
"custom adapter functions."
msgstr ""
"Python オブジェクトを SQLite の型に適合させる方法は 2 つあります。それは、オ"
"ブジェクト自体を適合させる方法と、 *adapter callable* を使用する方法です。 後"
"者は前者よりも優先されます。 カスタム型をエクスポートするライブラリの場合、 "
"その型がそれ自体を適合させる事ができるようにすることが理にかなっている場合が"
"あります。 アプリケーション開発者としては、カスタム適合関数を登録して直接制御"
"する方が理にかなっている場合もあります。"

#: ../../library/sqlite3.rst:2138
msgid "How to write adaptable objects"
msgstr "適合可能オブジェクトの書き方"

#: ../../library/sqlite3.rst:2140
msgid ""
"Suppose we have a :class:`!Point` class that represents a pair of "
"coordinates, ``x`` and ``y``, in a Cartesian coordinate system. The "
"coordinate pair will be stored as a text string in the database, using a "
"semicolon to separate the coordinates. This can be implemented by adding a "
"``__conform__(self, protocol)`` method which returns the adapted value. The "
"object passed to *protocol* will be of type :class:`PrepareProtocol`."
msgstr ""
"直交座標系(Cartesian coordinate system)で ``x`` と ``y`` のペアで座標を表"
"す、 :class:`!Point` クラスがあるとします。 この ``x`` と ``y`` のペアはセミ"
"コロンで区切られたテキスト文字列としてデータベースに保存されます。 これは、適"
"合した値を返す ``__conform__(self, protocol)`` メソッドを追加することで実装で"
"きます。 *protocol*  に渡されるオブジェクトは、 :class:`PrepareProtocol` 型に"
"なります。"

#: ../../library/sqlite3.rst:2148
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __conform__(self, protocol):\n"
"        if protocol is sqlite3.PrepareProtocol:\n"
"            return f\"{self.x};{self.y}\"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(4.0, -3.2),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2172
msgid "How to register adapter callables"
msgstr "適合用呼び出し可能オブジェクト(adapter callables)の登録方法"

#: ../../library/sqlite3.rst:2174
msgid ""
"The other possibility is to create a function that converts the Python "
"object to an SQLite-compatible type. This function can then be registered "
"using :func:`register_adapter`."
msgstr ""
"別の策としては、Python オブジェクトを SQLite 互換の型に変換する関数を作成する"
"ことが挙げられます。 この関数は、 :func:`register_adapter` を使用して登録でき"
"ます。"

#: ../../library/sqlite3.rst:2178
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(1.0, 2.5),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2205
msgid "How to convert SQLite values to custom Python types"
msgstr "SQLite 値をカスタム Python 型に変換する方法"

#: ../../library/sqlite3.rst:2207
msgid ""
"Writing an adapter lets you convert *from* custom Python types *to* SQLite "
"values. To be able to convert *from* SQLite values *to* custom Python types, "
"we use *converters*."
msgstr ""
"適合関数(adapter)を使用すると、カスタム Python 型から SQLite 値に変換できま"
"す。SQLite 値 から カスタム Python 型に変換できるようにするためには、 *変換関"
"数* (converters)を使用します。"

#: ../../library/sqlite3.rst:2212
msgid ""
"Let's go back to the :class:`!Point` class. We stored the x and y "
"coordinates separated via semicolons as strings in SQLite."
msgstr ""
"それでは :class:`!Point` クラスの話に戻るとしましょう。 先程は x 座標と y 座"
"標をセミコロンで区切られた文字列として SQLite に格納しました。"

#: ../../library/sqlite3.rst:2215
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`!Point` object from it."
msgstr ""
"まず、 文字列をパラメーターとして受け取り、そこから :class:`!Point` オブジェ"
"クトを構築する変換関数を定義します。"

#: ../../library/sqlite3.rst:2220
msgid ""
"Converter functions are **always** passed a :class:`bytes` object, no matter "
"the underlying SQLite data type."
msgstr ""
"変換関数には、基になる SQLite データ型に関係なく、 **常に** :class:`bytes` オ"
"ブジェクトで渡されます。"

#: ../../library/sqlite3.rst:2223
msgid ""
"def convert_point(s):\n"
"    x, y = map(float, s.split(b\";\"))\n"
"    return Point(x, y)"
msgstr ""

#: ../../library/sqlite3.rst:2229
msgid ""
"We now need to tell :mod:`!sqlite3` when it should convert a given SQLite "
"value. This is done when connecting to a database, using the *detect_types* "
"parameter of :func:`connect`. There are three options:"
msgstr ""
"与えられた SQLite 値をどの時点で変換すべきかを :mod:`!sqlite3` に伝える必要が"
"あります。これは、 :func:`connect` の *detect_types* パラメータを使用して、"
"データベースに接続する際に行います。 以下の 3 つの選択肢があります:"

#: ../../library/sqlite3.rst:2233
msgid "Implicit: set *detect_types* to :const:`PARSE_DECLTYPES`"
msgstr "暗黙的: *detect_types* に :const:`PARSE_DECLTYPES` と設定。"

#: ../../library/sqlite3.rst:2234
msgid "Explicit: set *detect_types* to :const:`PARSE_COLNAMES`"
msgstr "明示的: *detect_types* に :const:`PARSE_COLNAMES` と設定。"

#: ../../library/sqlite3.rst:2235
msgid ""
"Both: set *detect_types* to ``sqlite3.PARSE_DECLTYPES | sqlite3."
"PARSE_COLNAMES``. Column names take precedence over declared types."
msgstr ""
"両方: *detect_types* に ``sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES`` "
"を設定。列名での指定は、宣言時の型よりも優先されます。"

#: ../../library/sqlite3.rst:2239
msgid "The following example illustrates the implicit and explicit approaches:"
msgstr ""
"以下の例では、暗黙的なアプローチと明示的なアプローチについて表しています:"

#: ../../library/sqlite3.rst:2241
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __repr__(self):\n"
"        return f\"Point({self.x}, {self.y})\"\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"def convert_point(s):\n"
"    x, y = list(map(float, s.split(b\";\")))\n"
"    return Point(x, y)\n"
"\n"
"# Register the adapter and converter\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"sqlite3.register_converter(\"point\", convert_point)\n"
"\n"
"# 1) Parse using declared types\n"
"p = Point(4.0, -3.2)\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_DECLTYPES)\n"
"cur = con.execute(\"CREATE TABLE test(p point)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute(\"SELECT p FROM test\")\n"
"print(\"with declared types:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()\n"
"\n"
"# 2) Parse using column names\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_COLNAMES)\n"
"cur = con.execute(\"CREATE TABLE test(p)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute('SELECT p AS \"p [point]\" FROM test')\n"
"print(\"with column names:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2292
msgid "Adapter and converter recipes"
msgstr "適合関数と変換関数のレシピ集"

#: ../../library/sqlite3.rst:2294
msgid "This section shows recipes for common adapters and converters."
msgstr "この節では一般的な適合関数と変換関数のレシピを紹介します。"

#: ../../library/sqlite3.rst:2296
msgid ""
"import datetime\n"
"import sqlite3\n"
"\n"
"def adapt_date_iso(val):\n"
"    \"\"\"Adapt datetime.date to ISO 8601 date.\"\"\"\n"
"    return val.isoformat()\n"
"\n"
"def adapt_datetime_iso(val):\n"
"    \"\"\"Adapt datetime.datetime to timezone-naive ISO 8601 date.\"\"\"\n"
"    return val.isoformat()\n"
"\n"
"def adapt_datetime_epoch(val):\n"
"    \"\"\"Adapt datetime.datetime to Unix timestamp.\"\"\"\n"
"    return int(val.timestamp())\n"
"\n"
"sqlite3.register_adapter(datetime.date, adapt_date_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_epoch)\n"
"\n"
"def convert_date(val):\n"
"    \"\"\"Convert ISO 8601 date to datetime.date object.\"\"\"\n"
"    return datetime.date.fromisoformat(val.decode())\n"
"\n"
"def convert_datetime(val):\n"
"    \"\"\"Convert ISO 8601 datetime to datetime.datetime object.\"\"\"\n"
"    return datetime.datetime.fromisoformat(val.decode())\n"
"\n"
"def convert_timestamp(val):\n"
"    \"\"\"Convert Unix epoch timestamp to datetime.datetime object.\"\"\"\n"
"    return datetime.datetime.fromtimestamp(int(val))\n"
"\n"
"sqlite3.register_converter(\"date\", convert_date)\n"
"sqlite3.register_converter(\"datetime\", convert_datetime)\n"
"sqlite3.register_converter(\"timestamp\", convert_timestamp)"
msgstr ""

#: ../../library/sqlite3.rst:2356
msgid "How to use connection shortcut methods"
msgstr "接続(connection)ショートカット・メソッドの使い方"

#: ../../library/sqlite3.rst:2358
msgid ""
"Using the :meth:`~Connection.execute`, :meth:`~Connection.executemany`, and :"
"meth:`~Connection.executescript` methods of the :class:`Connection` class, "
"your code can be written more concisely because you don't have to create the "
"(often superfluous) :class:`Cursor` objects explicitly. Instead, the :class:"
"`Cursor` objects are created implicitly and these shortcut methods return "
"the cursor objects. This way, you can execute a ``SELECT`` statement and "
"iterate over it directly using only a single call on the :class:`Connection` "
"object."
msgstr ""
":class:`Connection` クラスのメソッド :meth:`~Connection.execute` と :meth:"
"`~Connection.executemany` と :meth:`~Connection.executescript` を使うこと"
"で、 (しばしば余計な) :class:`Cursor` オブジェクトをわざわざ作り出さずに済む"
"ので、コードをより簡潔に書くことができます。 :class:`Cursor` オブジェクトは暗"
"黙裡に生成され、ショートカット・メソッドの戻り値として受け取ることができま"
"す。この方法を使えば、 ``SELECT`` 文を実行してその結果について反復すること"
"が、 :class:`Connection` オブジェクトに対する呼び出し一つで行なえます。"

#: ../../library/sqlite3.rst:2367
msgid ""
"# Create and fill the table.\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"data = [\n"
"    (\"C++\", 1985),\n"
"    (\"Objective-C\", 1984),\n"
"]\n"
"con.executemany(\"INSERT INTO lang(name, first_appeared) VALUES(?, ?)\", "
"data)\n"
"\n"
"# Print the table contents\n"
"for row in con.execute(\"SELECT name, first_appeared FROM lang\"):\n"
"    print(row)\n"
"\n"
"print(\"I just deleted\", con.execute(\"DELETE FROM lang\").rowcount, "
"\"rows\")\n"
"\n"
"# close() is not a shortcut method and it's not called automatically;\n"
"# the connection object should be closed manually\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2399
msgid "How to use the connection context manager"
msgstr "接続(connection)コンテキストマネージャの使い方"

#: ../../library/sqlite3.rst:2401
msgid ""
"A :class:`Connection` object can be used as a context manager that "
"automatically commits or rolls back open transactions when leaving the body "
"of the context manager. If the body of the :keyword:`with` statement "
"finishes without exceptions, the transaction is committed. If this commit "
"fails, or if the body of the ``with`` statement raises an uncaught "
"exception, the transaction is rolled back. If :attr:`~Connection.autocommit` "
"is ``False``, a new transaction is implicitly opened after committing or "
"rolling back."
msgstr ""
":class:`Connection` オブジェクトは、コンテキスト・マネージャーとして使用で"
"き、コンテキスト・マネージャーとして使用すると、 :keyword:`with` ブロックを離"
"れるときに、開いているトランザクションを自動的にコミットまたはロールバックし"
"ます。 :keyword:`with` 文のブロックが例外なく終了すると、トランザクションはコ"
"ミットされます。このコミットが失敗した、または、 ``with`` 文のブロックで"
"キャッチされなかった例外が発生した場合、トランザクションはロールバックされま"
"す。 :attr:`~Connection.autocommit` が ``False`` の場合、コミット後またはロー"
"ルバック後に新しいトランザクションが暗黙に開かれます。"

#: ../../library/sqlite3.rst:2412
msgid ""
"If there is no open transaction upon leaving the body of the ``with`` "
"statement, or if :attr:`~Connection.autocommit` is ``True``, the context "
"manager does nothing."
msgstr ""
"``with`` 文のブロックを離れるときに開いているトランザクションがない、また"
"は、 :attr:`~Connection.autocommit` が ``True`` の場合、コンテキスト・マネー"
"ジャは何も行いません。"

#: ../../library/sqlite3.rst:2417
msgid ""
"The context manager neither implicitly opens a new transaction nor closes "
"the connection. If you need a closing context manager, consider using :meth:"
"`contextlib.closing`."
msgstr ""

#: ../../library/sqlite3.rst:2421
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(id INTEGER PRIMARY KEY, name VARCHAR "
"UNIQUE)\")\n"
"\n"
"# Successful, con.commit() is called automatically afterwards\n"
"with con:\n"
"    con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"\n"
"# con.rollback() is called after the with block finishes with an exception,\n"
"# the exception is still raised and must be caught\n"
"try:\n"
"    with con:\n"
"        con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"except sqlite3.IntegrityError:\n"
"    print(\"couldn't add Python twice\")\n"
"\n"
"# Connection object used as context manager only commits or rollbacks "
"transactions,\n"
"# so the connection object should be closed manually\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2451
msgid "How to work with SQLite URIs"
msgstr "SQLite URI の操作方法"

#: ../../library/sqlite3.rst:2453
msgid "Some useful URI tricks include:"
msgstr "URI の小技をいくつか紹介します:"

#: ../../library/sqlite3.rst:2455
msgid "Open a database in read-only mode:"
msgstr "データベースを読み取り専用で開きます:"

#: ../../library/sqlite3.rst:2457
msgid ""
">>> con = sqlite3.connect(\"file:tutorial.db?mode=ro\", uri=True)\n"
">>> con.execute(\"CREATE TABLE readonly(data)\")\n"
"Traceback (most recent call last):\n"
"OperationalError: attempt to write a readonly database"
msgstr ""

#: ../../library/sqlite3.rst:2464
msgid ""
"Do not implicitly create a new database file if it does not already exist; "
"will raise :exc:`~sqlite3.OperationalError` if unable to create a new file:"
msgstr ""
"まだ存在しない場合、新しいデータベース・ファイルを暗黙に作成しません。なお、"
"新しいファイルが作成できない場合には :exc:`~sqlite3.OperationalError` が送出"
"されます:"

#: ../../library/sqlite3.rst:2467
msgid ""
">>> con = sqlite3.connect(\"file:nosuchdb.db?mode=rw\", uri=True)\n"
"Traceback (most recent call last):\n"
"OperationalError: unable to open database file"
msgstr ""

#: ../../library/sqlite3.rst:2474
msgid "Create a shared named in-memory database:"
msgstr "共有の名前付きインメモリ・データベースを作成します:"

#: ../../library/sqlite3.rst:2476
msgid ""
"db = \"file:mem1?mode=memory&cache=shared\"\n"
"con1 = sqlite3.connect(db, uri=True)\n"
"con2 = sqlite3.connect(db, uri=True)\n"
"with con1:\n"
"    con1.execute(\"CREATE TABLE shared(data)\")\n"
"    con1.execute(\"INSERT INTO shared VALUES(28)\")\n"
"res = con2.execute(\"SELECT data FROM shared\")\n"
"assert res.fetchone() == (28,)\n"
"\n"
"con1.close()\n"
"con2.close()"
msgstr ""

#: ../../library/sqlite3.rst:2490
msgid ""
"More information about this feature, including a list of parameters, can be "
"found in the `SQLite URI documentation`_."
msgstr ""
"パラメータのリストを含む、この機能の詳細については、 `SQLite URI "
"documentation`_ を参照してください。"

#: ../../library/sqlite3.rst:2499
msgid "How to create and use row factories"
msgstr "行工場(row factories)の作成方法と使用方法"

#: ../../library/sqlite3.rst:2501
msgid ""
"By default, :mod:`!sqlite3` represents each row as a :class:`tuple`. If a :"
"class:`!tuple` does not suit your needs, you can use the :class:`sqlite3."
"Row` class or a custom :attr:`~Cursor.row_factory`."
msgstr ""
"デフォルトでは、 :mod:`!sqlite3` は各行(row)を :class:`タプル <tuple>` として"
"表します。 :class:`タプル <!tuple>` があなたのニーズと合わない場合は、 :"
"class:`sqlite3.Row` クラスまたはカスタム :attr:`~Cursor.row_factory` を使用で"
"きます。"

#: ../../library/sqlite3.rst:2506
msgid ""
"While :attr:`!row_factory` exists as an attribute both on the :class:"
"`Cursor` and the :class:`Connection`, it is recommended to set :class:"
"`Connection.row_factory`, so all cursors created from the connection will "
"use the same row factory."
msgstr ""
":attr:`!row_factory` は :class:`Cursor` と :class:`Connection` の両方に属性と"
"して存在しますが、 その接続(connection)から作成されたすべてのカーソルが同一の"
"行工場(row factory)を使用するようにするために、 :class:`Connection."
"row_factory` を設定することをお勧めします。"

#: ../../library/sqlite3.rst:2511
msgid ""
":class:`!Row` provides indexed and case-insensitive named access to columns, "
"with minimal memory overhead and performance impact over a :class:`!tuple`. "
"To use :class:`!Row` as a row factory, assign it to the :attr:`!row_factory` "
"attribute:"
msgstr ""
":class:`!Row` は、 :class:`タプル <!tuple>` に対してメモリ・オーバーヘッドと"
"パフォーマンスへの影響を最小限に抑えながら、列(row)へのインデックスによるアク"
"セスと、列への(大文字と小文字を区別しない)名前によるアクセスを提供します。 :"
"class:`!Row` を行工場(row factory)として使用するには、 :attr:`!row_factory` "
"属性に割り当てます:"

#: ../../library/sqlite3.rst:2516
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = sqlite3.Row"
msgstr ""

#: ../../library/sqlite3.rst:2521
msgid "Queries now return :class:`!Row` objects:"
msgstr ""
"このように設定すると、クエリは :class:`!Row` オブジェクトを返すようになりま"
"す:"

#: ../../library/sqlite3.rst:2523
msgid ""
">>> res = con.execute(\"SELECT 'Earth' AS name, 6378 AS radius\")\n"
">>> row = res.fetchone()\n"
">>> row.keys()\n"
"['name', 'radius']\n"
">>> row[0]         # Access by index.\n"
"'Earth'\n"
">>> row[\"name\"]    # Access by name.\n"
"'Earth'\n"
">>> row[\"RADIUS\"]  # Column names are case-insensitive.\n"
"6378\n"
">>> con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2539
msgid ""
"The ``FROM`` clause can be omitted in the ``SELECT`` statement, as in the "
"above example. In such cases, SQLite returns a single row with columns "
"defined by expressions, e.g. literals, with the given aliases ``expr AS "
"alias``."
msgstr ""

#: ../../library/sqlite3.rst:2544
msgid ""
"You can create a custom :attr:`~Cursor.row_factory` that returns each row as "
"a :class:`dict`, with column names mapped to values:"
msgstr ""
"各列名が各値にマップされた :class:`dict` として行を返す、カスタム :attr:"
"`~Cursor.row_factory` を作成することもできます:"

#: ../../library/sqlite3.rst:2547
msgid ""
"def dict_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    return {key: value for key, value in zip(fields, row)}"
msgstr ""

#: ../../library/sqlite3.rst:2553
msgid ""
"Using it, queries now return a :class:`!dict` instead of a :class:`!tuple`:"
msgstr ""
"これを使うと、クエリは :class:`タプル <!tuple>` の代わりに :class:`!dict` を"
"返すようになります:"

#: ../../library/sqlite3.rst:2555
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = dict_factory\n"
">>> for row in con.execute(\"SELECT 1 AS a, 2 AS b\"):\n"
"...     print(row)\n"
"{'a': 1, 'b': 2}\n"
">>> con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2564
msgid "The following row factory returns a :term:`named tuple`:"
msgstr ""
"以下の行工場(row factory)は :term:`名前付きタプル <named tuple>` を返します:"

#: ../../library/sqlite3.rst:2566
msgid ""
"from collections import namedtuple\n"
"\n"
"def namedtuple_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    cls = namedtuple(\"Row\", fields)\n"
"    return cls._make(row)"
msgstr ""

#: ../../library/sqlite3.rst:2575
msgid ":func:`!namedtuple_factory` can be used as follows:"
msgstr ":func:`!namedtuple_factory` は以下のようにして使う事ができます:"

#: ../../library/sqlite3.rst:2577
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = namedtuple_factory\n"
">>> cur = con.execute(\"SELECT 1 AS a, 2 AS b\")\n"
">>> row = cur.fetchone()\n"
">>> row\n"
"Row(a=1, b=2)\n"
">>> row[0]  # Indexed access.\n"
"1\n"
">>> row.b   # Attribute access.\n"
"2\n"
">>> con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2591
msgid ""
"With some adjustments, the above recipe can be adapted to use a :class:"
"`~dataclasses.dataclass`, or any other custom class, instead of a :class:"
"`~collections.namedtuple`."
msgstr ""
"上記レシピをチューニングすれば、 :class:`~collections.namedtuple` の代わり"
"に :class:`~dataclasses.dataclass` または、その他のカスタム・クラスを使用する"
"ように適合(adapt)させることができます。"

#: ../../library/sqlite3.rst:2599
msgid "How to handle non-UTF-8 text encodings"
msgstr ""

#: ../../library/sqlite3.rst:2601
msgid ""
"By default, :mod:`!sqlite3` uses :class:`str` to adapt SQLite values with "
"the ``TEXT`` data type. This works well for UTF-8 encoded text, but it might "
"fail for other encodings and invalid UTF-8. You can use a custom :attr:"
"`~Connection.text_factory` to handle such cases."
msgstr ""

#: ../../library/sqlite3.rst:2607
msgid ""
"Because of SQLite's `flexible typing`_, it is not uncommon to encounter "
"table columns with the ``TEXT`` data type containing non-UTF-8 encodings, or "
"even arbitrary data. To demonstrate, let's assume we have a database with "
"ISO-8859-2 (Latin-2) encoded text, for example a table of Czech-English "
"dictionary entries. Assuming we now have a :class:`Connection` instance :py:"
"data:`!con` connected to this database, we can decode the Latin-2 encoded "
"text using this :attr:`~Connection.text_factory`:"
msgstr ""

#: ../../library/sqlite3.rst:2616
msgid "con.text_factory = lambda data: str(data, encoding=\"latin2\")"
msgstr ""

#: ../../library/sqlite3.rst:2620
msgid ""
"For invalid UTF-8 or arbitrary data in stored in ``TEXT`` table columns, you "
"can use the following technique, borrowed from the :ref:`unicode-howto`:"
msgstr ""

#: ../../library/sqlite3.rst:2623
msgid "con.text_factory = lambda data: str(data, errors=\"surrogateescape\")"
msgstr ""

#: ../../library/sqlite3.rst:2629
msgid ""
"The :mod:`!sqlite3` module API does not support strings containing "
"surrogates."
msgstr ""

#: ../../library/sqlite3.rst:2634
msgid ":ref:`unicode-howto`"
msgstr ""

#: ../../library/sqlite3.rst:2640
msgid "Explanation"
msgstr "説明"

#: ../../library/sqlite3.rst:2646
msgid "Transaction control"
msgstr "トランザクション制御"

#: ../../library/sqlite3.rst:2648
msgid ""
":mod:`!sqlite3` offers multiple methods of controlling whether, when and how "
"database transactions are opened and closed. :ref:`sqlite3-transaction-"
"control-autocommit` is recommended, while :ref:`sqlite3-transaction-control-"
"isolation-level` retains the pre-Python 3.12 behaviour."
msgstr ""
":mod:`!sqlite3` は、データベース・トランザクションを開くかどうか、いつ、どの"
"ように開くかを制御する複数の方法を提供します。 :ref:`sqlite3-transaction-"
"control-autocommit` が推奨されますが、:ref:`sqlite3-transaction-control-"
"isolation-level` は Python 3.12 より前の動作を保持します。"

#: ../../library/sqlite3.rst:2657
msgid "Transaction control via the ``autocommit`` attribute"
msgstr "``autocommit`` 属性に依るトランザクション制御"

#: ../../library/sqlite3.rst:2659
msgid ""
"The recommended way of controlling transaction behaviour is through the :"
"attr:`Connection.autocommit` attribute, which should preferably be set using "
"the *autocommit* parameter of :func:`connect`."
msgstr ""
"トランザクションの動作を制御する推奨方法は、 :attr:`Connection.autocommit` 属"
"性を使用することです。 この属性は :func:`connect` の *autocommit* パラメータ"
"を使用して設定して頂けるとありがたいです。"

#: ../../library/sqlite3.rst:2664
msgid ""
"It is suggested to set *autocommit* to ``False``, which implies :pep:`249`-"
"compliant transaction control. This means:"
msgstr ""
"*autocommit* を ``False`` に設定することをお勧めします。そうすると :pep:"
"`249` 対応のトランザクション制御を行います。これは以下のことを意味します:"

#: ../../library/sqlite3.rst:2668
msgid ""
":mod:`!sqlite3` ensures that a transaction is always open, so :func:"
"`connect`, :meth:`Connection.commit`, and :meth:`Connection.rollback` will "
"implicitly open a new transaction (immediately after closing the pending "
"one, for the latter two). :mod:`!sqlite3` uses ``BEGIN DEFERRED`` statements "
"when opening transactions."
msgstr ""
":mod:`!sqlite3` はトランザクションが常に開いていることを保証します。そのた"
"め、 :func:`connect` や :meth:`Connection.commit` や :meth:`Connection."
"rollback` は暗黙に新しいトランザクションを開きます(1つ目については保留中のト"
"ランザクションを閉じた直後で、後の2つについてはその直後に、です)。 :mod:`!"
"sqlite3` はトランザクションを開くときに ``BEGIN DEFERRED`` 文を使用します。"

#: ../../library/sqlite3.rst:2673
msgid "Transactions should be committed explicitly using :meth:`!commit`."
msgstr ""
"トランザクションは、 :meth:`!commit` を使用して明示的にコミットする必要があり"
"ます。"

#: ../../library/sqlite3.rst:2674
msgid "Transactions should be rolled back explicitly using :meth:`!rollback`."
msgstr ""
"トランザクションは、 :meth:`!rollback` を使用して明示的にロールバックする必要"
"があります。"

#: ../../library/sqlite3.rst:2675
msgid ""
"An implicit rollback is performed if the database is :meth:`~Connection."
"close`-ed with pending changes."
msgstr ""
"データベースの保留中に行った変更は :meth:`~Connection.close` された場合、暗黙"
"のロールバックが実行されます。"

#: ../../library/sqlite3.rst:2678
msgid ""
"Set *autocommit* to ``True`` to enable SQLite's `autocommit mode`_. In this "
"mode, :meth:`Connection.commit` and :meth:`Connection.rollback` have no "
"effect. Note that SQLite's autocommit mode is distinct from the :pep:`249`-"
"compliant :attr:`Connection.autocommit` attribute; use :attr:`Connection."
"in_transaction` to query the low-level SQLite autocommit mode."
msgstr ""
"*autocommit* を ``True`` に設定して、SQLite の `autocommit mode`_ を有効にし"
"ます。このモードでは、 :meth:`Connection.commit` と :meth:`Connection."
"rollback` は効果がありません。 SQLite の自動コミット・モード(autocommit mode)"
"は、 :pep:`249` 対応の :attr:`Connection.autocommit` 属性とは異なることに注意"
"してください。 :attr:`Connection.in_transaction` を使用して、低レベル SQLite "
"自動コミット・モードを問い合わせします。"

#: ../../library/sqlite3.rst:2686
msgid ""
"Set *autocommit* to :data:`LEGACY_TRANSACTION_CONTROL` to leave transaction "
"control behaviour to the :attr:`Connection.isolation_level` attribute. See :"
"ref:`sqlite3-transaction-control-isolation-level` for more information."
msgstr ""
"*autocommit* を :data:`LEGACY_TRANSACTION_CONTROL` に設定して、トランザクショ"
"ン制御の振る舞いを :attr:`Connection.isolation_level` 属性に任せます。詳細に"
"ついては :ref:`sqlite3-transaction-control-isolation-level` を参照してくださ"
"い。"

#: ../../library/sqlite3.rst:2695
msgid "Transaction control via the ``isolation_level`` attribute"
msgstr "``isolation_level`` 属性に依るトランザクション制御"

#: ../../library/sqlite3.rst:2699
msgid ""
"The recommended way of controlling transactions is via the :attr:"
"`~Connection.autocommit` attribute. See :ref:`sqlite3-transaction-control-"
"autocommit`."
msgstr ""
"推奨のトランザクション制御方法は、 :attr:`~Connection.autocommit` 属性を使用"
"することです。 :ref:`sqlite3-transaction-control-autocommit` を参照してくださ"
"い。"

#: ../../library/sqlite3.rst:2703
msgid ""
"If :attr:`Connection.autocommit` is set to :data:"
"`LEGACY_TRANSACTION_CONTROL` (the default), transaction behaviour is "
"controlled using the :attr:`Connection.isolation_level` attribute. "
"Otherwise, :attr:`!isolation_level` has no effect."
msgstr ""
":attr:`Connection.autocommit` が :data:`LEGACY_TRANSACTION_CONTROL` (これがデ"
"フォルトです)に設定されている場合、トランザクションの振る舞いは :attr:"
"`Connection.isolation_level` 属性を使用して制御されます。 :data:"
"`LEGACY_TRANSACTION_CONTROL` 以外の場合、 :attr:`!isolation_level` は効果があ"
"りません。"

#: ../../library/sqlite3.rst:2709
msgid ""
"If the connection attribute :attr:`~Connection.isolation_level` is not "
"``None``, new transactions are implicitly opened before :meth:`~Cursor."
"execute` and :meth:`~Cursor.executemany` executes ``INSERT``, ``UPDATE``, "
"``DELETE``, or ``REPLACE`` statements; for other statements, no implicit "
"transaction handling is performed. Use the :meth:`~Connection.commit` and :"
"meth:`~Connection.rollback` methods to respectively commit and roll back "
"pending transactions. You can choose the underlying `SQLite transaction "
"behaviour`_ — that is, whether and what type of ``BEGIN`` statements :mod:`!"
"sqlite3` implicitly executes – via the :attr:`~Connection.isolation_level` "
"attribute."
msgstr ""
"接続属性 :attr:`~Connection.isolation_level` が ``None`` で無いのなら、 :"
"meth:`~Cursor.execute` や :meth:`~Cursor.executemany` が  ``INSERT`` または "
"``UPDATE`` または ``DELETE`` または ``REPLACE`` 文を実行する前に新しいトラン"
"ザクションが暗黙に開かれます。それ以外のSQL文では暗黙のトランザクション処理は"
"行われません。 :meth:`~Connection.commit` メソッドや :meth:`~Connection."
"rollback` メソッドを使用して、 保留中のトランザクションをそれぞれコミットおよ"
"びロールバックします。あなたは、背後にある SQLite ライブラリのトランザクショ"
"ンの振る舞い(`SQLite transaction behaviour`_) — つまり、 sqlite3 が暗黙に実行"
"する ``BEGIN`` 文の有無とその種類 – を、 :attr:`~Connection.isolation_level` "
"属性を介して選択できます。"

#: ../../library/sqlite3.rst:2722
msgid ""
"If :attr:`~Connection.isolation_level` is set to ``None``, no transactions "
"are implicitly opened at all. This leaves the underlying SQLite library in "
"`autocommit mode`_, but also allows the user to perform their own "
"transaction handling using explicit SQL statements. The underlying SQLite "
"library autocommit mode can be queried using the :attr:`~Connection."
"in_transaction` attribute."
msgstr ""
":attr:`~Connection.isolation_level` が ``None`` に設定されていると、トランザ"
"クションは暗黙に開かれません。これにより、背後にある SQLite ライブラリを自動"
"コミット・モード(`autocommit mode`_)にしたまま、 明示的な SQL 文を使用して、 "
"ユーザが独自のトランザクション処理を行えるようにします。背後にある SQLite ラ"
"イブラリの自動コミット・モードは、 :attr:`~Connection.in_transaction` 属性を"
"使用して問い合わせできます。"

#: ../../library/sqlite3.rst:2730
msgid ""
"The :meth:`~Cursor.executescript` method implicitly commits any pending "
"transaction before execution of the given SQL script, regardless of the "
"value of :attr:`~Connection.isolation_level`."
msgstr ""
":meth:`~Cursor.executescript` メソッドは、 :attr:`~Connection."
"isolation_level` の値に関係なく、与えられた SQL スクリプトの実行前に、保留中"
"のトランザクションを暗黙にコミットします。"

#: ../../library/sqlite3.rst:2734
msgid ""
":mod:`!sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr ""
":mod:`!sqlite3` は、 DDL文の前に、開いているトランザクションを暗黙にコミット"
"していました。これはもはや当てはまりません。"

#: ../../library/sqlite3.rst:2738
msgid ""
"The recommended way of controlling transactions is now via the :attr:"
"`~Connection.autocommit` attribute."
msgstr ""
"推奨のトランザクションを制御方法は、 :attr:`~Connection.autocommit` 属性を使"
"用することです。"

#: ../../library/sqlite3.rst:1490
msgid "? (question mark)"
msgstr "? (クエスチョンマーク)"

#: ../../library/sqlite3.rst:1490 ../../library/sqlite3.rst:1491
msgid "in SQL statements"
msgstr ""

#: ../../library/sqlite3.rst:1491
msgid ": (colon)"
msgstr ": (コロン)"
