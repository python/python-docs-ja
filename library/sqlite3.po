# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Osamu NAKAMURA, 2021
# Takanori Suzuki <takanori@takanory.net>, 2021
# tomo, 2022
# HIdeo Haga, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-14 14:13+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: HIdeo Haga, 2023\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/sqlite3.rst:2
msgid ":mod:`sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ""
":mod:`sqlite3` --- SQLite データベースに対する DB-API 2.0 インターフェース"

#: ../../library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**ソースコード:** :source:`Lib/sqlite3/`"

#: ../../library/sqlite3.rst:23
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can "
"use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as "
"PostgreSQL or Oracle."
msgstr ""
"SQLite は、軽量なディスク上のデータベースを提供する C ライブラリです。別の"
"サーバプロセスを用意する必要なく、 SQL クエリー言語の非標準的な一種を使用して"
"データベースにアクセスできます。一部のアプリケーションは内部データ保存に "
"SQLite を使えます。また、SQLite を使ってアプリケーションのプロトタイプを作"
"り、その後そのコードを PostgreSQL や Oracle のような大規模データベースに移植"
"するということも可能です。"

#: ../../library/sqlite3.rst:30
msgid ""
"The :mod:`!sqlite3` module was written by Gerhard Häring.  It provides an "
"SQL interface compliant with the DB-API 2.0 specification described by :pep:"
"`249`, and requires SQLite 3.7.15 or newer."
msgstr ""
":mod:`!sqlite3` モジュールは Gerhard Häring によって書かれました。 :pep:"
"`249` に記述された DB-API 2.0 仕様に準拠した SQL インターフェースを提供し、"
"SQLite 3.7.15 以降が必要です。"

#: ../../library/sqlite3.rst:34
msgid "This document includes four main sections:"
msgstr "この文書には大きく分けて 4 つの節があります:"

#: ../../library/sqlite3.rst:36
msgid ":ref:`sqlite3-tutorial` teaches how to use the :mod:`!sqlite3` module."
msgstr ":ref:`sqlite3-tutorial` :mod:`!sqlite3` モジュールの使い方を学びます。"

#: ../../library/sqlite3.rst:37
msgid ""
":ref:`sqlite3-reference` describes the classes and functions this module "
"defines."
msgstr ""
":ref:`sqlite3-reference` このモジュールが定義するクラスと関数について説明しま"
"す。"

#: ../../library/sqlite3.rst:39
msgid ":ref:`sqlite3-howtos` details how to handle specific tasks."
msgstr ":ref:`sqlite3-howtos` 特定のタスクの処理方法について詳しく説明します。"

#: ../../library/sqlite3.rst:40
msgid ""
":ref:`sqlite3-explanation` provides in-depth background on transaction "
"control."
msgstr ""
":ref:`sqlite3-explanation` トランザクション制御の背景をより深く掘り下げて説明"
"します。"

#: ../../library/sqlite3.rst:47
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../library/sqlite3.rst:46
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr ""
"SQLite のウェブページ。ここの文書ではサポートされる SQL 方言の文法と使える"
"データ型を説明しています。"

#: ../../library/sqlite3.rst:50
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: ../../library/sqlite3.rst:50
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "SQL 学習に効くチュートリアル、リファレンス、実例集。"

#: ../../library/sqlite3.rst:52
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - Database API Specification 2.0"

#: ../../library/sqlite3.rst:53
msgid "PEP written by Marc-André Lemburg."
msgstr "Marc-Andre Lemburg により書かれた PEP。"

#: ../../library/sqlite3.rst:66
msgid "Tutorial"
msgstr "チュートリアル"

#: ../../library/sqlite3.rst:68
msgid ""
"In this tutorial, you will create a database of Monty Python movies using "
"basic :mod:`!sqlite3` functionality. It assumes a fundamental understanding "
"of database concepts, including `cursors`_ and `transactions`_."
msgstr ""
"このチュートリアルでは、あなたは基本的な :mod:`!sqlite3` 機能を使用して、 例"
"としてモンティ・パイソンの映画のデータベースを作成します。 あなたがカーソル"
"(`cursors`_)やトランザクション(`transactions`_)を含むデータベースの基本概念を"
"理解していることを前提としています。"

#: ../../library/sqlite3.rst:73
msgid ""
"First, we need to create a new database and open a database connection to "
"allow :mod:`!sqlite3` to work with it. Call :func:`sqlite3.connect` to "
"create a connection to the database :file:`tutorial.db` in the current "
"working directory, implicitly creating it if it does not exist:"
msgstr ""
"最初に、新しいデータベースを作成し、データベース接続(connection)を開いて :"
"mod:`!sqlite3` が動作できるようにする必要があります。 :func:`sqlite3."
"connect` を呼び出して、データベース :file:`tutorial.db` への接続を現在の作業"
"ディレクトリに作成します。存在しない場合は暗黙的に作成します。"

#: ../../library/sqlite3.rst:84
msgid ""
"The returned :class:`Connection` object ``con`` represents the connection to "
"the on-disk database."
msgstr ""
"返された :class:`Connection` オブジェクト ``con`` は、ディスク上のデータベー"
"スへの接続を表します。"

#: ../../library/sqlite3.rst:87
msgid ""
"In order to execute SQL statements and fetch results from SQL queries, we "
"will need to use a database cursor. Call :meth:`con.cursor() <Connection."
"cursor>` to create the :class:`Cursor`:"
msgstr ""
"SQL 文を実行し、SQL クエリから結果を取得するには、データベース・カーソルを使"
"用する必要があります。 :meth:`con.cursor() <Connection.cursor>` を呼び出し"
"て :class:`Cursor` を作成してください:"

#: ../../library/sqlite3.rst:95
msgid ""
"Now that we've got a database connection and a cursor, we can create a "
"database table ``movie`` with columns for title, release year, and review "
"score. For simplicity, we can just use column names in the table declaration "
"-- thanks to the `flexible typing`_ feature of SQLite, specifying the data "
"types is optional. Execute the ``CREATE TABLE`` statement by calling :meth:"
"`cur.execute(...) <Cursor.execute>`:"
msgstr ""
"さて、今やデータベース接続とカーソルを取得したので、タイトル(title)とリリース"
"年(year)と、レビュー・スコア(score)の列(columns)を持つデータベース・テーブル "
"``movie`` を作成できます。 簡単にするために、テーブル宣言では列名だけを使用で"
"きます。SQLite の 柔軟な型付け(`flexible typing`_)機能のおかげで、データ型の"
"指定はオプションになっています。 :meth:`cur.execute(...) <Cursor.execute>` を"
"呼び出して ``CREATE TABLE`` 文を実行してください:"

#: ../../library/sqlite3.rst:111
msgid ""
"We can verify that the new table has been created by querying the "
"``sqlite_master`` table built-in to SQLite, which should now contain an "
"entry for the ``movie`` table definition (see `The Schema Table`_ for "
"details). Execute that query by calling :meth:`cur.execute(...) <Cursor."
"execute>`, assign the result to ``res``, and call :meth:`res.fetchone() "
"<Cursor.fetchone>` to fetch the resulting row:"
msgstr ""
"SQLite に組み込みの ``sqlite_master`` テーブルに対してクエリを実行すること"
"で、新しいテーブルが作成されたことを確認できます。このテーブルには、 "
"``movie`` テーブル定義のエントリが含まれているはずです(詳細は `The Schema "
"Table`_ 参照)。 :meth:`cur.execute(...) <Cursor.execute>` を呼び出してクエリ"
"を実行して、その結果を ``res`` に代入し、結果の行(row)を取得するために :meth:"
"`res.fetchone() <Cursor.fetchone>` を呼び出します:"

#: ../../library/sqlite3.rst:125
msgid ""
"We can see that the table has been created, as the query returns a :class:"
"`tuple` containing the table's name. If we query ``sqlite_master`` for a non-"
"existent table ``spam``, :meth:`!res.fetchone()` will return ``None``:"
msgstr ""
"クエリがテーブルの名前を含む :class:`タプル <tuple>` を返すので、テーブルが作"
"成されたことがわかります。 存在しないテーブル ``spam`` に対して "
"``sqlite_master`` をクエリすると、 :meth:`!res.fetchone()` は ``None`` を返し"
"ます:"

#: ../../library/sqlite3.rst:136
msgid ""
"Now, add two rows of data supplied as SQL literals by executing an "
"``INSERT`` statement, once again by calling :meth:`cur.execute(...) <Cursor."
"execute>`:"
msgstr ""
"ここで、 INSERT 文を実行して SQL のリテラルとして提供された 2 行のデータを追"
"加し、 再度 :meth:`cur.execute(...) <Cursor.execute>` を呼び出して追加します:"

#: ../../library/sqlite3.rst:148
msgid ""
"The ``INSERT`` statement implicitly opens a transaction, which needs to be "
"committed before changes are saved in the database (see :ref:`sqlite3-"
"controlling-transactions` for details). Call :meth:`con.commit() <Connection."
"commit>` on the connection object to commit the transaction:"
msgstr ""
"``INSERT`` 文は、変更がデータベースに保存される前にコミットする必要がある、ト"
"ランザクションを暗黙的に開きます(詳細は、 :ref:`sqlite3-controlling-"
"transactions` 参照)。 トランザクションをコミットするために接続オブジェクト"
"(connection object)の :meth:`con.commit() <Connection.commit>` を呼び出して下"
"さい:"

#: ../../library/sqlite3.rst:158
msgid ""
"We can verify that the data was inserted correctly by executing a ``SELECT`` "
"query. Use the now-familiar :meth:`cur.execute(...) <Cursor.execute>` to "
"assign the result to ``res``, and call :meth:`res.fetchall() <Cursor."
"fetchall>` to return all resulting rows:"
msgstr ""
"``SELECT`` クエリを実行することで、データが正しく挿入されたことを確認できま"
"す。 結果のすべての行を返すには、おなじみの :meth:`cur.execute(...) <Cursor."
"execute>` を使用して結果を ``res`` に代入し、 :meth:`res.fetchall() <Cursor."
"fetchall>` を呼び出して下さい:"

#: ../../library/sqlite3.rst:170
msgid ""
"The result is a :class:`list` of two :class:`!tuple`\\s, one per row, each "
"containing that row's ``score`` value."
msgstr ""
"結果は、2 つの :class:`タプル <!tuple>` の :class:`リスト <list>` で、 それぞ"
"れのタプルにその行の ``score`` 値が含まれています。"

#: ../../library/sqlite3.rst:173
msgid ""
"Now, insert three more rows by calling :meth:`cur.executemany(...) <Cursor."
"executemany>`:"
msgstr ""
"ここで、 :meth:`cur.executemany(...) <Cursor.executemany>` を呼び出して、さら"
"に 3 行挿入します:"

#: ../../library/sqlite3.rst:186
msgid ""
"Notice that ``?`` placeholders are used to bind ``data`` to the query. "
"Always use placeholders instead of :ref:`string formatting <tut-formatting>` "
"to bind Python values to SQL statements, to avoid `SQL injection attacks`_ "
"(see :ref:`sqlite3-placeholders` for more details)."
msgstr ""
"``data`` をクエリに結び付け(bind)するために ``?`` プレースホルダが使用されて"
"いることに注意してください。 SQL インジェクション攻撃(`SQL injection "
"attacks`_)を避けるために、Python の値を SQL 文に結び付けするには、常に :ref:`"
"文字列フォーマット <tut-formatting>` の代わりにプレースホルダを使用してくださ"
"い(詳細は :ref:`sqlite3-placeholders` 参照)。"

#: ../../library/sqlite3.rst:192
msgid ""
"We can verify that the new rows were inserted by executing a ``SELECT`` "
"query, this time iterating over the results of the query:"
msgstr ""
"``SELECT`` クエリを実行することで、新しい行が挿入されたことを確認できます。今"
"回は、クエリの結果を反復処理します:"

#: ../../library/sqlite3.rst:206
msgid ""
"Each row is a two-item :class:`tuple` of ``(year, title)``, matching the "
"columns selected in the query."
msgstr ""
"各行(row)は :class:`タプル <tuple>` の ``(year, title)`` の 2 つの項目であ"
"り、クエリで選択された列(columns)にマッチします。"

#: ../../library/sqlite3.rst:209
msgid ""
"Finally, verify that the database has been written to disk by calling :meth:"
"`con.close() <Connection.close>` to close the existing connection, opening a "
"new one, creating a new cursor, then querying the database:"
msgstr ""
"最後に、 :meth:`con.close() <Connection.close>` を呼び出して既存の接続"
"(connection)を閉じ、新しい接続を開き、新しいカーソルを作成してから、データ"
"ベースに対してクエリを実行して、データベースがディスクに書き込まれたことを確"
"認します:"

#: ../../library/sqlite3.rst:224
msgid ""
"You've now created an SQLite database using the :mod:`!sqlite3` module, "
"inserted data and retrieved values from it in multiple ways."
msgstr ""
"これで、あなたは、 :mod:`!sqlite3` モジュールを使用して SQLite データベースを"
"作成し、複数の方法でデータを挿入し、そこから値を取得することができるようにな"
"りました。"

#: ../../library/sqlite3.rst:236
msgid ":ref:`sqlite3-howtos` for further reading:"
msgstr ":ref:`sqlite3-howtos` も参考にしてください:"

#: ../../library/sqlite3.rst:238
msgid ":ref:`sqlite3-placeholders`"
msgstr ":ref:`sqlite3-placeholders`"

#: ../../library/sqlite3.rst:239
msgid ":ref:`sqlite3-adapters`"
msgstr ":ref:`sqlite3-adapters`"

#: ../../library/sqlite3.rst:240
msgid ":ref:`sqlite3-converters`"
msgstr ":ref:`sqlite3-converters`"

#: ../../library/sqlite3.rst:241 ../../library/sqlite3.rst:557
msgid ":ref:`sqlite3-connection-context-manager`"
msgstr ":ref:`sqlite3-connection-context-manager`"

#: ../../library/sqlite3.rst:242
msgid ":ref:`sqlite3-howto-row-factory`"
msgstr ":ref:`sqlite3-howto-row-factory`"

#: ../../library/sqlite3.rst:244
msgid ""
":ref:`sqlite3-explanation` for in-depth background on transaction control."
msgstr ""
":ref:`トランザクション制御 <sqlite3-explanation>` トランザクション制御の背景"
"についてより深く掘り下げた説明。"

#: ../../library/sqlite3.rst:249
msgid "Reference"
msgstr "リファレンス"

#: ../../library/sqlite3.rst:257
msgid "Module functions"
msgstr "モジュール関数"

#: ../../library/sqlite3.rst:264
msgid "Open a connection to an SQLite database."
msgstr "SQLite データベースとの接続(connection)を開きます。"

#: ../../library/sqlite3.rst:0
msgid "Parameters"
msgstr "パラメーター"

#: ../../library/sqlite3.rst:266
msgid ""
"The path to the database file to be opened. Pass ``\":memory:\"`` to open a "
"connection to a database that is in RAM instead of on disk."
msgstr ""
"開きたいデータベース・ファイルへのファイル・パス。 ディスク上ではなく RAM 上"
"に置くデータベースへの接続を開くには、``\":memory:\"`` を渡します。"

#: ../../library/sqlite3.rst:272
msgid ""
"How many seconds the connection should wait before raising an :exc:"
"`OperationalError` when a table is locked. If another connection opens a "
"transaction to modify a table, that table will be locked until the "
"transaction is committed. Default five seconds."
msgstr ""
"テーブルがロックされている場合、 :exc:`OperationalError` を送出する前に接続を"
"待機する秒数。 別の接続がテーブルを変更するためにトランザクションを開くと、そ"
"のテーブルはトランザクションがコミットされるまでロックされます。 デフォルト"
"は 5 秒です。"

#: ../../library/sqlite3.rst:279
msgid ""
"Control whether and how data types not :ref:`natively supported by SQLite "
"<sqlite3-types>` are looked up to be converted to Python types, using the "
"converters registered with :func:`register_converter`. Set it to any "
"combination (using ``|``, bitwise or) of :const:`PARSE_DECLTYPES` and :const:"
"`PARSE_COLNAMES` to enable this. Column names takes precedence over declared "
"types if both flags are set. Types cannot be detected for generated fields "
"(for example ``max(data)``), even when the *detect_types* parameter is set; :"
"class:`str` will be returned instead. By default (``0``), type detection is "
"disabled."
msgstr ""
":func:`register_converter` で登録された変換関数を使用して、 :ref:`SQLite でネ"
"イティブにサポートされている型 <sqlite3-types>` 以外のデータ型を検出して、 "
"Python 型に変換するかどうか、そして、その変換方法を制御します。 これは、 :"
"const:`PARSE_DECLTYPES` と :const:`PARSE_COLNAMES` を(ビット論理和 ``|`` を使"
"用して)任意の組み合わせで設定することで有効になります。 両方のフラグが設定さ"
"れている場合、宣言された型よりも列名が優先されます。 *detect_types* パラメー"
"タが設定されている場合でも、 生成されたフィールド(たとえば ``max(data)``)の型"
"は検出できず、代わりに :class:`str` が返されます。デフォルト (``0``) では、"
"データ型検出は無効になっています。"

#: ../../library/sqlite3.rst:293
msgid ""
"The :attr:`~Connection.isolation_level` of the connection, controlling "
"whether and how transactions are implicitly opened. Can be ``\"DEFERRED\"`` "
"(default), ``\"EXCLUSIVE\"`` or ``\"IMMEDIATE\"``; or ``None`` to disable "
"opening transactions implicitly. See :ref:`sqlite3-controlling-transactions` "
"for more."
msgstr ""
"接続(connection)の :attr:`~Connection.isolation_level` は、 トランザクション"
"が暗黙に開かれるかどうかと、どのように開かれるかを制御し、その値は "
"``\"DEFERRED\"`` (これがデフォルトです)または ``\"EXCLUSIVE\"`` または "
"``\"IMMEDIATE\"`` のいずれか、または、トランザクションを暗黙に開くことができ"
"なくなる ``None`` です。詳細は :ref:`sqlite3-controlling-transactions` を参照"
"してください。"

#: ../../library/sqlite3.rst:301
msgid ""
"If ``True`` (default), :exc:`ProgrammingError` will be raised if the "
"database connection is used by a thread other than the one that created it. "
"If ``False``, the connection may be accessed in multiple threads; write "
"operations may need to be serialized by the user to avoid data corruption. "
"See :attr:`threadsafety` for more information."
msgstr ""
"``True`` (これがデフォルトです)なら、データベース接続を作成したスレッド以外の"
"スレッドがデータベース接続を使用すると、 :exc:`ProgrammingError` が送出されま"
"す。 ``False`` なら、接続は複数のスレッドからアクセスできます。ただし、データ"
"の破損を避けるために、ユーザーによる書き込み操作の直列化が必要になることがあ"
"ります。詳細は :attr:`threadsafety`  を参照してください。"

#: ../../library/sqlite3.rst:310
msgid ""
"A custom subclass of :class:`Connection` to create the connection with, if "
"not the default :class:`Connection` class."
msgstr ""
"デフォルトの :class:`Connection` クラスでない場合に接続(connection)を作成す"
"る :class:`Connection` のカスタム・サブクラスです。"

#: ../../library/sqlite3.rst:314
msgid ""
"The number of statements that :mod:`!sqlite3` should internally cache for "
"this connection, to avoid parsing overhead. By default, 128 statements."
msgstr ""
":mod:`!sqlite3` がこの接続(connection)のために内部的にキャッシュするSQL文"
"(statements)の数で、 パース時のオーバーヘッドを回避します。 デフォルトでは、"
"128 文(statements)です。"

#: ../../library/sqlite3.rst:319
msgid ""
"If set to ``True``, *database* is interpreted as a :abbr:`URI (Uniform "
"Resource Identifier)` with a file path and an optional query string. The "
"scheme part *must* be ``\"file:\"``, and the path can be relative or "
"absolute. The query string allows passing parameters to SQLite, enabling "
"various :ref:`sqlite3-uri-tricks`."
msgstr ""
"``True`` に設定すると、 *database* は、ファイル・パス(path)とオプションのクエ"
"リ文字列を含む :abbr:`URI (Uniform Resource Identifier)` として解釈されま"
"す。 スキームの部分は ``\"file:\"`` でなければならず、パス(path)は相対パスま"
"たは絶対パスにすることができます。 クエリ文字列により、 パラメーターを "
"SQLite に渡すことができ、さまざまな :ref:`sqlite3-uri-tricks` が有効になりま"
"す。"

#: ../../library/sqlite3.rst:0
msgid "Return type"
msgstr "戻り値型"

#: ../../library/sqlite3.rst:330
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument "
"``database``."
msgstr ""
"引数 ``database`` を指定して :ref:`監査イベント <auditing>` ``sqlite3."
"connect`` を送出します。 "

#: ../../library/sqlite3.rst:331
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` with "
"argument ``connection_handle``."
msgstr ""
"引数 ``connection_handle`` を指定して :ref:`監査イベント <auditing>` "
"``sqlite3.connect/handle`` を送出します。 "

#: ../../library/sqlite3.rst:333
msgid "The *uri* parameter."
msgstr "*uri* パラメーター。"

#: ../../library/sqlite3.rst:336
msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr ""
"*database* は、文字列だけでなく、 :term:`path-like object` にすることもできる"
"ようになりました。"

#: ../../library/sqlite3.rst:339
msgid "The ``sqlite3.connect/handle`` auditing event."
msgstr "監査イベント ``sqlite3.connect/handle``"

#: ../../library/sqlite3.rst:344
msgid ""
"Return ``True`` if the string *statement* appears to contain one or more "
"complete SQL statements. No syntactic verification or parsing of any kind is "
"performed, other than checking that there are no unclosed string literals "
"and the statement is terminated by a semicolon."
msgstr ""
"文字列 *statement* が 1 つ以上の完全な SQL 文を含んでいるように見える場合、 "
"``True`` を返します。 閉じられていない文字列リテラルがないことと、文がセミコ"
"ロンで終了していることを確認する以外の、構文の検証やパースは行われません。"

#: ../../library/sqlite3.rst:350
msgid "For example:"
msgstr "例えば:"

#: ../../library/sqlite3.rst:359
msgid ""
"This function may be useful during command-line input to determine if the "
"entered text seems to form a complete SQL statement, or if additional input "
"is needed before calling :meth:`~Cursor.execute`."
msgstr ""
"この関数は、コマンドライン入力時に便利で、入力されたテキストが完全な SQL 文を"
"形成しているように見えるかどうか、または :meth:`~Cursor.execute` を呼び出す前"
"に追加の入力が必要かどうかを判断するのに使えます。"

#: ../../library/sqlite3.rst:365
msgid ""
"Enable or disable callback tracebacks. By default you will not get any "
"tracebacks in user-defined functions, aggregates, converters, authorizer "
"callbacks etc. If you want to debug them, you can call this function with "
"*flag* set to ``True``. Afterwards, you will get tracebacks from callbacks "
"on :data:`sys.stderr`. Use ``False`` to disable the feature again."
msgstr ""
"コールバックのトレースバックを有効または無効にします。  デフォルトでは、ユー"
"ザー定義関数や集計関数や変換関数や authorizer コールバックなどではトレース"
"バックを取得しません。それらをデバッグしたい場合は、 *flag* を ``True`` に設"
"定してこの関数を呼び出し。その後、 :data:`sys.stderr` のコールバックからト"
"レースバックを取得します。 機能を再び無効にするには ``False`` を使用します。"

#: ../../library/sqlite3.rst:372
msgid ""
"Register an :func:`unraisable hook handler <sys.unraisablehook>` for an "
"improved debug experience:"
msgstr ""
":func:`unraisable hook handler <sys.unraisablehook>` を登録して デバッグ・エ"
"クスペリエンスを向上させます:"

#: ../../library/sqlite3.rst:397
msgid ""
"Register an *adapter* callable to adapt the Python type *type* into an "
"SQLite type. The adapter is called with a Python object of type *type* as "
"its sole argument, and must return a value of a :ref:`type that SQLite "
"natively understands <sqlite3-types>`."
msgstr ""
"Python の型 *type* を SQLite 型に適合させるための *adapter* 呼び出し可能オブ"
"ジェクトを登録します。 適合関数(adapter)は、 *type* 型の Python オブジェクト"
"を唯一の引数として呼び出され、 :ref:`SQLite がネイティブに理解できる型 "
"<sqlite3-types>` の値を返す必要があります。"

#: ../../library/sqlite3.rst:405
msgid ""
"Register the *converter* callable to convert SQLite objects of type "
"*typename* into a Python object of a specific type. The converter is invoked "
"for all SQLite values of type *typename*; it is passed a :class:`bytes` "
"object and should return an object of the desired Python type. Consult the "
"parameter *detect_types* of :func:`connect` for information regarding how "
"type detection works."
msgstr ""
"*typename* 型の SQLite オブジェクトを特定の型の Python オブジェクトに変換する"
"ための *converter* 呼び出し可能オブジェクトを登録します。変換関数(converter)"
"は、 *typename* 型のすべての SQLite 値に対して呼び出されます。 変換関数には :"
"class:`bytes` オブジェクトが渡され、目的の Python の型のオブジェクトを返す必"
"要があります。 SQLite のデータ型検出がどのように機能するかについては、 :func:"
"`connect` の *detect_types* パラメータを参照してください。"

#: ../../library/sqlite3.rst:413
msgid ""
"Note: *typename* and the name of the type in your query are matched case-"
"insensitively."
msgstr ""
"注釈: *typename* とクエリ内の型の名前は、大文字小文字を区別せずにマッチングさ"
"れます。"

#: ../../library/sqlite3.rst:420
msgid "Module constants"
msgstr "モジュール定数"

#: ../../library/sqlite3.rst:424
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function by using the type name, parsed from the query "
"column name, as the converter dictionary key. The type name must be wrapped "
"in square brackets (``[]``)."
msgstr ""
"このフラグ値を :func:`connect` の *detect_types* パラメーターに渡し、クエリの"
"列(column)名からパースされた型名を変換関数辞書(converter dictionary)のキーと"
"して使用して変換関数を探します。型名は角括弧(``[]``)で囲む必要があります。"

#: ../../library/sqlite3.rst:434
msgid ""
"This flag may be combined with :const:`PARSE_DECLTYPES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"このフラグは ``|`` (ビット論理和)演算子を使用して :const:`PARSE_DECLTYPES` と"
"組み合わせることができます。"

#: ../../library/sqlite3.rst:439
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function using the declared types for each column. The "
"types are declared when the database table is created. :mod:`!sqlite3` will "
"look up a converter function using the first word of the declared type as "
"the converter dictionary key. For example:"
msgstr ""
"このフラグ値を :func:`connect` の *detect_types* パラメーターに渡して、各列"
"(column)で宣言した型を使用して変換関数を探します。型は、データベース・テーブ"
"ルの作成時に宣言します。 :mod:`!sqlite3` は、宣言された型の、最初の単語を、変"
"換関数辞書(converter dictionary)のキーとして使用して、変換関数を探します。例"
"えば:"

#: ../../library/sqlite3.rst:455
msgid ""
"This flag may be combined with :const:`PARSE_COLNAMES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"このフラグは ``|`` (ビット論理和)演算子を使用して :const:`PARSE_COLNAMES` と"
"組み合わせることができます。"

#: ../../library/sqlite3.rst:462
msgid ""
"Flags that should be returned by the *authorizer_callback* callable passed "
"to :meth:`Connection.set_authorizer`, to indicate whether:"
msgstr ""
":meth:`Connection.set_authorizer` に渡された *authorizer_callback* 呼び出し可"
"能オブジェクトが返すフラグ:"

#: ../../library/sqlite3.rst:465
msgid "Access is allowed (:const:`!SQLITE_OK`),"
msgstr "アクセスは許可されました(:const:`!SQLITE_OK`)"

#: ../../library/sqlite3.rst:466
msgid ""
"The SQL statement should be aborted with an error (:const:`!SQLITE_DENY`)"
msgstr ""
"当該SQL文全体の実行をエラーで中止(abort)する必要があります(:const:`!"
"SQLITE_DENY`)"

#: ../../library/sqlite3.rst:467
msgid ""
"The column should be treated as a ``NULL`` value (:const:`!SQLITE_IGNORE`)"
msgstr ""
"列(column)は ``NULL`` 値として扱う必要がありますが、当該SQL文の実行は続行する"
"必要があります(:const:`!SQLITE_IGNORE`)"

#: ../../library/sqlite3.rst:471
msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr ""
"サポートされている DB-API レベルを示す文字列定数。 DB-API で必要です。 "
"``\"2.0\"`` とハードコーディングされています。"

#: ../../library/sqlite3.rst:476
msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`!sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr ""
":mod:`!sqlite3` モジュールが期待するパラメータ・マーカーのフォーマットの種類"
"をあらわす文字列定数です。 DB-API で必要です。 ``\"qmark\"`` とハードコーディ"
"ングされています。"

#: ../../library/sqlite3.rst:482
msgid "The ``named`` DB-API parameter style is also supported."
msgstr "``named`` DB-API パラメータ・スタイルもサポートされています。"

#: ../../library/sqlite3.rst:486
msgid ""
"Version number of the runtime SQLite library as a :class:`string <str>`."
msgstr ""
":class:`文字列 <str>` としての、ランタイム SQLite ライブラリのバージョン番"
"号。"

#: ../../library/sqlite3.rst:490
msgid ""
"Version number of the runtime SQLite library as a :class:`tuple` of :class:"
"`integers <int>`."
msgstr ""
":class:`整数 <int>` の :class:`タプル <tuple>` としての、ランタイム SQLite ラ"
"イブラリのバージョン番号。"

#: ../../library/sqlite3.rst:495
msgid ""
"Integer constant required by the DB-API 2.0, stating the level of thread "
"safety the :mod:`!sqlite3` module supports. This attribute is set based on "
"the default `threading mode <https://sqlite.org/threadsafe.html>`_ the "
"underlying SQLite library is compiled with. The SQLite threading modes are:"
msgstr ""
":mod:`!sqlite3` モジュールがサポートするスレッドセーフのレベルを示す、DB-API "
"2.0 で必要な整数定数。 この属性は、背後の SQLite ライブラリのコンパイル時のデ"
"フォルトの SQLite スレッド・モード (`threading mode <https://sqlite.org/"
"threadsafe.html>`_)に基づいて設定されます。 SQLite のスレッド・モードは以下の"
"とおりです:"

#: ../../library/sqlite3.rst:500
msgid ""
"**Single-thread**: In this mode, all mutexes are disabled and SQLite is "
"unsafe to use in more than a single thread at once."
msgstr ""
"**シングル・スレッド**: このモードでは、すべてのミューテックスが無効になり、"
"一度に複数のスレッドで SQLite を使用するのは安全ではありません。"

#: ../../library/sqlite3.rst:502
msgid ""
"**Multi-thread**: In this mode, SQLite can be safely used by multiple "
"threads provided that no single database connection is used simultaneously "
"in two or more threads."
msgstr ""
"**マルチ・スレッド**: このモードでは、 1 つのデータベース接続が 2 つ以上のス"
"レッドで同時に使用されない限り、複数のスレッドで SQLite を安全に使用できま"
"す。"

#: ../../library/sqlite3.rst:505
msgid ""
"**Serialized**: In serialized mode, SQLite can be safely used by multiple "
"threads with no restriction."
msgstr ""
"**直列化**: 直列化(serialized)モードでは、 SQLite を複数のスレッドで制限なく"
"安全に使用できます。"

#: ../../library/sqlite3.rst:508
msgid ""
"The mappings from SQLite threading modes to DB-API 2.0 threadsafety levels "
"are as follows:"
msgstr ""
"SQLite スレッド・モードと、 DB-API 2.0 のスレッドセーフ・レベルとの対応は以下"
"のとおりです:"

#: ../../library/sqlite3.rst:512
msgid "SQLite threading mode"
msgstr "SQLite スレッド・モード"

#: ../../library/sqlite3.rst:512
msgid "`threadsafety`_"
msgstr "スレッドセーフ・レベル(`threadsafety`_)"

#: ../../library/sqlite3.rst:512
msgid "`SQLITE_THREADSAFE`_"
msgstr "`SQLITE_THREADSAFE`_"

#: ../../library/sqlite3.rst:512
msgid "DB-API 2.0 meaning"
msgstr "DB-API 2.0 での意味"

#: ../../library/sqlite3.rst:515
msgid "single-thread"
msgstr "シングル・スレッド"

#: ../../library/sqlite3.rst:515
msgid "0"
msgstr "0"

#: ../../library/sqlite3.rst:515
msgid "Threads may not share the module"
msgstr "スレッドはモジュールを共有できません"

#: ../../library/sqlite3.rst:518
msgid "multi-thread"
msgstr "マルチ・スレッド"

#: ../../library/sqlite3.rst:518 ../../library/sqlite3.rst:521
msgid "1"
msgstr "1"

#: ../../library/sqlite3.rst:518
msgid "2"
msgstr "2"

#: ../../library/sqlite3.rst:518
msgid "Threads may share the module, but not connections"
msgstr "スレッドはモジュールを共有できますが、接続は共有できません"

#: ../../library/sqlite3.rst:521
msgid "serialized"
msgstr "直列化"

#: ../../library/sqlite3.rst:521
msgid "3"
msgstr "3"

#: ../../library/sqlite3.rst:521
msgid "Threads may share the module, connections and cursors"
msgstr "スレッドは、モジュールや接続やカーソルを共有できます"

#: ../../library/sqlite3.rst:528
msgid "Set *threadsafety* dynamically instead of hard-coding it to ``1``."
msgstr ""
"``1`` とハード・コーディングする代わりに *threadsafety* を動的に設定します。"

#: ../../library/sqlite3.rst:533
msgid ""
"Version number of this module as a :class:`string <str>`. This is not the "
"version of the SQLite library."
msgstr ""
":class:`文字列 <str>` としての、このモジュールのバージョン番号。これは "
"SQLite ライブラリのバージョン番号ではありません。"

#: ../../library/sqlite3.rst:538
msgid ""
"Version number of this module as a :class:`tuple` of :class:`integers "
"<int>`. This is not the version of the SQLite library."
msgstr ""
":class:`整数 <int>` の :class:`タプル <tuple>` としての、このモジュールのバー"
"ジョン番号。これは SQLite ライブラリのバージョン番号ではありません。"

#: ../../library/sqlite3.rst:545
msgid "Connection objects"
msgstr "Connection オブジェクト"

#: ../../library/sqlite3.rst:549
msgid ""
"Each open SQLite database is represented by a ``Connection`` object, which "
"is created using :func:`sqlite3.connect`. Their main purpose is creating :"
"class:`Cursor` objects, and :ref:`sqlite3-controlling-transactions`."
msgstr ""
"開いた SQLite データベースの各々は、 :func:`sqlite3.connect` を使用して作成さ"
"れる ``Connection`` オブジェクトによって表されます。``Connection`` オブジェク"
"トの主な目的は :class:`Cursor` オブジェクトの作成と :ref:`sqlite3-"
"controlling-transactions` です。"

#: ../../library/sqlite3.rst:556
msgid ":ref:`sqlite3-connection-shortcuts`"
msgstr ":ref:`sqlite3-connection-shortcuts`"

#: ../../library/sqlite3.rst:559
msgid "An SQLite database connection has the following attributes and methods:"
msgstr ""
"SQLite データベース接続(connection)には、以下の属性とメソッドがあります:"

#: ../../library/sqlite3.rst:563
msgid ""
"Create and return a :class:`Cursor` object. The cursor method accepts a "
"single optional parameter *factory*. If supplied, this must be a callable "
"returning an instance of :class:`Cursor` or its subclasses."
msgstr ""
":class:`Cursor` オブジェクトを作成して返します。 cursor メソッドは、単一のオ"
"プション・パラメータ *factory* を受け入れます。 このオプション・パラメータが"
"提供される場合、 :class:`Cursor` またはそのサブクラスのインスタンスを返す呼び"
"出し可能オブジェクトでなければなりません。"

#: ../../library/sqlite3.rst:570
msgid ""
"Open a :class:`Blob` handle to an existing :abbr:`BLOB (Binary Large "
"OBject)`."
msgstr ""
"既存の :abbr:`BLOB (Binary Large OBject)` への :class:`Blob` ハンドルを開きま"
"す。"

#: ../../library/sqlite3.rst:573
msgid "The name of the table where the blob is located."
msgstr "当該 BLOB が配置されているテーブルの名前。"

#: ../../library/sqlite3.rst:576
msgid "The name of the column where the blob is located."
msgstr "当該 BLOB が配置されている列(column)の名前。"

#: ../../library/sqlite3.rst:579
msgid "The name of the row where the blob is located."
msgstr "当該 BLOB が配置されている行(row)の名前。"

#: ../../library/sqlite3.rst:582
msgid ""
"Set to ``True`` if the blob should be opened without write permissions. "
"Defaults to ``False``."
msgstr ""
"書き込み権限なしで BLOB を開く必要がある場合は、 ``True`` に設定します。 デ"
"フォルトは ``False`` です。"

#: ../../library/sqlite3.rst:587
msgid ""
"The name of the database where the blob is located. Defaults to ``\"main\"``."
msgstr ""
"当該 BLOB が配置されているデータベース名。 デフォルトは ``\"main\"`` です。"

#: ../../library/sqlite3.rst:0
msgid "Raises"
msgstr ""

#: ../../library/sqlite3.rst:591
msgid "When trying to open a blob in a ``WITHOUT ROWID`` table."
msgstr "``WITHOUT ROWID`` テーブルで BLOB を開こうとしたとき。"

#: ../../library/sqlite3.rst:598
msgid ""
"The blob size cannot be changed using the :class:`Blob` class. Use the SQL "
"function ``zeroblob`` to create a blob with a fixed size."
msgstr ""
":class:`Blob` クラスを使用して BLOB のサイズを変更することはできません。 SQL "
"関数 ``zeroblob`` を使用すると、固定サイズのブロブを作成します。"

#: ../../library/sqlite3.rst:605
msgid ""
"Commit any pending transaction to the database. If there is no open "
"transaction, this method is a no-op."
msgstr ""
"保留中のトランザクションをデータベースにコミットします。 開いているトランザク"
"ションがない場合、このメソッドは何もしません。"

#: ../../library/sqlite3.rst:610
msgid ""
"Roll back to the start of any pending transaction. If there is no open "
"transaction, this method is a no-op."
msgstr ""
"保留中のトランザクションの開始点までロールバックします。開いているトランザク"
"ションがない場合、このメソッドは何もしません。"

#: ../../library/sqlite3.rst:615
msgid ""
"Close the database connection. Any pending transaction is not committed "
"implicitly; make sure to :meth:`commit` before closing to avoid losing "
"pending changes."
msgstr ""
"データベース接続を閉じます。 保留中のトランザクションは暗黙にコミットされませ"
"ん。 保留中の変更が失われないように、データベース接続を閉じる前に必ず :meth:"
"`commit` してください。"

#: ../../library/sqlite3.rst:622
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"新しい :class:`Cursor` オブジェクトを作成し、指定の *sql* と *parameters* "
"で :meth:`~Cursor.execute` を呼び出します。新しいカーソル・オブジェクトを返し"
"ます。"

#: ../../library/sqlite3.rst:628
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"新しい :class:`Cursor` オブジェクトを作成し、与えられた *sql* と "
"*parameters* で :meth:`~Cursor.executemany` を呼び出します。新しいカーソル・"
"オブジェクトを返します。"

#: ../../library/sqlite3.rst:634
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""
"新しい :class:`Cursor` オブジェクトを作成し、指定された *sql_script* で :"
"meth:`~Cursor.executescript` を呼び出します。新しいカーソル・オブジェクトを返"
"します。"

#: ../../library/sqlite3.rst:640
msgid "Create or remove a user-defined SQL function."
msgstr "ユーザ定義 SQL 関数を作成または削除します。"

#: ../../library/sqlite3.rst:642
msgid "The name of the SQL function."
msgstr "SQL 関数の名前。"

#: ../../library/sqlite3.rst:645
msgid ""
"The number of arguments the SQL function can accept. If ``-1``, it may take "
"any number of arguments."
msgstr ""
"SQL 関数が受け入れることができる引数の数。 ``-1`` を指定すると、任意の数の引"
"数を取ることができます。"

#: ../../library/sqlite3.rst:649
msgid ""
"A callable that is called when the SQL function is invoked. The callable "
"must return :ref:`a type natively supported by SQLite <sqlite3-types>`. Set "
"to ``None`` to remove an existing SQL function."
msgstr ""
"SQL 関数を使用したときに呼び出される、呼び出し可能オブジェクト。 呼び出し可能"
"オブジェクトは :ref:`SQLite でネイティブにサポートされている型 <sqlite3-"
"types>` を返さなければなりません。 既存の SQL 関数を削除するには ``None`` を"
"設定します。"

#: ../../library/sqlite3.rst:656
msgid ""
"If ``True``, the created SQL function is marked as `deterministic <https://"
"sqlite.org/deterministic.html>`_, which allows SQLite to perform additional "
"optimizations."
msgstr ""
"``True`` の場合、作成された SQL 関数は決定論的(`deterministic <https://"
"sqlite.org/deterministic.html>`_ : 入力が同一なら常に同一の答えを返す)として"
"マークされ、SQLite が追加の最適化を実行できるようになります。"

#: ../../library/sqlite3.rst:661
msgid "If *deterministic* is used with SQLite versions older than 3.8.3."
msgstr ""
"*deterministic* が 3.8.3 より古い SQLite バージョンで使用されている場合に送出"
"されます。"

#: ../../library/sqlite3.rst:664
msgid "The *deterministic* parameter."
msgstr "*deterministic* パラメーター。"

#: ../../library/sqlite3.rst:667 ../../library/sqlite3.rst:705
#: ../../library/sqlite3.rst:768 ../../library/sqlite3.rst:1019
#: ../../library/sqlite3.rst:1256 ../../library/sqlite3.rst:1383
#: ../../library/sqlite3.rst:1404
msgid "Example:"
msgstr "例:"

#: ../../library/sqlite3.rst:683
msgid "Create or remove a user-defined SQL aggregate function."
msgstr "ユーザ定義集計関数を作成または削除します。"

#: ../../library/sqlite3.rst:685
msgid "The name of the SQL aggregate function."
msgstr "SQL 集計関数の名前。"

#: ../../library/sqlite3.rst:688
msgid ""
"The number of arguments the SQL aggregate function can accept. If ``-1``, it "
"may take any number of arguments."
msgstr ""
"SQL 集計関数が受け入れることができる引数の数。 ``-1`` を指定すると、任意の数"
"の引数を取ることができます。"

#: ../../library/sqlite3.rst:692
msgid ""
"A class must implement the following methods:  * ``step()``: Add a row to "
"the aggregate. * ``finalize()``: Return the final result of the aggregate "
"as   :ref:`a type natively supported by SQLite <sqlite3-types>`.  The number "
"of arguments that the ``step()`` method must accept is controlled by "
"*n_arg*.  Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""

#: ../../library/sqlite3.rst:693
msgid "A class must implement the following methods:"
msgstr "クラスは以下のメソッドを実装する必要があります:"

#: ../../library/sqlite3.rst:695
msgid "``step()``: Add a row to the aggregate."
msgstr "``step()``: 集計に行(row)を足し込みます。"

#: ../../library/sqlite3.rst:696 ../../library/sqlite3.rst:752
msgid ""
"``finalize()``: Return the final result of the aggregate as :ref:`a type "
"natively supported by SQLite <sqlite3-types>`."
msgstr ""
"``finalize()``: 集計の最終結果を :ref:`SQLite でネイティブにサポートされてい"
"る型 <sqlite3-types>` として返します。"

#: ../../library/sqlite3.rst:699
msgid ""
"The number of arguments that the ``step()`` method must accept is controlled "
"by *n_arg*."
msgstr ""
"``step()`` メソッドが受け入れなければならない引数の数は *n_arg* によって制御"
"されます。"

#: ../../library/sqlite3.rst:702
msgid "Set to ``None`` to remove an existing SQL aggregate function."
msgstr "既存の SQL 集計関数を削除するには、 ``None`` に設定します。"

#: ../../library/sqlite3.rst:737
msgid "Create or remove a user-defined aggregate window function."
msgstr "ユーザー定義の集計ウインドウ関数を作成または削除します。"

#: ../../library/sqlite3.rst:739
msgid "The name of the SQL aggregate window function to create or remove."
msgstr "作成または削除する SQL 集計ウインドウ関数の名前。"

#: ../../library/sqlite3.rst:742
msgid ""
"The number of arguments the SQL aggregate window function can accept. If "
"``-1``, it may take any number of arguments."
msgstr ""
"SQL 集計ウィンドウ関数が受け入れることができる引数の数。 ``-1`` を指定した場"
"合、任意の数の引数を取ることができます。"

#: ../../library/sqlite3.rst:746
msgid ""
"A class that must implement the following methods:  * ``step()``: Add a row "
"to the current window. * ``value()``: Return the current value of the "
"aggregate. * ``inverse()``: Remove a row from the current window. * "
"``finalize()``: Return the final result of the aggregate as   :ref:`a type "
"natively supported by SQLite <sqlite3-types>`.  The number of arguments that "
"the ``step()`` and ``value()`` methods must accept is controlled by "
"*num_params*.  Set to ``None`` to remove an existing SQL aggregate window "
"function."
msgstr ""

#: ../../library/sqlite3.rst:747
msgid "A class that must implement the following methods:"
msgstr "クラスは以下のメソッドを実装する必要があります:"

#: ../../library/sqlite3.rst:749
msgid "``step()``: Add a row to the current window."
msgstr "``step()``: 現在のウィンドウに行を足し込みます。"

#: ../../library/sqlite3.rst:750
msgid "``value()``: Return the current value of the aggregate."
msgstr "``value()``: 集計の現在の値を返します。"

#: ../../library/sqlite3.rst:751
msgid "``inverse()``: Remove a row from the current window."
msgstr "``inverse()``: 現在のウインドウから指定の行(row)の分を削除します。"

#: ../../library/sqlite3.rst:755
msgid ""
"The number of arguments that the ``step()`` and ``value()`` methods must "
"accept is controlled by *num_params*."
msgstr ""
"``step()`` メソッドと ``value()`` メソッドが受け入れなければならない引数の数"
"は *num_params* によって制御されます。"

#: ../../library/sqlite3.rst:758
msgid "Set to ``None`` to remove an existing SQL aggregate window function."
msgstr "``None`` に設定すると、既存の SQL 集計ウィンドウ関数が削除されます。"

#: ../../library/sqlite3.rst:760
msgid ""
"If used with a version of SQLite older than 3.25.0, which does not support "
"aggregate window functions."
msgstr ""
"集計ウィンドウ関数をサポートしていない 3.25.0 より古いバージョンの SQLite で"
"使用した場合に送出されます。"

#: ../../library/sqlite3.rst:823
msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""
"照合関数(collating function) *callable* を使用して *name* という名前の照合"
"(collation)を作成します。 *callable* には 2 つの :class:`文字列 <str>` 引数が"
"渡され、:class:`整数 <int>` を返す必要があります:"

#: ../../library/sqlite3.rst:827
msgid "``1`` if the first is ordered higher than the second"
msgstr "1 番目の文字列が 2 番目の文字列よりも高い順位ならば ``1`` を返す"

#: ../../library/sqlite3.rst:828
msgid "``-1`` if the first is ordered lower than the second"
msgstr "1 番目の文字列が 2 番目の文字列よりも低い順位ならば ``-1``  を返す"

#: ../../library/sqlite3.rst:829
msgid "``0`` if they are ordered equal"
msgstr "1 番目の文字列と 2 番目の文字列が同じ順位ならば ``0``  を返す"

#: ../../library/sqlite3.rst:831
msgid "The following example shows a reverse sorting collation:"
msgstr "以下は逆順での照合例です:"

#: ../../library/sqlite3.rst:859
msgid "Remove a collation function by setting *callable* to ``None``."
msgstr "照合関数を削除するには *callable* を ``None`` に設定します。"

#: ../../library/sqlite3.rst:861
msgid ""
"The collation name can contain any Unicode character.  Earlier, only ASCII "
"characters were allowed."
msgstr ""
"照合の名前には任意のユニコード文字を含めることができます。 以前は ASCII 文字"
"のみが許可されていました。"

#: ../../library/sqlite3.rst:868
msgid ""
"Call this method from a different thread to abort any queries that might be "
"executing on the connection. Aborted queries will raise an :exc:"
"`OperationalError`."
msgstr ""
"このメソッドを別のスレッドから呼び出して、この接続(connection)で、実行中のす"
"べてのクエリを中止(abort)させます。 中止(abort)させられたクエリは :exc:"
"`OperationalError` を送出します。"

#: ../../library/sqlite3.rst:875
msgid ""
"Register callable *authorizer_callback* to be invoked for each attempt to "
"access a column of a table in the database. The callback should return one "
"of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or :const:`SQLITE_IGNORE` to "
"signal how access to the column should be handled by the underlying SQLite "
"library."
msgstr ""
"データベース内のテーブルの列(column)にアクセスしようとするたびに呼び出され"
"る、 *authorizer_callback* 呼び出し可能オブジェクトを登録します。背後にある "
"SQLite ライブラリが列(column)へのアクセスをどのように処理すべきか教えるため"
"に、コールバックは :const:`SQLITE_OK` または  :const:`SQLITE_DENY` または :"
"const:`SQLITE_IGNORE` のいずれかを返す必要があります。"

#: ../../library/sqlite3.rst:881
msgid ""
"The first argument to the callback signifies what kind of operation is to be "
"authorized. The second and third argument will be arguments or ``None`` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or ``None`` if this access attempt is directly from input SQL code."
msgstr ""
"コールバックの最初の引数は、承認(authorize)される操作の種類を示します。 2 番"
"目と 3 番目の引数は、最初の引数に応じて、引数または ``None`` になります。 4 "
"番目の引数は、該当する場合、データベースの名前(\"main\" や \"temp\" 等)で"
"す。 5 番目の引数は、 アクセス試行を担当する最も内側のトリガーまたはビューの"
"名前です。このアクセス試行が入力 SQL コードから直接行われた場合は ``None`` で"
"す。"

#: ../../library/sqlite3.rst:888
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on "
"the first one. All necessary constants are available in the :mod:`!sqlite3` "
"module."
msgstr ""
"最初の引数に指定可能な値と、 最初の引数に応じた 2 番目と 3 番目の引数の意味に"
"ついては、 SQLite のドキュメントを参照してください。 必要なすべての定数は :"
"mod:`!sqlite3` モジュールで利用できます。"

#: ../../library/sqlite3.rst:892
msgid "Passing ``None`` as *authorizer_callback* will disable the authorizer."
msgstr ""
"*authorizer_callback* として ``None`` を渡すと、承認機構(authorizer)が無効に"
"なります。"

#: ../../library/sqlite3.rst:894
msgid "Added support for disabling the authorizer using ``None``."
msgstr ""
"``None`` を使用して承認機構(authorizer)を無効にするサポートが追加されました。"

#: ../../library/sqlite3.rst:900
msgid ""
"Register callable *progress_handler* to be invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update "
"a GUI."
msgstr ""
"SQLite 仮想マシンの *n* 個の命令ごとに呼び出される、 *progress_handler* 呼び"
"出し可能オブジェクトを登録します。 これは、 GUI での更新処理など、 長時間実行"
"される操作中に SQLite から呼び出されるようにしたい場合に便利です。"

#: ../../library/sqlite3.rst:905
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with ``None`` for *progress_handler*."
msgstr ""
"以前にインストールした progress ハンドラーをクリアしたい場合は、 "
"*progress_handler* に ``None`` を指定してメソッドを呼び出します。"

#: ../../library/sqlite3.rst:908
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise an :exc:`OperationalError` "
"exception."
msgstr ""
"ハンドラー関数からゼロ以外の値を返すと、 現在実行中のクエリが終了(terminate)"
"し、 :exc:`OperationalError` 例外を送出します。"

#: ../../library/sqlite3.rst:915
msgid ""
"Register callable *trace_callback* to be invoked for each SQL statement that "
"is actually executed by the SQLite backend."
msgstr ""
"SQLite バックエンドによって実際に実行される各 SQL 文に対して呼び出される、呼"
"び出し可能オブジェクトの *trace_callback* を登録します。"

#: ../../library/sqlite3.rst:918
msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the :meth:`Cursor."
"execute` methods.  Other sources include the :ref:`transaction management "
"<sqlite3-controlling-transactions>` of the :mod:`!sqlite3` module and the "
"execution of triggers defined in the current database."
msgstr ""
"コールバックに渡される唯一の引数は、(:class:`str` として渡される)実行中のSQL"
"文です。 コールバックの戻り値は無視されます。 バックエンドは、 :meth:`Cursor."
"execute` メソッドに渡されたSQL文を実行するだけではないことに注意してくださ"
"い。 :mod:`!sqlite3` モジュールの :ref:`トランザクション管理 <sqlite3-"
"controlling-transactions>` や、現在のデータベース内で定義されたトリガーの実行"
"その他も行います。"

#: ../../library/sqlite3.rst:926
msgid "Passing ``None`` as *trace_callback* will disable the trace callback."
msgstr ""
"*trace_callback* として ``None`` を渡すと、トレース・コールバックが無効になり"
"ます。"

#: ../../library/sqlite3.rst:929
msgid ""
"Exceptions raised in the trace callback are not propagated. As a development "
"and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to enable "
"printing tracebacks from exceptions raised in the trace callback."
msgstr ""
"トレース・コールバックで発生した例外は伝播されません。 開発およびデバッグの補"
"助として、 :meth:`~sqlite3.enable_callback_tracebacks` を使用して、トレース・"
"コールバックで発生した例外からのトレースバックの出力を有効にします。"

#: ../../library/sqlite3.rst:939
msgid ""
"Enable the SQLite engine to load SQLite extensions from shared libraries if "
"*enabled* is ``True``; else, disallow loading SQLite extensions. SQLite "
"extensions can define new functions, aggregates or whole new virtual table "
"implementations.  One well-known extension is the fulltext-search extension "
"distributed with SQLite."
msgstr ""
"*enabled* が ``True`` の場合、 SQLite エンジンが共有ライブラリから SQLite 拡"
"張機能をロードできるようにします。 ``True`` 以外の場合は、 SQLite 拡張機能の"
"読み込みを許可しません。 SQLite 拡張機能では、新しい関数の定義、または集計の"
"定義、またはまったく新しい仮想テーブルの実装を定義できます。 よく知られている"
"拡張機能の 1 つは、SQLite と共に配布される全文検索拡張機能です。"

#: ../../library/sqlite3.rst:948
msgid ""
"The :mod:`!sqlite3` module is not built with loadable extension support by "
"default, because some platforms (notably macOS) have SQLite libraries which "
"are compiled without this feature. To get loadable extension support, you "
"must pass the :option:`--enable-loadable-sqlite-extensions` option to :"
"program:`configure`."
msgstr ""
":mod:`!sqlite3` モジュールは、デフォルトではロード可能な拡張機能をサポートす"
"るようにビルドされていません。一部のプラットフォーム(特に macOS)には、この機"
"能なしでコンパイルされた SQLite ライブラリがあるためです。 ロード可能な拡張機"
"能のサポートを得るには、 :program:`configure` に :option:`--enable-loadable-"
"sqlite-extensions` オプションを渡す必要があります。"

#: ../../library/sqlite3.rst:955
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.enable_load_extension`` "
"with arguments ``connection``, ``enabled``."
msgstr ""
"引数 ``connection``, ``enabled`` を指定して :ref:`監査イベント <auditing>` "
"``sqlite3.enable_load_extension`` を送出します。 "

#: ../../library/sqlite3.rst:959
msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr "``sqlite3.enable_load_extension`` 監査イベントを追加しました。"

#: ../../library/sqlite3.rst:1002
msgid ""
"Load an SQLite extension from a shared library located at *path*. Enable "
"extension loading with :meth:`enable_load_extension` before calling this "
"method."
msgstr ""
"*path* にある共有ライブラリから SQLite 拡張機能をロードします。 このメソッド"
"を呼び出す前に :meth:`enable_load_extension` で拡張機能の読み込みを有効にして"
"ください。"

#: ../../library/sqlite3.rst:1006
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` with "
"arguments ``connection``, ``path``."
msgstr ""
"引数 ``connection``, ``path`` を指定して :ref:`監査イベント <auditing>` "
"``sqlite3.load_extension`` を送出します。 "

#: ../../library/sqlite3.rst:1010
msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr "``sqlite3.load_extension`` 監査イベントを追加しました。"

#: ../../library/sqlite3.rst:1015
msgid ""
"Return an :term:`iterator` to dump the database as SQL source code. Useful "
"when saving an in-memory database for later restoration. Similar to the ``."
"dump`` command in the :program:`sqlite3` shell."
msgstr ""
"データベースを SQL ソース・コードとしてダンプする :term:`iterator` を返しま"
"す。 後で復元するためにメモリ内データベースを保存する場合に便利です。 :"
"program:`sqlite3` シェルの ``.dump`` コマンドに似ています。"

#: ../../library/sqlite3.rst:1033
msgid "Create a backup of an SQLite database."
msgstr "SQLite データベースのバックアップを作成します。"

#: ../../library/sqlite3.rst:1035
msgid ""
"Works even if the database is being accessed by other clients or "
"concurrently by the same connection."
msgstr ""
"データベースが他のクライアントによってアクセスされている場合、または同一の接"
"続によって並行にアクセスされている場合でも機能します。"

#: ../../library/sqlite3.rst:1038
msgid "The database connection to save the backup to."
msgstr "バックアップ先のデータベース接続(connection)。"

#: ../../library/sqlite3.rst:1041
msgid ""
"The number of pages to copy at a time. If equal to or less than ``0``, the "
"entire database is copied in a single step. Defaults to ``-1``."
msgstr ""
"一度にコピーするページ数。 ``0`` 以下の場合、データベース全体がワンステップで"
"コピーされます。 デフォルトは ``-1`` です。"

#: ../../library/sqlite3.rst:1047
msgid ""
"If set to a callable, it is invoked with three integer arguments for every "
"backup iteration: the *status* of the last iteration, the *remaining* number "
"of pages still to be copied, and the *total* number of pages. Defaults to "
"``None``."
msgstr ""
"呼び出し可能オブジェクトを設定すると、バックアップの指定ページ数単位の反復ご"
"とに 3 つの整数引数で呼び出されます。 *status* は、最後の反復のステータス"
"で、 *remaining* はまだコピーされていない残りのページ数で、 *total* はコピー"
"されるページの合計です。 デフォルトは ``None`` です。"

#: ../../library/sqlite3.rst:1056
msgid ""
"The name of the database to back up. Either ``\"main\"`` (the default) for "
"the main database, ``\"temp\"`` for the temporary database, or the name of a "
"custom database as attached using the ``ATTACH DATABASE`` SQL statement."
msgstr ""
"バックアップするデータベース名。 ``\"main\"`` (メイン・データベース。これがデ"
"フォルトです)、または ``\"temp\"`` (一時データベース)、 または ``ATTACH "
"DATABASE`` SQL文を使用して取り付けられたカスタム・データベース名の、いずれか"
"です。"

#: ../../library/sqlite3.rst:1063
msgid ""
"The number of seconds to sleep between successive attempts to back up "
"remaining pages."
msgstr "バックアップの指定ページ数単位の反復ごとにスリープする秒数。"

#: ../../library/sqlite3.rst:1067
msgid "Example 1, copy an existing database into another:"
msgstr "例 1. 既存のデータベースを別のデータベースにコピーします:"

#: ../../library/sqlite3.rst:1086
msgid "Example 2, copy an existing database into a transient copy:"
msgstr "例 2. 既存のデータベースを臨時コピー(transient copy)にコピーします。"

#: ../../library/sqlite3.rst:1098
msgid "Get a connection runtime limit."
msgstr "接続(connection)の実行時制限を取得します。"

#: ../../library/sqlite3.rst:1100
msgid "The `SQLite limit category`_ to be queried."
msgstr "問い合わせを行う実行時制限カテゴリー(`SQLite limit category`_)。"

#: ../../library/sqlite3.rst:1105 ../../library/sqlite3.rst:1142
msgid "If *category* is not recognised by the underlying SQLite library."
msgstr ""
"*category* に、 背後の SQLite ライブラリが認識できないカテゴリーを指定した場"
"合に送出されます。"

#: ../../library/sqlite3.rst:1108
msgid ""
"Example, query the maximum length of an SQL statement for :class:"
"`Connection` ``con`` (the default is 1000000000):"
msgstr ""
"例: :class:`Connection` の ``con`` の SQL 文の最大長を照会します (デフォルト"
"は 1000000000 です):"

#: ../../library/sqlite3.rst:1128
msgid ""
"Set a connection runtime limit. Attempts to increase a limit above its hard "
"upper bound are silently truncated to the hard upper bound. Regardless of "
"whether or not the limit was changed, the prior value of the limit is "
"returned."
msgstr ""
"接続の実行時制限を設定します。 コンパイル時上限を超えて制限を増やそうとする"
"と、 暗黙のうちにコンパイル時上限に切り捨てられます。 制限が変更されたかどう"
"かに関係なく、 制限の以前の値が返されます。"

#: ../../library/sqlite3.rst:1133
msgid "The `SQLite limit category`_ to be set."
msgstr "`SQLite limit category`_ を設定する。"

#: ../../library/sqlite3.rst:1136
msgid ""
"The value of the new limit. If negative, the current limit is unchanged."
msgstr "新しい制限の値。 負数の場合、 現在の制限は変更されません。"

#: ../../library/sqlite3.rst:1145
msgid ""
"Example, limit the number of attached databases to 1 for :class:`Connection` "
"``con`` (the default limit is 10):"
msgstr ""
"class:`Connection` の ``con`` に対して、取り付けられるデータベース(attached "
"databases)の数を 1 に制限します (デフォルトの制限は 10 です):"

#: ../../library/sqlite3.rst:1162
msgid ""
"Serialize a database into a :class:`bytes` object.  For an ordinary on-disk "
"database file, the serialization is just a copy of the disk file.  For an in-"
"memory database or a \"temp\" database, the serialization is the same "
"sequence of bytes which would be written to disk if that database were "
"backed up to disk."
msgstr ""
"データベースを :class:`bytes` オブジェクトに直列化(serialize)します。 通常の"
"ディスク上のデータベース・ファイルの場合、 直列化はディスク・ファイルの単なる"
"コピーです。 インメモリ・データベースまたは \"temp\" データベースの場合、 直"
"列化は、 そのデータベースがディスクにバックアップされた場合にディスクに書き込"
"まれるバイト・シーケンスと同じです。"

#: ../../library/sqlite3.rst:1168
msgid "The database name to be serialized. Defaults to ``\"main\"``."
msgstr "直列化するデータベース名。 デフォルトは ``\"main\"`` です。"

#: ../../library/sqlite3.rst:1176
msgid ""
"This method is only available if the underlying SQLite library has the "
"serialize API."
msgstr ""
"このメソッドは、 背後の SQLite ライブラリに直列化 API がある場合にのみ使用で"
"きます。"

#: ../../library/sqlite3.rst:1184
msgid ""
"Deserialize a :meth:`serialized <serialize>` database into a :class:"
"`Connection`. This method causes the database connection to disconnect from "
"database *name*, and reopen *name* as an in-memory database based on the "
"serialization contained in *data*."
msgstr ""
":meth:`直列化 <serialize>` されたデータベースを :class:`Connection` に、 脱直"
"列化(deserialize)します。 このメソッドにより、 データベース接続はデータベー"
"ス *name* から切断され、そして、  *data* に含まれる直列化データに基づいて、 "
"データベース *name* がインメモリ・データベースとして再度開かれます。"

#: ../../library/sqlite3.rst:1190
msgid "A serialized database."
msgstr "直列化されたデータベース。"

#: ../../library/sqlite3.rst:1193
msgid "The database name to deserialize into. Defaults to ``\"main\"``."
msgstr ""
"脱直列化(deserialize)したデータを入れるデータベース名。 デフォルトは "
"``\"main\"`` です。"

#: ../../library/sqlite3.rst:1197
msgid ""
"If the database connection is currently involved in a read transaction or a "
"backup operation."
msgstr "データベース接続が読み取りトランザクションやバックアップ操作中の場合。"

#: ../../library/sqlite3.rst:1201
msgid "If *data* does not contain a valid SQLite database."
msgstr "*data* に有効な SQLite データベースが含まれていない場合。"

#: ../../library/sqlite3.rst:1204
msgid "If :func:`len(data) <len>` is larger than ``2**63 - 1``."
msgstr ":func:`len(data) <len>` が ``2**63 - 1`` より大きい場合。"

#: ../../library/sqlite3.rst:1209
msgid ""
"This method is only available if the underlying SQLite library has the "
"deserialize API."
msgstr ""
"このメソッドは、 背後の SQLite ライブラリに脱直列化 API がある場合にのみ使用"
"できます。"

#: ../../library/sqlite3.rst:1216
msgid ""
"This read-only attribute corresponds to the low-level SQLite `autocommit "
"mode`_."
msgstr ""
"この読み取り専用属性は、低レベルの SQLite `autocommit mode`_ に対応します。"

#: ../../library/sqlite3.rst:1219
msgid ""
"``True`` if a transaction is active (there are uncommitted changes), "
"``False`` otherwise."
msgstr ""
"トランザクションがアクティブな場合 (コミットされていない変更がある場合) は "
"``True`` 、それ以外の場合は ``False`` です。"

#: ../../library/sqlite3.rst:1226
msgid ""
"This attribute controls the :ref:`transaction handling <sqlite3-controlling-"
"transactions>` performed by :mod:`!sqlite3`. If set to ``None``, "
"transactions are never implicitly opened. If set to one of ``\"DEFERRED\"``, "
"``\"IMMEDIATE\"``, or ``\"EXCLUSIVE\"``, corresponding to the underlying "
"`SQLite transaction behaviour`_, implicit :ref:`transaction management "
"<sqlite3-controlling-transactions>` is performed."
msgstr ""
"この属性は、 :mod:`!sqlite3` によって実行される :ref:`トランザクション処理 "
"<sqlite3-controlling-transactions>` を制御します。 ``None`` に設定すると、ト"
"ランザクションが暗黙に開かれることはありません。背後の SQLite ライブラリのト"
"ランザクションの振る舞い(`SQLite transaction behaviour`_)に対応する "
"``\"DEFERRED\"`` または ``\"IMMEDIATE\"`` または ``\"EXCLUSIVE\"`` のいずれか"
"に設定すると、暗黙の :ref:`トランザクション制御 <sqlite3-controlling-"
"transactions>` が実行されます。"

#: ../../library/sqlite3.rst:1234
msgid ""
"If not overridden by the *isolation_level* parameter of :func:`connect`, the "
"default is ``\"\"``, which is an alias for ``\"DEFERRED\"``."
msgstr ""
":func:`connect` の *isolation_level* パラメーターでオーバーライドされない場"
"合、 デフォルトは ``\"\"`` で、 これは ``\"DEFERRED\"`` の別名です。"

#: ../../library/sqlite3.rst:1239
msgid ""
"The initial :attr:`~Cursor.row_factory` for :class:`Cursor` objects created "
"from this connection. Assigning to this attribute does not affect the :attr:"
"`!row_factory` of existing cursors belonging to this connection, only new "
"ones. Is ``None`` by default, meaning each row is returned as a :class:"
"`tuple`."
msgstr ""
"この接続から作成された :class:`Cursor` オブジェクトの初期 :attr:`~Cursor."
"row_factory` 。この属性に割り当てを行っても、 この接続に属する、すでに存在す"
"るカーソルの :attr:`!row_factory` には影響せず、 この属性に割り当てを行った後"
"に作成する新しいカーソルのみに影響します。 デフォルトでは ``None`` です。つま"
"り、各行は :class:`タプル <tuple>` として返されます。"

#: ../../library/sqlite3.rst:1246 ../../library/sqlite3.rst:1528
#: ../../library/sqlite3.rst:1551
msgid "See :ref:`sqlite3-howto-row-factory` for more details."
msgstr "詳細は :ref:`sqlite3-howto-row-factory` をご覧下さい。"

#: ../../library/sqlite3.rst:1250
msgid ""
"A callable that accepts a :class:`bytes` parameter and returns a text "
"representation of it. The callable is invoked for SQLite values with the "
"``TEXT`` data type. By default, this attribute is set to :class:`str`. If "
"you want to return ``bytes`` instead, set *text_factory* to ``bytes``."
msgstr ""
":class:`bytes` のパラメータを受け取り、そのテキスト表現を返す呼び出し可能オブ"
"ジェクトです。呼び出し可能オブジェクトは ``TEXT`` データ型である SQLite 値に"
"対して呼び出されます。 デフォルトでは、 この属性は :class:`str` に設定されて"
"います。代わりに ``bytes`` を返したい場合は、 *text_factory* を ``bytes`` に"
"設定してください。"

#: ../../library/sqlite3.rst:1290
msgid ""
"Return the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr ""
"データベース接続が開かれてから、変更または挿入または削除されたデータベース行"
"の総数を返します。"

#: ../../library/sqlite3.rst:1297
msgid "Cursor objects"
msgstr "Cursor オブジェクト"

#: ../../library/sqlite3.rst:1299
msgid ""
"A ``Cursor`` object represents a `database cursor`_ which is used to execute "
"SQL statements, and manage the context of a fetch operation. Cursors are "
"created using :meth:`Connection.cursor`, or by using any of the :ref:"
"`connection shortcut methods <sqlite3-connection-shortcuts>`."
msgstr ""
"``Cursor`` オブジェクトは、 SQL 文を実行し、 取得操作(fetch operation)のコン"
"テキストを管理するために使用されるデータベース・カーソル(`database cursor`_)"
"を表します。カーソルは、 :meth:`Connection.cursor` または :ref:`接続"
"(connection)ショートカット・メソッド <sqlite3-connection-shortcuts>` の、いず"
"れかを使用して作成されます。"

#: ../../library/sqlite3.rst:1306
msgid ""
"Cursor objects are :term:`iterators <iterator>`, meaning that if you :meth:"
"`~Cursor.execute` a ``SELECT`` query, you can simply iterate over the cursor "
"to fetch the resulting rows:"
msgstr ""
"カーソル・オブジェクトは :term:`イテレータ <iterator>` です。つまり、 "
"``SELECT`` クエリに対して :meth:`~Cursor.execute` した場合、結果の行(rows)を"
"取得するためには、カーソルを単純に反復(iterate)できます:"

#: ../../library/sqlite3.rst:1331
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr ":class:`Cursor` インスタンスは以下の属性やメソッドを持ちます。"

#: ../../library/sqlite3.rst:1338
msgid ""
"Execute SQL a single SQL statement, optionally binding Python values using :"
"ref:`placeholders <sqlite3-placeholders>`."
msgstr ""
"単一の SQL 文を実行し、オプションで :ref:`プレースホルダ <sqlite3-"
"placeholders>` を使用して Python 値を結び付け(bind)ます。"

#: ../../library/sqlite3.rst:1342
msgid "A single SQL statement."
msgstr "単一の SQL 文。"

#: ../../library/sqlite3.rst:1345
msgid ""
"Python values to bind to placeholders in *sql*. A :class:`!dict` if named "
"placeholders are used. A :term:`!sequence` if unnamed placeholders are used. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"*sql* のプレースホルダに結び付け(bind)する Python 値。 名前付きプレースホルダ"
"が使用されている場合は :class:`!dict` です。 名前のないプレースホルダが使用さ"
"れている場合は :term:`!sequence` です。 :ref:`sqlite3-placeholders` を参照し"
"てください。"

#: ../../library/sqlite3.rst:1352
msgid "If *sql* contains more than one SQL statement."
msgstr "*sql* に複数の SQL 文が含まれている場合。"

#: ../../library/sqlite3.rst:1355
msgid ""
"If :attr:`~Connection.isolation_level` is not ``None``, *sql* is an "
"``INSERT``, ``UPDATE``, ``DELETE``, or ``REPLACE`` statement, and there is "
"no open transaction, a transaction is implicitly opened before executing "
"*sql*."
msgstr ""
":attr:`~Connection.isolation_level` が ``None`` で無い場合、 *sql* は "
"``INSERT`` または ``UPDATE`` または ``DELETE`` または ``REPLACE`` 文であり、 "
"開いているトランザクションがない場合、 *sql* を実行する前にトランザクションが"
"暗黙に開かれます。"

#: ../../library/sqlite3.rst:1360
msgid "Use :meth:`executescript` to execute multiple SQL statements."
msgstr "複数の SQL 文を実行するには :meth:`executescript` を使用します。"

#: ../../library/sqlite3.rst:1364
msgid ""
"For every item in *parameters*, repeatedly execute the :ref:`parameterized "
"<sqlite3-placeholders>` SQL statement *sql*."
msgstr ""
"*parameters* のすべての item に対して、 :ref:`パラメーター化 <sqlite3-"
"placeholders>` された SQL 文である *sql* を繰り返し実行します。"

#: ../../library/sqlite3.rst:1368
msgid "Uses the same implicit transaction handling as :meth:`~Cursor.execute`."
msgstr ""
":meth:`~Cursor.execute` と同一の暗黙のトランザクション処理を使用します。"

#: ../../library/sqlite3.rst:1370
msgid "A single SQL :abbr:`DML (Data Manipulation Language)` statement."
msgstr "単一の SQL :abbr:`DML (データ操作言語)` 文。"

#: ../../library/sqlite3.rst:1373
msgid ""
"An :term:`!iterable` of parameters to bind with the placeholders in *sql*. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"*sql* のプレースホルダに結び付け(bind)するためのパラメータの :term:`!"
"iterable` 。 :ref:`sqlite3-placeholders` 参照。"

#: ../../library/sqlite3.rst:1379
msgid ""
"If *sql* contains more than one SQL statement, or is not a DML statment."
msgstr "*sql* に複数の SQL 文トが含まれているか、または DML 文じゃない場合。"

#: ../../library/sqlite3.rst:1396
msgid ""
"Execute the SQL statements in *sql_script*. If there is a pending "
"transaction, an implicit ``COMMIT`` statement is executed first. No other "
"implicit transaction control is performed; any transaction control must be "
"added to *sql_script*."
msgstr ""
"*sql_script* 内の複数の SQL 文を実行します。 保留中のトランザクションがある場"
"合、 暗黙の ``COMMIT`` 文が最初に実行されます。 他の暗黙のトランザクション制"
"御は実行されません。 つまり、 *sql_script* にはトランザクション制御を追加する"
"必要があります。"

#: ../../library/sqlite3.rst:1402
msgid "*sql_script* must be a :class:`string <str>`."
msgstr "*sql_script* は :class:`文字列 <str>` でなければなりません。"

#: ../../library/sqlite3.rst:1420
msgid ""
"If :attr:`~Cursor.row_factory` is ``None``, return the next row query result "
"set as a :class:`tuple`. Else, pass it to the row factory and return its "
"result. Return ``None`` if no more data is available."
msgstr ""
":attr:`~Cursor.row_factory` が ``None`` の場合、 次の行のクエリ結果セットを :"
"class:`タプル <tuple>` として返します。それ以外の場合は、 それを行工場(row "
"factory)に渡し、 その結果を返します。 これ以上データが無い場合は ``None`` を"
"返します。"

#: ../../library/sqlite3.rst:1428
msgid ""
"Return the next set of rows of a query result as a :class:`list`. Return an "
"empty list if no more rows are available."
msgstr ""
"クエリ結果の次の行セットを :class:`list` として返します。行がそれ以上ない場合"
"は、空のリストを返します。"

#: ../../library/sqlite3.rst:1431
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If *size* is not given, :attr:`arraysize` determines the number of rows to "
"be fetched. If fewer than *size* rows are available, as many rows as are "
"available are returned."
msgstr ""
"呼び出しごとに取得する行数は、*size* パラメーターで指定されます。 *size* が指"
"定されていない場合、 :attr:`arraysize` が取得する行数を決定します。有効な行の"
"数が *size* 未満の場合は、有効な数の行が返されます。"

#: ../../library/sqlite3.rst:1437
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain "
"the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"*size* 引数とパフォーマンスの関係についての注意です。パフォーマンスを最適化す"
"るためには、大抵、 arraysize 属性を利用するのがベストです。 *size* 引数を利用"
"したのであれば、次回の :meth:`fetchmany` の呼び出しでも *size* 引数に同一の値"
"を指定するのがのがベストです。"

#: ../../library/sqlite3.rst:1444
msgid ""
"Return all (remaining) rows of a query result as a :class:`list`. Return an "
"empty list if no rows are available. Note that the :attr:`arraysize` "
"attribute can affect the performance of this operation."
msgstr ""
"クエリ結果の(残りの)すべての行を :class:`list` として返します。 有効な行がな"
"い場合は、空のリストを返します。 :attr:`arraysize` 属性は、この操作のパフォー"
"マンスに影響を与える可能性があることに注意してください。"

#: ../../library/sqlite3.rst:1451
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "(``__del__`` が呼び出される時ではなく、) 今すぐカーソルを閉じます。"

#: ../../library/sqlite3.rst:1453
msgid ""
"The cursor will be unusable from this point forward; a :exc:"
"`ProgrammingError` exception will be raised if any operation is attempted "
"with the cursor."
msgstr ""
"この時点から、このカーソルは使用できなくなります。今後、このカーソルで何らか"
"の操作を試みると、 :exc:`ProgrammingError` 例外が送出されます。"

#: ../../library/sqlite3.rst:1458 ../../library/sqlite3.rst:1462
msgid "Required by the DB-API. Does nothing in :mod:`!sqlite3`."
msgstr "DB-API で必要です。 :mod:`!sqlite3` では何もしません。"

#: ../../library/sqlite3.rst:1466
msgid ""
"Read/write attribute that controls the number of rows returned by :meth:"
"`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr ""
"fetchmany によって返される行(row)数を制御する、読み取りと書き込みが可能な属"
"性。 デフォルト値は 1 で、これは呼び出しごとに 1 行が取得されることを意味しま"
"す。"

#: ../../library/sqlite3.rst:1471
msgid ""
"Read-only attribute that provides the SQLite database :class:`Connection` "
"belonging to the cursor.  A :class:`Cursor` object created by calling :meth:"
"`con.cursor() <Connection.cursor>` will have a :attr:`connection` attribute "
"that refers to *con*:"
msgstr ""
"カーソルが属する SQLite データベース :class:`Connection` を提供する読み取り専"
"用属性。 :meth:`con.cursor() <Connection.cursor>` と呼び出して作成した :"
"class:`Cursor` オブジェクトには、*con* を参照する :attr:`connection` 属性があ"
"ります:"

#: ../../library/sqlite3.rst:1485
msgid ""
"Read-only attribute that provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are ``None``."
msgstr ""
"最後のクエリの列(column)名を提供する読み取り専用属性。 Python DB API との互換"
"性を維持するために、各列ごとに 7 項目のタプルで、先頭の項目が列名、残りの6項"
"目が ``None`` です。"

#: ../../library/sqlite3.rst:1489
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr ""
"この属性は ``SELECT`` 文にマッチする行(row)が1つもなかった場合でもセットされ"
"ます。"

#: ../../library/sqlite3.rst:1493
msgid ""
"Read-only attribute that provides the row id of the last inserted row. It is "
"only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany` "
"or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is "
"``None``."
msgstr ""
"最後に挿入された行の行 ID (row id) を提供する読み取り専用属性。 :meth:"
"`execute`  で ``INSERT`` または ``REPLACE`` 文が成功した後にのみ更新されま"
"す。他のSQL文や、 :meth:`executemany` の後や、 :meth:`executescript` の後"
"や、 挿入が失敗した場合、 ``lastrowid`` の値は変更されません。``lastrowid`` "
"の初期値は ``None`` です。"

#: ../../library/sqlite3.rst:1501
msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr "``WITHOUT ROWID`` テーブルへの挿入(insert)は記録されません。"

#: ../../library/sqlite3.rst:1503
msgid "Added support for the ``REPLACE`` statement."
msgstr "``REPLACE`` 文のサポートが追加されました。"

#: ../../library/sqlite3.rst:1508
msgid ""
"Read-only attribute that provides the number of modified rows for "
"``INSERT``, ``UPDATE``, ``DELETE``, and ``REPLACE`` statements; is ``-1`` "
"for other statements, including :abbr:`CTE (Common Table Expression)` "
"queries. It is only updated by the :meth:`execute` and :meth:`executemany` "
"methods."
msgstr ""
"``INSERT`` や ``UPDATE`` や ``DELETE`` や ``REPLACE`` 文で変更された行数を提"
"供する読み取り専用属性。 :abbr:`CTE (共通テーブル式)` クエリを含む他のSQL文"
"は ``-1`` です。 :meth:`execute` と :meth:`executemany` メソッドによってのみ"
"更新されます。"

#: ../../library/sqlite3.rst:1516
msgid ""
"Control how a row fetched from this :class:`!Cursor` is represented. If "
"``None``, a row is represented as a :class:`tuple`. Can be set to the "
"included :class:`sqlite3.Row`; or a :term:`callable` that accepts two "
"arguments, a :class:`Cursor` object and the :class:`!tuple` of row values, "
"and returns a custom object representing an SQLite row."
msgstr ""
"この :class:`カーソル <!Cursor>` から取得された行の表現方法を制御します。 "
"``None`` の場合、行は :class:`タプル <tuple>` として表されます。 :class:"
"`sqlite3.Row` に設定でき。そしてまた :class:`Cursor` オブジェクトと、 行の値"
"の :class:`タプル <!tuple>` の、 2 つの引数を受け取り、 SQLite の行(row)を表"
"すカスタム・オブジェクトを返す、 :term:`呼び出し可能オブジェクト <callable>` "
"に設定できます。"

#: ../../library/sqlite3.rst:1523
msgid ""
"Defaults to what :attr:`Connection.row_factory` was set to when the :class:`!"
"Cursor` was created. Assigning to this attribute does not affect :attr:"
"`Connection.row_factory` of the parent connection."
msgstr ""

#: ../../library/sqlite3.rst:1539
msgid "Row objects"
msgstr ""

#: ../../library/sqlite3.rst:1543
msgid ""
"A :class:`!Row` instance serves as a highly optimized :attr:`~Connection."
"row_factory` for :class:`Connection` objects. It supports iteration, "
"equality testing, :func:`len`, and :term:`mapping` access by column name and "
"index."
msgstr ""

#: ../../library/sqlite3.rst:1548
msgid ""
"Two :class:`!Row` objects compare equal if they have identical column names "
"and values."
msgstr ""

#: ../../library/sqlite3.rst:1555
msgid ""
"Return a :class:`list` of column names as :class:`strings <str>`. "
"Immediately after a query, it is the first member of each tuple in :attr:"
"`Cursor.description`."
msgstr ""

#: ../../library/sqlite3.rst:1559
msgid "Added support of slicing."
msgstr "スライスがサポートされました。"

#: ../../library/sqlite3.rst:1566
msgid "Blob objects"
msgstr ""

#: ../../library/sqlite3.rst:1572
msgid ""
"A :class:`Blob` instance is a :term:`file-like object` that can read and "
"write data in an SQLite :abbr:`BLOB (Binary Large OBject)`. Call :func:"
"`len(blob) <len>` to get the size (number of bytes) of the blob. Use indices "
"and :term:`slices <slice>` for direct access to the blob data."
msgstr ""

#: ../../library/sqlite3.rst:1577
msgid ""
"Use the :class:`Blob` as a :term:`context manager` to ensure that the blob "
"handle is closed after use."
msgstr ""

#: ../../library/sqlite3.rst:1607
msgid "Close the blob."
msgstr ""

#: ../../library/sqlite3.rst:1609
msgid ""
"The blob will be unusable from this point onward.  An :class:`~sqlite3."
"Error` (or subclass) exception will be raised if any further operation is "
"attempted with the blob."
msgstr ""

#: ../../library/sqlite3.rst:1615
msgid ""
"Read *length* bytes of data from the blob at the current offset position. If "
"the end of the blob is reached, the data up to :abbr:`EOF (End of File)` "
"will be returned.  When *length* is not specified, or is negative, :meth:"
"`~Blob.read` will read until the end of the blob."
msgstr ""

#: ../../library/sqlite3.rst:1623
msgid ""
"Write *data* to the blob at the current offset.  This function cannot change "
"the blob length.  Writing beyond the end of the blob will raise :exc:"
"`ValueError`."
msgstr ""

#: ../../library/sqlite3.rst:1629
msgid "Return the current access position of the blob."
msgstr ""

#: ../../library/sqlite3.rst:1633
msgid ""
"Set the current access position of the blob to *offset*.  The *origin* "
"argument defaults to :data:`os.SEEK_SET` (absolute blob positioning). Other "
"values for *origin* are :data:`os.SEEK_CUR` (seek relative to the current "
"position) and :data:`os.SEEK_END` (seek relative to the blob’s end)."
msgstr ""

#: ../../library/sqlite3.rst:1641
msgid "PrepareProtocol objects"
msgstr ""

#: ../../library/sqlite3.rst:1645
msgid ""
"The PrepareProtocol type's single purpose is to act as a :pep:`246` style "
"adaption protocol for objects that can :ref:`adapt themselves <sqlite3-"
"conform>` to :ref:`native SQLite types <sqlite3-types>`."
msgstr ""

#: ../../library/sqlite3.rst:1653
msgid "Exceptions"
msgstr "例外"

#: ../../library/sqlite3.rst:1655
msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr "例外の階層は DB-API 2.0 (:pep:`249`) で定義されています。"

#: ../../library/sqlite3.rst:1659
msgid ""
"This exception is not currently raised by the :mod:`!sqlite3` module, but "
"may be raised by applications using :mod:`!sqlite3`, for example if a user-"
"defined function truncates data while inserting. ``Warning`` is a subclass "
"of :exc:`Exception`."
msgstr ""

#: ../../library/sqlite3.rst:1666
msgid ""
"The base class of the other exceptions in this module. Use this to catch all "
"errors with one single :keyword:`except` statement. ``Error`` is a subclass "
"of :exc:`Exception`."
msgstr ""

#: ../../library/sqlite3.rst:1670
msgid ""
"If the exception originated from within the SQLite library, the following "
"two attributes are added to the exception:"
msgstr ""

#: ../../library/sqlite3.rst:1675
msgid ""
"The numeric error code from the `SQLite API <https://sqlite.org/rescode."
"html>`_"
msgstr ""

#: ../../library/sqlite3.rst:1682
msgid ""
"The symbolic name of the numeric error code from the `SQLite API <https://"
"sqlite.org/rescode.html>`_"
msgstr ""

#: ../../library/sqlite3.rst:1689
msgid ""
"Exception raised for misuse of the low-level SQLite C API. In other words, "
"if this exception is raised, it probably indicates a bug in the :mod:`!"
"sqlite3` module. ``InterfaceError`` is a subclass of :exc:`Error`."
msgstr ""

#: ../../library/sqlite3.rst:1696
msgid ""
"Exception raised for errors that are related to the database. This serves as "
"the base exception for several types of database errors. It is only raised "
"implicitly through the specialised subclasses. ``DatabaseError`` is a "
"subclass of :exc:`Error`."
msgstr ""

#: ../../library/sqlite3.rst:1703
msgid ""
"Exception raised for errors caused by problems with the processed data, like "
"numeric values out of range, and strings which are too long. ``DataError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:1709
msgid ""
"Exception raised for errors that are related to the database's operation, "
"and not necessarily under the control of the programmer. For example, the "
"database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:1717
msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:1722
msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:1729
msgid ""
"Exception raised for :mod:`!sqlite3` API programming errors, for example "
"supplying the wrong number of bindings to a query, or trying to operate on a "
"closed :class:`Connection`. ``ProgrammingError`` is a subclass of :exc:"
"`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:1736
msgid ""
"Exception raised in case a method or database API is not supported by the "
"underlying SQLite library. For example, setting *deterministic* to ``True`` "
"in :meth:`~Connection.create_function`, if the underlying SQLite library "
"does not support deterministic functions. ``NotSupportedError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:1746
msgid "SQLite and Python types"
msgstr "SQLite と Python の型"

#: ../../library/sqlite3.rst:1748
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr ""
"SQLite は以下の型をネイティブにサポートします: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``。"

#: ../../library/sqlite3.rst:1751
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr "したがって、次の Python の型は問題なく SQLite に送り込めます:"

#: ../../library/sqlite3.rst:1754 ../../library/sqlite3.rst:1771
msgid "Python type"
msgstr "Python の型"

#: ../../library/sqlite3.rst:1754 ../../library/sqlite3.rst:1771
msgid "SQLite type"
msgstr "SQLite の型"

#: ../../library/sqlite3.rst:1756 ../../library/sqlite3.rst:1773
msgid "``None``"
msgstr "``None``"

#: ../../library/sqlite3.rst:1756 ../../library/sqlite3.rst:1773
msgid "``NULL``"
msgstr "``NULL``"

#: ../../library/sqlite3.rst:1758 ../../library/sqlite3.rst:1775
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/sqlite3.rst:1758 ../../library/sqlite3.rst:1775
msgid "``INTEGER``"
msgstr "``INTEGER``"

#: ../../library/sqlite3.rst:1760 ../../library/sqlite3.rst:1777
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/sqlite3.rst:1760 ../../library/sqlite3.rst:1777
msgid "``REAL``"
msgstr "``REAL``"

#: ../../library/sqlite3.rst:1762
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/sqlite3.rst:1762 ../../library/sqlite3.rst:1779
msgid "``TEXT``"
msgstr "``TEXT``"

#: ../../library/sqlite3.rst:1764 ../../library/sqlite3.rst:1782
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/sqlite3.rst:1764 ../../library/sqlite3.rst:1782
msgid "``BLOB``"
msgstr "``BLOB``"

#: ../../library/sqlite3.rst:1768
msgid "This is how SQLite types are converted to Python types by default:"
msgstr "SQLite の型から Python の型へのデフォルトでの変換は以下の通りです:"

#: ../../library/sqlite3.rst:1779
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr ""
":attr:`~Connection.text_factory` に依存する。デフォルトでは :class:`str` 。"

#: ../../library/sqlite3.rst:1785
msgid ""
"The type system of the :mod:`!sqlite3` module is extensible in two ways: you "
"can store additional Python types in an SQLite database via :ref:`object "
"adapters <sqlite3-adapters>`, and you can let the :mod:`!sqlite3` module "
"convert SQLite types to Python types via :ref:`converters <sqlite3-"
"converters>`."
msgstr ""

#: ../../library/sqlite3.rst:1795
msgid "Default adapters and converters"
msgstr "デフォルトの適合関数と変換関数"

#: ../../library/sqlite3.rst:1797
msgid ""
"There are default adapters for the date and datetime types in the datetime "
"module. They will be sent as ISO dates/ISO timestamps to SQLite."
msgstr ""
"datetime モジュールの date 型および datetime 型のためのデフォルト適合関数があ"
"ります。これらの型は ISO 日付 / ISO タイムスタンプとして SQLite に送られま"
"す。"

#: ../../library/sqlite3.rst:1800
msgid ""
"The default converters are registered under the name \"date\" for :class:"
"`datetime.date` and under the name \"timestamp\" for :class:`datetime."
"datetime`."
msgstr ""
"デフォルトの変換関数は :class:`datetime.date` 用が \"date\" という名前で、 :"
"class:`datetime.datetime` 用が \"timestamp\" という名前で登録されています。"

#: ../../library/sqlite3.rst:1804
msgid ""
"This way, you can use date/timestamps from Python without any additional "
"fiddling in most cases. The format of the adapters is also compatible with "
"the experimental SQLite date/time functions."
msgstr ""
"これにより、多くの場合特別な細工無しに Python の日付 / タイムスタンプを使えま"
"す。適合関数の書式は実験的な SQLite の date/time 関数とも互換性があります。"

#: ../../library/sqlite3.rst:1808
msgid "The following example demonstrates this."
msgstr "以下の例でこのことを確かめます。"

#: ../../library/sqlite3.rst:1812
msgid ""
"If a timestamp stored in SQLite has a fractional part longer than 6 numbers, "
"its value will be truncated to microsecond precision by the timestamp "
"converter."
msgstr ""
"SQLite に格納されているタイムスタンプが6桁より長い小数部を持っている場合、タ"
"イムスタンプの変換関数によってマイクロ秒精度に丸められます。"

#: ../../library/sqlite3.rst:1818
msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""

#: ../../library/sqlite3.rst:1827
msgid "How-to guides"
msgstr ""

#: ../../library/sqlite3.rst:1832
msgid "How to use placeholders to bind values in SQL queries"
msgstr "プレースホルダを使用して SQL クエリに値を結び付ける方法"

#: ../../library/sqlite3.rst:1834
msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to `SQL injection attacks`_. For example, an attacker can simply "
"close the single quote and inject ``OR TRUE`` to select all rows::"
msgstr ""
"たいてい、SQL 操作は Python 変数の値を使う必要があります。しかし、 Python の"
"文字列操作を使用してクエリを組み立てるのはSQLインジェクション攻撃(`SQL "
"injection attacks`_)に対して脆弱なので注意が必要です。たとえば、攻撃者は以下"
"のように単純にシングルクォートを閉じて ``OR TRUE`` を挿入してすべての行を選択"
"できます::"

#: ../../library/sqlite3.rst:1847
msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the "
"second argument of the cursor's :meth:`~Cursor.execute` method."
msgstr ""
"代わりに、DB-API のパラメータ割り当てを使います。クエリ文字列にPythonの変数を"
"挿入するには、クエリ文字列中でプレースホルダを使用し、 かつ、 カーソルの :"
"meth:`~Cursor.execute` メソッドの 2 番目の引数にPythonの変数を値の :class:`タ"
"プル <tuple>` として指定することにより、 実際の値をクエリに割り当てます。"

#: ../../library/sqlite3.rst:1852
msgid ""
"An SQL statement may use one of two kinds of placeholders: question marks "
"(qmark style) or named placeholders (named style). For the qmark style, "
"*parameters* must be a :term:`sequence` whose length must match the number "
"of placeholders, or a :exc:`ProgrammingError` is raised. For the named "
"style, *parameters* should be an instance of a :class:`dict` (or a "
"subclass), which must contain keys for all named parameters; any extra items "
"are ignored. Here's an example of both styles:"
msgstr ""
"SQL 文では、クエスチョンマーク(qmark タイル)または名前付きプレースホルダ"
"( named スタイル)の 2 種類のプレースホルダのどちらかを使用できます。 qmark ス"
"タイルの場合、 *パラメータ* は、その長さがプレースホルダの数と一致する必要が"
"ある :term:`シーケンス <sequence>` でなければなりません。さもないと、 :exc:"
"`ProgrammingError` が送出されます。  named スタイルの場合、 *パラメータ* は :"
"class:`dict` (またはそのサブクラス) のインスタンスである必要があり、これには"
"すべての名前付きパラメータのキーが含まれている必要があります。 余分な項目は無"
"視されます。 以下に両方のスタイルの例を示します:"

#: ../../library/sqlite3.rst:1889
msgid ""
":pep:`249` numeric placeholders are *not* supported. If used, they will be "
"interpreted as named placeholders."
msgstr ""
":pep:`249` numeric プレースホルダは *サポートされていません* 。 使用すると、"
"名前付きプレースホルダとして解釈されます。"

#: ../../library/sqlite3.rst:1896
msgid "How to adapt custom Python types to SQLite values"
msgstr "カスタム Python 型を SQLite 値に適合させる方法"

#: ../../library/sqlite3.rst:1898
msgid ""
"SQLite supports only a limited set of data types natively. To store custom "
"Python types in SQLite databases, *adapt* them to one of the :ref:`Python "
"types SQLite natively understands <sqlite3-types>`."
msgstr ""

#: ../../library/sqlite3.rst:1902
msgid ""
"There are two ways to adapt Python objects to SQLite types: letting your "
"object adapt itself, or using an *adapter callable*. The latter will take "
"precedence above the former. For a library that exports a custom type, it "
"may make sense to enable that type to adapt itself. As an application "
"developer, it may make more sense to take direct control by registering "
"custom adapter functions."
msgstr ""

#: ../../library/sqlite3.rst:1914
msgid "How to write adaptable objects"
msgstr ""

#: ../../library/sqlite3.rst:1916
msgid ""
"Suppose we have a :class:`!Point` class that represents a pair of "
"coordinates, ``x`` and ``y``, in a Cartesian coordinate system. The "
"coordinate pair will be stored as a text string in the database, using a "
"semicolon to separate the coordinates. This can be implemented by adding a "
"``__conform__(self, protocol)`` method which returns the adapted value. The "
"object passed to *protocol* will be of type :class:`PrepareProtocol`."
msgstr ""

#: ../../library/sqlite3.rst:1947
msgid "How to register adapter callables"
msgstr "適合関数の登録方法"

#: ../../library/sqlite3.rst:1949
msgid ""
"The other possibility is to create a function that converts the Python "
"object to an SQLite-compatible type. This function can then be registered "
"using :func:`register_adapter`."
msgstr ""

#: ../../library/sqlite3.rst:1979
msgid "How to convert SQLite values to custom Python types"
msgstr "SQLite 値をカスタム Python 型に変換する方法"

#: ../../library/sqlite3.rst:1981
msgid ""
"Writing an adapter lets you convert *from* custom Python types *to* SQLite "
"values. To be able to convert *from* SQLite values *to* custom Python types, "
"we use *converters*."
msgstr ""

#: ../../library/sqlite3.rst:1986
msgid ""
"Let's go back to the :class:`!Point` class. We stored the x and y "
"coordinates separated via semicolons as strings in SQLite."
msgstr ""

#: ../../library/sqlite3.rst:1989
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`!Point` object from it."
msgstr ""

#: ../../library/sqlite3.rst:1994
msgid ""
"Converter functions are **always** passed a :class:`bytes` object, no matter "
"the underlying SQLite data type."
msgstr ""

#: ../../library/sqlite3.rst:2003
msgid ""
"We now need to tell :mod:`!sqlite3` when it should convert a given SQLite "
"value. This is done when connecting to a database, using the *detect_types* "
"parameter of :func:`connect`. There are three options:"
msgstr ""

#: ../../library/sqlite3.rst:2007
msgid "Implicit: set *detect_types* to :const:`PARSE_DECLTYPES`"
msgstr ""

#: ../../library/sqlite3.rst:2008
msgid "Explicit: set *detect_types* to :const:`PARSE_COLNAMES`"
msgstr ""

#: ../../library/sqlite3.rst:2009
msgid ""
"Both: set *detect_types* to ``sqlite3.PARSE_DECLTYPES | sqlite3."
"PARSE_COLNAMES``. Column names take precedence over declared types."
msgstr ""

#: ../../library/sqlite3.rst:2013
msgid "The following example illustrates the implicit and explicit approaches:"
msgstr ""

#: ../../library/sqlite3.rst:2064
msgid "Adapter and converter recipes"
msgstr "適合関数と変換関数のレシピ集"

#: ../../library/sqlite3.rst:2066
msgid "This section shows recipes for common adapters and converters."
msgstr "この節では一般的な適合関数と変換関数のレシピを紹介します。"

#: ../../library/sqlite3.rst:2128
msgid "How to use connection shortcut methods"
msgstr ""

#: ../../library/sqlite3.rst:2130
msgid ""
"Using the :meth:`~Connection.execute`, :meth:`~Connection.executemany`, and :"
"meth:`~Connection.executescript` methods of the :class:`Connection` class, "
"your code can be written more concisely because you don't have to create the "
"(often superfluous) :class:`Cursor` objects explicitly. Instead, the :class:"
"`Cursor` objects are created implicitly and these shortcut methods return "
"the cursor objects. This way, you can execute a ``SELECT`` statement and "
"iterate over it directly using only a single call on the :class:`Connection` "
"object."
msgstr ""

#: ../../library/sqlite3.rst:2171
msgid "How to use the connection context manager"
msgstr ""

#: ../../library/sqlite3.rst:2173
msgid ""
"A :class:`Connection` object can be used as a context manager that "
"automatically commits or rolls back open transactions when leaving the body "
"of the context manager. If the body of the :keyword:`with` statement "
"finishes without exceptions, the transaction is committed. If this commit "
"fails, or if the body of the ``with`` statement raises an uncaught "
"exception, the transaction is rolled back."
msgstr ""

#: ../../library/sqlite3.rst:2182
msgid ""
"If there is no open transaction upon leaving the body of the ``with`` "
"statement, the context manager is a no-op."
msgstr ""

#: ../../library/sqlite3.rst:2187
msgid ""
"The context manager neither implicitly opens a new transaction nor closes "
"the connection."
msgstr ""

#: ../../library/sqlite3.rst:2220
msgid "How to work with SQLite URIs"
msgstr "SQLite URI の操作方法"

#: ../../library/sqlite3.rst:2222
msgid "Some useful URI tricks include:"
msgstr "URI の小技をいくつか紹介します:"

#: ../../library/sqlite3.rst:2224
msgid "Open a database in read-only mode:"
msgstr "データベースを読み取り専用で開きます:"

#: ../../library/sqlite3.rst:2233
msgid ""
"Do not implicitly create a new database file if it does not already exist; "
"will raise :exc:`~sqlite3.OperationalError` if unable to create a new file:"
msgstr ""
"まだ存在しない場合、新しいデータベース・ファイルを暗黙に作成しません。なお、"
"新しいファイルが作成できない場合には :exc:`~sqlite3.OperationalError` が送出"
"されます:"

#: ../../library/sqlite3.rst:2243
msgid "Create a shared named in-memory database:"
msgstr "共有の名前付きインメモリ・データベースを作成します:"

#: ../../library/sqlite3.rst:2257
msgid ""
"More information about this feature, including a list of parameters, can be "
"found in the `SQLite URI documentation`_."
msgstr ""

#: ../../library/sqlite3.rst:2266
msgid "How to create and use row factories"
msgstr "行工場(row factories)の作成方法と使用方法"

#: ../../library/sqlite3.rst:2268
msgid ""
"By default, :mod:`!sqlite3` represents each row as a :class:`tuple`. If a :"
"class:`!tuple` does not suit your needs, you can use the :class:`sqlite3."
"Row` class or a custom :attr:`~Cursor.row_factory`."
msgstr ""

#: ../../library/sqlite3.rst:2273
msgid ""
"While :attr:`!row_factory` exists as an attribute both on the :class:"
"`Cursor` and the :class:`Connection`, it is recommended to set :class:"
"`Connection.row_factory`, so all cursors created from the connection will "
"use the same row factory."
msgstr ""

#: ../../library/sqlite3.rst:2278
msgid ""
":class:`!Row` provides indexed and case-insensitive named access to columns, "
"with minimal memory overhead and performance impact over a :class:`!tuple`. "
"To use :class:`!Row` as a row factory, assign it to the :attr:`!row_factory` "
"attribute:"
msgstr ""

#: ../../library/sqlite3.rst:2288
msgid "Queries now return :class:`!Row` objects:"
msgstr ""

#: ../../library/sqlite3.rst:2303
msgid ""
"You can create a custom :attr:`~Cursor.row_factory` that returns each row as "
"a :class:`dict`, with column names mapped to values:"
msgstr ""

#: ../../library/sqlite3.rst:2312
msgid ""
"Using it, queries now return a :class:`!dict` instead of a :class:`!tuple`:"
msgstr ""

#: ../../library/sqlite3.rst:2322
msgid "The following row factory returns a :term:`named tuple`:"
msgstr ""

#: ../../library/sqlite3.rst:2333
msgid ":func:`!namedtuple_factory` can be used as follows:"
msgstr ""

#: ../../library/sqlite3.rst:2348
msgid ""
"With some adjustments, the above recipe can be adapted to use a :class:"
"`~dataclasses.dataclass`, or any other custom class, instead of a :class:"
"`~collections.namedtuple`."
msgstr ""

#: ../../library/sqlite3.rst:2356
msgid "Explanation"
msgstr "説明"

#: ../../library/sqlite3.rst:2361
msgid "Transaction control"
msgstr "トランザクション制御"

#: ../../library/sqlite3.rst:2363
msgid ""
"The :mod:`!sqlite3` module does not adhere to the transaction handling "
"recommended by :pep:`249`."
msgstr ""
":mod:`!sqlite3` モジュールは、 :pep:`249` で推奨されているトランザクション処"
"理に準拠していません。"

#: ../../library/sqlite3.rst:2366
msgid ""
"If the connection attribute :attr:`~Connection.isolation_level` is not "
"``None``, new transactions are implicitly opened before :meth:`~Cursor."
"execute` and :meth:`~Cursor.executemany` executes ``INSERT``, ``UPDATE``, "
"``DELETE``, or ``REPLACE`` statements; for other statements, no implicit "
"transaction handling is performed. Use the :meth:`~Connection.commit` and :"
"meth:`~Connection.rollback` methods to respectively commit and roll back "
"pending transactions. You can choose the underlying `SQLite transaction "
"behaviour`_ — that is, whether and what type of ``BEGIN`` statements :mod:`!"
"sqlite3` implicitly executes – via the :attr:`~Connection.isolation_level` "
"attribute."
msgstr ""
"接続属性 :attr:`~Connection.isolation_level` が ``None`` で無いのなら、 :"
"meth:`~Cursor.execute` や :meth:`~Cursor.executemany` が  ``INSERT`` または "
"``UPDATE`` または ``DELETE`` または ``REPLACE`` 文を実行する前に新しいトラン"
"ザクションが暗黙に開かれます。それ以外のSQL文では暗黙のトランザクション処理は"
"行われません。 :meth:`~Connection.commit` メソッドや :meth:`~Connection."
"rollback` メソッドを使用して、 保留中のトランザクションをそれぞれコミットおよ"
"びロールバックします。あなたは、背後にある SQLite ライブラリのトランザクショ"
"ンの振る舞い(`SQLite transaction behaviour`_) — つまり、 sqlite3 が暗黙に実行"
"する ``BEGIN`` 文の有無とその種類 – を、 :attr:`~Connection.isolation_level` "
"属性を介して選択できます。"

#: ../../library/sqlite3.rst:2379
msgid ""
"If :attr:`~Connection.isolation_level` is set to ``None``, no transactions "
"are implicitly opened at all. This leaves the underlying SQLite library in "
"`autocommit mode`_, but also allows the user to perform their own "
"transaction handling using explicit SQL statements. The underlying SQLite "
"library autocommit mode can be queried using the :attr:`~Connection."
"in_transaction` attribute."
msgstr ""
":attr:`~Connection.isolation_level` が ``None`` に設定されていると、トランザ"
"クションは暗黙に開かれません。これにより、背後にある SQLite ライブラリを自動"
"コミット・モード(`autocommit mode`_)にしたまま、 明示的な SQL 文を使用して、 "
"ユーザが独自のトランザクション処理を行えるようにします。背後にある SQLite ラ"
"イブラリの自動コミット・モードは、 :attr:`~Connection.in_transaction` 属性を"
"使用して問い合わせできます。"

#: ../../library/sqlite3.rst:2387
msgid ""
"The :meth:`~Cursor.executescript` method implicitly commits any pending "
"transaction before execution of the given SQL script, regardless of the "
"value of :attr:`~Connection.isolation_level`."
msgstr ""
":meth:`~Cursor.executescript` メソッドは、 :attr:`~Connection."
"isolation_level` の値に関係なく、与えられた SQL スクリプトの実行前に、保留中"
"のトランザクションを暗黙にコミットします。"

#: ../../library/sqlite3.rst:2391
msgid ""
":mod:`!sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr ""
":mod:`!sqlite3` は、 DDL文の前に、開いているトランザクションを暗黙にコミット"
"していました。これはもはや当てはまりません。"
