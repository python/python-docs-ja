# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-05 15:01+0000\n"
"PO-Revision-Date: 2018-06-29 17:23+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/weakref.rst:2
msgid ":mod:`weakref` --- Weak references"
msgstr ":mod:`weakref` --- å¼±å‚ç…§"

#: ../../library/weakref.rst:12
msgid "**Source code:** :source:`Lib/weakref.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/weakref.py`"

#: ../../library/weakref.rst:16
msgid ""
"The :mod:`weakref` module allows the Python programmer to create :dfn:`weak "
"references` to objects."
msgstr ""
":mod:`weakref` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€Pythonãƒ—ãƒ­ã‚°ãƒ©ãƒãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¼±å‚ç…§ (:dfn:`weak "
"refarence`)ã‚’ä½œæˆã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/weakref.rst:22
msgid ""
"In the following, the term :dfn:`referent` means the object which is "
"referred to by a weak reference."
msgstr "ä»¥ä¸‹ã§ã¯ã€ç”¨èªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆ(:dfn:`referent`) ã¯å¼±å‚ç…§ãŒå‚ç…§ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../library/weakref.rst:25
msgid ""
"A weak reference to an object is not enough to keep the object alive: when "
"the only remaining references to a referent are weak references, "
":term:`garbage collection` is free to destroy the referent and reuse its "
"memory for something else.  However, until the object is actually destroyed "
"the weak reference may return the object even if there are no strong "
"references to it."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¼±å‚ç…§ãŒã‚ã‚‹ã“ã¨ã¯ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿã‹ã—ã¦ãŠãã®ã«ã¯ä¸ååˆ†ã§ã™ã€‚ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆã¸ã®å‚ç…§ãŒå¼±å‚ç…§ã—ã‹æ®‹ã£ã¦ã„ãªã„å ´åˆã€ "
":term:`garbage collection` "
"ã¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆã‚’è‡ªç”±ã«ç ´æ£„ã—ã€ãƒ¡ãƒ¢ãƒªã‚’åˆ¥ã®ã‚‚ã®ã«å†åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã—ã‹ã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¼·å‚ç…§ãŒãªãã¦ã‚‚ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå®Ÿéš›ã«ç ´æ£„ã•ã‚Œã‚‹ã¾ã§ã¯ã€å¼±å‚ç…§ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™å ´åˆãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/weakref.rst:31
msgid ""
"A primary use for weak references is to implement caches or mappings holding"
" large objects, where it's desired that a large object not be kept alive "
"solely because it appears in a cache or mapping."
msgstr ""
"å¼±å‚ç…§ã®ä¸»ãªç”¨é€”ã¯ã€å·¨å¤§ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿æŒã™ã‚‹ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚„ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã“ã§ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚„ãƒãƒƒãƒ”ãƒ³ã‚°ã«ä¿æŒã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã¨ã„ã†ç†ç”±ã ã‘ã§ã€å·¨å¤§ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿãç¶šã‘ã‚‹ã“ã¨ã¯æœ›ã¾ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/weakref.rst:35
msgid ""
"For example, if you have a number of large binary image objects, you may "
"wish to associate a name with each.  If you used a Python dictionary to map "
"names to images, or images to names, the image objects would remain alive "
"just because they appeared as values or keys in the dictionaries.  The "
":class:`WeakKeyDictionary` and :class:`WeakValueDictionary` classes supplied"
" by the :mod:`weakref` module are an alternative, using weak references to "
"construct mappings that don't keep objects alive solely because they appear "
"in the mapping objects.  If, for example, an image object is a value in a "
":class:`WeakValueDictionary`, then when the last remaining references to "
"that image object are the weak references held by weak mappings, garbage "
"collection can reclaim the object, and its corresponding entries in weak "
"mappings are simply deleted."
msgstr ""
"ä¾‹ãˆã°ã€å·¨å¤§ãªãƒã‚¤ãƒŠãƒªç”»åƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãŸãã•ã‚“ã‚ã‚Šã€ãã‚Œãã‚Œã«åå‰ã‚’é–¢é€£ä»˜ã‘ãŸã„ã¨ã—ã¾ã™ã€‚ Python "
"ã®è¾æ›¸å‹ã‚’ä½¿ã£ã¦åå‰ã‚’ç”»åƒã«å¯¾å¿œä»˜ã‘ãŸã‚Šç”»åƒã‚’åå‰ã«å¯¾å¿œä»˜ã‘ãŸã‚Šã™ã‚‹ã¨ã€ç”»åƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è¾æ›¸å†…ã®ã‚­ãƒ¼ã‚„å€¤ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ãŸã‚å­˜ç¶šã—ã¤ã¥ã‘ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"
" :mod:`weakref` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæä¾›ã—ã¦ã„ã‚‹ :class:`WeakKeyDictionary` ã‚„ "
":class:`WeakValueDictionary` "
"ã‚¯ãƒ©ã‚¹ã¯ãã®ä»£ç”¨ã§ã€å¯¾å¿œä»˜ã‘ã‚’æ§‹ç¯‰ã™ã‚‹ã®ã«å¼±å‚ç…§ã‚’ä½¿ã„ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚„ãƒãƒƒãƒ”ãƒ³ã‚°ã«å­˜åœ¨ã™ã‚‹ã¨ã„ã†ç†ç”±ã ã‘ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å­˜ç¶šã•ã›ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚‚ã—ã‚ã‚‹ç”»åƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ"
" :class:`WeakValueDictionary` "
"ã®å€¤ã«ãªã£ã¦ã„ãŸå ´åˆã€æœ€å¾Œã«æ®‹ã£ãŸç”»åƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’å¼±å‚ç…§ãƒãƒƒãƒ”ãƒ³ã‚°ãŒä¿æŒã—ã¦ã„ã‚Œã°ã€ã‚¬ãƒ¼ãƒ™ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¯ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†åˆ©ç”¨ã§ãã€ç”»åƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å¼±å‚ç…§å†…ã®å¯¾å¿œä»˜ã‘ã¯å‰Šé™¤ã•ã‚Œã¾ã™ã€‚"

#: ../../library/weakref.rst:48
msgid ""
":class:`WeakKeyDictionary` and :class:`WeakValueDictionary` use weak "
"references in their implementation, setting up callback functions on the "
"weak references that notify the weak dictionaries when a key or value has "
"been reclaimed by garbage collection.  :class:`WeakSet` implements the "
":class:`set` interface, but keeps weak references to its elements, just like"
" a :class:`WeakKeyDictionary` does."
msgstr ""
":class:`WeakKeyDictionary` ã¨ :class:`WeakValueDictionary` "
"ã¯ãã®å®Ÿè£…ã«å¼±å‚ç…§ã‚’ä½¿ç”¨ã—ã¦ãŠã‚Šã€ã‚­ãƒ¼ã‚„å€¤ãŒã‚¬ãƒ¼ãƒ™ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚ˆã£ã¦å›åã•ã‚ŒãŸã“ã¨ã‚’å¼±å‚ç…§è¾æ›¸ã«é€šçŸ¥ã™ã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’è¨­å®šã—ã¦ã„ã¾ã™ã€‚ "
":class:`WeakSet` ã¯ :class:`set` ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ãŒã€ "
":class:`WeakKeyDictionary` ã®ã‚ˆã†ã«è¦ç´ ã¸ã®å¼±å‚ç…§ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/weakref.rst:55
msgid ""
":class:`finalize` provides a straight forward way to register a cleanup "
"function to be called when an object is garbage collected. This is simpler "
"to use than setting up a callback function on a raw weak reference, since "
"the module automatically ensures that the finalizer remains alive until the "
"object is collected."
msgstr ""
":class:`finalize` "
"ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œæ™‚ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã‚ˆã†ã«ç™»éŒ²ã™ã‚‹ã€å˜ç´”ãªæ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€æœªåŠ å·¥ã®å¼±å‚ç…§ä¸Šã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’è¨­å®šã™ã‚‹ã‚ˆã‚Šã‚‚ç°¡å˜ã§ã™ã€‚ãªãœãªã‚‰ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãŒå®Œäº†ã™ã‚‹ã¾ã§ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ãŒç”Ÿãç¶šã‘ã‚‹ã“ã¨ã‚’ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè‡ªå‹•çš„ã«ä¿è¨¼ã™ã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/weakref.rst:61
msgid ""
"Most programs should find that using one of these weak container types or "
":class:`finalize` is all they need -- it's not usually necessary to create "
"your own weak references directly.  The low-level machinery is exposed by "
"the :mod:`weakref` module for the benefit of advanced uses."
msgstr ""
"ã»ã¨ã‚“ã©ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯å¼±å‚ç…§ã‚³ãƒ³ãƒ†ãƒŠã¾ãŸã¯ :class:`finalize` "
"ã®ã©ã‚Œã‹ã‚’ä½¿ãˆã°å¿…è¦ãªã‚‚ã®ã¯æƒã†ã¯ãšã§ã™ã€‚é€šå¸¸ã¯ç›´æ¥è‡ªå‰ã®å¼±å‚ç…§ã‚’ä½œæˆã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä½ãƒ¬ãƒ™ãƒ«ãªæ©Ÿæ§‹ã¯ã€ã‚ˆã‚Šé€²ã‚“ã ä½¿ã„æ–¹ã‚’ã™ã‚‹ãŸã‚ã« "
":mod:`weakref` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã—ã¦å…¬é–‹ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/weakref.rst:66
msgid ""
"Not all objects can be weakly referenced; those objects which can include "
"class instances, functions written in Python (but not in C), instance "
"methods, sets, frozensets, some :term:`file objects <file object>`, "
":term:`generator`\\s, type objects, sockets, arrays, deques, regular "
"expression pattern objects, and code objects."
msgstr ""
"å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¼±å‚ç…§ã§å‚ç…§ã§ãã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“; å¼±å‚ç…§ã§å‚ç…§ã§ãã‚‹ã®ã¯ã€ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€(C ã§ã¯ãªã) Python "
"ã§æ›¸ã‹ã‚ŒãŸé–¢æ•°ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã€set ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€frozenset ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ :term:`file ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <file "
"object>` ã€ :term:`generator` å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€socket ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€array ã‚ªã‚¸ã‚§ã‚¯ãƒˆã€deque "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€code ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/weakref.rst:72
msgid "Added support for thread.lock, threading.Lock, and code objects."
msgstr "thread.lock, threading.Lock, code ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚µãƒãƒ¼ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/weakref.rst:75
msgid ""
"Several built-in types such as :class:`list` and :class:`dict` do not "
"directly support weak references but can add support through subclassing::"
msgstr ""
":class:`list` ã‚„ :class:`dict` "
"ãªã©ã€ã„ãã¤ã‹ã®çµ„ã¿è¾¼ã¿å‹ã¯å¼±å‚ç…§ã‚’ç›´æ¥ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ãŒã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã‚’è¡Œãˆã°ã‚µãƒãƒ¼ãƒˆã‚’è¿½åŠ ã§ãã¾ã™::"

#: ../../library/weakref.rst:83
msgid ""
"Other built-in types such as :class:`tuple` and :class:`int` do not support "
"weak references even when subclassed (This is an implementation detail and "
"may be different across various Python implementations.)."
msgstr ""
":class:`tuple` ã¨ :class:`int` "
"ã®ã‚ˆã†ãªä»–ã®çµ„ã¿è¾¼ã¿å‹ã¯ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã—ã¦ã‚‚å¼±å‚ç…§ã¯ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚(ã“ã‚Œã¯å®Ÿè£…è©³ç´°ã§ã‚ã‚Šã€ä»–ã®æ§˜ã€…ãª Python "
"å®Ÿè£…ã§ã¯ç•°ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚)ã€‚"

#: ../../library/weakref.rst:87
msgid ""
"Extension types can easily be made to support weak references; see :ref"
":`weakref-support`."
msgstr "æ‹¡å¼µå‹ã¯ã€ç°¡å˜ã«å¼±å‚ç…§ã‚’ã‚µãƒãƒ¼ãƒˆã§ãã¾ã™ã€‚è©³ç´°ã«ã¤ã„ã¦ã¯ã€ :ref:`weakref-support` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/weakref.rst:93
msgid ""
"Return a weak reference to *object*.  The original object can be retrieved "
"by calling the reference object if the referent is still alive; if the "
"referent is no longer alive, calling the reference object will cause "
":const:`None` to be returned.  If *callback* is provided and not "
":const:`None`, and the returned weakref object is still alive, the callback "
"will be called when the object is about to be finalized; the weak reference "
"object will be passed as the only parameter to the callback; the referent "
"will no longer be available."
msgstr ""
"*object* "
"ã¸ã®å¼±å‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆãŒã¾ã ç”Ÿãã¦ã„ã‚‹ãªã‚‰ã°ã€å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‘¼ã³å‡ºã—ã§å–ã‚Šå‡ºã›ã™ã€‚ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆãŒã‚‚ã¯ã‚„ç”Ÿãã¦ã„ãªã„ãªã‚‰ã°ã€å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‘¼ã³å‡ºã—ãŸã¨ãã«"
" :const:`None` ã‚’è¿”ã—ã¾ã™ã€‚ *callback* ã« :const:`None` "
"ä»¥å¤–ã®å€¤ã‚’ä¸ãˆãŸå ´åˆã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã¾ã•ã«å¾Œå§‹æœ«å‡¦ç†ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ãã«å‘¼ã³å‡ºã—ã¾ã™ã€‚ã“ã®ã¨ãå¼±å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ *callback* "
"ã®å”¯ä¸€ã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã¨ã—ã¦æ¸¡ã•ã‚Œã¾ã™ã€‚ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆã¯ã‚‚ã¯ã‚„åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/weakref.rst:101
msgid ""
"It is allowable for many weak references to be constructed for the same "
"object. Callbacks registered for each weak reference will be called from the"
" most recently registered callback to the oldest registered callback."
msgstr ""
"åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ãŸãã•ã‚“ã®å¼±å‚ç…§ã‚’ä½œã‚Œã¾ã™ã€‚ãã‚Œãã‚Œã®å¼±å‚ç…§ã«å¯¾ã—ã¦ç™»éŒ²ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ã€ã‚‚ã£ã¨ã‚‚æ–°ã—ãç™»éŒ²ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‹ã‚‰ã‚‚ã£ã¨ã‚‚å¤ã„ã‚‚ã®ã¸ã¨å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/weakref.rst:105
msgid ""
"Exceptions raised by the callback will be noted on the standard error "
"output, but cannot be propagated; they are handled in exactly the same way "
"as exceptions raised from an object's :meth:`__del__` method."
msgstr ""
"ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒç™ºç”Ÿã•ã›ãŸä¾‹å¤–ã¯æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã«æ›¸ãè¾¼ã¾ã‚Œã¾ã™ãŒã€ä¼æ’­ã•ã‚Œã¾ã›ã‚“ã€‚ãã‚Œã‚‰ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`__del__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒç™ºç”Ÿã•ã›ã‚‹ä¾‹å¤–ã¨å®Œå…¨ã«åŒã˜æ–¹æ³•ã§å‡¦ç†ã•ã‚Œã¾ã™ã€‚"

#: ../../library/weakref.rst:109
msgid ""
"Weak references are :term:`hashable` if the *object* is hashable.  They will"
" maintain their hash value even after the *object* was deleted.  If "
":func:`hash` is called the first time only after the *object* was deleted, "
"the call will raise :exc:`TypeError`."
msgstr ""
"*object* ãŒãƒãƒƒã‚·ãƒ¥å¯èƒ½(:term:`hashable`)ãªã‚‰ã°ã€å¼±å‚ç…§ã¯ãƒãƒƒã‚·ãƒ¥å¯èƒ½ã§ã™ã€‚ãã‚Œã‚‰ã¯ *object* "
"ãŒå‰Šé™¤ã•ã‚ŒãŸå¾Œã§ã‚‚ãã‚Œã‚‰ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’ä¿æŒã—ã¾ã™ã€‚ *object* ãŒå‰Šé™¤ã•ã‚Œã¦ã‹ã‚‰åˆã‚ã¦ :func:`hash` "
"ãŒå‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆã«ã€ãã®å‘¼ã³å‡ºã—ã¯ :exc:`TypeError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/weakref.rst:114
msgid ""
"Weak references support tests for equality, but not ordering.  If the "
"referents are still alive, two references have the same equality "
"relationship as their referents (regardless of the *callback*).  If either "
"referent has been deleted, the references are equal only if the reference "
"objects are the same object."
msgstr ""
"å¼±å‚ç…§ã¯ç­‰ä¾¡æ€§ã®ãƒ†ã‚¹ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ãŒã€é †åºã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚å‚ç…§ãŒã¾ã ç”Ÿãã¦ã„ã‚‹ãªã‚‰ã°ã€ *callback* "
"ã«é–¢ä¿‚ãªãäºŒã¤ã®å‚ç…§ã¯ãã‚Œã‚‰ã®ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆã¨åŒã˜ç­‰ä¾¡é–¢ä¿‚ã‚’æŒã¡ã¾ã™ã€‚ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆã®ã©ã¡ã‚‰ã‹ä¸€æ–¹ãŒå‰Šé™¤ã•ã‚ŒãŸå ´åˆã€å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒåŒä¸€ã§ã‚ã‚‹å ´åˆã«é™ã‚Šã€ãã®å‚ç…§ã¯ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/weakref.rst:119
msgid "This is a subclassable type rather than a factory function."
msgstr "ã“ã‚Œã¯ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–å¯èƒ½ãªå‹ã¨ã„ã†ã‚ˆã‚Šãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã§ã™ã€‚"

#: ../../library/weakref.rst:123
msgid ""
"This read-only attribute returns the callback currently associated to the "
"weakref.  If there is no callback or if the referent of the weakref is no "
"longer alive then this attribute will have value ``None``."
msgstr ""
"ã“ã®èª­ã¿å‡ºã—å°‚ç”¨ã®å±æ€§ã¯ã€ç¾åœ¨å¼±å‚ç…§ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’è¿”ã—ã¾ã™ã€‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒå­˜åœ¨ã—ãªã„ã‹ã€å¼±å‚ç…§ã®ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆãŒç”Ÿãã¦ã„ãªã„å ´åˆã€ã“ã®å±æ€§ã®å€¤ã¯"
" ``None``  ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/weakref.rst:127
msgid "Added the :attr:`__callback__` attribute."
msgstr ":attr:`__callback__` å±æ€§ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/weakref.rst:133
msgid ""
"Return a proxy to *object* which uses a weak reference.  This supports use "
"of the proxy in most contexts instead of requiring the explicit "
"dereferencing used with weak reference objects.  The returned object will "
"have a type of either ``ProxyType`` or ``CallableProxyType``, depending on "
"whether *object* is callable.  Proxy objects are not :term:`hashable` "
"regardless of the referent; this avoids a number of problems related to "
"their fundamentally mutable nature, and prevent their use as dictionary "
"keys.  *callback* is the same as the parameter of the same name to the "
":func:`ref` function."
msgstr ""
"å¼±å‚ç…§ã‚’ä½¿ã† *object* "
"ã¸ã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚å¼±å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ˜ç¤ºçš„ãªå‚ç…§å¤–ã—ã‚’ã—ãªãŒã‚‰åˆ©ç”¨ã™ã‚‹ä»£ã‚ã‚Šã«ã€å¤šãã®ã‚±ãƒ¼ã‚¹ã§ãƒ—ãƒ­ã‚­ã‚·ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€"
" *object* ãŒå‘¼ã³å‡ºã—å¯èƒ½ã‹ã©ã†ã‹ã«ã‚ˆã£ã¦ã€ ``ProxyType`` ã¾ãŸã¯ ``CallableProxyType`` "
"ã®ã©ã¡ã‚‰ã‹ã®å‹ã‚’æŒã¡ã¾ã™ã€‚ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆã«é–¢ä¿‚ãªããƒãƒƒã‚·ãƒ¥å¯èƒ½(:term:`hashable`)ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã«ã‚ˆã£ã¦ã€ãã‚Œã‚‰ã®åŸºæœ¬çš„ãªå¤‰æ›´å¯èƒ½ã¨ã„ã†æ€§è³ªã«ã‚ˆã‚‹å¤šãã®å•é¡Œã‚’é¿ã‘ã¦ã„ã¾ã™ã€‚ãã—ã¦ã€è¾æ›¸ã®ã‚­ãƒ¼ã¨ã—ã¦ã®åˆ©ç”¨ã‚’å¦¨ã’ã¾ã™ã€‚"
" *callback* ã¯ :func:`ref` é–¢æ•°ã®åŒã˜åå‰ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨åŒã˜ã‚‚ã®ã§ã™ã€‚(--- è¨³æ³¨: "
"ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆãŒå¤‰æ›´ä¸èƒ½å‹ã§ã‚ã£ã¦ã‚‚ã€ãƒ—ãƒ­ã‚­ã‚·ã¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆãŒæ¶ˆãˆã‚‹ã¨ã„ã†çŠ¶æ…‹ã®å¤‰æ›´ãŒã‚ã‚‹ãŸã‚ã«ã€å¤‰æ›´å¯èƒ½å‹ã§ã™ã€‚---)"

#: ../../library/weakref.rst:145
msgid ""
"Return the number of weak references and proxies which refer to *object*."
msgstr "*object* ã‚’å‚ç…§ã™ã‚‹å¼±å‚ç…§ã¨ãƒ—ãƒ­ã‚­ã‚·ã®æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/weakref.rst:150
msgid ""
"Return a list of all weak reference and proxy objects which refer to "
"*object*."
msgstr "*object* ã‚’å‚ç…§ã™ã‚‹ã™ã¹ã¦ã®å¼±å‚ç…§ã¨ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/weakref.rst:155
msgid ""
"Mapping class that references keys weakly.  Entries in the dictionary will "
"be discarded when there is no longer a strong reference to the key.  This "
"can be used to associate additional data with an object owned by other parts"
" of an application without adding attributes to those objects.  This can be "
"especially useful with objects that override attribute accesses."
msgstr ""
"ã‚­ãƒ¼ã‚’å¼±å‚ç…§ã™ã‚‹ãƒãƒƒãƒ”ãƒ³ã‚°ã‚¯ãƒ©ã‚¹ã€‚ã‚­ãƒ¼ã¸ã®å¼·å‚ç…§ãŒãªããªã£ãŸã¨ãã«ã€è¾æ›¸ã®ã‚¨ãƒ³ãƒˆãƒªã¯æ¨ã¦ã‚‰ã‚Œã¾ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ä»–ã®éƒ¨åˆ†ãŒæ‰€æœ‰ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸å±æ€§ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã‚‚ãªãã€ãã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¿½åŠ ãƒ‡ãƒ¼ã‚¿ã‚’é–¢é€£ã¥ã‘ã‚‹ãŸã‚ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯å±æ€§ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ç‰¹ã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../library/weakref.rst:163
msgid ""
"Caution: Because a :class:`WeakKeyDictionary` is built on top of a Python "
"dictionary, it must not change size when iterating over it.  This can be "
"difficult to ensure for a :class:`WeakKeyDictionary` because actions "
"performed by the program during iteration may cause items in the dictionary "
"to vanish \"by magic\" (as a side effect of garbage collection)."
msgstr ""
"è­¦å‘Š: :class:`WeakKeyDictionary` ã¯ Python "
"è¾æ›¸å‹ã®ä¸Šã«ä½œã‚‰ã‚Œã¦ã„ã‚‹ã®ã§ã€åå¾©å‡¦ç†ã‚’è¡Œã†ã¨ãã«ã¯ã‚µã‚¤ã‚ºå¤‰æ›´ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ :class:`WeakKeyDictionary` "
"ã®å ´åˆã€åå¾©å‡¦ç†ã®æœ€ä¸­ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒè¡Œã£ãŸæ“ä½œãŒã€(ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®å‰¯ä½œç”¨ã¨ã—ã¦) "
"ã€Œé­”æ³•ã®ã‚ˆã†ã«ã€è¾æ›¸å†…ã®è¦ç´ ã‚’æ¶ˆã—å»ã£ã¦ã—ã¾ã†ãŸã‚ã€ç¢ºå®Ÿãªã‚µã‚¤ã‚ºå¤‰æ›´ã¯å›°é›£ãªã®ã§ã™ã€‚"

#: ../../library/weakref.rst:169
msgid ""
":class:`WeakKeyDictionary` objects have an additional method that exposes "
"the internal references directly.  The references are not guaranteed to be "
"\"live\" at the time they are used, so the result of calling the references "
"needs to be checked before being used.  This can be used to avoid creating "
"references that will cause the garbage collector to keep the keys around "
"longer than needed."
msgstr ""

#: ../../library/weakref.rst:179
msgid "Return an iterable of the weak references to the keys."
msgstr "ã‚­ãƒ¼ã¸ã®å¼±å‚ç…§ã‚’æŒã¤ iterable ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/weakref.rst:184
msgid ""
"Mapping class that references values weakly.  Entries in the dictionary will"
" be discarded when no strong reference to the value exists any more."
msgstr "å€¤ã‚’å¼±å‚ç…§ã™ã‚‹ãƒãƒƒãƒ”ãƒ³ã‚°ã‚¯ãƒ©ã‚¹ã€‚å€¤ã¸ã®å¼·å‚ç…§ãŒå­˜åœ¨ã—ãªããªã£ãŸã¨ãã«ã€è¾æ›¸ã®ã‚¨ãƒ³ãƒˆãƒªã¯æ¨ã¦ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/weakref.rst:189
msgid ""
"Caution:  Because a :class:`WeakValueDictionary` is built on top of a Python"
" dictionary, it must not change size when iterating over it.  This can be "
"difficult to ensure for a :class:`WeakValueDictionary` because actions "
"performed by the program during iteration may cause items in the dictionary "
"to vanish \"by magic\" (as a side effect of garbage collection)."
msgstr ""
"è­¦å‘Š: :class:`WeakValueDictionary` ã¯ Python "
"è¾æ›¸å‹ã®ä¸Šã«ä½œã‚‰ã‚Œã¦ã„ã‚‹ã®ã§ã€åå¾©å‡¦ç†ã‚’è¡Œã†ã¨ãã«ã¯ã‚µã‚¤ã‚ºå¤‰æ›´ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ :class:`WeakValueDictionary` "
"ã®å ´åˆã€åå¾©å‡¦ç†ã®æœ€ä¸­ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒè¡Œã£ãŸæ“ä½œãŒã€(ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®å‰¯ä½œç”¨ã¨ã—ã¦) "
"ã€Œé­”æ³•ã®ã‚ˆã†ã«ã€è¾æ›¸å†…ã®è¦ç´ ã‚’æ¶ˆã—å»ã£ã¦ã—ã¾ã†ãŸã‚ã€ç¢ºå®Ÿãªã‚µã‚¤ã‚ºå¤‰æ›´ã¯å›°é›£ãªã®ã§ã™ã€‚"

#: ../../library/weakref.rst:195
msgid ""
":class:`WeakValueDictionary` objects have an additional method that has the "
"same issues as the :meth:`keyrefs` method of :class:`WeakKeyDictionary` "
"objects."
msgstr ""
":class:`WeakValueDictionary` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :class:`WeakKeyDictionary` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® "
":meth:`keyrefs` ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒã˜ç›®çš„ã‚’æŒã¤è¿½åŠ ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/weakref.rst:202
msgid "Return an iterable of the weak references to the values."
msgstr "å€¤ã¸ã®å¼±å‚ç…§ã‚’æŒã¤ iterable ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/weakref.rst:207
msgid ""
"Set class that keeps weak references to its elements.  An element will be "
"discarded when no strong reference to it exists any more."
msgstr "è¦ç´ ã¸ã®å¼±å‚ç…§ã‚’æŒã¤é›†åˆå‹ã€‚è¦ç´ ã¸ã®å¼·å‚ç…§ãŒç„¡ããªã£ãŸã¨ãã«ã€ãã®è¦ç´ ã¯å‰Šé™¤ã•ã‚Œã¾ã™ã€‚"

#: ../../library/weakref.rst:213
msgid ""
"A custom :class:`ref` subclass which simulates a weak reference to a bound "
"method (i.e., a method defined on a class and looked up on an instance). "
"Since a bound method is ephemeral, a standard weak reference cannot keep "
"hold of it.  :class:`WeakMethod` has special code to recreate the bound "
"method until either the object or the original function dies::"
msgstr ""
"æ‹¡å¼µã•ã‚ŒãŸ :class:`ref` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã€æŸç¸›ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã¸ã®å¼±å‚ç…§ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã¾ã™ (ã¤ã¾ã‚Šã€ã‚¯ãƒ©ã‚¹ã§å®šç¾©ã•ã‚Œã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã‚ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰)ã€‚\n"
"æŸç¸›ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã¯çŸ­å‘½ãªã®ã§ã€æ¨™æº–ã®å¼±å‚ç…§ã§ã¯ä¿æŒã—ç¶šã‘ã‚‰ã‚Œã¾ã›ã‚“ã€‚\n"
":class:`WeakMethod` ã«ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨å…ƒã€…ã®é–¢æ•°ãŒæ­»ã¬ã¾ã§æŸç¸›ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’å†ä½œæˆã™ã‚‹ç‰¹åˆ¥ãªã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã™::"

#: ../../library/weakref.rst:241
msgid ""
"Return a callable finalizer object which will be called when *obj* is "
"garbage collected. Unlike an ordinary weak reference, a finalizer will "
"always survive until the reference object is collected, greatly simplifying "
"lifecycle management."
msgstr ""
"*obj* ãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§å›åã•ã‚Œã‚‹ã¨ãã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã€å‘¼ã³å‡ºã—å¯èƒ½ãªãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚\n"
"é€šå¸¸ã®å¼±å‚ç…§ã¨ã¯ç•°ãªã‚Šã€ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ã¯å‚ç…§ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå›åã•ã‚Œã‚‹ã¾ã§å¿…ãšç”Ÿãæ®‹ã‚Šã€ãã®ãŠã‹ã’ã§ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç†ãŒå¤§ã„ã«ç°¡å˜ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/weakref.rst:246
msgid ""
"A finalizer is considered *alive* until it is called (either explicitly or "
"at garbage collection), and after that it is *dead*.  Calling a live "
"finalizer returns the result of evaluating ``func(*arg, **kwargs)``, whereas"
" calling a dead finalizer returns :const:`None`."
msgstr ""
"ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ã¯ (ç›´æ¥ã‚‚ã—ãã¯ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ã¨ãã«) å‘¼ã³å‡ºã•ã‚Œã‚‹ã¾ã§ *ç”Ÿãã¦ã„ã‚‹* ã¨è¦‹ãªã•ã‚Œã€å‘¼ã³å‡ºã•ã‚ŒãŸå¾Œã«ã¯ *æ­»ã‚“ã§ã„ã¾ã™* ã€‚\n"
"ç”Ÿãã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ã‚’å‘¼ã³å‡ºã™ã¨ã€ ``func(*arg, **kwargs)`` ã‚’è©•ä¾¡ã—ãŸçµæœã‚’è¿”ã—ã¾ã™ã€‚ä¸€æ–¹ã€æ­»ã‚“ã§ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ã‚’å‘¼ã³å‡ºã™ã¨ :const:`None` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/weakref.rst:251
msgid ""
"Exceptions raised by finalizer callbacks during garbage collection will be "
"shown on the standard error output, but cannot be propagated.  They are "
"handled in the same way as exceptions raised from an object's "
":meth:`__del__` method or a weak reference's callback."
msgstr ""
"ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ä¸­ã«ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒç™ºç”Ÿã•ã›ãŸä¾‹å¤–ã¯ã€æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã«è¡¨ç¤ºã•ã‚Œã¾ã™ãŒã€ä¼æ’­ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã“ã‚Œã‚‰ã®ä¾‹å¤–ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®"
" :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚„å¼±å‚ç…§ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒç™ºç”Ÿã•ã›ã‚‹ä¾‹å¤–ã¨åŒã˜æ–¹æ³•ã§å‡¦ç†ã•ã‚Œã¾ã™ã€‚"

#: ../../library/weakref.rst:257
msgid ""
"When the program exits, each remaining live finalizer is called unless its "
":attr:`atexit` attribute has been set to false.  They are called in reverse "
"order of creation."
msgstr ""
"ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒçµ‚äº†ã™ã‚‹ã¨ãã€ç”Ÿãæ®‹ã£ãŸãã‚Œãã‚Œã®ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ã¯ã€è‡ªèº«ã® :attr:`atexit` å±æ€§ãŒå½ã«è¨­å®šã•ã‚Œã‚‹ã¾ã§å‘¼ã³å‡ºã•ã‚Œç¶šã‘ã¾ã™ã€‚\n"
"ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ã¯ç”Ÿæˆã•ã‚ŒãŸé †åºã®é€†é †ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/weakref.rst:261
msgid ""
"A finalizer will never invoke its callback during the later part of the "
":term:`interpreter shutdown` when module globals are liable to have been "
"replaced by :const:`None`."
msgstr ""

#: ../../library/weakref.rst:267
msgid ""
"If *self* is alive then mark it as dead and return the result of calling "
"``func(*args, **kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""

#: ../../library/weakref.rst:273
msgid ""
"If *self* is alive then mark it as dead and return the tuple ``(obj, func, "
"args, kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""

#: ../../library/weakref.rst:279
msgid ""
"If *self* is alive then return the tuple ``(obj, func, args, kwargs)``.  If "
"*self* is dead then return :const:`None`."
msgstr ""

#: ../../library/weakref.rst:284
msgid "Property which is true if the finalizer is alive, false otherwise."
msgstr "ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ãŒç”Ÿãã¦ã„ã‚‹å ´åˆã«ã¯çœŸã€ãã†ã§ãªã„å ´åˆã«ã¯å½ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§ã™ã€‚"

#: ../../library/weakref.rst:288
msgid ""
"A writable boolean property which by default is true.  When the program "
"exits, it calls all remaining live finalizers for which :attr:`.atexit` is "
"true.  They are called in reverse order of creation."
msgstr ""

#: ../../library/weakref.rst:295
msgid ""
"It is important to ensure that *func*, *args* and *kwargs* do not own any "
"references to *obj*, either directly or indirectly, since otherwise *obj* "
"will never be garbage collected.  In particular, *func* should not be a "
"bound method of *obj*."
msgstr ""

#: ../../library/weakref.rst:305
msgid "The type object for weak references objects."
msgstr "å¼±å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãŸã‚ã®å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚"

#: ../../library/weakref.rst:310
msgid "The type object for proxies of objects which are not callable."
msgstr "å‘¼ã³å‡ºã—å¯èƒ½ã§ãªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ã‚­ã‚·ã®ãŸã‚ã®å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚"

#: ../../library/weakref.rst:315
msgid "The type object for proxies of callable objects."
msgstr "å‘¼ã³å‡ºã—å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ã‚­ã‚·ã®ãŸã‚ã®å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚"

#: ../../library/weakref.rst:320
msgid ""
"Sequence containing all the type objects for proxies.  This can make it "
"simpler to test if an object is a proxy without being dependent on naming "
"both proxy types."
msgstr ""
"ãƒ—ãƒ­ã‚­ã‚·ã®ãŸã‚ã®ã™ã¹ã¦ã®å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å«ã‚€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã€‚ã“ã‚Œã¯ä¸¡æ–¹ã®ãƒ—ãƒ­ã‚­ã‚·å‹ã®åå‰ä»˜ã‘ã«ä¾å­˜ã—ãªã„ã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒ—ãƒ­ã‚­ã‚·ã‹ã©ã†ã‹ã®ãƒ†ã‚¹ãƒˆã‚’ã‚ˆã‚Šç°¡å˜ã«ã§ãã¾ã™ã€‚"

#: ../../library/weakref.rst:327
msgid ""
"Exception raised when a proxy object is used but the underlying object has "
"been collected.  This is the same as the standard :exc:`ReferenceError` "
"exception."
msgstr ""
"ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½¿ã‚ã‚Œã¦ã‚‚ã€å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã•ã‚Œã¦ã—ã¾ã£ã¦ã„ã‚‹ã¨ãã«ç™ºç”Ÿã™ã‚‹ä¾‹å¤–ã€‚ã“ã‚Œã¯æ¨™æº–ã® "
":exc:`ReferenceError` ä¾‹å¤–ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/weakref.rst:334
msgid ":pep:`205` - Weak References"
msgstr ":pep:`205` - å¼±å‚ç…§"

#: ../../library/weakref.rst:334
msgid ""
"The proposal and rationale for this feature, including links to earlier "
"implementations and information about similar features in other languages."
msgstr "ã“ã®æ©Ÿèƒ½ã®ææ¡ˆã¨ç†è«–çš„æ ¹æ‹ ã€‚åˆæœŸã®å®Ÿè£…ã¨ä»–ã®è¨€èªã«ãŠã‘ã‚‹é¡ä¼¼ã®æ©Ÿèƒ½ã«ã¤ã„ã¦ã®æƒ…å ±ã¸ã®ãƒªãƒ³ã‚¯ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚"

#: ../../library/weakref.rst:341
msgid "Weak Reference Objects"
msgstr "å¼±å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/weakref.rst:343
msgid ""
"Weak reference objects have no methods and no attributes besides "
":attr:`ref.__callback__`. A weak reference object allows the referent to be "
"obtained, if it still exists, by calling it:"
msgstr ""

#: ../../library/weakref.rst:357
msgid ""
"If the referent no longer exists, calling the reference object returns "
":const:`None`:"
msgstr "ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆãŒã‚‚ã¯ã‚„å­˜åœ¨ã—ãªã„ãªã‚‰ã°ã€å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‘¼ã³å‡ºã—ã¯ :const:`None` ã‚’è¿”ã—ã¾ã™:"

#: ../../library/weakref.rst:364
msgid ""
"Testing that a weak reference object is still live should be done using the "
"expression ``ref() is not None``.  Normally, application code that needs to "
"use a reference object should follow this pattern::"
msgstr ""
"å¼±å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã¾ã ç”Ÿãã¦ã„ã‚‹ã‹ã©ã†ã‹ã®ãƒ†ã‚¹ãƒˆã¯ã€å¼ ``ref() is not None`` "
"ã‚’ç”¨ã„ã¦è¡Œã‚ã‚Œã¾ã™ã€‚é€šå¸¸ã€å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã†å¿…è¦ãŒã‚ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ‰ã¯ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¾“ã„ã¾ã™::"

#: ../../library/weakref.rst:377
msgid ""
"Using a separate test for \"liveness\" creates race conditions in threaded "
"applications; another thread can cause a weak reference to become "
"invalidated before the weak reference is called; the idiom shown above is "
"safe in threaded applications as well as single-threaded applications."
msgstr ""
"\"ç”Ÿå­˜æ€§(liveness)\"ã®ãƒ†ã‚¹ãƒˆã‚’åˆ†å‰²ã™ã‚‹ã¨ã€ã‚¹ãƒ¬ãƒƒãƒ‰åŒ–ã•ã‚ŒãŸã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ãŠã„ã¦ç«¶åˆçŠ¶æ…‹ã‚’ä½œã‚Šå‡ºã—ã¾ã™ã€‚ (è¨³æ³¨:``if r() is"
" not None: r().do_something()`` ã§ã¯ã€2åº¦ç›®ã®r()ãŒNoneã‚’è¿”ã™å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™) "
"å¼±å‚ç…§ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹å‰ã«ã€ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯å¼±å‚ç…§ãŒç„¡åŠ¹ã«ãªã‚‹åŸå› ã¨ãªã‚Šå¾—ã¾ã™ã€‚ä¸Šã§ç¤ºã—ãŸã‚¤ãƒ‡ã‚£ã‚ªãƒ ã¯ã€ã‚·ãƒ³ã‚°ãƒ«ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¨åŒã˜ããƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰åŒ–ã•ã‚ŒãŸã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ãŠã„ã¦ã‚‚å®‰å…¨ã§ã™ã€‚"

#: ../../library/weakref.rst:382
msgid ""
"Specialized versions of :class:`ref` objects can be created through "
"subclassing. This is used in the implementation of the "
":class:`WeakValueDictionary` to reduce the memory overhead for each entry in"
" the mapping.  This may be most useful to associate additional information "
"with a reference, but could also be used to insert additional processing on "
"calls to retrieve the referent."
msgstr ""
"ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã‚’è¡Œãˆã°ã€ :class:`ref` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç‰¹æ®Šãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½œæˆã§ãã¾ã™ã€‚ã“ã‚Œã¯ "
":class:`WeakValueDictionary` "
"ã®å®Ÿè£…ã§ä½¿ã‚ã‚Œã¦ãŠã‚Šã€ãƒãƒƒãƒ—å†…ã®å„ã‚¨ãƒ³ãƒˆãƒªã«ã‚ˆã‚‹ãƒ¡ãƒ¢ãƒªã®ã‚ªãƒ¼ãƒãƒ˜ãƒƒãƒ‰ã‚’æ¸›ã‚‰ã—ã¦ã„ã¾ã™ã€‚ã“ã†ã—ãŸå®Ÿè£…ã¯ã€ã‚ã‚‹å‚ç…§ã«è¿½åŠ æƒ…å ±ã‚’é–¢é€£ä»˜ã‘ãŸã„å ´åˆã«ä¾¿åˆ©ã§ã™ã—ã€ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆã‚’å–ã‚Šå‡ºã™ãŸã‚ã®å‘¼ã³å‡ºã—æ™‚ã«ä½•ã‚‰ã‹ã®è¿½åŠ å‡¦ç†ã‚’è¡Œã„ãŸã„å ´åˆã«ã‚‚ä½¿ãˆã¾ã™ã€‚"

#: ../../library/weakref.rst:388
msgid ""
"This example shows how a subclass of :class:`ref` can be used to store "
"additional information about an object and affect the value that's returned "
"when the referent is accessed::"
msgstr ""
"ä»¥ä¸‹ã®ä¾‹ã§ã¯ã€ :class:`ref` "
"ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã£ã¦ã€ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¿½åŠ æƒ…å ±ã‚’ä¿å­˜ã—ã€ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ãƒˆãŒã‚¢ã‚¯ã‚»ã‚¹ã•ã‚ŒãŸã¨ãã«ãã®å€¤ã«ä½œç”¨ã‚’ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®æ–¹æ³•ã‚’ç¤ºã—ã¦ã„ã¾ã™::"

#: ../../library/weakref.rst:415
msgid "Example"
msgstr "ä½¿ç”¨ä¾‹"

#: ../../library/weakref.rst:417
msgid ""
"This simple example shows how an application can use object IDs to retrieve "
"objects that it has seen before.  The IDs of the objects can then be used in"
" other data structures without forcing the objects to remain alive, but the "
"objects can still be retrieved by ID if they do."
msgstr ""
"ã“ã®ç°¡å˜ãªä¾‹ã§ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒä»¥å‰ã«å‚ç…§ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–ã‚Šå‡ºã™ãŸã‚ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆIDã‚’åˆ©ç”¨ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ç”ŸããŸã¾ã¾ã§ã‚ã‚‹ã“ã¨ã‚’å¼·åˆ¶ã™ã‚‹ã“ã¨ãªãã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®"
" IDã‚’ä»–ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ä¸­ã§ä½¿ã†ã“ã¨ãŒã§ãã€å¿…è¦ã«å¿œã˜ã¦IDã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–ã‚Šå‡ºã›ã¾ã™ã€‚"

#: ../../library/weakref.rst:442
msgid "Finalizer Objects"
msgstr "ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/weakref.rst:444
msgid ""
"The main benefit of using :class:`finalize` is that it makes it simple to "
"register a callback without needing to preserve the returned finalizer "
"object.  For instance"
msgstr ""

#: ../../library/weakref.rst:458
msgid ""
"The finalizer can be called directly as well.  However the finalizer will "
"invoke the callback at most once."
msgstr "ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ã¯ç›´æ¥å‘¼ã³å‡ºã™ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ãŸã ã—ã€ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ã¯ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’æœ€å¤§ã§ã‚‚ä¸€åº¦ã—ã‹å‘¼ã³å‡ºã—ã¾ã›ã‚“ã€‚"

#: ../../library/weakref.rst:474
msgid ""
"You can unregister a finalizer using its :meth:`~finalize.detach` method.  "
"This kills the finalizer and returns the arguments passed to the constructor"
" when it was created."
msgstr ""

#: ../../library/weakref.rst:488
msgid ""
"Unless you set the :attr:`~finalize.atexit` attribute to :const:`False`, a "
"finalizer will be called when the program exits if it is still alive.  For "
"instance"
msgstr ""

#: ../../library/weakref.rst:500
msgid "Comparing finalizers with :meth:`__del__` methods"
msgstr "ãƒ•ã‚¡ã‚¤ãƒŠãƒ©ã‚¤ã‚¶ã¨ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã®æ¯”è¼ƒ"

#: ../../library/weakref.rst:502
msgid ""
"Suppose we want to create a class whose instances represent temporary "
"directories.  The directories should be deleted with their contents when the"
" first of the following events occurs:"
msgstr ""
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒä¸€æ™‚ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’è¡¨ã™ã€ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã™ã‚‹ã¨ã—ã¾ã™ã€‚ãã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¯ã€æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆã®ã„ãšã‚Œã‹ãŒèµ·ããŸæ™‚ã«ã€ãã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å†…å®¹ã¨ã¨ã‚‚ã«å‰Šé™¤ã•ã‚Œã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/weakref.rst:506
msgid "the object is garbage collected,"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãŒè¡Œã‚ã‚ŒãŸå ´åˆ"

#: ../../library/weakref.rst:507
msgid "the object's :meth:`remove` method is called, or"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`remove` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆ"

#: ../../library/weakref.rst:508
msgid "the program exits."
msgstr "ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒçµ‚äº†ã—ãŸå ´åˆ"

#: ../../library/weakref.rst:510
msgid ""
"We might try to implement the class using a :meth:`__del__` method as "
"follows::"
msgstr "ã“ã“ã§ã¯ã€ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦æ¬¡ã®ã‚ˆã†ã«ã‚¯ãƒ©ã‚¹ã‚’å®Ÿè£…ã—ã¾ã™::"

#: ../../library/weakref.rst:529
msgid ""
"Starting with Python 3.4, :meth:`__del__` methods no longer prevent "
"reference cycles from being garbage collected, and module globals are no "
"longer forced to :const:`None` during :term:`interpreter shutdown`. So this "
"code should work without any issues on CPython."
msgstr ""

#: ../../library/weakref.rst:534
msgid ""
"However, handling of :meth:`__del__` methods is notoriously implementation "
"specific, since it depends on internal details of the interpreter's garbage "
"collector implementation."
msgstr ""

#: ../../library/weakref.rst:538
msgid ""
"A more robust alternative can be to define a finalizer which only references"
" the specific functions and objects that it needs, rather than having access"
" to the full state of the object::"
msgstr ""

#: ../../library/weakref.rst:554
msgid ""
"Defined like this, our finalizer only receives a reference to the details it"
" needs to clean up the directory appropriately. If the object never gets "
"garbage collected the finalizer will still be called at exit."
msgstr ""

#: ../../library/weakref.rst:558
msgid ""
"The other advantage of weakref based finalizers is that they can be used to "
"register finalizers for classes where the definition is controlled by a "
"third party, such as running code when a module is unloaded::"
msgstr ""

#: ../../library/weakref.rst:570
msgid ""
"If you create a finalizer object in a daemonic thread just as the program "
"exits then there is the possibility that the finalizer does not get called "
"at exit.  However, in a daemonic thread :func:`atexit.register`, ``try: ... "
"finally: ...`` and ``with: ...`` do not guarantee that cleanup occurs "
"either."
msgstr ""
