# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# tomo, 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/weakref.rst:2
msgid ":mod:`weakref` --- Weak references"
msgstr ":mod:`weakref` --- 弱参照"

#: ../../library/weakref.rst:14
msgid "**Source code:** :source:`Lib/weakref.py`"
msgstr "**ソースコード:** :source:`Lib/weakref.py`"

#: ../../library/weakref.rst:18
msgid ""
"The :mod:`weakref` module allows the Python programmer to create :dfn:`weak "
"references` to objects."
msgstr ""
":mod:`weakref` モジュールは、Pythonプログラマがオブジェクトへの弱参照 (:dfn:"
"`weak refarence`)を作成できるようにします。"

#: ../../library/weakref.rst:24
msgid ""
"In the following, the term :dfn:`referent` means the object which is "
"referred to by a weak reference."
msgstr ""
"以下では、リファレント (:dfn:`referent`) という用語は弱参照が参照するオブジェ"
"クトを意味します。"

#: ../../library/weakref.rst:27
msgid ""
"A weak reference to an object is not enough to keep the object alive: when "
"the only remaining references to a referent are weak references, :term:"
"`garbage collection` is free to destroy the referent and reuse its memory "
"for something else.  A primary use for weak references is to implement "
"caches or mappings holding large objects, where it's desired that a large "
"object not be kept alive solely because it appears in a cache or mapping."
msgstr ""
"オブジェクトに対する弱参照は、そのオブジェクトを生かしておく十分条件にはなり"
"ません: あるリファレントに対する参照が弱参照しか残っていない場合、ガベージコ"
"レクション (:term:`garbage collection`)機構は自由にリファレントを破壊し、その"
"メモリを別の用途に再利用できます。弱参照の主な用途は、巨大なオブジェクトを保"
"持するキャッシュやマップ型の実装において、キャッシュやマップ型にあるという理"
"由だけオブジェクトを存続させたくない場合です。"

#: ../../library/weakref.rst:34
msgid ""
"For example, if you have a number of large binary image objects, you may "
"wish to associate a name with each.  If you used a Python dictionary to map "
"names to images, or images to names, the image objects would remain alive "
"just because they appeared as values or keys in the dictionaries.  The :"
"class:`WeakKeyDictionary` and :class:`WeakValueDictionary` classes supplied "
"by the :mod:`weakref` module are an alternative, using weak references to "
"construct mappings that don't keep objects alive solely because they appear "
"in the mapping objects.  If, for example, an image object is a value in a :"
"class:`WeakValueDictionary`, then when the last remaining references to that "
"image object are the weak references held by weak mappings, garbage "
"collection can reclaim the object, and its corresponding entries in weak "
"mappings are simply deleted."
msgstr ""
"例えば、巨大なバイナリ画像のオブジェクトがたくさんあり、それぞれに名前を関連"
"付けたいとします。 Python の辞書型を使って名前を画像に対応付けたり画像を名前"
"に対応付けたりすると、画像オブジェクトは辞書内のキーや値に使われているため存"
"続しつづけることになります。 :mod:`weakref` モジュールが提供している :class:"
"`WeakKeyDictionary` や :class:`WeakValueDictionary` クラスはその代用で、対応"
"付けを構築するのに弱参照を使い、キャッシュやマッピングに存在するという理由だ"
"けでオブジェクトを存続させないようにします。例えば、もしある画像オブジェクト"
"が :class:`WeakValueDictionary` の値になっていた場合、最後に残った画像オブ"
"ジェクトへの参照を弱参照マッピングが保持していれば、ガーベジコレクションはこ"
"のオブジェクトを再利用でき、画像オブジェクトに対する弱参照内の対応付けは削除"
"されます。"

#: ../../library/weakref.rst:47
msgid ""
":class:`WeakKeyDictionary` and :class:`WeakValueDictionary` use weak "
"references in their implementation, setting up callback functions on the "
"weak references that notify the weak dictionaries when a key or value has "
"been reclaimed by garbage collection.  Most programs should find that using "
"one of these weak dictionary types is all they need -- it's not usually "
"necessary to create your own weak references directly.  The low-level "
"machinery used by the weak dictionary implementations is exposed by the :mod:"
"`weakref` module for the benefit of advanced uses."
msgstr ""
":class:`WeakKeyDictionary` や :class:`WeakValueDictionary` は弱参照を使って実"
"装されていて、キーや値がガベージコレクションによって回収されたことを弱参照辞"
"書に知らせるような弱参照オブジェクトのコールバック関数を設定しています。ほと"
"んどのプログラムが、いずれかの弱参照辞書型を使うだけで必要を満たせるはずです "
"--- 自作の弱参照辞書を直接作成する必要は普通はありません。とはいえ、高度な使"
"い方をするために、弱参照辞書の実装に使われている低水準の機構は :mod:"
"`weakref` モジュールで公開されています。"

#: ../../library/weakref.rst:56
msgid ""
"Not all objects can be weakly referenced; those objects which can include "
"class instances, functions written in Python (but not in C), methods (both "
"bound and unbound), sets, frozensets, file objects, :term:`generator`\\s, "
"type objects, :class:`DBcursor` objects from the :mod:`bsddb` module, "
"sockets, arrays, deques, regular expression pattern objects, and code "
"objects."
msgstr ""
"すべてのオブジェクトを弱参照できるわけではありません。弱参照できるオブジェク"
"トは、クラスインスタンス、(Cではなく) Pythonで書かれた関数、(束縛および非束縛"
"の両方の) メソッド、 :class:`set` と :class:`frozenset` 型、ファイルオブジェ"
"クト、ジェネレータ(:term:`generator`)、 type オブジェクト、 :mod:`bsddb` モ"
"ジュールの :class:`DBcursor` 型、ソケット型、 :class:`array` 型、 :class:"
"`deque` 型、正規表現パターンオブジェクト, code オブジェクトです。"

#: ../../library/weakref.rst:62
msgid "Added support for files, sockets, arrays, and patterns."
msgstr ""
"ファイル、ソケット、 :class:`array` 、および正規表現パターンのサポートを追加"
"しました."

#: ../../library/weakref.rst:65
msgid "Added support for thread.lock, threading.Lock, and code objects."
msgstr ""
"thread.lock, threading.Lock, code オブジェクトのサポートが追加されました。"

#: ../../library/weakref.rst:68
msgid ""
"Several built-in types such as :class:`list` and :class:`dict` do not "
"directly support weak references but can add support through subclassing::"
msgstr ""
":class:`list` や :class:`dict` など、いくつかの組み込み型は弱参照を直接サポー"
"トしませんが、以下のようにサブクラス化を行えばサポートを追加できます::"

#: ../../library/weakref.rst:78
msgid ""
"Other built-in types such as :class:`tuple` and :class:`long` do not support "
"weak references even when subclassed."
msgstr ""
":class:`tuple` や :class:`long` など、他の組み込み型はサブクラス化しても弱参"
"照をサポートしません。"

#: ../../library/weakref.rst:81
msgid ""
"Extension types can easily be made to support weak references; see :ref:"
"`weakref-support`."
msgstr ""
"拡張型は、簡単に弱参照をサポートできます。詳細については、 :ref:`weakref-"
"support` を参照してください。"

#: ../../library/weakref.rst:87
msgid ""
"Return a weak reference to *object*.  The original object can be retrieved "
"by calling the reference object if the referent is still alive; if the "
"referent is no longer alive, calling the reference object will cause :const:"
"`None` to be returned.  If *callback* is provided and not :const:`None`, and "
"the returned weakref object is still alive, the callback will be called when "
"the object is about to be finalized; the weak reference object will be "
"passed as the only parameter to the callback; the referent will no longer be "
"available."
msgstr ""
"*object* への弱参照を返します。リファレントがまだ生きているならば、元のオブ"
"ジェクトは参照オブジェクトの呼び出しで取り出せす。リファレントがもはや生きて"
"いないならば、参照オブジェクトを呼び出したときに :const:`None` を返します。 "
"*callback* に :const:`None` 以外の値を与えた場合、オブジェクトをまさに後始末"
"処理しようとするときに呼び出します。このとき弱参照オブジェクトは *callback* "
"の唯一のパラメタとして渡されます。リファレントはもはや利用できません。"

#: ../../library/weakref.rst:95
msgid ""
"It is allowable for many weak references to be constructed for the same "
"object. Callbacks registered for each weak reference will be called from the "
"most recently registered callback to the oldest registered callback."
msgstr ""
"同じオブジェクトに対してたくさんの弱参照を作れます。それぞれの弱参照に対して"
"登録されたコールバックは、もっとも新しく登録されたコールバックからもっとも古"
"いものへと呼び出されます。"

#: ../../library/weakref.rst:99
msgid ""
"Exceptions raised by the callback will be noted on the standard error "
"output, but cannot be propagated; they are handled in exactly the same way "
"as exceptions raised from an object's :meth:`__del__` method."
msgstr ""
"コールバックが発生させた例外は標準エラー出力に書き込まれますが、伝播されませ"
"ん。それらはオブジェクトの :meth:`__del__` メソッドが発生させる例外と完全に同"
"じ方法で処理されます。"

#: ../../library/weakref.rst:103
msgid ""
"Weak references are :term:`hashable` if the *object* is hashable.  They will "
"maintain their hash value even after the *object* was deleted.  If :func:"
"`hash` is called the first time only after the *object* was deleted, the "
"call will raise :exc:`TypeError`."
msgstr ""
"*object* がハッシュ可能(:term:`hashable`)ならば、弱参照はハッシュ可能です。そ"
"れらは *object* が削除された後でもそれらのハッシュ値を保持します。 *object* "
"が削除されてから初めて :func:`hash` が呼び出された場合に、その呼び出しは :"
"exc:`TypeError` を発生させます。"

#: ../../library/weakref.rst:108
msgid ""
"Weak references support tests for equality, but not ordering.  If the "
"referents are still alive, two references have the same equality "
"relationship as their referents (regardless of the *callback*).  If either "
"referent has been deleted, the references are equal only if the reference "
"objects are the same object."
msgstr ""
"弱参照は等価性のテストをサポートしていますが、順序をサポートしていません。参"
"照がまだ生きているならば、 *callback* に関係なく二つの参照はそれらのリファレ"
"ントと同じ等価関係を持ちます。リファレントのどちらか一方が削除された場合、参"
"照オブジェクトが同一である場合に限り、その参照は等価です。"

#: ../../library/weakref.rst:113
msgid ""
"This is now a subclassable type rather than a factory function; it derives "
"from :class:`object`."
msgstr ""
"以前はファクトリでしたが、サブクラス化可能な型になりました。 :class:`object` "
"型から派生しています."

#: ../../library/weakref.rst:120
msgid ""
"Return a proxy to *object* which uses a weak reference.  This supports use "
"of the proxy in most contexts instead of requiring the explicit "
"dereferencing used with weak reference objects.  The returned object will "
"have a type of either ``ProxyType`` or ``CallableProxyType``, depending on "
"whether *object* is callable.  Proxy objects are not :term:`hashable` "
"regardless of the referent; this avoids a number of problems related to "
"their fundamentally mutable nature, and prevent their use as dictionary "
"keys.  *callback* is the same as the parameter of the same name to the :func:"
"`ref` function."
msgstr ""
"弱参照を使う *object* へのプロキシを返します。弱参照オブジェクトを明示的な参"
"照外しをしながら利用する代わりに、多くのケースでプロキシを利用することができ"
"ます。返されるオブジェクトは、 *object* が呼び出し可能かどうかによって、 "
"``ProxyType`` または ``CallableProxyType`` のどちらかの型を持ちます。プロキシ"
"オブジェクトはリファレントに関係なくハッシュ可能(:term:`hashable`)ではありま"
"せん。これによって、それらの基本的な変更可能という性質による多くの問題を避け"
"ています。そして、辞書のキーとしての利用を妨げます。 *callback* は :func:"
"`ref` 関数の同じ名前のパラメータと同じものです。(--- 訳注: リファレントが変更"
"不能型であっても、プロキシはリファレントが消えるという状態の変更があるため"
"に、変更可能型です。---)"

#: ../../library/weakref.rst:132
msgid ""
"Return the number of weak references and proxies which refer to *object*."
msgstr "*object* を参照する弱参照とプロキシの数を返します。"

#: ../../library/weakref.rst:137
msgid ""
"Return a list of all weak reference and proxy objects which refer to "
"*object*."
msgstr ""
"*object* を参照するすべての弱参照とプロキシオブジェクトのリストを返します。"

#: ../../library/weakref.rst:142
msgid ""
"Mapping class that references keys weakly.  Entries in the dictionary will "
"be discarded when there is no longer a strong reference to the key.  This "
"can be used to associate additional data with an object owned by other parts "
"of an application without adding attributes to those objects.  This can be "
"especially useful with objects that override attribute accesses."
msgstr ""
"キーを弱参照するマッピングクラス。キーへの強参照がなくなったときに、辞書のエ"
"ントリは捨てられます。アプリケーションの他の部分が所有するオブジェクトへ属性"
"を追加することもなく、それらのオブジェクトに追加データを関連づけるために使う"
"ことができます。これは属性へのアクセスをオーバーライドするオブジェクトに特に"
"便利です。"

#: ../../library/weakref.rst:150
msgid ""
"Caution: Because a :class:`WeakKeyDictionary` is built on top of a Python "
"dictionary, it must not change size when iterating over it.  This can be "
"difficult to ensure for a :class:`WeakKeyDictionary` because actions "
"performed by the program during iteration may cause items in the dictionary "
"to vanish \"by magic\" (as a side effect of garbage collection)."
msgstr ""
"警告: :class:`WeakKeyDictionary` は Python 辞書型の上に作られているので、反復"
"処理を行うときにはサイズ変更してはなりません。 :class:`WeakKeyDictionary` の"
"場合、反復処理の最中にプログラムが行った操作が、(ガベージコレクションの副作用"
"として) 「魔法のように」辞書内の要素を消し去ってしまうため、確実なサイズ変更"
"は困難なのです。"

#: ../../library/weakref.rst:156
msgid ""
":class:`WeakKeyDictionary` objects have the following additional methods.  "
"These expose the internal references directly.  The references are not "
"guaranteed to be \"live\" at the time they are used, so the result of "
"calling the references needs to be checked before being used.  This can be "
"used to avoid creating references that will cause the garbage collector to "
"keep the keys around longer than needed."
msgstr ""
":class:`WeakKeyDictionary` オブジェクトは、以下の追加のメソッドを持ちます。こ"
"れらのメソッドは、内部の参照を直接公開します。その参照は、利用される時に生存"
"しているとは限りません。なので、参照を利用する前に、その参照をチェックする必"
"要があります。これにより、必要なくなったキーの参照が残っているために、ガベー"
"ジコレクタがそのキーを削除できなくなる事態を避ける事ができます。"

#: ../../library/weakref.rst:166
msgid "Return an iterable of the weak references to the keys."
msgstr "キーへの弱参照を持つ iterable オブジェクトを返します。"

#: ../../library/weakref.rst:173
msgid "Return a list of weak references to the keys."
msgstr "キーへの弱参照のリストを返します。"

#: ../../library/weakref.rst:180
msgid ""
"Mapping class that references values weakly.  Entries in the dictionary will "
"be discarded when no strong reference to the value exists any more."
msgstr ""
"値を弱参照するマッピングクラス。値への強参照が存在しなくなったときに、辞書の"
"エントリは捨てられます。"

#: ../../library/weakref.rst:185
msgid ""
"Caution:  Because a :class:`WeakValueDictionary` is built on top of a Python "
"dictionary, it must not change size when iterating over it.  This can be "
"difficult to ensure for a :class:`WeakValueDictionary` because actions "
"performed by the program during iteration may cause items in the dictionary "
"to vanish \"by magic\" (as a side effect of garbage collection)."
msgstr ""
"警告: :class:`WeakValueDictionary` は Python 辞書型の上に作られているので、反"
"復処理を行うときにはサイズ変更してはなりません。 :class:"
"`WeakValueDictionary` の場合、反復処理の最中にプログラムが行った操作が、(ガ"
"ベージコレクションの副作用として) 「魔法のように」辞書内の要素を消し去ってし"
"まうため、確実なサイズ変更は困難なのです。"

#: ../../library/weakref.rst:191
msgid ""
":class:`WeakValueDictionary` objects have the following additional methods. "
"These methods have the same issues as the :meth:`iterkeyrefs` and :meth:"
"`keyrefs` methods of :class:`WeakKeyDictionary` objects."
msgstr ""
":class:`WeakValueDictionary` オブジェクトは次のメソッドも備えています。\n"
"これらのメソッドは、 :class:`WeakKeyDictionary` オブジェクトの :meth:"
"`iterkeyrefs` メソッドや :meth:`keyrefs` メソッドと同じ問題を抱えています。"

#: ../../library/weakref.rst:198
msgid "Return an iterable of the weak references to the values."
msgstr "値への弱参照を持つ iterable オブジェクトを返します。"

#: ../../library/weakref.rst:205
msgid "Return a list of weak references to the values."
msgstr "値への弱参照のリストを返します。"

#: ../../library/weakref.rst:212
msgid ""
"Set class that keeps weak references to its elements.  An element will be "
"discarded when no strong reference to it exists any more."
msgstr ""
"要素への弱参照を持つ集合型。要素への強参照が無くなったときに、その要素は削除"
"されます。"

#: ../../library/weakref.rst:220
msgid "The type object for weak references objects."
msgstr "弱参照オブジェクトのための型オブジェクト。"

#: ../../library/weakref.rst:225
msgid "The type object for proxies of objects which are not callable."
msgstr "呼び出し可能でないオブジェクトのプロキシのための型オブジェクト。"

#: ../../library/weakref.rst:230
msgid "The type object for proxies of callable objects."
msgstr "呼び出し可能なオブジェクトのプロキシのための型オブジェクト。"

#: ../../library/weakref.rst:235
msgid ""
"Sequence containing all the type objects for proxies.  This can make it "
"simpler to test if an object is a proxy without being dependent on naming "
"both proxy types."
msgstr ""
"プロキシのためのすべての型オブジェクトを含むシーケンス。これは両方のプロキシ"
"型の名前付けに依存しないで、オブジェクトがプロキシかどうかのテストをより簡単"
"にできます。"

#: ../../library/weakref.rst:242
msgid ""
"Exception raised when a proxy object is used but the underlying object has "
"been collected.  This is the same as the standard :exc:`ReferenceError` "
"exception."
msgstr ""
"プロキシオブジェクトが使われても、元のオブジェクトがガベージコレクションされ"
"てしまっているときに発生する例外。これは標準の :exc:`ReferenceError` 例外と同"
"じです。"

#: ../../library/weakref.rst:249
msgid ":pep:`205` - Weak References"
msgstr ":pep:`205` - 弱参照"

#: ../../library/weakref.rst:249
msgid ""
"The proposal and rationale for this feature, including links to earlier "
"implementations and information about similar features in other languages."
msgstr ""
"この機能の提案と理論的根拠。初期の実装と他の言語における類似の機能についての"
"情報へのリンクを含んでいます。"

#: ../../library/weakref.rst:256
msgid "Weak Reference Objects"
msgstr "弱参照オブジェクト"

#: ../../library/weakref.rst:258
msgid ""
"Weak reference objects have no attributes or methods, but do allow the "
"referent to be obtained, if it still exists, by calling it:"
msgstr ""
"弱参照オブジェクトは属性あるいはメソッドを持ちません。しかし、リファレントが"
"まだ存在するならば、呼び出すことでそのリファレントを取得できるようにします::"

#: ../../library/weakref.rst:271
msgid ""
"If the referent no longer exists, calling the reference object returns :"
"const:`None`:"
msgstr ""
"リファレントがもはや存在しないならば、参照オブジェクトの呼び出しは :const:"
"`None` を返します:"

#: ../../library/weakref.rst:278
msgid ""
"Testing that a weak reference object is still live should be done using the "
"expression ``ref() is not None``.  Normally, application code that needs to "
"use a reference object should follow this pattern::"
msgstr ""
"弱参照オブジェクトがまだ生きているかどうかのテストは、式 ``ref() is not "
"None`` を用いて行われます。通常、参照オブジェクトを使う必要があるアプリケー"
"ションコードはこのパターンに従います::"

#: ../../library/weakref.rst:291
msgid ""
"Using a separate test for \"liveness\" creates race conditions in threaded "
"applications; another thread can cause a weak reference to become "
"invalidated before the weak reference is called; the idiom shown above is "
"safe in threaded applications as well as single-threaded applications."
msgstr ""
"\"生存性(liveness)\"のテストを分割すると、スレッド化されたアプリケーションに"
"おいて競合状態を作り出します。 (訳注:``if r() is not None: r()."
"do_something()`` では、2度目のr()がNoneを返す可能性があります) 弱参照が呼び出"
"される前に、他のスレッドは弱参照が無効になる原因となり得ます。上で示したイ"
"ディオムは、シングルスレッドのアプリケーションと同じくマルチスレッド化された"
"アプリケーションにおいても安全です。"

#: ../../library/weakref.rst:296
msgid ""
"Specialized versions of :class:`ref` objects can be created through "
"subclassing. This is used in the implementation of the :class:"
"`WeakValueDictionary` to reduce the memory overhead for each entry in the "
"mapping.  This may be most useful to associate additional information with a "
"reference, but could also be used to insert additional processing on calls "
"to retrieve the referent."
msgstr ""
"サブクラス化を行えば、 :class:`ref` オブジェクトの特殊なバージョンを作成でき"
"ます。これは :class:`WeakValueDictionary` の実装で使われており、マップ内の各"
"エントリによるメモリのオーバヘッドを減らしています。こうした実装は、ある参照"
"に追加情報を関連付けたい場合に便利ですし、リファレントを取り出すための呼び出"
"し時に何らかの追加処理を行いたい場合にも使えます。"

#: ../../library/weakref.rst:302
msgid ""
"This example shows how a subclass of :class:`ref` can be used to store "
"additional information about an object and affect the value that's returned "
"when the referent is accessed::"
msgstr ""
"以下の例では、 :class:`ref` のサブクラスを使って、あるオブジェクトに追加情報"
"を保存し、リファレントがアクセスされたときにその値に作用をできるようにするた"
"めの方法を示しています::"

#: ../../library/weakref.rst:329
msgid "Example"
msgstr "例"

#: ../../library/weakref.rst:331
msgid ""
"This simple example shows how an application can use object IDs to retrieve "
"objects that it has seen before.  The IDs of the objects can then be used in "
"other data structures without forcing the objects to remain alive, but the "
"objects can still be retrieved by ID if they do."
msgstr ""
"この簡単な例では、アプリケーションが以前に参照したオブジェクトを取り出すため"
"にオブジェクトIDを利用する方法を示します。オブジェクトに生きたままであること"
"を強制することなく、オブジェクトの IDを他のデータ構造の中で使うことができ、必"
"要に応じてIDからオブジェクトを取り出せます。"
