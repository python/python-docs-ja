# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# E. Kawashima, 2017
# Arihiro TAKASE, 2017
# Naoki INADA <songofacandy@gmail.com>, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2017
# Shun Sakurai, 2017
# tomoğŸ§, 2017
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2017
# Akihiro Uchida <uchida@turbare.net>, 2017
# Osamu NAKAMURA, 2017
# Nakamura Masahito <randomstep@gmail.com>, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-08 09:41+0900\n"
"PO-Revision-Date: 2017-02-16 23:26+0000\n"
"Last-Translator: Nakamura Masahito <randomstep@gmail.com>, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/shutil.rst:2
msgid ":mod:`shutil` --- High-level file operations"
msgstr ":mod:`shutil` --- é«˜æ°´æº–ã®ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ"

#: ../../library/shutil.rst:10
msgid "**Source code:** :source:`Lib/shutil.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/shutil.py`"

#: ../../library/shutil.rst:18
msgid ""
"The :mod:`shutil` module offers a number of high-level operations on files "
"and collections of files.  In particular, functions are provided  which "
"support file copying and removal. For operations on individual files, see "
"also the :mod:`os` module."
msgstr ""
":mod:`shutil` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒ•ã‚¡ã‚¤ãƒ«ã®é›†ã¾ã‚Šã«å¯¾ã™ã‚‹é«˜æ°´æº–ã®æ“ä½œæ–¹æ³•ã‚’å¤šæ•°æä¾›ã—ã¾ã™ã€‚ç‰¹ã«ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚³ãƒ”ãƒ¼ã‚„å‰Šé™¤ã®ãŸã‚ã®é–¢æ•°ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚å€‹åˆ¥ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã™ã‚‹æ“ä½œã«ã¤ã„ã¦ã¯ã€"
" :mod:`os` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/shutil.rst:25
msgid ""
"Even the higher-level file copying functions (:func:`shutil.copy`, "
":func:`shutil.copy2`) cannot copy all file metadata."
msgstr ""
"é«˜æ°´æº–ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚³ãƒ”ãƒ¼é–¢æ•° (:func:`shutil.copy`, :func:`shutil.copy2`) "
"ã§ã‚‚ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å…¨ã¦ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/shutil.rst:28
msgid ""
"On POSIX platforms, this means that file owner and group are lost as well as"
" ACLs.  On Mac OS, the resource fork and other metadata are not used. This "
"means that resources will be lost and file type and creator codes will not "
"be correct. On Windows, file owners, ACLs and alternate data streams are not"
" copied."
msgstr ""
"POSIXãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€ã“ã‚Œã¯ACLã‚„ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚ªãƒ¼ãƒŠãƒ¼ã€ã‚°ãƒ«ãƒ¼ãƒ—ãŒå¤±ã‚ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€‚ Mac "
"OSã§ã¯ã€ãƒªã‚½ãƒ¼ã‚¹ãƒ•ã‚©ãƒ¼ã‚¯(resource "
"fork)ã‚„ãã®ä»–ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒåˆ©ç”¨ã•ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€ãƒªã‚½ãƒ¼ã‚¹ãŒå¤±ã‚ã‚Œã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã‚„ç”Ÿæˆè€…ã‚³ãƒ¼ãƒ‰(creator "
"code)ãŒæ­£ã—ããªããªã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€‚ Windowsã§ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒŠãƒ¼ã€ACLã€ä»£æ›¿ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/shutil.rst:38
msgid "Directory and files operations"
msgstr "ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ãƒ•ã‚¡ã‚¤ãƒ«ã®æ“ä½œ"

#: ../../library/shutil.rst:42
msgid ""
"Copy the contents of the file-like object *fsrc* to the file-like object "
"*fdst*. The integer *length*, if given, is the buffer size. In particular, a"
" negative *length* value means to copy the data without looping over the "
"source data in chunks; by default the data is read in chunks to avoid "
"uncontrolled memory consumption. Note that if the current file position of "
"the *fsrc* object is not 0, only the contents from the current file position"
" to the end of the file will be copied."
msgstr ""
"ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *fsrc* ã®å†…å®¹ã‚’ *fdst* ã¸ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚æ•´æ•°å€¤ *length* "
"ã¯ä¸ãˆã‚‰ã‚ŒãŸå ´åˆãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã‚’è¡¨ã—ã¾ã™ã€‚ç‰¹ã« *length* "
"ãŒè² ã®å ´åˆã€ãƒãƒ£ãƒ³ã‚¯å†…ã®ã‚½ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ç¹°ã‚Šè¿”ã—æ“ä½œã™ã‚‹ã“ã¨ãªããƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€åˆ¶å¾¡ä¸èƒ½ãªãƒ¡ãƒ¢ãƒªæ¶ˆè²»ã‚’é¿ã‘ã‚‹ãŸã‚ã«ãƒ‡ãƒ¼ã‚¿ã¯ãƒãƒ£ãƒ³ã‚¯å†…ã«èª­ã¿è¾¼ã¾ã‚Œã¾ã™ã€‚"
" *fsrc* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ä½ç½®ãŒ0ã§ãªã„å ´åˆã€ç¾åœ¨ã®ä½ç½®ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«çµ‚ç«¯ã¾ã§ã®å†…å®¹ã®ã¿ãŒã‚³ãƒ”ãƒ¼ã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/shutil.rst:53
msgid ""
"Copy the contents (no metadata) of the file named *src* to a file named "
"*dst* and return *dst*.  *src* and *dst* are path names given as strings. "
"*dst* must be the complete target file name; look at :func:`shutil.copy` for"
" a copy that accepts a target directory path.  If *src* and *dst* specify "
"the same file, :exc:`SameFileError` is raised."
msgstr ""
"*src* ã¨ã„ã†åå‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ (ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å«ã¾ãªã„) ã‚’ *dst* ã¨ã„ã†åå‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚³ãƒ”ãƒ¼ã—ã€*dst* ã‚’è¿”ã—ã¾ã™ã€‚ *src* "
"ã¨ *dst* ã¯æ–‡å­—åˆ—ã§ãƒ‘ã‚¹åã‚’æŒ‡å®šã—ã¾ã™ã€‚ *dst* ã¯å®Œå…¨ãªå¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«åã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å¯¾è±¡ã¨ã—ã¦ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã‚’æŒ‡å®šã—ãŸã„å ´åˆã¯ "
":func:`shutil.copy` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ *src* ã¨ *dst* ãŒåŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã ã£ãŸå ´åˆã€ "
":exc:`SameFileError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:59
msgid ""
"The destination location must be writable; otherwise, an :exc:`OSError` "
"exception will be raised. If *dst* already exists, it will be replaced. "
"Special files such as character or block devices and pipes cannot be copied "
"with this function."
msgstr ""
"*dst* ã¯æ›¸ãè¾¼ã¿å¯èƒ½ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã†ã§ãªã„å ´åˆã€ :exc:`OSError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚ *dst* "
"ãŒã™ã§ã«å­˜åœ¨ã™ã‚‹å ´åˆã€ãã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ‡ãƒã‚¤ã‚¹ã‚„ãƒ–ãƒ­ãƒƒã‚¯ãƒ‡ãƒã‚¤ã‚¹ãªã©ã®ç‰¹æ®Šãªãƒ•ã‚¡ã‚¤ãƒ«ã¨ãƒ‘ã‚¤ãƒ—ã‚’ã“ã®é–¢æ•°ã§ã‚³ãƒ”ãƒ¼ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/shutil.rst:64
msgid ""
"If *follow_symlinks* is false and *src* is a symbolic link, a new symbolic "
"link will be created instead of copying the file *src* points to."
msgstr ""
"*follow_symlinks* ãŒå½ã§ *src* ãŒã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®å ´åˆã€ *src* "
"ã®ãƒªãƒ³ã‚¯å…ˆã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ä»£ã‚ã‚Šã«æ–°ã—ã„ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:68
msgid ""
":exc:`IOError` used to be raised instead of :exc:`OSError`. Added "
"*follow_symlinks* argument. Now returns *dst*."
msgstr ""
"ä»¥å‰ã¯ :exc:`OSError` ã®ä»£ã‚ã‚Šã« :exc:`IOError` ãŒé€å‡ºã•ã‚Œã¦ã„ã¾ã—ãŸã€‚ *follow_symlinks* "
"å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ *dst* ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/shutil.rst:73
msgid ""
"Raise :exc:`SameFileError` instead of :exc:`Error`.  Since the former is a "
"subclass of the latter, this change is backward compatible."
msgstr ""
":exc:`Error` ã®ä»£ã‚ã‚Šã« :exc:`SameFileError` ã‚’é€å‡ºã—ã¾ã™ã€‚å¾Œè€…ã¯å‰è€…ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãªã®ã§ã“ã®å¤‰æ›´ã¯å¾Œæ–¹äº’æ›ã§ã™ã€‚"

#: ../../library/shutil.rst:80
msgid ""
"This exception is raised if source and destination in :func:`copyfile` are "
"the same file."
msgstr ":func:`copyfile` ã®ã‚³ãƒ”ãƒ¼å…ƒã¨å…ˆãŒåŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/shutil.rst:88
msgid ""
"Copy the permission bits from *src* to *dst*.  The file contents, owner, and"
" group are unaffected.  *src* and *dst* are path names given as strings. If "
"*follow_symlinks* is false, and both *src* and *dst* are symbolic links, "
":func:`copymode` will attempt to modify the mode of *dst* itself (rather "
"than the file it points to).  This functionality is not available on every "
"platform; please see :func:`copystat` for more information.  If "
":func:`copymode` cannot modify symbolic links on the local platform, and it "
"is asked to do so, it will do nothing and return."
msgstr ""
"ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³ã‚’ *src* ã‹ã‚‰ *dst* ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã€ã‚ªãƒ¼ãƒŠãƒ¼ã€ã‚°ãƒ«ãƒ¼ãƒ—ã«ã¯å½±éŸ¿ã—ã¾ã›ã‚“ã€‚ *src* ã¨ *dst* "
"ã¯æ–‡å­—åˆ—ã§ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹åã‚’æŒ‡å®šã—ã¾ã™ã€‚ *follow_symlinks* ãŒå½ã§ã€*src* ãŠã‚ˆã³ *dst* ãŒã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®å ´åˆã€ "
":func:`copymode` ã¯ (ãƒªãƒ³ã‚¯å…ˆã§ã¯ãªã)  *dst* "
"è‡ªä½“ã®ãƒ¢ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã—ã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã¯å…¨ã¦ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ä½¿ãˆã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è©³ã—ãã¯ :func:`copystat` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®å¤‰æ›´ã‚’ã—ã‚ˆã†ã¨ã—ãŸæ™‚ã€ :func:`copymode` "
"ãŒãƒ­ãƒ¼ã‚«ãƒ«ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‚’å¤‰æ›´ã§ããªã„å ´åˆã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚"

#: ../../library/shutil.rst:97
msgid "Added *follow_symlinks* argument."
msgstr "*follow_symlinks* å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/shutil.rst:102
msgid ""
"Copy the permission bits, last access time, last modification time, and "
"flags from *src* to *dst*.  On Linux, :func:`copystat` also copies the "
"\"extended attributes\" where possible.  The file contents, owner, and group"
" are unaffected.  *src* and *dst* are path names given as strings."
msgstr ""
"ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³ã€æœ€çµ‚ã‚¢ã‚¯ã‚»ã‚¹æ™‚é–“ã€æœ€çµ‚å¤‰æ›´æ™‚é–“ã€ãã®ä»–ã®ãƒ•ãƒ©ã‚°ã‚’ *src* ã‹ã‚‰ *dst* ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚ Linux ã§ã¯ã€ "
":func:`copystat` ã¯å¯èƒ½ãªã‚‰ \"æ‹¡å¼µå±æ€§\" ã‚‚ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã€ã‚ªãƒ¼ãƒŠãƒ¼ã€ã‚°ãƒ«ãƒ¼ãƒ—ã«ã¯å½±éŸ¿ã—ã¾ã›ã‚“ã€‚ *src* ã¨ "
"*dst* ã¯æ–‡å­—åˆ—ã§ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹åã‚’æŒ‡å®šã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:107
msgid ""
"If *follow_symlinks* is false, and *src* and *dst* both refer to symbolic "
"links, :func:`copystat` will operate on the symbolic links themselves rather"
" than the files the symbolic links refer toâ€”reading the information from the"
" *src* symbolic link, and writing the information to the *dst* symbolic "
"link."
msgstr ""
"*follow_symlinks* ãŒå½ã®å ´åˆã€ *src* ã¨ *dst* ã®ä¸¡æ–¹ãŒã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã§ã‚ã‚Œã°ã€ :func:`copystat` "
"ã¯ãƒªãƒ³ã‚¯å…ˆã§ã¯ãªãã¦ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯è‡ªä½“ã‚’æ“ä½œã—ã¾ã™ã€‚ *src* ã‹ã‚‰ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®æƒ…å ±ã‚’èª­ã¿è¾¼ã¿ã€ *dst* "
"ã®ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã«ãã®æƒ…å ±ã‚’æ›¸ãè¾¼ã¿ã¾ã™ã€‚"

#: ../../library/shutil.rst:116
msgid ""
"Not all platforms provide the ability to examine and modify symbolic links."
"  Python itself can tell you what functionality is locally available."
msgstr ""
"ã™ã¹ã¦ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®æ¤œæŸ»ã¨å¤‰æ›´ãŒã§ãã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ Python "
"ã¯ãã®æ©Ÿèƒ½ãŒåˆ©ç”¨ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹æ–¹æ³•ã‚’ç”¨æ„ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/shutil.rst:120
msgid ""
"If ``os.chmod in os.supports_follow_symlinks`` is ``True``, :func:`copystat`"
" can modify the permission bits of a symbolic link."
msgstr ""
"``os.chmod in os.supports_follow_symlinks`` ãŒ ``True`` ã®å ´åˆ :func:`copystat` "
"ã¯ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚"

#: ../../library/shutil.rst:124
msgid ""
"If ``os.utime in os.supports_follow_symlinks`` is ``True``, :func:`copystat`"
" can modify the last access and modification times of a symbolic link."
msgstr ""
"``os.utime in os.supports_follow_symlinks`` ãŒ ``True`` ã®å ´åˆ :func:`copystat` "
"ã¯ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®æœ€çµ‚ã‚¢ã‚¯ã‚»ã‚¹æ™‚é–“ã¨æœ€çµ‚å¤‰æ›´æ™‚é–“ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚"

#: ../../library/shutil.rst:128
msgid ""
"If ``os.chflags in os.supports_follow_symlinks`` is ``True``, "
":func:`copystat` can modify the flags of a symbolic link.  (``os.chflags`` "
"is not available on all platforms.)"
msgstr ""
"``os.chflags in os.supports_follow_symlinks`` ãŒ ``True`` ã®å ´åˆ "
":func:`copystat` ã¯ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®ãƒ•ãƒ©ã‚°ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚ (``os.chflags`` ãŒãªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚‚ã‚ã‚Šã¾ã™ã€‚)"

#: ../../library/shutil.rst:133
msgid ""
"On platforms where some or all of this functionality is unavailable, when "
"asked to modify a symbolic link, :func:`copystat` will copy everything it "
"can. :func:`copystat` never returns failure."
msgstr ""
"æ©Ÿèƒ½ã®å¹¾ã¤ã‹ã€ã‚‚ã—ãã¯å…¨ã¦ãŒåˆ©ç”¨ã§ããªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‚’å¤‰æ›´ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã€ :func:`copystat` "
"ã¯å¯èƒ½ãªé™ã‚Šå…¨ã¦ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚:func:`copystat` ãŒå¤±æ•—ã‚’è¿”ã™ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/shutil.rst:138
msgid "Please see :data:`os.supports_follow_symlinks` for more information."
msgstr "ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã¯ :data:`os.supports_follow_symlinks` ã‚’å‚ç…§ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/shutil.rst:141
msgid ""
"Added *follow_symlinks* argument and support for Linux extended attributes."
msgstr "*follow_symlinks* å¼•æ•°ã¨ Linux ã®æ‹¡å¼µå±æ€§ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/shutil.rst:146
msgid ""
"Copies the file *src* to the file or directory *dst*.  *src* and *dst* "
"should be strings.  If *dst* specifies a directory, the file will be copied "
"into *dst* using the base filename from *src*.  Returns the path to the "
"newly created file."
msgstr ""
"ãƒ•ã‚¡ã‚¤ãƒ« *src* ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª *dst* ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚ *src* ã¨ *dst* ã¯ä¸¡æ–¹å…±æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ "
"*dst* ãŒãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æŒ‡å®šã—ã¦ã„ã‚‹å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«ã¯ *dst* ã®ä¸­ã«ã€ *src* "
"ã®ãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ä½¿ã£ã¦ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã™ã€‚æ–°ã—ãä½œæˆã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:151
msgid ""
"If *follow_symlinks* is false, and *src* is a symbolic link, *dst* will be "
"created as a symbolic link.  If *follow_symlinks* is true and *src* is a "
"symbolic link, *dst* will be a copy of the file *src* refers to."
msgstr ""
"*follow_symlinks* ãŒå½ã§ã€ *src* ãŒã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®å ´åˆã€ *dst* ã¯ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã¨ã—ã¦ä½œæˆã•ã‚Œã¾ã™ã€‚ "
"*follow_symlinks* ãŒçœŸã§ *src* ãŒã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®å ´åˆã€ *dst* ã«ã¯ *src* "
"ã®ãƒªãƒ³ã‚¯å…ˆã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã™ã€‚"

#: ../../library/shutil.rst:156
msgid ""
":func:`~shutil.copy` copies the file data and the file's permission mode "
"(see :func:`os.chmod`).  Other metadata, like the file's creation and "
"modification times, is not preserved. To preserve all file metadata from the"
" original, use :func:`~shutil.copy2` instead."
msgstr ""
":func:`~shutil.copy` ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ãƒ¼ã‚¿ã¨ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚ (:func:`os.chmod` ã‚’å‚ç…§)\n"
"ãã®ä»–ã®ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆæ™‚é–“ã‚„å¤‰æ›´æ™‚é–“ãªã©ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¯ã‚³ãƒ”ãƒ¼ã—ã¾ã›ã‚“ã€‚\n"
"ã‚³ãƒ”ãƒ¼å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ãŸã„å ´åˆã¯ã€ :func:`~shutils.copy2` ã‚’åˆ©ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/shutil.rst:162
msgid ""
"Added *follow_symlinks* argument. Now returns path to the newly created "
"file."
msgstr "*follow_symlinks* å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚æ–°ã—ãä½œæˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/shutil.rst:168
msgid ""
"Identical to :func:`~shutil.copy` except that :func:`copy2` also attempts to"
" preserve file metadata."
msgstr ""

#: ../../library/shutil.rst:171
msgid ""
"When *follow_symlinks* is false, and *src* is a symbolic link, :func:`copy2`"
" attempts to copy all metadata from the *src* symbolic link to the newly-"
"created *dst* symbolic link. However, this functionality is not available on"
" all platforms. On platforms where some or all of this functionality is "
"unavailable, :func:`copy2` will preserve all the metadata it can; "
":func:`copy2` never returns failure."
msgstr ""
"*follow_symlinks* ãŒå½ã§ã€ *src* ãŒã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®å ´åˆã€ :func:`copy2` ã¯ *src* "
"ã®ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‹ã‚‰ã™ã¹ã¦ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æ–°è¦ã«ä½œæˆã—ãŸ *dst* "
"ã®ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã«ã‚³ãƒ”ãƒ¼ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚ã—ã‹ã—ãªãŒã‚‰ã€ã“ã®æ©Ÿèƒ½ã¯å…¨ã¦ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§åˆ©ç”¨ã§ãã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æ©Ÿèƒ½ã®å¹¾ã¤ã‹ã€ã‚‚ã—ãã¯å…¨ã¦ãŒåˆ©ç”¨ã§ããªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®å ´åˆã€"
" :func:`copy2` ã¯å¯èƒ½ãªé™ã‚Šå…¨ã¦ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚:func:`copy2` ãŒå¤±æ•—ã‚’è¿”ã™ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/shutil.rst:179
msgid ""
":func:`copy2` uses :func:`copystat` to copy the file metadata. Please see "
":func:`copystat` for more information about platform support for modifying "
"symbolic link metadata."
msgstr ""
":func:`copy2` ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ãŸã‚ã« :func:`copystat` "
"ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å¤‰æ›´ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚µãƒãƒ¼ãƒˆã«ã¤ã„ã¦ã¯ :func:`copystat` ã‚’å‚ç…§ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/shutil.rst:183
msgid ""
"Added *follow_symlinks* argument, try to copy extended file system "
"attributes too (currently Linux only). Now returns path to the newly created"
" file."
msgstr ""
"*follow_symlinks* å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ æ‹¡å¼µãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ å±æ€§ã‚‚ã‚³ãƒ”ãƒ¼ã—ã‚ˆã†ã¨è©¦ã¿ã¾ã™ (ç¾åœ¨ã¯ Linux "
"ã®ã¿)ã€‚æ–°ã—ãä½œæˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/shutil.rst:190
msgid ""
"This factory function creates a function that can be used as a callable for "
":func:`copytree`\\'s *ignore* argument, ignoring files and directories that "
"match one of the glob-style *patterns* provided.  See the example below."
msgstr ""
"ã“ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã¯ã€ :func:`copytree` é–¢æ•°ã® *ignore* å¼•æ•°ã«æ¸¡ã™ãŸã‚ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚ "
"globå½¢å¼ã® *patterns* ã«ãƒãƒƒãƒã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒç„¡è¦–ã•ã‚Œã¾ã™ã€‚ä¸‹ã®ä¾‹ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/shutil.rst:198
msgid ""
"Recursively copy an entire directory tree rooted at *src*, returning the "
"destination directory.  The destination directory, named by *dst*, must not "
"already exist; it will be created as well as missing parent directories.  "
"Permissions and times of directories are copied with :func:`copystat`, "
"individual files are copied using :func:`shutil.copy2`."
msgstr ""
"*src* ã‚’ãƒ«ãƒ¼ãƒˆã«ã—ãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ„ãƒªãƒ¼å…¨ä½“ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã€ã‚³ãƒ”ãƒ¼å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’è¿”ã—ã¾ã™ã€‚ã‚³ãƒ”ãƒ¼å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª *dst* "
"ã¯äº‹å‰ã«å­˜åœ¨ã—ã¦ã„ã¦ã¯ãªã‚‰ãšã€è¶³ã‚Šãªã„è¦ªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨åˆã‚ã›ã¦ä½œæˆã•ã‚Œã¾ã™ã€‚ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å„ç¨®æ™‚é–“ã‚„ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³ã¯ :func:`copystat` "
"ã§ã‚³ãƒ”ãƒ¼ã—ã€å„ãƒ•ã‚¡ã‚¤ãƒ«ã¯ :func:`shutil.copy2` ã§ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:205
msgid ""
"If *symlinks* is true, symbolic links in the source tree are represented as "
"symbolic links in the new tree and the metadata of the original links will "
"be copied as far as the platform allows; if false or omitted, the contents "
"and metadata of the linked files are copied to the new tree."
msgstr ""
"*symlinks* "
"ãŒçœŸã®å ´åˆã€ã‚½ãƒ¼ã‚¹ãƒ„ãƒªãƒ¼å†…ã®ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã¯æ–°ã—ã„ãƒ„ãƒªãƒ¼ã§ã‚‚ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ã«ãªã‚Šã€å…ƒã®ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãŒè¨±ã™é™ã‚Šã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã™ã€‚å½ã®å ´åˆã‚„çœç•¥ã•ã‚ŒãŸå ´åˆã€ãƒªãƒ³ã‚¯å…ˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã¨ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒæ–°ã—ã„ãƒ„ãƒªãƒ¼ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã™ã€‚"

#: ../../library/shutil.rst:210
msgid ""
"When *symlinks* is false, if the file pointed by the symlink doesn't exist, "
"an exception will be added in the list of errors raised in an :exc:`Error` "
"exception at the end of the copy process. You can set the optional "
"*ignore_dangling_symlinks* flag to true if you want to silence this "
"exception. Notice that this option has no effect on platforms that don't "
"support :func:`os.symlink`."
msgstr ""
"*symlinks* ãŒå½ã®å ´åˆã€ãƒªãƒ³ã‚¯å…ˆã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã‘ã‚Œã°ã€ã‚³ãƒ”ãƒ¼å‡¦ç†çµ‚äº†æ™‚ã«é€å‡ºã•ã‚Œã‚‹ :exc:`Error` "
"ä¾‹å¤–ã®ã‚¨ãƒ©ãƒ¼ãƒªã‚¹ãƒˆã«ä¾‹å¤–ãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *ignore_dangling_symlinks* "
"ãƒ•ãƒ©ã‚°ã‚’çœŸã«è¨­å®šã—ã¦ã“ã®ã‚¨ãƒ©ãƒ¼ã‚’é€å‡ºã•ã›ãªã„ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ :func:`os.symlink` "
"ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¸Šã§ã¯åŠ¹æœãŒãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/shutil.rst:217
msgid ""
"If *ignore* is given, it must be a callable that will receive as its "
"arguments the directory being visited by :func:`copytree`, and a list of its"
" contents, as returned by :func:`os.listdir`.  Since :func:`copytree` is "
"called recursively, the *ignore* callable will be called once for each "
"directory that is copied.  The callable must return a sequence of directory "
"and file names relative to the current directory (i.e. a subset of the items"
" in its second argument); these names will then be ignored in the copy "
"process.  :func:`ignore_patterns` can be used to create such a callable that"
" ignores names based on glob-style patterns."
msgstr ""
"*ignore* ã¯ :func:`copytree` ãŒèµ°æŸ»ã—ã¦ã„ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ :func:`os.listdir` "
"ãŒè¿”ã™ãã®å†…å®¹ã®ãƒªã‚¹ãƒˆã‚’å¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚‹ã“ã¨ã®ã§ãã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ :func:`copytree` "
"ã¯å†å¸°çš„ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã®ã§ã€ *ignore* ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œã‚‹å„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ¯ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ *ignore* "
"ã®æˆ»ã‚Šå€¤ã¯ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ç›¸å¯¾çš„ãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåãŠã‚ˆã³ãƒ•ã‚¡ã‚¤ãƒ«åã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ï¼ˆã™ãªã‚ã¡ç¬¬äºŒå¼•æ•°ã®é …ç›®ã®ã‚µãƒ–ã‚»ãƒƒãƒˆï¼‰ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã‚Œã‚‰ã®åå‰ã¯ã‚³ãƒ”ãƒ¼ä¸­ã«ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"
" :func:`ignore_patterns` ã‚’ç”¨ã„ã¦ glob å½¢å¼ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚ˆã£ã¦ç„¡è¦–ã™ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚"

#: ../../library/shutil.rst:227
msgid ""
"If exception(s) occur, an :exc:`Error` is raised with a list of reasons."
msgstr "ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸå ´åˆã€ç†ç”±ã®ãƒªã‚¹ãƒˆã¨ã¨ã‚‚ã« :exc:`Error` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:229
msgid ""
"If *copy_function* is given, it must be a callable that will be used to copy"
" each file. It will be called with the source path and the destination path "
"as arguments. By default, :func:`shutil.copy2` is used, but any function "
"that supports the same signature (like :func:`shutil.copy`) can be used."
msgstr ""
"*copy_function* ã¯å„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚*copy_function* "
"ã¯ã‚³ãƒ”ãƒ¼å…ƒã®ãƒ‘ã‚¹ã¨ã‚³ãƒ”ãƒ¼å…ˆã®ãƒ‘ã‚¹ã‚’å¼•æ•°ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ :func:`shutil.copy2` ãŒåˆ©ç”¨ã•ã‚Œã¾ã™ãŒã€åŒã˜ç‰¹å¾´ã‚’æŒã¤é–¢æ•° "
"(:func:`shutil.copy` ãªã©) ãªã‚‰ã©ã‚Œã§ã‚‚åˆ©ç”¨å¯èƒ½ã§ã™ã€‚"

#: ../../library/shutil.rst:234
msgid "Copy metadata when *symlinks* is false. Now returns *dst*."
msgstr "*symlinks* ãŒå½ã®å ´åˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚ *dst* ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/shutil.rst:238
msgid ""
"Added the *copy_function* argument to be able to provide a custom copy "
"function. Added the *ignore_dangling_symlinks* argument to silent dangling "
"symlinks errors when *symlinks* is false."
msgstr ""
"ã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ”ãƒ¼æ©Ÿèƒ½ã‚’æä¾›ã§ãã‚‹ã‚ˆã†ã« *copy_function* å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ *symlinks* ãŒå½ã®æ™‚ã«ãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚° "
"(å®™ã¶ã‚‰ã‚Šã‚“ã®) ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‚¨ãƒ©ãƒ¼ã‚’é€å‡ºã•ã›ãªã„ãŸã‚ã« *ignore_dangling_symlinks* å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/shutil.rst:249
msgid ""
"Delete an entire directory tree; *path* must point to a directory (but not a"
" symbolic link to a directory).  If *ignore_errors* is true, errors "
"resulting from failed removals will be ignored; if false or omitted, such "
"errors are handled by calling a handler specified by *onerror* or, if that "
"is omitted, they raise an exception."
msgstr ""
"ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ„ãƒªãƒ¼å…¨ä½“ã‚’å‰Šé™¤ã—ã¾ã™ã€‚ *path* ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æŒ‡ã—ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ "
"(ãŸã ã—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«å¯¾ã™ã‚‹ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã§ã¯ã„ã‘ã¾ã›ã‚“)ã€‚*ignore_errors* "
"ãŒçœŸã§ã‚ã‚‹å ´åˆã€å‰Šé™¤ã«å¤±æ•—ã—ãŸã“ã¨ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚å½ã‚„çœç•¥ã•ã‚ŒãŸå ´åˆã¯ã“ã‚Œã‚‰ã®ã‚¨ãƒ©ãƒ¼ã¯ *onerror* "
"ã§ä¸ãˆã‚‰ã‚ŒãŸãƒãƒ³ãƒ‰ãƒ©ã‚’å‘¼ã³å‡ºã—ã¦å‡¦ç†ã•ã‚Œã€*onerror* ãŒçœç•¥ã•ã‚ŒãŸå ´åˆã¯ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:257
msgid ""
"On platforms that support the necessary fd-based functions a symlink attack "
"resistant version of :func:`rmtree` is used by default.  On other platforms,"
" the :func:`rmtree` implementation is susceptible to a symlink attack: given"
" proper timing and circumstances, attackers can manipulate symlinks on the "
"filesystem to delete files they wouldn't be able to access otherwise.  "
"Applications can use the :data:`rmtree.avoids_symlink_attacks` function "
"attribute to determine which case applies."
msgstr ""
"å¿…è¦ãª fd ãƒ™ãƒ¼ã‚¹ã®é–¢æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€ ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯æ”»æ’ƒã«è€æ€§ã®ã‚ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® :func:`rmtree` "
"ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€ :func:`rmtree` "
"ã®å®Ÿè£…ã¯ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯æ”»æ’ƒã®å½±éŸ¿ã‚’å—ã‘ã¾ã™ã€‚é©å½“ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã¨ç’°å¢ƒã§æ”»æ’ƒè€…ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‚’æ“ä½œã—ã¦ã€ãã‚Œä»¥å¤–ã®æ–¹æ³•ã§ã¯ã‚¢ã‚¯ã‚»ã‚¹ä¸å¯èƒ½ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ã©ã¡ã‚‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®"
" :func:`rmtree` ãŒåˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹ã‚’çŸ¥ã‚‹ãŸã‚ã«é–¢æ•°ã®ãƒ‡ãƒ¼ã‚¿å±æ€§ "
":data:`rmtree.avoids_symlink_attacks` ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/shutil.rst:265
msgid ""
"If *onerror* is provided, it must be a callable that accepts three "
"parameters: *function*, *path*, and *excinfo*."
msgstr ""
"*onerror* ã‚’æŒ‡å®šã™ã‚‹å ´åˆã€ *function*, *path*, *excinfo* "
"ã®3ã¤ã®å¼•æ•°ã‚’å—ã‘å–ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/shutil.rst:268
msgid ""
"The first parameter, *function*, is the function which raised the exception;"
" it depends on the platform and implementation.  The second parameter, "
"*path*, will be the path name passed to *function*.  The third parameter, "
"*excinfo*, will be the exception information returned by "
":func:`sys.exc_info`.  Exceptions raised by *onerror* will not be caught."
msgstr ""
"æœ€åˆã®å¼•æ•° *function* ã¯ä¾‹å¤–ã‚’é€å‡ºã—ãŸé–¢æ•°ã§ã€ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚„å®Ÿè£…ã«ä¾å­˜ã—ã¾ã™ã€‚ç¬¬äºŒå¼•æ•° *path* ã¯ *function* "
"ã«æ¸¡ã•ã‚ŒãŸãƒ‘ã‚¹åã§ã™ã€‚ç¬¬ä¸‰å¼•æ•° *excinfo* ã¯ :func:`sys.exc_info` ãŒè¿”ã—ãŸä¾‹å¤–ã®æƒ…å ±ã§ã™ã€‚ *onerror* "
"ãŒé€å‡ºã—ãŸä¾‹å¤–ã¯æ•æ‰ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/shutil.rst:274
msgid ""
"Added a symlink attack resistant version that is used automatically if "
"platform supports fd-based functions."
msgstr "ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãŒ fd ãƒ™ãƒ¼ã‚¹ã®é–¢æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã«è‡ªå‹•çš„ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯æ”»æ’ƒã«è€æ€§ã®ã‚ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/shutil.rst:280
msgid ""
"Indicates whether the current platform and implementation provides a symlink"
" attack resistant version of :func:`rmtree`.  Currently this is only true "
"for platforms supporting fd-based directory access functions."
msgstr ""
"ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã¨å®Ÿè£…ãŒã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯æ”»æ’ƒã«è€æ€§ã®ã‚ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® :func:`rmtree` "
"ã‚’æä¾›ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã—ã¾ã™ã€‚ç¾åœ¨ã®ã¨ã“ã‚ã€ã“ã®å±æ€§ã¯ fd ãƒ™ãƒ¼ã‚¹ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚¢ã‚¯ã‚»ã‚¹é–¢æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã®ã¿çœŸã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/shutil.rst:289
msgid ""
"Recursively move a file or directory (*src*) to another location (*dst*) and"
" return the destination."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª (*src*) ã‚’å†å¸°çš„ã«åˆ¥ã®å ´æ‰€ (*dst*) ã«ç§»å‹•ã—ã¦ã€ç§»å‹•å…ˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:292
msgid ""
"If the destination is an existing directory, then *src* is moved inside that"
" directory. If the destination already exists but is not a directory, it may"
" be overwritten depending on :func:`os.rename` semantics."
msgstr ""
"ç§»å‹•å…ˆãŒå­˜åœ¨ã™ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å ´åˆã€ *src* ã¯ãã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ä¸­ã¸ç§»å‹•ã—ã¾ã™ã€‚ç§»å‹•å…ˆãŒå­˜åœ¨ã—ã¦ã„ã¦ãã‚ŒãŒãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ãªã„å ´åˆã€ "
":func:`os.rename` ã®å‹•ä½œã«ã‚ˆã£ã¦ã¯ä¸Šæ›¸ãã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/shutil.rst:296
msgid ""
"If the destination is on the current filesystem, then :func:`os.rename` is "
"used. Otherwise, *src* is copied to *dst* using *copy_function* and then "
"removed.  In case of symlinks, a new symlink pointing to the target of *src*"
" will be created in or as *dst* and *src* will be removed."
msgstr ""
"ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã«ã‚ã‚‹å ´åˆã€ :func:`os.rename` ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚\n"
"ãã‚Œä»¥å¤–ã®å ´åˆ *copy_function* ã‚’ä½¿ç”¨ã—ã¦ *src* ã‚’ *dst* ã«ã‚³ãƒ”ãƒ¼ã—ã€ãã®å¾Œå‰Šé™¤ã—ã¾ã™ã€‚\n"
"ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®å ´åˆã«ã¯ã€ *src* ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’æŒ‡ã™æ–°ã—ã„ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ãŒã€ *dst* ã®ä¸­ã¾ãŸã¯ *dst* ã¨ã—ã¦ä½œæˆã•ã‚Œã€ *src* ãŒå‰Šé™¤ã•ã‚Œã¾ã™ã€‚"

#: ../../library/shutil.rst:301
msgid ""
"If *copy_function* is given, it must be a callable that takes two arguments "
"*src* and *dst*, and will be used to copy *src* to *dest* if "
":func:`os.rename` cannot be used.  If the source is a directory, "
":func:`copytree` is called, passing it the :func:`copy_function`. The "
"default *copy_function* is :func:`copy2`.  Using :func:`~shutil.copy` as the"
" *copy_function* allows the move to succeed when it is not possible to also "
"copy the metadata, at the expense of not copying any of the metadata."
msgstr ""
"*copy_function* ã‚’æŒ‡å®šã™ã‚‹å ´åˆã€ *src* ã¨ *dst* ã® 2 "
"ã¤ã®å¼•æ•°ã‚’æŒã¤å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€:func:`os.rename` ã‚’ä½¿ç”¨ã§ããªã„å ´åˆã« *src*"
" ã‚’ *dest* ã«ã‚³ãƒ”ãƒ¼ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã‚½ãƒ¼ã‚¹ãŒãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å ´åˆã€ :func:`copytree` ãŒå‘¼ã³å‡ºã•ã‚Œã€ãã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ "
":func:`copy_function` ã«æ¸¡ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®  *copy_function* ã¯ :func:`copy2` "
"ã§ã™ã€‚:func:`~shutil.copy` ã‚’ *copy_function* "
"ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ã¨ã€ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ã¨ã‚‚ã«ã‚³ãƒ”ãƒ¼ã™ã‚‹ã“ã¨ãŒã§ããªã„å ´åˆã«ç§»å‹•ã‚’æˆåŠŸã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®å ´åˆã€ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¯ã¾ã£ãŸãã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/shutil.rst:309
msgid ""
"Added explicit symlink handling for foreign filesystems, thus adapting it to"
" the behavior of GNU's :program:`mv`. Now returns *dst*."
msgstr ""
"ç•°ãªã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã«å¯¾ã™ã‚‹æ˜ç¤ºçš„ãªã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯å‡¦ç†ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ã“ã‚Œã«ã‚ˆã‚Š GNU :program:`mv` "
"ã®æŒ¯ã‚‹èˆã„ã«é©å¿œã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ *dst* ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/shutil.rst:314
msgid "Added the *copy_function* keyword argument."
msgstr "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•° *copy_function* ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/shutil.rst:319
msgid ""
"Return disk usage statistics about the given path as a :term:`named tuple` "
"with the attributes *total*, *used* and *free*, which are the amount of "
"total, used and free space, in bytes.  On Windows, *path* must be a "
"directory; on Unix, it can be a file or directory."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¹ã«ã¤ã„ã¦ã€ãƒ‡ã‚£ã‚¹ã‚¯ã®åˆ©ç”¨çŠ¶æ³ã‚’ã€åå‰ä»˜ãã‚¿ãƒ—ãƒ« (:term:`named tuple`) ã§è¿”ã—ã¾ã™ã€‚ã“ã®ã‚¿ãƒ—ãƒ«ã«ã¯ *total*, "
"*used*, *free* ã¨ã„ã†å±æ€§ãŒã‚ã‚Šã€ãã‚Œãã‚Œãƒˆãƒ¼ã‚¿ãƒ«ã€ä½¿ç”¨ä¸­ã€ç©ºãã®å®¹é‡ã‚’ãƒã‚¤ãƒˆå˜ä½ã§ç¤ºã—ã¾ã™ã€‚Windowsã§ã¯ã€ *path* "
"ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ãªãã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚ Unixã§ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã€ã¾ãŸã¯ã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/shutil.rst:326
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ""

#: ../../library/shutil.rst:330
msgid "Change owner *user* and/or *group* of the given *path*."
msgstr "æŒ‡å®šã•ã‚ŒãŸ *path* ã®ã‚ªãƒ¼ãƒŠãƒ¼ *user* ã¨/ã¾ãŸã¯ *group* ã‚’å¤‰æ›´ã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:332
msgid ""
"*user* can be a system user name or a uid; the same applies to *group*. At "
"least one argument is required."
msgstr "*user* ã¯ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‹ uid ã§ã™ã€‚ *group* ã‚‚åŒã˜ã§ã™ã€‚å°‘ãªãã¨ã‚‚ã©ã¡ã‚‰ã‹ã®å¼•æ•°ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/shutil.rst:335
msgid "See also :func:`os.chown`, the underlying function."
msgstr "å†…éƒ¨ã§åˆ©ç”¨ã—ã¦ã„ã‚‹ :func:`os.chown` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/shutil.rst:338
msgid ":ref:`Availability <availability>`: Unix."
msgstr ""

#: ../../library/shutil.rst:344
msgid ""
"Return the path to an executable which would be run if the given *cmd* was "
"called.  If no *cmd* would be called, return ``None``."
msgstr ""
"*cmd* ã‚’å®Ÿè¡Œã—ã‚ˆã†ã¨ã—ãŸæ™‚ã«å®Ÿè¡Œã•ã‚Œã‚‹å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ *cmd* ã‚’å‘¼ã³å‡ºã›ãªã„å ´åˆã¯ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:347
msgid ""
"*mode* is a permission mask passed to :func:`os.access`, by default "
"determining if the file exists and executable."
msgstr ""
"*mode* ã¯ :func:`os.access` ã«æ¸¡ã™ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³ãƒã‚¹ã‚¯ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¦å®Ÿè¡Œå¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:350
msgid ""
"When no *path* is specified, the results of :func:`os.environ` are used, "
"returning either the \"PATH\" value or a fallback of :attr:`os.defpath`."
msgstr ""
"*path* ãŒæŒ‡å®šã•ã‚Œãªã‹ã£ãŸå ´åˆã€ :func:`os.environ` ãŒåˆ©ç”¨ã•ã‚Œã€ \"PATH\" ã®å€¤ã‚’è¿”ã™ã‹ "
":attr:`os.defpath` ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:353
msgid ""
"On Windows, the current directory is always prepended to the *path* whether "
"or not you use the default or provide your own, which is the behavior the "
"command shell uses when finding executables.  Additionally, when finding the"
" *cmd* in the *path*, the ``PATHEXT`` environment variable is checked.  For "
"example, if you call ``shutil.which(\"python\")``, :func:`which` will search"
" ``PATHEXT`` to know that it should look for ``python.exe`` within the "
"*path* directories.  For example, on Windows::"
msgstr ""
"Windows ã§ã¯ã€ *path* "
"ã‚’æŒ‡å®šã—ãŸå ´åˆã‚‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ã£ãŸå ´åˆã‚‚ã€ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒæœ€åˆã«æ¢ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã‚³ãƒãƒ³ãƒ‰ã‚·ã‚§ãƒ«ãŒå®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ã™ã¨ãã®å‹•ä½œã§ã™ã€‚ã¾ãŸã€ "
"*cmd* ã‚’ *path* ã‹ã‚‰æ¤œç´¢ã™ã‚‹ã¨ãã«ã€ ``PATHEXT`` ç’°å¢ƒå¤‰æ•°ã‚‚åˆ©ç”¨ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ "
"``shutil.which(\"python\")`` ã‚’å®Ÿè¡Œã—ãŸå ´åˆã€ :func:`which` ã¯ ``PATHEXT`` ã‚’å‚ç…§ã—ã¦ "
"*path* ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ ``python.exe`` ã‚’æ¢ã™ã¹ãã ã¨ã„ã†ã“ã¨ã‚’æŠŠæ¡ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ Windows ã§ã¯::"

#: ../../library/shutil.rst:369
msgid ""
"This exception collects exceptions that are raised during a multi-file "
"operation. For :func:`copytree`, the exception argument is a list of "
"3-tuples (*srcname*, *dstname*, *exception*)."
msgstr ""
"ã“ã®ä¾‹å¤–ã¯è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®æ“ä½œã‚’è¡Œã£ã¦ã„ã‚‹ã¨ãã«ç”Ÿã˜ã‚‹ä¾‹å¤–ã‚’ã¾ã¨ã‚ãŸã‚‚ã®ã§ã™ã€‚ :func:`copytree` "
"ã«å¯¾ã—ã¦ã¯ä¾‹å¤–ã®å¼•æ•°ã¯3ã¤ã®ã‚¿ãƒ—ãƒ«(*srcname*, *dstname*, *exception*)ã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã§ã™ã€‚"

#: ../../library/shutil.rst:377
msgid "copytree example"
msgstr "copytree ã®ä¾‹"

#: ../../library/shutil.rst:379
msgid ""
"This example is the implementation of the :func:`copytree` function, "
"described above, with the docstring omitted.  It demonstrates many of the "
"other functions provided by this module. ::"
msgstr ""
"ä»¥ä¸‹ã¯å‰è¿°ã® :func:`copytree` é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ–‡å­—åˆ—ã‚’çœç•¥ã—ãŸå®Ÿè£…ä¾‹ã§ã™ã€‚æœ¬ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§æä¾›ã•ã‚Œã‚‹ä»–ã®é–¢æ•°ã®ä½¿ã„æ–¹ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ "
"::"

#: ../../library/shutil.rst:414
msgid "Another example that uses the :func:`ignore_patterns` helper::"
msgstr ":func:`ignore_patterns` ãƒ˜ãƒ«ãƒ‘é–¢æ•°ã‚’åˆ©ç”¨ã™ã‚‹ã€ã‚‚ã†1ã¤ã®ä¾‹ã§ã™ã€‚ ::"

#: ../../library/shutil.rst:420
msgid ""
"This will copy everything except ``.pyc`` files and files or directories "
"whose name starts with ``tmp``."
msgstr "ã“ã®ä¾‹ã§ã¯ã€ ``.pyc`` ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã€ ``tmp`` ã§å§‹ã¾ã‚‹å…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’é™¤ã„ã¦ã€å…¨ã¦ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:423
msgid ""
"Another example that uses the *ignore* argument to add a logging call::"
msgstr "*ignore* å¼•æ•°ã«ãƒ­ã‚®ãƒ³ã‚°ã•ã›ã‚‹åˆ¥ã®ä¾‹ã§ã™ã€‚ ::"

#: ../../library/shutil.rst:438
msgid "rmtree example"
msgstr "rmtree ã®ä¾‹"

#: ../../library/shutil.rst:440
msgid ""
"This example shows how to remove a directory tree on Windows where some of "
"the files have their read-only bit set. It uses the onerror callback to "
"clear the readonly bit and reattempt the remove. Any subsequent failure will"
" propagate. ::"
msgstr ""
"æ¬¡ã®ä¾‹ã¯ã€Windows ã§ä¸€éƒ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿å–ã‚Šå°‚ç”¨ã®ãƒ“ãƒƒãƒˆã‚»ãƒƒãƒˆã‚’å«ã‚€å ´åˆã«ã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ„ãƒªãƒ¼ã‚’å‰Šé™¤ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚onerror "
"ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¦ã€èª­ã¿å–ã‚Šå°‚ç”¨ã®ãƒ“ãƒƒãƒˆã‚’æ¶ˆå»ã—ã€å‰Šé™¤ã‚’å†è©¦è¡Œã—ã¾ã™ã€‚çµæœã¨ã—ã¦å¤±æ•—ãŒç™ºç”Ÿã—ãŸå ´åˆã€ãã‚Œã‚‰ã¯ä¼æ¬ã•ã‚Œã¾ã™::"

#: ../../library/shutil.rst:458
msgid "Archiving operations"
msgstr "ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åŒ–æ“ä½œ"

#: ../../library/shutil.rst:462
msgid "Added support for the *xztar* format."
msgstr "*xztar* å½¢å¼ã®ã‚µãƒãƒ¼ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/shutil.rst:466
msgid ""
"High-level utilities to create and read compressed and archived files are "
"also provided.  They rely on the :mod:`zipfile` and :mod:`tarfile` modules."
msgstr ""
"åœ§ç¸®ã¨ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åŒ–ã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿æ›¸ãã®é«˜æ°´æº–ãªãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚‚æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã¯ :mod:`zipfile` ã€ "
":mod:`tarfile` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ä¾æ‹ ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/shutil.rst:471
msgid "Create an archive file (such as zip or tar) and return its name."
msgstr "ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ•ã‚¡ã‚¤ãƒ« (zip ã‚„ tar) ã‚’ä½œæˆã—ã¦ãã®åå‰ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:473
msgid ""
"*base_name* is the name of the file to create, including the path, minus any"
" format-specific extension. *format* is the archive format: one of \"zip\" "
"(if the :mod:`zlib` module is available), \"tar\", \"gztar\" (if the "
":mod:`zlib` module is available), \"bztar\" (if the :mod:`bz2` module is "
"available), or \"xztar\" (if the :mod:`lzma` module is available)."
msgstr ""
"*base_name* ã¯ã€ä½œæˆã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ã€ãƒ‘ã‚¹ã‚’å«ã¿ã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã”ã¨ã®æ‹¡å¼µå­ã‚’æŠœã„ãŸåå‰ã§ã™ã€‚ *format* ã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ "
"\"zip\" (:mod:`zlib` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ), \"tar\", \"gztar\" (:mod:`zlib` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ), \"bztar\" (:mod:`bz2` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ), \"xztar\" (:mod:`lzma`"
" ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ) ã®ã„ãšã‚Œã‹ã§ã™ã€‚"

#: ../../library/shutil.rst:479
msgid ""
"*root_dir* is a directory that will be the root directory of the archive; "
"for example, we typically chdir into *root_dir* before creating the archive."
msgstr ""
"*root_dir* ã¯ã€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã®ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ãªã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã™ã€‚ä¾‹ãˆã°ã€ä¸€èˆ¬çš„ã«ã¯ã€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’ä½œæˆã™ã‚‹å‰ã« *root_dir* "
"ã‚’ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:483
msgid ""
"*base_dir* is the directory where we start archiving from; i.e. *base_dir* "
"will be the common prefix of all files and directories in the archive."
msgstr ""
"*base_dir* ã¯ã€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’é–‹å§‹ã™ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã™ã€‚ã™ãªã‚ã¡ã€ *base_dir* "
"ã¯ã€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã®ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«å…±é€šã™ã‚‹æ¥é ­è¾ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/shutil.rst:487
msgid "*root_dir* and *base_dir* both default to the current directory."
msgstr "*root_dir* ã¨ *base_dir* ã®ã©ã¡ã‚‰ã‚‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã™ã€‚"

#: ../../library/shutil.rst:489
msgid ""
"If *dry_run* is true, no archive is created, but the operations that would "
"be executed are logged to *logger*."
msgstr "*dry_run* ãŒçœŸã®å ´åˆã€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¯ä½œæˆã•ã‚Œã¾ã›ã‚“ãŒå®Ÿè¡Œã•ã‚Œã‚‹æ“ä½œã¯ *logger* ã«è¨˜éŒ²ã•ã‚Œã¾ã™ã€‚"

#: ../../library/shutil.rst:492
msgid ""
"*owner* and *group* are used when creating a tar archive. By default, uses "
"the current owner and group."
msgstr ""
"*owner* ã¨ *group* ã¯ã€tar ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’ä½œæˆã™ã‚‹ã¨ãã«ä½¿ã‚ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã‚«ãƒ¬ãƒ³ãƒˆã®ã‚ªãƒ¼ãƒŠãƒ¼ã¨ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/shutil.rst:495
msgid ""
"*logger* must be an object compatible with :pep:`282`, usually an instance "
"of :class:`logging.Logger`."
msgstr ""
"*logger* ã¯ :pep:`282` ã«äº’æ›ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯æ™®é€šã¯ :class:`logging.Logger` "
"ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã™ã€‚"

#: ../../library/shutil.rst:498
msgid "The *verbose* argument is unused and deprecated."
msgstr "*verbose* å¼•æ•°ã¯ä½¿ç”¨ã•ã‚Œãšã€éæ¨å¥¨ã§ã™ã€‚"

#: ../../library/shutil.rst:503
msgid ""
"Return a list of supported formats for archiving. Each element of the "
"returned sequence is a tuple ``(name, description)``."
msgstr ""
"ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åŒ–ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚è¿”ã•ã‚Œã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ãã‚Œãã‚Œã®è¦ç´ ã¯ã€ã‚¿ãƒ—ãƒ« ``(name, "
"description)`` ã§ã™ã€‚"

#: ../../library/shutil.rst:506 ../../library/shutil.rst:586
msgid "By default :mod:`shutil` provides these formats:"
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ :mod:`shutil` ã¯æ¬¡ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/shutil.rst:508
msgid "*zip*: ZIP file (if the :mod:`zlib` module is available)."
msgstr "*zip*: ZIP ãƒ•ã‚¡ã‚¤ãƒ« (:mod:`zlib` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ)ã€‚"

#: ../../library/shutil.rst:509 ../../library/shutil.rst:590
msgid "*tar*: uncompressed tar file."
msgstr "*tar*: åœ§ç¸®ã•ã‚Œã¦ã„ãªã„ tar ãƒ•ã‚¡ã‚¤ãƒ«ã€‚"

#: ../../library/shutil.rst:510 ../../library/shutil.rst:591
msgid "*gztar*: gzip'ed tar-file (if the :mod:`zlib` module is available)."
msgstr "*gztar*: gzip ã§åœ§ç¸®ã•ã‚ŒãŸ tar ãƒ•ã‚¡ã‚¤ãƒ« (:mod:`zlib` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ)ã€‚"

#: ../../library/shutil.rst:511 ../../library/shutil.rst:592
msgid "*bztar*: bzip2'ed tar-file (if the :mod:`bz2` module is available)."
msgstr "*bztar*: bzip2 ã§åœ§ç¸®ã•ã‚ŒãŸ tar ãƒ•ã‚¡ã‚¤ãƒ« (:mod:`bz2` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ)ã€‚"

#: ../../library/shutil.rst:512 ../../library/shutil.rst:593
msgid "*xztar*: xz'ed tar-file (if the :mod:`lzma` module is available)."
msgstr "*xztar*: xz ã§åœ§ç¸®ã•ã‚ŒãŸ tar ãƒ•ã‚¡ã‚¤ãƒ« (:mod:`lzma` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ)ã€‚"

#: ../../library/shutil.rst:514
msgid ""
"You can register new formats or provide your own archiver for any existing "
"formats, by using :func:`register_archive_format`."
msgstr ""
":func:`register_archive_format` "
"ã‚’ä½¿ã£ã¦ã€æ–°ã—ã„ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ç™»éŒ²ã—ãŸã‚Šã€æ—¢å­˜ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ç‹¬è‡ªã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒã‚’æä¾›ã—ãŸã‚Šã§ãã¾ã™ã€‚"

#: ../../library/shutil.rst:520
msgid "Register an archiver for the format *name*."
msgstr "ã‚¢ãƒ¼ã‚«ã‚¤ãƒã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ *name* ã«ç™»éŒ²ã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:522
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the *base_name* of the file to create, followed by the"
" *base_dir* (which defaults to :data:`os.curdir`) to start archiving from. "
"Further arguments are passed as keyword arguments: *owner*, *group*, "
"*dry_run* and *logger* (as passed in :func:`make_archive`)."
msgstr ""
"*function* ã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã®ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ã«ä½¿ç”¨ã•ã‚Œã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚*funciton* ã¯ä½œæˆã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã® "
"*base_name*ã€ç¶šã„ã¦ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’é–‹å§‹ã™ã‚‹å…ƒã® *base_dir* (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ :data:`os.curdir`) "
"ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ã•ã‚‰ãªã‚‹å¼•æ•°ã¯ã€æ¬¡ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã¾ã™: *owner*, *group*, *dry_run* ãªã‚‰ã³ã« *logger*"
" (:func:`make_archive` ã«æ¸¡ã•ã‚Œã¾ã™)ã€‚"

#: ../../library/shutil.rst:528
msgid ""
"If given, *extra_args* is a sequence of ``(name, value)`` pairs that will be"
" used as extra keywords arguments when the archiver callable is used."
msgstr ""
"*extra_args* ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ ``(name, value)`` "
"ã®å¯¾ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã€ã‚¢ãƒ¼ã‚«ã‚¤ãƒå‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½¿ã‚ã‚Œã‚‹ã¨ãã«è¿½åŠ ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/shutil.rst:531
msgid ""
"*description* is used by :func:`get_archive_formats` which returns the list "
"of archivers.  Defaults to an empty string."
msgstr ""
"*description* ã¯ã€ã‚¢ãƒ¼ã‚«ã‚¤ãƒã®ãƒªã‚¹ãƒˆã‚’è¿”ã™ :func:`get_archive_formats` "
"ã§ä½¿ã‚ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ç©ºã®æ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/shutil.rst:537
msgid "Remove the archive format *name* from the list of supported formats."
msgstr "ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ *name* ã‚’ã€ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ãƒªã‚¹ãƒˆã‹ã‚‰å–ã‚Šé™¤ãã¾ã™ã€‚"

#: ../../library/shutil.rst:542
msgid "Unpack an archive. *filename* is the full path of the archive."
msgstr "ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ã—ã¾ã™ã€‚ *filename* ã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã®ãƒ•ãƒ«ãƒ‘ã‚¹ã§ã™ã€‚"

#: ../../library/shutil.rst:544
msgid ""
"*extract_dir* is the name of the target directory where the archive is "
"unpacked. If not provided, the current working directory is used."
msgstr "*extract_dir* ã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ã™ã‚‹å…ˆã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã§ã™ã€‚æŒ‡å®šã•ã‚Œãªã‹ã£ãŸå ´åˆã¯ç¾åœ¨ã®ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’åˆ©ç”¨ã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:547
msgid ""
"*format* is the archive format: one of \"zip\", \"tar\", \"gztar\", "
"\"bztar\", or \"xztar\".  Or any other format registered with "
":func:`register_unpack_format`.  If not provided, :func:`unpack_archive` "
"will use the archive file name extension and see if an unpacker was "
"registered for that extension.  In case none is found, a :exc:`ValueError` "
"is raised."
msgstr ""
"*format* ã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã€ \"zip\", \"tar\", \"gztar\", \"bztar\", \"xztar\" ã‚ã‚‹ã„ã¯ :func:`register_unpack_format` ã§ç™»éŒ²ã—ãŸãã®ä»–ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ã©ã‚Œã‹ã§ã™ã€‚\n"
"æŒ‡å®šã•ã‚Œãªã‹ã£ãŸå ´åˆã€ :func:`unpack_archive` ã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ•ã‚¡ã‚¤ãƒ«åã®æ‹¡å¼µå­ã«å¯¾ã—ã¦ç™»éŒ²ã•ã‚ŒãŸã‚¢ãƒ³ãƒ‘ãƒƒã‚«ãƒ¼ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚\n"
"ã‚¢ãƒ³ãƒ‘ãƒƒã‚«ãƒ¼ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã€ :exc:`ValueError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/shutil.rst:554
msgid "Accepts a :term:`path-like object` for *filename* and *extract_dir*."
msgstr ""

#: ../../library/shutil.rst:560
msgid ""
"Registers an unpack format. *name* is the name of the format and "
"*extensions* is a list of extensions corresponding to the format, like "
"``.zip`` for Zip files."
msgstr ""
"ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ç”¨ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ç™»éŒ²ã—ã¾ã™ã€‚ *name* ã¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆåã§ã€ *extensions* ã¯ãã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å¯¾å¿œã™ã‚‹æ‹¡å¼µå­ (ä¾‹ãˆã° "
"Zip ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦ ``.zip``) ã®ãƒªã‚¹ãƒˆã§ã™ã€‚"

#: ../../library/shutil.rst:564
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the path of the archive, followed by the directory the"
" archive must be extracted to."
msgstr ""
"*function* "
"ã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ã™ã‚‹ãŸã‚ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã®ãƒ‘ã‚¹ã¨ã€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’å±•é–‹ã™ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹ã‚’å¼•æ•°ã«å—ã‘å–ã‚Šã¾ã™ã€‚"

#: ../../library/shutil.rst:568
msgid ""
"When provided, *extra_args* is a sequence of ``(name, value)`` tuples that "
"will be passed as keywords arguments to the callable."
msgstr ""
"*extra_args* ã¯çœç•¥å¯èƒ½ãªå¼•æ•°ã§ã€å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æ¸¡ã™ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ ``(name, value)`` "
"ã¨ã„ã†ã‚¿ãƒ—ãƒ«ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ã—ãŸã‚‚ã®ã§ã™ã€‚"

#: ../../library/shutil.rst:571
msgid ""
"*description* can be provided to describe the format, and will be returned "
"by the :func:`get_unpack_formats` function."
msgstr ""
"ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®èª¬æ˜ã¨ã—ã¦ *description* ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ :func:`get_unpack_formats` "
"é–¢æ•°ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/shutil.rst:577
msgid "Unregister an unpack format. *name* is the name of the format."
msgstr "ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ç™»éŒ²è§£é™¤ã—ã¾ã™ã€‚ *name* ã¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®åå‰ã§ã™ã€‚"

#: ../../library/shutil.rst:582
msgid ""
"Return a list of all registered formats for unpacking. Each element of the "
"returned sequence is a tuple ``(name, extensions, description)``."
msgstr ""
"ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ãƒªã‚¹ãƒˆã§è¿”ã—ã¾ã™ã€‚æˆ»ã‚Šå€¤ã®ãƒªã‚¹ãƒˆã®å„è¦ç´ ã¯ ``(name, extensions, "
"description)`` ã®å½¢ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚"

#: ../../library/shutil.rst:588
msgid ""
"*zip*: ZIP file (unpacking compressed files works only if the corresponding "
"module is available)."
msgstr "*zip*: ZIP ãƒ•ã‚¡ã‚¤ãƒ« (å¯¾å¿œã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã«ã®ã¿åœ§ç¸®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚¢ãƒ³ãƒ‘ãƒƒã‚¯ã•ã‚Œã¾ã™)ã€‚"

#: ../../library/shutil.rst:595
msgid ""
"You can register new formats or provide your own unpacker for any existing "
"formats, by using :func:`register_unpack_format`."
msgstr ""
":func:`register_unpack_format` "
"ã‚’ä½¿ã£ã¦æ–°ã—ã„ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚„æ—¢å­˜ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å¯¾ã™ã‚‹åˆ¥ã®ã‚¢ãƒ³ãƒ‘ãƒƒã‚«ãƒ¼ã‚’ç™»éŒ²ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/shutil.rst:602
msgid "Archiving example"
msgstr "ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åŒ–ã®ä¾‹"

#: ../../library/shutil.rst:604
msgid ""
"In this example, we create a gzip'ed tar-file archive containing all files "
"found in the :file:`.ssh` directory of the user::"
msgstr ""
"ã“ã®ä¾‹ã§ã¯ã€ãƒ¦ãƒ¼ã‚¶ã® :file:`.ssh` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã‚ã‚‹ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å«ã‚€ã€ gzip ã•ã‚ŒãŸ tar ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’ä½œæˆã—ã¾ã™::"

#: ../../library/shutil.rst:614
msgid "The resulting archive contains:"
msgstr "çµæœã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¯ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’å«ã¿ã¾ã™:"

#: ../../library/shutil.rst:630
msgid "Querying the size of the output terminal"
msgstr "å‡ºåŠ›ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã®ã‚µã‚¤ã‚ºã®å–å¾—"

#: ../../library/shutil.rst:634
msgid "Get the size of the terminal window."
msgstr "ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚µã‚¤ã‚ºã‚’å–å¾—ã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:636
msgid ""
"For each of the two dimensions, the environment variable, ``COLUMNS`` and "
"``LINES`` respectively, is checked. If the variable is defined and the value"
" is a positive integer, it is used."
msgstr ""
"å¹…ã¨é«˜ã•ã«ã¤ã„ã¦ã€ãã‚Œãã‚Œ ``COLUMNS`` ã¨ ``LINES`` "
"ã¨ã„ã†ç’°å¢ƒå¤‰æ•°ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚ãã®å¤‰æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã¦å€¤ãŒæ­£ã®æ•´æ•°ã§ã‚ã‚Œã°ãã‚Œã‚’åˆ©ç”¨ã—ã¾ã™ã€‚"

#: ../../library/shutil.rst:640
msgid ""
"When ``COLUMNS`` or ``LINES`` is not defined, which is the common case, the "
"terminal connected to :data:`sys.__stdout__` is queried by invoking "
":func:`os.get_terminal_size`."
msgstr ""
"å…¸å‹çš„ãª ``COLUMNS`` ã‚„ ``LINES`` ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã«ã¯ã€ :data:`sys.__stdout__` "
"ã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã« :func:`os.get_terminal_size` ã‚’å‘¼ã³å‡ºã—ã¦å•ã„åˆã‚ã›ã¾ã™ã€‚"

#: ../../library/shutil.rst:644
msgid ""
"If the terminal size cannot be successfully queried, either because the "
"system doesn't support querying, or because we are not connected to a "
"terminal, the value given in ``fallback`` parameter is used. ``fallback`` "
"defaults to ``(80, 24)`` which is the default size used by many terminal "
"emulators."
msgstr ""
"ã‚·ã‚¹ãƒ†ãƒ ãŒå¯¾å¿œã—ã¦ã„ãªã„å ´åˆã‚„ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã«æ¥ç¶šã—ã¦ã„ãªã„ãªã©ã®ç†ç”±ã§ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚µã‚¤ã‚ºã®å•ã„åˆã‚ã›ã«å¤±æ•—ã—ãŸå ´åˆã€ ``fallback`` "
"å¼•æ•°ã«ä¸ãˆã‚‰ã‚ŒãŸå€¤ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚ ``fallback`` ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ ``(80, 24)`` "
"ã§ã€ã“ã‚Œã¯å¤šãã®ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒåˆ©ç”¨ã—ã¦ã„ã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚µã‚¤ã‚ºã§ã™ã€‚"

#: ../../library/shutil.rst:650
msgid "The value returned is a named tuple of type :class:`os.terminal_size`."
msgstr "æˆ»ã‚Šå€¤ã¯ :class:`os.terminal_size` å‹ã®åå‰ä»˜ãã‚¿ãƒ—ãƒ«ã§ã™ã€‚"

#: ../../library/shutil.rst:652
msgid ""
"See also: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."
msgstr ""
"å‚è€ƒ: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."
