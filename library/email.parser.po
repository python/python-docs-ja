# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: E. Kawashima\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.parser.rst:2
msgid ":mod:`email.parser`: Parsing email messages"
msgstr ":mod:`email.parser`: 電子メールメッセージを解析(パース)する"

#: ../../library/email.parser.rst:8
msgid ""
"Message object structures can be created in one of two ways: they can be "
"created from whole cloth by instantiating :class:`~email.message.Message` "
"objects and stringing them together via :meth:`~email.message.Message."
"attach` and :meth:`~email.message.Message.set_payload` calls, or they can be "
"created by parsing a flat text representation of the email message."
msgstr ""
"メッセージオブジェクト構造体をつくるには 2つの方法があります。ひとつはまった"
"くのスクラッチから :class:`~email.message.Message` を生成して、これを :meth:"
"`~email.message.Message.attach` と :meth:`~email.message.Message."
"set_payload` 呼び出しを介してつなげていく方法で、もうひとつは電子メールメッ"
"セージのフラットなテキスト表現を解析 (parse、パーズ) する方法です。"

#: ../../library/email.parser.rst:14
msgid ""
"The :mod:`email` package provides a standard parser that understands most "
"email document structures, including MIME documents.  You can pass the "
"parser a string or a file object, and the parser will return to you the "
"root :class:`~email.message.Message` instance of the object structure.  For "
"simple, non-MIME messages the payload of this root object will likely be a "
"string containing the text of the message.  For MIME messages, the root "
"object will return ``True`` from its :meth:`~email.message.Message."
"is_multipart` method, and the subparts can be accessed via the :meth:`~email."
"message.Message.get_payload` and :meth:`~email.message.Message.walk` methods."
msgstr ""
":mod:`email` パッケージでは、MIME 文書をふくむ、ほとんどの電子メールの文書構"
"造に対応できる標準的なパーザ (解析器) を提供しています。このパーザに文字列あ"
"るいはファイルオブジェクトを渡せば、パーザはそのオブジェクト構造の基底となる "
"(root の) :class:`~email.message.Message` インスタンスを返します。簡単な非"
"MIMEメッセージであれば、この基底オブジェクトのペイロードはたんにメッセージの"
"テキストを格納する文字列になるでしょう。 MIMEメッセージであれば、基底オブジェ"
"クトはその :meth:`~email.message.Message.is_multipart` メソッドに対して "
"``True`` を返します。そして、その各 subpart に :meth:`~email.message.Message."
"get_payload` メソッドおよび :meth:`~email.message.Message.walk` メソッドを介"
"してアクセスすることができます。"

#: ../../library/email.parser.rst:24
msgid ""
"There are actually two parser interfaces available for use, the classic :"
"class:`Parser` API and the incremental :class:`FeedParser` API.  The "
"classic :class:`Parser` API is fine if you have the entire text of the "
"message in memory as a string, or if the entire message lives in a file on "
"the file system. :class:`FeedParser` is more appropriate for when you're "
"reading the message from a stream which might block waiting for more input "
"(e.g. reading an email message from a socket).  The :class:`FeedParser` can "
"consume and parse the message incrementally, and only returns the root "
"object when you close the parser [#]_."
msgstr ""
"実際には 2つのパーザインターフェイスが使用可能です。ひとつは旧式の :class:"
"`Parser` API であり、もうひとつはインクリメンタルな :class:`FeedParser` API "
"です。旧式の :class:`Parser` API はメッセージ全体のテキストが文字列としてすで"
"にメモリ上にあるか、それがローカルなファイルシステム上に存在しているときには"
"問題ありません。 :class:`FeedParser` はメッセージを読み込むときに、そのスト"
"リームが入力待ちのためにブロックされるような場合 (ソケットから email メッセー"
"ジを読み込む時など) に、より有効です。 :class:`FeedParser` はインクリメンタル"
"にメッセージを読み込み、解析します。パーザを close したときには根っこ (root) "
"のオブジェクトのみが返されます [#]_ 。"

#: ../../library/email.parser.rst:33
msgid ""
"Note that the parser can be extended in limited ways, and of course you can "
"implement your own parser completely from scratch.  There is no magical "
"connection between the :mod:`email` package's bundled parser and the :class:"
"`~email.message.Message` class, so your custom parser can create message "
"object trees any way it finds necessary."
msgstr ""
"このパーザは、ある制限された方法で拡張できます。また、もちろん自分でご自分の"
"パーザを完全に無から実装することもできます。 :mod:`email` パッケージについて"
"いるパーザと :class:`~email.message.Message` クラスの間に隠された秘密の関係は"
"なにもありませんので、ご自分で実装されたパーザも、それが必要とするやりかたで"
"メッセージオブジェクトツリーを作成することができます。"

#: ../../library/email.parser.rst:41
msgid "FeedParser API"
msgstr "FeedParser API"

#: ../../library/email.parser.rst:45
msgid ""
"The :class:`FeedParser`, imported from the :mod:`email.feedparser` module, "
"provides an API that is conducive to incremental parsing of email messages, "
"such as would be necessary when reading the text of an email message from a "
"source that can block (e.g. a socket).  The :class:`FeedParser` can of "
"course be used to parse an email message fully contained in a string or a "
"file, but the classic :class:`Parser` API may be more convenient for such "
"use cases.  The semantics and results of the two parser APIs are identical."
msgstr ""
":mod:`email.feedparser` モジュールからインポートされる :class:`FeedParser` "
"は email メッセージをインクリメンタルに解析するのに向いた API を提供します。"
"これは email メッセージのテキストを (ソケットなどの) 読み込みがブロックされる"
"可能性のある情報源から入力するときに必要となります。もちろん :class:"
"`FeedParser` は文字列またはファイルにすべて格納されている email メッセージを"
"解析するのにも使うことができますが、このような場合には旧式の :class:`Parser` "
"API のほうが便利かもしれません。これら 2つのパーザ API の意味論と得られる結果"
"は同一です。"

#: ../../library/email.parser.rst:53
msgid ""
"The :class:`FeedParser`'s API is simple; you create an instance, feed it a "
"bunch of text until there's no more to feed it, then close the parser to "
"retrieve the root message object.  The :class:`FeedParser` is extremely "
"accurate when parsing standards-compliant messages, and it does a very good "
"job of parsing non-compliant messages, providing information about how a "
"message was deemed broken.  It will populate a message object's *defects* "
"attribute with a list of any problems it found in a message.  See the :mod:"
"`email.errors` module for the list of defects that it can find."
msgstr ""
":class:`FeedParser` API は簡単です。まずインスタンスをつくり、それにテキスト"
"を (それ以上テキストが必要なくなるまで) 流しこみます。その後パーザを close す"
"ると根っこ (root) のメッセージオブジェクトが返されます。標準に従ったメッセー"
"ジを解析する場合、 :class:`FeedParser` は非常に正確であり、標準に従っていない"
"メッセージでもちゃんと動きます。そのさい、これはメッセージがどのように壊れて"
"いると認識されたかについての情報を残します。これはメッセージオブジェクトの "
"*defects* 属性にリストとして現れ、メッセージ中に発見された問題が記録されま"
"す。パーザが検出できる障害 (defect) については :mod:`email.errors` モジュール"
"を参照してください。"

#: ../../library/email.parser.rst:62
msgid "Here is the API for the :class:`FeedParser`:"
msgstr "以下は :class:`FeedParser` の API です:"

#: ../../library/email.parser.rst:67
msgid ""
"Create a :class:`FeedParser` instance.  Optional *_factory* is a no-argument "
"callable that will be called whenever a new message object is needed.  It "
"defaults to the :class:`email.message.Message` class."
msgstr ""
":class:`FeedParser` インスタンスを作成します。オプション引数 *_factory* には"
"引数なしの callable を指定し、これはつねに新しいメッセージオブジェクトの作成"
"が必要になったときに呼び出されます。デフォルトでは、これは :class:`email."
"message.Message` クラスになっています。"

#: ../../library/email.parser.rst:74
msgid ""
"Feed the :class:`FeedParser` some more data.  *data* should be a string "
"containing one or more lines.  The lines can be partial and the :class:"
"`FeedParser` will stitch such partial lines together properly.  The lines in "
"the string can have any of the common three line endings, carriage return, "
"newline, or carriage return and newline (they can even be mixed)."
msgstr ""
":class:`FeedParser` にデータを供給します。 *data* は 1行または複数行からなる"
"文字列を渡します。渡される行は完結していなくてもよく、その場合 :class:"
"`FeedParser` は部分的な行を適切につなぎ合わせます。文字列中の各行は標準的な 3"
"種類の行末文字 (復帰 CR、改行 LF、または CR+LF) どれかの組み合わせでよく、こ"
"れらが混在してもかまいません。"

#: ../../library/email.parser.rst:84
msgid ""
"Closing a :class:`FeedParser` completes the parsing of all previously fed "
"data, and returns the root message object.  It is undefined what happens if "
"you feed more data to a closed :class:`FeedParser`."
msgstr ""
":class:`FeedParser` を close し、それまでに渡されたすべてのデータの解析を完了"
"させ根っこ (root) のメッセージオブジェクトを返します。 :class:`FeedParser` "
"を close したあとにさらにデータを feed した場合の挙動は未定義です。"

#: ../../library/email.parser.rst:90
msgid "Parser class API"
msgstr "Parser クラス API"

#: ../../library/email.parser.rst:92
msgid ""
"The :class:`Parser` class, imported from the :mod:`email.parser` module, "
"provides an API that can be used to parse a message when the complete "
"contents of the message are available in a string or file.  The :mod:`email."
"parser` module also provides a second class, called :class:`HeaderParser` "
"which can be used if you're only interested in the headers of the message. :"
"class:`HeaderParser` can be much faster in these situations, since it does "
"not attempt to parse the message body, instead setting the payload to the "
"raw body as a string. :class:`HeaderParser` has the same API as the :class:"
"`Parser` class."
msgstr ""
":mod:`email.parser` モジュールからインポートされる :class:`Parser` クラスは、"
"メッセージを表すテキストが文字列またはファイルの形で完全に使用可能なときメッ"
"セージを解析するのに使われる API を提供します。 :mod:`email.Parser` モジュー"
"ルはまた、 :class:`HeaderParser` と呼ばれる\\ 2番目のクラスも提供しています。"
"これはメッセージのヘッダのみを処理したい場合に使うことができ、ずっと高速な処"
"理がおこなえます。なぜならこれはメッセージ本体を解析しようとはしないからで"
"す。かわりに、そのペイロードにはメッセージ本体の生の文字列が格納されます。 :"
"class:`HeaderParser` クラスは :class:`Parser` クラスと同じ API をもっていま"
"す。"

#: ../../library/email.parser.rst:105
msgid ""
"The constructor for the :class:`Parser` class takes an optional argument "
"*_class*.  This must be a callable factory (such as a function or a class), "
"and it is used whenever a sub-message object needs to be created.  It "
"defaults to :class:`~email.message.Message` (see :mod:`email.message`).  The "
"factory will be called without arguments."
msgstr ""
":class:`Parser` クラスのコンストラクタです。オプション引数 *_class* をとるこ"
"とができます。これは呼び出し可能なオブジェクト (関数やクラス) でなければなら"
"ず、メッセージ内コンポーネント (sub-message object) が作成されるときは常にそ"
"のファクトリクラスとして使用されます。デフォルトではこれは :class:`~email."
"message.Message` になっています (:mod:`email.message` 参照)。このファクトリク"
"ラスは引数なしで呼び出されます。"

#: ../../library/email.parser.rst:111
msgid "The optional *strict* flag is ignored."
msgstr "オプション引数 *strict* は無視されます。"

#: ../../library/email.parser.rst:113
msgid ""
"Because the :class:`Parser` class is a backward compatible API wrapper "
"around the new-in-Python 2.4 :class:`FeedParser`, *all* parsing is "
"effectively non-strict.  You should simply stop passing a *strict* flag to "
"the :class:`Parser` constructor."
msgstr ""
":class:`Parser` は Python 2.4 で新しく導入された :class:`FeedParser` の後方互"
"換性のための API ラッパで、 *すべての* 解析が事実上 non-strict です。 :class:"
"`Parser` コンストラクタに *strict* フラグを渡す必要はありません。"

#: ../../library/email.parser.rst:119 ../../library/email.parser.rst:173
#: ../../library/email.parser.rst:183
msgid "The *strict* flag was added."
msgstr "*strict* フラグが追加されました."

#: ../../library/email.parser.rst:122
msgid "The *strict* flag was deprecated."
msgstr "*strict* フラグは推奨されなくなりました."

#: ../../library/email.parser.rst:125
msgid "The other public :class:`Parser` methods are:"
msgstr "それ以外の :class:`Parser` メソッドは以下のとおりです:"

#: ../../library/email.parser.rst:130
msgid ""
"Read all the data from the file-like object *fp*, parse the resulting text, "
"and return the root message object.  *fp* must support both the :meth:`~io."
"TextIOBase.readline` and the :meth:`~io.TextIOBase.read` methods on file-"
"like objects."
msgstr ""
"ファイルなどストリーム形式 (file-like) のオブジェクト *fp* からすべてのデータ"
"を読み込み、得られたテキストを解析して基底 (root) メッセージオブジェクト構造"
"を返します。 *fp* はストリーム形式のオブジェクトで :meth:`~io.TextIOBase."
"readline` および :meth:`~io.TextIOBase.read` 両方のメソッドをサポートしている"
"必要があります。"

#: ../../library/email.parser.rst:135
msgid ""
"The text contained in *fp* must be formatted as a block of :rfc:`2822` style "
"headers and header continuation lines, optionally preceded by an envelope "
"header.  The header block is terminated either by the end of the data or by "
"a blank line.  Following the header block is the body of the message (which "
"may contain MIME-encoded subparts)."
msgstr ""
"*fp* に格納されているテキスト文字列は、一連の :rfc:`2822` 形式のヘッダおよび"
"ヘッダ継続行 (header continuation lines) によって構成されている必要がありま"
"す。オプションとして、最初にエンペローブヘッダが来ることもできます。ヘッダ部"
"分はデータの終端か、ひとつの空行によって終了したとみなされます。ヘッダ部分に"
"続くデータはメッセージ本体となります (MIME エンコードされた subpart を含んで"
"いるかもしれません)。"

#: ../../library/email.parser.rst:141
msgid ""
"Optional *headersonly* is a flag specifying whether to stop parsing after "
"reading the headers or not.  The default is ``False``, meaning it parses the "
"entire contents of the file."
msgstr ""
"オプション引数 *headersonly* はヘッダを読み終えた後にパースを止めるかを指定す"
"るフラグです。デフォルトは ``False`` で、ファイルの内容全体をパースします。"

#: ../../library/email.parser.rst:145 ../../library/email.parser.rst:158
msgid "The *headersonly* flag was added."
msgstr "*headersonly* フラグが追加されました."

#: ../../library/email.parser.rst:151
msgid ""
"Similar to the :meth:`parse` method, except it takes a string object instead "
"of a file-like object.  Calling this method on a string is exactly "
"equivalent to wrapping *text* in a :class:`~StringIO.StringIO` instance "
"first and calling :meth:`parse`."
msgstr ""
":meth:`parse` メソッドに似ていますが、ファイルなどのストリーム形式のかわりに"
"文字列を引数としてとるところが違います。文字列に対してこのメソッドを呼ぶこと"
"は、 *text* を :class:`~StringIO.StringIO` インスタンスとして作成して :meth:"
"`parse` を適用するのと同じです。"

#: ../../library/email.parser.rst:156
msgid "Optional *headersonly* is as with the :meth:`parse` method."
msgstr "オプション引数 *headersonly* は :meth:`parse` メソッドと同じです。"

#: ../../library/email.parser.rst:161
msgid ""
"Since creating a message object structure from a string or a file object is "
"such a common task, two functions are provided as a convenience.  They are "
"available in the top-level :mod:`email` package namespace."
msgstr ""
"ファイルや文字列からメッセージオブジェクト構造を作成するのはかなりよくおこな"
"われる作業なので、便宜上次のような 2つの関数が提供されています。これらは :"
"mod:`email` パッケージのトップレベルの名前空間で使用できます。"

#: ../../library/email.parser.rst:169
msgid ""
"Return a message object structure from a string.  This is exactly equivalent "
"to ``Parser().parsestr(s)``.  Optional *_class* and *strict* are interpreted "
"as with the :class:`~email.parser.Parser` class constructor."
msgstr ""
"文字列からメッセージオブジェクト構造を作成し返します。これは ``Parser()."
"parsestr(s)`` とまったく同じです。オプション引数 *_class* および *strict* "
"は :class:`~email.parser.Parser` クラスのコンストラクタと同様に解釈されます。"

#: ../../library/email.parser.rst:179
msgid ""
"Return a message object structure tree from an open file object.  This is "
"exactly equivalent to ``Parser().parse(fp)``.  Optional *_class* and "
"*strict* are interpreted as with the :class:`~email.parser.Parser` class "
"constructor."
msgstr ""
"Open されたファイルオブジェクトからメッセージオブジェクト構造を作成し返しま"
"す。これは ``Parser().parse(fp)`` とまったく同じです。オプション引数 "
"*_class* および *strict* は :class:`~email.parser.Parser` クラスのコンストラ"
"クタと同様に解釈されます。"

#: ../../library/email.parser.rst:186
msgid ""
"Here's an example of how you might use this at an interactive Python prompt::"
msgstr ""
"対話的な Python プロンプトでこの関数を使用するとすれば、このようになります::"

#: ../../library/email.parser.rst:193
msgid "Additional notes"
msgstr "追記事項"

#: ../../library/email.parser.rst:195
msgid "Here are some notes on the parsing semantics:"
msgstr "以下はテキスト解析の際に適用されるいくつかの規約です:"

#: ../../library/email.parser.rst:197
msgid ""
"Most non-\\ :mimetype:`multipart` type messages are parsed as a single "
"message object with a string payload.  These objects will return ``False`` "
"for :meth:`~email.message.Message.is_multipart`.  Their :meth:`~email."
"message.Message.get_payload` method will return a string object."
msgstr ""
"ほとんどの非 :mimetype:`multipart` 形式のメッセージは単一の文字列ペイロードを"
"もつ単一のメッセージオブジェクトとして解析されます。このオブジェクトは :meth:"
"`~email.message.Message.is_multipart` に対して ``False`` を返します。このオブ"
"ジェクトに対する :meth:`~email.message.Message.get_payload` メソッドは文字列"
"オブジェクトを返します。"

#: ../../library/email.parser.rst:202
msgid ""
"All :mimetype:`multipart` type messages will be parsed as a container "
"message object with a list of sub-message objects for their payload.  The "
"outer container message will return ``True`` for :meth:`~email.message."
"Message.is_multipart` and their :meth:`~email.message.Message.get_payload` "
"method will return the list of :class:`~email.message.Message` subparts."
msgstr ""
":mimetype:`multipart` 形式のメッセージはすべてメッセージ内コンポーネント "
"(sub-message object) のリストとして解析されます。外側のコンテナメッセージオブ"
"ジェクトは :meth:`~email.message.Message.is_multipart` に対して ``True`` を返"
"し、このオブジェクトに対する :meth:`~email.message.Message.get_payload` メ"
"ソッドは :class:`~email.message.Message` subpart のリストを返します。"

#: ../../library/email.parser.rst:209
msgid ""
"Most messages with a content type of :mimetype:`message/\\*` (e.g. :mimetype:"
"`message/delivery-status` and :mimetype:`message/rfc822`) will also be "
"parsed as container object containing a list payload of length 1.  Their :"
"meth:`~email.message.Message.is_multipart` method will return ``True``. The "
"single element in the list payload will be a sub-message object."
msgstr ""
":mimetype:`message/\\*` の Content-Type をもつほとんどのメッセージ (例: :"
"mimetype:`message/delivery-status` や :mimetype:`message/rfc822` など) もコン"
"テナメッセージオブジェクトとして解析されますが、ペイロードのリストの長さは 1 "
"になります。このオブジェクトは :meth:`~email.message.Message.is_multipart` メ"
"ソッドに対して ``True`` を返し、リスト内にあるひとつだけの要素がメッセージ内"
"のコンポーネントオブジェクトになります。"

#: ../../library/email.parser.rst:215
msgid ""
"Some non-standards compliant messages may not be internally consistent about "
"their :mimetype:`multipart`\\ -edness.  Such messages may have a :mailheader:"
"`Content-Type` header of type :mimetype:`multipart`, but their :meth:`~email."
"message.Message.is_multipart` method may return ``False``. If such messages "
"were parsed with the :class:`~email.parser.FeedParser`, they will have an "
"instance of the :class:`~email.errors.MultipartInvariantViolationDefect` "
"class in their *defects* attribute list.  See :mod:`email.errors` for "
"details."
msgstr ""
"いくつかの標準的でないメッセージは、 :mimetype:`multipart` の使い方に統一がと"
"れていない場合があります。このようなメッセージは :mailheader:`Content-Type` "
"ヘッダに :mimetype:`multipart` を指定しているものの、その :meth:`~email."
"message.Message.is_multipart` メソッドは ``False`` を返すことがあります。もし"
"このようなメッセージが :class:`~email.parser.FeedParser` によって解析される"
"と、その *defects* 属性のリスト中には :class:`~email.errors."
"MultipartInvariantViolationDefect` クラスのインスタンスが現れます。詳しい情報"
"については :mod:`email.errors` を参照してください。"

#: ../../library/email.parser.rst:225
msgid "Footnotes"
msgstr "脚注"

#: ../../library/email.parser.rst:226
msgid ""
"As of email package version 3.0, introduced in Python 2.4, the classic :"
"class:`~email.parser.Parser` was re-implemented in terms of the :class:"
"`~email.parser.FeedParser`, so the semantics and results are identical "
"between the two parsers."
msgstr ""
"Python 2.4 から導入された email パッケージバージョン 3.0 では、旧式の :class:"
"`~email.parser.Parser` は :class:`~email.parser.FeedParser` によって書き直さ"
"れました。そのためパーザの意味論と得られる結果は 2 つのパーザで同一のものにな"
"ります。"
