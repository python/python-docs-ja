# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-30 14:59+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/logging.config.rst:2
msgid ":mod:`logging.config` --- Logging configuration"
msgstr ":mod:`logging.config` --- ロギングの環境設定"

#: ../../library/logging.config.rst:10
msgid "**Source code:** :source:`Lib/logging/config.py`"
msgstr "**ソースコード:** :source:`Lib/logging/config.py`"

#: ../../library/logging.config.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ""
"このページには、リファレンス情報だけが含まれています。チュートリアルは、以下"
"のページを参照してください"

#: ../../library/logging.config.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`基本チュートリアル <logging-basic-tutorial>`"

#: ../../library/logging.config.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`上級チュートリアル <logging-advanced-tutorial>`"

#: ../../library/logging.config.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`ロギングクックブック <logging-cookbook>`"

#: ../../library/logging.config.rst:23
msgid "This section describes the API for configuring the logging module."
msgstr "この節は、logging モジュールを設定するための API を解説します。"

#: ../../library/logging.config.rst:28
msgid "Configuration functions"
msgstr "環境設定のための関数"

#: ../../library/logging.config.rst:30
msgid ""
"The following functions configure the logging module. They are located in "
"the :mod:`logging.config` module.  Their use is optional --- you can "
"configure the logging module using these functions or by making calls to the "
"main API (defined in :mod:`logging` itself) and defining handlers which are "
"declared either in :mod:`logging` or :mod:`logging.handlers`."
msgstr ""
"以下の関数は logging モジュールの環境設定をします。これらの関数は、 :mod:"
"`logging.config` にあります。これらの関数の使用はオプションです --- :mod:"
"`logging` モジュールはこれらの関数を使うか、 (:mod:`logging` 自体で定義されて"
"いる) 主要な API を呼び出し、 :mod:`logging` か :mod:`logging.handlers` で宣"
"言されているハンドラを定義することで設定できます。"

#: ../../library/logging.config.rst:38
msgid ""
"Takes the logging configuration from a dictionary.  The contents of this "
"dictionary are described in :ref:`logging-config-dictschema` below."
msgstr ""
"辞書からロギング環境設定を取得します。この辞書の内容は、以下の :ref:`logging-"
"config-dictschema` で記述されています。"

#: ../../library/logging.config.rst:42
msgid ""
"If an error is encountered during configuration, this function will raise a :"
"exc:`ValueError`, :exc:`TypeError`, :exc:`AttributeError` or :exc:"
"`ImportError` with a suitably descriptive message.  The following is a "
"(possibly incomplete) list of conditions which will raise an error:"
msgstr ""
"環境設定中にエラーに遭遇すると、この関数は適宜メッセージを記述しつつ :exc:"
"`ValueError`, :exc:`TypeError`, :exc:`AttributeError` または :exc:"
"`ImportError` を送出します。例外を送出する条件を (不完全かもしれませんが) 以"
"下に列挙します:"

#: ../../library/logging.config.rst:48
msgid ""
"A ``level`` which is not a string or which is a string not corresponding to "
"an actual logging level."
msgstr ""
"文字列でなかったり、実際のロギングレベルと関係ない文字列であったりする "
"``level``。"

#: ../../library/logging.config.rst:50
msgid "A ``propagate`` value which is not a boolean."
msgstr "ブール値でない ``propagate`` の値。"

#: ../../library/logging.config.rst:51
msgid "An id which does not have a corresponding destination."
msgstr "対応する行き先を持たない id。"

#: ../../library/logging.config.rst:52
msgid "A non-existent handler id found during an incremental call."
msgstr "インクリメンタルな呼び出しの中で見つかった存在しないハンドラ id。"

#: ../../library/logging.config.rst:53
msgid "An invalid logger name."
msgstr "無効なロガー名。"

#: ../../library/logging.config.rst:54
msgid "Inability to resolve to an internal or external object."
msgstr "内部や外部のオブジェクトに関わる不可能性。"

#: ../../library/logging.config.rst:56
msgid ""
"Parsing is performed by the :class:`DictConfigurator` class, whose "
"constructor is passed the dictionary used for configuration, and has a :meth:"
"`configure` method.  The :mod:`logging.config` module has a callable "
"attribute :attr:`dictConfigClass` which is initially set to :class:"
"`DictConfigurator`. You can replace the value of :attr:`dictConfigClass` "
"with a suitable implementation of your own."
msgstr ""
"解析は :class:`DictConfigurator` クラスによって行われます。このクラスのコンス"
"トラクタは環境設定に使われる辞書に渡され、このクラスは :meth:`configure` メ"
"ソッドを持ちます。 :mod:`logging.config` モジュールは、呼び出し可能属性 :"
"attr:`dictConfigClass` を持ち、これはまず :class:`DictConfigurator` に設定さ"
"れます。 :attr:`dictConfigClass` の値は適切な独自の実装で置き換えられます。"

#: ../../library/logging.config.rst:64
msgid ""
":func:`dictConfig` calls :attr:`dictConfigClass` passing the specified "
"dictionary, and then calls the :meth:`configure` method on the returned "
"object to put the configuration into effect::"
msgstr ""
":func:`dictConfig` は :attr:`dictConfigClass` を、指定された辞書を渡して呼び"
"出し、それから返されたオブジェクトの :meth:`configure` メソッドを呼び出して、"
"環境設定を作用させます::"

#: ../../library/logging.config.rst:71
msgid ""
"For example, a subclass of :class:`DictConfigurator` could call "
"``DictConfigurator.__init__()`` in its own :meth:`__init__()`, then set up "
"custom prefixes which would be usable in the subsequent :meth:`configure` "
"call. :attr:`dictConfigClass` would be bound to this new subclass, and then :"
"func:`dictConfig` could be called exactly as in the default, uncustomized "
"state."
msgstr ""
"例えば、 :class:`DictConfigurator` のサブクラスは、自身の :meth:`__init__()` "
"で ``DictConfigurator.__init__()`` を呼び出し、それから続く :meth:"
"`configure` の呼び出しに使えるカスタムの接頭辞を設定できます。 :attr:"
"`dictConfigClass` は、この新しいサブクラスに束縛され、そして :func:"
"`dictConfig` はちょうどデフォルトの、カスタマイズされていない状態のように呼び"
"出せます。"

#: ../../library/logging.config.rst:82
msgid ""
"Reads the logging configuration from a :mod:`configparser`\\-format file. "
"The format of the file should be as described in :ref:`logging-config-"
"fileformat`. This function can be called several times from an application, "
"allowing an end user to select from various pre-canned configurations (if "
"the developer provides a mechanism to present the choices and load the "
"chosen configuration)."
msgstr ""
"ログ記録の環境設定を :mod:`configparser` 形式ファイルから読み出します。その"
"ファイルの形式は :ref:`logging-config-fileformat` で記述されているとおりにし"
"なければなりません。この関数はアプリケーションから何度も呼び出すことができ、"
"これによって、 (設定を選択し、選択された設定を読み出す機構をデベロッパが提供"
"していれば) 複数の準備済みの設定からエンドユーザが選択するようにできます。"

#: ../../library/logging.config.rst:0
msgid "Parameters"
msgstr "パラメーター"

#: ../../library/logging.config.rst:90
msgid ""
"A filename, or a file-like object, or an instance derived from :class:"
"`~configparser.RawConfigParser`. If a ``RawConfigParser``-derived instance "
"is passed, it is used as is. Otherwise, a :class:`~configparser."
"Configparser` is instantiated, and the configuration read by it from the "
"object passed in ``fname``. If that has a :meth:`readline` method, it is "
"assumed to be a file-like object and read using :meth:`~configparser."
"ConfigParser.read_file`; otherwise, it is assumed to be a filename and "
"passed to :meth:`~configparser.ConfigParser.read`."
msgstr ""
"ファイル名、あるいはファイルのようなオブジェクト、または :class:"
"`~configparser.RawConfigParser` 派生のインスタンス。 :class:`~configparser."
"RawConfigParser` 派生のインスタンスが与えられれば、それはそのまま使われます。"
"そうでない場合 :class:`~configparser.Configparser` がインスタンス化され、設定"
"はそれを使って ``fname`` が指すオブジェクトから読み込まれます。それが :meth:"
"`readline` メソッドを持っていればそれはファイルのようなオブジェクトと仮定さ"
"れ、 :meth:`~configparser.ConfigParser.read_file` で読み込まれます; そうでな"
"い場合、それはファイル名と仮定されて、 :meth:`~configparser.ConfigParser."
"read` に渡されます。"

#: ../../library/logging.config.rst:102
msgid ""
"Defaults to be passed to the ConfigParser can be specified in this argument."
msgstr ""
"ConfigParser に渡されるデフォルト値をこの引数で指定することができます。"

#: ../../library/logging.config.rst:105
msgid ""
"If specified as ``False``, loggers which                                 "
"exist when this call is made are left                                 "
"enabled. The default is ``True`` because "
"this                                 enables old behaviour in "
"a                                 backward-compatible way. This behaviour is "
"to                                 disable any existing non-root loggers "
"unless                                 they or their ancestors are "
"explicitly named                                 in the logging "
"configuration.  :param encoding: The encoding used to open file when *fname* "
"is filename."
msgstr ""
"``False`` が指定されるとこの呼び出しが行われたときに存在するロガーは有効のま"
"ま残されます。後方互換性のあるやり方で古い振る舞いを保つので、デフォルト値は "
"``True`` になっています。そのような振る舞いでは、既存の非ルートロガーまたはそ"
"れらのロガーの先祖がロギング設定の中で明示的に名付けられていない限り、既存の"
"ロガーを無効にします。"

#: ../../library/logging.config.rst:112
msgid "If specified as ``False``, loggers which"
msgstr "``False`` が指定されると、"

#: ../../library/logging.config.rst:106
msgid ""
"exist when this call is made are left enabled. The default is ``True`` "
"because this enables old behaviour in a backward-compatible way. This "
"behaviour is to disable any existing non-root loggers unless they or their "
"ancestors are explicitly named in the logging configuration."
msgstr ""
"この呼び出しが行われたときに存在するロガーは有効のまま残されます。後方互換性"
"のあるやり方で古い振る舞いを保つので、デフォルト値は ``True`` になっていま"
"す。そのような振る舞いでは、既存の非ルートロガーまたはそれらのロガーの先祖が"
"ロギング設定の中で明示的に名付けられていない限り、既存のロガーを無効にしま"
"す。"

#: ../../library/logging.config.rst:0
msgid "param encoding"
msgstr "encoding"

#: ../../library/logging.config.rst:114
msgid "The encoding used to open file when *fname* is filename."
msgstr ""
"*fname* がファイル名の場合に、ファイルをオープンする時のエンコーディングで"
"す。"

#: ../../library/logging.config.rst:116
msgid ""
"An instance of a subclass of :class:`~configparser.RawConfigParser` is   now "
"accepted as a value for ``fname``. This facilitates:"
msgstr ""
"``fname`` として :class:`~configparser.RawConfigParser` のサブクラスのインス"
"タンスが渡せ得るようになっています。これによってこのようなことが容易になりま"
"す:"

#: ../../library/logging.config.rst:120
msgid ""
"Use of a configuration file where logging configuration is just part of the "
"overall application configuration."
msgstr ""
"ロギングの設定が、アプリケーション全体の設定における単なる一部であるような設"
"定ファイルの使用。"

#: ../../library/logging.config.rst:122
msgid ""
"Use of a configuration read from a file, and then modified by the using "
"application (e.g. based on command-line parameters or other aspects of the "
"runtime environment) before being passed to ``fileConfig``."
msgstr ""
"ファイルから設定を読み込み、 ``fileConfig`` に通す前に(例えばコマンドラインパ"
"ラメータやランタイム環境の他のなにかで)アプリケーションによって修正するような"
"こと。"

#: ../../library/logging.config.rst:126
msgid "The *encoding* parameter is added."
msgstr "*encoding* パラメータが追加されました。"

#: ../../library/logging.config.rst:131
msgid ""
"Starts up a socket server on the specified port, and listens for new "
"configurations. If no port is specified, the module's default :const:"
"`DEFAULT_LOGGING_CONFIG_PORT` is used. Logging configurations will be sent "
"as a file suitable for processing by :func:`dictConfig` or :func:"
"`fileConfig`. Returns a :class:`~threading.Thread` instance on which you can "
"call :meth:`~threading.Thread.start` to start the server, and which you can :"
"meth:`~threading.Thread.join` when appropriate. To stop the server, call :"
"func:`stopListening`."
msgstr ""
"指定されたポートでソケットサーバを起動し、新しい設定を待ち受けます。ポートが"
"指定されなかった場合は、モジュールのデフォルトの :const:"
"`DEFAULT_LOGGING_CONFIG_PORT` が使用されます。ロギング設定は :func:"
"`dictConfig` あるいは :func:`fileConfig` で処理できるファイルとして送信されま"
"す。 :class:`~threading.Thread` インスタンスを返し、このインスタンスの :meth:"
"`~threading.Thread.start` を呼び出してサーバを起動し、適切なところで :meth:"
"`~threading.Thread.join` を呼び出すことができます。サーバを停止するには、 :"
"func:`stopListening` を呼び出します。"

#: ../../library/logging.config.rst:140
msgid ""
"The ``verify`` argument, if specified, should be a callable which should "
"verify whether bytes received across the socket are valid and should be "
"processed. This could be done by encrypting and/or signing what is sent "
"across the socket, such that the ``verify`` callable can perform signature "
"verification and/or decryption. The ``verify`` callable is called with a "
"single argument - the bytes received across the socket - and should return "
"the bytes to be processed, or ``None`` to indicate that the bytes should be "
"discarded. The returned bytes could be the same as the passed in bytes (e.g. "
"when only verification is done), or they could be completely different "
"(perhaps if decryption were performed)."
msgstr ""
"``verify`` 引数を指定する場合は、これはソケットを通して受け取ったバイト文字列"
"が妥当であるか、処理すべきであるかどうかを検査する callable である必要があり"
"ます。ソケットを通じて、暗号化または署名あるいはその両方を受け取ることがあり"
"ます。そのような場合に、 ``verify`` callable が署名の正当性検査または暗号化の"
"復号あるいはその両方を実施することが出来ます。 ``verify`` callable は単一引数"
"で呼び出されます - ソケットを通じて受け取ったバイト文字列です - そして処理す"
"べきバイト文字列、または捨て去られるべきであることを示すための ``None`` を返"
"す必要があります。返却されるバイト文字列は(たとえば正当性検査だけが行われて)"
"渡されたものと同じかもしれませんし、あるいは(おそらく暗号化の復号が行われて)"
"まったく異なるものかもしれません。"

#: ../../library/logging.config.rst:151
msgid ""
"To send a configuration to the socket, read in the configuration file and "
"send it to the socket as a sequence of bytes preceded by a four-byte length "
"string packed in binary using ``struct.pack('>L', n)``."
msgstr ""
"ソケットに設定を送るには、まず設定ファイルを読み、それを ``struct.pack('>L', "
"n)`` を使って長さ 4 バイトのバイナリにパックしたものを前に付けたバイト列とし"
"てソケットに送ります。"

#: ../../library/logging.config.rst:159
msgid ""
"Because portions of the configuration are passed through :func:`eval`, use "
"of this function may open its users to a security risk. While the function "
"only binds to a socket on ``localhost``, and so does not accept connections "
"from remote machines, there are scenarios where untrusted code could be run "
"under the account of the process which calls :func:`listen`. Specifically, "
"if the process calling :func:`listen` runs on a multi-user machine where "
"users cannot trust each other, then a malicious user could arrange to run "
"essentially arbitrary code in a victim user's process, simply by connecting "
"to the victim's :func:`listen` socket and sending a configuration which runs "
"whatever code the attacker wants to have executed in the victim's process. "
"This is especially easy to do if the default port is used, but not hard even "
"if a different port is used. To avoid the risk of this happening, use the "
"``verify`` argument to :func:`listen` to prevent unrecognised configurations "
"from being applied."
msgstr ""
"設定の一部は :func:`eval` を通じて渡されるため、この関数を利用することはユー"
"ザーをセキュリティ上のリスクにさらす可能性があります。この関数は "
"``localhost`` のソケットだけにバインドされており、リモートマシンからの接続を"
"受け付けませんが、それでも :func:`listen` を呼び出したプロセスのアカウントの"
"もとで信頼できないコードが実行されうるシナリオが存在します。特に、 :func:"
"`listen` を呼び出したプロセスが複数のユーザーが利用するマシン上で実行されてお"
"り、ユーザー同士が互いに信頼できない場合、悪意あるユーザーが被害者ユーザーの"
"プロセス上で本質的に任意のコードを実行するように計画する可能性があります。攻"
"撃は、単に被害者ユーザーの :func:`listen` ソケットに接続して、被害者ユーザー"
"のプロセス上で攻撃者が実行したいコードが実行されるような設定を送り込むだけで"
"す。この攻撃はデフォルトのポートが使われている場合きわめて容易であり、異なる"
"ポートが使われている場合でもそれほど難しくはありません。このような事象が発生"
"するリスクを回避するためには、 :func:`listen` の ``verify`` 引数を使って不正"
"な設定が適用されるのを防ぐようにしてください。"

#: ../../library/logging.config.rst:175
msgid "The ``verify`` argument was added."
msgstr "``verify`` 引数が追加されました。"

#: ../../library/logging.config.rst:180
msgid ""
"If you want to send configurations to the listener which don't disable "
"existing loggers, you will need to use a JSON format for the configuration, "
"which will use :func:`dictConfig` for configuration. This method allows you "
"to specify ``disable_existing_loggers`` as ``False`` in the configuration "
"you send."
msgstr ""
"既存のロガーを無効にしない構成をリスナーに送信する場合は、設定にはJSONフォー"
"マットを使用する必要があります。これは、設定に :func:`dictConfig` を使用しま"
"す。 このメソッドを使用すると、 ``disable_existing_loggers`` に ``False`` を"
"指定した設定を送信できます。"

#: ../../library/logging.config.rst:189
msgid ""
"Stops the listening server which was created with a call to :func:`listen`. "
"This is typically called before calling :meth:`join` on the return value "
"from :func:`listen`."
msgstr ""
":func:`listen` を呼び出して作成された、待ち受け中のサーバを停止します。通常 :"
"func:`listen` の戻り値に対して :meth:`join` が呼ばれる前に呼び出します。"

#: ../../library/logging.config.rst:195
msgid "Security considerations"
msgstr "セキュリティで考慮すべき点"

#: ../../library/logging.config.rst:197
msgid ""
"The logging configuration functionality tries to offer convenience, and in "
"part this is done by offering the ability to convert text in configuration "
"files into Python objects used in logging configuration - for example, as "
"described in :ref:`logging-config-dict-userdef`. However, these same "
"mechanisms (importing callables from user-defined modules and calling them "
"with parameters from the configuration) could be used to invoke any code you "
"like, and for this reason you should treat configuration files from "
"untrusted sources with *extreme caution* and satisfy yourself that nothing "
"bad can happen if you load them, before actually loading them."
msgstr ""

#: ../../library/logging.config.rst:211
msgid "Configuration dictionary schema"
msgstr "環境設定辞書スキーマ"

#: ../../library/logging.config.rst:213
msgid ""
"Describing a logging configuration requires listing the various objects to "
"create and the connections between them; for example, you may create a "
"handler named 'console' and then say that the logger named 'startup' will "
"send its messages to the 'console' handler. These objects aren't limited to "
"those provided by the :mod:`logging` module because you might write your own "
"formatter or handler class. The parameters to these classes may also need to "
"include external objects such as ``sys.stderr``.  The syntax for describing "
"these objects and connections is defined in :ref:`logging-config-dict-"
"connections` below."
msgstr ""
"ロギング設定を記述するには、生成するさまざまなオブジェクトと、それらのつなが"
"りを列挙しなければなりません。例えば、 'console' という名前のハンドラを生成"
"し、'startup' という名前のロガーがメッセージを 'console' ハンドラに送るという"
"ようなことを記述します。これらのオブジェクトは、 :mod:`logging` モジュールに"
"よって提供されるものに限らず、独自のフォーマッタやハンドラクラスを書くことも"
"出来ます。このクラスへのパラメータは、 ``sys.stderr`` のような外部オブジェク"
"トを必要とすることもあります。これらのオブジェクトとつながりを記述する構文"
"は、以下の :ref:`logging-config-dict-connections` で定義されています。"

#: ../../library/logging.config.rst:225
msgid "Dictionary Schema Details"
msgstr "辞書スキーマの詳細"

#: ../../library/logging.config.rst:227
msgid ""
"The dictionary passed to :func:`dictConfig` must contain the following keys:"
msgstr ""
":func:`dictConfig` に渡される辞書は、以下のキーを含んでいなければなりません:"

#: ../../library/logging.config.rst:230
msgid ""
"*version* - to be set to an integer value representing the schema version.  "
"The only valid value at present is 1, but having this key allows the schema "
"to evolve while still preserving backwards compatibility."
msgstr ""
"*version* - スキーマのバージョンを表す整数値に設定されます。現在有効な値は 1 "
"だけですが、このキーがあることで、このスキーマは後方互換性を保ちながら発展で"
"きます。"

#: ../../library/logging.config.rst:235
msgid ""
"All other keys are optional, but if present they will be interpreted as "
"described below.  In all cases below where a 'configuring dict' is "
"mentioned, it will be checked for the special ``'()'`` key to see if a "
"custom instantiation is required.  If so, the mechanism described in :ref:"
"`logging-config-dict-userdef` below is used to create an instance; "
"otherwise, the context is used to determine what to instantiate."
msgstr ""
"その他すべてのキーは省略可能ですが、与えられたなら以下に記述するように解釈さ"
"れます。以下のすべての場合において、 '環境設定辞書' と記載されている所では、"
"その辞書に特殊な ``'()'`` キーがあるかを調べることで、カスタムのインスタント"
"化が必要であるか判断されます。その場合は、以下の :ref:`logging-config-dict-"
"userdef` で記述されている機構がインスタンス生成に使われます。そうでなければ、"
"インスタンス化するべきものを決定するのにコンテキストが使われます。"

#: ../../library/logging.config.rst:244
msgid ""
"*formatters* - the corresponding value will be a dict in which each key is a "
"formatter id and each value is a dict describing how to configure the "
"corresponding :class:`~logging.Formatter` instance."
msgstr ""
"*formatters* - 対応する値は辞書で、そのそれぞれのキーがフォーマッタ id にな"
"り、それぞれの値が対応する :class:`~logging.Formatter` インスタンスをどのよう"
"に環境設定するかを記述する辞書になります。"

#: ../../library/logging.config.rst:248
msgid ""
"The configuring dict is searched for the following optional keys which "
"correspond to the arguments passed to create a :class:`~logging.Formatter` "
"object:"
msgstr ""
"設定辞書は :class:`~logging.Formatter`  オブジェクトを作成するときの引数に対"
"応する、次のようなオプションキーがないか探索されます。"

#: ../../library/logging.config.rst:252
msgid "``format``"
msgstr "``format``"

#: ../../library/logging.config.rst:253
msgid "``datefmt``"
msgstr "``datefmt``"

#: ../../library/logging.config.rst:254
msgid "``style``"
msgstr "``style``"

#: ../../library/logging.config.rst:255
msgid "``validate`` (since version >=3.8)"
msgstr "``validate`` (バージョン3.8以降)"

#: ../../library/logging.config.rst:257
msgid ""
"An optional ``class`` key indicates the name of the formatter's class (as a "
"dotted module and class name).  The instantiation arguments are as for :"
"class:`~logging.Formatter`, thus this key is most useful for instantiating a "
"customised subclass of :class:`~logging.Formatter`.  For example, the "
"alternative class might present exception tracebacks in an expanded or "
"condensed format.  If your formatter requires different or extra "
"configuration keys, you should use :ref:`logging-config-dict-userdef`."
msgstr ""
"オプションの ``class`` キーはフォーマッタークラスの名前を表します（モジュール"
"とクラス名をドットで繋げる）。インスタンス化時の引数は :class:`~logging."
"Formatter` と同じであるため、このキーは :class:`~logging.Formatter` をカスタ"
"マイズしたサブクラスのインスタンス化に使うのがもっとも便利です。例えばトレー"
"スバックにさらに情報を付加したり、情報を要約代替クラスを実装するといったこと"
"が想定されます。もし、自作のフォーマッターが異なる引数や追加の設定引数を持つ"
"場合は、 :ref:`logging-config-dict-userdef` を使うべきです。"

#: ../../library/logging.config.rst:266
msgid ""
"*filters* - the corresponding value will be a dict in which each key is a "
"filter id and each value is a dict describing how to configure the "
"corresponding Filter instance."
msgstr ""
"*filters* - 対応する値は辞書で、そのそれぞれのキーがフィルタ id になり、それ"
"ぞれの値が対応する Filter インスタンスをどのように環境設定するかを記述する辞"
"書になります。"

#: ../../library/logging.config.rst:270
msgid ""
"The configuring dict is searched for the key ``name`` (defaulting to the "
"empty string) and this is used to construct a :class:`logging.Filter` "
"instance."
msgstr ""
"環境設定辞書は、(デフォルトが空文字列の) キー ``name`` を検索され、それらが :"
"class:`logging.Filter` インスタンスを構成するのに使われます。"

#: ../../library/logging.config.rst:274
msgid ""
"*handlers* - the corresponding value will be a dict in which each key is a "
"handler id and each value is a dict describing how to configure the "
"corresponding Handler instance."
msgstr ""
"*handlers* - 対応する値は辞書で、そのそれぞれのキーがハンドラ id になり、それ"
"ぞれの値が対応する Handler インスタンスをどのように環境設定するかを記述する辞"
"書になります。"

#: ../../library/logging.config.rst:278 ../../library/logging.config.rst:320
msgid "The configuring dict is searched for the following keys:"
msgstr "環境設定辞書は、以下のキーを検索されます:"

#: ../../library/logging.config.rst:280
msgid ""
"``class`` (mandatory).  This is the fully qualified name of the handler "
"class."
msgstr "``class`` (必須)。これはハンドラクラスの完全に修飾された名前です。"

#: ../../library/logging.config.rst:283
msgid "``level`` (optional).  The level of the handler."
msgstr "``level`` (任意)。ハンドラのレベルです。"

#: ../../library/logging.config.rst:285
msgid "``formatter`` (optional).  The id of the formatter for this handler."
msgstr "``formatter`` (任意)。このハンドラへのフォーマッタの id です。"

#: ../../library/logging.config.rst:288
msgid "``filters`` (optional).  A list of ids of the filters for this handler."
msgstr "``filters`` (任意)。このハンドラへのフィルタの id のリストです。"

#: ../../library/logging.config.rst:291
msgid ""
"All *other* keys are passed through as keyword arguments to the handler's "
"constructor.  For example, given the snippet:"
msgstr ""
"その他の *すべての* キーは、ハンドラのコンストラクタにキーワード引数として渡"
"されます。例えば、以下のコード片が与えられたとすると:"

#: ../../library/logging.config.rst:310
msgid ""
"the handler with id ``console`` is instantiated as a :class:`logging."
"StreamHandler`, using ``sys.stdout`` as the underlying stream.  The handler "
"with id ``file`` is instantiated as a :class:`logging.handlers."
"RotatingFileHandler` with the keyword arguments ``filename='logconfig.log', "
"maxBytes=1024, backupCount=3``."
msgstr ""
"id が ``console`` であるハンドラが、 ``sys.stdout`` を根底のストリームにし"
"て、 :class:`logging.StreamHandler` としてインスタンス化されます。id が "
"``file`` であるハンドラが、 ``filename='logconfig.log', maxBytes=1024, "
"backupCount=3`` をキーワード引数にして、 :class:`logging.handlers."
"RotatingFileHandler` としてインスタンス化されます。"

#: ../../library/logging.config.rst:316
msgid ""
"*loggers* - the corresponding value will be a dict in which each key is a "
"logger name and each value is a dict describing how to configure the "
"corresponding Logger instance."
msgstr ""
"*loggers* - 対応する値は辞書で、そのそれぞれのキーがロガー名になり、それぞれ"
"の値が対応する Logger インスタンスをどのように環境設定するかを記述する辞書に"
"なります。"

#: ../../library/logging.config.rst:322
msgid "``level`` (optional).  The level of the logger."
msgstr "``level`` (任意)。ロガーのレベルです。"

#: ../../library/logging.config.rst:324
msgid "``propagate`` (optional).  The propagation setting of the logger."
msgstr "``propagate`` (任意)。ロガーの伝播の設定です。"

#: ../../library/logging.config.rst:326
msgid "``filters`` (optional).  A list of ids of the filters for this logger."
msgstr "``filters`` (任意)。このロガーへのフィルタの id のリストです。"

#: ../../library/logging.config.rst:329
msgid ""
"``handlers`` (optional).  A list of ids of the handlers for this logger."
msgstr "``handlers`` (任意)。このロガーへのハンドラの id のリストです。"

#: ../../library/logging.config.rst:332
msgid ""
"The specified loggers will be configured according to the level, "
"propagation, filters and handlers specified."
msgstr ""
"指定されたロガーは、指定されたレベル、伝播、ハンドラに従って環境設定されま"
"す。"

#: ../../library/logging.config.rst:335
msgid ""
"*root* - this will be the configuration for the root logger. Processing of "
"the configuration will be as for any logger, except that the ``propagate`` "
"setting will not be applicable."
msgstr ""
"*root* - これは、ルートロガーへの設定になります。この環境設定の進行は、"
"``propagate`` 設定が適用されないことを除き、他のロガーと同じです。"

#: ../../library/logging.config.rst:339
msgid ""
"*incremental* - whether the configuration is to be interpreted as "
"incremental to the existing configuration.  This value defaults to "
"``False``, which means that the specified configuration replaces the "
"existing configuration with the same semantics as used by the existing :func:"
"`fileConfig` API."
msgstr ""
"*incremental* - この環境設定が既存の環境設定に対する増分として解釈されるかど"
"うかです。この値のデフォルトは ``False`` で、指定された環境設定は、既存の :"
"func:`fileConfig` API によって使われているのと同じ意味上で、既存の環境設定を"
"置き換えます。"

#: ../../library/logging.config.rst:345
msgid ""
"If the specified value is ``True``, the configuration is processed as "
"described in the section on :ref:`logging-config-dict-incremental`."
msgstr ""
"指定された値が ``True`` なら、環境設定は :ref:`logging-config-dict-"
"incremental` の節で記述されているように進行します。"

#: ../../library/logging.config.rst:348
msgid ""
"*disable_existing_loggers* - whether any existing non-root loggers are to be "
"disabled. This setting mirrors the parameter of the same name in :func:"
"`fileConfig`. If absent, this parameter defaults to ``True``. This value is "
"ignored if *incremental* is ``True``."
msgstr ""
"*disable_existing_loggers* - 既存の非ルートロガーをすべて無効にするべきかどう"
"かです。この設定は、 :func:`fileConfig` における同じ名前のパラメータと同じで"
"す。設定されていなければ、このパラメータのデフォルトは ``True`` です。この値"
"は、 *incremental* が ``True`` なら無視されます。"

#: ../../library/logging.config.rst:356
msgid "Incremental Configuration"
msgstr "増分設定"

#: ../../library/logging.config.rst:358
msgid ""
"It is difficult to provide complete flexibility for incremental "
"configuration.  For example, because objects such as filters and formatters "
"are anonymous, once a configuration is set up, it is not possible to refer "
"to such anonymous objects when augmenting a configuration."
msgstr ""
"増分設定に完全な柔軟性を提供するのは難しいです。例えば、フィルタやフォーマッ"
"タのようなオブジェクトは匿名なので、一旦環境設定がなされると、設定を拡張する"
"ときにそのような匿名オブジェクトを参照することができません。"

#: ../../library/logging.config.rst:364
msgid ""
"Furthermore, there is not a compelling case for arbitrarily altering the "
"object graph of loggers, handlers, filters, formatters at run-time, once a "
"configuration is set up; the verbosity of loggers and handlers can be "
"controlled just by setting levels (and, in the case of loggers, propagation "
"flags).  Changing the object graph arbitrarily in a safe way is problematic "
"in a multi-threaded environment; while not impossible, the benefits are not "
"worth the complexity it adds to the implementation."
msgstr ""
"さらに、一旦環境設定がなされた後、実行時にロガー、ハンドラ、フィルタ、フォー"
"マッタのオブジェクトグラフを任意に変えなければならない例もありません。ロガー"
"とハンドラの冗長性は、レベル (または、ロガーの場合には、伝播フラグ) を設定す"
"ることによってのみ制御できます。安全な方法でオブジェクトグラフを任意に変える"
"ことは、マルチスレッド環境で問題となります。不可能ではないですが、その効用は"
"実装に加えられる複雑さに見合いません。"

#: ../../library/logging.config.rst:373
msgid ""
"Thus, when the ``incremental`` key of a configuration dict is present and is "
"``True``, the system will completely ignore any ``formatters`` and "
"``filters`` entries, and process only the ``level`` settings in the "
"``handlers`` entries, and the ``level`` and ``propagate`` settings in the "
"``loggers`` and ``root`` entries."
msgstr ""
"従って、環境設定辞書の ``incremental`` キーが与えられ、これが ``True`` である"
"とき、システムは ``formatters`` と ``filters`` の項目を完全に無視し、"
"``handlers`` の項目の ``level`` 設定と、``loggers`` と ``root`` の項目の "
"``level`` と ``propagate`` 設定のみを処理します。"

#: ../../library/logging.config.rst:379
msgid ""
"Using a value in the configuration dict lets configurations to be sent over "
"the wire as pickled dicts to a socket listener. Thus, the logging verbosity "
"of a long-running application can be altered over time with no need to stop "
"and restart the application."
msgstr ""
"環境設定辞書の値を使うことで、設定は pickle 化された辞書としてネットワークを"
"通してソケットリスナに送ることができます。これにより、長時間起動するアプリ"
"ケーションのロギングの冗長性を、アプリケーションを止めて再起動する必要なし"
"に、いつでも変更することができます。"

#: ../../library/logging.config.rst:387
msgid "Object connections"
msgstr "オブジェクトの接続"

#: ../../library/logging.config.rst:389
msgid ""
"The schema describes a set of logging objects - loggers, handlers, "
"formatters, filters - which are connected to each other in an object graph.  "
"Thus, the schema needs to represent connections between the objects.  For "
"example, say that, once configured, a particular logger has attached to it a "
"particular handler.  For the purposes of this discussion, we can say that "
"the logger represents the source, and the handler the destination, of a "
"connection between the two.  Of course in the configured objects this is "
"represented by the logger holding a reference to the handler.  In the "
"configuration dict, this is done by giving each destination object an id "
"which identifies it unambiguously, and then using the id in the source "
"object's configuration to indicate that a connection exists between the "
"source and the destination object with that id."
msgstr ""
"このスキーマは、ロギングオブジェクトの一揃い - ロガー、ハンドラ、フォーマッ"
"タ、フィルタ - について記述します。これらは、オブジェクトグラフ上でお互い接続"
"されます。従って、このスキーマは、オブジェクト間の接続を表現しなければなりま"
"せん。例えば、環境設定で、特定のロガーが特定のハンドラに取り付けられたとしま"
"す。この議論では、ロガーとハンドラが、これら 2 つの接続のそれぞれ送信元と送信"
"先であるといえます。もちろん、この設定オブジェクト中では、これはハンドラへの"
"参照を保持しているロガーで表されます。設定辞書中で、これは次のようになされま"
"す。まず、送信先オブジェクトを曖昧さなく指定する id を与えます。そして、その "
"id を送信元オブジェクトの環境設定で使い、送信元とその id をもつ送信先が接続さ"
"れていることを示します。"

#: ../../library/logging.config.rst:403
msgid "So, for example, consider the following YAML snippet:"
msgstr "ですから、例えば、以下の YAML のコード片を例にとると:"

#: ../../library/logging.config.rst:424
msgid ""
"(Note: YAML used here because it's a little more readable than the "
"equivalent Python source form for the dictionary.)"
msgstr ""
"(注釈: YAML がここで使われているのは、辞書の等価な Python 形式よりもこちらの"
"ほうが少し読みやすいからです。)"

#: ../../library/logging.config.rst:427
msgid ""
"The ids for loggers are the logger names which would be used "
"programmatically to obtain a reference to those loggers, e.g. ``foo.bar."
"baz``.  The ids for Formatters and Filters can be any string value (such as "
"``brief``, ``precise`` above) and they are transient, in that they are only "
"meaningful for processing the configuration dictionary and used to determine "
"connections between objects, and are not persisted anywhere when the "
"configuration call is complete."
msgstr ""
"ロガーの id は、プログラム上でロガーへの参照を得るために使われるロガー名で、"
"たとえば ``foo.bar.baz`` です。フォーマッタとフィルタの id は、(上の "
"``brief``, ``precise`` のような) 任意の文字列値にできます。これらは一時的なも"
"ので、環境設定辞書の処理にのみ意味があり、オブジェクト間の接続を決定するのに"
"使われます。また、これらは設定の呼び出しが完了したとき、どこにも残りません。"

#: ../../library/logging.config.rst:435
msgid ""
"The above snippet indicates that logger named ``foo.bar.baz`` should have "
"two handlers attached to it, which are described by the handler ids ``h1`` "
"and ``h2``. The formatter for ``h1`` is that described by id ``brief``, and "
"the formatter for ``h2`` is that described by id ``precise``."
msgstr ""
"上記のコード片は、``foo.bar.baz`` というの名ロガーに、ハンドラ id ``h1`` と "
"``h2`` で表される 2 つのハンドラを接続することを示します。``h1`` のフォーマッ"
"タは id ``brief`` で記述されるもので、``h2`` のフォーマッタは id ``precise`` "
"で記述されるものです。"

#: ../../library/logging.config.rst:445
msgid "User-defined objects"
msgstr "ユーザ定義オブジェクト"

#: ../../library/logging.config.rst:447
msgid ""
"The schema supports user-defined objects for handlers, filters and "
"formatters.  (Loggers do not need to have different types for different "
"instances, so there is no support in this configuration schema for user-"
"defined logger classes.)"
msgstr ""
"このスキーマは、ハンドラ、フィルタ、フォーマッタのための、ユーザ定義オブジェ"
"クトをサポートします。(ロガーは、異なるインスタンスに対して異なる型を持つ必要"
"はないので、この環境設定スキーマは、ユーザ定義ロガークラスをサポートしていま"
"せん。)"

#: ../../library/logging.config.rst:452
msgid ""
"Objects to be configured are described by dictionaries which detail their "
"configuration.  In some places, the logging system will be able to infer "
"from the context how an object is to be instantiated, but when a user-"
"defined object is to be instantiated, the system will not know how to do "
"this.  In order to provide complete flexibility for user-defined object "
"instantiation, the user needs to provide a 'factory' - a callable which is "
"called with a configuration dictionary and which returns the instantiated "
"object. This is signalled by an absolute import path to the factory being "
"made available under the special key ``'()'``.  Here's a concrete example:"
msgstr ""
"設定されるオブジェクトは、それらの設定を詳述する辞書によって記述されます。場"
"所によっては、あるオブジェクトがどのようにインスタンス化されるかというコンテ"
"キストを、ロギングシステムが推測できます。しかし、ユーザ定義オブジェクトがイ"
"ンスタンス化されるとき、システムはどのようにこれを行うかを知りません。ユーザ"
"定義オブジェクトのインスタンス化を完全に柔軟なものにするため、ユーザは 'ファ"
"クトリ' - 設定辞書を引数として呼ばれ、インスタンス化されたオブジェクトを返す"
"呼び出し可能オブジェクト - を提供する必要があります。これは特殊キー ``'()'`` "
"で利用できる、ファクトリへの絶対インポートパスによって合図されます。ここに具"
"体的な例を挙げます:"

#: ../../library/logging.config.rst:478
msgid ""
"The above YAML snippet defines three formatters.  The first, with id "
"``brief``, is a standard :class:`logging.Formatter` instance with the "
"specified format string.  The second, with id ``default``, has a longer "
"format and also defines the time format explicitly, and will result in a :"
"class:`logging.Formatter` initialized with those two format strings.  Shown "
"in Python source form, the ``brief`` and ``default`` formatters have "
"configuration sub-dictionaries::"
msgstr ""
"上記の YAML コード片は 3 つのフォーマッタを定義します。 1 つ目は、id が "
"``brief`` で、指定されたフォーマット文字列をもつ、標準 :class:`logging."
"Formatter` インスタンスです。 2 つ目は、id が ``default`` で、長いフォーマッ"
"トを持ち、時間フォーマットも定義していて、結果はその 2 つのフォーマット文字列"
"で初期化された :class:`logging.Formatter` になります。Python ソース形式で見る"
"と、 ``brief`` と ``default`` フォーマッタは、それぞれ設定の部分辞書::"

#: ../../library/logging.config.rst:490
msgid "and::"
msgstr "および::"

#: ../../library/logging.config.rst:497
msgid ""
"respectively, and as these dictionaries do not contain the special key "
"``'()'``, the instantiation is inferred from the context: as a result, "
"standard :class:`logging.Formatter` instances are created.  The "
"configuration sub-dictionary for the third formatter, with id ``custom``, "
"is::"
msgstr ""
"を持ち、これらの辞書が特殊キー ``'()'`` を持たないので、インスタンス化はコン"
"テキストから推測され、結果として標準の :class:`logging.Formatter` インスタン"
"スが生成されます。id が ``custom`` である、3 つ目のフォーマッタの設定をする部"
"分辞書は::"

#: ../../library/logging.config.rst:510
msgid ""
"and this contains the special key ``'()'``, which means that user-defined "
"instantiation is wanted.  In this case, the specified factory callable will "
"be used. If it is an actual callable it will be used directly - otherwise, "
"if you specify a string (as in the example) the actual callable will be "
"located using normal import mechanisms. The callable will be called with the "
"**remaining** items in the configuration sub-dictionary as keyword "
"arguments.  In the above example, the formatter with id ``custom`` will be "
"assumed to be returned by the call::"
msgstr ""
"で、ユーザ定義のインスタンス化が望まれることを示す特殊キー ``'()'`` を含みま"
"す。この場合、指定された呼び出し可能ファクトリオブジェクトが使われます。これ"
"が実際の呼び出し可能オブジェクトであれば、それが直接使われます - そうではな"
"く、(この例でのように) 文字列を指定したなら、実際の呼び出し可能オブジェクト"
"は、通常のインポート機構を使って検索されます。その呼び出し可能オブジェクト"
"は、環境設定の部分辞書の、**残りの** 要素をキーワード引数として呼ばれます。上"
"記の例では、id が ``custom`` のフォーマッタは、以下の呼び出しによって返される"
"ものとみなされます::"

#: ../../library/logging.config.rst:522
msgid ""
"The key ``'()'`` has been used as the special key because it is not a valid "
"keyword parameter name, and so will not clash with the names of the keyword "
"arguments used in the call.  The ``'()'`` also serves as a mnemonic that the "
"corresponding value is a callable."
msgstr ""
"キー ``'()'`` が特殊キーとして使われるのは、キーワードパラメータ名として不正"
"で、呼び出しに使われるキーワード引数と衝突し得ないからです。``'()'`` はまた、"
"対応する値が呼び出し可能オブジェクトであると覚えやすくします。"

#: ../../library/logging.config.rst:527
msgid ""
"You can also specify a special key ``'.'`` whose value is a dictionary is a "
"mapping of attribute names to values. If found, the specified attributes "
"will be set on the user-defined object before it is returned. Thus, with the "
"following configuration::"
msgstr ""
"特殊なキーワード ``'.'`` を指定することもできます。この場合その値には属性名と"
"その値のマッピングをあらわす辞書を指定します。指定された属性は、もしそれが見"
"つかった場合、戻り値のユーザー定義オブジェクトに設定されます。したがって、以"
"下のように設定すると::"

#: ../../library/logging.config.rst:543
msgid ""
"the returned formatter will have attribute ``foo`` set to ``'bar'`` and "
"attribute ``baz`` set to ``'bozz'``."
msgstr ""
"戻り値のフォーマッタは属性 ``foo`` と``baz`` をもち、それぞれの値は "
"``'bar'`` と ``'bozz'`` に設定されます。"

#: ../../library/logging.config.rst:550
msgid "Access to external objects"
msgstr "外部オブジェクトへのアクセス"

#: ../../library/logging.config.rst:552
msgid ""
"There are times where a configuration needs to refer to objects external to "
"the configuration, for example ``sys.stderr``.  If the configuration dict is "
"constructed using Python code, this is straightforward, but a problem arises "
"when the configuration is provided via a text file (e.g. JSON, YAML).  In a "
"text file, there is no standard way to distinguish ``sys.stderr`` from the "
"literal string ``'sys.stderr'``.  To facilitate this distinction, the "
"configuration system looks for certain special prefixes in string values and "
"treat them specially.  For example, if the literal string ``'ext://sys."
"stderr'`` is provided as a value in the configuration, then the ``ext://`` "
"will be stripped off and the remainder of the value processed using normal "
"import mechanisms."
msgstr ""
"環境設定が、例えば ``sys.stderr`` のような、設定の外部のオブジェクトへの参照"
"を必要とすることがあります。設定辞書が Python コードで構成されていれば話は簡"
"単ですが、これがテキストファイル (JSON, YAML 等) を通して提供されていると問題"
"となります。テキストファイルでは、``sys.stderr`` をリテラル文字列 ``'sys."
"stderr'`` と区別する標準の方法がありません。この区別を容易にするため、環境設"
"定システムは、文字列中の特定の特殊接頭辞を見つけ、それらを特殊に扱います。例"
"えば、リテラル文字列 ``'ext://sys.stderr'`` が設定中の値として与えられたら、"
"この ``ext://`` は剥ぎ取られ、この値の残りが普通のインポート機構で処理されま"
"す。"

#: ../../library/logging.config.rst:565
msgid ""
"The handling of such prefixes is done in a way analogous to protocol "
"handling: there is a generic mechanism to look for prefixes which match the "
"regular expression ``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$`` whereby, if the "
"``prefix`` is recognised, the ``suffix`` is processed in a prefix-dependent "
"manner and the result of the processing replaces the string value.  If the "
"prefix is not recognised, then the string value will be left as-is."
msgstr ""
"このような接頭辞の処理は、プロトコルの処理と同じようになされます。どちらの機"
"構も、正規表現 ``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$`` にマッチする接頭辞を"
"検索し、それによって ``prefix`` が認識されたなら、接頭辞に応じたやり方で "
"``suffix`` が処理され、その処理の結果によって文字列値が置き換えられます。接頭"
"辞が認識されなければ、その文字列値はそのまま残されます。"

#: ../../library/logging.config.rst:577
msgid "Access to internal objects"
msgstr "内部オブジェクトへのアクセス"

#: ../../library/logging.config.rst:579
msgid ""
"As well as external objects, there is sometimes also a need to refer to "
"objects in the configuration.  This will be done implicitly by the "
"configuration system for things that it knows about.  For example, the "
"string value ``'DEBUG'`` for a ``level`` in a logger or handler will "
"automatically be converted to the value ``logging.DEBUG``, and the "
"``handlers``, ``filters`` and ``formatter`` entries will take an object id "
"and resolve to the appropriate destination object."
msgstr ""
"外部オブジェクトと同様、環境設定内部のオブジェクトへのアクセスを必要とするこ"
"ともあります。これは、その各オブジェクトを司る環境設定システムによって暗黙に"
"行われます。例えば、ロガーやハンドラの ``level`` に対する文字列値 "
"``'DEBUG'`` は、自動的に値 ``logging.DEBUG`` に変換されますし、``handlers``, "
"``filters`` および ``formatter`` の項目は、オブジェクト id を取って、適切な送"
"信先オブジェクトを決定します。"

#: ../../library/logging.config.rst:587
msgid ""
"However, a more generic mechanism is needed for user-defined objects which "
"are not known to the :mod:`logging` module.  For example, consider :class:"
"`logging.handlers.MemoryHandler`, which takes a ``target`` argument which is "
"another handler to delegate to. Since the system already knows about this "
"class, then in the configuration, the given ``target`` just needs to be the "
"object id of the relevant target handler, and the system will resolve to the "
"handler from the id.  If, however, a user defines a ``my.package.MyHandler`` "
"which has an ``alternate`` handler, the configuration system would not know "
"that the ``alternate`` referred to a handler.  To cater for this, a generic "
"resolution system allows the user to specify:"
msgstr ""
"しかし、ユーザ定義モジュールには、 :mod:`logging` モジュールには分からないよ"
"うな、より一般的な機構が必要です。例えば、 :class:`logging.handlers."
"MemoryHandler` があって、委譲する先の別のハンドラである ``target`` 引数を取る"
"とします。システムはこのクラスをすでに知っていますから、設定中で、与えられた "
"``target`` は関連するターゲットハンドラのオブジェクト id でさえあればよく、シ"
"ステムはその id からハンドラを決定します。しかし、ユーザが ``my.package."
"MyHandler`` を定義して、それが ``alternate`` ハンドラを持つなら、設定システム"
"は ``alternate`` がハンドラを参照していることを知りません。これを知らせるの"
"に、一般的な解析システムで、ユーザはこのように指定できます:"

#: ../../library/logging.config.rst:609
msgid ""
"The literal string ``'cfg://handlers.file'`` will be resolved in an "
"analogous way to strings with the ``ext://`` prefix, but looking in the "
"configuration itself rather than the import namespace.  The mechanism allows "
"access by dot or by index, in a similar way to that provided by ``str."
"format``.  Thus, given the following snippet:"
msgstr ""
"リテラル文字列 ``'cfg://handlers.file'`` は、``ext://`` 接頭辞が付いた文字列"
"と同じように分析されますが、インポート名前空間ではなく、環境設定自体が検索さ"
"れます。この機構は ``str.format`` でできるのと同じようにドットやインデックス"
"のアクセスができます。従って、環境設定において以下のコード片が与えられれば:"

#: ../../library/logging.config.rst:627
msgid ""
"in the configuration, the string ``'cfg://handlers'`` would resolve to the "
"dict with key ``handlers``, the string ``'cfg://handlers.email`` would "
"resolve to the dict with key ``email`` in the ``handlers`` dict, and so on.  "
"The string ``'cfg://handlers.email.toaddrs[1]`` would resolve to "
"``'dev_team@domain.tld'`` and the string ``'cfg://handlers.email."
"toaddrs[0]'`` would resolve to the value ``'support_team@domain.tld'``. The "
"``subject`` value could be accessed using either ``'cfg://handlers.email."
"subject'`` or, equivalently, ``'cfg://handlers.email[subject]'``.  The "
"latter form only needs to be used if the key contains spaces or non-"
"alphanumeric characters.  If an index value consists only of decimal digits, "
"access will be attempted using the corresponding integer value, falling back "
"to the string value if needed."
msgstr ""
"文字列 ``'cfg://handlers'`` は、キー ``handlers`` をもつ辞書であると分析さ"
"れ、文字列 ``'cfg://handlers.email'`` は、``handlers`` 辞書内の、``email`` "
"キーをもつ辞書であると分析されます。文字列 ``'cfg://handlers.email."
"toaddrs[1]`` は、``'dev_team@domain.tld'`` と分析され、``'cfg://handlers."
"email.toaddrs[0]'`` は値 ``'support_team@domain.tld'`` と分析されます。"
"``subject`` の値には、``'cfg://handlers.email.subject'`` または等価な "
"``'cfg://handlers.email[subject]'`` でアクセスできます。後者が必要なのは、"
"キーがスペースや非アルファベット文字を含むときのみです。インデックス値が十進"
"数字のみで構成されているなら、まず対応する整数値を使ってアクセスが試みられ、"
"必要なら文字列値で代替します。"

#: ../../library/logging.config.rst:641
msgid ""
"Given a string ``cfg://handlers.myhandler.mykey.123``, this will resolve to "
"``config_dict['handlers']['myhandler']['mykey']['123']``. If the string is "
"specified as ``cfg://handlers.myhandler.mykey[123]``, the system will "
"attempt to retrieve the value from ``config_dict['handlers']['myhandler']"
"['mykey'][123]``, and fall back to ``config_dict['handlers']['myhandler']"
"['mykey']['123']`` if that fails."
msgstr ""
"文字列 ``cfg://handlers.myhandler.mykey.123`` が与えられると、これは "
"``config_dict['handlers']['myhandler']['mykey']['123']`` と分析されます。文字"
"列が ``cfg://handlers.myhandler.mykey[123]`` と指定されたら、システムは "
"``config_dict['handlers']['myhandler']['mykey'][123]`` から値を引き出そうと"
"し、失敗したら ``config_dict['handlers']['myhandler']['mykey']['123']`` で代"
"替します。"

#: ../../library/logging.config.rst:653
msgid "Import resolution and custom importers"
msgstr "インポート解決とカスタムインポーター"

#: ../../library/logging.config.rst:655
msgid ""
"Import resolution, by default, uses the builtin :func:`__import__` function "
"to do its importing. You may want to replace this with your own importing "
"mechanism: if so, you can replace the :attr:`importer` attribute of the :"
"class:`DictConfigurator` or its superclass, the :class:`BaseConfigurator` "
"class. However, you need to be careful because of the way functions are "
"accessed from classes via descriptors. If you are using a Python callable to "
"do your imports, and you want to define it at class level rather than "
"instance level, you need to wrap it with :func:`staticmethod`. For example::"
msgstr ""
"インポート解決は、デフォルトではインポートを行うために :func:`__import__` 組"
"み込み関数を使用します。これを独自のインポートメカニズムに置き換えたいと思う"
"かもしれません: もしそうなら、 :class:`DictConfigurator` あるいはその上位クラ"
"スである :class:`BaseConfigurator` クラスの :attr:`importer` 属性を置換するこ"
"とができます。ただし、この関数はクラスからディスクリプタ経由でアクセスされる"
"点に注意する必要があります。インポートを行うために Python callable を使用して"
"いて、それをインスタンスレベルではなくクラスレベルで定義したければ、 :func:"
"`staticmethod` でそれをラップする必要があります。例えば::"

#: ../../library/logging.config.rst:670
msgid ""
"You don't need to wrap with :func:`staticmethod` if you're setting the "
"import callable on a configurator *instance*."
msgstr ""
"configurator *インスタンス* に対してインポート callable をセットする場合"
"は、 :func:`staticmethod` でラップする必要はありません。"

#: ../../library/logging.config.rst:677
msgid "Configuration file format"
msgstr "環境設定ファイルの書式"

#: ../../library/logging.config.rst:679
msgid ""
"The configuration file format understood by :func:`fileConfig` is based on :"
"mod:`configparser` functionality. The file must contain sections called "
"``[loggers]``, ``[handlers]`` and ``[formatters]`` which identify by name "
"the entities of each type which are defined in the file. For each such "
"entity, there is a separate section which identifies how that entity is "
"configured.  Thus, for a logger named ``log01`` in the ``[loggers]`` "
"section, the relevant configuration details are held in a section "
"``[logger_log01]``. Similarly, a handler called ``hand01`` in the "
"``[handlers]`` section will have its configuration held in a section called "
"``[handler_hand01]``, while a formatter called ``form01`` in the "
"``[formatters]`` section will have its configuration specified in a section "
"called ``[formatter_form01]``. The root logger configuration must be "
"specified in a section called ``[logger_root]``."
msgstr ""
":func:`fileConfig` が解釈できる環境設定ファイルの形式は、 :mod:"
"`configparser` の機能に基づいています。ファイルには、 ``[loggers]``, "
"``[handlers]``, ``[formatters]`` といったセクションが入っていなければならず、"
"各セクションではファイル中で定義されている各タイプのエンティティを名前で指定"
"しています。こうしたエンティティの各々について、そのエンティティをどう設定す"
"るかを示した個別のセクションがあります。すなわち、 ``log01`` という名前の "
"``[loggers]`` セクションにあるロガーに対しては、対応する詳細設定がセクション "
"``[logger_log01]`` に収められています。同様に、 ``hand01`` という名前の "
"``[handlers]`` セクションにあるハンドラは ``[handler_hand01]`` と呼ばれるセク"
"ションに設定をもつことになり、 ``[formatters]`` セクションにある ``form01`` "
"は ``[formatter_form01]`` というセクションで設定が指定されています。ルートロ"
"ガーの設定は ``[logger_root]`` と呼ばれるセクションで指定されていなければなり"
"ません。"

#: ../../library/logging.config.rst:694
msgid ""
"The :func:`fileConfig` API is older than the :func:`dictConfig` API and does "
"not provide functionality to cover certain aspects of logging. For example, "
"you cannot configure :class:`~logging.Filter` objects, which provide for "
"filtering of messages beyond simple integer levels, using :func:"
"`fileConfig`. If you need to have instances of :class:`~logging.Filter` in "
"your logging configuration, you will need to use :func:`dictConfig`. Note "
"that future enhancements to configuration functionality will be added to :"
"func:`dictConfig`, so it's worth considering transitioning to this newer API "
"when it's convenient to do so."
msgstr ""
":func:`fileConfig` API は :func:`dictConfig` API よりも古く、ロギングのある種"
"の側面についてカバーする機能に欠けています。たとえば :func:`fileConfig` では"
"数値レベルを超えたメッセージを単に拾うフィルタリングを行う :class:`~logging."
"Filter` オブジェクトを構成出来ません。 :class:`~logging.Filter` のインスタン"
"スをロギングの設定において持つ必要があるならば、 :func:`dictConfig` を使う必"
"要があるでしょう。設定の機能における将来の拡張は :func:`dictConfig` に対して"
"行われることに注意してください。ですから、そうするのが便利であるときに新しい "
"API に乗り換えるのは良い考えです。"

#: ../../library/logging.config.rst:704
msgid "Examples of these sections in the file are given below."
msgstr "ファイルにおけるこれらのセクションの例を以下に示します。"

#: ../../library/logging.config.rst:717
msgid ""
"The root logger must specify a level and a list of handlers. An example of a "
"root logger section is given below."
msgstr ""
"ルートロガーでは、レベルとハンドラのリストを指定しなければなりません。ルート"
"ロガーのセクションの例を以下に示します。"

#: ../../library/logging.config.rst:726
msgid ""
"The ``level`` entry can be one of ``DEBUG, INFO, WARNING, ERROR, CRITICAL`` "
"or ``NOTSET``. For the root logger only, ``NOTSET`` means that all messages "
"will be logged. Level values are :func:`eval`\\ uated in the context of the "
"``logging`` package's namespace."
msgstr ""
"``level`` エントリは ``DEBUG, INFO, WARNING, ERROR, CRITICAL`` のうちの一つ"
"か、 ``NOTSET`` になります。ルートロガーの場合にのみ、 ``NOTSET`` はすべての"
"メッセージがログ記録されることを意味します。レベル値は ``logging`` パッケージ"
"の名前空間のコンテキストにおいて :func:`eval` されます。"

#: ../../library/logging.config.rst:731
msgid ""
"The ``handlers`` entry is a comma-separated list of handler names, which "
"must appear in the ``[handlers]`` section. These names must appear in the "
"``[handlers]`` section and have corresponding sections in the configuration "
"file."
msgstr ""
"``handlers`` エントリはコンマで区切られたハンドラ名からなるリストで、"
"``[handlers]`` セクションになくてはなりません。また、これらの各ハンドラの名前"
"に対応するセクションが設定ファイルに存在しなければなりません。"

#: ../../library/logging.config.rst:736
msgid ""
"For loggers other than the root logger, some additional information is "
"required. This is illustrated by the following example."
msgstr ""
"ルートロガー以外のロガーでは、いくつか追加の情報が必要になります。これは以下"
"の例のように表されます。"

#: ../../library/logging.config.rst:747
msgid ""
"The ``level`` and ``handlers`` entries are interpreted as for the root "
"logger, except that if a non-root logger's level is specified as ``NOTSET``, "
"the system consults loggers higher up the hierarchy to determine the "
"effective level of the logger. The ``propagate`` entry is set to 1 to "
"indicate that messages must propagate to handlers higher up the logger "
"hierarchy from this logger, or 0 to indicate that messages are **not** "
"propagated to handlers up the hierarchy. The ``qualname`` entry is the "
"hierarchical channel name of the logger, that is to say the name used by the "
"application to get the logger."
msgstr ""
"``level`` および ``handlers`` エントリはルートロガーのエントリと同様に解釈さ"
"れますが、非ルートロガーのレベルが ``NOTSET`` に指定された場合、ロギングシス"
"テムはロガー階層のより上位のロガーにロガーの実効レベルを問い合わせるところが"
"違います。``propagate`` エントリは、メッセージをロガー階層におけるこのロガー"
"の上位のハンドラに伝播させることを示す 1 に設定されるか、メッセージを階層の上"
"位に伝播 **しない** ことを示す 0 に設定されます。``qualname`` エントリはロ"
"ガーのチャネル名を階層的に表したもの、すなわちアプリケーションがこのロガーを"
"取得する際に使う名前になります。"

#: ../../library/logging.config.rst:756
msgid ""
"Sections which specify handler configuration are exemplified by the "
"following."
msgstr "ハンドラの環境設定を指定しているセクションは以下の例のようになります。"

#: ../../library/logging.config.rst:766
msgid ""
"The ``class`` entry indicates the handler's class (as determined by :func:"
"`eval` in the ``logging`` package's namespace). The ``level`` is interpreted "
"as for loggers, and ``NOTSET`` is taken to mean 'log everything'."
msgstr ""
"``class`` エントリはハンドラのクラス (``logging`` パッケージの名前空間におい"
"て :func:`eval` で決定されます) を示します。 ``level`` はロガーの場合と同じよ"
"うに解釈され、 ``NOTSET`` は \"すべてを記録する (log everything)\" と解釈され"
"ます。"

#: ../../library/logging.config.rst:770
msgid ""
"The ``formatter`` entry indicates the key name of the formatter for this "
"handler. If blank, a default formatter (``logging._defaultFormatter``) is "
"used. If a name is specified, it must appear in the ``[formatters]`` section "
"and have a corresponding section in the configuration file."
msgstr ""
"``formatter`` エントリはこのハンドラのフォーマッタに対するキー名を表します。"
"空文字列の場合、デフォルトのフォーマッタ (``logging._defaultFormatter``) が使"
"われます。名前が指定されている場合、その名前は ``[formatters]`` セクションに"
"なくてはならず、対応するセクションが設定ファイル中になければなりません。"

#: ../../library/logging.config.rst:775
msgid ""
"The ``args`` entry, when :func:`eval`\\ uated in the context of the "
"``logging`` package's namespace, is the list of arguments to the constructor "
"for the handler class. Refer to the constructors for the relevant handlers, "
"or to the examples below, to see how typical entries are constructed. If not "
"provided, it defaults to ``()``."
msgstr ""
"``args`` エントリは、 ``logging`` パッケージの名前空間のコンテキストで :func:"
"`eval` される際、ハンドラクラスのコンストラクタに対する引数からなるリストにな"
"ります。典型的なエントリがどうやって作成されるかについては、対応するハンドラ"
"のコンストラクタか、以下の例を参照してください。もし指定しなかった場合にはデ"
"フォルトは ``()`` となります。"

#: ../../library/logging.config.rst:781
msgid ""
"The optional ``kwargs`` entry, when :func:`eval`\\ uated in the context of "
"the ``logging`` package's namespace, is the keyword argument dict to the "
"constructor for the handler class. If not provided, it defaults to ``{}``."
msgstr ""
"オプションの ``kwargs`` エントリーは、 :func:`eval` が ``logging`` パッケージ"
"の名前空間のコンテキストで利用された時に、ハンドラークラスのコンストラクタに"
"渡されるキーワード引数辞書となります。指定されなかったときのデフォルトは ``{}"
"`` です。"

#: ../../library/logging.config.rst:838
msgid ""
"Sections which specify formatter configuration are typified by the following."
msgstr "フォーマッタの環境設定を指定しているセクションは以下のような形式です。"

#: ../../library/logging.config.rst:849
msgid ""
"The arguments for the formatter configuration are the same as the keys in "
"the dictionary schema :ref:`formatters section <logging-config-dictschema-"
"formatters>`."
msgstr ""
":ref:`フォーマッターのセクション <logging-config-dictschema-formatters>` の辞"
"書スキーマと同じキーを持つ、フォーマッター設定の引数です。"

#: ../../library/logging.config.rst:855
msgid ""
"Due to the use of :func:`eval` as described above, there are potential "
"security risks which result from using the :func:`listen` to send and "
"receive configurations via sockets. The risks are limited to where multiple "
"users with no mutual trust run code on the same machine; see the :func:"
"`listen` documentation for more information."
msgstr ""
":func:`eval` を使用していることで、上述のようにソケット経由で設定を送受信する"
"ために :func:`listen` を使用していることに起因する潜在的なセキュリティリスク"
"があります。そのリスクは、相互に信頼できない多数のユーザが同じマシン上でコー"
"ドを実行する場合に制限されています; 詳細は :func:`listen` ドキュメンテーショ"
"ンを参照してください。"

#: ../../library/logging.config.rst:864
msgid "Module :mod:`logging`"
msgstr ":mod:`logging` モジュール"

#: ../../library/logging.config.rst:864
msgid "API reference for the logging module."
msgstr "logging モジュールの API リファレンス。"

#: ../../library/logging.config.rst:866
msgid "Module :mod:`logging.handlers`"
msgstr ":mod:`logging.handlers` モジュール"

#: ../../library/logging.config.rst:867
msgid "Useful handlers included with the logging module."
msgstr "logging モジュールに含まれる、便利なハンドラです。"
