# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-30 14:59+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/logging.rst:2
msgid ":mod:`logging` --- Logging facility for Python"
msgstr ":mod:`logging` --- Python 用ロギング機能"

#: ../../library/logging.rst:10
msgid "**Source code:** :source:`Lib/logging/__init__.py`"
msgstr "**ソースコード:** :source:`Lib/logging/__init__.py`"

#: ../../library/logging.rst:16
msgid ""
"This page contains the API reference information. For tutorial information "
"and discussion of more advanced topics, see"
msgstr ""
"このページには、リファレンス情報だけが含まれています。チュートリアルは、以下"
"のページを参照してください"

#: ../../library/logging.rst:19
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`基本チュートリアル <logging-basic-tutorial>`"

#: ../../library/logging.rst:20
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`上級チュートリアル <logging-advanced-tutorial>`"

#: ../../library/logging.rst:21
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`ロギングクックブック <logging-cookbook>`"

#: ../../library/logging.rst:25
msgid ""
"This module defines functions and classes which implement a flexible event "
"logging system for applications and libraries."
msgstr ""
"このモジュールは、アプリケーションやライブラリのための柔軟なエラーログ記録 "
"(logging) システムを実装するための関数やクラスを定義しています。"

#: ../../library/logging.rst:28
msgid ""
"The key benefit of having the logging API provided by a standard library "
"module is that all Python modules can participate in logging, so your "
"application log can include your own messages integrated with messages from "
"third-party modules."
msgstr ""
"標準ライブラリモジュールとしてログ記録 API が提供される利点は、すべての "
"Python モジュールがログ記録に参加できることであり、これによってあなたが書くア"
"プリケーションのログにサードパーティーのモジュールが出力するメッセージを含ま"
"せることができます。"

#: ../../library/logging.rst:33
msgid "The simplest example:"
msgstr ""

#: ../../library/logging.rst:41
msgid ""
"The module provides a lot of functionality and flexibility.  If you are "
"unfamiliar with logging, the best way to get to grips with it is to view the "
"tutorials (**see the links above and on the right**)."
msgstr ""

#: ../../library/logging.rst:45
msgid ""
"The basic classes defined by the module, together with their functions, are "
"listed below."
msgstr "モジュールで定義されている基本的なクラスと関数を、以下に列挙します。"

#: ../../library/logging.rst:48
msgid "Loggers expose the interface that application code directly uses."
msgstr ""
"ロガーは、アプリケーションコードが直接使うインターフェースを公開します。"

#: ../../library/logging.rst:49
msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr ""
"ハンドラは、(ロガーによって生成された) ログ記録を適切な送信先に送ります。"

#: ../../library/logging.rst:51
msgid ""
"Filters provide a finer grained facility for determining which log records "
"to output."
msgstr ""
"フィルタは、どのログ記録を出力するかを決定する、きめ細かい機能を提供します。"

#: ../../library/logging.rst:53
msgid "Formatters specify the layout of log records in the final output."
msgstr "フォーマッタは、ログ記録が最終的に出力されるレイアウトを指定します。"

#: ../../library/logging.rst:59
msgid "Logger Objects"
msgstr "ロガーオブジェクト"

#: ../../library/logging.rst:61
msgid ""
"Loggers have the following attributes and methods.  Note that Loggers should "
"*NEVER* be instantiated directly, but always through the module-level "
"function ``logging.getLogger(name)``.  Multiple calls to :func:`getLogger` "
"with the same name will always return a reference to the same Logger object."
msgstr ""
"ロガーには以下のような属性とメソッドがあります。\n"
"ロガーを直接インスタンス化することは *絶対に* してはならず、常にモジュール関"
"数 ``logging.getLogger(name)`` を介してインスタンス化することに注意してくださ"
"い。\n"
"同じ name で :func:`getLogger` を複数回呼び出すと、常に同じロガー・オブジェク"
"トへの参照が返されます。"

#: ../../library/logging.rst:66
msgid ""
"The ``name`` is potentially a period-separated hierarchical value, like "
"``foo.bar.baz`` (though it could also be just plain ``foo``, for example). "
"Loggers that are further down in the hierarchical list are children of "
"loggers higher up in the list.  For example, given a logger with a name of "
"``foo``, loggers with names of ``foo.bar``, ``foo.bar.baz``, and ``foo.bam`` "
"are all descendants of ``foo``.  The logger name hierarchy is analogous to "
"the Python package hierarchy, and identical to it if you organise your "
"loggers on a per-module basis using the recommended construction ``logging."
"getLogger(__name__)``.  That's because in a module, ``__name__`` is the "
"module's name in the Python package namespace."
msgstr ""
"``name`` は ``foo.bar.baz`` のようにピリオドで分割された (ただし単なるプレー"
"ンな ``foo`` もありえます) 潜在的に階層的な値です。階層リスト中でより下位のロ"
"ガーは、上位のロガーの子です。例えば、``foo`` という名前を持つロガーがあると"
"き、``foo.bar``, ``foo.bar.baz``, ``foo.bam`` という名前を持つロガーはすべて "
"``foo`` の子孫です。ロガー名の階層は Python パッケージ階層と類似していて、推"
"奨される構築方法 ``logging.getLogger(__name__)`` を使用してロガーをモジュール"
"単位で構成すれば、Python パッケージ階層と同一になります。これは、モジュールの"
"中では ``__name__`` が Python パッケージ名前空間におけるモジュール名だからで"
"す。"

#: ../../library/logging.rst:82
msgid ""
"If this attribute evaluates to true, events logged to this logger will be "
"passed to the handlers of higher level (ancestor) loggers, in addition to "
"any handlers attached to this logger. Messages are passed directly to the "
"ancestor loggers' handlers - neither the level nor filters of the ancestor "
"loggers in question are considered."
msgstr ""
"この属性が真と評価された場合、このロガーに記録されたイベントは、このロガーに"
"取り付けられた全てのハンドラに加え、上位 (祖先) ロガーのハンドラにも渡されま"
"す。\n"
"メッセージは、祖先ロガーのハンドラに直接渡されます - 今問題にしている祖先ロ"
"ガーのレベルもフィルタも、どちらも考慮されません。"

#: ../../library/logging.rst:88
msgid ""
"If this evaluates to false, logging messages are not passed to the handlers "
"of ancestor loggers."
msgstr ""
"この値の評価結果が偽になる場合、ロギングメッセージは祖先ロガーのハンドラに渡"
"されません。"

#: ../../library/logging.rst:91
msgid ""
"Spelling it out with an example: If the propagate attribute of the logger "
"named ``A.B.C`` evaluates to true, any event logged to ``A.B.C`` via a "
"method call such as ``logging.getLogger('A.B.C').error(...)`` will [subject "
"to passing that logger's level and filter settings] be passed in turn to any "
"handlers attached to loggers named ``A.B``, ``A`` and the root logger, after "
"first being passed to any handlers attached to ``A.B.C``. If any logger in "
"the chain ``A.B.C``, ``A.B``, ``A`` has its ``propagate`` attribute set to "
"false, then that is the last logger whose handlers are offered the event to "
"handle, and propagation stops at that point."
msgstr ""

#: ../../library/logging.rst:100
msgid "The constructor sets this attribute to ``True``."
msgstr "コンストラクタはこの属性を ``True`` に設定します。"

#: ../../library/logging.rst:102
msgid ""
"If you attach a handler to a logger *and* one or more of its ancestors, it "
"may emit the same record multiple times. In general, you should not need to "
"attach a handler to more than one logger - if you just attach it to the "
"appropriate logger which is highest in the logger hierarchy, then it will "
"see all events logged by all descendant loggers, provided that their "
"propagate setting is left set to ``True``. A common scenario is to attach "
"handlers only to the root logger, and to let propagation take care of the "
"rest."
msgstr ""
"ハンドラを、あるロガー *と* その祖先のロガーに接続した場合、同一レコードが複"
"数回発行される場合があります。一般的に、ハンドラを複数のロガーに接続する必要"
"はありません。propagate 設定が ``True`` のままになっていれば、ロガーの階層に"
"おいて最上位にある適切なロガーにハンドラを接続するだけで、そのハンドラは全て"
"の子孫ロガーが記録する全てのイベントを確認することができます。一般的なシナリ"
"オでは、ハンドラをルートロガーに対してのみ接続し、残りは propagate にすべて委"
"ねます。"

#: ../../library/logging.rst:113
msgid ""
"Sets the threshold for this logger to *level*. Logging messages which are "
"less severe than *level* will be ignored; logging messages which have "
"severity *level* or higher will be emitted by whichever handler or handlers "
"service this logger, unless a handler's level has been set to a higher "
"severity level than *level*."
msgstr ""
"このロガーの閾値を *level* に設定します。\n"
"*level* よりも深刻でないログメッセージは無視されます; 深刻さが *level* 以上の"
"ログメッセージは、ハンドラのレベルが *level* より上に設定されていない限り、こ"
"のロガーに取り付けられているハンドラによって投げられます。"

#: ../../library/logging.rst:118
msgid ""
"When a logger is created, the level is set to :const:`NOTSET` (which causes "
"all messages to be processed when the logger is the root logger, or "
"delegation to the parent when the logger is a non-root logger). Note that "
"the root logger is created with level :const:`WARNING`."
msgstr ""
"ロガーが生成された際、レベルは :const:`NOTSET` (これによりすべてのメッセージ"
"について、ロガーがルートロガーであれば処理される、そうでなくてロガーが非ルー"
"トロガーの場合には親ロガーに委譲させる) に設定されます。\n"
"ルートロガーは :const:`WARNING` レベルで生成されることに注意してください。"

#: ../../library/logging.rst:123
msgid ""
"The term 'delegation to the parent' means that if a logger has a level of "
"NOTSET, its chain of ancestor loggers is traversed until either an ancestor "
"with a level other than NOTSET is found, or the root is reached."
msgstr ""
"「親ロガーに委譲」という用語の意味は、もしロガーのレベルが NOTSET ならば、祖"
"先ロガーの系列の中を NOTSET 以外のレベルの祖先を見つけるかルートに到達するま"
"で辿っていく、ということです。"

#: ../../library/logging.rst:127
msgid ""
"If an ancestor is found with a level other than NOTSET, then that ancestor's "
"level is treated as the effective level of the logger where the ancestor "
"search began, and is used to determine how a logging event is handled."
msgstr ""
"もし NOTSET 以外のレベルの祖先が見つかったなら、その祖先のレベルが探索を開始"
"したロガーの実効レベルとして扱われ、ログイベントがどのように処理されるかを決"
"めるのに使われます。"

#: ../../library/logging.rst:131
msgid ""
"If the root is reached, and it has a level of NOTSET, then all messages will "
"be processed. Otherwise, the root's level will be used as the effective "
"level."
msgstr ""
"ルートに到達した場合、ルートのレベルが NOTSET ならばすべてのメッセージは処理"
"されます。そうでなければルートのレベルが実効レベルとして使われます。"

#: ../../library/logging.rst:134 ../../library/logging.rst:447
msgid "See :ref:`levels` for a list of levels."
msgstr "レベルの一覧については :ref:`levels` を参照してください。"

#: ../../library/logging.rst:136
msgid ""
"The *level* parameter now accepts a string representation of the level such "
"as 'INFO' as an alternative to the integer constants such as :const:`INFO`. "
"Note, however, that levels are internally stored as integers, and methods "
"such as e.g. :meth:`getEffectiveLevel` and :meth:`isEnabledFor` will return/"
"expect to be passed integers."
msgstr ""
"*level* パラメータは、 :const:`INFO` のような整数定数の代わりに 'INFO' のよう"
"なレベルの文字列表現も受け付けるようになりました。ただし、レベルは内部で整数"
"として保存されますし、 :meth:`getEffectiveLevel` や :meth:`isEnabledFor` と"
"いったメソッドは、整数を返し、また渡されるものと期待します。"

#: ../../library/logging.rst:146
msgid ""
"Indicates if a message of severity *level* would be processed by this "
"logger. This method checks first the module-level level set by ``logging."
"disable(level)`` and then the logger's effective level as determined by :"
"meth:`getEffectiveLevel`."
msgstr ""
"深刻度が *lvl* のメッセージが、このロガーで処理されることになっているかどうか"
"を示します。このメソッドはまず、 ``logging.disable(level)`` で設定されるモ"
"ジュールレベルの深刻度レベルを調べ、次にロガーの実効レベルを :meth:"
"`getEffectiveLevel` で調べます。"

#: ../../library/logging.rst:154
msgid ""
"Indicates the effective level for this logger. If a value other than :const:"
"`NOTSET` has been set using :meth:`setLevel`, it is returned. Otherwise, the "
"hierarchy is traversed towards the root until a value other than :const:"
"`NOTSET` is found, and that value is returned. The value returned is an "
"integer, typically one of :const:`logging.DEBUG`, :const:`logging.INFO` etc."
msgstr ""
"このロガーの実効レベルを示します。 :const:`NOTSET` 以外の値が :meth:"
"`setLevel` で設定されていた場合、その値が返されます。そうでない場合、 :const:"
"`NOTSET` 以外の値が見つかるまでロガーの階層をルートロガーの方向に追跡します。"
"見つかった場合、その値が返されます。返される値は整数で、典型的には :const:"
"`logging.DEBUG`, :const:`logging.INFO` 等のうち一つです。"

#: ../../library/logging.rst:164
msgid ""
"Returns a logger which is a descendant to this logger, as determined by the "
"suffix. Thus, ``logging.getLogger('abc').getChild('def.ghi')`` would return "
"the same logger as would be returned by ``logging.getLogger('abc.def."
"ghi')``. This is a convenience method, useful when the parent logger is "
"named using e.g. ``__name__`` rather than a literal string."
msgstr ""
"このロガーの子であるロガーを、接頭辞によって決定し、返します。従って、"
"``logging.getLogger('abc').getChild('def.ghi')`` は、``logging."
"getLogger('abc.def.ghi')`` によって返されるのと同じロガーを返すことになりま"
"す。これは簡便なメソッドで、親ロガーがリテラルでなく ``__name__`` などを使っ"
"て名付けられているときに便利です。"

#: ../../library/logging.rst:175
msgid ""
"Logs a message with level :const:`DEBUG` on this logger. The *msg* is the "
"message format string, and the *args* are the arguments which are merged "
"into *msg* using the string formatting operator. (Note that this means that "
"you can use keywords in the format string, together with a single dictionary "
"argument.) No % formatting operation is performed on *msg* when no *args* "
"are supplied."
msgstr ""
"レベル :const:`DEBUG` のメッセージをこのロガーで記録します。 *msg* はメッセー"
"ジの書式文字列で、 *args* は *msg* に文字列書式化演算子を使って取り込むための"
"引数です。 (これは、書式化文字列の中でキーワードを使い、引数として単一の辞書"
"を渡すことができる、ということを意味します。) *args* が提供されない場合は "
"*msg* の%フォーマットは実行されません。"

#: ../../library/logging.rst:181
msgid ""
"There are four keyword arguments in *kwargs* which are inspected: "
"*exc_info*, *stack_info*, *stacklevel* and *extra*."
msgstr ""
"*kwargs* のうち、 *exc_info*, *stack_info*, *stacklevel*, *extra* という4つの"
"キーワード引数の中身を調べます。"

#: ../../library/logging.rst:184
msgid ""
"If *exc_info* does not evaluate as false, it causes exception information to "
"be added to the logging message. If an exception tuple (in the format "
"returned by :func:`sys.exc_info`) or an exception instance is provided, it "
"is used; otherwise, :func:`sys.exc_info` is called to get the exception "
"information."
msgstr ""
"*exc_info* は、この値の評価値が false でない場合、例外情報がロギングメッセー"
"ジに追加されます。もし例外情報をあらわすタプル(:func:`sys.exc_info` 関数に"
"よって戻されるフォーマットにおいて)、または、例外情報をあらわすインスタンスが"
"与えられていれば、それが使用されることになります。それ以外の場合には、 :func:"
"`sys.exc_info` を呼び出して例外情報を取得します。"

#: ../../library/logging.rst:189 ../../library/logging.rst:1066
msgid ""
"The second optional keyword argument is *stack_info*, which defaults to "
"``False``. If true, stack information is added to the logging message, "
"including the actual logging call. Note that this is not the same stack "
"information as that displayed through specifying *exc_info*: The former is "
"stack frames from the bottom of the stack up to the logging call in the "
"current thread, whereas the latter is information about stack frames which "
"have been unwound, following an exception, while searching for exception "
"handlers."
msgstr ""
"2つ目の省略可能なキーワード引数は *stack_info* で、デフォルトは ``False`` で"
"す。真の場合、実際のロギング呼び出しを含むスタック情報がロギングメッセージに"
"追加されます。これは *exc_info* 指定によって表示されるスタック情報と同じもの"
"ではないことに注意してください: 前者はカレントスレッド内での、一番下からロギ"
"ング呼び出しまでのスタックフレームですが、後者は例外に呼応して、例外ハンドラ"
"が見つかるところまで巻き戻されたスタックフレームの情報です。"

#: ../../library/logging.rst:198 ../../library/logging.rst:1075
msgid ""
"You can specify *stack_info* independently of *exc_info*, e.g. to just show "
"how you got to a certain point in your code, even when no exceptions were "
"raised. The stack frames are printed following a header line which says:"
msgstr ""
"*exc_info* とは独立に *stack_info* を指定することもできます (例えば、例外が上"
"げられなかった場合でも、コード中のある地点にどのように到着したかを単に示すた"
"めに)。スタックフレームは、次のようなヘッダー行に続いて表示されます:"

#: ../../library/logging.rst:206 ../../library/logging.rst:1083
msgid ""
"This mimics the ``Traceback (most recent call last):`` which is used when "
"displaying exception frames."
msgstr ""
"これは、例外フレームを表示する場合に使用される ``Traceback (most recent call "
"last):`` を模倣します。"

#: ../../library/logging.rst:209
msgid ""
"The third optional keyword argument is *stacklevel*, which defaults to "
"``1``. If greater than 1, the corresponding number of stack frames are "
"skipped when computing the line number and function name set in the :class:"
"`LogRecord` created for the logging event. This can be used in logging "
"helpers so that the function name, filename and line number recorded are not "
"the information for the helper function/method, but rather its caller. The "
"name of this parameter mirrors the equivalent one in the :mod:`warnings` "
"module."
msgstr ""
"3番目のオプションキーワード引数は *stacklevel* で、デフォルトは ``1`` です。"
"もしこれが1よりも大きい場合は、 :class:`LogRecord` 内で行番号と関数名を算出す"
"る時に、指定されたスタックフレームの数をスキップします。これはログヘルパー内"
"部で使われる場合、関数名、ファイル名、行番号はそのヘルパーの情報ではなく、そ"
"のヘルパーを呼び出した呼び出し元のものになります。このパラメータの名前は :"
"mod:`warnings` モジュールと同じものになります。"

#: ../../library/logging.rst:217
msgid ""
"The fourth keyword argument is *extra* which can be used to pass a "
"dictionary which is used to populate the __dict__ of the :class:`LogRecord` "
"created for the logging event with user-defined attributes. These custom "
"attributes can then be used as you like. For example, they could be "
"incorporated into logged messages. For example::"
msgstr ""
"4番目のキーワード引数は *extra* で、当該ログイベント用に作られる :class:"
"`LogRecord` の __dict__ にユーザー定義属性を加えるのに使われる辞書を渡すため"
"に用いられます。これらの属性は好きなように使えます。たとえば、ログメッセージ"
"の一部にすることもできます。以下の例を見てください::"

#: ../../library/logging.rst:229
msgid "would print something like"
msgstr "これは以下のような出力を行います"

#: ../../library/logging.rst:235
msgid ""
"The keys in the dictionary passed in *extra* should not clash with the keys "
"used by the logging system. (See the section on :ref:`logrecord-attributes` "
"for more information on which keys are used by the logging system.)"
msgstr ""

#: ../../library/logging.rst:239
msgid ""
"If you choose to use these attributes in logged messages, you need to "
"exercise some care. In the above example, for instance, the :class:"
"`Formatter` has been set up with a format string which expects 'clientip' "
"and 'user' in the attribute dictionary of the :class:`LogRecord`. If these "
"are missing, the message will not be logged because a string formatting "
"exception will occur. So in this case, you always need to pass the *extra* "
"dictionary with these keys."
msgstr ""
"これらの属性をログメッセージに使うことにしたなら、少し注意が必要です。上の例"
"では、 'clientip' と 'user' が :class:`LogRecord` の属性辞書に含まれているこ"
"とを期待した書式文字列で :class:`Formatter` がセットアップされています。もし"
"これらが欠けていると、書式化例外が発生してしまうためメッセージはログに残りま"
"せん。したがってこの場合、常にこれらのキーを含む *extra* 辞書を渡す必要があり"
"ます。"

#: ../../library/logging.rst:246 ../../library/logging.rst:1114
msgid ""
"While this might be annoying, this feature is intended for use in "
"specialized circumstances, such as multi-threaded servers where the same "
"code executes in many contexts, and interesting conditions which arise are "
"dependent on this context (such as remote client IP address and "
"authenticated user name, in the above example). In such circumstances, it is "
"likely that specialized :class:`Formatter`\\ s would be used with "
"particular :class:`Handler`\\ s."
msgstr ""
"このようなことは煩わしいかもしれませんが、この機能は限定された場面で使われる"
"ように意図しているものなのです。たとえば同じコードがいくつものコンテキストで"
"実行されるマルチスレッドのサーバで、興味のある条件が現れるのがそのコンテキス"
"トに依存している (上の例で言えば、リモートのクライアント IP アドレスや認証さ"
"れたユーザ名など)、というような場合です。そういった場面では、それ用の :class:"
"`Formatter` が特定の :class:`Handler` と共に使われるというのはよくあることで"
"す。"

#: ../../library/logging.rst:253
msgid ""
"If no handler is attached to this logger (or any of its ancestors, taking "
"into account the relevant :attr:`Logger.propagate` attributes), the message "
"will be sent to the handler set on :attr:`lastResort`."
msgstr ""

#: ../../library/logging.rst:257 ../../library/logging.rst:1125
msgid "The *stack_info* parameter was added."
msgstr "*stack_info* パラメータが追加されました。"

#: ../../library/logging.rst:260
msgid "The *exc_info* parameter can now accept exception instances."
msgstr "*exc_info* パラメータは例外インスタンスを受け入れることが可能です。"

#: ../../library/logging.rst:263
msgid "The *stacklevel* parameter was added."
msgstr "*stacklevel* 引数が追加されました。"

#: ../../library/logging.rst:269
msgid ""
"Logs a message with level :const:`INFO` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr ""
"レベル :const:`INFO` のメッセージをこのロガーで記録します。引数は :meth:"
"`debug` と同じように解釈されます。"

#: ../../library/logging.rst:275
msgid ""
"Logs a message with level :const:`WARNING` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr ""
"レベル :const:`WARNING` のメッセージをこのロガーで記録します。引数は :meth:"
"`debug` と同じように解釈されます。"

#: ../../library/logging.rst:278
msgid ""
"There is an obsolete method ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""
"``warning`` と機能的に等価な古いメソッド ``warn`` があります。``warn`` は廃止"
"予定なので使わないでください - 代わりに ``warning`` を使ってください。"

#: ../../library/logging.rst:284
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr ""
"レベル :const:`ERROR` のメッセージをこのロガーで記録します。引数は :meth:"
"`debug` と同じように解釈されます。"

#: ../../library/logging.rst:290
msgid ""
"Logs a message with level :const:`CRITICAL` on this logger. The arguments "
"are interpreted as for :meth:`debug`."
msgstr ""
"レベル :const:`CRITICAL` のメッセージをこのロガーで記録します。引数は :meth:"
"`debug` と同じように解釈されます。"

#: ../../library/logging.rst:296
msgid ""
"Logs a message with integer level *level* on this logger. The other "
"arguments are interpreted as for :meth:`debug`."
msgstr ""
"整数で表したレベル *level* のメッセージをこのロガーで記録します。その他の引数"
"は :meth:`debug` と同じように解釈されます。"

#: ../../library/logging.rst:302
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments are "
"interpreted as for :meth:`debug`. Exception info is added to the logging "
"message. This method should only be called from an exception handler."
msgstr ""
"レベル :const:`ERROR` のメッセージをこのロガーで記録します。引数は :meth:"
"`debug` と同じように解釈されます。例外情報がログメッセージに追加されます。こ"
"のメソッドは例外ハンドラからのみ呼び出されるべきです。"

#: ../../library/logging.rst:309
msgid "Adds the specified filter *filter* to this logger."
msgstr "指定されたフィルタ *filter* をこのロガーに追加します。"

#: ../../library/logging.rst:314
msgid "Removes the specified filter *filter* from this logger."
msgstr "指定されたフィルタ *filter* をこのロガーから取り除きます。"

#: ../../library/logging.rst:319
msgid ""
"Apply this logger's filters to the record and return ``True`` if the record "
"is to be processed. The filters are consulted in turn, until one of them "
"returns a false value. If none of them return a false value, the record will "
"be processed (passed to handlers). If one returns a false value, no further "
"processing of the record occurs."
msgstr ""
"レコードに対してこのロガーのフィルタを適用し、レコードが処理されるべき場合に "
"``True`` を返します。フィルタのいずれかの値が偽を返すまで、それらは順番に試さ"
"れていきます。いずれも偽を返さなければ、レコードは処理される(ハンドラに渡され"
"る)ことになります。ひとつでも偽を返せば、発生したレコードはもはや処理されるこ"
"とはありません。"

#: ../../library/logging.rst:328
msgid "Adds the specified handler *hdlr* to this logger."
msgstr "指定されたハンドラ *hdlr* をこのロガーに追加します。"

#: ../../library/logging.rst:333
msgid "Removes the specified handler *hdlr* from this logger."
msgstr "指定されたハンドラ *hdlr* をこのロガーから取り除きます。"

#: ../../library/logging.rst:338
msgid ""
"Finds the caller's source filename and line number. Returns the filename, "
"line number, function name and stack information as a 4-element tuple. The "
"stack information is returned as ``None`` unless *stack_info* is ``True``."
msgstr ""
"呼び出し元のソースファイル名と行番号を調べます。ファイル名と行番号、関数名、"
"スタック情報を 4 要素のタプルで返します。*stack_info* が ``True`` でなけれ"
"ば、スタック情報は ``None`` が返されます。"

#: ../../library/logging.rst:342
msgid ""
"The *stacklevel* parameter is passed from code calling the :meth:`debug` and "
"other APIs. If greater than 1, the excess is used to skip stack frames "
"before determining the values to be returned. This will generally be useful "
"when calling logging APIs from helper/wrapper code, so that the information "
"in the event log refers not to the helper/wrapper code, but to the code that "
"calls it."
msgstr ""
"*stacklevel* パラメータは :meth:`debug` や他のAPIを呼び出すコードから渡されま"
"す。もしこれが1よりも大きい場合は、その超過分は返す値を決定する前にスタックフ"
"レームをスキップする数として利用されます。これは通常、ログAPIをヘルパーやラッ"
"パー経由で呼び出す場合に便利です。こうすることで、イベントログに記録される情"
"報はヘルパーやラッパーのコードではなく、それらを呼び出しているコードのものと"
"なります。"

#: ../../library/logging.rst:352
msgid ""
"Handles a record by passing it to all handlers associated with this logger "
"and its ancestors (until a false value of *propagate* is found). This method "
"is used for unpickled records received from a socket, as well as those "
"created locally. Logger-level filtering is applied using :meth:`~Logger."
"filter`."
msgstr ""
"レコードを、このロガーおよびその上位ロガー (ただし *propagate* の値が false "
"になったところまで) に関連付けられているすべてのハンドラに渡して処理します。"
"このメソッドは、ローカルで生成されたレコードだけでなく、ソケットから受信した "
"unpickle されたレコードに対しても同様に用いられます。 :meth:`~Logger.filter` "
"によって、ロガーレベルでのフィルタが適用されます。"

#: ../../library/logging.rst:360
msgid ""
"This is a factory method which can be overridden in subclasses to create "
"specialized :class:`LogRecord` instances."
msgstr ""
"このメソッドは、特殊な :class:`LogRecord` インスタンスを生成するためにサブク"
"ラスでオーバライドできるファクトリメソッドです。"

#: ../../library/logging.rst:365
msgid ""
"Checks to see if this logger has any handlers configured. This is done by "
"looking for handlers in this logger and its parents in the logger hierarchy. "
"Returns ``True`` if a handler was found, else ``False``. The method stops "
"searching up the hierarchy whenever a logger with the 'propagate' attribute "
"set to false is found - that will be the last logger which is checked for "
"the existence of handlers."
msgstr ""
"このロガーにハンドラが設定されているかどうかを調べます。\n"
"そのために、このロガーとロガー階層におけるその祖先についてハンドラ探していき"
"ます。\n"
"ハンドラが見つかれば ``True`` 、そうでなければ ``False`` を返します。\n"
"このメソッドは、'propagate' 属性が偽に設定されたロガーを見つけると、さらに上"
"位の探索をやめます - そのロガーが、ハンドラが存在するかどうかチェックされる最"
"後のロガー、という意味です。"

#: ../../library/logging.rst:374
msgid "Loggers can now be pickled and unpickled."
msgstr "ロガーの pickle 化と unpickle 化ができるようになりました。"

#: ../../library/logging.rst:380
msgid "Logging Levels"
msgstr "ロギングレベル"

#: ../../library/logging.rst:382
msgid ""
"The numeric values of logging levels are given in the following table. These "
"are primarily of interest if you want to define your own levels, and need "
"them to have specific values relative to the predefined levels. If you "
"define a level with the same numeric value, it overwrites the predefined "
"value; the predefined name is lost."
msgstr ""
"ログレベルの数値は以下の表のように与えられています。これらは基本的に自分でレ"
"ベルを定義したい人のためのもので、定義するレベルを既存のレベルの間に位置づけ"
"るためには具体的な値が必要になります。もし数値が他のレベルと同じだったら、既"
"存の値は上書きされその名前は失われます。"

#: ../../library/logging.rst:389
msgid "Level"
msgstr "レベル"

#: ../../library/logging.rst:389
msgid "Numeric value"
msgstr "数値"

#: ../../library/logging.rst:391
msgid "``CRITICAL``"
msgstr "``CRITICAL``"

#: ../../library/logging.rst:391
msgid "50"
msgstr "50"

#: ../../library/logging.rst:393
msgid "``ERROR``"
msgstr "``ERROR``"

#: ../../library/logging.rst:393
msgid "40"
msgstr "40"

#: ../../library/logging.rst:395
msgid "``WARNING``"
msgstr "``WARNING``"

#: ../../library/logging.rst:395
msgid "30"
msgstr "30"

#: ../../library/logging.rst:397
msgid "``INFO``"
msgstr "``INFO``"

#: ../../library/logging.rst:397
msgid "20"
msgstr "20"

#: ../../library/logging.rst:399
msgid "``DEBUG``"
msgstr "``DEBUG``"

#: ../../library/logging.rst:399
msgid "10"
msgstr "10"

#: ../../library/logging.rst:401
msgid "``NOTSET``"
msgstr "``NOTSET``"

#: ../../library/logging.rst:401
msgid "0"
msgstr "0"

#: ../../library/logging.rst:408
msgid "Handler Objects"
msgstr "ハンドラオブジェクト"

#: ../../library/logging.rst:410
msgid ""
"Handlers have the following attributes and methods. Note that :class:"
"`Handler` is never instantiated directly; this class acts as a base for more "
"useful subclasses. However, the :meth:`__init__` method in subclasses needs "
"to call :meth:`Handler.__init__`."
msgstr ""
"ハンドラ (Handler) は以下の属性とメソッドを持ちます。 :class:`Handler` は直接"
"インスタンス化されることはありません; このクラスはより便利なサブクラスの基底"
"クラスとして働きます。しかしながら、サブクラスにおける :meth:`__init__` メ"
"ソッドでは、 :meth:`Handler.__init__` を呼び出す必要があります。"

#: ../../library/logging.rst:419
msgid ""
"Initializes the :class:`Handler` instance by setting its level, setting the "
"list of filters to the empty list and creating a lock (using :meth:"
"`createLock`) for serializing access to an I/O mechanism."
msgstr ""
"レベルを設定して、 :class:`Handler` インスタンスを初期化します。空のリストを"
"使ってフィルタを設定し、 I/O 機構へのアクセスを直列化するために (:meth:"
"`createLock` を使って) ロックを生成します。"

#: ../../library/logging.rst:426
msgid ""
"Initializes a thread lock which can be used to serialize access to "
"underlying I/O functionality which may not be threadsafe."
msgstr ""
"スレッドセーフでない背後の I/O 機能に対するアクセスを直列化するために用いられ"
"るスレッドロック (thread lock) を初期化します。"

#: ../../library/logging.rst:432
msgid "Acquires the thread lock created with :meth:`createLock`."
msgstr ":meth:`createLock` で生成されたスレッドロックを獲得します。"

#: ../../library/logging.rst:437
msgid "Releases the thread lock acquired with :meth:`acquire`."
msgstr ":meth:`acquire` で獲得したスレッドロックを解放します。"

#: ../../library/logging.rst:442
msgid ""
"Sets the threshold for this handler to *level*. Logging messages which are "
"less severe than *level* will be ignored. When a handler is created, the "
"level is set to :const:`NOTSET` (which causes all messages to be processed)."
msgstr ""
"このハンドラに対する閾値を *level* に設定します。\n"
"*level* よりも深刻でないログメッセージは無視されます。\n"
"ハンドラが生成された際、レベルは :const:`NOTSET` (すべてのメッセージが処理さ"
"れる) に設定されます。"

#: ../../library/logging.rst:449
msgid ""
"The *level* parameter now accepts a string representation of the level such "
"as 'INFO' as an alternative to the integer constants such as :const:`INFO`."
msgstr ""
"*level* パラメータは、 :const:`INFO` のような整数定数の代わりに 'INFO' のよう"
"なレベルの文字列表現も受け付けるようになりました。"

#: ../../library/logging.rst:457
msgid "Sets the :class:`Formatter` for this handler to *fmt*."
msgstr "このハンドラのフォーマッタを *fmt* に設定します。"

#: ../../library/logging.rst:462
msgid "Adds the specified filter *filter* to this handler."
msgstr "指定されたフィルタ *filter* をこのハンドラに追加します。"

#: ../../library/logging.rst:467
msgid "Removes the specified filter *filter* from this handler."
msgstr "指定されたフィルタ *filter* をこのハンドラから除去します。"

#: ../../library/logging.rst:472
msgid ""
"Apply this handler's filters to the record and return ``True`` if the record "
"is to be processed. The filters are consulted in turn, until one of them "
"returns a false value. If none of them return a false value, the record will "
"be emitted. If one returns a false value, the handler will not emit the "
"record."
msgstr ""
"レコードに対してこのハンドラのフィルタを適用し、レコードが処理されるべき場合"
"に ``True`` を返します。フィルタのいずれかの値が偽を返すまで、それらは順番に"
"試されていきます。いずれも偽を返さなければ、レコードは発行されることになりま"
"す。ひとつでも偽を返せば、ハンドラはレコードを発行しません。"

#: ../../library/logging.rst:481
msgid ""
"Ensure all logging output has been flushed. This version does nothing and is "
"intended to be implemented by subclasses."
msgstr ""
"すべてのログ出力がフラッシュされるようにします。このクラスのバージョンではな"
"にも行わず、サブクラスで実装するためのものです。"

#: ../../library/logging.rst:487
msgid ""
"Tidy up any resources used by the handler. This version does no output but "
"removes the handler from an internal list of handlers which is closed when :"
"func:`shutdown` is called. Subclasses should ensure that this gets called "
"from overridden :meth:`close` methods."
msgstr ""
"ハンドラで使われているすべてのリソースの後始末を行います。このバージョンでは"
"何も出力せず、 :func:`shutdown` が呼ばれたときに閉じられたハンドラを内部リス"
"トから削除します。サブクラスではオーバライドされた :meth:`close` メソッドから"
"このメソッドが必ず呼ばれるようにしてください。"

#: ../../library/logging.rst:495
msgid ""
"Conditionally emits the specified logging record, depending on filters which "
"may have been added to the handler. Wraps the actual emission of the record "
"with acquisition/release of the I/O thread lock."
msgstr ""
"ハンドラに追加されたフィルタの条件に応じて、指定されたログレコードを出力しま"
"す。このメソッドは I/O スレッドロックの獲得/解放を伴う実際のログ出力をラップ"
"します。"

#: ../../library/logging.rst:502
msgid ""
"This method should be called from handlers when an exception is encountered "
"during an :meth:`emit` call. If the module-level attribute "
"``raiseExceptions`` is ``False``, exceptions get silently ignored. This is "
"what is mostly wanted for a logging system - most users will not care about "
"errors in the logging system, they are more interested in application "
"errors. You could, however, replace this with a custom handler if you wish. "
"The specified record is the one which was being processed when the exception "
"occurred. (The default value of ``raiseExceptions`` is ``True``, as that is "
"more useful during development)."
msgstr ""
"このメソッドは :meth:`emit` の呼び出し中に例外に遭遇した際にハンドラから呼び"
"出されます。モジュールレベル属性 ``raiseExceptions`` が ``False`` の場合、例"
"外は暗黙のまま無視されます。ほとんどの場合、これがロギングシステムの望ましい"
"動作です - というのは、ほとんどのユーザはロギングシステム自体のエラーは気にせ"
"ず、むしろアプリケーションのエラーに興味があるからです。しかしながら、望むな"
"らこのメソッドを自作のハンドラと置き換えることもできます。 *record* には、例"
"外発生時に処理されていたレコードが入ります。 (*raiseExceptions* のデフォルト"
"値は ``True`` です。これは開発中はその方が便利だからです)。"

#: ../../library/logging.rst:515
msgid ""
"Do formatting for a record - if a formatter is set, use it. Otherwise, use "
"the default formatter for the module."
msgstr ""
"レコードに対する書式化を行います - フォーマッタが設定されていれば、それを使い"
"ます。そうでない場合、モジュールにデフォルト指定されたフォーマッタを使いま"
"す。"

#: ../../library/logging.rst:521
msgid ""
"Do whatever it takes to actually log the specified logging record. This "
"version is intended to be implemented by subclasses and so raises a :exc:"
"`NotImplementedError`."
msgstr ""
"指定されたログ記録レコードを実際にログ記録する際のすべての処理を行います。こ"
"のメソッドはサブクラスで実装されることを意図しており、そのためこのクラスの"
"バージョンは :exc:`NotImplementedError` を送出します。"

#: ../../library/logging.rst:525
msgid ""
"This method is called after a handler-level lock is acquired, which is "
"released after this method returns. When you override this method, note that "
"you should be careful when calling anything that invokes other parts of the "
"logging API which might do locking, because that might result in a deadlock. "
"Specifically:"
msgstr ""

#: ../../library/logging.rst:531
msgid ""
"Logging configuration APIs acquire the module-level lock, and then "
"individual handler-level locks as those handlers are configured."
msgstr ""

#: ../../library/logging.rst:534
msgid ""
"Many logging APIs lock the module-level lock. If such an API is called from "
"this method, it could cause a deadlock if a configuration call is made on "
"another thread, because that thread will try to acquire the module-level "
"lock *before* the handler-level lock, whereas this thread tries to acquire "
"the module-level lock *after* the handler-level lock (because in this "
"method, the handler-level lock has already been acquired)."
msgstr ""

#: ../../library/logging.rst:541
msgid ""
"For a list of handlers included as standard, see :mod:`logging.handlers`."
msgstr ""
"標準として含まれているハンドラについては、 :mod:`logging.handlers` を参照して"
"ください。"

#: ../../library/logging.rst:546
msgid "Formatter Objects"
msgstr "フォーマッタオブジェクト"

#: ../../library/logging.rst:550
msgid ""
":class:`Formatter` objects have the following attributes and methods. They "
"are responsible for converting a :class:`LogRecord` to (usually) a string "
"which can be interpreted by either a human or an external system. The base :"
"class:`Formatter` allows a formatting string to be specified. If none is "
"supplied, the default value of ``'%(message)s'`` is used, which just "
"includes the message in the logging call. To have additional items of "
"information in the formatted output (such as a timestamp), keep reading."
msgstr ""
":class:`Formatter` オブジェクトは以下の属性とメソッドを持っています。 :class:"
"`Formatter` は :class:`LogRecord` を (通常は) 人間か外部のシステムで解釈でき"
"る文字列に変換する役割を担っています。基底クラスの :class:`Formatter` では書"
"式文字列を指定することができます。何も指定されなかった場合、ロギングコール中"
"のメッセージ以外の情報だけを持つ ``'%(message)s'`` の値が使われます。フォー"
"マットされた出力に情報の要素 (タイムスタンプなど) を追加したいなら、このまま"
"読み進めてください。"

#: ../../library/logging.rst:558
msgid ""
"A Formatter can be initialized with a format string which makes use of "
"knowledge of the :class:`LogRecord` attributes - such as the default value "
"mentioned above making use of the fact that the user's message and arguments "
"are pre-formatted into a :class:`LogRecord`'s *message* attribute.  This "
"format string contains standard Python %-style mapping keys. See section :"
"ref:`old-string-formatting` for more information on string formatting."
msgstr ""
"Formatter は :class:`LogRecord` 属性の知識を利用できるような書式文字列を用い"
"て初期化することができます。例えば、上で言及したデフォルト値では、ユーザによ"
"るメッセージと引数はあらかじめフォーマットされて、 :class:`LogRecord` の "
"*message* 属性に入っていることを利用しています。この書式文字列は、 Python 標"
"準の % を使った変換文字列で構成されます。文字列整形に関する詳細は :ref:`old-"
"string-formatting` を参照してください。"

#: ../../library/logging.rst:565
msgid ""
"The useful mapping keys in a :class:`LogRecord` are given in the section on :"
"ref:`logrecord-attributes`."
msgstr ""
":class:`LogRecord` の便利なマッピングキーは、 :ref:`logrecord-attributes` の"
"節で与えられます。"

#: ../../library/logging.rst:571
msgid ""
"Returns a new instance of the :class:`Formatter` class.  The instance is "
"initialized with a format string for the message as a whole, as well as a "
"format string for the date/time portion of a message.  If no *fmt* is "
"specified, ``'%(message)s'`` is used.  If no *datefmt* is specified, a "
"format is used which is described in the :meth:`formatTime` documentation."
msgstr ""
":class:`Formatter` クラスの新たなインスタンスを返します。インスタンスは全体と"
"してのメッセージに対する書式文字列と、メッセージの日付/時刻部分のための書式文"
"字列を伴って初期化されます。 *fmt* が指定されない場合、 ``'%(message)s'`` が"
"使われます。 *datefmt* が指定されない場合、 :meth:`formatTime` ドキュメントで"
"解説されている書式が使われます。"

#: ../../library/logging.rst:577
msgid ""
"The *style* parameter can be one of '%', '{' or '$' and determines how the "
"format string will be merged with its data: using one of %-formatting, :meth:"
"`str.format` or :class:`string.Template`. This only applies to the format "
"string *fmt* (e.g. ``'%(message)s'`` or ``{message}``), not to the actual "
"log messages passed to ``Logger.debug`` etc; see :ref:`formatting-styles` "
"for more information on using {- and $-formatting for log messages."
msgstr ""
"*style* パラメータは '%',  '{', '$' のうちのいずれかで、書式文字列がどのよう"
"にデータとマージされるかを決めます: %-format 、 :meth:`str.format` 、 :class:"
"`string.Template` のうちのどれかが使用されます。この引数は *fmt* のフォーマッ"
"ト文字列（例えば ``'%(message)s'`` や ``{message}`` ）にのみ適用され、 "
"``Logger.debug`` などに渡される実際のログメッセージには現れることはありませ"
"ん。ログメッセージに使用する { および $ 形式のフォーマットの情報は :ref:"
"`formatting-styles` を参照してください。"

#: ../../library/logging.rst:585
msgid ""
"The *defaults* parameter can be a dictionary with default values to use in "
"custom fields. For example: ``logging.Formatter('%(ip)s %(message)s', "
"defaults={\"ip\": None})``"
msgstr ""
"*defaults* パラメーターはカスタムフィールドとして使用されるデフォルトの値で"
"す。例: ``logging.Formatter('%(ip)s %(message)s', defaults={\"ip\": None})``"

#: ../../library/logging.rst:589
msgid "The *style* parameter was added."
msgstr "*style* パラメータが追加されました。"

#: ../../library/logging.rst:592
msgid ""
"The *validate* parameter was added. Incorrect or mismatched style and fmt "
"will raise a ``ValueError``. For example: ``logging.Formatter('%(asctime)s - "
"%(message)s', style='{')``."
msgstr ""
"*validate* パラメータが追加されました。styleとfmtが不正だったりミスマッチ"
"だっった場合に ``ValueError`` を送出します。例: ``logging."
"Formatter('%(asctime)s - %(message)s', style='{')`` 。"

#: ../../library/logging.rst:597
msgid "The *defaults* parameter was added."
msgstr "*defaults* パラメータが追加されました。"

#: ../../library/logging.rst:602
msgid ""
"The record's attribute dictionary is used as the operand to a string "
"formatting operation. Returns the resulting string. Before formatting the "
"dictionary, a couple of preparatory steps are carried out. The *message* "
"attribute of the record is computed using *msg* % *args*. If the formatting "
"string contains ``'(asctime)'``, :meth:`formatTime` is called to format the "
"event time. If there is exception information, it is formatted using :meth:"
"`formatException` and appended to the message. Note that the formatted "
"exception information is cached in attribute *exc_text*. This is useful "
"because the exception information can be pickled and sent across the wire, "
"but you should be careful if you have more than one :class:`Formatter` "
"subclass which customizes the formatting of exception information. In this "
"case, you will have to clear the cached value (by setting the *exc_text* "
"attribute to ``None``) after a formatter has done its formatting, so that "
"the next formatter to handle the event doesn't use the cached value, but "
"recalculates it afresh."
msgstr ""
"レコードの属性辞書が、文字列を書式化する演算で被演算子として使われます。書式"
"化された結果の文字列を返します。辞書を書式化する前に、二つの準備段階を経ま"
"す。レコードの *message* 属性が *msg* % *args* を使って処理されます。書式化さ"
"れた文字列が ``'(asctime)'`` を含むなら、 :meth:`formatTime` が呼び出され、イ"
"ベントの発生時刻を書式化します。例外情報が存在する場合、 :meth:"
"`formatException` を使って書式化され、メッセージに追加されます。ここで注意し"
"ていただきたいのは、書式化された例外情報は *exc_text* にキャッシュされるとい"
"う点です。これが有用なのは例外情報がピックル化されて回線上を送ることができる"
"からですが、しかし二つ以上の :class:`Formatter` サブクラスで例外情報の書式化"
"をカスタマイズしている場合には注意が必要になります。この場合、フォーマッタが"
"書式化を終えるごとにキャッシュをクリアして（ *ext_text* 属性に ``None`` を設"
"定して）、次のフォーマッタがキャッシュされた値を使わずに新鮮な状態で再計算す"
"るようにしなければならないことになります。"

#: ../../library/logging.rst:618
msgid ""
"If stack information is available, it's appended after the exception "
"information, using :meth:`formatStack` to transform it if necessary."
msgstr ""
"スタック情報が利用可能な場合、(必要ならば :meth:`formatStack` を使って整形し"
"た上で) スタック情報が例外情報の後に追加されます。"

#: ../../library/logging.rst:624
msgid ""
"This method should be called from :meth:`format` by a formatter which wants "
"to make use of a formatted time. This method can be overridden in formatters "
"to provide for any specific requirement, but the basic behavior is as "
"follows: if *datefmt* (a string) is specified, it is used with :func:`time."
"strftime` to format the creation time of the record. Otherwise, the format "
"'%Y-%m-%d %H:%M:%S,uuu' is used, where the uuu part is a millisecond value "
"and the other letters are as per the :func:`time.strftime` documentation.  "
"An example time in this format is ``2003-01-23 00:29:50,411``.  The "
"resulting string is returned."
msgstr ""
"このメソッドは、フォーマッタが書式化された時間を利用したい際に、 :meth:"
"`format` から呼び出されます。\n"
"このメソッドは特定の要求を提供するためにフォーマッタで上書きすることができま"
"すが、基本的な振る舞いは以下のようになります: *datefmt* (文字列) が指定された"
"場合、レコードが生成された時刻を書式化するために :func:`time.strftime` で使わ"
"れます。\n"
"そうでない場合、 '%Y-%m-%d %H:%M:%S,uuu' というフォーマットが使われます。 "
"uuu 部分はミリ秒値で、それ以外の文字は :func:`time.strftime` ドキュメントに従"
"います。\n"
"このフォーマットの時刻の例は ``2003-01-23 00:29:50,411`` です。\n"
"結果の文字列が返されます。"

#: ../../library/logging.rst:634
msgid ""
"This function uses a user-configurable function to convert the creation time "
"to a tuple. By default, :func:`time.localtime` is used; to change this for a "
"particular formatter instance, set the ``converter`` attribute to a function "
"with the same signature as :func:`time.localtime` or :func:`time.gmtime`. To "
"change it for all formatters, for example if you want all logging times to "
"be shown in GMT, set the ``converter`` attribute in the ``Formatter`` class."
msgstr ""
"この関数は、ユーザが設定できる関数を使って、生成時刻をタプルに変換します。デ"
"フォルトでは、 :func:`time.localtime` が使われます。特定のフォーマッタインス"
"タンスに対してこれを変更するには、 ``converter`` 属性を :func:`time."
"localtime` や :func:`time.gmtime` と同じ署名をもつ関数に設定してください。す"
"べてのフォーマッタインスタンスに対してこれを変更するには、例えば全てのロギン"
"グ時刻を GMT で表示するには、 ``Formatter`` クラスの ``converter`` 属性を設定"
"してください。"

#: ../../library/logging.rst:642
msgid ""
"Previously, the default format was hard-coded as in this example: "
"``2010-09-06 22:38:15,292`` where the part before the comma is handled by a "
"strptime format string (``'%Y-%m-%d %H:%M:%S'``), and the part after the "
"comma is a millisecond value. Because strptime does not have a format "
"placeholder for milliseconds, the millisecond value is appended using "
"another format string, ``'%s,%03d'`` --- and both of these format strings "
"have been hardcoded into this method. With the change, these strings are "
"defined as class-level attributes which can be overridden at the instance "
"level when desired. The names of the attributes are ``default_time_format`` "
"(for the strptime format string) and ``default_msec_format`` (for appending "
"the millisecond value)."
msgstr ""
"以前は、デフォルトのフォーマットがこの例のようにハードコーディングされていま"
"した: ``2010-09-06 22:38:15,292`` ここで、コンマの前の部分は strptime フォー"
"マット文字列 (``'%Y-%m-%d %H:%M:%S'``) によって扱われる部分で、コンマの後の部"
"分はミリ秒値です。strptime にミリ秒のフォーマットプレースホルダーがないので、"
"ミリ秒値は別のフォーマット文字列 ``'%s,%03d'`` を使用して追加されます。そし"
"て、これらのフォーマット文字列は両方ともこのメソッドでハードコーディングされ"
"ていました。変更後は、これらの文字列はクラスレベル属性として定義され、必要な"
"らインスタンスレベルでオーバーライドすることができます。属性の名前は "
"``default_time_format`` (strptime 書式文字列用) と ``default_msec_format`` "
"(ミリ秒値の追加用) です。"

#: ../../library/logging.rst:655
msgid "The ``default_msec_format`` can be ``None``."
msgstr "``default_msec_format`` 引数が ``None`` であることを許容します。"

#: ../../library/logging.rst:660
msgid ""
"Formats the specified exception information (a standard exception tuple as "
"returned by :func:`sys.exc_info`) as a string. This default implementation "
"just uses :func:`traceback.print_exception`. The resulting string is "
"returned."
msgstr ""
"指定された例外情報 (:func:`sys.exc_info` が返すような標準例外のタプル) を文字"
"列として書式化します。デフォルトの実装は単に :func:`traceback."
"print_exception` を使います。結果の文字列が返されます。"

#: ../../library/logging.rst:667
msgid ""
"Formats the specified stack information (a string as returned by :func:"
"`traceback.print_stack`, but with the last newline removed) as a string. "
"This default implementation just returns the input value."
msgstr ""
"指定されたスタック情報を文字列としてフォーマットします (:func:`traceback."
"print_stack` によって返される文字列ですが、最後の改行が取り除かれています)。"
"このデフォルト実装は、単に入力値をそのまま返します。"

#: ../../library/logging.rst:673
msgid ""
"A base formatter class suitable for subclassing when you want to format a "
"number of records. You can pass a :class:`Formatter` instance which you want "
"to use to format each line (that corresponds to a single record). If not "
"specified, the default formatter (which just outputs the event message) is "
"used as the line formatter."
msgstr ""

#: ../../library/logging.rst:681
msgid ""
"Return a header for a list of *records*. The base implementation just "
"returns the empty string. You will need to override this method if you want "
"specific behaviour, e.g. to show the count of records, a title or a "
"separator line."
msgstr ""

#: ../../library/logging.rst:688
msgid ""
"Return a footer for a list of *records*. The base implementation just "
"returns the empty string. You will need to override this method if you want "
"specific behaviour, e.g. to show the count of records or a separator line."
msgstr ""

#: ../../library/logging.rst:695
msgid ""
"Return formatted text for a list of *records*. The base implementation just "
"returns the empty string if there are no records; otherwise, it returns the "
"concatenation of the header, each record formatted with the line formatter, "
"and the footer."
msgstr ""

#: ../../library/logging.rst:703
msgid "Filter Objects"
msgstr "フィルタオブジェクト"

#: ../../library/logging.rst:705
msgid ""
"``Filters`` can be used by ``Handlers`` and ``Loggers`` for more "
"sophisticated filtering than is provided by levels. The base filter class "
"only allows events which are below a certain point in the logger hierarchy. "
"For example, a filter initialized with 'A.B' will allow events logged by "
"loggers 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' etc. but not 'A.BB', 'B.A.B' etc. "
"If initialized with the empty string, all events are passed."
msgstr ""
"``フィルタ (Filter)`` は、``ハンドラ`` や ``ロガー`` によって使われ、レベルに"
"よって提供されるのよりも洗練されたフィルタリングを実現します。基底のフィルタ"
"クラスは、ロガー階層構造内の特定地点の配下にあるイベントだけを許可します。例"
"えば、'A.B' で初期化されたフィルタは、ロガー 'A.B', 'A.B.C', 'A.B.C.D', 'A.B."
"D' 等によって記録されたイベントは許可しますが、'A.BB', 'B.A.B' などは許可しま"
"せん。空の文字列で初期化された場合、すべてのイベントを通過させます。"

#: ../../library/logging.rst:715
msgid ""
"Returns an instance of the :class:`Filter` class. If *name* is specified, it "
"names a logger which, together with its children, will have its events "
"allowed through the filter. If *name* is the empty string, allows every "
"event."
msgstr ""
":class:`Filter` クラスのインスタンスを返します。 *name* が指定されていれば、 "
"*name* はロガーの名前を表します。指定されたロガーとその子ロガーのイベントが"
"フィルタを通過できるようになります。 *name* が指定されなければ、すべてのイベ"
"ントを通過させます。"

#: ../../library/logging.rst:722
msgid ""
"Is the specified record to be logged? Returns zero for no, nonzero for yes. "
"If deemed appropriate, the record may be modified in-place by this method."
msgstr ""
"指定されたレコードがログされるべきか？no ならばばゼロを、yes ならばゼロでない"
"値を返します。適切と判断されれば、このメソッドによってレコードはその場で修正"
"されることがあります。"

#: ../../library/logging.rst:726
msgid ""
"Note that filters attached to handlers are consulted before an event is "
"emitted by the handler, whereas filters attached to loggers are consulted "
"whenever an event is logged (using :meth:`debug`, :meth:`info`, etc.), "
"before sending an event to handlers. This means that events which have been "
"generated by descendant loggers will not be filtered by a logger's filter "
"setting, unless the filter has also been applied to those descendant loggers."
msgstr ""
"ハンドラに対するフィルタはハンドラがイベントを発行する前に試され、一方ではロ"
"ガーに対するフィルタは、イベントが(:meth:`debug`, :meth:`info` などによって)"
"ロギングされる際には、ハンドラにイベントが送信される前にはいつでも試されるこ"
"とに注意してください。そのフィルタがそれら子孫ロガーにも適用されていない限"
"り、子孫ロガーによって生成されたイベントはロガーのフィルタ設定によってフィル"
"タされることはありません。"

#: ../../library/logging.rst:733
msgid ""
"You don't actually need to subclass ``Filter``: you can pass any instance "
"which has a ``filter`` method with the same semantics."
msgstr ""
"実際には、``Filter`` をサブクラス化する必要はありません。同じ意味の "
"``filter`` メソッドを持つ、すべてのインスタンスを通せます。"

#: ../../library/logging.rst:736
msgid ""
"You don't need to create specialized ``Filter`` classes, or use other "
"classes with a ``filter`` method: you can use a function (or other callable) "
"as a filter. The filtering logic will check to see if the filter object has "
"a ``filter`` attribute: if it does, it's assumed to be a ``Filter`` and its :"
"meth:`~Filter.filter` method is called. Otherwise, it's assumed to be a "
"callable and called with the record as the single parameter. The returned "
"value should conform to that returned by :meth:`~Filter.filter`."
msgstr ""
"特殊な ``Filter`` クラスを作ったり、 ``filter`` メソッドを持つ他のクラスを使"
"う必要はありません: 関数 (あるいは他の callable) をフィルタとして使用すること"
"ができます。フィルタロジックは、フィルタオブジェクトが ``filter`` 属性を持っ"
"ているかどうかチェックします: もし ``filter`` 属性を持っていたら、それは "
"``Filter`` であると仮定され、その :meth:`~Filter.filter` メソッドが呼び出され"
"ます。そうでなければ、それは callable であると仮定され、レコードを単一のパラ"
"メータとして呼び出されます。返される値は :meth:`~Filter.filter` によって返さ"
"れるものと一致すべきです。"

#: ../../library/logging.rst:746
msgid ""
"Although filters are used primarily to filter records based on more "
"sophisticated criteria than levels, they get to see every record which is "
"processed by the handler or logger they're attached to: this can be useful "
"if you want to do things like counting how many records were processed by a "
"particular logger or handler, or adding, changing or removing attributes in "
"the :class:`LogRecord` being processed. Obviously changing the LogRecord "
"needs to be done with some care, but it does allow the injection of "
"contextual information into logs (see :ref:`filters-contextual`)."
msgstr ""
"フィルタは本来、レコードをレベルよりも洗練された基準に基づいてフィルタするた"
"めに使われますが、それが取り付けられたハンドラやロガーによって処理されるレ"
"コードをすべて監視します。これは、特定のロガーやハンドラに処理されたレコード"
"の数を数えたり、処理されている :class:`LogRecord` の属性を追加、変更、削除し"
"たりするときに便利です。もちろん、LogRecord を変更するには注意が必要ですが、"
"これにより、ログにコンテキスト情報を注入できます (:ref:`filters-contextual` "
"を参照してください)。"

#: ../../library/logging.rst:759
msgid "LogRecord Objects"
msgstr "LogRecord オブジェクト"

#: ../../library/logging.rst:761
msgid ""
":class:`LogRecord` instances are created automatically by the :class:"
"`Logger` every time something is logged, and can be created manually via :"
"func:`makeLogRecord` (for example, from a pickled event received over the "
"wire)."
msgstr ""
":class:`LogRecord` インスタンスは、何かをログ記録するたびに :class:`Logger` "
"によって生成されます。また、 :func:`makeLogRecord` を通して (例えば、ワイヤを"
"通して受け取られた pickle 化されたイベントから) 手動で生成することも出来ま"
"す。"

#: ../../library/logging.rst:769
msgid "Contains all the information pertinent to the event being logged."
msgstr "ロギングされているイベントに適切なすべての情報を含みます。"

#: ../../library/logging.rst:771
msgid ""
"The primary information is passed in *msg* and *args*, which are combined "
"using ``msg % args`` to create the :attr:`!message` attribute of the record."
msgstr ""

#: ../../library/logging.rst:0
msgid "Parameters"
msgstr "パラメーター"

#: ../../library/logging.rst:775
msgid ""
"The name of the logger used to log the event represented by this :class:`!"
"LogRecord`. Note that the logger name in the :class:`!LogRecord` will always "
"have this value, even though it may be emitted by a handler attached to a "
"different (ancestor) logger."
msgstr ""

#: ../../library/logging.rst:783
msgid ""
"The :ref:`numeric level <levels>` of the logging event (such as ``10`` for "
"``DEBUG``, ``20`` for ``INFO``, etc). Note that this is converted to *two* "
"attributes of the LogRecord: :attr:`!levelno` for the numeric value and :"
"attr:`!levelname` for the corresponding level name."
msgstr ""

#: ../../library/logging.rst:790
msgid ""
"The full string path of the source file where the logging call was made."
msgstr ""

#: ../../library/logging.rst:794
msgid "The line number in the source file where the logging call was made."
msgstr "ロギングの呼び出しが発せられたソース行番号。"

#: ../../library/logging.rst:798
msgid ""
"The event description message, which can be a %-format string with "
"placeholders for variable data."
msgstr ""

#: ../../library/logging.rst:802
msgid ""
"Variable data to merge into the *msg* argument to obtain the event "
"description."
msgstr "*msg* 引数と組み合わせてイベント記述を得るための変数データです。"

#: ../../library/logging.rst:806
msgid ""
"An exception tuple with the current exception information, as returned by :"
"func:`sys.exc_info`, or ``None`` if no exception information is available."
msgstr ""

#: ../../library/logging.rst:811
msgid ""
"The name of the function or method from which the logging call was invoked."
msgstr "ロギングの呼び出しを行った関数またはメソッドの名前です。"

#: ../../library/logging.rst:815
msgid ""
"A text string representing stack information from the base of the stack in "
"the current thread, up to the logging call."
msgstr ""
"現在のスレッドのスタックベースからログ呼び出しまでの間のスタック情報を表わす"
"テキスト文字列。"

#: ../../library/logging.rst:822
msgid ""
"Returns the message for this :class:`LogRecord` instance after merging any "
"user-supplied arguments with the message. If the user-supplied message "
"argument to the logging call is not a string, :func:`str` is called on it to "
"convert it to a string. This allows use of user-defined classes as messages, "
"whose ``__str__`` method can return the actual format string to be used."
msgstr ""
"ユーザが提供した引数をメッセージに交ぜた後、この :class:`LogRecord` インスタ"
"ンスへのメッセージを返します。ユーザがロギングの呼び出しに与えた引数が文字列"
"でなければ、その引数に :func:`str` が呼ばれ、文字列に変換されます。これによ"
"り、 ``__str__`` メソッドが実際のフォーマット文字列を返せるようなユーザ定義の"
"クラスをメッセージとして使えます。"

#: ../../library/logging.rst:829
msgid ""
"The creation of a :class:`LogRecord` has been made more configurable by "
"providing a factory which is used to create the record. The factory can be "
"set using :func:`getLogRecordFactory` and :func:`setLogRecordFactory` (see "
"this for the factory's signature)."
msgstr ""
":class:`LogRecord` の生成は、レコードを生成するために使用されるファクトリを提"
"供することにより、さらに設定可能になりました。ファクトリは :func:"
"`getLogRecordFactory` と :func:`setLogRecordFactory` を使用して設定することが"
"できます (ファクトリのシグネチャに関しては :func:`setLogRecordFactory` を参"
"照)。"

#: ../../library/logging.rst:835
msgid ""
"This functionality can be used to inject your own values into a :class:"
"`LogRecord` at creation time. You can use the following pattern::"
msgstr ""
"この機能を使うと :class:`LogRecord` の生成時に独自の値を注入することができま"
"す。次のパターンが使えます::"

#: ../../library/logging.rst:847
msgid ""
"With this pattern, multiple factories could be chained, and as long as they "
"don't overwrite each other's attributes or unintentionally overwrite the "
"standard attributes listed above, there should be no surprises."
msgstr ""
"このパターンでは複数のファクトリをつなぐこともできます。それらが互いの属性を"
"上書きしたりせず、また上にリストされた標準属性を意図せず上書きしたりしない限"
"り、驚くようなことは何も起こりません (there should be no surprises)。"

#: ../../library/logging.rst:856
msgid "LogRecord attributes"
msgstr "LogRecord 属性"

#: ../../library/logging.rst:858
msgid ""
"The LogRecord has a number of attributes, most of which are derived from the "
"parameters to the constructor. (Note that the names do not always correspond "
"exactly between the LogRecord constructor parameters and the LogRecord "
"attributes.) These attributes can be used to merge data from the record into "
"the format string. The following table lists (in alphabetical order) the "
"attribute names, their meanings and the corresponding placeholder in a %-"
"style format string."
msgstr ""
"LogRecord には幾つかの属性があり、そのほとんどはコンストラクタの引数から得ら"
"れます。(なお、LogRecord コンストラクタの引数と LogRecord 属性が常に厳密に対"
"応するわけではありません。) これらの属性は、レコードからのデータをフォーマッ"
"ト文字列に統合するのに使えます。以下のテーブルに、属性名、意味、そして % 形式"
"フォーマット文字列における対応するプレースホルダを (アルファベット順に) 列挙"
"します。"

#: ../../library/logging.rst:866
msgid ""
"If you are using {}-formatting (:func:`str.format`), you can use ``{attrname}"
"`` as the placeholder in the format string. If you are using $-formatting (:"
"class:`string.Template`), use the form ``${attrname}``. In both cases, of "
"course, replace ``attrname`` with the actual attribute name you want to use."
msgstr ""
"{}-フォーマット (:func:`str.format`) を使用していれば、書式文字列の中でプレー"
"スホールダーとして ``{attrname}`` を使うことができます。 $-フォーマット (:"
"class:`string.Template`) を使用している場合は、 ``${attrname}`` 形式にしてく"
"ださい。もちろん、両方の場合で ``attrname`` は使用したい実際の属性名に置き換"
"えてください。"

#: ../../library/logging.rst:872
msgid ""
"In the case of {}-formatting, you can specify formatting flags by placing "
"them after the attribute name, separated from it with a colon. For example: "
"a placeholder of ``{msecs:03d}`` would format a millisecond value of ``4`` "
"as ``004``. Refer to the :meth:`str.format` documentation for full details "
"on the options available to you."
msgstr ""
"{}-フォーマットの場合には、属性名の後にフォーマットフラグを指定することができ"
"ます。属性名とフォーマットフラグの間はコロンで分割します。例: プレースホール"
"ダー ``{msecs:03d}`` は、ミリセカンド値 ``4`` を ``004`` としてフォーマットし"
"ます。利用可能なオプション上の全詳細に関しては :meth:`str.format` ドキュメン"
"テーションを参照してください。"

#: ../../library/logging.rst:879
msgid "Attribute name"
msgstr "属性名"

#: ../../library/logging.rst:879 ../../library/logging.rst:1262
msgid "Format"
msgstr "フォーマット"

#: ../../library/logging.rst:879 ../../library/logging.rst:1262
msgid "Description"
msgstr "説明"

#: ../../library/logging.rst:881 ../../library/logging.rst:0
msgid "args"
msgstr "``args``"

#: ../../library/logging.rst:881 ../../library/logging.rst:895
#: ../../library/logging.rst:923 ../../library/logging.rst:941
msgid "You shouldn't need to format this yourself."
msgstr "このフォーマットを自分で使う必要はないでしょう。"

#: ../../library/logging.rst:881
msgid ""
"The tuple of arguments merged into ``msg`` to produce ``message``, or a dict "
"whose values are used for the merge (when there is only one argument, and it "
"is a dictionary)."
msgstr ""
"``msg`` に組み合わせて ``message`` を生成するための引数のタプル、または、マー"
"ジに用いられる辞書(引数が一つしかなく、かつそれが辞書の場合)。"

#: ../../library/logging.rst:886
msgid "asctime"
msgstr "asctime"

#: ../../library/logging.rst:886
msgid "``%(asctime)s``"
msgstr "``%(asctime)s``"

#: ../../library/logging.rst:886
msgid ""
"Human-readable time when the :class:`LogRecord` was created.  By default "
"this is of the form '2003-07-08 16:49:45,896' (the numbers after the comma "
"are millisecond portion of the time)."
msgstr ""
":class:`LogRecord` が生成された時刻を人間が読める書式で表したもの。デフォルト"
"では \"2003-07-08 16:49:45,896\" 形式 (コンマ以降の数字は時刻のミリ秒部分) で"
"す。"

#: ../../library/logging.rst:892
msgid "created"
msgstr "created"

#: ../../library/logging.rst:892
msgid "``%(created)f``"
msgstr "``%(created)f``"

#: ../../library/logging.rst:892
msgid ""
"Time when the :class:`LogRecord` was created (as returned by :func:`time."
"time`)."
msgstr ""
":class:`LogRecord` が生成された時刻 (:func:`time.time` によって返される形式"
"で)。"

#: ../../library/logging.rst:895 ../../library/logging.rst:0
msgid "exc_info"
msgstr "exc_info"

#: ../../library/logging.rst:895
msgid ""
"Exception tuple (à la ``sys.exc_info``) or, if no exception has occurred, "
"``None``."
msgstr ""
"(``sys.exc_info`` 風の) 例外タプルか、例外が起こっていない場合は ``None``。"

#: ../../library/logging.rst:898
msgid "filename"
msgstr "ファイル名"

#: ../../library/logging.rst:898
msgid "``%(filename)s``"
msgstr "``%(filename)s``"

#: ../../library/logging.rst:898
msgid "Filename portion of ``pathname``."
msgstr "``pathname`` のファイル名部分。"

#: ../../library/logging.rst:900
msgid "funcName"
msgstr "funcName"

#: ../../library/logging.rst:900
msgid "``%(funcName)s``"
msgstr "``%(funcName)s``"

#: ../../library/logging.rst:900
msgid "Name of function containing the logging call."
msgstr "ロギングの呼び出しを含む関数の名前。"

#: ../../library/logging.rst:902
msgid "levelname"
msgstr "levelname"

#: ../../library/logging.rst:902
msgid "``%(levelname)s``"
msgstr "``%(levelname)s``"

#: ../../library/logging.rst:902
msgid ""
"Text logging level for the message (``'DEBUG'``, ``'INFO'``, ``'WARNING'``, "
"``'ERROR'``, ``'CRITICAL'``)."
msgstr ""
"メッセージのための文字のロギングレベル (``'DEBUG'``, ``'INFO'``, "
"``'WARNING'``, ``'ERROR'``, ``'CRITICAL'``)。"

#: ../../library/logging.rst:906
msgid "levelno"
msgstr "levelno"

#: ../../library/logging.rst:906
msgid "``%(levelno)s``"
msgstr "``%(levelno)s``"

#: ../../library/logging.rst:906
msgid ""
"Numeric logging level for the message (:const:`DEBUG`, :const:`INFO`, :const:"
"`WARNING`, :const:`ERROR`, :const:`CRITICAL`)."
msgstr ""
"メッセージのための数値のロギングレベル (:const:`DEBUG`, :const:`INFO`, :"
"const:`WARNING`, :const:`ERROR`, :const:`CRITICAL`)。"

#: ../../library/logging.rst:911
msgid "lineno"
msgstr "lineno"

#: ../../library/logging.rst:911
msgid "``%(lineno)d``"
msgstr "``%(lineno)d``"

#: ../../library/logging.rst:911
msgid "Source line number where the logging call was issued (if available)."
msgstr "ロギングの呼び出しが発せられたソース行番号 (利用できる場合のみ)。"

#: ../../library/logging.rst:914
msgid "message"
msgstr "message"

#: ../../library/logging.rst:914
msgid "``%(message)s``"
msgstr "``%(message)s``"

#: ../../library/logging.rst:914
msgid ""
"The logged message, computed as ``msg % args``. This is set when :meth:"
"`Formatter.format` is invoked."
msgstr ""
"``msg % args`` として求められた、ログメッセージ。 :meth:`Formatter.format` が"
"呼び出されたときに設定されます。"

#: ../../library/logging.rst:918
msgid "module"
msgstr "module"

#: ../../library/logging.rst:918
msgid "``%(module)s``"
msgstr "``%(module)s``"

#: ../../library/logging.rst:918
msgid "Module (name portion of ``filename``)."
msgstr "モジュール (``filename`` の名前部分)。"

#: ../../library/logging.rst:920
msgid "msecs"
msgstr "msecs"

#: ../../library/logging.rst:920
msgid "``%(msecs)d``"
msgstr "``%(msecs)d``"

#: ../../library/logging.rst:920
msgid ""
"Millisecond portion of the time when the :class:`LogRecord` was created."
msgstr ":class:`LogRecord` が生成された時刻のミリ秒部分。"

#: ../../library/logging.rst:923 ../../library/logging.rst:0
msgid "msg"
msgstr "msg"

#: ../../library/logging.rst:923
msgid ""
"The format string passed in the original logging call. Merged with ``args`` "
"to produce ``message``, or an arbitrary object (see :ref:`arbitrary-object-"
"messages`)."
msgstr ""
"元のロギングの呼び出しで渡されたフォーマット文字列。 ``args`` と合わせて、 "
"``message`` 、または任意のオブジェクトを生成します (:ref:`arbitrary-object-"
"messages` 参照)。"

#: ../../library/logging.rst:928 ../../library/logging.rst:0
msgid "name"
msgstr "name"

#: ../../library/logging.rst:928
msgid "``%(name)s``"
msgstr "``%(name)s``"

#: ../../library/logging.rst:928
msgid "Name of the logger used to log the call."
msgstr "ロギングに使われたロガーの名前。"

#: ../../library/logging.rst:930
msgid "pathname"
msgstr "pathname"

#: ../../library/logging.rst:930
msgid "``%(pathname)s``"
msgstr "``%(pathname)s``"

#: ../../library/logging.rst:930
msgid ""
"Full pathname of the source file where the logging call was issued (if "
"available)."
msgstr ""
"ロギングの呼び出しが発せられたファイルの完全なパス名 (利用できる場合のみ)。"

#: ../../library/logging.rst:933
msgid "process"
msgstr "process"

#: ../../library/logging.rst:933
msgid "``%(process)d``"
msgstr "``%(process)d``"

#: ../../library/logging.rst:933
msgid "Process ID (if available)."
msgstr "プロセス ID (利用可能な場合のみ)。"

#: ../../library/logging.rst:935
msgid "processName"
msgstr "processName"

#: ../../library/logging.rst:935
msgid "``%(processName)s``"
msgstr "``%(processName)s``"

#: ../../library/logging.rst:935
msgid "Process name (if available)."
msgstr "プロセス名 (利用可能な場合のみ)。"

#: ../../library/logging.rst:937
msgid "relativeCreated"
msgstr "relativeCreated"

#: ../../library/logging.rst:937
msgid "``%(relativeCreated)d``"
msgstr "``%(relativeCreated)d``"

#: ../../library/logging.rst:937
msgid ""
"Time in milliseconds when the LogRecord was created, relative to the time "
"the logging module was loaded."
msgstr ""
"logging モジュールが読み込まれた時刻に対する、LogRecord が生成された時刻を、"
"ミリ秒で表したもの。"

#: ../../library/logging.rst:941
msgid "stack_info"
msgstr "stack_info"

#: ../../library/logging.rst:941
msgid ""
"Stack frame information (where available) from the bottom of the stack in "
"the current thread, up to and including the stack frame of the logging call "
"which resulted in the creation of this record."
msgstr ""
"現在のスレッドでのスタックの底からこのレコードの生成に帰着したログ呼び出しま"
"でのスタックフレーム情報 (利用可能な場合)。"

#: ../../library/logging.rst:947
msgid "thread"
msgstr "thread"

#: ../../library/logging.rst:947
msgid "``%(thread)d``"
msgstr "``%(thread)d``"

#: ../../library/logging.rst:947
msgid "Thread ID (if available)."
msgstr "スレッド ID (利用可能な場合のみ)。"

#: ../../library/logging.rst:949
msgid "threadName"
msgstr "threadName"

#: ../../library/logging.rst:949
msgid "``%(threadName)s``"
msgstr "``%(threadName)s``"

#: ../../library/logging.rst:949
msgid "Thread name (if available)."
msgstr "スレッド名 (利用可能な場合のみ)。"

#: ../../library/logging.rst:952
msgid "*processName* was added."
msgstr "*processName* が追加されました。"

#: ../../library/logging.rst:959
msgid "LoggerAdapter Objects"
msgstr "LoggerAdapter オブジェクト"

#: ../../library/logging.rst:961
msgid ""
":class:`LoggerAdapter` instances are used to conveniently pass contextual "
"information into logging calls. For a usage example, see the section on :ref:"
"`adding contextual information to your logging output <context-info>`."
msgstr ""
":class:`LoggerAdapter` インスタンスは文脈情報をログ記録呼び出しに渡すのを簡単"
"にするために使われます。使い方の例は :ref:`コンテキスト情報をログ記録出力に付"
"加する <context-info>` を参照してください。"

#: ../../library/logging.rst:967
msgid ""
"Returns an instance of :class:`LoggerAdapter` initialized with an "
"underlying :class:`Logger` instance and a dict-like object."
msgstr ""
"内部で使う :class:`Logger` インスタンスと辞書風 (dict-like) オブジェクトで初"
"期化した :class:`LoggerAdapter` のインスタンスを返します。"

#: ../../library/logging.rst:972
msgid ""
"Modifies the message and/or keyword arguments passed to a logging call in "
"order to insert contextual information. This implementation takes the object "
"passed as *extra* to the constructor and adds it to *kwargs* using key "
"'extra'. The return value is a (*msg*, *kwargs*) tuple which has the "
"(possibly modified) versions of the arguments passed in."
msgstr ""
"文脈情報を挿入するために、ログ記録呼び出しに渡されたメッセージおよび/または"
"キーワード引数に変更を加えます。ここでの実装は *extra* としてコンストラクタに"
"渡されたオブジェクトを取り、'extra' キーを使って *kwargs* に加えます。返り値"
"は (*msg*, *kwargs*) というタプルで、(変更されているはずの) 渡された引数を含"
"みます。"

#: ../../library/logging.rst:978
msgid ""
"In addition to the above, :class:`LoggerAdapter` supports the following "
"methods of :class:`Logger`: :meth:`~Logger.debug`, :meth:`~Logger.info`, :"
"meth:`~Logger.warning`, :meth:`~Logger.error`, :meth:`~Logger.exception`, :"
"meth:`~Logger.critical`, :meth:`~Logger.log`, :meth:`~Logger.isEnabledFor`, :"
"meth:`~Logger.getEffectiveLevel`, :meth:`~Logger.setLevel` and :meth:"
"`~Logger.hasHandlers`. These methods have the same signatures as their "
"counterparts in :class:`Logger`, so you can use the two types of instances "
"interchangeably."
msgstr ""
":class:`LoggerAdapter` は上記に加え :class:`Logger` のメソッド :meth:"
"`~Logger.debug`, :meth:`~Logger.info`, :meth:`~Logger.warning`, :meth:"
"`~Logger.error`, :meth:`~Logger.exception`, :meth:`~Logger.critical`, :meth:"
"`~Logger.log`, :meth:`~Logger.isEnabledFor`, :meth:`~Logger."
"getEffectiveLevel`, :meth:`~Logger.setLevel`, :meth:`~Logger.hasHandlers` を"
"サポートします。これらは :class:`Logger` の対応するメソッドと同じシグニチャを"
"持つため、2つのインスタンスは区別せずに利用出来ます。"

#: ../../library/logging.rst:987
msgid ""
"The :meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, :meth:"
"`~Logger.setLevel` and :meth:`~Logger.hasHandlers` methods were added to :"
"class:`LoggerAdapter`.  These methods delegate to the underlying logger."
msgstr ""
":meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, :meth:"
"`~Logger.setLevel`, :meth:`~Logger.hasHandlers` が :class:`LoggerAdapter` に"
"追加されました。これらメソッドは元のロガーに処理を委譲します。"

#: ../../library/logging.rst:992
msgid ""
"Attribute :attr:`manager` and method :meth:`_log` were added, which delegate "
"to the underlying logger and allow adapters to be nested."
msgstr ""
"基底のロガーに移譲し、アダプターをネストできるようにするために :attr:"
"`manager` 属性と :meth:`_log` メソッドが追加されました。"

#: ../../library/logging.rst:998
msgid "Thread Safety"
msgstr "スレッドセーフ性"

#: ../../library/logging.rst:1000
msgid ""
"The logging module is intended to be thread-safe without any special work "
"needing to be done by its clients. It achieves this though using threading "
"locks; there is one lock to serialize access to the module's shared data, "
"and each handler also creates a lock to serialize access to its underlying I/"
"O."
msgstr ""
"logging モジュールは、クライアントで特殊な作業を必要としない限りスレッドセー"
"フになっています。このスレッドセーフ性はスレッドロックによって達成されていま"
"す; モジュールの共有データへのアクセスを直列化するためのロックが一つ存在し、"
"各ハンドラでも背後にある I/O へのアクセスを直列化するためにロックを生成しま"
"す。"

#: ../../library/logging.rst:1005
msgid ""
"If you are implementing asynchronous signal handlers using the :mod:`signal` "
"module, you may not be able to use logging from within such handlers. This "
"is because lock implementations in the :mod:`threading` module are not "
"always re-entrant, and so cannot be invoked from such signal handlers."
msgstr ""
":mod:`signal` モジュールを使用して非同期シグナルハンドラを実装している場合、"
"そのようなハンドラからはログ記録を使用できないかもしれません。これは、 :mod:"
"`threading` モジュールにおけるロック実装が常にリエントラントではなく、そのよ"
"うなシグナルハンドラから呼び出すことができないからです。"

#: ../../library/logging.rst:1012
msgid "Module-Level Functions"
msgstr "モジュールレベルの関数"

#: ../../library/logging.rst:1014
msgid ""
"In addition to the classes described above, there are a number of module-"
"level functions."
msgstr ""
"上で述べたクラスに加えて、いくつかのモジュールレベルの関数が存在します。"

#: ../../library/logging.rst:1020
msgid ""
"Return a logger with the specified name or, if name is ``None``, return a "
"logger which is the root logger of the hierarchy. If specified, the name is "
"typically a dot-separated hierarchical name like *'a'*, *'a.b'* or *'a.b.c."
"d'*. Choice of these names is entirely up to the developer who is using "
"logging."
msgstr ""
"指定された名前のロガーを返します。名前が ``None`` であれば、ロガー階層のルー"
"ト (root) にあるロガーを返します。*name* を指定する場合には、通常は *'a'*, "
"*'a.b'*, *'a.b.c.d'* といったドット区切りの階層的な名前にします。名前の付け方"
"はログ機能を使う開発者次第です。"

#: ../../library/logging.rst:1025
msgid ""
"All calls to this function with a given name return the same logger "
"instance. This means that logger instances never need to be passed between "
"different parts of an application."
msgstr ""
"与えられた名前に対して、この関数はどの呼び出しでも同じロガーインスタンスを返"
"します。したがって、ロガーインスタンスをアプリケーションの各部でやりとりする"
"必要はありません。"

#: ../../library/logging.rst:1032
msgid ""
"Return either the standard :class:`Logger` class, or the last class passed "
"to :func:`setLoggerClass`. This function may be called from within a new "
"class definition, to ensure that installing a customized :class:`Logger` "
"class will not undo customizations already applied by other code. For "
"example::"
msgstr ""
"標準の :class:`Logger` クラスか、最後に :func:`setLoggerClass` に渡したクラス"
"を返します。この関数は、新たなクラス定義の中で呼び出して、カスタマイズした :"
"class:`Logger` クラスのインストールが既に他のコードで適用したカスタマイズを取"
"り消さないことを保証するために使われることがあります。例えば以下のようにしま"
"す::"

#: ../../library/logging.rst:1043
msgid "Return a callable which is used to create a :class:`LogRecord`."
msgstr ":class:`LogRecord` を生成するのに使われる callable を返します。"

#: ../../library/logging.rst:1045
msgid ""
"This function has been provided, along with :func:`setLogRecordFactory`, to "
"allow developers more control over how the :class:`LogRecord` representing a "
"logging event is constructed."
msgstr ""
"この関数は、ログイベントを表現する :class:`LogRecord` の構築方法に関して開発"
"者により多くのコントロールを与えるため、 :func:`setLogRecordFactory` とともに"
"提供されました。"

#: ../../library/logging.rst:1050
msgid ""
"See :func:`setLogRecordFactory` for more information about the how the "
"factory is called."
msgstr ""
"このファクトリがどのように呼ばれるかに関する詳細は :func:"
"`setLogRecordFactory` を参照してください。"

#: ../../library/logging.rst:1055
msgid ""
"Logs a message with level :const:`DEBUG` on the root logger. The *msg* is "
"the message format string, and the *args* are the arguments which are merged "
"into *msg* using the string formatting operator. (Note that this means that "
"you can use keywords in the format string, together with a single dictionary "
"argument.)"
msgstr ""
"レベル :const:`DEBUG` のメッセージをルートロガーで記録します。 *msg* はメッ"
"セージの書式文字列で、 *args* は *msg* に文字列書式化演算子を使って取り込むた"
"めの引数です。 (これは、書式文字列の中でキーワードを使い、引数として単一の辞"
"書を渡すことができる、ということを意味します。)"

#: ../../library/logging.rst:1060
msgid ""
"There are three keyword arguments in *kwargs* which are inspected: "
"*exc_info* which, if it does not evaluate as false, causes exception "
"information to be added to the logging message. If an exception tuple (in "
"the format returned by :func:`sys.exc_info`) or an exception instance is "
"provided, it is used; otherwise, :func:`sys.exc_info` is called to get the "
"exception information."
msgstr ""
"キーワード引数 *kwargs* からは 3 つのキーワードが調べられます。一つ目は "
"*exc_info* で、この値の評価値が false でない場合、例外情報をログメッセージに"
"追加します。 (:func:`sys.exc_info` の返す形式の) 例外情報を表すタプルや例外イ"
"ンスタンスが与えられていれば、それをメッセージに使います。それ以外の場合に"
"は、 :func:`sys.exc_info` を呼び出して例外情報を取得します。"

#: ../../library/logging.rst:1086
msgid ""
"The third optional keyword argument is *extra* which can be used to pass a "
"dictionary which is used to populate the __dict__ of the LogRecord created "
"for the logging event with user-defined attributes. These custom attributes "
"can then be used as you like. For example, they could be incorporated into "
"logged messages. For example::"
msgstr ""
"3番目のキーワード引数は *extra* で、当該ログイベント用に作られる LogRecoed "
"の __dict__ にユーザー定義属性を加えるのに使われる辞書を渡すために用いられま"
"す。これらの属性は好きなように使えます。たとえば、ログメッセージの一部にする"
"こともできます。以下の例を見てください::"

#: ../../library/logging.rst:1097
msgid "would print something like:"
msgstr "これは以下のような出力を行います:"

#: ../../library/logging.rst:1103
msgid ""
"The keys in the dictionary passed in *extra* should not clash with the keys "
"used by the logging system. (See the :class:`Formatter` documentation for "
"more information on which keys are used by the logging system.)"
msgstr ""
"*extra* で渡される辞書のキーはロギングシステムで使われているものと衝突しない"
"ようにしなければなりません。 (どのキーがロギングシステムで使われているかにつ"
"いての詳細は :class:`Formatter` のドキュメントを参照してください。)"

#: ../../library/logging.rst:1107
msgid ""
"If you choose to use these attributes in logged messages, you need to "
"exercise some care. In the above example, for instance, the :class:"
"`Formatter` has been set up with a format string which expects 'clientip' "
"and 'user' in the attribute dictionary of the LogRecord. If these are "
"missing, the message will not be logged because a string formatting "
"exception will occur. So in this case, you always need to pass the *extra* "
"dictionary with these keys."
msgstr ""
"これらの属性をログメッセージに使うことにしたなら、少し注意が必要です。上の例"
"では、 'clientip' と 'user' が LogRecord の属性辞書に含まれていることを期待し"
"た書式文字列で :class:`Formatter` がセットアップされています。もしこれらが欠"
"けていると、書式化例外が発生してしまうためメッセージはログに残りません。した"
"がってこの場合、常にこれらのキーを含む *extra* 辞書を渡す必要があります。"

#: ../../library/logging.rst:1121
msgid ""
"This function (as well as :func:`info`, :func:`warning`, :func:`error` and :"
"func:`critical`) will call :func:`basicConfig` if the root logger doesn't "
"have any handler attached."
msgstr ""

#: ../../library/logging.rst:1130
msgid ""
"Logs a message with level :const:`INFO` on the root logger. The arguments "
"are interpreted as for :func:`debug`."
msgstr ""
"レベル :const:`INFO` のメッセージをルートロガーで記録します。引数は :func:"
"`debug` と同じように解釈されます。"

#: ../../library/logging.rst:1136
msgid ""
"Logs a message with level :const:`WARNING` on the root logger. The arguments "
"are interpreted as for :func:`debug`."
msgstr ""
"レベル :const:`WARNING` のメッセージをルートロガーで記録します。引数は :func:"
"`debug` と同じように解釈されます。"

#: ../../library/logging.rst:1139
msgid ""
"There is an obsolete function ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""
"``warning`` と機能的に等価な古い関数 ``warn`` があります。``warn`` は廃止予定"
"なので使わないでください - 代わりに ``warning`` を使ってください。"

#: ../../library/logging.rst:1146
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The arguments "
"are interpreted as for :func:`debug`."
msgstr ""
"レベル :const:`ERROR` のメッセージをルートロガーで記録します。引数は :func:"
"`debug` と同じように解釈されます。"

#: ../../library/logging.rst:1152
msgid ""
"Logs a message with level :const:`CRITICAL` on the root logger. The "
"arguments are interpreted as for :func:`debug`."
msgstr ""
"レベル :const:`CRITICAL` のメッセージをルートロガーで記録します。引数は :"
"func:`debug` と同じように解釈されます。"

#: ../../library/logging.rst:1158
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The arguments "
"are interpreted as for :func:`debug`. Exception info is added to the logging "
"message. This function should only be called from an exception handler."
msgstr ""
"レベル :const:`ERROR` のメッセージをルートロガーで記録します。引数は :func:"
"`debug` と同じように解釈されます。例外情報がログメッセージに追加されます。こ"
"のメソッドは例外ハンドラからのみ呼び出されます。"

#: ../../library/logging.rst:1164
msgid ""
"Logs a message with level *level* on the root logger. The other arguments "
"are interpreted as for :func:`debug`."
msgstr ""
"レベル *level* のメッセージをルートロガーで記録します。その他の引数は :func:"
"`debug` と同じように解釈されます。"

#: ../../library/logging.rst:1169
msgid ""
"Provides an overriding level *level* for all loggers which takes precedence "
"over the logger's own level. When the need arises to temporarily throttle "
"logging output down across the whole application, this function can be "
"useful. Its effect is to disable all logging calls of severity *level* and "
"below, so that if you call it with a value of INFO, then all INFO and DEBUG "
"events would be discarded, whereas those of severity WARNING and above would "
"be processed according to the logger's effective level. If ``logging."
"disable(logging.NOTSET)`` is called, it effectively removes this overriding "
"level, so that logging output again depends on the effective levels of "
"individual loggers."
msgstr ""
"全てのロガーのレベル *level* を上書きし、これはロガー自身の出力レベルよりも優"
"先されます。アプリケーション全体を横断するログ出力を一時的に調整する必要が生"
"じたら、この関数は便利でしょう。これの効果は重大度 *level* 以下の全てのロギン"
"グ呼び出しを無効にすることですので、INFO で呼び出しをすれば、INFO と DEBUG イ"
"ベントが捨てられる一方で、重大度 WARNING 以上のものは、ロガーの有効レベルに基"
"いて処理されます。 ``logging.disable(logging.NOTSET)`` が呼び出されると、この"
"上書きレベルは削除され、ログ出力は再び個々のロガーの有効レベルに依存するよう"
"になります。"

#: ../../library/logging.rst:1180
msgid ""
"Note that if you have defined any custom logging level higher than "
"``CRITICAL`` (this is not recommended), you won't be able to rely on the "
"default value for the *level* parameter, but will have to explicitly supply "
"a suitable value."
msgstr ""
"``CRITICAL`` より高い独自のログレベル (これは推奨されません) を定義した場合"
"は、 *level* 引数のデフォルト値を当てにできなくなり、適切な値を明示的に与える"
"必要があります。"

#: ../../library/logging.rst:1185
msgid ""
"The *level* parameter was defaulted to level ``CRITICAL``. See :issue:"
"`28524` for more information about this change."
msgstr ""
"*level* 引数のデフォルトが ``CRITICAL`` レベルになりました。この変更について"
"のより詳しいことは :issue:`28524` を参照してください。"

#: ../../library/logging.rst:1191
msgid ""
"Associates level *level* with text *levelName* in an internal dictionary, "
"which is used to map numeric levels to a textual representation, for example "
"when a :class:`Formatter` formats a message. This function can also be used "
"to define your own levels. The only constraints are that all levels used "
"must be registered using this function, levels should be positive integers "
"and they should increase in increasing order of severity."
msgstr ""
"内部的な辞書の中でレベル *level* をテキスト *levelName* に関連付けます。これ"
"は例えば :class:`Formatter` でメッセージを書式化する際のように、数字のレベル"
"をテキスト表現に対応付ける際に用いられます。この関数は自作のレベルを定義する"
"ために使うこともできます。使われるレベルに対する唯一の制限は、レベルは正の整"
"数でなくてはならず、メッセージの深刻度が上がるに従ってレベルの数も上がらなく"
"てはならないということです。"

#: ../../library/logging.rst:1198
msgid ""
"If you are thinking of defining your own levels, please see the section on :"
"ref:`custom-levels`."
msgstr ""
"独自のレベルを定義したい場合、 :ref:`custom-levels` のセクションを参照してく"
"ださい。"

#: ../../library/logging.rst:1203
msgid "Returns the textual or numeric representation of logging level *level*."
msgstr "テキストまたは数値表現でログレベル *level* を返してください。"

#: ../../library/logging.rst:1205
msgid ""
"If *level* is one of the predefined levels :const:`CRITICAL`, :const:"
"`ERROR`, :const:`WARNING`, :const:`INFO` or :const:`DEBUG` then you get the "
"corresponding string. If you have associated levels with names using :func:"
"`addLevelName` then the name you have associated with *level* is returned. "
"If a numeric value corresponding to one of the defined levels is passed in, "
"the corresponding string representation is returned."
msgstr ""
"*level* が定義済みのレベル :const:`CRITICAL`, :const:`ERROR`, :const:"
"`WARNING`, :const:`INFO`, :const:`DEBUG` のいずれかである場合、対応する文字列"
"が返されます。 :func:`addLevelName` を使ってレベルに名前を関連付けていた場"
"合、 *level* に関連付けられた名前が返されます。定義済みのレベルに対応する数値"
"を指定した場合、レベルに対応した文字列表現を返します。"

#: ../../library/logging.rst:1212
msgid ""
"The *level* parameter also accepts a string representation of the level such "
"as 'INFO'. In such cases, this functions returns the corresponding numeric "
"value of the level."
msgstr ""
"*level* パラメータは、 :const:`INFO` のような整数定数の代わりに 'INFO' のよう"
"なレベルの文字列表現も受け付けます。この場合、この関数は関連するレベルの数値"
"表現を返します。"

#: ../../library/logging.rst:1216
msgid ""
"If no matching numeric or string value is passed in, the string 'Level %s' % "
"level is returned."
msgstr ""
"もし渡された数値や文字列がマッチしなければ、 'Level %s' % level が返されま"
"す。"

#: ../../library/logging.rst:1219
msgid ""
"Levels are internally integers (as they need to be compared in the logging "
"logic). This function is used to convert between an integer level and the "
"level name displayed in the formatted log output by means of the "
"``%(levelname)s`` format specifier (see :ref:`logrecord-attributes`), and "
"vice versa."
msgstr ""
"レベルは内部的には整数です(これはロギングのロジックが大小比較をする必要がある"
"からです)。この関数は、数値のレベルを、書式記述子 ``%(levelname)s`` (:ref:"
"`logrecord-attributes` 参照)によって書式化されるログ出力の表示用レベル名に変"
"換するなどの用途に使用されます。"

#: ../../library/logging.rst:1225
msgid ""
"In Python versions earlier than 3.4, this function could also be passed a "
"text level, and would return the corresponding numeric value of the level. "
"This undocumented behaviour was considered a mistake, and was removed in "
"Python 3.4, but reinstated in 3.4.2 due to retain backward compatibility."
msgstr ""
"Python 3.4以前のバージョンでは、この関数にはテキストのレベルも渡すことが出"
"来、これは対応する数字レベルに読み替えられていました。このドキュメントされて"
"いなかった振る舞いは誤りであると判断され、Python 3.4 で一度削除されました。た"
"だし後方互換性のために、これは 3.4.2 で元に戻されました。"

#: ../../library/logging.rst:1233
msgid ""
"Creates and returns a new :class:`LogRecord` instance whose attributes are "
"defined by *attrdict*. This function is useful for taking a pickled :class:"
"`LogRecord` attribute dictionary, sent over a socket, and reconstituting it "
"as a :class:`LogRecord` instance at the receiving end."
msgstr ""
"属性が *attrdict* で定義された、新しい :class:`LogRecord` インスタンスを生成"
"して返します。この関数は、 pickle された :class:`LogRecord` 属性の辞書をソ"
"ケットを介して送信し、受信端で :class:`LogRecord` インスタンスとして再構成す"
"る場合に便利です。"

#: ../../library/logging.rst:1241
msgid ""
"Does basic configuration for the logging system by creating a :class:"
"`StreamHandler` with a default :class:`Formatter` and adding it to the root "
"logger. The functions :func:`debug`, :func:`info`, :func:`warning`, :func:"
"`error` and :func:`critical` will call :func:`basicConfig` automatically if "
"no handlers are defined for the root logger."
msgstr ""
"デフォルトの :class:`Formatter` を持つ :class:`StreamHandler` を生成してルー"
"トロガーに追加し、ロギングシステムの基本的な環境設定を行います。関数 :func:"
"`debug`, :func:`info`, :func:`warning`, :func:`error`, :func:`critical` は、"
"ルートロガーにハンドラが定義されていない場合に自動的に :func:`basicConfig` を"
"呼び出します。"

#: ../../library/logging.rst:1247
msgid ""
"This function does nothing if the root logger already has handlers "
"configured, unless the keyword argument *force* is set to ``True``."
msgstr ""
"この関数は *force* キーワード引数に ``True`` が設定されない限り、ルートロガー"
"に設定されたハンドラがあれば何もしません。"

#: ../../library/logging.rst:1250
msgid ""
"This function should be called from the main thread before other threads are "
"started. In versions of Python prior to 2.7.1 and 3.2, if this function is "
"called from multiple threads, it is possible (in rare circumstances) that a "
"handler will be added to the root logger more than once, leading to "
"unexpected results such as messages being duplicated in the log."
msgstr ""
"この関数は、他のスレッドが開始される前にメインスレッドから呼び出されるべきで"
"す。Python の 2.7.1 や 3.2 以前のバージョンでは、この関数が複数のスレッドから"
"呼ばれると(珍しい状況下とはいえ)ハンドラがルートロガーに複数回加えられること"
"があり、ログ内のメッセージが重複するという予期しない結果をもたらすことがあり"
"ます。"

#: ../../library/logging.rst:1257
msgid "The following keyword arguments are supported."
msgstr "以下のキーワード引数がサポートされます。"

#: ../../library/logging.rst:1264
msgid "*filename*"
msgstr "*filename*"

#: ../../library/logging.rst:1264
msgid ""
"Specifies that a :class:`FileHandler` be created, using the specified "
"filename, rather than a :class:`StreamHandler`."
msgstr ""
":class:`StreamHandler` ではなく指定された名前で  :class:`FileHandler` が作ら"
"れます。"

#: ../../library/logging.rst:1268
msgid "*filemode*"
msgstr "*filemode*"

#: ../../library/logging.rst:1268
msgid ""
"If *filename* is specified, open the file in this :ref:`mode <filemodes>`. "
"Defaults to ``'a'``."
msgstr ""
"*filename* が指定された場合、この :ref:`モード <filemodes>` でファイルが開か"
"れます。\n"
"デフォルトは  ``'a'`` です。"

#: ../../library/logging.rst:1272
msgid "*format*"
msgstr "*format*"

#: ../../library/logging.rst:1272
msgid ""
"Use the specified format string for the handler. Defaults to attributes "
"``levelname``, ``name`` and ``message`` separated by colons."
msgstr ""
"ハンドラーで指定されたフォーマット文字列を使います。デフォルトは "
"``levelname``, ``name``, ``message`` 属性をコロン区切りにしたものです。"

#: ../../library/logging.rst:1277
msgid "*datefmt*"
msgstr "*datefmt*"

#: ../../library/logging.rst:1277
msgid ""
"Use the specified date/time format, as accepted by :func:`time.strftime`."
msgstr ""
"指定された日時の書式で :func:`time.strftime` が受け付けるものを使います。"

#: ../../library/logging.rst:1280
msgid "*style*"
msgstr "*style*"

#: ../../library/logging.rst:1280
msgid ""
"If *format* is specified, use this style for the format string. One of "
"``'%'``, ``'{'`` or ``'$'`` for :ref:`printf-style <old-string-"
"formatting>`, :meth:`str.format` or :class:`string.Template` respectively. "
"Defaults to ``'%'``."
msgstr ""
"*format* が指定された場合、書式文字列にこのスタイルを仕様します。\n"
"``'%'``, ``'{'``, ``'$'`` のうち1つで、それぞれ :ref:`printf-style <old-"
"string-formatting>`, :meth:`str.format`, :class:`string.Template` に対応しま"
"す。\n"
"デフォルトは ``'%'`` です。"

#: ../../library/logging.rst:1288
msgid "*level*"
msgstr "*level*"

#: ../../library/logging.rst:1288
msgid "Set the root logger level to the specified :ref:`level <levels>`."
msgstr "ルートロガーのレベルを指定された :ref:`レベル <levels>` に設定します。"

#: ../../library/logging.rst:1291
msgid "*stream*"
msgstr "*stream*"

#: ../../library/logging.rst:1291
msgid ""
"Use the specified stream to initialize the :class:`StreamHandler`. Note that "
"this argument is incompatible with *filename* - if both are present, a "
"``ValueError`` is raised."
msgstr ""
"指定されたストリームを :class:`StreamHandler` の初期化に使います。\n"
"この引数は *filename* と同時には使えないことに注意してください。\n"
"両方が指定されたときには ``ValueError`` が送出されます。"

#: ../../library/logging.rst:1297
msgid "*handlers*"
msgstr "*handlers*"

#: ../../library/logging.rst:1297
msgid ""
"If specified, this should be an iterable of already created handlers to add "
"to the root logger. Any handlers which don't already have a formatter set "
"will be assigned the default formatter created in this function. Note that "
"this argument is incompatible with *filename* or *stream* - if both are "
"present, a ``ValueError`` is raised."
msgstr ""
"もし指定されれば、 これは root ロガーに追加される既に作られたハンドラのイテラ"
"ブルになります。まだフォーマッタがセットされていないすべてのハンドラは、この"
"関数で作られたデフォルトフォーマッタが割り当てられることになります。この引数"
"は *filename* や *stream* と互換性がないことに注意してください。両方が存在す"
"る場合 ``ValueError`` が上げられます。"

#: ../../library/logging.rst:1306
msgid "*force*"
msgstr "*force*"

#: ../../library/logging.rst:1306
msgid ""
"If this keyword argument is specified as true, any existing handlers "
"attached to the root logger are removed and closed, before carrying out the "
"configuration as specified by the other arguments."
msgstr ""
"このキーワード引数が真に設定されている場合、ルートのロガーに取り付けられたハ"
"ンドラは全て取り除かれ、他の引数によって指定された設定が有効になる前に閉じら"
"れます。"

#: ../../library/logging.rst:1312
msgid "*encoding*"
msgstr "*encoding*"

#: ../../library/logging.rst:1312
msgid ""
"If this keyword argument is specified along with *filename*, its value is "
"used when the :class:`FileHandler` is created, and thus used when opening "
"the output file."
msgstr ""
"もしこのキーワード引数が *filename* とともに指定された場合、 :class:"
"`FileHandler` が作成されるときにこの値が利用され、出力ファイルを開く時に使用"
"されます。"

#: ../../library/logging.rst:1317
msgid "*errors*"
msgstr "*errors*"

#: ../../library/logging.rst:1317
msgid ""
"If this keyword argument is specified along with *filename*, its value is "
"used when the :class:`FileHandler` is created, and thus used when opening "
"the output file. If not specified, the value 'backslashreplace' is used. "
"Note that if ``None`` is specified, it will be passed as such to :func:"
"`open`, which means that it will be treated the same as passing 'errors'."
msgstr ""
"もしこのキーワード引数が *filename* とともに指定された場合、 :class:"
"`FileHandler` が作成されるときのこの値が使用され、出力ファイルを開く時に使わ"
"れます。もし指定されなかった場合、 'backslashreplace' が使用されます。もし "
"``None`` が指定されると :func:`open` のように渡され、'errors' を渡したのと同"
"じように扱われます。"

#: ../../library/logging.rst:1328
msgid "The *style* argument was added."
msgstr "*style* 引数が追加されました。"

#: ../../library/logging.rst:1331
msgid ""
"The *handlers* argument was added. Additional checks were added to catch "
"situations where incompatible arguments are specified (e.g. *handlers* "
"together with *stream* or *filename*, or *stream* together with *filename*)."
msgstr ""
"互換性のない引数が指定された状況 (例えば *handlers* が *stream* や "
"*filename* と一緒に指定されたり、*stream* が *filename* と一緒に指定された場"
"合) を捕捉するために、追加のチェックが加えられました。"

#: ../../library/logging.rst:1337
msgid "The *force* argument was added."
msgstr "*force* 引数が追加されました。"

#: ../../library/logging.rst:1340
msgid "The *encoding* and *errors* arguments were added."
msgstr "*encoding* と *errors* 引数が追加されました。"

#: ../../library/logging.rst:1345
msgid ""
"Informs the logging system to perform an orderly shutdown by flushing and "
"closing all handlers. This should be called at application exit and no "
"further use of the logging system should be made after this call."
msgstr ""
"ロギングシステムに対して、バッファのフラッシュを行い、すべてのハンドラを閉じ"
"ることで順次シャットダウンを行うように告知します。この関数はアプリケーション"
"の終了時に呼ばれるべきであり、また呼び出し以降はそれ以上ロギングシステムを"
"使ってはなりません。"

#: ../../library/logging.rst:1349
msgid ""
"When the logging module is imported, it registers this function as an exit "
"handler (see :mod:`atexit`), so normally there's no need to do that manually."
msgstr ""
"loggingモジュールがインポートされると、この関数が終了ハンドラーとして登録され"
"ます（ :mod:`atexit` 参照）。そのため、通常はこれを手動で行う必要はありませ"
"ん。"

#: ../../library/logging.rst:1356
msgid ""
"Tells the logging system to use the class *klass* when instantiating a "
"logger. The class should define :meth:`__init__` such that only a name "
"argument is required, and the :meth:`__init__` should call :meth:`Logger."
"__init__`. This function is typically called before any loggers are "
"instantiated by applications which need to use custom logger behavior. After "
"this call, as at any other time, do not instantiate loggers directly using "
"the subclass: continue to use the :func:`logging.getLogger` API to get your "
"loggers."
msgstr ""
"ロギングシステムに対して、ロガーをインスタンス化する際にクラス *klass* を使う"
"ように指示します。\n"
"指定するクラスは引数として名前だけをとるようなメソッド :meth:`__init__` を定"
"義していなければならず、 :meth:`__init__` では :meth:`Logger.__init__` を呼び"
"出さなければなりません。\n"
"この関数が呼び出されるのはたいてい、独自の振る舞いをするロガーを使う必要のあ"
"るアプリケーションでロガーがインスタンス化される前です。\n"
"呼び出された後は、いつでもそのサブクラスを使ってロガーのインスタンス化をして"
"はいけません: 引き続き :func:`logging.getLogger` API を使用してロガーを取得し"
"てください。"

#: ../../library/logging.rst:1367
msgid "Set a callable which is used to create a :class:`LogRecord`."
msgstr ":class:`LogRecord` を生成するのに使われる callable をセットします。"

#: ../../library/logging.rst:1369
msgid "The factory callable to be used to instantiate a log record."
msgstr "ログレコードを生成するファクトリとして振舞う callable。"

#: ../../library/logging.rst:1371
msgid ""
"This function has been provided, along with :func:`getLogRecordFactory`, to "
"allow developers more control over how the :class:`LogRecord` representing a "
"logging event is constructed."
msgstr ""
"この関数は、ログイベントを表現する :class:`LogRecord` の構築方法に関して開発"
"者により多くのコントロールを与えるため、 :func:`getLogRecordFactory` とともに"
"提供されました。"

#: ../../library/logging.rst:1376
msgid "The factory has the following signature:"
msgstr "ファクトリは以下のようなシグネチャを持っています:"

#: ../../library/logging.rst:1378
msgid ""
"``factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, "
"**kwargs)``"
msgstr ""
"``factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, "
"**kwargs)``"

#: ../../library/logging.rst:1380
msgid "The logger name."
msgstr "ロガーの名前。"

#: ../../library/logging.rst:0
msgid "level"
msgstr "level"

#: ../../library/logging.rst:1381
msgid "The logging level (numeric)."
msgstr "ログレベル (数値)。"

#: ../../library/logging.rst:0
msgid "fn"
msgstr "fn"

#: ../../library/logging.rst:1382
msgid "The full pathname of the file where the logging call was made."
msgstr "ログ呼び出しが行われたファイルのフルパス名。"

#: ../../library/logging.rst:0
msgid "lno"
msgstr "lno"

#: ../../library/logging.rst:1383
msgid "The line number in the file where the logging call was made."
msgstr "ログ呼び出しが行われたファイルの行数。"

#: ../../library/logging.rst:1384
msgid "The logging message."
msgstr "ログメッセージ。"

#: ../../library/logging.rst:1385
msgid "The arguments for the logging message."
msgstr "ログメッセージに対する引数。"

#: ../../library/logging.rst:1386
msgid "An exception tuple, or ``None``."
msgstr "例外タプルまたは ``None``。"

#: ../../library/logging.rst:0
msgid "func"
msgstr "func"

#: ../../library/logging.rst:1387
msgid "The name of the function or method which invoked the logging call."
msgstr "ログ呼び出しを起動した関数またはメソッドの名前。"

#: ../../library/logging.rst:0
msgid "sinfo"
msgstr "sinfo"

#: ../../library/logging.rst:1389
msgid ""
"A stack traceback such as is provided by :func:`traceback.print_stack`, "
"showing the call hierarchy."
msgstr ""
":func:`traceback.print_stack` で提供されるような、呼び出し階層を示すスタック"
"トレースバック。"

#: ../../library/logging.rst:0
msgid "kwargs"
msgstr "``kwargs``"

#: ../../library/logging.rst:1391
msgid "Additional keyword arguments."
msgstr "追加のキーワード引数。"

#: ../../library/logging.rst:1395
msgid "Module-Level Attributes"
msgstr "モジュールレベル属性"

#: ../../library/logging.rst:1399
msgid ""
"A \"handler of last resort\" is available through this attribute. This is a :"
"class:`StreamHandler` writing to ``sys.stderr`` with a level of ``WARNING``, "
"and is used to handle logging events in the absence of any logging "
"configuration. The end result is to just print the message to ``sys."
"stderr``. This replaces the earlier error message saying that \"no handlers "
"could be found for logger XYZ\". If you need the earlier behaviour for some "
"reason, ``lastResort`` can be set to ``None``."
msgstr ""
"「最後の手段のハンドラ」が、この属性で利用可能です。これは :class:"
"`StreamHandler` が ``sys.stderr`` に ``WARNING`` レベルで書き出しているのがそ"
"うですし、ロギングの設定がなにか不在のロギングイベントを扱う場合に使われま"
"す。最終的な結果は、メッセージを単に ``sys.stderr`` に出力することです。これ"
"はかつて「logger XYZ についてのハンドラが見つかりません」と言っていたエラー"
"メッセージを置き換えています。もしも何らかの理由でその昔の振る舞いが必要な場"
"合は、 ``lastResort`` に ``None`` をセットすれば良いです。"

#: ../../library/logging.rst:1410
msgid "Integration with the warnings module"
msgstr "warnings モジュールとの統合"

#: ../../library/logging.rst:1412
msgid ""
"The :func:`captureWarnings` function can be used to integrate :mod:`logging` "
"with the :mod:`warnings` module."
msgstr ""
":func:`captureWarnings` 関数を使って、 :mod:`logging` を :mod:`warnings` モ"
"ジュールと統合できます。"

#: ../../library/logging.rst:1417
msgid ""
"This function is used to turn the capture of warnings by logging on and off."
msgstr "この関数は、logging による警告の補足を、有効にまたは無効にします。"

#: ../../library/logging.rst:1420
msgid ""
"If *capture* is ``True``, warnings issued by the :mod:`warnings` module will "
"be redirected to the logging system. Specifically, a warning will be "
"formatted using :func:`warnings.formatwarning` and the resulting string "
"logged to a logger named ``'py.warnings'`` with a severity of :const:"
"`WARNING`."
msgstr ""
"*capture* が ``True`` なら、 :mod:`warnings` モジュールに発せられた警告は、ロ"
"ギングシステムにリダイレクトされるようになります。具体的には、警告が :func:"
"`warnings.formatwarning` でフォーマット化され、結果の文字列が ``'py."
"warnings'`` という名のロガーに、 :const:`WARNING` の重大度でロギングされるよ"
"うになります。"

#: ../../library/logging.rst:1425
msgid ""
"If *capture* is ``False``, the redirection of warnings to the logging system "
"will stop, and warnings will be redirected to their original destinations (i."
"e. those in effect before ``captureWarnings(True)`` was called)."
msgstr ""
"*capture* が ``False`` なら、警告のロギングシステムに対するリダイレクトは止め"
"られ、警告は元の (すなわち、``captureWarnings(True)`` が呼び出される前に有効"
"だった) 送信先にリダイレクトされるようになります。"

#: ../../library/logging.rst:1433
msgid "Module :mod:`logging.config`"
msgstr ":mod:`logging.config` モジュール"

#: ../../library/logging.rst:1433
msgid "Configuration API for the logging module."
msgstr "logging モジュールの環境設定 API です。"

#: ../../library/logging.rst:1436
msgid "Module :mod:`logging.handlers`"
msgstr ":mod:`logging.handlers` モジュール"

#: ../../library/logging.rst:1436
msgid "Useful handlers included with the logging module."
msgstr "logging モジュールに含まれる、便利なハンドラです。"

#: ../../library/logging.rst:1440
msgid ":pep:`282` - A Logging System"
msgstr ":pep:`282` - ログシステム"

#: ../../library/logging.rst:1439
msgid ""
"The proposal which described this feature for inclusion in the Python "
"standard library."
msgstr "この機能を Python 標準ライブラリに含めることを述べた提案です。"

#: ../../library/logging.rst:1445
msgid ""
"`Original Python logging package <https://old.red-dove.com/python_logging."
"html>`_"
msgstr ""

#: ../../library/logging.rst:1443
msgid ""
"This is the original source for the :mod:`logging` package.  The version of "
"the package available from this site is suitable for use with Python 1.5.2, "
"2.1.x and 2.2.x, which do not include the :mod:`logging` package in the "
"standard library."
msgstr ""
"これは、 :mod:`logging` パッケージのオリジナルのソースです。このサイトから利"
"用できるバージョンのパッケージは、 :mod:`logging` パッケージを標準ライブラリ"
"に含まない、 Python 1.5.2, 2.1.x および 2.2.x で使うのに適しています。"
