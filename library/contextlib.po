# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-24 13:57+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/contextlib.rst:2
msgid ""
":mod:`contextlib` --- Utilities for :keyword:`with`\\ -statement contexts"
msgstr ":mod:`contextlib` --- :keyword:`with` æ–‡ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç”¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£"

#: ../../library/contextlib.rst:7
msgid "**Source code:** :source:`Lib/contextlib.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/contextlib.py`"

#: ../../library/contextlib.rst:11
msgid ""
"This module provides utilities for common tasks involving the "
":keyword:`with` statement. For more information see also "
":ref:`typecontextmanager` and :ref:`context-managers`."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :keyword:`with` æ–‡ã«é–¢ã‚ã‚‹ä¸€èˆ¬çš„ãªã‚¿ã‚¹ã‚¯ã®ãŸã‚ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚’æä¾›ã—ã¾ã™ã€‚è©³ã—ã„æƒ…å ±ã¯ã€ "
":ref:`typecontextmanager` ã¨ :ref:`context-managers` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/contextlib.rst:17
msgid "Utilities"
msgstr "ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£"

#: ../../library/contextlib.rst:19
msgid "Functions and classes provided:"
msgstr "ä»¥ä¸‹ã®é–¢æ•°ã¨ã‚¯ãƒ©ã‚¹ã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/contextlib.rst:23
msgid ""
"An :term:`abstract base class` for classes that implement "
":meth:`object.__enter__` and :meth:`object.__exit__`. A default "
"implementation for :meth:`object.__enter__` is provided which returns "
"``self`` while :meth:`object.__exit__` is an abstract method which by "
"default returns ``None``. See also the definition of "
":ref:`typecontextmanager`."
msgstr ""

#: ../../library/contextlib.rst:35
msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`with` statement context managers, without needing to "
"create a class or separate :meth:`__enter__` and :meth:`__exit__` methods."
msgstr ""
"ã“ã®é–¢æ•°ã¯ :keyword:`with` æ–‡ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã§ãã‚‹ :term:`ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ "
"<decorator>` ã§ã™ã€‚æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚„ :meth:`__enter__` ã¨ :meth:`__exit__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’åˆ¥ã€…ã«å®šç¾©ã—ãªãã¦ã‚‚ã€ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã‚’å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/contextlib.rst:39
msgid ""
"While many objects natively support use in with statements, sometimes a "
"resource needs to be managed that isn't a context manager in its own right, "
"and doesn't implement a ``close()`` method for use with "
"``contextlib.closing``"
msgstr ""

#: ../../library/contextlib.rst:43
msgid ""
"An abstract example would be the following to ensure correct resource "
"management::"
msgstr ""

#: ../../library/contextlib.rst:62
msgid ""
"The function being decorated must return a :term:`generator`-iterator when "
"called. This iterator must yield exactly one value, which will be bound to "
"the targets in the :keyword:`with` statement's :keyword:`as` clause, if any."
msgstr ""
"ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆå¯¾è±¡ã®é–¢æ•°ã¯å‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã« :term:`ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ "
"<generator>`-ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯å¿…ãšå€¤ã‚’1ã¤ yield ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ "
":keyword:`with` æ–‡ã® :keyword:`as` ç¯€ãŒå­˜åœ¨ã™ã‚‹ãªã‚‰ã€ãã®å€¤ã¯ as ç¯€ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸æŸç¸›ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/contextlib.rst:66
msgid ""
"At the point where the generator yields, the block nested in the "
":keyword:`with` statement is executed.  The generator is then resumed after "
"the block is exited. If an unhandled exception occurs in the block, it is "
"reraised inside the generator at the point where the yield occurred.  Thus, "
"you can use a :keyword:`try`...\\ :keyword:`except`...\\ :keyword:`finally` "
"statement to trap the error (if any), or ensure that some cleanup takes "
"place. If an exception is trapped merely in order to log it or to perform "
"some action (rather than to suppress it entirely), the generator must "
"reraise that exception. Otherwise the generator context manager will "
"indicate to the :keyword:`with` statement that the exception has been "
"handled, and execution will resume with the statement immediately following "
"the :keyword:`with` statement."
msgstr ""
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒ yield ã‚’å®Ÿè¡Œã—ãŸç®‡æ‰€ã§ :keyword:`with` "
"æ–‡ã®ãƒã‚¹ãƒˆã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰æŠœã‘ãŸå¾Œã§ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯å†é–‹ã•ã‚Œã¾ã™ã€‚ãƒ–ãƒ­ãƒƒã‚¯å†…ã§å‡¦ç†ã•ã‚Œãªã„ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿å†…éƒ¨ã®"
" yield ã‚’å®Ÿè¡Œã—ãŸç®‡æ‰€ã§ä¾‹å¤–ãŒå†é€å‡ºã•ã‚Œã¾ã™ã€‚ãªã®ã§ã€(ã‚‚ã—ã‚ã‚Œã°) "
"ã‚¨ãƒ©ãƒ¼ã‚’æ•æ‰ã—ãŸã‚Šã€ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†ã‚’ç¢ºå®Ÿã«å®Ÿè¡Œã—ãŸã‚Šã™ã‚‹ãŸã‚ã«ã€:keyword:`try`...\\ :keyword:`except`...\\"
" :keyword:`finally` æ§‹æ–‡ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚ä¾‹å¤–ã‚’æ•æ‰ã™ã‚‹ç›®çš„ãŒã€(å®Œå…¨ã«ä¾‹å¤–ã‚’æŠ‘åˆ¶ã—ã¦ã—ã¾ã†ã®ã§ã¯ãªã) "
"å˜ã«ä¾‹å¤–ã®ãƒ­ã‚°ã‚’ã¨ã‚‹ãŸã‚ã€ã‚‚ã—ãã¯ã‚ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ãªã‚‰ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯ãã®ä¾‹å¤–ã‚’å†é€å‡ºã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹å¤–ã‚’å†é€å‡ºã—ãªã„å ´åˆã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¯"
" :keyword:`with` æ–‡ã«å¯¾ã—ã¦ä¾‹å¤–ãŒå‡¦ç†ã•ã‚ŒãŸã“ã¨ã‚’ç¤ºã—ã€:keyword:`with` æ–‡ã®ç›´å¾Œã®æ–‡ã‹ã‚‰å®Ÿè¡Œã‚’å†é–‹ã—ã¾ã™ã€‚"

#: ../../library/contextlib.rst:78
msgid ""
":func:`contextmanager` uses :class:`ContextDecorator` so the context "
"managers it creates can be used as decorators as well as in :keyword:`with` "
"statements. When used as a decorator, a new generator instance is implicitly"
" created on each function call (this allows the otherwise \"one-shot\" "
"context managers created by :func:`contextmanager` to meet the requirement "
"that context managers support multiple invocations in order to be used as "
"decorators)."
msgstr ""
":func:`contextmanager` ã¯ :class:`ContextDecorator` ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã§ã€ "
":func:`contextmanager` ã§ä½œã£ãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¯ :keyword:`with` "
"æ–‡ã ã‘ã§ãªããƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦ã‚‚åˆ©ç”¨ã§ãã¾ã™ã€‚ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¨ã—ã¦åˆ©ç”¨ã•ã‚ŒãŸå ´åˆã€æ–°ã—ã„ generator "
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒé–¢æ•°å‘¼ã³å‡ºã—ã®ãŸã³ã«æš—é»™ã«ç”Ÿæˆã•ã‚Œã¾ã™ (ã“ã®ã“ã¨ã«ã‚ˆã£ã¦ã€ :func:`contextmanager` "
"ã«ã‚ˆã£ã¦ä½œã‚‰ã‚ŒãŸãªã«ãŒã—ã‹ã€Œå˜ç™ºã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãŒãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹ãŸã‚ã«ã¯å¤šé‡ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€ã¨ã„ã†è¦ä»¶ã«åˆè‡´ã•ã›ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚)"

#: ../../library/contextlib.rst:85
msgid "Use of :class:`ContextDecorator`."
msgstr ":class:`ContextDecorator` ã®ä½¿ç”¨ã€‚"

#: ../../library/contextlib.rst:91
msgid ""
"Return a context manager that closes *thing* upon completion of the block.  "
"This is basically equivalent to::"
msgstr "ãƒ–ãƒ­ãƒƒã‚¯ã®å®Œäº†æ™‚ã« *thing* ã‚’ close ã™ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯åŸºæœ¬çš„ã«ä»¥ä¸‹ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/contextlib.rst:103
msgid "And lets you write code like this::"
msgstr "ãã—ã¦ã€æ˜ç¤ºçš„ã« ``page`` ã‚’ close ã™ã‚‹å¿…è¦ãªã—ã«ã€æ¬¡ã®ã‚ˆã†ã«æ›¸ãã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/contextlib.rst:112
msgid ""
"without needing to explicitly close ``page``.  Even if an error occurs, "
"``page.close()`` will be called when the :keyword:`with` block is exited."
msgstr ""
"``page`` ã‚’æ˜ç¤ºçš„ã« close ã™ã‚‹å¿…è¦ã¯ç„¡ãã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã§ã‚‚ã€ :keyword:`with` ãƒ–ãƒ­ãƒƒã‚¯ã‚’å‡ºã‚‹ã¨ãã« "
"``page.close()`` ãŒå‘¼ã°ã‚Œã¾ã™ã€‚"

#: ../../library/contextlib.rst:118
msgid ""
"Return a context manager that suppresses any of the specified exceptions if "
"they occur in the body of a with statement and then resumes execution with "
"the first statement following the end of the with statement."
msgstr ""
"ä»»æ„ã®ä¾‹å¤–ãƒªã‚¹ãƒˆã‚’å—ã‘å–ã‚Šã€with ãƒ–ãƒ­ãƒƒã‚¯å†…ã§ã„ãšã‚Œã‹ãŒèµ·ã“ã‚‹ã¨ with ãƒ–ãƒ­ãƒƒã‚¯ã®ç›´å¾Œã‹ã‚‰é»™ã£ã¦å®Ÿè¡Œã‚’å†é–‹ã™ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/contextlib.rst:122
msgid ""
"As with any other mechanism that completely suppresses exceptions, this "
"context manager should be used only to cover very specific errors where "
"silently continuing with program execution is known to be the right thing to"
" do."
msgstr ""
"ã»ã‹ã®å®Œå…¨ã«ä¾‹å¤–ã‚’æŠ‘åˆ¶ã™ã‚‹ãƒ¡ã‚«ãƒ‹ã‚ºãƒ åŒæ§˜ã€ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¯ã€é»™ã£ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ å®Ÿè¡Œã‚’ç¶šã‘ã‚‹ã“ã¨ãŒæ­£ã—ã„ã“ã¨ã§ã‚ã‚‹ã¨ã‚ã‹ã£ã¦ã„ã‚‹ã€éå¸¸ã«é™å®šçš„ãªã‚¨ãƒ©ãƒ¼ã‚’ã‚«ãƒãƒ¼ã™ã‚‹ä»¥ä¸Šã®ä½¿ã„æ–¹ã¯ã—ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../library/contextlib.rst:127
msgid "For example::"
msgstr "ä¾‹ãˆã°::"

#: ../../library/contextlib.rst:137
msgid "This code is equivalent to::"
msgstr "ã“ã‚Œã¯ä»¥ä¸‹ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/contextlib.rst:149 ../../library/contextlib.rst:188
#: ../../library/contextlib.rst:198
msgid "This context manager is :ref:`reentrant <reentrant-cms>`."
msgstr "ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¯ :ref:`å†å…¥å¯èƒ½(ãƒªã‚¨ãƒ³ãƒˆãƒ©ãƒ³ãƒˆ) <reentrant-cms>` ã§ã™ã€‚"

#: ../../library/contextlib.rst:156
msgid ""
"Context manager for temporarily redirecting :data:`sys.stdout` to another "
"file or file-like object."
msgstr ""

#: ../../library/contextlib.rst:159
msgid ""
"This tool adds flexibility to existing functions or classes whose output is "
"hardwired to stdout."
msgstr ""

#: ../../library/contextlib.rst:162
msgid ""
"For example, the output of :func:`help` normally is sent to *sys.stdout*. "
"You can capture that output in a string by redirecting the output to an "
":class:`io.StringIO` object::"
msgstr ""

#: ../../library/contextlib.rst:171
msgid ""
"To send the output of :func:`help` to a file on disk, redirect the output to"
" a regular file::"
msgstr ""

#: ../../library/contextlib.rst:178
msgid "To send the output of :func:`help` to *sys.stderr*::"
msgstr ""

#: ../../library/contextlib.rst:183
msgid ""
"Note that the global side effect on :data:`sys.stdout` means that this "
"context manager is not suitable for use in library code and most threaded "
"applications. It also has no effect on the output of subprocesses. However, "
"it is still a useful approach for many utility scripts."
msgstr ""

#: ../../library/contextlib.rst:195
msgid ""
"Similar to :func:`~contextlib.redirect_stdout` but redirecting "
":data:`sys.stderr` to another file or file-like object."
msgstr ""

#: ../../library/contextlib.rst:205
msgid ""
"A base class that enables a context manager to also be used as a decorator."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦ã‚‚ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/contextlib.rst:207
msgid ""
"Context managers inheriting from ``ContextDecorator`` have to implement "
"``__enter__`` and ``__exit__`` as normal. ``__exit__`` retains its optional "
"exception handling even when used as a decorator."
msgstr ""
"``ContextDecorator`` ã‹ã‚‰ç¶™æ‰¿ã—ãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã¯ã€é€šå¸¸ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¨åŒã˜ã ``__enter__`` "
"ãŠã‚ˆã³ ``__exit__`` ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚``__exit__`` "
"ã¯ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦ä½¿ç”¨ã•ã‚ŒãŸå ´åˆã§ã‚‚ä¾‹å¤–ã‚’ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚Šã¾ã™ã€‚"

#: ../../library/contextlib.rst:211
msgid ""
"``ContextDecorator`` is used by :func:`contextmanager`, so you get this "
"functionality automatically."
msgstr ""
":func:`contextmanager` ã¯ ``ContextDecorator`` "
"ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ã®ã§ã€è‡ªå‹•çš„ã«ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¨ã—ã¦ã‚‚åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/contextlib.rst:214
msgid "Example of ``ContextDecorator``::"
msgstr "``ContextDecorator`` ã®ä¾‹::"

#: ../../library/contextlib.rst:243
msgid ""
"This change is just syntactic sugar for any construct of the following "
"form::"
msgstr "ã“ã‚Œã¯æ¬¡ã®ã‚ˆã†ãªå½¢ã®ã‚³ãƒ¼ãƒ‰ã«å¯¾ã™ã‚‹ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚·ãƒ¥ã‚¬ãƒ¼ã«ãªã‚Šã¾ã™::"

#: ../../library/contextlib.rst:249
msgid "``ContextDecorator`` lets you instead write::"
msgstr "``ContextDecorator`` ã‚’ä½¿ã†ã¨ä»£ã‚ã‚Šã«æ¬¡ã®ã‚ˆã†ã«æ›¸ã‘ã¾ã™::"

#: ../../library/contextlib.rst:255
msgid ""
"It makes it clear that the ``cm`` applies to the whole function, rather than"
" just a piece of it (and saving an indentation level is nice, too)."
msgstr ""
"ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ä½¿ã†ã¨ã€``cm`` ãŒé–¢æ•°ã®ä¸€éƒ¨ã§ã¯ãªãå…¨ä½“ã«é©ç”¨ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒæ˜ç¢ºã«ãªã‚Šã¾ã™ (ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãƒ¬ãƒ™ãƒ«ã‚’1ã¤ç¯€ç´„ã§ãã‚‹ã®ã‚‚ãƒ¡ãƒªãƒƒãƒˆã§ã™)ã€‚"

#: ../../library/contextlib.rst:258
msgid ""
"Existing context managers that already have a base class can be extended by "
"using ``ContextDecorator`` as a mixin class::"
msgstr ""
"ã™ã§ã«åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’æŒã£ã¦ã„ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚‚ã€``ContextDecorator`` ã‚’ mixin "
"ã‚¯ãƒ©ã‚¹ã¨ã—ã¦åˆ©ç”¨ã™ã‚‹ã“ã¨ã§æ‹¡å¼µã§ãã¾ã™::"

#: ../../library/contextlib.rst:271
msgid ""
"As the decorated function must be able to be called multiple times, the "
"underlying context manager must support use in multiple :keyword:`with` "
"statements. If this is not the case, then the original construct with the "
"explicit :keyword:`with` statement inside the function should be used."
msgstr ""
"ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã•ã‚ŒãŸé–¢æ•°ãŒè¤‡æ•°å›å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ã€å†…éƒ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¯è¤‡æ•°ã® :keyword:`with` "
"æ–‡ã«å¯¾å¿œã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãã†ã§ãªã„ãªã‚‰ã€æ˜ç¤ºçš„ãª :keyword:`with` æ–‡ã‚’é–¢æ•°å†…ã§åˆ©ç”¨ã™ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/contextlib.rst:281
msgid ""
"A context manager that is designed to make it easy to programmatically "
"combine other context managers and cleanup functions, especially those that "
"are optional or otherwise driven by input data."
msgstr ""
"ä»–ã®ã€ç‰¹ã«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã‚ã£ãŸã‚Šå…¥åŠ›ã«ä¾å­˜ã™ã‚‹ã‚ˆã†ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚„ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–¢æ•°ã‚’å‹•çš„ã«çµ„ã¿åˆã‚ã›ã‚‹ãŸã‚ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã§ã™ã€‚"

#: ../../library/contextlib.rst:285
msgid ""
"For example, a set of files may easily be handled in a single with statement"
" as follows::"
msgstr "ä¾‹ãˆã°ã€è¤‡æ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’1ã¤ã® with æ–‡ã§ç°¡å˜ã«æ‰±ã†ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/contextlib.rst:294
msgid ""
"Each instance maintains a stack of registered callbacks that are called in "
"reverse order when the instance is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement). Note that callbacks are *not* "
"invoked implicitly when the context stack instance is garbage collected."
msgstr ""
"å„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ç™»éŒ²ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®ã‚¹ã‚¿ãƒƒã‚¯ã‚’ç®¡ç†ã—ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ (æ˜ç¤ºçš„ã«ã€ã‚ã‚‹ã„ã¯ :keyword:`with` æ–‡ã®çµ‚ã‚ã‚Šã«æš—é»™çš„ã«)"
"  close ã•ã‚Œã‚‹ã¨ãã«é€†é †ã§ãã‚Œã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¹ã‚¿ãƒƒã‚¯ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒæš—é»™çš„ã«ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚ŒãŸã¨ãã«ã¯ callback "
"ã¯å‘¼ã³å‡ºã•ã‚Œ **ã¾ã›ã‚“** ã€‚"

#: ../../library/contextlib.rst:299
msgid ""
"This stack model is used so that context managers that acquire their "
"resources in their ``__init__`` method (such as file objects) can be handled"
" correctly."
msgstr ""
"ã“ã®ã‚¹ã‚¿ãƒƒã‚¯ãƒ¢ãƒ‡ãƒ«ã¯ã€(file ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚ˆã†ã«) ``__init__`` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã§ãƒªã‚½ãƒ¼ã‚¹ã‚’ç¢ºä¿ã™ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’æ­£ã—ãæ‰±ã†ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚"

#: ../../library/contextlib.rst:303
msgid ""
"Since registered callbacks are invoked in the reverse order of registration,"
" this ends up behaving as if multiple nested :keyword:`with` statements had "
"been used with the registered set of callbacks. This even extends to "
"exception handling - if an inner callback suppresses or replaces an "
"exception, then outer callbacks will be passed arguments based on that "
"updated state."
msgstr ""
"ç™»éŒ²ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒç™»éŒ²ã®é€†é †ã§å®Ÿè¡Œã•ã‚Œã‚‹ã®ã§ã€è¤‡æ•°ã®ãƒã‚¹ãƒˆã•ã‚ŒãŸ :keyword:`with` "
"æ–‡ã‚’åˆ©ç”¨ã™ã‚‹ã®ã¨åŒã˜æŒ¯ã‚‹èˆã„ã‚’ã—ã¾ã™ã€‚ã“ã‚Œã¯ä¾‹å¤–å‡¦ç†ã«ã‚‚é©ç”¨ã•ã‚Œã¾ã™ã€‚å†…å´ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒä¾‹å¤–ã‚’æŠ‘åˆ¶ã—ãŸã‚Šç½®ãæ›ãˆãŸã‚Šã—ãŸå ´åˆã€å¤–å´ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã«ã¯æ›´æ–°ã•ã‚ŒãŸçŠ¶æ…‹ã«å¿œã˜ãŸå¼•æ•°ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/contextlib.rst:310
msgid ""
"This is a relatively low level API that takes care of the details of "
"correctly unwinding the stack of exit callbacks. It provides a suitable "
"foundation for higher level context managers that manipulate the exit stack "
"in application specific ways."
msgstr ""
"ã“ã‚Œã¯æ­£ã—ã exit callback ã® stack ã‚’å·»ãæˆ»ã™ãŸã‚ã®ã€æ¯”è¼ƒçš„ä½ãƒ¬ãƒ™ãƒ«ãª API "
"ã§ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ç‹¬è‡ªã®ã‚ˆã‚Šé«˜ãƒ¬ãƒ™ãƒ«ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ä½œã‚‹ãŸã‚ã®åŸºæ¿ã¨ã—ã¦ä½¿ã†ã®ã«é©ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/contextlib.rst:319
msgid ""
"Enters a new context manager and adds its :meth:`__exit__` method to the "
"callback stack. The return value is the result of the context manager's own "
":meth:`__enter__` method."
msgstr ""
"æ–°ã—ã„ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã« enter ã—ã€ãã® :meth:`__exit__` method "
"ã‚’ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¹ã‚¿ãƒƒã‚¯ã«è¿½åŠ ã—ã¾ã™ã€‚æ¸¡ã•ã‚ŒãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã® :meth:`__enter__` ãƒ¡ã‚½ãƒƒãƒ‰ã®æˆ»ã‚Šå€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/contextlib.rst:323
msgid ""
"These context managers may suppress exceptions just as they normally would "
"if used directly as part of a :keyword:`with` statement."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¯ã€æ™®æ®µ :keyword:`with` æ–‡ã§åˆ©ç”¨ã•ã‚ŒãŸæ™‚ã¨åŒã˜ã‚ˆã†ã«ã€ä¾‹å¤–ã‚’æŠ‘åˆ¶ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/contextlib.rst:328
msgid ""
"Adds a context manager's :meth:`__exit__` method to the callback stack."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã® :meth:`__exit__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¹ã‚¿ãƒƒã‚¯ã«è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../library/contextlib.rst:330
msgid ""
"As ``__enter__`` is *not* invoked, this method can be used to cover part of "
"an :meth:`__enter__` implementation with a context manager's own "
":meth:`__exit__` method."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ ``__enter__`` ã‚’ **å‘¼ã³å‡ºã•ãªã„** ã®ã§ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’å®Ÿè£…ã™ã‚‹ã¨ãã«ã€ "
":meth:`__enter__` ã®å®Ÿè£…ã®ä¸€éƒ¨ã‚’è‡ªèº«ã® :meth:`__exit__` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚«ãƒãƒ¼ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/contextlib.rst:334
msgid ""
"If passed an object that is not a context manager, this method assumes it is"
" a callback with the same signature as a context manager's :meth:`__exit__` "
"method and adds it directly to the callback stack."
msgstr ""
"ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã§ã¯ãªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ¸¡ã•ã‚ŒãŸå ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã® :meth:`__exit__`"
" ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒã˜ã‚·ã‚°ãƒãƒãƒ£ã‚’æŒã¤ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã ã¨ä»®å®šã—ã¦ã€ç›´æ¥ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¹ã‚¿ãƒƒã‚¯ã«è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../library/contextlib.rst:338
msgid ""
"By returning true values, these callbacks can suppress exceptions the same "
"way context manager :meth:`__exit__` methods can."
msgstr ""
"ãã‚Œã‚‰ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚‚ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã® :meth:`__exit__` ã¨åŒã˜ãã€ true "
"å€¤ã‚’è¿”ã™ã“ã¨ã§ä¾‹å¤–ã‚’æŠ‘åˆ¶ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/contextlib.rst:341
msgid ""
"The passed in object is returned from the function, allowing this method to "
"be used as a function decorator."
msgstr "ã“ã®é–¢æ•°ã¯ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦ã‚‚ä½¿ãˆã‚‹ã‚ˆã†ã«ã€å—ã‘å–ã£ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãã®ã¾ã¾è¿”ã—ã¾ã™ã€‚"

#: ../../library/contextlib.rst:346
msgid ""
"Accepts an arbitrary callback function and arguments and adds it to the "
"callback stack."
msgstr "ä»»æ„ã®é–¢æ•°ã¨å¼•æ•°ã‚’å—ã‘å–ã‚Šã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¹ã‚¿ãƒƒã‚¯ã«è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../library/contextlib.rst:349
msgid ""
"Unlike the other methods, callbacks added this way cannot suppress "
"exceptions (as they are never passed the exception details)."
msgstr "ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨ç•°ãªã‚Šã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§è¿½åŠ ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ä¾‹å¤–ã‚’æŠ‘åˆ¶ã—ã¾ã›ã‚“ (ä¾‹å¤–ã®è©³ç´°ã‚‚æ¸¡ã•ã‚Œã¾ã›ã‚“)ã€‚"

#: ../../library/contextlib.rst:352
msgid ""
"The passed in callback is returned from the function, allowing this method "
"to be used as a function decorator."
msgstr "ã“ã®é–¢æ•°ã¯ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦ã‚‚ä½¿ãˆã‚‹ã‚ˆã†ã«ã€å—ã‘å–ã£ãŸ callback ã‚’ãã®ã¾ã¾è¿”ã—ã¾ã™ã€‚"

#: ../../library/contextlib.rst:357
msgid ""
"Transfers the callback stack to a fresh :class:`ExitStack` instance and "
"returns it. No callbacks are invoked by this operation - instead, they will "
"now be invoked when the new stack is closed (either explicitly or implicitly"
" at the end of a :keyword:`with` statement)."
msgstr ""
"ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¹ã‚¿ãƒƒã‚¯ã‚’æ–°ã—ã„ :class:`ExitStack` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ç§»ã—ã¦ã€ãã‚Œã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ callback "
"ã‚’å®Ÿè¡Œã—ã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«ã€æ–°ã—ã„ stack ãŒ (æ˜ç¤ºçš„ã«ã€ã‚ã‚‹ã„ã¯ :keyword:`with` æ–‡ã®çµ‚ã‚ã‚Šã«æš—é»™çš„ã«) close "
"ã•ã‚Œã‚‹ã¨ãã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../library/contextlib.rst:362
msgid ""
"For example, a group of files can be opened as an \"all or nothing\" "
"operation as follows::"
msgstr "ä¾‹ãˆã°ã€è¤‡æ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ \"all or nothing\" ã«é–‹ãå‡¦ç†ã‚’æ¬¡ã®ã‚ˆã†ã«æ›¸ã‘ã¾ã™::"

#: ../../library/contextlib.rst:376
msgid ""
"Immediately unwinds the callback stack, invoking callbacks in the reverse "
"order of registration. For any context managers and exit callbacks "
"registered, the arguments passed in will indicate that no exception "
"occurred."
msgstr ""
"ã™ãã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¹ã‚¿ãƒƒã‚¯ã‚’å·»ãæˆ»ã—ã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’ç™»éŒ²ã®é€†é †ã«å‘¼ã³å‡ºã—ã¾ã™ã€‚ç™»éŒ²ã•ã‚ŒãŸã™ã¹ã¦ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¨çµ‚äº† callback "
"ã«ã€ä¾‹å¤–ãŒèµ·ã“ã‚‰ãªã‹ã£ãŸå ´åˆã®å¼•æ•°ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/contextlib.rst:383
msgid "Examples and Recipes"
msgstr "ä¾‹ã¨ãƒ¬ã‚·ãƒ”"

#: ../../library/contextlib.rst:385
msgid ""
"This section describes some examples and recipes for making effective use of"
" the tools provided by :mod:`contextlib`."
msgstr "ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ :mod:`contextlib` ãŒæä¾›ã™ã‚‹ãƒ„ãƒ¼ãƒ«ã®åŠ¹æœçš„ãªä½¿ã„æ–¹ã‚’ç¤ºã™ä¾‹ã¨ãƒ¬ã‚·ãƒ”ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚"

#: ../../library/contextlib.rst:390
msgid "Supporting a variable number of context managers"
msgstr "å¯å¤‰æ•°å€‹ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹"

#: ../../library/contextlib.rst:392
msgid ""
"The primary use case for :class:`ExitStack` is the one given in the class "
"documentation: supporting a variable number of context managers and other "
"cleanup operations in a single :keyword:`with` statement. The variability "
"may come from the number of context managers needed being driven by user "
"input (such as opening a user specified collection of files), or from some "
"of the context managers being optional::"
msgstr ""
":class:`ExitStack` ã®ç¬¬ä¸€ã®ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã¯ã€ã‚¯ãƒ©ã‚¹ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‹ã‹ã‚Œã¦ã„ã‚‹é€šã‚Šã€ä¸€ã¤ã® :keyword:`with` "
"æ–‡ã§å¯å¤‰æ•°å€‹ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚„ä»–ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–¢æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ› (æŒ‡å®šã•ã‚ŒãŸè¤‡æ•°å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãå ´åˆãªã©) "
"ã«å¿œã˜ã¦è¤‡æ•°å€‹ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒå¿…è¦ã¨ãªã‚‹å ´åˆã‚„ã€ã„ãã¤ã‹ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨ãªã‚‹å ´åˆã«ã€å¯å¤‰æ•°å€‹ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒå¿…è¦ã«ãªã‚Šã¾ã™::"

#: ../../library/contextlib.rst:407
msgid ""
"As shown, :class:`ExitStack` also makes it quite easy to use :keyword:`with`"
" statements to manage arbitrary resources that don't natively support the "
"context management protocol."
msgstr ""
"ä¸Šã®ä¾‹ã«ã‚ã‚‹ã‚ˆã†ã«ã€ :class:`ExitStack` ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ãƒªã‚½ãƒ¼ã‚¹ã®ç®¡ç†ã‚’ "
":keyword:`with` æ–‡ã‚’ä½¿ã£ã¦ç°¡å˜ã«è¡Œãˆã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/contextlib.rst:413
msgid "Simplifying support for single optional context managers"
msgstr "1ã¤ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ç°¡æ½”ã«ã‚µãƒãƒ¼ãƒˆã™ã‚‹"

#: ../../library/contextlib.rst:415
msgid ""
"In the specific case of a single optional context manager, "
":class:`ExitStack` instances can be used as a \"do nothing\" context "
"manager, allowing a context manager to easily be omitted without affecting "
"the overall structure of the source code::"
msgstr ""
"1ã¤ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ä½¿ã†å ´åˆã€ :class:`ExitStack` "
"ã‚’ä½•ã‚‚ã—ãªã„ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¨ã—ã¦åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®æ§‹é€ ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãªã1ã¤ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’çœç•¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/contextlib.rst:431
msgid "Catching exceptions from ``__enter__`` methods"
msgstr "``__enter__`` ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰ã®ä¾‹å¤–ã‚’ã‚­ãƒ£ãƒƒãƒã™ã‚‹"

#: ../../library/contextlib.rst:433
msgid ""
"It is occasionally desirable to catch exceptions from an ``__enter__`` "
"method implementation, *without* inadvertently catching exceptions from the "
":keyword:`with` statement body or the context manager's ``__exit__`` method."
" By using :class:`ExitStack` the steps in the context management protocol "
"can be separated slightly in order to allow this::"
msgstr ""
"ç¨€ã«ã€ ``__enter__`` ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰ã®ä¾‹å¤–ã‚’ã€ :keyword:`with` æ–‡ã® body ã‚„ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã® "
"``__exit__`` ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰ã®ä¾‹å¤–ã¯é–“é•ãˆã¦æ•ã¾ãˆãªã„ã‚ˆã†ã«ã€ catch ã—ãŸã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ :class:`ExitStack` "
"ã‚’ä½¿ã£ã¦ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ãƒˆã‚³ãƒ«å†…ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’åˆ†é›¢ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/contextlib.rst:448
msgid ""
"Actually needing to do this is likely to indicate that the underlying API "
"should be providing a direct resource management interface for use with "
":keyword:`try`/:keyword:`except`/:keyword:`finally` statements, but not all "
"APIs are well designed in that regard. When a context manager is the only "
"resource management API provided, then :class:`ExitStack` can make it easier"
" to handle various situations that can't be handled directly in a "
":keyword:`with` statement."
msgstr ""
"å®Ÿéš›ã®ã¨ã“ã‚ã€ã“ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ãŒå¿…è¦ã«ãªã‚‹ã®ãªã‚‰ã°ã€åˆ©ç”¨ã—ã¦ã„ã‚‹ API å´ã§ "
":keyword:`try`/:keyword:`except`/:keyword:`finally` "
"æ–‡ã‚’ä½¿ã£ãŸç›´æ¥çš„ãªãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã™ã‚‹ã¹ãã§ã™ã€‚ã—ã‹ã—ã€ã™ã¹ã¦ã® API "
"ãŒãã®ã‚ˆã†ã«ã‚ˆãè¨­è¨ˆã•ã‚Œã¦ã„ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒæä¾›ã•ã‚Œã¦ã„ã‚‹å”¯ä¸€ã®ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†APIã§ã‚ã‚‹ãªã‚‰ã€ "
":class:`ExitStack` ã‚’ä½¿ã£ã¦ :keyword:`with` "
"æ–‡ã‚’ä½¿ã£ã¦å‡¦ç†ã™ã‚‹ã“ã¨ãŒã§ããªã„æ§˜ã€…ãªã‚·ãƒãƒ¥ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã®å‡¦ç†ã‚’ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/contextlib.rst:458
msgid "Cleaning up in an ``__enter__`` implementation"
msgstr "``__enter__`` å®Ÿè£…å†…ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"

#: ../../library/contextlib.rst:460
msgid ""
"As noted in the documentation of :meth:`ExitStack.push`, this method can be "
"useful in cleaning up an already allocated resource if later steps in the "
":meth:`__enter__` implementation fail."
msgstr ""
":meth:`ExitStack.push` ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§è¨€åŠã—ãŸã¨ãŠã‚Šã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã™ã§ã«ç²å¾—ã—ãŸãƒªã‚½ãƒ¼ã‚¹ã‚’ã€ "
":meth:`__enter__` ãƒ¡ã‚½ãƒƒãƒ‰ã®æ®‹ã‚Šã®ã‚¹ãƒ†ãƒƒãƒ—ãŒå¤±æ•—ã—ãŸæ™‚ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/contextlib.rst:464
msgid ""
"Here's an example of doing this for a context manager that accepts resource "
"acquisition and release functions, along with an optional validation "
"function, and maps them to the context management protocol::"
msgstr ""
"æ¬¡ã®ä¾‹ã§ã¯ã€ãƒªã‚½ãƒ¼ã‚¹ã®ç¢ºä¿ã¨é–‹æ”¾ã®é–¢æ•°ã«åŠ ãˆã¦ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°ã‚’å—ã‘å–ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã§ã€ã“ã®æ–¹æ³•ã‚’ä½¿ã£ã¦ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’æä¾›ã—ã¦ã„ã¾ã™::"

#: ../../library/contextlib.rst:504
msgid "Replacing any use of ``try-finally`` and flag variables"
msgstr "``try-finally`` + flag å¤‰æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç½®ãæ›ãˆã‚‹"

#: ../../library/contextlib.rst:506
msgid ""
"A pattern you will sometimes see is a ``try-finally`` statement with a flag "
"variable to indicate whether or not the body of the ``finally`` clause "
"should be executed. In its simplest form (that can't already be handled just"
" by using an ``except`` clause instead), it looks something like this::"
msgstr ""
"``try-finally`` æ–‡ã«ã€``finally`` "
"å¥ã®å†…å®¹ã‚’å®Ÿè¡Œã™ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™ãƒ•ãƒ©ã‚°å¤‰æ•°ã‚’çµ„ã¿åˆã‚ã›ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç›®ã«ã™ã‚‹ã“ã¨ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ä¸€ç•ªã‚·ãƒ³ãƒ—ãƒ«ãª (å˜ã« ``except`` "
"å¥ã‚’ä½¿ã†ã ã‘ã§ã¯å‡¦ç†ã§ããªã„) ã‚±ãƒ¼ã‚¹ã§ã¯æ¬¡ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã«ãªã‚Šã¾ã™::"

#: ../../library/contextlib.rst:520
msgid ""
"As with any ``try`` statement based code, this can cause problems for "
"development and review, because the setup code and the cleanup code can end "
"up being separated by arbitrarily long sections of code."
msgstr ""
"``try`` "
"æ–‡ã‚’ä½¿ã£ãŸã‚³ãƒ¼ãƒ‰ã§ã¯ã€ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¨ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã®ã‚³ãƒ¼ãƒ‰ãŒä»»æ„ã®é•·ã•ã®ã‚³ãƒ¼ãƒ‰ã§åˆ†é›¢ã—ã¦ã—ã¾ã†ã®ã§ã€é–‹ç™ºè€…ã‚„ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¢ã«ã¨ã£ã¦å•é¡Œã«ãªã‚Šãˆã¾ã™ã€‚"

#: ../../library/contextlib.rst:524
msgid ""
":class:`ExitStack` makes it possible to instead register a callback for "
"execution at the end of a ``with`` statement, and then later decide to skip "
"executing that callback::"
msgstr ""
":class:`ExitStack` ã‚’ä½¿ãˆã°ã€ä»£ã‚ã‚Šã« ``with`` "
"æ–‡ã®çµ‚ã‚ã‚Šã«å®Ÿè¡Œã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ç™»éŒ²ã—ã€å¾Œã§ãã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ã‹ã©ã†ã‹ã‚’æ±ºå®šã§ãã¾ã™::"

#: ../../library/contextlib.rst:536
msgid ""
"This allows the intended cleanup up behaviour to be made explicit up front, "
"rather than requiring a separate flag variable."
msgstr "ã“ã‚Œã«ã‚ˆã‚Šã€åˆ¥ã®ãƒ•ãƒ©ã‚°å¤‰æ•°ã‚’ä½¿ã†ä»£ã‚ã‚Šã«ã€å¿…è¦ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†ã‚’æ‰‹å‰ã«æ˜ç¤ºã—ã¦ãŠãã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/contextlib.rst:539
msgid ""
"If a particular application uses this pattern a lot, it can be simplified "
"even further by means of a small helper class::"
msgstr "ã‚‚ã—ã‚ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å¤šç”¨ã™ã‚‹ã®ã§ã‚ã‚Œã°ã€å°ã•ã„ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹ã‚’å°å…¥ã—ã¦ã‚ˆã‚Šã‚·ãƒ³ãƒ—ãƒ«ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/contextlib.rst:557
msgid ""
"If the resource cleanup isn't already neatly bundled into a standalone "
"function, then it is still possible to use the decorator form of "
":meth:`ExitStack.callback` to declare the resource cleanup in advance::"
msgstr ""
"ã‚‚ã—ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ãŒå˜ä½“ã®é–¢æ•°ã«ã¾ã¨ã¾ã£ã¦ãªã„å ´åˆã§ã‚‚ã€ :meth:`ExitStack.callback` "
"ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼å½¢å¼ã‚’åˆ©ç”¨ã—ã¦ãƒªã‚½ãƒ¼ã‚¹é–‹æ”¾å‡¦ç†ã‚’å®£è¨€ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/contextlib.rst:572
msgid ""
"Due to the way the decorator protocol works, a callback function declared "
"this way cannot take any parameters. Instead, any resources to be released "
"must be accessed as closure variables."
msgstr ""

#: ../../library/contextlib.rst:578
msgid "Using a context manager as a function decorator"
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’é–¢æ•°ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¨ã—ã¦ä½¿ã†"

#: ../../library/contextlib.rst:580
msgid ""
":class:`ContextDecorator` makes it possible to use a context manager in both"
" an ordinary ``with`` statement and also as a function decorator."
msgstr ""
":class:`ContextDecorator` ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’é€šå¸¸ã® ``with`` "
"æ–‡ã«åŠ ãˆã¦é–¢æ•°ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¨ã—ã¦ã‚‚åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/contextlib.rst:583
msgid ""
"For example, it is sometimes useful to wrap functions or groups of "
"statements with a logger that can track the time of entry and time of exit."
"  Rather than writing both a function decorator and a context manager for "
"the task, inheriting from :class:`ContextDecorator` provides both "
"capabilities in a single definition::"
msgstr ""
"ä¾‹ãˆã°ã€é–¢æ•°ã‚„ã¾ã¨ã¾ã£ãŸæ–‡ã‚’ã€ãã“ã«å…¥ã£ãŸæ™‚ã¨å‡ºãŸæ™‚ã®æ™‚é–“ã‚’ãƒˆãƒ©ãƒƒã‚¯ã™ã‚‹ãƒ­ã‚¬ãƒ¼ã§ãƒ©ãƒƒãƒ—ã—ãŸã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ãã®ãŸã‚ã«é–¢æ•°ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’åˆ¥ã€…ã«æ›¸ãä»£ã‚ã‚Šã«ã€"
" :class:`ContextDecorator` ã‚’ç¶™æ‰¿ã™ã‚‹ã¨1ã¤ã®å®šç¾©ã§ä¸¡æ–¹ã®æ©Ÿèƒ½ã‚’æä¾›ã§ãã¾ã™::"

#: ../../library/contextlib.rst:604
msgid "Instances of this class can be used as both a context manager::"
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¨ã—ã¦ã‚‚åˆ©ç”¨ã§ã::"

#: ../../library/contextlib.rst:610
msgid "And also as a function decorator::"
msgstr "ã¾ãŸé–¢æ•°ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¨ã—ã¦ã‚‚åˆ©ç”¨ã§ãã¾ã™::"

#: ../../library/contextlib.rst:617
msgid ""
"Note that there is one additional limitation when using context managers as "
"function decorators: there's no way to access the return value of "
":meth:`__enter__`. If that value is needed, then it is still necessary to "
"use an explicit ``with`` statement."
msgstr ""
"ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’é–¢æ•°ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¨ã—ã¦ä½¿ã†å ´åˆã€ :meth:`__enter__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã®æˆ»ã‚Šå€¤ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ‰‹æ®µãŒãªã„ã¨ã„ã†åˆ¶é™ãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã‚‚ã—ãã®å€¤ãŒå¿…è¦ã§ã‚ã‚Œã°ã€æ˜ç¤ºçš„ãª ``with`` "
"æ–‡ã‚’ä½¿ã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/contextlib.rst:625
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆ"

#: ../../library/contextlib.rst:625
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python ã® :keyword:`with` æ–‡ã®ä»•æ§˜ã€èƒŒæ™¯ã€ãŠã‚ˆã³ä¾‹ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/contextlib.rst:631
msgid "Single use, reusable and reentrant context managers"
msgstr ""

#: ../../library/contextlib.rst:633
msgid ""
"Most context managers are written in a way that means they can only be used "
"effectively in a :keyword:`with` statement once. These single use context "
"managers must be created afresh each time they're used - attempting to use "
"them a second time will trigger an exception or otherwise not work "
"correctly."
msgstr ""

#: ../../library/contextlib.rst:639
msgid ""
"This common limitation means that it is generally advisable to create "
"context managers directly in the header of the :keyword:`with` statement "
"where they are used (as shown in all of the usage examples above)."
msgstr ""

#: ../../library/contextlib.rst:643
msgid ""
"Files are an example of effectively single use context managers, since the "
"first :keyword:`with` statement will close the file, preventing any further "
"IO operations using that file object."
msgstr ""

#: ../../library/contextlib.rst:647
msgid ""
"Context managers created using :func:`contextmanager` are also single use "
"context managers, and will complain about the underlying generator failing "
"to yield if an attempt is made to use them a second time::"
msgstr ""

#: ../../library/contextlib.rst:675
msgid "Reentrant context managers"
msgstr ""

#: ../../library/contextlib.rst:677
msgid ""
"More sophisticated context managers may be \"reentrant\". These context "
"managers can not only be used in multiple :keyword:`with` statements, but "
"may also be used *inside* a :keyword:`with` statement that is already using "
"the same context manager."
msgstr ""

#: ../../library/contextlib.rst:682
msgid ""
":class:`threading.RLock` is an example of a reentrant context manager, as "
"are :func:`suppress` and :func:`redirect_stdout`. Here's a very simple "
"example of reentrant use::"
msgstr ""

#: ../../library/contextlib.rst:701
msgid ""
"Real world examples of reentrancy are more likely to involve multiple "
"functions calling each other and hence be far more complicated than this "
"example."
msgstr ""

#: ../../library/contextlib.rst:705
msgid ""
"Note also that being reentrant is *not* the same thing as being thread safe."
" :func:`redirect_stdout`, for example, is definitely not thread safe, as it "
"makes a global modification to the system state by binding "
":data:`sys.stdout` to a different stream."
msgstr ""

#: ../../library/contextlib.rst:714
msgid "Reusable context managers"
msgstr ""

#: ../../library/contextlib.rst:716
msgid ""
"Distinct from both single use and reentrant context managers are "
"\"reusable\" context managers (or, to be completely explicit, \"reusable, "
"but not reentrant\" context managers, since reentrant context managers are "
"also reusable). These context managers support being used multiple times, "
"but will fail (or otherwise not work correctly) if the specific context "
"manager instance has already been used in a containing with statement."
msgstr ""

#: ../../library/contextlib.rst:723
msgid ""
":class:`threading.Lock` is an example of a reusable, but not reentrant, "
"context manager (for a reentrant lock, it is necessary to use "
":class:`threading.RLock` instead)."
msgstr ""

#: ../../library/contextlib.rst:727
msgid ""
"Another example of a reusable, but not reentrant, context manager is "
":class:`ExitStack`, as it invokes *all* currently registered callbacks when "
"leaving any with statement, regardless of where those callbacks were added::"
msgstr ""

#: ../../library/contextlib.rst:758
msgid ""
"As the output from the example shows, reusing a single stack object across "
"multiple with statements works correctly, but attempting to nest them will "
"cause the stack to be cleared at the end of the innermost with statement, "
"which is unlikely to be desirable behaviour."
msgstr ""

#: ../../library/contextlib.rst:763
msgid ""
"Using separate :class:`ExitStack` instances instead of reusing a single "
"instance avoids that problem::"
msgstr ""
