# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Takanori Suzuki <takanori@takanory.net>, 2021
# tomo, 2021
# Osamu NAKAMURA, 2021
# Takeshi Nakazato, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-24 14:15+0000\n"
"PO-Revision-Date: 2021-06-28 00:57+0000\n"
"Last-Translator: Takeshi Nakazato, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/contextlib.rst:2
msgid ""
":mod:`!contextlib` --- Utilities for :keyword:`!with`\\ -statement contexts"
msgstr ":mod:`!contextlib` --- :keyword:`!with` 文コンテキスト用ユーティリティ"

#: ../../library/contextlib.rst:7
msgid "**Source code:** :source:`Lib/contextlib.py`"
msgstr "**ソースコード:** :source:`Lib/contextlib.py`"

#: ../../library/contextlib.rst:11
msgid ""
"This module provides utilities for common tasks involving the :keyword:"
"`with` statement. For more information see also :ref:`typecontextmanager` "
"and :ref:`context-managers`."
msgstr ""
"このモジュールは :keyword:`with` 文に関わる一般的なタスクのためのユーティリ"
"ティを提供します。詳しい情報は、 :ref:`typecontextmanager` と :ref:`context-"
"managers` を参照してください。"

#: ../../library/contextlib.rst:17
msgid "Utilities"
msgstr "ユーティリティ"

#: ../../library/contextlib.rst:19
msgid "Functions and classes provided:"
msgstr "以下の関数とクラスを提供しています:"

#: ../../library/contextlib.rst:23
msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__enter__` and :meth:`object.__exit__`. A default implementation for :meth:"
"`object.__enter__` is provided which returns ``self`` while :meth:`object."
"__exit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`typecontextmanager`."
msgstr ""
":meth:`object.__enter__` と :meth:`object.__exit__` の2つのメソッドを実装した"
"抽象基底クラス (:term:`abstract base class`) です。 :meth:`object.__enter__` "
"は ``self`` を返すデフォルトの実装が提供されるいっぽう、 :meth:`object."
"__exit__` はデフォルトで ``None`` を返す抽象メソッドです。 :ref:"
"`typecontextmanager` の定義も参照してください。"

#: ../../library/contextlib.rst:34
msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__aenter__` and :meth:`object.__aexit__`. A default implementation for :meth:"
"`object.__aenter__` is provided which returns ``self`` while :meth:`object."
"__aexit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`async-context-managers`."
msgstr ""
":meth:`object.__aenter__` と :meth:`object.__aexit__` の2つのメソッドを実装す"
"るクラスのための抽象基底クラス (:term:`abstract base class`) です。 :meth:"
"`object.__aenter__` は ``self`` を返すデフォルト実装が提供されるいっぽう、 :"
"meth:`object.__aexit__` はデフォルトで ``None`` を返す抽象メソッドです。 :"
"ref:`async-context-managers` の定義も参照してください。"

#: ../../library/contextlib.rst:46
msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`with` statement context managers, without needing to "
"create a class or separate :meth:`__enter__` and :meth:`__exit__` methods."
msgstr ""
"この関数は :keyword:`with` 文コンテキストマネージャのファクトリ関数を定義する"
"ために利用できる :term:`デコレータ <decorator>` です。新しいクラスや :meth:"
"`__enter__` と :meth:`__exit__` メソッドを別々に定義しなくても、ファクトリ関"
"数を定義することができます。"

#: ../../library/contextlib.rst:50
msgid ""
"While many objects natively support use in with statements, sometimes a "
"resource needs to be managed that isn't a context manager in its own right, "
"and doesn't implement a ``close()`` method for use with ``contextlib."
"closing``"
msgstr ""
"多くのオブジェクトが with 文の仕様を固有にサポートしていますが、コンテキスト"
"マネージャの権限に属さず、 ``close()`` メソッドを実装していないために "
"``contextlib.closing`` の利用もできないリソースを管理する必要があることがあり"
"ます。"

#: ../../library/contextlib.rst:54
msgid ""
"An abstract example would be the following to ensure correct resource "
"management::"
msgstr ""
"リソースを正しく管理するよう保証する抽象的な例は以下のようなものでしょう::"

#: ../../library/contextlib.rst:69
msgid "The function can then be used like this::"
msgstr "このとき、関数は次のように使うことができます::"

#: ../../library/contextlib.rst:75
msgid ""
"The function being decorated must return a :term:`generator`-iterator when "
"called. This iterator must yield exactly one value, which will be bound to "
"the targets in the :keyword:`with` statement's :keyword:`!as` clause, if any."
msgstr ""
"デコレート対象の関数は呼び出されたときに :term:`ジェネレータ <generator>`-イ"
"テレータを返す必要があります。このイテレータは必ず値を1つ yield しなければな"
"りません。 :keyword:`with` 文の :keyword:`!as` 節が存在するなら、その値は as "
"節のターゲットへ束縛されることになります。"

#: ../../library/contextlib.rst:79
msgid ""
"At the point where the generator yields, the block nested in the :keyword:"
"`with` statement is executed.  The generator is then resumed after the block "
"is exited. If an unhandled exception occurs in the block, it is reraised "
"inside the generator at the point where the yield occurred.  Thus, you can "
"use a :keyword:`try`...\\ :keyword:`except`...\\ :keyword:`finally` "
"statement to trap the error (if any), or ensure that some cleanup takes "
"place. If an exception is trapped merely in order to log it or to perform "
"some action (rather than to suppress it entirely), the generator must "
"reraise that exception. Otherwise the generator context manager will "
"indicate to the :keyword:`!with` statement that the exception has been "
"handled, and execution will resume with the statement immediately following "
"the :keyword:`!with` statement."
msgstr ""
"ジェネレータが yield を実行した箇所で :keyword:`with` 文のネストされたブロッ"
"クが実行されます。ブロックから抜けた後でジェネレータは再開されます。ブロック"
"内で処理されない例外が発生した場合は、ジェネレータ内部の yield を実行した箇所"
"で例外が再送出されます。なので、(もしあれば) エラーを捕捉したり、クリーンアッ"
"プ処理を確実に実行したりするために、:keyword:`try`...\\ :keyword:`except`..."
"\\ :keyword:`finally` 構文を使用できます。例外を捕捉する目的が、(完全に例外を"
"抑制してしまうのではなく) 単に例外のログをとるため、もしくはあるアクションを"
"実行するためなら、ジェネレータはその例外を再送出しなければなりません。例外を"
"再送出しない場合、ジェネレータのコンテキストマネージャは :keyword:`!with` 文"
"に対して例外が処理されたことを示し、:keyword:`!with` 文の直後の文から実行を再"
"開します。"

#: ../../library/contextlib.rst:91
msgid ""
":func:`contextmanager` uses :class:`ContextDecorator` so the context "
"managers it creates can be used as decorators as well as in :keyword:`with` "
"statements. When used as a decorator, a new generator instance is implicitly "
"created on each function call (this allows the otherwise \"one-shot\" "
"context managers created by :func:`contextmanager` to meet the requirement "
"that context managers support multiple invocations in order to be used as "
"decorators)."
msgstr ""
":func:`contextmanager` は :class:`ContextDecorator` を使っているので、 :func:"
"`contextmanager` で作ったコンテキストマネージャは :keyword:`with` 文だけでな"
"くデコレータとしても利用できます。デコレーターとして利用された場合、新しい "
"generator インスタンスが関数呼び出しのたびに暗黙に生成されます (このことに"
"よって、 :func:`contextmanager` によって作られたなにがしか「単発」コンテキス"
"トマネージャを、コンテキストマネージャがデコレータとして使われるためには多重"
"に呼び出されることをサポートする必要がある、という要件に合致させることが出来"
"ます。)"

#: ../../library/contextlib.rst:98
msgid "Use of :class:`ContextDecorator`."
msgstr ":class:`ContextDecorator` の使用。"

#: ../../library/contextlib.rst:104
msgid ""
"Similar to :func:`~contextlib.contextmanager`, but creates an :ref:"
"`asynchronous context manager <async-context-managers>`."
msgstr ""
":func:`~contextlib.contextmanager` と似ていますが、 :ref:`非同期コンテキスト"
"マネージャ (asynchronous context manager) <async-context-managers>` を生成し"
"ます。"

#: ../../library/contextlib.rst:107
msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`async with` statement asynchronous context managers, "
"without needing to create a class or separate :meth:`__aenter__` and :meth:"
"`__aexit__` methods. It must be applied to an :term:`asynchronous generator` "
"function."
msgstr ""
"この関数は :keyword:`async with` 文のための非同期コンテキストマネージャのファ"
"クトリ関数を定義するために利用できるデコレータ (:term:`decorator`) です。新し"
"いクラスや  :meth:`__aenter__` と :meth:`__aexit__` メソッドを個別に定義する"
"必要はありません。このデコレータは非同期ジェネレータ (:term:`asynchronous "
"generator`) 関数に適用しなければなりません。"

#: ../../library/contextlib.rst:113
msgid "A simple example::"
msgstr "簡単な例::"

#: ../../library/contextlib.rst:131
msgid ""
"Context managers defined with :func:`asynccontextmanager` can be used either "
"as decorators or with :keyword:`async with` statements::"
msgstr ""
":func:`asynccontextmanager` とともに定義されたコンテキストマネージャは、デコ"
"レータとして使うことも :keyword:`async with` 文と組み合わせて使うこともできま"
"す::"

#: ../../library/contextlib.rst:149
msgid ""
"When used as a decorator, a new generator instance is implicitly created on "
"each function call. This allows the otherwise \"one-shot\" context managers "
"created by :func:`asynccontextmanager` to meet the requirement that context "
"managers support multiple invocations in order to be used as decorators."
msgstr ""
"デコレータとして使われた場合は、各関数呼び出しに対して暗黙のうちに新しいジェ"
"ネレータインスタンスが生成されます。これにより、 :func:`asynccontextmanager` "
"で生成された単回使用のコンテキストマネージャが複数回呼び出し可能となり、コン"
"テキストマネージャをデコレータとして使うことができるための要件を満たすように"
"することができます。"

#: ../../library/contextlib.rst:154
msgid ""
"Async context managers created with :func:`asynccontextmanager` can be used "
"as decorators."
msgstr ""
":func:`asynccontextmanager` により生成された非同期コンテキストマネージャをデ"
"コレータとして使うことができるようになりました。"

#: ../../library/contextlib.rst:161
msgid ""
"Return a context manager that closes *thing* upon completion of the block.  "
"This is basically equivalent to::"
msgstr ""
"ブロックの完了時に *thing* を close するコンテキストマネージャを返します。こ"
"れは基本的に以下と等価です::"

#: ../../library/contextlib.rst:173
msgid "And lets you write code like this::"
msgstr ""
"そして、明示的に ``page`` を close する必要なしに、次のように書くことができま"
"す::"

#: ../../library/contextlib.rst:182
msgid ""
"without needing to explicitly close ``page``.  Even if an error occurs, "
"``page.close()`` will be called when the :keyword:`with` block is exited."
msgstr ""
"``page`` を明示的に close する必要は無く、エラーが発生した場合でも、 :"
"keyword:`with` ブロックを出るときに ``page.close()`` が呼ばれます。"

#: ../../library/contextlib.rst:188
msgid ""
"Return an async context manager that calls the ``aclose()`` method of "
"*thing* upon completion of the block.  This is basically equivalent to::"
msgstr ""
"ブロックの完了時に *thing* の ``aclose()`` メソッドを呼び出すような非同期コン"
"テキストマネージャを返します。これは基本的に以下と等価です::"

#: ../../library/contextlib.rst:200
msgid ""
"Significantly, ``aclosing()`` supports deterministic cleanup of async "
"generators when they happen to exit early by :keyword:`break` or an "
"exception.  For example::"
msgstr ""
"重要なことは、たとえば次の例のように :keyword:`break` や例外によって早期にブ"
"ロックが終了した場合に、 ``aclosing()`` は非同期ジェネレータの決定論的なク"
"リーンアップをサポートすることです::"

#: ../../library/contextlib.rst:211
msgid ""
"This pattern ensures that the generator's async exit code is executed in the "
"same context as its iterations (so that exceptions and context variables "
"work as expected, and the exit code isn't run after the lifetime of some "
"task it depends on)."
msgstr ""
"このパターンは、ジェネレータの非同期な終了のコードがイテレーション処理と同じ"
"コンテキストの中で実行されることを保証します (すなわち例外とコンテキスト変数"
"は期待通りに動作し、またジェネレータが依存するタスクの寿命が尽きたあとに終了"
"のコードが実行されることもありません)。"

#: ../../library/contextlib.rst:223
msgid ""
"Return a context manager that returns *enter_result* from ``__enter__``, but "
"otherwise does nothing. It is intended to be used as a stand-in for an "
"optional context manager, for example::"
msgstr ""
"*enter_result* を ``__enter__`` メソッドが返すだけで、その他は何もしないコン"
"テキストマネージャを返します。たとえば以下のように、ある機能を持った別のコン"
"テキストマネージャに対する、選択可能な代役として使われることが意図されていま"
"す::"

#: ../../library/contextlib.rst:237
msgid "An example using *enter_result*::"
msgstr "*enter_result* を使った例です::"

#: ../../library/contextlib.rst:250
msgid ""
"It can also be used as a stand-in for :ref:`asynchronous context managers "
"<async-context-managers>`::"
msgstr ""
":ref:`非同期コンテキストマネージャ <async-context-managers>` の代役として使う"
"こともできます::"

#: ../../library/contextlib.rst:266
msgid ":term:`asynchronous context manager` support was added."
msgstr ""
"非同期コンテキストマネージャ (:term:`asynchronous context manager`) のサポー"
"トが追加されました。"

#: ../../library/contextlib.rst:273
msgid ""
"Return a context manager that suppresses any of the specified exceptions if "
"they occur in the body of a :keyword:`!with` statement and then resumes "
"execution with the first statement following the end of the :keyword:`!with` "
"statement."
msgstr ""
":keyword:`!with` 文の内部で指定された例外の発生を抑えるコンテキストマネージャ"
"を返します。 :keyword:`!with` 文の後に続く最初の文から処理が再開されます。"

#: ../../library/contextlib.rst:278
msgid ""
"As with any other mechanism that completely suppresses exceptions, this "
"context manager should be used only to cover very specific errors where "
"silently continuing with program execution is known to be the right thing to "
"do."
msgstr ""
"ほかの完全に例外を抑制するメカニズム同様、このコンテキストマネージャは、黙っ"
"てプログラム実行を続けることが正しいことであるとわかっている、非常に限定的な"
"エラーをカバーする以上の使い方はしてはいけません。"

#: ../../library/contextlib.rst:283
msgid "For example::"
msgstr "例えば::"

#: ../../library/contextlib.rst:293
msgid "This code is equivalent to::"
msgstr "これは以下と等価です::"

#: ../../library/contextlib.rst:305 ../../library/contextlib.rst:345
#: ../../library/contextlib.rst:355 ../../library/contextlib.rst:372
msgid "This context manager is :ref:`reentrant <reentrant-cms>`."
msgstr ""
"このコンテキストマネージャは :ref:`再入可能(リエントラント) <reentrant-cms>` "
"です。"

#: ../../library/contextlib.rst:312
msgid ""
"Context manager for temporarily redirecting :data:`sys.stdout` to another "
"file or file-like object."
msgstr ""
":data:`sys.stdout` を一時的に別のファイルまたは file-like オブジェクトにリダ"
"イレクトするコンテキストマネージャです。"

#: ../../library/contextlib.rst:315
msgid ""
"This tool adds flexibility to existing functions or classes whose output is "
"hardwired to stdout."
msgstr ""
"このツールは、出力先が標準出力 (stdout) に固定されている既存の関数やクラスに"
"出力先の柔軟性を追加します。"

#: ../../library/contextlib.rst:318
msgid ""
"For example, the output of :func:`help` normally is sent to *sys.stdout*. "
"You can capture that output in a string by redirecting the output to an :"
"class:`io.StringIO` object. The replacement stream is returned from the "
"``__enter__`` method and so is available as the target of the :keyword:"
"`with` statement::"
msgstr ""
"たとえば、 :func:`help` の出力は通常標準出力 (*sys.stdout*) に送られます。出"
"力される文字列を :class:`io.StringIO` オブジェクトにリダイレクトすることに"
"よって捕捉することができます。代替の出力ストリームは ``__enter__`` メソッドに"
"よって返されるので、 :keyword:`with` 文のターゲットとして利用可能です::"

#: ../../library/contextlib.rst:328
msgid ""
"To send the output of :func:`help` to a file on disk, redirect the output to "
"a regular file::"
msgstr ""
":func:`help` の出力をディスク上のファイルに送るためには、出力を通常のファイル"
"にリダイレクトします::"

#: ../../library/contextlib.rst:335
msgid "To send the output of :func:`help` to *sys.stderr*::"
msgstr ""
":func:`help` の出力を標準エラー出力 (*sys.stderr*) に送るには以下のようにしま"
"す::"

#: ../../library/contextlib.rst:340
msgid ""
"Note that the global side effect on :data:`sys.stdout` means that this "
"context manager is not suitable for use in library code and most threaded "
"applications. It also has no effect on the output of subprocesses. However, "
"it is still a useful approach for many utility scripts."
msgstr ""
":data:`sys.stdout` のシステム全体にわたる副作用により、このコンテキストマネー"
"ジャはライブラリコードやマルチスレッドアプリケーションでの使用には適していま"
"せん。また、サブプロセスの出力に対しても効果がありません。そのような制限はあ"
"りますが、それでも多くのユーティリティスクリプトに対して有用なアプローチで"
"す。"

#: ../../library/contextlib.rst:352
msgid ""
"Similar to :func:`~contextlib.redirect_stdout` but redirecting :data:`sys."
"stderr` to another file or file-like object."
msgstr ""
":func:`~contextlib.redirect_stdout` と同じですが、標準エラー出力 (:data:`sys."
"stderr`) を別のファイルや file-like オブジェクトにリダイレクトします。"

#: ../../library/contextlib.rst:362
msgid ""
"Non parallel-safe context manager to change the current working directory. "
"As this changes a global state, the working directory, it is not suitable "
"for use in most threaded or async contexts. It is also not suitable for most "
"non-linear code execution, like generators, where the program execution is "
"temporarily relinquished -- unless explicitly desired, you should not yield "
"when this context manager is active."
msgstr ""
"現在の作業ディレクトリを変更するパラレル非安全なコンテキストマネージャです。"
"グローバルな状態である作業ディレクトリを変更するため、ほとんどのマルチスレッ"
"ドまたは非同期のコンテキストに対する利用は適切ではありません。また、プログラ"
"ムの実行権限を一時的に放棄するジェネレータのような、直線的でないコードを実行"
"する場合も適切ではありません -- 明確に必要でないかぎり、このコンテキストマ"
"ネージャがアクティブな状態で yield すべきではありません。"

#: ../../library/contextlib.rst:369
msgid ""
"This is a simple wrapper around :func:`~os.chdir`, it changes the current "
"working directory upon entering and restores the old one on exit."
msgstr ""
"これは :func:`~os.chdir` の単純なラッパーで、コンテキストに入るときに現在の作"
"業ディレクトリを変更し、終了時に元の作業ディレクトリを復元します。"

#: ../../library/contextlib.rst:379
msgid ""
"A base class that enables a context manager to also be used as a decorator."
msgstr ""
"コンテキストマネージャをデコレータとしても使用できるようにする基底クラスで"
"す。"

#: ../../library/contextlib.rst:381
msgid ""
"Context managers inheriting from ``ContextDecorator`` have to implement "
"``__enter__`` and ``__exit__`` as normal. ``__exit__`` retains its optional "
"exception handling even when used as a decorator."
msgstr ""
"``ContextDecorator`` から継承したコンテキストマネージャは、通常のコンテキスト"
"マネージャーと同じく ``__enter__`` および ``__exit__`` を実装する必要がありま"
"す。``__exit__`` はデコレータとして使用された場合でも例外をオプションの引数と"
"して受け取ります。"

#: ../../library/contextlib.rst:385
msgid ""
"``ContextDecorator`` is used by :func:`contextmanager`, so you get this "
"functionality automatically."
msgstr ""
":func:`contextmanager` は ``ContextDecorator`` を利用しているので、自動的にデ"
"コレーターとしても利用できるようになります。"

#: ../../library/contextlib.rst:388
msgid "Example of ``ContextDecorator``::"
msgstr "``ContextDecorator`` の例::"

#: ../../library/contextlib.rst:401 ../../library/contextlib.rst:473
msgid "The class can then be used like this::"
msgstr "このとき、クラスは次のように使うことができます::"

#: ../../library/contextlib.rst:419
msgid ""
"This change is just syntactic sugar for any construct of the following form::"
msgstr "これは次のような形のコードに対するシンタックスシュガーになります::"

#: ../../library/contextlib.rst:425
msgid "``ContextDecorator`` lets you instead write::"
msgstr "``ContextDecorator`` を使うと代わりに次のように書けます::"

#: ../../library/contextlib.rst:431
msgid ""
"It makes it clear that the ``cm`` applies to the whole function, rather than "
"just a piece of it (and saving an indentation level is nice, too)."
msgstr ""
"デコレーターを使うと、``cm`` が関数の一部ではなく全体に適用されていることが明"
"確になります (インデントレベルを1つ節約できるのもメリットです)。"

#: ../../library/contextlib.rst:434
msgid ""
"Existing context managers that already have a base class can be extended by "
"using ``ContextDecorator`` as a mixin class::"
msgstr ""
"すでに基底クラスを持っているコンテキストマネージャーも、``ContextDecorator`` "
"を mixin クラスとして利用することで拡張できます::"

#: ../../library/contextlib.rst:447
msgid ""
"As the decorated function must be able to be called multiple times, the "
"underlying context manager must support use in multiple :keyword:`with` "
"statements. If this is not the case, then the original construct with the "
"explicit :keyword:`!with` statement inside the function should be used."
msgstr ""
"デコレートされた関数が複数回呼び出せるように、内部のコンテキストマネージャー"
"は複数の :keyword:`with` 文に対応する必要があります。そうでないなら、明示的"
"な :keyword:`!with` 文を関数内で利用するべきです。"

#: ../../library/contextlib.rst:457
msgid ""
"Similar to :class:`ContextDecorator` but only for asynchronous functions."
msgstr ":class:`ContextDecorator` と同じですが、非同期関数専用のクラスです。"

#: ../../library/contextlib.rst:459
msgid "Example of ``AsyncContextDecorator``::"
msgstr "``AsyncContextDecorator`` の使用例::"

#: ../../library/contextlib.rst:498
msgid ""
"A context manager that is designed to make it easy to programmatically "
"combine other context managers and cleanup functions, especially those that "
"are optional or otherwise driven by input data."
msgstr ""
"他の、特にオプションであったり入力に依存するようなコンテキストマネージャーや"
"クリーンアップ関数を動的に組み合わせるためのコンテキストマネージャーです。"

#: ../../library/contextlib.rst:502
msgid ""
"For example, a set of files may easily be handled in a single with statement "
"as follows::"
msgstr "例えば、複数のファイルを1つの with 文で簡単に扱うことができます::"

#: ../../library/contextlib.rst:511
msgid ""
"The :meth:`__enter__` method returns the :class:`ExitStack` instance, and "
"performs no additional operations."
msgstr ""
":meth:`__enter__` メソッドは :class:`ExitStack` インスタンスを返し、それ以外"
"のいかなる処理も行いません。"

#: ../../library/contextlib.rst:514
msgid ""
"Each instance maintains a stack of registered callbacks that are called in "
"reverse order when the instance is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement). Note that callbacks are *not* "
"invoked implicitly when the context stack instance is garbage collected."
msgstr ""
"各インスタンスは登録されたコールバックのスタックを管理し、インスタンスが (明"
"示的に、あるいは :keyword:`with` 文の終わりに暗黙的に)  close されるときに逆"
"順でそれを呼び出します。コンテキストスタックのインスタンスが暗黙的にガベージ"
"コレクトされたときには callback は呼び出され **ません** 。"

#: ../../library/contextlib.rst:519
msgid ""
"This stack model is used so that context managers that acquire their "
"resources in their ``__init__`` method (such as file objects) can be handled "
"correctly."
msgstr ""
"このスタックモデルは、(file オブジェクトのように) ``__init__`` メソッドでリ"
"ソースを確保するコンテキストマネージャーを正しく扱うためのものです。"

#: ../../library/contextlib.rst:523
msgid ""
"Since registered callbacks are invoked in the reverse order of registration, "
"this ends up behaving as if multiple nested :keyword:`with` statements had "
"been used with the registered set of callbacks. This even extends to "
"exception handling - if an inner callback suppresses or replaces an "
"exception, then outer callbacks will be passed arguments based on that "
"updated state."
msgstr ""
"登録されたコールバックが登録の逆順で実行されるので、複数のネストされた :"
"keyword:`with` 文を利用するのと同じ振る舞いをします。これは例外処理にも適用さ"
"れます。内側のコールバックが例外を抑制したり置き換えたりした場合、外側のコー"
"ルバックには更新された状態に応じた引数が渡されます。"

#: ../../library/contextlib.rst:530
msgid ""
"This is a relatively low level API that takes care of the details of "
"correctly unwinding the stack of exit callbacks. It provides a suitable "
"foundation for higher level context managers that manipulate the exit stack "
"in application specific ways."
msgstr ""
"これは正しく exit callback の stack を巻き戻すための、比較的低レベルな API で"
"す。アプリケーション独自のより高レベルなコンテキストマネージャーを作るための"
"基板として使うのに適しています。"

#: ../../library/contextlib.rst:539
msgid ""
"Enters a new context manager and adds its :meth:`__exit__` method to the "
"callback stack. The return value is the result of the context manager's own :"
"meth:`__enter__` method."
msgstr ""
"新しいコンテキストマネージャーに enter し、その :meth:`__exit__` method を"
"コールバックスタックに追加します。渡されたコンテキストマネージャーの :meth:"
"`__enter__` メソッドの戻り値を返します。"

#: ../../library/contextlib.rst:543
msgid ""
"These context managers may suppress exceptions just as they normally would "
"if used directly as part of a :keyword:`with` statement."
msgstr ""
"コンテキストマネージャーは、普段 :keyword:`with` 文で利用された時と同じよう"
"に、例外を抑制することができます。"

#: ../../library/contextlib.rst:546
msgid ""
"Raises :exc:`TypeError` instead of :exc:`AttributeError` if *cm* is not a "
"context manager."
msgstr ""
"*cm* がコンテキストマネージャでなかった場合、 :exc:`AttributeError` の代わり"
"に :exc:`TypeError` 例外を送出します。"

#: ../../library/contextlib.rst:552
msgid "Adds a context manager's :meth:`__exit__` method to the callback stack."
msgstr ""
"コンテキストマネージャーの :meth:`__exit__` メソッドをコールバックスタックに"
"追加します。"

#: ../../library/contextlib.rst:554
msgid ""
"As ``__enter__`` is *not* invoked, this method can be used to cover part of "
"an :meth:`__enter__` implementation with a context manager's own :meth:"
"`__exit__` method."
msgstr ""
"このメソッドは ``__enter__`` を **呼び出さない** ので、コンテキストマネー"
"ジャーを実装するときに、 :meth:`__enter__` の実装の一部を自身の :meth:"
"`__exit__` メソッドでカバーするために利用できます。"

#: ../../library/contextlib.rst:558
msgid ""
"If passed an object that is not a context manager, this method assumes it is "
"a callback with the same signature as a context manager's :meth:`__exit__` "
"method and adds it directly to the callback stack."
msgstr ""
"コンテキストマネージャーではないオブジェクトが渡された場合、このメソッドはそ"
"のオブジェクトをコンテキストマネージャーの :meth:`__exit__` メソッドと同じシ"
"グネチャを持つコールバック関数だと仮定して、直接コールバックスタックに追加し"
"ます。"

#: ../../library/contextlib.rst:562
msgid ""
"By returning true values, these callbacks can suppress exceptions the same "
"way context manager :meth:`__exit__` methods can."
msgstr ""
"それらのコールバック関数も、コンテキストマネージャーの :meth:`__exit__` と同"
"じく、 true 値を返すことで例外を抑制することができます。"

#: ../../library/contextlib.rst:565
msgid ""
"The passed in object is returned from the function, allowing this method to "
"be used as a function decorator."
msgstr ""
"この関数はデコレータとしても使えるように、受け取ったオブジェクトをそのまま返"
"します。"

#: ../../library/contextlib.rst:570
msgid ""
"Accepts an arbitrary callback function and arguments and adds it to the "
"callback stack."
msgstr "任意の関数と引数を受け取り、コールバックスタックに追加します。"

#: ../../library/contextlib.rst:573
msgid ""
"Unlike the other methods, callbacks added this way cannot suppress "
"exceptions (as they are never passed the exception details)."
msgstr ""
"他のメソッドと異なり、このメソッドで追加されたコールバックは例外を抑制しませ"
"ん (例外の詳細も渡されません)。"

#: ../../library/contextlib.rst:576
msgid ""
"The passed in callback is returned from the function, allowing this method "
"to be used as a function decorator."
msgstr ""
"この関数はデコレータとしても使えるように、受け取った callback をそのまま返し"
"ます。"

#: ../../library/contextlib.rst:581
msgid ""
"Transfers the callback stack to a fresh :class:`ExitStack` instance and "
"returns it. No callbacks are invoked by this operation - instead, they will "
"now be invoked when the new stack is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement)."
msgstr ""
"コールバックスタックを新しい :class:`ExitStack` インスタンスに移して、それを"
"返します。このメソッドは callback を実行しません。代わりに、新しい stack が "
"(明示的に、あるいは :keyword:`with` 文の終わりに暗黙的に) close されるときに"
"実行されます。"

#: ../../library/contextlib.rst:586
msgid ""
"For example, a group of files can be opened as an \"all or nothing\" "
"operation as follows::"
msgstr ""
"例えば、複数のファイルを \"all or nothing\" に開く処理を次のように書けます::"

#: ../../library/contextlib.rst:600
msgid ""
"Immediately unwinds the callback stack, invoking callbacks in the reverse "
"order of registration. For any context managers and exit callbacks "
"registered, the arguments passed in will indicate that no exception occurred."
msgstr ""
"すぐにコールバックスタックを巻き戻し、コールバック関数を登録の逆順に呼び出し"
"ます。登録されたすべてのコンテキストマネージャーと終了 callback に、例外が起"
"こらなかった場合の引数が渡されます。"

#: ../../library/contextlib.rst:607
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>`, similar to :"
"class:`ExitStack`, that supports combining both synchronous and asynchronous "
"context managers, as well as having coroutines for cleanup logic."
msgstr ""
":class:`ExitStack` に似た :ref:`非同期コンテキストマネージャ <async-context-"
"managers>` です。スタック上で同期と非同期の両方のコンテキストマネージャの組み"
"合わせをサポートします。また、後処理のためのコルーチンも持っています。"

#: ../../library/contextlib.rst:612
msgid ""
"The :meth:`close` method is not implemented, :meth:`aclose` must be used "
"instead."
msgstr ""
":meth:`close` メソッドは実装されていません。代わりに :meth:`aclose` を使って"
"ください。"

#: ../../library/contextlib.rst:617
msgid ""
"Similar to :meth:`enter_context` but expects an asynchronous context manager."
msgstr ""
":meth:`enter_context` と同様のメソッドですが、非同期コンテキストマネージャを"
"受け取ります。"

#: ../../library/contextlib.rst:620
msgid ""
"Raises :exc:`TypeError` instead of :exc:`AttributeError` if *cm* is not an "
"asynchronous context manager."
msgstr ""
"*cm* が非同期コンテキストマネージャでなかった場合、 :exc:`AttributeError` の"
"代わりに :exc:`TypeError` 例外を送出します。"

#: ../../library/contextlib.rst:626
msgid ""
"Similar to :meth:`push` but expects either an asynchronous context manager "
"or a coroutine function."
msgstr ""
":meth:`push` と同様のメソッドですが、非同期コンテキストマネージャかコルーチン"
"関数を受け取ります。"

#: ../../library/contextlib.rst:631
msgid "Similar to :meth:`callback` but expects a coroutine function."
msgstr ""
":meth:`callback` と同様のメソッドですが、コルーチン関数を受け取ります。"

#: ../../library/contextlib.rst:635
msgid "Similar to :meth:`close` but properly handles awaitables."
msgstr ""
":meth:`close` と同様のメソッドですが、待ち受け可能オブジェクト (awaitables) "
"を適切に処理します。"

#: ../../library/contextlib.rst:637
msgid "Continuing the example for :func:`asynccontextmanager`::"
msgstr ":func:`asynccontextmanager` の使用例の続きです::"

#: ../../library/contextlib.rst:649
msgid "Examples and Recipes"
msgstr "例とレシピ"

#: ../../library/contextlib.rst:651
msgid ""
"This section describes some examples and recipes for making effective use of "
"the tools provided by :mod:`contextlib`."
msgstr ""
"このセクションでは、 :mod:`contextlib` が提供するツールの効果的な使い方を示す"
"例とレシピを紹介します。"

#: ../../library/contextlib.rst:656
msgid "Supporting a variable number of context managers"
msgstr "可変数個のコンテキストマネージャーをサポートする"

#: ../../library/contextlib.rst:658
msgid ""
"The primary use case for :class:`ExitStack` is the one given in the class "
"documentation: supporting a variable number of context managers and other "
"cleanup operations in a single :keyword:`with` statement. The variability "
"may come from the number of context managers needed being driven by user "
"input (such as opening a user specified collection of files), or from some "
"of the context managers being optional::"
msgstr ""
":class:`ExitStack` の第一のユースケースは、クラスのドキュメントにかかれている"
"通り、一つの :keyword:`with` 文で可変数個のコンテキストマネージャーや他のク"
"リーンアップ関数をサポートすることです。ユーザーの入力 (指定された複数個の"
"ファイルを開く場合など) に応じて複数個のコンテキストマネージャーが必要となる"
"場合や、いくつかのコンテキストマネージャーがオプションとなる場合に、可変数個"
"のコンテキストマネージャーが必要になります::"

#: ../../library/contextlib.rst:673
msgid ""
"As shown, :class:`ExitStack` also makes it quite easy to use :keyword:`with` "
"statements to manage arbitrary resources that don't natively support the "
"context management protocol."
msgstr ""
"上の例にあるように、 :class:`ExitStack` はコンテキストマネージャープロトコル"
"をサポートしていないリソースの管理を :keyword:`with` 文を使って簡単に行えるよ"
"うにします。"

#: ../../library/contextlib.rst:679
msgid "Catching exceptions from ``__enter__`` methods"
msgstr "``__enter__`` メソッドからの例外をキャッチする"

#: ../../library/contextlib.rst:681
msgid ""
"It is occasionally desirable to catch exceptions from an ``__enter__`` "
"method implementation, *without* inadvertently catching exceptions from the :"
"keyword:`with` statement body or the context manager's ``__exit__`` method. "
"By using :class:`ExitStack` the steps in the context management protocol can "
"be separated slightly in order to allow this::"
msgstr ""
"稀に、 ``__enter__`` メソッドからの例外を、 :keyword:`with` 文の body やコン"
"テキストマネージャーの ``__exit__`` メソッドからの例外は間違えて捕まえないよ"
"うに、 catch したい場合があります。 :class:`ExitStack` を使って、コンテキスト"
"マネージャープロトコル内のステップを分離することができます::"

#: ../../library/contextlib.rst:696
msgid ""
"Actually needing to do this is likely to indicate that the underlying API "
"should be providing a direct resource management interface for use with :"
"keyword:`try`/:keyword:`except`/:keyword:`finally` statements, but not all "
"APIs are well designed in that regard. When a context manager is the only "
"resource management API provided, then :class:`ExitStack` can make it easier "
"to handle various situations that can't be handled directly in a :keyword:"
"`with` statement."
msgstr ""
"実際のところ、このようなコードが必要になるのならば、利用している API 側で :"
"keyword:`try`/:keyword:`except`/:keyword:`finally` 文を使った直接的なリソース"
"管理インターフェースを提供するべきです。しかし、すべての API がそのようによく"
"設計されているとは限りません。もしコンテキストマネージャーが提供されている唯"
"一のリソース管理APIであるなら、 :class:`ExitStack` を使って :keyword:`with` "
"文を使って処理することができない様々なシチュエーションの処理をすることができ"
"ます。"

#: ../../library/contextlib.rst:706
msgid "Cleaning up in an ``__enter__`` implementation"
msgstr "``__enter__`` 実装内のクリーンアップ"

#: ../../library/contextlib.rst:708
msgid ""
"As noted in the documentation of :meth:`ExitStack.push`, this method can be "
"useful in cleaning up an already allocated resource if later steps in the :"
"meth:`__enter__` implementation fail."
msgstr ""
":meth:`ExitStack.push` のドキュメントで言及したとおり、このメソッドはすでに獲"
"得したリソースを、 :meth:`__enter__` メソッドの残りのステップが失敗した時にク"
"リーンアップするために利用することができます。"

#: ../../library/contextlib.rst:712
msgid ""
"Here's an example of doing this for a context manager that accepts resource "
"acquisition and release functions, along with an optional validation "
"function, and maps them to the context management protocol::"
msgstr ""
"次の例では、リソースの確保と開放の関数に加えて、オプションのバリデーション関"
"数を受け取るコンテキストマネージャーで、この方法を使ってコンテキストマネー"
"ジャープロトコルを提供しています::"

#: ../../library/contextlib.rst:752
msgid "Replacing any use of ``try-finally`` and flag variables"
msgstr "``try-finally`` + flag 変数パターンを置き換える"

#: ../../library/contextlib.rst:754
msgid ""
"A pattern you will sometimes see is a ``try-finally`` statement with a flag "
"variable to indicate whether or not the body of the ``finally`` clause "
"should be executed. In its simplest form (that can't already be handled just "
"by using an ``except`` clause instead), it looks something like this::"
msgstr ""
"``try-finally`` 文に、``finally`` 句の内容を実行するかどうかを示すフラグ変数"
"を組み合わせたパターンを目にすることがあるかもしれません。一番シンプルな (単"
"に ``except`` 句を使うだけでは処理できない) ケースでは次のようなコードになり"
"ます::"

#: ../../library/contextlib.rst:768
msgid ""
"As with any ``try`` statement based code, this can cause problems for "
"development and review, because the setup code and the cleanup code can end "
"up being separated by arbitrarily long sections of code."
msgstr ""
"``try`` 文を使ったコードでは、セットアップとクリーンアップのコードが任意の長"
"さのコードで分離してしまうので、開発者やレビューアにとって問題になりえます。"

#: ../../library/contextlib.rst:772
msgid ""
":class:`ExitStack` makes it possible to instead register a callback for "
"execution at the end of a ``with`` statement, and then later decide to skip "
"executing that callback::"
msgstr ""
":class:`ExitStack` を使えば、代わりに ``with`` 文の終わりに実行されるコール"
"バックを登録し、後でそのコールバックをスキップするかどうかを決定できます::"

#: ../../library/contextlib.rst:784
msgid ""
"This allows the intended cleanup up behaviour to be made explicit up front, "
"rather than requiring a separate flag variable."
msgstr ""
"これにより、別のフラグ変数を使う代わりに、必要なクリーンアップ処理を手前に明"
"示しておくことができます。"

#: ../../library/contextlib.rst:787
msgid ""
"If a particular application uses this pattern a lot, it can be simplified "
"even further by means of a small helper class::"
msgstr ""
"もしあるアプリケーションがこのパターンを多用するのであれば、小さいヘルパーク"
"ラスを導入してよりシンプルにすることができます::"

#: ../../library/contextlib.rst:805
msgid ""
"If the resource cleanup isn't already neatly bundled into a standalone "
"function, then it is still possible to use the decorator form of :meth:"
"`ExitStack.callback` to declare the resource cleanup in advance::"
msgstr ""
"もしリソースのクリーンアップが単体の関数にまとまってない場合でも、 :meth:"
"`ExitStack.callback` のデコレーター形式を利用してリソース開放処理を宣言するこ"
"とができます::"

#: ../../library/contextlib.rst:820
msgid ""
"Due to the way the decorator protocol works, a callback function declared "
"this way cannot take any parameters. Instead, any resources to be released "
"must be accessed as closure variables."
msgstr ""
"デコレータープロトコルの使用上、このように宣言されたコールバック関数は引数を"
"取ることができません。その代わりに、リリースするリソースをクロージャー変数と"
"してアクセスできる必要があります。"

#: ../../library/contextlib.rst:826
msgid "Using a context manager as a function decorator"
msgstr "コンテキストマネージャーを関数デコレーターとして使う"

#: ../../library/contextlib.rst:828
msgid ""
":class:`ContextDecorator` makes it possible to use a context manager in both "
"an ordinary ``with`` statement and also as a function decorator."
msgstr ""
":class:`ContextDecorator` はコンテキストマネージャーを通常の ``with`` 文に加"
"えて関数デコレーターとしても利用できるようにします。"

#: ../../library/contextlib.rst:831
msgid ""
"For example, it is sometimes useful to wrap functions or groups of "
"statements with a logger that can track the time of entry and time of exit.  "
"Rather than writing both a function decorator and a context manager for the "
"task, inheriting from :class:`ContextDecorator` provides both capabilities "
"in a single definition::"
msgstr ""
"例えば、関数やまとまった文を、そこに入った時と出た時の時間をトラックするロ"
"ガーでラップしたい場合があります。そのために関数デコレーターとコンテキストマ"
"ネージャーを別々に書く代わりに、 :class:`ContextDecorator` を継承すると1つの"
"定義で両方の機能を提供できます::"

#: ../../library/contextlib.rst:852
msgid "Instances of this class can be used as both a context manager::"
msgstr "このクラスのインスタンスはコンテキストマネージャーとしても利用でき::"

#: ../../library/contextlib.rst:858
msgid "And also as a function decorator::"
msgstr "また関数デコレーターとしても利用できます::"

#: ../../library/contextlib.rst:865
msgid ""
"Note that there is one additional limitation when using context managers as "
"function decorators: there's no way to access the return value of :meth:"
"`__enter__`. If that value is needed, then it is still necessary to use an "
"explicit ``with`` statement."
msgstr ""
"コンテキストマネージャーを関数デコレーターとして使う場合、 :meth:`__enter__` "
"メソッドの戻り値にアクセスする手段がないという制限があることに注意してくださ"
"い。もしその値が必要であれば、明示的な ``with`` 文を使う必要があります。"

#: ../../library/contextlib.rst:873
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" ステートメント"

#: ../../library/contextlib.rst:873
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python の :keyword:`with` 文の仕様、背景、および例が記載されています。"

#: ../../library/contextlib.rst:879
msgid "Single use, reusable and reentrant context managers"
msgstr "単回使用、再利用可能、およびリエントラントなコンテキストマネージャ"

#: ../../library/contextlib.rst:881
msgid ""
"Most context managers are written in a way that means they can only be used "
"effectively in a :keyword:`with` statement once. These single use context "
"managers must be created afresh each time they're used - attempting to use "
"them a second time will trigger an exception or otherwise not work correctly."
msgstr ""
"ほとんどのコンテキストマネージャは、 :keyword:`with` 文の中で一度だけ使われる"
"ような場合に効果的になるように書かれています。これら単回使用のコンテキストマ"
"ネージャは毎回新規に生成されなければなりません - それらを再利用しようとする"
"と、例外を引き起こすか、正しく動作しません。"

#: ../../library/contextlib.rst:887
msgid ""
"This common limitation means that it is generally advisable to create "
"context managers directly in the header of the :keyword:`with` statement "
"where they are used (as shown in all of the usage examples above)."
msgstr ""
"この共通の制限が意味することは、コンテキストマネージャは (上記すべての使用例"
"に示すとおり) 一般に :keyword:`with` 文のヘッダ部分で直接生成することが推奨さ"
"れるということです。"

#: ../../library/contextlib.rst:891
msgid ""
"Files are an example of effectively single use context managers, since the "
"first :keyword:`with` statement will close the file, preventing any further "
"IO operations using that file object."
msgstr ""
"ファイルオブジェクトは単回使用のコンテキストマネージャ有効に利用した例です。"
"最初の :keyword:`with` 文によりファイルがクローズされ、それ以降そのファイルオ"
"ブジェクトに対するすべての IO 操作を防止します。"

#: ../../library/contextlib.rst:895
msgid ""
"Context managers created using :func:`contextmanager` are also single use "
"context managers, and will complain about the underlying generator failing "
"to yield if an attempt is made to use them a second time::"
msgstr ""
":func:`contextmanager` により生成されたコンテキストマネージャも単回使用のコン"
"テキスト  マネージャです。二回目に使おうとした場合、内部にあるジェネレータが"
"値の生成に失敗したと訴えるでしょう::"

#: ../../library/contextlib.rst:923
msgid "Reentrant context managers"
msgstr "リエントラントなコンテキストマネージャ"

#: ../../library/contextlib.rst:925
msgid ""
"More sophisticated context managers may be \"reentrant\". These context "
"managers can not only be used in multiple :keyword:`with` statements, but "
"may also be used *inside* a :keyword:`!with` statement that is already using "
"the same context manager."
msgstr ""
"より洗練されたコンテキストマネージャには\"リエントラント\"なものがあります。"
"そのようなコンテキストマネージャは、複数の :keyword:`with` 文で使えるだけでな"
"く、同じコンテキストマネージャをすでに使っている :keyword:`!with` 文の *内部"
"* でも使うことができます。"

#: ../../library/contextlib.rst:930
msgid ""
":class:`threading.RLock` is an example of a reentrant context manager, as "
"are :func:`suppress`, :func:`redirect_stdout`, and :func:`chdir`. Here's a "
"very simple example of reentrant use::"
msgstr ""
":class:`threading.RLock` はリエントラントなコンテキストマネージャの例であり、"
"また :func:`suppress`, :func:`redirect_stdout`, そして :func:`chdir` もリエン"
"トラントです。以下はリエントラントな利用法の非常に単純な例です::"

#: ../../library/contextlib.rst:949
msgid ""
"Real world examples of reentrancy are more likely to involve multiple "
"functions calling each other and hence be far more complicated than this "
"example."
msgstr ""
"リエントラントな性質の実例はお互いを呼び出しあう複数の関数を含んでいる可能性"
"が高く、したがってこの例よりもはるかに複雑です。"

#: ../../library/contextlib.rst:953
msgid ""
"Note also that being reentrant is *not* the same thing as being thread "
"safe. :func:`redirect_stdout`, for example, is definitely not thread safe, "
"as it makes a global modification to the system state by binding :data:`sys."
"stdout` to a different stream."
msgstr ""
"リエントラントであることはスレッドセーフであることと同じ *ではない* ことには"
"注意が必要です。たとえば :func:`redirect_stdout` は、 :data:`sys.stdout` を異"
"なるストリームに束縛することによりシステムの状態に対してグローバルな変更を行"
"うことから、明らかにスレッドセーフではありません。"

#: ../../library/contextlib.rst:962
msgid "Reusable context managers"
msgstr "再利用可能なコンテキストマネージャ"

#: ../../library/contextlib.rst:964
msgid ""
"Distinct from both single use and reentrant context managers are "
"\"reusable\" context managers (or, to be completely explicit, \"reusable, "
"but not reentrant\" context managers, since reentrant context managers are "
"also reusable). These context managers support being used multiple times, "
"but will fail (or otherwise not work correctly) if the specific context "
"manager instance has already been used in a containing with statement."
msgstr ""
"単回使用のコンテキストマネージャとリエントラントなコンテキストマネージャのい"
"ずれとも異なるタイプに \"再利用可能\" なコンテキストマネージャがあります (あ"
"るいは、より明確には、\"再利用可能だがリエントラントでない\" コンテキストマ"
"ネージャです。リエントラントなコンテキストマネージャもまた再利用可能だからで"
"す)。再利用可能なコンテキストマネージャは複数回利用をサポートしますが、同じコ"
"ンテキストマネージャのインスタンスがすでに with 文で使われている場合には失敗"
"します (もしくは正しく動作しません)。"

#: ../../library/contextlib.rst:971
msgid ""
":class:`threading.Lock` is an example of a reusable, but not reentrant, "
"context manager (for a reentrant lock, it is necessary to use :class:"
"`threading.RLock` instead)."
msgstr ""
":class:`threading.Lock` は再利用可能だがリエントラントでないコンテキストマ"
"ネージャの例です (リエントラントなロックのためには :class:`threading.RLock` "
"を代わりに使う必要があります)。"

#: ../../library/contextlib.rst:975
msgid ""
"Another example of a reusable, but not reentrant, context manager is :class:"
"`ExitStack`, as it invokes *all* currently registered callbacks when leaving "
"any with statement, regardless of where those callbacks were added::"
msgstr ""
"再利用可能だがリエントラントでないコンテキストマネージャのもうひとつの例は :"
"class:`ExitStack` です。これは現在登録されている *全ての* コールバック関数"
"を、どこで登録されたかにかかわらず、呼び出します::"

#: ../../library/contextlib.rst:1006
msgid ""
"As the output from the example shows, reusing a single stack object across "
"multiple with statements works correctly, but attempting to nest them will "
"cause the stack to be cleared at the end of the innermost with statement, "
"which is unlikely to be desirable behaviour."
msgstr ""
"例における出力が示すように、ひとつのスタックオブジェクトを複数の with 文で再"
"利用しても正しく動作します。しかし入れ子にして使った場合は、一番内側の with "
"文を抜ける際にスタックが空になります。これは望ましい動作とは思えません。"

#: ../../library/contextlib.rst:1011
msgid ""
"Using separate :class:`ExitStack` instances instead of reusing a single "
"instance avoids that problem::"
msgstr ""
"ひとつの :class:`ExitStack` インスタンスを再利用する代わりに複数のインスタン"
"スを使うことにより、この問題は回避することができます::"
