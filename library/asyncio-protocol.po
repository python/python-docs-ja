# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-14 13:35+0900\n"
"PO-Revision-Date: 2018-06-29 17:39+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-protocol.rst:5
msgid "Transports and protocols (callback based API)"
msgstr ""

#: ../../library/asyncio-protocol.rst:7
msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr ""

#: ../../library/asyncio-protocol.rst:9
msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr ""

#: ../../library/asyncio-protocol.rst:14
msgid "Transports"
msgstr "ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆ"

#: ../../library/asyncio-protocol.rst:16
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels.  You generally won't instantiate a "
"transport yourself; instead, you will call an :class:`AbstractEventLoop` "
"method which will create the transport and try to initiate the underlying "
"communication channel, calling you back when it succeeds."
msgstr ""
"ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã¯ã€:mod:`asyncio` "
"ãŒæä¾›ã™ã‚‹ã€ã•ã¾ã–ã¾ãªç¨®é¡ã®é€šä¿¡ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æŠ½è±¡åŒ–ã™ã‚‹ã‚¯ãƒ©ã‚¹ç¾¤ã§ã™ã€‚é€šå¸¸ã‚ãªãŸè‡ªèº«ãŒç›´æ¥ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ã“ã¨ã¯ãªãã€:class:`AbstractEventLoop`"
" ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã¨ãã®ä¸‹å±¤ã®é€šä¿¡ãƒãƒ£ãƒ³ãƒãƒ«ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒä½œæˆã•ã‚Œã€æˆåŠŸæ™‚ã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒè¿”ã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:22
msgid ""
"Once the communication channel is established, a transport is always paired "
"with a :ref:`protocol <asyncio-protocol>` instance.  The protocol can then "
"call the transport's methods for various purposes."
msgstr ""
"ã„ã£ãŸã‚“é€šä¿¡ãƒãƒ£ãƒ³ãƒãƒ«ãŒç¢ºç«‹ã•ã‚Œã‚‹ã¨ã€ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã¯å¸¸ã« :ref:`ãƒ—ãƒ­ãƒˆã‚³ãƒ« <asyncio-protocol>` "
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã®ãƒšã‚¢ã‚’æˆã—ã¾ã™ã€‚ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ãã®å¾Œã•ã¾ã–ã¾ãªç”¨é€”ã®ãŸã‚ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:26
msgid ""
":mod:`asyncio` currently implements transports for TCP, UDP, SSL, and "
"subprocess pipes.  The methods available on a transport depend on the "
"transport's kind."
msgstr ""
":mod:`asyncio` ã¯ç¾åœ¨ TCPã€UDPã€SSL "
"ãŠã‚ˆã³ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ãƒ‘ã‚¤ãƒ—ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚åˆ©ç”¨å¯èƒ½ãªãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã®ç¨®é¡ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:30
msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr "ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã‚¯ãƒ©ã‚¹ã¯ :ref:`ã‚¹ãƒ¬ãƒƒãƒ‰å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ <asyncio-multithreading>`ã€‚"

#: ../../library/asyncio-protocol.rst:32
msgid "The socket option ``TCP_NODELAY`` is now set by default."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® ``TCP_NODELAY``Â ãŒè¨­å®šã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/asyncio-protocol.rst:37
msgid "BaseTransport"
msgstr "BaseTransport"

#: ../../library/asyncio-protocol.rst:41
msgid "Base class for transports."
msgstr "ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/asyncio-protocol.rst:45
msgid ""
"Close the transport.  If the transport has a buffer for outgoing data, "
"buffered data will be flushed asynchronously.  No more data will be "
"received.  After all buffered data is flushed, the protocol's "
":meth:`connection_lost` method will be called with :const:`None` as its "
"argument."
msgstr ""
"ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆãŒç™ºä¿¡ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚’æŒã£ã¦ã„ãŸå ´åˆã€ãƒãƒƒãƒ•ã‚¡ãƒ¼ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã¯éåŒæœŸã«ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥é™ãƒ‡ãƒ¼ã‚¿ã¯å—ä¿¡ã•ã‚Œã¾ã›ã‚“ã€‚ãƒãƒƒãƒ•ã‚¡ãƒ¼ã•ã‚Œã¦ã„ãŸãƒ‡ãƒ¼ã‚¿ãŒã™ã¹ã¦ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸå¾Œã€ãã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®"
" :meth:`connection_lost` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¼•æ•° :const:`None` ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:53
msgid "Return ``True`` if the transport is closing or is closed."
msgstr "ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã‚’é–‰ã˜ã¦ã„ã‚‹æœ€ä¸­ã‹é–‰ã˜ã¦ã„ãŸå ´åˆ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:59
msgid ""
"Return optional transport information.  *name* is a string representing the "
"piece of transport-specific information to get, *default* is the value to "
"return if the information doesn't exist."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆæƒ…å ±ã‚’è¿”ã—ã¾ã™ã€‚*name* ã¯å–å¾—ã—ãŸãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆå›ºæœ‰ã®æƒ…å ±ã‚’è¡¨ã™æ–‡å­—åˆ—ã§ã€*default* "
"ã¯æƒ…å ±ãŒå­˜åœ¨ã—ãªã‹ã£ãŸã¨ãã«è¿”ã™å€¤ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:63
msgid ""
"This method allows transport implementations to easily expose channel-"
"specific information."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã®å®Ÿè£…ã«å®¹æ˜“ã«ãƒãƒ£ãƒ³ãƒãƒ«å›ºæœ‰ã®æƒ…å ±ã‚’æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:66
msgid "socket:"
msgstr "ã‚½ã‚±ãƒƒãƒˆ:"

#: ../../library/asyncio-protocol.rst:68
msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``: ã‚½ã‚±ãƒƒãƒˆãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ãƒªãƒ¢ãƒ¼ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã€:meth:`socket.socket.getpeername` "
"ã®çµæœã«ãªã‚Šã¾ã™ (ã‚¨ãƒ©ãƒ¼ã®ã¨ãã¯ ``None``)"

#: ../../library/asyncio-protocol.rst:70
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: :class:`socket.socket` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚Šã¾ã™"

#: ../../library/asyncio-protocol.rst:71
msgid ""
"``'sockname'``: the socket's own address, result of "
":meth:`socket.socket.getsockname`"
msgstr ""
"``'sockname'``: ã‚½ã‚±ãƒƒãƒˆè‡ªèº«ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã€:meth:`socket.socket.getsockname` ã®çµæœã«ãªã‚Šã¾ã™"

#: ../../library/asyncio-protocol.rst:74
msgid "SSL socket:"
msgstr "SSL ã‚½ã‚±ãƒƒãƒˆ:"

#: ../../library/asyncio-protocol.rst:76
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of "
":meth:`ssl.SSLSocket.compression`"
msgstr ""
"``'compression'``: åœ§ç¸®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã€:meth:`ssl.SSLSocket.compression` "
"ã®çµæœã«ãªã‚Šã¾ã™ã€‚åœ§ç¸®ã•ã‚Œã¦ã„ãªã„ã¨ãã¯ ``None`` ã«ãªã‚Šã¾ã™"

#: ../../library/asyncio-protocol.rst:79
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``: 3 å€‹ã®å€¤ (ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹æš—å·ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®åç§°ã€ä½¿ç”¨ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ SSL "
"ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€ãŠã‚ˆã³ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ç§˜å¯†éµã®ãƒ“ãƒƒãƒˆæ•°) ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã§ã€:meth:`ssl.SSLSocket.cipher` "
"ã®çµæœã«ãªã‚Šã¾ã™"

#: ../../library/asyncio-protocol.rst:83
msgid ""
"``'peercert'``: peer certificate; result of "
":meth:`ssl.SSLSocket.getpeercert`"
msgstr "``'peercert'``: ãƒ”ã‚¢ã®è¨¼æ˜æ›¸ã§ã€:meth:`ssl.SSLSocket.getpeercert` ã®çµæœã«ãªã‚Šã¾ã™"

#: ../../library/asyncio-protocol.rst:85
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: :class:`ssl.SSLContext` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚Šã¾ã™"

#: ../../library/asyncio-protocol.rst:86
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr ""
"``'ssl_object'``: :class:`ssl.SSLObject` ã¾ãŸã¯ :class:`ssl.SSLSocket` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹"

#: ../../library/asyncio-protocol.rst:89
msgid "pipe:"
msgstr "ãƒ‘ã‚¤ãƒ—:"

#: ../../library/asyncio-protocol.rst:91
msgid "``'pipe'``: pipe object"
msgstr "``'pipe'``: ãƒ‘ã‚¤ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™"

#: ../../library/asyncio-protocol.rst:93
msgid "subprocess:"
msgstr "ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹:"

#: ../../library/asyncio-protocol.rst:95
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'subprocess'``: :class:`subprocess.Popen` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚Šã¾ã™"

#: ../../library/asyncio-protocol.rst:99
msgid ""
"Set a new protocol.  Switching protocol should only be done when both "
"protocols are documented to support the switch."
msgstr "æ–°ã—ã„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’è¨­å®šã—ã¾ã™ã€‚ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®åˆ‡ã‚Šæ›¿ãˆã¯ã€ä¸¡æ–¹ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§åˆ‡ã‚Šæ›¿ãˆãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã®ã¿è¡Œã†ã¹ãã§ã™ã€‚"

#: ../../library/asyncio-protocol.rst:106
msgid "Return the current protocol."
msgstr "ç¾åœ¨ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:110
msgid "``'ssl_object'`` info was added to SSL sockets."
msgstr "``'ssl_object'`` æƒ…å ±ãŒ SSL ã‚½ã‚±ãƒƒãƒˆã«è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/asyncio-protocol.rst:115
msgid "ReadTransport"
msgstr "ReadTransport"

#: ../../library/asyncio-protocol.rst:119
msgid "Interface for read-only transports."
msgstr "èª­ã¿å‡ºã—å°‚ç”¨ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ã™ã€‚"

#: ../../library/asyncio-protocol.rst:123
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`data_received` method until :meth:`resume_reading` is "
"called."
msgstr ""
"ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã®å—ä¿¡å´ã‚’ä¸€æ™‚åœæ­¢ã—ã¾ã™ã€‚:meth:`resume_reading` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¾ã§ãã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã® "
":meth:`data_received` ãƒ¡ã‚½ãƒƒãƒ‰ã«ãƒ‡ãƒ¼ã‚¿ã¯æ¸¡ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-protocol.rst:127
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr ""

#: ../../library/asyncio-protocol.rst:133
msgid ""
"Resume the receiving end.  The protocol's :meth:`data_received` method will "
"be called once again if some data is available for reading."
msgstr ""
"å—ä¿¡ã‚’å†é–‹ã—ã¾ã™ã€‚èª­ã¿è¾¼ã¿å¯èƒ½ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ãŸå ´åˆãã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã® :meth:`data_received` ãƒ¡ã‚½ãƒƒãƒ‰ãŒä¸€åº¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:136
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr ""

#: ../../library/asyncio-protocol.rst:142
msgid "WriteTransport"
msgstr "WriteTransport"

#: ../../library/asyncio-protocol.rst:146
msgid "Interface for write-only transports."
msgstr "æ›¸ãè¾¼ã¿å°‚ç”¨ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ã™ã€‚"

#: ../../library/asyncio-protocol.rst:150
#: ../../library/asyncio-protocol.rst:238
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`connection_lost` method will eventually be called with "
":const:`None` as its argument."
msgstr ""
"ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã‚’å³åº§ã«ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚æœªå®Œäº†ã®å‡¦ç†ãŒã‚ã£ã¦ã‚‚ãã‚Œã‚’å¾…ã¡ã¾ã›ã‚“ã€‚ãƒãƒƒãƒ•ã‚¡ãƒ¼ã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ã¯å¤±ã‚ã‚Œã¾ã™ã€‚ãã‚Œä»¥é™ãƒ‡ãƒ¼ã‚¿ã¯å—ä¿¡ã•ã‚Œã¾ã›ã‚“ã€‚æœ€çµ‚çš„ã«ãã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®"
" :meth:`connection_lost` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¼•æ•° :const:`None` ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:157
msgid ""
"Return :const:`True` if the transport supports :meth:`write_eof`, "
":const:`False` if not."
msgstr ""
"ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆãŒ :meth:`write_eof` ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹å ´åˆ :const:`True` ã‚’ã€ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„å ´åˆã¯ "
":const:`False` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:162
msgid "Return the current size of the output buffer used by the transport."
msgstr "ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ã®ç¾åœ¨ã®ã‚µã‚¤ã‚ºã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:166
msgid ""
"Get the *high*- and *low*-water limits for write flow control. Return a "
"tuple ``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"æ›¸ãè¾¼ã¿ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡ã® *æœ€é«˜* ãŠã‚ˆã³ *æœ€ä½* æ°´ä½ç‚¹ (*high*- and *low*-water limits) ã‚’å–å¾—ã—ã¾ã™ã€‚``(low,"
" high)`` ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚*low* ãŠã‚ˆã³ *high* ã¯æ•´æ•°ã®ãƒã‚¤ãƒˆåˆ—ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:170
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr "æ°´ä½ç‚¹ã®è¨­å®šã¯ :meth:`set_write_buffer_limits` ã§è¡Œã„ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:176
msgid "Set the *high*- and *low*-water limits for write flow control."
msgstr "æ›¸ãè¾¼ã¿ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡ã® *æœ€é«˜* ãŠã‚ˆã³ *æœ€ä½* æ°´ä½ç‚¹ (*high*- and *low*-water limits) ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:178
msgid ""
"These two values (measured in number of bytes) control when the protocol's "
":meth:`pause_writing` and :meth:`resume_writing` methods are called. If "
"specified, the low-water limit must be less than or equal to the high-water "
"limit.  Neither *high* nor *low* can be negative."
msgstr ""

#: ../../library/asyncio-protocol.rst:184
msgid ""
":meth:`pause_writing` is called when the buffer size becomes greater than or"
" equal to the *high* value. If writing has been paused, "
":meth:`resume_writing` is called when the buffer size becomes less than or "
"equal to the *low* value."
msgstr ""

#: ../../library/asyncio-protocol.rst:189
msgid ""
"The defaults are implementation-specific.  If only the high-water limit is "
"given, the low-water limit defaults to an implementation-specific value less"
" than or equal to the high-water limit.  Setting *high* to zero forces *low*"
" to zero as well, and causes :meth:`pause_writing` to be called whenever the"
" buffer becomes non-empty.  Setting *low* to zero causes "
":meth:`resume_writing` to be called only once the buffer is empty. Use of "
"zero for either limit is generally sub-optimal as it reduces opportunities "
"for doing I/O and computation concurrently."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯å®Ÿè£…å›ºæœ‰ã«ãªã‚Šã¾ã™ã€‚æœ€é«˜æ°´ä½ç‚¹ã®ã¿ä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€æœ€ä½æ°´ä½ç‚¹ã¯æœ€é«˜æ°´ä½ç‚¹ä»¥ä¸‹ã®å®Ÿè£…å›ºæœ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã«ãªã‚Šã¾ã™ã€‚æœ€é«˜æ°´ä½ç‚¹ã«ã‚¼ãƒ­ãŒè¨­å®šã•ã‚Œã‚‹ã¨æœ€ä½æ°´ä½ç‚¹ã‚‚å¼·åˆ¶çš„ã«ã‚¼ãƒ­ã«ãªã‚Šã€ãƒãƒƒãƒ•ã‚¡ãŒç©ºã§ãªããªã‚‹ãŸã³ã«"
" :meth:`pause_writing` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚æœ€ä½æ°´ä½ç‚¹ã«ã‚¼ãƒ­ãŒè¨­å®šã•ã‚Œã‚‹ã¨ãƒãƒƒãƒ•ã‚¡ã¯ç©ºã«ãªã‚‹ã¨ã™ãã« "
":meth:`resume_writing` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ã©ã¡ã‚‰ã‹ã«ã‚¼ãƒ­ã‚’è¨­å®šã™ã‚‹ã“ã¨ã¯ã€ä¸¦åˆ—ã® I/O "
"å‡¦ç†ã‚„è¨ˆç®—ã®æ©Ÿä¼šã‚’æ¸›ã‚‰ã™ã“ã¨ã«ãªã‚‹ãŸã‚ã€ä¸€èˆ¬ã«æœ€å–„ã¨ã¯è¨€ãˆã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-protocol.rst:200
msgid "Use :meth:`get_write_buffer_limits` to get the limits."
msgstr "æ°´ä½ç‚¹ã®å–å¾—ã«ã¯ :meth:`get_write_buffer_limits` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:204
msgid "Write some *data* bytes to the transport."
msgstr "ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã«ãƒã‚¤ãƒˆåˆ— *data* ã‚’æ›¸ãè¾¼ã¿ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:206
#: ../../library/asyncio-protocol.rst:233
msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“; ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒƒãƒ•ã‚¡ãƒ¼ã—ã€éåŒæœŸã«é€ä¿¡ã™ã‚‹æº–å‚™ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:211
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""
"ãƒã‚¤ãƒˆåˆ—ã®ãƒ‡ãƒ¼ã‚¿ã®ãƒªã‚¹ãƒˆ (ã¾ãŸã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«) ã‚’ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã«æ›¸ãè¾¼ã¿ã¾ã™ã€‚ã“ã®æŒ¯ã‚‹èˆã„ã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’ yield ã—ã¦å„è¦ç´ ã§ "
":meth:`write` ã‚’å‘¼ã³å‡ºã™ã“ã¨ã¨ç­‰ä¾¡ã§ã™ãŒã€ã‚ˆã‚ŠåŠ¹ç‡çš„ãªå®Ÿè£…ã¨ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:217
msgid ""
"Close the write end of the transport after flushing buffered data. Data may "
"still be received."
msgstr "ãƒãƒƒãƒ•ã‚¡ãƒ¼ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã—ãŸå¾Œãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã®é€ä¿¡å´ã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ã¯å—ä¿¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:220
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL)"
" doesn't support half-closes."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆ (ä¾‹ãˆã° SSL) ãŒãƒãƒ¼ãƒ•ã‚¯ãƒ­ãƒ¼ã‚ºã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„å ´åˆ :exc:`NotImplementedError` "
"ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:225
msgid "DatagramTransport"
msgstr "DatagramTransport"

#: ../../library/asyncio-protocol.rst:229
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"ãƒªãƒ¢ãƒ¼ãƒˆãƒ”ã‚¢ *addr* (ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆä¾å­˜ã®å¯¾è±¡ã‚¢ãƒ‰ãƒ¬ã‚¹) ã«ãƒã‚¤ãƒˆåˆ— *data* ã‚’é€ä¿¡ã—ã¾ã™ã€‚*addr* ãŒ :const:`None` "
"ã®å ´åˆã€ãƒ‡ãƒ¼ã‚¿ã¯ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã®ä½œæˆæ™‚ã«æŒ‡å®šã•ã‚ŒãŸé€ä¿¡å…ˆã«é€ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:245
msgid "BaseSubprocessTransport"
msgstr "BaseSubprocessTransport"

#: ../../library/asyncio-protocol.rst:251
msgid "Return the subprocess process id as an integer."
msgstr "ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ—ãƒ­ã‚»ã‚¹ ID (æ•´æ•°) ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:255
msgid ""
"Return the transport for the communication pipe corresponding to the integer"
" file descriptor *fd*:"
msgstr "æ•´æ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ *fd* ã«è©²å½“ã™ã‚‹é€šä¿¡ãƒ‘ã‚¤ãƒ—ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã‚’è¿”ã—ã¾ã™:"

#: ../../library/asyncio-protocol.rst:258
msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or "
":const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""
"``0``: æ¨™æº–å…¥åŠ› (*stdin*) ã®èª­ã¿è¾¼ã¿å¯èƒ½ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã€‚ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ãŒ ``stdin=PIPE`` "
"ã§ä½œæˆã•ã‚Œã¦ã„ãªã„å ´åˆã¯ :const:`None`"

#: ../../library/asyncio-protocol.rst:260
msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or "
":const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""
"``1``: æ¨™æº–å‡ºåŠ› (*stdout*) ã®æ›¸ãè¾¼ã¿å¯èƒ½ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã€‚ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ãŒ ``stdout=PIPE`` "
"ã§ä½œæˆã•ã‚Œã¦ã„ãªã„å ´åˆã¯ :const:`None`"

#: ../../library/asyncio-protocol.rst:262
msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or "
":const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""
"``2``: æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ› (*stderr*) ã®æ›¸ãè¾¼ã¿å¯èƒ½ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã€‚ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ãŒ ``stderr=PIPE`` "
"ã§ä½œæˆã•ã‚Œã¦ã„ãªã„å ´åˆã¯ :const:`None`"

#: ../../library/asyncio-protocol.rst:264
msgid "other *fd*: :const:`None`"
msgstr "ãã®ä»–ã® *fd*: :const:`None`"

#: ../../library/asyncio-protocol.rst:268
msgid ""
"Return the subprocess returncode as an integer or :const:`None` if it hasn't"
" returned, similarly to the :attr:`subprocess.Popen.returncode` attribute."
msgstr ""
"ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒªã‚¿ãƒ¼ãƒ³ã‚³ãƒ¼ãƒ‰ (æ•´æ•°) ã‚’è¿”ã—ã¾ã™ã€‚ãƒªã‚¿ãƒ¼ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’æŒãŸãªã„å ´åˆ :const:`None` "
"ã‚’è¿”ã—ã¾ã™ã€‚:attr:`subprocess.Popen.returncode` å±æ€§ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/asyncio-protocol.rst:274
msgid "Kill the subprocess, as in :meth:`subprocess.Popen.kill`."
msgstr ":meth:`subprocess.Popen.kill` ã¨åŒæ§˜ã«ã€ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã‚’ kill ã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:276
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""
"POSIX ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ã“ã®é–¢æ•°ã¯ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã« SIGKILL ã‚’é€ä¿¡ã—ã¾ã™ã€‚Windows ã§ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ "
":meth:`terminate` ã®åˆ¥åã§ã™ã€‚"

#: ../../library/asyncio-protocol.rst:281
msgid ""
"Send the *signal* number to the subprocess, as in "
":meth:`subprocess.Popen.send_signal`."
msgstr ""
"ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚·ã‚°ãƒŠãƒ« *signal* ã‚’é€ä¿¡ã—ã¾ã™ã€‚:meth:`subprocess.Popen.send_signal` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/asyncio-protocol.rst:286
msgid ""
"Ask the subprocess to stop, as in :meth:`subprocess.Popen.terminate`. This "
"method is an alias for the :meth:`close` method."
msgstr ""
"ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã«åœæ­¢ã‚’è¦æ±‚ã—ã¾ã™ã€‚:meth:`subprocess.Popen.terminate` ã¨åŒã˜ã§ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ "
":meth:`close` ãƒ¡ã‚½ãƒƒãƒ‰ã®åˆ¥åã§ã™ã€‚"

#: ../../library/asyncio-protocol.rst:289
msgid ""
"On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, "
"the Windows API function TerminateProcess() is called to stop the "
"subprocess."
msgstr ""
"POSIX ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã« SIGTERM ã‚’é€ä¿¡ã—ã¾ã™ã€‚Windows ã§ã¯ã€Windows API é–¢æ•° "
"TerminateProcess() ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:295
msgid ""
"Ask the subprocess to stop by calling the :meth:`terminate` method if the "
"subprocess hasn't returned yet, and close transports of all pipes (*stdin*, "
"*stdout* and *stderr*)."
msgstr ""
"ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ãŒã¾ã è¿”ã—ã¦ã„ãªã„å ´åˆã€:meth:`terminate` ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã«åœæ­¢ã‚’è¦æ±‚ã—ã€å…¨ãƒ‘ã‚¤ãƒ— "
"(*stdin*ã€*stdout* ãŠã‚ˆã³ *stderr*) ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:303
msgid "Protocols"
msgstr "ãƒ—ãƒ­ãƒˆã‚³ãƒ«"

#: ../../library/asyncio-protocol.rst:305
msgid ""
":mod:`asyncio` provides base classes that you can subclass to implement your"
" network protocols.  Those classes are used in conjunction with "
":ref:`transports <asyncio-transport>` (see below): the protocol parses "
"incoming data and asks for the writing of outgoing data, while the transport"
" is responsible for the actual I/O and buffering."
msgstr ""
":mod:`asyncio` ã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®å®Ÿè£…ã‚’ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã™ã‚‹åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã‚¯ãƒ©ã‚¹ã¯ :ref:`ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆ "
"<asyncio-transport>` ã¨é€£å‹•ã—ã¦ä½¿ç”¨ã•ã‚Œã¾ã™: "
"ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®è§£æãŠã‚ˆã³å‡ºåŠ›ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿ã®ãŸã‚ã®å•ã„åˆã‚ã›ã‚’è¡Œã„ã€ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã¯å®Ÿéš›ã® I/O ã¨ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã«è²¬ä»»ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:311
msgid ""
"When subclassing a protocol class, it is recommended you override certain "
"methods.  Those methods are callbacks: they will be called by the transport "
"on certain events (for example when some data is received); you shouldn't "
"call them yourself, unless you are implementing a transport."
msgstr ""
"ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¯ãƒ©ã‚¹ã‚’ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã™ã‚‹ã¨ãã€ã„ãã¤ã‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§ã™: "
"ã„ãã¤ã‹ã®ã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç”Ÿã—ãŸã¨ã (ä¾‹ãˆã°ãƒ‡ãƒ¼ã‚¿ã®å—ä¿¡ãªã©) ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™; "
"ã‚ãªãŸãŒãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã‚’å®Ÿè£…ã™ã‚‹å ´åˆã‚’é™¤ãã€ã“ã‚Œã‚‰ã‚’ç›´æ¥å‘¼ã³å‡ºã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-protocol.rst:317
msgid ""
"All callbacks have default implementations, which are empty.  Therefore, you"
" only need to implement the callbacks for the events in which you are "
"interested."
msgstr "ã™ã¹ã¦ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ç©ºã®å®Ÿè£…ã‚’æŒã¡ã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ã‚ãªãŸãŒèˆˆå‘³ã‚’æŒã£ãŸã‚¤ãƒ™ãƒ³ãƒˆç”¨ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®ã¿å®Ÿè£…ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:323
msgid "Protocol classes"
msgstr "ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¯ãƒ©ã‚¹ç¾¤"

#: ../../library/asyncio-protocol.rst:327
msgid ""
"The base class for implementing streaming protocols (for use with e.g. TCP "
"and SSL transports)."
msgstr "(ä¾‹ãˆã° TCP ã‚„ SSL ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã¨ã¨ã‚‚ã«ä½¿ç”¨ã™ã‚‹) ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®Ÿè£…ã™ã‚‹åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/asyncio-protocol.rst:332
msgid ""
"The base class for implementing datagram protocols (for use with e.g. UDP "
"transports)."
msgstr "(ä¾‹ãˆã° UDP ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã¨ã‚‚ã«ä½¿ç”¨ã™ã‚‹) ãƒ‡ãƒ¼ã‚¿ã‚°ãƒ©ãƒ ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®Ÿè£…ã™ã‚‹åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/asyncio-protocol.rst:337
msgid ""
"The base class for implementing protocols communicating with child processes"
" (through a set of unidirectional pipes)."
msgstr "å­ãƒ—ãƒ­ã‚»ã‚¹ã¨ (ä¸€æ–¹å‘ãƒ‘ã‚¤ãƒ—ã‚’ä½¿ç”¨ã—ã¦) é€šä¿¡ã™ã‚‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®Ÿè£…ã™ã‚‹åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/asyncio-protocol.rst:342
msgid "Connection callbacks"
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯"

#: ../../library/asyncio-protocol.rst:344
#: ../../library/asyncio-protocol.rst:456
msgid ""
"These callbacks may be called on :class:`Protocol`, "
":class:`DatagramProtocol` and :class:`SubprocessProtocol` instances:"
msgstr ""
"ã“ã‚Œã‚‰ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ :class:`Protocol`ã€:class:`DatagramProtocol` ãŠã‚ˆã³ "
":class:`SubprocessProtocol` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™:"

#: ../../library/asyncio-protocol.rst:349
msgid "Called when a connection is made."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒä½œæˆã•ã‚ŒãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:351
msgid ""
"The *transport* argument is the transport representing the connection.  You "
"are responsible for storing it somewhere (e.g. as an attribute) if you need "
"to."
msgstr ""
"å¼•æ•° *transport* ã¯ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ã™ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã§ã™ã€‚å¿…è¦ã§ã‚ã‚Œã°ã€ãã‚Œã‚’ã©ã“ã«æ ¼ç´ã™ã‚‹ã‹ (ä¾‹ãˆã°å±æ€§ã¸) ã‚’æ±ºã‚ã‚‹ã®ã¯ã‚ãªãŸã§ã™ã€‚"

#: ../../library/asyncio-protocol.rst:357
msgid "Called when the connection is lost or closed."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒå¤±ã‚ã‚ŒãŸã€ã‚ã‚‹ã„ã¯ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:359
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr ""
"å¼•æ•°ã¯ä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ :const:`None` ã«ãªã‚Šã¾ã™ã€‚:const:`None` ã®ã¨ãã€é€šå¸¸ã® EOF "
"ãŒå—ä¿¡ã•ã‚ŒãŸã‹ã€ã‚ã‚‹ã„ã¯ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒã“ã¡ã‚‰å´ã‹ã‚‰ä¸­æ­¢ã¾ãŸã¯ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:363
msgid ""
":meth:`~BaseProtocol.connection_made` and "
":meth:`~BaseProtocol.connection_lost` are called exactly once per successful"
" connection.  All other callbacks will be called between those two methods, "
"which allows for easier resource management in your protocol implementation."
msgstr ""
":meth:`~BaseProtocol.connection_made` ãŠã‚ˆã³ "
":meth:`~BaseProtocol.connection_lost` ã¯æ¥ç¶šãŒæˆåŠŸã™ã‚‹ãŸã³ã«å³å¯†ã« 1 "
"å›å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ãã®ä»–ã®ã™ã¹ã¦ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ã“ã‚Œã‚‰ 2 ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®é–“ã«å‘¼ã³å‡ºã•ã‚Œã€ã‚ãªãŸã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®å®Ÿè£…å†…ã®ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ã‚’å®¹æ˜“ã«è¡Œãˆã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:368
msgid ""
"The following callbacks may be called only on :class:`SubprocessProtocol` "
"instances:"
msgstr "ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å‘¼ã³å‡ºã™ã®ã¯ :class:`SubprocessProtocol` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã¿ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“:"

#: ../../library/asyncio-protocol.rst:373
msgid ""
"Called when the child process writes data into its stdout or stderr pipe. "
"*fd* is the integer file descriptor of the pipe.  *data* is a non-empty "
"bytes object containing the data."
msgstr ""
"å­ãƒ—ãƒ­ã‚»ã‚¹ãŒè‡ªèº«ã®æ¨™æº–å‡ºåŠ›ã‚„æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã®ãƒ‘ã‚¤ãƒ—ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚“ã ã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚*fd* ã¯ãƒ‘ã‚¤ãƒ—ã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ (æ•´æ•°) "
"ã«ãªã‚Šã¾ã™ã€‚*data* ã¯ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€ç©ºã§ã¯ãªã„ãƒã‚¤ãƒˆåˆ—ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:379
msgid ""
"Called when one of the pipes communicating with the child process is closed."
"  *fd* is the integer file descriptor that was closed."
msgstr "å­ãƒ—ãƒ­ã‚»ã‚¹ã¨é€šä¿¡ã™ã‚‹ãƒ‘ã‚¤ãƒ—ã®ä¸€ã¤ãŒã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚Œã‚‹ã¨å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚*fd* ã¯ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ (æ•´æ•°) ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:384
msgid "Called when the child process has exited."
msgstr "å­ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã—ãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:388
msgid "Streaming protocols"
msgstr "ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ—ãƒ­ãƒˆã‚³ãƒ«"

#: ../../library/asyncio-protocol.rst:390
msgid "The following callbacks are called on :class:`Protocol` instances:"
msgstr "ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ :class:`Protocol` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä¸Šã§å‘¼ã³å‡ºã•ã‚Œã¾ã™:"

#: ../../library/asyncio-protocol.rst:394
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr "ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚*data* ã¯å—ä¿¡ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€ç©ºã§ã¯ãªã„ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:398
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead"
" make your parsing generic and flexible enough.  However, data is always "
"received in the correct order."
msgstr ""
"ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã«ã‚ˆã£ã¦ã€ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒãƒ•ã‚¡ãƒ¼ã€ãƒãƒ£ãƒ³ã‚¯ã‚ã‚‹ã„ã¯å†æ§‹ç¯‰ã®ã©ã‚Œã‹ãŒè¡Œã‚ã‚Œã¾ã™ã€‚ä¸€èˆ¬ã«ã€å›ºæœ‰ã®ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ã‚’ä¿¡é ¼ã™ã¹ãã§ã¯ãªãã€ä»£ã‚ã‚Šã«å…¨ä½“çš„ã‹ã¤ååˆ†ã«æŸ”è»Ÿãªè§£æã‚’è¡Œã†ã¹ãã§ã™ã€‚ãŸã ã—ã€ãƒ‡ãƒ¼ã‚¿ã¯å¸¸ã«æ­£ã—ã„é †åºã§å—ä¿¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:405
msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`write_eof`, if the other end also uses asyncio)."
msgstr ""
"ç›¸æ‰‹æ–¹ãŒé€ä¿¡ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒãªã„ã“ã¨ã‚’ä¼ãˆã¦ããŸã¨ã (ä¾‹ãˆã°ç›¸æ‰‹æ–¹ãŒ asyncio ã‚’ä½¿ç”¨ã—ã¦ãŠã‚Š :meth:`write_eof` "
"ã‚’å‘¼ã³å‡ºã—ãŸå ´åˆ) ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:409
msgid ""
"This method may return a false value (including ``None``), in which case the"
" transport will close itself.  Conversely, if this method returns a true "
"value, closing the transport is up to the protocol.  Since the default "
"implementation returns ``None``, it implicitly closes the connection."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å½å€¤ (``None`` ã‚’å«ã‚€) "
"ã‚’è¿”ã™ã“ã¨ãŒã‚ã‚Šã€ãã®å ´åˆãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã¯è‡ªèº«ã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚çœŸå€¤ã‚’è¿”ã™å ´åˆã€ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«ã‚ˆã£ã¦ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè£…ã§ã¯"
" ``None`` ã‚’è¿”ã™ãŸã‚ã€ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã¯æš—é»™çš„ã«ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:415
msgid ""
"Some transports such as SSL don't support half-closed connections, in which "
"case returning true from this method will not prevent closing the "
"connection."
msgstr ""
"SSL "
"ã®ã‚ˆã†ãªä¸€éƒ¨ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã¯ãƒãƒ¼ãƒ•ã‚¯ãƒ­ãƒ¼ã‚ºæ¥ç¶šã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚ãã®å ´åˆã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒçœŸå€¤ã‚’è¿”ã™ã¨ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¯ãƒ­ãƒ¼ã‚ºã‚’å›é¿ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-protocol.rst:419
msgid ""
":meth:`data_received` can be called an arbitrary number of times during a "
"connection.  However, :meth:`eof_received` is called at most once and, if "
"called, :meth:`data_received` won't be called after it."
msgstr ""
"æ¥ç¶šä¸­ã€:meth:`data_received` ã¯è¤‡æ•°å›å‘¼ã³å‡ºã•ã‚Œãˆã¾ã™ã€‚:meth:`eof_received` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã®ã¯ 1 å›ã§ã€1"
" åº¦å‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ã€ãã®å¾Œ :meth:`data_received` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-protocol.rst:423
msgid "State machine:"
msgstr "ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³:"

#: ../../library/asyncio-protocol.rst:425
msgid ""
"start -> :meth:`~BaseProtocol.connection_made` [-> "
":meth:`~Protocol.data_received` \\*] [-> :meth:`~Protocol.eof_received` ?] "
"-> :meth:`~BaseProtocol.connection_lost` -> end"
msgstr ""
"é–‹å§‹çŠ¶æ…‹ -> :meth:`~BaseProtocol.connection_made` [-> "
":meth:`~Protocol.data_received` \\*] [-> :meth:`~Protocol.eof_received` ?] "
"-> :meth:`~BaseProtocol.connection_lost` -> çµ‚äº†çŠ¶æ…‹ "

#: ../../library/asyncio-protocol.rst:432
msgid "Datagram protocols"
msgstr "ãƒ‡ãƒ¼ã‚¿ã‚°ãƒ©ãƒ ãƒ—ãƒ­ãƒˆã‚³ãƒ«"

#: ../../library/asyncio-protocol.rst:434
msgid ""
"The following callbacks are called on :class:`DatagramProtocol` instances."
msgstr "ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ :class:`DatagramProtocol` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä¸Šã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:438
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the"
" incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""
"ãƒ‡ãƒ¼ã‚¿ã‚°ãƒ©ãƒ ã‚’å—ä¿¡ã—ãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚*data* ã¯å—ä¿¡ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€ãƒã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚*addr* ã¯ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã™ã‚‹ãƒ”ã‚¢ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™;"
" æ­£ç¢ºãªå½¢å¼ã¯ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:444
msgid ""
"Called when a previous send or receive operation raises an :class:`OSError`."
"  *exc* is the :class:`OSError` instance."
msgstr ""
"ç›´å‰ã®é€ä¿¡ã‚ã‚‹ã„ã¯å—ä¿¡ãŒ :class:`OSError` ã‚’é€å‡ºã—ãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚*exc* ã¯ :class:`OSError` "
"ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:447
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram couldn't be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã‚‹ã®ã¯ã€ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆ (UDP ãªã©) "
"ãŒãƒ‡ãƒ¼ã‚¿ã‚°ãƒ©ãƒ ã‚’å—ä¿¡å´ã«é…ä¿¡ã§ããªã‹ã£ãŸã“ã¨ãŒæ¤œå‡ºã•ã‚ŒãŸãªã©ã®ã€ã¾ã‚Œãªå ´åˆã«ãŠã„ã¦ã®ã¿ã§ã™ã€‚ã»ã¨ã‚“ã©ã®å ´åˆã€ãƒ‡ãƒ¼ã‚¿ã‚°ãƒ©ãƒ ãŒé…ä¿¡ã§ããªã‘ã‚Œã°ãã®ã¾ã¾é€šçŸ¥ã•ã‚Œã‚‹ã“ã¨ãªãç ´æ£„ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:454
msgid "Flow control callbacks"
msgstr "ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯"

#: ../../library/asyncio-protocol.rst:461
msgid "Called when the transport's buffer goes over the high-water mark."
msgstr "ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã®ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚µã‚¤ã‚ºãŒæœ€é«˜æ°´ä½ç‚¹ (High-Water Mark) ã‚’è¶…ãˆãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:465
msgid "Called when the transport's buffer drains below the low-water mark."
msgstr "ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã®ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚µã‚¤ã‚ºãŒæœ€ä½æ°´ä½ç‚¹ (Low-Water Mark) ã«é”ã—ãŸãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:468
msgid ""
":meth:`pause_writing` and :meth:`resume_writing` calls are paired -- "
":meth:`pause_writing` is called once when the buffer goes strictly over the "
"high-water mark (even if subsequent writes increases the buffer size even "
"more), and eventually :meth:`resume_writing` is called once when the buffer "
"size reaches the low-water mark."
msgstr ""
":meth:`pause_writing` ãŠã‚ˆã³ :meth:`resume_writing` ã®å‘¼ã³å‡ºã—ã¯å¯¾ã«ãªã‚Šã¾ã™ã€‚-- "
":meth:`pause_writing` ã¯ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒå®Œå…¨ã«æœ€é«˜æ°´ä½ç‚¹ã‚’è¶…ãˆãŸã¨ã (å¾Œç¶šã®æ›¸ãè¾¼ã¿ãŒã•ã‚‰ã«ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚µã‚¤ã‚ºã‚’å¢—ã‚„ã™ã¨ã—ã¦ã‚‚) 1 "
"åº¦å‘¼ã³å‡ºã•ã‚Œã€ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚µã‚¤ã‚ºãŒæœ€çµ‚çš„ã«æœ€ä½æ°´ä½ç‚¹ã«é”ã—ãŸã¨ãã« :meth:`resume_writing` ãŒ 1 åº¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:475
msgid ""
"If the buffer size equals the high-water mark, :meth:`pause_writing` is not "
"called -- it must go strictly over. Conversely, :meth:`resume_writing` is "
"called when the buffer size is equal or lower than the low-water mark.  "
"These end conditions are important to ensure that things go as expected when"
" either mark is zero."
msgstr ""
"ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚µã‚¤ã‚ºãŒæœ€é«˜æ°´ä½ç‚¹ã¨ç­‰ã—ããªã£ãŸæ™‚ç‚¹ã§ã¯ :meth:`pause_writing` ã¯å‘¼ã³å‡ºã•ã‚Œã¾ã›ã‚“ -- "
"å®Œå…¨ã«è¶…ãˆãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å¯¾ã—ã¦ã€ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚µã‚¤ã‚ºãŒæœ€ä½æ°´ä½ç‚¹ã¨ç­‰ã—ããªã£ãŸã¨ãã¯ :meth:`resume_writing` "
"ã¯å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ç«¯æœ«æ¡ä»¶ã¯å„ç‚¹ãŒã‚¼ãƒ­ã«ãªã£ãŸã¨ãäºˆå®šé€šã‚Šã«å‹•ä½œã™ã‚‹ã‹ã©ã†ã‹ç¢ºèªã™ã‚‹ãŸã‚ã«é‡è¦ã§ã™ã€‚"

#: ../../library/asyncio-protocol.rst:483
msgid ""
"On BSD systems (OS X, FreeBSD, etc.) flow control is not supported for "
":class:`DatagramProtocol`, because send failures caused by writing too many "
"packets cannot be detected easily.  The socket always appears 'ready' and "
"excess packets are dropped; an :class:`OSError` with errno set to "
":const:`errno.ENOBUFS` may or may not be raised; if it is raised, it will be"
" reported to :meth:`DatagramProtocol.error_received` but otherwise ignored."
msgstr ""
"BSD ã‚·ã‚¹ãƒ†ãƒ  (OS Xã€FreeBSD ãªã©) ã§ã¯ã€:class:`DatagramProtocol` "
"ã§ã®ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡ã¯ã€å¤§é‡ã®ãƒ‘ã‚±ãƒƒãƒˆé€ä¿¡ã«ã‚ˆã‚‹é€ä¿¡å¤±æ•—ã‚’æ¤œçŸ¥ã™ã‚‹ã®ãŒå®¹æ˜“ã§ã¯ãªã„ãŸã‚ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã‚½ã‚±ãƒƒãƒˆã¯å¸¸ã« 'å¾…æ©ŸçŠ¶æ…‹' "
"ã®ã‚ˆã†ã«è¦‹ãˆã€è¶…éåˆ†ã®ãƒ‘ã‚±ãƒƒãƒˆã¯ç ´æ£„ã•ã‚Œã¾ã™; ã‚¨ãƒ©ãƒ¼ç•ªå· :const:`errno.ENOBUFS` ãŒè¨­å®šã•ã‚ŒãŸ :class:`OSError`"
" ãŒé€å‡ºã•ã‚Œã‚‹ã¨ãã‚‚ã‚ã‚Œã°ã•ã‚Œãªã„ã¨ãã‚‚ã‚ã‚Šã¾ã™; é€å‡ºã•ã‚ŒãŸå ´åˆã€:meth:`DatagramProtocol.error_received` "
"ã«é€šçŸ¥ã•ã‚Œã¾ã™ãŒã€é€å‡ºã•ã‚Œãªã„ã¨ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:493
msgid "Coroutines and protocols"
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«"

#: ../../library/asyncio-protocol.rst:495
msgid ""
"Coroutines can be scheduled in a protocol method using "
":func:`ensure_future`, but there is no guarantee made about the execution "
"order.  Protocols are not aware of coroutines created in protocol methods "
"and so will not wait for them."
msgstr ""
"ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒ¡ã‚½ãƒƒãƒ‰ã§ :func:`ensure_future` "
"ã‚’ä½¿ç”¨ã—ã¦ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ãŒã€ãã‚Œã¯å®Ÿè¡Œé †ã‚’ä¿è¨¼ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ä½œæˆã•ã‚ŒãŸã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚’æ¤œçŸ¥ã—ãªã„ãŸã‚ã€ãã‚Œã‚‰ã‚’å¾…æ©Ÿã—ã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-protocol.rst:499
msgid ""
"To have a reliable execution order, use :ref:`stream objects <asyncio-"
"streams>` in a coroutine with ``yield from``. For example, the "
":meth:`StreamWriter.drain` coroutine can be used to wait until the write "
"buffer is flushed."
msgstr ""
"ä¿¡é ¼ã§ãã‚‹å®Ÿè¡Œé †ã‚’æŒã¤ã«ã¯ã€ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®  ``yield from`` ã§ :ref:`ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <asyncio-streams>` "
"ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€:meth:`StreamWriter.drain` ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯æ›¸ãè¾¼ã¿ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:505
msgid "Protocol examples"
msgstr "ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ä¾‹"

#: ../../library/asyncio-protocol.rst:510
msgid "TCP echo client protocol"
msgstr "TCP Echo ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ«"

#: ../../library/asyncio-protocol.rst:512
msgid ""
"TCP echo client  using the :meth:`AbstractEventLoop.create_connection` "
"method, send data and wait until the connection is closed::"
msgstr ""
":meth:`AbstractEventLoop.create_connection` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ãŸ TCP Echo "
"ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã€ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:542
msgid ""
"The event loop is running twice. The "
":meth:`~AbstractEventLoop.run_until_complete` method is preferred in this "
"short example to raise an exception if the server is not listening, instead "
"of having to write a short coroutine to handle the exception and stop the "
"running loop. At :meth:`~AbstractEventLoop.run_until_complete` exit, the "
"loop is no longer running, so there is no need to stop the loop in case of "
"an error."
msgstr ""
"ã“ã®ä¾‹ã§ã¯ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã‚’ 2 å€‹å®Ÿè¡Œã—ã¦ã„ã¾ã™ã€‚:meth:`~AbstractEventLoop.run_until_complete` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚µãƒ¼ãƒãŒå¾…ã¡å—ã‘çŠ¶æ…‹ã«ãªã„ã¨ãã«ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã€é€šå¸¸ä½œæˆã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ä¾‹å¤–ã®é€å‡ºã‚„ãƒ«ãƒ¼ãƒ—ã®åœæ­¢ãªã©ã‚’è¡Œã†ãŸã‚ã®çŸ­ã„ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®ä»£ç”¨ã«ãªã‚Šã¾ã™ã€‚:meth:`~AbstractEventLoop.run_until_complete`"
" ã®çµ‚äº†æ™‚ã€ãƒ«ãƒ¼ãƒ—ã®å®Ÿè¡Œã¯çµ‚äº†ã—ã¦ã„ã‚‹ã®ã§ã€ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã«ãƒ«ãƒ¼ãƒ—ã‚’åœæ­¢ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-protocol.rst:551
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the :func:`asyncio.open_connection` function."
msgstr ""
":ref:`ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã£ãŸ TCP Echo ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ <asyncio-tcp-echo-client-streams>` ã®ä¾‹ã§ã¯ "
":func:`asyncio.open_connection` é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:558
msgid "TCP echo server protocol"
msgstr "TCP Echo ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ãƒˆã‚³ãƒ«"

#: ../../library/asyncio-protocol.rst:560
msgid ""
"TCP echo server using the :meth:`AbstractEventLoop.create_server` method, "
"send back received data and close the connection::"
msgstr ""
":meth:`AbstractEventLoop.create_server` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ãŸ TCP Echo "
"ã‚µãƒ¼ãƒãƒ¼ã§ã€å—ä¿¡ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’è¿”ä¿¡ã—ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:598
msgid ""
":meth:`Transport.close` can be called immediately after "
":meth:`WriteTransport.write` even if data are not sent yet on the socket: "
"both methods are asynchronous. ``yield from`` is not needed because these "
"transport methods are not coroutines."
msgstr ""
":meth:`Transport.close` ã¯ã€ãƒ‡ãƒ¼ã‚¿ãŒã¾ã ã‚½ã‚±ãƒƒãƒˆã«é€ä¿¡ã•ã‚Œã¦ã„ãªãã¦ã‚‚ã€:meth:`WriteTransport.write`"
" ã®ç›´å¾Œã«å‘¼ã³å‡ºã•ã‚Œã¾ã™: ãã‚Œãã‚Œã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯éåŒæœŸã§ã™ã€‚ã“ã‚Œã‚‰ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚³ãƒ«ãƒ¼ãƒãƒ³ã§ã¯ãªã„ãŸã‚ã€``yield from`` "
"ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-protocol.rst:605
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the :func:`asyncio.start_server` function."
msgstr ""
":ref:`ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã£ãŸ TCP Echo ã‚µãƒ¼ãƒãƒ¼ <asyncio-tcp-echo-server-streams>` ã®ä¾‹ã§ã¯ "
":func:`asyncio.start_server` é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:612
msgid "UDP echo client protocol"
msgstr "UDP Echo ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ«"

#: ../../library/asyncio-protocol.rst:614
msgid ""
"UDP echo client using the :meth:`AbstractEventLoop.create_datagram_endpoint`"
" method, send data and close the transport when we received the answer::"
msgstr ""
":meth:`AbstractEventLoop.create_datagram_endpoint` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ UDP Echo "
"ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã€ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—å¿œç­”ã‚’å—ä¿¡ã™ã‚‹ã¨ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:658
msgid "UDP echo server protocol"
msgstr "UDP Echo ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ãƒˆã‚³ãƒ«"

#: ../../library/asyncio-protocol.rst:660
msgid ""
"UDP echo server using the :meth:`AbstractEventLoop.create_datagram_endpoint`"
" method, send back received data::"
msgstr ""
":meth:`AbstractEventLoop.create_datagram_endpoint` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã™ã‚‹ UDP Echo "
"ã‚µãƒ¼ãƒãƒ¼ã§ã€å—ä¿¡ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’è¿”é€ã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:694
msgid "Register an open socket to wait for data using a protocol"
msgstr "ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ä½¿ã£ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å¾…ã¤ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ã‚±ãƒƒãƒˆã®ç™»éŒ²"

#: ../../library/asyncio-protocol.rst:696
msgid ""
"Wait until a socket receives data using the "
":meth:`AbstractEventLoop.create_connection` method with a protocol, and then"
" close the event loop ::"
msgstr ""
"ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ :meth:`AbstractEventLoop.create_connection` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã‚½ã‚±ãƒƒãƒˆãŒãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã™ã‚‹ã¾ã§å¾…æ©Ÿã—ã€å—ä¿¡å¾Œã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:743
msgid ""
"The :ref:`watch a file descriptor for read events <asyncio-watch-read-"
"event>` example uses the low-level :meth:`AbstractEventLoop.add_reader` "
"method to register the file descriptor of a socket."
msgstr ""
":ref:`èª­ã¿è¾¼ã¿ã‚¤ãƒ™ãƒ³ãƒˆç”¨ã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã®ç›£è¦– <asyncio-watch-read-event>` "
"ã®ä¾‹ã§ã¯ã€ã‚½ã‚±ãƒƒãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’ç™»éŒ²ã™ã‚‹ã®ã«ä½æ°´æº–ã® :meth:`AbstractEventLoop.add_reader` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-protocol.rst:748
msgid ""
"The :ref:`register an open socket to wait for data using streams <asyncio-"
"register-socket-streams>` example uses high-level streams created by the "
":func:`open_connection` function in a coroutine."
msgstr ""
":ref:`ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã£ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å¾…ã¤ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ã‚±ãƒƒãƒˆã®ç™»éŒ² <asyncio-register-socket-streams>` "
"ã®ä¾‹ã§ã¯ã‚³ãƒ«ãƒ¼ãƒãƒ³ã® :func:`open_connection` é–¢æ•°ã«ã‚ˆã£ã¦ä½œæˆã•ã‚ŒãŸé«˜æ°´æº–ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚"
