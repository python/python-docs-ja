# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2021
# Takeshi Nakazato, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-24 14:15+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Takeshi Nakazato, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-protocol.rst:9
msgid "Transports and Protocols"
msgstr "トランスポートとプロトコル"

#: ../../library/asyncio-protocol.rst:12
msgid "Preface"
msgstr "まえがき"

#: ../../library/asyncio-protocol.rst:13
msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs such "
"as :meth:`loop.create_connection`.  They use callback-based programming "
"style and enable high-performance implementations of network or IPC "
"protocols (e.g. HTTP)."
msgstr ""
"トランスポートとプロトコルは :meth:`loop.create_connection` のような **低水準"
"の** イベントループ API から使われます。これらはコールバックに基づくプログラ"
"ミングスタイルを使うことでネットワークや IPC プロトコル (HTTP など) の高性能"
"な実装を可能にします。"

#: ../../library/asyncio-protocol.rst:18
msgid ""
"Essentially, transports and protocols should only be used in libraries and "
"frameworks and never in high-level asyncio applications."
msgstr ""
"基本的にトランスポートとプロトコルはライブラリやフレームワークからのみ使われ"
"るべきであり、高水準の asyncio アプリケーションから使われるものではありませ"
"ん。"

#: ../../library/asyncio-protocol.rst:22
msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr "このドキュメントは `Transports`_ と `Protocols`_ を扱います。"

#: ../../library/asyncio-protocol.rst:25
msgid "Introduction"
msgstr "はじめに"

#: ../../library/asyncio-protocol.rst:26
msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and to "
"some extent when)."
msgstr ""
"最上位の観点からは、トランスポートは *どのように* バイトデータを送信するかに"
"影響を与え、いっぽうプロトコルは *どの* バイトデータを送信するかを決定します "
"(また、ある程度は *いつ* も決定します) 。"

#: ../../library/asyncio-protocol.rst:30
msgid ""
"A different way of saying the same thing: a transport is an abstraction for "
"a socket (or similar I/O endpoint) while a protocol is an abstraction for an "
"application, from the transport's point of view."
msgstr ""
"同じことを違う言い方で表現します: トランスポートはソケット (または同様の I/O "
"端点) の抽象化であり、プロトコルはトランスポートから見たときのアプリケーショ"
"ンの抽象化です。"

#: ../../library/asyncio-protocol.rst:35
msgid ""
"Yet another view is the transport and protocol interfaces together define an "
"abstract interface for using network I/O and interprocess I/O."
msgstr ""
"さらにもう一つの見方として、トランスポートとプロトコルの2つのインターフェース"
"は、協調してネットワーク I/O やプロセス間 I/O の抽象インターフェースを定義し"
"ています。"

#: ../../library/asyncio-protocol.rst:39
msgid ""
"There is always a 1:1 relationship between transport and protocol objects: "
"the protocol calls transport methods to send data, while the transport calls "
"protocol methods to pass it data that has been received."
msgstr ""
"トランスポートオブジェクトとプロトコルオブジェクトの間には常に1対1の関係があ"
"ります: プロトコルはデータを送信するためにトランスポートのメソッドを呼び出"
"し、トランスポートは受信したデータを渡すためにプロトコルのメソッドを呼び出し"
"ます。"

#: ../../library/asyncio-protocol.rst:44
msgid ""
"Most of connection oriented event loop methods (such as :meth:`loop."
"create_connection`) usually accept a *protocol_factory* argument used to "
"create a *Protocol* object for an accepted connection, represented by a "
"*Transport* object. Such methods usually return a tuple of ``(transport, "
"protocol)``."
msgstr ""
"ほとんどの接続に基づくイベントループメソッド (:meth:`loop.create_connection` "
"など) は通常 *protocol_factory* 引数を受け取り、 *Transport* オブジェクトで表"
"現される確立した接続に対する *Protocol* オブジェクトを生成するために使いま"
"す。そのようなメソッドは通常 ``(transport, protocol)`` タプルを返します。"

#: ../../library/asyncio-protocol.rst:51
msgid "Contents"
msgstr "内容"

#: ../../library/asyncio-protocol.rst:52
msgid "This documentation page contains the following sections:"
msgstr "このページは以下の節から構成されます:"

#: ../../library/asyncio-protocol.rst:54
msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"`Transports`_ 節は asyncio の :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, および :class:`SubprocessTransport` クラスについて記述し"
"ています。"

#: ../../library/asyncio-protocol.rst:59
msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, :class:"
"`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, and :class:"
"`SubprocessProtocol` classes."
msgstr ""
"`Protocols`_ 節は asyncio の :class:`BaseProtocol`, :class:`Protocol`, :"
"class:`BufferedProtocol`, :class:`DatagramProtocol`, および :class:"
"`SubprocessProtocol` クラスについて記述しています。"

#: ../../library/asyncio-protocol.rst:63
msgid ""
"The `Examples`_ section showcases how to work with transports, protocols, "
"and low-level event loop APIs."
msgstr ""
"`Examples`_ 節はトランスポート、プロトコル、および低水準のイベントループ API "
"の利用方法を紹介しています。"

#: ../../library/asyncio-protocol.rst:70
msgid "Transports"
msgstr "トランスポート"

#: ../../library/asyncio-protocol.rst:72
msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr "**ソースコード:** :source:`Lib/asyncio/transports.py`"

#: ../../library/asyncio-protocol.rst:76
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr ""
"トランスポートはさまざまな通信方法を抽象化するために :mod:`asyncio` が提供す"
"るクラス群です。"

#: ../../library/asyncio-protocol.rst:79
msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr ""
"トランスポートオブジェクトは常に :ref:`asyncio イベントループ <asyncio-event-"
"loop>` によってインスタンス化されます。"

#: ../../library/asyncio-protocol.rst:82
msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. The "
"methods available on a transport depend on the transport's kind."
msgstr ""
"asyncio は TCP, UDP, SSL, およびサブプロセスパイプのトランスポートを実装して"
"います。利用可能なトランスポートのメソッドはトランスポートの種類に依存しま"
"す。"

#: ../../library/asyncio-protocol.rst:85
msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""
"トランスポートクラスは :ref:`スレッド安全ではありません <asyncio-"
"multithreading>`。"

#: ../../library/asyncio-protocol.rst:89
msgid "Transports Hierarchy"
msgstr "トランスポートのクラス階層構造"

#: ../../library/asyncio-protocol.rst:93
msgid ""
"Base class for all transports.  Contains methods that all asyncio transports "
"share."
msgstr ""
"全てのトランスポートの基底クラスです。すべての asyncio トランスポートが共有す"
"るメソッドを含んでいます。"

#: ../../library/asyncio-protocol.rst:98
msgid "A base transport for write-only connections."
msgstr "書き込み専用の接続に対する基底トランスポートクラスです。"

#: ../../library/asyncio-protocol.rst:100
msgid ""
"Instances of the *WriteTransport* class are returned from the :meth:`loop."
"connect_write_pipe` event loop method and are also used by subprocess-"
"related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"*WriteTransport* クラスのインスタンスは :meth:`loop.connect_write_pipe` イベ"
"ントループメソッドから返され、 :meth:`loop.subprocess_exec` のようなサブプロ"
"セスに関連するメソッドから利用されます。"

#: ../../library/asyncio-protocol.rst:107
msgid "A base transport for read-only connections."
msgstr "読み込み専用の接続に対する基底トランスポートクラスです。"

#: ../../library/asyncio-protocol.rst:109
msgid ""
"Instances of the *ReadTransport* class are returned from the :meth:`loop."
"connect_read_pipe` event loop method and are also used by subprocess-related "
"methods like :meth:`loop.subprocess_exec`."
msgstr ""
" *ReadTransport* クラスのインスタンスは :meth:`loop.connect_read_pipe` イベン"
"トループメソッドから返され、 :meth:`loop.subprocess_exec` のようなサブプロセ"
"スに関連するメソッドから利用されます。"

#: ../../library/asyncio-protocol.rst:116
msgid ""
"Interface representing a bidirectional transport, such as a TCP connection."
msgstr ""
"TCP 接続のような、読み出しと書き込みの双方向のトランスポートを表現するイン"
"ターフェースです。"

#: ../../library/asyncio-protocol.rst:119
msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary to "
"create the transport and protocol."
msgstr ""
"ユーザーはトランスポートを直接インスタンス化することはありません; ユーザー"
"は、ユーティリティ関数にプロトコルファクトリとその他トランスポートとプロトコ"
"ルを作成するために必要な情報を渡して呼び出します。"

#: ../../library/asyncio-protocol.rst:123
msgid ""
"Instances of the *Transport* class are returned from or used by event loop "
"methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."
msgstr ""
"*Transport* クラスのインスタンスは、:meth:`loop.create_connection`, :meth:"
"`loop.create_unix_connection`, :meth:`loop.create_server`, :meth:`loop."
"sendfile` などのイベントループメソッドから返されたり、これらのメソッドから利"
"用されたりします。"

#: ../../library/asyncio-protocol.rst:131
msgid "A transport for datagram (UDP) connections."
msgstr "データグラム (UDP) 接続のためのトランスポートです。"

#: ../../library/asyncio-protocol.rst:133
msgid ""
"Instances of the *DatagramTransport* class are returned from the :meth:`loop."
"create_datagram_endpoint` event loop method."
msgstr ""
"*DatagramTransport* クラスのインスタンスは :meth:`loop."
"create_datagram_endpoint` イベントループメソッドから返されます。"

#: ../../library/asyncio-protocol.rst:139
msgid ""
"An abstraction to represent a connection between a parent and its child OS "
"process."
msgstr "親プロセスとその子プロセスの間の接続を表現する抽象クラスです。"

#: ../../library/asyncio-protocol.rst:142
msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop "
"methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"*SubprocessTransport* クラスのインスタンスは :meth:`loop.subprocess_shell` "
"と :meth:`loop.subprocess_exec` の2つのイベントループメソッドから返されます。"

#: ../../library/asyncio-protocol.rst:148
msgid "Base Transport"
msgstr "基底トランスポート"

#: ../../library/asyncio-protocol.rst:152
msgid "Close the transport."
msgstr "トランスポートをクローズします。"

#: ../../library/asyncio-protocol.rst:154
msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all buffered "
"data is flushed, the protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will be called with :const:`None` as "
"its argument. The transport should not be used once it is closed."
msgstr ""

#: ../../library/asyncio-protocol.rst:164
msgid "Return ``True`` if the transport is closing or is closed."
msgstr "トランスポートを閉じている最中か閉じていた場合 ``True`` を返します。"

#: ../../library/asyncio-protocol.rst:168
msgid "Return information about the transport or underlying resources it uses."
msgstr "トランスポートまたはそれが背後で利用しているリソースの情報を返します。"

#: ../../library/asyncio-protocol.rst:171
msgid ""
"*name* is a string representing the piece of transport-specific information "
"to get."
msgstr "*name* は取得するトランスポート特有の情報を表す文字列です。"

#: ../../library/asyncio-protocol.rst:174
msgid ""
"*default* is the value to return if the information is not available, or if "
"the transport does not support querying it with the given third-party event "
"loop implementation or on the current platform."
msgstr ""
"*default* は、取得したい情報が取得可能でなかったり、サードパーティのイベント"
"ループ実装や現在のプラットフォームがその情報の問い合わせをサポートしていない"
"場合に返される値です。"

#: ../../library/asyncio-protocol.rst:179
msgid ""
"For example, the following code attempts to get the underlying socket object "
"of the transport::"
msgstr ""
"例えば、以下のコードはトランスポート内のソケットオブジェクトを取得しようとし"
"ます::"

#: ../../library/asyncio-protocol.rst:186
msgid "Categories of information that can be queried on some transports:"
msgstr "いくつかのトランスポートで問い合わせ可能な情報のカテゴリを示します:"

#: ../../library/asyncio-protocol.rst:188
msgid "socket:"
msgstr "ソケット:"

#: ../../library/asyncio-protocol.rst:190
msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``: ソケットが接続されているリモートアドレスで、:meth:`socket."
"socket.getpeername` の結果になります (エラーのときは ``None``)"

#: ../../library/asyncio-protocol.rst:194
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: :class:`socket.socket` のインスタンスになります"

#: ../../library/asyncio-protocol.rst:196
msgid ""
"``'sockname'``: the socket's own address, result of :meth:`socket.socket."
"getsockname`"
msgstr ""
"``'sockname'``: ソケット自身のアドレスで、:meth:`socket.socket.getsockname` "
"の結果になります"

#: ../../library/asyncio-protocol.rst:199
msgid "SSL socket:"
msgstr "SSL ソケット:"

#: ../../library/asyncio-protocol.rst:201
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of :meth:`ssl.SSLSocket."
"compression`"
msgstr ""
"``'compression'``: 圧縮アルゴリズムで、:meth:`ssl.SSLSocket.compression` の結"
"果になります。圧縮されていないときは ``None`` になります"

#: ../../library/asyncio-protocol.rst:205
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``: 3 個の値 (使用されている暗号アルゴリズムの名称、使用が定義され"
"ている SSL プロトコルのバージョン、および使用されている秘密鍵のビット数) から"
"なるタプルで、:meth:`ssl.SSLSocket.cipher` の結果になります"

#: ../../library/asyncio-protocol.rst:210
msgid ""
"``'peercert'``: peer certificate; result of :meth:`ssl.SSLSocket.getpeercert`"
msgstr ""
"``'peercert'``: ピアの証明書で、:meth:`ssl.SSLSocket.getpeercert` の結果にな"
"ります"

#: ../../library/asyncio-protocol.rst:213
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: :class:`ssl.SSLContext` のインスタンスになります"

#: ../../library/asyncio-protocol.rst:215
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr ""
"``'ssl_object'``: :class:`ssl.SSLObject` または :class:`ssl.SSLSocket` インス"
"タンス"

#: ../../library/asyncio-protocol.rst:218
msgid "pipe:"
msgstr "パイプ:"

#: ../../library/asyncio-protocol.rst:220
msgid "``'pipe'``: pipe object"
msgstr "``'pipe'``: パイプオブジェクトです"

#: ../../library/asyncio-protocol.rst:222
msgid "subprocess:"
msgstr "サブプロセス:"

#: ../../library/asyncio-protocol.rst:224
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'subprocess'``: :class:`subprocess.Popen` のインスタンスになります"

#: ../../library/asyncio-protocol.rst:228
msgid "Set a new protocol."
msgstr "トランスポートに新しいプロトコルを設定します。"

#: ../../library/asyncio-protocol.rst:230
msgid ""
"Switching protocol should only be done when both protocols are documented to "
"support the switch."
msgstr ""
"プロトコルの切り替えは、両方のプロトコルのドキュメントで切り替えがサポートさ"
"れている場合にのみ行うべきです。"

#: ../../library/asyncio-protocol.rst:235
msgid "Return the current protocol."
msgstr "現在のプロトコルを返します。"

#: ../../library/asyncio-protocol.rst:239
msgid "Read-only Transports"
msgstr "読み出し専用のトランスポート"

#: ../../library/asyncio-protocol.rst:243
msgid "Return ``True`` if the transport is receiving new data."
msgstr "トランスポートが新しいデータを受信中の場合 ``True`` を返します。"

#: ../../library/asyncio-protocol.rst:249
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` method "
"until :meth:`resume_reading` is called."
msgstr ""
"トランスポートの受信側を一時停止します。 :meth:`resume_reading` メソッドが呼"
"び出されるまでプロトコルの :meth:`protocol.data_received() <Protocol."
"data_received>` メソッドにデータは渡されません。"

#: ../../library/asyncio-protocol.rst:253
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr ""
"このメソッドはべき等です。すなわちトランスポートがすでに停止していたりクロー"
"ズしていても呼び出すことができます。"

#: ../../library/asyncio-protocol.rst:259
msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received() "
"<Protocol.data_received>` method will be called once again if some data is "
"available for reading."
msgstr ""
"受信を再開します。データが読み込み可能になるとプロトコルの :meth:`protocol."
"data_received() <Protocol.data_received>` メソッドが再び呼び出されるようにな"
"ります。"

#: ../../library/asyncio-protocol.rst:263
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr ""
"このメソッドはべき等です。すなわちトランスポートがすでにデータを読み込み中で"
"あっても呼び出すことができます。"

#: ../../library/asyncio-protocol.rst:269
msgid "Write-only Transports"
msgstr "書き込み専用のトランスポート"

#: ../../library/asyncio-protocol.rst:273
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"未完了の処理が完了するのを待たず、即座にトランスポートをクローズします。バッ"
"ファーされているデータは失われます。このメソッドの呼び出し以降データは受信さ"
"れません。最終的にプロトコルの :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` メソッドが引数 :const:`None` で呼び出されま"
"す。"

#: ../../library/asyncio-protocol.rst:281
msgid ""
"Return :const:`True` if the transport supports :meth:`~WriteTransport."
"write_eof`, :const:`False` if not."
msgstr ""
"トランスポートが :meth:`~WriteTransport.write_eof` メソッドをサポートしている"
"場合 :const:`True` を返し、そうでない場合は :const:`False` を返します。"

#: ../../library/asyncio-protocol.rst:286
msgid "Return the current size of the output buffer used by the transport."
msgstr "トランスポートで使用されている出力バッファーの現在のサイズを返します。"

#: ../../library/asyncio-protocol.rst:290
msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a tuple "
"``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"書き込みフロー制御の *最高* および *最低* 水位点を取得します。 ``(low, "
"high)`` タプルを返します。ここで *low* と *high* はバイト数をあらわす正の整数"
"です。"

#: ../../library/asyncio-protocol.rst:294
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr "水位点の設定は :meth:`set_write_buffer_limits` で行います。"

#: ../../library/asyncio-protocol.rst:300
msgid "Set the *high* and *low* watermarks for write flow control."
msgstr "書き込みフロー制御の *最高* および *最低* 水位点を設定します。"

#: ../../library/asyncio-protocol.rst:302
msgid ""
"These two values (measured in number of bytes) control when the protocol's :"
"meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` and :meth:"
"`protocol.resume_writing() <BaseProtocol.resume_writing>` methods are "
"called. If specified, the low watermark must be less than or equal to the "
"high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"(バイト数をあらわす) これら2つの値はプロトコルの :meth:`protocol."
"pause_writing() <BaseProtocol.pause_writing>` と :meth:`protocol."
"resume_writing() <BaseProtocol.resume_writing>` の2つのメソッドがいつ呼ばれる"
"かを制御します。指定する場合、 *low* は *high* と等しいかまたは *high* より小"
"さくなければなりません。また、 *high* も *low* も負の値を指定することはできま"
"せん。"

#: ../../library/asyncio-protocol.rst:310
msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size becomes "
"greater than or equal to the *high* value. If writing has been paused, :meth:"
"`~BaseProtocol.resume_writing` is called when the buffer size becomes less "
"than or equal to the *low* value."
msgstr ""
":meth:`~BaseProtocol.pause_writing` はバッファーサイズが *high* の値以上に"
"なった場合に呼び出されます。書き込みが一時停止している場合、バッファーサイズ"
"が *low* の値以下になると :meth:`~BaseProtocol.resume_writing` メソッドが呼び"
"出されます。"

#: ../../library/asyncio-protocol.rst:315
msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value less "
"than or equal to the high watermark.  Setting *high* to zero forces *low* to "
"zero as well, and causes :meth:`~BaseProtocol.pause_writing` to be called "
"whenever the buffer becomes non-empty.  Setting *low* to zero causes :meth:"
"`~BaseProtocol.resume_writing` to be called only once the buffer is empty. "
"Use of zero for either limit is generally sub-optimal as it reduces "
"opportunities for doing I/O and computation concurrently."
msgstr ""
"デフォルト値は実装固有になります。 *high* のみ与えられた場合、 *low* は "
"*high* 以下の実装固有のデフォルト値になります。 *high* をゼロに設定すると "
"*low* も強制的にゼロになり、バッファーが空でなくなるとすぐに :meth:"
"`~BaseProtocol.pause_writing` メソッドが呼び出されるようになります。 *low* を"
"ゼロに設定すると、バッファーが空にな :meth:`~BaseProtocol.resume_writing` が"
"呼び出されるようになります。どちらかにゼロを設定することは I/O と計算を並行に"
"実行する機会を減少させるため、一般に最適ではありません。"

#: ../../library/asyncio-protocol.rst:326
msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr ""
"上限値と下限値を取得するには :meth:`~WriteTransport.get_write_buffer_limits` "
"メソッドを使ってください。"

#: ../../library/asyncio-protocol.rst:331
msgid "Write some *data* bytes to the transport."
msgstr "トランスポートにバイト列 *data* を書き込みます。"

#: ../../library/asyncio-protocol.rst:333
#: ../../library/asyncio-protocol.rst:362
msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr ""
"このメソッドはブロックしません; データをバッファーし、非同期に送信する準備を"
"行います。"

#: ../../library/asyncio-protocol.rst:338
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""
"バイト列のデータのリスト (またはイテラブル) をトランスポートに書き込みます。"
"この振る舞いはイテラブルを yield して各要素で :meth:`write` を呼び出すことと"
"等価ですが、より効率的な実装となる場合があります。"

#: ../../library/asyncio-protocol.rst:345
msgid ""
"Close the write end of the transport after flushing all buffered data. Data "
"may still be received."
msgstr ""
"バッファーされた全てのデータをフラッシュした後トランスポートの送信側をクロー"
"ズします。送信側をクローズした後もデータを受信することは可能です。"

#: ../../library/asyncio-protocol.rst:348
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL) "
"doesn't support half-closed connections."
msgstr ""
"このメソッドはトランスポート (例えば SSL) がハーフクローズドな接続をサポート"
"していない場合 :exc:`NotImplementedError` を送出します。"

#: ../../library/asyncio-protocol.rst:353
msgid "Datagram Transports"
msgstr "データグラムトランスポート"

#: ../../library/asyncio-protocol.rst:357
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"リモートピア *addr* (トランスポート依存の対象アドレス) にバイト列 *data* を送"
"信します。*addr* が :const:`None` の場合、データはトランスポートの作成時に指"
"定された送信先に送られます。"

#: ../../library/asyncio-protocol.rst:367
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost. No more data will be received.  The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"未完了の処理が完了するのを待たず、即座にトランスポートをクローズします。バッ"
"ファーされているデータは失われます。このメソッドの呼び出し以降データは受信さ"
"れません。最終的にプロトコルの :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` メソッドが引数 :const:`None` で呼び出されま"
"す。"

#: ../../library/asyncio-protocol.rst:377
msgid "Subprocess Transports"
msgstr "サブプロセス化されたトランスポート"

#: ../../library/asyncio-protocol.rst:381
msgid "Return the subprocess process id as an integer."
msgstr "サブプロセスのプロセス ID (整数) を返します。"

#: ../../library/asyncio-protocol.rst:385
msgid ""
"Return the transport for the communication pipe corresponding to the integer "
"file descriptor *fd*:"
msgstr ""
"整数のファイル記述子 *fd* に該当する通信パイプのトランスポートを返します:"

#: ../../library/asyncio-protocol.rst:388
msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or :"
"const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""
"``0``: 標準入力 (*stdin*) の読み込み可能ストリーミングトランスポート。サブプ"
"ロセスが ``stdin=PIPE`` で作成されていない場合は :const:`None`"

#: ../../library/asyncio-protocol.rst:390
msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or :"
"const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""
"``1``: 標準出力 (*stdout*) の書き込み可能ストリーミングトランスポート。サブプ"
"ロセスが ``stdout=PIPE`` で作成されていない場合は :const:`None`"

#: ../../library/asyncio-protocol.rst:392
msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or :"
"const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""
"``2``: 標準エラー出力 (*stderr*) の書き込み可能ストリーミングトランスポート。"
"サブプロセスが ``stderr=PIPE`` で作成されていない場合は :const:`None`"

#: ../../library/asyncio-protocol.rst:394
msgid "other *fd*: :const:`None`"
msgstr "その他の *fd*: :const:`None`"

#: ../../library/asyncio-protocol.rst:398
msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the :attr:`subprocess.Popen.returncode` "
"attribute."
msgstr ""
"サブプロセスのリターンコードを整数で返します。サブプロセスがリターンしなかっ"
"た場合は :const:`None` を返します。 :attr:`subprocess.Popen.returncode` 属性"
"と同じです。"

#: ../../library/asyncio-protocol.rst:404
msgid "Kill the subprocess."
msgstr "サブプロセスを強制終了 (kill) します。"

#: ../../library/asyncio-protocol.rst:406
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""
"POSIX システムでは、この関数はサブプロセスに SIGKILL を送信します。Windows で"
"は、このメソッドは :meth:`terminate` の別名です。"

#: ../../library/asyncio-protocol.rst:409
msgid "See also :meth:`subprocess.Popen.kill`."
msgstr ":meth:`subprocess.Popen.kill` も参照してください。"

#: ../../library/asyncio-protocol.rst:413
msgid ""
"Send the *signal* number to the subprocess, as in :meth:`subprocess.Popen."
"send_signal`."
msgstr ""
"サブプロセスにシグナル *signal* を送信します。:meth:`subprocess.Popen."
"send_signal` と同じです。"

#: ../../library/asyncio-protocol.rst:418
msgid "Stop the subprocess."
msgstr "サブプロセスを停止します。"

#: ../../library/asyncio-protocol.rst:420
msgid ""
"On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, "
"the Windows API function TerminateProcess() is called to stop the subprocess."
msgstr ""
"POSIX システムでは、このメソッドはサブプロセスに SIGTERM を送信します。"
"Windows では、Windows API 関数 TerminateProcess() が呼び出されます。"

#: ../../library/asyncio-protocol.rst:424
msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr ":meth:`subprocess.Popen.terminate` も参照してください。"

#: ../../library/asyncio-protocol.rst:428
msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr ":meth:`kill` メソッドを呼び出すことでサブプロセスを強制終了します。"

#: ../../library/asyncio-protocol.rst:430
msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr ""
"サブプロセスがまだリターンしていない場合、 *stdin*, *stdout*, および "
"*stderr* の各パイプのトランスポートをクローズします。"

#: ../../library/asyncio-protocol.rst:437
msgid "Protocols"
msgstr "プロトコル"

#: ../../library/asyncio-protocol.rst:439
msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr "**ソースコード:** :source:`Lib/asyncio/protocols.py`"

#: ../../library/asyncio-protocol.rst:443
msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together "
"with :ref:`transports <asyncio-transport>`."
msgstr ""
"asyncio はネットワークプロトコルを実装するために使う抽象基底クラス群を提供し"
"ます。これらのクラスは :ref:`トランスポート <asyncio-transport>` と組み合わせ"
"て使うことが想定されています。"

#: ../../library/asyncio-protocol.rst:447
msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports on "
"certain events, for example when some data is received. A base protocol "
"method should be called by the corresponding transport."
msgstr ""
"抽象基底プロトコルクラスの派生クラスはメソッドの一部または全てを実装すること"
"ができます。これらのメソッドは全てコールバックです: それらは、データを受信し"
"た、などの決まったイベントに対してトランスポートから呼び出されます。基底プロ"
"トコルメソッドは対応するトランスポートから呼び出されるべきです。"

#: ../../library/asyncio-protocol.rst:454
msgid "Base Protocols"
msgstr "基底プロトコル"

#: ../../library/asyncio-protocol.rst:458
msgid "Base protocol with methods that all protocols share."
msgstr ""
"全てのプロトコルクラスが共有する全てのメソッドを持った基底プロトコルクラスで"
"す。"

#: ../../library/asyncio-protocol.rst:462
msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, etc)."
msgstr ""
"ストリーミングプロトコル (TCP, Unix ソケットなど) を実装するための基底クラス"
"です。"

#: ../../library/asyncio-protocol.rst:467
msgid ""
"A base class for implementing streaming protocols with manual control of the "
"receive buffer."
msgstr ""
"受信バッファーを手動で制御するストリーミングプロトコルを実装するための基底ク"
"ラスです。"

#: ../../library/asyncio-protocol.rst:472
msgid "The base class for implementing datagram (UDP) protocols."
msgstr "データグラム (UDP) プロトコルを実装するための基底クラスです。"

#: ../../library/asyncio-protocol.rst:476
msgid ""
"The base class for implementing protocols communicating with child processes "
"(unidirectional pipes)."
msgstr ""
"子プロセスと (一方向パイプを通じて) 通信するプロトコルを実装するための基底ク"
"ラスです。"

#: ../../library/asyncio-protocol.rst:481
msgid "Base Protocol"
msgstr "基底プロトコル"

#: ../../library/asyncio-protocol.rst:483
msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr ""
"全ての asyncio プロトコルは基底プロトコルのコールバックを実装することができま"
"す。"

#: ../../library/asyncio-protocol.rst:486
msgid "Connection Callbacks"
msgstr "通信のコールバック"

#: ../../library/asyncio-protocol.rst:487
msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr ""
"コネクションコールバックは全てのプロトコルから、成功したコネクションそれぞれ"
"につきただ一度だけ呼び出されます。その他の全てのプロトコルコールバックはこれ"
"ら2つのメソッドの間に呼び出すことができます。 "

#: ../../library/asyncio-protocol.rst:493
msgid "Called when a connection is made."
msgstr "コネクションが作成されたときに呼び出されます。"

#: ../../library/asyncio-protocol.rst:495
msgid ""
"The *transport* argument is the transport representing the connection.  The "
"protocol is responsible for storing the reference to its transport."
msgstr ""
"引数 *transport* はコネクションをあらわすトランスポートです。プロトコルはトラ"
"ンスポートへの参照を保存する責任を負います。"

#: ../../library/asyncio-protocol.rst:501
msgid "Called when the connection is lost or closed."
msgstr "コネクションが失われた、あるいはクローズされたときに呼び出されます。"

#: ../../library/asyncio-protocol.rst:503
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr ""
"引数は例外オブジェクトまたは :const:`None` になります。:const:`None` のとき、"
"通常の EOF が受信されたか、あるいはコネクションがこちら側から中止またはクロー"
"ズされたことを意味します。"

#: ../../library/asyncio-protocol.rst:509
msgid "Flow Control Callbacks"
msgstr "フロー制御コールバック"

#: ../../library/asyncio-protocol.rst:510
msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr ""
"フロー制御コールバックは、プロトコルによって実行される書き込み処理を停止また"
"は再開するためにトランスポートから呼び出されます。"

#: ../../library/asyncio-protocol.rst:513
msgid ""
"See the documentation of the :meth:`~WriteTransport.set_write_buffer_limits` "
"method for more details."
msgstr ""
"詳しくは :meth:`~WriteTransport.set_write_buffer_limits` メソッドのドキュメン"
"トを参照してください。"

#: ../../library/asyncio-protocol.rst:518
msgid "Called when the transport's buffer goes over the high watermark."
msgstr ""
"トランスポートのバッファーサイズが最高水位点 (high watermark) を超えたときに"
"呼び出されます。"

#: ../../library/asyncio-protocol.rst:522
msgid "Called when the transport's buffer drains below the low watermark."
msgstr ""
"トランスポートのバッファーサイズが最低水位点 (low watermark) に達したきに呼び"
"出されます。"

#: ../../library/asyncio-protocol.rst:524
msgid ""
"If the buffer size equals the high watermark, :meth:`~BaseProtocol."
"pause_writing` is not called: the buffer size must go strictly over."
msgstr ""
"バッファーサイズが最高水位点と等しい場合、 :meth:`~BaseProtocol."
"pause_writing` は呼び出されません: バッファーサイズは必ず制限値を超えなければ"
"なりません。"

#: ../../library/asyncio-protocol.rst:528
msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size is equal or lower than the low watermark.  These end conditions are "
"important to ensure that things go as expected when either mark is zero."
msgstr ""
"それに対して、 :meth:`~BaseProtocol.resume_writing` はバッファーサイズが最低"
"水位点と等しいかそれよりも小さい場合に呼び出されます。これらの境界条件は、ど"
"ちらの基準値もゼロである場合の処理が期待通りとなることを保証するために重要で"
"す。"

#: ../../library/asyncio-protocol.rst:535
msgid "Streaming Protocols"
msgstr "ストリーミングプロトコル"

#: ../../library/asyncio-protocol.rst:537
msgid ""
"Event methods, such as :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, and :meth:`loop.connect_write_pipe` accept factories "
"that return streaming protocols."
msgstr ""
":meth:`loop.create_server`, :meth:`loop.create_unix_server`, :meth:`loop."
"create_connection`, :meth:`loop.create_unix_connection`, :meth:`loop."
"connect_accepted_socket`, :meth:`loop.connect_read_pipe`, そして :meth:`loop."
"connect_write_pipe` などのイベントメソッドはストリーミングプロトコルを返す"
"ファクトリを受け付けます。"

#: ../../library/asyncio-protocol.rst:545
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr ""
"データを受信したときに呼び出されます。*data* は受信したデータを含む空ではない"
"バイト列オブジェクトになります。"

#: ../../library/asyncio-protocol.rst:548
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead "
"make your parsing generic and flexible. However, data is always received in "
"the correct order."
msgstr ""
"データがバッファーされるか、チャンキングされるか、または再構築されるかはトラ"
"ンスポートに依存します。一般には、特定のセマンティクスを信頼するべきではな"
"く、代わりにデータのパースを全般的かつ柔軟に行うべきです。ただし、データは常"
"に正しい順序で受信されます。"

#: ../../library/asyncio-protocol.rst:553
msgid ""
"The method can be called an arbitrary number of times while a connection is "
"open."
msgstr ""
"このメソッドは、コネクションがオープンである間は何度でも呼び出すことができま"
"す。"

#: ../../library/asyncio-protocol.rst:556
msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is called "
"at most once.  Once ``eof_received()`` is called, ``data_received()`` is not "
"called anymore."
msgstr ""

#: ../../library/asyncio-protocol.rst:562
msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`transport.write_eof() <WriteTransport.write_eof>`, if the "
"other end also uses asyncio)."
msgstr ""
"コネクションの相手方がこれ以上データを送信しないことを伝えてきたとき (例えば"
"相手方が asyncio を使用しており、 :meth:`transport.write_eof() "
"<WriteTransport.write_eof>` を呼び出した場合) に呼び出されます。"

#: ../../library/asyncio-protocol.rst:567
msgid ""
"This method may return a false value (including ``None``), in which case the "
"transport will close itself.  Conversely, if this method returns a true "
"value, the protocol used determines whether to close the transport. Since "
"the default implementation returns ``None``, it implicitly closes the "
"connection."
msgstr ""
"このメソッドは (``None`` を含む) 偽値 を返すことがあり、その場合トランスポー"
"トは自身をクローズします。一方メソッドが真値を返す場合は、利用しているプロト"
"コルがトランスポートをクローズするかどうかを決めます。デフォルトの実装は "
"``None`` を返すため、コネクションは暗黙のうちにクローズされます。"

#: ../../library/asyncio-protocol.rst:573
msgid ""
"Some transports, including SSL, don't support half-closed connections, in "
"which case returning true from this method will result in the connection "
"being closed."
msgstr ""
"SSL を含む一部のトランスポートはハーフクローズ接続をサポートしません。そのよ"
"うな場合このメソッドが真値を返すとコネクションはクローズされます。"

#: ../../library/asyncio-protocol.rst:578
#: ../../library/asyncio-protocol.rst:636
msgid "State machine:"
msgstr "ステートマシン:"

#: ../../library/asyncio-protocol.rst:589
msgid "Buffered Streaming Protocols"
msgstr "バッファリングされたストリーミングプロトコル"

#: ../../library/asyncio-protocol.rst:593
msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr ""
"バッファー付きプロトコルは  `ストリーミングプロトコル`_ をサポートするイベン"
"トループメソッドで利用することができます。"

#: ../../library/asyncio-protocol.rst:596
msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and "
"control of the receive buffer.  Event loops can then use the buffer provided "
"by the protocol to avoid unnecessary data copies.  This can result in "
"noticeable performance improvement for protocols that receive big amounts of "
"data.  Sophisticated protocol implementations can significantly reduce the "
"number of buffer allocations."
msgstr ""
"``BufferedProtocol`` 実装は受信バッファーの手動での明示的な割り当てや制御を可"
"能にします。イベントループはプロトコルにより提供されるバッファを利用すること"
"により不要なデータのコピーを避けることができます。これにより大量のデータを受"
"信するプロトコルにおいて顕著なパフォーマンスの向上をもたらします。精巧なプロ"
"トコル実装によりバッファー割り当ての数を劇的に減少させることができます。"

#: ../../library/asyncio-protocol.rst:603
msgid ""
"The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr ""
"以下に示すコールバックは :class:`BufferedProtocol` インスタンスに対して呼び出"
"されます:"

#: ../../library/asyncio-protocol.rst:608
msgid "Called to allocate a new receive buffer."
msgstr "新しい受信バッファを割り当てるために呼び出します。"

#: ../../library/asyncio-protocol.rst:610
msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It is "
"acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an error "
"to return a buffer with a zero size."
msgstr ""
"*sizehint* は返されるバッファーの推奨される最小サイズです。 *sizehint* によっ"
"て推奨された値より小さい、または大きいサイズのバッファーを返すことは容認され"
"ています。 -1 がセットされた場合、バッファーサイズは任意となります。サイズが"
"ゼロのバッファーを返すとエラーになります。"

#: ../../library/asyncio-protocol.rst:615
msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr ""
"``get_buffer()`` は :ref:`バッファープロトコル <bufferobjects>` を実装したオ"
"ブジェクトを返さなければなりません。"

#: ../../library/asyncio-protocol.rst:620
msgid "Called when the buffer was updated with the received data."
msgstr "受信データによりバッファが更新された場合に呼び出されます。"

#: ../../library/asyncio-protocol.rst:622
msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr "*nbytes* はバッファに書き込まれた総バイト数です。"

#: ../../library/asyncio-protocol.rst:626
msgid ""
"See the documentation of the :meth:`protocol.eof_received() <Protocol."
"eof_received>` method."
msgstr ""
":meth:`protocol.eof_received() <Protocol.eof_received>` メソッドのドキュメン"
"トを参照してください。"

#: ../../library/asyncio-protocol.rst:630
msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of "
"times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, :meth:"
"`~BufferedProtocol.get_buffer` and :meth:`~BufferedProtocol.buffer_updated` "
"won't be called after it."
msgstr ""
"コネクションの間、 :meth:`~BufferedProtocol.get_buffer` は何度でも呼び出すこ"
"とができます。しかし :meth:`protocol.eof_received() <Protocol.eof_received>` "
"が呼び出されるのは最大でも1回で、もし呼び出されると、それ以降 :meth:"
"`~BufferedProtocol.get_buffer` と :meth:`~BufferedProtocol.buffer_updated` が"
"呼び出されることはありません。"

#: ../../library/asyncio-protocol.rst:649
msgid "Datagram Protocols"
msgstr "データグラムプロトコル"

#: ../../library/asyncio-protocol.rst:651
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr ""
"データグラムプロトコルのインスタンスは :meth:`loop.create_datagram_endpoint` "
"メソッドに渡されたプロトコルファクトリによって生成されるべきです。"

#: ../../library/asyncio-protocol.rst:656
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the "
"incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""
"データグラムを受信したときに呼び出されます。*data* は受信データを含むバイトオ"
"ブジェクトです。*addr* はデータを送信するピアのアドレスです; 正確な形式はトラ"
"ンスポートに依存します。"

#: ../../library/asyncio-protocol.rst:662
msgid ""
"Called when a previous send or receive operation raises an :class:"
"`OSError`.  *exc* is the :class:`OSError` instance."
msgstr ""
"直前の送信あるいは受信が :class:`OSError` を送出したときに呼び出されます。"
"*exc* は :class:`OSError` のインスタンスになります。"

#: ../../library/asyncio-protocol.rst:665
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""
"このメソッドが呼ばれるのは、トランスポート (UDP など) がデータグラムを受信側"
"に配信できなかったことが検出されたなどの、まれな場合においてのみです。ほとん"
"どの場合、データグラムが配信できなければそのまま通知されることなく破棄されま"
"す。"

#: ../../library/asyncio-protocol.rst:672
msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send failures "
"caused by writing too many packets."
msgstr ""
"BSD システム (macOS, FreeBSD など) ではフロー制御はサポートされていません。こ"
"れは非常に多くのパケットを書き込もうとしたことによる送信の失敗を検出する信頼"
"できる方法が存在しないためです。"

#: ../../library/asyncio-protocol.rst:676
msgid ""
"The socket always appears 'ready' and excess packets are dropped. An :class:"
"`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may not be "
"raised; if it is raised, it will be reported to :meth:`DatagramProtocol."
"error_received` but otherwise ignored."
msgstr ""
"ソケットは常に '準備ができた状態' のように振る舞いますが、超過したパケットは"
"破棄されます。この場合 ``errno`` を :const:`errno.ENOBUFS` に設定した :class:"
"`OSError` 例外が送出されることがあります。もし例外が送出された場合は :meth:"
"`DatagramProtocol.error_received` に通知されますが、送出されない場合は単に無"
"視されます。"

#: ../../library/asyncio-protocol.rst:685
msgid "Subprocess Protocols"
msgstr "サブプロセスプロトコル"

#: ../../library/asyncio-protocol.rst:687
msgid ""
"Subprocess Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ""
"サブプロセスプロトコルのインスタンスは  :meth:`loop.subprocess_exec` と :"
"meth:`loop.subprocess_shell` メソッドに渡されたプロトコルファクトリにより生成"
"されるべきです。"

#: ../../library/asyncio-protocol.rst:693
msgid ""
"Called when the child process writes data into its stdout or stderr pipe."
msgstr ""
"子プロセスが標準出力または標準エラー出力のパイプにデータを書き込んだ時に呼び"
"出されます。"

#: ../../library/asyncio-protocol.rst:696
msgid "*fd* is the integer file descriptor of the pipe."
msgstr "*fd* はパイプのファイル記述子を表す整数です。"

#: ../../library/asyncio-protocol.rst:698
msgid "*data* is a non-empty bytes object containing the received data."
msgstr "*data* は受信データを含む空でないバイトオブジェクトです。"

#: ../../library/asyncio-protocol.rst:702
msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr ""
"子プロセスと通信するパイプのいずれかがクローズされたときに呼び出されます。"

#: ../../library/asyncio-protocol.rst:705
msgid "*fd* is the integer file descriptor that was closed."
msgstr "*fd* はクローズされたファイル記述子を表す整数です。"

#: ../../library/asyncio-protocol.rst:709
msgid "Called when the child process has exited."
msgstr "子プロセスが終了したときに呼び出されます。"

#: ../../library/asyncio-protocol.rst:713
msgid "Examples"
msgstr "使用例"

#: ../../library/asyncio-protocol.rst:718
msgid "TCP Echo Server"
msgstr "TCP エコーサーバー"

#: ../../library/asyncio-protocol.rst:720
msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, send "
"back received data, and close the connection::"
msgstr ""
":meth:`loop.create_server` メソッドを使って TCP エコーサーバーを生成し、受信"
"したデータをそのまま送り返して、最後にコネクションをクローズします::"

#: ../../library/asyncio-protocol.rst:761
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the high-level :func:`asyncio.start_server` function."
msgstr ""
":ref:`ストリームを使った TCP エコーサーバー <asyncio-tcp-echo-server-"
"streams>` の例では高水準の :func:`asyncio.start_server` 関数を使っています。"

#: ../../library/asyncio-protocol.rst:767
msgid "TCP Echo Client"
msgstr "TCP エコークライアント"

#: ../../library/asyncio-protocol.rst:769
msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr ""
":meth:`loop.create_connection` メソッドを使った TCP エコークライアントは、"
"データを送信したあとコネクションがクローズされるまで待機します::"

#: ../../library/asyncio-protocol.rst:817
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the high-level :func:`asyncio.open_connection` function."
msgstr ""
":ref:`ストリームを使った TCP エコークライアント <asyncio-tcp-echo-client-"
"streams>` の例では高水準の :func:`asyncio.open_connection` 関数を使っていま"
"す。"

#: ../../library/asyncio-protocol.rst:824
msgid "UDP Echo Server"
msgstr "UDP エコーサーバー"

#: ../../library/asyncio-protocol.rst:826
msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` method, "
"sends back received data::"
msgstr ""
":meth:`loop.create_datagram_endpoint` メソッドを使った UDP エコーサーバーは受"
"信したデータをそのまま送り返します::"

#: ../../library/asyncio-protocol.rst:868
msgid "UDP Echo Client"
msgstr "UDP エコークライアント"

#: ../../library/asyncio-protocol.rst:870
msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` method, "
"sends data and closes the transport when it receives the answer::"
msgstr ""
":meth:`loop.create_datagram_endpoint` メソッドを使った UDP エコークライアント"
"はデータを送信し、応答を受信するとトランスポートをクローズします::"

#: ../../library/asyncio-protocol.rst:925
msgid "Connecting Existing Sockets"
msgstr "既存のソケットへの接続"

#: ../../library/asyncio-protocol.rst:927
msgid ""
"Wait until a socket receives data using the :meth:`loop.create_connection` "
"method with a protocol::"
msgstr ""
"プロトコルを設定した :meth:`loop.create_connection` メソッドを使ってソケット"
"がデータを受信するまで待機します::"

#: ../../library/asyncio-protocol.rst:981
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to register an FD."
msgstr ""
":ref:`ファイル記述子の読み込みイベントを監視する <asyncio_example_watch_fd>` "
"例では低レベルの :meth:`loop.add_reader` メソッドを使ってファイル記述子 (FD) "
"を登録しています。"

#: ../../library/asyncio-protocol.rst:985
msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level streams "
"created by the :func:`open_connection` function in a coroutine."
msgstr ""
":ref:`ストリームを使ってデータを待ち受けるオープンなソケットを登録する "
"<asyncio_example_create_connection-streams>` 例ではコルーチン内で :func:"
"`open_connection` 関数によって生成されたストリームを使っています。"

#: ../../library/asyncio-protocol.rst:992
msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr "loop.subprocess_exec() と SubprocessProtocol"

#: ../../library/asyncio-protocol.rst:994
msgid ""
"An example of a subprocess protocol used to get the output of a subprocess "
"and to wait for the subprocess exit."
msgstr ""
"サブプロセスからの出力を受け取り、サブプロセスが終了するまで待機するために使"
"われるサブプロセスプロトコルの例です。"

#: ../../library/asyncio-protocol.rst:997
msgid "The subprocess is created by the :meth:`loop.subprocess_exec` method::"
msgstr ""
"サブプロセスは :meth:`loop.subprocess_exec` メソッドにより生成されます::"

#: ../../library/asyncio-protocol.rst:1043
msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>` "
"written using high-level APIs."
msgstr ""
"高水準の API を使って書かれた :ref:`同様の例 "
"<asyncio_example_create_subprocess_exec>` も参照してください。"
