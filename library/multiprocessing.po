# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017-2018
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-08 17:08+0900\n"
"PO-Revision-Date: 2018-05-08 08:18+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/multiprocessing.rst:2
msgid ":mod:`multiprocessing` --- Process-based \"threading\" interface"
msgstr ":mod:`multiprocessing` --- ãƒ—ãƒ­ã‚»ã‚¹ãƒ™ãƒ¼ã‚¹ã® \"ä¸¦åˆ—å‡¦ç†\" ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹"

#: ../../library/multiprocessing.rst:11
msgid "Introduction"
msgstr "ã¯ã˜ã‚ã«"

#: ../../library/multiprocessing.rst:13
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock` by using subprocesses instead of "
"threads.  Due to this, the :mod:`multiprocessing` module allows the "
"programmer to fully leverage multiple processors on a given machine.  It "
"runs on both Unix and Windows."
msgstr ":mod:`multiprocessing` ã¯ã€ :mod:`threading` ã¨ä¼¼ãŸ API ã§è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç”Ÿæˆã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã™ã€‚ :mod:`multiprocessing` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€ãƒ­ãƒ¼ã‚«ãƒ«ã¨ãƒªãƒ¢ãƒ¼ãƒˆä¸¡æ–¹ã®ä¸¦è¡Œå‡¦ç†ã‚’æä¾›ã—ã¾ã™ã€‚ã¾ãŸã€ã“ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã®ä»£ã‚ã‚Šã«ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€:term:`ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ­ãƒƒã‚¯ <Global Interpreter Lock>` ã®å•é¡Œã‚’é¿ã‘ã‚‹å·¥å¤«ãŒè¡Œã‚ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ã‚ˆã†ãªç‰¹å¾´ãŒã‚ã‚‹ãŸã‚ :mod:`multiprocessing` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã†ã“ã¨ã§ã€ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼ãƒã‚·ãƒ³ã®æ€§èƒ½ã‚’æœ€å¤§é™ã«æ´»ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã§ã—ã‚‡ã†ã€‚ãªãŠã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ Unix ã¨ Windows ã§å‹•ä½œã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:21
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the "
":class:`Pool` object which offers a convenient means of parallelizing the "
"execution of a function across multiple input values, distributing the input"
" data across processes (data parallelism).  The following example "
"demonstrates the common practice of defining such functions in a module so "
"that child processes can successfully import that module.  This basic "
"example of data parallelism using :class:`Pool`, ::"
msgstr ":mod:`multiprocessing` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ :mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ä¼¼ãŸã‚‚ã®ãŒãªã„ API ã‚‚å°å…¥ã—ã¦ã„ã¾ã™ã€‚ãã®æœ€ãŸã‚‹ã‚‚ã®ãŒ :class:`~multiprocessing.pool.Pool` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã“ã‚Œã¯è¤‡æ•°ã®å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã€ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ç¾¤ã«å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†é…ã—ã¦ä¸¦åˆ—ã«é–¢æ•°å®Ÿè¡Œã™ã‚‹ (ãƒ‡ãƒ¼ã‚¿ä¸¦åˆ—) ã®ã«ä¾¿åˆ©ãªæ‰‹æ®µã‚’æä¾›ã—ã¾ã™ã€‚ä»¥ä¸‹ã®ä¾‹ã§ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§é–¢æ•°ã‚’å®šç¾©ã™ã‚‹ã®ã«ã€å­ãƒ—ãƒ­ã‚»ã‚¹ãŒãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã¤ã¤ãŒãªãã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡ºæ¥ã‚‹ã‚ˆã†ã«ã™ã‚‹ä¸€èˆ¬çš„ãªæ…£ä¾‹ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚ :class:`~multiprocessing.pool.Pool` ã‚’ç”¨ã„ãŸãƒ‡ãƒ¼ã‚¿ä¸¦åˆ—ã®åŸºç¤çš„ãªå®Ÿä¾‹ã¯ã“ã®ã‚ˆã†ãªã‚‚ã®ã§ã™::"

#: ../../library/multiprocessing.rst:39
msgid "will print to standard output ::"
msgstr "æ¨™æº–å‡ºåŠ›ã«ä»¥ä¸‹ãŒå‡ºåŠ›ã•ã‚Œã¾ã™::"

#: ../../library/multiprocessing.rst:45
msgid "The :class:`Process` class"
msgstr ":class:`Process` ã‚¯ãƒ©ã‚¹"

#: ../../library/multiprocessing.rst:47
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a "
":class:`Process` object and then calling its :meth:`~Process.start` method."
"  :class:`Process` follows the API of :class:`threading.Thread`.  A trivial "
"example of a multiprocess program is ::"
msgstr ":mod:`multiprocessing` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ãƒ—ãƒ­ã‚»ã‚¹ã¯ä»¥ä¸‹ã®æ‰‹é †ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã¾ã™ã€‚ã¯ã˜ã‚ã« :class:`Process` ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã€ç¶šã„ã¦ :meth:`~Process.start` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ã“ã® :class:`Process` ã‚¯ãƒ©ã‚¹ã¯ :class:`threading.Thread` ã‚¯ãƒ©ã‚¹ã¨åŒæ§˜ã® API ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã¾ãšã¯ã€ç°¡å˜ãªä¾‹ã‚’ã‚‚ã¨ã«ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½¿ç”¨ã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¤ã„ã¦ã¿ã¦ã„ãã¾ã—ã‚‡ã† ::"

#: ../../library/multiprocessing.rst:62
msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr "å®Ÿè¡Œã•ã‚ŒãŸå€‹ã€…ã®ãƒ—ãƒ­ã‚»ã‚¹ ID ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã«æ‹¡å¼µã—ãŸã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../library/multiprocessing.rst:84
msgid ""
"For an explanation of why (on Windows) the ``if __name__ == '__main__'`` "
"part is necessary, see :ref:`multiprocessing-programming`."
msgstr "(Windows ç’°å¢ƒã§) ``if __name__ == '__main__'`` ã¨ã„ã†è¨˜è¿°ãŒå¿…è¦ãªç†ç”±ã«ã¤ã„ã¦ã¯ã€ :ref:`multiprocessing-programming` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:89
msgid "Exchanging objects between processes"
msgstr "ãƒ—ãƒ­ã‚»ã‚¹é–“ã§ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆäº¤æ›"

#: ../../library/multiprocessing.rst:91
msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ":mod:`multiprocessing` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ãƒ—ãƒ­ã‚»ã‚¹é–“é€šä¿¡ã®æ‰‹æ®µãŒ2ã¤ç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚ãã‚Œãã‚Œä»¥ä¸‹ã«è©³ç´°ã‚’ç¤ºã—ã¾ã™:"

#: ../../library/multiprocessing.rst:94
msgid "**Queues**"
msgstr "**ã‚­ãƒ¥ãƒ¼ (Queue)**"

#: ../../library/multiprocessing.rst:96
msgid ""
"The :class:`~multiprocessing.Queue` class is a near clone of "
":class:`Queue.Queue`.  For example::"
msgstr ":class:`~multiprocessing.Queue` ã‚¯ãƒ©ã‚¹ã¯ :class:`Queue.Queue` ã‚¯ãƒ©ã‚¹ã¨ã»ã¨ã‚“ã©åŒã˜ã‚ˆã†ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚ ::"

#: ../../library/multiprocessing.rst:111
msgid "Queues are thread and process safe."
msgstr "ã‚­ãƒ¥ãƒ¼ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã‚ã‚Šã€ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:113
msgid "**Pipes**"
msgstr "**ãƒ‘ã‚¤ãƒ— (Pipe)**"

#: ../../library/multiprocessing.rst:115
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ":func:`Pipe` é–¢æ•°ã¯ãƒ‘ã‚¤ãƒ—ã§ç¹‹ãŒã‚ŒãŸã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒšã‚¢ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯åŒæ–¹å‘æ€§ãƒ‘ã‚¤ãƒ—ã‚’è¿”ã—ã¾ã™ã€‚ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../library/multiprocessing.rst:131
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and "
":meth:`~Connection.recv` methods (among others).  Note that data in a pipe "
"may become corrupted if two processes (or threads) try to read from or write"
" to the *same* end of the pipe at the same time.  Of course there is no risk"
" of corruption from processes using different ends of the pipe at the same "
"time."
msgstr "ãƒ‘ã‚¤ãƒ—ã®ãã‚Œãã‚Œã®ç«¯ã‚’è¡¨ã™2ã¤ã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ :func:`Pipe` é–¢æ•°ã‹ã‚‰è¿”ã•ã‚Œã¾ã™ã€‚å„ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€ :meth:`~Connection.send`ã€ :meth:`~Connection.recv`ã€ãã®ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚2ã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ (ã¾ãŸã¯ã‚¹ãƒ¬ãƒƒãƒ‰) ãŒãƒ‘ã‚¤ãƒ—ã® *åŒã˜* ç«¯ã§åŒæ™‚ã«èª­ã¿è¾¼ã¿ã‚„æ›¸ãè¾¼ã¿ã‚’è¡Œã†ã¨ã€ãƒ‘ã‚¤ãƒ—å†…ã®ãƒ‡ãƒ¼ã‚¿ãŒç ´æã—ã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã‚‚ã¡ã‚ã‚“ã€å„ãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ‘ã‚¤ãƒ—ã®åˆ¥ã€…ã®ç«¯ã‚’åŒæ™‚ã«ä½¿ç”¨ã™ã‚‹ãªã‚‰ã°ã€ãƒ‡ãƒ¼ã‚¿ãŒç ´å£Šã•ã‚Œã‚‹å±é™ºæ€§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:141
msgid "Synchronization between processes"
msgstr "ãƒ—ãƒ­ã‚»ã‚¹é–“ã®åŒæœŸ"

#: ../../library/multiprocessing.rst:143
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure"
" that only one process prints to standard output at a time::"
msgstr ":mod:`multiprocessing` ã¯ :mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ç­‰ä¾¡ãªåŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’å‚™ãˆã¦ã„ã¾ã™ã€‚ä»¥ä¸‹ã®ä¾‹ã§ã¯ã€ãƒ­ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¦ã€ä¸€åº¦ã«1ã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ã—ã‹æ¨™æº–å‡ºåŠ›ã«æ›¸ãè¾¼ã¾ãªã„ã‚ˆã†ã«ã—ã¦ã„ã¾ã™::"

#: ../../library/multiprocessing.rst:160
msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr "ãƒ­ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ãªã„ã§æ¨™æº–å‡ºåŠ›ã«æ›¸ãè¾¼ã‚“ã å ´åˆã¯ã€å„ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ã®å‡ºåŠ›ãŒã”ã¡ã‚ƒã¾ãœã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:165
msgid "Sharing state between processes"
msgstr "ãƒ—ãƒ­ã‚»ã‚¹é–“ã§ã®çŠ¶æ…‹ã®å…±æœ‰"

#: ../../library/multiprocessing.rst:167
msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when"
" using multiple processes."
msgstr "ã“ã‚Œã¾ã§ã®è©±ã®æµã‚Œã§è§¦ã‚ŒãŸã¨ãŠã‚Šã€ä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’è¡Œã†ã¨ãã«ã¯ã€ã§ãã‚‹ã‹ãã‚ŠçŠ¶æ…‹ã‚’å…±æœ‰ã—ãªã„ã®ãŒå®šçŸ³ã§ã™ã€‚è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã¨ãã¯ç‰¹ã«ãã†ã§ã—ã‚‡ã†ã€‚"

#: ../../library/multiprocessing.rst:171
msgid ""
"However, if you really do need to use some shared data then "
":mod:`multiprocessing` provides a couple of ways of doing so."
msgstr "ã—ã‹ã—ã€ã©ã†ã—ã¦ã‚‚ãƒ—ãƒ­ã‚»ã‚¹é–“ã®ãƒ‡ãƒ¼ã‚¿å…±æœ‰ãŒå¿…è¦ãªå ´åˆã®ãŸã‚ã« :mod:`multiprocessing` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯2ã¤ã®æ–¹æ³•ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:174
msgid "**Shared memory**"
msgstr "**å…±æœ‰ãƒ¡ãƒ¢ãƒª (Shared memory)**"

#: ../../library/multiprocessing.rst:176
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or "
":class:`Array`.  For example, the following code ::"
msgstr "ãƒ‡ãƒ¼ã‚¿ã‚’å…±æœ‰ãƒ¡ãƒ¢ãƒªä¸Šã«ä¿æŒã™ã‚‹ãŸã‚ã« :class:`Value` ã‚¯ãƒ©ã‚¹ã€ã‚‚ã—ãã¯ :class:`Array` ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä»¥ä¸‹ã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ã€ã“ã®æ©Ÿèƒ½ã«ã¤ã„ã¦ã¿ã¦ã„ãã¾ã—ã‚‡ã† ::"

#: ../../library/multiprocessing.rst:197 ../../library/multiprocessing.rst:244
msgid "will print ::"
msgstr "ã“ã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«è¡¨ç¤ºã•ã‚Œã¾ã™ ::"

#: ../../library/multiprocessing.rst:202
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are"
" typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared"
" objects will be process and thread-safe."
msgstr "``num`` ã¨ ``arr`` ã‚’ç”Ÿæˆã™ã‚‹ã¨ãã«ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã€å¼•æ•° ``'d'`` ã¨ ``'i'`` ã¯ :mod:`array` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ˆã‚Šä½¿ç”¨ã•ã‚Œã‚‹ç¨®åˆ¥ã®å‹ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚ã“ã“ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ ``'d'`` ã¯å€ç²¾åº¦æµ®å‹•å°æ•°ã€ ``'i'`` ã¯ç¬¦å·ä»˜æ•´æ•°ã‚’è¡¨ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•ã§ã‚ã‚Šã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:207
msgid ""
"For more flexibility in using shared memory one can use the "
":mod:`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr "å…±æœ‰ãƒ¡ãƒ¢ãƒªã‚’ä½¿ç”¨ã—ã¦ã€ã•ã‚‰ã«æŸ”è»Ÿãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’è¡Œã†ã«ã¯ :mod:`multiprocessing.sharedctypes` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸä»»æ„ã® ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:211
msgid "**Server process**"
msgstr "**ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ (Server process)**"

#: ../../library/multiprocessing.rst:213
msgid ""
"A manager object returned by :func:`Manager` controls a server process which"
" holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ":func:`Manager` é–¢æ•°ã«ã‚ˆã‚Šç”Ÿæˆã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç®¡ç†ã—ã¾ã™ã€‚ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ Python ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿æŒã—ã¦ã€ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§ãã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ“ä½œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:217
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, "
":class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, "
":class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, "
":class:`Event`, :class:`~multiprocessing.Queue`, :class:`Value` and "
":class:`Array`.  For example, ::"
msgstr ":func:`Manager` é–¢æ•°ãŒè¿”ã™ãƒãƒãƒ¼ã‚¸ãƒ£ã¯ :class:`list` ã€ :class:`dict` ã€ :class:`~managers.Namespace` ã€ :class:`Lock` ã€ :class:`RLock` ã€ :class:`Semaphore` ã€ :class:`BoundedSemaphore` ã€ :class:`Condition` ã€ :class:`Event` ã€ :class:`~multiprocessing.Queue` ã€ :class:`Value` ã€ :class:`Array` ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ä»¥ä¸‹ã«ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’ç¤ºã—ã¾ã™ã€‚ ::"

#: ../../library/multiprocessing.rst:249
msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr "ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å…±æœ‰ãƒ¡ãƒ¢ãƒªã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚ˆã‚Šã‚‚æŸ”è»Ÿã§ã‚ã‚‹ã¨ã„ãˆã¾ã™ã€‚ãã‚Œã¯ã€ã©ã®ã‚ˆã†ãªå‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚ä½¿ãˆã‚‹ã‹ã‚‰ã§ã™ã€‚ã¾ãŸã€1ã¤ã®ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çµŒç”±ã§ä»–ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ä¸Šã®ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚ˆã£ã¦å…±æœ‰ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã—ã‹ã—ã€å…±æœ‰ãƒ¡ãƒ¢ãƒªã‚ˆã‚Šå‹•ä½œãŒé…ã„ã¨ã„ã†æ¬ ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:256
msgid "Using a pool of workers"
msgstr "ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ—ãƒ¼ãƒ«ã‚’ä½¿ç”¨"

#: ../../library/multiprocessing.rst:258
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ":class:`~multiprocessing.pool.Pool` ã‚¯ãƒ©ã‚¹ã¯ã€ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’ãƒ—ãƒ¼ãƒ«ã™ã‚‹æ©Ÿèƒ½ã‚’å‚™ãˆã¦ã„ã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã«ã¯ã€ç•°ãªã‚‹æ–¹æ³•ã§ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã¸ã‚¿ã‚¹ã‚¯ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã„ãã¤ã‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:262
msgid "For example::"
msgstr "ä¾‹ãˆã°::"

#: ../../library/multiprocessing.rst:300
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr "ãƒ—ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãã®ãƒ—ãƒ¼ãƒ«ã‚’ä½œæˆã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã®ã¿ãŒå‘¼ã³å‡ºã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:305
msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`Pool` examples will not work in the "
"interactive interpreter. For example::"
msgstr "ã“ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å«ã¾ã‚Œã‚‹æ©Ÿèƒ½ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã«ã¯ã€å­ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ ``__main__`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã“ã¨ã«ã¤ã„ã¦ã¯ :ref:`multiprocessing-programming` ã§è§¦ã‚Œã¦ã„ã¾ã™ãŒã€ã“ã“ã§ã‚ã‚‰ãŸã‚ã¦å¼·èª¿ã—ã¦ãŠãã¾ã™ã€‚ãªãœã‹ã¨ã„ã†ã¨ã€ã„ãã¤ã‹ã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã€ä¾‹ãˆã° :class:`multiprocessing.pool.Pool` ã®ã‚µãƒ³ãƒ—ãƒ«ã¯ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã‚·ã‚§ãƒ«ä¸Šã§ã¯å‹•ä½œã—ãªã„ã‹ã‚‰ã§ã™ã€‚ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../library/multiprocessing.rst:327
msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the master process "
"somehow.)"
msgstr "(ã“ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’è©¦ã™ã¨ã€3ã¤ã®ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã™ã¹ã¦ãŒã»ã¼ãƒ©ãƒ³ãƒ€ãƒ ã«äº¤äº’ã«é‡ãªã£ã¦è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ãã†ãªã£ãŸã‚‰ã€ãªã‚“ã¨ã‹ã—ã¦ãƒã‚¹ã‚¿ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ­¢ã‚ã¾ã—ã‚‡ã†ã€‚)"

#: ../../library/multiprocessing.rst:333
msgid "Reference"
msgstr "ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹"

#: ../../library/multiprocessing.rst:335
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the "
":mod:`threading` module."
msgstr ":mod:`multiprocessing` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ :mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® API ã¨ã»ã¨ã‚“ã©åŒã˜ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:340
msgid ":class:`Process` and exceptions"
msgstr ":class:`Process` ã‚¯ãƒ©ã‚¹ã¨ä¾‹å¤–"

#: ../../library/multiprocessing.rst:344
msgid ""
"Process objects represent activity that is run in a separate process. The "
":class:`Process` class has equivalents of all the methods of "
":class:`threading.Thread`."
msgstr "Process ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å„ãƒ—ãƒ­ã‚»ã‚¹ã®å‡¦ç†ã‚’è¡¨ã—ã¾ã™ã€‚ :class:`Process` ã‚¯ãƒ©ã‚¹ã¯ :class:`threading.Thread` ã‚¯ãƒ©ã‚¹ã®ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒã˜ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:348
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with "
":class:`threading.Thread`.  *target* is the callable object to be invoked by"
" the :meth:`run()` method.  It defaults to ``None``, meaning nothing is "
"called. *name* is the process name.  By default, a unique name is "
"constructed of the form 'Process-N\\ :sub:`1`:N\\ :sub:`2`:...:N\\ :sub:`k`'"
" where N\\ :sub:`1`,N\\ :sub:`2`,...,N\\ :sub:`k` is a sequence of integers "
"whose length is determined by the *generation* of the process.  *args* is "
"the argument tuple for the target invocation.  *kwargs* is a dictionary of "
"keyword arguments for the target invocation.  By default, no arguments are "
"passed to *target*."
msgstr "ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯å¿…ãšã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã§å‘¼ã³å‡ºã™ã¹ãã§ã™ã€‚å¼•æ•° *group* ã«ã¯å¿…ãš ``None`` ã‚’æ¸¡ã—ã¦ãã ã•ã„ã€‚ã“ã®å¼•æ•°ã¯ :class:`threading.Thread` ã‚¯ãƒ©ã‚¹ã¨ã®äº’æ›æ€§ã®ãŸã‚ã ã‘ã«æ®‹ã•ã‚Œã¦ã„ã¾ã™ã€‚å¼•æ•° *target* ã«ã¯ã€å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (Callable Object) ã‚’æ¸¡ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :meth:`run()` ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®å¼•æ•°ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ ``None`` ã¨ãªã£ã¦ãŠã‚Šã€ä½•ã‚‚å‘¼ã³å‡ºã•ã‚Œã¾ã›ã‚“ã€‚å¼•æ•° *name* ã«ã¯ãƒ—ãƒ­ã‚»ã‚¹åã‚’æ¸¡ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€è‡ªå‹•ã§ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªåå‰ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚å‘½åè¦å‰‡ã¯ã€ 'Process-N\\ :sub:`1`:N\\ :sub:`2`:...:N\\ :sub:`k`' ã¨ãªã‚Šã¾ã™ã€‚ã“ã“ã§ N\\ :sub:`1`,N\\ :sub:`2`,...,N\\ :sub:`k` ã¯æ•´æ•°ã®æ•°åˆ—ã§ã€ *ä½œæˆã—ãŸ* ãƒ—ãƒ­ã‚»ã‚¹æ•°ã«å¯¾å¿œã—ã¾ã™ã€‚å¼•æ•° *args* ã¯ target ã§æŒ‡å®šã•ã‚ŒãŸå‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¼•æ•°ã‚’æ¸¡ã—ã¾ã™ã€‚åŒã˜ãã€å¼•æ•° *kwargs* ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’æ¸¡ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ *target* ã«ã¯å¼•æ•°ãŒæ¸¡ã•ã‚Œãªã„ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:360
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (:meth:`Process.__init__`) before doing anything else"
" to the process."
msgstr "ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹å ´åˆã¯ã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ã«å¯¾ã™ã‚‹å‡¦ç†ã‚’è¡Œã†å‰ã«åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ (:meth:`Process.__init__`) ã‚’å®Ÿè¡Œã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:366
msgid "Method representing the process's activity."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Ÿè¡Œã™ã‚‹å‡¦ç†ã‚’è¡¨ã™ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:368
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method"
" invokes the callable object passed to the object's constructor as the "
"target argument, if any, with sequential and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ¨™æº–ã® :meth:`run` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã® target å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚ŒãŸå‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ã‚‚ã—ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã« *args* ã‚‚ã—ãã¯ *kwargs* å¼•æ•°ãŒæ¸¡ã•ã‚Œã¦ã„ã‚Œã°ã€å‘¼ã³å‡ºã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã“ã‚Œã‚‰ã®å¼•æ•°ã‚’æ¸¡ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:375
msgid "Start the process's activity."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ã®å‡¦ç†ã‚’é–‹å§‹ã™ã‚‹ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:377
msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr "å„ Process ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒ2å›ä»¥ä¸Šå‘¼ã³å‡ºã•ã‚Œã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚å„ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`run` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™æº–å‚™ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:382
msgid ""
"Block the calling thread until the process whose :meth:`join` method is "
"called terminates or until the optional timeout occurs."
msgstr ":meth:`join` ã•ã‚ŒãŸãƒ—ãƒ­ã‚»ã‚¹ãŒ terminate ã‚’å‘¼ã³å‡ºã™ã¾ã§ã€ã‚‚ã—ãã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§æŒ‡å®šã—ãŸã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç™ºç”Ÿã™ã‚‹ã¾ã§å‘¼ã³å‡ºã—å´ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:385
msgid "If *timeout* is ``None`` then there is no timeout."
msgstr "*timeout* ãŒ ``None`` ãªã‚‰ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯è¨­å®šã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:387
msgid "A process can be joined many times."
msgstr "1ã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ä½•å›ã‚‚ join ã•ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:389
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ã¯è‡ªåˆ†è‡ªèº«ã‚’ join ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ãã‚Œã¯ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’å¼•ãèµ·ã“ã™ã“ã¨ãŒã‚ã‚‹ã‹ã‚‰ã§ã™ã€‚ãƒ—ãƒ­ã‚»ã‚¹ãŒ start ã•ã‚Œã‚‹å‰ã« join ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:394
msgid "The process's name."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹åã§ã™ã€‚"

#: ../../library/multiprocessing.rst:396
msgid ""
"The name is a string used for identification purposes only.  It has no "
"semantics.  Multiple processes may be given the same name.  The initial name"
" is set by the constructor."
msgstr "ã“ã®åå‰ã¯æ–‡å­—åˆ—ã§ã€ãƒ—ãƒ­ã‚»ã‚¹ã®è­˜åˆ¥ã«ã®ã¿ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ç‰¹åˆ¥ãªå‘½åè¦å‰‡ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒåŒã˜åå‰ã‚’æŒã¤å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚ã¾ãŸã€ã“ã®åå‰ã¯ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã‚ŠåˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:402
msgid "Return whether the process is alive."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Ÿè¡Œä¸­ã‹ã‚’åˆ¤åˆ¥ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:404
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr "ãŠãŠã¾ã‹ã«è¨€ã£ã¦ã€ãƒ—ãƒ­ã‚»ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :meth:`start` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ã‹ã‚‰å­ãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†ã¾ã§ã®æœŸé–“ãŒå®Ÿè¡Œä¸­ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:409
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before "
":meth:`start` is called."
msgstr "ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚ã‚‹ã‹ã®ãƒ•ãƒ©ã‚°ã§ã‚ã‚Šã€ãƒ–ãƒ¼ãƒ«å€¤ã§ã™ã€‚ã“ã®å±æ€§ã¯ :meth:`start` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹å‰ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:412
msgid "The initial value is inherited from the creating process."
msgstr "åˆæœŸå€¤ã¯ä½œæˆã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ç¶™æ‰¿ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:414
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr "ã‚ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã™ã‚‹ã¨ãã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ãã®å­ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚ã‚‹ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã™ã¹ã¦ã‚’çµ‚äº†ã•ã›ã‚ˆã†ã¨ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:417
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr "ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã¯å­ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œæˆã§ããªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã‚‚ã—ä½œæˆã§ãã¦ã—ã¾ã†ã¨ã€ãã®ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã®è¦ªãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã—ãŸã¨ãã«ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã®å­ãƒ—ãƒ­ã‚»ã‚¹ãŒå­¤å…ã«ãªã£ã¦ã—ã¾ã†å ´åˆãŒã‚ã‚‹ã‹ã‚‰ã§ã™ã€‚ã•ã‚‰ã«è¨€ãˆã°ã€ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã¯Unix ãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚„ã‚µãƒ¼ãƒ“ã‚¹ã§ã¯ **ãªã** é€šå¸¸ã®ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚ã‚Šã€éãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã™ã‚‹ã¨çµ‚äº†ã•ã‚Œã¾ã™ (ãã—ã¦ join ã•ã‚Œã¾ã›ã‚“)ã€‚"

#: ../../library/multiprocessing.rst:423
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr ":class:`threading.Thread` ã‚¯ãƒ©ã‚¹ã® API ã«åŠ ãˆã¦ :class:`Process` ã‚¯ãƒ©ã‚¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ä»¥ä¸‹ã®å±æ€§ãŠã‚ˆã³ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™:"

#: ../../library/multiprocessing.rst:428
msgid ""
"Return the process ID.  Before the process is spawned, this will be "
"``None``."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹IDã‚’è¿”ã—ã¾ã™ã€‚ãƒ—ãƒ­ã‚»ã‚¹ã®ç”Ÿæˆå‰ã¯ ``None`` ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:433
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated.  A negative value *-N* indicates that the child was terminated "
"by signal *N*."
msgstr "å­ãƒ—ãƒ­ã‚»ã‚¹ã®çµ‚äº†ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚å­ãƒ—ãƒ­ã‚»ã‚¹ãŒã¾ã çµ‚äº†ã—ã¦ã„ãªã„å ´åˆã¯ ``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚è² ã®å€¤ *-N* ã¯å­ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚·ã‚°ãƒŠãƒ« *N* ã§çµ‚äº†ã—ãŸã“ã¨ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:439
msgid "The process's authentication key (a byte string)."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ã®èªè¨¼ã‚­ãƒ¼ã§ã™ (ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã§ã™)ã€‚"

#: ../../library/multiprocessing.rst:441
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr ":mod:`multiprocessing` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚ˆã‚ŠåˆæœŸåŒ–ã•ã‚Œã‚‹å ´åˆã«ã¯ã€ :func:`os.urandom` é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ãƒ©ãƒ³ãƒ€ãƒ ãªå€¤ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:444
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ":class:`Process` ã‚¯ãƒ©ã‚¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆæ™‚ã«ãã®è¦ªãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰èªè¨¼ã‚­ãƒ¼ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚ã‚‚ã—ãã¯ :attr:`authkey` ã«åˆ¥ã®ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:448
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "è©³ç´°ã¯ :ref:`multiprocessing-auth-keys` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:452
msgid ""
"Terminate the process.  On Unix this is done using the ``SIGTERM`` signal; "
"on Windows :c:func:`TerminateProcess` is used.  Note that exit handlers and "
"finally clauses, etc., will not be executed."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ã‚’çµ‚äº†ã—ã¾ã™ã€‚Unix ç’°å¢ƒã§ã¯ ``SIGTERM`` ã‚·ã‚°ãƒŠãƒ«ã‚’ã€ Windows ç’°å¢ƒã§ã¯ :c:func:`TerminateProcess` ã‚’ä½¿ç”¨ã—ã¦çµ‚äº†ã•ã›ã¾ã™ã€‚çµ‚äº†ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚„ finally ç¯€ãªã©ã¯ã€å®Ÿè¡Œã•ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:456
msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã‚Šçµ‚äº†ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã®å­å­«ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€çµ‚äº† *ã—ã¾ã›ã‚“* ã€‚ãã†ã„ã£ãŸå­å­«ãƒ—ãƒ­ã‚»ã‚¹ã¯å˜ç´”ã«å­¤å…ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:461
msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable"
" by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ä½¿ç”¨æ™‚ã«ã€é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ‘ã‚¤ãƒ—ã‚„ã‚­ãƒ¥ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã«ã¯ã€ä½¿ç”¨ä¸­ã®ãƒ‘ã‚¤ãƒ—ã‚„ã‚­ãƒ¥ãƒ¼ãŒç ´æã—ã¦ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ä½¿ç”¨ã§ããªããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚åŒæ§˜ã«ã€ãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ­ãƒƒã‚¯ã‚„ã‚»ãƒãƒ•ã‚©ãªã©ã‚’å–å¾—ã—ã¦ã„ã‚‹å ´åˆã«ã¯ã€ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã—ã¦ã—ã¾ã†ã¨ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã®åŸå› ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/multiprocessing.rst:467
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, "
":meth:`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã®ã¿ãŒ :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:`terminate` ã¨ :attr:`exitcode` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:471
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr "ä»¥ä¸‹ã®ä¾‹ã§ã¯ :class:`Process` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ä½¿ã„æ–¹ã‚’ç¤ºã—ã¦ã„ã¾ã™:"

#: ../../library/multiprocessing.rst:492
#: ../../library/multiprocessing.rst:2065
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into()` when the supplied "
"buffer object is too small for the message read."
msgstr "ã“ã®ä¾‹å¤–ã¯ :meth:`Connection.recv_bytes_into()` ã«ã‚ˆã£ã¦ç™ºç”Ÿã—ã€ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå°ã•ã™ãã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã‚ãªã„ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:495
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr "``e`` ãŒ :exc:`BufferTooShort` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã™ã‚‹ã¨ã€ ``e.args[0]`` ã¯ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã§ãã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—ã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:500
msgid "Pipes and Queues"
msgstr "ãƒ‘ã‚¤ãƒ— (Pipe) ã¨ã‚­ãƒ¥ãƒ¼ (Queue)"

#: ../../library/multiprocessing.rst:502
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization"
" primitives like locks."
msgstr "è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½¿ã†å ´åˆã€ä¸€èˆ¬çš„ã«ã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ‘ãƒƒã‚·ãƒ³ã‚°ã‚’ãƒ—ãƒ­ã‚»ã‚¹é–“é€šä¿¡ã«ä½¿ç”¨ã—ã€ãƒ­ãƒƒã‚¯ã®ã‚ˆã†ãªåŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’ä½¿ç”¨ã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:506
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚„ã‚Šã¨ã‚Šã®ãŸã‚ã« :func:`Pipe` (2ã¤ã®ãƒ—ãƒ­ã‚»ã‚¹é–“ã®é€šä¿¡ç”¨)ã€ã‚‚ã—ãã¯ã‚­ãƒ¥ãƒ¼ (è¤‡æ•°ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆãƒ—ãƒ­ã‚»ã‚¹ (producer)ã€æ¶ˆè²»ãƒ—ãƒ­ã‚»ã‚¹ (consumer) ã®å®Ÿç¾ç”¨) ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:509
msgid ""
"The :class:`~multiprocessing.Queue`, "
":class:`multiprocessing.queues.SimpleQueue` and :class:`JoinableQueue` types"
" are multi-producer, multi-consumer FIFO queues modelled on the "
":class:`Queue.Queue` class in the standard library.  They differ in that "
":class:`~multiprocessing.Queue` lacks the :meth:`~Queue.Queue.task_done` and"
" :meth:`~Queue.Queue.join` methods introduced into Python 2.5's "
":class:`Queue.Queue` class."
msgstr ":class:`~multiprocessing.Queue`, :class:`multiprocessing.queues.SimpleQueue`, :class:`JoinableQueue` ã¯è¤‡æ•°ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ç”Ÿæˆ/æ¶ˆè²»ã‚’è¡Œã† FIFO ã‚­ãƒ¥ãƒ¼ã§ã™ã€‚ã“ã‚Œã‚‰ã®ã‚­ãƒ¥ãƒ¼ã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® :class:`Queue.Queue` ã‚’æ¨¡å€£ã—ã¦ã„ã¾ã™ã€‚ :class:`~multiprocessing.Queue` ã«ã¯ Python 2.5 ã® :class:`Queue.Queue` ã‚¯ãƒ©ã‚¹ã§å°å…¥ã•ã‚ŒãŸ :meth:`~Queue.Queue.task_done` ã¨ :meth:`~Queue.Queue.join` ãƒ¡ã‚½ãƒƒãƒ‰ãŒãªã„ã“ã¨ãŒé•ã†ç‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:515
msgid ""
"If you use :class:`JoinableQueue` then you **must** call "
":meth:`JoinableQueue.task_done` for each task removed from the queue or else"
" the semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr "ã‚‚ã— :class:`JoinableQueue` ã‚’ä½¿ç”¨ã™ã‚‹ãªã‚‰ã€ã‚­ãƒ¥ãƒ¼ã‹ã‚‰å‰Šé™¤ã•ã‚Œã‚‹å„ã‚¿ã‚¹ã‚¯ã®ãŸã‚ã« :meth:`JoinableQueue.task_done` ã‚’å‘¼ã³å‡ºã•ãªã‘ã‚Œã° **ãªã‚Šã¾ã›ã‚“** ã€‚ã•ã‚‚ãªã„ã¨ã€ã„ã¤ã‹å®Œäº†ã—ã¦ã„ãªã„ã‚¿ã‚¹ã‚¯ã‚’æ•°ãˆã‚‹ãŸã‚ã®ã‚»ãƒãƒ•ã‚©ãŒã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã—ã€ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/multiprocessing.rst:520
msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr "ç®¡ç†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§å…±æœ‰ã‚­ãƒ¥ãƒ¼ã‚’ä½œæˆã§ãã‚‹ã“ã¨ã‚‚è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚è©³ç´°ã¯ :ref:`multiprocessing-managers` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:525
msgid ""
":mod:`multiprocessing` uses the usual :exc:`Queue.Empty` and "
":exc:`Queue.Full` exceptions to signal a timeout.  They are not available in"
" the :mod:`multiprocessing` namespace so you need to import them from "
":mod:`Queue`."
msgstr ":mod:`multiprocessing` ã¯é€šå¸¸ã® :exc:`Queue.Empty` ã¨ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®ã‚·ã‚°ãƒŠãƒ«ã‚’é€ã‚‹ãŸã‚ã« :exc:`Queue.Full` ä¾‹å¤–ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ãã‚Œã‚‰ã¯ :mod:`Queue` ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§ :mod:`multiprocessing` ã®åå‰ç©ºé–“ã§ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:532
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use"
" a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚Œã‚‹éš›ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ pickle åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚ãã®ãŸã‚ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒå¾Œã«ãªã£ã¦ä¸‹ä½å±¤ã®ãƒ‘ã‚¤ãƒ—ã« pickle åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å°‘ã—é©šãã‚ˆã†ãªçµæœã«ãªã‚Šã¾ã™ãŒã€å®Ÿéš›ã«å•é¡Œã«ãªã‚‹ã“ã¨ã¯ãªã„ã¯ãšã§ã™ã€‚ã“ã‚ŒãŒå•é¡Œã«ãªã‚‹ã‚ˆã†ãªçŠ¶æ³ã§ã¯ã€ã‹ã‚ã‚Šã« :ref:`manager <multiprocessing-managers>` ã‚’ä½¿ã£ã¦ã‚­ãƒ¥ãƒ¼ã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:539
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`Queue.Empty`."
msgstr "ç©ºã®ã‚­ãƒ¥ãƒ¼ã®ä¸­ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿½åŠ ã—ãŸå¾Œã€ã‚­ãƒ¥ãƒ¼ã® :meth:`~Queue.empty` ãƒ¡ã‚½ãƒƒãƒ‰ãŒ :const:`False` ã‚’è¿”ã™ã¾ã§ã®é–“ã«ã”ãã‚ãšã‹ãªé…å»¶ãŒèµ·ãã‚‹ã“ã¨ãŒã‚ã‚Šã€:meth:`~Queue.get_nowait` ãŒ :exc:`Queue.Empty` ã‚’ç™ºç”Ÿã•ã›ã‚‹ã“ã¨ãªãåˆ¶å¾¡ãŒå‘¼ã³å‡ºã—å…ƒã«è¿”ã£ã¦ã—ã¾ã†ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:544
msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr "è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚­ãƒ¥ãƒ¼ã«è©°ã‚ã¦ã„ã‚‹å ´åˆã€ã‚­ãƒ¥ãƒ¼ã®åå¯¾å´ã§ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè©°ã‚ã‚‰ã‚ŒãŸã®ã¨ã¯é•ã†é †åºã§å–å¾—ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ãŸã ã—ã€åŒä¸€ã®ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰è©°ã‚è¾¼ã¾ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé–“ã§ã¯ã€å¿…ãšæœŸå¾…ã©ãŠã‚Šã®é †åºã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:551
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`~multiprocessing.Queue`, then the data "
"in the queue is likely to become corrupted.  This may cause any other "
"process to get an exception when it tries to use the queue later on."
msgstr ":class:`~multiprocessing.Queue` ã‚’åˆ©ç”¨ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹æœ€ä¸­ã«ãƒ—ãƒ­ã‚»ã‚¹ã‚’ :meth:`Process.terminate` ã‚„ :func:`os.kill` ã§çµ‚äº†ã•ã›ã‚‹å ´åˆã€ã‚­ãƒ¥ãƒ¼ã«ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ã¯ç ´æã—æ˜“ããªã‚Šã¾ã™ã€‚çµ‚äº†ã—ãŸå¾Œã§ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚­ãƒ¥ãƒ¼ã‚’åˆ©ç”¨ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:558
msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>`), then that process will not "
"terminate until all buffered items have been flushed to the pipe."
msgstr "ä¸Šè¿°ã—ãŸã‚ˆã†ã«ã€ã‚‚ã—å­ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚­ãƒ¥ãƒ¼ã¸è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ãªã‚‰ (ã‹ã¤ :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` ã‚’ä½¿ç”¨ã—ãªã„ãªã‚‰) ãã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ãƒãƒƒãƒ•ã‚¡ãƒ¼ã•ã‚ŒãŸã™ã¹ã¦ã®è¦ç´ ãŒãƒ‘ã‚¤ãƒ—ã¸ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã•ã‚Œã‚‹ã¾ã§çµ‚äº†ã—ã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:563
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr "ã“ã‚Œã¯ã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ join ã—ã‚ˆã†ã¨ã™ã‚‹å ´åˆã€ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚ŒãŸã™ã¹ã¦ã®è¦ç´ ãŒæ¶ˆè²»ã•ã‚ŒãŸã“ã¨ãŒç¢ºå®Ÿã§ãªã„ã‹ãã‚Šã€ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’ç™ºç”Ÿã•ã›ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ä¼¼ãŸã‚ˆã†ãªç¾è±¡ã§ã€å­ãƒ—ãƒ­ã‚»ã‚¹ãŒéãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã®å ´åˆã€è¦ªãƒ—ãƒ­ã‚»ã‚¹ã¯çµ‚äº†æ™‚ã«éãƒ‡ãƒ¼ãƒ¢ãƒ³ã®ã™ã¹ã¦ã®å­ãƒ—ãƒ­ã‚»ã‚¹ã‚’ join ã—ã‚ˆã†ã¨ã—ã¦ãƒãƒ³ã‚°ã‚¢ãƒƒãƒ—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:568
msgid ""
"Note that a queue created using a manager does not have this issue.  See "
":ref:`multiprocessing-programming`."
msgstr "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ä½œæˆã•ã‚ŒãŸã‚­ãƒ¥ãƒ¼ã§ã¯ã“ã®å•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è©³ç´°ã¯ :ref:`multiprocessing-programming` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:571
msgid ""
"For an example of the usage of queues for interprocess communication see "
":ref:`multiprocessing-examples`."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹é–“é€šä¿¡ã«ãŠã‘ã‚‹ã‚­ãƒ¥ãƒ¼ã®ä½¿ç”¨ä¾‹ã‚’çŸ¥ã‚ŠãŸã„ãªã‚‰ :ref:`multiprocessing-examples` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:577
msgid ""
"Returns a pair ``(conn1, conn2)`` of :class:`Connection` objects "
"representing the ends of a pipe."
msgstr "ãƒ‘ã‚¤ãƒ—ã®ä¸¡ç«¯ã‚’è¡¨ã™ :class:`Connection` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒšã‚¢ ``(conn1, conn2)`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:580
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be"
" used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr "*duplex* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ãƒ‘ã‚¤ãƒ—ã¯åŒæ–¹å‘æ€§ã§ã™ã€‚*duplex* ãŒ ``False`` ãªã‚‰ãƒ‘ã‚¤ãƒ—ã¯ä¸€æ–¹å‘æ€§ã§ã€``conn1`` ã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å—ä¿¡å°‚ç”¨ã€``conn2`` ã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡å°‚ç”¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:588
msgid ""
"Returns a process shared queue implemented using a pipe and a few "
"locks/semaphores.  When a process first puts an item on the queue a feeder "
"thread is started which transfers objects from a buffer into the pipe."
msgstr "ãƒ‘ã‚¤ãƒ—ã‚„2ï½3å€‹ã®ãƒ­ãƒƒã‚¯/ã‚»ãƒãƒ•ã‚©ã‚’ä½¿ç”¨ã—ã¦å®Ÿè£…ã•ã‚ŒãŸãƒ—ãƒ­ã‚»ã‚¹å…±æœ‰ã‚­ãƒ¥ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ã‚ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ãŒæœ€åˆã«è¦ç´ ã‚’ã‚­ãƒ¥ãƒ¼ã¸è¿½åŠ ã™ã‚‹ã¨ãã€ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‹ã‚‰ãƒ‘ã‚¤ãƒ—ã®ä¸­ã¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è»¢é€ã™ã‚‹ä¾›çµ¦ã‚¹ãƒ¬ãƒƒãƒ‰ãŒé–‹å§‹ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:592
msgid ""
"The usual :exc:`Queue.Empty` and :exc:`Queue.Full` exceptions from the "
"standard library's :mod:`Queue` module are raised to signal timeouts."
msgstr "æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® :mod:`Queue` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ã®é€šå¸¸ã® :exc:`Queue.Empty` ã‚„ :exc:`Queue.Full` ä¾‹å¤–ã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®ã‚·ã‚°ãƒŠãƒ«ã‚’é€ã‚‹ãŸã‚ã«ç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:595
msgid ""
":class:`~multiprocessing.Queue` implements all the methods of "
":class:`Queue.Queue` except for :meth:`~Queue.Queue.task_done` and "
":meth:`~Queue.Queue.join`."
msgstr ":class:`~multiprocessing.Queue` ã¯ :meth:`~Queue.Queue.task_done` ã‚„ :meth:`~Queue.Queue.join` ã‚’é™¤ã :class:`Queue.Queue` ã®å…¨ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:600
msgid ""
"Return the approximate size of the queue.  Because of "
"multithreading/multiprocessing semantics, this number is not reliable."
msgstr "ãŠãŠã‚ˆãã®ã‚­ãƒ¥ãƒ¼ã®ã‚µã‚¤ã‚ºã‚’è¿”ã—ã¾ã™ã€‚ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‡ã‚£ãƒ³ã‚°/ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚¹ã®ç‰¹æ€§ä¸Šã€ã“ã®æ•°å€¤ã¯ä¿¡ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:603
msgid ""
"Note that this may raise :exc:`NotImplementedError` on Unix platforms like "
"Mac OS X where ``sem_getvalue()`` is not implemented."
msgstr "ã“ã‚Œã¯ ``sem_getvalue()`` ãŒå®Ÿè£…ã•ã‚Œã¦ã„ãªã„ Mac OS X ã®ã‚ˆã†ãª Unix ãƒ—ãƒ©ãƒƒãƒˆãƒ›ãƒ¼ãƒ ä¸Šã§ :exc:`NotImplementedError` ã‚’ç™ºç”Ÿã•ã›ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:608
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr "ã‚­ãƒ¥ãƒ¼ãŒç©ºã£ã½ãªã‚‰ ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™ã€‚ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‡ã‚£ãƒ³ã‚°/ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚·ãƒ³ã‚°ã®ç‰¹æ€§ä¸Šã€ã“ã‚Œã¯ä¿¡ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:613
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr "ã‚­ãƒ¥ãƒ¼ãŒã„ã£ã±ã„ãªã‚‰ ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™ã€‚ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‡ã‚£ãƒ³ã‚°/ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚·ãƒ³ã‚°ã®ç‰¹æ€§ä¸Šã€ã“ã‚Œã¯ä¿¡ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:618
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a"
" free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`Queue.Full` exception if no free"
" slot was available within that time.  Otherwise (*block* is ``False``), put"
" an item on the queue if a free slot is immediately available, else raise "
"the :exc:`Queue.Full` exception (*timeout* is ignored in that case)."
msgstr "ã‚­ãƒ¥ãƒ¼ã®ä¸­ã¸è¦ç´ ã‚’è¿½åŠ ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *block* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ä¸”ã¤ *timeout* ãŒ ``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã€ç©ºãã‚¹ãƒ­ãƒƒãƒˆãŒåˆ©ç”¨å¯èƒ½ã«ãªã‚‹ã¾ã§å¿…è¦ã§ã‚ã‚Œã°ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ *timeout* ãŒæ­£ã®æ•°ãªã‚‰ã€æœ€å¤§ *timeout* ç§’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã€ãã®æ™‚é–“å†…ã«ç©ºãã‚¹ãƒ­ãƒƒãƒˆãŒåˆ©ç”¨ã§ããªã‹ã£ãŸã‚‰ :exc:`Queue.Full` ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚ãã‚Œä»¥å¤– ( *block* ãŒ ``False`` ) ã§ã€ç©ºãã‚¹ãƒ­ãƒƒãƒˆãŒã™ãã«åˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ã‚­ãƒ¥ãƒ¼ã«è¦ç´ ã‚’è¿½åŠ ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° :exc:`Queue.Full` ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™(ãã®å ´åˆ *timeout* ã¯ç„¡è¦–ã•ã‚Œã¾ã™)ã€‚"

#: ../../library/multiprocessing.rst:629
msgid "Equivalent to ``put(obj, False)``."
msgstr "``put(obj, False)`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:633
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it"
" blocks at most *timeout* seconds and raises the :exc:`Queue.Empty` "
"exception if no item was available within that time.  Otherwise (block is "
"``False``), return an item if one is immediately available, else raise the "
":exc:`Queue.Empty` exception (*timeout* is ignored in that case)."
msgstr "ã‚­ãƒ¥ãƒ¼ã‹ã‚‰è¦ç´ ã‚’å–ã‚Šå‡ºã—ã¦å‰Šé™¤ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *block* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ä¸”ã¤ *timeout* ãŒ ``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã€è¦ç´ ãŒå–ã‚Šå‡ºã›ã‚‹ã¾ã§å¿…è¦ã§ã‚ã‚Œã°ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ *timeout* ãŒæ­£ã®æ•°ãªã‚‰ã€æœ€å¤§ *timeout* ç§’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã€ãã®æ™‚é–“å†…ã«è¦ç´ ãŒå–ã‚Šå‡ºã›ãªã‹ã£ãŸã‚‰ :exc:`Queue.Empty` ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚ãã‚Œä»¥å¤– ( *block* ãŒ ``False`` ) ã§ã€è¦ç´ ãŒã™ãã«å–ã‚Šå‡ºã›ã‚‹å ´åˆã¯è¦ç´ ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° :exc:`Queue.Empty` ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™(ãã®å ´åˆ *timeout* ã¯ç„¡è¦–ã•ã‚Œã¾ã™)ã€‚"

#: ../../library/multiprocessing.rst:643
msgid "Equivalent to ``get(False)``."
msgstr "``get(False)`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:645
msgid ""
":class:`~multiprocessing.Queue` has a few additional methods not found in "
":class:`Queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ":class:`~multiprocessing.Queue` ã¯ :class:`Queue.Queue` ã«ã¯ãªã„è¿½åŠ ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯é€šå¸¸ã€ã»ã¨ã‚“ã©ã®ã‚³ãƒ¼ãƒ‰ã«å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:651
msgid ""
"Indicate that no more data will be put on this queue by the current process."
"  The background thread will quit once it has flushed all buffered data to "
"the pipe.  This is called automatically when the queue is garbage collected."
msgstr "ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ã“ã®ã‚­ãƒ¥ãƒ¼ã¸ãã‚Œä»¥ä¸Šãƒ‡ãƒ¼ã‚¿ãŒè¿½åŠ ã•ã‚Œãªã„ã“ã¨ã‚’è¡¨ã—ã¾ã™ã€‚ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãƒ‘ã‚¤ãƒ—ã¸ãƒãƒƒãƒ•ã‚¡ãƒ¼ã•ã‚ŒãŸã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹ã¨ã™ãã«çµ‚äº†ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚­ãƒ¥ãƒ¼ãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹ã¨ãã«è‡ªå‹•çš„ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:658
msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all"
" data in the buffer has been flushed to the pipe."
msgstr "ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ join ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :meth:`close` ãŒå‘¼ã³å‡ºã•ã‚ŒãŸå¾Œã§ã®ã¿ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ãƒ¼ã•ã‚ŒãŸã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ãŒãƒ‘ã‚¤ãƒ—ã¸ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã•ã‚Œã‚‹ã®ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:662
msgid ""
"By default if a process is not the creator of the queue then on exit it will"
" attempt to join the queue's background thread.  The process can call "
":meth:`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã‚ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚­ãƒ¥ãƒ¼ã‚’ä½œæˆã—ã¦ã„ãªã„å ´åˆã€çµ‚äº†æ™‚ã«ã‚­ãƒ¥ãƒ¼ã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ join ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚ãã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ :meth:`join_thread` ãŒä½•ã‚‚ã—ãªã„ã‚ˆã†ã« :meth:`cancel_join_thread` ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:668
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the"
" background thread from being joined automatically when the process exits --"
" see :meth:`join_thread`."
msgstr ":meth:`join_thread` ãŒãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã™ã‚‹ã®ã‚’é˜²ãã¾ã™ã€‚ç‰¹ã«ã“ã‚Œã¯ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãã®ãƒ—ãƒ­ã‚»ã‚¹ã®çµ‚äº†æ™‚ã«è‡ªå‹•çš„ã« join ã•ã‚Œã‚‹ã®ã‚’é˜²ãã¾ã™ã€‚è©³ç´°ã¯ :meth:`join_thread` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:672
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to lost, and you almost certainly will not "
"need to use it. It is really only there if you need the current process to "
"exit immediately without waiting to flush enqueued data to the underlying "
"pipe, and you don't care about lost data."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ ``allow_exit_without_flush()`` ã¨ã„ã†åå‰ã®ã»ã†ãŒã‚ˆã‹ã£ãŸã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒå¤±ã‚ã‚Œã¦ã—ã¾ã„ãŒã¡ãªãŸã‚ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†å¿…è¦ã¯ã»ã¼ç¢ºå®Ÿã«ãªã„ã§ã—ã‚‡ã†ã€‚æœ¬å½“ã«ã“ã‚ŒãŒå¿…è¦ã«ãªã‚‹ã®ã¯ã€ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’ä¸‹ä½å±¤ã®ãƒ‘ã‚¤ãƒ—ã«ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹ã“ã¨ãªãã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‚’ç›´ã¡ã«çµ‚äº†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€ã‹ã¤å¤±ã‚ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã«é–¢å¿ƒãŒãªã„å ´åˆã§ã™ã€‚"

#: ../../library/multiprocessing.rst:681
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue`"
" will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã«å«ã¾ã‚Œã‚‹æ©Ÿèƒ½ã«ã¯ã€ãƒ›ã‚¹ãƒˆã¨ãªã‚‹ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ä¸Šã§å‹•ä½œã—ã¦ã„ã‚‹å…±æœ‰ã‚»ãƒãƒ•ã‚© (shared semaphore) ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚ŒãŒä½¿ç”¨ã§ããªã„å ´åˆã«ã¯ã€ã“ã®ã‚¯ãƒ©ã‚¹ãŒç„¡åŠ¹ã«ãªã‚Šã€ :class:`Queue` ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹æ™‚ã« :exc:`ImportError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚è©³ç´°ã¯ :issue:`3770` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚åŒæ§˜ã®ã“ã¨ãŒã€ä»¥ä¸‹ã«åˆ—æŒ™ã•ã‚Œã¦ã„ã‚‹ç‰¹æ®Šãªã‚­ãƒ¥ãƒ¼ã§ã‚‚æˆã‚Šç«‹ã¡ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:691
msgid ""
"It is a simplified :class:`~multiprocessing.Queue` type, very close to a "
"locked :class:`Pipe`."
msgstr "å˜ç´”åŒ–ã•ã‚ŒãŸ :class:`~multiprocessing.Queue` å‹ã§ã™ã€‚ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸ :class:`Pipe` ã«éå¸¸ã«ä¼¼ã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:695
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "ã‚‚ã—ã‚­ãƒ¥ãƒ¼ãŒç©ºãªã‚‰ã° ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:699
msgid "Remove and return an item from the queue."
msgstr "ã‚­ãƒ¥ãƒ¼ã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–ã‚Šé™¤ã„ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:703
msgid "Put *item* into the queue."
msgstr "*item* ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:708
msgid ""
":class:`JoinableQueue`, a :class:`~multiprocessing.Queue` subclass, is a "
"queue which additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ":class:`JoinableQueue` ã¯ :class:`~multiprocessing.Queue` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€ :meth:`task_done` ã‚„ :meth:`join` ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿½åŠ ã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¥ãƒ¼ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:713
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue consumer "
"threads.  For each :meth:`~Queue.get` used to fetch a task, a subsequent "
"call to :meth:`task_done` tells the queue that the processing on the task is"
" complete."
msgstr "ä»¥å‰ã«ã‚­ãƒ¥ãƒ¼ã¸è¿½åŠ ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ãŒå®Œäº†ã—ãŸã“ã¨ã‚’è¡¨ã—ã¾ã™ã€‚ã‚­ãƒ¥ãƒ¼æ¶ˆè²»ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚ˆã£ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã‚¿ã‚¹ã‚¯ã‚’ãƒ•ã‚§ãƒƒãƒã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ãã‚Œãã‚Œã® :meth:`~Queue.get` ã§ã¯ã€æ¬¡ã« :meth:`task_done` ã‚’å‘¼ã³å‡ºã—ã¦ã‚¿ã‚¹ã‚¯ã®å‡¦ç†ãŒå®Œäº†ã—ãŸã“ã¨ã‚’ã‚­ãƒ¥ãƒ¼ã¸ä¼ãˆã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:718
msgid ""
"If a :meth:`~Queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr "ã‚‚ã— :meth:`~Queue.Queue.join` ãŒãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°çŠ¶æ…‹ãªã‚‰ã€å…¨ã¦ã®è¦ç´ ãŒå‡¦ç†ã•ã‚ŒãŸã¨ãã«å¾©å¸°ã—ã¾ã™( :meth:`task_done` å‘¼ã³å‡ºã—ãŒå…¨ã¦ã®è¦ç´ ã‹ã‚‰ã‚­ãƒ¥ãƒ¼å†…ã¸ :meth:`~Queue.put` ã•ã‚ŒãŸã¨å—ã‘å–ã£ãŸã“ã¨ã‚’æ„å‘³ã—ã¾ã™)ã€‚"

#: ../../library/multiprocessing.rst:722
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed"
" in the queue."
msgstr "ã‚­ãƒ¥ãƒ¼ã«ã‚ã‚‹è¦ç´ ã‚ˆã‚Šå¤šãå‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆ :exc:`ValueError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:728
msgid "Block until all items in the queue have been gotten and processed."
msgstr "ã‚­ãƒ¥ãƒ¼ã«ã‚ã‚‹ã™ã¹ã¦ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒå–ã‚Šå‡ºã•ã‚Œã¦å‡¦ç†ã•ã‚Œã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:730
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer thread calls "
":meth:`task_done` to indicate that the item was retrieved and all work on it"
" is complete.  When the count of unfinished tasks drops to zero, "
":meth:`~Queue.Queue.join` unblocks."
msgstr "ã‚­ãƒ¥ãƒ¼ã«è¦ç´ ãŒè¿½åŠ ã•ã‚Œã‚‹ã¨æœªçµ‚äº†ã‚¿ã‚¹ã‚¯æ•°ãŒå¢—ãˆã¾ã™ã€‚ã‚­ãƒ¥ãƒ¼ã®è¦ç´ ãŒå–ã‚Šå‡ºã•ã‚Œã¦å…¨ã¦å‡¦ç†ãŒå®Œäº†ã—ãŸã“ã¨ã‚’è¡¨ã™ :meth:`task_done` ã‚’æ¶ˆè²»ã‚¹ãƒ¬ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã™ã¨æ•°ãŒæ¸›ã‚Šã¾ã™ã€‚æœªçµ‚äº†ã‚¿ã‚¹ã‚¯æ•°ãŒã‚¼ãƒ­ã«ãªã‚‹ã¨ :meth:`~Queue.Queue.join` ã¯ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚’è§£é™¤ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:738
msgid "Miscellaneous"
msgstr "ãã®ä»–ã®é–¢æ•°"

#: ../../library/multiprocessing.rst:742
msgid "Return list of all live children of the current process."
msgstr "ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå­ãƒ—ãƒ­ã‚»ã‚¹ã®ã™ã¹ã¦ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:744
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr "ã“ã‚Œã‚’å‘¼ã³å‡ºã™ã¨ \"join\" ã—ã¦ã™ã§ã«çµ‚äº†ã—ã¦ã„ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã«ã¯å‰¯ä½œç”¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:749
msgid ""
"Return the number of CPUs in the system.  May raise "
":exc:`NotImplementedError`."
msgstr "ã‚·ã‚¹ãƒ†ãƒ ã® CPU æ•°ã‚’è¿”ã—ã¾ã™ã€‚ :exc:`NotImplementedError` ãŒé€å‡ºã•ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:754
msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr "ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã«å¯¾å¿œã™ã‚‹ :class:`Process` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:756
msgid "An analogue of :func:`threading.current_thread`."
msgstr ":func:`threading.current_thread` ã¨ã‚ˆãä¼¼ãŸé–¢æ•°ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:760
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce a Windows executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ":mod:`multiprocessing` ã‚’ä½¿ç”¨ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒ Windows ã®å®Ÿè¡Œå¯èƒ½å½¢å¼ã‚’ç”Ÿæˆã—ã‚ˆã†ã¨ã—ã¦å›ºã¾ã£ãŸã¨ãã®ã‚µãƒãƒ¼ãƒˆã‚’è¿½åŠ ã—ã¾ã™ã€‚(**py2exe** , **PyInstaller** ã‚„ **cx_Freeze** ã§ãƒ†ã‚¹ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚)"

#: ../../library/multiprocessing.rst:764
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr "ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``if __name__ == '__main__'`` ã®ç›´å¾Œã«ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../library/multiprocessing.rst:776
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr "ã‚‚ã— ``freeze_support()`` ã®è¡ŒãŒãªã„å ´åˆã€å›ºã¾ã£ãŸå®Ÿè¡Œå¯èƒ½å½¢å¼ã‚’å®Ÿè¡Œã—ã‚ˆã†ã¨ã™ã‚‹ã¨ :exc:`RuntimeError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:779
msgid ""
"Calling ``freeze_support()`` has no effect when invoked on any operating "
"system other than Windows.  In addition, if the module is being run normally"
" by the Python interpreter on Windows (the program has not been frozen), "
"then ``freeze_support()`` has no effect."
msgstr "``freeze_support()`` ã®å‘¼ã³å‡ºã—ã¯ Windows ä»¥å¤–ã® OS ã§ã¯åŠ¹æœãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã•ã‚‰ã«ã€ã‚‚ã—ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ Windows ã®é€šå¸¸ã® Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã£ã¦å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ãªã‚‰ã°ï¼ˆãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒãƒ•ãƒªãƒ¼ã‚ºã•ã‚Œã¦ã„ãªã‘ã‚Œã°ï¼‰ ``freeze_support()`` ã¯åŠ¹æœãŒã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:786
msgid ""
"Sets the path of the Python interpreter to use when starting a child "
"process. (By default :data:`sys.executable` is used).  Embedders will "
"probably need to do some thing like ::"
msgstr "å­ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã™ã‚‹ã¨ãã«ã€ä½¿ç”¨ã™ã‚‹ Python ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã®ãƒ‘ã‚¹ã‚’è¨­å®šã—ã¾ã™ã€‚(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ :data:`sys.executable` ãŒä½¿ç”¨ã•ã‚Œã¾ã™)ã€‚ã‚³ãƒ¼ãƒ‰ã«çµ„ã¿è¾¼ã‚€ã¨ãã¯ã€ãŠãã‚‰ãæ¬¡ã®ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ ::"

#: ../../library/multiprocessing.rst:792
msgid "before they can create child processes.  (Windows only)"
msgstr "å­ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç”Ÿæˆã™ã‚‹å‰ã«è¡Œãªã£ã¦ãã ã•ã„ã€‚ (Windows only)"

#: ../../library/multiprocessing.rst:797
msgid ""
":mod:`multiprocessing` contains no analogues of "
":func:`threading.active_count`, :func:`threading.enumerate`, "
":func:`threading.settrace`, :func:`threading.setprofile`, "
":class:`threading.Timer`, or :class:`threading.local`."
msgstr ":mod:`multiprocessing` ã«ã¯ :func:`threading.active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :func:`threading.setprofile`, :class:`threading.Timer` ã‚„ :class:`threading.local` ã®ã‚ˆã†ãªé–¢æ•°ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:804
msgid "Connection Objects"
msgstr "Connection ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/multiprocessing.rst:808
msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr "Connection ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ pickle ã§ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºå¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹æ–‡å­—åˆ—ã‚’é€ã£ãŸã‚Šã€å—ã‘å–ã£ãŸã‚Šã—ã¾ã™ã€‚ãã†ã„ã£ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŒ‡å‘ã®æ¥ç¶šã‚½ã‚±ãƒƒãƒˆã¨è€ƒãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:811
msgid ""
"Connection objects are usually created using :func:`Pipe "
"<multiprocessing.Pipe>` -- see also :ref:`multiprocessing-listeners-"
"clients`."
msgstr ""

#: ../../library/multiprocessing.rst:819
msgid ""
"Send an object to the other end of the connection which should be read using"
" :meth:`recv`."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã¸ :meth:`recv` ã‚’ä½¿ç”¨ã—ã¦èª­ã¿è¾¼ã‚€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é€ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:822
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ pickle ã§ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºå¯èƒ½ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ pickle ãŒæ¥µç«¯ã«å¤§ãã™ãã‚‹ (OS ã«ã‚‚ä¾ã‚Šã¾ã™ãŒã€ãŠã‚ˆã 32 MB+) ã¨ã€ :exc:`ValueError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:827
msgid ""
"Return an object sent from the other end of the connection using "
":meth:`send`.  Blocks until there is something to receive.  Raises "
":exc:`EOFError` if there is nothing left to receive and the other end was "
"closed."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã‹ã‚‰ :meth:`send` ã‚’ä½¿ç”¨ã—ã¦é€ã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ ä½•ã‹å—ã‘å–ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ä½•ã‚‚å—ã‘å–ã‚‰ãšã«ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã§ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸå ´åˆ :exc:`EOFError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:834
msgid "Return the file descriptor or handle used by the connection."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒä½¿ç”¨ã™ã‚‹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‹ã€ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:838
msgid "Close the connection."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:840
msgid "This is called automatically when the connection is garbage collected."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹ã¨ãã«è‡ªå‹•çš„ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:844
msgid "Return whether there is any data available to be read."
msgstr "èª­ã¿è¾¼ã¿å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:846
msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout*"
" is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr "*timeout* ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã™ãã«è¿”ã—ã¾ã™ã€‚ *timeout* ã«æ•°å€¤ã‚’æŒ‡å®šã™ã‚‹ã¨ã€æœ€å¤§æŒ‡å®šã—ãŸç§’æ•°ã‚’ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã—ã¾ã™ã€‚ *timeout* ã« ``None`` ã‚’æŒ‡å®šã™ã‚‹ã¨ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã›ãšã«ãšã£ã¨ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:852
msgid ""
"Send byte data from an object supporting the buffer interface as a complete "
"message."
msgstr "ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å®Œå…¨ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã—ã¦ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:855
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MB+, though it depends on the OS) may raise a "
":exc:`ValueError` exception"
msgstr "*offset* ãŒæŒ‡å®šã•ã‚Œã‚‹ã¨ *buffer* ã®ãã®ä½ç½®ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã™ã€‚ *size* ãŒæŒ‡å®šã•ã‚Œã‚‹ã¨ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‹ã‚‰ãã®é‡ã®ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã™ã€‚éå¸¸ã«å¤§ããªãƒãƒƒãƒ•ã‚¡ãƒ¼ (OS ã«ä¾å­˜ã—ã¾ã™ãŒã€ãŠã‚ˆã 32MB+) ã‚’æŒ‡å®šã™ã‚‹ã¨ã€ :exc:`ValueError` ä¾‹å¤–ãŒç™ºç”Ÿã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:862
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises "
":exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã‹ã‚‰é€ã‚‰ã‚ŒãŸãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã®å®Œå…¨ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ–‡å­—åˆ—ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ä½•ã‹å—ã‘å–ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚å—ã‘å–ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒä½•ã‚‚æ®‹ã£ã¦ãŠã‚‰ãšã€ç›¸æ‰‹å´ãŒã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’é–‰ã˜ã¦ã„ãŸå ´åˆã€ :exc:`EOFError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:867
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then "
":exc:`IOError` is raised and the connection will no longer be readable."
msgstr "*maxlength* ã‚’æŒ‡å®šã—ã¦ã€ä¸”ã¤ *maxlength* ã‚ˆã‚Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé•·ã„å ´åˆã€ :exc:`IOError` ã‚’ç™ºç”Ÿã•ã›ã¦ã€ãã‚Œä»¥ä¸Šã¯ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰èª­ã¿è¾¼ã‚ãªããªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:873
msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã‹ã‚‰é€ã‚‰ã‚ŒãŸãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ *buffer* ã«èª­ã¿è¾¼ã¿ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ã€‚ ä½•ã‹å—ã‘å–ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ä½•ã‚‚å—ã‘å–ã‚‰ãšã«ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã§ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸå ´åˆ :exc:`EOFError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:879
msgid ""
"*buffer* must be an object satisfying the writable buffer interface.  If "
"*offset* is given then the message will be written into the buffer from that"
" position.  Offset must be a non-negative integer less than the length of "
"*buffer* (in bytes)."
msgstr "*buffer* ã¯æ›¸ãè¾¼ã¿å¯èƒ½ãªãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å‚™ãˆãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ *offset* ãŒä¸ãˆã‚‰ã‚ŒãŸã‚‰ã€ãã®ä½ç½®ã‹ã‚‰ãƒãƒƒãƒ•ã‚¡ã¸ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ›¸ãè¾¼ã¾ã‚Œã¾ã™ã€‚ã‚ªãƒ•ã‚»ãƒƒãƒˆã¯ *buffer* ãƒã‚¤ãƒˆã‚ˆã‚Šã‚‚å°ã•ã„æ­£ã®æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:884
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr "ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒã‚ã¾ã‚Šã«å°ã•ã„ã¨ :exc:`BufferTooShort` ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚ ``e`` ãŒä¾‹å¤–ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã™ã‚‹ã¨å®Œå…¨ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ ``e.args[0]`` ã§ç¢ºèªã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:889
msgid "For example:"
msgstr "ä¾‹ãˆã°:"

#: ../../library/multiprocessing.rst:913
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ":meth:`Connection.recv` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å—ä¿¡ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•çš„ã« unpickle åŒ–ã—ã¾ã™ã€‚ãã‚Œã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã£ãŸãƒ—ãƒ­ã‚»ã‚¹ãŒä¿¡é ¼ã§ãã‚‹å ´åˆã‚’é™¤ã„ã¦ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:917
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref"
":`multiprocessing-auth-keys`."
msgstr "ãã®ãŸã‚ :func:`Pipe` ã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹å ´åˆã‚’é™¤ã„ã¦ã€ä½•ã‚‰ã‹ã®èªè¨¼å‡¦ç†ã‚’å®Ÿè¡Œã—ãŸå¾Œã§ :meth:`~Connection.recv` ã‚„ :meth:`~Connection.send` ãƒ¡ã‚½ãƒƒãƒ‰ã®ã¿ã‚’ä½¿ç”¨ã™ã¹ãã§ã™ã€‚è©³ç´°ã¯ :ref:`multiprocessing-auth-keys` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:924
msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr "ã‚‚ã—ãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ‘ã‚¤ãƒ—ã®èª­ã¿è¾¼ã¿ã¾ãŸã¯æ›¸ãè¾¼ã¿ä¸­ã« kill ã•ã‚Œã‚‹ã¨ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å¢ƒç•ŒãŒã©ã“ãªã®ã‹åˆ†ã‹ã‚‰ãªããªã£ã¦ã—ã¾ã†ã®ã§ã€ãã®ãƒ‘ã‚¤ãƒ—å†…ã®ãƒ‡ãƒ¼ã‚¿ã¯ç ´æã—ã¦ã—ã¾ã„ãŒã¡ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:930
msgid "Synchronization primitives"
msgstr "åŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–"

#: ../../library/multiprocessing.rst:934
msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for "
":mod:`threading` module."
msgstr "ä¸€èˆ¬çš„ã«ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚¹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã»ã©ã¯åŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’å¿…è¦ã¨ã—ã¾ã›ã‚“ã€‚è©³ç´°ã¯ :mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:938
msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã—ã¦åŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’ä½œæˆã§ãã‚‹ã“ã¨ã‚‚è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚è©³ç´°ã¯ :ref:`multiprocessing-managers` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:943
msgid ""
"A bounded semaphore object: a close analog of "
":class:`threading.BoundedSemaphore`."
msgstr "æœ‰é™ã‚»ãƒãƒ•ã‚©ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ: :class:`threading.BoundedSemaphore` ã®ã‚¯ãƒ­ãƒ¼ãƒ³ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:946
#: ../../library/multiprocessing.rst:1086
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's"
" first argument is named *block* and it supports an optional second argument"
" *timeout*, as is consistent with :meth:`Lock.acquire`."
msgstr "ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ãŒã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚‚ã®ã¨ä¸€ã¤ã ã‘é•ã„ã¾ã™: ``acquire`` ãƒ¡ã‚½ãƒƒãƒ‰ã®æœ€åˆã®å¼•æ•°ã¯ *block* ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•°ã¨ã—ã¦ *timeout* ã‚’å–ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ :meth:`Lock.acquire` ã§ã®ã‚‚ã®ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:951
msgid ""
"On Mac OS X, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr "Mac OS X ã§ã¯ ``sem_getvalue()`` ãŒå®Ÿè£…ã•ã‚Œã¦ã„ãªã„ã®ã§ :class:`Semaphore` ã¨åŒºåˆ¥ãŒã¤ãã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:956
msgid "A condition variable: a clone of :class:`threading.Condition`."
msgstr "çŠ¶æ…‹å¤‰æ•°: :class:`threading.Condition` ã®ã‚¯ãƒ­ãƒ¼ãƒ³ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:958
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr "*lock* ã‚’æŒ‡å®šã™ã‚‹ãªã‚‰ :mod:`multiprocessing` ã® :class:`Lock` ã‹ :class:`RLock` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:963
msgid ""
"A clone of :class:`threading.Event`. This method returns the state of the "
"internal semaphore on exit, so it will always return ``True`` except if a "
"timeout is given and the operation times out."
msgstr ":class:`threading.Event` ã®ã‚¯ãƒ­ãƒ¼ãƒ³ã§ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€çµ‚äº†æ™‚ã®å†…éƒ¨ã‚»ãƒãƒ•ã‚©ã®çŠ¶æ…‹ã‚’è¿”ã™ã®ã§ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒä¸ãˆã‚‰ã‚Œã€å®Ÿéš›ã«ã‚ªãƒšãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸã®ã§ãªã‘ã‚Œã°ã€å¿…ãš ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:968
msgid "Previously, the method always returned ``None``."
msgstr "ä»¥å‰ã¯ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¸¸ã« ``None`` ã‚’è¿”ã—ã¦ã„ã¾ã—ãŸã€‚"

#: ../../library/multiprocessing.rst:974
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once"
" a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of "
":class:`threading.Lock` as it applies to threads are replicated here in "
":class:`multiprocessing.Lock` as it applies to either processes or threads, "
"except as noted."
msgstr "å†å¸°ã—ãªã„ãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ :class:`threading.Lock` ç›¸å½“ã®ã‚‚ã®ã§ã™ã€‚ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã‚’ã„ã£ãŸã‚“ç²å¾— (acquire) ã™ã‚‹ã¨ã€ãã‚Œã«ç¶šãã»ã‹ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ãŒç²å¾—ã—ã‚ˆã†ã¨ã™ã‚‹éš›ã€ãã‚ŒãŒè§£æ”¾ (release) ã•ã‚Œã‚‹ã¾ã§ã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚è§£æ”¾ã¯ã©ã®ãƒ—ãƒ­ã‚»ã‚¹ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ã‚‚è¡Œãˆã¾ã™ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾ã—ã¦é©ç”¨ã•ã‚Œã‚‹ :class:`threading.Lock` ã®ã‚³ãƒ³ã‚»ãƒ—ãƒˆã¨æŒ¯ã‚‹èˆã„ã¯ã€ç‰¹ç­†ã™ã¹ãã‚‚ã®ãŒãªã„é™ã‚Šã€ãƒ—ãƒ­ã‚»ã‚¹ã¨ã‚¹ãƒ¬ãƒƒãƒ‰ã«é©ç”¨ã•ã‚Œã‚‹ :class:`multiprocessing.Lock` ã«å¼•ãç¶™ãŒã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:982
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ":class:`Lock` ã¯å®Ÿéš›ã«ã¯ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§åˆæœŸåŒ–ã•ã‚ŒãŸ ``multiprocessing.synchronize.Lock`` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:986
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ":class:`Lock` ã¯ :term:`context manager` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã¤ã¾ã‚Š :keyword:`with` æ–‡ã§ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:991
#: ../../library/multiprocessing.rst:1040
msgid "Acquire a lock, blocking or non-blocking."
msgstr "ãƒ–ãƒ­ãƒƒã‚¯ã‚ã‚Šã€ã¾ãŸã¯ãƒ–ãƒ­ãƒƒã‚¯ãªã—ã§ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:993
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and"
" return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr "å¼•æ•° *block* ã‚’ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã«è¨­å®šã—ã¦å‘¼ã³å‡ºã—ãŸå ´åˆã€ãƒ­ãƒƒã‚¯ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰æŠœã‘ã‚‹ã¨ãã‚Œã‚’ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ã—ã¦ã‹ã‚‰ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ :meth:`threading.Lock.acquire` ã®æœ€åˆã®å¼•æ•°ã¨ã¯åå‰ãŒé•ã£ã¦ã„ã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:998
msgid ""
"With the *block* argument set to ``False``, the method call does not block."
"  If the lock is currently in a locked state, return ``False``; otherwise "
"set the lock to a locked state and return ``True``."
msgstr "å¼•æ•° *block* ã®å€¤ã‚’ ``False`` ã«ã—ã¦å‘¼ã³å‡ºã™ã¨ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚ ç¾åœ¨ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã§ã‚ã‚Œã°ã€ç›´ã¡ã« ``False`` ã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€ãƒ­ãƒƒã‚¯ã‚’ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ã—ã¦ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1002
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can"
" not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed.  Note that the "
"*timeout* argument does not exist in this method's analog, "
":meth:`threading.Lock.acquire`."
msgstr "*timeout* ã¨ã—ã¦æ­£ã®æµ®å‹•å°æ•°ç‚¹æ•°ã‚’ä¸ãˆã¦å‘¼ã³å‡ºã™ã¨ã€ãƒ­ãƒƒã‚¯ãŒç²å¾—å‡ºæ¥ãªã„ã‚ã„ã æœ€å¤§ã§ã“ã‚Œã§æŒ‡å®šã—ãŸç§’æ•°ã ã‘ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ *timeout* å€¤ã®è² æ•°ã¯ã‚¼ãƒ­ã¨åŒã˜ã§ã™ã€‚ *timeout* å€¤ã® ``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã¯ç„¡é™ã«ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ *block* ãŒ ``False`` ã®å ´åˆã«ã¯ *timeout* ã«ã¯å®Ÿéš›çš„ãªæ„å‘³ã¯ãªã„ã®ã§ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã™ã‚‹ã¨ ``True`` ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸå ´åˆã¯ ``False`` ã§æˆ»ã‚Šã¾ã™ã€‚ *timeout* å¼•æ•°ã¯é¡ä¼¼å“ã® :meth:`threading.Lock.acquire` ã«ã¯ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1015
msgid ""
"Release a lock.  This can be called from any process or thread, not only the"
" process or thread which originally acquired the lock."
msgstr "ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ã ã‘ã§ãªãã€ä»»æ„ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰å‘¼ã¶ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1018
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ":meth:`threading.Lock.release` ã¨åŒã˜ã‚ˆã†ã«æŒ¯èˆã„ã¾ã™ãŒã€ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„å ´åˆã«å‘¼ã³å‡ºã™ã¨ :exc:`ValueError` ã¨ãªã‚‹ç‚¹ã ã‘ãŒé•ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1024
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr "å†å¸°ãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ :class:`threading.RLock` ç›¸å½“ã®ã‚‚ã®ã§ã™ã€‚å†å¸°ãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã‚Œã‚’ç²å¾— (acquire) ã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ãŒè§£æ”¾ (release) ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã‚’ã„ã£ãŸã‚“ç²å¾—ã™ã‚‹ã¨ã€åŒã˜ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œãšã«å†åº¦ç²å¾—å‡ºæ¥ã¾ã™ã€‚ãã®ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ç²å¾—ã—ãŸå›æ•°ã¶ã‚“è§£æ”¾ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1030
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default"
" context."
msgstr ":class:`RLock` ã¯å®Ÿéš›ã«ã¯ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§åˆæœŸåŒ–ã•ã‚ŒãŸ ``multiprocessing.synchronize.Lock`` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1034
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be"
" used in :keyword:`with` statements."
msgstr ":class:`RLock` ã¯ :term:`context manager` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã¤ã¾ã‚Š :keyword:`with` æ–‡ã§ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1042
msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock"
" is in an unlocked state (not owned by any process or thread) unless the "
"lock is already owned by the current process or thread.  The current process"
" or thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation"
" of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr "*block* å¼•æ•°ã‚’ ``True`` ã«ã—ã¦å‘¼ã³å‡ºã—ãŸå ´åˆã€ãƒ­ãƒƒã‚¯ãŒæ—¢ã«ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãŒæ—¢ã«æ‰€æœ‰ã—ã¦ã„ãªã„é™ã‚Šã¯ã€ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ (ã©ã®ãƒ—ãƒ­ã‚»ã‚¹ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‚‚æ‰€æœ‰ã—ã¦ã„ãªã„çŠ¶æ…‹) ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰æŠœã‘ã‚‹ã¨ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãŒ (æ—¢ã«æŒã£ã¦ã„ãªã‘ã‚Œã°) æ‰€æœ‰æ¨©ã‚’å¾—ã¦ã€å†å¸°ãƒ¬ãƒ™ãƒ«ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã€ ``True`` ã§æˆ»ã‚Šã¾ã™ã€‚ :meth:`threading.RLock.acquire` ã®å®Ÿè£…ã¨ã¯ã“ã®æœ€åˆã®å¼•æ•°ã®æŒ¯ã‚‹èˆã„ãŒã€ãã®åå‰è‡ªèº«ã‚’å§‹ã‚ã¨ã—ã¦ã„ãã¤ã‹é•ã†ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1052
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or"
" thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr "*block* å¼•æ•°ã‚’ ``False`` ã«ã—ã¦å‘¼ã³å‡ºã—ãŸå ´åˆã€ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚ãƒ­ãƒƒã‚¯ãŒä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚ˆã‚Šç²å¾—æ¸ˆã¿ (ã¤ã¾ã‚Šæ‰€æœ‰ã•ã‚Œã¦ã„ã‚‹) ã§ã‚ã‚Œã°ã€ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã¾ãŸã¯ã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ã¯æ‰€æœ‰æ¨©ã‚’å¾—ãšã€å†å¸°ãƒ¬ãƒ™ãƒ«ã‚‚å¤‰æ›´ã›ãšã«ã€ ``False`` ã§æˆ»ã‚Šã¾ã™ã€‚ãƒ­ãƒƒã‚¯ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®å ´åˆã€ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ã¯æ‰€æœ‰æ¨©ã‚’å¾—ã¦å†å¸°ãƒ¬ãƒ™ãƒ«ãŒã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œã€ ``True`` ã§æˆ»ã‚Šã¾ã™ã€‚(---è¨³æ³¨: *block* ã® True/False é–¢ä¿‚ãªãã“ã“ã§ã®èª¬æ˜ã§ã¯ã€Œæ‰€æœ‰æ¨©ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã®2åº¦ç›®ä»¥é™ã® aquireã€ã®èª¬æ˜ãŒæ¬ ã‘ã¦ã„ã¾ã™ã€‚2åº¦ç›®ä»¥é™ã® acquire ã§ã¯å†å¸°ãƒ¬ãƒ™ãƒ«ãŒã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œã¦å³åº§ã«è¿”ã‚Šã¾ã™ã€‚å…¨ä½“èª­ã‚ã°ã‚ã‹ã‚‹ã¨ã¯æ€ã„ã¾ã™ãŒä¸€å¿œã€‚---)"

#: ../../library/multiprocessing.rst:1060
msgid ""
"Use and behaviors of the *timeout* argument are the same as in "
":meth:`Lock.acquire`.  Note that the *timeout* argument does not exist in "
"this method's analog, :meth:`threading.RLock.acquire`."
msgstr "*timeout* å¼•æ•°ã®ä½¿ã„æ–¹ã¨æŒ¯ã‚‹èˆã„ã¯ :meth:`Lock.acquire` ã¨åŒã˜ã§ã™ã€‚ *timeout* å¼•æ•°ã¯é¡ä¼¼å“ã® :meth:`threading.RLock.acquire` ã«ã¯ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1067
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting"
" for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr "å†å¸°ãƒ¬ãƒ™ãƒ«ã‚’ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã¾ã™ã€‚ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆå¾Œã«å†å¸°ãƒ¬ãƒ™ãƒ«ãŒã‚¼ãƒ­ã«ãªã£ãŸå ´åˆã€ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ (ã„ã‹ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã€ã„ã‹ãªã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚‚æ‰€æœ‰ã•ã‚Œã¦ã„ãªã„çŠ¶æ…‹) ã«ãƒªã‚»ãƒƒãƒˆã—ã€ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã«ãªã‚‹ã®ã‚’å¾…ã£ã¦ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã„ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚ã‚‹å ´åˆã«ã¯ãã®ä¸­ã®ãŸã ä¸€ã¤ã ã‘ãŒå‡¦ç†ã‚’é€²è¡Œã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆå¾Œã‚‚å†å¸°ãƒ¬ãƒ™ãƒ«ãŒã‚¼ãƒ­ã§ãªã„å ´åˆã€ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã¯ãƒ­ãƒƒã‚¯ã®ã¾ã¾ã§ã€å‘¼ã³å‡ºã—å´ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã«æ‰€æœ‰ã•ã‚ŒãŸã¾ã¾ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1075
msgid ""
"Only call this method when the calling process or thread owns the lock. An "
":exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å‘¼ã³å‡ºã—ãƒ—ãƒ­ã‚»ã‚¹ã‚ã‚‹ã„ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã‚’æ‰€æœ‰ã—ã¦ã„ã‚‹å ´åˆã«é™ã‚Šå‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚æ‰€æœ‰è€…ã§ãªã„ãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚ˆã£ã¦å‘¼ã°ã‚Œã‚‹ã‹ã€ã‚ã‚‹ã„ã¯ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ (æœªæ‰€æœ‰) çŠ¶æ…‹ã§å‘¼ã°ã‚ŒãŸå ´åˆã€ :exc:`AssertionError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚åŒã˜çŠ¶æ³ã§ã® :meth:`threading.RLock.release` å®Ÿè£…ã¨ã¯ä¾‹å¤–ã®å‹ãŒç•°ãªã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1084
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr "ã‚»ãƒãƒ•ã‚©ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ: :class:`threading.Semaphore` ã®ã‚¯ãƒ­ãƒ¼ãƒ³ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1092
msgid ""
"The :meth:`acquire` method of :class:`BoundedSemaphore`, :class:`Lock`, "
":class:`RLock` and :class:`Semaphore` has a timeout parameter not supported "
"by the equivalents in :mod:`threading`.  The signature is "
"``acquire(block=True, timeout=None)`` with keyword parameters being "
"acceptable.  If *block* is ``True`` and *timeout* is not ``None`` then it "
"specifies a timeout in seconds.  If *block* is ``False`` then *timeout* is "
"ignored."
msgstr ":class:`BoundedSemaphore`, :class:`Lock`, :class:`RLock` ã¨ :class:`Semaphore` ã® :meth:`acquire` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :mod:`threading` ã§ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–ã‚Šã¾ã™ã€‚ãã®å¼•æ•°ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã§å—ã‘å–ã‚Œã‚‹ ``acquire(block=True, timeout=None)`` ã§ã™ã€‚ *block* ãŒ ``True`` ä¸”ã¤ *timeout* ãŒ ``None`` ã§ã¯ãªã„ãªã‚‰ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç§’å˜ä½ã§è¨­å®šã•ã‚Œã¾ã™ã€‚ *block* ãŒ ``False`` ãªã‚‰ *timeout* ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1100
msgid ""
"On Mac OS X, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with"
" a timeout will emulate that function's behavior using a sleeping loop."
msgstr "Mac OS X ã§ã¯ ``sem_timedwait`` ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã®ã§ã€``acquire()`` ã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ä¸ãˆã¦å‘¼ã¶ã¨ã€ãƒ«ãƒ¼ãƒ—å†…ã§ã‚¹ãƒªãƒ¼ãƒ—ã™ã‚‹ã“ã¨ã§ã“ã®é–¢æ•°ãŒã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1105
msgid ""
"If the SIGINT signal generated by :kbd:`Ctrl-C` arrives while the main "
"thread is blocked by a call to :meth:`BoundedSemaphore.acquire`, "
":meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, "
":meth:`Condition.acquire` or :meth:`Condition.wait` then the call will be "
"immediately interrupted and :exc:`KeyboardInterrupt` will be raised."
msgstr "ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ãŒ :meth:`BoundedSemaphore.acquire`, :meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, :meth:`Condition.acquire` åˆã¯ :meth:`Condition.wait` ã‚’å‘¼ã³å‡ºã—ã¦ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°çŠ¶æ…‹ã®ã¨ãã« :kbd:`Ctrl-C` ã§ç”Ÿæˆã•ã‚Œã‚‹ SIGINT ã‚·ã‚°ãƒŠãƒ«ã‚’å—ã‘å–ã‚‹ã¨ã€ãã®å‘¼ã³å‡ºã—ã¯ã™ãã«ä¸­æ–­ã•ã‚Œã¦ :exc:`KeyboardInterrupt` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1111
msgid ""
"This differs from the behaviour of :mod:`threading` where SIGINT will be "
"ignored while the equivalent blocking calls are in progress."
msgstr "ã“ã‚Œã¯åŒç­‰ã®ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°å‘¼ã³å‡ºã—ãŒå®Ÿè¡Œä¸­ã®ã¨ãã« SIGINT ãŒç„¡è¦–ã•ã‚Œã‚‹ :mod:`threading` ã®æŒ¯ã‚‹èˆã„ã¨ã¯é•ã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1116
msgid ""
"Some of this package's functionality requires a functioning shared semaphore"
" implementation on the host operating system. Without one, the "
":mod:`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr "ã“ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å«ã¾ã‚Œã‚‹æ©Ÿèƒ½ã«ã¯ã€ãƒ›ã‚¹ãƒˆã¨ãªã‚‹ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ä¸Šã§å‹•ä½œã—ã¦ã„ã‚‹å…±æœ‰ã‚»ãƒãƒ•ã‚©ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚ŒãŒä½¿ç”¨ã§ããªã„å ´åˆã«ã¯ã€:mod:`multiprocessing.synchronize` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒç„¡åŠ¹ã«ãªã‚Šã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ™‚ã« :exc:`ImportError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚è©³ç´°ã¯ :issue:`3770` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1124
msgid "Shared :mod:`ctypes` Objects"
msgstr "å…±æœ‰ :mod:`ctypes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/multiprocessing.rst:1126
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr "å­ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚ˆã‚Šç¶™æ‰¿ã•ã‚Œã‚‹å…±æœ‰ãƒ¡ãƒ¢ãƒªã‚’ä½¿ç”¨ã™ã‚‹å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1131
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object."
msgstr "å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸ :mod:`ctypes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€è¿”ã‚Šå€¤ã¯å®Ÿéš›ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŒæœŸãƒ©ãƒƒãƒ‘ãƒ¼ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1134
#: ../../library/multiprocessing.rst:1221
msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the "
":mod:`array` module.  *\\*args* is passed on to the constructor for the "
"type."
msgstr "*typecode_or_type* ã¯è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’æ±ºã‚ã¾ã™ã€‚ãã‚Œã¯ ctypes ã®å‹ã‹ :mod:`array` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä½¿ç”¨ã•ã‚Œã‚‹ã‚ˆã†ãª1æ–‡å­—ã®å‹ã‚³ãƒ¼ãƒ‰ã‹ã®ã©ã¡ã‚‰ã‹ä¸€æ–¹ã§ã™ã€‚ *\\*args* ã¯å‹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã¸æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1138
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` or"
" :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr "*lock* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã€å€¤ã¸åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«æ–°ãŸã«å†å¸°çš„ãªãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã•ã‚Œã¾ã™ã€‚ *lock* ãŒ :class:`Lock` ã‹ :class:`RLock` ãªã‚‰å€¤ã¸ã®åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ *lock* ãŒ ``False`` ãªã‚‰ã€è¿”ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ãƒ­ãƒƒã‚¯ã«ã‚ˆã‚Šè‡ªå‹•çš„ã«ä¿è­·ã•ã‚Œã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€å¿…ãšã—ã‚‚ \"ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•\" ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1145
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr "``+=`` ã®ã‚ˆã†ãªæ¼”ç®—ã¯ã€èª­ã¿è¾¼ã¿ã¨æ›¸ãè¾¼ã¿ã‚’å«ã‚€ãŸã‚ã‚¢ãƒˆãƒŸãƒƒã‚¯ã§ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ãŸã‚ã€ãŸã¨ãˆã°è‡ªå‹•çš„ã«å…±æœ‰ã®å€¤ã‚’å¢—åŠ ã•ã›ãŸã„å ´åˆã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã™ã‚‹ã®ã§ã¯ä¸ååˆ†ã§ã™ ::"

#: ../../library/multiprocessing.rst:1151
msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr "é–¢é€£ã™ã‚‹ãƒ­ãƒƒã‚¯ãŒå†å¸°çš„ (ãã‚ŒãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã™) ãªã‚‰ã€ã‹ã‚ã‚Šã«æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™ ::"

#: ../../library/multiprocessing.rst:1157
#: ../../library/multiprocessing.rst:1247
#: ../../library/multiprocessing.rst:1262
msgid "Note that *lock* is a keyword-only argument."
msgstr "*lock* ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã§ã®ã¿æŒ‡å®šã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1161
msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr "å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸ ctypes é…åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€è¿”ã‚Šå€¤ã¯å®Ÿéš›ã®é…åˆ—ã®åŒæœŸãƒ©ãƒƒãƒ‘ãƒ¼ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1164
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr "*typecode_or_type* ã¯è¿”ã•ã‚Œã‚‹é…åˆ—ã®è¦ç´ ã®å‹ã‚’æ±ºã‚ã¾ã™ã€‚ãã‚Œã¯ ctypes ã®å‹ã‹ :mod:`array` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä½¿ç”¨ã•ã‚Œã‚‹ã‚ˆã†ãª1æ–‡å­—ã®å‹ã‚³ãƒ¼ãƒ‰ã‹ã®ã©ã¡ã‚‰ã‹ä¸€æ–¹ã§ã™ã€‚ *size_or_initializer* ãŒæ•´æ•°ãªã‚‰ã€é…åˆ—ã®é•·ã•ã‚’æ±ºå®šã—ã€ãã®é…åˆ—ã¯ã‚¼ãƒ­ã§åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚åˆ¥ã®ä½¿ç”¨æ–¹æ³•ã¨ã—ã¦ *size_or_initializer* ã¯é…åˆ—ã®åˆæœŸåŒ–ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ãªã‚Šã€ãã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹é•·ãŒé…åˆ—ã®é•·ã•ã‚’æ±ºå®šã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1171
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or "
":class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr "*lock* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã€å€¤ã¸åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«æ–°ãŸãªãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã•ã‚Œã¾ã™ã€‚ *lock* ãŒ :class:`Lock` ã‹ :class:`RLock` ãªã‚‰å€¤ã¸ã®åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ *lock* ãŒ ``False`` ãªã‚‰ã€è¿”ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ãƒ­ãƒƒã‚¯ã«ã‚ˆã‚Šè‡ªå‹•çš„ã«ä¿è­·ã•ã‚Œã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€å¿…ãšã—ã‚‚ \"ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•\" ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1178
msgid "Note that *lock* is a keyword only argument."
msgstr "*lock* ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ã—ã¦ã®ã¿åˆ©ç”¨å¯èƒ½ãªã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1180
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes"
" which allow one to use it to store and retrieve strings."
msgstr ":data:`ctypes.c_char` ã®é…åˆ—ã¯æ–‡å­—åˆ—ã‚’æ ¼ç´ã—ã¦å–ã‚Šå‡ºã›ã‚‹ *value* ã¨ *raw* å±æ€§ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1185
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr ":mod:`multiprocessing.sharedctypes` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/multiprocessing.rst:1190
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ":mod:`multiprocessing.sharedctypes` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å­ãƒ—ãƒ­ã‚»ã‚¹ã«ç¶™æ‰¿ã•ã‚Œã‚‹å…±æœ‰ãƒ¡ãƒ¢ãƒªã® :mod:`ctypes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰²ã‚Šå½“ã¦ã‚‹é–¢æ•°ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1196
msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process"
" may cause a crash."
msgstr "å…±æœ‰ãƒ¡ãƒ¢ãƒªã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’æ ¼ç´ã™ã‚‹ã“ã¨ã¯å¯èƒ½ã§ã¯ã‚ã‚Šã¾ã™ãŒã€ç‰¹å®šãƒ—ãƒ­ã‚»ã‚¹ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ç©ºé–“ã®ä½ç½®ã‚’å‚ç…§ã™ã‚‹ã¨ã„ã†ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚ã—ã‹ã—ã€ãã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¯åˆ¥ã®ãƒ—ãƒ­ã‚»ã‚¹ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ãŠã„ã¦ç„¡åŠ¹ã«ãªã‚‹ç¢ºç‡ãŒé«˜ã„ã§ã™ã€‚ãã—ã¦ã€åˆ¥ã®ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ãã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’é€†å‚ç…§ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã‚’å¼•ãèµ·ã“ã™å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1204
msgid "Return a ctypes array allocated from shared memory."
msgstr "å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸ ctypes é…åˆ—ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1206
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr "*typecode_or_type* ã¯è¿”ã•ã‚Œã‚‹é…åˆ—ã®è¦ç´ ã®å‹ã‚’æ±ºã‚ã¾ã™ã€‚ãã‚Œã¯ ctypes ã®å‹ã‹ :mod:`array` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä½¿ç”¨ã•ã‚Œã‚‹ã‚ˆã†ãª1æ–‡å­—ã®å‹ã‚³ãƒ¼ãƒ‰ã®ã©ã¡ã‚‰ã‹ä¸€æ–¹ã§ã™ã€‚ *size_or_initializer* ãŒæ•´æ•°ãªã‚‰ã€ãã‚ŒãŒé…åˆ—ã®é•·ã•ã«ãªã‚Šã€ãã®é…åˆ—ã¯ã‚¼ãƒ­ã§åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚åˆ¥ã®ä½¿ç”¨æ–¹æ³•ã¨ã—ã¦ *size_or_initializer* ã«ã¯é…åˆ—ã®åˆæœŸåŒ–ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã€ãã®å ´åˆã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒé…åˆ—ã®é•·ã•ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1213
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use "
":func:`Array` instead to make sure that access is automatically synchronized"
" using a lock."
msgstr "è¦ç´ ã‚’å–å¾—ã—ãŸã‚Šè¨­å®šã—ãŸã‚Šã™ã‚‹ã“ã¨ã¯æ½œåœ¨çš„ã«éã‚¢ãƒˆãƒŸãƒƒã‚¯ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãƒ­ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¦è‡ªå‹•çš„ã«åŒæœŸåŒ–ã•ã‚ŒãŸã‚¢ã‚¯ã‚»ã‚¹ã‚’ä¿è¨¼ã™ã‚‹ã«ã¯ :func:`Array` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1219
msgid "Return a ctypes object allocated from shared memory."
msgstr "å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸ ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1225
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use "
":func:`Value` instead to make sure that access is automatically synchronized"
" using a lock."
msgstr "å€¤ã‚’å–å¾—ã—ãŸã‚Šè¨­å®šã—ãŸã‚Šã™ã‚‹ã“ã¨ã¯æ½œåœ¨çš„ã«éã‚¢ãƒˆãƒŸãƒƒã‚¯ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãƒ­ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¦è‡ªå‹•çš„ã«åŒæœŸåŒ–ã•ã‚ŒãŸã‚¢ã‚¯ã‚»ã‚¹ã‚’ä¿è¨¼ã™ã‚‹ã«ã¯ :func:`Value` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1229
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ":data:`ctypes.c_char` ã®é…åˆ—ã¯æ–‡å­—åˆ—ã‚’æ ¼ç´ã—ã¦å–ã‚Šå‡ºã›ã‚‹ ``value`` ã¨ ``raw`` å±æ€§ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚è©³ç´°ã¯ :mod:`ctypes` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1235
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes"
" array."
msgstr ":func:`RawArray` ã¨åŒæ§˜ã§ã™ãŒã€ *lock* ã®å€¤ã«ã‚ˆã£ã¦ã¯ ctypes é…åˆ—ã‚’ãã®ã¾ã¾è¿”ã™ä»£ã‚ã‚Šã«ã€ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•ãªåŒæœŸãƒ©ãƒƒãƒ‘ãƒ¼ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1239
#: ../../library/multiprocessing.rst:1255
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a "
":class:`~multiprocessing.Lock` or :class:`~multiprocessing.RLock` object "
"then that will be used to synchronize access to the value.  If *lock* is "
"``False`` then access to the returned object will not be automatically "
"protected by a lock, so it will not necessarily be \"process-safe\"."
msgstr "*lock* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã€å€¤ã¸åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«æ–°ãŸãª ãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã•ã‚Œã¾ã™ã€‚ *lock* ãŒ :class:`~multiprocessing.Lock` ã‹ :class:`~multiprocessing.RLock` ãªã‚‰å€¤ã¸ã®åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ *lock* ãŒ ``False`` ãªã‚‰ã€è¿”ã•ã‚ŒãŸ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ãƒ­ãƒƒã‚¯ã«ã‚ˆã‚Šè‡ªå‹•çš„ã«ä¿è­·ã•ã‚Œã¾ã›ã‚“ã€‚ ãã®ãŸã‚ã€å¿…ãšã—ã‚‚ \"ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•\" ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1251
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes"
" object."
msgstr ":func:`RawValue` ã¨åŒæ§˜ã§ã™ãŒã€ *lock* ã®å€¤ã«ã‚ˆã£ã¦ã¯ ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãã®ã¾ã¾è¿”ã™ä»£ã‚ã‚Šã«ã€ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•ãªåŒæœŸãƒ©ãƒƒãƒ‘ãƒ¼ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1266
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr "å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸ ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *obj* ã‚’ã‚³ãƒ”ãƒ¼ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1271
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a "
":class:`multiprocessing.RLock` object is created automatically."
msgstr "åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã« *lock* ã‚’ä½¿ç”¨ã™ã‚‹ ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãŸã‚ã«ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•ãªãƒ©ãƒƒãƒ‘ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ *lock* ãŒ ``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã€ :class:`multiprocessing.RLock` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè‡ªå‹•çš„ã«ä½œæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1275
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and "
":meth:`get_lock` returns the lock object used for synchronization."
msgstr "åŒæœŸãƒ©ãƒƒãƒ‘ãƒ¼ãŒãƒ©ãƒƒãƒ—ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åŠ ãˆã¦2ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚ :meth:`get_obj` ã¯ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ :meth:`get_lock` ã¯åŒæœŸã®ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1279
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr "ãƒ©ãƒƒãƒ‘ãƒ¼çµŒç”±ã§ ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã¯ raw ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã‚ˆã‚Šãšã£ã¨é…ããªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1283
msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr "æ¬¡ã®è¡¨ã¯é€šå¸¸ã® ctypes æ§‹æ–‡ã§å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å…±æœ‰ ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ãŸã‚ã®æ§‹æ–‡ã‚’æ¯”è¼ƒã—ã¾ã™ã€‚ (``MyStruct`` ãƒ†ãƒ¼ãƒ–ãƒ«å†…ã«ã¯ :class:`ctypes.Structure` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒã‚ã‚Šã¾ã™ã€‚)"

#: ../../library/multiprocessing.rst:1288
msgid "ctypes"
msgstr "ctypes"

#: ../../library/multiprocessing.rst:1288
msgid "sharedctypes using type"
msgstr "type ã‚’ä½¿ç”¨ã™ã‚‹ sharedctypes"

#: ../../library/multiprocessing.rst:1288
msgid "sharedctypes using typecode"
msgstr "typecode ã‚’ä½¿ç”¨ã™ã‚‹ sharedctypes"

#: ../../library/multiprocessing.rst:1290
msgid "c_double(2.4)"
msgstr "c_double(2.4)"

#: ../../library/multiprocessing.rst:1290
msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2.4)"

#: ../../library/multiprocessing.rst:1290
msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

#: ../../library/multiprocessing.rst:1291
msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

#: ../../library/multiprocessing.rst:1291
msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

#: ../../library/multiprocessing.rst:1292
msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

#: ../../library/multiprocessing.rst:1292
msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

#: ../../library/multiprocessing.rst:1292
msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

#: ../../library/multiprocessing.rst:1293
msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

#: ../../library/multiprocessing.rst:1293
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

#: ../../library/multiprocessing.rst:1293
msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray('i', (9, 2, 8))"

#: ../../library/multiprocessing.rst:1297
msgid ""
"Below is an example where a number of ctypes objects are modified by a child"
" process::"
msgstr "ä»¥ä¸‹ã«å­ãƒ—ãƒ­ã‚»ã‚¹ãŒå¤šãã® ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¤‰æ›´ã™ã‚‹ä¾‹ã‚’ç´¹ä»‹ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:1335
msgid "The results printed are ::"
msgstr "çµæœã¯ä»¥ä¸‹ã®ã‚ˆã†ã«è¡¨ç¤ºã•ã‚Œã¾ã™ ::"

#: ../../library/multiprocessing.rst:1348
msgid "Managers"
msgstr "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼"

#: ../../library/multiprocessing.rst:1350
msgid ""
"Managers provide a way to create data which can be shared between different "
"processes. A manager object controls a server process which manages *shared "
"objects*.  Other processes can access the shared objects by using proxies."
msgstr "Manager ã¯åˆ¥ã®ãƒ—ãƒ­ã‚»ã‚¹é–“ã§å…±æœ‰ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆæ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚ãƒãƒãƒ¼ã‚¸ãƒ£ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ *å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ* ã‚’ç®¡ç†ã™ã‚‹ã‚µãƒ¼ãƒãƒ—ãƒ­ã‚»ã‚¹ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1356
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹é–“ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å…±æœ‰ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ :class:`~multiprocessing.managers.SyncManager` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚è¿”ã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ç”Ÿæˆã•ã‚Œã‚‹å­ãƒ—ãƒ­ã‚»ã‚¹ã«å¯¾å¿œä»˜ã‘ã‚‰ã‚Œã€å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚„ã€å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾å¿œã™ã‚‹ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1364
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the "
":mod:`multiprocessing.managers` module:"
msgstr "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã¯è¦ªãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã™ã‚‹ã‹ã€ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹ã¨åœæ­¢ã—ã¾ã™ã€‚ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¯ãƒ©ã‚¹ã¯ :mod:`multiprocessing.managers` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™:"

#: ../../library/multiprocessing.rst:1370
msgid "Create a BaseManager object."
msgstr "BaseManager ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1372
msgid ""
"Once created one should call :meth:`start` or "
"``get_server().serve_forever()`` to ensure that the manager object refers to"
" a started manager process."
msgstr "ä½œæˆå¾Œã€:meth:`start` ã‹ ``get_server().serve_forever()`` ã‚’å‘¼ã³å‡ºã—ã¦ã€ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç¢ºå®Ÿã«é–‹å§‹ã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’å‚ç…§ã™ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1375
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr "*address* ã¯ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒæ–°ãŸãªã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’å¾…ã¡å—ã‘ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚*address* ãŒ ``None`` ã®å ´åˆã€ä»»æ„ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1378
msgid ""
"*authkey* is the authentication key which will be used to check the validity"
" of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey``.  Otherwise *authkey* is used and it must"
" be a string."
msgstr "*authkey* ã¯ã‚µãƒ¼ãƒãƒ—ãƒ­ã‚»ã‚¹ã¸æ¥ç¶šã—ã‚ˆã†ã¨ã™ã‚‹ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®æ­£å½“æ€§ã‚’æ¤œè¨¼ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹èªè¨¼ã‚­ãƒ¼ã§ã™ã€‚ *authkey* ãŒ ``None`` ã®å ´åˆ ``current_process().authkey`` ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ *authkey* ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1385
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’é–‹å§‹ã™ã‚‹ãŸã‚ã«ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã—ã¾ã™ã€‚*initializer* ãŒ ``None`` ã§ãªã‘ã‚Œã°ã€ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã¯é–‹å§‹æ™‚ã« ``initializer(*initargs)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1390
msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the "
":meth:`serve_forever` method::"
msgstr "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆ¶å¾¡ä¸‹ã«ã‚ã‚‹å®Ÿéš›ã®ã‚µãƒ¼ãƒãƒ¼ã‚’è¡¨ã™ :class:`Server` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ :class:`Server` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :meth:`serve_forever` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™::"

#: ../../library/multiprocessing.rst:1399
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` ã¯ã•ã‚‰ã« :attr:`address` å±æ€§ã‚‚æŒã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1403
msgid "Connect a local manager object to a remote manager process::"
msgstr "ãƒ­ãƒ¼ã‚«ãƒ«ã‹ã‚‰ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸æ¥ç¶šã—ã¾ã™::"

#: ../../library/multiprocessing.rst:1411
msgid ""
"Stop the process used by the manager.  This is only available if "
":meth:`start` has been used to start the server process."
msgstr "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒä½¿ç”¨ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‚’åœæ­¢ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã™ã‚‹ãŸã‚ã« :meth:`start` ãŒä½¿ç”¨ã•ã‚ŒãŸå ´åˆã®ã¿æœ‰åŠ¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1414
msgid "This can be called multiple times."
msgstr "ã“ã‚Œã¯è¤‡æ•°å›å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1418
msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¯ãƒ©ã‚¹ã§å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ(callable)ã‚„å‹ã‚’ç™»éŒ²ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1421
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr "*typeid* ã¯ç‰¹ã«å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ \"å‹è­˜åˆ¥å­\" ã§ã™ã€‚ã“ã‚Œã¯æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1424
msgid ""
"*callable* is a callable used for creating objects for this type identifier."
"  If a manager instance will be created using the :meth:`from_address` "
"classmethod or if the *create_method* argument is ``False`` then this can be"
" left as ``None``."
msgstr "*callable* ã¯ã“ã®å‹è­˜åˆ¥å­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ãƒãƒãƒ¼ã‚¸ãƒ£ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ :meth:`from_address` ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ä½œæˆã•ã‚Œã‚‹ã‹ã€ *create_method* å¼•æ•°ãŒ ``False`` ã®å ´åˆã¯ ``None`` ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1429
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr "*proxytype* ã¯ã“ã® *typeid* ã§å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ã‚­ã‚·ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ :class:`BaseProxy` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ ``None`` ã®å ´åˆã€ãƒ—ãƒ­ã‚­ã‚·ã‚¯ãƒ©ã‚¹ã¯è‡ªå‹•çš„ã«ä½œæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1433
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy._callmethod`."
"  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is used instead"
" if it exists.)  In the case where no exposed list is specified, all "
"\"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr "*exposed* ã¯ :meth:`BaseProxy._callmethod` ã‚’ä½¿ç”¨ã—ãŸã‚¢ã‚¯ã‚»ã‚¹ãŒè¨±ã•ã‚Œã‚‹ã¹ã typeid ã‚’ãƒ—ãƒ­ã‚­ã‚·ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰åã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ (*exposed* ãŒ ``None`` ã®å ´åˆ :attr:`proxytype._exposed_` ãŒå­˜åœ¨ã™ã‚Œã°ãã‚ŒãŒä»£ã‚ã‚Šã«ä½¿ç”¨ã•ã‚Œã¾ã™)ã€‚*exposed* ãƒªã‚¹ãƒˆãŒæŒ‡å®šã•ã‚Œãªã„å ´åˆã€å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã™ã¹ã¦ã® \"ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰\" ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚ (ã“ã“ã§ã„ã† \"ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰\" ã¨ã¯ :meth:`~object.__call__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚‚ã®ã¨åå‰ãŒ ``'_'`` ã§å§‹ã¾ã‚‰ãªã„ã‚ã‚‰ã‚†ã‚‹å±æ€§ã‚’æ„å‘³ã—ã¾ã™ã€‚)"

#: ../../library/multiprocessing.rst:1442
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid"
" strings.  (If *method_to_typeid* is ``None`` then "
":attr:`proxytype._method_to_typeid_` is used instead if it exists.)  If a "
"method's name is not a key of this mapping or if the mapping is ``None`` "
"then the object returned by the method will be copied by value."
msgstr "*method_to_typeid* ã¯ãƒ—ãƒ­ã‚­ã‚·ãŒè¿”ã™ exposed ãƒ¡ã‚½ãƒƒãƒ‰ã®è¿”ã‚Šå€¤ã®å‹ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒãƒƒãƒ”ãƒ³ã‚°ã§ã€ãƒ¡ã‚½ãƒƒãƒ‰åã‚’ typeid æ–‡å­—åˆ—ã«ãƒãƒƒãƒ—ã—ã¾ã™ã€‚ (*method_to_typeid* ãŒ ``None`` ã®å ´åˆ :attr:`proxytype._method_to_typeid_` ãŒå­˜åœ¨ã™ã‚Œã°ã€ãã‚ŒãŒä»£ã‚ã‚Šã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚) ãƒ¡ã‚½ãƒƒãƒ‰åãŒã“ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã®ã‚­ãƒ¼ã§ã¯ãªã„ã‹ã€ãƒãƒƒãƒ”ãƒ³ã‚°ãŒ ``None`` ã®å ´åˆã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå€¤ã¨ã—ã¦ (by value) ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1449
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared"
" object and return a proxy for it.  By default it is ``True``."
msgstr "*create_method* ã¯ã€å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã€ãã‚Œã«å¯¾ã™ã‚‹ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã™ã‚ˆã†ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã«ä¼ãˆã‚‹ã€åå‰ *typeid* ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½œæˆã™ã‚‹ã‹ã‚’æ±ºå®šã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``True`` ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1453
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ":class:`BaseManager` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚‚èª­ã¿å–ã‚Šå°‚ç”¨å±æ€§ã‚’1ã¤æŒã£ã¦ã„ã¾ã™:"

#: ../../library/multiprocessing.rst:1457
msgid "The address used by the manager."
msgstr "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒä½¿ç”¨ã™ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1462
msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization"
" of processes.  Objects of this type are returned by "
":func:`multiprocessing.Manager`."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹é–“ã®åŒæœŸã®ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ :class:`BaseManager` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ :func:`multiprocessing.Manager` ã¯ã“ã®å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1466
msgid "It also supports creation of shared lists and dictionaries."
msgstr "ã¾ãŸå…±æœ‰ã®ãƒªã‚¹ãƒˆã‚„ãƒ‡ã‚£ã‚¯ã‚·ãƒ§ãƒŠãƒªã®ä½œæˆã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1470
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr "å…±æœ‰ :class:`threading.BoundedSemaphore` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1475
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr "å…±æœ‰ :class:`threading.Condition` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1478
msgid ""
"If *lock* is supplied then it should be a proxy for a "
":class:`threading.Lock` or :class:`threading.RLock` object."
msgstr "*lock* ãŒæä¾›ã•ã‚Œã‚‹å ´åˆ :class:`threading.Lock` ã‹ :class:`threading.RLock` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãŸã‚ã®ãƒ—ãƒ­ã‚­ã‚·ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1483
msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr "å…±æœ‰ :class:`threading.Event` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1487
msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr "å…±æœ‰ :class:`threading.Lock` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1491
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr "å…±æœ‰ :class:`Namespace` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1495
msgid "Create a shared :class:`Queue.Queue` object and return a proxy for it."
msgstr "å…±æœ‰ :class:`Queue.Queue` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1499
msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr "å…±æœ‰ :class:`threading.RLock` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1503
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr "å…±æœ‰ :class:`threading.Semaphore` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1508
msgid "Create an array and return a proxy for it."
msgstr "é…åˆ—ã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1512
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr "æ›¸ãè¾¼ã¿å¯èƒ½ãª ``value`` å±æ€§ã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1519
msgid "Create a shared ``dict`` object and return a proxy for it."
msgstr "å…±æœ‰ ``dict`` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1524
msgid "Create a shared ``list`` object and return a proxy for it."
msgstr "å…±æœ‰ ``list`` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1528
msgid ""
"Modifications to mutable values or items in dict and list proxies will not "
"be propagated through the manager, because the proxy has no way of knowing "
"when its values or items are modified.  To modify such an item, you can re-"
"assign the modified object to the container proxy::"
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã«ã¯ã€è‡ªèº«ã®æŒã¤è¾æ›¸ã¨ãƒªã‚¹ãƒˆã®ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªå€¤ã‚„é …ç›®ãŒã„ã¤å¤‰æ›´ã•ã‚ŒãŸã®ã‹ã‚’çŸ¥ã‚‹æ–¹æ³•ãŒãªã„ãŸã‚ã€ã“ã‚Œã‚‰ã®å€¤ã‚„é …ç›®ã®å¤‰æ›´ã¯ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’é€šã—ã¦ä¼æ’­ã—ã¾ã›ã‚“ã€‚ã“ã®ã‚ˆã†ãªè¦ç´ ã‚’å¤‰æ›´ã™ã‚‹ã«ã¯ã€ã‚³ãƒ³ãƒ†ãƒŠãƒ¼ã®ãƒ—ãƒ­ã‚­ã‚·ã«å¤‰æ›´ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†ä»£å…¥ã—ã¦ãã ã•ã„::"

#: ../../library/multiprocessing.rst:1547
msgid "A type that can register with :class:`SyncManager`."
msgstr ":class:`SyncManager` ã«ç™»éŒ²ã™ã‚‹ã“ã¨ã®ã§ãã‚‹å‹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1549
msgid ""
"A namespace object has no public methods, but does have writable attributes."
" Its representation shows the values of its attributes."
msgstr "Namespace ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãªãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€æ›¸ãè¾¼ã¿å¯èƒ½ãªå±æ€§ã‚’æŒã¡ã¾ã™ã€‚ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¾ã¯ãã®å±æ€§ã®å€¤ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1552
msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr "ã—ã‹ã—ã€Namespace ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãŸã‚ã«ãƒ—ãƒ­ã‚­ã‚·ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã ``'_'`` ãŒå…ˆé ­ã«ä»˜ãå±æ€§ã¯ãƒ—ãƒ­ã‚­ã‚·ã®å±æ€§ã«ãªã‚Šã€å‚ç…§å¯¾è±¡ã®å±æ€§ã«ã¯ãªã‚Šã¾ã›ã‚“:"

#: ../../library/multiprocessing.rst:1567
msgid "Customized managers"
msgstr "ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼"

#: ../../library/multiprocessing.rst:1569
msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types"
" or callables with the manager class.  For example::"
msgstr "ç‹¬è‡ªã®ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ä½œæˆã™ã‚‹ã«ã¯ã€:class:`BaseManager` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ã¦ã€ ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¯ãƒ©ã‚¹ã§å‘¼ã³å‡ºã—å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹æ–°ãŸãªå‹ã‚’ç™»éŒ²ã™ã‚‹ãŸã‚ã« :meth:`~BaseManager.register` ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/multiprocessing.rst:1595
msgid "Using a remote manager"
msgstr "ãƒªãƒ¢ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹"

#: ../../library/multiprocessing.rst:1597
msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr "ã‚ã‚‹ãƒã‚·ãƒ³ä¸Šã§ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚µãƒ¼ãƒãƒ¼ã‚’å®Ÿè¡Œã—ã¦ã€ä»–ã®ãƒã‚·ãƒ³ã‹ã‚‰ãã®ã‚µãƒ¼ãƒãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’æŒã¤ã“ã¨ãŒã§ãã¾ã™(ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã‚’é€šéã§ãã‚‹ã“ã¨ãŒå‰æ)ã€‚"

#: ../../library/multiprocessing.rst:1600
msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr "æ¬¡ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ãƒªãƒ¢ãƒ¼ãƒˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã‚’å—ã‘ä»˜ã‘ã‚‹1ã¤ã®å…±æœ‰ã‚­ãƒ¥ãƒ¼ã®ãŸã‚ã«ã‚µãƒ¼ãƒãƒ¼ã‚’ä½œæˆã—ã¾ã™::"

#: ../../library/multiprocessing.rst:1612
msgid "One client can access the server as follows::"
msgstr "ã‚ã‚‹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã‚µãƒ¼ãƒãƒ¼ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/multiprocessing.rst:1622
msgid "Another client can also use it::"
msgstr "åˆ¥ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚‚ãã‚Œã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/multiprocessing.rst:1633
msgid ""
"Local processes can also access that queue, using the code from above on the"
" client to access it remotely::"
msgstr "ãƒ­ãƒ¼ã‚«ãƒ«ãƒ—ãƒ­ã‚»ã‚¹ã‚‚ãã®ã‚­ãƒ¥ãƒ¼ã¸ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆä¸Šã§ä¸Šè¿°ã®ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:1656
msgid "Proxy Objects"
msgstr "Proxy ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/multiprocessing.rst:1658
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã¯åˆ¥ã®ãƒ—ãƒ­ã‚»ã‚¹ã§(ãŠãã‚‰ã)æœ‰åŠ¹ãªå…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ *å‚ç…§ã™ã‚‹* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ­ã‚­ã‚·ã® *å‚ç…§å¯¾è±¡* ã«ãªã‚‹ã¨ã„ã†ã“ã¨ãŒã§ãã¾ã™ã€‚è¤‡æ•°ã®ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒåŒã˜å‚ç…§å¯¾è±¡ã‚’æŒã¤å¯èƒ½æ€§ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1662
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  A proxy can usually be used in most of the "
"same ways that its referent can:"
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã®å‚ç…§å¯¾è±¡ãŒæŒã¤å¯¾å¿œãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¡ã¾ã™ã€‚(ãã†ã¯è¨€ã£ã¦ã‚‚ã€å‚ç…§å¯¾è±¡ã®ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¿…ãšã—ã‚‚ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§åˆ©ç”¨å¯èƒ½ã§ã¯ã‚ã‚Šã¾ã›ã‚“) ãƒ—ãƒ­ã‚­ã‚·ã¯é€šå¸¸ãã®å‚ç…§å¯¾è±¡ãŒã§ãã‚‹ã“ã¨ã¨åŒã˜æ–¹æ³•ã§ä½¿ç”¨ã•ã‚Œã¾ã™:"

#: ../../library/multiprocessing.rst:1681
msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã« :func:`str` ã‚’é©ç”¨ã™ã‚‹ã¨å‚ç…§å¯¾è±¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¾ã‚’è¿”ã™ã®ã«å¯¾ã—ã¦ã€ :func:`repr` ã‚’é©ç”¨ã™ã‚‹ã¨ãƒ—ãƒ­ã‚­ã‚·ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¾ã‚’è¿”ã™ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1685
msgid ""
"An important feature of proxy objects is that they are picklable so they can"
" be passed between processes.  Note, however, that if a proxy is sent to the"
" corresponding manager's process then unpickling it will produce the "
"referent itself.  This means, for example, that one shared object can "
"contain a second:"
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é‡è¦ãªæ©Ÿèƒ½ã¯ãƒ—ãƒ­ã‚»ã‚¹é–“ã§å—ã‘æ¸¡ã—å¯èƒ½ãª pickle åŒ–ãŒã§ãã‚‹ã“ã¨ã§ã™ã€‚ã—ã‹ã—ã€ãƒ—ãƒ­ã‚­ã‚·ãŒå¯¾å¿œã™ã‚‹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã«å¯¾ã—ã¦é€ä¿¡ã•ã‚Œã‚‹å ´åˆã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’ unpickle ã™ã‚‹ã¨ãã®å‚ç…§å¯¾è±¡ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°ã€ã“ã‚Œã¯ã‚ã‚‹å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åˆ¥ã®å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå«ã‚ã‚‰ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™:"

#: ../../library/multiprocessing.rst:1703
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ":mod:`multiprocessing` ã®ãƒ—ãƒ­ã‚­ã‚·å‹ã¯å€¤ã«ã‚ˆã‚‹æ¯”è¼ƒã«å¯¾ã—ã¦ä½•ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™:"

#: ../../library/multiprocessing.rst:1711
msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr "æ¯”è¼ƒã‚’è¡Œã„ãŸã„ã¨ãã¯å‚ç…§å¯¾è±¡ã®ã‚³ãƒ”ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1715
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :class:`BaseProxy` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1719
msgid "Call and return the result of a method of the proxy's referent."
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã®å‚ç…§å¯¾è±¡ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè¡Œçµæœã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1721
msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr "``proxy`` ãŒãƒ—ãƒ­ã‚­ã‚·ã§ã€ãƒ—ãƒ­ã‚­ã‚·å†…ã®å‚ç…§å¯¾è±¡ãŒ ``obj`` ãªã‚‰ã“ã®å¼ ::"

#: ../../library/multiprocessing.rst:1725
msgid "will evaluate the expression ::"
msgstr "ã¯ã“ã®å¼ã‚’è©•ä¾¡ã—ã¾ã™ ::"

#: ../../library/multiprocessing.rst:1729
msgid "in the manager's process."
msgstr "(ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹å†…ã®)ã€‚"

#: ../../library/multiprocessing.rst:1731
msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr "è¿”ã•ã‚Œã‚‹å€¤ã¯ãã®å‘¼ã³å‡ºã—çµæœã®ã‚³ãƒ”ãƒ¼ã‹ã€æ–°ãŸãªå…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ãƒ—ãƒ­ã‚­ã‚·ã«ãªã‚Šã¾ã™ã€‚è©³ç´°ã¯ :meth:`BaseManager.register` ã® *method_to_typeid* å¼•æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1735
msgid ""
"If an exception is raised by the call, then is re-raised by "
":meth:`_callmethod`.  If some other exception is raised in the manager's "
"process then this is converted into a :exc:`RemoteError` exception and is "
"raised by :meth:`_callmethod`."
msgstr "ãã®å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸå ´åˆã€:meth:`_callmethod` ã«ã‚ˆã£ã¦ãã®ä¾‹å¤–ã¯å†é€å‡ºã•ã‚Œã¾ã™ã€‚ä»–ã®ä¾‹å¤–ãŒãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã§ç™ºç”Ÿã—ãŸãªã‚‰ã€:exc:`RemoteError` ä¾‹å¤–ã«å¤‰æ›ã•ã‚ŒãŸã‚‚ã®ãŒ :meth:`_callmethod` ã«ã‚ˆã£ã¦é€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1740
msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr "ç‰¹ã« *methodname* ãŒ *å…¬é–‹* ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ä¾‹å¤–ãŒç™ºç”Ÿã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1743
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr ":meth:`_callmethod` ã®ä½¿ç”¨ä¾‹ã«ãªã‚Šã¾ã™:"

#: ../../library/multiprocessing.rst:1759
msgid "Return a copy of the referent."
msgstr "å‚ç…§å¯¾è±¡ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1761
msgid "If the referent is unpicklable then this will raise an exception."
msgstr "å‚ç…§å¯¾è±¡ãŒ unpickle åŒ–ã§ãã‚‹ãªã‚‰ä¾‹å¤–ã‚’ç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1765
msgid "Return a representation of the proxy object."
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¾ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1769
msgid "Return the representation of the referent."
msgstr "å‚ç…§å¯¾è±¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¾ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1773
msgid "Cleanup"
msgstr "ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"

#: ../../library/multiprocessing.rst:1775
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¼±å‚ç…§(weakref)ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹ã¨ãã«ãã®å‚ç…§å¯¾è±¡ãŒæ‰€æœ‰ã™ã‚‹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‹ã‚‰ãã®ç™»éŒ²ã‚’å–ã‚Šæ¶ˆã›ã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1778
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr "å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ­ã‚­ã‚·ãŒå‚ç…§ã—ãªããªã£ãŸã¨ãã«ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰å‰Šé™¤ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1783
msgid "Process Pools"
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ãƒ—ãƒ¼ãƒ«"

#: ../../library/multiprocessing.rst:1788
msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr ":class:`Pool` ã‚¯ãƒ©ã‚¹ã§ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ—ãƒ¼ãƒ«ã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1793
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ãƒ—ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚¸ãƒ§ãƒ–ã‚’é€ã‚Šè¾¼ã‚ã‚‹ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ—ãƒ¼ãƒ«ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚„ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®ã‚ã‚‹éåŒæœŸã®å®Ÿè¡Œã‚’ã‚µãƒãƒ¼ãƒˆã—ã€ä¸¦åˆ— map å®Ÿè£…ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1797
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`cpu_count` is used.  If "
"*initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr "*processes* ã¯ä½¿ç”¨ã™ã‚‹ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã®æ•°ã§ã™ã€‚ *processes* ãŒ ``None`` ã®å ´åˆ :func:`cpu_count` ãŒè¿”ã™æ•°ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ *initializer* ãŒ ``None`` ã§ãªã„å ´åˆã€å„ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒé–‹å§‹æ™‚ã« ``initializer(*initargs)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1802
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr "ãƒ—ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãã®ãƒ—ãƒ¼ãƒ«ã‚’ä½œæˆã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã®ã¿ãŒå‘¼ã³å‡ºã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1805
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is ``None``, "
"which means worker processes will live as long as the pool."
msgstr "*maxtasksperchild* ã¯ã€ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒ exit ã—ã¦æ–°ãŸãªãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã¨ç½®ãæ›¿ãˆã‚‰ã‚Œã‚‹ã¾ã§ã®é–“ã«ã€ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Œäº†ã™ã‚‹ã“ã¨ã®ã§ãã‚‹ã‚¿ã‚¹ã‚¯ã®æ•°ã§ã™ã€‚ã“ã®è¨­å®šã«ã‚ˆã‚Šæœªåˆ©ç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ãŒè§£æ”¾ã•ã‚Œã‚‹ã‚ˆã†ãªã‚Šã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® *maxtasksperchild* ã¯ ``None`` ã§ã€ã“ã‚Œã¯ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ—ãƒ¼ãƒ«ã¨åŒã˜æœŸé–“ã ã‘ç”Ÿãç¶šã‘ã‚‹ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1813
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems"
" (such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old"
" one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ":class:`Pool` ä¸­ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€å…¸å‹çš„ã«ã¯ãƒ—ãƒ¼ãƒ«ã®ãƒ¯ãƒ¼ã‚¯ã‚­ãƒ¥ãƒ¼ã®å­˜ç¶šæœŸé–“ã¨ã¡ã‚‡ã†ã©åŒã˜ã ã‘ç”Ÿãç¶šã‘ã¾ã™ã€‚ãƒ¯ãƒ¼ã‚«ãƒ¼ã«ç¢ºä¿ã•ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ã‚’è§£æ”¾ã™ã‚‹ãŸã‚ã« (Apache, mod_wsgi, ãªã©ã®ã‚ˆã†ãª) ä»–ã®ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆãè¦‹ã‚‰ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ãƒ—ãƒ¼ãƒ«å†…ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒè¨­å®šã•ã‚ŒãŸé‡ã ã‘ã®ä»•äº‹ã‚’å®Œäº†ã—ãŸã‚‰ exit ã¨ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’è¡Œã„ã€å¤ã„ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç½®ãæ›ãˆã‚‹ãŸã‚ã«æ–°ã—ã„ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚ :class:`Pool` ã® *maxtasksperchild* å¼•æ•°ã¯ã€ã“ã®èƒ½åŠ›ã‚’ã‚¨ãƒ³ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«æä¾›ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1823
msgid ""
"Equivalent of the :func:`apply` built-in function.  It blocks until the "
"result is ready, so :meth:`apply_async` is better suited for performing work"
" in parallel. Additionally, *func* is only executed in one of the workers of"
" the pool."
msgstr "çµ„ã¿è¾¼ã¿é–¢æ•° :func:`apply` ã®åŒç­‰å“ã§ã€çµæœãŒå–å¾—å‡ºæ¥ã‚‹ã‚ˆã†ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ã§ã™ã‹ã‚‰ä½œæ¥­ã‚’ä¸¦åˆ—ã«å®Ÿè¡Œã™ã‚‹ã®ã«ã‚ˆã‚Šç›¸å¿œã—ã„ã®ã¯ :meth:`apply_async` ã§ã™ã€‚åŠ ãˆã¦ *func* ã¯ãƒ—ãƒ¼ãƒ«ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã®ã†ã¡ä¸€ã¤ã®ä¸­ã§å®Ÿè¡Œã•ã‚Œã‚‹ã«éãã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1830
msgid "A variant of the :meth:`apply` method which returns a result object."
msgstr ":meth:`apply` ãƒ¡ã‚½ãƒƒãƒ‰ã®æ´¾ç”Ÿç‰ˆã§çµæœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1832
#: ../../library/multiprocessing.rst:1850
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it "
"(unless the call failed).  *callback* should complete immediately since "
"otherwise the thread which handles the results will get blocked."
msgstr "*callback* ã‚’æŒ‡å®šã™ã‚‹å ´åˆã¯ 1 ã¤ã®å¼•æ•°ã‚’å—ã‘å–ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã®çµæœã‚’è¿”ã›ã‚‹ã‚ˆã†ã«ãªã£ãŸã¨ãã« *callback* ãŒçµæœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ (ãã®å‘¼ã³å‡ºã—ãŒå¤±æ•—ã—ãªã„é™ã‚Š)é©ç”¨ã•ã‚Œã¾ã™ã€‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ç›´ã¡ã«å®Œäº†ã™ã¹ãã§ã™ã€‚ãªãœãªã‚‰ã€ãã†ã—ãªã‘ã‚Œã°ã€çµæœã‚’æ‰±ã†ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1839
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only"
" one *iterable* argument though).  It blocks until the result is ready."
msgstr ":func:`map` çµ„ã¿è¾¼ã¿é–¢æ•°ã®ä¸¦åˆ—ç‰ˆã§ã™ (*iterable* ãªå¼•æ•°ã‚’1ã¤ã ã‘ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã¨ã„ã†é•ã„ã¯ã‚ã‚Šã¾ã™ãŒ)ã€‚çµæœãŒå‡ºã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1842
msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’ã„ãã¤ã‚‚ã®ãƒãƒ£ãƒ³ã‚¯ã«åˆ†å‰²ã—ã€ãƒ—ãƒ­ã‚»ã‚¹ãƒ—ãƒ¼ãƒ«ã«ãã‚Œãã‚Œç‹¬ç«‹ã—ãŸã‚¿ã‚¹ã‚¯ã¨ã—ã¦é€ã‚Šã¾ã™ã€‚(æ¦‚ç®—ã®) ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚ºã¯ *chunksize* ã‚’æ­£ã®æ•´æ•°ã«è¨­å®šã™ã‚‹ã“ã¨ã§æŒ‡å®šã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1848
msgid "A variant of the :meth:`.map` method which returns a result object."
msgstr ":meth:`.map` ãƒ¡ã‚½ãƒƒãƒ‰ã®æ´¾ç”Ÿç‰ˆã§çµæœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1857
msgid "An equivalent of :func:`itertools.imap`."
msgstr ":func:`itertools.imap` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1859
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr "*chunksize* å¼•æ•°ã¯ :meth:`.map` ãƒ¡ã‚½ãƒƒãƒ‰ã§ä½¿ç”¨ã•ã‚Œã‚‹ã‚‚ã®ã¨åŒã˜ã§ã™ã€‚ å¼•æ•° iterable ãŒã¨ã¦ã‚‚é•·ã„ãªã‚‰ *chunksize* ã«å¤§ããªå€¤ã‚’æŒ‡å®šã—ã¦ä½¿ç”¨ã™ã‚‹æ–¹ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã® ``1`` ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã‚Šã‚‚ã‚¸ãƒ§ãƒ–ã®å®Œäº†ãŒ **ã‹ãªã‚Š** é€Ÿããªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1864
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr "ã¾ãŸ *chunksize* ãŒ ``1`` ã®å ´åˆ :meth:`imap` ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã® :meth:`!next` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ *timeout* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’æŒã¡ã¾ã™ã€‚ ``next(timeout)`` ã¯ã€ãã®çµæœãŒ *timeout* ç§’ä»¥å†…ã«è¿”ã•ã‚Œãªã„ã¨ãã« :exc:`multiprocessing.TimeoutError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1871
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr "ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒè¿”ã™çµæœã®é †ç•ªãŒä»»æ„ã®é †ç•ªã§è‰¯ã„ã¨è¦‹ãªã•ã‚Œã‚‹ã“ã¨ã‚’é™¤ã‘ã° :meth:`imap` ã¨åŒã˜ã§ã™ã€‚ (ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒ1ã¤ã—ã‹ãªã„å ´åˆã®ã¿ \"æ­£ã—ã„\" é †ç•ªã«ãªã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚)"

#: ../../library/multiprocessing.rst:1877
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr "ã“ã‚Œä»¥ä¸Šãƒ—ãƒ¼ãƒ«ã§ã‚¿ã‚¹ã‚¯ãŒå®Ÿè¡Œã•ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ãŒå®Œäº†ã—ãŸå¾Œã§ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1882
msgid ""
"Stops the worker processes immediately without completing outstanding work."
"  When the pool object is garbage collected :meth:`terminate` will be called"
" immediately."
msgstr "å®Ÿè¡Œä¸­ã®å‡¦ç†ã‚’å®Œäº†ã•ã›ãšã«ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’ã™ãã«åœæ­¢ã—ã¾ã™ã€‚ãƒ—ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹ã¨ãã« :meth:`terminate` ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1888
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or "
":meth:`terminate` before using :meth:`join`."
msgstr "ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã™ã‚‹ã®ã‚’å¾…ã¡ã¾ã™ã€‚ :meth:`join` ã‚’ä½¿ç”¨ã™ã‚‹å‰ã« :meth:`close` ã‹ :meth:`terminate` ã‚’å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1894
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and "
":meth:`Pool.map_async`."
msgstr ":meth:`Pool.apply_async` ã‚„ :meth:`Pool.map_async` ã§è¿”ã•ã‚Œã‚‹çµæœã®ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1899
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then "
":exc:`multiprocessing.TimeoutError` is raised.  If the remote call raised an"
" exception then that exception will be reraised by :meth:`get`."
msgstr "çµæœã‚’å—ã‘å–ã£ãŸã¨ãã«è¿”ã—ã¾ã™ã€‚ *timeout* ãŒ ``None`` ã§ã¯ãªãã¦ã€ãã®çµæœãŒ *timeout* ç§’ä»¥å†…ã«å—ã‘å–ã‚Œãªã„å ´åˆ :exc:`multiprocessing.TimeoutError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ãƒªãƒ¢ãƒ¼ãƒˆã®å‘¼ã³å‡ºã—ãŒä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹å ´åˆã€ãã®ä¾‹å¤–ã¯ :meth:`get` ãŒå†ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1906
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr "ãã®çµæœãŒæœ‰åŠ¹ã«ãªã‚‹ã‹ *timeout* ç§’çµŒã¤ã¾ã§å¾…ã¡ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1910
msgid "Return whether the call has completed."
msgstr "ãã®å‘¼ã³å‡ºã—ãŒå®Œäº†ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1914
msgid ""
"Return whether the call completed without raising an exception.  Will raise "
":exc:`AssertionError` if the result is not ready."
msgstr "ãã®å‘¼ã³å‡ºã—ãŒä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹ã“ã¨ãªãå®Œäº†ã—ãŸã‹ã©ã†ã‹ã‚’è¿”ã—ã¾ã™ã€‚ãã®çµæœãŒè¿”ã›ã‚‹çŠ¶æ…‹ã§ãªã„å ´åˆ :exc:`AssertionError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1917
msgid "The following example demonstrates the use of a pool::"
msgstr "æ¬¡ã®ä¾‹ã¯ãƒ—ãƒ¼ãƒ«ã®ä½¿ç”¨ä¾‹ã‚’ç´¹ä»‹ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:1945
msgid "Listeners and Clients"
msgstr "ãƒªã‚¹ãƒŠãƒ¼ã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ"

#: ../../library/multiprocessing.rst:1950
msgid ""
"Usually message passing between processes is done using queues or by using "
":class:`Connection` objects returned by :func:`~multiprocessing.Pipe`."
msgstr ""

#: ../../library/multiprocessing.rst:1953
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes, and also has support for "
"*digest authentication* using the :mod:`hmac` module."
msgstr "ã—ã‹ã— :mod:`multiprocessing.connection` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã•ã‚‰ã«æŸ”è»Ÿãªä»•çµ„ã¿ãŒã‚ã‚Šã¾ã™ã€‚åŸºæœ¬çš„ã«ã¯ã‚½ã‚±ãƒƒãƒˆã‚‚ã—ãã¯ Windows ã®åå‰ä»˜ããƒ‘ã‚¤ãƒ—ã‚’æ‰±ã†é«˜ãƒ¬ãƒ™ãƒ«ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŒ‡å‘ API ã‚’æä¾›ã—ã¦ :mod:`hmac` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦ *ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆèªè¨¼* ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1961
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr "ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã¸é€ä¿¡ã—ã¦å¿œç­”ã‚’å¾…ã¡ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1964
msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`AuthenticationError` is raised."
msgstr "ãã®å¿œç­”ãŒã‚­ãƒ¼ã¨ã—ã¦ *authkey* ã‚’ä½¿ç”¨ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆã¨ä¸€è‡´ã™ã‚‹å ´åˆã€ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã¸æ­“è¿ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° :exc:`AuthenticationError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1970
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ä¿¡ã—ã¦ã€ãã®ã‚­ãƒ¼ã¨ã—ã¦ *authkey* ã‚’ä½¿ç”¨ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆã‚’è¨ˆç®—ã—ã€ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆã‚’é€ã‚Šè¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1973
msgid ""
"If a welcome message is not received, then :exc:`AuthenticationError` is "
"raised."
msgstr "æ­“è¿ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ã‘å–ã‚Œãªã„å ´åˆ :exc:`AuthenticationError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1978
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`Connection`."
msgstr ""

#: ../../library/multiprocessing.rst:1981
msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ç¨®åˆ¥ã¯ *family* å¼•æ•°ã§æ±ºå®šã—ã¾ã™ãŒã€ä¸€èˆ¬çš„ã«ã¯ *address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‹ã‚‰æ¨æ¸¬ã§ãã‚‹ã®ã§ã€ã“ã‚Œã¯æŒ‡å®šã•ã‚Œã¾ã›ã‚“ã€‚ (:ref:`multiprocessing-address-formats` ã‚’å‚ç…§ã—ã¦ãã ã•ã„)"

#: ../../library/multiprocessing.rst:1985
msgid ""
"If *authenticate* is ``True`` or *authkey* is a string then digest "
"authentication is used.  The key used for authentication will be either "
"*authkey* or ``current_process().authkey)`` if *authkey* is ``None``. If "
"authentication fails then :exc:`AuthenticationError` is raised.  See :ref"
":`multiprocessing-auth-keys`."
msgstr "*authenticate* ãŒ ``True`` ã‹ *authkey* ãŒæ–‡å­—åˆ—ã®å ´åˆã€ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆèªè¨¼ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚èªè¨¼ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚­ãƒ¼ã¯ *authkey* ã€åˆã¯ *authkey* ãŒ ``None`` ã®å ´åˆã¯ ``current_process().authkey`` ã®ã©ã¡ã‚‰ã‹ã§ã™ã€‚èªè¨¼ãŒå¤±æ•—ã—ãŸå ´åˆ :exc:`AuthenticationError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ :ref:`multiprocessing-auth-keys` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1993
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ 'å¾…ã¡å—ã‘ã‚‹' æŸç¸›ã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‹ Windows ã®åå‰ä»˜ããƒ‘ã‚¤ãƒ—ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1996
msgid ""
"*address* is the address to be used by the bound socket or named pipe of the"
" listener object."
msgstr "*address* ã¯ãƒªã‚¹ãƒŠãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æŸç¸›ã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‹åå‰ä»˜ããƒ‘ã‚¤ãƒ—ãŒä½¿ç”¨ã™ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2001
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use"
" '127.0.0.1'."
msgstr "'0.0.0.0' ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€Windows ä¸Šã®çµ‚ç‚¹ã¸æ¥ç¶šã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚çµ‚ç‚¹ã¸æ¥ç¶šã—ãŸã„å ´åˆã¯ '127.0.0.1' ã‚’ä½¿ç”¨ã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2005
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr "*family* ã¯ä½¿ç”¨ã™ã‚‹ã‚½ã‚±ãƒƒãƒˆ(åå‰ä»˜ããƒ‘ã‚¤ãƒ—)ã®ç¨®åˆ¥ã§ã™ã€‚ã“ã‚Œã¯ ``'AF_INET'`` (TCP ã‚½ã‚±ãƒƒãƒˆ), ``'AF_UNIX'`` (Unix ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚½ã‚±ãƒƒãƒˆ) ã¾ãŸã¯ ``'AF_PIPE'`` (Windows åå‰ä»˜ããƒ‘ã‚¤ãƒ—) ã¨ã„ã†æ–‡å­—åˆ—ã®ã©ã‚Œã‹1ã¤ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã†ã¡ ``'AF_INET'`` ã®ã¿ãŒåˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã¾ã™ã€‚ *family* ãŒ ``None`` ã®å ´åˆ *address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‹ã‚‰æ¨æ¸¬ã•ã‚ŒãŸã‚‚ã®ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ *address* ã‚‚ ``None`` ã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãŒé¸æŠã•ã‚Œã¾ã™ã€‚è©³ç´°ã¯ :ref:`multiprocessing-address-formats` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ *family* ãŒ ``'AF_UNIX'`` ã§ *address* ãŒ ``None`` ã®å ´åˆ :func:`tempfile.mkstemp` ã‚’ä½¿ç”¨ã—ã¦ä½œæˆã•ã‚ŒãŸãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªä¸€æ™‚ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã‚½ã‚±ãƒƒãƒˆãŒä½œæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2016
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed"
" to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr "ãƒªã‚¹ãƒŠãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚½ã‚±ãƒƒãƒˆã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ã‚½ã‚±ãƒƒãƒˆã«æŸç¸›ã•ã‚Œã‚‹ã¨ãã« *backlog* (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯1ã¤) ãŒã‚½ã‚±ãƒƒãƒˆã® :meth:`~socket.socket.listen` ãƒ¡ã‚½ãƒƒãƒ‰ã«å¯¾ã—ã¦æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2020
msgid ""
"If *authenticate* is ``True`` (``False`` by default) or *authkey* is not "
"``None`` then digest authentication is used."
msgstr "*authenticate* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``False``) ã‹ *authkey* ãŒ ``None`` ã§ã¯ãªã„å ´åˆã€ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆèªè¨¼ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2023
msgid ""
"If *authkey* is a string then it will be used as the authentication key; "
"otherwise it must be ``None``."
msgstr "*authkey* ãŒæ–‡å­—åˆ—ã®å ´åˆã€èªè¨¼ã‚­ãƒ¼ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ãã†ã§ãªã„å ´åˆã¯ ``None`` ã§ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2026
msgid ""
"If *authkey* is ``None`` and *authenticate* is ``True`` then "
"``current_process().authkey`` is used as the authentication key.  If "
"*authkey* is ``None`` and *authenticate* is ``False`` then no authentication"
" is done.  If authentication fails then :exc:`AuthenticationError` is "
"raised.  See :ref:`multiprocessing-auth-keys`."
msgstr "*authkey* ãŒ ``None`` ä¸”ã¤ *authenticate* ãŒ ``True`` ã®å ´åˆ ``current_process().authkey`` ãŒèªè¨¼ã‚­ãƒ¼ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ *authkey* ãŒ ``None`` ä¸”ã¤ *authentication* ãŒ ``False`` ã®å ´åˆã€èªè¨¼ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚ã‚‚ã—èªè¨¼ãŒå¤±æ•—ã—ãŸå ´åˆ :exc:`AuthenticationError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚è©³ç´° :ref:`multiprocessing-auth-keys` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2034
msgid ""
"Accept a connection on the bound socket or named pipe of the listener object"
" and return a :class:`Connection` object. If authentication is attempted and"
" fails, then :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""

#: ../../library/multiprocessing.rst:2041
msgid ""
"Close the bound socket or named pipe of the listener object.  This is called"
" automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr "ãƒªã‚¹ãƒŠãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åå‰ä»˜ããƒ‘ã‚¤ãƒ—ã‹æŸç¸›ã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒªã‚¹ãƒŠãƒ¼ãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹ã¨ãã«è‡ªå‹•çš„ã«å‘¼ã°ã‚Œã¾ã™ã€‚ãã†ã¯è¨€ã£ã¦ã‚‚ã€æ˜ç¤ºçš„ã« close() ã‚’å‘¼ã³å‡ºã™æ–¹ãŒæœ›ã¾ã—ã„ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2045
msgid "Listener objects have the following read-only properties:"
msgstr "ãƒªã‚¹ãƒŠãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ¬¡ã®èª­ã¿å–ã‚Šå°‚ç”¨å±æ€§ã‚’æŒã£ã¦ã„ã¾ã™:"

#: ../../library/multiprocessing.rst:2049
msgid "The address which is being used by the Listener object."
msgstr "ãƒªã‚¹ãƒŠãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½¿ç”¨ä¸­ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2053
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr "æœ€å¾Œã«ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’å—ã‘ä»˜ã‘ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚æœ‰åŠ¹ãªã‚¢ãƒ‰ãƒ¬ã‚¹ãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2057
msgid "The module defines the following exceptions:"
msgstr ""

#: ../../library/multiprocessing.rst:2061
msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "ã™ã¹ã¦ã® :mod:`multiprocessing` ä¾‹å¤–ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2070
msgid "Raised when there is an authentication error."
msgstr "èªè¨¼ã‚¨ãƒ©ãƒ¼ãŒã‚ã£ãŸå ´åˆã«é€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2074
msgid "Raised by methods with a timeout when the timeout expires."
msgstr "ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒéããŸã¨ãã«é€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2077
msgid "**Examples**"
msgstr "**ä¾‹**"

#: ../../library/multiprocessing.rst:2079
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr "æ¬¡ã®ã‚µãƒ¼ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ã¯èªè¨¼ã‚­ãƒ¼ã¨ã—ã¦ ``'secret password'`` ã‚’ä½¿ç”¨ã™ã‚‹ãƒªã‚¹ãƒŠãƒ¼ã‚’ä½œæˆã—ã¾ã™ã€‚ã“ã®ã‚µãƒ¼ãƒãƒ¼ã¯ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’å¾…ã£ã¦ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:2101
msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr "æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚µãƒ¼ãƒãƒ¼ã¸æ¥ç¶šã—ã¦ã€ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:2124
msgid "Address Formats"
msgstr "ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"

#: ../../library/multiprocessing.rst:2126
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr "``'AF_INET'`` ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ ``(hostname, port)`` ã®ã‚¿ãƒ—ãƒ«ã«ãªã‚Šã¾ã™ã€‚ *hostname* ã¯æ–‡å­—åˆ—ã§ *port* ã¯æ•´æ•°ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2129
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr "``'AF_UNIX'`` ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®ãƒ•ã‚¡ã‚¤ãƒ«åã®æ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2135
msgid "An ``'AF_PIPE'`` address is a string of the form"
msgstr "``'AF_PIPE'`` ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ã€æ¬¡ã®å½¢å¼ã‚’æŒã¤æ–‡å­—åˆ—ã§ã™"

#: ../../library/multiprocessing.rst:2133
msgid ""
":samp:`r'\\\\\\\\.\\\\pipe\\\\{PipeName}'`.  To use :func:`Client` to "
"connect to a named pipe on a remote computer called *ServerName* one should "
"use an address of the form "
":samp:`r'\\\\\\\\{ServerName}\\\\pipe\\\\{PipeName}'` instead."
msgstr ":samp:`r'\\\\\\\\.\\\\pipe\\\\{PipeName}'` ã€‚ *ServerName* ã¨ã„ã†åå‰ã®ãƒªãƒ¢ãƒ¼ãƒˆã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ä¸Šã®åå‰ä»˜ããƒ‘ã‚¤ãƒ—ã«æ¥ç¶šã™ã‚‹ãŸã‚ã« :func:`Client` ã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯ã€ä»£ã‚ã‚Šã« :samp:`r'\\\\\\\\{ServerName}\\\\pipe\\\\{PipeName}'` å½¢å¼ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2137
msgid ""
"Note that any string beginning with two backslashes is assumed by default to"
" be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€2ã¤ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§å§‹ã¾ã‚‹æ–‡å­—åˆ—ã¯ ``'AF_UNIX'`` ã‚ˆã‚Šã‚‚ ``'AF_PIPE'`` ã¨ã—ã¦æ¨æ¸¬ã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2144
msgid "Authentication keys"
msgstr "èªè¨¼ã‚­ãƒ¼"

#: ../../library/multiprocessing.rst:2146
msgid ""
"When one uses :meth:`Connection.recv`, the data received is automatically "
"unpickled.  Unfortunately unpickling data from an untrusted source is a "
"security risk.  Therefore :class:`Listener` and :func:`Client` use the "
":mod:`hmac` module to provide digest authentication."
msgstr ""

#: ../../library/multiprocessing.rst:2152
msgid ""
"An authentication key is a string which can be thought of as a password: "
"once a connection is established both ends will demand proof that the other "
"knows the authentication key.  (Demonstrating that both ends are using the "
"same key does **not** involve sending the key over the connection.)"
msgstr "èªè¨¼ã‚­ãƒ¼ã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¨ã—ã¦ã¿ãªã•ã‚Œã‚‹æ–‡å­—åˆ—ã§ã™ã€‚ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒç¢ºç«‹ã™ã‚‹ã¨ã€åŒæ–¹ã®çµ‚ç‚¹ã§æ­£ã—ã„æ¥ç¶šå…ˆã§ã‚ã‚‹ã“ã¨ã‚’è¨¼æ˜ã™ã‚‹ãŸã‚ã«çŸ¥ã£ã¦ã„ã‚‹ãŠäº’ã„ã®èªè¨¼ã‚­ãƒ¼ã‚’è¦æ±‚ã—ã¾ã™ã€‚ (åŒæ–¹ã®çµ‚ç‚¹ãŒåŒã˜ã‚­ãƒ¼ã‚’ä½¿ç”¨ã—ã¦é€šä¿¡ã—ã‚ˆã†ã¨ã—ã¦ã‚‚ã€ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ä¸Šã§ãã®ã‚­ãƒ¼ã‚’é€ä¿¡ã™ã‚‹ã“ã¨ã¯ **ã§ãã¾ã›ã‚“** ã€‚)"

#: ../../library/multiprocessing.rst:2157
msgid ""
"If authentication is requested but no authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see "
":class:`~multiprocessing.Process`).  This value will be automatically "
"inherited by any :class:`~multiprocessing.Process` object that the current "
"process creates. This means that (by default) all processes of a multi-"
"process program will share a single authentication key which can be used "
"when setting up connections between themselves."
msgstr "èªè¨¼ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšèªè¨¼ã‚­ãƒ¼ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆ ``current_process().authkey`` ã®è¿”ã™å€¤ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ (è©³ç´°ã¯ :class:`~multiprocessing.Process` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚) ã“ã®å€¤ã¯ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œæˆã™ã‚‹ :class:`~multiprocessing.Process` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã£ã¦è‡ªå‹•çš„ã«ç¶™æ‰¿ã•ã‚Œã¾ã™ã€‚ ã“ã‚Œã¯(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯)è¤‡æ•°ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å…¨ãƒ—ãƒ­ã‚»ã‚¹ãŒç›¸äº’ã«ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ ç¢ºç«‹ã™ã‚‹ã¨ãã«ä½¿ç”¨ã•ã‚Œã‚‹1ã¤ã®èªè¨¼ã‚­ãƒ¼ã‚’å…±æœ‰ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2165
msgid ""
"Suitable authentication keys can also be generated by using "
":func:`os.urandom`."
msgstr "é©å½“ãªèªè¨¼ã‚­ãƒ¼ã‚’ :func:`os.urandom` ã‚’ä½¿ç”¨ã—ã¦ç”Ÿæˆã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2169
msgid "Logging"
msgstr "ãƒ­ã‚°è¨˜éŒ²"

#: ../../library/multiprocessing.rst:2171
msgid ""
"Some support for logging is available.  Note, however, that the "
":mod:`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get"
" mixed up."
msgstr "ãƒ­ã‚®ãƒ³ã‚°ã®ãŸã‚ã«ã„ãã¤ã‹ã®æ©Ÿèƒ½ãŒåˆ©ç”¨å¯èƒ½ã§ã™ã€‚ã—ã‹ã— :mod:`logging` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€ (ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ç¨®åˆ¥ã«ä¾å­˜ã—ã¦)é•ã†ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã”ã¡ã‚ƒæ··ãœã«ãªã‚‹ã®ã§ã€ãƒ—ãƒ­ã‚»ã‚¹ã®å…±æœ‰ãƒ­ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2178
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr ":mod:`multiprocessing` ãŒä½¿ç”¨ã™ã‚‹ãƒ­ã‚¬ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å¿…è¦ã«å¿œã˜ã¦æ–°ãŸãªãƒ­ã‚¬ãƒ¼ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2181
msgid ""
"When first created the logger has level :data:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr "æœ€åˆã«ä½œæˆã™ã‚‹ã¨ãã€ãƒ­ã‚¬ãƒ¼ã¯ãƒ¬ãƒ™ãƒ«ã« :data:`logging.NOTSET` ãŒè¨­å®šã•ã‚Œã¦ã„ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ãƒ­ã‚¬ãƒ¼ã¸é€ã‚‰ã‚Œã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ãƒ«ãƒ¼ãƒˆãƒ­ã‚¬ãƒ¼ã¸ä¼æ’­ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2185
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be"
" inherited."
msgstr "Windows ä¸Šã§ã¯å­ãƒ—ãƒ­ã‚»ã‚¹ãŒè¦ªãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ­ã‚¬ãƒ¼ãƒ¬ãƒ™ãƒ«ã‚’ç¶™æ‰¿ã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã•ã‚‰ã«ãã®ä»–ã®ãƒ­ã‚¬ãƒ¼ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå†…å®¹ã‚‚ã™ã¹ã¦ç¶™æ‰¿ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2192
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s]"
" %(message)s'``."
msgstr "ã“ã®é–¢æ•°ã¯ :func:`get_logger` ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã‚’å®Ÿè¡Œã—ã¾ã™ãŒã€ get_logger ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã‚‹ãƒ­ã‚¬ãƒ¼ã‚’è¿”ã™ã“ã¨ã«åŠ ãˆã¦ã€ ``'[%(levelname)s/%(processName)s] %(message)s'`` ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ä½¿ç”¨ã—ã¦ :data:`sys.stderr` ã¸å‡ºåŠ›ã‚’é€ã‚‹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2197
msgid "Below is an example session with logging turned on::"
msgstr "ä»¥ä¸‹ã«ãƒ­ã‚®ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«ã—ãŸä¾‹ã‚’ç´¹ä»‹ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:2212
msgid ""
"In addition to having these two logging functions, the multiprocessing also "
"exposes two additional logging level attributes. These are  "
":const:`SUBWARNING` and :const:`SUBDEBUG`. The table below illustrates where"
" theses fit in the normal level hierarchy."
msgstr "ã“ã‚Œã‚‰ã®2ã¤ã®ãƒ­ã‚®ãƒ³ã‚°é–¢æ•°ãŒã‚ã‚‹ã“ã¨ã«åŠ ãˆã¦ã€ multiprocessing ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚2ã¤ã®è¿½åŠ ãƒ­ã‚®ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«å±æ€§ã‚’æä¾›ã—ã¾ã™ã€‚ãã‚Œã¯ :const:`SUBWARNING` ã¨ :const:`SUBDEBUG` ã§ã™ã€‚æ¬¡ã®è¡¨ã¯é€šå¸¸ã®ãƒ¬ãƒ™ãƒ«éšå±¤ã«ã†ã¾ãé©åˆã—ã¦ã„ã‚‹ã“ã¨ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2218
msgid "Level"
msgstr "ãƒ¬ãƒ™ãƒ«"

#: ../../library/multiprocessing.rst:2218
msgid "Numeric value"
msgstr "Numeric value"

#: ../../library/multiprocessing.rst:2220
msgid "``SUBWARNING``"
msgstr "``SUBWARNING``"

#: ../../library/multiprocessing.rst:2220
msgid "25"
msgstr "25"

#: ../../library/multiprocessing.rst:2222
msgid "``SUBDEBUG``"
msgstr "``SUBDEBUG``"

#: ../../library/multiprocessing.rst:2222
msgid "5"
msgstr "5"

#: ../../library/multiprocessing.rst:2225
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr "å®Œå…¨ãªãƒ­ã‚®ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«ã®è¡¨ã«ã¤ã„ã¦ã¯ :mod:`logging` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2227
msgid ""
"These additional logging levels are used primarily for certain debug "
"messages within the multiprocessing module. Below is the same example as "
"above, except with :const:`SUBDEBUG` enabled::"
msgstr "ã“ã†ã„ã£ãŸè¿½åŠ ã®ãƒ­ã‚®ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«ã¯ä¸»ã« multiprocessing ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¿¡é ¼ã§ãã‚‹ãƒ‡ãƒãƒƒã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ä»¥ä¸‹ã«ä¸Šè¿°ã®ä¾‹ã« :const:`SUBDEBUG` ã‚’æœ‰åŠ¹ã«ã—ãŸã‚‚ã®ã‚’ç´¹ä»‹ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:2251
msgid "The :mod:`multiprocessing.dummy` module"
msgstr ":mod:`multiprocessing.dummy` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/multiprocessing.rst:2256
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ":mod:`multiprocessing.dummy` ã¯ :mod:`multiprocessing` ã® API ã‚’è¤‡è£½ã—ã¾ã™ãŒ :mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã§ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2263
msgid "Programming guidelines"
msgstr "ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³"

#: ../../library/multiprocessing.rst:2265
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ":mod:`multiprocessing` ã‚’ä½¿ç”¨ã™ã‚‹ã¨ãã«å®ˆã‚‹ã¹ãä¸€å®šã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã¨ã‚¤ãƒ‡ã‚£ã‚ªãƒ ã‚’æŒ™ã’ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2270
msgid "All platforms"
msgstr "å…¨ã¦ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ›ãƒ¼ãƒ "

#: ../../library/multiprocessing.rst:2272
msgid "Avoid shared state"
msgstr "å…±æœ‰çŠ¶æ…‹ã‚’é¿ã‘ã‚‹"

#: ../../library/multiprocessing.rst:2274
msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr "ã§ãã‚‹ã ã‘ãƒ—ãƒ­ã‚»ã‚¹é–“ã§å·¨å¤§ãªãƒ‡ãƒ¼ã‚¿ã‚’ç§»å‹•ã™ã‚‹ã“ã¨ã¯é¿ã‘ã‚‹ã‚ˆã†ã«ã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2277
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives from the :mod:`threading` module."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹é–“ã®é€šä¿¡ã«ã¯ã€ :mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½ãƒ¬ãƒ™ãƒ«ãªåŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’ä½¿ã†ã®ã§ã¯ãªãã€ã‚­ãƒ¥ãƒ¼ã‚„ãƒ‘ã‚¤ãƒ—ã‚’ä½¿ã†ã®ãŒè‰¯ã„ã§ã—ã‚‡ã†ã€‚"

#: ../../library/multiprocessing.rst:2281
msgid "Picklability"
msgstr "pickle åŒ–ã®å¯èƒ½æ€§"

#: ../../library/multiprocessing.rst:2283
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¸ã®å¼•æ•°ã¯ã€ pickle åŒ–ã§ãã‚‹ã‚‚ã®ã«ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2285
msgid "Thread safety of proxies"
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•æ€§"

#: ../../library/multiprocessing.rst:2287
msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr "1 ã¤ã®ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒ­ãƒƒã‚¯ã§ä¿è­·ã—ãªã„ã‹ãã‚Šã€2 ã¤ä»¥ä¸Šã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ä½¿ç”¨ã—ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2290
msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr "(ç•°ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã§ *åŒã˜* ãƒ—ãƒ­ã‚­ã‚·ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯å•é¡Œã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚)"

#: ../../library/multiprocessing.rst:2292
msgid "Joining zombie processes"
msgstr "ã‚¾ãƒ³ãƒ“ãƒ—ãƒ­ã‚»ã‚¹ã‚’ join ã™ã‚‹"

#: ../../library/multiprocessing.rst:2294
msgid ""
"On Unix when a process finishes but has not been joined it becomes a zombie."
" There should never be very many because each time a new process starts (or "
":func:`~multiprocessing.active_children` is called) all completed processes "
"which have not yet been joined will be joined.  Also calling a finished "
"process's :meth:`Process.is_alive <multiprocessing.Process.is_alive>` will "
"join the process.  Even so it is probably good practice to explicitly join "
"all the processes that you start."
msgstr "Unix ä¸Šã§ã¯ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã—ãŸã¨ãã« join ã—ãªã„ã¨ã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ã‚¾ãƒ³ãƒ“ã«ãªã‚Šã¾ã™ã€‚æ–°ãŸãªãƒ—ãƒ­ã‚»ã‚¹ãŒé–‹å§‹ã™ã‚‹ (ã¾ãŸã¯ :func:`~multiprocessing.active_children` ãŒå‘¼ã°ã‚Œã‚‹) ã¨ãã«ã€join ã•ã‚Œã¦ã„ãªã„ã™ã¹ã¦ã®å®Œäº†ãƒ—ãƒ­ã‚»ã‚¹ãŒ join ã•ã‚Œã‚‹ã®ã§ã€ã‚ã¾ã‚Šå¤šãã«ã¯ãªã‚‰ãªã„ã§ã—ã‚‡ã†ã€‚ã¾ãŸã€çµ‚äº†ã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã® :meth:`Process.is_alive <multiprocessing.Process.is_alive>` ã¯ãã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ join ã—ã¾ã™ã€‚ãã†ã¯è¨€ã£ã¦ã‚‚ã€è‡ªåˆ†ã§é–‹å§‹ã—ãŸã™ã¹ã¦ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ˜ç¤ºçš„ã« join ã™ã‚‹ã“ã¨ã¯ãŠãã‚‰ãè‰¯ã„ãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2302
msgid "Better to inherit than pickle/unpickle"
msgstr "pickle/unpickle ã‚ˆã‚Šç¶™æ‰¿ã™ã‚‹æ–¹ãŒè‰¯ã„"

#: ../../library/multiprocessing.rst:2304
msgid ""
"On Windows many types from :mod:`multiprocessing` need to be picklable so "
"that child processes can use them.  However, one should generally avoid "
"sending shared objects to other processes using pipes or queues.  Instead "
"you should arrange the program so that a process which needs access to a "
"shared resource created elsewhere can inherit it from an ancestor process."
msgstr "Windows ä¸Šã§ã¯ :mod:`multiprocessing` ã®å¤šãã®å‹ã¯å­ãƒ—ãƒ­ã‚»ã‚¹ãŒä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ pickle åŒ–ã§ããªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ãƒ‘ã‚¤ãƒ—ã‚„ã‚­ãƒ¥ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã¸å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é€ã‚‹ã“ã¨ã¯ä¸€èˆ¬çš„ã«é¿ã‘ã‚‹ã¹ãã§ã™ã€‚ãã®ä»£ã‚ã‚Šã€ã©ã“ã‹ã§ä½œæˆã•ã‚ŒãŸå…±æœ‰ãƒªã‚½ãƒ¼ã‚¹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒå¿…è¦ãªãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ç¥–å…ˆã®ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ãã‚Œã‚’ç¶™æ‰¿ã™ã‚‹ã‚ˆã†ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å¤‰æ›´ã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2310
msgid "Avoid terminating processes"
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ã®å¼·åˆ¶çµ‚äº†ã‚’é¿ã‘ã‚‹"

#: ../../library/multiprocessing.rst:2312
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr "ã‚ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‚’åœæ­¢ã™ã‚‹ãŸã‚ã« :meth:`Process.terminate <multiprocessing.Process.terminate>` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ãŒç¾åœ¨ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ (ãƒ­ãƒƒã‚¯ã€ã‚»ãƒãƒ•ã‚©ã€ãƒ‘ã‚¤ãƒ—ã‚„ã‚­ãƒ¥ãƒ¼ã®ã‚ˆã†ãª) å…±æœ‰ãƒªã‚½ãƒ¼ã‚¹ã‚’ç ´å£Šã—ãŸã‚Šä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰åˆ©ç”¨ã§ããªã„çŠ¶æ…‹ã‚’å¼•ãèµ·ã“ã—æ˜“ã„ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2318
msgid ""
"Therefore it is probably best to only consider using "
":meth:`Process.terminate <multiprocessing.Process.terminate>` on processes "
"which never use any shared resources."
msgstr "ãã®ãŸã‚ã€å…±æœ‰ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½¿ç”¨ã—ãªã„ãƒ—ãƒ­ã‚»ã‚¹ã§ã®ã¿ :meth:`Process.terminate <multiprocessing.Process.terminate>` ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’è€ƒæ…®ã™ã‚‹ã“ã¨ãŒãŠãã‚‰ãæœ€å–„ã®æ–¹æ³•ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2322
msgid "Joining processes that use queues"
msgstr "ã‚­ãƒ¥ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‚’ join ã™ã‚‹"

#: ../../library/multiprocessing.rst:2324
msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to"
" the underlying pipe.  (The child process can call the "
":meth:`~multiprocessing.Queue.cancel_join_thread` method of the queue to "
"avoid this behaviour.)"
msgstr "ã‚­ãƒ¥ãƒ¼ã«è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€å…¨ã¦ã®ãƒãƒƒãƒ•ã‚¡ã•ã‚ŒãŸè¦ç´ ãŒ \"feeder\" ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚ˆã£ã¦ä¸‹ä½å±¤ã®ãƒ‘ã‚¤ãƒ—ã«å¯¾ã—ã¦ãƒ•ã‚£ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã¾ã§çµ‚äº†ã‚’å¾…ã¤ã¨ã„ã†ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚ (å­ãƒ—ãƒ­ã‚»ã‚¹ã¯ã“ã®å‹•ä½œã‚’é¿ã‘ã‚‹ãŸã‚ã«ã‚­ãƒ¥ãƒ¼ã® :meth:`~multiprocessing.Queue.cancel_join_thread` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã¶ã“ã¨ãŒã§ãã¾ã™ã€‚)"

#: ../../library/multiprocessing.rst:2329
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the"
" process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr "ã“ã‚Œã¯ã‚­ãƒ¥ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ã¨ãã«ã€ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚ŒãŸã™ã¹ã¦ã®è¦ç´ ãŒæœ€çµ‚çš„ã«ãã®ãƒ—ãƒ­ã‚»ã‚¹ãŒ join ã•ã‚Œã‚‹å‰ã«å‰Šé™¤ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ãã†ã—ãªã„ã¨ã€ãã®ã‚­ãƒ¥ãƒ¼ã«è¦ç´ ãŒè¿½åŠ ã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã®çµ‚äº†ã‚’ä¿è¨¼ã§ãã¾ã›ã‚“ã€‚ãƒ‡ãƒ¼ãƒ¢ãƒ³ã§ã¯ãªã„ãƒ—ãƒ­ã‚»ã‚¹ã¯è‡ªå‹•çš„ã« join ã•ã‚Œã‚‹ã“ã¨ã‚‚è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2335
msgid "An example which will deadlock is the following::"
msgstr "æ¬¡ã®ä¾‹ã¯ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’å¼•ãèµ·ã“ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:2349
msgid ""
"A fix here would be to swap the last two lines (or simply remove the "
"``p.join()`` line)."
msgstr "ä¿®æ­£ã™ã‚‹ã«ã¯æœ€å¾Œã®2è¡Œã‚’å…¥ã‚Œæ›¿ãˆã¾ã™(ã¾ãŸã¯å˜ç´”ã« ``p.join()`` ã®è¡Œã‚’å‰Šé™¤ã—ã¾ã™)ã€‚"

#: ../../library/multiprocessing.rst:2352
msgid "Explicitly pass resources to child processes"
msgstr "æ˜ç¤ºçš„ã«å­ãƒ—ãƒ­ã‚»ã‚¹ã¸ãƒªã‚½ãƒ¼ã‚¹ã‚’æ¸¡ã™"

#: ../../library/multiprocessing.rst:2354
msgid ""
"On Unix a child process can make use of a shared resource created in a "
"parent process using a global resource.  However, it is better to pass the "
"object as an argument to the constructor for the child process."
msgstr "Unix ä¸Šã§ã¯å­ãƒ—ãƒ­ã‚»ã‚¹ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªãƒªã‚½ãƒ¼ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹è¦ªãƒ—ãƒ­ã‚»ã‚¹ãŒä½œæˆã—ãŸå…±æœ‰ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã—ã‹ã—ã€å¼•æ•°ã¨ã—ã¦ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å­ãƒ—ãƒ­ã‚»ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¸æ¸¡ã™æ–¹ãŒè‰¯ã„ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2358
msgid ""
"Apart from making the code (potentially) compatible with Windows this also "
"ensures that as long as the child process is still alive the object will not"
" be garbage collected in the parent process.  This might be important if "
"some resource is freed when the object is garbage collected in the parent "
"process."
msgstr "ã“ã‚Œã«ã‚ˆã‚Šã€ã‚³ãƒ¼ãƒ‰ãŒ (æ½œåœ¨çš„ã«) Windows äº’æ›ã«ãªã‚‹ã ã‘ã§ãªãã€å­ãƒ—ãƒ­ã‚»ã‚¹ãŒç”Ÿãç¶šã‘ã‚‹é™ã‚Šã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è¦ªãƒ—ãƒ­ã‚»ã‚¹ã§ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œãªã„ã“ã¨ã‚‚ä¿è¨¼ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯è¦ªãƒ—ãƒ­ã‚»ã‚¹ã§ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹ã¨ãã«ãƒªã‚½ãƒ¼ã‚¹ãŒè§£æ”¾ã•ã‚Œã‚‹å ´åˆã«é‡è¦ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/multiprocessing.rst:2364
msgid "So for instance ::"
msgstr "ãã®ãŸã‚ã€ä¾‹ãˆã° ::"

#: ../../library/multiprocessing.rst:2376
msgid "should be rewritten as ::"
msgstr "ã¯ã€æ¬¡ã®ã‚ˆã†ã«æ›¸ãç›´ã™ã¹ãã§ã™ ::"

#: ../../library/multiprocessing.rst:2388
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr ":data:`sys.stdin` ã‚’ file-like ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ç½®ãæ›ãˆã‚‹ã“ã¨ã«æ³¨æ„ã™ã‚‹"

#: ../../library/multiprocessing.rst:2390
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ":mod:`multiprocessing` ã¯å…ƒã€…ç„¡æ¡ä»¶ã«::"

#: ../../library/multiprocessing.rst:2394
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr "ã‚’ :meth:`multiprocessing.Process._bootstrap` ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸­ã§å‘¼ã³å‡ºã—ã¦ã„ã¾ã—ãŸ --- ã“ã‚Œã¯ãƒ—ãƒ­ã‚»ã‚¹å†…ãƒ—ãƒ­ã‚»ã‚¹ (processes-in-processes) ã§å•é¡ŒãŒèµ·ã“ã—ã¦ã—ã¾ã„ã¾ã™ã€‚ãã“ã§ã€ã“ã‚Œã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å¤‰æ›´ã•ã‚Œã¾ã—ãŸ::"

#: ../../library/multiprocessing.rst:2400
msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call "
":meth:`~io.IOBase.close()` on this file-like object, it could result in the "
"same data being flushed to the object multiple times, resulting in "
"corruption."
msgstr "ã“ã‚Œã«ã‚ˆã£ã¦ãƒ—ãƒ­ã‚»ã‚¹åŒå£«ãŒè¡çªã—ã¦ bad file descripter ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã™ã¨ã„ã†æ ¹æœ¬çš„ãªå•é¡Œã¯è§£æ±ºã—ã¾ã—ãŸãŒã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚’ :func:`sys.stdin` ã‹ã‚‰ \"file-like ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ\" ã«ç½®ãæ›ãˆã‚‹ã¨ã„ã†æ½œåœ¨çš„å±é™ºã‚’æŒã¡è¾¼ã‚“ã§ã—ã¾ã„ã¾ã—ãŸã€‚å±é™ºã¨ã„ã†ã®ã¯ã€è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒ file-like ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`~io.IOBase.close()` ã‚’å‘¼ã³å‡ºã™ã¨ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åŒã˜ãƒ‡ãƒ¼ã‚¿ãŒä½•åº¦ã‚‚ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã•ã‚Œã€ç ´æã—ã¦ã—ã¾ã†å¯èƒ½æ€§ãŒã‚ã‚‹ã€ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2407
msgid ""
"If you write a file-like object and implement your own caching, you can make"
" it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr "ã‚‚ã— file-like ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ›¸ã„ã¦ç‹¬è‡ªã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å®Ÿè£…ã™ã‚‹ãªã‚‰ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ã¨ãã«å¸¸ã« pid ã‚’è¨˜éŒ²ã—ã¦ãŠãã€pid ãŒå¤‰ã‚ã£ãŸã‚‰ã‚­ãƒ¥ãƒƒã‚·ãƒ¥ã‚’æ¨ã¦ã‚‹ã“ã¨ã§ã€ãƒ•ã‚©ãƒ¼ã‚¯ã‚»ãƒ¼ãƒ•ã«ã§ãã¾ã™ã€‚ä¾‹::"

#: ../../library/multiprocessing.rst:2419
msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr "ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã¯ :issue:`5155` ã€ :issue:`5313` ã€ :issue:`5331` ã‚’è¦‹ã¦ãã ã•ã„"

#: ../../library/multiprocessing.rst:2422
msgid "Windows"
msgstr "Windows"

#: ../../library/multiprocessing.rst:2424
msgid "Since Windows lacks :func:`os.fork` it has a few extra restrictions:"
msgstr "Windows ã«ã¯ :func:`os.fork` ãŒãªã„ã®ã§ã„ãã¤ã‹è¿½åŠ åˆ¶é™ãŒã‚ã‚Šã¾ã™:"

#: ../../library/multiprocessing.rst:2426
msgid "More picklability"
msgstr "ã•ã‚‰ãªã‚‹ pickle åŒ–ã®å¯èƒ½æ€§"

#: ../../library/multiprocessing.rst:2428
msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable.  This "
"means, in particular, that bound or unbound methods cannot be used directly "
"as the ``target`` argument on Windows --- just define a function and use "
"that instead."
msgstr ":meth:`Process.__init__` ã¸æ¸¡ã™å…¨ã¦ã®å¼•æ•°ã¯ã€pickleåŒ–ã§ãã‚‹ã‚‚ã®ã«ã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã¯ã¨ã‚Šã‚ã‘ã€Windows ä¸Šã§ã€æŸç¸›ãƒ¡ã‚½ãƒƒãƒ‰ã‚„éæŸç¸›ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç›´æ¥ ``target`` å¼•æ•°ã¨ã—ã¦ä½¿ã£ã¦ã¯ãªã‚‰ãªã„ã€ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ãªãã€é–¢æ•°ã‚’ä½¿ã†ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2433
msgid ""
"Also, if you subclass :class:`~multiprocessing.Process` then make sure that "
"instances will be picklable when the :meth:`Process.start "
"<multiprocessing.Process.start>` method is called."
msgstr "ã¾ãŸ :class:`~multiprocessing.Process` ã‚’ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã™ã‚‹å ´åˆã€ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ :meth:`Process.start <multiprocessing.Process.start>` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚ŒãŸã¨ãã« pickle åŒ–ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2437
msgid "Global variables"
msgstr "ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°"

#: ../../library/multiprocessing.rst:2439
msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start "
"<multiprocessing.Process.start>` was called."
msgstr "å­ãƒ—ãƒ­ã‚»ã‚¹ã§å®Ÿè¡Œã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ãŒã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã‚ˆã†ã¨ã™ã‚‹å ´åˆã€å­ãƒ—ãƒ­ã‚»ã‚¹ãŒè¦‹ã‚‹ãã®å€¤ã¯ :meth:`Process.start <multiprocessing.Process.start>` ãŒå‘¼ã°ã‚ŒãŸã¨ãã®è¦ªãƒ—ãƒ­ã‚»ã‚¹ã®å€¤ã¨åŒã˜ã§ã¯ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2444
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr "ã—ã‹ã—ã€å˜ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®å®šæ•°ã§ã‚ã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãªã‚‰å•é¡Œã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2447
msgid "Safe importing of main module"
msgstr "ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å®‰å…¨ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆ"

#: ../../library/multiprocessing.rst:2449
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such a starting a new "
"process)."
msgstr "æ–°ãŸãª Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã‚‹ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒã€æ„å›³ã—ãªã„å‰¯ä½œç”¨ (æ–°ãŸãªãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã™ã‚‹ç­‰) ã‚’èµ·ã“ã•ãšã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2453
msgid ""
"For example, under Windows running the following module would fail with a "
":exc:`RuntimeError`::"
msgstr "ä¾‹ãˆã° Windows ã§æ¬¡ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å®Ÿè¡Œã—ã‚ˆã†ã¨ã™ã‚‹ã¨ :exc:`RuntimeError` ã§å¤±æ•—ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:2464
msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr "ä»£ã‚ã‚Šã«ã€æ¬¡ã®ã‚ˆã†ã« ``if __name__ == '__main__':`` ã‚’ä½¿ç”¨ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã® \"ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆ\" ã‚’ä¿è­·ã™ã¹ãã§ã™::"

#: ../../library/multiprocessing.rst:2477
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr "(``freeze_support()`` è¡Œã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå›ºã¾ã‚‰ãšã«é€šå¸¸ã©ãŠã‚Šå®Ÿè¡Œã•ã‚Œã‚‹ãªã‚‰å–ã‚Šé™¤ã‘ã¾ã™ã€‚)"

#: ../../library/multiprocessing.rst:2480
msgid ""
"This allows the newly spawned Python interpreter to safely import the module"
" and then run the module's ``foo()`` function."
msgstr "ã“ã‚Œã¯æ–°ãŸã«ç”Ÿæˆã•ã‚ŒãŸ Python ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ãŒãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å®‰å…¨ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``foo()`` é–¢æ•°ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2483
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr "ãƒ—ãƒ¼ãƒ«ã¾ãŸã¯ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä½œæˆã•ã‚Œã‚‹å ´åˆã«ä¼¼ãŸã‚ˆã†ãªåˆ¶é™ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2490
msgid "Examples"
msgstr "ä¾‹"

#: ../../library/multiprocessing.rst:2492
msgid ""
"Demonstration of how to create and use customized managers and proxies:"
msgstr "ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚„ãƒ—ãƒ­ã‚­ã‚·ã®ä½œæˆæ–¹æ³•ã¨ä½¿ç”¨æ–¹æ³•ã‚’ç´¹ä»‹ã—ã¾ã™:"

#: ../../library/multiprocessing.rst:2497
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr ":class:`~multiprocessing.pool.Pool` ã‚’ä½¿ç”¨ã™ã‚‹ä¾‹ã§ã™:"

#: ../../library/multiprocessing.rst:2502
msgid "Synchronization types like locks, conditions and queues:"
msgstr "ãƒ­ãƒƒã‚¯ã€ã‚³ãƒ³ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚„ã‚­ãƒ¥ãƒ¼ã®ã‚ˆã†ãªåŒæœŸã®ä¾‹ã‚’ç´¹ä»‹ã—ã¾ã™:"

#: ../../library/multiprocessing.rst:2507
msgid ""
"An example showing how to use queues to feed tasks to a collection of worker"
" processes and collect the results:"
msgstr "ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«å¯¾ã—ã¦ã‚¿ã‚¹ã‚¯ã‚’ãƒ•ã‚£ãƒ¼ãƒ‰ã—ã¦ãã®çµæœã‚’ã¾ã¨ã‚ã‚‹ã‚­ãƒ¥ãƒ¼ã®ä½¿ã„æ–¹ã®ä¾‹ã‚’ç´¹ä»‹ã—ã¾ã™:"

#: ../../library/multiprocessing.rst:2513
msgid ""
"An example of how a pool of worker processes can each run a "
":class:`SimpleHTTPServer.HttpServer` instance while sharing a single "
"listening socket."
msgstr "ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ—ãƒ¼ãƒ«ãŒ1ã¤ã®ã‚½ã‚±ãƒƒãƒˆã‚’å…±æœ‰ã—ã¦ãã‚Œãã‚Œã® :class:`SimpleHTTPServer.HttpServer` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å®Ÿè¡Œã™ã‚‹æ–¹æ³•ã®ä¾‹ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2520
msgid ""
"Some simple benchmarks comparing :mod:`multiprocessing` with "
":mod:`threading`:"
msgstr ":mod:`multiprocessing` ã¨ :mod:`threading` ã‚’æ¯”è¼ƒã—ãŸç°¡å˜ãªãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã§ã™:"
