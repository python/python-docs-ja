# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-16 13:40+0900\n"
"PO-Revision-Date: 2018-06-29 17:21+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/multiprocessing.rst:2
msgid ":mod:`multiprocessing` --- Process-based parallelism"
msgstr ":mod:`multiprocessing` --- ãƒ—ãƒ­ã‚»ã‚¹ãƒ™ãƒ¼ã‚¹ã®ä¸¦åˆ—å‡¦ç†"

#: ../../library/multiprocessing.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/multiprocessing/`"

#: ../../library/multiprocessing.rst:12
msgid "Introduction"
msgstr "ã¯ã˜ã‚ã«"

#: ../../library/multiprocessing.rst:14
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock` by using subprocesses instead of "
"threads.  Due to this, the :mod:`multiprocessing` module allows the "
"programmer to fully leverage multiple processors on a given machine.  It "
"runs on both Unix and Windows."
msgstr ""
":mod:`multiprocessing` ã¯ã€ :mod:`threading` ã¨ä¼¼ãŸ API "
"ã§è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ã®ç”Ÿæˆã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã™ã€‚ :mod:`multiprocessing` "
"ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€ãƒ­ãƒ¼ã‚«ãƒ«ã¨ãƒªãƒ¢ãƒ¼ãƒˆä¸¡æ–¹ã®ä¸¦è¡Œå‡¦ç†ã‚’æä¾›ã—ã¾ã™ã€‚ã¾ãŸã€ã“ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã®ä»£ã‚ã‚Šã«ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€:term:`ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ­ãƒƒã‚¯"
" <Global Interpreter Lock>` ã®å•é¡Œã‚’é¿ã‘ã‚‹å·¥å¤«ãŒè¡Œã‚ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ã‚ˆã†ãªç‰¹å¾´ãŒã‚ã‚‹ãŸã‚ "
":mod:`multiprocessing` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã†ã“ã¨ã§ã€ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼ãƒã‚·ãƒ³ã®æ€§èƒ½ã‚’æœ€å¤§é™ã«æ´»ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã§ã—ã‚‡ã†ã€‚ãªãŠã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ Unix ã¨ Windows "
"ã®ä¸¡æ–¹ã§å‹•ä½œã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:22
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the "
":class:`~multiprocessing.pool.Pool` object which offers a convenient means "
"of parallelizing the execution of a function across multiple input values, "
"distributing the input data across processes (data parallelism).  The "
"following example demonstrates the common practice of defining such "
"functions in a module so that child processes can successfully import that "
"module.  This basic example of data parallelism using "
":class:`~multiprocessing.pool.Pool`, ::"
msgstr ""
":mod:`multiprocessing` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€:mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ä¼¼ãŸã‚‚ã®ãŒå­˜åœ¨ã—ãªã„ API "
"ã‚‚å°å…¥ã•ã‚Œã¦ã„ã¾ã™ã€‚ãã®æœ€ãŸã‚‹ã‚‚ã®ãŒ :class:`~multiprocessing.pool.Pool` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã“ã‚Œã¯è¤‡æ•°ã®å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã€ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ç¾¤ã«å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†é… (ãƒ‡ãƒ¼ã‚¿ä¸¦åˆ—) "
"ã—ã¦é–¢æ•°ã‚’ä¸¦åˆ—å®Ÿè¡Œã™ã‚‹ã®ã«ä¾¿åˆ©ãªæ‰‹æ®µã‚’æä¾›ã—ã¾ã™ã€‚ä»¥ä¸‹ã®ä¾‹ã§ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§é–¢æ•°ã‚’å®šç¾©ã—ã¦ã€å­ãƒ—ãƒ­ã‚»ã‚¹ãŒãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ­£å¸¸ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ä¸€èˆ¬çš„ãªæ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚"
" :class:`~multiprocessing.pool.Pool` ã‚’ç”¨ã„ãŸãƒ‡ãƒ¼ã‚¿ä¸¦åˆ—ã®åŸºç¤çš„ãªä¾‹ã¯æ¬¡ã®é€šã‚Šã§ã™::"

#: ../../library/multiprocessing.rst:40
msgid "will print to standard output ::"
msgstr "æ¨™æº–å‡ºåŠ›ã«ä»¥ä¸‹ãŒå‡ºåŠ›ã•ã‚Œã¾ã™::"

#: ../../library/multiprocessing.rst:46
msgid "The :class:`Process` class"
msgstr ":class:`Process` ã‚¯ãƒ©ã‚¹"

#: ../../library/multiprocessing.rst:48
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a "
":class:`Process` object and then calling its :meth:`~Process.start` method."
"  :class:`Process` follows the API of :class:`threading.Thread`.  A trivial "
"example of a multiprocess program is ::"
msgstr ""
":mod:`multiprocessing` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ãƒ—ãƒ­ã‚»ã‚¹ã¯ä»¥ä¸‹ã®æ‰‹é †ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã¾ã™ã€‚ã¯ã˜ã‚ã« :class:`Process` "
"ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã€ç¶šã„ã¦ :meth:`~Process.start` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ã“ã® :class:`Process` ã‚¯ãƒ©ã‚¹ã¯ "
":class:`threading.Thread` ã‚¯ãƒ©ã‚¹ã¨åŒæ§˜ã® API "
"ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã¾ãšã¯ã€ç°¡å˜ãªä¾‹ã‚’ã‚‚ã¨ã«ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½¿ç”¨ã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¤ã„ã¦ã¿ã¦ã„ãã¾ã—ã‚‡ã† ::"

#: ../../library/multiprocessing.rst:63
msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr "å®Ÿè¡Œã•ã‚ŒãŸå€‹ã€…ã®ãƒ—ãƒ­ã‚»ã‚¹ ID ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã«æ‹¡å¼µã—ãŸã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™::"

#: ../../library/multiprocessing.rst:84
msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"ãªãœ ``if __name__ == '__main__'`` ã¨ã„ã†è¨˜è¿°ãŒå¿…è¦ã‹ã¯ :ref:`multiprocessing-"
"programming` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:90
msgid "Contexts and start methods"
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨é–‹å§‹æ–¹å¼"

#: ../../library/multiprocessing.rst:94
msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr ""
"ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ã‚‚ã‚ˆã‚Šã¾ã™ãŒã€:mod:`multiprocessing` ã¯ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã™ã‚‹ãŸã‚ã« 3 ã¤ã®æ–¹æ³•ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ãã‚Œã‚‰ "
"*é–‹å§‹æ–¹å¼* ã¯ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã™"

#: ../../library/multiprocessing.rst:105
msgid "*spawn*"
msgstr "*spawn*"

#: ../../library/multiprocessing.rst:98
msgid ""
"The parent process starts a fresh python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"objects :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using *fork*"
" or *forkserver*."
msgstr ""
"è¦ªãƒ—ãƒ­ã‚»ã‚¹ã¯æ–°ãŸã« python ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã—ã¾ã™ã€‚å­ãƒ—ãƒ­ã‚»ã‚¹ã¯ãƒ—ãƒ­ã‚»ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`~Process.run` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè¡Œã«å¿…è¦ãªãƒªã‚½ãƒ¼ã‚¹ã®ã¿ç¶™æ‰¿ã—ã¾ã™ã€‚ç‰¹ã«ã€è¦ªãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ã®ä¸è¦ãªãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã¨ãƒãƒ³ãƒ‰ãƒ«ã¯ç¶™æ‰¿ã•ã‚Œã¾ã›ã‚“ã€‚ã“ã®æ–¹å¼ã‚’ä½¿ç”¨ã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã®é–‹å§‹ã¯ "
"*fork* ã‚„ *forkserver* ã«æ¯”ã¹é…ããªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:105
msgid "Available on Unix and Windows.  The default on Windows."
msgstr "Unix ã¨ Windows ã§åˆ©ç”¨å¯èƒ½ã€‚Windows ã§ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã€‚"

#: ../../library/multiprocessing.rst:114
msgid "*fork*"
msgstr "*fork*"

#: ../../library/multiprocessing.rst:108
msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  The"
" child process, when it begins, is effectively identical to the parent "
"process.  All resources of the parent are inherited by the child process.  "
"Note that safely forking a multithreaded process is problematic."
msgstr ""
"è¦ªãƒ—ãƒ­ã‚»ã‚¹ã¯ :func:`os.fork` ã‚’ä½¿ç”¨ã—ã¦ Python "
"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã‚’ãƒ•ã‚©ãƒ¼ã‚¯ã—ã¾ã™ã€‚å­ãƒ—ãƒ­ã‚»ã‚¹ã¯ãã‚ŒãŒé–‹å§‹ã•ã‚Œã‚‹ã¨ãã€äº‹å®Ÿä¸Šè¦ªãƒ—ãƒ­ã‚»ã‚¹ã¨åŒä¸€ã«ãªã‚Šã¾ã™ã€‚è¦ªãƒ—ãƒ­ã‚»ã‚¹ã®ãƒªã‚½ãƒ¼ã‚¹ã¯ã™ã¹ã¦å­ãƒ—ãƒ­ã‚»ã‚¹ã«ç¶™æ‰¿ã•ã‚Œã¾ã™ã€‚ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ•ã‚©ãƒ¼ã‚¯ã¯å®‰å…¨æ€§ã«å•é¡ŒãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:114
msgid "Available on Unix only.  The default on Unix."
msgstr "Unix ã§ã®ã¿åˆ©ç”¨å¯èƒ½ã€‚Unix ã§ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã€‚"

#: ../../library/multiprocessing.rst:125
msgid "*forkserver*"
msgstr "*forkserver*"

#: ../../library/multiprocessing.rst:117
msgid ""
"When the program starts and selects the *forkserver* start method, a server "
"process is started.  From then on, whenever a new process is needed, the "
"parent process connects to the server and requests that it fork a new "
"process.  The fork server process is single threaded so it is safe for it to"
" use :func:`os.fork`.  No unnecessary resources are inherited."
msgstr ""
"ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’é–‹å§‹ã™ã‚‹ã¨ã *forkserver* "
"æ–¹å¼ã‚’é¸æŠã—ãŸå ´åˆã€ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒé–‹å§‹ã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥é™ã€æ–°ã—ã„ãƒ—ãƒ­ã‚»ã‚¹ãŒå¿…è¦ã«ãªã£ãŸã¨ãã¯ã„ã¤ã§ã‚‚ã€è¦ªãƒ—ãƒ­ã‚»ã‚¹ã¯ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã—ã€æ–°ã—ã„ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ•ã‚©ãƒ¼ã‚¯ã‚’è¦æ±‚ã—ã¾ã™ã€‚ãƒ•ã‚©ãƒ¼ã‚¯ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã¯ã‚·ãƒ³ã‚°ãƒ«ã‚¹ãƒ¬ãƒƒãƒ‰ãªã®ã§"
" :func:`os.fork` ã®ä½¿ç”¨ã«é–¢ã—ã¦ã‚‚å®‰å…¨ã§ã™ã€‚ä¸è¦ãªãƒªã‚½ãƒ¼ã‚¹ã¯ç¶™æ‰¿ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:124
msgid ""
"Available on Unix platforms which support passing file descriptors over Unix"
" pipes."
msgstr "Unix ãƒ‘ã‚¤ãƒ—ã‚’çµŒç”±ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã®å—ã‘æ¸¡ã—ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ Unix ã§åˆ©ç”¨å¯èƒ½ã€‚"

#: ../../library/multiprocessing.rst:127
msgid ""
"*spawn* added on all unix platforms, and *forkserver* added for some unix "
"platforms. Child processes no longer inherit all of the parents inheritable "
"handles on Windows."
msgstr ""
"ã™ã¹ã¦ã® Unix ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ *spawn* ãŒã€ä¸€éƒ¨ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ *forkserver* ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚Windows "
"ã§ã¯è¦ªãƒ—ãƒ­ã‚»ã‚¹ã®ç¶™æ‰¿å¯èƒ½ãªå…¨ãƒãƒ³ãƒ‰ãƒ«ãŒå­ãƒ—ãƒ­ã‚»ã‚¹ã«ç¶™æ‰¿ã•ã‚Œã‚‹ã“ã¨ãŒãªããªã‚Šã¾ã—ãŸã€‚"

#: ../../library/multiprocessing.rst:133
msgid ""
"On Unix using the *spawn* or *forkserver* start methods will also start a "
"*semaphore tracker* process which tracks the unlinked named semaphores "
"created by processes of the program.  When all processes have exited the "
"semaphore tracker unlinks any remaining semaphores. Usually there should be "
"none, but if a process was killed by a signal there may be some \"leaked\" "
"semaphores.  (Unlinking the named semaphores is a serious matter since the "
"system allows only a limited number, and they will not be automatically "
"unlinked until the next reboot.)"
msgstr ""

#: ../../library/multiprocessing.rst:142
msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if "
"__name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"é–‹å§‹æ–¹å¼ã¯ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``if __name__ == '__main__'`` ç¯€å†…ã§ã€é–¢æ•° :func:`set_start_method`"
" ã«ã‚ˆã£ã¦æŒ‡å®šã—ã¾ã™ã€‚ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../library/multiprocessing.rst:159
msgid ""
":func:`set_start_method` should not be used more than once in the program."
msgstr "é–¢æ•° :func:`set_start_method` ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã§è¤‡æ•°å›ä½¿ç”¨ã—ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:162
msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context object.  "
"Context objects have the same API as the multiprocessing module, and allow "
"one to use multiple start methods in the same program. ::"
msgstr ""
"ã‚‚ã†ã²ã¨ã¤ã®æ–¹æ³•ã¨ã—ã¦ã€:func:`get_context` ã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ "
"multiprocessing ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨åŒã˜ API ã‚’æŒã¡ã€åŒã˜ãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã§è¤‡æ•°ã®é–‹å§‹æ–¹å¼ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚ ::"

#: ../../library/multiprocessing.rst:180
msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using the "
"*fork* context cannot be passed to processes started using the *spawn* or "
"*forkserver* start methods."
msgstr ""

#: ../../library/multiprocessing.rst:185
msgid ""
"A library which wants to use a particular start method should probably use "
":func:`get_context` to avoid interfering with the choice of the library "
"user."
msgstr ""
"ç‰¹å®šã®é–‹å§‹æ–¹å¼ã®ä½¿ç”¨ã‚’è¦æ±‚ã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ :func:`get_context` ã‚’ä½¿ç”¨ã—ã¦ãƒ©ã‚¤ãƒ–ãƒ©ãƒªåˆ©ç”¨è€…ã®é¸æŠã‚’é˜»å®³ã—ãªã„ã‚ˆã†ã«ã™ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:191
msgid "Exchanging objects between processes"
msgstr "ãƒ—ãƒ­ã‚»ã‚¹é–“ã§ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆäº¤æ›"

#: ../../library/multiprocessing.rst:193
msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ":mod:`multiprocessing` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ãƒ—ãƒ­ã‚»ã‚¹é–“é€šä¿¡ã®æ‰‹æ®µãŒ2ã¤ç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚ãã‚Œãã‚Œä»¥ä¸‹ã«è©³ç´°ã‚’ç¤ºã—ã¾ã™:"

#: ../../library/multiprocessing.rst:196
msgid "**Queues**"
msgstr "**ã‚­ãƒ¥ãƒ¼ (Queue)**"

#: ../../library/multiprocessing.rst:198
msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr ""
":class:`Queue` ã‚¯ãƒ©ã‚¹ã¯ :class:`queue.Queue` ã‚¯ãƒ©ã‚¹ã¨ã»ã¨ã‚“ã©åŒã˜ã‚ˆã†ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../library/multiprocessing.rst:213
msgid "Queues are thread and process safe."
msgstr "ã‚­ãƒ¥ãƒ¼ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã‚ã‚Šã€ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:215
msgid "**Pipes**"
msgstr "**ãƒ‘ã‚¤ãƒ— (Pipe)**"

#: ../../library/multiprocessing.rst:217
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ""
":func:`Pipe` é–¢æ•°ã¯ãƒ‘ã‚¤ãƒ—ã§ç¹‹ãŒã‚ŒãŸã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒšã‚¢ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯åŒæ–¹å‘æ€§ãƒ‘ã‚¤ãƒ—ã‚’è¿”ã—ã¾ã™ã€‚ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../library/multiprocessing.rst:233
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and "
":meth:`~Connection.recv` methods (among others).  Note that data in a pipe "
"may become corrupted if two processes (or threads) try to read from or write"
" to the *same* end of the pipe at the same time.  Of course there is no risk"
" of corruption from processes using different ends of the pipe at the same "
"time."
msgstr ""
"ãƒ‘ã‚¤ãƒ—ã®ãã‚Œãã‚Œã®ç«¯ã‚’è¡¨ã™2ã¤ã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ :func:`Pipe` é–¢æ•°ã‹ã‚‰è¿”ã•ã‚Œã¾ã™ã€‚å„ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€ "
":meth:`~Connection.send`ã€ :meth:`~Connection.recv`ã€ãã®ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚2ã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ "
"(ã¾ãŸã¯ã‚¹ãƒ¬ãƒƒãƒ‰) ãŒãƒ‘ã‚¤ãƒ—ã® *åŒã˜* "
"ç«¯ã§åŒæ™‚ã«èª­ã¿è¾¼ã¿ã‚„æ›¸ãè¾¼ã¿ã‚’è¡Œã†ã¨ã€ãƒ‘ã‚¤ãƒ—å†…ã®ãƒ‡ãƒ¼ã‚¿ãŒç ´æã—ã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã‚‚ã¡ã‚ã‚“ã€å„ãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ‘ã‚¤ãƒ—ã®åˆ¥ã€…ã®ç«¯ã‚’åŒæ™‚ã«ä½¿ç”¨ã™ã‚‹ãªã‚‰ã°ã€ãƒ‡ãƒ¼ã‚¿ãŒç ´å£Šã•ã‚Œã‚‹å±é™ºæ€§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:243
msgid "Synchronization between processes"
msgstr "ãƒ—ãƒ­ã‚»ã‚¹é–“ã®åŒæœŸ"

#: ../../library/multiprocessing.rst:245
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure"
" that only one process prints to standard output at a time::"
msgstr ""
":mod:`multiprocessing` ã¯ :mod:`threading` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ç­‰ä¾¡ãªåŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’å‚™ãˆã¦ã„ã¾ã™ã€‚ä»¥ä¸‹ã®ä¾‹ã§ã¯ã€ãƒ­ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¦ã€ä¸€åº¦ã«1ã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ã—ã‹æ¨™æº–å‡ºåŠ›ã«æ›¸ãè¾¼ã¾ãªã„ã‚ˆã†ã«ã—ã¦ã„ã¾ã™::"

#: ../../library/multiprocessing.rst:264
msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr "ãƒ­ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ãªã„ã§æ¨™æº–å‡ºåŠ›ã«æ›¸ãè¾¼ã‚“ã å ´åˆã¯ã€å„ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ã®å‡ºåŠ›ãŒã”ã¡ã‚ƒã¾ãœã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:269
msgid "Sharing state between processes"
msgstr "ãƒ—ãƒ­ã‚»ã‚¹é–“ã§ã®çŠ¶æ…‹ã®å…±æœ‰"

#: ../../library/multiprocessing.rst:271
msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when"
" using multiple processes."
msgstr ""
"ã“ã‚Œã¾ã§ã®è©±ã®æµã‚Œã§è§¦ã‚ŒãŸã¨ãŠã‚Šã€ä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’è¡Œã†ã¨ãã«ã¯ã€ã§ãã‚‹ã‹ãã‚ŠçŠ¶æ…‹ã‚’å…±æœ‰ã—ãªã„ã®ãŒå®šçŸ³ã§ã™ã€‚è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã¨ãã¯ç‰¹ã«ãã†ã§ã—ã‚‡ã†ã€‚"

#: ../../library/multiprocessing.rst:275
msgid ""
"However, if you really do need to use some shared data then "
":mod:`multiprocessing` provides a couple of ways of doing so."
msgstr ""
"ã—ã‹ã—ã€ã©ã†ã—ã¦ã‚‚ãƒ—ãƒ­ã‚»ã‚¹é–“ã®ãƒ‡ãƒ¼ã‚¿å…±æœ‰ãŒå¿…è¦ãªå ´åˆã®ãŸã‚ã« :mod:`multiprocessing` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯2ã¤ã®æ–¹æ³•ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:278
msgid "**Shared memory**"
msgstr "**å…±æœ‰ãƒ¡ãƒ¢ãƒª (Shared memory)**"

#: ../../library/multiprocessing.rst:280
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or "
":class:`Array`.  For example, the following code ::"
msgstr ""
"ãƒ‡ãƒ¼ã‚¿ã‚’å…±æœ‰ãƒ¡ãƒ¢ãƒªä¸Šã«ä¿æŒã™ã‚‹ãŸã‚ã« :class:`Value` ã‚¯ãƒ©ã‚¹ã€ã‚‚ã—ãã¯ :class:`Array` "
"ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä»¥ä¸‹ã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ã€ã“ã®æ©Ÿèƒ½ã«ã¤ã„ã¦ã¿ã¦ã„ãã¾ã—ã‚‡ã† ::"

#: ../../library/multiprocessing.rst:301 ../../library/multiprocessing.rst:347
msgid "will print ::"
msgstr "ã“ã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«è¡¨ç¤ºã•ã‚Œã¾ã™ ::"

#: ../../library/multiprocessing.rst:306
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are"
" typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared"
" objects will be process and thread-safe."
msgstr ""
"``num`` ã¨ ``arr`` ã‚’ç”Ÿæˆã™ã‚‹ã¨ãã«ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã€å¼•æ•° ``'d'`` ã¨ ``'i'`` ã¯ :mod:`array` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ˆã‚Šä½¿ç”¨ã•ã‚Œã‚‹ç¨®åˆ¥ã®å‹ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚ã“ã“ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ ``'d'`` ã¯å€ç²¾åº¦æµ®å‹•å°æ•°ã€ ``'i'`` "
"ã¯ç¬¦å·ä»˜æ•´æ•°ã‚’è¡¨ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•ã§ã‚ã‚Šã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:311
msgid ""
"For more flexibility in using shared memory one can use the "
":mod:`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr ""
"å…±æœ‰ãƒ¡ãƒ¢ãƒªã‚’ä½¿ç”¨ã—ã¦ã€ã•ã‚‰ã«æŸ”è»Ÿãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’è¡Œã†ã«ã¯ :mod:`multiprocessing.sharedctypes` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸä»»æ„ã® ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:315
msgid "**Server process**"
msgstr "**ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ (Server process)**"

#: ../../library/multiprocessing.rst:317
msgid ""
"A manager object returned by :func:`Manager` controls a server process which"
" holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ""
":func:`Manager` é–¢æ•°ã«ã‚ˆã‚Šç”Ÿæˆã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç®¡ç†ã—ã¾ã™ã€‚ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ Python "
"ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿æŒã—ã¦ã€ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§ãã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ“ä½œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:321
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, "
":class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, "
":class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, "
":class:`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` and "
":class:`Array`.  For example, ::"
msgstr ""
":func:`Manager` é–¢æ•°ãŒè¿”ã™ãƒãƒãƒ¼ã‚¸ãƒ£ã¯ :class:`list`, :class:`dict`, "
":class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, "
":class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, "
":class:`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value`, "
":class:`Array` ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ ä»¥ä¸‹ã«ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’ç¤ºã—ã¾ã™ã€‚ ::"

#: ../../library/multiprocessing.rst:352
msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr ""
"ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å…±æœ‰ãƒ¡ãƒ¢ãƒªã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚ˆã‚Šã‚‚æŸ”è»Ÿã§ã‚ã‚‹ã¨ã„ãˆã¾ã™ã€‚ãã‚Œã¯ã€ã©ã®ã‚ˆã†ãªå‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚‚ä½¿ãˆã‚‹ã‹ã‚‰ã§ã™ã€‚ã¾ãŸã€1ã¤ã®ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çµŒç”±ã§ä»–ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ä¸Šã®ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚ˆã£ã¦å…±æœ‰ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã—ã‹ã—ã€å…±æœ‰ãƒ¡ãƒ¢ãƒªã‚ˆã‚Šå‹•ä½œãŒé…ã„ã¨ã„ã†æ¬ ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:359
msgid "Using a pool of workers"
msgstr "ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ—ãƒ¼ãƒ«ã‚’ä½¿ç”¨"

#: ../../library/multiprocessing.rst:361
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ""
":class:`~multiprocessing.pool.Pool` "
"ã‚¯ãƒ©ã‚¹ã¯ã€ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’ãƒ—ãƒ¼ãƒ«ã™ã‚‹æ©Ÿèƒ½ã‚’å‚™ãˆã¦ã„ã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã«ã¯ã€ç•°ãªã‚‹æ–¹æ³•ã§ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã¸ã‚¿ã‚¹ã‚¯ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã„ãã¤ã‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:365
msgid "For example::"
msgstr "ä¾‹ãˆã°::"

#: ../../library/multiprocessing.rst:409
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr "ãƒ—ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãã®ãƒ—ãƒ¼ãƒ«ã‚’ä½œæˆã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã®ã¿ãŒå‘¼ã³å‡ºã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:414
msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will not "
"work in the interactive interpreter. For example::"
msgstr ""
"ã“ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å«ã¾ã‚Œã‚‹æ©Ÿèƒ½ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã«ã¯ã€å­ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ ``__main__`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã“ã¨ã«ã¤ã„ã¦ã¯"
" :ref:`multiprocessing-programming` "
"ã§è§¦ã‚Œã¦ã„ã¾ã™ãŒã€ã“ã“ã§ã‚ã‚‰ãŸã‚ã¦å¼·èª¿ã—ã¦ãŠãã¾ã™ã€‚ãªãœã‹ã¨ã„ã†ã¨ã€ã„ãã¤ã‹ã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã€ä¾‹ãˆã° "
":class:`multiprocessing.pool.Pool` ã®ã‚µãƒ³ãƒ—ãƒ«ã¯ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã‚·ã‚§ãƒ«ä¸Šã§ã¯å‹•ä½œã—ãªã„ã‹ã‚‰ã§ã™ã€‚ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../library/multiprocessing.rst:436
msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the master process "
"somehow.)"
msgstr ""
"(ã“ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’è©¦ã™ã¨ã€3ã¤ã®ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯ã™ã¹ã¦ãŒã»ã¼ãƒ©ãƒ³ãƒ€ãƒ ã«äº¤äº’ã«é‡ãªã£ã¦è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ãã†ãªã£ãŸã‚‰ã€ãªã‚“ã¨ã‹ã—ã¦ãƒã‚¹ã‚¿ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ­¢ã‚ã¾ã—ã‚‡ã†ã€‚)"

#: ../../library/multiprocessing.rst:442
msgid "Reference"
msgstr "ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹"

#: ../../library/multiprocessing.rst:444
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the "
":mod:`threading` module."
msgstr ":mod:`multiprocessing` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ :mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® API ã¨ã»ã¨ã‚“ã©åŒã˜ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:449
msgid ":class:`Process` and exceptions"
msgstr ":class:`Process` ã‚¯ãƒ©ã‚¹ã¨ä¾‹å¤–"

#: ../../library/multiprocessing.rst:454
msgid ""
"Process objects represent activity that is run in a separate process. The "
":class:`Process` class has equivalents of all the methods of "
":class:`threading.Thread`."
msgstr ""
"Process ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å„ãƒ—ãƒ­ã‚»ã‚¹ã®å‡¦ç†ã‚’è¡¨ã—ã¾ã™ã€‚ :class:`Process` ã‚¯ãƒ©ã‚¹ã¯ "
":class:`threading.Thread` ã‚¯ãƒ©ã‚¹ã®ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒã˜ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:458
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with "
":class:`threading.Thread`.  *target* is the callable object to be invoked by"
" the :meth:`run()` method.  It defaults to ``None``, meaning nothing is "
"called. *name* is the process name (see :attr:`name` for more details). "
"*args* is the argument tuple for the target invocation.  *kwargs* is a "
"dictionary of keyword arguments for the target invocation.  If provided, the"
" keyword-only *daemon* argument sets the process :attr:`daemon` flag to "
"``True`` or ``False``.  If ``None`` (the default), this flag will be "
"inherited from the creating process."
msgstr ""
"ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã¯å¿…ãšã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã§å‘¼ã³å‡ºã™ã¹ãã§ã™ã€‚å¼•æ•° *group* ã«ã¯å¿…ãš ``None`` ã‚’æ¸¡ã—ã¦ãã ã•ã„ã€‚ ã“ã®å¼•æ•°ã¯ "
":class:`threading.Thread` ã‚¯ãƒ©ã‚¹ã¨ã®äº’æ›æ€§ã®ãŸã‚ã ã‘ã«æ®‹ã•ã‚Œã¦ã„ã¾ã™ã€‚å¼•æ•° *target* ã«ã¯ã€ "
":meth:`run()` ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹ callable ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã—ã¾ã™ã€‚ã“ã®å¼•æ•°ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ ``None`` "
"ã¨ãªã£ã¦ãŠã‚Šã€ä½•ã‚‚å‘¼ã³å‡ºã•ã‚Œã¾ã›ã‚“ã€‚å¼•æ•° *name* ã«ã¯ãƒ—ãƒ­ã‚»ã‚¹åã‚’æ¸¡ã—ã¾ã™ (è©³ç´°ã¯ :attr:`name` ã‚’è¦‹ã¦ãã ã•ã„)ã€‚ *args* "
"ã¯å¯¾è±¡ã®å‘¼ã³å‡ºã—ã«å¯¾ã™ã‚‹å¼•æ•°ã®ã‚¿ãƒ—ãƒ«ã‚’æ¸¡ã—ã¾ã™ã€‚ *kwargs* "
"ã¯å¯¾è±¡ã®å‘¼ã³å‡ºã—ã«å¯¾ã™ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®è¾æ›¸ã‚’æ¸¡ã—ã¾ã™ã€‚ã‚‚ã—æä¾›ã•ã‚Œã‚Œã°ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ã¿ã® *daemon* å¼•æ•°ã¯ãƒ—ãƒ­ã‚»ã‚¹ã® "
":attr:`daemon` ãƒ•ãƒ©ã‚°ã‚’ ``True`` ã¾ãŸã¯ ``False`` ã«ã‚»ãƒƒãƒˆã—ã¾ã™ã€‚ ``None`` ã®å ´åˆ "
"(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)ã€ã“ã®ãƒ•ãƒ©ã‚°ã¯ä½œæˆã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ç¶™æ‰¿ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:469
msgid "By default, no arguments are passed to *target*."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€*target* ã«ã¯å¼•æ•°ãŒæ¸¡ã•ã‚Œãªã„ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:471
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (:meth:`Process.__init__`) before doing anything else"
" to the process."
msgstr ""
"ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹å ´åˆã¯ã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ã«å¯¾ã™ã‚‹å‡¦ç†ã‚’è¡Œã†å‰ã«åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ "
"(:meth:`Process.__init__`) ã‚’å®Ÿè¡Œã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:475
msgid "Added the *daemon* argument."
msgstr "*daemon* å¼•æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/multiprocessing.rst:480
msgid "Method representing the process's activity."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Ÿè¡Œã™ã‚‹å‡¦ç†ã‚’è¡¨ã™ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:482
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method"
" invokes the callable object passed to the object's constructor as the "
"target argument, if any, with sequential and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ¨™æº–ã® :meth:`run` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã® target "
"å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚ŒãŸå‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ã‚‚ã—ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã« *args* ã‚‚ã—ãã¯ *kwargs* "
"å¼•æ•°ãŒæ¸¡ã•ã‚Œã¦ã„ã‚Œã°ã€å‘¼ã³å‡ºã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã“ã‚Œã‚‰ã®å¼•æ•°ã‚’æ¸¡ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:489
msgid "Start the process's activity."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ã®å‡¦ç†ã‚’é–‹å§‹ã™ã‚‹ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:491
msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr ""
"å„ Process ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒ2å›ä»¥ä¸Šå‘¼ã³å‡ºã•ã‚Œã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚å„ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`run` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™æº–å‚™ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:496
msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. If "
"*timeout* is a positive number, it blocks at most *timeout* seconds. Note "
"that the method returns ``None`` if its process terminates or if the method "
"times out.  Check the process's :attr:`exitcode` to determine if it "
"terminated."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *timeout* ãŒ ``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã®å ´åˆã€ :meth:`join` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚ŒãŸãƒ—ãƒ­ã‚»ã‚¹ã¯å‡¦ç†ãŒçµ‚äº†ã™ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚\n"
"*timeout* ãŒæ­£ã®æ•°ã§ã‚ã‚‹å ´åˆã€æœ€å¤§ *timeout* ç§’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚\n"
"ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã‚ã‚‹ã„ã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸå ´åˆã€ãƒ¡ã‚½ãƒƒãƒ‰ã¯ ``None`` ã‚’è¿”ã™ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚\n"
"ãƒ—ãƒ­ã‚»ã‚¹ã® :attr:`exitcode` ã‚’ç¢ºèªã—çµ‚äº†ã—ãŸã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:503
msgid "A process can be joined many times."
msgstr "1ã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ä½•å›ã‚‚ join ã•ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:505
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr ""
"ãƒ—ãƒ­ã‚»ã‚¹ã¯è‡ªåˆ†è‡ªèº«ã‚’ join ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ãã‚Œã¯ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’å¼•ãèµ·ã“ã™ã“ã¨ãŒã‚ã‚‹ã‹ã‚‰ã§ã™ã€‚ãƒ—ãƒ­ã‚»ã‚¹ãŒ start ã•ã‚Œã‚‹å‰ã« join "
"ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:510
msgid ""
"The process's name.  The name is a string used for identification purposes "
"only.  It has no semantics.  Multiple processes may be given the same name."
msgstr ""
"ãƒ—ãƒ­ã‚»ã‚¹ã®åå‰ã€‚åå‰ã¯è­˜åˆ¥ã®ãŸã‚ã ã‘ã«ä½¿ç”¨ã•ã‚Œã‚‹æ–‡å­—åˆ—ã§ã™ã€‚ãã‚Œè‡ªä½“ã«ã¯ç‰¹åˆ¥ãªæ„å‘³ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ã«åŒã˜åå‰ãŒä¸ãˆã‚‰ã‚Œã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:514
msgid ""
"The initial name is set by the constructor.  If no explicit name is provided"
" to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\ "
":sub:`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is the "
"N-th child of its parent."
msgstr ""
"æœ€åˆã®åå‰ã¯ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã«ã‚ˆã£ã¦ã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã«æ˜ç¤ºçš„ãªåå‰ãŒæ¸¡ã•ã‚Œãªã„å ´åˆã€ 'Process-N\\ :sub:`1`:N\\"
" :sub:`2`:...:N\\ :sub:`k`' å½¢å¼ã®åå‰ãŒæ§‹ç¯‰ã•ã‚Œã¾ã™ã€‚ã“ã“ã§ãã‚Œãã‚Œã® N\\ :sub:`k` "
"ã¯ãã®è¦ªã®Nç•ªç›®ã®å­ä¾›ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:521
msgid "Return whether the process is alive."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Ÿè¡Œä¸­ã‹ã‚’åˆ¤åˆ¥ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:523
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr "ãŠãŠã¾ã‹ã«è¨€ã£ã¦ã€ãƒ—ãƒ­ã‚»ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :meth:`start` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ã‹ã‚‰å­ãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†ã¾ã§ã®æœŸé–“ãŒå®Ÿè¡Œä¸­ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:528
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before "
":meth:`start` is called."
msgstr ""
"ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚ã‚‹ã‹ã®ãƒ•ãƒ©ã‚°ã§ã‚ã‚Šã€ãƒ–ãƒ¼ãƒ«å€¤ã§ã™ã€‚ã“ã®å±æ€§ã¯ :meth:`start` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹å‰ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:531
msgid "The initial value is inherited from the creating process."
msgstr "åˆæœŸå€¤ã¯ä½œæˆã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ç¶™æ‰¿ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:533
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr "ã‚ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã™ã‚‹ã¨ãã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ãã®å­ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚ã‚‹ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã™ã¹ã¦ã‚’çµ‚äº†ã•ã›ã‚ˆã†ã¨ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:536
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr ""
"ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã¯å­ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œæˆã§ããªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã‚‚ã—ä½œæˆã§ãã¦ã—ã¾ã†ã¨ã€ãã®ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã®è¦ªãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã—ãŸã¨ãã«ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã®å­ãƒ—ãƒ­ã‚»ã‚¹ãŒå­¤å…ã«ãªã£ã¦ã—ã¾ã†å ´åˆãŒã‚ã‚‹ã‹ã‚‰ã§ã™ã€‚ã•ã‚‰ã«è¨€ãˆã°ã€ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã¯Unix"
" ãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚„ã‚µãƒ¼ãƒ“ã‚¹ã§ã¯ **ãªã** é€šå¸¸ã®ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚ã‚Šã€éãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã™ã‚‹ã¨çµ‚äº†ã•ã‚Œã¾ã™ (ãã—ã¦ join ã•ã‚Œã¾ã›ã‚“)ã€‚"

#: ../../library/multiprocessing.rst:542
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr ""
":class:`threading.Thread` ã‚¯ãƒ©ã‚¹ã® API ã«åŠ ãˆã¦ :class:`Process` "
"ã‚¯ãƒ©ã‚¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ä»¥ä¸‹ã®å±æ€§ãŠã‚ˆã³ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™:"

#: ../../library/multiprocessing.rst:547
msgid ""
"Return the process ID.  Before the process is spawned, this will be "
"``None``."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹IDã‚’è¿”ã—ã¾ã™ã€‚ãƒ—ãƒ­ã‚»ã‚¹ã®ç”Ÿæˆå‰ã¯ ``None`` ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:552
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated.  A negative value *-N* indicates that the child was terminated "
"by signal *N*."
msgstr ""
"å­ãƒ—ãƒ­ã‚»ã‚¹ã®çµ‚äº†ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚å­ãƒ—ãƒ­ã‚»ã‚¹ãŒã¾ã çµ‚äº†ã—ã¦ã„ãªã„å ´åˆã¯ ``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚è² ã®å€¤ *-N* ã¯å­ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚·ã‚°ãƒŠãƒ« *N* "
"ã§çµ‚äº†ã—ãŸã“ã¨ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:558
msgid "The process's authentication key (a byte string)."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ã®èªè¨¼ã‚­ãƒ¼ã§ã™ (ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã§ã™)ã€‚"

#: ../../library/multiprocessing.rst:560
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr ""
":mod:`multiprocessing` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚ˆã‚ŠåˆæœŸåŒ–ã•ã‚Œã‚‹å ´åˆã«ã¯ã€ :func:`os.urandom` "
"é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ãƒ©ãƒ³ãƒ€ãƒ ãªå€¤ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:563
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ""
":class:`Process` ã‚¯ãƒ©ã‚¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆæ™‚ã«ãã®è¦ªãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰èªè¨¼ã‚­ãƒ¼ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚ã‚‚ã—ãã¯ :attr:`authkey` "
"ã«åˆ¥ã®ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:567
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "è©³ç´°ã¯ :ref:`multiprocessing-auth-keys` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:571
msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã™ã‚‹ã¨ãã« \"ready\" ã¨ãªã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ•°å€¤ãƒãƒ³ãƒ‰ãƒ«ã€‚"

#: ../../library/multiprocessing.rst:574
msgid ""
"You can use this value if you want to wait on several events at once using "
":func:`multiprocessing.connection.wait`.  Otherwise calling :meth:`join()` "
"is simpler."
msgstr ""
":func:`multiprocessing.connection.wait` ã‚’ä½¿ç”¨ã—ã¦ã„ãã¤ã‹ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’åŒæ™‚ã« wait "
"ã—ãŸã„å ´åˆã¯ã“ã®å€¤ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ :meth:`join()` ã‚’å‘¼ã¶æ–¹ãŒã‚ˆã‚Šå˜ç´”ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:578
msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` and"
" ``WaitForMultipleObjects`` family of API calls.  On Unix, this is a file "
"descriptor usable with primitives from the :mod:`select` module."
msgstr ""
"Windows ã«ãŠã„ã¦ã¯ã€ã“ã‚Œã¯ ``WaitForSingleObject`` ãŠã‚ˆã³ ``WaitForMultipleObjects`` "
"ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã® API å‘¼ã³å‡ºã—ã§ä½¿ç”¨å¯èƒ½ãª OS ãƒãƒ³ãƒ‰ãƒ«ã§ã™ã€‚ Unix ã«ãŠã„ã¦ã¯ã€ã“ã‚Œã¯ :mod:`select` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã§ä½¿ç”¨å¯èƒ½ãªãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:586
msgid ""
"Terminate the process.  On Unix this is done using the ``SIGTERM`` signal; "
"on Windows :c:func:`TerminateProcess` is used.  Note that exit handlers and "
"finally clauses, etc., will not be executed."
msgstr ""
"ãƒ—ãƒ­ã‚»ã‚¹ã‚’çµ‚äº†ã—ã¾ã™ã€‚Unix ç’°å¢ƒã§ã¯ ``SIGTERM`` ã‚·ã‚°ãƒŠãƒ«ã‚’ã€ Windows ç’°å¢ƒã§ã¯ "
":c:func:`TerminateProcess` ã‚’ä½¿ç”¨ã—ã¦çµ‚äº†ã•ã›ã¾ã™ã€‚çµ‚äº†ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚„ finally "
"ç¯€ãªã©ã¯ã€å®Ÿè¡Œã•ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:590
msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã‚Šçµ‚äº†ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã®å­å­«ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€çµ‚äº† *ã—ã¾ã›ã‚“* ã€‚ãã†ã„ã£ãŸå­å­«ãƒ—ãƒ­ã‚»ã‚¹ã¯å˜ç´”ã«å­¤å…ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:595
msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable"
" by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ä½¿ç”¨æ™‚ã«ã€é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ‘ã‚¤ãƒ—ã‚„ã‚­ãƒ¥ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã«ã¯ã€ä½¿ç”¨ä¸­ã®ãƒ‘ã‚¤ãƒ—ã‚„ã‚­ãƒ¥ãƒ¼ãŒç ´æã—ã¦ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ä½¿ç”¨ã§ããªããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚åŒæ§˜ã«ã€ãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ­ãƒƒã‚¯ã‚„ã‚»ãƒãƒ•ã‚©ãªã©ã‚’å–å¾—ã—ã¦ã„ã‚‹å ´åˆã«ã¯ã€ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã—ã¦ã—ã¾ã†ã¨ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã®åŸå› ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/multiprocessing.rst:601
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, "
":meth:`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr ""
"ãƒ—ãƒ­ã‚»ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã®ã¿ãŒ :meth:`start`, :meth:`join`, :meth:`is_alive`, "
":meth:`terminate` ã¨ :attr:`exitcode` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:605
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr "ä»¥ä¸‹ã®ä¾‹ã§ã¯ :class:`Process` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ä½¿ã„æ–¹ã‚’ç¤ºã—ã¦ã„ã¾ã™:"

#: ../../library/multiprocessing.rst:625
msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "ã™ã¹ã¦ã® :mod:`multiprocessing` ä¾‹å¤–ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:629
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into()` when the supplied "
"buffer object is too small for the message read."
msgstr ""
"ã“ã®ä¾‹å¤–ã¯ :meth:`Connection.recv_bytes_into()` "
"ã«ã‚ˆã£ã¦ç™ºç”Ÿã—ã€ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå°ã•ã™ãã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã‚ãªã„ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:632
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr ""
"``e`` ãŒ :exc:`BufferTooShort` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹ã¨ã™ã‚‹ã¨ã€ ``e.args[0]`` "
"ã¯ãã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã§ä¸ãˆã‚‹ã‚‚ã®ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:637
msgid "Raised when there is an authentication error."
msgstr "èªè¨¼ã‚¨ãƒ©ãƒ¼ãŒã‚ã£ãŸå ´åˆã«é€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:641
msgid "Raised by methods with a timeout when the timeout expires."
msgstr "ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒéããŸã¨ãã«é€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:644
msgid "Pipes and Queues"
msgstr "ãƒ‘ã‚¤ãƒ— (Pipe) ã¨ã‚­ãƒ¥ãƒ¼ (Queue)"

#: ../../library/multiprocessing.rst:646
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization"
" primitives like locks."
msgstr "è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½¿ã†å ´åˆã€ä¸€èˆ¬çš„ã«ã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ‘ãƒƒã‚·ãƒ³ã‚°ã‚’ãƒ—ãƒ­ã‚»ã‚¹é–“é€šä¿¡ã«ä½¿ç”¨ã—ã€ãƒ­ãƒƒã‚¯ã®ã‚ˆã†ãªåŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’ä½¿ç”¨ã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:650
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr ""
"ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚„ã‚Šã¨ã‚Šã®ãŸã‚ã« :func:`Pipe` (2ã¤ã®ãƒ—ãƒ­ã‚»ã‚¹é–“ã®é€šä¿¡ç”¨)ã€ã‚‚ã—ãã¯ã‚­ãƒ¥ãƒ¼ (è¤‡æ•°ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆãƒ—ãƒ­ã‚»ã‚¹ "
"(producer)ã€æ¶ˆè²»ãƒ—ãƒ­ã‚»ã‚¹ (consumer) ã®å®Ÿç¾ç”¨) ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:653
msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types "
"are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` queues"
" modelled on the :class:`queue.Queue` class in the standard library.  They "
"differ in that :class:`Queue` lacks the :meth:`~queue.Queue.task_done` and "
":meth:`~queue.Queue.join` methods introduced into Python 2.5's "
":class:`queue.Queue` class."
msgstr ""
":class:`Queue`, :class:`SimpleQueue` ã¨ :class:`JoinableQueue` "
"å‹ã¯è¤‡æ•°ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ç”Ÿæˆ/æ¶ˆè²»ã‚’è¡Œã† :abbr:`FIFO (first-in, first-out, å…ˆå…¥ã‚Œå…ˆå‡ºã—)` "
"ã‚­ãƒ¥ãƒ¼ã§ã™ã€‚ã“ã‚Œã‚‰ã®ã‚­ãƒ¥ãƒ¼ã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® :class:`queue.Queue` ã‚’æ¨¡å€£ã—ã¦ã„ã¾ã™ã€‚ :class:`Queue` ã«ã¯ "
"Python 2.5 ã® :class:`queue.Queue` ã‚¯ãƒ©ã‚¹ã§å°å…¥ã•ã‚ŒãŸ :meth:`~queue.Queue.task_done` ã¨"
" :meth:`~queue.Queue.join` ãƒ¡ã‚½ãƒƒãƒ‰ãŒãªã„ã“ã¨ãŒé•ã†ç‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:660
msgid ""
"If you use :class:`JoinableQueue` then you **must** call "
":meth:`JoinableQueue.task_done` for each task removed from the queue or else"
" the semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr ""
"ã‚‚ã— :class:`JoinableQueue` ã‚’ä½¿ç”¨ã™ã‚‹ãªã‚‰ã€ã‚­ãƒ¥ãƒ¼ã‹ã‚‰å‰Šé™¤ã•ã‚Œã‚‹å„ã‚¿ã‚¹ã‚¯ã®ãŸã‚ã« "
":meth:`JoinableQueue.task_done` ã‚’å‘¼ã³å‡ºã•ãªã‘ã‚Œã° **ãªã‚Šã¾ã›ã‚“** "
"ã€‚ã•ã‚‚ãªã„ã¨ã€ã„ã¤ã‹å®Œäº†ã—ã¦ã„ãªã„ã‚¿ã‚¹ã‚¯ã‚’æ•°ãˆã‚‹ãŸã‚ã®ã‚»ãƒãƒ•ã‚©ãŒã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã—ã€ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/multiprocessing.rst:665
msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr ""
"ç®¡ç†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§å…±æœ‰ã‚­ãƒ¥ãƒ¼ã‚’ä½œæˆã§ãã‚‹ã“ã¨ã‚‚è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚è©³ç´°ã¯ :ref:`multiprocessing-managers`"
" ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:670
msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and "
":exc:`queue.Full` exceptions to signal a timeout.  They are not available in"
" the :mod:`multiprocessing` namespace so you need to import them from "
":mod:`queue`."
msgstr ""
":mod:`multiprocessing` ã¯ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ä¼ãˆã‚‹ãŸã‚ã«ã€é€šå¸¸ã® :exc:`queue.Empty` ã¨ "
":exc:`queue.Full` ä¾‹å¤–ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ãã‚Œã‚‰ã¯ :mod:`multiprocessing` "
"ã®åå‰ç©ºé–“ã§ã¯åˆ©ç”¨ã§ããªã„ãŸã‚ã€:mod:`queue` ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:677
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use"
" a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚Œã‚‹éš›ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ pickle åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚ãã®ãŸã‚ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒå¾Œã«ãªã£ã¦ä¸‹ä½å±¤ã®ãƒ‘ã‚¤ãƒ—ã« "
"pickle "
"åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å°‘ã—é©šãã‚ˆã†ãªçµæœã«ãªã‚Šã¾ã™ãŒã€å®Ÿéš›ã«å•é¡Œã«ãªã‚‹ã“ã¨ã¯ãªã„ã¯ãšã§ã™ã€‚ã“ã‚ŒãŒå•é¡Œã«ãªã‚‹ã‚ˆã†ãªçŠ¶æ³ã§ã¯ã€ã‹ã‚ã‚Šã«"
" :ref:`manager <multiprocessing-managers>` ã‚’ä½¿ã£ã¦ã‚­ãƒ¥ãƒ¼ã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:684
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`queue.Empty`."
msgstr ""
"ç©ºã®ã‚­ãƒ¥ãƒ¼ã®ä¸­ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿½åŠ ã—ãŸå¾Œã€ã‚­ãƒ¥ãƒ¼ã® :meth:`~Queue.empty` ãƒ¡ã‚½ãƒƒãƒ‰ãŒ :const:`False` "
"ã‚’è¿”ã™ã¾ã§ã®é–“ã«ã”ãã‚ãšã‹ãªé…å»¶ãŒèµ·ãã‚‹ã“ã¨ãŒã‚ã‚Šã€:meth:`~Queue.get_nowait` ãŒ :exc:`queue.Empty` "
"ã‚’ç™ºç”Ÿã•ã›ã‚‹ã“ã¨ãªãåˆ¶å¾¡ãŒå‘¼ã³å‡ºã—å…ƒã«è¿”ã£ã¦ã—ã¾ã†ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:689
msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr ""
"è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚­ãƒ¥ãƒ¼ã«è©°ã‚ã¦ã„ã‚‹å ´åˆã€ã‚­ãƒ¥ãƒ¼ã®åå¯¾å´ã§ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè©°ã‚ã‚‰ã‚ŒãŸã®ã¨ã¯é•ã†é †åºã§å–å¾—ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ãŸã ã—ã€åŒä¸€ã®ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰è©°ã‚è¾¼ã¾ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé–“ã§ã¯ã€å¿…ãšæœŸå¾…ã©ãŠã‚Šã®é †åºã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:696
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`Queue`, then the data in the queue is "
"likely to become corrupted.  This may cause any other process to get an "
"exception when it tries to use the queue later on."
msgstr ""
":class:`Queue` ã‚’åˆ©ç”¨ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹æœ€ä¸­ã«ãƒ—ãƒ­ã‚»ã‚¹ã‚’ :meth:`Process.terminate` ã‚„ "
":func:`os.kill` "
"ã§çµ‚äº†ã•ã›ã‚‹å ´åˆã€ã‚­ãƒ¥ãƒ¼ã«ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ã¯ç ´æã—æ˜“ããªã‚Šã¾ã™ã€‚çµ‚äº†ã—ãŸå¾Œã§ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚­ãƒ¥ãƒ¼ã‚’åˆ©ç”¨ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:703
msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>`), then that process will not "
"terminate until all buffered items have been flushed to the pipe."
msgstr ""
"ä¸Šè¿°ã—ãŸã‚ˆã†ã«ã€ã‚‚ã—å­ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚­ãƒ¥ãƒ¼ã¸è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ãªã‚‰ (ã‹ã¤ :meth:`JoinableQueue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>` ã‚’ä½¿ç”¨ã—ãªã„ãªã‚‰) "
"ãã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ãƒãƒƒãƒ•ã‚¡ãƒ¼ã•ã‚ŒãŸã™ã¹ã¦ã®è¦ç´ ãŒãƒ‘ã‚¤ãƒ—ã¸ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã•ã‚Œã‚‹ã¾ã§çµ‚äº†ã—ã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:708
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr ""
"ã“ã‚Œã¯ã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ join "
"ã—ã‚ˆã†ã¨ã™ã‚‹å ´åˆã€ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚ŒãŸã™ã¹ã¦ã®è¦ç´ ãŒæ¶ˆè²»ã•ã‚ŒãŸã“ã¨ãŒç¢ºå®Ÿã§ãªã„ã‹ãã‚Šã€ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’ç™ºç”Ÿã•ã›ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ä¼¼ãŸã‚ˆã†ãªç¾è±¡ã§ã€å­ãƒ—ãƒ­ã‚»ã‚¹ãŒéãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã®å ´åˆã€è¦ªãƒ—ãƒ­ã‚»ã‚¹ã¯çµ‚äº†æ™‚ã«éãƒ‡ãƒ¼ãƒ¢ãƒ³ã®ã™ã¹ã¦ã®å­ãƒ—ãƒ­ã‚»ã‚¹ã‚’"
" join ã—ã‚ˆã†ã¨ã—ã¦ãƒãƒ³ã‚°ã‚¢ãƒƒãƒ—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:713
msgid ""
"Note that a queue created using a manager does not have this issue.  See "
":ref:`multiprocessing-programming`."
msgstr ""
"ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ä½œæˆã•ã‚ŒãŸã‚­ãƒ¥ãƒ¼ã§ã¯ã“ã®å•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è©³ç´°ã¯ :ref:`multiprocessing-programming` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:716
msgid ""
"For an example of the usage of queues for interprocess communication see "
":ref:`multiprocessing-examples`."
msgstr "ãƒ—ãƒ­ã‚»ã‚¹é–“é€šä¿¡ã«ãŠã‘ã‚‹ã‚­ãƒ¥ãƒ¼ã®ä½¿ç”¨ä¾‹ã‚’çŸ¥ã‚ŠãŸã„ãªã‚‰ :ref:`multiprocessing-examples` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:722
msgid ""
"Returns a pair ``(conn1, conn2)`` of "
":class:`~multiprocessing.connection.Connection` objects representing the "
"ends of a pipe."
msgstr ""

#: ../../library/multiprocessing.rst:726
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be"
" used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr ""
"*duplex* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ãƒ‘ã‚¤ãƒ—ã¯åŒæ–¹å‘æ€§ã§ã™ã€‚*duplex* ãŒ ``False`` "
"ãªã‚‰ãƒ‘ã‚¤ãƒ—ã¯ä¸€æ–¹å‘æ€§ã§ã€``conn1`` ã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å—ä¿¡å°‚ç”¨ã€``conn2`` ã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡å°‚ç”¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:734
msgid ""
"Returns a process shared queue implemented using a pipe and a few "
"locks/semaphores.  When a process first puts an item on the queue a feeder "
"thread is started which transfers objects from a buffer into the pipe."
msgstr ""
"ãƒ‘ã‚¤ãƒ—ã‚„2ï½3å€‹ã®ãƒ­ãƒƒã‚¯/ã‚»ãƒãƒ•ã‚©ã‚’ä½¿ç”¨ã—ã¦å®Ÿè£…ã•ã‚ŒãŸãƒ—ãƒ­ã‚»ã‚¹å…±æœ‰ã‚­ãƒ¥ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ã‚ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ãŒæœ€åˆã«è¦ç´ ã‚’ã‚­ãƒ¥ãƒ¼ã¸è¿½åŠ ã™ã‚‹ã¨ãã€ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‹ã‚‰ãƒ‘ã‚¤ãƒ—ã®ä¸­ã¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è»¢é€ã™ã‚‹ä¾›çµ¦ã‚¹ãƒ¬ãƒƒãƒ‰ãŒé–‹å§‹ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:738
msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr ""
"æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® :mod:`queue` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é€šå¸¸ã® :exc:`queue.Empty` ã‚„ :exc:`queue.Full` "
"ä¾‹å¤–ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ä¼ãˆã‚‹ãŸã‚ã«é€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:741
msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except for"
" :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
":class:`Queue` ã¯ :meth:`~queue.Queue.task_done` ã‚„ :meth:`~queue.Queue.join` "
"ã‚’é™¤ã :class:`queue.Queue` ã®ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:746
msgid ""
"Return the approximate size of the queue.  Because of "
"multithreading/multiprocessing semantics, this number is not reliable."
msgstr "ãŠãŠã‚ˆãã®ã‚­ãƒ¥ãƒ¼ã®ã‚µã‚¤ã‚ºã‚’è¿”ã—ã¾ã™ã€‚ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‡ã‚£ãƒ³ã‚°/ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚¹ã®ç‰¹æ€§ä¸Šã€ã“ã®æ•°å€¤ã¯ä¿¡ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:749
msgid ""
"Note that this may raise :exc:`NotImplementedError` on Unix platforms like "
"Mac OS X where ``sem_getvalue()`` is not implemented."
msgstr ""
"ã“ã‚Œã¯ ``sem_getvalue()`` ãŒå®Ÿè£…ã•ã‚Œã¦ã„ãªã„ Mac OS X ã®ã‚ˆã†ãª Unix ãƒ—ãƒ©ãƒƒãƒˆãƒ›ãƒ¼ãƒ ä¸Šã§ "
":exc:`NotImplementedError` ã‚’ç™ºç”Ÿã•ã›ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:754
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"ã‚­ãƒ¥ãƒ¼ãŒç©ºã£ã½ãªã‚‰ ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` "
"ã‚’è¿”ã—ã¾ã™ã€‚ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‡ã‚£ãƒ³ã‚°/ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚·ãƒ³ã‚°ã®ç‰¹æ€§ä¸Šã€ã“ã‚Œã¯ä¿¡ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:759
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"ã‚­ãƒ¥ãƒ¼ãŒã„ã£ã±ã„ãªã‚‰ ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` "
"ã‚’è¿”ã—ã¾ã™ã€‚ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‡ã‚£ãƒ³ã‚°/ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚·ãƒ³ã‚°ã®ç‰¹æ€§ä¸Šã€ã“ã‚Œã¯ä¿¡ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:764
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a"
" free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`queue.Full` exception if no free"
" slot was available within that time.  Otherwise (*block* is ``False``), put"
" an item on the queue if a free slot is immediately available, else raise "
"the :exc:`queue.Full` exception (*timeout* is ignored in that case)."
msgstr ""
"ã‚­ãƒ¥ãƒ¼ã®ä¸­ã¸ obj ã‚’è¿½åŠ ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *block* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ä¸”ã¤ *timeout* ãŒ "
"``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã€ç©ºãã‚¹ãƒ­ãƒƒãƒˆãŒåˆ©ç”¨å¯èƒ½ã«ãªã‚‹ã¾ã§å¿…è¦ã§ã‚ã‚Œã°ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ *timeout* ãŒæ­£ã®æ•°ãªã‚‰ã€æœ€å¤§ "
"*timeout* ç§’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã€ãã®æ™‚é–“å†…ã«ç©ºãã‚¹ãƒ­ãƒƒãƒˆãŒåˆ©ç”¨ã§ããªã‹ã£ãŸã‚‰ :exc:`queue.Full` ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚ãã‚Œä»¥å¤– "
"(*block* ãŒ ``False``) ã§ã€ç©ºãã‚¹ãƒ­ãƒƒãƒˆãŒã™ãã«åˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ã‚­ãƒ¥ãƒ¼ã«è¦ç´ ã‚’è¿½åŠ ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° "
":exc:`queue.Full` ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™(ãã®å ´åˆ *timeout* ã¯ç„¡è¦–ã•ã‚Œã¾ã™)ã€‚"

#: ../../library/multiprocessing.rst:775
msgid "Equivalent to ``put(obj, False)``."
msgstr "``put(obj, False)`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:779
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it"
" blocks at most *timeout* seconds and raises the :exc:`queue.Empty` "
"exception if no item was available within that time.  Otherwise (block is "
"``False``), return an item if one is immediately available, else raise the "
":exc:`queue.Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"ã‚­ãƒ¥ãƒ¼ã‹ã‚‰è¦ç´ ã‚’å–ã‚Šå‡ºã—ã¦å‰Šé™¤ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *block* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ä¸”ã¤ *timeout* ãŒ "
"``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã€è¦ç´ ãŒå–ã‚Šå‡ºã›ã‚‹ã¾ã§å¿…è¦ã§ã‚ã‚Œã°ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ *timeout* ãŒæ­£ã®æ•°ãªã‚‰ã€æœ€å¤§ *timeout* "
"ç§’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã€ãã®æ™‚é–“å†…ã«è¦ç´ ãŒå–ã‚Šå‡ºã›ãªã‹ã£ãŸã‚‰ :exc:`queue.Empty` ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚ãã‚Œä»¥å¤– (*block* ãŒ "
"``False``) ã§ã€è¦ç´ ãŒã™ãã«å–ã‚Šå‡ºã›ã‚‹å ´åˆã¯è¦ç´ ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° :exc:`queue.Empty` ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™(ãã®å ´åˆ "
"*timeout* ã¯ç„¡è¦–ã•ã‚Œã¾ã™)ã€‚"

#: ../../library/multiprocessing.rst:789
msgid "Equivalent to ``get(False)``."
msgstr "``get(False)`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:791
msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in "
":class:`queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ""
":class:`multiprocessing.Queue` ã¯ :class:`queue.Queue` ã«ã¯ãªã„è¿½åŠ ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚ "
"ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯é€šå¸¸ã€ã»ã¨ã‚“ã©ã®ã‚³ãƒ¼ãƒ‰ã«å¿…è¦ã‚ã‚Šã¾ã›ã‚“:"

#: ../../library/multiprocessing.rst:797
msgid ""
"Indicate that no more data will be put on this queue by the current process."
"  The background thread will quit once it has flushed all buffered data to "
"the pipe.  This is called automatically when the queue is garbage collected."
msgstr ""
"ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ã“ã®ã‚­ãƒ¥ãƒ¼ã¸ãã‚Œä»¥ä¸Šãƒ‡ãƒ¼ã‚¿ãŒè¿½åŠ ã•ã‚Œãªã„ã“ã¨ã‚’è¡¨ã—ã¾ã™ã€‚ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãƒ‘ã‚¤ãƒ—ã¸ãƒãƒƒãƒ•ã‚¡ãƒ¼ã•ã‚ŒãŸã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹ã¨ã™ãã«çµ‚äº†ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚­ãƒ¥ãƒ¼ãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹ã¨ãã«è‡ªå‹•çš„ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:804
msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all"
" data in the buffer has been flushed to the pipe."
msgstr ""
"ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ join ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :meth:`close` "
"ãŒå‘¼ã³å‡ºã•ã‚ŒãŸå¾Œã§ã®ã¿ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ãƒ¼ã•ã‚ŒãŸã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ãŒãƒ‘ã‚¤ãƒ—ã¸ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã•ã‚Œã‚‹ã®ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:808
msgid ""
"By default if a process is not the creator of the queue then on exit it will"
" attempt to join the queue's background thread.  The process can call "
":meth:`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã‚ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚­ãƒ¥ãƒ¼ã‚’ä½œæˆã—ã¦ã„ãªã„å ´åˆã€çµ‚äº†æ™‚ã«ã‚­ãƒ¥ãƒ¼ã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ join ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚ãã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ "
":meth:`join_thread` ãŒä½•ã‚‚ã—ãªã„ã‚ˆã†ã« :meth:`cancel_join_thread` ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:814
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the"
" background thread from being joined automatically when the process exits --"
" see :meth:`join_thread`."
msgstr ""
":meth:`join_thread` ãŒãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã™ã‚‹ã®ã‚’é˜²ãã¾ã™ã€‚ç‰¹ã«ã“ã‚Œã¯ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãã®ãƒ—ãƒ­ã‚»ã‚¹ã®çµ‚äº†æ™‚ã«è‡ªå‹•çš„ã« join "
"ã•ã‚Œã‚‹ã®ã‚’é˜²ãã¾ã™ã€‚è©³ç´°ã¯ :meth:`join_thread` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:818
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to lost, and you almost certainly will not "
"need to use it. It is really only there if you need the current process to "
"exit immediately without waiting to flush enqueued data to the underlying "
"pipe, and you don't care about lost data."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ ``allow_exit_without_flush()`` "
"ã¨ã„ã†åå‰ã®ã»ã†ãŒã‚ˆã‹ã£ãŸã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒå¤±ã‚ã‚Œã¦ã—ã¾ã„ãŒã¡ãªãŸã‚ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†å¿…è¦ã¯ã»ã¼ç¢ºå®Ÿã«ãªã„ã§ã—ã‚‡ã†ã€‚æœ¬å½“ã«ã“ã‚ŒãŒå¿…è¦ã«ãªã‚‹ã®ã¯ã€ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’ä¸‹ä½å±¤ã®ãƒ‘ã‚¤ãƒ—ã«ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹ã“ã¨ãªãã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‚’ç›´ã¡ã«çµ‚äº†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€ã‹ã¤å¤±ã‚ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã«é–¢å¿ƒãŒãªã„å ´åˆã§ã™ã€‚"

#: ../../library/multiprocessing.rst:827
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue`"
" will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹ã«å«ã¾ã‚Œã‚‹æ©Ÿèƒ½ã«ã¯ã€ãƒ›ã‚¹ãƒˆã¨ãªã‚‹ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ä¸Šã§å‹•ä½œã—ã¦ã„ã‚‹å…±æœ‰ã‚»ãƒãƒ•ã‚© (shared semaphore) "
"ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚ŒãŒä½¿ç”¨ã§ããªã„å ´åˆã«ã¯ã€ã“ã®ã‚¯ãƒ©ã‚¹ãŒç„¡åŠ¹ã«ãªã‚Šã€ :class:`Queue` ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹æ™‚ã« "
":exc:`ImportError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚è©³ç´°ã¯ :issue:`3770` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚åŒæ§˜ã®ã“ã¨ãŒã€ä»¥ä¸‹ã«åˆ—æŒ™ã•ã‚Œã¦ã„ã‚‹ç‰¹æ®Šãªã‚­ãƒ¥ãƒ¼ã§ã‚‚æˆã‚Šç«‹ã¡ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:836
msgid ""
"It is a simplified :class:`Queue` type, very close to a locked "
":class:`Pipe`."
msgstr "å˜ç´”åŒ–ã•ã‚ŒãŸ :class:`Queue` å‹ã§ã™ã€‚ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸ :class:`Pipe` ã¨éå¸¸ã«ä¼¼ã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:840
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "ã‚­ãƒ¥ãƒ¼ãŒç©ºãªã‚‰ã° ``True`` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:844
msgid "Remove and return an item from the queue."
msgstr "ã‚­ãƒ¥ãƒ¼ã‹ã‚‰è¦ç´ ã‚’å‰Šé™¤ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:848
msgid "Put *item* into the queue."
msgstr "*item* ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:853
msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`JoinableQueue` ã¯ :class:`Queue` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€ :meth:`task_done` ã‚„ "
":meth:`join` ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿½åŠ ã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¥ãƒ¼ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:858
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue consumers."
"  For each :meth:`~Queue.get` used to fetch a task, a subsequent call to "
":meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""
"ä»¥å‰ã«ã‚­ãƒ¥ãƒ¼ã¸è¿½åŠ ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ãŒå®Œäº†ã—ãŸã“ã¨ã‚’è¡¨ã—ã¾ã™ã€‚ã‚­ãƒ¥ãƒ¼ã®ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒã«ã‚ˆã£ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ ã‚¿ã‚¹ã‚¯ã‚’ãƒ•ã‚§ãƒƒãƒã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ãã‚Œãã‚Œã® "
":meth:`~Queue.get` ã«å¯¾ã—ã¦ã€ å¾Œç¶šã® :meth:`task_done` å‘¼ã³å‡ºã—ã¯ã‚¿ã‚¹ã‚¯ã®å‡¦ç†ãŒå®Œäº†ã—ãŸã“ã¨ã‚’ã‚­ãƒ¥ãƒ¼ã¸ä¼ãˆã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:863
msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"ã‚‚ã— :meth:`~queue.Queue.join` ãŒãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°çŠ¶æ…‹ãªã‚‰ã€ ã™ã¹ã¦ã®è¦ç´ ãŒå‡¦ç†ã•ã‚ŒãŸã¨ãã«å¾©å¸°ã—ã¾ã™( "
":meth:`task_done` å‘¼ã³å‡ºã—ãŒ ã™ã¹ã¦ã®è¦ç´ ã‹ã‚‰ã‚­ãƒ¥ãƒ¼å†…ã¸ :meth:`~Queue.put` ã•ã‚ŒãŸã¨å—ã‘å–ã£ãŸã“ã¨ã‚’æ„å‘³ã—ã¾ã™)ã€‚"

#: ../../library/multiprocessing.rst:867
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed"
" in the queue."
msgstr "ã‚­ãƒ¥ãƒ¼ã«ã‚ã‚‹è¦ç´ ã‚ˆã‚Šå¤šãå‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆ :exc:`ValueError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:873
msgid "Block until all items in the queue have been gotten and processed."
msgstr "ã‚­ãƒ¥ãƒ¼ã«ã‚ã‚‹ã™ã¹ã¦ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒå–ã‚Šå‡ºã•ã‚Œã¦å‡¦ç†ã•ã‚Œã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:875
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` to "
"indicate that the item was retrieved and all work on it is complete.  When "
"the count of unfinished tasks drops to zero, :meth:`~queue.Queue.join` "
"unblocks."
msgstr ""
"ã‚­ãƒ¥ãƒ¼ã«è¦ç´ ãŒè¿½åŠ ã•ã‚Œã‚‹ã¨æœªå®Œäº†ã‚¿ã‚¹ã‚¯æ•°ãŒå¢—ãˆã¾ã™ã€‚ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãŒã‚­ãƒ¥ãƒ¼ã®è¦ç´ ãŒå–ã‚Šå‡ºã•ã‚Œã¦ã™ã¹ã¦ã®å‡¦ç†ãŒå®Œäº†ã—ãŸã“ã¨ã‚’è¡¨ã™ "
":meth:`task_done` ã‚’å‘¼ã³å‡ºã™ã¨æ•°ãŒæ¸›ã‚Šã¾ã™ã€‚ æœªå®Œäº†ã‚¿ã‚¹ã‚¯æ•°ãŒã‚¼ãƒ­ã«ãªã‚‹ã¨ :meth:`~queue.Queue.join` "
"ã¯ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚’è§£é™¤ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:883
msgid "Miscellaneous"
msgstr "ãã®ä»–"

#: ../../library/multiprocessing.rst:887
msgid "Return list of all live children of the current process."
msgstr "ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã®ã™ã¹ã¦ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå­ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:889
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr "ã“ã‚Œã‚’å‘¼ã³å‡ºã™ã¨ \"join\" ã—ã¦ã™ã§ã«çµ‚äº†ã—ã¦ã„ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã«ã¯å‰¯ä½œç”¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:894
msgid "Return the number of CPUs in the system."
msgstr "ã‚·ã‚¹ãƒ†ãƒ ã® CPU æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:896
msgid ""
"This number is not equivalent to the number of CPUs the current process can "
"use.  The number of usable CPUs can be obtained with "
"``len(os.sched_getaffinity(0))``"
msgstr ""
"ã“ã®æ•°ã¯ç¾åœ¨ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒä½¿ãˆã‚‹ CPU æ•°ã¨åŒã˜ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚\n"
"ä½¿ç”¨å¯èƒ½ãª CPU æ•°ã¯ ``len(os.sched_getaffinity(0))`` ã§å–å¾—ã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:900
msgid "May raise :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` ã‚’é€å‡ºã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:903
msgid ":func:`os.cpu_count`"
msgstr ":func:`os.cpu_count`"

#: ../../library/multiprocessing.rst:907
msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr "ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã«å¯¾å¿œã™ã‚‹ :class:`Process` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:909
msgid "An analogue of :func:`threading.current_thread`."
msgstr ":func:`threading.current_thread` ã¨ã‚ˆãä¼¼ãŸé–¢æ•°ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:913
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce a Windows executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ""
":mod:`multiprocessing` ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒ•ãƒªãƒ¼ã‚ºã—ã¦ Windows "
"ã®å®Ÿè¡Œå¯èƒ½å½¢å¼ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã®ã‚µãƒãƒ¼ãƒˆã‚’è¿½åŠ ã—ã¾ã™ã€‚(**py2exe** , **PyInstaller** ã‚„ **cx_Freeze** "
"ã§ãƒ†ã‚¹ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚)"

#: ../../library/multiprocessing.rst:917
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr ""
"ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``if __name__ == '__main__'`` ã®ç›´å¾Œã«ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../library/multiprocessing.rst:929
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr ""
"ã‚‚ã— ``freeze_support()`` ã®è¡ŒãŒãªã„å ´åˆã€ãƒ•ãƒªãƒ¼ã‚ºã•ã‚ŒãŸå®Ÿè¡Œå¯èƒ½å½¢å¼ã‚’å®Ÿè¡Œã—ã‚ˆã†ã¨ã™ã‚‹ã¨ :exc:`RuntimeError` "
"ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:932
msgid ""
"Calling ``freeze_support()`` has no effect when invoked on any operating "
"system other than Windows.  In addition, if the module is being run normally"
" by the Python interpreter on Windows (the program has not been frozen), "
"then ``freeze_support()`` has no effect."
msgstr ""
"``freeze_support()`` ã®å‘¼ã³å‡ºã—ã¯ Windows ä»¥å¤–ã® OS ã§ã¯åŠ¹æœãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã•ã‚‰ã«ã€ã‚‚ã—ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ Windows "
"ã®é€šå¸¸ã® Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã£ã¦å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ãªã‚‰ã°ï¼ˆãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒãƒ•ãƒªãƒ¼ã‚ºã•ã‚Œã¦ã„ãªã‘ã‚Œã°ï¼‰ ``freeze_support()`` "
"ã¯åŠ¹æœãŒã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:939
msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  On Windows only ``'spawn'`` is available.  On Unix "
"``'fork'`` and ``'spawn'`` are always supported, with ``'fork'`` being the "
"default."
msgstr ""
"ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹é–‹å§‹æ–¹å¼ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚å…ˆé ­ã®è¦ç´ ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’æ„å‘³ã—ã¾ã™ã€‚åˆ©ç”¨å¯èƒ½ãªé–‹å§‹æ–¹å¼ã«ã¯ ``'fork'``ã€``'spawn'`` "
"ãŠã‚ˆã³ ``'forkserver'`` ãŒã‚ã‚Šã¾ã™ã€‚Windows ã§ã¯ ``'spawn'`` ã®ã¿ãŒåˆ©ç”¨å¯èƒ½ã§ã™ã€‚Unix ã§ã¯ "
"``'fork'`` ãŠã‚ˆã³ ``'spawn'`` ã¯å¸¸ã«ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ãŠã‚Šã€``'fork'`` ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:949
msgid ""
"Return a context object which has the same attributes as the "
":mod:`multiprocessing` module."
msgstr ":mod:`multiprocessing` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨åŒã˜å±æ€§ã‚’æŒã¤ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:952
msgid ""
"If *method* is ``None`` then the default context is returned. Otherwise "
"*method* should be ``'fork'``, ``'spawn'``, ``'forkserver'``.  "
":exc:`ValueError` is raised if the specified start method is not available."
msgstr ""
"*method* ãŒ ``None`` ã®å ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒè¿”ã•ã‚Œã¾ã™ã€‚ãã®ä»–ã®å ´åˆ *method* ã¯ "
"``'fork'``ã€``'spawn'`` ã‚ã‚‹ã„ã¯ ``'forkserver'`` ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æŒ‡å®šã•ã‚ŒãŸé–‹å§‹æ–¹å¼ãŒåˆ©ç”¨ã§ããªã„å ´åˆã¯ "
":exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:961
msgid "Return the name of start method used for starting processes."
msgstr "é–‹å§‹ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã§ä½¿ç”¨ã™ã‚‹é–‹å§‹æ–¹å¼åã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:963
msgid ""
"If the start method has not been fixed and *allow_none* is false, then the "
"start method is fixed to the default and the name is returned.  If the start"
" method has not been fixed and *allow_none* is true then ``None`` is "
"returned."
msgstr ""
"é–‹å§‹æ–¹å¼ãŒã¾ã ç¢ºå®šã—ã¦ãŠã‚‰ãšã€*allow_none* "
"ã®å€¤ãŒå½ã®å ´åˆã€é–‹å§‹æ–¹å¼ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ç¢ºå®šã•ã‚Œã€ãã®åå‰ãŒè¿”ã•ã‚Œã¾ã™ã€‚é–‹å§‹æ–¹å¼ãŒç¢ºå®šã—ã¦ãŠã‚‰ãšã€*allow_none* ã®å€¤ãŒçœŸã®å ´åˆã€ "
"``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:968
msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  ``'fork'`` is the default on Unix, while ``'spawn'`` is the "
"default on Windows."
msgstr ""
"è¿”ã‚Šå€¤ã¯ ``'fork'``ã€``'spawn'``ã€``'forkserver'`` ã‚ã‚‹ã„ã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚Unix ã§ã¯ "
"``'fork'`` ãŒã€Windows ã§ã¯ ``'spawn'`` ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:976
msgid ""
"Sets the path of the Python interpreter to use when starting a child "
"process. (By default :data:`sys.executable` is used).  Embedders will "
"probably need to do some thing like ::"
msgstr ""
"å­ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã™ã‚‹ã¨ãã«ã€ä½¿ç”¨ã™ã‚‹ Python ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã®ãƒ‘ã‚¹ã‚’è¨­å®šã—ã¾ã™ã€‚(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ :data:`sys.executable` "
"ãŒä½¿ç”¨ã•ã‚Œã¾ã™)ã€‚ã‚³ãƒ¼ãƒ‰ã«çµ„ã¿è¾¼ã‚€ã¨ãã¯ã€ãŠãã‚‰ãæ¬¡ã®ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ ::"

#: ../../library/multiprocessing.rst:982
msgid "before they can create child processes."
msgstr "å­ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œæˆã™ã‚‹å‰ã«è¡Œã£ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:984
msgid "Now supported on Unix when the ``'spawn'`` start method is used."
msgstr "Unix ã§é–‹å§‹æ–¹å¼ã« ``'spawn'`` ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã«ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/multiprocessing.rst:989
msgid ""
"Set the method which should be used to start child processes. *method* can "
"be ``'fork'``, ``'spawn'`` or ``'forkserver'``."
msgstr ""
"å­ãƒ—ãƒ­ã‚»ã‚¹ã®é–‹å§‹æ–¹å¼ã‚’æŒ‡å®šã—ã¾ã™ã€‚*method* ã«ã¯ ``'fork'``ã€``'spawn'`` ã‚ã‚‹ã„ã¯ ``'forkserver'`` "
"ã‚’æŒ‡å®šã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:992
msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr ""
"ã“ã‚Œã¯ä¸€åº¦ã—ã‹å‘¼ã³å‡ºã™ã“ã¨ãŒã§ããšã€ãã®å ´æ‰€ã‚‚ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``if __name__ == '__main__'`` "
"ç¯€å†…ã§ä¿è­·ã•ã‚ŒãŸçŠ¶æ…‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1000
msgid ""
":mod:`multiprocessing` contains no analogues of "
":func:`threading.active_count`, :func:`threading.enumerate`, "
":func:`threading.settrace`, :func:`threading.setprofile`, "
":class:`threading.Timer`, or :class:`threading.local`."
msgstr ""
":mod:`multiprocessing` ã«ã¯ :func:`threading.active_count`, "
":func:`threading.enumerate`, :func:`threading.settrace`, "
":func:`threading.setprofile`, :class:`threading.Timer` ã‚„ "
":class:`threading.local` ã®ã‚ˆã†ãªé–¢æ•°ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1007
msgid "Connection Objects"
msgstr "Connection ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/multiprocessing.rst:1011
msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr ""
"Connection ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ pickle "
"ã§ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºå¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹æ–‡å­—åˆ—ã‚’é€ã£ãŸã‚Šã€å—ã‘å–ã£ãŸã‚Šã—ã¾ã™ã€‚ãã†ã„ã£ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŒ‡å‘ã®æ¥ç¶šã‚½ã‚±ãƒƒãƒˆã¨è€ƒãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1014
msgid ""
"Connection objects are usually created using :func:`Pipe "
"<multiprocessing.Pipe>` -- see also :ref:`multiprocessing-listeners-"
"clients`."
msgstr ""

#: ../../library/multiprocessing.rst:1022
msgid ""
"Send an object to the other end of the connection which should be read using"
" :meth:`recv`."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã¸ :meth:`recv` ã‚’ä½¿ç”¨ã—ã¦èª­ã¿è¾¼ã‚€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é€ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1025
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ pickle ã§ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºå¯èƒ½ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ pickle ãŒæ¥µç«¯ã«å¤§ãã™ãã‚‹ (OS ã«ã‚‚ä¾ã‚Šã¾ã™ãŒã€ãŠã‚ˆã 32 MB+)"
" ã¨ã€ :exc:`ValueError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1030
msgid ""
"Return an object sent from the other end of the connection using "
":meth:`send`.  Blocks until there is something to receive.  Raises "
":exc:`EOFError` if there is nothing left to receive and the other end was "
"closed."
msgstr ""
"ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã‹ã‚‰ :meth:`send` ã‚’ä½¿ç”¨ã—ã¦é€ã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ "
"ä½•ã‹å—ã‘å–ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ä½•ã‚‚å—ã‘å–ã‚‰ãšã«ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã§ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸå ´åˆ :exc:`EOFError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1037
msgid "Return the file descriptor or handle used by the connection."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒä½¿ç”¨ã™ã‚‹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‹ã€ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1041
msgid "Close the connection."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1043
msgid "This is called automatically when the connection is garbage collected."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹ã¨ãã«è‡ªå‹•çš„ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1047
msgid "Return whether there is any data available to be read."
msgstr "èª­ã¿è¾¼ã¿å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1049
msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout*"
" is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"*timeout* ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã™ãã«è¿”ã—ã¾ã™ã€‚ *timeout* ã«æ•°å€¤ã‚’æŒ‡å®šã™ã‚‹ã¨ã€æœ€å¤§æŒ‡å®šã—ãŸç§’æ•°ã‚’ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã—ã¾ã™ã€‚ "
"*timeout* ã« ``None`` ã‚’æŒ‡å®šã™ã‚‹ã¨ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã›ãšã«ãšã£ã¨ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1053
msgid ""
"Note that multiple connection objects may be polled at once by using "
":func:`multiprocessing.connection.wait`."
msgstr ""
":func:`multiprocessing.connection.wait` "
"ã‚’ä½¿ã£ã¦è¤‡æ•°ã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åŒæ™‚ã«ãƒãƒ¼ãƒªãƒ³ã‚°ã§ãã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1058
msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr ":term:`bytes-like object` ã‹ã‚‰å®Œå…¨ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã—ã¦ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1060
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MB+, though it depends on the OS) may raise a "
":exc:`ValueError` exception"
msgstr ""
"*offset* ãŒæŒ‡å®šã•ã‚Œã‚‹ã¨ *buffer* ã®ãã®ä½ç½®ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã™ã€‚ *size* "
"ãŒæŒ‡å®šã•ã‚Œã‚‹ã¨ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‹ã‚‰ãã®é‡ã®ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã™ã€‚éå¸¸ã«å¤§ããªãƒãƒƒãƒ•ã‚¡ãƒ¼ (OS ã«ä¾å­˜ã—ã¾ã™ãŒã€ãŠã‚ˆã 32MB+) ã‚’æŒ‡å®šã™ã‚‹ã¨ã€ "
":exc:`ValueError` ä¾‹å¤–ãŒç™ºç”Ÿã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1067
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises "
":exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr ""
"ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã‹ã‚‰é€ã‚‰ã‚ŒãŸãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã®å®Œå…¨ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ–‡å­—åˆ—ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ä½•ã‹å—ã‘å–ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚å—ã‘å–ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒä½•ã‚‚æ®‹ã£ã¦ãŠã‚‰ãšã€ç›¸æ‰‹å´ãŒã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’é–‰ã˜ã¦ã„ãŸå ´åˆã€"
" :exc:`EOFError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1072
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then "
":exc:`OSError` is raised and the connection will no longer be readable."
msgstr ""
"*maxlength* ã‚’æŒ‡å®šã—ã¦ã„ã¦ã€ã‹ã¤ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒ *maxlength* ã‚ˆã‚Šé•·ã„å ´åˆã€ :exc:`OSError` "
"ãŒç™ºç”Ÿã—ã¦ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰ãã‚Œä»¥ä¸Šèª­ã‚ãªããªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1076
msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of "
":exc:`OSError`."
msgstr "ã“ã®é–¢æ•°ã¯ä»¥å‰ã¯ :exc:`IOError` ã‚’é€å‡ºã—ã¦ã„ã¾ã—ãŸã€‚ä»Šã§ã¯ :exc:`OSError` ã®åˆ¥åã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1083
msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr ""
"ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã‹ã‚‰é€ã‚‰ã‚ŒãŸãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ *buffer* ã«èª­ã¿è¾¼ã¿ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ã€‚ "
"ä½•ã‹å—ã‘å–ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ä½•ã‚‚å—ã‘å–ã‚‰ãšã«ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã§ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸå ´åˆ :exc:`EOFError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1089
msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is given"
" then the message will be written into the buffer from that position.  "
"Offset must be a non-negative integer less than the length of *buffer* (in "
"bytes)."
msgstr ""
"*buffer* ã¯æ›¸ãè¾¼ã¿å¯èƒ½ãª :term:`bytes-like object` ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ *offset* "
"ãŒä¸ãˆã‚‰ã‚ŒãŸã‚‰ã€ãã®ä½ç½®ã‹ã‚‰ãƒãƒƒãƒ•ã‚¡ãƒ¼ã¸ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ›¸ãè¾¼ã¾ã‚Œã¾ã™ã€‚ ã‚ªãƒ•ã‚»ãƒƒãƒˆã¯ *buffer* ãƒã‚¤ãƒˆã‚ˆã‚Šã‚‚å°ã•ã„æ­£ã®æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1094
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr ""
"ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒã‚ã¾ã‚Šã«å°ã•ã„ã¨ :exc:`BufferTooShort` ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚ ``e`` ãŒä¾‹å¤–ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã™ã‚‹ã¨å®Œå…¨ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ "
"``e.args[0]`` ã§ç¢ºèªã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1098
msgid ""
"Connection objects themselves can now be transferred between processes using"
" :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr ""
":meth:`Connection.send` ã¨ :meth:`Connection.recv` ã‚’ä½¿ç”¨ã—ã¦ Connection "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã‚’ãƒ—ãƒ­ã‚»ã‚¹é–“ã§è»¢é€ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/multiprocessing.rst:1102
msgid ""
"Connection objects now support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"connection object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Connection ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆãƒ»ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ -- "
":ref:`typecontextmanager` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ :meth:`~contextmanager.__enter__` ã¯ "
"Connection ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã¾ãŸ :meth:`~contextmanager.__exit__` ã¯ :meth:`close` "
"ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1107
msgid "For example:"
msgstr "ä¾‹ãˆã°:"

#: ../../library/multiprocessing.rst:1131
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ""
":meth:`Connection.recv` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å—ä¿¡ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•çš„ã« unpickle "
"åŒ–ã—ã¾ã™ã€‚ãã‚Œã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã£ãŸãƒ—ãƒ­ã‚»ã‚¹ãŒä¿¡é ¼ã§ãã‚‹å ´åˆã‚’é™¤ã„ã¦ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1135
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref"
":`multiprocessing-auth-keys`."
msgstr ""
"ãã®ãŸã‚ :func:`Pipe` ã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹å ´åˆã‚’é™¤ã„ã¦ã€ä½•ã‚‰ã‹ã®èªè¨¼å‡¦ç†ã‚’å®Ÿè¡Œã—ãŸå¾Œã§ "
":meth:`~Connection.recv` ã‚„ :meth:`~Connection.send` ãƒ¡ã‚½ãƒƒãƒ‰ã®ã¿ã‚’ä½¿ç”¨ã™ã¹ãã§ã™ã€‚è©³ç´°ã¯ :ref"
":`multiprocessing-auth-keys` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1142
msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr ""
"ã‚‚ã—ãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ‘ã‚¤ãƒ—ã®èª­ã¿è¾¼ã¿ã¾ãŸã¯æ›¸ãè¾¼ã¿ä¸­ã« kill "
"ã•ã‚Œã‚‹ã¨ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å¢ƒç•ŒãŒã©ã“ãªã®ã‹åˆ†ã‹ã‚‰ãªããªã£ã¦ã—ã¾ã†ã®ã§ã€ãã®ãƒ‘ã‚¤ãƒ—å†…ã®ãƒ‡ãƒ¼ã‚¿ã¯ç ´æã—ã¦ã—ã¾ã„ãŒã¡ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1148
msgid "Synchronization primitives"
msgstr "åŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–"

#: ../../library/multiprocessing.rst:1152
msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for "
":mod:`threading` module."
msgstr ""
"ä¸€èˆ¬çš„ã«ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚¹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã»ã©ã¯åŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’å¿…è¦ã¨ã—ã¾ã›ã‚“ã€‚è©³ç´°ã¯ :mod:`threading` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1156
msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr ""
"ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã—ã¦åŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’ä½œæˆã§ãã‚‹ã“ã¨ã‚‚è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚è©³ç´°ã¯ :ref:`multiprocessing-"
"managers` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1161
msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "ãƒãƒªã‚¢ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ: :class:`threading.Barrier` ã®ã‚¯ãƒ­ãƒ¼ãƒ³ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1167
msgid ""
"A bounded semaphore object: a close analog of "
":class:`threading.BoundedSemaphore`."
msgstr "æœ‰é™ã‚»ãƒãƒ•ã‚©ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ: :class:`threading.BoundedSemaphore` ã®é¡ä¼¼ç‰©ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1170
#: ../../library/multiprocessing.rst:1308
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's"
" first argument is named *block*, as is consistent with "
":meth:`Lock.acquire`."
msgstr ""
"ã‚ˆãä¼¼ãŸ :class:`threading.BoundedSemaphore`  ã¨ã¯ã€æ¬¡ã®ä¸€ç‚¹ã ã‘ç•°ãªã‚Šã¾ã™ã€‚ ``acquire`` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã®ç¬¬ä¸€å¼•æ•°åã¯ *block* ã§ã€:meth:`Lock.acquire` ã¨ä¸€è‡´ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1174
msgid ""
"On Mac OS X, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr ""
"Mac OS X ã§ã¯ ``sem_getvalue()`` ãŒå®Ÿè£…ã•ã‚Œã¦ã„ãªã„ã®ã§ :class:`Semaphore` ã¨åŒºåˆ¥ãŒã¤ãã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1179
msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr "çŠ¶æ…‹å¤‰æ•°: :class:`threading.Condition` ã®åˆ¥åã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1181
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr ""
"*lock* ã‚’æŒ‡å®šã™ã‚‹ãªã‚‰ :mod:`multiprocessing` ã® :class:`Lock` ã‹ :class:`RLock` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1184
#: ../../library/multiprocessing.rst:1718
msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr ":meth:`~threading.Condition.wait_for` ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/multiprocessing.rst:1189
msgid "A clone of :class:`threading.Event`."
msgstr ":class:`threading.Event` ã®ã‚¯ãƒ­ãƒ¼ãƒ³ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1194
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once"
" a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of "
":class:`threading.Lock` as it applies to threads are replicated here in "
":class:`multiprocessing.Lock` as it applies to either processes or threads, "
"except as noted."
msgstr ""
"å†å¸°ã—ãªã„ãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ :class:`threading.Lock` ç›¸å½“ã®ã‚‚ã®ã§ã™ã€‚ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã‚’ã„ã£ãŸã‚“ç²å¾— "
"(acquire) ã™ã‚‹ã¨ã€ãã‚Œã«ç¶šãã»ã‹ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ãŒç²å¾—ã—ã‚ˆã†ã¨ã™ã‚‹éš›ã€ãã‚ŒãŒè§£æ”¾ (release) "
"ã•ã‚Œã‚‹ã¾ã§ã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚è§£æ”¾ã¯ã©ã®ãƒ—ãƒ­ã‚»ã‚¹ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ã‚‚è¡Œãˆã¾ã™ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾ã—ã¦é©ç”¨ã•ã‚Œã‚‹ :class:`threading.Lock` "
"ã®ã‚³ãƒ³ã‚»ãƒ—ãƒˆã¨æŒ¯ã‚‹èˆã„ã¯ã€ç‰¹ç­†ã™ã¹ãã‚‚ã®ãŒãªã„é™ã‚Šã€ãƒ—ãƒ­ã‚»ã‚¹ã¨ã‚¹ãƒ¬ãƒƒãƒ‰ã«é©ç”¨ã•ã‚Œã‚‹ :class:`multiprocessing.Lock` "
"ã«å¼•ãç¶™ãŒã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1202
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ""
":class:`Lock` ã¯å®Ÿéš›ã«ã¯ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§åˆæœŸåŒ–ã•ã‚ŒãŸ "
"``multiprocessing.synchronize.Lock`` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1206
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`Lock` ã¯ :term:`context manager` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã¤ã¾ã‚Š :keyword:`with` "
"æ–‡ã§ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1211
#: ../../library/multiprocessing.rst:1262
msgid "Acquire a lock, blocking or non-blocking."
msgstr "ãƒ–ãƒ­ãƒƒã‚¯ã‚ã‚Šã€ã¾ãŸã¯ãƒ–ãƒ­ãƒƒã‚¯ãªã—ã§ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1213
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and"
" return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr ""
"å¼•æ•° *block* ã‚’ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) "
"ã«è¨­å®šã—ã¦å‘¼ã³å‡ºã—ãŸå ´åˆã€ãƒ­ãƒƒã‚¯ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰æŠœã‘ã‚‹ã¨ãã‚Œã‚’ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ã—ã¦ã‹ã‚‰ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"
" :meth:`threading.Lock.acquire` ã®æœ€åˆã®å¼•æ•°ã¨ã¯åå‰ãŒé•ã£ã¦ã„ã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1218
msgid ""
"With the *block* argument set to ``False``, the method call does not block."
"  If the lock is currently in a locked state, return ``False``; otherwise "
"set the lock to a locked state and return ``True``."
msgstr ""
"å¼•æ•° *block* ã®å€¤ã‚’ ``False`` ã«ã—ã¦å‘¼ã³å‡ºã™ã¨ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚ ç¾åœ¨ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã§ã‚ã‚Œã°ã€ç›´ã¡ã« ``False`` "
"ã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€ãƒ­ãƒƒã‚¯ã‚’ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ã—ã¦ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1222
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can"
" not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  Note that the "
"treatment of negative or ``None`` values for *timeout* differs from the "
"implemented behavior in :meth:`threading.Lock.acquire`.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed."
msgstr ""
"*timeout* ã¨ã—ã¦æ­£ã®æµ®å‹•å°æ•°ç‚¹æ•°ã‚’ä¸ãˆã¦å‘¼ã³å‡ºã™ã¨ã€ãƒ­ãƒƒã‚¯ãŒç²å¾—ã§ããªã„é™ã‚Šã€æŒ‡å®šã•ã‚ŒãŸç§’æ•°ã ã‘ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ *timeout* "
"å€¤ã«è² æ•°ã‚’ä¸ãˆã‚‹ã¨ã€ã‚¼ãƒ­ã‚’ä¸ãˆãŸå ´åˆã¨åŒã˜ã«ãªã‚Šã¾ã™ã€‚ *timeout* å€¤ã® ``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã‚’ä¸ãˆã‚‹ã¨ã€ç„¡é™ã«ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ "
"*timeout* å¼•æ•°ã®è² æ•°ã¨ ``None`` ã®æ‰±ã„ã¯ã€ :meth:`threading.Lock.acquire` "
"ã«å®Ÿè£…ã•ã‚ŒãŸå‹•ä½œã¨ç•°ãªã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ *block* ãŒ ``False`` ã®å ´åˆã€ *timeout* "
"ã¯å®Ÿéš›çš„ãªæ„å‘³ã‚’æŒãŸãªããªã‚‹ã®ã§ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ãŸå ´åˆã¯ ``True`` ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸå ´åˆã¯ ``False`` ã§æˆ»ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1237
msgid ""
"Release a lock.  This can be called from any process or thread, not only the"
" process or thread which originally acquired the lock."
msgstr "ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ã ã‘ã§ãªãã€ä»»æ„ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰å‘¼ã¶ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1240
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
":meth:`threading.Lock.release` ã¨åŒã˜ã‚ˆã†ã«æŒ¯èˆã„ã¾ã™ãŒã€ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„å ´åˆã«å‘¼ã³å‡ºã™ã¨ "
":exc:`ValueError` ã¨ãªã‚‹ç‚¹ã ã‘ãŒé•ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1246
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr ""
"å†å¸°ãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ :class:`threading.RLock` ç›¸å½“ã®ã‚‚ã®ã§ã™ã€‚å†å¸°ãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã‚Œã‚’ç²å¾— (acquire) "
"ã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ãŒè§£æ”¾ (release) "
"ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã‚’ã„ã£ãŸã‚“ç²å¾—ã™ã‚‹ã¨ã€åŒã˜ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œãšã«å†åº¦ç²å¾—å‡ºæ¥ã¾ã™ã€‚ãã®ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ç²å¾—ã—ãŸå›æ•°ã¶ã‚“è§£æ”¾ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1252
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default"
" context."
msgstr ""
":class:`RLock` ã¯å®Ÿéš›ã«ã¯ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§åˆæœŸåŒ–ã•ã‚ŒãŸ "
"``multiprocessing.synchronize.Lock`` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1256
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be"
" used in :keyword:`with` statements."
msgstr ""
":class:`RLock` ã¯ :term:`context manager` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã¤ã¾ã‚Š :keyword:`with`"
" æ–‡ã§ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1264
msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock"
" is in an unlocked state (not owned by any process or thread) unless the "
"lock is already owned by the current process or thread.  The current process"
" or thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation"
" of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr ""
"*block* å¼•æ•°ã‚’ ``True`` "
"ã«ã—ã¦å‘¼ã³å‡ºã—ãŸå ´åˆã€ãƒ­ãƒƒã‚¯ãŒæ—¢ã«ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãŒæ—¢ã«æ‰€æœ‰ã—ã¦ã„ãªã„é™ã‚Šã¯ã€ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ "
"(ã©ã®ãƒ—ãƒ­ã‚»ã‚¹ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‚‚æ‰€æœ‰ã—ã¦ã„ãªã„çŠ¶æ…‹) ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰æŠœã‘ã‚‹ã¨ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãŒ "
"(æ—¢ã«æŒã£ã¦ã„ãªã‘ã‚Œã°) æ‰€æœ‰æ¨©ã‚’å¾—ã¦ã€å†å¸°ãƒ¬ãƒ™ãƒ«ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã€ ``True`` ã§æˆ»ã‚Šã¾ã™ã€‚ "
":meth:`threading.RLock.acquire` "
"ã®å®Ÿè£…ã¨ã¯ã“ã®æœ€åˆã®å¼•æ•°ã®æŒ¯ã‚‹èˆã„ãŒã€ãã®åå‰è‡ªèº«ã‚’å§‹ã‚ã¨ã—ã¦ã„ãã¤ã‹é•ã†ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1274
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or"
" thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr ""
"*block* å¼•æ•°ã‚’ ``False`` ã«ã—ã¦å‘¼ã³å‡ºã—ãŸå ´åˆã€ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚ãƒ­ãƒƒã‚¯ãŒä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚ˆã‚Šç²å¾—æ¸ˆã¿ "
"(ã¤ã¾ã‚Šæ‰€æœ‰ã•ã‚Œã¦ã„ã‚‹) ã§ã‚ã‚Œã°ã€ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã¾ãŸã¯ã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ã¯æ‰€æœ‰æ¨©ã‚’å¾—ãšã€å†å¸°ãƒ¬ãƒ™ãƒ«ã‚‚å¤‰æ›´ã›ãšã«ã€ ``False`` "
"ã§æˆ»ã‚Šã¾ã™ã€‚ãƒ­ãƒƒã‚¯ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®å ´åˆã€ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ã¯æ‰€æœ‰æ¨©ã‚’å¾—ã¦å†å¸°ãƒ¬ãƒ™ãƒ«ãŒã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œã€ ``True`` "
"ã§æˆ»ã‚Šã¾ã™ã€‚(---è¨³æ³¨: *block* ã® True/False é–¢ä¿‚ãªãã“ã“ã§ã®èª¬æ˜ã§ã¯ã€Œæ‰€æœ‰æ¨©ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã®2åº¦ç›®ä»¥é™ã® "
"aquireã€ã®èª¬æ˜ãŒæ¬ ã‘ã¦ã„ã¾ã™ã€‚2åº¦ç›®ä»¥é™ã® acquire "
"ã§ã¯å†å¸°ãƒ¬ãƒ™ãƒ«ãŒã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œã¦å³åº§ã«è¿”ã‚Šã¾ã™ã€‚å…¨ä½“èª­ã‚ã°ã‚ã‹ã‚‹ã¨ã¯æ€ã„ã¾ã™ãŒä¸€å¿œã€‚---)"

#: ../../library/multiprocessing.rst:1282
msgid ""
"Use and behaviors of the *timeout* argument are the same as in "
":meth:`Lock.acquire`.  Note that some of these behaviors of *timeout* differ"
" from the implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"*timeout* å¼•æ•°ã®ä½¿ã„æ–¹ã¨æŒ¯ã‚‹èˆã„ã¯ :meth:`Lock.acquire` ã¨åŒã˜ã§ã™ã€‚ *timeout* å¼•æ•°ã®æŒ¯ã‚‹èˆã„ãŒã„ãã¤ã‹ã®ç‚¹ã§"
" :meth:`threading.RLock.acquire` ã¨ç•°ãªã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1289
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting"
" for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr ""
"å†å¸°ãƒ¬ãƒ™ãƒ«ã‚’ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã¾ã™ã€‚ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆå¾Œã«å†å¸°ãƒ¬ãƒ™ãƒ«ãŒã‚¼ãƒ­ã«ãªã£ãŸå ´åˆã€ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ "
"(ã„ã‹ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã€ã„ã‹ãªã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚‚æ‰€æœ‰ã•ã‚Œã¦ã„ãªã„çŠ¶æ…‹) "
"ã«ãƒªã‚»ãƒƒãƒˆã—ã€ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã«ãªã‚‹ã®ã‚’å¾…ã£ã¦ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã„ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚ã‚‹å ´åˆã«ã¯ãã®ä¸­ã®ãŸã ä¸€ã¤ã ã‘ãŒå‡¦ç†ã‚’é€²è¡Œã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆå¾Œã‚‚å†å¸°ãƒ¬ãƒ™ãƒ«ãŒã‚¼ãƒ­ã§ãªã„å ´åˆã€ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã¯ãƒ­ãƒƒã‚¯ã®ã¾ã¾ã§ã€å‘¼ã³å‡ºã—å´ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã«æ‰€æœ‰ã•ã‚ŒãŸã¾ã¾ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1297
msgid ""
"Only call this method when the calling process or thread owns the lock. An "
":exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å‘¼ã³å‡ºã—ãƒ—ãƒ­ã‚»ã‚¹ã‚ã‚‹ã„ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ­ãƒƒã‚¯ã‚’æ‰€æœ‰ã—ã¦ã„ã‚‹å ´åˆã«é™ã‚Šå‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚æ‰€æœ‰è€…ã§ãªã„ãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã—ãã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚ˆã£ã¦å‘¼ã°ã‚Œã‚‹ã‹ã€ã‚ã‚‹ã„ã¯ã‚¢ãƒ³ãƒ­ãƒƒã‚¯"
" (æœªæ‰€æœ‰) çŠ¶æ…‹ã§å‘¼ã°ã‚ŒãŸå ´åˆã€ :exc:`AssertionError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚åŒã˜çŠ¶æ³ã§ã® "
":meth:`threading.RLock.release` å®Ÿè£…ã¨ã¯ä¾‹å¤–ã®å‹ãŒç•°ãªã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1306
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr "ã‚»ãƒãƒ•ã‚©ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ: :class:`threading.Semaphore` ã®ã‚¯ãƒ­ãƒ¼ãƒ³ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1313
msgid ""
"On Mac OS X, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with"
" a timeout will emulate that function's behavior using a sleeping loop."
msgstr ""
"Mac OS X ã§ã¯ ``sem_timedwait`` ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã®ã§ã€``acquire()`` "
"ã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ä¸ãˆã¦å‘¼ã¶ã¨ã€ãƒ«ãƒ¼ãƒ—å†…ã§ã‚¹ãƒªãƒ¼ãƒ—ã™ã‚‹ã“ã¨ã§ã“ã®é–¢æ•°ãŒã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1318
msgid ""
"If the SIGINT signal generated by :kbd:`Ctrl-C` arrives while the main "
"thread is blocked by a call to :meth:`BoundedSemaphore.acquire`, "
":meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, "
":meth:`Condition.acquire` or :meth:`Condition.wait` then the call will be "
"immediately interrupted and :exc:`KeyboardInterrupt` will be raised."
msgstr ""
"ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ãŒ :meth:`BoundedSemaphore.acquire`, :meth:`Lock.acquire`, "
":meth:`RLock.acquire`, :meth:`Semaphore.acquire`, :meth:`Condition.acquire` "
"åˆã¯ :meth:`Condition.wait` ã‚’å‘¼ã³å‡ºã—ã¦ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°çŠ¶æ…‹ã®ã¨ãã« :kbd:`Ctrl-C` ã§ç”Ÿæˆã•ã‚Œã‚‹ SIGINT "
"ã‚·ã‚°ãƒŠãƒ«ã‚’å—ã‘å–ã‚‹ã¨ã€ãã®å‘¼ã³å‡ºã—ã¯ã™ãã«ä¸­æ–­ã•ã‚Œã¦ :exc:`KeyboardInterrupt` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1324
msgid ""
"This differs from the behaviour of :mod:`threading` where SIGINT will be "
"ignored while the equivalent blocking calls are in progress."
msgstr ""
"ã“ã‚Œã¯åŒç­‰ã®ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°å‘¼ã³å‡ºã—ãŒå®Ÿè¡Œä¸­ã®ã¨ãã« SIGINT ãŒç„¡è¦–ã•ã‚Œã‚‹ :mod:`threading` ã®æŒ¯ã‚‹èˆã„ã¨ã¯é•ã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1329
msgid ""
"Some of this package's functionality requires a functioning shared semaphore"
" implementation on the host operating system. Without one, the "
":mod:`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"ã“ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å«ã¾ã‚Œã‚‹æ©Ÿèƒ½ã«ã¯ã€ãƒ›ã‚¹ãƒˆã¨ãªã‚‹ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ä¸Šã§å‹•ä½œã—ã¦ã„ã‚‹å…±æœ‰ã‚»ãƒãƒ•ã‚©ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚ŒãŒä½¿ç”¨ã§ããªã„å ´åˆã«ã¯ã€:mod:`multiprocessing.synchronize`"
" ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒç„¡åŠ¹ã«ãªã‚Šã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ™‚ã« :exc:`ImportError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚è©³ç´°ã¯ :issue:`3770` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1337
msgid "Shared :mod:`ctypes` Objects"
msgstr "å…±æœ‰ :mod:`ctypes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/multiprocessing.rst:1339
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr "å­ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚ˆã‚Šç¶™æ‰¿ã•ã‚Œã‚‹å…±æœ‰ãƒ¡ãƒ¢ãƒªã‚’ä½¿ç”¨ã™ã‚‹å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1344
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object.  The object "
"itself can be accessed via the *value* attribute of a :class:`Value`."
msgstr ""
"å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸ :mod:`ctypes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ "
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€è¿”ã‚Šå€¤ã¯å®Ÿéš›ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŒæœŸãƒ©ãƒƒãƒ‘ãƒ¼ã§ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãã‚Œè‡ªèº«ã¯ã€ :class:`Value` ã® *value* "
"å±æ€§ã«ã‚ˆã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1348
#: ../../library/multiprocessing.rst:1435
msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the "
":mod:`array` module.  *\\*args* is passed on to the constructor for the "
"type."
msgstr ""
"*typecode_or_type* ã¯è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’æ±ºã‚ã¾ã™ã€‚ãã‚Œã¯ ctypes ã®å‹ã‹ :mod:`array` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä½¿ç”¨ã•ã‚Œã‚‹ã‚ˆã†ãª1æ–‡å­—ã®å‹ã‚³ãƒ¼ãƒ‰ã‹ã®ã©ã¡ã‚‰ã‹ä¸€æ–¹ã§ã™ã€‚ *\\*args* ã¯å‹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã¸æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1352
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` or"
" :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"*lock* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã€å€¤ã¸åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«æ–°ãŸã«å†å¸°çš„ãªãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã•ã‚Œã¾ã™ã€‚ *lock* ãŒ "
":class:`Lock` ã‹ :class:`RLock` ãªã‚‰å€¤ã¸ã®åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ *lock* ãŒ ``False`` "
"ãªã‚‰ã€è¿”ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ãƒ­ãƒƒã‚¯ã«ã‚ˆã‚Šè‡ªå‹•çš„ã«ä¿è­·ã•ã‚Œã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€å¿…ãšã—ã‚‚ \"ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•\" ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1359
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr ""
"``+=`` "
"ã®ã‚ˆã†ãªæ¼”ç®—ã¯ã€èª­ã¿è¾¼ã¿ã¨æ›¸ãè¾¼ã¿ã‚’å«ã‚€ãŸã‚ã‚¢ãƒˆãƒŸãƒƒã‚¯ã§ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ãŸã‚ã€ãŸã¨ãˆã°è‡ªå‹•çš„ã«å…±æœ‰ã®å€¤ã‚’å¢—åŠ ã•ã›ãŸã„å ´åˆã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã™ã‚‹ã®ã§ã¯ä¸ååˆ†ã§ã™"
" ::"

#: ../../library/multiprocessing.rst:1365
msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr "é–¢é€£ã™ã‚‹ãƒ­ãƒƒã‚¯ãŒå†å¸°çš„ (ãã‚ŒãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã™) ãªã‚‰ã€ã‹ã‚ã‚Šã«æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™ ::"

#: ../../library/multiprocessing.rst:1371
#: ../../library/multiprocessing.rst:1461
#: ../../library/multiprocessing.rst:1476
msgid "Note that *lock* is a keyword-only argument."
msgstr "*lock* ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã§ã®ã¿æŒ‡å®šã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1375
msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr "å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸ ctypes é…åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€è¿”ã‚Šå€¤ã¯å®Ÿéš›ã®é…åˆ—ã®åŒæœŸãƒ©ãƒƒãƒ‘ãƒ¼ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1378
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* ã¯è¿”ã•ã‚Œã‚‹é…åˆ—ã®è¦ç´ ã®å‹ã‚’æ±ºã‚ã¾ã™ã€‚ãã‚Œã¯ ctypes ã®å‹ã‹ :mod:`array` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä½¿ç”¨ã•ã‚Œã‚‹ã‚ˆã†ãª1æ–‡å­—ã®å‹ã‚³ãƒ¼ãƒ‰ã‹ã®ã©ã¡ã‚‰ã‹ä¸€æ–¹ã§ã™ã€‚ *size_or_initializer* "
"ãŒæ•´æ•°ãªã‚‰ã€é…åˆ—ã®é•·ã•ã‚’æ±ºå®šã—ã€ãã®é…åˆ—ã¯ã‚¼ãƒ­ã§åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚åˆ¥ã®ä½¿ç”¨æ–¹æ³•ã¨ã—ã¦ *size_or_initializer* "
"ã¯é…åˆ—ã®åˆæœŸåŒ–ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ãªã‚Šã€ãã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹é•·ãŒé…åˆ—ã®é•·ã•ã‚’æ±ºå®šã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1385
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or "
":class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"*lock* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã€å€¤ã¸åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«æ–°ãŸãªãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã•ã‚Œã¾ã™ã€‚ *lock* ãŒ "
":class:`Lock` ã‹ :class:`RLock` ãªã‚‰å€¤ã¸ã®åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ *lock* ãŒ ``False`` "
"ãªã‚‰ã€è¿”ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ãƒ­ãƒƒã‚¯ã«ã‚ˆã‚Šè‡ªå‹•çš„ã«ä¿è­·ã•ã‚Œã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€å¿…ãšã—ã‚‚ \"ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•\" ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1392
msgid "Note that *lock* is a keyword only argument."
msgstr "*lock* ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ã—ã¦ã®ã¿åˆ©ç”¨å¯èƒ½ãªã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1394
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes"
" which allow one to use it to store and retrieve strings."
msgstr ""
":data:`ctypes.c_char` ã®é…åˆ—ã¯æ–‡å­—åˆ—ã‚’æ ¼ç´ã—ã¦å–ã‚Šå‡ºã›ã‚‹ *value* ã¨ *raw* "
"å±æ€§ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1399
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr ":mod:`multiprocessing.sharedctypes` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/multiprocessing.rst:1404
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ""
":mod:`multiprocessing.sharedctypes` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å­ãƒ—ãƒ­ã‚»ã‚¹ã«ç¶™æ‰¿ã•ã‚Œã‚‹å…±æœ‰ãƒ¡ãƒ¢ãƒªã® :mod:`ctypes` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰²ã‚Šå½“ã¦ã‚‹é–¢æ•°ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1410
msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process"
" may cause a crash."
msgstr ""
"å…±æœ‰ãƒ¡ãƒ¢ãƒªã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’æ ¼ç´ã™ã‚‹ã“ã¨ã¯å¯èƒ½ã§ã¯ã‚ã‚Šã¾ã™ãŒã€ç‰¹å®šãƒ—ãƒ­ã‚»ã‚¹ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ç©ºé–“ã®ä½ç½®ã‚’å‚ç…§ã™ã‚‹ã¨ã„ã†ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚ã—ã‹ã—ã€ãã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¯åˆ¥ã®ãƒ—ãƒ­ã‚»ã‚¹ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ãŠã„ã¦ç„¡åŠ¹ã«ãªã‚‹ç¢ºç‡ãŒé«˜ã„ã§ã™ã€‚ãã—ã¦ã€åˆ¥ã®ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ãã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’é€†å‚ç…§ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã‚’å¼•ãèµ·ã“ã™å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1418
msgid "Return a ctypes array allocated from shared memory."
msgstr "å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸ ctypes é…åˆ—ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1420
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* ã¯è¿”ã•ã‚Œã‚‹é…åˆ—ã®è¦ç´ ã®å‹ã‚’æ±ºã‚ã¾ã™ã€‚ãã‚Œã¯ ctypes ã®å‹ã‹ :mod:`array` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä½¿ç”¨ã•ã‚Œã‚‹ã‚ˆã†ãª1æ–‡å­—ã®å‹ã‚³ãƒ¼ãƒ‰ã®ã©ã¡ã‚‰ã‹ä¸€æ–¹ã§ã™ã€‚ *size_or_initializer* "
"ãŒæ•´æ•°ãªã‚‰ã€ãã‚ŒãŒé…åˆ—ã®é•·ã•ã«ãªã‚Šã€ãã®é…åˆ—ã¯ã‚¼ãƒ­ã§åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚åˆ¥ã®ä½¿ç”¨æ–¹æ³•ã¨ã—ã¦ *size_or_initializer* "
"ã«ã¯é…åˆ—ã®åˆæœŸåŒ–ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã€ãã®å ´åˆã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒé…åˆ—ã®é•·ã•ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1427
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use "
":func:`Array` instead to make sure that access is automatically synchronized"
" using a lock."
msgstr ""
"è¦ç´ ã‚’å–å¾—ã—ãŸã‚Šè¨­å®šã—ãŸã‚Šã™ã‚‹ã“ã¨ã¯æ½œåœ¨çš„ã«éã‚¢ãƒˆãƒŸãƒƒã‚¯ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãƒ­ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¦è‡ªå‹•çš„ã«åŒæœŸåŒ–ã•ã‚ŒãŸã‚¢ã‚¯ã‚»ã‚¹ã‚’ä¿è¨¼ã™ã‚‹ã«ã¯ "
":func:`Array` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1433
msgid "Return a ctypes object allocated from shared memory."
msgstr "å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸ ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1439
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use "
":func:`Value` instead to make sure that access is automatically synchronized"
" using a lock."
msgstr ""
"å€¤ã‚’å–å¾—ã—ãŸã‚Šè¨­å®šã—ãŸã‚Šã™ã‚‹ã“ã¨ã¯æ½œåœ¨çš„ã«éã‚¢ãƒˆãƒŸãƒƒã‚¯ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãƒ­ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¦è‡ªå‹•çš„ã«åŒæœŸåŒ–ã•ã‚ŒãŸã‚¢ã‚¯ã‚»ã‚¹ã‚’ä¿è¨¼ã™ã‚‹ã«ã¯ "
":func:`Value` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1443
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ""
":data:`ctypes.c_char` ã®é…åˆ—ã¯æ–‡å­—åˆ—ã‚’æ ¼ç´ã—ã¦å–ã‚Šå‡ºã›ã‚‹ ``value`` ã¨ ``raw`` "
"å±æ€§ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚è©³ç´°ã¯ :mod:`ctypes` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1449
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes"
" array."
msgstr ""
":func:`RawArray` ã¨åŒæ§˜ã§ã™ãŒã€ *lock* ã®å€¤ã«ã‚ˆã£ã¦ã¯ ctypes "
"é…åˆ—ã‚’ãã®ã¾ã¾è¿”ã™ä»£ã‚ã‚Šã«ã€ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•ãªåŒæœŸãƒ©ãƒƒãƒ‘ãƒ¼ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1453
#: ../../library/multiprocessing.rst:1469
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a "
":class:`~multiprocessing.Lock` or :class:`~multiprocessing.RLock` object "
"then that will be used to synchronize access to the value.  If *lock* is "
"``False`` then access to the returned object will not be automatically "
"protected by a lock, so it will not necessarily be \"process-safe\"."
msgstr ""
"*lock* ãŒ ``True`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã€å€¤ã¸åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«æ–°ãŸãª ãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã•ã‚Œã¾ã™ã€‚ *lock* ãŒ "
":class:`~multiprocessing.Lock` ã‹ :class:`~multiprocessing.RLock` "
"ãªã‚‰å€¤ã¸ã®åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ *lock* ãŒ ``False`` ãªã‚‰ã€è¿”ã•ã‚ŒãŸ "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ãƒ­ãƒƒã‚¯ã«ã‚ˆã‚Šè‡ªå‹•çš„ã«ä¿è­·ã•ã‚Œã¾ã›ã‚“ã€‚ ãã®ãŸã‚ã€å¿…ãšã—ã‚‚ \"ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•\" ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1465
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes"
" object."
msgstr ""
":func:`RawValue` ã¨åŒæ§˜ã§ã™ãŒã€ *lock* ã®å€¤ã«ã‚ˆã£ã¦ã¯ ctypes "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãã®ã¾ã¾è¿”ã™ä»£ã‚ã‚Šã«ã€ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•ãªåŒæœŸãƒ©ãƒƒãƒ‘ãƒ¼ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1480
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr "å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸ ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *obj* ã‚’ã‚³ãƒ”ãƒ¼ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1485
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a "
":class:`multiprocessing.RLock` object is created automatically."
msgstr ""
"åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã« *lock* ã‚’ä½¿ç”¨ã™ã‚‹ ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãŸã‚ã«ãƒ—ãƒ­ã‚»ã‚¹ã‚»ãƒ¼ãƒ•ãªãƒ©ãƒƒãƒ‘ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ *lock* ãŒ "
"``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã€ :class:`multiprocessing.RLock` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè‡ªå‹•çš„ã«ä½œæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1489
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and "
":meth:`get_lock` returns the lock object used for synchronization."
msgstr ""
"åŒæœŸãƒ©ãƒƒãƒ‘ãƒ¼ãŒãƒ©ãƒƒãƒ—ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åŠ ãˆã¦2ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚ :meth:`get_obj` ã¯ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ "
":meth:`get_lock` ã¯åŒæœŸã®ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1493
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr ""
"ãƒ©ãƒƒãƒ‘ãƒ¼çµŒç”±ã§ ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã¯ raw ctypes "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã‚ˆã‚Šãšã£ã¨é…ããªã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1496
msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr ""
"synchronized ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :term:`ã‚³ãƒ³ãƒ†ã‚¯ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ <context manager>` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1500
msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr ""
"æ¬¡ã®è¡¨ã¯é€šå¸¸ã® ctypes æ§‹æ–‡ã§å…±æœ‰ãƒ¡ãƒ¢ãƒªã‹ã‚‰å…±æœ‰ ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ãŸã‚ã®æ§‹æ–‡ã‚’æ¯”è¼ƒã—ã¾ã™ã€‚ (``MyStruct`` "
"ãƒ†ãƒ¼ãƒ–ãƒ«å†…ã«ã¯ :class:`ctypes.Structure` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒã‚ã‚Šã¾ã™ã€‚)"

#: ../../library/multiprocessing.rst:1505
msgid "ctypes"
msgstr "ctypes"

#: ../../library/multiprocessing.rst:1505
msgid "sharedctypes using type"
msgstr "type ã‚’ä½¿ç”¨ã™ã‚‹ sharedctypes"

#: ../../library/multiprocessing.rst:1505
msgid "sharedctypes using typecode"
msgstr "typecode ã‚’ä½¿ç”¨ã™ã‚‹ sharedctypes"

#: ../../library/multiprocessing.rst:1507
msgid "c_double(2.4)"
msgstr "c_double(2.4)"

#: ../../library/multiprocessing.rst:1507
msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2.4)"

#: ../../library/multiprocessing.rst:1507
msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

#: ../../library/multiprocessing.rst:1508
msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

#: ../../library/multiprocessing.rst:1508
msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

#: ../../library/multiprocessing.rst:1509
msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

#: ../../library/multiprocessing.rst:1509
msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

#: ../../library/multiprocessing.rst:1509
msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

#: ../../library/multiprocessing.rst:1510
msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

#: ../../library/multiprocessing.rst:1510
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

#: ../../library/multiprocessing.rst:1510
msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray('i', (9, 2, 8))"

#: ../../library/multiprocessing.rst:1514
msgid ""
"Below is an example where a number of ctypes objects are modified by a child"
" process::"
msgstr "ä»¥ä¸‹ã«å­ãƒ—ãƒ­ã‚»ã‚¹ãŒå¤šãã® ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¤‰æ›´ã™ã‚‹ä¾‹ã‚’ç´¹ä»‹ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:1552
msgid "The results printed are ::"
msgstr "çµæœã¯ä»¥ä¸‹ã®ã‚ˆã†ã«è¡¨ç¤ºã•ã‚Œã¾ã™ ::"

#: ../../library/multiprocessing.rst:1565
msgid "Managers"
msgstr "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼"

#: ../../library/multiprocessing.rst:1567
msgid ""
"Managers provide a way to create data which can be shared between different "
"processes, including sharing over a network between processes running on "
"different machines. A manager object controls a server process which manages"
" *shared objects*.  Other processes can access the shared objects by using "
"proxies."
msgstr ""
"ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¯ç•°ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹é–“ã§å…±æœ‰ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆæ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã‚Œã«ã¯åˆ¥ã®ãƒã‚·ãƒ³ä¸Šã§èµ°ã‚‹ãƒ—ãƒ­ã‚»ã‚¹é–“ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¶Šã—ã®å…±æœ‰ã‚‚å«ã¾ã‚Œã¾ã™ã€‚ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯"
" *å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ* ã‚’ç®¡ç†ã™ã‚‹ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1575
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr ""
"ãƒ—ãƒ­ã‚»ã‚¹é–“ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å…±æœ‰ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ :class:`~multiprocessing.managers.SyncManager` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚è¿”ã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ç”Ÿæˆã•ã‚Œã‚‹å­ãƒ—ãƒ­ã‚»ã‚¹ã«å¯¾å¿œä»˜ã‘ã‚‰ã‚Œã€å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚„ã€å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾å¿œã™ã‚‹ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1583
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the "
":mod:`multiprocessing.managers` module:"
msgstr ""
"ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã¯è¦ªãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã™ã‚‹ã‹ã€ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹ã¨åœæ­¢ã—ã¾ã™ã€‚ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¯ãƒ©ã‚¹ã¯ "
":mod:`multiprocessing.managers` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™:"

#: ../../library/multiprocessing.rst:1589
msgid "Create a BaseManager object."
msgstr "BaseManager ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1591
msgid ""
"Once created one should call :meth:`start` or "
"``get_server().serve_forever()`` to ensure that the manager object refers to"
" a started manager process."
msgstr ""
"ä½œæˆå¾Œã€:meth:`start` ã¾ãŸã¯ ``get_server().serve_forever()`` "
"ã‚’å‘¼ã³å‡ºã—ã¦ã€ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã€é–‹å§‹ã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç¢ºå®Ÿã«å‚ç…§ã™ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1594
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr ""
"*address* ã¯ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒæ–°ãŸãªã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’å¾…ã¡å—ã‘ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚*address* ãŒ ``None`` "
"ã®å ´åˆã€ä»»æ„ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1597
msgid ""
"*authkey* is the authentication key which will be used to check the validity"
" of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey`` is used. Otherwise *authkey* is used and "
"it must be a byte string."
msgstr ""
"*authkey* ã¯ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã¸æ¥ç¶šã—ã‚ˆã†ã¨ã™ã‚‹ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®æ­£å½“æ€§ã‚’æ¤œè¨¼ã™ã‚‹ãŸã‚ã« ä½¿ç”¨ã•ã‚Œã‚‹èªè¨¼ã‚­ãƒ¼ã§ã™ã€‚*authkey* ãŒ "
"``None`` ã®å ´åˆ ``current_process().authkey`` ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚*authkey* "
"ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1604
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr ""
"ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’é–‹å§‹ã™ã‚‹ãŸã‚ã«ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã—ã¾ã™ã€‚*initializer* ãŒ ``None`` ã§ãªã‘ã‚Œã°ã€ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã¯é–‹å§‹æ™‚ã« "
"``initializer(*initargs)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1609
msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the "
":meth:`serve_forever` method::"
msgstr ""
"ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆ¶å¾¡ä¸‹ã«ã‚ã‚‹å®Ÿéš›ã®ã‚µãƒ¼ãƒãƒ¼ã‚’è¡¨ã™ :class:`Server` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ :class:`Server` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯"
" :meth:`serve_forever` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™::"

#: ../../library/multiprocessing.rst:1618
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` ã¯ã•ã‚‰ã« :attr:`address` å±æ€§ã‚‚æŒã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1622
msgid "Connect a local manager object to a remote manager process::"
msgstr "ãƒ­ãƒ¼ã‚«ãƒ«ã‹ã‚‰ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸æ¥ç¶šã—ã¾ã™::"

#: ../../library/multiprocessing.rst:1630
msgid ""
"Stop the process used by the manager.  This is only available if "
":meth:`start` has been used to start the server process."
msgstr ""
"ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒä½¿ç”¨ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‚’åœæ­¢ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã™ã‚‹ãŸã‚ã« :meth:`start` ãŒä½¿ç”¨ã•ã‚ŒãŸå ´åˆã®ã¿æœ‰åŠ¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1633
msgid "This can be called multiple times."
msgstr "ã“ã‚Œã¯è¤‡æ•°å›å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1637
msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¯ãƒ©ã‚¹ã§å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ(callable)ã‚„å‹ã‚’ç™»éŒ²ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1640
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr "*typeid* ã¯ç‰¹ã«å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ \"å‹è­˜åˆ¥å­\" ã§ã™ã€‚ã“ã‚Œã¯æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1643
msgid ""
"*callable* is a callable used for creating objects for this type identifier."
"  If a manager instance will be connected to the server using the "
":meth:`connect` method, or if the *create_method* argument is ``False`` then"
" this can be left as ``None``."
msgstr ""
"*callable* ã¯ã“ã®å‹è­˜åˆ¥å­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ "
":meth:`connect` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ã€ *create_method* å¼•æ•°ãŒ ``False`` ã®å ´åˆã¯ã€ "
"``None`` ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:1649
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""
"*proxytype* ã¯ã“ã® *typeid* ã§å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ã‚­ã‚·ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ :class:`BaseProxy` "
"ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ ``None`` ã®å ´åˆã€ãƒ—ãƒ­ã‚­ã‚·ã‚¯ãƒ©ã‚¹ã¯è‡ªå‹•çš„ã«ä½œæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1653
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy._callmethod`."
"  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is used instead"
" if it exists.)  In the case where no exposed list is specified, all "
"\"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr ""
"*exposed* ã¯ :meth:`BaseProxy._callmethod` ã‚’ä½¿ç”¨ã—ãŸã‚¢ã‚¯ã‚»ã‚¹ãŒè¨±ã•ã‚Œã‚‹ã¹ã typeid "
"ã‚’ãƒ—ãƒ­ã‚­ã‚·ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰åã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ (*exposed* ãŒ ``None`` ã®å ´åˆ "
":attr:`proxytype._exposed_` ãŒå­˜åœ¨ã™ã‚Œã°ãã‚ŒãŒä»£ã‚ã‚Šã«ä½¿ç”¨ã•ã‚Œã¾ã™)ã€‚*exposed* "
"ãƒªã‚¹ãƒˆãŒæŒ‡å®šã•ã‚Œãªã„å ´åˆã€å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã™ã¹ã¦ã® \"ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰\" ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚ (ã“ã“ã§ã„ã† \"ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰\" "
"ã¨ã¯ :meth:`~object.__call__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚‚ã®ã¨åå‰ãŒ ``'_'`` ã§å§‹ã¾ã‚‰ãªã„ã‚ã‚‰ã‚†ã‚‹å±æ€§ã‚’æ„å‘³ã—ã¾ã™ã€‚)"

#: ../../library/multiprocessing.rst:1662
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid"
" strings.  (If *method_to_typeid* is ``None`` then "
":attr:`proxytype._method_to_typeid_` is used instead if it exists.)  If a "
"method's name is not a key of this mapping or if the mapping is ``None`` "
"then the object returned by the method will be copied by value."
msgstr ""
"*method_to_typeid* ã¯ãƒ—ãƒ­ã‚­ã‚·ãŒè¿”ã™ exposed ãƒ¡ã‚½ãƒƒãƒ‰ã®è¿”ã‚Šå€¤ã®å‹ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒãƒƒãƒ”ãƒ³ã‚°ã§ã€ãƒ¡ã‚½ãƒƒãƒ‰åã‚’ "
"typeid æ–‡å­—åˆ—ã«ãƒãƒƒãƒ—ã—ã¾ã™ã€‚ (*method_to_typeid* ãŒ ``None`` ã®å ´åˆ "
":attr:`proxytype._method_to_typeid_` ãŒå­˜åœ¨ã™ã‚Œã°ã€ãã‚ŒãŒä»£ã‚ã‚Šã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚) "
"ãƒ¡ã‚½ãƒƒãƒ‰åãŒã“ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã®ã‚­ãƒ¼ã§ã¯ãªã„ã‹ã€ãƒãƒƒãƒ”ãƒ³ã‚°ãŒ ``None`` ã®å ´åˆã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå€¤ã¨ã—ã¦ (by "
"value) ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1669
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared"
" object and return a proxy for it.  By default it is ``True``."
msgstr ""
"*create_method* ã¯ã€å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã€ãã‚Œã«å¯¾ã™ã‚‹ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã™ã‚ˆã†ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã«ä¼ãˆã‚‹ã€åå‰ *typeid* "
"ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½œæˆã™ã‚‹ã‹ã‚’æ±ºå®šã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``True`` ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1673
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ":class:`BaseManager` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚‚èª­ã¿å‡ºã—å°‚ç”¨å±æ€§ã‚’1ã¤æŒã£ã¦ã„ã¾ã™:"

#: ../../library/multiprocessing.rst:1677
msgid "The address used by the manager."
msgstr "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒä½¿ç”¨ã™ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1679
msgid ""
"Manager objects support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the "
"server process (if it has not already started) and then returns the manager "
"object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""
"ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆãƒ»ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ -- :ref:`typecontextmanager` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ :meth:`~contextmanager.__enter__` ã¯ (ã¾ã é–‹å§‹ã—ã¦ã„ãªã„å ´åˆ) "
"ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã—ã¦ã‹ã‚‰ã€ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ :meth:`~contextmanager.__exit__` ã¯ "
":meth:`shutdown` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1685
msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr ""
"æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ :meth:`~contextmanager.__enter__` "
"ã¯ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒã¾ã é–‹å§‹ã—ã¦ã„ãªã‹ã£ãŸå ´åˆã§ã‚‚ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã—ã¾ã›ã‚“ã§ã—ãŸã€‚"

#: ../../library/multiprocessing.rst:1690
msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization"
" of processes.  Objects of this type are returned by "
":func:`multiprocessing.Manager`."
msgstr ""
"ãƒ—ãƒ­ã‚»ã‚¹é–“ã®åŒæœŸã®ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ :class:`BaseManager` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ "
":func:`multiprocessing.Manager` ã¯ã“ã®å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1694
msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. This"
" notably includes shared lists and dictionaries."
msgstr ""

#: ../../library/multiprocessing.rst:1700
msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for it."
msgstr "å…±æœ‰ :class:`threading.Barrier` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1707
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr "å…±æœ‰ :class:`threading.BoundedSemaphore` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1712
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr "å…±æœ‰ :class:`threading.Condition` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1715
msgid ""
"If *lock* is supplied then it should be a proxy for a "
":class:`threading.Lock` or :class:`threading.RLock` object."
msgstr ""
"*lock* ãŒæä¾›ã•ã‚Œã‚‹å ´åˆ :class:`threading.Lock` ã‹ :class:`threading.RLock` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãŸã‚ã®ãƒ—ãƒ­ã‚­ã‚·ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1723
msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr "å…±æœ‰ :class:`threading.Event` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1727
msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr "å…±æœ‰ :class:`threading.Lock` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1731
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr "å…±æœ‰ :class:`Namespace` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1735
msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr "å…±æœ‰ :class:`queue.Queue` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1739
msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr "å…±æœ‰ :class:`threading.RLock` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1743
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr "å…±æœ‰ :class:`threading.Semaphore` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1748
msgid "Create an array and return a proxy for it."
msgstr "é…åˆ—ã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1752
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr "æ›¸ãè¾¼ã¿å¯èƒ½ãª ``value`` å±æ€§ã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1759
msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr "å…±æœ‰ :class:`dict` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1764
msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr "å…±æœ‰ :class:`list` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€ãã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1766
msgid ""
"Shared objects are capable of being nested.  For example, a shared container"
" object such as a shared list can contain other shared objects which will "
"all be managed and synchronized by the :class:`SyncManager`."
msgstr ""
"å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å…¥ã‚Œå­ã‚‚ã§ãã¾ã™ã€‚\n"
"ä¾‹ãˆã°ã€å…±æœ‰ãƒªã‚¹ãƒˆã®ã‚ˆã†ãªå…±æœ‰ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ :class:`SyncManager` ãŒã¾ã¨ã‚ã¦ç®¡ç†ã—åŒæœŸã‚’å–ã£ã¦ã„ã‚‹ä»–ã®å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿æŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1773
msgid "A type that can register with :class:`SyncManager`."
msgstr ":class:`SyncManager` ã«ç™»éŒ²ã™ã‚‹ã“ã¨ã®ã§ãã‚‹å‹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1775
msgid ""
"A namespace object has no public methods, but does have writable attributes."
" Its representation shows the values of its attributes."
msgstr ""
"Namespace ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãªãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€æ›¸ãè¾¼ã¿å¯èƒ½ãªå±æ€§ã‚’æŒã¡ã¾ã™ã€‚ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¾ã¯ãã®å±æ€§ã®å€¤ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1778
msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr ""
"ã—ã‹ã—ã€Namespace ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãŸã‚ã«ãƒ—ãƒ­ã‚­ã‚·ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã ``'_'`` "
"ãŒå…ˆé ­ã«ä»˜ãå±æ€§ã¯ãƒ—ãƒ­ã‚­ã‚·ã®å±æ€§ã«ãªã‚Šã€å‚ç…§å¯¾è±¡ã®å±æ€§ã«ã¯ãªã‚Šã¾ã›ã‚“:"

#: ../../library/multiprocessing.rst:1794
msgid "Customized managers"
msgstr "ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼"

#: ../../library/multiprocessing.rst:1796
msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types"
" or callables with the manager class.  For example::"
msgstr ""
"ç‹¬è‡ªã®ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ä½œæˆã™ã‚‹ã«ã¯ã€:class:`BaseManager` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ã¦ã€ "
"ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¯ãƒ©ã‚¹ã§å‘¼ã³å‡ºã—å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹æ–°ãŸãªå‹ã‚’ç™»éŒ²ã™ã‚‹ãŸã‚ã« :meth:`~BaseManager.register` "
"ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/multiprocessing.rst:1821
msgid "Using a remote manager"
msgstr "ãƒªãƒ¢ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹"

#: ../../library/multiprocessing.rst:1823
msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr ""
"ã‚ã‚‹ãƒã‚·ãƒ³ä¸Šã§ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚µãƒ¼ãƒãƒ¼ã‚’å®Ÿè¡Œã—ã¦ã€ä»–ã®ãƒã‚·ãƒ³ã‹ã‚‰ãã®ã‚µãƒ¼ãƒãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’æŒã¤ã“ã¨ãŒã§ãã¾ã™(ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã‚’é€šéã§ãã‚‹ã“ã¨ãŒå‰æ)ã€‚"

#: ../../library/multiprocessing.rst:1826
msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr "æ¬¡ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ãƒªãƒ¢ãƒ¼ãƒˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã‚’å—ã‘ä»˜ã‘ã‚‹1ã¤ã®å…±æœ‰ã‚­ãƒ¥ãƒ¼ã®ãŸã‚ã«ã‚µãƒ¼ãƒãƒ¼ã‚’ä½œæˆã—ã¾ã™::"

#: ../../library/multiprocessing.rst:1838
msgid "One client can access the server as follows::"
msgstr "ã‚ã‚‹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã‚µãƒ¼ãƒãƒ¼ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/multiprocessing.rst:1848
msgid "Another client can also use it::"
msgstr "åˆ¥ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚‚ãã‚Œã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/multiprocessing.rst:1859
msgid ""
"Local processes can also access that queue, using the code from above on the"
" client to access it remotely::"
msgstr "ãƒ­ãƒ¼ã‚«ãƒ«ãƒ—ãƒ­ã‚»ã‚¹ã‚‚ãã®ã‚­ãƒ¥ãƒ¼ã¸ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆä¸Šã§ä¸Šè¿°ã®ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:1884
msgid "Proxy Objects"
msgstr "Proxy ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/multiprocessing.rst:1886
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr ""
"ãƒ—ãƒ­ã‚­ã‚·ã¯åˆ¥ã®ãƒ—ãƒ­ã‚»ã‚¹ã§(ãŠãã‚‰ã)æœ‰åŠ¹ãªå…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ *å‚ç…§ã™ã‚‹* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ­ã‚­ã‚·ã® *å‚ç…§å¯¾è±¡* "
"ã«ãªã‚‹ã¨ã„ã†ã“ã¨ãŒã§ãã¾ã™ã€‚è¤‡æ•°ã®ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒåŒã˜å‚ç…§å¯¾è±¡ã‚’æŒã¤å¯èƒ½æ€§ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1890
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like "
"its referent can:"
msgstr ""
"ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã®å‚ç…§å¯¾è±¡ã®å¯¾å¿œã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¡ã¾ã™ (ãã†ã¯è¨€ã£ã¦ã‚‚ã€å‚ç…§å¯¾è±¡ã®ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¿…ãšã—ã‚‚ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§åˆ©ç”¨å¯èƒ½ãªã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“)ã€‚\n"
"ã“ã®æ–¹æ³•ã§ã€ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã¾ã‚‹ã§ãã®å‚ç…§å…ˆã¨åŒã˜ã‚ˆã†ã«ä½¿ãˆã¾ã™:"

#: ../../library/multiprocessing.rst:1908
msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr ""
"ãƒ—ãƒ­ã‚­ã‚·ã« :func:`str` ã‚’é©ç”¨ã™ã‚‹ã¨å‚ç…§å¯¾è±¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¾ã‚’è¿”ã™ã®ã«å¯¾ã—ã¦ã€ :func:`repr` "
"ã‚’é©ç”¨ã™ã‚‹ã¨ãƒ—ãƒ­ã‚­ã‚·ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¾ã‚’è¿”ã™ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1912
msgid ""
"An important feature of proxy objects is that they are picklable so they can"
" be passed between processes.  As such, a referent can contain :ref"
":`multiprocessing-proxy_objects`.  This permits nesting of these managed "
"lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""
"ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é‡è¦ãªæ©Ÿèƒ½ã¯ pickle åŒ–ãŒã§ãã‚‹ã“ã¨ã§ã€ã“ã‚Œã«ã‚ˆã‚Šãƒ—ãƒ­ã‚»ã‚¹é–“ã§ã®å—ã‘æ¸¡ã—ãŒã§ãã¾ã™ã€‚\n"
"ãã®ãŸã‚ã€å‚ç…§å¯¾è±¡ãŒ :ref:`multiprocessing-proxy_objects` ã‚’æŒã¦ã¾ã™ã€‚\n"
"ã“ã‚Œã«ã‚ˆã£ã¦ç®¡ç†ã•ã‚ŒãŸãƒªã‚¹ãƒˆã€è¾æ›¸ã€ãã®ä»– :ref:`multiprocessing-proxy_objects` ã‚’ãƒã‚¹ãƒˆã§ãã¾ã™:"

#: ../../library/multiprocessing.rst:1928
msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr "åŒæ§˜ã«ã€è¾æ›¸ã¨ãƒªã‚¹ãƒˆã®ãƒ—ãƒ­ã‚­ã‚·ã‚‚ä»–ã®ãƒ—ãƒ­ã‚­ã‚·ã®å†…éƒ¨ã«å…¥ã‚Œã¦ãƒã‚¹ãƒˆã§ãã¾ã™::"

#: ../../library/multiprocessing.rst:1941
msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are contained"
" in a referent, modifications to those mutable values will not be propagated"
" through the manager because the proxy has no way of knowing when the values"
" contained within are modified.  However, storing a value in a container "
"proxy (which triggers a ``__setitem__`` on the proxy object) does propagate "
"through the manager and so to effectively modify such an item, one could re-"
"assign the modified value to the container proxy::"
msgstr ""
"(ãƒ—ãƒ­ã‚­ã‚·ã§ãªã„) æ¨™æº–ã® :class:`list` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„ :class:`dict` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‚ç…§å¯¾è±¡ã«å«ã¾ã‚Œã¦ã„ãŸå ´åˆã€ãã‚Œã‚‰ã®å¯å¤‰ãªå€¤ã®å¤‰æ›´ã¯ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‹ã‚‰ã¯ä¼æ¬ã•ã‚Œã¾ã›ã‚“ã€‚\n"
"ã¨ã„ã†ã®ã‚‚ã€ãƒ—ãƒ­ã‚­ã‚·ã«ã¯å‚ç…§å¯¾è±¡ã®ä¸­ã«å«ã¾ã‚Œã‚‹å€¤ãŒã„ã¤å¤‰æ›´ã•ã‚ŒãŸã‹ã‚’çŸ¥ã‚‹è¡“ãŒç„¡ã„ã®ã§ã™ã€‚\n"
"ã—ã‹ã—ã€ã‚³ãƒ³ãƒ†ãƒŠãƒ—ãƒ­ã‚­ã‚·ã«å€¤ã‚’ä¿å­˜ã™ã‚‹ (ã“ã‚Œã¯ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® ``__setitem__`` ã‚’èµ·å‹•ã—ã¾ã™) å ´åˆã¯ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’é€šã—ã¦å¤‰æ›´ãŒä¼æ¬ã•ã‚Œã€ãã®è¦ç´ ã‚’å®Ÿéš›ã«å¤‰æ›´ã™ã‚‹ãŸã‚ã«ã€ã‚³ãƒ³ãƒ†ãƒŠãƒ—ãƒ­ã‚­ã‚·ã«å¤‰æ›´å¾Œã®å€¤ãŒå†ä»£å…¥ã•ã‚Œã¾ã™::"

#: ../../library/multiprocessing.rst:1960
msgid ""
"This approach is perhaps less convenient than employing nested :ref"
":`multiprocessing-proxy_objects` for most use cases but also demonstrates a "
"level of control over the synchronization."
msgstr ""

#: ../../library/multiprocessing.rst:1966
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ""
":mod:`multiprocessing` ã®ãƒ—ãƒ­ã‚­ã‚·å‹ã¯å€¤ã«ã‚ˆã‚‹æ¯”è¼ƒã«å¯¾ã—ã¦ä½•ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™:"

#: ../../library/multiprocessing.rst:1974
msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr "æ¯”è¼ƒã‚’è¡Œã„ãŸã„ã¨ãã¯å‚ç…§å¯¾è±¡ã®ã‚³ãƒ”ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1978
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :class:`BaseProxy` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:1982
msgid "Call and return the result of a method of the proxy's referent."
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã®å‚ç…§å¯¾è±¡ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè¡Œçµæœã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:1984
msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr "``proxy`` ãŒãƒ—ãƒ­ã‚­ã‚·ã§ã€ãƒ—ãƒ­ã‚­ã‚·å†…ã®å‚ç…§å¯¾è±¡ãŒ ``obj`` ãªã‚‰ã“ã®å¼ ::"

#: ../../library/multiprocessing.rst:1988
msgid "will evaluate the expression ::"
msgstr "ã¯ã“ã®å¼ã‚’è©•ä¾¡ã—ã¾ã™ ::"

#: ../../library/multiprocessing.rst:1992
msgid "in the manager's process."
msgstr "(ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹å†…ã®)ã€‚"

#: ../../library/multiprocessing.rst:1994
msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr ""
"è¿”ã•ã‚Œã‚‹å€¤ã¯ãã®å‘¼ã³å‡ºã—çµæœã®ã‚³ãƒ”ãƒ¼ã‹ã€æ–°ãŸãªå…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ãƒ—ãƒ­ã‚­ã‚·ã«ãªã‚Šã¾ã™ã€‚è©³ç´°ã¯ "
":meth:`BaseManager.register` ã® *method_to_typeid* å¼•æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:1998
msgid ""
"If an exception is raised by the call, then is re-raised by "
":meth:`_callmethod`.  If some other exception is raised in the manager's "
"process then this is converted into a :exc:`RemoteError` exception and is "
"raised by :meth:`_callmethod`."
msgstr ""
"ãã®å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸå ´åˆã€:meth:`_callmethod` "
"ã«ã‚ˆã£ã¦ãã®ä¾‹å¤–ã¯å†é€å‡ºã•ã‚Œã¾ã™ã€‚ä»–ã®ä¾‹å¤–ãŒãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã§ç™ºç”Ÿã—ãŸãªã‚‰ã€:exc:`RemoteError` ä¾‹å¤–ã«å¤‰æ›ã•ã‚ŒãŸã‚‚ã®ãŒ "
":meth:`_callmethod` ã«ã‚ˆã£ã¦é€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2003
msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr "ç‰¹ã« *methodname* ãŒ *å…¬é–‹* ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ä¾‹å¤–ãŒç™ºç”Ÿã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2006
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr ":meth:`_callmethod` ã®ä½¿ç”¨ä¾‹ã«ãªã‚Šã¾ã™:"

#: ../../library/multiprocessing.rst:2022
msgid "Return a copy of the referent."
msgstr "å‚ç…§å¯¾è±¡ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2024
msgid "If the referent is unpicklable then this will raise an exception."
msgstr "å‚ç…§å¯¾è±¡ãŒ unpickle åŒ–ã§ãã‚‹ãªã‚‰ä¾‹å¤–ã‚’ç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2028
msgid "Return a representation of the proxy object."
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¾ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2032
msgid "Return the representation of the referent."
msgstr "å‚ç…§å¯¾è±¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¾ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2036
msgid "Cleanup"
msgstr "ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"

#: ../../library/multiprocessing.rst:2038
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr ""
"ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¼±å‚ç…§(weakref)ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹ã¨ãã«ãã®å‚ç…§å¯¾è±¡ãŒæ‰€æœ‰ã™ã‚‹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‹ã‚‰ãã®ç™»éŒ²ã‚’å–ã‚Šæ¶ˆã›ã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2041
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr "å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ­ã‚­ã‚·ãŒå‚ç…§ã—ãªããªã£ãŸã¨ãã«ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰å‰Šé™¤ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2046
msgid "Process Pools"
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ãƒ—ãƒ¼ãƒ«"

#: ../../library/multiprocessing.rst:2051
msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr ":class:`Pool` ã‚¯ãƒ©ã‚¹ã§ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ—ãƒ¼ãƒ«ã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2056
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr ""
"ãƒ—ãƒ­ã‚»ã‚¹ãƒ—ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚¸ãƒ§ãƒ–ã‚’é€ã‚Šè¾¼ã‚ã‚‹ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ—ãƒ¼ãƒ«ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚„ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®ã‚ã‚‹éåŒæœŸã®å®Ÿè¡Œã‚’ã‚µãƒãƒ¼ãƒˆã—ã€ä¸¦åˆ— "
"map å®Ÿè£…ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2060
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.cpu_count` is used."
msgstr ""
"*processes* ã¯ä½¿ç”¨ã™ã‚‹ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã®æ•°ã§ã™ã€‚*processes* ãŒ ``None`` ã®å ´åˆ "
":func:`os.cpu_count` ãŒè¿”ã™å€¤ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2063
msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""
"*initializer* ãŒ ``None`` ã§ã¯ãªã„å ´åˆã€å„ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã¯é–‹å§‹æ™‚ã« ``initializer(*initargs)`` "
"ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2066
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is ``None``, "
"which means worker processes will live as long as the pool."
msgstr ""
"*maxtasksperchild* ã¯ã€ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒ exit "
"ã—ã¦æ–°ãŸãªãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã¨ç½®ãæ›¿ãˆã‚‰ã‚Œã‚‹ã¾ã§ã®é–“ã«ã€ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Œäº†ã™ã‚‹ã“ã¨ã®ã§ãã‚‹ã‚¿ã‚¹ã‚¯ã®æ•°ã§ã™ã€‚ã“ã®è¨­å®šã«ã‚ˆã‚Šæœªåˆ©ç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ãŒè§£æ”¾ã•ã‚Œã‚‹ã‚ˆã†ãªã‚Šã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®"
" *maxtasksperchild* ã¯ ``None`` ã§ã€ã“ã‚Œã¯ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ—ãƒ¼ãƒ«ã¨åŒã˜æœŸé–“ã ã‘ç”Ÿãç¶šã‘ã‚‹ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2071
msgid ""
"*context* can be used to specify the context used for starting the worker "
"processes.  Usually a pool is created using the function "
":func:`multiprocessing.Pool` or the :meth:`Pool` method of a context object."
"  In both cases *context* is set appropriately."
msgstr ""
"*context* ã¯ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æŒ‡å®šã«ä½¿ç”¨ã§ãã¾ã™ã€‚é€šå¸¸ãƒ—ãƒ¼ãƒ«ã¯é–¢æ•° "
":func:`multiprocessing.Pool` ã‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`Pool` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ä½œæˆã•ã‚Œã¾ã™ã€‚ã©ã¡ã‚‰ã®å ´åˆã§ã‚‚ *context* ã¯é©åˆ‡ã«è¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2077
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr "ãƒ—ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãã®ãƒ—ãƒ¼ãƒ«ã‚’ä½œæˆã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã®ã¿ãŒå‘¼ã³å‡ºã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2080
msgid "*maxtasksperchild*"
msgstr "*maxtasksperchild*"

#: ../../library/multiprocessing.rst:2083
msgid "*context*"
msgstr "*context*"

#: ../../library/multiprocessing.rst:2088
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems"
" (such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old"
" one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ""
":class:`Pool` "
"ä¸­ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€å…¸å‹çš„ã«ã¯ãƒ—ãƒ¼ãƒ«ã®ãƒ¯ãƒ¼ã‚¯ã‚­ãƒ¥ãƒ¼ã®å­˜ç¶šæœŸé–“ã¨ã¡ã‚‡ã†ã©åŒã˜ã ã‘ç”Ÿãç¶šã‘ã¾ã™ã€‚ãƒ¯ãƒ¼ã‚«ãƒ¼ã«ç¢ºä¿ã•ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ã‚’è§£æ”¾ã™ã‚‹ãŸã‚ã« "
"(Apache, mod_wsgi, ãªã©ã®ã‚ˆã†ãª) ä»–ã®ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆãè¦‹ã‚‰ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ãƒ—ãƒ¼ãƒ«å†…ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒè¨­å®šã•ã‚ŒãŸé‡ã ã‘ã®ä»•äº‹ã‚’å®Œäº†ã—ãŸã‚‰ "
"exit ã¨ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’è¡Œã„ã€å¤ã„ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç½®ãæ›ãˆã‚‹ãŸã‚ã«æ–°ã—ã„ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚ :class:`Pool` ã® "
"*maxtasksperchild* å¼•æ•°ã¯ã€ã“ã®èƒ½åŠ›ã‚’ã‚¨ãƒ³ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«æä¾›ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2098
msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It blocks "
"until the result is ready. Given this blocks, :meth:`apply_async` is better "
"suited for performing work in parallel. Additionally, *func* is only "
"executed in one of the workers of the pool."
msgstr ""
"å¼•æ•° *args* ã¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•° *kwds* ã‚’ä¼´ã£ã¦ *func* ã‚’å‘¼ã³ã¾ã™ã€‚çµæœãŒæº–å‚™ã§ãã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚‹ãŸã‚ã€ "
":meth:`apply_async` ã®æ–¹ãŒä¸¦è¡Œä½œæ¥­ã«ã‚ˆã‚Šé©ã—ã¦ã„ã¾ã™ã€‚åŠ ãˆã¦ã€ *func* ã¯ã€ãƒ—ãƒ¼ãƒ«å†…ã®1ã¤ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã ã‘ã§å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2105
msgid "A variant of the :meth:`apply` method which returns a result object."
msgstr ":meth:`apply` ãƒ¡ã‚½ãƒƒãƒ‰ã®æ´¾ç”Ÿç‰ˆã§çµæœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2107
#: ../../library/multiprocessing.rst:2132
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it,"
" that is unless the call failed, in which case the *error_callback* is "
"applied instead."
msgstr ""
"*callback* ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã€ãã‚Œã¯å˜ä¸€ã®å¼•æ•°ã‚’å—ã‘å–ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚çµæœã‚’è¿”ã›ã‚‹ã‚ˆã†ã«ãªã£ãŸã¨ãã« "
"*callback* ãŒçµæœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦é©ç”¨ã•ã‚Œã¾ã™ã€‚ãŸã ã—å‘¼ã³å‡ºã—ãŒå¤±æ•—ã—ãŸå ´åˆã¯ã€ä»£ã‚ã‚Šã« *error_callback* "
"ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2112
#: ../../library/multiprocessing.rst:2137
msgid ""
"If *error_callback* is specified then it should be a callable which accepts "
"a single argument.  If the target function fails, then the *error_callback* "
"is called with the exception instance."
msgstr ""
"*error_callback* "
"ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã€ãã‚Œã¯å˜ä¸€ã®å¼•æ•°ã‚’å—ã‘å–ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å¯¾è±¡ã®é–¢æ•°ãŒå¤±æ•—ã—ãŸå ´åˆã€ä¾‹å¤–ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä¼´ã£ã¦ "
"*error_callback* ãŒå‘¼ã°ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2116
#: ../../library/multiprocessing.rst:2141
msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr "ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ç›´ã¡ã«å®Œäº†ã™ã¹ãã§ã™ã€‚ãªãœãªã‚‰ã€ãã†ã—ãªã‘ã‚Œã°ã€çµæœã‚’æ‰±ã†ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2121
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only"
" one *iterable* argument though).  It blocks until the result is ready."
msgstr ""
":func:`map` çµ„ã¿è¾¼ã¿é–¢æ•°ã®ä¸¦åˆ—ç‰ˆã§ã™ (*iterable* "
"ãªå¼•æ•°ã‚’1ã¤ã ã‘ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã¨ã„ã†é•ã„ã¯ã‚ã‚Šã¾ã™ãŒ)ã€‚çµæœãŒå‡ºã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2124
msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã‚’ã„ãã¤ã‚‚ã®ãƒãƒ£ãƒ³ã‚¯ã«åˆ†å‰²ã—ã€ãƒ—ãƒ­ã‚»ã‚¹ãƒ—ãƒ¼ãƒ«ã«ãã‚Œãã‚Œç‹¬ç«‹ã—ãŸã‚¿ã‚¹ã‚¯ã¨ã—ã¦é€ã‚Šã¾ã™ã€‚(æ¦‚ç®—ã®) ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚ºã¯ "
"*chunksize* ã‚’æ­£ã®æ•´æ•°ã«è¨­å®šã™ã‚‹ã“ã¨ã§æŒ‡å®šã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2130
msgid "A variant of the :meth:`.map` method which returns a result object."
msgstr ":meth:`.map` ãƒ¡ã‚½ãƒƒãƒ‰ã®æ´¾ç”Ÿç‰ˆã§çµæœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2146
msgid "A lazier version of :meth:`map`."
msgstr ":meth:`map` ã®é…å»¶è©•ä¾¡ç‰ˆã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2148
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr ""
"*chunksize* å¼•æ•°ã¯ :meth:`.map` ãƒ¡ã‚½ãƒƒãƒ‰ã§ä½¿ç”¨ã•ã‚Œã‚‹ã‚‚ã®ã¨åŒã˜ã§ã™ã€‚ å¼•æ•° iterable ãŒã¨ã¦ã‚‚é•·ã„ãªã‚‰ "
"*chunksize* ã«å¤§ããªå€¤ã‚’æŒ‡å®šã—ã¦ä½¿ç”¨ã™ã‚‹æ–¹ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã® ``1`` ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã‚Šã‚‚ã‚¸ãƒ§ãƒ–ã®å®Œäº†ãŒ **ã‹ãªã‚Š** é€Ÿããªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2153
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr ""
"ã¾ãŸ *chunksize* ãŒ ``1`` ã®å ´åˆ :meth:`imap` ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã® :meth:`!next` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ *timeout* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’æŒã¡ã¾ã™ã€‚ ``next(timeout)`` ã¯ã€ãã®çµæœãŒ *timeout* "
"ç§’ä»¥å†…ã«è¿”ã•ã‚Œãªã„ã¨ãã« :exc:`multiprocessing.TimeoutError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2160
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr ""
"ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒè¿”ã™çµæœã®é †ç•ªãŒä»»æ„ã®é †ç•ªã§è‰¯ã„ã¨è¦‹ãªã•ã‚Œã‚‹ã“ã¨ã‚’é™¤ã‘ã° :meth:`imap` ã¨åŒã˜ã§ã™ã€‚ (ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒ1ã¤ã—ã‹ãªã„å ´åˆã®ã¿"
" \"æ­£ã—ã„\" é †ç•ªã«ãªã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚)"

#: ../../library/multiprocessing.rst:2166
msgid ""
"Like :meth:`map` except that the elements of the *iterable* are expected to "
"be iterables that are unpacked as arguments."
msgstr ""
"*iterable* ã®è¦ç´ ãŒã€å¼•æ•°ã¨ã—ã¦ unpack ã•ã‚Œã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã¨æœŸå¾…ã•ã‚Œã‚‹ä»¥å¤–ã¯ã€ :meth:`map` "
"ã¨ä¼¼ã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2169
msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr ""
"ãã®ãŸã‚ã€*iterable* ãŒ ``[(1,2), (3, 4)]`` ãªã‚‰ã€çµæœã¯ ``[func(1,2), func(3,4)]`` "
"ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2176
msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over "
"*iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""
":meth:`starmap` ã¨ :meth:`map_async` ã®çµ„ã¿åˆã‚ã›ã§ã™ã€‚ ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® *iterable* "
"ã‚’ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã—ã¦ã€ unpack ã—ãŸã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¼´ã£ã¦ *func* ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚çµæœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2184
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr "ã“ã‚Œä»¥ä¸Šãƒ—ãƒ¼ãƒ«ã§ã‚¿ã‚¹ã‚¯ãŒå®Ÿè¡Œã•ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ãŒå®Œäº†ã—ãŸå¾Œã§ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2189
msgid ""
"Stops the worker processes immediately without completing outstanding work."
"  When the pool object is garbage collected :meth:`terminate` will be called"
" immediately."
msgstr ""
"å®Ÿè¡Œä¸­ã®å‡¦ç†ã‚’å®Œäº†ã•ã›ãšã«ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’ã™ãã«åœæ­¢ã—ã¾ã™ã€‚ãƒ—ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹ã¨ãã« :meth:`terminate` "
"ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2195
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or "
":meth:`terminate` before using :meth:`join`."
msgstr ""
"ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã™ã‚‹ã®ã‚’å¾…ã¡ã¾ã™ã€‚ :meth:`join` ã‚’ä½¿ç”¨ã™ã‚‹å‰ã« :meth:`close` ã‹ :meth:`terminate` "
"ã‚’å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2198
msgid ""
"Pool objects now support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"pool object, and :meth:`~contextmanager.__exit__` calls :meth:`terminate`."
msgstr ""
"Pool ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆãƒ»ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ -- :ref:`typecontextmanager`"
" ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ :meth:`~contextmanager.__enter__` ã¯ Pool ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã¾ãŸ "
":meth:`~contextmanager.__exit__` ã¯ :meth:`terminate` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2206
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and "
":meth:`Pool.map_async`."
msgstr ":meth:`Pool.apply_async` ã‚„ :meth:`Pool.map_async` ã§è¿”ã•ã‚Œã‚‹çµæœã®ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2211
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then "
":exc:`multiprocessing.TimeoutError` is raised.  If the remote call raised an"
" exception then that exception will be reraised by :meth:`get`."
msgstr ""
"çµæœã‚’å—ã‘å–ã£ãŸã¨ãã«è¿”ã—ã¾ã™ã€‚ *timeout* ãŒ ``None`` ã§ã¯ãªãã¦ã€ãã®çµæœãŒ *timeout* ç§’ä»¥å†…ã«å—ã‘å–ã‚Œãªã„å ´åˆ "
":exc:`multiprocessing.TimeoutError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ãƒªãƒ¢ãƒ¼ãƒˆã®å‘¼ã³å‡ºã—ãŒä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹å ´åˆã€ãã®ä¾‹å¤–ã¯ "
":meth:`get` ãŒå†ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2218
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr "ãã®çµæœãŒæœ‰åŠ¹ã«ãªã‚‹ã‹ *timeout* ç§’çµŒã¤ã¾ã§å¾…ã¡ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2222
msgid "Return whether the call has completed."
msgstr "ãã®å‘¼ã³å‡ºã—ãŒå®Œäº†ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2226
msgid ""
"Return whether the call completed without raising an exception.  Will raise "
":exc:`AssertionError` if the result is not ready."
msgstr ""
"ãã®å‘¼ã³å‡ºã—ãŒä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹ã“ã¨ãªãå®Œäº†ã—ãŸã‹ã©ã†ã‹ã‚’è¿”ã—ã¾ã™ã€‚ãã®çµæœãŒè¿”ã›ã‚‹çŠ¶æ…‹ã§ãªã„å ´åˆ :exc:`AssertionError` "
"ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2229
msgid "The following example demonstrates the use of a pool::"
msgstr "æ¬¡ã®ä¾‹ã¯ãƒ—ãƒ¼ãƒ«ã®ä½¿ç”¨ä¾‹ã‚’ç´¹ä»‹ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:2256
msgid "Listeners and Clients"
msgstr "ãƒªã‚¹ãƒŠãƒ¼ã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ"

#: ../../library/multiprocessing.rst:2261
msgid ""
"Usually message passing between processes is done using queues or by using "
":class:`~Connection` objects returned by :func:`~multiprocessing.Pipe`."
msgstr ""

#: ../../library/multiprocessing.rst:2265
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""
"ã—ã‹ã— :mod:`multiprocessing.connection` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã•ã‚‰ã«æŸ”è»Ÿãªä»•çµ„ã¿ãŒã‚ã‚Šã¾ã™ã€‚ "
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€åŸºæœ¬çš„ã«ã¯ã‚½ã‚±ãƒƒãƒˆã‚‚ã—ãã¯ Windows ã®åå‰ä»˜ããƒ‘ã‚¤ãƒ—ã‚’æ‰±ã†é«˜ãƒ¬ãƒ™ãƒ«ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŒ‡å‘ API ã‚’æä¾›ã—ã¾ã™ã€‚ã¾ãŸã€ "
":mod:`hmac` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ãŸ *ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆèªè¨¼* ã‚„åŒæ™‚ã®è¤‡æ•°æ¥ç¶šã®ãƒãƒ¼ãƒªãƒ³ã‚°ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2274
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr "ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã¸é€ä¿¡ã—ã¦å¿œç­”ã‚’å¾…ã¡ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2277
msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"ãã®å¿œç­”ãŒã‚­ãƒ¼ã¨ã—ã¦ *authkey* ã‚’ä½¿ç”¨ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆã¨ä¸€è‡´ã™ã‚‹å ´åˆã€ ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ç›¸æ‰‹å´ã¸æ­“è¿ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã™ã€‚ "
"ãã†ã§ãªã‘ã‚Œã° :exc:`~multiprocessing.AuthenticationError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2283
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ä¿¡ã—ã¦ã€ãã®ã‚­ãƒ¼ã¨ã—ã¦ *authkey* ã‚’ä½¿ç”¨ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆã‚’è¨ˆç®—ã—ã€ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆã‚’é€ã‚Šè¿”ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2286
msgid ""
"If a welcome message is not received, then "
":exc:`~multiprocessing.AuthenticationError` is raised."
msgstr "æ­“è¿ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ã‘å–ã‚Œãªã„å ´åˆ :exc:`~multiprocessing.AuthenticationError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2291
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr ""

#: ../../library/multiprocessing.rst:2294
msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""
"ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ç¨®åˆ¥ã¯ *family* å¼•æ•°ã§æ±ºå®šã—ã¾ã™ãŒã€ä¸€èˆ¬çš„ã«ã¯ *address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‹ã‚‰æ¨æ¸¬ã§ãã‚‹ã®ã§ã€ã“ã‚Œã¯æŒ‡å®šã•ã‚Œã¾ã›ã‚“ã€‚ "
"(:ref:`multiprocessing-address-formats` ã‚’å‚ç…§ã—ã¦ãã ã•ã„)"

#: ../../library/multiprocessing.rst:2298
#: ../../library/multiprocessing.rst:2333
msgid ""
"If *authkey* is given and not None, it should be a byte string and will be "
"used as the secret key for an HMAC-based authentication challenge. No "
"authentication is done if *authkey* is None. "
":exc:`~multiprocessing.AuthenticationError` is raised if authentication "
"fails. See :ref:`multiprocessing-auth-keys`."
msgstr ""

#: ../../library/multiprocessing.rst:2306
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ 'å¾…ã¡å—ã‘ã‚‹' æŸç¸›ã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‹ Windows ã®åå‰ä»˜ããƒ‘ã‚¤ãƒ—ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2309
msgid ""
"*address* is the address to be used by the bound socket or named pipe of the"
" listener object."
msgstr "*address* ã¯ãƒªã‚¹ãƒŠãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æŸç¸›ã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‹åå‰ä»˜ããƒ‘ã‚¤ãƒ—ãŒä½¿ç”¨ã™ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2314
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use"
" '127.0.0.1'."
msgstr ""
"'0.0.0.0' ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€Windows ä¸Šã®çµ‚ç‚¹ã¸æ¥ç¶šã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚çµ‚ç‚¹ã¸æ¥ç¶šã—ãŸã„å ´åˆã¯ '127.0.0.1' "
"ã‚’ä½¿ç”¨ã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2318
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr ""
"*family* ã¯ä½¿ç”¨ã™ã‚‹ã‚½ã‚±ãƒƒãƒˆ(åå‰ä»˜ããƒ‘ã‚¤ãƒ—)ã®ç¨®åˆ¥ã§ã™ã€‚ã“ã‚Œã¯ ``'AF_INET'`` (TCP ã‚½ã‚±ãƒƒãƒˆ), ``'AF_UNIX'``"
" (Unix ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚½ã‚±ãƒƒãƒˆ) ã¾ãŸã¯ ``'AF_PIPE'`` (Windows åå‰ä»˜ããƒ‘ã‚¤ãƒ—) "
"ã¨ã„ã†æ–‡å­—åˆ—ã®ã©ã‚Œã‹1ã¤ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã†ã¡ ``'AF_INET'`` ã®ã¿ãŒåˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã¾ã™ã€‚ *family* ãŒ "
"``None`` ã®å ´åˆ *address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‹ã‚‰æ¨æ¸¬ã•ã‚ŒãŸã‚‚ã®ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ *address* ã‚‚ ``None`` "
"ã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãŒé¸æŠã•ã‚Œã¾ã™ã€‚è©³ç´°ã¯ :ref:`multiprocessing-address-formats` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ "
"*family* ãŒ ``'AF_UNIX'`` ã§ *address* ãŒ ``None`` ã®å ´åˆ :func:`tempfile.mkstemp`"
" ã‚’ä½¿ç”¨ã—ã¦ä½œæˆã•ã‚ŒãŸãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªä¸€æ™‚ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã‚½ã‚±ãƒƒãƒˆãŒä½œæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2329
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed"
" to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr ""
"ãƒªã‚¹ãƒŠãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚½ã‚±ãƒƒãƒˆã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ã‚½ã‚±ãƒƒãƒˆã«æŸç¸›ã•ã‚Œã‚‹ã¨ãã« *backlog* (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯1ã¤) ãŒã‚½ã‚±ãƒƒãƒˆã® "
":meth:`~socket.socket.listen` ãƒ¡ã‚½ãƒƒãƒ‰ã«å¯¾ã—ã¦æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2341
msgid ""
"Accept a connection on the bound socket or named pipe of the listener object"
" and return a :class:`~Connection` object. If authentication is attempted "
"and fails, then :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""

#: ../../library/multiprocessing.rst:2348
msgid ""
"Close the bound socket or named pipe of the listener object.  This is called"
" automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr ""
"ãƒªã‚¹ãƒŠãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åå‰ä»˜ããƒ‘ã‚¤ãƒ—ã‹æŸç¸›ã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒªã‚¹ãƒŠãƒ¼ãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹ã¨ãã«è‡ªå‹•çš„ã«å‘¼ã°ã‚Œã¾ã™ã€‚ãã†ã¯è¨€ã£ã¦ã‚‚ã€æ˜ç¤ºçš„ã«"
" close() ã‚’å‘¼ã³å‡ºã™æ–¹ãŒæœ›ã¾ã—ã„ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2352
msgid "Listener objects have the following read-only properties:"
msgstr "ãƒªã‚¹ãƒŠãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ¬¡ã®èª­ã¿å‡ºã—å°‚ç”¨å±æ€§ã‚’æŒã£ã¦ã„ã¾ã™:"

#: ../../library/multiprocessing.rst:2356
msgid "The address which is being used by the Listener object."
msgstr "ãƒªã‚¹ãƒŠãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½¿ç”¨ä¸­ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2360
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr "æœ€å¾Œã«ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’å—ã‘ä»˜ã‘ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚æœ‰åŠ¹ãªã‚¢ãƒ‰ãƒ¬ã‚¹ãŒãªã„å ´åˆã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2363
msgid ""
"Listener objects now support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"listener object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Listener ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆãƒ»ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ -- "
":ref:`typecontextmanager` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ :meth:`~contextmanager.__enter__` "
"ã¯ãƒªã‚¹ãƒŠãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã¾ãŸ :meth:`~contextmanager.__exit__` ã¯ :meth:`close` "
"ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2370
msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those "
"objects in *object_list* which are ready.  If *timeout* is a float then the "
"call blocks for at most that many seconds.  If *timeout* is ``None`` then it"
" will block for an unlimited period. A negative timeout is equivalent to a "
"zero timeout."
msgstr ""
"*object_list* ä¸­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæº–å‚™ãŒã§ãã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚æº–å‚™ãŒã§ããŸ *object_list* "
"ä¸­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚*timeout* ãŒæµ®å‹•å°æ•°ç‚¹ãªã‚‰ã€æœ€å¤§ã§ãã®ç§’æ•°ã ã‘å‘¼ã³å‡ºã—ãŒãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚*timeout* ãŒ "
"``None`` ã®å ´åˆã€ç„¡åˆ¶é™ã®æœŸé–“ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚è² ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯0ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2376
msgid ""
"For both Unix and Windows, an object can appear in *object_list* if it is"
msgstr "Unix ã¨ Windows ã®ä¸¡æ–¹ã§ã€ *object_list* ã«ã¯ä»¥ä¸‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å«ã‚ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™"

#: ../../library/multiprocessing.rst:2379
msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr ""

#: ../../library/multiprocessing.rst:2380
msgid "a connected and readable :class:`socket.socket` object; or"
msgstr "æ¥ç¶šã•ã‚ŒãŸèª­ã¿å–ã‚Šå¯èƒ½ãª :class:`socket.socket` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ; ã¾ãŸã¯"

#: ../../library/multiprocessing.rst:2381
msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a "
":class:`~multiprocessing.Process` object."
msgstr ""
":class:`~multiprocessing.Process` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® "
":attr:`~multiprocessing.Process.sentinel` å±æ€§ã€‚"

#: ../../library/multiprocessing.rst:2384
msgid ""
"A connection or socket object is ready when there is data available to be "
"read from it, or the other end has been closed."
msgstr "èª­ã¿å–ã‚‹ã“ã¨ã®ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã€ã‚ã‚‹ã„ã¯ç›¸æ‰‹å´ã®ç«¯ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã‚‹å ´åˆã€ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã¾ãŸã¯ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æº–å‚™ãŒã§ãã¦ã„ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2387
msgid ""
"**Unix**: ``wait(object_list, timeout)`` almost equivalent "
"``select.select(object_list, [], [], timeout)``.  The difference is that, if"
" :func:`select.select` is interrupted by a signal, it can raise "
":exc:`OSError` with an error number of ``EINTR``, whereas :func:`wait` will "
"not."
msgstr ""
"**Unix**: ``wait(object_list, timeout)`` ã¯ ``select.select(object_list, [], "
"[], timeout)`` ã¨ã»ã¨ã‚“ã©ç­‰ä¾¡ã§ã™ã€‚é•ã„ã¯ã€ :func:`select.select` ãŒã‚·ã‚°ãƒŠãƒ«ã«ã‚ˆã£ã¦ä¸­æ–­ã•ã‚Œã‚‹å ´åˆã€ "
"``EINTR`` ã®ã‚¨ãƒ©ãƒ¼ç•ªå·ä»˜ãã§ :exc:`OSError` ã‚’ä¸Šã’ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ :func:`wait` ã¯ãã®ã‚ˆã†ãªã“ã¨ã¯è¡Œã„ã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2393
msgid ""
"**Windows**: An item in *object_list* must either be an integer handle which"
" is waitable (according to the definition used by the documentation of the "
"Win32 function ``WaitForMultipleObjects()``) or it can be an object with a "
":meth:`fileno` method which returns a socket handle or pipe handle.  (Note "
"that pipe handles and socket handles are **not** waitable handles.)"
msgstr ""
"**Windows**: *object_list* ã®è¦ç´ ã¯ã€ (Win32 é–¢æ•° ``WaitForMultipleObjects()`` "
"ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ä½¿ã‚ã‚Œã¦ã„ã‚‹å®šç¾©ã‹ã‚‰) wait å¯èƒ½ãªæ•´æ•°ãƒãƒ³ãƒ‰ãƒ«ã‹ã€ã‚½ã‚±ãƒƒãƒˆãƒãƒ³ãƒ‰ãƒ«ã¾ãŸã¯ãƒ‘ã‚¤ãƒ—ãƒãƒ³ãƒ‰ãƒ«ã‚’è¿”ã™ :meth:`fileno` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã©ã¡ã‚‰ã‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ (ãƒ‘ã‚¤ãƒ—ãƒãƒ³ãƒ‰ãƒ«ã¨ã‚½ã‚±ãƒƒãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã¯ wait å¯èƒ½ãªãƒãƒ³ãƒ‰ãƒ«ã§ã¯ **ãªã„** "
"ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚)"

#: ../../library/multiprocessing.rst:2403
msgid "**Examples**"
msgstr "**ä¾‹**"

#: ../../library/multiprocessing.rst:2405
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr ""
"æ¬¡ã®ã‚µãƒ¼ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ã¯èªè¨¼ã‚­ãƒ¼ã¨ã—ã¦ ``'secret password'`` "
"ã‚’ä½¿ç”¨ã™ã‚‹ãƒªã‚¹ãƒŠãƒ¼ã‚’ä½œæˆã—ã¾ã™ã€‚ã“ã®ã‚µãƒ¼ãƒãƒ¼ã¯ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’å¾…ã£ã¦ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:2424
msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr "æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚µãƒ¼ãƒãƒ¼ã¸æ¥ç¶šã—ã¦ã€ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:2441
msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait for"
" messages from multiple processes at once::"
msgstr ""
"æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ :func:`~multiprocessing.connection.wait` "
"ã‚’ä½¿ã£ã¦è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’åŒæ™‚ã«å¾…ã¡ã¾ã™::"

#: ../../library/multiprocessing.rst:2480
msgid "Address Formats"
msgstr "ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"

#: ../../library/multiprocessing.rst:2482
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr ""
"``'AF_INET'`` ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ ``(hostname, port)`` ã®ã‚¿ãƒ—ãƒ«ã«ãªã‚Šã¾ã™ã€‚ *hostname* ã¯æ–‡å­—åˆ—ã§ *port* "
"ã¯æ•´æ•°ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2485
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr "``'AF_UNIX'`` ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®ãƒ•ã‚¡ã‚¤ãƒ«åã®æ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2491
msgid "An ``'AF_PIPE'`` address is a string of the form"
msgstr "``'AF_PIPE'`` ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ã€æ¬¡ã®å½¢å¼ã‚’æŒã¤æ–‡å­—åˆ—ã§ã™"

#: ../../library/multiprocessing.rst:2489
msgid ""
":samp:`r'\\\\\\\\.\\\\pipe\\\\{PipeName}'`.  To use :func:`Client` to "
"connect to a named pipe on a remote computer called *ServerName* one should "
"use an address of the form "
":samp:`r'\\\\\\\\{ServerName}\\\\pipe\\\\{PipeName}'` instead."
msgstr ""
":samp:`r'\\\\\\\\.\\\\pipe\\\\{PipeName}'` ã€‚ *ServerName* "
"ã¨ã„ã†åå‰ã®ãƒªãƒ¢ãƒ¼ãƒˆã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ä¸Šã®åå‰ä»˜ããƒ‘ã‚¤ãƒ—ã«æ¥ç¶šã™ã‚‹ãŸã‚ã« :func:`Client` ã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯ã€ä»£ã‚ã‚Šã« "
":samp:`r'\\\\\\\\{ServerName}\\\\pipe\\\\{PipeName}'` å½¢å¼ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2493
msgid ""
"Note that any string beginning with two backslashes is assumed by default to"
" be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€2ã¤ã®ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§å§‹ã¾ã‚‹æ–‡å­—åˆ—ã¯ ``'AF_UNIX'`` ã‚ˆã‚Šã‚‚ ``'AF_PIPE'`` "
"ã¨ã—ã¦æ¨æ¸¬ã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2500
msgid "Authentication keys"
msgstr "èªè¨¼ã‚­ãƒ¼"

#: ../../library/multiprocessing.rst:2502
msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data received "
"is automatically unpickled. Unfortunately unpickling data from an untrusted "
"source is a security risk. Therefore :class:`Listener` and :func:`Client` "
"use the :mod:`hmac` module to provide digest authentication."
msgstr ""

#: ../../library/multiprocessing.rst:2508
msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof that "
"the other knows the authentication key.  (Demonstrating that both ends are "
"using the same key does **not** involve sending the key over the "
"connection.)"
msgstr ""
"èªè¨¼ã‚­ãƒ¼ã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¨ã—ã¦è¦‹ãªã•ã‚Œã‚‹ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã§ã™ã€‚ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒç¢ºç«‹ã™ã‚‹ã¨ã€åŒæ–¹ã®çµ‚ç‚¹ã§æ­£ã—ã„æ¥ç¶šå…ˆã§ã‚ã‚‹ã“ã¨ã‚’è¨¼æ˜ã™ã‚‹ãŸã‚ã« "
"çŸ¥ã£ã¦ã„ã‚‹ãŠäº’ã„ã®èªè¨¼ã‚­ãƒ¼ã‚’è¦æ±‚ã—ã¾ã™ã€‚(åŒæ–¹ã®çµ‚ç‚¹ãŒåŒã˜ã‚­ãƒ¼ã‚’ä½¿ç”¨ã—ã¦é€šä¿¡ã—ã‚ˆã†ã¨ã—ã¦ã‚‚ã€ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ä¸Šã§ãã®ã‚­ãƒ¼ã‚’é€ä¿¡ã™ã‚‹ã“ã¨ã¯ "
"**ã§ãã¾ã›ã‚“**ã€‚)"

#: ../../library/multiprocessing.rst:2514
msgid ""
"If authentication is requested but no authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see "
":class:`~multiprocessing.Process`).  This value will be automatically "
"inherited by any :class:`~multiprocessing.Process` object that the current "
"process creates. This means that (by default) all processes of a multi-"
"process program will share a single authentication key which can be used "
"when setting up connections between themselves."
msgstr ""
"èªè¨¼ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšèªè¨¼ã‚­ãƒ¼ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆ ``current_process().authkey`` ã®è¿”ã™å€¤ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ "
"(è©³ç´°ã¯ :class:`~multiprocessing.Process` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚) ã“ã®å€¤ã¯ã‚«ãƒ¬ãƒ³ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œæˆã™ã‚‹ "
":class:`~multiprocessing.Process` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã£ã¦è‡ªå‹•çš„ã«ç¶™æ‰¿ã•ã‚Œã¾ã™ã€‚ "
"ã“ã‚Œã¯(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯)è¤‡æ•°ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å…¨ãƒ—ãƒ­ã‚»ã‚¹ãŒç›¸äº’ã«ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ ç¢ºç«‹ã™ã‚‹ã¨ãã«ä½¿ç”¨ã•ã‚Œã‚‹1ã¤ã®èªè¨¼ã‚­ãƒ¼ã‚’å…±æœ‰ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2522
msgid ""
"Suitable authentication keys can also be generated by using "
":func:`os.urandom`."
msgstr "é©å½“ãªèªè¨¼ã‚­ãƒ¼ã‚’ :func:`os.urandom` ã‚’ä½¿ç”¨ã—ã¦ç”Ÿæˆã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2526
msgid "Logging"
msgstr "ãƒ­ã‚°è¨˜éŒ²"

#: ../../library/multiprocessing.rst:2528
msgid ""
"Some support for logging is available.  Note, however, that the "
":mod:`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get"
" mixed up."
msgstr ""
"ãƒ­ã‚®ãƒ³ã‚°ã®ãŸã‚ã«ã„ãã¤ã‹ã®æ©Ÿèƒ½ãŒåˆ©ç”¨å¯èƒ½ã§ã™ã€‚ã—ã‹ã— :mod:`logging` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€ "
"(ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ç¨®åˆ¥ã«ä¾å­˜ã—ã¦)é•ã†ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã”ã¡ã‚ƒæ··ãœã«ãªã‚‹ã®ã§ã€ãƒ—ãƒ­ã‚»ã‚¹ã®å…±æœ‰ãƒ­ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2535
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr ":mod:`multiprocessing` ãŒä½¿ç”¨ã™ã‚‹ãƒ­ã‚¬ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚å¿…è¦ã«å¿œã˜ã¦æ–°ãŸãªãƒ­ã‚¬ãƒ¼ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2538
msgid ""
"When first created the logger has level :data:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr ""
"æœ€åˆã«ä½œæˆã™ã‚‹ã¨ãã€ãƒ­ã‚¬ãƒ¼ã¯ãƒ¬ãƒ™ãƒ«ã« :data:`logging.NOTSET` "
"ãŒè¨­å®šã•ã‚Œã¦ã„ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ãƒ­ã‚¬ãƒ¼ã¸é€ã‚‰ã‚Œã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ãƒ«ãƒ¼ãƒˆãƒ­ã‚¬ãƒ¼ã¸ä¼æ’­ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2542
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be"
" inherited."
msgstr ""
"Windows "
"ä¸Šã§ã¯å­ãƒ—ãƒ­ã‚»ã‚¹ãŒè¦ªãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ­ã‚¬ãƒ¼ãƒ¬ãƒ™ãƒ«ã‚’ç¶™æ‰¿ã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã•ã‚‰ã«ãã®ä»–ã®ãƒ­ã‚¬ãƒ¼ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå†…å®¹ã‚‚ã™ã¹ã¦ç¶™æ‰¿ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2549
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s]"
" %(message)s'``."
msgstr ""
"ã“ã®é–¢æ•°ã¯ :func:`get_logger` ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã‚’å®Ÿè¡Œã—ã¾ã™ãŒã€ get_logger ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã‚‹ãƒ­ã‚¬ãƒ¼ã‚’è¿”ã™ã“ã¨ã«åŠ ãˆã¦ã€ "
"``'[%(levelname)s/%(processName)s] %(message)s'`` ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ä½¿ç”¨ã—ã¦ "
":data:`sys.stderr` ã¸å‡ºåŠ›ã‚’é€ã‚‹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2554
msgid "Below is an example session with logging turned on::"
msgstr "ä»¥ä¸‹ã«ãƒ­ã‚®ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«ã—ãŸä¾‹ã‚’ç´¹ä»‹ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:2569
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr "å®Œå…¨ãªãƒ­ã‚®ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«ã®è¡¨ã«ã¤ã„ã¦ã¯ :mod:`logging` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2573
msgid "The :mod:`multiprocessing.dummy` module"
msgstr ":mod:`multiprocessing.dummy` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/multiprocessing.rst:2578
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ""
":mod:`multiprocessing.dummy` ã¯ :mod:`multiprocessing` ã® API ã‚’è¤‡è£½ã—ã¾ã™ãŒ "
":mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã§ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2585
msgid "Programming guidelines"
msgstr "ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³"

#: ../../library/multiprocessing.rst:2587
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ":mod:`multiprocessing` ã‚’ä½¿ç”¨ã™ã‚‹ã¨ãã«å®ˆã‚‹ã¹ãä¸€å®šã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã¨ã‚¤ãƒ‡ã‚£ã‚ªãƒ ã‚’æŒ™ã’ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2592
msgid "All start methods"
msgstr "ã™ã¹ã¦ã®é–‹å§‹æ–¹å¼ã«ã¤ã„ã¦"

#: ../../library/multiprocessing.rst:2594
msgid "The following applies to all start methods."
msgstr "ä»¥ä¸‹ã¯ã™ã¹ã¦ã®é–‹å§‹æ–¹å¼ã«å½“ã¦ã¯ã¾ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2596
msgid "Avoid shared state"
msgstr "å…±æœ‰çŠ¶æ…‹ã‚’é¿ã‘ã‚‹"

#: ../../library/multiprocessing.rst:2598
msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr "ã§ãã‚‹ã ã‘ãƒ—ãƒ­ã‚»ã‚¹é–“ã§å·¨å¤§ãªãƒ‡ãƒ¼ã‚¿ã‚’ç§»å‹•ã™ã‚‹ã“ã¨ã¯é¿ã‘ã‚‹ã‚ˆã†ã«ã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2601
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr ""
"ãƒ—ãƒ­ã‚»ã‚¹é–“ã®é€šä¿¡ã«ã¯ã€:mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½ãƒ¬ãƒ™ãƒ«ãªåŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’ä½¿ã†ã®ã§ã¯ãªãã€ã‚­ãƒ¥ãƒ¼ã‚„ãƒ‘ã‚¤ãƒ—ã‚’ä½¿ã†ã®ãŒè‰¯ã„ã§ã—ã‚‡ã†ã€‚"

#: ../../library/multiprocessing.rst:2605
msgid "Picklability"
msgstr "pickle åŒ–ã®å¯èƒ½æ€§"

#: ../../library/multiprocessing.rst:2607
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¸ã®å¼•æ•°ã¯ã€ pickle åŒ–ã§ãã‚‹ã‚‚ã®ã«ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2609
msgid "Thread safety of proxies"
msgstr "ãƒ—ãƒ­ã‚­ã‚·ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•æ€§"

#: ../../library/multiprocessing.rst:2611
msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr "1 ã¤ã®ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒ­ãƒƒã‚¯ã§ä¿è­·ã—ãªã„ã‹ãã‚Šã€2 ã¤ä»¥ä¸Šã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ä½¿ç”¨ã—ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2614
msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr "(ç•°ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã§ *åŒã˜* ãƒ—ãƒ­ã‚­ã‚·ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯å•é¡Œã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚)"

#: ../../library/multiprocessing.rst:2616
msgid "Joining zombie processes"
msgstr "ã‚¾ãƒ³ãƒ“ãƒ—ãƒ­ã‚»ã‚¹ã‚’ join ã™ã‚‹"

#: ../../library/multiprocessing.rst:2618
msgid ""
"On Unix when a process finishes but has not been joined it becomes a zombie."
" There should never be very many because each time a new process starts (or "
":func:`~multiprocessing.active_children` is called) all completed processes "
"which have not yet been joined will be joined.  Also calling a finished "
"process's :meth:`Process.is_alive <multiprocessing.Process.is_alive>` will "
"join the process.  Even so it is probably good practice to explicitly join "
"all the processes that you start."
msgstr ""
"Unix ä¸Šã§ã¯ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã—ãŸã¨ãã« join ã—ãªã„ã¨ã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ã‚¾ãƒ³ãƒ“ã«ãªã‚Šã¾ã™ã€‚æ–°ãŸãªãƒ—ãƒ­ã‚»ã‚¹ãŒé–‹å§‹ã™ã‚‹ (ã¾ãŸã¯ "
":func:`~multiprocessing.active_children` ãŒå‘¼ã°ã‚Œã‚‹) ã¨ãã«ã€join ã•ã‚Œã¦ã„ãªã„ã™ã¹ã¦ã®å®Œäº†ãƒ—ãƒ­ã‚»ã‚¹ãŒ "
"join ã•ã‚Œã‚‹ã®ã§ã€ã‚ã¾ã‚Šå¤šãã«ã¯ãªã‚‰ãªã„ã§ã—ã‚‡ã†ã€‚ã¾ãŸã€çµ‚äº†ã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã® :meth:`Process.is_alive "
"<multiprocessing.Process.is_alive>` ã¯ãã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ join "
"ã—ã¾ã™ã€‚ãã†ã¯è¨€ã£ã¦ã‚‚ã€è‡ªåˆ†ã§é–‹å§‹ã—ãŸã™ã¹ã¦ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ˜ç¤ºçš„ã« join ã™ã‚‹ã“ã¨ã¯ãŠãã‚‰ãè‰¯ã„ãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2626
msgid "Better to inherit than pickle/unpickle"
msgstr "pickle/unpickle ã‚ˆã‚Šç¶™æ‰¿ã™ã‚‹æ–¹ãŒè‰¯ã„"

#: ../../library/multiprocessing.rst:2628
msgid ""
"When using the *spawn* or *forkserver* start methods many types from "
":mod:`multiprocessing` need to be picklable so that child processes can use "
"them.  However, one should generally avoid sending shared objects to other "
"processes using pipes or queues. Instead you should arrange the program so "
"that a process which needs access to a shared resource created elsewhere can"
" inherit it from an ancestor process."
msgstr ""
"é–‹å§‹æ–¹å¼ã« *spawn* ã‚ã‚‹ã„ã¯ *forkserver* ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã€:mod:`multiprocessing` ã‹ã‚‰å¤šãã®å‹ã‚’ "
"pickle "
"åŒ–ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚å­ãƒ—ãƒ­ã‚»ã‚¹ã¯ãã‚Œã‚‰ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ã—ã‹ã—ã€ä¸€èˆ¬ã«ãƒ‘ã‚¤ãƒ—ã‚„ã‚­ãƒ¥ãƒ¼ã‚’ä½¿ç”¨ã—ã¦å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã«é€ä¿¡ã™ã‚‹ã“ã¨ã¯é¿ã‘ã‚‹ã¹ãã§ã™ã€‚ä»£ã‚ã‚Šã«ã€å…±æœ‰ãƒªã‚½ãƒ¼ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å¿…è¦ã®ã‚ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã¯ä¸Šä½ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ãã‚Œã‚‰ã‚’ç¶™æ‰¿ã™ã‚‹ã‚ˆã†ã«ã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2636
msgid "Avoid terminating processes"
msgstr "ãƒ—ãƒ­ã‚»ã‚¹ã®å¼·åˆ¶çµ‚äº†ã‚’é¿ã‘ã‚‹"

#: ../../library/multiprocessing.rst:2638
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr ""
"ã‚ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‚’åœæ­¢ã™ã‚‹ãŸã‚ã« :meth:`Process.terminate <multiprocessing.Process.terminate>`"
" ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ãŒç¾åœ¨ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ (ãƒ­ãƒƒã‚¯ã€ã‚»ãƒãƒ•ã‚©ã€ãƒ‘ã‚¤ãƒ—ã‚„ã‚­ãƒ¥ãƒ¼ã®ã‚ˆã†ãª) "
"å…±æœ‰ãƒªã‚½ãƒ¼ã‚¹ã‚’ç ´å£Šã—ãŸã‚Šä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰åˆ©ç”¨ã§ããªã„çŠ¶æ…‹ã‚’å¼•ãèµ·ã“ã—æ˜“ã„ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2644
msgid ""
"Therefore it is probably best to only consider using "
":meth:`Process.terminate <multiprocessing.Process.terminate>` on processes "
"which never use any shared resources."
msgstr ""
"ãã®ãŸã‚ã€å…±æœ‰ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½¿ç”¨ã—ãªã„ãƒ—ãƒ­ã‚»ã‚¹ã§ã®ã¿ :meth:`Process.terminate "
"<multiprocessing.Process.terminate>` ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’è€ƒæ…®ã™ã‚‹ã“ã¨ãŒãŠãã‚‰ãæœ€å–„ã®æ–¹æ³•ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2648
msgid "Joining processes that use queues"
msgstr "ã‚­ãƒ¥ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‚’ join ã™ã‚‹"

#: ../../library/multiprocessing.rst:2650
msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to"
" the underlying pipe.  (The child process can call the "
":meth:`Queue.cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` "
"method of the queue to avoid this behaviour.)"
msgstr ""
"ã‚­ãƒ¥ãƒ¼ã«è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ã™ã¹ã¦ã®ãƒãƒƒãƒ•ã‚¡ãƒ¼ã•ã‚ŒãŸè¦ç´ ãŒ \"feeder\" "
"ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚ˆã£ã¦ä¸‹ä½å±¤ã®ãƒ‘ã‚¤ãƒ—ã«å¯¾ã—ã¦ãƒ•ã‚£ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã¾ã§çµ‚äº†ã‚’å¾…ã¤ã¨ã„ã†ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚ (å­ãƒ—ãƒ­ã‚»ã‚¹ã¯ã“ã®å‹•ä½œã‚’é¿ã‘ã‚‹ãŸã‚ã«ã‚­ãƒ¥ãƒ¼ã® "
":meth:`Queue.cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã¶ã“ã¨ãŒã§ãã¾ã™ã€‚)"

#: ../../library/multiprocessing.rst:2656
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the"
" process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr ""
"ã“ã‚Œã¯ã‚­ãƒ¥ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ã¨ãã«ã€ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚ŒãŸã™ã¹ã¦ã®è¦ç´ ãŒæœ€çµ‚çš„ã«ãã®ãƒ—ãƒ­ã‚»ã‚¹ãŒ join "
"ã•ã‚Œã‚‹å‰ã«å‰Šé™¤ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ãã†ã—ãªã„ã¨ã€ãã®ã‚­ãƒ¥ãƒ¼ã«è¦ç´ ãŒè¿½åŠ ã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã®çµ‚äº†ã‚’ä¿è¨¼ã§ãã¾ã›ã‚“ã€‚ãƒ‡ãƒ¼ãƒ¢ãƒ³ã§ã¯ãªã„ãƒ—ãƒ­ã‚»ã‚¹ã¯è‡ªå‹•çš„ã«"
" join ã•ã‚Œã‚‹ã“ã¨ã‚‚è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2662
msgid "An example which will deadlock is the following::"
msgstr "æ¬¡ã®ä¾‹ã¯ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’å¼•ãèµ·ã“ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:2676
msgid ""
"A fix here would be to swap the last two lines (or simply remove the "
"``p.join()`` line)."
msgstr "ä¿®æ­£ã™ã‚‹ã«ã¯æœ€å¾Œã®2è¡Œã‚’å…¥ã‚Œæ›¿ãˆã¾ã™(ã¾ãŸã¯å˜ç´”ã« ``p.join()`` ã®è¡Œã‚’å‰Šé™¤ã—ã¾ã™)ã€‚"

#: ../../library/multiprocessing.rst:2679
msgid "Explicitly pass resources to child processes"
msgstr "æ˜ç¤ºçš„ã«å­ãƒ—ãƒ­ã‚»ã‚¹ã¸ãƒªã‚½ãƒ¼ã‚¹ã‚’æ¸¡ã™"

#: ../../library/multiprocessing.rst:2681
msgid ""
"On Unix using the *fork* start method, a child process can make use of a "
"shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the constructor "
"for the child process."
msgstr ""
"Unix ã§é–‹å§‹æ–¹å¼ã« *fork* "
"ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã€å­ãƒ—ãƒ­ã‚»ã‚¹ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½¿ç”¨ã—ãŸè¦ªãƒ—ãƒ­ã‚»ã‚¹å†…ã§ä½œæˆã•ã‚ŒãŸå…±æœ‰ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚ã—ã‹ã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å­ãƒ—ãƒ­ã‚»ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã«å¼•æ•°ã¨ã—ã¦æ¸¡ã™ã¹ãã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2686
msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process is "
"still alive the object will not be garbage collected in the parent process."
"  This might be important if some resource is freed when the object is "
"garbage collected in the parent process."
msgstr ""
"Windows ã‚„ä»–ã®é–‹å§‹æ–¹å¼ã¨ (å°†æ¥çš„ã«ã§ã‚‚) "
"äº’æ›æ€§ã®ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãå ´åˆã¯åˆ¥ã¨ã—ã¦ã€ã“ã‚Œã¯å­ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Ÿè¡Œä¸­ã§ã‚ã‚‹é™ã‚Šã¯è¦ªãƒ—ãƒ­ã‚»ã‚¹å†…ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚Œãªã„ã“ã¨ã‚‚ä¿è¨¼ã—ã¾ã™ã€‚ã“ã‚Œã¯è¦ªãƒ—ãƒ­ã‚»ã‚¹å†…ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ãƒˆã•ã‚ŒãŸã¨ãã«ä¸€éƒ¨ã®ãƒªã‚½ãƒ¼ã‚¹ãŒé–‹æ”¾ã•ã‚Œã¦ã—ã¾ã†å ´åˆã«é‡è¦ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2693
msgid "So for instance ::"
msgstr "ãã®ãŸã‚ã€ä¾‹ãˆã° ::"

#: ../../library/multiprocessing.rst:2705
msgid "should be rewritten as ::"
msgstr "ã¯ã€æ¬¡ã®ã‚ˆã†ã«æ›¸ãç›´ã™ã¹ãã§ã™ ::"

#: ../../library/multiprocessing.rst:2717
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr ":data:`sys.stdin` ã‚’ file-like ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ç½®ãæ›ãˆã‚‹ã“ã¨ã«æ³¨æ„ã™ã‚‹"

#: ../../library/multiprocessing.rst:2719
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ":mod:`multiprocessing` ã¯å…ƒã€…ç„¡æ¡ä»¶ã«::"

#: ../../library/multiprocessing.rst:2723
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr ""
"ã‚’ :meth:`multiprocessing.Process._bootstrap` ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸­ã§å‘¼ã³å‡ºã—ã¦ã„ã¾ã—ãŸ --- "
"ã“ã‚Œã¯ãƒ—ãƒ­ã‚»ã‚¹å†…ãƒ—ãƒ­ã‚»ã‚¹ (processes-in-processes) ã§å•é¡ŒãŒèµ·ã“ã—ã¦ã—ã¾ã„ã¾ã™ã€‚ãã“ã§ã€ã“ã‚Œã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å¤‰æ›´ã•ã‚Œã¾ã—ãŸ::"

#: ../../library/multiprocessing.rst:2729
msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call "
":meth:`~io.IOBase.close()` on this file-like object, it could result in the "
"same data being flushed to the object multiple times, resulting in "
"corruption."
msgstr ""
"ã“ã‚Œã«ã‚ˆã£ã¦ãƒ—ãƒ­ã‚»ã‚¹åŒå£«ãŒè¡çªã—ã¦ bad file descripter "
"ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã™ã¨ã„ã†æ ¹æœ¬çš„ãªå•é¡Œã¯è§£æ±ºã—ã¾ã—ãŸãŒã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚’ :func:`sys.stdin` ã‹ã‚‰ \"file-like "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ\" ã«ç½®ãæ›ãˆã‚‹ã¨ã„ã†æ½œåœ¨çš„å±é™ºã‚’æŒã¡è¾¼ã‚“ã§ã—ã¾ã„ã¾ã—ãŸã€‚å±é™ºã¨ã„ã†ã®ã¯ã€è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒ file-like ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® "
":meth:`~io.IOBase.close()` "
"ã‚’å‘¼ã³å‡ºã™ã¨ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åŒã˜ãƒ‡ãƒ¼ã‚¿ãŒä½•åº¦ã‚‚ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã•ã‚Œã€ç ´æã—ã¦ã—ã¾ã†å¯èƒ½æ€§ãŒã‚ã‚‹ã€ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚"

#: ../../library/multiprocessing.rst:2736
msgid ""
"If you write a file-like object and implement your own caching, you can make"
" it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr ""
"ã‚‚ã— file-like ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ›¸ã„ã¦ç‹¬è‡ªã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å®Ÿè£…ã™ã‚‹ãªã‚‰ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ã¨ãã«å¸¸ã« pid ã‚’è¨˜éŒ²ã—ã¦ãŠãã€pid "
"ãŒå¤‰ã‚ã£ãŸã‚‰ã‚­ãƒ¥ãƒƒã‚·ãƒ¥ã‚’æ¨ã¦ã‚‹ã“ã¨ã§ã€ãƒ•ã‚©ãƒ¼ã‚¯ã‚»ãƒ¼ãƒ•ã«ã§ãã¾ã™ã€‚ä¾‹::"

#: ../../library/multiprocessing.rst:2748
msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr "ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã¯ :issue:`5155` ã€ :issue:`5313` ã€ :issue:`5331` ã‚’è¦‹ã¦ãã ã•ã„"

#: ../../library/multiprocessing.rst:2751
msgid "The *spawn* and *forkserver* start methods"
msgstr "é–‹å§‹æ–¹å¼ãŒ *spawn* ãŠã‚ˆã³ *forkserver* ã®å ´åˆ"

#: ../../library/multiprocessing.rst:2753
msgid ""
"There are a few extra restriction which don't apply to the *fork* start "
"method."
msgstr "é–‹å§‹æ–¹å¼ã« *fork* ã‚’é©ç”¨ã—ãªã„å ´åˆã«ã„ãã¤ã‹ã®è¿½åŠ ã®åˆ¶é™äº‹é …ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2756
msgid "More picklability"
msgstr "ã•ã‚‰ãªã‚‹ pickle åŒ–ã®å¯èƒ½æ€§"

#: ../../library/multiprocessing.rst:2758
msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable. Also, "
"if you subclass :class:`~multiprocessing.Process` then make sure that "
"instances will be picklable when the :meth:`Process.start "
"<multiprocessing.Process.start>` method is called."
msgstr ""
":meth:`Process.__init__` ã¸ã®ã™ã¹ã¦ã®å¼•æ•°ã¯ pickle åŒ–ã§ãã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚ã¾ãŸ "
":class:`~multiprocessing.Process` ã‚’ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã™ã‚‹å ´åˆã€ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ :meth:`Process.start"
" <multiprocessing.Process.start>` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚ŒãŸã¨ãã« pickle åŒ–ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2763
msgid "Global variables"
msgstr "ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°"

#: ../../library/multiprocessing.rst:2765
msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start "
"<multiprocessing.Process.start>` was called."
msgstr ""
"å­ãƒ—ãƒ­ã‚»ã‚¹ã§å®Ÿè¡Œã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ãŒã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã‚ˆã†ã¨ã™ã‚‹å ´åˆã€å­ãƒ—ãƒ­ã‚»ã‚¹ãŒè¦‹ã‚‹ãã®å€¤ã¯ :meth:`Process.start "
"<multiprocessing.Process.start>` ãŒå‘¼ã°ã‚ŒãŸã¨ãã®è¦ªãƒ—ãƒ­ã‚»ã‚¹ã®å€¤ã¨åŒã˜ã§ã¯ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2770
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr "ã—ã‹ã—ã€å˜ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®å®šæ•°ã§ã‚ã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãªã‚‰å•é¡Œã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/multiprocessing.rst:2773
msgid "Safe importing of main module"
msgstr "ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å®‰å…¨ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆ"

#: ../../library/multiprocessing.rst:2775
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such a starting a new "
"process)."
msgstr ""
"æ–°ãŸãª Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã‚‹ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒã€æ„å›³ã—ãªã„å‰¯ä½œç”¨ (æ–°ãŸãªãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã™ã‚‹ç­‰) "
"ã‚’èµ·ã“ã•ãšã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/multiprocessing.rst:2779
msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr ""
"ä¾‹ãˆã°ã€é–‹å§‹æ–¹å¼ã« *spawn* ã‚ã‚‹ã„ã¯ *forkserver* ã‚’ä½¿ç”¨ã—ãŸå ´åˆã«ä»¥ä¸‹ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å®Ÿè¡Œã™ã‚‹ã¨ "
":exc:`RuntimeError` ã§å¤±æ•—ã—ã¾ã™::"

#: ../../library/multiprocessing.rst:2791
msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr ""
"ä»£ã‚ã‚Šã«ã€æ¬¡ã®ã‚ˆã†ã« ``if __name__ == '__main__':`` ã‚’ä½¿ç”¨ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã® \"ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆ\" "
"ã‚’ä¿è­·ã™ã¹ãã§ã™::"

#: ../../library/multiprocessing.rst:2805
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr "(ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒ•ãƒªãƒ¼ã‚ºã›ãšã«é€šå¸¸é€šã‚Šå®Ÿè¡Œã™ã‚‹ãªã‚‰ ``freeze_support()`` è¡Œã¯å–ã‚Šé™¤ã‘ã¾ã™ã€‚)"

#: ../../library/multiprocessing.rst:2808
msgid ""
"This allows the newly spawned Python interpreter to safely import the module"
" and then run the module's ``foo()`` function."
msgstr ""
"ã“ã‚Œã¯æ–°ãŸã«ç”Ÿæˆã•ã‚ŒãŸ Python ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ãŒãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å®‰å…¨ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``foo()`` é–¢æ•°ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2811
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr "ãƒ—ãƒ¼ãƒ«ã¾ãŸã¯ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä½œæˆã•ã‚Œã‚‹å ´åˆã«ä¼¼ãŸã‚ˆã†ãªåˆ¶é™ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/multiprocessing.rst:2818
msgid "Examples"
msgstr "ä½¿ç”¨ä¾‹"

#: ../../library/multiprocessing.rst:2820
msgid ""
"Demonstration of how to create and use customized managers and proxies:"
msgstr "ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚„ãƒ—ãƒ­ã‚­ã‚·ã®ä½œæˆæ–¹æ³•ã¨ä½¿ç”¨æ–¹æ³•ã‚’ç´¹ä»‹ã—ã¾ã™:"

#: ../../library/multiprocessing.rst:2826
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr ":class:`~multiprocessing.pool.Pool` ã‚’ä½¿ç”¨ã™ã‚‹ä¾‹ã§ã™:"

#: ../../library/multiprocessing.rst:2832
msgid ""
"An example showing how to use queues to feed tasks to a collection of worker"
" processes and collect the results:"
msgstr "ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«å¯¾ã—ã¦ã‚¿ã‚¹ã‚¯ã‚’ãƒ•ã‚£ãƒ¼ãƒ‰ã—ã¦ãã®çµæœã‚’ã¾ã¨ã‚ã‚‹ã‚­ãƒ¥ãƒ¼ã®ä½¿ã„æ–¹ã®ä¾‹ã‚’ç´¹ä»‹ã—ã¾ã™:"
