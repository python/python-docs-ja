# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Osamu NAKAMURA, 2021
# Takanori Suzuki <takanori@takanory.net>, 2021
# 菊池 健志, 2023
# tomo, 2023
# Arihiro TAKASE, 2023
# souma987, 2024
# 石井明久, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-06 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:10+0000\n"
"Last-Translator: 石井明久, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/multiprocessing.rst:2
msgid ":mod:`!multiprocessing` --- Process-based parallelism"
msgstr ":mod:`!multiprocessing` --- プロセスベースの並列処理"

#: ../../library/multiprocessing.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**ソースコード:** :source:`Lib/multiprocessing/`"

#: ../../includes/wasm-ios-notavail.rst:3
msgid ":ref:`Availability <availability>`: not WASI, not iOS."
msgstr ":ref:`利用可能な環境 <availability>`: WASI 及び iOS 以外。"

#: ../../includes/wasm-ios-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms, or "
"on iOS. See :ref:`wasm-availability` for more information on WASM "
"availability; see :ref:`iOS-availability` for more information on iOS "
"availability."
msgstr ""
"このモジュールは WebAssembly プラットフォームと iOS では動作しないか、利用不"
"可です。 WASM 上での利用可能性についてのさらなる情報は :ref:`wasm-"
"availability` を、 iOS 上での利用可能性についてのさらなる情報は :ref:`iOS-"
"availability` を見てください。"

#: ../../library/multiprocessing.rst:14
msgid "Introduction"
msgstr "はじめに"

#: ../../library/multiprocessing.rst:16
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock <global interpreter lock>` by using "
"subprocesses instead of threads.  Due to this, the :mod:`multiprocessing` "
"module allows the programmer to fully leverage multiple processors on a "
"given machine.  It runs on both POSIX and Windows."
msgstr ""

#: ../../library/multiprocessing.rst:25
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the :"
"class:`~multiprocessing.pool.Pool` object which offers a convenient means of "
"parallelizing the execution of a function across multiple input values, "
"distributing the input data across processes (data parallelism).  The "
"following example demonstrates the common practice of defining such "
"functions in a module so that child processes can successfully import that "
"module.  This basic example of data parallelism using :class:"
"`~multiprocessing.pool.Pool`, ::"
msgstr ""
":mod:`multiprocessing` モジュールでは、:mod:`threading` モジュールには似たも"
"のが存在しない API も導入されています。その最たるものが :class:"
"`~multiprocessing.pool.Pool` オブジェクトです。これは複数の入力データに対し"
"て、サブプロセス群に入力データを分配 (データ並列) して関数を並列実行するのに"
"便利な手段を提供します。以下の例では、モジュール内で関数を定義して、子プロセ"
"スがそのモジュールを正常にインポートできるようにする一般的な方法を示しま"
"す。 :class:`~multiprocessing.pool.Pool` を用いたデータ並列の基礎的な例は次の"
"通りです::"

#: ../../library/multiprocessing.rst:34
msgid ""
"from multiprocessing import Pool\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(5) as p:\n"
"        print(p.map(f, [1, 2, 3]))"
msgstr ""

#: ../../library/multiprocessing.rst:43
msgid "will print to standard output ::"
msgstr "標準出力に以下が出力されます::"

#: ../../library/multiprocessing.rst:45
msgid "[1, 4, 9]"
msgstr ""

#: ../../library/multiprocessing.rst:50
msgid ""
":class:`concurrent.futures.ProcessPoolExecutor` offers a higher level "
"interface to push tasks to a background process without blocking execution "
"of the calling process. Compared to using the :class:`~multiprocessing.pool."
"Pool` interface directly, the :mod:`concurrent.futures` API more readily "
"allows the submission of work to the underlying process pool to be separated "
"from waiting for the results."
msgstr ""

#: ../../library/multiprocessing.rst:59
msgid "The :class:`Process` class"
msgstr ":class:`Process` クラス"

#: ../../library/multiprocessing.rst:61
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a :class:"
"`Process` object and then calling its :meth:`~Process.start` method.  :class:"
"`Process` follows the API of :class:`threading.Thread`.  A trivial example "
"of a multiprocess program is ::"
msgstr ""
":mod:`multiprocessing` モジュールでは、プロセスは以下の手順によって生成されま"
"す。はじめに :class:`Process` のオブジェクトを作成し、続いて :meth:`~Process."
"start` メソッドを呼び出します。この :class:`Process` クラスは :class:"
"`threading.Thread` クラスと同様の API を持っています。まずは、簡単な例をもと"
"にマルチプロセスを使用したプログラムについてみていきましょう ::"

#: ../../library/multiprocessing.rst:66
msgid ""
"from multiprocessing import Process\n"
"\n"
"def f(name):\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""

#: ../../library/multiprocessing.rst:76
msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr ""
"実行された個々のプロセス ID を表示するために拡張したサンプルコードを以下に示"
"します::"

#: ../../library/multiprocessing.rst:78
msgid ""
"from multiprocessing import Process\n"
"import os\n"
"\n"
"def info(title):\n"
"    print(title)\n"
"    print('module name:', __name__)\n"
"    print('parent process:', os.getppid())\n"
"    print('process id:', os.getpid())\n"
"\n"
"def f(name):\n"
"    info('function f')\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    info('main line')\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""

#: ../../library/multiprocessing.rst:97
msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"なぜ ``if __name__ == '__main__'`` という記述が必要かは :ref:"
"`multiprocessing-programming` を参照してください。"

#: ../../library/multiprocessing.rst:105
msgid "Contexts and start methods"
msgstr "コンテキストと開始方式"

#: ../../library/multiprocessing.rst:107
msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr ""
"プラットフォームにもよりますが、:mod:`multiprocessing` はプロセスを開始するた"
"めに 3 つの方法をサポートしています。それら *開始方式* は以下のとおりです"

#: ../../library/multiprocessing.rst:110
msgid "*spawn*"
msgstr "*spawn*"

#: ../../library/multiprocessing.rst:111
msgid ""
"The parent process starts a fresh Python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"object's :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using *fork* "
"or *forkserver*."
msgstr ""
"親プロセスは新たに Python インタープリタープロセスを開始します。子プロセスは"
"プロセスオブジェクトの :meth:`~Process.run` メソッドの実行に必要なリソースの"
"み継承します。特に、親プロセスからの不要なファイル記述子とハンドルは継承され"
"ません。この方式を使用したプロセスの開始は *fork* や *forkserver* に比べ遅く"
"なります。"

#: ../../library/multiprocessing.rst:118
msgid ""
"Available on POSIX and Windows platforms.  The default on Windows and macOS."
msgstr ""

#: ../../library/multiprocessing.rst:120
msgid "*fork*"
msgstr "*fork*"

#: ../../library/multiprocessing.rst:121
msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  The "
"child process, when it begins, is effectively identical to the parent "
"process.  All resources of the parent are inherited by the child process.  "
"Note that safely forking a multithreaded process is problematic."
msgstr ""
"親プロセスは :func:`os.fork` を使用して Python インタープリターをフォークしま"
"す。子プロセスはそれが開始されるとき、事実上親プロセスと同一になります。親プ"
"ロセスのリソースはすべて子プロセスに継承されます。マルチスレッドプロセスの"
"フォークは安全性に問題があることに注意してください。"

#: ../../library/multiprocessing.rst:127
msgid ""
"Available on POSIX systems.  Currently the default on POSIX except macOS."
msgstr ""

#: ../../library/multiprocessing.rst:130
msgid ""
"The default start method will change away from *fork* in Python 3.14. Code "
"that requires *fork* should explicitly specify that via :func:`get_context` "
"or :func:`set_start_method`."
msgstr ""

#: ../../library/multiprocessing.rst:134
msgid ""
"If Python is able to detect that your process has multiple threads, the :"
"func:`os.fork` function that this start method calls internally will raise "
"a :exc:`DeprecationWarning`. Use a different start method. See the :func:`os."
"fork` documentation for further explanation."
msgstr ""

#: ../../library/multiprocessing.rst:140
msgid "*forkserver*"
msgstr "*forkserver*"

#: ../../library/multiprocessing.rst:141
msgid ""
"When the program starts and selects the *forkserver* start method, a server "
"process is spawned.  From then on, whenever a new process is needed, the "
"parent process connects to the server and requests that it fork a new "
"process.  The fork server process is single threaded unless system libraries "
"or preloaded imports spawn threads as a side-effect so it is generally safe "
"for it to use :func:`os.fork`. No unnecessary resources are inherited."
msgstr ""

#: ../../library/multiprocessing.rst:149
msgid ""
"Available on POSIX platforms which support passing file descriptors over "
"Unix pipes such as Linux."
msgstr ""

#: ../../library/multiprocessing.rst:153
msgid ""
"*spawn* added on all POSIX platforms, and *forkserver* added for some POSIX "
"platforms. Child processes no longer inherit all of the parents inheritable "
"handles on Windows."
msgstr ""

#: ../../library/multiprocessing.rst:161
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess as macOS system libraries may start threads. See :issue:`33725`."
msgstr ""

#: ../../library/multiprocessing.rst:165
msgid ""
"On POSIX using the *spawn* or *forkserver* start methods will also start a "
"*resource tracker* process which tracks the unlinked named system resources "
"(such as named semaphores or :class:`~multiprocessing.shared_memory."
"SharedMemory` objects) created by processes of the program.  When all "
"processes have exited the resource tracker unlinks any remaining tracked "
"object. Usually there should be none, but if a process was killed by a "
"signal there may be some \"leaked\" resources.  (Neither leaked semaphores "
"nor shared memory segments will be automatically unlinked until the next "
"reboot. This is problematic for both objects because the system allows only "
"a limited number of named semaphores, and shared memory segments occupy some "
"space in the main memory.)"
msgstr ""

#: ../../library/multiprocessing.rst:178
msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if "
"__name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"開始方式はメインモジュールの ``if __name__ == '__main__'`` 節内で、関数 :"
"func:`set_start_method` によって指定します。以下に例を示します::"

#: ../../library/multiprocessing.rst:182
msgid ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    mp.set_start_method('spawn')\n"
"    q = mp.Queue()\n"
"    p = mp.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"
msgstr ""

#: ../../library/multiprocessing.rst:195
msgid ""
":func:`set_start_method` should not be used more than once in the program."
msgstr ""
"関数 :func:`set_start_method` はプログラム内で複数回使用してはいけません。"

#: ../../library/multiprocessing.rst:198
msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context object.  "
"Context objects have the same API as the multiprocessing module, and allow "
"one to use multiple start methods in the same program. ::"
msgstr ""
"もうひとつの方法として、:func:`get_context` を使用してコンテキストオブジェク"
"トを取得することができます。コンテキストオブジェクトは multiprocessing モ"
"ジュールと同じ API を持ち、同じプログラム内で複数の開始方式を使用できま"
"す。 ::"

#: ../../library/multiprocessing.rst:203
msgid ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    ctx = mp.get_context('spawn')\n"
"    q = ctx.Queue()\n"
"    p = ctx.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"
msgstr ""

#: ../../library/multiprocessing.rst:216
msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using the "
"*fork* context cannot be passed to processes started using the *spawn* or "
"*forkserver* start methods."
msgstr ""
"あるコンテキストに関連したオブジェクトは、異なるコンテキストのプロセスとは互"
"換性がない場合があることに注意してください。特に、*fork* コンテキストを使用し"
"て作成されたロックは、*spawn* あるいは *forkserver* を使用して開始されたプロ"
"セスに渡すことはできません。 "

#: ../../library/multiprocessing.rst:221
msgid ""
"A library which wants to use a particular start method should probably use :"
"func:`get_context` to avoid interfering with the choice of the library user."
msgstr ""
"特定の開始方式の使用を要求するライブラリは :func:`get_context` を使用してライ"
"ブラリ利用者の選択を阻害しないようにするべきです。"

#: ../../library/multiprocessing.rst:227
msgid ""
"The ``'spawn'`` and ``'forkserver'`` start methods generally cannot be used "
"with \"frozen\" executables (i.e., binaries produced by packages like "
"**PyInstaller** and **cx_Freeze**) on POSIX systems. The ``'fork'`` start "
"method may work if code does not use threads."
msgstr ""

#: ../../library/multiprocessing.rst:234
msgid "Exchanging objects between processes"
msgstr "プロセス間でのオブジェクト交換"

#: ../../library/multiprocessing.rst:236
msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ""
":mod:`multiprocessing` モジュールでは、プロセス間通信の手段が2つ用意されてい"
"ます。それぞれ以下に詳細を示します:"

#: ../../library/multiprocessing.rst:239
msgid "**Queues**"
msgstr "**キュー (Queue)**"

#: ../../library/multiprocessing.rst:241
msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr ""
":class:`Queue` クラスは :class:`queue.Queue` クラスとほとんど同じように使うこ"
"とができます。以下に例を示します::"

#: ../../library/multiprocessing.rst:244
msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put([42, None, 'hello'])\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    p = Process(target=f, args=(q,))\n"
"    p.start()\n"
"    print(q.get())    # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""

#: ../../library/multiprocessing.rst:256
msgid ""
"Queues are thread and process safe. Any object put into a :mod:"
"`~multiprocessing` queue will be serialized."
msgstr ""

#: ../../library/multiprocessing.rst:259
msgid "**Pipes**"
msgstr "**パイプ (Pipe)**"

#: ../../library/multiprocessing.rst:261
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ""
":func:`Pipe` 関数はパイプで繋がれたコネクションオブジェクトのペアを返します。"
"デフォルトでは双方向性パイプを返します。以下に例を示します::"

#: ../../library/multiprocessing.rst:264
msgid ""
"from multiprocessing import Process, Pipe\n"
"\n"
"def f(conn):\n"
"    conn.send([42, None, 'hello'])\n"
"    conn.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    parent_conn, child_conn = Pipe()\n"
"    p = Process(target=f, args=(child_conn,))\n"
"    p.start()\n"
"    print(parent_conn.recv())   # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""

#: ../../library/multiprocessing.rst:277
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and :meth:"
"`~Connection.recv` methods (among others).  Note that data in a pipe may "
"become corrupted if two processes (or threads) try to read from or write to "
"the *same* end of the pipe at the same time.  Of course there is no risk of "
"corruption from processes using different ends of the pipe at the same time."
msgstr ""
"パイプのそれぞれの端を表す2つのコネクションオブジェクトが :func:`Pipe` 関数か"
"ら返されます。各コネクションオブジェクトには、 :meth:`~Connection.send`、 :"
"meth:`~Connection.recv`、その他のメソッドがあります。2つのプロセス (またはス"
"レッド) がパイプの *同じ* 端で同時に読み込みや書き込みを行うと、パイプ内の"
"データが破損してしまうかもしれないことに注意してください。もちろん、各プロセ"
"スがパイプの別々の端を同時に使用するならば、データが破壊される危険性はありま"
"せん。"

#: ../../library/multiprocessing.rst:285
msgid ""
"The :meth:`~Connection.send` method serializes the the object and :meth:"
"`~Connection.recv` re-creates the object."
msgstr ""

#: ../../library/multiprocessing.rst:289
msgid "Synchronization between processes"
msgstr "プロセス間の同期"

#: ../../library/multiprocessing.rst:291
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure "
"that only one process prints to standard output at a time::"
msgstr ""
":mod:`multiprocessing` は :mod:`threading` モジュールと等価な同期プリミティブ"
"を備えています。以下の例では、ロックを使用して、一度に1つのプロセスしか標準出"
"力に書き込まないようにしています::"

#: ../../library/multiprocessing.rst:295
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l, i):\n"
"    l.acquire()\n"
"    try:\n"
"        print('hello world', i)\n"
"    finally:\n"
"        l.release()\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    for num in range(10):\n"
"        Process(target=f, args=(lock, num)).start()"
msgstr ""

#: ../../library/multiprocessing.rst:310
msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr ""
"ロックを使用しないで標準出力に書き込んだ場合は、各プロセスからの出力がごちゃ"
"まぜになってしまいます。"

#: ../../library/multiprocessing.rst:315
msgid "Sharing state between processes"
msgstr "プロセス間での状態の共有"

#: ../../library/multiprocessing.rst:317
msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when "
"using multiple processes."
msgstr ""
"これまでの話の流れで触れたとおり、並行プログラミングを行うときには、できるか"
"ぎり状態を共有しないのが定石です。複数のプロセスを使用するときは特にそうで"
"しょう。"

#: ../../library/multiprocessing.rst:321
msgid ""
"However, if you really do need to use some shared data then :mod:"
"`multiprocessing` provides a couple of ways of doing so."
msgstr ""
"しかし、どうしてもプロセス間のデータ共有が必要な場合のために :mod:"
"`multiprocessing` モジュールには2つの方法が用意されています。"

#: ../../library/multiprocessing.rst:324
msgid "**Shared memory**"
msgstr "**共有メモリ (Shared memory)**"

#: ../../library/multiprocessing.rst:326
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or :class:"
"`Array`.  For example, the following code ::"
msgstr ""
"データを共有メモリ上に保持するために :class:`Value` クラス、もしくは :class:"
"`Array` クラスを使用することができます。以下のサンプルコードを使って、この機"
"能についてみていきましょう ::"

#: ../../library/multiprocessing.rst:329
msgid ""
"from multiprocessing import Process, Value, Array\n"
"\n"
"def f(n, a):\n"
"    n.value = 3.1415927\n"
"    for i in range(len(a)):\n"
"        a[i] = -a[i]\n"
"\n"
"if __name__ == '__main__':\n"
"    num = Value('d', 0.0)\n"
"    arr = Array('i', range(10))\n"
"\n"
"    p = Process(target=f, args=(num, arr))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(num.value)\n"
"    print(arr[:])"
msgstr ""

#: ../../library/multiprocessing.rst:347 ../../library/multiprocessing.rst:393
msgid "will print ::"
msgstr "このサンプルコードを実行すると以下のように表示されます ::"

#: ../../library/multiprocessing.rst:349
msgid ""
"3.1415927\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]"
msgstr ""

#: ../../library/multiprocessing.rst:352
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are "
"typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared "
"objects will be process and thread-safe."
msgstr ""
"``num`` と ``arr`` を生成するときに使用されている、引数 ``'d'`` と ``'i'`` "
"は :mod:`array` モジュールにより使用される種別の型コードです。ここで使用され"
"ている ``'d'`` は倍精度浮動小数、 ``'i'`` は符号付整数を表します。これらの共"
"有オブジェクトは、プロセスセーフでありスレッドセーフです。"

#: ../../library/multiprocessing.rst:357
msgid ""
"For more flexibility in using shared memory one can use the :mod:"
"`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr ""
"共有メモリを使用して、さらに柔軟なプログラミングを行うには :mod:"
"`multiprocessing.sharedctypes` モジュールを使用します。このモジュールは共有メ"
"モリから割り当てられた任意の ctypes オブジェクトの生成をサポートします。"

#: ../../library/multiprocessing.rst:361
msgid "**Server process**"
msgstr "**サーバープロセス (Server process)**"

#: ../../library/multiprocessing.rst:363
msgid ""
"A manager object returned by :func:`Manager` controls a server process which "
"holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ""
":func:`Manager` 関数により生成されたマネージャーオブジェクトはサーバープロセ"
"スを管理します。マネージャーオブジェクトは Python のオブジェクトを保持して、"
"他のプロセスがプロキシ経由でその Python オブジェクトを操作することができま"
"す。"

#: ../../library/multiprocessing.rst:367
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, :"
"class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, :"
"class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, :class:"
"`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` and :class:"
"`Array`.  For example, ::"
msgstr ""
":func:`Manager` 関数が返すマネージャは :class:`list`, :class:`dict`, :class:"
"`~managers.Namespace`, :class:`Lock`, :class:`RLock`, :class:`Semaphore`, :"
"class:`BoundedSemaphore`, :class:`Condition`, :class:`Event`, :class:"
"`Barrier`, :class:`Queue`, :class:`Value`, :class:`Array` をサポートします。 "
"以下にサンプルコードを示します。 ::"

#: ../../library/multiprocessing.rst:373
msgid ""
"from multiprocessing import Process, Manager\n"
"\n"
"def f(d, l):\n"
"    d[1] = '1'\n"
"    d['2'] = 2\n"
"    d[0.25] = None\n"
"    l.reverse()\n"
"\n"
"if __name__ == '__main__':\n"
"    with Manager() as manager:\n"
"        d = manager.dict()\n"
"        l = manager.list(range(10))\n"
"\n"
"        p = Process(target=f, args=(d, l))\n"
"        p.start()\n"
"        p.join()\n"
"\n"
"        print(d)\n"
"        print(l)"
msgstr ""

#: ../../library/multiprocessing.rst:395
msgid ""
"{0.25: None, 1: '1', '2': 2}\n"
"[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]"
msgstr ""

#: ../../library/multiprocessing.rst:398
msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr ""
"サーバープロセスのマネージャーオブジェクトは共有メモリのオブジェクトよりも柔"
"軟であるといえます。それは、どのような型のオブジェクトでも使えるからです。ま"
"た、1つのマネージャーオブジェクトはネットワーク経由で他のコンピューター上のプ"
"ロセスによって共有することもできます。しかし、共有メモリより動作が遅いという"
"欠点があります。"

#: ../../library/multiprocessing.rst:405
msgid "Using a pool of workers"
msgstr "ワーカープロセスのプールを使用"

#: ../../library/multiprocessing.rst:407
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ""
":class:`~multiprocessing.pool.Pool` クラスは、ワーカープロセスをプールする機"
"能を備えています。このクラスには、異なる方法でワーカープロセスへタスクを割り"
"当てるいくつかのメソッドがあります。"

#: ../../library/multiprocessing.rst:411
msgid "For example::"
msgstr "例えば::"

#: ../../library/multiprocessing.rst:413
msgid ""
"from multiprocessing import Pool, TimeoutError\n"
"import time\n"
"import os\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    # start 4 worker processes\n"
"    with Pool(processes=4) as pool:\n"
"\n"
"        # print \"[0, 1, 4,..., 81]\"\n"
"        print(pool.map(f, range(10)))\n"
"\n"
"        # print same numbers in arbitrary order\n"
"        for i in pool.imap_unordered(f, range(10)):\n"
"            print(i)\n"
"\n"
"        # evaluate \"f(20)\" asynchronously\n"
"        res = pool.apply_async(f, (20,))      # runs in *only* one process\n"
"        print(res.get(timeout=1))             # prints \"400\"\n"
"\n"
"        # evaluate \"os.getpid()\" asynchronously\n"
"        res = pool.apply_async(os.getpid, ()) # runs in *only* one process\n"
"        print(res.get(timeout=1))             # prints the PID of that "
"process\n"
"\n"
"        # launching multiple evaluations asynchronously *may* use more "
"processes\n"
"        multiple_results = [pool.apply_async(os.getpid, ()) for i in "
"range(4)]\n"
"        print([res.get(timeout=1) for res in multiple_results])\n"
"\n"
"        # make a single worker sleep for 10 seconds\n"
"        res = pool.apply_async(time.sleep, (10,))\n"
"        try:\n"
"            print(res.get(timeout=1))\n"
"        except TimeoutError:\n"
"            print(\"We lacked patience and got a multiprocessing."
"TimeoutError\")\n"
"\n"
"        print(\"For the moment, the pool remains available for more work\")\n"
"\n"
"    # exiting the 'with'-block has stopped the pool\n"
"    print(\"Now the pool is closed and no longer available\")"
msgstr ""

#: ../../library/multiprocessing.rst:455
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr ""
"プールオブジェクトのメソッドは、そのプールを作成したプロセスのみが呼び出すべ"
"きです。"

#: ../../library/multiprocessing.rst:460
msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will not "
"work in the interactive interpreter. For example::"
msgstr ""
"このパッケージに含まれる機能を使用するためには、子プロセスから ``__main__`` "
"モジュールをインポートできる必要があります。このことについては :ref:"
"`multiprocessing-programming` で触れていますが、ここであらためて強調しておき"
"ます。なぜかというと、いくつかのサンプルコード、例えば :class:"
"`multiprocessing.pool.Pool` のサンプルはインタラクティブシェル上では動作しな"
"いからです。以下に例を示します::"

#: ../../library/multiprocessing.rst:466
msgid ""
">>> from multiprocessing import Pool\n"
">>> p = Pool(5)\n"
">>> def f(x):\n"
"...     return x*x\n"
"...\n"
">>> with p:\n"
"...     p.map(f, [1,2,3])\n"
"Process PoolWorker-1:\n"
"Process PoolWorker-2:\n"
"Process PoolWorker-3:\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>"
msgstr ""

#: ../../library/multiprocessing.rst:483
msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the parent process "
"somehow.)"
msgstr ""
"(もしこのコードを試すなら、実際には3つの完全なトレースバックがばらばらの順番"
"で出力されますし、親プロセスを何らかの方法で止める必要があります。)"

#: ../../library/multiprocessing.rst:489
msgid "Reference"
msgstr "リファレンス"

#: ../../library/multiprocessing.rst:491
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the :mod:"
"`threading` module."
msgstr ""
":mod:`multiprocessing` パッケージは :mod:`threading` モジュールの API とほと"
"んど同じです。"

#: ../../library/multiprocessing.rst:496
msgid ":class:`Process` and exceptions"
msgstr ":class:`Process` クラスと例外"

#: ../../library/multiprocessing.rst:501
msgid ""
"Process objects represent activity that is run in a separate process. The :"
"class:`Process` class has equivalents of all the methods of :class:"
"`threading.Thread`."
msgstr ""
"Process オブジェクトは各プロセスの処理を表します。 :class:`Process` クラス"
"は :class:`threading.Thread` クラスのすべてのメソッドと同じインターフェースを"
"提供します。"

#: ../../library/multiprocessing.rst:505
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with :class:"
"`threading.Thread`.  *target* is the callable object to be invoked by the :"
"meth:`run` method.  It defaults to ``None``, meaning nothing is called. "
"*name* is the process name (see :attr:`name` for more details). *args* is "
"the argument tuple for the target invocation.  *kwargs* is a dictionary of "
"keyword arguments for the target invocation.  If provided, the keyword-only "
"*daemon* argument sets the process :attr:`daemon` flag to ``True`` or "
"``False``.  If ``None`` (the default), this flag will be inherited from the "
"creating process."
msgstr ""

#: ../../library/multiprocessing.rst:516
msgid ""
"By default, no arguments are passed to *target*. The *args* argument, which "
"defaults to ``()``, can be used to specify a list or tuple of the arguments "
"to pass to *target*."
msgstr ""
"デフォルトでは、*target* に何の引数も与えられません。(実) 引数 *args* (デフォ"
"ルトは``()``)は、*target* に渡す引数のリストまたはタプルを指定するために使用"
"されます。"

#: ../../library/multiprocessing.rst:520
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (:meth:`Process.__init__`) before doing anything else "
"to the process."
msgstr ""
"サブクラスがコンストラクターをオーバーライドする場合は、そのプロセスに対する"
"処理を行う前に基底クラスのコンストラクター (:meth:`Process.__init__`) を実行"
"しなければなりません。"

#: ../../library/multiprocessing.rst:524
msgid "Added the *daemon* parameter."
msgstr ""

#: ../../library/multiprocessing.rst:529
msgid "Method representing the process's activity."
msgstr "プロセスが実行する処理を表すメソッドです。"

#: ../../library/multiprocessing.rst:531
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the target "
"argument, if any, with sequential and keyword arguments taken from the "
"*args* and *kwargs* arguments, respectively."
msgstr ""
"このメソッドはサブクラスでオーバーライドすることができます。標準の :meth:"
"`run` メソッドは、コンストラクターの target 引数として渡された呼び出し可能オ"
"ブジェクトを呼び出します。もしコンストラクターに *args* もしくは *kwargs* 引"
"数が渡されていれば、呼び出すオブジェクトにこれらの引数を渡します。"

#: ../../library/multiprocessing.rst:536
msgid ""
"Using a list or tuple as the *args* argument passed to :class:`Process` "
"achieves the same effect."
msgstr ""
":class:`Process` に渡される *args* の引数にリストやタプルを使っても、同じ効果"
"が得られます。"

#: ../../library/multiprocessing.rst:539
msgid "Example::"
msgstr "以下はプログラム例です::"

#: ../../library/multiprocessing.rst:541
msgid ""
">>> from multiprocessing import Process\n"
">>> p = Process(target=print, args=[1])\n"
">>> p.run()\n"
"1\n"
">>> p = Process(target=print, args=(1,))\n"
">>> p.run()\n"
"1"
msgstr ""

#: ../../library/multiprocessing.rst:551
msgid "Start the process's activity."
msgstr "プロセスの処理を開始するためのメソッドです。"

#: ../../library/multiprocessing.rst:553
msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr ""
"各 Process オブジェクトに対し、このメソッドが2回以上呼び出されてはいけませ"
"ん。各プロセスでオブジェクトの :meth:`run` メソッドを呼び出す準備を行います。"

#: ../../library/multiprocessing.rst:558
msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. If "
"*timeout* is a positive number, it blocks at most *timeout* seconds. Note "
"that the method returns ``None`` if its process terminates or if the method "
"times out.  Check the process's :attr:`exitcode` to determine if it "
"terminated."
msgstr ""
"オプションの引数 *timeout* が ``None`` (デフォルト) の場合、 :meth:`join` メ"
"ソッドが呼ばれたプロセスは処理が終了するまでブロックします。\n"
"*timeout* が正の数である場合、最大 *timeout* 秒ブロックします。\n"
"プロセスが終了あるいはタイムアウトした場合、メソッドは ``None`` を返すことに"
"注意してください。\n"
"プロセスの :attr:`exitcode` を確認し終了したかどうかを判断してください。"

#: ../../library/multiprocessing.rst:565
msgid "A process can be joined many times."
msgstr "1つのプロセスは何回も join されることができます。"

#: ../../library/multiprocessing.rst:567
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr ""
"プロセスは自分自身を join することはできません。それはデッドロックを引き起こ"
"すことがあるからです。プロセスが start される前に join しようとするとエラーが"
"発生します。"

#: ../../library/multiprocessing.rst:572
msgid ""
"The process's name.  The name is a string used for identification purposes "
"only.  It has no semantics.  Multiple processes may be given the same name."
msgstr ""
"プロセスの名前。名前は識別のためだけに使用される文字列です。それ自体には特別"
"な意味はありません。複数のプロセスに同じ名前が与えられても構いません。"

#: ../../library/multiprocessing.rst:576
msgid ""
"The initial name is set by the constructor.  If no explicit name is provided "
"to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\ :sub:"
"`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is the N-th "
"child of its parent."
msgstr ""
"最初の名前はコンストラクターによってセットされます。コンストラクターに明示的"
"な名前が渡されない場合、 'Process-N\\ :sub:`1`:N\\ :sub:`2`:...:N\\ :sub:"
"`k`' 形式の名前が構築されます。ここでそれぞれの N\\ :sub:`k` はその親のN番目"
"の子供です。"

#: ../../library/multiprocessing.rst:583
msgid "Return whether the process is alive."
msgstr "プロセスが実行中かを判別します。"

#: ../../library/multiprocessing.rst:585
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr ""
"おおまかに言って、プロセスオブジェクトは :meth:`start` メソッドを呼び出してか"
"ら子プロセス終了までの期間が実行中となります。"

#: ../../library/multiprocessing.rst:590
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before :meth:"
"`start` is called."
msgstr ""
"デーモンプロセスであるかのフラグであり、ブール値です。この属性は :meth:"
"`start` が呼び出される前に設定されている必要があります。"

#: ../../library/multiprocessing.rst:593
msgid "The initial value is inherited from the creating process."
msgstr "初期値は作成するプロセスから継承します。"

#: ../../library/multiprocessing.rst:595
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr ""
"あるプロセスが終了するとき、そのプロセスはその子プロセスであるデーモンプロセ"
"スすべてを終了させようとします。"

#: ../../library/multiprocessing.rst:598
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr ""
"デーモンプロセスは子プロセスを作成できないことに注意してください。もし作成で"
"きてしまうと、そのデーモンプロセスの親プロセスが終了したときにデーモンプロセ"
"スの子プロセスが孤児になってしまう場合があるからです。さらに言えば、デーモン"
"プロセスはUnix デーモンやサービスでは **なく** 通常のプロセスであり、非デーモ"
"ンプロセスが終了すると終了されます (そして join されません)。"

#: ../../library/multiprocessing.rst:604
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr ""
":class:`threading.Thread` クラスの API に加えて :class:`Process` クラスのオブ"
"ジェクトには以下の属性およびメソッドがあります:"

#: ../../library/multiprocessing.rst:609
msgid ""
"Return the process ID.  Before the process is spawned, this will be ``None``."
msgstr "プロセスIDを返します。プロセスの生成前は ``None`` が設定されています。"

#: ../../library/multiprocessing.rst:614
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated."
msgstr ""

#: ../../library/multiprocessing.rst:617
msgid ""
"If the child's :meth:`run` method returned normally, the exit code will be "
"0.  If it terminated via :func:`sys.exit` with an integer argument *N*, the "
"exit code will be *N*."
msgstr ""

#: ../../library/multiprocessing.rst:621
msgid ""
"If the child terminated due to an exception not caught within :meth:`run`, "
"the exit code will be 1.  If it was terminated by signal *N*, the exit code "
"will be the negative value *-N*."
msgstr ""

#: ../../library/multiprocessing.rst:627
msgid "The process's authentication key (a byte string)."
msgstr "プロセスの認証キーです (バイト文字列です)。"

#: ../../library/multiprocessing.rst:629
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr ""
":mod:`multiprocessing` モジュールがメインプロセスにより初期化される場合に"
"は、 :func:`os.urandom` 関数を使用してランダムな値が設定されます。"

#: ../../library/multiprocessing.rst:632
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ""
":class:`Process` クラスのオブジェクトの作成時にその親プロセスから認証キーを継"
"承します。もしくは :attr:`authkey` に別のバイト文字列を設定することもできま"
"す。"

#: ../../library/multiprocessing.rst:636
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "詳細は :ref:`multiprocessing-auth-keys` を参照してください。"

#: ../../library/multiprocessing.rst:640
msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr ""
"プロセスが終了するときに \"ready\" となるシステムオブジェクトの数値ハンドル。"

#: ../../library/multiprocessing.rst:643
msgid ""
"You can use this value if you want to wait on several events at once using :"
"func:`multiprocessing.connection.wait`.  Otherwise calling :meth:`join` is "
"simpler."
msgstr ""

#: ../../library/multiprocessing.rst:647
msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` and "
"``WaitForMultipleObjects`` family of API calls.  On POSIX, this is a file "
"descriptor usable with primitives from the :mod:`select` module."
msgstr ""

#: ../../library/multiprocessing.rst:655
msgid ""
"Terminate the process.  On POSIX this is done using the :py:const:`~signal."
"SIGTERM` signal; on Windows :c:func:`!TerminateProcess` is used.  Note that "
"exit handlers and finally clauses, etc., will not be executed."
msgstr ""

#: ../../library/multiprocessing.rst:659
msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr ""
"このメソッドにより終了するプロセスの子孫プロセスは、終了 *しません* 。そう"
"いった子孫プロセスは単純に孤児になります。"

#: ../../library/multiprocessing.rst:664
msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable "
"by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr ""
"このメソッドの使用時に、関連付けられたプロセスがパイプやキューを使用している"
"場合には、使用中のパイプやキューが破損して他のプロセスから使用できなくなる可"
"能性があります。同様に、プロセスがロックやセマフォなどを取得している場合に"
"は、このプロセスが終了してしまうと他のプロセスのデッドロックの原因になるで"
"しょう。"

#: ../../library/multiprocessing.rst:672
msgid "Same as :meth:`terminate` but using the ``SIGKILL`` signal on POSIX."
msgstr ""

#: ../../library/multiprocessing.rst:678
msgid ""
"Close the :class:`Process` object, releasing all resources associated with "
"it.  :exc:`ValueError` is raised if the underlying process is still "
"running.  Once :meth:`close` returns successfully, most other methods and "
"attributes of the :class:`Process` object will raise :exc:`ValueError`."
msgstr ""
":class:`Process` オブジェクトを閉じ、関連付けられていたすべてのリソースを開放"
"します。中のプロセスが実行中であった場合、:exc:`ValueError` を送出します。:"
"meth:`close` が成功した場合、:class:`Process` オブジェクトの他のメソッドや属"
"性は、ほとんどが :exc:`ValueError` を送出します。"

#: ../../library/multiprocessing.rst:686
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr ""
"プロセスオブジェクトが作成したプロセスのみが :meth:`start`, :meth:`join`, :"
"meth:`is_alive`, :meth:`terminate` と :attr:`exitcode` のメソッドを呼び出すべ"
"きです。"

#: ../../library/multiprocessing.rst:690
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr "以下の例では :class:`Process` のメソッドの使い方を示しています:"

#: ../../library/multiprocessing.rst:692
msgid ""
">>> import multiprocessing, time, signal\n"
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> p = mp_context.Process(target=time.sleep, args=(1000,))\n"
">>> print(p, p.is_alive())\n"
"<...Process ... initial> False\n"
">>> p.start()\n"
">>> print(p, p.is_alive())\n"
"<...Process ... started> True\n"
">>> p.terminate()\n"
">>> time.sleep(0.1)\n"
">>> print(p, p.is_alive())\n"
"<...Process ... stopped exitcode=-SIGTERM> False\n"
">>> p.exitcode == -signal.SIGTERM\n"
"True"
msgstr ""

#: ../../library/multiprocessing.rst:711
msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "すべての :mod:`multiprocessing` 例外の基底クラスです。"

#: ../../library/multiprocessing.rst:715
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into` when the supplied "
"buffer object is too small for the message read."
msgstr ""

#: ../../library/multiprocessing.rst:718
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr ""
"``e`` が :exc:`BufferTooShort` のインスタンスであるとすると、 ``e.args[0]`` "
"はそのメッセージをバイト文字列で与えるものです。"

#: ../../library/multiprocessing.rst:723
msgid "Raised when there is an authentication error."
msgstr "認証エラーがあった場合に送出されます。"

#: ../../library/multiprocessing.rst:727
msgid "Raised by methods with a timeout when the timeout expires."
msgstr ""
"タイムアウトをサポートするメソッドでタイムアウトが過ぎたときに送出されます。"

#: ../../library/multiprocessing.rst:730
msgid "Pipes and Queues"
msgstr "パイプ (Pipe) とキュー (Queue)"

#: ../../library/multiprocessing.rst:732
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization "
"primitives like locks."
msgstr ""
"複数のプロセスを使う場合、一般的にはメッセージパッシングをプロセス間通信に使"
"用し、ロックのような同期プリミティブを使用しないようにします。"

#: ../../library/multiprocessing.rst:736
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr ""
"メッセージのやりとりのために :func:`Pipe` (2つのプロセス間の通信用)、もしくは"
"キュー (複数のメッセージ生成プロセス (producer)、消費プロセス (consumer) の実"
"現用) を使うことができます。"

#: ../../library/multiprocessing.rst:739
msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types "
"are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` queues "
"modelled on the :class:`queue.Queue` class in the standard library.  They "
"differ in that :class:`Queue` lacks the :meth:`~queue.Queue.task_done` and :"
"meth:`~queue.Queue.join` methods introduced into Python 2.5's :class:`queue."
"Queue` class."
msgstr ""
":class:`Queue`, :class:`SimpleQueue` と :class:`JoinableQueue` 型は複数プロセ"
"スから生成/消費を行う :abbr:`FIFO (first-in, first-out, 先入れ先出し)` キュー"
"です。これらのキューは標準ライブラリの :class:`queue.Queue` を模倣していま"
"す。 :class:`Queue` には Python 2.5 の :class:`queue.Queue` クラスで導入され"
"た :meth:`~queue.Queue.task_done` と :meth:`~queue.Queue.join` メソッドがない"
"ことが違う点です。"

#: ../../library/multiprocessing.rst:746
msgid ""
"If you use :class:`JoinableQueue` then you **must** call :meth:"
"`JoinableQueue.task_done` for each task removed from the queue or else the "
"semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr ""
"もし :class:`JoinableQueue` を使用するなら、キューから削除される各タスクのた"
"めに :meth:`JoinableQueue.task_done` を呼び出さなければ **なりません** 。さも"
"ないと、いつか完了していないタスクを数えるためのセマフォがオーバーフローし、"
"例外を発生させるでしょう。"

#: ../../library/multiprocessing.rst:751
msgid ""
"One difference from other Python queue implementations, is that :mod:"
"`multiprocessing` queues serializes all objects that are put into them "
"using :mod:`pickle`. The object return by the get method is a re-created "
"object that does not share memory with the original object."
msgstr ""

#: ../../library/multiprocessing.rst:756
msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr ""
"管理オブジェクトを使用することで共有キューを作成できることも覚えておいてくだ"
"さい。詳細は :ref:`multiprocessing-managers` を参照してください。"

#: ../../library/multiprocessing.rst:761
msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and :exc:`queue."
"Full` exceptions to signal a timeout.  They are not available in the :mod:"
"`multiprocessing` namespace so you need to import them from :mod:`queue`."
msgstr ""
":mod:`multiprocessing` は、タイムアウトを伝えるために、通常の :exc:`queue."
"Empty` と :exc:`queue.Full` 例外を使用します。それらは :mod:"
"`multiprocessing` の名前空間では利用できないため、:mod:`queue` からインポート"
"する必要があります。"

#: ../../library/multiprocessing.rst:768
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use "
"a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"オブジェクトがキューに追加される際、そのオブジェクトは pickle 化されていま"
"す。そのため、バックグラウンドのスレッドが後になって下位層のパイプに pickle "
"化されたデータをフラッシュすることがあります。これにより、少し驚くような結果"
"になりますが、実際に問題になることはないはずです。これが問題になるような状況"
"では、かわりに :ref:`manager <multiprocessing-managers>` を使ってキューを作成"
"することができるからです。"

#: ../../library/multiprocessing.rst:775
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`queue.Empty`."
msgstr ""
"空のキューの中にオブジェクトを追加した後、キューの :meth:`~Queue.empty` メ"
"ソッドが :const:`False` を返すまでの間にごくわずかな遅延が起きることがあり、:"
"meth:`~Queue.get_nowait` が :exc:`queue.Empty` を発生させることなく制御が呼び"
"出し元に返ってしまうことがあります。"

#: ../../library/multiprocessing.rst:780
msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr ""
"複数のプロセスがオブジェクトをキューに詰めている場合、キューの反対側ではオブ"
"ジェクトが詰められたのとは違う順序で取得される可能性があります。ただし、同一"
"のプロセスから詰め込まれたオブジェクトは、それらのオブジェクト間では、必ず期"
"待どおりの順序になります。"

#: ../../library/multiprocessing.rst:787
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`Queue`, then the data in the queue is "
"likely to become corrupted.  This may cause any other process to get an "
"exception when it tries to use the queue later on."
msgstr ""
":class:`Queue` を利用しようとしている最中にプロセスを :meth:`Process."
"terminate` や :func:`os.kill` で終了させる場合、キューにあるデータは破損し易"
"くなります。終了した後で他のプロセスがキューを利用しようとすると、例外を発生"
"させる可能性があります。"

#: ../../library/multiprocessing.rst:794
msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>`), then that process will not terminate until all "
"buffered items have been flushed to the pipe."
msgstr ""
"上述したように、もし子プロセスがキューへ要素を追加するなら (かつ :meth:"
"`JoinableQueue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>` を使用しないなら) そのプロセスはバッファーされたすべての"
"要素がパイプへフラッシュされるまで終了しません。"

#: ../../library/multiprocessing.rst:799
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr ""
"これは、そのプロセスを join しようとする場合、キューに追加されたすべての要素"
"が消費されたことが確実でないかぎり、デッドロックを発生させる可能性があること"
"を意味します。似たような現象で、子プロセスが非デーモンプロセスの場合、親プロ"
"セスは終了時に非デーモンのすべての子プロセスを join しようとしてハングアップ"
"する可能性があります。"

#: ../../library/multiprocessing.rst:804
msgid ""
"Note that a queue created using a manager does not have this issue.  See :"
"ref:`multiprocessing-programming`."
msgstr ""
"マネージャーを使用して作成されたキューではこの問題はありません。詳細は :ref:"
"`multiprocessing-programming` を参照してください。"

#: ../../library/multiprocessing.rst:807
msgid ""
"For an example of the usage of queues for interprocess communication see :"
"ref:`multiprocessing-examples`."
msgstr ""
"プロセス間通信におけるキューの使用例を知りたいなら :ref:`multiprocessing-"
"examples` を参照してください。"

#: ../../library/multiprocessing.rst:813
msgid ""
"Returns a pair ``(conn1, conn2)`` of :class:`~multiprocessing.connection."
"Connection` objects representing the ends of a pipe."
msgstr ""
"パイプの両端を表す :class:`~multiprocessing.connection.Connection` オブジェク"
"トのペア ``(conn1, conn2)`` を返します。"

#: ../../library/multiprocessing.rst:817
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be "
"used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr ""
"*duplex* が ``True`` (デフォルト) ならパイプは双方向性です。*duplex* が "
"``False`` ならパイプは一方向性で、``conn1`` はメッセージの受信専用、"
"``conn2`` はメッセージの送信専用になります。"

#: ../../library/multiprocessing.rst:822
msgid ""
"The :meth:`~multiprocessing.Connection.send` method serializes the the "
"object using :mod:`pickle` and the :meth:`~multiprocessing.Connection.recv` "
"re-creates the object."
msgstr ""

#: ../../library/multiprocessing.rst:827
msgid ""
"Returns a process shared queue implemented using a pipe and a few locks/"
"semaphores.  When a process first puts an item on the queue a feeder thread "
"is started which transfers objects from a buffer into the pipe."
msgstr ""
"パイプや2～3個のロック/セマフォを使用して実装されたプロセス共有キューを返しま"
"す。あるプロセスが最初に要素をキューへ追加するとき、バッファーからパイプの中"
"へオブジェクトを転送する供給スレッドが開始されます。"

#: ../../library/multiprocessing.rst:831
msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr ""
"標準ライブラリの :mod:`queue` モジュールの通常の :exc:`queue.Empty` や :exc:"
"`queue.Full` 例外がタイムアウトを伝えるために送出されます。"

#: ../../library/multiprocessing.rst:834
msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except "
"for :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
":class:`Queue` は :meth:`~queue.Queue.task_done` や :meth:`~queue.Queue."
"join` を除く :class:`queue.Queue` のすべてのメソッドを実装します。"

#: ../../library/multiprocessing.rst:839
msgid ""
"Return the approximate size of the queue.  Because of multithreading/"
"multiprocessing semantics, this number is not reliable."
msgstr ""
"おおよそのキューのサイズを返します。マルチスレッディング/マルチプロセスの特性"
"上、この数値は信用できません。"

#: ../../library/multiprocessing.rst:842
msgid ""
"Note that this may raise :exc:`NotImplementedError` on platforms like macOS "
"where ``sem_getvalue()`` is not implemented."
msgstr ""

#: ../../library/multiprocessing.rst:847
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"キューが空っぽなら ``True`` を、そうでなければ ``False`` を返します。マルチス"
"レッディング/マルチプロセシングの特性上、これは信用できません。"

#: ../../library/multiprocessing.rst:850
msgid "May raise an :exc:`OSError` on closed queues. (not guaranteed)"
msgstr ""

#: ../../library/multiprocessing.rst:854
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"キューがいっぱいなら ``True`` を、そうでなければ ``False`` を返します。マルチ"
"スレッディング/マルチプロセシングの特性上、これは信用できません。"

#: ../../library/multiprocessing.rst:859
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a "
"free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`queue.Full` exception if no free "
"slot was available within that time.  Otherwise (*block* is ``False``), put "
"an item on the queue if a free slot is immediately available, else raise "
"the :exc:`queue.Full` exception (*timeout* is ignored in that case)."
msgstr ""
"キューの中へ obj を追加します。オプションの引数 *block* が ``True`` (デフォル"
"ト) 且つ *timeout* が ``None`` (デフォルト) なら、空きスロットが利用可能にな"
"るまで必要であればブロックします。 *timeout* が正の数なら、最大 *timeout* 秒"
"ブロックして、その時間内に空きスロットが利用できなかったら :exc:`queue.Full` "
"例外を発生させます。それ以外 (*block* が ``False``) で、空きスロットがすぐに"
"利用可能な場合はキューに要素を追加します。そうでなければ :exc:`queue.Full` 例"
"外が発生します(その場合 *timeout* は無視されます)。"

#: ../../library/multiprocessing.rst:868
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""

#: ../../library/multiprocessing.rst:874
msgid "Equivalent to ``put(obj, False)``."
msgstr "``put(obj, False)`` と等価です。"

#: ../../library/multiprocessing.rst:878
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it "
"blocks at most *timeout* seconds and raises the :exc:`queue.Empty` exception "
"if no item was available within that time.  Otherwise (block is ``False``), "
"return an item if one is immediately available, else raise the :exc:`queue."
"Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"キューから要素を取り出して削除します。オプションの引数 *block* が ``True`` "
"(デフォルト) 且つ *timeout* が ``None`` (デフォルト) なら、要素が取り出せるま"
"で必要であればブロックします。 *timeout* が正の数なら、最大 *timeout* 秒ブ"
"ロックして、その時間内に要素が取り出せなかったら :exc:`queue.Empty` 例外を発"
"生させます。それ以外 (*block* が ``False``) で、要素がすぐに取り出せる場合は"
"要素を返します。そうでなければ :exc:`queue.Empty` 例外が発生します(その場合 "
"*timeout* は無視されます)。"

#: ../../library/multiprocessing.rst:886
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`OSError`."
msgstr ""

#: ../../library/multiprocessing.rst:892
msgid "Equivalent to ``get(False)``."
msgstr "``get(False)`` と等価です。"

#: ../../library/multiprocessing.rst:894
msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in :"
"class:`queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ""
":class:`multiprocessing.Queue` は :class:`queue.Queue` にはない追加メソッドが"
"あります。 これらのメソッドは通常、ほとんどのコードに必要ありません:"

#: ../../library/multiprocessing.rst:900
msgid ""
"Indicate that no more data will be put on this queue by the current "
"process.  The background thread will quit once it has flushed all buffered "
"data to the pipe.  This is called automatically when the queue is garbage "
"collected."
msgstr ""
"カレントプロセスからこのキューへそれ以上データが追加されないことを表します。"
"バックグラウンドスレッドはパイプへバッファーされたすべてのデータをフラッシュ"
"するとすぐに終了します。これはキューがガベージコレクトされるときに自動的に呼"
"び出されます。"

#: ../../library/multiprocessing.rst:907
msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all "
"data in the buffer has been flushed to the pipe."
msgstr ""
"バックグラウンドスレッドを join します。このメソッドは :meth:`close` が呼び出"
"された後でのみ使用されます。バッファーされたすべてのデータがパイプへフラッ"
"シュされるのを保証するため、バックグラウンドスレッドが終了するまでブロックし"
"ます。"

#: ../../library/multiprocessing.rst:911
msgid ""
"By default if a process is not the creator of the queue then on exit it will "
"attempt to join the queue's background thread.  The process can call :meth:"
"`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"デフォルトでは、あるプロセスがキューを作成していない場合、終了時にキューの"
"バックグラウンドスレッドを join しようとします。そのプロセスは :meth:"
"`join_thread` が何もしないように :meth:`cancel_join_thread` を呼び出すことが"
"できます。"

#: ../../library/multiprocessing.rst:917
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the "
"background thread from being joined automatically when the process exits -- "
"see :meth:`join_thread`."
msgstr ""
":meth:`join_thread` がブロッキングするのを防ぎます。特にこれはバックグラウン"
"ドスレッドがそのプロセスの終了時に自動的に join されるのを防ぎます。詳細は :"
"meth:`join_thread` を参照してください。"

#: ../../library/multiprocessing.rst:921
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to be lost, and you almost certainly will "
"not need to use it. It is really only there if you need the current process "
"to exit immediately without waiting to flush enqueued data to the underlying "
"pipe, and you don't care about lost data."
msgstr ""
"このメソッドは ``allow_exit_without_flush()`` という名前のほうがよかったかも"
"しれません。キューに追加されたデータが失われてしまいがちなため、このメソッド"
"を使う必要はほぼ確実にないでしょう。本当にこれが必要になるのは、キューに追加"
"されたデータを下位層のパイプにフラッシュすることなくカレントプロセスを直ちに"
"終了する必要があり、かつ失われるデータに関心がない場合です。"

#: ../../library/multiprocessing.rst:930
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue` "
"will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr ""
"このクラスに含まれる機能には、ホストとなるオペレーティングシステム上で動作し"
"ている共有セマフォ (shared semaphore) を使用しているものがあります。これが使"
"用できない場合には、このクラスが無効になり、 :class:`Queue` をインスタンス化"
"する時に :exc:`ImportError` が発生します。詳細は :issue:`3770` を参照してくだ"
"さい。同様のことが、以下に列挙されている特殊なキューでも成り立ちます。"

#: ../../library/multiprocessing.rst:939
msgid ""
"It is a simplified :class:`Queue` type, very close to a locked :class:`Pipe`."
msgstr ""
"単純化された :class:`Queue` 型です。ロックされた :class:`Pipe` と非常に似てい"
"ます。"

#: ../../library/multiprocessing.rst:943
msgid "Close the queue: release internal resources."
msgstr ""

#: ../../library/multiprocessing.rst:945
msgid ""
"A queue must not be used anymore after it is closed. For example, :meth:"
"`get`, :meth:`put` and :meth:`empty` methods must no longer be called."
msgstr ""

#: ../../library/multiprocessing.rst:953
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "キューが空ならば ``True`` を、そうでなければ ``False`` を返します。"

#: ../../library/multiprocessing.rst:955
msgid "Always raises an :exc:`OSError` if the SimpleQueue is closed."
msgstr ""

#: ../../library/multiprocessing.rst:959
msgid "Remove and return an item from the queue."
msgstr "キューから要素を削除して返します。"

#: ../../library/multiprocessing.rst:963
msgid "Put *item* into the queue."
msgstr "*item* をキューに追加します。"

#: ../../library/multiprocessing.rst:968
msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`JoinableQueue` は :class:`Queue` のサブクラスであり、 :meth:"
"`task_done` や :meth:`join` メソッドが追加されているキューです。"

#: ../../library/multiprocessing.rst:973
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue "
"consumers.  For each :meth:`~Queue.get` used to fetch a task, a subsequent "
"call to :meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""
"以前にキューへ追加されたタスクが完了したことを表します。キューのコンシューマ"
"によって使用されます。 タスクをフェッチするために使用されるそれぞれの :meth:"
"`~Queue.get` に対して、 後続の :meth:`task_done` 呼び出しはタスクの処理が完了"
"したことをキューへ伝えます。"

#: ../../library/multiprocessing.rst:978
msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"もし :meth:`~queue.Queue.join` がブロッキング状態なら、 すべての要素が処理さ"
"れたときに復帰します( :meth:`task_done` 呼び出しが すべての要素からキュー内"
"へ :meth:`~Queue.put` されたと受け取ったことを意味します)。"

#: ../../library/multiprocessing.rst:982
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"キューにある要素より多く呼び出された場合 :exc:`ValueError` が発生します。"

#: ../../library/multiprocessing.rst:988
msgid "Block until all items in the queue have been gotten and processed."
msgstr ""
"キューにあるすべてのアイテムが取り出されて処理されるまでブロックします。"

#: ../../library/multiprocessing.rst:990
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` to "
"indicate that the item was retrieved and all work on it is complete.  When "
"the count of unfinished tasks drops to zero, :meth:`~queue.Queue.join` "
"unblocks."
msgstr ""
"キューに要素が追加されると未完了タスク数が増えます。コンシューマがキューの要"
"素が取り出されてすべての処理が完了したことを表す :meth:`task_done` を呼び出す"
"と数が減ります。 未完了タスク数がゼロになると :meth:`~queue.Queue.join` はブ"
"ロッキングを解除します。"

#: ../../library/multiprocessing.rst:998
msgid "Miscellaneous"
msgstr "その他"

#: ../../library/multiprocessing.rst:1002
msgid "Return list of all live children of the current process."
msgstr "カレントプロセスのすべてのアクティブな子プロセスのリストを返します。"

#: ../../library/multiprocessing.rst:1004
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr ""
"これを呼び出すと \"join\" してすでに終了しているプロセスには副作用がありま"
"す。"

#: ../../library/multiprocessing.rst:1009
msgid "Return the number of CPUs in the system."
msgstr "システムの CPU 数を返します。"

#: ../../library/multiprocessing.rst:1011
msgid ""
"This number is not equivalent to the number of CPUs the current process can "
"use.  The number of usable CPUs can be obtained with :func:`os."
"process_cpu_count` (or ``len(os.sched_getaffinity(0))``)."
msgstr ""

#: ../../library/multiprocessing.rst:1015
msgid ""
"When the number of CPUs cannot be determined a :exc:`NotImplementedError` is "
"raised."
msgstr ""

#: ../../library/multiprocessing.rst:1019
msgid ":func:`os.cpu_count` :func:`os.process_cpu_count`"
msgstr ""

#: ../../library/multiprocessing.rst:1024
msgid ""
"The return value can also be overridden using the :option:`-X cpu_count <-"
"X>` flag or :envvar:`PYTHON_CPU_COUNT` as this is merely a wrapper around "
"the :mod:`os` cpu count APIs."
msgstr ""

#: ../../library/multiprocessing.rst:1030
msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr "カレントプロセスに対応する :class:`Process` オブジェクトを返します。"

#: ../../library/multiprocessing.rst:1032
msgid "An analogue of :func:`threading.current_thread`."
msgstr ":func:`threading.current_thread` とよく似た関数です。"

#: ../../library/multiprocessing.rst:1036
msgid ""
"Return the :class:`Process` object corresponding to the parent process of "
"the :func:`current_process`. For the main process, ``parent_process`` will "
"be ``None``."
msgstr ""

#: ../../library/multiprocessing.rst:1044
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce a Windows executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ""
":mod:`multiprocessing` を使用しているプログラムをフリーズして Windows の実行"
"可能形式を生成するためのサポートを追加します。(**py2exe** , **PyInstaller** "
"や **cx_Freeze** でテストされています。)"

#: ../../library/multiprocessing.rst:1048
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr ""
"メインモジュールの ``if __name__ == '__main__'`` の直後にこの関数を呼び出す必"
"要があります。以下に例を示します::"

#: ../../library/multiprocessing.rst:1051
msgid ""
"from multiprocessing import Process, freeze_support\n"
"\n"
"def f():\n"
"    print('hello world!')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    Process(target=f).start()"
msgstr ""

#: ../../library/multiprocessing.rst:1060
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr ""
"もし ``freeze_support()`` の行がない場合、フリーズされた実行可能形式を実行し"
"ようとすると :exc:`RuntimeError` を発生させます。"

#: ../../library/multiprocessing.rst:1063
msgid ""
"Calling ``freeze_support()`` has no effect when invoked on any operating "
"system other than Windows.  In addition, if the module is being run normally "
"by the Python interpreter on Windows (the program has not been frozen), then "
"``freeze_support()`` has no effect."
msgstr ""
"``freeze_support()`` の呼び出しは Windows 以外の OS では効果がありません。さ"
"らに、もしモジュールが Windows の通常の Python インタプリタによって実行されて"
"いるならば（プログラムがフリーズされていなければ） ``freeze_support()`` は効"
"果がありません。"

#: ../../library/multiprocessing.rst:1070
msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  Not all platforms support all methods.  See :ref:"
"`multiprocessing-start-methods`."
msgstr ""

#: ../../library/multiprocessing.rst:1079
msgid ""
"Return a context object which has the same attributes as the :mod:"
"`multiprocessing` module."
msgstr ""
":mod:`multiprocessing` モジュールと同じ属性を持つコンテキストオブジェクトを返"
"します。"

#: ../../library/multiprocessing.rst:1082
msgid ""
"If *method* is ``None`` then the default context is returned. Otherwise "
"*method* should be ``'fork'``, ``'spawn'``, ``'forkserver'``.  :exc:"
"`ValueError` is raised if the specified start method is not available.  See :"
"ref:`multiprocessing-start-methods`."
msgstr ""

#: ../../library/multiprocessing.rst:1091
msgid "Return the name of start method used for starting processes."
msgstr "開始するプロセスで使用する開始方式名を返します。"

#: ../../library/multiprocessing.rst:1093
msgid ""
"If the start method has not been fixed and *allow_none* is false, then the "
"start method is fixed to the default and the name is returned.  If the start "
"method has not been fixed and *allow_none* is true then ``None`` is returned."
msgstr ""
"開始方式がまだ確定しておらず、*allow_none* の値が偽の場合、開始方式はデフォル"
"トに確定され、その名前が返されます。開始方式が確定しておらず、*allow_none* の"
"値が真の場合、 ``None`` が返されます。"

#: ../../library/multiprocessing.rst:1098
msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  See :ref:`multiprocessing-start-methods`."
msgstr ""

#: ../../library/multiprocessing.rst:1105
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess. See :issue:`33725`."
msgstr ""
"macOS では、 *spawn* 開始方式がデフォルトになりました。 *fork* 開始方法は、サ"
"ブプロセスのクラッシュを引き起こす可能性があるため、安全ではありません。 :"
"issue:`33725` を参照。"

#: ../../library/multiprocessing.rst:1111
msgid ""
"Set the path of the Python interpreter to use when starting a child process. "
"(By default :data:`sys.executable` is used).  Embedders will probably need "
"to do some thing like ::"
msgstr ""
"子プロセスを開始するときに、使用する Python インタープリターのパスを設定しま"
"す。(デフォルトでは :data:`sys.executable` が使用されます)。コードに組み込む"
"ときは、おそらく次のようにする必要があります ::"

#: ../../library/multiprocessing.rst:1115
msgid "set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))"
msgstr ""

#: ../../library/multiprocessing.rst:1117
msgid "before they can create child processes."
msgstr "子プロセスを作成する前に行ってください。"

#: ../../library/multiprocessing.rst:1119
msgid "Now supported on POSIX when the ``'spawn'`` start method is used."
msgstr ""

#: ../../library/multiprocessing.rst:1122
msgid "Accepts a :term:`path-like object`."
msgstr ":term:`path-like object` を受け入れるようになりました。"

#: ../../library/multiprocessing.rst:1127
msgid ""
"Set a list of module names for the forkserver main process to attempt to "
"import so that their already imported state is inherited by forked "
"processes. Any :exc:`ImportError` when doing so is silently ignored. This "
"can be used as a performance enhancement to avoid repeated work in every "
"process."
msgstr ""

#: ../../library/multiprocessing.rst:1133
msgid ""
"For this to work, it must be called before the forkserver process has been "
"launched (before creating a :class:`Pool` or starting a :class:`Process`)."
msgstr ""

#: ../../library/multiprocessing.rst:1136
msgid ""
"Only meaningful when using the ``'forkserver'`` start method. See :ref:"
"`multiprocessing-start-methods`."
msgstr ""

#: ../../library/multiprocessing.rst:1143
msgid ""
"Set the method which should be used to start child processes. The *method* "
"argument can be ``'fork'``, ``'spawn'`` or ``'forkserver'``. Raises :exc:"
"`RuntimeError` if the start method has already been set and *force* is not "
"``True``.  If *method* is ``None`` and *force* is ``True`` then the start "
"method is set to ``None``.  If *method* is ``None`` and *force* is ``False`` "
"then the context is set to the default context."
msgstr ""

#: ../../library/multiprocessing.rst:1150
msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr ""
"これは一度しか呼び出すことができず、その場所もメインモジュールの ``if "
"__name__ == '__main__'`` 節内で保護された状態でなければなりません。"

#: ../../library/multiprocessing.rst:1154
msgid "See :ref:`multiprocessing-start-methods`."
msgstr ""

#: ../../library/multiprocessing.rst:1160
msgid ""
":mod:`multiprocessing` contains no analogues of :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, or :class:`threading."
"local`."
msgstr ""
":mod:`multiprocessing` には :func:`threading.active_count`, :func:`threading."
"enumerate`, :func:`threading.settrace`, :func:`threading.setprofile`, :class:"
"`threading.Timer` や :class:`threading.local` のような関数はありません。"

#: ../../library/multiprocessing.rst:1167
msgid "Connection Objects"
msgstr "Connection オブジェクト"

#: ../../library/multiprocessing.rst:1171
msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr ""
"Connection オブジェクトは pickle でシリアライズ可能なオブジェクトか文字列を"
"送ったり、受け取ったりします。そういったオブジェクトはメッセージ指向の接続ソ"
"ケットと考えられます。"

#: ../../library/multiprocessing.rst:1174
msgid ""
"Connection objects are usually created using :func:`Pipe <multiprocessing."
"Pipe>` -- see also :ref:`multiprocessing-listeners-clients`."
msgstr ""
"Connection オブジェクトは通常は :func:`Pipe <multiprocessing.Pipe>` を使用し"
"て作成されます。 詳細は :ref:`multiprocessing-listeners-clients` も参照してく"
"ださい。"

#: ../../library/multiprocessing.rst:1182
msgid ""
"Send an object to the other end of the connection which should be read "
"using :meth:`recv`."
msgstr ""
"コネクションの相手側へ :meth:`recv` を使用して読み込むオブジェクトを送りま"
"す。"

#: ../../library/multiprocessing.rst:1185
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MiB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr ""
"オブジェクトは pickle でシリアライズ可能でなければなりません。 pickle が極端"
"に大きすぎる (OS にも依りますが、およそ 32 MiB+) と、 :exc:`ValueError` 例外"
"が送出されることがあります。"

#: ../../library/multiprocessing.rst:1190
msgid ""
"Return an object sent from the other end of the connection using :meth:"
"`send`.  Blocks until there is something to receive.  Raises :exc:`EOFError` "
"if there is nothing left to receive and the other end was closed."
msgstr ""
"コネクションの相手側から :meth:`send` を使用して送られたオブジェクトを返しま"
"す。 何か受け取るまでブロックします。何も受け取らずにコネクションの相手側でク"
"ローズされた場合 :exc:`EOFError` が発生します。"

#: ../../library/multiprocessing.rst:1197
msgid "Return the file descriptor or handle used by the connection."
msgstr "コネクションが使用するハンドラーか、ファイル記述子を返します。"

#: ../../library/multiprocessing.rst:1201
msgid "Close the connection."
msgstr "コネクションをクローズします。"

#: ../../library/multiprocessing.rst:1203
msgid "This is called automatically when the connection is garbage collected."
msgstr "コネクションがガベージコレクトされるときに自動的に呼び出されます。"

#: ../../library/multiprocessing.rst:1207
msgid "Return whether there is any data available to be read."
msgstr "読み込み可能なデータがあるかどうかを返します。"

#: ../../library/multiprocessing.rst:1209
msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout* "
"is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"*timeout* が指定されていなければすぐに返します。 *timeout* に数値を指定する"
"と、最大指定した秒数をブロッキングします。 *timeout* に ``None`` を指定すると"
"タイムアウトせずにずっとブロッキングします。"

#: ../../library/multiprocessing.rst:1213
msgid ""
"Note that multiple connection objects may be polled at once by using :func:"
"`multiprocessing.connection.wait`."
msgstr ""
":func:`multiprocessing.connection.wait` を使って複数のコネクションオブジェク"
"トを同時にポーリングできることに注意してください。"

#: ../../library/multiprocessing.rst:1218
msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr ""
":term:`bytes-like object` から完全なメッセージとしてバイトデータを送ります。"

#: ../../library/multiprocessing.rst:1220
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MiB+, though it depends on the OS) may raise a :"
"exc:`ValueError` exception"
msgstr ""
"*offset* が指定されると *buffer* のその位置からデータが読み込まれます。 "
"*size* が指定されるとバッファーからその量のデータが読み込まれます。非常に大き"
"なバッファー (OS に依存しますが、およそ 32MiB+) を指定すると、 :exc:"
"`ValueError` 例外が発生するかもしれません。"

#: ../../library/multiprocessing.rst:1227
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises :"
"exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr ""
"コネクションの相手側から送られたバイトデータの完全なメッセージを文字列として"
"返します。何か受け取るまでブロックします。受け取るデータが何も残っておらず、"
"相手側がコネクションを閉じていた場合、 :exc:`EOFError` が送出されます。"

#: ../../library/multiprocessing.rst:1232
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then :"
"exc:`OSError` is raised and the connection will no longer be readable."
msgstr ""
"*maxlength* を指定していて、かつメッセージが *maxlength* より長い場合、 :exc:"
"`OSError` が発生してコネクションからそれ以上読めなくなります。"

#: ../../library/multiprocessing.rst:1236
msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of :exc:"
"`OSError`."
msgstr ""
"この関数は以前は :exc:`IOError` を送出していました。今では :exc:`OSError` の"
"別名です。"

#: ../../library/multiprocessing.rst:1243
msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr ""
"コネクションの相手側から送られたバイトデータを *buffer* に読み込み、メッセー"
"ジのバイト数を返します。 何か受け取るまでブロックします。何も受け取らずにコネ"
"クションの相手側でクローズされた場合 :exc:`EOFError` が発生します。"

#: ../../library/multiprocessing.rst:1249
msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is given "
"then the message will be written into the buffer from that position.  Offset "
"must be a non-negative integer less than the length of *buffer* (in bytes)."
msgstr ""
"*buffer* は書き込み可能な :term:`bytes-like object` でなければなりません。 "
"*offset* が与えられたら、その位置からバッファーへメッセージが書き込まれま"
"す。 オフセットは *buffer* バイトよりも小さい正の数でなければなりません。"

#: ../../library/multiprocessing.rst:1254
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr ""
"バッファーがあまりに小さいと :exc:`BufferTooShort` 例外が発生します。 ``e`` "
"が例外インスタンスとすると完全なメッセージは ``e.args[0]`` で確認できます。"

#: ../../library/multiprocessing.rst:1258
msgid ""
"Connection objects themselves can now be transferred between processes "
"using :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr ""
":meth:`Connection.send` と :meth:`Connection.recv` を使用して Connection オブ"
"ジェクト自体をプロセス間で転送できるようになりました。"

#: ../../library/multiprocessing.rst:1262
msgid ""
"Connection objects also now support the context management protocol -- see :"
"ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"connection object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""

#: ../../library/multiprocessing.rst:1266
msgid "For example:"
msgstr "例えば:"

#: ../../library/multiprocessing.rst:1268
msgid ""
">>> from multiprocessing import Pipe\n"
">>> a, b = Pipe()\n"
">>> a.send([1, 'hello', None])\n"
">>> b.recv()\n"
"[1, 'hello', None]\n"
">>> b.send_bytes(b'thank you')\n"
">>> a.recv_bytes()\n"
"b'thank you'\n"
">>> import array\n"
">>> arr1 = array.array('i', range(5))\n"
">>> arr2 = array.array('i', [0] * 10)\n"
">>> a.send_bytes(arr1)\n"
">>> count = b.recv_bytes_into(arr2)\n"
">>> assert count == len(arr1) * arr1.itemsize\n"
">>> arr2\n"
"array('i', [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])"
msgstr ""

#: ../../library/multiprocessing.rst:1291
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ""
":meth:`Connection.recv` メソッドは受信したデータを自動的に unpickle 化しま"
"す。それはメッセージを送ったプロセスが信頼できる場合を除いてセキュリティリス"
"クになります。"

#: ../../library/multiprocessing.rst:1295
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"そのため :func:`Pipe` を使用してコネクションオブジェクトを生成する場合を除い"
"て、何らかの認証処理を実行した後で :meth:`~Connection.recv` や :meth:"
"`~Connection.send` メソッドのみを使用すべきです。詳細は :ref:"
"`multiprocessing-auth-keys` を参照してください。"

#: ../../library/multiprocessing.rst:1302
msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr ""
"もしプロセスがパイプの読み込みまたは書き込み中に kill されると、メッセージの"
"境界がどこなのか分からなくなってしまうので、そのパイプ内のデータは破損してし"
"まいがちです。"

#: ../../library/multiprocessing.rst:1308
msgid "Synchronization primitives"
msgstr "同期プリミティブ"

#: ../../library/multiprocessing.rst:1312
msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for :"
"mod:`threading` module."
msgstr ""
"一般的にマルチプロセスプログラムは、マルチスレッドプログラムほどは同期プリミ"
"ティブを必要としません。詳細は :mod:`threading` モジュールのドキュメントを参"
"照してください。"

#: ../../library/multiprocessing.rst:1316
msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr ""
"マネージャーオブジェクトを使用して同期プリミティブを作成できることも覚えてお"
"いてください。詳細は :ref:`multiprocessing-managers` を参照してください。"

#: ../../library/multiprocessing.rst:1321
msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "バリアーオブジェクト: :class:`threading.Barrier` のクローンです。"

#: ../../library/multiprocessing.rst:1327
msgid ""
"A bounded semaphore object: a close analog of :class:`threading."
"BoundedSemaphore`."
msgstr ""
"有限セマフォオブジェクト: :class:`threading.BoundedSemaphore` の類似物です。"

#: ../../library/multiprocessing.rst:1330
#: ../../library/multiprocessing.rst:1468
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's "
"first argument is named *block*, as is consistent with :meth:`Lock.acquire`."
msgstr ""
"よく似た :class:`threading.BoundedSemaphore`  とは、次の一点だけ異なります。 "
"``acquire`` メソッドの第一引数名は *block* で、:meth:`Lock.acquire` と一致し"
"ています。"

#: ../../library/multiprocessing.rst:1334
msgid ""
"On macOS, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr ""
"macOS では ``sem_getvalue()`` が実装されていないので :class:`Semaphore` と区"
"別がつきません。"

#: ../../library/multiprocessing.rst:1339
msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr "状態変数: :class:`threading.Condition` の別名です。"

#: ../../library/multiprocessing.rst:1341
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr ""
"*lock* を指定するなら :mod:`multiprocessing` の :class:`Lock` か :class:"
"`RLock` オブジェクトにすべきです。"

#: ../../library/multiprocessing.rst:1344
#: ../../library/multiprocessing.rst:1882
msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr ":meth:`~threading.Condition.wait_for` メソッドが追加されました。"

#: ../../library/multiprocessing.rst:1349
msgid "A clone of :class:`threading.Event`."
msgstr ":class:`threading.Event` のクローンです。"

#: ../../library/multiprocessing.rst:1354
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once "
"a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of :class:`threading."
"Lock` as it applies to threads are replicated here in :class:"
"`multiprocessing.Lock` as it applies to either processes or threads, except "
"as noted."
msgstr ""
"再帰しないロックオブジェクトで、 :class:`threading.Lock` 相当のものです。プロ"
"セスやスレッドがロックをいったん獲得 (acquire) すると、それに続くほかのプロセ"
"スやスレッドが獲得しようとする際、それが解放 (release) されるまではブロックさ"
"れます。解放はどのプロセス、スレッドからも行えます。スレッドに対して適用され"
"る :class:`threading.Lock` のコンセプトと振る舞いは、特筆すべきものがない限"
"り、プロセスとスレッドに適用される :class:`multiprocessing.Lock` に引き継がれ"
"ています。"

#: ../../library/multiprocessing.rst:1362
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ""
":class:`Lock` は実際にはファクトリ関数で、デフォルトコンテキストで初期化され"
"た ``multiprocessing.synchronize.Lock`` のインスタンスを返すことに注意してく"
"ださい。"

#: ../../library/multiprocessing.rst:1366
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`Lock` は :term:`context manager` プロトコルをサポートしています。つま"
"り :keyword:`with` 文で使うことができます。"

#: ../../library/multiprocessing.rst:1371
#: ../../library/multiprocessing.rst:1422
msgid "Acquire a lock, blocking or non-blocking."
msgstr "ブロックあり、またはブロックなしでロックを獲得します。"

#: ../../library/multiprocessing.rst:1373
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and "
"return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr ""
"引数 *block* を ``True`` (デフォルト) に設定して呼び出した場合、ロックがアン"
"ロック状態になるまでブロックします。ブロックから抜けるとそれをロック状態にし"
"てから ``True`` を返します。 :meth:`threading.Lock.acquire` の最初の引数とは"
"名前が違っているので注意してください。"

#: ../../library/multiprocessing.rst:1378
msgid ""
"With the *block* argument set to ``False``, the method call does not block.  "
"If the lock is currently in a locked state, return ``False``; otherwise set "
"the lock to a locked state and return ``True``."
msgstr ""
"引数 *block* の値を ``False`` にして呼び出すとブロックしません。 現在ロック状"
"態であれば、直ちに ``False`` を返します。それ以外の場合には、ロックをロック状"
"態にして ``True`` を返します。"

#: ../../library/multiprocessing.rst:1382
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can "
"not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  Note that the "
"treatment of negative or ``None`` values for *timeout* differs from the "
"implemented behavior in :meth:`threading.Lock.acquire`.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed."
msgstr ""
"*timeout* として正の浮動小数点数を与えて呼び出すと、ロックが獲得できない限"
"り、指定された秒数だけブロックします。 *timeout* 値に負数を与えると、ゼロを与"
"えた場合と同じになります。 *timeout* 値の ``None`` (デフォルト) を与えると、"
"無限にブロックします。 *timeout* 引数の負数と ``None`` の扱いは、 :meth:"
"`threading.Lock.acquire` に実装された動作と異なるので注意してください。 "
"*block* が ``False`` の場合、 *timeout* は実際的な意味を持たなくなるので無視"
"されます。ロックを獲得した場合は ``True`` 、タイムアウトした場合は ``False`` "
"で戻ります。"

#: ../../library/multiprocessing.rst:1397
msgid ""
"Release a lock.  This can be called from any process or thread, not only the "
"process or thread which originally acquired the lock."
msgstr ""
"ロックを解放します。これはロックを獲得したプロセスやスレッドだけでなく、任意"
"のプロセスやスレッドから呼ぶことができます。"

#: ../../library/multiprocessing.rst:1400
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
":meth:`threading.Lock.release` と同じように振舞いますが、ロックされていない場"
"合に呼び出すと :exc:`ValueError` となる点だけが違います。"

#: ../../library/multiprocessing.rst:1406
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr ""
"再帰ロックオブジェクトで、 :class:`threading.RLock` 相当のものです。再帰ロッ"
"クオブジェクトはそれを獲得 (acquire) したプロセスやスレッドが解放 (release) "
"しなければなりません。プロセスやスレッドがロックをいったん獲得すると、同じプ"
"ロセスやスレッドはブロックされずに再度獲得出来ます。そのプロセスやスレッドは"
"獲得した回数ぶん解放しなければなりません。"

#: ../../library/multiprocessing.rst:1412
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default "
"context."
msgstr ""
":class:`RLock` は実際にはファクトリ関数で、デフォルトコンテキストで初期化され"
"た ``multiprocessing.synchronize.Lock`` のインスタンスを返すことに注意してく"
"ださい。"

#: ../../library/multiprocessing.rst:1416
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`RLock` は :term:`context manager` プロトコルをサポートしています。つ"
"まり :keyword:`with` 文で使うことができます。"

#: ../../library/multiprocessing.rst:1424
msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock "
"is in an unlocked state (not owned by any process or thread) unless the lock "
"is already owned by the current process or thread.  The current process or "
"thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation "
"of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr ""
"*block* 引数を ``True`` にして呼び出した場合、ロックが既にカレントプロセスも"
"しくはカレントスレッドが既に所有していない限りは、アンロック状態 (どのプロセ"
"ス、スレッドも所有していない状態) になるまでブロックします。ブロックから抜け"
"るとカレントプロセスもしくはカレントスレッドが (既に持っていなければ) 所有権"
"を得て、再帰レベルをインクリメントし、 ``True`` で戻ります。 :meth:"
"`threading.RLock.acquire` の実装とはこの最初の引数の振る舞いが、その名前自身"
"を始めとしていくつか違うので注意してください。"

#: ../../library/multiprocessing.rst:1434
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or "
"thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr ""
"*block* 引数を ``False`` にして呼び出した場合、ブロックしません。ロックが他の"
"プロセスもしくはスレッドにより獲得済み (つまり所有されている) であれば、カレ"
"ントプロセスまたはカレントスレッドは所有権を得ず、再帰レベルも変更せずに、 "
"``False`` で戻ります。ロックがアンロック状態の場合、カレントプロセスもしくは"
"カレントスレッドは所有権を得て再帰レベルがインクリメントされ、 ``True`` で戻"
"ります。(---訳注: *block* の True/False 関係なくここでの説明では「所有権を"
"持っている場合の2度目以降の aquire」の説明が欠けています。2度目以降の "
"acquire では再帰レベルがインクリメントされて即座に返ります。全体読めばわかる"
"とは思いますが一応。---)"

#: ../../library/multiprocessing.rst:1442
msgid ""
"Use and behaviors of the *timeout* argument are the same as in :meth:`Lock."
"acquire`.  Note that some of these behaviors of *timeout* differ from the "
"implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"*timeout* 引数の使い方と振る舞いは :meth:`Lock.acquire` と同じです。 "
"*timeout* 引数の振る舞いがいくつかの点で :meth:`threading.RLock.acquire` と異"
"なるので注意してください。"

#: ../../library/multiprocessing.rst:1449
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting "
"for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr ""
"再帰レベルをデクリメントしてロックを解放します。デクリメント後に再帰レベルが"
"ゼロになった場合、ロックの状態をアンロック (いかなるプロセス、いかなるスレッ"
"ドにも所有されていない状態) にリセットし、ロックの状態がアンロックになるのを"
"待ってブロックしているプロセスもしくはスレッドがある場合にはその中のただ一つ"
"だけが処理を進行できるようにします。デクリメント後も再帰レベルがゼロでない場"
"合、ロックの状態はロックのままで、呼び出し側のプロセスもしくはスレッドに所有"
"されたままになります。"

#: ../../library/multiprocessing.rst:1457
msgid ""
"Only call this method when the calling process or thread owns the lock. An :"
"exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"このメソッドは呼び出しプロセスあるいはスレッドがロックを所有している場合に限"
"り呼び出してください。所有者でないプロセスもしくはスレッドによって呼ばれる"
"か、あるいはアンロック (未所有) 状態で呼ばれた場合、 :exc:`AssertionError` が"
"送出されます。同じ状況での :meth:`threading.RLock.release` 実装とは例外の型が"
"異なるので注意してください。"

#: ../../library/multiprocessing.rst:1466
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr "セマフォオブジェクト: :class:`threading.Semaphore` のクローンです。"

#: ../../library/multiprocessing.rst:1473
msgid ""
"On macOS, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with a "
"timeout will emulate that function's behavior using a sleeping loop."
msgstr ""
"macOS では ``sem_timedwait`` がサポートされていないので、``acquire()`` にタイ"
"ムアウトを与えて呼ぶと、ループ内でスリープすることでこの関数がエミュレートさ"
"れます。"

#: ../../library/multiprocessing.rst:1478
msgid ""
"Some of this package's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the :mod:"
"`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"このパッケージに含まれる機能には、ホストとなるオペレーティングシステム上で動"
"作している共有セマフォを使用しているものがあります。これが使用できない場合に"
"は、:mod:`multiprocessing.synchronize` モジュールが無効になり、このモジュール"
"のインポート時に :exc:`ImportError` が発生します。詳細は :issue:`3770` を参照"
"してください。"

#: ../../library/multiprocessing.rst:1486
msgid "Shared :mod:`ctypes` Objects"
msgstr "共有 :mod:`ctypes` オブジェクト"

#: ../../library/multiprocessing.rst:1488
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr ""
"子プロセスにより継承される共有メモリを使用する共有オブジェクトを作成すること"
"ができます。"

#: ../../library/multiprocessing.rst:1493
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object.  The object "
"itself can be accessed via the *value* attribute of a :class:`Value`."
msgstr ""
"共有メモリから割り当てられた :mod:`ctypes` オブジェクトを返します。 デフォル"
"トでは、返り値は実際のオブジェクトの同期ラッパーです。オブジェクトそれ自身"
"は、 :class:`Value` の *value* 属性によってアクセスできます。"

#: ../../library/multiprocessing.rst:1497
#: ../../library/multiprocessing.rst:1584
msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the :mod:"
"`array` module.  *\\*args* is passed on to the constructor for the type."
msgstr ""
"*typecode_or_type* は返されるオブジェクトの型を決めます。それは ctypes の型"
"か :mod:`array` モジュールで使用されるような1文字の型コードかのどちらか一方で"
"す。 *\\*args* は型のコンストラクターへ渡されます。"

#: ../../library/multiprocessing.rst:1501
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` "
"or :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"*lock* が ``True`` (デフォルト) なら、値へ同期アクセスするために新たに再帰的"
"なロックオブジェクトが作成されます。 *lock* が :class:`Lock` か :class:"
"`RLock` なら値への同期アクセスに使用されます。 *lock* が ``False`` なら、返さ"
"れたオブジェクトへのアクセスはロックにより自動的に保護されません。そのため、"
"必ずしも \"プロセスセーフ\" ではありません。"

#: ../../library/multiprocessing.rst:1508
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr ""
"``+=`` のような演算は、読み込みと書き込みを含むためアトミックでありません。こ"
"のため、たとえば自動的に共有の値を増加させたい場合、以下のようにするのでは不"
"十分です ::"

#: ../../library/multiprocessing.rst:1512
msgid "counter.value += 1"
msgstr ""

#: ../../library/multiprocessing.rst:1514
msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr ""
"関連するロックが再帰的 (それがデフォルトです) なら、かわりに次のようにしま"
"す ::"

#: ../../library/multiprocessing.rst:1517
msgid ""
"with counter.get_lock():\n"
"    counter.value += 1"
msgstr ""

#: ../../library/multiprocessing.rst:1520
#: ../../library/multiprocessing.rst:1610
#: ../../library/multiprocessing.rst:1625
msgid "Note that *lock* is a keyword-only argument."
msgstr "*lock* はキーワード専用引数であることに注意してください。"

#: ../../library/multiprocessing.rst:1524
msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr ""
"共有メモリから割り当てられた ctypes 配列を返します。デフォルトでは、返り値は"
"実際の配列の同期ラッパーです。"

#: ../../library/multiprocessing.rst:1527
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* は返される配列の要素の型を決めます。それは ctypes の型か :"
"mod:`array` モジュールで使用されるような1文字の型コードかのどちらか一方で"
"す。 *size_or_initializer* が整数なら、配列の長さを決定し、その配列はゼロで初"
"期化されます。別の使用方法として *size_or_initializer* は配列の初期化に使用さ"
"れるシーケンスになり、そのシーケンス長が配列の長さを決定します。"

#: ../../library/multiprocessing.rst:1534
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or :class:"
"`RLock` object then that will be used to synchronize access to the value.  "
"If *lock* is ``False`` then access to the returned object will not be "
"automatically protected by a lock, so it will not necessarily be \"process-"
"safe\"."
msgstr ""
"*lock* が ``True`` (デフォルト) なら、値へ同期アクセスするために新たなロック"
"オブジェクトが作成されます。 *lock* が :class:`Lock` か :class:`RLock` なら値"
"への同期アクセスに使用されます。 *lock* が ``False`` なら、返されたオブジェク"
"トへのアクセスはロックにより自動的に保護されません。そのため、必ずしも \"プロ"
"セスセーフ\" ではありません。"

#: ../../library/multiprocessing.rst:1541
msgid "Note that *lock* is a keyword only argument."
msgstr "*lock* はキーワード引数としてのみ利用可能なことに注意してください。"

#: ../../library/multiprocessing.rst:1543
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes "
"which allow one to use it to store and retrieve strings."
msgstr ""
":data:`ctypes.c_char` の配列は文字列を格納して取り出せる *value* と *raw* 属"
"性を持っていることを覚えておいてください。"

#: ../../library/multiprocessing.rst:1548
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr ":mod:`multiprocessing.sharedctypes` モジュール"

#: ../../library/multiprocessing.rst:1553
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ""
":mod:`multiprocessing.sharedctypes` モジュールは子プロセスに継承される共有メ"
"モリの :mod:`ctypes` オブジェクトを割り当てる関数を提供します。"

#: ../../library/multiprocessing.rst:1559
msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process "
"may cause a crash."
msgstr ""
"共有メモリのポインターを格納することは可能ではありますが、特定プロセスのアド"
"レス空間の位置を参照するということを覚えておいてください。しかし、そのポイン"
"ターは別のプロセスのコンテキストにおいて無効になる確率が高いです。そして、別"
"のプロセスからそのポインターを逆参照しようとするとクラッシュを引き起こす可能"
"性があります。"

#: ../../library/multiprocessing.rst:1567
msgid "Return a ctypes array allocated from shared memory."
msgstr "共有メモリから割り当てられた ctypes 配列を返します。"

#: ../../library/multiprocessing.rst:1569
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* は返される配列の要素の型を決めます。それは ctypes の型か :"
"mod:`array` モジュールで使用されるような1文字の型コードのどちらか一方です。 "
"*size_or_initializer* が整数なら、それが配列の長さになり、その配列はゼロで初"
"期化されます。別の使用方法として *size_or_initializer* には配列の初期化に使用"
"されるシーケンスを設定することもでき、その場合はシーケンスの長さが配列の長さ"
"になります。"

#: ../../library/multiprocessing.rst:1576
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use :"
"func:`Array` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"要素を取得したり設定したりすることは潜在的に非アトミックであることに注意して"
"ください。ロックを使用して自動的に同期化されたアクセスを保証するには :func:"
"`Array` を使用してください。"

#: ../../library/multiprocessing.rst:1582
msgid "Return a ctypes object allocated from shared memory."
msgstr "共有メモリから割り当てられた ctypes オブジェクトを返します。"

#: ../../library/multiprocessing.rst:1588
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use :"
"func:`Value` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"値を取得したり設定したりすることは潜在的に非アトミックであることに注意してく"
"ださい。ロックを使用して自動的に同期化されたアクセスを保証するには :func:"
"`Value` を使用してください。"

#: ../../library/multiprocessing.rst:1592
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ""
":data:`ctypes.c_char` の配列は文字列を格納して取り出せる ``value`` と "
"``raw`` 属性を持っていることを覚えておいてください。詳細は :mod:`ctypes` を参"
"照してください。"

#: ../../library/multiprocessing.rst:1598
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"array."
msgstr ""
":func:`RawArray` と同様ですが、 *lock* の値によっては ctypes 配列をそのまま返"
"す代わりに、プロセスセーフな同期ラッパーが返されます。"

#: ../../library/multiprocessing.rst:1602
#: ../../library/multiprocessing.rst:1618
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`~multiprocessing."
"Lock` or :class:`~multiprocessing.RLock` object then that will be used to "
"synchronize access to the value.  If *lock* is ``False`` then access to the "
"returned object will not be automatically protected by a lock, so it will "
"not necessarily be \"process-safe\"."
msgstr ""
"*lock* が ``True`` (デフォルト) なら、値へ同期アクセスするために新たな ロック"
"オブジェクトが作成されます。 *lock* が :class:`~multiprocessing.Lock` か :"
"class:`~multiprocessing.RLock` なら値への同期アクセスに使用されます。 *lock* "
"が ``False`` なら、返された オブジェクトへのアクセスはロックにより自動的に保"
"護されません。 そのため、必ずしも \"プロセスセーフ\" ではありません。"

#: ../../library/multiprocessing.rst:1614
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"object."
msgstr ""
":func:`RawValue` と同様ですが、 *lock* の値によっては ctypes オブジェクトをそ"
"のまま返す代わりに、プロセスセーフな同期ラッパーが返されます。"

#: ../../library/multiprocessing.rst:1629
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr ""
"共有メモリから割り当てられた ctypes オブジェクト *obj* をコピーしたオブジェク"
"トを返します。"

#: ../../library/multiprocessing.rst:1634
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a :class:"
"`multiprocessing.RLock` object is created automatically."
msgstr ""
"同期アクセスに *lock* を使用する ctypes オブジェクトのためにプロセスセーフな"
"ラッパーオブジェクトを返します。 *lock* が ``None`` (デフォルト) なら、 :"
"class:`multiprocessing.RLock` オブジェクトが自動的に作成されます。"

#: ../../library/multiprocessing.rst:1638
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and :meth:"
"`get_lock` returns the lock object used for synchronization."
msgstr ""
"同期ラッパーがラップするオブジェクトに加えて2つのメソッドがあります。 :meth:"
"`get_obj` はラップされたオブジェクトを返します。 :meth:`get_lock` は同期のた"
"めに使用されるロックオブジェクトを返します。"

#: ../../library/multiprocessing.rst:1642
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr ""
"ラッパー経由で ctypes オブジェクトにアクセスすることは raw ctypes オブジェク"
"トへアクセスするよりずっと遅くなることに注意してください。"

#: ../../library/multiprocessing.rst:1645
msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr ""
"synchronized オブジェクトは :term:`コンテキストマネージャ <context manager>` "
"プロトコルをサポートしています。"

#: ../../library/multiprocessing.rst:1649
msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr ""
"次の表は通常の ctypes 構文で共有メモリから共有 ctypes オブジェクトを作成する"
"ための構文を比較します。 (``MyStruct`` テーブル内には :class:`ctypes."
"Structure` のサブクラスがあります。)"

#: ../../library/multiprocessing.rst:1654
msgid "ctypes"
msgstr "ctypes"

#: ../../library/multiprocessing.rst:1654
msgid "sharedctypes using type"
msgstr "type を使用する sharedctypes"

#: ../../library/multiprocessing.rst:1654
msgid "sharedctypes using typecode"
msgstr "typecode を使用する sharedctypes"

#: ../../library/multiprocessing.rst:1656
msgid "c_double(2.4)"
msgstr "c_double(2.4)"

#: ../../library/multiprocessing.rst:1656
msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2.4)"

#: ../../library/multiprocessing.rst:1656
msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

#: ../../library/multiprocessing.rst:1657
msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

#: ../../library/multiprocessing.rst:1657
msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

#: ../../library/multiprocessing.rst:1658
msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

#: ../../library/multiprocessing.rst:1658
msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

#: ../../library/multiprocessing.rst:1658
msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

#: ../../library/multiprocessing.rst:1659
msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

#: ../../library/multiprocessing.rst:1659
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

#: ../../library/multiprocessing.rst:1659
msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray('i', (9, 2, 8))"

#: ../../library/multiprocessing.rst:1663
msgid ""
"Below is an example where a number of ctypes objects are modified by a child "
"process::"
msgstr "以下に子プロセスが多くの ctypes オブジェクトを変更する例を紹介します::"

#: ../../library/multiprocessing.rst:1666
msgid ""
"from multiprocessing import Process, Lock\n"
"from multiprocessing.sharedctypes import Value, Array\n"
"from ctypes import Structure, c_double\n"
"\n"
"class Point(Structure):\n"
"    _fields_ = [('x', c_double), ('y', c_double)]\n"
"\n"
"def modify(n, x, s, A):\n"
"    n.value **= 2\n"
"    x.value **= 2\n"
"    s.value = s.value.upper()\n"
"    for a in A:\n"
"        a.x **= 2\n"
"        a.y **= 2\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    n = Value('i', 7)\n"
"    x = Value(c_double, 1.0/3.0, lock=False)\n"
"    s = Array('c', b'hello world', lock=lock)\n"
"    A = Array(Point, [(1.875,-6.25), (-5.75,2.0), (2.375,9.5)], lock=lock)\n"
"\n"
"    p = Process(target=modify, args=(n, x, s, A))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(n.value)\n"
"    print(x.value)\n"
"    print(s.value)\n"
"    print([(a.x, a.y) for a in A])"
msgstr ""

#: ../../library/multiprocessing.rst:1701
msgid "The results printed are ::"
msgstr "結果は以下のように表示されます ::"

#: ../../library/multiprocessing.rst:1703
msgid ""
"49\n"
"0.1111111111111111\n"
"HELLO WORLD\n"
"[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]"
msgstr ""

#: ../../library/multiprocessing.rst:1714
msgid "Managers"
msgstr "マネージャー"

#: ../../library/multiprocessing.rst:1716
msgid ""
"Managers provide a way to create data which can be shared between different "
"processes, including sharing over a network between processes running on "
"different machines. A manager object controls a server process which manages "
"*shared objects*.  Other processes can access the shared objects by using "
"proxies."
msgstr ""
"マネージャーは異なるプロセス間で共有されるデータの作成方法を提供します。これ"
"には別のマシン上で走るプロセス間のネットワーク越しの共有も含まれます。マネー"
"ジャーオブジェクトは *共有オブジェクト* を管理するサーバープロセスを制御しま"
"す。他のプロセスはプロキシ経由で共有オブジェクトへアクセスすることができま"
"す。"

#: ../../library/multiprocessing.rst:1725
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr ""
"プロセス間でオブジェクトを共有するために使用される :class:`~multiprocessing."
"managers.SyncManager` オブジェクトを返します。返されたマネージャーオブジェク"
"トは生成される子プロセスに対応付けられ、共有オブジェクトを作成するメソッド"
"や、共有オブジェクトに対応するプロキシを返すメソッドを持ちます。"

#: ../../library/multiprocessing.rst:1733
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the :mod:"
"`multiprocessing.managers` module:"
msgstr ""
"マネージャープロセスは親プロセスが終了するか、ガベージコレクトされると停止し"
"ます。マネージャークラスは :mod:`multiprocessing.managers` モジュールで定義さ"
"れています:"

#: ../../library/multiprocessing.rst:1739
msgid "Create a BaseManager object."
msgstr "BaseManager オブジェクトを作成します。"

#: ../../library/multiprocessing.rst:1741
msgid ""
"Once created one should call :meth:`start` or ``get_server()."
"serve_forever()`` to ensure that the manager object refers to a started "
"manager process."
msgstr ""
"作成後、:meth:`start` または ``get_server().serve_forever()`` を呼び出して、"
"マネージャーオブジェクトが、開始されたマネージャープロセスを確実に参照するよ"
"うにしてください。"

#: ../../library/multiprocessing.rst:1744
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr ""
"*address* はマネージャープロセスが新たなコネクションを待ち受けるアドレスで"
"す。*address* が ``None`` の場合、任意のアドレスが設定されます。"

#: ../../library/multiprocessing.rst:1747
msgid ""
"*authkey* is the authentication key which will be used to check the validity "
"of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey`` is used. Otherwise *authkey* is used and "
"it must be a byte string."
msgstr ""
"*authkey* はサーバープロセスへ接続しようとするコネクションの正当性を検証する"
"ために 使用される認証キーです。*authkey* が ``None`` の場合 "
"``current_process().authkey`` が使用されます。*authkey* を使用する場合はバイ"
"ト文字列でなければなりません。"

#: ../../library/multiprocessing.rst:1752
msgid ""
"*serializer* must be ``'pickle'`` (use :mod:`pickle` serialization) or "
"``'xmlrpclib'`` (use :mod:`xmlrpc.client` serialization)."
msgstr ""

#: ../../library/multiprocessing.rst:1755
msgid ""
"*ctx* is a context object, or ``None`` (use the current context). See the :"
"func:`get_context` function."
msgstr ""

#: ../../library/multiprocessing.rst:1758
msgid ""
"*shutdown_timeout* is a timeout in seconds used to wait until the process "
"used by the manager completes in the :meth:`shutdown` method. If the "
"shutdown times out, the process is terminated. If terminating the process "
"also times out, the process is killed."
msgstr ""

#: ../../library/multiprocessing.rst:1763
msgid "Added the *shutdown_timeout* parameter."
msgstr "*shutdown_timeout* パラメータを追加しました。"

#: ../../library/multiprocessing.rst:1768
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr ""
"マネージャーを開始するためにサブプロセスを開始します。*initializer* が "
"``None`` でなければ、サブプロセスは開始時に ``initializer(*initargs)`` を呼び"
"出します。"

#: ../../library/multiprocessing.rst:1773
msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the :meth:"
"`serve_forever` method::"
msgstr ""
"マネージャーの制御下にある実際のサーバーを表す :class:`Server` オブジェクトを"
"返します。 :class:`Server` オブジェクトは :meth:`serve_forever` メソッドをサ"
"ポートします::"

#: ../../library/multiprocessing.rst:1777
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> manager = BaseManager(address=('', 50000), authkey=b'abc')\n"
">>> server = manager.get_server()\n"
">>> server.serve_forever()"
msgstr ""

#: ../../library/multiprocessing.rst:1782
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` はさらに :attr:`address` 属性も持っています。"

#: ../../library/multiprocessing.rst:1786
msgid "Connect a local manager object to a remote manager process::"
msgstr "ローカルからリモートのマネージャーオブジェクトへ接続します::"

#: ../../library/multiprocessing.rst:1788
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> m = BaseManager(address=('127.0.0.1', 50000), authkey=b'abc')\n"
">>> m.connect()"
msgstr ""

#: ../../library/multiprocessing.rst:1794
msgid ""
"Stop the process used by the manager.  This is only available if :meth:"
"`start` has been used to start the server process."
msgstr ""
"マネージャーが使用するプロセスを停止します。これはサーバープロセスを開始する"
"ために :meth:`start` が使用された場合のみ有効です。"

#: ../../library/multiprocessing.rst:1797
msgid "This can be called multiple times."
msgstr "これは複数回呼び出すことができます。"

#: ../../library/multiprocessing.rst:1801
msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr ""
"マネージャークラスで呼び出し可能オブジェクト(callable)や型を登録するために使"
"用されるクラスメソッドです。"

#: ../../library/multiprocessing.rst:1804
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr ""
"*typeid* は特に共有オブジェクトの型を識別するために使用される \"型識別子\" で"
"す。これは文字列でなければなりません。"

#: ../../library/multiprocessing.rst:1807
msgid ""
"*callable* is a callable used for creating objects for this type "
"identifier.  If a manager instance will be connected to the server using "
"the :meth:`connect` method, or if the *create_method* argument is ``False`` "
"then this can be left as ``None``."
msgstr ""
"*callable* はこの型識別子のオブジェクトを作成するために使用される呼び出し可能"
"オブジェクトです。マネージャーインスタンスが :meth:`connect` メソッドを使って"
"サーバーに接続されているか、 *create_method* 引数が ``False`` の場合は、 "
"``None`` でも構いません。"

#: ../../library/multiprocessing.rst:1813
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""
"*proxytype* はこの *typeid* で共有オブジェクトのプロキシを作成するために使用"
"される :class:`BaseProxy` のサブクラスです。 ``None`` の場合、プロキシクラス"
"は自動的に作成されます。"

#: ../../library/multiprocessing.rst:1817
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy."
"_callmethod`.  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is "
"used instead if it exists.)  In the case where no exposed list is specified, "
"all \"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr ""
"*exposed* は :meth:`BaseProxy._callmethod` を使用したアクセスが許されるべき "
"typeid をプロキシするメソッド名のシーケンスを指定するために使用されます "
"(*exposed* が ``None`` の場合 :attr:`proxytype._exposed_` が存在すればそれが"
"代わりに使用されます)。*exposed* リストが指定されない場合、共有オブジェクトの"
"すべての \"パブリックメソッド\" がアクセス可能になります。 (ここでいう \"パブ"
"リックメソッド\" とは :meth:`~object.__call__` メソッドを持つものと名前が "
"``'_'`` で始まらないあらゆる属性を意味します。)"

#: ../../library/multiprocessing.rst:1826
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid "
"strings.  (If *method_to_typeid* is ``None`` then :attr:`proxytype."
"_method_to_typeid_` is used instead if it exists.)  If a method's name is "
"not a key of this mapping or if the mapping is ``None`` then the object "
"returned by the method will be copied by value."
msgstr ""
"*method_to_typeid* はプロキシが返す exposed メソッドの返り値の型を指定するた"
"めに使用されるマッピングで、メソッド名を typeid 文字列にマップします。 "
"(*method_to_typeid* が ``None`` の場合 :attr:`proxytype._method_to_typeid_` "
"が存在すれば、それが代わりに使用されます。) メソッド名がこのマッピングのキー"
"ではないか、マッピングが ``None`` の場合、そのメソッドによって返されるオブ"
"ジェクトが値として (by value) コピーされます。"

#: ../../library/multiprocessing.rst:1833
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared "
"object and return a proxy for it.  By default it is ``True``."
msgstr ""
"*create_method* は、共有オブジェクトを作成し、それに対するプロキシを返すよう"
"サーバープロセスに伝える、名前 *typeid* のメソッドを作成するかを決定します。"
"デフォルトでは ``True`` です。"

#: ../../library/multiprocessing.rst:1837
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ":class:`BaseManager` インスタンスも読み出し専用属性を1つ持っています:"

#: ../../library/multiprocessing.rst:1841
msgid "The address used by the manager."
msgstr "マネージャーが使用するアドレスです。"

#: ../../library/multiprocessing.rst:1843
msgid ""
"Manager objects support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the server "
"process (if it has not already started) and then returns the manager "
"object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""
"マネージャーオブジェクトはコンテキストマネージメント・プロトコルをサポートし"
"ます -- :ref:`typecontextmanager` を参照してください。 :meth:"
"`~contextmanager.__enter__` は (まだ開始していない場合) サーバープロセスを開"
"始してから、マネージャーオブジェクトを返します。 :meth:`~contextmanager."
"__exit__` は :meth:`shutdown` を呼び出します。"

#: ../../library/multiprocessing.rst:1849
msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr ""
"旧バージョンでは、 :meth:`~contextmanager.__enter__` はマネージャーのサーバー"
"プロセスがまだ開始していなかった場合でもプロセスを開始しませんでした。"

#: ../../library/multiprocessing.rst:1854
msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization "
"of processes.  Objects of this type are returned by :func:`multiprocessing."
"Manager`."
msgstr ""
"プロセス間の同期のために使用される :class:`BaseManager` のサブクラスです。 :"
"func:`multiprocessing.Manager` はこの型のオブジェクトを返します。"

#: ../../library/multiprocessing.rst:1858
msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. This "
"notably includes shared lists and dictionaries."
msgstr ""

#: ../../library/multiprocessing.rst:1864
msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for it."
msgstr ""
"共有 :class:`threading.Barrier` オブジェクトを作成して、そのプロキシを返しま"
"す。"

#: ../../library/multiprocessing.rst:1871
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr ""
"共有 :class:`threading.BoundedSemaphore` オブジェクトを作成して、そのプロキシ"
"を返します。"

#: ../../library/multiprocessing.rst:1876
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr ""
"共有 :class:`threading.Condition` オブジェクトを作成して、そのプロキシを返し"
"ます。"

#: ../../library/multiprocessing.rst:1879
msgid ""
"If *lock* is supplied then it should be a proxy for a :class:`threading."
"Lock` or :class:`threading.RLock` object."
msgstr ""
"*lock* が提供される場合 :class:`threading.Lock` か :class:`threading.RLock` "
"オブジェクトのためのプロキシになります。"

#: ../../library/multiprocessing.rst:1887
msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr ""
"共有 :class:`threading.Event` オブジェクトを作成して、そのプロキシを返しま"
"す。"

#: ../../library/multiprocessing.rst:1891
msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr ""
"共有 :class:`threading.Lock` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1895
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr ""
"共有 :class:`Namespace` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1899
msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr ""
"共有 :class:`queue.Queue` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1903
msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr ""
"共有 :class:`threading.RLock` オブジェクトを作成して、そのプロキシを返しま"
"す。"

#: ../../library/multiprocessing.rst:1907
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr ""
"共有 :class:`threading.Semaphore` オブジェクトを作成して、そのプロキシを返し"
"ます。"

#: ../../library/multiprocessing.rst:1912
msgid "Create an array and return a proxy for it."
msgstr "配列を作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1916
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr "書き込み可能な ``value`` 属性を作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1923
msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr "共有 :class:`dict` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1928
msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr "共有 :class:`list` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1930
msgid ""
"Shared objects are capable of being nested.  For example, a shared container "
"object such as a shared list can contain other shared objects which will all "
"be managed and synchronized by the :class:`SyncManager`."
msgstr ""
"共有オブジェクトは入れ子もできます。\n"
"例えば、共有リストのような共有コンテナオブジェクトは、 :class:`SyncManager` "
"がまとめて管理し同期を取っている他の共有オブジェクトを保持できます。"

#: ../../library/multiprocessing.rst:1937
msgid "A type that can register with :class:`SyncManager`."
msgstr ":class:`SyncManager` に登録することのできる型です。"

#: ../../library/multiprocessing.rst:1939
msgid ""
"A namespace object has no public methods, but does have writable attributes. "
"Its representation shows the values of its attributes."
msgstr ""
"Namespace オブジェクトにはパブリックなメソッドはありませんが、書き込み可能な"
"属性を持ちます。そのオブジェクト表現はその属性の値を表示します。"

#: ../../library/multiprocessing.rst:1942
msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr ""
"しかし、Namespace オブジェクトのためにプロキシを使用するとき ``'_'`` が先頭に"
"付く属性はプロキシの属性になり、参照対象の属性にはなりません:"

#: ../../library/multiprocessing.rst:1946
msgid ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> Global = manager.Namespace()\n"
">>> Global.x = 10\n"
">>> Global.y = 'hello'\n"
">>> Global._z = 12.3    # this is an attribute of the proxy\n"
">>> print(Global)\n"
"Namespace(x=10, y='hello')"
msgstr ""

#: ../../library/multiprocessing.rst:1959
msgid "Customized managers"
msgstr "カスタマイズされたマネージャー"

#: ../../library/multiprocessing.rst:1961
msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types "
"or callables with the manager class.  For example::"
msgstr ""
"独自のマネージャーを作成するには、:class:`BaseManager` のサブクラスを作成し"
"て、 マネージャークラスで呼び出し可能なオブジェクトか新たな型を登録するため"
"に :meth:`~BaseManager.register` クラスメソッドを使用します。例えば::"

#: ../../library/multiprocessing.rst:1965
msgid ""
"from multiprocessing.managers import BaseManager\n"
"\n"
"class MathsClass:\n"
"    def add(self, x, y):\n"
"        return x + y\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"MyManager.register('Maths', MathsClass)\n"
"\n"
"if __name__ == '__main__':\n"
"    with MyManager() as manager:\n"
"        maths = manager.Maths()\n"
"        print(maths.add(4, 3))         # prints 7\n"
"        print(maths.mul(7, 8))         # prints 56"
msgstr ""

#: ../../library/multiprocessing.rst:1986
msgid "Using a remote manager"
msgstr "リモートマネージャーを使用する"

#: ../../library/multiprocessing.rst:1988
msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr ""
"あるマシン上でマネージャーサーバーを実行して、他のマシンからそのサーバーを使"
"用するクライアントを持つことができます(ファイアウォールを通過できることが前"
"提)。"

#: ../../library/multiprocessing.rst:1991
msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr ""
"次のコマンドを実行することでリモートクライアントからアクセスを受け付ける1つの"
"共有キューのためにサーバーを作成します::"

#: ../../library/multiprocessing.rst:1994
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> from queue import Queue\n"
">>> queue = Queue()\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue', callable=lambda:queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""

#: ../../library/multiprocessing.rst:2003
msgid "One client can access the server as follows::"
msgstr "あるクライアントからサーバーへのアクセスは次のようになります::"

#: ../../library/multiprocessing.rst:2005
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), "
"authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.put('hello')"
msgstr ""

#: ../../library/multiprocessing.rst:2013
msgid "Another client can also use it::"
msgstr "別のクライアントもそれを使用することができます::"

#: ../../library/multiprocessing.rst:2015
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), "
"authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.get()\n"
"'hello'"
msgstr ""

#: ../../library/multiprocessing.rst:2024
msgid ""
"Local processes can also access that queue, using the code from above on the "
"client to access it remotely::"
msgstr ""
"ローカルプロセスもそのキューへアクセスすることができます。クライアント上で上"
"述のコードを使用してアクセスします::"

#: ../../library/multiprocessing.rst:2027
msgid ""
">>> from multiprocessing import Process, Queue\n"
">>> from multiprocessing.managers import BaseManager\n"
">>> class Worker(Process):\n"
"...     def __init__(self, q):\n"
"...         self.q = q\n"
"...         super().__init__()\n"
"...     def run(self):\n"
"...         self.q.put('local hello')\n"
"...\n"
">>> queue = Queue()\n"
">>> w = Worker(queue)\n"
">>> w.start()\n"
">>> class QueueManager(BaseManager): pass\n"
"...\n"
">>> QueueManager.register('get_queue', callable=lambda: queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""

#: ../../library/multiprocessing.rst:2049
msgid "Proxy Objects"
msgstr "Proxy オブジェクト"

#: ../../library/multiprocessing.rst:2051
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr ""
"プロキシは別のプロセスで(おそらく)有効な共有オブジェクトを *参照する* オブ"
"ジェクトです。共有オブジェクトはプロキシの *参照対象* になるということができ"
"ます。複数のプロキシオブジェクトが同じ参照対象を持つ可能性もあります。"

#: ../../library/multiprocessing.rst:2055
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like "
"its referent can:"
msgstr ""
"プロキシオブジェクトはその参照対象の対応するメソッドを呼び出すメソッドを持ち"
"ます (そうは言っても、参照対象のすべてのメソッドが必ずしもプロキシ経由で利用"
"可能なわけではありません)。\n"
"この方法で、プロキシオブジェクトはまるでその参照先と同じように使えます:"

#: ../../library/multiprocessing.rst:2059
msgid ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> l = manager.list([i*i for i in range(10)])\n"
">>> print(l)\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n"
">>> print(repr(l))\n"
"<ListProxy object, typeid 'list' at 0x...>\n"
">>> l[4]\n"
"16\n"
">>> l[2:5]\n"
"[4, 9, 16]"
msgstr ""

#: ../../library/multiprocessing.rst:2073
msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr ""
"プロキシに :func:`str` を適用すると参照対象のオブジェクト表現を返すのに対し"
"て、 :func:`repr` を適用するとプロキシのオブジェクト表現を返すことに注意して"
"ください。"

#: ../../library/multiprocessing.rst:2077
msgid ""
"An important feature of proxy objects is that they are picklable so they can "
"be passed between processes.  As such, a referent can contain :ref:"
"`multiprocessing-proxy_objects`.  This permits nesting of these managed "
"lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""
"プロキシオブジェクトの重要な機能は pickle 化ができることで、これによりプロセ"
"ス間での受け渡しができます。\n"
"そのため、参照対象が :ref:`multiprocessing-proxy_objects` を持てます。\n"
"これによって管理されたリスト、辞書、その他 :ref:`multiprocessing-"
"proxy_objects` をネストできます:"

#: ../../library/multiprocessing.rst:2082
msgid ""
">>> a = manager.list()\n"
">>> b = manager.list()\n"
">>> a.append(b)         # referent of a now contains referent of b\n"
">>> print(a, b)\n"
"[<ListProxy object, typeid 'list' at ...>] []\n"
">>> b.append('hello')\n"
">>> print(a[0], b)\n"
"['hello'] ['hello']"
msgstr ""

#: ../../library/multiprocessing.rst:2093
msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr ""
"同様に、辞書とリストのプロキシも他のプロキシの内部に入れてネストできます::"

#: ../../library/multiprocessing.rst:2095
msgid ""
">>> l_outer = manager.list([ manager.dict() for i in range(2) ])\n"
">>> d_first_inner = l_outer[0]\n"
">>> d_first_inner['a'] = 1\n"
">>> d_first_inner['b'] = 2\n"
">>> l_outer[1]['c'] = 3\n"
">>> l_outer[1]['z'] = 26\n"
">>> print(l_outer[0])\n"
"{'a': 1, 'b': 2}\n"
">>> print(l_outer[1])\n"
"{'c': 3, 'z': 26}"
msgstr ""

#: ../../library/multiprocessing.rst:2106
msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are contained "
"in a referent, modifications to those mutable values will not be propagated "
"through the manager because the proxy has no way of knowing when the values "
"contained within are modified.  However, storing a value in a container "
"proxy (which triggers a ``__setitem__`` on the proxy object) does propagate "
"through the manager and so to effectively modify such an item, one could re-"
"assign the modified value to the container proxy::"
msgstr ""
"(プロキシでない) 標準の :class:`list` オブジェクトや :class:`dict` オブジェク"
"トが参照対象に含まれていた場合、それらの可変な値の変更はマネージャーからは伝"
"搬されません。\n"
"というのも、プロキシには参照対象の中に含まれる値がいつ変更されたかを知る術が"
"無いのです。\n"
"しかし、コンテナプロキシに値を保存する (これはプロキシオブジェクトの "
"``__setitem__`` を起動します) 場合はマネージャーを通して変更が伝搬され、その"
"要素を実際に変更するために、コンテナプロキシに変更後の値が再代入されます::"

#: ../../library/multiprocessing.rst:2114
msgid ""
"# create a list proxy and append a mutable object (a dictionary)\n"
"lproxy = manager.list()\n"
"lproxy.append({})\n"
"# now mutate the dictionary\n"
"d = lproxy[0]\n"
"d['a'] = 1\n"
"d['b'] = 2\n"
"# at this point, the changes to d are not yet synced, but by\n"
"# updating the dictionary, the proxy is notified of the change\n"
"lproxy[0] = d"
msgstr ""

#: ../../library/multiprocessing.rst:2125
msgid ""
"This approach is perhaps less convenient than employing nested :ref:"
"`multiprocessing-proxy_objects` for most use cases but also demonstrates a "
"level of control over the synchronization."
msgstr ""

#: ../../library/multiprocessing.rst:2131
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ""
":mod:`multiprocessing` のプロキシ型は値による比較に対して何もサポートしませ"
"ん。そのため、例えば以下のようになります:"

#: ../../library/multiprocessing.rst:2134
msgid ""
">>> manager.list([1,2,3]) == [1,2,3]\n"
"False"
msgstr ""

#: ../../library/multiprocessing.rst:2139
msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr "比較を行いたいときは参照対象のコピーを使用してください。"

#: ../../library/multiprocessing.rst:2143
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr ""
"プロキシオブジェクトは :class:`BaseProxy` のサブクラスのインスタンスです。"

#: ../../library/multiprocessing.rst:2147
msgid "Call and return the result of a method of the proxy's referent."
msgstr "プロキシの参照対象のメソッドの実行結果を返します。"

#: ../../library/multiprocessing.rst:2149
msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr "``proxy`` がプロキシで、プロキシ内の参照対象が ``obj`` ならこの式 ::"

#: ../../library/multiprocessing.rst:2151
msgid "proxy._callmethod(methodname, args, kwds)"
msgstr ""

#: ../../library/multiprocessing.rst:2153
msgid "will evaluate the expression ::"
msgstr "はこの式を評価します ::"

#: ../../library/multiprocessing.rst:2155
msgid "getattr(obj, methodname)(*args, **kwds)"
msgstr ""

#: ../../library/multiprocessing.rst:2157
msgid "in the manager's process."
msgstr "(マネージャープロセス内の)。"

#: ../../library/multiprocessing.rst:2159
msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr ""
"返される値はその呼び出し結果のコピーか、新たな共有オブジェクトに対するプロキ"
"シになります。詳細は :meth:`BaseManager.register` の *method_to_typeid* 引数"
"のドキュメントを参照してください。"

#: ../../library/multiprocessing.rst:2163
msgid ""
"If an exception is raised by the call, then is re-raised by :meth:"
"`_callmethod`.  If some other exception is raised in the manager's process "
"then this is converted into a :exc:`RemoteError` exception and is raised by :"
"meth:`_callmethod`."
msgstr ""
"その呼び出しによって例外が発生した場合、:meth:`_callmethod` によってその例外"
"は再送出されます。他の例外がマネージャープロセスで発生したなら、:exc:"
"`RemoteError` 例外に変換されたものが :meth:`_callmethod` によって送出されま"
"す。"

#: ../../library/multiprocessing.rst:2168
msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr ""
"特に *methodname* が *公開* されていない場合は例外が発生することに注意してく"
"ださい。"

#: ../../library/multiprocessing.rst:2171
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr ":meth:`_callmethod` の使用例になります:"

#: ../../library/multiprocessing.rst:2173
msgid ""
">>> l = manager.list(range(10))\n"
">>> l._callmethod('__len__')\n"
"10\n"
">>> l._callmethod('__getitem__', (slice(2, 7),)) # equivalent to l[2:7]\n"
"[2, 3, 4, 5, 6]\n"
">>> l._callmethod('__getitem__', (20,))          # equivalent to l[20]\n"
"Traceback (most recent call last):\n"
"...\n"
"IndexError: list index out of range"
msgstr ""

#: ../../library/multiprocessing.rst:2187
msgid "Return a copy of the referent."
msgstr "参照対象のコピーを返します。"

#: ../../library/multiprocessing.rst:2189
msgid "If the referent is unpicklable then this will raise an exception."
msgstr "参照対象が unpickle 化できるなら例外を発生します。"

#: ../../library/multiprocessing.rst:2193
msgid "Return a representation of the proxy object."
msgstr "プロキシオブジェクトのオブジェクト表現を返します。"

#: ../../library/multiprocessing.rst:2197
msgid "Return the representation of the referent."
msgstr "参照対象のオブジェクト表現を返します。"

#: ../../library/multiprocessing.rst:2201
msgid "Cleanup"
msgstr "クリーンアップ"

#: ../../library/multiprocessing.rst:2203
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr ""
"プロキシオブジェクトは弱参照(weakref)コールバックを使用します。プロキシオブ"
"ジェクトがガベージコレクトされるときにその参照対象が所有するマネージャーから"
"その登録を取り消せるようにするためです。"

#: ../../library/multiprocessing.rst:2206
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr ""
"共有オブジェクトはプロキシが参照しなくなったときにマネージャープロセスから削"
"除されます。"

#: ../../library/multiprocessing.rst:2211
msgid "Process Pools"
msgstr "プロセスプール"

#: ../../library/multiprocessing.rst:2216
msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr ""
":class:`Pool` クラスでタスクを実行するプロセスのプールを作成することができま"
"す。"

#: ../../library/multiprocessing.rst:2221
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr ""
"プロセスプールオブジェクトは、ジョブを送り込めるワーカープロセスのプールを制"
"御します。タイムアウトやコールバックのある非同期の実行をサポートし、並列 map "
"実装を持ちます。"

#: ../../library/multiprocessing.rst:2225
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.process_cpu_count` is used."
msgstr ""

#: ../../library/multiprocessing.rst:2228
#: ../../library/multiprocessing.rst:2792
msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""
"*initializer* が ``None`` ではない場合、各ワーカープロセスは開始時に "
"``initializer(*initargs)`` を呼び出します。"

#: ../../library/multiprocessing.rst:2231
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is ``None``, "
"which means worker processes will live as long as the pool."
msgstr ""
"*maxtasksperchild* は、ワーカープロセスが exit して新たなワーカープロセスと置"
"き替えられるまでの間に、ワーカープロセスが完了することのできるタスクの数で"
"す。この設定により未利用のリソースが解放されるようなります。デフォルトの "
"*maxtasksperchild* は ``None`` で、これはワーカープロセスがプールと同じ期間だ"
"け生き続けるということを意味します。"

#: ../../library/multiprocessing.rst:2236
msgid ""
"*context* can be used to specify the context used for starting the worker "
"processes.  Usually a pool is created using the function :func:"
"`multiprocessing.Pool` or the :meth:`Pool` method of a context object.  In "
"both cases *context* is set appropriately."
msgstr ""
"*context* はワーカープロセスを開始するために使用されるコンテキストの指定に使"
"用できます。通常プールは関数 :func:`multiprocessing.Pool` かコンテキストオブ"
"ジェクトの :meth:`Pool` メソッドを使用して作成されます。どちらの場合でも "
"*context* は適切に設定されます。"

#: ../../library/multiprocessing.rst:2242
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr ""
"プールオブジェクトのメソッドは、そのプールを作成したプロセスのみが呼び出すべ"
"きです。"

#: ../../library/multiprocessing.rst:2246
msgid ""
":class:`multiprocessing.pool` objects have internal resources that need to "
"be properly managed (like any other resource) by using the pool as a context "
"manager or by calling :meth:`close` and :meth:`terminate` manually. Failure "
"to do this can lead to the process hanging on finalization."
msgstr ""

#: ../../library/multiprocessing.rst:2251
msgid ""
"Note that it is **not correct** to rely on the garbage collector to destroy "
"the pool as CPython does not assure that the finalizer of the pool will be "
"called (see :meth:`object.__del__` for more information)."
msgstr ""

#: ../../library/multiprocessing.rst:2255
msgid "Added the *maxtasksperchild* parameter."
msgstr ""

#: ../../library/multiprocessing.rst:2258
msgid "Added the *context* parameter."
msgstr "*context* パラメータを追加しました。"

#: ../../library/multiprocessing.rst:2261
msgid ""
"*processes* uses :func:`os.process_cpu_count` by default, instead of :func:"
"`os.cpu_count`."
msgstr ""

#: ../../library/multiprocessing.rst:2267
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems "
"(such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old "
"one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ""
":class:`Pool` 中のワーカープロセスは、典型的にはプールのワークキューの存続期"
"間とちょうど同じだけ生き続けます。ワーカーに確保されたリソースを解放するため"
"に (Apache, mod_wsgi, などのような) 他のシステムによく見られるパターンは、"
"プール内のワーカーが設定された量だけの仕事を完了したら exit とクリーンアップ"
"を行い、古いプロセスを置き換えるために新しいプロセスを生成するというもので"
"す。 :class:`Pool` の *maxtasksperchild* 引数は、この能力をエンドユーザーに提"
"供します。"

#: ../../library/multiprocessing.rst:2277
msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It blocks "
"until the result is ready. Given this blocks, :meth:`apply_async` is better "
"suited for performing work in parallel. Additionally, *func* is only "
"executed in one of the workers of the pool."
msgstr ""
"引数 *args* とキーワード引数 *kwds* を伴って *func* を呼びます。結果が準備で"
"きるまでブロックします。このブロックがあるため、 :meth:`apply_async` の方が並"
"行作業により適しています。加えて、 *func* は、プール内の1つのワーカーだけで実"
"行されます。"

#: ../../library/multiprocessing.rst:2284
msgid ""
"A variant of the :meth:`apply` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
":meth:`apply` メソッドの派生版で :class:`~multiprocessing.pool.AsyncResult` "
"オブジェクトを返します。"

#: ../../library/multiprocessing.rst:2287
#: ../../library/multiprocessing.rst:2318
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it, "
"that is unless the call failed, in which case the *error_callback* is "
"applied instead."
msgstr ""
"*callback* が指定された場合、それは単一の引数を受け取る呼び出し可能オブジェク"
"トでなければなりません。結果を返せるようになったときに *callback* が結果オブ"
"ジェクトに対して適用されます。ただし呼び出しが失敗した場合は、代わりに "
"*error_callback* が適用されます。"

#: ../../library/multiprocessing.rst:2292
#: ../../library/multiprocessing.rst:2323
msgid ""
"If *error_callback* is specified then it should be a callable which accepts "
"a single argument.  If the target function fails, then the *error_callback* "
"is called with the exception instance."
msgstr ""
"*error_callback* が指定された場合、それは単一の引数を受け取る呼び出し可能オブ"
"ジェクトでなければなりません。対象の関数が失敗した場合、例外インスタンスを"
"伴って *error_callback* が呼ばれます。"

#: ../../library/multiprocessing.rst:2296
#: ../../library/multiprocessing.rst:2327
msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr ""
"コールバックは直ちに完了すべきです。なぜなら、そうしなければ、結果を扱うス"
"レッドがブロックするからです。"

#: ../../library/multiprocessing.rst:2301
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only "
"one *iterable* argument though, for multiple iterables see :meth:`starmap`). "
"It blocks until the result is ready."
msgstr ""
":func:`map` 組み込み関数の並列版です (*iterable* な引数を1つだけサポートする"
"という違いはあります。もしも複数のイテラブルを使いたいのならば :meth:"
"`starmap` を参照)。結果が出るまでブロックします。"

#: ../../library/multiprocessing.rst:2305
msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr ""
"このメソッドはイテラブルをいくつものチャンクに分割し、プロセスプールにそれぞ"
"れ独立したタスクとして送ります。(概算の) チャンクサイズは *chunksize* を正の"
"整数に設定することで指定できます。"

#: ../../library/multiprocessing.rst:2309
msgid ""
"Note that it may cause high memory usage for very long iterables. Consider "
"using :meth:`imap` or :meth:`imap_unordered` with explicit *chunksize* "
"option for better efficiency."
msgstr ""

#: ../../library/multiprocessing.rst:2315
msgid ""
"A variant of the :meth:`.map` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
":meth:`.map` メソッドの派生版で :class:`~multiprocessing.pool.AsyncResult` オ"
"ブジェクトを返します。"

#: ../../library/multiprocessing.rst:2332
msgid "A lazier version of :meth:`.map`."
msgstr ":meth:`.map` の遅延評価版です。"

#: ../../library/multiprocessing.rst:2334
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr ""
"*chunksize* 引数は :meth:`.map` メソッドで使用されるものと同じです。 引数 "
"iterable がとても長いなら *chunksize* に大きな値を指定して使用する方がデフォ"
"ルト値の ``1`` を使用するよりもジョブの完了が **かなり** 速くなります。"

#: ../../library/multiprocessing.rst:2339
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr ""
"また *chunksize* が ``1`` の場合 :meth:`imap` メソッドが返すイテレーターの :"
"meth:`!next` メソッドはオプションで *timeout* パラメーターを持ちます。 "
"``next(timeout)`` は、その結果が *timeout* 秒以内に返されないときに :exc:"
"`multiprocessing.TimeoutError` を発生させます。"

#: ../../library/multiprocessing.rst:2346
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr ""
"イテレーターが返す結果の順番が任意の順番で良いと見なされることを除けば :meth:"
"`imap` と同じです。 (ワーカープロセスが1つしかない場合のみ \"正しい\" 順番に"
"なることが保証されます。)"

#: ../../library/multiprocessing.rst:2352
msgid ""
"Like :meth:`~multiprocessing.pool.Pool.map` except that the elements of the "
"*iterable* are expected to be iterables that are unpacked as arguments."
msgstr ""
"*iterable* の要素が、引数として unpack されるイテレート可能オブジェクトである"
"と期待される以外は、 :meth:`~multiprocessing.pool.Pool.map` と似ています。"

#: ../../library/multiprocessing.rst:2356
msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr ""
"そのため、*iterable* が ``[(1,2), (3, 4)]`` なら、結果は ``[func(1,2), "
"func(3,4)]`` になります。"

#: ../../library/multiprocessing.rst:2363
msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over "
"*iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""
":meth:`starmap` と :meth:`map_async` の組み合わせです。 イテレート可能オブ"
"ジェクトの *iterable* をイテレートして、 unpack したイテレート可能オブジェク"
"トを伴って *func* を呼び出します。結果オブジェクトを返します。"

#: ../../library/multiprocessing.rst:2371
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr ""
"これ以上プールでタスクが実行されないようにします。すべてのタスクが完了した後"
"でワーカープロセスが終了します。"

#: ../../library/multiprocessing.rst:2376
msgid ""
"Stops the worker processes immediately without completing outstanding work.  "
"When the pool object is garbage collected :meth:`terminate` will be called "
"immediately."
msgstr ""
"実行中の処理を完了させずにワーカープロセスをすぐに停止します。プールオブジェ"
"クトがガベージコレクトされるときに :meth:`terminate` が呼び出されます。"

#: ../../library/multiprocessing.rst:2382
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or :meth:"
"`terminate` before using :meth:`join`."
msgstr ""
"ワーカープロセスが終了するのを待ちます。 :meth:`join` を使用する前に :meth:"
"`close` か :meth:`terminate` を呼び出さなければなりません。"

#: ../../library/multiprocessing.rst:2385
msgid ""
"Pool objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the pool "
"object, and :meth:`~contextmanager.__exit__` calls :meth:`terminate`."
msgstr ""
"Pool オブジェクトがコンテキストマネージメント・プロトコルをサポートするように"
"なりました。 -- :ref:`typecontextmanager` を参照してください。 :meth:"
"`~contextmanager.__enter__` は Pool オブジェクトを返します。また :meth:"
"`~contextmanager.__exit__` は :meth:`terminate` を呼び出します。"

#: ../../library/multiprocessing.rst:2393
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and :meth:`Pool."
"map_async`."
msgstr ""
":meth:`Pool.apply_async` や :meth:`Pool.map_async` で返される結果のクラスで"
"す。"

#: ../../library/multiprocessing.rst:2398
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then :exc:`multiprocessing."
"TimeoutError` is raised.  If the remote call raised an exception then that "
"exception will be reraised by :meth:`get`."
msgstr ""
"結果を受け取ったときに返します。 *timeout* が ``None`` ではなくて、その結果"
"が *timeout* 秒以内に受け取れない場合 :exc:`multiprocessing.TimeoutError` が"
"発生します。リモートの呼び出しが例外を発生させる場合、その例外は :meth:`get` "
"が再発生させます。"

#: ../../library/multiprocessing.rst:2405
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr "その結果が有効になるか *timeout* 秒経つまで待ちます。"

#: ../../library/multiprocessing.rst:2409
msgid "Return whether the call has completed."
msgstr "その呼び出しが完了しているかどうかを返します。"

#: ../../library/multiprocessing.rst:2413
msgid ""
"Return whether the call completed without raising an exception.  Will raise :"
"exc:`ValueError` if the result is not ready."
msgstr ""
"その呼び出しが例外を発生させることなく完了したかどうかを返します。その結果が"
"返せる状態でない場合 :exc:`ValueError` が発生します。"

#: ../../library/multiprocessing.rst:2416
msgid ""
"If the result is not ready, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""

#: ../../library/multiprocessing.rst:2420
msgid "The following example demonstrates the use of a pool::"
msgstr "次の例はプールの使用例を紹介します::"

#: ../../library/multiprocessing.rst:2422
msgid ""
"from multiprocessing import Pool\n"
"import time\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(processes=4) as pool:         # start 4 worker processes\n"
"        result = pool.apply_async(f, (10,)) # evaluate \"f(10)\" "
"asynchronously in a single process\n"
"        print(result.get(timeout=1))        # prints \"100\" unless your "
"computer is *very* slow\n"
"\n"
"        print(pool.map(f, range(10)))       # prints \"[0, 1, 4,..., 81]\"\n"
"\n"
"        it = pool.imap(f, range(10))\n"
"        print(next(it))                     # prints \"0\"\n"
"        print(next(it))                     # prints \"1\"\n"
"        print(it.next(timeout=1))           # prints \"4\" unless your "
"computer is *very* slow\n"
"\n"
"        result = pool.apply_async(time.sleep, (10,))\n"
"        print(result.get(timeout=1))        # raises multiprocessing."
"TimeoutError"
msgstr ""

#: ../../library/multiprocessing.rst:2447
msgid "Listeners and Clients"
msgstr "リスナーとクライアント"

#: ../../library/multiprocessing.rst:2452
msgid ""
"Usually message passing between processes is done using queues or by using :"
"class:`~Connection` objects returned by :func:`~multiprocessing.Pipe`."
msgstr ""
"通常、プロセス間でメッセージを渡すにはキューを使用するか :func:"
"`~multiprocessing.Pipe` が返す :class:`~Connection` オブジェクトを使用しま"
"す。"

#: ../../library/multiprocessing.rst:2456
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""
"しかし :mod:`multiprocessing.connection` モジュールにはさらに柔軟な仕組みがあ"
"ります。 このモジュールは、基本的にはソケットもしくは Windows の名前付きパイ"
"プを扱う高レベルのメッセージ指向 API を提供します。また、 :mod:`hmac` モ"
"ジュールを使用した *ダイジェスト認証* や同時の複数接続のポーリングもサポート"
"します。"

#: ../../library/multiprocessing.rst:2465
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr ""
"ランダム生成したメッセージをコネクションの相手側へ送信して応答を待ちます。"

#: ../../library/multiprocessing.rst:2468
msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"その応答がキーとして *authkey* を使用するメッセージのダイジェストと一致する場"
"合、 コネクションの相手側へ歓迎メッセージを送信します。 そうでなければ :exc:"
"`~multiprocessing.AuthenticationError` を発生させます。"

#: ../../library/multiprocessing.rst:2474
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr ""
"メッセージを受信して、そのキーとして *authkey* を使用するメッセージのダイジェ"
"ストを計算し、ダイジェストを送り返します。"

#: ../../library/multiprocessing.rst:2477
msgid ""
"If a welcome message is not received, then :exc:`~multiprocessing."
"AuthenticationError` is raised."
msgstr ""
"歓迎メッセージを受け取れない場合 :exc:`~multiprocessing.AuthenticationError` "
"が発生します。"

#: ../../library/multiprocessing.rst:2482
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr ""
"*address* で渡したアドレスを使用するリスナーに対してコネクションを確立しよう"
"として :class:`~Connection` を返します。"

#: ../../library/multiprocessing.rst:2485
msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""
"コネクション種別は *family* 引数で決定しますが、一般的には *address* のフォー"
"マットから推測できるので、これは指定されません。 (:ref:`multiprocessing-"
"address-formats` を参照してください)"

#: ../../library/multiprocessing.rst:2489
#: ../../library/multiprocessing.rst:2524
msgid ""
"If *authkey* is given and not ``None``, it should be a byte string and will "
"be used as the secret key for an HMAC-based authentication challenge. No "
"authentication is done if *authkey* is ``None``. :exc:`~multiprocessing."
"AuthenticationError` is raised if authentication fails. See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""

#: ../../library/multiprocessing.rst:2497
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr ""
"コネクションを '待ち受ける' 束縛されたソケットか Windows の名前付きパイプの"
"ラッパーです。"

#: ../../library/multiprocessing.rst:2500
msgid ""
"*address* is the address to be used by the bound socket or named pipe of the "
"listener object."
msgstr ""
"*address* はリスナーオブジェクトの束縛されたソケットか名前付きパイプが使用す"
"るアドレスです。"

#: ../../library/multiprocessing.rst:2505
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use "
"'127.0.0.1'."
msgstr ""
"'0.0.0.0' のアドレスを使用する場合、Windows 上の終点へ接続することができませ"
"ん。終点へ接続したい場合は '127.0.0.1' を使用すべきです。"

#: ../../library/multiprocessing.rst:2509
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr ""
"*family* は使用するソケット(名前付きパイプ)の種別です。これは ``'AF_INET'`` "
"(TCP ソケット), ``'AF_UNIX'`` (Unix ドメインソケット) または ``'AF_PIPE'`` "
"(Windows 名前付きパイプ) という文字列のどれか1つになります。これらのうち "
"``'AF_INET'`` のみが利用可能であることが保証されています。 *family* が "
"``None`` の場合 *address* のフォーマットから推測されたものが使用されます。 "
"*address* も ``None`` の場合はデフォルトが選択されます。詳細は :ref:"
"`multiprocessing-address-formats` を参照してください。 *family* が "
"``'AF_UNIX'`` で *address* が ``None`` の場合 :func:`tempfile.mkstemp` を使用"
"して作成されたプライベートな一時ディレクトリにソケットが作成されます。"

#: ../../library/multiprocessing.rst:2520
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed "
"to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr ""
"リスナーオブジェクトがソケットを使用する場合、ソケットに束縛されるときに "
"*backlog* (デフォルトでは1つ) がソケットの :meth:`~socket.socket.listen` メ"
"ソッドに対して渡されます。"

#: ../../library/multiprocessing.rst:2532
msgid ""
"Accept a connection on the bound socket or named pipe of the listener object "
"and return a :class:`~Connection` object. If authentication is attempted and "
"fails, then :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"リスナーオブジェクトの名前付きパイプか束縛されたソケット上でコネクションを 受"
"け付けて :class:`~Connection` オブジェクトを返します。 認証が失敗した場合 :"
"exc:`~multiprocessing.AuthenticationError` が発生します。"

#: ../../library/multiprocessing.rst:2539
msgid ""
"Close the bound socket or named pipe of the listener object.  This is called "
"automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr ""
"リスナーオブジェクトの名前付きパイプか束縛されたソケットをクローズします。こ"
"れはリスナーがガベージコレクトされるときに自動的に呼ばれます。そうは言って"
"も、明示的に close() を呼び出す方が望ましいです。"

#: ../../library/multiprocessing.rst:2543
msgid "Listener objects have the following read-only properties:"
msgstr "リスナーオブジェクトは次の読み出し専用属性を持っています:"

#: ../../library/multiprocessing.rst:2547
msgid "The address which is being used by the Listener object."
msgstr "リスナーオブジェクトが使用中のアドレスです。"

#: ../../library/multiprocessing.rst:2551
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr ""
"最後にコネクションを受け付けたアドレスです。有効なアドレスがない場合は "
"``None`` になります。"

#: ../../library/multiprocessing.rst:2554
msgid ""
"Listener objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"listener object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Listener オブジェクトがコンテキストマネージメント・プロトコルをサポートするよ"
"うになりました。 -- :ref:`typecontextmanager` を参照してください。 :meth:"
"`~contextmanager.__enter__` はリスナーオブジェクトを返します。また :meth:"
"`~contextmanager.__exit__` は :meth:`close` を呼び出します。"

#: ../../library/multiprocessing.rst:2561
msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those "
"objects in *object_list* which are ready.  If *timeout* is a float then the "
"call blocks for at most that many seconds.  If *timeout* is ``None`` then it "
"will block for an unlimited period. A negative timeout is equivalent to a "
"zero timeout."
msgstr ""
"*object_list* 中のオブジェクトが準備ができるまで待機します。準備ができた "
"*object_list* 中のオブジェクトのリストを返します。*timeout* が浮動小数点な"
"ら、最大でその秒数だけ呼び出しがブロックします。*timeout* が ``None`` の場"
"合、無制限の期間ブロックします。負のタイムアウトは0と等価です。"

#: ../../library/multiprocessing.rst:2567
msgid ""
"For both POSIX and Windows, an object can appear in *object_list* if it is"
msgstr ""

#: ../../library/multiprocessing.rst:2570
msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr ""
"読み取り可能な :class:`~multiprocessing.connection.Connection` オブジェクト;"

#: ../../library/multiprocessing.rst:2571
msgid "a connected and readable :class:`socket.socket` object; or"
msgstr "接続された読み取り可能な :class:`socket.socket` オブジェクト; または"

#: ../../library/multiprocessing.rst:2572
msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a :class:"
"`~multiprocessing.Process` object."
msgstr ""
":class:`~multiprocessing.Process` オブジェクトの :attr:`~multiprocessing."
"Process.sentinel` 属性。"

#: ../../library/multiprocessing.rst:2575
msgid ""
"A connection or socket object is ready when there is data available to be "
"read from it, or the other end has been closed."
msgstr ""
"読み取ることのできるデータがある場合、あるいは相手側の端が閉じられている場"
"合、コネクションまたはソケットオブジェクトは準備ができています。"

#: ../../library/multiprocessing.rst:2578
msgid ""
"**POSIX**: ``wait(object_list, timeout)`` almost equivalent ``select."
"select(object_list, [], [], timeout)``.  The difference is that, if :func:"
"`select.select` is interrupted by a signal, it can raise :exc:`OSError` with "
"an error number of ``EINTR``, whereas :func:`wait` will not."
msgstr ""

#: ../../library/multiprocessing.rst:2584
msgid ""
"**Windows**: An item in *object_list* must either be an integer handle which "
"is waitable (according to the definition used by the documentation of the "
"Win32 function ``WaitForMultipleObjects()``) or it can be an object with a :"
"meth:`~io.IOBase.fileno` method which returns a socket handle or pipe "
"handle.  (Note that pipe handles and socket handles are **not** waitable "
"handles.)"
msgstr ""

#: ../../library/multiprocessing.rst:2594
msgid "**Examples**"
msgstr "**例**"

#: ../../library/multiprocessing.rst:2596
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr ""
"次のサーバーコードは認証キーとして ``'secret password'`` を使用するリスナーを"
"作成します。このサーバーはコネクションを待ってクライアントへデータを送信しま"
"す::"

#: ../../library/multiprocessing.rst:2600
msgid ""
"from multiprocessing.connection import Listener\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)     # family is deduced to be 'AF_INET'\n"
"\n"
"with Listener(address, authkey=b'secret password') as listener:\n"
"    with listener.accept() as conn:\n"
"        print('connection accepted from', listener.last_accepted)\n"
"\n"
"        conn.send([2.25, None, 'junk', float])\n"
"\n"
"        conn.send_bytes(b'hello')\n"
"\n"
"        conn.send_bytes(array('i', [42, 1729]))"
msgstr ""

#: ../../library/multiprocessing.rst:2615
msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr "次のコードはサーバーへ接続して、サーバーからデータを受信します::"

#: ../../library/multiprocessing.rst:2618
msgid ""
"from multiprocessing.connection import Client\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)\n"
"\n"
"with Client(address, authkey=b'secret password') as conn:\n"
"    print(conn.recv())                  # => [2.25, None, 'junk', float]\n"
"\n"
"    print(conn.recv_bytes())            # => 'hello'\n"
"\n"
"    arr = array('i', [0, 0, 0, 0, 0])\n"
"    print(conn.recv_bytes_into(arr))    # => 8\n"
"    print(arr)                          # => array('i', [42, 1729, 0, 0, 0])"
msgstr ""

#: ../../library/multiprocessing.rst:2632
msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait for "
"messages from multiple processes at once::"
msgstr ""
"次のコードは :func:`~multiprocessing.connection.wait` を使って複数のプロセス"
"からのメッセージを同時に待ちます::"

#: ../../library/multiprocessing.rst:2635
msgid ""
"from multiprocessing import Process, Pipe, current_process\n"
"from multiprocessing.connection import wait\n"
"\n"
"def foo(w):\n"
"    for i in range(10):\n"
"        w.send((i, current_process().name))\n"
"    w.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    readers = []\n"
"\n"
"    for i in range(4):\n"
"        r, w = Pipe(duplex=False)\n"
"        readers.append(r)\n"
"        p = Process(target=foo, args=(w,))\n"
"        p.start()\n"
"        # We close the writable end of the pipe now to be sure that\n"
"        # p is the only process which owns a handle for it.  This\n"
"        # ensures that when p closes its handle for the writable end,\n"
"        # wait() will promptly report the readable end as being ready.\n"
"        w.close()\n"
"\n"
"    while readers:\n"
"        for r in wait(readers):\n"
"            try:\n"
"                msg = r.recv()\n"
"            except EOFError:\n"
"                readers.remove(r)\n"
"            else:\n"
"                print(msg)"
msgstr ""

#: ../../library/multiprocessing.rst:2670
msgid "Address Formats"
msgstr "アドレスフォーマット"

#: ../../library/multiprocessing.rst:2672
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr ""
"``'AF_INET'`` アドレスは ``(hostname, port)`` のタプルになります。 "
"*hostname* は文字列で *port* は整数です。"

#: ../../library/multiprocessing.rst:2675
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr "``'AF_UNIX'`` アドレスはファイルシステム上のファイル名の文字列です。"

#: ../../library/multiprocessing.rst:2678
msgid ""
"An ``'AF_PIPE'`` address is a string of the form :samp:`r'\\\\\\\\\\\\.\\"
"\\pipe\\\\\\\\{PipeName}'`.  To use :func:`Client` to connect to a named "
"pipe on a remote computer called *ServerName* one should use an address of "
"the form :samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\\\pipe\\\\\\\\{PipeName}'` "
"instead."
msgstr ""
"``'AF_PIPE'`` アドレスは :samp:`r'\\\\\\\\\\\\.\\\\pipe\\\\\\\\{PipeName}'` "
"という形式の文字列です。 *ServerName* という名前のリモートコンピューター上の"
"名前付きパイプに接続するために :func:`Client` を使用するには、代わりに :samp:"
"`r'\\\\\\\\\\\\\\\\{ServerName}\\\\pipe\\\\\\\\{PipeName}'` 形式のアドレスを"
"使用する必要があります。"

#: ../../library/multiprocessing.rst:2683
msgid ""
"Note that any string beginning with two backslashes is assumed by default to "
"be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr ""
"デフォルトでは、2つのバックスラッシュで始まる文字列は ``'AF_UNIX'`` よりも "
"``'AF_PIPE'`` として推測されることに注意してください。"

#: ../../library/multiprocessing.rst:2690
msgid "Authentication keys"
msgstr "認証キー"

#: ../../library/multiprocessing.rst:2692
msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data received "
"is automatically unpickled. Unfortunately unpickling data from an untrusted "
"source is a security risk. Therefore :class:`Listener` and :func:`Client` "
"use the :mod:`hmac` module to provide digest authentication."
msgstr ""
":meth:`Connection.recv <multiprocessing.Connection.recv>` を使用するとき、"
"データは自動的に unpickle されて受信します。 信頼できない接続元からのデータ"
"を unpickle することはセキュリティリスクがあります。 そのため :class:"
"`Listener` や :func:`Client` はダイジェスト認証を提供するために :mod:`hmac` "
"モジュールを使用します。"

#: ../../library/multiprocessing.rst:2698
msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof that "
"the other knows the authentication key.  (Demonstrating that both ends are "
"using the same key does **not** involve sending the key over the connection.)"
msgstr ""
"認証キーはパスワードとして見なされるバイト文字列です。コネクションが確立する"
"と、双方の終点で正しい接続先であることを証明するために 知っているお互いの認証"
"キーを要求します。(双方の終点が同じキーを使用して通信しようとしても、コネク"
"ション上でそのキーを送信することは **できません**。)"

#: ../../library/multiprocessing.rst:2704
msgid ""
"If authentication is requested but no authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see :class:"
"`~multiprocessing.Process`).  This value will be automatically inherited by "
"any :class:`~multiprocessing.Process` object that the current process "
"creates. This means that (by default) all processes of a multi-process "
"program will share a single authentication key which can be used when "
"setting up connections between themselves."
msgstr ""
"認証が要求されているにもかかわらず認証キーが指定されていない場合 "
"``current_process().authkey`` の返す値が使用されます。 (詳細は :class:"
"`~multiprocessing.Process` を参照してください。) この値はカレントプロセスを作"
"成する :class:`~multiprocessing.Process` オブジェクトによって自動的に継承され"
"ます。 これは(デフォルトでは)複数プロセスのプログラムの全プロセスが相互にコネ"
"クションを 確立するときに使用される1つの認証キーを共有することを意味します。"

#: ../../library/multiprocessing.rst:2712
msgid ""
"Suitable authentication keys can also be generated by using :func:`os."
"urandom`."
msgstr "適当な認証キーを :func:`os.urandom` を使用して生成することもできます。"

#: ../../library/multiprocessing.rst:2716
msgid "Logging"
msgstr "ログ記録"

#: ../../library/multiprocessing.rst:2718
msgid ""
"Some support for logging is available.  Note, however, that the :mod:"
"`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get "
"mixed up."
msgstr ""
"ロギングのためにいくつかの機能が利用可能です。しかし :mod:`logging` パッケー"
"ジは、 (ハンドラー種別に依存して)違うプロセスからのメッセージがごちゃ混ぜにな"
"るので、プロセスの共有ロックを使用しないことに注意してください。"

#: ../../library/multiprocessing.rst:2725
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr ""
":mod:`multiprocessing` が使用するロガーを返します。必要に応じて新たなロガーを"
"作成します。"

#: ../../library/multiprocessing.rst:2728
msgid ""
"When first created the logger has level :const:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr ""

#: ../../library/multiprocessing.rst:2732
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be "
"inherited."
msgstr ""
"Windows 上では子プロセスが親プロセスのロガーレベルを継承しないことに注意して"
"ください。さらにその他のロガーのカスタマイズ内容もすべて継承されません。"

#: ../../library/multiprocessing.rst:2739
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s] "
"%(message)s'``. You can modify ``levelname`` of the logger by passing a "
"``level`` argument."
msgstr ""
"この関数は :func:`get_logger` に対する呼び出しを実行しますが、 get_logger に"
"よって作成されるロガーを返すことに加えて、 ``'[%(levelname)s/"
"%(processName)s] %(message)s'`` のフォーマットを使用して :data:`sys.stderr` "
"へ出力を送るハンドラーを追加します。``level`` 引数を渡すことによってロガーの "
"``levelname`` を変更できます。"

#: ../../library/multiprocessing.rst:2745
msgid "Below is an example session with logging turned on::"
msgstr "以下にロギングを有効にした例を紹介します::"

#: ../../library/multiprocessing.rst:2747
msgid ""
">>> import multiprocessing, logging\n"
">>> logger = multiprocessing.log_to_stderr()\n"
">>> logger.setLevel(logging.INFO)\n"
">>> logger.warning('doomed')\n"
"[WARNING/MainProcess] doomed\n"
">>> m = multiprocessing.Manager()\n"
"[INFO/SyncManager-...] child process calling self.run()\n"
"[INFO/SyncManager-...] created temp directory /.../pymp-...\n"
"[INFO/SyncManager-...] manager serving at '/.../listener-...'\n"
">>> del m\n"
"[INFO/MainProcess] sending shutdown message to manager\n"
"[INFO/SyncManager-...] manager exiting with exitcode 0"
msgstr ""

#: ../../library/multiprocessing.rst:2760
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr ""
"完全なロギングレベルの表については :mod:`logging` モジュールを参照してくださ"
"い。"

#: ../../library/multiprocessing.rst:2764
msgid "The :mod:`multiprocessing.dummy` module"
msgstr ":mod:`multiprocessing.dummy` モジュール"

#: ../../library/multiprocessing.rst:2769
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ""
":mod:`multiprocessing.dummy` は :mod:`multiprocessing` の API を複製します"
"が :mod:`threading` モジュールのラッパーでしかありません。"

#: ../../library/multiprocessing.rst:2774
msgid ""
"In particular, the ``Pool`` function provided by :mod:`multiprocessing."
"dummy` returns an instance of :class:`ThreadPool`, which is a subclass of :"
"class:`Pool` that supports all the same method calls but uses a pool of "
"worker threads rather than worker processes."
msgstr ""

#: ../../library/multiprocessing.rst:2782
msgid ""
"A thread pool object which controls a pool of worker threads to which jobs "
"can be submitted.  :class:`ThreadPool` instances are fully interface "
"compatible with :class:`Pool` instances, and their resources must also be "
"properly managed, either by using the pool as a context manager or by "
"calling :meth:`~multiprocessing.pool.Pool.close` and :meth:`~multiprocessing."
"pool.Pool.terminate` manually."
msgstr ""

#: ../../library/multiprocessing.rst:2789
msgid ""
"*processes* is the number of worker threads to use.  If *processes* is "
"``None`` then the number returned by :func:`os.process_cpu_count` is used."
msgstr ""

#: ../../library/multiprocessing.rst:2795
msgid ""
"Unlike :class:`Pool`, *maxtasksperchild* and *context* cannot be provided."
msgstr ""

#: ../../library/multiprocessing.rst:2799
msgid ""
"A :class:`ThreadPool` shares the same interface as :class:`Pool`, which is "
"designed around a pool of processes and predates the introduction of the :"
"class:`concurrent.futures` module.  As such, it inherits some operations "
"that don't make sense for a pool backed by threads, and it has its own type "
"for representing the status of asynchronous jobs, :class:`AsyncResult`, that "
"is not understood by any other libraries."
msgstr ""

#: ../../library/multiprocessing.rst:2806
msgid ""
"Users should generally prefer to use :class:`concurrent.futures."
"ThreadPoolExecutor`, which has a simpler interface that was designed around "
"threads from the start, and which returns :class:`concurrent.futures.Future` "
"instances that are compatible with many other libraries, including :mod:"
"`asyncio`."
msgstr ""

#: ../../library/multiprocessing.rst:2816
msgid "Programming guidelines"
msgstr "プログラミングガイドライン"

#: ../../library/multiprocessing.rst:2818
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ""
":mod:`multiprocessing` を使用するときに守るべき一定のガイドラインとイディオム"
"を挙げます。"

#: ../../library/multiprocessing.rst:2823
msgid "All start methods"
msgstr "すべての開始方式について"

#: ../../library/multiprocessing.rst:2825
msgid "The following applies to all start methods."
msgstr "以下はすべての開始方式に当てはまります。"

#: ../../library/multiprocessing.rst:2827
msgid "Avoid shared state"
msgstr "共有状態を避ける"

#: ../../library/multiprocessing.rst:2829
msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr ""
"できるだけプロセス間で巨大なデータを移動することは避けるようにすべきです。"

#: ../../library/multiprocessing.rst:2832
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr ""
"プロセス間の通信には、:mod:`threading` モジュールの低レベルな同期プリミティブ"
"を使うのではなく、キューやパイプを使うのが良いでしょう。"

#: ../../library/multiprocessing.rst:2836
msgid "Picklability"
msgstr "pickle 化の可能性"

#: ../../library/multiprocessing.rst:2838
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr "プロキシのメソッドへの引数は、 pickle 化できるものにしてください。"

#: ../../library/multiprocessing.rst:2840
msgid "Thread safety of proxies"
msgstr "プロキシのスレッドセーフ性"

#: ../../library/multiprocessing.rst:2842
msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr ""
"1 つのプロキシオブジェクトは、ロックで保護しないかぎり、2 つ以上のスレッドか"
"ら使用してはいけません。"

#: ../../library/multiprocessing.rst:2845
msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr "(異なるプロセスで *同じ* プロキシを使用することは問題ではありません。)"

#: ../../library/multiprocessing.rst:2847
msgid "Joining zombie processes"
msgstr "ゾンビプロセスを join する"

#: ../../library/multiprocessing.rst:2849
msgid ""
"On POSIX when a process finishes but has not been joined it becomes a "
"zombie. There should never be very many because each time a new process "
"starts (or :func:`~multiprocessing.active_children` is called) all completed "
"processes which have not yet been joined will be joined.  Also calling a "
"finished process's :meth:`Process.is_alive <multiprocessing.Process."
"is_alive>` will join the process.  Even so it is probably good practice to "
"explicitly join all the processes that you start."
msgstr ""

#: ../../library/multiprocessing.rst:2857
msgid "Better to inherit than pickle/unpickle"
msgstr "pickle/unpickle より継承する方が良い"

#: ../../library/multiprocessing.rst:2859
msgid ""
"When using the *spawn* or *forkserver* start methods many types from :mod:"
"`multiprocessing` need to be picklable so that child processes can use "
"them.  However, one should generally avoid sending shared objects to other "
"processes using pipes or queues. Instead you should arrange the program so "
"that a process which needs access to a shared resource created elsewhere can "
"inherit it from an ancestor process."
msgstr ""
"開始方式に *spawn* あるいは *forkserver* を使用している場合、:mod:"
"`multiprocessing` から多くの型を pickle 化する必要があるため子プロセスはそれ"
"らを使うことができます。しかし、一般にパイプやキューを使用して共有オブジェク"
"トを他のプロセスに送信することは避けるべきです。代わりに、共有リソースにアク"
"セスする必要のあるプロセスは上位プロセスからそれらを継承するようにすべきで"
"す。"

#: ../../library/multiprocessing.rst:2867
msgid "Avoid terminating processes"
msgstr "プロセスの強制終了を避ける"

#: ../../library/multiprocessing.rst:2869
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr ""
"あるプロセスを停止するために :meth:`Process.terminate <multiprocessing."
"Process.terminate>` メソッドを使用すると、そのプロセスが現在使用されている "
"(ロック、セマフォ、パイプやキューのような) 共有リソースを破壊したり他のプロセ"
"スから利用できない状態を引き起こし易いです。"

#: ../../library/multiprocessing.rst:2875
msgid ""
"Therefore it is probably best to only consider using :meth:`Process."
"terminate <multiprocessing.Process.terminate>` on processes which never use "
"any shared resources."
msgstr ""
"そのため、共有リソースを使用しないプロセスでのみ :meth:`Process.terminate "
"<multiprocessing.Process.terminate>` を使用することを考慮することがおそらく最"
"善の方法です。"

#: ../../library/multiprocessing.rst:2879
msgid "Joining processes that use queues"
msgstr "キューを使用するプロセスを join する"

#: ../../library/multiprocessing.rst:2881
msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to "
"the underlying pipe.  (The child process can call the :meth:`Queue."
"cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` method of the "
"queue to avoid this behaviour.)"
msgstr ""
"キューに要素を追加するプロセスは、すべてのバッファーされた要素が \"feeder\" "
"スレッドによって下位層のパイプに対してフィードされるまで終了を待つということ"
"を覚えておいてください。 (子プロセスはこの動作を避けるためにキューの :meth:"
"`Queue.cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` メソッ"
"ドを呼ぶことができます。)"

#: ../../library/multiprocessing.rst:2887
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the "
"process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr ""
"これはキューを使用するときに、キューに追加されたすべての要素が最終的にそのプ"
"ロセスが join される前に削除されていることを確認する必要があることを意味しま"
"す。そうしないと、そのキューに要素が追加したプロセスの終了を保証できません。"
"デーモンではないプロセスは自動的に join されることも覚えておいてください。"

#: ../../library/multiprocessing.rst:2893
msgid "An example which will deadlock is the following::"
msgstr "次の例はデッドロックを引き起こします::"

#: ../../library/multiprocessing.rst:2895
msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put('X' * 1000000)\n"
"\n"
"if __name__ == '__main__':\n"
"    queue = Queue()\n"
"    p = Process(target=f, args=(queue,))\n"
"    p.start()\n"
"    p.join()                    # this deadlocks\n"
"    obj = queue.get()"
msgstr ""

#: ../../library/multiprocessing.rst:2907
msgid ""
"A fix here would be to swap the last two lines (or simply remove the ``p."
"join()`` line)."
msgstr ""
"修正するには最後の2行を入れ替えます(または単純に ``p.join()`` の行を削除しま"
"す)。"

#: ../../library/multiprocessing.rst:2910
msgid "Explicitly pass resources to child processes"
msgstr "明示的に子プロセスへリソースを渡す"

#: ../../library/multiprocessing.rst:2912
msgid ""
"On POSIX using the *fork* start method, a child process can make use of a "
"shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the constructor "
"for the child process."
msgstr ""

#: ../../library/multiprocessing.rst:2917
msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process is "
"still alive the object will not be garbage collected in the parent process.  "
"This might be important if some resource is freed when the object is garbage "
"collected in the parent process."
msgstr ""
"Windows や他の開始方式と (将来的にでも) 互換性のあるコードを書く場合は別とし"
"て、これは子プロセスが実行中である限りは親プロセス内でオブジェクトがガベージ"
"コレクトされないことも保証します。これは親プロセス内でオブジェクトがガベージ"
"コレクトされたときに一部のリソースが開放されてしまう場合に重要かもしれませ"
"ん。"

#: ../../library/multiprocessing.rst:2924
msgid "So for instance ::"
msgstr "そのため、例えば ::"

#: ../../library/multiprocessing.rst:2926
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f():\n"
"    ... do something using \"lock\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f).start()"
msgstr ""

#: ../../library/multiprocessing.rst:2936
msgid "should be rewritten as ::"
msgstr "は、次のように書き直すべきです ::"

#: ../../library/multiprocessing.rst:2938
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l):\n"
"    ... do something using \"l\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f, args=(lock,)).start()"
msgstr ""

#: ../../library/multiprocessing.rst:2948
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr ":data:`sys.stdin` を file-like オブジェクトに置き換えることに注意する"

#: ../../library/multiprocessing.rst:2950
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ":mod:`multiprocessing` は元々無条件に::"

#: ../../library/multiprocessing.rst:2952
msgid "os.close(sys.stdin.fileno())"
msgstr ""

#: ../../library/multiprocessing.rst:2954
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr ""
"を :meth:`multiprocessing.Process._bootstrap` メソッドの中で呼び出していまし"
"た --- これはプロセス内プロセス (processes-in-processes) で問題が起こしてしま"
"います。そこで、これは以下のように変更されました::"

#: ../../library/multiprocessing.rst:2957
msgid ""
"sys.stdin.close()\n"
"sys.stdin = open(os.open(os.devnull, os.O_RDONLY), closefd=False)"
msgstr ""

#: ../../library/multiprocessing.rst:2960
msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call :meth:"
"`~io.IOBase.close` on this file-like object, it could result in the same "
"data being flushed to the object multiple times, resulting in corruption."
msgstr ""

#: ../../library/multiprocessing.rst:2967
msgid ""
"If you write a file-like object and implement your own caching, you can make "
"it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr ""
"もし file-like オブジェクトを書いて独自のキャッシュを実装するなら、キャッシュ"
"するときに常に pid を記録しておき、pid が変わったらキュッシュを捨てることで、"
"フォークセーフにできます。例::"

#: ../../library/multiprocessing.rst:2971
msgid ""
"@property\n"
"def cache(self):\n"
"    pid = os.getpid()\n"
"    if pid != self._pid:\n"
"        self._pid = pid\n"
"        self._cache = []\n"
"    return self._cache"
msgstr ""

#: ../../library/multiprocessing.rst:2979
msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr ""
"より詳しい情報は :issue:`5155` 、 :issue:`5313` 、 :issue:`5331` を見てくださ"
"い"

#: ../../library/multiprocessing.rst:2982
msgid "The *spawn* and *forkserver* start methods"
msgstr "開始方式が *spawn* および *forkserver* の場合"

#: ../../library/multiprocessing.rst:2984
msgid ""
"There are a few extra restrictions which don't apply to the *fork* start "
"method."
msgstr ""

#: ../../library/multiprocessing.rst:2987
msgid "More picklability"
msgstr "さらなる pickle 化の可能性"

#: ../../library/multiprocessing.rst:2989
msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable. Also, "
"if you subclass :class:`~multiprocessing.Process` then make sure that "
"instances will be picklable when the :meth:`Process.start <multiprocessing."
"Process.start>` method is called."
msgstr ""
":meth:`Process.__init__` へのすべての引数は pickle 化できることを確認してくだ"
"さい。また :class:`~multiprocessing.Process` をサブクラス化する場合、そのイン"
"スタンスが :meth:`Process.start <multiprocessing.Process.start>` メソッドが呼"
"ばれたときに pickle 化できるようにしてください。"

#: ../../library/multiprocessing.rst:2994
msgid "Global variables"
msgstr "グローバル変数"

#: ../../library/multiprocessing.rst:2996
msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start <multiprocessing."
"Process.start>` was called."
msgstr ""
"子プロセスで実行されるコードがグローバル変数にアクセスしようとする場合、子プ"
"ロセスが見るその値は :meth:`Process.start <multiprocessing.Process.start>` が"
"呼ばれたときの親プロセスの値と同じではない可能性があります。"

#: ../../library/multiprocessing.rst:3001
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr ""
"しかし、単にモジュールレベルの定数であるグローバル変数なら問題にはなりませ"
"ん。"

#: ../../library/multiprocessing.rst:3006
msgid "Safe importing of main module"
msgstr "メインモジュールの安全なインポート"

#: ../../library/multiprocessing.rst:3008
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such as starting a new "
"process)."
msgstr ""

#: ../../library/multiprocessing.rst:3012
msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr ""
"例えば、開始方式に *spawn* あるいは *forkserver* を使用した場合に以下のモ"
"ジュールを実行すると :exc:`RuntimeError` で失敗します::"

#: ../../library/multiprocessing.rst:3016
msgid ""
"from multiprocessing import Process\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"p = Process(target=foo)\n"
"p.start()"
msgstr ""

#: ../../library/multiprocessing.rst:3024
msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr ""
"代わりに、次のように ``if __name__ == '__main__':`` を使用してプログラムの "
"\"エントリポイント\" を保護すべきです::"

#: ../../library/multiprocessing.rst:3027
msgid ""
"from multiprocessing import Process, freeze_support, set_start_method\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    set_start_method('spawn')\n"
"    p = Process(target=foo)\n"
"    p.start()"
msgstr ""

#: ../../library/multiprocessing.rst:3038
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr ""
"(プログラムをフリーズせずに通常通り実行するなら ``freeze_support()`` 行は取り"
"除けます。)"

#: ../../library/multiprocessing.rst:3041
msgid ""
"This allows the newly spawned Python interpreter to safely import the module "
"and then run the module's ``foo()`` function."
msgstr ""
"これは新たに生成された Python インタープリターがそのモジュールを安全にイン"
"ポートして、モジュールの ``foo()`` 関数を実行します。"

#: ../../library/multiprocessing.rst:3044
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr ""
"プールまたはマネージャーがメインモジュールで作成される場合に似たような制限が"
"適用されます。"

#: ../../library/multiprocessing.rst:3051
msgid "Examples"
msgstr "使用例"

#: ../../library/multiprocessing.rst:3053
msgid "Demonstration of how to create and use customized managers and proxies:"
msgstr ""
"カスタマイズされたマネージャーやプロキシの作成方法と使用方法を紹介します:"

#: ../../library/multiprocessing.rst:3055
msgid ""
"from multiprocessing import freeze_support\n"
"from multiprocessing.managers import BaseManager, BaseProxy\n"
"import operator\n"
"\n"
"##\n"
"\n"
"class Foo:\n"
"    def f(self):\n"
"        print('you called Foo.f()')\n"
"    def g(self):\n"
"        print('you called Foo.g()')\n"
"    def _h(self):\n"
"        print('you called Foo._h()')\n"
"\n"
"# A simple generator function\n"
"def baz():\n"
"    for i in range(10):\n"
"        yield i*i\n"
"\n"
"# Proxy type for generator objects\n"
"class GeneratorProxy(BaseProxy):\n"
"    _exposed_ = ['__next__']\n"
"    def __iter__(self):\n"
"        return self\n"
"    def __next__(self):\n"
"        return self._callmethod('__next__')\n"
"\n"
"# Function to return the operator module\n"
"def get_operator_module():\n"
"    return operator\n"
"\n"
"##\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"# register the Foo class; make `f()` and `g()` accessible via proxy\n"
"MyManager.register('Foo1', Foo)\n"
"\n"
"# register the Foo class; make `g()` and `_h()` accessible via proxy\n"
"MyManager.register('Foo2', Foo, exposed=('g', '_h'))\n"
"\n"
"# register the generator function baz; use `GeneratorProxy` to make proxies\n"
"MyManager.register('baz', baz, proxytype=GeneratorProxy)\n"
"\n"
"# register get_operator_module(); make public functions accessible via "
"proxy\n"
"MyManager.register('operator', get_operator_module)\n"
"\n"
"##\n"
"\n"
"def test():\n"
"    manager = MyManager()\n"
"    manager.start()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f1 = manager.Foo1()\n"
"    f1.f()\n"
"    f1.g()\n"
"    assert not hasattr(f1, '_h')\n"
"    assert sorted(f1._exposed_) == sorted(['f', 'g'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f2 = manager.Foo2()\n"
"    f2.g()\n"
"    f2._h()\n"
"    assert not hasattr(f2, 'f')\n"
"    assert sorted(f2._exposed_) == sorted(['g', '_h'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    it = manager.baz()\n"
"    for i in it:\n"
"        print('<%d>' % i, end=' ')\n"
"    print()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    op = manager.operator()\n"
"    print('op.add(23, 45) =', op.add(23, 45))\n"
"    print('op.pow(2, 94) =', op.pow(2, 94))\n"
"    print('op._exposed_ =', op._exposed_)\n"
"\n"
"##\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""

#: ../../library/multiprocessing.rst:3059
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr ":class:`~multiprocessing.pool.Pool` を使用する例です:"

#: ../../library/multiprocessing.rst:3061
msgid ""
"import multiprocessing\n"
"import time\n"
"import random\n"
"import sys\n"
"\n"
"#\n"
"# Functions used by test code\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % (\n"
"        multiprocessing.current_process().name,\n"
"        func.__name__, args, result\n"
"        )\n"
"\n"
"def calculatestar(args):\n"
"    return calculate(*args)\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a + b\n"
"\n"
"def f(x):\n"
"    return 1.0 / (x - 5.0)\n"
"\n"
"def pow3(x):\n"
"    return x ** 3\n"
"\n"
"def noop(x):\n"
"    pass\n"
"\n"
"#\n"
"# Test code\n"
"#\n"
"\n"
"def test():\n"
"    PROCESSES = 4\n"
"    print('Creating pool with %d processes\\n' % PROCESSES)\n"
"\n"
"    with multiprocessing.Pool(PROCESSES) as pool:\n"
"        #\n"
"        # Tests\n"
"        #\n"
"\n"
"        TASKS = [(mul, (i, 7)) for i in range(10)] + \\\n"
"                [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"        results = [pool.apply_async(calculate, t) for t in TASKS]\n"
"        imap_it = pool.imap(calculatestar, TASKS)\n"
"        imap_unordered_it = pool.imap_unordered(calculatestar, TASKS)\n"
"\n"
"        print('Ordered results using pool.apply_async():')\n"
"        for r in results:\n"
"            print('\\t', r.get())\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.imap():')\n"
"        for x in imap_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Unordered results using pool.imap_unordered():')\n"
"        for x in imap_unordered_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.map() --- will block till "
"complete:')\n"
"        for x in pool.map(calculatestar, TASKS):\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        #\n"
"        # Test error handling\n"
"        #\n"
"\n"
"        print('Testing error handling:')\n"
"\n"
"        try:\n"
"            print(pool.apply(f, (5,)))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.apply()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(pool.map(f, list(range(10))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.map()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(list(pool.imap(f, list(range(10)))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from list(pool."
"imap())')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        it = pool.imap(f, list(range(10)))\n"
"        for i in range(10):\n"
"            try:\n"
"                x = next(it)\n"
"            except ZeroDivisionError:\n"
"                if i == 5:\n"
"                    pass\n"
"            except StopIteration:\n"
"                break\n"
"            else:\n"
"                if i == 5:\n"
"                    raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        assert i == 9\n"
"        print('\\tGot ZeroDivisionError as expected from IMapIterator."
"next()')\n"
"        print()\n"
"\n"
"        #\n"
"        # Testing timeouts\n"
"        #\n"
"\n"
"        print('Testing ApplyResult.get() with timeout:', end=' ')\n"
"        res = pool.apply_async(calculate, TASKS[0])\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % res.get(0.02))\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"        print('Testing IMapIterator.next() with timeout:', end=' ')\n"
"        it = pool.imap(calculatestar, TASKS)\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % it.next(0.02))\n"
"            except StopIteration:\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    multiprocessing.freeze_support()\n"
"    test()\n"
msgstr ""

#: ../../library/multiprocessing.rst:3065
msgid ""
"An example showing how to use queues to feed tasks to a collection of worker "
"processes and collect the results:"
msgstr ""
"ワーカープロセスのコレクションに対してタスクをフィードしてその結果をまとめる"
"キューの使い方の例を紹介します:"

#: ../../library/multiprocessing.rst:3068
msgid ""
"import time\n"
"import random\n"
"\n"
"from multiprocessing import Process, Queue, current_process, freeze_support\n"
"\n"
"#\n"
"# Function run by worker processes\n"
"#\n"
"\n"
"def worker(input, output):\n"
"    for func, args in iter(input.get, 'STOP'):\n"
"        result = calculate(func, args)\n"
"        output.put(result)\n"
"\n"
"#\n"
"# Function used to calculate result\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % \\\n"
"        (current_process().name, func.__name__, args, result)\n"
"\n"
"#\n"
"# Functions referenced by tasks\n"
"#\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a + b\n"
"\n"
"#\n"
"#\n"
"#\n"
"\n"
"def test():\n"
"    NUMBER_OF_PROCESSES = 4\n"
"    TASKS1 = [(mul, (i, 7)) for i in range(20)]\n"
"    TASKS2 = [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"    # Create queues\n"
"    task_queue = Queue()\n"
"    done_queue = Queue()\n"
"\n"
"    # Submit tasks\n"
"    for task in TASKS1:\n"
"        task_queue.put(task)\n"
"\n"
"    # Start worker processes\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        Process(target=worker, args=(task_queue, done_queue)).start()\n"
"\n"
"    # Get and print results\n"
"    print('Unordered results:')\n"
"    for i in range(len(TASKS1)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Add more tasks using `put()`\n"
"    for task in TASKS2:\n"
"        task_queue.put(task)\n"
"\n"
"    # Get and print some more results\n"
"    for i in range(len(TASKS2)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Tell child processes to stop\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        task_queue.put('STOP')\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""
