# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-14 13:51+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ctypes.rst:2
msgid ":mod:`ctypes` --- A foreign function library for Python"
msgstr ":mod:`ctypes` --- Pythonã®ãŸã‚ã®å¤–éƒ¨é–¢æ•°ãƒ©ã‚¤ãƒ–ãƒ©ãƒª"

#: ../../library/ctypes.rst:11
msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ""
":mod:`ctypes` ã¯ Python ã®ãŸã‚ã®å¤–éƒ¨é–¢æ•°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ C "
"ã¨äº’æ›æ€§ã®ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿å‹ã‚’æä¾›ã—ã€å‹•çš„ãƒªãƒ³ã‚¯/å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå†…ã®é–¢æ•°å‘¼ã³å‡ºã—ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚å‹•çš„ãƒªãƒ³ã‚¯/å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ç´”ç²‹ãª Python "
"ã§ãƒ©ãƒƒãƒ—ã™ã‚‹ãŸã‚ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ctypes.rst:19
msgid "ctypes tutorial"
msgstr "ctypesãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«"

#: ../../library/ctypes.rst:21
msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure that"
" they actually work.  Since some code samples behave differently under "
"Linux, Windows, or Mac OS X, they contain doctest directives in comments."
msgstr ""
"æ³¨æ„: ã“ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã‚µãƒ³ãƒ—ãƒ«ã¯å‹•ä½œç¢ºèªã®ãŸã‚ã« :mod:`doctest` ã‚’ä½¿ã„ã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ã‚µãƒ³ãƒ—ãƒ«ã®ä¸­ã«ã¯ Linuxã€ "
"Windowsã€ã‚ã‚‹ã„ã¯ Mac OS X ä¸Šã§ç•°ãªã‚‹å‹•ä½œã‚’ã™ã‚‹ã‚‚ã®ãŒã‚ã‚‹ãŸã‚ã€ã‚µãƒ³ãƒ—ãƒ«ã®ã‚³ãƒ¡ãƒ³ãƒˆã« doctest å‘½ä»¤ã‚’å…¥ã‚Œã¦ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:25
msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type.  On "
"platforms where ``sizeof(long) == sizeof(int)`` it is an alias to "
":class:`c_long`. So, you should not be confused if :class:`c_long` is "
"printed if you would expect :class:`c_int` --- they are actually the same "
"type."
msgstr ""
"æ³¨æ„: ã„ãã¤ã‹ã®ã‚³ãƒ¼ãƒ‰ã‚µãƒ³ãƒ—ãƒ«ã§ ctypes ã® :class:`c_int` å‹ã‚’å‚ç…§ã—ã¦ã„ã¾ã™ã€‚ ``sizeof(long) == "
"sizeof(int)`` ã§ã‚ã‚‹ã‚ˆã†ãªãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€ã“ã®å‹ã¯ :class:`c_long` ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã™ã€‚ãã®ãŸã‚ã€ "
":class:`c_int` å‹ã‚’æƒ³å®šã—ã¦ã„ã‚‹ã¨ãã« :class:`c_long` ãŒè¡¨ç¤ºã•ã‚ŒãŸã¨ã—ã¦ã‚‚ã€æ··ä¹±ã—ãªã„ã‚ˆã†ã«ã—ã¦ãã ã•ã„ --- "
"å®Ÿéš›ã«ã¯åŒã˜å‹ãªã®ã§ã™ã€‚"

#: ../../library/ctypes.rst:33
msgid "Loading dynamic link libraries"
msgstr "å‹•çš„ãƒªãƒ³ã‚¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹"

#: ../../library/ctypes.rst:35
msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ""
"å‹•çš„ãƒªãƒ³ã‚¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã«ã€ :mod:`ctypes` ã¯ *cdll* ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ Windows ã§ã¯ *windll* "
"ã¨ *oledll* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:38
msgid ""
"You load libraries by accessing them as attributes of these objects. *cdll* "
"loads libraries which export functions using the standard ``cdecl`` calling "
"convention, while *windll* libraries call functions using the ``stdcall`` "
"calling convention. *oledll* also uses the ``stdcall`` calling convention, "
"and assumes the functions return a Windows :c:type:`HRESULT` error code. The"
" error code is used to automatically raise an :class:`OSError` exception "
"when the function call fails."
msgstr ""
"ã“ã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§ã¨ã—ã¦ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã§ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ *cdll* ã¯ã€æ¨™æº– ``cdecl`` "
"å‘¼ã³å‡ºã—è¦ç´„ã‚’ç”¨ã„ã¦é–¢æ•°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ãã‚Œã«å¯¾ã—ã¦ã€ *windll* ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ ``stdcall`` "
"å‘¼ã³å‡ºã—è¦ç´„ã‚’ç”¨ã„ã‚‹é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ *oledll* ã‚‚ ``stdcall`` å‘¼ã³å‡ºã—è¦ç´„ã‚’ä½¿ã„ã¾ã™ãŒã€é–¢æ•°ãŒ Windows "
":c:type:`HRESULT` ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã‚’è¿”ã™ã“ã¨ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚ã“ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã¯é–¢æ•°å‘¼ã³å‡ºã—ãŒå¤±æ•—ã—ãŸã¨ãã€ "
":class:`OSError` ä¾‹å¤–ã‚’è‡ªå‹•çš„ã«é€å‡ºã•ã›ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:46
msgid ""
"Windows errors used to raise :exc:`WindowsError`, which is now an alias of "
":exc:`OSError`."
msgstr ""
"Windows ã‚¨ãƒ©ãƒ¼ã¯ä»¥å‰ã¯ :exc:`WindowsError` ã‚’é€å‡ºã—ã¦ã„ã¾ã—ãŸãŒã€ã“ã‚Œã¯ç¾åœ¨ã§ã¯ :exc:`OSError` "
"ã®åˆ¥åã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/ctypes.rst:51
msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS standard "
"C library containing most standard C functions, and uses the cdecl calling "
"convention::"
msgstr ""
"Windowsç”¨ã®ä¾‹ã§ã™ãŒã€ ``msvcrt`` ã¯ã»ã¨ã‚“ã©ã®æ¨™æº– C é–¢æ•°ãŒå«ã¾ã‚Œã¦ã„ã‚‹ MS æ¨™æº– C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã‚ã‚Šã€ cdecl "
"å‘¼ã³å‡ºã—è¦ç´„ã‚’ä½¿ã†ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„::"

#: ../../library/ctypes.rst:63
msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr "Windows ã§ã¯é€šå¸¸ã® ``.dll`` ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‚’è‡ªå‹•çš„ã«è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:66
msgid ""
"Accessing the standard C library through ``cdll.msvcrt`` will use an "
"outdated version of the library that may be incompatible with the one being "
"used by Python. Where possible, use native Python functionality, or else "
"import and use the ``msvcrt`` module."
msgstr ""
"``cdll.msvcrt`` çµŒç”±ã§æ¨™æº– C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ã€Python "
"ãŒä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ã¯äº’æ›æ€§ã®ãªã„å¯èƒ½æ€§ã®ã‚ã‚‹ã€å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚å¯èƒ½ãªå ´åˆã«ã¯ã€ãƒã‚¤ãƒ†ã‚£ãƒ– Python "
"ã®æ©Ÿèƒ½ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã€``msvcrt`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ctypes.rst:71
msgid ""
"On Linux, it is required to specify the filename *including* the extension "
"to load a library, so attribute access can not be used to load libraries. "
"Either the :meth:`LoadLibrary` method of the dll loaders should be used, or "
"you should load the library by creating an instance of CDLL by calling the "
"constructor::"
msgstr ""
"Linux ã§ã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã«æ‹¡å¼µå­ã‚’ *å«ã‚€* "
"ãƒ•ã‚¡ã‚¤ãƒ«åã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§ã€ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å¯¾ã™ã‚‹å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã¯ã§ãã¾ã›ã‚“ã€‚ dll ãƒ­ãƒ¼ãƒ€ãƒ¼ã® :meth:`LoadLibrary` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã‹ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å‘¼ã³å‡ºã—ã¦ CDLL ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚‹ã“ã¨ã§ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‹ã®ã©ã¡ã‚‰ã‹ã‚’è¡Œã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“::"

#: ../../library/ctypes.rst:89
msgid "Accessing functions from loaded dlls"
msgstr "ãƒ­ãƒ¼ãƒ‰ã—ãŸdllã‹ã‚‰é–¢æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹"

#: ../../library/ctypes.rst:91
msgid "Functions are accessed as attributes of dll objects::"
msgstr "dll ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±æ€§ã¨ã—ã¦é–¢æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™::"

#: ../../library/ctypes.rst:106
msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export "
"ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with an ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 ``GetModuleHandle`` "
"function, which returns a *module handle* for a given module name, has the "
"following C prototype, and a macro is used to expose one of them as "
"``GetModuleHandle`` depending on whether UNICODE is defined or not::"
msgstr ""
"``kernel32`` ã‚„ ``user32`` ã®ã‚ˆã†ãª win32 ã‚·ã‚¹ãƒ†ãƒ  dll ã¯ã€å¤šãã®å ´åˆé–¢æ•°ã® UNICODE ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«åŠ ãˆã¦ "
"ANSI ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚‚ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ UNICODE ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯å¾Œã‚ã« ``W`` ãŒä»˜ã„ãŸåå‰ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚Œã€ "
"ANSI ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ ``A`` ãŒä»˜ã„ãŸåå‰ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚ä¸ãˆã‚‰ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® *ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒãƒ³ãƒ‰ãƒ«* ã‚’è¿”ã™ win32 "
"``GetModuleHandle`` é–¢æ•°ã¯æ¬¡ã®ã‚ˆã†ãª C ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ã‚’æŒã¡ã¾ã™ã€‚ UNICODE ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã«ã‚ˆã‚Š "
"``GetModuleHandle`` ã¨ã—ã¦ã©ã¡ã‚‰ã‹ä¸€ã¤ã‚’å…¬é–‹ã™ã‚‹ãŸã‚ã«ãƒã‚¯ãƒ­ãŒä½¿ã‚ã‚Œã¾ã™::"

#: ../../library/ctypes.rst:119
msgid ""
"*windll* does not try to select one of them by magic, you must access the "
"version you need by specifying ``GetModuleHandleA`` or ``GetModuleHandleW`` "
"explicitly, and then call it with bytes or string objects respectively."
msgstr ""
"*windll* ã¯é­”æ³•ã‚’ä½¿ã£ã¦ã©ã¡ã‚‰ã‹ä¸€ã¤ã‚’é¸ã¶ã‚ˆã†ãªã“ã¨ã¯ã—ã¾ã›ã‚“ã€‚``GetModuleHandleA`` ã‚‚ã—ãã¯ "
"``GetModuleHandleW`` "
"ã‚’æ˜ç¤ºçš„ã«æŒ‡å®šã—ã¦å¿…è¦ã¨ã™ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€ãƒã‚¤ãƒˆåˆ—ã‹æ–‡å­—åˆ—ã‚’ä½¿ã£ã¦ãã‚Œãã‚Œå‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:123
msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use "
":func:`getattr` to retrieve the function::"
msgstr ""
"æ™‚ã«ã¯ã€ dll ãŒé–¢æ•°ã‚’ ``\"??2@YAPAXI@Z\"`` ã®ã‚ˆã†ãª Python "
"è­˜åˆ¥å­ã¨ã—ã¦æœ‰åŠ¹ã§ãªã„åå‰ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚ˆã†ãªå ´åˆã«é–¢æ•°ã‚’å–ã‚Šå‡ºã™ã«ã¯ã€ :func:`getattr` "
"ã‚’ä½¿ã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚::"

#: ../../library/ctypes.rst:131
msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr ""
"Windows ã§ã¯ã€åå‰ã§ã¯ãªãåºæ•°ã«ã‚ˆã£ã¦é–¢æ•°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ dll ã‚‚ã‚ã‚Šã¾ã™ã€‚ã“ã†ã—ãŸé–¢æ•°ã«ã¯åºæ•°ã‚’ä½¿ã£ã¦ dll "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã™ã‚‹ã“ã¨ã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™::"

#: ../../library/ctypes.rst:148
msgid "Calling functions"
msgstr "é–¢æ•°ã‚’å‘¼ã³å‡ºã™"

#: ../../library/ctypes.rst:150
msgid ""
"You can call these functions like any other Python callable. This example "
"uses the ``time()`` function, which returns system time in seconds since the"
" Unix epoch, and the ``GetModuleHandleA()`` function, which returns a win32 "
"module handle."
msgstr ""
"ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ä»–ã® Python å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒã˜ã‚ˆã†ã«å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯ ``time()`` é–¢æ•° "
"(Unixã‚¨ãƒãƒƒã‚¯ã‹ã‚‰ã®ã‚·ã‚¹ãƒ†ãƒ æ™‚é–“ã‚’ç§’å˜ä½ã§è¿”ã™) ã¨ã€ ``GetModuleHandleA()`` é–¢æ•° (win32ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒãƒ³ãƒ‰ãƒ«ã‚’è¿”ã™) "
"ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/ctypes.rst:155
msgid ""
"This example calls both functions with a NULL pointer (``None`` should be "
"used as the NULL pointer)::"
msgstr "ã“ã®ä¾‹ã¯ä¸¡æ–¹ã®é–¢æ•°ã‚’ NULL ãƒã‚¤ãƒ³ã‚¿ã¨ã¨ã‚‚ã«å‘¼ã³å‡ºã—ã¾ã™ (``None`` ã‚’ NULL ãƒã‚¤ãƒ³ã‚¿ã¨ã—ã¦ä½¿ã†å¿…è¦ãŒã‚ã‚Šã¾ã™)::"

#: ../../library/ctypes.rst:166
msgid ""
":mod:`ctypes` may raise a :exc:`ValueError` after calling the function, if "
"it detects that an invalid number of arguments were passed.  This behavior "
"should not be relied upon.  It is deprecated in 3.6.2, and will be removed "
"in 3.7."
msgstr ""
"ä¸æ­£ãªæ•°ã®å¼•æ•°ãŒæ¸¡ã•ã‚ŒãŸã“ã¨ã‚’æ¤œçŸ¥ã—ãŸå ´åˆã€ :mod:`ctypes` ã¯é–¢æ•°ã‚’å‘¼ã³å‡ºã—ãŸå¾Œã« :exc:`ValueError` ã‚’é€å‡ºã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚\n"
"ã“ã®å‹•ä½œã«ã¯ä¾å­˜ã™ã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚\n"
"ã“ã®å‹•ä½œã¯ 3.6.2 ã§éæ¨å¥¨ã§ã‚ã‚Šã€ 3.7 ã§å‰Šé™¤äºˆå®šã§ã™ã€‚"

#: ../../library/ctypes.rst:171
msgid ""
":exc:`ValueError` is raised when you call an ``stdcall`` function with the "
"``cdecl`` calling convention, or vice versa::"
msgstr ""
"``cdecl`` å‘¼ã³å‡ºã—è¦ç´„ã‚’ä½¿ã£ã¦ ``stdcall`` é–¢æ•°ã‚’å‘¼ã³å‡ºã—ãŸã¨ãã«ã¯ã€ :exc:`ValueError` "
"ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚é€†ã®å ´åˆã‚‚åŒæ§˜ã§ã™::"

#: ../../library/ctypes.rst:186
msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr "æ­£ã—ã„å‘¼ã³å‡ºã—è¦ç´„ã‚’çŸ¥ã‚‹ãŸã‚ã«ã¯ã€å‘¼ã³å‡ºã—ãŸã„é–¢æ•°ã«ã¤ã„ã¦ã® C ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚ã—ãã¯ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’è¦‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:189
msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr ""
"Windows ã§ã¯ã€é–¢æ•°ãŒç„¡åŠ¹ãªå¼•æ•°ã¨ã¨ã‚‚ã«å‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆã®ä¸€èˆ¬ä¿è­·ä¾‹å¤–ã«ã‚ˆã‚‹ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã‚’é˜²ããŸã‚ã«ã€ :mod:`ctypes` ã¯ win32 "
"æ§‹é€ åŒ–ä¾‹å¤–å‡¦ç†ã‚’ä½¿ã„ã¾ã™::"

#: ../../library/ctypes.rst:199
msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so you "
"should be careful anyway.  The :mod:`faulthandler` module can be helpful in "
"debugging crashes (e.g. from segmentation faults produced by erroneous C "
"library calls)."
msgstr ""
"ã—ã‹ã—ãã‚Œã§ã‚‚ä»–ã« :mod:`ctypes` ã§ Python "
"ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹çŠ¶æ³ã¯ã‚ã‚‹ã®ã§ã€ã©ã¡ã‚‰ã«ã›ã‚ˆæ°—ã‚’é…ã‚‹ã¹ãã§ã™ã€‚ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã®ãƒ‡ãƒãƒƒã‚°ã«ã¯ã€ :mod:`faulthandler` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå½¹ã«ç«‹ã¤å ´åˆãŒã‚ã‚Šã¾ã™ (ä¾‹ãˆã°ã€èª¤ã£ãŸ C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦å¼•ãèµ·ã“ã•ã‚ŒãŸã‚»ã‚°ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³é•å) ã€‚"

#: ../../library/ctypes.rst:204
msgid ""
"``None``, integers, bytes objects and (unicode) strings are the only native "
"Python objects that can directly be used as parameters in these function "
"calls. ``None`` is passed as a C ``NULL`` pointer, bytes objects and strings"
" are passed as pointer to the memory block that contains their data "
"(:c:type:`char *` or :c:type:`wchar_t *`).  Python integers are passed as "
"the platforms default C :c:type:`int` type, their value is masked to fit "
"into the C type."
msgstr ""
"``None`` ã€æ•´æ•°ã€ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŠã‚ˆã³ (Unicode) "
"æ–‡å­—åˆ—ã ã‘ãŒã€ã“ã†ã—ãŸé–¢æ•°å‘¼ã³å‡ºã—ã«ãŠã„ã¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦ç›´æ¥ä½¿ãˆã‚‹ãƒã‚¤ãƒ†ã‚£ãƒ–ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ ``None`` ã¯ C ã® "
"``NULL`` ãƒã‚¤ãƒ³ã‚¿ã¨ã—ã¦æ¸¡ã•ã‚Œã€ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã¨ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—ã¯ãã®ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã¸ã®ãƒã‚¤ãƒ³ã‚¿ (:c:type:`char *` "
"ã¾ãŸã¯ :c:type:`wchar_t *`) ã¨ã—ã¦æ¸¡ã•ã‚Œã¾ã™ã€‚ Python æ•´æ•°ã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ›ãƒ¼ãƒ ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® C :c:type:`int` "
"å‹ã¨ã—ã¦æ¸¡ã•ã‚Œã€ãã®å€¤ã¯ C :c:type:`int` å‹ã«åˆã†ã‚ˆã†ã«ãƒã‚¹ã‚¯ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:211
msgid ""
"Before we move on calling functions with other parameter types, we have to "
"learn more about :mod:`ctypes` data types."
msgstr "ä»–ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‹ã‚’ã‚‚ã¤é–¢æ•°å‘¼ã³å‡ºã—ã«ç§»ã‚‹å‰ã«ã€ :mod:`ctypes` ãƒ‡ãƒ¼ã‚¿å‹ã«ã¤ã„ã¦ã•ã‚‰ã«å­¦ã¶å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:218 ../../library/ctypes.rst:2064
msgid "Fundamental data types"
msgstr "åŸºæœ¬ãƒ‡ãƒ¼ã‚¿å‹"

#: ../../library/ctypes.rst:220
msgid ":mod:`ctypes` defines a number of primitive C compatible data types:"
msgstr ":mod:`ctypes` ã§ã¯ã„ãã¤ã‚‚ã® C äº’æ›ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãªãƒ‡ãƒ¼ã‚¿å‹ã‚’å®šç¾©ã—ã¦ã„ã¾ã™:"

#: ../../library/ctypes.rst:223
msgid "ctypes type"
msgstr "ctypes ã®å‹"

#: ../../library/ctypes.rst:223
msgid "C type"
msgstr "C ã®å‹"

#: ../../library/ctypes.rst:223
msgid "Python type"
msgstr "Python ã®å‹"

#: ../../library/ctypes.rst:225
msgid ":class:`c_bool`"
msgstr ":class:`c_bool`"

#: ../../library/ctypes.rst:225
msgid ":c:type:`_Bool`"
msgstr ":c:type:`_Bool`"

#: ../../library/ctypes.rst:225
msgid "bool (1)"
msgstr "bool (1)"

#: ../../library/ctypes.rst:227
msgid ":class:`c_char`"
msgstr ":class:`c_char`"

#: ../../library/ctypes.rst:227 ../../library/ctypes.rst:231
msgid ":c:type:`char`"
msgstr ":c:type:`char`"

#: ../../library/ctypes.rst:227
msgid "1-character bytes object"
msgstr "1æ–‡å­—ã®ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/ctypes.rst:229
msgid ":class:`c_wchar`"
msgstr ":class:`c_wchar`"

#: ../../library/ctypes.rst:229
msgid ":c:type:`wchar_t`"
msgstr ":c:type:`wchar_t`"

#: ../../library/ctypes.rst:229
msgid "1-character string"
msgstr "1æ–‡å­—ã®æ–‡å­—åˆ—"

#: ../../library/ctypes.rst:231
msgid ":class:`c_byte`"
msgstr ":class:`c_byte`"

#: ../../library/ctypes.rst:231 ../../library/ctypes.rst:233
#: ../../library/ctypes.rst:235 ../../library/ctypes.rst:237
#: ../../library/ctypes.rst:239 ../../library/ctypes.rst:241
#: ../../library/ctypes.rst:243 ../../library/ctypes.rst:245
#: ../../library/ctypes.rst:247 ../../library/ctypes.rst:249
#: ../../library/ctypes.rst:252 ../../library/ctypes.rst:254
msgid "int"
msgstr "int"

#: ../../library/ctypes.rst:233
msgid ":class:`c_ubyte`"
msgstr ":class:`c_ubyte`"

#: ../../library/ctypes.rst:233
msgid ":c:type:`unsigned char`"
msgstr ":c:type:`unsigned char`"

#: ../../library/ctypes.rst:235
msgid ":class:`c_short`"
msgstr ":class:`c_short`"

#: ../../library/ctypes.rst:235
msgid ":c:type:`short`"
msgstr ":c:type:`short`"

#: ../../library/ctypes.rst:237
msgid ":class:`c_ushort`"
msgstr ":class:`c_ushort`"

#: ../../library/ctypes.rst:237
msgid ":c:type:`unsigned short`"
msgstr ":c:type:`unsigned short`"

#: ../../library/ctypes.rst:239
msgid ":class:`c_int`"
msgstr ":class:`c_int`"

#: ../../library/ctypes.rst:239
msgid ":c:type:`int`"
msgstr ":c:type:`int`"

#: ../../library/ctypes.rst:241
msgid ":class:`c_uint`"
msgstr ":class:`c_uint`"

#: ../../library/ctypes.rst:241
msgid ":c:type:`unsigned int`"
msgstr ":c:type:`unsigned int`"

#: ../../library/ctypes.rst:243
msgid ":class:`c_long`"
msgstr ":class:`c_long`"

#: ../../library/ctypes.rst:243
msgid ":c:type:`long`"
msgstr ":c:type:`long`"

#: ../../library/ctypes.rst:245
msgid ":class:`c_ulong`"
msgstr ":class:`c_ulong`"

#: ../../library/ctypes.rst:245
msgid ":c:type:`unsigned long`"
msgstr ":c:type:`unsigned long`"

#: ../../library/ctypes.rst:247
msgid ":class:`c_longlong`"
msgstr ":class:`c_longlong`"

#: ../../library/ctypes.rst:247
msgid ":c:type:`__int64` or :c:type:`long long`"
msgstr ":c:type:`__int64` ã¾ãŸã¯ :c:type:`long long`"

#: ../../library/ctypes.rst:249
msgid ":class:`c_ulonglong`"
msgstr ":class:`c_ulonglong`"

#: ../../library/ctypes.rst:249
msgid ":c:type:`unsigned __int64` or :c:type:`unsigned long long`"
msgstr ":c:type:`unsigned __int64` ã¾ãŸã¯ :c:type:`unsigned long long`"

#: ../../library/ctypes.rst:252
msgid ":class:`c_size_t`"
msgstr ":class:`c_size_t`"

#: ../../library/ctypes.rst:252
msgid ":c:type:`size_t`"
msgstr ":c:type:`size_t`"

#: ../../library/ctypes.rst:254
msgid ":class:`c_ssize_t`"
msgstr ":class:`c_ssize_t`"

#: ../../library/ctypes.rst:254
msgid ":c:type:`ssize_t` or :c:type:`Py_ssize_t`"
msgstr ":c:type:`ssize_t` ã¾ãŸã¯ :c:type:`Py_ssize_t`"

#: ../../library/ctypes.rst:257
msgid ":class:`c_float`"
msgstr ":class:`c_float`"

#: ../../library/ctypes.rst:257
msgid ":c:type:`float`"
msgstr ":c:type:`float`"

#: ../../library/ctypes.rst:257 ../../library/ctypes.rst:259
#: ../../library/ctypes.rst:261
msgid "float"
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°"

#: ../../library/ctypes.rst:259
msgid ":class:`c_double`"
msgstr ":class:`c_double`"

#: ../../library/ctypes.rst:259
msgid ":c:type:`double`"
msgstr ":c:type:`double`"

#: ../../library/ctypes.rst:261
msgid ":class:`c_longdouble`"
msgstr ":class:`c_longdouble`"

#: ../../library/ctypes.rst:261
msgid ":c:type:`long double`"
msgstr ":c:type:`long double`"

#: ../../library/ctypes.rst:263
msgid ":class:`c_char_p`"
msgstr ":class:`c_char_p`"

#: ../../library/ctypes.rst:263
msgid ":c:type:`char *` (NUL terminated)"
msgstr ":c:type:`char *` (NUL çµ‚ç«¯)"

#: ../../library/ctypes.rst:263
msgid "bytes object or ``None``"
msgstr "ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ ``None``"

#: ../../library/ctypes.rst:265
msgid ":class:`c_wchar_p`"
msgstr ":class:`c_wchar_p`"

#: ../../library/ctypes.rst:265
msgid ":c:type:`wchar_t *` (NUL terminated)"
msgstr ":c:type:`wchar_t *` (NUL çµ‚ç«¯)"

#: ../../library/ctypes.rst:265
msgid "string or ``None``"
msgstr "æ–‡å­—åˆ—ã¾ãŸã¯ ``None``"

#: ../../library/ctypes.rst:267
msgid ":class:`c_void_p`"
msgstr ":class:`c_void_p`"

#: ../../library/ctypes.rst:267
msgid ":c:type:`void *`"
msgstr ":c:type:`void *`"

#: ../../library/ctypes.rst:267
msgid "int or ``None``"
msgstr "æ•´æ•°ã¾ãŸã¯ ``None``"

#: ../../library/ctypes.rst:271
msgid "The constructor accepts any object with a truth value."
msgstr "ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãã®çœŸå½å€¤ã¨ã—ã¦å—ã‘å–ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:273
msgid ""
"All these types can be created by calling them with an optional initializer "
"of the correct type and value::"
msgstr "ã“ã‚Œã‚‰å…¨ã¦ã®å‹ã¯ãã®å‹ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦ä½œæˆã§ãã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨ã—ã¦å‹ã¨å€¤ãŒåˆã£ã¦ã„ã‚‹åˆæœŸåŒ–å­ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/ctypes.rst:284
msgid ""
"Since these types are mutable, their value can also be changed afterwards::"
msgstr "ã“ã‚Œã‚‰ã®å‹ã¯å¤‰æ›´å¯èƒ½ã§ã‚ã‚Šã€å€¤ã‚’å¾Œã§å¤‰æ›´ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™::"

#: ../../library/ctypes.rst:296
msgid ""
"Assigning a new value to instances of the pointer types :class:`c_char_p`, "
":class:`c_wchar_p`, and :class:`c_void_p` changes the *memory location* they"
" point to, *not the contents* of the memory block (of course not, because "
"Python bytes objects are immutable)::"
msgstr ""
"æ–°ã—ã„å€¤ã‚’ãƒã‚¤ãƒ³ã‚¿å‹ :class:`c_char_p`, :class:`c_wchar_p` ãŠã‚ˆã³ :class:`c_void_p` "
"ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ä»£å…¥ã™ã‚‹ã¨ã€å¤‰ã‚ã‚‹ã®ã¯æŒ‡ã—ã¦ã„ã‚‹ *ãƒ¡ãƒ¢ãƒªä½ç½®* ã§ã‚ã£ã¦ã€ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã® *å†…å®¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“* (ã“ã‚Œã¯å½“ç„¶ã§ã€ãªãœãªã‚‰ã€ "
"Python ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤‰æ›´ä¸å¯èƒ½ã ã‹ã‚‰ã§ã™)::"

#: ../../library/ctypes.rst:316
msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has a "
":func:`create_string_buffer` function which creates these in various ways.  "
"The current memory block contents can be accessed (or changed) with the "
"``raw`` property; if you want to access it as NUL terminated string, use the"
" ``value`` property::"
msgstr ""
"ã—ã‹ã—ã€å¤‰æ›´å¯èƒ½ãªãƒ¡ãƒ¢ãƒªã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã§ã‚ã‚‹ã“ã¨ã‚’æƒ³å®šã—ã¦ã„ã‚‹é–¢æ•°ã¸ãã‚Œã‚‰ã‚’æ¸¡ã•ãªã„ã‚ˆã†ã«æ³¨æ„ã™ã¹ãã§ã™ã€‚ã‚‚ã—å¤‰æ›´å¯èƒ½ãªãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ãŒå¿…è¦ãªã‚‰ã€ "
"ctypes ã«ã¯ :func:`create_string_buffer` "
"é–¢æ•°ãŒã‚ã‚Šã€ã„ã‚ã„ã‚ãªæ–¹æ³•ã§ä½œæˆã™ã‚‹ã“ã¨ã§ãã¾ã™ã€‚ç¾åœ¨ã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã®å†…å®¹ã¯ ``raw`` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ (ã‚ã‚‹ã„ã¯å¤‰æ›´) "
"ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚‚ã—ç¾åœ¨ã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã« NUL çµ‚ç«¯æ–‡å­—åˆ—ã¨ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã„ãªã‚‰ã€ ``value`` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ã£ã¦ãã ã•ã„::"

#: ../../library/ctypes.rst:340
msgid ""
"The :func:`create_string_buffer` function replaces the :func:`c_buffer` "
"function (which is still available as an alias), as well as the "
":func:`c_string` function from earlier ctypes releases.  To create a mutable"
" memory block containing unicode characters of the C type :c:type:`wchar_t` "
"use the :func:`create_unicode_buffer` function."
msgstr ""
":func:`create_string_buffer` é–¢æ•°ã¯åˆæœŸã® ctypes ãƒªãƒªãƒ¼ã‚¹ã«ã‚ã£ãŸ :func:`c_string` "
"é–¢æ•°ã ã‘ã§ãªãã€ (ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã¨ã—ã¦ã¯ã¾ã åˆ©ç”¨ã§ãã‚‹) :func:`c_buffer` é–¢æ•°ã‚’ã‚‚ç½®ãæ›ãˆã‚‹ã‚‚ã®ã§ã™ã€‚ C ã®å‹ "
":c:type:`wchar_t` ã® Unicode æ–‡å­—ã‚’å«ã‚€å¤‰æ›´å¯èƒ½ãªãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½œæˆã™ã‚‹ã«ã¯ã€ "
":func:`create_unicode_buffer` é–¢æ•°ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/ctypes.rst:350
msgid "Calling functions, continued"
msgstr "ç¶šãƒ»é–¢æ•°ã‚’å‘¼ã³å‡ºã™"

#: ../../library/ctypes.rst:352
msgid ""
"Note that printf prints to the real standard output channel, *not* to "
":data:`sys.stdout`, so these examples will only work at the console prompt, "
"not from within *IDLE* or *PythonWin*::"
msgstr ""
"printf ã¯ :data:`sys.stdout` ã§ã¯ *ãªã* "
"ã€æœ¬ç‰©ã®æ¨™æº–å‡ºåŠ›ãƒãƒ£ãƒ³ãƒãƒ«ã¸ãƒ—ãƒªãƒ³ãƒˆã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã—ãŸãŒã£ã¦ã€ã“ã‚Œã‚‰ã®ä¾‹ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§ã®ã¿å‹•ä½œã—ã€ *IDLE* ã‚„ "
"*PythonWin* ã§ã¯å‹•ä½œã—ã¾ã›ã‚“ã€‚::"

#: ../../library/ctypes.rst:372
msgid ""
"As has been mentioned before, all Python types except integers, strings, and"
" bytes objects have to be wrapped in their corresponding :mod:`ctypes` type,"
" so that they can be converted to the required C data type::"
msgstr ""
"å‰ã«è¿°ã¹ãŸã‚ˆã†ã«ã€å¿…è¦ãª C ã®ãƒ‡ãƒ¼ã‚¿å‹ã¸å¤‰æ›ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã¯ã€æ•´æ•°ã€æ–‡å­—åˆ—ãŠã‚ˆã³ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é™¤ãã™ã¹ã¦ã® Python å‹ã‚’å¯¾å¿œã™ã‚‹"
" :mod:`ctypes` å‹ã§ãƒ©ãƒƒãƒ—ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“::"

#: ../../library/ctypes.rst:385
msgid "Calling functions with your own custom data types"
msgstr "è‡ªä½œã®ãƒ‡ãƒ¼ã‚¿å‹ã¨ã¨ã‚‚ã«é–¢æ•°ã‚’å‘¼ã³å‡ºã™"

#: ../../library/ctypes.rst:387
msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow instances "
"of your own classes be used as function arguments.  :mod:`ctypes` looks for "
"an :attr:`_as_parameter_` attribute and uses this as the function argument."
"  Of course, it must be one of integer, string, or bytes::"
msgstr ""
"è‡ªä½œã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’é–¢æ•°å¼•æ•°ã¨ã—ã¦ä½¿ãˆã‚‹ã‚ˆã†ã«ã€ :mod:`ctypes` å¼•æ•°å¤‰æ›ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ "
":mod:`ctypes` ã¯ :attr:`_as_parameter_` "
"å±æ€§ã‚’æ¢ã—å‡ºã—ã€é–¢æ•°å¼•æ•°ã¨ã—ã¦ä½¿ã„ã¾ã™ã€‚ã‚‚ã¡ã‚ã‚“ã€æ•´æ•°ã€æ–‡å­—åˆ—ã‚‚ã—ãã¯ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸­ã®ä¸€ã¤ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“::"

#: ../../library/ctypes.rst:402
msgid ""
"If you don't want to store the instance's data in the :attr:`_as_parameter_`"
" instance variable, you could define a :class:`property` which makes the "
"attribute available on request."
msgstr ""
":attr:`_as_parameter_` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã—ãŸããªã„å ´åˆã¯ã€å¿…è¦ã«å¿œã˜ã¦åˆ©ç”¨ã§ãã‚‹å±æ€§ã‚’ä½œã‚‹ "
":class:`property` ã‚’å®šç¾©ã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:410
msgid "Specifying the required argument types (function prototypes)"
msgstr "è¦æ±‚ã•ã‚Œã‚‹å¼•æ•°ã®å‹ã‚’æŒ‡å®šã™ã‚‹ (é–¢æ•°ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—)"

#: ../../library/ctypes.rst:412
msgid ""
"It is possible to specify the required argument types of functions exported "
"from DLLs by setting the :attr:`argtypes` attribute."
msgstr ""
":attr:`argtypes` å±æ€§ã‚’è¨­å®šã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ DLL ã‹ã‚‰ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹é–¢æ•°ã«è¦æ±‚ã•ã‚Œã‚‹å¼•æ•°ã®å‹ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ctypes.rst:415
msgid ""
":attr:`argtypes` must be a sequence of C data types (the ``printf`` function"
" is probably not a good example here, because it takes a variable number and"
" different types of parameters depending on the format string, on the other "
"hand this is quite handy to experiment with this feature)::"
msgstr ""
":attr:`argtypes` ã¯ C ãƒ‡ãƒ¼ã‚¿å‹ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ (ã“ã®å ´åˆ ``printf`` "
"é–¢æ•°ã¯ãŠãã‚‰ãè‰¯ã„ä¾‹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãªãœãªã‚‰ã€å¼•æ•°ã®æ•°ãŒå¯å¤‰ã§ã‚ã‚Šã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ã«ä¾å­˜ã—ãŸç•°ãªã‚‹å‹ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–ã‚‹ã‹ã‚‰ã§ã™ã€‚ä¸€æ–¹ã§ã¯ã€ã“ã®æ©Ÿèƒ½ã®å®Ÿé¨“ã«ã¯ã¨ã¦ã‚‚ä¾¿åˆ©ã§ã™)ã€‚::"

#: ../../library/ctypes.rst:426
msgid ""
"Specifying a format protects against incompatible argument types (just as a "
"prototype for a C function), and tries to convert the arguments to valid "
"types::"
msgstr "(C ã®é–¢æ•°ã®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ã®ã‚ˆã†ã«) æ›¸å¼ã‚’æŒ‡å®šã™ã‚‹ã¨äº’æ›æ€§ã®ãªã„å¼•æ•°å‹ã«ãªã‚‹ã®ã‚’é˜²ãã€å¼•æ•°ã‚’æœ‰åŠ¹ãªå‹ã¸å¤‰æ›ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚::"

#: ../../library/ctypes.rst:438
msgid ""
"If you have defined your own classes which you pass to function calls, you "
"have to implement a :meth:`from_param` class method for them to be able to "
"use them in the :attr:`argtypes` sequence. The :meth:`from_param` class "
"method receives the Python object passed to the function call, it should do "
"a typecheck or whatever is needed to make sure this object is acceptable, "
"and then return the object itself, its :attr:`_as_parameter_` attribute, or "
"whatever you want to pass as the C function argument in this case. Again, "
"the result should be an integer, string, bytes, a :mod:`ctypes` instance, or"
" an object with an :attr:`_as_parameter_` attribute."
msgstr ""
"é–¢æ•°å‘¼ã³å‡ºã—ã¸æ¸¡ã™è‡ªä½œã®ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ãŸå ´åˆã«ã¯ã€ :attr:`argtypes` ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ä¸­ã§ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€ãã®ã‚¯ãƒ©ã‚¹ã« "
":meth:`from_param` ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ :meth:`from_param` "
"ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¯é–¢æ•°å‘¼ã³å‡ºã—ã¸æ¸¡ã•ã‚ŒãŸ Python "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚Šã€å‹ãƒã‚§ãƒƒã‚¯ã‚‚ã—ãã¯ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå—ã‘å…¥ã‚Œå¯èƒ½ã§ã‚ã‚‹ã¨ç¢ºã‹ã‚ã‚‹ãŸã‚ã«å¿…è¦ãªã“ã¨ã¯ã™ã¹ã¦è¡Œã£ã¦ã‹ã‚‰ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªèº«ã€ "
":attr:`_as_parameter_` å±æ€§ã€ã‚ã‚‹ã„ã¯ã€ã“ã®å ´åˆã« C "
"é–¢æ•°å¼•æ•°ã¨ã—ã¦æ¸¡ã—ãŸã„ä½•ã‹ã®å€¤ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ç¹°ã‚Šè¿”ã—ã«ãªã‚Šã¾ã™ãŒã€ãã®è¿”ã•ã‚Œã‚‹çµæœã¯æ•´æ•°ã€æ–‡å­—åˆ—ã€ãƒã‚¤ãƒˆåˆ—ã€ :mod:`ctypes` "
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€ã‚ã‚‹ã„ã¯ :attr:`_as_parameter_` å±æ€§ã‚’ã‚‚ã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/ctypes.rst:452
msgid "Return types"
msgstr "æˆ»ã‚Šå€¤ã®å‹"

#: ../../library/ctypes.rst:454
msgid ""
"By default functions are assumed to return the C :c:type:`int` type.  Other "
"return types can be specified by setting the :attr:`restype` attribute of "
"the function object."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€é–¢æ•°ã¯ C :c:type:`int` ã‚’è¿”ã™ã¨ä»®å®šã•ã‚Œã¾ã™ã€‚ä»–ã®æˆ»ã‚Šå€¤ã®å‹ã‚’æŒ‡å®šã™ã‚‹ã«ã¯ã€é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® "
":attr:`restype` å±æ€§ã«è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:458
msgid ""
"Here is a more advanced example, it uses the ``strchr`` function, which "
"expects a string pointer and a char, and returns a pointer to a string::"
msgstr ""
"ã•ã‚‰ã«é«˜åº¦ãªä¾‹ã¨ã—ã¦ã€ ``strchr`` é–¢æ•°ã‚’ä½¿ã„ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯æ–‡å­—åˆ—ãƒã‚¤ãƒ³ã‚¿ã¨ char ã‚’å—ã‘å–ã‚Šã€æ–‡å­—åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚::"

#: ../../library/ctypes.rst:471
msgid ""
"If you want to avoid the ``ord(\"x\")`` calls above, you can set the "
":attr:`argtypes` attribute, and the second argument will be converted from a"
" single character Python bytes object into a C char::"
msgstr ""
"ä¸Šã® ``ord(\"x\")`` å‘¼ã³å‡ºã—ã‚’é¿ã‘ãŸã„ãªã‚‰ã€ :attr:`argtypes` å±æ€§ã‚’è¨­å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚äºŒç•ªç›®ã®å¼•æ•°ãŒä¸€æ–‡å­—ã® "
"Python ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ C ã® char ã¸å¤‰æ›ã•ã‚Œã¾ã™::"

#: ../../library/ctypes.rst:489
msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`restype` attribute, if the foreign function returns "
"an integer.  The callable will be called with the *integer* the C function "
"returns, and the result of this call will be used as the result of your "
"function call. This is useful to check for error return values and "
"automatically raise an exception::"
msgstr ""
"å¤–éƒ¨é–¢æ•°ãŒæ•´æ•°ã‚’è¿”ã™å ´åˆã¯ã€ :attr:`restype` å±æ€§ã¨ã—ã¦å‘¼ã³å‡ºã—å¯èƒ½ãª Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ä¾‹ãˆã°ã€é–¢æ•°ã¾ãŸã¯ã‚¯ãƒ©ã‚¹) "
"ã‚’ä½¿ã†ã“ã¨ã‚‚ã§ãã¾ã™ã€‚å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ C é–¢æ•°ãŒè¿”ã™ *æ•´æ•°* "
"ã¨ã¨ã‚‚ã«å‘¼ã³å‡ºã•ã‚Œã€ã“ã®å‘¼ã³å‡ºã—ã®çµæœã¯é–¢æ•°å‘¼ã³å‡ºã—ã®çµæœã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹ã§ã—ã‚‡ã†ã€‚ã“ã‚Œã¯ã‚¨ãƒ©ãƒ¼ã®æˆ»ã‚Šå€¤ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦è‡ªå‹•çš„ã«ä¾‹å¤–ã‚’é€å‡ºã•ã›ã‚‹ãŸã‚ã«å½¹ã«ç«‹ã¡ã¾ã™ã€‚::"

#: ../../library/ctypes.rst:512
msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` api "
"to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one is"
" used, it calls :func:`GetLastError` to retrieve it."
msgstr ""
"``WinError`` ã¯ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã®æ–‡å­—åˆ—è¡¨ç¾ã‚’å¾—ã‚‹ãŸã‚ã« Windows ã® ``FormatMessage()`` api ã‚’å‘¼ã³å‡ºã—ã€ä¾‹å¤–ã‚’"
" *è¿”ã™* é–¢æ•°ã§ã™ã€‚ ``WinError`` "
"ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–ã‚Šã¾ã™ã€‚ã“ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒä½¿ã‚ã‚Œãªã„å ´åˆã¯ã€ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã‚’å–ã‚Šå‡ºã™ãŸã‚ã« :func:`GetLastError`"
" ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:517
msgid ""
"Please note that a much more powerful error checking mechanism is available "
"through the :attr:`errcheck` attribute; see the reference manual for "
"details."
msgstr ""
":attr:`errcheck` "
"å±æ€§ã«ã‚ˆã£ã¦ã‚‚ã£ã¨å¼·åŠ›ãªã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯æ©Ÿæ§‹ã‚’åˆ©ç”¨ã§ãã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚è©³ç´°ã¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ctypes.rst:524
msgid "Passing pointers (or: passing parameters by reference)"
msgstr "ãƒã‚¤ãƒ³ã‚¿ã‚’æ¸¡ã™(ã¾ãŸã¯ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‚ç…§æ¸¡ã—)"

#: ../../library/ctypes.rst:526
msgid ""
"Sometimes a C api function expects a *pointer* to a data type as parameter, "
"probably to write into the corresponding location, or if the data is too "
"large to be passed by value. This is also known as *passing parameters by "
"reference*."
msgstr ""
"æ™‚ã«ã¯ã€ C api é–¢æ•°ãŒãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ãƒ‡ãƒ¼ã‚¿å‹ã¨ã—ã¦ *ãƒã‚¤ãƒ³ã‚¿* "
"ã‚’æƒ³å®šã—ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ãŠãã‚‰ããƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨åŒä¸€ã®å ´æ‰€ã«æ›¸ãè¾¼ã‚€ãŸã‚ã‹ã€ã‚‚ã—ãã¯ãã®ãƒ‡ãƒ¼ã‚¿ãŒå¤§ãã™ãã¦å€¤æ¸¡ã—ã§ããªã„å ´åˆã§ã™ã€‚ã“ã‚Œã¯ "
"*ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‚ç…§æ¸¡ã—* ã¨ã—ã¦ã‚‚çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/ctypes.rst:530
msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the "
":func:`pointer` function, although :func:`pointer` does a lot more work "
"since it constructs a real pointer object, so it is faster to use "
":func:`byref` if you don't need the pointer object in Python itself::"
msgstr ""
":mod:`ctypes` ã¯ :func:`byref` é–¢æ•°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ãŠã‚Šã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å‚ç…§æ¸¡ã—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™ã€‚ "
":func:`pointer` é–¢æ•°ã‚’ä½¿ã£ã¦ã‚‚åŒã˜åŠ¹æœãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€ :func:`pointer` "
"ã¯æœ¬å½“ã®ãƒã‚¤ãƒ³ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã‚ˆã‚Šå¤šãã®å‡¦ç†ã‚’è¡Œã†ã“ã¨ã‹ã‚‰ã€ Python å´ã§ãƒã‚¤ãƒ³ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã‚’å¿…è¦ã¨ã—ãªã„ãªã‚‰ã° "
":func:`byref` ã‚’ä½¿ã†æ–¹ãŒã‚ˆã‚Šé«˜é€Ÿã§ã™ã€‚::"

#: ../../library/ctypes.rst:552
msgid "Structures and unions"
msgstr "æ§‹é€ ä½“ã¨å…±ç”¨ä½“"

#: ../../library/ctypes.rst:554
msgid ""
"Structures and unions must derive from the :class:`Structure` and "
":class:`Union` base classes which are defined in the :mod:`ctypes` module. "
"Each subclass must define a :attr:`_fields_` attribute.  :attr:`_fields_` "
"must be a list of *2-tuples*, containing a *field name* and a *field type*."
msgstr ""
"æ§‹é€ ä½“ã¨å…±ç”¨ä½“ã¯ :mod:`ctypes` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ :class:`Structure` ãŠã‚ˆã³ :class:`Union` "
"ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã‹ã‚‰ã®æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã‚Œãã‚Œã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã¯ :attr:`_fields_` å±æ€§ã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ "
":attr:`_fields_` ã¯ *ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å* ã¨ *ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å‹* ã‚’æŒã¤ *2è¦ç´ ã‚¿ãƒ—ãƒ«* ã®ãƒªã‚¹ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:559
msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr ""
"ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å‹ã¯ :class:`c_int` ã‹ä»–ã® :mod:`ctypes` å‹ (æ§‹é€ ä½“ã€å…±ç”¨ä½“ã€é…åˆ—ã€ãƒã‚¤ãƒ³ã‚¿) ã‹ã‚‰æ´¾ç”Ÿã—ãŸ "
":mod:`ctypes` å‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:562
msgid ""
"Here is a simple example of a POINT structure, which contains two integers "
"named *x* and *y*, and also shows how to initialize a structure in the "
"constructor::"
msgstr ""
"ä»¥ä¸‹ã¯ã€ *x* ã¨ *y* ã¨ã„ã†åå‰ã®äºŒã¤ã®æ•´æ•°ã‹ã‚‰ãªã‚‹ç°¡å˜ãª POINT "
"æ§‹é€ ä½“ã®ä¾‹ã§ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§æ§‹é€ ä½“ã‚’åˆæœŸåŒ–ã™ã‚‹æ–¹æ³•ã‚‚èª¬æ˜ã—ã¦ã„ã¾ã™::"

#: ../../library/ctypes.rst:582
msgid ""
"You can, however, build much more complicated structures.  A structure can "
"itself contain other structures by using a structure as a field type."
msgstr ""
"ã—ã‹ã—ã€ã‚‚ã£ã¨è¤‡é›‘ãªæ§‹é€ ä½“ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã‚ã‚‹æ§‹é€ ä½“ã¯ã€ä»–ã®æ§‹é€ ä½“ã‚’ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å‹ã¨ã—ã¦ä½¿ã†ã“ã¨ã§ã€ä»–ã®æ§‹é€ ä½“ã‚’å«ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ctypes.rst:585
msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr "*upperleft* ã¨ *lowerright* ã¨ã„ã†åå‰ã®äºŒã¤ã® POINT ã‚’æŒã¤ RECT æ§‹é€ ä½“ã§ã™ã€‚::"

#: ../../library/ctypes.rst:599
msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr "å…¥ã‚Œå­ã«ãªã£ãŸæ§‹é€ ä½“ã¯ã„ãã¤ã‹ã®æ–¹æ³•ã‚’ç”¨ã„ã¦ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§åˆæœŸåŒ–ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚::"

#: ../../library/ctypes.rst:604
msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information::"
msgstr ""
"ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ :term:`descriptor` (è¨˜è¿°å­)ã¯ *ã‚¯ãƒ©ã‚¹* ã‹ã‚‰å–ã‚Šå‡ºã›ã¾ã™ã€‚ãƒ‡ãƒãƒƒã‚°ã™ã‚‹ã¨ãã«å½¹ã«ç«‹ã¤æƒ…å ±ã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/ctypes.rst:618
msgid ""
":mod:`ctypes` does not support passing unions or structures with bit-fields "
"to functions by value.  While this may work on 32-bit x86, it's not "
"guaranteed by the library to work in the general case.  Unions and "
"structures with bit-fields should always be passed to functions by pointer."
msgstr ""
":mod:`ctypes` ã§ã¯ã€ãƒ“ãƒƒãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚ã‚‹å…±ç”¨ä½“ã‚„æ§‹é€ ä½“ã®é–¢æ•°ã¸ã®å€¤æ¸¡ã—ã¯ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚ã“ã‚Œã¯ 32-bit ã® x86 "
"ç’°å¢ƒã§ã¯å‹•ãã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã¯ä¸€èˆ¬ã®å ´åˆã«å‹•ä½œã™ã‚‹ã“ã¨ã¯ä¿è¨¼ã—ã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:624
msgid "Structure/union alignment and byte order"
msgstr "æ§‹é€ ä½“/å…±ç”¨ä½“ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã¨ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼"

#: ../../library/ctypes.rst:626
msgid ""
"By default, Structure and Union fields are aligned in the same way the C "
"compiler does it. It is possible to override this behavior be specifying a "
":attr:`_pack_` class attribute in the subclass definition. This must be set "
"to a positive integer and specifies the maximum alignment for the fields. "
"This is what ``#pragma pack(n)`` also does in MSVC."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€æ§‹é€ ä½“ (Structure) ã¨å…±ç”¨ä½“(Union) ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ C "
"ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒè¡Œã†ã®ã¨åŒã˜æ–¹æ³•ã§ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã™ã‚‹ã¨ãã« :attr:`_pack_` "
"ã‚¯ãƒ©ã‚¹å±æ€§ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ã“ã®å‹•ä½œã‚’å¤‰ãˆã‚‹ã“ã¨ã¯å¯èƒ½ã§ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹å±æ€§ã«ã¯æ­£ã®æ•´æ•°ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®æœ€å¤§ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã‚’æŒ‡å®šã—ã¾ã™ã€‚ã“ã‚Œã¯"
" MSVC ã§ ``#pragma pack(n)`` ãŒè¡Œã£ã¦ã„ã‚‹ã“ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/ctypes.rst:632
msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the "
":class:`BigEndianStructure`, :class:`LittleEndianStructure`, "
":class:`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  These"
" classes cannot contain pointer fields."
msgstr ""
":mod:`ctypes` ã¯ Structure ã¨ Union "
"ã«å¯¾ã—ã¦ãƒã‚¤ãƒ†ã‚£ãƒ–ã®ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ã‚’ä½¿ã„ã¾ã™ã€‚ãƒã‚¤ãƒ†ã‚£ãƒ–ã§ã¯ãªã„ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ã®æ§‹é€ ä½“ã‚’ä½œæˆã™ã‚‹ã«ã¯ã€ "
":class:`BigEndianStructure`, :class:`LittleEndianStructure`, "
":class:`BigEndianUnion` ãŠã‚ˆã³ :class:`LittleEndianUnion` "
"ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã®ä¸­ã®ä¸€ã¤ã‚’ä½¿ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã‚¯ãƒ©ã‚¹ã«ãƒã‚¤ãƒ³ã‚¿ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒãŸã›ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:642
msgid "Bit fields in structures and unions"
msgstr "æ§‹é€ ä½“ã¨å…±ç”¨ä½“ã«ãŠã‘ã‚‹ãƒ“ãƒƒãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰"

#: ../../library/ctypes.rst:644
msgid ""
"It is possible to create structures and unions containing bit fields. Bit "
"fields are only possible for integer fields, the bit width is specified as "
"the third item in the :attr:`_fields_` tuples::"
msgstr ""
"ãƒ“ãƒƒãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å«ã‚€æ§‹é€ ä½“ã¨å…±ç”¨ä½“ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ“ãƒƒãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯æ•´æ•°ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å¯¾ã—ã¦ã®ã¿ä½œã‚‹ã“ã¨ãŒã§ãã€ãƒ“ãƒƒãƒˆå¹…ã¯ "
":attr:`_fields_` ã‚¿ãƒ—ãƒ«ã®ç¬¬ä¸‰è¦ç´ ã§æŒ‡å®šã—ã¾ã™ã€‚::"

#: ../../library/ctypes.rst:662
msgid "Arrays"
msgstr "é…åˆ—"

#: ../../library/ctypes.rst:664
msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr "é…åˆ— (Array) ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã‚ã‚Šã€æ±ºã¾ã£ãŸæ•°ã®åŒã˜å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/ctypes.rst:666
msgid ""
"The recommended way to create array types is by multiplying a data type with"
" a positive integer::"
msgstr "æ¨å¥¨ã•ã‚Œã¦ã„ã‚‹é…åˆ—ã®ä½œæˆæ–¹æ³•ã¯ãƒ‡ãƒ¼ã‚¿å‹ã«æ­£ã®æ•´æ•°ã‚’æ›ã‘ã‚‹ã“ã¨ã§ã™ã€‚::"

#: ../../library/ctypes.rst:671
msgid ""
"Here is an example of a somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr "ã‚„ã‚„ã‚ã–ã¨ã‚‰ã—ã„ãƒ‡ãƒ¼ã‚¿å‹ã®ä¾‹ã«ãªã‚Šã¾ã™ãŒã€ä»–ã®ã‚‚ã®ã«æ··ã–ã£ã¦ 4 å€‹ã® POINT ãŒã‚ã‚‹æ§‹é€ ä½“ã§ã™::"

#: ../../library/ctypes.rst:687
msgid "Instances are created in the usual way, by calling the class::"
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã‚¯ãƒ©ã‚¹ã‚’å‘¼ã³å‡ºã™é€šå¸¸ã®æ–¹æ³•ã§ä½œæˆã—ã¾ã™ã€‚::"

#: ../../library/ctypes.rst:693
msgid ""
"The above code print a series of ``0 0`` lines, because the array contents "
"is initialized to zeros."
msgstr "ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã¯ ``0 0`` ã¨ã„ã†è¡ŒãŒä¸¦ã‚“ã ã‚‚ã®ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚é…åˆ—ã®è¦ç´ ãŒã‚¼ãƒ­ã§åˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã§ã™ã€‚"

#: ../../library/ctypes.rst:696
msgid "Initializers of the correct type can also be specified::"
msgstr "æ­£ã—ã„å‹ã®åˆæœŸåŒ–å­ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚::"

#: ../../library/ctypes.rst:712
msgid "Pointers"
msgstr "ãƒã‚¤ãƒ³ã‚¿"

#: ../../library/ctypes.rst:714
msgid ""
"Pointer instances are created by calling the :func:`pointer` function on a "
":mod:`ctypes` type::"
msgstr "ãƒã‚¤ãƒ³ã‚¿ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ :mod:`ctypes` å‹ã«å¯¾ã—ã¦ :func:`pointer` é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ä½œæˆã—ã¾ã™ã€‚::"

#: ../../library/ctypes.rst:722
msgid ""
"Pointer instances have a :attr:`~_Pointer.contents` attribute which returns "
"the object to which the pointer points, the ``i`` object above::"
msgstr ""
"æ¬¡ã®ã‚ˆã†ã«ã€ãƒã‚¤ãƒ³ã‚¿ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ãƒã‚¤ãƒ³ã‚¿ãŒæŒ‡ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ä¸Šã®ä¾‹ã§ã¯ ``i``) ã‚’è¿”ã™ :attr:`~_Pointer.contents`"
" å±æ€§ã‚’æŒã¡ã¾ã™::"

#: ../../library/ctypes.rst:729
msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ""
":mod:`ctypes` ã¯ OOR (original object return ã€å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã“ã¨) "
"ã§ã¯ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚å±æ€§ã‚’å–ã‚Šå‡ºã™åº¦ã«ã€æ–°ã—ã„åŒç­‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã„ã‚‹ã®ã§ã™ã€‚::"

#: ../../library/ctypes.rst:738
msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where this"
" is stored::"
msgstr ""
"åˆ¥ã® :class:`c_int` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒãƒã‚¤ãƒ³ã‚¿ã® contents "
"å±æ€§ã«ä»£å…¥ã•ã‚Œã‚‹ã¨ã€ã“ã‚ŒãŒè¨˜æ†¶ã•ã‚Œã¦ã„ã‚‹ãƒ¡ãƒ¢ãƒªä½ç½®ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã«å¤‰åŒ–ã—ã¾ã™ã€‚::"

#: ../../library/ctypes.rst:750
msgid "Pointer instances can also be indexed with integers::"
msgstr "ãƒã‚¤ãƒ³ã‚¿ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯æ•´æ•°ã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚::"

#: ../../library/ctypes.rst:756
msgid "Assigning to an integer index changes the pointed to value::"
msgstr "æ•´æ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¸ä»£å…¥ã™ã‚‹ã¨ãƒã‚¤ãƒ³ã‚¿ãŒæŒ‡ã™å€¤ãŒå¤‰æ›´ã•ã‚Œã¾ã™ã€‚::"

#: ../../library/ctypes.rst:765
msgid ""
"It is also possible to use indexes different from 0, but you must know what "
"you're doing, just as in C: You can access or change arbitrary memory "
"locations. Generally you only use this feature if you receive a pointer from"
" a C function, and you *know* that the pointer actually points to an array "
"instead of a single item."
msgstr ""
"0 ã§ã¯ãªã„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ã†ã“ã¨ã‚‚ã§ãã¾ã™ãŒã€ C "
"ã®å ´åˆã¨åŒã˜ã‚ˆã†ã«è‡ªåˆ†ãŒä½•ã‚’ã—ã¦ã„ã‚‹ã‹ã‚’ç†è§£ã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä»»æ„ã®ãƒ¡ãƒ¢ãƒªä½ç½®ã«ã‚¢ã‚¯ã‚»ã‚¹ã‚‚ã—ãã¯å¤‰æ›´ã§ãã‚‹ã®ã§ã™ã€‚ä¸€èˆ¬çš„ã«ã“ã®æ©Ÿèƒ½ã‚’ä½¿ã†ã®ã¯ã€ C"
" é–¢æ•°ã‹ã‚‰ãƒã‚¤ãƒ³ã‚¿ã‚’å—ã‘å–ã‚Šã€ãã®ãƒã‚¤ãƒ³ã‚¿ãŒå˜ä¸€ã®è¦ç´ ã§ã¯ãªãå®Ÿéš›ã«é…åˆ—ã‚’æŒ‡ã—ã¦ã„ã‚‹ã¨ *åˆ†ã‹ã£ã¦ã„ã‚‹* å ´åˆã ã‘ã§ã™ã€‚"

#: ../../library/ctypes.rst:771
msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply create"
" pointer instances, it has to create pointer *types* first. This is done "
"with the :func:`POINTER` function, which accepts any :mod:`ctypes` type, and"
" returns a new type::"
msgstr ""
"èˆå°è£ã§ã¯ã€ :func:`pointer` é–¢æ•°ã¯å˜ã«ãƒã‚¤ãƒ³ã‚¿ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ã¨ã„ã†ä»¥ä¸Šã®ã“ã¨ã‚’è¡Œã£ã¦ã„ã¾ã™ã€‚ã¯ã˜ã‚ã«ãƒã‚¤ãƒ³ã‚¿ *å‹* "
"ã‚’ä½œæˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ä»»æ„ã® :mod:`ctypes` å‹ã‚’å—ã‘å–ã‚‹ :func:`POINTER` "
"é–¢æ•°ã‚’ä½¿ã£ã¦è¡Œã‚ã‚Œã€æ–°ã—ã„å‹ã‚’è¿”ã—ã¾ã™::"

#: ../../library/ctypes.rst:787
msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr ""
"ãƒã‚¤ãƒ³ã‚¿å‹ã‚’å¼•æ•°ãªã—ã§å‘¼ã³å‡ºã™ã¨ ``NULL`` ãƒã‚¤ãƒ³ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚ ``NULL`` ãƒã‚¤ãƒ³ã‚¿ã¯ ``False`` "
"ãƒ–ãƒ¼ãƒ«å€¤ã‚’æŒã£ã¦ã„ã¾ã™ã€‚::"

#: ../../library/ctypes.rst:795
msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ""
":mod:`ctypes` ã¯ãƒã‚¤ãƒ³ã‚¿ã®æŒ‡ã™å€¤ã‚’å–ã‚Šå‡ºã™ã¨ãã« ``NULL`` ã‹ã©ã†ã‹ã‚’èª¿ã¹ã¾ã™(ã—ã‹ã—ã€ ``NULL`` "
"ã§ãªã„ä¸æ­£ãªãƒã‚¤ãƒ³ã‚¿ã®æŒ‡ã™å€¤ã®å–ã‚Šå‡ºã™è¡Œç‚ºã¯ Python ã‚’ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã•ã›ã‚‹ã§ã—ã‚‡ã†)ã€‚::"

#: ../../library/ctypes.rst:814
msgid "Type conversions"
msgstr "å‹å¤‰æ›"

#: ../../library/ctypes.rst:816
msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`argtypes` list of a function or as the type"
" of a member field in a structure definition, only instances of exactly the "
"same type are accepted.  There are some exceptions to this rule, where "
"ctypes accepts other objects.  For example, you can pass compatible array "
"instances instead of pointer types.  So, for ``POINTER(c_int)``, ctypes "
"accepts an array of c_int::"
msgstr ""
"ãŸã„ã¦ã„ã®å ´åˆã€ ctypes ã¯å³å¯†ãªå‹ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã„ã¾ã™ã€‚ã“ã‚ŒãŒæ„å‘³ã™ã‚‹ã®ã¯ã€é–¢æ•°ã® :attr:`argtypes` "
"ãƒªã‚¹ãƒˆå†…ã«ã€ã‚‚ã—ãã¯ã€æ§‹é€ ä½“å®šç¾©ã«ãŠã‘ã‚‹ãƒ¡ãƒ³ãƒãƒ¼ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‹ã¨ã—ã¦ ``POINTER(c_int)`` "
"ãŒã‚ã‚‹å ´åˆã€å³å¯†ã«åŒã˜å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã ã‘ã‚’å—ã‘å–ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ã“ã®ãƒ«ãƒ¼ãƒ«ã«ã¯ ctypes "
"ãŒä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚‹å ´åˆã«ä¾‹å¤–ãŒã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒã‚¤ãƒ³ã‚¿å‹ã®ä»£ã‚ã‚Šã«äº’æ›æ€§ã®ã‚ã‚‹é…åˆ—ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®ã‚ˆã†ã«ã€ "
"``POINTER(c_int)`` ã«å¯¾ã—ã¦ã€ ctypes ã¯ c_int ã®é…åˆ—ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚::"

#: ../../library/ctypes.rst:837
msgid ""
"In addition, if a function argument is explicitly declared to be a pointer "
"type (such as ``POINTER(c_int)``) in :attr:`argtypes`, an object of the "
"pointed type (``c_int`` in this case) can be passed to the function.  ctypes"
" will apply the required :func:`byref` conversion in this case "
"automatically."
msgstr ""
"ãã‚Œã«åŠ ãˆã¦ã€ :attr:`argtypes` ã§é–¢æ•°ã®å¼•æ•°ãŒæ˜ç¤ºçš„ã« (``POINTER(c_int)`` ãªã©ã®) "
"ãƒã‚¤ãƒ³ã‚¿å‹ã§ã‚ã‚‹ã¨å®£è¨€ã•ã‚Œã¦ã„ãŸå ´åˆã€ãƒã‚¤ãƒ³ã‚¿å‹ãŒæŒ‡ã—ç¤ºã—ã¦ã„ã‚‹å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ã“ã®å ´åˆã§ã¯ ``c_int``) "
"ã‚’é–¢æ•°ã«æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®å ´åˆ ctypes ã¯ã€å¿…è¦ã¨ãªã‚‹ :func:`byref` ã§ã®å¤‰æ›ã‚’è‡ªå‹•çš„ã«é©ç”¨ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:842
msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr "POINTERå‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ ``NULL`` ã«è¨­å®šã™ã‚‹ãŸã‚ã«ã€ ``None`` ã‚’ä»£å…¥ã—ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚::"

#: ../../library/ctypes.rst:849
msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast one "
"type into another type.  :mod:`ctypes` provides a :func:`cast` function "
"which can be used in the same way.  The ``Bar`` structure defined above "
"accepts ``POINTER(c_int)`` pointers or :class:`c_int` arrays for its "
"``values`` field, but not instances of other types::"
msgstr ""
"æ™‚ã«ã¯ã€éäº’æ›ãªå‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚ C ã§ã¯ã€ã‚ã‚‹å‹ã‚’ä»–ã®å‹ã¸ã‚­ãƒ£ã‚¹ãƒˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ :mod:`ctypes` "
"ã¯åŒã˜ã‚„ã‚Šæ–¹ã§ä½¿ãˆã‚‹ :func:`cast` é–¢æ•°ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ä¸Šã§å®šç¾©ã—ãŸ ``Bar`` æ§‹é€ ä½“ã¯ ``POINTER(c_int)`` "
"ãƒã‚¤ãƒ³ã‚¿ã¾ãŸã¯ :class:`c_int` é…åˆ—ã‚’ ``values`` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å¯¾ã—ã¦å—ã‘å–ã‚Šã€ä»–ã®å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯å—ã‘å–ã‚Šã¾ã›ã‚“::"

#: ../../library/ctypes.rst:861
msgid "For these cases, the :func:`cast` function is handy."
msgstr "ã“ã®ã‚ˆã†ãªå ´åˆã«ã¯ã€ :func:`cast` é–¢æ•°ãŒä¾¿åˆ©ã§ã™ã€‚"

#: ../../library/ctypes.rst:863
msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two parameters,"
" a ctypes object that is or can be converted to a pointer of some kind, and "
"a ctypes pointer type.  It returns an instance of the second argument, which"
" references the same memory block as the first argument::"
msgstr ""
":func:`cast` é–¢æ•°ã¯ ctypes ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç•°ãªã‚‹ ctypes ãƒ‡ãƒ¼ã‚¿å‹ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã¸ã‚­ãƒ£ã‚¹ãƒˆã™ã‚‹ãŸã‚ã«ä½¿ãˆã¾ã™ã€‚ "
":func:`cast` ã¯äºŒã¤ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€ã‚ã‚‹ç¨®ã®ãƒã‚¤ãƒ³ã‚¿ã‹ãã®ãƒã‚¤ãƒ³ã‚¿ã¸å¤‰æ›ã§ãã‚‹ ctypes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã€ ctypes "
"ãƒã‚¤ãƒ³ã‚¿å‹ã‚’å–ã‚Šã¾ã™ã€‚ãã—ã¦ã€ç¬¬äºŒå¼•æ•°ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ç¬¬ä¸€å¼•æ•°ã¨åŒã˜ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’å‚ç…§ã—ã¦ã„ã¾ã™::"

#: ../../library/ctypes.rst:874
msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar`` "
"the structure::"
msgstr ""
"ã—ãŸãŒã£ã¦ã€ :func:`cast` ã‚’ ``Bar`` æ§‹é€ ä½“ã® ``values`` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¸ä»£å…¥ã™ã‚‹ãŸã‚ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/ctypes.rst:887
msgid "Incomplete Types"
msgstr "ä¸å®Œå…¨å‹"

#: ../../library/ctypes.rst:889
msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not "
"yet specified. In C, they are specified by forward declarations, which are "
"defined later::"
msgstr "*ä¸å®Œå…¨å‹* ã¯ãƒ¡ãƒ³ãƒãƒ¼ãŒã¾ã æŒ‡å®šã•ã‚Œã¦ã„ãªã„æ§‹é€ ä½“ã€å…±ç”¨ä½“ã‚‚ã—ãã¯é…åˆ—ã§ã™ã€‚ C ã§ã¯ã€å‰æ–¹å®£è¨€ã«ã‚ˆã‚ŠæŒ‡å®šã•ã‚Œã€å¾Œã§å®šç¾©ã•ã‚Œã¾ã™ã€‚::"

#: ../../library/ctypes.rst:900
msgid ""
"The straightforward translation into ctypes code would be this, but it does "
"not work::"
msgstr "ctypes ã‚³ãƒ¼ãƒ‰ã¸ã®ç›´æ¥çš„ãªå¤‰æ›ã§ã¯ã“ã†ãªã‚‹ã§ã—ã‚‡ã†ã€‚ã—ã‹ã—ã€å‹•ä½œã—ã¾ã›ã‚“::"

#: ../../library/ctypes.rst:913
msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the "
":attr:`_fields_` attribute later, after the class statement::"
msgstr ""
"ãªãœãªã‚‰ã€æ–°ã—ã„ ``class cell`` ã¯ã‚¯ãƒ©ã‚¹æ–‡è‡ªä½“ã®ä¸­ã§ã¯åˆ©ç”¨ã§ããªã„ã‹ã‚‰ã§ã™ã€‚ :mod:`ctypes` ã§ã¯ã€ ``cell`` "
"ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã¦ã€ :attr:`_fields_` å±æ€§ã‚’ã‚¯ãƒ©ã‚¹æ–‡ã®å¾Œã§è¨­å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚::"

#: ../../library/ctypes.rst:925
msgid ""
"Lets try it. We create two instances of ``cell``, and let them point to each"
" other, and finally follow the pointer chain a few times::"
msgstr ""
"è©¦ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ ``cell`` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’äºŒã¤ä½œã‚Šã€äº’ã„ã«å‚ç…§ã—åˆã†ã‚ˆã†ã«ã—ã¾ã™ã€‚æœ€å¾Œã«ã€ã¤ãªãŒã£ãŸãƒã‚¤ãƒ³ã‚¿ã‚’ä½•åº¦ã‹ãŸã©ã‚Šã¾ã™ã€‚::"

#: ../../library/ctypes.rst:946
msgid "Callback functions"
msgstr "ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°"

#: ../../library/ctypes.rst:948
msgid ""
":mod:`ctypes` allows creating C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ""
":mod:`ctypes` ã¯ C ã®å‘¼ã³å‡ºã—å¯èƒ½ãªé–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã‚’ Python å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ä½œæˆã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã¯ "
"*ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°* ã¨å‘¼ã°ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:951
msgid ""
"First, you must create a class for the callback function. The class knows "
"the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr ""
"æœ€åˆã«ã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã®ãŸã‚ã®ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãã®ã‚¯ãƒ©ã‚¹ã«ã¯å‘¼ã³å‡ºã—è¦ç´„ã€æˆ»ã‚Šå€¤ã®å‹ãŠã‚ˆã³ã“ã®é–¢æ•°ãŒå—ã‘å–ã‚‹å¼•æ•°ã®æ•°ã¨å‹ã«ã¤ã„ã¦ã®æƒ…å ±ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:955
msgid ""
"The :func:`CFUNCTYPE` factory function creates types for callback functions "
"using the ``cdecl`` calling convention. On Windows, the :func:`WINFUNCTYPE` "
"factory function creates types for callback functions using the ``stdcall`` "
"calling convention."
msgstr ""
":func:`CFUNCTYPE` ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã¯é€šå¸¸ã® ``cdecl`` å‘¼ã³å‡ºã—è¦ç´„ã‚’ç”¨ã„ã¦ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã®ãŸã‚ã®å‹ã‚’ä½œæˆã—ã¾ã™ã€‚ "
"Windows ã§ã¯ã€ :func:`WINFUNCTYPE` ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ãŒ ``stdcall`` "
"å‘¼ã³å‡ºã—è¦ç´„ã‚’ç”¨ã„ã¦ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã®å‹ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:960
msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr "ã“ã‚Œã‚‰ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã¯ã¨ã‚‚ã«æœ€åˆã®å¼•æ•°ã«æˆ»ã‚Šå€¤ã®å‹ã€æ®‹ã‚Šã®å¼•æ•°ã¨ã—ã¦ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ãŒæƒ³å®šã™ã‚‹å¼•æ•°ã®å‹ã‚’æ¸¡ã—ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:964
msgid ""
"I will present an example here which uses the standard C library's "
":c:func:`qsort` function, that is used to sort items with the help of a "
"callback function.  :c:func:`qsort` will be used to sort an array of "
"integers::"
msgstr ""
"æ¨™æº– C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® :c:func:`qsort` é–¢æ•°ã‚’ä½¿ã†ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã®åŠ©ã‘ã‚’ã‹ã‚Šã¦è¦ç´ ã‚’ã‚½ãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ "
":c:func:`qsort` ã¯æ•´æ•°ã®é…åˆ—ã‚’ã‚½ãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™::"

#: ../../library/ctypes.rst:974
msgid ""
":func:`qsort` must be called with a pointer to the data to sort, the number "
"of items in the data array, the size of one item, and a pointer to the "
"comparison function, the callback. The callback will then be called with two"
" pointers to items, and it must return a negative integer if the first item "
"is smaller than the second, a zero if they are equal, and a positive integer"
" otherwise."
msgstr ""
":func:`qsort` "
"ã¯ã‚½ãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€ãƒ‡ãƒ¼ã‚¿é…åˆ—ã®è¦ç´ ã®æ•°ã€è¦ç´ ã®ä¸€ã¤ã®å¤§ãã•ã€ãŠã‚ˆã³ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã§ã‚ã‚‹æ¯”è¼ƒé–¢æ•°ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å¼•æ•°ã«æ¸¡ã—ã¦å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã—ã¦ã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã¯è¦ç´ ã‚’æŒ‡ã™äºŒã¤ã®ãƒã‚¤ãƒ³ã‚¿ã‚’æ¸¡ã•ã‚Œã¦å‘¼ã³å‡ºã•ã‚Œã€ä¸€ç•ªç›®ãŒäºŒç•ªç›®ã‚ˆã‚Šå°ã•ã„ãªã‚‰è² ã®æ•°ã‚’ã€ç­‰ã—ã„ãªã‚‰ã‚¼ãƒ­ã‚’ã€ãã‚Œä»¥å¤–ãªã‚‰æ­£ã®æ•°ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:980
msgid ""
"So our callback function receives pointers to integers, and must return an "
"integer. First we create the ``type`` for the callback function::"
msgstr ""
"ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã¯æ•´æ•°ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å—ã‘å–ã‚Šã€æ•´æ•°ã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã¾ãšã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã®ãŸã‚ã® ``type`` ã‚’ä½œæˆã—ã¾ã™ã€‚::"

#: ../../library/ctypes.rst:986
msgid ""
"To get started, here is a simple callback that shows the values it gets "
"passed::"
msgstr "ã¾ãšåˆã‚ã«ã€ã“ã‚ŒãŒå—ã‘å–ã£ãŸå¤‰æ•°ã‚’è¡¨ç¤ºã™ã‚‹ã ã‘ã®ã‚·ãƒ³ãƒ—ãƒ«ãªã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§ã™::"

#: ../../library/ctypes.rst:996
msgid "The result::"
msgstr "çµæœã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™::"

#: ../../library/ctypes.rst:1006
msgid "Now we can actually compare the two items and return a useful result::"
msgstr "ã“ã“ã§ 2 ã¤ã®è¦ç´ ã‚’å®Ÿéš›ã«æ¯”è¼ƒã—ã€å½¹ã«ç«‹ã¤çµæœã‚’è¿”ã—ã¾ã™::"

#: ../../library/ctypes.rst:1021
msgid "As we can easily check, our array is sorted now::"
msgstr "ç°¡å˜ã«ç¢ºèªã§ãã‚‹ã‚ˆã†ã«ã€é…åˆ—ã‚’æ¬¡ã®ã‚ˆã†ã«ã‚½ãƒ¼ãƒˆã—ã¾ã—ãŸ::"

#: ../../library/ctypes.rst:1028
msgid ""
"The function factories can be used as decorator factories, so we may as well"
" write::"
msgstr ""

#: ../../library/ctypes.rst:1046
msgid ""
"Make sure you keep references to :func:`CFUNCTYPE` objects as long as they "
"are used from C code. :mod:`ctypes` doesn't, and if you don't, they may be "
"garbage collected, crashing your program when a callback is made."
msgstr ""
"C ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ :func:`CFUNCTYPE` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½¿ç”¨ã•ã‚Œã‚‹é™ã‚Šã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’ç¢ºå®Ÿã«ä¿æŒã—ã¦ãã ã•ã„ã€‚ "
":mod:`ctypes` "
"ã¯å‚ç…§ã‚’ä¿æŒã—ãªã„ãŸã‚ã€ã‚ãªãŸãŒå‚ç…§ã‚’ä¿æŒã—ãªã„ã¨ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®å¯¾è±¡ã¨ãªã‚Šã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒè¡Œã‚ã‚ŒãŸã¨ãã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã•ã›ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1050
msgid ""
"Also, note that if the callback function is called in a thread created "
"outside of Python's control (e.g. by the foreign code that calls the "
"callback), ctypes creates a new dummy Python thread on every invocation. "
"This behavior is correct for most purposes, but it means that values stored "
"with :class:`threading.local` will *not* survive across different callbacks,"
" even when those calls are made from the same C thread."
msgstr ""
"åŒæ§˜ã«ã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ãŒ Python ã®ç®¡ç†å¤– (ä¾‹ãˆã°ã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å‘¼ã³å‡ºã™å¤–éƒ¨ã®ã‚³ãƒ¼ãƒ‰) ã§ä½œã‚‰ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã§å‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆã€ ctypes"
" ã¯å…¨ã¦ã®å‘¼ã³å‡ºã—ã”ã¨ã«æ–°ã—ã„ãƒ€ãƒŸãƒ¼ã® Python ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½œæˆã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ ã“ã®å‹•ä½œã¯ã»ã¨ã‚“ã©ã®ç›®çš„ã«å¯¾ã—ã¦æ­£ã—ã„ã‚‚ã®ã§ã™ãŒã€åŒã˜"
" C ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ã®å‘¼ã³å‡ºã—ã ã£ãŸã¨ã—ã¦ã‚‚ã€ :class:`threading.local` ã§æ ¼ç´ã•ã‚ŒãŸå€¤ã¯ç•°ãªã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã¾ãŸã„ã§ç”Ÿå­˜ã¯ "
"*ã—ã¾ã›ã‚“* ã€‚"

#: ../../library/ctypes.rst:1060
msgid "Accessing values exported from dlls"
msgstr "dllã‹ã‚‰ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚ŒãŸå€¤ã¸ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹"

#: ../../library/ctypes.rst:1062
msgid ""
"Some shared libraries not only export functions, they also export variables."
" An example in the Python library itself is the :c:data:`Py_OptimizeFlag`, "
"an integer set to 0, 1, or 2, depending on the :option:`-O` or :option:`-OO`"
" flag given on startup."
msgstr ""
"å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ä¸€éƒ¨ã¯é–¢æ•°ã ã‘ã§ãªãå¤‰æ•°ã‚‚ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ Python ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ã‚‹ä¾‹ã¨ã—ã¦ã¯ "
":c:data:`Py_OptimizeFlag` ã€èµ·å‹•æ™‚ã® :option:`-O` ã¾ãŸã¯ :option:`-OO` ãƒ•ãƒ©ã‚°ã«ä¾å­˜ã—ã¦ã€ 0 ,"
" 1 ã¾ãŸã¯ 2 ãŒè¨­å®šã•ã‚Œã‚‹æ•´æ•°ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1067
msgid ""
":mod:`ctypes` can access values like this with the :meth:`in_dll` class "
"methods of the type.  *pythonapi* is a predefined symbol giving access to "
"the Python C api::"
msgstr ""
":mod:`ctypes` ã¯å‹ã® :meth:`in_dll` ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ã“ã®ã‚ˆã†ã«å€¤ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚ *pythonapi* "
"ã¯Python C api ã¸ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®äºˆã‚å®šç¾©ã•ã‚ŒãŸã‚·ãƒ³ãƒœãƒ«ã§ã™ã€‚::"

#: ../../library/ctypes.rst:1076
msgid ""
"If the interpreter would have been started with :option:`-O`, the sample "
"would have printed ``c_long(1)``, or ``c_long(2)`` if :option:`-OO` would "
"have been specified."
msgstr ""
"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãŒ :option:`-O` ã‚’æŒ‡å®šã•ã‚Œã¦å‹•ãå§‹ã‚ãŸå ´åˆã€ã‚µãƒ³ãƒ—ãƒ«ã¯ ``c_long(1)`` ã‚’è¡¨ç¤ºã™ã‚‹ã§ã—ã‚‡ã†ã—ã€ "
":option:`-OO` ãŒæŒ‡å®šã•ã‚ŒãŸãªã‚‰ã° ``c_long(2)`` ã‚’è¡¨ç¤ºã™ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/ctypes.rst:1080
msgid ""
"An extended example which also demonstrates the use of pointers accesses the"
" :c:data:`PyImport_FrozenModules` pointer exported by Python."
msgstr ""
"ãƒã‚¤ãƒ³ã‚¿ã®ä½¿ã„æ–¹ã‚’èª¬æ˜ã™ã‚‹æ‹¡å¼µä¾‹ã§ã¯ã€ Python ãŒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ :c:data:`PyImport_FrozenModules` "
"ãƒã‚¤ãƒ³ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1083
msgid "Quoting the docs for that value:"
msgstr "ã“ã®å€¤ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‹ã‚‰å¼•ç”¨ã™ã‚‹ã¨:"

#: ../../library/ctypes.rst:1085
msgid ""
"This pointer is initialized to point to an array of :c:type:`struct _frozen`"
" records, terminated by one whose members are all *NULL* or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"ã“ã®ãƒã‚¤ãƒ³ã‚¿ã¯ :c:type:`struct _frozen` ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ãªã‚Šã€çµ‚ç«¯ã®è¦ç´ ã®ãƒ¡ãƒ³ãƒãŒ *NULL* "
"ã‹ã‚¼ãƒ­ã«ãªã£ã¦ã„ã‚‹ã‚ˆã†ãªé…åˆ—ã‚’æŒ‡ã™ã‚ˆã†åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚ãƒ•ãƒªãƒ¼ã‚ºã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã¨ãã€ã“ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ¤œç´¢ã—ã¾ã™ã€‚ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£è£½ã®ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã“ã®ãƒã‚¤ãƒ³ã‚¿ã«ä»•æ›ã‘ã‚’è¬›ã˜ã¦ã€å‹•çš„ã«ç”Ÿæˆã•ã‚ŒãŸãƒ•ãƒªãƒ¼ã‚ºåŒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é›†åˆã‚’æä¾›ã™ã‚‹ã‚ˆã†ã«ã§ãã¾ã™ã€‚"

#: ../../library/ctypes.rst:1090
msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with :mod:`ctypes`::"
msgstr ""
"ã“ã‚Œã§ã€ã“ã®ãƒã‚¤ãƒ³ã‚¿ã‚’æ“ä½œã™ã‚‹ã“ã¨ãŒå½¹ã«ç«‹ã¤ã“ã¨ã‚’è¨¼æ˜ã§ãã‚‹ã§ã—ã‚‡ã†ã€‚ä¾‹ã®å¤§ãã•ã‚’åˆ¶é™ã™ã‚‹ãŸã‚ã«ã€ã“ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ :mod:`ctypes` "
"ã‚’ä½¿ã£ã¦èª­ã‚€æ–¹æ³•ã ã‘ã‚’ç¤ºã—ã¾ã™ã€‚::"

#: ../../library/ctypes.rst:1102
msgid ""
"We have defined the :c:type:`struct _frozen` data type, so we can get the "
"pointer to the table::"
msgstr "ç§ãŸã¡ã¯ :c:type:`struct _frozen` ãƒ‡ãƒ¼ã‚¿å‹ã‚’å®šç¾©æ¸ˆã¿ãªã®ã§ã€ã“ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/ctypes.rst:1109
msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` records, "
"we can iterate over it, but we just have to make sure that our loop "
"terminates, because pointers have no size. Sooner or later it would probably"
" crash with an access violation or whatever, so it's better to break out of "
"the loop when we hit the NULL entry::"
msgstr ""
"``table`` ãŒ ``struct_frozen`` ãƒ¬ã‚³ãƒ¼ãƒ‰ã®é…åˆ—ã¸ã® ``pointer`` "
"ãªã®ã§ã€ãã®é…åˆ—ã«å¯¾ã—ã¦åå¾©å‡¦ç†ã‚’è¡Œãˆã¾ã™ã€‚ã—ã‹ã—ã€ãƒ«ãƒ¼ãƒ—ãŒç¢ºå®Ÿã«çµ‚äº†ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãªãœãªã‚‰ã€ãƒã‚¤ãƒ³ã‚¿ã«å¤§ãã•ã®æƒ…å ±ãŒãªã„ã‹ã‚‰ã§ã™ã€‚é…ã‹ã‚Œæ—©ã‹ã‚Œã€ã‚¢ã‚¯ã‚»ã‚¹é•åã‹ä½•ã‹ã§ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚"
" NULL ã‚¨ãƒ³ãƒˆãƒªã«é”ã—ãŸã¨ãã¯ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹æ–¹ãŒè‰¯ã„ã§ã™ã€‚::"

#: ../../library/ctypes.rst:1127
msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative size member) is not well known, it is only used "
"for testing. Try it out with ``import __hello__`` for example."
msgstr ""
"æ¨™æº– Python ã¯ãƒ•ãƒ­ãƒ¼ã‚ºãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ãƒ•ãƒ­ãƒ¼ã‚ºãƒ³ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ (è² ã®ã‚µã‚¤ã‚ºã®ãƒ¡ãƒ³ãƒãƒ¼ã§è¡¨ã•ã‚Œã¦ã„ã¾ã™) "
"ã‚’æŒã£ã¦ã„ã‚‹ã¨ã„ã†äº‹å®Ÿã¯ã‚ã¾ã‚ŠçŸ¥ã‚‰ã‚Œã¦ãŠã‚‰ãšã€ãƒ†ã‚¹ãƒˆã«ã ã‘ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``import __hello__`` ã‚’è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚"

#: ../../library/ctypes.rst:1135
msgid "Surprises"
msgstr "ã³ã£ãã‚Šä»°å¤©"

#: ../../library/ctypes.rst:1137
msgid ""
"There are some edges in :mod:`ctypes` where you might expect something other"
" than what actually happens."
msgstr " :mod:`ctypes`  ã«ã¯ã€æœŸå¾…ã™ã‚‹å‹•ä½œã¨å®Ÿéš›ã«èµ·ã“ã‚‹å‹•ä½œãŒç•°ãªã‚‹ã‚ˆã†ãªå¥‡å¦™ãªç®‡æ‰€ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1140
msgid "Consider the following example::"
msgstr "æ¬¡ã«ç¤ºã™ä¾‹ã«ã¤ã„ã¦è€ƒãˆã¦ã¿ã¦ãã ã•ã„ã€‚::"

#: ../../library/ctypes.rst:1160
msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line above::"
msgstr ""
"ã†ãƒ¼ã‚“ã€æœ€å¾Œã®æ–‡ã« ``3 4 1 2`` ã¨è¡¨ç¤ºã•ã‚Œã‚‹ã“ã¨ã‚’æœŸå¾…ã—ã¦ã„ãŸã¯ãšã§ã™ã€‚ä½•ãŒèµ·ããŸã®ã§ã—ã‚‡ã†ã‹? ä¸Šã®è¡Œã® ``rc.a, rc.b = "
"rc.b, rc.a`` ã®å„æ®µéšã¯ã“ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚::"

#: ../../library/ctypes.rst:1168
msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies the "
"buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, changes "
"the contents of ``temp1``. So, the last assignment ``rc.b = temp1``, doesn't"
" have the expected effect."
msgstr ""
"``temp0`` ã¨ ``temp1`` ã¯å‰è¨˜ã® ``rc`` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…éƒ¨ãƒãƒƒãƒ•ã‚¡ã§ã¾ã ä½¿ã‚ã‚Œã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã—ãŸãŒã£ã¦ã€ "
"``rc.a = temp0`` ã‚’å®Ÿè¡Œã™ã‚‹ã¨ ``temp0`` ã®ãƒãƒƒãƒ•ã‚¡å†…å®¹ãŒ ``rc`` ã®ãƒãƒƒãƒ•ã‚¡ã¸ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã™ã€‚ã•ã‚‰ã«ã€ã“ã‚Œã¯ "
"``temp1`` ã®å†…å®¹ã‚’å¤‰æ›´ã—ã¾ã™ã€‚ãã®ãŸã‚ã€æœ€å¾Œã®ä»£å…¥ ``rc.b = temp1`` ã¯ã€æœŸå¾…ã™ã‚‹çµæœã«ã¯ãªã‚‰ãªã„ã®ã§ã™ã€‚"

#: ../../library/ctypes.rst:1174
msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays "
"doesn't *copy* the sub-object, instead it retrieves a wrapper object "
"accessing the root-object's underlying buffer."
msgstr ""
"Structure ã€ Union ãŠã‚ˆã³ Array ã®ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–ã‚Šå‡ºã—ã¦ã‚‚ã€ãã®ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ *ã‚³ãƒ”ãƒ¼* "
"ã•ã‚Œã‚‹ã‚ã‘ã§ã¯ãªãã€ãƒ«ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…éƒ¨ãƒãƒƒãƒ•ã‚¡ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–ã‚Šå‡ºã™ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚"

#: ../../library/ctypes.rst:1178
msgid ""
"Another example that may behave different from what one would expect is "
"this::"
msgstr "æœŸå¾…ã¨ã¯é•ã†æŒ¯ã‚‹èˆã„ã‚’ã™ã‚‹åˆ¥ã®ä¾‹ã¯ã“ã‚Œã§ã™ã€‚::"

#: ../../library/ctypes.rst:1188
msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of the "
"memory. Storing a Python object in the memory block does not store the "
"object itself, instead the ``contents`` of the object is stored.  Accessing "
"the contents again constructs a new Python object each time!"
msgstr ""
"ãªãœ ``False`` ã¨è¡¨ç¤ºã•ã‚Œã‚‹ã®ã§ã—ã‚‡ã†ã‹? ctypes ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ãƒ¡ãƒ¢ãƒªã¨ã€ãƒ¡ãƒ¢ãƒªã®å†…å®¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã„ãã¤ã‹ã® "
":term:`descriptor` (è¨˜è¿°å­)ã‚’å«ã‚€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã« Python "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿å­˜ã—ã¦ã‚‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªèº«ãŒä¿å­˜ã•ã‚Œã‚‹è¨³ã§ã¯ãªãã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® ``contents`` ãŒä¿å­˜ã•ã‚Œã¾ã™ã€‚ãã® contents "
"ã«å†ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨æ–°ã—ã„ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãã®åº¦ã«ä½œã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1198
msgid "Variable-sized data types"
msgstr "å¯å¤‰ã‚µã‚¤ã‚ºã®ãƒ‡ãƒ¼ã‚¿å‹"

#: ../../library/ctypes.rst:1200
msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and "
"structures."
msgstr ":mod:`ctypes` ã¯å¯å¤‰ã‚µã‚¤ã‚ºã®é…åˆ—ã¨æ§‹é€ ä½“ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1202
msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an "
"existing ctypes object.  The function takes the object as first argument, "
"and the requested size in bytes as the second argument.  The memory block "
"cannot be made smaller than the natural memory block specified by the "
"objects type, a :exc:`ValueError` is raised if this is tried::"
msgstr ""
":func:`resize` é–¢æ•°ã¯æ—¢å­˜ã® ctypes "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚ºã‚’å¤‰æ›´ã—ãŸã„å ´åˆã«ä½¿ãˆã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ç¬¬ä¸€å¼•æ•°ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ç¬¬äºŒå¼•æ•°ã«è¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºã‚’ãƒã‚¤ãƒˆå˜ä½ã§æŒ‡å®šã—ã¾ã™ã€‚ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã§æŒ‡å®šã•ã‚Œã‚‹é€šå¸¸ã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚ˆã‚Šå°ã•ãã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã“ã‚Œã‚’ã‚„ã‚ã†ã¨ã™ã‚‹ã¨ã€"
" :exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚::"

#: ../../library/ctypes.rst:1222
msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 elements, "
"we get errors accessing other elements::"
msgstr ""
"ã“ã‚Œã¯ã“ã‚Œã§ä¸Šæ‰‹ãã„ã£ã¦ã„ã¾ã™ãŒã€ã“ã®é…åˆ—ã®è¿½åŠ ã—ãŸè¦ç´ ã¸ã©ã†ã‚„ã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ã§ã—ã‚‡ã†ã‹? ã“ã®å‹ã¯è¦ç´ ã®æ•°ãŒ 4 "
"å€‹ã§ã‚ã‚‹ã¨ã¾ã èªè­˜ã—ã¦ã„ã‚‹ã®ã§ã€ä»–ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚::"

#: ../../library/ctypes.rst:1234
msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use "
"the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ""
":mod:`ctypes` ã§å¯å¤‰ã‚µã‚¤ã‚ºã®ãƒ‡ãƒ¼ã‚¿å‹ã‚’ä½¿ã†ã‚‚ã†ä¸€ã¤ã®æ–¹æ³•ã¯ã€å¿…è¦ãªã‚µã‚¤ã‚ºãŒåˆ†ã‹ã£ãŸå¾Œã« Python "
"ã®å‹•çš„æ€§è³ªã‚’ä½¿ã£ã¦ä¸€ã¤ä¸€ã¤ãƒ‡ãƒ¼ã‚¿å‹ã‚’(å†)å®šç¾©ã™ã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../library/ctypes.rst:1242
msgid "ctypes reference"
msgstr "ctypesãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹"

#: ../../library/ctypes.rst:1248
msgid "Finding shared libraries"
msgstr "å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’è¦‹ã¤ã‘ã‚‹"

#: ../../library/ctypes.rst:1250
msgid ""
"When programming in a compiled language, shared libraries are accessed when "
"compiling/linking a program, and when the program is run."
msgstr ""
"ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã‚‹è¨€èªã§ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã—ã¦ã„ã‚‹å ´åˆã€å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«/ãƒªãƒ³ã‚¯ã—ã¦ã„ã‚‹ã¨ãã¨ã€ãã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå‹•ä½œã—ã¦ã„ã‚‹ã¨ãã«ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1253
msgid ""
"The purpose of the :func:`find_library` function is to locate a library in a"
" way similar to what the compiler or runtime loader does (on platforms with "
"several versions of a shared library the most recent should be loaded), "
"while the ctypes library loaders act like when a program is run, and call "
"the runtime loader directly."
msgstr ""
"ctypes ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå‹•ä½œã—ã¦ã„ã‚‹ã¨ãã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã„ã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãƒ­ãƒ¼ãƒ€ãƒ¼ã‚’ç›´æ¥å‘¼ã³å‡ºã™ã®ã«å¯¾ã—ã€ "
":func:`find_library` é–¢æ•°ã®ç›®çš„ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¾ãŸã¯ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒè¡Œã†ã®ã¨ä¼¼ãŸæ–¹æ³•ã§ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’æ¢ã—å‡ºã™ã“ã¨ã§ã™ã€‚ "
"(è¤‡æ•°ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ›ãƒ¼ãƒ ã§ã¯ã€ä¸€ç•ªæœ€è¿‘ã«è¦‹ã¤ã‹ã£ãŸã‚‚ã®ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã™)ã€‚"

#: ../../library/ctypes.rst:1259
msgid ""
"The :mod:`ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ":mod:`ctypes.util` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’æ±ºã‚ã‚‹ã®ã«å½¹ç«‹ã¤é–¢æ•°ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1267
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’è¦‹ã¤ã‘ã¦ãƒ‘ã‚¹åã‚’è¿”ãã†ã¨è©¦ã¿ã¾ã™ã€‚ *name* ã¯ ``lib`` ã®ã‚ˆã†ãªæ¥é ­è¾ã€ ``.so``, ``.dylib`` ã®ã‚ˆã†ãªæ¥å°¾è¾ã€ã‚ã‚‹ã„ã¯ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ãŒä½•ã‚‚ä»˜ã„ã¦ã„ãªã„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åå‰ã§ã™ (ã“ã‚Œã¯ posix ãƒªãƒ³ã‚«ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ :option:`!-l` ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹å½¢å¼ã§ã™)ã€‚\n"
"ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒè¦‹ã¤ã‹ã‚‰ãªã„ã¨ãã¯ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1272 ../../library/ctypes.rst:1858
msgid "The exact functionality is system dependent."
msgstr "å³å¯†ãªæ©Ÿèƒ½ã¯ã‚·ã‚¹ãƒ†ãƒ ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1274
msgid ""
"On Linux, :func:`find_library` tries to run external programs "
"(``/sbin/ldconfig``, ``gcc``, ``objdump`` and ``ld``) to find the library "
"file. It returns the filename of the library file."
msgstr ""
"Linux ã§ã¯ã€ :func:`find_library` ã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«å¤–éƒ¨ãƒ—ãƒ­ã‚°ãƒ©ãƒ  "
"(``/sbin/ldconfig``, ``gcc``, ``objdump`` ã¨ ``ld``) "
"ã‚’å®Ÿè¡Œã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1278
msgid ""
"On Linux, the value of the environment variable ``LD_LIBRARY_PATH`` is used "
"when searching for libraries, if a library cannot be found by any other "
"means."
msgstr ""
"Linux ã§ã¯ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’æ¤œç´¢ã™ã‚‹éš›ã«ã€ä»–ã®æ–¹æ³•ã§ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒè¦‹ã¤ã‘ã‚‰ã‚Œãªã„å ´åˆã¯ã€ ``LD_LIBRARY_PATH`` "
"ç’°å¢ƒå¤‰æ•°ã®å€¤ãŒä½¿ã‚ã‚Œã¾ã™"

#: ../../library/ctypes.rst:1282
msgid "Here are some examples::"
msgstr "ã“ã“ã«ä¾‹ãŒã‚ã‚Šã¾ã™::"

#: ../../library/ctypes.rst:1293
msgid ""
"On OS X, :func:`find_library` tries several predefined naming schemes and "
"paths to locate the library, and returns a full pathname if successful::"
msgstr ""
"OS X ã§ã¯ã€ :func:`find_library` "
"ã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ä½ç½®ã‚’æ¢ã™ãŸã‚ã«ã€äºˆã‚å®šç¾©ã•ã‚ŒãŸè¤‡æ•°ã®å‘½åæ–¹æ³•ã¨ãƒ‘ã‚¹ã‚’è©¦ã—ã€æˆåŠŸã™ã‚Œã°ãƒ•ãƒ«ãƒ‘ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚::"

#: ../../library/ctypes.rst:1307
msgid ""
"On Windows, :func:`find_library` searches along the system search path, and "
"returns the full pathname, but since there is no predefined naming scheme a "
"call like ``find_library(\"c\")`` will fail and return ``None``."
msgstr ""
"Windows ã§ã¯ã€ :func:`find_library` "
"ã¯ã‚·ã‚¹ãƒ†ãƒ ã®æ¢ç´¢ãƒ‘ã‚¹ã«æ²¿ã£ã¦æ¢ã—ã€ãƒ•ãƒ«ãƒ‘ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã—ã‹ã—ã€äºˆã‚å®šç¾©ã•ã‚ŒãŸå‘½åæ–¹æ³•ãŒãªã„ãŸã‚ã€ ``find_library(\"c\")`` "
"ã®ã‚ˆã†ãªå‘¼ã³å‡ºã—ã¯å¤±æ•—ã—ã€ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1311
msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development time, and hardcode that "
"into the wrapper module instead of using :func:`find_library` to locate the "
"library at runtime."
msgstr ""
":mod:`ctypes` ã§å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹å ´åˆã€ :func:`find_library` "
"ã‚’ä½¿ã£ã¦å®Ÿè¡Œæ™‚ã«ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å ´æ‰€ã‚’ç‰¹å®šã™ã‚‹ã®ã§ã¯ãªãã€å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åå‰ã‚’é–‹ç™ºæ™‚ã«æ±ºã‚ã¦ãŠã„ã¦ã€ãƒ©ãƒƒãƒ‘ãƒ¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã™ã‚‹æ–¹ãŒè‰¯ã„ "
"*ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“* ã€‚"

#: ../../library/ctypes.rst:1319
msgid "Loading shared libraries"
msgstr "å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹"

#: ../../library/ctypes.rst:1321
msgid ""
"There are several ways to load shared libraries into the Python process.  "
"One way is to instantiate one of the following classes:"
msgstr "å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ Python ãƒ—ãƒ­ã‚»ã‚¹ã¸ãƒ­ãƒ¼ãƒ‰ã™ã‚‹æ–¹æ³•ã¯ã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚ä¸€ã¤ã®æ–¹æ³•ã¯ä¸‹è¨˜ã®ã‚¯ãƒ©ã‚¹ã®ä¸€ã¤ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ã“ã¨ã§ã™:"

#: ../../library/ctypes.rst:1327
msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to "
"return :c:type:`int`."
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚ã‚‰ã‚ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®é–¢æ•°ã¯æ¨™æº– C å‘¼ã³å‡ºã—è¦ç´„ã‚’ä½¿ç”¨ã—ã€ "
":c:type:`int` ã‚’è¿”ã™ã¨ä»®å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1334
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are"
" assumed to return the windows specific :class:`HRESULT` code.  "
":class:`HRESULT` values contain information specifying whether the function "
"call failed or succeeded, together with additional error code.  If the "
"return value signals a failure, an :class:`OSError` is automatically raised."
msgstr ""
"Windows ç”¨: ã“ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚ã‚‰ã‚ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®é–¢æ•°ã¯ ``stdcall`` "
"å‘¼ã³å‡ºã—è¦ç´„ã‚’ä½¿ç”¨ã—ã€ windows å›ºæœ‰ã® :class:`HRESULT` ã‚³ãƒ¼ãƒ‰ã‚’è¿”ã™ã¨ä»®å®šã•ã‚Œã¾ã™ã€‚ :class:`HRESULT` "
"å€¤ã«ã¯é–¢æ•°å‘¼ã³å‡ºã—ãŒå¤±æ•—ã—ãŸã®ã‹æˆåŠŸã—ãŸã®ã‹ã‚’ç‰¹å®šã™ã‚‹æƒ…å ±ã¨ã¨ã‚‚ã«ã€è£œè¶³ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã¾ã™ã€‚æˆ»ã‚Šå€¤ãŒå¤±æ•—ã‚’çŸ¥ã‚‰ã›ãŸãªã‚‰ã°ã€ "
":class:`OSError` ãŒè‡ªå‹•çš„ã«é€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1341
msgid ":exc:`WindowsError` used to be raised."
msgstr "ä»¥å‰ã¯ :exc:`WindowsError` ã‚’é€å‡ºã—ã¦ã„ã¾ã—ãŸã€‚"

#: ../../library/ctypes.rst:1347
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are"
" assumed to return :c:type:`int` by default."
msgstr ""
"Windows ç”¨: ã“ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚ã‚‰ã‚ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®é–¢æ•°ã¯ ``stdcall`` "
"å‘¼ã³å‡ºã—è¦ç´„ã‚’ä½¿ç”¨ã—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ :c:type:`int` ã‚’è¿”ã™ã¨ä»®å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1351
msgid ""
"On Windows CE only the standard calling convention is used, for convenience "
"the :class:`WinDLL` and :class:`OleDLL` use the standard calling convention "
"on this platform."
msgstr ""
"Windows CE ã§ã¯æ¨™æº–å‘¼ã³å‡ºã—è¦ç´„ã ã‘ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ä¾¿å®œä¸Šã€ã“ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€ :class:`WinDLL` ã¨ "
":class:`OleDLL` ãŒæ¨™æº–å‘¼ã³å‡ºã—è¦ç´„ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1355
msgid ""
"The Python :term:`global interpreter lock` is released before calling any "
"function exported by these libraries, and reacquired afterwards."
msgstr ""
"ã“ã‚Œã‚‰ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã©ã®é–¢æ•°ã§ã‚‚å‘¼ã³å‡ºã™å‰ã« Python GIL (:term:`global interpreter lock`) "
"ã¯è§£æ”¾ã•ã‚Œã€å¾Œã§ã¾ãŸç²å¾—ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1361
msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that the"
" Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is "
"set, a Python exception is raised."
msgstr ""
"Python GIL ãŒé–¢æ•°å‘¼ã³å‡ºã—ã®é–“è§£æ”¾ *ã•ã‚Œãš* ã€é–¢æ•°å®Ÿè¡Œã®å¾Œã« Python "
"ã‚¨ãƒ©ãƒ¼ãƒ•ãƒ©ã‚°ãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œã‚‹ã¨ã„ã†ã“ã¨ã‚’é™¤ã‘ã°ã€ã“ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ :class:`CDLL` "
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã„ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ãƒ•ãƒ©ã‚°ãŒã‚»ãƒƒãƒˆã•ã‚ŒãŸå ´åˆã€ Python ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1366
msgid "Thus, this is only useful to call Python C api functions directly."
msgstr "è¦ã™ã‚‹ã«ã€ã“ã‚Œã¯ Python C api é–¢æ•°ã‚’ç›´æ¥å‘¼ã³å‡ºã™ã®ã«ä¾¿åˆ©ã ã¨ã„ã†ã ã‘ã§ã™ã€‚"

#: ../../library/ctypes.rst:1368
msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platforms ``dlopen`` or"
" ``LoadLibrary`` function is used to load the library into the process, and "
"to get a handle to it."
msgstr ""
"ã“ã‚Œã‚‰ã™ã¹ã¦ã®ã‚¯ãƒ©ã‚¹ã¯å°‘ãªãã¨ã‚‚ä¸€ã¤ã®å¼•æ•°ã€ã™ãªã‚ã¡ãƒ­ãƒ¼ãƒ‰ã™ã‚‹å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ‘ã‚¹ã‚’æ¸¡ã—ã¦å‘¼ã³å‡ºã™ã“ã¨ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚Œã¾ã™ã€‚ã™ã§ã«ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿ã®å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¸ã®ãƒãƒ³ãƒ‰ãƒ«ãŒã‚ã‚‹ãªã‚‰ã€"
" ``handle`` åå‰ä»˜ãå¼•æ•°ã¨ã—ã¦æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚åœŸå°ã¨ãªã£ã¦ã„ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã® ``dlopen`` ã¾ãŸã¯ "
"``LoadLibrary`` é–¢æ•°ãŒãƒ—ãƒ­ã‚»ã‚¹ã¸ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã€ãã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å¯¾ã™ã‚‹ãƒãƒ³ãƒ‰ãƒ«ã‚’å¾—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1375
msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  For "
"details, consult the :manpage:`dlopen(3)` manpage.  On Windows, *mode* is "
"ignored.  On posix systems, RTLD_NOW is always added, and is not "
"configurable."
msgstr ""
"*mode* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ä½¿ã†ã¨ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã©ã†ã‚„ã£ã¦ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸã‹ã‚’ç‰¹å®šã§ãã¾ã™ã€‚\n"
"è©³ç´°ã¯ :manpage:`dlopen(3)` ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚\n"
"Windows ã§ã¯ *mode* ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚\n"
"POSIX ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ RTLD_NOW ãŒå¸¸ã«è¿½åŠ ã•ã‚Œã€è¨­å®šå¤‰æ›´ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:1380
msgid ""
"The *use_errno* parameter, when set to true, enables a ctypes mechanism that"
" allows accessing the system :data:`errno` error number in a safe way. "
":mod:`ctypes` maintains a thread-local copy of the systems :data:`errno` "
"variable; if you call foreign functions created with ``use_errno=True`` then"
" the :data:`errno` value before the function call is swapped with the ctypes"
" private copy, the same happens immediately after the function call."
msgstr ""
"*use_errno* å¤‰æ•°ãŒçœŸã«è¨­å®šã•ã‚ŒãŸã¨ãã€ã‚·ã‚¹ãƒ†ãƒ ã® :data:`errno` ã‚¨ãƒ©ãƒ¼ãƒŠãƒ³ãƒãƒ¼ã«å®‰å…¨ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ ctypes "
"ã®ä»•çµ„ã¿ãŒæœ‰åŠ¹åŒ–ã•ã‚Œã¾ã™ã€‚ :mod:`ctypes` ã¯ã‚·ã‚¹ãƒ†ãƒ ã® :data:`errno` å¤‰æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰é™å®šã®ã‚³ãƒ”ãƒ¼ã‚’ç®¡ç†ã—ã¾ã™ã€‚ã‚‚ã—ã€ "
"``use_errno=True`` ã®çŠ¶æ…‹ã§ä½œã‚‰ã‚ŒãŸå¤–éƒ¨é–¢æ•°ã‚’å‘¼ã³å‡ºã—ãŸãªã‚‰ã€é–¢æ•°å‘¼ã³å‡ºã—å‰ã® :data:`errno` å¤‰æ•°ã¯ ctypes "
"ã®ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚³ãƒ”ãƒ¼ã¨ç½®ãæ›ãˆã‚‰ã‚Œã€åŒã˜ã“ã¨ãŒé–¢æ•°å‘¼ã³å‡ºã—ã®ç›´å¾Œã«ã‚‚ç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1387
msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the ctypes "
"private copy to a new value and returns the former value."
msgstr ""
":func:`ctypes.get_errno` é–¢æ•°ã¯ ctypes ã®ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚³ãƒ”ãƒ¼ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚ãã—ã¦ã€ "
":func:`ctypes.set_errno` é–¢æ•°ã¯ ctypes ã®ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚³ãƒ”ãƒ¼ã‚’ç½®ãæ›ãˆã€ä»¥å‰ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1391
msgid ""
"The *use_last_error* parameter, when set to true, enables the same mechanism"
" for the Windows error code which is managed by the :func:`GetLastError` and"
" :func:`SetLastError` Windows API functions; :func:`ctypes.get_last_error` "
"and :func:`ctypes.set_last_error` are used to request and change the ctypes "
"private copy of the windows error code."
msgstr ""
"*use_last_error* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ã€çœŸã«è¨­å®šã•ã‚ŒãŸã¨ãã€ :func:`GetLastError` ã¨ "
":func:`SetLastError` Windows API ã«ã‚ˆã£ã¦ç®¡ç†ã•ã‚Œã‚‹ Windows "
"ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã«å¯¾ã™ã‚‹ã®ã¨åŒã˜ä»•çµ„ã¿ãŒæœ‰åŠ¹åŒ–ã•ã‚Œã¾ã™ã€‚ :func:`ctypes.get_last_error` ã¨ "
":func:`ctypes.set_last_error` ã¯ Windows ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã® ctypes "
"ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚³ãƒ”ãƒ¼ã‚’å¤‰æ›´ã—ãŸã‚Šè¦æ±‚ã—ãŸã‚Šã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1400
msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr "*mode* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦ä½¿ã†ãƒ•ãƒ©ã‚°ã€‚ã“ã®ãƒ•ãƒ©ã‚°ãŒåˆ©ç”¨ã§ããªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€æ•´æ•°ã®ã‚¼ãƒ­ã¨å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1407
msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not available, "
"it is the same as *RTLD_GLOBAL*."
msgstr "*mode* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦ä½¿ã†ãƒ•ãƒ©ã‚°ã€‚ã“ã‚ŒãŒåˆ©ç”¨ã§ããªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€ *RTLD_GLOBAL* ã¨åŒæ§˜ã§ã™ã€‚"

#: ../../library/ctypes.rst:1414
msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, this "
"is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr ""
"å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ¼ãƒ‰ã€‚ OSX 10.3 ã§ã¯ *RTLD_GLOBAL* ã§ã‚ã‚Šã€ãã†ã§ãªã‘ã‚Œã° "
"*RTLD_LOCAL* ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/ctypes.rst:1417
msgid ""
"Instances of these classes have no public methods.  Functions exported by "
"the shared library can be accessed as attributes or by index.  Please note "
"that accessing the function through an attribute caches the result and "
"therefore accessing it repeatedly returns the same object each time.  On the"
" other hand, accessing it through an index returns a new object each time:"
msgstr ""
"ã“ã‚Œã‚‰ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã¯å…¬é–‹ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‹ã‚‰ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚ŒãŸé–¢æ•°ã¯ã€å±æ€§ã¨ã—ã¦ã€ã‚‚ã—ãã¯æ·»å­—ã§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚å±æ€§ã‚’é€šã—ãŸé–¢æ•°ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯çµæœãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã€å¾“ã£ã¦ç¹°ã‚Šè¿”ã—ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ã¨æ¯å›åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãã‚Œã¨ã¯åå¯¾ã«ã€æ·»å­—ã‚’é€šã—ãŸã‚¢ã‚¯ã‚»ã‚¹ã¯æ¯å›æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™:"

#: ../../library/ctypes.rst:1428
msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr "æ¬¡ã«è¿°ã¹ã‚‹å…¬é–‹å±æ€§ãŒåˆ©ç”¨ã§ãã¾ã™ã€‚ãã‚Œã‚‰ã®åå‰ã¯ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚ŒãŸé–¢æ•°åã«è¡çªã—ãªã„ã‚ˆã†ã«ä¸‹ç·šã§å§‹ã¾ã‚Šã¾ã™ã€‚:"

#: ../../library/ctypes.rst:1434
msgid "The system handle used to access the library."
msgstr "ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«ç”¨ã„ã‚‰ã‚Œã‚‹ã‚·ã‚¹ãƒ†ãƒ ãƒãƒ³ãƒ‰ãƒ«ã€‚"

#: ../../library/ctypes.rst:1439
msgid "The name of the library passed in the constructor."
msgstr "ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«æ¸¡ã•ã‚ŒãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åå‰ã€‚"

#: ../../library/ctypes.rst:1441
msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either by "
"calling the :meth:`LoadLibrary` method, or by retrieving the library as "
"attribute of the loader instance."
msgstr ""
"å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ (:class:`LibraryLoader` ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹) "
"å‰ã‚‚ã£ã¦ä½œã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸€ã¤ã‚’ä½¿ã†ã“ã¨ã«ã‚ˆã£ã¦ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ãã‚Œã‚‰ã® :meth:`LoadLibrary` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã‹ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ã¨ã—ã¦ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’å–ã‚Šå‡ºã™ã‹ã®ã©ã¡ã‚‰ã‹ã«ã‚ˆã‚Šãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1449
msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the "
":class:`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr ""
"å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‚¯ãƒ©ã‚¹ã€‚ *dlltype* ã¯ :class:`CDLL` ã€ :class:`PyDLL` ã€ "
":class:`WinDLL` ã‚‚ã—ãã¯ :class:`OleDLL` å‹ã®ä¸€ã¤ã§ã‚ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/ctypes.rst:1452
msgid ""
":meth:`__getattr__` has special behavior: It allows loading a shared library"
" by accessing it as attribute of a library loader instance.  The result is "
"cached, so repeated attribute accesses return the same library each time."
msgstr ""
":meth:`__getattr__` "
"ã¯æ¬¡ã®ã‚ˆã†ãªç‰¹åˆ¥ãªã¯ãŸã‚‰ãã‚’ã—ã¾ã™ã€‚ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ­ãƒ¼ãƒ€ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å±æ€§ã¨ã—ã¦å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ãã‚ŒãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã¨ã„ã†ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚çµæœã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¾ã™ã€‚ãã®ãŸã‚ã€ç¹°ã‚Šè¿”ã—å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¡Œã†ã¨ã„ã¤ã‚‚åŒã˜ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1458
msgid ""
"Load a shared library into the process and return it.  This method always "
"returns a new instance of the library."
msgstr "å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ãƒ—ãƒ­ã‚»ã‚¹ã¸ãƒ­ãƒ¼ãƒ‰ã—ã€ãã‚Œã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å¸¸ã«è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1462
msgid "These prefabricated library loaders are available:"
msgstr "ã“ã‚Œã‚‰ã®å‰ã‚‚ã£ã¦ä½œã‚‰ã‚ŒãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ­ãƒ¼ãƒ€ãƒ¼ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚:"

#: ../../library/ctypes.rst:1467
msgid "Creates :class:`CDLL` instances."
msgstr ":class:`CDLL` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1473
msgid "Windows only: Creates :class:`WinDLL` instances."
msgstr "Windows ç”¨: :class:`WinDLL` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1479
msgid "Windows only: Creates :class:`OleDLL` instances."
msgstr "Windows ç”¨: :class:`OleDLL` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1485
msgid "Creates :class:`PyDLL` instances."
msgstr ":class:`PyDLL` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1488
msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr ""
"C Python api ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«ã€ã™ãã«ä½¿ç”¨ã§ãã‚‹ Python å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ¬¡ã®ã‚ˆã†ã«ç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1494
msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C "
":c:type:`int`, which is of course not always the truth, so you have to "
"assign the correct :attr:`restype` attribute to use these functions."
msgstr ""
"å±æ€§ã¨ã—ã¦ Python C api é–¢æ•°ã‚’å…¬é–‹ã™ã‚‹ :class:`PyDLL` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€‚ã“ã‚Œã‚‰ã™ã¹ã¦ã®é–¢æ•°ã¯ C :c:type:`int`"
" ã‚’è¿”ã™ã¨ä»®å®šã•ã‚Œã¾ã™ãŒã€ã‚‚ã¡ã‚ã‚“å¸¸ã«æ­£ã—ã„ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€ã“ã‚Œã‚‰ã®é–¢æ•°ã‚’ä½¿ã†ãŸã‚ã«ã¯æ­£ã—ã„ :attr:`restype` "
"å±æ€§ã‚’ä»£å…¥ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:1503
msgid "Foreign functions"
msgstr "å¤–éƒ¨é–¢æ•°"

#: ../../library/ctypes.rst:1505
msgid ""
"As explained in the previous section, foreign functions can be accessed as "
"attributes of loaded shared libraries.  The function objects created in this"
" way by default accept any number of arguments, accept any ctypes data "
"instances as arguments, and return the default result type specified by the "
"library loader. They are instances of a private class:"
msgstr ""
"å‰ç¯€ã§èª¬æ˜ã—ãŸé€šã‚Šã€å¤–éƒ¨é–¢æ•°ã¯ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å±æ€§ã¨ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã“ã®æ–¹æ³•ã§ä½œæˆã•ã‚ŒãŸé–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã©ã‚“ãªæ•°ã®å¼•æ•°ã§ã‚‚å—ã‘å–ã‚Šã€å¼•æ•°ã¨ã—ã¦ã©ã‚“ãª"
" ctypes "
"ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã‚‚å—ã‘å–ã‚Šã€ãã—ã¦ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ­ãƒ¼ãƒ€ãƒ¼ãŒæŒ‡å®šã—ãŸãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®çµæœã®å€¤ã®å‹ã‚’è¿”ã—ã¾ã™ã€‚é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã™ã€‚:"

#: ../../library/ctypes.rst:1514
msgid "Base class for C callable foreign functions."
msgstr "C ã®å‘¼ã³å‡ºã—å¯èƒ½å¤–éƒ¨é–¢æ•°ã®ãŸã‚ã®ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã€‚"

#: ../../library/ctypes.rst:1516
msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr "å¤–éƒ¨é–¢æ•°ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚‚ C äº’æ›ãƒ‡ãƒ¼ã‚¿å‹ã§ã™ã€‚ãã‚Œã‚‰ã¯ C ã®é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã‚’è¡¨ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1519
msgid ""
"This behavior can be customized by assigning to special attributes of the "
"foreign function object."
msgstr "ã“ã®æŒ¯ã‚‹èˆã„ã¯å¤–éƒ¨é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç‰¹åˆ¥ãªå±æ€§ã«ä»£å…¥ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ctypes.rst:1524
msgid ""
"Assign a ctypes type to specify the result type of the foreign function. Use"
" ``None`` for :c:type:`void`, a function not returning anything."
msgstr ""
"å¤–éƒ¨é–¢æ•°ã®çµæœã®å‹ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã« ctypes å‹ã‚’ä»£å…¥ã™ã‚‹ã€‚ä½•ã‚‚è¿”ã•ãªã„é–¢æ•°ã‚’è¡¨ã™ :c:type:`void` ã«å¯¾ã—ã¦ã¯ ``None`` "
"ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1527
msgid ""
"It is possible to assign a callable Python object that is not a ctypes type,"
" in this case the function is assumed to return a C :c:type:`int`, and the "
"callable will be called with this integer, allowing further processing or "
"error checking.  Using this is deprecated, for more flexible post processing"
" or error checking use a ctypes data type as :attr:`restype` and assign a "
"callable to the :attr:`errcheck` attribute."
msgstr ""
"ctypes å‹ã§ã¯ãªã„å‘¼ã³å‡ºã—å¯èƒ½ãª Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»£å…¥ã™ã‚‹ã“ã¨ã¯å¯èƒ½ã§ã™ã€‚ã“ã®ã‚ˆã†ãªå ´åˆã€é–¢æ•°ãŒ C :c:type:`int` "
"ã‚’è¿”ã™ã¨ä»®å®šã•ã‚Œã€å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã“ã®æ•´æ•°ã‚’å¼•æ•°ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã•ã‚‰ã«å‡¦ç†ã‚’è¡Œã£ãŸã‚Šã€ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã‚’ã—ãŸã‚Šã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã§ã™ã€‚ã“ã‚Œã®ä½¿ç”¨ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“ã€‚ã‚ˆã‚ŠæŸ”è»Ÿãªå¾Œå‡¦ç†ã‚„ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã®ãŸã‚ã«ã¯"
" :attr:`restype` ã¨ã—ã¦ ctypes å‹ã‚’ä½¿ã„ã€ :attr:`errcheck` å±æ€§ã¸å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»£å…¥ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/ctypes.rst:1536
msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can "
"only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr ""
"é–¢æ•°ãŒå—ã‘å–ã‚‹å¼•æ•°ã®å‹ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã« ctypes å‹ã®ã‚¿ãƒ—ãƒ«ã‚’ä»£å…¥ã—ã¾ã™ã€‚``stdcall`` "
"å‘¼ã³å‡ºã—è¦ç´„ã‚’ä½¿ã†é–¢æ•°ã¯ã“ã®ã‚¿ãƒ—ãƒ«ã®é•·ã•ã¨åŒã˜æ•°ã®å¼•æ•°ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚C å‘¼ã³å‡ºã—è¦ç´„ã‚’ä½¿ã†é–¢æ•°ã¯ã€è¿½åŠ ã®ä¸ç‰¹å®šã®å¼•æ•°ã‚‚å–ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1542
msgid ""
"When a foreign function is called, each actual argument is passed to the "
":meth:`from_param` class method of the items in the :attr:`argtypes` tuple, "
"this method allows adapting the actual argument to an object that the "
"foreign function accepts.  For example, a :class:`c_char_p` item in the "
":attr:`argtypes` tuple will convert a string passed as argument into a bytes"
" object using ctypes conversion rules."
msgstr ""
"å¤–éƒ¨é–¢æ•°ãŒå‘¼ã°ã‚ŒãŸã¨ãã€ãã‚Œãã‚Œã®å®Ÿå¼•æ•°ã¯ :attr:`argtypes` ã‚¿ãƒ—ãƒ«ã®è¦ç´ ã® :meth:`from_param` "
"ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¸æ¸¡ã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å®Ÿå¼•æ•°ã‚’å¤–éƒ¨é–¢æ•°ãŒå—ã‘å–ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åˆã‚ã›ã¦å¤‰ãˆã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ "
":attr:`argtypes` ã‚¿ãƒ—ãƒ«ã® :class:`c_char_p` è¦ç´ ã¯ã€ ctypes "
"å¤‰æ›è¦å‰‡ã«ã—ãŸãŒã£ã¦å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚ŒãŸæ–‡å­—åˆ—ã‚’ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸å¤‰æ›ã™ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/ctypes.rst:1549
msgid ""
"New: It is now possible to put items in argtypes which are not ctypes types,"
" but each item must have a :meth:`from_param` method which returns a value "
"usable as argument (integer, string, ctypes instance).  This allows defining"
" adapters that can adapt custom objects as function parameters."
msgstr ""
"æ–°: ctypes å‹ã§ãªã„è¦ç´ ã‚’ argtypes ã«å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€å€‹ã€…ã®è¦ç´ ã¯å¼•æ•°ã¨ã—ã¦ä½¿ãˆã‚‹å€¤ (æ•´æ•°ã€æ–‡å­—åˆ—ã€ ctypes "
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹) ã‚’è¿”ã™ :meth:`from_param` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã«ã‚ˆã‚Šé–¢æ•°ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦ã‚«ã‚¹ã‚¿ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é©åˆã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ã§ãã‚‹ã‚¢ãƒ€ãƒ—ã‚¿ãŒå®šç¾©å¯èƒ½ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1556
msgid ""
"Assign a Python function or another callable to this attribute. The callable"
" will be called with three or more arguments:"
msgstr ""
"Python é–¢æ•°ã¾ãŸã¯ä»–ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã“ã®å±æ€§ã«ä»£å…¥ã—ã¾ã™ã€‚å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸‰ã¤ä»¥ä¸Šã®å¼•æ•°ã¨ã¨ã‚‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1563
msgid ""
"*result* is what the foreign function returns, as specified by the "
":attr:`restype` attribute."
msgstr "*result* ã¯å¤–éƒ¨é–¢æ•°ãŒè¿”ã™ã‚‚ã®ã§ã€ :attr:`restype` å±æ€§ã§æŒ‡å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1566
msgid ""
"*func* is the foreign function object itself, this allows reusing the same "
"callable object to check or post process the results of several functions."
msgstr ""
"*func* "
"ã¯å¤–éƒ¨é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªèº«ã§ã€ã“ã‚Œã«ã‚ˆã‚Šè¤‡æ•°ã®é–¢æ•°ã®å‡¦ç†çµæœã‚’ãƒã‚§ãƒƒã‚¯ã¾ãŸã¯å¾Œå‡¦ç†ã™ã‚‹ãŸã‚ã«ã€åŒã˜å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1570
msgid ""
"*arguments* is a tuple containing the parameters originally passed to the "
"function call, this allows specializing the behavior on the arguments used."
msgstr ""
"*arguments* "
"ã¯é–¢æ•°å‘¼ã³å‡ºã—ã«æœ€åˆã«æ¸¡ã•ã‚ŒãŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå…¥ã£ãŸã‚¿ãƒ—ãƒ«ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šä½¿ã‚ã‚ŒãŸå¼•æ•°ã«åŸºã¥ã„ãŸç‰¹åˆ¥ãªæŒ¯ã‚‹èˆã„ã‚’ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1574
msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an exception"
" if the foreign function call failed."
msgstr ""
"ã“ã®é–¢æ•°ãŒè¿”ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤–éƒ¨é–¢æ•°å‘¼ã³å‡ºã—ã‹ã‚‰è¿”ã•ã‚ŒãŸå€¤ã§ã—ã‚‡ã†ã€‚ã—ã‹ã—ã€æˆ»ã‚Šå€¤ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã€å¤–éƒ¨é–¢æ•°å‘¼ã³å‡ºã—ãŒå¤±æ•—ã—ã¦ã„ã‚‹ãªã‚‰ä¾‹å¤–ã‚’é€å‡ºã•ã›ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../library/ctypes.rst:1581
msgid ""
"This exception is raised when a foreign function call cannot convert one of "
"the passed arguments."
msgstr "ã“ã®ä¾‹å¤–ã¯å¤–éƒ¨é–¢æ•°å‘¼ã³å‡ºã—ãŒæ¸¡ã•ã‚ŒãŸå¼•æ•°ã‚’å¤‰æ›ã§ããªã‹ã£ãŸã¨ãã«é€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1588
msgid "Function prototypes"
msgstr "é–¢æ•°ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—"

#: ../../library/ctypes.rst:1590
msgid ""
"Foreign functions can also be created by instantiating function prototypes. "
"Function prototypes are similar to function prototypes in C; they describe a"
" function (return type, argument types, calling convention) without defining"
" an implementation.  The factory functions must be called with the desired "
"result type and the argument types of the function, and can be used as "
"decorator factories, and as such, be applied to functions through the "
"``@wrapper`` syntax. See :ref:`ctypes-callback-functions` for examples."
msgstr ""

#: ../../library/ctypes.rst:1601
msgid ""
"The returned function prototype creates functions that use the standard C "
"calling convention.  The function will release the GIL during the call.  If "
"*use_errno* is set to true, the ctypes private copy of the system "
":data:`errno` variable is exchanged with the real :data:`errno` value before"
" and after the call; *use_last_error* does the same for the Windows error "
"code."
msgstr ""
"è¿”ã•ã‚ŒãŸé–¢æ•°ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ã¯æ¨™æº– C å‘¼ã³å‡ºã—è¦ç´„ã‚’ã¤ã‹ã†é–¢æ•°ã‚’ä½œæˆã—ã¾ã™ã€‚é–¢æ•°ã¯å‘¼ã³å‡ºã•ã‚Œã¦ã„ã‚‹é–“ GIL ã‚’è§£æ”¾ã—ã¾ã™ã€‚ *use_errno* "
"ãŒçœŸã«è¨­å®šã•ã‚Œã‚Œã°ã€å‘¼ã³å‡ºã—ã®å‰å¾Œã§ System å¤‰æ•° :data:`errno` ã® ctypesãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚³ãƒ”ãƒ¼ã¯æœ¬å½“ã® "
":data:`errno` ã®å€¤ã¨äº¤æ›ã•ã‚Œã¾ã™ã€‚ *use_last_error* ã‚‚ Windows ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã«å¯¾ã™ã‚‹ã®ã¨åŒæ§˜ã§ã™ã€‚"

#: ../../library/ctypes.rst:1611
msgid ""
"Windows only: The returned function prototype creates functions that use the"
" ``stdcall`` calling convention, except on Windows CE where "
":func:`WINFUNCTYPE` is the same as :func:`CFUNCTYPE`.  The function will "
"release the GIL during the call.  *use_errno* and *use_last_error* have the "
"same meaning as above."
msgstr ""
"Windows ã®ã¿: è¿”ã•ã‚ŒãŸé–¢æ•°ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ã¯ ``stdcall`` å‘¼ã³å‡ºã—è¦ç´„ã‚’ä½¿ã†é–¢æ•°ã‚’ä½œæˆã—ã¾ã™ã€‚ãŸã ã—ã€ "
":func:`WINFUNCTYPE` ãŒ :func:`CFUNCTYPE` ã¨åŒã˜ã§ã‚ã‚‹ Windows CE ã‚’é™¤ãã¾ã™ã€‚é–¢æ•°ã¯å‘¼ã³å‡ºã•ã‚Œã¦ã„ã‚‹é–“"
" GIL ã‚’è§£æ”¾ã—ã¾ã™ã€‚ *use_errno* ã¨ *use_last_error* ã¯å‰è¿°ã¨åŒã˜æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1620
msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the "
"call."
msgstr "è¿”ã•ã‚ŒãŸé–¢æ•°ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ã¯ Python å‘¼ã³å‡ºã—è¦ç´„ã‚’ä½¿ã†é–¢æ•°ã‚’ä½œæˆã—ã¾ã™ã€‚é–¢æ•°ã¯å‘¼ã³å‡ºã•ã‚Œã¦ã„ã‚‹é–“ GIL ã‚’è§£æ”¾ *ã—ã¾ã›ã‚“*ã€‚"

#: ../../library/ctypes.rst:1623
msgid ""
"Function prototypes created by these factory functions can be instantiated "
"in different ways, depending on the type and number of the parameters in the"
" call:"
msgstr "ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã«ã‚ˆã£ã¦ä½œã‚‰ã‚ŒãŸé–¢æ•°ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ã¯å‘¼ã³å‡ºã—ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã¨æ•°ã«ä¾å­˜ã—ãŸåˆ¥ã®æ–¹æ³•ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ :"

#: ../../library/ctypes.rst:1631
msgid ""
"Returns a foreign function at the specified address which must be an "
"integer."
msgstr "æŒ‡å®šã•ã‚ŒãŸã‚¢ãƒ‰ãƒ¬ã‚¹(æ•´æ•°ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“)ã®å¤–éƒ¨é–¢æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1638
msgid ""
"Create a C callable function (a callback function) from a Python *callable*."
msgstr "Python ã® *callable* ã‹ã‚‰ C ã®å‘¼ã³å‡ºã—å¯èƒ½é–¢æ•°(ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°) ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1645
msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must be"
" a 2-tuple ``(name_or_ordinal, library)``. The first item is the name of the"
" exported function as string, or the ordinal of the exported function as "
"small integer.  The second item is the shared library instance."
msgstr ""
"å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹å¤–éƒ¨é–¢æ•°ã‚’è¿”ã—ã¾ã™ã€‚ *func_spec* ã¯ 2 è¦ç´ ã‚¿ãƒ—ãƒ« ``(name_or_ordinal, "
"library)`` "
"ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ç¬¬ä¸€è¦ç´ ã¯ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚ŒãŸé–¢æ•°ã®åå‰ã§ã‚ã‚‹æ–‡å­—åˆ—ã€ã¾ãŸã¯ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚ŒãŸé–¢æ•°ã®åºæ•°ã§ã‚ã‚‹å°ã•ã„æ•´æ•°ã§ã™ã€‚ç¬¬äºŒè¦ç´ ã¯å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã™ã€‚"

#: ../../library/ctypes.rst:1655
msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is the "
"index into the virtual function table, a small non-negative integer. *name* "
"is name of the COM method. *iid* is an optional pointer to the interface "
"identifier which is used in extended error reporting."
msgstr ""
"COM ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™å¤–éƒ¨é–¢æ•°ã‚’è¿”ã—ã¾ã™ã€‚ *vtbl_index* ã¯ä»®æƒ³é–¢æ•°ãƒ†ãƒ¼ãƒ–ãƒ«ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã€éè² ã®å°ã•ã„æ•´æ•°ã§ã™ã€‚ *name* ã¯ "
"COM ãƒ¡ã‚½ãƒƒãƒ‰ã®åå‰ã§ã™ã€‚ *iid* ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹è­˜åˆ¥å­ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ã€æ‹¡å¼µã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼æƒ…å ±ã®æä¾›ã®ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1660
msgid ""
"COM methods use a special calling convention: They require a pointer to the "
"COM interface as first argument, in addition to those parameters that are "
"specified in the :attr:`argtypes` tuple."
msgstr ""
"COM ãƒ¡ã‚½ãƒƒãƒ‰ã¯ç‰¹æ®Šãªå‘¼ã³å‡ºã—è¦ç´„ã‚’ç”¨ã„ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :attr:`argtypes` ã‚¿ãƒ—ãƒ«ã«æŒ‡å®šã•ã‚ŒãŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«åŠ ãˆã¦ã€ç¬¬ä¸€å¼•æ•°ã¨ã—ã¦ "
"COM ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å¿…è¦ã¨ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1664
msgid ""
"The optional *paramflags* parameter creates foreign function wrappers with "
"much more functionality than the features described above."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *paramflags* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ä¸Šè¿°ã—ãŸæ©Ÿèƒ½ã‚ˆã‚Šå¤šæ©Ÿèƒ½ãªå¤–éƒ¨é–¢æ•°ãƒ©ãƒƒãƒ‘ãƒ¼ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1667
msgid "*paramflags* must be a tuple of the same length as :attr:`argtypes`."
msgstr "*paramflags* ã¯ :attr:`argtypes` ã¨åŒã˜é•·ã•ã®ã‚¿ãƒ—ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:1669
msgid ""
"Each item in this tuple contains further information about a parameter, it "
"must be a tuple containing one, two, or three items."
msgstr "ã“ã®ã‚¿ãƒ—ãƒ«ã®å€‹ã€…ã®è¦ç´ ã¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã¤ã„ã¦ã®ã‚ˆã‚Šè©³ç´°ãªæƒ…å ±ã‚’æŒã¡ã€ 1 ã€ 2 ã‚‚ã—ãã¯ 3 è¦ç´ ã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:1672
msgid ""
"The first item is an integer containing a combination of direction flags for"
" the parameter:"
msgstr "ç¬¬ä¸€è¦ç´ ã¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã¤ã„ã¦ã®ãƒ•ãƒ©ã‚°ã®çµ„ã¿åˆã‚ã›ã‚’å«ã‚“ã æ•´æ•°ã§ã™ã€‚"

#: ../../library/ctypes.rst:1676
msgid "1"
msgstr "1"

#: ../../library/ctypes.rst:1676
msgid "Specifies an input parameter to the function."
msgstr "å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é–¢æ•°ã«æŒ‡å®šã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1679
msgid "2"
msgstr "2"

#: ../../library/ctypes.rst:1679
msgid "Output parameter.  The foreign function fills in a value."
msgstr "å‡ºåŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€‚å¤–éƒ¨é–¢æ•°ãŒå€¤ã‚’æ›¸ãè¾¼ã¿ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1682
msgid "4"
msgstr "4"

#: ../../library/ctypes.rst:1682
msgid "Input parameter which defaults to the integer zero."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æ•´æ•°ã‚¼ãƒ­ã«ãªã‚‹å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€‚"

#: ../../library/ctypes.rst:1684
msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ç¬¬äºŒè¦ç´ ã¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åã®æ–‡å­—åˆ—ã§ã™ã€‚ã“ã‚ŒãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã¯ã€å¤–éƒ¨é–¢æ•°ã‚’åå‰ä»˜ããƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ctypes.rst:1687
msgid "The optional third item is the default value for this parameter."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ç¬¬ä¸‰è¦ç´ ã¯ã“ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§ã™ã€‚"

#: ../../library/ctypes.rst:1689
msgid ""
"This example demonstrates how to wrap the Windows ``MessageBoxW`` function "
"so that it supports default parameters and named arguments. The C "
"declaration from the windows header file is this::"
msgstr ""
"ã“ã®ä¾‹ã§ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨åå‰ä»˜ãå¼•æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã« Windows ã® ``MessageBoxW`` é–¢æ•°ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚\n"
"windows ã®ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã® C ã®å®£è¨€ã¯æ¬¡ã®é€šã‚Šã§ã™::"

#: ../../library/ctypes.rst:1700 ../../library/ctypes.rst:1723
msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr ":mod:`ctypes` ã‚’ä½¿ã£ã¦ãƒ©ãƒƒãƒ—ã—ã¾ã™ã€‚::"

#: ../../library/ctypes.rst:1708
msgid "The ``MessageBox`` foreign function can now be called in these ways::"
msgstr "ã“ã‚Œã§å¤–éƒ¨é–¢æ•°ã® ``MessageBox`` ã‚’æ¬¡ã®ã‚ˆã†ãªæ–¹æ³•ã§å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸ::"

#: ../../library/ctypes.rst:1714
msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window by"
" copying them into ``RECT`` structure that the caller has to supply.  Here "
"is the C declaration::"
msgstr ""
"äºŒç•ªç›®ã®ä¾‹ã¯å‡ºåŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚ win32 ã® ``GetWindowRect`` "
"é–¢æ•°ã¯ã€æŒ‡å®šã•ã‚ŒãŸã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®å¤§ãã•ã‚’å‘¼ã³å‡ºã—å´ãŒä¸ãˆã‚‹ ``RECT`` æ§‹é€ ä½“ã¸ã‚³ãƒ”ãƒ¼ã™ã‚‹ã“ã¨ã§å–ã‚Šå‡ºã—ã¾ã™ã€‚ C ã®å®£è¨€ã¯ã“ã†ã§ã™ã€‚::"

#: ../../library/ctypes.rst:1732
msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the output "
"parameter values when there are more than one, so the GetWindowRect function"
" now returns a RECT instance, when called."
msgstr ""
"å‡ºåŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒã¤é–¢æ•°ã¯ã€å˜ä¸€ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã«ã¯ãã®å‡ºåŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å€¤ã‚’ã€è¤‡æ•°ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã«ã¯å‡ºåŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å€¤ãŒå…¥ã£ãŸã‚¿ãƒ—ãƒ«ã‚’ã€ãã‚Œãã‚Œè‡ªå‹•çš„ã«è¿”ã—ã¾ã™ã€‚ãã®ãŸã‚ã€GetWindowRect"
" é–¢æ•°ã¯å‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ RECT ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1737
msgid ""
"Output parameters can be combined with the :attr:`errcheck` protocol to do "
"further output processing and error checking.  The win32 ``GetWindowRect`` "
"api function returns a ``BOOL`` to signal success or failure, so this "
"function could do the error checking, and raises an exception when the api "
"call failed::"
msgstr ""
"ã•ã‚‰ã«å‡ºåŠ›å‡¦ç†ã‚„ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†ãŸã‚ã«ã€å‡ºåŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ :attr:`errcheck` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ win32 "
"``GetWindowRect`` api é–¢æ•°ã¯æˆåŠŸã—ãŸã‹å¤±æ•—ã—ãŸã‹ã‚’çŸ¥ã‚‰ã›ã‚‹ãŸã‚ã« ``BOOL`` "
"ã‚’è¿”ã—ã¾ã™ã€‚ãã®ãŸã‚ã€ã“ã®é–¢æ•°ã¯ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã£ã¦ã€ api å‘¼ã³å‡ºã—ãŒå¤±æ•—ã—ãŸå ´åˆã«ä¾‹å¤–ã‚’é€å‡ºã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚::"

#: ../../library/ctypes.rst:1750
msgid ""
"If the :attr:`errcheck` function returns the argument tuple it receives "
"unchanged, :mod:`ctypes` continues the normal processing it does on the "
"output parameters.  If you want to return a tuple of window coordinates "
"instead of a ``RECT`` instance, you can retrieve the fields in the function "
"and return them instead, the normal processing will no longer take place::"
msgstr ""
":attr:`errcheck` é–¢æ•°ãŒå—ã‘å–ã£ãŸå¼•æ•°ã‚¿ãƒ—ãƒ«ã‚’å¤‰æ›´ãªã—ã«è¿”ã—ãŸå ´åˆã€ :mod:`ctypes` "
"ã¯å‡ºåŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹é€šå¸¸ã®å‡¦ç†ã‚’ç¶šã‘ã¾ã™ã€‚ ``RECT`` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä»£ã‚ã‚Šã« window "
"åº§æ¨™ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã™ã«ã¯ã€é–¢æ•°ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å–ã‚Šå‡ºã—ã€ä»£ã‚ã‚Šã«ãã‚Œã‚‰ã‚’è¿”ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®å ´åˆã€é€šå¸¸å‡¦ç†ã¯è¡Œã‚ã‚Œãªããªã‚Šã¾ã™::"

#: ../../library/ctypes.rst:1769
msgid "Utility functions"
msgstr "ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¼é–¢æ•°"

#: ../../library/ctypes.rst:1773
msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr "ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ç¤ºã™æ•´æ•°ã‚’è¿”ã—ã¾ã™ã€‚ *obj* ã¯ ctypes å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:1779
msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must be a"
" ctypes type or instance."
msgstr ""
"ctypes å‹ã®ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã®å¿…è¦æ¡ä»¶ã‚’è¿”ã—ã¾ã™ã€‚ *obj_or_type* ã¯ ctypes å‹ã¾ãŸã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:1785
msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will be"
" added to the internal pointer value."
msgstr ""
"*obj* (ctypes å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„) ã¸ã®è»½é‡ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ *offset* ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ 0 "
"ã§ã€å†…éƒ¨ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¸åŠ ç®—ã•ã‚Œã‚‹æ•´æ•°ã§ã™ã€‚"

#: ../../library/ctypes.rst:1789
msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr "``byref(obj, offset)`` ã¯ã€ C ã‚³ãƒ¼ãƒ‰ã¨ã—ã¦ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã¿ãªã•ã‚Œã¾ã™ã€‚::"

#: ../../library/ctypes.rst:1793
msgid ""
"The returned object can only be used as a foreign function call parameter. "
"It behaves similar to ``pointer(obj)``, but the construction is a lot "
"faster."
msgstr ""
"è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤–éƒ¨é–¢æ•°å‘¼ã³å‡ºã—ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚``pointer(obj)`` "
"ã¨ä¼¼ãŸãµã‚‹ã¾ã„ã‚’ã—ã¾ã™ãŒã€ä½œæˆãŒéå¸¸ã«é€Ÿãè¡Œãˆã¾ã™ã€‚"

#: ../../library/ctypes.rst:1799
msgid ""
"This function is similar to the cast operator in C. It returns a new "
"instance of *type* which points to the same memory block as *obj*.  *type* "
"must be a pointer type, and *obj* must be an object that can be interpreted "
"as a pointer."
msgstr ""
"ã“ã®é–¢æ•°ã¯ C ã®ã‚­ãƒ£ã‚¹ãƒˆæ¼”ç®—å­ã«ä¼¼ã¦ã„ã¾ã™ã€‚*obj* ã¨åŒã˜ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’æŒ‡ã—ã¦ã„ã‚‹ *type* ã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚*type* "
"ã¯ãƒã‚¤ãƒ³ã‚¿å‹ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€*obj* ã¯ãƒã‚¤ãƒ³ã‚¿ã¨ã—ã¦è§£é‡ˆã§ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:1807
msgid ""
"This function creates a mutable character buffer. The returned object is a "
"ctypes array of :class:`c_char`."
msgstr "ã“ã®é–¢æ•°ã¯å¤‰æ›´å¯èƒ½ãªæ–‡å­—ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆã—ã¾ã™ã€‚è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :class:`c_char` ã® ctypes é…åˆ—ã§ã™ã€‚"

#: ../../library/ctypes.rst:1810
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a bytes object which will be used to initialize the array items."
msgstr ""
"*init_or_size* ã¯é…åˆ—ã®ã‚µã‚¤ã‚ºã‚’æŒ‡å®šã™ã‚‹æ•´æ•°ã‚‚ã—ãã¯é…åˆ—è¦ç´ ã‚’åˆæœŸåŒ–ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1813
msgid ""
"If a bytes object is specified as first argument, the buffer is made one "
"item larger than its length so that the last element in the array is a NUL "
"termination character. An integer can be passed as second argument which "
"allows specifying the size of the array if the length of the bytes should "
"not be used."
msgstr ""
"ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç¬¬ä¸€å¼•æ•°ã¨ã—ã¦æŒ‡å®šã•ã‚Œã¦ã„ãŸå ´åˆã€é…åˆ—ã®æœ€å¾Œã®è¦ç´ ãŒ NUL çµ‚ç«¯æ–‡å­—ã¨ãªã‚‹ã‚ˆã†ã«ã€ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é•·ã•ã‚ˆã‚Š 1 "
"ã¤é•·ã„ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆã—ã¾ã™ã€‚ãƒã‚¤ãƒˆåˆ—ã®é•·ã•ã‚’ä½¿ã†ã¹ãã§ã¯ãªã„å ´åˆã¯ã€ç¬¬äºŒå¼•æ•°ã¨ã—ã¦æ•´æ•°ã‚’æ¸¡ã—ã¦ã€é…åˆ—ã®é•·ã•ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ctypes.rst:1822
msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr ""
"ã“ã®é–¢æ•°ã¯å¤‰æ›´å¯èƒ½ãª Unicode æ–‡å­—ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆã—ã¾ã™ã€‚è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :class:`c_wchar` ã® ctypes é…åˆ—ã§ã™ã€‚"

#: ../../library/ctypes.rst:1825
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a string which will be used to initialize the array items."
msgstr "*init_or_size* ã¯é…åˆ—ã®ã‚µã‚¤ã‚ºã‚’æŒ‡å®šã™ã‚‹æ•´æ•°ã‚‚ã—ãã¯é…åˆ—è¦ç´ ã‚’åˆæœŸåŒ–ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹æ–‡å­—åˆ—ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1828
msgid ""
"If a string is specified as first argument, the buffer is made one item "
"larger than the length of the string so that the last element in the array "
"is a NUL termination character. An integer can be passed as second argument "
"which allows specifying the size of the array if the length of the string "
"should not be used."
msgstr ""
"ç¬¬ä¸€å¼•æ•°ã¨ã—ã¦æ–‡å­—åˆ—ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã¯ã€ãƒãƒƒãƒ•ã‚¡ãŒæ–‡å­—åˆ—ã®é•·ã•ã‚ˆã‚Šä¸€è¦ç´ åˆ†å¤§ããä½œã‚‰ã‚Œã¾ã™ã€‚é…åˆ—ã®æœ€å¾Œã®è¦ç´ ãŒ NUL "
"çµ‚ç«¯æ–‡å­—ã§ã‚ã‚‹ãŸã‚ã§ã™ã€‚æ–‡å­—åˆ—ã®é•·ã•ã‚’ä½¿ã†ã¹ãã§ãªã„å ´åˆã¯ã€é…åˆ—ã®ã‚µã‚¤ã‚ºã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«æ•´æ•°ã‚’ç¬¬äºŒå¼•æ•°ã¨ã—ã¦æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ctypes.rst:1838
msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllCanUnloadNow function "
"that the _ctypes extension dll exports."
msgstr ""
"Windows ç”¨: ã“ã®é–¢æ•°ã¯ ctypes ã‚’ã¤ã‹ã£ã¦ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ COM ã‚µãƒ¼ãƒãƒ¼ã‚’å®Ÿè£…ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®ãƒ•ãƒƒã‚¯ã§ã™ã€‚_ctypes æ‹¡å¼µ "
"dll ãŒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ DllCanUnloadNow é–¢æ•°ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1845
msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllGetClassObject function "
"that the ``_ctypes`` extension dll exports."
msgstr ""
"Windows ç”¨: ã“ã®é–¢æ•°ã¯ ctypes ã‚’ã¤ã‹ã£ã¦ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ COM ã‚µãƒ¼ãƒãƒ¼ã‚’å®Ÿè£…ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®ãƒ•ãƒƒã‚¯ã§ã™ã€‚``_ctypes`` "
"æ‹¡å¼µ dll ãŒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ DllGetClassObject é–¢æ•°ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1853
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’æ¤œç´¢ã—ã€ãƒ‘ã‚¹åã‚’è¿”ã—ã¾ã™ã€‚ *name* ã¯ ``lib`` ã®ã‚ˆã†ãªæ¥é ­è¾ã€ ``.so`` ã‚„ ``.dylib`` "
"ã®ã‚ˆã†ãªæ¥å°¾è¾ã€ãã—ã¦ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒŠãƒ³ãƒãƒ¼ã‚’é™¤ããƒ©ã‚¤ãƒ–ãƒ©ãƒªåã§ã™ (ã“ã‚Œã¯ posix ã®ãƒªãƒ³ã‚«ãƒ¼ã‚ªãƒ—ã‚·ãƒ§ãƒ³ :option:`!-l` "
"ã§ä½¿ã‚ã‚Œã‚‹æ›¸å¼ã§ã™) ã€‚ã‚‚ã—ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ã€ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1864
msgid ""
"Windows only: return the filename of the VC runtime library used by Python, "
"and by the extension modules.  If the name of the library cannot be "
"determined, ``None`` is returned."
msgstr ""
"Windows ç”¨: Python ã¨æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä½¿ã‚ã‚Œã‚‹ VC ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—ãƒ©ã‚¤ãƒ–ãƒ©ãƒªåãŒåŒå®šã§ããªã‘ã‚Œã°ã€ "
"``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1868
msgid ""
"If you need to free memory, for example, allocated by an extension module "
"with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr ""
"ã‚‚ã—ã€ä¾‹ãˆã°æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ˆã‚Šå‰²ã‚Šä»˜ã‘ã‚‰ã‚ŒãŸãƒ¡ãƒ¢ãƒªã‚’ ``free(void *)`` "
"ã§è§£æ”¾ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãªã‚‰ã€ãƒ¡ãƒ¢ãƒªå‰²ã‚Šä»˜ã‘ã‚’è¡Œã£ãŸã®ã¨åŒã˜ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®é–¢æ•°ã‚’ä½¿ã†ã“ã¨ãŒé‡è¦ã§ã™ã€‚"

#: ../../library/ctypes.rst:1875
msgid ""
"Windows only: Returns a textual description of the error code *code*.  If no"
" error code is specified, the last error code is used by calling the Windows"
" api function GetLastError."
msgstr ""
"Windows ç”¨: ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ *code* ã®èª¬æ˜æ–‡ã‚’è¿”ã—ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ãŒæŒ‡å®šã•ã‚Œãªã„å ´åˆã¯ã€ Windows api é–¢æ•° "
"GetLastError ã‚’å‘¼ã³å‡ºã—ã¦ã€ã‚‚ã£ã¨ã‚‚æ–°ã—ã„ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1882
msgid ""
"Windows only: Returns the last error code set by Windows in the calling "
"thread. This function calls the Windows `GetLastError()` function directly, "
"it does not return the ctypes-private copy of the error code."
msgstr ""
"Windows ç”¨: å‘¼ã³å‡ºã—å´ã®ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã§ Windows ã«ã‚ˆã£ã¦è¨­å®šã•ã‚ŒãŸæœ€æ–°ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ Windows ã® "
"`GetLastError()` é–¢æ•°ã‚’ç›´æ¥å®Ÿè¡Œã—ã¾ã™ã€‚ ctypes ã®ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ãŸã‚Šã¯ã—ã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:1888
msgid ""
"Returns the current value of the ctypes-private copy of the system "
":data:`errno` variable in the calling thread."
msgstr "ã‚·ã‚¹ãƒ†ãƒ ã® :data:`errno` å¤‰æ•°ã®ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ­ãƒ¼ã‚«ãƒ«ãªãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1893
msgid ""
"Windows only: returns the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread."
msgstr "Windows ç”¨: ã‚·ã‚¹ãƒ†ãƒ ã® :data:`LastError` å¤‰æ•°ã®ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ­ãƒ¼ã‚«ãƒ«ãªãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1898
msgid ""
"Same as the standard C memmove library function: copies *count* bytes from "
"*src* to *dst*. *dst* and *src* must be integers or ctypes instances that "
"can be converted to pointers."
msgstr ""
"æ¨™æº– C ã® memmove ãƒ©ã‚¤ãƒ–ãƒ©ãƒªé–¢æ•°ã¨åŒã˜ã‚‚ã®ã§ã™ã€‚: *count* ãƒã‚¤ãƒˆã‚’ *src* ã‹ã‚‰ *dst* ã¸ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚ *dst* ã¨"
" *src* ã¯ãƒã‚¤ãƒ³ã‚¿ã¸å¤‰æ›å¯èƒ½ãªæ•´æ•°ã¾ãŸã¯ ctypes ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:1905
msgid ""
"Same as the standard C memset library function: fills the memory block at "
"address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr ""
"æ¨™æº– C ã® memset ãƒ©ã‚¤ãƒ–ãƒ©ãƒªé–¢æ•°ã¨åŒã˜ã‚‚ã®ã§ã™ã€‚: ã‚¢ãƒ‰ãƒ¬ã‚¹ *dst* ã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’å€¤ *c* ã‚’ *count* "
"ãƒã‚¤ãƒˆåˆ†æ›¸ãè¾¼ã¿ã¾ã™ã€‚ *dst* ã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®šã™ã‚‹æ•´æ•°ã¾ãŸã¯ ctypes ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:1912
msgid ""
"This factory function creates and returns a new ctypes pointer type. Pointer"
" types are cached and reused internally, so calling this function repeatedly"
" is cheap. *type* must be a ctypes type."
msgstr ""
"ã“ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã¯æ–°ã—ã„ ctypes "
"ãƒã‚¤ãƒ³ã‚¿å‹ã‚’ä½œæˆã—ã¦è¿”ã—ã¾ã™ã€‚ãƒã‚¤ãƒ³ã‚¿å‹ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã€å†…éƒ¨ã§å†åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ã“ã®é–¢æ•°ã‚’ç¹°ã‚Šè¿”ã—å‘¼ã³å‡ºã—ã¦ã‚‚ã‚³ã‚¹ãƒˆã¯å°ã•ã„ã§ã™ã€‚*type*"
" ã¯ ctypes å‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:1919
msgid ""
"This function creates a new pointer instance, pointing to *obj*. The "
"returned object is of the type ``POINTER(type(obj))``."
msgstr ""
"ã“ã®é–¢æ•°ã¯ *obj* ã‚’æŒ‡ã™æ–°ã—ã„ãƒã‚¤ãƒ³ã‚¿ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ ``POINTER(type(obj))`` å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/ctypes.rst:1922
msgid ""
"Note: If you just want to pass a pointer to an object to a foreign function "
"call, you should use ``byref(obj)`` which is much faster."
msgstr "æ³¨æ„: å¤–éƒ¨é–¢æ•°å‘¼ã³å‡ºã—ã¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’æ¸¡ã—ãŸã„ã ã‘ãªã‚‰ã€ã¯ã‚‹ã‹ã«é«˜é€Ÿãª ``byref(obj)`` ã‚’ä½¿ã†ã¹ãã§ã™ã€‚"

#: ../../library/ctypes.rst:1928
msgid ""
"This function resizes the internal memory buffer of *obj*, which must be an "
"instance of a ctypes type.  It is not possible to make the buffer smaller "
"than the native size of the objects type, as given by ``sizeof(type(obj))``,"
" but it is possible to enlarge the buffer."
msgstr ""
"ã“ã®é–¢æ•°ã¯ *obj* ã®å†…éƒ¨ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚ºã‚’å¤‰æ›´ã—ã¾ã™ã€‚ *obj* ã¯ ctypes å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒãƒƒãƒ•ã‚¡ã‚’ "
"``sizeof(type(obj))`` ã§ä¸ãˆã‚‰ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã®æœ¬æ¥ã®ã‚µã‚¤ã‚ºã‚ˆã‚Šå°ã•ãã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ãŒã€ãƒãƒƒãƒ•ã‚¡ã‚’æ‹¡å¤§ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã™ã€‚"

#: ../../library/ctypes.rst:1936
msgid ""
"Set the current value of the ctypes-private copy of the system :data:`errno`"
" variable in the calling thread to *value* and return the previous value."
msgstr ""
"ã‚·ã‚¹ãƒ†ãƒ å¤‰æ•° :data:`errno` ã®ã€å‘¼ã³å‡ºã—å…ƒã‚¹ãƒ¬ãƒƒãƒ‰ã§ã® ctypes ã®ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚³ãƒ”ãƒ¼ã®ç¾åœ¨å€¤ã‚’ *value* "
"ã«è¨­å®šã—ã€å‰ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1943
msgid ""
"Windows only: set the current value of the ctypes-private copy of the system"
" :data:`LastError` variable in the calling thread to *value* and return the "
"previous value."
msgstr ""
"Windows ç”¨: ã‚·ã‚¹ãƒ†ãƒ å¤‰æ•° :data:`LastError` ã®ã€å‘¼ã³å‡ºã—å…ƒã‚¹ãƒ¬ãƒƒãƒ‰ã§ã® ctypes ã®ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚³ãƒ”ãƒ¼ã®ç¾åœ¨å€¤ã‚’ "
"*value* ã«è¨­å®šã—ã€å‰ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1951
msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. Does "
"the same as the C ``sizeof`` operator."
msgstr "ctypes ã®å‹ã‚„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚ºã‚’ãƒã‚¤ãƒˆæ•°ã§è¿”ã—ã¾ã™ã€‚C ã® ``sizeof`` æ¼”ç®—å­ã¨åŒæ§˜ã®å‹•ãã‚’ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1957
msgid ""
"This function returns the C string starting at memory address *address* as a"
" bytes object. If size is specified, it is used as size, otherwise the "
"string is assumed to be zero-terminated."
msgstr ""
"ã“ã®é–¢æ•°ã¯ãƒ¡ãƒ¢ãƒªã‚¢ãƒ‰ãƒ¬ã‚¹ *address* ã‹ã‚‰å§‹ã¾ã‚‹ C æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚size "
"ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã¯ã‚µã‚¤ã‚ºã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚æŒ‡å®šã•ã‚Œãªã‘ã‚Œã°ã€æ–‡å­—åˆ—ãŒã‚¼ãƒ­çµ‚ç«¯ã•ã‚Œã¦ã„ã‚‹ã¨ä»®å®šã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1964
msgid ""
"Windows only: this function is probably the worst-named thing in ctypes. It "
"creates an instance of OSError.  If *code* is not specified, "
"``GetLastError`` is called to determine the error code. If *descr* is not "
"specified, :func:`FormatError` is called to get a textual description of the"
" error."
msgstr ""
"Windows ç”¨: ã“ã®é–¢æ•°ã¯ãŠãã‚‰ã ctypes ã®ä¸­ã§æœ€æ‚ªã®åå‰ã§ã—ã‚‡ã†ã€‚ã“ã‚Œã¯ OSError ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚ *code* "
"ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã‹ã£ãŸå ´åˆã€ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã‚’åˆ¤åˆ¥ã™ã‚‹ãŸã‚ã« ``GetLastError`` ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ *descr* "
"ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã‹ã£ãŸå ´åˆã€ã‚¨ãƒ©ãƒ¼ã®èª¬æ˜æ–‡ã‚’å¾—ã‚‹ãŸã‚ã« :func:`FormatError` ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:1970
msgid "An instance of :exc:`WindowsError` used to be created."
msgstr "ä»¥å‰ã¯ :exc:`WindowsError` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒä½œæˆã•ã‚Œã¦ã„ã¾ã—ãŸã€‚"

#: ../../library/ctypes.rst:1976
msgid ""
"This function returns the wide character string starting at memory address "
"*address* as a string.  If *size* is specified, it is used as the number of "
"characters of the string, otherwise the string is assumed to be zero-"
"terminated."
msgstr ""
"ã“ã®é–¢æ•°ã¯æ–‡å­—åˆ—ã¨ã—ã¦ãƒ¡ãƒ¢ãƒªã‚¢ãƒ‰ãƒ¬ã‚¹ *address* ã‹ã‚‰å§‹ã¾ã‚‹ãƒ¯ã‚¤ãƒ‰ã‚­ãƒ£ãƒ©ã‚¯ã‚¿æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚*size* "
"ãŒæŒ‡å®šã•ã‚ŒãŸãªã‚‰ã°ã€æ–‡å­—åˆ—ã®æ–‡å­—æ•°ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚æŒ‡å®šã•ã‚Œãªã‘ã‚Œã°ã€æ–‡å­—åˆ—ãŒã‚¼ãƒ­çµ‚ç«¯ã•ã‚Œã¦ã„ã‚‹ã¨ä»®å®šã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1985
msgid "Data types"
msgstr "ãƒ‡ãƒ¼ã‚¿å‹"

#: ../../library/ctypes.rst:1990
msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that "
"hold C compatible data; the address of the memory block is returned by the "
":func:`addressof` helper function. Another instance variable is exposed as "
":attr:`_objects`; this contains other Python objects that need to be kept "
"alive in case the memory block contains pointers."
msgstr ""
"ã“ã®éå…¬é–‹ã‚¯ãƒ©ã‚¹ã¯ã™ã¹ã¦ã® ctypes ãƒ‡ãƒ¼ã‚¿å‹ã®å…±é€šã®ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ä»–ã®ã“ã¨ã¯ã•ã¦ãŠãã€ã™ã¹ã¦ã® ctypes å‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ C "
"äº’æ›ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã™ã‚‹ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’å†…éƒ¨ã«æŒã¡ã¾ã™ã€‚ã“ã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ :func:`addressof` "
"ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ãŒè¿”ã—ã¾ã™ã€‚åˆ¥ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ãŒ :attr:`_objects` "
"ã¨ã—ã¦å…¬é–‹ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ãŒãƒã‚¤ãƒ³ã‚¿ã‚’å«ã‚€å ´åˆã«å­˜ç¶šã—ç¶šã‘ã‚‹å¿…è¦ã®ã‚ã‚‹ä»–ã® Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å«ã‚“ã§ã„ã¾ã™ã€‚"

#: ../../library/ctypes.rst:1997
msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr ""
"ctypes ãƒ‡ãƒ¼ã‚¿å‹ã®å…±é€šãƒ¡ã‚½ãƒƒãƒ‰ã€ã™ã¹ã¦ã®ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ãŒå­˜åœ¨ã—ã¾ã™ (æ­£ç¢ºã«ã¯ã€ :term:`ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ <metaclass>` "
"ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™):"

#: ../../library/ctypes.rst:2002
msgid ""
"This method returns a ctypes instance that shares the buffer of the *source*"
" object.  The *source* object must support the writeable buffer interface.  "
"The optional *offset* parameter specifies an offset into the source buffer "
"in bytes; the default is zero.  If the source buffer is not large enough a "
":exc:`ValueError` is raised."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ *source* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒƒãƒ•ã‚¡ã‚’å…±æœ‰ã™ã‚‹ ctypes ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ *source* "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ›¸ãè¾¼ã¿å¯èƒ½ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *offset* å¼•æ•°ã§ã¯ *source* "
"ãƒãƒƒãƒ•ã‚¡ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ãƒã‚¤ãƒˆå˜ä½ã§æŒ‡å®šã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã‚¼ãƒ­ã§ã™ã€‚ã‚‚ã— *source* ãƒãƒƒãƒ•ã‚¡ãŒååˆ†ã«å¤§ãããªã‘ã‚Œã°ã€ "
":exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:2011
msgid ""
"This method creates a ctypes instance, copying the buffer from the *source* "
"object buffer which must be readable.  The optional *offset* parameter "
"specifies an offset into the source buffer in bytes; the default is zero.  "
"If the source buffer is not large enough a :exc:`ValueError` is raised."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ *source* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®èª­ã¿å‡ºã—å¯èƒ½ãƒãƒƒãƒ•ã‚¡ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã“ã¨ã§ã€ctypes ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® "
"*offset* å¼•æ•°ã§ã¯ *source* ãƒãƒƒãƒ•ã‚¡ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ãƒã‚¤ãƒˆå˜ä½ã§æŒ‡å®šã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã‚¼ãƒ­ã§ã™ã€‚ã‚‚ã— *source* "
"ãƒãƒƒãƒ•ã‚¡ãŒååˆ†ã«å¤§ãããªã‘ã‚Œã°ã€ :exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:2019
msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ *address* ã§æŒ‡å®šã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã‚’ä½¿ã£ã¦ ctypes å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ *address* "
"ã¯æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2024
msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`argtypes` tuple; it must return an object that can"
" be used as a function call parameter."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ *obj* ã‚’ ctypes å‹ã«é©åˆã•ã›ã¾ã™ã€‚å¤–éƒ¨é–¢æ•°ã® :attr:`argtypes` "
"ã‚¿ãƒ—ãƒ«ã«ã€ãã®å‹ãŒã‚ã‚‹ã¨ãã€å¤–éƒ¨é–¢æ•°å‘¼ã³å‡ºã—ã§å®Ÿéš›ã«ä½¿ã‚ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨å…±ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:2029
msgid ""
"All ctypes data types have a default implementation of this classmethod that"
" normally returns *obj* if that is an instance of the type.  Some types "
"accept other objects as well."
msgstr ""
"ã™ã¹ã¦ã® ctypes ã®ãƒ‡ãƒ¼ã‚¿å‹ã¯ã€ãã‚ŒãŒå‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚Œã°ã€ *obj* "
"ã‚’è¿”ã™ã“ã®ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè£…ã‚’æŒã¡ã¾ã™ã€‚ã„ãã¤ã‹ã®å‹ã¯ã€åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚å—ã‘ä»˜ã‘ã¾ã™ã€‚"

#: ../../library/ctypes.rst:2035
msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ˆã£ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚ŒãŸ ctypes å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ *name* ã¯ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã®åå‰ã§ã€"
" *library* ã¯ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚"

#: ../../library/ctypes.rst:2039
msgid "Common instance variables of ctypes data types:"
msgstr "ctypes ãƒ‡ãƒ¼ã‚¿å‹å…±é€šã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°:"

#: ../../library/ctypes.rst:2043
msgid ""
"Sometimes ctypes data instances do not own the memory block they contain, "
"instead they share part of the memory block of a base object.  The "
":attr:`_b_base_` read-only member is the root ctypes object that owns the "
"memory block."
msgstr ""
"ctypes å‹ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ãã‚Œè‡ªèº«ã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’æŒãŸãšã€åŸºåº•ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã®ä¸€éƒ¨ã‚’å…±æœ‰ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ "
":attr:`_b_base_` èª­ã¿å‡ºã—å°‚ç”¨å±æ€§ã¯ã€ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’ä¿æŒã™ã‚‹ ctypes ã®åŸºåº•ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/ctypes.rst:2050
msgid ""
"This read-only variable is true when the ctypes data instance has allocated "
"the memory block itself, false otherwise."
msgstr ""
"ã“ã®èª­ã¿å‡ºã—å°‚ç”¨ã®å¤‰æ•°ã¯ã€ ctypes ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã€ãã‚Œè‡ªèº«ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã‚’æŒã¤ã¨ã true ã«ãªã‚Šã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯"
" false ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:2055
msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept valid."
"  This object is only exposed for debugging; never modify the contents of "
"this dictionary."
msgstr ""
"ã“ã®ãƒ¡ãƒ³ãƒã¯ ``None`` ã€ã¾ãŸã¯ã€ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã®å†…å®¹ãŒæ­£ã—ãä¿ã¤ãŸã‚ã«ã€ç”Ÿå­˜ã•ã›ã¦ãŠã‹ãªãã¦ã¯ãªã‚‰ãªã„ Python "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒã¤ãƒ‡ã‚£ã‚¯ã‚·ãƒ§ãƒŠãƒªã§ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ‡ãƒãƒƒã‚°ã§ã®ã¿ä½¿ã‚ã‚Œã¾ã™ã€‚æ±ºã—ã¦ãƒ‡ã‚£ã‚¯ã‚·ãƒ§ãƒŠãƒªã®å†…å®¹ã‚’å¤‰æ›´ã—ãªã„ã§ä¸‹ã•ã„ã€‚"

#: ../../library/ctypes.rst:2068
msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of the"
" fundamental ctypes data types.  :class:`_SimpleCData` is a subclass of "
":class:`_CData`, so it inherits their methods and attributes. ctypes data "
"types that are not and do not contain pointers can now be pickled."
msgstr ""
"ã“ã®éå…¬é–‹ã‚¯ãƒ©ã‚¹ã¯ã€å…¨ã¦ã®åŸºæœ¬çš„ãª ctypes ãƒ‡ãƒ¼ã‚¿å‹ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ã“ã‚Œã¯åŸºæœ¬çš„ãª ctypes "
"ãƒ‡ãƒ¼ã‚¿å‹ã«å…±é€šã®å±æ€§ã‚’æŒã£ã¦ã„ã‚‹ã®ã§ã€ã“ã“ã§è§¦ã‚Œã¦ãŠãã¾ã™ã€‚ :class:`_SimpleCData` ã¯ :class:`_CData` "
"ã®å­ã‚¯ãƒ©ã‚¹ãªã®ã§ã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨å±æ€§ã‚’ç¶™æ‰¿ã—ã¦ã„ã¾ã™ã€‚ãƒã‚¤ãƒ³ã‚¿ã§ãªã„ã‹ãƒã‚¤ãƒ³ã‚¿ã‚’å«ã¾ãªã„ ctypes ãƒ‡ãƒ¼ã‚¿å‹ã¯ã€ç¾åœ¨ã¯ pickle åŒ–ã§ãã¾ã™ã€‚"

#: ../../library/ctypes.rst:2074
msgid "Instances have a single attribute:"
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ä¸€ã¤ã ã‘å±æ€§ã‚’æŒã¡ã¾ã™:"

#: ../../library/ctypes.rst:2078
msgid ""
"This attribute contains the actual value of the instance. For integer and "
"pointer types, it is an integer, for character types, it is a single "
"character bytes object or string, for character pointer types it is a Python"
" bytes object or string."
msgstr ""
"ã“ã®å±æ€§ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å®Ÿéš›ã®å€¤ã‚’æŒã¡ã¾ã™ã€‚æ•´æ•°å‹ã¨ãƒã‚¤ãƒ³ã‚¿å‹ã«å¯¾ã—ã¦ã¯æ•´æ•°å‹ã€æ–‡å­—å‹ã«å¯¾ã—ã¦ã¯ä¸€æ–‡å­—ã®ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€æ–‡å­—ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã«å¯¾ã—ã¦ã¯"
" Python ã®ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ã—ãã¯æ–‡å­—åˆ—ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:2083
msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually a "
"new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr ""
"``value`` å±æ€§ãŒ ctypes ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ˆã‚Šå‚ç…§ã•ã‚ŒãŸã¨ãã€å¤§æŠµã®å ´åˆã¯ãã‚Œãã‚Œã«å¯¾ã—æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ "
":mod:`ctypes` ã¯ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™å®Ÿè£…ã«ã¯ãªã£ã¦ *ãŠã‚‰ãš* æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚åŒã˜ã“ã¨ãŒä»–ã® ctypes "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã—ã¦ã‚‚è¨€ãˆã¾ã™ã€‚"

#: ../../library/ctypes.rst:2089
msgid ""
"Fundamental data types, when returned as foreign function call results, or, "
"for example, by retrieving structure field members or array items, are "
"transparently converted to native Python types.  In other words, if a "
"foreign function has a :attr:`restype` of :class:`c_char_p`, you will always"
" receive a Python bytes object, *not* a :class:`c_char_p` instance."
msgstr ""
"åŸºæœ¬ãƒ‡ãƒ¼ã‚¿å‹ã¯ã€å¤–éƒ¨é–¢æ•°å‘¼ã³å‡ºã—ã®çµæœã¨ã—ã¦è¿”ã•ã‚ŒãŸã¨ãã‚„ã€ä¾‹ãˆã°æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ¡ãƒ³ãƒãƒ¼ã‚„é…åˆ—è¦ç´ ã‚’å–ã‚Šå‡ºã™ã¨ãã«ã€ãƒã‚¤ãƒ†ã‚£ãƒ–ã® Python "
"å‹ã¸é€éçš„ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚è¨€ã„æ›ãˆã‚‹ã¨ã€å¤–éƒ¨é–¢æ•°ãŒ :class:`c_char_p` ã® :attr:`restype` ã‚’æŒã¤å ´åˆã¯ã€ "
":class:`c_char_p` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã¯ *ãªã* å¸¸ã« Python ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚‹ã“ã¨ã§ã—ã‚‡ã†ã€‚"

#: ../../library/ctypes.rst:2097
msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, if "
"a foreign functions :attr:`restype` is a subclass of :class:`c_void_p`, you "
"will receive an instance of this subclass from the function call. Of course,"
" you can get the value of the pointer by accessing the ``value`` attribute."
msgstr ""
"åŸºæœ¬ãƒ‡ãƒ¼ã‚¿å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã¯ã“ã®æŒ¯ã‚‹èˆã„ã‚’ç¶™æ‰¿ *ã—ã¾ã›ã‚“* ã€‚ã—ãŸãŒã£ã¦ã€å¤–éƒ¨é–¢æ•°ã® :attr:`restype` ãŒ "
":class:`c_void_p` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãªã‚‰ã°ã€é–¢æ•°å‘¼ã³å‡ºã—ã‹ã‚‰ã“ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ã‚‚ã¡ã‚ã‚“ã€ ``value`` "
"å±æ€§ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãƒã‚¤ãƒ³ã‚¿ã®å€¤ã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/ctypes.rst:2102
msgid "These are the fundamental ctypes data types:"
msgstr "ã“ã‚Œã‚‰ãŒåŸºæœ¬ ctypes ãƒ‡ãƒ¼ã‚¿å‹ã§ã™:"

#: ../../library/ctypes.rst:2106
msgid ""
"Represents the C :c:type:`signed char` datatype, and interprets the value as"
" small integer.  The constructor accepts an optional integer initializer; no"
" overflow checking is done."
msgstr ""
"C ã® :c:type:`signed char` "
"ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã€å°æ•´æ•°ã¨ã—ã¦å€¤ã‚’è§£é‡ˆã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•´æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2113
msgid ""
"Represents the C :c:type:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string initializer, "
"the length of the string must be exactly one character."
msgstr ""
"C :c:type:`char` "
"ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã€å˜ä¸€ã®æ–‡å­—ã¨ã—ã¦å€¤ã‚’è§£é‡ˆã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ–‡å­—åˆ—åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã€ãã®æ–‡å­—åˆ—ã®é•·ã•ã¡ã‚‡ã†ã©ä¸€æ–‡å­—ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:2120
msgid ""
"Represents the C :c:type:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point to "
"binary data, ``POINTER(c_char)`` must be used.  The constructor accepts an "
"integer address, or a bytes object."
msgstr ""
"C :c:type:`char *` "
"ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã€ã‚¼ãƒ­çµ‚ç«¯æ–‡å­—åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™å¯èƒ½æ€§ã®ã‚ã‚‹ä¸€èˆ¬çš„ãªãƒã‚¤ãƒ³ã‚¿ã«å¯¾ã—ã¦ã¯ "
"``POINTER(c_char)`` ã‚’ä½¿ã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯æ•´æ•°ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚‚ã—ãã¯ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:2128
msgid ""
"Represents the C :c:type:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr "C :c:type:`double` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æµ®å‹•å°æ•°ç‚¹æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:2134
msgid ""
"Represents the C :c:type:`long double` datatype.  The constructor accepts an"
" optional float initializer.  On platforms where ``sizeof(long double) == "
"sizeof(double)`` it is an alias to :class:`c_double`."
msgstr ""
"C :c:type:`long double` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§æµ®å‹•å°æ•°ç‚¹æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ "
"``sizeof(long double) == sizeof(double)`` ã§ã‚ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ :class:`c_double` "
"ã®åˆ¥åã§ã™ã€‚"

#: ../../library/ctypes.rst:2140
msgid ""
"Represents the C :c:type:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr "C :c:type:`float` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æµ®å‹•å°æ•°ç‚¹æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:2146
msgid ""
"Represents the C :c:type:`signed int` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias to :class:`c_long`."
msgstr ""
"C :c:type:`signed int` "
"ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•´æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚ ``sizeof(int) == "
"sizeof(long)`` ã§ã‚ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€ :class:`c_long` ã®åˆ¥åã§ã™ã€‚"

#: ../../library/ctypes.rst:2153
msgid ""
"Represents the C 8-bit :c:type:`signed int` datatype.  Usually an alias for "
":class:`c_byte`."
msgstr "C 8-bit :c:type:`signed int` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ãŸã„ã¦ã„ã¯ã€ :class:`c_byte` ã®åˆ¥åã§ã™ã€‚"

#: ../../library/ctypes.rst:2159
msgid ""
"Represents the C 16-bit :c:type:`signed int` datatype.  Usually an alias for"
" :class:`c_short`."
msgstr ""
"C 16-bit :c:type:`signed int` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ãŸã„ã¦ã„ã¯ã€ :class:`c_short` ã®åˆ¥åã§ã™ã€‚"

#: ../../library/ctypes.rst:2165
msgid ""
"Represents the C 32-bit :c:type:`signed int` datatype.  Usually an alias for"
" :class:`c_int`."
msgstr "C 32-bit :c:type:`signed int` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ãŸã„ã¦ã„ã¯ã€ :class:`c_int` ã®åˆ¥åã§ã™ã€‚"

#: ../../library/ctypes.rst:2171
msgid ""
"Represents the C 64-bit :c:type:`signed int` datatype.  Usually an alias for"
" :class:`c_longlong`."
msgstr ""
"C 64-bit :c:type:`signed int` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ãŸã„ã¦ã„ã¯ã€ :class:`c_longlong` ã®åˆ¥åã§ã™ã€‚"

#: ../../library/ctypes.rst:2177
msgid ""
"Represents the C :c:type:`signed long` datatype.  The constructor accepts an"
" optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed long` "
"ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•´æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2183
msgid ""
"Represents the C :c:type:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed long long` "
"ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•´æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2189
msgid ""
"Represents the C :c:type:`signed short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed short` "
"ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•´æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2195
msgid "Represents the C :c:type:`size_t` datatype."
msgstr "C :c:type:`size_t` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:2200
msgid "Represents the C :c:type:`ssize_t` datatype."
msgstr "C :c:type:`ssize_t` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:2207
msgid ""
"Represents the C :c:type:`unsigned char` datatype, it interprets the value "
"as small integer.  The constructor accepts an optional integer initializer; "
"no overflow checking is done."
msgstr ""
"C ã® :c:type:`unsigned char` "
"ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã€å°ã•ãªæ•´æ•°ã¨ã—ã¦å€¤ã‚’è§£é‡ˆã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•´æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™; ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2214
msgid ""
"Represents the C :c:type:`unsigned int` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done.  On platforms"
" where ``sizeof(int) == sizeof(long)`` it is an alias for :class:`c_ulong`."
msgstr ""
"C ã®  :c:type:`unsigned int` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•´æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™; "
"ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€ ``sizeof(int) == sizeof(long)`` ã§ã‚ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ "
":class:`c_ulong` ã®åˆ¥åã§ã™ã€‚"

#: ../../library/ctypes.rst:2221
msgid ""
"Represents the C 8-bit :c:type:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ubyte`."
msgstr ""
"C 8-bit :c:type:`unsigned int` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ãŸã„ã¦ã„ã¯ã€ :class:`c_ubyte` ã®åˆ¥åã§ã™ã€‚"

#: ../../library/ctypes.rst:2227
msgid ""
"Represents the C 16-bit :c:type:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ushort`."
msgstr ""
"C 16-bit :c:type:`unsigned int` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ãŸã„ã¦ã„ã¯ã€ :class:`c_ushort` ã®åˆ¥åã§ã™ã€‚"

#: ../../library/ctypes.rst:2233
msgid ""
"Represents the C 32-bit :c:type:`unsigned int` datatype.  Usually an alias "
"for :class:`c_uint`."
msgstr ""
"C 32-bit :c:type:`unsigned int` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ãŸã„ã¦ã„ã¯ã€ :class:`c_uint` ã®åˆ¥åã§ã™ã€‚"

#: ../../library/ctypes.rst:2239
msgid ""
"Represents the C 64-bit :c:type:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ulonglong`."
msgstr ""
"C 64-bit :c:type:`unsigned int` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ãŸã„ã¦ã„ã¯ã€ :class:`c_ulonglong` ã®åˆ¥åã§ã™ã€‚"

#: ../../library/ctypes.rst:2245
msgid ""
"Represents the C :c:type:`unsigned long` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned long` "
"ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•´æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2251
msgid ""
"Represents the C :c:type:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned long long` "
"ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•´æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2257
msgid ""
"Represents the C :c:type:`unsigned short` datatype.  The constructor accepts"
" an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned short` "
"ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•´æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2263
msgid ""
"Represents the C :c:type:`void *` type.  The value is represented as "
"integer. The constructor accepts an optional integer initializer."
msgstr ""
"C :c:type:`void *` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚å€¤ã¯æ•´æ•°ã¨ã—ã¦è¡¨ã•ã‚Œã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•´æ•°åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:2269
msgid ""
"Represents the C :c:type:`wchar_t` datatype, and interprets the value as a "
"single character unicode string.  The constructor accepts an optional string"
" initializer, the length of the string must be exactly one character."
msgstr ""
"C :c:type:`wchar_t` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã€å€¤ã¯ Unicode "
"æ–‡å­—åˆ—ã®å˜ä¸€ã®æ–‡å­—ã¨ã—ã¦è§£é‡ˆã•ã‚Œã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ–‡å­—åˆ—åˆæœŸåŒ–å­ã‚’å—ã‘å–ã‚Šã€ãã®æ–‡å­—åˆ—ã®é•·ã•ã¯ã¡ã‚‡ã†ã©ä¸€æ–‡å­—ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:2276
msgid ""
"Represents the C :c:type:`wchar_t *` datatype, which must be a pointer to a "
"zero-terminated wide character string.  The constructor accepts an integer "
"address, or a string."
msgstr ""
"C :c:type:`wchar_t *` "
"ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã€ã‚¼ãƒ­çµ‚ç«¯ãƒ¯ã‚¤ãƒ‰æ–‡å­—åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯æ•´æ•°ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚‚ã—ãã¯æ–‡å­—åˆ—ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:2283
msgid ""
"Represent the C :c:type:`bool` datatype (more accurately, :c:type:`_Bool` "
"from C99).  Its value can be ``True`` or ``False``, and the constructor "
"accepts any object that has a truth value."
msgstr ""
"C ã® :c:type:`bool` ãƒ‡ãƒ¼ã‚¿å‹ (ã‚ˆã‚Šæ­£ç¢ºã«ã¯ã€ C99 ä»¥é™ã®  :c:type:`_Bool`) ã‚’è¡¨ã—ã¾ã™ã€‚ ``True`` "
"ã¾ãŸã¯ ``False`` ã®å€¤ã‚’æŒã¡ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯çœŸå½å€¤ã¨è§£é‡ˆã§ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:2290
msgid ""
"Windows only: Represents a :c:type:`HRESULT` value, which contains success "
"or error information for a function or method call."
msgstr "Windowsç”¨: :c:type:`HRESULT` å€¤ã‚’è¡¨ã—ã€é–¢æ•°ã¾ãŸã¯ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—ã«å¯¾ã™ã‚‹æˆåŠŸã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ã®æƒ…å ±ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚"

#: ../../library/ctypes.rst:2296
msgid ""
"Represents the C :c:type:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :c:type:`PyObject *` pointer."
msgstr ""
"C :c:type:`PyObject *` ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ã—ã¾ã™ã€‚å¼•æ•°ãªã—ã§ã“ã‚Œã‚’å‘¼ã³å‡ºã™ã¨ ``NULL`` :c:type:`PyObject *`"
" ãƒã‚¤ãƒ³ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:2299
msgid ""
"The :mod:`ctypes.wintypes` module provides quite some other Windows specific"
" data types, for example :c:type:`HWND`, :c:type:`WPARAM`, or "
":c:type:`DWORD`.  Some useful structures like :c:type:`MSG` or "
":c:type:`RECT` are also defined."
msgstr ""
":mod:`ctypes.wintypes` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ä»–ã® Windows å›ºæœ‰ã®ãƒ‡ãƒ¼ã‚¿å‹ã‚’æä¾›ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ :c:type:`HWND`, "
":c:type:`WPARAM`, :c:type:`DWORD` ã§ã™ã€‚ :c:type:`MSG` ã‚„ :c:type:`RECT` "
"ã®ã‚ˆã†ãªæœ‰ç”¨ãªæ§‹é€ ä½“ã‚‚å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/ctypes.rst:2307
msgid "Structured data types"
msgstr "æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿å‹"

#: ../../library/ctypes.rst:2312
msgid "Abstract base class for unions in native byte order."
msgstr "ãƒã‚¤ãƒ†ã‚£ãƒ–ã®ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ã§ã®å…±ç”¨ä½“ã®ãŸã‚ã®æŠ½è±¡ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã€‚"

#: ../../library/ctypes.rst:2317
msgid "Abstract base class for structures in *big endian* byte order."
msgstr "*ãƒ“ãƒƒã‚¯ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³* ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ã§ã®æ§‹é€ ä½“ã®ãŸã‚ã®æŠ½è±¡ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã€‚"

#: ../../library/ctypes.rst:2322
msgid "Abstract base class for structures in *little endian* byte order."
msgstr "*ãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³* ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ã§ã®æ§‹é€ ä½“ã®ãŸã‚ã®æŠ½è±¡ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã€‚"

#: ../../library/ctypes.rst:2324
msgid ""
"Structures with non-native byte order cannot contain pointer type fields, or"
" any other data types containing pointer type fields."
msgstr ""
"ãƒã‚¤ãƒ†ã‚£ãƒ–ã§ã¯ãªã„ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ã‚’æŒã¤æ§‹é€ ä½“ã«ãƒã‚¤ãƒ³ã‚¿å‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚ã‚‹ã„ã¯ãƒã‚¤ãƒ³ã‚¿å‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å«ã‚€ä»–ã®ã©ã‚“ãªãƒ‡ãƒ¼ã‚¿å‹ã‚’ã‚‚å…¥ã‚Œã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2330
msgid "Abstract base class for structures in *native* byte order."
msgstr "*ãƒã‚¤ãƒ†ã‚£ãƒ–* ã®ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ã§ã®æ§‹é€ ä½“ã®ãŸã‚ã®æŠ½è±¡ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã€‚"

#: ../../library/ctypes.rst:2332
msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. "
":mod:`ctypes` will create :term:`descriptor`\\s which allow reading and "
"writing the fields by direct attribute accesses.  These are the"
msgstr ""
"å…·è±¡æ§‹é€ ä½“å‹ã¨å…·è±¡å…±ç”¨ä½“å‹ã¯ã“ã‚Œã‚‰ã®å‹ã®ä¸€ã¤ã‚’ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã™ã‚‹ã“ã¨ã§ä½œã‚‰ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å°‘ãªãã¨ã‚‚ã€ :attr:`_fields_` "
"ã‚¯ãƒ©ã‚¹å¤‰æ•°ã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ :mod:`ctypes` ã¯ã€å±æ€§ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’èª­ã¿æ›¸ãã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹è¨˜è¿°å­ "
"(:term:`descriptor`) ã‚’ä½œæˆã™ã‚‹ã§ã—ã‚‡ã†ã€‚ã“ã‚Œã‚‰ã¯ã€"

#: ../../library/ctypes.rst:2340
msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or "
"3-tuples.  The first item is the name of the field, the second item "
"specifies the type of the field; it can be any ctypes data type."
msgstr ""
"æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å®šç¾©ã™ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã€‚è¦ç´ ã¯2è¦ç´ ã‚¿ãƒ—ãƒ«ã‹3è¦ç´ ã‚¿ãƒ—ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ç¬¬ä¸€è¦ç´ ã¯ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®åå‰ã§ã™ã€‚ç¬¬äºŒè¦ç´ ã¯ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚ãã‚Œã¯ã©ã‚“ãª"
" ctypes ãƒ‡ãƒ¼ã‚¿å‹ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2344
msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be "
"given.  It must be a small positive integer defining the bit width of the "
"field."
msgstr ""
":class:`c_int` "
"ã®ã‚ˆã†ãªæ•´æ•°å‹ã®ãŸã‚ã«ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ç¬¬ä¸‰è¦ç´ ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒ“ãƒƒãƒˆå¹…ã‚’å®šç¾©ã™ã‚‹æ­£ã®å°æ•´æ•°ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:2348
msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr ""
"ä¸€ã¤ã®æ§‹é€ ä½“ã¨å…±ç”¨ä½“ã®ä¸­ã§ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã¯ãŸã ä¸€ã¤ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¾ã›ã‚“ã€‚åå‰ãŒç¹°ã‚Šè¿”ã—ã§ã¦ããŸã¨ãã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã®ã¯ä¸€ã¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã ã‘ã§ã™ã€‚"

#: ../../library/ctypes.rst:2351
msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows creating "
"data types that directly or indirectly reference themselves::"
msgstr ""
"Structure ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã™ã‚‹ã‚¯ãƒ©ã‚¹æ–‡ã® *å¾Œã§* ã€ :attr:`_fields_` "
"ã‚¯ãƒ©ã‚¹å¤‰æ•°ã‚’å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€æ¬¡ã®ã‚ˆã†ã«è‡ªèº«ã‚’ç›´æ¥ã¾ãŸã¯é–“æ¥çš„ã«å‚ç…§ã™ã‚‹ãƒ‡ãƒ¼ã‚¿å‹ã‚’ä½œæˆã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/ctypes.rst:2361
msgid ""
"The :attr:`_fields_` class variable must, however, be defined before the "
"type is first used (an instance is created, :func:`sizeof` is called on it, "
"and so on).  Later assignments to the :attr:`_fields_` class variable will "
"raise an AttributeError."
msgstr ""
"ã—ã‹ã—ã€ :attr:`_fields_` ã‚¯ãƒ©ã‚¹å¤‰æ•°ã¯ãã®å‹ãŒæœ€åˆã«ä½¿ã‚ã‚Œã‚‹ (ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒä½œæˆã•ã‚Œã‚‹ã€ãã‚Œã«å¯¾ã—ã¦ :func:`sizeof` "
"ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ãªã©) ã‚ˆã‚Šå‰ã«å®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã®å¾Œ :attr:`_fields_` ã‚¯ãƒ©ã‚¹å¤‰æ•°ã¸ä»£å…¥ã™ã‚‹ã¨ "
"AttributeError ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:2366
msgid ""
"It is possible to defined sub-subclasses of structure types, they inherit "
"the fields of the base class plus the :attr:`_fields_` defined in the sub-"
"subclass, if any."
msgstr ""
"æ§‹é€ ä½“å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã€ã‚‚ã—ã‚ã‚‹ãªã‚‰ã‚µãƒ–ã‚¯ãƒ©ã‚¹å†…ã§å®šç¾©ã•ã‚ŒãŸ :attr:`_fields_` "
"ã«åŠ ãˆã¦ã€ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚‚ç¶™æ‰¿ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:2373
msgid ""
"An optional small integer that allows overriding the alignment of structure "
"fields in the instance.  :attr:`_pack_` must already be defined when "
":attr:`_fields_` is assigned, otherwise it will have no effect."
msgstr ""
"ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ§‹é€ ä½“ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã‚’ä¸Šæ›¸ãã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã‚ªãƒ–ã‚·ãƒ§ãƒ³ã®å°æ•´æ•°ã€‚ :attr:`_pack_` ã¯ "
":attr:`_fields_` ãŒä»£å…¥ã•ã‚ŒãŸã¨ãã™ã§ã«å®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ä½•ã®åŠ¹æœã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2380
msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. "
":attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr ""
"ç„¡å (åŒ¿å) ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®åå‰ãŒä¸¦ã¹ã‚ã’ã‚‰ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã€‚ :attr:`_fields_` ãŒä»£å…¥ã•ã‚ŒãŸã¨ãã€ "
":attr:`_anonymous_` ãŒã™ã§ã«å®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ä½•ã‚‰å½±éŸ¿ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2384
msgid ""
"The fields listed in this variable must be structure or union type fields. "
":mod:`ctypes` will create descriptors in the structure type that allows "
"accessing the nested fields directly, without the need to create the "
"structure or union field."
msgstr ""
"ã“ã®å¤‰æ•°ã«ä¸¦ã¹ã‚ã’ã‚‰ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯æ§‹é€ ä½“å‹ã‚‚ã—ãã¯å…±ç”¨ä½“å‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚æ§‹é€ ä½“ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¾ãŸã¯å…±ç”¨ä½“ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½œã‚‹å¿…è¦ãªãã€å…¥ã‚Œå­ã«ãªã£ãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€"
" :mod:`ctypes` ã¯æ§‹é€ ä½“å‹ã®ä¸­ã«è¨˜è¿°å­ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:2389
msgid "Here is an example type (Windows)::"
msgstr "å‹ã®ä¾‹ã§ã™ (Windows)::"

#: ../../library/ctypes.rst:2402
msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field is "
"defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` are "
"equivalent, but the former is faster since it does not need to create a "
"temporary union instance::"
msgstr ""
"``TYPEDESC`` æ§‹é€ ä½“ã¯COMãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ç¾ã—ã¦ãŠã‚Šã€ ``vt`` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å…±ç”¨ä½“ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã©ã‚ŒãŒæœ‰åŠ¹ã§ã‚ã‚‹ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚ "
"``u`` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯åŒ¿åãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ TYPEDESC ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰å–ã‚Šé™¤ã‹ã‚Œã¦ãã®ãƒ¡ãƒ³ãƒãƒ¼ã¸ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚ "
"``td.lptdesc`` ã¨ ``td.u.lptdesc`` "
"ã¯åŒç­‰ã§ã™ãŒã€å‰è€…ãŒã‚ˆã‚Šé«˜é€Ÿã§ã™ã€‚ãªãœãªã‚‰ä¸€æ™‚çš„ãªå…±ç”¨ä½“ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚‹å¿…è¦ãŒãªã„ãŸã‚ã§ã™ã€‚::"

#: ../../library/ctypes.rst:2414
msgid ""
"It is possible to defined sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate "
":attr:`_fields_` variable, the fields specified in this are appended to the "
"fields of the base class."
msgstr ""
"æ§‹é€ ä½“ã®ã‚µãƒ–-ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã€ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚ã‚µãƒ–ã‚¯ãƒ©ã‚¹å®šç¾©ã«åˆ¥ã® :attr:`_fields_` "
"å¤‰æ•°ãŒã‚ã‚‹å ´åˆã¯ã€ã“ã®ä¸­ã§æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¸è¿½åŠ ã•ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:2419
msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in the"
" same order as they are appear in :attr:`_fields_`.  Keyword arguments in "
"the constructor are interpreted as attribute assignments, so they will "
"initialize :attr:`_fields_` with the same name, or create new attributes for"
" names not present in :attr:`_fields_`."
msgstr ""
"æ§‹é€ ä½“ã¨å…±ç”¨ä½“ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ä½ç½®å¼•æ•°ã¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®ä¸¡æ–¹ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ä½ç½®å¼•æ•°ã¯ :attr:`_fields_` "
"ã®ä¸­ã«ç¾ã‚ŒãŸã®ã¨åŒã˜é †ç•ªã§ãƒ¡ãƒ³ãƒãƒ¼ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åˆæœŸåŒ–ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¯å±æ€§ä»£å…¥ã¨ã—ã¦è§£é‡ˆã•ã‚Œã€ãã®ãŸã‚ã€åŒã˜åå‰ã‚’ã‚‚ã¤"
" :attr:`_fields_` ã‚’åˆæœŸåŒ–ã™ã‚‹ã‹ã€ :attr:`_fields_` ã«å­˜åœ¨ã—ãªã„åå‰ã«å¯¾ã—ã¦ã¯æ–°ã—ã„å±æ€§ã‚’ä½œã‚Šã¾ã™ã€‚"

#: ../../library/ctypes.rst:2430
msgid "Arrays and pointers"
msgstr "é…åˆ—ã¨ãƒã‚¤ãƒ³ã‚¿"

#: ../../library/ctypes.rst:2434
msgid "Abstract base class for arrays."
msgstr "é…åˆ—ã®ãŸã‚ã®æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/ctypes.rst:2436
msgid ""
"The recommended way to create concrete array types is by multiplying any "
":mod:`ctypes` data type with a positive integer.  Alternatively, you can "
"subclass this type and define :attr:`_length_` and :attr:`_type_` class "
"variables. Array elements can be read and written using standard subscript "
"and slice accesses; for slice reads, the resulting object is *not* itself an"
" :class:`Array`."
msgstr ""
"å…·è±¡é…åˆ—å‹ã‚’ä½œæˆã™ã‚‹ãŸã‚ã®æ¨å¥¨ã•ã‚Œã‚‹æ–¹æ³•ã¯ã€ä»»æ„ã® :mod:`ctypes` "
"ãƒ‡ãƒ¼ã‚¿å‹ã«æ­£ã®æ•´æ•°ã‚’ä¹—ç®—ã™ã‚‹ã“ã¨ã§ã™ã€‚ä»£ã‚ã‚Šã«ã€ã“ã®å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ã€ :attr:`_length_` ã¨ :attr:`_type_` "
"ã®ã‚¯ãƒ©ã‚¹å¤‰æ•°ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚é…åˆ—ã®è¦ç´ ã¯ã€æ¨™æº–ã®æ·»ãˆå­—ã¨ã‚¹ãƒ©ã‚¤ã‚¹ã«ã‚ˆã‚‹ã‚¢ã‚¯ã‚»ã‚¹ã‚’ä½¿ç”¨ã—ã¦èª­ã¿æ›¸ãã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚¹ãƒ©ã‚¤ã‚¹ã®èª­ã¿è¾¼ã¿ã§ã¯ã€çµæœã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã¯"
" :class:`Array` ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/ctypes.rst:2446
msgid ""
"A positive integer specifying the number of elements in the array. Out-of-"
"range subscripts result in an :exc:`IndexError`. Will be returned by "
":func:`len`."
msgstr ""
"é…åˆ—ã®è¦ç´ æ•°ã‚’æŒ‡å®šã™ã‚‹æ­£ã®æ•´æ•°ã€‚ç¯„å›²å¤–ã®æ·»ãˆå­—ã‚’æŒ‡å®šã™ã‚‹ã¨ã€ :exc:`IndexError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚:func:`len` "
"ãŒã“ã®æ•´æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:2453
msgid "Specifies the type of each element in the array."
msgstr "é…åˆ—å†…ã®å„è¦ç´ ã®å‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:2456
msgid ""
"Array subclass constructors accept positional arguments, used to initialize "
"the elements in order."
msgstr "é…åˆ—ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€ä½ç½®å¼•æ•°ã‚’å—ã‘ä»˜ã‘ã¦ã€é…åˆ—ã‚’é †ç•ªã«åˆæœŸåŒ–ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:2462
msgid "Private, abstract base class for pointers."
msgstr "ãƒã‚¤ãƒ³ã‚¿ã®ãŸã‚ã®ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªæŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/ctypes.rst:2464
msgid ""
"Concrete pointer types are created by calling :func:`POINTER` with the type "
"that will be pointed to; this is done automatically by :func:`pointer`."
msgstr ""
"å…·è±¡ãƒã‚¤ãƒ³ã‚¿å‹ã¯ã€ãƒã‚¤ãƒ³ãƒˆå…ˆã®å‹ã‚’æŒã¤ :func:`POINTER` ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ä½œæˆã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€ :func:`pointer` "
"ã«ã‚ˆã‚Šè‡ªå‹•çš„ã«è¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../library/ctypes.rst:2468
msgid ""
"If a pointer points to an array, its elements can be read and written using "
"standard subscript and slice accesses.  Pointer objects have no size, so "
":func:`len` will raise :exc:`TypeError`.  Negative subscripts will read from"
" the memory *before* the pointer (as in C), and out-of-range subscripts will"
" probably crash with an access violation (if you're lucky)."
msgstr ""
"ãƒã‚¤ãƒ³ã‚¿ãŒé…åˆ—ã‚’æŒ‡ã™å ´åˆã€ãã®é…åˆ—ã®è¦ç´ ã¯ã€æ¨™æº–ã®æ·»ãˆå­—ã¨ã‚¹ãƒ©ã‚¤ã‚¹ã«ã‚ˆã‚‹ã‚¢ã‚¯ã‚»ã‚¹ã‚’ä½¿ç”¨ã—ã¦èª­ã¿æ›¸ããŒè¡Œãˆã¾ã™ã€‚ãƒã‚¤ãƒ³ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€ã‚µã‚¤ã‚ºãŒãªã„ãŸã‚ã€"
" :func:`len` é–¢æ•°ã¯ :exc:`TypeError` ã‚’é€å‡ºã—ã¾ã™ã€‚è² ã®æ·»ãˆå­—ã¯ã€(C ã¨åŒæ§˜ã«) ãƒã‚¤ãƒ³ã‚¿ã® *å‰* "
"ã®ãƒ¡ãƒ¢ãƒªã‹ã‚‰èª­ã¿è¾¼ã¿ã€ç¯„å›²å¤–ã®æ·»ãˆå­—ã¯ãŠãã‚‰ã (å¹¸é‹ãªå ´åˆã§ã‚‚) ã‚¢ã‚¯ã‚»ã‚¹é•åã«ã‚ˆã‚Šã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã‚’èµ·ã“ã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:2478
msgid "Specifies the type pointed to."
msgstr "ãƒã‚¤ãƒ³ãƒˆå…ˆã®å‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚"

#: ../../library/ctypes.rst:2482
msgid ""
"Returns the object to which to pointer points.  Assigning to this attribute "
"changes the pointer to point to the assigned object."
msgstr "ãƒã‚¤ãƒ³ã‚¿ãŒæŒ‡ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã®å±æ€§ã«å‰²ã‚Šå½“ã¦ã‚‹ã¨ã€ãƒã‚¤ãƒ³ã‚¿ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã™ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚"
