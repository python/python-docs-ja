# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# tomo, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:22+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ctypes.rst:2
msgid ":mod:`ctypes` --- A foreign function library for Python"
msgstr ":mod:`ctypes` --- Pythonのための外部関数ライブラリ"

#: ../../library/ctypes.rst:11
msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ""
":mod:`ctypes` は Python のための外部関数ライブラリです。このライブラリは C と"
"互換性のあるデータ型を提供し、動的リンク/共有ライブラリ内の関数呼び出しを可能"
"にします。動的リンク/共有ライブラリを純粋な Python でラップするために使うこと"
"ができます。"

#: ../../library/ctypes.rst:19
msgid "ctypes tutorial"
msgstr "ctypesチュートリアル"

#: ../../library/ctypes.rst:21
msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure that "
"they actually work.  Since some code samples behave differently under Linux, "
"Windows, or Mac OS X, they contain doctest directives in comments."
msgstr ""
"注意: このチュートリアルのコードサンプルは動作確認のために :mod:`doctest` を"
"使います。コードサンプルの中には Linux、 Windows、あるいは Mac OS X 上で異な"
"る動作をするものがあるため、サンプルのコメントに doctest 命令を入れてありま"
"す。"

#: ../../library/ctypes.rst:25
msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type. This type "
"is an alias for the :class:`c_long` type on 32-bit systems.  So, you should "
"not be confused if :class:`c_long` is printed if you would expect :class:"
"`c_int` --- they are actually the same type."
msgstr ""
"注意: いくつかのコードサンプルで ctypes の :class:`c_int` 型を参照していま"
"す。 32 ビットシステムにおいてこの型は :class:`c_long` 型のエイリアスです。そ"
"のため、 :class:`c_int` 型を想定しているときに :class:`c_long` が表示されたと"
"しても、混乱しないようにしてください --- 実際には同じ型なのです。"

#: ../../library/ctypes.rst:34
msgid "Loading dynamic link libraries"
msgstr "動的リンクライブラリをロードする"

#: ../../library/ctypes.rst:36
msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ""
"動的リンクライブラリをロードするために、 :mod:`ctypes` は *cdll* をエクスポー"
"トします。 Windows では *windll* と *oledll* オブジェクトをエクスポートしま"
"す。"

#: ../../library/ctypes.rst:39
msgid ""
"You load libraries by accessing them as attributes of these objects. *cdll* "
"loads libraries which export functions using the standard ``cdecl`` calling "
"convention, while *windll* libraries call functions using the ``stdcall`` "
"calling convention. *oledll* also uses the ``stdcall`` calling convention, "
"and assumes the functions return a Windows :c:type:`HRESULT` error code. The "
"error code is used to automatically raise a :class:`WindowsError` exception "
"when the function call fails."
msgstr ""
"これらのオブジェクトの属性としてライブラリにアクセスすることでライブラリを"
"ロードします。 *cdll* は標準 ``cdecl`` 呼び出し規約を用いて関数をエクスポート"
"しているライブラリをロードします。それに対して、 *windll* ライブラリは "
"``stdcall`` 呼び出し規約を用いる関数を呼び出します。 *oledll* も ``stdcall`` "
"呼び出し規約を使いますが、関数が Windows :c:type:`HRESULT` エラーコードを返す"
"ことを想定しています。このエラーコードは関数呼び出しが失敗したとき、 :class:"
"`WindowsError` 例外を自動的に送出させるために使われます。"

#: ../../library/ctypes.rst:47
msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS standard "
"C library containing most standard C functions, and uses the cdecl calling "
"convention::"
msgstr ""
"Windows用の例ですが、 ``msvcrt`` はほとんどの標準 C 関数が含まれている MS 標"
"準 C ライブラリであり、 cdecl 呼び出し規約を使うことに注意してください::"

#: ../../library/ctypes.rst:59
msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr "Windows では通常の ``.dll`` ファイル拡張子を自動的に追加します。"

#: ../../library/ctypes.rst:61
msgid ""
"On Linux, it is required to specify the filename *including* the extension "
"to load a library, so attribute access can not be used to load libraries. "
"Either the :meth:`LoadLibrary` method of the dll loaders should be used, or "
"you should load the library by creating an instance of CDLL by calling the "
"constructor::"
msgstr ""
"Linux ではライブラリをロードするために拡張子を *含む* ファイル名を指定する必"
"要があるので、ロードしたライブラリに対する属性アクセスはできません。 dll ロー"
"ダーの :meth:`LoadLibrary` メソッドを使うか、コンストラクタを呼び出して CDLL "
"のインスタンスを作ることでライブラリをロードするかのどちらかを行わなければな"
"りません::"

#: ../../library/ctypes.rst:79
msgid "Accessing functions from loaded dlls"
msgstr "ロードしたdllから関数にアクセスする"

#: ../../library/ctypes.rst:81
msgid "Functions are accessed as attributes of dll objects::"
msgstr "dll オブジェクトの属性として関数にアクセスします::"

#: ../../library/ctypes.rst:96
msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export "
"ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with an ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 ``GetModuleHandle`` "
"function, which returns a *module handle* for a given module name, has the "
"following C prototype, and a macro is used to expose one of them as "
"``GetModuleHandle`` depending on whether UNICODE is defined or not::"
msgstr ""
"``kernel32`` や ``user32`` のような win32 システム dll は、多くの場合関数の "
"UNICODE バージョンに加えて ANSI バージョンもエクスポートすることに注意してく"
"ださい。 UNICODE バージョンは後ろに ``W`` が付いた名前でエクスポートされ、 "
"ANSI バージョンは ``A`` が付いた名前でエクスポートされます。与えられたモ"
"ジュールの *モジュールハンドル* を返す win32 ``GetModuleHandle`` 関数は次のよ"
"うな C プロトタイプを持ちます。 UNICODE バージョンが定義されているかどうかに"
"より ``GetModuleHandle`` としてどちらか一つを公開するためにマクロが使われま"
"す::"

#: ../../library/ctypes.rst:109
msgid ""
"*windll* does not try to select one of them by magic, you must access the "
"version you need by specifying ``GetModuleHandleA`` or ``GetModuleHandleW`` "
"explicitly, and then call it with strings or unicode strings respectively."
msgstr ""
"*windll* は魔法を使ってどちらか一つを選ぶようなことはしません。 "
"``GetModuleHandleA`` もしくは ``GetModuleHandleW`` を明示的に指定して必要とす"
"るバージョンにアクセスし、文字列か Unicode 文字列を使ってそれぞれ呼び出さなけ"
"ればなりません。"

#: ../../library/ctypes.rst:114
msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use :func:"
"`getattr` to retrieve the function::"
msgstr ""
"時には、 dll が関数を ``\"??2@YAPAXI@Z\"`` のような Python 識別子として有効で"
"ない名前でエクスポートすることがあります。このような場合に関数を取り出すに"
"は、 :func:`getattr` を使わなければなりません。::"

#: ../../library/ctypes.rst:122
msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr ""
"Windows では、名前ではなく序数によって関数をエクスポートする dll もあります。"
"こうした関数には序数を使って dll オブジェクトにインデックス指定することでアク"
"セスします::"

#: ../../library/ctypes.rst:139
msgid "Calling functions"
msgstr "関数を呼び出す"

#: ../../library/ctypes.rst:141
msgid ""
"You can call these functions like any other Python callable. This example "
"uses the ``time()`` function, which returns system time in seconds since the "
"Unix epoch, and the ``GetModuleHandleA()`` function, which returns a win32 "
"module handle."
msgstr ""
"これらの関数は他の Python 呼び出し可能オブジェクトと同じように呼び出すことが"
"できます。この例では ``time()`` 関数 (Unixエポックからのシステム時間を秒単位"
"で返す) と、 ``GetModuleHandleA()`` 関数 (win32モジュールハンドルを返す) を使"
"います。"

#: ../../library/ctypes.rst:146
msgid ""
"This example calls both functions with a NULL pointer (``None`` should be "
"used as the NULL pointer)::"
msgstr ""
"この例は両方の関数を NULL ポインタとともに呼び出します (``None`` を NULL ポイ"
"ンタとして使う必要があります)::"

#: ../../library/ctypes.rst:155
msgid ""
":mod:`ctypes` tries to protect you from calling functions with the wrong "
"number of arguments or the wrong calling convention.  Unfortunately this "
"only works on Windows.  It does this by examining the stack after the "
"function returns, so although an error is raised the function *has* been "
"called::"
msgstr ""
":mod:`ctypes` は引数の数を間違えたり、あるいは呼び出し規約を間違えた関数呼び"
"出しからあなたを守ろうとします。残念ながら、これは Windows でしか機能しませ"
"ん。関数が返った後にスタックを調べることでこれを行います。したがって、エラー"
"は発生しますが、その関数は呼び出された *後です*::"

#: ../../library/ctypes.rst:170
msgid ""
"The same exception is raised when you call an ``stdcall`` function with the "
"``cdecl`` calling convention, or vice versa::"
msgstr ""
"同じ例外が ``cdecl`` 呼び出し規約を使って ``stdcall`` 関数を呼び出したときに"
"送出されますし、逆の場合も同様です。::"

#: ../../library/ctypes.rst:185
msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr ""
"正しい呼び出し規約を知るためには、呼び出したい関数についての C ヘッダファイル"
"もしくはドキュメントを見なければなりません。"

#: ../../library/ctypes.rst:188
msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr ""
"Windows では、関数が無効な引数とともに呼び出された場合の一般保護例外によるク"
"ラッシュを防ぐために、 :mod:`ctypes` は win32 構造化例外処理を使います::"

#: ../../library/ctypes.rst:198
msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so you "
"should be careful anyway."
msgstr ""
"しかし、 :mod:`ctypes` を使って Python をクラッシュさせる方法は十分なほどある"
"ので、よく注意すべきです。"

#: ../../library/ctypes.rst:201
msgid ""
"``None``, integers, longs, byte strings and unicode strings are the only "
"native Python objects that can directly be used as parameters in these "
"function calls. ``None`` is passed as a C ``NULL`` pointer, byte strings and "
"unicode strings are passed as pointer to the memory block that contains "
"their data (:c:type:`char *` or :c:type:`wchar_t *`).  Python integers and "
"Python longs are passed as the platforms default C :c:type:`int` type, their "
"value is masked to fit into the C type."
msgstr ""
"``None`` 、整数、長整数、バイト文字列および Unicode 文字列だけが、こうした関"
"数呼び出しにおいてパラメータとして直接使えるネイティブの Python オブジェクト"
"です。 ``None`` は C の ``NULL`` ポインタとして渡され、バイト文字列と "
"Unicode 文字列はそのデータを含むメモリブロックへのポインタ (:c:type:`char *` "
"または :c:type:`wchar_t *`) として渡されます。 Python 整数と Python 長整数は"
"プラットフォームのデフォルトの C :c:type:`int` 型として渡され、その値は C :c:"
"type:`int` 型に合うようにマスクされます。"

#: ../../library/ctypes.rst:209
msgid ""
"Before we move on calling functions with other parameter types, we have to "
"learn more about :mod:`ctypes` data types."
msgstr ""
"他のパラメータ型をもつ関数呼び出しに移る前に、 :mod:`ctypes` データ型について"
"さらに学ぶ必要があります。"

#: ../../library/ctypes.rst:216 ../../library/ctypes.rst:2142
msgid "Fundamental data types"
msgstr "基本データ型"

#: ../../library/ctypes.rst:218
msgid ":mod:`ctypes` defines a number of primitive C compatible data types:"
msgstr ""
":mod:`ctypes` ではいくつもの C 互換のプリミティブなデータ型を定義しています:"

#: ../../library/ctypes.rst:221
msgid "ctypes type"
msgstr "ctypes の型"

#: ../../library/ctypes.rst:221
msgid "C type"
msgstr "C の型"

#: ../../library/ctypes.rst:221
msgid "Python type"
msgstr "Python の型"

#: ../../library/ctypes.rst:223
msgid ":class:`c_bool`"
msgstr ":class:`c_bool`"

#: ../../library/ctypes.rst:223
msgid ":c:type:`_Bool`"
msgstr ":c:type:`_Bool`"

#: ../../library/ctypes.rst:223
msgid "bool (1)"
msgstr "bool (1)"

#: ../../library/ctypes.rst:225
msgid ":class:`c_char`"
msgstr ":class:`c_char`"

#: ../../library/ctypes.rst:225 ../../library/ctypes.rst:229
msgid ":c:type:`char`"
msgstr ":c:type:`char`"

#: ../../library/ctypes.rst:225
msgid "1-character string"
msgstr "1文字の文字列"

#: ../../library/ctypes.rst:227
msgid ":class:`c_wchar`"
msgstr ":class:`c_wchar`"

#: ../../library/ctypes.rst:227
msgid ":c:type:`wchar_t`"
msgstr ":c:type:`wchar_t`"

#: ../../library/ctypes.rst:227
msgid "1-character unicode string"
msgstr "1文字の Unicode 文字列"

#: ../../library/ctypes.rst:229
msgid ":class:`c_byte`"
msgstr ":class:`c_byte`"

#: ../../library/ctypes.rst:229 ../../library/ctypes.rst:231
#: ../../library/ctypes.rst:233 ../../library/ctypes.rst:235
#: ../../library/ctypes.rst:237 ../../library/ctypes.rst:239
#: ../../library/ctypes.rst:241 ../../library/ctypes.rst:243
#: ../../library/ctypes.rst:245 ../../library/ctypes.rst:247
msgid "int/long"
msgstr "整数/長整数"

#: ../../library/ctypes.rst:231
msgid ":class:`c_ubyte`"
msgstr ":class:`c_ubyte`"

#: ../../library/ctypes.rst:231
msgid ":c:type:`unsigned char`"
msgstr ":c:type:`unsigned char`"

#: ../../library/ctypes.rst:233
msgid ":class:`c_short`"
msgstr ":class:`c_short`"

#: ../../library/ctypes.rst:233
msgid ":c:type:`short`"
msgstr ":c:type:`short`"

#: ../../library/ctypes.rst:235
msgid ":class:`c_ushort`"
msgstr ":class:`c_ushort`"

#: ../../library/ctypes.rst:235
msgid ":c:type:`unsigned short`"
msgstr ":c:type:`unsigned short`"

#: ../../library/ctypes.rst:237
msgid ":class:`c_int`"
msgstr ":class:`c_int`"

#: ../../library/ctypes.rst:237
msgid ":c:type:`int`"
msgstr ":c:type:`int`"

#: ../../library/ctypes.rst:239
msgid ":class:`c_uint`"
msgstr ":class:`c_uint`"

#: ../../library/ctypes.rst:239
msgid ":c:type:`unsigned int`"
msgstr ":c:type:`unsigned int`"

#: ../../library/ctypes.rst:241
msgid ":class:`c_long`"
msgstr ":class:`c_long`"

#: ../../library/ctypes.rst:241
msgid ":c:type:`long`"
msgstr ":c:type:`long`"

#: ../../library/ctypes.rst:243
msgid ":class:`c_ulong`"
msgstr ":class:`c_ulong`"

#: ../../library/ctypes.rst:243
msgid ":c:type:`unsigned long`"
msgstr ":c:type:`unsigned long`"

#: ../../library/ctypes.rst:245
msgid ":class:`c_longlong`"
msgstr ":class:`c_longlong`"

#: ../../library/ctypes.rst:245
msgid ":c:type:`__int64` or :c:type:`long long`"
msgstr ":c:type:`__int64` または :c:type:`long long`"

#: ../../library/ctypes.rst:247
msgid ":class:`c_ulonglong`"
msgstr ":class:`c_ulonglong`"

#: ../../library/ctypes.rst:247
msgid ":c:type:`unsigned __int64` or :c:type:`unsigned long long`"
msgstr ":c:type:`unsigned __int64` または :c:type:`unsigned long long`"

#: ../../library/ctypes.rst:250
msgid ":class:`c_float`"
msgstr ":class:`c_float`"

#: ../../library/ctypes.rst:250
msgid ":c:type:`float`"
msgstr ":c:type:`float`"

#: ../../library/ctypes.rst:250 ../../library/ctypes.rst:252
#: ../../library/ctypes.rst:254
msgid "float"
msgstr "浮動小数点数"

#: ../../library/ctypes.rst:252
msgid ":class:`c_double`"
msgstr ":class:`c_double`"

#: ../../library/ctypes.rst:252
msgid ":c:type:`double`"
msgstr ":c:type:`double`"

#: ../../library/ctypes.rst:254
msgid ":class:`c_longdouble`"
msgstr ":class:`c_longdouble`"

#: ../../library/ctypes.rst:254
msgid ":c:type:`long double`"
msgstr ":c:type:`long double`"

#: ../../library/ctypes.rst:256
msgid ":class:`c_char_p`"
msgstr ":class:`c_char_p`"

#: ../../library/ctypes.rst:256
msgid ":c:type:`char *` (NUL terminated)"
msgstr ":c:type:`char *` (NUL 終端)"

#: ../../library/ctypes.rst:256
msgid "string or ``None``"
msgstr "文字列または ``None``"

#: ../../library/ctypes.rst:258
msgid ":class:`c_wchar_p`"
msgstr ":class:`c_wchar_p`"

#: ../../library/ctypes.rst:258
msgid ":c:type:`wchar_t *` (NUL terminated)"
msgstr ":c:type:`wchar_t *` (NUL 終端)"

#: ../../library/ctypes.rst:258
msgid "unicode or ``None``"
msgstr "Unicode または ``None``"

#: ../../library/ctypes.rst:260
msgid ":class:`c_void_p`"
msgstr ":class:`c_void_p`"

#: ../../library/ctypes.rst:260
msgid ":c:type:`void *`"
msgstr ":c:type:`void *`"

#: ../../library/ctypes.rst:260
msgid "int/long or ``None``"
msgstr "整数/長整数または ``None``"

#: ../../library/ctypes.rst:264
msgid "The constructor accepts any object with a truth value."
msgstr "コンストラクタは任意のオブジェクトをその真偽値として受け取ります。"

#: ../../library/ctypes.rst:266
msgid ""
"All these types can be created by calling them with an optional initializer "
"of the correct type and value::"
msgstr ""
"これら全ての型はその型を呼び出すことによって作成でき、オプションとして型と値"
"が合っている初期化子を指定することができます::"

#: ../../library/ctypes.rst:277
msgid ""
"Since these types are mutable, their value can also be changed afterwards::"
msgstr "これらの型は変更可能であり、値を後で変更することもできます::"

#: ../../library/ctypes.rst:289
msgid ""
"Assigning a new value to instances of the pointer types :class:`c_char_p`, :"
"class:`c_wchar_p`, and :class:`c_void_p` changes the *memory location* they "
"point to, *not the contents* of the memory block (of course not, because "
"Python strings are immutable)::"
msgstr ""
"新しい値をポインタ型 :class:`c_char_p`, :class:`c_wchar_p` および :class:"
"`c_void_p` のインスタンスへ代入すると、変わるのは指している *メモリ位置* で"
"あって、メモリブロックの *内容ではありません* (これは当然で、なぜなら、 "
"Python 文字列は変更不可能だからです)::"

#: ../../library/ctypes.rst:305
msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has a :"
"func:`create_string_buffer` function which creates these in various ways.  "
"The current memory block contents can be accessed (or changed) with the "
"``raw`` property; if you want to access it as NUL terminated string, use the "
"``value`` property::"
msgstr ""
"しかし、変更可能なメモリを指すポインタであることを想定している関数へそれらを"
"渡さないように注意すべきです。もし変更可能なメモリブロックが必要なら、 "
"ctypes には :func:`create_string_buffer` 関数があり、いろいろな方法で作成する"
"ことできます。現在のメモリブロックの内容は ``raw`` プロパティを使ってアクセ"
"ス (あるいは変更) することができます。もし現在のメモリブロックに NUL 終端文字"
"列としてアクセスしたいなら、 ``value`` プロパティを使ってください::"

#: ../../library/ctypes.rst:329
msgid ""
"The :func:`create_string_buffer` function replaces the :func:`c_buffer` "
"function (which is still available as an alias), as well as the :func:"
"`c_string` function from earlier ctypes releases.  To create a mutable "
"memory block containing unicode characters of the C type :c:type:`wchar_t` "
"use the :func:`create_unicode_buffer` function."
msgstr ""
":func:`create_string_buffer` 関数は初期の ctypes リリースにあった :func:"
"`c_string` 関数だけでなく、 (エイリアスとしてはまだ利用できる) :func:"
"`c_buffer` 関数をも置き換えるものです。 C の型 :c:type:`wchar_t` の Unicode "
"文字を含む変更可能なメモリブロックを作成するには、 :func:"
"`create_unicode_buffer` 関数を使ってください。"

#: ../../library/ctypes.rst:339
msgid "Calling functions, continued"
msgstr "続・関数を呼び出す"

#: ../../library/ctypes.rst:341
msgid ""
"Note that printf prints to the real standard output channel, *not* to :data:"
"`sys.stdout`, so these examples will only work at the console prompt, not "
"from within *IDLE* or *PythonWin*::"
msgstr ""
"printf は :data:`sys.stdout` では *なく* 、本物の標準出力チャンネルへプリント"
"することに注意してください。したがって、これらの例はコンソールプロンプトでの"
"み動作し、 *IDLE* や *PythonWin* では動作しません。::"

#: ../../library/ctypes.rst:361
msgid ""
"As has been mentioned before, all Python types except integers, strings, and "
"unicode strings have to be wrapped in their corresponding :mod:`ctypes` "
"type, so that they can be converted to the required C data type::"
msgstr ""
"前に述べたように、必要な C のデータ型へ変換できるようにするためには、整数、文"
"字列および Unicode 文字列を除くすべての Python 型を対応する :mod:`ctypes` 型"
"でラップしなければなりません。::"

#: ../../library/ctypes.rst:374
msgid "Calling functions with your own custom data types"
msgstr "自作のデータ型とともに関数を呼び出す"

#: ../../library/ctypes.rst:376
msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow instances "
"of your own classes be used as function arguments.  :mod:`ctypes` looks for "
"an :attr:`_as_parameter_` attribute and uses this as the function argument.  "
"Of course, it must be one of integer, string, or unicode::"
msgstr ""
"自作のクラスのインスタンスを関数引数として使えるように、 :mod:`ctypes` 引数変"
"換をカスタマイズすることもできます。 :mod:`ctypes` は :attr:`_as_parameter_` "
"属性を探し出し、関数引数として使います。もちろん、整数、文字列もしくは "
"Unicode の中の一つでなければなりません。::"

#: ../../library/ctypes.rst:391
msgid ""
"If you don't want to store the instance's data in the :attr:`_as_parameter_` "
"instance variable, you could define a :func:`property` which makes the data "
"available."
msgstr ""
"インスタンスのデータを :attr:`_as_parameter_` インスタンス変数の中に入れたく"
"ない場合には、そのデータを利用できるようにする :func:`property` を定義するこ"
"とができます。"

#: ../../library/ctypes.rst:399
msgid "Specifying the required argument types (function prototypes)"
msgstr "要求される引数の型を指定する (関数プロトタイプ)"

#: ../../library/ctypes.rst:401
msgid ""
"It is possible to specify the required argument types of functions exported "
"from DLLs by setting the :attr:`argtypes` attribute."
msgstr ""
":attr:`argtypes` 属性を設定することによって、 DLL からエクスポートされている"
"関数に要求される引数の型を指定することができます。"

#: ../../library/ctypes.rst:404
msgid ""
":attr:`argtypes` must be a sequence of C data types (the ``printf`` function "
"is probably not a good example here, because it takes a variable number and "
"different types of parameters depending on the format string, on the other "
"hand this is quite handy to experiment with this feature)::"
msgstr ""
":attr:`argtypes` は C データ型のシーケンスでなければなりません (この場合 "
"``printf`` 関数はおそらく良い例ではありません。なぜなら、引数の数が可変であ"
"り、フォーマット文字列に依存した異なる型のパラメータを取るからです。一方で"
"は、この機能の実験にはとても便利です)。::"

#: ../../library/ctypes.rst:415
msgid ""
"Specifying a format protects against incompatible argument types (just as a "
"prototype for a C function), and tries to convert the arguments to valid "
"types::"
msgstr ""
"(C の関数のプロトタイプのように) 書式を指定すると互換性のない引数型になるのを"
"防ぎ、引数を有効な型へ変換しようとします。::"

#: ../../library/ctypes.rst:427
msgid ""
"If you have defined your own classes which you pass to function calls, you "
"have to implement a :meth:`from_param` class method for them to be able to "
"use them in the :attr:`argtypes` sequence. The :meth:`from_param` class "
"method receives the Python object passed to the function call, it should do "
"a typecheck or whatever is needed to make sure this object is acceptable, "
"and then return the object itself, its :attr:`_as_parameter_` attribute, or "
"whatever you want to pass as the C function argument in this case. Again, "
"the result should be an integer, string, unicode, a :mod:`ctypes` instance, "
"or an object with an :attr:`_as_parameter_` attribute."
msgstr ""
"関数呼び出しへ渡す自作のクラスを定義した場合には、 :attr:`argtypes` シーケン"
"スの中で使えるようにするために、そのクラスに :meth:`from_param` クラスメソッ"
"ドを実装しなければなりません。 :meth:`from_param` クラスメソッドは関数呼び出"
"しへ渡された Python オブジェクトを受け取り、型チェックもしくはこのオブジェク"
"トが受け入れ可能であると確かめるために必要なことはすべて行ってから、オブジェ"
"クト自身、 :attr:`_as_parameter_` 属性、あるいは、この場合に C 関数引数として"
"渡したい何かの値を返さなければなりません。繰り返しになりますが、その返される"
"結果は整数、文字列、 Unicode 、 :mod:`ctypes` インスタンス、あるいは :attr:"
"`_as_parameter_` 属性をもつオブジェクトであるべきです。"

#: ../../library/ctypes.rst:441
msgid "Return types"
msgstr "戻り値の型"

#: ../../library/ctypes.rst:443
msgid ""
"By default functions are assumed to return the C :c:type:`int` type.  Other "
"return types can be specified by setting the :attr:`restype` attribute of "
"the function object."
msgstr ""
"デフォルトでは、関数は C :c:type:`int` を返すと仮定されます。他の戻り値の型を"
"指定するには、関数オブジェクトの :attr:`restype` 属性に設定します。"

#: ../../library/ctypes.rst:447
msgid ""
"Here is a more advanced example, it uses the ``strchr`` function, which "
"expects a string pointer and a char, and returns a pointer to a string::"
msgstr ""
"さらに高度な例として、 ``strchr`` 関数を使います。この関数は文字列ポインタと "
"char を受け取り、文字列へのポインタを返します。::"

#: ../../library/ctypes.rst:460
msgid ""
"If you want to avoid the ``ord(\"x\")`` calls above, you can set the :attr:"
"`argtypes` attribute, and the second argument will be converted from a "
"single character Python string into a C char::"
msgstr ""
"上の ``ord(\"x\")`` 呼び出しを避けたいなら、 :attr:`argtypes` 属性を設定する"
"ことができます。二番目の引数が一文字の Python 文字列から C の char へ変換され"
"ます。::"

#: ../../library/ctypes.rst:478
msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`restype` attribute, if the foreign function returns "
"an integer.  The callable will be called with the *integer* the C function "
"returns, and the result of this call will be used as the result of your "
"function call. This is useful to check for error return values and "
"automatically raise an exception::"
msgstr ""
"外部関数が整数を返す場合は、 :attr:`restype` 属性として呼び出し可能な Python "
"オブジェクト (例えば、関数またはクラス) を使うこともできます。呼び出し可能オ"
"ブジェクトは C 関数が返す *整数* とともに呼び出され、この呼び出しの結果は関数"
"呼び出しの結果として使われるでしょう。これはエラーの戻り値をチェックして自動"
"的に例外を送出させるために役に立ちます。::"

#: ../../library/ctypes.rst:501
msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` api "
"to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one is "
"used, it calls :func:`GetLastError` to retrieve it."
msgstr ""
"``WinError`` はエラーコードの文字列表現を得るために Windows の "
"``FormatMessage()`` api を呼び出し、例外を *返す* 関数です。 ``WinError`` は"
"オプションでエラーコードパラメータを取ります。このパラメータが使われない場合"
"は、エラーコードを取り出すために :func:`GetLastError` を呼び出します。"

#: ../../library/ctypes.rst:506
msgid ""
"Please note that a much more powerful error checking mechanism is available "
"through the :attr:`errcheck` attribute; see the reference manual for details."
msgstr ""
":attr:`errcheck` 属性によってもっと強力なエラーチェック機構を利用できることに"
"注意してください。詳細はリファレンスマニュアルを参照してください。"

#: ../../library/ctypes.rst:513
msgid "Passing pointers (or: passing parameters by reference)"
msgstr "ポインタを渡す(または、パラメータの参照渡し)"

#: ../../library/ctypes.rst:515
msgid ""
"Sometimes a C api function expects a *pointer* to a data type as parameter, "
"probably to write into the corresponding location, or if the data is too "
"large to be passed by value. This is also known as *passing parameters by "
"reference*."
msgstr ""
"時には、 C api 関数がパラメータのデータ型として *ポインタ* を想定していること"
"があります。おそらくパラメータと同一の場所に書き込むためか、もしくはそのデー"
"タが大きすぎて値渡しできない場合です。これは *パラメータの参照渡し* としても"
"知られています。"

#: ../../library/ctypes.rst:519
msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the :func:"
"`pointer` function, although :func:`pointer` does a lot more work since it "
"constructs a real pointer object, so it is faster to use :func:`byref` if "
"you don't need the pointer object in Python itself::"
msgstr ""
":mod:`ctypes` は :func:`byref` 関数をエクスポートしており、パラメータを参照渡"
"しするために使用します。 :func:`pointer` 関数を使っても同じ効果が得られます。"
"しかし、 :func:`pointer` は本当のポインタオブジェクトを構築するためより多くの"
"処理を行うことから、 Python 側でポインタオブジェクト自体を必要としないなら"
"ば :func:`byref` を使う方がより高速です。::"

#: ../../library/ctypes.rst:541
msgid "Structures and unions"
msgstr "構造体と共用体"

#: ../../library/ctypes.rst:543
msgid ""
"Structures and unions must derive from the :class:`Structure` and :class:"
"`Union` base classes which are defined in the :mod:`ctypes` module. Each "
"subclass must define a :attr:`_fields_` attribute.  :attr:`_fields_` must be "
"a list of *2-tuples*, containing a *field name* and a *field type*."
msgstr ""
"構造体と共用体は :mod:`ctypes` モジュールに定義されている :class:`Structure` "
"および :class:`Union` ベースクラスからの派生クラスでなければなりません。それ"
"ぞれのサブクラスは :attr:`_fields_` 属性を定義する必要があります。 :attr:"
"`_fields_` は *フィールド名* と *フィールド型* を持つ *2要素タプル* のリスト"
"でなければなりません。"

#: ../../library/ctypes.rst:548
msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr ""
"フィールド型は :class:`c_int` か他の :mod:`ctypes` 型 (構造体、共用体、配列、"
"ポインタ) から派生した :mod:`ctypes` 型である必要があります。"

#: ../../library/ctypes.rst:551
msgid ""
"Here is a simple example of a POINT structure, which contains two integers "
"named *x* and *y*, and also shows how to initialize a structure in the "
"constructor::"
msgstr ""
"*x* と *y* という名前の二つの整数からなる簡単な POINT 構造体の例です。コンス"
"トラクタで構造体の初期化する方法の説明にもなっています。::"

#: ../../library/ctypes.rst:571
msgid ""
"You can, however, build much more complicated structures.  A structure can "
"itself contain other structures by using a structure as a field type."
msgstr ""
"しかし、もっと複雑な構造体を構築することもできます。ある構造体は、他の構造体"
"をフィールド型として使うことで、他の構造体を含むことができます。"

#: ../../library/ctypes.rst:574
msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr ""
"*upperleft* と *lowerright* という名前の二つの POINT を持つ RECT 構造体で"
"す。::"

#: ../../library/ctypes.rst:588
msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr ""
"入れ子になった構造体はいくつかの方法を用いてコンストラクタで初期化することが"
"できます。::"

#: ../../library/ctypes.rst:593
msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information::"
msgstr ""
"フィールド :term:`descriptor` (記述子)は *クラス* から取り出せます。デバッグ"
"するときに役に立つ情報を得ることができます::"

#: ../../library/ctypes.rst:607
msgid ""
":mod:`ctypes` does not support passing unions or structures with bit-fields "
"to functions by value.  While this may work on 32-bit x86, it's not "
"guaranteed by the library to work in the general case.  Unions and "
"structures with bit-fields should always be passed to functions by pointer."
msgstr ""
":mod:`ctypes` では、ビットフィールドのある共用体や構造体の関数への値渡しはサ"
"ポートしていません。これは 32-bit の x86 環境では動くかもしれませんが、このラ"
"イブラリでは一般の場合に動作することは保証していません。"

#: ../../library/ctypes.rst:613
msgid "Structure/union alignment and byte order"
msgstr "構造体/共用体アライメントとバイトオーダー"

#: ../../library/ctypes.rst:615
msgid ""
"By default, Structure and Union fields are aligned in the same way the C "
"compiler does it. It is possible to override this behavior be specifying a :"
"attr:`_pack_` class attribute in the subclass definition. This must be set "
"to a positive integer and specifies the maximum alignment for the fields. "
"This is what ``#pragma pack(n)`` also does in MSVC."
msgstr ""
"デフォルトでは、構造体 (Structure) と共用体(Union) のフィールドは C コンパイ"
"ラが行うのと同じ方法でアライメントされています。サブクラスを定義するときに :"
"attr:`_pack_` クラス属性を指定することでこの動作を変えることは可能です。この"
"クラス属性には正の整数を設定する必要があり、フィールドの最大アライメントを指"
"定します。これは MSVC で ``#pragma pack(n)`` が行っていること同じです。"

#: ../../library/ctypes.rst:621
msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the :class:"
"`BigEndianStructure`, :class:`LittleEndianStructure`, :class:"
"`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  These "
"classes cannot contain pointer fields."
msgstr ""
":mod:`ctypes` は Structure と Union に対してネイティブのバイトオーダーを使い"
"ます。ネイティブではないバイトオーダーの構造体を作成するには、 :class:"
"`BigEndianStructure`, :class:`LittleEndianStructure`, :class:"
"`BigEndianUnion` および :class:`LittleEndianUnion` ベースクラスの中の一つを使"
"います。これらのクラスにポインタフィールドを持たせることはできません。"

#: ../../library/ctypes.rst:631
msgid "Bit fields in structures and unions"
msgstr "構造体と共用体におけるビットフィールド"

#: ../../library/ctypes.rst:633
msgid ""
"It is possible to create structures and unions containing bit fields. Bit "
"fields are only possible for integer fields, the bit width is specified as "
"the third item in the :attr:`_fields_` tuples::"
msgstr ""
"ビットフィールドを含む構造体と共用体を作ることができます。ビットフィールドは"
"整数フィールドに対してのみ作ることができ、ビット幅は :attr:`_fields_` タプル"
"の第三要素で指定します。::"

#: ../../library/ctypes.rst:651
msgid "Arrays"
msgstr "配列"

#: ../../library/ctypes.rst:653
msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr ""
"配列 (Array) はシーケンスであり、決まった数の同じ型のインスタンスを持ちます。"

#: ../../library/ctypes.rst:655
msgid ""
"The recommended way to create array types is by multiplying a data type with "
"a positive integer::"
msgstr "推奨されている配列の作成方法はデータ型に正の整数を掛けることです。::"

#: ../../library/ctypes.rst:660
msgid ""
"Here is an example of a somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr ""
"ややわざとらしいデータ型の例になりますが、他のものに混ざって 4 個の POINT が"
"ある構造体です::"

#: ../../library/ctypes.rst:676
msgid "Instances are created in the usual way, by calling the class::"
msgstr "インスタンスはクラスを呼び出す通常の方法で作成します。::"

#: ../../library/ctypes.rst:682
msgid ""
"The above code print a series of ``0 0`` lines, because the array contents "
"is initialized to zeros."
msgstr ""
"上記のコードは ``0 0`` という行が並んだものを表示します。配列の要素がゼロで初"
"期化されているためです。"

#: ../../library/ctypes.rst:685
msgid "Initializers of the correct type can also be specified::"
msgstr "正しい型の初期化子を指定することもできます。::"

#: ../../library/ctypes.rst:701
msgid "Pointers"
msgstr "ポインタ"

#: ../../library/ctypes.rst:703
msgid ""
"Pointer instances are created by calling the :func:`pointer` function on a :"
"mod:`ctypes` type::"
msgstr ""
"ポインタのインスタンスは :mod:`ctypes` 型に対して :func:`pointer` 関数を呼び"
"出して作成します。::"

#: ../../library/ctypes.rst:711
msgid ""
"Pointer instances have a :attr:`~_Pointer.contents` attribute which returns "
"the object to which the pointer points, the ``i`` object above::"
msgstr ""
"次のように、ポインタインスタンスは、ポインタが指すオブジェクト (上の例では "
"``i``) を返す :attr:`~_Pointer.contents` 属性を持ちます::"

#: ../../library/ctypes.rst:718
msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ""
":mod:`ctypes` は OOR (original object return 、元のオブジェクトを返すこと) で"
"はないことに注意してください。属性を取り出す度に、新しい同等のオブジェクトを"
"作成しているのです。::"

#: ../../library/ctypes.rst:727
msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where this "
"is stored::"
msgstr ""
"別の :class:`c_int` インスタンスがポインタの contents 属性に代入されると、こ"
"れが記憶されているメモリ位置を指すポインタに変化します。::"

#: ../../library/ctypes.rst:739
msgid "Pointer instances can also be indexed with integers::"
msgstr "ポインタインスタンスは整数でインデックス指定することもできます。::"

#: ../../library/ctypes.rst:745
msgid "Assigning to an integer index changes the pointed to value::"
msgstr "整数インデックスへ代入するとポインタが指す値が変更されます。::"

#: ../../library/ctypes.rst:754
msgid ""
"It is also possible to use indexes different from 0, but you must know what "
"you're doing, just as in C: You can access or change arbitrary memory "
"locations. Generally you only use this feature if you receive a pointer from "
"a C function, and you *know* that the pointer actually points to an array "
"instead of a single item."
msgstr ""
"0 ではないインデックスを使うこともできますが、 C の場合と同じように自分が何を"
"しているかを理解している必要があります。任意のメモリ位置にアクセスもしくは変"
"更できるのです。一般的にこの機能を使うのは、 C 関数からポインタを受け取り、そ"
"のポインタが単一の要素ではなく実際に配列を指していると *分かっている* 場合だ"
"けです。"

#: ../../library/ctypes.rst:760
msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply create "
"pointer instances, it has to create pointer *types* first.  This is done "
"with the :func:`POINTER` function, which accepts any :mod:`ctypes` type, and "
"returns a new type::"
msgstr ""
"舞台裏では、 :func:`pointer` 関数は単にポインタインスタンスを作成するという以"
"上のことを行っています。はじめにポインタ *型* を作成する必要があります。これ"
"は任意の :mod:`ctypes` 型を受け取る :func:`POINTER` 関数を使って行われ、新し"
"い型を返します。::"

#: ../../library/ctypes.rst:776
msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr ""
"ポインタ型を引数なしで呼び出すと ``NULL`` ポインタを作成します。 ``NULL`` ポ"
"インタは ``False`` ブール値を持っています。::"

#: ../../library/ctypes.rst:784
msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ""
":mod:`ctypes` はポインタの指す値を取り出すときに ``NULL`` かどうかを調べます"
"(しかし、 ``NULL`` でない不正なポインタの指す値の取り出す行為は Python をク"
"ラッシュさせるでしょう)。::"

#: ../../library/ctypes.rst:803
msgid "Type conversions"
msgstr "型変換"

#: ../../library/ctypes.rst:805
msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`argtypes` list of a function or as the type "
"of a member field in a structure definition, only instances of exactly the "
"same type are accepted.  There are some exceptions to this rule, where "
"ctypes accepts other objects.  For example, you can pass compatible array "
"instances instead of pointer types.  So, for ``POINTER(c_int)``, ctypes "
"accepts an array of c_int::"
msgstr ""
"たいていの場合、 ctypes は厳密な型チェックを行います。これが意味するのは、関"
"数の :attr:`argtypes` リスト内に、もしくは、構造体定義におけるメンバーフィー"
"ルドの型として ``POINTER(c_int)`` がある場合、厳密に同じ型のインスタンスだけ"
"を受け取るということです。このルールには ctypes が他のオブジェクトを受け取る"
"場合に例外がいくつかあります。例えば、ポインタ型の代わりに互換性のある配列イ"
"ンスタンスを渡すことができます。このように、 ``POINTER(c_int)`` に対して、 "
"ctypes は c_int の配列を受け取ります。::"

#: ../../library/ctypes.rst:826
msgid ""
"In addition, if a function argument is explicitly declared to be a pointer "
"type (such as ``POINTER(c_int)``) in :attr:`argtypes`, an object of the "
"pointed type (``c_int`` in this case) can be passed to the function.  ctypes "
"will apply the required :func:`byref` conversion in this case automatically."
msgstr ""
"それに加えて、 :attr:`argtypes` で関数の引数が明示的に (``POINTER(c_int)`` な"
"どの) ポインタ型であると宣言されていた場合、ポインタ型が指し示している型のオ"
"ブジェクト (この場合では ``c_int``) を関数に渡すことができます。この場合 "
"ctypes は、必要となる :func:`byref` での変換を自動的に適用します。"

#: ../../library/ctypes.rst:831
msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr ""
"POINTER型フィールドを ``NULL`` に設定するために、 ``None`` を代入してもかまい"
"ません。::"

#: ../../library/ctypes.rst:838
msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast one "
"type into another type.  :mod:`ctypes` provides a :func:`cast` function "
"which can be used in the same way.  The ``Bar`` structure defined above "
"accepts ``POINTER(c_int)`` pointers or :class:`c_int` arrays for its "
"``values`` field, but not instances of other types::"
msgstr ""
"時には、非互換な型のインスタンスであることもあります。 C では、ある型を他の型"
"へキャストすることができます。 :mod:`ctypes` は同じやり方で使える :func:"
"`cast` 関数を提供しています。上で定義した ``Bar`` 構造体は "
"``POINTER(c_int)`` ポインタまたは :class:`c_int` 配列を ``values`` フィールド"
"に対して受け取り、他の型のインスタンスは受け取りません::"

#: ../../library/ctypes.rst:850
msgid "For these cases, the :func:`cast` function is handy."
msgstr "このような場合には、 :func:`cast` 関数が便利です。"

#: ../../library/ctypes.rst:852
msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two parameters, "
"a ctypes object that is or can be converted to a pointer of some kind, and a "
"ctypes pointer type.  It returns an instance of the second argument, which "
"references the same memory block as the first argument::"
msgstr ""
":func:`cast` 関数は ctypes インスタンスを異なる ctypes データ型を指すポインタ"
"へキャストするために使えます。 :func:`cast` は二つのパラメータ、ある種のポイ"
"ンタかそのポインタへ変換できる ctypes オブジェクトと、 ctypes ポインタ型を取"
"ります。そして、第二引数のインスタンスを返します。このインスタンスは第一引数"
"と同じメモリブロックを参照しています::"

#: ../../library/ctypes.rst:863
msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar`` "
"the structure::"
msgstr ""
"したがって、 :func:`cast` を ``Bar`` 構造体の ``values`` フィールドへ代入する"
"ために使うことができます::"

#: ../../library/ctypes.rst:876
msgid "Incomplete Types"
msgstr "不完全型"

#: ../../library/ctypes.rst:878
msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not "
"yet specified. In C, they are specified by forward declarations, which are "
"defined later::"
msgstr ""
"*不完全型* はメンバーがまだ指定されていない構造体、共用体もしくは配列です。 "
"C では、前方宣言により指定され、後で定義されます。::"

#: ../../library/ctypes.rst:889
msgid ""
"The straightforward translation into ctypes code would be this, but it does "
"not work::"
msgstr ""
"ctypes コードへの直接的な変換ではこうなるでしょう。しかし、動作しません::"

#: ../../library/ctypes.rst:902
msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the :attr:"
"`_fields_` attribute later, after the class statement::"
msgstr ""
"なぜなら、新しい ``class cell`` はクラス文自体の中では利用できないからで"
"す。 :mod:`ctypes` では、 ``cell`` クラスを定義して、 :attr:`_fields_` 属性を"
"クラス文の後で設定することができます。::"

#: ../../library/ctypes.rst:914
msgid ""
"Lets try it. We create two instances of ``cell``, and let them point to each "
"other, and finally follow the pointer chain a few times::"
msgstr ""
"試してみましょう。 ``cell`` のインスタンスを二つ作り、互いに参照し合うように"
"します。最後に、つながったポインタを何度かたどります。::"

#: ../../library/ctypes.rst:935
msgid "Callback functions"
msgstr "コールバック関数"

#: ../../library/ctypes.rst:937
msgid ""
":mod:`ctypes` allows creating C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ""
":mod:`ctypes` は C の呼び出し可能な関数ポインタを Python 呼び出し可能オブジェ"
"クトから作成できるようにします。これらは *コールバック関数* と呼ばれることが"
"あります。"

#: ../../library/ctypes.rst:940
msgid ""
"First, you must create a class for the callback function, the class knows "
"the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr ""
"最初に、コールバック関数のためのクラスを作る必要があります。そのクラスには呼"
"び出し規約、戻り値の型およびこの関数が受け取る引数の数と型についての情報があ"
"ります。"

#: ../../library/ctypes.rst:944
msgid ""
"The CFUNCTYPE factory function creates types for callback functions using "
"the normal cdecl calling convention, and, on Windows, the WINFUNCTYPE "
"factory function creates types for callback functions using the stdcall "
"calling convention."
msgstr ""
"CFUNCTYPE ファクトリ関数は通常の cdecl 呼び出し規約を用いてコールバック関数の"
"ための型を作成します。 Windows では、 WINFUNCTYPE ファクトリ関数が stdcall 呼"
"び出し規約を用いてコールバック関数の型を作成します。"

#: ../../library/ctypes.rst:949
msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr ""
"これらのファクトリ関数はともに最初の引数に戻り値の型、残りの引数としてコール"
"バック関数が想定する引数の型を渡して呼び出されます。"

#: ../../library/ctypes.rst:953
msgid ""
"I will present an example here which uses the standard C library's :func:"
"`qsort` function, this is used to sort items with the help of a callback "
"function. :func:`qsort` will be used to sort an array of integers::"
msgstr ""
"標準 C ライブラリの :func:`qsort` 関数を使う例を示します。これはコールバック"
"関数の助けをかりて要素をソートするために使われます。 :func:`qsort` は整数の配"
"列をソートするために使われます。::"

#: ../../library/ctypes.rst:963
msgid ""
":func:`qsort` must be called with a pointer to the data to sort, the number "
"of items in the data array, the size of one item, and a pointer to the "
"comparison function, the callback. The callback will then be called with two "
"pointers to items, and it must return a negative integer if the first item "
"is smaller than the second, a zero if they are equal, and a positive integer "
"else."
msgstr ""
":func:`qsort` はソートするデータを指すポインタ、データ配列の要素の数、要素の"
"一つの大きさ、およびコールバック関数である比較関数へのポインタを引数に渡して"
"呼び出さなければなりません。そして、コールバック関数は要素を指す二つのポイン"
"タを渡されて呼び出され、一番目が二番目より小さいなら負の数を、等しいならゼロ"
"を、それ以外なら正の数を返さなければなりません。"

#: ../../library/ctypes.rst:969
msgid ""
"So our callback function receives pointers to integers, and must return an "
"integer. First we create the ``type`` for the callback function::"
msgstr ""
"コールバック関数は整数へのポインタを受け取り、整数を返す必要があります。ま"
"ず、コールバック関数のための ``type`` を作成します。::"

#: ../../library/ctypes.rst:975
msgid ""
"For the first implementation of the callback function, we simply print the "
"arguments we get, and return 0 (incremental development ;-)::"
msgstr ""
"コールバック関数のはじめての実装なので、受け取った引数を単純に表示して、 0 を"
"返します (漸進型開発 (incremental development)です ;-)::"

#: ../../library/ctypes.rst:984
msgid "Create the C callable callback::"
msgstr "C の呼び出し可能なコールバック関数を作成します。::"

#: ../../library/ctypes.rst:989
msgid "And we're ready to go::"
msgstr "そうすると、準備完了です。::"

#: ../../library/ctypes.rst:1004
msgid ""
"We know how to access the contents of a pointer, so lets redefine our "
"callback::"
msgstr ""
"ポインタの中身にアクセスする方法がわかっているので、コールバック関数を再定義"
"しましょう。::"

#: ../../library/ctypes.rst:1013
msgid "Here is what we get on Windows::"
msgstr "Windows での実行結果です。::"

#: ../../library/ctypes.rst:1028
msgid ""
"It is funny to see that on linux the sort function seems to work much more "
"efficiently, it is doing less comparisons::"
msgstr ""
"linux ではソート関数がはるかに効率的に動作しており、実施する比較の数が少ない"
"ように見えるのが不思議です。::"

#: ../../library/ctypes.rst:1039
msgid ""
"Ah, we're nearly done! The last step is to actually compare the two items "
"and return a useful result::"
msgstr ""
"ええ、ほぼ完成です! 最終段階は、実際に二つの要素を比較して実用的な結果を返す"
"ことです。::"

#: ../../library/ctypes.rst:1048
msgid "Final run on Windows::"
msgstr "Windows での最終的な実行結果です。::"

#: ../../library/ctypes.rst:1063
msgid "and on Linux::"
msgstr "Linuxでは::"

#: ../../library/ctypes.rst:1073
msgid ""
"It is quite interesting to see that the Windows :func:`qsort` function needs "
"more comparisons than the linux version!"
msgstr ""
"Windows の :func:`qsort` 関数は linux バージョンより多く比較する必要があるこ"
"とがわかり、非常におもしろいですね!"

#: ../../library/ctypes.rst:1076
msgid "As we can easily check, our array is sorted now::"
msgstr "簡単に確認できるように、今では配列はソートされています。::"

#: ../../library/ctypes.rst:1085
msgid ""
"Make sure you keep references to :func:`CFUNCTYPE` objects as long as they "
"are used from C code. :mod:`ctypes` doesn't, and if you don't, they may be "
"garbage collected, crashing your program when a callback is made."
msgstr ""
"C コードから使われる限り、 :func:`CFUNCTYPE` オブジェクトへの参照を確実に保持"
"してください。 :mod:`ctypes` は保持しません。もしあなたがやらなければ、オブ"
"ジェクトはゴミ集めされてしまい、コールバックしたときにあなたのプログラムをク"
"ラッシュさせるかもしれません。"

#: ../../library/ctypes.rst:1089
msgid ""
"Also, note that if the callback function is called in a thread created "
"outside of Python's control (e.g. by the foreign code that calls the "
"callback), ctypes creates a new dummy Python thread on every invocation. "
"This behavior is correct for most purposes, but it means that values stored "
"with :class:`threading.local` will *not* survive across different callbacks, "
"even when those calls are made from the same C thread."
msgstr ""
"同様に、コールバック関数が Python の管理外 (例えば、コールバックを呼び出す外"
"部のコード) で作られたスレッドで呼び出された場合、 ctypes は全ての呼び出しご"
"とに新しいダミーの Python スレッドを作成することに注意してください。 この動作"
"はほとんどの目的に対して正しいものですが、同じ C スレッドからの呼び出しだった"
"としても、 :class:`threading.local` で格納された値は異なるコールバックをまた"
"いで生存は *しません* 。"

#: ../../library/ctypes.rst:1099
msgid "Accessing values exported from dlls"
msgstr "dllからエクスポートされている値へアクセスする"

#: ../../library/ctypes.rst:1101
msgid ""
"Some shared libraries not only export functions, they also export variables. "
"An example in the Python library itself is the ``Py_OptimizeFlag``, an "
"integer set to 0, 1, or 2, depending on the :option:`-O` or :option:`-OO` "
"flag given on startup."
msgstr ""
"共有ライブラリの一部は関数だけでなく変数もエクスポートしています。 Python ラ"
"イブラリにある例としては ``Py_OptimizeFlag`` 、起動時の :option:`-O` または :"
"option:`-OO` フラグに依存して、 0 , 1 または 2 が設定される整数があります。"

#: ../../library/ctypes.rst:1106
msgid ""
":mod:`ctypes` can access values like this with the :meth:`in_dll` class "
"methods of the type.  *pythonapi* is a predefined symbol giving access to "
"the Python C api::"
msgstr ""
":mod:`ctypes` は型の :meth:`in_dll` クラスメソッドを使ってこのように値にアク"
"セスできます。 *pythonapi* はPython C api へアクセスできるようにするための予"
"め定義されたシンボルです。::"

#: ../../library/ctypes.rst:1115
msgid ""
"If the interpreter would have been started with :option:`-O`, the sample "
"would have printed ``c_long(1)``, or ``c_long(2)`` if :option:`-OO` would "
"have been specified."
msgstr ""
"インタープリタが :option:`-O` を指定されて動き始めた場合、サンプルは "
"``c_long(1)`` を表示するでしょうし、 :option:`-OO` が指定されたならば "
"``c_long(2)`` を表示するでしょう。"

#: ../../library/ctypes.rst:1119
msgid ""
"An extended example which also demonstrates the use of pointers accesses the "
"``PyImport_FrozenModules`` pointer exported by Python."
msgstr ""
"ポインタの使い方を説明する拡張例では、 Python がエクスポートする "
"``PyImport_FrozenModules`` ポインタにアクセスします。"

#: ../../library/ctypes.rst:1122
msgid ""
"Quoting the Python docs: *This pointer is initialized to point to an array "
"of \"struct _frozen\" records, terminated by one whose members are all NULL "
"or zero. When a frozen module is imported, it is searched in this table. "
"Third-party code could play tricks with this to provide a dynamically "
"created collection of frozen modules.*"
msgstr ""
"Python ドキュメントから引用すると: *このポインタは \"struct _frozen\" のレ"
"コードからなり、終端の要素のメンバが NULL かゼロになっているような配列を指す"
"よう初期化されます。フリーズされたモジュールを import するとき、このテーブル"
"を検索します。サードパーティ製のコードからこのポインタに仕掛けを講じて、動的"
"に生成されたフリーズ化モジュールの集合を提供するようにできます。*"

#: ../../library/ctypes.rst:1128
msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with :mod:`ctypes`::"
msgstr ""
"これで、このポインタを操作することが役に立つことを証明できるでしょう。例の大"
"きさを制限するために、このテーブルを :mod:`ctypes` を使って読む方法だけを示し"
"ます。::"

#: ../../library/ctypes.rst:1140
msgid ""
"We have defined the ``struct _frozen`` data type, so we can get the pointer "
"to the table::"
msgstr ""
"私たちは ``struct _frozen`` データ型を定義済みなので、このテーブルを指すポイ"
"ンタを得ることができます。::"

#: ../../library/ctypes.rst:1147
msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` records, "
"we can iterate over it, but we just have to make sure that our loop "
"terminates, because pointers have no size. Sooner or later it would probably "
"crash with an access violation or whatever, so it's better to break out of "
"the loop when we hit the NULL entry::"
msgstr ""
"``table`` が ``struct_frozen`` レコードの配列への ``pointer`` なので、その配"
"列に対して反復処理を行えます。しかし、ループが確実に終了するようにする必要が"
"あります。なぜなら、ポインタに大きさの情報がないからです。遅かれ早かれ、アク"
"セス違反か何かでクラッシュすることになるでしょう。 NULL エントリに達したとき"
"はループを抜ける方が良いです。::"

#: ../../library/ctypes.rst:1164
msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative size member) is not well known, it is only used "
"for testing. Try it out with ``import __hello__`` for example."
msgstr ""
"標準 Python はフローズンモジュールとフローズンパッケージ (負のサイズのメン"
"バーで表されています) を持っているという事実はあまり知られておらず、テストに"
"だけ使われています。例えば、 ``import __hello__`` を試してみてください。"

#: ../../library/ctypes.rst:1172
msgid "Surprises"
msgstr "びっくり仰天"

#: ../../library/ctypes.rst:1174
msgid ""
"There are some edge cases in :mod:`ctypes` where you might expect something "
"other than what actually happens."
msgstr ""
" :mod:`ctypes`  には、期待する動作と実際に起こる動作が異なるような奇妙な箇所"
"があります。"

#: ../../library/ctypes.rst:1177
msgid "Consider the following example::"
msgstr "次に示す例について考えてみてください。::"

#: ../../library/ctypes.rst:1197
msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line above::"
msgstr ""
"うーん、最後の文に ``3 4 1 2`` と表示されることを期待していたはずです。何が起"
"きたのでしょうか? 上の行の ``rc.a, rc.b = rc.b, rc.a`` の各段階はこのようにな"
"ります。::"

#: ../../library/ctypes.rst:1205
msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies the "
"buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, changes "
"the contents of ``temp1``. So, the last assignment ``rc.b = temp1``, doesn't "
"have the expected effect."
msgstr ""
"``temp0`` と ``temp1`` は前記の ``rc`` オブジェクトの内部バッファでまだ使われ"
"ているオブジェクトです。したがって、 ``rc.a = temp0`` を実行すると ``temp0`` "
"のバッファ内容が ``rc`` のバッファへコピーされます。さらに、これは ``temp1`` "
"の内容を変更します。そのため、最後の代入 ``rc.b = temp1`` は、期待する結果に"
"はならないのです。"

#: ../../library/ctypes.rst:1211
msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays "
"doesn't *copy* the sub-object, instead it retrieves a wrapper object "
"accessing the root-object's underlying buffer."
msgstr ""
"Structure 、 Union および Array のサブオブジェクトを取り出しても、そのサブオ"
"ブジェクトが *コピー* されるわけではなく、ルートオブジェクトの内部バッファに"
"アクセスするラッパーオブジェクトを取り出すことを覚えておいてください。"

#: ../../library/ctypes.rst:1215
msgid ""
"Another example that may behave different from what one would expect is "
"this::"
msgstr "期待とは違う振る舞いをする別の例はこれです。::"

#: ../../library/ctypes.rst:1225
msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of the "
"memory. Storing a Python object in the memory block does not store the "
"object itself, instead the ``contents`` of the object is stored.  Accessing "
"the contents again constructs a new Python object each time!"
msgstr ""
"なぜ ``False`` と表示されるのでしょうか? ctypes インスタンスはメモリと、メモ"
"リの内容にアクセスするいくつかの :term:`descriptor` (記述子)を含むオブジェク"
"トです。メモリブロックに Python オブジェクトを保存してもオブジェクト自身が保"
"存される訳ではなく、オブジェクトの ``contents`` が保存されます。その "
"contents に再アクセスすると新しい Python オブジェクトがその度に作られます。"

#: ../../library/ctypes.rst:1235
msgid "Variable-sized data types"
msgstr "可変サイズのデータ型"

#: ../../library/ctypes.rst:1237
msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and structures."
msgstr ":mod:`ctypes` は可変サイズの配列と構造体をサポートしています。"

#: ../../library/ctypes.rst:1239
msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an "
"existing ctypes object.  The function takes the object as first argument, "
"and the requested size in bytes as the second argument.  The memory block "
"cannot be made smaller than the natural memory block specified by the "
"objects type, a :exc:`ValueError` is raised if this is tried::"
msgstr ""
":func:`resize` 関数は既存の ctypes オブジェクトのメモリバッファのサイズを変更"
"したい場合に使えます。この関数は第一引数にオブジェクト、第二引数に要求された"
"サイズをバイト単位で指定します。メモリブロックはオブジェクト型で指定される通"
"常のメモリブロックより小さくすることはできません。これをやろうとすると、 :"
"exc:`ValueError` が送出されます。::"

#: ../../library/ctypes.rst:1259
msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 elements, "
"we get errors accessing other elements::"
msgstr ""
"これはこれで上手くいっていますが、この配列の追加した要素へどうやってアクセス"
"するのでしょうか? この型は要素の数が 4 個であるとまだ認識しているので、他の要"
"素にアクセスするとエラーになります。::"

#: ../../library/ctypes.rst:1271
msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use "
"the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ""
":mod:`ctypes` で可変サイズのデータ型を使うもう一つの方法は、必要なサイズが分"
"かった後に Python の動的性質を使って一つ一つデータ型を(再)定義することです。"

#: ../../library/ctypes.rst:1279
msgid "ctypes reference"
msgstr "ctypesリファレンス"

#: ../../library/ctypes.rst:1285
msgid "Finding shared libraries"
msgstr "共有ライブラリを見つける"

#: ../../library/ctypes.rst:1287
msgid ""
"When programming in a compiled language, shared libraries are accessed when "
"compiling/linking a program, and when the program is run."
msgstr ""
"コンパイルされる言語でプログラミングしている場合、共有ライブラリはプログラム"
"をコンパイル/リンクしているときと、そのプログラムが動作しているときにアクセス"
"されます。"

#: ../../library/ctypes.rst:1290
msgid ""
"The purpose of the :func:`find_library` function is to locate a library in a "
"way similar to what the compiler does (on platforms with several versions of "
"a shared library the most recent should be loaded), while the ctypes library "
"loaders act like when a program is run, and call the runtime loader directly."
msgstr ""
"ctypes ライブラリローダーはプログラムが動作しているときのように振る舞い、ラン"
"タイムローダーを直接呼び出すのに対し、 :func:`find_library` 関数の目的はコン"
"パイラが行うのと似た方法でライブラリを探し出すことです。 (複数のバージョンの"
"共有ライブラリがあるプラットフォームでは、一番最近に見つかったものがロードさ"
"れます)。"

#: ../../library/ctypes.rst:1295
msgid ""
"The :mod:`ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ""
":mod:`ctypes.util` モジュールはロードするライブラリを決めるのに役立つ関数を提"
"供します。"

#: ../../library/ctypes.rst:1303
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"ライブラリを見つけてパス名を返そうと試みます。 *name* は ``lib`` のような接頭"
"辞、 ``.so``, ``.dylib`` のような接尾辞、あるいは、バージョン番号が何も付いて"
"いないライブラリの名前です (これは posix リンカのオプション :option:`!-l` に"
"使われている形式です)。もしライブラリが見つからなければ、 ``None`` を返しま"
"す。"

#: ../../library/ctypes.rst:1308 ../../library/ctypes.rst:1903
msgid "The exact functionality is system dependent."
msgstr "厳密な機能はシステムに依存します。"

#: ../../library/ctypes.rst:1310
msgid ""
"On Linux, :func:`find_library` tries to run external programs (``/sbin/"
"ldconfig``, ``gcc``, and ``objdump``) to find the library file.  It returns "
"the filename of the library file.  Here are some examples::"
msgstr ""
"Linux では、 :func:`find_library` はライブラリファイルを見つけるために外部プ"
"ログラム (``/sbin/ldconfig``, ``gcc`` および ``objdump``) を実行しようとしま"
"す。ライブラリファイルのファイル名を返します。いくつか例があります。::"

#: ../../library/ctypes.rst:1323
msgid ""
"On OS X, :func:`find_library` tries several predefined naming schemes and "
"paths to locate the library, and returns a full pathname if successful::"
msgstr ""
"OS X では、 :func:`find_library` はライブラリの位置を探すために、予め定義され"
"た複数の命名方法とパスを試し、成功すればフルパスを返します。::"

#: ../../library/ctypes.rst:1337
msgid ""
"On Windows, :func:`find_library` searches along the system search path, and "
"returns the full pathname, but since there is no predefined naming scheme a "
"call like ``find_library(\"c\")`` will fail and return ``None``."
msgstr ""
"Windows では、 :func:`find_library` はシステムの探索パスに沿って探し、フルパ"
"スを返します。しかし、予め定義された命名方法がないため、 "
"``find_library(\"c\")`` のような呼び出しは失敗し、 ``None`` を返します。"

#: ../../library/ctypes.rst:1341
msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development time, and hardcode that "
"into the wrapper module instead of using :func:`find_library` to locate the "
"library at runtime."
msgstr ""
":mod:`ctypes` で共有ライブラリをラップする場合、 :func:`find_library` を使っ"
"て実行時にライブラリの場所を特定するのではなく、共有ライブラリの名前を開発時"
"に決めておいて、ラッパーモジュールにハードコードする方が良い *かもしれません"
"* 。"

#: ../../library/ctypes.rst:1349
msgid "Loading shared libraries"
msgstr "共有ライブラリをロードする"

#: ../../library/ctypes.rst:1351
msgid ""
"There are several ways to load shared libraries into the Python process.  "
"One way is to instantiate one of the following classes:"
msgstr ""
"共有ライブラリを Python プロセスへロードする方法はいくつかあります。一つの方"
"法は下記のクラスの一つをインスタンス化することです:"

#: ../../library/ctypes.rst:1357
msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to "
"return :c:type:`int`."
msgstr ""
"このクラスのインスタンスはロードされた共有ライブラリをあらわします。これらの"
"ライブラリの関数は標準 C 呼び出し規約を使用し、 :c:type:`int` を返すと仮定さ"
"れます。"

#: ../../library/ctypes.rst:1364
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return the windows specific :class:`HRESULT` code.  :class:"
"`HRESULT` values contain information specifying whether the function call "
"failed or succeeded, together with additional error code.  If the return "
"value signals a failure, an :class:`WindowsError` is automatically raised."
msgstr ""
"Windows 用: このクラスのインスタンスはロードされた共有ライブラリをあらわしま"
"す。これらのライブラリの関数は ``stdcall`` 呼び出し規約を使用し、 windows 固"
"有の :class:`HRESULT` コードを返すと仮定されます。 :class:`HRESULT` 値には関"
"数呼び出しが失敗したのか成功したのかを特定する情報とともに、補足のエラーコー"
"ドが含まれます。戻り値が失敗を知らせたならば、 :class:`WindowsError` が自動的"
"に送出されます。"

#: ../../library/ctypes.rst:1374
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return :c:type:`int` by default."
msgstr ""
"Windows 用: このクラスのインスタンスはロードされた共有ライブラリをあらわしま"
"す。これらのライブラリの関数は ``stdcall`` 呼び出し規約を使用し、デフォルトで"
"は :c:type:`int` を返すと仮定されます。"

#: ../../library/ctypes.rst:1378
msgid ""
"On Windows CE only the standard calling convention is used, for convenience "
"the :class:`WinDLL` and :class:`OleDLL` use the standard calling convention "
"on this platform."
msgstr ""
"Windows CE では標準呼び出し規約だけが使われます。便宜上、このプラットフォーム"
"では、 :class:`WinDLL` と :class:`OleDLL` が標準呼び出し規約を使用します。"

#: ../../library/ctypes.rst:1382
msgid ""
"The Python :term:`global interpreter lock` is released before calling any "
"function exported by these libraries, and reacquired afterwards."
msgstr ""
"これらのライブラリがエクスポートするどの関数でも呼び出す前に Python GIL (:"
"term:`global interpreter lock`) は解放され、後でまた獲得されます。"

#: ../../library/ctypes.rst:1388
msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that the "
"Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is "
"set, a Python exception is raised."
msgstr ""
"Python GIL が関数呼び出しの間解放 *されず* 、関数実行の後に Python エラーフラ"
"グがチェックされるということを除けば、このクラスのインスタンスは :class:"
"`CDLL` インスタンスのように振る舞います。エラーフラグがセットされた場合、 "
"Python 例外が送出されます。"

#: ../../library/ctypes.rst:1393
msgid "Thus, this is only useful to call Python C api functions directly."
msgstr ""
"要するに、これは Python C api 関数を直接呼び出すのに便利だというだけです。"

#: ../../library/ctypes.rst:1395
msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platforms ``dlopen`` or "
"``LoadLibrary`` function is used to load the library into the process, and "
"to get a handle to it."
msgstr ""
"これらすべてのクラスは少なくとも一つの引数、すなわちロードする共有ライブラリ"
"のパスを渡して呼び出すことでインスタンス化されます。すでにロード済みの共有ラ"
"イブラリへのハンドルがあるなら、 ``handle`` 名前付き引数として渡すことができ"
"ます。土台となっているプラットフォームの ``dlopen`` または ``LoadLibrary`` 関"
"数がプロセスへライブラリをロードするために使われ、そのライブラリに対するハン"
"ドルを得ます。"

#: ../../library/ctypes.rst:1402
msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  For "
"details, consult the :manpage:`dlopen(3)` manpage.  On Windows, *mode* is "
"ignored.  On posix systems, RTLD_NOW is always added, and is not "
"configurable."
msgstr ""
"*mode* パラメータを使うと、ライブラリがどうやってロードされたかを特定できま"
"す。\n"
"詳細は :manpage:`dlopen(3)` マニュアルページを参考にしてください。\n"
"Windows では *mode* は無視されます。\n"
"POSIX システムでは RTLD_NOW が常に追加され、設定変更はできません。"

#: ../../library/ctypes.rst:1407
msgid ""
"The *use_errno* parameter, when set to true, enables a ctypes mechanism that "
"allows accessing the system :data:`errno` error number in a safe way. :mod:"
"`ctypes` maintains a thread-local copy of the systems :data:`errno` "
"variable; if you call foreign functions created with ``use_errno=True`` then "
"the :data:`errno` value before the function call is swapped with the ctypes "
"private copy, the same happens immediately after the function call."
msgstr ""
"*use_errno* 変数が真に設定されたとき、システムの :data:`errno` エラーナンバー"
"に安全にアクセスする ctypes の仕組みが有効化されます。 :mod:`ctypes` はシステ"
"ムの :data:`errno` 変数のスレッド限定のコピーを管理します。もし、 "
"``use_errno=True`` の状態で作られた外部関数を呼び出したなら、関数呼び出し前"
"の :data:`errno` 変数は ctypes のプライベートコピーと置き換えられ、同じことが"
"関数呼び出しの直後にも発生します。"

#: ../../library/ctypes.rst:1414
msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the ctypes "
"private copy to a new value and returns the former value."
msgstr ""
":func:`ctypes.get_errno` 関数は ctypes のプライベートコピーの値を返します。そ"
"して、 :func:`ctypes.set_errno` 関数は ctypes のプライベートコピーを置き換"
"え、以前の値を返します。"

#: ../../library/ctypes.rst:1418
msgid ""
"The *use_last_error* parameter, when set to true, enables the same mechanism "
"for the Windows error code which is managed by the :func:`GetLastError` and :"
"func:`SetLastError` Windows API functions; :func:`ctypes.get_last_error` "
"and :func:`ctypes.set_last_error` are used to request and change the ctypes "
"private copy of the windows error code."
msgstr ""
"*use_last_error* パラメータは、真に設定されたとき、 :func:`GetLastError` と :"
"func:`SetLastError` Windows API によって管理される Windows エラーコードに対す"
"るのと同じ仕組みが有効化されます。 :func:`ctypes.get_last_error` と :func:"
"`ctypes.set_last_error` は Windows エラーコードの ctypes プライベートコピーを"
"変更したり要求したりするのに使われます。"

#: ../../library/ctypes.rst:1424
msgid "The *use_last_error* and *use_errno* optional parameters were added."
msgstr "*use_last_error* と *use_errno* オプション変数が追加されました。"

#: ../../library/ctypes.rst:1430
msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr ""
"*mode* パラメータとして使うフラグ。このフラグが利用できないプラットフォームで"
"は、整数のゼロと定義されています。"

#: ../../library/ctypes.rst:1437
msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not available, "
"it is the same as *RTLD_GLOBAL*."
msgstr ""
"*mode* パラメータとして使うフラグ。これが利用できないプラットフォームでは、 "
"*RTLD_GLOBAL* と同様です。"

#: ../../library/ctypes.rst:1444
msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, this "
"is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr ""
"共有ライブラリをロードするために使われるデフォルトモード。 OSX 10.3 では "
"*RTLD_GLOBAL* であり、そうでなければ *RTLD_LOCAL* と同じです。"

#: ../../library/ctypes.rst:1447
msgid ""
"Instances of these classes have no public methods.  Functions exported by "
"the shared library can be accessed as attributes or by index.  Please note "
"that accessing the function through an attribute caches the result and "
"therefore accessing it repeatedly returns the same object each time.  On the "
"other hand, accessing it through an index returns a new object each time:"
msgstr ""
"これらのクラスのインスタンスには公開メソッドはありません。共有ライブラリから"
"エクスポートされた関数は、属性として、もしくは添字でアクセスできます。属性を"
"通した関数へのアクセスは結果がキャッシュされ、従って繰り返しアクセスされると"
"毎回同じオブジェクトを返すことに注意してください。それとは反対に、添字を通し"
"たアクセスは毎回新しいオブジェクトを返します:"

#: ../../library/ctypes.rst:1458
msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr ""
"次に述べる公開属性が利用できます。それらの名前はエクスポートされた関数名に衝"
"突しないように下線で始まります。:"

#: ../../library/ctypes.rst:1464
msgid "The system handle used to access the library."
msgstr "ライブラリへのアクセスに用いられるシステムハンドル。"

#: ../../library/ctypes.rst:1469
msgid "The name of the library passed in the constructor."
msgstr "コンストラクタに渡されたライブラリの名前。"

#: ../../library/ctypes.rst:1471
msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either by "
"calling the :meth:`LoadLibrary` method, or by retrieving the library as "
"attribute of the loader instance."
msgstr ""
"共有ライブラリは (:class:`LibraryLoader` クラスのインスタンスである) 前もって"
"作られたオブジェクトの一つを使うことによってロードすることもできます。それら"
"の :meth:`LoadLibrary` メソッドを呼び出すか、ローダーインスタンスの属性として"
"ライブラリを取り出すかのどちらかによりロードします。"

#: ../../library/ctypes.rst:1479
msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the :class:"
"`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr ""
"共有ライブラリをロードするクラス。 *dlltype* は :class:`CDLL` 、 :class:"
"`PyDLL` 、 :class:`WinDLL` もしくは :class:`OleDLL` 型の一つであるべきです。"

#: ../../library/ctypes.rst:1482
msgid ""
":meth:`__getattr__` has special behavior: It allows loading a shared library "
"by accessing it as attribute of a library loader instance.  The result is "
"cached, so repeated attribute accesses return the same library each time."
msgstr ""
":meth:`__getattr__` は次のような特別なはたらきをします。ライブラリローダーイ"
"ンスタンスの属性として共有ライブラリにアクセスするとそれがロードされるという"
"ことを可能にします。結果はキャッシュされます。そのため、繰り返し属性アクセス"
"を行うといつも同じライブラリが返されます。"

#: ../../library/ctypes.rst:1489
msgid ""
"Load a shared library into the process and return it.  This method always "
"returns a new instance of the library."
msgstr ""
"共有ライブラリをプロセスへロードし、それを返します。このメソッドはライブラリ"
"の新しいインスタンスを常に返します。"

#: ../../library/ctypes.rst:1492
msgid "These prefabricated library loaders are available:"
msgstr "これらの前もって作られたライブラリローダーを利用することができます。:"

#: ../../library/ctypes.rst:1498
msgid "Creates :class:`CDLL` instances."
msgstr ":class:`CDLL` インスタンスを作ります。"

#: ../../library/ctypes.rst:1504
msgid "Windows only: Creates :class:`WinDLL` instances."
msgstr "Windows 用: :class:`WinDLL` インスタンスを作ります。"

#: ../../library/ctypes.rst:1510
msgid "Windows only: Creates :class:`OleDLL` instances."
msgstr "Windows 用: :class:`OleDLL` インスタンスを作ります。"

#: ../../library/ctypes.rst:1516
msgid "Creates :class:`PyDLL` instances."
msgstr ":class:`PyDLL` インスタンスを作ります。"

#: ../../library/ctypes.rst:1518
msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr ""
"C Python api に直接アクセするために、すぐに使用できる Python 共有ライブラリオ"
"ブジェクトが用意されています。:"

#: ../../library/ctypes.rst:1525
msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C :c:type:"
"`int`, which is of course not always the truth, so you have to assign the "
"correct :attr:`restype` attribute to use these functions."
msgstr ""
"属性として Python C api 関数を公開する :class:`PyDLL` のインスタンス。これら"
"すべての関数は C :c:type:`int` を返すと仮定されますが、もちろん常に正しいとは"
"限りません。そのため、これらの関数を使うためには正しい :attr:`restype` 属性を"
"代入しなければなりません。"

#: ../../library/ctypes.rst:1534
msgid "Foreign functions"
msgstr "外部関数"

#: ../../library/ctypes.rst:1536
msgid ""
"As explained in the previous section, foreign functions can be accessed as "
"attributes of loaded shared libraries.  The function objects created in this "
"way by default accept any number of arguments, accept any ctypes data "
"instances as arguments, and return the default result type specified by the "
"library loader. They are instances of a private class:"
msgstr ""
"前節で説明した通り、外部関数はロードされた共有ライブラリの属性としてアクセス"
"できます。デフォルトではこの方法で作成された関数オブジェクトはどんな数の引数"
"でも受け取り、引数としてどんな ctypes データのインスタンスをも受け取り、そし"
"て、ライブラリローダーが指定したデフォルトの結果の値の型を返します。関数オブ"
"ジェクトはプライベートクラスのインスタンスです。:"

#: ../../library/ctypes.rst:1545
msgid "Base class for C callable foreign functions."
msgstr "C の呼び出し可能外部関数のためのベースクラス。"

#: ../../library/ctypes.rst:1547
msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr ""
"外部関数のインスタンスも C 互換データ型です。それらは C の関数ポインタを表し"
"ています。"

#: ../../library/ctypes.rst:1550
msgid ""
"This behavior can be customized by assigning to special attributes of the "
"foreign function object."
msgstr ""
"この振る舞いは外部関数オブジェクトの特別な属性に代入することによって、カスタ"
"マイズすることができます。"

#: ../../library/ctypes.rst:1556
msgid ""
"Assign a ctypes type to specify the result type of the foreign function. Use "
"``None`` for :c:type:`void`, a function not returning anything."
msgstr ""
"外部関数の結果の型を指定するために ctypes 型を代入する。何も返さない関数を表"
"す :c:type:`void` に対しては ``None`` を使います。"

#: ../../library/ctypes.rst:1559
msgid ""
"It is possible to assign a callable Python object that is not a ctypes type, "
"in this case the function is assumed to return a C :c:type:`int`, and the "
"callable will be called with this integer, allowing further processing or "
"error checking.  Using this is deprecated, for more flexible post processing "
"or error checking use a ctypes data type as :attr:`restype` and assign a "
"callable to the :attr:`errcheck` attribute."
msgstr ""
"ctypes 型ではない呼び出し可能な Python オブジェクトを代入することは可能です。"
"このような場合、関数が C :c:type:`int` を返すと仮定され、呼び出し可能オブジェ"
"クトはこの整数を引数に呼び出されます。さらに処理を行ったり、エラーチェックを"
"したりできるようにするためです。これの使用は推奨されません。より柔軟な後処理"
"やエラーチェックのためには :attr:`restype` として ctypes 型を使い、 :attr:"
"`errcheck` 属性へ呼び出し可能オブジェクトを代入してください。"

#: ../../library/ctypes.rst:1569
msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can "
"only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr ""
"関数が受け取る引数の型を指定するために ctypes 型のタプルを代入します。 "
"``stdcall`` 呼び出し規約をつかう関数はこのタプルの長さと同じ数の引数で呼び出"
"されます。その上、 C 呼び出し規約をつかう関数は追加の不特定の引数も取ります。"

#: ../../library/ctypes.rst:1575
msgid ""
"When a foreign function is called, each actual argument is passed to the :"
"meth:`from_param` class method of the items in the :attr:`argtypes` tuple, "
"this method allows adapting the actual argument to an object that the "
"foreign function accepts.  For example, a :class:`c_char_p` item in the :"
"attr:`argtypes` tuple will convert a unicode string passed as argument into "
"a byte string using ctypes conversion rules."
msgstr ""
"外部関数が呼ばれたとき、それぞれの実引数は :attr:`argtypes` タプルの要素の :"
"meth:`from_param` クラスメソッドへ渡されます。このメソッドは実引数を外部関数"
"が受け取るオブジェクトに合わせて変えられるようにします。例えば、 :attr:"
"`argtypes` タプルの :class:`c_char_p` 要素は、 ctypes 変換規則にしたがって引"
"数として渡された Unicode 文字列をバイト文字列へ変換します。"

#: ../../library/ctypes.rst:1582
msgid ""
"New: It is now possible to put items in argtypes which are not ctypes types, "
"but each item must have a :meth:`from_param` method which returns a value "
"usable as argument (integer, string, ctypes instance).  This allows defining "
"adapters that can adapt custom objects as function parameters."
msgstr ""
"新: ctypes 型でない要素を argtypes に入れることができますが、個々の要素は引数"
"として使える値 (整数、文字列、 ctypes インスタンス) を返す :meth:"
"`from_param` メソッドを持っていなければなりません。これにより関数パラメータと"
"してカスタムオブジェクトを適合するように変更できるアダプタが定義可能となりま"
"す。"

#: ../../library/ctypes.rst:1590
msgid ""
"Assign a Python function or another callable to this attribute. The callable "
"will be called with three or more arguments:"
msgstr ""
"Python 関数または他の呼び出し可能オブジェクトをこの属性に代入します。呼び出し"
"可能オブジェクトは三つ以上の引数とともに呼び出されます。"

#: ../../library/ctypes.rst:1596
msgid ""
"*result* is what the foreign function returns, as specified by the :attr:"
"`restype` attribute."
msgstr "*result* は外部関数が返すもので、 :attr:`restype` 属性で指定されます。"

#: ../../library/ctypes.rst:1599
msgid ""
"*func* is the foreign function object itself, this allows reusing the same "
"callable object to check or post process the results of several functions."
msgstr ""
"*func* は外部関数オブジェクト自身で、これにより複数の関数の処理結果をチェック"
"または後処理するために、同じ呼び出し可能オブジェクトを再利用できるようになり"
"ます。"

#: ../../library/ctypes.rst:1603
msgid ""
"*arguments* is a tuple containing the parameters originally passed to the "
"function call, this allows specializing the behavior on the arguments used."
msgstr ""
"*arguments* は関数呼び出しに最初に渡されたパラメータが入ったタプルです。これ"
"により使われた引数に基づいた特別な振る舞いをさせることができるようになりま"
"す。"

#: ../../library/ctypes.rst:1607
msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an exception "
"if the foreign function call failed."
msgstr ""
"この関数が返すオブジェクトは外部関数呼び出しから返された値でしょう。しかし、"
"戻り値をチェックして、外部関数呼び出しが失敗しているなら例外を送出させること"
"もできます。"

#: ../../library/ctypes.rst:1614
msgid ""
"This exception is raised when a foreign function call cannot convert one of "
"the passed arguments."
msgstr ""
"この例外は外部関数呼び出しが渡された引数を変換できなかったときに送出されま"
"す。"

#: ../../library/ctypes.rst:1621
msgid "Function prototypes"
msgstr "関数プロトタイプ"

#: ../../library/ctypes.rst:1623
msgid ""
"Foreign functions can also be created by instantiating function prototypes. "
"Function prototypes are similar to function prototypes in C; they describe a "
"function (return type, argument types, calling convention) without defining "
"an implementation.  The factory functions must be called with the desired "
"result type and the argument types of the function."
msgstr ""
"外部関数は関数プロトタイプをインスタンス化することによって作成されます。関数"
"プロトタイプは C の関数プロトタイプと似ています。実装を定義せずに、関数 (戻り"
"値、引数の型、呼び出し規約) を記述します。ファクトリ関数は関数に要求する戻り"
"値の型と引数の型とともに呼び出されます。"

#: ../../library/ctypes.rst:1632
msgid ""
"The returned function prototype creates functions that use the standard C "
"calling convention.  The function will release the GIL during the call.  If "
"*use_errno* is set to true, the ctypes private copy of the system :data:"
"`errno` variable is exchanged with the real :data:`errno` value before and "
"after the call; *use_last_error* does the same for the Windows error code."
msgstr ""
"返された関数プロトタイプは標準 C 呼び出し規約をつかう関数を作成します。関数は"
"呼び出されている間 GIL を解放します。 *use_errno* が真に設定されれば、呼び出"
"しの前後で System 変数 :data:`errno` の ctypesプライベートコピーは本当の :"
"data:`errno` の値と交換されます。 *use_last_error* も Windows エラーコードに"
"対するのと同様です。"

#: ../../library/ctypes.rst:1639
msgid "The optional *use_errno* and *use_last_error* parameters were added."
msgstr "オプションの *use_errno* と *use_last_error* 変数が追加されました。"

#: ../../library/ctypes.rst:1645
msgid ""
"Windows only: The returned function prototype creates functions that use the "
"``stdcall`` calling convention, except on Windows CE where :func:"
"`WINFUNCTYPE` is the same as :func:`CFUNCTYPE`.  The function will release "
"the GIL during the call.  *use_errno* and *use_last_error* have the same "
"meaning as above."
msgstr ""
"Windows 用: 返された関数プロトタイプは ``stdcall`` 呼び出し規約をつかう関数を"
"作成します。ただし、 :func:`WINFUNCTYPE` が :func:`CFUNCTYPE` と同じである "
"Windows CE を除きます。関数は呼び出されている間 GIL を解放します。 "
"*use_errno* と *use_last_error* は前述と同じ意味を持ちます。"

#: ../../library/ctypes.rst:1654
msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the call."
msgstr ""
"返された関数プロトタイプは Python 呼び出し規約をつかう関数を作成します。関数"
"は呼び出されている間 GIL を解放 *しません* 。"

#: ../../library/ctypes.rst:1657
msgid ""
"Function prototypes created by these factory functions can be instantiated "
"in different ways, depending on the type and number of the parameters in the "
"call:"
msgstr ""
"ファクトリ関数によって作られた関数プロトタイプは呼び出しのパラメータの型と数"
"に依存した別の方法でインスタンス化することができます。 :"

#: ../../library/ctypes.rst:1665
msgid ""
"Returns a foreign function at the specified address which must be an integer."
msgstr "指定されたアドレス(整数でなくてはなりません)の外部関数を返します。"

#: ../../library/ctypes.rst:1672
msgid ""
"Create a C callable function (a callback function) from a Python *callable*."
msgstr ""
"Python の *callable* から C の呼び出し可能関数(コールバック関数) を作成しま"
"す。"

#: ../../library/ctypes.rst:1679
msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must be "
"a 2-tuple ``(name_or_ordinal, library)``. The first item is the name of the "
"exported function as string, or the ordinal of the exported function as "
"small integer.  The second item is the shared library instance."
msgstr ""
"共有ライブラリがエクスポートしている外部関数を返します。 *func_spec* は 2 要"
"素タプル ``(name_or_ordinal, library)`` でなければなりません。第一要素はエク"
"スポートされた関数の名前である文字列、またはエクスポートされた関数の序数であ"
"る小さい整数です。第二要素は共有ライブラリインスタンスです。"

#: ../../library/ctypes.rst:1689
msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is the "
"index into the virtual function table, a small non-negative integer. *name* "
"is name of the COM method. *iid* is an optional pointer to the interface "
"identifier which is used in extended error reporting."
msgstr ""
"COM メソッドを呼び出す外部関数を返します。 *vtbl_index* は仮想関数テーブルの"
"インデックスで、非負の小さい整数です。 *name* は COM メソッドの名前です。 "
"*iid* はオプションのインターフェイス識別子へのポインタで、拡張されたエラー情"
"報の提供のために使われます。"

#: ../../library/ctypes.rst:1694
msgid ""
"COM methods use a special calling convention: They require a pointer to the "
"COM interface as first argument, in addition to those parameters that are "
"specified in the :attr:`argtypes` tuple."
msgstr ""
"COM メソッドは特殊な呼び出し規約を用います。このメソッドは :attr:`argtypes` "
"タプルに指定されたパラメータに加えて、第一引数として COM インターフェイスへの"
"ポインタを必要とします。"

#: ../../library/ctypes.rst:1698
msgid ""
"The optional *paramflags* parameter creates foreign function wrappers with "
"much more functionality than the features described above."
msgstr ""
"オプションの *paramflags* パラメータは上述した機能より多機能な外部関数ラッ"
"パーを作成します。"

#: ../../library/ctypes.rst:1701
msgid "*paramflags* must be a tuple of the same length as :attr:`argtypes`."
msgstr ""
"*paramflags* は :attr:`argtypes` と同じ長さのタプルでなければなりません。"

#: ../../library/ctypes.rst:1703
msgid ""
"Each item in this tuple contains further information about a parameter, it "
"must be a tuple containing one, two, or three items."
msgstr ""
"このタプルの個々の要素はパラメータについてのより詳細な情報を持ち、 1 、 2 も"
"しくは 3 要素を含むタプルでなければなりません。"

#: ../../library/ctypes.rst:1706
msgid ""
"The first item is an integer containing a combination of direction flags for "
"the parameter:"
msgstr "第一要素はパラメータについてのフラグの組み合わせを含んだ整数です。"

#: ../../library/ctypes.rst:1710
msgid "1"
msgstr "1"

#: ../../library/ctypes.rst:1710
msgid "Specifies an input parameter to the function."
msgstr "入力パラメータを関数に指定します。"

#: ../../library/ctypes.rst:1713
msgid "2"
msgstr "2"

#: ../../library/ctypes.rst:1713
msgid "Output parameter.  The foreign function fills in a value."
msgstr "出力パラメータ。外部関数が値を書き込みます。"

#: ../../library/ctypes.rst:1716
msgid "4"
msgstr "4"

#: ../../library/ctypes.rst:1716
msgid "Input parameter which defaults to the integer zero."
msgstr "デフォルトで整数ゼロになる入力パラメータ。"

#: ../../library/ctypes.rst:1718
msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr ""
"オプションの第二要素はパラメータ名の文字列です。これが指定された場合は、外部"
"関数を名前付きパラメータで呼び出すことができます。"

#: ../../library/ctypes.rst:1721
msgid "The optional third item is the default value for this parameter."
msgstr "オプションの第三要素はこのパラメータのデフォルト値です。"

#: ../../library/ctypes.rst:1723
msgid ""
"This example demonstrates how to wrap the Windows ``MessageBoxA`` function "
"so that it supports default parameters and named arguments. The C "
"declaration from the windows header file is this::"
msgstr ""
"この例では、デフォルトパラメータと名前付き引数をサポートするために Windows "
"``MessageBoxA`` 関数をラップする方法を示します。 windowsヘッダファイルの C の"
"宣言はこれです。::"

#: ../../library/ctypes.rst:1734 ../../library/ctypes.rst:1759
msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr ":mod:`ctypes` を使ってラップします。::"

#: ../../library/ctypes.rst:1743
msgid "The MessageBox foreign function can now be called in these ways::"
msgstr "今は MessageBox 外部関数をこのような方法で呼び出すことができます。::"

#: ../../library/ctypes.rst:1750
msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window by "
"copying them into ``RECT`` structure that the caller has to supply.  Here is "
"the C declaration::"
msgstr ""
"二番目の例は出力パラメータについて説明します。 win32 の ``GetWindowRect`` 関"
"数は、指定されたウィンドウの大きさを呼び出し側が与える ``RECT`` 構造体へコ"
"ピーすることで取り出します。 C の宣言はこうです。::"

#: ../../library/ctypes.rst:1768
msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the output "
"parameter values when there are more than one, so the GetWindowRect function "
"now returns a RECT instance, when called."
msgstr ""
"もし単一の値もしくは一つより多い場合には出力パラメータ値が入ったタプルがある"
"ならば、出力パラメータを持つ関数は自動的に出力パラメータ値を返すでしょう。そ"
"のため、今は GetWindowRect 関数は呼び出されたときに RECT インスタンスを返しま"
"す。"

#: ../../library/ctypes.rst:1773
msgid ""
"Output parameters can be combined with the :attr:`errcheck` protocol to do "
"further output processing and error checking.  The win32 ``GetWindowRect`` "
"api function returns a ``BOOL`` to signal success or failure, so this "
"function could do the error checking, and raises an exception when the api "
"call failed::"
msgstr ""
"さらに出力処理やエラーチェックを行うために、出力パラメータを :attr:"
"`errcheck` プロトコルと組み合わせることができます。 win32 ``GetWindowRect`` "
"api 関数は成功したか失敗したかを知らせるために ``BOOL`` を返します。そのた"
"め、この関数はエラーチェックを行って、 api 呼び出しが失敗した場合に例外を送出"
"させることができます。::"

#: ../../library/ctypes.rst:1786
msgid ""
"If the :attr:`errcheck` function returns the argument tuple it receives "
"unchanged, :mod:`ctypes` continues the normal processing it does on the "
"output parameters.  If you want to return a tuple of window coordinates "
"instead of a ``RECT`` instance, you can retrieve the fields in the function "
"and return them instead, the normal processing will no longer take place::"
msgstr ""
":attr:`errcheck` 関数が変更なしに受け取った引数タプルを返したならば、 :mod:"
"`ctypes` は出力パラメータに対して通常の処理を続けます。 ``RECT`` インスタンス"
"の代わりに window 座標のタプルを返してほしいなら、関数のフィールドを取り出"
"し、代わりにそれらを返すことができます。通常処理はもはや行われないでしょ"
"う。::"

#: ../../library/ctypes.rst:1805
msgid "Utility functions"
msgstr "ユーティリティ関数"

#: ../../library/ctypes.rst:1810
msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr ""
"メモリバッファのアドレスを示す整数を返します。 *obj* は ctypes 型のインスタン"
"スでなければなりません。"

#: ../../library/ctypes.rst:1816
msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must be a "
"ctypes type or instance."
msgstr ""
"ctypes 型のアライメントの必要条件を返します。 *obj_or_type* は ctypes 型また"
"はインスタンスでなければなりません。"

#: ../../library/ctypes.rst:1822
msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will be "
"added to the internal pointer value."
msgstr ""
"*obj* (ctypes 型のインスタンスでなければならない) への軽量ポインタを返しま"
"す。 *offset* はデフォルトでは 0 で、内部ポインターへ加算される整数です。"

#: ../../library/ctypes.rst:1826
msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr ""
"``byref(obj, offset)`` は、 C コードとしては、以下のようにみなされます。::"

#: ../../library/ctypes.rst:1830
msgid ""
"The returned object can only be used as a foreign function call parameter.  "
"It behaves similar to ``pointer(obj)``, but the construction is a lot faster."
msgstr ""
"返されるオブジェクトは外部関数呼び出しのパラメータとしてのみ使用できます。 "
"``pointer(obj)`` と似たふるまいをしますが、作成が非常に速く行えます。"

#: ../../library/ctypes.rst:1834
msgid "The *offset* optional argument was added."
msgstr "*offset* オプション引数が追加されました。"

#: ../../library/ctypes.rst:1840
msgid ""
"This function is similar to the cast operator in C.  It returns a new "
"instance of *type* which points to the same memory block as *obj*.  *type* "
"must be a pointer type, and *obj* must be an object that can be interpreted "
"as a pointer."
msgstr ""
"この関数は C のキャスト演算子に似ています。 *obj* と同じメモリブロックを指し"
"ている *type* の新しいインスタンスを返します。 *type* はポインタ型でなければ"
"ならず、 *obj* はポインタとして解釈できるオブジェクトでなければなりません。"

#: ../../library/ctypes.rst:1848
msgid ""
"This function creates a mutable character buffer. The returned object is a "
"ctypes array of :class:`c_char`."
msgstr ""
"この関数は変更可能な文字バッファを作成します。返されるオブジェクトは :class:"
"`c_char` の ctypes 配列です。"

#: ../../library/ctypes.rst:1851
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a string which will be used to initialize the array items."
msgstr ""
"*init_or_size* は配列のサイズを指定する整数もしくは配列要素を初期化するために"
"使われる文字列である必要があります。"

#: ../../library/ctypes.rst:1854
msgid ""
"If a string is specified as first argument, the buffer is made one item "
"larger than the length of the string so that the last element in the array "
"is a NUL termination character. An integer can be passed as second argument "
"which allows specifying the size of the array if the length of the string "
"should not be used."
msgstr ""
"第一引数として文字列が指定された場合は、バッファが文字列の長さより一要素分大"
"きく作られます。配列の最後の要素が NUL 終端文字であるためです。文字列の長さを"
"使うべきでない場合は、配列のサイズを指定するために整数を第二引数として渡すこ"
"とができます。"

#: ../../library/ctypes.rst:1859
msgid ""
"If the first parameter is a unicode string, it is converted into an 8-bit "
"string according to ctypes conversion rules."
msgstr ""
"第一引数が Unicode 文字列ならば、 ctypes 変換規則にしたがい 8 ビット文字列へ"
"変換されます。"

#: ../../library/ctypes.rst:1865
msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr ""
"この関数は変更可能な Unicode 文字バッファを作成します。返されるオブジェクト"
"は :class:`c_wchar` の ctypes 配列です。"

#: ../../library/ctypes.rst:1868
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a unicode string which will be used to initialize the array items."
msgstr ""
"*init_or_size* は配列のサイズを指定する整数もしくは配列要素を初期化するために"
"使われる Unicode 文字列です。"

#: ../../library/ctypes.rst:1871
msgid ""
"If a unicode string is specified as first argument, the buffer is made one "
"item larger than the length of the string so that the last element in the "
"array is a NUL termination character. An integer can be passed as second "
"argument which allows specifying the size of the array if the length of the "
"string should not be used."
msgstr ""
"第一引数として Unicode 文字列が指定された場合は、バッファが文字列の長さより一"
"要素分大きく作られます。それは配列の最後の要素が NUL 終端文字であるためです。"
"文字列の長さを使うべきでない場合は、配列のサイズを指定するために整数を第二引"
"数として渡すことができます。"

#: ../../library/ctypes.rst:1877
msgid ""
"If the first parameter is an 8-bit string, it is converted into a unicode "
"string according to ctypes conversion rules."
msgstr ""
"第一引数が 8 ビット文字列ならば、 ctypes 変換規則にしたがい Unicode 文字列へ"
"変換されます。"

#: ../../library/ctypes.rst:1883
msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllCanUnloadNow function "
"that the _ctypes extension dll exports."
msgstr ""
"Windows 用: この関数は ctypes をつかってインプロセス COM サーバーを実装できる"
"ようにするためのフックです。_ctypes 拡張 dll がエクスポートしている "
"DllCanUnloadNow 関数から呼び出されます。"

#: ../../library/ctypes.rst:1890
msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllGetClassObject function "
"that the ``_ctypes`` extension dll exports."
msgstr ""
"Windows 用: この関数は ctypes をつかってインプロセス COM サーバーを実装できる"
"ようにするためのフックです。``_ctypes`` 拡張 dll がエクスポートしている "
"DllGetClassObject 関数から呼び出されます。"

#: ../../library/ctypes.rst:1898
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"ライブラリを検索し、パス名を返します。 *name* は ``lib`` のような接頭辞、 ``."
"so`` や ``.dylib`` のような接尾辞、そして、バージョンナンバーを除くライブラリ"
"名です (これは posix のリンカーオプション :option:`!-l` で使われる書式で"
"す) 。もしライブラリが見つからなければ、 ``None`` を返します。"

#: ../../library/ctypes.rst:1905
msgid ""
"Windows only: ``find_library(\"m\")`` or ``find_library(\"c\")`` return the "
"result of a call to ``find_msvcrt()``."
msgstr ""
"Windows 用: ``find_library(\"m\")`` もしくは ``find_library(\"c\")`` は "
"``find_msvcrt()`` の呼び出し結果を返します。"

#: ../../library/ctypes.rst:1913
msgid ""
"Windows only: return the filename of the VC runtime library used by Python, "
"and by the extension modules.  If the name of the library cannot be "
"determined, ``None`` is returned."
msgstr ""
"Windows 用: Python と拡張モジュールで使われる VC ランタイムライブラリのファイ"
"ル名を返します。もしライブラリ名が同定できなければ、 ``None`` を返します。"

#: ../../library/ctypes.rst:1917
msgid ""
"If you need to free memory, for example, allocated by an extension module "
"with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr ""
"もし、例えば拡張モジュールにより割り付けられたメモリを ``free(void *)`` で解"
"放する必要があるなら、メモリ割り付けを行ったのと同じライブラリの関数を使うこ"
"とが重要です。"

#: ../../library/ctypes.rst:1926
msgid ""
"Windows only: Returns a textual description of the error code *code*.  If no "
"error code is specified, the last error code is used by calling the Windows "
"api function GetLastError."
msgstr ""
"Windows 用: エラーコード *code* の説明文を返します。エラーコードが指定されな"
"い場合は、 Windows api 関数 GetLastError を呼び出して、もっとも新しいエラー"
"コードが使われます。"

#: ../../library/ctypes.rst:1933
msgid ""
"Windows only: Returns the last error code set by Windows in the calling "
"thread. This function calls the Windows `GetLastError()` function directly, "
"it does not return the ctypes-private copy of the error code."
msgstr ""
"Windows 用: 呼び出し側のスレッド内で Windows によって設定された最新のエラー"
"コードを返します。この関数は Windows の `GetLastError()` 関数を直接実行しま"
"す。 ctypes のプライベートなエラーコードのコピーを返したりはしません。"

#: ../../library/ctypes.rst:1939
msgid ""
"Returns the current value of the ctypes-private copy of the system :data:"
"`errno` variable in the calling thread."
msgstr ""
"システムの :data:`errno` 変数の、スレッドローカルなプライベートコピーを返しま"
"す。"

#: ../../library/ctypes.rst:1946
msgid ""
"Windows only: returns the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread."
msgstr ""
"Windows 用: システムの :data:`LastError` 変数の、スレッドローカルなプライベー"
"トコピーを返します。"

#: ../../library/ctypes.rst:1953
msgid ""
"Same as the standard C memmove library function: copies *count* bytes from "
"*src* to *dst*. *dst* and *src* must be integers or ctypes instances that "
"can be converted to pointers."
msgstr ""
"標準 C の memmove ライブラリ関数と同じものです。: *count* バイトを *src* か"
"ら *dst* へコピーします。 *dst* と *src* はポインタへ変換可能な整数または "
"ctypes インスタンスでなければなりません。"

#: ../../library/ctypes.rst:1960
msgid ""
"Same as the standard C memset library function: fills the memory block at "
"address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr ""
"標準 C の memset ライブラリ関数と同じものです。: アドレス *dst* のメモリブ"
"ロックを値 *c* を *count* バイト分書き込みます。 *dst* はアドレスを指定する整"
"数または ctypes インスタンスである必要があります。"

#: ../../library/ctypes.rst:1967
msgid ""
"This factory function creates and returns a new ctypes pointer type. Pointer "
"types are cached and reused internally, so calling this function repeatedly "
"is cheap. *type* must be a ctypes type."
msgstr ""
"このファクトリ関数は新しい ctypes ポインタ型を作成して返します。ポインタ型は"
"キャッシュされ、内部で再利用されます。したがって、この関数を繰り返し呼び出し"
"てもコストは小さいです。*type* は ctypes 型でなければなりません。"

#: ../../library/ctypes.rst:1974
msgid ""
"This function creates a new pointer instance, pointing to *obj*. The "
"returned object is of the type ``POINTER(type(obj))``."
msgstr ""
"この関数は *obj* を指す新しいポインタインスタンスを作成します。戻り値は "
"``POINTER(type(obj))`` 型のオブジェクトです。"

#: ../../library/ctypes.rst:1977
msgid ""
"Note: If you just want to pass a pointer to an object to a foreign function "
"call, you should use ``byref(obj)`` which is much faster."
msgstr ""
"注意: 外部関数呼び出しへオブジェクトへのポインタを渡したいだけなら、はるかに"
"高速な ``byref(obj)`` を使うべきです。"

#: ../../library/ctypes.rst:1983
msgid ""
"This function resizes the internal memory buffer of *obj*, which must be an "
"instance of a ctypes type.  It is not possible to make the buffer smaller "
"than the native size of the objects type, as given by ``sizeof(type(obj))``, "
"but it is possible to enlarge the buffer."
msgstr ""
"この関数は *obj* の内部メモリバッファのサイズを変更します。 *obj* は ctypes "
"型のインスタンスでなければなりません。バッファを ``sizeof(type(obj))`` で与え"
"られるオブジェクト型の本来のサイズより小さくすることはできませんが、バッファ"
"を拡大することはできます。"

#: ../../library/ctypes.rst:1991
msgid ""
"This function sets the rules that ctypes objects use when converting between "
"8-bit strings and unicode strings.  *encoding* must be a string specifying "
"an encoding, like ``'utf-8'`` or ``'mbcs'``, *errors* must be a string "
"specifying the error handling on encoding/decoding errors.  Examples of "
"possible values are ``\"strict\"``, ``\"replace\"``, or ``\"ignore\"``."
msgstr ""
"この関数は 8 ビット文字列と Unicode 文字列の間で変換するときに使われる規則を"
"設定します。 *encoding* は ``'utf-8'`` や ``'mbcs'`` のようなエンコーディング"
"を指定する文字列でなければなりません。 *errors* はエンコーディング/デコーディ"
"ングエラーについてのエラー処理を指定する文字列でなければなりません。指定可能"
"な値の例としては、 ``\"strict\"``, ``\"replace\"``, ``\"ignore\"`` がありま"
"す。"

#: ../../library/ctypes.rst:1997
msgid ""
":func:`set_conversion_mode` returns a 2-tuple containing the previous "
"conversion rules.  On windows, the initial conversion rules are ``('mbcs', "
"'ignore')``, on other systems ``('ascii', 'strict')``."
msgstr ""
":func:`set_conversion_mode` は以前の変換規則を含む 2 要素タプルを返します。 "
"windows では初期の変換規則は ``('mbcs', 'ignore')`` であり、他のシステムでは "
"``('ascii', 'strict')`` です。"

#: ../../library/ctypes.rst:2004
msgid ""
"Set the current value of the ctypes-private copy of the system :data:`errno` "
"variable in the calling thread to *value* and return the previous value."
msgstr ""
"システム変数 :data:`errno` の、呼び出し元スレッドでの ctypes のプライベートコ"
"ピーの現在値を *value* に設定し、前の値を返します。"

#: ../../library/ctypes.rst:2012
msgid ""
"Windows only: set the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread to *value* and "
"return the previous value."
msgstr ""
"Windows 用: システム変数 :data:`LastError` の、呼び出し元スレッドでの ctypes "
"のプライベートコピーの現在値を *value* に設定し、前の値を返します。"

#: ../../library/ctypes.rst:2021
msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. Does "
"the same as the C ``sizeof`` operator."
msgstr ""
"ctypes の型やインスタンスのメモリバッファのサイズをバイト数で返します。C の "
"``sizeof`` 演算子と同様の動きをします。"

#: ../../library/ctypes.rst:2027
msgid ""
"This function returns the string starting at memory address *address*. If "
"size is specified, it is used as size, otherwise the string is assumed to be "
"zero-terminated."
msgstr ""
"この関数はメモリアドレス *address* から始まる文字列を返します。 size が指定さ"
"れた場合はサイズとして使われます。指定されなければ、文字列がゼロ終端されてい"
"ると仮定します。"

#: ../../library/ctypes.rst:2034
msgid ""
"Windows only: this function is probably the worst-named thing in ctypes.  It "
"creates an instance of WindowsError.  If *code* is not specified, "
"``GetLastError`` is called to determine the error code.  If ``descr`` is not "
"specified, :func:`FormatError` is called to get a textual description of the "
"error."
msgstr ""
"Windows 用: この関数は ctypes の中でもおそらく最悪な名前がつけられたもので"
"す。 WindowsError のインスタンスを作成します。 *code* が指定されないならば、"
"エラーコードを決めるために ``GetLastError`` が呼び出されます。 *descr* が指定"
"されないならば、 :func:`FormatError` がエラーの説明文を得るために呼び出されま"
"す。"

#: ../../library/ctypes.rst:2043
msgid ""
"This function returns the wide character string starting at memory address "
"*address* as unicode string.  If *size* is specified, it is used as the "
"number of characters of the string, otherwise the string is assumed to be "
"zero-terminated."
msgstr ""
"この関数は Unicode 文字列としてメモリアドレス *address* から始まるワイドキャ"
"ラクタ文字列を返します。 *size* が指定されたならば、文字列の文字数として使わ"
"れます。指定されなければ、文字列がゼロ終端されていると仮定します。"

#: ../../library/ctypes.rst:2052
msgid "Data types"
msgstr "データ型"

#: ../../library/ctypes.rst:2057
msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that "
"hold C compatible data; the address of the memory block is returned by the :"
"func:`addressof` helper function.  Another instance variable is exposed as :"
"attr:`_objects`; this contains other Python objects that need to be kept "
"alive in case the memory block contains pointers."
msgstr ""
"この非公開クラスはすべての ctypes データ型の共通のベースクラスです。他のこと"
"はさておき、すべての ctypes 型インスタンスは C 互換データを保持するメモリブ"
"ロックを内部に持ちます。このメモリブロックのアドレスは :func:`addressof` ヘル"
"パー関数が返します。別のインスタンス変数が :attr:`_objects` として公開されま"
"す。これはメモリブロックがポインタを含む場合に存続し続ける必要のある他の "
"Python オブジェクトを含んでいます。"

#: ../../library/ctypes.rst:2064
msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr ""
"ctypes データ型の共通メソッド、すべてのクラスメソッドが存在します (正確に"
"は、 :term:`メタクラス <metaclass>` のメソッドです):"

#: ../../library/ctypes.rst:2070
msgid ""
"This method returns a ctypes instance that shares the buffer of the *source* "
"object.  The *source* object must support the writeable buffer interface.  "
"The optional *offset* parameter specifies an offset into the source buffer "
"in bytes; the default is zero.  If the source buffer is not large enough a :"
"exc:`ValueError` is raised."
msgstr ""
"このメソッドは *source* オブジェクトのバッファを共有する ctypes のインスタン"
"スを返します。 *source* オブジェクトは書き込み可能バッファインターフェースを"
"サポートしている必要があります。オプションの *offset* 引数では *source* バッ"
"ファのオフセットをバイト単位で指定します。デフォルトではゼロです。もし "
"*source* バッファが十分に大きくなければ、 :exc:`ValueError` が送出されます。"

#: ../../library/ctypes.rst:2081
msgid ""
"This method creates a ctypes instance, copying the buffer from the *source* "
"object buffer which must be readable.  The optional *offset* parameter "
"specifies an offset into the source buffer in bytes; the default is zero.  "
"If the source buffer is not large enough a :exc:`ValueError` is raised."
msgstr ""
"このメソッドは *source* オブジェクトの読み出し可能バッファをコピーすること"
"で、ctypes のインスタンスを生成します。オプションの *offset* 引数では "
"*source* バッファのオフセットをバイト単位で指定します。デフォルトではゼロで"
"す。もし *source* バッファが十分に大きくなければ、 :exc:`ValueError` が送出さ"
"れます。"

#: ../../library/ctypes.rst:2092
msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr ""
"このメソッドは *address* で指定されたメモリを使って ctypes 型のインスタンスを"
"返します。 *address* は整数でなければなりません。"

#: ../../library/ctypes.rst:2098
msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`argtypes` tuple; it must return an object that can "
"be used as a function call parameter."
msgstr ""
"このメソッドは *obj* を ctypes 型に適合させます。外部関数の :attr:`argtypes` "
"タプルに、その型があるとき、外部関数呼び出しで実際に使われるオブジェクトと共"
"に呼び出されます。"

#: ../../library/ctypes.rst:2103
msgid ""
"All ctypes data types have a default implementation of this classmethod that "
"normally returns *obj* if that is an instance of the type.  Some types "
"accept other objects as well."
msgstr ""
"すべての ctypes のデータ型は、それが型のインスタンスであれば、 *obj* を返すこ"
"のクラスメソッドのデフォルトの実装を持ちます。いくつかの型は、別のオブジェク"
"トも受け付けます。"

#: ../../library/ctypes.rst:2110
msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr ""
"このメソッドは、共有ライブラリによってエクスポートされた ctypes 型のインスタ"
"ンスを返します。 *name* はエクスポートされたデータの名前で、 *library* はロー"
"ドされた共有ライブラリです。"

#: ../../library/ctypes.rst:2115
msgid "Common instance variables of ctypes data types:"
msgstr "ctypes データ型共通のインスタンス変数:"

#: ../../library/ctypes.rst:2119
msgid ""
"Sometimes ctypes data instances do not own the memory block they contain, "
"instead they share part of the memory block of a base object.  The :attr:"
"`_b_base_` read-only member is the root ctypes object that owns the memory "
"block."
msgstr ""
"ctypes 型データのインスタンスは、それ自身のメモリブロックを持たず、基底オブ"
"ジェクトのメモリブロックの一部を共有することがあります。 :attr:`_b_base_` 読"
"み出し専用属性は、メモリブロックを保持する ctypes の基底オブジェクトです。"

#: ../../library/ctypes.rst:2127
msgid ""
"This read-only variable is true when the ctypes data instance has allocated "
"the memory block itself, false otherwise."
msgstr ""
"この読み出し専用の変数は、 ctypes データインスタンスが、それ自身に割り当てら"
"れたメモリブロックを持つとき true になります。それ以外の場合は false になりま"
"す。"

#: ../../library/ctypes.rst:2133
msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept valid.  "
"This object is only exposed for debugging; never modify the contents of this "
"dictionary."
msgstr ""
"このメンバは ``None`` 、または、メモリブロックの内容が正しく保つために、生存"
"させておかなくてはならない Python オブジェクトを持つディクショナリです。この"
"オブジェクトはデバッグでのみ使われます。決してディクショナリの内容を変更しな"
"いで下さい。"

#: ../../library/ctypes.rst:2147
msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of the "
"fundamental ctypes data types.  :class:`_SimpleCData` is a subclass of :"
"class:`_CData`, so it inherits their methods and attributes."
msgstr ""
"この非公開クラスはすべての基本 ctypes データ型のベースクラスです。ここでこの"
"クラスに触れたのは、基本 ctypes データ型の共通属性を含んでいるからです。 :"
"class:`_SimpleCData` は :class:`_CData` のサブクラスですので、そのメソッドと"
"属性を継承しています。"

#: ../../library/ctypes.rst:2152
msgid ""
"ctypes data types that are not and do not contain pointers can now be "
"pickled."
msgstr ""
"ポインタと、ポインタを含まない ctypes データ型が pickle 化できるようになりま"
"した。"

#: ../../library/ctypes.rst:2156
msgid "Instances have a single attribute:"
msgstr "インスタンスは一つだけ属性を持ちます:"

#: ../../library/ctypes.rst:2160
msgid ""
"This attribute contains the actual value of the instance. For integer and "
"pointer types, it is an integer, for character types, it is a single "
"character string, for character pointer types it is a Python string or "
"unicode string."
msgstr ""
"この属性は、インスタンスの実際の値を持ちます。整数型とポインタ型に対しては整"
"数型、文字型に対しては一文字の文字列、文字へのポインタに対しては Python の文"
"字列もしくは Unicode 文字列となります。"

#: ../../library/ctypes.rst:2165
msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually a "
"new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr ""
"``value`` 属性が ctypes インスタンスより参照されたとき、大抵の場合はそれぞれ"
"に対し新しいオブジェクトを返します。 :mod:`ctypes` はオリジナルのオブジェクト"
"を返す実装にはなって *おらず* 新しいオブジェクトを構築します。同じことが他の "
"ctypes オブジェクトインスタンスに対しても言えます。"

#: ../../library/ctypes.rst:2171
msgid ""
"Fundamental data types, when returned as foreign function call results, or, "
"for example, by retrieving structure field members or array items, are "
"transparently converted to native Python types.  In other words, if a "
"foreign function has a :attr:`restype` of :class:`c_char_p`, you will always "
"receive a Python string, *not* a :class:`c_char_p` instance."
msgstr ""
"基本データ型は、外部関数呼び出しの結果として返されたときや、例えば構造体の"
"フィールドメンバーや配列要素を取り出すときに、ネイティブの Python 型へ透過的"
"に変換されます。言い換えると、外部関数が :class:`c_char_p` の :attr:"
"`restype` を持つ場合は、 :class:`c_char_p` インスタンスでは *なく* 常に "
"Python 文字列を受け取ることでしょう。"

#: ../../library/ctypes.rst:2177
msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, if "
"a foreign functions :attr:`restype` is a subclass of :class:`c_void_p`, you "
"will receive an instance of this subclass from the function call. Of course, "
"you can get the value of the pointer by accessing the ``value`` attribute."
msgstr ""
"基本データ型のサブクラスはこの振る舞いを継承 *しません* 。したがって、外部関"
"数の :attr:`restype` が :class:`c_void_p` のサブクラスならば、関数呼び出しか"
"らこのサブクラスのインスタンスを受け取ります。もちろん、 ``value`` 属性にアク"
"セスしてポインタの値を得ることができます。"

#: ../../library/ctypes.rst:2182
msgid "These are the fundamental ctypes data types:"
msgstr "これらが基本 ctypes データ型です:"

#: ../../library/ctypes.rst:2186
msgid ""
"Represents the C :c:type:`signed char` datatype, and interprets the value as "
"small integer.  The constructor accepts an optional integer initializer; no "
"overflow checking is done."
msgstr ""
"C の :c:type:`signed char` データ型を表し、小整数として値を解釈します。コンス"
"トラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは"
"行われません。"

#: ../../library/ctypes.rst:2193
msgid ""
"Represents the C :c:type:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string initializer, "
"the length of the string must be exactly one character."
msgstr ""
"C :c:type:`char` データ型を表し、単一の文字として値を解釈します。コンストラク"
"タはオプションの文字列初期化子を受け取り、その文字列の長さちょうど一文字であ"
"る必要があります。"

#: ../../library/ctypes.rst:2200
msgid ""
"Represents the C :c:type:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point to "
"binary data, ``POINTER(c_char)`` must be used.  The constructor accepts an "
"integer address, or a string."
msgstr ""
"C :c:type:`char *` データ型を表し、ゼロ終端文字列へのポインタでなければなりま"
"せん。バイナリデータを指す可能性のある一般的なポインタに対しては "
"``POINTER(c_char)`` を使わなければなりません。コンストラクタは整数のアドレス"
"もしくは文字列を受け取ります。"

#: ../../library/ctypes.rst:2208
msgid ""
"Represents the C :c:type:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"C :c:type:`double` データ型を表します。コンストラクタはオプションの浮動小数点"
"数初期化子を受け取ります。"

#: ../../library/ctypes.rst:2214
msgid ""
"Represents the C :c:type:`long double` datatype.  The constructor accepts an "
"optional float initializer.  On platforms where ``sizeof(long double) == "
"sizeof(double)`` it is an alias to :class:`c_double`."
msgstr ""
"C :c:type:`long double` データ型を表します。コンストラクタはオプションで浮動"
"小数点数初期化子を受け取ります。 ``sizeof(long double) == sizeof(double)`` で"
"あるプラットフォームでは :class:`c_double` の別名です。"

#: ../../library/ctypes.rst:2222
msgid ""
"Represents the C :c:type:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"C :c:type:`float` データ型を表します。コンストラクタはオプションの浮動小数点"
"数初期化子を受け取ります。"

#: ../../library/ctypes.rst:2228
msgid ""
"Represents the C :c:type:`signed int` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias to :class:`c_long`."
msgstr ""
"C :c:type:`signed int` データ型を表します。コンストラクタはオプションの整数初"
"期化子を受け取ります。オーバーフローのチェックは行われません。 ``sizeof(int) "
"== sizeof(long)`` であるプラットフォームでは、 :class:`c_long` の別名です。"

#: ../../library/ctypes.rst:2235
msgid ""
"Represents the C 8-bit :c:type:`signed int` datatype.  Usually an alias for :"
"class:`c_byte`."
msgstr ""
"C 8-bit :c:type:`signed int` データ型を表します。たいていは、 :class:"
"`c_byte` の別名です。"

#: ../../library/ctypes.rst:2241
msgid ""
"Represents the C 16-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_short`."
msgstr ""
"C 16-bit :c:type:`signed int` データ型を表します。たいていは、 :class:"
"`c_short` の別名です。"

#: ../../library/ctypes.rst:2247
msgid ""
"Represents the C 32-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_int`."
msgstr ""
"C 32-bit :c:type:`signed int` データ型を表します。たいていは、 :class:"
"`c_int` の別名です。"

#: ../../library/ctypes.rst:2253
msgid ""
"Represents the C 64-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_longlong`."
msgstr ""
"C 64-bit :c:type:`signed int` データ型を表します。たいていは、 :class:"
"`c_longlong` の別名です。"

#: ../../library/ctypes.rst:2259
msgid ""
"Represents the C :c:type:`signed long` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed long` データ型を表します。コンストラクタはオプションの整数"
"初期化子を受け取ります。オーバーフローのチェックは行われません。"

#: ../../library/ctypes.rst:2265
msgid ""
"Represents the C :c:type:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed long long` データ型を表します。コンストラクタはオプションの"
"整数初期化子を受け取ります。オーバーフローのチェックは行われません。"

#: ../../library/ctypes.rst:2271
msgid ""
"Represents the C :c:type:`signed short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed short` データ型を表します。コンストラクタはオプションの整数"
"初期化子を受け取ります。オーバーフローのチェックは行われません。"

#: ../../library/ctypes.rst:2277
msgid "Represents the C :c:type:`size_t` datatype."
msgstr "C :c:type:`size_t` データ型を表します。"

#: ../../library/ctypes.rst:2282
msgid "Represents the C :c:type:`ssize_t` datatype."
msgstr "C :c:type:`ssize_t` データ型を表します。"

#: ../../library/ctypes.rst:2289
msgid ""
"Represents the C :c:type:`unsigned char` datatype, it interprets the value "
"as small integer.  The constructor accepts an optional integer initializer; "
"no overflow checking is done."
msgstr ""
"C の :c:type:`unsigned char` データ型を表し、小さな整数として値を解釈します。"
"コンストラクタはオプションの整数初期化子を受け取ります; オーバーフローの"
"チェックは行われません。"

#: ../../library/ctypes.rst:2296
msgid ""
"Represents the C :c:type:`unsigned int` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias for :class:`c_ulong`."
msgstr ""
"C の  :c:type:`unsigned int` データ型を表します。コンストラクタはオプションの"
"整数初期化子を受け取ります; オーバーフローのチェックは行われません。これは、 "
"``sizeof(int) == sizeof(long)`` であるプラットフォームでは :class:`c_ulong` "
"の別名です。"

#: ../../library/ctypes.rst:2303
msgid ""
"Represents the C 8-bit :c:type:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ubyte`."
msgstr ""
"C 8-bit :c:type:`unsigned int` データ型を表します。たいていは、 :class:"
"`c_ubyte` の別名です。"

#: ../../library/ctypes.rst:2309
msgid ""
"Represents the C 16-bit :c:type:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ushort`."
msgstr ""
"C 16-bit :c:type:`unsigned int` データ型を表します。たいていは、 :class:"
"`c_ushort` の別名です。"

#: ../../library/ctypes.rst:2315
msgid ""
"Represents the C 32-bit :c:type:`unsigned int` datatype.  Usually an alias "
"for :class:`c_uint`."
msgstr ""
"C 32-bit :c:type:`unsigned int` データ型を表します。たいていは、 :class:"
"`c_uint` の別名です。"

#: ../../library/ctypes.rst:2321
msgid ""
"Represents the C 64-bit :c:type:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ulonglong`."
msgstr ""
"C 64-bit :c:type:`unsigned int` データ型を表します。たいていは、 :class:"
"`c_ulonglong` の別名です。"

#: ../../library/ctypes.rst:2327
msgid ""
"Represents the C :c:type:`unsigned long` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned long` データ型を表します。コンストラクタはオプションの整"
"数初期化子を受け取ります。オーバーフローのチェックは行われません。"

#: ../../library/ctypes.rst:2333
msgid ""
"Represents the C :c:type:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned long long` データ型を表します。コンストラクタはオプション"
"の整数初期化子を受け取ります。オーバーフローのチェックは行われません。"

#: ../../library/ctypes.rst:2339
msgid ""
"Represents the C :c:type:`unsigned short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned short` データ型を表します。コンストラクタはオプションの整"
"数初期化子を受け取ります。オーバーフローのチェックは行われません。"

#: ../../library/ctypes.rst:2345
msgid ""
"Represents the C :c:type:`void *` type.  The value is represented as "
"integer. The constructor accepts an optional integer initializer."
msgstr ""
"C :c:type:`void *` データ型を表します。値は整数として表されます。コンストラク"
"タはオプションの整数初期化子を受け取ります。"

#: ../../library/ctypes.rst:2351
msgid ""
"Represents the C :c:type:`wchar_t` datatype, and interprets the value as a "
"single character unicode string.  The constructor accepts an optional string "
"initializer, the length of the string must be exactly one character."
msgstr ""
"C :c:type:`wchar_t` データ型を表し、値は Unicode 文字列の単一の文字として解釈"
"されます。コンストラクタはオプションの文字列初期化子を受け取り、その文字列の"
"長さはちょうど一文字である必要があります。"

#: ../../library/ctypes.rst:2358
msgid ""
"Represents the C :c:type:`wchar_t *` datatype, which must be a pointer to a "
"zero-terminated wide character string.  The constructor accepts an integer "
"address, or a string."
msgstr ""
"C :c:type:`wchar_t *` データ型を表し、ゼロ終端ワイド文字列へのポインタでなけ"
"ればなりません。コンストラクタは整数のアドレスもしくは文字列を受け取ります。"

#: ../../library/ctypes.rst:2365
msgid ""
"Represent the C :c:type:`bool` datatype (more accurately, :c:type:`_Bool` "
"from C99).  Its value can be ``True`` or ``False``, and the constructor "
"accepts any object that has a truth value."
msgstr ""
"C の :c:type:`bool` データ型 (より正確には、 C99 以降の  :c:type:`_Bool`) を"
"表します。 ``True`` または ``False`` の値を持ち、コンストラクタは真偽値と解釈"
"できるオブジェクトを受け取ります。"

#: ../../library/ctypes.rst:2374
msgid ""
"Windows only: Represents a :c:type:`HRESULT` value, which contains success "
"or error information for a function or method call."
msgstr ""
"Windows用: :c:type:`HRESULT` 値を表し、関数またはメソッド呼び出しに対する成功"
"またはエラーの情報を含んでいます。"

#: ../../library/ctypes.rst:2380
msgid ""
"Represents the C :c:type:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :c:type:`PyObject *` pointer."
msgstr ""
"C :c:type:`PyObject *` データ型を表します。引数なしでこれを呼び出すと "
"``NULL`` :c:type:`PyObject *` ポインタを作成します。"

#: ../../library/ctypes.rst:2383
msgid ""
"The :mod:`ctypes.wintypes` module provides quite some other Windows specific "
"data types, for example :c:type:`HWND`, :c:type:`WPARAM`, or :c:type:"
"`DWORD`.  Some useful structures like :c:type:`MSG` or :c:type:`RECT` are "
"also defined."
msgstr ""
":mod:`ctypes.wintypes` モジュールは他の Windows 固有のデータ型を提供します。"
"例えば、 :c:type:`HWND`, :c:type:`WPARAM`, :c:type:`DWORD` です。 :c:type:"
"`MSG` や :c:type:`RECT` のような有用な構造体も定義されています。"

#: ../../library/ctypes.rst:2391
msgid "Structured data types"
msgstr "構造化データ型"

#: ../../library/ctypes.rst:2396
msgid "Abstract base class for unions in native byte order."
msgstr "ネイティブのバイトオーダーでの共用体のための抽象ベースクラス。"

#: ../../library/ctypes.rst:2401
msgid "Abstract base class for structures in *big endian* byte order."
msgstr ""
"*ビックエンディアン* バイトオーダーでの構造体のための抽象ベースクラス。"

#: ../../library/ctypes.rst:2406
msgid "Abstract base class for structures in *little endian* byte order."
msgstr ""
"*リトルエンディアン* バイトオーダーでの構造体のための抽象ベースクラス。"

#: ../../library/ctypes.rst:2408
msgid ""
"Structures with non-native byte order cannot contain pointer type fields, or "
"any other data types containing pointer type fields."
msgstr ""
"ネイティブではないバイトオーダーを持つ構造体にポインタ型フィールドあるいはポ"
"インタ型フィールドを含む他のどんなデータ型をも入れることはできません。"

#: ../../library/ctypes.rst:2414
msgid "Abstract base class for structures in *native* byte order."
msgstr "*ネイティブ* のバイトオーダーでの構造体のための抽象ベースクラス。"

#: ../../library/ctypes.rst:2416
msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. :mod:"
"`ctypes` will create :term:`descriptor`\\s which allow reading and writing "
"the fields by direct attribute accesses.  These are the"
msgstr ""
"具象構造体型と具象共用体型はこれらの型の一つをサブクラス化することで作らなけ"
"ればなりません。少なくとも、 :attr:`_fields_` クラス変数を定義する必要があり"
"ます。 :mod:`ctypes` は、属性に直接アクセスしてフィールドを読み書きできるよう"
"にする記述子 (:term:`descriptor`) を作成するでしょう。これらは、"

#: ../../library/ctypes.rst:2424
msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or 3-"
"tuples.  The first item is the name of the field, the second item specifies "
"the type of the field; it can be any ctypes data type."
msgstr ""
"構造体のフィールドを定義するシーケンス。要素は2要素タプルか3要素タプルでなけ"
"ればなりません。第一要素はフィールドの名前です。第二要素はフィールドの型を指"
"定します。それはどんな ctypes データ型でも構いません。"

#: ../../library/ctypes.rst:2428
msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be "
"given.  It must be a small positive integer defining the bit width of the "
"field."
msgstr ""
":class:`c_int` のような整数型のために、オプションの第三要素を与えることができ"
"ます。フィールドのビット幅を定義する正の小整数である必要があります。"

#: ../../library/ctypes.rst:2432
msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr ""
"一つの構造体と共用体の中で、フィールド名はただ一つである必要があります。これ"
"はチェックされません。名前が繰り返しでてきたときにアクセスできるのは一つの"
"フィールドだけです。"

#: ../../library/ctypes.rst:2435
msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows creating "
"data types that directly or indirectly reference themselves::"
msgstr ""
"Structure サブクラスを定義するクラス文の *後で* 、 :attr:`_fields_` クラス変"
"数を定義することができます。これにより、次のように自身を直接または間接的に参"
"照するデータ型を作成できるようになります::"

#: ../../library/ctypes.rst:2445
msgid ""
"The :attr:`_fields_` class variable must, however, be defined before the "
"type is first used (an instance is created, ``sizeof()`` is called on it, "
"and so on).  Later assignments to the :attr:`_fields_` class variable will "
"raise an AttributeError."
msgstr ""
"しかし、 :attr:`_fields_` クラス変数はその型が最初に使われる ( インスタンスが"
"作成される、それに対して ``sizeof()`` が呼び出されるなど ) より前に定義されて"
"いなければなりません。その後 :attr:`_fields_` クラス変数へ代入すると "
"AttributeError が送出されます。"

#: ../../library/ctypes.rst:2450
msgid ""
"It is possible to defined sub-subclasses of structure types, they inherit "
"the fields of the base class plus the :attr:`_fields_` defined in the sub-"
"subclass, if any."
msgstr ""
"構造体型のサブクラスを定義することができ、もしあるならサブクラス内で定義され"
"た :attr:`_fields_` に加えて、ベースクラスのフィールドも継承します。"

#: ../../library/ctypes.rst:2457
msgid ""
"An optional small integer that allows overriding the alignment of structure "
"fields in the instance.  :attr:`_pack_` must already be defined when :attr:"
"`_fields_` is assigned, otherwise it will have no effect."
msgstr ""
"インスタンスの構造体フィールドのアライメントを上書きできるようにするオブショ"
"ンの小整数。 :attr:`_pack_` は :attr:`_fields_` が代入されたときすでに定義さ"
"れていなければなりません。そうでなければ、何の効果もありません。"

#: ../../library/ctypes.rst:2464
msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. :"
"attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr ""
"無名 (匿名) フィールドの名前が並べあげられたオプションのシーケンス。 :attr:"
"`_fields_` が代入されたとき、 :attr:`_anonymous_` がすでに定義されていなけれ"
"ばなりません。そうでなければ、何ら影響はありません。"

#: ../../library/ctypes.rst:2468
msgid ""
"The fields listed in this variable must be structure or union type fields. :"
"mod:`ctypes` will create descriptors in the structure type that allow "
"accessing the nested fields directly, without the need to create the "
"structure or union field."
msgstr ""
"この変数に並べあげられたフィールドは構造体型もしくは共用体型フィールドでなけ"
"ればなりません。構造体フィールドまたは共用体フィールドを作る必要なく、入れ子"
"になったフィールドに直接アクセスできるようにするために、 :mod:`ctypes` は構造"
"体型の中に記述子を作成します。"

#: ../../library/ctypes.rst:2473
msgid "Here is an example type (Windows)::"
msgstr "型の例です (Windows)::"

#: ../../library/ctypes.rst:2486
msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field is "
"defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` are "
"equivalent, but the former is faster since it does not need to create a "
"temporary union instance::"
msgstr ""
"``TYPEDESC`` 構造体はCOMデータ型を表現しており、 ``vt`` フィールドは共用体"
"フィールドのどれが有効であるかを指定します。 ``u`` フィールドは匿名フィールド"
"として定義されているため、 TYPEDESC インスタンスから取り除かれてそのメンバー"
"へ直接アクセスできます。 ``td.lptdesc`` と ``td.u.lptdesc`` は同等ですが、前"
"者がより高速です。なぜなら一時的な共用体インスタンスを作る必要がないためで"
"す。::"

#: ../../library/ctypes.rst:2498
msgid ""
"It is possible to defined sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate :attr:"
"`_fields_` variable, the fields specified in this are appended to the fields "
"of the base class."
msgstr ""
"構造体のサブ-サブクラスを定義することができ、ベースクラスのフィールドを継承し"
"ます。サブクラス定義に別の :attr:`_fields_` 変数がある場合は、この中で指定さ"
"れたフィールドはベースクラスのフィールドへ追加されます。"

#: ../../library/ctypes.rst:2503
msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in the "
"same order as they are appear in :attr:`_fields_`.  Keyword arguments in the "
"constructor are interpreted as attribute assignments, so they will "
"initialize :attr:`_fields_` with the same name, or create new attributes for "
"names not present in :attr:`_fields_`."
msgstr ""
"構造体と共用体のコンストラクタは位置引数とキーワード引数の両方を受け取りま"
"す。位置引数は :attr:`_fields_` の中に現れたのと同じ順番でメンバーフィールド"
"を初期化するために使われます。コンストラクタのキーワード引数は属性代入として"
"解釈され、そのため、同じ名前をもつ :attr:`_fields_` を初期化するか、 :attr:"
"`_fields_` に存在しない名前に対しては新しい属性を作ります。"

#: ../../library/ctypes.rst:2514
msgid "Arrays and pointers"
msgstr "配列とポインタ"

#: ../../library/ctypes.rst:2518
msgid "Abstract base class for arrays."
msgstr "配列のための抽象基底クラスです。"

#: ../../library/ctypes.rst:2520
msgid ""
"The recommended way to create concrete array types is by multiplying any :"
"mod:`ctypes` data type with a positive integer.  Alternatively, you can "
"subclass this type and define :attr:`_length_` and :attr:`_type_` class "
"variables. Array elements can be read and written using standard subscript "
"and slice accesses; for slice reads, the resulting object is *not* itself "
"an :class:`Array`."
msgstr ""
"具象配列型を作成するための推奨される方法は、任意の :mod:`ctypes` データ型に正"
"の整数を乗算することです。代わりに、この型のサブクラスを作成し、 :attr:"
"`_length_` と :attr:`_type_` のクラス変数を定義することもできます。配列の要素"
"は、標準の添え字とスライスによるアクセスを使用して読み書きを行うことができま"
"す。スライスの読み込みでは、結果のオブジェクト自体は :class:`Array` ではあり"
"ません。"

#: ../../library/ctypes.rst:2530
msgid ""
"A positive integer specifying the number of elements in the array. Out-of-"
"range subscripts result in an :exc:`IndexError`. Will be returned by :func:"
"`len`."
msgstr ""
"配列の要素数を指定する正の整数。範囲外の添え字を指定すると、 :exc:"
"`IndexError` が送出されます。:func:`len` がこの整数を返します。"

#: ../../library/ctypes.rst:2537
msgid "Specifies the type of each element in the array."
msgstr "配列内の各要素の型を指定します。"

#: ../../library/ctypes.rst:2540
msgid ""
"Array subclass constructors accept positional arguments, used to initialize "
"the elements in order."
msgstr ""
"配列のサブクラスのコンストラクタは、位置引数を受け付けて、配列を順番に初期化"
"するために使用します。"

#: ../../library/ctypes.rst:2546
msgid "Private, abstract base class for pointers."
msgstr "ポインタのためのプライベートな抽象基底クラスです。"

#: ../../library/ctypes.rst:2548
msgid ""
"Concrete pointer types are created by calling :func:`POINTER` with the type "
"that will be pointed to; this is done automatically by :func:`pointer`."
msgstr ""
"具象ポインタ型は、ポイント先の型を持つ :func:`POINTER` を呼び出すことで、作成"
"できます。これは、 :func:`pointer` により自動的に行われます。"

#: ../../library/ctypes.rst:2552
msgid ""
"If a pointer points to an array, its elements can be read and written using "
"standard subscript and slice accesses.  Pointer objects have no size, so :"
"func:`len` will raise :exc:`TypeError`.  Negative subscripts will read from "
"the memory *before* the pointer (as in C), and out-of-range subscripts will "
"probably crash with an access violation (if you're lucky)."
msgstr ""
"ポインタが配列を指す場合、その配列の要素は、標準の添え字とスライスによるアク"
"セスを使用して読み書きが行えます。ポインタオブジェクトには、サイズがないた"
"め、 :func:`len` 関数は :exc:`TypeError` を送出します。負の添え字は、(C と同"
"様に) ポインタの *前* のメモリから読み込み、範囲外の添え字はおそらく (幸運な"
"場合でも) アクセス違反によりクラッシュを起こします。"

#: ../../library/ctypes.rst:2562
msgid "Specifies the type pointed to."
msgstr "ポイント先の型を指定します。"

#: ../../library/ctypes.rst:2566
msgid ""
"Returns the object to which to pointer points.  Assigning to this attribute "
"changes the pointer to point to the assigned object."
msgstr ""
"ポインタが指すオブジェクトを返します。この属性に割り当てると、ポインタが割り"
"当てられたオブジェクトを指すようになります。"
