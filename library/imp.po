# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-05 15:01+0000\n"
"PO-Revision-Date: 2018-06-29 17:33+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/imp.rst:2
msgid ":mod:`imp` --- Access the :ref:`import <importsystem>` internals"
msgstr ":mod:`imp` --- :ref:`import <importsystem>` å†…éƒ¨ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹"

#: ../../library/imp.rst:8
msgid "**Source code:** :source:`Lib/imp.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/imp.py`"

#: ../../library/imp.rst:10
msgid ""
"The :mod:`imp` package is pending deprecation in favor of :mod:`importlib`."
msgstr ":mod:`imp` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ :mod:`importlib` ã‚’å¾Œç¶™ã¨ã—ã¦å»ƒæ­¢äºˆå®šã§ã™ã€‚"

#: ../../library/imp.rst:17
msgid ""
"This module provides an interface to the mechanisms used to implement the "
":keyword:`import` statement.  It defines the following constants and "
"functions:"
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :keyword:`import` "
"æ–‡ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã¸ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚æ¬¡ã®å®šæ•°ã¨é–¢æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™:"

#: ../../library/imp.rst:25
msgid ""
"Return the magic string value used to recognize byte-compiled code files "
"(:file:`.pyc` files).  (This value may be different for each Python "
"version.)"
msgstr ""
"ãƒã‚¤ãƒˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«(:file:`.pyc` ãƒ•ã‚¡ã‚¤ãƒ«)ã‚’èªè­˜ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹ãƒã‚¸ãƒƒã‚¯æ–‡å­—åˆ—å€¤ã‚’è¿”ã—ã¾ã™ã€‚ (ã“ã®å€¤ã¯ Python"
" ã®å„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ç•°ãªã‚Šã¾ã™ã€‚)"

#: ../../library/imp.rst:28
msgid "Use :attr:`importlib.util.MAGIC_NUMBER` instead."
msgstr "ä»£ã‚ã‚Šã« :attr:`importlib.util.MAGIC_NUMBER` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/imp.rst:34
msgid ""
"Return a list of 3-element tuples, each describing a particular type of "
"module. Each triple has the form ``(suffix, mode, type)``, where *suffix* is"
" a string to be appended to the module name to form the filename to search "
"for, *mode* is the mode string to pass to the built-in :func:`open` function"
" to open the file (this can be ``'r'`` for text files or ``'rb'`` for binary"
" files), and *type* is the file type, which has one of the values "
":const:`PY_SOURCE`, :const:`PY_COMPILED`, or :const:`C_EXTENSION`, described"
" below."
msgstr ""
"3è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œãã‚Œã®ã‚¿ãƒ—ãƒ«ã¯ç‰¹å®šã®ç¨®é¡ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚å„ã‚¿ãƒ—ãƒ«ã¯ ``(suffix, mode, type)``"
" ã¨ã„ã†å½¢å¼ã§ã™ã€‚ã“ã“ã§ã€ *suffix* ã¯æ¢ã™ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ä½œã‚‹ãŸã‚ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã«è¿½åŠ ã™ã‚‹æ–‡å­—åˆ—ã§ã™ã€‚ãã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚ªãƒ¼ãƒ—ãƒ³ã™ã‚‹ãŸã‚ã«ã€ "
"*mode* ã¯çµ„ã¿è¾¼ã¿ :func:`open` é–¢æ•°ã¸æ¸¡ã•ã‚Œã‚‹ãƒ¢ãƒ¼ãƒ‰æ–‡å­—åˆ—ã§ã™ (ã“ã‚Œã¯ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«å¯¾ã—ã¦ã¯ ``'r'`` "
"ã€ãƒã‚¤ãƒŠãƒªãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦ã¯ ``'rb'`` ã¨ãªã‚Šã¾ã™)ã€‚ *type* ã¯ãƒ•ã‚¡ã‚¤ãƒ«å‹ã§ã€ä»¥ä¸‹ã§èª¬æ˜ã™ã‚‹å€¤ :const:`PY_SOURCE`, "
":const:`PY_COMPILED` ã‚ã‚‹ã„ã¯ã€ :const:`C_EXTENSION` ã®ä¸€ã¤ã‚’å–ã‚Šã¾ã™ã€‚"

#: ../../library/imp.rst:43
msgid "Use the constants defined on :mod:`importlib.machinery` instead."
msgstr "ä»£ã‚ã‚Šã« :mod:`importlib.machinery` ã§å®šç¾©ã•ã‚ŒãŸå®šæ•°ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/imp.rst:49
msgid ""
"Try to find the module *name*.  If *path* is omitted or ``None``, the list "
"of directory names given by ``sys.path`` is searched, but first a few "
"special places are searched: the function tries to find a built-in module "
"with the given name (:const:`C_BUILTIN`), then a frozen module "
"(:const:`PY_FROZEN`), and on some systems some other places are looked in as"
" well (on Windows, it looks in the registry which may point to a specific "
"file)."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« *name* ã‚’è¦‹ã¤ã‘ã‚ˆã†ã¨ã—ã¾ã™ã€‚ *path* ãŒçœç•¥ã•ã‚Œã‚‹ã‹ ``None`` ãªã‚‰ã°ã€ ``sys.path`` "
"ã«ã‚ˆã£ã¦ä¸ãˆã‚‰ã‚Œã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã®ãƒªã‚¹ãƒˆãŒæ¤œç´¢ã•ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€æœ€åˆã«ã„ãã¤ã‹ç‰¹åˆ¥ãªå ´æ‰€ã‚’æ¤œç´¢ã—ã¾ã™ã€‚ã¾ãšã€æ‰€å®šã®åå‰ã‚’ã‚‚ã¤çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«(:const:`C_BUILTIN`)ã‚’è¦‹ã¤ã‘ã‚ˆã†ã¨ã—ã¾ã™ã€‚ãã‚Œã‹ã‚‰ã€ãƒ•ãƒªãƒ¼ã‚ºã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«(:const:`PY_FROZEN`)ã€ãã—ã¦ã„ãã¤ã‹ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ä»–ã®å ´æ‰€ãŒåŒæ§˜ã«æ¤œç´¢ã•ã‚Œã¾ã™"
" (Windowsã§ã¯ã€ç‰¹å®šã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡ã™ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã®ä¸­ã‚’è¦‹ã¾ã™)ã€‚"

#: ../../library/imp.rst:56
msgid ""
"Otherwise, *path* must be a list of directory names; each directory is "
"searched for files with any of the suffixes returned by :func:`get_suffixes`"
" above.  Invalid names in the list are silently ignored (but all list items "
"must be strings)."
msgstr ""
"ãã‚Œä»¥å¤–ã®å ´åˆã€ *path* ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã®ãƒªã‚¹ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¸Šã® :func:`get_suffixes` "
"ãŒè¿”ã™æ‹¡å¼µå­ã®ã„ãšã‚Œã‹ã‚’ä¼´ã£ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’å„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ä¸­ã§æ¤œç´¢ã—ã¾ã™ã€‚ãƒªã‚¹ãƒˆå†…ã®æœ‰åŠ¹ã§ãªã„åå‰ã¯é»™ã£ã¦ç„¡è¦–ã•ã‚Œã¾ã™(ã—ã‹ã—ã€ã™ã¹ã¦ã®ãƒªã‚¹ãƒˆé …ç›®ã¯æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“)ã€‚"

#: ../../library/imp.rst:61
msgid ""
"If search is successful, the return value is a 3-element tuple ``(file, "
"pathname, description)``:"
msgstr "æ¤œç´¢ãŒæˆåŠŸã™ã‚Œã°ã€æˆ»ã‚Šå€¤ã¯3è¦ç´ ã®ã‚¿ãƒ—ãƒ« ``(file, pathname, description)`` ã§ã™:"

#: ../../library/imp.rst:64
msgid ""
"*file* is an open :term:`file object` positioned at the beginning, "
"*pathname* is the pathname of the file found, and *description* is a "
"3-element tuple as contained in the list returned by :func:`get_suffixes` "
"describing the kind of module found."
msgstr ""
"*file* ã¯å…ˆé ­ã«ä½ç½®åˆã‚ã›ã•ã‚ŒãŸã‚ªãƒ¼ãƒ—ãƒ³ :term:`ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <file object>` ã§ã€ *pathname* "
"ã¯è¦‹ã¤ã‹ã£ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹åã§ã™ã€‚ãã—ã¦ã€ *description* ã¯ :func:`get_suffixes` "
"ãŒè¿”ã™ãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ã‚‹ã‚ˆã†ãª3è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã§ã€è¦‹ã¤ã‹ã£ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ç¨®é¡ã‚’èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/imp.rst:69
msgid ""
"If the module does not live in a file, the returned *file* is ``None``, "
"*pathname* is the empty string, and the *description* tuple contains empty "
"strings for its suffix and mode; the module type is indicated as given in "
"parentheses above.  If the search is unsuccessful, :exc:`ImportError` is "
"raised.  Other exceptions indicate problems with the arguments or "
"environment."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦å­˜åœ¨ã—ã¦ã„ãªã‘ã‚Œã°ã€è¿”ã•ã‚ŒãŸ *file* ã¯ ``None`` ã§ã€ *pathname* ã¯ç©ºæ–‡å­—åˆ—ã€ "
"*description* ã‚¿ãƒ—ãƒ«ã¯ãã®æ‹¡å¼µå­ã¨ãƒ¢ãƒ¼ãƒ‰ã«å¯¾ã—ã¦ç©ºæ–‡å­—åˆ—ã‚’å«ã¿ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å‹ã¯ä¸Šã®æ‹¬å¼§ã®ä¸­ã«ç¤ºã•ã‚Œã¾ã™ã€‚æ¤œç´¢ãŒå¤±æ•—ã™ã‚Œã°ã€ "
":exc:`ImportError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ä»–ã®ä¾‹å¤–ã¯å¼•æ•°ã¾ãŸã¯ç’°å¢ƒã«å•é¡ŒãŒã‚ã‚‹ã“ã¨ã‚’ç¤ºå”†ã—ã¾ã™ã€‚"

#: ../../library/imp.rst:76
msgid ""
"If the module is a package, *file* is ``None``, *pathname* is the package "
"path and the last item in the *description* tuple is :const:`PKG_DIRECTORY`."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãªã‚‰ã°ã€ *file* ã¯ ``None`` ã§ã€ *pathname* ã¯ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ãƒ‘ã‚¹ã§ *description* "
"ã‚¿ãƒ—ãƒ«ã®æœ€å¾Œã®é …ç›®ã¯ :const:`PKG_DIRECTORY` ã§ã™ã€‚"

#: ../../library/imp.rst:79
msgid ""
"This function does not handle hierarchical module names (names containing "
"dots).  In order to find *P.M*, that is, submodule *M* of package *P*, use "
":func:`find_module` and :func:`load_module` to find and load package *P*, "
"and then use :func:`find_module` with the *path* argument set to "
"``P.__path__``. When *P* itself has a dotted name, apply this recipe "
"recursively."
msgstr ""
"ã“ã®é–¢æ•°ã¯éšå±¤çš„ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å(ãƒ‰ãƒƒãƒˆã‚’å«ã‚€åå‰)ã‚’æ‰±ã„ã¾ã›ã‚“ã€‚ *P.M* ã€ã™ãªã‚ã¡ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ *P* ã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« *M* "
"ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ã¯ã€ã¾ãš :func:`find_module` ã¨ :func:`load_module` ã‚’ä½¿ç”¨ã—ã¦ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ *P* "
"ã‚’è¦‹ã¤ã‘ã¦ãƒ­ãƒ¼ãƒ‰ã—ã¦ã€æ¬¡ã« ``P.__path__`` ã‚’ *path* å¼•æ•°ã«ã—ã¦ :func:`find_module` "
"ã‚’å‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚ã‚‚ã— *P* è‡ªä½“ãŒãƒ‰ãƒƒãƒˆä»˜ãã®åå‰ã‚’æŒã¤å ´åˆã€ã“ã®ãƒ¬ã‚·ãƒ”ã‚’å†å¸°çš„ã«é©ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/imp.rst:85
msgid ""
"Use :func:`importlib.util.find_spec` instead unless Python 3.3 compatibility"
" is required, in which case use :func:`importlib.find_loader`. For example "
"usage of the former case, see the :ref:`importlib-examples` section of the "
":mod:`importlib` documentation."
msgstr ""
"Python 3.3 ã¨ã®äº’æ›æ€§ãŒä¸è¦ã§ã‚ã‚Œã°ã€:func:`importlib.util.find_spec` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„, "
"äº’æ›æ€§ãŒå¿…è¦ãªå ´åˆã¯ :func:`importlib.find_loader` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚å‰è€…ã®ä½¿ç”¨ä¾‹ã¯ã€:mod:`importlib` "
"ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®:ref:`importlib-examples` ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/imp.rst:95
msgid ""
"Load a module that was previously found by :func:`find_module` (or by an "
"otherwise conducted search yielding compatible results).  This function does"
" more than importing the module: if the module was already imported, it will"
" reload the module!  The *name* argument indicates the full module name "
"(including the package name, if this is a submodule of a package).  The "
"*file* argument is an open file, and *pathname* is the corresponding file "
"name; these can be ``None`` and ``''``, respectively, when the module is a "
"package or not being loaded from a file.  The *description* argument is a "
"tuple, as would be returned by :func:`get_suffixes`, describing what kind of"
" module must be loaded."
msgstr ""
":func:`find_module` "
"ã‚’ä½¿ã£ã¦(ã‚ã‚‹ã„ã¯ã€äº’æ›æ€§ã®ã‚ã‚‹çµæœã‚’ä½œã‚Šå‡ºã™æ¤œç´¢ã‚’è¡Œã£ã¦)ä»¥å‰è¦‹ã¤ã‘ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã¨ã„ã†ä»¥ä¸Šã®ã“ã¨ã‚’è¡Œã„ã¾ã™:"
" ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæ—¢ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãªã‚‰ã°ã€ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¾ã™! *name* "
"å¼•æ•°ã¯(ã“ã‚ŒãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãªã‚‰ã°ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åã‚’å«ã‚€)å®Œå…¨ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’ç¤ºã—ã¾ã™ã€‚ *file* å¼•æ•°ã¯ã‚ªãƒ¼ãƒ—ãƒ³ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã§ã€ "
"*pathname* ã¯å¯¾å¿œã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«åã§ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã‚ã‚‹ã‹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚ˆã†ã¨ã—ã¦ã„ãªã„ã¨ãã€ã“ã‚Œã‚‰ã¯ãã‚Œãã‚Œ "
"``None`` ã¨ ``''`` ã§ã‚ã£ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ :func:`get_suffixes` ãŒè¿”ã™ã‚ˆã†ã« *description* "
"å¼•æ•°ã¯ã‚¿ãƒ—ãƒ«ã§ã€ã©ã®ç¨®é¡ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œãªã‘ã‚Œã°ãªã‚‰ãªã„ã‹ã‚’èª¬æ˜ã™ã‚‹ã‚‚ã®ã§ã™ã€‚"

#: ../../library/imp.rst:106
msgid ""
"If the load is successful, the return value is the module object; otherwise,"
" an exception (usually :exc:`ImportError`) is raised."
msgstr ""
"ãƒ­ãƒ¼ãƒ‰ãŒæˆåŠŸã—ãŸãªã‚‰ã°ã€æˆ»ã‚Šå€¤ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ä¾‹å¤–(ãŸã„ã¦ã„ã¯ :exc:`ImportError`)ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/imp.rst:109
msgid ""
"**Important:** the caller is responsible for closing the *file* argument, if"
" it was not ``None``, even when an exception is raised.  This is best done "
"using a :keyword:`try` ... :keyword:`finally` statement."
msgstr ""
"**é‡è¦:** *file* å¼•æ•°ãŒ ``None`` ã§ãªã‘ã‚Œã°ã€ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸå ´åˆã§ã‚‚å‘¼ã³å‡ºã—å´ã«ã¯ãã‚Œã‚’é–‰ã˜ã‚‹è²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚’è¡Œã†ã«ã¯ã€ "
":keyword:`try` ... :keyword:`finally` æ–‡ã‚’ä½¿ã†ã“ã¨ãŒæœ€ã‚‚è‰¯ã„ã§ã™ã€‚"

#: ../../library/imp.rst:113
msgid ""
"If previously used in conjunction with :func:`imp.find_module` then consider"
" using :func:`importlib.import_module`, otherwise use the loader returned by"
" the replacement you chose for :func:`imp.find_module`. If you called "
":func:`imp.load_module` and related functions directly with file path "
"arguments then use a combination of "
":func:`importlib.util.spec_from_file_location` and "
":func:`importlib.util.module_from_spec`. See the :ref:`importlib-examples` "
"section of the :mod:`importlib` documentation for details of the various "
"approaches."
msgstr ""

#: ../../library/imp.rst:127
msgid ""
"Return a new empty module object called *name*.  This object is *not* "
"inserted in ``sys.modules``."
msgstr ""
"*name* ã¨ã„ã†åå‰ã®æ–°ã—ã„ç©ºãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ ``sys.modules`` ã«æŒ¿å…¥ã•ã‚Œ *ã¾ã›ã‚“* ã€‚"

#: ../../library/imp.rst:130
msgid "Use :func:`importlib.util.module_from_spec` instead."
msgstr "ä»£ã‚ã‚Šã«:func:`importlib.util.module_from_spec` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/imp.rst:136
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (the same as the *module* argument)."
msgstr ""
"ã™ã§ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸ *module* "
"ã‚’å†è§£é‡ˆã—ã€å†åˆæœŸåŒ–ã—ã¾ã™ã€‚å¼•æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã§ã€äºˆã‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«æˆåŠŸã—ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®é–¢æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¤–éƒ¨ã‚¨ãƒ‡ã‚£ã‚¿ã§ç·¨é›†ã—ã¦ã€Python"
" ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‹ã‚‰é›¢ã‚Œã‚‹ã“ã¨ãªãæ–°ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è©¦ã—ãŸã„éš›ã«æœ‰åŠ¹ã§ã™ã€‚æˆ»ã‚Šå€¤ã¯ (*module* å¼•æ•°ã¨åŒã˜) ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/imp.rst:142
msgid "When ``reload(module)`` is executed:"
msgstr "``reload(module)`` ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ä»¥ä¸‹ã®å‡¦ç†ãŒè¡Œã‚ã‚Œã¾ã™:"

#: ../../library/imp.rst:144
msgid ""
"Python modules' code is recompiled and the module-level code reexecuted, "
"defining a new set of objects which are bound to names in the module's "
"dictionary.  The ``init`` function of extension modules is not called a "
"second time."
msgstr ""
"Python "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã¯å†ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã¯å†åº¦å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è¾æ›¸ä¸­ã«ã‚ã‚‹ã€ä½•ã‚‰ã‹ã®åå‰ã«çµã³ä»˜ã‘ã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ–°ãŸã«å®šç¾©ã—ã¾ã™ã€‚æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸­ã®"
" ``init`` é–¢æ•°ãŒäºŒåº¦å‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/imp.rst:149
msgid ""
"As with all other objects in Python the old objects are only reclaimed after"
" their reference counts drop to zero."
msgstr "Python ã«ãŠã‘ã‚‹ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒæ§˜ã€ä»¥å‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ãƒ¢ãƒªé ˜åŸŸã¯ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«ãªã‚‰ãªã„ã‹ãã‚Šå†åˆ©ç”¨ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/imp.rst:152
msgid ""
"The names in the module namespace are updated to point to any new or changed"
" objects."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åå‰ç©ºé–“å†…ã®åå‰ã¯æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ã¾ãŸã¯æ›´æ–°ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) ã‚’æŒ‡ã™ã‚ˆã†æ›´æ–°ã•ã‚Œã¾ã™ã€‚"

#: ../../library/imp.rst:155
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"ä»¥å‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ (å¤–éƒ¨ã®ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãªã©ã‹ã‚‰ã®) "
"å‚ç…§ã‚’å—ã‘ã¦ã„ã‚‹å ´åˆã€ãã‚Œã‚‰ã‚’æ–°ãŸãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å†æŸç¸›ã—ç›´ã™ã“ã¨ã¯ãªã„ã®ã§ã€å¿…è¦ãªã‚‰è‡ªåˆ†ã§åå‰ç©ºé–“ã‚’æ›´æ–°ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/imp.rst:159
msgid "There are a number of other caveats:"
msgstr "ã„ãã¤ã‹è£œè¶³èª¬æ˜ãŒã‚ã‚Šã¾ã™:"

#: ../../library/imp.rst:161
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå†ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸéš›ã€ãã®è¾æ›¸ (ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’å«ã¿ã¾ã™) "
"ã¯ãã®ã¾ã¾æ®‹ã‚Šã¾ã™ã€‚åå‰ã®å†å®šç¾©ã‚’è¡Œã†ã¨ã€ä»¥å‰ã®å®šç¾©ã‚’ä¸Šæ›¸ãã™ã‚‹ã®ã§ã€ä¸€èˆ¬çš„ã«ã¯å•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æ–°ãŸãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§å®šç¾©ã•ã‚ŒãŸåå‰ã‚’å®šç¾©ã—ã¦ã„ãªã„å ´åˆã€å¤ã„å®šç¾©ãŒãã®ã¾ã¾æ®‹ã‚Šã¾ã™ã€‚è¾æ›¸ãŒã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç¶­æŒã—ã¦ã„ã‚Œã°ã€ã“ã®æ©Ÿèƒ½ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æœ‰åŠ¹æ€§ã‚’å¼•ãå‡ºã™ãŸã‚ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™"
" --- ã¤ã¾ã‚Šã€ :keyword:`try` æ–‡ã‚’ä½¿ãˆã°ã€å¿…è¦ã«å¿œã˜ã¦ãƒ†ãƒ¼ãƒ–ãƒ«ãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã—ã€ãã®åˆæœŸåŒ–ã‚’é£›ã°ã™ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/imp.rst:174
msgid ""
"It is legal though generally not very useful to reload built-in or "
"dynamically loaded modules, except for :mod:`sys`, :mod:`__main__` and "
":mod:`builtins`. In many cases, however, extension modules are not designed "
"to be initialized more than once, and may fail in arbitrary ways when "
"reloaded."
msgstr ""
"ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„å‹•çš„ã«ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ã¯ã€ :mod:`sys`, :mod:`__main__`, "
":mod:`builtins` "
"ã‚’é™¤ã„ã¦ä¸€èˆ¬ã«ã¯ãã‚Œã»ã©æœ‰ç”¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€åˆæ³•ã§ã™ã€‚ã—ã‹ã—ã€å¤šãã®å ´åˆã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯äºŒåº¦ä»¥ä¸ŠåˆæœŸåŒ–ã•ã‚Œã‚‹ã‚ˆã†ã«ã¯ä½œã‚‰ã‚Œã¦ãŠã‚‰ãšã€ãƒªãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸæ™‚ã«ç„¡ä½œç‚ºãªæ–¹æ³•ã§å¤±æ•—ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/imp.rst:179
msgid ""
"If a module imports objects from another module using :keyword:`from` ... "
":keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`from` statement, another is to use :keyword:`import` "
"and qualified names (*module*.*name*) instead."
msgstr ""
"ä¸€æ–¹ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ :keyword:`from` ... :keyword:`import` ... "
"ã‚’ä½¿ã£ã¦ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»–æ–¹ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãªã‚‰ã€ä»–æ–¹ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ :func:`reload` "
"ã§å‘¼ã³å‡ºã—ã¦ã‚‚ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†å®šç¾©ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ --- ã“ã®å•é¡Œã‚’å›é¿ã™ã‚‹ä¸€ã¤ã®æ–¹æ³•ã¯ã€ "
":keyword:`from` æ–‡ã‚’å†åº¦å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã€ã‚‚ã†ä¸€ã¤ã®æ–¹æ³•ã¯ :keyword:`from` æ–‡ã®ä»£ã‚ã‚Šã« "
":keyword:`import` ã¨é™å®šçš„ãªåå‰ (*module*.\\*name*) ã‚’ä½¿ã†ã“ã¨ã§ã™ã€‚"

#: ../../library/imp.rst:185
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"ã‚ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¦ã„ã‚‹å ´åˆã€ãã®ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†ãƒ­ãƒ¼ãƒ‰ã¯ãã‚Œã‚‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ã«å½±éŸ¿ã—ã¾ã›ã‚“ "
"--- ãã‚Œã‚‰ã¯å¤ã„ã‚¯ãƒ©ã‚¹å®šç¾©ã‚’ä½¿ã„ç¶šã‘ã¾ã™ã€‚ã“ã‚Œã¯æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã®å ´åˆã§ã‚‚åŒã˜ã§ã™ã€‚"

#: ../../library/imp.rst:189
msgid ""
"Relies on both ``__name__`` and ``__loader__`` being defined on the module "
"being reloaded instead of just ``__name__``."
msgstr ""
"ãƒªãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸Šã§ã€``__name__`` ã ã‘ã§ãªã ``__name__`` ã¨ ``__loader__`` "
"ã®ä¸¡æ–¹ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã«ä¾å­˜ã—ã¾ã™ã€‚"

#: ../../library/imp.rst:193
msgid "Use :func:`importlib.reload` instead."
msgstr "ä»£ã‚ã‚Šã« :func:`importlib.reload` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/imp.rst:197
msgid ""
"The following functions are conveniences for handling :pep:`3147` byte-"
"compiled file paths."
msgstr "ä»¥ä¸‹ã¯ã€ :pep:`3147` ã®ãƒã‚¤ãƒˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ‰±ã†ãŸã‚ã«ä¾¿åˆ©ãªé–¢æ•°ã§ã™ã€‚"

#: ../../library/imp.rst:204
msgid ""
"Return the :pep:`3147` path to the byte-compiled file associated with the "
"source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the return "
"value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python 3.2. "
"The ``cpython-32`` string comes from the current magic tag (see "
":func:`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then"
" :exc:`NotImplementedError` will be raised). By passing in ``True`` or "
"``False`` for *debug_override* you can override the system's value for "
"``__debug__``, leading to optimized bytecode."
msgstr ""
"ã‚½ãƒ¼ã‚¹ *path* ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸãƒã‚¤ãƒˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã® :pep:`3147` ãƒ‘ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ *path* ãŒ "
"``/foo/bar/baz.py`` ãªã‚‰ã€ Python 3.2 ã®å ´åˆè¿”ã‚Šå€¤ã¯ "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` ã«ãªã‚Šã¾ã™ã€‚ ``cpython-32`` "
"ã¨ã„ã†æ–‡å­—åˆ—ã¯ã€ç¾åœ¨ã®ãƒã‚¸ãƒƒã‚¯ã‚¿ã‚°ã‹ã‚‰å¾—ã‚‰ã‚Œã¾ã™ (ãƒã‚¸ãƒƒã‚¯ã‚¿ã‚°ã«ã¤ã„ã¦ã¯ :func:`get_tag` ã‚’å‚ç…§; "
":attr:`sys.implementation.cache_tag` ãŒæœªå®šç¾©ãªã‚‰ :exc:`NotImplementedError` "
"ãŒé€å‡ºã•ã‚Œã¾ã™)ã€‚ *debug_override* ã« ``True`` ã‚ã‚‹ã„ã¯ ``False`` ã‚’æ¸¡ã™ã“ã¨ã«ã‚ˆã£ã¦ã€ "
"``__debug__`` ã‚·ã‚¹ãƒ†ãƒ å€¤ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¦æœ€é©åŒ–ã•ã‚ŒãŸãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/imp.rst:213
msgid "*path* need not exist."
msgstr "*path* ã¯å­˜åœ¨ã—ã¦ã„ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/imp.rst:215
msgid ""
"If :attr:`sys.implementation.cache_tag` is ``None``, then "
":exc:`NotImplementedError` is raised."
msgstr ""
":attr:`sys.implementation.cache_tag` ãŒ ``None`` ã®å ´åˆã€ "
":exc:`NotImplementedError` ãŒä¸Šã’ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/imp.rst:219
msgid "Use :func:`importlib.util.cache_from_source` instead."
msgstr "ä»£ã‚ã‚Šã« :func:`importlib.util.cache_from_source` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/imp.rst:222
msgid "The *debug_override* parameter no longer creates a ``.pyo`` file."
msgstr "*debug_override* å¼•æ•°ã¯ ``.pyo`` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã™ã‚‹ã“ã¨ã¯ã‚‚ã†ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/imp.rst:228
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` the returned path would be "
"``/foo/bar/baz.py``.  *path* need not exist, however if it does not conform "
"to :pep:`3147` format, a ``ValueError`` is raised. If "
":attr:`sys.implementation.cache_tag` is not defined, "
":exc:`NotImplementedError` is raised."
msgstr ""
":pep:`3147` ãƒ•ã‚¡ã‚¤ãƒ«åã¸ã® *path* ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€é–¢é€£ã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ *path* ãŒ "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` ãªã‚‰ã€è¿”ã•ã‚Œã‚‹ãƒ‘ã‚¹ã¯ ``/foo/bar/baz.py`` "
"ã«ãªã‚Šã¾ã™ã€‚ *path* ã¯å­˜åœ¨ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ :pep:`3147` ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ä¸€è‡´ã—ãªã„å ´åˆã¯ ``ValueError`` "
"ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ :attr:`sys.implementation.cache_tag` ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ "
":exc:`NotImplementedError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/imp.rst:236
msgid ""
"Raise :exc:`NotImplementedError` when :attr:`sys.implementation.cache_tag` "
"is not defined."
msgstr ""
":attr:`sys.implementation.cache_tag` ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ :exc:`NotImplementedError`"
" ãŒä¸Šã’ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/imp.rst:240
msgid "Use :func:`importlib.util.source_from_cache` instead."
msgstr "ä»£ã‚ã‚Šã« :func:`importlib.util.source_from_cache` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/imp.rst:246
msgid ""
"Return the :pep:`3147` magic tag string matching this version of Python's "
"magic number, as returned by :func:`get_magic`."
msgstr ""
":func:`get_magic` ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ã®ã¨åŒã˜ã€ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã®ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ã¨ä¸€è‡´ã™ã‚‹ :pep:`3147` "
"ã®ãƒã‚¸ãƒƒã‚¯ã‚¿ã‚°æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/imp.rst:249
msgid ""
"Use :attr:`sys.implementation.cache_tag` directly starting in Python 3.3."
msgstr "Python 3.3 ã‹ã‚‰ã¯ :attr:`sys.implementation.cache_tag`  ã‚’ç›´æ¥ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/imp.rst:254
msgid ""
"The following functions help interact with the import system's internal "
"locking mechanism.  Locking semantics of imports are an implementation "
"detail which may vary from release to release.  However, Python ensures that"
" circular imports work without any deadlocks."
msgstr ""
"ä»¥ä¸‹ã®é–¢æ•°ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®å†…éƒ¨ãƒ­ãƒƒã‚¯ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã¨ã®ã‚„ã‚Šã¨ã‚Šã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®ãƒ­ãƒƒã‚¯ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã¯ãƒªãƒªãƒ¼ã‚¹æ¯ã«å¤‰ã‚ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹å®Ÿè£…è©³ç´°ã§ã™ã€‚ãŸã ã—ã€Python"
" ã¯å¾ªç’°ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ãªã—ã§å‹•ä½œã™ã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/imp.rst:262
msgid ""
"Return ``True`` if the global import lock is currently held, else ``False``."
" On platforms without threads, always return ``False``."
msgstr ""
"ç¾åœ¨ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ­ãƒƒã‚¯ãŒä¿æŒã•ã‚Œã¦ã„ã‚‹å ´åˆ ``True`` ã‚’è¿”ã—ã€ãã†ã§ãªã‘ã‚Œã° ``False`` "
"ã‚’è¿”ã—ã¾ã™ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰ã®ãªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯å¸¸ã« ``False`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/imp.rst:265
msgid ""
"On platforms with threads, a thread executing an import first holds a global"
" import lock, then sets up a per-module lock for the rest of the import.  "
"This blocks other threads from importing the same module until the original "
"import completes, preventing other threads from seeing incomplete module "
"objects constructed by the original thread.  An exception is made for "
"circular imports, which by construction have to expose an incomplete module "
"object at some point."
msgstr ""
"ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’æŒã¤ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€ã¾ãšã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’å®Ÿè¡Œã™ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ­ãƒƒã‚¯ã‚’ä¿æŒã—ã€æ¬¡ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®æ®‹ã‚Šã®éƒ¨åˆ†ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å˜ä½ã®ãƒ­ãƒƒã‚¯ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŒã˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã®ã‚’ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒå®Œäº†ã™ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã€ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚ˆã£ã¦æ§‹ç¯‰ã•ã‚ŒãŸä¸å®Œå…¨ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¦‹ã¦ã—ã¾ã‚ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚å¾ªç’°ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¯¾ã—ã¦ã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ãã®ã‚ˆã†ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«ã¯ã€ã©ã“ã‹ã®æ™‚ç‚¹ã§ä¸å®Œå…¨ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’éœ²å‡ºã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ãŸã‚ã§ã™ã€‚"

#: ../../library/imp.rst:273 ../../library/imp.rst:293
#: ../../library/imp.rst:306
msgid ""
"The locking scheme has changed to per-module locks for the most part.  A "
"global import lock is kept for some critical tasks, such as initializing the"
" per-module locks."
msgstr ""
"ãƒ­ãƒƒã‚¯ã‚¹ã‚­ãƒ¼ãƒ ã¯ã€å¤§éƒ¨åˆ†ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¯ã®ãƒ­ãƒƒã‚¯ã«å¤‰ã‚ã‚Šã¾ã—ãŸã€‚ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ­ãƒƒã‚¯ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¯ã®ãƒ­ãƒƒã‚¯ã‚’åˆæœŸåŒ–ã™ã‚‹ã‚ˆã†ãªã„ãã¤ã‹ã®ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚¿ã‚¹ã‚¯ã®ãŸã‚ã«ç¶­æŒã•ã‚Œã¾ã™ã€‚"

#: ../../library/imp.rst:283
msgid ""
"Acquire the interpreter's global import lock for the current thread. This "
"lock should be used by import hooks to ensure thread-safety when importing "
"modules."
msgstr ""
"ç¾åœ¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¾ã™ã€‚ã“ã®ãƒ­ãƒƒã‚¯ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹éš›ã«ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•æ€§ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã«ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ•ãƒƒã‚¯ã«ã‚ˆã£ã¦ä½¿ç”¨ã•ã‚Œã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/imp.rst:287
msgid ""
"Once a thread has acquired the import lock, the same thread may acquire it "
"again without blocking; the thread must release it once for each time it has"
" acquired it."
msgstr ""
"ä¸€æ—¦ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ­ãƒƒã‚¯ã‚’å–å¾—ã—ãŸã‚‰ã€ãã®åŒã˜ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã“ã¨ãªããã®ãƒ­ãƒƒã‚¯ã‚’å†åº¦å–å¾—ã§ãã¾ã™ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãƒ­ãƒƒã‚¯ã‚’å–å¾—ã™ã‚‹ã®ã¨åŒã˜ã ã‘è§£æ”¾ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/imp.rst:291
msgid "On platforms without threads, this function does nothing."
msgstr "ã‚¹ãƒ¬ãƒƒãƒ‰ã®ãªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ›ãƒ¼ãƒ ã§ã¯ã“ã®é–¢æ•°ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚"

#: ../../library/imp.rst:303
msgid ""
"Release the interpreter's global import lock. On platforms without threads, "
"this function does nothing."
msgstr "ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã¾ã™ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰ã®ãªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚"

#: ../../library/imp.rst:314
msgid ""
"The following constants with integer values, defined in this module, are "
"used to indicate the search result of :func:`find_module`."
msgstr "æ•´æ•°å€¤ã‚’ã‚‚ã¤æ¬¡ã®å®šæ•°ã¯ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¸­ã§å®šç¾©ã•ã‚Œã¦ãŠã‚Šã€ :func:`find_module` ã®æ¤œç´¢çµæœã‚’è¡¨ã™ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/imp.rst:320
msgid "The module was found as a source file."
msgstr "ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒç™ºè¦‹ã•ã‚ŒãŸã€‚"

#: ../../library/imp.rst:327
msgid "The module was found as a compiled code object file."
msgstr "ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒç™ºè¦‹ã•ã‚ŒãŸã€‚"

#: ../../library/imp.rst:334
msgid "The module was found as dynamically loadable shared library."
msgstr "å‹•çš„ã«ãƒ­ãƒ¼ãƒ‰å¯èƒ½ãªå…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ã—ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒç™ºè¦‹ã•ã‚ŒãŸã€‚"

#: ../../library/imp.rst:341
msgid "The module was found as a package directory."
msgstr "ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ã—ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒç™ºè¦‹ã•ã‚ŒãŸã€‚"

#: ../../library/imp.rst:348
msgid "The module was found as a built-in module."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒçµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã—ã¦ç™ºè¦‹ã•ã‚ŒãŸã€‚"

#: ../../library/imp.rst:355
msgid "The module was found as a frozen module."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ frozen ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã—ã¦ç™ºè¦‹ã•ã‚ŒãŸã€‚"

#: ../../library/imp.rst:362
msgid ""
"The :class:`NullImporter` type is a :pep:`302` import hook that handles non-"
"directory path strings by failing to find any modules.  Calling this type "
"with an existing directory or empty string raises :exc:`ImportError`. "
"Otherwise, a :class:`NullImporter` instance is returned."
msgstr ""
":class:`NullImporter` å‹ã¯ :pep:`302` "
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ•ãƒƒã‚¯ã§ã€ä½•ã‚‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã¨ãã®éãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹æ–‡å­—åˆ—ã‚’å‡¦ç†ã—ã¾ã™ã€‚ã“ã®å‹ã‚’æ—¢å­˜ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚„ç©ºæ–‡å­—åˆ—ã«å¯¾ã—ã¦ã‚³ãƒ¼ãƒ«ã™ã‚‹ã¨"
" :exc:`ImportError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ :class:`NullImporter` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/imp.rst:367
msgid "Instances have only one method:"
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ãŸã£ãŸä¸€ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¡ã¾ã™:"

#: ../../library/imp.rst:371
msgid ""
"This method always returns ``None``, indicating that the requested module "
"could not be found."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¸¸ã« ``None`` ã‚’è¿”ã—ã€è¦æ±‚ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã“ã¨ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/imp.rst:374
msgid ""
"``None`` is inserted into ``sys.path_importer_cache`` instead of an instance"
" of :class:`NullImporter`."
msgstr ""
":class:`NullImporter` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä»£ã‚ã‚Šã« ``None`` ãŒ ``sys.path_importer_cache`` "
"ã«æŒ¿å…¥ã•ã‚Œã¾ã™ã€‚"

#: ../../library/imp.rst:378
msgid "Insert ``None`` into ``sys.path_importer_cache`` instead."
msgstr "ä»£ã‚ã‚Šã« ``None`` ã‚’ ``sys.path_importer_cache`` ã«æŒ¿å…¥ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/imp.rst:385
msgid "Examples"
msgstr "ä½¿ç”¨ä¾‹"

#: ../../library/imp.rst:387
msgid ""
"The following function emulates what was the standard import statement up to"
" Python 1.4 (no hierarchical module names).  (This *implementation* wouldn't"
" work in that version, since :func:`find_module` has been extended and "
":func:`load_module` has been added in 1.4.) ::"
msgstr ""
"æ¬¡ã®é–¢æ•°ã¯ Python 1.4 ã¾ã§ã®æ¨™æº– import æ–‡(éšå±¤çš„ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åãŒãªã„)ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã¾ã™ã€‚ (ã“ã® *å®Ÿè£…* "
"ã¯ãã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯å‹•ä½œã—ãªã„ã§ã—ã‚‡ã†ã€‚ãªãœãªã‚‰ã€ :func:`find_module` ã¯æ‹¡å¼µã•ã‚Œã¦ãŠã‚Šã€ã¾ãŸ "
":func:`load_module` ãŒ 1.4 ã§è¿½åŠ ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚) ::"
