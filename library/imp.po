# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/imp.rst:3
msgid ":mod:`imp` --- Access the :keyword:`import` internals"
msgstr ":mod:`imp` --- :keyword:`import` 内部へアクセスする"

#: ../../library/imp.rst:11
msgid ""
"This module provides an interface to the mechanisms used to implement the :"
"keyword:`import` statement.  It defines the following constants and "
"functions:"
msgstr ""
"このモジュールは :keyword:`import` 文を実装するために使われているメカニズムへ"
"のインターフェイスを提供します。次の定数と関数が定義されています:"

#: ../../library/imp.rst:19
msgid ""
"Return the magic string value used to recognize byte-compiled code files (:"
"file:`.pyc` files).  (This value may be different for each Python version.)"
msgstr ""
"バイトコンパイルされたコードファイル(:file:`.pyc` ファイル)を認識するために使"
"われるマジック文字列値を返します。 (この値は Python の各バージョンで異なりま"
"す。)"

#: ../../library/imp.rst:25
msgid ""
"Return a list of 3-element tuples, each describing a particular type of "
"module. Each triple has the form ``(suffix, mode, type)``, where *suffix* is "
"a string to be appended to the module name to form the filename to search "
"for, *mode* is the mode string to pass to the built-in :func:`open` function "
"to open the file (this can be ``'r'`` for text files or ``'rb'`` for binary "
"files), and *type* is the file type, which has one of the values :const:"
"`PY_SOURCE`, :const:`PY_COMPILED`, or :const:`C_EXTENSION`, described below."
msgstr ""
"3要素のタプルのリストを返します。それぞれのタプルは特定の種類のモジュールを説"
"明しています。各タプルは ``(suffix, mode, type)`` という形式です。ここで、 "
"*suffix* は探すファイル名を作るためにモジュール名に追加する文字列です。その"
"ファイルをオープンするために、 *mode* は組み込み :func:`open` 関数へ渡される"
"モード文字列です (これはテキストファイル対しては ``'r'`` 、バイナリファイルに"
"対しては ``'rb'`` となります)。 *type* はファイル型で、以下で説明する値 :"
"const:`PY_SOURCE`, :const:`PY_COMPILED` あるいは、 :const:`C_EXTENSION` の一"
"つを取ります。"

#: ../../library/imp.rst:37
msgid ""
"Try to find the module *name*.  If *path* is omitted or ``None``, the list "
"of directory names given by ``sys.path`` is searched, but first a few "
"special places are searched: the function tries to find a built-in module "
"with the given name (:const:`C_BUILTIN`), then a frozen module (:const:"
"`PY_FROZEN`), and on some systems some other places are looked in as well "
"(on Windows, it looks in the registry which may point to a specific file)."
msgstr ""
"モジュール *name* を見つけようとします。 *path* が省略されるか ``None`` なら"
"ば、 ``sys.path`` によって与えられるディレクトリ名のリストが検索されます。し"
"かし、最初にいくつか特別な場所を検索します。まず、所定の名前をもつ組み込みモ"
"ジュール(:const:`C_BUILTIN`)を見つけようとします。それから、フリーズされたモ"
"ジュール(:const:`PY_FROZEN`)、そしていくつかのシステムでは他の場所が同様に検"
"索されます (Windowsでは、特定のファイルを指すレジストリの中を見ます)。"

#: ../../library/imp.rst:44
msgid ""
"Otherwise, *path* must be a list of directory names; each directory is "
"searched for files with any of the suffixes returned by :func:`get_suffixes` "
"above.  Invalid names in the list are silently ignored (but all list items "
"must be strings)."
msgstr ""
"それ以外の場合、 *path* はディレクトリ名のリストでなければなりません。上の :"
"func:`get_suffixes` が返す拡張子のいずれかを伴ったファイルを各ディレクトリの"
"中で検索します。リスト内の有効でない名前は黙って無視されます(しかし、すべての"
"リスト項目は文字列でなければなりません)。"

#: ../../library/imp.rst:49
msgid ""
"If search is successful, the return value is a 3-element tuple ``(file, "
"pathname, description)``:"
msgstr ""
"検索が成功すれば、戻り値は3要素のタプル ``(file, pathname, description)`` で"
"す:"

#: ../../library/imp.rst:52
msgid ""
"*file* is an open file object positioned at the beginning, *pathname* is the "
"pathname of the file found, and *description* is a 3-element tuple as "
"contained in the list returned by :func:`get_suffixes` describing the kind "
"of module found."
msgstr ""
"*file* は先頭に位置合わせされたオープンファイルオブジェクトで、 *pathname* は"
"見つかったファイルのパス名です。そして、 *description* は :func:"
"`get_suffixes` が返すリストに含まれているような3要素のタプルで、見つかったモ"
"ジュールの種類を説明しています。"

#: ../../library/imp.rst:57
msgid ""
"If the module does not live in a file, the returned *file* is ``None``, "
"*pathname* is the empty string, and the *description* tuple contains empty "
"strings for its suffix and mode; the module type is indicated as given in "
"parentheses above.  If the search is unsuccessful, :exc:`ImportError` is "
"raised.  Other exceptions indicate problems with the arguments or "
"environment."
msgstr ""
"モジュールがファイルとして存在していなければ、返された *file* は ``None`` "
"で、 *pathname* は空文字列、 *description* タプルはその拡張子とモードに対して"
"空文字列を含みます。モジュール型は上の括弧の中に示されます。検索が失敗すれ"
"ば、 :exc:`ImportError` が発生します。他の例外は引数または環境に問題があるこ"
"とを示唆します。"

#: ../../library/imp.rst:64
msgid ""
"If the module is a package, *file* is ``None``, *pathname* is the package "
"path and the last item in the *description* tuple is :const:`PKG_DIRECTORY`."
msgstr ""
"モジュールがパッケージならば、 *file* は ``None`` で、 *pathname* はパッケー"
"ジのパスで *description* タプルの最後の項目は :const:`PKG_DIRECTORY` です。"

#: ../../library/imp.rst:67
msgid ""
"This function does not handle hierarchical module names (names containing "
"dots).  In order to find *P.M*, that is, submodule *M* of package *P*, use :"
"func:`find_module` and :func:`load_module` to find and load package *P*, and "
"then use :func:`find_module` with the *path* argument set to ``P.__path__``. "
"When *P* itself has a dotted name, apply this recipe recursively."
msgstr ""
"この関数は階層的なモジュール名(ドットを含む名前)を扱いません。 *P.M* 、すなわ"
"ちパッケージ *P* のサブモジュール *M* を見つけるためには、まず :func:"
"`find_module` と :func:`load_module` を使用してパッケージ *P* を見つけてロー"
"ドして、次に ``P.__path__`` を *path* 引数にして :func:`find_module` を呼び出"
"してください。もし *P* 自体がドット付きの名前を持つ場合、このレシピを再帰的に"
"適用してください。"

#: ../../library/imp.rst:78
msgid ""
"Load a module that was previously found by :func:`find_module` (or by an "
"otherwise conducted search yielding compatible results).  This function does "
"more than importing the module: if the module was already imported, it is "
"equivalent to a :func:`reload`!  The *name* argument indicates the full "
"module name (including the package name, if this is a submodule of a "
"package).  The *file* argument is an open file, and *pathname* is the "
"corresponding file name; these can be ``None`` and ``''``, respectively, "
"when the module is a package or not being loaded from a file.  The "
"*description* argument is a tuple, as would be returned by :func:"
"`get_suffixes`, describing what kind of module must be loaded."
msgstr ""
":func:`find_module` を使って(あるいは、互換性のある結果を作り出す検索を行っ"
"て)以前見つけたモジュールをロードします。この関数はモジュールをインポートする"
"という以上のことを行います: モジュールが既にインポートされているならば、 :"
"func:`reload` と同じです! *name* 引数は(これがパッケージのサブモジュールなら"
"ばパッケージ名を含む)完全なモジュール名を示します。 *file* 引数はオープンした"
"ファイルで、 *pathname* は対応するファイル名です。モジュールがパッケージであ"
"るかファイルからロードされようとしていないとき、これらはそれぞれ ``None`` と "
"``''`` であっても構いません。 :func:`get_suffixes` が返すように "
"*description* 引数はタプルで、どの種類のモジュールがロードされなければならな"
"いかを説明するものです。"

#: ../../library/imp.rst:89
msgid ""
"If the load is successful, the return value is the module object; otherwise, "
"an exception (usually :exc:`ImportError`) is raised."
msgstr ""
"ロードが成功したならば、戻り値はモジュールオブジェクトです。そうでなければ、"
"例外(たいていは :exc:`ImportError`)が発生します。"

#: ../../library/imp.rst:92
msgid ""
"**Important:** the caller is responsible for closing the *file* argument, if "
"it was not ``None``, even when an exception is raised.  This is best done "
"using a :keyword:`try` ... :keyword:`finally` statement."
msgstr ""
"**重要:** *file* 引数が ``None`` でなければ、例外が発生した場合でも呼び出し側"
"にはそれを閉じる責任があります。これを行うには、 :keyword:`try` ... :keyword:"
"`finally` 文を使うことが最も良いです。"

#: ../../library/imp.rst:99
msgid ""
"Return a new empty module object called *name*.  This object is *not* "
"inserted in ``sys.modules``."
msgstr ""
"*name* という名前の新しい空モジュールオブジェクトを返します。このオブジェクト"
"は ``sys.modules`` に挿入され *ません* 。"

#: ../../library/imp.rst:105
msgid ""
"Return ``True`` if the import lock is currently held, else ``False``. On "
"platforms without threads, always return ``False``."
msgstr ""
"現在インポートロックが維持されているならば、 ``True`` を返します。そうでなけ"
"れば、 ``False`` を返します。スレッドのないプラットホームでは、常に "
"``False`` を返します。"

#: ../../library/imp.rst:108
msgid ""
"On platforms with threads, a thread executing an import holds an internal "
"lock until the import is complete. This lock blocks other threads from doing "
"an import until the original import completes, which in turn prevents other "
"threads from seeing incomplete module objects constructed by the original "
"thread while in the process of completing its import (and the imports, if "
"any, triggered by that)."
msgstr ""
"スレッドのあるプラットホームでは、インポートが完了するまでインポートを実行す"
"るスレッドは内部ロックを維持します。このロックは元のインポートが完了するまで"
"他のスレッドがインポートすることを阻止します。言い換えると、元のスレッドがそ"
"のインポート(および、もしあるならば、それによって引き起こされるインポート) の"
"途中で構築した不完全なモジュールオブジェクトを、他のスレッドが見られないよう"
"にします。"

#: ../../library/imp.rst:118
msgid ""
"Acquire the interpreter's import lock for the current thread.  This lock "
"should be used by import hooks to ensure thread-safety when importing "
"modules."
msgstr ""
"実行中のスレッドでインタープリタのインポートロックを取得します。インポート"
"フックは、スレッドセーフのためにこのロックを取得しなければなりません。"

#: ../../library/imp.rst:121
msgid ""
"Once a thread has acquired the import lock, the same thread may acquire it "
"again without blocking; the thread must release it once for each time it has "
"acquired it."
msgstr ""
"一旦スレッドがインポートロックを取得したら、その同じスレッドはブロックされる"
"ことなくそのロックを再度取得できます。スレッドはロックを取得するのと同じだけ"
"解放しなければなりません。"

#: ../../library/imp.rst:125
msgid "On platforms without threads, this function does nothing."
msgstr "スレッドのないプラットホームではこの関数は何もしません。"

#: ../../library/imp.rst:132
msgid ""
"Release the interpreter's import lock. On platforms without threads, this "
"function does nothing."
msgstr ""
"インタープリタのインポートロックを解放します。スレッドのないプラットホームで"
"はこの関数は何もしません。"

#: ../../library/imp.rst:137
msgid ""
"The following constants with integer values, defined in this module, are "
"used to indicate the search result of :func:`find_module`."
msgstr ""
"整数値をもつ次の定数はこのモジュールの中で定義されており、 :func:"
"`find_module` の検索結果を表すために使われます。"

#: ../../library/imp.rst:143
msgid "The module was found as a source file."
msgstr "ソースファイルとしてモジュールが発見された。"

#: ../../library/imp.rst:148
msgid "The module was found as a compiled code object file."
msgstr ""
"コンパイルされたコードオブジェクトファイルとしてモジュールが発見された。"

#: ../../library/imp.rst:153
msgid "The module was found as dynamically loadable shared library."
msgstr "動的にロード可能な共有ライブラリとしてモジュールが発見された。"

#: ../../library/imp.rst:158
msgid "The module was found as a package directory."
msgstr "パッケージディレクトリとしてモジュールが発見された。"

#: ../../library/imp.rst:163
msgid "The module was found as a built-in module."
msgstr "モジュールが組み込みモジュールとして発見された。"

#: ../../library/imp.rst:168
msgid "The module was found as a frozen module (see :func:`init_frozen`)."
msgstr ""
"モジュールがフリーズされたモジュールとして発見された(:func:`init_frozen` を参"
"照)。"

#: ../../library/imp.rst:170
msgid ""
"The following constant and functions are obsolete; their functionality is "
"available through :func:`find_module` or :func:`load_module`. They are kept "
"around for backward compatibility:"
msgstr ""
"以下の定数と関数は旧バージョンのものです。 :func:`find_module` や :func:"
"`load_module` を使えば同様の機能を利用できます。これらは後方互換性のために残"
"されています:"

#: ../../library/imp.rst:177
msgid "Unused."
msgstr "使われていません。"

#: ../../library/imp.rst:182
msgid ""
"Initialize the built-in module called *name* and return its module object "
"along with storing it in ``sys.modules``.  If the module was already "
"initialized, it will be initialized *again*.  Re-initialization involves the "
"copying of the built-in module's ``__dict__`` from the cached module over "
"the module's entry in ``sys.modules``.  If there is no built-in module "
"called *name*, ``None`` is returned."
msgstr ""
"*name* という名前の組み込みモジュールを初期化し、そのモジュールオブジェクト"
"を ``sys.modules`` に格納した上で返します。モジュールが既に初期化されている場"
"合は、 *再度* 初期化されます。再初期化は組み込みモジュールの ``__dict__`` を "
"``sys.modules`` のエントリーに結びつけられたキャッシュモジュールからコピーす"
"る過程を含みます。 *name* という名前の組み込みモジュールがない場合は、 "
"``None`` を返します。"

#: ../../library/imp.rst:192
msgid ""
"Initialize the frozen module called *name* and return its module object.  If "
"the module was already initialized, it will be initialized *again*.  If "
"there is no frozen module called *name*, ``None`` is returned.  (Frozen "
"modules are modules written in Python whose compiled byte-code object is "
"incorporated into a custom-built Python interpreter by Python's :program:"
"`freeze` utility. See :file:`Tools/freeze/` for now.)"
msgstr ""
"*name* という名前のフリーズされたモジュールを初期化し、モジュールオブジェクト"
"を返します。モジュールが既に初期化されている場合は、 *再度* 初期化されます。 "
"*name* という名前のフリーズされたモジュールがない場合は、 ``None`` を返しま"
"す。 (フリーズされたモジュールは Python で書かれたモジュールで、そのコンパイ"
"ルされたバイトコードオブジェクトが Python の :program:`freeze` ユーティリティ"
"を使ってカスタムビルド版の Python インタープリタへ組み込まれています。差し当"
"たり、 :file:`Tools/freeze/` を参照してください。)"

#: ../../library/imp.rst:202
msgid ""
"Return ``1`` if there is a built-in module called *name* which can be "
"initialized again.  Return ``-1`` if there is a built-in module called "
"*name* which cannot be initialized again (see :func:`init_builtin`).  Return "
"``0`` if there is no built-in module called *name*."
msgstr ""
"*name* という名前の再初期化できる組み込みモジュールがある場合は、 ``1`` を返"
"します。 *name* という名前の再初期化できない組み込みモジュールがある場合は、 "
"``-1`` を返します (:func:`init_builtin` を参照してください)。 *name* という名"
"前の組み込みモジュールがない場合は、 ``0`` を返します。"

#: ../../library/imp.rst:210
msgid ""
"Return ``True`` if there is a frozen module (see :func:`init_frozen`) called "
"*name*, or ``False`` if there is no such module."
msgstr ""
"*name* という名前のフリーズされたモジュール(:func:`init_frozen` を参照)がある"
"場合は、 ``True`` を返します。または、そのようなモジュールがない場合は、 "
"``False`` を返します。"

#: ../../library/imp.rst:218
msgid ""
"Load and initialize a module implemented as a byte-compiled code file and "
"return its module object.  If the module was already initialized, it will be "
"initialized *again*.  The *name* argument is used to create or access a "
"module object.  The *pathname* argument points to the byte-compiled code "
"file.  The *file* argument is the byte-compiled code file, open for reading "
"in binary mode, from the beginning. It must currently be a real file object, "
"not a user-defined class emulating a file."
msgstr ""
"バイトコンパイルされたコードファイルとして実装されているモジュールをロードし"
"て初期化し、そのモジュールオブジェクトを返します。モジュールが既に初期化され"
"ている場合は、 *再度* 初期化されます。 *name* 引数はモジュールオブジェクトを"
"作ったり、アクセスするために使います。 *pathname* 引数はバイトコンパイルされ"
"たコードファイルを指します。 *file* 引数はバイトコンパイルされたコードファイ"
"ルで、バイナリモードでオープンされ、先頭からアクセスされます。現在は、ユーザ"
"定義のファイルをエミュレートするクラスではなく、実際のファイルオブジェクトで"
"なければなりません。"

#: ../../library/imp.rst:229
msgid ""
"Load and initialize a module implemented as a dynamically loadable shared "
"library and return its module object.  If the module was already "
"initialized, it will be initialized *again*. Re-initialization involves "
"copying the ``__dict__`` attribute of the cached instance of the module over "
"the value used in the module cached in ``sys.modules``.  The *pathname* "
"argument must point to the shared library.  The *name* argument is used to "
"construct the name of the initialization function: an external C function "
"called ``initname()`` in the shared library is called.  The optional *file* "
"argument is ignored.  (Note: using shared libraries is highly system "
"dependent, and not all systems support it.)"
msgstr ""
"動的ロード可能な共有ライブラリとして実装されているモジュールをロードして初期"
"化します。モジュールが既に初期化されている場合は、 *再度* 初期化します。再初"
"期化はモジュールのキャッシュされたインスタンスの ``__dict__`` 属性を ``sys."
"modules`` にキャッシュされたモジュールの中で使われた値に上書きコピーする過程"
"を含みます。 *pathname* 引数は共有ライブラリを指していなければなりません。 "
"*name* 引数は初期化関数の名前を作るために使われます。共有ライブラリの "
"``initname()`` という名前の外部C関数が呼び出されます。オプションの *file* 引"
"数は無視されます。 (注意: 共有ライブラリはシステムに大きく依存します。また、"
"すべてのシステムがサポートしているわけではありません。)"

#: ../../library/imp.rst:242
msgid ""
"The import internals identify extension modules by filename, so doing ``foo "
"= load_dynamic(\"foo\", \"mod.so\")`` and ``bar = load_dynamic(\"bar\", "
"\"mod.so\")`` will result in both foo and bar referring to the same module, "
"regardless of whether or not ``mod.so`` exports an ``initbar`` function. On "
"systems which support them, symlinks can be used to import multiple modules "
"from the same shared library, as each reference to the module will use a "
"different file name."
msgstr ""
"インポートの内部処理は拡張モジュールをファイル名で識別します。ですから ``foo "
"= load_dynamic(\"foo\", \"mod.so\")`` と ``bar = load_dynamic(\"bar\", \"mod."
"so\")`` では foo と bar のどちらも同じモジュールを参照します。 ``mod.so`` が "
"``initbar`` 関数を公開しているかどうかに無関係にです。シンボリックリンクをサ"
"ポートするシステムでも、それをすると、各々のモジュール参照が異なったファイル"
"名を使って同じ共有ライブラリからの多重インポートになりえます。"

#: ../../library/imp.rst:254
msgid ""
"Load and initialize a module implemented as a Python source file and return "
"its module object.  If the module was already initialized, it will be "
"initialized *again*.  The *name* argument is used to create or access a "
"module object.  The *pathname* argument points to the source file.  The "
"*file* argument is the source file, open for reading as text, from the "
"beginning. It must currently be a real file object, not a user-defined class "
"emulating a file.  Note that if a properly matching byte-compiled file (with "
"suffix :file:`.pyc` or :file:`.pyo`) exists, it will be used instead of "
"parsing the given source file."
msgstr ""
"Python ソースファイルとして実装されているモジュールをロードして初期化し、モ"
"ジュールオブジェクトを返します。モジュールが既に初期化されている場合は、 *再"
"度* 初期化します。 *name* 引数はモジュールオブジェクトを作成したり、アクセス"
"したりするために使われます。 *pathname* 引数はソースファイルを指します。 "
"*file* 引数はソースファイルで、テキストとして読み込むためにオープンされ、先頭"
"からアクセスされます。現在は、ユーザ定義のファイルをエミュレートするクラスで"
"はなく、実際のファイルオブジェクトでなければなりません。 (拡張子 :file:`."
"pyc` または :file:`.pyo` をもつ)正しく対応するバイトコンパイルされたファイル"
"が存在する場合は、与えられたソースファイルを構文解析する代わりにそれが使われ"
"ることに注意してください。"

#: ../../library/imp.rst:266
msgid ""
"The :class:`NullImporter` type is a :pep:`302` import hook that handles non-"
"directory path strings by failing to find any modules.  Calling this type "
"with an existing directory or empty string raises :exc:`ImportError`. "
"Otherwise, a :class:`NullImporter` instance is returned."
msgstr ""
":class:`NullImporter` 型は :pep:`302` インポートフックで、何もモジュールが見"
"つからなかったときの非ディレクトリパス文字列を処理します。この型を既存のディ"
"レクトリや空文字列に対してコールすると :exc:`ImportError` が発生します。それ"
"以外の場合は :class:`NullImporter` のインスタンスが返されます。"

#: ../../library/imp.rst:271
msgid ""
"Python adds instances of this type to ``sys.path_importer_cache`` for any "
"path entries that are not directories and are not handled by any other path "
"hooks on ``sys.path_hooks``.  Instances have only one method:"
msgstr ""
"Python は、ディレクトリでなく ``sys.path_hooks`` のどのパスフックでも処理され"
"ていないすべてのパスエントリに対して、この型のインスタンスを ``sys."
"path_importer_cache`` に追加します。このインスタンスが持つメソッドは次のひと"
"つです。"

#: ../../library/imp.rst:278
msgid ""
"This method always returns ``None``, indicating that the requested module "
"could not be found."
msgstr ""
"このメソッドは常に ``None`` を返し、要求されたモジュールが見つからなかったこ"
"とを表します。"

#: ../../library/imp.rst:287
msgid "Examples"
msgstr "例"

#: ../../library/imp.rst:289
msgid ""
"The following function emulates what was the standard import statement up to "
"Python 1.4 (no hierarchical module names).  (This *implementation* wouldn't "
"work in that version, since :func:`find_module` has been extended and :func:"
"`load_module` has been added in 1.4.) ::"
msgstr ""
"次の関数は Python 1.4 までの標準 import 文(階層的なモジュール名がない)をエ"
"ミュレートします。 (この *実装* はそのバージョンでは動作しないでしょう。なぜ"
"なら、 :func:`find_module` は拡張されており、また :func:`load_module` が 1.4 "
"で追加されているからです。) ::"

#: ../../library/imp.rst:320
msgid ""
"A more complete example that implements hierarchical module names and "
"includes a :func:`reload` function can be found in the module :mod:`knee`.  "
"The :mod:`knee` module can be found in :file:`Demo/imputil/` in the Python "
"source distribution."
msgstr ""
"階層的なモジュール名を実装し、 :func:`reload` 関数を含むより完全な例はモ"
"ジュール :mod:`knee` にあります。 :mod:`knee` モジュールは Python のソース"
"ディストリビューションの中の :file:`Demo/imputil/` にあります。"
