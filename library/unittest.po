# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Yusuke Miyazaki <miyazaki.dev@gmail.com>, 2021
# tomo, 2021
# Osamu NAKAMURA, 2021
# Atsuo Ishimoto <atsuoishimoto@gmail.com>, 2022
# 秘湯 <xwhhsprings@gmail.com>, 2022
# yuta100101 <yuta07317776@i.softbank.jp>, 2022
# Takanori Suzuki <takanori@takanory.net>, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-24 14:15+0000\n"
"PO-Revision-Date: 2021-06-28 01:16+0000\n"
"Last-Translator: Takanori Suzuki <takanori@takanory.net>, 2023\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/unittest.rst:2
msgid ":mod:`unittest` --- Unit testing framework"
msgstr ":mod:`unittest` --- ユニットテストフレームワーク"

#: ../../library/unittest.rst:12
msgid "**Source code:** :source:`Lib/unittest/__init__.py`"
msgstr "**ソースコード:** :source:`Lib/unittest/__init__.py`"

#: ../../library/unittest.rst:16
msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""
"(すでにテストの基本概念について詳しいようでしたら、この部分をとばして :ref:`"
"アサートメソッド一覧 <assert-methods>` に進むと良いでしょう。)"

#: ../../library/unittest.rst:19
msgid ""
"The :mod:`unittest` unit testing framework was originally inspired by JUnit "
"and has a similar flavor as major unit testing frameworks in other "
"languages.  It supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework."
msgstr ""
":mod:`unittest` ユニットテストフレームワークは元々 JUnit に触発されたもの"
"で、\n"
"他の言語の主要なユニットテストフレームワークと同じような感じです。\n"
"テストの自動化、テスト用のセットアップやシャットダウンのコードの共有、テスト"
"のコレクション化、そして報告フレームワークからのテストの独立性をサポートして"
"います。"

#: ../../library/unittest.rst:25
msgid ""
"To achieve this, :mod:`unittest` supports some important concepts in an "
"object-oriented way:"
msgstr ""
"これを実現するために、 :mod:`unittest` はいくつかの重要な概念をオブジェクト指"
"向の方法でサポートしています:"

#: ../../library/unittest.rst:32
msgid "test fixture"
msgstr "テストフィクスチャ (test fixture)"

#: ../../library/unittest.rst:29
msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associated cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""
"テストフィクスチャ (:dfn:`test fixture`) とは、テスト実行のために必要な準備や"
"終了処理を指します。例: テスト用データベースの作成・ディレクトリ・サーバプロ"
"セスの起動など。"

#: ../../library/unittest.rst:37
msgid "test case"
msgstr "テストケース (test case)"

#: ../../library/unittest.rst:35
msgid ""
"A :dfn:`test case` is the individual unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a "
"base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""
"テストケース (:dfn:`test case`) はテストの独立した単位で、各入力に対する結果"
"をチェックします。テストケースを作成する場合は、 :mod:`unittest` が提供する :"
"class:`TestCase` クラスを基底クラスとして利用することができます。"

#: ../../library/unittest.rst:41
msgid "test suite"
msgstr "テストスイート (test suite)"

#: ../../library/unittest.rst:40
msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It "
"is used to aggregate tests that should be executed together."
msgstr ""
"テストスイート (:dfn:`test suite`) はテストケースとテストスイートの集まりで、"
"同時に実行しなければならないテストをまとめる場合に使用します。"

#: ../../library/unittest.rst:48
msgid "test runner"
msgstr "テストランナー (test runner)"

#: ../../library/unittest.rst:44
msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""
"テストランナー (:dfn:`test runner`) はテストの実行を管理し結果を提供する要素"
"です。ランナーはグラフィカルインターフェースやテキストインターフェースを使用"
"しても構いませんし、テストの実行結果を示す特別な値を返しても構いません。"

#: ../../library/unittest.rst:53
msgid "Module :mod:`doctest`"
msgstr ":mod:`doctest` モジュール"

#: ../../library/unittest.rst:53
msgid "Another test-support module with a very different flavor."
msgstr ""
"テストをサポートするもうひとつのモジュールで、このモジュールとは趣きがだいぶ"
"異なります。"

#: ../../library/unittest.rst:57
msgid ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

#: ../../library/unittest.rst:56
msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared "
"by :mod:`unittest`."
msgstr ""
"Kent Beck のテスティングフレームワークに関する原論文で、ここに記載されたパ"
"ターンを :mod:`unittest` が使用しています。"

#: ../../library/unittest.rst:61
msgid "`pytest <https://docs.pytest.org/>`_"
msgstr "`pytest <https://docs.pytest.org/>`_"

#: ../../library/unittest.rst:60
msgid ""
"Third-party unittest framework with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""
"サードパーティのユニットテストフレームワークでより軽量な構文でテストを書くこ"
"とができます。例えば、``assert func(10) == 42``  のように書きます。"

#: ../../library/unittest.rst:65
msgid ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"
msgstr ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"

#: ../../library/unittest.rst:64
msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr ""
"多くの Python のテストツールが一覧で紹介されています。ファンクショナルテスト"
"のフレームワークやモックライブラリも掲載されています。"

#: ../../library/unittest.rst:69
msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr ""
"`Testing in Python メーリングリスト <http://lists.idyll.org/listinfo/testing-"
"in-python>`_"

#: ../../library/unittest.rst:68
msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr "Python でテストやテストツールについての議論に特化したグループです。"

#: ../../library/unittest.rst:71
msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot <https://buildbot.net/>`_, "
"`Jenkins <https://jenkins.io/>`_, `GitHub Actions <https://github.com/"
"features/actions>`_, or `AppVeyor <https://www.appveyor.com/>`_."
msgstr ""
"Python のソースコード配布物にあるスクリプト :file:`Tools/unittestgui/"
"unittestgui.py` はテストディスカバリとテスト実行のための GUI ツールです。\n"
"主な目的は単体テストの初心者が簡単に使えるようにすることです。\n"
"実際の生産環境では、 `Buildbot <https://buildbot.net/>`_, `Jenkins <https://"
"jenkins.io/>`_ 、 `GitHub Actions <https://github.com/features/actions>`_, "
"`AppVeyor <https://www.appveyor.com/>`_ のような継続的インテグレーションシス"
"テムでテストを実行することを推奨します。"

#: ../../library/unittest.rst:83
msgid "Basic example"
msgstr "基本的な例"

#: ../../library/unittest.rst:85
msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and "
"running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ""
":mod:`unittest` モジュールには、テストの開発や実行の為の優れたツールが用意さ"
"れており、この節では、その一部を紹介します。ほとんどのユーザとっては、ここで"
"紹介するツールだけで十分でしょう。"

#: ../../library/unittest.rst:89
msgid "Here is a short script to test three string methods::"
msgstr "以下は、三つの文字列メソッドをテストするスクリプトです::"

#: ../../library/unittest.rst:113
msgid ""
"A testcase is created by subclassing :class:`unittest.TestCase`.  The three "
"individual tests are defined with methods whose names start with the letters "
"``test``.  This naming convention informs the test runner about which "
"methods represent tests."
msgstr ""
"テストケースは、 :class:`unittest.TestCase` のサブクラスとして作成します。メ"
"ソッド名が ``test`` で始まる三つのメソッドがテストです。テストランナーはこの"
"命名規約によってテストを行うメソッドを検索します。"

#: ../../library/unittest.rst:118
msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` or :meth:`~TestCase."
"assertFalse` to verify a condition; or :meth:`~TestCase.assertRaises` to "
"verify that a specific exception gets raised.  These methods are used "
"instead of the :keyword:`assert` statement so the test runner can accumulate "
"all test results and produce a report."
msgstr ""
"これらのテスト内では、予定の結果が得られていることを確かめるために :meth:"
"`~TestCase.assertEqual` を、条件のチェックに :meth:`~TestCase.assertTrue` "
"や :meth:`~TestCase.assertFalse` を、例外が発生する事を確認するために :meth:"
"`~TestCase.assertRaises` をそれぞれ呼び出しています。 :keyword:`assert` 文の"
"代わりにこれらのメソッドを使用すると、テストランナーでテスト結果を集計してレ"
"ポートを作成する事ができます。"

#: ../../library/unittest.rst:125
msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you "
"to define instructions that will be executed before and after each test "
"method. They are covered in more detail in the section :ref:`organizing-"
"tests`."
msgstr ""
":meth:`~TestCase.setUp` および :meth:`~TestCase.tearDown` メソッドによって各"
"テストメソッドの前後に実行する命令を実装することが出来ます。\n"
"詳細は :ref:`organizing-tests` を参照してください。"

#: ../../library/unittest.rst:129
msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""
"最後のブロックは簡単なテストの実行方法を示しています。 :func:`unittest.main` "
"は、テストスクリプトのコマンドライン用インターフェースを提供します。コマンド"
"ラインから起動された場合、上記のスクリプトは以下のような結果を出力します::"

#: ../../library/unittest.rst:139
msgid ""
"Passing the ``-v`` option to your test script will instruct :func:`unittest."
"main` to enable a higher level of verbosity, and produce the following "
"output::"
msgstr ""
"``-v`` オプションをテストスクリプトに渡すことで :func:`unittest.main` はより"
"冗長になり、以下のような出力をします::"

#: ../../library/unittest.rst:151
msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr ""
"上の例が :mod:`unittest` モジュールで最もよく使われる機能で、ほとんどのテスト"
"ではこれで十分です。以下では全ての機能を一から解説しています。"

#: ../../library/unittest.rst:155
msgid ""
"The behavior of returning a value from a test method (other than the default "
"``None`` value), is now deprecated."
msgstr ""
"テストメソッドが（デフォルトの``None``以外の）戻り値を返す挙動は現在非推奨で"
"す。"

#: ../../library/unittest.rst:163
msgid "Command-Line Interface"
msgstr "コマンドラインインターフェイス"

#: ../../library/unittest.rst:165
msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr ""
"ユニットテストモジュールはコマンドラインから使って、モジュール、クラス、ある"
"いは個別のテストメソッドで定義されたテストを実行することが出来ます::"

#: ../../library/unittest.rst:172
msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr ""
"モジュール名ならびに完全修飾されたクラス名やメソッド名の任意の組み合わせを一"
"覧で渡すことが出来ます。"

#: ../../library/unittest.rst:175
msgid "Test modules can be specified by file path as well::"
msgstr "テストモジュールはファイルパスで指定することも出来ます::"

#: ../../library/unittest.rst:179
msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path is "
"converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""
"そのため、テストモジュールを指定するのにシェルのファイル名補完が使えます。指"
"定されたファイルはやはりモジュールとしてインポート可能でなければなりません。"
"パスから '.py' を取り除き、パスセパレータを '.' に置き換えることでモジュール"
"名に変換されます。モジュールとしてインポート可能でないテストファイルを実行し"
"たい場合は、代わりにそのファイルを直接実行するのが良いでしょう。"

#: ../../library/unittest.rst:185
msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr "テスト実行時に (より冗長な) 詳細を表示するには -v フラグを渡します::"

#: ../../library/unittest.rst:189
msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is started::"
msgstr "引数無しで実行すると :ref:`unittest-test-discovery` が開始されます::"

#: ../../library/unittest.rst:193
msgid "For a list of all the command-line options::"
msgstr "コマンドラインプションの一覧を表示するには以下のコマンドを実行します::"

#: ../../library/unittest.rst:197
msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr ""
"以前のバージョンでは、個々のテストメソッドしか実行することができず、モジュー"
"ル単位やクラス単位で実行することは不可能でした。"

#: ../../library/unittest.rst:203
msgid "Command-line options"
msgstr "コマンドラインオプション"

#: ../../library/unittest.rst:205
msgid ":program:`unittest` supports these command-line options:"
msgstr ":program:`unittest` には以下のコマンドラインオプションがあります:"

#: ../../library/unittest.rst:211
msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on "
"test fail or error and is added to the failure messages."
msgstr ""
"標準出力と標準エラーのストリームをテストの実行中にバッファします。テストが成"
"功している間は結果の出力は破棄されます。テストの失敗やエラーの場合、出力は通"
"常通り表示され、エラーメッセージに追加されます。"

#: ../../library/unittest.rst:217
msgid ""
":kbd:`Control-C` during the test run waits for the current test to end and "
"then reports all the results so far. A second :kbd:`Control-C` raises the "
"normal :exc:`KeyboardInterrupt` exception."
msgstr ""
":kbd:`Control-C` を実行中のテストが終了するまで遅延させ、そこまでの結果を出力"
"します。二回目の :kbd:`Control-C` は、通常通り :exc:`KeyboardInterrupt` の例"
"外を発生させます。"

#: ../../library/unittest.rst:221
msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr ""
"この機能の仕組みについては、`シグナルハンドリング`_ を参照してください。"

#: ../../library/unittest.rst:225
msgid "Stop the test run on the first error or failure."
msgstr "初回のエラーもしくは失敗の時にテストを停止します。"

#: ../../library/unittest.rst:229
msgid ""
"Only run test methods and classes that match the pattern or substring. This "
"option may be used multiple times, in which case all test cases that match "
"any of the given patterns are included."
msgstr ""
"パターンや部分文字列にマッチするテストメソッドとテストクラスのみ実行します。"
"このオプションは複数回使うことができ、その場合はすべてのパターンにマッチする"
"テストケースが実行対象に含まれます。"

#: ../../library/unittest.rst:233
msgid ""
"Patterns that contain a wildcard character (``*``) are matched against the "
"test name using :meth:`fnmatch.fnmatchcase`; otherwise simple case-sensitive "
"substring matching is used."
msgstr ""
"ワイルドカード(``*``) を含むパターンは :meth:`fnmatch.fnmatchcase` を使用して"
"テスト名と照合され、それ以外の場合は単純な大文字と小文字を区別した部分文字列"
"マッチングが使用されます。"

#: ../../library/unittest.rst:237
msgid ""
"Patterns are matched against the fully qualified test method name as "
"imported by the test loader."
msgstr ""
"パターンは、テストローダがインポートする時の完全修飾されたテストメソッド名と"
"照合されます。"

#: ../../library/unittest.rst:240
msgid ""
"For example, ``-k foo`` matches ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, but not ``bar_tests.FooTest."
"test_something``."
msgstr ""
"たとえば、 ``-k foo`` は ``foo_tests.SomeTest.test_something``, ``bar_tests."
"SomeTest.test_foo`` にマッチし、 ``bar_tests.FooTest.test_something`` はマッ"
"チしません。"

#: ../../library/unittest.rst:245
msgid "Show local variables in tracebacks."
msgstr "トレースバック内の局所変数を表示します。"

#: ../../library/unittest.rst:247
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr "コマンドラインオプションの ``-b``、``-c``、``-f`` が追加されました。"

#: ../../library/unittest.rst:250
msgid "The command-line option ``--locals``."
msgstr "コマンドラインオプション ``--locals``。"

#: ../../library/unittest.rst:253
msgid "The command-line option ``-k``."
msgstr "コマンドラインオプション ``-k``。"

#: ../../library/unittest.rst:256
msgid ""
"The command line can also be used for test discovery, for running all of the "
"tests in a project or just a subset."
msgstr ""
"コマンドラインによってテストディスカバリ、すなわちプロジェクトの全テストを実"
"行したりサブセットのみを実行したりすることも出来ます。"

#: ../../library/unittest.rst:263
msgid "Test Discovery"
msgstr "テストディスカバリ"

#: ../../library/unittest.rst:267
msgid ""
"Unittest supports simple test discovery. In order to be compatible with test "
"discovery, all of the test files must be :ref:`modules <tut-modules>` or :"
"ref:`packages <tut-packages>` importable from the top-level directory of the "
"project (this means that their filenames must be valid :ref:`identifiers "
"<identifiers>`)."
msgstr ""
"unittest はシンプルなテストディスカバリをサポートします。このテストディスカバ"
"リに対応するために、テストが定義された全ファイルは :ref:`modules <tut-"
"modules>` もしくは :ref:`packages <tut-packages>` としてプロジェクトの最上位"
"のディスカバリでインポート可能である必要があります (つまり、これらのファイル"
"は :ref:`identifiers <identifiers>` として有効である必要があるということで"
"す)。"

#: ../../library/unittest.rst:273
msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr ""
"テストディスカバリは :meth:`TestLoader.discover` で実装されていますが、コマン"
"ドラインから使う事も出来ます。その基本的な使い方は::"

#: ../../library/unittest.rst:281
msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""
"``python -m unittest`` は ``python -m unittest discover`` と等価なショート"
"カットです。テストディスカバリに引数を渡したい場合は、``discover`` サブコマン"
"ドを明示的に使用しなければなりません。"

#: ../../library/unittest.rst:285
msgid "The ``discover`` sub-command has the following options:"
msgstr "``discover`` サブコマンドには以下のオプションがあります:"

#: ../../library/unittest.rst:291
msgid "Verbose output"
msgstr "詳細な出力"

#: ../../library/unittest.rst:295
msgid "Directory to start discovery (``.`` default)"
msgstr "ディスカバリを開始するディレクトリ (デフォルトは ``.``)"

#: ../../library/unittest.rst:299
msgid "Pattern to match test files (``test*.py`` default)"
msgstr "テストファイル名を識別するパターン (デフォルトは ``test*.py``)"

#: ../../library/unittest.rst:303
msgid "Top level directory of project (defaults to start directory)"
msgstr ""
"プロジェクトの最上位のディスカバリのディレクトリ (デフォルトは開始のディレク"
"トリ)"

#: ../../library/unittest.rst:305
msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as "
"positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ""
":option:`-s` 、 :option:`-p` 、および :option:`-t` オプションは、この順番であ"
"れば位置引数として渡す事ができます。以下の二つのコマンドは等価です::"

#: ../../library/unittest.rst:312
msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used "
"as the start directory."
msgstr ""
"パスと同様にパッケージ名を、例えば ``myproject.subpackage.test`` のように、開"
"始ディレクトリとして渡すことができます。\n"
"指定したパッケージ名はインポートされ、そのファイルシステム上の場所が開始ディ"
"レクトリとして使われます。"

#: ../../library/unittest.rst:319
msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""
"テストディスカバリはインポートによりテストを読み込みます。\n"
"一旦テストディスカバリが指定された開始ディレクトリから全テストファイルを見付"
"けると、パスはインポートするパッケージ名に変換されます。\n"
"例えば、 :file:`foo/bar/baz.py` は ``foo.bar.baz`` としてインポートされます。"

#: ../../library/unittest.rst:324
msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr ""
"グローバルにインストールされたパッケージがあり、それとは異なるコピーでディス"
"カバリしようとしたとき、誤った場所からインポートが行われる *かもしれません"
"*。\n"
"その場合テストディスカバリは警告し、停止します。"

#: ../../library/unittest.rst:328
msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr ""
"ディレクトリのパスではなくパッケージ名を開始ディレクトリに指定した場合、ディ"
"スカバリはインポートするいずれの場所も意図した場所とするため、警告を受けない"
"はずです。"

#: ../../library/unittest.rst:333
msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr ""
"テストモジュールとパッケージは、 `load_tests プロトコル`_ によってテストの"
"ロードとディスカバリをカスタマイズすることができます。"

#: ../../library/unittest.rst:336
msgid ""
"Test discovery supports :term:`namespace packages <namespace package>` for "
"the start directory. Note that you need to specify the top level directory "
"too (e.g. ``python -m unittest discover -s root/namespace -t root``)."
msgstr ""
"テストディスカバリは開始ディレクトリとして :term:`名前空間パッケージ "
"<namespace package>` をサポートします。トップレベルのディレクトリも指定する必"
"要があることに注意してください(例えば ``python -m unittest discover -s root/"
"namespace -t root``)。"

#: ../../library/unittest.rst:342
msgid ""
"Python 3.11 dropped the :term:`namespace packages <namespace package>` "
"support. It has been broken since Python 3.7. Start directory and "
"subdirectories containing tests must be regular package that have ``__init__."
"py`` file."
msgstr ""

#: ../../library/unittest.rst:348
msgid ""
"Directories containing start directory still can be a namespace package. In "
"this case, you need to specify start directory as dotted package name, and "
"target directory explicitly. For example::"
msgstr ""

#: ../../library/unittest.rst:364
msgid "Organizing test code"
msgstr "テストコードの構成"

#: ../../library/unittest.rst:366
msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In :mod:"
"`unittest`, test cases are represented by :class:`unittest.TestCase` "
"instances. To make your own test cases you must write subclasses of :class:"
"`TestCase` or use :class:`FunctionTestCase`."
msgstr ""
"ユニットテストの基本的な構成要素は、 :dfn:`テストケース` --- 設定され正しさの"
"ためにチェックされるべき単独のシナリオ --- です。\n"
":mod:`unittest` では、テストケースは :class:`unittest.TestCase` クラスのイン"
"スタンスで表現されます。\n"
"独自のテストケースを作成するには :class:`TestCase` のサブクラスを記述する"
"か、 :class:`FunctionTestCase` を使用しなければなりません。"

#: ../../library/unittest.rst:372
msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ""
":class:`TestCase` インスタンスのテストコードは完全に独立していなければなりま"
"せん。\n"
"すなわち単独でか、他の様々なテストケースの任意の組み合わせのいずれかで実行可"
"能でなければなりません。"

#: ../../library/unittest.rst:376
msgid ""
"The simplest :class:`TestCase` subclass will simply implement a test method "
"(i.e. a method whose name starts with ``test``) in order to perform specific "
"testing code::"
msgstr ""
"最も単純な :class:`TestCase` のサブクラスは、特定のテストコードを実行するため"
"のテストメソッド (すなわち名前が ``test`` で始まるメソッド) を実装するだけで"
"簡単に書くことができます::"

#: ../../library/unittest.rst:387
msgid ""
"Note that in order to test something, we use one of the :meth:`assert\\*` "
"methods provided by the :class:`TestCase` base class.  If the test fails, an "
"exception will be raised with an explanatory message, and :mod:`unittest` "
"will identify the test case as a :dfn:`failure`.  Any other exceptions will "
"be treated as :dfn:`errors`."
msgstr ""
"何らかのテストを行うには、 :class:`TestCase` ベースクラスが提供する :meth:"
"`assert\\*` メソッドのうちの一つを使用してください。\n"
"テストが失敗した場合は、例外が説明のメッセージとともに送出され、 :mod:"
"`unittest` はテスト結果を :dfn:`failure` とします。\n"
"その他の例外は :dfn:`error` として扱われます。"

#: ../../library/unittest.rst:393
msgid ""
"Tests can be numerous, and their set-up can be repetitive.  Luckily, we can "
"factor out set-up code by implementing a method called :meth:`~TestCase."
"setUp`, which the testing framework will automatically call for every single "
"test we run::"
msgstr ""
"テストは多くなり、それらの設定は繰り返しになるかもしれません。\n"
"幸いにも、:meth:`~TestCase.setUp` メソッドを実装することで設定コードをくくり"
"出すことができます。\n"
"テストフレームワークは実行するテストごとに自動的に :meth:`~TestCase.setUp` を"
"呼びます::"

#: ../../library/unittest.rst:414
msgid ""
"The order in which the various tests will be run is determined by sorting "
"the test method names with respect to the built-in ordering for strings."
msgstr ""
"いろいろなテストが実行される順序は、文字列の組み込みの順序でテストメソッド名"
"をソートすることで決まります。"

#: ../../library/unittest.rst:418
msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and "
"the test method will not be executed."
msgstr ""
"テスト中に :meth:`~TestCase.setUp` メソッドで例外が発生した場合、フレームワー"
"クはそのテストに問題があるとみなし、そのテストメソッドは実行されません。"

#: ../../library/unittest.rst:422
msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up "
"after the test method has been run::"
msgstr ""
"同様に、テストメソッド実行後に片付けをする :meth:`~TestCase.tearDown` メソッ"
"ドを提供出来ます::"

#: ../../library/unittest.rst:434
msgid ""
"If :meth:`~TestCase.setUp` succeeded, :meth:`~TestCase.tearDown` will be run "
"whether the test method succeeded or not."
msgstr ""
":meth:`~TestCase.setUp` が成功した場合、テストメソッドが成功したかどうかに関"
"わらず :meth:`~TestCase.tearDown` が実行されます。"

#: ../../library/unittest.rst:437
msgid ""
"Such a working environment for the testing code is called a :dfn:`test "
"fixture`.  A new TestCase instance is created as a unique test fixture used "
"to execute each individual test method.  Thus :meth:`~TestCase.setUp`, :meth:"
"`~TestCase.tearDown`, and :meth:`~TestCase.__init__` will be called once per "
"test."
msgstr ""
"そのようなテストコードのための作業環境は :dfn:`テストフィクスチャ (test "
"fixture)` と呼ばれます。\n"
"新しい TestCase インスタンスはある単一のテストフィクスチャとして作成され、"
"個々のテストメソッドを実行するのに使われます。\n"
"従って、 :meth:`~TestCase.setUp`, :meth:`~TestCase.tearDown`, :meth:"
"`~TestCase.__init__` は1回のテストにつき1回だけ呼び出されます。"

#: ../../library/unittest.rst:443
msgid ""
"It is recommended that you use TestCase implementations to group tests "
"together according to the features they test.  :mod:`unittest` provides a "
"mechanism for this: the :dfn:`test suite`, represented by :mod:`unittest`'s :"
"class:`TestSuite` class.  In most cases, calling :func:`unittest.main` will "
"do the right thing and collect all the module's test cases for you and "
"execute them."
msgstr ""
"テストケースの実装では、テストする機能に従ってテストをまとめるのをお勧めしま"
"す。\n"
":mod:`unittest` はこのための機構、:mod:`unittest` の :class:`TestSuite` クラ"
"スで表現される :dfn:`test suite`、を提供します。\n"
"たいていの場合 :func:`unittest.main` を呼び出しは正しい処理を行い、モジュール"
"の全テストケースを集めて実行します。"

#: ../../library/unittest.rst:450
msgid ""
"However, should you want to customize the building of your test suite, you "
"can do it yourself::"
msgstr ""
"しかし、テストスイートの構築をカスタマイズしたい場合、自分ですることができま"
"す::"

#: ../../library/unittest.rst:463
msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""
"テストケースやテストコードの定義を (:file:`widget.py` のような) テスト対象"
"コードと同じモジュールに置くことが出来ますが、テストコードを (:file:"
"`test_widget.py` のような) 独立したモジュールに置くのには以下のような利点があ"
"ります:"

#: ../../library/unittest.rst:468
msgid "The test module can be run standalone from the command line."
msgstr "テストモジュールだけをコマンドラインから独立に実行することができる。"

#: ../../library/unittest.rst:470
msgid "The test code can more easily be separated from shipped code."
msgstr "テストコードと出荷するコードをより簡単に分ける事ができる。"

#: ../../library/unittest.rst:472
msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr ""
"余程のことがない限り、テスト対象のコードに合わせてテストコードを変更すること"
"になりにくい。"

#: ../../library/unittest.rst:475
msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr "テストコードは、テスト対象コードほど頻繁に変更されない。"

#: ../../library/unittest.rst:477
msgid "Tested code can be refactored more easily."
msgstr "テストコードをより簡単にリファクタリングすることができる。"

#: ../../library/unittest.rst:479
msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr ""
"Cで書いたモジュールのテストはどうせ独立したモジュールなのだから、同様にしない"
"理由がない"

#: ../../library/unittest.rst:482
msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr "テストの方策を変更した場合でも、ソースコードを変更する必要がない。"

#: ../../library/unittest.rst:488
msgid "Re-using old test code"
msgstr "既存テストコードの再利用"

#: ../../library/unittest.rst:490
msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to "
"a :class:`TestCase` subclass."
msgstr ""
"既存のテストコードが有るとき、このテストを :mod:`unittest` で実行しようとする"
"ために古いテスト関数をいちいち :class:`TestCase` クラスのサブクラスに変換する"
"のは大変です。"

#: ../../library/unittest.rst:494
msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class. "
"This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""
"このような場合は、 :mod:`unittest` では :class:`TestCase` のサブクラスであ"
"る :class:`FunctionTestCase` クラスを使い、既存のテスト関数をラップします。初"
"期設定と終了処理も行なえます。"

#: ../../library/unittest.rst:498
msgid "Given the following test function::"
msgstr "以下のテストコードがあった場合::"

#: ../../library/unittest.rst:505
msgid ""
"one can create an equivalent test case instance as follows, with optional "
"set-up and tear-down methods::"
msgstr ""
"オプションの set-up と tear-down メソッドを持った同等のテストケースインスタン"
"スは次のように作成します::"

#: ../../library/unittest.rst:514
msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""
":class:`FunctionTestCase` を使って既存のテストを :mod:`unittest` ベースのテス"
"ト体系に変換することができますが、この方法は推奨されません。時間を掛けて :"
"class:`TestCase` のサブクラスに書き直した方が将来的なテストのリファクタリング"
"が限りなく易しくなります。"

#: ../../library/unittest.rst:519
msgid ""
"In some cases, the existing tests may have been written using the :mod:"
"`doctest` module.  If so, :mod:`doctest` provides a :class:`DocTestSuite` "
"class that can automatically build :class:`unittest.TestSuite` instances "
"from the existing :mod:`doctest`\\ -based tests."
msgstr ""
"既存のテストが :mod:`doctest` を使って書かれている場合もあるでしょう。その場"
"合、 :mod:`doctest` は :class:`DocTestSuite` クラスを提供します。このクラス"
"は、既存の :mod:`doctest`\\ ベースのテストから、自動的に :class:`unittest."
"TestSuite` のインスタンスを作成します。"

#: ../../library/unittest.rst:528
msgid "Skipping tests and expected failures"
msgstr "テストのスキップと予期された失敗"

#: ../../library/unittest.rst:532
msgid ""
"Unittest supports skipping individual test methods and even whole classes of "
"tests.  In addition, it supports marking a test as an \"expected failure,\" "
"a test that is broken and will fail, but shouldn't be counted as a failure "
"on a :class:`TestResult`."
msgstr ""
"unittest は特定のテストメソッドやテストクラス全体をスキップする仕組みを備えて"
"います。さらに、この機能はテスト結果を「予期された失敗 (expected failure)」と"
"することができ、テストが失敗しても :class:`TestResult` の失敗数にはカウントさ"
"れなくなります。"

#: ../../library/unittest.rst:537
msgid ""
"Skipping a test is simply a matter of using the :func:`skip` :term:"
"`decorator` or one of its conditional variants, calling :meth:`TestCase."
"skipTest` within a :meth:`~TestCase.setUp` or test method, or raising :exc:"
"`SkipTest` directly."
msgstr ""
"テストをスキップするには、 :func:`skip` デコレータかその条件付きバージョンの"
"一つを使うか、:meth:`~TestCase.setUp` やテストメソッドの中で :meth:`TestCase."
"skipTest` を呼び出すか、あるいは直接 :exc:`SkipTest` を送出するだけです。"

#: ../../library/unittest.rst:541
msgid "Basic skipping looks like this::"
msgstr "基本的なスキップは以下のようになります::"

#: ../../library/unittest.rst:566
msgid "This is the output of running the example above in verbose mode::"
msgstr "このサンプルを冗長モードで実行すると以下のように出力されます::"

#: ../../library/unittest.rst:578
msgid "Classes can be skipped just like methods::"
msgstr "テストクラスは以下のようにメソッドをスキップすることができます::"

#: ../../library/unittest.rst:585
msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ""
":meth:`TestCase.setUp` もスキップすることができます。この機能はセットアップの"
"対象のリソースが使用不可能な時に便利です。"

#: ../../library/unittest.rst:588
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr ""
"予期された失敗の機能を使用するには :func:`expectedFailure` デコレータを使いま"
"す。 ::"

#: ../../library/unittest.rst:595
msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""
"独自のスキップ用のデコレータの作成は簡単です。 そのためには、独自のデコレータ"
"のスキップしたい時点で :func:`skip` を呼び出します。 以下のデコレータはオブ"
"ジェクトに指定した属性が無い場合にテストをスキップします::"

#: ../../library/unittest.rst:604
msgid ""
"The following decorators and exception implement test skipping and expected "
"failures:"
msgstr ""
"以下のデコレータと例外はテストのスキップと予期された失敗を実装しています:"

#: ../../library/unittest.rst:608
msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr ""
"デコレートしたテストを無条件でスキップします。*reason* にはテストをスキップし"
"た理由を記載します。"

#: ../../library/unittest.rst:613
msgid "Skip the decorated test if *condition* is true."
msgstr "*condition* が真の場合、デコレートしたテストをスキップします。"

#: ../../library/unittest.rst:617
msgid "Skip the decorated test unless *condition* is true."
msgstr "*condition* が偽の場合、デコレートしたテストをスキップします。"

#: ../../library/unittest.rst:621
msgid ""
"Mark the test as an expected failure or error.  If the test fails or errors "
"in the test function itself (rather than in one of the :dfn:`test fixture` "
"methods) then it will be considered a success.  If the test passes, it will "
"be considered a failure."
msgstr ""
"失敗またはエラーが予測されるものとしてテストをマークします。テストが失敗する"
"か (:dfn:`test fixture` メソッドのいずれかではなく、) テスト関数そのものでエ"
"ラーとなった場合に成功したとみなされます。テストが成功した場合は失敗とみなさ"
"れます。"

#: ../../library/unittest.rst:628
msgid "This exception is raised to skip a test."
msgstr "この例外はテストをスキップするために送出されます。"

#: ../../library/unittest.rst:630
msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr ""
"ふつうはこれを直接送出する代わりに :meth:`TestCase.skipTest` やスキッピングデ"
"コレータの一つを使用出来ます。"

#: ../../library/unittest.rst:633
msgid ""
"Skipped tests will not have :meth:`~TestCase.setUp` or :meth:`~TestCase."
"tearDown` run around them. Skipped classes will not have :meth:`~TestCase."
"setUpClass` or :meth:`~TestCase.tearDownClass` run. Skipped modules will not "
"have :func:`setUpModule` or :func:`tearDownModule` run."
msgstr ""
"スキップしたテストの前後では、 :meth:`~TestCase.setUp` および :meth:"
"`~TestCase.tearDown` は実行されません。同様に、スキップしたクラスの前後で"
"は、 :meth:`~TestCase.setUpClass` および :meth:`~TestCase.tearDownClass` は実"
"行されません。スキップしたモジュールの前後では、 :meth:`setUpModule` および :"
"meth:`tearDownModule` は実行されません。"

#: ../../library/unittest.rst:641
msgid "Distinguishing test iterations using subtests"
msgstr "サブテストを利用して繰り返しテストの区別を付ける"

#: ../../library/unittest.rst:645
msgid ""
"When there are very small differences among your tests, for instance some "
"parameters, unittest allows you to distinguish them inside the body of a "
"test method using the :meth:`~TestCase.subTest` context manager."
msgstr ""
"テストの間にとても小さな差異がある場合（例えばいくつかのパラメータなど）、"
"unittestでは :meth:`~TestCase.subTest` コンテキストマネージャを使用してテスト"
"メソッドの内部でそれらを区別することができます。"

#: ../../library/unittest.rst:649
msgid "For example, the following test::"
msgstr "例えば以下のテストは::"

#: ../../library/unittest.rst:661
msgid "will produce the following output::"
msgstr "以下の出力をします::"

#: ../../library/unittest.rst:693
msgid ""
"Without using a subtest, execution would stop after the first failure, and "
"the error would be less easy to diagnose because the value of ``i`` wouldn't "
"be displayed::"
msgstr ""
"サブテスト無しの場合、最初の失敗で実行は停止し、``i`` の値が表示されないため"
"エラーの原因を突き止めるのは困難になります::"

#: ../../library/unittest.rst:709
msgid "Classes and functions"
msgstr "クラスと関数"

#: ../../library/unittest.rst:711
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr "この節では、 :mod:`unittest` モジュールのAPIの詳細について説明します。"

#: ../../library/unittest.rst:717
msgid "Test cases"
msgstr "テストクラス"

#: ../../library/unittest.rst:721
msgid ""
"Instances of the :class:`TestCase` class represent the logical test units in "
"the :mod:`unittest` universe.  This class is intended to be used as a base "
"class, with specific tests being implemented by concrete subclasses.  This "
"class implements the interface needed by the test runner to allow it to "
"drive the tests, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""
":class:`TestCase` クラスのインスタンスは、 :mod:`unittest` の世界における論理"
"的なテストの単位を示します。このクラスをベースクラスとして使用し、必要なテス"
"トを具象サブクラスに実装します。 :class:`TestCase` クラスでは、テストランナー"
"がテストを実行するため のインターフェースと、各種の失敗をチェックしレポートす"
"るためのメソッドを実装しています。"

#: ../../library/unittest.rst:728
msgid ""
"Each instance of :class:`TestCase` will run a single base method: the method "
"named *methodName*. In most uses of :class:`TestCase`, you will neither "
"change the *methodName* nor reimplement the default ``runTest()`` method."
msgstr ""
":class:`TestCase` の各インスタンスは *methodName* という名前の単一の基底メ"
"ソッドを実行します。\n"
":class:`TestCase` を使用する大半の場合 *methodName* を変更したりデフォルトの "
"``runTest()`` メソッドを再実装することはありません。"

#: ../../library/unittest.rst:733
msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"*methodName*. This makes it easier to experiment with :class:`TestCase` from "
"the interactive interpreter."
msgstr ""
":class:`TestCase` が *methodName* を指定しなくてもインスタンス化できるように"
"なりました。これにより対話的インタプリタから :class:`TestCase` を簡単に試せる"
"ようになりました。"

#: ../../library/unittest.rst:738
msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions "
"and report failures, and some inquiry methods allowing information about the "
"test itself to be gathered."
msgstr ""
":class:`TestCase` のインスタンスのメソッドは3種類のグループを提供します。 \n"
"1つ目のグループはテストの実行で使用されます。\n"
"2つ目のグループは条件のチェックおよび失敗のレポートを行うテストの実装で使用さ"
"れます。\n"
"3つ目のグループである問い合わせ用のメソッドによってテスト自身の情報が収集され"
"ます。"

#: ../../library/unittest.rst:743
msgid "Methods in the first group (running the test) are:"
msgstr "はじめのグループ (テスト実行) に含まれるメソッドは以下の通りです:"

#: ../../library/unittest.rst:747
msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or :exc:"
"`SkipTest`, any exception raised by this method will be considered an error "
"rather than a test failure. The default implementation does nothing."
msgstr ""
"テストフィクスチャの準備のために呼び出されるメソッドです。テストメソッドの直"
"前に呼び出されます。このメソッドで :exc:`AssertionError` や :exc:`SkipTest` "
"以外の例外が発生した場合、テストの失敗ではなくエラーとされます。デフォルトの"
"実装では何も行いません。"

#: ../../library/unittest.rst:755
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception, other than :exc:"
"`AssertionError` or :exc:`SkipTest`, raised by this method will be "
"considered an additional error rather than a test failure (thus increasing "
"the total number of reported errors). This method will only be called if "
"the :meth:`setUp` succeeds, regardless of the outcome of the test method. "
"The default implementation does nothing."
msgstr ""
"テストメソッドが実行され、結果が記録された直後に呼び出されるメソッドです。\n"
"このメソッドはテストメソッドで例外が投げられても呼び出されます。\n"
"そのため、サブクラスでこのメソッドを実装する場合は、内部状態を確認することが"
"必要になるでしょう。\n"
"このメソッドで :exc:`AssertionError` や :exc:`SkipTest` 以外の例外が発生した"
"場合、テストの失敗とは別のエラーとみなされます (従って報告されるエラーの総数"
"は増えます)。\n"
"このメソッドは、テストの結果に関わらず :meth:`setUp` が成功した場合にのみ呼ば"
"れます。\n"
"デフォルトの実装では何も行いません。"

#: ../../library/unittest.rst:768
msgid ""
"A class method called before tests in an individual class are run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""
"個別のクラス内のテストが実行される前に呼び出されるクラスメソッドです。 "
"``setUpClass`` はクラスを唯一の引数として取り、 :func:`classmethod` でデコ"
"レートされていなければなりません::"

#: ../../library/unittest.rst:776 ../../library/unittest.rst:791
msgid "See `Class and Module Fixtures`_ for more details."
msgstr "詳しくは `クラスとモジュールのフィクスチャ`_ を参照してください。"

#: ../../library/unittest.rst:783
msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""
"個別のクラス内のテストが実行された後に呼び出されるクラスメソッドです。 "
"``tearDownClass`` はクラスを唯一の引数として取り、 :func:`classmethod` でデコ"
"レートされていなければなりません::"

#: ../../library/unittest.rst:798
msgid ""
"Run the test, collecting the result into the :class:`TestResult` object "
"passed as *result*.  If *result* is omitted or ``None``, a temporary result "
"object is created (by calling the :meth:`defaultTestResult` method) and "
"used. The result object is returned to :meth:`run`'s caller."
msgstr ""
"テストを実行し、テスト結果を *result* に指定された :class:`TestResult` オブ"
"ジェクトにまとめます。 *result* が省略されるか ``None`` が渡された場合、 (:"
"meth:`defaultTestResult` メソッドを呼んで)  一時的な結果オブジェクトを生成"
"し、使用します。 結果オブジェクトは :meth:`run` の呼び出し元に返されます。"

#: ../../library/unittest.rst:804
msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr ""
"このメソッドは、単に :class:`TestCase` インスタンスを呼び出した場合と同様に振"
"る舞います。"

#: ../../library/unittest.rst:807
msgid ""
"Previous versions of ``run`` did not return the result. Neither did calling "
"an instance."
msgstr ""
"以前のバージョンの ``run`` は結果オブジェクトを返しませんでした。また :class:"
"`TestCase` インスタンスを呼び出した場合も同様でした。"

#: ../../library/unittest.rst:813
msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr ""
"テストメソッドや :meth:`setUp` が現在のテストをスキップする間に呼ばれます。詳"
"細については、 :ref:`unittest-skipping` を参照してください。"

#: ../../library/unittest.rst:821
msgid ""
"Return a context manager which executes the enclosed code block as a "
"subtest.  *msg* and *params* are optional, arbitrary values which are "
"displayed whenever a subtest fails, allowing you to identify them clearly."
msgstr ""
"このメソッドを囲っているブロックをサブテストとして実行するコンテキストマネー"
"ジャを返します。\n"
"*msg* と *params* はサブテストが失敗したときに表示されるオプションの任意の値"
"で、どんな値が使われたかを明確にするものです。"

#: ../../library/unittest.rst:826
msgid ""
"A test case can contain any number of subtest declarations, and they can be "
"arbitrarily nested."
msgstr ""
"テストケースには subtest 宣言を幾らでも含めることができ、任意にネストすること"
"ができます。"

#: ../../library/unittest.rst:829
msgid "See :ref:`subtests` for more information."
msgstr "詳細は :ref:`subtests` を参照してください。"

#: ../../library/unittest.rst:836
msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr ""
"テスト結果を収集せずにテストを実行します。例外が呼び出し元に通知されます。ま"
"た、テストをデバッガで実行することができます。"

#: ../../library/unittest.rst:842
msgid ""
"The :class:`TestCase` class provides several assert methods to check for and "
"report failures.  The following table lists the most commonly used methods "
"(see the tables below for more assert methods):"
msgstr ""
":class:`TestCase` クラスは失敗の検査と報告を行う多くのメソッドを提供していま"
"す。\n"
"以下の表は最も一般的に使われるメソッドを列挙しています (より多くのアサートメ"
"ソッドについては表の下を見てください):"

#: ../../library/unittest.rst:847 ../../library/unittest.rst:968
#: ../../library/unittest.rst:1182 ../../library/unittest.rst:1309
msgid "Method"
msgstr "メソッド"

#: ../../library/unittest.rst:847 ../../library/unittest.rst:968
#: ../../library/unittest.rst:1182
msgid "Checks that"
msgstr "確認事項"

#: ../../library/unittest.rst:847 ../../library/unittest.rst:968
#: ../../library/unittest.rst:1182 ../../library/unittest.rst:1309
msgid "New in"
msgstr "初出"

#: ../../library/unittest.rst:849
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

#: ../../library/unittest.rst:849
msgid "``a == b``"
msgstr "``a == b``"

#: ../../library/unittest.rst:852
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

#: ../../library/unittest.rst:852
msgid "``a != b``"
msgstr "``a != b``"

#: ../../library/unittest.rst:855
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

#: ../../library/unittest.rst:855
msgid "``bool(x) is True``"
msgstr "``bool(x) is True``"

#: ../../library/unittest.rst:858
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

#: ../../library/unittest.rst:858
msgid "``bool(x) is False``"
msgstr "``bool(x) is False``"

#: ../../library/unittest.rst:861
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

#: ../../library/unittest.rst:861
msgid "``a is b``"
msgstr "``a is b``"

#: ../../library/unittest.rst:861 ../../library/unittest.rst:864
#: ../../library/unittest.rst:867 ../../library/unittest.rst:870
#: ../../library/unittest.rst:873 ../../library/unittest.rst:876
#: ../../library/unittest.rst:973 ../../library/unittest.rst:1190
#: ../../library/unittest.rst:1193 ../../library/unittest.rst:1196
#: ../../library/unittest.rst:1199 ../../library/unittest.rst:1202
#: ../../library/unittest.rst:1311 ../../library/unittest.rst:1314
#: ../../library/unittest.rst:1317 ../../library/unittest.rst:1320
#: ../../library/unittest.rst:1323 ../../library/unittest.rst:1326
msgid "3.1"
msgstr "3.1"

#: ../../library/unittest.rst:864
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

#: ../../library/unittest.rst:864
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../../library/unittest.rst:867
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

#: ../../library/unittest.rst:867
msgid "``x is None``"
msgstr "``x is None``"

#: ../../library/unittest.rst:870
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

#: ../../library/unittest.rst:870
msgid "``x is not None``"
msgstr "``x is not None``"

#: ../../library/unittest.rst:873
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ":meth:`assertIn(a, b) <TestCase.assertIn>`"

#: ../../library/unittest.rst:873
msgid "``a in b``"
msgstr "``a in b``"

#: ../../library/unittest.rst:876
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"

#: ../../library/unittest.rst:876
msgid "``a not in b``"
msgstr "``a not in b``"

#: ../../library/unittest.rst:879
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"

#: ../../library/unittest.rst:879
msgid "``isinstance(a, b)``"
msgstr "``isinstance(a, b)``"

#: ../../library/unittest.rst:879 ../../library/unittest.rst:882
#: ../../library/unittest.rst:976 ../../library/unittest.rst:979
#: ../../library/unittest.rst:1205 ../../library/unittest.rst:1208
msgid "3.2"
msgstr "3.2"

#: ../../library/unittest.rst:882
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"

#: ../../library/unittest.rst:882
msgid "``not isinstance(a, b)``"
msgstr "``not isinstance(a, b)``"

#: ../../library/unittest.rst:886
msgid ""
"All the assert methods accept a *msg* argument that, if specified, is used "
"as the error message on failure (see also :data:`longMessage`). Note that "
"the *msg* keyword argument can be passed to :meth:`assertRaises`, :meth:"
"`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` only when "
"they are used as a context manager."
msgstr ""
"全てのアサートメソッドは *msg* 引数を受け取り、指定された場合、失敗時のエラー"
"メッセージとして使われます。 (:data:`longMessage` も参照してください)。 "
"*msg* キーワード引数は :meth:`assertRaises` 、 :meth:`assertRaisesRegex` 、 :"
"meth:`assertWarns` 、 :meth:`assertWarnsRegex` には、そのメソッドをコンテキス"
"トマネージャとして使った場合にのみ使えます。"

#: ../../library/unittest.rst:894
msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr ""
"*first* と *second* が等しいことをテストします。両者が等しくない場合、テスト"
"は失敗です。"

#: ../../library/unittest.rst:897
msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""
"さらに、 *first* と *second* が厳密に同じ型であり、list、tuple、dict、set、"
"frozenset もしくは str のいずれか、またはサブクラスが :meth:"
"`addTypeEqualityFunc` に登録されている任意の型の場合、より有用なデフォルトの"
"エラーメッセージを生成するために、その型特有の比較関数が呼ばれます（:ref:`型"
"固有のメソッドの一覧 <type-specific-methods>` も参照してください）。"

#: ../../library/unittest.rst:904
msgid "Added the automatic calling of type-specific equality function."
msgstr "自動で型固有の比較関数が呼ばれるようになりました。"

#: ../../library/unittest.rst:907
msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function for "
"comparing strings."
msgstr ""
"文字列比較のデフォルトの比較関数として :meth:`assertMultiLineEqual` が追加さ"
"れました。"

#: ../../library/unittest.rst:914
msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr ""
"*first* と *second* が等しくないことをテストします。両者が等しい場合、テスト"
"は失敗です。"

#: ../../library/unittest.rst:920
msgid "Test that *expr* is true (or false)."
msgstr "*expr* が真 (偽) であることをテストします。"

#: ../../library/unittest.rst:922
msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""
"このメソッドは、``bool(expr) is True`` と等価であり、``expr is True`` と等価"
"ではないことに注意が必要です (後者のためには、``assertIs(expr, True)`` が用意"
"されています)。また、専用のメソッドが使用できる場合には、そちらを使用してくだ"
"さい (例えば ``assertTrue(a == b)`` の代わりに ``assertEqual(a, b)`` を使用し"
"てください)。そうすることにより、テスト失敗時のエラーメッセージを詳細に表示す"
"ることができます。"

#: ../../library/unittest.rst:932
msgid "Test that *first* and *second* are (or are not) the same object."
msgstr ""
"*first* と *second* が同じオブジェクトであること (またはそうでないこと) をテ"
"ストします。"

#: ../../library/unittest.rst:940
msgid "Test that *expr* is (or is not) ``None``."
msgstr ""
"*expr* が ``None`` であること (および、そうでないこと) をテストします。"

#: ../../library/unittest.rst:948
msgid "Test that *member* is (or is not) in *container*."
msgstr ""
"*member* が *container* に含まれること (またはそうでないこと) をテストしま"
"す。"

#: ../../library/unittest.rst:956
msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or "
"a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""
"*obj* が *cls* のインスタンスであること (あるいはそうでないこと) をテストしま"
"す (この *cls* は、 :func:`isinstance` が扱うことのできる、クラスもしくはクラ"
"スのタプルである必要があります)。正確な型をチェックするためには、 :func:"
"`assertIs(type(obj), cls) <assertIs>` を使用してください。"

#: ../../library/unittest.rst:964
msgid ""
"It is also possible to check the production of exceptions, warnings, and log "
"messages using the following methods:"
msgstr ""
"以下のメソッドを使用して例外、警告、およびログメッセージの発生を確認すること"
"が出来ます:"

#: ../../library/unittest.rst:970
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"

#: ../../library/unittest.rst:970
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr "``fun(*args, **kwds)`` が *exc* を送出する"

#: ../../library/unittest.rst:973
msgid ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"
msgstr ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"

#: ../../library/unittest.rst:973
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` が *exc* を送出してメッセージが正規表現 *r* とマッチす"
"る"

#: ../../library/unittest.rst:976
msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"

#: ../../library/unittest.rst:976
msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr "``fun(*args, **kwds)`` が *warn* を送出する"

#: ../../library/unittest.rst:979
msgid ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"
msgstr ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"

#: ../../library/unittest.rst:979
msgid "``fun(*args, **kwds)`` raises *warn* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` が *warn* を送出してメッセージが正規表現 *r* とマッチ"
"する"

#: ../../library/unittest.rst:982
msgid ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"
msgstr ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"

#: ../../library/unittest.rst:982
msgid "The ``with`` block logs on *logger* with minimum *level*"
msgstr "``with`` ブロックが 最低 *level* で *logger* を使用する"

#: ../../library/unittest.rst:982
msgid "3.4"
msgstr "3.4"

#: ../../library/unittest.rst:985
msgid ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"
msgstr ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"

#: ../../library/unittest.rst:985
msgid "The ``with`` block does not log on"
msgstr ""

#: ../../library/unittest.rst:986
msgid "*logger* with minimum *level*"
msgstr ""

#: ../../library/unittest.rst:985
msgid "3.10"
msgstr "3.10"

#: ../../library/unittest.rst:992
msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertRaises`.  The test passes if *exception* is raised, is an error if "
"another exception is raised, or fails if no exception is raised. To catch "
"any of a group of exceptions, a tuple containing the exception classes may "
"be passed as *exception*."
msgstr ""
"*callable* を呼び出した時に例外が発生することをテストします。 :meth:"
"`assertRaises` で指定した位置パラメータとキーワードパラメータを該当メソッドに"
"渡します。 *exception* が送出された場合、テストは成功です。また、他の例外が投"
"げられた場合はエラー、例外が送出されなかった場合は失敗になります。複数の例外"
"をキャッチする場合には、例外クラスのタプルを *exception* に指定してください。"

#: ../../library/unittest.rst:999
msgid ""
"If only the *exception* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"*exception* 引数のみ（またはそれに加えて *msg* 引数）が渡された場合には、コン"
"テキストマネージャが返されます。これにより関数名を渡す形式ではなく、インライ"
"ンでテスト対象のコードを書くことができます::"

#: ../../library/unittest.rst:1006
msgid ""
"When used as a context manager, :meth:`assertRaises` accepts the additional "
"keyword argument *msg*."
msgstr ""
"コンテキストマネージャとして使われたときは、 :meth:`assertRaises` は加えて "
"*msg* キーワード引数も受け付けます。"

#: ../../library/unittest.rst:1009
msgid ""
"The context manager will store the caught exception object in its :attr:"
"`exception` attribute.  This can be useful if the intention is to perform "
"additional checks on the exception raised::"
msgstr ""
"このコンテキストマネージャは :attr:`exception` で指定されたオブジェクトを格納"
"します。これにより、例外発生時の詳細な確認をおこなうことができます::"

#: ../../library/unittest.rst:1019
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ""
":meth:`assertRaises` がコンテキストマネージャとして使えるようになりました。"

#: ../../library/unittest.rst:1022
msgid "Added the :attr:`exception` attribute."
msgstr ":attr:`exception` 属性が追加されました。"

#: ../../library/unittest.rst:1025 ../../library/unittest.rst:1051
#: ../../library/unittest.rst:1092 ../../library/unittest.rst:1115
msgid "Added the *msg* keyword argument when used as a context manager."
msgstr ""
"コンテキストマネージャとして使用したときに *msg* キーワード引数が追加されまし"
"た。"

#: ../../library/unittest.rst:1032
msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the string "
"representation of the raised exception.  *regex* may be a regular expression "
"object or a string containing a regular expression suitable for use by :func:"
"`re.search`.  Examples::"
msgstr ""
":meth:`assertRaises` と同等ですが、例外の文字列表現が *regex* にマッチするこ"
"ともテストします。 *regex* は正規表現オブジェクトか、 :func:`re.search` が扱"
"える正規表現が書かれた文字列である必要があります。例えば以下のようになりま"
"す::"

#: ../../library/unittest.rst:1040 ../../library/unittest.rst:1108
msgid "or::"
msgstr "もしくは::"

#: ../../library/unittest.rst:1045
msgid "Added under the name ``assertRaisesRegexp``."
msgstr "``assertRaisesRegexp``という名前で追加されました。"

#: ../../library/unittest.rst:1048
msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr ":meth:`assertRaisesRegex` にリネームされました。"

#: ../../library/unittest.rst:1058
msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertWarns`.  The test passes if *warning* is triggered and fails if it "
"isn't.  Any exception is an error. To catch any of a group of warnings, a "
"tuple containing the warning classes may be passed as *warnings*."
msgstr ""
"*callable* を呼び出した時に警告が発生することをテストします。 :meth:"
"`assertWarns` で指定した位置パラメータとキーワードパラメータを該当メソッドに"
"渡します。 *warning* が発生した場合にテストが成功し、そうでなければ失敗になり"
"ます。例外が送出された場合はエラーになります。複数の警告を捕捉する場合には、"
"警告クラスのタプルを *warnings* に指定してください。"

#: ../../library/unittest.rst:1065
msgid ""
"If only the *warning* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"*warning* 引数のみ（またはそれに加えて *msg* 引数）が渡された場合には、コンテ"
"キストマネージャが返されます。これにより関数名を渡す形式ではなく、インライン"
"でテスト対象のコードを書くことができます::"

#: ../../library/unittest.rst:1072
msgid ""
"When used as a context manager, :meth:`assertWarns` accepts the additional "
"keyword argument *msg*."
msgstr ""
"コンテキストマネージャとして使われたときは、 :meth:`assertWarns` は加えて "
"*msg* キーワード引数も受け付けます。"

#: ../../library/unittest.rst:1075
msgid ""
"The context manager will store the caught warning object in its :attr:"
"`warning` attribute, and the source line which triggered the warnings in "
"the :attr:`filename` and :attr:`lineno` attributes. This can be useful if "
"the intention is to perform additional checks on the warning caught::"
msgstr ""
"このコンテキストマネージャは、捕捉した警告オブジェクトを :attr:`warning` 属性"
"に、警告が発生したソース行を :attr:`filename` 属性と :attr:`lineno` 属性に格"
"納します。これは警告発生時に捕捉された警告に対して追加の確認を行いたい場合に"
"便利です::"

#: ../../library/unittest.rst:1087
msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr "このメソッドは呼び出されたときに警告フィルタを無視して動作します。"

#: ../../library/unittest.rst:1099
msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the message "
"of the triggered warning.  *regex* may be a regular expression object or a "
"string containing a regular expression suitable for use by :func:`re."
"search`.  Example::"
msgstr ""
":meth:`assertWarns` と同等ですが、警告メッセージが *regex* にマッチすることも"
"テストします。 *regex* は正規表現オブジェクトか、 :func:`re.search` が扱える"
"正規表現が書かれた文字列である必要があります。例えば以下のようになります::"

#: ../../library/unittest.rst:1120
msgid ""
"A context manager to test that at least one message is logged on the "
"*logger* or one of its children, with at least the given *level*."
msgstr ""
"*logger* かその子ロガーのうちの1つに、少なくとも1つのログメッセージが少なくと"
"も与えられた *level* で出力されることをテストするコンテキストマネージャです。"

#: ../../library/unittest.rst:1124
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages that were not blocked by a non-propagating "
"descendent logger."
msgstr ""

#: ../../library/unittest.rst:1129 ../../library/unittest.rst:1170
msgid ""
"If given, *level* should be either a numeric logging level or its string "
"equivalent (for example either ``\"ERROR\"`` or :attr:`logging.ERROR`).  The "
"default is :attr:`logging.INFO`."
msgstr ""
"*level* が与えられた場合、ログレベルを表す数値もしくはそれに相当する文字列 "
"(例えば ``\"ERROR\"`` もしくは :attr:`logging.ERROR`) であるべきです。\n"
"デフォルトは :attr:`logging.INFO` です。"

#: ../../library/unittest.rst:1133
msgid ""
"The test passes if at least one message emitted inside the ``with`` block "
"matches the *logger* and *level* conditions, otherwise it fails."
msgstr ""
"``with`` ブロック内で出たメッセージの少なくとも一つが *logger* および "
"*level* 条件に合っている場合、このテストをパスします。それ以外の場合は失敗で"
"す。"

#: ../../library/unittest.rst:1136
msgid ""
"The object returned by the context manager is a recording helper which keeps "
"tracks of the matching log messages.  It has two attributes:"
msgstr ""
"コンテキストマネージャから返されるオブジェクトは、条件に該当するログメッセー"
"ジを追跡し続ける記録のためのヘルパーです。\n"
"このオブジェクトには2つの属性があります:"

#: ../../library/unittest.rst:1142
msgid ""
"A list of :class:`logging.LogRecord` objects of the matching log messages."
msgstr ""
"該当するログメッセージを表す :class:`logging.LogRecord` オブジェクトのリス"
"ト。"

#: ../../library/unittest.rst:1147
msgid ""
"A list of :class:`str` objects with the formatted output of matching "
"messages."
msgstr ""
"該当するメッセージ出力をフォーマットした :class:`str` オブジェクトのリスト。"

#: ../../library/unittest.rst:1150
msgid "Example::"
msgstr "以下はプログラム例です::"

#: ../../library/unittest.rst:1162
msgid ""
"A context manager to test that no messages are logged on the *logger* or one "
"of its children, with at least the given *level*."
msgstr ""

#: ../../library/unittest.rst:1166
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages."
msgstr ""
"*logger* が与えられた場合、 :class:`logging.Logger` オブジェクトもしくはロ"
"ガーの名前である :class:`str` であるべきです。\n"
"デフォルトはルートロガーで、これは全てのメッセージを掴まえます。"

#: ../../library/unittest.rst:1174
msgid ""
"Unlike :meth:`assertLogs`, nothing will be returned by the context manager."
msgstr ""
":meth:`assertLogs` と異なり、このコンテキストマネージャは何も返しません。"

#: ../../library/unittest.rst:1179
msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr "より具体的な確認を行うために以下のメソッドが用意されています:"

#: ../../library/unittest.rst:1184
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"

#: ../../library/unittest.rst:1184
msgid "``round(a-b, 7) == 0``"
msgstr "``round(a-b, 7) == 0``"

#: ../../library/unittest.rst:1187
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"

#: ../../library/unittest.rst:1187
msgid "``round(a-b, 7) != 0``"
msgstr "``round(a-b, 7) != 0``"

#: ../../library/unittest.rst:1190
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"

#: ../../library/unittest.rst:1190
msgid "``a > b``"
msgstr "``a > b``"

#: ../../library/unittest.rst:1193
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"

#: ../../library/unittest.rst:1193
msgid "``a >= b``"
msgstr "``a >= b``"

#: ../../library/unittest.rst:1196
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ":meth:`assertLess(a, b) <TestCase.assertLess>`"

#: ../../library/unittest.rst:1196
msgid "``a < b``"
msgstr "``a < b``"

#: ../../library/unittest.rst:1199
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"

#: ../../library/unittest.rst:1199
msgid "``a <= b``"
msgstr "``a <= b``"

#: ../../library/unittest.rst:1202
msgid ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"
msgstr ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"

#: ../../library/unittest.rst:1202
msgid "``r.search(s)``"
msgstr "``r.search(s)``"

#: ../../library/unittest.rst:1205
msgid ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"
msgstr ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"

#: ../../library/unittest.rst:1205
msgid "``not r.search(s)``"
msgstr "``not r.search(s)``"

#: ../../library/unittest.rst:1208
msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"

#: ../../library/unittest.rst:1208
msgid ""
"*a* and *b* have the same elements in the same number, regardless of their "
"order."
msgstr "*a* と *b* に、順番によらず同じ要素が同じ数だけある。"

#: ../../library/unittest.rst:1217
msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the :func:"
"`round` function) and not *significant digits*."
msgstr ""
"*first* と *second* が近似的に等しい (等しくない) ことをテストします。これ"
"は、*places* (デフォルト7) で指定した小数位で丸めた差分をゼロと比較することで"
"行われます。これらのメソッドは (:func:`round` と同様に) *小数位* を指定するの"
"であって、*有効桁数* を指定するのではないことに注意してください。"

#: ../../library/unittest.rst:1223
msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""
"*places* の代わりに *delta* が渡された場合には、*first* と *second* の差分が "
"*delta* 以下 (以上) であることをテストします。"

#: ../../library/unittest.rst:1226
msgid "Supplying both *delta* and *places* raises a :exc:`TypeError`."
msgstr ""
"*delta* と *places* の両方が指定された場合は :exc:`TypeError` が送出されま"
"す。"

#: ../../library/unittest.rst:1228
msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""
":meth:`assertAlmostEqual` は、オブジェクトが等しい場合には自動で近似的に等し"
"いとみなすようになりました。 :meth:`assertNotAlmostEqual` は、オブジェクトが"
"等しい場合には自動的に失敗するようになりました。 *delta* 引数が追加されまし"
"た。"

#: ../../library/unittest.rst:1239
msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr ""
"*first* が *second* と比べて、メソッド名に対応して >, >=, < もしくは <= であ"
"ることをテストします。そうでない場合はテストは失敗です::"

#: ../../library/unittest.rst:1251
msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case of "
"failure, the error message will include the pattern and the *text* (or the "
"pattern and the part of *text* that unexpectedly matched).  *regex* may be a "
"regular expression object or a string containing a regular expression "
"suitable for use by :func:`re.search`."
msgstr ""
"*regex* の検索が *text* とマッチする (またはマッチしない) ことをテストしま"
"す。テスト失敗時には、エラーメッセージにパターンと *text* が表示されます（も"
"しくは、パターンと意図しないかたちでマッチした *text* の一部が表示されま"
"す）。 *regex* は正規表現オブジェクトか、 :func:`re.search` が扱える正規表現"
"が書かれた文字列である必要があります。"

#: ../../library/unittest.rst:1257
msgid "Added under the name ``assertRegexpMatches``."
msgstr "``assertRegexpMatches``という名前で追加されました。"

#: ../../library/unittest.rst:1259
msgid ""
"The method ``assertRegexpMatches()`` has been renamed to :meth:`."
"assertRegex`."
msgstr ""
"メソッド ``assertRegexpMatches()`` は :meth:`.assertRegex` にリネームされまし"
"た。"

#: ../../library/unittest.rst:1262
msgid ":meth:`.assertNotRegex`."
msgstr ":meth:`.assertNotRegex`。"

#: ../../library/unittest.rst:1264
msgid ""
"The name ``assertNotRegexpMatches`` is a deprecated alias for :meth:`."
"assertNotRegex`."
msgstr ""
"``assertNotRegexpMatches`` は :meth:`assertNotRegex` のエイリアスであることか"
"ら非推奨となります。"

#: ../../library/unittest.rst:1271
msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""
"シーケンス *first* が *second* と同じ要素を含んでいることをテストします。要素"
"の順序はテスト結果に影響しません。要素が含まれていない場合には、シーケンスの"
"差分がエラーメッセージとして表示されます。"

#: ../../library/unittest.rst:1275
msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*. It "
"verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"but works with sequences of unhashable objects as well."
msgstr ""
"*first* と *second* の比較では、重複した要素は無視 *されません*。両者に同じ数"
"の要素が含まれていることを検証します。このメソッドは "
"``assertEqual(Counter(list(first)), Counter(list(second)))`` と同等に振る舞う"
"ことに加えて、ハッシュ化できないオブジェクトのシーケンスでも動作します。"

#: ../../library/unittest.rst:1286
msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already "
"implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""
":meth:`assertEqual` メソッドは、同じ型のオブジェクトの等価性確認のために、型"
"ごとに特有のメソッドにディスパッチします。これらのメソッドは、ほとんどの組み"
"込み型用のメソッドは既に実装されています。さらに、 :meth:"
"`addTypeEqualityFunc` を使う事で新たなメソッドを登録することができます:"

#: ../../library/unittest.rst:1293
msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise :data:`self."
"failureException(msg) <failureException>` when inequality between the first "
"two parameters is detected -- possibly providing useful information and "
"explaining the inequalities in details in the error message."
msgstr ""
":meth:`assertEqual` で呼び出される型特有のメソッドを登録します。登録するメ"
"ソッドは、比較する2つのオブジェクトの型が厳密に *typeobj* と同じ (サブクラス"
"でもいけません) の場合に等価性を確認します。 *function*  は :meth:"
"`assertEqual` と同様に、2つの位置引数と、3番目に msg=None のキーワード引数を"
"取れる必要があります。このメソッドは、始めの2つに指定したパラメータ間の差分を"
"検出した時に :data:`self.failureException(msg) <failureException>` の例外を投"
"げる必要があります。この例外を投げる際は、出来る限り、エラーの内容が分かる有"
"用な情報と差分の詳細をエラーメッセージに含めてください。"

#: ../../library/unittest.rst:1304
msgid ""
"The list of type-specific methods automatically used by :meth:`~TestCase."
"assertEqual` are summarized in the following table.  Note that it's usually "
"not necessary to invoke these methods directly."
msgstr ""
":meth:`~TestCase.assertEqual` が自動的に呼び出す型特有のメソッドの概要を以下"
"の表示に記載しています。これらのメソッドは通常は直接呼び出す必要がないことに"
"注意が必要です。"

#: ../../library/unittest.rst:1309
msgid "Used to compare"
msgstr "比較の対象"

#: ../../library/unittest.rst:1311
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

#: ../../library/unittest.rst:1311
msgid "strings"
msgstr "文字列"

#: ../../library/unittest.rst:1314
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

#: ../../library/unittest.rst:1314
msgid "sequences"
msgstr "シーケンス"

#: ../../library/unittest.rst:1317
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

#: ../../library/unittest.rst:1317
msgid "lists"
msgstr "リスト"

#: ../../library/unittest.rst:1320
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

#: ../../library/unittest.rst:1320
msgid "tuples"
msgstr "タプル"

#: ../../library/unittest.rst:1323
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

#: ../../library/unittest.rst:1323
msgid "sets or frozensets"
msgstr "set または frozenset"

#: ../../library/unittest.rst:1326
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

#: ../../library/unittest.rst:1326
msgid "dicts"
msgstr "辞書"

#: ../../library/unittest.rst:1334
msgid ""
"Test that the multiline string *first* is equal to the string *second*. When "
"not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing "
"strings with :meth:`assertEqual`."
msgstr ""
"複数行の文字列 *first* が文字列 *second* と等しいことをテストします。等しくな"
"い場合には、両者の差分がハイライトされてエラーメッセージに表示されます。この"
"メソッドは、デフォルトで、 :meth:`assertEqual` が string を比較するときに自動"
"的に使用します。"

#: ../../library/unittest.rst:1344
msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that "
"shows the difference between the two."
msgstr ""
"2つのシーケンスが等しいことをテストします。*seq_type* が指定された場合、"
"*first* と *second* が *seq_type* のインスタンスで無い場合にはテストが失敗し"
"ます。シーケンスどうしが異なる場合には、両者の差分がエラーメッセージに表示さ"
"れます。"

#: ../../library/unittest.rst:1349
msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""
"このメソッドは直接 :meth:`assertEqual` からは呼ばれませんが、 :meth:"
"`assertListEqual` と :meth:`assertTupleEqual` の実装で使われています。"

#: ../../library/unittest.rst:1359
msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods "
"are used by default when comparing lists or tuples with :meth:`assertEqual`."
msgstr ""
"2つのリストまたはタプルが等しいかどうかをテストします。等しくない場合には、両"
"者の差分を表示します。2つのパラメータの型が異なる場合にはテストがエラーになり"
"ます。このメソッドは、デフォルトで、 :meth:`assertEqual` が list または "
"tuple を比較するときに自動的に使用します。"

#: ../../library/unittest.rst:1370
msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that "
"lists the differences between the sets.  This method is used by default when "
"comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""
"2つのセットが等しいかどうかをテストします。等しくない場合には、両者の差分を表"
"示します。このメソッドは、デフォルトで、 :meth:`assertEqual` が set もしくは "
"frozenset を比較するときに自動的に使用します。"

#: ../../library/unittest.rst:1374
msgid ""
"Fails if either of *first* or *second* does not have a :meth:`set."
"difference` method."
msgstr ""
"*first* or *second* のいずれかに :meth:`set.difference` が無い場合にはテスト"
"は失敗します。"

#: ../../library/unittest.rst:1382
msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will "
"be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""
"2つの辞書が等しいかどうかをテストします。等しくない場合には、両者の差分を表示"
"します。このメソッドは、デフォルトで、 :meth:`assertEqual` が dict を比較する"
"ときに自動的に使用します。"

#: ../../library/unittest.rst:1393
msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr "最後に、 :class:`TestCase` の残りのメソッドと属性を紹介します:"

#: ../../library/unittest.rst:1398
msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error "
"message."
msgstr ""
"無条件にテストを失敗させます。エラーメッセージの表示に、*msg* または "
"``None`` が使われます。"

#: ../../library/unittest.rst:1404
msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is :exc:"
"`AssertionError`."
msgstr ""
":meth:`test` メソッドが送出する例外を指定するクラス属性です。例えばテストフ"
"レームワークで追加情報を付した特殊な例外が必要になる場合、この例外のサブクラ"
"スとして作成します。この属性の初期値は :exc:`AssertionError` です。"

#: ../../library/unittest.rst:1413
msgid ""
"This class attribute determines what happens when a custom failure message "
"is passed as the msg argument to an assertXYY call that fails. ``True`` is "
"the default value. In this case, the custom message is appended to the end "
"of the standard failure message. When set to ``False``, the custom message "
"replaces the standard message."
msgstr ""
"このクラス属性は、失敗した assertXYY の呼び出しで独自の失敗時のメッセージが "
"msg 引数として渡されていたときにどうするかを決定します。\n"
"``True`` がデフォルト値です。\n"
"この場合、標準の失敗時のメッセージの後に独自のメッセージが追記されます。\n"
"``False`` に設定したときは、標準のメッセージを独自のメッセージで置き換えま"
"す。"

#: ../../library/unittest.rst:1419
msgid ""
"The class setting can be overridden in individual test methods by assigning "
"an instance attribute, self.longMessage, to ``True`` or ``False`` before "
"calling the assert methods."
msgstr ""
"アサートメソッドを呼び出す前に、個別のテストメソッドの中でインスタンス属性 "
"self.longMessage を ``True`` または ``False`` に設定して、この設定を上書きで"
"きます。"

#: ../../library/unittest.rst:1423
msgid "The class setting gets reset before each test call."
msgstr "このクラスの設定はそれぞれのテストを呼び出す前にリセットされます。"

#: ../../library/unittest.rst:1430
msgid ""
"This attribute controls the maximum length of diffs output by assert methods "
"that report diffs on failure. It defaults to 80*8 characters. Assert methods "
"affected by this attribute are :meth:`assertSequenceEqual` (including all "
"the sequence comparison methods that delegate to it), :meth:"
"`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""
"この属性は、アサーションメソッドが失敗をレポートする時に表示する差分の長さを"
"コントロールします。デフォルトは 80*8 文字です。この属性が影響するメソッド"
"は、 :meth:`assertSequenceEqual` (およびこのメソッドに委譲するシーケンス比較"
"メソッド)、 :meth:`assertDictEqual` と :meth:`assertMultiLineEqual` です。"

#: ../../library/unittest.rst:1437
msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr "``maxDiff`` を ``None`` に設定すると差分表示の上限がなくなります。"

#: ../../library/unittest.rst:1443
msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr ""
"テストフレームワークは、テスト情報を収集するために以下のメソッドを使用します:"

#: ../../library/unittest.rst:1449
msgid ""
"Return the number of tests represented by this test object.  For :class:"
"`TestCase` instances, this will always be ``1``."
msgstr ""
"テストオブジェクトに含まれるテストの数を返します。 :class:`TestCase` インスタ"
"ンスは常に ``1`` を返します。"

#: ../../library/unittest.rst:1455
msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr ""
"このテストケースクラスで使われるテスト結果クラスのインスタンスを (もし :meth:"
"`run` メソッドに他の結果インスタンスが提供されないならば) 返します。"

#: ../../library/unittest.rst:1459
msgid ""
"For :class:`TestCase` instances, this will always be an instance of :class:"
"`TestResult`; subclasses of :class:`TestCase` should override this as "
"necessary."
msgstr ""
":class:`TestCase` インスタンスに対しては、いつも :class:`TestResult` のインス"
"タンスですので、 :class:`TestCase` のサブクラスでは必要に応じてこのメソッドを"
"オーバライドしてください。"

#: ../../library/unittest.rst:1466
msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr ""
"テストケースを特定する文字列を返します。通常、*id* はモジュール名・クラス名を"
"含む、テストメソッドのフルネームを指定します。"

#: ../../library/unittest.rst:1472
msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or ``None``."
msgstr ""
"テストの説明を一行分、または説明がない場合には ``None`` を返します。デフォル"
"トでは、テストメソッドの docstring の先頭の一行、または ``None`` を返します。"

#: ../../library/unittest.rst:1477
msgid ""
"In 3.1 this was changed to add the test name to the short description even "
"in the presence of a docstring.  This caused compatibility issues with "
"unittest extensions and adding the test name was moved to the :class:"
"`TextTestResult` in Python 3.2."
msgstr ""
"3.1で docstring があったとしても、返される短い説明文字列にテスト名が付けられ"
"るようになりました。\n"
"この変更によって unittest 拡張に互換性の問題が発生し、 Python 3.2 でテスト名"
"が追加される場所は :class:`TextTestResult` へ移動しました。"

#: ../../library/unittest.rst:1486
msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used "
"during the test. Functions will be called in reverse order to the order they "
"are added (:abbr:`LIFO (last-in, first-out)`).  They are called with any "
"arguments and keyword arguments passed into :meth:`addCleanup` when they are "
"added."
msgstr ""
":meth:`tearDown` の後に呼び出される関数を追加します。この関数はリソースのク"
"リーンアップのために使用します。追加された関数は、追加された順と逆の順番で呼"
"び出されます（:abbr:`LIFO (last-in, first-out)`）。 :meth:`addCleanup` に渡さ"
"れた引数とキーワード引数が追加された関数にも渡されます。"

#: ../../library/unittest.rst:1492
msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr ""
":meth:`setUp` が失敗した場合、つまり :meth:`tearDown` が呼ばれなかった場合で"
"も、追加されたクリーンアップ関数は呼び出されます。"

#: ../../library/unittest.rst:1500
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:`addCleanup` "
"and return the result of the :meth:`~object.__enter__` method."
msgstr ""

#: ../../library/unittest.rst:1510
msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after :meth:"
"`setUp` if :meth:`setUp` raises an exception."
msgstr ""
"このメソッドは、 :meth:`tearDown` の後、もしくは、 :meth:`setUp` が例外を投げ"
"た場合は :meth:`setUp` の後に、無条件で呼ばれます。"

#: ../../library/unittest.rst:1513
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addCleanup`. If you need cleanup functions to be called *prior* to :meth:"
"`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""
"このメソッドは、 :meth:`addCleanup` で追加された関数を呼び出す責務を担いま"
"す。もし、クリーンアップ関数を :meth:`tearDown` より前に呼び出す必要がある場"
"合には、 :meth:`doCleanups` を明示的に呼び出してください。"

#: ../../library/unittest.rst:1518
msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ""
":meth:`doCleanups` は、どこで呼び出されても、クリーンアップ関数をスタックから"
"削除して実行します。"

#: ../../library/unittest.rst:1526
msgid ""
"Add a function to be called after :meth:`tearDownClass` to cleanup resources "
"used during the test class. Functions will be called in reverse order to the "
"order they are added (:abbr:`LIFO (last-in, first-out)`). They are called "
"with any arguments and keyword arguments passed into :meth:`addClassCleanup` "
"when they are added."
msgstr ""
":meth:`tearDownClass` の後に呼び出される関数を追加します。この関数はリソース"
"のクリーンアップのために使用します。追加された関数は、追加された順と逆の順番"
"で呼び出されます（:abbr:`LIFO (last-in, first-out)`）。 :meth:"
"`addClassCleanup` に渡された引数とキーワード引数が追加された関数にも渡されま"
"す。"

#: ../../library/unittest.rst:1532
msgid ""
"If :meth:`setUpClass` fails, meaning that :meth:`tearDownClass` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
":meth:`setUpClass` が失敗した場合、つまり :meth:`tearDownClass` が呼ばれな"
"かった場合でも、追加されたクリーンアップ関数は呼び出されます。"

#: ../../library/unittest.rst:1540
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:"
"`addClassCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""

#: ../../library/unittest.rst:1550
msgid ""
"This method is called unconditionally after :meth:`tearDownClass`, or after :"
"meth:`setUpClass` if :meth:`setUpClass` raises an exception."
msgstr ""
"このメソッドは、 :meth:`tearDownClass` の後、もしくは、 :meth:`setUpClass` が"
"例外を投げた場合は :meth:`setUpClass` の後に、無条件で呼ばれます。"

#: ../../library/unittest.rst:1553
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addClassCleanup`. If you need cleanup functions to be called *prior* to :"
"meth:`tearDownClass` then you can call :meth:`doClassCleanups` yourself."
msgstr ""
"このメソッドは、 :meth:`addClassCleanup` で追加された関数を呼び出す責務を担い"
"ます。もし、クリーンアップ関数を :meth:`tearDownClass` より前に呼び出す必要が"
"ある場合には、 :meth:`doClassCleanups` を明示的に呼び出してください。"

#: ../../library/unittest.rst:1558
msgid ""
":meth:`doClassCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":meth:`doClassCleanups` は、どこで呼び出されても、クリーンアップ関数をスタッ"
"クから削除して実行します。"

#: ../../library/unittest.rst:1566
msgid ""
"This class provides an API similar to :class:`TestCase` and also accepts "
"coroutines as test functions."
msgstr ""
"このクラスは:class:`TestCase` と似たAPIを提供し、テスト関数としてコルーチンも"
"許容します。"

#: ../../library/unittest.rst:1573
msgid ""
"Method called to prepare the test fixture. This is called after :meth:"
"`setUp`. This is called immediately before calling the test method; other "
"than :exc:`AssertionError` or :exc:`SkipTest`, any exception raised by this "
"method will be considered an error rather than a test failure. The default "
"implementation does nothing."
msgstr ""
"テストフィクスチャを用意するために呼び出されるメソッドです。これは :meth:"
"`setUp`. の後に呼び出されます。これはテストメソッドを呼び出す直前に呼び出され"
"ます。:exc:`AssertionError` と :exc:`SkipTest` を除いて、このメソッドのによっ"
"て送出されたあらゆる例外はテストの失敗ではなくエラーとみなされます。デフォル"
"トの実装では何もしません。"

#: ../../library/unittest.rst:1581
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called before :meth:`tearDown`. This is called "
"even if the test method raised an exception, so the implementation in "
"subclasses may need to be particularly careful about checking internal "
"state.  Any exception, other than :exc:`AssertionError` or :exc:`SkipTest`, "
"raised by this method will be considered an additional error rather than a "
"test failure (thus increasing the total number of reported errors). This "
"method will only be called if the :meth:`asyncSetUp` succeeds, regardless of "
"the outcome of the test method. The default implementation does nothing."
msgstr ""
"テストメソッドが呼び出され、その結果が記録された直後に呼び出されるメソッドで"
"す。これは :meth:`tearDown`の前に呼び出されます。これはテストメソッドが例外を"
"送出した場合でも呼び出されるので、サブクラスの実装では内部状態のチェックに特"
"に気を付ける必要があります。このメソッドで送出された:exc:`AssertionError` "
"と :exc:`SkipTest`以外の例外は、テストの失敗ではなく追加のエラーとみなされま"
"す(そのため、報告されるエラーの総数が増えることになります)。このメソッドはテ"
"ストメソッドの結果に関係なく、:meth:`asyncSetUp` が成功した場合にのみ呼び出さ"
"れます。デフォルトの実装では何もしません。"

#: ../../library/unittest.rst:1593
msgid "This method accepts a coroutine that can be used as a cleanup function."
msgstr ""
"このメソッドはクリーンアップ関数として使用できるコルーチンを受け入れます。"

#: ../../library/unittest.rst:1597
msgid ""
"Enter the supplied :term:`asynchronous context manager`.  If successful, "
"also add its :meth:`~object.__aexit__` method as a cleanup function by :meth:"
"`addAsyncCleanup` and return the result of the :meth:`~object.__aenter__` "
"method."
msgstr ""

#: ../../library/unittest.rst:1607
msgid ""
"Sets up a new event loop to run the test, collecting the result into the :"
"class:`TestResult` object passed as *result*.  If *result* is omitted or "
"``None``, a temporary result object is created (by calling the :meth:"
"`defaultTestResult` method) and used. The result object is returned to :meth:"
"`run`'s caller. At the end of the test all the tasks in the event loop are "
"cancelled."
msgstr ""
"テストを実行するための新しいイベントループを作成し、 *result*として渡された:"
"class:`TestResult`オブジェクトに結果を収集します。*result*が省略された場合や"
"``None``の場合は、一時的なresultオブジェクトが(:meth:`defaultTestResult`メ"
"ソッドの呼び出しによって)作成され、使用されます。このresultオブジェクトは :"
"meth:`run`の呼び出し元に返されます。テスト終了時には、イベントループ内のすべ"
"てのタスクがキャンセルされます。"

#: ../../library/unittest.rst:1615
msgid "An example illustrating the order::"
msgstr "順番を示す例です:"

#: ../../library/unittest.rst:1651
msgid ""
"After running the test, ``events`` would contain ``[\"setUp\", "
"\"asyncSetUp\", \"test_response\", \"asyncTearDown\", \"tearDown\", "
"\"cleanup\"]``."
msgstr ""
"テスト実行後、``events``には``[\"setUp\", \"asyncSetUp\", \"test_response\", "
"\"asyncTearDown\", \"tearDown\", \"cleanup\"]``が含まれます。"

#: ../../library/unittest.rst:1656
msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a :mod:"
"`unittest`-based test framework."
msgstr ""
"このクラスでは :class:`TestCase` インターフェースの内、テストランナーがテスト"
"を実行するためのインターフェースだけを実装しており、テスト結果のチェックやレ"
"ポートに関するメソッドは実装していません。既存のテストコードを :mod:"
"`unittest` によるテストフレームワークに組み込むために使用します。"

#: ../../library/unittest.rst:1666
msgid "Deprecated aliases"
msgstr "非推奨のエイリアス"

#: ../../library/unittest.rst:1668
msgid ""
"For historical reasons, some of the :class:`TestCase` methods had one or "
"more aliases that are now deprecated.  The following table lists the correct "
"names along with their deprecated aliases:"
msgstr ""
"歴史的な経緯で、 :class:`TestCase` のいくつかのエイリアスは非推奨となりまし"
"た。以下の表に、非推奨のエイリアスをまとめます:"

#: ../../library/unittest.rst:1673
msgid "Method Name"
msgstr "メソッド名"

#: ../../library/unittest.rst:1673
msgid "Deprecated alias"
msgstr "非推奨のエイリアス"

#: ../../library/unittest.rst:1675
msgid ":meth:`.assertEqual`"
msgstr ":meth:`.assertEqual`"

#: ../../library/unittest.rst:1675
msgid "failUnlessEqual"
msgstr "failUnlessEqual"

#: ../../library/unittest.rst:1675
msgid "assertEquals"
msgstr "assertEquals"

#: ../../library/unittest.rst:1676
msgid ":meth:`.assertNotEqual`"
msgstr ":meth:`.assertNotEqual`"

#: ../../library/unittest.rst:1676
msgid "failIfEqual"
msgstr "failIfEqual"

#: ../../library/unittest.rst:1676
msgid "assertNotEquals"
msgstr "assertNotEquals"

#: ../../library/unittest.rst:1677
msgid ":meth:`.assertTrue`"
msgstr ":meth:`.assertTrue`"

#: ../../library/unittest.rst:1677
msgid "failUnless"
msgstr "failUnless"

#: ../../library/unittest.rst:1677
msgid "assert\\_"
msgstr "assert\\_"

#: ../../library/unittest.rst:1678
msgid ":meth:`.assertFalse`"
msgstr ":meth:`.assertFalse`"

#: ../../library/unittest.rst:1678
msgid "failIf"
msgstr "failIf"

#: ../../library/unittest.rst:1679
msgid ":meth:`.assertRaises`"
msgstr ":meth:`.assertRaises`"

#: ../../library/unittest.rst:1679
msgid "failUnlessRaises"
msgstr "failUnlessRaises"

#: ../../library/unittest.rst:1680
msgid ":meth:`.assertAlmostEqual`"
msgstr ":meth:`.assertAlmostEqual`"

#: ../../library/unittest.rst:1680
msgid "failUnlessAlmostEqual"
msgstr "failUnlessAlmostEqual"

#: ../../library/unittest.rst:1680
msgid "assertAlmostEquals"
msgstr "assertAlmostEquals"

#: ../../library/unittest.rst:1681
msgid ":meth:`.assertNotAlmostEqual`"
msgstr ":meth:`.assertNotAlmostEqual`"

#: ../../library/unittest.rst:1681
msgid "failIfAlmostEqual"
msgstr "failIfAlmostEqual"

#: ../../library/unittest.rst:1681
msgid "assertNotAlmostEquals"
msgstr "assertNotAlmostEquals"

#: ../../library/unittest.rst:1682
msgid ":meth:`.assertRegex`"
msgstr ":meth:`.assertRegex`"

#: ../../library/unittest.rst:1682
msgid "assertRegexpMatches"
msgstr "assertRegexpMatches"

#: ../../library/unittest.rst:1683
msgid ":meth:`.assertNotRegex`"
msgstr ":meth:`.assertNotRegex`"

#: ../../library/unittest.rst:1683
msgid "assertNotRegexpMatches"
msgstr "assertNotRegexpMatches"

#: ../../library/unittest.rst:1684
msgid ":meth:`.assertRaisesRegex`"
msgstr ":meth:`.assertRaisesRegex`"

#: ../../library/unittest.rst:1684
msgid "assertRaisesRegexp"
msgstr "assertRaisesRegexp"

#: ../../library/unittest.rst:1687
msgid "The fail* aliases listed in the second column have been deprecated."
msgstr "2列目に記載されている fail* エイリアスは非推奨になりました。"

#: ../../library/unittest.rst:1689
msgid "The assert* aliases listed in the third column have been deprecated."
msgstr "3列目に記載されている assert* エイリアスは非推奨になりました。"

#: ../../library/unittest.rst:1691
msgid ""
"``assertRegexpMatches`` and ``assertRaisesRegexp`` have been renamed to :"
"meth:`.assertRegex` and :meth:`.assertRaisesRegex`."
msgstr ""
"``assertRegexpMatches`` は :meth:`assertRegex` に、 ``assertRaisesRegexp`` "
"は :meth:`assertRaisesRegex` にメソッド名が変更されました"

#: ../../library/unittest.rst:1694
msgid ""
"The ``assertNotRegexpMatches`` name is deprecated in favor of :meth:`."
"assertNotRegex`."
msgstr ""
"``assertNotRegexpMatches``という名前は非推奨となり、:meth:`.assertNotRegex`に"
"なりました。"

#: ../../library/unittest.rst:1700
msgid "Grouping tests"
msgstr "テストのグループ化"

#: ../../library/unittest.rst:1704
msgid ""
"This class represents an aggregation of individual test cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""
"このクラスは、個々のテストケースやテストスイートの集合を表現しています。\n"
"通常のテストケースと同じようにテストランナーで実行するためのインターフェース"
"を備えています。 :class:`TestSuite` インスタンスを実行することはスイートをイ"
"テレートして得られる個々のテストを実行することと同じです。"

#: ../../library/unittest.rst:1709
msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional "
"methods are provided to add test cases and suites to the collection later on."
msgstr ""
"引数 *tests* が指定された場合、それはテストケースに亘る繰り返し可能オブジェク"
"トまたは内部でスイートを組み立てるための他のテストスイートでなければなりませ"
"ん。後からテストケースやスイートをコレクションに付け加えるためのメソッドも提"
"供されています。"

#: ../../library/unittest.rst:1713
msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""
":class:`TestSuite` は :class:`TestCase` オブジェクトのように振る舞います。違"
"いは、スイートにはテストを実装しない点にあります。代わりに、テストをまとめて"
"グループ化して、同時に実行します。 :class:`TestSuite` のインスタンスにテスト"
"追加するためのメソッドが用意されています:"

#: ../../library/unittest.rst:1721
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr ""
":class:`TestCase` 又は :class:`TestSuite` のインスタンスをスイートに追加しま"
"す。"

#: ../../library/unittest.rst:1726
msgid ""
"Add all the tests from an iterable of :class:`TestCase` and :class:"
"`TestSuite` instances to this test suite."
msgstr ""
"イテラブル *tests* に含まれる全ての :class:`TestCase` 又は :class:"
"`TestSuite` のインスタンスをスイートに追加します。"

#: ../../library/unittest.rst:1729
msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr ""
"このメソッドは *tests* 上のイテレーションをしながらそれぞれの要素に :meth:"
"`addTest` を呼び出すのと等価です。"

#: ../../library/unittest.rst:1732
msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ""
":class:`TestSuite` クラスは :class:`TestCase` と以下のメソッドを共有します:"

#: ../../library/unittest.rst:1737
msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike :meth:`TestCase."
"run`, :meth:`TestSuite.run` requires the result object to be passed in."
msgstr ""
"スイート内のテストを実行し、結果を *result* で指定した結果オブジェクトに収集"
"します。 :meth:`TestCase.run` と異なり、 :meth:`TestSuite.run` では必ず結果オ"
"ブジェクトを指定する必要があります。"

#: ../../library/unittest.rst:1745
msgid ""
"Run the tests associated with this suite without collecting the result. This "
"allows exceptions raised by the test to be propagated to the caller and can "
"be used to support running tests under a debugger."
msgstr ""
"このスイートに関連づけられたテストを結果を収集せずに実行します。これによりテ"
"ストで送出された例外は呼び出し元に伝わるようになり、デバッガの下でのテスト実"
"行をサポートできるようになります。"

#: ../../library/unittest.rst:1752
msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr ""
"このテストオブジェクトによって表現されるテストの数を返します。これには個別の"
"テストと下位のスイートも含まれます。"

#: ../../library/unittest.rst:1758
msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`__iter__`. Note "
"that this method may be called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned by "
"repeated iterations before :meth:`TestSuite.run` must be the same for each "
"call iteration. After :meth:`TestSuite.run`, callers should not rely on the "
"tests returned by this method unless the caller uses a subclass that "
"overrides :meth:`TestSuite._removeTestAtIndex` to preserve test references."
msgstr ""
":class:`TestSuite` でグループ化されたテストは反復アクセスできます。\n"
"サブクラスは :meth:`__iter__` をオーバーライドすることで、遅延処理でテストを"
"提供できます。\n"
"1つのスイート内でこのメソッドは何度も呼ばれる可能性があることに注意してくださ"
"い (例えば、テスト数のカウントや等価性の比較)。\n"
"そのため、 :meth:`TestSuite.run` を実行する前に反復アクセスを何度繰り返しても"
"同じテスト群を返すようにしなければなりません。\n"
"呼び出し側が :meth:`TestSuite._removeTestAtIndex` をオーバーライドしたサブク"
"ラスを使いテストへの参照を保存していない限り、 :meth:`TestSuite.run` を実行し"
"た後はこのメソッドが返すテスト群を信頼すべきではありません。"

#: ../../library/unittest.rst:1768
msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`__iter__` wasn't sufficient for "
"providing tests."
msgstr ""
"以前のバージョンでは :class:`TestSuite` はイテレータではなく、直接テストにア"
"クセスしていました。そのため、 :meth:`__iter__` をオーバーラードしてもテスト"
"にアクセスできませんでした。"

#: ../../library/unittest.rst:1773
msgid ""
"In earlier versions the :class:`TestSuite` held references to each :class:"
"`TestCase` after :meth:`TestSuite.run`. Subclasses can restore that behavior "
"by overriding :meth:`TestSuite._removeTestAtIndex`."
msgstr ""
"以前のバージョンでは、 :meth:`TestSuite.run` の実行後は :class:`TestSuite` が"
"各 :class:`TestCase` への参照を保持していました。\n"
"サブクラスで :meth:`TestSuite._removeTestAtIndex` をオーバーライドすることで"
"この振る舞いを復元できます。"

#: ../../library/unittest.rst:1778
msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test harness."
msgstr ""
"通常、 :class:`TestSuite` の :meth:`run` メソッドは :class:`TestRunner` が起"
"動するため、ユーザが直接実行する必要はありません。"

#: ../../library/unittest.rst:1783
msgid "Loading and running tests"
msgstr "テストのロードと起動"

#: ../../library/unittest.rst:1787
msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and "
"modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as :data:"
"`unittest.defaultTestLoader`.  Using a subclass or instance, however, allows "
"customization of some configurable properties."
msgstr ""
":class:`TestLoader` クラスはクラスとモジュールからテストスイートを生成しま"
"す。通常、このクラスのインスタンスを明示的に生成する必要はありません。 :mod:"
"`unittest` モジュールの :data:`unittest.defaultTestLoader` を共用インスタンス"
"として使用することができます。 しかし、このクラスのサブクラスやインスタンス"
"で、属性をカスタマイズすることができます。"

#: ../../library/unittest.rst:1793
msgid ":class:`TestLoader` objects have the following attributes:"
msgstr ":class:`TestLoader` オブジェクトには以下の属性があります:"

#: ../../library/unittest.rst:1798
msgid ""
"A list of the non-fatal errors encountered while loading tests. Not reset by "
"the loader at any point. Fatal errors are signalled by the relevant method "
"raising an exception to the caller. Non-fatal errors are also indicated by a "
"synthetic test that will raise the original error when run."
msgstr ""
"テストの読み込み中に起きた致命的でないエラーのリストです。\n"
"どの時点でもローダーからリセットされることはありません。\n"
"致命的なエラーは適切なメソッドが例外を送出して、呼び出し元に通知します。\n"
"致命的でないエラーも、実行したときのエラーを総合テストが通知してくれます。"

#: ../../library/unittest.rst:1807
msgid ":class:`TestLoader` objects have the following methods:"
msgstr ":class:`TestLoader` のオブジェクトには以下のメソッドがあります:"

#: ../../library/unittest.rst:1812
msgid ""
"Return a suite of all test cases contained in the :class:`TestCase`\\ -"
"derived :class:`testCaseClass`."
msgstr ""
":class:`TestCase` の派生クラス :class:`testCaseClass` に含まれる全テストケー"
"スのスイートを返します。"

#: ../../library/unittest.rst:1815
msgid ""
"A test case instance is created for each method named by :meth:"
"`getTestCaseNames`. By default these are the method names beginning with "
"``test``. If :meth:`getTestCaseNames` returns no methods, but the :meth:"
"`runTest` method is implemented, a single test case is created for that "
"method instead."
msgstr ""
":meth:`getTestCaseNames` で指定されたメソッドに対し、テストケースインスタンス"
"が作成されます。\n"
"デフォルトでは ``test`` で始まる名前のメソッド群です。\n"
":meth:`getTestCaseNames` がメソッド名を返さなかったが、 :meth:`runTest` メ"
"ソッドが実装されている場合は、そのメソッドに対するテストケースが代わりに作成"
"されます。"

#: ../../library/unittest.rst:1824
msgid ""
"Return a suite of all test cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""
"指定したモジュールに含まれる全テストケースのスイートを返します。このメソッド"
"は *module* 内の :class:`TestCase` 派生クラスを検索し、見つかったクラスのテス"
"トメソッドごとにクラスのインスタンスを作成します。"

#: ../../library/unittest.rst:1831
msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""
":class:`TestCase` クラスを基底クラスとしてクラス階層を構築するとテストフィク"
"スチャや補助的な関数をうまく共用することができますが、基底クラスに直接インス"
"タンス化できないテストメソッドがあると、この :meth:`loadTestsFromModule` を使"
"うことができません。この場合でも、 fixture が全て別々で定義がサブクラスにある"
"場合は使用することができます。"

#: ../../library/unittest.rst:1837
msgid ""
"If a module provides a ``load_tests`` function it will be called to load the "
"tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_.  The *pattern* argument is passed as the third "
"argument to ``load_tests``."
msgstr ""
"モジュールが ``load_tests`` 関数を用意している場合、この関数がテストの読み込"
"みに使われます。\n"
"これによりテストの読み込み処理がカスタマイズできます。\n"
"これが `load_tests プロトコル`_ です。\n"
"*pattern* 引数は ``load_tests`` に第3引数として渡されます。"

#: ../../library/unittest.rst:1842
msgid "Support for ``load_tests`` added."
msgstr "``load_tests`` のサポートが追加されました。"

#: ../../library/unittest.rst:1845
msgid ""
"The undocumented and unofficial *use_load_tests* default argument is "
"deprecated and ignored, although it is still accepted for backward "
"compatibility.  The method also now accepts a keyword-only argument "
"*pattern* which is passed to ``load_tests`` as the third argument."
msgstr ""
"ドキュメントにない、非公式の *use_load_tests* デフォルト引数は非推奨で、後方"
"互換性のために残されていますが無視されます。\n"
"また、このメソッドはキーワード専用引数 *pattern* を受け取るようになりました。"
"これは ``load_tests`` の第三引数に渡されます。"

#: ../../library/unittest.rst:1854
msgid "Return a suite of all test cases given a string specifier."
msgstr "文字列で指定される全テストケースを含むスイートを返します。"

#: ../../library/unittest.rst:1856
msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a :class:"
"`TestSuite` instance, or a callable object which returns a :class:`TestCase` "
"or :class:`TestSuite` instance.  These checks are applied in the order "
"listed here; that is, a method on a possible test case class will be picked "
"up as \"a test method within a test case class\", rather than \"a callable "
"object\"."
msgstr ""
"*name* には \"ドット修飾名\" でモジュールかテストケースクラス、テストケースク"
"ラス内のメソッド、 :class:`TestSuite` インスタンスまたは :class:`TestCase` "
"か :class:`TestSuite` のインスタンスを返す呼び出し可能オブジェクトを指定しま"
"す。このチェックはここで挙げた順番に行なわれます。すなわち、候補テストケース"
"クラス内のメソッドは「呼び出し可能オブジェクト」としてではなく「テストケース"
"クラス内のメソッド」として拾い出されます。"

#: ../../library/unittest.rst:1864
msgid ""
"For example, if you have a module :mod:`SampleTests` containing a :class:"
"`TestCase`\\ -derived class :class:`SampleTestCase` with three test methods "
"(:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the specifier "
"``'SampleTests.SampleTestCase'`` would cause this method to return a suite "
"which will run all three test methods. Using the specifier ``'SampleTests."
"SampleTestCase.test_two'`` would cause it to return a test suite which will "
"run only the :meth:`test_two` test method. The specifier can refer to "
"modules and packages which have not been imported; they will be imported as "
"a side-effect."
msgstr ""
"例えば :mod:`SampleTests` モジュールに :class:`TestCase` から派生した :class:"
"`SampleTestCase` クラスがあり、 :class:`SampleTestCase` にはテストメソッド :"
"meth:`test_one` ・ :meth:`test_two` ・ :meth:`test_three` があるとします。こ"
"の場合、 *name* に ``'SampleTests.SampleTestCase'`` と指定すると、 :class:"
"`SampleTestCase` の三つのテストメソッドを実行するテストスイートが作成されま"
"す。 ``'SampleTests.SampleTestCase.test_two'`` と指定すれば、 :meth:"
"`test_two` だけを実行するテストスイートが作成されます。インポートされていない"
"モジュールやパッケージ名を含んだ名前を指定した場合は自動的にインポートされま"
"す。"

#: ../../library/unittest.rst:1874
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr "また、*module* を指定した場合、*module* 内の *name* を取得します。"

#: ../../library/unittest.rst:1876
msgid ""
"If an :exc:`ImportError` or :exc:`AttributeError` occurs while traversing "
"*name* then a synthetic test that raises that error when run will be "
"returned. These errors are included in the errors accumulated by self.errors."
msgstr ""
"*name* を巡回している間に :exc:`ImportError` か :exc:`AttributeError` が発生"
"した場合、実行するとその例外を発生させるようなテストを合成して返します。それ"
"らのエラーは self.errors に集められます。"

#: ../../library/unittest.rst:1885
msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the "
"tests defined for each name."
msgstr ""
":meth:`loadTestsFromName` と同じですが、名前を一つだけ指定するのではなく、複"
"数の名前のシーケンスを指定する事ができます。戻り値は *names* 中の名前で指定さ"
"れるテスト全てを含むテストスイートです。"

#: ../../library/unittest.rst:1892
msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr ""
"*testCaseClass* 中の全てのメソッド名を含むソート済みシーケンスを返します。 "
"*testCaseClass* は :class:`TestCase` のサブクラスでなければなりません。"

#: ../../library/unittest.rst:1898
msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them. "
"Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""
"指定された開始ディレクトリからサブディレクトリに再帰することですべてのテスト"
"モジュールを検索し、それらを含む TestSuite オブジェクトを返します。*pattern* "
"にマッチしたテストファイルだけがロードの対象になります。 (シェルスタイルのパ"
"ターンマッチングが使われます)。その中で、インポート可能なもジュール (つまり "
"Python の識別子として有効であるということです) がロードされます。"

#: ../../library/unittest.rst:1904
msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then the top level "
"directory must be specified separately."
msgstr ""
"すべてのテストモジュールはプロジェクトのトップレベルからインポート可能である"
"必要があります。開始ディレクトリがトップレベルディレクトリでない場合は、トッ"
"プレベルディレクトリを個別に指定しなければなりません。"

#: ../../library/unittest.rst:1908
msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue.  If the "
"import failure is due to :exc:`SkipTest` being raised, it will be recorded "
"as a skip instead of an error."
msgstr ""
"シンタックスエラーなどでモジュールのインポートに失敗した場合、エラーが記録さ"
"れ、ディスカバリ自体は続けられます。 import  の失敗が :exc:`SkipTest` 例外が"
"発生したためだった場合は、そのモジュールはエラーではなく skip として記録され"
"ます。"

#: ../../library/unittest.rst:1913
msgid ""
"If a package (a directory containing a file named :file:`__init__.py`) is "
"found, the package will be checked for a ``load_tests`` function. If this "
"exists then it will be called ``package.load_tests(loader, tests, "
"pattern)``. Test discovery takes care to ensure that a package is only "
"checked for tests once during an invocation, even if the load_tests function "
"itself calls ``loader.discover``."
msgstr ""
"パッケージ (:file:`__init__.py` という名前のファイルがあるディレクトリ) が見"
"付かった場合、そのパッケージに ``load_tests`` 関数があるかをチェックしま"
"す。\n"
"関数があった場合、次に ``package.load_tests(loader, tests, pattern)`` が呼ば"
"れます。\n"
"テストの検索の実行では、たとえ load_tests 関数自身が ``loader.discover`` を呼"
"んだとしても、パッケージのチェックは1回のみとなることが保証されています。"

#: ../../library/unittest.rst:1921
msgid ""
"If ``load_tests`` exists then discovery does *not* recurse into the package, "
"``load_tests`` is responsible for loading all tests in the package."
msgstr ""
"``load_tests`` が存在して、ディスカバリがパッケージ内を再帰的な検索を続けてい"
"る途中で *ない* 場合、``load_tests`` はそのパッケージ内の全てのテストをロード"
"する責務を担います。"

#: ../../library/unittest.rst:1925
msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves. *top_level_dir* is stored so "
"``load_tests`` does not need to pass this argument in to ``loader."
"discover()``."
msgstr ""
"意図的にパターンはローダの属性として保持されないようになっています。それによ"
"り、パッケージが自分自身のディスカバリを続ける事ができます。*top_level_dir* "
"は保持されるため、``load_tests`` はこの引数を ``loader.discover()`` に渡す必"
"要はありません。"

#: ../../library/unittest.rst:1930
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr "*start_dir* はドット付のモジュール名でもディレクトリでも構いません。"

#: ../../library/unittest.rst:1934
msgid ""
"Modules that raise :exc:`SkipTest` on import are recorded as skips, not "
"errors."
msgstr ""
"インポート時に :exc:`SkipTest` を送出するモジュールはエラーではなくスキップと"
"して記録されます。"

#: ../../library/unittest.rst:1938
msgid "*start_dir* can be a :term:`namespace packages <namespace package>`."
msgstr ""
"*start_dir*に:term:`名前空間パッケージ <namespace package>`を指定できます。"

#: ../../library/unittest.rst:1941
msgid ""
"Paths are sorted before being imported so that execution order is the same "
"even if the underlying file system's ordering is not dependent on file name."
msgstr ""
"ファイルシステムの順序がファイル名に従わないとしても実行順序が一定になるよう"
"に、パスはインポートする前にソートされます。"

#: ../../library/unittest.rst:1946
msgid ""
"Found packages are now checked for ``load_tests`` regardless of whether "
"their path matches *pattern*, because it is impossible for a package name to "
"match the default pattern."
msgstr ""
"パッケージ名がデフォルトのパターンに適合するのは不可能なので、パスが "
"*pattern* に適合するかどうかに関係無く、見付けたパッケージに ``load_tests`` "
"があるかをチェックするようになりました。"

#: ../../library/unittest.rst:1951
msgid ""
"*start_dir* can not be a :term:`namespace packages <namespace package>`. It "
"has been broken since Python 3.7 and Python 3.11 officially remove it."
msgstr ""

#: ../../library/unittest.rst:1956
msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ""
"以下の属性は、サブクラス化またはインスタンスの属性値を変更して :class:"
"`TestLoader` をカスタマイズする場合に使用します:"

#: ../../library/unittest.rst:1962
msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr ""
"テストメソッドの名前と判断されるメソッド名の接頭語を示す文字列。デフォルト値"
"は ``'test'`` です。"

#: ../../library/unittest.rst:1965
msgid ""
"This affects :meth:`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` "
"methods."
msgstr ""
"この値は :meth:`getTestCaseNames` と全ての :meth:`loadTestsFrom\\*` メソッド"
"に影響を与えます。"

#: ../../library/unittest.rst:1971
msgid ""
"Function to be used to compare method names when sorting them in :meth:"
"`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` methods."
msgstr ""
":meth:`getTestCaseNames` および全ての :meth:`loadTestsFrom\\*` メソッドでメ"
"ソッド名をソートする際に使用する比較関数。"

#: ../../library/unittest.rst:1977
msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the :class:"
"`TestSuite` class."
msgstr ""
"テストのリストからテストスイートを構築する呼び出し可能オブジェクト。メソッド"
"を持つ必要はありません。デフォルト値は :class:`TestSuite` です。"

#: ../../library/unittest.rst:1981 ../../library/unittest.rst:1994
msgid "This affects all the :meth:`loadTestsFrom\\*` methods."
msgstr "この値は全ての :meth:`loadTestsFrom\\*` メソッドに影響を与えます。"

#: ../../library/unittest.rst:1985
msgid ""
"List of Unix shell-style wildcard test name patterns that test methods have "
"to match to be included in test suites (see ``-k`` option)."
msgstr ""
"テストメソッドがテストスイートに含まれるためにマッチしなければならないUnix"
"シェルスタイルのワイルドカードテスト名パターンのリストです(``-k``オプションを"
"参照)。"

#: ../../library/unittest.rst:1988
msgid ""
"If this attribute is not ``None`` (the default), all test methods to be "
"included in test suites must match one of the patterns in this list. Note "
"that matches are always performed using :meth:`fnmatch.fnmatchcase`, so "
"unlike patterns passed to the ``-k`` option, simple substring patterns will "
"have to be converted using ``*`` wildcards."
msgstr ""
"この属性が``None`` (デフォルト)でない場合、テストスイートに含まれるすべてのテ"
"ストメソッドはこのリストのパターンのいずれかにマッチしていなければなりませ"
"ん。マッチは常に :meth:`fnmatch.fnmatchcase`を使用して実行されるため、``-k``"
"オプションに渡されるパターンとは異なり、単純な部分文字列パターンは ``*``ワイ"
"ルドカードを使用して変換する必要があることに注意してください。"

#: ../../library/unittest.rst:2001
msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr ""
"このクラスはどのテストが成功しどのテストが失敗したかという情報を収集するのに"
"使います。"

#: ../../library/unittest.rst:2004
msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The :"
"class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""
":class:`TestResult` は、複数のテスト結果を記録します。 :class:`TestCase` クラ"
"スと :class:`TestSuite` クラスのテスト結果を正しく記録しますので、テスト開発"
"者が独自にテスト結果を管理する処理を開発する必要はありません。"

#: ../../library/unittest.rst:2009
msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the :"
"class:`TestResult` object generated by running a set of tests for reporting "
"purposes; a :class:`TestResult` instance is returned by the :meth:"
"`TestRunner.run` method for this purpose."
msgstr ""
":mod:`unittest` を利用したテストフレームワークでは、 :meth:`TestRunner.run` "
"が返す :class:`TestResult` インスタンスを参照し、テスト結果をレポートします。"

#: ../../library/unittest.rst:2014
msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ""
":class:`TestResult` インスタンスの以下の属性は、テストの実行結果を検査する際"
"に使用することができます:"

#: ../../library/unittest.rst:2020
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr ""
":class:`TestCase` と例外のトレースバック情報をフォーマットした文字列の 2 要素"
"タプルからなるリスト。それぞれのタプルは予想外の例外を送出したテストに対応し"
"ます。"

#: ../../library/unittest.rst:2026
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :meth:`TestCase.assert\\*` methods."
msgstr ""
":class:`TestCase` と例外のトレースバック情報をフォーマットした文字列の 2 要素"
"タプルからなるリスト。それぞれのタプルは :meth:`TestCase.assert\\*` メソッド"
"を使って見つけ出した失敗に対応します。"

#: ../../library/unittest.rst:2032
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr ""
":class:`TestCase` インスタンスとテストをスキップした理由を保持する文字列の2要"
"素タプルからなるリストです。"

#: ../../library/unittest.rst:2039
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure or "
"error of the test case."
msgstr ""
":class:`TestCase` と例外のトレースバック情報をフォーマット済の文字列の 2 要素"
"タプルからなるリストです。それぞれのタプルは予期された失敗またはエラーに対応"
"します。"

#: ../../library/unittest.rst:2045
msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr ""
"予期された失敗とされていながら成功してしまった :class:`TestCase` のインスタン"
"スのリスト。"

#: ../../library/unittest.rst:2050
msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr "``True`` が設定されると :meth:`stop` によりテストの実行が停止します。"

#: ../../library/unittest.rst:2054
msgid "The total number of tests run so far."
msgstr "これまでに実行したテストの総数です。"

#: ../../library/unittest.rst:2058
msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""
"``True`` が設定されると、 ``sys.stdout`` と ``sys.stderr`` は、 :meth:"
"`startTest` から :meth:`stopTest` が呼ばれるまでの間バッファリングされます。"
"実際に、結果が ``sys.stdout`` と ``sys.stderr`` に出力されるのは、テストが失"
"敗するかエラーが発生した時になります。表示の際には、全ての失敗 / エラーメッ"
"セージが表示されます。"

#: ../../library/unittest.rst:2067
msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr ""
"真の場合 :meth:`stop` が始めの失敗もしくはエラーの時に呼び出され、テストの実"
"行が終了します。"

#: ../../library/unittest.rst:2074
msgid "If set to true then local variables will be shown in tracebacks."
msgstr "真の場合、局所変数がトレースバックに表示されます。"

#: ../../library/unittest.rst:2080
msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr ""
"これまでに実行したテストが全て成功していれば ``True`` を、それ以外なら "
"``False`` を返します。"

#: ../../library/unittest.rst:2083
msgid ""
"Returns ``False`` if there were any :attr:`unexpectedSuccesses` from tests "
"marked with the :func:`expectedFailure` decorator."
msgstr ""
":func:`expectedFailure` デコレ－タでマークされたテストに :attr:"
"`unexpectedSuccesses` があった場合 ``False`` を返します。"

#: ../../library/unittest.rst:2089
msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. :class:"
"`TestRunner` objects should respect this flag and return without running any "
"additional tests."
msgstr ""
"このメソッドを呼び出して :class:`TestResult` の :attr:`shouldStop` 属性に "
"``True`` をセットすることで、実行中のテストは中断しなければならないというシグ"
"ナルを送ることができます。 :class:`TestRunner` オブジェクトはこのフラグを順守"
"してそれ以上のテストを実行することなく復帰しなければなりません。"

#: ../../library/unittest.rst:2094
msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""
"たとえばこの機能は、ユーザのキーボード割り込みを受け取って :class:"
"`TextTestRunner` クラスがテストフレームワークを停止させるのに使えます。 :"
"class:`TestRunner` の実装を提供する対話的なツールでも同じように使用することが"
"できます。"

#: ../../library/unittest.rst:2099
msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""
":class:`TestResult` クラスの以下のメソッドは内部データ管理用のメソッドです"
"が、対話的にテスト結果をレポートするテストツールを開発する場合などにはサブク"
"ラスで拡張することができます。"

#: ../../library/unittest.rst:2107
msgid "Called when the test case *test* is about to be run."
msgstr "*test* を実行する直前に呼び出されます。"

#: ../../library/unittest.rst:2111
msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr "*test* の実行直後に、テスト結果に関わらず呼び出されます。"

#: ../../library/unittest.rst:2116
msgid "Called once before any tests are executed."
msgstr "全てのテストが実行される前に一度だけ実行されます。"

#: ../../library/unittest.rst:2123
msgid "Called once after all tests are executed."
msgstr "全てのテストが実行された後に一度だけ実行されます。"

#: ../../library/unittest.rst:2130
msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""
"テスト *test* 実行中に、想定外の例外が発生した場合に呼び出されます。 *err* "
"は :func:`sys.exc_info` が返すタプル ``(type, value, traceback)`` です。"

#: ../../library/unittest.rst:2134
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"デフォルトの実装では、タプル、 ``(test, formatted_err)`` をインスタンスの :"
"attr:`errors` 属性に追加します。ここで、 *formatted_err* は、 *err* から導出"
"される、整形されたトレースバックです。"

#: ../../library/unittest.rst:2141
msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"テストケース *test* が失敗した場合に呼び出されます。 *err* は :func:`sys."
"exc_info` が返すタプル ``(type, value, traceback)`` です。"

#: ../../library/unittest.rst:2144
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"デフォルトの実装では、タプル、 ``(test, formatted_err)`` をインスタンスの :"
"attr:`failures` 属性に追加します。ここで、 *formatted_err* は、 *err* から導"
"出される、整形されたトレースバックです。"

#: ../../library/unittest.rst:2151
msgid "Called when the test case *test* succeeds."
msgstr "テストケース *test* が成功した場合に呼び出されます。"

#: ../../library/unittest.rst:2153
msgid "The default implementation does nothing."
msgstr "デフォルトの実装では何もしません。"

#: ../../library/unittest.rst:2158
msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr ""
"*test* がスキップされた時に呼び出されます。*reason* はスキップの際に渡された"
"理由の文字列です。"

#: ../../library/unittest.rst:2161
msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr ""
"デフォルトの実装では、 ``(test, reason)`` のタプルをインスタンスの :attr:"
"`skipped` 属性に追加します。"

#: ../../library/unittest.rst:2167
msgid ""
"Called when the test case *test* fails or errors, but was marked with the :"
"func:`expectedFailure` decorator."
msgstr ""
":func:`expectedFailure` のデコレータでマークされた *test* が失敗またはエラー"
"の時に呼び出されます。"

#: ../../library/unittest.rst:2170
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""
"デフォルトの実装では ``(test, formatted_err)`` のタプルをインスタンスの :"
"attr:`expectedFailures` に追加します。ここで *formatted_err* は *err* から派"
"生した整形されたトレースバックです。"

#: ../../library/unittest.rst:2177
msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure` "
"decorator, but succeeded."
msgstr ""
":func:`expectedFailure` のデコレータでマークされた *test* が成功した時に呼び"
"出されます。"

#: ../../library/unittest.rst:2180
msgid ""
"The default implementation appends the test to the instance's :attr:"
"`unexpectedSuccesses` attribute."
msgstr ""
"デフォルトの実装ではテストをインスタンスの :attr:`unexpectedSuccesses` 属性に"
"追加します。"

#: ../../library/unittest.rst:2186
msgid ""
"Called when a subtest finishes.  *test* is the test case corresponding to "
"the test method.  *subtest* is a custom :class:`TestCase` instance "
"describing the subtest."
msgstr ""
"サブテストが終了すると呼ばれます。\n"
"*test* はテストメソッドに対応するテストケースです。\n"
"*subtest* はサブテストを記述するカスタムの :class:`TestCase` インスタンスで"
"す。"

#: ../../library/unittest.rst:2190
msgid ""
"If *outcome* is :const:`None`, the subtest succeeded.  Otherwise, it failed "
"with an exception where *outcome* is a tuple of the form returned by :func:"
"`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"*outcome* が :const:`None` の場合サブテストは成功です。\n"
"それ以外の場合は失敗で、:func:`sys.exc_info` が返す形式 ``(type, value, "
"traceback)`` の *outcome* を持つ例外を伴います。"

#: ../../library/unittest.rst:2194
msgid ""
"The default implementation does nothing when the outcome is a success, and "
"records subtest failures as normal failures."
msgstr ""
"結果が成功の場合デフォルトの実装では何もせず、サブテストの失敗を通常の失敗と"
"して報告します。"

#: ../../library/unittest.rst:2202
msgid ""
"A concrete implementation of :class:`TestResult` used by the :class:"
"`TextTestRunner`."
msgstr ""
":class:`TextTestRunner` に使用される :class:`TestResult` の具象実装です。"

#: ../../library/unittest.rst:2205
msgid ""
"This class was previously named ``_TextTestResult``. The old name still "
"exists as an alias but is deprecated."
msgstr ""
"このクラスは以前 ``_TextTestResult`` という名前でした。以前の名前はエイリアス"
"として残っていますが非推奨です。"

#: ../../library/unittest.rst:2212
msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""
":class:`TestLoader` のインスタンスで、共用することが目的です。 :class:"
"`TestLoader` をカスタマイズする必要がなければ、新しい :class:`TestLoader` オ"
"ブジェクトを作らずにこのインスタンスを使用します。"

#: ../../library/unittest.rst:2220
msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the output "
"stream. This class has a few configurable parameters, but is essentially "
"very simple.  Graphical applications which run test suites should provide "
"alternate implementations. Such implementations should accept ``**kwargs`` "
"as the interface to construct runners changes when features are added to "
"unittest."
msgstr ""
"結果をストリームに出力する、基本的なテストランナーの実装です。\n"
"*stream* が ``None`` の場合、デフォルトで :data:`sys.stderr` が出力ストリーム"
"として使われます。\n"
"このクラスはいくつかの設定項目があるだけで、基本的に非常に単純です。\n"
"グラフィカルなテスト実行アプリケーションでは、独自のテストランナーを実装して"
"ください。\n"
"テストランナーの実装は、 unittest に新しい機能が追加されランナーを構築するイ"
"ンターフェースが変更されたときに備えて ``**kwargs`` を受け取れるようにするべ"
"きです。"

#: ../../library/unittest.rst:2227
msgid ""
"By default this runner shows :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` and :exc:`ImportWarning` "
"even if they are :ref:`ignored by default <warning-ignored>`. Deprecation "
"warnings caused by :ref:`deprecated unittest methods <deprecated-aliases>` "
"are also special-cased and, when the warning filters are ``'default'`` or "
"``'always'``, they will appear only once per-module, in order to avoid too "
"many warning messages.  This behavior can be overridden using Python's :"
"option:`!-Wd` or :option:`!-Wa` options (see :ref:`Warning control <using-on-"
"warnings>`) and leaving *warnings* to ``None``."
msgstr ""
":ref:`デフォルトで無視 <warning-ignored>` に設定されているとしても、このラン"
"ナーのデフォルトでは :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning`, :exc:`ImportWarning` を"
"表示します。\n"
":ref:`unittest の非推奨メソッド <deprecated-aliases>` で起きた非推奨警告も特"
"別な場合として扱われ、警告フィルタが ``'default'`` もしくは ``'always'`` だっ"
"たとき、対象の警告メッセージが出ないようにモジュールごとに1回だけ表示されま"
"す。\n"
"Python の :option:`!-Wd` オプションや :option:`!-Wa` オプション (:ref:`警告の"
"制御 <using-on-warnings>` を参照してください) を使ったり、 *warnings* を "
"``None`` にしたりしておくと、この動作を上書きできます。"

#: ../../library/unittest.rst:2238
msgid "Added the ``warnings`` argument."
msgstr "``warnings`` 引数が追加されました。"

#: ../../library/unittest.rst:2241
msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time rather "
"than import time."
msgstr ""
"インポート時でなくインスタンス化時にデフォルトのストリームが :data:`sys."
"stderr` に設定されます。"

#: ../../library/unittest.rst:2245
msgid "Added the tb_locals parameter."
msgstr "tb_locals 引数が追加されました。"

#: ../../library/unittest.rst:2250
msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""
"このメソッドは :meth:`run` で使われる ``TestResult`` のインスタンスを返しま"
"す。このメソッドは明示的に呼び出す必要はありませんが、サブクラスで "
"``TestResult`` をカスタマイズすることができます。"

#: ../../library/unittest.rst:2254
msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""
"``_makeResult()`` は、 ``TextTestRunner`` のコンストラクタで ``resultclass`` "
"引数として渡されたクラスもしくはコーラブルオブジェクトをインスタンス化しま"
"す。 ``resultclass`` が指定されていない場合には、デフォルトで :class:"
"`TextTestResult` が使用されます。結果のクラスは以下の引数が渡されインスタンス"
"化されます::"

#: ../../library/unittest.rst:2263
msgid ""
"This method is the main public interface to the ``TextTestRunner``. This "
"method takes a :class:`TestSuite` or :class:`TestCase` instance. A :class:"
"`TestResult` is created by calling :func:`_makeResult` and the test(s) are "
"run and the results printed to stdout."
msgstr ""
"このメソッドは ``TextTestRunner`` へのメインの公開インターフェースです。\n"
"このメソッドは :class:`TestSuite` インスタンスあるいは :class:`TestCase` イン"
"スタンスを受け取ります。\n"
":func:`_makeResult` が呼ばれて :class:`TestResult` が作成され、テストが実行さ"
"れ、結果が標準出力に表示されます。"

#: ../../library/unittest.rst:2274
msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The "
"simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr ""
"*module* から複数のテストを読み込んで実行するためのコマンドラインプログラム。"
"この関数を使えば、簡単に実行可能なテストモジュールを作成する事ができます。一"
"番簡単なこの関数の使い方は、以下の行をテストスクリプトの最後に置くことです::"

#: ../../library/unittest.rst:2282
msgid ""
"You can run tests with more detailed information by passing in the verbosity "
"argument::"
msgstr "より詳細な情報は verbosity 引数を指定して実行すると得られます::"

#: ../../library/unittest.rst:2288
msgid ""
"The *defaultTest* argument is either the name of a single test or an "
"iterable of test names to run if no test names are specified via *argv*.  If "
"not specified or ``None`` and no test names are provided via *argv*, all "
"tests found in *module* are run."
msgstr ""
"*defaultTest* 引数は、 *argv* にテスト名が指定されていない場合に実行する、あ"
"る1つのテストの名前もしくはテスト名のイテラブルです。\n"
"この引数を指定しないか ``None`` を指定し、かつ *argv* にテスト名が与えられな"
"い場合は、 *module* にある全てのテストを実行します。"

#: ../../library/unittest.rst:2293
msgid ""
"The *argv* argument can be a list of options passed to the program, with the "
"first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr ""
"*argv* 引数には、プログラムに渡されたオプションのリストを、最初の要素がプログ"
"ラム名のままで渡せます。指定しないか ``None`` の場合は :data:`sys.argv` が使"
"われます。"

#: ../../library/unittest.rst:2297
msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success or failure of the tests run."
msgstr ""
"引数、 *testRunner* は、test runner class、あるいは、そのインスタンスのどちら"
"でも構いません。でフォルトでは ``main`` はテストが成功したか失敗したかに対応"
"した終了コードと共に :func:`sys.exit` を呼び出します。"

#: ../../library/unittest.rst:2301
msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""
"*testLoader* 引数は :class:`TestLoader` インスタンスでなければなりません。デ"
"フォルトは :data:`defaultTestLoader` です。"

#: ../../library/unittest.rst:2304
msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""
"``main`` は、 ``exit=False`` を指定する事で対話的なインタプリタから使用するこ"
"ともできます。この引数を指定すると、 :func:`sys.exit` を呼ばずに、結果のみを"
"出力します::"

#: ../../library/unittest.rst:2311
msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as "
"the same-name `command-line options`_."
msgstr ""
"*failfast*, *catchbreak*, *buffer* は、`コマンドラインオプション`_ にある同名"
"のオプションと同じ効果のあるパラメータです。"

#: ../../library/unittest.rst:2314
msgid ""
"The *warnings* argument specifies the :ref:`warning filter <warning-filter>` "
"that should be used while running the tests.  If it's not specified, it will "
"remain ``None`` if a :option:`!-W` option is passed to :program:`python` "
"(see :ref:`Warning control <using-on-warnings>`), otherwise it will be set "
"to ``'default'``."
msgstr ""
"*warnings* 引数では、テストの実行中に使うべき :ref:`警告フィルタ <warning-"
"filter>` を指定します。\n"
"この引数が指定されない場合には、 :option:`!-W` オプションが :program:"
"`python` に渡されていなければ ``None`` のまま (:ref:`警告の制御 <using-on-"
"warnings>` を参照してください) で、そうでなければ ``'default'`` が設定されま"
"す。"

#: ../../library/unittest.rst:2320
msgid ""
"Calling ``main`` actually returns an instance of the ``TestProgram`` class. "
"This stores the result of the tests run as the ``result`` attribute."
msgstr ""
"``main`` を呼び出すと、``TestProgram`` のインスタンスが返されます。このインス"
"タンスは、``result`` 属性にテスト結果を保持します。"

#: ../../library/unittest.rst:2323
msgid "The *exit* parameter was added."
msgstr "*exit* パラメータが追加されました。"

#: ../../library/unittest.rst:2326
msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr ""
"*verbosity*、*failfast*、*catchbreak*、*buffer*、*warnings* 引数が追加されま"
"した。"

#: ../../library/unittest.rst:2330
msgid ""
"The *defaultTest* parameter was changed to also accept an iterable of test "
"names."
msgstr "*defaultTest* 引数がテスト名のイテラブルも受け取るようになりました。"

#: ../../library/unittest.rst:2336
msgid "load_tests Protocol"
msgstr "load_tests プロトコル"

#: ../../library/unittest.rst:2340
msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr ""
"モジュールやパッケージには、``load_tests`` と呼ばれる関数を実装できます。これ"
"により、通常のテスト実行時やテストディスカバリ時のテストのロードされ方をカス"
"タマイズできます。"

#: ../../library/unittest.rst:2343
msgid ""
"If a test module defines ``load_tests`` it will be called by :meth:"
"`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""
"テストモジュールが ``load_tests`` を定義していると、それが :meth:`TestLoader."
"loadTestsFromModule` から呼ばれます。引数は以下です::"

#: ../../library/unittest.rst:2348
msgid ""
"where *pattern* is passed straight through from ``loadTestsFromModule``.  It "
"defaults to ``None``."
msgstr ""
"*pattern* は ``loadTestsFromModule`` からそのまま渡されます。デフォルトは "
"``None`` です。"

#: ../../library/unittest.rst:2351
msgid "It should return a :class:`TestSuite`."
msgstr "これは :class:`TestSuite` を返すべきです。"

#: ../../library/unittest.rst:2353
msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""
"*loader* はローディングを行う :class:`TestLoader` のインスタンスです。 "
"*standard_tests* は、そのモジュールからデフォルトでロードされるテストです。こ"
"れは、テストの標準セットのテストの追加や削除のみを行いたいテストモジュールに"
"一般に使われます。第三引数は、パッケージをテストディスカバリの一部としてロー"
"ドするときに使われます。"

#: ../../library/unittest.rst:2359
msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of :"
"class:`TestCase` classes may look like::"
msgstr ""
"特定の :class:`TestCase` クラスのセットからテストをロードする典型的な "
"``load_tests`` 関数は、このようになります::"

#: ../../library/unittest.rst:2371
msgid ""
"If discovery is started in a directory containing a package, either from the "
"command line or by calling :meth:`TestLoader.discover`, then the package :"
"file:`__init__.py` will be checked for ``load_tests``.  If that function "
"does not exist, discovery will recurse into the package as though it were "
"just another directory.  Otherwise, discovery of the package's tests will be "
"left up to ``load_tests`` which is called with the following arguments::"
msgstr ""
"コマンドラインからでも :meth:`TestLoader.discover` の呼び出しでも、パッケージ"
"を含むディレクトリで検索を始めた場合、そのパッケージの :file:`__init__.py` を"
"チェックして ``load_tests`` を探します。\n"
"その関数が存在しない場合、他のディレクトリであるかのようにパッケージの中を再"
"帰的に検索します。\n"
"その関数が存在した場合、パッケージのテストの検索をそちらに任せ、 "
"``load_tests`` が次の引数で呼び出されます::"

#: ../../library/unittest.rst:2380
msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from :file:"
"`__init__.py`.)"
msgstr ""
"これはパッケージ内のすべてのテストを表す :class:`TestSuite` を返すべきです。 "
"(``standard_tests`` には、 :file:`__init__.py` から収集されたテストのみが含ま"
"れます。)"

#: ../../library/unittest.rst:2384
msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""
"パターンは ``load_tests`` に渡されるので、パッケージは自由にテストディスカバ"
"リを継続 (必要なら変更) できます。テストパッケージに '何もしない' "
"``load_tests`` 関数は次のようになります::"

#: ../../library/unittest.rst:2395
msgid ""
"Discovery no longer checks package names for matching *pattern* due to the "
"impossibility of package names matching the default pattern."
msgstr ""
"パッケージ名がデフォルトのパターンに適合するのが不可能なため、検索ではパッ"
"ケージ名が *pattern* に適合するかのチェックは行われなくなりました。"

#: ../../library/unittest.rst:2402
msgid "Class and Module Fixtures"
msgstr "クラスとモジュールのフィクスチャ"

#: ../../library/unittest.rst:2404
msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass` "
"from the previous class (if there is one) is called, followed by :meth:"
"`setUpClass` from the new class."
msgstr ""
"クラスレベルとモジュールレベルのフィクスチャが :class:`TestSuite` に実装され"
"ました。\n"
"テストスイートが新しいクラスのテストを始める時、以前のクラス (あれば)の :"
"meth:`tearDownClass` を呼び出し、その後に新しいクラスの :meth:`setUpClass` を"
"呼び出します。"

#: ../../library/unittest.rst:2409
msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""
"同様に、今回のテストのモジュールが前回のテストとは異なる場合、以前のモジュー"
"ルの ``tearDownModule`` を実行し、次に新しいモジュールの ``setUpModule`` を実"
"行します。"

#: ../../library/unittest.rst:2413
msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr ""
"すべてのテストが実行された後、最後の ``tearDownClass`` と ``tearDownModule`` "
"が実行されます。"

#: ../../library/unittest.rst:2416
msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with "
"care."
msgstr ""
"なお、共有フィクスチャは、テストの並列化などの [潜在的な] 機能と同時にはうま"
"くいかず、テストの分離を壊すので、気をつけて使うべきです。"

#: ../../library/unittest.rst:2419
msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""
"unittest テストローダによるテスト作成のデフォルトの順序では、同じモジュールや"
"クラスからのテストはすべて同じグループにまとめられます。これにより、"
"``setUpClass`` / ``setUpModule`` (など) は、一つのクラスやモジュールにつき一"
"度だけ呼ばれます。この順序をバラバラにし、異なるモジュールやクラスのテストが"
"並ぶようにすると、共有フィクスチャ関数は、一度のテストで複数回呼ばれるように"
"もなります。"

#: ../../library/unittest.rst:2426
msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to "
"support shared fixtures."
msgstr ""
"共有フィクスチャは標準でない順序で実行されることを意図していません。\n"
"共有フィクスチャをサポートしたくないフレームワークのために、"
"``BaseTestSuite`` がまだ存在しています。"

#: ../../library/unittest.rst:2430
msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""
"共有フィクスチャ関数のいずれかで例外が発生した場合、そのテストはエラーとして"
"報告されます。\n"
"そのとき、対応するテストインスタンスが無いので(:class:`TestCase` と同じイン"
"ターフェースの) ``_ErrorHolder`` オブジェクトが生成され、エラーを表します。\n"
"標準 unittest テストランナーを使っている場合はこの詳細は問題になりませんが、"
"あなたがフレームワークの作者である場合は注意してください。"

#: ../../library/unittest.rst:2439
msgid "setUpClass and tearDownClass"
msgstr "setUpClass と tearDownClass"

#: ../../library/unittest.rst:2441
msgid "These must be implemented as class methods::"
msgstr "これらはクラスメソッドとして実装されなければなりません::"

#: ../../library/unittest.rst:2454
msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in :class:"
"`TestCase` are empty."
msgstr ""
"基底クラスの ``setUpClass`` および ``tearDownClass`` を使いたいなら、それらを"
"自分で呼び出さなければなりません。 :class:`TestCase` の実装は空です。"

#: ../../library/unittest.rst:2458
msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will "
"not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a :exc:"
"`SkipTest` exception then the class will be reported as having been skipped "
"instead of as an error."
msgstr ""
"``setUpClass`` の中で例外が送出されたら、クラス内のテストは実行されず、 "
"``tearDownClass`` も実行されません。スキップされたクラスは ``setUpClass`` も "
"``tearDownClass`` も実行されません。例外が :exc:`SkipTest` 例外であれば、その"
"クラスはエラーではなくスキップされたものとして報告されます。"

#: ../../library/unittest.rst:2466
msgid "setUpModule and tearDownModule"
msgstr "setUpModule と tearDownModule"

#: ../../library/unittest.rst:2468
msgid "These should be implemented as functions::"
msgstr "これらは関数として実装されなければなりません::"

#: ../../library/unittest.rst:2476
msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the "
"module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as "
"having been skipped instead of as an error."
msgstr ""
"``setUpModule`` の中で例外が送出されたら、モジュール内のテストは実行されず、 "
"``tearDownModule`` も実行されません。例外が :exc:`SkipTest` 例外であれば、そ"
"のモジュールはエラーではなくスキップされたものとして報告されます。"

#: ../../library/unittest.rst:2481
msgid ""
"To add cleanup code that must be run even in the case of an exception, use "
"``addModuleCleanup``:"
msgstr ""
"例外が発生した場合でも実行しなければならないクリーンアップコードを追加するに"
"は``addModuleCleanup``を使用します:"

#: ../../library/unittest.rst:2487
msgid ""
"Add a function to be called after :func:`tearDownModule` to cleanup "
"resources used during the test class. Functions will be called in reverse "
"order to the order they are added (:abbr:`LIFO (last-in, first-out)`). They "
"are called with any arguments and keyword arguments passed into :meth:"
"`addModuleCleanup` when they are added."
msgstr ""
":func:`tearDownModule` の後に呼び出される関数を追加します。この関数はリソース"
"のクリーンアップのために使用します。追加された関数は、追加された順と逆の順番"
"で呼び出されます（:abbr:`LIFO (last-in, first-out)`）。 :meth:"
"`addModuleCleanup` に渡された引数とキーワード引数が追加された関数にも渡されま"
"す。"

#: ../../library/unittest.rst:2493
msgid ""
"If :meth:`setUpModule` fails, meaning that :func:`tearDownModule` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
":meth:`setUpModule` が失敗した場合、つまり :func:`tearDownModule` が呼ばれな"
"かった場合でも、追加されたクリーンアップ関数は呼び出されます。"

#: ../../library/unittest.rst:2501
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :func:"
"`addModuleCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""

#: ../../library/unittest.rst:2511
msgid ""
"This function is called unconditionally after :func:`tearDownModule`, or "
"after :func:`setUpModule` if :func:`setUpModule` raises an exception."
msgstr ""
"この関数は、 :func:`tearDownModule` の後、もしくは、 :func:`setUpModule` が例"
"外を投げた場合は :func:`setUpModule` の後に、無条件で呼ばれます。"

#: ../../library/unittest.rst:2514
msgid ""
"It is responsible for calling all the cleanup functions added by :func:"
"`addModuleCleanup`. If you need cleanup functions to be called *prior* to :"
"func:`tearDownModule` then you can call :func:`doModuleCleanups` yourself."
msgstr ""
"このメソッドは、 :func:`addModuleCleanup` で追加された関数を呼び出す責務を担"
"います。もし、クリーンアップ関数を :func:`tearDownModule` より前に呼び出す必"
"要がある場合には、 :func:`doModuleCleanups` を明示的に呼び出してください。"

#: ../../library/unittest.rst:2519
msgid ""
":func:`doModuleCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":func:`doModuleCleanups` は、どこで呼び出されても、クリーンアップ関数をスタッ"
"クから削除して実行します。"

#: ../../library/unittest.rst:2526
msgid "Signal Handling"
msgstr "シグナルハンドリング"

#: ../../library/unittest.rst:2530
msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main()`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""
"unittest の :option:`-c/--catch <unittest -c>` コマンドラインオプションや、 :"
"func:`unittest.main()` の ``catchbreak`` パラメタは、テスト実行中の control-"
"C の処理をよりフレンドリーにします。中断捕捉動作を有効である場合、 control-C "
"が押されると、現在実行されているテストまで完了され、そのテストランが終わると"
"今までの結果が報告されます。control-C がもう一度押されると、通常通り :exc:"
"`KeyboardInterrupt` が送出されます。"

#: ../../library/unittest.rst:2537
msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed :const:`signal."
"SIGINT` handler, i.e. it has been replaced by the system under test and "
"delegated to, then it calls the default handler. This will normally be the "
"expected behavior by code that replaces an installed handler and delegates "
"to it. For individual tests that need ``unittest`` control-c handling "
"disabled the :func:`removeHandler` decorator can be used."
msgstr ""
"シグナルハンドラを処理する control-c は、独自の :const:`signal.SIGINT` ハンド"
"ラをインストールするコードやテストの互換性を保とうとします。 ``unittest`` ハ"
"ンドラが呼ばれ、それがインストールされた :const:`signal.SIGINT` ハンドラで *"
"なければ* 、すなわちテスト中のシステムに置き換えられて移譲されたなら、それは"
"デフォルトのハンドラを呼び出します。インストールされたハンドラを置き換えて委"
"譲するようなコードは、通常その動作を期待するからです。 ``unittest`` の "
"control-c 処理を無効にしたいような個別のテストには、 :func:`removeHandler` デ"
"コレータが使えます。"

#: ../../library/unittest.rst:2546
msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr ""
"フレームワークの作者がテストフレームワーク内で control-c 処理を有効にするため"
"の、いくつかのユーティリティ関数があります。"

#: ../../library/unittest.rst:2551
msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""
"control-c ハンドラをインストールします。(主にユーザが control-c を押したこと"
"により) :const:`signal.SIGINT` が受け取られると、登録した結果すべてに :meth:"
"`~TestResult.stop` が呼び出されます。"

#: ../../library/unittest.rst:2558
msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr ""
"control-c 処理のために :class:`TestResult` を登録します。結果を登録するとそれ"
"に対する弱参照が格納されるので、結果がガベージコレクトされるのを妨げません。"

#: ../../library/unittest.rst:2562
msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all "
"results they create independently of whether or not handling is enabled."
msgstr ""
"control-c 処理が有効でなければ、 :class:`TestResult` オブジェクトの登録には副"
"作用がありません。ですからテストフレームワークは、処理が有効か無効かにかかわ"
"らず、作成する全ての結果を無条件に登録できます。"

#: ../../library/unittest.rst:2569
msgid ""
"Remove a registered result. Once a result has been removed then :meth:"
"`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr ""
"登録された結果を削除します。一旦結果が削除されると、control-c が押された際に"
"その結果オブジェクトに対して :meth:`~TestResult.stop` が呼び出されなくなりま"
"す。"

#: ../../library/unittest.rst:2576
msgid ""
"When called without arguments this function removes the control-c handler if "
"it has been installed. This function can also be used as a test decorator to "
"temporarily remove the handler while the test is being executed::"
msgstr ""
"引数なしで呼び出されると、この関数はCtrl+Cのシグナルハンドラを（それがインス"
"トールされていた場合）削除します。また、この関数はテストが実行されている間、"
"Ctrl+Cのハンドラを一時的に削除するテストデコレーターとしても使用できます。"
