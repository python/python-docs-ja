# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-05 15:01+0000\n"
"PO-Revision-Date: 2018-06-29 17:33+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/audioop.rst:2
msgid ":mod:`audioop` --- Manipulate raw audio data"
msgstr ":mod:`audioop` --- ç”Ÿã®éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’æ“ä½œã™ã‚‹"

#: ../../library/audioop.rst:9
msgid ""
"The :mod:`audioop` module contains some useful operations on sound "
"fragments. It operates on sound fragments consisting of signed integer "
"samples 8, 16, 24 or 32 bits wide, stored in :term:`bytes-like objects "
"<bytes-like object>`.  All scalar items are integers, unless specified "
"otherwise."
msgstr ""
":mod:`audioop`  ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ä¾¿åˆ©ãªæ“ä½œã‚’å«ã‚“ã§ã„ã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ :term:`bytes-like ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ "
"<bytes-like object>` ã«ä¿å­˜ã•ã‚ŒãŸã€ç¬¦å·ä»˜ãæ•´æ•°ã®ã€ãƒ“ãƒƒãƒˆå¹…ãŒ 8, 16, 24, ã‚ã‚‹ã„ã¯ 32 "
"ãƒ“ãƒƒãƒˆã®éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’å¯¾è±¡ã¨ã—ã¦æ“ä½œã—ã¾ã™ã€‚ç‰¹ã«æŒ‡å®šã•ã‚Œã¦ã„ãªã„é™ã‚Šã€ã™ã¹ã¦ã®æ³¢å½¢ãƒ‡ãƒ¼ã‚¿ï¼ˆã‚¹ã‚«ãƒ©ãƒ¼è¦ç´ ï¼‰ã¯æ•´æ•°ã§ã™ã€‚"

#: ../../library/audioop.rst:14
msgid ""
"Support for 24-bit samples was added. All functions now accept any :term"
":`bytes-like object`. String input now results in an immediate error."
msgstr ""
"24 bit ã‚µãƒ³ãƒ—ãƒ«ã®ã‚µãƒãƒ¼ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ã™ã¹ã¦ã®é–¢æ•°ã¯ã©ã‚“ãª :term:`bytes-like object` "
"ã§ã‚‚ä½¿ç”¨ã§ãã¾ã™ã€‚æ–‡å­—åˆ—ã®å…¥åŠ›ã¯å³åº§ã«ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/audioop.rst:25
msgid ""
"This module provides support for a-LAW, u-LAW and Intel/DVI ADPCM encodings."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯a-LAWã€u-LAWãã—ã¦Intel/DVI ADPCMã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/audioop.rst:29
msgid ""
"A few of the more complicated operations only take 16-bit samples, otherwise"
" the sample size (in bytes) is always a parameter of the operation."
msgstr ""
"è¤‡é›‘ãªæ“ä½œã®ã†ã¡ã„ãã¤ã‹ã¯ã‚µãƒ³ãƒ—ãƒ«å¹…ãŒ 16 ãƒ“ãƒƒãƒˆã®ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã®ã¿åƒãã¾ã™ãŒã€ãã‚Œä»¥å¤–ã¯å¸¸ã«ã‚µãƒ³ãƒ—ãƒ«å¹…ã‚’æ“ä½œã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã¨ã—ã¦ (ãƒã‚¤ãƒˆå˜ä½ã§) "
"æ¸¡ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:32
msgid "The module defines the following variables and functions:"
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ä»¥ä¸‹ã®å¤‰æ•°ã¨é–¢æ•°ã‚’å®šç¾©ã—ã¦ã„ã¾ã™:"

#: ../../library/audioop.rst:37
msgid ""
"This exception is raised on all errors, such as unknown number of bytes per "
"sample, etc."
msgstr "ã“ã®ä¾‹å¤–ã¯ã€æœªçŸ¥ã®ã‚µãƒ³ãƒ—ãƒ«å½“ãŸã‚Šã®ãƒã‚¤ãƒˆæ•°ã‚’æŒ‡å®šã—ãŸæ™‚ãªã©ã€å…¨èˆ¬çš„ãªã‚¨ãƒ©ãƒ¼ã«å¯¾ã—ã¦é€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/audioop.rst:43
msgid ""
"Return a fragment which is the addition of the two samples passed as "
"parameters. *width* is the sample width in bytes, either ``1``, ``2``, ``3``"
" or ``4``.  Both fragments should have the same length.  Samples are "
"truncated in case of overflow."
msgstr ""
"ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦æ¸¡ã•ã‚ŒãŸ2ã¤ã®ã‚µãƒ³ãƒ—ãƒ«ã®å’Œã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚*width* ã¯ãƒã‚¤ãƒˆå˜ä½ã®ã‚µãƒ³ãƒ—ãƒ«å¹…ã§ã€``1``, ``2``, ``3``, "
"``4`` ã®ã„ãšã‚Œã‹ã§ã™ã€‚ä¸¡æ–¹ã®ãƒ‡ãƒ¼ã‚¿ã¯åŒã˜é•·ã•ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã—ãŸå ´åˆã¯ã€åˆ‡ã‚Šæ¨ã¦ã•ã‚Œã¾ã™ã€‚"

#: ../../library/audioop.rst:50
msgid ""
"Decode an Intel/DVI ADPCM coded fragment to a linear fragment.  See the "
"description of :func:`lin2adpcm` for details on ADPCM coding. Return a tuple"
" ``(sample, newstate)`` where the sample has the width specified in *width*."
msgstr ""
"Intel/DVI ADPCM å½¢å¼ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªãƒ‹ã‚¢ (linear) å½¢å¼ã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ ADPCM ç¬¦å·åŒ–æ–¹å¼ã®è©³ç´°ã«ã¤ã„ã¦ã¯ "
":func:`lin2adpcm` ã®èª¬æ˜ã‚’å‚ç…§ã—ã¦ä¸‹ã•ã„ã€‚ ``(sample, newstate)`` ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã€ã‚µãƒ³ãƒ—ãƒ«ã¯ "
"*width* ã«æŒ‡å®šã—ãŸå¹…ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/audioop.rst:57
msgid ""
"Convert sound fragments in a-LAW encoding to linearly encoded sound "
"fragments. a-LAW encoding always uses 8 bits samples, so *width* refers only"
" to the sample width of the output fragment here."
msgstr ""
"a-LAWå½¢å¼ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªãƒ‹ã‚¢ (linear) å½¢å¼ã«å¤‰æ›ã—ã¾ã™ã€‚a-LAWå½¢å¼ã¯å¸¸ã« 8 ãƒ“ãƒƒãƒˆã®ã‚µãƒ³ãƒ—ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã®ã§ã€ã“ã“ã§ã¯ *width* "
"ã¯å˜ã«å‡ºåŠ›ãƒ‡ãƒ¼ã‚¿ã®ã‚µãƒ³ãƒ—ãƒ«å¹…ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/audioop.rst:64
msgid "Return the average over all samples in the fragment."
msgstr "ãƒ‡ãƒ¼ã‚¿ä¸­ã®å…¨ã‚µãƒ³ãƒ—ãƒ«ã®å¹³å‡å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:69
msgid ""
"Return the average peak-peak value over all samples in the fragment. No "
"filtering is done, so the usefulness of this routine is questionable."
msgstr "ãƒ‡ãƒ¼ã‚¿ä¸­ã®å…¨ã‚µãƒ³ãƒ—ãƒ«ã®å¹³å‡ peak-peak æŒ¯å¹…ã‚’è¿”ã—ã¾ã™ã€‚ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’è¡Œã£ã¦ã„ãªã„å ´åˆã€ã“ã®ãƒ«ãƒ¼ãƒãƒ³ã®æœ‰ç”¨æ€§ã¯ç–‘å•ã§ã™ã€‚"

#: ../../library/audioop.rst:75
msgid ""
"Return a fragment that is the original fragment with a bias added to each "
"sample.  Samples wrap around in case of overflow."
msgstr "å…ƒã®éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®å„ã‚µãƒ³ãƒ—ãƒ«ã«ãƒã‚¤ã‚¢ã‚¹ã‚’åŠ ç®—ã—ãŸéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã—ãŸå ´åˆã¯ãƒ©ãƒƒãƒ—ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰ã•ã‚Œã¾ã™ã€‚"

#: ../../library/audioop.rst:81
msgid ""
"\"Byteswap\" all samples in a fragment and returns the modified fragment. "
"Converts big-endian samples to little-endian and vice versa."
msgstr ""
"fragment ã®ã™ã¹ã¦ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’ \"byteswap\" ã—ã¦ã€ä¿®æ­£ã•ã‚ŒãŸ fragment "
"ã‚’è¿”ã—ã¾ã™ã€‚ãƒ“ãƒƒã‚°ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’ãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ã«ã€ã¾ãŸã¯ãã®é€†ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:89
msgid ""
"Return the number of zero crossings in the fragment passed as an argument."
msgstr "å¼•æ•°ã«æ¸¡ã—ãŸãƒ‡ãƒ¼ã‚¿ä¸­ã®ã‚¼ãƒ­äº¤å·®å›æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:94
msgid ""
"Return a factor *F* such that ``rms(add(fragment, mul(reference, -F)))`` is "
"minimal, i.e., return the factor with which you should multiply *reference* "
"to make it match as well as possible to *fragment*.  The fragments should "
"both contain 2-byte samples."
msgstr ""
"``rms(add(fragment, mul(reference, -F)))`` ã‚’æœ€å°ã«ã™ã‚‹ã‚ˆã†ãªä¿‚æ•° *F*ã€ã™ãªã‚ã¡ã€*reference* "
"ã«ä¹—ç®—ã—ãŸã¨ãã«ã‚‚ã£ã¨ã‚‚ *fragment* ã«è¿‘ããªã‚‹ã‚ˆã†ãªå€¤ã‚’è¿”ã—ã¾ã™ã€‚*fragment* ã¨ *reference* ã®ã‚µãƒ³ãƒ—ãƒ«å¹…ã¯ã„ãšã‚Œã‚‚ "
"2ãƒã‚¤ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/audioop.rst:99
msgid "The time taken by this routine is proportional to ``len(fragment)``."
msgstr "ã“ã®ãƒ«ãƒ¼ãƒãƒ³ã®å®Ÿè¡Œã«è¦ã™ã‚‹æ™‚é–“ã¯ ``len(fragment)`` ã«æ¯”ä¾‹ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:104
msgid ""
"Try to match *reference* as well as possible to a portion of *fragment* "
"(which should be the longer fragment).  This is (conceptually) done by "
"taking slices out of *fragment*, using :func:`findfactor` to compute the "
"best match, and minimizing the result.  The fragments should both contain "
"2-byte samples. Return a tuple ``(offset, factor)`` where *offset* is the "
"(integer) offset into *fragment* where the optimal match started and "
"*factor* is the (floating-point) factor as per :func:`findfactor`."
msgstr ""
"*reference* ã‚’å¯èƒ½ãªé™ã‚Š *fragment* ã«ä¸€è‡´ã•ã›ã‚ˆã†ã¨ã—ã¾ã™ (*fragment* ã¯ *reference* "
"ã‚ˆã‚Šé•·ããªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“)ã€‚ã“ã®å‡¦ç†ã¯ (æ¦‚å¿µçš„ã«ã¯) *fragment* ã‹ã‚‰ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ã„ãã¤ã‹å–ã‚Šå‡ºã—ã€ãã‚Œãã‚Œã«ã¤ã„ã¦ "
":func:`findfactor` ã‚’ä½¿ã£ã¦æœ€è‰¯ãªä¸€è‡´ã‚’è¨ˆç®—ã—ã€èª¤å·®ãŒæœ€å°ã®çµæœã‚’é¸ã¶ã“ã¨ã§å®Ÿç¾ã—ã¾ã™ã€‚ *fragment* ã¨ "
"*reference* ã®ã‚µãƒ³ãƒ—ãƒ«å¹…ã¯ä¸¡æ–¹ã¨ã‚‚2ãƒã‚¤ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ ``(offset, factor)`` ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ "
"*offset* ã¯æœ€é©ãªä¸€è‡´ç®‡æ‰€ãŒå§‹ã¾ã‚‹ *fragment* ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆå€¤ï¼ˆæ•´æ•°ï¼‰ã§ã€ *factor* ã¯ :func:`findfactor`"
" ã®è¿”ã™ä¿‚æ•° (æµ®å‹•å°æ•°ç‚¹æ•°) ã§ã™ã€‚"

#: ../../library/audioop.rst:115
msgid ""
"Search *fragment* for a slice of length *length* samples (not bytes!) with "
"maximum energy, i.e., return *i* for which "
"``rms(fragment[i*2:(i+length)*2])`` is maximal.  The fragments should both "
"contain 2-byte samples."
msgstr ""
"*fragment* ã‹ã‚‰ã€é•·ã•ãŒ *length* ã‚µãƒ³ãƒ—ãƒ« (ãƒã‚¤ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“!) "
"ã§æœ€å¤§ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æŒã¤ã‚¹ãƒ©ã‚¤ã‚¹ã€ã™ãªã‚ã¡ã€``rms(fragment[i*2:(i+length)* 2])`` "
"ã‚’æœ€å¤§ã«ã™ã‚‹ã‚ˆã†ãªã‚¹ãƒ©ã‚¤ã‚¹ã‚’æ¢ã—ã€*i* ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ã®ã¯ã‚µãƒ³ãƒ—ãƒ«å¹…ã¯ 2ãƒã‚¤ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/audioop.rst:119
msgid "The routine takes time proportional to ``len(fragment)``."
msgstr "ã“ã®ãƒ«ãƒ¼ãƒãƒ³ã®å®Ÿè¡Œã«è¦ã™ã‚‹æ™‚é–“ã¯ ``len(fragment)`` ã«æ¯”ä¾‹ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:124
msgid "Return the value of sample *index* from the fragment."
msgstr "ãƒ‡ãƒ¼ã‚¿ä¸­ã® *index* ã‚µãƒ³ãƒ—ãƒ«ç›®ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:129
msgid ""
"Convert samples to 4 bit Intel/DVI ADPCM encoding.  ADPCM coding is an "
"adaptive coding scheme, whereby each 4 bit number is the difference between "
"one sample and the next, divided by a (varying) step.  The Intel/DVI ADPCM "
"algorithm has been selected for use by the IMA, so it may well become a "
"standard."
msgstr ""
"ãƒ‡ãƒ¼ã‚¿ã‚’ 4 ãƒ“ãƒƒãƒˆã® Intel/DVI ADPCM ç¬¦å·åŒ–æ–¹å¼ã«å¤‰æ›ã—ã¾ã™ã€‚ADPCM ç¬¦å·åŒ–æ–¹å¼ã¨ã¯é©å¿œç¬¦å·åŒ–æ–¹å¼ã®ä¸€ã¤ã§ã€ã‚ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã¨ "
"(å¯å¤‰ã®) ã‚¹ãƒ†ãƒƒãƒ—ã ã‘é›¢ã‚ŒãŸãã®æ¬¡ã®ã‚µãƒ³ãƒ—ãƒ«ã¨ã®å·®ã‚’ 4 ãƒ“ãƒƒãƒˆã®æ•´æ•°ã§è¡¨ç¾ã™ã‚‹æ–¹å¼ã§ã™ã€‚Intel/DVI ADPCMã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ IMA  "
"(å›½éš›MIDIå”ä¼š) ã«æ¡ç”¨ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ãŠãã‚‰ãæ¨™æº–ã«ãªã‚‹ã¯ãšã§ã™ã€‚"

#: ../../library/audioop.rst:134
msgid ""
"*state* is a tuple containing the state of the coder.  The coder returns a "
"tuple ``(adpcmfrag, newstate)``, and the *newstate* should be passed to the "
"next call of :func:`lin2adpcm`.  In the initial call, ``None`` can be passed"
" as the state. *adpcmfrag* is the ADPCM coded fragment packed 2 4-bit values"
" per byte."
msgstr ""
"*state* ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ã®å†…éƒ¨çŠ¶æ…‹ãŒå…¥ã£ãŸã‚¿ãƒ—ãƒ«ã§ã™ã€‚ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ã¯ ``(adpcmfrag, newstate)`` ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã€æ¬¡ã« "
":func:`lin2adpcm` ã‚’å‘¼ã³å‡ºã™æ™‚ã« *newstate* ã‚’æ¸¡ã•ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚æœ€åˆã«å‘¼ã³å‡ºã™æ™‚ã«ã¯ *state* ã« "
"``None`` ã‚’æ¸¡ã—ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚ *adpcmfrag* ã¯ ADPCMã§ç¬¦å·åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã§ã€ãƒã‚¤ãƒˆå½“ãŸã‚Š 2 "
"ã¤ã®4ãƒ“ãƒƒãƒˆå€¤ãŒãƒ‘ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/audioop.rst:142
msgid ""
"Convert samples in the audio fragment to a-LAW encoding and return this as a"
" bytes object.  a-LAW is an audio encoding format whereby you get a dynamic "
"range of about 13 bits using only 8 bit samples.  It is used by the Sun "
"audio hardware, among others."
msgstr ""
"éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’ a-LAW ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«å¤‰æ›ã—ã€ãƒã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚a-LAW ã¨ã¯ 13ãƒ“ãƒƒãƒˆã®ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ãƒ¬ãƒ³ã‚¸ã‚’ "
"8bit ã ã‘ã§è¡¨ç¾ã§ãã‚‹éŸ³å£°ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã™ã€‚Sun ã®éŸ³å£°ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãªã©ã§ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/audioop.rst:150
msgid "Convert samples between 1-, 2-, 3- and 4-byte formats."
msgstr "ã‚µãƒ³ãƒ—ãƒ«å¹…ã‚’ 1ã€2ã€3ã€4 ãƒã‚¤ãƒˆå½¢å¼ã®é–“ã§å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:154
msgid ""
"In some audio formats, such as .WAV files, 16, 24 and 32 bit samples are "
"signed, but 8 bit samples are unsigned.  So when converting to 8 bit wide "
"samples for these formats, you need to also add 128 to the result::"
msgstr ""
".WAV ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚ˆã†ãªå¹¾ã¤ã‹ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã¯ã€16ã€24 ã¨ 32 bit ã®ã‚µãƒ³ãƒ—ãƒ«ã¯ç¬¦å·ä»˜ãã§ã™ãŒã€8 bit "
"ã®ã‚µãƒ³ãƒ—ãƒ«ã¯ç¬¦å·ãªã—ã§ã™ã€‚ãã®ãŸã‚ã€ãã®ã‚ˆã†ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ 8 bit ã«å¤‰æ›ã™ã‚‹å ´åˆã¯ã€å¤‰æ›çµæœã«128ã‚’è¶³ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“::"

#: ../../library/audioop.rst:161
msgid ""
"The same, in reverse, has to be applied when converting from 8 to 16, 24 or "
"32 bit width samples."
msgstr "é€†ã«ã€8 bit ã‹ã‚‰ 16ã€24ã€32 bit ã«å¤‰æ›ã™ã‚‹å ´åˆã‚‚ã€åŒã˜ã“ã¨ãŒè¨€ãˆã¾ã™ã€‚"

#: ../../library/audioop.rst:167
msgid ""
"Convert samples in the audio fragment to u-LAW encoding and return this as a"
" bytes object.  u-LAW is an audio encoding format whereby you get a dynamic "
"range of about 14 bits using only 8 bit samples.  It is used by the Sun "
"audio hardware, among others."
msgstr ""
"éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’ u-LAW ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«å¤‰æ›ã—ã€ãƒã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚u-LAW ã¨ã¯ 14ãƒ“ãƒƒãƒˆã®ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ãƒ¬ãƒ³ã‚¸ã‚’ "
"8bit ã ã‘ã§è¡¨ç¾ã§ãã‚‹éŸ³å£°ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã™ã€‚Sun ã®éŸ³å£°ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãªã©ã§ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/audioop.rst:175
msgid ""
"Return the maximum of the *absolute value* of all samples in a fragment."
msgstr "éŸ³å£°ãƒ‡ãƒ¼ã‚¿å…¨ã‚µãƒ³ãƒ—ãƒ«ã® *çµ¶å¯¾å€¤* ã®æœ€å¤§å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:180
msgid "Return the maximum peak-peak value in the sound fragment."
msgstr "éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®æœ€å¤§ peak-peak æŒ¯å¹…ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:185
msgid ""
"Return a tuple consisting of the minimum and maximum values of all samples "
"in the sound fragment."
msgstr "éŸ³å£°ãƒ‡ãƒ¼ã‚¿å…¨ã‚µãƒ³ãƒ—ãƒ«ä¸­ã«ãŠã‘ã‚‹æœ€å°å€¤ã¨æœ€å¤§å€¤ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:191
msgid ""
"Return a fragment that has all samples in the original fragment multiplied "
"by the floating-point value *factor*.  Samples are truncated in case of "
"overflow."
msgstr "å…ƒã®éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®å„ã‚µãƒ³ãƒ—ãƒ«ã«æµ®å‹•å°æ•°ç‚¹æ•° *factor* ã‚’ä¹—ç®—ã—ãŸéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã—ãŸå ´åˆã¯åˆ‡ã‚Šæ¨ã¦ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/audioop.rst:197
msgid "Convert the frame rate of the input fragment."
msgstr "å…¥åŠ›ã—ãŸãƒ‡ãƒ¼ã‚¿ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆã‚’å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:199
msgid ""
"*state* is a tuple containing the state of the converter.  The converter "
"returns a tuple ``(newfragment, newstate)``, and *newstate* should be passed"
" to the next call of :func:`ratecv`.  The initial call should pass ``None`` "
"as the state."
msgstr ""
"*state* ã¯å¤‰æ›ãƒ«ãƒ¼ãƒãƒ³ã®å†…éƒ¨çŠ¶æ…‹ã‚’å…¥ã‚ŒãŸã‚¿ãƒ—ãƒ«ã§ã™ã€‚å¤‰æ›ãƒ«ãƒ¼ãƒãƒ³ã¯ ``(newfragment, newstate)`` ã‚’è¿”ã—ã€æ¬¡ã« "
":func:`ratecv` ã‚’å‘¼ã³å‡ºã™æ™‚ã«ã¯ *newstate* ã‚’æ¸¡ã•ãªã­ã°ãªã‚Šã¾ã›ã‚“ã€‚æœ€åˆã®å‘¼ã³å‡ºã—ã§ã¯ ``None`` ã‚’æ¸¡ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:203
msgid ""
"The *weightA* and *weightB* arguments are parameters for a simple digital "
"filter and default to ``1`` and ``0`` respectively."
msgstr ""
"å¼•æ•° *weightA* ã¨ *weightB* ã¯å˜ç´”ãªãƒ‡ã‚¸ã‚¿ãƒ«ãƒ•ã‚£ãƒ«ã‚¿ã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ãã‚Œãã‚Œ ``1`` ã¨ ``0`` ã§ã™ã€‚"

#: ../../library/audioop.rst:209
msgid "Reverse the samples in a fragment and returns the modified fragment."
msgstr "ãƒ‡ãƒ¼ã‚¿å†…ã®ã‚µãƒ³ãƒ—ãƒ«ã®é †åºã‚’é€†è»¢ã—ã€å¤‰æ›´ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:214
msgid ""
"Return the root-mean-square of the fragment, i.e. ``sqrt(sum(S_i^2)/n)``."
msgstr "ãƒ‡ãƒ¼ã‚¿ã®è‡ªä¹—å¹³å‡æ ¹(root-mean-square)ã€ã™ãªã‚ã¡ ``sqrt(sum(S_i^2)/n)`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:216
msgid "This is a measure of the power in an audio signal."
msgstr "ã“ã‚Œã¯ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªä¿¡å·ã®å¼·åº¦ (power) ã‚’æ¸¬ã‚‹ä¸€ã¤ã®ç›®å®‰ã§ã™ã€‚"

#: ../../library/audioop.rst:221
msgid ""
"Convert a stereo fragment to a mono fragment.  The left channel is "
"multiplied by *lfactor* and the right channel by *rfactor* before adding the"
" two channels to give a mono signal."
msgstr ""
"ã‚¹ãƒ†ãƒ¬ã‚ªéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ¢ãƒãƒ©ãƒ«éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›ã—ã¾ã™ã€‚å·¦ãƒãƒ£ãƒãƒ«ã®ãƒ‡ãƒ¼ã‚¿ã« *lfactor*ã€å³ãƒãƒ£ãƒãƒ«ã®ãƒ‡ãƒ¼ã‚¿ã« *rfactor* "
"ã‚’æ›ã‘ãŸå¾Œã€äºŒã¤ã®ãƒãƒ£ãƒãƒ«ã®å€¤ã‚’åŠ ç®—ã—ã¦å˜ä¸€ãƒãƒ£ãƒãƒ«ã®ä¿¡å·ã‚’ç”Ÿæˆã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:228
msgid ""
"Generate a stereo fragment from a mono fragment.  Each pair of samples in "
"the stereo fragment are computed from the mono sample, whereby left channel "
"samples are multiplied by *lfactor* and right channel samples by *rfactor*."
msgstr ""
"ãƒ¢ãƒãƒ©ãƒ«éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¹ãƒ†ãƒ¬ã‚ªéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›ã—ã¾ã™ã€‚ã‚¹ãƒ†ãƒ¬ã‚ªéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®å„ã‚µãƒ³ãƒ—ãƒ«å¯¾ã¯ã€ãƒ¢ãƒãƒ©ãƒ«éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®å„ã‚µãƒ³ãƒ—ãƒ«ã‚’ãã‚Œãã‚Œå·¦ãƒãƒ£ãƒãƒ«ã¯ "
"*lfactor* å€ã€å³ãƒãƒ£ãƒãƒ«ã¯ *rfactor* å€ã—ã¦ç”Ÿæˆã—ã¾ã™ã€‚"

#: ../../library/audioop.rst:235
msgid ""
"Convert sound fragments in u-LAW encoding to linearly encoded sound "
"fragments. u-LAW encoding always uses 8 bits samples, so *width* refers only"
" to the sample width of the output fragment here."
msgstr ""
"u-LAW ã§ç¬¦å·åŒ–ã•ã‚Œã¦ã„ã‚‹éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’ç·šå½¢ã«ç¬¦å·åŒ–ã•ã‚ŒãŸéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›ã—ã¾ã™ã€‚u-LAW ç¬¦å·åŒ–ã¯å¸¸ã«ã‚µãƒ³ãƒ—ãƒ«å½“ãŸã‚Š 8 "
"ãƒ“ãƒƒãƒˆã‚’ä½¿ã†ãŸã‚ã€*width* ã¯å‡ºåŠ›éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ã‚µãƒ³ãƒ—ãƒ«å¹…ã«ã—ã‹ä½¿ã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/audioop.rst:239
msgid ""
"Note that operations such as :func:`.mul` or :func:`.max` make no "
"distinction between mono and stereo fragments, i.e. all samples are treated "
"equal.  If this is a problem the stereo fragment should be split into two "
"mono fragments first and recombined later.  Here is an example of how to do "
"that::"
msgstr ""
":func:`.mul` ã‚„ :func:`.max` "
"ã¨ã„ã£ãŸæ“ä½œã¯ãƒ¢ãƒãƒ©ãƒ«ã¨ã‚¹ãƒ†ãƒ¬ã‚ªã‚’åŒºåˆ¥ã—ãªã„ã€ã™ãªã‚ã¡å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å¹³ç­‰ã«æ‰±ã†ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã®ä»•æ§˜ãŒå•é¡Œã«ãªã‚‹ã‚ˆã†ãªã‚‰ã€ã‚ã‚‰ã‹ã˜ã‚ã‚¹ãƒ†ãƒ¬ã‚ªéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’äºŒã¤ã®ãƒ¢ãƒãƒ©ãƒ«éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã«åˆ†å‰²ã—ã¦ãŠãã€æ“ä½œå¾Œã«å†åº¦çµ±åˆã—ã¦ãã ã•ã„ã€‚ãã®ã‚ˆã†ãªä¾‹ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™::"

#: ../../library/audioop.rst:253
msgid ""
"If you use the ADPCM coder to build network packets and you want your "
"protocol to be stateless (i.e. to be able to tolerate packet loss) you "
"should not only transmit the data but also the state.  Note that you should "
"send the *initial* state (the one you passed to :func:`lin2adpcm`) along to "
"the decoder, not the final state (as returned by the coder).  If you want to"
" use :class:`struct.Struct` to store the state in binary you can code the "
"first element (the predicted value) in 16 bits and the second (the delta "
"index) in 8."
msgstr ""
"ã‚‚ã— ADPCM ç¬¦å·ã‚’ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ‘ã‚±ãƒƒãƒˆã®æ§‹ç¯‰ã«ä½¿ã£ã¦ç‹¬è‡ªã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ã«ã—ãŸã„å ´åˆ "
"(ã¤ã¾ã‚Šã€ãƒ‘ã‚±ãƒƒãƒˆãƒ­ã‚¹ã‚’è¨±å®¹ã—ãŸã„å ´åˆ)ã¯ã€ãƒ‡ãƒ¼ã‚¿ã ã‘ã‚’é€ä¿¡ã—ã¦ã€ã‚¹ãƒ†ãƒ¼ãƒˆã‚’é€ä¿¡ã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ‡ã‚³ãƒ¼ãƒ€ã«å¾“ã£ã¦ *initial* ã‚¹ãƒ†ãƒ¼ãƒˆ "
"(:func:`lin2adpcm` ã«æ¸¡ã•ã‚Œã‚‹å€¤) ã‚’é€ã‚‹ã¹ãã§ã€æœ€çµ‚çŠ¶æ…‹ (ç¬¦å·åŒ–å™¨ãŒè¿”ã™å€¤) ã‚’é€ã‚‹ã¹ãã§ã¯ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ "
"ã‚‚ã—ã€:class:`struct.Struct` ã‚’ãƒã‚¤ãƒŠãƒªã§ã®çŠ¶æ…‹ä¿å­˜ã«ä½¿ã„ãŸã„å ´åˆã¯ã€æœ€åˆã®è¦ç´  (äºˆæ¸¬å€¤) ã‚’ 16bit "
"ã§ç¬¦å·åŒ–ã—ã€ï¼’ç•ªç›®ã®è¦ç´  (ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹) ã‚’ 8bit ã§ç¬¦å·åŒ–ã§ãã¾ã™ã€‚"

#: ../../library/audioop.rst:261
msgid ""
"The ADPCM coders have never been tried against other ADPCM coders, only "
"against themselves.  It could well be that I misinterpreted the standards in"
" which case they will not be interoperable with the respective standards."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ADPCM ç¬¦å·ã®ãƒ†ã‚¹ãƒˆã¯è‡ªåˆ†è‡ªèº«ã«å¯¾ã—ã¦ã®ã¿è¡Œã£ã¦ãŠã‚Šã€ä»–ã® ADPCM "
"ç¬¦å·ã¨ã®é–“ã§ã¯è¡Œã£ã¦ã„ã¾ã›ã‚“ã€‚ä½œè€…ãŒä»•æ§˜ã‚’èª¤è§£ã—ã¦ã„ã‚‹éƒ¨åˆ†ã‚‚ã‚ã‚‹ã‹ã‚‚ã—ã‚Œãšã€ãã‚Œãã‚Œã®æ¨™æº–ã¨ã®é–“ã§ç›¸äº’é‹ç”¨ã§ããªã„å ´åˆã‚‚ã‚ã‚Šå¾—ã¾ã™ã€‚"

#: ../../library/audioop.rst:265
msgid ""
"The :func:`find\\*` routines might look a bit funny at first sight. They are"
" primarily meant to do echo cancellation.  A reasonably fast way to do this "
"is to pick the most energetic piece of the output sample, locate that in the"
" input sample and subtract the whole output sample from the input sample::"
msgstr ""
":func:`find\\*` ãƒ«ãƒ¼ãƒãƒ³ã¯ä¸€è¦‹æ»‘ç¨½ã«è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã‚‰ã®é–¢æ•°ã®ä¸»ãªç›®çš„ã¯ã‚¨ã‚³ãƒ¼é™¤å» (echo cancellation) "
"ã«ã‚ã‚Šã¾ã™ã€‚ã‚¨ã‚³ãƒ¼é™¤å»ã‚’ååˆ†é«˜é€Ÿã«è¡Œã†ã«ã¯ã€å‡ºåŠ›ã‚µãƒ³ãƒ—ãƒ«ä¸­ã‹ã‚‰æœ€ã‚‚å¤§ããªã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æŒã£ãŸéƒ¨åˆ†ã‚’å–ã‚Šå‡ºã—ã€ã“ã®éƒ¨åˆ†ãŒå…¥åŠ›ã‚µãƒ³ãƒ—ãƒ«ä¸­ã®ã©ã“ã«ã‚ã‚‹ã‹ã‚’èª¿ã¹ã€å…¥åŠ›ã‚µãƒ³ãƒ—ãƒ«ã‹ã‚‰å‡ºåŠ›ã‚µãƒ³ãƒ—ãƒ«è‡ªä½“ã‚’æ¸›ç®—ã—ã¾ã™::"
