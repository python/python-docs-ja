# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2018-01-20 20:59+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/codeop.rst:3
msgid ":mod:`codeop` --- Compile Python code"
msgstr ":mod:`codeop` --- Pythonã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹"

#: ../../library/codeop.rst:10
msgid ""
"The :mod:`codeop` module provides utilities upon which the Python read-eval-"
"print loop can be emulated, as is done in the :mod:`code` module.  As a "
"result, you probably don't want to use the module directly; if you want to "
"include such a loop in your program you probably want to use the :mod:`code`"
" module instead."
msgstr ":mod:`codeop` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ :mod:`code` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§è¡Œã‚ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªPythonã® read-eval-printãƒ«ãƒ¼ãƒ—ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚’æä¾›ã—ã¾ã™ã€‚ãã®ãŸã‚ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç›´æ¥åˆ©ç”¨ã™ã‚‹å ´é¢ã¯ã‚ã¾ã‚Šç„¡ã„ã§ã—ã‚‡ã†ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã“ã®ã‚ˆã†ãªãƒ«ãƒ¼ãƒ—ã‚’å«ã‚ãŸã„å ´åˆã¯ã€ :mod:`code` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ–¹ãŒä¾¿åˆ©ã§ã™ã€‚"

#: ../../library/codeop.rst:16
msgid "There are two parts to this job:"
msgstr "ã“ã®ä»•äº‹ã«ã¯äºŒã¤ã®éƒ¨åˆ†ãŒã‚ã‚Šã¾ã™:"

#: ../../library/codeop.rst:18
msgid ""
"Being able to tell if a line of input completes a Python  statement: in "
"short, telling whether to print '``>>>``' or '``...``' next."
msgstr "å…¥åŠ›ã®ä¸€è¡ŒãŒPythonã®æ–‡ã¨ã—ã¦å®Œå…¨ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’è¦‹åˆ†ã‘ã‚‰ã‚Œã‚‹ã“ã¨: ç°¡å˜ã«è¨€ãˆã°ã€æ¬¡ãŒ '``>>>``' ã‹ã€ã‚ã‚‹ã„ã¯ '``...``' ã‹ã©ã†ã‹ã‚’è¦‹åˆ†ã‘ã¾ã™ã€‚"

#: ../../library/codeop.rst:21
msgid ""
"Remembering which future statements the user has entered, so  subsequent "
"input can be compiled with these in effect."
msgstr "ã©ã®futureæ–‡ã‚’ãƒ¦ãƒ¼ã‚¶ãŒå…¥åŠ›ã—ãŸã®ã‹ã‚’è¦šãˆã¦ã„ã‚‹ã“ã¨ã€‚ã—ãŸãŒã£ã¦ã€å®Ÿè³ªçš„ã«ãã‚Œã«ç¶šãå…¥åŠ›ã‚’ã“ã‚Œã‚‰ã¨ã¨ã‚‚ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/codeop.rst:24
msgid ""
"The :mod:`codeop` module provides a way of doing each of these things, and a"
" way of doing them both."
msgstr ":mod:`codeop` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã“ã†ã—ãŸã“ã¨ã®ãã‚Œãã‚Œã‚’è¡Œã†æ–¹æ³•ã¨ãã‚Œã‚‰ä¸¡æ–¹ã‚’è¡Œã†æ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/codeop.rst:27
msgid "To do just the former:"
msgstr "å‰è€…ã¯å®Ÿè¡Œã™ã‚‹ã«ã¯:"

#: ../../library/codeop.rst:31
msgid ""
"Tries to compile *source*, which should be a string of Python code and "
"return a code object if *source* is valid Python code. In that case, the "
"filename attribute of the code object will be *filename*, which defaults to "
"``'<input>'``. Returns ``None`` if *source* is *not* valid Python code, but "
"is a prefix of valid Python code."
msgstr "Pythonã‚³ãƒ¼ãƒ‰ã®æ–‡å­—åˆ—ã§ã‚ã‚‹ã¹ã *source* ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¦ã¿ã¦ã€*source* ãŒæœ‰åŠ¹ãªPythonã‚³ãƒ¼ãƒ‰ã®å ´åˆã¯ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ã‚ˆã†ãªå ´åˆã€ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«åå±æ€§ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ ``'<input>'`` ã§ã‚ã‚‹ *filename* ã§ã—ã‚‡ã†ã€‚*source* ãŒæœ‰åŠ¹ãªPythonã‚³ãƒ¼ãƒ‰ã§ã¯ *ãªã„* ãŒã€æœ‰åŠ¹ãªPythonã‚³ãƒ¼ãƒ‰ã®æ¥é ­èªã§ã‚ã‚‹å ´åˆã«ã¯ã€``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/codeop.rst:37
msgid ""
"If there is a problem with *source*, an exception will be raised. "
":exc:`SyntaxError` is raised if there is invalid Python syntax, and "
":exc:`OverflowError` or :exc:`ValueError` if there is an invalid literal."
msgstr "*source* ã«å•é¡ŒãŒã‚ã‚‹å ´åˆã¯ã€ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚ç„¡åŠ¹ãªPythonæ§‹æ–‡ãŒã‚ã‚‹å ´åˆã¯ã€ :exc:`SyntaxError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚ã¾ãŸã€ç„¡åŠ¹ãªãƒªãƒ†ãƒ©ãƒ«ãŒã‚ã‚‹å ´åˆã¯ã€ :exc:`OverflowError` ã¾ãŸã¯ :exc:`ValueError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/codeop.rst:41
msgid ""
"The *symbol* argument determines whether *source* is compiled as a statement"
" (``'single'``, the default) or as an :term:`expression` (``'eval'``).  Any "
"other value will cause :exc:`ValueError` to  be raised."
msgstr "*symbol* å¼•æ•°ã¯ *source* ãŒæ–‡ã¨ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã‚‹ã‹(``'single'`` ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã€ã¾ãŸã¯ :term:`å¼ <expression>` ã¨ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã‚‹ã‹ã‚’æ±ºå®šã—ã¾ã™(``'eval'``)ã€‚ä»–ã®ã©ã‚“ãªå€¤ã‚‚ :exc:`ValueError` ã‚’ç™ºç”Ÿã•ã›ã‚‹åŸå› ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/codeop.rst:47
msgid ""
"It is possible (but not likely) that the parser stops parsing with a "
"successful outcome before reaching the end of the source; in this case, "
"trailing symbols may be ignored instead of causing an error.  For example, a"
" backslash followed by two newlines may be followed by arbitrary garbage. "
"This will be fixed once the API for the parser is better."
msgstr "ã‚½ãƒ¼ã‚¹ã®çµ‚ã‚ã‚Šã«é”ã™ã‚‹å‰ã«ã€æˆåŠŸã—ãŸçµæœã‚’ã‚‚ã£ã¦ãƒ‘ãƒ¼ã‚µã¯æ§‹æ–‡è§£æã‚’æ­¢ã‚ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚ˆã†ãªå ´åˆã€å¾Œã‚ã«ç¶šãè¨˜å·ã¯ã‚¨ãƒ©ãƒ¼ã¨ãªã‚‰ãšã«ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã®å¾Œã‚ã«æ”¹è¡ŒãŒ2ã¤ã‚ã£ã¦ã€ãã®å¾Œã‚ã«ã‚´ãƒŸãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãƒ‘ãƒ¼ã‚µã®APIãŒã‚ˆã‚Šè‰¯ããªã‚Œã°ã™ãã«ã€ã“ã®æŒ™å‹•ã¯ä¿®æ­£ã•ã‚Œã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/codeop.rst:56
msgid ""
"Instances of this class have :meth:`__call__` methods identical in signature"
" to the built-in function :func:`compile`, but with the difference that if "
"the instance compiles program text containing a :mod:`__future__` statement,"
" the instance 'remembers' and compiles all subsequent program texts with the"
" statement in force."
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯çµ„ã¿è¾¼ã¿é–¢æ•° :func:`compile` ã¨ã‚·ã‚°ãƒãƒãƒ£ãŒä¸€è‡´ã™ã‚‹ :meth:`__call__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã™ãŒã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ :mod:`__future__` æ–‡ã‚’å«ã‚€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹å ´åˆã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯æœ‰åŠ¹ãªãã®æ–‡ã¨ã¨ã‚‚ã«ç¶šãã™ã¹ã¦ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ†ã‚­ã‚¹ãƒˆã‚’'è¦šãˆã¦ã„ã¦'ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã¨ã„ã†é•ã„ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/codeop.rst:65
msgid ""
"Instances of this class have :meth:`__call__` methods identical in signature"
" to :func:`compile_command`; the difference is that if the instance compiles"
" program text containing a ``__future__`` statement, the instance "
"'remembers' and compiles all subsequent program texts with the statement in "
"force."
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ :func:`compile_command` ã¨ã‚·ã‚°ãƒãƒãƒ£ãŒä¸€è‡´ã™ã‚‹ :meth:`__call__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ ``__future__`` æ–‡ã‚’å«ã‚€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹å ´åˆã«ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯æœ‰åŠ¹ãªãã®æ–‡ã¨ã¨ã‚‚ã«ãã‚Œã«ç¶šãã™ã¹ã¦ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ†ã‚­ã‚¹ãƒˆã‚’'è¦šãˆã¦ã„ã¦'ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã¨ã„ã†é•ã„ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/codeop.rst:70
msgid ""
"A note on version compatibility: the :class:`Compile` and "
":class:`CommandCompiler` are new in Python 2.2.  If you want to enable the "
"future-tracking features of 2.2 but also retain compatibility with 2.1 and "
"earlier versions of Python you can either write ::"
msgstr "ãƒãƒ¼ã‚¸ãƒ§ãƒ³é–“ã®äº’æ›æ€§ã«ã¤ã„ã¦ã®æ³¨æ„: :class:`Compile` ã¨ :class:`CommandCompiler` ã¯Python 2.2 ã§å°å…¥ã•ã‚Œã¾ã—ãŸã€‚2.2 ã® future-tracking æ©Ÿèƒ½ã‚’æœ‰åŠ¹ã«ã™ã‚‹ã ã‘ã§ãªãã€ 2.1 ã¨ Python ã®ã‚ˆã‚Šä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã®äº’æ›æ€§ã‚‚ä¿ã¡ãŸã„å ´åˆã¯ã€æ¬¡ã®ã‚ˆã†ã«æ›¸ãã“ã¨ãŒã§ãã¾ã™ ::"

#: ../../library/codeop.rst:82
msgid ""
"which is a low-impact change, but introduces possibly unwanted global state "
"into your program, or you can write::"
msgstr "ã“ã‚Œã¯å½±éŸ¿ã®å°ã•ã„å¤‰æ›´ã§ã™ãŒã€ã‚ãªãŸã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠãã‚‰ãæœ›ã¾ã‚Œãªã„ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã‚’å°å…¥ã—ã¾ã™ã€‚ã¾ãŸã¯ã€æ¬¡ã®ã‚ˆã†ã«æ›¸ãã“ã¨ã‚‚ã§ãã¾ã™::"

#: ../../library/codeop.rst:92
msgid ""
"and then call ``CommandCompiler`` every time you need a fresh compiler "
"object."
msgstr "ãã—ã¦ã€æ–°ãŸãªã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¿…è¦ã¨ãªã‚‹ãŸã³ã« ``CommandCompiler`` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"
