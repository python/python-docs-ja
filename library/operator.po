# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Shun Sakurai, 2017
# tomoğŸ§, 2017
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2017
# E. Kawashima, 2017
# Arihiro TAKASE, 2017
# takey <taketakeyyy@gmail.com>, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-30 05:56+0900\n"
"PO-Revision-Date: 2017-02-16 23:20+0000\n"
"Last-Translator: takey <taketakeyyy@gmail.com>, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/operator.rst:2
msgid ":mod:`operator` --- Standard operators as functions"
msgstr ":mod:`operator` --- é–¢æ•°å½¢å¼ã®æ¨™æº–æ¼”ç®—å­"

#: ../../library/operator.rst:9
msgid "**Source code:** :source:`Lib/operator.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/operator.py`"

#: ../../library/operator.rst:18
msgid ""
"The :mod:`operator` module exports a set of efficient functions "
"corresponding to the intrinsic operators of Python.  For example, "
"``operator.add(x, y)`` is equivalent to the expression ``x+y``. Many "
"function names are those used for special methods, without the double "
"underscores.  For backward compatibility, many of these have a variant with "
"the double underscores kept. The variants without the double underscores are"
" preferred for clarity."
msgstr ""
":mod:`operator` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€Python ã®çµ„ã¿è¾¼ã¿æ¼”ç®—å­ã«å¯¾å¿œã™ã‚‹åŠ¹ç‡çš„ãªé–¢æ•°ç¾¤ã‚’æä¾›ã—ã¾ã™ã€‚\n"
"ä¾‹ãˆã°ã€ ``operator.add(x, y)`` ã¯å¼ ``x+y`` ã¨ç­‰ä¾¡ã§ã™ã€‚\n"
"å¤šãã®é–¢æ•°åã¯ã€ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹åå‰ã‹ã‚‰å‰å¾Œã®äºŒé‡ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã‚’é™¤ã„ãŸã‚‚ã®ã¨åŒã˜ã§ã™ã€‚\n"
"å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã€ã»ã¨ã‚“ã©ã®é–¢æ•°ã«äºŒé‡ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã‚’ä»˜ã‘ãŸã¾ã¾ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã™ã€‚\n"
"ç°¡æ½”ã•ã®ãŸã‚ã«ã€äºŒé‡ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ãŒç„¡ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®æ–¹ãŒå¥½ã¾ã‚Œã¾ã™ã€‚"

#: ../../library/operator.rst:25
msgid ""
"The functions fall into categories that perform object comparisons, logical "
"operations, mathematical operations and sequence operations."
msgstr "ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ¯”è¼ƒã€è«–ç†æ¼”ç®—ã€æ•°å­¦æ¼”ç®—ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹æ¼”ç®—ã‚’ã™ã‚‹ã‚‚ã®ã«åˆ†é¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/operator.rst:28
msgid ""
"The object comparison functions are useful for all objects, and are named "
"after the rich comparison operators they support:"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ¯”è¼ƒé–¢æ•°ã¯å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§æœ‰åŠ¹ã§ã€é–¢æ•°ã®åå‰ã¯ã‚µãƒãƒ¼ãƒˆã™ã‚‹æ‹¡å¼µæ¯”è¼ƒæ¼”ç®—å­ã‹ã‚‰ã¨ã‚‰ã‚Œã¦ã„ã¾ã™:"

#: ../../library/operator.rst:45
msgid ""
"Perform \"rich comparisons\" between *a* and *b*. Specifically, ``lt(a, b)``"
" is equivalent to ``a < b``, ``le(a, b)`` is equivalent to ``a <= b``, "
"``eq(a, b)`` is equivalent to ``a == b``, ``ne(a, b)`` is equivalent to ``a "
"!= b``, ``gt(a, b)`` is equivalent to ``a > b`` and ``ge(a, b)`` is "
"equivalent to ``a >= b``.  Note that these functions can return any value, "
"which may or may not be interpretable as a Boolean value.  See "
":ref:`comparisons` for more information about rich comparisons."
msgstr ""
"*a* ã¨ *b* ã® \"æ‹¡å¼µæ¯”è¼ƒ (rich comparisons)\" ã‚’è¡Œã„ã¾ã™ã€‚å…·ä½“çš„ã«ã¯ã€ ``lt(a, b)`` ã¯ ``a < "
"b`` ã€ ``le(a, b)`` ã¯ ``a <= b`` ã€ ``eq(a, b)`` ã¯ ``a == b`` ã€ ``ne(a, b)`` ã¯"
" ``a != b`` ã€ ``gt(a, b)`` ã¯ ``a > b`` ã€ãã—ã¦ ``ge(a, b)`` ã¯ ``a >= b`` "
"ã¨ç­‰ä¾¡ã§ã™ã€‚ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ã©ã®ã‚ˆã†ãªå€¤ã‚’è¿”ã—ã¦ã‚‚ã‚ˆãã€ãƒ–ãƒ¼ãƒ«å€¤ã¨ã—ã¦è§£é‡ˆã§ãã¦ã‚‚ã§ããªãã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“ã€‚æ‹¡å¼µæ¯”è¼ƒã®è©³ç´°ã«ã¤ã„ã¦ã¯ "
":ref:`comparisons` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/operator.rst:54
msgid ""
"The logical operations are also generally applicable to all objects, and "
"support truth tests, identity tests, and boolean operations:"
msgstr "è«–ç†æ¼”ç®—ã‚‚ã¾ãŸå…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦é©ç”¨ã§ãã€çœŸç†å€¤åˆ¤å®šã€åŒä¸€æ€§åˆ¤å®šãŠã‚ˆã³ãƒ–ãƒ¼ãƒ«æ¼”ç®—ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™:"

#: ../../library/operator.rst:61
msgid ""
"Return the outcome of :keyword:`not` *obj*.  (Note that there is no "
":meth:`__not__` method for object instances; only the interpreter core "
"defines this operation.  The result is affected by the :meth:`__bool__` and "
":meth:`__len__` methods.)"
msgstr ""
":keyword:`not` *obj* ã®çµæœã‚’è¿”ã—ã¾ã™ã€‚(ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã¯ :meth:`__not__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã¯ç„¡ã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„; ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚³ã‚¢ãŒã“ã®æ¼”ç®—ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã ã‘ã§ã™ã€‚çµæœã¯ :meth:`__bool__` ãŠã‚ˆã³ "
":meth:`__len__` ãƒ¡ã‚½ãƒƒãƒ‰ã«å½±éŸ¿ã•ã‚Œã¾ã™ã€‚)"

#: ../../library/operator.rst:69
msgid ""
"Return :const:`True` if *obj* is true, and :const:`False` otherwise.  This "
"is equivalent to using the :class:`bool` constructor."
msgstr ""
"*obj* ãŒçœŸã®å ´åˆ :const:`True`  ã‚’è¿”ã—ã€ãã†ã§ãªã„å ´åˆ :const:`False` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ "
":class:`bool` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—ã¨åŒç­‰ã§ã™ã€‚"

#: ../../library/operator.rst:75
msgid "Return ``a is b``.  Tests object identity."
msgstr "``a is b`` ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŒä¸€æ€§ã‚’åˆ¤å®šã—ã¾ã™ã€‚"

#: ../../library/operator.rst:80
msgid "Return ``a is not b``.  Tests object identity."
msgstr "``a is not b`` ã‚’è¿”ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŒä¸€æ€§ã‚’åˆ¤å®šã—ã¾ã™ã€‚"

#: ../../library/operator.rst:83
msgid "The mathematical and bitwise operations are the most numerous:"
msgstr "æ¼”ç®—å­ã§æœ€ã‚‚å¤šã„ã®ã¯æ•°å­¦æ¼”ç®—ãŠã‚ˆã³ãƒ“ãƒƒãƒˆå˜ä½ã®æ¼”ç®—ã§ã™:"

#: ../../library/operator.rst:89
msgid "Return the absolute value of *obj*."
msgstr "*obj* ã®çµ¶å¯¾å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:95
msgid "Return ``a + b``, for *a* and *b* numbers."
msgstr "æ•°å€¤ *a* ãŠã‚ˆã³ *b* ã«ã¤ã„ã¦ ``a + b`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:101
msgid "Return the bitwise and of *a* and *b*."
msgstr "*a* ã¨ *b* ã®ãƒ“ãƒƒãƒˆå˜ä½è«–ç†ç©ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:107
msgid "Return ``a // b``."
msgstr "``a // b`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:113
msgid "Return *a* converted to an integer.  Equivalent to ``a.__index__()``."
msgstr "æ•´æ•°ã«å¤‰æ›ã•ã‚ŒãŸ *a* ã‚’è¿”ã—ã¾ã™ã€‚``a.__index__()`` ã¨åŒç­‰ã§ã™ã€‚"

#: ../../library/operator.rst:121
msgid ""
"Return the bitwise inverse of the number *obj*.  This is equivalent to "
"``~obj``."
msgstr "*obj* ã®ãƒ“ãƒƒãƒˆå˜ä½åè»¢ã‚’è¿”ã—ã¾ã™ã€‚``~obj`` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/operator.rst:127
msgid "Return *a* shifted left by *b*."
msgstr "*a* ã® *b* ãƒ“ãƒƒãƒˆå·¦ã‚·ãƒ•ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:133
msgid "Return ``a % b``."
msgstr "``a % b`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:139
msgid "Return ``a * b``, for *a* and *b* numbers."
msgstr "æ•°å€¤ *a* ãŠã‚ˆã³ *b* ã«ã¤ã„ã¦ ``a * b`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:145
msgid "Return ``a @ b``."
msgstr "``a @ b`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:153
msgid "Return *obj* negated (``-obj``)."
msgstr "è² ã® *obj* (``-obj``) ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:159
msgid "Return the bitwise or of *a* and *b*."
msgstr "*a* ã¨ *b* ã®ãƒ“ãƒƒãƒˆå˜ä½è«–ç†å’Œã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:165
msgid "Return *obj* positive (``+obj``)."
msgstr "æ­£ã® *obj* (``+obj``) ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:171
msgid "Return ``a ** b``, for *a* and *b* numbers."
msgstr "æ•°å€¤ *a* ãŠã‚ˆã³ *b* ã«ã¤ã„ã¦ ``a ** b`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:177
msgid "Return *a* shifted right by *b*."
msgstr "*a* ã® *b* ãƒ“ãƒƒãƒˆå³ã‚·ãƒ•ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:183
msgid "Return ``a - b``."
msgstr "``a - b`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:189
msgid ""
"Return ``a / b`` where 2/3 is .66 rather than 0.  This is also known as "
"\"true\" division."
msgstr "2/3 ãŒ 0 ã§ã¯ãªã 0.66 ã¨ãªã‚‹ã‚ˆã†ãª ``a / b``  ã‚’è¿”ã—ã¾ã™ã€‚ \"çœŸã®\" é™¤ç®—ã¨ã—ã¦ã‚‚çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/operator.rst:196
msgid "Return the bitwise exclusive or of *a* and *b*."
msgstr "*a* ãŠã‚ˆã³ *b* ã®ãƒ“ãƒƒãƒˆå˜ä½æ’ä»–çš„è«–ç†å’Œã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:199
msgid ""
"Operations which work with sequences (some of them with mappings too) "
"include:"
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’æ‰±ã†æ¼”ç®—å­ï¼ˆã„ãã¤ã‹ã®æ¼”ç®—å­ã¯ãƒãƒƒãƒ”ãƒ³ã‚°ã‚‚æ‰±ã„ã¾ã™ï¼‰ã«ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ãŒã‚ã‚Šã¾ã™:"

#: ../../library/operator.rst:204
msgid "Return ``a + b`` for *a* and *b* sequences."
msgstr "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *a* ãŠã‚ˆã³ *b* ã«ã¤ã„ã¦ ``a + b`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:210
msgid "Return the outcome of the test ``b in a``. Note the reversed operands."
msgstr "``b in a`` ã®åˆ¤å®šçµæœã‚’è¿”ã—ã¾ã™ã€‚è¢«æ¼”ç®—å­ãŒå·¦å³åè»¢ã—ã¦ã„ã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/operator.rst:215
msgid "Return the number of occurrences of *b* in *a*."
msgstr "*a* ã®ä¸­ã« *b* ãŒå‡ºç¾ã™ã‚‹å›æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:221
msgid "Remove the value of *a* at index *b*."
msgstr "*a* ã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ãŒ *b* ã®å€¤ã‚’å‰Šé™¤ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:227
msgid "Return the value of *a* at index *b*."
msgstr "*a* ã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ãŒ *b* ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:232
msgid "Return the index of the first of occurrence of *b* in *a*."
msgstr "*a* ã§æœ€åˆã« *b* ãŒå‡ºç¾ã™ã‚‹å ´æ‰€ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:238
msgid "Set the value of *a* at index *b* to *c*."
msgstr "*a* ã§ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ãŒ *b* ã®å€¤ã‚’ *c* ã«è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/operator.rst:243
msgid ""
"Return an estimated length for the object *o*. First try to return its "
"actual length, then an estimate using :meth:`object.__length_hint__`, and "
"finally return the default value."
msgstr ""
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *o* ã®æ¦‚ç®—ã®é•·ã•ã‚’è¿”ã—ã¾ã™ã€‚æœ€åˆã«å®Ÿéš›ã®é•·ã•ã‚’ã€æ¬¡ã« :meth:`object.__length_hint__` "
"ã‚’ä½¿ã£ã¦æ¦‚ç®—ã®é•·ã•ã‚’ã€ãã—ã¦æœ€å¾Œã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å€¤ã‚’è¿”ãã†ã¨ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:249
msgid ""
"The :mod:`operator` module also defines tools for generalized attribute and "
"item lookups.  These are useful for making fast field extractors as "
"arguments for :func:`map`, :func:`sorted`, :meth:`itertools.groupby`, or "
"other functions that expect a function argument."
msgstr ""
":mod:`operator` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å±æ€§ã¨ã‚¢ã‚¤ãƒ†ãƒ ã®æ±ç”¨çš„ãªæ¤œç´¢ã®ãŸã‚ã®é“å…·ã‚‚å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ :func:`map`, "
":func:`sorted`, :meth:`itertools.groupby`,  "
"ã‚„é–¢æ•°ã‚’å¼•æ•°ã«å–ã‚‹ãã®ä»–ã®é–¢æ•°ã«å¯¾ã—ã¦é«˜é€Ÿã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŠ½å‡ºã™ã‚‹éš›ã«å¼•æ•°ã¨ã—ã¦ä½¿ã†ã¨ä¾¿åˆ©ã§ã™ã€‚"

#: ../../library/operator.rst:258
msgid ""
"Return a callable object that fetches *attr* from its operand. If more than "
"one attribute is requested, returns a tuple of attributes. The attribute "
"names can also contain dots. For example:"
msgstr ""
"æ¼”ç®—å¯¾è±¡ã‹ã‚‰ *attr* "
"ã‚’å–å¾—ã™ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚äºŒã¤ä»¥ä¸Šã®å±æ€§ã‚’è¦æ±‚ã•ã‚ŒãŸå ´åˆã«ã¯ã€å±æ€§ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚å±æ€§åã¯ãƒ‰ãƒƒãƒˆã‚’å«ã‚€ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ä¾‹ãˆã°:"

#: ../../library/operator.rst:262
msgid ""
"After ``f = attrgetter('name')``, the call ``f(b)`` returns ``b.name``."
msgstr "``f = attrgetter('name')`` ã¨ã—ãŸå¾Œã§ã€``f(b)`` ã‚’å‘¼ã³å‡ºã™ã¨ ``b.name`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:264
msgid ""
"After ``f = attrgetter('name', 'date')``, the call ``f(b)`` returns "
"``(b.name, b.date)``."
msgstr ""
"``f = attrgetter('name', 'date')`` ã¨ã—ãŸå¾Œã§ã€``f(b)`` ã‚’å‘¼ã³å‡ºã™ã¨ ``(b.name, "
"b.date)`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:267
msgid ""
"After ``f = attrgetter('name.first', 'name.last')``, the call ``f(b)`` "
"returns ``(b.name.first, b.name.last)``."
msgstr ""
"``f = attrgetter('name.first', 'name.last')`` ã¨ã—ãŸå¾Œã§ã€``f(b)`` ã‚’å‘¼ã³å‡ºã™ã¨ "
"``(b.name.first, b.name.last)`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:270 ../../library/operator.rst:302
#: ../../library/operator.rst:351
msgid "Equivalent to::"
msgstr "æ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/operator.rst:293
msgid ""
"Return a callable object that fetches *item* from its operand using the "
"operand's :meth:`__getitem__` method.  If multiple items are specified, "
"returns a tuple of lookup values.  For example:"
msgstr ""
"æ¼”ç®—å¯¾è±¡ã‹ã‚‰ãã® :meth:`__getitem__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ *item* ã‚’å–å¾—ã™ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ "
"äºŒã¤ä»¥ä¸Šã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¦æ±‚ã•ã‚ŒãŸå ´åˆã«ã¯ã€ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ä¾‹ãˆã°:"

#: ../../library/operator.rst:297
msgid "After ``f = itemgetter(2)``, the call ``f(r)`` returns ``r[2]``."
msgstr "``f = itemgetter(2)`` ã¨ã—ãŸå¾Œã§ã€``f(r)`` ã‚’å‘¼ã³å‡ºã™ã¨ ``r[2]`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:299
msgid ""
"After ``g = itemgetter(2, 5, 3)``, the call ``g(r)`` returns ``(r[2], r[5], "
"r[3])``."
msgstr ""
"``g = itemgetter(2, 5, 3)`` ã¨ã—ãŸå¾Œã§ã€``g(r)`` ã‚’å‘¼ã³å‡ºã™ã¨ ``(r[2], r[5], r[3])`` "
"ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:314
msgid ""
"The items can be any type accepted by the operand's :meth:`__getitem__` "
"method.  Dictionaries accept any hashable value.  Lists, tuples, and strings"
" accept an index or a slice:"
msgstr ""
"ã‚¢ã‚¤ãƒ†ãƒ ã¯è¢«æ¼”ç®—å­ã® :meth:`__getitem__` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒå—ã‘ä»˜ã‘ã‚‹ã©ã‚“ãªå‹ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚è¾æ›¸ãªã‚‰ã°ä»»æ„ã®ãƒãƒƒã‚·ãƒ¥å¯èƒ½ãªå€¤ã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚ãƒªã‚¹ãƒˆã€ã‚¿ãƒ—ãƒ«ã€æ–‡å­—åˆ—ãªã©ã¯ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ã‹ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å—ã‘ä»˜ã‘ã¾ã™:"

#: ../../library/operator.rst:329
msgid ""
"Example of using :func:`itemgetter` to retrieve specific fields from a tuple"
" record:"
msgstr ":func:`itemgetter` ã‚’ä½¿ã£ã¦ç‰¹å®šã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã‚¿ãƒ—ãƒ«ãƒ¬ã‚³ãƒ¼ãƒ‰ã‹ã‚‰å–ã‚Šå‡ºã™ä¾‹:"

#: ../../library/operator.rst:342
msgid ""
"Return a callable object that calls the method *name* on its operand.  If "
"additional arguments and/or keyword arguments are given, they will be given "
"to the method as well.  For example:"
msgstr ""
"å¼•æ•°ã® *name* "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚è¿½åŠ ã®å¼•æ•°ãŠã‚ˆã³/ã¾ãŸã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ã“ã‚Œã‚‰ã‚‚ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã«å¼•ãæ¸¡ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°:"

#: ../../library/operator.rst:346
msgid ""
"After ``f = methodcaller('name')``, the call ``f(b)`` returns ``b.name()``."
msgstr ""
"``f = methodcaller('name')`` ã¨ã—ãŸå¾Œã§ã€``f(b)`` ã‚’å‘¼ã³å‡ºã™ã¨ ``b.name()`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:348
msgid ""
"After ``f = methodcaller('name', 'foo', bar=1)``, the call ``f(b)`` returns "
"``b.name('foo', bar=1)``."
msgstr ""
"``f = methodcaller('name', 'foo', bar=1)`` ã¨ã—ãŸå¾Œã§ã€``f(b)`` ã‚’å‘¼ã³å‡ºã™ã¨ "
"``b.name('foo', bar=1)`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/operator.rst:362
msgid "Mapping Operators to Functions"
msgstr "æ¼”ç®—å­ã‹ã‚‰é–¢æ•°ã¸ã®å¯¾å¿œè¡¨"

#: ../../library/operator.rst:364
msgid ""
"This table shows how abstract operations correspond to operator symbols in "
"the Python syntax and the functions in the :mod:`operator` module."
msgstr ""
"ä¸‹ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã§ã¯ã€å€‹ã€…ã®æŠ½è±¡çš„ãªæ“ä½œãŒã€ã©ã®ã‚ˆã†ã« Python æ§‹æ–‡ä¸Šã®å„æ¼”ç®—å­ã‚„ :mod:`operator` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–¢æ•°ã«å¯¾å¿œã—ã¦ã„ã‚‹ã‹ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/operator.rst:368
msgid "Operation"
msgstr "æ¼”ç®—"

#: ../../library/operator.rst:368
msgid "Syntax"
msgstr "æ“ä½œ"

#: ../../library/operator.rst:368
msgid "Function"
msgstr "é–¢æ•°"

#: ../../library/operator.rst:370
msgid "Addition"
msgstr "åŠ ç®—"

#: ../../library/operator.rst:370
msgid "``a + b``"
msgstr "``a + b``"

#: ../../library/operator.rst:370
msgid "``add(a, b)``"
msgstr "``add(a, b)``"

#: ../../library/operator.rst:372
msgid "Concatenation"
msgstr "çµåˆ"

#: ../../library/operator.rst:372
msgid "``seq1 + seq2``"
msgstr "``seq1 + seq2``"

#: ../../library/operator.rst:372
msgid "``concat(seq1, seq2)``"
msgstr "``concat(seq1, seq2)``"

#: ../../library/operator.rst:374
msgid "Containment Test"
msgstr "åŒ…å«åˆ¤å®š"

#: ../../library/operator.rst:374
msgid "``obj in seq``"
msgstr "``obj in seq``"

#: ../../library/operator.rst:374
msgid "``contains(seq, obj)``"
msgstr "``contains(seq, obj)``"

#: ../../library/operator.rst:376 ../../library/operator.rst:378
msgid "Division"
msgstr "é™¤ç®—"

#: ../../library/operator.rst:376
msgid "``a / b``"
msgstr "``a / b``"

#: ../../library/operator.rst:376
msgid "``truediv(a, b)``"
msgstr "``truediv(a, b)``"

#: ../../library/operator.rst:378
msgid "``a // b``"
msgstr "``a // b``"

#: ../../library/operator.rst:378
msgid "``floordiv(a, b)``"
msgstr "``floordiv(a, b)``"

#: ../../library/operator.rst:380
msgid "Bitwise And"
msgstr "ãƒ“ãƒƒãƒˆå˜ä½è«–ç†ç©"

#: ../../library/operator.rst:380
msgid "``a & b``"
msgstr "``a & b``"

#: ../../library/operator.rst:380
msgid "``and_(a, b)``"
msgstr "``and_(a, b)``"

#: ../../library/operator.rst:382
msgid "Bitwise Exclusive Or"
msgstr "ãƒ“ãƒƒãƒˆå˜ä½æ’ä»–çš„è«–ç†å’Œ"

#: ../../library/operator.rst:382
msgid "``a ^ b``"
msgstr "``a ^ b``"

#: ../../library/operator.rst:382
msgid "``xor(a, b)``"
msgstr "``xor(a, b)``"

#: ../../library/operator.rst:384
msgid "Bitwise Inversion"
msgstr "ãƒ“ãƒƒãƒˆå˜ä½åè»¢"

#: ../../library/operator.rst:384
msgid "``~ a``"
msgstr "``~ a``"

#: ../../library/operator.rst:384
msgid "``invert(a)``"
msgstr "``invert(a)``"

#: ../../library/operator.rst:386
msgid "Bitwise Or"
msgstr "ãƒ“ãƒƒãƒˆå˜ä½è«–ç†å’Œ"

#: ../../library/operator.rst:386
msgid "``a | b``"
msgstr "``a | b``"

#: ../../library/operator.rst:386
msgid "``or_(a, b)``"
msgstr "``or_(a, b)``"

#: ../../library/operator.rst:388
msgid "Exponentiation"
msgstr "å†ªä¹—"

#: ../../library/operator.rst:388
msgid "``a ** b``"
msgstr "``a ** b``"

#: ../../library/operator.rst:388
msgid "``pow(a, b)``"
msgstr "``pow(a, b)``"

#: ../../library/operator.rst:390 ../../library/operator.rst:392
msgid "Identity"
msgstr "åŒä¸€æ€§"

#: ../../library/operator.rst:390
msgid "``a is b``"
msgstr "``a is b``"

#: ../../library/operator.rst:390
msgid "``is_(a, b)``"
msgstr "``is_(a, b)``"

#: ../../library/operator.rst:392
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../../library/operator.rst:392
msgid "``is_not(a, b)``"
msgstr "``is_not(a, b)``"

#: ../../library/operator.rst:394
msgid "Indexed Assignment"
msgstr "ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹æŒ‡å®šã®ä»£å…¥"

#: ../../library/operator.rst:394
msgid "``obj[k] = v``"
msgstr "``obj[k] = v``"

#: ../../library/operator.rst:394
msgid "``setitem(obj, k, v)``"
msgstr "``setitem(obj, k, v)``"

#: ../../library/operator.rst:396
msgid "Indexed Deletion"
msgstr "ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹æŒ‡å®šã®å‰Šé™¤"

#: ../../library/operator.rst:396
msgid "``del obj[k]``"
msgstr "``del obj[k]``"

#: ../../library/operator.rst:396
msgid "``delitem(obj, k)``"
msgstr "``delitem(obj, k)``"

#: ../../library/operator.rst:398
msgid "Indexing"
msgstr "ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹æŒ‡å®š"

#: ../../library/operator.rst:398
msgid "``obj[k]``"
msgstr "``obj[k]``"

#: ../../library/operator.rst:398
msgid "``getitem(obj, k)``"
msgstr "``getitem(obj, k)``"

#: ../../library/operator.rst:400
msgid "Left Shift"
msgstr "å·¦ã‚·ãƒ•ãƒˆ"

#: ../../library/operator.rst:400
msgid "``a << b``"
msgstr "``a << b``"

#: ../../library/operator.rst:400
msgid "``lshift(a, b)``"
msgstr "``lshift(a, b)``"

#: ../../library/operator.rst:402
msgid "Modulo"
msgstr "å‰°ä½™"

#: ../../library/operator.rst:402
msgid "``a % b``"
msgstr "``a % b``"

#: ../../library/operator.rst:402
msgid "``mod(a, b)``"
msgstr "``mod(a, b)``"

#: ../../library/operator.rst:404
msgid "Multiplication"
msgstr "ä¹—ç®—"

#: ../../library/operator.rst:404
msgid "``a * b``"
msgstr "``a * b``"

#: ../../library/operator.rst:404
msgid "``mul(a, b)``"
msgstr "``mul(a, b)``"

#: ../../library/operator.rst:406
msgid "Matrix Multiplication"
msgstr "è¡Œåˆ—ã®ä¹—ç®—"

#: ../../library/operator.rst:406
msgid "``a @ b``"
msgstr "``a @ b``"

#: ../../library/operator.rst:406
msgid "``matmul(a, b)``"
msgstr "``matmul(a, b)``"

#: ../../library/operator.rst:408
msgid "Negation (Arithmetic)"
msgstr "(ç®—è¡“) è² "

#: ../../library/operator.rst:408
msgid "``- a``"
msgstr "``- a``"

#: ../../library/operator.rst:408
msgid "``neg(a)``"
msgstr "``neg(a)``"

#: ../../library/operator.rst:410
msgid "Negation (Logical)"
msgstr "(è«–ç†) å¦"

#: ../../library/operator.rst:410
msgid "``not a``"
msgstr "``not a``"

#: ../../library/operator.rst:410
msgid "``not_(a)``"
msgstr "``not_(a)``"

#: ../../library/operator.rst:412
msgid "Positive"
msgstr "æ­£"

#: ../../library/operator.rst:412
msgid "``+ a``"
msgstr "``+ a``"

#: ../../library/operator.rst:412
msgid "``pos(a)``"
msgstr "``pos(a)``"

#: ../../library/operator.rst:414
msgid "Right Shift"
msgstr "å³ã‚·ãƒ•ãƒˆ"

#: ../../library/operator.rst:414
msgid "``a >> b``"
msgstr "``a >> b``"

#: ../../library/operator.rst:414
msgid "``rshift(a, b)``"
msgstr "``rshift(a, b)``"

#: ../../library/operator.rst:416
msgid "Slice Assignment"
msgstr "ã‚¹ãƒ©ã‚¤ã‚¹æŒ‡å®šã®ä»£å…¥"

#: ../../library/operator.rst:416
msgid "``seq[i:j] = values``"
msgstr "``seq[i:j] = values``"

#: ../../library/operator.rst:416
msgid "``setitem(seq, slice(i, j), values)``"
msgstr "``setitem(seq, slice(i, j), values)``"

#: ../../library/operator.rst:418
msgid "Slice Deletion"
msgstr "ã‚¹ãƒ©ã‚¤ã‚¹æŒ‡å®šã®å‰Šé™¤"

#: ../../library/operator.rst:418
msgid "``del seq[i:j]``"
msgstr "``del seq[i:j]``"

#: ../../library/operator.rst:418
msgid "``delitem(seq, slice(i, j))``"
msgstr "``delitem(seq, slice(i, j))``"

#: ../../library/operator.rst:420
msgid "Slicing"
msgstr "ã‚¹ãƒ©ã‚¤ã‚¹æŒ‡å®š"

#: ../../library/operator.rst:420
msgid "``seq[i:j]``"
msgstr "``seq[i:j]``"

#: ../../library/operator.rst:420
msgid "``getitem(seq, slice(i, j))``"
msgstr "``getitem(seq, slice(i, j))``"

#: ../../library/operator.rst:422
msgid "String Formatting"
msgstr "æ–‡å­—åˆ—æ›¸å¼åŒ–"

#: ../../library/operator.rst:422
msgid "``s % obj``"
msgstr "``s % obj``"

#: ../../library/operator.rst:422
msgid "``mod(s, obj)``"
msgstr "``mod(s, obj)``"

#: ../../library/operator.rst:424
msgid "Subtraction"
msgstr "æ¸›ç®—"

#: ../../library/operator.rst:424
msgid "``a - b``"
msgstr "``a - b``"

#: ../../library/operator.rst:424
msgid "``sub(a, b)``"
msgstr "``sub(a, b)``"

#: ../../library/operator.rst:426
msgid "Truth Test"
msgstr "çœŸç†å€¤åˆ¤å®š"

#: ../../library/operator.rst:426
msgid "``obj``"
msgstr "``obj``"

#: ../../library/operator.rst:426
msgid "``truth(obj)``"
msgstr "``truth(obj)``"

#: ../../library/operator.rst:428 ../../library/operator.rst:430
#: ../../library/operator.rst:436 ../../library/operator.rst:438
msgid "Ordering"
msgstr "é †åºä»˜ã‘"

#: ../../library/operator.rst:428
msgid "``a < b``"
msgstr "``a < b``"

#: ../../library/operator.rst:428
msgid "``lt(a, b)``"
msgstr "``lt(a, b)``"

#: ../../library/operator.rst:430
msgid "``a <= b``"
msgstr "``a <= b``"

#: ../../library/operator.rst:430
msgid "``le(a, b)``"
msgstr "``le(a, b)``"

#: ../../library/operator.rst:432
msgid "Equality"
msgstr "ç­‰ä¾¡æ€§"

#: ../../library/operator.rst:432
msgid "``a == b``"
msgstr "``a == b``"

#: ../../library/operator.rst:432
msgid "``eq(a, b)``"
msgstr "``eq(a, b)``"

#: ../../library/operator.rst:434
msgid "Difference"
msgstr "ä¸ç­‰æ€§"

#: ../../library/operator.rst:434
msgid "``a != b``"
msgstr "``a != b``"

#: ../../library/operator.rst:434
msgid "``ne(a, b)``"
msgstr "``ne(a, b)``"

#: ../../library/operator.rst:436
msgid "``a >= b``"
msgstr "``a >= b``"

#: ../../library/operator.rst:436
msgid "``ge(a, b)``"
msgstr "``ge(a, b)``"

#: ../../library/operator.rst:438
msgid "``a > b``"
msgstr "``a > b``"

#: ../../library/operator.rst:438
msgid "``gt(a, b)``"
msgstr "``gt(a, b)``"

#: ../../library/operator.rst:442
msgid "Inplace Operators"
msgstr "ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹æ¼”ç®—å­"

#: ../../library/operator.rst:444
msgid ""
"Many operations have an \"in-place\" version.  Listed below are functions "
"providing a more primitive access to in-place operators than the usual "
"syntax does; for example, the :term:`statement` ``x += y`` is equivalent to "
"``x = operator.iadd(x, y)``.  Another way to put it is to say that ``z = "
"operator.iadd(x, y)`` is equivalent to the compound statement ``z = x; z += "
"y``."
msgstr ""
"å¤šãã®æ¼”ç®—ã«ã€Œã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã€ç‰ˆãŒã‚ã‚Šã¾ã™ã€‚ "
"ä»¥ä¸‹ã®é–¢æ•°ã¯ãã†ã—ãŸæ¼”ç®—å­ã®é€šå¸¸ã®æ–‡æ³•ã«æ¯”ã¹ã¦ã‚ˆã‚Šç´ æœ´ãªå‘¼ã³å‡ºã—æ–¹ã‚’æä¾›ã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€æ–‡(:term:`statement`) ``x += y``"
" ã¯ ``x = operator.iadd(x, y)`` ã¨ç­‰ä¾¡ã§ã™ã€‚åˆ¥ã®è¨€ã„æ–¹ã‚’ã™ã‚‹ã¨ã€ ``z = operator.iadd(x, y)`` "
"ã¯è¤‡åˆæ–‡ ``z = x; z += y`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:451
msgid ""
"In those examples, note that when an in-place method is called, the "
"computation and assignment are performed in two separate steps.  The in-"
"place functions listed below only do the first step, calling the in-place "
"method.  The second step, assignment, is not handled."
msgstr ""
"ãªãŠã€ã“ã‚Œã‚‰ã®ä¾‹ã§ã¯ã€ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã€è¨ˆç®—ã¨ä»£å…¥ã¯äºŒæ®µéšã«åˆ†ã‘ã¦è¡Œã‚ã‚Œã¾ã™ã€‚ä»¥ä¸‹ã«æŒ™ã’ã‚‹ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹é–¢æ•°ã¯ã€ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ãã®ç¬¬ä¸€æ®µéšã ã‘ã‚’è¡Œã„ã¾ã™ã€‚ç¬¬äºŒæ®µéšã®ä»£å…¥ã¯æ‰±ã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/operator.rst:456
msgid ""
"For immutable targets such as strings, numbers, and tuples, the updated "
"value is computed, but not assigned back to the input variable:"
msgstr "æ–‡å­—åˆ—ã€æ•°ã€ã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãªã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚¿ãƒ¼ã‚²ãƒƒãƒˆã§ã¯ã€æ›´æ–°ã•ã‚ŒãŸå€¤ãŒè¨ˆç®—ã•ã‚Œã¾ã™ãŒã€å…¥åŠ›å¤‰æ•°ã«ä»£å…¥ã—è¿”ã•ã‚Œã¯ã—ã¾ã›ã‚“ã€‚"

#: ../../library/operator.rst:465
msgid ""
"For mutable targets such as lists and dictionaries, the inplace method will "
"perform the update, so no subsequent assignment is necessary:"
msgstr "ãƒªã‚¹ãƒˆã‚„è¾æ›¸ã®ã‚ˆã†ãªãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚¿ãƒ¼ã‚²ãƒƒãƒˆã§ã¯ã€ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ›´æ–°ã‚’è¡Œã†ã®ã§ã€ç¶šãä»£å…¥ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/operator.rst:477
msgid "``a = iadd(a, b)`` is equivalent to ``a += b``."
msgstr "``a = iadd(a, b)`` ã¯ ``a += b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:483
msgid "``a = iand(a, b)`` is equivalent to ``a &= b``."
msgstr "``a = iand(a, b)`` ã¯ ``a &= b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:489
msgid ""
"``a = iconcat(a, b)`` is equivalent to ``a += b`` for *a* and *b* sequences."
msgstr "``a = iconcat(a, b)`` ã¯äºŒã¤ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *a* ã¨ *b* ã«å¯¾ã— ``a += b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:495
msgid "``a = ifloordiv(a, b)`` is equivalent to ``a //= b``."
msgstr "``a = ifloordiv(a, b)`` ã¯ ``a //= b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:501
msgid "``a = ilshift(a, b)`` is equivalent to ``a <<= b``."
msgstr "``a = ilshift(a, b)`` ã¯ ``a <<= b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:507
msgid "``a = imod(a, b)`` is equivalent to ``a %= b``."
msgstr "``a = imod(a, b)`` ã¯ ``a %= b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:513
msgid "``a = imul(a, b)`` is equivalent to ``a *= b``."
msgstr "``a = imul(a, b)`` ã¯ ``a *= b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:519
msgid "``a = imatmul(a, b)`` is equivalent to ``a @= b``."
msgstr "``a = imatmul(a, b)`` ã¯ ``a @= b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:527
msgid "``a = ior(a, b)`` is equivalent to ``a |= b``."
msgstr "``a = ior(a, b)`` ã¯ ``a |= b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:533
msgid "``a = ipow(a, b)`` is equivalent to ``a **= b``."
msgstr "``a = ipow(a, b)`` ã¯ ``a **= b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:539
msgid "``a = irshift(a, b)`` is equivalent to ``a >>= b``."
msgstr "``a = irshift(a, b)`` ã¯ ``a >>= b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:545
msgid "``a = isub(a, b)`` is equivalent to ``a -= b``."
msgstr "``a = isub(a, b)`` ã¯ ``a -= b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:551
msgid "``a = itruediv(a, b)`` is equivalent to ``a /= b``."
msgstr "``a = itruediv(a, b)`` ã¯ ``a /= b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/operator.rst:557
msgid "``a = ixor(a, b)`` is equivalent to ``a ^= b``."
msgstr "``a = ixor(a, b)`` ã¯ ``a ^= b`` ã¨ç­‰ä¾¡ã§ã™ã€‚"
