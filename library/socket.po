# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Takanori Suzuki <takanori@takanory.net>, 2021
# tomo, 2021
# Osamu NAKAMURA, 2021
# souma987, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-03 14:14+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: souma987, 2023\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/socket.rst:2
msgid ":mod:`socket` --- Low-level networking interface"
msgstr ":mod:`socket` --- 低水準ネットワークインターフェース"

#: ../../library/socket.rst:7
msgid "**Source code:** :source:`Lib/socket.py`"
msgstr "**ソースコード:** :source:`Lib/socket.py`"

#: ../../library/socket.rst:11
msgid ""
"This module provides access to the BSD *socket* interface. It is available "
"on all modern Unix systems, Windows, MacOS, and probably additional "
"platforms."
msgstr ""
"このモジュールはBSDの *ソケット(socket)* インターフェイスへのアクセスを提供し"
"ます。これは、近代的なUnixシステム、Windows、MacOS、その他多くのプラット"
"フォームで動作します。"

#: ../../library/socket.rst:16
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs."
msgstr ""
"いくつかの挙動はプラットフォームに依存します。オペレーティングシステムのソ"
"ケットAPIを呼び出しているためです。"

#: ../../includes/wasm-notavail.rst:3
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ""
":ref:`利用可能性<availability>`: Emscripten でなく、WASI でもないこと。"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"このモジュールは WebAssembly プラットフォーム ``wasm32-emscripten`` と "
"``wasm32-wasi`` では動作しないか、利用不可です。詳しくは、:ref:`wasm-"
"availability` を見てください。"

#: ../../library/socket.rst:24
msgid ""
"The Python interface is a straightforward transliteration of the Unix system "
"call and library interface for sockets to Python's object-oriented style: "
"the :func:`.socket` function returns a :dfn:`socket object` whose methods "
"implement the various socket system calls.  Parameter types are somewhat "
"higher-level than in the C interface: as with :meth:`read` and :meth:`write` "
"operations on Python files, buffer allocation on receive operations is "
"automatic, and buffer length is implicit on send operations."
msgstr ""
"Pythonインターフェースは、Unixのソケット用システムコールとライブラリインター"
"フェースを、そのままPythonのオブジェクト指向スタイルに変換したものです。各種"
"ソケット関連のシステムコールは、 :func:`.socket` 関数で生成される :dfn:"
"`socket オブジェクト` のメソッドとして実装されています。 メソッドの引数は C "
"のインターフェイスよりも多少高水準で、例えばファイルに対する :meth:`read` "
"や :meth:`write` メソッドと同様に、 受信時のバッファ確保は自動的に処理され、"
"送信時のバッファ長は暗黙的に決まります。"

#: ../../library/socket.rst:36
msgid "Module :mod:`socketserver`"
msgstr "Module :mod:`socketserver`"

#: ../../library/socket.rst:36
msgid "Classes that simplify writing network servers."
msgstr "ネットワークサーバの開発を省力化するためのクラス群。"

#: ../../library/socket.rst:38
msgid "Module :mod:`ssl`"
msgstr "Module :mod:`ssl`"

#: ../../library/socket.rst:39
msgid "A TLS/SSL wrapper for socket objects."
msgstr "ソケットオブジェクトに対する TLS/SSL ラッパー."

#: ../../library/socket.rst:43
msgid "Socket families"
msgstr "ソケットファミリー"

#: ../../library/socket.rst:45
msgid ""
"Depending on the system and the build options, various socket families are "
"supported by this module."
msgstr ""
"どのシステムで実行するかとビルドオプションに依存しますが、このモジュールに"
"よって多様なソケットファミリーをサポートします。"

#: ../../library/socket.rst:48
msgid ""
"The address format required by a particular socket object is automatically "
"selected based on the address family specified when the socket object was "
"created.  Socket addresses are represented as follows:"
msgstr ""
"特定のソケットオブジェクトによって必要とされるアドレスフォーマットは、ソケッ"
"トオブジェクトが生成されたときに指定されたアドレスファミリーを元に自動的に選"
"択されます。ソケットアドレスは次の通りです。"

#: ../../library/socket.rst:52
msgid ""
"The address of an :const:`AF_UNIX` socket bound to a file system node is "
"represented as a string, using the file system encoding and the "
"``'surrogateescape'`` error handler (see :pep:`383`).  An address in Linux's "
"abstract namespace is returned as a :term:`bytes-like object` with an "
"initial null byte; note that sockets in this namespace can communicate with "
"normal file system sockets, so programs intended to run on Linux may need to "
"deal with both types of address.  A string or bytes-like object can be used "
"for either type of address when passing it as an argument."
msgstr ""
"ファイルシステム上のノードに束縛された :const:`AF_UNIX` ソケットのアドレス"
"は、ファイルシステムエンコーディングと ``'surrogateescape'`` エラーハンドラ "
"(:pep:`383` を参照) を使って文字列として表現されます。 Linux の抽象名前空間の"
"アドレスは、先頭が null バイトとなる :term:`bytes-like object` として返されま"
"す。この名前空間のソケットは通常のファイルシステム上のソケットと通信できるの"
"で、 Linux 上で動作することを意図したプログラムは両方のアドレスを扱う必要があ"
"る可能性があります。文字列と bytes-like オブジェクトはどちらのタイプのアドレ"
"スにも引数として渡すことができます。"

#: ../../library/socket.rst:62
msgid ""
"Previously, :const:`AF_UNIX` socket paths were assumed to use UTF-8 encoding."
msgstr ""
"これまでは :const:`AF_UNIX` ソケットパスは UTF-8 エンコーディングを使用するも"
"のとされていました。"

#: ../../library/socket.rst:66 ../../library/socket.rst:1043
#: ../../library/socket.rst:1085 ../../library/socket.rst:1844
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr ""
"書き込み可能な :term:`bytes-like object` を使用できるようになりました。"

#: ../../library/socket.rst:71
msgid ""
"A pair ``(host, port)`` is used for the :const:`AF_INET` address family, "
"where *host* is a string representing either a hostname in internet domain "
"notation like ``'daring.cwi.nl'`` or an IPv4 address like "
"``'100.50.200.5'``, and *port* is an integer."
msgstr ""

#: ../../library/socket.rst:76
msgid ""
"For IPv4 addresses, two special forms are accepted instead of a host "
"address: ``''`` represents :const:`INADDR_ANY`, which is used to bind to all "
"interfaces, and the string ``'<broadcast>'`` represents :const:"
"`INADDR_BROADCAST`.  This behavior is not compatible with IPv6, therefore, "
"you may want to avoid these if you intend to support IPv6 with your Python "
"programs."
msgstr ""

#: ../../library/socket.rst:83
msgid ""
"For :const:`AF_INET6` address family, a four-tuple ``(host, port, flowinfo, "
"scope_id)`` is used, where *flowinfo* and *scope_id* represent the "
"``sin6_flowinfo`` and ``sin6_scope_id`` members in :const:`struct "
"sockaddr_in6` in C.  For :mod:`socket` module methods, *flowinfo* and "
"*scope_id* can be omitted just for backward compatibility.  Note, however, "
"omission of *scope_id* can cause problems in manipulating scoped IPv6 "
"addresses."
msgstr ""
":const:`AF_INET6` アドレスファミリーでは、 ``(host, port, flowinfo, "
"scope_id)`` の4 要素のタプルが利用されます。 *flowinfo* と *scopeid* はそれぞ"
"れC言語の :const:`struct sockaddr_in6` の ``sin6_flowinfo`` と "
"``sin6_scope_id`` メンバーを表します。 :mod:`socket` モジュールのメソッドで"
"は、後方互換性のために *flowinfo* と *scope_id* の省略を許しています。しか"
"し、 *scope_id* を省略すると scope された IPv6 アドレスを操作するときに問題が"
"起こる場合があることに注意してください。"

#: ../../library/socket.rst:90
msgid ""
"For multicast addresses (with *scope_id* meaningful) *address* may not "
"contain ``%scope_id`` (or ``zone id``) part. This information is superfluous "
"and may be safely omitted (recommended)."
msgstr ""

#: ../../library/socket.rst:95
msgid ":const:`AF_NETLINK` sockets are represented as pairs ``(pid, groups)``."
msgstr ""
":const:`AF_NETLINK` ソケットのアドレスは ``(pid, groups)`` のペアで表されま"
"す。"

#: ../../library/socket.rst:97
msgid ""
"Linux-only support for TIPC is available using the :const:`AF_TIPC` address "
"family.  TIPC is an open, non-IP based networked protocol designed for use "
"in clustered computer environments.  Addresses are represented by a tuple, "
"and the fields depend on the address type. The general tuple form is "
"``(addr_type, v1, v2, v3 [, scope])``, where:"
msgstr ""
"Linux 限定で、 :const:`AF_TIPC` アドレスファミリーを用いて TIPC がサポートさ"
"れます。 TIPC は、クラスタコンピューティング環境のために設計された、IP ベース"
"ではないオープンなネットワークプロトコルです。アドレスはタプルで表現され、"
"フィールドはアドレスタイプに依存します。一般的なタプルの形式は ``(addr_type, "
"v1, v2, v3 [, scope])`` で、それぞれは次の通りです:"

#: ../../library/socket.rst:103
msgid ""
"*addr_type* is one of :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"or :const:`TIPC_ADDR_ID`."
msgstr ""
"*addr_type* は :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, :const:"
"`TIPC_ADDR_ID` の1つ。"

#: ../../library/socket.rst:105
msgid ""
"*scope* is one of :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, "
"and :const:`TIPC_NODE_SCOPE`."
msgstr ""
"*scope* は :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, :const:"
"`TIPC_NODE_SCOPE` の1つ。"

#: ../../library/socket.rst:107
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAME`, then *v1* is the server type, "
"*v2* is the port identifier, and *v3* should be 0."
msgstr ""
"*addr_type* が :const:`TIPC_ADDR_NAME` の場合、 *v1* はサーバータイプ、 *v2* "
"はポートID (the port identifier)、そして *v3* は 0 であるべきです。"

#: ../../library/socket.rst:110
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAMESEQ`, then *v1* is the server type, "
"*v2* is the lower port number, and *v3* is the upper port number."
msgstr ""
"*addr_type* が :const:`TIPC_ADDR_NAMESEQ` の場合、 *v1* はサーバータイプ、 "
"*v2* はポート番号下位(lower port number)、 *v3* はポート番号上位(upper port "
"number) です。"

#: ../../library/socket.rst:113
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_ID`, then *v1* is the node, *v2* is the "
"reference, and *v3* should be set to 0."
msgstr ""
"*addr_type* が :const:`TIPC_ADDR_ID` の場合、 *v1* はノード、 *v2* は参照、 "
"*v3* は0であるべきです。"

#: ../../library/socket.rst:116
msgid ""
"A tuple ``(interface, )`` is used for the :const:`AF_CAN` address family, "
"where *interface* is a string representing a network interface name like "
"``'can0'``. The network interface name ``''`` can be used to receive packets "
"from all network interfaces of this family."
msgstr ""
":const:`AF_CAN` アドレスファミリーには ``(interface, )`` というタプルを利用し"
"ます。 *interface* は ``'can0'`` のようなネットワークインターフェース名を表す"
"文字列です。このファミリーの全てのネットワークインターフェースからパケットを"
"受信するために、ネットワークインターフェース名 ``''`` を利用できます。"

#: ../../library/socket.rst:121
msgid ""
":const:`CAN_ISOTP` protocol require a tuple ``(interface, rx_addr, "
"tx_addr)`` where both additional parameters are unsigned long integer that "
"represent a CAN identifier (standard or extended)."
msgstr ""

#: ../../library/socket.rst:124
msgid ""
":const:`CAN_J1939` protocol require a tuple ``(interface, name, pgn, addr)`` "
"where additional parameters are 64-bit unsigned integer representing the ECU "
"name, a 32-bit unsigned integer representing the Parameter Group Number "
"(PGN), and an 8-bit integer representing the address."
msgstr ""

#: ../../library/socket.rst:129
msgid ""
"A string or a tuple ``(id, unit)`` is used for the :const:`SYSPROTO_CONTROL` "
"protocol of the :const:`PF_SYSTEM` family. The string is the name of a "
"kernel control using a dynamically assigned ID. The tuple can be used if ID "
"and unit number of the kernel control are known or if a registered ID is "
"used."
msgstr ""

#: ../../library/socket.rst:137
msgid ""
":const:`AF_BLUETOOTH` supports the following protocols and address formats:"
msgstr ""
":const:`AF_BLUETOOTH` は以下のプロトコルとアドレスフォーマットをサポートして"
"います。"

#: ../../library/socket.rst:140
msgid ""
":const:`BTPROTO_L2CAP` accepts ``(bdaddr, psm)`` where ``bdaddr`` is the "
"Bluetooth address as a string and ``psm`` is an integer."
msgstr ""
":const:`BTPROTO_L2CAP` は ``(bdaddr, psm)`` を受け取ります。\n"
"``bdaddr`` は Bluetooth アドレスを表す文字列で、 ``psm`` は整数です。"

#: ../../library/socket.rst:143
msgid ""
":const:`BTPROTO_RFCOMM` accepts ``(bdaddr, channel)`` where ``bdaddr`` is "
"the Bluetooth address as a string and ``channel`` is an integer."
msgstr ""
":const:`BTPROTO_RFCOMM` は ``(bdaddr, channel)`` を受け取ります。\n"
"``bdaddr`` は Bluetooth アドレスを表す文字列で、 ``channel`` は整数です。"

#: ../../library/socket.rst:146
msgid ""
":const:`BTPROTO_HCI` accepts ``(device_id,)`` where ``device_id`` is either "
"an integer or a string with the Bluetooth address of the interface. (This "
"depends on your OS; NetBSD and DragonFlyBSD expect a Bluetooth address while "
"everything else expects an integer.)"
msgstr ""
":const:`BTPROTO_HCI` は ``(device_id,)`` を受け取ります。 ``device_id`` は、"
"数値またはインターフェイスの Bluetooth アドレスを表す文字列です。(OS に依存し"
"ます。NetBSD と DragonFlyBSD は Bluetooth アドレスを期待しますが、その他すべ"
"ての OS は、数値を期待します。)"

#: ../../library/socket.rst:151
msgid "NetBSD and DragonFlyBSD support added."
msgstr "NetBSD と DragonFlyBSD のサポートが追加されました。"

#: ../../library/socket.rst:154
msgid ""
":const:`BTPROTO_SCO` accepts ``bdaddr`` where ``bdaddr`` is a :class:`bytes` "
"object containing the Bluetooth address in a string format. (ex. "
"``b'12:23:34:45:56:67'``) This protocol is not supported under FreeBSD."
msgstr ""
":const:`BTPROTO_SCO` は ``bdaddr`` を受け取ります。ここで、 ``bdaddr`` は "
"Bluetooth アドレスを文字列形式で持つ :class:`bytes` オブジェクトです (例: "
"``b'12:23:34:45:56:67'``)。このプロトコルは、  FreeBSD ではサポートされていま"
"せん。"

#: ../../library/socket.rst:159
msgid ""
":const:`AF_ALG` is a Linux-only socket based interface to Kernel "
"cryptography. An algorithm socket is configured with a tuple of two to four "
"elements ``(type, name [, feat [, mask]])``, where:"
msgstr ""
":const:`AF_ALG` はカーネル暗号へのソケットベースのインターフェイスで、Linux "
"でのみ使用できます。アルゴリズムソケットは、2 つから 4 つの要素を持つタプル "
"``(type, name [, feat [, mask]])`` で構成されます。各要素の意味は、以下の通り"
"です。"

#: ../../library/socket.rst:163
msgid ""
"*type* is the algorithm type as string, e.g. ``aead``, ``hash``, "
"``skcipher`` or ``rng``."
msgstr ""
"*type* はアルゴリズムタイプを示す文字列です。例: ``aead``, ``hash``, "
"``skcipher`` または ``rng``。"

#: ../../library/socket.rst:166
msgid ""
"*name* is the algorithm name and operation mode as string, e.g. ``sha256``, "
"``hmac(sha256)``, ``cbc(aes)`` or ``drbg_nopr_ctr_aes256``."
msgstr ""
"*name* はアルゴリズム名及び操作モードを示す文字列です。例: ``sha256``, "
"``hmac(sha256)``, ``cbc(aes)`` または ``drbg_nopr_ctr_aes256``。"

#: ../../library/socket.rst:169
msgid "*feat* and *mask* are unsigned 32bit integers."
msgstr "*feat* と *mask* は、符号を持たない 32 ビットの整数です。"

#: ../../library/socket.rst:171 ../../library/socket.rst:519
#: ../../library/socket.rst:1766
msgid ":ref:`Availability <availability>`: Linux >= 2.6.38."
msgstr ":ref:`利用可能な環境 <availability>`: Linux 2.6.38以上。"

#: ../../library/socket.rst:173
msgid "Some algorithm types require more recent Kernels."
msgstr ""

#: ../../library/socket.rst:177
msgid ""
":const:`AF_VSOCK` allows communication between virtual machines and their "
"hosts. The sockets are represented as a ``(CID, port)`` tuple where the "
"context ID or CID and port are integers."
msgstr ""

#: ../../library/socket.rst:181 ../../library/socket.rst:592
msgid ":ref:`Availability <availability>`: Linux >= 3.9"
msgstr ""

#: ../../library/socket.rst:183
msgid "See :manpage:`vsock(7)`"
msgstr ""

#: ../../library/socket.rst:187
msgid ""
":const:`AF_PACKET` is a low-level interface directly to network devices. The "
"packets are represented by the tuple ``(ifname, proto[, pkttype[, hatype[, "
"addr]]])`` where:"
msgstr ""

#: ../../library/socket.rst:191
msgid "*ifname* - String specifying the device name."
msgstr "*ifname* - デバイス名を指定する文字列。"

#: ../../library/socket.rst:192
msgid ""
"*proto* - An in network-byte-order integer specifying the Ethernet protocol "
"number."
msgstr ""

#: ../../library/socket.rst:194
msgid "*pkttype* - Optional integer specifying the packet type:"
msgstr "*pkttype* - パケットタイプを指定するオプションの整数:"

#: ../../library/socket.rst:196
msgid "``PACKET_HOST`` (the default) - Packet addressed to the local host."
msgstr ""

#: ../../library/socket.rst:197
msgid "``PACKET_BROADCAST`` - Physical-layer broadcast packet."
msgstr ""

#: ../../library/socket.rst:198
msgid ""
"``PACKET_MULTICAST`` - Packet sent to a physical-layer multicast address."
msgstr ""

#: ../../library/socket.rst:199
msgid ""
"``PACKET_OTHERHOST`` - Packet to some other host that has been caught by a "
"device driver in promiscuous mode."
msgstr ""

#: ../../library/socket.rst:201
msgid ""
"``PACKET_OUTGOING`` - Packet originating from the local host that is looped "
"back to a packet socket."
msgstr ""

#: ../../library/socket.rst:203
msgid "*hatype* - Optional integer specifying the ARP hardware address type."
msgstr ""

#: ../../library/socket.rst:204
msgid ""
"*addr* - Optional bytes-like object specifying the hardware physical "
"address, whose interpretation depends on the device."
msgstr ""

#: ../../library/socket.rst:207 ../../library/socket.rst:480
msgid ":ref:`Availability <availability>`: Linux >= 2.2."
msgstr ":ref:`利用可能な環境 <availability>`: Linux 2.2以上。"

#: ../../library/socket.rst:209
msgid ""
":const:`AF_QIPCRTR` is a Linux-only socket based interface for communicating "
"with services running on co-processors in Qualcomm platforms. The address "
"family is represented as a ``(node, port)`` tuple where the *node* and "
"*port* are non-negative integers."
msgstr ""

#: ../../library/socket.rst:214 ../../library/socket.rst:568
msgid ":ref:`Availability <availability>`: Linux >= 4.7."
msgstr ":ref:`利用可能な環境 <availability>`: Linux 4.7以上。"

#: ../../library/socket.rst:218
msgid ""
":const:`IPPROTO_UDPLITE` is a variant of UDP which allows you to specify "
"what portion of a packet is covered with the checksum. It adds two socket "
"options that you can change. ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)`` will change what portion of outgoing packets "
"are covered by the checksum and ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_RECV_CSCOV, length)`` will filter out packets which cover too little "
"of their data. In both cases ``length`` should be in ``range(8, 2**16, 8)``."
msgstr ""

#: ../../library/socket.rst:227
msgid ""
"Such a socket should be constructed with ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv4 or ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv6."
msgstr ""

#: ../../library/socket.rst:231
msgid ":ref:`Availability <availability>`: Linux >= 2.6.20, FreeBSD >= 10.1"
msgstr ""

#: ../../library/socket.rst:235
msgid ""
"If you use a hostname in the *host* portion of IPv4/v6 socket address, the "
"program may show a nondeterministic behavior, as Python uses the first "
"address returned from the DNS resolution.  The socket address will be "
"resolved differently into an actual IPv4/v6 address, depending on the "
"results from DNS resolution and/or the host configuration.  For "
"deterministic behavior use a numeric address in *host* portion."
msgstr ""
"IPv4/v6ソケットの *host* 部にホスト名を指定すると、処理結果が一定ではない場合"
"があります。これはPythonはDNSから取得したアドレスのうち最初のアドレスを使用す"
"るので、 DNSの処理やホストの設定によって異なるIPv4/6アドレスを取得する場合が"
"あるためです。常に同じ結果が必要であれば、 *host* に数値のアドレスを指定して"
"ください。"

#: ../../library/socket.rst:242
msgid ""
"All errors raise exceptions.  The normal exceptions for invalid argument "
"types and out-of-memory conditions can be raised. Errors related to socket "
"or address semantics raise :exc:`OSError` or one of its subclasses."
msgstr ""

#: ../../library/socket.rst:247
msgid ""
"Non-blocking mode is supported through :meth:`~socket.setblocking`.  A "
"generalization of this based on timeouts is supported through :meth:`~socket."
"settimeout`."
msgstr ""
":meth:`~socket.setblocking` メソッドで、非ブロッキングモードを使用することが"
"できます。また、より汎用的に :meth:`~socket.settimeout` メソッドでタイムアウ"
"トを指定する事ができます。"

#: ../../library/socket.rst:253
msgid "Module contents"
msgstr "モジュールの内容"

#: ../../library/socket.rst:255
msgid "The module :mod:`socket` exports the following elements."
msgstr ":mod:`socket` モジュールは以下の要素を公開しています。"

#: ../../library/socket.rst:259
msgid "Exceptions"
msgstr "例外"

#: ../../library/socket.rst:263
msgid "A deprecated alias of :exc:`OSError`."
msgstr ":exc:`OSError` の非推奨のエイリアスです。"

#: ../../library/socket.rst:265
msgid "Following :pep:`3151`, this class was made an alias of :exc:`OSError`."
msgstr ""
":pep:`3151` に基づき、このクラスは :exc:`OSError` のエイリアスになりました。"

#: ../../library/socket.rst:271
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors, i.e. for functions that use *h_errno* in the POSIX C API, including :"
"func:`gethostbyname_ex` and :func:`gethostbyaddr`. The accompanying value is "
"a pair ``(h_errno, string)`` representing an error returned by a library "
"call.  *h_errno* is a numeric value, while *string* represents the "
"description of *h_errno*, as returned by the :c:func:`hstrerror` C function."
msgstr ""
":exc:`OSError` のサブクラス。この例外はアドレス関連のエラー、つまり :func:"
"`gethostbyname_ex` と :func:`gethostbyaddr` などの、 POSIX C API の "
"*h_errno* を利用する関数のために利用されます。例外に付随する ``(h_errno, "
"string)`` ペアはライブラリの呼び出しによって返されたエラーを表します。 "
"*h_errno* は数値で、 *string* は、 :c:func:`hstrerror` C関数によって返される "
"*h_errno* を説明する文字列です。"

#: ../../library/socket.rst:279 ../../library/socket.rst:292
#: ../../library/socket.rst:305
msgid "This class was made a subclass of :exc:`OSError`."
msgstr "このクラスは :exc:`OSError` のサブクラスになりました。"

#: ../../library/socket.rst:284
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors by :func:`getaddrinfo` and :func:`getnameinfo`. The accompanying "
"value is a pair ``(error, string)`` representing an error returned by a "
"library call.  *string* represents the description of *error*, as returned "
"by the :c:func:`gai_strerror` C function.  The numeric *error* value will "
"match one of the :const:`EAI_\\*` constants defined in this module."
msgstr ""
":exc:`OSError` のサブクラスです。この例外は :func:`getaddrinfo` と :func:"
"`getnameinfo` でアドレス関連のエラーが発生した場合に送出されます。例外の値は "
"``(error, string)`` のペアで、ライブラリの呼び出し結果を返します。 *string* "
"はC関数 :c:func:`gai_strerror` で取得した、 *error* の意味を示す文字列です。 "
"*error* の値は、このモジュールで定義される :const:`EAI_\\*` 定数のどれかとな"
"ります。"

#: ../../library/socket.rst:297
msgid "A deprecated alias of :exc:`TimeoutError`."
msgstr ""

#: ../../library/socket.rst:299
msgid ""
"A subclass of :exc:`OSError`, this exception is raised when a timeout occurs "
"on a socket which has had timeouts enabled via a prior call to :meth:"
"`~socket.settimeout` (or implicitly through :func:`~socket."
"setdefaulttimeout`).  The accompanying value is a string whose value is "
"currently always \"timed out\"."
msgstr ""
":exc:`OSError` のサブクラスです。この例外は、あらかじめ :meth:`~socket."
"settimeout` を呼び出して (あるいは :func:`~socket.setdefaulttimeout` を利用し"
"て暗黙に) タイムアウトを有効にしてあるソケットでタイムアウトが生じた際に送出"
"されます。 例外に付属する値は文字列で、その内容は現状では常に \"timed out\" "
"となります。"

#: ../../library/socket.rst:308
msgid "This class was made an alias of :exc:`TimeoutError`."
msgstr ""

#: ../../library/socket.rst:313
msgid "Constants"
msgstr "定数"

#: ../../library/socket.rst:315
msgid ""
"The AF_* and SOCK_* constants are now :class:`AddressFamily` and :class:"
"`SocketKind` :class:`.IntEnum` collections."
msgstr ""
"AF_* 定数と SOCK_* 定数は、 :class:`AddressFamily` と :class:`SocketKind` :"
"class:`.IntEnum` collection になりました。"

#: ../../library/socket.rst:324
msgid ""
"These constants represent the address (and protocol) families, used for the "
"first argument to :func:`.socket`.  If the :const:`AF_UNIX` constant is not "
"defined then this protocol is unsupported.  More constants may be available "
"depending on the system."
msgstr ""
"アドレス (およびプロトコル) ファミリーを示す定数で、 :func:`.socket` の 最初"
"の引数に指定することができます。 :const:`AF_UNIX` ファミリーをサポート しない"
"プラットフォームでは、 :const:`AF_UNIX` は未定義となります。システムによって"
"はこれら以外の定数が定義されているかもしれません。"

#: ../../library/socket.rst:336
msgid ""
"These constants represent the socket types, used for the second argument to :"
"func:`.socket`.  More constants may be available depending on the system. "
"(Only :const:`SOCK_STREAM` and :const:`SOCK_DGRAM` appear to be generally "
"useful.)"
msgstr ""
"ソケットタイプを示す定数で、 :func:`.socket` の2番目の引数に指定することがで"
"きます。システムによってはこれら以外の定数が定義されているかもしれません。 "
"(ほとんどの場合、 :const:`SOCK_STREAM` と :const:`SOCK_DGRAM` 以外は必要あり"
"ません。)"

#: ../../library/socket.rst:344
msgid ""
"These two constants, if defined, can be combined with the socket types and "
"allow you to set some flags atomically (thus avoiding possible race "
"conditions and the need for separate calls)."
msgstr ""
"この2つの定数が定義されていた場合、ソケットタイプと組み合わせていくつかの "
"flags をアトミックに設定することができます (別の呼び出しを不要にして競合状態"
"を避ける事ができます)。"

#: ../../library/socket.rst:350
msgid ""
"`Secure File Descriptor Handling <https://udrepper.livejournal.com/20407."
"html>`_ for a more thorough explanation."
msgstr ""

#: ../../library/socket.rst:353
msgid ":ref:`Availability <availability>`: Linux >= 2.6.27."
msgstr ":ref:`利用可能な環境 <availability>`: Linux 2.6.27以上。"

#: ../../library/socket.rst:372
msgid ""
"Many constants of these forms, documented in the Unix documentation on "
"sockets and/or the IP protocol, are also defined in the socket module. They "
"are generally used in arguments to the :meth:`setsockopt` and :meth:"
"`getsockopt` methods of socket objects.  In most cases, only those symbols "
"that are defined in the Unix header files are defined; for a few symbols, "
"default values are provided."
msgstr ""
"Unixのソケット・IPプロトコルのドキュメントで定義されている各種定数。ソケット"
"オブジェクトの :meth:`setsockopt` や :meth:`getsockopt` で使用します。ほとん"
"どのシンボルはUnixのヘッダファイルに従っています。一部のシンボルには、デフォ"
"ルト値を定義してあります。"

#: ../../library/socket.rst:379
msgid ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` were added."
msgstr ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` が追加されました。"

#: ../../library/socket.rst:383
msgid ""
"On Windows, ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` appear if run-time Windows "
"supports."
msgstr ""
"Windowsでは、実行時のWindowsがサポートしているならば ``TCP_FASTOPEN``、 "
"``TCP_KEEPCNT``が表示されます。"

#: ../../library/socket.rst:387
msgid "``TCP_NOTSENT_LOWAT`` was added."
msgstr "``TCP_NOTSENT_LOWAT``が追加されました。"

#: ../../library/socket.rst:390
msgid ""
"On Windows, ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` appear if run-time Windows "
"supports."
msgstr ""
"Windowsでは、実行時のWindowsがサポートしているならば  ``TCP_KEEPIDLE``, "
"``TCP_KEEPINTVL`` が表示されます。"

#: ../../library/socket.rst:393
msgid ""
"``IP_RECVTOS`` was added.  Added ``TCP_KEEPALIVE``. On MacOS this constant "
"can be used in the same  way that ``TCP_KEEPIDLE`` is used on Linux."
msgstr ""

#: ../../library/socket.rst:398
msgid ""
"Added ``TCP_CONNECTION_INFO``. On MacOS this constant can be used in the "
"same way that ``TCP_INFO`` is used on Linux and BSD."
msgstr ""

#: ../../library/socket.rst:407 ../../library/socket.rst:477
#: ../../library/socket.rst:488
msgid ""
"Many constants of these forms, documented in the Linux documentation, are "
"also defined in the socket module."
msgstr ""
"Linux ドキュメントにあるこの形式の定数は socket モジュールでも定義されていま"
"す。"

#: ../../library/socket.rst:410
msgid ":ref:`Availability <availability>`: Linux >= 2.6.25, NetBSD >= 8."
msgstr ""

#: ../../library/socket.rst:414
msgid "NetBSD support was added."
msgstr ""

#: ../../library/socket.rst:420
msgid ""
"CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) "
"protocol. Broadcast manager constants, documented in the Linux "
"documentation, are also defined in the socket module."
msgstr ""
"CANプロトコルファミリーのCAN_BCMは、ブロードキャストマネージャー(BCM)プロトコ"
"ルです。Linuxドキュメントにあるこの形式の定数は、socketモジュールでも定義され"
"ています。"

#: ../../library/socket.rst:424 ../../library/socket.rst:459
msgid ":ref:`Availability <availability>`: Linux >= 2.6.25."
msgstr ":ref:`利用可能な環境 <availability>`: Linux 2.6.25以上。"

#: ../../library/socket.rst:427
msgid ""
"The :data:`CAN_BCM_CAN_FD_FRAME` flag is only available on Linux >= 4.8."
msgstr ""

#: ../../library/socket.rst:433
msgid ""
"Enables CAN FD support in a CAN_RAW socket. This is disabled by default. "
"This allows your application to send both CAN and CAN FD frames; however, "
"you must accept both CAN and CAN FD frames when reading from the socket."
msgstr ""
"CAN_RAW ソケットで CAN FD をサポートします。これはデフォルトで無効になってい"
"ます。これにより、アプリケーションが CAN フレームと CAN FD フレームを送信でき"
"るようになります。ただし、ソケットからの読み出し時に、CAN と CAN FD の両方の"
"フレームを受け入れなければなりません。"

#: ../../library/socket.rst:437 ../../library/socket.rst:448
msgid "This constant is documented in the Linux documentation."
msgstr "この定数は、 Linux のドキュメンテーションで説明されています。"

#: ../../library/socket.rst:439
msgid ":ref:`Availability <availability>`: Linux >= 3.6."
msgstr ":ref:`利用可能な環境 <availability>`: Linux 3.6以上。"

#: ../../library/socket.rst:445
msgid ""
"Joins the applied CAN filters such that only CAN frames that match all given "
"CAN filters are passed to user space."
msgstr ""

#: ../../library/socket.rst:450
msgid ":ref:`Availability <availability>`: Linux >= 4.1."
msgstr ":ref:`利用可能な環境 <availability>`: Linux 4.1以上。"

#: ../../library/socket.rst:456
msgid ""
"CAN_ISOTP, in the CAN protocol family, is the ISO-TP (ISO 15765-2) protocol. "
"ISO-TP constants, documented in the Linux documentation."
msgstr ""

#: ../../library/socket.rst:465
msgid ""
"CAN_J1939, in the CAN protocol family, is the SAE J1939 protocol. J1939 "
"constants, documented in the Linux documentation."
msgstr ""

#: ../../library/socket.rst:468
msgid ":ref:`Availability <availability>`: Linux >= 5.4."
msgstr ":ref:`利用可能な環境 <availability>`: Linux 5.4以上。"

#: ../../library/socket.rst:491
msgid ":ref:`Availability <availability>`: Linux >= 2.6.30."
msgstr ":ref:`利用可能な環境 <availability>`: Linux 2.6.30以上。"

#: ../../library/socket.rst:501
msgid ""
"Constants for Windows' WSAIoctl(). The constants are used as arguments to "
"the :meth:`~socket.socket.ioctl` method of socket objects."
msgstr ""
"Windows の WSAIoctl() のための定数です。この定数はソケットオブジェクトの :"
"meth:`~socket.socket.ioctl` メソッドに引数として渡されます。"

#: ../../library/socket.rst:504 ../../library/socket.rst:1458
msgid "``SIO_LOOPBACK_FAST_PATH`` was added."
msgstr "``SIO_LOOPBACK_FAST_PATH`` が追加されました。"

#: ../../library/socket.rst:510
msgid ""
"TIPC related constants, matching the ones exported by the C socket API. See "
"the TIPC documentation for more information."
msgstr ""
"TIPC 関連の定数で、C のソケットAPIが公開しているものにマッチします。詳しい情"
"報は TIPC のドキュメントを参照してください。"

#: ../../library/socket.rst:517
msgid "Constants for Linux Kernel cryptography."
msgstr "Linux カーネル暗号用の定数です。"

#: ../../library/socket.rst:529
msgid "Constants for Linux host/guest communication."
msgstr ""

#: ../../library/socket.rst:531
msgid ":ref:`Availability <availability>`: Linux >= 4.8."
msgstr ":ref:`利用可能な環境 <availability>`: Linux 4.8以上。"

#: ../../library/socket.rst:537
msgid ":ref:`Availability <availability>`: BSD, macOS."
msgstr ""

#: ../../library/socket.rst:543
msgid ""
"This constant contains a boolean value which indicates if IPv6 is supported "
"on this platform."
msgstr "現在のプラットフォームでIPv6がサポートされているか否かを示す真偽値。"

#: ../../library/socket.rst:549
msgid ""
"These are string constants containing Bluetooth addresses with special "
"meanings. For example, :const:`BDADDR_ANY` can be used to indicate any "
"address when specifying the binding socket with :const:`BTPROTO_RFCOMM`."
msgstr ""
"これらは、特別な意味を持つ Bluetooth アドレスを含む文字列定数です。例えば、:"
"const:`BDADDR_ANY` を使用すると、 :const:`BTPROTO_RFCOMM` で束縛ソケットを指"
"定する際に、任意のアドレスを指し示すことができます。"

#: ../../library/socket.rst:558
msgid ""
"For use with :const:`BTPROTO_HCI`. :const:`HCI_FILTER` is not available for "
"NetBSD or DragonFlyBSD. :const:`HCI_TIME_STAMP` and :const:`HCI_DATA_DIR` "
"are not available for FreeBSD, NetBSD, or DragonFlyBSD."
msgstr ""
":const:`BTPROTO_HCI` で使用します。 :const:`HCI_FILTER` は NetBSD または "
"DragonFlyBSD では使用できません。 :const:`HCI_TIME_STAMP` と :const:"
"`HCI_DATA_DIR` は FreeBSD, NetBSD, DragonFlyBSD では使用できません。"

#: ../../library/socket.rst:565
msgid ""
"Constant for Qualcomm's IPC router protocol, used to communicate with "
"service providing remote processors."
msgstr ""

#: ../../library/socket.rst:574
msgid ""
"LOCAL_CREDS and LOCAL_CREDS_PERSISTENT can be used with SOCK_DGRAM, "
"SOCK_STREAM sockets, equivalent to Linux/DragonFlyBSD SO_PASSCRED, while "
"LOCAL_CREDS sends the credentials at first read, LOCAL_CREDS_PERSISTENT "
"sends for each read, SCM_CREDS2 must be then used for the latter for the "
"message type."
msgstr ""

#: ../../library/socket.rst:583
msgid ":ref:`Availability <availability>`: FreeBSD."
msgstr ""

#: ../../library/socket.rst:587
msgid ""
"Constant to optimize CPU locality, to be used in conjunction with :data:"
"`SO_REUSEPORT`."
msgstr ""

#: ../../library/socket.rst:595
msgid "Functions"
msgstr "関数"

#: ../../library/socket.rst:598
msgid "Creating sockets"
msgstr "ソケットの作成"

#: ../../library/socket.rst:600
msgid ""
"The following functions all create :ref:`socket objects <socket-objects>`."
msgstr "以下の関数は全て :ref:`socket object <socket-objects>` を生成します。"

#: ../../library/socket.rst:605
msgid ""
"Create a new socket using the given address family, socket type and protocol "
"number.  The address family should be :const:`AF_INET` (the default), :const:"
"`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:`AF_PACKET`, or :const:"
"`AF_RDS`. The socket type should be :const:`SOCK_STREAM` (the default), :"
"const:`SOCK_DGRAM`, :const:`SOCK_RAW` or perhaps one of the other ``SOCK_`` "
"constants. The protocol number is usually zero and may be omitted or in the "
"case where the address family is :const:`AF_CAN` the protocol should be one "
"of :const:`CAN_RAW`, :const:`CAN_BCM`, :const:`CAN_ISOTP` or :const:"
"`CAN_J1939`."
msgstr ""
"アドレスファミリー、ソケットタイプ、プロトコル番号を指定してソケットを作成し"
"ます。アドレスファミリーには :const:`AF_INET` (デフォルト値), :const:"
"`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:`AF_PACKET`, :const:"
"`AF_RDS` を指定することができます。ソケットタイプには :const:`SOCK_STREAM` "
"(デフォルト値), :const:`SOCK_DGRAM`, :const:`SOCK_RAW` または他の ``SOCK_`` "
"定数の何れかを指定します。プロトコル番号は通常省略するか、または0を指定します"
"が、アドレスファミリーに :const:`AF_CAN` を指定した場合は、プロトコル番号に"
"は const:`CAN_RAW`, :const:`CAN_BCM`, :const:`CAN_ISOTP`, :const:`CAN_J1939` "
"のいずれかを指定すべきです。"

#: ../../library/socket.rst:615
msgid ""
"If *fileno* is specified, the values for *family*, *type*, and *proto* are "
"auto-detected from the specified file descriptor.  Auto-detection can be "
"overruled by calling the function with explicit *family*, *type*, or *proto* "
"arguments.  This only affects how Python represents e.g. the return value "
"of :meth:`socket.getpeername` but not the actual OS resource.  Unlike :func:"
"`socket.fromfd`, *fileno* will return the same socket and not a duplicate. "
"This may help close a detached socket using :meth:`socket.close()`."
msgstr ""

#: ../../library/socket.rst:624 ../../library/socket.rst:770
#: ../../library/socket.rst:1277 ../../library/socket.rst:1371
msgid "The newly created socket is :ref:`non-inheritable <fd_inheritance>`."
msgstr "新たに作成されたソケットは :ref:`継承不可 <fd_inheritance>`  です。"

#: ../../library/socket.rst:635
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.__new__`` with arguments "
"``self``, ``family``, ``type``, ``protocol``."
msgstr ""
"引数 ``self``, ``family``, ``type``, ``protocol`` 付きで :ref:`監査イベント "
"<auditing>` ``socket.__new__`` を送出します。"

#: ../../library/socket.rst:628
msgid "The AF_CAN family was added. The AF_RDS family was added."
msgstr "AF_CAN, AF_RDS ファミリーが追加されました。"

#: ../../library/socket.rst:632
msgid "The CAN_BCM protocol was added."
msgstr "CAN_BCMプロトコルが追加されました。"

#: ../../library/socket.rst:635 ../../library/socket.rst:772
msgid "The returned socket is now non-inheritable."
msgstr "返されるソケットは継承不可になりました。"

#: ../../library/socket.rst:638
msgid "The CAN_ISOTP protocol was added."
msgstr "CAN_ISOTP プロトコルが追加されました。"

#: ../../library/socket.rst:641
msgid ""
"When :const:`SOCK_NONBLOCK` or :const:`SOCK_CLOEXEC` bit flags are applied "
"to *type* they are cleared, and :attr:`socket.type` will not reflect them.  "
"They are still passed to the underlying system ``socket()`` call.  Therefore,"
msgstr ""

#: ../../library/socket.rst:653
msgid ""
"will still create a non-blocking socket on OSes that support "
"``SOCK_NONBLOCK``, but ``sock.type`` will be set to ``socket.SOCK_STREAM``."
msgstr ""

#: ../../library/socket.rst:657
msgid "The CAN_J1939 protocol was added."
msgstr "CAN_J1939 プロトコルが追加されました。"

#: ../../library/socket.rst:660
msgid "The IPPROTO_MPTCP protocol was added."
msgstr ""

#: ../../library/socket.rst:665
msgid ""
"Build a pair of connected socket objects using the given address family, "
"socket type, and protocol number.  Address family, socket type, and protocol "
"number are as for the :func:`.socket` function above. The default family is :"
"const:`AF_UNIX` if defined on the platform; otherwise, the default is :const:"
"`AF_INET`."
msgstr ""
"指定されたアドレスファミリー、ソケットタイプ、プロトコル番号から、接続された"
"ソケットオブジェクトのペアを作成します。アドレスファミリー、ソケットタイプ、"
"プロトコル番号は :func:`.socket` 関数と同様に指定します。デフォルトのアドレス"
"ファミリは、プラットフォームで定義されている場合 :const:`AF_UNIX` 、そうでな"
"ければ :const:`AF_INET` が使われます。"

#: ../../library/socket.rst:670
msgid "The newly created sockets are :ref:`non-inheritable <fd_inheritance>`."
msgstr "新たに作成されたソケットは :ref:`継承不可 <fd_inheritance>` です。"

#: ../../library/socket.rst:672
msgid ""
"The returned socket objects now support the whole socket API, rather than a "
"subset."
msgstr ""
"返されるソケットオブジェクトが、サブセットではなく完全なソケットAPIを提供する"
"ようになりました。"

#: ../../library/socket.rst:676
msgid "The returned sockets are now non-inheritable."
msgstr "返されるソケットの組は、どちらも継承不可になりました。"

#: ../../library/socket.rst:679
msgid "Windows support added."
msgstr "Windows のサポートが追加されました。"

#: ../../library/socket.rst:685
msgid ""
"Connect to a TCP service listening on the internet *address* (a 2-tuple "
"``(host, port)``), and return the socket object.  This is a higher-level "
"function than :meth:`socket.connect`: if *host* is a non-numeric hostname, "
"it will try to resolve it for both :data:`AF_INET` and :data:`AF_INET6`, and "
"then try to connect to all possible addresses in turn until a connection "
"succeeds.  This makes it easy to write clients that are compatible to both "
"IPv4 and IPv6."
msgstr ""

#: ../../library/socket.rst:693
msgid ""
"Passing the optional *timeout* parameter will set the timeout on the socket "
"instance before attempting to connect.  If no *timeout* is supplied, the "
"global default timeout setting returned by :func:`getdefaulttimeout` is used."
msgstr ""
"オプションの *timeout* 引数を指定すると、接続を試みる前にソケットオブジェクト"
"のタイムアウトを設定します。 *timeout* が指定されない場合、 :func:"
"`getdefaulttimeout` が返すデフォルトのタイムアウト設定値を利用します。"

#: ../../library/socket.rst:698
msgid ""
"If supplied, *source_address* must be a 2-tuple ``(host, port)`` for the "
"socket to bind to as its source address before connecting.  If host or port "
"are '' or 0 respectively the OS default behavior will be used."
msgstr ""
"*source_address* は接続する前にバインドするソースアドレスを指定するオプション"
"引数で、指定する場合は ``(host, port)`` の2要素タプルでなければなりません。 "
"host や port が '' か 0 だった場合は、OSのデフォルトの動作になります。"

#: ../../library/socket.rst:702
msgid ""
"When a connection cannot be created, an exception is raised. By default, it "
"is the exception from the last address in the list. If *all_errors* is "
"``True``, it is an :exc:`ExceptionGroup` containing the errors of all "
"attempts."
msgstr ""

#: ../../library/socket.rst:707
msgid "*source_address* was added."
msgstr "*source_address* が追加されました。"

#: ../../library/socket.rst:710
msgid "*all_errors* was added."
msgstr ""

#: ../../library/socket.rst:716
msgid ""
"Convenience function which creates a TCP socket bound to *address* (a 2-"
"tuple ``(host, port)``) and return the socket object."
msgstr ""

#: ../../library/socket.rst:719
msgid ""
"*family* should be either :data:`AF_INET` or :data:`AF_INET6`. *backlog* is "
"the queue size passed to :meth:`socket.listen`; if not specified , a default "
"reasonable value is chosen. *reuse_port* dictates whether to set the :data:"
"`SO_REUSEPORT` socket option."
msgstr ""

#: ../../library/socket.rst:724
msgid ""
"If *dualstack_ipv6* is true and the platform supports it the socket will be "
"able to accept both IPv4 and IPv6 connections, else it will raise :exc:"
"`ValueError`. Most POSIX platforms and Windows are supposed to support this "
"functionality. When this functionality is enabled the address returned by :"
"meth:`socket.getpeername` when an IPv4 connection occurs will be an IPv6 "
"address represented as an IPv4-mapped IPv6 address. If *dualstack_ipv6* is "
"false it will explicitly disable this functionality on platforms that enable "
"it by default (e.g. Linux). This parameter can be used in conjunction with :"
"func:`has_dualstack_ipv6`:"
msgstr ""

#: ../../library/socket.rst:746
msgid ""
"On POSIX platforms the :data:`SO_REUSEADDR` socket option is set in order to "
"immediately reuse previous sockets which were bound on the same *address* "
"and remained in TIME_WAIT state."
msgstr ""

#: ../../library/socket.rst:754
msgid ""
"Return ``True`` if the platform supports creating a TCP socket which can "
"handle both IPv4 and IPv6 connections."
msgstr ""

#: ../../library/socket.rst:761
msgid ""
"Duplicate the file descriptor *fd* (an integer as returned by a file "
"object's :meth:`fileno` method) and build a socket object from the result.  "
"Address family, socket type and protocol number are as for the :func:`."
"socket` function above. The file descriptor should refer to a socket, but "
"this is not checked --- subsequent operations on the object may fail if the "
"file descriptor is invalid. This function is rarely needed, but can be used "
"to get or set socket options on a socket passed to a program as standard "
"input or output (such as a server started by the Unix inet daemon).  The "
"socket is assumed to be in blocking mode."
msgstr ""
"ファイル記述子 (ファイルオブジェクトの :meth:`fileno` メソッドが返す整数) "
"*fd* を複製して、ソケットオブジェクトを構築します。アドレスファミリとプロトコ"
"ル番号は :func:`.socket` と同様に指定します。ファイル記述子 はソケットを指し"
"ていなければなりませんが、実際にソケットであるかどうかのチェックは行っていま"
"せん。このため、ソケット以外のファイル記述子 を指定するとその後の処理が失敗す"
"る場合があります。この関数が必要な事はあまりありませんが、 (Unixのinetデーモ"
"ンに起動されるプログラムのように) ソケットを標準入力や標準出力として使用する"
"プログラムでソケットオプションの取得や設定を行うために使われます。この関数で"
"使用するソケットは、ブロッキングモードと想定しています。"

#: ../../library/socket.rst:778
msgid ""
"Instantiate a socket from data obtained from the :meth:`socket.share` "
"method.  The socket is assumed to be in blocking mode."
msgstr ""
":meth:`socket.share` メソッドから取得した data からソケットオブジェクトを生成"
"します。ソケットはブロッキングモードだと仮定されます。"

#: ../../library/socket.rst:781 ../../library/socket.rst:1872
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`利用可能な環境 <availability>`: Windows 。"

#: ../../library/socket.rst:788
msgid ""
"This is a Python type object that represents the socket object type. It is "
"the same as ``type(socket(...))``."
msgstr ""
"ソケットオブジェクトの型を示す型オブジェクト。 ``type(socket(...))`` と同じで"
"す。"

#: ../../library/socket.rst:793
msgid "Other functions"
msgstr "その他の関数"

#: ../../library/socket.rst:795
msgid "The :mod:`socket` module also offers various network-related services:"
msgstr ":mod:`socket` モジュールはネットワーク関連のサービスを提供しています:"

#: ../../library/socket.rst:800
msgid ""
"Close a socket file descriptor. This is like :func:`os.close`, but for "
"sockets. On some platforms (most noticeable Windows) :func:`os.close` does "
"not work for socket file descriptors."
msgstr ""

#: ../../library/socket.rst:808
msgid ""
"Translate the *host*/*port* argument into a sequence of 5-tuples that "
"contain all the necessary arguments for creating a socket connected to that "
"service. *host* is a domain name, a string representation of an IPv4/v6 "
"address or ``None``. *port* is a string service name such as ``'http'``, a "
"numeric port number or ``None``.  By passing ``None`` as the value of *host* "
"and *port*, you can pass ``NULL`` to the underlying C API."
msgstr ""
"*host* / *port* 引数の指すアドレス情報を、そのサービスに接続されたソケットを"
"作成するために必要な全ての引数が入った 5 要素のタプルに変換します。 *host* は"
"ドメイン名、IPv4/v6アドレスの文字列、または ``None`` です。 *port* は "
"``'http'`` のようなサービス名文字列、ポート番号を表す数値、または ``None`` で"
"す。 *host* と *port* に ``None`` を指定すると C APIに ``NULL`` を渡せます。"

#: ../../library/socket.rst:815
msgid ""
"The *family*, *type* and *proto* arguments can be optionally specified in "
"order to narrow the list of addresses returned.  Passing zero as a value for "
"each of these arguments selects the full range of results. The *flags* "
"argument can be one or several of the ``AI_*`` constants, and will influence "
"how results are computed and returned. For example, :const:`AI_NUMERICHOST` "
"will disable domain name resolution and will raise an error if *host* is a "
"domain name."
msgstr ""
"オプションの *family*, *type*, *proto* 引数を指定すると、返されるアドレスのリ"
"ストを絞り込むことができます。これらの引数の値として 0 を渡すと絞り込まない結"
"果を返します。 *flags* 引数には ``AI_*`` 定数のうち 1 つ以上が指定でき、結果"
"の取り方を変えることができます。例えば、 :const:`AI_NUMERICHOST` を指定すると"
"ドメイン名解決を行わないようにし、 *host* がドメイン名だった場合には例外を送"
"出します。"

#: ../../library/socket.rst:823
msgid "The function returns a list of 5-tuples with the following structure:"
msgstr "この関数は以下の構造をとる 5 要素のタプルのリストを返します:"

#: ../../library/socket.rst:825
msgid "``(family, type, proto, canonname, sockaddr)``"
msgstr "``(family, type, proto, canonname, sockaddr)``"

#: ../../library/socket.rst:827
msgid ""
"In these tuples, *family*, *type*, *proto* are all integers and are meant to "
"be passed to the :func:`.socket` function.  *canonname* will be a string "
"representing the canonical name of the *host* if :const:`AI_CANONNAME` is "
"part of the *flags* argument; else *canonname* will be empty.  *sockaddr* is "
"a tuple describing a socket address, whose format depends on the returned "
"*family* (a ``(address, port)`` 2-tuple for :const:`AF_INET`, a ``(address, "
"port, flowinfo, scope_id)`` 4-tuple for :const:`AF_INET6`), and is meant to "
"be passed to the :meth:`socket.connect` method."
msgstr ""
"このタプルにある *family*, *type*, *proto* は、 :func:`.socket` 関数を呼び出"
"す際に指定する値と同じ整数です。 :const:`AI_CANONNAME` を含んだ *flags* を指"
"定した場合、 *canonname* は *host* の canonical name を示す文字列です。そうで"
"ない場合は *canonname* は空文字列です。 *sockaddr* は、ソケットアドレスを "
"*family* に依存した形式で表すタプルで、 (:const:`AF_INET` の場合は 2 要素のタ"
"プル ``(address, port)`` 、 :const:`AF_INET6` の場合は 4 要素のタプル "
"``(address, port, flowinfo, scope_id)``) :meth:`socket.connect` メソッドに渡"
"すためのものです。"

#: ../../library/socket.rst:846
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getaddrinfo`` with "
"arguments ``host``, ``port``, ``family``, ``type``, ``protocol``."
msgstr ""
"引数 ``host``, ``port``, ``family``, ``type``, ``protocol`` 付きで :ref:`監査"
"イベント <auditing>` ``socket.getaddrinfo`` を送出します。"

#: ../../library/socket.rst:839
msgid ""
"The following example fetches address information for a hypothetical TCP "
"connection to ``example.org`` on port 80 (results may differ on your system "
"if IPv6 isn't enabled)::"
msgstr ""
"次の例では ``example.org`` の 80 番ポートポートへの TCP 接続を得るためのアド"
"レス情報を取得しようとしています。 (結果は IPv6 をサポートしているかどうかで"
"変わります)::"

#: ../../library/socket.rst:849
msgid "parameters can now be passed using keyword arguments."
msgstr "パラメータをキーワード引数で渡すことができるようになりました。"

#: ../../library/socket.rst:852
msgid ""
"for IPv6 multicast addresses, string representing an address will not "
"contain ``%scope_id`` part."
msgstr ""

#: ../../library/socket.rst:858
msgid ""
"Return a fully qualified domain name for *name*. If *name* is omitted or "
"empty, it is interpreted as the local host.  To find the fully qualified "
"name, the hostname returned by :func:`gethostbyaddr` is checked, followed by "
"aliases for the host, if available.  The first name which includes a period "
"is selected.  In case no fully qualified domain name is available and *name* "
"was provided, it is returned unchanged.  If *name* was empty or equal to "
"``'0.0.0.0'``, the hostname from :func:`gethostname` is returned."
msgstr ""

#: ../../library/socket.rst:869
msgid ""
"Translate a host name to IPv4 address format.  The IPv4 address is returned "
"as a string, such as  ``'100.50.200.5'``.  If the host name is an IPv4 "
"address itself it is returned unchanged.  See :func:`gethostbyname_ex` for a "
"more complete interface. :func:`gethostbyname` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"ホスト名を ``'100.50.200.5'`` のようなIPv4形式のアドレスに変換します。ホスト"
"名としてIPv4アドレスを指定した場合、その値は変換せずにそのまま返ります。 :"
"func:`gethostbyname` APIへのより完全なインターフェイスが必要であれば、 :func:"
"`gethostbyname_ex` を参照してください。 :func:`gethostbyname` は、IPv6名前解"
"決をサポートしていません。IPv4/ v6のデュアルスタックをサポートする場合は :"
"func:`getaddrinfo` を使用します。"

#: ../../library/socket.rst:884 ../../library/socket.rst:900
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyname`` with "
"argument ``hostname``."
msgstr ""
"引数 ``hostname`` を指定して :ref:`監査イベント <auditing>` ``socket."
"gethostbyname`` を送出します。 "

#: ../../library/socket.rst:877 ../../library/socket.rst:893
#: ../../library/socket.rst:906 ../../library/socket.rst:921
#: ../../library/socket.rst:938 ../../library/socket.rst:949
#: ../../library/socket.rst:960 ../../library/socket.rst:971
#: ../../library/socket.rst:1295 ../../library/socket.rst:1342
#: ../../library/socket.rst:1356 ../../library/socket.rst:1376
#: ../../library/socket.rst:1423 ../../library/socket.rst:1468
#: ../../library/socket.rst:1850 ../../library/socket.rst:1860
msgid ":ref:`Availability <availability>`: not WASI."
msgstr ""

#: ../../library/socket.rst:882
msgid ""
"Translate a host name to IPv4 address format, extended interface. Return a "
"triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the host's "
"primary host name, *aliaslist* is a (possibly empty) list of alternative "
"host names for the same address, and *ipaddrlist* is a list of IPv4 "
"addresses for the same interface on the same host (often but not always a "
"single address). :func:`gethostbyname_ex` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""

#: ../../library/socket.rst:898
msgid ""
"Return a string containing the hostname of the machine where  the Python "
"interpreter is currently executing."
msgstr ""
"Pythonインタープリタを現在実行しているマシンのホスト名を含む文字列を返しま"
"す。"

#: ../../library/socket.rst:910
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostname`` with no "
"arguments."
msgstr ""
"引数無しで :ref:`監査イベント <auditing>` ``socket.gethostname`` を送出しま"
"す。 "

#: ../../library/socket.rst:903
msgid ""
"Note: :func:`gethostname` doesn't always return the fully qualified domain "
"name; use :func:`getfqdn` for that."
msgstr ""
"注意: :func:`gethostname` は完全修飾ドメイン名を返すとは限りません。完全修飾"
"ドメイン名が必要であれば、:func:`getfqdn` を使用してください。"

#: ../../library/socket.rst:911
msgid ""
"Return a triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is "
"the primary host name responding to the given *ip_address*, *aliaslist* is a "
"(possibly empty) list of alternative host names for the same address, and "
"*ipaddrlist* is a list of IPv4/v6 addresses for the same interface on the "
"same host (most likely containing only a single address). To find the fully "
"qualified domain name, use the function :func:`getfqdn`. :func:"
"`gethostbyaddr` supports both IPv4 and IPv6."
msgstr ""
"``(hostname, aliaslist, ipaddrlist)`` のタプルを返し、 *hostname* は "
"*ip_address* で指定したホストの正式名、 *aliaslist* は同じアドレスの別名のリ"
"スト(空の場合もある)、 *ipaddrlist* は同じホスト上の同一インターフェイスの"
"IPv4アドレスのリスト(ほとんどの場合は単一のアドレスのみ)を示します。完全修飾"
"ドメイン名が必要であれば、 :func:`getfqdn` を使用してください。 :func:"
"`gethostbyaddr` は、IPv4/IPv6の両方をサポートしています。"

#: ../../library/socket.rst:928
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyaddr`` with "
"argument ``ip_address``."
msgstr ""
"引数 ``ip_address`` を指定して :ref:`監査イベント <auditing>` ``socket."
"gethostbyaddr`` を送出します。 "

#: ../../library/socket.rst:926
msgid ""
"Translate a socket address *sockaddr* into a 2-tuple ``(host, port)``. "
"Depending on the settings of *flags*, the result can contain a fully "
"qualified domain name or numeric address representation in *host*.  "
"Similarly, *port* can contain a string port name or a numeric port number."
msgstr ""

#: ../../library/socket.rst:931
msgid ""
"For IPv6 addresses, ``%scope_id`` is appended to the host part if *sockaddr* "
"contains meaningful *scope_id*. Usually this happens for multicast addresses."
msgstr ""

#: ../../library/socket.rst:934
msgid ""
"For more information about *flags* you can consult :manpage:`getnameinfo(3)`."
msgstr ""

#: ../../library/socket.rst:945
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getnameinfo`` with "
"argument ``sockaddr``."
msgstr ""
"引数 ``sockaddr`` を指定して :ref:`監査イベント <auditing>` ``socket."
"getnameinfo`` を送出します。 "

#: ../../library/socket.rst:943
msgid ""
"Translate an internet protocol name (for example, ``'icmp'``) to a constant "
"suitable for passing as the (optional) third argument to the :func:`.socket` "
"function.  This is usually only needed for sockets opened in \"raw\" mode (:"
"const:`SOCK_RAW`); for the normal socket modes, the correct protocol is "
"chosen automatically if the protocol is omitted or zero."
msgstr ""

#: ../../library/socket.rst:954
msgid ""
"Translate an internet service name and protocol name to a port number for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""

#: ../../library/socket.rst:967
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyname`` with "
"arguments ``servicename``, ``protocolname``."
msgstr ""
"引数 ``servicename``, ``protocolname`` を指定して :ref:`監査イベント "
"<auditing>` ``socket.getservbyname`` を送出します。 "

#: ../../library/socket.rst:965
msgid ""
"Translate an internet port number and protocol name to a service name for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""

#: ../../library/socket.rst:978
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyport`` with "
"arguments ``port``, ``protocolname``."
msgstr ""
"引数 ``port``, ``protocolname`` を指定して :ref:`監査イベント <auditing>` "
"``socket.getservbyport`` を送出します。 "

#: ../../library/socket.rst:976
msgid ""
"Convert 32-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"32ビットの正の整数のバイトオーダを、ネットワークバイトオーダからホストバイト"
"オーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致するマ"
"シンでは、この関数は何もしません。それ以外の場合は4バイトのスワップを行いま"
"す。"

#: ../../library/socket.rst:983
msgid ""
"Convert 16-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"16ビットの正の整数のバイトオーダを、ネットワークバイトオーダからホストバイト"
"オーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致するマ"
"シンでは、この関数は何もしません。それ以外の場合は2バイトのスワップを行いま"
"す。"

#: ../../library/socket.rst:987 ../../library/socket.rst:1005
msgid ""
"Raises :exc:`OverflowError` if *x* does not fit in a 16-bit unsigned integer."
msgstr ""

#: ../../library/socket.rst:994
msgid ""
"Convert 32-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"32ビットの正の整数のバイトオーダを、ホストバイトオーダからネットワークバイト"
"オーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致するマ"
"シンでは、この関数は何もしません。それ以外の場合は4バイトのスワップを行いま"
"す。"

#: ../../library/socket.rst:1001
msgid ""
"Convert 16-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"16ビットの正の整数のバイトオーダを、ホストバイトオーダからネットワークバイト"
"オーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致するマ"
"シンでは、この関数は何もしません。それ以外の場合は2バイトのスワップを行いま"
"す。"

#: ../../library/socket.rst:1012
msgid ""
"Convert an IPv4 address from dotted-quad string format (for example, "
"'123.45.67.89') to 32-bit packed binary format, as a bytes object four "
"characters in length.  This is useful when conversing with a program that "
"uses the standard C library and needs objects of type :c:struct:`in_addr`, "
"which is the C type for the 32-bit packed binary this function returns."
msgstr ""

#: ../../library/socket.rst:1018
msgid ""
":func:`inet_aton` also accepts strings with less than three dots; see the "
"Unix manual page :manpage:`inet(3)` for details."
msgstr ""
":func:`inet_aton` はドットが 3 個以下の文字列も受け取ります; 詳細については "
"Unix のマニュアル :manpage:`inet(3)` を参照してください。"

#: ../../library/socket.rst:1021
msgid ""
"If the IPv4 address string passed to this function is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on the "
"underlying C implementation of :c:func:`inet_aton`."
msgstr ""
"IPv4アドレス文字列が不正であれば、 :exc:`OSError` が発生します。このチェック"
"は、この関数で使用しているCの実装 :c:func:`inet_aton` で行われます。"

#: ../../library/socket.rst:1025
msgid ""
":func:`inet_aton` does not support IPv6, and :func:`inet_pton` should be "
"used instead for IPv4/v6 dual stack support."
msgstr ""
":func:`inet_aton` は、IPv6をサポートしません。IPv4/v6のデュアルスタックをサ"
"ポートする場合は :func:`inet_pton` を使用します。"

#: ../../library/socket.rst:1031
msgid ""
"Convert a 32-bit packed IPv4 address (a :term:`bytes-like object` four bytes "
"in length) to its standard dotted-quad string representation (for example, "
"'123.45.67.89').  This is useful when conversing with a program that uses "
"the standard C library and needs objects of type :c:struct:`in_addr`, which "
"is the C type for the 32-bit packed binary data this function takes as an "
"argument."
msgstr ""

#: ../../library/socket.rst:1038
msgid ""
"If the byte sequence passed to this function is not exactly 4 bytes in "
"length, :exc:`OSError` will be raised. :func:`inet_ntoa` does not support "
"IPv6, and :func:`inet_ntop` should be used instead for IPv4/v6 dual stack "
"support."
msgstr ""
"この関数に渡すバイトシーケンスの長さが4バイト以外であれば、 :exc:`OSError` が"
"発生します。 :func:`inet_ntoa` は、IPv6をサポートしません。IPv4/v6のデュアル"
"スタックをサポートする場合は :func:`inet_ntop` を使用します。"

#: ../../library/socket.rst:1049
msgid ""
"Convert an IP address from its family-specific string format to a packed, "
"binary format. :func:`inet_pton` is useful when a library or network "
"protocol calls for an object of type :c:struct:`in_addr` (similar to :func:"
"`inet_aton`) or :c:struct:`in6_addr`."
msgstr ""

#: ../../library/socket.rst:1054
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the IP address string *ip_string* is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on both "
"the value of *address_family* and the underlying implementation of :c:func:"
"`inet_pton`."
msgstr ""
"現在サポートされている *address_family* は、 :const:`AF_INET` と :const:"
"`AF_INET6` です。 *ip_string* に不正なIPアドレス文字列を指定すると、 :exc:"
"`OSError` が発生します。有効な *ip_string* は、 *address_family* と :c:func:"
"`inet_pton` の実装によって異なります。"

#: ../../library/socket.rst:1060 ../../library/socket.rst:1080
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Availability <availability>`: Unix, Windows。"

#: ../../library/socket.rst:1062 ../../library/socket.rst:1082
msgid "Windows support added"
msgstr "Windowsで利用可能になりました"

#: ../../library/socket.rst:1068
msgid ""
"Convert a packed IP address (a :term:`bytes-like object` of some number of "
"bytes) to its standard, family-specific string representation (for example, "
"``'7.10.0.5'`` or ``'5aef:2b::8'``). :func:`inet_ntop` is useful when a "
"library or network protocol returns an object of type :c:struct:`in_addr` "
"(similar to :func:`inet_ntoa`) or :c:struct:`in6_addr`."
msgstr ""

#: ../../library/socket.rst:1075
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the bytes object *packed_ip* is not the correct length "
"for the specified address family, :exc:`ValueError` will be raised. :exc:"
"`OSError` is raised for errors from the call to :func:`inet_ntop`."
msgstr ""
"現在サポートされている *address_family* の値は、 :const:`AF_INET` と :const:"
"`AF_INET6` です。バイトオブジェクトの *packed_ip* の長さが、指定したアドレス"
"ファミリで適切な長さでない場合、 :exc:`ValueError` が発生します。 :func:"
"`inet_ntop` の呼び出しでエラーが起こると、 :exc:`OSError` が発生します。"

#: ../../library/socket.rst:1097
msgid ""
"Return the total length, without trailing padding, of an ancillary data item "
"with associated data of the given *length*.  This value can often be used as "
"the buffer size for :meth:`~socket.recvmsg` to receive a single item of "
"ancillary data, but :rfc:`3542` requires portable applications to use :func:"
"`CMSG_SPACE` and thus include space for padding, even when the item will be "
"the last in the buffer.  Raises :exc:`OverflowError` if *length* is outside "
"the permissible range of values."
msgstr ""
"指定された *length* にある制御メッセージ（CMSG）から、末尾のパディングを除い"
"た全体の長さを返します。この値は多くの場合、 :meth:`~socket.recvmsg` が制御"
"メッセージの一連の要素を受信するためのバッファサイズとして使用できますが、"
"バッファの末尾が要素である場合であってもパディングは含まれるので、バッファサ"
"イズを取得するには :rfc:`3542` で求められているように、 :func:`CMSG_SPACE` を"
"使用した移植可能なアプリケーションが必要です。通常 *length* は定数であり、許"
"容範囲外の値が指定された場合は :exc:`OverflowError` 例外が送出されます。"

#: ../../library/socket.rst:1106 ../../library/socket.rst:1129
msgid ":ref:`Availability <availability>`: Unix, not Emscripten, not WASI."
msgstr ""

#: ../../library/socket.rst:1108 ../../library/socket.rst:1598
#: ../../library/socket.rst:1642 ../../library/socket.rst:1750
msgid "Most Unix platforms."
msgstr ""

#: ../../library/socket.rst:1115
msgid ""
"Return the buffer size needed for :meth:`~socket.recvmsg` to receive an "
"ancillary data item with associated data of the given *length*, along with "
"any trailing padding.  The buffer space needed to receive multiple items is "
"the sum of the :func:`CMSG_SPACE` values for their associated data lengths.  "
"Raises :exc:`OverflowError` if *length* is outside the permissible range of "
"values."
msgstr ""
"指定された *length* の制御メッセージ（CMSG）の要素を :meth:`~socket.recvmsg` "
"が受信するために必要な、パディングを含めたバッファサイズを返します。複数の項"
"目を受信するために必要なバッファスペースは、 :func:`CMSG_SPACE` が返すそれぞ"
"れの要素の長さの合計です。通常 *length* は定数であり、許容範囲外の値が指定さ"
"れた場合は :exc:`OverflowError` 例外が送出されます。"

#: ../../library/socket.rst:1123
msgid ""
"Note that some systems might support ancillary data without providing this "
"function.  Also note that setting the buffer size using the results of this "
"function may not precisely limit the amount of ancillary data that can be "
"received, since additional data may be able to fit into the padding area."
msgstr ""
"一部のシステムではこの関数を提供せずに制御メッセージをサポートする可能性があ"
"ることに注意してください。また、この関数の返り値を使用して設定するバッファサ"
"イズは、受信する制御メッセージの量を正確に規定しないことがあり、その後に受信"
"するデータがパディング領域に合う場合があることに注意してください。"

#: ../../library/socket.rst:1131
msgid "most Unix platforms."
msgstr ""

#: ../../library/socket.rst:1138
msgid ""
"Return the default timeout in seconds (float) for new socket objects. A "
"value of ``None`` indicates that new socket objects have no timeout. When "
"the socket module is first imported, the default is ``None``."
msgstr ""
"新規に生成されたソケットオブジェクトの、デフォルトのタイムアウト値を浮動小数"
"点形式の秒数で返します。タイムアウトを使用しない場合には ``None`` を返しま"
"す。最初に socket モジュールがインポートされた時の初期値は ``None`` です。"

#: ../../library/socket.rst:1145
msgid ""
"Set the default timeout in seconds (float) for new socket objects.  When the "
"socket module is first imported, the default is ``None``.  See :meth:"
"`~socket.settimeout` for possible values and their respective meanings."
msgstr ""
"新規に生成されるソケットオブジェクトの、デフォルトのタイムアウト値を秒数 "
"(float 型) で設定します。最初に socket モジュールがインポートされた時の初期値"
"は ``None`` です。指定可能な値とその意味については :meth:`~socket."
"settimeout` メソッドを参照してください。"

#: ../../library/socket.rst:1153
msgid ""
"Set the machine's hostname to *name*.  This will raise an :exc:`OSError` if "
"you don't have enough rights."
msgstr ""
"マシンのホスト名を *name* に設定します。必要な権限がない場合は :exc:"
"`OSError` を送出します。"

#: ../../library/socket.rst:1165
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sethostname`` with "
"argument ``name``."
msgstr ""
"引数 ``name`` を指定して :ref:`監査イベント <auditing>` ``socket."
"sethostname`` を送出します。"

#: ../../library/socket.rst:1158 ../../library/socket.rst:1596
#: ../../library/socket.rst:1640
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`利用可能な環境 <availability>`: Unix。"

#: ../../library/socket.rst:1165
msgid ""
"Return a list of network interface information (index int, name string) "
"tuples. :exc:`OSError` if the system call fails."
msgstr ""
"ネットワークインターフェース情報 (index int, name string)のタプルを返します。"
"システムコールが失敗した場合、 :exc:`OSError` 例外を送出します。"

#: ../../library/socket.rst:1169 ../../library/socket.rst:1196
#: ../../library/socket.rst:1213 ../../library/socket.rst:1230
#: ../../library/socket.rst:1244
msgid ""
":ref:`Availability <availability>`: Unix, Windows, not Emscripten, not WASI."
msgstr ""

#: ../../library/socket.rst:1173 ../../library/socket.rst:1200
#: ../../library/socket.rst:1217
msgid "Windows support was added."
msgstr "Windows のサポートが追加されました。"

#: ../../library/socket.rst:1178
msgid ""
"On Windows network interfaces have different names in different contexts "
"(all names are examples):"
msgstr ""

#: ../../library/socket.rst:1181
msgid "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"
msgstr "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"

#: ../../library/socket.rst:1182
msgid "name: ``ethernet_32770``"
msgstr ""

#: ../../library/socket.rst:1183
msgid "friendly name: ``vEthernet (nat)``"
msgstr ""

#: ../../library/socket.rst:1184
msgid "description: ``Hyper-V Virtual Ethernet Adapter``"
msgstr ""

#: ../../library/socket.rst:1186
msgid ""
"This function returns names of the second form from the list, "
"``ethernet_32770`` in this example case."
msgstr ""

#: ../../library/socket.rst:1192
msgid ""
"Return a network interface index number corresponding to an interface name. :"
"exc:`OSError` if no interface with the given name exists."
msgstr ""
"インターフェース名 *if_name* に対応するネットワークインターフェースのインデッ"
"クス番号を返します。対応するインターフェースが存在しない場合は :exc:"
"`OSError` 例外を送出します。"

#: ../../library/socket.rst:1204 ../../library/socket.rst:1221
msgid "\"Interface name\" is a name as documented in :func:`if_nameindex`."
msgstr ""

#: ../../library/socket.rst:1209
msgid ""
"Return a network interface name corresponding to an interface index number. :"
"exc:`OSError` if no interface with the given index exists."
msgstr ""
"インターフェースインデックス番号 *if_index* に対応するネットワークインター"
"フェース名を返します。対応するインターフェースが存在しない場合は :exc:"
"`OSError` 例外を送出します。"

#: ../../library/socket.rst:1226
msgid ""
"Send the list of file descriptors *fds* over an :const:`AF_UNIX` socket "
"*sock*. The *fds* parameter is a sequence of file descriptors. Consult :meth:"
"`sendmsg` for the documentation of these parameters."
msgstr ""

#: ../../library/socket.rst:1232 ../../library/socket.rst:1246
msgid ""
"Unix platforms supporting :meth:`~socket.sendmsg` and :const:`SCM_RIGHTS` "
"mechanism."
msgstr ""

#: ../../library/socket.rst:1240
msgid ""
"Receive up to *maxfds* file descriptors from an :const:`AF_UNIX` socket "
"*sock*. Return ``(msg, list(fds), flags, addr)``. Consult :meth:`recvmsg` "
"for the documentation of these parameters."
msgstr ""

#: ../../library/socket.rst:1253
msgid "Any truncated integers at the end of the list of file descriptors."
msgstr ""

#: ../../library/socket.rst:1259
msgid "Socket Objects"
msgstr "socket オブジェクト"

#: ../../library/socket.rst:1261
msgid ""
"Socket objects have the following methods.  Except for :meth:`~socket."
"makefile`, these correspond to Unix system calls applicable to sockets."
msgstr ""
"ソケットオブジェクトは以下のメソッドを持ちます。 :meth:`~socket.makefile` 以"
"外のメソッドは、Unixのソケット用システムコールに対応しています。"

#: ../../library/socket.rst:1265
msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`~socket.close`."
msgstr ""
":term:`context manager` プロトコルのサポートが追加されました。コンテキストマ"
"ネージャを終了することは、 :meth:`~socket.close` を呼ぶことと同一です。"

#: ../../library/socket.rst:1272
msgid ""
"Accept a connection. The socket must be bound to an address and listening "
"for connections. The return value is a pair ``(conn, address)`` where *conn* "
"is a *new* socket object usable to send and receive data on the connection, "
"and *address* is the address bound to the socket on the other end of the "
"connection."
msgstr ""
"接続を受け付けます。ソケットはアドレスにbind済みで、listen中である必要があり"
"ます。戻り値は ``(conn, address)`` のペアで、 *conn* は接続を通じてデータの送"
"受信を行うための *新しい* ソケットオブジェクト、 *address* は接続先でソケット"
"にbindしているアドレスを示します。"

#: ../../library/socket.rst:1279 ../../library/socket.rst:1373
msgid "The socket is now non-inheritable."
msgstr "ソケットが :ref:`継承不可 <fd_inheritance>` になりました。"

#: ../../library/socket.rst:1282 ../../library/socket.rst:1511
#: ../../library/socket.rst:1525 ../../library/socket.rst:1602
#: ../../library/socket.rst:1675 ../../library/socket.rst:1694
#: ../../library/socket.rst:1711 ../../library/socket.rst:1756
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the method now retries the system call instead of raising an :exc:"
"`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"システムコールが中断されシグナルハンドラが例外を送出しなかった場合、このメ"
"ソッドは :exc:`InterruptedError` 例外を送出する代わりにシステムコールを再試行"
"するようになりました (論拠については :pep:`475` を参照してください)。"

#: ../../library/socket.rst:1290
msgid ""
"Bind the socket to *address*.  The socket must not already be bound. (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"ソケットを *address* にbindします。bind済みのソケットを再バインドする事はでき"
"ません。(*address* のフォーマットはアドレスファミリによって異なります -- 前"
"述。)"

#: ../../library/socket.rst:1302
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.bind`` with arguments "
"``self``, ``address``."
msgstr ""
"引数 ``self``, ``address`` を指定して :ref:`監査イベント <auditing>` "
"``socket.bind`` を送出します。 "

#: ../../library/socket.rst:1300
msgid ""
"Mark the socket closed.  The underlying system resource (e.g. a file "
"descriptor) is also closed when all file objects from :meth:`makefile()` are "
"closed.  Once that happens, all future operations on the socket object will "
"fail. The remote end will receive no more data (after queued data is "
"flushed)."
msgstr ""
"ソケットを閉じられたものとしてマークします。 :meth:`makefile()` が返したファ"
"イルオブジェクトを閉じる時、対応する下層のシステムリソース（例：ファイル記述"
"子）もすべて閉じます。一度この操作をすると、その後、このソケットオブジェクト"
"に対するすべての操作が失敗します。キューに溜まったデータがフラッシュされた後"
"は、リモート側の端点ではそれ以上のデータを受信しません。"

#: ../../library/socket.rst:1306
msgid ""
"Sockets are automatically closed when they are garbage-collected, but it is "
"recommended to :meth:`close` them explicitly, or to use a :keyword:`with` "
"statement around them."
msgstr ""
"ソケットはガベージコレクション時に自動的にクローズされます。しかし、明示的"
"に :meth:`close` するか、 :keyword:`with` 文の中でソケットを使うことを推奨し"
"ます。"

#: ../../library/socket.rst:1310
msgid ""
":exc:`OSError` is now raised if an error occurs when the underlying :c:func:"
"`close` call is made."
msgstr ""
"下層の :c:func:`close` が呼び出される時、:exc:`OSError` が送出されるようにな"
"りました。"

#: ../../library/socket.rst:1316
msgid ""
":meth:`close()` releases the resource associated with a connection but does "
"not necessarily close the connection immediately.  If you want to close the "
"connection in a timely fashion, call :meth:`shutdown()` before :meth:"
"`close()`."
msgstr ""
":meth:`close()` は接続に関連付けられたリソースを解放しますが、接続をすぐに切"
"断するとは限りません。接続を即座に切断したい場合は、 :meth:`close()` の前に :"
"meth:`shutdown()` を呼び出してください。"

#: ../../library/socket.rst:1324
msgid ""
"Connect to a remote socket at *address*. (The format of *address* depends on "
"the address family --- see above.)"
msgstr ""
"*address* で示されるリモートソケットに接続します。(*address* のフォーマットは"
"アドレスファミリによって異なります --- 前述。)"

#: ../../library/socket.rst:1327
msgid ""
"If the connection is interrupted by a signal, the method waits until the "
"connection completes, or raise a :exc:`TimeoutError` on timeout, if the "
"signal handler doesn't raise an exception and the socket is blocking or has "
"a timeout. For non-blocking sockets, the method raises an :exc:"
"`InterruptedError` exception if the connection is interrupted by a signal "
"(or the exception raised by the signal handler)."
msgstr ""

#: ../../library/socket.rst:1343 ../../library/socket.rst:1363
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.connect`` with arguments "
"``self``, ``address``."
msgstr ""
"引数 ``self``, ``address`` を指定して :ref:`監査イベント <auditing>` "
"``socket.connect`` を送出します。 "

#: ../../library/socket.rst:1336
msgid ""
"The method now waits until the connection completes instead of raising an :"
"exc:`InterruptedError` exception if the connection is interrupted by a "
"signal, the signal handler doesn't raise an exception and the socket is "
"blocking or has a timeout (see the :pep:`475` for the rationale)."
msgstr ""
"このメソッドは、接続が信号によって中断され、信号ハンドラが例外を送出せず、ソ"
"ケットがブロックであるかタイムアウトが設定されている場合、:exc:"
"`InterruptedError` 例外を送出する代わりに、接続を完了するまで待機するようにな"
"りました (論拠については :pep:`475`  を参照してください)。"

#: ../../library/socket.rst:1347
msgid ""
"Like ``connect(address)``, but return an error indicator instead of raising "
"an exception for errors returned by the C-level :c:func:`connect` call "
"(other problems, such as \"host not found,\" can still raise exceptions).  "
"The error indicator is ``0`` if the operation succeeded, otherwise the value "
"of the :c:data:`errno` variable.  This is useful to support, for example, "
"asynchronous connects."
msgstr ""
"``connect(address)`` と同様ですが、C言語の :c:func:`connect` 関数の呼び出しで"
"エラーが発生した場合には例外を送出せずにエラーを戻り値として返します。(これ以"
"外の、\"host not found,\"等のエラーの場合には例外が発生します。)処理が正常に"
"終了した場合には ``0`` を返し、エラー時には :c:data:`errno` の値を返します。"
"この関数は、非同期接続をサポートする場合などに使用することができます。"

#: ../../library/socket.rst:1360
msgid ""
"Put the socket object into closed state without actually closing the "
"underlying file descriptor.  The file descriptor is returned, and can be "
"reused for other purposes."
msgstr ""
"実際にファイル記述子を閉じることなく、ソケットオブジェクトを閉じた状態にしま"
"す。ファイル記述子は返却され、他の目的に再利用することができます。"

#: ../../library/socket.rst:1369
msgid "Duplicate the socket."
msgstr "ソケットを複製します。"

#: ../../library/socket.rst:1381
msgid ""
"Return the socket's file descriptor (a small integer), or -1 on failure. "
"This is useful with :func:`select.select`."
msgstr ""
"ソケットのファイル記述子を短い整数型で返します。失敗時には、-1 を返します。"
"ファイル記述子は、 :func:`select.select` などで使用します。"

#: ../../library/socket.rst:1384
msgid ""
"Under Windows the small integer returned by this method cannot be used where "
"a file descriptor can be used (such as :func:`os.fdopen`).  Unix does not "
"have this limitation."
msgstr ""
"Windowsではこのメソッドで返された小整数をファイル記述子を扱う箇所 (:func:`os."
"fdopen` など) で利用できません。 Unix にはこの制限はありません。"

#: ../../library/socket.rst:1390
msgid ""
"Get the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle: ``True`` if the socket can be inherited in "
"child processes, ``False`` if it cannot."
msgstr ""
"ソケットのファイル記述子またはソケットのハンドルの :ref:`継承可能フラグ "
"<fd_inheritance>` を取得します。ソケットが子プロセスへ継承可能なら "
"``True`` 、継承不可なら ``False`` を返します。"

#: ../../library/socket.rst:1399
msgid ""
"Return the remote address to which the socket is connected.  This is useful "
"to find out the port number of a remote IPv4/v6 socket, for instance. (The "
"format of the address returned depends on the address family --- see "
"above.)  On some systems this function is not supported."
msgstr ""
"ソケットが接続しているリモートアドレスを返します。この関数は、リモート IPv4/"
"v6ソケットのポート番号を調べる場合などに使用します。 *address* のフォーマット"
"はアドレスファミリによって異なります(前述)。この関数をサポートしていないシス"
"テムも存在します。"

#: ../../library/socket.rst:1407
msgid ""
"Return the socket's own address.  This is useful to find out the port number "
"of an IPv4/v6 socket, for instance. (The format of the address returned "
"depends on the address family --- see above.)"
msgstr ""
"ソケット自身のアドレスを返します。この関数は、IPv4/v6ソケットのポート番号を調"
"べる場合などに使用します。(*address* のフォーマットはアドレスファミリによって"
"異なります --- 前述。)"

#: ../../library/socket.rst:1414
msgid ""
"Return the value of the given socket option (see the Unix man page :manpage:"
"`getsockopt(2)`).  The needed symbolic constants (:const:`SO_\\*` etc.) are "
"defined in this module.  If *buflen* is absent, an integer option is assumed "
"and its integer value is returned by the function.  If *buflen* is present, "
"it specifies the maximum length of the buffer used to receive the option in, "
"and this buffer is returned as a bytes object.  It is up to the caller to "
"decode the contents of the buffer (see the optional built-in module :mod:"
"`struct` for a way to decode C structures encoded as byte strings)."
msgstr ""
"ソケットに指定されたオプションを返します(Unixのマニュアルページ :manpage:"
"`getsockopt(2)` を参照)。 :const:`SO_\\*` 等のシンボルは、このモジュールで定"
"義しています。 *buflen* を省略した場合、取得するオブションは整数とみなし、整"
"数型の値を戻り値とします。 *buflen* を指定した場合、長さ *buflen* のバッファ"
"でオプションを受け取り、このバッファをバイト列オブジェクトとして返します。こ"
"のバッファは、呼び出し元プログラムで :mod:`struct` モジュール等を利用して内容"
"を読み取ることができます。"

#: ../../library/socket.rst:1428
msgid ""
"Return ``True`` if socket is in blocking mode, ``False`` if in non-blocking."
msgstr ""

#: ../../library/socket.rst:1431
msgid "This is equivalent to checking ``socket.gettimeout() == 0``."
msgstr ""

#: ../../library/socket.rst:1438
msgid ""
"Return the timeout in seconds (float) associated with socket operations, or "
"``None`` if no timeout is set.  This reflects the last call to :meth:"
"`setblocking` or :meth:`settimeout`."
msgstr ""
"ソケットに指定されたタイムアウト値を取得します。タイムアウト値が設定されてい"
"る場合には浮動小数点型で秒数が、設定されていなければ ``None`` が返ります。こ"
"の値は、最後に呼び出された :meth:`setblocking` または :meth:`settimeout` に"
"よって設定されます。"

#: ../../library/socket.rst:0
msgid "platform"
msgstr "プラットフォーム"

#: ../../library/socket.rst:1445
msgid "Windows"
msgstr "Windows"

#: ../../library/socket.rst:1447
msgid ""
"The :meth:`ioctl` method is a limited interface to the WSAIoctl system "
"interface.  Please refer to the `Win32 documentation <https://msdn.microsoft."
"com/en-us/library/ms741621%28VS.85%29.aspx>`_ for more information."
msgstr ""
":meth:`ioctl` メソッドは WSAIoctl システムインターフェースへの制限されたイン"
"ターフェースです。詳しい情報については、 `Win32 documentation <https://msdn."
"microsoft.com/en-us/library/ms741621%28VS.85%29.aspx>`_ を参照してください。"

#: ../../library/socket.rst:1452
msgid ""
"On other platforms, the generic :func:`fcntl.fcntl` and :func:`fcntl.ioctl` "
"functions may be used; they accept a socket object as their first argument."
msgstr ""
"他のプラットフォームでは一般的な :func:`fcntl.fcntl` と :func:`fcntl.ioctl` "
"が使われるでしょう; これらの関数は第 1 引数としてソケットオブジェクトを取りま"
"す。"

#: ../../library/socket.rst:1455
msgid ""
"Currently only the following control codes are supported: ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS``, and ``SIO_LOOPBACK_FAST_PATH``."
msgstr ""
"現在、以下のコントロールコードのみがサポートされています。 ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS``, ``SIO_LOOPBACK_FAST_PATH``。"

#: ../../library/socket.rst:1463
msgid ""
"Enable a server to accept connections.  If *backlog* is specified, it must "
"be at least 0 (if it is lower, it is set to 0); it specifies the number of "
"unaccepted connections that the system will allow before refusing new "
"connections. If not specified, a default reasonable value is chosen."
msgstr ""
"サーバーを有効にして、接続を受け付けるようにします。*backlog* が指定されてい"
"る場合、少なくとも 0 以上でなければなりません (それより低い場合、0 に設定され"
"ます)。システムが新しい接続を拒否するまでに許可する未受付の接続の数を指定しま"
"す。指定しない場合、デフォルトの妥当な値が選択されます。"

#: ../../library/socket.rst:1470
msgid "The *backlog* parameter is now optional."
msgstr "*backlog* 引数が任意になりました。"

#: ../../library/socket.rst:1479
msgid ""
"Return a :term:`file object` associated with the socket.  The exact returned "
"type depends on the arguments given to :meth:`makefile`.  These arguments "
"are interpreted the same way as by the built-in :func:`open` function, "
"except the only supported *mode* values are ``'r'`` (default), ``'w'`` and "
"``'b'``."
msgstr ""
"ソケットに関連付けられた :term:`ファイルオブジェクト <file object>` を返しま"
"す。戻り値の正確な型は、 :meth:`makefile` に指定した引数によります。これらの"
"引数は、組み込み関数 :func:`open` の引数と同様に解釈されます。ただし、*mode* "
"の値は  ``'r'`` (デフォルト), ``'w'``, ``'b'`` のみがサポートされています。"

#: ../../library/socket.rst:1484
msgid ""
"The socket must be in blocking mode; it can have a timeout, but the file "
"object's internal buffer may end up in an inconsistent state if a timeout "
"occurs."
msgstr ""
"ソケットはブロッキングモードでなければなりません。タイムアウトを設定すること"
"はできますが、タイムアウトが発生すると、ファイルオブジェクトの内部バッファが"
"矛盾した状態になることがあります。"

#: ../../library/socket.rst:1488
msgid ""
"Closing the file object returned by :meth:`makefile` won't close the "
"original socket unless all other file objects have been closed and :meth:"
"`socket.close` has been called on the socket object."
msgstr ""
":meth:`makefile` でファイルオブジェクトにソケットを関連づけた場合、ソケットを"
"閉じるには、関連づけられたすべてのファイルオブジェクトを閉じたあとで、元のソ"
"ケットの :meth:`socket.close` を呼び出さなければなりません。"

#: ../../library/socket.rst:1494
msgid ""
"On Windows, the file-like object created by :meth:`makefile` cannot be used "
"where a file object with a file descriptor is expected, such as the stream "
"arguments of :meth:`subprocess.Popen`."
msgstr ""
"Windows では :meth:`subprocess.Popen` の stream 引数などファイルディスクリプ"
"タつき file オブジェクトが期待されている場所では、 :meth:`makefile` によって"
"作成される file-like オブジェクトは使用できません。"

#: ../../library/socket.rst:1501
msgid ""
"Receive data from the socket.  The return value is a bytes object "
"representing the data received.  The maximum amount of data to be received "
"at once is specified by *bufsize*.  See the Unix manual page :manpage:"
"`recv(2)` for the meaning of the optional argument *flags*; it defaults to "
"zero."
msgstr ""
"ソケットからデータを受信し、結果を bytes オブジェクトで返します。一度に受信す"
"るデータは、最大でも *bufsize* で指定した量です。オプション引数 *flags* に指"
"定するフラグの意味については、 Unix のマニュアルページ :manpage:`recv(2)` を"
"参照してください。 *flags* のデフォルトは 0 です。"

#: ../../library/socket.rst:1508
msgid ""
"For best match with hardware and network realities, the value of  *bufsize* "
"should be a relatively small power of 2, for example, 4096."
msgstr ""
"ハードウェアおよびネットワークの現実に最大限マッチするように、 *bufsize* の値"
"は比較的小さい2の累乗、たとえば 4096、にすべきです。"

#: ../../library/socket.rst:1519
msgid ""
"Receive data from the socket.  The return value is a pair ``(bytes, "
"address)`` where *bytes* is a bytes object representing the data received "
"and *address* is the address of the socket sending the data.  See the Unix "
"manual page :manpage:`recv(2)` for the meaning of the optional argument "
"*flags*; it defaults to zero. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"ソケットからデータを受信し、結果をタプル ``(bytes, address)`` として返しま"
"す。 *bytes* は受信データの bytes オブジェクトで、 *address* は送信元のアドレ"
"スを示します。オプション引数 *flags* については、 Unix のマニュアルページ :"
"manpage:`recv(2)` を参照してください。デフォルトは0です。 (*address* のフォー"
"マットはアドレスファミリによって異なります(前述))"

#: ../../library/socket.rst:1530
msgid ""
"For multicast IPv6 address, first item of *address* does not contain "
"``%scope_id`` part anymore. In order to get full IPv6 address use :func:"
"`getnameinfo`."
msgstr ""

#: ../../library/socket.rst:1537
msgid ""
"Receive normal data (up to *bufsize* bytes) and ancillary data from the "
"socket.  The *ancbufsize* argument sets the size in bytes of the internal "
"buffer used to receive the ancillary data; it defaults to 0, meaning that no "
"ancillary data will be received.  Appropriate buffer sizes for ancillary "
"data can be calculated using :func:`CMSG_SPACE` or :func:`CMSG_LEN`, and "
"items which do not fit into the buffer might be truncated or discarded.  The "
"*flags* argument defaults to 0 and has the same meaning as for :meth:`recv`."
msgstr ""
"ソケットから通常のデータ (最大 *bufsize* バイト) と補助的なデータを受信しま"
"す。*ancbufsize* 引数により、補助的なデータの受信に使用される内部バッファのバ"
"イト数として、サイズが設定されます。このデフォルトは 0 で、補助的なデータを受"
"信しないことを意味します。:func:`CMSG_SPACE` または :func:`CMSG_LEN` を使用し"
"て、補助的なデータの適切なサイズを計算することができ、バッファ内に収まらない"
"アイテムは、短縮されるか破棄されます。*flags* 引数はデフォルトでは 0 で、:"
"meth:`recv` での意味と同じ意味を持ちます。"

#: ../../library/socket.rst:1547
msgid ""
"The return value is a 4-tuple: ``(data, ancdata, msg_flags, address)``.  The "
"*data* item is a :class:`bytes` object holding the non-ancillary data "
"received.  The *ancdata* item is a list of zero or more tuples "
"``(cmsg_level, cmsg_type, cmsg_data)`` representing the ancillary data "
"(control messages) received: *cmsg_level* and *cmsg_type* are integers "
"specifying the protocol level and protocol-specific type respectively, and "
"*cmsg_data* is a :class:`bytes` object holding the associated data.  The "
"*msg_flags* item is the bitwise OR of various flags indicating conditions on "
"the received message; see your system documentation for details. If the "
"receiving socket is unconnected, *address* is the address of the sending "
"socket, if available; otherwise, its value is unspecified."
msgstr ""
"戻り値は 4 要素のタプル ``(data, ancdata, msg_flags, address)`` です。*data* "
"アイテムは、受信した非付属的データを保持する :class:`bytes` オブジェクトで"
"す。*ancdata* アイテムは、ゼロ以上のタプル ``(cmsg_level, cmsg_type, "
"cmsg_data)`` からなるリストで、受信する付属的なデータ (制御メッセージ) を表し"
"ます。*cmsg_level* と *cmsg_type* はそれぞれ、プロトコルレベルとプロトコル固"
"有のタイプを指定する整数で、*cmsg_data* は関連するデータを保持する :class:"
"`bytes` オブジェクトです。*msg_flags* アイテムは、受信したメッセージの条件を"
"示す様々なフラグのビット OR です。詳細は、システムのドキュメントを参照してく"
"ださい。受信ソケットが接続されていない場合、*address* は、送信ソケットが利用"
"できる場合にはそのアドレスで、利用できない場合、その値は未指定になります。"

#: ../../library/socket.rst:1561
msgid ""
"On some systems, :meth:`sendmsg` and :meth:`recvmsg` can be used to pass "
"file descriptors between processes over an :const:`AF_UNIX` socket.  When "
"this facility is used (it is often restricted to :const:`SOCK_STREAM` "
"sockets), :meth:`recvmsg` will return, in its ancillary data, items of the "
"form ``(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)``, where *fds* is a :"
"class:`bytes` object representing the new file descriptors as a binary array "
"of the native C :c:expr:`int` type.  If :meth:`recvmsg` raises an exception "
"after the system call returns, it will first attempt to close any file "
"descriptors received via this mechanism."
msgstr ""

#: ../../library/socket.rst:1572
msgid ""
"Some systems do not indicate the truncated length of ancillary data items "
"which have been only partially received.  If an item appears to extend "
"beyond the end of the buffer, :meth:`recvmsg` will issue a :exc:"
"`RuntimeWarning`, and will return the part of it which is inside the buffer "
"provided it has not been truncated before the start of its associated data."
msgstr ""
"一部のシステムでは、部分的に受信した付属的なデータアイテムの短縮された長さが"
"示されません。アイテムがバッファの末尾を超えているようである場合、:meth:"
"`recvmsg` は :exc:`RuntimeWarning` を送出し、関連するデータの開始位置より前で"
"途切れていない場合、バッファ内の付属的なデータの一部を返します。"

#: ../../library/socket.rst:1579
msgid ""
"On systems which support the :const:`SCM_RIGHTS` mechanism, the following "
"function will receive up to *maxfds* file descriptors, returning the message "
"data and a list containing the descriptors (while ignoring unexpected "
"conditions such as unrelated control messages being received).  See also :"
"meth:`sendmsg`. ::"
msgstr ""
":const:`SCM_RIGHTS` メカニズムをサポートするシステム上では、次の関数が最大 "
"*maxfds* のファイル記述子を受信し、メッセージデータと記述子を含むリストを返し"
"ま(無関係な制御メッセージを受信した場合など、予期しない条件は無視します)。 :"
"meth:`sendmsg` も参照してください。"

#: ../../library/socket.rst:1610
msgid ""
"Receive normal data and ancillary data from the socket, behaving as :meth:"
"`recvmsg` would, but scatter the non-ancillary data into a series of buffers "
"instead of returning a new bytes object.  The *buffers* argument must be an "
"iterable of objects that export writable buffers (e.g. :class:`bytearray` "
"objects); these will be filled with successive chunks of the non-ancillary "
"data until it has all been written or there are no more buffers.  The "
"operating system may set a limit (:func:`~os.sysconf` value ``SC_IOV_MAX``) "
"on the number of buffers that can be used.  The *ancbufsize* and *flags* "
"arguments have the same meaning as for :meth:`recvmsg`."
msgstr ""
":meth:`recvmsg` と同様に動作してソケットから通常のデータと付属的なデータを受"
"信しますが、非付属的データは新しいバイトオブジェクトとして返すのではなく、一"
"連のバッファとして返します。*buffers* 引数は書き込み可能なバッファをエクス"
"ポートするオブジェクトのイテラブルでなければなりません (例: :class:"
"`bytearray` オブジェクト)。これらは、全てに書き込まれるか、残りバッファがなく"
"なるまで、非付属的データの連続チャンクで埋められます。オペレーティングシステ"
"ムによって、使用できるバッファの数が制限 (:func:`~os.sysconf` 値 "
"``SC_IOV_MAX``) されている場合があります。*ancbufsize* 引数と *flags* 引数"
"は、:meth:`recvmsg` での意味と同じ意味を持ちます。"

#: ../../library/socket.rst:1621
msgid ""
"The return value is a 4-tuple: ``(nbytes, ancdata, msg_flags, address)``, "
"where *nbytes* is the total number of bytes of non-ancillary data written "
"into the buffers, and *ancdata*, *msg_flags* and *address* are the same as "
"for :meth:`recvmsg`."
msgstr ""
"戻り値は 4 要素のタプル ``(nbytes, ancdata, msg_flags, address)`` です。ここ"
"で、*nbytes* はバッファに書き込まれた非付属的データの総数で、*ancdata*、"
"*msg_flags*、*address* は :meth:`recvmsg` と同様です。"

#: ../../library/socket.rst:1626
msgid "Example::"
msgstr "以下はプログラム例です::"

#: ../../library/socket.rst:1649
msgid ""
"Receive data from the socket, writing it into *buffer* instead of creating a "
"new bytestring.  The return value is a pair ``(nbytes, address)`` where "
"*nbytes* is the number of bytes received and *address* is the address of the "
"socket sending the data.  See the Unix manual page :manpage:`recv(2)` for "
"the meaning of the optional argument *flags*; it defaults to zero.  (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"ソケットからデータを受信し、そのデータを新しいバイト文字列として返す代わりに "
"*buffer* に書きます。戻り値は ``(nbytes, address)`` のペアで、 *nbytes* は受"
"信したデータのバイト数を、 *address* はデータを送信したソケットのアドレスで"
"す。オプション引数 *flags* (デフォルト:0) の意味については、 Unix マニュアル"
"ページ :manpage:`recv(2)` を参照してください。(*address* のフォーマットは前述"
"のとおりアドレスファミリーに依存します。)"

#: ../../library/socket.rst:1659
msgid ""
"Receive up to *nbytes* bytes from the socket, storing the data into a buffer "
"rather than creating a new bytestring.  If *nbytes* is not specified (or 0), "
"receive up to the size available in the given buffer.  Returns the number of "
"bytes received.  See the Unix manual page :manpage:`recv(2)` for the meaning "
"of the optional argument *flags*; it defaults to zero."
msgstr ""
"*nbytes* バイトまでのデータをソケットから受信して、そのデータを新しいバイト文"
"字列にするのではなく *buffer* に保存します。 *nbytes* が指定されない(あるいは"
"0が指定された)場合、 *buffer* の利用可能なサイズまで受信します。受信したバイ"
"ト数を返り値として返します。オプション引数 *flags* (デフォルト:0) の意味につ"
"いては、 Unix マニュアルページ :manpage:`recv(2)` を参照してください。"

#: ../../library/socket.rst:1668
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Returns the number of bytes sent. Applications are responsible for "
"checking that all data has been sent; if only some of the data was "
"transmitted, the application needs to attempt delivery of the remaining "
"data. For further information on this topic, consult the :ref:`socket-howto`."
msgstr ""
"ソケットにデータを送信します。ソケットはリモートソケットに接続済みでなければ"
"なりません。オプション引数 *flags* の意味は、上記 :meth:`recv` と同じです。戻"
"り値として、送信したバイト数を返します。アプリケーションでは、必ず戻り値を"
"チェックし、全てのデータが送られた事を確認する必要があります。データの一部だ"
"けが送信された場合、アプリケーションで残りのデータを再送信してください。 :"
"ref:`ソケットプログラミングHOWTO <socket-howto>` に、さらに詳しい情報がありま"
"す。"

#: ../../library/socket.rst:1683
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Unlike :meth:`send`, this method continues to send data from *bytes* "
"until either all data has been sent or an error occurs.  ``None`` is "
"returned on success.  On error, an exception is raised, and there is no way "
"to determine how much data, if any, was successfully sent."
msgstr ""
"ソケットにデータを送信します。ソケットはリモートソケットに接続済みでなければ"
"なりません。オプション引数 *flags* の意味は、上記 :meth:`recv` と同じです。 :"
"meth:`send` と異なり、このメソッドは *bytes* の全データを送信するか、エラーが"
"発生するまで処理を継続します。正常終了の場合は ``None`` を返し、エラー発生時"
"には例外が発生します。エラー発生時、送信されたバイト数を調べる事はできませ"
"ん。"

#: ../../library/socket.rst:1690
msgid ""
"The socket timeout is no more reset each time data is sent successfully. The "
"socket timeout is now the maximum total duration to send all data."
msgstr ""
"ソケットのタイムアウトは、データが正常に送信される度にリセットされなくなりま"
"した。ソケットのタイムアウトは、すべてのデータを送る最大の合計時間となりま"
"す。"

#: ../../library/socket.rst:1703
msgid ""
"Send data to the socket.  The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*.  The "
"optional *flags* argument has the same meaning as for :meth:`recv` above.  "
"Return the number of bytes sent. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"ソケットにデータを送信します。このメソッドでは接続先を *address* で指定するの"
"で、接続済みではいけません。オプション引数 *flags* の意味は、上記 :meth:"
"`recv` と同じです。戻り値として、送信したバイト数を返します。(*address* の"
"フォーマットはアドレスファミリによって異なります --- 前述。)"

#: ../../library/socket.rst:1718
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendto`` with arguments "
"``self``, ``address``."
msgstr ""
"引数 ``self``, ``address`` を指定して :ref:`監査イベント <auditing>` "
"``socket.sendto`` を送出します。 "

#: ../../library/socket.rst:1719
msgid ""
"Send normal and ancillary data to the socket, gathering the non-ancillary "
"data from a series of buffers and concatenating it into a single message.  "
"The *buffers* argument specifies the non-ancillary data as an iterable of :"
"term:`bytes-like objects <bytes-like object>` (e.g. :class:`bytes` objects); "
"the operating system may set a limit (:func:`~os.sysconf` value "
"``SC_IOV_MAX``) on the number of buffers that can be used.  The *ancdata* "
"argument specifies the ancillary data (control messages) as an iterable of "
"zero or more tuples ``(cmsg_level, cmsg_type, cmsg_data)``, where "
"*cmsg_level* and *cmsg_type* are integers specifying the protocol level and "
"protocol-specific type respectively, and *cmsg_data* is a bytes-like object "
"holding the associated data.  Note that some systems (in particular, systems "
"without :func:`CMSG_SPACE`) might support sending only one control message "
"per call.  The *flags* argument defaults to 0 and has the same meaning as "
"for :meth:`send`.  If *address* is supplied and not ``None``, it sets a "
"destination address for the message.  The return value is the number of "
"bytes of non-ancillary data sent."
msgstr ""
"非付属的なデータを一連のバッファから集め、単一のメッセージにまとめることで、"
"通常のデータと付属的なデータをソケットに送信します。*buffers* 引数は、非付属"
"的なデータを :term:`bytes-like objects <bytes-like object>` (例: :class:"
"`bytes` オブジェクト) のイテラブルとして指定します。オペレーティングシステム"
"によって、使用できるバッファの数が制限 (:func:`~os.sysconf` 値 "
"``SC_IOV_MAX``) されている場合があります。*ancdata* 引数は付属的なデータ (制"
"御メッセージ) をゼロ以上のタプル ``(cmsg_level, cmsg_type, cmsg_data)`` のイ"
"テラブルとして指定します。ここで、*cmsg_level* と *cmsg_type* はそれぞれプロ"
"トコルレベルとプロトコル固有のタイプを指定する整数で、*cmsg_data* は関連デー"
"タを保持するバイトライクオブジェクトです。一部のシステム (特に :func:"
"`CMSG_SPACE` を持たないシステム) では、一度の呼び出しで一つの制御メッセージの"
"送信しかサポートされていない場合があります。*flags* 引数のデフォルトは 0 であ"
"り、:meth:`send` での意味と同じ意味を持ちます。``None`` 以外の *address* が渡"
"された場合、メッセージの目的地のアドレスを設定します。戻り値は、送信された非"
"付属的データのバイト数です。"

#: ../../library/socket.rst:1739
msgid ""
"The following function sends the list of file descriptors *fds* over an :"
"const:`AF_UNIX` socket, on systems which support the :const:`SCM_RIGHTS` "
"mechanism.  See also :meth:`recvmsg`. ::"
msgstr ""
"以下の関数は、:const:`SCM_RIGHTS` メカニズムをサポートするシステムで、ファイ"
"ル記述子 *fds* を :const:`AF_UNIX` ソケット経由で送信します。:meth:`recvmsg` "
"も参照してください。"

#: ../../library/socket.rst:1748
msgid ":ref:`Availability <availability>`: Unix, not WASI."
msgstr ""

#: ../../library/socket.rst:1761
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendmsg`` with arguments "
"``self``, ``address``."
msgstr ""
"引数 ``self``, ``address`` を指定して :ref:`監査イベント <auditing>` "
"``socket.sendmsg`` を送出します。 "

#: ../../library/socket.rst:1763
msgid ""
"Specialized version of :meth:`~socket.sendmsg` for :const:`AF_ALG` socket. "
"Set mode, IV, AEAD associated data length and flags for :const:`AF_ALG` "
"socket."
msgstr ""
":meth:`~socket.sendmsg` の :const:`AF_ALG` ソケット用に特化したバージョンで"
"す。:const:`AF_ALG` ソケットの、モード、IV、AEAD に関連づけられたデータ長、フ"
"ラグを設定します。"

#: ../../library/socket.rst:1772
msgid ""
"Send a file until EOF is reached by using high-performance :mod:`os."
"sendfile` and return the total number of bytes which were sent. *file* must "
"be a regular file object opened in binary mode. If :mod:`os.sendfile` is not "
"available (e.g. Windows) or *file* is not a regular file :meth:`send` will "
"be used instead. *offset* tells from where to start reading the file. If "
"specified, *count* is the total number of bytes to transmit as opposed to "
"sending the file until EOF is reached. File position is updated on return or "
"also in case of error in which case :meth:`file.tell() <io.IOBase.tell>` can "
"be used to figure out the number of bytes which were sent. The socket must "
"be of :const:`SOCK_STREAM` type. Non-blocking sockets are not supported."
msgstr ""
"高性能の :mod:`os.sendfile` を使用して、ファイルを EOF まで送信し、送信された"
"バイトの総数を返します。*file* は、バイナリモードで開かれた標準的なファイルオ"
"ブジェクトです。:mod:`os.sendfile` が使用できない場合 (例: Windows)、または "
"*file* が標準的なファイルでない場合、代わりに :meth:`send` が使用されます。"
"*offset* は、ファイルの読み出し開始位置を指定します。*count* が指定されている"
"場合、ファイルを EOF まで送信するのではなく、転送するバイトの総数を指定しま"
"す。ファイルの位置は、返る時に更新されます。あるいは、エラー時には :meth:"
"`file.tell() <io.IOBase.tell>`  を使用して送信されたバイトの数を確認すること"
"ができます。ソケットは :const:`SOCK_STREAM` タイプでなければなりません。非ブ"
"ロックソケットはサポートされていません。"

#: ../../library/socket.rst:1788
msgid ""
"Set the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle."
msgstr ""
"ソケットのファイル記述子、またはソケットのハンドルの、 :ref:`継承可能フラグ "
"<fd_inheritance>` を立てます。"

#: ../../library/socket.rst:1796
msgid ""
"Set blocking or non-blocking mode of the socket: if *flag* is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr ""
"ソケットをブロッキングモード、または非ブロッキングモードに設定します。*flag* "
"が False の場合にはソケットは非ブロッキングモードになり、True の場合にはブ"
"ロッキングモードになります。"

#: ../../library/socket.rst:1799
msgid ""
"This method is a shorthand for certain :meth:`~socket.settimeout` calls:"
msgstr ""
"このメソッドは、次の :meth:`~socket.settimeout` 呼び出しの省略表記です:"

#: ../../library/socket.rst:1801
msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr "``sock.setblocking(True)`` は ``sock.settimeout(None)`` と等価です"

#: ../../library/socket.rst:1803
msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0.0)``"
msgstr "``sock.setblocking(False)`` は ``sock.settimeout(0.0)`` と等価です"

#: ../../library/socket.rst:1805
msgid ""
"The method no longer applies :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""

#: ../../library/socket.rst:1812
msgid ""
"Set a timeout on blocking socket operations.  The *value* argument can be a "
"nonnegative floating point number expressing seconds, or ``None``. If a non-"
"zero value is given, subsequent socket operations will raise a :exc:"
"`timeout` exception if the timeout period *value* has elapsed before the "
"operation has completed.  If zero is given, the socket is put in non-"
"blocking mode. If ``None`` is given, the socket is put in blocking mode."
msgstr ""
"ブロッキングソケットの処理のタイムアウト値を指定します。 *value* には float "
"型で非負の秒数を指定するか、 ``None`` を指定します。ゼロ以外の値を指定した場"
"合、ソケットの処理が完了する前に *value* で指定した秒数が経過すれば :exc:"
"`timeout` 例外を送出します。ゼロを指定した場合、ソケットは非ブロッキングモー"
"ド状態に置かれます。 ``None`` を指定した場合、ソケットのタイムアウトを無効に"
"します。"

#: ../../library/socket.rst:1819
msgid ""
"For further information, please consult the :ref:`notes on socket timeouts "
"<socket-timeouts>`."
msgstr ""
"詳しくは :ref:`ソケットタイムアウトの注意事項 <socket-timeouts>` を参照してく"
"ださい。"

#: ../../library/socket.rst:1821
msgid ""
"The method no longer toggles :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""

#: ../../library/socket.rst:1834
msgid ""
"Set the value of the given socket option (see the Unix manual page :manpage:"
"`setsockopt(2)`).  The needed symbolic constants are defined in the :mod:"
"`socket` module (:const:`SO_\\*` etc.).  The value can be an integer, "
"``None`` or a :term:`bytes-like object` representing a buffer. In the later "
"case it is up to the caller to ensure that the bytestring contains the "
"proper bits (see the optional built-in module :mod:`struct` for a way to "
"encode C structures as bytestrings). When *value* is set to ``None``, "
"*optlen* argument is required. It's equivalent to call :c:func:`setsockopt` "
"C function with ``optval=NULL`` and ``optlen=optlen``."
msgstr ""
"指定されたソケットオプションの値を設定します (Unix のマニュアルページ :"
"manpage:`setsockopt(2)` を参照)。必要なシンボリック定数は、:mod:`socket` モ"
"ジュール (:const:`SO_\\*` など) で定義されています。この値は、整数、"
"``None``、またはバッファを表す :term:`bytes-like object` のいずれかです。バイ"
"トライクオブジェクトの場合、バイト文字列に適切なビットが含まれていることを確"
"認するのは呼び出し元の仕事です (C 構造をバイト文字列としてエンコードする方法"
"については、オプションの組み込みモジュール :mod:`struct` を参照)。値が "
"``None`` に設定されている場合、optlen 引数が必須です。これは、 "
"``optval=NULL`` と ``optlen=optlen`` で :c:func:`setsockopt` C 関数を呼び出す"
"のと同一です。"

#: ../../library/socket.rst:1847
msgid "setsockopt(level, optname, None, optlen: int) form added."
msgstr "setsockopt(level, optname, None, optlen: int) の形式が追加されました。"

#: ../../library/socket.rst:1855
msgid ""
"Shut down one or both halves of the connection.  If *how* is :const:"
"`SHUT_RD`, further receives are disallowed.  If *how* is :const:`SHUT_WR`, "
"further sends are disallowed.  If *how* is :const:`SHUT_RDWR`, further sends "
"and receives are disallowed."
msgstr ""
"接続の片方向、または両方向を切断します。 *how* が :const:`SHUT_RD` の場合、以"
"降は受信を行えません。 *how* が :const:`SHUT_WR` の場合、以降は送信を行えませ"
"ん。 *how* が :const:`SHUT_RDWR` の場合、以降は送受信を行えません。"

#: ../../library/socket.rst:1865
msgid ""
"Duplicate a socket and prepare it for sharing with a target process.  The "
"target process must be provided with *process_id*.  The resulting bytes "
"object can then be passed to the target process using some form of "
"interprocess communication and the socket can be recreated there using :func:"
"`fromshare`. Once this method has been called, it is safe to close the "
"socket since the operating system has already duplicated it for the target "
"process."
msgstr ""
"ソケットを複製し、対象のプロセスと共有するための bytes オブジェクトを返しま"
"す。対象のプロセスを *process_id* で指定しなければなりません。戻り値の bytes "
"オブジェクトは、何らかのプロセス間通信を使って対象のプロセスに伝えます。対象"
"のプロセス側では、 :func:`fromshare` を使って複製されたソケットをとらえます。"
"オペレーティング・システムは対象のプロセスに対してソケットを複製するため、こ"
"のメソッドを呼び出した後であれば、元のソケットをクローズしても、対象のプロセ"
"スに渡ったソケットには影響がありません。"

#: ../../library/socket.rst:1877
msgid ""
"Note that there are no methods :meth:`read` or :meth:`write`; use :meth:"
"`~socket.recv` and :meth:`~socket.send` without *flags* argument instead."
msgstr ""
":meth:`read` メソッドと :meth:`write` メソッドは存在しませんので注意してくだ"
"さい。代わりに *flags* を省略した :meth:`~socket.recv` と :meth:`~socket."
"send` を使うことができます。"

#: ../../library/socket.rst:1880
msgid ""
"Socket objects also have these (read-only) attributes that correspond to the "
"values given to the :class:`~socket.socket` constructor."
msgstr ""
"ソケットオブジェクトには以下の :class:`~socket.socket` コンストラクタに渡され"
"た値に対応した (読み出し専用) 属性があります。"

#: ../../library/socket.rst:1886
msgid "The socket family."
msgstr "ソケットファミリー。"

#: ../../library/socket.rst:1891
msgid "The socket type."
msgstr "ソケットタイプ。"

#: ../../library/socket.rst:1896
msgid "The socket protocol."
msgstr "ソケットプロトコル。"

#: ../../library/socket.rst:1903
msgid "Notes on socket timeouts"
msgstr "ソケットタイムアウトの注意事項"

#: ../../library/socket.rst:1905
msgid ""
"A socket object can be in one of three modes: blocking, non-blocking, or "
"timeout.  Sockets are by default always created in blocking mode, but this "
"can be changed by calling :func:`setdefaulttimeout`."
msgstr ""
"ソケットオブジェクトは、ブロッキングモード、非ブロッキングモード、タイムアウ"
"トモードのうち、いずれか1つのモードをとります。デフォルトでは、ソケットは常に"
"ブロッキングモードで作成されますが、 :func:`setdefaulttimeout` で標準のモード"
"を変更することができます。"

#: ../../library/socket.rst:1909
msgid ""
"In *blocking mode*, operations block until complete or the system returns an "
"error (such as connection timed out)."
msgstr ""
"*ブロッキングモード* での操作は、完了するか、または（接続がタイムアウトするな"
"どして）システムがエラーを返すまで、ブロックされます。"

#: ../../library/socket.rst:1912
msgid ""
"In *non-blocking mode*, operations fail (with an error that is unfortunately "
"system-dependent) if they cannot be completed immediately: functions from "
"the :mod:`select` can be used to know when and whether a socket is available "
"for reading or writing."
msgstr ""
"*非ブロッキングモード* での操作は、ただちに完了できない場合、例外を送出して失"
"敗します。この場合の例外の種類は、システムに依存するため、ここに記すことがで"
"きません。 :mod:`select` モジュールの関数を使って、ソケットの読み書きが利用可"
"能かどうか、可能な場合はいつ利用できるかを調べることができます。"

#: ../../library/socket.rst:1917
msgid ""
"In *timeout mode*, operations fail if they cannot be completed within the "
"timeout specified for the socket (they raise a :exc:`timeout` exception) or "
"if the system returns an error."
msgstr ""
"*タイムアウトモード* での操作は、指定されたタイムアウトの時間内に完了しなけれ"
"ば、 :exc:`timeout` 例外を送出します。タイムアウトの時間内にシステムがエラー"
"を返した場合は、そのエラーを返します。"

#: ../../library/socket.rst:1922
msgid ""
"At the operating system level, sockets in *timeout mode* are internally set "
"in non-blocking mode.  Also, the blocking and timeout modes are shared "
"between file descriptors and socket objects that refer to the same network "
"endpoint. This implementation detail can have visible consequences if e.g. "
"you decide to use the :meth:`~socket.fileno()` of a socket."
msgstr ""
"オペレーティング・システムのレベルでは、 *タイムアウトモード* のソケットに"
"は、内部的に非ブロッキングモードが設定されています。またブロッキングモードと"
"タイムアウトモードの指定は、ファイル記述子と、「そのファイル記述子と同じネッ"
"トワーク端点を参照するソケットオブジェクト」との間で共有されます。このこと"
"は、例えばソケットの :meth:`~socket.fileno()` を使うことにした場合に、明らか"
"な影響を与えます。"

#: ../../library/socket.rst:1929
msgid "Timeouts and the ``connect`` method"
msgstr "タイムアウトと ``connect`` メソッド"

#: ../../library/socket.rst:1931
msgid ""
"The :meth:`~socket.connect` operation is also subject to the timeout "
"setting, and in general it is recommended to call :meth:`~socket.settimeout` "
"before calling :meth:`~socket.connect` or pass a timeout parameter to :meth:"
"`create_connection`.  However, the system network stack may also return a "
"connection timeout error of its own regardless of any Python socket timeout "
"setting."
msgstr ""
":meth:`~socket.connect` もタイムアウト設定に従います。一般的に、 :meth:"
"`~socket.settimeout` を :meth:`~socket.connect` の前に呼ぶか、 :meth:"
"`create_connection` にタイムアウト引数を渡すことが推奨されます。ただし、シス"
"テムのネットワークスタックが Python のソケットタイムアウトの設定を無視して、"
"自身の接続タイムアウトエラーを返すこともあります。"

#: ../../library/socket.rst:1939
msgid "Timeouts and the ``accept`` method"
msgstr "タイムアウトと ``accept`` メソッド"

#: ../../library/socket.rst:1941
msgid ""
"If :func:`getdefaulttimeout` is not :const:`None`, sockets returned by the :"
"meth:`~socket.accept` method inherit that timeout.  Otherwise, the behaviour "
"depends on settings of the listening socket:"
msgstr ""
":func:`getdefaulttimeout` が :const:`None` でない場合、 :meth:`~socket."
"accept` メソッドが返すソケットでは、そのタイムアウトが継承されます。 :const:"
"`None` である場合、待機中のソケットの設定によって動作は異なります。"

#: ../../library/socket.rst:1945
msgid ""
"if the listening socket is in *blocking mode* or in *timeout mode*, the "
"socket returned by :meth:`~socket.accept` is in *blocking mode*;"
msgstr ""
"待機中のソケットが *ブロッキングモード* または *タイムアウトモード* である場"
"合、:meth:`~socket.accept` が返すソケットは、*ブロッキングモード* になりま"
"す。"

#: ../../library/socket.rst:1948
msgid ""
"if the listening socket is in *non-blocking mode*, whether the socket "
"returned by :meth:`~socket.accept` is in blocking or non-blocking mode is "
"operating system-dependent.  If you want to ensure cross-platform behaviour, "
"it is recommended you manually override this setting."
msgstr ""
"待機中のソケットが *非ブロッキングモード* である場合、:meth:`~socket.accept` "
"が返すソケットは、オペレーティングシステムによってブロッキングモードまたは非"
"ブロッキングモードになります。クロスプラットフォームの動作を確保したい場合、"
"この設定を手動でオーバーライドすることをお勧めします。"

#: ../../library/socket.rst:1957
msgid "Example"
msgstr "使用例"

#: ../../library/socket.rst:1959
msgid ""
"Here are four minimal example programs using the TCP/IP protocol: a server "
"that echoes all data that it receives back (servicing only one client), and "
"a client using it.  Note that a server must perform the sequence :func:`."
"socket`, :meth:`~socket.bind`, :meth:`~socket.listen`, :meth:`~socket."
"accept` (possibly repeating the :meth:`~socket.accept` to service more than "
"one client), while a client only needs the sequence :func:`.socket`, :meth:"
"`~socket.connect`.  Also note that the server does not :meth:`~socket."
"sendall`/:meth:`~socket.recv` on the socket it is listening on but on the "
"new socket returned by :meth:`~socket.accept`."
msgstr ""
"以下は TCP/IP プロトコルの簡単なサンプルとして、受信したデータをクライアント"
"にそのまま返送するサーバ (接続可能なクライアントは一件のみ) と、サーバに接続"
"するクライアントの例を示します。サーバでは、 :func:`.socket` ・ :meth:"
"`~socket.bind` ・ :meth:`~socket.listen` ・ :meth:`~socket.accept` を実行し "
"(複数のクライアントからの接続を受け付ける場合、 :meth:`~socket.accept` を複数"
"回呼び出します)、クライアントでは :func:`.socket` と :meth:`~socket.connect` "
"だけを呼び出しています。サーバでは :meth:`~socket.sendall` / :meth:`~socket."
"recv` メソッドは listen 中のソケットで実行するのではなく、 :meth:`~socket."
"accept` で取得したソケットに対して実行している点にも注意してください。"

#: ../../library/socket.rst:1969
msgid "The first two examples support IPv4 only. ::"
msgstr "次のクライアントとサーバは、IPv4 のみをサポートしています。 ::"

#: ../../library/socket.rst:2000
msgid ""
"The next two examples are identical to the above two, but support both IPv4 "
"and IPv6. The server side will listen to the first address family available "
"(it should listen to both instead). On most of IPv6-ready systems, IPv6 will "
"take precedence and the server may not accept IPv4 traffic. The client side "
"will try to connect to the all addresses returned as a result of the name "
"resolution, and sends traffic to the first one connected successfully. ::"
msgstr ""
"次のサンプルは上記のサンプルとほとんど同じですが、IPv4 と IPv6 の両方をサポー"
"トしています。サーバでは、IPv4/v6 の両方ではなく、利用可能な最初のアドレス"
"ファミリだけを listen しています。ほとんどの IPv6 対応システムでは IPv6 が先"
"に現れるため、サーバは IPv4 には応答しません。クライアントでは名前解決の結果"
"として取得したアドレスに順次接続を試み、最初に接続に成功したソケットにデータ"
"を送信しています。 ::"

#: ../../library/socket.rst:2072
msgid ""
"The next example shows how to write a very simple network sniffer with raw "
"sockets on Windows. The example requires administrator privileges to modify "
"the interface::"
msgstr ""
"次の例は、Windowsで raw socket を利用して非常にシンプルなネットワークスニ"
"ファーを書きます。このサンプルを実行するには、インターフェースを操作するため"
"の管理者権限が必要です::"

#: ../../library/socket.rst:2097
msgid ""
"The next example shows how to use the socket interface to communicate to a "
"CAN network using the raw socket protocol. To use CAN with the broadcast "
"manager protocol instead, open a socket with::"
msgstr ""
"次の例では、ソケットインターフェースを使用してローソケットプロトコルを使用す"
"る CAN ネットワークと通信する方法を説明します。ブロードキャストマネージャプロ"
"トコロルで CAN を使用するには、以下でソケットを開きます。"

#: ../../library/socket.rst:2103
msgid ""
"After binding (:const:`CAN_RAW`) or connecting (:const:`CAN_BCM`) the "
"socket, you can use the :meth:`socket.send`, and the :meth:`socket.recv` "
"operations (and their counterparts) on the socket object as usual."
msgstr ""
"ソケットの束縛 (:const:`CAN_RAW`) または (:const:`CAN_BCM`) 接続を行ったあ"
"と、ソケットオブジェクトで :meth:`socket.send` と :meth:`socket.recv` 操作 "
"(とそのカウンターパート) を通常通りに使用することができます。"

#: ../../library/socket.rst:2107
msgid "This last example might require special privileges::"
msgstr "最後の例では、特権が必要になるかもしれません::"

#: ../../library/socket.rst:2147
msgid ""
"Running an example several times with too small delay between executions, "
"could lead to this error::"
msgstr ""
"この例を、ほとんど間を空けずに複数回実行すると、以下のエラーが発生する場合が"
"あります::"

#: ../../library/socket.rst:2152
msgid ""
"This is because the previous execution has left the socket in a "
"``TIME_WAIT`` state, and can't be immediately reused."
msgstr ""
"これは以前の実行がソケットを ``TIME_WAIT`` 状態のままにし、すぐには再利用でき"
"ないことで起こります。"

#: ../../library/socket.rst:2155
msgid ""
"There is a :mod:`socket` flag to set, in order to prevent this, :data:"
"`socket.SO_REUSEADDR`::"
msgstr ""
"これを防ぐのに、 :mod:`socket` フラグの :data:`socket.SO_REUSEADDR` がありま"
"す::"

#: ../../library/socket.rst:2162
msgid ""
"the :data:`SO_REUSEADDR` flag tells the kernel to reuse a local socket in "
"``TIME_WAIT`` state, without waiting for its natural timeout to expire."
msgstr ""
":data:`SO_REUSEADDR` フラグは、 ``TIME_WAIT`` 状態にあるローカルソケットをそ"
"のタイムアウト期限が自然に切れるのを待つことなく再利用することをカーネルに伝"
"えます。"

#: ../../library/socket.rst:2168
msgid ""
"For an introduction to socket programming (in C), see the following papers:"
msgstr ""
"C 言語によるソケットプログラミングの基礎については、以下の資料を参照してくだ"
"さい。 "

#: ../../library/socket.rst:2170
msgid ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, by Stuart "
"Sechrest"
msgstr ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, by Stuart "
"Sechrest"

#: ../../library/socket.rst:2172
msgid ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, by Samuel J.  "
"Leffler et al,"
msgstr ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, by Samuel J.  "
"Leffler et al,"

#: ../../library/socket.rst:2175
msgid ""
"both in the UNIX Programmer's Manual, Supplementary Documents 1 (sections "
"PS1:7 and PS1:8).  The platform-specific reference material for the various "
"socket-related system calls are also a valuable source of information on the "
"details of socket semantics.  For Unix, refer to the manual pages; for "
"Windows, see the WinSock (or Winsock 2) specification.  For IPv6-ready APIs, "
"readers may want to refer to :rfc:`3493` titled Basic Socket Interface "
"Extensions for IPv6."
msgstr ""
"両書とも UNIX Programmer's Manual, Supplementary Documents 1 (PS1:7章 PS1:8"
"章)。ソケットの詳細については、各プラットフォームのソケット関連システムコール"
"に関するドキュメントも参照してください。Unix ではマニュアルページ、Windowsで"
"はWinSock (または WinSock2) 仕様書をご覧ください。IPv6 対応の API について"
"は、 :rfc:`3493` \"Basic Socket Interface Extensions for IPv6\" を参照してく"
"ださい。"
