# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2017-11-20 04:52+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/socket.rst:2
msgid ":mod:`socket` --- Low-level networking interface"
msgstr ":mod:`socket` --- ä½ãƒ¬ãƒ™ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹"

#: ../../library/socket.rst:8
msgid ""
"This module provides access to the BSD *socket* interface. It is available "
"on all modern Unix systems, Windows, Mac OS X, BeOS, OS/2, and probably "
"additional platforms."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€Pythonã§BSD *ã‚½ã‚±ãƒƒãƒˆ(socket)* ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™ã€‚æœ€è¿‘ã®Unixã‚·ã‚¹ãƒ†ãƒ ã€Windows, Max OS X, BeOS, OS/2ãªã©ã€å¤šãã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§åˆ©ç”¨å¯èƒ½ã§ã™ã€‚"

#: ../../library/socket.rst:14
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs."
msgstr "ã„ãã¤ã‹ã®æŒ¯ã‚‹èˆã„ã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ä¾å­˜ã—ã¾ã™ã€‚ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®ã‚½ã‚±ãƒƒãƒˆAPIã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ãŸã‚ã§ã™ã€‚"

#: ../../library/socket.rst:17
msgid ""
"For an introduction to socket programming (in C), see the following papers: "
"An Introductory 4.3BSD Interprocess Communication Tutorial, by Stuart "
"Sechrest and An Advanced 4.3BSD Interprocess Communication Tutorial, by "
"Samuel J.  Leffler et al, both in the UNIX Programmer's Manual, "
"Supplementary Documents 1 (sections PS1:7 and PS1:8).  The platform-specific"
" reference material for the various socket-related system calls are also a "
"valuable source of information on the details of socket semantics.  For "
"Unix, refer to the manual pages; for Windows, see the WinSock (or Winsock 2)"
" specification. For IPv6-ready APIs, readers may want to refer to "
":rfc:`3493` titled Basic Socket Interface Extensions for IPv6."
msgstr "Cè¨€èªã«ã‚ˆã‚‹ã‚½ã‚±ãƒƒãƒˆãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®åŸºç¤ã«ã¤ã„ã¦ã¯ã€ä»¥ä¸‹ã®è³‡æ–™ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ An Introductory 4.3BSD Interprocess Communication Tutorial (Stuart Sechrest), An Advanced 4.3BSD Interprocess Communication Tutorial (Samuel J. Lefflerä»–), UNIX Programmer's Manual, Supplementary Documents 1(PS1:7ç«  PS1:8ç« )ã€‚ã‚½ã‚±ãƒƒãƒˆã®è©³ç´°ã«ã¤ã„ã¦ã¯ã€å„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®ã‚½ã‚±ãƒƒãƒˆé–¢é€£ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã«é–¢ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ(Unix ã§ã¯ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ã€Windowsã§ã¯WinSock(ã¾ãŸã¯WinSock2)ä»•æ§˜æ›¸)ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚ IPv6å¯¾å¿œã®APIã«ã¤ã„ã¦ã¯ã€ :rfc:`3493` \"Basic Socket Interface Extensions for IPv6\" ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:29
msgid ""
"The Python interface is a straightforward transliteration of the Unix system"
" call and library interface for sockets to Python's object-oriented style: "
"the :func:`.socket` function returns a :dfn:`socket object` whose methods "
"implement the various socket system calls.  Parameter types are somewhat "
"higher-level than in the C interface: as with :meth:`read` and :meth:`write`"
" operations on Python files, buffer allocation on receive operations is "
"automatic, and buffer length is implicit on send operations."
msgstr "Pythonã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯ã€Unixã®ã‚½ã‚±ãƒƒãƒˆç”¨ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã€ãã®ã¾ã¾Pythonã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã‚¹ã‚¿ã‚¤ãƒ«ã«å¤‰æ›ã—ãŸã‚‚ã®ã§ã™ã€‚å„ç¨®ã‚½ã‚±ãƒƒãƒˆé–¢é€£ã®ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã¯ã€ :func:`.socket` é–¢æ•°ã§ç”Ÿæˆã™ã‚‹ :dfn:`socket ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚ ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯Cã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚ˆã‚Šã‚‚å¤šå°‘é«˜æ°´æº–ã§ã€ä¾‹ãˆã° :meth:`read` ã‚„ :meth:`write` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒæ§˜ã€ å—ä¿¡æ™‚ã®ãƒãƒƒãƒ•ã‚¡ç¢ºä¿ã‚„é€ä¿¡æ™‚ã®å‡ºåŠ›ã‚µã‚¤ã‚ºãªã©ã¯è‡ªå‹•çš„ã«å‡¦ç†ã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:39
msgid ""
"Socket addresses are represented as follows: A single string is used for the"
" :const:`AF_UNIX` address family. A pair ``(host, port)`` is used for the "
":const:`AF_INET` address family, where *host* is a string representing "
"either a hostname in Internet domain notation like ``'daring.cwi.nl'`` or an"
" IPv4 address like ``'100.50.200.5'``, and *port* is an integer. For "
":const:`AF_INET6` address family, a four-tuple ``(host, port, flowinfo, "
"scopeid)`` is used, where *flowinfo* and *scopeid* represents "
"``sin6_flowinfo`` and ``sin6_scope_id`` member in :const:`struct "
"sockaddr_in6` in C. For :mod:`socket` module methods, *flowinfo* and "
"*scopeid* can be omitted just for backward compatibility. Note, however, "
"omission of *scopeid* can cause problems in manipulating scoped IPv6 "
"addresses. Other address families are currently not supported. The address "
"format required by a particular socket object is automatically selected "
"based on the address family specified when the socket object was created."
msgstr "ã‚½ã‚±ãƒƒãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«æŒ‡å®šã—ã¾ã™:å˜ä¸€ã®æ–‡å­—åˆ—ã¯ã€ :const:`AF_UNIX` ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã‚’ç¤ºã—ã¾ã™ã€‚ ``(host, port)`` ã®ãƒšã‚¢ã¯ :const:`AF_INET` ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã‚’ç¤ºã—ã€ *host* ã¯ ``'daring.cwi.nl'`` ã®ã‚ˆã†ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒ‰ãƒ¡ã‚¤ãƒ³å½¢å¼ã¾ãŸã¯ ``'100.50.200.5'`` ã®ã‚ˆã†ãªIPv4ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ–‡å­—åˆ—ã§ã€ *port* ã¯ãƒãƒ¼ãƒˆç•ªå·ã‚’æ•´æ•°ã§æŒ‡å®šã—ã¾ã™ã€‚ :const:`AF_INET6` ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã¯ ``(host, port, flowinfo, scopeid)`` ã®é•·ã•4ã®ã‚¿ãƒ—ãƒ«ã§ç¤ºã—ã€ *flowinfo* ã¨ *scopeid* ã«ã¯ãã‚Œãã‚ŒCã® :const:`struct sockaddr_in6` ã«ãŠã‘ã‚‹ ``sin6_flowinfo`` ã¨ ``sin6_scope_id`` ã®å€¤ã‚’æŒ‡å®šã—ã¾ã™ã€‚å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã€ :mod:`socket` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ ``sin6_flowinfo`` ã¨ ``sin6_scope_id`` ã‚’çœç•¥ã™ã‚‹äº‹ãŒã§ãã¾ã™ãŒã€ *scopeid* ã‚’çœç•¥ã™ã‚‹ã¨ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŒã£ãŸIPv6ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å‡¦ç†ã§å•é¡ŒãŒç™ºç”Ÿã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ç¾åœ¨ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã¯ä»¥ä¸Šã§ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§åˆ©ç”¨ã™ã‚‹äº‹ã®ã§ãã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹å½¢å¼ã¯ã€ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆæ™‚ã«æŒ‡å®šã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã§æ±ºã¾ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:54
msgid ""
"For IPv4 addresses, two special forms are accepted instead of a host "
"address: the empty string represents :const:`INADDR_ANY`, and the string "
"``'<broadcast>'`` represents :const:`INADDR_BROADCAST`. The behavior is not "
"available for IPv6 for backward compatibility, therefore, you may want to "
"avoid these if you intend to support IPv6 with your Python programs."
msgstr "IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒ›ã‚¹ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ãŒç©ºæ–‡å­—åˆ—ã®å ´åˆã€ :const:`INADDR_ANY` ã¨ã—ã¦å‡¦ç†ã•ã‚Œã¾ã™ã€‚ã¾ãŸã€ ``'<broadcast>'`` ã®å ´åˆã¯ :const:`INADDR_BROADCAST` ã¨ã—ã¦å‡¦ç†ã•ã‚Œã¾ã™ã€‚ IPv6ã§ã¯å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã“ã®æ©Ÿèƒ½ã¯ç”¨æ„ã•ã‚Œã¦ã„ã¾ã›ã‚“ã®ã§ã€IPv6ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹Pythonãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯åˆ©ç”¨ã—ãªã„ã§ä¸‹ã•ã„ã€‚"

#: ../../library/socket.rst:60
msgid ""
"If you use a hostname in the *host* portion of IPv4/v6 socket address, the "
"program may show a nondeterministic behavior, as Python uses the first "
"address returned from the DNS resolution.  The socket address will be "
"resolved differently into an actual IPv4/v6 address, depending on the "
"results from DNS resolution and/or the host configuration.  For "
"deterministic behavior use a numeric address in *host* portion."
msgstr "IPv4/v6ã‚½ã‚±ãƒƒãƒˆã® *host* éƒ¨ã«ãƒ›ã‚¹ãƒˆåã‚’æŒ‡å®šã™ã‚‹ã¨ã€å‡¦ç†çµæœãŒä¸€å®šã§ã¯ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯Pythonã¯DNSã‹ã‚‰å–å¾—ã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã®ã†ã¡æœ€åˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã®ã§ã€ DNSã®å‡¦ç†ã‚„ãƒ›ã‚¹ãƒˆã®è¨­å®šã«ã‚ˆã£ã¦ç•°ãªã‚‹IPv4/6ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã™ã‚‹å ´åˆãŒã‚ã‚‹ãŸã‚ã§ã™ã€‚å¸¸ã«åŒã˜çµæœãŒå¿…è¦ã§ã‚ã‚Œã°ã€ *host* ã«æ•°å€¤ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:67
msgid "AF_NETLINK sockets are represented as  pairs ``pid, groups``."
msgstr "AF_NETLINK ã‚½ã‚±ãƒƒãƒˆãŒ ``pid, groups`` ã®ãƒšã‚¢ã§è¡¨ç¾ã•ã‚Œã¾ã™."

#: ../../library/socket.rst:70
msgid ""
"Linux-only support for TIPC is also available using the :const:`AF_TIPC` "
"address family. TIPC is an open, non-IP based networked protocol designed "
"for use in clustered computer environments.  Addresses are represented by a "
"tuple, and the fields depend on the address type. The general tuple form is "
"``(addr_type, v1, v2, v3 [, scope])``, where:"
msgstr "Linuxã®ã¿ã€ :const:`AF_TIPC` ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã‚’ä½¿ã£ã¦ TIPC ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ TIPCã¯ã‚ªãƒ¼ãƒ—ãƒ³ã§ã€IPãƒ™ãƒ¼ã‚¹ã§ã¯ãªã„ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ç’°å¢ƒå‘ã‘ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ã‚¿ãƒ—ãƒ«ã§è¡¨ç¾ã•ã‚Œã€ãã®ä¸­èº«ã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚¿ã‚¤ãƒ—ã«ä¾å­˜ã—ã¾ã™ã€‚ä¸€èˆ¬çš„ãªã‚¿ãƒ—ãƒ«ã®å½¢ã¯ ``(addr_type, v1, v2, v3 [, scope])`` ã§ã€"

#: ../../library/socket.rst:77
msgid ""
"*addr_type* is one of :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"or :const:`TIPC_ADDR_ID`."
msgstr "*addr_type* ã¯ :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, :const:`TIPC_ADDR_ID` ã®1ã¤ã€‚"

#: ../../library/socket.rst:79
msgid ""
"*scope* is one of :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, and"
" :const:`TIPC_NODE_SCOPE`."
msgstr "*scope* ã¯ :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, :const:`TIPC_NODE_SCOPE` ã®1ã¤ã€‚"

#: ../../library/socket.rst:81
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAME`, then *v1* is the server type, "
"*v2* is the port identifier, and *v3* should be 0."
msgstr "*addr_type* ãŒ :const:`TIPC_ADDR_NAME` ã®å ´åˆã€ *v1* ã¯ã‚µãƒ¼ãƒãƒ¼ã‚¿ã‚¤ãƒ—ã€ *v2* ã¯ãƒãƒ¼ãƒˆID (the port identifier)ã€ãã—ã¦ *v3* ã¯ 0 ã§ã‚ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/socket.rst:84
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAMESEQ`, then *v1* is the server type, "
"*v2* is the lower port number, and *v3* is the upper port number."
msgstr "*addr_type* ãŒ :const:`TIPC_ADDR_NAMESEQ` ã®å ´åˆã€ *v1* ã¯ã‚µãƒ¼ãƒãƒ¼ã‚¿ã‚¤ãƒ—ã€ *v2* ã¯ãƒãƒ¼ãƒˆç•ªå·ä¸‹ä½(lower port number)ã€ *v3* ã¯ãƒãƒ¼ãƒˆç•ªå·ä¸Šä½(upper port number) ã§ã™ã€‚"

#: ../../library/socket.rst:87
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_ID`, then *v1* is the node, *v2* is the "
"reference, and *v3* should be set to 0."
msgstr "*addr_type* ãŒ :const:`TIPC_ADDR_ID` ã®å ´åˆã€ *v1* ã¯ãƒãƒ¼ãƒ‰ã€ *v2* ã¯å‚ç…§ã€ *v3* ã¯0ã§ã‚ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/socket.rst:91
msgid ""
"All errors raise exceptions.  The normal exceptions for invalid argument "
"types and out-of-memory conditions can be raised; errors related to socket "
"or address semantics raise the error :exc:`socket.error`."
msgstr "ã‚¨ãƒ©ãƒ¼æ™‚ã«ã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚å¼•æ•°å‹ã®ã‚¨ãƒ©ãƒ¼ã‚„ãƒ¡ãƒ¢ãƒªä¸è¶³ã®å ´åˆã«ã¯é€šå¸¸ã®ä¾‹å¤–ãŒç™ºç”Ÿã—ã€ã‚½ã‚±ãƒƒãƒˆã‚„ã‚¢ãƒ‰ãƒ¬ã‚¹é–¢é€£ã®ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ :exc:`socket.error` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/socket.rst:95
msgid ""
"Non-blocking mode is supported through :meth:`~socket.setblocking`.  A "
"generalization of this based on timeouts is supported through "
":meth:`~socket.settimeout`."
msgstr ":meth:`~socket.setblocking` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã€éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã¾ãŸã€ã‚ˆã‚Šæ±ç”¨çš„ã« :meth:`~socket.settimeout` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’æŒ‡å®šã™ã‚‹äº‹ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:99
msgid ""
"The module :mod:`socket` exports the following constants and functions:"
msgstr ":mod:`socket` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ä»¥ä¸‹ã®å®šæ•°ã¨é–¢æ•°ã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/socket.rst:106
msgid ""
"This exception is raised for socket-related errors. The accompanying value "
"is either a string telling what went wrong or a pair ``(errno, string)`` "
"representing an error returned by a system call, similar to the value "
"accompanying :exc:`os.error`. See the module :mod:`errno`, which contains "
"names for the error codes defined by the underlying operating system."
msgstr "ã“ã®ä¾‹å¤–ã¯ã€ã‚½ã‚±ãƒƒãƒˆé–¢é€£ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«é€å‡ºã•ã‚Œã¾ã™ã€‚ä¾‹å¤–ã®å€¤ã¯éšœå®³ã®å†…å®¹ã‚’ç¤ºã™æ–‡å­—åˆ—ã‹ã€ã¾ãŸã¯ :exc:`os.error` ã¨åŒæ§˜ãª ``(errno, string)`` ã®ãƒšã‚¢ã¨ãªã‚Šã¾ã™ã€‚ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã«ã¤ã„ã¦ã¯ :mod:`errno` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:112
msgid ":exc:`socket.error` is now a child class of :exc:`IOError`."
msgstr ":exc:`socket.error` ã¯ :exc:`IOError` ã®å­ã‚¯ãƒ©ã‚¹ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/socket.rst:118
msgid ""
"This exception is raised for address-related errors, i.e. for functions that"
" use *h_errno* in the C API, including :func:`gethostbyname_ex` and "
":func:`gethostbyaddr`."
msgstr "ã“ã®ä¾‹å¤–ã¯ã€C APIã® :func:`gethostbyname_ex` ã‚„ :func:`gethostbyaddr` ãªã©ã§ã€ *h_errno* ã®ã‚ˆã†ãªã‚¢ãƒ‰ãƒ¬ã‚¹é–¢é€£ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«é€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:122
msgid ""
"The accompanying value is a pair ``(h_errno, string)`` representing an error"
" returned by a library call. *string* represents the description of "
"*h_errno*, as returned by the :c:func:`hstrerror` C function."
msgstr "ä¾‹å¤–ã®å€¤ã¯ ``(h_errno, string)`` ã®ãƒšã‚¢ã§ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‘¼ã³å‡ºã—çµæœã‚’è¿”ã—ã¾ã™ã€‚ *string* ã¯Cé–¢æ•° :c:func:`hstrerror` ã§å–å¾—ã—ãŸã€ *h_errno* ã®æ„å‘³ã‚’ç¤ºã™æ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/socket.rst:129
msgid ""
"This exception is raised for address-related errors, for :func:`getaddrinfo`"
" and :func:`getnameinfo`. The accompanying value is a pair ``(error, "
"string)`` representing an error returned by a library call. *string* "
"represents the description of *error*, as returned by the "
":c:func:`gai_strerror` C function. The *error* value will match one of the "
":const:`EAI_\\*` constants defined in this module."
msgstr "ã“ã®ä¾‹å¤–ã¯ :func:`getaddrinfo` ã¨ :func:`getnameinfo` ã§ã‚¢ãƒ‰ãƒ¬ã‚¹é–¢é€£ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«é€å‡ºã•ã‚Œã¾ã™ã€‚ä¾‹å¤–ã®å€¤ã¯ ``(error, string)`` ã®ãƒšã‚¢ã§ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‘¼ã³å‡ºã—çµæœã‚’è¿”ã—ã¾ã™ã€‚ *string* ã¯Cé–¢æ•° :c:func:`gai_strerror` ã§å–å¾—ã—ãŸã€ *h_errno* ã®æ„å‘³ã‚’ç¤ºã™æ–‡å­—åˆ—ã§ã™ã€‚ *error* ã®å€¤ã¯ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã‚‹ :const:`EAI_\\*` å®šæ•°ã®ä½•ã‚Œã‹ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:139
msgid ""
"This exception is raised when a timeout occurs on a socket which has had "
"timeouts enabled via a prior call to :meth:`settimeout`.  The accompanying "
"value is a string whose value is currently always \"timed out\"."
msgstr "ã“ã®ä¾‹å¤–ã¯ã€ã‚ã‚‰ã‹ã˜ã‚ :meth:`settimeout` ã‚’å‘¼ã³å‡ºã—ã¦ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’æœ‰åŠ¹ã«ã—ã¦ã‚ã‚‹ã‚½ã‚±ãƒƒãƒˆã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç”Ÿã˜ãŸéš›ã«é€å‡ºã•ã‚Œã¾ã™ã€‚ä¾‹å¤–ã«ä»˜å±ã™ã‚‹å€¤ã¯æ–‡å­—åˆ—ã§ã€ãã®å†…å®¹ã¯ç¾çŠ¶ã§ã¯å¸¸ã« \"timed out\" ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:150
msgid ""
"These constants represent the address (and protocol) families, used for the "
"first argument to :func:`.socket`.  If the :const:`AF_UNIX` constant is not "
"defined then this protocol is unsupported."
msgstr "ã‚¢ãƒ‰ãƒ¬ã‚¹ (ãŠã‚ˆã³ãƒ—ãƒ­ãƒˆã‚³ãƒ«) ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã‚’ç¤ºã™å®šæ•°ã§ã€ :func:`.socket` ã® æœ€åˆã®å¼•æ•°ã«æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ :const:`AF_UNIX` ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã‚’ã‚µãƒãƒ¼ãƒˆ ã—ãªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€ :const:`AF_UNIX` ã¯æœªå®šç¾©ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:161
msgid ""
"These constants represent the socket types, used for the second argument to "
":func:`socket`. (Only :const:`SOCK_STREAM` and :const:`SOCK_DGRAM` appear to"
" be generally useful.)"
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã‚’ç¤ºã™å®šæ•°ã§ã€ :func:`socket` ã®2ç•ªç›®ã®å¼•æ•°ã«æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚(ã»ã¨ã‚“ã©ã®å ´åˆã€ :const:`SOCK_STREAM` ã¨ :const:`SOCK_DGRAM` ä»¥å¤–ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚)"

#: ../../library/socket.rst:180
msgid ""
"Many constants of these forms, documented in the Unix documentation on "
"sockets and/or the IP protocol, are also defined in the socket module. They "
"are generally used in arguments to the :meth:`setsockopt` and "
":meth:`getsockopt` methods of socket objects.  In most cases, only those "
"symbols that are defined in the Unix header files are defined; for a few "
"symbols, default values are provided."
msgstr "Unixã®ã‚½ã‚±ãƒƒãƒˆãƒ»IPãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹å„ç¨®å®šæ•°ã€‚ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`setsockopt` ã‚„ :meth:`getsockopt` ã§ä½¿ç”¨ã—ã¾ã™ã€‚ã»ã¨ã‚“ã©ã®ã‚·ãƒ³ãƒœãƒ«ã¯Unixã®ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã«å¾“ã£ã¦ã„ã¾ã™ã€‚ä¸€éƒ¨ã®ã‚·ãƒ³ãƒœãƒ«ã«ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’å®šç¾©ã—ã¦ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:190
msgid ""
"Constants for Windows' WSAIoctl(). The constants are used as arguments to "
"the :meth:`~socket.socket.ioctl` method of socket objects."
msgstr "Windows ã® WSAIoctl() ã®ãŸã‚ã®å®šæ•°ã§ã™ã€‚ã“ã®å®šæ•°ã¯ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`~socket.socket.ioctl` ãƒ¡ã‚½ãƒƒãƒ‰ã«å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:197
msgid ""
"TIPC related constants, matching the ones exported by the C socket API. See "
"the TIPC documentation for more information."
msgstr "TIPC é–¢é€£ã®å®šæ•°ã§ã€C ã®ã‚½ã‚±ãƒƒãƒˆAPIãŒå…¬é–‹ã—ã¦ã„ã‚‹ã‚‚ã®ã«ãƒãƒƒãƒã—ã¾ã™ã€‚è©³ã—ã„æƒ…å ±ã¯ TIPC ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:204
msgid ""
"This constant contains a boolean value which indicates if IPv6 is supported "
"on this platform."
msgstr "ç¾åœ¨ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§IPv6ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‹å¦ã‹ã‚’ç¤ºã™çœŸå½å€¤ã€‚"

#: ../../library/socket.rst:212
msgid ""
"Connect to a TCP service listening on the Internet *address* (a 2-tuple "
"``(host, port)``), and return the socket object.  This is a higher-level "
"function than :meth:`socket.connect`: if *host* is a non-numeric hostname, "
"it will try to resolve it for both :data:`AF_INET` and :data:`AF_INET6`, and"
" then try to connect to all possible addresses in turn until a connection "
"succeeds.  This makes it easy to write clients that are compatible to both "
"IPv4 and IPv6."
msgstr "*address* (``(host, port)`` ãƒšã‚¢) ã§ listen ã—ã¦ã„ã‚‹TCPã‚µãƒ¼ãƒ“ã‚¹ã«æ¥ç¶šã—ã€ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯ :meth:`socket.connect` ã‚’é«˜ç´šã«ã—ãŸé–¢æ•°ã§ã™ã€‚ *host* ãŒæ•°å€¤ã§ãªã„ãƒ›ã‚¹ãƒˆåã®å ´åˆã€ :data:`AF_INET` ã¨ :data:`AF_INET6` ã®ä¸¡æ–¹ã§åå‰è§£æ±ºã‚’è©¦ã¿ã€å¾—ã‚‰ã‚ŒãŸå…¨ã¦ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«å¯¾ã—ã¦æˆåŠŸã™ã‚‹ã¾ã§æ¥ç¶šã‚’è©¦ã¿ã¾ã™ã€‚ã“ã®é–¢æ•°ã‚’ä½¿ã£ã¦ IPv4 ã¨ IPv6 ã«ä¸¡å¯¾å¿œã—ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ç°¡å˜ã«æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:220
msgid ""
"Passing the optional *timeout* parameter will set the timeout on the socket "
"instance before attempting to connect.  If no *timeout* is supplied, the "
"global default timeout setting returned by :func:`getdefaulttimeout` is "
"used."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *timeout* å¼•æ•°ã‚’æŒ‡å®šã™ã‚‹ã¨ã€æ¥ç¶šã‚’è©¦ã¿ã‚‹å‰ã«ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®šã—ã¾ã™ã€‚ *timeout* ãŒæŒ‡å®šã•ã‚Œãªã„å ´åˆã€ :func:`getdefaulttimeout` ãŒè¿”ã™ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šå€¤ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:225
msgid ""
"If supplied, *source_address* must be a 2-tuple ``(host, port)`` for the "
"socket to bind to as its source address before connecting.  If host or port "
"are '' or 0 respectively the OS default behavior will be used."
msgstr "*source_address* ã¯æ¥ç¶šã™ã‚‹å‰ã«ãƒã‚¤ãƒ³ãƒ‰ã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®šã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•°ã§ã€æŒ‡å®šã™ã‚‹å ´åˆã¯ ``(host, port)`` ã®2è¦ç´ ã‚¿ãƒ—ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ host ã‚„ port ãŒ '' ã‹ 0 ã ã£ãŸå ´åˆã¯ã€OSã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:231
msgid "*source_address* was added."
msgstr "*source_address* ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/socket.rst:237
msgid ""
"Translate the *host*/*port* argument into a sequence of 5-tuples that "
"contain all the necessary arguments for creating a socket connected to that "
"service. *host* is a domain name, a string representation of an IPv4/v6 "
"address or ``None``. *port* is a string service name such as ``'http'``, a "
"numeric port number or ``None``.  By passing ``None`` as the value of *host*"
" and *port*, you can pass ``NULL`` to the underlying C API."
msgstr "*host* / *port* å¼•æ•°ã®æŒ‡ã™ã‚¢ãƒ‰ãƒ¬ã‚¹æƒ…å ±ã‚’ã€ãã®ã‚µãƒ¼ãƒ“ã‚¹ã«æ¥ç¶šã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‚’ä½œæˆã™ã‚‹ãŸã‚ã«å¿…è¦ãªå…¨ã¦ã®å¼•æ•°ãŒå…¥ã£ãŸ 5 è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã«å¤‰æ›ã—ã¾ã™ã€‚ *host* ã¯ãƒ‰ãƒ¡ã‚¤ãƒ³åã€IPv4/v6ã‚¢ãƒ‰ãƒ¬ã‚¹ã®æ–‡å­—åˆ—ã€ã¾ãŸã¯ ``None`` ã§ã™ã€‚ *port* ã¯ ``'http'`` ã®ã‚ˆã†ãªã‚µãƒ¼ãƒ“ã‚¹åæ–‡å­—åˆ—ã€ãƒãƒ¼ãƒˆç•ªå·ã‚’è¡¨ã™æ•°å€¤ã€ã¾ãŸã¯ ``None`` ã§ã™ã€‚ *host* ã¨ *port* ã« ``None`` ã‚’æŒ‡å®šã™ã‚‹ã¨ C APIã« ``NULL`` ã‚’æ¸¡ã›ã¾ã™ã€‚"

#: ../../library/socket.rst:244
msgid ""
"The *family*, *socktype* and *proto* arguments can be optionally specified "
"in order to narrow the list of addresses returned.  By default, their value "
"is ``0``, meaning that the full range of results is selected. The *flags* "
"argument can be one or several of the ``AI_*`` constants, and will influence"
" how results are computed and returned.  Its default value is ``0``.  For "
"example, :const:`AI_NUMERICHOST` will disable domain name resolution and "
"will raise an error if *host* is a domain name."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *family* ã€ *socktype* ã€ *proto* å¼•æ•°ã‚’æŒ‡å®šã™ã‚‹ã¨ã€è¿”ã•ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒªã‚¹ãƒˆã‚’çµã‚Šè¾¼ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã“ã‚Œã‚‰ã®å€¤ã¯ ``0`` ã§ã€çµã‚Šè¾¼ã¾ãšã«å…¨ã¦å–å¾—ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ *flags* å¼•æ•°ã«ã¯ ``AI_*`` å®šæ•°ã®ã†ã¡ 1 ã¤ä»¥ä¸ŠãŒæŒ‡å®šã§ãã€çµæœã®å–ã‚Šæ–¹ã‚’å¤‰ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã“ã‚Œã¯ ``0`` ã§ã™ã€‚ä¾‹ãˆã°ã€ :const:`AI_NUMERICHOST` ã‚’æŒ‡å®šã™ã‚‹ã¨ãƒ‰ãƒ¡ã‚¤ãƒ³åè§£æ±ºã‚’è¡Œã‚ãªã„ã‚ˆã†ã«ã—ã€ *host* ãŒãƒ‰ãƒ¡ã‚¤ãƒ³åã ã£ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/socket.rst:252
msgid "The function returns a list of 5-tuples with the following structure:"
msgstr "ã“ã®é–¢æ•°ã¯ä»¥ä¸‹ã®æ§‹é€ ã‚’ã¨ã‚‹ 5 è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™:"

#: ../../library/socket.rst:254
msgid "``(family, socktype, proto, canonname, sockaddr)``"
msgstr "``(family, socktype, proto, canonname, sockaddr)``"

#: ../../library/socket.rst:256
msgid ""
"In these tuples, *family*, *socktype*, *proto* are all integers and are "
"meant to be passed to the :func:`.socket` function.  *canonname* will be a "
"string representing the canonical name of the *host* if "
":const:`AI_CANONNAME` is part of the *flags* argument; else *canonname* will"
" be empty.  *sockaddr* is a tuple describing a socket address, whose format "
"depends on the returned *family* (a ``(address, port)`` 2-tuple for "
":const:`AF_INET`, a ``(address, port, flow info, scope id)`` 4-tuple for "
":const:`AF_INET6`), and is meant to be passed to the :meth:`socket.connect` "
"method."
msgstr "ã“ã®ã‚¿ãƒ—ãƒ«ã«ã‚ã‚‹ *family*, *socktype*, *proto* ã¯ã€ :func:`.socket` é–¢æ•°ã‚’å‘¼ã³å‡ºã™éš›ã«æŒ‡å®šã™ã‚‹å€¤ã¨åŒã˜æ•´æ•°ã§ã™ã€‚ :const:`AI_CANONNAME` ã‚’å«ã‚“ã  *flags* ã‚’æŒ‡å®šã—ãŸå ´åˆã€ *canonname* ã¯ *host* ã® canonical name ã‚’ç¤ºã™æ–‡å­—åˆ—ã§ã™ã€‚ãã†ã§ãªã„å ´åˆã¯ *canonname* ã¯ç©ºæ–‡å­—åˆ—ã§ã™ã€‚ *sockaddr* ã¯ã€ã‚½ã‚±ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ *family* ã«ä¾å­˜ã—ãŸå½¢å¼ã§è¡¨ã™ã‚¿ãƒ—ãƒ«ã§ã€ (:const:`AF_INET` ã®å ´åˆã¯ 2 è¦ç´ ã®ã‚¿ãƒ—ãƒ« ``(address, port)`` ã€ :const:`AF_INET6` ã®å ´åˆã¯ 4 è¦ç´ ã®ã‚¿ãƒ—ãƒ« ``(address, port, flow info, scope id)``) :meth:`socket.connect` ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã™ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚"

#: ../../library/socket.rst:266
msgid ""
"The following example fetches address information for a hypothetical TCP "
"connection to ``example.org`` on port 80 (results may differ on your system "
"if IPv6 isn't enabled)::"
msgstr "æ¬¡ã®ä¾‹ã§ã¯ ``example.org`` ã® 80 ç•ªãƒãƒ¼ãƒˆãƒãƒ¼ãƒˆã¸ã® TCP æ¥ç¶šã‚’å¾—ã‚‹ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹æƒ…å ±ã‚’å–å¾—ã—ã‚ˆã†ã¨ã—ã¦ã„ã¾ã™ã€‚ (çµæœã¯ IPv6 ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã§å¤‰ã‚ã‚Šã¾ã™)::"

#: ../../library/socket.rst:279
msgid ""
"Return a fully qualified domain name for *name*. If *name* is omitted or "
"empty, it is interpreted as the local host.  To find the fully qualified "
"name, the hostname returned by :func:`gethostbyaddr` is checked, followed by"
" aliases for the host, if available.  The first name which includes a period"
" is selected.  In case no fully qualified domain name is available, the "
"hostname as returned by :func:`gethostname` is returned."
msgstr "*name* ã®å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åã‚’è¿”ã—ã¾ã™ã€‚ *name* ãŒç©ºã¾ãŸã¯çœç•¥ã•ã‚ŒãŸå ´åˆã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒ›ã‚¹ãƒˆã‚’æŒ‡å®šã—ãŸã¨ã¿ãªã—ã¾ã™ã€‚å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åã®å–å¾—ã«ã¯ã¾ãš :func:`gethostbyaddr` ã§ãƒã‚§ãƒƒã‚¯ã—ã€æ¬¡ã«å¯èƒ½ã§ã‚ã‚Œã°ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚’èª¿ã¹ã€åå‰ã«ãƒ”ãƒªã‚ªãƒ‰ã‚’å«ã‚€æœ€åˆã®åå‰ã‚’å€¤ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åã‚’å–å¾—ã§ããªã„å ´åˆã€ :func:`gethostname` ã§è¿”ã•ã‚Œã‚‹ãƒ›ã‚¹ãƒˆåã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:291
msgid ""
"Translate a host name to IPv4 address format.  The IPv4 address is returned "
"as a string, such as  ``'100.50.200.5'``.  If the host name is an IPv4 "
"address itself it is returned unchanged.  See :func:`gethostbyname_ex` for a"
" more complete interface. :func:`gethostbyname` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr "ãƒ›ã‚¹ãƒˆåã‚’ ``'100.50.200.5'`` ã®ã‚ˆã†ãªIPv4å½¢å¼ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«å¤‰æ›ã—ã¾ã™ã€‚ãƒ›ã‚¹ãƒˆåã¨ã—ã¦IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®šã—ãŸå ´åˆã€ãã®å€¤ã¯å¤‰æ›ã›ãšã«ãã®ã¾ã¾è¿”ã‚Šã¾ã™ã€‚ :func:`gethostbyname` APIã¸ã®ã‚ˆã‚Šå®Œå…¨ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒå¿…è¦ã§ã‚ã‚Œã°ã€ :func:`gethostbyname_ex` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ :func:`gethostbyname` ã¯ã€IPv6åå‰è§£æ±ºã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚IPv4/ v6ã®ãƒ‡ãƒ¥ã‚¢ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã¯ :func:`getaddrinfo` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:300
msgid ""
"Translate a host name to IPv4 address format, extended interface. Return a "
"triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the primary"
" host name responding to the given *ip_address*, *aliaslist* is a (possibly "
"empty) list of alternative host names for the same address, and *ipaddrlist*"
" is a list of IPv4 addresses for the same interface on the same host (often "
"but not always a single address). :func:`gethostbyname_ex` does not support "
"IPv6 name resolution, and :func:`getaddrinfo` should be used instead for "
"IPv4/v6 dual stack support."
msgstr "ãƒ›ã‚¹ãƒˆåã‹ã‚‰ã€IPv4å½¢å¼ã®å„ç¨®ã‚¢ãƒ‰ãƒ¬ã‚¹æƒ…å ±ã‚’å–å¾—ã—ã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ ``(hostname, aliaslist, ipaddrlist)`` ã®ã‚¿ãƒ—ãƒ«ã§ã€ *hostname* ã¯ *ip_address* ã§æŒ‡å®šã—ãŸãƒ›ã‚¹ãƒˆã®æ­£å¼åã€ *aliaslist* ã¯åŒã˜ã‚¢ãƒ‰ãƒ¬ã‚¹ã®åˆ¥åã®ãƒªã‚¹ãƒˆ(ç©ºã®å ´åˆã‚‚ã‚ã‚‹)ã€ *ipaddrlist* ã¯åŒã˜ãƒ›ã‚¹ãƒˆä¸Šã®åŒä¸€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒªã‚¹ãƒˆ(ã»ã¨ã‚“ã©ã®å ´åˆã¯å˜ä¸€ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ã¿) ã‚’ç¤ºã—ã¾ã™ã€‚ :func:`gethostbyname_ex` ã¯ã€IPv6åå‰è§£æ±ºã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚IPv4/v6ã®ãƒ‡ãƒ¥ã‚¢ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã¯ :func:`getaddrinfo` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:312
msgid ""
"Return a string containing the hostname of the machine where  the Python "
"interpreter is currently executing."
msgstr "Pythonã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã‚’ç¾åœ¨å®Ÿè¡Œä¸­ã®ãƒã‚·ãƒ³ã®ãƒ›ã‚¹ãƒˆåã‚’ç¤ºã™æ–‡å­—åˆ—ã‚’å–å¾—ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:315
msgid ""
"If you want to know the current machine's IP address, you may want to use "
"``gethostbyname(gethostname())``. This operation assumes that there is a "
"valid address-to-host mapping for the host, and the assumption does not "
"always hold."
msgstr "å®Ÿè¡Œä¸­ãƒã‚·ãƒ³ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå¿…è¦ã§ã‚ã‚Œã°ã€ ``gethostbyname(gethostname())`` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚ã“ã®å‡¦ç†ã¯å®Ÿè¡Œä¸­ãƒ›ã‚¹ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹-ãƒ›ã‚¹ãƒˆåå¤‰æ›ãŒå¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’å‰æã¨ã—ã¦ã„ã¾ã™ãŒã€å¸¸ã«å¤‰æ›å¯èƒ½ã§ã‚ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:320
msgid ""
"Note: :func:`gethostname` doesn't always return the fully qualified domain "
"name; use ``getfqdn()`` (see above)."
msgstr "æ³¨æ„: :func:`gethostname` ã¯å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åã‚’è¿”ã™ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åãŒå¿…è¦ã§ã‚ã‚Œã°ã€ ``gethostbyaddr(gethostname())`` ã¨ã—ã¦ãã ã•ã„(ä¸‹è¨˜å‚ç…§)ã€‚"

#: ../../library/socket.rst:326
msgid ""
"Return a triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is "
"the primary host name responding to the given *ip_address*, *aliaslist* is a"
" (possibly empty) list of alternative host names for the same address, and "
"*ipaddrlist* is a list of IPv4/v6 addresses for the same interface on the "
"same host (most likely containing only a single address). To find the fully "
"qualified domain name, use the function :func:`getfqdn`. "
":func:`gethostbyaddr` supports both IPv4 and IPv6."
msgstr "``(hostname, aliaslist, ipaddrlist)`` ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã€ *hostname* ã¯ *ip_address* ã§æŒ‡å®šã—ãŸãƒ›ã‚¹ãƒˆã®æ­£å¼åã€ *aliaslist* ã¯åŒã˜ã‚¢ãƒ‰ãƒ¬ã‚¹ã®åˆ¥åã®ãƒªã‚¹ãƒˆ(ç©ºã®å ´åˆã‚‚ã‚ã‚‹)ã€ *ipaddrlist* ã¯åŒã˜ãƒ›ã‚¹ãƒˆä¸Šã®åŒä¸€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒªã‚¹ãƒˆ(ã»ã¨ã‚“ã©ã®å ´åˆã¯å˜ä¸€ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ã¿)ã‚’ç¤ºã—ã¾ã™ã€‚å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åãŒå¿…è¦ã§ã‚ã‚Œã°ã€ :func:`getfqdn` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚ :func:`gethostbyaddr` ã¯ã€IPv4/IPv6ã®ä¸¡æ–¹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/socket.rst:337
msgid ""
"Translate a socket address *sockaddr* into a 2-tuple ``(host, port)``. "
"Depending on the settings of *flags*, the result can contain a fully-"
"qualified domain name or numeric address representation in *host*.  "
"Similarly, *port* can contain a string port name or a numeric port number."
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ *sockaddr* ã‹ã‚‰ã€ ``(host, port)`` ã®ã‚¿ãƒ—ãƒ«ã‚’å–å¾—ã—ã¾ã™ã€‚ *flags* ã®è¨­å®šã«å¾“ã„ã€ *host* ã¯å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åã¾ãŸã¯æ•°å€¤å½¢å¼ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãªã‚Šã¾ã™ã€‚åŒæ§˜ã«ã€ *port* ã¯æ–‡å­—åˆ—ã®ãƒãƒ¼ãƒˆåã¾ãŸã¯æ•°å€¤ã®ãƒãƒ¼ãƒˆç•ªå·ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:347
msgid ""
"Translate an Internet protocol name (for example, ``'icmp'``) to a constant "
"suitable for passing as the (optional) third argument to the :func:`.socket`"
" function.  This is usually only needed for sockets opened in \"raw\" mode "
"(:const:`SOCK_RAW`); for the normal socket modes, the correct protocol is "
"chosen automatically if the protocol is omitted or zero."
msgstr "(``'icmp'`` ã®ã‚ˆã†ãª) ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ«åã‚’ã€ :func:`.socket` ã® ç¬¬ä¸‰å¼•æ•°ã¨ã—ã¦æŒ‡å®šã™ã‚‹äº‹ãŒã§ãã‚‹å®šæ•°ã«å¤‰æ›ã—ã¾ã™ã€‚ã“ã‚Œã¯ä¸»ã«ã‚½ã‚±ãƒƒãƒˆã‚’ \"raw\" ãƒ¢ãƒ¼ãƒ‰(:const:`SOCK_RAW`)ã§ã‚ªãƒ¼ãƒ—ãƒ³ã™ã‚‹å ´åˆã«ã¯å¿…è¦ã§ã™ãŒã€é€šå¸¸ã® ã‚½ã‚±ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã¯ç¬¬ä¸‰å¼•æ•°ã«0ã‚’æŒ‡å®šã™ã‚‹ã‹çœç•¥ã™ã‚Œã°æ­£ã—ã„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒè‡ªå‹•çš„ã«é¸æŠã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:356
msgid ""
"Translate an Internet service name and protocol name to a port number for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr "ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã‚µãƒ¼ãƒ“ã‚¹åã¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‹ã‚‰ã€ãã®ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒãƒ¼ãƒˆç•ªå·ã‚’å–å¾—ã—ã¾ã™ã€‚çœç•¥å¯èƒ½ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«åã¨ã—ã¦ã€ ``'tcp'`` ã‹ ``'udp'`` ã®ã©ã¡ã‚‰ã‹ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æŒ‡å®šãŒãªã‘ã‚Œã°ã©ã¡ã‚‰ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/socket.rst:363
msgid ""
"Translate an Internet port number and protocol name to a service name for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr "ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒãƒ¼ãƒˆç•ªå·ã¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«åã‹ã‚‰ã€ã‚µãƒ¼ãƒ“ã‚¹åã‚’å–å¾—ã—ã¾ã™ã€‚çœç•¥å¯èƒ½ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«åã¨ã—ã¦ã€ ``'tcp'`` ã‹ ``'udp'`` ã®ã©ã¡ã‚‰ã‹ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æŒ‡å®šãŒãªã‘ã‚Œã°ã©ã¡ã‚‰ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/socket.rst:370
msgid ""
"Create a new socket using the given address family, socket type and protocol"
" number.  The address family should be :const:`AF_INET` (the default), "
":const:`AF_INET6` or :const:`AF_UNIX`.  The socket type should be "
":const:`SOCK_STREAM` (the default), :const:`SOCK_DGRAM` or perhaps one of "
"the other ``SOCK_`` constants.  The protocol number is usually zero and may "
"be omitted in that case."
msgstr "ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã€ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç•ªå·ã‚’æŒ‡å®šã—ã¦ã‚½ã‚±ãƒƒãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ã¯ :const:`AF_INET` \\ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤)ãƒ» :const:`AF_INET6` ãƒ» :const:`AF_UNIX` ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã«ã¯ :const:`SOCK_STREAM` \\ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤)ãƒ» :const:`SOCK_DGRAM` ãƒ»ã¾ãŸã¯ä»–ã® ``SOCK_`` å®šæ•°ã®ä½•ã‚Œã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç•ªå·ã¯é€šå¸¸çœç•¥ã™ã‚‹ã‹ã€ã¾ãŸã¯0ã‚’æŒ‡å®šã—ã¾ã™ã€‚"

#: ../../library/socket.rst:380
msgid ""
"Build a pair of connected socket objects using the given address family, "
"socket type, and protocol number.  Address family, socket type, and protocol"
" number are as for the :func:`.socket` function above. The default family is"
" :const:`AF_UNIX` if defined on the platform; otherwise, the default is "
":const:`AF_INET`. Availability: Unix."
msgstr "æŒ‡å®šã•ã‚ŒãŸã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã€ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç•ªå·ã‹ã‚‰ã€æ¥ç¶šã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã®ãƒšã‚¢ã‚’ä½œæˆã—ã¾ã™ã€‚ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã€ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç•ªå·ã¯ :func:`.socket` é–¢æ•°ã¨åŒæ§˜ã«æŒ‡å®šã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã¯ã€ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§å®šç¾©ã•ã‚Œã¦ã„ã‚Œã° :const:`AF_UNIX`, ãã†ã§ãªã‘ã‚Œã° :const:`AF_INET` ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:391
msgid ""
"Duplicate the file descriptor *fd* (an integer as returned by a file "
"object's :meth:`fileno` method) and build a socket object from the result.  "
"Address family, socket type and protocol number are as for the "
":func:`.socket` function above. The file descriptor should refer to a "
"socket, but this is not checked --- subsequent operations on the object may "
"fail if the file descriptor is invalid. This function is rarely needed, but "
"can be used to get or set socket options on a socket passed to a program as "
"standard input or output (such as a server started by the Unix inet daemon)."
"  The socket is assumed to be in blocking mode. Availability: Unix."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ (ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`fileno` ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿”ã™æ•´æ•°) *fd* ã‚’è¤‡è£½ã—ã¦ã€ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç•ªå·ã¯ :func:`.socket` ã¨åŒæ§˜ã«æŒ‡å®šã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ ã¯ã‚½ã‚±ãƒƒãƒˆã‚’æŒ‡ã—ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ãŒã€å®Ÿéš›ã«ã‚½ã‚±ãƒƒãƒˆã§ã‚ã‚‹ã‹ã©ã†ã‹ã®ãƒã‚§ãƒƒã‚¯ã¯è¡Œã£ã¦ã„ã¾ã›ã‚“ã€‚ã“ã®ãŸã‚ã€ã‚½ã‚±ãƒƒãƒˆä»¥å¤–ã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ ã‚’æŒ‡å®šã™ã‚‹ã¨ãã®å¾Œã®å‡¦ç†ãŒå¤±æ•—ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ã“ã®é–¢æ•°ãŒå¿…è¦ãªäº‹ã¯ã‚ã¾ã‚Šã‚ã‚Šã¾ã›ã‚“ãŒã€ (Unixã®inetãƒ‡ãƒ¼ãƒ¢ãƒ³ã«èµ·å‹•ã•ã‚Œã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚ˆã†ã«) ã‚½ã‚±ãƒƒãƒˆã‚’æ¨™æº–å…¥åŠ›ã‚„æ¨™æº–å‡ºåŠ›ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å–å¾—ã‚„è¨­å®šã‚’è¡Œã†ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã®é–¢æ•°ã§ä½¿ç”¨ã™ã‚‹ã‚½ã‚±ãƒƒãƒˆã¯ã€ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã¨æƒ³å®šã—ã¦ã„ã¾ã™ã€‚ åˆ©ç”¨å¯èƒ½: Unix"

#: ../../library/socket.rst:404
msgid ""
"Convert 32-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr "32ãƒ“ãƒƒãƒˆã®æ­£ã®æ•´æ•°ã®ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‚’ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‹ã‚‰ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã«å¤‰æ›ã—ã¾ã™ã€‚ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãŒä¸€è‡´ã™ã‚‹ãƒã‚·ãƒ³ã§ã¯ã€ã“ã®é–¢æ•°ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯4ãƒã‚¤ãƒˆã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/socket.rst:411
msgid ""
"Convert 16-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr "16ãƒ“ãƒƒãƒˆã®æ­£ã®æ•´æ•°ã®ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‚’ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‹ã‚‰ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã«å¤‰æ›ã—ã¾ã™ã€‚ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãŒä¸€è‡´ã™ã‚‹ãƒã‚·ãƒ³ã§ã¯ã€ã“ã®é–¢æ•°ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯2ãƒã‚¤ãƒˆã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/socket.rst:418
msgid ""
"Convert 32-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr "32ãƒ“ãƒƒãƒˆã®æ­£ã®æ•´æ•°ã®ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‚’ã€ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‹ã‚‰ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã«å¤‰æ›ã—ã¾ã™ã€‚ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãŒä¸€è‡´ã™ã‚‹ãƒã‚·ãƒ³ã§ã¯ã€ã“ã®é–¢æ•°ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯4ãƒã‚¤ãƒˆã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/socket.rst:425
msgid ""
"Convert 16-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr "16ãƒ“ãƒƒãƒˆã®æ­£ã®æ•´æ•°ã®ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‚’ã€ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‹ã‚‰ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã«å¤‰æ›ã—ã¾ã™ã€‚ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãŒä¸€è‡´ã™ã‚‹ãƒã‚·ãƒ³ã§ã¯ã€ã“ã®é–¢æ•°ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯2ãƒã‚¤ãƒˆã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/socket.rst:432
msgid ""
"Convert an IPv4 address from dotted-quad string format (for example, "
"'123.45.67.89') to 32-bit packed binary format, as a string four characters "
"in length.  This is useful when conversing with a program that uses the "
"standard C library and needs objects of type :c:type:`struct in_addr`, which"
" is the C type for the 32-bit packed binary this function returns."
msgstr "ãƒ‰ãƒƒãƒˆè¨˜æ³•ã«ã‚ˆã‚‹IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹(``'123.45.67.89'`` ãªã©)ã‚’32ãƒ“ãƒƒãƒˆã«ãƒ‘ãƒƒã‚¯ã—ãŸãƒã‚¤ãƒŠãƒªå½¢å¼ã«å¤‰æ›ã—ã€é•·ã•4ã®æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ãŒè¿”ã™å€¤ã¯ã€æ¨™æº–Cãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® :c:type:`struct in_addr` å‹ã‚’ä½¿ç”¨ã™ã‚‹é–¢æ•°ã«æ¸¡ã™äº‹ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:438
msgid ""
":func:`inet_aton` also accepts strings with less than three dots; see the "
"Unix manual page :manpage:`inet(3)` for details."
msgstr ":func:`inet_aton` ã¯ãƒ‰ãƒƒãƒˆãŒ 3 å€‹ä»¥ä¸‹ã®æ–‡å­—åˆ—ã‚‚å—ã‘å–ã‚Šã¾ã™; è©³ç´°ã«ã¤ã„ã¦ã¯ Unix ã®ãƒãƒ‹ãƒ¥ã‚¢ãƒ« :manpage:`inet(3)` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:441
msgid ""
"If the IPv4 address string passed to this function is invalid, "
":exc:`socket.error` will be raised. Note that exactly what is valid depends "
"on the underlying C implementation of :c:func:`inet_aton`."
msgstr "IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹æ–‡å­—åˆ—ãŒä¸æ­£ã§ã‚ã‚Œã°ã€ :exc:`socket.error` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ã“ã®ãƒã‚§ãƒƒã‚¯ã¯ã€ã“ã®é–¢æ•°ã§ä½¿ç”¨ã—ã¦ã„ã‚‹Cã®å®Ÿè£… :c:func:`inet_aton` ã§è¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:445
msgid ""
":func:`inet_aton` does not support IPv6, and :func:`inet_pton` should be "
"used instead for IPv4/v6 dual stack support."
msgstr ":func:`inet_aton` ã¯ã€IPv6ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚IPv4/v6ã®ãƒ‡ãƒ¥ã‚¢ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã¯ :func:`inet_pton` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:451
msgid ""
"Convert a 32-bit packed IPv4 address (a string four characters in length) to"
" its standard dotted-quad string representation (for example, "
"'123.45.67.89').  This is useful when conversing with a program that uses "
"the standard C library and needs objects of type :c:type:`struct in_addr`, "
"which is the C type for the 32-bit packed binary data this function takes as"
" an argument."
msgstr "32ãƒ“ãƒƒãƒˆã«ãƒ‘ãƒƒã‚¯ã—ãŸãƒã‚¤ãƒŠãƒªå½¢å¼ã®IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ã€ãƒ‰ãƒƒãƒˆè¨˜æ³•ã«ã‚ˆã‚‹æ–‡å­—åˆ— (``'123.45.67.89'`` ãªã©)ã«å¤‰æ›ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ãŒè¿”ã™å€¤ã¯ã€æ¨™æº–Cãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® :c:type:`struct in_addr` å‹ã‚’ä½¿ç”¨ã™ã‚‹é–¢æ•°ã«æ¸¡ã™äº‹ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:457
msgid ""
"If the string passed to this function is not exactly 4 bytes in length, "
":exc:`socket.error` will be raised. :func:`inet_ntoa` does not support IPv6,"
" and :func:`inet_ntop` should be used instead for IPv4/v6 dual stack "
"support."
msgstr "ã“ã®é–¢æ•°ã«æ¸¡ã™æ–‡å­—åˆ—ã®é•·ã•ãŒ4ãƒã‚¤ãƒˆä»¥å¤–ã§ã‚ã‚Œã°ã€ :exc:`socket.error` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ :func:`inet_ntoa` ã¯ã€IPv6ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚IPv4/v6ã®ãƒ‡ãƒ¥ã‚¢ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã¯ :func:`inet_pton` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:464
msgid ""
"Convert an IP address from its family-specific string format to a packed, "
"binary format. :func:`inet_pton` is useful when a library or network "
"protocol calls for an object of type :c:type:`struct in_addr` (similar to "
":func:`inet_aton`) or :c:type:`struct in6_addr`."
msgstr "IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ã€ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªå›ºæœ‰ã®æ–‡å­—åˆ—ã‹ã‚‰ãƒ‘ãƒƒã‚¯ã—ãŸãƒã‚¤ãƒŠãƒªå½¢å¼ã«å¤‰æ›ã—ã¾ã™ã€‚ :func:`inet_pton` ã¯ã€ :c:type:`struct in_addr` å‹ (:func:`inet_aton` ã¨åŒæ§˜)ã‚„ :c:type:`struct in6_addr` ã‚’ä½¿ç”¨ã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å‘¼ã³å‡ºã™éš›ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:469
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and "
":const:`AF_INET6`. If the IP address string *ip_string* is invalid, "
":exc:`socket.error` will be raised. Note that exactly what is valid depends "
"on both the value of *address_family* and the underlying implementation of "
":c:func:`inet_pton`."
msgstr "ç¾åœ¨ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ *address_family* ã¯ã€ :const:`AF_INET` ã¨ :const:`AF_INET6` ã§ã™ã€‚ *ip_string* ã«ä¸æ­£ãªIPã‚¢ãƒ‰ãƒ¬ã‚¹æ–‡å­—åˆ—ã‚’æŒ‡å®šã™ã‚‹ã¨ã€ :exc:`socket.error` ãŒç™ºç”Ÿã—ã¾ã™ã€‚æœ‰åŠ¹ãª *ip_string* ã¯ã€ *address_family* ã¨ :c:func:`inet_pton` ã®å®Ÿè£…ã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:475 ../../library/socket.rst:493
msgid "Availability: Unix (maybe not all platforms)."
msgstr "åˆ©ç”¨å¯èƒ½: Unix (ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚‚ã‚ã‚Šã¾ã™)ã€‚"

#: ../../library/socket.rst:482
msgid ""
"Convert a packed IP address (a string of some number of characters) to its "
"standard, family-specific string representation (for example, ``'7.10.0.5'``"
" or ``'5aef:2b::8'``) :func:`inet_ntop` is useful when a library or network "
"protocol returns an object of type :c:type:`struct in_addr` (similar to "
":func:`inet_ntoa`) or :c:type:`struct in6_addr`."
msgstr "ãƒ‘ãƒƒã‚¯ã—ãŸIPã‚¢ãƒ‰ãƒ¬ã‚¹(æ•°æ–‡å­—ã®æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ)ã‚’ã€ ``'7.10.0.5'`` ã‚„ ``'5aef:2b::8'`` ãªã©ã®æ¨™æº–çš„ãªã€ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªå›ºæœ‰ã®æ–‡å­—åˆ—å½¢å¼ã«å¤‰æ›ã—ã¾ã™ã€‚ :func:`inet_ntop` ã¯(:func:`inet_ntoa` ã¨åŒæ§˜ã«) :c:type:`struct in_addr` å‹ã‚„ :c:type:`struct in6_addr` å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç­‰ã§ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:488
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and "
":const:`AF_INET6`. If the string *packed_ip* is not the correct length for "
"the specified address family, :exc:`ValueError` will be raised.  A "
":exc:`socket.error` is raised for errors from the call to :func:`inet_ntop`."
msgstr "ç¾åœ¨ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ *address_family* ã¯ã€ :const:`AF_INET` ã¨ :const:`AF_INET6` ã§ã™ã€‚ *packed_ip* ã®é•·ã•ãŒæŒ‡å®šã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã§é©åˆ‡ãªé•·ã•ã§ãªã‘ã‚Œã°ã€ :exc:`ValueError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ :func:`inet_ntop` ã§ã‚¨ãƒ©ãƒ¼ã¨ãªã‚‹ã¨ã€ :exc:`socket.error` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/socket.rst:500
msgid ""
"Return the default timeout in seconds (float) for new socket objects. A "
"value of ``None`` indicates that new socket objects have no timeout. When "
"the socket module is first imported, the default is ``None``."
msgstr "æ–°è¦ã«ç”Ÿæˆã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ã‚’æµ®å‹•å°æ•°ç‚¹å½¢å¼ã®ç§’æ•°ã§è¿”ã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ä½¿ç”¨ã—ãªã„å ´åˆã«ã¯ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚æœ€åˆã« socket ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸæ™‚ã®åˆæœŸå€¤ã¯ ``None`` ã§ã™ã€‚"

#: ../../library/socket.rst:509
msgid ""
"Set the default timeout in seconds (float) for new socket objects. A value "
"of ``None`` indicates that new socket objects have no timeout. When the "
"socket module is first imported, the default is ``None``."
msgstr "æ–°è¦ã«ç”Ÿæˆã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ã‚’æµ®å‹•å°æ•°ç‚¹å½¢å¼ã®ç§’æ•°ã§æŒ‡å®šã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ä½¿ç”¨ã—ãªã„å ´åˆã«ã¯ ``None`` ã‚’æŒ‡å®šã—ã¾ã™ã€‚æœ€åˆã« socket ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸæ™‚ã®åˆæœŸå€¤ã¯ ``None`` ã§ã™ã€‚"

#: ../../library/socket.rst:518
msgid ""
"This is a Python type object that represents the socket object type. It is "
"the same as ``type(socket(...))``."
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’ç¤ºã™å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚ ``type(socket(...))`` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/socket.rst:525
msgid "Module :mod:`SocketServer`"
msgstr ":mod:`SocketServer` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/socket.rst:525
msgid "Classes that simplify writing network servers."
msgstr "ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚µãƒ¼ãƒã®é–‹ç™ºã‚’çœåŠ›åŒ–ã™ã‚‹ãŸã‚ã®ã‚¯ãƒ©ã‚¹ç¾¤ã€‚"

#: ../../library/socket.rst:527
msgid "Module :mod:`ssl`"
msgstr "Module :mod:`ssl`"

#: ../../library/socket.rst:528
msgid "A TLS/SSL wrapper for socket objects."
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ TLS/SSL ãƒ©ãƒƒãƒ‘ãƒ¼."

#: ../../library/socket.rst:534
msgid "Socket Objects"
msgstr "socket ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/socket.rst:536
msgid ""
"Socket objects have the following methods.  Except for :meth:`makefile` "
"these correspond to Unix system calls applicable to sockets."
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¡ã¾ã™ã€‚ :meth:`makefile` ä»¥å¤–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€Unixã®ã‚½ã‚±ãƒƒãƒˆç”¨ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/socket.rst:542
msgid ""
"Accept a connection. The socket must be bound to an address and listening "
"for connections. The return value is a pair ``(conn, address)`` where *conn*"
" is a *new* socket object usable to send and receive data on the connection,"
" and *address* is the address bound to the socket on the other end of the "
"connection."
msgstr "æ¥ç¶šã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ã«bindæ¸ˆã¿ã§ã€listenä¸­ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ ``(conn, address)`` ã®ãƒšã‚¢ã§ã€ *conn* ã¯æ¥ç¶šã‚’é€šã˜ã¦ãƒ‡ãƒ¼ã‚¿ã®é€å—ä¿¡ã‚’è¡Œã†ãŸã‚ã® *æ–°ã—ã„* ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ *address* ã¯æ¥ç¶šå…ˆã§ã‚½ã‚±ãƒƒãƒˆã«bindã—ã¦ã„ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/socket.rst:550
msgid ""
"Bind the socket to *address*.  The socket must not already be bound. (The "
"format of *address* depends on the address family --- see above.)"
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚’ *address* ã«bindã—ã¾ã™ã€‚bindæ¸ˆã¿ã®ã‚½ã‚±ãƒƒãƒˆã‚’å†ãƒã‚¤ãƒ³ãƒ‰ã™ã‚‹äº‹ã¯ã§ãã¾ã›ã‚“ã€‚(*address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ -- å‰è¿°ã€‚)"

#: ../../library/socket.rst:555 ../../library/socket.rst:581
msgid ""
"This method has historically accepted a pair of parameters for "
":const:`AF_INET` addresses instead of only a tuple.  This was never "
"intentional and is no longer available in Python 2.0 and later."
msgstr "æœ¬æ¥ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å˜ä¸€ã®ã‚¿ãƒ—ãƒ«ã®ã¿ã‚’å¼•æ•°ã¨ã—ã¦å—ã‘ä»˜ã‘ã¾ã™ãŒã€ä»¥å‰ã¯ :const:`AF_INET` ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ç¤ºã™äºŒã¤ã®å€¤ã‚’æŒ‡å®šã™ã‚‹äº‹ãŒã§ãã¾ã—ãŸã€‚ã“ã‚Œã¯æœ¬æ¥ã®ä»•æ§˜ã§ã¯ãªãã€Python 2.0ä»¥é™ã§ã¯ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:562
msgid ""
"Close the socket.  All future operations on the socket object will fail. The"
" remote end will receive no more data (after queued data is flushed). "
"Sockets are automatically closed when they are garbage-collected."
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã™ã€‚ä»¥é™ã€ã“ã®ã‚½ã‚±ãƒƒãƒˆã§ã¯å…¨ã¦ã®æ“ä½œãŒå¤±æ•—ã—ã¾ã™ã€‚ãƒªãƒ¢ãƒ¼ãƒˆç«¯ç‚¹ã§ã¯ã‚­ãƒ¥ãƒ¼ã«æºœã¾ã£ãŸãƒ‡ãƒ¼ã‚¿ãŒãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸå¾Œã¯ãã‚Œä»¥ä¸Šã®ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã¾ã›ã‚“ã€‚ã‚½ã‚±ãƒƒãƒˆã¯ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æ™‚ã«è‡ªå‹•çš„ã«ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:568
msgid ""
":meth:`close()` releases the resource associated with a connection but does "
"not necessarily close the connection immediately.  If you want to close the "
"connection in a timely fashion, call :meth:`shutdown()` before "
":meth:`close()`."
msgstr ":meth:`close()` ã¯æ¥ç¶šã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ã‚’è§£æ”¾ã—ã¾ã™ãŒã€æ¥ç¶šã‚’ã™ãã«åˆ‡æ–­ã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚æ¥ç¶šã‚’å³åº§ã«åˆ‡æ–­ã—ãŸã„å ´åˆã¯ã€ :meth:`close()` ã®å‰ã« :meth:`shutdown()` ã‚’å‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:576
msgid ""
"Connect to a remote socket at *address*. (The format of *address* depends on"
" the address family --- see above.)"
msgstr "*address* ã§ç¤ºã•ã‚Œã‚‹ãƒªãƒ¢ãƒ¼ãƒˆã‚½ã‚±ãƒƒãƒˆã«æ¥ç¶šã—ã¾ã™ã€‚(*address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ --- å‰è¿°ã€‚)"

#: ../../library/socket.rst:588
msgid ""
"Like ``connect(address)``, but return an error indicator instead of raising "
"an exception for errors returned by the C-level :c:func:`connect` call "
"(other problems, such as \"host not found,\" can still raise exceptions).  "
"The error indicator is ``0`` if the operation succeeded, otherwise the value"
" of the :c:data:`errno` variable.  This is useful to support, for example, "
"asynchronous connects."
msgstr "``connect(address)`` ã¨åŒæ§˜ã§ã™ãŒã€Cè¨€èªã® :c:func:`connect` é–¢æ•°ã®å‘¼ã³å‡ºã—ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’é€å‡ºã›ãšã«ã‚¨ãƒ©ãƒ¼ã‚’æˆ»ã‚Šå€¤ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚(ã“ã‚Œä»¥å¤–ã®ã€\"host not found,\"ç­‰ã®ã‚¨ãƒ©ãƒ¼ã®å ´åˆã«ã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚)å‡¦ç†ãŒæ­£å¸¸ã«çµ‚äº†ã—ãŸå ´åˆã«ã¯ ``0`` ã‚’è¿”ã—ã€ã‚¨ãƒ©ãƒ¼æ™‚ã«ã¯ :c:data:`errno` ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã€éåŒæœŸæ¥ç¶šã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆãªã©ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:597
msgid ""
"This method has historically accepted a pair of parameters for "
":const:`AF_INET` addresses instead of only a tuple. This was never "
"intentional and is no longer available in Python 2.0 and later."
msgstr "æœ¬æ¥ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å˜ä¸€ã®ã‚¿ãƒ—ãƒ«ã®ã¿ã‚’å¼•æ•°ã¨ã—ã¦å—ã‘ä»˜ã‘ã¾ã™ãŒã€ä»¥å‰ã¯ :const:`AF_INET` ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ç¤ºã™äºŒã¤ã®å€¤ã‚’æŒ‡å®šã™ã‚‹äº‹ãŒã§ãã¾ã—ãŸã€‚ã“ã‚Œã¯æœ¬æ¥ã®ä»•æ§˜ã§ã¯ãªãã€Python 2.0ä»¥é™ã§ã¯ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:604
msgid ""
"Return the socket's file descriptor (a small integer).  This is useful with "
":func:`select.select`."
msgstr "ã‚½ã‚±ãƒƒãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’æ•´æ•°å‹ã§è¿”ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã¯ã€ :func:`select.select` ãªã©ã§ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:607
msgid ""
"Under Windows the small integer returned by this method cannot be used where"
" a file descriptor can be used (such as :func:`os.fdopen`).  Unix does not "
"have this limitation."
msgstr "Windowsã§ã¯ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§è¿”ã•ã‚ŒãŸå°æ•´æ•°ã‚’ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’æ‰±ã†ç®‡æ‰€ (:func:`os.fdopen` ãªã©) ã§åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚ Unix ã«ã¯ã“ã®åˆ¶é™ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:614
msgid ""
"Return the remote address to which the socket is connected.  This is useful "
"to find out the port number of a remote IPv4/v6 socket, for instance. (The "
"format of the address returned depends on the address family --- see above.)"
"  On some systems this function is not supported."
msgstr "ã‚½ã‚±ãƒƒãƒˆãŒæ¥ç¶šã—ã¦ã„ã‚‹ãƒªãƒ¢ãƒ¼ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã€ãƒªãƒ¢ãƒ¼ãƒˆ IPv4/v6ã‚½ã‚±ãƒƒãƒˆã®ãƒãƒ¼ãƒˆç•ªå·ã‚’èª¿ã¹ã‚‹å ´åˆãªã©ã«ä½¿ç”¨ã—ã¾ã™ã€‚ *address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™(å‰è¿°)ã€‚ã“ã®é–¢æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã‚·ã‚¹ãƒ†ãƒ ã‚‚å­˜åœ¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:622
msgid ""
"Return the socket's own address.  This is useful to find out the port number"
" of an IPv4/v6 socket, for instance. (The format of the address returned "
"depends on the address family --- see above.)"
msgstr "ã‚½ã‚±ãƒƒãƒˆè‡ªèº«ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã€IPv4/v6ã‚½ã‚±ãƒƒãƒˆã®ãƒãƒ¼ãƒˆç•ªå·ã‚’èª¿ã¹ã‚‹å ´åˆãªã©ã«ä½¿ç”¨ã—ã¾ã™ã€‚(*address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ --- å‰è¿°ã€‚)"

#: ../../library/socket.rst:629
msgid ""
"Return the value of the given socket option (see the Unix man page "
":manpage:`getsockopt(2)`).  The needed symbolic constants (:const:`SO_\\*` "
"etc.) are defined in this module.  If *buflen* is absent, an integer option "
"is assumed and its integer value is returned by the function.  If *buflen* "
"is present, it specifies the maximum length of the buffer used to receive "
"the option in, and this buffer is returned as a string.  It is up to the "
"caller to decode the contents of the buffer (see the optional built-in "
"module :mod:`struct` for a way to decode C structures encoded as strings)."
msgstr "ã‚½ã‚±ãƒƒãƒˆã«æŒ‡å®šã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿”ã—ã¾ã™(Unixã®ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ :manpage:`getsockopt(2)` ã‚’å‚ç…§)ã€‚ :const:`SO_\\*` ç­‰ã®ã‚·ãƒ³ãƒœãƒ«ã¯ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ *buflen* ã‚’çœç•¥ã—ãŸå ´åˆã€å–å¾—ã™ã‚‹ã‚ªãƒ–ã‚·ãƒ§ãƒ³ã¯æ•´æ•°ã¨ã¿ãªã—ã€æ•´æ•°å‹ã®å€¤ã‚’æˆ»ã‚Šå€¤ã¨ã—ã¾ã™ã€‚ *buflen* ã‚’æŒ‡å®šã—ãŸå ´åˆã€é•·ã• *buflen* ã®ãƒãƒƒãƒ•ã‚¡ã§ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’å—ã‘å–ã‚Šã€ã“ã®ãƒãƒƒãƒ•ã‚¡ã‚’æ–‡å­—åˆ—ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ã“ã®ãƒãƒƒãƒ•ã‚¡ã¯ã€å‘¼ã³å‡ºã—å…ƒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ :mod:`struct` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç­‰ã‚’åˆ©ç”¨ã—ã¦å†…å®¹ã‚’èª­ã¿å–ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:0
msgid "platform"
msgstr "ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ "

#: ../../library/socket.rst:641
msgid "Windows"
msgstr "Windows"

#: ../../library/socket.rst:643
msgid ""
"The :meth:`ioctl` method is a limited interface to the WSAIoctl system "
"interface.  Please refer to the `Win32 documentation "
"<https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx>`_ for "
"more information."
msgstr ":meth:`ioctl` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ WSAIoctl ã‚·ã‚¹ãƒ†ãƒ ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¸ã®åˆ¶é™ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§ã™ã€‚è©³ã—ã„æƒ…å ±ã«ã¤ã„ã¦ã¯ã€ `Win32 documentation <https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx>`_ ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:648
msgid ""
"On other platforms, the generic :func:`fcntl.fcntl` and :func:`fcntl.ioctl` "
"functions may be used; they accept a socket object as their first argument."
msgstr "ä»–ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ä¸€èˆ¬çš„ãª :func:`fcntl.fcntl` ã¨ :func:`fcntl.ioctl` ãŒä½¿ã‚ã‚Œã‚‹ã§ã—ã‚‡ã†; ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ç¬¬ 1 å¼•æ•°ã¨ã—ã¦ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:656
msgid ""
"Listen for connections made to the socket.  The *backlog* argument specifies"
" the maximum number of queued connections and should be at least 0; the "
"maximum value is system-dependent (usually 5), the minimum value is forced "
"to 0."
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚’Listenã—ã€æ¥ç¶šã‚’å¾…ã¡ã¾ã™ã€‚å¼•æ•° *backlog* ã«ã¯æ¥ç¶šã‚­ãƒ¥ãƒ¼ã®æœ€å¤§ã®é•·ã•(0ä»¥ä¸Š)ã‚’æŒ‡å®šã—ã¾ã™ã€‚ *backlog* ã®æœ€å¤§æ•°ã¯ã‚·ã‚¹ãƒ†ãƒ ã«ä¾å­˜ã—ã¾ã™ (é€šå¸¸ã¯5)ã€‚æœ€å°å€¤ã¯å¿…ãš 0 ã§ã™ã€‚"

#: ../../library/socket.rst:665
msgid ""
"Return a :dfn:`file object` associated with the socket.  (File objects are "
"described in :ref:`bltin-file-objects`.) The file object does not close the "
"socket explicitly when its :meth:`close` method is called, but only removes "
"its reference to the socket object, so that the socket will be closed if it "
"is not referenced from anywhere else."
msgstr "ã‚½ã‚±ãƒƒãƒˆã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸ :dfn:`ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ` ã‚’è¿”ã—ã¾ã™ (ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã¯ :ref:`bltin-file-objects` ã‚’å‚ç…§)ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã® :meth:`close` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚ŒãŸéš›ã‚‚ã‚½ã‚±ãƒƒãƒˆã‚’æ˜ç¤ºçš„ã«ã‚¯ãƒ­ãƒ¼ã‚ºã›ãšã«ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’å‰Šé™¤ã™ã‚‹ã ã‘ã§ã™ã€‚ã“ã®ãŸã‚ã€ã‚½ã‚±ãƒƒãƒˆã¯ã€ã©ã“ã‹ã‚‰ã‚‚å‚ç…§ã•ã‚Œãªããªã£ã¦ã‹ã‚‰ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:671
msgid ""
"The socket must be in blocking mode (it can not have a timeout). The "
"optional *mode* and *bufsize* arguments are interpreted the same way as by "
"the built-in :func:`file` function."
msgstr "ã‚½ã‚±ãƒƒãƒˆã¯ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“(ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã›ã‚“)ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•°ã® *mode* ã¨ *bufsize* ã«ã¯ã€ :func:`file` çµ„ã¿è¾¼ã¿é–¢æ•°ã¨åŒã˜å€¤ã‚’æŒ‡å®šã—ã¾ã™ã€‚"

#: ../../library/socket.rst:677
msgid ""
"On Windows, the file-like object created by :meth:`makefile` cannot be used "
"where a file object with a file descriptor is expected, such as the stream "
"arguments of :meth:`subprocess.Popen`."
msgstr "Windows ã§ã¯ã€ :meth:`makefile` ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã‚‹ file-like ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ :meth:`subprocess.Popen` ãªã©ã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã®ã‚ã‚‹ file ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æœŸå¾…ã—ã¦ã„ã‚‹å ´æ‰€ã§åˆ©ç”¨ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:684
msgid ""
"Receive data from the socket.  The return value is a string representing the"
" data received.  The maximum amount of data to be received at once is "
"specified by *bufsize*.  See the Unix manual page :manpage:`recv(2)` for the"
" meaning of the optional argument *flags*; it defaults to zero."
msgstr "ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã€æ–‡å­—åˆ—ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚å—ä¿¡ã™ã‚‹æœ€å¤§ãƒã‚¤ãƒˆæ•°ã¯ã€ *bufsize* ã§æŒ‡å®šã—ã¾ã™ã€‚ *flags* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯0ã§ã™ã€‚å€¤ã®æ„å‘³ã«ã¤ã„ã¦ã¯Unixãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ã® :manpage:`recv(2)` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:691
msgid ""
"For best match with hardware and network realities, the value of  *bufsize* "
"should be a relatively small power of 2, for example, 4096."
msgstr "ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãŠã‚ˆã³ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ç¾å®Ÿã«æœ€å¤§é™ãƒãƒƒãƒã™ã‚‹ã‚ˆã†ã«ã€ *bufsize* ã®å€¤ã¯æ¯”è¼ƒçš„å°ã•ã„2ã®ç´¯ä¹—ã€ãŸã¨ãˆã° 4096ã€ã«ã™ã¹ãã§ã™ã€‚"

#: ../../library/socket.rst:697
msgid ""
"Receive data from the socket.  The return value is a pair ``(string, "
"address)`` where *string* is a string representing the data received and "
"*address* is the address of the socket sending the data.  See the Unix "
"manual page :manpage:`recv(2)` for the meaning of the optional argument "
"*flags*; it defaults to zero. (The format of *address* depends on the "
"address family --- see above.)"
msgstr "ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã€çµæœã‚’ã‚¿ãƒ—ãƒ« ``(string, address)`` ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ *string* ã¯å—ä¿¡ãƒ‡ãƒ¼ã‚¿ã®æ–‡å­—åˆ—ã§ã€ *address* ã¯é€ä¿¡å…ƒã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ç¤ºã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *flags* ã«ã¤ã„ã¦ã¯ã€ Unix ã®ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ :manpage:`recv(2)` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯0ã§ã™ã€‚ (*address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™(å‰è¿°))"

#: ../../library/socket.rst:706
msgid ""
"Receive data from the socket, writing it into *buffer* instead of  creating "
"a new string.  The return value is a pair ``(nbytes, address)`` where "
"*nbytes* is the number of bytes received and *address* is the address of the"
" socket sending the data.  See the Unix manual page :manpage:`recv(2)` for "
"the meaning of the optional argument *flags*; it defaults to zero.  (The "
"format of *address* depends on the address family --- see above.)"
msgstr "ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã€ãã®ãƒ‡ãƒ¼ã‚¿ã‚’æ–°ã—ã„æ–‡å­—åˆ—ã¨ã—ã¦è¿”ã™ä»£ã‚ã‚Šã« *buffer* ã«æ›¸ãã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ ``(nbytes, address)`` ã®ãƒšã‚¢ã§ã€ *nbytes* ã¯å—ä¿¡ã—ãŸãƒ‡ãƒ¼ã‚¿ã®ãƒã‚¤ãƒˆæ•°ã‚’ã€ *address* ã¯ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ãŸã‚½ã‚±ãƒƒãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *flags* (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ:0) ã®æ„å‘³ã«ã¤ã„ã¦ã¯ã€ Unix ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ :manpage:`recv(2)` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚(*address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯å‰è¿°ã®ã¨ãŠã‚Šã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã«ä¾å­˜ã—ã¾ã™ã€‚)"

#: ../../library/socket.rst:718
msgid ""
"Receive up to *nbytes* bytes from the socket, storing the data into a buffer"
" rather than creating a new string.  If *nbytes* is not specified (or 0), "
"receive up to the size available in the given buffer.  Returns the number of"
" bytes received.  See the Unix manual page :manpage:`recv(2)` for the "
"meaning of the optional argument *flags*; it defaults to zero."
msgstr "*nbytes* ãƒã‚¤ãƒˆã¾ã§ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰å—ä¿¡ã—ã¦ã€ãã®ãƒ‡ãƒ¼ã‚¿ã‚’æ–°ã—ã„æ–‡å­—åˆ—ã«ã™ã‚‹ã®ã§ã¯ãªã *buffer* ã«ä¿å­˜ã—ã¾ã™ã€‚ *nbytes* ãŒæŒ‡å®šã•ã‚Œãªã„(ã‚ã‚‹ã„ã¯0ãŒæŒ‡å®šã•ã‚ŒãŸ)å ´åˆã€ *buffer* ã®åˆ©ç”¨å¯èƒ½ãªã‚µã‚¤ã‚ºã¾ã§å—ä¿¡ã—ã¾ã™ã€‚å—ä¿¡ã—ãŸãƒã‚¤ãƒˆæ•°ã‚’è¿”ã‚Šå€¤ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *flags* (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ:0) ã®æ„å‘³ã«ã¤ã„ã¦ã¯ã€ Unix ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ :manpage:`recv(2)` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:729
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Returns the number of bytes sent. Applications are responsible for "
"checking that all data has been sent; if only some of the data was "
"transmitted, the application needs to attempt delivery of the remaining "
"data. For further information on this concept, consult the :ref:`socket-"
"howto`."
msgstr "ã‚½ã‚±ãƒƒãƒˆã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã¯ãƒªãƒ¢ãƒ¼ãƒˆã‚½ã‚±ãƒƒãƒˆã«æ¥ç¶šæ¸ˆã¿ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *flags* ã®æ„å‘³ã¯ã€ä¸Šè¨˜ :meth:`recv` ã¨åŒã˜ã§ã™ã€‚æˆ»ã‚Šå€¤ã¨ã—ã¦ã€é€ä¿¡ã—ãŸãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€å¿…ãšæˆ»ã‚Šå€¤ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿ãŒé€ã‚‰ã‚ŒãŸäº‹ã‚’ç¢ºèªã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ã®ä¸€éƒ¨ã ã‘ãŒé€ä¿¡ã•ã‚ŒãŸå ´åˆã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§æ®‹ã‚Šã®ãƒ‡ãƒ¼ã‚¿ã‚’å†é€ä¿¡ã—ã¦ãã ã•ã„ã€‚ :ref:`ã‚½ã‚±ãƒƒãƒˆãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°HOWTO <socket-howto>` ã«ã€ã•ã‚‰ã«è©³ã—ã„æƒ…å ±ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:739
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Unlike :meth:`send`, this method continues to send data from *string*"
" until either all data has been sent or an error occurs.  ``None`` is "
"returned on success.  On error, an exception is raised, and there is no way "
"to determine how much data, if any, was successfully sent."
msgstr "ã‚½ã‚±ãƒƒãƒˆã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã¯ãƒªãƒ¢ãƒ¼ãƒˆã‚½ã‚±ãƒƒãƒˆã«æ¥ç¶šæ¸ˆã¿ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *flags* ã®æ„å‘³ã¯ã€ä¸Šè¨˜ :meth:`recv` ã¨åŒã˜ã§ã™ã€‚ :meth:`send` ã¨ç•°ãªã‚Šã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ *string* ã®å…¨ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã™ã‚‹ã‹ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã¾ã§å‡¦ç†ã‚’ç¶™ç¶šã—ã¾ã™ã€‚æ­£å¸¸çµ‚äº†ã®å ´åˆã¯ ``None`` ã‚’è¿”ã—ã€ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã«ã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã€é€ä¿¡ã•ã‚ŒãŸãƒã‚¤ãƒˆæ•°ã‚’èª¿ã¹ã‚‹äº‹ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:750
msgid ""
"Send data to the socket.  The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*.  The "
"optional *flags* argument has the same meaning as for :meth:`recv` above.  "
"Return the number of bytes sent. (The format of *address* depends on the "
"address family --- see above.)"
msgstr "ã‚½ã‚±ãƒƒãƒˆã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯æ¥ç¶šå…ˆã‚’ *address* ã§æŒ‡å®šã™ã‚‹ã®ã§ã€æ¥ç¶šæ¸ˆã¿ã§ã¯ã„ã‘ã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *flags* ã®æ„å‘³ã¯ã€ä¸Šè¨˜ :meth:`recv` ã¨åŒã˜ã§ã™ã€‚æˆ»ã‚Šå€¤ã¨ã—ã¦ã€é€ä¿¡ã—ãŸãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ã€‚(*address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ --- å‰è¿°ã€‚)"

#: ../../library/socket.rst:759
msgid ""
"Set blocking or non-blocking mode of the socket: if *flag* is 0, the socket "
"is set to non-blocking, else to blocking mode.  Initially all sockets are in"
" blocking mode.  In non-blocking mode, if a :meth:`recv` call doesn't find "
"any data, or if a :meth:`send` call can't immediately dispose of the data, "
"an :exc:`error` exception is raised; in blocking mode, the calls block until"
" they can proceed. ``s.setblocking(0)`` is equivalent to "
"``s.settimeout(0.0)``; ``s.setblocking(1)`` is equivalent to "
"``s.settimeout(None)``."
msgstr "ã‚½ã‚±ãƒƒãƒˆã®ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ»éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚ *flag* ãŒ0 ã®å ´åˆã¯éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã€0ä»¥å¤–ã®å ´åˆã¯ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã¨ãªã‚Šã¾ã™ã€‚å…¨ã¦ã®ã‚½ã‚±ãƒƒãƒˆã¯ã€åˆæœŸçŠ¶æ…‹ã§ã¯ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã™ã€‚éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€ :meth:`recv` ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—æ™‚ã«èª­ã¿è¾¼ã¿ãƒ‡ãƒ¼ã‚¿ãŒç„¡ã‹ã£ãŸã‚Š :meth:`send` ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—æ™‚ã«ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ã™ã‚‹äº‹ãŒã§ããªã„ã‚ˆã†ãªå ´åˆã« :exc:`error` ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚ã—ã‹ã—ã€ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã¯å‘¼ã³å‡ºã—ã¯å‡¦ç†ãŒè¡Œã‚ã‚Œã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚ ``s.setblocking(0)`` ã¯ ``s.settimeout(0.0)`` ã¨ã€ ``s.setblocking(1)`` ã¯ ``s.settimeout(None)`` ã¨ãã‚Œãã‚ŒåŒã˜æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/socket.rst:770
msgid ""
"Set a timeout on blocking socket operations.  The *value* argument can be a "
"nonnegative float expressing seconds, or ``None``. If a float is given, "
"subsequent socket operations will raise a :exc:`timeout` exception if the "
"timeout period *value* has elapsed before the operation has completed.  "
"Setting a timeout of ``None`` disables timeouts on socket operations. "
"``s.settimeout(0.0)`` is equivalent to ``s.setblocking(0)``; "
"``s.settimeout(None)`` is equivalent to ``s.setblocking(1)``."
msgstr "ã‚½ã‚±ãƒƒãƒˆã®ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°å‡¦ç†ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ã‚’æŒ‡å®šã—ã¾ã™ã€‚ *value* ã«ã¯ã€æ­£ã®æµ®å‹•å°æ•°ç‚¹ã§ç§’æ•°ã‚’æŒ‡å®šã™ã‚‹ã‹ã€ã‚‚ã—ãã¯ ``None`` ã‚’æŒ‡å®šã—ã¾ã™ã€‚æµ®å‹•å°æ•°ç‚¹å€¤ã‚’æŒ‡å®šã—ãŸå ´åˆã€æ“ä½œãŒå®Œäº†ã™ã‚‹å‰ã« *value* ã§æŒ‡å®šã—ãŸç§’æ•°ãŒçµŒéã™ã‚‹ã¨ :exc:`timeout` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ã« ``None`` ã‚’æŒ‡å®šã™ã‚‹ã¨ã€ã‚½ã‚±ãƒƒãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ç„¡åŠ¹ã«ã—ã¾ã™ã€‚ ``s.settimeout(0.0)`` ã¯ ``s.setblocking(0)`` ã¨ã€ ``s.settimeout(None)`` ã¯ ``s.setblocking(1)`` ã¨ãã‚Œãã‚ŒåŒã˜æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/socket.rst:783
msgid ""
"Return the timeout in seconds (float) associated with socket operations, or "
"``None`` if no timeout is set.  This reflects the last call to "
":meth:`setblocking` or :meth:`settimeout`."
msgstr "ã‚½ã‚±ãƒƒãƒˆã«æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ã‚’å–å¾—ã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯æµ®å‹•å°æ•°ç‚¹å‹ã§ç§’æ•°ãŒã€è¨­å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã° ``None`` ãŒè¿”ã‚Šã¾ã™ã€‚ã“ã®å€¤ã¯ã€æœ€å¾Œã«å‘¼ã³å‡ºã•ã‚ŒãŸ :meth:`setblocking` ã¾ãŸã¯ :meth:`settimeout` ã«ã‚ˆã£ã¦è¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:789
msgid ""
"Some notes on socket blocking and timeouts: A socket object can be in one of"
" three modes: blocking, non-blocking, or timeout.  Sockets are always "
"created in blocking mode.  In blocking mode, operations block until complete"
" or the system returns an error (such as connection timed out).  In non-"
"blocking mode, operations fail (with an error that is unfortunately system-"
"dependent) if they cannot be completed immediately.  In timeout mode, "
"operations fail if they cannot be completed within the timeout specified for"
" the socket or if the system returns an error.  The "
":meth:`~socket.setblocking` method is simply a shorthand for certain "
":meth:`~socket.settimeout` calls."
msgstr "ã‚½ã‚±ãƒƒãƒˆã®ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã¨ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã«ã¤ã„ã¦: ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¢ãƒ¼ãƒ‰ã¯ã€ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ»éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ»ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®ä½•ã‚Œã‹ã¨ãªã‚Šã¾ã™ã€‚åˆæœŸçŠ¶æ…‹ã§ã¯å¸¸ã«ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã™ã€‚ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€å‡¦ç†ãŒå®Œäº†ã™ã‚‹ã¾ã§ã€ã‚‚ã—ãã¯ã‚·ã‚¹ãƒ†ãƒ ãŒ (æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãªã©ã®) ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€å‡¦ç†ã‚’è¡Œã†äº‹ãŒã§ããªã‘ã‚Œã°(ä¸å¹¸ã«ã‚‚ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ç•°ãªã‚‹å€¤ã®)ã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã¾ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€ã‚½ã‚±ãƒƒãƒˆã«æŒ‡å®šã—ãŸã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¾ã§ã€ã‚‚ã—ãã¯ã‚·ã‚¹ãƒ†ãƒ ãŒã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã¾ã§ã«å®Œäº†ã—ãªã‘ã‚Œã°å‡¦ç†ã¯å¤±æ•—ã¨ãªã‚Šã¾ã™ã€‚ :meth:`~socket.setblocking` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ :meth:`~socket.settimeout` ã®çœç•¥å½¢å¼ã§ã™ã€‚"

#: ../../library/socket.rst:799
msgid ""
"Timeout mode internally sets the socket in non-blocking mode.  The blocking "
"and timeout modes are shared between file descriptors and socket objects "
"that refer to the same network endpoint.  A consequence of this is that file"
" objects returned by the :meth:`~socket.makefile` method must only be used "
"when the socket is in blocking mode; in timeout or non-blocking mode file "
"operations that cannot be completed immediately will fail."
msgstr "å†…éƒ¨çš„ã«ã¯ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã¯ã‚½ã‚±ãƒƒãƒˆã‚’éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã«è¨­å®šã—ã¾ã™ã€‚ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã¨ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®è¨­å®šã¯ã€ã‚½ã‚±ãƒƒãƒˆã¨åŒã˜ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç«¯ç‚¹ã¸æ¥ç¶šã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã«ã‚‚åæ˜ ã•ã‚Œã¾ã™ã€‚ã“ã®çµæœã€ :meth:`~socket.makefile` ã§ä½œæˆã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã®ã¿ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã¨ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€å³åº§ã«å®Œäº†ã—ãªã„ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã¯ã‚¨ãƒ©ãƒ¼ã¨ãªã‚‹ãŸã‚ã§ã™ã€‚"

#: ../../library/socket.rst:806
msgid ""
"Note that the :meth:`~socket.connect` operation is subject to the timeout "
"setting, and in general it is recommended to call :meth:`~socket.settimeout`"
" before calling :meth:`~socket.connect` or pass a timeout parameter to "
":meth:`create_connection`.  The system network stack may return a connection"
" timeout error of its own regardless of any Python socket timeout setting."
msgstr "è¨»: :meth:`~socket.connect` ã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šã«å¾“ã„ã¾ã™ã€‚ä¸€èˆ¬çš„ã«ã€ :meth:`~socket.settimeout` ã‚’ :meth:`~socket.connect` ã®å‰ã«å‘¼ã¶ã‹ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ã‚’ :meth:`create_connection` ã«æ¸¡ã™ã“ã¨ã‚’ãŠã™ã™ã‚ã—ã¾ã™ã€‚ã‚·ã‚¹ãƒ†ãƒ ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ã‚¿ãƒƒã‚¯ã¯ Python ã®ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®è¨­å®šã‚’ç„¡è¦–ã—ã¦ã€è‡ªèº«ã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:817
msgid ""
"Set the value of the given socket option (see the Unix manual page "
":manpage:`setsockopt(2)`).  The needed symbolic constants are defined in the"
" :mod:`socket` module (:const:`SO_\\*` etc.).  The value can be an integer "
"or a string representing a buffer.  In the latter case it is up to the "
"caller to ensure that the string contains the proper bits (see the optional "
"built-in module :mod:`struct` for a way to encode C structures as strings)."
msgstr "ã‚½ã‚±ãƒƒãƒˆã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¨­å®šã—ã¾ã™(Unixã®ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ :manpage:`setsockopt(2)` ã‚’å‚ç…§)ã€‚ :const:`SO_\\*` ç­‰ã®ã‚·ãƒ³ãƒœãƒ«ã¯ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ ``value`` ã«ã¯ã€æ•´æ•°ã¾ãŸã¯æ–‡å­—åˆ—ã‚’ãƒãƒƒãƒ•ã‚¡ã¨ã—ã¦æŒ‡å®šã™ã‚‹äº‹ãŒã§ãã¾ã™ã€‚æ–‡å­—åˆ—ã‚’æŒ‡å®šã™ã‚‹å ´åˆã€æ–‡å­—åˆ—ã«ã¯é©åˆ‡ãªãƒ“ãƒƒãƒˆã‚’è¨­å®šã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚(:mod:`struct` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆ©ç”¨ã™ã‚Œã°ã€Cã®æ§‹é€ ä½“ã‚’æ–‡å­—åˆ—ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹äº‹ãŒã§ãã¾ã™ã€‚)"

#: ../../library/socket.rst:827
msgid ""
"Shut down one or both halves of the connection.  If *how* is "
":const:`SHUT_RD`, further receives are disallowed.  If *how* is "
":const:`SHUT_WR`, further sends are disallowed.  If *how* is "
":const:`SHUT_RDWR`, further sends and receives are disallowed.  Depending on"
" the platform, shutting down one half of the connection can also close the "
"opposite half (e.g. on Mac OS X, ``shutdown(SHUT_WR)`` does not allow "
"further reads on the other end of the connection)."
msgstr "æ¥ç¶šã®ç‰‡æ–¹å‘ã€ã¾ãŸã¯ä¸¡æ–¹å‘ã‚’åˆ‡æ–­ã—ã¾ã™ã€‚ *how* ãŒ :const:`SHUT_RD` ã®å ´åˆã€ä»¥é™ã¯å—ä¿¡ã‚’è¡Œãˆã¾ã›ã‚“ã€‚ *how* ãŒ :const:`SHUT_WR` ã®å ´åˆã€ä»¥é™ã¯é€ä¿¡ã‚’è¡Œãˆã¾ã›ã‚“ã€‚ *how* ãŒ ``SHUT_RDWR`` ã®å ´åˆã€ä»¥é™ã¯é€å—ä¿¡ã‚’è¡Œãˆã¾ã›ã‚“ã€‚ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ã‚ˆã£ã¦ã¯ã€æ¥ç¶šã®ç‰‡æ–¹å‘ã‚’ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã™ã‚‹ã¨ç›¸æ‰‹å´ã‚‚é–‰ã˜ã‚‰ã‚Œã¾ã™ã€‚(ä¾‹ãˆã°ã€ Mac OS X ã§ã¯ã€ ``shutdown(SHUT_WR)`` ã‚’ã™ã‚‹ã¨ã€æ¥ç¶šã®ç›¸æ‰‹å´ã¯ã‚‚ã† read ãŒã§ããªããªã‚Šã¾ã™)"

#: ../../library/socket.rst:834
msgid ""
"Note that there are no methods :meth:`read` or :meth:`write`; use "
":meth:`~socket.recv` and :meth:`~socket.send` without *flags* argument "
"instead."
msgstr ":meth:`read` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ :meth:`write` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ä»£ã‚ã‚Šã« *flags* ã‚’çœç•¥ã—ãŸ :meth:`~socket.recv` ã¨ :meth:`~socket.send` ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:837
msgid ""
"Socket objects also have these (read-only) attributes that correspond to the"
" values given to the :class:`~socket.socket` constructor."
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ä»¥ä¸‹ã® :class:`~socket.socket` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«æ¸¡ã•ã‚ŒãŸå€¤ã«å¯¾å¿œã—ãŸ (èª­ã¿å‡ºã—å°‚ç”¨) å±æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:843
msgid "The socket family."
msgstr "ã‚½ã‚±ãƒƒãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼ã€‚"

#: ../../library/socket.rst:850
msgid "The socket type."
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã€‚"

#: ../../library/socket.rst:857
msgid "The socket protocol."
msgstr "ã‚½ã‚±ãƒƒãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ«ã€‚"

#: ../../library/socket.rst:865
msgid "Example"
msgstr "ä¾‹"

#: ../../library/socket.rst:867
msgid ""
"Here are four minimal example programs using the TCP/IP protocol: a server "
"that echoes all data that it receives back (servicing only one client), and "
"a client using it.  Note that a server must perform the sequence "
":func:`.socket`, :meth:`~socket.bind`, :meth:`~socket.listen`, "
":meth:`~socket.accept` (possibly repeating the :meth:`~socket.accept` to "
"service more than one client), while a client only needs the sequence "
":func:`.socket`, :meth:`~socket.connect`.  Also note that the server does "
"not :meth:`~socket.sendall`/:meth:`~socket.recv` on the socket it is "
"listening on but on the new socket returned by :meth:`~socket.accept`."
msgstr "ä»¥ä¸‹ã¯ TCP/IP ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ç°¡å˜ãªã‚µãƒ³ãƒ—ãƒ«ã¨ã—ã¦ã€å—ä¿¡ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ãã®ã¾ã¾è¿”é€ã™ã‚‹ã‚µãƒ¼ãƒ (æ¥ç¶šå¯èƒ½ãªã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ä¸€ä»¶ã®ã¿) ã¨ã€ã‚µãƒ¼ãƒã«æ¥ç¶šã™ã‚‹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚ã‚µãƒ¼ãƒã§ã¯ã€ :func:`.socket` ãƒ» :meth:`~socket.bind` ãƒ» :meth:`~socket.listen` ãƒ» :meth:`~socket.accept` ã‚’å®Ÿè¡Œã— (è¤‡æ•°ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®æ¥ç¶šã‚’å—ã‘ä»˜ã‘ã‚‹å ´åˆã€ :meth:`~socket.accept` ã‚’è¤‡æ•°å›å‘¼ã³å‡ºã—ã¾ã™)ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã¯ :func:`.socket` ã¨ :meth:`~socket.connect` ã ã‘ã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚ã‚µãƒ¼ãƒã§ã¯ :meth:`~socket.sendall` / :meth:`~socket.recv` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ listen ä¸­ã®ã‚½ã‚±ãƒƒãƒˆã§å®Ÿè¡Œã™ã‚‹ã®ã§ã¯ãªãã€ :meth:`~socket.accept` ã§å–å¾—ã—ãŸã‚½ã‚±ãƒƒãƒˆã«å¯¾ã—ã¦å®Ÿè¡Œã—ã¦ã„ã‚‹ç‚¹ã«ã‚‚æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:877
msgid "The first two examples support IPv4 only. ::"
msgstr "æ¬¡ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚µãƒ¼ãƒã¯ã€IPv4 ã®ã¿ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ ::"

#: ../../library/socket.rst:909
msgid ""
"The next two examples are identical to the above two, but support both IPv4 "
"and IPv6. The server side will listen to the first address family available "
"(it should listen to both instead). On most of IPv6-ready systems, IPv6 will"
" take precedence and the server may not accept IPv4 traffic. The client side"
" will try to connect to the all addresses returned as a result of the name "
"resolution, and sends traffic to the first one connected successfully. ::"
msgstr "æ¬¡ã®ã‚µãƒ³ãƒ—ãƒ«ã¯ä¸Šè¨˜ã®ã‚µãƒ³ãƒ—ãƒ«ã¨ã»ã¨ã‚“ã©åŒã˜ã§ã™ãŒã€IPv4 ã¨ IPv6 ã®ä¸¡æ–¹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã‚µãƒ¼ãƒã§ã¯ã€IPv4/v6 ã®ä¸¡æ–¹ã§ã¯ãªãã€åˆ©ç”¨å¯èƒ½ãªæœ€åˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã ã‘ã‚’ listen ã—ã¦ã„ã¾ã™ã€‚ã»ã¨ã‚“ã©ã® IPv6 å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ ã§ã¯ IPv6 ãŒå…ˆã«ç¾ã‚Œã‚‹ãŸã‚ã€ã‚µãƒ¼ãƒã¯ IPv4 ã«ã¯å¿œç­”ã—ã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã¯åå‰è§£æ±ºã®çµæœã¨ã—ã¦å–å¾—ã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã«é †æ¬¡æ¥ç¶šã‚’è©¦ã¿ã€æœ€åˆã«æ¥ç¶šã«æˆåŠŸã—ãŸã‚½ã‚±ãƒƒãƒˆã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¦ã„ã¾ã™ã€‚ ::"

#: ../../library/socket.rst:982
msgid ""
"The last example shows how to write a very simple network sniffer with raw "
"sockets on Windows. The example requires administrator privileges to modify "
"the interface::"
msgstr "æœ€å¾Œã®ä¾‹ã¯ã€Windowsã§ raw socket ã‚’åˆ©ç”¨ã—ã¦éå¸¸ã«ã‚·ãƒ³ãƒ—ãƒ«ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ãƒ‹ãƒ•ã‚¡ãƒ¼ã‚’æ›¸ãã¾ã™ã€‚ã“ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’å®Ÿè¡Œã™ã‚‹ã«ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ã€‚"

#: ../../library/socket.rst:1008
msgid ""
"Running an example several times with too small delay between executions, "
"could lead to this error::"
msgstr "ã“ã®ä¾‹ã®å®Ÿè¡Œã‚’ã€ã»ã¨ã‚“ã©é–“ã‚’ç©ºã‘ãšã«ä½•åº¦ã‚‚å®Ÿè¡Œã™ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“::"

#: ../../library/socket.rst:1013
msgid ""
"This is because the previous execution has left the socket in a "
"``TIME_WAIT`` state, and can't be immediately reused."
msgstr "ã“ã‚Œã¯ä»¥å‰ã®å®Ÿè¡ŒãŒã‚½ã‚±ãƒƒãƒˆã‚’ ``TIME_WAIT`` çŠ¶æ…‹ã®ã¾ã¾ã«ã—ã€ã™ãã«ã¯å†åˆ©ç”¨å‡ºæ¥ãªã„ã“ã¨ã§èµ·ã“ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:1016
msgid ""
"There is a :mod:`socket` flag to set, in order to prevent this, "
":data:`socket.SO_REUSEADDR`::"
msgstr "ã“ã‚Œã‚’é˜²ãã®ã«ã€ :mod:`socket` ãƒ•ãƒ©ã‚°ã® :data:`socket.SO_REUSEADDR` ãŒã‚ã‚Šã¾ã™::"

#: ../../library/socket.rst:1023
msgid ""
"the :data:`SO_REUSEADDR` flag tells the kernel to reuse a local socket in "
"``TIME_WAIT`` state, without waiting for its natural timeout to expire."
msgstr ":data:`SO_REUSEADDR` ãƒ•ãƒ©ã‚°ã¯ã€ ``TIME_WAIT`` çŠ¶æ…‹ã«ã‚ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«ã‚½ã‚±ãƒƒãƒˆã‚’ãã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæœŸé™ãŒè‡ªç„¶ã«åˆ‡ã‚Œã‚‹ã®ã‚’å¾…ã¤ã“ã¨ãªãå†åˆ©ç”¨ã™ã‚‹ã“ã¨ã‚’ã‚«ãƒ¼ãƒãƒ«ã«ä¼ãˆã¾ã™ã€‚"
