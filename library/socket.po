# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-29 13:58+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/socket.rst:2
msgid ":mod:`socket` --- Low-level networking interface"
msgstr ":mod:`socket` --- ä½æ°´æº–ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹"

#: ../../library/socket.rst:7
msgid "**Source code:** :source:`Lib/socket.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/socket.py`"

#: ../../library/socket.rst:11
msgid ""
"This module provides access to the BSD *socket* interface. It is available "
"on all modern Unix systems, Windows, MacOS, and probably additional "
"platforms."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯BSDã® *ã‚½ã‚±ãƒƒãƒˆ(socket)* "
"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€è¿‘ä»£çš„ãªUnixã‚·ã‚¹ãƒ†ãƒ ã€Windowsã€MacOSã€ãã®ä»–å¤šãã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§å‹•ä½œã—ã¾ã™ã€‚"

#: ../../library/socket.rst:16
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs."
msgstr "ã„ãã¤ã‹ã®æŒ™å‹•ã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ä¾å­˜ã—ã¾ã™ã€‚ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®ã‚½ã‚±ãƒƒãƒˆAPIã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ãŸã‚ã§ã™ã€‚"

#: ../../library/socket.rst:21
msgid ""
"The Python interface is a straightforward transliteration of the Unix system"
" call and library interface for sockets to Python's object-oriented style: "
"the :func:`.socket` function returns a :dfn:`socket object` whose methods "
"implement the various socket system calls.  Parameter types are somewhat "
"higher-level than in the C interface: as with :meth:`read` and :meth:`write`"
" operations on Python files, buffer allocation on receive operations is "
"automatic, and buffer length is implicit on send operations."
msgstr ""
"Pythonã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯ã€Unixã®ã‚½ã‚±ãƒƒãƒˆç”¨ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ã€ãã®ã¾ã¾Pythonã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã‚¹ã‚¿ã‚¤ãƒ«ã«å¤‰æ›ã—ãŸã‚‚ã®ã§ã™ã€‚å„ç¨®ã‚½ã‚±ãƒƒãƒˆé–¢é€£ã®ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã¯ã€"
" :func:`.socket` é–¢æ•°ã§ç”Ÿæˆã•ã‚Œã‚‹ :dfn:`socket ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚ ãƒ¡ã‚½ãƒƒãƒ‰ã®å¼•æ•°ã¯ C "
"ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚ˆã‚Šã‚‚å¤šå°‘é«˜æ°´æº–ã§ã€ä¾‹ãˆã°ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã™ã‚‹ :meth:`read` ã‚„ :meth:`write` ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒæ§˜ã«ã€ "
"å—ä¿¡æ™‚ã®ãƒãƒƒãƒ•ã‚¡ç¢ºä¿ã¯è‡ªå‹•çš„ã«å‡¦ç†ã•ã‚Œã€é€ä¿¡æ™‚ã®ãƒãƒƒãƒ•ã‚¡é•·ã¯æš—é»™çš„ã«æ±ºã¾ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:33
msgid "Module :mod:`socketserver`"
msgstr "Module :mod:`socketserver`"

#: ../../library/socket.rst:33
msgid "Classes that simplify writing network servers."
msgstr "ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚µãƒ¼ãƒã®é–‹ç™ºã‚’çœåŠ›åŒ–ã™ã‚‹ãŸã‚ã®ã‚¯ãƒ©ã‚¹ç¾¤ã€‚"

#: ../../library/socket.rst:35
msgid "Module :mod:`ssl`"
msgstr "Module :mod:`ssl`"

#: ../../library/socket.rst:36
msgid "A TLS/SSL wrapper for socket objects."
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ TLS/SSL ãƒ©ãƒƒãƒ‘ãƒ¼."

#: ../../library/socket.rst:40
msgid "Socket families"
msgstr "ã‚½ã‚±ãƒƒãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼"

#: ../../library/socket.rst:42
msgid ""
"Depending on the system and the build options, various socket families are "
"supported by this module."
msgstr "ã©ã®ã‚·ã‚¹ãƒ†ãƒ ã§å®Ÿè¡Œã™ã‚‹ã‹ã¨ãƒ“ãƒ«ãƒ‰ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«ä¾å­˜ã—ã¾ã™ãŒã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ˆã£ã¦å¤šæ§˜ãªã‚½ã‚±ãƒƒãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../library/socket.rst:45
msgid ""
"The address format required by a particular socket object is automatically "
"selected based on the address family specified when the socket object was "
"created.  Socket addresses are represented as follows:"
msgstr ""
"ç‰¹å®šã®ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã£ã¦å¿…è¦ã¨ã•ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã€ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã•ã‚ŒãŸã¨ãã«æŒ‡å®šã•ã‚ŒãŸã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã‚’å…ƒã«è‡ªå‹•çš„ã«é¸æŠã•ã‚Œã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã¯æ¬¡ã®é€šã‚Šã§ã™ã€‚"

#: ../../library/socket.rst:49
msgid ""
"The address of an :const:`AF_UNIX` socket bound to a file system node is "
"represented as a string, using the file system encoding and the "
"``'surrogateescape'`` error handler (see :pep:`383`).  An address in Linux's"
" abstract namespace is returned as a :term:`bytes-like object` with an "
"initial null byte; note that sockets in this namespace can communicate with "
"normal file system sockets, so programs intended to run on Linux may need to"
" deal with both types of address.  A string or bytes-like object can be used"
" for either type of address when passing it as an argument."
msgstr ""
"ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®ãƒãƒ¼ãƒ‰ã«æŸç¸›ã•ã‚ŒãŸ :const:`AF_UNIX` ã‚½ã‚±ãƒƒãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¨ "
"``'surrogateescape'`` ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ© (:pep:`383` ã‚’å‚ç…§) ã‚’ä½¿ã£ã¦æ–‡å­—åˆ—ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¾ã™ã€‚ Linux "
"ã®æŠ½è±¡åå‰ç©ºé–“ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ã€å…ˆé ­ãŒ null ãƒã‚¤ãƒˆã¨ãªã‚‹ :term:`bytes-like object` "
"ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚ã“ã®åå‰ç©ºé–“ã®ã‚½ã‚±ãƒƒãƒˆã¯é€šå¸¸ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®ã‚½ã‚±ãƒƒãƒˆã¨é€šä¿¡ã§ãã‚‹ã®ã§ã€ Linux "
"ä¸Šã§å‹•ä½œã™ã‚‹ã“ã¨ã‚’æ„å›³ã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ä¸¡æ–¹ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ‰±ã†å¿…è¦ãŒã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚æ–‡å­—åˆ—ã¨ bytes-like "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã©ã¡ã‚‰ã®ã‚¿ã‚¤ãƒ—ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ã‚‚å¼•æ•°ã¨ã—ã¦æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:59
msgid ""
"Previously, :const:`AF_UNIX` socket paths were assumed to use UTF-8 "
"encoding."
msgstr "ã“ã‚Œã¾ã§ã¯ :const:`AF_UNIX` ã‚½ã‚±ãƒƒãƒˆãƒ‘ã‚¹ã¯ UTF-8 ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ç”¨ã™ã‚‹ã‚‚ã®ã¨ã•ã‚Œã¦ã„ã¾ã—ãŸã€‚"

#: ../../library/socket.rst:63 ../../library/socket.rst:720
#: ../../library/socket.rst:762 ../../library/socket.rst:1404
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "æ›¸ãè¾¼ã¿å¯èƒ½ãª :term:`bytes-like object` ã‚’ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/socket.rst:68
msgid ""
"A pair ``(host, port)`` is used for the :const:`AF_INET` address family, "
"where *host* is a string representing either a hostname in Internet domain "
"notation like ``'daring.cwi.nl'`` or an IPv4 address like "
"``'100.50.200.5'``, and *port* is an integer."
msgstr ""
":const:`AF_INET` ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã«ã¯ã€ ``(host, port)`` ãƒšã‚¢ãŒã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ã—ã¦åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚ *host* "
"ã¯ãƒ›ã‚¹ãƒˆåã‹ ``'daring.cwi.nl'`` ã®ã‚ˆã†ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒ‰ãƒ¡ã‚¤ãƒ³ã‹ã€ ``'100.50.200.5'`` ã®ã‚ˆã†ãª IPv4 "
"ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã€ *port* ã¯æ•´æ•°ã§ã™ã€‚"

#: ../../library/socket.rst:73
msgid ""
"For IPv4 addresses, two special forms are accepted instead of a host "
"address: ``''`` represents :const:`INADDR_ANY`, which is used to bind to all"
" interfaces, and the string ``'<broadcast>'`` represents "
":const:`INADDR_BROADCAST`.  This behavior is not compatible with IPv6, "
"therefore, you may want to avoid these if you intend to support IPv6 with "
"your Python programs."
msgstr ""

#: ../../library/socket.rst:80
msgid ""
"For :const:`AF_INET6` address family, a four-tuple ``(host, port, flowinfo, "
"scopeid)`` is used, where *flowinfo* and *scopeid* represent the "
"``sin6_flowinfo`` and ``sin6_scope_id`` members in :const:`struct "
"sockaddr_in6` in C.  For :mod:`socket` module methods, *flowinfo* and "
"*scopeid* can be omitted just for backward compatibility.  Note, however, "
"omission of *scopeid* can cause problems in manipulating scoped IPv6 "
"addresses."
msgstr ""
":const:`AF_INET6` ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã§ã¯ã€ ``(host, port, flowinfo, scopeid)`` ã®4 "
"è¦ç´ ã®ã‚¿ãƒ—ãƒ«ãŒåˆ©ç”¨ã•ã‚Œã¾ã™ã€‚ *flowinfo* ã¨ *scopeid* ã¯ãã‚Œãã‚ŒCè¨€èªã® :const:`struct sockaddr_in6`"
" ã® ``sin6_flowinfo`` ã¨ ``sin6_scope_id`` ãƒ¡ãƒ³ãƒãƒ¼ã‚’è¡¨ã—ã¾ã™ã€‚ :mod:`socket` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ã€å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã« *flowinfo* ã¨ *scopeid* ã®çœç•¥ã‚’è¨±ã—ã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€ *scopeid* "
"ã‚’çœç•¥ã™ã‚‹ã¨ scope ã•ã‚ŒãŸ IPv6 ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ“ä½œã™ã‚‹ã¨ãã«å•é¡ŒãŒèµ·ã“ã‚‹å ´åˆãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:87
msgid ""
":const:`AF_NETLINK` sockets are represented as pairs ``(pid, groups)``."
msgstr ":const:`AF_NETLINK` ã‚½ã‚±ãƒƒãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ ``(pid, groups)`` ã®ãƒšã‚¢ã§è¡¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:89
msgid ""
"Linux-only support for TIPC is available using the :const:`AF_TIPC` address "
"family.  TIPC is an open, non-IP based networked protocol designed for use "
"in clustered computer environments.  Addresses are represented by a tuple, "
"and the fields depend on the address type. The general tuple form is "
"``(addr_type, v1, v2, v3 [, scope])``, where:"
msgstr ""
"Linux é™å®šã§ã€ :const:`AF_TIPC` ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã‚’ç”¨ã„ã¦ TIPC ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚ TIPC "
"ã¯ã€ã‚¯ãƒ©ã‚¹ã‚¿ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ç’°å¢ƒã®ãŸã‚ã«è¨­è¨ˆã•ã‚ŒãŸã€IP "
"ãƒ™ãƒ¼ã‚¹ã§ã¯ãªã„ã‚ªãƒ¼ãƒ—ãƒ³ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ã‚¿ãƒ—ãƒ«ã§è¡¨ç¾ã•ã‚Œã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚¿ã‚¤ãƒ—ã«ä¾å­˜ã—ã¾ã™ã€‚ä¸€èˆ¬çš„ãªã‚¿ãƒ—ãƒ«ã®å½¢å¼ã¯ "
"``(addr_type, v1, v2, v3 [, scope])`` ã§ã€ãã‚Œãã‚Œã¯æ¬¡ã®é€šã‚Šã§ã™:"

#: ../../library/socket.rst:95
msgid ""
"*addr_type* is one of :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"or :const:`TIPC_ADDR_ID`."
msgstr ""
"*addr_type* ã¯ :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
":const:`TIPC_ADDR_ID` ã®1ã¤ã€‚"

#: ../../library/socket.rst:97
msgid ""
"*scope* is one of :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, and"
" :const:`TIPC_NODE_SCOPE`."
msgstr ""
"*scope* ã¯ :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, "
":const:`TIPC_NODE_SCOPE` ã®1ã¤ã€‚"

#: ../../library/socket.rst:99
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAME`, then *v1* is the server type, "
"*v2* is the port identifier, and *v3* should be 0."
msgstr ""
"*addr_type* ãŒ :const:`TIPC_ADDR_NAME` ã®å ´åˆã€ *v1* ã¯ã‚µãƒ¼ãƒãƒ¼ã‚¿ã‚¤ãƒ—ã€ *v2* ã¯ãƒãƒ¼ãƒˆID (the "
"port identifier)ã€ãã—ã¦ *v3* ã¯ 0 ã§ã‚ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/socket.rst:102
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAMESEQ`, then *v1* is the server type, "
"*v2* is the lower port number, and *v3* is the upper port number."
msgstr ""
"*addr_type* ãŒ :const:`TIPC_ADDR_NAMESEQ` ã®å ´åˆã€ *v1* ã¯ã‚µãƒ¼ãƒãƒ¼ã‚¿ã‚¤ãƒ—ã€ *v2* "
"ã¯ãƒãƒ¼ãƒˆç•ªå·ä¸‹ä½(lower port number)ã€ *v3* ã¯ãƒãƒ¼ãƒˆç•ªå·ä¸Šä½(upper port number) ã§ã™ã€‚"

#: ../../library/socket.rst:105
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_ID`, then *v1* is the node, *v2* is the "
"reference, and *v3* should be set to 0."
msgstr ""
"*addr_type* ãŒ :const:`TIPC_ADDR_ID` ã®å ´åˆã€ *v1* ã¯ãƒãƒ¼ãƒ‰ã€ *v2* ã¯å‚ç…§ã€ *v3* "
"ã¯0ã§ã‚ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/socket.rst:108
msgid ""
"A tuple ``(interface, )`` is used for the :const:`AF_CAN` address family, "
"where *interface* is a string representing a network interface name like "
"``'can0'``. The network interface name ``''`` can be used to receive packets"
" from all network interfaces of this family."
msgstr ""
":const:`AF_CAN` ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã«ã¯ ``(interface,)`` ã¨ã„ã†ã‚¿ãƒ—ãƒ«ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚ *interface* ã¯ "
"``'can0'`` "
"ã®ã‚ˆã†ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹åã‚’è¡¨ã™æ–‡å­—åˆ—ã§ã™ã€‚ã“ã®ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã®å…¨ã¦ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‹ã‚‰ãƒ‘ã‚±ãƒƒãƒˆã‚’å—ä¿¡ã™ã‚‹ãŸã‚ã«ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å"
" ``''`` ã‚’åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:113
msgid ""
"A string or a tuple ``(id, unit)`` is used for the :const:`SYSPROTO_CONTROL`"
" protocol of the :const:`PF_SYSTEM` family. The string is the name of a "
"kernel control using a dynamically-assigned ID. The tuple can be used if ID "
"and unit number of the kernel control are known or if a registered ID is "
"used."
msgstr ""
"æ–‡å­—åˆ—ã¾ãŸã¯ã‚¿ãƒ—ãƒ« ``(id, unit)`` ã¯ :const:`PF_SYSTEM` ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã® "
":const:`SYSPROTO_CONTROL` "
"ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã®æ–‡å­—åˆ—ã¯ã€å‹•çš„ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸIDã«ã‚ˆã‚‹ã‚«ãƒ¼ãƒãƒ«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®åå‰ã§ã™ã€‚ã“ã®ã‚¿ãƒ—ãƒ«ã¯ã€ã‚«ãƒ¼ãƒãƒ«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®IDã¨ãƒ¦ãƒ‹ãƒƒãƒˆç•ªå·ãŒæ—¢çŸ¥ã®å ´åˆã€ã¾ãŸã¯ç™»éŒ²æ¸ˆã¿IDãŒä½¿ç”¨ä¸­ã®å ´åˆã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:121
msgid ""
":const:`AF_BLUETOOTH` supports the following protocols and address formats:"
msgstr ":const:`AF_BLUETOOTH` ã¯ä»¥ä¸‹ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/socket.rst:124
msgid ""
":const:`BTPROTO_L2CAP` accepts ``(bdaddr, psm)`` where ``bdaddr`` is the "
"Bluetooth address as a string and ``psm`` is an integer."
msgstr ""
":const:`BTPROTO_L2CAP` ã¯ ``(bdaddr, psm)`` ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚\n"
"``bdaddr`` ã¯ Bluetooth ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¡¨ã™æ–‡å­—åˆ—ã§ã€ ``psm`` ã¯æ•´æ•°ã§ã™ã€‚"

#: ../../library/socket.rst:127
msgid ""
":const:`BTPROTO_RFCOMM` accepts ``(bdaddr, channel)`` where ``bdaddr`` is "
"the Bluetooth address as a string and ``channel`` is an integer."
msgstr ""
":const:`BTPROTO_RFCOMM` ã¯ ``(bdaddr, channel)`` ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚\n"
"``bdaddr`` ã¯ Bluetooth ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¡¨ã™æ–‡å­—åˆ—ã§ã€ ``channel`` ã¯æ•´æ•°ã§ã™ã€‚"

#: ../../library/socket.rst:130
msgid ""
":const:`BTPROTO_HCI` accepts ``(device_id,)`` where ``device_id`` is either "
"an integer or a string with the Bluetooth address of the interface. (This "
"depends on your OS; NetBSD and DragonFlyBSD expect a Bluetooth address while"
" everything else expects an integer.)"
msgstr ""
":const:`BTPROTO_HCI` ã¯ ``(device_id,)`` ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ ``device_id`` "
"ã¯ã€æ•°å€¤ã¾ãŸã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã® Bluetooth ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¡¨ã™æ–‡å­—åˆ—ã§ã™ã€‚(OS ã«ä¾å­˜ã—ã¾ã™ã€‚NetBSD ã¨ DragonFlyBSD ã¯ "
"Bluetooth ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æœŸå¾…ã—ã¾ã™ãŒã€ãã®ä»–ã™ã¹ã¦ã® OS ã¯ã€æ•°å€¤ã‚’æœŸå¾…ã—ã¾ã™ã€‚)"

#: ../../library/socket.rst:135
msgid "NetBSD and DragonFlyBSD support added."
msgstr "NetBSD ã¨ DragonFlyBSD ã®ã‚µãƒãƒ¼ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/socket.rst:138
msgid ""
":const:`BTPROTO_SCO` accepts ``bdaddr`` where ``bdaddr`` is a :class:`bytes`"
" object containing the Bluetooth address in a string format. (ex. "
"``b'12:23:34:45:56:67'``) This protocol is not supported under FreeBSD."
msgstr ""
":const:`BTPROTO_SCO` ã¯ ``bdaddr`` ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ã“ã“ã§ã€ ``bdaddr`` ã¯ Bluetooth "
"ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ–‡å­—åˆ—å½¢å¼ã§æŒã¤ :class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ (ä¾‹: "
"``b'12:23:34:45:56:67'``)ã€‚ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ã€  FreeBSD ã§ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:143
msgid ""
":const:`AF_ALG` is a Linux-only socket based interface to Kernel "
"cryptography. An algorithm socket is configured with a tuple of two to four "
"elements ``(type, name [, feat [, mask]])``, where:"
msgstr ""
":const:`AF_ALG` ã¯ã‚«ãƒ¼ãƒãƒ«æš—å·ã¸ã®ã‚½ã‚±ãƒƒãƒˆãƒ™ãƒ¼ã‚¹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã§ã€Linux ã§ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚½ã‚±ãƒƒãƒˆã¯ã€2 ã¤ã‹ã‚‰"
" 4 ã¤ã®è¦ç´ ã‚’æŒã¤ã‚¿ãƒ—ãƒ« ``(type, name [, feat [, mask]])`` ã§æ§‹æˆã•ã‚Œã¾ã™ã€‚å„è¦ç´ ã®æ„å‘³ã¯ã€ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚"

#: ../../library/socket.rst:147
msgid ""
"*type* is the algorithm type as string, e.g. ``aead``, ``hash``, "
"``skcipher`` or ``rng``."
msgstr ""
"*type* ã¯ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚¿ã‚¤ãƒ—ã‚’ç¤ºã™æ–‡å­—åˆ—ã§ã™ã€‚ä¾‹: ``aead``, ``hash``, ``skcipher`` ã¾ãŸã¯ ``rng``ã€‚"

#: ../../library/socket.rst:150
msgid ""
"*name* is the algorithm name and operation mode as string, e.g. ``sha256``, "
"``hmac(sha256)``, ``cbc(aes)`` or ``drbg_nopr_ctr_aes256``."
msgstr ""
"*name* ã¯ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ååŠã³æ“ä½œãƒ¢ãƒ¼ãƒ‰ã‚’ç¤ºã™æ–‡å­—åˆ—ã§ã™ã€‚ä¾‹: ``sha256``, ``hmac(sha256)``, ``cbc(aes)``"
" ã¾ãŸã¯ ``drbg_nopr_ctr_aes256``ã€‚"

#: ../../library/socket.rst:153
msgid "*feat* and *mask* are unsigned 32bit integers."
msgstr "*feat* ã¨ *mask* ã¯ã€ç¬¦å·ã‚’æŒãŸãªã„ 32 ãƒ“ãƒƒãƒˆã®æ•´æ•°ã§ã™ã€‚"

#: ../../library/socket.rst:155
msgid ""
"Availability Linux 2.6.38, some algorithm types require more recent Kernels."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ: Linux 2.6.38 ä»¥é™ã€‚ä¸€éƒ¨ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚¿ã‚¤ãƒ—ã§ã¯ã€ã•ã‚‰ã«æ–°ã—ã„ã‚«ãƒ¼ãƒãƒ«ãŒå¿…è¦ã§ã™ã€‚"

#: ../../library/socket.rst:159
msgid ""
"Certain other address families (:const:`AF_PACKET`, :const:`AF_CAN`) support"
" specific representations."
msgstr ""
"ãã®ä»–ã®ç‰¹å®šã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ (:const:`AF_PACKET`, :const:`AF_CAN`) "
"ã¯ã€ãã‚Œãã‚Œå›ºæœ‰ã®å½¢å¼ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/socket.rst:164
msgid ""
"If you use a hostname in the *host* portion of IPv4/v6 socket address, the "
"program may show a nondeterministic behavior, as Python uses the first "
"address returned from the DNS resolution.  The socket address will be "
"resolved differently into an actual IPv4/v6 address, depending on the "
"results from DNS resolution and/or the host configuration.  For "
"deterministic behavior use a numeric address in *host* portion."
msgstr ""
"IPv4/v6ã‚½ã‚±ãƒƒãƒˆã® *host* "
"éƒ¨ã«ãƒ›ã‚¹ãƒˆåã‚’æŒ‡å®šã™ã‚‹ã¨ã€å‡¦ç†çµæœãŒä¸€å®šã§ã¯ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯Pythonã¯DNSã‹ã‚‰å–å¾—ã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã®ã†ã¡æœ€åˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã®ã§ã€ "
"DNSã®å‡¦ç†ã‚„ãƒ›ã‚¹ãƒˆã®è¨­å®šã«ã‚ˆã£ã¦ç•°ãªã‚‹IPv4/6ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã™ã‚‹å ´åˆãŒã‚ã‚‹ãŸã‚ã§ã™ã€‚å¸¸ã«åŒã˜çµæœãŒå¿…è¦ã§ã‚ã‚Œã°ã€ *host* "
"ã«æ•°å€¤ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:171
msgid ""
"All errors raise exceptions.  The normal exceptions for invalid argument "
"types and out-of-memory conditions can be raised; starting from Python 3.3, "
"errors related to socket or address semantics raise :exc:`OSError` or one of"
" its subclasses (they used to raise :exc:`socket.error`)."
msgstr ""
"å…¨ã¦ã®ã‚¨ãƒ©ãƒ¼ã¯ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚å¼•æ•°å‹ã®ã‚¨ãƒ©ãƒ¼ã‚„ãƒ¡ãƒ¢ãƒªä¸è¶³ã®å ´åˆã«ã¯é€šå¸¸ã®ä¾‹å¤–ãŒç™ºç”Ÿã—ã€ã‚½ã‚±ãƒƒãƒˆã‚„ã‚¢ãƒ‰ãƒ¬ã‚¹é–¢é€£ã®ã‚¨ãƒ©ãƒ¼ã¯ Python 3.3 ã‹ã‚‰ã¯"
" :exc:`OSError` ã‹ãã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ç™ºç”Ÿã•ã›ã¾ã™ (Python 3.3 ä»¥å‰ã¯ :exc:`socket.error` "
"ã‚’ç™ºç”Ÿã•ã›ã¦ã„ã¾ã—ãŸ)ã€‚"

#: ../../library/socket.rst:176
msgid ""
"Non-blocking mode is supported through :meth:`~socket.setblocking`.  A "
"generalization of this based on timeouts is supported through "
":meth:`~socket.settimeout`."
msgstr ""
":meth:`~socket.setblocking` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã€éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã¾ãŸã€ã‚ˆã‚Šæ±ç”¨çš„ã« "
":meth:`~socket.settimeout` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’æŒ‡å®šã™ã‚‹äº‹ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:182
msgid "Module contents"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†…å®¹"

#: ../../library/socket.rst:184
msgid "The module :mod:`socket` exports the following elements."
msgstr ":mod:`socket` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ä»¥ä¸‹ã®è¦ç´ ã‚’å…¬é–‹ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/socket.rst:188
msgid "Exceptions"
msgstr "ä¾‹å¤–"

#: ../../library/socket.rst:192
msgid "A deprecated alias of :exc:`OSError`."
msgstr ":exc:`OSError` ã®éæ¨å¥¨ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã™ã€‚"

#: ../../library/socket.rst:194
msgid "Following :pep:`3151`, this class was made an alias of :exc:`OSError`."
msgstr ":pep:`3151` ã«åŸºã¥ãã€ã“ã®ã‚¯ãƒ©ã‚¹ã¯ :exc:`OSError` ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/socket.rst:200
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors, i.e. for functions that use *h_errno* in the POSIX C API, including "
":func:`gethostbyname_ex` and :func:`gethostbyaddr`. The accompanying value "
"is a pair ``(h_errno, string)`` representing an error returned by a library "
"call.  *h_errno* is a numeric value, while *string* represents the "
"description of *h_errno*, as returned by the :c:func:`hstrerror` C function."
msgstr ""
":exc:`OSError` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã€‚ã“ã®ä¾‹å¤–ã¯ã‚¢ãƒ‰ãƒ¬ã‚¹é–¢é€£ã®ã‚¨ãƒ©ãƒ¼ã€ã¤ã¾ã‚Š :func:`gethostbyname_ex` ã¨ "
":func:`gethostbyaddr` ãªã©ã®ã€ POSIX C API ã® *h_errno* ã‚’åˆ©ç”¨ã™ã‚‹é–¢æ•°ã®ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚ä¾‹å¤–ã«ä»˜éšã™ã‚‹"
" ``(h_errno, string)`` ãƒšã‚¢ã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦è¿”ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ã‚’è¡¨ã—ã¾ã™ã€‚ *h_errno* ã¯æ•°å€¤ã§ã€ "
"*string* ã¯ã€ :c:func:`hstrerror` Cé–¢æ•°ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ *h_errno* ã‚’èª¬æ˜ã™ã‚‹æ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/socket.rst:208 ../../library/socket.rst:221
#: ../../library/socket.rst:232
msgid "This class was made a subclass of :exc:`OSError`."
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã¯ :exc:`OSError` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/socket.rst:213
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors by :func:`getaddrinfo` and :func:`getnameinfo`. The accompanying "
"value is a pair ``(error, string)`` representing an error returned by a "
"library call.  *string* represents the description of *error*, as returned "
"by the :c:func:`gai_strerror` C function.  The numeric *error* value will "
"match one of the :const:`EAI_\\*` constants defined in this module."
msgstr ""
":exc:`OSError` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ã“ã®ä¾‹å¤–ã¯ :func:`getaddrinfo` ã¨ :func:`getnameinfo` "
"ã§ã‚¢ãƒ‰ãƒ¬ã‚¹é–¢é€£ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«é€å‡ºã•ã‚Œã¾ã™ã€‚ä¾‹å¤–ã®å€¤ã¯ ``(error, string)`` ã®ãƒšã‚¢ã§ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‘¼ã³å‡ºã—çµæœã‚’è¿”ã—ã¾ã™ã€‚ "
"*string* ã¯Cé–¢æ•° :c:func:`gai_strerror` ã§å–å¾—ã—ãŸã€ *error* ã®æ„å‘³ã‚’ç¤ºã™æ–‡å­—åˆ—ã§ã™ã€‚ *error* "
"ã®å€¤ã¯ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã‚‹ :const:`EAI_\\*` å®šæ•°ã®ã©ã‚Œã‹ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:226
msgid ""
"A subclass of :exc:`OSError`, this exception is raised when a timeout occurs"
" on a socket which has had timeouts enabled via a prior call to "
":meth:`~socket.settimeout` (or implicitly through "
":func:`~socket.setdefaulttimeout`).  The accompanying value is a string "
"whose value is currently always \"timed out\"."
msgstr ""
":exc:`OSError` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ã“ã®ä¾‹å¤–ã¯ã€ã‚ã‚‰ã‹ã˜ã‚ :meth:`~socket.settimeout` ã‚’å‘¼ã³å‡ºã—ã¦ (ã‚ã‚‹ã„ã¯ "
":func:`~socket.setdefaulttimeout` ã‚’åˆ©ç”¨ã—ã¦æš—é»™ã«) "
"ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’æœ‰åŠ¹ã«ã—ã¦ã‚ã‚‹ã‚½ã‚±ãƒƒãƒˆã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç”Ÿã˜ãŸéš›ã«é€å‡ºã•ã‚Œã¾ã™ã€‚ ä¾‹å¤–ã«ä»˜å±ã™ã‚‹å€¤ã¯æ–‡å­—åˆ—ã§ã€ãã®å†…å®¹ã¯ç¾çŠ¶ã§ã¯å¸¸ã« \"timed "
"out\" ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:237
msgid "Constants"
msgstr "å®šæ•°"

#: ../../library/socket.rst:239
msgid ""
"The AF_* and SOCK_* constants are now :class:`AddressFamily` and "
":class:`SocketKind` :class:`.IntEnum` collections."
msgstr ""
"AF_* å®šæ•°ã¨ SOCK_* å®šæ•°ã¯ã€ :class:`AddressFamily` ã¨ :class:`SocketKind` "
":class:`.IntEnum` collection ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/socket.rst:248
msgid ""
"These constants represent the address (and protocol) families, used for the "
"first argument to :func:`.socket`.  If the :const:`AF_UNIX` constant is not "
"defined then this protocol is unsupported.  More constants may be available "
"depending on the system."
msgstr ""
"ã‚¢ãƒ‰ãƒ¬ã‚¹ (ãŠã‚ˆã³ãƒ—ãƒ­ãƒˆã‚³ãƒ«) ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã‚’ç¤ºã™å®šæ•°ã§ã€ :func:`.socket` ã® æœ€åˆã®å¼•æ•°ã«æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ "
":const:`AF_UNIX` ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã‚’ã‚µãƒãƒ¼ãƒˆ ã—ãªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€ :const:`AF_UNIX` "
"ã¯æœªå®šç¾©ã¨ãªã‚Šã¾ã™ã€‚ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ã¯ã“ã‚Œã‚‰ä»¥å¤–ã®å®šæ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:260
msgid ""
"These constants represent the socket types, used for the second argument to "
":func:`.socket`.  More constants may be available depending on the system. "
"(Only :const:`SOCK_STREAM` and :const:`SOCK_DGRAM` appear to be generally "
"useful.)"
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã‚’ç¤ºã™å®šæ•°ã§ã€ :func:`.socket` "
"ã®2ç•ªç›®ã®å¼•æ•°ã«æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ã¯ã“ã‚Œã‚‰ä»¥å¤–ã®å®šæ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ (ã»ã¨ã‚“ã©ã®å ´åˆã€ "
":const:`SOCK_STREAM` ã¨ :const:`SOCK_DGRAM` ä»¥å¤–ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚)"

#: ../../library/socket.rst:268
msgid ""
"These two constants, if defined, can be combined with the socket types and "
"allow you to set some flags atomically (thus avoiding possible race "
"conditions and the need for separate calls)."
msgstr ""
"ã“ã®2ã¤ã®å®šæ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ãŸå ´åˆã€ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã¨çµ„ã¿åˆã‚ã›ã¦ã„ãã¤ã‹ã® flags ã‚’ã‚¢ãƒˆãƒŸãƒƒã‚¯ã«è¨­å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ "
"(åˆ¥ã®å‘¼ã³å‡ºã—ã‚’ä¸è¦ã«ã—ã¦ç«¶åˆçŠ¶æ…‹ã‚’é¿ã‘ã‚‹äº‹ãŒã§ãã¾ã™)ã€‚"

#: ../../library/socket.rst:274
msgid ""
"`Secure File Descriptor Handling "
"<http://udrepper.livejournal.com/20407.html>`_ for a more thorough "
"explanation."
msgstr ""
"ã‚ˆã‚Šå®Œå…¨ãªèª¬æ˜ã¯ `Secure File Descriptor Handling "
"<http://udrepper.livejournal.com/20407.html>`_ ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:277
msgid "Availability: Linux >= 2.6.27."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ: Linux 2.6.27 ä»¥é™ã€‚"

#: ../../library/socket.rst:296
msgid ""
"Many constants of these forms, documented in the Unix documentation on "
"sockets and/or the IP protocol, are also defined in the socket module. They "
"are generally used in arguments to the :meth:`setsockopt` and "
":meth:`getsockopt` methods of socket objects.  In most cases, only those "
"symbols that are defined in the Unix header files are defined; for a few "
"symbols, default values are provided."
msgstr ""
"Unixã®ã‚½ã‚±ãƒƒãƒˆãƒ»IPãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹å„ç¨®å®šæ•°ã€‚ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`setsockopt` ã‚„ "
":meth:`getsockopt` "
"ã§ä½¿ç”¨ã—ã¾ã™ã€‚ã»ã¨ã‚“ã©ã®ã‚·ãƒ³ãƒœãƒ«ã¯Unixã®ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã«å¾“ã£ã¦ã„ã¾ã™ã€‚ä¸€éƒ¨ã®ã‚·ãƒ³ãƒœãƒ«ã«ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’å®šç¾©ã—ã¦ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:303
msgid ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` were added."
msgstr ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/socket.rst:307
msgid ""
"On Windows, ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` appear if run-time Windows "
"supports."
msgstr ""
"Windowsã§ã¯ã€å®Ÿè¡Œæ™‚ã®WindowsãŒã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãªã‚‰ã° ``TCP_FASTOPEN``ã€ ``TCP_KEEPCNT``ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:316 ../../library/socket.rst:351
msgid ""
"Many constants of these forms, documented in the Linux documentation, are "
"also defined in the socket module."
msgstr "Linux ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚ã‚‹ã“ã®å½¢å¼ã®å®šæ•°ã¯ socket ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã‚‚å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/socket.rst:319 ../../library/socket.rst:330
msgid "Availability: Linux >= 2.6.25."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ: Linux 2.6.25 ä»¥é™ã€‚"

#: ../../library/socket.rst:326
msgid ""
"CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) "
"protocol. Broadcast manager constants, documented in the Linux "
"documentation, are also defined in the socket module."
msgstr ""
"CANãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã®CAN_BCMã¯ã€ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼(BCM)ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚Linuxãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚ã‚‹ã“ã®å½¢å¼ã®å®šæ•°ã¯ã€socketãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã‚‚å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/socket.rst:336
msgid ""
"Enables CAN FD support in a CAN_RAW socket. This is disabled by default. "
"This allows your application to send both CAN and CAN FD frames; however, "
"you one must accept both CAN and CAN FD frames when reading from the socket."
msgstr ""
"CAN_RAW ã‚½ã‚±ãƒƒãƒˆã§ CAN FD ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ç„¡åŠ¹ã«ãªã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒ CAN ãƒ•ãƒ¬ãƒ¼ãƒ ã¨ "
"CAN FD ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é€ä¿¡ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ãŸã ã—ã€ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰ã®èª­ã¿å‡ºã—æ™‚ã«ã€CAN ã¨ CAN FD "
"ã®ä¸¡æ–¹ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å—ã‘å…¥ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:340
msgid "This constant is documented in the Linux documentation."
msgstr "ã“ã®å®šæ•°ã¯ã€ Linux ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã§èª¬æ˜ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/socket.rst:342
msgid "Availability: Linux >= 3.6."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ: Linux 3.6 ä»¥é™ã€‚"

#: ../../library/socket.rst:354
msgid "Availability: Linux >= 2.6.30."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ: Linux 2.6.30 ä»¥é™ã€‚"

#: ../../library/socket.rst:364
msgid ""
"Constants for Windows' WSAIoctl(). The constants are used as arguments to "
"the :meth:`~socket.socket.ioctl` method of socket objects."
msgstr ""
"Windows ã® WSAIoctl() ã®ãŸã‚ã®å®šæ•°ã§ã™ã€‚ã“ã®å®šæ•°ã¯ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`~socket.socket.ioctl` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã«å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:367 ../../library/socket.rst:1044
msgid "``SIO_LOOPBACK_FAST_PATH`` was added."
msgstr "``SIO_LOOPBACK_FAST_PATH`` ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/socket.rst:373
msgid ""
"TIPC related constants, matching the ones exported by the C socket API. See "
"the TIPC documentation for more information."
msgstr "TIPC é–¢é€£ã®å®šæ•°ã§ã€C ã®ã‚½ã‚±ãƒƒãƒˆAPIãŒå…¬é–‹ã—ã¦ã„ã‚‹ã‚‚ã®ã«ãƒãƒƒãƒã—ã¾ã™ã€‚è©³ã—ã„æƒ…å ±ã¯ TIPC ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:380
msgid "Constants for Linux Kernel cryptography."
msgstr "Linux ã‚«ãƒ¼ãƒãƒ«æš—å·ç”¨ã®å®šæ•°ã§ã™ã€‚"

#: ../../library/socket.rst:382
msgid "Availability: Linux >= 2.6.38."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ: Linux 2.6.38 ä»¥é™ã€‚"

#: ../../library/socket.rst:388
msgid "Availability: BSD, OSX."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ: BSD, OSX."

#: ../../library/socket.rst:394
msgid ""
"This constant contains a boolean value which indicates if IPv6 is supported "
"on this platform."
msgstr "ç¾åœ¨ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§IPv6ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‹å¦ã‹ã‚’ç¤ºã™çœŸå½å€¤ã€‚"

#: ../../library/socket.rst:400
msgid ""
"These are string constants containing Bluetooth addresses with special "
"meanings. For example, :const:`BDADDR_ANY` can be used to indicate any "
"address when specifying the binding socket with :const:`BTPROTO_RFCOMM`."
msgstr ""
"ã“ã‚Œã‚‰ã¯ã€ç‰¹åˆ¥ãªæ„å‘³ã‚’æŒã¤ Bluetooth ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å«ã‚€æ–‡å­—åˆ—å®šæ•°ã§ã™ã€‚ä¾‹ãˆã°ã€:const:`BDADDR_ANY` ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ "
":const:`BTPROTO_RFCOMM` ã§æŸç¸›ã‚½ã‚±ãƒƒãƒˆã‚’æŒ‡å®šã™ã‚‹éš›ã«ã€ä»»æ„ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡ã—ç¤ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:409
msgid ""
"For use with :const:`BTPROTO_HCI`. :const:`HCI_FILTER` is not available for "
"NetBSD or DragonFlyBSD. :const:`HCI_TIME_STAMP` and :const:`HCI_DATA_DIR` "
"are not available for FreeBSD, NetBSD, or DragonFlyBSD."
msgstr ""
":const:`BTPROTO_HCI` ã§ä½¿ç”¨ã—ã¾ã™ã€‚ :const:`HCI_FILTER` ã¯ NetBSD ã¾ãŸã¯ DragonFlyBSD "
"ã§ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚ :const:`HCI_TIME_STAMP` ã¨ :const:`HCI_DATA_DIR` ã¯ FreeBSD, "
"NetBSD, DragonFlyBSD ã§ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:415
msgid "Functions"
msgstr "é–¢æ•°"

#: ../../library/socket.rst:418
msgid "Creating sockets"
msgstr "ã‚½ã‚±ãƒƒãƒˆã®ä½œæˆ"

#: ../../library/socket.rst:420
msgid ""
"The following functions all create :ref:`socket objects <socket-objects>`."
msgstr "ä»¥ä¸‹ã®é–¢æ•°ã¯å…¨ã¦ :ref:`socket object <socket-objects>` ã‚’ç”Ÿæˆã—ã¾ã™ã€‚"

#: ../../library/socket.rst:425
msgid ""
"Create a new socket using the given address family, socket type and protocol"
" number.  The address family should be :const:`AF_INET` (the default), "
":const:`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN` or :const:`AF_RDS`. The"
" socket type should be :const:`SOCK_STREAM` (the default), "
":const:`SOCK_DGRAM`, :const:`SOCK_RAW` or perhaps one of the other ``SOCK_``"
" constants. The protocol number is usually zero and may be omitted or in the"
" case where the address family is :const:`AF_CAN` the protocol should be one"
" of :const:`CAN_RAW` or :const:`CAN_BCM`.  If *fileno* is specified, the "
"other arguments are ignored, causing the socket with the specified file "
"descriptor to return.  Unlike :func:`socket.fromfd`, *fileno* will return "
"the same socket and not a duplicate. This may help close a detached socket "
"using :meth:`socket.close()`."
msgstr ""
"ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã€ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç•ªå·ã‚’æŒ‡å®šã—ã¦æ–°ã—ã„ã‚½ã‚±ãƒƒãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã«ã¯ :const:`AF_INET` "
"(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤)ã€ :const:`AF_INET6`  ã€ :const:`AF_UNIX`  ã€ :const:`AF_CAN`  ã€ã¾ãŸã¯ "
":const:`AF_RDS` ã‚’æŒ‡å®šã—ã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã«ã¯ :const:`SOCK_STREAM` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤)ã€ "
":const:`SOCK_DGRAM` ã€ :const:`SOCK_RAW` ã€ã¾ãŸã¯ä»–ã® ``SOCK_`` "
"å®šæ•°ã‚’æŒ‡å®šã—ã¾ã™ã€‚ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç•ªå·ã¯é€šå¸¸çœç•¥ã™ã‚‹ã‹ã€ã¾ãŸã¯0ã‚’æŒ‡å®šã—ã¾ã™ãŒã€ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã« :const:`AF_CAN` "
"ã‚’æŒ‡å®šã—ãŸå ´åˆã¯ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç•ªå·ã«ã¯ :const:`CAN_RAW` ã‹ :const:`CAN_BCM` "
"ã®ã„ãšã‚Œã‹ã‚’æŒ‡å®šã™ã¹ãã§ã™ã€‚*fileno* ã‚’æŒ‡å®šã—ãŸå ´åˆã€åˆ¥ã®å¼•æ•°ãŒç„¡è¦–ã•ã‚Œã‚‹ãŸã‚ã€æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã®ã‚½ã‚±ãƒƒãƒˆãŒè¿”ã‚Šã¾ã™ã€‚*fileno* "
"ã¯ã€:func:`socket.fromfd` ã¨ã¯ç•°ãªã‚Šã€ã‚½ã‚±ãƒƒãƒˆã®è¤‡è£½ã§ã¯ãªãã€åŒä¸€ã®ã‚½ã‚±ãƒƒãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ã“ã¨ã¯ã€åˆ‡ã‚Šé›¢ã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‚’ "
":meth:`socket.close()` ã§é–‰ã˜ã‚‹ã®ã«å½¹ç«‹ã¤å ´åˆãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:438 ../../library/socket.rst:505
#: ../../library/socket.rst:888 ../../library/socket.rst:971
msgid "The newly created socket is :ref:`non-inheritable <fd_inheritance>`."
msgstr "æ–°ãŸã«ä½œæˆã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã¯ :ref:`ç¶™æ‰¿ä¸å¯ <fd_inheritance>`  ã§ã™ã€‚"

#: ../../library/socket.rst:440
msgid "The AF_CAN family was added. The AF_RDS family was added."
msgstr "AF_CAN, AF_RDS ãƒ•ã‚¡ãƒŸãƒªãƒ¼ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/socket.rst:444
msgid "The CAN_BCM protocol was added."
msgstr "CAN_BCMãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/socket.rst:447 ../../library/socket.rst:507
msgid "The returned socket is now non-inheritable."
msgstr "è¿”ã•ã‚Œã‚‹ã‚½ã‚±ãƒƒãƒˆã¯ç¶™æ‰¿ä¸å¯ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/socket.rst:453
msgid ""
"Build a pair of connected socket objects using the given address family, "
"socket type, and protocol number.  Address family, socket type, and protocol"
" number are as for the :func:`.socket` function above. The default family is"
" :const:`AF_UNIX` if defined on the platform; otherwise, the default is "
":const:`AF_INET`."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã€ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç•ªå·ã‹ã‚‰ã€æ¥ç¶šã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒšã‚¢ã‚’ä½œæˆã—ã¾ã™ã€‚ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã€ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç•ªå·ã¯"
" :func:`.socket` é–¢æ•°ã¨åŒæ§˜ã«æŒ‡å®šã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã¯ã€ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆ "
":const:`AF_UNIX` ã€ãã†ã§ãªã‘ã‚Œã° :const:`AF_INET` ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:458
msgid "The newly created sockets are :ref:`non-inheritable <fd_inheritance>`."
msgstr "æ–°ãŸã«ä½œæˆã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã¯ :ref:`ç¶™æ‰¿ä¸å¯ <fd_inheritance>` ã§ã™ã€‚"

#: ../../library/socket.rst:460
msgid ""
"The returned socket objects now support the whole socket API, rather than a "
"subset."
msgstr "è¿”ã•ã‚Œã‚‹ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã€ã‚µãƒ–ã‚»ãƒƒãƒˆã§ã¯ãªãå®Œå…¨ãªã‚½ã‚±ãƒƒãƒˆAPIã‚’æä¾›ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/socket.rst:464
msgid "The returned sockets are now non-inheritable."
msgstr "è¿”ã•ã‚Œã‚‹ã‚½ã‚±ãƒƒãƒˆã®çµ„ã¯ã€ã©ã¡ã‚‰ã‚‚ç¶™æ‰¿ä¸å¯ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/socket.rst:467
msgid "Windows support added."
msgstr "Windows ã®ã‚µãƒãƒ¼ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/socket.rst:473
msgid ""
"Connect to a TCP service listening on the Internet *address* (a 2-tuple "
"``(host, port)``), and return the socket object.  This is a higher-level "
"function than :meth:`socket.connect`: if *host* is a non-numeric hostname, "
"it will try to resolve it for both :data:`AF_INET` and :data:`AF_INET6`, and"
" then try to connect to all possible addresses in turn until a connection "
"succeeds.  This makes it easy to write clients that are compatible to both "
"IPv4 and IPv6."
msgstr ""
"*address* (``(host, port)`` ãƒšã‚¢) ã§ listen ã—ã¦ã„ã‚‹TCPã‚µãƒ¼ãƒ“ã‚¹ã«æ¥ç¶šã—ã€ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯"
" :meth:`socket.connect` ã‚’é«˜ç´šã«ã—ãŸé–¢æ•°ã§ã™ã€‚ *host* ãŒæ•°å€¤ã§ãªã„ãƒ›ã‚¹ãƒˆåã®å ´åˆã€ :data:`AF_INET` ã¨ "
":data:`AF_INET6` ã®ä¸¡æ–¹ã§åå‰è§£æ±ºã‚’è©¦ã¿ã€å¾—ã‚‰ã‚ŒãŸå…¨ã¦ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«å¯¾ã—ã¦æˆåŠŸã™ã‚‹ã¾ã§æ¥ç¶šã‚’è©¦ã¿ã¾ã™ã€‚ã“ã®é–¢æ•°ã‚’ä½¿ã£ã¦ IPv4 ã¨ "
"IPv6 ã«ä¸¡å¯¾å¿œã—ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ç°¡å˜ã«æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:481
msgid ""
"Passing the optional *timeout* parameter will set the timeout on the socket "
"instance before attempting to connect.  If no *timeout* is supplied, the "
"global default timeout setting returned by :func:`getdefaulttimeout` is "
"used."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *timeout* å¼•æ•°ã‚’æŒ‡å®šã™ã‚‹ã¨ã€æ¥ç¶šã‚’è©¦ã¿ã‚‹å‰ã«ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®šã—ã¾ã™ã€‚ *timeout* "
"ãŒæŒ‡å®šã•ã‚Œãªã„å ´åˆã€ :func:`getdefaulttimeout` ãŒè¿”ã™ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šå€¤ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:486
msgid ""
"If supplied, *source_address* must be a 2-tuple ``(host, port)`` for the "
"socket to bind to as its source address before connecting.  If host or port "
"are '' or 0 respectively the OS default behavior will be used."
msgstr ""
"*source_address* ã¯æ¥ç¶šã™ã‚‹å‰ã«ãƒã‚¤ãƒ³ãƒ‰ã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®šã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•°ã§ã€æŒ‡å®šã™ã‚‹å ´åˆã¯ ``(host, port)`` "
"ã®2è¦ç´ ã‚¿ãƒ—ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ host ã‚„ port ãŒ '' ã‹ 0 ã ã£ãŸå ´åˆã¯ã€OSã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:490
msgid "*source_address* was added."
msgstr "*source_address* ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/socket.rst:496
msgid ""
"Duplicate the file descriptor *fd* (an integer as returned by a file "
"object's :meth:`fileno` method) and build a socket object from the result.  "
"Address family, socket type and protocol number are as for the "
":func:`.socket` function above. The file descriptor should refer to a "
"socket, but this is not checked --- subsequent operations on the object may "
"fail if the file descriptor is invalid. This function is rarely needed, but "
"can be used to get or set socket options on a socket passed to a program as "
"standard input or output (such as a server started by the Unix inet daemon)."
"  The socket is assumed to be in blocking mode."
msgstr ""
"ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ (ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`fileno` ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿”ã™æ•´æ•°) *fd* "
"ã‚’è¤‡è£½ã—ã¦ã€ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç•ªå·ã¯ :func:`.socket` ã¨åŒæ§˜ã«æŒ‡å®šã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ "
"ã¯ã‚½ã‚±ãƒƒãƒˆã‚’æŒ‡ã—ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ãŒã€å®Ÿéš›ã«ã‚½ã‚±ãƒƒãƒˆã§ã‚ã‚‹ã‹ã©ã†ã‹ã®ãƒã‚§ãƒƒã‚¯ã¯è¡Œã£ã¦ã„ã¾ã›ã‚“ã€‚ã“ã®ãŸã‚ã€ã‚½ã‚±ãƒƒãƒˆä»¥å¤–ã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ "
"ã‚’æŒ‡å®šã™ã‚‹ã¨ãã®å¾Œã®å‡¦ç†ãŒå¤±æ•—ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ã“ã®é–¢æ•°ãŒå¿…è¦ãªäº‹ã¯ã‚ã¾ã‚Šã‚ã‚Šã¾ã›ã‚“ãŒã€ (Unixã®inetãƒ‡ãƒ¼ãƒ¢ãƒ³ã«èµ·å‹•ã•ã‚Œã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚ˆã†ã«)"
" "
"ã‚½ã‚±ãƒƒãƒˆã‚’æ¨™æº–å…¥åŠ›ã‚„æ¨™æº–å‡ºåŠ›ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å–å¾—ã‚„è¨­å®šã‚’è¡Œã†ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã®é–¢æ•°ã§ä½¿ç”¨ã™ã‚‹ã‚½ã‚±ãƒƒãƒˆã¯ã€ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã¨æƒ³å®šã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/socket.rst:513
msgid ""
"Instantiate a socket from data obtained from the :meth:`socket.share` "
"method.  The socket is assumed to be in blocking mode."
msgstr ""
":meth:`socket.share` ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰å–å¾—ã—ãŸ data "
"ã‹ã‚‰ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã¯ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã ã¨ä»®å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:516 ../../library/socket.rst:1428
msgid "Availability: Windows."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ : Windows."

#: ../../library/socket.rst:523
msgid ""
"This is a Python type object that represents the socket object type. It is "
"the same as ``type(socket(...))``."
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’ç¤ºã™å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚ ``type(socket(...))`` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/socket.rst:528
msgid "Other functions"
msgstr "ãã®ä»–ã®é–¢æ•°"

#: ../../library/socket.rst:530
msgid "The :mod:`socket` module also offers various network-related services:"
msgstr ":mod:`socket` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é–¢é€£ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/socket.rst:535
msgid ""
"Translate the *host*/*port* argument into a sequence of 5-tuples that "
"contain all the necessary arguments for creating a socket connected to that "
"service. *host* is a domain name, a string representation of an IPv4/v6 "
"address or ``None``. *port* is a string service name such as ``'http'``, a "
"numeric port number or ``None``.  By passing ``None`` as the value of *host*"
" and *port*, you can pass ``NULL`` to the underlying C API."
msgstr ""
"*host* / *port* å¼•æ•°ã®æŒ‡ã™ã‚¢ãƒ‰ãƒ¬ã‚¹æƒ…å ±ã‚’ã€ãã®ã‚µãƒ¼ãƒ“ã‚¹ã«æ¥ç¶šã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‚’ä½œæˆã™ã‚‹ãŸã‚ã«å¿…è¦ãªå…¨ã¦ã®å¼•æ•°ãŒå…¥ã£ãŸ 5 "
"è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã«å¤‰æ›ã—ã¾ã™ã€‚ *host* ã¯ãƒ‰ãƒ¡ã‚¤ãƒ³åã€IPv4/v6ã‚¢ãƒ‰ãƒ¬ã‚¹ã®æ–‡å­—åˆ—ã€ã¾ãŸã¯ ``None`` ã§ã™ã€‚ *port* ã¯ "
"``'http'`` ã®ã‚ˆã†ãªã‚µãƒ¼ãƒ“ã‚¹åæ–‡å­—åˆ—ã€ãƒãƒ¼ãƒˆç•ªå·ã‚’è¡¨ã™æ•°å€¤ã€ã¾ãŸã¯ ``None`` ã§ã™ã€‚ *host* ã¨ *port* ã« "
"``None`` ã‚’æŒ‡å®šã™ã‚‹ã¨ C APIã« ``NULL`` ã‚’æ¸¡ã›ã¾ã™ã€‚"

#: ../../library/socket.rst:542
msgid ""
"The *family*, *type* and *proto* arguments can be optionally specified in "
"order to narrow the list of addresses returned.  Passing zero as a value for"
" each of these arguments selects the full range of results. The *flags* "
"argument can be one or several of the ``AI_*`` constants, and will influence"
" how results are computed and returned. For example, :const:`AI_NUMERICHOST`"
" will disable domain name resolution and will raise an error if *host* is a "
"domain name."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *family*, *type*, *proto* "
"å¼•æ•°ã‚’æŒ‡å®šã™ã‚‹ã¨ã€è¿”ã•ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒªã‚¹ãƒˆã‚’çµã‚Šè¾¼ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã‚‰ã®å¼•æ•°ã®å€¤ã¨ã—ã¦ 0 ã‚’æ¸¡ã™ã¨çµã‚Šè¾¼ã¾ãªã„çµæœã‚’è¿”ã—ã¾ã™ã€‚ *flags* "
"å¼•æ•°ã«ã¯ ``AI_*`` å®šæ•°ã®ã†ã¡ 1 ã¤ä»¥ä¸ŠãŒæŒ‡å®šã§ãã€çµæœã®å–ã‚Šæ–¹ã‚’å¤‰ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ "
":const:`AI_NUMERICHOST` ã‚’æŒ‡å®šã™ã‚‹ã¨ãƒ‰ãƒ¡ã‚¤ãƒ³åè§£æ±ºã‚’è¡Œã‚ãªã„ã‚ˆã†ã«ã—ã€ *host* "
"ãŒãƒ‰ãƒ¡ã‚¤ãƒ³åã ã£ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/socket.rst:550
msgid "The function returns a list of 5-tuples with the following structure:"
msgstr "ã“ã®é–¢æ•°ã¯ä»¥ä¸‹ã®æ§‹é€ ã‚’ã¨ã‚‹ 5 è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™:"

#: ../../library/socket.rst:552
msgid "``(family, type, proto, canonname, sockaddr)``"
msgstr "``(family, type, proto, canonname, sockaddr)``"

#: ../../library/socket.rst:554
msgid ""
"In these tuples, *family*, *type*, *proto* are all integers and are meant to"
" be passed to the :func:`.socket` function.  *canonname* will be a string "
"representing the canonical name of the *host* if :const:`AI_CANONNAME` is "
"part of the *flags* argument; else *canonname* will be empty.  *sockaddr* is"
" a tuple describing a socket address, whose format depends on the returned "
"*family* (a ``(address, port)`` 2-tuple for :const:`AF_INET`, a ``(address, "
"port, flow info, scope id)`` 4-tuple for :const:`AF_INET6`), and is meant to"
" be passed to the :meth:`socket.connect` method."
msgstr ""
"ã“ã®ã‚¿ãƒ—ãƒ«ã«ã‚ã‚‹ *family*, *type*, *proto* ã¯ã€ :func:`.socket` é–¢æ•°ã‚’å‘¼ã³å‡ºã™éš›ã«æŒ‡å®šã™ã‚‹å€¤ã¨åŒã˜æ•´æ•°ã§ã™ã€‚"
" :const:`AI_CANONNAME` ã‚’å«ã‚“ã  *flags* ã‚’æŒ‡å®šã—ãŸå ´åˆã€ *canonname* ã¯ *host* ã® "
"canonical name ã‚’ç¤ºã™æ–‡å­—åˆ—ã§ã™ã€‚ãã†ã§ãªã„å ´åˆã¯ *canonname* ã¯ç©ºæ–‡å­—åˆ—ã§ã™ã€‚ *sockaddr* ã¯ã€ã‚½ã‚±ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’"
" *family* ã«ä¾å­˜ã—ãŸå½¢å¼ã§è¡¨ã™ã‚¿ãƒ—ãƒ«ã§ã€ (:const:`AF_INET` ã®å ´åˆã¯ 2 è¦ç´ ã®ã‚¿ãƒ—ãƒ« ``(address, "
"port)`` ã€ :const:`AF_INET6` ã®å ´åˆã¯ 4 è¦ç´ ã®ã‚¿ãƒ—ãƒ« ``(address, port, flow info, scope"
" id)``) :meth:`socket.connect` ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã™ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚"

#: ../../library/socket.rst:564
msgid ""
"The following example fetches address information for a hypothetical TCP "
"connection to ``example.org`` on port 80 (results may differ on your system "
"if IPv6 isn't enabled)::"
msgstr ""
"æ¬¡ã®ä¾‹ã§ã¯ ``example.org`` ã® 80 ç•ªãƒãƒ¼ãƒˆãƒãƒ¼ãƒˆã¸ã® TCP æ¥ç¶šã‚’å¾—ã‚‹ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹æƒ…å ±ã‚’å–å¾—ã—ã‚ˆã†ã¨ã—ã¦ã„ã¾ã™ã€‚ (çµæœã¯ "
"IPv6 ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã§å¤‰ã‚ã‚Šã¾ã™)::"

#: ../../library/socket.rst:574
msgid "parameters can now be passed using keyword arguments."
msgstr "ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã§æ¸¡ã™ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/socket.rst:579
msgid ""
"Return a fully qualified domain name for *name*. If *name* is omitted or "
"empty, it is interpreted as the local host.  To find the fully qualified "
"name, the hostname returned by :func:`gethostbyaddr` is checked, followed by"
" aliases for the host, if available.  The first name which includes a period"
" is selected.  In case no fully qualified domain name is available, the "
"hostname as returned by :func:`gethostname` is returned."
msgstr ""
"*name* ã®å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åã‚’è¿”ã—ã¾ã™ã€‚ *name* "
"ãŒç©ºã¾ãŸã¯çœç•¥ã•ã‚ŒãŸå ´åˆã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒ›ã‚¹ãƒˆã‚’æŒ‡å®šã—ãŸã¨ã¿ãªã—ã¾ã™ã€‚å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åã®å–å¾—ã«ã¯ã¾ãš :func:`gethostbyaddr` "
"ã§ãƒã‚§ãƒƒã‚¯ã—ã€æ¬¡ã«å¯èƒ½ã§ã‚ã‚Œã°ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚’èª¿ã¹ã€åå‰ã«ãƒ”ãƒªã‚ªãƒ‰ã‚’å«ã‚€æœ€åˆã®åå‰ã‚’å€¤ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åã‚’å–å¾—ã§ããªã„å ´åˆã€ "
":func:`gethostname` ã§è¿”ã•ã‚Œã‚‹ãƒ›ã‚¹ãƒˆåã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:589
msgid ""
"Translate a host name to IPv4 address format.  The IPv4 address is returned "
"as a string, such as  ``'100.50.200.5'``.  If the host name is an IPv4 "
"address itself it is returned unchanged.  See :func:`gethostbyname_ex` for a"
" more complete interface. :func:`gethostbyname` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"ãƒ›ã‚¹ãƒˆåã‚’ ``'100.50.200.5'`` "
"ã®ã‚ˆã†ãªIPv4å½¢å¼ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«å¤‰æ›ã—ã¾ã™ã€‚ãƒ›ã‚¹ãƒˆåã¨ã—ã¦IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®šã—ãŸå ´åˆã€ãã®å€¤ã¯å¤‰æ›ã›ãšã«ãã®ã¾ã¾è¿”ã‚Šã¾ã™ã€‚ "
":func:`gethostbyname` APIã¸ã®ã‚ˆã‚Šå®Œå…¨ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ãŒå¿…è¦ã§ã‚ã‚Œã°ã€ :func:`gethostbyname_ex` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ :func:`gethostbyname` ã¯ã€IPv6åå‰è§£æ±ºã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚IPv4/ "
"v6ã®ãƒ‡ãƒ¥ã‚¢ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã¯ :func:`getaddrinfo` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:598
msgid ""
"Translate a host name to IPv4 address format, extended interface. Return a "
"triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the primary"
" host name responding to the given *ip_address*, *aliaslist* is a (possibly "
"empty) list of alternative host names for the same address, and *ipaddrlist*"
" is a list of IPv4 addresses for the same interface on the same host (often "
"but not always a single address). :func:`gethostbyname_ex` does not support "
"IPv6 name resolution, and :func:`getaddrinfo` should be used instead for "
"IPv4/v6 dual stack support."
msgstr ""
"ãƒ›ã‚¹ãƒˆåã‹ã‚‰ã€IPv4å½¢å¼ã®å„ç¨®ã‚¢ãƒ‰ãƒ¬ã‚¹æƒ…å ±ã‚’å–å¾—ã—ã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ ``(hostname, aliaslist, ipaddrlist)`` "
"ã®ã‚¿ãƒ—ãƒ«ã§ã€ *hostname* ã¯ *ip_address* ã§æŒ‡å®šã—ãŸãƒ›ã‚¹ãƒˆã®æ­£å¼åã€ *aliaslist* "
"ã¯åŒã˜ã‚¢ãƒ‰ãƒ¬ã‚¹ã®åˆ¥åã®ãƒªã‚¹ãƒˆ(ç©ºã®å ´åˆã‚‚ã‚ã‚‹)ã€ *ipaddrlist* "
"ã¯åŒã˜ãƒ›ã‚¹ãƒˆä¸Šã®åŒä¸€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã®IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒªã‚¹ãƒˆ(ã»ã¨ã‚“ã©ã®å ´åˆã¯å˜ä¸€ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ã¿) ã‚’ç¤ºã—ã¾ã™ã€‚ "
":func:`gethostbyname_ex` ã¯ã€IPv6åå‰è§£æ±ºã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚IPv4/v6ã®ãƒ‡ãƒ¥ã‚¢ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã¯ "
":func:`getaddrinfo` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:610
msgid ""
"Return a string containing the hostname of the machine where  the Python "
"interpreter is currently executing."
msgstr "Pythonã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã‚’ç¾åœ¨å®Ÿè¡Œã—ã¦ã„ã‚‹ãƒã‚·ãƒ³ã®ãƒ›ã‚¹ãƒˆåã‚’å«ã‚€æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:613
msgid ""
"Note: :func:`gethostname` doesn't always return the fully qualified domain "
"name; use :func:`getfqdn` for that."
msgstr ""
"æ³¨æ„: :func:`gethostname` "
"ã¯å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åã‚’è¿”ã™ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åãŒå¿…è¦ã§ã‚ã‚Œã°ã€:func:`getfqdn` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:619
msgid ""
"Return a triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is "
"the primary host name responding to the given *ip_address*, *aliaslist* is a"
" (possibly empty) list of alternative host names for the same address, and "
"*ipaddrlist* is a list of IPv4/v6 addresses for the same interface on the "
"same host (most likely containing only a single address). To find the fully "
"qualified domain name, use the function :func:`getfqdn`. "
":func:`gethostbyaddr` supports both IPv4 and IPv6."
msgstr ""
"``(hostname, aliaslist, ipaddrlist)`` ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã€ *hostname* ã¯ *ip_address* "
"ã§æŒ‡å®šã—ãŸãƒ›ã‚¹ãƒˆã®æ­£å¼åã€ *aliaslist* ã¯åŒã˜ã‚¢ãƒ‰ãƒ¬ã‚¹ã®åˆ¥åã®ãƒªã‚¹ãƒˆ(ç©ºã®å ´åˆã‚‚ã‚ã‚‹)ã€ *ipaddrlist* "
"ã¯åŒã˜ãƒ›ã‚¹ãƒˆä¸Šã®åŒä¸€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã®IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒªã‚¹ãƒˆ(ã»ã¨ã‚“ã©ã®å ´åˆã¯å˜ä¸€ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ã¿)ã‚’ç¤ºã—ã¾ã™ã€‚å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åãŒå¿…è¦ã§ã‚ã‚Œã°ã€ "
":func:`getfqdn` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚ :func:`gethostbyaddr` ã¯ã€IPv4/IPv6ã®ä¸¡æ–¹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/socket.rst:630
msgid ""
"Translate a socket address *sockaddr* into a 2-tuple ``(host, port)``. "
"Depending on the settings of *flags*, the result can contain a fully-"
"qualified domain name or numeric address representation in *host*.  "
"Similarly, *port* can contain a string port name or a numeric port number."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ *sockaddr* ã‹ã‚‰ã€ ``(host, port)`` ã®ã‚¿ãƒ—ãƒ«ã‚’å–å¾—ã—ã¾ã™ã€‚ *flags* ã®è¨­å®šã«å¾“ã„ã€ *host* "
"ã¯å®Œå…¨ä¿®é£¾ãƒ‰ãƒ¡ã‚¤ãƒ³åã¾ãŸã¯æ•°å€¤å½¢å¼ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãªã‚Šã¾ã™ã€‚åŒæ§˜ã«ã€ *port* ã¯æ–‡å­—åˆ—ã®ãƒãƒ¼ãƒˆåã¾ãŸã¯æ•°å€¤ã®ãƒãƒ¼ãƒˆç•ªå·ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:638
msgid ""
"Translate an Internet protocol name (for example, ``'icmp'``) to a constant "
"suitable for passing as the (optional) third argument to the :func:`.socket`"
" function.  This is usually only needed for sockets opened in \"raw\" mode "
"(:const:`SOCK_RAW`); for the normal socket modes, the correct protocol is "
"chosen automatically if the protocol is omitted or zero."
msgstr ""
"(``'icmp'`` ã®ã‚ˆã†ãª) ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ«åã‚’ã€ :func:`.socket` ã® "
"ç¬¬ä¸‰å¼•æ•°ã¨ã—ã¦æŒ‡å®šã™ã‚‹äº‹ãŒã§ãã‚‹å®šæ•°ã«å¤‰æ›ã—ã¾ã™ã€‚ã“ã‚Œã¯ä¸»ã«ã‚½ã‚±ãƒƒãƒˆã‚’ \"raw\" "
"ãƒ¢ãƒ¼ãƒ‰(:const:`SOCK_RAW`)ã§ã‚ªãƒ¼ãƒ—ãƒ³ã™ã‚‹å ´åˆã«ã¯å¿…è¦ã§ã™ãŒã€é€šå¸¸ã® "
"ã‚½ã‚±ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã¯ç¬¬ä¸‰å¼•æ•°ã«0ã‚’æŒ‡å®šã™ã‚‹ã‹çœç•¥ã™ã‚Œã°æ­£ã—ã„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒè‡ªå‹•çš„ã«é¸æŠã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:647
msgid ""
"Translate an Internet service name and protocol name to a port number for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã‚µãƒ¼ãƒ“ã‚¹åã¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‹ã‚‰ã€ãã®ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒãƒ¼ãƒˆç•ªå·ã‚’å–å¾—ã—ã¾ã™ã€‚çœç•¥å¯èƒ½ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«åã¨ã—ã¦ã€ ``'tcp'`` ã‹ "
"``'udp'`` ã®ã©ã¡ã‚‰ã‹ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æŒ‡å®šãŒãªã‘ã‚Œã°ã©ã¡ã‚‰ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/socket.rst:654
msgid ""
"Translate an Internet port number and protocol name to a service name for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒãƒ¼ãƒˆç•ªå·ã¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«åã‹ã‚‰ã€ã‚µãƒ¼ãƒ“ã‚¹åã‚’å–å¾—ã—ã¾ã™ã€‚çœç•¥å¯èƒ½ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«åã¨ã—ã¦ã€ ``'tcp'`` ã‹ ``'udp'`` "
"ã®ã©ã¡ã‚‰ã‹ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æŒ‡å®šãŒãªã‘ã‚Œã°ã©ã¡ã‚‰ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚"

#: ../../library/socket.rst:661
msgid ""
"Convert 32-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"32ãƒ“ãƒƒãƒˆã®æ­£ã®æ•´æ•°ã®ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‚’ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‹ã‚‰ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã«å¤‰æ›ã—ã¾ã™ã€‚ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãŒä¸€è‡´ã™ã‚‹ãƒã‚·ãƒ³ã§ã¯ã€ã“ã®é–¢æ•°ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯4ãƒã‚¤ãƒˆã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/socket.rst:668
msgid ""
"Convert 16-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"16ãƒ“ãƒƒãƒˆã®æ­£ã®æ•´æ•°ã®ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‚’ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‹ã‚‰ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã«å¤‰æ›ã—ã¾ã™ã€‚ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãŒä¸€è‡´ã™ã‚‹ãƒã‚·ãƒ³ã§ã¯ã€ã“ã®é–¢æ•°ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯2ãƒã‚¤ãƒˆã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/socket.rst:675
msgid ""
"Convert 32-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"32ãƒ“ãƒƒãƒˆã®æ­£ã®æ•´æ•°ã®ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‚’ã€ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‹ã‚‰ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã«å¤‰æ›ã—ã¾ã™ã€‚ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãŒä¸€è‡´ã™ã‚‹ãƒã‚·ãƒ³ã§ã¯ã€ã“ã®é–¢æ•°ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯4ãƒã‚¤ãƒˆã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/socket.rst:682
msgid ""
"Convert 16-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"16ãƒ“ãƒƒãƒˆã®æ­£ã®æ•´æ•°ã®ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‚’ã€ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã‹ã‚‰ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã«å¤‰æ›ã—ã¾ã™ã€‚ãƒ›ã‚¹ãƒˆãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãŒä¸€è‡´ã™ã‚‹ãƒã‚·ãƒ³ã§ã¯ã€ã“ã®é–¢æ•°ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯2ãƒã‚¤ãƒˆã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/socket.rst:689
msgid ""
"Convert an IPv4 address from dotted-quad string format (for example, "
"'123.45.67.89') to 32-bit packed binary format, as a bytes object four "
"characters in length.  This is useful when conversing with a program that "
"uses the standard C library and needs objects of type :c:type:`struct "
"in_addr`, which is the C type for the 32-bit packed binary this function "
"returns."
msgstr ""
"ãƒ‰ãƒƒãƒˆè¨˜æ³•ã«ã‚ˆã‚‹IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹(``'123.45.67.89'`` "
"ãªã©)ã‚’32ãƒ“ãƒƒãƒˆã«ãƒ‘ãƒƒã‚¯ã—ãŸãƒã‚¤ãƒŠãƒªå½¢å¼ã«å¤‰æ›ã—ã€é•·ã•4ã®ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ãŒè¿”ã™å€¤ã¯ã€æ¨™æº–Cãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® "
":c:type:`struct in_addr` å‹ã‚’ä½¿ç”¨ã™ã‚‹é–¢æ•°ã«æ¸¡ã™äº‹ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:695
msgid ""
":func:`inet_aton` also accepts strings with less than three dots; see the "
"Unix manual page :manpage:`inet(3)` for details."
msgstr ""
":func:`inet_aton` ã¯ãƒ‰ãƒƒãƒˆãŒ 3 å€‹ä»¥ä¸‹ã®æ–‡å­—åˆ—ã‚‚å—ã‘å–ã‚Šã¾ã™; è©³ç´°ã«ã¤ã„ã¦ã¯ Unix ã®ãƒãƒ‹ãƒ¥ã‚¢ãƒ« "
":manpage:`inet(3)` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:698
msgid ""
"If the IPv4 address string passed to this function is invalid, "
":exc:`OSError` will be raised. Note that exactly what is valid depends on "
"the underlying C implementation of :c:func:`inet_aton`."
msgstr ""
"IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹æ–‡å­—åˆ—ãŒä¸æ­£ã§ã‚ã‚Œã°ã€ :exc:`OSError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ã“ã®ãƒã‚§ãƒƒã‚¯ã¯ã€ã“ã®é–¢æ•°ã§ä½¿ç”¨ã—ã¦ã„ã‚‹Cã®å®Ÿè£… "
":c:func:`inet_aton` ã§è¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:702
msgid ""
":func:`inet_aton` does not support IPv6, and :func:`inet_pton` should be "
"used instead for IPv4/v6 dual stack support."
msgstr ""
":func:`inet_aton` ã¯ã€IPv6ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚IPv4/v6ã®ãƒ‡ãƒ¥ã‚¢ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã¯ "
":func:`inet_pton` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:708
msgid ""
"Convert a 32-bit packed IPv4 address (a :term:`bytes-like object` four bytes"
" in length) to its standard dotted-quad string representation (for example, "
"'123.45.67.89').  This is useful when conversing with a program that uses "
"the standard C library and needs objects of type :c:type:`struct in_addr`, "
"which is the C type for the 32-bit packed binary data this function takes as"
" an argument."
msgstr ""
"32 ãƒ“ãƒƒãƒˆã«ãƒ‘ãƒƒã‚¯ã•ã‚ŒãŸ IPv4 ã‚¢ãƒ‰ãƒ¬ã‚¹ (é•·ã• 4 ãƒã‚¤ãƒˆã® :term:`bytes-like object`) ã‚’ã€æ¨™æº–çš„ãªãƒ‰ãƒƒãƒˆè¨˜æ³•ã«ã‚ˆã‚‹"
" 4 æ¡ã®æ–‡å­—åˆ— (``'123.45.67.89'`` ãªã©) ã«å¤‰æ›ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã€:c:type:`struct in_addr` "
"å‹ã‚’ä½¿ç”¨ã™ã‚‹æ¨™æº– C ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã‚„ã‚Šã¨ã‚Šã™ã‚‹å ´åˆã«ä¾¿åˆ©ã§ã™ã€‚:c:type:`struct in_addr` "
"å‹ã¯ã€ã“ã®é–¢æ•°ãŒå¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚‹ 32 ãƒ“ãƒƒãƒˆã«ãƒ‘ãƒƒã‚¯ã•ã‚ŒãŸãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹ C ã®å‹ã§ã™ã€‚"

#: ../../library/socket.rst:715
msgid ""
"If the byte sequence passed to this function is not exactly 4 bytes in "
"length, :exc:`OSError` will be raised. :func:`inet_ntoa` does not support "
"IPv6, and :func:`inet_ntop` should be used instead for IPv4/v6 dual stack "
"support."
msgstr ""
"ã“ã®é–¢æ•°ã«æ¸¡ã™ãƒã‚¤ãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®é•·ã•ãŒ4ãƒã‚¤ãƒˆä»¥å¤–ã§ã‚ã‚Œã°ã€ :exc:`OSError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚ :func:`inet_ntoa` "
"ã¯ã€IPv6ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã›ã‚“ã€‚IPv4/v6ã®ãƒ‡ãƒ¥ã‚¢ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã¯ :func:`inet_ntop` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:726
msgid ""
"Convert an IP address from its family-specific string format to a packed, "
"binary format. :func:`inet_pton` is useful when a library or network "
"protocol calls for an object of type :c:type:`struct in_addr` (similar to "
":func:`inet_aton`) or :c:type:`struct in6_addr`."
msgstr ""
"IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ã€ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªå›ºæœ‰ã®æ–‡å­—åˆ—ã‹ã‚‰ãƒ‘ãƒƒã‚¯ã—ãŸãƒã‚¤ãƒŠãƒªå½¢å¼ã«å¤‰æ›ã—ã¾ã™ã€‚ :func:`inet_pton` ã¯ã€ "
":c:type:`struct in_addr` å‹ (:func:`inet_aton` ã¨åŒæ§˜)ã‚„ :c:type:`struct "
"in6_addr` ã‚’ä½¿ç”¨ã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å‘¼ã³å‡ºã™éš›ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:731
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and "
":const:`AF_INET6`. If the IP address string *ip_string* is invalid, "
":exc:`OSError` will be raised. Note that exactly what is valid depends on "
"both the value of *address_family* and the underlying implementation of "
":c:func:`inet_pton`."
msgstr ""
"ç¾åœ¨ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ *address_family* ã¯ã€ :const:`AF_INET` ã¨ :const:`AF_INET6` ã§ã™ã€‚ "
"*ip_string* ã«ä¸æ­£ãªIPã‚¢ãƒ‰ãƒ¬ã‚¹æ–‡å­—åˆ—ã‚’æŒ‡å®šã™ã‚‹ã¨ã€ :exc:`OSError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚æœ‰åŠ¹ãª *ip_string* ã¯ã€ "
"*address_family* ã¨ :c:func:`inet_pton` ã®å®Ÿè£…ã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:737 ../../library/socket.rst:757
msgid "Availability: Unix (maybe not all platforms), Windows."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ: Unix (ä¸€éƒ¨ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚’é™¤ã)ã€Windowsã€‚"

#: ../../library/socket.rst:739 ../../library/socket.rst:759
msgid "Windows support added"
msgstr "Windowsã§åˆ©ç”¨å¯èƒ½ã«ãªã‚Šã¾ã—ãŸ"

#: ../../library/socket.rst:745
msgid ""
"Convert a packed IP address (a :term:`bytes-like object` of some number of "
"bytes) to its standard, family-specific string representation (for example, "
"``'7.10.0.5'`` or ``'5aef:2b::8'``). :func:`inet_ntop` is useful when a "
"library or network protocol returns an object of type :c:type:`struct "
"in_addr` (similar to :func:`inet_ntoa`) or :c:type:`struct in6_addr`."
msgstr ""
"ãƒ‘ãƒƒã‚¯ã—ãŸIPã‚¢ãƒ‰ãƒ¬ã‚¹ (æ•°ãƒã‚¤ãƒˆã‹ã‚‰ãªã‚‹ :term:`bytes-like ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <bytes-like object>` ) ã‚’ã€ "
"``'7.10.0.5'`` ã‚„ ``'5aef:2b::8'`` ãªã©ã®æ¨™æº–çš„ãªã€ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªå›ºæœ‰ã®æ–‡å­—åˆ—å½¢å¼ã«å¤‰æ›ã—ã¾ã™ã€‚ "
":func:`inet_ntop` ã¯ (:func:`inet_ntoa` ã¨åŒæ§˜ã«)ã€ :c:type:`struct in_addr` å‹ã‚„ "
":c:type:`struct in6_addr` å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç­‰ã§ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:752
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and "
":const:`AF_INET6`. If the bytes object *packed_ip* is not the correct length"
" for the specified address family, :exc:`ValueError` will be raised. "
":exc:`OSError` is raised for errors from the call to :func:`inet_ntop`."
msgstr ""
"ç¾åœ¨ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ *address_family* ã®å€¤ã¯ã€ :const:`AF_INET` ã¨ :const:`AF_INET6` "
"ã§ã™ã€‚ãƒã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® *packed_ip* ã®é•·ã•ãŒã€æŒ‡å®šã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã§é©åˆ‡ãªé•·ã•ã§ãªã„å ´åˆã€ :exc:`ValueError` "
"ãŒç™ºç”Ÿã—ã¾ã™ã€‚ :func:`inet_ntop` ã®å‘¼ã³å‡ºã—ã§ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã‚‹ã¨ã€ :exc:`OSError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/socket.rst:774
msgid ""
"Return the total length, without trailing padding, of an ancillary data item"
" with associated data of the given *length*.  This value can often be used "
"as the buffer size for :meth:`~socket.recvmsg` to receive a single item of "
"ancillary data, but :rfc:`3542` requires portable applications to use "
":func:`CMSG_SPACE` and thus include space for padding, even when the item "
"will be the last in the buffer.  Raises :exc:`OverflowError` if *length* is "
"outside the permissible range of values."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸ *length* ã«ã‚ã‚‹åˆ¶å¾¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆCMSGï¼‰ã‹ã‚‰ã€æœ«å°¾ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’é™¤ã„ãŸå…¨ä½“ã®é•·ã•ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®å€¤ã¯å¤šãã®å ´åˆã€ "
":meth:`~socket.recvmsg` "
"ãŒåˆ¶å¾¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ä¸€é€£ã®è¦ç´ ã‚’å—ä¿¡ã™ã‚‹ãŸã‚ã®ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã¨ã—ã¦ä½¿ç”¨ã§ãã¾ã™ãŒã€ãƒãƒƒãƒ•ã‚¡ã®æœ«å°¾ãŒè¦ç´ ã§ã‚ã‚‹å ´åˆã§ã‚ã£ã¦ã‚‚ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã¯å«ã¾ã‚Œã‚‹ã®ã§ã€ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã‚’å–å¾—ã™ã‚‹ã«ã¯"
" :rfc:`3542` ã§æ±‚ã‚ã‚‰ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã€ :func:`CMSG_SPACE` ã‚’ä½¿ç”¨ã—ãŸç§»æ¤å¯èƒ½ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒå¿…è¦ã§ã™ã€‚é€šå¸¸ "
"*length* ã¯å®šæ•°ã§ã‚ã‚Šã€è¨±å®¹ç¯„å›²å¤–ã®å€¤ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã¯ :exc:`OverflowError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:783 ../../library/socket.rst:804
#: ../../library/socket.rst:1175 ../../library/socket.rst:1217
#: ../../library/socket.rst:1321
msgid "Availability: most Unix platforms, possibly others."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ: ä¸»ãª Unix ã§åˆ©ç”¨ã§ãã¾ã™ã€‚ä»–ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã‚‚ã€åˆ©ç”¨ã§ãã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:790
msgid ""
"Return the buffer size needed for :meth:`~socket.recvmsg` to receive an "
"ancillary data item with associated data of the given *length*, along with "
"any trailing padding.  The buffer space needed to receive multiple items is "
"the sum of the :func:`CMSG_SPACE` values for their associated data lengths."
"  Raises :exc:`OverflowError` if *length* is outside the permissible range "
"of values."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸ *length* ã®åˆ¶å¾¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆCMSGï¼‰ã®è¦ç´ ã‚’ :meth:`~socket.recvmsg` "
"ãŒå—ä¿¡ã™ã‚‹ãŸã‚ã«å¿…è¦ãªã€ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’å«ã‚ãŸãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã‚’è¿”ã—ã¾ã™ã€‚è¤‡æ•°ã®é …ç›®ã‚’å—ä¿¡ã™ã‚‹ãŸã‚ã«å¿…è¦ãªãƒãƒƒãƒ•ã‚¡ã‚¹ãƒšãƒ¼ã‚¹ã¯ã€ "
":func:`CMSG_SPACE` ãŒè¿”ã™ãã‚Œãã‚Œã®è¦ç´ ã®é•·ã•ã®åˆè¨ˆã§ã™ã€‚é€šå¸¸ *length* ã¯å®šæ•°ã§ã‚ã‚Šã€è¨±å®¹ç¯„å›²å¤–ã®å€¤ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã¯ "
":exc:`OverflowError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:798
msgid ""
"Note that some systems might support ancillary data without providing this "
"function.  Also note that setting the buffer size using the results of this "
"function may not precisely limit the amount of ancillary data that can be "
"received, since additional data may be able to fit into the padding area."
msgstr ""
"ä¸€éƒ¨ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã“ã®é–¢æ•°ã‚’æä¾›ã›ãšã«åˆ¶å¾¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã¾ãŸã€ã“ã®é–¢æ•°ã®è¿”ã‚Šå€¤ã‚’ä½¿ç”¨ã—ã¦è¨­å®šã™ã‚‹ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã¯ã€å—ä¿¡ã™ã‚‹åˆ¶å¾¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é‡ã‚’æ­£ç¢ºã«è¦å®šã—ãªã„ã“ã¨ãŒã‚ã‚Šã€ãã®å¾Œã«å—ä¿¡ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒãƒ‘ãƒ‡ã‚£ãƒ³ã‚°é ˜åŸŸã«åˆã†å ´åˆãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:811
msgid ""
"Return the default timeout in seconds (float) for new socket objects. A "
"value of ``None`` indicates that new socket objects have no timeout. When "
"the socket module is first imported, the default is ``None``."
msgstr ""
"æ–°è¦ã«ç”Ÿæˆã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ã‚’æµ®å‹•å°æ•°ç‚¹å½¢å¼ã®ç§’æ•°ã§è¿”ã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ä½¿ç”¨ã—ãªã„å ´åˆã«ã¯ ``None`` "
"ã‚’è¿”ã—ã¾ã™ã€‚æœ€åˆã« socket ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸæ™‚ã®åˆæœŸå€¤ã¯ ``None`` ã§ã™ã€‚"

#: ../../library/socket.rst:818
msgid ""
"Set the default timeout in seconds (float) for new socket objects.  When the"
" socket module is first imported, the default is ``None``.  See "
":meth:`~socket.settimeout` for possible values and their respective "
"meanings."
msgstr ""
"æ–°è¦ã«ç”Ÿæˆã•ã‚Œã‚‹ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ã‚’ç§’æ•° (float å‹) ã§è¨­å®šã—ã¾ã™ã€‚æœ€åˆã« socket "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸæ™‚ã®åˆæœŸå€¤ã¯ ``None`` ã§ã™ã€‚æŒ‡å®šå¯èƒ½ãªå€¤ã¨ãã®æ„å‘³ã«ã¤ã„ã¦ã¯ :meth:`~socket.settimeout`"
" ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:826
msgid ""
"Set the machine's hostname to *name*.  This will raise an :exc:`OSError` if "
"you don't have enough rights."
msgstr "ãƒã‚·ãƒ³ã®ãƒ›ã‚¹ãƒˆåã‚’ *name* ã«è¨­å®šã—ã¾ã™ã€‚å¿…è¦ãªæ¨©é™ãŒãªã„å ´åˆã¯ :exc:`OSError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/socket.rst:829 ../../library/socket.rst:840
#: ../../library/socket.rst:851 ../../library/socket.rst:862
msgid "Availability: Unix."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ : Unix ã€‚"

#: ../../library/socket.rst:836
msgid ""
"Return a list of network interface information (index int, name string) "
"tuples. :exc:`OSError` if the system call fails."
msgstr ""
"ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹æƒ…å ± (index int, name string)ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ãŒå¤±æ•—ã—ãŸå ´åˆã€ "
":exc:`OSError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/socket.rst:847
msgid ""
"Return a network interface index number corresponding to an interface name. "
":exc:`OSError` if no interface with the given name exists."
msgstr ""
"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹å *if_name* ã«å¯¾å¿œã™ã‚‹ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç•ªå·ã‚’è¿”ã—ã¾ã™ã€‚å¯¾å¿œã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ "
":exc:`OSError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/socket.rst:858
msgid ""
"Return a network interface name corresponding to an interface index number. "
":exc:`OSError` if no interface with the given index exists."
msgstr ""
"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç•ªå· *if_index* ã«å¯¾å¿œã™ã‚‹ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹åã‚’è¿”ã—ã¾ã™ã€‚å¯¾å¿œã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ "
":exc:`OSError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/socket.rst:870
msgid "Socket Objects"
msgstr "socket ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/socket.rst:872
msgid ""
"Socket objects have the following methods.  Except for "
":meth:`~socket.makefile`, these correspond to Unix system calls applicable "
"to sockets."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¡ã¾ã™ã€‚ :meth:`~socket.makefile` "
"ä»¥å¤–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€Unixã®ã‚½ã‚±ãƒƒãƒˆç”¨ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/socket.rst:876
msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`~socket.close`."
msgstr ""
":term:`context manager` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ã‚µãƒãƒ¼ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’çµ‚äº†ã™ã‚‹ã“ã¨ã¯ã€ "
":meth:`~socket.close` ã‚’å‘¼ã¶ã“ã¨ã¨åŒä¸€ã§ã™ã€‚"

#: ../../library/socket.rst:883
msgid ""
"Accept a connection. The socket must be bound to an address and listening "
"for connections. The return value is a pair ``(conn, address)`` where *conn*"
" is a *new* socket object usable to send and receive data on the connection,"
" and *address* is the address bound to the socket on the other end of the "
"connection."
msgstr ""
"æ¥ç¶šã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ã«bindæ¸ˆã¿ã§ã€listenä¸­ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ ``(conn, address)`` ã®ãƒšã‚¢ã§ã€"
" *conn* ã¯æ¥ç¶šã‚’é€šã˜ã¦ãƒ‡ãƒ¼ã‚¿ã®é€å—ä¿¡ã‚’è¡Œã†ãŸã‚ã® *æ–°ã—ã„* ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ *address* "
"ã¯æ¥ç¶šå…ˆã§ã‚½ã‚±ãƒƒãƒˆã«bindã—ã¦ã„ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/socket.rst:890 ../../library/socket.rst:973
msgid "The socket is now non-inheritable."
msgstr "ã‚½ã‚±ãƒƒãƒˆãŒ :ref:`ç¶™æ‰¿ä¸å¯ <fd_inheritance>` ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/socket.rst:893 ../../library/socket.rst:1094
#: ../../library/socket.rst:1108 ../../library/socket.rst:1179
#: ../../library/socket.rst:1250 ../../library/socket.rst:1269
#: ../../library/socket.rst:1284 ../../library/socket.rst:1325
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the method now retries the system call instead of raising an "
":exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ãŒä¸­æ–­ã•ã‚Œã‚·ã‚°ãƒŠãƒ«ãƒãƒ³ãƒ‰ãƒ©ãŒä¾‹å¤–ã‚’é€å‡ºã—ãªã‹ã£ãŸå ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :exc:`InterruptedError` "
"ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ä»£ã‚ã‚Šã«ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’å†è©¦è¡Œã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸ (è«–æ‹ ã«ã¤ã„ã¦ã¯ :pep:`475` ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../library/socket.rst:901
msgid ""
"Bind the socket to *address*.  The socket must not already be bound. (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‚’ *address* ã«bindã—ã¾ã™ã€‚bindæ¸ˆã¿ã®ã‚½ã‚±ãƒƒãƒˆã‚’å†ãƒã‚¤ãƒ³ãƒ‰ã™ã‚‹äº‹ã¯ã§ãã¾ã›ã‚“ã€‚(*address* "
"ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ -- å‰è¿°ã€‚)"

#: ../../library/socket.rst:907
msgid ""
"Mark the socket closed.  The underlying system resource (e.g. a file "
"descriptor) is also closed when all file objects from :meth:`makefile()` are"
" closed.  Once that happens, all future operations on the socket object will"
" fail. The remote end will receive no more data (after queued data is "
"flushed)."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‚’é–‰ã˜ã‚‰ã‚ŒãŸã‚‚ã®ã¨ã—ã¦ãƒãƒ¼ã‚¯ã—ã¾ã™ã€‚ :meth:`makefile()` "
"ãŒè¿”ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é–‰ã˜ã‚‹æ™‚ã€å¯¾å¿œã™ã‚‹ä¸‹å±¤ã®ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚½ãƒ¼ã‚¹ï¼ˆä¾‹ï¼šãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ï¼‰ã‚‚ã™ã¹ã¦é–‰ã˜ã¾ã™ã€‚ä¸€åº¦ã“ã®æ“ä½œã‚’ã™ã‚‹ã¨ã€ãã®å¾Œã€ã“ã®ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ã™ã¹ã¦ã®æ“ä½œãŒå¤±æ•—ã—ã¾ã™ã€‚ã‚­ãƒ¥ãƒ¼ã«æºœã¾ã£ãŸãƒ‡ãƒ¼ã‚¿ãŒãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸå¾Œã¯ã€ãƒªãƒ¢ãƒ¼ãƒˆå´ã®ç«¯ç‚¹ã§ã¯ãã‚Œä»¥ä¸Šã®ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:913
msgid ""
"Sockets are automatically closed when they are garbage-collected, but it is "
"recommended to :meth:`close` them explicitly, or to use a :keyword:`with` "
"statement around them."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã¯ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æ™‚ã«è‡ªå‹•çš„ã«ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€æ˜ç¤ºçš„ã« :meth:`close` ã™ã‚‹ã‹ã€ :keyword:`with` "
"æ–‡ã®ä¸­ã§ã‚½ã‚±ãƒƒãƒˆã‚’ä½¿ã†ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:917
msgid ""
":exc:`OSError` is now raised if an error occurs when the underlying "
":c:func:`close` call is made."
msgstr "ä¸‹å±¤ã® :c:func:`close` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹æ™‚ã€:exc:`OSError` ãŒé€å‡ºã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/socket.rst:923
msgid ""
":meth:`close()` releases the resource associated with a connection but does "
"not necessarily close the connection immediately.  If you want to close the "
"connection in a timely fashion, call :meth:`shutdown()` before "
":meth:`close()`."
msgstr ""
":meth:`close()` ã¯æ¥ç¶šã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ã‚’è§£æ”¾ã—ã¾ã™ãŒã€æ¥ç¶šã‚’ã™ãã«åˆ‡æ–­ã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚æ¥ç¶šã‚’å³åº§ã«åˆ‡æ–­ã—ãŸã„å ´åˆã¯ã€ "
":meth:`close()` ã®å‰ã« :meth:`shutdown()` ã‚’å‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:931
msgid ""
"Connect to a remote socket at *address*. (The format of *address* depends on"
" the address family --- see above.)"
msgstr ""
"*address* ã§ç¤ºã•ã‚Œã‚‹ãƒªãƒ¢ãƒ¼ãƒˆã‚½ã‚±ãƒƒãƒˆã«æ¥ç¶šã—ã¾ã™ã€‚(*address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ --- å‰è¿°ã€‚)"

#: ../../library/socket.rst:934
msgid ""
"If the connection is interrupted by a signal, the method waits until the "
"connection completes, or raise a :exc:`socket.timeout` on timeout, if the "
"signal handler doesn't raise an exception and the socket is blocking or has "
"a timeout. For non-blocking sockets, the method raises an "
":exc:`InterruptedError` exception if the connection is interrupted by a "
"signal (or the exception raised by the signal handler)."
msgstr ""
"æ¥ç¶šãŒä¿¡å·ã«ã‚ˆã£ã¦ä¸­æ–­ã•ã‚ŒãŸå ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ¥ç¶šãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…æ©Ÿã™ã‚‹ã‹ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã« :exc:`socket.timeout` "
"ã‚’é€å‡ºã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯ã€ä¿¡å·ãƒãƒ³ãƒ‰ãƒ©ãŒä¾‹å¤–ã‚’é€å‡ºã›ãšã€ã‚½ã‚±ãƒƒãƒˆãŒãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã‹ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã«èµ·ã“ã‚Šã¾ã™ã€‚éãƒ–ãƒ­ãƒƒã‚¯ã‚½ã‚±ãƒƒãƒˆã§ã¯ã€æ¥ç¶šãŒä¿¡å·ã«ã‚ˆã£ã¦ä¸­æ–­ã•ã‚ŒãŸå ´åˆ"
" (ã‚ã‚‹ã„ã¯ä¿¡å·ãƒãƒ³ãƒ‰ãƒ©ã«ã‚ˆã‚Šä¾‹å¤–ãŒé€å‡ºã•ã‚ŒãŸå ´åˆ)ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :exc:`InterruptedError` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/socket.rst:941
msgid ""
"The method now waits until the connection completes instead of raising an "
":exc:`InterruptedError` exception if the connection is interrupted by a "
"signal, the signal handler doesn't raise an exception and the socket is "
"blocking or has a timeout (see the :pep:`475` for the rationale)."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æ¥ç¶šãŒä¿¡å·ã«ã‚ˆã£ã¦ä¸­æ–­ã•ã‚Œã€ä¿¡å·ãƒãƒ³ãƒ‰ãƒ©ãŒä¾‹å¤–ã‚’é€å‡ºã›ãšã€ã‚½ã‚±ãƒƒãƒˆãŒãƒ–ãƒ­ãƒƒã‚¯ã§ã‚ã‚‹ã‹ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€:exc:`InterruptedError`"
"Â ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ä»£ã‚ã‚Šã«ã€æ¥ç¶šã‚’å®Œäº†ã™ã‚‹ã¾ã§å¾…æ©Ÿã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸ (è«–æ‹ ã«ã¤ã„ã¦ã¯ :pep:`475`  ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../library/socket.rst:950
msgid ""
"Like ``connect(address)``, but return an error indicator instead of raising "
"an exception for errors returned by the C-level :c:func:`connect` call "
"(other problems, such as \"host not found,\" can still raise exceptions).  "
"The error indicator is ``0`` if the operation succeeded, otherwise the value"
" of the :c:data:`errno` variable.  This is useful to support, for example, "
"asynchronous connects."
msgstr ""
"``connect(address)`` ã¨åŒæ§˜ã§ã™ãŒã€Cè¨€èªã® :c:func:`connect` "
"é–¢æ•°ã®å‘¼ã³å‡ºã—ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«ã¯ä¾‹å¤–ã‚’é€å‡ºã›ãšã«ã‚¨ãƒ©ãƒ¼ã‚’æˆ»ã‚Šå€¤ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚(ã“ã‚Œä»¥å¤–ã®ã€\"host not "
"found,\"ç­‰ã®ã‚¨ãƒ©ãƒ¼ã®å ´åˆã«ã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚)å‡¦ç†ãŒæ­£å¸¸ã«çµ‚äº†ã—ãŸå ´åˆã«ã¯ ``0`` ã‚’è¿”ã—ã€ã‚¨ãƒ©ãƒ¼æ™‚ã«ã¯ :c:data:`errno` "
"ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã€éåŒæœŸæ¥ç¶šã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å ´åˆãªã©ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:960
msgid ""
"Put the socket object into closed state without actually closing the "
"underlying file descriptor.  The file descriptor is returned, and can be "
"reused for other purposes."
msgstr ""
"å®Ÿéš›ã«ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’é–‰ã˜ã‚‹ã“ã¨ãªãã€ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é–‰ã˜ãŸçŠ¶æ…‹ã«ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã¯è¿”å´ã•ã‚Œã€ä»–ã®ç›®çš„ã«å†åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:969
msgid "Duplicate the socket."
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚’è¤‡è£½ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:979
msgid ""
"Return the socket's file descriptor (a small integer), or -1 on failure. "
"This is useful with :func:`select.select`."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’çŸ­ã„æ•´æ•°å‹ã§è¿”ã—ã¾ã™ã€‚å¤±æ•—æ™‚ã«ã¯ã€-1 ã‚’è¿”ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã¯ã€ :func:`select.select` "
"ãªã©ã§ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:982
msgid ""
"Under Windows the small integer returned by this method cannot be used where"
" a file descriptor can be used (such as :func:`os.fdopen`).  Unix does not "
"have this limitation."
msgstr ""
"Windowsã§ã¯ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§è¿”ã•ã‚ŒãŸå°æ•´æ•°ã‚’ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’æ‰±ã†ç®‡æ‰€ (:func:`os.fdopen` ãªã©) ã§åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚ Unix "
"ã«ã¯ã“ã®åˆ¶é™ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:988
msgid ""
"Get the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle: ``True`` if the socket can be inherited in "
"child processes, ``False`` if it cannot."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã¾ãŸã¯ã‚½ã‚±ãƒƒãƒˆã®ãƒãƒ³ãƒ‰ãƒ«ã® :ref:`ç¶™æ‰¿å¯èƒ½ãƒ•ãƒ©ã‚° <fd_inheritance>` "
"ã‚’å–å¾—ã—ã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆãŒå­ãƒ—ãƒ­ã‚»ã‚¹ã¸ç¶™æ‰¿å¯èƒ½ãªã‚‰ ``True`` ã€ç¶™æ‰¿ä¸å¯ãªã‚‰ ``False`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:997
msgid ""
"Return the remote address to which the socket is connected.  This is useful "
"to find out the port number of a remote IPv4/v6 socket, for instance. (The "
"format of the address returned depends on the address family --- see above.)"
"  On some systems this function is not supported."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆãŒæ¥ç¶šã—ã¦ã„ã‚‹ãƒªãƒ¢ãƒ¼ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã€ãƒªãƒ¢ãƒ¼ãƒˆ IPv4/v6ã‚½ã‚±ãƒƒãƒˆã®ãƒãƒ¼ãƒˆç•ªå·ã‚’èª¿ã¹ã‚‹å ´åˆãªã©ã«ä½¿ç”¨ã—ã¾ã™ã€‚ "
"*address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™(å‰è¿°)ã€‚ã“ã®é–¢æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã‚·ã‚¹ãƒ†ãƒ ã‚‚å­˜åœ¨ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:1005
msgid ""
"Return the socket's own address.  This is useful to find out the port number"
" of an IPv4/v6 socket, for instance. (The format of the address returned "
"depends on the address family --- see above.)"
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆè‡ªèº«ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã€IPv4/v6ã‚½ã‚±ãƒƒãƒˆã®ãƒãƒ¼ãƒˆç•ªå·ã‚’èª¿ã¹ã‚‹å ´åˆãªã©ã«ä½¿ç”¨ã—ã¾ã™ã€‚(*address* "
"ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ --- å‰è¿°ã€‚)"

#: ../../library/socket.rst:1012
msgid ""
"Return the value of the given socket option (see the Unix man page "
":manpage:`getsockopt(2)`).  The needed symbolic constants (:const:`SO_\\*` "
"etc.) are defined in this module.  If *buflen* is absent, an integer option "
"is assumed and its integer value is returned by the function.  If *buflen* "
"is present, it specifies the maximum length of the buffer used to receive "
"the option in, and this buffer is returned as a bytes object.  It is up to "
"the caller to decode the contents of the buffer (see the optional built-in "
"module :mod:`struct` for a way to decode C structures encoded as byte "
"strings)."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã«æŒ‡å®šã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿”ã—ã¾ã™(Unixã®ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ :manpage:`getsockopt(2)` ã‚’å‚ç…§)ã€‚ "
":const:`SO_\\*` ç­‰ã®ã‚·ãƒ³ãƒœãƒ«ã¯ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ *buflen* "
"ã‚’çœç•¥ã—ãŸå ´åˆã€å–å¾—ã™ã‚‹ã‚ªãƒ–ã‚·ãƒ§ãƒ³ã¯æ•´æ•°ã¨ã¿ãªã—ã€æ•´æ•°å‹ã®å€¤ã‚’æˆ»ã‚Šå€¤ã¨ã—ã¾ã™ã€‚ *buflen* ã‚’æŒ‡å®šã—ãŸå ´åˆã€é•·ã• *buflen* "
"ã®ãƒãƒƒãƒ•ã‚¡ã§ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’å—ã‘å–ã‚Šã€ã“ã®ãƒãƒƒãƒ•ã‚¡ã‚’ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ã“ã®ãƒãƒƒãƒ•ã‚¡ã¯ã€å‘¼ã³å‡ºã—å…ƒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ :mod:`struct` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç­‰ã‚’åˆ©ç”¨ã—ã¦å†…å®¹ã‚’èª­ã¿å–ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:1024
msgid ""
"Return the timeout in seconds (float) associated with socket operations, or "
"``None`` if no timeout is set.  This reflects the last call to "
":meth:`setblocking` or :meth:`settimeout`."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã«æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ã‚’å–å¾—ã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯æµ®å‹•å°æ•°ç‚¹å‹ã§ç§’æ•°ãŒã€è¨­å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã° ``None`` "
"ãŒè¿”ã‚Šã¾ã™ã€‚ã“ã®å€¤ã¯ã€æœ€å¾Œã«å‘¼ã³å‡ºã•ã‚ŒãŸ :meth:`setblocking` ã¾ãŸã¯ :meth:`settimeout` ã«ã‚ˆã£ã¦è¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:0
msgid "platform"
msgstr "ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ "

#: ../../library/socket.rst:1031
msgid "Windows"
msgstr "Windows"

#: ../../library/socket.rst:1033
msgid ""
"The :meth:`ioctl` method is a limited interface to the WSAIoctl system "
"interface.  Please refer to the `Win32 documentation "
"<https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx>`_ for "
"more information."
msgstr ""
":meth:`ioctl` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ WSAIoctl ã‚·ã‚¹ãƒ†ãƒ ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¸ã®åˆ¶é™ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§ã™ã€‚è©³ã—ã„æƒ…å ±ã«ã¤ã„ã¦ã¯ã€ `Win32 "
"documentation <https://msdn.microsoft.com/en-"
"us/library/ms741621%28VS.85%29.aspx>`_ ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:1038
msgid ""
"On other platforms, the generic :func:`fcntl.fcntl` and :func:`fcntl.ioctl` "
"functions may be used; they accept a socket object as their first argument."
msgstr ""
"ä»–ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ä¸€èˆ¬çš„ãª :func:`fcntl.fcntl` ã¨ :func:`fcntl.ioctl` ãŒä½¿ã‚ã‚Œã‚‹ã§ã—ã‚‡ã†; "
"ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ç¬¬ 1 å¼•æ•°ã¨ã—ã¦ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:1041
msgid ""
"Currently only the following control codes are supported: ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS``, and ``SIO_LOOPBACK_FAST_PATH``."
msgstr ""
"ç¾åœ¨ã€ä»¥ä¸‹ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚³ãƒ¼ãƒ‰ã®ã¿ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚ ``SIO_RCVALL``, ``SIO_KEEPALIVE_VALS``, "
"``SIO_LOOPBACK_FAST_PATH``ã€‚"

#: ../../library/socket.rst:1049
msgid ""
"Enable a server to accept connections.  If *backlog* is specified, it must "
"be at least 0 (if it is lower, it is set to 0); it specifies the number of "
"unaccepted connections that the system will allow before refusing new "
"connections. If not specified, a default reasonable value is chosen."
msgstr ""
"ã‚µãƒ¼ãƒãƒ¼ã‚’æœ‰åŠ¹ã«ã—ã¦ã€æ¥ç¶šã‚’å—ã‘ä»˜ã‘ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚*backlog* ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€å°‘ãªãã¨ã‚‚ 0 ä»¥ä¸Šã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ "
"(ãã‚Œã‚ˆã‚Šä½ã„å ´åˆã€0 "
"ã«è¨­å®šã•ã‚Œã¾ã™)ã€‚ã‚·ã‚¹ãƒ†ãƒ ãŒæ–°ã—ã„æ¥ç¶šã‚’æ‹’å¦ã™ã‚‹ã¾ã§ã«è¨±å¯ã™ã‚‹æœªå—ä»˜ã®æ¥ç¶šã®æ•°ã‚’æŒ‡å®šã—ã¾ã™ã€‚æŒ‡å®šã—ãªã„å ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å¦¥å½“ãªå€¤ãŒé¸æŠã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:1054
msgid "The *backlog* parameter is now optional."
msgstr "*backlog* å¼•æ•°ãŒä»»æ„ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/socket.rst:1062
msgid ""
"Return a :term:`file object` associated with the socket.  The exact returned"
" type depends on the arguments given to :meth:`makefile`.  These arguments "
"are interpreted the same way as by the built-in :func:`open` function, "
"except the only supported *mode* values are ``'r'`` (default), ``'w'`` and "
"``'b'``."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸ :term:`ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <file object>` ã‚’è¿”ã—ã¾ã™ã€‚æˆ»ã‚Šå€¤ã®æ­£ç¢ºãªå‹ã¯ã€ "
":meth:`makefile` ã«æŒ‡å®šã—ãŸå¼•æ•°ã«ã‚ˆã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®å¼•æ•°ã¯ã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`open` "
"ã®å¼•æ•°ã¨åŒæ§˜ã«è§£é‡ˆã•ã‚Œã¾ã™ã€‚ãŸã ã—ã€*mode* ã®å€¤ã¯  ``'r'`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ), ``'w'``, ``'b'`` "
"ã®ã¿ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/socket.rst:1067
msgid ""
"The socket must be in blocking mode; it can have a timeout, but the file "
"object's internal buffer may end up in an inconsistent state if a timeout "
"occurs."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã¯ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®šã™ã‚‹ã“ã¨ã¯ã§ãã¾ã™ãŒã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç™ºç”Ÿã™ã‚‹ã¨ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…éƒ¨ãƒãƒƒãƒ•ã‚¡ãŒçŸ›ç›¾ã—ãŸçŠ¶æ…‹ã«ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:1071
msgid ""
"Closing the file object returned by :meth:`makefile` won't close the "
"original socket unless all other file objects have been closed and "
":meth:`socket.close` has been called on the socket object."
msgstr ""
":meth:`makefile` "
"ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚½ã‚±ãƒƒãƒˆã‚’é–¢é€£ã¥ã‘ãŸå ´åˆã€ã‚½ã‚±ãƒƒãƒˆã‚’é–‰ã˜ã‚‹ã«ã¯ã€é–¢é€£ã¥ã‘ã‚‰ã‚ŒãŸã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é–‰ã˜ãŸã‚ã¨ã§ã€å…ƒã®ã‚½ã‚±ãƒƒãƒˆã® "
":meth:`socket.close` ã‚’å‘¼ã³å‡ºã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:1077
msgid ""
"On Windows, the file-like object created by :meth:`makefile` cannot be used "
"where a file object with a file descriptor is expected, such as the stream "
"arguments of :meth:`subprocess.Popen`."
msgstr ""
"Windows ã§ã¯ :meth:`subprocess.Popen` ã® stream å¼•æ•°ãªã©ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¤ã file "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæœŸå¾…ã•ã‚Œã¦ã„ã‚‹å ´æ‰€ã§ã¯ã€ :meth:`makefile` ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã‚‹ file-like ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:1084
msgid ""
"Receive data from the socket.  The return value is a bytes object "
"representing the data received.  The maximum amount of data to be received "
"at once is specified by *bufsize*.  See the Unix manual page "
":manpage:`recv(2)` for the meaning of the optional argument *flags*; it "
"defaults to zero."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã€çµæœã‚’ bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§è¿”ã—ã¾ã™ã€‚ä¸€åº¦ã«å—ä¿¡ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã¯ã€æœ€å¤§ã§ã‚‚ *bufsize* "
"ã§æŒ‡å®šã—ãŸé‡ã§ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *flags* ã«æŒ‡å®šã™ã‚‹ãƒ•ãƒ©ã‚°ã®æ„å‘³ã«ã¤ã„ã¦ã¯ã€ Unix ã®ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ :manpage:`recv(2)`"
" ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ *flags* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ 0 ã§ã™ã€‚"

#: ../../library/socket.rst:1091
msgid ""
"For best match with hardware and network realities, the value of  *bufsize* "
"should be a relatively small power of 2, for example, 4096."
msgstr ""
"ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãŠã‚ˆã³ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ç¾å®Ÿã«æœ€å¤§é™ãƒãƒƒãƒã™ã‚‹ã‚ˆã†ã«ã€ *bufsize* ã®å€¤ã¯æ¯”è¼ƒçš„å°ã•ã„2ã®ç´¯ä¹—ã€ãŸã¨ãˆã° 4096ã€ã«ã™ã¹ãã§ã™ã€‚"

#: ../../library/socket.rst:1102
msgid ""
"Receive data from the socket.  The return value is a pair ``(bytes, "
"address)`` where *bytes* is a bytes object representing the data received "
"and *address* is the address of the socket sending the data.  See the Unix "
"manual page :manpage:`recv(2)` for the meaning of the optional argument "
"*flags*; it defaults to zero. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã€çµæœã‚’ã‚¿ãƒ—ãƒ« ``(bytes, address)`` ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ *bytes* ã¯å—ä¿¡ãƒ‡ãƒ¼ã‚¿ã® bytes "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€ *address* ã¯é€ä¿¡å…ƒã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ç¤ºã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *flags* ã«ã¤ã„ã¦ã¯ã€ Unix ã®ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ "
":manpage:`recv(2)` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯0ã§ã™ã€‚ (*address* "
"ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™(å‰è¿°))"

#: ../../library/socket.rst:1116
msgid ""
"Receive normal data (up to *bufsize* bytes) and ancillary data from the "
"socket.  The *ancbufsize* argument sets the size in bytes of the internal "
"buffer used to receive the ancillary data; it defaults to 0, meaning that no"
" ancillary data will be received.  Appropriate buffer sizes for ancillary "
"data can be calculated using :func:`CMSG_SPACE` or :func:`CMSG_LEN`, and "
"items which do not fit into the buffer might be truncated or discarded.  The"
" *flags* argument defaults to 0 and has the same meaning as for "
":meth:`recv`."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰é€šå¸¸ã®ãƒ‡ãƒ¼ã‚¿ (æœ€å¤§ *bufsize* ãƒã‚¤ãƒˆ) ã¨è£œåŠ©çš„ãªãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã¾ã™ã€‚*ancbufsize* "
"å¼•æ•°ã«ã‚ˆã‚Šã€è£œåŠ©çš„ãªãƒ‡ãƒ¼ã‚¿ã®å—ä¿¡ã«ä½¿ç”¨ã•ã‚Œã‚‹å†…éƒ¨ãƒãƒƒãƒ•ã‚¡ã®ãƒã‚¤ãƒˆæ•°ã¨ã—ã¦ã€ã‚µã‚¤ã‚ºãŒè¨­å®šã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ 0 "
"ã§ã€è£œåŠ©çš„ãªãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚:func:`CMSG_SPACE` ã¾ãŸã¯ :func:`CMSG_LEN` "
"ã‚’ä½¿ç”¨ã—ã¦ã€è£œåŠ©çš„ãªãƒ‡ãƒ¼ã‚¿ã®é©åˆ‡ãªã‚µã‚¤ã‚ºã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ãŒã§ãã€ãƒãƒƒãƒ•ã‚¡å†…ã«åã¾ã‚‰ãªã„ã‚¢ã‚¤ãƒ†ãƒ ã¯ã€çŸ­ç¸®ã•ã‚Œã‚‹ã‹ç ´æ£„ã•ã‚Œã¾ã™ã€‚*flags* "
"å¼•æ•°ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ 0 ã§ã€:meth:`recv` ã§ã®æ„å‘³ã¨åŒã˜æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/socket.rst:1126
msgid ""
"The return value is a 4-tuple: ``(data, ancdata, msg_flags, address)``.  The"
" *data* item is a :class:`bytes` object holding the non-ancillary data "
"received.  The *ancdata* item is a list of zero or more tuples "
"``(cmsg_level, cmsg_type, cmsg_data)`` representing the ancillary data "
"(control messages) received: *cmsg_level* and *cmsg_type* are integers "
"specifying the protocol level and protocol-specific type respectively, and "
"*cmsg_data* is a :class:`bytes` object holding the associated data.  The "
"*msg_flags* item is the bitwise OR of various flags indicating conditions on"
" the received message; see your system documentation for details. If the "
"receiving socket is unconnected, *address* is the address of the sending "
"socket, if available; otherwise, its value is unspecified."
msgstr ""
"æˆ»ã‚Šå€¤ã¯ 4 è¦ç´ ã®ã‚¿ãƒ—ãƒ« ``(data, ancdata, msg_flags, address)`` ã§ã™ã€‚*data* "
"ã‚¢ã‚¤ãƒ†ãƒ ã¯ã€å—ä¿¡ã—ãŸéä»˜å±çš„ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã™ã‚‹ :class:`bytes`Â ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚*ancdata* ã‚¢ã‚¤ãƒ†ãƒ ã¯ã€ã‚¼ãƒ­ä»¥ä¸Šã®ã‚¿ãƒ—ãƒ« "
"``(cmsg_level, cmsg_type, cmsg_data)`` ã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã§ã€å—ä¿¡ã™ã‚‹ä»˜å±çš„ãªãƒ‡ãƒ¼ã‚¿ (åˆ¶å¾¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸) "
"ã‚’è¡¨ã—ã¾ã™ã€‚*cmsg_level* ã¨ *cmsg_type* "
"ã¯ãã‚Œãã‚Œã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒ¬ãƒ™ãƒ«ã¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«å›ºæœ‰ã®ã‚¿ã‚¤ãƒ—ã‚’æŒ‡å®šã™ã‚‹æ•´æ•°ã§ã€*cmsg_data* ã¯é–¢é€£ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã™ã‚‹ :class:`bytes` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚*msg_flags* ã‚¢ã‚¤ãƒ†ãƒ ã¯ã€å—ä¿¡ã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ¡ä»¶ã‚’ç¤ºã™æ§˜ã€…ãªãƒ•ãƒ©ã‚°ã®ãƒ“ãƒƒãƒˆ OR "
"ã§ã™ã€‚è©³ç´°ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚å—ä¿¡ã‚½ã‚±ãƒƒãƒˆãŒæ¥ç¶šã•ã‚Œã¦ã„ãªã„å ´åˆã€*address* "
"ã¯ã€é€ä¿¡ã‚½ã‚±ãƒƒãƒˆãŒåˆ©ç”¨ã§ãã‚‹å ´åˆã«ã¯ãã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã€åˆ©ç”¨ã§ããªã„å ´åˆã€ãã®å€¤ã¯æœªæŒ‡å®šã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:1140
msgid ""
"On some systems, :meth:`sendmsg` and :meth:`recvmsg` can be used to pass "
"file descriptors between processes over an :const:`AF_UNIX` socket.  When "
"this facility is used (it is often restricted to :const:`SOCK_STREAM` "
"sockets), :meth:`recvmsg` will return, in its ancillary data, items of the "
"form ``(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)``, where *fds* is a "
":class:`bytes` object representing the new file descriptors as a binary "
"array of the native C :c:type:`int` type.  If :meth:`recvmsg` raises an "
"exception after the system call returns, it will first attempt to close any "
"file descriptors received via this mechanism."
msgstr ""
"ä¸€éƒ¨ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€:meth:`sendmsg` ã¨ :meth:`recvmsg` ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ—ãƒ­ã‚»ã‚¹é–“ã§ :const:`AF_UNIX` "
"ã‚½ã‚±ãƒƒãƒˆã‚’çµŒç”±ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆ (ã—ã°ã—ã° :const:`SOCK_STREAM` "
"ã‚½ã‚±ãƒƒãƒˆã«é™å®šã•ã‚Œã¾ã™)ã€:meth:`recvmsg`Â ã¯ã€ä»˜å±çš„ãªãƒ‡ãƒ¼ã‚¿ä¸­ã«ã€``(socket.SOL_SOCKET, "
"socket.SCM_RIGHTS, fds)`` ã¨ã„ã†å½¢å¼ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿”ã—ã¾ã™ã€‚ã“ã“ã§ã€*fds* ã¯ã€æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’ãƒã‚¤ãƒ†ã‚£ãƒ– C ã® "
":c:type:`int` å‹ã®ãƒã‚¤ãƒŠãƒªé…åˆ—ã¨ã—ã¦è¡¨ã—ã¾ã™ã€‚ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ãŒè¿”ã£ãŸå¾Œ :meth:`recvmsg`Â "
"ãŒä¾‹å¤–ã‚’é€å‡ºã™ã‚‹å ´åˆã€ã¾ãšã“ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’çµŒç”±ã—ã¦å—ä¿¡ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’å…¨ã¦é–‰ã˜ã‚ˆã†ã¨è©¦ã¿ã¾ã™ã€‚"

#: ../../library/socket.rst:1151
msgid ""
"Some systems do not indicate the truncated length of ancillary data items "
"which have been only partially received.  If an item appears to extend "
"beyond the end of the buffer, :meth:`recvmsg` will issue a "
":exc:`RuntimeWarning`, and will return the part of it which is inside the "
"buffer provided it has not been truncated before the start of its associated"
" data."
msgstr ""
"ä¸€éƒ¨ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€éƒ¨åˆ†çš„ã«å—ä¿¡ã—ãŸä»˜å±çš„ãªãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¤ãƒ†ãƒ ã®çŸ­ç¸®ã•ã‚ŒãŸé•·ã•ãŒç¤ºã•ã‚Œã¾ã›ã‚“ã€‚ã‚¢ã‚¤ãƒ†ãƒ ãŒãƒãƒƒãƒ•ã‚¡ã®æœ«å°¾ã‚’è¶…ãˆã¦ã„ã‚‹ã‚ˆã†ã§ã‚ã‚‹å ´åˆã€:meth:`recvmsg`"
"Â ã¯ :exc:`RuntimeWarning` "
"ã‚’é€å‡ºã—ã€é–¢é€£ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®é–‹å§‹ä½ç½®ã‚ˆã‚Šå‰ã§é€”åˆ‡ã‚Œã¦ã„ãªã„å ´åˆã€ãƒãƒƒãƒ•ã‚¡å†…ã®ä»˜å±çš„ãªãƒ‡ãƒ¼ã‚¿ã®ä¸€éƒ¨ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:1158
msgid ""
"On systems which support the :const:`SCM_RIGHTS` mechanism, the following "
"function will receive up to *maxfds* file descriptors, returning the message"
" data and a list containing the descriptors (while ignoring unexpected "
"conditions such as unrelated control messages being received).  See also "
":meth:`sendmsg`. ::"
msgstr ""
":const:`SCM_RIGHTS` ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ä¸Šã§ã¯ã€æ¬¡ã®é–¢æ•°ãŒæœ€å¤§ *maxfds* "
"ã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’å—ä¿¡ã—ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ã¨è¨˜è¿°å­ã‚’å«ã‚€ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾(ç„¡é–¢ä¿‚ãªåˆ¶å¾¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ä¿¡ã—ãŸå ´åˆãªã©ã€äºˆæœŸã—ãªã„æ¡ä»¶ã¯ç„¡è¦–ã—ã¾ã™)ã€‚ "
":meth:`sendmsg` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:1187
msgid ""
"Receive normal data and ancillary data from the socket, behaving as "
":meth:`recvmsg` would, but scatter the non-ancillary data into a series of "
"buffers instead of returning a new bytes object.  The *buffers* argument "
"must be an iterable of objects that export writable buffers (e.g. "
":class:`bytearray` objects); these will be filled with successive chunks of "
"the non-ancillary data until it has all been written or there are no more "
"buffers.  The operating system may set a limit (:func:`~os.sysconf` value "
"``SC_IOV_MAX``) on the number of buffers that can be used.  The *ancbufsize*"
" and *flags* arguments have the same meaning as for :meth:`recvmsg`."
msgstr ""
":meth:`recvmsg` "
"ã¨åŒæ§˜ã«å‹•ä½œã—ã¦ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰é€šå¸¸ã®ãƒ‡ãƒ¼ã‚¿ã¨ä»˜å±çš„ãªãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã¾ã™ãŒã€éä»˜å±çš„ãƒ‡ãƒ¼ã‚¿ã¯æ–°ã—ã„ãƒã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã™ã®ã§ã¯ãªãã€ä¸€é€£ã®ãƒãƒƒãƒ•ã‚¡ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚*buffers*"
" å¼•æ•°ã¯æ›¸ãè¾¼ã¿å¯èƒ½ãªãƒãƒƒãƒ•ã‚¡ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ (ä¾‹: :class:`bytearray` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ)ã€‚ã“ã‚Œã‚‰ã¯ã€å…¨ã¦ã«æ›¸ãè¾¼ã¾ã‚Œã‚‹ã‹ã€æ®‹ã‚Šãƒãƒƒãƒ•ã‚¡ãŒãªããªã‚‹ã¾ã§ã€éä»˜å±çš„ãƒ‡ãƒ¼ã‚¿ã®é€£ç¶šãƒãƒ£ãƒ³ã‚¯ã§åŸ‹ã‚ã‚‰ã‚Œã¾ã™ã€‚ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ã€ä½¿ç”¨ã§ãã‚‹ãƒãƒƒãƒ•ã‚¡ã®æ•°ãŒåˆ¶é™"
" (:func:`~os.sysconf` å€¤ ``SC_IOV_MAX``) ã•ã‚Œã¦ã„ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚*ancbufsize* å¼•æ•°ã¨ "
"*flags* å¼•æ•°ã¯ã€:meth:`recvmsg` ã§ã®æ„å‘³ã¨åŒã˜æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/socket.rst:1198
msgid ""
"The return value is a 4-tuple: ``(nbytes, ancdata, msg_flags, address)``, "
"where *nbytes* is the total number of bytes of non-ancillary data written "
"into the buffers, and *ancdata*, *msg_flags* and *address* are the same as "
"for :meth:`recvmsg`."
msgstr ""
"æˆ»ã‚Šå€¤ã¯ 4 è¦ç´ ã®ã‚¿ãƒ—ãƒ« ``(nbytes, ancdata, msg_flags, address)`` ã§ã™ã€‚ã“ã“ã§ã€*nbytes* "
"ã¯ãƒãƒƒãƒ•ã‚¡ã«æ›¸ãè¾¼ã¾ã‚ŒãŸéä»˜å±çš„ãƒ‡ãƒ¼ã‚¿ã®ç·æ•°ã§ã€*ancdata*ã€*msg_flags*ã€*address* ã¯ :meth:`recvmsg` "
"ã¨åŒæ§˜ã§ã™ã€‚"

#: ../../library/socket.rst:1203
msgid "Example::"
msgstr "ä»¥ä¸‹ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¾‹ã§ã™::"

#: ../../library/socket.rst:1224
msgid ""
"Receive data from the socket, writing it into *buffer* instead of creating a"
" new bytestring.  The return value is a pair ``(nbytes, address)`` where "
"*nbytes* is the number of bytes received and *address* is the address of the"
" socket sending the data.  See the Unix manual page :manpage:`recv(2)` for "
"the meaning of the optional argument *flags*; it defaults to zero.  (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã€ãã®ãƒ‡ãƒ¼ã‚¿ã‚’æ–°ã—ã„ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã¨ã—ã¦è¿”ã™ä»£ã‚ã‚Šã« *buffer* ã«æ›¸ãã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ ``(nbytes, "
"address)`` ã®ãƒšã‚¢ã§ã€ *nbytes* ã¯å—ä¿¡ã—ãŸãƒ‡ãƒ¼ã‚¿ã®ãƒã‚¤ãƒˆæ•°ã‚’ã€ *address* "
"ã¯ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ãŸã‚½ã‚±ãƒƒãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *flags* (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ:0) ã®æ„å‘³ã«ã¤ã„ã¦ã¯ã€ Unix ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ "
":manpage:`recv(2)` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚(*address* ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯å‰è¿°ã®ã¨ãŠã‚Šã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã«ä¾å­˜ã—ã¾ã™ã€‚)"

#: ../../library/socket.rst:1234
msgid ""
"Receive up to *nbytes* bytes from the socket, storing the data into a buffer"
" rather than creating a new bytestring.  If *nbytes* is not specified (or "
"0), receive up to the size available in the given buffer.  Returns the "
"number of bytes received.  See the Unix manual page :manpage:`recv(2)` for "
"the meaning of the optional argument *flags*; it defaults to zero."
msgstr ""
"*nbytes* ãƒã‚¤ãƒˆã¾ã§ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰å—ä¿¡ã—ã¦ã€ãã®ãƒ‡ãƒ¼ã‚¿ã‚’æ–°ã—ã„ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã«ã™ã‚‹ã®ã§ã¯ãªã *buffer* ã«ä¿å­˜ã—ã¾ã™ã€‚ "
"*nbytes* ãŒæŒ‡å®šã•ã‚Œãªã„(ã‚ã‚‹ã„ã¯0ãŒæŒ‡å®šã•ã‚ŒãŸ)å ´åˆã€ *buffer* "
"ã®åˆ©ç”¨å¯èƒ½ãªã‚µã‚¤ã‚ºã¾ã§å—ä¿¡ã—ã¾ã™ã€‚å—ä¿¡ã—ãŸãƒã‚¤ãƒˆæ•°ã‚’è¿”ã‚Šå€¤ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *flags* (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ:0) ã®æ„å‘³ã«ã¤ã„ã¦ã¯ã€ "
"Unix ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ :manpage:`recv(2)` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:1243
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Returns the number of bytes sent. Applications are responsible for "
"checking that all data has been sent; if only some of the data was "
"transmitted, the application needs to attempt delivery of the remaining "
"data. For further information on this topic, consult the :ref:`socket-"
"howto`."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã¯ãƒªãƒ¢ãƒ¼ãƒˆã‚½ã‚±ãƒƒãƒˆã«æ¥ç¶šæ¸ˆã¿ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *flags* ã®æ„å‘³ã¯ã€ä¸Šè¨˜ "
":meth:`recv` "
"ã¨åŒã˜ã§ã™ã€‚æˆ»ã‚Šå€¤ã¨ã—ã¦ã€é€ä¿¡ã—ãŸãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€å¿…ãšæˆ»ã‚Šå€¤ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿ãŒé€ã‚‰ã‚ŒãŸäº‹ã‚’ç¢ºèªã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ã®ä¸€éƒ¨ã ã‘ãŒé€ä¿¡ã•ã‚ŒãŸå ´åˆã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§æ®‹ã‚Šã®ãƒ‡ãƒ¼ã‚¿ã‚’å†é€ä¿¡ã—ã¦ãã ã•ã„ã€‚"
" :ref:`ã‚½ã‚±ãƒƒãƒˆãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°HOWTO <socket-howto>` ã«ã€ã•ã‚‰ã«è©³ã—ã„æƒ…å ±ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:1258
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Unlike :meth:`send`, this method continues to send data from *bytes* "
"until either all data has been sent or an error occurs.  ``None`` is "
"returned on success.  On error, an exception is raised, and there is no way "
"to determine how much data, if any, was successfully sent."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã¯ãƒªãƒ¢ãƒ¼ãƒˆã‚½ã‚±ãƒƒãƒˆã«æ¥ç¶šæ¸ˆã¿ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *flags* ã®æ„å‘³ã¯ã€ä¸Šè¨˜ "
":meth:`recv` ã¨åŒã˜ã§ã™ã€‚ :meth:`send` ã¨ç•°ãªã‚Šã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ *bytes* "
"ã®å…¨ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã™ã‚‹ã‹ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã¾ã§å‡¦ç†ã‚’ç¶™ç¶šã—ã¾ã™ã€‚æ­£å¸¸çµ‚äº†ã®å ´åˆã¯ ``None`` "
"ã‚’è¿”ã—ã€ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã«ã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã€é€ä¿¡ã•ã‚ŒãŸãƒã‚¤ãƒˆæ•°ã‚’èª¿ã¹ã‚‹äº‹ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:1265
msgid ""
"The socket timeout is no more reset each time data is sent successfully. The"
" socket timeout is now the maximum total duration to send all data."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯ã€ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«é€ä¿¡ã•ã‚Œã‚‹åº¦ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œãªããªã‚Šã¾ã—ãŸã€‚ã‚½ã‚±ãƒƒãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯ã€ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚‹æœ€å¤§ã®åˆè¨ˆæ™‚é–“ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:1278
msgid ""
"Send data to the socket.  The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*.  The "
"optional *flags* argument has the same meaning as for :meth:`recv` above.  "
"Return the number of bytes sent. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯æ¥ç¶šå…ˆã‚’ *address* ã§æŒ‡å®šã™ã‚‹ã®ã§ã€æ¥ç¶šæ¸ˆã¿ã§ã¯ã„ã‘ã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *flags* "
"ã®æ„å‘³ã¯ã€ä¸Šè¨˜ :meth:`recv` ã¨åŒã˜ã§ã™ã€‚æˆ»ã‚Šå€¤ã¨ã—ã¦ã€é€ä¿¡ã—ãŸãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ã€‚(*address* "
"ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ --- å‰è¿°ã€‚)"

#: ../../library/socket.rst:1292
msgid ""
"Send normal and ancillary data to the socket, gathering the non-ancillary "
"data from a series of buffers and concatenating it into a single message.  "
"The *buffers* argument specifies the non-ancillary data as an iterable of "
":term:`bytes-like objects <bytes-like object>` (e.g. :class:`bytes` "
"objects); the operating system may set a limit (:func:`~os.sysconf` value "
"``SC_IOV_MAX``) on the number of buffers that can be used.  The *ancdata* "
"argument specifies the ancillary data (control messages) as an iterable of "
"zero or more tuples ``(cmsg_level, cmsg_type, cmsg_data)``, where "
"*cmsg_level* and *cmsg_type* are integers specifying the protocol level and "
"protocol-specific type respectively, and *cmsg_data* is a bytes-like object "
"holding the associated data.  Note that some systems (in particular, systems"
" without :func:`CMSG_SPACE`) might support sending only one control message "
"per call.  The *flags* argument defaults to 0 and has the same meaning as "
"for :meth:`send`.  If *address* is supplied and not ``None``, it sets a "
"destination address for the message.  The return value is the number of "
"bytes of non-ancillary data sent."
msgstr ""
"éä»˜å±çš„ãªãƒ‡ãƒ¼ã‚¿ã‚’ä¸€é€£ã®ãƒãƒƒãƒ•ã‚¡ã‹ã‚‰é›†ã‚ã€å˜ä¸€ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¾ã¨ã‚ã‚‹ã“ã¨ã§ã€é€šå¸¸ã®ãƒ‡ãƒ¼ã‚¿ã¨ä»˜å±çš„ãªãƒ‡ãƒ¼ã‚¿ã‚’ã‚½ã‚±ãƒƒãƒˆã«é€ä¿¡ã—ã¾ã™ã€‚*buffers* "
"å¼•æ•°ã¯ã€éä»˜å±çš„ãªãƒ‡ãƒ¼ã‚¿ã‚’ :term:`bytes-like objects <bytes-like object>` (ä¾‹: "
":class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã¨ã—ã¦æŒ‡å®šã—ã¾ã™ã€‚ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ã€ä½¿ç”¨ã§ãã‚‹ãƒãƒƒãƒ•ã‚¡ã®æ•°ãŒåˆ¶é™ "
"(:func:`~os.sysconf` å€¤ ``SC_IOV_MAX``) ã•ã‚Œã¦ã„ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚*ancdata* å¼•æ•°ã¯ä»˜å±çš„ãªãƒ‡ãƒ¼ã‚¿ "
"(åˆ¶å¾¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸) ã‚’ã‚¼ãƒ­ä»¥ä¸Šã®ã‚¿ãƒ—ãƒ« ``(cmsg_level, cmsg_type, cmsg_data)`` "
"ã®ã‚¤ãƒ†ãƒ©ãƒ–ãƒ«ã¨ã—ã¦æŒ‡å®šã—ã¾ã™ã€‚ã“ã“ã§ã€*cmsg_level* ã¨ *cmsg_type* "
"ã¯ãã‚Œãã‚Œãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒ¬ãƒ™ãƒ«ã¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«å›ºæœ‰ã®ã‚¿ã‚¤ãƒ—ã‚’æŒ‡å®šã™ã‚‹æ•´æ•°ã§ã€*cmsg_data* "
"ã¯é–¢é€£ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã™ã‚‹ãƒã‚¤ãƒˆãƒ©ã‚¤ã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ä¸€éƒ¨ã®ã‚·ã‚¹ãƒ†ãƒ  (ç‰¹ã« :func:`CMSG_SPACE` ã‚’æŒãŸãªã„ã‚·ã‚¹ãƒ†ãƒ ) "
"ã§ã¯ã€ä¸€åº¦ã®å‘¼ã³å‡ºã—ã§ä¸€ã¤ã®åˆ¶å¾¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã—ã‹ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚*flags* å¼•æ•°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ 0 "
"ã§ã‚ã‚Šã€:meth:`send` ã§ã®æ„å‘³ã¨åŒã˜æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚``None`` ä»¥å¤–ã® *address* "
"ãŒæ¸¡ã•ã‚ŒãŸå ´åˆã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç›®çš„åœ°ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨­å®šã—ã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ã€é€ä¿¡ã•ã‚ŒãŸéä»˜å±çš„ãƒ‡ãƒ¼ã‚¿ã®ãƒã‚¤ãƒˆæ•°ã§ã™ã€‚"

#: ../../library/socket.rst:1312
msgid ""
"The following function sends the list of file descriptors *fds* over an "
":const:`AF_UNIX` socket, on systems which support the :const:`SCM_RIGHTS` "
"mechanism.  See also :meth:`recvmsg`. ::"
msgstr ""
"ä»¥ä¸‹ã®é–¢æ•°ã¯ã€:const:`SCM_RIGHTS` ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã§ã€ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ *fds* ã‚’ "
":const:`AF_UNIX` ã‚½ã‚±ãƒƒãƒˆçµŒç”±ã§é€ä¿¡ã—ã¾ã™ã€‚:meth:`recvmsg` ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:1332
msgid ""
"Specialized version of :meth:`~socket.sendmsg` for :const:`AF_ALG` socket. "
"Set mode, IV, AEAD associated data length and flags for :const:`AF_ALG` "
"socket."
msgstr ""
":meth:`~socket.sendmsg` ã® :const:`AF_ALG` ã‚½ã‚±ãƒƒãƒˆç”¨ã«ç‰¹åŒ–ã—ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã™ã€‚:const:`AF_ALG` "
"ã‚½ã‚±ãƒƒãƒˆã®ã€ãƒ¢ãƒ¼ãƒ‰ã€IVã€AEAD ã«é–¢é€£ã¥ã‘ã‚‰ã‚ŒãŸãƒ‡ãƒ¼ã‚¿é•·ã€ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/socket.rst:1335
msgid "Availability: Linux >= 2.6.38"
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ: Linux 2.6.38 ä»¥é™ã€‚"

#: ../../library/socket.rst:1341
msgid ""
"Send a file until EOF is reached by using high-performance "
":mod:`os.sendfile` and return the total number of bytes which were sent. "
"*file* must be a regular file object opened in binary mode. If "
":mod:`os.sendfile` is not available (e.g. Windows) or *file* is not a "
"regular file :meth:`send` will be used instead. *offset* tells from where to"
" start reading the file. If specified, *count* is the total number of bytes "
"to transmit as opposed to sending the file until EOF is reached. File "
"position is updated on return or also in case of error in which case "
":meth:`file.tell() <io.IOBase.tell>` can be used to figure out the number of"
" bytes which were sent. The socket must be of :const:`SOCK_STREAM` type. "
"Non-blocking sockets are not supported."
msgstr ""
"é«˜æ€§èƒ½ã® :mod:`os.sendfile`Â ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ EOF ã¾ã§é€ä¿¡ã—ã€é€ä¿¡ã•ã‚ŒãŸãƒã‚¤ãƒˆã®ç·æ•°ã‚’è¿”ã—ã¾ã™ã€‚*file* "
"ã¯ã€ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§é–‹ã‹ã‚ŒãŸæ¨™æº–çš„ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚:mod:`os.sendfile`Â ãŒä½¿ç”¨ã§ããªã„å ´åˆ (ä¾‹: Windows)ã€ã¾ãŸã¯"
" *file* ãŒæ¨™æº–çš„ãªãƒ•ã‚¡ã‚¤ãƒ«ã§ãªã„å ´åˆã€ä»£ã‚ã‚Šã« :meth:`send` ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚*offset*Â "
"ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿å‡ºã—é–‹å§‹ä½ç½®ã‚’æŒ‡å®šã—ã¾ã™ã€‚*count*Â ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ EOF "
"ã¾ã§é€ä¿¡ã™ã‚‹ã®ã§ã¯ãªãã€è»¢é€ã™ã‚‹ãƒã‚¤ãƒˆã®ç·æ•°ã‚’æŒ‡å®šã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½ç½®ã¯ã€è¿”ã‚‹æ™‚ã«æ›´æ–°ã•ã‚Œã¾ã™ã€‚ã‚ã‚‹ã„ã¯ã€ã‚¨ãƒ©ãƒ¼æ™‚ã«ã¯ "
":meth:`file.tell() <io.IOBase.tell>`Â  ã‚’ä½¿ç”¨ã—ã¦é€ä¿¡ã•ã‚ŒãŸãƒã‚¤ãƒˆã®æ•°ã‚’ç¢ºèªã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆã¯ "
":const:`SOCK_STREAM` ã‚¿ã‚¤ãƒ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚éãƒ–ãƒ­ãƒƒã‚¯ã‚½ã‚±ãƒƒãƒˆã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:1357
msgid ""
"Set the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle."
msgstr "ã‚½ã‚±ãƒƒãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã€ã¾ãŸã¯ã‚½ã‚±ãƒƒãƒˆã®ãƒãƒ³ãƒ‰ãƒ«ã®ã€ :ref:`ç¶™æ‰¿å¯èƒ½ãƒ•ãƒ©ã‚° <fd_inheritance>` ã‚’ç«‹ã¦ã¾ã™ã€‚"

#: ../../library/socket.rst:1365
msgid ""
"Set blocking or non-blocking mode of the socket: if *flag* is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‚’ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã€ã¾ãŸã¯éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã«è¨­å®šã—ã¾ã™ã€‚*flag* ãŒ False "
"ã®å ´åˆã«ã¯ã‚½ã‚±ãƒƒãƒˆã¯éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã«ãªã‚Šã€True ã®å ´åˆã«ã¯ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:1368
msgid ""
"This method is a shorthand for certain :meth:`~socket.settimeout` calls:"
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æ¬¡ã® :meth:`~socket.settimeout` å‘¼ã³å‡ºã—ã®çœç•¥è¡¨è¨˜ã§ã™:"

#: ../../library/socket.rst:1370
msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr "``sock.setblocking(True)`` ã¯ ``sock.settimeout(None)`` ã¨ç­‰ä¾¡ã§ã™"

#: ../../library/socket.rst:1372
msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0.0)``"
msgstr "``sock.setblocking(False)`` ã¯ ``sock.settimeout(0.0)`` ã¨ç­‰ä¾¡ã§ã™"

#: ../../library/socket.rst:1377
msgid ""
"Set a timeout on blocking socket operations.  The *value* argument can be a "
"nonnegative floating point number expressing seconds, or ``None``. If a non-"
"zero value is given, subsequent socket operations will raise a "
":exc:`timeout` exception if the timeout period *value* has elapsed before "
"the operation has completed.  If zero is given, the socket is put in non-"
"blocking mode. If ``None`` is given, the socket is put in blocking mode."
msgstr ""
"ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚½ã‚±ãƒƒãƒˆã®å‡¦ç†ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ã‚’æŒ‡å®šã—ã¾ã™ã€‚ *value* ã«ã¯ float å‹ã§éè² ã®ç§’æ•°ã‚’æŒ‡å®šã™ã‚‹ã‹ã€ ``None`` "
"ã‚’æŒ‡å®šã—ã¾ã™ã€‚ã‚¼ãƒ­ä»¥å¤–ã®å€¤ã‚’æŒ‡å®šã—ãŸå ´åˆã€ã‚½ã‚±ãƒƒãƒˆã®å‡¦ç†ãŒå®Œäº†ã™ã‚‹å‰ã« *value* ã§æŒ‡å®šã—ãŸç§’æ•°ãŒçµŒéã™ã‚Œã° :exc:`timeout` "
"ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚ã‚¼ãƒ­ã‚’æŒ‡å®šã—ãŸå ´åˆã€ã‚½ã‚±ãƒƒãƒˆã¯éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰çŠ¶æ…‹ã«ç½®ã‹ã‚Œã¾ã™ã€‚ ``None`` "
"ã‚’æŒ‡å®šã—ãŸå ´åˆã€ã‚½ã‚±ãƒƒãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ç„¡åŠ¹ã«ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:1384
msgid ""
"For further information, please consult the :ref:`notes on socket timeouts "
"<socket-timeouts>`."
msgstr "è©³ã—ãã¯ :ref:`ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®æ³¨æ„äº‹é … <socket-timeouts>` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:1393
msgid ""
"Set the value of the given socket option (see the Unix manual page "
":manpage:`setsockopt(2)`).  The needed symbolic constants are defined in the"
" :mod:`socket` module (:const:`SO_\\*` etc.).  The value can be an integer, "
"``None`` or a :term:`bytes-like object` representing a buffer. In the later "
"case it is up to the caller to ensure that the bytestring contains the "
"proper bits (see the optional built-in module :mod:`struct` for a way to "
"encode C structures as bytestrings). When value is set to ``None``, optlen "
"argument is required. It's equivalent to call setsockopt C function with "
"optval=NULL and optlen=optlen."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å€¤ã‚’è¨­å®šã—ã¾ã™ (Unix ã®ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ :manpage:`setsockopt(2)` "
"ã‚’å‚ç…§)ã€‚å¿…è¦ãªã‚·ãƒ³ãƒœãƒªãƒƒã‚¯å®šæ•°ã¯ã€:mod:`socket` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (:const:`SO_\\*` ãªã©) "
"ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®å€¤ã¯ã€æ•´æ•°ã€``None``ã€ã¾ãŸã¯ãƒãƒƒãƒ•ã‚¡ã‚’è¡¨ã™ :term:`bytes-like object` "
"ã®ã„ãšã‚Œã‹ã§ã™ã€‚ãƒã‚¤ãƒˆãƒ©ã‚¤ã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã«é©åˆ‡ãªãƒ“ãƒƒãƒˆãŒå«ã¾ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã®ã¯å‘¼ã³å‡ºã—å…ƒã®ä»•äº‹ã§ã™ (C "
"æ§‹é€ ã‚’ãƒã‚¤ãƒˆæ–‡å­—åˆ—ã¨ã—ã¦ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹æ–¹æ³•ã«ã¤ã„ã¦ã¯ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`struct` ã‚’å‚ç…§)ã€‚å€¤ãŒ ``None`` "
"ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€optlen å¼•æ•°ãŒå¿…é ˆã§ã™ã€‚ã“ã‚Œã¯ã€optval=NULL ã¨ optlen=optlen ã§ setsockopt C "
"é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã®ã¨åŒä¸€ã§ã™ã€‚"

#: ../../library/socket.rst:1407
msgid "setsockopt(level, optname, None, optlen: int) form added."
msgstr "setsockopt(level, optname, None, optlen: int) ã®å½¢å¼ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/socket.rst:1413
msgid ""
"Shut down one or both halves of the connection.  If *how* is "
":const:`SHUT_RD`, further receives are disallowed.  If *how* is "
":const:`SHUT_WR`, further sends are disallowed.  If *how* is "
":const:`SHUT_RDWR`, further sends and receives are disallowed."
msgstr ""
"æ¥ç¶šã®ç‰‡æ–¹å‘ã€ã¾ãŸã¯ä¸¡æ–¹å‘ã‚’åˆ‡æ–­ã—ã¾ã™ã€‚ *how* ãŒ :const:`SHUT_RD` ã®å ´åˆã€ä»¥é™ã¯å—ä¿¡ã‚’è¡Œãˆã¾ã›ã‚“ã€‚ *how* ãŒ "
":const:`SHUT_WR` ã®å ´åˆã€ä»¥é™ã¯é€ä¿¡ã‚’è¡Œãˆã¾ã›ã‚“ã€‚ *how* ãŒ :const:`SHUT_RDWR` "
"ã®å ´åˆã€ä»¥é™ã¯é€å—ä¿¡ã‚’è¡Œãˆã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:1421
msgid ""
"Duplicate a socket and prepare it for sharing with a target process.  The "
"target process must be provided with *process_id*.  The resulting bytes "
"object can then be passed to the target process using some form of "
"interprocess communication and the socket can be recreated there using "
":func:`fromshare`. Once this method has been called, it is safe to close the"
" socket since the operating system has already duplicated it for the target "
"process."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‚’è¤‡è£½ã—ã€å¯¾è±¡ã®ãƒ—ãƒ­ã‚»ã‚¹ã¨å…±æœ‰ã™ã‚‹ãŸã‚ã® bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚å¯¾è±¡ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ *process_id* "
"ã§æŒ‡å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æˆ»ã‚Šå€¤ã® bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ä½•ã‚‰ã‹ã®ãƒ—ãƒ­ã‚»ã‚¹é–“é€šä¿¡ã‚’ä½¿ã£ã¦å¯¾è±¡ã®ãƒ—ãƒ­ã‚»ã‚¹ã«ä¼ãˆã¾ã™ã€‚å¯¾è±¡ã®ãƒ—ãƒ­ã‚»ã‚¹å´ã§ã¯ã€ "
":func:`fromshare` "
"ã‚’ä½¿ã£ã¦è¤‡è£½ã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆã‚’ã¨ã‚‰ãˆã¾ã™ã€‚ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ»ã‚·ã‚¹ãƒ†ãƒ ã¯å¯¾è±¡ã®ãƒ—ãƒ­ã‚»ã‚¹ã«å¯¾ã—ã¦ã‚½ã‚±ãƒƒãƒˆã‚’è¤‡è£½ã™ã‚‹ãŸã‚ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ãŸå¾Œã§ã‚ã‚Œã°ã€å…ƒã®ã‚½ã‚±ãƒƒãƒˆã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¦ã‚‚ã€å¯¾è±¡ã®ãƒ—ãƒ­ã‚»ã‚¹ã«æ¸¡ã£ãŸã‚½ã‚±ãƒƒãƒˆã«ã¯å½±éŸ¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/socket.rst:1433
msgid ""
"Note that there are no methods :meth:`read` or :meth:`write`; use "
":meth:`~socket.recv` and :meth:`~socket.send` without *flags* argument "
"instead."
msgstr ""
":meth:`read` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ :meth:`write` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ä»£ã‚ã‚Šã« *flags* ã‚’çœç•¥ã—ãŸ "
":meth:`~socket.recv` ã¨ :meth:`~socket.send` ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:1436
msgid ""
"Socket objects also have these (read-only) attributes that correspond to the"
" values given to the :class:`~socket.socket` constructor."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ä»¥ä¸‹ã® :class:`~socket.socket` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«æ¸¡ã•ã‚ŒãŸå€¤ã«å¯¾å¿œã—ãŸ (èª­ã¿å‡ºã—å°‚ç”¨) å±æ€§ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:1442
msgid "The socket family."
msgstr "ã‚½ã‚±ãƒƒãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼ã€‚"

#: ../../library/socket.rst:1447
msgid "The socket type."
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã€‚"

#: ../../library/socket.rst:1452
msgid "The socket protocol."
msgstr "ã‚½ã‚±ãƒƒãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ«ã€‚"

#: ../../library/socket.rst:1459
msgid "Notes on socket timeouts"
msgstr "ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®æ³¨æ„äº‹é …"

#: ../../library/socket.rst:1461
msgid ""
"A socket object can be in one of three modes: blocking, non-blocking, or "
"timeout.  Sockets are by default always created in blocking mode, but this "
"can be changed by calling :func:`setdefaulttimeout`."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã€éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ¢ãƒ¼ãƒ‰ã®ã†ã¡ã€ã„ãšã‚Œã‹1ã¤ã®ãƒ¢ãƒ¼ãƒ‰ã‚’ã¨ã‚Šã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã‚½ã‚±ãƒƒãƒˆã¯å¸¸ã«ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ä½œæˆã•ã‚Œã¾ã™ãŒã€"
" :func:`setdefaulttimeout` ã§æ¨™æº–ã®ãƒ¢ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:1465
msgid ""
"In *blocking mode*, operations block until complete or the system returns an"
" error (such as connection timed out)."
msgstr "*ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰* ã§ã®æ“ä½œã¯ã€å®Œäº†ã™ã‚‹ã‹ã€ã¾ãŸã¯ï¼ˆæ¥ç¶šãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã™ã‚‹ãªã©ã—ã¦ï¼‰ã‚·ã‚¹ãƒ†ãƒ ãŒã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã¾ã§ã€ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚"

#: ../../library/socket.rst:1468
msgid ""
"In *non-blocking mode*, operations fail (with an error that is unfortunately"
" system-dependent) if they cannot be completed immediately: functions from "
"the :mod:`select` can be used to know when and whether a socket is available"
" for reading or writing."
msgstr ""
"*éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰* "
"ã§ã®æ“ä½œã¯ã€ãŸã ã¡ã«å®Œäº†ã§ããªã„å ´åˆã€ä¾‹å¤–ã‚’é€å‡ºã—ã¦å¤±æ•—ã—ã¾ã™ã€‚ã“ã®å ´åˆã®ä¾‹å¤–ã®ç¨®é¡ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã«ä¾å­˜ã™ã‚‹ãŸã‚ã€ã“ã“ã«è¨˜ã™ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ "
":mod:`select` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–¢æ•°ã‚’ä½¿ã£ã¦ã€ã‚½ã‚±ãƒƒãƒˆã®èª­ã¿æ›¸ããŒåˆ©ç”¨å¯èƒ½ã‹ã©ã†ã‹ã€å¯èƒ½ãªå ´åˆã¯ã„ã¤åˆ©ç”¨ã§ãã‚‹ã‹ã‚’èª¿ã¹ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:1473
msgid ""
"In *timeout mode*, operations fail if they cannot be completed within the "
"timeout specified for the socket (they raise a :exc:`timeout` exception) or "
"if the system returns an error."
msgstr ""
"*ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ¢ãƒ¼ãƒ‰* ã§ã®æ“ä½œã¯ã€æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®æ™‚é–“å†…ã«å®Œäº†ã—ãªã‘ã‚Œã°ã€ :exc:`timeout` "
"ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®æ™‚é–“å†…ã«ã‚·ã‚¹ãƒ†ãƒ ãŒã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ãŸå ´åˆã¯ã€ãã®ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:1478
msgid ""
"At the operating system level, sockets in *timeout mode* are internally set "
"in non-blocking mode.  Also, the blocking and timeout modes are shared "
"between file descriptors and socket objects that refer to the same network "
"endpoint. This implementation detail can have visible consequences if e.g. "
"you decide to use the :meth:`~socket.fileno()` of a socket."
msgstr ""
"ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ»ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ¬ãƒ™ãƒ«ã§ã¯ã€ *ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ¢ãƒ¼ãƒ‰* "
"ã®ã‚½ã‚±ãƒƒãƒˆã«ã¯ã€å†…éƒ¨çš„ã«éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™ã€‚ã¾ãŸãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã¨ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ¢ãƒ¼ãƒ‰ã®æŒ‡å®šã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã¨ã€ã€Œãã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã¨åŒã˜ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç«¯ç‚¹ã‚’å‚ç…§ã™ã‚‹ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã¨ã®é–“ã§å…±æœ‰ã•ã‚Œã¾ã™ã€‚ã“ã®ã“ã¨ã¯ã€ä¾‹ãˆã°ã‚½ã‚±ãƒƒãƒˆã®"
" :meth:`~socket.fileno()` ã‚’ä½¿ã†ã“ã¨ã«ã—ãŸå ´åˆã«ã€æ˜ã‚‰ã‹ãªå½±éŸ¿ã‚’ä¸ãˆã¾ã™ã€‚"

#: ../../library/socket.rst:1485
msgid "Timeouts and the ``connect`` method"
msgstr "ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¨ ``connect`` ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../library/socket.rst:1487
msgid ""
"The :meth:`~socket.connect` operation is also subject to the timeout "
"setting, and in general it is recommended to call :meth:`~socket.settimeout`"
" before calling :meth:`~socket.connect` or pass a timeout parameter to "
":meth:`create_connection`.  However, the system network stack may also "
"return a connection timeout error of its own regardless of any Python socket"
" timeout setting."
msgstr ""
":meth:`~socket.connect` ã‚‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šã«å¾“ã„ã¾ã™ã€‚ä¸€èˆ¬çš„ã«ã€ :meth:`~socket.settimeout` ã‚’ "
":meth:`~socket.connect` ã®å‰ã«å‘¼ã¶ã‹ã€ :meth:`create_connection` "
"ã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¼•æ•°ã‚’æ¸¡ã™ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¾ã™ã€‚ãŸã ã—ã€ã‚·ã‚¹ãƒ†ãƒ ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ã‚¿ãƒƒã‚¯ãŒ Python "
"ã®ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®è¨­å®šã‚’ç„¡è¦–ã—ã¦ã€è‡ªèº«ã®æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:1495
msgid "Timeouts and the ``accept`` method"
msgstr "ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¨ ``accept`` ãƒ¡ã‚½ãƒƒãƒ‰"

#: ../../library/socket.rst:1497
msgid ""
"If :func:`getdefaulttimeout` is not :const:`None`, sockets returned by the "
":meth:`~socket.accept` method inherit that timeout.  Otherwise, the "
"behaviour depends on settings of the listening socket:"
msgstr ""
":func:`getdefaulttimeout` ãŒ :const:`None` ã§ãªã„å ´åˆã€ :meth:`~socket.accept` "
"ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿”ã™ã‚½ã‚±ãƒƒãƒˆã§ã¯ã€ãã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç¶™æ‰¿ã•ã‚Œã¾ã™ã€‚ :const:`None` ã§ã‚ã‚‹å ´åˆã€å¾…æ©Ÿä¸­ã®ã‚½ã‚±ãƒƒãƒˆã®è¨­å®šã«ã‚ˆã£ã¦å‹•ä½œã¯ç•°ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:1501
msgid ""
"if the listening socket is in *blocking mode* or in *timeout mode*, the "
"socket returned by :meth:`~socket.accept` is in *blocking mode*;"
msgstr ""
"å¾…æ©Ÿä¸­ã®ã‚½ã‚±ãƒƒãƒˆãŒ *ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰* ã¾ãŸã¯ *ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ¢ãƒ¼ãƒ‰* ã§ã‚ã‚‹å ´åˆã€:meth:`~socket.accept` "
"ãŒè¿”ã™ã‚½ã‚±ãƒƒãƒˆã¯ã€*ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰*Â ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:1504
msgid ""
"if the listening socket is in *non-blocking mode*, whether the socket "
"returned by :meth:`~socket.accept` is in blocking or non-blocking mode is "
"operating system-dependent.  If you want to ensure cross-platform behaviour,"
" it is recommended you manually override this setting."
msgstr ""
"å¾…æ©Ÿä¸­ã®ã‚½ã‚±ãƒƒãƒˆãŒ *éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰* ã§ã‚ã‚‹å ´åˆã€:meth:`~socket.accept` "
"ãŒè¿”ã™ã‚½ã‚±ãƒƒãƒˆã¯ã€ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã«ãªã‚Šã¾ã™ã€‚ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®å‹•ä½œã‚’ç¢ºä¿ã—ãŸã„å ´åˆã€ã“ã®è¨­å®šã‚’æ‰‹å‹•ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚"

#: ../../library/socket.rst:1513
msgid "Example"
msgstr "ä½¿ç”¨ä¾‹"

#: ../../library/socket.rst:1515
msgid ""
"Here are four minimal example programs using the TCP/IP protocol: a server "
"that echoes all data that it receives back (servicing only one client), and "
"a client using it.  Note that a server must perform the sequence "
":func:`.socket`, :meth:`~socket.bind`, :meth:`~socket.listen`, "
":meth:`~socket.accept` (possibly repeating the :meth:`~socket.accept` to "
"service more than one client), while a client only needs the sequence "
":func:`.socket`, :meth:`~socket.connect`.  Also note that the server does "
"not :meth:`~socket.sendall`/:meth:`~socket.recv` on the socket it is "
"listening on but on the new socket returned by :meth:`~socket.accept`."
msgstr ""
"ä»¥ä¸‹ã¯ TCP/IP ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ç°¡å˜ãªã‚µãƒ³ãƒ—ãƒ«ã¨ã—ã¦ã€å—ä¿¡ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ãã®ã¾ã¾è¿”é€ã™ã‚‹ã‚µãƒ¼ãƒ (æ¥ç¶šå¯èƒ½ãªã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ä¸€ä»¶ã®ã¿) "
"ã¨ã€ã‚µãƒ¼ãƒã«æ¥ç¶šã™ã‚‹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚ã‚µãƒ¼ãƒã§ã¯ã€ :func:`.socket` ãƒ» :meth:`~socket.bind` ãƒ» "
":meth:`~socket.listen` ãƒ» :meth:`~socket.accept` ã‚’å®Ÿè¡Œã— "
"(è¤‡æ•°ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®æ¥ç¶šã‚’å—ã‘ä»˜ã‘ã‚‹å ´åˆã€ :meth:`~socket.accept` ã‚’è¤‡æ•°å›å‘¼ã³å‡ºã—ã¾ã™)ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã¯ "
":func:`.socket` ã¨ :meth:`~socket.connect` ã ã‘ã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚ã‚µãƒ¼ãƒã§ã¯ "
":meth:`~socket.sendall` / :meth:`~socket.recv` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ listen "
"ä¸­ã®ã‚½ã‚±ãƒƒãƒˆã§å®Ÿè¡Œã™ã‚‹ã®ã§ã¯ãªãã€ :meth:`~socket.accept` ã§å–å¾—ã—ãŸã‚½ã‚±ãƒƒãƒˆã«å¯¾ã—ã¦å®Ÿè¡Œã—ã¦ã„ã‚‹ç‚¹ã«ã‚‚æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/socket.rst:1525
msgid "The first two examples support IPv4 only. ::"
msgstr "æ¬¡ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚µãƒ¼ãƒã¯ã€IPv4 ã®ã¿ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ ::"

#: ../../library/socket.rst:1556
msgid ""
"The next two examples are identical to the above two, but support both IPv4 "
"and IPv6. The server side will listen to the first address family available "
"(it should listen to both instead). On most of IPv6-ready systems, IPv6 will"
" take precedence and the server may not accept IPv4 traffic. The client side"
" will try to connect to the all addresses returned as a result of the name "
"resolution, and sends traffic to the first one connected successfully. ::"
msgstr ""
"æ¬¡ã®ã‚µãƒ³ãƒ—ãƒ«ã¯ä¸Šè¨˜ã®ã‚µãƒ³ãƒ—ãƒ«ã¨ã»ã¨ã‚“ã©åŒã˜ã§ã™ãŒã€IPv4 ã¨ IPv6 ã®ä¸¡æ–¹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã‚µãƒ¼ãƒã§ã¯ã€IPv4/v6 "
"ã®ä¸¡æ–¹ã§ã¯ãªãã€åˆ©ç”¨å¯èƒ½ãªæœ€åˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã ã‘ã‚’ listen ã—ã¦ã„ã¾ã™ã€‚ã»ã¨ã‚“ã©ã® IPv6 å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ ã§ã¯ IPv6 "
"ãŒå…ˆã«ç¾ã‚Œã‚‹ãŸã‚ã€ã‚µãƒ¼ãƒã¯ IPv4 "
"ã«ã¯å¿œç­”ã—ã¾ã›ã‚“ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã¯åå‰è§£æ±ºã®çµæœã¨ã—ã¦å–å¾—ã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã«é †æ¬¡æ¥ç¶šã‚’è©¦ã¿ã€æœ€åˆã«æ¥ç¶šã«æˆåŠŸã—ãŸã‚½ã‚±ãƒƒãƒˆã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¦ã„ã¾ã™ã€‚ ::"

#: ../../library/socket.rst:1629
msgid ""
"The next example shows how to write a very simple network sniffer with raw "
"sockets on Windows. The example requires administrator privileges to modify "
"the interface::"
msgstr ""
"æ¬¡ã®ä¾‹ã¯ã€Windowsã§ raw socket "
"ã‚’åˆ©ç”¨ã—ã¦éå¸¸ã«ã‚·ãƒ³ãƒ—ãƒ«ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ãƒ‹ãƒ•ã‚¡ãƒ¼ã‚’æ›¸ãã¾ã™ã€‚ã“ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’å®Ÿè¡Œã™ã‚‹ã«ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™::"

#: ../../library/socket.rst:1654
msgid ""
"The last example shows how to use the socket interface to communicate to a "
"CAN network using the raw socket protocol. To use CAN with the broadcast "
"manager protocol instead, open a socket with::"
msgstr ""
"æœ€å¾Œã®ä¾‹ã§ã¯ã€ã‚½ã‚±ãƒƒãƒˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’ä½¿ç”¨ã—ã¦ãƒ­ãƒ¼ã‚½ã‚±ãƒƒãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ CAN "
"ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã¨é€šä¿¡ã™ã‚‹æ–¹æ³•ã‚’èª¬æ˜ã—ã¾ã™ã€‚ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ—ãƒ­ãƒˆã‚³ãƒ­ãƒ«ã§ CAN ã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯ã€ä»¥ä¸‹ã§ã‚½ã‚±ãƒƒãƒˆã‚’é–‹ãã¾ã™ã€‚"

#: ../../library/socket.rst:1660
msgid ""
"After binding (:const:`CAN_RAW`) or connecting (:const:`CAN_BCM`) the "
"socket, you can use the :meth:`socket.send`, and the :meth:`socket.recv` "
"operations (and their counterparts) on the socket object as usual."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã®æŸç¸› (:const:`CAN_RAW`) ã¾ãŸã¯ (:const:`CAN_BCM`) æ¥ç¶šã‚’è¡Œã£ãŸã‚ã¨ã€ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ "
":meth:`socket.send` ã¨ :meth:`socket.recv` æ“ä½œ (ã¨ãã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒ‘ãƒ¼ãƒˆ) "
"ã‚’é€šå¸¸é€šã‚Šã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/socket.rst:1664
msgid "This example might require special privileges::"
msgstr "æ¬¡ã®ä¾‹ã§ã¯ã€ç‰¹æ¨©ãŒå¿…è¦ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“::"

#: ../../library/socket.rst:1704
msgid ""
"Running an example several times with too small delay between executions, "
"could lead to this error::"
msgstr "ã“ã®ä¾‹ã‚’ã€ã»ã¨ã‚“ã©é–“ã‚’ç©ºã‘ãšã«è¤‡æ•°å›å®Ÿè¡Œã™ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™::"

#: ../../library/socket.rst:1709
msgid ""
"This is because the previous execution has left the socket in a "
"``TIME_WAIT`` state, and can't be immediately reused."
msgstr "ã“ã‚Œã¯ä»¥å‰ã®å®Ÿè¡ŒãŒã‚½ã‚±ãƒƒãƒˆã‚’ ``TIME_WAIT`` çŠ¶æ…‹ã®ã¾ã¾ã«ã—ã€ã™ãã«ã¯å†åˆ©ç”¨ã§ããªã„ã“ã¨ã§èµ·ã“ã‚Šã¾ã™ã€‚"

#: ../../library/socket.rst:1712
msgid ""
"There is a :mod:`socket` flag to set, in order to prevent this, "
":data:`socket.SO_REUSEADDR`::"
msgstr "ã“ã‚Œã‚’é˜²ãã®ã«ã€ :mod:`socket` ãƒ•ãƒ©ã‚°ã® :data:`socket.SO_REUSEADDR` ãŒã‚ã‚Šã¾ã™::"

#: ../../library/socket.rst:1719
msgid ""
"the :data:`SO_REUSEADDR` flag tells the kernel to reuse a local socket in "
"``TIME_WAIT`` state, without waiting for its natural timeout to expire."
msgstr ""
":data:`SO_REUSEADDR` ãƒ•ãƒ©ã‚°ã¯ã€ ``TIME_WAIT`` "
"çŠ¶æ…‹ã«ã‚ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«ã‚½ã‚±ãƒƒãƒˆã‚’ãã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæœŸé™ãŒè‡ªç„¶ã«åˆ‡ã‚Œã‚‹ã®ã‚’å¾…ã¤ã“ã¨ãªãå†åˆ©ç”¨ã™ã‚‹ã“ã¨ã‚’ã‚«ãƒ¼ãƒãƒ«ã«ä¼ãˆã¾ã™ã€‚"

#: ../../library/socket.rst:1725
msgid ""
"For an introduction to socket programming (in C), see the following papers:"
msgstr "C è¨€èªã«ã‚ˆã‚‹ã‚½ã‚±ãƒƒãƒˆãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®åŸºç¤ã«ã¤ã„ã¦ã¯ã€ä»¥ä¸‹ã®è³‡æ–™ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ "

#: ../../library/socket.rst:1727
msgid ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, by Stuart "
"Sechrest"
msgstr ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, by Stuart "
"Sechrest"

#: ../../library/socket.rst:1729
msgid ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, by Samuel J.  "
"Leffler et al,"
msgstr ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, by Samuel J.  "
"Leffler et al,"

#: ../../library/socket.rst:1732
msgid ""
"both in the UNIX Programmer's Manual, Supplementary Documents 1 (sections "
"PS1:7 and PS1:8).  The platform-specific reference material for the various "
"socket-related system calls are also a valuable source of information on the"
" details of socket semantics.  For Unix, refer to the manual pages; for "
"Windows, see the WinSock (or Winsock 2) specification.  For IPv6-ready APIs,"
" readers may want to refer to :rfc:`3493` titled Basic Socket Interface "
"Extensions for IPv6."
msgstr ""
"ä¸¡æ›¸ã¨ã‚‚ UNIX Programmer's Manual, Supplementary Documents 1 (PS1:7ç«  "
"PS1:8ç« )ã€‚ã‚½ã‚±ãƒƒãƒˆã®è©³ç´°ã«ã¤ã„ã¦ã¯ã€å„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®ã‚½ã‚±ãƒƒãƒˆé–¢é€£ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã«é–¢ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚Unix "
"ã§ã¯ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ã€Windowsã§ã¯WinSock (ã¾ãŸã¯ WinSock2) ä»•æ§˜æ›¸ã‚’ã”è¦§ãã ã•ã„ã€‚IPv6 å¯¾å¿œã® API ã«ã¤ã„ã¦ã¯ã€ "
":rfc:`3493` \"Basic Socket Interface Extensions for IPv6\" ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"
