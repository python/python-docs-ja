# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-27 14:46+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/os.path.rst:2
msgid ":mod:`os.path` --- Common pathname manipulations"
msgstr ":mod:`os.path` --- å…±é€šã®ãƒ‘ã‚¹åæ“ä½œ"

#: ../../library/os.path.rst:7
msgid ""
"**Source code:** :source:`Lib/posixpath.py` (for POSIX), "
":source:`Lib/ntpath.py` (for Windows NT), and :source:`Lib/macpath.py` (for "
"Macintosh)"
msgstr ""
"**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/posixpath.py` (POSIX), :source:`Lib/ntpath.py` "
"(Windows NT), :source:`Lib/macpath.py` (Mac)"

#: ../../library/os.path.rst:15
msgid ""
"This module implements some useful functions on pathnames. To read or write "
"files see :func:`open`, and for accessing the filesystem see the :mod:`os` "
"module. The path parameters can be passed as either strings, or bytes. "
"Applications are encouraged to represent file names as (Unicode) character "
"strings. Unfortunately, some file names may not be representable as strings "
"on Unix, so applications that need to support arbitrary file names on Unix "
"should use bytes objects to represent path names. Vice versa, using bytes "
"objects cannot represent all file names on Windows (in the standard ``mbcs``"
" encoding), hence Windows applications should use string objects to access "
"all files."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã€ãƒ‘ã‚¹åã‚’æ“ä½œã™ã‚‹ä¾¿åˆ©ãªé–¢æ•°ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿æ›¸ãã«é–¢ã—ã¦ã¯ :func:`open` "
"ã‚’ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«é–¢ã—ã¦ã¯ :mod:`os` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯æ–‡å­—åˆ—ã¾ãŸã¯ãƒã‚¤ãƒˆåˆ—ã§æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ Unicode "
"æ–‡å­—åˆ—ã§è¡¨ã™ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ã€‚æ®‹å¿µãªãŒã‚‰ã€Unix ã§ã¯æ–‡å­—åˆ—ã§è¡¨ã™ã“ã¨ã®ã§ããªã„ãƒ•ã‚¡ã‚¤ãƒ«åãŒã‚ã‚‹ãŸã‚ã€Unix "
"ä¸Šã§ä»»æ„ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ã®ã‚ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ãã®ãƒ‘ã‚¹åã«ãƒã‚¤ãƒˆåˆ—ã‚’ä½¿ç”¨ã™ã¹ãã§ã™ã€‚é€†ã«ã€ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã¨ "
"Windows (æ¨™æº–ã® ``mbcs`` ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°) ä¸Šã§ã¯ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¡¨ã™ã“ã¨ãŒã§ããªã„ãŸã‚ã€Windows "
"ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ã‚¯ã‚»ã‚¹ã®ãŸã‚ã«æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/os.path.rst:26
msgid ""
"Unlike a unix shell, Python does not do any *automatic* path expansions. "
"Functions such as :func:`expanduser` and :func:`expandvars` can be invoked "
"explicitly when an application desires shell-like path expansion.  (See also"
" the :mod:`glob` module.)"
msgstr ""
"Unix ã‚·ã‚§ãƒ«ã¨ã¯ç•°ãªã‚Šã€Python ã¯ã‚ã‚‰ã‚†ã‚‹ãƒ‘ã‚¹å±•é–‹ã‚’ *è‡ªå‹•çš„ã«ã¯* è¡Œã„ã¾ã›ã‚“ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚·ã‚§ãƒ«ã®ã‚ˆã†ãªãƒ‘ã‚¹å±•é–‹ã‚’å¿…è¦ã¨ã—ãŸå ´åˆã¯ã€"
" :func:`expanduser` ã‚„ :func:`expandvars` ã¨ã„ã£ãŸé–¢æ•°ã‚’æ˜ç¤ºçš„ã«å‘¼ã³å‡ºã™ã“ã¨ã§è¡Œãˆã¾ã™ã€‚(:mod:`glob`"
" ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚å‚ç…§ã—ã¦ãã ã•ã„)"

#: ../../library/os.path.rst:33
msgid "The :mod:`pathlib` module offers high-level path objects."
msgstr ":mod:`pathlib` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯é«˜æ°´æº–ã®ãƒ‘ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:38
msgid ""
"All of these functions accept either only bytes or only string objects as "
"their parameters.  The result is an object of the same type, if a path or "
"file name is returned."
msgstr ""
"ä»¥ä¸‹ã®ã™ã¹ã¦ã®é–¢æ•°ã¯ã€ãã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ãƒã‚¤ãƒˆåˆ—ã®ã¿ã€ã‚ã‚‹ã„ã¯æ–‡å­—åˆ—ã®ã¿å—ã‘ä»˜ã‘ã¾ã™ã€‚ãƒ‘ã‚¹ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¿”ã™å ´åˆã€è¿”ã‚Šå€¤ã¯åŒã˜å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/os.path.rst:45
msgid ""
"Since different operating systems have different path name conventions, "
"there are several versions of this module in the standard library.  The "
":mod:`os.path` module is always the path module suitable for the operating "
"system Python is running on, and therefore usable for local paths.  However,"
" you can also import and use the individual modules if you want to "
"manipulate a path that is *always* in one of the different formats.  They "
"all have the same interface:"
msgstr ""
"OS ã«ã‚ˆã£ã¦ç•°ãªã‚‹ãƒ‘ã‚¹åã®æ±ºã¾ã‚ŠãŒã‚ã‚‹ãŸã‚ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã¯ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã„ãã¤ã‹ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚ :mod:`os.path` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å¸¸ã«ç¾åœ¨ Python ãŒå‹•ä½œã—ã¦ã„ã‚‹ OS "
"ã«é©ã—ãŸãƒ‘ã‚¹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã‚ã‚‹ãŸã‚ã€ãƒ­ãƒ¼ã‚«ãƒ«ã®ãƒ‘ã‚¹ã‚’æ‰±ã†ã®ã«é©ã—ã¦ã„ã¾ã™ã€‚å„ã€…ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ *å¸¸ã«* "
"ä¸€ã¤ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚ã“ã‚Œã‚‰ã¯ã™ã¹ã¦åŒã˜ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æŒã£ã¦ã„ã¾ã™:"

#: ../../library/os.path.rst:53
msgid ":mod:`posixpath` for UNIX-style paths"
msgstr ":mod:`posixpath` UNIX ã‚¹ã‚¿ã‚¤ãƒ«ã®ãƒ‘ã‚¹ç”¨"

#: ../../library/os.path.rst:54
msgid ":mod:`ntpath` for Windows paths"
msgstr ":mod:`ntpath` Windows ãƒ‘ã‚¹ç”¨"

#: ../../library/os.path.rst:55
msgid ":mod:`macpath` for old-style MacOS paths"
msgstr ":mod:`macpath` å¤ã„ã‚¹ã‚¿ã‚¤ãƒ«ã® MacOS ãƒ‘ã‚¹ç”¨"

#: ../../library/os.path.rst:60
msgid ""
"Return a normalized absolutized version of the pathname *path*. On most "
"platforms, this is equivalent to calling the function :func:`normpath` as "
"follows: ``normpath(join(os.getcwd(), path))``."
msgstr ""
"ãƒ‘ã‚¹å *path* ã®æ­£è¦åŒ–ã•ã‚ŒãŸçµ¶å¯¾ãƒ‘ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã»ã¨ã‚“ã©ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€ã“ã‚Œã¯é–¢æ•° :func:`normpath` "
"ã‚’æ¬¡ã®ã‚ˆã†ã«å‘¼ã³å‡ºã—ãŸæ™‚ã¨ç­‰ä¾¡ã§ã™: ``normpath(join(os.getcwd(), path))``ã€‚"

#: ../../library/os.path.rst:64 ../../library/os.path.rst:77
#: ../../library/os.path.rst:116 ../../library/os.path.rst:125
#: ../../library/os.path.rst:141 ../../library/os.path.rst:151
#: ../../library/os.path.rst:177 ../../library/os.path.rst:194
#: ../../library/os.path.rst:217 ../../library/os.path.rst:229
#: ../../library/os.path.rst:238 ../../library/os.path.rst:248
#: ../../library/os.path.rst:258 ../../library/os.path.rst:268
#: ../../library/os.path.rst:278 ../../library/os.path.rst:296
#: ../../library/os.path.rst:329 ../../library/os.path.rst:341
#: ../../library/os.path.rst:350 ../../library/os.path.rst:365
#: ../../library/os.path.rst:383 ../../library/os.path.rst:396
#: ../../library/os.path.rst:412 ../../library/os.path.rst:428
#: ../../library/os.path.rst:449 ../../library/os.path.rst:460
msgid "Accepts a :term:`path-like object`."
msgstr ":term:`path-like object` ã‚’å—ã‘å…¥ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/os.path.rst:70
msgid ""
"Return the base name of pathname *path*.  This is the second element of the "
"pair returned by passing *path* to the function :func:`split`.  Note that "
"the result of this function is different from the Unix :program:`basename` "
"program; where :program:`basename` for ``'/foo/bar/'`` returns ``'bar'``, "
"the :func:`basename` function returns an empty string (``''``)."
msgstr ""
"ãƒ‘ã‚¹å *path* ã®æœ«å°¾ã®ãƒ•ã‚¡ã‚¤ãƒ«åéƒ¨åˆ†ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯é–¢æ•° :func:`split` ã« *path* ã‚’æ¸¡ã—ãŸæ™‚ã«è¿”ã•ã‚Œã‚‹ãƒšã‚¢ã® 2 "
"ç•ªã‚ã®è¦ç´ ã§ã™ã€‚ã“ã®é–¢æ•°ãŒè¿”ã™ã®ã¯ Unix ã® :program:`basename` ã¨ã¯ç•°ãªã‚Šã¾ã™; Unix ã® "
":program:`basename` ã¯ ``'/foo/bar/'`` ã«å¯¾ã—ã¦ ``'bar'`` ã‚’è¿”ã—ã¾ã™ãŒã€é–¢æ•° "
":func:`basename` ã¯ç©ºæ–‡å­—åˆ— (``''``) ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:83
msgid ""
"Return the longest common sub-path of each pathname in the sequence *paths*."
"  Raise ValueError if *paths* contains both absolute and relative pathnames,"
" or if *paths* is empty.  Unlike :func:`commonprefix`, this returns a valid "
"path."
msgstr ""
"ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ *paths* ä¸­ã®å„ãƒ‘ã‚¹åã«å…±é€šã™ã‚‹ã‚µãƒ–ãƒ‘ã‚¹ã®ã†ã¡ã€æœ€ã‚‚é•·ã„ã‚‚ã®ã‚’è¿”ã—ã¾ã™ã€‚*paths* "
"ã«çµ¶å¯¾ãƒ‘ã‚¹åã¨ç›¸å¯¾ãƒ‘ã‚¹åã®ä¸¡æ–¹ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ã€*paths* ãŒç©ºã®å ´åˆã€ ValueError "
"ã‚’é€å‡ºã—ã¾ã™ã€‚:func:`commonprefix` ã¨ã¯ç•°ãªã‚Šã€æœ‰åŠ¹ãªãƒ‘ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:88
msgid "Availability: Unix, Windows"
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ : Unix, Windows"

#: ../../library/os.path.rst:92
msgid "Accepts a sequence of :term:`path-like objects <path-like object>`."
msgstr ":term:`path-like objects <path-like object>` ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’å—ã‘å…¥ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/os.path.rst:98
msgid ""
"Return the longest path prefix (taken character-by-character) that is a "
"prefix of all paths in  *list*.  If *list* is empty, return the empty string"
" (``''``)."
msgstr ""
"*list* å†…ã®ã™ã¹ã¦ã®ãƒ‘ã‚¹ã«å…±é€šã™ã‚‹æ¥é ­è¾ã®ã†ã¡ã€æœ€ã‚‚é•·ã„ã‚‚ã®ã‚’ (ãƒ‘ã‚¹åã® 1 æ–‡å­— 1 æ–‡å­—ã‚’åˆ¤æ–­ã—ã¦) è¿”ã—ã¾ã™ã€‚*list* "
"ãŒç©ºã®å ´åˆã€ç©ºæ–‡å­—åˆ— (``''``) ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:104
msgid ""
"This function may return invalid paths because it works a character at a "
"time.  To obtain a valid path, see :func:`commonpath`."
msgstr ""
"ã“ã®é–¢æ•°ã¯ä¸€åº¦ã« 1 æ–‡å­—ãšã¤å‡¦ç†ã™ã‚‹ãŸã‚ã€ä¸æ­£ãªãƒ‘ã‚¹ã‚’è¿”ã™å ´åˆãŒã‚ã‚Šã¾ã™ã€‚æœ‰åŠ¹ãªãƒ‘ã‚¹ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ã¯ã€:func:`commonpath` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/os.path.rst:122
msgid ""
"Return the directory name of pathname *path*.  This is the first element of "
"the pair returned by passing *path* to the function :func:`split`."
msgstr ""
"ãƒ‘ã‚¹å *path* ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯é–¢æ•° :func:`split` ã« *path* ã‚’æ¸¡ã—ãŸæ™‚ã«è¿”ã•ã‚Œã‚‹ãƒšã‚¢ã® 1 "
"ç•ªã‚ã®è¦ç´ ã§ã™ã€‚"

#: ../../library/os.path.rst:131
msgid ""
"Return ``True`` if *path* refers to an existing path or an open file "
"descriptor.  Returns ``False`` for broken symbolic links.  On some "
"platforms, this function may return ``False`` if permission is not granted "
"to execute :func:`os.stat` on the requested file, even if the *path* "
"physically exists."
msgstr ""
"*path* ãŒå®Ÿåœ¨ã™ã‚‹ãƒ‘ã‚¹ã‹ã‚ªãƒ¼ãƒ—ãƒ³ã—ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’å‚ç…§ã—ã¦ã„ã‚‹å ´åˆ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚å£Šã‚ŒãŸã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã«ã¤ã„ã¦ã¯ "
"``False`` ã‚’è¿”ã—ã¾ã™ã€‚ä¸€éƒ¨ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ã€ãŸã¨ãˆ *path* ãŒç‰©ç†çš„ã«å­˜åœ¨ã—ã¦ã„ãŸã¨ã—ã¦ã‚‚ã€è¦æ±‚ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã™ã‚‹ "
":func:`os.stat` ã®å®Ÿè¡Œæ¨©ãŒãªã‘ã‚Œã°ã“ã®é–¢æ•°ãŒ ``False`` ã‚’è¿”ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/os.path.rst:137
msgid ""
"*path* can now be an integer: ``True`` is returned if it is an  open file "
"descriptor, ``False`` otherwise."
msgstr ""
"*path* ã¯æ•´æ•°ã§ã‚‚å¯èƒ½ã«ãªã‚Šã¾ã—ãŸ: ãã‚ŒãŒã‚ªãƒ¼ãƒ—ãƒ³ã—ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ãªã‚‰ ``True`` ãŒè¿”ã‚Šã€ãã‚Œä»¥å¤–ãªã‚‰ ``False`` "
"ãŒè¿”ã‚Šã¾ã™ã€‚"

#: ../../library/os.path.rst:147
msgid ""
"Return ``True`` if *path* refers to an existing path. Returns ``True`` for "
"broken symbolic links.   Equivalent to :func:`exists` on platforms lacking "
":func:`os.lstat`."
msgstr ""
"*path* ãŒå®Ÿåœ¨ã™ã‚‹ãƒ‘ã‚¹ãªã‚‰ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚å£Šã‚ŒãŸã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã«ã¤ã„ã¦ã¯ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ "
":func:`os.lstat` ãŒãªã„ç’°å¢ƒã§ã¯ :func:`exists` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/os.path.rst:159
msgid ""
"On Unix and Windows, return the argument with an initial component of ``~`` "
"or ``~user`` replaced by that *user*'s home directory."
msgstr ""
"Unix ãŠã‚ˆã³ Windows ã§ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸå¼•æ•°ã®å…ˆé ­ã®ãƒ‘ã‚¹è¦ç´  ``~`` ã€ã¾ãŸã¯ ``~user`` ã‚’ã€ *user* "
"ã®ãƒ›ãƒ¼ãƒ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹ã«ç½®ãæ›ãˆã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:164
msgid ""
"On Unix, an initial ``~`` is replaced by the environment variable "
":envvar:`HOME` if it is set; otherwise the current user's home directory is "
"looked up in the password directory through the built-in module :mod:`pwd`. "
"An initial ``~user`` is looked up directly in the password directory."
msgstr ""
"Unix ã§ã¯ã€å…ˆé ­ã® ``~`` ã¯ã€ç’°å¢ƒå¤‰æ•° :envvar:`HOME` "
"ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ãªã‚‰ãã®å€¤ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚è¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ã®ãƒ›ãƒ¼ãƒ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`pwd` "
"ã‚’ä½¿ã£ã¦ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰æ¢ã—ã¦ç½®ãæ›ãˆã¾ã™ã€‚å…ˆé ­ã® ``~user`` ã«ã¤ã„ã¦ã¯ã€ç›´æ¥ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰æ¢ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:169
msgid ""
"On Windows, :envvar:`HOME` and :envvar:`USERPROFILE` will be used if set, "
"otherwise a combination of :envvar:`HOMEPATH` and :envvar:`HOMEDRIVE` will "
"be used.  An initial ``~user`` is handled by stripping the last directory "
"component from the created user path derived above."
msgstr ""
"Windows ã§ã¯ã€ :envvar:`HOME` ã¨ :envvar:`USERPROFILE` "
"ãŒè¨­å®šã•ã‚Œã¦ã„ã‚Œã°ãã‚Œã‚’ä½¿ç”¨ã—ã¾ã™ã€‚è¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ç’°å¢ƒå¤‰æ•° :envvar:`HOMEPATH` ã¨ :envvar:`HOMEDRIVE` "
"ã®çµ„ã¿åˆã‚ã›ã§ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚å…ˆé ­ã® ``~user`` ã¯ ``~`` ã§å¾—ã‚‰ã‚Œã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ‘ã‚¹ã®æœ€å¾Œã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªè¦ç´ ã‚’é™¤å»ã—ãŸã‚‚ã®ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:174
msgid ""
"If the expansion fails or if the path does not begin with a tilde, the path "
"is returned unchanged."
msgstr "ç½®ãæ›ãˆã«å¤±æ•—ã—ãŸã‚Šã€å¼•æ•°ã®ãƒ‘ã‚¹ãŒãƒãƒ«ãƒ€ã§å§‹ã¾ã£ã¦ã„ãªã‹ã£ãŸå ´åˆã¯ã€ãƒ‘ã‚¹ã‚’ãã®ã¾ã¾è¿”ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:186
msgid ""
"Return the argument with environment variables expanded.  Substrings of the "
"form ``$name`` or ``${name}`` are replaced by the value of environment "
"variable *name*.  Malformed variable names and references to non-existing "
"variables are left unchanged."
msgstr ""
"å¼•æ•°ã®ãƒ‘ã‚¹ã®ç’°å¢ƒå¤‰æ•°ã‚’å±•é–‹ã—ã¦è¿”ã—ã¾ã™ã€‚å¼•æ•°ã®ä¸­ã® ``$name`` ã¾ãŸã¯ ``${name}`` ã®ã‚ˆã†ãªå½¢å¼ã®æ–‡å­—åˆ—ã¯ç’°å¢ƒå¤‰æ•°ã€ *name* "
"ã®å€¤ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚ä¸æ­£ãªå¤‰æ•°åã‚„å­˜åœ¨ã—ãªã„å¤‰æ•°åã®å ´åˆã«ã¯å¤‰æ›ã•ã‚Œãšã€ãã®ã¾ã¾è¿”ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:191
msgid ""
"On Windows, ``%name%`` expansions are supported in addition to ``$name`` and"
" ``${name}``."
msgstr ""
"Windows ã§ã¯ã€ ``$name`` ã‚„ ``${name}`` ã®å½¢å¼ã«åŠ ãˆã¦ã€ ``%name%`` ã®å½¢å¼ã‚‚ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/os.path.rst:200
msgid ""
"Return the time of last access of *path*.  The return value is a number "
"giving the number of seconds since the epoch (see the  :mod:`time` module)."
"  Raise :exc:`OSError` if the file does not exist or is inaccessible."
msgstr ""
"*path* ã«æœ€å¾Œã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸæ™‚åˆ»ã‚’ã€ã‚¨ãƒãƒƒã‚¯ (:mod:`time` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§) "
"ã‹ã‚‰ã®çµŒéæ™‚é–“ã‚’ç¤ºã™ç§’æ•°ã§è¿”ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„ã€ã‚ã‚‹ã„ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã‹ã£ãŸå ´åˆã¯ :exc:`OSError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:204 ../../library/os.path.rst:214
msgid ""
"If :func:`os.stat_float_times` returns ``True``, the result is a floating "
"point number."
msgstr ":func:`os.stat_float_times` ãŒ ``True`` ã‚’è¿”ã™å ´åˆã€ã“ã®é–¢æ•°ã®è¿”ã‚Šå€¤ã¯æµ®å‹•å°æ•°ç‚¹æ•°ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/os.path.rst:210
msgid ""
"Return the time of last modification of *path*.  The return value is a "
"number giving the number of seconds since the epoch (see the  :mod:`time` "
"module). Raise :exc:`OSError` if the file does not exist or is inaccessible."
msgstr ""
"*path* ã‚’æœ€å¾Œã«æ›´æ–°ã—ãŸæ™‚åˆ»ã‚’ã€ã‚¨ãƒãƒƒã‚¯ (:mod:`time` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§) "
"ã‹ã‚‰ã®çµŒéæ™‚é–“ã‚’ç¤ºã™ç§’æ•°ã§è¿”ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„ã€ã‚ã‚‹ã„ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã‹ã£ãŸå ´åˆã¯ :exc:`OSError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:223
msgid ""
"Return the system's ctime which, on some systems (like Unix) is the time of "
"the last metadata change, and, on others (like Windows), is the creation "
"time for *path*. The return value is a number giving the number of seconds "
"since the epoch (see the  :mod:`time` module).  Raise :exc:`OSError` if the "
"file does not exist or is inaccessible."
msgstr ""
"ã‚·ã‚¹ãƒ†ãƒ ã® ctimeã€Unixç³»ãªã©ä¸€éƒ¨ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯æœ€å¾Œã«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚åˆ»ã€Windows ãªã©ãã®ä»–ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ *path* "
"ã®ä½œæˆæ™‚åˆ»ã‚’è¿”ã—ã¾ã™ã€‚è¿”ã‚Šå€¤ã¯ã‚¨ãƒãƒƒã‚¯ (:mod:`time` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§) "
"ã‹ã‚‰ã®çµŒéæ™‚é–“ã‚’ç¤ºã™ç§’æ•°ã«ãªã‚Šã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„ã€ã‚ã‚‹ã„ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã‹ã£ãŸå ´åˆã¯ :exc:`OSError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:235
msgid ""
"Return the size, in bytes, of *path*.  Raise :exc:`OSError` if the file does"
" not exist or is inaccessible."
msgstr ""
"*path* ã®ã‚µã‚¤ã‚ºã‚’ãƒã‚¤ãƒˆæ•°ã§è¿”ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„ã€ã‚ã‚‹ã„ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã‹ã£ãŸå ´åˆã¯ :exc:`OSError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:244
msgid ""
"Return ``True`` if *path* is an absolute pathname.  On Unix, that means it "
"begins with a slash, on Windows that it begins with a (back)slash after "
"chopping off a potential drive letter."
msgstr ""
"*path* ãŒçµ¶å¯¾ãƒ‘ã‚¹ãªã‚‰ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ã™ãªã‚ã¡ã€ Unix ã§ã¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§å§‹ã¾ã‚Šã€ Windows ã§ã¯ãƒ‰ãƒ©ã‚¤ãƒ–ãƒ¬ã‚¿ãƒ¼ã«ç¶šã "
"(ãƒãƒƒã‚¯) ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§å§‹ã¾ã‚‹å ´åˆã§ã™ã€‚"

#: ../../library/os.path.rst:254
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` regular file. This"
" follows symbolic links, so both :func:`islink` and :func:`isfile` can be "
"true for the same path."
msgstr ""

#: ../../library/os.path.rst:264
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` directory.  This "
"follows symbolic links, so both :func:`islink` and :func:`isdir` can be true"
" for the same path."
msgstr ""

#: ../../library/os.path.rst:274
msgid ""
"Return ``True`` if *path* refers to an :func:`existing <exists>` directory "
"entry that is a symbolic link.  Always ``False`` if symbolic links are not "
"supported by the Python runtime."
msgstr ""

#: ../../library/os.path.rst:284
msgid ""
"Return ``True`` if pathname *path* is a :dfn:`mount point`: a point in a "
"file system where a different file system has been mounted.  On POSIX, the "
"function checks whether *path*'s parent, :file:`path/..`, is on a different "
"device than *path*, or whether :file:`path/..` and *path* point to the same "
"i-node on the same device --- this should detect mount points for all Unix "
"and POSIX variants.  On Windows, a drive letter root and a share UNC are "
"always mount points, and for any other path ``GetVolumePathName`` is called "
"to see if it is different from the input path."
msgstr ""
"ãƒ‘ã‚¹å *path* ãŒãƒã‚¦ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒˆ :dfn:`mount point` "
"(ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ä¸­ã§ç•°ãªã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ãŒãƒã‚¦ãƒ³ãƒˆã•ã‚Œã¦ã„ã‚‹ã¨ã“ã‚) ãªã‚‰ã€ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚POSIX ã§ã¯ã€ã“ã®é–¢æ•°ã¯ "
"*path* ã®è¦ªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã‚ã‚‹ :file:`path/..` ãŒ *path* ã¨ç•°ãªã‚‹ãƒ‡ãƒã‚¤ã‚¹ä¸Šã«ã‚ã‚‹ã‹ã€ã‚ã‚‹ã„ã¯ "
":file:`path/..` ã¨ *path* ãŒåŒã˜ãƒ‡ãƒã‚¤ã‚¹ä¸Šã®åŒã˜ i-node ã‚’æŒ‡ã—ã¦ã„ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ --- ã“ã‚Œã«ã‚ˆã£ã¦å…¨ã¦ã® "
"Unix ç³»ã‚·ã‚¹ãƒ†ãƒ ã¨ POSIX æ¨™æº–ã§ãƒã‚¦ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒˆãŒæ¤œå‡ºã§ãã¾ã™ã€‚Windows ã§ã¯ã€ãƒ‰ãƒ©ã‚¤ãƒ–ãƒ¬ã‚¿ãƒ¼ã‚’æŒã¤ãƒ«ãƒ¼ãƒˆã¨å…±æœ‰ UNC "
"ã¯å¸¸ã«ãƒã‚¦ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒˆã§ã‚ã‚Šã€ã¾ãŸä»–ã®ãƒ‘ã‚¹ã§ã¯ã€å…¥åŠ›ã®ãƒ‘ã‚¹ãŒç•°ãªã‚‹ãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰ã®ã‚‚ã®ã‹è¦‹ã‚‹ãŸã‚ã« ``GetVolumePathName`` "
"ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/os.path.rst:293
msgid "Support for detecting non-root mount points on Windows."
msgstr "Windows ã§ã®ã€ãƒ«ãƒ¼ãƒˆã§ãªã„ãƒã‚¦ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒˆã®æ¤œå‡ºã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/os.path.rst:302
msgid ""
"Join one or more path components intelligently.  The return value is the "
"concatenation of *path* and any members of *\\*paths* with exactly one "
"directory separator (``os.sep``) following each non-empty part except the "
"last, meaning that the result will only end in a separator if the last part "
"is empty.  If a component is an absolute path, all previous components are "
"thrown away and joining continues from the absolute path component."
msgstr ""
"1 ã¤ã‚ã‚‹ã„ã¯ãã‚Œä»¥ä¸Šã®ãƒ‘ã‚¹ã®è¦ç´ ã‚’è³¢ãçµåˆã—ã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ *path*ã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®åŒºåˆ‡ã‚Šæ–‡å­— (``os.sep``) ã‚’ *\\*paths*"
" "
"ã®å„ãƒ‘ãƒ¼ãƒˆã®(æœ«å°¾ã§ãªã„å ´åˆã®ç©ºæ–‡å­—åˆ—ã‚’é™¤ã„ã¦)é ­ã«ä»˜ã‘ãŸã‚‚ã®ã€ã“ã‚Œã‚‰ã®çµåˆã«ãªã‚Šã¾ã™ã€‚æœ€å¾Œã®éƒ¨åˆ†ãŒç©ºæ–‡å­—åˆ—ã®å ´åˆã«é™ã‚ŠåŒºåˆ‡ã‚Šæ–‡å­—ã§çµ‚ã‚ã‚‹æ–‡å­—åˆ—ã«ãªã‚Šã¾ã™ã€‚ä»˜ã‘åŠ ãˆã‚‹è¦ç´ ã«çµ¶å¯¾ãƒ‘ã‚¹ãŒã‚ã‚Œã°ã€ãã‚Œã‚ˆã‚Šå‰ã®è¦ç´ ã¯å…¨ã¦ç ´æ£„ã•ã‚Œã€ä»¥é™ã®è¦ç´ ã‚’çµåˆã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:310
msgid ""
"On Windows, the drive letter is not reset when an absolute path component "
"(e.g., ``r'\\foo'``) is encountered.  If a component contains a drive "
"letter, all previous components are thrown away and the drive letter is "
"reset.  Note that since there is a current directory for each drive, "
"``os.path.join(\"c:\", \"foo\")`` represents a path relative to the current "
"directory on drive :file:`C:` (:file:`c:foo`), not :file:`c:\\\\foo`."
msgstr ""
"Windows ã®å ´åˆã¯ã€çµ¶å¯¾ãƒ‘ã‚¹ã®è¦ç´  (ãŸã¨ãˆã° ``r'\\foo'``) "
"ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã¯ãƒ‰ãƒ©ã‚¤ãƒ–ãƒ¬ã‚¿ãƒ¼ã¯ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã›ã‚“ã€‚è¦ç´ ã«ãƒ‰ãƒ©ã‚¤ãƒ–ãƒ¬ã‚¿ãƒ¼ãŒå«ã¾ã‚Œã¦ã„ã‚Œã°ã€ãã‚Œã‚ˆã‚Šå‰ã®è¦ç´ ã¯å…¨ã¦ç ´æ£„ã•ã‚Œã€ãƒ‰ãƒ©ã‚¤ãƒ–ãƒ¬ã‚¿ãƒ¼ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚å„ãƒ‰ãƒ©ã‚¤ãƒ–ã«å¯¾ã—ã¦ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒã‚ã‚‹ã®ã§ã€"
" ``os.path.join(\"c:\", \"foo\")`` ã«ã‚ˆã£ã¦ã€ :file:`c:\\\\foo` ã§ã¯ãªãã€ãƒ‰ãƒ©ã‚¤ãƒ– "
":file:`C:` ä¸Šã®ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹(:file:`c:foo`) ãŒè¿”ã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/os.path.rst:317
msgid "Accepts a :term:`path-like object` for *path* and *paths*."
msgstr "*path* ã¨ *paths* ãŒ :term:`path-like object` ã‚’å—ã‘ä»˜ã‘ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/os.path.rst:323
msgid ""
"Normalize the case of a pathname.  On Unix and Mac OS X, this returns the "
"path unchanged; on case-insensitive filesystems, it converts the path to "
"lowercase.  On Windows, it also converts forward slashes to backward "
"slashes. Raise a TypeError if the type of *path* is not ``str`` or ``bytes``"
" (directly or indirectly through the :class:`os.PathLike` interface)."
msgstr ""

#: ../../library/os.path.rst:335
msgid ""
"Normalize a pathname by collapsing redundant separators and up-level "
"references so that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all "
"become ``A/B``.  This string manipulation may change the meaning of a path "
"that contains symbolic links.  On Windows, it converts forward slashes to "
"backward slashes. To normalize case, use :func:`normcase`."
msgstr ""
"ãƒ‘ã‚¹ã‚’æ­£è¦åŒ–ã—ã¾ã™ã€‚ä½™åˆ†ãªåŒºåˆ‡ã‚Šæ–‡å­—ã‚„ä¸Šä½ãƒ¬ãƒ™ãƒ«å‚ç…§ã‚’é™¤å»ã—ã€``A//B``ã€``A/B/``ã€``A/./B`` ã‚„ ``A/foo/../B`` "
"ãªã©ã¯ã™ã¹ã¦ ``A/B`` ã«ãªã‚Šã¾ã™ã€‚ã“ã®æ–‡å­—åˆ—æ“ä½œã¯ã€ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‚’å«ã‚€ãƒ‘ã‚¹ã®æ„å‘³ã‚’å¤‰ãˆã¦ã—ã¾ã†å ´åˆãŒã‚ã‚Šã¾ã™ã€‚Windows "
"ã§ã¯ã€ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«å¤‰æ›ã—ã¾ã™ã€‚å¤§æ–‡å­—å°æ–‡å­—ã®æ­£è¦åŒ–ã«ã¯ :func:`normcase` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/os.path.rst:347
msgid ""
"Return the canonical path of the specified filename, eliminating any "
"symbolic links encountered in the path (if they are supported by the "
"operating system)."
msgstr ""
"ãƒ‘ã‚¹ã®ä¸­ã®ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ (ã‚‚ã—ãã‚ŒãŒå½“è©²ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚Œã°) "
"ã‚’å–ã‚Šé™¤ã„ã¦ã€æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«åã‚’æ­£è¦åŒ–ã—ãŸãƒ‘ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:356
msgid ""
"Return a relative filepath to *path* either from the current directory or "
"from an optional *start* directory.  This is a path computation:  the "
"filesystem is not accessed to confirm the existence or nature of *path* or "
"*start*."
msgstr ""
"ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚ã‚‹ã„ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *start* ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ã® *path* "
"ã¸ã®ç›¸å¯¾ãƒ‘ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒ‘ã‚¹è¨ˆç®—ã§è¡Œã£ã¦ãŠã‚Šã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ *path* ã‚„ *start* "
"ã®å­˜åœ¨ã‚„æ€§è³ªã‚’ç¢ºèªã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/os.path.rst:361
msgid "*start* defaults to :attr:`os.curdir`."
msgstr "*start* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ :attr:`os.curdir` ã§ã™ã€‚"

#: ../../library/os.path.rst:363 ../../library/os.path.rst:375
#: ../../library/os.path.rst:391 ../../library/os.path.rst:407
msgid "Availability: Unix, Windows."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ : Unix ã€ Windows ã€‚"

#: ../../library/os.path.rst:371
msgid ""
"Return ``True`` if both pathname arguments refer to the same file or "
"directory. This is determined by the device number and i-node number and "
"raises an exception if an :func:`os.stat` call on either pathname fails."
msgstr ""
"å¼•æ•°ã®ä¸¡ãƒ‘ã‚¹åãŒåŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å‚ç…§ã—ã¦ã„ã‚‹å ´åˆã€ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒ‡ãƒã‚¤ã‚¹ç•ªå·ã¨ i-node "
"ç•ªå·ã§æ±ºå®šã•ã‚Œã¾ã™ã€‚ã©ã¡ã‚‰ã‹ã®ãƒ‘ã‚¹åã¸ã® :func:`os.stat` å‘¼ã³å‡ºã—ãŒå¤±æ•—ã—ãŸå ´åˆã€ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/os.path.rst:377 ../../library/os.path.rst:393
#: ../../library/os.path.rst:409
msgid "Added Windows support."
msgstr "Windows ã‚µãƒãƒ¼ãƒˆã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚"

#: ../../library/os.path.rst:380
msgid "Windows now uses the same implementation as all other platforms."
msgstr "Windows ãŒä»–ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã¨åŒã˜å®Ÿè£…ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/os.path.rst:389
msgid ""
"Return ``True`` if the file descriptors *fp1* and *fp2* refer to the same "
"file."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ *fp1* ã¨ *fp2* ãŒåŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§ã—ã¦ã„ãŸã‚‰ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:402
msgid ""
"Return ``True`` if the stat tuples *stat1* and *stat2* refer to the same "
"file. These structures may have been returned by :func:`os.fstat`, "
":func:`os.lstat`, or :func:`os.stat`.  This function implements the "
"underlying comparison used by :func:`samefile` and :func:`sameopenfile`."
msgstr ""
"stat ã‚¿ãƒ—ãƒ« *stat1* ã¨ *stat2* ãŒåŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§ã—ã¦ã„ã‚Œã° ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã‚¿ãƒ—ãƒ«ã¯ "
":func:`os.fstat` ã€ :func:`os.lstat` ã‚ã‚‹ã„ã¯ :func:`os.stat` ã®è¿”ã‚Šå€¤ã§æ§‹ã„ã¾ã›ã‚“ã€‚ã“ã®é–¢æ•°ã¯ "
":func:`samefile` ã¨ :func:`sameopenfile` ã‚’ä½¿ç”¨ã—ãŸæ¯”è¼ƒã«åŸºã„ã¦å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/os.path.rst:418
msgid ""
"Split the pathname *path* into a pair, ``(head, tail)`` where *tail* is the "
"last pathname component and *head* is everything leading up to that.  The "
"*tail* part will never contain a slash; if *path* ends in a slash, *tail* "
"will be empty.  If there is no slash in *path*, *head* will be empty.  If "
"*path* is empty, both *head* and *tail* are empty.  Trailing slashes are "
"stripped from *head* unless it is the root (one or more slashes only).  In "
"all cases, ``join(head, tail)`` returns a path to the same location as "
"*path* (but the strings may differ).  Also see the functions :func:`dirname`"
" and :func:`basename`."
msgstr ""
"ãƒ‘ã‚¹å *path* ã‚’ ``(head, tail)`` ã®ãƒšã‚¢ã«åˆ†å‰²ã—ã¾ã™ã€‚ *tail* ã¯ãƒ‘ã‚¹åã®æ§‹æˆè¦ç´ ã®æœ«å°¾ã§ã€ *head* "
"ã¯ãã‚Œã‚ˆã‚Šå‰ã®éƒ¨åˆ†ã§ã™ã€‚ *tail* ã¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’å«ã¿ã¾ã›ã‚“; ã‚‚ã— *path* ãŒã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§çµ‚ã‚ã£ã¦ã„ã‚Œã° *tail* "
"ã¯ç©ºæ–‡å­—åˆ—ã«ãªã‚Šã¾ã™ã€‚ã‚‚ã— *path* ã«ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ãŒãªã‘ã‚Œã°ã€ *head* ã¯ç©ºæ–‡å­—ã«ãªã‚Šã¾ã™ã€‚ *path* ãŒç©ºæ–‡å­—ãªã‚‰ã€ *head* ã¨ "
"*tail* ã®ä¸¡æ–¹ãŒç©ºæ–‡å­—ã«ãªã‚Šã¾ã™ã€‚ *head* ã®æœ«å°¾ã®ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¯ *head* ãŒãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª (ã¾ãŸã¯ 1 å€‹ä»¥ä¸Šã®ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã ã‘)"
" ã§ãªã„é™ã‚Šå–ã‚Šé™¤ã‹ã‚Œã¾ã™ã€‚ ``join(head, tail)`` ã¯å¸¸ã« *path* "
"ã¨åŒã˜å ´æ‰€ã‚’è¿”ã—ã¾ã™ãŒã€æ–‡å­—åˆ—ã¨ã—ã¦ã¯ç•°ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚é–¢æ•° :func:`dirname`, :func:`basename` "
"ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/os.path.rst:434
msgid ""
"Split the pathname *path* into a pair ``(drive, tail)`` where *drive* is "
"either a mount point or the empty string.  On systems which do not use drive"
" specifications, *drive* will always be the empty string.  In all cases, "
"``drive + tail`` will be the same as *path*."
msgstr ""
"ãƒ‘ã‚¹å *path* ã‚’ ``(drive, tail)`` ã®ãƒšã‚¢ã«åˆ†å‰²ã—ã¾ã™ã€‚*drive* "
"ã¯ãƒã‚¦ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒˆã‹ç©ºæ–‡å­—åˆ—ã«ãªã‚Šã¾ã™ã€‚ãƒ‰ãƒ©ã‚¤ãƒ–æŒ‡å®šã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€*drive* "
"ã¯å¸¸ã«ç©ºæ–‡å­—ã«ãªã‚Šã¾ã™ã€‚ã©ã®å ´åˆã§ã‚‚ã€``drive + tail`` ã¯ *path* ã¨ç­‰ã—ããªã‚Šã¾ã™ã€‚"

#: ../../library/os.path.rst:439
msgid ""
"On Windows, splits a pathname into drive/UNC sharepoint and relative path."
msgstr "Windows ã§ã¯ã€ãƒ‘ã‚¹åã¯ãƒ‰ãƒ©ã‚¤ãƒ–å/UNC å…±æœ‰ãƒã‚¤ãƒ³ãƒˆã¨ç›¸å¯¾ãƒ‘ã‚¹ã«åˆ†å‰²ã•ã‚Œã¾ã™ã€‚"

#: ../../library/os.path.rst:441
msgid ""
"If the path contains a drive letter, drive will contain everything up to and"
" including the colon. e.g. ``splitdrive(\"c:/dir\")`` returns ``(\"c:\", "
"\"/dir\")``"
msgstr ""
"ãƒ‘ã‚¹ãŒãƒ‰ãƒ©ã‚¤ãƒ–ãƒ¬ã‚¿ãƒ¼ã‚’å«ã‚€å ´åˆã€ãƒ‰ãƒ©ã‚¤ãƒ–ãƒ¬ã‚¿ãƒ¼ã«ã¯ã‚³ãƒ­ãƒ³ã¾ã§ãŒå«ã¾ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€``splitdrive(\"c:/dir\")`` ã¯ "
"``(\"c:\", \"/dir\")`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:445
msgid ""
"If the path contains a UNC path, drive will contain the host name and share,"
" up to but not including the fourth separator. e.g. "
"``splitdrive(\"//host/computer/dir\")`` returns ``(\"//host/computer\", "
"\"/dir\")``"
msgstr ""
"ãƒ‘ã‚¹ãŒ UNC "
"ãƒ‘ã‚¹ã‚’å«ã‚€å ´åˆã€ãƒ‰ãƒ©ã‚¤ãƒ–ãƒ¬ã‚¿ãƒ¼ã«ã¯ãƒ›ã‚¹ãƒˆåã¨å…±æœ‰åã¾ã§ãŒå«ã¾ã‚Œã¾ã™ãŒã€å…±æœ‰åã®å¾Œã®åŒºåˆ‡ã‚Šæ–‡å­—ã¯å«ã¾ã‚Œã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€``splitdrive(\"//host/computer/dir\")``"
" ã¯ ``(\"//host/computer\", \"/dir\")`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:455
msgid ""
"Split the pathname *path* into a pair ``(root, ext)``  such that ``root + "
"ext == path``, and *ext* is empty or begins with a period and contains at "
"most one period. Leading periods on the basename are  ignored; "
"``splitext('.cshrc')`` returns  ``('.cshrc', '')``."
msgstr ""
"ãƒ‘ã‚¹å *path* ã‚’ ``(root, ext)`` ã®ãƒšã‚¢ã«åˆ†å‰²ã—ã¾ã™ã€‚ ``root + ext == path`` ã«ãªã‚Šã¾ã™ã€‚ *ext* "
"ã¯ç©ºæ–‡å­—åˆ—ã‹ 1 ã¤ã®ãƒ”ãƒªã‚ªãƒ‰ã§å§‹ã¾ã‚Šã€å¤šãã¦ã‚‚ 1 ã¤ã®ãƒ”ãƒªã‚ªãƒ‰ã‚’å«ã¿ã¾ã™ã€‚ãƒ™ãƒ¼ã‚¹ãƒãƒ¼ãƒ ã‚’å°å‡ºã™ã‚‹ãƒ”ãƒªã‚ªãƒ‰ã¯ç„¡è¦–ã•ã‚Œã¾ã™; "
"``splitext('.cshrc')`` ã¯ ``('.cshrc', '')`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/os.path.rst:466
msgid "Use *splitdrive* instead."
msgstr "ä»£ã‚ã‚Šã« *splitdrive* ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/os.path.rst:469
msgid ""
"Split the pathname *path* into a pair ``(unc, rest)`` so that *unc* is the "
"UNC mount point (such as ``r'\\\\host\\mount'``), if present, and *rest* the"
" rest of the path (such as  ``r'\\path\\file.ext'``).  For paths containing "
"drive letters, *unc* will always be the empty string."
msgstr ""
"ãƒ‘ã‚¹å *path* ã‚’ãƒšã‚¢ ``(unc, rest)`` ã«åˆ†å‰²ã—ã¾ã™ã€‚ã“ã“ã§ *unc* ã¯ (``r'\\\\host\\mount'`` "
"ã®ã‚ˆã†ãª) UNC ãƒã‚¦ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒˆã€ãã—ã¦ *rest* ã¯ (``r'\\path\\file.ext'`` ã®ã‚ˆã†ãª) "
"ãƒ‘ã‚¹ã®æ®‹ã‚Šã®éƒ¨åˆ†ã§ã™ã€‚ãƒ‰ãƒ©ã‚¤ãƒ–ãƒ¬ã‚¿ãƒ¼ã‚’å«ã‚€ãƒ‘ã‚¹ã§ã¯å¸¸ã« *unc* ãŒç©ºæ–‡å­—åˆ—ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/os.path.rst:474
msgid "Availability:  Windows."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ: Windowsã€‚"

#: ../../library/os.path.rst:479
msgid ""
"``True`` if arbitrary Unicode strings can be used as file names (within "
"limitations imposed by the file system)."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«åã«ä»»æ„ã® Unicode æ–‡å­—åˆ—ã‚’ (ã‚·ã‚¹ãƒ†ãƒ ã®åˆ¶é™å†…ã§) ä½¿ç”¨ã§ãã‚‹å ´åˆã¯ ``True`` ã«ãªã‚Šã¾ã™ã€‚"
