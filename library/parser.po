# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-05 15:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/parser.rst:2
msgid ":mod:`parser` --- Access Python parse trees"
msgstr ":mod:`parser` --- Python è§£ææœ¨ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹"

#: ../../library/parser.rst:21
msgid ""
"The :mod:`parser` module provides an interface to Python's internal parser "
"and byte-code compiler.  The primary purpose for this interface is to allow "
"Python code to edit the parse tree of a Python expression and create "
"executable code from this.  This is better than trying to parse and modify "
"an arbitrary Python code fragment as a string because parsing is performed "
"in a manner identical to the code forming the application.  It is also "
"faster."
msgstr ""
":mod:`parser` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ Python "
"ã®å†…éƒ¨ãƒ‘ãƒ¼ã‚µã¨ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ»ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¸ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã®ç¬¬ä¸€ã®ç›®çš„ã¯ã€ Python ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ Python "
"ã®å¼ã®è§£ææœ¨ã‚’ç·¨é›†ã—ãŸã‚Šã€ã“ã‚Œã‹ã‚‰å®Ÿè¡Œå¯èƒ½ãªã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆã—ãŸã‚Šã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã¯ä»»æ„ã® Python "
"ã‚³ãƒ¼ãƒ‰ã®æ–­ç‰‡ã‚’æ–‡å­—åˆ—ã¨ã—ã¦æ§‹æ–‡è§£æã‚„å¤‰æ›´ã‚’è¡Œã†ã‚ˆã‚Šè‰¯ã„æ–¹æ³•ã§ã™ã€‚ãªãœãªã‚‰ã€æ§‹æ–‡è§£æãŒã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ã¨åŒã˜æ–¹æ³•ã§å®Ÿè¡Œã•ã‚Œã‚‹ã‹ã‚‰ã§ã™ã€‚ãã®ä¸Šã€é«˜é€Ÿã§ã™ã€‚"

#: ../../library/parser.rst:30
msgid ""
"From Python 2.5 onward, it's much more convenient to cut in at the Abstract "
"Syntax Tree (AST) generation and compilation stage, using the :mod:`ast` "
"module."
msgstr ""
"Python 2.5 ä»¥é™ã€æŠ½è±¡æ§‹æ–‡æœ¨ (AST) ã®ç”Ÿæˆãƒ»ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã®æ®µéšã«å‰²ã‚Šè¾¼ã‚€ã«ã¯ :mod:`ast` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã†ã®ãŒãšã£ã¨ãŠæ‰‹è»½ã§ã™ã€‚"

#: ../../library/parser.rst:34
msgid ""
"There are a few things to note about this module which are important to "
"making use of the data structures created.  This is not a tutorial on "
"editing the parse trees for Python code, but some examples of using the "
":mod:`parser` module are presented."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦æ³¨æ„ã™ã¹ãã“ã¨ãŒå°‘ã—ã‚ã‚Šã¾ã™ã€‚ãã‚Œã¯ä½œæˆã—ãŸãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚ã«é‡è¦ãªã“ã¨ã§ã™ã€‚ã“ã®æ–‡æ›¸ã¯ Python "
"ã‚³ãƒ¼ãƒ‰ã®è§£ææœ¨ã‚’ç·¨é›†ã™ã‚‹ãŸã‚ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ :mod:`parser` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ãŸä¾‹ã‚’ã„ãã¤ã‹ç¤ºã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/parser.rst:39
msgid ""
"Most importantly, a good understanding of the Python grammar processed by "
"the internal parser is required.  For full information on the language "
"syntax, refer to :ref:`reference-index`.  The parser itself is created from "
"a grammar specification defined in the file :file:`Grammar/Grammar` in the "
"standard Python distribution.  The parse trees stored in the ST objects "
"created by this module are the actual output from the internal parser when "
"created by the :func:`expr` or :func:`suite` functions, described below.  "
"The ST objects created by :func:`sequence2st` faithfully simulate those "
"structures.  Be aware that the values of the sequences which are considered "
"\"correct\" will vary from one version of Python to another as the formal "
"grammar for the language is revised.  However, transporting code from one "
"Python version to another as source text will always allow correct parse "
"trees to be created in the target version, with the only restriction being "
"that migrating to an older version of the interpreter will not support more "
"recent language constructs.  The parse trees are not typically compatible "
"from one version to another, whereas source code has always been forward-"
"compatible."
msgstr ""
"ã‚‚ã£ã¨ã‚‚é‡è¦ãªã“ã¨ã¯ã€å†…éƒ¨ãƒ‘ãƒ¼ã‚µãŒå‡¦ç†ã™ã‚‹ Python "
"ã®æ–‡æ³•ã«ã¤ã„ã¦ã‚ˆãç†è§£ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚è¨€èªã®æ–‡æ³•ã«é–¢ã™ã‚‹å®Œå…¨ãªæƒ…å ±ã«ã¤ã„ã¦ã¯ã€ :ref:`reference-index` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚æ¨™æº–ã® Python ãƒ‡ã‚£ã‚¹ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã«å«ã¾ã‚Œã‚‹ãƒ•ã‚¡ã‚¤ãƒ« :file:`Grammar/Grammar` "
"ã®ä¸­ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹æ–‡æ³•ä»•æ§˜ã‹ã‚‰ã€ãƒ‘ãƒ¼ã‚µè‡ªèº«ã¯ä½œæˆã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä½œæˆã™ã‚‹ ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸­ã«æ ¼ç´ã•ã‚Œã‚‹è§£ææœ¨ã¯ã€ä¸‹ã§èª¬æ˜ã™ã‚‹ "
":func:`expr` ã¾ãŸã¯ :func:`suite` é–¢æ•°ã«ã‚ˆã£ã¦ä½œã‚‰ã‚Œã‚‹ã¨ãã«å†…éƒ¨ãƒ‘ãƒ¼ã‚µã‹ã‚‰å®Ÿéš›ã«å‡ºåŠ›ã•ã‚Œã‚‹ã‚‚ã®ã§ã™ã€‚ "
":func:`sequence2st` ãŒä½œã‚‹ ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¿ å®Ÿã«ã“ã‚Œã‚‰ã®æ§‹é€ ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚è¨€èªã®å½¢å¼æ–‡æ³•ãŒæ”¹è¨‚ã•ã‚Œã‚‹ãŸã‚ã«ã€ "
"\"æ­£ã—ã„\" ã¨è€ƒãˆã‚‰ã‚Œã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å€¤ãŒ Python ã®ã‚ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‹ã‚‰åˆ¥ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§å¤‰åŒ–ã™ã‚‹ã“ã¨ãŒã‚ã‚‹ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã—ã‹ã—ã€"
" Python "
"ã®ã‚ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‹ã‚‰åˆ¥ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¸ãƒ†ã‚­ã‚¹ãƒˆã®ã‚½ãƒ¼ã‚¹ã®ã¾ã¾ã‚³ãƒ¼ãƒ‰ã‚’ç§»ã›ã°ã€ç›®çš„ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§æ­£ã—ã„è§£ææœ¨ã‚’å¸¸ã«ä½œæˆã§ãã¾ã™ã€‚ãŸã ã—ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã®å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¸ç§»è¡Œã™ã‚‹éš›ã«ã€æœ€è¿‘ã®è¨€èªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ã“ã¨ãŒã‚ã‚‹ã¨ã„ã†åˆ¶é™ã ã‘ãŒã‚ã‚Šã¾ã™ã€‚ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ãŒå¸¸ã«å‰æ–¹äº’æ›æ€§ãŒã‚ã‚‹ã®ã«å¯¾ã—ã¦ã€ä¸€èˆ¬çš„ã«è§£ææœ¨ã¯ã‚ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‹ã‚‰åˆ¥ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¸ã®äº’æ›æ€§ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/parser.rst:56
msgid ""
"Each element of the sequences returned by :func:`st2list` or "
":func:`st2tuple` has a simple form.  Sequences representing non-terminal "
"elements in the grammar always have a length greater than one.  The first "
"element is an integer which identifies a production in the grammar.  These "
"integers are given symbolic names in the C header file "
":file:`Include/graminit.h` and the Python module :mod:`symbol`.  Each "
"additional element of the sequence represents a component of the production "
"as recognized in the input string: these are always sequences which have the"
" same form as the parent.  An important aspect of this structure which "
"should be noted is that keywords used to identify the parent node type, such"
" as the keyword :keyword:`if` in an :const:`if_stmt`, are included in the "
"node tree without any special treatment.  For example, the :keyword:`if` "
"keyword is represented by the tuple ``(1, 'if')``, where ``1`` is the "
"numeric value associated with all :const:`NAME` tokens, including variable "
"and function names defined by the user.  In an alternate form returned when "
"line number information is requested, the same token might be represented as"
" ``(1, 'if', 12)``, where the ``12`` represents the line number at which the"
" terminal symbol was found."
msgstr ""
":func:`st2list` ã¾ãŸã¯ :func:`st2tuple` "
"ã‹ã‚‰è¿”ã•ã‚Œã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ãã‚Œãã‚Œã®è¦ç´ ã¯å˜ç´”ãªå½¢å¼ã§ã™ã€‚æ–‡æ³•ã®éçµ‚ç«¯è¦ç´ ã‚’è¡¨ã™ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯å¸¸ã«ä¸€ã‚ˆã‚Šå¤§ãã„é•·ã•ã‚’æŒã¡ã¾ã™ã€‚æœ€åˆã®è¦ç´ ã¯æ–‡æ³•ã®ç”Ÿæˆè¦å‰‡ã‚’è­˜åˆ¥ã™ã‚‹æ•´æ•°ã§ã™ã€‚ã“ã‚Œã‚‰ã®æ•´æ•°ã¯"
" C ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ« :file:`Include/graminit.h` ã¨ Python ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`symbol` "
"ã®ä¸­ã®ç‰¹å®šã®ã‚·ãƒ³ãƒœãƒ«åã§ã™ã€‚ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ä»˜ã‘åŠ ãˆã‚‰ã‚Œã¦ã„ã‚‹å„è¦ç´ ã¯ã€å…¥åŠ›æ–‡å­—åˆ—ã®ä¸­ã§èªè­˜ã•ã‚ŒãŸã¾ã¾ã®å½¢ã§ç”Ÿæˆè¦å‰‡ã®æ§‹æˆè¦ç´ ã‚’è¡¨ã—ã¦ã„ã¾ã™: "
"ã“ã‚Œã‚‰ã¯å¸¸ã«è¦ªã¨åŒã˜å½¢å¼ã‚’æŒã¤ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã™ã€‚ã“ã®æ§‹é€ ã®æ³¨æ„ã™ã¹ãé‡è¦ãªå´é¢ã¯ã€ :const:`if_stmt` ã®ä¸­ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ "
":keyword:`if` "
"ã®ã‚ˆã†ãªè¦ªãƒãƒ¼ãƒ‰ã®å‹ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒã„ã‹ãªã‚‹ç‰¹åˆ¥ãªæ‰±ã„ã‚‚ãªããƒãƒ¼ãƒ‰ãƒ„ãƒªãƒ¼ã«å«ã¾ã‚Œã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ä¾‹ãˆã°ã€ "
":keyword:`if` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯ã‚¿ãƒ—ãƒ« ``(1, 'if')`` ã¨è¡¨ã•ã‚Œã¾ã™ã€‚ã“ã“ã§ã€ ``1`` "
"ã¯ã€ãƒ¦ãƒ¼ã‚¶ãŒå®šç¾©ã—ãŸå¤‰æ•°åã¨é–¢æ•°åã‚’å«ã‚€ã™ã¹ã¦ã® :const:`NAME` "
"ãƒˆãƒ¼ã‚¯ãƒ³ã«å¯¾å¿œã™ã‚‹æ•°å€¤ã§ã™ã€‚è¡Œç•ªå·æƒ…å ±ãŒå¿…è¦ãªã¨ãã«è¿”ã•ã‚Œã‚‹åˆ¥ã®å½¢å¼ã§ã¯ã€åŒã˜ãƒˆãƒ¼ã‚¯ãƒ³ãŒ ``(1, 'if', 12)`` "
"ã®ã‚ˆã†ã«è¡¨ã•ã‚Œã¾ã™ã€‚ã“ã“ã§ã¯ã€ ``12`` ãŒçµ‚ç«¯è¨˜å·ã®è¦‹ã¤ã‹ã£ãŸè¡Œç•ªå·ã‚’è¡¨ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/parser.rst:73
msgid ""
"Terminal elements are represented in much the same way, but without any "
"child elements and the addition of the source text which was identified.  "
"The example of the :keyword:`if` keyword above is representative.  The "
"various types of terminal symbols are defined in the C header file "
":file:`Include/token.h` and the Python module :mod:`token`."
msgstr ""
"çµ‚ç«¯è¦ç´ ã¯åŒã˜æ–¹æ³•ã§è¡¨ç¾ã•ã‚Œã¾ã™ãŒã€å­ã®è¦ç´ ã‚„è­˜åˆ¥ã•ã‚ŒãŸã‚½ãƒ¼ã‚¹ãƒ†ã‚­ã‚¹ãƒˆã®è¿½åŠ ã¯å…¨ãã‚ã‚Šã¾ã›ã‚“ã€‚ä¸Šè¨˜ã® :keyword:`if` "
"ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ä¾‹ãŒä»£è¡¨çš„ãªã‚‚ã®ã§ã™ã€‚çµ‚ç«¯è¨˜å·ã®ã„ã‚ã„ã‚ãªå‹ã¯ã€ C ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ« :file:`Include/token.h` ã¨ Python "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`token` ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/parser.rst:79
msgid ""
"The ST objects are not required to support the functionality of this module,"
" but are provided for three purposes: to allow an application to amortize "
"the cost of processing complex parse trees, to provide a parse tree "
"representation which conserves memory space when compared to the Python list"
" or tuple representation, and to ease the creation of additional modules in "
"C which manipulate parse trees.  A simple \"wrapper\" class may be created "
"in Python to hide the use of ST objects."
msgstr ""
"ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ©Ÿèƒ½ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«å¿…è¦ã‚ã‚Šã¾ã›ã‚“ãŒã€ä¸‰ã¤ã®ç›®çš„ã‹ã‚‰æä¾›ã•ã‚Œã¦ã„ã¾ã™: "
"ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒè¤‡é›‘ãªè§£ææœ¨ã‚’å‡¦ç†ã™ã‚‹ã‚³ã‚¹ãƒˆã‚’å„Ÿå´ã™ã‚‹ãŸã‚ã€Python "
"ã®ãƒªã‚¹ãƒˆã‚„ã‚¿ãƒ—ãƒ«è¡¨ç¾ã«æ¯”ã¹ã¦ãƒ¡ãƒ¢ãƒªç©ºé–“ã‚’ä¿å…¨ã™ã‚‹è§£ææœ¨è¡¨ç¾ã‚’æä¾›ã™ã‚‹ãŸã‚ã€è§£ææœ¨ã‚’æ“ä½œã™ã‚‹è¿½åŠ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ C ã§ä½œã‚‹ã“ã¨ã‚’ç°¡å˜ã«ã™ã‚‹ãŸã‚ã€‚ST "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã£ã¦ã„ã‚‹ã“ã¨ã‚’éš ã™ãŸã‚ã«ã€ç°¡å˜ãª \"ãƒ©ãƒƒãƒ‘ãƒ¼\" ã‚¯ãƒ©ã‚¹ã‚’ Python ã§ä½œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/parser.rst:87
msgid ""
"The :mod:`parser` module defines functions for a few distinct purposes.  The"
" most important purposes are to create ST objects and to convert ST objects "
"to other representations such as parse trees and compiled code objects, but "
"there are also functions which serve to query the type of parse tree "
"represented by an ST object."
msgstr ""
":mod:`parser` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯äºŒã€ä¸‰ã®åˆ¥ã€…ã®ç›®çš„ã®ãŸã‚ã«é–¢æ•°ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ã‚‚ã£ã¨ã‚‚é‡è¦ãªç›®çš„ã¯ ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚‹ã“ã¨ã¨ã€ ST "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è§£ææœ¨ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚ˆã†ãªä»–ã®è¡¨ç¾ã«å¤‰æ›ã™ã‚‹ã“ã¨ã§ã™ã€‚ã—ã‹ã—ã€ ST "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§è¡¨ç¾ã•ã‚ŒãŸè§£ææœ¨ã®å‹ã‚’èª¿ã¹ã‚‹ãŸã‚ã«å½¹ã«ç«‹ã¤é–¢æ•°ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/parser.rst:97
msgid "Module :mod:`symbol`"
msgstr ":mod:`symbol` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/parser.rst:97
msgid "Useful constants representing internal nodes of the parse tree."
msgstr "è§£ææœ¨ã®å†…éƒ¨ãƒãƒ¼ãƒ‰ã‚’è¡¨ã™ä¾¿åˆ©ãªå®šæ•°ã€‚"

#: ../../library/parser.rst:100
msgid "Module :mod:`token`"
msgstr ":mod:`token` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/parser.rst:100
msgid ""
"Useful constants representing leaf nodes of the parse tree and functions for"
" testing node values."
msgstr "ä¾¿åˆ©ãªè§£ææœ¨ã®è‘‰ã®ãƒãƒ¼ãƒ‰ã‚’è¡¨ã™å®šæ•°ã¨ãƒãƒ¼ãƒ‰å€¤ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ãŸã‚ã®é–¢æ•°ã€‚"

#: ../../library/parser.rst:107
msgid "Creating ST Objects"
msgstr "ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹"

#: ../../library/parser.rst:109
msgid ""
"ST objects may be created from source code or from a parse tree. When "
"creating an ST object from source, different functions are used to create "
"the ``'eval'`` and ``'exec'`` forms."
msgstr ""
"ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚ã‚‹ã„ã¯è§£ææœ¨ã‹ã‚‰ä½œã‚‰ã‚Œã¾ã™ã€‚ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚½ãƒ¼ã‚¹ã‹ã‚‰ä½œã‚‹ã¨ãã¯ã€``'eval'`` ã¨ ``'exec'`` "
"å½¢å¼ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«åˆ¥ã€…ã®é–¢æ•°ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/parser.rst:116
msgid ""
"The :func:`expr` function parses the parameter *source* as if it were an "
"input to ``compile(source, 'file.py', 'eval')``.  If the parse succeeds, an "
"ST object is created to hold the internal parse tree representation, "
"otherwise an appropriate exception is raised."
msgstr ""
"ã¾ã‚‹ã§ ``compile(source, 'file.py', 'eval')`` ã¸ã®å…¥åŠ›ã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«ã€ :func:`expr` "
"é–¢æ•°ã¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ *source* ã‚’æ§‹æ–‡è§£æã—ã¾ã™ã€‚è§£æãŒæˆåŠŸã—ãŸå ´åˆã¯ã€ ST "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å†…éƒ¨è§£ææœ¨è¡¨ç¾ã‚’ä¿æŒã™ã‚‹ãŸã‚ã«ä½œæˆã•ã‚Œã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€é©åˆ‡ãªä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/parser.rst:124
msgid ""
"The :func:`suite` function parses the parameter *source* as if it were an "
"input to ``compile(source, 'file.py', 'exec')``.  If the parse succeeds, an "
"ST object is created to hold the internal parse tree representation, "
"otherwise an appropriate exception is raised."
msgstr ""
"ã¾ã‚‹ã§ ``compile(source, 'file.py', 'exec')`` ã¸ã®å…¥åŠ›ã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«ã€ :func:`suite` "
"é–¢æ•°ã¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ *source* ã‚’æ§‹æ–‡è§£æã—ã¾ã™ã€‚è§£æãŒæˆåŠŸã—ãŸå ´åˆã¯ã€ ST "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å†…éƒ¨è§£ææœ¨è¡¨ç¾ã‚’ä¿æŒã™ã‚‹ãŸã‚ã«ä½œæˆã•ã‚Œã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€é©åˆ‡ãªä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/parser.rst:132
msgid ""
"This function accepts a parse tree represented as a sequence and builds an "
"internal representation if possible.  If it can validate that the tree "
"conforms to the Python grammar and all nodes are valid node types in the "
"host version of Python, an ST object is created from the internal "
"representation and returned to the called.  If there is a problem creating "
"the internal representation, or if the tree cannot be validated, a "
":exc:`ParserError` exception is raised.  An ST object created this way "
"should not be assumed to compile correctly; normal exceptions raised by "
"compilation may still be initiated when the ST object is passed to "
":func:`compilest`.  This may indicate problems not related to syntax (such "
"as a :exc:`MemoryError` exception), but may also be due to constructs such "
"as the result of parsing ``del f(0)``, which escapes the Python parser but "
"is checked by the bytecode compiler."
msgstr ""
"ã“ã®é–¢æ•°ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦è¡¨ç¾ã•ã‚ŒãŸè§£ææœ¨ã‚’å—ã‘å–ã‚Šã€å¯èƒ½ãªã‚‰ã°å†…éƒ¨è¡¨ç¾ã‚’ä½œã‚Šã¾ã™ã€‚æœ¨ãŒ Python ã®æ–‡æ³•ã«åˆã£ã¦ã„ã‚‹ã“ã¨ã¨ã€ã™ã¹ã¦ã®ãƒãƒ¼ãƒ‰ãŒ "
"Python ã®ãƒ›ã‚¹ãƒˆãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§æœ‰åŠ¹ãªãƒãƒ¼ãƒ‰å‹ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ãŸå ´åˆã¯ã€ ST "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå†…éƒ¨è¡¨ç¾ã‹ã‚‰ä½œæˆã•ã‚Œã¦å‘¼ã³å‡ºã—å´ã¸è¿”ã•ã‚Œã¾ã™ã€‚å†…éƒ¨è¡¨ç¾ã®ä½œæˆã«å•é¡ŒãŒã‚ã‚‹ãªã‚‰ã°ã€ã‚ã‚‹ã„ã¯æœ¨ãŒæ­£ã—ã„ã¨ç¢ºèªã§ããªã„ãªã‚‰ã°ã€ "
":exc:`ParserError` ä¾‹å¤–ã‚’ç™ºç”Ÿã—ã¾ã™ã€‚ã“ã®æ–¹æ³•ã§ä½œã‚‰ã‚ŒãŸ ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ­£ã—ãã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã‚‹ã¨æ±ºã‚ã¤ã‘ãªã„æ–¹ãŒã‚ˆã„ã§ã—ã‚‡ã†ã€‚ "
"ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ :func:`compilest` "
"ã¸æ¸¡ã•ã‚ŒãŸã¨ãã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«ã‚ˆã£ã¦é€å‡ºã•ã‚ŒãŸé€šå¸¸ã®ä¾‹å¤–ãŒã¾ã ç™ºç”Ÿã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã¯(:exc:`MemoryError` "
"ä¾‹å¤–ã®ã‚ˆã†ãª)æ§‹æ–‡ã«é–¢ä¿‚ã—ã¦ã„ãªã„å•é¡Œã‚’ç¤ºã™ã®ã‹ã‚‚ã—ã‚Œãªã„ã—ã€ ``del f(0)`` "
"ã‚’è§£æã—ãŸçµæœã®ã‚ˆã†ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ãƒˆãŒåŸå› ã§ã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã®ã‚ˆã†ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ãƒˆã¯ Python "
"ã®ãƒ‘ãƒ¼ã‚µã‚’é€ƒã‚Œã¾ã™ãŒã€ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã«ã‚ˆã£ã¦ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚"

#: ../../library/parser.rst:145
msgid ""
"Sequences representing terminal tokens may be represented as either two-"
"element lists of the form ``(1, 'name')`` or as three-element lists of the "
"form ``(1, 'name', 56)``.  If the third element is present, it is assumed to"
" be a valid line number.  The line number may be specified for any subset of"
" the terminal symbols in the input tree."
msgstr ""
"çµ‚ç«¯ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¡¨ã™ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€``(1, 'name')`` å½¢å¼ã®äºŒã¤ã®è¦ç´ ã®ãƒªã‚¹ãƒˆã‹ã€ã¾ãŸã¯ ``(1, 'name', 56)`` "
"å½¢å¼ã®ä¸‰ã¤ã®è¦ç´ ã®ãƒªã‚¹ãƒˆã§ã™ã€‚ä¸‰ç•ªç›®ã®è¦ç´ ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ã€æœ‰åŠ¹ãªè¡Œç•ªå·ã ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚è¡Œç•ªå·ãŒæŒ‡å®šã•ã‚Œã‚‹ã®ã¯ã€å…¥åŠ›æœ¨ã®çµ‚ç«¯è¨˜å·ã®ä¸€éƒ¨ã«å¯¾ã—ã¦ã§ã™ã€‚"

#: ../../library/parser.rst:154
msgid ""
"This is the same function as :func:`sequence2st`.  This entry point is "
"maintained for backward compatibility."
msgstr "ã“ã‚Œã¯ :func:`sequence2st` ã¨åŒã˜é–¢æ•°ã§ã™ã€‚ã“ã®ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆã¯å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã«ç¶­æŒã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/parser.rst:161
msgid "Converting ST Objects"
msgstr "ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¤‰æ›ã™ã‚‹"

#: ../../library/parser.rst:163
msgid ""
"ST objects, regardless of the input used to create them, may be converted to"
" parse trees represented as list- or tuple- trees, or may be compiled into "
"executable code objects.  Parse trees may be extracted with or without line "
"numbering information."
msgstr ""
"ä½œæˆã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚ŒãŸå…¥åŠ›ã«é–¢ä¿‚ãªãã€ST "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒªã‚¹ãƒˆæœ¨ã¾ãŸã¯ã‚¿ãƒ—ãƒ«æœ¨ã¨ã—ã¦è¡¨ã•ã‚Œã‚‹è§£ææœ¨ã¸å¤‰æ›ã•ã‚Œã‚‹ã‹ã€ã¾ãŸã¯å®Ÿè¡Œå¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã™ã€‚è§£ææœ¨ã¯è¡Œç•ªå·æƒ…å ±ã‚’æŒã£ã¦ã€ã‚ã‚‹ã„ã¯æŒãŸãšã«æŠ½å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/parser.rst:171
msgid ""
"This function accepts an ST object from the caller in *st* and returns a "
"Python list representing the equivalent parse tree.  The resulting list "
"representation can be used for inspection or the creation of a new parse "
"tree in list form.  This function does not fail so long as memory is "
"available to build the list representation.  If the parse tree will only be "
"used for inspection, :func:`st2tuple` should be used instead to reduce "
"memory consumption and fragmentation.  When the list representation is "
"required, this function is significantly faster than retrieving a tuple "
"representation and converting that to nested lists."
msgstr ""
"ã“ã®é–¢æ•°ã¯å‘¼ã³å‡ºã—å´ã‹ã‚‰ *st* ã« ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚Šã€è§£ææœ¨ã¨ç­‰ä¾¡ãª Python "
"ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚çµæœã®ãƒªã‚¹ãƒˆè¡¨ç¾ã¯ã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚·ãƒ§ãƒ³ã‚ã‚‹ã„ã¯ãƒªã‚¹ãƒˆå½¢å¼ã®æ–°ã—ã„è§£ææœ¨ã®ä½œæˆã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒªã‚¹ãƒˆè¡¨ç¾ã‚’ä½œã‚‹ãŸã‚ã«ãƒ¡ãƒ¢ãƒªãŒåˆ©ç”¨ã§ãã‚‹é™ã‚Šã€ã“ã®é–¢æ•°ã¯å¤±æ•—ã—ã¾ã›ã‚“ã€‚è§£ææœ¨ãŒã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚·ãƒ§ãƒ³ã®ãŸã‚ã ã‘ã«ã¤ã‹ã‚ã‚Œã‚‹ãªã‚‰ã°ã€ãƒ¡ãƒ¢ãƒªã®æ¶ˆè²»é‡ã¨æ–­ç‰‡åŒ–ã‚’æ¸›ã‚‰ã™ãŸã‚ã«"
" :func:`st2tuple` "
"ã‚’ä»£ã‚ã‚Šã«ä½¿ã†ã¹ãã§ã™ã€‚ãƒªã‚¹ãƒˆè¡¨ç¾ãŒå¿…è¦ã¨ã•ã‚Œã‚‹ã¨ãã€ã“ã®é–¢æ•°ã¯ã‚¿ãƒ—ãƒ«è¡¨ç¾ã‚’å–ã‚Šå‡ºã—ã¦å…¥ã‚Œå­ã®ãƒªã‚¹ãƒˆã«å¤‰æ›ã™ã‚‹ã‚ˆã‚Šã‹ãªã‚Šé«˜é€Ÿã§ã™ã€‚"

#: ../../library/parser.rst:181
msgid ""
"If *line_info* is true, line number information will be included for all "
"terminal tokens as a third element of the list representing the token.  Note"
" that the line number provided specifies the line on which the token *ends*."
" This information is omitted if the flag is false or omitted."
msgstr ""
"*line_info* ãŒçœŸãªã‚‰ã°ã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¡¨ã™ãƒªã‚¹ãƒˆã®ä¸‰ç•ªç›®ã®è¦ç´ ã¨ã—ã¦è¡Œç•ªå·æƒ…å ±ãŒã™ã¹ã¦ã®çµ‚ç«¯ãƒˆãƒ¼ã‚¯ãƒ³ã«å«ã¾ã‚Œã¾ã™ã€‚ä¸ãˆã‚‰ã‚ŒãŸè¡Œç•ªå·ã¯ãƒˆãƒ¼ã‚¯ãƒ³ "
"*ãŒçµ‚ã‚ã‚‹* è¡Œã‚’æŒ‡å®šã—ã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãƒ•ãƒ©ã‚°ãŒå½ã¾ãŸã¯çœç•¥ã•ã‚ŒãŸå ´åˆã¯ã€ã“ã®æƒ…å ±ã¯çœã‹ã‚Œã¾ã™ã€‚"

#: ../../library/parser.rst:189
msgid ""
"This function accepts an ST object from the caller in *st* and returns a "
"Python tuple representing the equivalent parse tree.  Other than returning a"
" tuple instead of a list, this function is identical to :func:`st2list`."
msgstr ""
"ã“ã®é–¢æ•°ã¯å‘¼ã³å‡ºã—å´ã‹ã‚‰ *st* ã« ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚Šã€è§£ææœ¨ã¨ç­‰ä¾¡ãª Python "
"ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ãƒªã‚¹ãƒˆã®ä»£ã‚ã‚Šã«ã‚¿ãƒ—ãƒ«ã‚’è¿”ã™ä»¥å¤–ã¯ã€ã“ã®é–¢æ•°ã¯ :func:`st2list` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/parser.rst:193
msgid ""
"If *line_info* is true, line number information will be included for all "
"terminal tokens as a third element of the list representing the token.  This"
" information is omitted if the flag is false or omitted."
msgstr ""
"*line_info* "
"ãŒçœŸãªã‚‰ã°ã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¡¨ã™ãƒªã‚¹ãƒˆã®ä¸‰ç•ªç›®ã®è¦ç´ ã¨ã—ã¦è¡Œç•ªå·æƒ…å ±ãŒã™ã¹ã¦ã®çµ‚ç«¯ãƒˆãƒ¼ã‚¯ãƒ³ã«å«ã¾ã‚Œã¾ã™ã€‚ãƒ•ãƒ©ã‚°ãŒå½ã¾ãŸã¯çœç•¥ã•ã‚ŒãŸå ´åˆã¯ã€ã“ã®æƒ…å ±ã¯çœã‹ã‚Œã¾ã™ã€‚"

#: ../../library/parser.rst:204
msgid ""
"The Python byte compiler can be invoked on an ST object to produce code "
"objects which can be used as part of a call to the built-in :func:`exec` or "
":func:`eval` functions. This function provides the interface to the "
"compiler, passing the internal parse tree from *st* to the parser, using the"
" source file name specified by the *filename* parameter. The default value "
"supplied for *filename* indicates that the source was an ST object."
msgstr ""
"çµ„ã¿è¾¼ã¿ã® :func:`exec` ã‚„ :func:`eval` é–¢æ•°ã¸ã®å‘¼ã³å‡ºã—ã¨ã—ã¦ä½¿ãˆã‚‹ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ã€ Python "
"ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚’ ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¸ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’æä¾›ã—ã€ *filename* "
"ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§æŒ‡å®šã•ã‚Œã‚‹ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ä½¿ã£ã¦ã€ *st* ã‹ã‚‰ãƒ‘ãƒ¼ã‚µã¸å†…éƒ¨è§£ææœ¨ã‚’æ¸¡ã—ã¾ã™ã€‚ *filename* "
"ã«ä¸ãˆã‚‰ã‚Œã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ã€ã‚½ãƒ¼ã‚¹ãŒ ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã ã£ãŸã“ã¨ã‚’ç¤ºå”†ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/parser.rst:211
msgid ""
"Compiling an ST object may result in exceptions related to compilation; an "
"example would be a :exc:`SyntaxError` caused by the parse tree for ``del "
"f(0)``: this statement is considered legal within the formal grammar for "
"Python but is not a legal language construct.  The :exc:`SyntaxError` raised"
" for this condition is actually generated by the Python byte-compiler "
"normally, which is why it can be raised at this point by the :mod:`parser` "
"module.  Most causes of compilation failure can be diagnosed "
"programmatically by inspection of the parse tree."
msgstr ""
"ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã“ã¨ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«é–¢ã™ã‚‹ä¾‹å¤–ã‚’å¼•ãèµ·ã“ã™ã“ã¨ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ä¾‹ã¨ã—ã¦ã¯ã€ ``del f(0)`` "
"ã®è§£ææœ¨ã«ã‚ˆã£ã¦ç™ºç”Ÿã•ã›ã‚‰ã‚Œã‚‹ :exc:`SyntaxError` ãŒã‚ã‚Šã¾ã™: ã“ã®æ–‡ã¯ Python "
"ã®å½¢å¼æ–‡æ³•ã¨ã—ã¦ã¯æ­£ã—ã„ã¨è€ƒãˆã‚‰ã‚Œã¾ã™ãŒã€æ­£ã—ã„è¨€èªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®çŠ¶æ³ã«å¯¾ã—ã¦ç™ºç”Ÿã™ã‚‹ :exc:`SyntaxError` "
"ã¯ã€å®Ÿéš›ã«ã¯ Python ãƒã‚¤ãƒˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã£ã¦é€šå¸¸ä½œã‚Šå‡ºã•ã‚Œã¾ã™ã€‚ã“ã‚ŒãŒ :mod:`parser` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã“ã®æ™‚ç‚¹ã§ä¾‹å¤–ã‚’ç™ºç”Ÿã§ãã‚‹ç†ç”±ã§ã™ã€‚è§£ææœ¨ã®ã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡Œã†ã“ã¨ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒå¤±æ•—ã™ã‚‹ã»ã¨ã‚“ã©ã®åŸå› ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã‚ˆã£ã¦è¨ºæ–­ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/parser.rst:224
msgid "Queries on ST Objects"
msgstr "ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å•ã„åˆã‚ã›"

#: ../../library/parser.rst:226
msgid ""
"Two functions are provided which allow an application to determine if an ST "
"was created as an expression or a suite.  Neither of these functions can be "
"used to determine if an ST was created from source code via :func:`expr` or "
":func:`suite` or from a parse tree via :func:`sequence2st`."
msgstr ""
"ST ãŒå¼ã¾ãŸã¯ suite ã¨ã—ã¦ä½œæˆã•ã‚ŒãŸã‹ã©ã†ã‹ã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒæ±ºå®šã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹äºŒã¤ã®é–¢æ•°ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®é–¢æ•°ã®ã©ã¡ã‚‰ã‚‚ã€ "
"ST ãŒ :func:`expr` ã¾ãŸã¯ :func:`suite` ã‚’é€šã—ã¦ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ä½œã‚‰ã‚ŒãŸã‹ã©ã†ã‹ã€ã‚ã‚‹ã„ã¯ã€ "
":func:`sequence2st` ã‚’é€šã—ã¦è§£ææœ¨ã‹ã‚‰ä½œã‚‰ã‚ŒãŸã‹ã©ã†ã‹ã‚’æ±ºå®šã§ãã¾ã›ã‚“ã€‚"

#: ../../library/parser.rst:236
msgid ""
"When *st* represents an ``'eval'`` form, this function returns true, "
"otherwise it returns false.  This is useful, since code objects normally "
"cannot be queried for this information using existing built-in functions.  "
"Note that the code objects created by :func:`compilest` cannot be queried "
"like this either, and are identical to those created by the built-in "
":func:`compile` function."
msgstr ""
"*st* ãŒ ``'eval'`` "
"å½¢å¼ã‚’è¡¨ã—ã¦ã„ã‚‹å ´åˆã«ã€ã“ã®é–¢æ•°ã¯çœŸã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€å½ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯å½¹ã«ç«‹ã¡ã¾ã™ã€‚ãªãœãªã‚‰ã°ã€é€šå¸¸ã¯æ—¢å­˜ã®çµ„ã¿è¾¼ã¿é–¢æ•°ã‚’ä½¿ã£ã¦ã‚‚ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã“ã®æƒ…å ±ã‚’å•ã„åˆã‚ã›ã‚‹ã“ã¨ãŒã§ããªã„ã‹ã‚‰ã§ã™ã€‚ã“ã®ã©ã¡ã‚‰ã®ã‚ˆã†ã«ã‚‚"
" :func:`compilest` ã«ã‚ˆã£ã¦ä½œæˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å•ã„åˆã‚ã›ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã—ã€ãã®ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯çµ„ã¿è¾¼ã¿ "
":func:`compile` é–¢æ•°ã«ã‚ˆã£ã¦ä½œæˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒã˜ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/parser.rst:245
msgid ""
"This function mirrors :func:`isexpr` in that it reports whether an ST object"
" represents an ``'exec'`` form, commonly known as a \"suite.\"  It is not "
"safe to assume that this function is equivalent to ``not isexpr(st)``, as "
"additional syntactic fragments may be supported in the future."
msgstr ""
"ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ(é€šå¸¸ \"suite\" ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹) ``'exec'`` å½¢å¼ã‚’è¡¨ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’å ±å‘Šã™ã‚‹ã¨ã„ã†ç‚¹ã§ã€ã“ã®é–¢æ•°ã¯ "
":func:`isexpr` ã«é…·ä¼¼ã—ã¦ã„ã¾ã™ã€‚è¿½åŠ ã®æ§‹æ–‡ãŒå°†æ¥ã‚µãƒãƒ¼ãƒˆã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã€ã“ã®é–¢æ•°ãŒ ``not isexpr(st)`` "
"ã¨ç­‰ä¾¡ã§ã‚ã‚‹ã¨ã¿ãªã™ã®ã¯å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/parser.rst:254
msgid "Exceptions and Error Handling"
msgstr "ä¾‹å¤–ã¨ã‚¨ãƒ©ãƒ¼å‡¦ç†"

#: ../../library/parser.rst:256
msgid ""
"The parser module defines a single exception, but may also pass other built-"
"in exceptions from other portions of the Python runtime environment.  See "
"each function for information about the exceptions it can raise."
msgstr ""
"parser ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ä¾‹å¤–ã‚’ä¸€ã¤å®šç¾©ã—ã¦ã„ã¾ã™ãŒã€Python "
"ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ç’°å¢ƒã®ä»–ã®éƒ¨åˆ†ãŒæä¾›ã™ã‚‹åˆ¥ã®çµ„ã¿è¾¼ã¿ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚å„é–¢æ•°ãŒç™ºç”Ÿã•ã›ã‚‹ä¾‹å¤–ã®æƒ…å ±ã«ã¤ã„ã¦ã¯ã€ãã‚Œãã‚Œé–¢æ•°ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/parser.rst:263
msgid ""
"Exception raised when a failure occurs within the parser module.  This is "
"generally produced for validation failures rather than the built-in "
":exc:`SyntaxError` raised during normal parsing. The exception argument is "
"either a string describing the reason of the failure or a tuple containing a"
" sequence causing the failure from a parse tree passed to "
":func:`sequence2st` and an explanatory string.  Calls to :func:`sequence2st`"
" need to be able to handle either type of exception, while calls to other "
"functions in the module will only need to be aware of the simple string "
"values."
msgstr ""
"parser ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…éƒ¨ã§éšœå®³ãŒèµ·ããŸã¨ãã«ç™ºç”Ÿã™ã‚‹ä¾‹å¤–ã€‚æ™®é€šã®æ§‹æ–‡è§£æä¸­ã«ç™ºç”Ÿã™ã‚‹çµ„ã¿è¾¼ã¿ã® :exc:`SyntaxError` "
"ã§ã¯ãªãã€ä¸€èˆ¬çš„ã«å¦¥å½“æ€§ç¢ºèªãŒå¤±æ•—ã—ãŸå ´åˆã«å¼•ãèµ·ã“ã•ã‚Œã¾ã™ã€‚ä¾‹å¤–ã®å¼•æ•°ã¨ã—ã¦ã¯ã€éšœå®³ã®ç†ç”±ã‚’èª¬æ˜ã™ã‚‹æ–‡å­—åˆ—ã§ã‚ã‚‹å ´åˆã¨ã€ "
":func:`sequence2st` "
"ã¸æ¸¡ã•ã‚Œã‚‹è§£ææœ¨ã®ä¸­ã®éšœå®³ã‚’å¼•ãèµ·ã“ã™ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’å«ã‚€ã‚¿ãƒ—ãƒ«ã¨èª¬æ˜ç”¨ã®æ–‡å­—åˆ—ã§ã‚ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã®ä»–ã®é–¢æ•°ã®å‘¼ã³å‡ºã—ã¯å˜ç´”ãªæ–‡å­—åˆ—å€¤ã‚’æ¤œå‡ºã™ã‚Œã°ã‚ˆã„ã ã‘ã§ã™ãŒã€"
" :func:`sequence2st` ã®å‘¼ã³å‡ºã—ã¯ã©ã¡ã‚‰ã®ä¾‹å¤–ã®å‹ã‚‚å‡¦ç†ã§ãã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/parser.rst:272
msgid ""
"Note that the functions :func:`compilest`, :func:`expr`, and :func:`suite` "
"may raise exceptions which are normally raised by the parsing and "
"compilation process.  These include the built in exceptions "
":exc:`MemoryError`, :exc:`OverflowError`, :exc:`SyntaxError`, and "
":exc:`SystemError`.  In these cases, these exceptions carry all the meaning "
"normally associated with them. Refer to the descriptions of each function "
"for detailed information."
msgstr ""
"æ™®é€šã¯æ§‹æ–‡è§£æã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å‡¦ç†ã«ã‚ˆã£ã¦ç™ºç”Ÿã™ã‚‹ä¾‹å¤–ã‚’ã€é–¢æ•° :func:`compilest` ã€ :func:`expr` ãŠã‚ˆã³ "
":func:`suite` ãŒç™ºç”Ÿã•ã›ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã®ã‚ˆã†ãªä¾‹å¤–ã«ã¯çµ„ã¿è¾¼ã¿ä¾‹å¤– :exc:`MemoryError` ã€ "
":exc:`OverflowError` ã€ :exc:`SyntaxError` ãŠã‚ˆã³ :exc:`SystemError` "
"ãŒå«ã¾ã‚Œã¾ã™ã€‚ã“ã†ã—ãŸå ´åˆã«ã¯ã€ã“ã‚Œã‚‰ã®ä¾‹å¤–ãŒé€šå¸¸ãã®ä¾‹å¤–ã«é–¢ä¿‚ã™ã‚‹å…¨ã¦ã®æ„å‘³ã‚’ä¼ãˆã¾ã™ã€‚è©³ç´°ã«ã¤ã„ã¦ã¯ã€å„é–¢æ•°ã®èª¬æ˜ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/parser.rst:283
msgid "ST Objects"
msgstr "ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/parser.rst:285
msgid ""
"Ordered and equality comparisons are supported between ST objects. Pickling "
"of ST objects (using the :mod:`pickle` module) is also supported."
msgstr ""
"ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé–“ã®é †åºã¨ç­‰å€¤æ€§ã®æ¯”è¼ƒãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚ (:mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ãŸ) ST "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ”ã‚¯ãƒ«ã‚¹åŒ–ã‚‚ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/parser.rst:291
msgid ""
"The type of the objects returned by :func:`expr`, :func:`suite` and "
":func:`sequence2st`."
msgstr ":func:`expr` ã€ :func:`suite` ã¨ :func:`sequence2st` ãŒè¿”ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã€‚"

#: ../../library/parser.rst:294
msgid "ST objects have the following methods:"
msgstr "ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ¬¡ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã™:"

#: ../../library/parser.rst:299
msgid "Same as ``compilest(st, filename)``."
msgstr "``compilest(st, filename)`` ã¨åŒã˜ã€‚"

#: ../../library/parser.rst:304
msgid "Same as ``isexpr(st)``."
msgstr "``isexpr(st)`` ã¨åŒã˜ã€‚"

#: ../../library/parser.rst:309
msgid "Same as ``issuite(st)``."
msgstr "``issuite(st)`` ã¨åŒã˜ã€‚"

#: ../../library/parser.rst:314
msgid "Same as ``st2list(st, line_info, col_info)``."
msgstr "``st2list(st, line_info, col_info)`` ã¨åŒã˜ã€‚"

#: ../../library/parser.rst:319
msgid "Same as ``st2tuple(st, line_info, col_info)``."
msgstr "``st2tuple(st, line_info, col_info)`` ã¨åŒã˜ã€‚"

#: ../../library/parser.rst:323
msgid "Example: Emulation of :func:`compile`"
msgstr "ä¾‹: :func:`compile` ã®ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³"

#: ../../library/parser.rst:325
msgid ""
"While many useful operations may take place between parsing and bytecode "
"generation, the simplest operation is to do nothing.  For this purpose, "
"using the :mod:`parser` module to produce an intermediate data structure is "
"equivalent to the code ::"
msgstr ""
"ãŸãã•ã‚“ã®æœ‰ç”¨ãªæ¼”ç®—ã‚’æ§‹æ–‡è§£æã¨ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ç”Ÿæˆã®é–“ã«è¡Œã†ã“ã¨ãŒã§ãã¾ã™ãŒã€ã‚‚ã£ã¨ã‚‚å˜ç´”ãªæ¼”ç®—ã¯ä½•ã‚‚ã—ãªã„ã“ã¨ã§ã™ã€‚ã“ã®ãŸã‚ã€ "
":mod:`parser` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦ä¸­é–“ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½œã‚‹ã“ã¨ã¯æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¨ç­‰ä¾¡ã§ã™ ::"

#: ../../library/parser.rst:335
msgid ""
"The equivalent operation using the :mod:`parser` module is somewhat longer, "
"and allows the intermediate internal parse tree to be retained as an ST "
"object::"
msgstr ""
":mod:`parser` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ãŸç­‰ä¾¡ãªæ¼”ç®—ã¯ã‚„ã‚„é•·ããªã‚Šã¾ã™ãŒã€ ST ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ä¸­é–“å†…éƒ¨è§£ææœ¨ãŒç¶­æŒã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../library/parser.rst:345
msgid ""
"An application which needs both ST and code objects can package this code "
"into readily available functions::"
msgstr "ST ã¨ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸¡æ–¹ãŒå¿…è¦ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’ç°¡å˜ã«åˆ©ç”¨ã§ãã‚‹é–¢æ•°ã«ã¾ã¨ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™::"
