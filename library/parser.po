# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2020
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 16:06+0000\n"
"PO-Revision-Date: 2020-05-30 12:07+0000\n"
"Last-Translator: tomo, 2020\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/parser.rst:2
msgid ":mod:`parser` --- Access Python parse trees"
msgstr ":mod:`parser` --- Python 解析木にアクセスする"

#: ../../library/parser.rst:21
msgid ""
"The :mod:`parser` module provides an interface to Python's internal parser "
"and byte-code compiler.  The primary purpose for this interface is to allow "
"Python code to edit the parse tree of a Python expression and create "
"executable code from this.  This is better than trying to parse and modify "
"an arbitrary Python code fragment as a string because parsing is performed "
"in a manner identical to the code forming the application.  It is also "
"faster."
msgstr ""
":mod:`parser` モジュールは Python の内部パーサとバイトコード・コンパイラへの"
"インターフェイスを提供します。このインターフェイスの第一の目的は、 Python "
"コードから Python の式の解析木を編集したり、これから実行可能なコードを作成し"
"たりできるようにすることです。これは任意の Python コードの断片を文字列として"
"構文解析や変更を行うより良い方法です。なぜなら、構文解析がアプリケーションを"
"作成するコードと同じ方法で実行されるからです。その上、高速です。"

#: ../../library/parser.rst:30
msgid ""
"From Python 2.5 onward, it's much more convenient to cut in at the Abstract "
"Syntax Tree (AST) generation and compilation stage, using the :mod:`ast` "
"module."
msgstr ""
"Python 2.5 以降、抽象構文木 (AST) の生成・コンパイルの段階に割り込むには :"
"mod:`ast` モジュールを使うのがずっとお手軽です。"

#: ../../library/parser.rst:34
msgid ""
"There are a few things to note about this module which are important to "
"making use of the data structures created.  This is not a tutorial on "
"editing the parse trees for Python code, but some examples of using the :mod:"
"`parser` module are presented."
msgstr ""
"このモジュールについて注意すべきことが少しあります。それは作成したデータ構造"
"を利用するために重要なことです。この文書は Python コードの解析木を編集するた"
"めのチュートリアルではありませんが、 :mod:`parser` モジュールを使った例をいく"
"つか示しています。"

#: ../../library/parser.rst:39
msgid ""
"Most importantly, a good understanding of the Python grammar processed by "
"the internal parser is required.  For full information on the language "
"syntax, refer to :ref:`reference-index`.  The parser itself is created from "
"a grammar specification defined in the file :file:`Grammar/Grammar` in the "
"standard Python distribution.  The parse trees stored in the ST objects "
"created by this module are the actual output from the internal parser when "
"created by the :func:`expr` or :func:`suite` functions, described below.  "
"The ST objects created by :func:`sequence2st` faithfully simulate those "
"structures.  Be aware that the values of the sequences which are considered "
"\"correct\" will vary from one version of Python to another as the formal "
"grammar for the language is revised.  However, transporting code from one "
"Python version to another as source text will always allow correct parse "
"trees to be created in the target version, with the only restriction being "
"that migrating to an older version of the interpreter will not support more "
"recent language constructs.  The parse trees are not typically compatible "
"from one version to another, though source code has usually been forward-"
"compatible within a major release series."
msgstr ""
"もっとも重要なことは、内部パーサが処理する Python の文法についてよく理解して"
"おく必要があるということです。言語の文法に関する完全な情報については、 :ref:"
"`reference-index` を参照してください。標準の Python ディストリビューションに"
"含まれるファイル :file:`Grammar/Grammar` の中で定義されている文法仕様から、"
"パーサ自身は作成されています。このモジュールが作成する ST オブジェクトの中に"
"格納される解析木は、下で説明する :func:`expr` または :func:`suite` 関数によっ"
"て作られるときに内部パーサから実際に出力されるものです。 :func:`sequence2st` "
"が作る ST オブジェクトは忠実にこれらの構造をシミュレートしています。言語の形"
"式文法が改訂されるために、 \"正しい\" と考えられるシーケンスの値が Python の"
"あるバージョンから別のバージョンで変化することがあるということに注意してくだ"
"さい。しかし、 Python のあるバージョンから別のバージョンへテキストのソースの"
"ままコードを移せば、目的のバージョンで正しい解析木を常に作成できます。ただ"
"し、インタープリタの古いバージョンへ移行する際に、最近の言語コンストラクトを"
"サポートしていないことがあるという制限だけがあります。同一のメジャーバージョ"
"ンの範囲内では、通常はソースコードに前方互換性がありますが、一般的に解析木は"
"あるバージョンから別のバージョンへの互換性がありません。"

#: ../../library/parser.rst:57
msgid ""
"Each element of the sequences returned by :func:`st2list` or :func:"
"`st2tuple` has a simple form.  Sequences representing non-terminal elements "
"in the grammar always have a length greater than one.  The first element is "
"an integer which identifies a production in the grammar.  These integers are "
"given symbolic names in the C header file :file:`Include/graminit.h` and the "
"Python module :mod:`symbol`.  Each additional element of the sequence "
"represents a component of the production as recognized in the input string: "
"these are always sequences which have the same form as the parent.  An "
"important aspect of this structure which should be noted is that keywords "
"used to identify the parent node type, such as the keyword :keyword:`if` in "
"an :const:`if_stmt`, are included in the node tree without any special "
"treatment.  For example, the :keyword:`!if` keyword is represented by the "
"tuple ``(1, 'if')``, where ``1`` is the numeric value associated with all :"
"const:`NAME` tokens, including variable and function names defined by the "
"user.  In an alternate form returned when line number information is "
"requested, the same token might be represented as ``(1, 'if', 12)``, where "
"the ``12`` represents the line number at which the terminal symbol was found."
msgstr ""
":func:`st2list` または :func:`st2tuple` から返されるシーケンスのそれぞれの要"
"素は単純な形式です。文法の非終端要素を表すシーケンスは常に一より大きい長さを"
"持ちます。最初の要素は文法の生成規則を識別する整数です。これらの整数は C ヘッ"
"ダファイル :file:`Include/graminit.h` と Python モジュール :mod:`symbol` の中"
"の特定のシンボル名です。シーケンスに付け加えられている各要素は、入力文字列の"
"中で認識されたままの形で生成規則の構成要素を表しています: これらは常に親と同"
"じ形式を持つシーケンスです。この構造の注意すべき重要な側面は、 :const:"
"`if_stmt` の中のキーワード :keyword:`if` のような親ノードの型を識別するために"
"使われるキーワードがいかなる特別な扱いもなくノードツリーに含まれているという"
"ことです。例えば、 :keyword:`!if` キーワードはタプル ``(1, 'if')`` と表されま"
"す。ここで、 ``1`` は、ユーザが定義した変数名と関数名を含むすべての :const:"
"`NAME` トークンに対応する数値です。行番号情報が必要なときに返される別の形式で"
"は、同じトークンが ``(1, 'if', 12)`` のように表されます。ここでは、 ``12`` が"
"終端記号の見つかった行番号を表しています。"

#: ../../library/parser.rst:74
msgid ""
"Terminal elements are represented in much the same way, but without any "
"child elements and the addition of the source text which was identified.  "
"The example of the :keyword:`if` keyword above is representative.  The "
"various types of terminal symbols are defined in the C header file :file:"
"`Include/token.h` and the Python module :mod:`token`."
msgstr ""
"終端要素は同じ方法で表現されますが、子の要素や識別されたソーステキストの追加"
"は全くありません。上記の :keyword:`if` キーワードの例が代表的なものです。終端"
"記号のいろいろな型は、 C ヘッダファイル :file:`Include/token.h` と Python モ"
"ジュール :mod:`token` で定義されています。"

#: ../../library/parser.rst:80
msgid ""
"The ST objects are not required to support the functionality of this module, "
"but are provided for three purposes: to allow an application to amortize the "
"cost of processing complex parse trees, to provide a parse tree "
"representation which conserves memory space when compared to the Python list "
"or tuple representation, and to ease the creation of additional modules in C "
"which manipulate parse trees.  A simple \"wrapper\" class may be created in "
"Python to hide the use of ST objects."
msgstr ""
"ST オブジェクトはこのモジュールの機能をサポートするために必要ありませんが、三"
"つの目的から提供されています: アプリケーションが複雑な解析木を処理するコスト"
"を償却するため、Python のリストやタプル表現に比べてメモリ空間を保全する解析木"
"表現を提供するため、解析木を操作する追加モジュールを C で作ることを簡単にする"
"ため。ST オブジェクトを使っていることを隠すために、簡単な \"ラッパー\" クラス"
"を Python で作ることができます。"

#: ../../library/parser.rst:88
msgid ""
"The :mod:`parser` module defines functions for a few distinct purposes.  The "
"most important purposes are to create ST objects and to convert ST objects "
"to other representations such as parse trees and compiled code objects, but "
"there are also functions which serve to query the type of parse tree "
"represented by an ST object."
msgstr ""
":mod:`parser` モジュールは二、三の別々の目的のために関数を定義しています。"
"もっとも重要な目的は ST オブジェクトを作ることと、 ST オブジェクトを解析木と"
"コンパイルされたコードオブジェクトのような他の表現に変換することです。しか"
"し、 ST オブジェクトで表現された解析木の型を調べるために役に立つ関数もありま"
"す。"

#: ../../library/parser.rst:98
msgid "Module :mod:`symbol`"
msgstr ":mod:`symbol` モジュール"

#: ../../library/parser.rst:98
msgid "Useful constants representing internal nodes of the parse tree."
msgstr "解析木の内部ノードを表す便利な定数。"

#: ../../library/parser.rst:101
msgid "Module :mod:`token`"
msgstr ":mod:`token` モジュール"

#: ../../library/parser.rst:101
msgid ""
"Useful constants representing leaf nodes of the parse tree and functions for "
"testing node values."
msgstr "便利な解析木の葉のノードを表す定数とノード値をテストするための関数。"

#: ../../library/parser.rst:108
msgid "Creating ST Objects"
msgstr "ST オブジェクトを作成する"

#: ../../library/parser.rst:110
msgid ""
"ST objects may be created from source code or from a parse tree. When "
"creating an ST object from source, different functions are used to create "
"the ``'eval'`` and ``'exec'`` forms."
msgstr ""
"ST オブジェクトはソースコードあるいは解析木から作られます。ST オブジェクトを"
"ソースから作るときは、``'eval'`` と ``'exec'`` 形式を作成するために別々の関数"
"が使われます。"

#: ../../library/parser.rst:117
msgid ""
"The :func:`expr` function parses the parameter *source* as if it were an "
"input to ``compile(source, 'file.py', 'eval')``.  If the parse succeeds, an "
"ST object is created to hold the internal parse tree representation, "
"otherwise an appropriate exception is raised."
msgstr ""
"まるで ``compile(source, 'file.py', 'eval')`` への入力であるかのように、 :"
"func:`expr` 関数はパラメータ *source* を構文解析します。解析が成功した場合"
"は、 ST オブジェクトは内部解析木表現を保持するために作成されます。そうでなけ"
"れば、適切な例外を発生させます。"

#: ../../library/parser.rst:125
msgid ""
"The :func:`suite` function parses the parameter *source* as if it were an "
"input to ``compile(source, 'file.py', 'exec')``.  If the parse succeeds, an "
"ST object is created to hold the internal parse tree representation, "
"otherwise an appropriate exception is raised."
msgstr ""
"まるで ``compile(source, 'file.py', 'exec')`` への入力であるかのように、 :"
"func:`suite` 関数はパラメータ *source* を構文解析します。解析が成功した場合"
"は、 ST オブジェクトは内部解析木表現を保持するために作成されます。そうでなけ"
"れば、適切な例外を発生させます。"

#: ../../library/parser.rst:133
msgid ""
"This function accepts a parse tree represented as a sequence and builds an "
"internal representation if possible.  If it can validate that the tree "
"conforms to the Python grammar and all nodes are valid node types in the "
"host version of Python, an ST object is created from the internal "
"representation and returned to the called.  If there is a problem creating "
"the internal representation, or if the tree cannot be validated, a :exc:"
"`ParserError` exception is raised.  An ST object created this way should not "
"be assumed to compile correctly; normal exceptions raised by compilation may "
"still be initiated when the ST object is passed to :func:`compilest`.  This "
"may indicate problems not related to syntax (such as a :exc:`MemoryError` "
"exception), but may also be due to constructs such as the result of parsing "
"``del f(0)``, which escapes the Python parser but is checked by the bytecode "
"compiler."
msgstr ""
"この関数はシーケンスとして表現された解析木を受け取り、可能ならば内部表現を作"
"ります。木が Python の文法に合っていることと、すべてのノードが Python のホス"
"トバージョンで有効なノード型であることを確認した場合は、 ST オブジェクトが内"
"部表現から作成されて呼び出し側へ返されます。内部表現の作成に問題があるなら"
"ば、あるいは木が正しいと確認できないならば、 :exc:`ParserError` 例外を発生し"
"ます。この方法で作られた ST オブジェクトが正しくコンパイルできると決めつけな"
"い方がよいでしょう。 ST オブジェクトが :func:`compilest` へ渡されたとき、コン"
"パイルによって送出された通常の例外がまだ発生するかもしれません。これは(:exc:"
"`MemoryError` 例外のような)構文に関係していない問題を示すのかもしれないし、 "
"``del f(0)`` を解析した結果のようなコンストラクトが原因であるかもしれません。"
"このようなコンストラクトは Python のパーサを逃れますが、バイトコードインター"
"プリタによってチェックされます。"

#: ../../library/parser.rst:146
msgid ""
"Sequences representing terminal tokens may be represented as either two-"
"element lists of the form ``(1, 'name')`` or as three-element lists of the "
"form ``(1, 'name', 56)``.  If the third element is present, it is assumed to "
"be a valid line number.  The line number may be specified for any subset of "
"the terminal symbols in the input tree."
msgstr ""
"終端トークンを表すシーケンスは、``(1, 'name')`` 形式の二つの要素のリストか、"
"または ``(1, 'name', 56)`` 形式の三つの要素のリストです。三番目の要素が存在す"
"る場合は、有効な行番号だとみなされます。行番号が指定されるのは、入力木の終端"
"記号の一部に対してです。"

#: ../../library/parser.rst:155
msgid ""
"This is the same function as :func:`sequence2st`.  This entry point is "
"maintained for backward compatibility."
msgstr ""
"これは :func:`sequence2st` と同じ関数です。このエントリポイントは後方互換性の"
"ために維持されています。"

#: ../../library/parser.rst:162
msgid "Converting ST Objects"
msgstr "ST オブジェクトを変換する"

#: ../../library/parser.rst:164
msgid ""
"ST objects, regardless of the input used to create them, may be converted to "
"parse trees represented as list- or tuple- trees, or may be compiled into "
"executable code objects.  Parse trees may be extracted with or without line "
"numbering information."
msgstr ""
"作成するために使われた入力に関係なく、ST オブジェクトはリスト木またはタプル木"
"として表される解析木へ変換されるか、または実行可能なオブジェクトへコンパイル"
"されます。解析木は行番号情報を持って、あるいは持たずに抽出されます。"

#: ../../library/parser.rst:172
msgid ""
"This function accepts an ST object from the caller in *st* and returns a "
"Python list representing the equivalent parse tree.  The resulting list "
"representation can be used for inspection or the creation of a new parse "
"tree in list form.  This function does not fail so long as memory is "
"available to build the list representation.  If the parse tree will only be "
"used for inspection, :func:`st2tuple` should be used instead to reduce "
"memory consumption and fragmentation.  When the list representation is "
"required, this function is significantly faster than retrieving a tuple "
"representation and converting that to nested lists."
msgstr ""
"この関数は呼び出し側から *st* に ST オブジェクトを受け取り、解析木と等価な "
"Python のリストを返します。結果のリスト表現はインスペクションあるいはリスト形"
"式の新しい解析木の作成に使うことができます。リスト表現を作るためにメモリが利"
"用できる限り、この関数は失敗しません。解析木がインスペクションのためだけにつ"
"かわれるならば、メモリの消費量と断片化を減らすために :func:`st2tuple` を代わ"
"りに使うべきです。リスト表現が必要とされるとき、この関数はタプル表現を取り出"
"して入れ子のリストに変換するよりかなり高速です。"

#: ../../library/parser.rst:182
msgid ""
"If *line_info* is true, line number information will be included for all "
"terminal tokens as a third element of the list representing the token.  Note "
"that the line number provided specifies the line on which the token *ends*. "
"This information is omitted if the flag is false or omitted."
msgstr ""
"*line_info* が真ならば、トークンを表すリストの三番目の要素として行番号情報が"
"すべての終端トークンに含まれます。与えられた行番号はトークン *が終わる* 行を"
"指定していることに注意してください。フラグが偽または省略された場合は、この情"
"報は省かれます。"

#: ../../library/parser.rst:190
msgid ""
"This function accepts an ST object from the caller in *st* and returns a "
"Python tuple representing the equivalent parse tree.  Other than returning a "
"tuple instead of a list, this function is identical to :func:`st2list`."
msgstr ""
"この関数は呼び出し側から *st* に ST オブジェクトを受け取り、解析木と等価な "
"Python のタプルを返します。リストの代わりにタプルを返す以外は、この関数は :"
"func:`st2list` と同じです。"

#: ../../library/parser.rst:194
msgid ""
"If *line_info* is true, line number information will be included for all "
"terminal tokens as a third element of the list representing the token.  This "
"information is omitted if the flag is false or omitted."
msgstr ""
"*line_info* が真ならば、トークンを表すリストの三番目の要素として行番号情報が"
"すべての終端トークンに含まれます。フラグが偽または省略された場合は、この情報"
"は省かれます。"

#: ../../library/parser.rst:205
msgid ""
"The Python byte compiler can be invoked on an ST object to produce code "
"objects which can be used as part of a call to the built-in :func:`exec` or :"
"func:`eval` functions. This function provides the interface to the compiler, "
"passing the internal parse tree from *st* to the parser, using the source "
"file name specified by the *filename* parameter. The default value supplied "
"for *filename* indicates that the source was an ST object."
msgstr ""
"組み込みの :func:`exec` や :func:`eval` 関数への呼び出しとして使えるコードオ"
"ブジェクトを生成するために、 Python バイトコードコンパイラを ST オブジェクト"
"に対して呼び出すことができます。この関数はコンパイラへのインターフェイスを提"
"供し、 *filename* パラメータで指定されるソースファイル名を使って、 *st* から"
"パーサへ内部解析木を渡します。 *filename* に与えられるデフォルト値は、ソース"
"が ST オブジェクトだったことを示唆しています。"

#: ../../library/parser.rst:212
msgid ""
"Compiling an ST object may result in exceptions related to compilation; an "
"example would be a :exc:`SyntaxError` caused by the parse tree for ``del "
"f(0)``: this statement is considered legal within the formal grammar for "
"Python but is not a legal language construct.  The :exc:`SyntaxError` raised "
"for this condition is actually generated by the Python byte-compiler "
"normally, which is why it can be raised at this point by the :mod:`parser` "
"module.  Most causes of compilation failure can be diagnosed "
"programmatically by inspection of the parse tree."
msgstr ""
"ST オブジェクトをコンパイルすることは、コンパイルに関する例外を引き起こすこと"
"になるかもしれません。例としては、 ``del f(0)`` の解析木によって発生させられ"
"る :exc:`SyntaxError` があります: この文は Python の形式文法としては正しいと"
"考えられますが、正しい言語コンストラクトではありません。この状況に対して発生"
"する :exc:`SyntaxError` は、実際には Python バイトコンパイラによって通常作り"
"出されます。これが :mod:`parser` モジュールがこの時点で例外を発生できる理由で"
"す。解析木のインスペクションを行うことで、コンパイルが失敗するほとんどの原因"
"をプログラムによって診断することができます。"

#: ../../library/parser.rst:225
msgid "Queries on ST Objects"
msgstr "ST オブジェクトに対する問い合わせ"

#: ../../library/parser.rst:227
msgid ""
"Two functions are provided which allow an application to determine if an ST "
"was created as an expression or a suite.  Neither of these functions can be "
"used to determine if an ST was created from source code via :func:`expr` or :"
"func:`suite` or from a parse tree via :func:`sequence2st`."
msgstr ""
"ST が式または suite として作成されたかどうかをアプリケーションが決定できるよ"
"うにする二つの関数が提供されています。これらの関数のどちらも、 ST が :func:"
"`expr` または :func:`suite` を通してソースコードから作られたかどうか、あるい"
"は、 :func:`sequence2st` を通して解析木から作られたかどうかを決定できません。"

#: ../../library/parser.rst:237
msgid ""
"When *st* represents an ``'eval'`` form, this function returns ``True``, "
"otherwise it returns ``False``.  This is useful, since code objects normally "
"cannot be queried for this information using existing built-in functions.  "
"Note that the code objects created by :func:`compilest` cannot be queried "
"like this either, and are identical to those created by the built-in :func:"
"`compile` function."
msgstr ""
"*st* が ``'eval'`` 形式を表している場合に、この関数は ``True`` を返します。そ"
"うでなければ、 ``False`` を返します。これは役に立ちます。なぜならば、通常は既"
"存の組み込み関数を使ってもコードオブジェクトに対してこの情報を問い合わせるこ"
"とができないからです。このどちらのようにも :func:`compilest` によって作成され"
"たコードオブジェクトに問い合わせることはできませんし、そのコードオブジェクト"
"は組み込み :func:`compile` 関数によって作成されたコードオブジェクトと同じであ"
"ることに注意してください。"

#: ../../library/parser.rst:246
msgid ""
"This function mirrors :func:`isexpr` in that it reports whether an ST object "
"represents an ``'exec'`` form, commonly known as a \"suite.\"  It is not "
"safe to assume that this function is equivalent to ``not isexpr(st)``, as "
"additional syntactic fragments may be supported in the future."
msgstr ""
"ST オブジェクトが(通常 \"suite\" として知られる) ``'exec'`` 形式を表している"
"かどうかを報告するという点で、この関数は :func:`isexpr` に酷似しています。追"
"加の構文が将来サポートされるかもしれないので、この関数が ``not isexpr(st)`` "
"と等価であるとみなすのは安全ではありません。"

#: ../../library/parser.rst:255
msgid "Exceptions and Error Handling"
msgstr "例外とエラー処理"

#: ../../library/parser.rst:257
msgid ""
"The parser module defines a single exception, but may also pass other built-"
"in exceptions from other portions of the Python runtime environment.  See "
"each function for information about the exceptions it can raise."
msgstr ""
"parser モジュールは例外を一つ定義していますが、Python ランタイム環境の他の部"
"分が提供する別の組み込み例外を発生させることもあります。各関数が発生させる例"
"外の情報については、それぞれ関数を参照してください。"

#: ../../library/parser.rst:264
msgid ""
"Exception raised when a failure occurs within the parser module.  This is "
"generally produced for validation failures rather than the built-in :exc:"
"`SyntaxError` raised during normal parsing. The exception argument is either "
"a string describing the reason of the failure or a tuple containing a "
"sequence causing the failure from a parse tree passed to :func:`sequence2st` "
"and an explanatory string.  Calls to :func:`sequence2st` need to be able to "
"handle either type of exception, while calls to other functions in the "
"module will only need to be aware of the simple string values."
msgstr ""
"parser モジュール内部で障害が起きたときに発生する例外。普通の構文解析中に発生"
"する組み込みの :exc:`SyntaxError` ではなく、一般的に妥当性確認が失敗した場合"
"に引き起こされます。例外の引数としては、障害の理由を説明する文字列である場合"
"と、 :func:`sequence2st` へ渡される解析木の中の障害を引き起こすシーケンスを含"
"むタプルと説明用の文字列である場合があります。モジュール内の他の関数の呼び出"
"しは単純な文字列値を検出すればよいだけですが、 :func:`sequence2st` の呼び出し"
"はどちらの例外の型も処理できる必要があります。"

#: ../../library/parser.rst:273
msgid ""
"Note that the functions :func:`compilest`, :func:`expr`, and :func:`suite` "
"may raise exceptions which are normally raised by the parsing and "
"compilation process.  These include the built in exceptions :exc:"
"`MemoryError`, :exc:`OverflowError`, :exc:`SyntaxError`, and :exc:"
"`SystemError`.  In these cases, these exceptions carry all the meaning "
"normally associated with them. Refer to the descriptions of each function "
"for detailed information."
msgstr ""
"普通は構文解析とコンパイル処理によって発生する例外を、関数 :func:"
"`compilest` 、 :func:`expr` および :func:`suite` が発生させることに注意してく"
"ださい。このような例外には組み込み例外 :exc:`MemoryError` 、 :exc:"
"`OverflowError` 、 :exc:`SyntaxError` および :exc:`SystemError` が含まれま"
"す。こうした場合には、これらの例外が通常その例外に関係する全ての意味を伝えま"
"す。詳細については、各関数の説明を参照してください。"

#: ../../library/parser.rst:284
msgid "ST Objects"
msgstr "ST オブジェクト"

#: ../../library/parser.rst:286
msgid ""
"Ordered and equality comparisons are supported between ST objects. Pickling "
"of ST objects (using the :mod:`pickle` module) is also supported."
msgstr ""
"ST オブジェクト間の順序と等値性の比較がサポートされています。 (:mod:`pickle` "
"モジュールを使った) ST オブジェクトのピクルス化もサポートされています。"

#: ../../library/parser.rst:292
msgid ""
"The type of the objects returned by :func:`expr`, :func:`suite` and :func:"
"`sequence2st`."
msgstr ""
":func:`expr` 、 :func:`suite` と :func:`sequence2st` が返すオブジェクトの型。"

#: ../../library/parser.rst:295
msgid "ST objects have the following methods:"
msgstr "ST オブジェクトは次のメソッドを持っています:"

#: ../../library/parser.rst:300
msgid "Same as ``compilest(st, filename)``."
msgstr "``compilest(st, filename)`` と同じ。"

#: ../../library/parser.rst:305
msgid "Same as ``isexpr(st)``."
msgstr "``isexpr(st)`` と同じ。"

#: ../../library/parser.rst:310
msgid "Same as ``issuite(st)``."
msgstr "``issuite(st)`` と同じ。"

#: ../../library/parser.rst:315
msgid "Same as ``st2list(st, line_info, col_info)``."
msgstr "``st2list(st, line_info, col_info)`` と同じ。"

#: ../../library/parser.rst:320
msgid "Same as ``st2tuple(st, line_info, col_info)``."
msgstr "``st2tuple(st, line_info, col_info)`` と同じ。"

#: ../../library/parser.rst:324
msgid "Example: Emulation of :func:`compile`"
msgstr "例: :func:`compile` のエミュレーション"

#: ../../library/parser.rst:326
msgid ""
"While many useful operations may take place between parsing and bytecode "
"generation, the simplest operation is to do nothing.  For this purpose, "
"using the :mod:`parser` module to produce an intermediate data structure is "
"equivalent to the code ::"
msgstr ""
"たくさんの有用な演算を構文解析とバイトコード生成の間に行うことができますが、"
"もっとも単純な演算は何もしないことです。このため、 :mod:`parser` モジュールを"
"使って中間データ構造を作ることは次のコードと等価です ::"

#: ../../library/parser.rst:336
msgid ""
"The equivalent operation using the :mod:`parser` module is somewhat longer, "
"and allows the intermediate internal parse tree to be retained as an ST "
"object::"
msgstr ""
":mod:`parser` モジュールを使った等価な演算はやや長くなりますが、 ST オブジェ"
"クトとして中間内部解析木が維持されるようにします::"

#: ../../library/parser.rst:346
msgid ""
"An application which needs both ST and code objects can package this code "
"into readily available functions::"
msgstr ""
"ST とコードオブジェクトの両方が必要なアプリケーションでは、このコードを簡単に"
"利用できる関数にまとめることができます::"
