# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# cocoatomo, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-15 13:55+0900\n"
"PO-Revision-Date: 2018-05-20 05:59+0000\n"
"Last-Translator: cocoatomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/io.rst:2
msgid ":mod:`io` --- Core tools for working with streams"
msgstr ":mod:`io` --- ストリームを扱うコアツール"

#: ../../library/io.rst:16
msgid ""
"The :mod:`io` module provides the Python interfaces to stream handling. "
"Under Python 2.x, this is proposed as an alternative to the built-in "
":class:`file` object, but in Python 3.x it is the default interface to "
"access files and streams."
msgstr ":mod:`io` モジュールはストリーム処理を行う Python インタフェースを提供します。 Python 2.x では、これは組み込みの :class:`file` オブジェクトの代わりとして提案されていますが、Python 3.x では、これがファイルやストリームのデフォルトインタフェースです。"

#: ../../library/io.rst:23
msgid ""
"Since this module has been designed primarily for Python 3.x, you have to be"
" aware that all uses of \"bytes\" in this document refer to the :class:`str`"
" type (of which :class:`bytes` is an alias), and all uses of \"text\" refer "
"to the :class:`unicode` type.  Furthermore, those two types are not "
"interchangeable in the :mod:`io` APIs."
msgstr "このモジュールはもともと、Python 3.x のために設計されたものなので、このドキュメントの中で使われるすべての \"bytes\" は (:class:`bytes` がエイリアスとなる) :class:`str` 型のことで、すべての \"text\" は :class:`unicode` 型のことです。さらに、 :mod:`io` API では、この 2 つの型は入れ替えられません。"

#: ../../library/io.rst:29
msgid ""
"At the top of the I/O hierarchy is the abstract base class :class:`IOBase`."
"  It defines the basic interface to a stream.  Note, however, that there is "
"no separation between reading and writing to streams; implementations are "
"allowed to raise an :exc:`IOError` if they do not support a given operation."
msgstr "I/O 階層の最上位には抽象基底クラスの :class:`IOBase` があります。 :class:`IOBase` ではストリームに対して基本的なインタフェースを定義しています。しかしながら、ストリームに対する読み込みと書き込みが分離されていないことに注意してください。実装においては与えられた操作をサポートしない場合は :exc:`IOError` を送出することが許されています。"

#: ../../library/io.rst:34
msgid ""
"Extending :class:`IOBase` is :class:`RawIOBase` which deals simply with the "
"reading and writing of raw bytes to a stream.  :class:`FileIO` subclasses "
":class:`RawIOBase` to provide an interface to files in the machine's file "
"system."
msgstr ":class:`IOBase` の拡張は、単純なストリームに対する生のバイト列の読み書きを扱う :class:`RawIOBase` です。 :class:`FileIO` は、 :class:`RawIOBase` を継承してマシンのファイルシステム中のファイルへのインタフェースを提供します。"

#: ../../library/io.rst:39
msgid ""
":class:`BufferedIOBase` deals with buffering on a raw byte stream "
"(:class:`RawIOBase`).  Its subclasses, :class:`BufferedWriter`, "
":class:`BufferedReader`, and :class:`BufferedRWPair` buffer streams that are"
" readable, writable, and both readable and writable. :class:`BufferedRandom`"
" provides a buffered interface to random access streams.  :class:`BytesIO` "
"is a simple stream of in-memory bytes."
msgstr ":class:`BufferedIOBase` では生のバイトストリーム (:class:`RawIOBase`) 上にバッファ処理を追加します。そのサブクラスの :class:`BufferedWriter`, :class:`BufferedReader`, :class:`BufferedRWPair` では、それぞれ読み込み専用、書き込み専用、読み書き可能なストリームをバッファします。 :class:`BufferedRandom` ではランダムアクセスストリームに対してバッファされたインタフェースを提供します。 :class:`BytesIO` はインメモリバイトへのシンプルなストリームです。"

#: ../../library/io.rst:46
msgid ""
"Another :class:`IOBase` subclass, :class:`TextIOBase`, deals with streams "
"whose bytes represent text, and handles encoding and decoding from and to "
":class:`unicode` strings.  :class:`TextIOWrapper`, which extends it, is a "
"buffered text interface to a buffered raw stream (:class:`BufferedIOBase`). "
"Finally, :class:`~io.StringIO` is an in-memory stream for unicode text."
msgstr ":class:`IOBase` のもう一つのサブクラスである :class:`TextIOBase` は、テキストを表すバイトストリームを扱い、 :class:`unicode` エンコードやデコードといった処理を行います。 :class:`TextIOWrapper` はその拡張で、バッファ付き生ストリーム (:class:`BufferedIOBase`) へのバッファされたテキストインタフェースです。最後に :class:`~io.StringIO` は Unicode テキストに対するインメモリストリームです。"

#: ../../library/io.rst:53
msgid ""
"Argument names are not part of the specification, and only the arguments of "
":func:`.open` are intended to be used as keyword arguments."
msgstr "引数名は規約に含まれていません。そして :func:`.open` の引数だけがキーワード引数として用いられることが意図されています。"

#: ../../library/io.rst:58
msgid "Module Interface"
msgstr "モジュールインタフェース"

#: ../../library/io.rst:62
msgid ""
"An int containing the default buffer size used by the module's buffered I/O "
"classes.  :func:`.open` uses the file's blksize (as obtained by "
":func:`os.stat`) if possible."
msgstr "モジュールのバッファ I/O クラスで使用されるデフォルトのバッファサイズを指定する整数値です。 :func:`.open` は可能であればファイル全体のサイズ (:func:`os.stat` で取得されます) を使用します。"

#: ../../library/io.rst:68
msgid ""
"Open *file* and return a corresponding stream.  If the file cannot be "
"opened, an :exc:`IOError` is raised."
msgstr "*file* を開き、対応するストリームを返します。ファイルが開けなかった場合、 :exc:`IOError` が発生します。"

#: ../../library/io.rst:71
msgid ""
"*file* is either a string giving the pathname (absolute or relative to the "
"current working directory) of the file to be opened or an integer file "
"descriptor of the file to be wrapped.  (If a file descriptor is given, it is"
" closed when the returned I/O object is closed, unless *closefd* is set to "
"``False``.)"
msgstr "*file* は開きたいファイルの (絶対、またはカレントワーキングディレクトリに対する相対) パス名を示す文字列か、開きたいファイルがラップされているファイル記述子です。 (ファイル記述子が与えられた場合、 *closefd* が ``False`` に設定されていない限り、返された I/O オブジェクトが閉じられたときにそのファイル識別子も閉じられます)"

#: ../../library/io.rst:77
msgid ""
"*mode* is an optional string that specifies the mode in which the file is "
"opened.  It defaults to ``'r'`` which means open for reading in text mode. "
"Other common values are ``'w'`` for writing (truncating the file if it "
"already exists), and ``'a'`` for appending (which on *some* Unix systems, "
"means that *all* writes append to the end of the file regardless of the "
"current seek position).  In text mode, if *encoding* is not specified the "
"encoding used is platform dependent. (For reading and writing raw bytes use "
"binary mode and leave *encoding* unspecified.)  The available modes are:"
msgstr "*mode* はオプションの文字列です。これによってファイルをどのようなモードで開くか明示することができます。デフォルトは ``'r'`` でテキストモードで読み取り専用で開くことを指します。他にも ``'w'`` は書き込み専用 (もしファイルが存在していた場合は上書きになります) となり、 ``'a'`` では追記モードとなります。 (``'a'`` は *いくつかの* Unixシステムでは *すべての* 書き込みがシーク位置に関係なくファイルの末尾に追記されることを意味します) テキストモードでは、もし *encoding* が指定されていなかった場合、エンコーディングはプラットフォーム依存となります。 (生のバイトデータの読み込みと書き込みはバイナリモードを用いて、 *encoding* は未指定のままとします) 指定可能なモードは次の表の通りです。"

#: ../../library/io.rst:87
msgid "Character"
msgstr "文字"

#: ../../library/io.rst:87
msgid "Meaning"
msgstr "意味"

#: ../../library/io.rst:89
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/io.rst:89
msgid "open for reading (default)"
msgstr "読み込み用に開く (デフォルト)"

#: ../../library/io.rst:90
msgid "``'w'``"
msgstr "``'w'``"

#: ../../library/io.rst:90
msgid "open for writing, truncating the file first"
msgstr "書き込み用に開き、ファイルはまず切り詰められる"

#: ../../library/io.rst:91
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/io.rst:91
msgid "open for writing, appending to the end of the file if it exists"
msgstr "書き込み用に開き、ファイルが存在する場合は末尾に追記する"

#: ../../library/io.rst:92
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/io.rst:92
msgid "binary mode"
msgstr "バイナリモード"

#: ../../library/io.rst:93
msgid "``'t'``"
msgstr "``'t'``"

#: ../../library/io.rst:93
msgid "text mode (default)"
msgstr "テキストモード (デフォルト)"

#: ../../library/io.rst:94
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/io.rst:94
msgid "open a disk file for updating (reading and writing)"
msgstr "ディスクファイルを更新用に開く (読み込み／書き込み)"

#: ../../library/io.rst:95
msgid "``'U'``"
msgstr "``'U'``"

#: ../../library/io.rst:95
msgid ""
"universal newlines mode (for backwards compatibility; should not be used in "
"new code)"
msgstr "ユニバーサル改行モード (後方互換性のためのものです; 新しいコードでは使うべきでありません)"

#: ../../library/io.rst:99
msgid ""
"The default mode is ``'rt'`` (open for reading text).  For binary random "
"access, the mode ``'w+b'`` opens and truncates the file to 0 bytes, while "
"``'r+b'`` opens the file without truncation."
msgstr "デフォルトモードは ``'rt'`` です (テキストを読み込み専用で開きます)。バイナリのランダムアクセスでは ``'w+b'`` はファイルを開き、ファイルを 0 バイトに切り詰めます。一方で ``'r+b'`` でファイルを開くとサイズの切り詰めは行われません。"

#: ../../library/io.rst:103
msgid ""
"Python distinguishes between files opened in binary and text modes, even "
"when the underlying operating system doesn't.  Files opened in binary mode "
"(including ``'b'`` in the *mode* argument) return contents as :class:`bytes`"
" objects without any decoding.  In text mode (the default, or when ``'t'`` "
"is included in the *mode* argument), the contents of the file are returned "
"as :class:`unicode` strings, the bytes having been first decoded using a "
"platform-dependent encoding or using the specified *encoding* if given."
msgstr "Python ではバイナリモードで開かれたファイルとテキストモードで開かれたファイルは区別されます。オペレーティングシステムが区別しない場合でもこの区別は適用されます。バイナリモードで開かれたファイル (つまり *mode* 引数に ``'b'`` が含まれるとき) では、中身を :class:`bytes` オブジェクトとして返し、一切のデコードを行いません。テキストモード (デフォルトか *mode* 引数に ``'t'`` が含まれている場合) では、ファイルの内容は :class:`unicode` 文字列として返され、バイト列はプラットフォーム依存のエンコーディングか、 *encoding* が指定された場合は指定されたエンコーディングを使ってデコードされます。"

#: ../../library/io.rst:111
msgid ""
"*buffering* is an optional integer used to set the buffering policy. Pass 0 "
"to switch buffering off (only allowed in binary mode), 1 to select line "
"buffering (only usable in text mode), and an integer > 1 to indicate the "
"size of a fixed-size chunk buffer.  When no *buffering* argument is given, "
"the default buffering policy works as follows:"
msgstr "オプションの *buffering* はバッファ用の設定を行う整数値です。 0 を設定することでバッファがオフになります (バイナリモードでのみ有効です)。 1 の場合は 1 行ごとのバッファリングを行い (テキストモードでのみ利用可能です)、 1 より大きい場合は固定サイズチャンクバッファのサイズを表します。 *buffering* 引数が与えられなければ、デフォルトのバッファリングポリシーは以下のように働きます:"

#: ../../library/io.rst:117
msgid ""
"Binary files are buffered in fixed-size chunks; the size of the buffer is "
"chosen using a heuristic trying to determine the underlying device's \"block"
" size\" and falling back on :attr:`DEFAULT_BUFFER_SIZE`. On many systems, "
"the buffer will typically be 4096 or 8192 bytes long."
msgstr "バイナリファイルは固定サイズのチャンクでバッファリングされます。バッファサイズは、背後のデバイスの「ブロックサイズ」を決定するヒューリスティックを用いて選択され、それが不可能な場合は代わりに :attr:`DEFAULT_BUFFER_SIZE` が使われます。多くのシステムでは、典型的なバッファサイズは 4096 か 8192 バイト長になるでしょう。"

#: ../../library/io.rst:122
msgid ""
"\"Interactive\" text files (files for which :meth:`isatty` returns True) use"
" line buffering.  Other text files use the policy described above for binary"
" files."
msgstr "「対話的な」テキストファイル (:meth:`isatty` が True を返すファイル) は行バッファリングを使用します。その他のテキストファイルは、上で説明されたバイナリファイルのためのポリシーを使用します。"

#: ../../library/io.rst:126
msgid ""
"*encoding* is the name of the encoding used to decode or encode the file. "
"This should only be used in text mode.  The default encoding is platform "
"dependent (whatever :func:`locale.getpreferredencoding` returns), but any "
"encoding supported by Python can be used.  See the :mod:`codecs` module for "
"the list of supported encodings."
msgstr "*encoding* はファイルのエンコードやデコードに使われるエンコーディングの名前です。このオプションはテキストモードでのみ使用されるべきです。デフォルトエンコーディングはプラットフォーム依存 (:func:`locale.getpreferredencoding` が返すもの) ですが、Pythonでサポートされているエンコーディングはどれでも使えます。詳しくは :mod:`codecs` モジュール内のサポートしているエンコーディングのリストを参照してください。"

#: ../../library/io.rst:132
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled—this cannot be used in binary mode.  Pass "
"``'strict'`` to raise a :exc:`ValueError` exception if there is an encoding "
"error (the default of ``None`` has the same effect), or pass ``'ignore'`` to"
" ignore errors.  (Note that ignoring encoding errors can lead to data loss.)"
" ``'replace'`` causes a replacement marker (such as ``'?'``) to be inserted "
"where there is malformed data.  When writing, ``'xmlcharrefreplace'`` "
"(replace with the appropriate XML character reference) or "
"``'backslashreplace'`` (replace with backslashed escape sequences) can be "
"used.  Any other error handling name that has been registered with "
":func:`codecs.register_error` is also valid."
msgstr "*errors* はエンコードやデコードの際のエラーをどのように扱うかを指定する文字列で、バイナリモードでは使えません。 ``'strict'`` を指定すると、エンコードエラーがあった場合 :exc:`ValueError` 例外が発生します (デフォルトである ``None`` は同様の処理を行います)。 ``'ignore'`` を指定した場合はエラーを無視します。 ``'replace'`` を指定した場合は正常に変換されなかった文字の代わりにマーカ (例えば ``'?'`` のような文字) を挿入します。書き込みの際には ``'xmlcharrefreplace'`` (適切なXML文字参照に置き換える) か ``'backslashreplace'`` (バックスラッシュによるエスケープシーケンスに置き換える) のどちらかが使用できます。 :func:`codecs.register_error` に登録されている他のエラー処理名も指定できます。"

#: ../../library/io.rst:147
msgid ""
"*newline* controls how :term:`universal newlines` works (it only applies to "
"text mode).  It can be ``None``, ``''``, ``'\\n'``, ``'\\r'``, and "
"``'\\r\\n'``. It works as follows:"
msgstr "*newline* は :term:`universal newlines` モードがどのように働くかを制御します (テキストモードでのみはたらきます)。これは ``None``, ``''``, ``'\\n'``, ``'\\r'``, ``'\\r\\n'`` のいずれかです。これは以下のようにはたらきます:"

#: ../../library/io.rst:151
msgid ""
"On input, if *newline* is ``None``, universal newlines mode is enabled. "
"Lines in the input can end in ``'\\n'``, ``'\\r'``, or ``'\\r\\n'``, and "
"these are translated into ``'\\n'`` before being returned to the caller.  If"
" it is ``''``, universal newlines mode is enabled, but line endings are "
"returned to the caller untranslated.  If it has any of the other legal "
"values, input lines are only terminated by the given string, and the line "
"ending is returned to the caller untranslated."
msgstr "ストリームからの入力の読み込み時、*newline* が ``None`` であれば、ユニバーサル改行モードが有効になります。入力中の行は ``'\\n'``, ``'\\r'``, または ``'\\r\\n'`` で終端され、呼び出し元に返される前に ``'\\n'`` に切り詰められます。``''`` なら、ユニバーサル改行モードは有効になりますが、行末は翻訳されずに呼び出し元に返されます。その他の正当な値なら、入力行は与えられた文字列でのみ終端され、行末は翻訳されずに呼び出し元に返されます。"

#: ../../library/io.rst:159 ../../library/io.rst:805
msgid ""
"On output, if *newline* is ``None``, any ``'\\n'`` characters written are "
"translated to the system default line separator, :data:`os.linesep`.  If "
"*newline* is ``''``, no translation takes place.  If *newline* is any of the"
" other legal values, any ``'\\n'`` characters written are translated to the "
"given string."
msgstr "出力時、 *newline* が ``None`` の場合は、すべての ``'\\n'`` 文字はシステムのデフォルト行区切り文字 :data:`os.linesep` に変換されます。もし *newline* が ``''`` の場合、変換は起こりません。もし *newline* に他の適切な値が指定された場合は、 ``'\\n'`` 文字は与えられた文字に変換されます。"

#: ../../library/io.rst:165
msgid ""
"If *closefd* is ``False`` and a file descriptor rather than a filename was "
"given, the underlying file descriptor will be kept open when the file is "
"closed.  If a filename is given *closefd* has no effect and must be ``True``"
" (the default)."
msgstr "もし *closefd* が ``False`` で、ファイル名ではなくてファイル記述子が与えられていた場合、処理中のファイル記述子はファイルが閉じられた後も開いたままとなります。もしファイル名が与えられていた場合は、 *closefd* は関係ありません。しかし ``True`` でなければなりません (デフォルト値)。"

#: ../../library/io.rst:170
msgid ""
"The type of file object returned by the :func:`.open` function depends on "
"the mode.  When :func:`.open` is used to open a file in a text mode "
"(``'w'``, ``'r'``, ``'wt'``, ``'rt'``, etc.), it returns a subclass of "
":class:`TextIOBase` (specifically :class:`TextIOWrapper`).  When used to "
"open a file in a binary mode with buffering, the returned class is a "
"subclass of :class:`BufferedIOBase`.  The exact class varies: in read binary"
" mode, it returns a :class:`BufferedReader`; in write binary and append "
"binary modes, it returns a :class:`BufferedWriter`, and in read/write mode, "
"it returns a :class:`BufferedRandom`.  When buffering is disabled, the raw "
"stream, a subclass of :class:`RawIOBase`, :class:`FileIO`, is returned."
msgstr ":func:`.open` によって返されるファイルオブジェクトの型はモードに依存します。 :func:`.open` がテキストモードでファイルを開くために使われた場合 (``'w'``\\ 、 ``'r'``\\ 、 ``'wt'``\\ 、 ``'rt'`` など) :class:`TextIOBase` のサブクラス (具体的には :class:`TextIOWrapper`) が返されます。バッファリングをしてバイナリモードでファイルを開く場合、 :class:`BufferedIOBase` のサブクラスが返されます。具体的なクラスは多様です。もし読み取り専用のバイナリモードだった場合は :class:`BufferedReader` が返されます。書き込み専用のバイナリモードだった場合は :class:`BufferedWriter` が返されます。読み書き可能なバイナリモードの場合は :class:`BufferedRandom` が返されます。バッファリングが無効な場合、raw ストリーム、 :class:`RawIOBase` のサブクラス、 :class:`FileIO` が返されます。"

#: ../../library/io.rst:181
msgid ""
"It is also possible to use an :class:`unicode` or :class:`bytes` string as a"
" file for both reading and writing.  For :class:`unicode` strings "
":class:`~io.StringIO` can be used like a file opened in text mode, and for "
":class:`bytes` a :class:`BytesIO` can be used like a file opened in a binary"
" mode."
msgstr ":class:`unicode` 文字列や :class:`bytes` 文字列をファイルとして読み書きすることも可能です。 :class:`unicode` 文字列では :class:`~io.StringIO` を使えばテキストモードで開いたファイルのように扱えます。 :class:`bytes` では :class:`BytesIO` を使えばバイナリモードで開いたファイルのように扱えます。"

#: ../../library/io.rst:190
msgid ""
"Error raised when blocking would occur on a non-blocking stream.  It "
"inherits :exc:`IOError`."
msgstr "非ブロッキングストリームでブロック処理が起きた場合に発生するエラーです。 :exc:`IOError` を継承しています。"

#: ../../library/io.rst:193
msgid ""
"In addition to those of :exc:`IOError`, :exc:`BlockingIOError` has one "
"attribute:"
msgstr ":exc:`IOError` で持っている属性以外に :exc:`BlockingIOError` では次の属性を持っています。"

#: ../../library/io.rst:198
msgid ""
"An integer containing the number of characters written to the stream before "
"it blocked."
msgstr "ブロック前にストリームに書き込まれる文字数を保持する整数値です。"

#: ../../library/io.rst:204
msgid ""
"An exception inheriting :exc:`IOError` and :exc:`ValueError` that is raised "
"when an unsupported operation is called on a stream."
msgstr ":exc:`IOError` と :exc:`ValueError` を継承した例外で、ストリームに未サポートの操作が行われた場合に発生します。"

#: ../../library/io.rst:209
msgid "I/O Base Classes"
msgstr "I/O 基底クラス"

#: ../../library/io.rst:213
msgid ""
"The abstract base class for all I/O classes, acting on streams of bytes. "
"There is no public constructor."
msgstr "すべての I/O クラスの抽象基底クラスです。バイトストリームへの操作を行います。パブリックなコンストラクタはありません。"

#: ../../library/io.rst:216
msgid ""
"This class provides empty abstract implementations for many methods that "
"derived classes can override selectively; the default implementations "
"represent a file that cannot be read, written or seeked."
msgstr "継承先のクラスが選択的にオーバライドできるように、このクラスは多くのメソッドに空の抽象実装をしています。デフォルトの実装では、読み込み、書き込み、シークができないファイルを表現します。"

#: ../../library/io.rst:221
msgid ""
"Even though :class:`IOBase` does not declare :meth:`read`, :meth:`readinto`,"
" or :meth:`write` because their signatures will vary, implementations and "
"clients should consider those methods part of the interface.  Also, "
"implementations may raise an :exc:`IOError` when operations they do not "
"support are called."
msgstr ":class:`IOBase` では :meth:`read`, :meth:`readinto`, :meth:`write` が宣言されていませんが、これはシグナチャが変化するためで、実装やクライアントはこれらのメソッドをインタフェースの一部として考えるべきです。また、実装はサポートしていない操作を呼び出されたときは :exc:`IOError` を発生させるかもしれません。"

#: ../../library/io.rst:227
msgid ""
"The basic type used for binary data read from or written to a file is "
":class:`bytes` (also known as :class:`str`).  Method arguments may also be "
":class:`bytearray` or :class:`memoryview` of arrays of bytes. In some cases,"
" such as :meth:`~RawIOBase.readinto`, a writable object such as "
":class:`bytearray` is required. Text I/O classes work with :class:`unicode` "
"data."
msgstr "ファイルへのバイナリデータの読み書きに用いられる基本型は (:class:`str` としても知られる) :class:`bytes` です。\nメソッドの引数によっては :class:`bytearray` や bytes 配列の :class:`memoryview` のこともあります。\n:meth:`~RawIOBase.readinto` などのケースでは、 :class:`bytearray` のような書き込み可能オブジェクトが必要です。\nテキスト I/O クラスは :class:`unicode` データを扱います。"

#: ../../library/io.rst:234
msgid "Implementations should support :class:`memoryview` arguments."
msgstr "実装は :class:`memoryview` 引数をサポートする必要があります。"

#: ../../library/io.rst:237
msgid ""
"Note that calling any method (even inquiries) on a closed stream is "
"undefined.  Implementations may raise :exc:`IOError` in this case."
msgstr "閉じられたストリームに対するメソッド呼び出しは (問い合わせであっても) 未定義です。この場合、実装は :exc:`IOError` を発生させることがあります。"

#: ../../library/io.rst:240
msgid ""
"IOBase (and its subclasses) support the iterator protocol, meaning that an "
":class:`IOBase` object can be iterated over yielding the lines in a stream. "
"Lines are defined slightly differently depending on whether the stream is a "
"binary stream (yielding :class:`bytes`), or a text stream (yielding "
":class:`unicode` strings).  See :meth:`~IOBase.readline` below."
msgstr ":class:`IOBase` (とそのサブクラス) はイテレータプロトコルをサポートします。 :class:`IOBase` オブジェクトをイテレートすると、ストリーム内の行が yield されます。行は、ストリームが (:class:`bytes` を与える) バイナリストリームか (:class:`unicode` 文字列を与える) テキストストリームかによって、 少し違う定義がされています。下の :meth:`~IOBase.readline` を参照してください。"

#: ../../library/io.rst:246
msgid ""
"IOBase is also a context manager and therefore supports the :keyword:`with` "
"statement.  In this example, *file* is closed after the :keyword:`with` "
"statement's suite is finished---even if an exception occurs::"
msgstr "IOBase はコンテキストマネージャでもあります。そのため :keyword:`with` 構文をサポートします。次の例では、 :keyword:`with` 構文が終わった後で---たとえ例外が発生した場合でも、 *file* は閉じられます。"

#: ../../library/io.rst:253
msgid ":class:`IOBase` provides these data attributes and methods:"
msgstr ":class:`IOBase` は以下のデータ属性とメソッドを提供します:"

#: ../../library/io.rst:257
msgid ""
"Flush and close this stream. This method has no effect if the file is "
"already closed. Once the file is closed, any operation on the file (e.g. "
"reading or writing) will raise a :exc:`ValueError`."
msgstr "このストリームをフラッシュして閉じます。このメソッドはファイルが既に閉じられていた場合は特に何の効果もありません。いったんファイルが閉じられると、すべてのファイルに対する操作 (例えば読み込みや書き込み) で :exc:`ValueError` が発生します。"

#: ../../library/io.rst:261
msgid ""
"As a convenience, it is allowed to call this method more than once; only the"
" first call, however, will have an effect."
msgstr "利便性のためにこのメソッドを複数回呼ぶことは許されています。しかし、効果があるのは最初の1回だけです。"

#: ../../library/io.rst:266
msgid "True if the stream is closed."
msgstr "ストリームが閉じられていた場合 True になります。"

#: ../../library/io.rst:270
msgid ""
"Return the underlying file descriptor (an integer) of the stream if it "
"exists.  An :exc:`IOError` is raised if the IO object does not use a file "
"descriptor."
msgstr "ストリームが保持しているファイル記述子 (整数値) が存在する場合はそれを返します。もし IO オブジェクトがファイル記述子を使っていない場合は :exc:`IOError` が発生します。"

#: ../../library/io.rst:276
msgid ""
"Flush the write buffers of the stream if applicable.  This does nothing for "
"read-only and non-blocking streams."
msgstr "適用可能であればストリームの書き込みバッファをフラッシュします。読み込み専用や非ブロッキングストリームでは何もしません。"

#: ../../library/io.rst:281
msgid ""
"Return ``True`` if the stream is interactive (i.e., connected to a "
"terminal/tty device)."
msgstr "ストリームが対話的であれば (つまりターミナルや tty デバイスにつながっている場合) ``True`` を返します。"

#: ../../library/io.rst:286
msgid ""
"Return ``True`` if the stream can be read from.  If ``False``, :meth:`read` "
"will raise :exc:`IOError`."
msgstr "ストリームが読み込める場合 ``True`` を返します。 ``False`` の場合は :meth:`read` は :exc:`IOError` を発生させます。"

#: ../../library/io.rst:291
msgid ""
"Read and return one line from the stream.  If *limit* is specified, at most "
"*limit* bytes will be read."
msgstr "ストリームから 1 行読み込んで返します。もし *limit* が指定された場合、最大で *limit* バイトが読み込まれます。"

#: ../../library/io.rst:294
msgid ""
"The line terminator is always ``b'\\n'`` for binary files; for text files, "
"the *newline* argument to :func:`.open` can be used to select the line "
"terminator(s) recognized."
msgstr "バイナリファイルでは行末文字は常に ``b'\\n'`` となります。テキストファイルでは、認識される行末文字を選択するために :func:`.open` に対する *newline* 引数が使われます。"

#: ../../library/io.rst:300
msgid ""
"Read and return a list of lines from the stream.  *hint* can be specified to"
" control the number of lines read: no more lines will be read if the total "
"size (in bytes/characters) of all lines so far exceeds *hint*."
msgstr "ストリームから行のリストを読み込んで返します。 *hint* を指定することで、読み込む行数を制御できます。もし読み込んだすべての行のサイズ (バイト数、もしくは文字数) が *hint* の値を超えた場合、読み込みをそこで終了します。"

#: ../../library/io.rst:304
msgid ""
"Note that it's already possible to iterate on file objects using ``for line "
"in file: ...`` without calling ``file.readlines()``."
msgstr "``file.readlines()`` を呼びださなくても ``for line in file: ...`` のように、file オブジェクトを直接イテレートすることができることに注意してください。"

#: ../../library/io.rst:309
msgid ""
"Change the stream position to the given byte *offset*.  *offset* is "
"interpreted relative to the position indicated by *whence*.  The default "
"value for *whence* is :data:`SEEK_SET`.  Values for *whence* are:"
msgstr "ストリーム位置を指定された *offset* バイトに変更します。*offset* は *whence* で指定された位置からの相対位置として解釈されます。 *whence* のデフォルト値は :data:`SEEK_SET` です。 *whence* に指定できる値は:"

#: ../../library/io.rst:313
msgid ""
":data:`SEEK_SET` or ``0`` -- start of the stream (the default); *offset* "
"should be zero or positive"
msgstr ":data:`SEEK_SET` または ``0`` -- ストリームの先頭 (デフォルト)。 *offset* は 0 もしくは正の値でなければなりません。"

#: ../../library/io.rst:315
msgid ""
":data:`SEEK_CUR` or ``1`` -- current stream position; *offset* may be "
"negative"
msgstr ":data:`SEEK_CUR` または ``1`` -- 現在のストリーム位置。 *offset* は負の値も可能です。"

#: ../../library/io.rst:317
msgid ""
":data:`SEEK_END` or ``2`` -- end of the stream; *offset* is usually negative"
msgstr ":data:`SEEK_END` または ``2`` -- ストリームの末尾。 *offset* は通常負の値です。"

#: ../../library/io.rst:320
msgid "Return the new absolute position."
msgstr "新しい絶対位置を返します。"

#: ../../library/io.rst:322
msgid "The ``SEEK_*`` constants"
msgstr "``SEEK_*`` 定数"

#: ../../library/io.rst:327
msgid ""
"Return ``True`` if the stream supports random access.  If ``False``, "
":meth:`seek`, :meth:`tell` and :meth:`truncate` will raise :exc:`IOError`."
msgstr "もしストリームがランダムアクセスをサポートしていた場合 ``True`` を返します。 ``False`` の場合は :meth:`seek`\\ 、 :meth:`tell`\\ 、 :meth:`truncate` は :exc:`IOError` を発生させます。"

#: ../../library/io.rst:332
msgid "Return the current stream position."
msgstr "現在のストリーム位置を返します。"

#: ../../library/io.rst:336
msgid ""
"Resize the stream to the given *size* in bytes (or the current position if "
"*size* is not specified).  The current stream position isn't changed. This "
"resizing can extend or reduce the current file size.  In case of extension, "
"the contents of the new file area depend on the platform (on most systems, "
"additional bytes are zero-filled, on Windows they're undetermined).  The new"
" file size is returned."
msgstr "指定された *size* バイト (または *size* が指定されなければ現在の位置) にストリームをリサイズします。現在のストリーム位置は変更されません。このリサイズは、現在のファイルサイズを拡大または縮小させることができます。拡大の場合には、新しいファイル領域の内容はプラットホームに依存します (ほとんどのシステムでは、追加のバイトが 0 で埋められます。 Windowsでは不定です)。新しいファイルサイズが返されます。"

#: ../../library/io.rst:345
msgid ""
"Return ``True`` if the stream supports writing.  If ``False``, :meth:`write`"
" and :meth:`truncate` will raise :exc:`IOError`."
msgstr "ストリームが書き込みをサポートしている場合 ``True`` を返します。 ``False`` の場合は :meth:`write`\\ 、 :meth:`truncate` は :exc:`IOError` を返します。"

#: ../../library/io.rst:350
msgid ""
"Write a list of lines to the stream.  Line separators are not added, so it "
"is usual for each of the lines provided to have a line separator at the end."
msgstr "ストリームに複数行書き込みます。行区切り文字は付与されないので、通常書き込む各行の行末には行区切り文字があります。"

#: ../../library/io.rst:356
msgid ""
"Prepare for object destruction. :class:`IOBase` provides a default "
"implementation of this method that calls the instance's "
":meth:`~IOBase.close` method."
msgstr "オブジェクトの破壊の用意をします。このメソッドはインスタンスの :meth:`~IOBase.close` メソッドを呼びます。 :class:`IOBase` はこのメソッドのデフォルトの実装を提供します"

#: ../../library/io.rst:363
msgid ""
"Base class for raw binary I/O.  It inherits :class:`IOBase`.  There is no "
"public constructor."
msgstr "生のバイナリ I/O への基底クラスです。 :class:`IOBase` を継承しています。パブリックコンストラクタはありません。"

#: ../../library/io.rst:366
msgid ""
"Raw binary I/O typically provides low-level access to an underlying OS "
"device or API, and does not try to encapsulate it in high-level primitives "
"(this is left to Buffered I/O and Text I/O, described later in this page)."
msgstr "生のバイナリ I/O は典型的に、下にある OS デバイスや API への、低レベルなアクセスを提供し、高レベルな基本要素へとカプセル化しようとはしません (これはこのページで後述する Buffered I/O や Text I/O に任せます)。"

#: ../../library/io.rst:370
msgid ""
"In addition to the attributes and methods from :class:`IOBase`, RawIOBase "
"provides the following methods:"
msgstr ":class:`IOBase` の属性やメソッドに加えて、 RawIOBase は次のメソッドを提供します："

#: ../../library/io.rst:375
msgid ""
"Read up to *n* bytes from the object and return them.  As a convenience, if "
"*n* is unspecified or -1, :meth:`readall` is called.  Otherwise, only one "
"system call is ever made.  Fewer than *n* bytes may be returned if the "
"operating system call returns fewer than *n* bytes."
msgstr "オブジェクトを *n* バイトまで読み込み、それを返します。簡単のため、 *n* が指定されていないか -1 なら、 :meth:`readall` が呼び出されます。そうでなければ、システムコール呼び出しが一度だけ行われます。既に EOF に達していたら空のバイトオブジェクトが返されます。オペレーティングシステムコールが返したものがが *n* バイトより少なければ、 *n* バイトより少なく返されることがあります。"

#: ../../library/io.rst:380
msgid ""
"If 0 bytes are returned, and *n* was not 0, this indicates end of file. If "
"the object is in non-blocking mode and no bytes are available, ``None`` is "
"returned."
msgstr "0 バイトが返って、 *n* が 0 でなければ、それはファイルの終端を表します。オブジェクトがノンブロッキングモードで、 1 バイトも読み込めなければ、 ``None`` が返されます。"

#: ../../library/io.rst:386
msgid ""
"Read and return all the bytes from the stream until EOF, using multiple "
"calls to the stream if necessary."
msgstr "EOF までストリームからすべてのバイトを読み込みます。必要な場合はストリームに対して複数の呼び出しをします。"

#: ../../library/io.rst:391
msgid ""
"Read up to len(b) bytes into *b*, and return the number of bytes read.  The "
"object *b* should be a pre-allocated, writable array of bytes, either "
":class:`bytearray` or :class:`memoryview`. If the object is in non-blocking "
"mode and no bytes are available, ``None`` is returned."
msgstr "*b* に最大 len(b) バイト分読み込み、読み込んだバイト数を返します。\nオブジェクト *b* はメモリ確保済みの書き込み可能なバイト配列、 :class:`bytearray` もしくは :class:`memoryview` である必要があります。\nオブジェクトがノンブロッキングモードで、 1 バイトも読み込めなければ、 ``None`` が返されます。"

#: ../../library/io.rst:399
msgid ""
"Write *b* to the underlying raw stream, and return the number of bytes "
"written.  The object *b* should be an array of bytes, either :class:`bytes`,"
" :class:`bytearray`, or :class:`memoryview`.  The return value can be less "
"than ``len(b)``, depending on specifics of the underlying raw stream, and "
"especially if it is in non-blocking mode.  ``None`` is returned if the raw "
"stream is set not to block and no single byte could be readily written to "
"it.  The caller may release or mutate *b* after this method returns, so the "
"implementation should only access *b* during the method call."
msgstr "*b* を生ストリームに書き込み、書き込んだバイト数を返します。\nこのオブジェクト *b* はバイト配列、:class:`bytes` 、 :class:`bytearray` 、 :class:`memoryview` のいずれかである必要があります。\n返り値は、根底の生ストリームの性質によって、特にノンブロッキングモードである場合に、 ``len(b)`` より小さくなることがあります。\n生ストリームがブロックされないように設定されていて、かつ1バイトも即座に書き込むことができない場合は、 ``None`` が返されます。\nこのメソッドから返った後で呼び出し元は *b* を解放したり変更したりするかもしれないので、実装はメソッド呼び出しの間だけ *b* にアクセスすべきです。"

#: ../../library/io.rst:413
msgid ""
"Base class for binary streams that support some kind of buffering. It "
"inherits :class:`IOBase`. There is no public constructor."
msgstr "何らかのバッファリングをサポートするバイナリストリームの基底クラスです。 :class:`IOBase` を継承します。パブリックなコンストラクタはありません。"

#: ../../library/io.rst:416
msgid ""
"The main difference with :class:`RawIOBase` is that methods :meth:`read`, "
":meth:`readinto` and :meth:`write` will try (respectively) to read as much "
"input as requested or to consume all given output, at the expense of making "
"perhaps more than one system call."
msgstr ":class:`RawIOBase` との主な違いは、メソッド :meth:`read`、 :meth:`readinto` および :meth:`write` は 、ことによると複数回のシステムコールを行って、(それぞれ) 要求されただけの入力を読み込もうとしたり与えられた出力の全てを消費しようとしたりする点です。"

#: ../../library/io.rst:421
msgid ""
"In addition, those methods can raise :exc:`BlockingIOError` if the "
"underlying raw stream is in non-blocking mode and cannot take or give enough"
" data; unlike their :class:`RawIOBase` counterparts, they will never return "
"``None``."
msgstr "加えて、元になる生ストリームが非ブロッキングモードでかつ準備ができていない場合に、これらのメソッドは、 :exc:`BlockingIOError` を送出するかもしれません。対応する :class:`RawIOBase` バージョンと違って、 ``None`` を返すことはありません。"

#: ../../library/io.rst:426
msgid ""
"Besides, the :meth:`read` method does not have a default implementation that"
" defers to :meth:`readinto`."
msgstr "さらに、 :meth:`read` メソッドは、 :meth:`readinto` に従うデフォルト実装を持ちません。"

#: ../../library/io.rst:429
msgid ""
"A typical :class:`BufferedIOBase` implementation should not inherit from a "
":class:`RawIOBase` implementation, but wrap one, like "
":class:`BufferedWriter` and :class:`BufferedReader` do."
msgstr "通常の :class:`BufferedIOBase` 実装は :class:`RawIOBase` 実装を継承せずに、 :class:`BufferedWriter` と :class:`BufferedReader` がするようにこれをラップすべきです。"

#: ../../library/io.rst:433
msgid ""
":class:`BufferedIOBase` provides or overrides these methods and attribute in"
" addition to those from :class:`IOBase`:"
msgstr ":class:`BufferedIOBase` は :class:`IOBase` からのメソッドと属性に加えて、以下のメソッドを提供もしくはオーバーライドします:"

#: ../../library/io.rst:438
msgid ""
"The underlying raw stream (a :class:`RawIOBase` instance) that "
":class:`BufferedIOBase` deals with.  This is not part of the "
":class:`BufferedIOBase` API and may not exist on some implementations."
msgstr ":class:`BufferedIOBase` が扱う根底の生ストリーム (:class:`RawIOBase` インスタンス) を返します。これは :class:`BufferedIOBase` API には含まれず、よって実装に含まれないことがあります。"

#: ../../library/io.rst:444
msgid "Separate the underlying raw stream from the buffer and return it."
msgstr "根底の生ストリームをバッファから分離して返します。"

#: ../../library/io.rst:446
msgid ""
"After the raw stream has been detached, the buffer is in an unusable state."
msgstr "生ストリームが取り外された後、バッファは使用不能状態になります。"

#: ../../library/io.rst:449
msgid ""
"Some buffers, like :class:`BytesIO`, do not have the concept of a single raw"
" stream to return from this method.  They raise :exc:`UnsupportedOperation`."
msgstr "バッファには、 :class:`BytesIO` など、このメソッドで返される単体のストリームという概念を持たないものがあります。これらは :exc:`UnsupportedOperation` を送出します。"

#: ../../library/io.rst:457
msgid ""
"Read and return up to *n* bytes.  If the argument is omitted, ``None``, or "
"negative, data is read and returned until EOF is reached.  An empty bytes "
"object is returned if the stream is already at EOF."
msgstr "最大で *n* バイト読み込み、返します。引数が省略されるか、 ``None`` か、または負の値であった場合、データは EOF に到達するまで読み込まれます。ストリームが既に EOF に到達していた場合は空の bytes オブジェクトが返されます。"

#: ../../library/io.rst:461
msgid ""
"If the argument is positive, and the underlying raw stream is not "
"interactive, multiple raw reads may be issued to satisfy the byte count "
"(unless EOF is reached first).  But for interactive raw streams, at most one"
" raw read will be issued, and a short result does not imply that EOF is "
"imminent."
msgstr "引数が正で、元になる生ストリームが対話的でなければ、必要なバイト数を満たすように複数回の生 read が発行されるかもしれません (先に EOF に到達しない限りは)。対話的な場合は、最大で一回の raw read しか発行されず、短い結果でも EOF に達したことを意味しません。"

#: ../../library/io.rst:467 ../../library/io.rst:486
msgid ""
"A :exc:`BlockingIOError` is raised if the underlying raw stream is in non "
"blocking-mode, and has no data available at the moment."
msgstr "元になる生ストリームがノンブロッキングモードで、呼び出された時点でデータを持っていなければ、 :exc:`BlockingIOError` が送出されます。"

#: ../../library/io.rst:472
msgid ""
"Read and return up to *n* bytes, with at most one call to the underlying raw"
" stream's :meth:`~RawIOBase.read` method.  This can be useful if you are "
"implementing your own buffering on top of a :class:`BufferedIOBase` object."
msgstr "根底の生ストリームの :meth:`~RawIOBase.read` メソッドを高々 1 回呼び出し、最大で *n* バイト読み込み、返します。これは、 :class:`BufferedIOBase` オブジェクトの上に独自のバッファリングを実装するときに便利です。"

#: ../../library/io.rst:479
msgid ""
"Read up to len(b) bytes into *b*, and return the number of bytes read. The "
"object *b* should be a pre-allocated, writable array of bytes, either "
":class:`bytearray` or :class:`memoryview`."
msgstr "*b* に最大 len(b) バイト分読み込み、読み込んだバイト数を返します。\nオブジェクト *b* はメモリ確保済みの書き込み可能なバイト配列、 :class:`bytearray` もしくは :class:`memoryview` である必要があります。"

#: ../../library/io.rst:483
msgid ""
"Like :meth:`read`, multiple reads may be issued to the underlying raw "
"stream, unless the latter is 'interactive'."
msgstr ":meth:`read` と同様、元になる生ストリームが '対話的' でない限り、複数回の read が発行されるかもしれません。"

#: ../../library/io.rst:491
msgid ""
"Write *b*, and return the number of bytes written (always equal to "
"``len(b)``, since if the write fails an :exc:`IOError` will be raised).  The"
" object *b* should be an array of bytes, either :class:`bytes`, "
":class:`bytearray`, or :class:`memoryview`.  Depending on the actual "
"implementation, these bytes may be readily written to the underlying stream,"
" or held in a buffer for performance and latency reasons."
msgstr "*b* を書き込み、書き込んだバイト数を返します (これは常に ``len(b)`` と等しいです。なぜなら、もし書き込みに失敗した場合は :exc:`IOError` が発生するからです)。\nこのオブジェクト *b* はバイト配列、:class:`bytes` 、 :class:`bytearray` 、 :class:`memoryview` のいずれかである必要があります。\n実際の実装に依って、これらのバイトは根底のストリームに読めるように書きこまれたり、パフォーマンスとレイテンシの理由でバッファに保持されたりします。"

#: ../../library/io.rst:499
msgid ""
"When in non-blocking mode, a :exc:`BlockingIOError` is raised if the data "
"needed to be written to the raw stream but it couldn't accept all the data "
"without blocking."
msgstr "ノンブロッキングモードであるとき、バッファが満杯で根底の生ストリームが書き込み時点でさらなるデータを受け付けられない場合 :exc:`BlockingIOError` が送出されます。"

#: ../../library/io.rst:503
msgid ""
"The caller may release or mutate *b* after this method returns, so the "
"implementation should only access *b* during the method call."
msgstr "このメソッドが戻った後で、呼び出し元は *b* を解放、または変更するかもしれないので、実装はメソッド呼び出しの間だけ *b* にアクセスすべきです。"

#: ../../library/io.rst:508
msgid "Raw File I/O"
msgstr "生ファイルI/O"

#: ../../library/io.rst:512
msgid ""
":class:`FileIO` represents an OS-level file containing bytes data. It "
"implements the :class:`RawIOBase` interface (and therefore the "
":class:`IOBase` interface, too)."
msgstr ":class:`FileIO` はバイトデータを含む OS レベルのファイルを表します。 :class:`RawIOBase` インタフェースを (したがって :class:`IOBase` インタフェースも) 実装しています。"

#: ../../library/io.rst:516
msgid "The *name* can be one of two things:"
msgstr "*name* はこの 2 つのいずれかに出来ます:"

#: ../../library/io.rst:518
msgid "a string representing the path to the file which will be opened;"
msgstr "開くファイルのパスを表す文字列"

#: ../../library/io.rst:519
msgid ""
"an integer representing the number of an existing OS-level file descriptor "
"to which the resulting :class:`FileIO` object will give access."
msgstr "結果の :class:`FileIO` オブジェクトがアクセスを与える、既存の OS レベルファイルディスクリプタの数を表す整数"

#: ../../library/io.rst:522
msgid ""
"The *mode* can be ``'r'``, ``'w'`` or ``'a'`` for reading (default), "
"writing, or appending.  The file will be created if it doesn't exist when "
"opened for writing or appending; it will be truncated when opened for "
"writing.  Add a ``'+'`` to the mode to allow simultaneous reading and "
"writing."
msgstr "*mode* はそれぞれ読み込み (デフォルト)、書き込み、追記を表す ``'r'``\\ 、 ``'w'``\\ 、 ``'a'`` にすることができます。ファイルは書き込みまたは追記モードで開かれたときに存在しなければ作成されます。書き込みモードでは存在したファイル内容は消されます。読み込みと書き込みを同時に行いたければ ``'+'`` をモードに加えて下さい。"

#: ../../library/io.rst:527
msgid ""
"The :meth:`read` (when called with a positive argument), :meth:`readinto` "
"and :meth:`write` methods on this class will only make one system call."
msgstr "このクラスの :meth:`read` (正の引数で呼び出されたとき), :meth:`readinto` および :meth:`write` メソッドは、単にシステムコールを一度呼び出します。"

#: ../../library/io.rst:530
msgid ""
"In addition to the attributes and methods from :class:`IOBase` and "
":class:`RawIOBase`, :class:`FileIO` provides the following data attributes "
"and methods:"
msgstr ":class:`IOBase` および :class:`RawIOBase` から継承した属性とメソッドに加えて、 :class:`FileIO` は以下のデータ属性とメソッドを提供しています:"

#: ../../library/io.rst:536
msgid "The mode as given in the constructor."
msgstr "コンストラクタに渡されたモードです。"

#: ../../library/io.rst:540
msgid ""
"The file name.  This is the file descriptor of the file when no name is "
"given in the constructor."
msgstr "ファイル名。コンストラクタに名前が渡されなかったときはファイル記述子になります。"

#: ../../library/io.rst:545
msgid "Buffered Streams"
msgstr "バッファ付きストリーム"

#: ../../library/io.rst:547
msgid ""
"Buffered I/O streams provide a higher-level interface to an I/O device than "
"raw I/O does."
msgstr "バッファ付き I/O ストリームは、I/O デバイスに生 I/O より高レベルなインタフェースを提供します。"

#: ../../library/io.rst:552
msgid ""
"A stream implementation using an in-memory bytes buffer.  It inherits "
":class:`BufferedIOBase`."
msgstr "インメモリの bytes バッファを利用したストリームの実装。 :class:`BufferedIOBase` を継承します。"

#: ../../library/io.rst:555
msgid ""
"The optional argument *initial_bytes* is a :class:`bytes` object that "
"contains initial data."
msgstr "省略可能な引数 *initial_bytes* は、初期データを含んだ :class:`bytes` オブジェクトです。"

#: ../../library/io.rst:558
msgid ""
":class:`BytesIO` provides or overrides these methods in addition to those "
"from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ":class:`BytesIO` は :class:`BufferedIOBase` または :class:`IOBase` からのメソッドに加えて、以下のメソッドを提供もしくはオーバーライドします:"

#: ../../library/io.rst:563
msgid "Return ``bytes`` containing the entire contents of the buffer."
msgstr "バッファの全内容を保持した ``bytes`` を返します。"

#: ../../library/io.rst:567
msgid "In :class:`BytesIO`, this is the same as :meth:`read`."
msgstr ":class:`BytesIO` においては、このメソッドは :meth:`read` と同じです。"

#: ../../library/io.rst:572
msgid ""
"A buffer providing higher-level access to a readable, sequential "
":class:`RawIOBase` object.  It inherits :class:`BufferedIOBase`. When "
"reading data from this object, a larger amount of data may be requested from"
" the underlying raw stream, and kept in an internal buffer. The buffered "
"data can then be returned directly on subsequent reads."
msgstr "読み込み可能でシーケンシャルな :class:`RawIOBase` オブジェクトへの、高レベルなアクセスを提供するバッファです。 :class:`BufferedIOBase` を継承します。このオブジェクトからデータを読み込むとき、根底の生ストリームからより大きい量のデータが要求されることがあり、内部バッファに保存されます。バッファされたデータは、続く読み込み時に直接返されます。"

#: ../../library/io.rst:578
msgid ""
"The constructor creates a :class:`BufferedReader` for the given readable "
"*raw* stream and *buffer_size*.  If *buffer_size* is omitted, "
":data:`DEFAULT_BUFFER_SIZE` is used."
msgstr "このコンストラクタは与えられた *raw* ストリームと *buffer_size* に対し :class:`BufferedReader` を生成します。 *buffer_size* が省略された場合、代わりに :data:`DEFAULT_BUFFER_SIZE` が使われます。"

#: ../../library/io.rst:582
msgid ""
":class:`BufferedReader` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ":class:`BufferedReader` は :class:`BufferedIOBase` または :class:`IOBase` からのメソッドに加えて、以下のメソッドを提供もしくはオーバーライドします:"

#: ../../library/io.rst:587
msgid ""
"Return bytes from the stream without advancing the position.  At most one "
"single read on the raw stream is done to satisfy the call. The number of "
"bytes returned may be less or more than requested."
msgstr "位置を進めずにストリームからバイト列を返します。これを果たすために生ストリームに対して行われる read は高々一度だけです。返されるバイト数は、要求より少ないかもしれませんし、多いかもしれません。"

#: ../../library/io.rst:593
msgid ""
"Read and return *n* bytes, or if *n* is not given or negative, until EOF or "
"if the read call would block in non-blocking mode."
msgstr "*n* バイトを読み込んで返します。 *n* が与えられないかまたは負の値ならば、EOF まで、または非ブロッキングモード中で read 呼び出しがブロックされるまでを返します。"

#: ../../library/io.rst:598
msgid ""
"Read and return up to *n* bytes with only one call on the raw stream.  If at"
" least one byte is buffered, only buffered bytes are returned. Otherwise, "
"one raw stream read call is made."
msgstr "生ストリームに対しただ一度の呼び出しで最大 *n* バイトを読み込んで返します。少なくとも 1 バイトがバッファされていれば、バッファされているバイト列だけが返されます。それ以外の場合にはちょうど一回生ストリームに read 呼び出しが行われます。"

#: ../../library/io.rst:605
msgid ""
"A buffer providing higher-level access to a writeable, sequential "
":class:`RawIOBase` object.  It inherits :class:`BufferedIOBase`. When "
"writing to this object, data is normally held into an internal buffer.  The "
"buffer will be written out to the underlying :class:`RawIOBase` object under"
" various conditions, including:"
msgstr "書き込み可能でシーケンシャルな :class:`RawIOBase` オブジェクトへの、高レベルなアクセスを提供するバッファです。 :class:`BufferedIOBase` を継承します。このオブジェクトに書き込むとき、データは通常内部バッファに保持されます。このバッファは、以下のような種々の状況で根底の :class:`RawIOBase` オブジェクトに書きこまれます:"

#: ../../library/io.rst:611
msgid "when the buffer gets too small for all pending data;"
msgstr "保留中の全データに対してバッファが足りなくなったとき;"

#: ../../library/io.rst:612
msgid "when :meth:`flush()` is called;"
msgstr ":meth:`flush()` が呼び出されたとき;"

#: ../../library/io.rst:613
msgid ""
"when a :meth:`seek()` is requested (for :class:`BufferedRandom` objects);"
msgstr ":meth:`seek()` が (:class:`BufferedRandom` オブジェクトに対して) 呼び出されたとき;"

#: ../../library/io.rst:614
msgid "when the :class:`BufferedWriter` object is closed or destroyed."
msgstr ":class:`BufferedWriter` オブジェクトが閉じられたり破棄されたりしたとき。"

#: ../../library/io.rst:616
msgid ""
"The constructor creates a :class:`BufferedWriter` for the given writeable "
"*raw* stream.  If the *buffer_size* is not given, it defaults to "
":data:`DEFAULT_BUFFER_SIZE`."
msgstr "このコンストラクタは与えられた書き込み可能な *raw* ストリームに対し :class:`BufferedWriter` を生成します。 *buffer_size* が省略された場合、 :data:`DEFAULT_BUFFER_SIZE` がデフォルトになります。"

#: ../../library/io.rst:620 ../../library/io.rst:649
msgid ""
"A third argument, *max_buffer_size*, is supported, but unused and "
"deprecated."
msgstr "第三引数 *max_buffer_size* が提供されていますが、使われず、非推奨です。"

#: ../../library/io.rst:622
msgid ""
":class:`BufferedWriter` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ":class:`BufferedWriter` は :class:`BufferedIOBase` または :class:`IOBase` からのメソッドに加えて、以下のメソッドを提供もしくはオーバーライドします:"

#: ../../library/io.rst:627
msgid ""
"Force bytes held in the buffer into the raw stream.  A "
":exc:`BlockingIOError` should be raised if the raw stream blocks."
msgstr "バッファに保持されたバイト列を生ストリームに強制的に流し込みます。生ストリームがブロックした場合 :exc:`BlockingIOError` が送出されます。"

#: ../../library/io.rst:632
msgid ""
"Write *b*, and return the number of bytes written. The object *b* should be "
"an array of bytes, either :class:`bytes`, :class:`bytearray`, or "
":class:`memoryview`. When in non-blocking mode, a :exc:`BlockingIOError` is "
"raised if the buffer needs to be written out but the raw stream blocks."
msgstr "*b* を書き込み、書き込んだバイト数を返します。\nこのオブジェクト *b* はバイト配列、:class:`bytes` 、 :class:`bytearray` 、 :class:`memoryview` のいずれかである必要があります。\nノンブロッキングモードのときは、バッファが書き込まれる必要があるところで生ストリームがブロックした場合 :exc:`BlockingIOError` が送出されます。"

#: ../../library/io.rst:641
msgid ""
"A buffered interface to random access streams.  It inherits "
":class:`BufferedReader` and :class:`BufferedWriter`, and further supports "
":meth:`seek` and :meth:`tell` functionality."
msgstr "ランダムアクセスストリームへのバッファ付きインタフェース。 :class:`BufferedReader` および :class:`BufferedWriter` を継承し、さらに :meth:`seek` および :meth:`tell` をサポートしています。"

#: ../../library/io.rst:645
msgid ""
"The constructor creates a reader and writer for a seekable raw stream, given"
" in the first argument.  If the *buffer_size* is omitted it defaults to "
":data:`DEFAULT_BUFFER_SIZE`."
msgstr "このコンストラクタは第一引数として与えられるシーク可能な生ストリームに対し、リーダーおよびライターを作成します。 *buffer_size* が省略された場合、 :data:`DEFAULT_BUFFER_SIZE` がデフォルトになります。"

#: ../../library/io.rst:651
msgid ""
":class:`BufferedRandom` is capable of anything :class:`BufferedReader` or "
":class:`BufferedWriter` can do."
msgstr ":class:`BufferedRandom` は :class:`BufferedReader` や :class:`BufferedWriter` にできることは何でもできます。"

#: ../../library/io.rst:657
msgid ""
"A buffered I/O object combining two unidirectional :class:`RawIOBase` "
"objects -- one readable, the other writeable -- into a single bidirectional "
"endpoint.  It inherits :class:`BufferedIOBase`."
msgstr "2つの単方向 :class:`RawIOBase` オブジェクト -- 一つは読み込み可能、他方が書き込み可能 -- を組み合わせてバッファ付きの双方向 I/O オブジェクトにしたものです。 :class:`BufferedIOBase` を継承しています。"

#: ../../library/io.rst:661
msgid ""
"*reader* and *writer* are :class:`RawIOBase` objects that are readable and "
"writeable respectively.  If the *buffer_size* is omitted it defaults to "
":data:`DEFAULT_BUFFER_SIZE`."
msgstr "*reader* と *writer* はそれぞれ読み込み可能、書き込み可能な :class:`RawIOBase` オブジェクトです。 *buffer_size* が省略された場合 :data:`DEFAULT_BUFFER_SIZE` がデフォルトになります。"

#: ../../library/io.rst:665
msgid ""
"A fourth argument, *max_buffer_size*, is supported, but unused and "
"deprecated."
msgstr "第四引数 *max_buffer_size* が提供されていますが、使われず、非推奨です。"

#: ../../library/io.rst:668
msgid ""
":class:`BufferedRWPair` implements all of :class:`BufferedIOBase`\\'s "
"methods except for :meth:`~BufferedIOBase.detach`, which raises "
":exc:`UnsupportedOperation`."
msgstr ":class:`BufferedRWPair` は、 :exc:`UnsupportedOperation` を送出する :meth:`~BufferedIOBase.detach` を除く、 :class:`BufferedIOBase` の全てのメソッドを実装します。"

#: ../../library/io.rst:674
msgid ""
":class:`BufferedRWPair` does not attempt to synchronize accesses to its "
"underlying raw streams.  You should not pass it the same object as reader "
"and writer; use :class:`BufferedRandom` instead."
msgstr ":class:`BufferedRWPair` は下層の生ストリームのアクセスを同期しようとはしません。同じオブジェクトをリーダとライタとして渡してはいけません。その場合は代わりに :class:`BufferedRandom` を使用してください。"

#: ../../library/io.rst:680 ../../library/io.rst:896
msgid "Text I/O"
msgstr "テキスト I/O"

#: ../../library/io.rst:684
msgid ""
"Base class for text streams.  This class provides a unicode character and "
"line based interface to stream I/O.  There is no :meth:`readinto` method "
"because Python's :class:`unicode` strings are immutable. It inherits "
":class:`IOBase`.  There is no public constructor."
msgstr "テキストストリームの基底クラスです。このクラスはストリーム I/O への Unicode 文字と行に基づいたインタフェースを提供します。 Python の :class:`unicode` 文字列は変更不可能なので、 :meth:`readinto` メソッドは存在しません。 :class:`IOBase` を継承します。パブリックなコンストラクタはありません。"

#: ../../library/io.rst:689
msgid ""
":class:`TextIOBase` provides or overrides these data attributes and methods "
"in addition to those from :class:`IOBase`:"
msgstr ":class:`IOBase` から継承した属性とメソッドに加えて、 :class:`TextIOBase` は以下のデータ属性とメソッドを提供しています:"

#: ../../library/io.rst:694
msgid ""
"The name of the encoding used to decode the stream's bytes into strings, and"
" to encode strings into bytes."
msgstr "エンコーディング名で、ストリームのバイト列を文字列にデコードするとき、また文字列をバイト列にエンコードするときに使われます。"

#: ../../library/io.rst:699
msgid "The error setting of the decoder or encoder."
msgstr "このエンコーダやデコーダのエラー設定です。"

#: ../../library/io.rst:703
msgid ""
"A string, a tuple of strings, or ``None``, indicating the newlines "
"translated so far.  Depending on the implementation and the initial "
"constructor flags, this may not be available."
msgstr "文字列、文字列のタプル、または ``None`` で、改行がどのように読み換えられるかを指定します。実装や内部コンストラクタのフラグに依って、これは利用できないことがあります。"

#: ../../library/io.rst:709
msgid ""
"The underlying binary buffer (a :class:`BufferedIOBase` instance) that "
":class:`TextIOBase` deals with.  This is not part of the :class:`TextIOBase`"
" API and may not exist on some implementations."
msgstr ":class:`TextIOBase` が扱う根底のバイナリバッファ (:class:`BufferedIOBase` インスタンス) です。これは :class:`TextIOBase` API には含まれず、よって実装に含まれないことがあります。"

#: ../../library/io.rst:715
msgid ""
"Separate the underlying binary buffer from the :class:`TextIOBase` and "
"return it."
msgstr "根底のバイナリバッファを :class:`TextIOBase` から分離して返します。"

#: ../../library/io.rst:718
msgid ""
"After the underlying buffer has been detached, the :class:`TextIOBase` is in"
" an unusable state."
msgstr "根底のバッファが取り外された後、 :class:`TextIOBase` は使用不能状態になります。"

#: ../../library/io.rst:721
msgid ""
"Some :class:`TextIOBase` implementations, like :class:`~io.StringIO`, may "
"not have the concept of an underlying buffer and calling this method will "
"raise :exc:`UnsupportedOperation`."
msgstr ":class:`TextIOBase` 実装には、 :class:`~io.StringIO` など、根底のバッファという概念を持たないものがあります。これらを呼び出すと :exc:`UnsupportedOperation` を送出します。"

#: ../../library/io.rst:729
msgid ""
"Read and return at most *n* characters from the stream as a single "
":class:`unicode`.  If *n* is negative or ``None``, reads until EOF."
msgstr "最大 *n* 文字をストリームから読み込み、一つの :class:`unicode` にして返します。 *n* が負の値または ``None`` ならば、 EOF まで読みます。"

#: ../../library/io.rst:734
msgid ""
"Read until newline or EOF and return a single ``unicode``.  If the stream is"
" already at EOF, an empty string is returned."
msgstr "改行または EOF まで読み込み、一つの ``unicode`` を返します。ストリームが既に EOF に到達している場合、空文字列が返されます。"

#: ../../library/io.rst:737
msgid "If *limit* is specified, at most *limit* characters will be read."
msgstr "もし *limit* が指定された場合、最大で *limit* バイトが読み込まれます。"

#: ../../library/io.rst:741
msgid ""
"Change the stream position to the given *offset*.  Behaviour depends on the "
"*whence* parameter.  The default value for *whence* is :data:`SEEK_SET`."
msgstr "指定された *offset* にストリーム位置を変更します。 挙動は *whence* 引数によります。 *whence* のデフォルト値は :data:`SEEK_SET` です。:"

#: ../../library/io.rst:745
msgid ""
":data:`SEEK_SET` or ``0``: seek from the start of the stream (the default); "
"*offset* must either be a number returned by :meth:`TextIOBase.tell`, or "
"zero.  Any other *offset* value produces undefined behaviour."
msgstr ":data:`SEEK_SET` または ``0``: ストリームの先頭からシークします (デフォルト)。 *offset* は :meth:`TextIOBase.tell` が返す数か0のどちらかでなければなりません。それ以外の *offset* 値は未定義の挙動を起こします。"

#: ../../library/io.rst:749
msgid ""
":data:`SEEK_CUR` or ``1``: \"seek\" to the current position; *offset* must "
"be zero, which is a no-operation (all other values are unsupported)."
msgstr ":data:`SEEK_CUR` または ``1``: 現在の位置に \"シークします\"。 *offset* は 0 でなければなりません。つまり何もしません (他の値はサポートされていません)。"

#: ../../library/io.rst:752
msgid ""
":data:`SEEK_END` or ``2``: seek to the end of the stream; *offset* must be "
"zero (all other values are unsupported)."
msgstr ":data:`SEEK_END` または ``2``: ストリーム終端へシークします。 *offset* は 0 でなければなりません (他の値はサポートされていません)．"

#: ../../library/io.rst:755
msgid "Return the new absolute position as an opaque number."
msgstr "新しい絶対位置を、不透明な数値で返します。"

#: ../../library/io.rst:757
msgid "The ``SEEK_*`` constants."
msgstr "``SEEK_*`` 定数."

#: ../../library/io.rst:762
msgid ""
"Return the current stream position as an opaque number.  The number does not"
" usually represent a number of bytes in the underlying binary storage."
msgstr "ストリームの現在位置を不透明な数値で返します。この値は根底のバイナリストレージ内でのバイト数を表すとは限りません。"

#: ../../library/io.rst:768
msgid ""
"Write the :class:`unicode` string *s* to the stream and return the number of"
" characters written."
msgstr ":class:`unicode` 文字列 *s* をストリームに書き込み、書き込まれた文字数を返します。"

#: ../../library/io.rst:774
msgid ""
"A buffered text stream over a :class:`BufferedIOBase` binary stream. It "
"inherits :class:`TextIOBase`."
msgstr ":class:`BufferedIOBase` バイナリストリーム上のバッファ付きテキストストリーム。 :class:`TextIOBase` を継承します。"

#: ../../library/io.rst:777
msgid ""
"*encoding* gives the name of the encoding that the stream will be decoded or"
" encoded with.  It defaults to :func:`locale.getpreferredencoding`."
msgstr "*encoding* にはストリームをデコードしたりそれを使ってエンコードしたりするエンコーディング名を渡します。デフォルトは :func:`locale.getpreferredencoding` です。"

#: ../../library/io.rst:780
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled.  Pass ``'strict'`` to raise a :exc:`ValueError` "
"exception if there is an encoding error (the default of ``None`` has the "
"same effect), or pass ``'ignore'`` to ignore errors.  (Note that ignoring "
"encoding errors can lead to data loss.)  ``'replace'`` causes a replacement "
"marker (such as ``'?'``) to be inserted where there is malformed data.  When"
" writing, ``'xmlcharrefreplace'`` (replace with the appropriate XML "
"character reference) or ``'backslashreplace'`` (replace with backslashed "
"escape sequences) can be used.  Any other error handling name that has been "
"registered with :func:`codecs.register_error` is also valid."
msgstr "*errors* はオプションの文字列で、エンコードやデコードの際のエラーをどのように扱うかを指定します。エンコードエラーがあったら :exc:`ValueError` 例外を送出させるには ``'strict'`` を渡します(デフォルトの ``None`` でも同じです)。エラーを無視させるには ``'ignore'`` です。 (注意しなければならないのは、エンコーディングエラーを無視するとデータ喪失につながる可能性があるということです。) ``'replace'`` は正常に変換されなかった文字の代わりにマーカ (たとえば ``'?'``) を挿入させます。書き込み時には ``'xmlcharrefreplace'`` (適切な XML 文字参照に置き換え) や ``'backslashreplace'`` (バックスラッシュによるエスケープシーケンスに置き換え) も使えます。他にも :func:`codecs.register_error` で登録されたエラー処理名が有効です。"

#: ../../library/io.rst:794
msgid ""
"*newline* controls how line endings are handled.  It can be ``None``, "
"``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as follows:"
msgstr "*newline* は行末をどのように処理するかを制御します 。これは ``None``, ``''``, ``'\\n'``, ``'\\r'``, ``'\\r\\n'`` のいずれかです。これは以下のように働きます:"

#: ../../library/io.rst:797
msgid ""
"On input, if *newline* is ``None``, :term:`universal newlines` mode is "
"enabled.  Lines in the input can end in ``'\\n'``, ``'\\r'``, or "
"``'\\r\\n'``, and these are translated into ``'\\n'`` before being returned "
"to the caller.  If it is ``''``, universal newlines mode is enabled, but "
"line endings are returned to the caller untranslated.  If it has any of the "
"other legal values, input lines are only terminated by the given string, and"
" the line ending is returned to the caller untranslated."
msgstr "ストリームからの入力を読み込んでいる時、*newline* が ``None`` の場合、:term:`universal newlines` モードが有効になります。入力中の行は ``'\\n'``、``'\\r'``、または ``'\\r\\n'`` で終わり、呼び出し元に返される前に ``'\\n'`` に変換されます。 ``''`` の場合、ユニバーサル改行モードは有効になりますが、行末は変換されずに呼び出し元に返されます。その他の合法な値の場合、入力行は与えられた文字列でのみ終わり、行末は変換されずに呼び出し元に返されます。"

#: ../../library/io.rst:811
msgid ""
"If *line_buffering* is ``True``, :meth:`flush` is implied when a call to "
"write contains a newline character or a carriage return."
msgstr "*line_buffering* が ``True`` の場合、 write への呼び出しが改行文字もしくはキャリッジリターンを含んでいれば、暗黙的に :meth:`flush` が呼び出されます。"

#: ../../library/io.rst:814
msgid ""
":class:`TextIOWrapper` provides one attribute in addition to those of "
":class:`TextIOBase` and its parents:"
msgstr ":class:`TextIOBase` およびその親クラスの属性に加えて、 :class:`TextIOWrapper` は以下の属性を提供しています:"

#: ../../library/io.rst:819
msgid "Whether line buffering is enabled."
msgstr "行バッファリングが有効かどうか。"

#: ../../library/io.rst:824
msgid ""
"An in-memory stream for unicode text.  It inherits :class:`TextIOWrapper`."
msgstr "Unicode テキストのためのインメモリストリーム。 :class:`TextIOWrapper` を継承します。"

#: ../../library/io.rst:826
msgid ""
"The initial value of the buffer can be set by providing *initial_value*. If "
"newline translation is enabled, newlines will be encoded as if by "
":meth:`~TextIOBase.write`.  The stream is positioned at the start of the "
"buffer."
msgstr "バッファの初期値を *initial_value* で与えることが出来ます。改行変換を有効にすると、改行コードは :meth:`~TextIOBase.write` によってエンコードされます。ストリームはバッファの開始位置に配置されます。"

#: ../../library/io.rst:831
msgid ""
"The *newline* argument works like that of :class:`TextIOWrapper`. The "
"default is to consider only ``\\n`` characters as ends of lines and to do no"
" newline translation.  If *newline* is set to ``None``, newlines are written"
" as ``\\n`` on all platforms, but universal newline decoding is still "
"performed when reading."
msgstr "*newline* 引数は :class:`TextIOWrapper` のものと同じように働きます。デフォルトでは ``\\n`` 文字だけを行末とみなし、また、改行の変換は行いません。 *newline* に ``None`` をセットすると改行コードを全てのプラットフォームで ``\\n`` で書き込みますが、読み込み時にはそれでもユニバーサル改行としてのデコードは実行されます。"

#: ../../library/io.rst:837
msgid ""
":class:`~io.StringIO` provides this method in addition to those from "
":class:`TextIOWrapper` and its parents:"
msgstr ":class:`~io.StringIO` およびその親クラスから継承したメソッドに加えて :class:`StringIO` は以下のメソッドを提供しています:"

#: ../../library/io.rst:842
msgid ""
"Return a ``unicode`` containing the entire contents of the buffer at any "
"time before the :class:`~io.StringIO` object's :meth:`close` method is "
"called.  Newlines are decoded as if by :meth:`~TextIOBase.read`, although "
"the stream position is not changed."
msgstr ":class:`~io.StringIO` オブジェクトの :meth:`close` メソッドが呼び出される前の、任意の時点でのバッファの全内容を含む ``unicode`` を返します。改行コードのデコードは :meth:`~TextIOBase.read` によって行われますが、これによるストリーム位置の変更は起こりません。"

#: ../../library/io.rst:847
msgid "Example usage::"
msgstr "使用例::"

#: ../../library/io.rst:869
msgid ""
"A helper codec that decodes newlines for :term:`universal newlines` mode. It"
" inherits :class:`codecs.IncrementalDecoder`."
msgstr "改行を :term:`universal newlines` モードにデコードするヘルパーコーデックです。 :class:`codecs.IncrementalDecoder` を継承しています。"

#: ../../library/io.rst:874
msgid "Advanced topics"
msgstr "進んだ話題"

#: ../../library/io.rst:876
msgid ""
"Here we will discuss several advanced topics pertaining to the concrete I/O "
"implementations described above."
msgstr "ここで、上述の I/O 実装に関係するいくつかの進んだ話題について議論します。"

#: ../../library/io.rst:880
msgid "Performance"
msgstr "パフォーマンス"

#: ../../library/io.rst:883
msgid "Binary I/O"
msgstr "バイナリ I/O"

#: ../../library/io.rst:885
msgid ""
"By reading and writing only large chunks of data even when the user asks for"
" a single byte, buffered I/O is designed to hide any inefficiency in calling"
" and executing the operating system's unbuffered I/O routines.  The gain "
"will vary very much depending on the OS and the kind of I/O which is "
"performed (for example, on some contemporary OSes such as Linux, unbuffered "
"disk I/O can be as fast as buffered I/O).  The bottom line, however, is that"
" buffered I/O will offer you predictable performance regardless of the "
"platform and the backing device.  Therefore, it is most always preferable to"
" use buffered I/O rather than unbuffered I/O."
msgstr "バッファ付き I/O は、ユーザが 1 バイトだけ要求したときでさえ、データを大きな塊でのみ読み書きします。これにより、オペレーティングシステムのバッファ無し I/O ルーチンを呼び出して実行する非効率性をすべて隠しています。その成果は、OS と処理される I/O の種類に本当にとても大きく依存します (例えば、Linux のような現行の OS では、バッファ無しディスク I/O がバッファ付き I/O と同じくらい早いことがあります)。しかし、最低でも、バッファ付き I/O は予測できるパフォーマンスを提供します。ですから、ほとんどいつも、バッファ無し I/O より、バッファ付きの I/O を使うほうが望ましいです。"

#: ../../library/io.rst:898
msgid ""
"Text I/O over a binary storage (such as a file) is significantly slower than"
" binary I/O over the same storage, because it implies conversions from "
"unicode to binary data using a character codec.  This can become noticeable "
"if you handle huge amounts of text data (for example very large log files). "
"Also, :meth:`TextIOWrapper.tell` and :meth:`TextIOWrapper.seek` are both "
"quite slow due to the reconstruction algorithm used."
msgstr "(ファイルなどの) バイナリストレージ上のテキスト I/O は、同じストレージ上のバイナリ I/O より非常に遅いです。なぜならこれは、文字コーデックを使った Unicode からバイナリデータへの変換を暗示しているからです。これは大量のテキストデータ (例えば非常に大きなログファイル) を扱うときに顕著に成り得ます。同様に、 :meth:`TextIOWrapper.tell` や :meth:`TextIOWrapper.seek` はどちらも、使われている復元アルゴリズムのために遅くなります。"

#: ../../library/io.rst:905
msgid ""
":class:`~io.StringIO`, however, is a native in-memory unicode container and "
"will exhibit similar speed to :class:`BytesIO`."
msgstr "しかし :class:`~io.StringIO` は、ネイティブなインメモリ Unicode コンテナで、 :class:`BytesIO` と同程度の速度を示します。"

#: ../../library/io.rst:909
msgid "Multi-threading"
msgstr "マルチスレッディング"

#: ../../library/io.rst:911
msgid ""
":class:`FileIO` objects are thread-safe to the extent that the operating "
"system calls (such as ``read(2)`` under Unix) they are wrapping are thread-"
"safe too."
msgstr "(Unix における ``read(2)`` のような) オペレーティングシステムコールの、それがラッピングしているものがスレッドセーフであるような範囲内では、 :class:`FileIO` オブジェクトもまた、スレッドセーフです。"

#: ../../library/io.rst:915
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, "
":class:`BufferedWriter`, :class:`BufferedRandom` and "
":class:`BufferedRWPair`) protect their internal structures using a lock; it "
"is therefore safe to call them from multiple threads at once."
msgstr "バイナリバッファ付きオブジェクト (:class:`BufferedReader`, :class:`BufferedWriter`, :class:`BufferedRandom` および :class:`BufferedRWPair` のインスタンス) は、その内部構造をロックを使って保護します。このため、これらを複数のスレッドから同時に呼び出しても安全です。"

#: ../../library/io.rst:920
msgid ":class:`TextIOWrapper` objects are not thread-safe."
msgstr ":class:`TextIOWrapper` オブジェクトはスレッドセーフではありません。"

#: ../../library/io.rst:923
msgid "Reentrancy"
msgstr "リエントラント性"

#: ../../library/io.rst:925
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, "
":class:`BufferedWriter`, :class:`BufferedRandom` and "
":class:`BufferedRWPair`) are not reentrant.  While reentrant calls will not "
"happen in normal situations, they can arise if you are doing I/O in a "
":mod:`signal` handler.  If it is attempted to enter a buffered object again "
"while already being accessed *from the same thread*, then a "
":exc:`RuntimeError` is raised."
msgstr "バイナリバッファ付きオブジェクト (:class:`BufferedReader`, :class:`BufferedWriter`, :class:`BufferedRandom` および :class:`BufferedRWPair` のインスタンス) は、リエントラントではありません。リエントラントな呼び出しは普通の状況では起こりませんが、 I/O を :mod:`signal` ハンドラで行なっているときに起こりえます。バッファ化されたオブジェクトに、すでに *同じスレッドから* アクセスされているのにもかかわらず、再び入ろうとすると :exc:`RuntimeError` が送出されます。"

#: ../../library/io.rst:932
msgid ""
"The above implicitly extends to text files, since the :func:`open()` "
"function will wrap a buffered object inside a :class:`TextIOWrapper`.  This "
"includes standard streams and therefore affects the built-in function "
":func:`print()` as well."
msgstr ":func:`open()` 関数は :class:`TextIOWrapper` 内部のバッファ付きオブジェクトをラップするため、テキストファイルにも暗黙に拡張されます。これは、標準ストリームを含むので、組み込み関数 :func:`print()` にも同様に影響します。"
