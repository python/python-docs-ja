# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-15 13:55+0900\n"
"PO-Revision-Date: 2018-05-20 05:59+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/io.rst:2
msgid ":mod:`io` --- Core tools for working with streams"
msgstr ":mod:`io` --- ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ‰±ã†ã‚³ã‚¢ãƒ„ãƒ¼ãƒ«"

#: ../../library/io.rst:16
msgid ""
"The :mod:`io` module provides the Python interfaces to stream handling. "
"Under Python 2.x, this is proposed as an alternative to the built-in "
":class:`file` object, but in Python 3.x it is the default interface to "
"access files and streams."
msgstr ":mod:`io` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã‚’è¡Œã† Python ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚ Python 2.x ã§ã¯ã€ã“ã‚Œã¯çµ„ã¿è¾¼ã¿ã® :class:`file` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»£ã‚ã‚Šã¨ã—ã¦ææ¡ˆã•ã‚Œã¦ã„ã¾ã™ãŒã€Python 3.x ã§ã¯ã€ã“ã‚ŒãŒãƒ•ã‚¡ã‚¤ãƒ«ã‚„ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§ã™ã€‚"

#: ../../library/io.rst:23
msgid ""
"Since this module has been designed primarily for Python 3.x, you have to be"
" aware that all uses of \"bytes\" in this document refer to the :class:`str`"
" type (of which :class:`bytes` is an alias), and all uses of \"text\" refer "
"to the :class:`unicode` type.  Furthermore, those two types are not "
"interchangeable in the :mod:`io` APIs."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã‚‚ã¨ã‚‚ã¨ã€Python 3.x ã®ãŸã‚ã«è¨­è¨ˆã•ã‚ŒãŸã‚‚ã®ãªã®ã§ã€ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ä¸­ã§ä½¿ã‚ã‚Œã‚‹ã™ã¹ã¦ã® \"bytes\" ã¯ (:class:`bytes` ãŒã‚¨ã‚¤ãƒªã‚¢ã‚¹ã¨ãªã‚‹) :class:`str` å‹ã®ã“ã¨ã§ã€ã™ã¹ã¦ã® \"text\" ã¯ :class:`unicode` å‹ã®ã“ã¨ã§ã™ã€‚ã•ã‚‰ã«ã€ :mod:`io` API ã§ã¯ã€ã“ã® 2 ã¤ã®å‹ã¯å…¥ã‚Œæ›¿ãˆã‚‰ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:29
msgid ""
"At the top of the I/O hierarchy is the abstract base class :class:`IOBase`."
"  It defines the basic interface to a stream.  Note, however, that there is "
"no separation between reading and writing to streams; implementations are "
"allowed to raise an :exc:`IOError` if they do not support a given operation."
msgstr "I/O éšå±¤ã®æœ€ä¸Šä½ã«ã¯æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã® :class:`IOBase` ãŒã‚ã‚Šã¾ã™ã€‚ :class:`IOBase` ã§ã¯ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ã¦åŸºæœ¬çš„ãªã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ã—ã‹ã—ãªãŒã‚‰ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã™ã‚‹èª­ã¿è¾¼ã¿ã¨æ›¸ãè¾¼ã¿ãŒåˆ†é›¢ã•ã‚Œã¦ã„ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚å®Ÿè£…ã«ãŠã„ã¦ã¯ä¸ãˆã‚‰ã‚ŒãŸæ“ä½œã‚’ã‚µãƒãƒ¼ãƒˆã—ãªã„å ´åˆã¯ :exc:`IOError` ã‚’é€å‡ºã™ã‚‹ã“ã¨ãŒè¨±ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/io.rst:34
msgid ""
"Extending :class:`IOBase` is :class:`RawIOBase` which deals simply with the "
"reading and writing of raw bytes to a stream.  :class:`FileIO` subclasses "
":class:`RawIOBase` to provide an interface to files in the machine's file "
"system."
msgstr ":class:`IOBase` ã®æ‹¡å¼µã¯ã€å˜ç´”ãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã™ã‚‹ç”Ÿã®ãƒã‚¤ãƒˆåˆ—ã®èª­ã¿æ›¸ãã‚’æ‰±ã† :class:`RawIOBase` ã§ã™ã€‚ :class:`FileIO` ã¯ã€ :class:`RawIOBase` ã‚’ç¶™æ‰¿ã—ã¦ãƒã‚·ãƒ³ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/io.rst:39
msgid ""
":class:`BufferedIOBase` deals with buffering on a raw byte stream "
"(:class:`RawIOBase`).  Its subclasses, :class:`BufferedWriter`, "
":class:`BufferedReader`, and :class:`BufferedRWPair` buffer streams that are"
" readable, writable, and both readable and writable. :class:`BufferedRandom`"
" provides a buffered interface to random access streams.  :class:`BytesIO` "
"is a simple stream of in-memory bytes."
msgstr ":class:`BufferedIOBase` ã§ã¯ç”Ÿã®ãƒã‚¤ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ  (:class:`RawIOBase`) ä¸Šã«ãƒãƒƒãƒ•ã‚¡å‡¦ç†ã‚’è¿½åŠ ã—ã¾ã™ã€‚ãã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã® :class:`BufferedWriter`, :class:`BufferedReader`, :class:`BufferedRWPair` ã§ã¯ã€ãã‚Œãã‚Œèª­ã¿è¾¼ã¿å°‚ç”¨ã€æ›¸ãè¾¼ã¿å°‚ç”¨ã€èª­ã¿æ›¸ãå¯èƒ½ãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ãƒãƒƒãƒ•ã‚¡ã—ã¾ã™ã€‚ :class:`BufferedRandom` ã§ã¯ãƒ©ãƒ³ãƒ€ãƒ ã‚¢ã‚¯ã‚»ã‚¹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ã¦ãƒãƒƒãƒ•ã‚¡ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚ :class:`BytesIO` ã¯ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªãƒã‚¤ãƒˆã¸ã®ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã™ã€‚"

#: ../../library/io.rst:46
msgid ""
"Another :class:`IOBase` subclass, :class:`TextIOBase`, deals with streams "
"whose bytes represent text, and handles encoding and decoding from and to "
":class:`unicode` strings.  :class:`TextIOWrapper`, which extends it, is a "
"buffered text interface to a buffered raw stream (:class:`BufferedIOBase`). "
"Finally, :class:`~io.StringIO` is an in-memory stream for unicode text."
msgstr ":class:`IOBase` ã®ã‚‚ã†ä¸€ã¤ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ :class:`TextIOBase` ã¯ã€ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ã™ãƒã‚¤ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ‰±ã„ã€ :class:`unicode` ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚„ãƒ‡ã‚³ãƒ¼ãƒ‰ã¨ã„ã£ãŸå‡¦ç†ã‚’è¡Œã„ã¾ã™ã€‚ :class:`TextIOWrapper` ã¯ãã®æ‹¡å¼µã§ã€ãƒãƒƒãƒ•ã‚¡ä»˜ãç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ  (:class:`BufferedIOBase`) ã¸ã®ãƒãƒƒãƒ•ã‚¡ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§ã™ã€‚æœ€å¾Œã« :class:`~io.StringIO` ã¯ Unicode ãƒ†ã‚­ã‚¹ãƒˆã«å¯¾ã™ã‚‹ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã™ã€‚"

#: ../../library/io.rst:53
msgid ""
"Argument names are not part of the specification, and only the arguments of "
":func:`.open` are intended to be used as keyword arguments."
msgstr "å¼•æ•°åã¯è¦ç´„ã«å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãã—ã¦ :func:`.open` ã®å¼•æ•°ã ã‘ãŒã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ã—ã¦ç”¨ã„ã‚‰ã‚Œã‚‹ã“ã¨ãŒæ„å›³ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/io.rst:58
msgid "Module Interface"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹"

#: ../../library/io.rst:62
msgid ""
"An int containing the default buffer size used by the module's buffered I/O "
"classes.  :func:`.open` uses the file's blksize (as obtained by "
":func:`os.stat`) if possible."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒãƒƒãƒ•ã‚¡ I/O ã‚¯ãƒ©ã‚¹ã§ä½¿ç”¨ã•ã‚Œã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã‚’æŒ‡å®šã™ã‚‹æ•´æ•°å€¤ã§ã™ã€‚ :func:`.open` ã¯å¯èƒ½ã§ã‚ã‚Œã°ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“ã®ã‚µã‚¤ã‚º (:func:`os.stat` ã§å–å¾—ã•ã‚Œã¾ã™) ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/io.rst:68
msgid ""
"Open *file* and return a corresponding stream.  If the file cannot be "
"opened, an :exc:`IOError` is raised."
msgstr "*file* ã‚’é–‹ãã€å¯¾å¿œã™ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸå ´åˆã€ :exc:`IOError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/io.rst:71
msgid ""
"*file* is either a string giving the pathname (absolute or relative to the "
"current working directory) of the file to be opened or an integer file "
"descriptor of the file to be wrapped.  (If a file descriptor is given, it is"
" closed when the returned I/O object is closed, unless *closefd* is set to "
"``False``.)"
msgstr "*file* ã¯é–‹ããŸã„ãƒ•ã‚¡ã‚¤ãƒ«ã® (çµ¶å¯¾ã€ã¾ãŸã¯ã‚«ãƒ¬ãƒ³ãƒˆãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«å¯¾ã™ã‚‹ç›¸å¯¾) ãƒ‘ã‚¹åã‚’ç¤ºã™æ–‡å­—åˆ—ã‹ã€é–‹ããŸã„ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ©ãƒƒãƒ—ã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã§ã™ã€‚ (ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ *closefd* ãŒ ``False`` ã«è¨­å®šã•ã‚Œã¦ã„ãªã„é™ã‚Šã€è¿”ã•ã‚ŒãŸ I/O ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒé–‰ã˜ã‚‰ã‚ŒãŸã¨ãã«ãã®ãƒ•ã‚¡ã‚¤ãƒ«è­˜åˆ¥å­ã‚‚é–‰ã˜ã‚‰ã‚Œã¾ã™)"

#: ../../library/io.rst:77
msgid ""
"*mode* is an optional string that specifies the mode in which the file is "
"opened.  It defaults to ``'r'`` which means open for reading in text mode. "
"Other common values are ``'w'`` for writing (truncating the file if it "
"already exists), and ``'a'`` for appending (which on *some* Unix systems, "
"means that *all* writes append to the end of the file regardless of the "
"current seek position).  In text mode, if *encoding* is not specified the "
"encoding used is platform dependent. (For reading and writing raw bytes use "
"binary mode and leave *encoding* unspecified.)  The available modes are:"
msgstr "*mode* ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ–‡å­—åˆ—ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã£ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã©ã®ã‚ˆã†ãªãƒ¢ãƒ¼ãƒ‰ã§é–‹ãã‹æ˜ç¤ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``'r'`` ã§ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§èª­ã¿å–ã‚Šå°‚ç”¨ã§é–‹ãã“ã¨ã‚’æŒ‡ã—ã¾ã™ã€‚ä»–ã«ã‚‚ ``'w'`` ã¯æ›¸ãè¾¼ã¿å°‚ç”¨ (ã‚‚ã—ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¦ã„ãŸå ´åˆã¯ä¸Šæ›¸ãã«ãªã‚Šã¾ã™) ã¨ãªã‚Šã€ ``'a'`` ã§ã¯è¿½è¨˜ãƒ¢ãƒ¼ãƒ‰ã¨ãªã‚Šã¾ã™ã€‚ (``'a'`` ã¯ *ã„ãã¤ã‹ã®* Unixã‚·ã‚¹ãƒ†ãƒ ã§ã¯ *ã™ã¹ã¦ã®* æ›¸ãè¾¼ã¿ãŒã‚·ãƒ¼ã‚¯ä½ç½®ã«é–¢ä¿‚ãªããƒ•ã‚¡ã‚¤ãƒ«ã®æœ«å°¾ã«è¿½è¨˜ã•ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™) ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€ã‚‚ã— *encoding* ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã‹ã£ãŸå ´åˆã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã¨ãªã‚Šã¾ã™ã€‚ (ç”Ÿã®ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã¨æ›¸ãè¾¼ã¿ã¯ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã‚’ç”¨ã„ã¦ã€ *encoding* ã¯æœªæŒ‡å®šã®ã¾ã¾ã¨ã—ã¾ã™) æŒ‡å®šå¯èƒ½ãªãƒ¢ãƒ¼ãƒ‰ã¯æ¬¡ã®è¡¨ã®é€šã‚Šã§ã™ã€‚"

#: ../../library/io.rst:87
msgid "Character"
msgstr "æ–‡å­—"

#: ../../library/io.rst:87
msgid "Meaning"
msgstr "æ„å‘³"

#: ../../library/io.rst:89
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/io.rst:89
msgid "open for reading (default)"
msgstr "èª­ã¿è¾¼ã¿ç”¨ã«é–‹ã (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)"

#: ../../library/io.rst:90
msgid "``'w'``"
msgstr "``'w'``"

#: ../../library/io.rst:90
msgid "open for writing, truncating the file first"
msgstr "æ›¸ãè¾¼ã¿ç”¨ã«é–‹ãã€ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã¾ãšåˆ‡ã‚Šè©°ã‚ã‚‰ã‚Œã‚‹"

#: ../../library/io.rst:91
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/io.rst:91
msgid "open for writing, appending to the end of the file if it exists"
msgstr "æ›¸ãè¾¼ã¿ç”¨ã«é–‹ãã€ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯æœ«å°¾ã«è¿½è¨˜ã™ã‚‹"

#: ../../library/io.rst:92
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/io.rst:92
msgid "binary mode"
msgstr "ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰"

#: ../../library/io.rst:93
msgid "``'t'``"
msgstr "``'t'``"

#: ../../library/io.rst:93
msgid "text mode (default)"
msgstr "ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)"

#: ../../library/io.rst:94
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/io.rst:94
msgid "open a disk file for updating (reading and writing)"
msgstr "ãƒ‡ã‚£ã‚¹ã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°ç”¨ã«é–‹ã (èª­ã¿è¾¼ã¿ï¼æ›¸ãè¾¼ã¿)"

#: ../../library/io.rst:95
msgid "``'U'``"
msgstr "``'U'``"

#: ../../library/io.rst:95
msgid ""
"universal newlines mode (for backwards compatibility; should not be used in "
"new code)"
msgstr "ãƒ¦ãƒ‹ãƒãƒ¼ã‚µãƒ«æ”¹è¡Œãƒ¢ãƒ¼ãƒ‰ (å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã®ã‚‚ã®ã§ã™; æ–°ã—ã„ã‚³ãƒ¼ãƒ‰ã§ã¯ä½¿ã†ã¹ãã§ã‚ã‚Šã¾ã›ã‚“)"

#: ../../library/io.rst:99
msgid ""
"The default mode is ``'rt'`` (open for reading text).  For binary random "
"access, the mode ``'w+b'`` opens and truncates the file to 0 bytes, while "
"``'r+b'`` opens the file without truncation."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ¼ãƒ‰ã¯ ``'rt'`` ã§ã™ (ãƒ†ã‚­ã‚¹ãƒˆã‚’èª­ã¿è¾¼ã¿å°‚ç”¨ã§é–‹ãã¾ã™)ã€‚ãƒã‚¤ãƒŠãƒªã®ãƒ©ãƒ³ãƒ€ãƒ ã‚¢ã‚¯ã‚»ã‚¹ã§ã¯ ``'w+b'`` ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ 0 ãƒã‚¤ãƒˆã«åˆ‡ã‚Šè©°ã‚ã¾ã™ã€‚ä¸€æ–¹ã§ ``'r+b'`` ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãã¨ã‚µã‚¤ã‚ºã®åˆ‡ã‚Šè©°ã‚ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:103
msgid ""
"Python distinguishes between files opened in binary and text modes, even "
"when the underlying operating system doesn't.  Files opened in binary mode "
"(including ``'b'`` in the *mode* argument) return contents as :class:`bytes`"
" objects without any decoding.  In text mode (the default, or when ``'t'`` "
"is included in the *mode* argument), the contents of the file are returned "
"as :class:`unicode` strings, the bytes having been first decoded using a "
"platform-dependent encoding or using the specified *encoding* if given."
msgstr "Python ã§ã¯ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¨ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯åŒºåˆ¥ã•ã‚Œã¾ã™ã€‚ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ãŒåŒºåˆ¥ã—ãªã„å ´åˆã§ã‚‚ã“ã®åŒºåˆ¥ã¯é©ç”¨ã•ã‚Œã¾ã™ã€‚ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ« (ã¤ã¾ã‚Š *mode* å¼•æ•°ã« ``'b'`` ãŒå«ã¾ã‚Œã‚‹ã¨ã) ã§ã¯ã€ä¸­èº«ã‚’ :class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã—ã€ä¸€åˆ‡ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚’è¡Œã„ã¾ã›ã‚“ã€‚ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‹ *mode* å¼•æ•°ã« ``'t'`` ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆ) ã§ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã¯ :class:`unicode` æ–‡å­—åˆ—ã¨ã—ã¦è¿”ã•ã‚Œã€ãƒã‚¤ãƒˆåˆ—ã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‹ã€ *encoding* ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã¯æŒ‡å®šã•ã‚ŒãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã£ã¦ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:111
msgid ""
"*buffering* is an optional integer used to set the buffering policy. Pass 0 "
"to switch buffering off (only allowed in binary mode), 1 to select line "
"buffering (only usable in text mode), and an integer > 1 to indicate the "
"size of a fixed-size chunk buffer.  When no *buffering* argument is given, "
"the default buffering policy works as follows:"
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *buffering* ã¯ãƒãƒƒãƒ•ã‚¡ç”¨ã®è¨­å®šã‚’è¡Œã†æ•´æ•°å€¤ã§ã™ã€‚ 0 ã‚’è¨­å®šã™ã‚‹ã“ã¨ã§ãƒãƒƒãƒ•ã‚¡ãŒã‚ªãƒ•ã«ãªã‚Šã¾ã™ (ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§ã®ã¿æœ‰åŠ¹ã§ã™)ã€‚ 1 ã®å ´åˆã¯ 1 è¡Œã”ã¨ã®ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã‚’è¡Œã„ (ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã™)ã€ 1 ã‚ˆã‚Šå¤§ãã„å ´åˆã¯å›ºå®šã‚µã‚¤ã‚ºãƒãƒ£ãƒ³ã‚¯ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚ºã‚’è¡¨ã—ã¾ã™ã€‚ *buffering* å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œãªã‘ã‚Œã°ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ãƒãƒªã‚·ãƒ¼ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«åƒãã¾ã™:"

#: ../../library/io.rst:117
msgid ""
"Binary files are buffered in fixed-size chunks; the size of the buffer is "
"chosen using a heuristic trying to determine the underlying device's \"block"
" size\" and falling back on :attr:`DEFAULT_BUFFER_SIZE`. On many systems, "
"the buffer will typically be 4096 or 8192 bytes long."
msgstr "ãƒã‚¤ãƒŠãƒªãƒ•ã‚¡ã‚¤ãƒ«ã¯å›ºå®šã‚µã‚¤ã‚ºã®ãƒãƒ£ãƒ³ã‚¯ã§ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã•ã‚Œã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã¯ã€èƒŒå¾Œã®ãƒ‡ãƒã‚¤ã‚¹ã®ã€Œãƒ–ãƒ­ãƒƒã‚¯ã‚µã‚¤ã‚ºã€ã‚’æ±ºå®šã™ã‚‹ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚’ç”¨ã„ã¦é¸æŠã•ã‚Œã€ãã‚ŒãŒä¸å¯èƒ½ãªå ´åˆã¯ä»£ã‚ã‚Šã« :attr:`DEFAULT_BUFFER_SIZE` ãŒä½¿ã‚ã‚Œã¾ã™ã€‚å¤šãã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€å…¸å‹çš„ãªãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã¯ 4096 ã‹ 8192 ãƒã‚¤ãƒˆé•·ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/io.rst:122
msgid ""
"\"Interactive\" text files (files for which :meth:`isatty` returns True) use"
" line buffering.  Other text files use the policy described above for binary"
" files."
msgstr "ã€Œå¯¾è©±çš„ãªã€ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ« (:meth:`isatty` ãŒ True ã‚’è¿”ã™ãƒ•ã‚¡ã‚¤ãƒ«) ã¯è¡Œãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ãã®ä»–ã®ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ä¸Šã§èª¬æ˜ã•ã‚ŒãŸãƒã‚¤ãƒŠãƒªãƒ•ã‚¡ã‚¤ãƒ«ã®ãŸã‚ã®ãƒãƒªã‚·ãƒ¼ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/io.rst:126
msgid ""
"*encoding* is the name of the encoding used to decode or encode the file. "
"This should only be used in text mode.  The default encoding is platform "
"dependent (whatever :func:`locale.getpreferredencoding` returns), but any "
"encoding supported by Python can be used.  See the :mod:`codecs` module for "
"the list of supported encodings."
msgstr "*encoding* ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚„ãƒ‡ã‚³ãƒ¼ãƒ‰ã«ä½¿ã‚ã‚Œã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®åå‰ã§ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã®ã¿ä½¿ç”¨ã•ã‚Œã‚‹ã¹ãã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ (:func:`locale.getpreferredencoding` ãŒè¿”ã™ã‚‚ã®) ã§ã™ãŒã€Pythonã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ã©ã‚Œã§ã‚‚ä½¿ãˆã¾ã™ã€‚è©³ã—ãã¯ :mod:`codecs` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã®ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ãƒªã‚¹ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/io.rst:132
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handledâ€”this cannot be used in binary mode.  Pass "
"``'strict'`` to raise a :exc:`ValueError` exception if there is an encoding "
"error (the default of ``None`` has the same effect), or pass ``'ignore'`` to"
" ignore errors.  (Note that ignoring encoding errors can lead to data loss.)"
" ``'replace'`` causes a replacement marker (such as ``'?'``) to be inserted "
"where there is malformed data.  When writing, ``'xmlcharrefreplace'`` "
"(replace with the appropriate XML character reference) or "
"``'backslashreplace'`` (replace with backslashed escape sequences) can be "
"used.  Any other error handling name that has been registered with "
":func:`codecs.register_error` is also valid."
msgstr "*errors* ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚„ãƒ‡ã‚³ãƒ¼ãƒ‰ã®éš›ã®ã‚¨ãƒ©ãƒ¼ã‚’ã©ã®ã‚ˆã†ã«æ‰±ã†ã‹ã‚’æŒ‡å®šã™ã‚‹æ–‡å­—åˆ—ã§ã€ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§ã¯ä½¿ãˆã¾ã›ã‚“ã€‚ ``'strict'`` ã‚’æŒ‡å®šã™ã‚‹ã¨ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒã‚ã£ãŸå ´åˆ :exc:`ValueError` ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚ã‚‹ ``None`` ã¯åŒæ§˜ã®å‡¦ç†ã‚’è¡Œã„ã¾ã™)ã€‚ ``'ignore'`` ã‚’æŒ‡å®šã—ãŸå ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–ã—ã¾ã™ã€‚ ``'replace'`` ã‚’æŒ‡å®šã—ãŸå ´åˆã¯æ­£å¸¸ã«å¤‰æ›ã•ã‚Œãªã‹ã£ãŸæ–‡å­—ã®ä»£ã‚ã‚Šã«ãƒãƒ¼ã‚« (ä¾‹ãˆã° ``'?'`` ã®ã‚ˆã†ãªæ–‡å­—) ã‚’æŒ¿å…¥ã—ã¾ã™ã€‚æ›¸ãè¾¼ã¿ã®éš›ã«ã¯ ``'xmlcharrefreplace'`` (é©åˆ‡ãªXMLæ–‡å­—å‚ç…§ã«ç½®ãæ›ãˆã‚‹) ã‹ ``'backslashreplace'`` (ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«ã‚ˆã‚‹ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ç½®ãæ›ãˆã‚‹) ã®ã©ã¡ã‚‰ã‹ãŒä½¿ç”¨ã§ãã¾ã™ã€‚ :func:`codecs.register_error` ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ä»–ã®ã‚¨ãƒ©ãƒ¼å‡¦ç†åã‚‚æŒ‡å®šã§ãã¾ã™ã€‚"

#: ../../library/io.rst:147
msgid ""
"*newline* controls how :term:`universal newlines` works (it only applies to "
"text mode).  It can be ``None``, ``''``, ``'\\n'``, ``'\\r'``, and "
"``'\\r\\n'``. It works as follows:"
msgstr "*newline* ã¯ :term:`universal newlines` ãƒ¢ãƒ¼ãƒ‰ãŒã©ã®ã‚ˆã†ã«åƒãã‹ã‚’åˆ¶å¾¡ã—ã¾ã™ (ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã®ã¿ã¯ãŸã‚‰ãã¾ã™)ã€‚ã“ã‚Œã¯ ``None``, ``''``, ``'\\n'``, ``'\\r'``, ``'\\r\\n'`` ã®ã„ãšã‚Œã‹ã§ã™ã€‚ã“ã‚Œã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã¯ãŸã‚‰ãã¾ã™:"

#: ../../library/io.rst:151
msgid ""
"On input, if *newline* is ``None``, universal newlines mode is enabled. "
"Lines in the input can end in ``'\\n'``, ``'\\r'``, or ``'\\r\\n'``, and "
"these are translated into ``'\\n'`` before being returned to the caller.  If"
" it is ``''``, universal newlines mode is enabled, but line endings are "
"returned to the caller untranslated.  If it has any of the other legal "
"values, input lines are only terminated by the given string, and the line "
"ending is returned to the caller untranslated."
msgstr "ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰ã®å…¥åŠ›ã®èª­ã¿è¾¼ã¿æ™‚ã€*newline* ãŒ ``None`` ã§ã‚ã‚Œã°ã€ãƒ¦ãƒ‹ãƒãƒ¼ã‚µãƒ«æ”¹è¡Œãƒ¢ãƒ¼ãƒ‰ãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚å…¥åŠ›ä¸­ã®è¡Œã¯ ``'\\n'``, ``'\\r'``, ã¾ãŸã¯ ``'\\r\\n'`` ã§çµ‚ç«¯ã•ã‚Œã€å‘¼ã³å‡ºã—å…ƒã«è¿”ã•ã‚Œã‚‹å‰ã« ``'\\n'`` ã«åˆ‡ã‚Šè©°ã‚ã‚‰ã‚Œã¾ã™ã€‚``''`` ãªã‚‰ã€ãƒ¦ãƒ‹ãƒãƒ¼ã‚µãƒ«æ”¹è¡Œãƒ¢ãƒ¼ãƒ‰ã¯æœ‰åŠ¹ã«ãªã‚Šã¾ã™ãŒã€è¡Œæœ«ã¯ç¿»è¨³ã•ã‚Œãšã«å‘¼ã³å‡ºã—å…ƒã«è¿”ã•ã‚Œã¾ã™ã€‚ãã®ä»–ã®æ­£å½“ãªå€¤ãªã‚‰ã€å…¥åŠ›è¡Œã¯ä¸ãˆã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã§ã®ã¿çµ‚ç«¯ã•ã‚Œã€è¡Œæœ«ã¯ç¿»è¨³ã•ã‚Œãšã«å‘¼ã³å‡ºã—å…ƒã«è¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:159 ../../library/io.rst:805
msgid ""
"On output, if *newline* is ``None``, any ``'\\n'`` characters written are "
"translated to the system default line separator, :data:`os.linesep`.  If "
"*newline* is ``''``, no translation takes place.  If *newline* is any of the"
" other legal values, any ``'\\n'`` characters written are translated to the "
"given string."
msgstr "å‡ºåŠ›æ™‚ã€ *newline* ãŒ ``None`` ã®å ´åˆã¯ã€ã™ã¹ã¦ã® ``'\\n'`` æ–‡å­—ã¯ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¡ŒåŒºåˆ‡ã‚Šæ–‡å­— :data:`os.linesep` ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚ã‚‚ã— *newline* ãŒ ``''`` ã®å ´åˆã€å¤‰æ›ã¯èµ·ã“ã‚Šã¾ã›ã‚“ã€‚ã‚‚ã— *newline* ã«ä»–ã®é©åˆ‡ãªå€¤ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã¯ã€ ``'\\n'`` æ–‡å­—ã¯ä¸ãˆã‚‰ã‚ŒãŸæ–‡å­—ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:165
msgid ""
"If *closefd* is ``False`` and a file descriptor rather than a filename was "
"given, the underlying file descriptor will be kept open when the file is "
"closed.  If a filename is given *closefd* has no effect and must be ``True``"
" (the default)."
msgstr "ã‚‚ã— *closefd* ãŒ ``False`` ã§ã€ãƒ•ã‚¡ã‚¤ãƒ«åã§ã¯ãªãã¦ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ãŒä¸ãˆã‚‰ã‚Œã¦ã„ãŸå ´åˆã€å‡¦ç†ä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‰ã˜ã‚‰ã‚ŒãŸå¾Œã‚‚é–‹ã„ãŸã¾ã¾ã¨ãªã‚Šã¾ã™ã€‚ã‚‚ã—ãƒ•ã‚¡ã‚¤ãƒ«åãŒä¸ãˆã‚‰ã‚Œã¦ã„ãŸå ´åˆã¯ã€ *closefd* ã¯é–¢ä¿‚ã‚ã‚Šã¾ã›ã‚“ã€‚ã—ã‹ã— ``True`` ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤)ã€‚"

#: ../../library/io.rst:170
msgid ""
"The type of file object returned by the :func:`.open` function depends on "
"the mode.  When :func:`.open` is used to open a file in a text mode "
"(``'w'``, ``'r'``, ``'wt'``, ``'rt'``, etc.), it returns a subclass of "
":class:`TextIOBase` (specifically :class:`TextIOWrapper`).  When used to "
"open a file in a binary mode with buffering, the returned class is a "
"subclass of :class:`BufferedIOBase`.  The exact class varies: in read binary"
" mode, it returns a :class:`BufferedReader`; in write binary and append "
"binary modes, it returns a :class:`BufferedWriter`, and in read/write mode, "
"it returns a :class:`BufferedRandom`.  When buffering is disabled, the raw "
"stream, a subclass of :class:`RawIOBase`, :class:`FileIO`, is returned."
msgstr ":func:`.open` ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã¯ãƒ¢ãƒ¼ãƒ‰ã«ä¾å­˜ã—ã¾ã™ã€‚ :func:`.open` ãŒãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ããŸã‚ã«ä½¿ã‚ã‚ŒãŸå ´åˆ (``'w'``\\ ã€ ``'r'``\\ ã€ ``'wt'``\\ ã€ ``'rt'`` ãªã©) :class:`TextIOBase` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ (å…·ä½“çš„ã«ã¯ :class:`TextIOWrapper`) ãŒè¿”ã•ã‚Œã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã‚’ã—ã¦ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãå ´åˆã€ :class:`BufferedIOBase` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ãŒè¿”ã•ã‚Œã¾ã™ã€‚å…·ä½“çš„ãªã‚¯ãƒ©ã‚¹ã¯å¤šæ§˜ã§ã™ã€‚ã‚‚ã—èª­ã¿å–ã‚Šå°‚ç”¨ã®ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã ã£ãŸå ´åˆã¯ :class:`BufferedReader` ãŒè¿”ã•ã‚Œã¾ã™ã€‚æ›¸ãè¾¼ã¿å°‚ç”¨ã®ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã ã£ãŸå ´åˆã¯ :class:`BufferedWriter` ãŒè¿”ã•ã‚Œã¾ã™ã€‚èª­ã¿æ›¸ãå¯èƒ½ãªãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯ :class:`BufferedRandom` ãŒè¿”ã•ã‚Œã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ãŒç„¡åŠ¹ãªå ´åˆã€raw ã‚¹ãƒˆãƒªãƒ¼ãƒ ã€ :class:`RawIOBase` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã€ :class:`FileIO` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:181
msgid ""
"It is also possible to use an :class:`unicode` or :class:`bytes` string as a"
" file for both reading and writing.  For :class:`unicode` strings "
":class:`~io.StringIO` can be used like a file opened in text mode, and for "
":class:`bytes` a :class:`BytesIO` can be used like a file opened in a binary"
" mode."
msgstr ":class:`unicode` æ–‡å­—åˆ—ã‚„ :class:`bytes` æ–‡å­—åˆ—ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦èª­ã¿æ›¸ãã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚ :class:`unicode` æ–‡å­—åˆ—ã§ã¯ :class:`~io.StringIO` ã‚’ä½¿ãˆã°ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§é–‹ã„ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚ˆã†ã«æ‰±ãˆã¾ã™ã€‚ :class:`bytes` ã§ã¯ :class:`BytesIO` ã‚’ä½¿ãˆã°ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§é–‹ã„ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚ˆã†ã«æ‰±ãˆã¾ã™ã€‚"

#: ../../library/io.rst:190
msgid ""
"Error raised when blocking would occur on a non-blocking stream.  It "
"inherits :exc:`IOError`."
msgstr "éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ãƒ–ãƒ­ãƒƒã‚¯å‡¦ç†ãŒèµ·ããŸå ´åˆã«ç™ºç”Ÿã™ã‚‹ã‚¨ãƒ©ãƒ¼ã§ã™ã€‚ :exc:`IOError` ã‚’ç¶™æ‰¿ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/io.rst:193
msgid ""
"In addition to those of :exc:`IOError`, :exc:`BlockingIOError` has one "
"attribute:"
msgstr ":exc:`IOError` ã§æŒã£ã¦ã„ã‚‹å±æ€§ä»¥å¤–ã« :exc:`BlockingIOError` ã§ã¯æ¬¡ã®å±æ€§ã‚’æŒã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/io.rst:198
msgid ""
"An integer containing the number of characters written to the stream before "
"it blocked."
msgstr "ãƒ–ãƒ­ãƒƒã‚¯å‰ã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«æ›¸ãè¾¼ã¾ã‚Œã‚‹æ–‡å­—æ•°ã‚’ä¿æŒã™ã‚‹æ•´æ•°å€¤ã§ã™ã€‚"

#: ../../library/io.rst:204
msgid ""
"An exception inheriting :exc:`IOError` and :exc:`ValueError` that is raised "
"when an unsupported operation is called on a stream."
msgstr ":exc:`IOError` ã¨ :exc:`ValueError` ã‚’ç¶™æ‰¿ã—ãŸä¾‹å¤–ã§ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«æœªã‚µãƒãƒ¼ãƒˆã®æ“ä½œãŒè¡Œã‚ã‚ŒãŸå ´åˆã«ç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/io.rst:209
msgid "I/O Base Classes"
msgstr "I/O åŸºåº•ã‚¯ãƒ©ã‚¹"

#: ../../library/io.rst:213
msgid ""
"The abstract base class for all I/O classes, acting on streams of bytes. "
"There is no public constructor."
msgstr "ã™ã¹ã¦ã® I/O ã‚¯ãƒ©ã‚¹ã®æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ãƒã‚¤ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã¸ã®æ“ä½œã‚’è¡Œã„ã¾ã™ã€‚ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:216
msgid ""
"This class provides empty abstract implementations for many methods that "
"derived classes can override selectively; the default implementations "
"represent a file that cannot be read, written or seeked."
msgstr "ç¶™æ‰¿å…ˆã®ã‚¯ãƒ©ã‚¹ãŒé¸æŠçš„ã«ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã§ãã‚‹ã‚ˆã†ã«ã€ã“ã®ã‚¯ãƒ©ã‚¹ã¯å¤šãã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ç©ºã®æŠ½è±¡å®Ÿè£…ã‚’ã—ã¦ã„ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè£…ã§ã¯ã€èª­ã¿è¾¼ã¿ã€æ›¸ãè¾¼ã¿ã€ã‚·ãƒ¼ã‚¯ãŒã§ããªã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¡¨ç¾ã—ã¾ã™ã€‚"

#: ../../library/io.rst:221
msgid ""
"Even though :class:`IOBase` does not declare :meth:`read`, :meth:`readinto`,"
" or :meth:`write` because their signatures will vary, implementations and "
"clients should consider those methods part of the interface.  Also, "
"implementations may raise an :exc:`IOError` when operations they do not "
"support are called."
msgstr ":class:`IOBase` ã§ã¯ :meth:`read`, :meth:`readinto`, :meth:`write` ãŒå®£è¨€ã•ã‚Œã¦ã„ã¾ã›ã‚“ãŒã€ã“ã‚Œã¯ã‚·ã‚°ãƒŠãƒãƒ£ãŒå¤‰åŒ–ã™ã‚‹ãŸã‚ã§ã€å®Ÿè£…ã‚„ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã®ä¸€éƒ¨ã¨ã—ã¦è€ƒãˆã‚‹ã¹ãã§ã™ã€‚ã¾ãŸã€å®Ÿè£…ã¯ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„æ“ä½œã‚’å‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã¯ :exc:`IOError` ã‚’ç™ºç”Ÿã•ã›ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:227
msgid ""
"The basic type used for binary data read from or written to a file is "
":class:`bytes` (also known as :class:`str`).  Method arguments may also be "
":class:`bytearray` or :class:`memoryview` of arrays of bytes. In some cases,"
" such as :meth:`~RawIOBase.readinto`, a writable object such as "
":class:`bytearray` is required. Text I/O classes work with :class:`unicode` "
"data."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã®èª­ã¿æ›¸ãã«ç”¨ã„ã‚‰ã‚Œã‚‹åŸºæœ¬å‹ã¯ (:class:`str` ã¨ã—ã¦ã‚‚çŸ¥ã‚‰ã‚Œã‚‹) :class:`bytes` ã§ã™ã€‚\nãƒ¡ã‚½ãƒƒãƒ‰ã®å¼•æ•°ã«ã‚ˆã£ã¦ã¯ :class:`bytearray` ã‚„ bytes é…åˆ—ã® :class:`memoryview` ã®ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚\n:meth:`~RawIOBase.readinto` ãªã©ã®ã‚±ãƒ¼ã‚¹ã§ã¯ã€ :class:`bytearray` ã®ã‚ˆã†ãªæ›¸ãè¾¼ã¿å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¿…è¦ã§ã™ã€‚\nãƒ†ã‚­ã‚¹ãƒˆ I/O ã‚¯ãƒ©ã‚¹ã¯ :class:`unicode` ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã„ã¾ã™ã€‚"

#: ../../library/io.rst:234
msgid "Implementations should support :class:`memoryview` arguments."
msgstr "å®Ÿè£…ã¯ :class:`memoryview` å¼•æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:237
msgid ""
"Note that calling any method (even inquiries) on a closed stream is "
"undefined.  Implementations may raise :exc:`IOError` in this case."
msgstr "é–‰ã˜ã‚‰ã‚ŒãŸã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—ã¯ (å•ã„åˆã‚ã›ã§ã‚ã£ã¦ã‚‚) æœªå®šç¾©ã§ã™ã€‚ã“ã®å ´åˆã€å®Ÿè£…ã¯ :exc:`IOError` ã‚’ç™ºç”Ÿã•ã›ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:240
msgid ""
"IOBase (and its subclasses) support the iterator protocol, meaning that an "
":class:`IOBase` object can be iterated over yielding the lines in a stream. "
"Lines are defined slightly differently depending on whether the stream is a "
"binary stream (yielding :class:`bytes`), or a text stream (yielding "
":class:`unicode` strings).  See :meth:`~IOBase.readline` below."
msgstr ":class:`IOBase` (ã¨ãã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹) ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ :class:`IOBase` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã¨ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®è¡ŒãŒ yield ã•ã‚Œã¾ã™ã€‚è¡Œã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒ (:class:`bytes` ã‚’ä¸ãˆã‚‹) ãƒã‚¤ãƒŠãƒªã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ (:class:`unicode` æ–‡å­—åˆ—ã‚’ä¸ãˆã‚‹) ãƒ†ã‚­ã‚¹ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã«ã‚ˆã£ã¦ã€ å°‘ã—é•ã†å®šç¾©ãŒã•ã‚Œã¦ã„ã¾ã™ã€‚ä¸‹ã® :meth:`~IOBase.readline` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/io.rst:246
msgid ""
"IOBase is also a context manager and therefore supports the :keyword:`with` "
"statement.  In this example, *file* is closed after the :keyword:`with` "
"statement's suite is finished---even if an exception occurs::"
msgstr "IOBase ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã§ã‚‚ã‚ã‚Šã¾ã™ã€‚ãã®ãŸã‚ :keyword:`with` æ§‹æ–‡ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚æ¬¡ã®ä¾‹ã§ã¯ã€ :keyword:`with` æ§‹æ–‡ãŒçµ‚ã‚ã£ãŸå¾Œã§---ãŸã¨ãˆä¾‹å¤–ãŒç™ºç”Ÿã—ãŸå ´åˆã§ã‚‚ã€ *file* ã¯é–‰ã˜ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:253
msgid ":class:`IOBase` provides these data attributes and methods:"
msgstr ":class:`IOBase` ã¯ä»¥ä¸‹ã®ãƒ‡ãƒ¼ã‚¿å±æ€§ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¾ã™:"

#: ../../library/io.rst:257
msgid ""
"Flush and close this stream. This method has no effect if the file is "
"already closed. Once the file is closed, any operation on the file (e.g. "
"reading or writing) will raise a :exc:`ValueError`."
msgstr "ã“ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã—ã¦é–‰ã˜ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ—¢ã«é–‰ã˜ã‚‰ã‚Œã¦ã„ãŸå ´åˆã¯ç‰¹ã«ä½•ã®åŠ¹æœã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚ã„ã£ãŸã‚“ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‰ã˜ã‚‰ã‚Œã‚‹ã¨ã€ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã™ã‚‹æ“ä½œ (ä¾‹ãˆã°èª­ã¿è¾¼ã¿ã‚„æ›¸ãè¾¼ã¿) ã§ :exc:`ValueError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/io.rst:261
msgid ""
"As a convenience, it is allowed to call this method more than once; only the"
" first call, however, will have an effect."
msgstr "åˆ©ä¾¿æ€§ã®ãŸã‚ã«ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¤‡æ•°å›å‘¼ã¶ã“ã¨ã¯è¨±ã•ã‚Œã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€åŠ¹æœãŒã‚ã‚‹ã®ã¯æœ€åˆã®1å›ã ã‘ã§ã™ã€‚"

#: ../../library/io.rst:266
msgid "True if the stream is closed."
msgstr "ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ãŸå ´åˆ True ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:270
msgid ""
"Return the underlying file descriptor (an integer) of the stream if it "
"exists.  An :exc:`IOError` is raised if the IO object does not use a file "
"descriptor."
msgstr "ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒä¿æŒã—ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ (æ•´æ•°å€¤) ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ãã‚Œã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã— IO ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’ä½¿ã£ã¦ã„ãªã„å ´åˆã¯ :exc:`IOError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/io.rst:276
msgid ""
"Flush the write buffers of the stream if applicable.  This does nothing for "
"read-only and non-blocking streams."
msgstr "é©ç”¨å¯èƒ½ã§ã‚ã‚Œã°ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æ›¸ãè¾¼ã¿ãƒãƒƒãƒ•ã‚¡ã‚’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã—ã¾ã™ã€‚èª­ã¿è¾¼ã¿å°‚ç”¨ã‚„éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:281
msgid ""
"Return ``True`` if the stream is interactive (i.e., connected to a "
"terminal/tty device)."
msgstr "ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒå¯¾è©±çš„ã§ã‚ã‚Œã° (ã¤ã¾ã‚Šã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚„ tty ãƒ‡ãƒã‚¤ã‚¹ã«ã¤ãªãŒã£ã¦ã„ã‚‹å ´åˆ) ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/io.rst:286
msgid ""
"Return ``True`` if the stream can be read from.  If ``False``, :meth:`read` "
"will raise :exc:`IOError`."
msgstr "ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒèª­ã¿è¾¼ã‚ã‚‹å ´åˆ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ ``False`` ã®å ´åˆã¯ :meth:`read` ã¯ :exc:`IOError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/io.rst:291
msgid ""
"Read and return one line from the stream.  If *limit* is specified, at most "
"*limit* bytes will be read."
msgstr "ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰ 1 è¡Œèª­ã¿è¾¼ã‚“ã§è¿”ã—ã¾ã™ã€‚ã‚‚ã— *limit* ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã€æœ€å¤§ã§ *limit* ãƒã‚¤ãƒˆãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:294
msgid ""
"The line terminator is always ``b'\\n'`` for binary files; for text files, "
"the *newline* argument to :func:`.open` can be used to select the line "
"terminator(s) recognized."
msgstr "ãƒã‚¤ãƒŠãƒªãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯è¡Œæœ«æ–‡å­—ã¯å¸¸ã« ``b'\\n'`` ã¨ãªã‚Šã¾ã™ã€‚ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ã€èªè­˜ã•ã‚Œã‚‹è¡Œæœ«æ–‡å­—ã‚’é¸æŠã™ã‚‹ãŸã‚ã« :func:`.open` ã«å¯¾ã™ã‚‹ *newline* å¼•æ•°ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:300
msgid ""
"Read and return a list of lines from the stream.  *hint* can be specified to"
" control the number of lines read: no more lines will be read if the total "
"size (in bytes/characters) of all lines so far exceeds *hint*."
msgstr "ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰è¡Œã®ãƒªã‚¹ãƒˆã‚’èª­ã¿è¾¼ã‚“ã§è¿”ã—ã¾ã™ã€‚ *hint* ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ã€èª­ã¿è¾¼ã‚€è¡Œæ•°ã‚’åˆ¶å¾¡ã§ãã¾ã™ã€‚ã‚‚ã—èª­ã¿è¾¼ã‚“ã ã™ã¹ã¦ã®è¡Œã®ã‚µã‚¤ã‚º (ãƒã‚¤ãƒˆæ•°ã€ã‚‚ã—ãã¯æ–‡å­—æ•°) ãŒ *hint* ã®å€¤ã‚’è¶…ãˆãŸå ´åˆã€èª­ã¿è¾¼ã¿ã‚’ãã“ã§çµ‚äº†ã—ã¾ã™ã€‚"

#: ../../library/io.rst:304
msgid ""
"Note that it's already possible to iterate on file objects using ``for line "
"in file: ...`` without calling ``file.readlines()``."
msgstr "``file.readlines()`` ã‚’å‘¼ã³ã ã•ãªãã¦ã‚‚ ``for line in file: ...`` ã®ã‚ˆã†ã«ã€file ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç›´æ¥ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/io.rst:309
msgid ""
"Change the stream position to the given byte *offset*.  *offset* is "
"interpreted relative to the position indicated by *whence*.  The default "
"value for *whence* is :data:`SEEK_SET`.  Values for *whence* are:"
msgstr "ã‚¹ãƒˆãƒªãƒ¼ãƒ ä½ç½®ã‚’æŒ‡å®šã•ã‚ŒãŸ *offset* ãƒã‚¤ãƒˆã«å¤‰æ›´ã—ã¾ã™ã€‚*offset* ã¯ *whence* ã§æŒ‡å®šã•ã‚ŒãŸä½ç½®ã‹ã‚‰ã®ç›¸å¯¾ä½ç½®ã¨ã—ã¦è§£é‡ˆã•ã‚Œã¾ã™ã€‚ *whence* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ :data:`SEEK_SET` ã§ã™ã€‚ *whence* ã«æŒ‡å®šã§ãã‚‹å€¤ã¯:"

#: ../../library/io.rst:313
msgid ""
":data:`SEEK_SET` or ``0`` -- start of the stream (the default); *offset* "
"should be zero or positive"
msgstr ":data:`SEEK_SET` ã¾ãŸã¯ ``0`` -- ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å…ˆé ­ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)ã€‚ *offset* ã¯ 0 ã‚‚ã—ãã¯æ­£ã®å€¤ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:315
msgid ""
":data:`SEEK_CUR` or ``1`` -- current stream position; *offset* may be "
"negative"
msgstr ":data:`SEEK_CUR` ã¾ãŸã¯ ``1`` -- ç¾åœ¨ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ä½ç½®ã€‚ *offset* ã¯è² ã®å€¤ã‚‚å¯èƒ½ã§ã™ã€‚"

#: ../../library/io.rst:317
msgid ""
":data:`SEEK_END` or ``2`` -- end of the stream; *offset* is usually negative"
msgstr ":data:`SEEK_END` ã¾ãŸã¯ ``2`` -- ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æœ«å°¾ã€‚ *offset* ã¯é€šå¸¸è² ã®å€¤ã§ã™ã€‚"

#: ../../library/io.rst:320
msgid "Return the new absolute position."
msgstr "æ–°ã—ã„çµ¶å¯¾ä½ç½®ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/io.rst:322
msgid "The ``SEEK_*`` constants"
msgstr "``SEEK_*`` å®šæ•°"

#: ../../library/io.rst:327
msgid ""
"Return ``True`` if the stream supports random access.  If ``False``, "
":meth:`seek`, :meth:`tell` and :meth:`truncate` will raise :exc:`IOError`."
msgstr "ã‚‚ã—ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒãƒ©ãƒ³ãƒ€ãƒ ã‚¢ã‚¯ã‚»ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãŸå ´åˆ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ ``False`` ã®å ´åˆã¯ :meth:`seek`\\ ã€ :meth:`tell`\\ ã€ :meth:`truncate` ã¯ :exc:`IOError` ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚"

#: ../../library/io.rst:332
msgid "Return the current stream position."
msgstr "ç¾åœ¨ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ä½ç½®ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/io.rst:336
msgid ""
"Resize the stream to the given *size* in bytes (or the current position if "
"*size* is not specified).  The current stream position isn't changed. This "
"resizing can extend or reduce the current file size.  In case of extension, "
"the contents of the new file area depend on the platform (on most systems, "
"additional bytes are zero-filled, on Windows they're undetermined).  The new"
" file size is returned."
msgstr "æŒ‡å®šã•ã‚ŒãŸ *size* ãƒã‚¤ãƒˆ (ã¾ãŸã¯ *size* ãŒæŒ‡å®šã•ã‚Œãªã‘ã‚Œã°ç¾åœ¨ã®ä½ç½®) ã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ãƒªã‚µã‚¤ã‚ºã—ã¾ã™ã€‚ç¾åœ¨ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ä½ç½®ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚ã“ã®ãƒªã‚µã‚¤ã‚ºã¯ã€ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’æ‹¡å¤§ã¾ãŸã¯ç¸®å°ã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ‹¡å¤§ã®å ´åˆã«ã¯ã€æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«é ˜åŸŸã®å†…å®¹ã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ›ãƒ¼ãƒ ã«ä¾å­˜ã—ã¾ã™ (ã»ã¨ã‚“ã©ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€è¿½åŠ ã®ãƒã‚¤ãƒˆãŒ 0 ã§åŸ‹ã‚ã‚‰ã‚Œã¾ã™ã€‚ Windowsã§ã¯ä¸å®šã§ã™)ã€‚æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:345
msgid ""
"Return ``True`` if the stream supports writing.  If ``False``, :meth:`write`"
" and :meth:`truncate` will raise :exc:`IOError`."
msgstr "ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒæ›¸ãè¾¼ã¿ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹å ´åˆ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ ``False`` ã®å ´åˆã¯ :meth:`write`\\ ã€ :meth:`truncate` ã¯ :exc:`IOError` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/io.rst:350
msgid ""
"Write a list of lines to the stream.  Line separators are not added, so it "
"is usual for each of the lines provided to have a line separator at the end."
msgstr "ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«è¤‡æ•°è¡Œæ›¸ãè¾¼ã¿ã¾ã™ã€‚è¡ŒåŒºåˆ‡ã‚Šæ–‡å­—ã¯ä»˜ä¸ã•ã‚Œãªã„ã®ã§ã€é€šå¸¸æ›¸ãè¾¼ã‚€å„è¡Œã®è¡Œæœ«ã«ã¯è¡ŒåŒºåˆ‡ã‚Šæ–‡å­—ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:356
msgid ""
"Prepare for object destruction. :class:`IOBase` provides a default "
"implementation of this method that calls the instance's "
":meth:`~IOBase.close` method."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç ´å£Šã®ç”¨æ„ã‚’ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® :meth:`~IOBase.close` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³ã¾ã™ã€‚ :class:`IOBase` ã¯ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè£…ã‚’æä¾›ã—ã¾ã™"

#: ../../library/io.rst:363
msgid ""
"Base class for raw binary I/O.  It inherits :class:`IOBase`.  There is no "
"public constructor."
msgstr "ç”Ÿã®ãƒã‚¤ãƒŠãƒª I/O ã¸ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ :class:`IOBase` ã‚’ç¶™æ‰¿ã—ã¦ã„ã¾ã™ã€‚ãƒ‘ãƒ–ãƒªãƒƒã‚¯ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:366
msgid ""
"Raw binary I/O typically provides low-level access to an underlying OS "
"device or API, and does not try to encapsulate it in high-level primitives "
"(this is left to Buffered I/O and Text I/O, described later in this page)."
msgstr "ç”Ÿã®ãƒã‚¤ãƒŠãƒª I/O ã¯å…¸å‹çš„ã«ã€ä¸‹ã«ã‚ã‚‹ OS ãƒ‡ãƒã‚¤ã‚¹ã‚„ API ã¸ã®ã€ä½ãƒ¬ãƒ™ãƒ«ãªã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›ã—ã€é«˜ãƒ¬ãƒ™ãƒ«ãªåŸºæœ¬è¦ç´ ã¸ã¨ã‚«ãƒ—ã‚»ãƒ«åŒ–ã—ã‚ˆã†ã¨ã¯ã—ã¾ã›ã‚“ (ã“ã‚Œã¯ã“ã®ãƒšãƒ¼ã‚¸ã§å¾Œè¿°ã™ã‚‹ Buffered I/O ã‚„ Text I/O ã«ä»»ã›ã¾ã™)ã€‚"

#: ../../library/io.rst:370
msgid ""
"In addition to the attributes and methods from :class:`IOBase`, RawIOBase "
"provides the following methods:"
msgstr ":class:`IOBase` ã®å±æ€§ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã«åŠ ãˆã¦ã€ RawIOBase ã¯æ¬¡ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¾ã™ï¼š"

#: ../../library/io.rst:375
msgid ""
"Read up to *n* bytes from the object and return them.  As a convenience, if "
"*n* is unspecified or -1, :meth:`readall` is called.  Otherwise, only one "
"system call is ever made.  Fewer than *n* bytes may be returned if the "
"operating system call returns fewer than *n* bytes."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ *n* ãƒã‚¤ãƒˆã¾ã§èª­ã¿è¾¼ã¿ã€ãã‚Œã‚’è¿”ã—ã¾ã™ã€‚ç°¡å˜ã®ãŸã‚ã€ *n* ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ã‹ -1 ãªã‚‰ã€ :meth:`readall` ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«å‘¼ã³å‡ºã—ãŒä¸€åº¦ã ã‘è¡Œã‚ã‚Œã¾ã™ã€‚æ—¢ã« EOF ã«é”ã—ã¦ã„ãŸã‚‰ç©ºã®ãƒã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¿”ã•ã‚Œã¾ã™ã€‚ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ãŒè¿”ã—ãŸã‚‚ã®ãŒãŒ *n* ãƒã‚¤ãƒˆã‚ˆã‚Šå°‘ãªã‘ã‚Œã°ã€ *n* ãƒã‚¤ãƒˆã‚ˆã‚Šå°‘ãªãè¿”ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:380
msgid ""
"If 0 bytes are returned, and *n* was not 0, this indicates end of file. If "
"the object is in non-blocking mode and no bytes are available, ``None`` is "
"returned."
msgstr "0 ãƒã‚¤ãƒˆãŒè¿”ã£ã¦ã€ *n* ãŒ 0 ã§ãªã‘ã‚Œã°ã€ãã‚Œã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®çµ‚ç«¯ã‚’è¡¨ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã€ 1 ãƒã‚¤ãƒˆã‚‚èª­ã¿è¾¼ã‚ãªã‘ã‚Œã°ã€ ``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:386
msgid ""
"Read and return all the bytes from the stream until EOF, using multiple "
"calls to the stream if necessary."
msgstr "EOF ã¾ã§ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰ã™ã¹ã¦ã®ãƒã‚¤ãƒˆã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚å¿…è¦ãªå ´åˆã¯ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ã¦è¤‡æ•°ã®å‘¼ã³å‡ºã—ã‚’ã—ã¾ã™ã€‚"

#: ../../library/io.rst:391
msgid ""
"Read up to len(b) bytes into *b*, and return the number of bytes read.  The "
"object *b* should be a pre-allocated, writable array of bytes, either "
":class:`bytearray` or :class:`memoryview`. If the object is in non-blocking "
"mode and no bytes are available, ``None`` is returned."
msgstr "*b* ã«æœ€å¤§ len(b) ãƒã‚¤ãƒˆåˆ†èª­ã¿è¾¼ã¿ã€èª­ã¿è¾¼ã‚“ã ãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ã€‚\nã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *b* ã¯ãƒ¡ãƒ¢ãƒªç¢ºä¿æ¸ˆã¿ã®æ›¸ãè¾¼ã¿å¯èƒ½ãªãƒã‚¤ãƒˆé…åˆ—ã€ :class:`bytearray` ã‚‚ã—ãã¯ :class:`memoryview` ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\nã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã€ 1 ãƒã‚¤ãƒˆã‚‚èª­ã¿è¾¼ã‚ãªã‘ã‚Œã°ã€ ``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:399
msgid ""
"Write *b* to the underlying raw stream, and return the number of bytes "
"written.  The object *b* should be an array of bytes, either :class:`bytes`,"
" :class:`bytearray`, or :class:`memoryview`.  The return value can be less "
"than ``len(b)``, depending on specifics of the underlying raw stream, and "
"especially if it is in non-blocking mode.  ``None`` is returned if the raw "
"stream is set not to block and no single byte could be readily written to "
"it.  The caller may release or mutate *b* after this method returns, so the "
"implementation should only access *b* during the method call."
msgstr "*b* ã‚’ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ã«æ›¸ãè¾¼ã¿ã€æ›¸ãè¾¼ã‚“ã ãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ã€‚\nã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *b* ã¯ãƒã‚¤ãƒˆé…åˆ—ã€:class:`bytes` ã€ :class:`bytearray` ã€ :class:`memoryview` ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\nè¿”ã‚Šå€¤ã¯ã€æ ¹åº•ã®ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æ€§è³ªã«ã‚ˆã£ã¦ã€ç‰¹ã«ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã‚ã‚‹å ´åˆã«ã€ ``len(b)`` ã‚ˆã‚Šå°ã•ããªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚\nç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œãªã„ã‚ˆã†ã«è¨­å®šã•ã‚Œã¦ã„ã¦ã€ã‹ã¤1ãƒã‚¤ãƒˆã‚‚å³åº§ã«æ›¸ãè¾¼ã‚€ã“ã¨ãŒã§ããªã„å ´åˆã¯ã€ ``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚\nã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰è¿”ã£ãŸå¾Œã§å‘¼ã³å‡ºã—å…ƒã¯ *b* ã‚’è§£æ”¾ã—ãŸã‚Šå¤‰æ›´ã—ãŸã‚Šã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã€å®Ÿè£…ã¯ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—ã®é–“ã ã‘ *b* ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã¹ãã§ã™ã€‚"

#: ../../library/io.rst:413
msgid ""
"Base class for binary streams that support some kind of buffering. It "
"inherits :class:`IOBase`. There is no public constructor."
msgstr "ä½•ã‚‰ã‹ã®ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãƒã‚¤ãƒŠãƒªã‚¹ãƒˆãƒªãƒ¼ãƒ ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ :class:`IOBase` ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:416
msgid ""
"The main difference with :class:`RawIOBase` is that methods :meth:`read`, "
":meth:`readinto` and :meth:`write` will try (respectively) to read as much "
"input as requested or to consume all given output, at the expense of making "
"perhaps more than one system call."
msgstr ":class:`RawIOBase` ã¨ã®ä¸»ãªé•ã„ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ :meth:`read`ã€ :meth:`readinto` ãŠã‚ˆã³ :meth:`write` ã¯ ã€ã“ã¨ã«ã‚ˆã‚‹ã¨è¤‡æ•°å›ã®ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’è¡Œã£ã¦ã€(ãã‚Œãã‚Œ) è¦æ±‚ã•ã‚ŒãŸã ã‘ã®å…¥åŠ›ã‚’èª­ã¿è¾¼ã‚‚ã†ã¨ã—ãŸã‚Šä¸ãˆã‚‰ã‚ŒãŸå‡ºåŠ›ã®å…¨ã¦ã‚’æ¶ˆè²»ã—ã‚ˆã†ã¨ã—ãŸã‚Šã™ã‚‹ç‚¹ã§ã™ã€‚"

#: ../../library/io.rst:421
msgid ""
"In addition, those methods can raise :exc:`BlockingIOError` if the "
"underlying raw stream is in non-blocking mode and cannot take or give enough"
" data; unlike their :class:`RawIOBase` counterparts, they will never return "
"``None``."
msgstr "åŠ ãˆã¦ã€å…ƒã«ãªã‚‹ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒéãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã‹ã¤æº–å‚™ãŒã§ãã¦ã„ãªã„å ´åˆã«ã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ :exc:`BlockingIOError` ã‚’é€å‡ºã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚å¯¾å¿œã™ã‚‹ :class:`RawIOBase` ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨é•ã£ã¦ã€ ``None`` ã‚’è¿”ã™ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:426
msgid ""
"Besides, the :meth:`read` method does not have a default implementation that"
" defers to :meth:`readinto`."
msgstr "ã•ã‚‰ã«ã€ :meth:`read` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ :meth:`readinto` ã«å¾“ã†ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã‚’æŒã¡ã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:429
msgid ""
"A typical :class:`BufferedIOBase` implementation should not inherit from a "
":class:`RawIOBase` implementation, but wrap one, like "
":class:`BufferedWriter` and :class:`BufferedReader` do."
msgstr "é€šå¸¸ã® :class:`BufferedIOBase` å®Ÿè£…ã¯ :class:`RawIOBase` å®Ÿè£…ã‚’ç¶™æ‰¿ã›ãšã«ã€ :class:`BufferedWriter` ã¨ :class:`BufferedReader` ãŒã™ã‚‹ã‚ˆã†ã«ã“ã‚Œã‚’ãƒ©ãƒƒãƒ—ã™ã¹ãã§ã™ã€‚"

#: ../../library/io.rst:433
msgid ""
":class:`BufferedIOBase` provides or overrides these methods and attribute in"
" addition to those from :class:`IOBase`:"
msgstr ":class:`BufferedIOBase` ã¯ :class:`IOBase` ã‹ã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨å±æ€§ã«åŠ ãˆã¦ã€ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã‚‚ã—ãã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¾ã™:"

#: ../../library/io.rst:438
msgid ""
"The underlying raw stream (a :class:`RawIOBase` instance) that "
":class:`BufferedIOBase` deals with.  This is not part of the "
":class:`BufferedIOBase` API and may not exist on some implementations."
msgstr ":class:`BufferedIOBase` ãŒæ‰±ã†æ ¹åº•ã®ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ  (:class:`RawIOBase` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹) ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯ :class:`BufferedIOBase` API ã«ã¯å«ã¾ã‚Œãšã€ã‚ˆã£ã¦å®Ÿè£…ã«å«ã¾ã‚Œãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:444
msgid "Separate the underlying raw stream from the buffer and return it."
msgstr "æ ¹åº•ã®ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ãƒãƒƒãƒ•ã‚¡ã‹ã‚‰åˆ†é›¢ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/io.rst:446
msgid ""
"After the raw stream has been detached, the buffer is in an unusable state."
msgstr "ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒå–ã‚Šå¤–ã•ã‚ŒãŸå¾Œã€ãƒãƒƒãƒ•ã‚¡ã¯ä½¿ç”¨ä¸èƒ½çŠ¶æ…‹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:449
msgid ""
"Some buffers, like :class:`BytesIO`, do not have the concept of a single raw"
" stream to return from this method.  They raise :exc:`UnsupportedOperation`."
msgstr "ãƒãƒƒãƒ•ã‚¡ã«ã¯ã€ :class:`BytesIO` ãªã©ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§è¿”ã•ã‚Œã‚‹å˜ä½“ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã„ã†æ¦‚å¿µã‚’æŒãŸãªã„ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã¯ :exc:`UnsupportedOperation` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/io.rst:457
msgid ""
"Read and return up to *n* bytes.  If the argument is omitted, ``None``, or "
"negative, data is read and returned until EOF is reached.  An empty bytes "
"object is returned if the stream is already at EOF."
msgstr "æœ€å¤§ã§ *n* ãƒã‚¤ãƒˆèª­ã¿è¾¼ã¿ã€è¿”ã—ã¾ã™ã€‚å¼•æ•°ãŒçœç•¥ã•ã‚Œã‚‹ã‹ã€ ``None`` ã‹ã€ã¾ãŸã¯è² ã®å€¤ã§ã‚ã£ãŸå ´åˆã€ãƒ‡ãƒ¼ã‚¿ã¯ EOF ã«åˆ°é”ã™ã‚‹ã¾ã§èª­ã¿è¾¼ã¾ã‚Œã¾ã™ã€‚ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒæ—¢ã« EOF ã«åˆ°é”ã—ã¦ã„ãŸå ´åˆã¯ç©ºã® bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:461
msgid ""
"If the argument is positive, and the underlying raw stream is not "
"interactive, multiple raw reads may be issued to satisfy the byte count "
"(unless EOF is reached first).  But for interactive raw streams, at most one"
" raw read will be issued, and a short result does not imply that EOF is "
"imminent."
msgstr "å¼•æ•°ãŒæ­£ã§ã€å…ƒã«ãªã‚‹ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒå¯¾è©±çš„ã§ãªã‘ã‚Œã°ã€å¿…è¦ãªãƒã‚¤ãƒˆæ•°ã‚’æº€ãŸã™ã‚ˆã†ã«è¤‡æ•°å›ã®ç”Ÿ read ãŒç™ºè¡Œã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ (å…ˆã« EOF ã«åˆ°é”ã—ãªã„é™ã‚Šã¯)ã€‚å¯¾è©±çš„ãªå ´åˆã¯ã€æœ€å¤§ã§ä¸€å›ã® raw read ã—ã‹ç™ºè¡Œã•ã‚Œãšã€çŸ­ã„çµæœã§ã‚‚ EOF ã«é”ã—ãŸã“ã¨ã‚’æ„å‘³ã—ã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:467 ../../library/io.rst:486
msgid ""
"A :exc:`BlockingIOError` is raised if the underlying raw stream is in non "
"blocking-mode, and has no data available at the moment."
msgstr "å…ƒã«ãªã‚‹ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã€å‘¼ã³å‡ºã•ã‚ŒãŸæ™‚ç‚¹ã§ãƒ‡ãƒ¼ã‚¿ã‚’æŒã£ã¦ã„ãªã‘ã‚Œã°ã€ :exc:`BlockingIOError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:472
msgid ""
"Read and return up to *n* bytes, with at most one call to the underlying raw"
" stream's :meth:`~RawIOBase.read` method.  This can be useful if you are "
"implementing your own buffering on top of a :class:`BufferedIOBase` object."
msgstr "æ ¹åº•ã®ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ã® :meth:`~RawIOBase.read` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’é«˜ã€… 1 å›å‘¼ã³å‡ºã—ã€æœ€å¤§ã§ *n* ãƒã‚¤ãƒˆèª­ã¿è¾¼ã¿ã€è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ :class:`BufferedIOBase` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸Šã«ç‹¬è‡ªã®ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã‚’å®Ÿè£…ã™ã‚‹ã¨ãã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../library/io.rst:479
msgid ""
"Read up to len(b) bytes into *b*, and return the number of bytes read. The "
"object *b* should be a pre-allocated, writable array of bytes, either "
":class:`bytearray` or :class:`memoryview`."
msgstr "*b* ã«æœ€å¤§ len(b) ãƒã‚¤ãƒˆåˆ†èª­ã¿è¾¼ã¿ã€èª­ã¿è¾¼ã‚“ã ãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ã€‚\nã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *b* ã¯ãƒ¡ãƒ¢ãƒªç¢ºä¿æ¸ˆã¿ã®æ›¸ãè¾¼ã¿å¯èƒ½ãªãƒã‚¤ãƒˆé…åˆ—ã€ :class:`bytearray` ã‚‚ã—ãã¯ :class:`memoryview` ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:483
msgid ""
"Like :meth:`read`, multiple reads may be issued to the underlying raw "
"stream, unless the latter is 'interactive'."
msgstr ":meth:`read` ã¨åŒæ§˜ã€å…ƒã«ãªã‚‹ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒ 'å¯¾è©±çš„' ã§ãªã„é™ã‚Šã€è¤‡æ•°å›ã® read ãŒç™ºè¡Œã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:491
msgid ""
"Write *b*, and return the number of bytes written (always equal to "
"``len(b)``, since if the write fails an :exc:`IOError` will be raised).  The"
" object *b* should be an array of bytes, either :class:`bytes`, "
":class:`bytearray`, or :class:`memoryview`.  Depending on the actual "
"implementation, these bytes may be readily written to the underlying stream,"
" or held in a buffer for performance and latency reasons."
msgstr "*b* ã‚’æ›¸ãè¾¼ã¿ã€æ›¸ãè¾¼ã‚“ã ãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ (ã“ã‚Œã¯å¸¸ã« ``len(b)`` ã¨ç­‰ã—ã„ã§ã™ã€‚ãªãœãªã‚‰ã€ã‚‚ã—æ›¸ãè¾¼ã¿ã«å¤±æ•—ã—ãŸå ´åˆã¯ :exc:`IOError` ãŒç™ºç”Ÿã™ã‚‹ã‹ã‚‰ã§ã™)ã€‚\nã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *b* ã¯ãƒã‚¤ãƒˆé…åˆ—ã€:class:`bytes` ã€ :class:`bytearray` ã€ :class:`memoryview` ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\nå®Ÿéš›ã®å®Ÿè£…ã«ä¾ã£ã¦ã€ã“ã‚Œã‚‰ã®ãƒã‚¤ãƒˆã¯æ ¹åº•ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«èª­ã‚ã‚‹ã‚ˆã†ã«æ›¸ãã“ã¾ã‚ŒãŸã‚Šã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¨ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ã®ç†ç”±ã§ãƒãƒƒãƒ•ã‚¡ã«ä¿æŒã•ã‚ŒãŸã‚Šã—ã¾ã™ã€‚"

#: ../../library/io.rst:499
msgid ""
"When in non-blocking mode, a :exc:`BlockingIOError` is raised if the data "
"needed to be written to the raw stream but it couldn't accept all the data "
"without blocking."
msgstr "ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã‚ã‚‹ã¨ãã€ãƒãƒƒãƒ•ã‚¡ãŒæº€æ¯ã§æ ¹åº•ã®ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒæ›¸ãè¾¼ã¿æ™‚ç‚¹ã§ã•ã‚‰ãªã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘ä»˜ã‘ã‚‰ã‚Œãªã„å ´åˆ :exc:`BlockingIOError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:503
msgid ""
"The caller may release or mutate *b* after this method returns, so the "
"implementation should only access *b* during the method call."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒæˆ»ã£ãŸå¾Œã§ã€å‘¼ã³å‡ºã—å…ƒã¯ *b* ã‚’è§£æ”¾ã€ã¾ãŸã¯å¤‰æ›´ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã€å®Ÿè£…ã¯ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—ã®é–“ã ã‘ *b* ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã¹ãã§ã™ã€‚"

#: ../../library/io.rst:508
msgid "Raw File I/O"
msgstr "ç”Ÿãƒ•ã‚¡ã‚¤ãƒ«I/O"

#: ../../library/io.rst:512
msgid ""
":class:`FileIO` represents an OS-level file containing bytes data. It "
"implements the :class:`RawIOBase` interface (and therefore the "
":class:`IOBase` interface, too)."
msgstr ":class:`FileIO` ã¯ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€ OS ãƒ¬ãƒ™ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¡¨ã—ã¾ã™ã€‚ :class:`RawIOBase` ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ (ã—ãŸãŒã£ã¦ :class:`IOBase` ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚‚) å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/io.rst:516
msgid "The *name* can be one of two things:"
msgstr "*name* ã¯ã“ã® 2 ã¤ã®ã„ãšã‚Œã‹ã«å‡ºæ¥ã¾ã™:"

#: ../../library/io.rst:518
msgid "a string representing the path to the file which will be opened;"
msgstr "é–‹ããƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’è¡¨ã™æ–‡å­—åˆ—"

#: ../../library/io.rst:519
msgid ""
"an integer representing the number of an existing OS-level file descriptor "
"to which the resulting :class:`FileIO` object will give access."
msgstr "çµæœã® :class:`FileIO` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¢ã‚¯ã‚»ã‚¹ã‚’ä¸ãˆã‚‹ã€æ—¢å­˜ã® OS ãƒ¬ãƒ™ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ•°ã‚’è¡¨ã™æ•´æ•°"

#: ../../library/io.rst:522
msgid ""
"The *mode* can be ``'r'``, ``'w'`` or ``'a'`` for reading (default), "
"writing, or appending.  The file will be created if it doesn't exist when "
"opened for writing or appending; it will be truncated when opened for "
"writing.  Add a ``'+'`` to the mode to allow simultaneous reading and "
"writing."
msgstr "*mode* ã¯ãã‚Œãã‚Œèª­ã¿è¾¼ã¿ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)ã€æ›¸ãè¾¼ã¿ã€è¿½è¨˜ã‚’è¡¨ã™ ``'r'``\\ ã€ ``'w'``\\ ã€ ``'a'`` ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã¯æ›¸ãè¾¼ã¿ã¾ãŸã¯è¿½è¨˜ãƒ¢ãƒ¼ãƒ‰ã§é–‹ã‹ã‚ŒãŸã¨ãã«å­˜åœ¨ã—ãªã‘ã‚Œã°ä½œæˆã•ã‚Œã¾ã™ã€‚æ›¸ãè¾¼ã¿ãƒ¢ãƒ¼ãƒ‰ã§ã¯å­˜åœ¨ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã¯æ¶ˆã•ã‚Œã¾ã™ã€‚èª­ã¿è¾¼ã¿ã¨æ›¸ãè¾¼ã¿ã‚’åŒæ™‚ã«è¡Œã„ãŸã‘ã‚Œã° ``'+'`` ã‚’ãƒ¢ãƒ¼ãƒ‰ã«åŠ ãˆã¦ä¸‹ã•ã„ã€‚"

#: ../../library/io.rst:527
msgid ""
"The :meth:`read` (when called with a positive argument), :meth:`readinto` "
"and :meth:`write` methods on this class will only make one system call."
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã® :meth:`read` (æ­£ã®å¼•æ•°ã§å‘¼ã³å‡ºã•ã‚ŒãŸã¨ã), :meth:`readinto` ãŠã‚ˆã³ :meth:`write` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å˜ã«ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’ä¸€åº¦å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/io.rst:530
msgid ""
"In addition to the attributes and methods from :class:`IOBase` and "
":class:`RawIOBase`, :class:`FileIO` provides the following data attributes "
"and methods:"
msgstr ":class:`IOBase` ãŠã‚ˆã³ :class:`RawIOBase` ã‹ã‚‰ç¶™æ‰¿ã—ãŸå±æ€§ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã«åŠ ãˆã¦ã€ :class:`FileIO` ã¯ä»¥ä¸‹ã®ãƒ‡ãƒ¼ã‚¿å±æ€§ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/io.rst:536
msgid "The mode as given in the constructor."
msgstr "ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«æ¸¡ã•ã‚ŒãŸãƒ¢ãƒ¼ãƒ‰ã§ã™ã€‚"

#: ../../library/io.rst:540
msgid ""
"The file name.  This is the file descriptor of the file when no name is "
"given in the constructor."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«åã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«åå‰ãŒæ¸¡ã•ã‚Œãªã‹ã£ãŸã¨ãã¯ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:545
msgid "Buffered Streams"
msgstr "ãƒãƒƒãƒ•ã‚¡ä»˜ãã‚¹ãƒˆãƒªãƒ¼ãƒ "

#: ../../library/io.rst:547
msgid ""
"Buffered I/O streams provide a higher-level interface to an I/O device than "
"raw I/O does."
msgstr "ãƒãƒƒãƒ•ã‚¡ä»˜ã I/O ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€I/O ãƒ‡ãƒã‚¤ã‚¹ã«ç”Ÿ I/O ã‚ˆã‚Šé«˜ãƒ¬ãƒ™ãƒ«ãªã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/io.rst:552
msgid ""
"A stream implementation using an in-memory bytes buffer.  It inherits "
":class:`BufferedIOBase`."
msgstr "ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªã® bytes ãƒãƒƒãƒ•ã‚¡ã‚’åˆ©ç”¨ã—ãŸã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å®Ÿè£…ã€‚ :class:`BufferedIOBase` ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚"

#: ../../library/io.rst:555
msgid ""
"The optional argument *initial_bytes* is a :class:`bytes` object that "
"contains initial data."
msgstr "çœç•¥å¯èƒ½ãªå¼•æ•° *initial_bytes* ã¯ã€åˆæœŸãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚“ã  :class:`bytes` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/io.rst:558
msgid ""
":class:`BytesIO` provides or overrides these methods in addition to those "
"from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ":class:`BytesIO` ã¯ :class:`BufferedIOBase` ã¾ãŸã¯ :class:`IOBase` ã‹ã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«åŠ ãˆã¦ã€ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã‚‚ã—ãã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¾ã™:"

#: ../../library/io.rst:563
msgid "Return ``bytes`` containing the entire contents of the buffer."
msgstr "ãƒãƒƒãƒ•ã‚¡ã®å…¨å†…å®¹ã‚’ä¿æŒã—ãŸ ``bytes`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/io.rst:567
msgid "In :class:`BytesIO`, this is the same as :meth:`read`."
msgstr ":class:`BytesIO` ã«ãŠã„ã¦ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :meth:`read` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/io.rst:572
msgid ""
"A buffer providing higher-level access to a readable, sequential "
":class:`RawIOBase` object.  It inherits :class:`BufferedIOBase`. When "
"reading data from this object, a larger amount of data may be requested from"
" the underlying raw stream, and kept in an internal buffer. The buffered "
"data can then be returned directly on subsequent reads."
msgstr "èª­ã¿è¾¼ã¿å¯èƒ½ã§ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ãª :class:`RawIOBase` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã€é«˜ãƒ¬ãƒ™ãƒ«ãªã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›ã™ã‚‹ãƒãƒƒãƒ•ã‚¡ã§ã™ã€‚ :class:`BufferedIOBase` ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€ã¨ãã€æ ¹åº•ã®ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰ã‚ˆã‚Šå¤§ãã„é‡ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦æ±‚ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã€å†…éƒ¨ãƒãƒƒãƒ•ã‚¡ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã¯ã€ç¶šãèª­ã¿è¾¼ã¿æ™‚ã«ç›´æ¥è¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:578
msgid ""
"The constructor creates a :class:`BufferedReader` for the given readable "
"*raw* stream and *buffer_size*.  If *buffer_size* is omitted, "
":data:`DEFAULT_BUFFER_SIZE` is used."
msgstr "ã“ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ä¸ãˆã‚‰ã‚ŒãŸ *raw* ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ *buffer_size* ã«å¯¾ã— :class:`BufferedReader` ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ *buffer_size* ãŒçœç•¥ã•ã‚ŒãŸå ´åˆã€ä»£ã‚ã‚Šã« :data:`DEFAULT_BUFFER_SIZE` ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:582
msgid ""
":class:`BufferedReader` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ":class:`BufferedReader` ã¯ :class:`BufferedIOBase` ã¾ãŸã¯ :class:`IOBase` ã‹ã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«åŠ ãˆã¦ã€ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã‚‚ã—ãã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¾ã™:"

#: ../../library/io.rst:587
msgid ""
"Return bytes from the stream without advancing the position.  At most one "
"single read on the raw stream is done to satisfy the call. The number of "
"bytes returned may be less or more than requested."
msgstr "ä½ç½®ã‚’é€²ã‚ãšã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰ãƒã‚¤ãƒˆåˆ—ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã‚’æœãŸã™ãŸã‚ã«ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ã¦è¡Œã‚ã‚Œã‚‹ read ã¯é«˜ã€…ä¸€åº¦ã ã‘ã§ã™ã€‚è¿”ã•ã‚Œã‚‹ãƒã‚¤ãƒˆæ•°ã¯ã€è¦æ±‚ã‚ˆã‚Šå°‘ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã—ã€å¤šã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:593
msgid ""
"Read and return *n* bytes, or if *n* is not given or negative, until EOF or "
"if the read call would block in non-blocking mode."
msgstr "*n* ãƒã‚¤ãƒˆã‚’èª­ã¿è¾¼ã‚“ã§è¿”ã—ã¾ã™ã€‚ *n* ãŒä¸ãˆã‚‰ã‚Œãªã„ã‹ã¾ãŸã¯è² ã®å€¤ãªã‚‰ã°ã€EOF ã¾ã§ã€ã¾ãŸã¯éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ä¸­ã§ read å‘¼ã³å‡ºã—ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã¾ã§ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/io.rst:598
msgid ""
"Read and return up to *n* bytes with only one call on the raw stream.  If at"
" least one byte is buffered, only buffered bytes are returned. Otherwise, "
"one raw stream read call is made."
msgstr "ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ãŸã ä¸€åº¦ã®å‘¼ã³å‡ºã—ã§æœ€å¤§ *n* ãƒã‚¤ãƒˆã‚’èª­ã¿è¾¼ã‚“ã§è¿”ã—ã¾ã™ã€‚å°‘ãªãã¨ã‚‚ 1 ãƒã‚¤ãƒˆãŒãƒãƒƒãƒ•ã‚¡ã•ã‚Œã¦ã„ã‚Œã°ã€ãƒãƒƒãƒ•ã‚¡ã•ã‚Œã¦ã„ã‚‹ãƒã‚¤ãƒˆåˆ—ã ã‘ãŒè¿”ã•ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã¡ã‚‡ã†ã©ä¸€å›ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ã« read å‘¼ã³å‡ºã—ãŒè¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:605
msgid ""
"A buffer providing higher-level access to a writeable, sequential "
":class:`RawIOBase` object.  It inherits :class:`BufferedIOBase`. When "
"writing to this object, data is normally held into an internal buffer.  The "
"buffer will be written out to the underlying :class:`RawIOBase` object under"
" various conditions, including:"
msgstr "æ›¸ãè¾¼ã¿å¯èƒ½ã§ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ãª :class:`RawIOBase` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã€é«˜ãƒ¬ãƒ™ãƒ«ãªã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›ã™ã‚‹ãƒãƒƒãƒ•ã‚¡ã§ã™ã€‚ :class:`BufferedIOBase` ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æ›¸ãè¾¼ã‚€ã¨ãã€ãƒ‡ãƒ¼ã‚¿ã¯é€šå¸¸å†…éƒ¨ãƒãƒƒãƒ•ã‚¡ã«ä¿æŒã•ã‚Œã¾ã™ã€‚ã“ã®ãƒãƒƒãƒ•ã‚¡ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªç¨®ã€…ã®çŠ¶æ³ã§æ ¹åº•ã® :class:`RawIOBase` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æ›¸ãã“ã¾ã‚Œã¾ã™:"

#: ../../library/io.rst:611
msgid "when the buffer gets too small for all pending data;"
msgstr "ä¿ç•™ä¸­ã®å…¨ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ãƒãƒƒãƒ•ã‚¡ãŒè¶³ã‚Šãªããªã£ãŸã¨ã;"

#: ../../library/io.rst:612
msgid "when :meth:`flush()` is called;"
msgstr ":meth:`flush()` ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ã;"

#: ../../library/io.rst:613
msgid ""
"when a :meth:`seek()` is requested (for :class:`BufferedRandom` objects);"
msgstr ":meth:`seek()` ãŒ (:class:`BufferedRandom` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦) å‘¼ã³å‡ºã•ã‚ŒãŸã¨ã;"

#: ../../library/io.rst:614
msgid "when the :class:`BufferedWriter` object is closed or destroyed."
msgstr ":class:`BufferedWriter` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒé–‰ã˜ã‚‰ã‚ŒãŸã‚Šç ´æ£„ã•ã‚ŒãŸã‚Šã—ãŸã¨ãã€‚"

#: ../../library/io.rst:616
msgid ""
"The constructor creates a :class:`BufferedWriter` for the given writeable "
"*raw* stream.  If the *buffer_size* is not given, it defaults to "
":data:`DEFAULT_BUFFER_SIZE`."
msgstr "ã“ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ä¸ãˆã‚‰ã‚ŒãŸæ›¸ãè¾¼ã¿å¯èƒ½ãª *raw* ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã— :class:`BufferedWriter` ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ *buffer_size* ãŒçœç•¥ã•ã‚ŒãŸå ´åˆã€ :data:`DEFAULT_BUFFER_SIZE` ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:620 ../../library/io.rst:649
msgid ""
"A third argument, *max_buffer_size*, is supported, but unused and "
"deprecated."
msgstr "ç¬¬ä¸‰å¼•æ•° *max_buffer_size* ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ãŒã€ä½¿ã‚ã‚Œãšã€éæ¨å¥¨ã§ã™ã€‚"

#: ../../library/io.rst:622
msgid ""
":class:`BufferedWriter` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ":class:`BufferedWriter` ã¯ :class:`BufferedIOBase` ã¾ãŸã¯ :class:`IOBase` ã‹ã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«åŠ ãˆã¦ã€ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã‚‚ã—ãã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¾ã™:"

#: ../../library/io.rst:627
msgid ""
"Force bytes held in the buffer into the raw stream.  A "
":exc:`BlockingIOError` should be raised if the raw stream blocks."
msgstr "ãƒãƒƒãƒ•ã‚¡ã«ä¿æŒã•ã‚ŒãŸãƒã‚¤ãƒˆåˆ—ã‚’ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¼·åˆ¶çš„ã«æµã—è¾¼ã¿ã¾ã™ã€‚ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒãƒ–ãƒ­ãƒƒã‚¯ã—ãŸå ´åˆ :exc:`BlockingIOError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:632
msgid ""
"Write *b*, and return the number of bytes written. The object *b* should be "
"an array of bytes, either :class:`bytes`, :class:`bytearray`, or "
":class:`memoryview`. When in non-blocking mode, a :exc:`BlockingIOError` is "
"raised if the buffer needs to be written out but the raw stream blocks."
msgstr "*b* ã‚’æ›¸ãè¾¼ã¿ã€æ›¸ãè¾¼ã‚“ã ãƒã‚¤ãƒˆæ•°ã‚’è¿”ã—ã¾ã™ã€‚\nã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *b* ã¯ãƒã‚¤ãƒˆé…åˆ—ã€:class:`bytes` ã€ :class:`bytearray` ã€ :class:`memoryview` ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\nãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã®ã¨ãã¯ã€ãƒãƒƒãƒ•ã‚¡ãŒæ›¸ãè¾¼ã¾ã‚Œã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ã“ã‚ã§ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒãƒ–ãƒ­ãƒƒã‚¯ã—ãŸå ´åˆ :exc:`BlockingIOError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:641
msgid ""
"A buffered interface to random access streams.  It inherits "
":class:`BufferedReader` and :class:`BufferedWriter`, and further supports "
":meth:`seek` and :meth:`tell` functionality."
msgstr "ãƒ©ãƒ³ãƒ€ãƒ ã‚¢ã‚¯ã‚»ã‚¹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¸ã®ãƒãƒƒãƒ•ã‚¡ä»˜ãã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã€‚ :class:`BufferedReader` ãŠã‚ˆã³ :class:`BufferedWriter` ã‚’ç¶™æ‰¿ã—ã€ã•ã‚‰ã« :meth:`seek` ãŠã‚ˆã³ :meth:`tell` ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/io.rst:645
msgid ""
"The constructor creates a reader and writer for a seekable raw stream, given"
" in the first argument.  If the *buffer_size* is omitted it defaults to "
":data:`DEFAULT_BUFFER_SIZE`."
msgstr "ã“ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ç¬¬ä¸€å¼•æ•°ã¨ã—ã¦ä¸ãˆã‚‰ã‚Œã‚‹ã‚·ãƒ¼ã‚¯å¯èƒ½ãªç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ã€ãƒªãƒ¼ãƒ€ãƒ¼ãŠã‚ˆã³ãƒ©ã‚¤ã‚¿ãƒ¼ã‚’ä½œæˆã—ã¾ã™ã€‚ *buffer_size* ãŒçœç•¥ã•ã‚ŒãŸå ´åˆã€ :data:`DEFAULT_BUFFER_SIZE` ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:651
msgid ""
":class:`BufferedRandom` is capable of anything :class:`BufferedReader` or "
":class:`BufferedWriter` can do."
msgstr ":class:`BufferedRandom` ã¯ :class:`BufferedReader` ã‚„ :class:`BufferedWriter` ã«ã§ãã‚‹ã“ã¨ã¯ä½•ã§ã‚‚ã§ãã¾ã™ã€‚"

#: ../../library/io.rst:657
msgid ""
"A buffered I/O object combining two unidirectional :class:`RawIOBase` "
"objects -- one readable, the other writeable -- into a single bidirectional "
"endpoint.  It inherits :class:`BufferedIOBase`."
msgstr "2ã¤ã®å˜æ–¹å‘ :class:`RawIOBase` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ -- ä¸€ã¤ã¯èª­ã¿è¾¼ã¿å¯èƒ½ã€ä»–æ–¹ãŒæ›¸ãè¾¼ã¿å¯èƒ½ -- ã‚’çµ„ã¿åˆã‚ã›ã¦ãƒãƒƒãƒ•ã‚¡ä»˜ãã®åŒæ–¹å‘ I/O ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã—ãŸã‚‚ã®ã§ã™ã€‚ :class:`BufferedIOBase` ã‚’ç¶™æ‰¿ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/io.rst:661
msgid ""
"*reader* and *writer* are :class:`RawIOBase` objects that are readable and "
"writeable respectively.  If the *buffer_size* is omitted it defaults to "
":data:`DEFAULT_BUFFER_SIZE`."
msgstr "*reader* ã¨ *writer* ã¯ãã‚Œãã‚Œèª­ã¿è¾¼ã¿å¯èƒ½ã€æ›¸ãè¾¼ã¿å¯èƒ½ãª :class:`RawIOBase` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ *buffer_size* ãŒçœç•¥ã•ã‚ŒãŸå ´åˆ :data:`DEFAULT_BUFFER_SIZE` ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:665
msgid ""
"A fourth argument, *max_buffer_size*, is supported, but unused and "
"deprecated."
msgstr "ç¬¬å››å¼•æ•° *max_buffer_size* ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ãŒã€ä½¿ã‚ã‚Œãšã€éæ¨å¥¨ã§ã™ã€‚"

#: ../../library/io.rst:668
msgid ""
":class:`BufferedRWPair` implements all of :class:`BufferedIOBase`\\'s "
"methods except for :meth:`~BufferedIOBase.detach`, which raises "
":exc:`UnsupportedOperation`."
msgstr ":class:`BufferedRWPair` ã¯ã€ :exc:`UnsupportedOperation` ã‚’é€å‡ºã™ã‚‹ :meth:`~BufferedIOBase.detach` ã‚’é™¤ãã€ :class:`BufferedIOBase` ã®å…¨ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../library/io.rst:674
msgid ""
":class:`BufferedRWPair` does not attempt to synchronize accesses to its "
"underlying raw streams.  You should not pass it the same object as reader "
"and writer; use :class:`BufferedRandom` instead."
msgstr ":class:`BufferedRWPair` ã¯ä¸‹å±¤ã®ç”Ÿã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’åŒæœŸã—ã‚ˆã†ã¨ã¯ã—ã¾ã›ã‚“ã€‚åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒªãƒ¼ãƒ€ã¨ãƒ©ã‚¤ã‚¿ã¨ã—ã¦æ¸¡ã—ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚ãã®å ´åˆã¯ä»£ã‚ã‚Šã« :class:`BufferedRandom` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/io.rst:680 ../../library/io.rst:896
msgid "Text I/O"
msgstr "ãƒ†ã‚­ã‚¹ãƒˆ I/O"

#: ../../library/io.rst:684
msgid ""
"Base class for text streams.  This class provides a unicode character and "
"line based interface to stream I/O.  There is no :meth:`readinto` method "
"because Python's :class:`unicode` strings are immutable. It inherits "
":class:`IOBase`.  There is no public constructor."
msgstr "ãƒ†ã‚­ã‚¹ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯ã‚¹ãƒˆãƒªãƒ¼ãƒ  I/O ã¸ã® Unicode æ–‡å­—ã¨è¡Œã«åŸºã¥ã„ãŸã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚ Python ã® :class:`unicode` æ–‡å­—åˆ—ã¯å¤‰æ›´ä¸å¯èƒ½ãªã®ã§ã€ :meth:`readinto` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚ :class:`IOBase` ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:689
msgid ""
":class:`TextIOBase` provides or overrides these data attributes and methods "
"in addition to those from :class:`IOBase`:"
msgstr ":class:`IOBase` ã‹ã‚‰ç¶™æ‰¿ã—ãŸå±æ€§ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã«åŠ ãˆã¦ã€ :class:`TextIOBase` ã¯ä»¥ä¸‹ã®ãƒ‡ãƒ¼ã‚¿å±æ€§ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/io.rst:694
msgid ""
"The name of the encoding used to decode the stream's bytes into strings, and"
" to encode strings into bytes."
msgstr "ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°åã§ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ãƒã‚¤ãƒˆåˆ—ã‚’æ–‡å­—åˆ—ã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã™ã‚‹ã¨ãã€ã¾ãŸæ–‡å­—åˆ—ã‚’ãƒã‚¤ãƒˆåˆ—ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ã¨ãã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:699
msgid "The error setting of the decoder or encoder."
msgstr "ã“ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ã‚„ãƒ‡ã‚³ãƒ¼ãƒ€ã®ã‚¨ãƒ©ãƒ¼è¨­å®šã§ã™ã€‚"

#: ../../library/io.rst:703
msgid ""
"A string, a tuple of strings, or ``None``, indicating the newlines "
"translated so far.  Depending on the implementation and the initial "
"constructor flags, this may not be available."
msgstr "æ–‡å­—åˆ—ã€æ–‡å­—åˆ—ã®ã‚¿ãƒ—ãƒ«ã€ã¾ãŸã¯ ``None`` ã§ã€æ”¹è¡ŒãŒã©ã®ã‚ˆã†ã«èª­ã¿æ›ãˆã‚‰ã‚Œã‚‹ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚å®Ÿè£…ã‚„å†…éƒ¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ãƒ•ãƒ©ã‚°ã«ä¾ã£ã¦ã€ã“ã‚Œã¯åˆ©ç”¨ã§ããªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:709
msgid ""
"The underlying binary buffer (a :class:`BufferedIOBase` instance) that "
":class:`TextIOBase` deals with.  This is not part of the :class:`TextIOBase`"
" API and may not exist on some implementations."
msgstr ":class:`TextIOBase` ãŒæ‰±ã†æ ¹åº•ã®ãƒã‚¤ãƒŠãƒªãƒãƒƒãƒ•ã‚¡ (:class:`BufferedIOBase` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹) ã§ã™ã€‚ã“ã‚Œã¯ :class:`TextIOBase` API ã«ã¯å«ã¾ã‚Œãšã€ã‚ˆã£ã¦å®Ÿè£…ã«å«ã¾ã‚Œãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:715
msgid ""
"Separate the underlying binary buffer from the :class:`TextIOBase` and "
"return it."
msgstr "æ ¹åº•ã®ãƒã‚¤ãƒŠãƒªãƒãƒƒãƒ•ã‚¡ã‚’ :class:`TextIOBase` ã‹ã‚‰åˆ†é›¢ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/io.rst:718
msgid ""
"After the underlying buffer has been detached, the :class:`TextIOBase` is in"
" an unusable state."
msgstr "æ ¹åº•ã®ãƒãƒƒãƒ•ã‚¡ãŒå–ã‚Šå¤–ã•ã‚ŒãŸå¾Œã€ :class:`TextIOBase` ã¯ä½¿ç”¨ä¸èƒ½çŠ¶æ…‹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:721
msgid ""
"Some :class:`TextIOBase` implementations, like :class:`~io.StringIO`, may "
"not have the concept of an underlying buffer and calling this method will "
"raise :exc:`UnsupportedOperation`."
msgstr ":class:`TextIOBase` å®Ÿè£…ã«ã¯ã€ :class:`~io.StringIO` ãªã©ã€æ ¹åº•ã®ãƒãƒƒãƒ•ã‚¡ã¨ã„ã†æ¦‚å¿µã‚’æŒãŸãªã„ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã‚’å‘¼ã³å‡ºã™ã¨ :exc:`UnsupportedOperation` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/io.rst:729
msgid ""
"Read and return at most *n* characters from the stream as a single "
":class:`unicode`.  If *n* is negative or ``None``, reads until EOF."
msgstr "æœ€å¤§ *n* æ–‡å­—ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰èª­ã¿è¾¼ã¿ã€ä¸€ã¤ã® :class:`unicode` ã«ã—ã¦è¿”ã—ã¾ã™ã€‚ *n* ãŒè² ã®å€¤ã¾ãŸã¯ ``None`` ãªã‚‰ã°ã€ EOF ã¾ã§èª­ã¿ã¾ã™ã€‚"

#: ../../library/io.rst:734
msgid ""
"Read until newline or EOF and return a single ``unicode``.  If the stream is"
" already at EOF, an empty string is returned."
msgstr "æ”¹è¡Œã¾ãŸã¯ EOF ã¾ã§èª­ã¿è¾¼ã¿ã€ä¸€ã¤ã® ``unicode`` ã‚’è¿”ã—ã¾ã™ã€‚ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒæ—¢ã« EOF ã«åˆ°é”ã—ã¦ã„ã‚‹å ´åˆã€ç©ºæ–‡å­—åˆ—ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:737
msgid "If *limit* is specified, at most *limit* characters will be read."
msgstr "ã‚‚ã— *limit* ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã€æœ€å¤§ã§ *limit* ãƒã‚¤ãƒˆãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:741
msgid ""
"Change the stream position to the given *offset*.  Behaviour depends on the "
"*whence* parameter.  The default value for *whence* is :data:`SEEK_SET`."
msgstr "æŒ‡å®šã•ã‚ŒãŸ *offset* ã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ä½ç½®ã‚’å¤‰æ›´ã—ã¾ã™ã€‚ æŒ™å‹•ã¯ *whence* å¼•æ•°ã«ã‚ˆã‚Šã¾ã™ã€‚ *whence* ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ :data:`SEEK_SET` ã§ã™ã€‚:"

#: ../../library/io.rst:745
msgid ""
":data:`SEEK_SET` or ``0``: seek from the start of the stream (the default); "
"*offset* must either be a number returned by :meth:`TextIOBase.tell`, or "
"zero.  Any other *offset* value produces undefined behaviour."
msgstr ":data:`SEEK_SET` ã¾ãŸã¯ ``0``: ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å…ˆé ­ã‹ã‚‰ã‚·ãƒ¼ã‚¯ã—ã¾ã™ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)ã€‚ *offset* ã¯ :meth:`TextIOBase.tell` ãŒè¿”ã™æ•°ã‹0ã®ã©ã¡ã‚‰ã‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã‚Œä»¥å¤–ã® *offset* å€¤ã¯æœªå®šç¾©ã®æŒ™å‹•ã‚’èµ·ã“ã—ã¾ã™ã€‚"

#: ../../library/io.rst:749
msgid ""
":data:`SEEK_CUR` or ``1``: \"seek\" to the current position; *offset* must "
"be zero, which is a no-operation (all other values are unsupported)."
msgstr ":data:`SEEK_CUR` ã¾ãŸã¯ ``1``: ç¾åœ¨ã®ä½ç½®ã« \"ã‚·ãƒ¼ã‚¯ã—ã¾ã™\"ã€‚ *offset* ã¯ 0 ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šä½•ã‚‚ã—ã¾ã›ã‚“ (ä»–ã®å€¤ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“)ã€‚"

#: ../../library/io.rst:752
msgid ""
":data:`SEEK_END` or ``2``: seek to the end of the stream; *offset* must be "
"zero (all other values are unsupported)."
msgstr ":data:`SEEK_END` ã¾ãŸã¯ ``2``: ã‚¹ãƒˆãƒªãƒ¼ãƒ çµ‚ç«¯ã¸ã‚·ãƒ¼ã‚¯ã—ã¾ã™ã€‚ *offset* ã¯ 0 ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ (ä»–ã®å€¤ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“)ï¼"

#: ../../library/io.rst:755
msgid "Return the new absolute position as an opaque number."
msgstr "æ–°ã—ã„çµ¶å¯¾ä½ç½®ã‚’ã€ä¸é€æ˜ãªæ•°å€¤ã§è¿”ã—ã¾ã™ã€‚"

#: ../../library/io.rst:757
msgid "The ``SEEK_*`` constants."
msgstr "``SEEK_*`` å®šæ•°."

#: ../../library/io.rst:762
msgid ""
"Return the current stream position as an opaque number.  The number does not"
" usually represent a number of bytes in the underlying binary storage."
msgstr "ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ç¾åœ¨ä½ç½®ã‚’ä¸é€æ˜ãªæ•°å€¤ã§è¿”ã—ã¾ã™ã€‚ã“ã®å€¤ã¯æ ¹åº•ã®ãƒã‚¤ãƒŠãƒªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å†…ã§ã®ãƒã‚¤ãƒˆæ•°ã‚’è¡¨ã™ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:768
msgid ""
"Write the :class:`unicode` string *s* to the stream and return the number of"
" characters written."
msgstr ":class:`unicode` æ–‡å­—åˆ— *s* ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«æ›¸ãè¾¼ã¿ã€æ›¸ãè¾¼ã¾ã‚ŒãŸæ–‡å­—æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/io.rst:774
msgid ""
"A buffered text stream over a :class:`BufferedIOBase` binary stream. It "
"inherits :class:`TextIOBase`."
msgstr ":class:`BufferedIOBase` ãƒã‚¤ãƒŠãƒªã‚¹ãƒˆãƒªãƒ¼ãƒ ä¸Šã®ãƒãƒƒãƒ•ã‚¡ä»˜ããƒ†ã‚­ã‚¹ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã€‚ :class:`TextIOBase` ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚"

#: ../../library/io.rst:777
msgid ""
"*encoding* gives the name of the encoding that the stream will be decoded or"
" encoded with.  It defaults to :func:`locale.getpreferredencoding`."
msgstr "*encoding* ã«ã¯ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ãŸã‚Šãã‚Œã‚’ä½¿ã£ã¦ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸã‚Šã™ã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°åã‚’æ¸¡ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ :func:`locale.getpreferredencoding` ã§ã™ã€‚"

#: ../../library/io.rst:780
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled.  Pass ``'strict'`` to raise a :exc:`ValueError` "
"exception if there is an encoding error (the default of ``None`` has the "
"same effect), or pass ``'ignore'`` to ignore errors.  (Note that ignoring "
"encoding errors can lead to data loss.)  ``'replace'`` causes a replacement "
"marker (such as ``'?'``) to be inserted where there is malformed data.  When"
" writing, ``'xmlcharrefreplace'`` (replace with the appropriate XML "
"character reference) or ``'backslashreplace'`` (replace with backslashed "
"escape sequences) can be used.  Any other error handling name that has been "
"registered with :func:`codecs.register_error` is also valid."
msgstr "*errors* ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ–‡å­—åˆ—ã§ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚„ãƒ‡ã‚³ãƒ¼ãƒ‰ã®éš›ã®ã‚¨ãƒ©ãƒ¼ã‚’ã©ã®ã‚ˆã†ã«æ‰±ã†ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒã‚ã£ãŸã‚‰ :exc:`ValueError` ä¾‹å¤–ã‚’é€å‡ºã•ã›ã‚‹ã«ã¯ ``'strict'`` ã‚’æ¸¡ã—ã¾ã™(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® ``None`` ã§ã‚‚åŒã˜ã§ã™)ã€‚ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–ã•ã›ã‚‹ã«ã¯ ``'ignore'`` ã§ã™ã€‚ (æ³¨æ„ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã¯ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–ã™ã‚‹ã¨ãƒ‡ãƒ¼ã‚¿å–ªå¤±ã«ã¤ãªãŒã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚) ``'replace'`` ã¯æ­£å¸¸ã«å¤‰æ›ã•ã‚Œãªã‹ã£ãŸæ–‡å­—ã®ä»£ã‚ã‚Šã«ãƒãƒ¼ã‚« (ãŸã¨ãˆã° ``'?'``) ã‚’æŒ¿å…¥ã•ã›ã¾ã™ã€‚æ›¸ãè¾¼ã¿æ™‚ã«ã¯ ``'xmlcharrefreplace'`` (é©åˆ‡ãª XML æ–‡å­—å‚ç…§ã«ç½®ãæ›ãˆ) ã‚„ ``'backslashreplace'`` (ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«ã‚ˆã‚‹ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ç½®ãæ›ãˆ) ã‚‚ä½¿ãˆã¾ã™ã€‚ä»–ã«ã‚‚ :func:`codecs.register_error` ã§ç™»éŒ²ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼å‡¦ç†åãŒæœ‰åŠ¹ã§ã™ã€‚"

#: ../../library/io.rst:794
msgid ""
"*newline* controls how line endings are handled.  It can be ``None``, "
"``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as follows:"
msgstr "*newline* ã¯è¡Œæœ«ã‚’ã©ã®ã‚ˆã†ã«å‡¦ç†ã™ã‚‹ã‹ã‚’åˆ¶å¾¡ã—ã¾ã™ ã€‚ã“ã‚Œã¯ ``None``, ``''``, ``'\\n'``, ``'\\r'``, ``'\\r\\n'`` ã®ã„ãšã‚Œã‹ã§ã™ã€‚ã“ã‚Œã¯ä»¥ä¸‹ã®ã‚ˆã†ã«åƒãã¾ã™:"

#: ../../library/io.rst:797
msgid ""
"On input, if *newline* is ``None``, :term:`universal newlines` mode is "
"enabled.  Lines in the input can end in ``'\\n'``, ``'\\r'``, or "
"``'\\r\\n'``, and these are translated into ``'\\n'`` before being returned "
"to the caller.  If it is ``''``, universal newlines mode is enabled, but "
"line endings are returned to the caller untranslated.  If it has any of the "
"other legal values, input lines are only terminated by the given string, and"
" the line ending is returned to the caller untranslated."
msgstr "ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰ã®å…¥åŠ›ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã‚‹æ™‚ã€*newline* ãŒ ``None`` ã®å ´åˆã€:term:`universal newlines` ãƒ¢ãƒ¼ãƒ‰ãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚å…¥åŠ›ä¸­ã®è¡Œã¯ ``'\\n'``ã€``'\\r'``ã€ã¾ãŸã¯ ``'\\r\\n'`` ã§çµ‚ã‚ã‚Šã€å‘¼ã³å‡ºã—å…ƒã«è¿”ã•ã‚Œã‚‹å‰ã« ``'\\n'`` ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚ ``''`` ã®å ´åˆã€ãƒ¦ãƒ‹ãƒãƒ¼ã‚µãƒ«æ”¹è¡Œãƒ¢ãƒ¼ãƒ‰ã¯æœ‰åŠ¹ã«ãªã‚Šã¾ã™ãŒã€è¡Œæœ«ã¯å¤‰æ›ã•ã‚Œãšã«å‘¼ã³å‡ºã—å…ƒã«è¿”ã•ã‚Œã¾ã™ã€‚ãã®ä»–ã®åˆæ³•ãªå€¤ã®å ´åˆã€å…¥åŠ›è¡Œã¯ä¸ãˆã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã§ã®ã¿çµ‚ã‚ã‚Šã€è¡Œæœ«ã¯å¤‰æ›ã•ã‚Œãšã«å‘¼ã³å‡ºã—å…ƒã«è¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:811
msgid ""
"If *line_buffering* is ``True``, :meth:`flush` is implied when a call to "
"write contains a newline character or a carriage return."
msgstr "*line_buffering* ãŒ ``True`` ã®å ´åˆã€ write ã¸ã®å‘¼ã³å‡ºã—ãŒæ”¹è¡Œæ–‡å­—ã‚‚ã—ãã¯ã‚­ãƒ£ãƒªãƒƒã‚¸ãƒªã‚¿ãƒ¼ãƒ³ã‚’å«ã‚“ã§ã„ã‚Œã°ã€æš—é»™çš„ã« :meth:`flush` ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:814
msgid ""
":class:`TextIOWrapper` provides one attribute in addition to those of "
":class:`TextIOBase` and its parents:"
msgstr ":class:`TextIOBase` ãŠã‚ˆã³ãã®è¦ªã‚¯ãƒ©ã‚¹ã®å±æ€§ã«åŠ ãˆã¦ã€ :class:`TextIOWrapper` ã¯ä»¥ä¸‹ã®å±æ€§ã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/io.rst:819
msgid "Whether line buffering is enabled."
msgstr "è¡Œãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã€‚"

#: ../../library/io.rst:824
msgid ""
"An in-memory stream for unicode text.  It inherits :class:`TextIOWrapper`."
msgstr "Unicode ãƒ†ã‚­ã‚¹ãƒˆã®ãŸã‚ã®ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒªãƒ¼ãƒ ã€‚ :class:`TextIOWrapper` ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚"

#: ../../library/io.rst:826
msgid ""
"The initial value of the buffer can be set by providing *initial_value*. If "
"newline translation is enabled, newlines will be encoded as if by "
":meth:`~TextIOBase.write`.  The stream is positioned at the start of the "
"buffer."
msgstr "ãƒãƒƒãƒ•ã‚¡ã®åˆæœŸå€¤ã‚’ *initial_value* ã§ä¸ãˆã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚æ”¹è¡Œå¤‰æ›ã‚’æœ‰åŠ¹ã«ã™ã‚‹ã¨ã€æ”¹è¡Œã‚³ãƒ¼ãƒ‰ã¯ :meth:`~TextIOBase.write` ã«ã‚ˆã£ã¦ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ã€‚ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ãƒãƒƒãƒ•ã‚¡ã®é–‹å§‹ä½ç½®ã«é…ç½®ã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:831
msgid ""
"The *newline* argument works like that of :class:`TextIOWrapper`. The "
"default is to consider only ``\\n`` characters as ends of lines and to do no"
" newline translation.  If *newline* is set to ``None``, newlines are written"
" as ``\\n`` on all platforms, but universal newline decoding is still "
"performed when reading."
msgstr "*newline* å¼•æ•°ã¯ :class:`TextIOWrapper` ã®ã‚‚ã®ã¨åŒã˜ã‚ˆã†ã«åƒãã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``\\n`` æ–‡å­—ã ã‘ã‚’è¡Œæœ«ã¨ã¿ãªã—ã€ã¾ãŸã€æ”¹è¡Œã®å¤‰æ›ã¯è¡Œã„ã¾ã›ã‚“ã€‚ *newline* ã« ``None`` ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã¨æ”¹è¡Œã‚³ãƒ¼ãƒ‰ã‚’å…¨ã¦ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ ``\\n`` ã§æ›¸ãè¾¼ã¿ã¾ã™ãŒã€èª­ã¿è¾¼ã¿æ™‚ã«ã¯ãã‚Œã§ã‚‚ãƒ¦ãƒ‹ãƒãƒ¼ã‚µãƒ«æ”¹è¡Œã¨ã—ã¦ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã¯å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:837
msgid ""
":class:`~io.StringIO` provides this method in addition to those from "
":class:`TextIOWrapper` and its parents:"
msgstr ":class:`~io.StringIO` ãŠã‚ˆã³ãã®è¦ªã‚¯ãƒ©ã‚¹ã‹ã‚‰ç¶™æ‰¿ã—ãŸãƒ¡ã‚½ãƒƒãƒ‰ã«åŠ ãˆã¦ :class:`StringIO` ã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/io.rst:842
msgid ""
"Return a ``unicode`` containing the entire contents of the buffer at any "
"time before the :class:`~io.StringIO` object's :meth:`close` method is "
"called.  Newlines are decoded as if by :meth:`~TextIOBase.read`, although "
"the stream position is not changed."
msgstr ":class:`~io.StringIO` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`close` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹å‰ã®ã€ä»»æ„ã®æ™‚ç‚¹ã§ã®ãƒãƒƒãƒ•ã‚¡ã®å…¨å†…å®¹ã‚’å«ã‚€ ``unicode`` ã‚’è¿”ã—ã¾ã™ã€‚æ”¹è¡Œã‚³ãƒ¼ãƒ‰ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã¯ :meth:`~TextIOBase.read` ã«ã‚ˆã£ã¦è¡Œã‚ã‚Œã¾ã™ãŒã€ã“ã‚Œã«ã‚ˆã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ä½ç½®ã®å¤‰æ›´ã¯èµ·ã“ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:847
msgid "Example usage::"
msgstr "ä½¿ç”¨ä¾‹::"

#: ../../library/io.rst:869
msgid ""
"A helper codec that decodes newlines for :term:`universal newlines` mode. It"
" inherits :class:`codecs.IncrementalDecoder`."
msgstr "æ”¹è¡Œã‚’ :term:`universal newlines` ãƒ¢ãƒ¼ãƒ‰ã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ã§ã™ã€‚ :class:`codecs.IncrementalDecoder` ã‚’ç¶™æ‰¿ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/io.rst:874
msgid "Advanced topics"
msgstr "é€²ã‚“ã è©±é¡Œ"

#: ../../library/io.rst:876
msgid ""
"Here we will discuss several advanced topics pertaining to the concrete I/O "
"implementations described above."
msgstr "ã“ã“ã§ã€ä¸Šè¿°ã® I/O å®Ÿè£…ã«é–¢ä¿‚ã™ã‚‹ã„ãã¤ã‹ã®é€²ã‚“ã è©±é¡Œã«ã¤ã„ã¦è­°è«–ã—ã¾ã™ã€‚"

#: ../../library/io.rst:880
msgid "Performance"
msgstr "ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹"

#: ../../library/io.rst:883
msgid "Binary I/O"
msgstr "ãƒã‚¤ãƒŠãƒª I/O"

#: ../../library/io.rst:885
msgid ""
"By reading and writing only large chunks of data even when the user asks for"
" a single byte, buffered I/O is designed to hide any inefficiency in calling"
" and executing the operating system's unbuffered I/O routines.  The gain "
"will vary very much depending on the OS and the kind of I/O which is "
"performed (for example, on some contemporary OSes such as Linux, unbuffered "
"disk I/O can be as fast as buffered I/O).  The bottom line, however, is that"
" buffered I/O will offer you predictable performance regardless of the "
"platform and the backing device.  Therefore, it is most always preferable to"
" use buffered I/O rather than unbuffered I/O."
msgstr "ãƒãƒƒãƒ•ã‚¡ä»˜ã I/O ã¯ã€ãƒ¦ãƒ¼ã‚¶ãŒ 1 ãƒã‚¤ãƒˆã ã‘è¦æ±‚ã—ãŸã¨ãã§ã•ãˆã€ãƒ‡ãƒ¼ã‚¿ã‚’å¤§ããªå¡Šã§ã®ã¿èª­ã¿æ›¸ãã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®ãƒãƒƒãƒ•ã‚¡ç„¡ã— I/O ãƒ«ãƒ¼ãƒãƒ³ã‚’å‘¼ã³å‡ºã—ã¦å®Ÿè¡Œã™ã‚‹éåŠ¹ç‡æ€§ã‚’ã™ã¹ã¦éš ã—ã¦ã„ã¾ã™ã€‚ãã®æˆæœã¯ã€OS ã¨å‡¦ç†ã•ã‚Œã‚‹ I/O ã®ç¨®é¡ã«æœ¬å½“ã«ã¨ã¦ã‚‚å¤§ããä¾å­˜ã—ã¾ã™ (ä¾‹ãˆã°ã€Linux ã®ã‚ˆã†ãªç¾è¡Œã® OS ã§ã¯ã€ãƒãƒƒãƒ•ã‚¡ç„¡ã—ãƒ‡ã‚£ã‚¹ã‚¯ I/O ãŒãƒãƒƒãƒ•ã‚¡ä»˜ã I/O ã¨åŒã˜ãã‚‰ã„æ—©ã„ã“ã¨ãŒã‚ã‚Šã¾ã™)ã€‚ã—ã‹ã—ã€æœ€ä½ã§ã‚‚ã€ãƒãƒƒãƒ•ã‚¡ä»˜ã I/O ã¯äºˆæ¸¬ã§ãã‚‹ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚ã§ã™ã‹ã‚‰ã€ã»ã¨ã‚“ã©ã„ã¤ã‚‚ã€ãƒãƒƒãƒ•ã‚¡ç„¡ã— I/O ã‚ˆã‚Šã€ãƒãƒƒãƒ•ã‚¡ä»˜ãã® I/O ã‚’ä½¿ã†ã»ã†ãŒæœ›ã¾ã—ã„ã§ã™ã€‚"

#: ../../library/io.rst:898
msgid ""
"Text I/O over a binary storage (such as a file) is significantly slower than"
" binary I/O over the same storage, because it implies conversions from "
"unicode to binary data using a character codec.  This can become noticeable "
"if you handle huge amounts of text data (for example very large log files). "
"Also, :meth:`TextIOWrapper.tell` and :meth:`TextIOWrapper.seek` are both "
"quite slow due to the reconstruction algorithm used."
msgstr "(ãƒ•ã‚¡ã‚¤ãƒ«ãªã©ã®) ãƒã‚¤ãƒŠãƒªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä¸Šã®ãƒ†ã‚­ã‚¹ãƒˆ I/O ã¯ã€åŒã˜ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä¸Šã®ãƒã‚¤ãƒŠãƒª I/O ã‚ˆã‚Šéå¸¸ã«é…ã„ã§ã™ã€‚ãªãœãªã‚‰ã“ã‚Œã¯ã€æ–‡å­—ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ã‚’ä½¿ã£ãŸ Unicode ã‹ã‚‰ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã¸ã®å¤‰æ›ã‚’æš—ç¤ºã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚ã“ã‚Œã¯å¤§é‡ã®ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ (ä¾‹ãˆã°éå¸¸ã«å¤§ããªãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«) ã‚’æ‰±ã†ã¨ãã«é¡•è‘—ã«æˆã‚Šå¾—ã¾ã™ã€‚åŒæ§˜ã«ã€ :meth:`TextIOWrapper.tell` ã‚„ :meth:`TextIOWrapper.seek` ã¯ã©ã¡ã‚‰ã‚‚ã€ä½¿ã‚ã‚Œã¦ã„ã‚‹å¾©å…ƒã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ãŸã‚ã«é…ããªã‚Šã¾ã™ã€‚"

#: ../../library/io.rst:905
msgid ""
":class:`~io.StringIO`, however, is a native in-memory unicode container and "
"will exhibit similar speed to :class:`BytesIO`."
msgstr "ã—ã‹ã— :class:`~io.StringIO` ã¯ã€ãƒã‚¤ãƒ†ã‚£ãƒ–ãªã‚¤ãƒ³ãƒ¡ãƒ¢ãƒª Unicode ã‚³ãƒ³ãƒ†ãƒŠã§ã€ :class:`BytesIO` ã¨åŒç¨‹åº¦ã®é€Ÿåº¦ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/io.rst:909
msgid "Multi-threading"
msgstr "ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‡ã‚£ãƒ³ã‚°"

#: ../../library/io.rst:911
msgid ""
":class:`FileIO` objects are thread-safe to the extent that the operating "
"system calls (such as ``read(2)`` under Unix) they are wrapping are thread-"
"safe too."
msgstr "(Unix ã«ãŠã‘ã‚‹ ``read(2)`` ã®ã‚ˆã†ãª) ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã®ã€ãã‚ŒãŒãƒ©ãƒƒãƒ”ãƒ³ã‚°ã—ã¦ã„ã‚‹ã‚‚ã®ãŒã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã‚ã‚‹ã‚ˆã†ãªç¯„å›²å†…ã§ã¯ã€ :class:`FileIO` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ã¾ãŸã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã™ã€‚"

#: ../../library/io.rst:915
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, "
":class:`BufferedWriter`, :class:`BufferedRandom` and "
":class:`BufferedRWPair`) protect their internal structures using a lock; it "
"is therefore safe to call them from multiple threads at once."
msgstr "ãƒã‚¤ãƒŠãƒªãƒãƒƒãƒ•ã‚¡ä»˜ãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (:class:`BufferedReader`, :class:`BufferedWriter`, :class:`BufferedRandom` ãŠã‚ˆã³ :class:`BufferedRWPair` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹) ã¯ã€ãã®å†…éƒ¨æ§‹é€ ã‚’ãƒ­ãƒƒã‚¯ã‚’ä½¿ã£ã¦ä¿è­·ã—ã¾ã™ã€‚ã“ã®ãŸã‚ã€ã“ã‚Œã‚‰ã‚’è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰åŒæ™‚ã«å‘¼ã³å‡ºã—ã¦ã‚‚å®‰å…¨ã§ã™ã€‚"

#: ../../library/io.rst:920
msgid ":class:`TextIOWrapper` objects are not thread-safe."
msgstr ":class:`TextIOWrapper` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/io.rst:923
msgid "Reentrancy"
msgstr "ãƒªã‚¨ãƒ³ãƒˆãƒ©ãƒ³ãƒˆæ€§"

#: ../../library/io.rst:925
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, "
":class:`BufferedWriter`, :class:`BufferedRandom` and "
":class:`BufferedRWPair`) are not reentrant.  While reentrant calls will not "
"happen in normal situations, they can arise if you are doing I/O in a "
":mod:`signal` handler.  If it is attempted to enter a buffered object again "
"while already being accessed *from the same thread*, then a "
":exc:`RuntimeError` is raised."
msgstr "ãƒã‚¤ãƒŠãƒªãƒãƒƒãƒ•ã‚¡ä»˜ãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (:class:`BufferedReader`, :class:`BufferedWriter`, :class:`BufferedRandom` ãŠã‚ˆã³ :class:`BufferedRWPair` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹) ã¯ã€ãƒªã‚¨ãƒ³ãƒˆãƒ©ãƒ³ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒªã‚¨ãƒ³ãƒˆãƒ©ãƒ³ãƒˆãªå‘¼ã³å‡ºã—ã¯æ™®é€šã®çŠ¶æ³ã§ã¯èµ·ã“ã‚Šã¾ã›ã‚“ãŒã€ I/O ã‚’ :mod:`signal` ãƒãƒ³ãƒ‰ãƒ©ã§è¡Œãªã£ã¦ã„ã‚‹ã¨ãã«èµ·ã“ã‚Šãˆã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡åŒ–ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã€ã™ã§ã« *åŒã˜ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰* ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã¦ã„ã‚‹ã®ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€å†ã³å…¥ã‚ã†ã¨ã™ã‚‹ã¨ :exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/io.rst:932
msgid ""
"The above implicitly extends to text files, since the :func:`open()` "
"function will wrap a buffered object inside a :class:`TextIOWrapper`.  This "
"includes standard streams and therefore affects the built-in function "
":func:`print()` as well."
msgstr ":func:`open()` é–¢æ•°ã¯ :class:`TextIOWrapper` å†…éƒ¨ã®ãƒãƒƒãƒ•ã‚¡ä»˜ãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹ãŸã‚ã€ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚‚æš—é»™ã«æ‹¡å¼µã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€æ¨™æº–ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å«ã‚€ã®ã§ã€çµ„ã¿è¾¼ã¿é–¢æ•° :func:`print()` ã«ã‚‚åŒæ§˜ã«å½±éŸ¿ã—ã¾ã™ã€‚"
