# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Takanori Suzuki <takanori@takanory.net>, 2021
# 菊池 健志, 2023
# tomo, 2023
# Inada Naoki <songofacandy@gmail.com>, 2023
# 石井明久, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-04 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: 石井明久, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/_thread.rst:2
msgid ":mod:`!_thread` --- Low-level threading API"
msgstr ":mod:`!_thread` --- 低水準なスレッド API"

#: ../../library/_thread.rst:15
msgid ""
"This module provides low-level primitives for working with multiple threads "
"(also called :dfn:`light-weight processes` or :dfn:`tasks`) --- multiple "
"threads of control sharing their global data space.  For synchronization, "
"simple locks (also called :dfn:`mutexes` or :dfn:`binary semaphores`) are "
"provided. The :mod:`threading` module provides an easier to use and higher-"
"level threading API built on top of this module."
msgstr ""
"このモジュールはマルチスレッド (別名 :dfn:`軽量プロセス` (:dfn:`light-weight "
"processes`)または :dfn:`タスク` (:dfn:`tasks`)) に用いられる低水準プリミティ"
"ブを提供します --- グローバルデータ空間を共有するマルチスレッドを制御します。"
"同期のための単純なロック (別名 :dfn:`mutexes` またはバイナリセマフォ (:dfn:"
"`binary semaphores`))が提供されています。 :mod:`threading` モジュールは、この"
"モジュール上で、より使い易く高級なスレッディングの API を提供します。"

#: ../../library/_thread.rst:26
msgid "This module used to be optional, it is now always available."
msgstr ""
"このモジュールは以前はオプションでしたが、常に利用可能なモジュールとなりまし"
"た。"

#: ../../library/_thread.rst:29
msgid "This module defines the following constants and functions:"
msgstr "このモジュールでは以下の定数および関数を定義しています:"

#: ../../library/_thread.rst:33
msgid "Raised on thread-specific errors."
msgstr "スレッド固有の例外です。"

#: ../../library/_thread.rst:35
msgid "This is now a synonym of the built-in :exc:`RuntimeError`."
msgstr "現在は組み込みの :exc:`RuntimeError` の別名です。"

#: ../../library/_thread.rst:41
msgid "This is the type of lock objects."
msgstr "これはロックオブジェクトのタイプです。"

#: ../../library/_thread.rst:46
msgid ""
"Start a new thread and return its identifier.  The thread executes the "
"function *function* with the argument list *args* (which must be a tuple). "
"The optional *kwargs* argument specifies a dictionary of keyword arguments."
msgstr ""
"新しいスレッドを開始して、そのIDを返します。スレッドは引数リスト *args* (タプ"
"ルでなければなりません)の関数 *function* を実行します。オプション引数 "
"*kwargs* はキーワード引数の辞書を指定します。"

#: ../../library/_thread.rst:50
msgid "When the function returns, the thread silently exits."
msgstr "関数が戻るとき、スレッドは静かに終了します。"

#: ../../library/_thread.rst:52
msgid ""
"When the function terminates with an unhandled exception, :func:`sys."
"unraisablehook` is called to handle the exception. The *object* attribute of "
"the hook argument is *function*. By default, a stack trace is printed and "
"then the thread exits (but other threads continue to run)."
msgstr ""

#: ../../library/_thread.rst:57
msgid ""
"When the function raises a :exc:`SystemExit` exception, it is silently "
"ignored."
msgstr ""

#: ../../library/_thread.rst:60
msgid ""
"Raises an :ref:`auditing event <auditing>` ``_thread.start_new_thread`` with "
"arguments ``function``, ``args``, ``kwargs``."
msgstr ""

#: ../../library/_thread.rst:62
msgid ":func:`sys.unraisablehook` is now used to handle unhandled exceptions."
msgstr ""

#: ../../library/_thread.rst:68
msgid ""
"Simulate the effect of a signal arriving in the main thread. A thread can "
"use this function to interrupt the main thread, though there is no guarantee "
"that the interruption will happen immediately."
msgstr ""

#: ../../library/_thread.rst:72
msgid ""
"If given, *signum* is the number of the signal to simulate. If *signum* is "
"not given, :const:`signal.SIGINT` is simulated."
msgstr ""

#: ../../library/_thread.rst:75
msgid ""
"If the given signal isn't handled by Python (it was set to :const:`signal."
"SIG_DFL` or :const:`signal.SIG_IGN`), this function does nothing."
msgstr ""

#: ../../library/_thread.rst:79
msgid "The *signum* argument is added to customize the signal number."
msgstr ""

#: ../../library/_thread.rst:83
msgid ""
"This does not emit the corresponding signal but schedules a call to the "
"associated handler (if it exists). If you want to truly emit the signal, "
"use :func:`signal.raise_signal`."
msgstr ""

#: ../../library/_thread.rst:90
msgid ""
"Raise the :exc:`SystemExit` exception.  When not caught, this will cause the "
"thread to exit silently."
msgstr ""
":exc:`SystemExit` を送出します。それが捕えられないときは、静かにスレッドを終"
"了させます。"

#: ../../library/_thread.rst:104
msgid ""
"Return a new lock object.  Methods of locks are described below.  The lock "
"is initially unlocked."
msgstr ""
"新しいロックオブジェクトを返します。ロックのメソッドはこの後に記述されます。"
"ロックは初期状態としてアンロック状態です。"

#: ../../library/_thread.rst:110
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"現在のスレッドの 'スレッドID' を返します。非ゼロの整数です。この値は直接の意"
"味を持っていません; 例えばスレッド特有のデータの辞書に索引をつけるためのよう"
"な、マジッククッキーとして意図されています。スレッドが終了し、他のスレッドが"
"作られたとき、スレッド ID は再利用されるかもしれません。"

#: ../../library/_thread.rst:118
msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""

#: ../../library/_thread.rst:123
msgid ""
":ref:`Availability <availability>`: Windows, FreeBSD, Linux, macOS, OpenBSD, "
"NetBSD, AIX, DragonFlyBSD, GNU/kFreeBSD."
msgstr ""

#: ../../library/_thread.rst:127
msgid "Added support for GNU/kFreeBSD."
msgstr ""

#: ../../library/_thread.rst:133
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"新しいスレッドを作るときのスレッドスタックサイズを返します。オプションの "
"*size* 引数にはこれ以降に作成するスレッドのスタックサイズを指定し、0 (プラッ"
"トフォームのデフォルト値または設定されたデフォルト値) か、 32,768 (32 KiB) 以"
"上の正の整数でなければなりません。*size* が指定されない場合 0 が使われます。"
"スレッドのスタックサイズの変更がサポートされていない場合、 :exc:"
"`RuntimeError` を送出します。不正なスタックサイズが指定された場合、 :exc:"
"`ValueError` を送出して、スタックサイズは変更されません。32 KiB は現在のイン"
"タープリタ自身のために十分であると保証された最小のスタックサイズです。いくつ"
"かのプラットフォームではスタックサイズに対して制限があることに注意してくださ"
"い。例えば最小のスタックサイズが 32 KiB より大きかったり、システムのメモリ"
"ページサイズ の整数倍の必要があるなどです。この制限についてはプラットフォーム"
"のドキュメントを参照してください (一般的なページサイズは 4 KiB なので、プラッ"
"トフォームに関する情報がない場合は 4096 の整数倍のスタックサイズを選ぶといい"
"かもしれません)。"

#: ../../library/_thread.rst:148
msgid ":ref:`Availability <availability>`: Windows, pthreads."
msgstr ":ref:`利用可能な環境 <availability>`: Windows, pthreads。"

#: ../../library/_thread.rst:150
msgid "Unix platforms with POSIX threads support."
msgstr ""

#: ../../library/_thread.rst:155
msgid ""
"The maximum value allowed for the *timeout* parameter of :meth:`Lock.acquire "
"<threading.Lock.acquire>`. Specifying a timeout greater than this value will "
"raise an :exc:`OverflowError`."
msgstr ""

#: ../../library/_thread.rst:162
msgid "Lock objects have the following methods:"
msgstr "ロックオブジェクトは次のようなメソッドを持っています:"

#: ../../library/_thread.rst:167
msgid ""
"Without any optional argument, this method acquires the lock "
"unconditionally, if necessary waiting until it is released by another thread "
"(only one thread at a time can acquire a lock --- that's their reason for "
"existence)."
msgstr ""
"オプションの引数なしで使用すると、このメソッドは他のスレッドがロックしている"
"かどうかにかかわらずロックを獲得します。ただし、他のスレッドがすでにロックし"
"ている場合には解除されるまで待ってからロックを獲得します (同時にロックを獲得"
"できるスレッドはひとつだけであり、これこそがロックの存在理由です)。"

#: ../../library/_thread.rst:171
msgid ""
"If the *blocking* argument is present, the action depends on its value: if "
"it is false, the lock is only acquired if it can be acquired immediately "
"without waiting, while if it is true, the lock is acquired unconditionally "
"as above."
msgstr ""

#: ../../library/_thread.rst:176
msgid ""
"If the floating-point *timeout* argument is present and positive, it "
"specifies the maximum wait time in seconds before returning.  A negative "
"*timeout* argument specifies an unbounded wait.  You cannot specify a "
"*timeout* if *blocking* is false."
msgstr ""

#: ../../library/_thread.rst:181
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not."
msgstr ""
"なお、ロックを獲得できた場合は ``True``、できなかった場合は ``False`` を返し"
"ます。"

#: ../../library/_thread.rst:184
msgid "The *timeout* parameter is new."
msgstr "新しい *timeout* 引数。"

#: ../../library/_thread.rst:187
msgid "Lock acquires can now be interrupted by signals on POSIX."
msgstr "POSIX ではロックの取得がシグナルに割り込まれるようになりました。"

#: ../../library/_thread.rst:193
msgid ""
"Releases the lock.  The lock must have been acquired earlier, but not "
"necessarily by the same thread."
msgstr ""
"ロックを解放します。そのロックは既に獲得されたものでなければなりませんが、し"
"かし同じスレッドによって獲得されたものである必要はありません。"

#: ../../library/_thread.rst:199
msgid ""
"Return the status of the lock: ``True`` if it has been acquired by some "
"thread, ``False`` if not."
msgstr ""
"ロックの状態を返します: 同じスレッドによって獲得されたものなら ``True`` 、違"
"うのなら ``False`` を返します。"

#: ../../library/_thread.rst:202
msgid ""
"In addition to these methods, lock objects can also be used via the :keyword:"
"`with` statement, e.g.::"
msgstr ""
"これらのメソッドに加えて、ロックオブジェクトは :keyword:`with` 文を通じて以下"
"の例のように使うこともできます。 ::"

#: ../../library/_thread.rst:205
msgid ""
"import _thread\n"
"\n"
"a_lock = _thread.allocate_lock()\n"
"\n"
"with a_lock:\n"
"    print(\"a_lock is locked while this executes\")"
msgstr ""

#: ../../library/_thread.rst:212
msgid "**Caveats:**"
msgstr "**警告:**"

#: ../../library/_thread.rst:216
msgid ""
"Threads interact strangely with interrupts: the :exc:`KeyboardInterrupt` "
"exception will be received by an arbitrary thread.  (When the :mod:`signal` "
"module is available, interrupts always go to the main thread.)"
msgstr ""
"スレッドは割り込みと奇妙な相互作用をします: :exc:`KeyboardInterrupt` 例外は任"
"意のスレッドによって受け取られます。 (:mod:`signal` モジュールが利用可能なと"
"き、割り込みは常にメインスレッドへ行きます。)"

#: ../../library/_thread.rst:220
msgid ""
"Calling :func:`sys.exit` or raising the :exc:`SystemExit` exception is "
"equivalent to calling :func:`_thread.exit`."
msgstr ""
":func:`sys.exit` を呼び出す、あるいは :exc:`SystemExit` 例外を送出すること"
"は、 :func:`_thread.exit` を呼び出すことと同じです。"

#: ../../library/_thread.rst:223
msgid ""
"It is not possible to interrupt the :meth:`~threading.Lock.acquire` method "
"on a lock --- the :exc:`KeyboardInterrupt` exception will happen after the "
"lock has been acquired."
msgstr ""

#: ../../library/_thread.rst:227
msgid ""
"When the main thread exits, it is system defined whether the other threads "
"survive.  On most systems, they are killed without executing :keyword:"
"`try` ... :keyword:`finally` clauses or executing object destructors."
msgstr ""
"メインスレッドが終了したとき、他のスレッドが生き残るかどうかは、システムに依"
"存します。多くのシステムでは、 :keyword:`try` ... :keyword:`finally` 節や、オ"
"ブジェクトデストラクタを実行せずに終了されます。"

#: ../../library/_thread.rst:232
msgid ""
"When the main thread exits, it does not do any of its usual cleanup (except "
"that :keyword:`try` ... :keyword:`finally` clauses are honored), and the "
"standard I/O files are not flushed."
msgstr ""
"メインスレッドが終了したとき、それの通常のクリーンアップは行なわれず、 (:"
"keyword:`try` ... :keyword:`finally` 節が尊重されることは除きます)、標準 I/O "
"ファイルはフラッシュされません。"

#: ../../library/_thread.rst:7
msgid "light-weight processes"
msgstr "light-weight processes"

#: ../../library/_thread.rst:7
msgid "processes, light-weight"
msgstr "processes, light-weight"

#: ../../library/_thread.rst:7
msgid "binary semaphores"
msgstr "binary semaphores"

#: ../../library/_thread.rst:7
msgid "semaphores, binary"
msgstr "semaphores, binary"

#: ../../library/_thread.rst:22
msgid "pthreads"
msgstr "pthreads"

#: ../../library/_thread.rst:22
msgid "threads"
msgstr "threads"

#: ../../library/_thread.rst:22
msgid "POSIX"
msgstr "POSIX"

#: ../../library/_thread.rst:214
msgid "module"
msgstr "module"

#: ../../library/_thread.rst:214
msgid "signal"
msgstr "signal"
