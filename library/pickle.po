# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Osamu NAKAMURA, 2021
# mollinaca, 2021
# Masaaki Kobashi <murmur2winzcud37dle@gmail.com>, 2021
# tomo, 2021
# Takeshi Nakazato, 2022
# Takanori Suzuki <takanori@takanory.net>, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-24 14:15+0000\n"
"PO-Revision-Date: 2021-06-28 01:11+0000\n"
"Last-Translator: Takanori Suzuki <takanori@takanory.net>, 2023\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ":mod:`pickle` --- Python オブジェクトの直列化"

#: ../../library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**ソースコード:** :source:`Lib/pickle.py`"

#: ../../library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and "
"*\"unpickling\"* is the inverse operation, whereby a byte stream (from a :"
"term:`binary file` or :term:`bytes-like object`) is converted back into an "
"object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
":mod:`pickle` モジュールは Python オブジェクトの直列化および直列化されたオブ"
"ジェクトの復元のためのバイナリプロトコルを実装しています。*\"Pickle 化\"* は "
"Python オブジェクト階層をバイトストリームに変換する処理、*\"非 pickle 化\"* "
"は (:term:`バイナリファイル <binary file>` または :term:`バイトライクオブジェ"
"クト <bytes-like object>` から) バイトストリームをオブジェクト階層に復元する"
"処理を意味します。pickle 化 (および非 pickle 化) は \"直列化 "
"(serialization)\"、\"整列化 (marshalling)\"、あるいは [#]_ \"平坦化 "
"(flattening)\" とも呼ばれますが、混乱を避けるため、ここでは \"Pickle 化"
"\"、\"非 pickle 化\" で統一します。"

#: ../../library/pickle.rst:33
msgid "The ``pickle`` module **is not secure**. Only unpickle data you trust."
msgstr ""
"``pickle``モジュールは **安全ではありません** 。信頼できるデータのみを非 "
"pickle 化してください。"

#: ../../library/pickle.rst:35
msgid ""
"It is possible to construct malicious pickle data which will **execute "
"arbitrary code during unpickling**. Never unpickle data that could have come "
"from an untrusted source, or that could have been tampered with."
msgstr ""
"**非 pickle 化の過程で任意のコードを実行する** ような、悪意ある pickle オブ"
"ジェクトを生成することが可能です。信頼できない提供元からのデータや、改竄され"
"た可能性のあるデータの非 pickle 化は絶対に行わないでください。"

#: ../../library/pickle.rst:39
msgid ""
"Consider signing data with :mod:`hmac` if you need to ensure that it has not "
"been tampered with."
msgstr ""
"データが改竄されていないことを保証したい場合は、 :mod:`hmac` による鍵付きハッ"
"シュ化を検討してください。"

#: ../../library/pickle.rst:42
msgid ""
"Safer serialization formats such as :mod:`json` may be more appropriate if "
"you are processing untrusted data. See :ref:`comparison-with-json`."
msgstr ""
"信頼できないデータを処理する場合 :mod:`json` のようなより安全な直列化形式の方"
"が適切でしょう。 :ref:`comparison-with-json` を参照してください。"

#: ../../library/pickle.rst:47
msgid "Relationship to other Python modules"
msgstr "他の Python モジュールとの関係"

#: ../../library/pickle.rst:50
msgid "Comparison with ``marshal``"
msgstr "``marshal`` との比較"

#: ../../library/pickle.rst:52
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's :file:`."
"pyc` files."
msgstr ""
"Python には :mod:`marshal` と呼ばれるより原始的な直列化モジュールがあります"
"が、一般的に Python オブジェクトを直列化する方法としては :mod:`pickle` を選ぶ"
"べきです。 :mod:`marshal` は基本的に :file:`.pyc` ファイルをサポートするため"
"に存在しています。"

#: ../../library/pickle.rst:57
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ""
":mod:`pickle` モジュールはいくつかの点で :mod:`marshal` と明確に異なります:"

#: ../../library/pickle.rst:59
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""
":mod:`pickle` モジュールでは、同じオブジェクトが再度直列化されることのないよ"
"う、すでに直列化されたオブジェクトについて追跡情報を保持します。 :mod:"
"`marshal` はこれを行いません。"

#: ../../library/pickle.rst:63
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"この機能は再帰的オブジェクトと共有オブジェクトの両方に重要な関わりをもってい"
"ます。再帰的オブジェクトとは自分自身に対する参照を持っているオブジェクトで"
"す。再帰的オブジェクトは marshal で扱うことができず、実際、再帰的オブジェクト"
"を marshal 化しようとすると Python インタプリタをクラッシュさせてしまいます。"
"共有オブジェクトは、直列化しようとするオブジェクト階層の異なる複数の場所で同"
"じオブジェクトに対する参照が存在する場合に生じます。共有オブジェクトを共有の"
"ままにしておくことは、変更可能なオブジェクトの場合には非常に重要です。"

#: ../../library/pickle.rst:72
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` はユーザ定義クラスやそのインスタンスを直列化するために使うこと"
"ができません。 :mod:`pickle` はクラスインスタンスを透過的に保存したり復元した"
"りすることができますが、クラス定義をインポートすることが可能で、かつオブジェ"
"クトが保存された際と同じモジュールで定義されていなければなりません。"

#: ../../library/pickle.rst:77
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support :file:"
"`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise. "
"The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases provided a compatible pickle protocol is "
"chosen and pickling and unpickling code deals with Python 2 to Python 3 type "
"differences if your data is crossing that unique breaking change language "
"boundary."
msgstr ""
":mod:`marshal` の直列化形式は Python のバージョン間での移植性を保証していませ"
"ん。  :file:`.pyc` ファイルをサポートすることが主な役割であるため、 Python 開"
"発者は必要があれば直列化形式に非互換な変更を加える権利を有しています。 いっぽ"
"う :mod:`pickle` の直列化形式は、互換性のあるプロトコルを選ぶという条件のもと"
"で Python リリース間の後方互換性が保証されます。また処理すべきデータが "
"Python 2 と Python 3 の間で非互換な型を含む場合も、 pickle 化および非 pickle "
"化のコードはそのような互換性を破る言語の境界を適切に取り扱います。"

#: ../../library/pickle.rst:90
msgid "Comparison with ``json``"
msgstr "``json`` との比較"

#: ../../library/pickle.rst:92
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <https://json.org>`_:"
msgstr ""
"pickle プロトコルと `JSON (JavaScript Object Notation) <https://json.org>`_ "
"との基本的な違いは以下のとおりです:"

#: ../../library/pickle.rst:95
msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""
"JSON はテキストの直列化フォーマット (大抵の場合 ``utf-8`` にエンコードされま"
"すが、その出力は Unicode 文字列です) で、pickle はバイナリの直列化フォーマッ"
"トです;"

#: ../../library/pickle.rst:99
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON は人間が読める形式ですが、pickle はそうではありません;"

#: ../../library/pickle.rst:101
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while "
"pickle is Python-specific;"
msgstr ""
"JSON は相互運用可能で Python 以外でも広く使用されていますが、pickle は "
"Python 固有です;"

#: ../../library/pickle.rst:104
msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by implementing :ref:"
"`specific object APIs <pickle-inst>`);"
msgstr ""
"JSON は、デフォルトでは Python の組み込み型の一部しか表現することができず、カ"
"スタムクラスに対しても行えません; pickle は極めて多くの Python 組み込み型を表"
"現できます (その多くは賢い Python 内省機構によって自動的に行われます; 複雑な"
"ケースでは :ref:`固有のオブジェクト API <pickle-inst>` によって対応できま"
"す)。"

#: ../../library/pickle.rst:110
msgid ""
"Unlike pickle, deserializing untrusted JSON does not in itself create an "
"arbitrary code execution vulnerability."
msgstr ""
"pickleとは異なり、信頼できないJSONを復元するだけでは、任意のコードを実行でき"
"る脆弱性は発生しません。"

#: ../../library/pickle.rst:114
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ""
":mod:`json` モジュール: JSON への直列化および復元を行うための標準ライブラリモ"
"ジュール。"

#: ../../library/pickle.rst:121
msgid "Data stream format"
msgstr "データストリームの形式"

#: ../../library/pickle.rst:126
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON or XDR (which can't represent pointer sharing); however it means "
"that non-Python programs may not be able to reconstruct pickled Python "
"objects."
msgstr ""
":mod:`pickle` によって使用されるデータフォーマットは Python 固有です。これ"
"は、JSON や XDR のような外部標準によって (例えばポインター共有を表わすことが"
"できないといったような) 制限を受けることがないという利点があります; ただし、"
"これは非 Python プログラムが pickle された Python オブジェクトを再構成するこ"
"とができないということも意味します。"

#: ../../library/pickle.rst:131
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"デフォルトでは、:mod:`pickle` データフォーマットは比較的コンパクトなバイナリ"
"表現を使用します。サイズの抑制目的の最適化が必要なら、pickle されたデータを効"
"率的に :doc:`圧縮する <archiving>` ことができます。"

#: ../../library/pickle.rst:135
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""
":mod:`pickletools` モジュールには :mod:`pickle` によって生成されたデータスト"
"リームを解析するためのツールが含まれます。:mod:`pickletools` のソースコードに"
"は、pickle プロトコルで使用される命令コードに関する詳細なコメントがあります。"

#: ../../library/pickle.rst:139
msgid ""
"There are currently 6 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr ""
"現在 pickle 化には 6 種類のプロトコルを使用できます。より高いプロトコルを使用"
"するほど、作成された pickle を読み込むためにより高い Python のバージョンが必"
"要になります。"

#: ../../library/pickle.rst:143
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr ""
"プロトコルバージョン 0 はオリジナルの「人間に判読可能な」プロトコルで、"
"Python の初期のバージョンとの後方互換性を持ちます。"

#: ../../library/pickle.rst:146
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr ""
"プロトコルバージョン 1 は旧形式のバイナリフォーマットで、これも Python の初期"
"バージョンと互換性があります。"

#: ../../library/pickle.rst:149
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style classes <new-style class>`.  Refer "
"to :pep:`307` for information about improvements brought by protocol 2."
msgstr ""
"プロトコルバージョン 2 は Python 2.3 で導入されました。このバージョンでは :"
"term:`新方式のクラス <new-style class>` のより効率的な pickle 化を提供しまし"
"た。プロトコル 2 による改良に関する情報は :pep:`307` を参照してください。"

#: ../../library/pickle.rst:153
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for :"
"class:`bytes` objects and cannot be unpickled by Python 2.x.  This was the "
"default protocol in Python 3.0--3.7."
msgstr ""
"プロトコルバージョン 3 は Python 3 で追加されました。 :class:`bytes` オブジェ"
"クトを明示的にサポートしており、 Python 2.x で unpickle することはできませ"
"ん。これは Python 3.0から3.7のデフォルトプロトコルでした。"

#: ../../library/pickle.rst:157
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format "
"optimizations.  It is the default protocol starting with Python 3.8. Refer "
"to :pep:`3154` for information about improvements brought by protocol 4."
msgstr ""
"プロトコルバージョン 4 は Python 3.4 で追加されました。このバージョンでは巨大"
"なオブジェクトのサポート、より多くの種類のオブジェクトの pickle 化、および一"
"部のデータ形式の最適化が行われました。これはPython 3.8からのデフォルトプロト"
"コルです。プロトコル 4 による改良に関する情報は :pep:`3154` を参照してくださ"
"い。"

#: ../../library/pickle.rst:163
msgid ""
"Protocol version 5 was added in Python 3.8.  It adds support for out-of-band "
"data and speedup for in-band data.  Refer to :pep:`574` for information "
"about improvements brought by protocol 5."
msgstr ""
"プロトコルバージョン 5 は Python 3.8 で追加されました。このバージョンでは帯域"
"外データのサポートが追加され、また帯域内データに対するパフォーマンスが向上し"
"ます。プロトコルバージョン 5 によってもたらされる改善についての情報は :pep:"
"`574` を参照してください。"

#: ../../library/pickle.rst:168
msgid ""
"Serialization is a more primitive notion than persistence; although :mod:"
"`pickle` reads and writes file objects, it does not handle the issue of "
"naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"直列化は永続性より原始的な概念です。 :mod:`pickle` はファイルオブジェクトの読"
"み書きを行いますが、永続オブジェクトの命名に関する問題にも、(さらに困難な) 永"
"続オブジェクトへの並列アクセスに関する問題にも対応しません。:mod:`pickle` モ"
"ジュールは複雑なオブジェクトをバイトストリームに変換し、バイトストリームから"
"同じ内部構造のオブジェクトに復元することができます。これらのバイトストリーム"
"はファイルに出力されることが多いでしょうが、ネットワークを介して送信したり、"
"データベースに格納することもありえます。:mod:`shelve` モジュールは、オブジェ"
"クトを DBM 方式のデータベースファイル上で pickle 化および非 pickle 化するシン"
"プルなインターフェースを提供します。"

#: ../../library/pickle.rst:181
msgid "Module Interface"
msgstr "モジュールインターフェース"

#: ../../library/pickle.rst:183
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the :func:"
"`loads` function. However, if you want more control over serialization and "
"de-serialization, you can create a :class:`Pickler` or an :class:`Unpickler` "
"object, respectively."
msgstr ""
"オブジェクト階層を直列化するには、:func:`dumps` 関数を呼ぶだけです。同様に、"
"データストリームを復元するには、:func:`loads` 関数を呼びます。しかし、直列化"
"および復元に対してより多くのコントロールを行いたい場合、それぞれ :class:"
"`Pickler` または :class:`Unpickler` オブジェクトを作成することができます。"

#: ../../library/pickle.rst:188
msgid "The :mod:`pickle` module provides the following constants:"
msgstr ":mod:`pickle` モジュールは以下の定数を提供しています:"

#: ../../library/pickle.rst:193
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions :"
"func:`dump` and :func:`dumps` as well as the :class:`Pickler` constructor."
msgstr ""
"利用可能なうち最も高い :ref:`プロトコルバージョン <pickle-protocols>` (整"
"数)。この値は *protocol* 値として関数 :func:`dump`  および :func:`dumps` "
"と、:class:`Pickler` コンストラクターに渡すことができます。"

#: ../../library/pickle.rst:200
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default "
"protocol is 4, first introduced in Python 3.4 and incompatible with previous "
"versions."
msgstr ""
"pickle化に使われるデフォルトの :ref:`プロトコルバージョン <pickle-"
"protocols>` (整数)。`HIGHEST_PROTOCOL`よりも小さい場合があります。現在のデ"
"フォルトプロトコルは4です。このプロトコルはPython3.4で初めて導入され、その前"
"のバージョンとは互換性がありません。"

#: ../../library/pickle.rst:207
msgid "The default protocol is 3."
msgstr "デフォルトプロトコルは 3 です。"

#: ../../library/pickle.rst:211
msgid "The default protocol is 4."
msgstr "デフォルトプロトコルは 4 です。"

#: ../../library/pickle.rst:213
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ""
"この pickle 化の手続きを便利にするために、 :mod:`pickle` モジュールでは以下の"
"関数を提供しています:"

#: ../../library/pickle.rst:218
msgid ""
"Write the pickled representation of the object *obj* to the open :term:`file "
"object` *file*.  This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""
"オブジェクト *obj* を pickle 化し、すでにオープンしている :term:`ファイルオブ"
"ジェクト <file object>` *file* に書き込みます。``Pickler(file, protocol)."
"dump(obj)`` と等価です。"

#: ../../library/pickle.rst:222
msgid ""
"Arguments *file*, *protocol*, *fix_imports* and *buffer_callback* have the "
"same meaning as in the :class:`Pickler` constructor."
msgstr ""
"引数 *file*, *protocol*, *fix_imports* および *buffer_callback* は :class:"
"`Pickler` のコンストラクタと同じ意味になります。"

#: ../../library/pickle.rst:225 ../../library/pickle.rst:236
#: ../../library/pickle.rst:328
msgid "The *buffer_callback* argument was added."
msgstr "*buffer_callback* 引数が追加されました。"

#: ../../library/pickle.rst:230
msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr ""
"ファイルに書く代わりに、:class:`bytes` オブジェクトとしてオブジェクト *obj* "
"の pickle 表現を返します。"

#: ../../library/pickle.rst:233
msgid ""
"Arguments *protocol*, *fix_imports* and *buffer_callback* have the same "
"meaning as in the :class:`Pickler` constructor."
msgstr ""
"引数 *protocol*, *fix_imports* および *buffer_callback* は :class:`Pickler` "
"のコンストラクタと同じ意味になります。"

#: ../../library/pickle.rst:241
msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"あるオブジェクトの pickle 化表現を、オープンしている :term:`ファイルオブジェ"
"クト <file object>` *file* から読み込み、その中で指定されているオブジェクト階"
"層に再構成して返します。これは ``Unpickler(file).load()`` と等価です。"

#: ../../library/pickle.rst:245 ../../library/pickle.rst:260
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed.  Bytes past the pickled representation of the object are "
"ignored."
msgstr ""
"pickle のプロトコルバージョンは自動的に検出されます。したがって protocol 引数"
"は必要ありません。pickle 化オブジェクト表現より後のバイト列は無視されます。"

#: ../../library/pickle.rst:249
msgid ""
"Arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* and "
"*buffers* have the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"引数 *file*, *fix_imports*, *encoding*, *errors*, *strict* および *buffers* "
"は :class:`Unpickler` のコンストラクタと同じ意味になります。"

#: ../../library/pickle.rst:252 ../../library/pickle.rst:267
#: ../../library/pickle.rst:429
msgid "The *buffers* argument was added."
msgstr "*buffers* 引数が追加されました。"

#: ../../library/pickle.rst:257
msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*data* of an object. *data* must be a :term:`bytes-like object`."
msgstr ""
"オブジェクトのピックル化表現 *data* から再構成されたオブジェクト階層を返しま"
"す。 *data* は バイトライクオブジェクト (:term:`bytes-like object`) でなけれ"
"ばなりません。"

#: ../../library/pickle.rst:264
msgid ""
"Arguments *fix_imports*, *encoding*, *errors*, *strict* and *buffers* have "
"the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"引数 *fix_imports*, *encoding*, *errors*, *strict* および *buffers* は :"
"class:`Unpickler` のコンストラクタと同じ意味になります。"

#: ../../library/pickle.rst:271
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr ":mod:`pickle` モジュールでは 3 つの例外を定義しています:"

#: ../../library/pickle.rst:275
msgid ""
"Common base class for the other pickling exceptions.  It inherits :exc:"
"`Exception`."
msgstr ""
"他の pickle 化例外の共通基底クラス。:exc:`Exception` を継承しています。"

#: ../../library/pickle.rst:280
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits :exc:`PickleError`."
msgstr ""
":class:`Pickler` が pickle 化不可能なオブジェクトに遭遇したときに送出されるエ"
"ラー。:exc:`PickleError` を継承しています。"

#: ../../library/pickle.rst:283
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr ""
"どんな種類のオブジェクトが pickle 化できるのか確認するには :ref:`pickle-"
"picklable` を参照してください。"

#: ../../library/pickle.rst:288
msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits :exc:`PickleError`."
msgstr ""
"データ破損やセキュリティ違反のような、オブジェクトを非 pickle 化するのに問題"
"がある場合に送出されるエラー。:exc:`PickleError` を継承します。"

#: ../../library/pickle.rst:291
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""
"非 picke 化の最中に他の例外が送出されることもあるので注意してください。これに"
"は AttributeError, EOFError, ImportError, IndexError が含まれます (ただし必ず"
"しもこれらに限定されません)。"

#: ../../library/pickle.rst:296
msgid ""
"The :mod:`pickle` module exports three classes, :class:`Pickler`, :class:"
"`Unpickler` and :class:`PickleBuffer`:"
msgstr ""
":mod:`pickle` モジュールでは、3 つのクラス :class:`Pickler`, :class:"
"`Unpickler` および :class:`PickleBuffer` を提供しています:"

#: ../../library/pickle.rst:301
msgid "This takes a binary file for writing a pickle data stream."
msgstr ""
"pickle 化されたオブジェクトのデータストリームを書き込むためのバイナリファイル"
"を引数にとります。"

#: ../../library/pickle.rst:303
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"任意の引数 *protocol* は、整数で、pickle 化で使用するプロトコルを指定します; "
"サポートされているプロトコルは 0 から :data:`HIGHEST_PROTOCOL` までになりま"
"す。指定されない場合、:data:`DEFAULT_PROTOCOL` が使用されます。負数が与えられ"
"た場合、:data:`HIGHEST_PROTOCOL` が使用されます。"

#: ../../library/pickle.rst:308
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, an :"
"class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""
"引数 *file* は、1 バイトの引数一つを受け付ける write() メソッドを持たなければ"
"なりません。すなわち、*file* には、バイナリの書き込み用にオープンされたファイ"
"ルオブジェクト、:class:`io.BytesIO` オブジェクト、このインターフェースに適合"
"するその他のカスタムオブジェクトをとることができます。"

#: ../../library/pickle.rst:313
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that "
"the pickle data stream is readable with Python 2."
msgstr ""
"*fix_imports* が真であり、かつ、*protocol* が 3 未満の場合、pickle は新しい "
"Python 3 の名前と Python 2 で使用されていた古いモジュール名との対応付けを試み"
"るので、pickle データストリームは Python 2 でも読み込み可能です。"

#: ../../library/pickle.rst:317
msgid ""
"If *buffer_callback* is None (the default), buffer views are serialized into "
"*file* as part of the pickle stream."
msgstr ""
"*buffer_callback* が None (デフォルト) の場合、バッファビューはストリームの一"
"部として*file* 中に直列化されます。"

#: ../../library/pickle.rst:320
msgid ""
"If *buffer_callback* is not None, then it can be called any number of times "
"with a buffer view.  If the callback returns a false value (such as None), "
"the given buffer is :ref:`out-of-band <pickle-oob>`; otherwise the buffer is "
"serialized in-band, i.e. inside the pickle stream."
msgstr ""
"*buffer_callback* が None でない場合、バッファビューを引数として何度でも呼び"
"出すことができる関数です。コールバック関数が偽値 (None など) を返すと、与えら"
"れたバッファは :ref:`アウトオブバウンド管理 (out-of-band) <pickle-oob>` とな"
"ります; そうでない場合はインバンドで、すなわち pickle ストリーム内で、直列化"
"されます。"

#: ../../library/pickle.rst:325
msgid ""
"It is an error if *buffer_callback* is not None and *protocol* is None or "
"smaller than 5."
msgstr ""
"*buffer_callback* が None でなく、かつ *protocol* が None または 5 より小さい"
"場合はエラーとなります。"

#: ../../library/pickle.rst:333
msgid ""
"Write the pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr ""
"*obj* の pickle 化表現を、コンストラクターで与えられた、すでにオープンしてい"
"るファイルオブジェクトに書き込みます。"

#: ../../library/pickle.rst:338
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr ""
"デフォルトでは何もしません。このメソッドはサブクラスがオーバーライドできるよ"
"うに存在します。"

#: ../../library/pickle.rst:340
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
":meth:`persistent_id` が ``None`` を返す場合、通常通り *obj* が pickle 化され"
"ます。それ以外の値を返した場合、:class:`Pickler` がその値を *obj* のために永"
"続的な ID として出力するようになります。この永続的な ID の意味は :meth:"
"`Unpickler.persistent_load` によって定義されています。:meth:`persistent_id` "
"によって返された値自身は永続的な ID を持つことができないことに注意してくださ"
"い。"

#: ../../library/pickle.rst:346 ../../library/pickle.rst:447
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr ""
"詳細および使用例については :ref:`pickle-persistent` を参照してください。"

#: ../../library/pickle.rst:350
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`__reduce__` method."
msgstr ""
"pickler オブジェクトのディスパッチテーブルは :func:`copyreg.pickle` を使用し"
"て宣言できる種類の *reduction functions* のレジストリです。これはキーがクラス"
"でその値が減少関数のマッピング型オブジェクトです。減少関数は関連するクラスの"
"引数を 1 個とり、:meth:`__reduce__` メソッドと同じインターフェースでなければ"
"なりません。"

#: ../../library/pickle.rst:358
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by the :"
"mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has a :attr:"
"`dispatch_table` attribute then this will be used as the default dispatch "
"table for instances of that class."
msgstr ""
"デフォルトでは、pickler オブジェクトは :attr:`dispatch_table` 属性を持たず、"
"代わりに :mod:`copyreg` モジュールによって管理されるグローバルなディスパッチ"
"テーブルを使用します。しかし、特定の pickler オブジェクトによる pickle 化をカ"
"スタマイズするために :attr:`dispatch_table` 属性に dict-like オブジェクトを設"
"定することができます。あるいは、:class:`Pickler` のサブクラスが :attr:"
"`dispatch_table` 属性を持てば、そのクラスのインスタンスに対するデフォルトの"
"ディスパッチテーブルとして使用されます。"

#: ../../library/pickle.rst:367
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "使用例については :ref:`pickle-dispatch` を参照してください。"

#: ../../library/pickle.rst:373
msgid ""
"Special reducer that can be defined in :class:`Pickler` subclasses. This "
"method has priority over any reducer in the :attr:`dispatch_table`.  It "
"should conform to the same interface as a :meth:`__reduce__` method, and can "
"optionally return ``NotImplemented`` to fallback on :attr:`dispatch_table`-"
"registered reducers to pickle ``obj``."
msgstr ""
":class:`Pickler` のサブクラスで定義可能な特殊なリデューサ (reducer) です。こ"
"のメソッドは :attr:`dispatch_table` 内のいかなるリデューサよりも優先されま"
"す。このメソッドは :meth:`__reduce__` メソッドのインターフェースと適合してい"
"なければなりません。また、メソッドが ``NotImplemented`` を返すことにより、 :"
"attr:`dispatch_table` に登録されたリデューサにフォールバックして ``obj`` を直"
"列化することもできます。"

#: ../../library/pickle.rst:379
msgid "For a detailed example, see :ref:`reducer_override`."
msgstr "詳細な例については、 :ref:`reducer_override` を参照してください。"

#: ../../library/pickle.rst:385
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables "
"the usage of memo, therefore speeding the pickling process by not generating "
"superfluous PUT opcodes.  It should not be used with self-referential "
"objects, doing otherwise will cause :class:`Pickler` to recurse infinitely."
msgstr ""
"廃止予定です。真値が設定されれば高速モードを有効にします。高速モードは、メモ"
"の使用を無効にします。それにより余分な PUT 命令コードを生成しなくなるので "
"pickle 化処理が高速化します。自己参照オブジェクトに対しては使用すべきではあり"
"ません。さもなければ :class:`Pickler` に無限再帰を起こさせるでしょう。"

#: ../../library/pickle.rst:391
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr ""
"よりコンパクトな pickle 化を必要とする場合は、:func:`pickletools.optimize` を"
"使用してください。"

#: ../../library/pickle.rst:396
msgid "This takes a binary file for reading a pickle data stream."
msgstr ""
"これは pickle データストリームの読み込みのためにバイナリファイルをとります。"

#: ../../library/pickle.rst:398
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed."
msgstr ""
"pickle のプロトコルバージョンは自動的に検出されます。したがって protocol 引数"
"は必要ありません。"

#: ../../library/pickle.rst:401
msgid ""
"The argument *file* must have three methods, a read() method that takes an "
"integer argument, a readinto() method that takes a buffer argument and a "
"readline() method that requires no arguments, as in the :class:`io."
"BufferedIOBase` interface.  Thus *file* can be an on-disk file opened for "
"binary reading, an :class:`io.BytesIO` object, or any other custom object "
"that meets this interface."
msgstr ""
"引数 *file* は :class:`io.BufferedIOBase` のインターフェースと同様に、整数を"
"引数にとる read() 、バッファを引数にとる readinto() 、引数を取らない "
"readline() の3つのメソッドを持たなければなりません。したがって、 *file* はバ"
"イナリ読み込みモードでオープンされたディスク上のファイル、 :class:`io."
"BytesIO` オブジェクト、または上記インターフェース要件を満たす任意のカスタムオ"
"ブジェクトのいずれかです。"

#: ../../library/pickle.rst:408
msgid ""
"The optional arguments *fix_imports*, *encoding* and *errors* are used to "
"control compatibility support for pickle stream generated by Python 2. If "
"*fix_imports* is true, pickle will try to map the old Python 2 names to the "
"new names used in Python 3.  The *encoding* and *errors* tell pickle how to "
"decode 8-bit string instances pickled by Python 2; these default to 'ASCII' "
"and 'strict', respectively.  The *encoding* can be 'bytes' to read these 8-"
"bit string instances as bytes objects. Using ``encoding='latin1'`` is "
"required for unpickling NumPy arrays and instances of :class:`~datetime."
"datetime`, :class:`~datetime.date` and :class:`~datetime.time` pickled by "
"Python 2."
msgstr ""
"オプション引数 *fix_imports*, *encoding* および *errors* はPython 2で生成され"
"た pickle ストリームに対する互換性サポートを制御するために使われます。 "
"*fix_imports* が真の場合、 pickle は古い Python 2 の名前を Python 3 の新しい"
"名前に対応づけようとします。 *encoding* と *errors* は pickle に Python 2 "
"で  pickle 化された 8 ビット文字列をデコードする方法を指定します; これらの引"
"数のデフォルト値はそれぞれ 'ASCII' と 'strict' です。 *encoding* は 8 ビット"
"文字列インスタンスをバイトオブジェクトとして読み込む場合は 'bytes' を指定しま"
"す。  Python 2 で pickle 化された NumPy 配列および :class:`~datetime."
"datetime`, :class:`~datetime.date`, :class:`~datetime.time` の各インスタンス"
"を非 pickle 化するためには ``encoding='latin1'`` を使う必要があります。"

#: ../../library/pickle.rst:419
msgid ""
"If *buffers* is None (the default), then all data necessary for "
"deserialization must be contained in the pickle stream.  This means that the "
"*buffer_callback* argument was None when a :class:`Pickler` was instantiated "
"(or when :func:`dump` or :func:`dumps` was called)."
msgstr ""
"*buffers* が None (デフォルト値) の場合、非直列化に必要な全てのデータは "
"pickle ストリームに含まれている必要があります。これは :class:`Pickler` がイン"
"スタンス化されたとき (または :func:`dump` や :func:`dumps` が呼び出されたと"
"き) に *buffer_callback* 引数に None を指定したことに相当します。"

#: ../../library/pickle.rst:424
msgid ""
"If *buffers* is not None, it should be an iterable of buffer-enabled objects "
"that is consumed each time the pickle stream references an :ref:`out-of-band "
"<pickle-oob>` buffer view.  Such buffers have been given in order to the "
"*buffer_callback* of a Pickler object."
msgstr ""
"*buffers* が None でない場合、各イテレーションで :ref:`アウトオブバウンド "
"(out-of-band) <pickle-oob>` のバッファビューを参照する pickle ストリームを消"
"費する、バッファ対応のイテラブルでなければなりません。ここに指定するバッファ"
"は Pickler オブジェクトの *buffer_callback* に順番に渡されたものです。"

#: ../../library/pickle.rst:434
msgid ""
"Read the pickled representation of an object from the open file object given "
"in the constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled representation of the object are ignored."
msgstr ""
"コンストラクターで与えられたオープンしたファイルオブジェクトからオブジェクト"
"の pickle 化表現を読み込み、その中で指定されたオブジェクト階層に再構成して返"
"します。オブジェクトの pickle 化表現より後のバイト列は無視されます。"

#: ../../library/pickle.rst:441
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "デフォルトで :exc:`UnpicklingError` を送出します。"

#: ../../library/pickle.rst:443
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an :"
"exc:`UnpicklingError` should be raised."
msgstr ""
"もし定義されていれば、:meth:`persistent_load` は永続的な ID *pid* によって指"
"定されたオブジェクトを返す必要があります。永続的な ID が無効な場合、:exc:"
"`UnpicklingError` を送出しなければなりません。"

#: ../../library/pickle.rst:451
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"必要なら *module* をインポートして、そこから *name* という名前のオブジェクト"
"を返します。ここで *module* および *name* 引数は :class:`str` オブジェクトで"
"す。その名前が示唆することに反して :meth:`find_class` は関数を探すためにも使"
"われることに注意してください。"

#: ../../library/pickle.rst:456
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to :ref:"
"`pickle-restrict` for details."
msgstr ""
"サブクラスは、どんな型のオブジェクトを、どのようにロードするか (潜在的にはセ"
"キュリティリスクの減少) に関する制御を得るためにこれをオーバーライドすること"
"ができます。詳細に関しては :ref:`pickle-restrict` を参照してください。"

#: ../../library/pickle.rst:460
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pickle.find_class`` with "
"arguments ``module``, ``name``."
msgstr ""
"引数 ``modulet``, ``name`` を指定して :ref:`監査イベント <auditing>` "
"``pickle.find_class`` を送出します。 "

#: ../../library/pickle.rst:464
msgid ""
"A wrapper for a buffer representing picklable data.  *buffer* must be a :ref:"
"`buffer-providing <bufferobjects>` object, such as a :term:`bytes-like "
"object` or a N-dimensional array."
msgstr ""
"pickle 可能なデータをあらわすバッファのラッパーです。 *buffer* はバッファライ"
"クなオブジェクト (:term:`bytes-like object`) や N 次元配列のような :ref:`バッ"
"ファ機能を提供する <bufferobjects>` オブジェクトでなければなりません。"

#: ../../library/pickle.rst:468
msgid ""
":class:`PickleBuffer` is itself a buffer provider, therefore it is possible "
"to pass it to other APIs expecting a buffer-providing object, such as :class:"
"`memoryview`."
msgstr ""
":class:`PickleBuffer` はそれ自身バッファ機能を提供します。したがってこのクラ"
"スのインスタンスを、バッファ機能を提供するオブジェクトを期待する :class:"
"`memoryview` など他の API に渡すことが可能です。"

#: ../../library/pickle.rst:472
msgid ""
":class:`PickleBuffer` objects can only be serialized using pickle protocol 5 "
"or higher.  They are eligible for :ref:`out-of-band serialization <pickle-"
"oob>`."
msgstr ""
":class:`PickleBuffer` オブジェクトはプロトコル 5 以上でのみ直列化可能で、 :"
"ref:`アウトオブバウンド (out-of-band) の直列化 <pickle-oob>` に対応していま"
"す。"

#: ../../library/pickle.rst:480
msgid ""
"Return a :class:`memoryview` of the memory area underlying this buffer. The "
"returned object is a one-dimensional, C-contiguous memoryview with format "
"``B`` (unsigned bytes).  :exc:`BufferError` is raised if the buffer is "
"neither C- nor Fortran-contiguous."
msgstr ""
"このバッファの背後にあるメモリ領域への :class:`memoryview` を返します。戻り値"
"のオブジェクトはフォーマット ``B`` (符号なしバイト) の C-連続な1次元のメモリ"
"ビューです。バッファが C-連続でも Fortran-連続でもない場合 :exc:"
"`BufferError` 例外が送出されます。"

#: ../../library/pickle.rst:487
msgid "Release the underlying buffer exposed by the PickleBuffer object."
msgstr ""
"PickleBuffer オブジェクトを通じてアクセスされる背後のバッファを解放します。"

#: ../../library/pickle.rst:493
msgid "What can be pickled and unpickled?"
msgstr "pickle 化、非 pickle 化できるもの"

#: ../../library/pickle.rst:495
msgid "The following types can be pickled:"
msgstr "以下の型は pickle 化できます:"

#: ../../library/pickle.rst:497
msgid "``None``, ``True``, and ``False``;"
msgstr "``None`` 、 ``True`` 、および ``False``"

#: ../../library/pickle.rst:499
msgid "integers, floating-point numbers, complex numbers;"
msgstr "整数、浮動小数点数、複素数"

#: ../../library/pickle.rst:501
msgid "strings, bytes, bytearrays;"
msgstr "文字列、バイト列、バイト配列"

#: ../../library/pickle.rst:503
msgid ""
"tuples, lists, sets, and dictionaries containing only picklable objects;"
msgstr "pickle 化可能なオブジェクトからなるタプル、リスト、集合および辞書"

#: ../../library/pickle.rst:505
msgid ""
"functions (built-in and user-defined) accessible from the top level of a "
"module (using :keyword:`def`, not :keyword:`lambda`);"
msgstr ""
"モジュールのトップレベルで定義された関数 (:keyword:`def` で定義されたもののみ"
"で :keyword:`lambda` で定義されたものは含まない)"

#: ../../library/pickle.rst:508
msgid "classes accessible from the top level of a module;"
msgstr "モジュールのトップレベルで定義されているクラス"

#: ../../library/pickle.rst:510
msgid ""
"instances of such classes whose the result of calling :meth:`__getstate__` "
"is picklable  (see section :ref:`pickle-inst` for details)."
msgstr ""

#: ../../library/pickle.rst:513
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a :exc:"
"`RecursionError` will be raised in this case.  You can carefully raise this "
"limit with :func:`sys.setrecursionlimit`."
msgstr ""
"pickle 化できないオブジェクトを pickle 化しようとすると、:exc:"
"`PicklingError` 例外が送出されます。この例外が起きたとき、すでに元のファイル"
"には未知の長さのバイト列が書き込まれている場合があります。極端に再帰的なデー"
"タ構造を pickle 化しようとした場合には再帰の深さ制限を越えてしまうかもしれ"
"ず、この場合には :exc:`RecursionError` が送出されます。この制限は、:func:"
"`sys.setrecursionlimit` で慎重に上げていくことは可能です。"

#: ../../library/pickle.rst:520
msgid ""
"Note that functions (built-in and user-defined) are pickled by fully :term:"
"`qualified name`, not by value. [#]_  This means that only the function name "
"is pickled, along with the name of the containing module and classes.  "
"Neither the function's code, nor any of its function attributes are "
"pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""

#: ../../library/pickle.rst:527
msgid ""
"Similarly, classes are pickled by fully qualified name, so the same "
"restrictions in the unpickling environment apply.  Note that none of the "
"class's code or data is pickled, so in the following example the class "
"attribute ``attr`` is not restored in the unpickling environment::"
msgstr ""

#: ../../library/pickle.rst:537
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"at the top level of a module."
msgstr ""
"pickle 化可能な関数やクラスがモジュールのトップレベルで定義されていなければな"
"らないのはこれらの制限のためです。"

#: ../../library/pickle.rst:540
msgid ""
"Similarly, when class instances are pickled, their class's code and data are "
"not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`__setstate__` "
"method."
msgstr ""
"同様に、クラスのインスタンスが pickle 化された際、そのクラスのコードおよび"
"データはオブジェクトと一緒に pickle 化されることはありません。インスタンスの"
"データのみが pickle 化されます。この仕様は、クラス内のバグを修正したりメソッ"
"ドを追加した後でも、そのクラスの以前のバージョンで作られたオブジェクトを読み"
"出せるように意図的に行われています。あるクラスの多くのバージョンで使われるよ"
"うな長命なオブジェクトを作ろうと計画しているなら、そのクラスの :meth:"
"`__setstate__` メソッドによって適切な変換が行われるようにオブジェクトのバー"
"ジョン番号を入れておくとよいかもしれません。"

#: ../../library/pickle.rst:552
msgid "Pickling Class Instances"
msgstr "クラスインスタンスの pickle 化"

#: ../../library/pickle.rst:556
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and unpickled."
msgstr ""
"この節では、クラスインスタンスがどのように pickle 化または非 pickle 化される"
"のかを定義したり、カスタマイズしたり、コントロールしたりするのに利用可能な一"
"般的機構について説明します。"

#: ../../library/pickle.rst:559
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By "
"default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its :meth:`__init__` "
"method is usually *not* invoked.  The default behaviour first creates an "
"uninitialized instance and then restores the saved attributes.  The "
"following code shows an implementation of this behaviour::"
msgstr ""
"ほとんどの場合、インスタンスを pickle 化できるようにするために追加のコードは"
"必要ありません。デフォルトで、pickle はインスタンスのクラスと属性を内省によっ"
"て検索します。クラスインスタンスが非 pickle 化される場合、通常その :meth:"
"`__init__` メソッドは実行 *されません* 。デフォルトの振る舞いは、最初に初期化"
"されていないインスタンスを作成して、次に保存された属性を復元します。次のコー"
"ドはこの振る舞いの実装を示しています::"

#: ../../library/pickle.rst:574
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr ""
"クラスは、いくつかの特殊メソッドを提供することによって、デフォルトの振る舞い"
"を変更することができます:"

#: ../../library/pickle.rst:579
msgid ""
"In protocols 2 and newer, classes that implements the :meth:"
"`__getnewargs_ex__` method can dictate the values passed to the :meth:"
"`__new__` method upon unpickling.  The method must return a pair ``(args, "
"kwargs)`` where *args* is a tuple of positional arguments and *kwargs* a "
"dictionary of named arguments for constructing the object.  Those will be "
"passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"プロトコル 2 以上の場合、 :meth:`__getnewargs_ex__` メソッドを実装したクラス"
"は :meth:`__new__` メソッドに渡された値の非 pickle 化の方法を指示することがで"
"きます。このメソッドは、オブジェクトの生成に必要な位置引数のタプル *args* と"
"名前付き引数の辞書 *kwargs* のペア ``(args, kwargs)`` を返さなければなりませ"
"ん。これらは非 pickle 化に際して :meth:`__new__` メソッドに渡されます。"

#: ../../library/pickle.rst:587
msgid ""
"You should implement this method if the :meth:`__new__` method of your class "
"requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"クラスの :meth:`__new__` メソッドがキーワード専用引数を求める場合はこのメソッ"
"ドを実装すべきです。\n"
"そうしない場合、互換性のため :meth:`__getnewargs__` メソッドの実装を推奨しま"
"す。"

#: ../../library/pickle.rst:591
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ""
":meth:`__getnewargs_ex__` がプロトコル 2 と 3 でも使われるようになりました。"

#: ../../library/pickle.rst:597
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"このメソッドは :meth:`__getnewargs_ex__` と同じような機能を提供しますが、位置"
"引数のみをサポートします。このメソッドは引数のタプル ``args`` を返さなければ"
"ならず、戻り値は非 pickle 化に際して :meth:`__new__` メソッドに渡されます。"

#: ../../library/pickle.rst:601
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr ""
":meth:`__getnewargs_ex__` が定義されていると :meth:`__getnewargs__` は呼び出"
"しません。"

#: ../../library/pickle.rst:604
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of :meth:"
"`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""
"Python 3.6以前のプロトコル 2 と 3 では、:meth:`__getnewargs_ex__` の代わり"
"に :meth:`__getnewargs__` が呼び出されていました。"

#: ../../library/pickle.rst:611
msgid ""
"Classes can further influence how their instances are pickled by overriding "
"the method :meth:`__getstate__`.  It is called and the returned object is "
"pickled as the contents for the instance, instead of a default state. There "
"are several cases:"
msgstr ""

#: ../../library/pickle.rst:616
msgid ""
"For a class that has no instance :attr:`~object.__dict__` and no :attr:"
"`~object.__slots__`, the default state is ``None``."
msgstr ""

#: ../../library/pickle.rst:619
msgid ""
"For a class that has an instance :attr:`~object.__dict__` and no :attr:"
"`~object.__slots__`, the default state is ``self.__dict__``."
msgstr ""

#: ../../library/pickle.rst:622
msgid ""
"For a class that has an instance :attr:`~object.__dict__` and :attr:`~object."
"__slots__`, the default state is a tuple consisting of two dictionaries:  "
"``self.__dict__``, and a dictionary mapping slot names to slot values.  Only "
"slots that have a value are included in the latter."
msgstr ""

#: ../../library/pickle.rst:628
msgid ""
"For a class that has :attr:`~object.__slots__` and no instance :attr:"
"`~object.__dict__`, the default state is a tuple whose first item is "
"``None`` and whose second item is a dictionary mapping slot names to slot "
"values described in the previous bullet."
msgstr ""

#: ../../library/pickle.rst:633
msgid ""
"Added the default implementation of the ``__getstate__()`` method in the :"
"class:`object` class."
msgstr ""

#: ../../library/pickle.rst:640
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"非 pickle 化に際して、クラスが :meth:`__setstate__` を定義している場合、それ"
"は非 pickle 化された状態とともに呼び出されます。その場合、状態オブジェクトが"
"辞書でなければならないという要求はありません。そうでなければ、 pickle された"
"状態は辞書で、その要素は新しいインスタンスの辞書に割り当てられます。"

#: ../../library/pickle.rst:647
msgid ""
"If :meth:`__getstate__` returns a false value, the :meth:`__setstate__` "
"method will not be called upon unpickling."
msgstr ""
":meth:`__getstate__` が偽値を返す場合、非 pickle 化時に :meth:`__setstate__` "
"メソッドは呼ばれません。"

#: ../../library/pickle.rst:651
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`__getstate__` and :meth:`__setstate__`."
msgstr ""
":meth:`__getstate__` および :meth:`__setstate__` メソッドの使い方に関する詳細"
"な情報については :ref:`pickle-state` 節を参照してください。"

#: ../../library/pickle.rst:656
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, :meth:"
"`__getattribute__`, or :meth:`__setattr__` may be called upon the instance.  "
"In case those methods rely on some internal invariant being true, the type "
"should implement :meth:`__new__` to establish such an invariant, as :meth:"
"`__init__` is not called when unpickling an instance."
msgstr ""
"非 pickle 化に際しては、 :meth:`__getattr__`, :meth:`__getattribute__`, また"
"は :meth:`__setattr__` といったメソッドがインスタンスに対して呼ばれることがあ"
"ります。これらのメソッドが何らかの内部の不変な条件が真であることを必要とする"
"場合、その型は :meth:`__new__` メソッドを実装してそのような不変な条件を構築す"
"べきです。なぜならばインスタンスの非 pickle 化においては :meth:`__init__` メ"
"ソッドは呼ばれないからです。"

#: ../../library/pickle.rst:665
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the :"
"meth:`__reduce__` special method.  The copy protocol provides a unified "
"interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""
"これらから見るように、pickle は上記のメソッドを直接使用しません。実際には、こ"
"れらのメソッドは :meth:`__reduce__` 特殊メソッドを実装するコピープロトコルの"
"一部です。コピープロトコルは、pickle 化とオブジェクトのコピーに必要な、データ"
"を取得するための統一されたインターフェースを提供します。 [#]_"

#: ../../library/pickle.rst:671
msgid ""
"Although powerful, implementing :meth:`__reduce__` directly in your classes "
"is error prone.  For this reason, class designers should use the high-level "
"interface (i.e., :meth:`__getnewargs_ex__`, :meth:`__getstate__` and :meth:"
"`__setstate__`) whenever possible.  We will show, however, cases where "
"using :meth:`__reduce__` is the only option or leads to more efficient "
"pickling or both."
msgstr ""
"強力ですが、クラスに :meth:`__reduce__` メソッドを直接実装することはエラーを"
"起こしやすくなります。この理由のため、クラスの設計者は可能なかぎり高レベルイ"
"ンターフェース (:meth:`__getnewargs_ex__`、:meth:`__getstate__` および :meth:"
"`__setstate__`) を使用するべきです。公開はしているものの、:meth:`__reduce__` "
"の使用は、あくまでオプションとして、より効果的な pickle 化につながる場合、あ"
"るいはその両方の場合のみにしてください。"

#: ../../library/pickle.rst:680
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""
"このインターフェースは現在、以下のように定義されています。 :meth:"
"`__reduce__` メソッドは引数を取らず、文字列あるいは (こちらの方が好まれます"
"が) タプルのいずれかを返すべきです (返されたオブジェクトは、しばしば "
"\"reduce value\" と呼ばれます)。"

#: ../../library/pickle.rst:684
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""
"文字列が返された場合、その文字列はグローバル変数の名前として解釈されます。そ"
"れはオブジェクトのモジュールから見たローカル名であるべきです; pickle モジュー"
"ルは、オブジェクトのモジュールを決定するためにモジュールの名前空間を検索しま"
"す。この振る舞いは、典型的にシングルトンで便利です。"

#: ../../library/pickle.rst:689
msgid ""
"When a tuple is returned, it must be between two and six items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr ""
"タプルが返された場合、それは 2〜6 要素長でなければなりません。オプションのア"
"イテムは省略することができます。あるいはそれらの値として ``None`` を渡すこと"
"ができます。各要素の意味は順に:"

#: ../../library/pickle.rst:695
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr ""
"オブジェクトの初期バージョンを作成するために呼ばれる呼び出し可能オブジェク"
"ト。"

#: ../../library/pickle.rst:698
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr ""
"呼出し可能オブジェクトに対する引数のタプル。呼出し可能オブジェクトが引数を受"
"け取らない場合、空のタプルが与えられなければなりません。"

#: ../../library/pickle.rst:701
msgid ""
"Optionally, the object's state, which will be passed to the object's :meth:"
"`__setstate__` method as previously described.  If the object has no such "
"method then, the value must be a dictionary and it will be added to the "
"object's :attr:`~object.__dict__` attribute."
msgstr ""
"任意で、前述のオブジェクトの :meth:`__setstate__` メソッドに渡されるオブジェ"
"クトの状態。オブジェクトがそのようなメソッドを持たない場合、値は辞書でなけれ"
"ばならず、それはオブジェクトの :attr:`~object.__dict__` 属性に追加されます。"

#: ../../library/pickle.rst:706
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)`` "
"or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have :"
"meth:`append` and :meth:`extend` methods with the appropriate signature.  "
"(Whether :meth:`append` or :meth:`extend` is used depends on which pickle "
"protocol version is used as well as the number of items to append, so both "
"must be supported.)"
msgstr ""
"任意で、連続した要素を yield する (シーケンスではなく) イテレーター。これらの"
"要素は ``obj.append(item)`` を使用して、あるいはバッチでは ``obj."
"extend(list_of_items)`` を使用して、オブジェクトに追加されます。これは主とし"
"てリストのサブクラスに対して使用されますが、適切なシグネチャを持つ :meth:"
"`append` および :meth:`extend` メソッドがあるかぎり、他のクラスで使用すること"
"もできます。 (:meth:`append` または :meth:`extend` のどちらが使用されるかは、"
"どの pickle プロトコルバージョンが使われるかに加えて追加されるアイテムの数に"
"も依存します。したがって、両方をサポートする必要があります)"

#: ../../library/pickle.rst:715
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be used "
"by other classes as long as they implement :meth:`__setitem__`."
msgstr ""
"任意で、連続する key-value ペアを yield する (シーケンスでなく) イテレー"
"ター。これらの要素は ``obj[key] = value`` を使用して、オブジェクトに格納され"
"ます。これは主として辞書のサブクラスに対して使用されますが、:meth:"
"`__setitem__` を実装しているかぎり他のクラスで使用することもできます。"

#: ../../library/pickle.rst:720
msgid ""
"Optionally, a callable with a ``(obj, state)`` signature. This callable "
"allows the user to programmatically control the state-updating behavior of a "
"specific object, instead of using ``obj``'s static :meth:`__setstate__` "
"method. If not ``None``, this callable will have priority over ``obj``'s :"
"meth:`__setstate__`."
msgstr ""
"任意で、シグネチャが ``(obj, state)`` である呼び出し可能オブジェクト。このオ"
"ブジェクトは、 ``obj`` のスタティックな :meth:`__setstate__` メソッドの代わり"
"に、ユーザーがオブジェクトの状態を更新する方法をプログラム的に制御することを"
"許します。 ``None`` 以外の場合、この呼び出し可能オブジェクトは ``obj`` の :"
"meth:`__setstate__` メソッドに優先します。"

#: ../../library/pickle.rst:726
msgid "The optional sixth tuple item, ``(obj, state)``, was added."
msgstr "任意の6番目のタプル要素 ``(obj, state)`` が追加されました。"

#: ../../library/pickle.rst:732
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the :meth:"
"`__reduce__` method.  In addition, :meth:`__reduce__` automatically becomes "
"a synonym for the extended version.  The main use for this method is to "
"provide backwards-compatible reduce values for older Python releases."
msgstr ""
"別の方法として、:meth:`__reduce_ex__` メソッドを定義することもできます。唯一"
"の違いは、このメソッドは単一の整数引数、プロトコルバージョンを取る必要がある"
"ということです。もし定義された場合、pickle は :meth:`__reduce__` メソッドより"
"もこのメソッドを優先します。さらに、:meth:`__reduce__` は自動的に拡張版の同義"
"語になります。このメソッドの主な用途は、古い Python リリースに対して後方互換"
"性のある reduce value を提供することです。"

#: ../../library/pickle.rst:744
msgid "Persistence of External Objects"
msgstr "外部オブジェクトの永続化"

#: ../../library/pickle.rst:750
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the "
"notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object "
"(for any newer protocol)."
msgstr ""
"オブジェクトの永続化のために、:mod:`pickle` モジュールは、pickle データスト"
"リーム外のオブジェクトに対する参照の概念をサポートしています。そのようなオブ"
"ジェクトは永続的 ID によって参照されます。それは、英数文字の文字列 (プロトコ"
"ル 0 に対して) [#]_ あるいは単に任意のオブジェクト (より新しい任意のプロトコ"
"ルに対して) のいずれかです。"

#: ../../library/pickle.rst:756
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user-defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` and :meth:`~Unpickler."
"persistent_load` respectively."
msgstr ""
"そのような永続的 ID の分解能は :mod:`pickle` モジュールでは定義されていませ"
"ん; これはこの分解能を pickler および unpickler のそれぞれ :meth:`~Pickler."
"persistent_id` および :meth:`~Unpickler.persistent_load` 上でのユーザー定義メ"
"ソッドに移譲します。"

#: ../../library/pickle.rst:761
msgid ""
"To pickle objects that have an external persistent ID, the pickler must have "
"a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent ID for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""
"外部の永続的 ID を持つ pickle オブジェクトの pickler は、引数にオブジェクトを"
"取り、``None`` かオブジェクトの永続的 ID を返すカスタム :meth:`~Pickler."
"persistent_id` メソッドを持たなくてはなりません。``None`` を返す場合、"
"pickler は通常通りマーカーとともにオブジェクトを pickle 化するため、"
"unpickler はそれを永続的 ID として認識します。"

#: ../../library/pickle.rst:768
msgid ""
"To unpickle external objects, the unpickler must have a custom :meth:"
"`~Unpickler.persistent_load` method that takes a persistent ID object and "
"returns the referenced object."
msgstr ""
"外部オブジェクトを非 pickle 化するには、unpickler は永続的 ID オブジェクトを"
"取り被参照オブジェクトを返すカスタム :meth:`~Unpickler.persistent_load` メ"
"ソッドを持たなくてはなりません。"

#: ../../library/pickle.rst:772
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr ""
"これは、外部のオブジェクトを参照によって pickle 化するために永続的 ID をどの"
"ように使用するかを示す包括的な例です。"

#: ../../library/pickle.rst:780
msgid "Dispatch Tables"
msgstr "ディスパッチテーブル"

#: ../../library/pickle.rst:782
msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr ""
"pickle 化に依存する他のコードの邪魔をせずに、一部のクラスの pickle 化だけをカ"
"スタマイズしたい場合、プライベートのディスパッチテーブルを持つ pickler を作成"
"することができます。"

#: ../../library/pickle.rst:786
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`copyreg.dispatch_table` as a private dispatch table."
msgstr ""
":mod:`copyreg` モジュールによって管理されるグローバルなディスパッチテーブル"
"は :data:`copyreg.dispatch_table` として利用可能です。したがって、:data:"
"`copyreg.dispatch_table` の修正済のコピーをプライベートのディスパッチテーブル"
"として使用することを選択できます。"

#: ../../library/pickle.rst:791
msgid "For example ::"
msgstr "例えば ::"

#: ../../library/pickle.rst:798
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table "
"which handles the ``SomeClass`` class specially.  Alternatively, the code ::"
msgstr ""
"これは ``SomeClass`` クラスを特別に扱うプライベートのディスパッチテーブルを持"
"つ :class:`pickle.Pickler` のインスタンスを作成します。あるいは、次のコー"
"ド ::"

#: ../../library/pickle.rst:808
msgid ""
"does the same but all instances of ``MyPickler`` will by default share the "
"private dispatch table.  On the other hand, the code ::"
msgstr ""

#: ../../library/pickle.rst:815
msgid ""
"modifies the global dispatch table shared by all users of the :mod:`copyreg` "
"module."
msgstr ""

#: ../../library/pickle.rst:820
msgid "Handling Stateful Objects"
msgstr "状態を持つオブジェクトの扱い"

#: ../../library/pickle.rst:826
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`TextReader` class opens a text file, and returns the line number "
"and line contents each time its :meth:`!readline` method is called. If a :"
"class:`TextReader` instance is pickled, all attributes *except* the file "
"object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The :meth:"
"`__setstate__` and :meth:`__getstate__` methods are used to implement this "
"behavior. ::"
msgstr ""
"ここでは、クラスを pickle 化する振る舞いの変更手順を紹介しています。:class:"
"`TextReader` クラスはテキストファイルをオープンし、:meth:`!readline` メソッド"
"が呼ばれると、その度に行番号と行の内容を返します。:class:`TextReader` インス"
"タンスが pickle 化されるとき、ファイルオブジェクトメンバーを *除く* すべての"
"属性が保存されます。インスタンスが非 pickle 化されるとき、ファイルは再びオー"
"プンされ、最後に読み込んだ位置から読み込みを再開します。このような振る舞いを"
"実装するには :meth:`__setstate__` および :meth:`__getstate__` メソッドを使用"
"します。 ::"

#: ../../library/pickle.rst:872
msgid "A sample usage might be something like this::"
msgstr "使用例は以下のようになるでしょう::"

#: ../../library/pickle.rst:886
msgid "Custom Reduction for Types, Functions, and Other Objects"
msgstr "型、関数、その他のオブジェクトに対するリダクションのカスタマイズ"

#: ../../library/pickle.rst:890
msgid ""
"Sometimes, :attr:`~Pickler.dispatch_table` may not be flexible enough. In "
"particular we may want to customize pickling based on another criterion than "
"the object's type, or we may want to customize the pickling of functions and "
"classes."
msgstr ""
":attr:`~Pickler.dispatch_table` は、ときにその柔軟性が十分でないがことありま"
"す。特に、オブジェクトの型以外の別の条件で pickle 化をカスタマイズしたい場合"
"や、関数やクラスを使って pickle 化をカスタマイズしたい場合などです。 "

#: ../../library/pickle.rst:895
msgid ""
"For those cases, it is possible to subclass from the :class:`Pickler` class "
"and implement a :meth:`~Pickler.reducer_override` method. This method can "
"return an arbitrary reduction tuple (see :meth:`__reduce__`). It can "
"alternatively return ``NotImplemented`` to fallback to the traditional "
"behavior."
msgstr ""
"そのような場合、 :class:`Pickler` クラスから派生したサブクラスで :meth:"
"`~Pickler.reducer_override` メソッドを実装することができます。このメソッドは"
"任意のリダクション用タプルを返すことができます  (:meth:`__reduce__` を参照し"
"てください)。もしくは、従来の振る舞いにフォールバックするために "
"``NotImplemented`` を返すこともできます。"

#: ../../library/pickle.rst:900
msgid ""
"If both the :attr:`~Pickler.dispatch_table` and :meth:`~Pickler."
"reducer_override` are defined, then :meth:`~Pickler.reducer_override` method "
"takes priority."
msgstr ""
":attr:`~Pickler.dispatch_table` と :meth:`~Pickler.reducer_override` の両方が"
"定義されている場合、 :meth:`~Pickler.reducer_override` メソッドが優先されま"
"す。"

#: ../../library/pickle.rst:905
msgid ""
"For performance reasons, :meth:`~Pickler.reducer_override` may not be called "
"for the following objects: ``None``, ``True``, ``False``, and exact "
"instances of :class:`int`, :class:`float`, :class:`bytes`, :class:`str`, :"
"class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` and :class:"
"`tuple`."
msgstr ""
"パフォーマンス上の理由により、次に挙げるオブジェクトに対しては :meth:"
"`~Pickler.reducer_override` が呼ばれないことがあります: ``None``, ``True``, "
"``False``, および :class:`int`, :class:`float`, :class:`bytes`, :class:"
"`str`, :class:`dict`, :class:`set`, :class:`frozenset`, :class:`list`, :"
"class:`tuple` の厳密なインスタンス。"

#: ../../library/pickle.rst:911
msgid ""
"Here is a simple example where we allow pickling and reconstructing a given "
"class::"
msgstr "以下は特定のクラスを pickle 化して再構成する単純な例です::"

#: ../../library/pickle.rst:946
msgid "Out-of-band Buffers"
msgstr "アウトオブバウンドバッファ"

#: ../../library/pickle.rst:950
msgid ""
"In some contexts, the :mod:`pickle` module is used to transfer massive "
"amounts of data.  Therefore, it can be important to minimize the number of "
"memory copies, to preserve performance and resource consumption.  However, "
"normal operation of the :mod:`pickle` module, as it transforms a graph-like "
"structure of objects into a sequential stream of bytes, intrinsically "
"involves copying data to and from the pickle stream."
msgstr ""
"ある状況では、 :mod:`pickle` モジュールは大量のデータを転送するために使われま"
"す。 そのため、メモリのコピーを最小限に抑えてパフォーマンスとリソースの消費を"
"良好な状態に保つことが重要になることがあります。 しかし、オブジェクトのグラフ"
"的構造をシーケンシャルなバイトストリームに変換する :mod:`pickle` モジュールの"
"通常の処理は、本質的に pickle ストリームへの、または pickle ストリームからの"
"データのコピーを伴います。"

#: ../../library/pickle.rst:957
msgid ""
"This constraint can be eschewed if both the *provider* (the implementation "
"of the object types to be transferred) and the *consumer* (the "
"implementation of the communications system) support the out-of-band "
"transfer facilities provided by pickle protocol 5 and higher."
msgstr ""
"この制約は、生産者 *provider* (変換されるオブジェクトの型の実装) と消費者 "
"*consumer* (通信システムの実装) が pickle プロトコル5以上で提供されるアウトオ"
"ブバウンドのデータ転送機能をサポートしていれば回避できます。"

#: ../../library/pickle.rst:963
msgid "Provider API"
msgstr "生産者 API"

#: ../../library/pickle.rst:965
msgid ""
"The large data objects to be pickled must implement a :meth:`__reduce_ex__` "
"method specialized for protocol 5 and higher, which returns a :class:"
"`PickleBuffer` instance (instead of e.g. a :class:`bytes` object) for any "
"large data."
msgstr ""
"pickle 化される大きなサイズのデータオブジェクトは、プロトコル5以上でサポート"
"された :meth:`__reduce_ex__` メソッドを実装しなければなりません。このメソッド"
"は大きなデータに対して (:class:`bytes` オブジェクトなどの代わりに) :class:"
"`PickleBuffer` インスタンスを返します。"

#: ../../library/pickle.rst:970
msgid ""
"A :class:`PickleBuffer` object *signals* that the underlying buffer is "
"eligible for out-of-band data transfer.  Those objects remain compatible "
"with normal usage of the :mod:`pickle` module.  However, consumers can also "
"opt-in to tell :mod:`pickle` that they will handle those buffers by "
"themselves."
msgstr ""
":class:`PickleBuffer` オブジェクトは背後にあるバッファがアウトオブバウンドの"
"データ転送に適合していることを *知らせます* 。これらのオブジェクトは :mod:"
"`pickle` モジュールの通常の使い方との互換性を保っています。しかし、消費者側"
"で :mod:`pickle` モジュールに対してそれらのバッファを自身で処理することを事前"
"に知らせることもできます。"

#: ../../library/pickle.rst:977
msgid "Consumer API"
msgstr "消費者 API"

#: ../../library/pickle.rst:979
msgid ""
"A communications system can enable custom handling of the :class:"
"`PickleBuffer` objects generated when serializing an object graph."
msgstr ""
"通信システムは、オブジェクトグラフを直列化するときに生成された :class:"
"`PickleBuffer` オブジェクトのカスタマイズされた処理を有効化することができま"
"す。"

#: ../../library/pickle.rst:982
msgid ""
"On the sending side, it needs to pass a *buffer_callback* argument to :class:"
"`Pickler` (or to the :func:`dump` or :func:`dumps` function), which will be "
"called with each :class:`PickleBuffer` generated while pickling the object "
"graph.  Buffers accumulated by the *buffer_callback* will not see their data "
"copied into the pickle stream, only a cheap marker will be inserted."
msgstr ""
"送信側は *buffer_callback* 引数を :class:`Pickler` (または :func:`dump` や :"
"func:`dumps` 関数) に渡す必要があります。この関数はオブジェクトグラフを "
"pickle 化するときに生成されるそれぞれの :class:`PickleBuffer` を引数として呼"
"ばれます。 *buffer_callback* によって蓄積されたバッファは、それが保持するデー"
"タのコピーを pickle ストリームに送らず、軽量なマーカーが挿入されるだけです。"

#: ../../library/pickle.rst:989
msgid ""
"On the receiving side, it needs to pass a *buffers* argument to :class:"
"`Unpickler` (or to the :func:`load` or :func:`loads` function), which is an "
"iterable of the buffers which were passed to *buffer_callback*. That "
"iterable should produce buffers in the same order as they were passed to "
"*buffer_callback*.  Those buffers will provide the data expected by the "
"reconstructors of the objects whose pickling produced the original :class:"
"`PickleBuffer` objects."
msgstr ""
"受信側は *buffers* 引数を :class:`Unpickler` (または :func:`load` や :func:"
"`loads` 関数) に渡す必要があります。これは *buffer_callback* に渡されたバッ"
"ファのイテラブルです。このイテラブルは  *buffer_callback* に渡されたのと同じ"
"順番でバッファを返さなければなりません。これらのバッファは、pickle 化処理に"
"よって :class:`PickleBuffer` オブジェクトを生成したオブジェクトの再構築処理で"
"期待されるデータを提供します。"

#: ../../library/pickle.rst:997
msgid ""
"Between the sending side and the receiving side, the communications system "
"is free to implement its own transfer mechanism for out-of-band buffers. "
"Potential optimizations include the use of shared memory or datatype-"
"dependent compression."
msgstr ""
"送信側と受信側の間で、通信システムはアウトオブバウンドバッファの独自の転送メ"
"カニズムを自由に実装することができます。見込みのある最適化としては、共有メモ"
"リの利用や、データタイプ依存のデータ圧縮などが考えられます。"

#: ../../library/pickle.rst:1003
msgid "Example"
msgstr "使用例"

#: ../../library/pickle.rst:1005
msgid ""
"Here is a trivial example where we implement a :class:`bytearray` subclass "
"able to participate in out-of-band buffer pickling::"
msgstr ""
"以下は、アウトオブバウンドのバッファを使った pickle 処理に関与することができ"
"るサブクラス :class:`bytearray` を実装したささいな例です::"

#: ../../library/pickle.rst:1029
msgid ""
"The reconstructor (the ``_reconstruct`` class method) returns the buffer's "
"providing object if it has the right type.  This is an easy way to simulate "
"zero-copy behaviour on this toy example."
msgstr ""
"再構成関数 (``_reconstruct`` クラスメソッド) は、受け取ったバッファが持ってい"
"るオブジェクトを、それが正しい型であれば、そのまま返します。これは、このおも"
"ちゃのような例において、ゼロコピーの挙動を模擬的に行う簡単な方法です。"

#: ../../library/pickle.rst:1033
msgid ""
"On the consumer side, we can pickle those objects the usual way, which when "
"unserialized will give us a copy of the original object::"
msgstr ""
"消費者側では、これらのオブジェクトを通常の方法で pickle 化することができま"
"す。この場合非直列化処理は元のオブジェクトのコピーを返します::"

#: ../../library/pickle.rst:1042
msgid ""
"But if we pass a *buffer_callback* and then give back the accumulated "
"buffers when unserializing, we are able to get back the original object::"
msgstr ""
"いっぽう直列化において *buffer_callback* を設定し、非直列化において蓄積された"
"バッファを渡した場合、コピーではなく元のオブジェクトを得ることができます::"

#: ../../library/pickle.rst:1052
msgid ""
"This example is limited by the fact that :class:`bytearray` allocates its "
"own memory: you cannot create a :class:`bytearray` instance that is backed "
"by another object's memory.  However, third-party datatypes such as NumPy "
"arrays do not have this limitation, and allow use of zero-copy pickling (or "
"making as few copies as possible) when transferring between distinct "
"processes or systems."
msgstr ""
"この例では :class:`bytearray` がそれ自身メモリを割り当てるという性質による制"
"限があります: すなわち、他のオブジェクトのメモリを参照する :class:"
"`bytearray` を生成することはできません。しかし、 NumPy 配列のようなサードパー"
"ティのデータ型ではそのような制限はなく、異なるプロセス間または異なるシステム"
"間で、ゼロコピー (または最小限のコピー) でのpickle 処理の利用が可能です。"

#: ../../library/pickle.rst:1059
msgid ":pep:`574` -- Pickle protocol 5 with out-of-band data"
msgstr ":pep:`574` -- Pickle プロトコルバージョン 5 による帯域外データ"

#: ../../library/pickle.rst:1065
msgid "Restricting Globals"
msgstr "グローバル変数を制限する"

#: ../../library/pickle.rst:1070
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider "
"what this hand-crafted pickle data stream does when loaded::"
msgstr ""
"デフォルトで、非 pickle 化は pickle データ内で見つけたあらゆるクラスや関数を"
"インポートします。多くのアプリケーションでは、この振る舞いは受け入れられませ"
"ん。なぜなら、それによって unpickler が任意のコードをインポートして実行するこ"
"とが可能になるからです。この手の巧妙に作られた pickle データストリームがロー"
"ドされたときに何を行うかをちょっと考えてみてください::"

#: ../../library/pickle.rst:1080
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""
"この例において、unpickler は :func:`os.system` 関数をインポートして、次に文字"
"列の引数 \"echo hello world\" を適用しています。この例は無害ですが、システム"
"を破壊する例を想像するのは難しくありません。"

#: ../../library/pickle.rst:1084
msgid ""
"For this reason, you may want to control what gets unpickled by customizing :"
"meth:`Unpickler.find_class`.  Unlike its name suggests, :meth:`Unpickler."
"find_class` is called whenever a global (i.e., a class or a function) is "
"requested.  Thus it is possible to either completely forbid globals or "
"restrict them to a safe subset."
msgstr ""
"この理由のため、:meth:`Unpickler.find_class` をカスタマイズすることで非 "
"pickle 化で何を得るかを制御したくなるかもしれません。その名前が示唆するのと異"
"なり、:meth:`Unpickler.find_class` はグローバル (クラスや関数) が必要とした時"
"にはいつでも呼びだされます。したがって、グローバルを完全に禁止することも安全"
"なサブセットに制限することも可能です。"

#: ../../library/pickle.rst:1090
msgid ""
"Here is an example of an unpickler allowing only few safe classes from the :"
"mod:`builtins` module to be loaded::"
msgstr ""
"これは、一部の安全なクラスについてのみ :mod:`builtins` モジュールからロードす"
"ることを許可する unpickler の例です::"

#: ../../library/pickle.rst:1119
msgid "A sample usage of our unpickler working as intended::"
msgstr "この unpickler が働く使用例は次のように意図されます::"

#: ../../library/pickle.rst:1138
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""
"この例が示すように、非 pickle 化を認めるものに注意しなければなりません。した"
"がって、セキュリティが重要な場合は :mod:`xmlrpc.client` の marshal API や、"
"サードパーティのソリューションのような別の選択肢を考慮した方がよいでしょう。"

#: ../../library/pickle.rst:1145
msgid "Performance"
msgstr "性能"

#: ../../library/pickle.rst:1147
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature "
"efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""
"pickle プロトコルの最近のバージョン (プロトコル 2 以降) は一部の一般的な機能"
"と組み込みデータ型を効率的にバイナリにエンコードするよう考慮されています。ま"
"た、:mod:`pickle` モジュールは C 言語で書かれた透過的オプティマイザーを持って"
"います。"

#: ../../library/pickle.rst:1155
msgid "Examples"
msgstr "使用例"

#: ../../library/pickle.rst:1157
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr ""
"最も単純なコードでは、:func:`dump` および :func:`load` 関数を使用してくださ"
"い。 ::"

#: ../../library/pickle.rst:1173
msgid "The following example reads the resulting pickled data. ::"
msgstr "次の例は、pickle 化されたデータを読み込みます。 ::"

#: ../../library/pickle.rst:1190
msgid "Module :mod:`copyreg`"
msgstr ":mod:`copyreg` モジュール"

#: ../../library/pickle.rst:1190
msgid "Pickle interface constructor registration for extension types."
msgstr "拡張型を登録するための Pickle インターフェース構成機構。"

#: ../../library/pickle.rst:1193
msgid "Module :mod:`pickletools`"
msgstr ":mod:`pickletools` モジュール"

#: ../../library/pickle.rst:1193
msgid "Tools for working with and analyzing pickled data."
msgstr "pickle データの処理や分析を行うためのツール。"

#: ../../library/pickle.rst:1196
msgid "Module :mod:`shelve`"
msgstr ":mod:`shelve` モジュール"

#: ../../library/pickle.rst:1196
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "オブジェクトのインデクス付きデータベース; :mod:`pickle` を使います。"

#: ../../library/pickle.rst:1199
msgid "Module :mod:`copy`"
msgstr ":mod:`copy` モジュール"

#: ../../library/pickle.rst:1199
msgid "Shallow and deep object copying."
msgstr "オブジェクトの浅いコピーおよび深いコピー。"

#: ../../library/pickle.rst:1201
msgid "Module :mod:`marshal`"
msgstr ":mod:`marshal` モジュール"

#: ../../library/pickle.rst:1202
msgid "High-performance serialization of built-in types."
msgstr "組み込み型の高性能な直列化。"

#: ../../library/pickle.rst:1206
msgid "Footnotes"
msgstr "脚注"

#: ../../library/pickle.rst:1207
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr ":mod:`marshal` モジュールと間違えないように注意してください。"

#: ../../library/pickle.rst:1209
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all :keyword:`!"
"lambda` functions share the same name:  ``<lambda>``."
msgstr ""
"なぜ :keyword:`lambda` 関数を pickle 化できないかというと、すべての :keyword:"
"`!lambda` 関数は同じ名前: ``<lambda>`` を共有しているからです。"

#: ../../library/pickle.rst:1212
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an :exc:"
"`AttributeError` but it could be something else."
msgstr ""
"送出される例外は :exc:`ImportError` や :exc:`AttributeError` になるはずです"
"が、他の例外も起こりえます。"

#: ../../library/pickle.rst:1215
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ""
":mod:`copy` モジュールは、浅いコピーと深いコピーの操作にこのプロトコルを使用"
"します。"

#: ../../library/pickle.rst:1218
msgid ""
"The limitation on alphanumeric characters is due to the fact that persistent "
"IDs in protocol 0 are delimited by the newline character.  Therefore if any "
"kind of newline characters occurs in persistent IDs, the resulting pickled "
"data will become unreadable."
msgstr ""
