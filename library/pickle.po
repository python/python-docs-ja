# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# tomo, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ":mod:`pickle` --- Python オブジェクトの直列化"

#: ../../library/pickle.rst:17
msgid ""
"The :mod:`pickle` module implements a fundamental, but powerful algorithm "
"for serializing and de-serializing a Python object structure.  \"Pickling\" "
"is the process whereby a Python object hierarchy is converted into a byte "
"stream, and \"unpickling\" is the inverse operation, whereby a byte stream "
"is converted back into an object hierarchy.  Pickling (and unpickling) is "
"alternatively known as \"serialization\", \"marshalling,\" [#]_ or "
"\"flattening\", however, to avoid confusion, the terms used here are "
"\"pickling\" and \"unpickling\"."
msgstr ""
":mod:`pickle` モジュールでは、Python オブジェクトデータ構造を直列化 "
"(serialize) したり非直列化 (de-serialize)するための基礎的ですが強力なアルゴリ"
"ズムを実装しています。 \"Pickle 化 (Pickling)\" は Python のオブジェクト階層"
"をバイトストリームに変換する過程を指します。\"非 Pickle 化 (unpickling)\" は"
"その逆の操作で、バイトストリームをオブジェクト階層に戻すように変換します。"
"Pickle 化 (及び非 Pickle 化) は、別名 \"直列化 (serialization)\" や \"整列化 "
"(marshalling)\" [#]_ 、 \"平坦化 (flattening)\" として知られていますが、ここ"
"では混乱を避けるため、用語として \"Pickle 化\" および \"非Pickle 化\" を使い"
"ます。"

#: ../../library/pickle.rst:25
msgid ""
"This documentation describes both the :mod:`pickle` module and the :mod:"
"`cPickle` module."
msgstr ""
"このドキュメントでは :mod:`pickle` モジュールおよび :mod:`cPickle` モジュール"
"の両方について記述します。"

#: ../../library/pickle.rst:30
msgid ""
"The :mod:`pickle` module is not secure against erroneous or maliciously "
"constructed data.  Never unpickle data received from an untrusted or "
"unauthenticated source."
msgstr ""
":mod:`pickle` モジュールはエラーや不正に生成されたデータに対して安全ではあり"
"ません。信頼できない、あるいは認証されていないソースから受け取ったしたデータ"
"を unpickle してはいけません。"

#: ../../library/pickle.rst:36
msgid "Relationship to other Python modules"
msgstr "他の Python モジュールとの関係"

#: ../../library/pickle.rst:38
msgid ""
"The :mod:`pickle` module has an optimized cousin called the :mod:`cPickle` "
"module.  As its name implies, :mod:`cPickle` is written in C, so it can be "
"up to 1000 times faster than :mod:`pickle`.  However it does not support "
"subclassing of the :func:`Pickler` and :func:`Unpickler` classes, because "
"in :mod:`cPickle` these are functions, not classes.  Most applications have "
"no need for this functionality, and can benefit from the improved "
"performance of :mod:`cPickle`. Other than that, the interfaces of the two "
"modules are nearly identical; the common interface is described in this "
"manual and differences are pointed out where necessary.  In the following "
"discussions, we use the term \"pickle\" to collectively describe the :mod:"
"`pickle` and :mod:`cPickle` modules."
msgstr ""
":mod:`pickle` モジュールには :mod:`cPickle` と呼ばれる最適化のなされた親類モ"
"ジュールがあります。名前が示すように、 :mod:`cPickle` は C で書かれており、こ"
"のため :mod:`pickle` より 1000 倍くらいまで高速になる可能性があります。しかし"
"ながら :mod:`cPickle` では :func:`Pickler` および :func:`Unpickler` クラスの"
"サブクラス化をサポートしていません。これは :mod:`cPickle` では、これらは関数"
"であってクラスではないからです。ほとんどのアプリケーションではこの機能は不要"
"であり、 :mod:`cPickle` の持つ高いパフォーマンスの恩恵を受けることができま"
"す。その他の点では、二つのモジュールにおけるインタフェースはほとんど同じで"
"す; このマニュアルでは共通のインタフェースを記述しており、必要に応じてモ"
"ジュール間の相違について指摘します。以下の議論では、 :mod:`pickle` と :mod:"
"`cPickle` の総称として \"pickle\" という用語を使うことにします。"

#: ../../library/pickle.rst:49
msgid ""
"The data streams the two modules produce are guaranteed to be "
"interchangeable."
msgstr ""
"これら二つのモジュールが生成するデータストリームは相互交換できることが保証さ"
"れています。"

#: ../../library/pickle.rst:51
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's :file:`."
"pyc` files."
msgstr ""
"Python には :mod:`marshal` と呼ばれるより原始的な直列化モジュールがあります"
"が、一般的に Python オブジェクトを直列化する方法としては :mod:`pickle` を選ぶ"
"べきです。 :mod:`marshal` は基本的に :file:`.pyc` ファイルをサポートするため"
"に存在しています。"

#: ../../library/pickle.rst:56
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ""
":mod:`pickle` モジュールはいくつかの点で :mod:`marshal` と明確に異なります:"

#: ../../library/pickle.rst:58
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""
":mod:`pickle` モジュールでは、同じオブジェクトが再度直列化されることのないよ"
"う、すでに直列化されたオブジェクトについて追跡情報を保持します。 :mod:"
"`marshal` はこれを行いません。"

#: ../../library/pickle.rst:62
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"この機能は再帰的オブジェクトと共有オブジェクトの両方に重要な関わりをもってい"
"ます。再帰的オブジェクトとは自分自身に対する参照を持っているオブジェクトで"
"す。再帰的オブジェクトは marshal で扱うことができず、実際、再帰的オブジェクト"
"を marshal 化しようとすると Python インタプリタをクラッシュさせてしまいます。"
"共有オブジェクトは、直列化しようとするオブジェクト階層の異なる複数の場所で同"
"じオブジェクトに対する参照が存在する場合に生じます。共有オブジェクトを共有の"
"ままにしておくことは、変更可能なオブジェクトの場合には非常に重要です。"

#: ../../library/pickle.rst:71
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` はユーザ定義クラスやそのインスタンスを直列化するために使うこと"
"ができません。 :mod:`pickle` はクラスインスタンスを透過的に保存したり復元した"
"りすることができますが、クラス定義をインポートすることが可能で、かつオブジェ"
"クトが保存された際と同じモジュールで定義されていなければなりません。"

#: ../../library/pickle.rst:76
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support :file:"
"`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise. "
"The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases."
msgstr ""
":mod:`marshal` の直列化フォーマットは Python の異なるバージョンで可搬性がある"
"ことを保証していません。 :mod:`marshal` の本来の仕事は :file:`.pyc` ファイル"
"のサポートなので、Python を実装する人々には、必要に応じて直列化フォーマットを"
"以前のバージョンと互換性のないものに変更する権限が残されています。 :mod:"
"`pickle` 直列化フォーマットには、全ての Python リリース間で以前のバージョンと"
"の互換性が保証されています。"

#: ../../library/pickle.rst:83
msgid ""
"Note that serialization is a more primitive notion than persistence; "
"although :mod:`pickle` reads and writes file objects, it does not handle the "
"issue of naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The module :mod:`shelve` provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"直列化は永続化 (persisitence) よりも原始的な概念です; :mod:`pickle` はファイ"
"ルオブジェクトを読み書きしますが、永続化されたオブジェクトの名前付け問題や、"
"(より複雑な) オブジェクトに対する競合アクセスの問題を扱いません。 :mod:"
"`pickle` モジュールは複雑なオブジェクトをバイトストリームに変換することがで"
"き、バイトストリームを変換前と同じ内部構造をオブジェクトに変換することができ"
"ます。このバイトストリームの最も明白な用途はファイルへの書き込みですが、その"
"他にもネットワークを介して送信したり、データベースに記録したりすることができ"
"ます。モジュール :mod:`shelve` はオブジェクトを DBM 形式のデータベースファイ"
"ル上で pickle 化したり unpickle 化したりするための単純なインタフェースを提供"
"しています。"

#: ../../library/pickle.rst:96
msgid "Data stream format"
msgstr "データストリームの形式"

#: ../../library/pickle.rst:102
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as XDR (which can't represent pointer sharing); however it means that non-"
"Python programs may not be able to reconstruct pickled Python objects."
msgstr ""
":mod:`pickle` が使うデータ形式は Python 特有です。そうすることで、XDR のよう"
"な外部の標準が持つ制限 (例えば XDR ではポインタの共有を表現できません) を課せ"
"られることがないという利点があります; しかしこれは Python で書かれていないプ"
"ログラムが pickle 化された Python オブジェクトを再構築できない可能性があるこ"
"とを意味します。"

#: ../../library/pickle.rst:107
msgid ""
"By default, the :mod:`pickle` data format uses a printable ASCII "
"representation. This is slightly more voluminous than a binary "
"representation.  The big advantage of using printable ASCII (and of some "
"other characteristics of :mod:`pickle`'s representation) is that for "
"debugging or recovery purposes it is possible for a human to read the "
"pickled file with a standard text editor."
msgstr ""
"標準では、 :mod:`pickle` データ形式では印字可能な ASCII 表現を使います。これ"
"はバイナリ表現よりも少しかさばるデータになります。印字可能な ASCII の利用 (と"
"その他の :mod:`pickle` 表現形式が持つ特徴) の大きな利点は、デバッグやリカバリ"
"を目的とした場合に、 pickle 化されたファイルを標準的なテキストエディタで読め"
"るということです。"

#: ../../library/pickle.rst:113
msgid ""
"There are currently 3 different protocols which can be used for pickling."
msgstr "現在、pickle化に使われるプロトコルは、以下の 3 種類です。"

#: ../../library/pickle.rst:115
msgid ""
"Protocol version 0 is the original ASCII protocol and is backwards "
"compatible with earlier versions of Python."
msgstr ""
"バージョン 0 のプロトコルは、最初の ASCII プロトコルで、以前のバージョンの"
"Python と後方互換です。"

#: ../../library/pickle.rst:118
msgid ""
"Protocol version 1 is the old binary format which is also compatible with "
"earlier versions of Python."
msgstr ""
"バージョン 1 のプロトコルは、古いバイナリ形式で、以前のバージョンの Python と"
"後方互換です。"

#: ../../library/pickle.rst:121
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style class`\\es."
msgstr ""
"バージョン 2 のプロトコルは、Python 2.3 で導入されました。 :term:`new-style "
"class` を、より効率よく piclke 化します。"

#: ../../library/pickle.rst:124
msgid "Refer to :pep:`307` for more information."
msgstr "詳細は :pep:`307` を参照してください。"

#: ../../library/pickle.rst:126
msgid ""
"If a *protocol* is not specified, protocol 0 is used. If *protocol* is "
"specified as a negative value or :const:`HIGHEST_PROTOCOL`, the highest "
"protocol version available will be used."
msgstr ""
"*protocol* を指定しない場合、プロトコル 0 が使われます。 *protocol* に負値"
"か :const:`HIGHEST_PROTOCOL` を指定すると、有効なプロトコルの内、もっとも高い"
"バージョンのものが使われます。"

#: ../../library/pickle.rst:130 ../../library/pickle.rst:176
#: ../../library/pickle.rst:252
msgid "Introduced the *protocol* parameter."
msgstr "*protocol* パラメータが導入されました。"

#: ../../library/pickle.rst:133
msgid ""
"A binary format, which is slightly more efficient, can be chosen by "
"specifying a *protocol* version >= 1."
msgstr ""
"*protocol* version >= 1 を指定することで、少しだけ効率の高いバイナリ形式を選"
"ぶことができます。"

#: ../../library/pickle.rst:138
msgid "Usage"
msgstr "使用法"

#: ../../library/pickle.rst:140
msgid ""
"To serialize an object hierarchy, you first create a pickler, then you call "
"the pickler's :meth:`dump` method.  To de-serialize a data stream, you first "
"create an unpickler, then you call the unpickler's :meth:`load` method.  "
"The :mod:`pickle` module provides the following constant:"
msgstr ""
"オブジェクト階層を直列化するには、まず pickler を生成し、続いてpickler の :"
"meth:`dump` メソッドを呼び出します。データストリームから非直列化するには、ま"
"ず unpickler を生成し、続いて unpicklerの :meth:`load` メソッドを呼び出しま"
"す。 :mod:`pickle` モジュールでは以下の定数を提供しています:"

#: ../../library/pickle.rst:148
msgid ""
"The highest protocol version available.  This value can be passed as a "
"*protocol* value."
msgstr ""
"有効なプロトコルのうち、最も大きいバージョン。この値は、 *protocol* として渡"
"せます。"

#: ../../library/pickle.rst:155
msgid ""
"Be sure to always open pickle files created with protocols >= 1 in binary "
"mode. For the old ASCII-based pickle protocol 0 you can use either text mode "
"or binary mode as long as you stay consistent."
msgstr ""
"protocols >= 1 で作られた pickle ファイルは、常にバイナリモードでオープンする"
"ようにしてください。古い ASCII ベースの pickle プロトコル 0 では、矛盾しない"
"限りにおいてテキストモードとバイナリモードのいずれも利用することができます。"

#: ../../library/pickle.rst:159
msgid ""
"A pickle file written with protocol 0 in binary mode will contain lone "
"linefeeds as line terminators and therefore will look \"funny\" when viewed "
"in Notepad or other editors which do not support this format."
msgstr ""
"プロトコル 0 で書かれたバイナリの pickle ファイルは、行ターミネータとして単独"
"の改行(LF)を含んでいて、ですのでこの形式をサポートしない、 Notepad や他のエ"
"ディタで見たときに「おかしく」見えるかもしれません。"

#: ../../library/pickle.rst:163
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ""
"この pickle 化の手続きを便利にするために、 :mod:`pickle` モジュールでは以下の"
"関数を提供しています:"

#: ../../library/pickle.rst:169
msgid ""
"Write a pickled representation of *obj* to the open file object *file*.  "
"This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""
"すでに開かれているファイルオブジェクト *file* に、 *obj* を pickle 化したもの"
"を表現する文字列を書き込みます。 ``Pickler(file, protocol).dump(obj)`` と同じ"
"です。"

#: ../../library/pickle.rst:172 ../../library/pickle.rst:205
#: ../../library/pickle.rst:248
msgid ""
"If the *protocol* parameter is omitted, protocol 0 is used. If *protocol* is "
"specified as a negative value or :const:`HIGHEST_PROTOCOL`, the highest "
"protocol version will be used."
msgstr ""
"*protocol* を指定しない場合、プロトコル 0 が使われます。 *protocol* に負値"
"か :const:`HIGHEST_PROTOCOL` を指定すると、有効なプロトコルの内、もっとも高い"
"バージョンのものが使われます。"

#: ../../library/pickle.rst:179
msgid ""
"*file* must have a :meth:`write` method that accepts a single string "
"argument. It can thus be a file object opened for writing, a :mod:`StringIO` "
"object, or any other custom object that meets this interface."
msgstr ""
"*file* は、単一の文字列引数を受理する :meth:`write` メソッドを持たなければな"
"りません。従って、 *file* としては、書き込みのために開かれたファイルオブジェ"
"クト、 :mod:`StringIO` オブジェクト、その他前述のインタフェースに適合する他の"
"カスタムオブジェクトをとることができます。"

#: ../../library/pickle.rst:186
msgid ""
"Read a string from the open file object *file* and interpret it as a pickle "
"data stream, reconstructing and returning the original object hierarchy.  "
"This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"すでに開かれているファイルオブジェクト *file* から文字列を読み出し、読み出さ"
"れた文字列を pickle 化されたデータ列として解釈して、もとのオブジェクト階層を"
"再構築して返します。 ``Unpickler(file).load()`` と同じです。"

#: ../../library/pickle.rst:190 ../../library/pickle.rst:304
msgid ""
"*file* must have two methods, a :meth:`read` method that takes an integer "
"argument, and a :meth:`readline` method that requires no arguments.  Both "
"methods should return a string.  Thus *file* can be a file object opened for "
"reading, a :mod:`StringIO` object, or any other custom object that meets "
"this interface."
msgstr ""
"*file* は、整数引数をとる :meth:`read` メソッドと、引数の必要ない :meth:"
"`readline` メソッドを持たなければなりません。これらのメソッドは両方とも文字列"
"を返さなければなりません。従って、 *file* としては、読み出しのために開かれた"
"ファイルオブジェクト、 :mod:`StringIO` オブジェクト、その他前述のインタフェー"
"スに適合する他のカスタムオブジェクトをとることができます。"

#: ../../library/pickle.rst:196
msgid ""
"This function automatically determines whether the data stream was written "
"in binary mode or not."
msgstr ""
"この関数はデータ列の書き込まれているモードがバイナリかそうでないかを自動的に"
"判断します。"

#: ../../library/pickle.rst:202
msgid ""
"Return the pickled representation of the object as a string, instead of "
"writing it to a file."
msgstr ""
"*obj* の pickle 化された表現を、ファイルに書き込む代わりに文字列で返します。"

#: ../../library/pickle.rst:209
msgid "The *protocol* parameter was added."
msgstr "*protocol* パラメータが追加されました。"

#: ../../library/pickle.rst:215
msgid ""
"Read a pickled object hierarchy from a string.  Characters in the string "
"past the pickled object's representation are ignored."
msgstr ""
"pickle 化されたオブジェクト階層を文字列から読み出します。文字列中で pickle 化"
"されたオブジェクト表現よりも後に続く文字列は無視されます。"

#: ../../library/pickle.rst:218
msgid "The :mod:`pickle` module also defines three exceptions:"
msgstr ":mod:`pickle` モジュールでは、以下の 3 つの例外も定義しています:"

#: ../../library/pickle.rst:223
msgid ""
"A common base class for the other exceptions defined below.  This inherits "
"from :exc:`Exception`."
msgstr ""
"下で定義されている他の例外で共通の基底クラスです。 :exc:`Exception` を継承し"
"ています。"

#: ../../library/pickle.rst:229
msgid ""
"This exception is raised when an unpicklable object is passed to the :meth:"
"`dump` method."
msgstr ""
"この例外は unpickle 不可能なオブジェクトが :meth:`dump` メソッドに渡された場"
"合に送出されます。"

#: ../../library/pickle.rst:235
msgid ""
"This exception is raised when there is a problem unpickling an object. Note "
"that other exceptions may also be raised during unpickling, including (but "
"not necessarily limited to) :exc:`AttributeError`, :exc:`EOFError`, :exc:"
"`ImportError`, and :exc:`IndexError`."
msgstr ""
"この例外は、オブジェクトを unpickle 化する際に問題が発生した場合に送出されま"
"す。 unpickle 化中には :exc:`AttributeError` 、 :exc:`EOFError` 、 :exc:"
"`ImportError` 、および :exc:`IndexError` といった他の例外 (これだけとは限りま"
"せん) も発生する可能性があるので注意してください。"

#: ../../library/pickle.rst:240
msgid ""
"The :mod:`pickle` module also exports two callables [#]_, :class:`Pickler` "
"and :class:`Unpickler`:"
msgstr ""
":mod:`pickle` モジュールでは、2 つの呼び出し可能オブジェクト [#]_ として、 :"
"class:`Pickler` および :class:`Unpickler` を提供しています:"

#: ../../library/pickle.rst:246
msgid ""
"This takes a file-like object to which it will write a pickle data stream."
msgstr ""
"pickle 化されたオブジェクトのデータ列を書き込むためのファイル類似のオブジェク"
"トを引数にとります。"

#: ../../library/pickle.rst:255
msgid ""
"*file* must have a :meth:`write` method that accepts a single string "
"argument. It can thus be an open file object, a :mod:`StringIO` object, or "
"any other custom object that meets this interface."
msgstr ""
"*file* は単一の文字列引数を受理する :meth:`write` メソッドを持たなければなり"
"ません。従って、 *file* としては、書き込みのために開かれたファイルオブジェク"
"ト、 :mod:`StringIO` オブジェクト、その他前述のインタフェースに適合する他のカ"
"スタムオブジェクトをとることができます。"

#: ../../library/pickle.rst:259
msgid ":class:`Pickler` objects define one (or two) public methods:"
msgstr ""
":class:`Pickler` オブジェクトでは、一つ (または二つ) の public なメソッドを定"
"義しています:"

#: ../../library/pickle.rst:264
msgid ""
"Write a pickled representation of *obj* to the open file object given in the "
"constructor.  Either the binary or ASCII format will be used, depending on "
"the value of the *protocol* argument passed to the constructor."
msgstr ""
"コンストラクタで与えられた、すでに開かれているファイルオブジェクトに *obj* "
"の pickle 化された表現を書き込みます。コンストラクタに渡された *protocol* 引"
"数の値に応じて、バイナリおよびASCII 形式が使われます。"

#: ../../library/pickle.rst:271
msgid ""
"Clears the pickler's \"memo\".  The memo is the data structure that "
"remembers which objects the pickler has already seen, so that shared or "
"recursive objects pickled by reference and not by value.  This method is "
"useful when re-using picklers."
msgstr ""
"picller の \"メモ\" を消去します。メモとは、共有オブジェクトまたは再帰的なオ"
"ブジェクトが値ではなく参照で記憶されるようにするために、 pickler がこれまでど"
"のオブジェクトに遭遇してきたかを記憶するデータ構造です。このメソッドは "
"pickler を再利用する際に便利です。"

#: ../../library/pickle.rst:278
msgid ""
"Prior to Python 2.3, :meth:`clear_memo` was only available on the picklers "
"created by :mod:`cPickle`.  In the :mod:`pickle` module, picklers have an "
"instance variable called :attr:`memo` which is a Python dictionary.  So to "
"clear the memo for a :mod:`pickle` module pickler, you could do the "
"following::"
msgstr ""
"Python 2.3 以前では、 :meth:`clear_memo` は :mod:`cPickle` で生成された "
"pickler でのみ利用可能でした。 :mod:`pickle` モジュールでは、pickler は :"
"attr:`memo` と呼ばれる Python 辞書型のインスタンス変数を持ちます。従って、 :"
"mod:`pickler` モジュールにおける pickler のメモを消去は、以下のようにしてでき"
"ます::"

#: ../../library/pickle.rst:285
msgid ""
"Code that does not need to support older versions of Python should simply "
"use :meth:`clear_memo`."
msgstr ""
"以前のバージョンの Python での動作をサポートする必要のないコードでは、単に :"
"meth:`clear_memo` を使ってください。"

#: ../../library/pickle.rst:288
msgid ""
"It is possible to make multiple calls to the :meth:`dump` method of the "
"same :class:`Pickler` instance.  These must then be matched to the same "
"number of calls to the :meth:`load` method of the corresponding :class:"
"`Unpickler` instance.  If the same object is pickled by multiple :meth:"
"`dump` calls, the :meth:`load` will all yield references to the same object. "
"[#]_"
msgstr ""
"同じ :class:`Pickler` のインスタンスに対し、 :meth:`dump` メソッドを複数回呼"
"び出すことは可能です。この呼び出しは、対応する :class:`Unpickler` インスタン"
"スで同じ回数だけ :meth:`load` を呼び出す操作に対応します。同じオブジェクト"
"が :meth:`dump` を複数回呼び出して pickle 化された場合、 :meth:`load` は全て"
"同じオブジェクトに対して参照を行います [#]_ 。"

#: ../../library/pickle.rst:294
msgid ":class:`Unpickler` objects are defined as:"
msgstr ":class:`Unpickler` オブジェクトは以下のように定義されています:"

#: ../../library/pickle.rst:299
msgid ""
"This takes a file-like object from which it will read a pickle data stream. "
"This class automatically determines whether the data stream was written in "
"binary mode or not, so it does not need a flag as in the :class:`Pickler` "
"factory."
msgstr ""
"pickle データ列を読み出すためのファイル類似のオブジェクトを引数に取ります。こ"
"のクラスはデータ列がバイナリモードかどうかを自動的に判別します。従って、 :"
"class:`Pickler` のファクトリメソッドのようなフラグを必要としません。"

#: ../../library/pickle.rst:310
msgid ":class:`Unpickler` objects have one (or two) public methods:"
msgstr ""
":class:`Unpickler` オブジェクトは 1 つ (または 2 つ) の public なメソッドを"
"持っています:"

#: ../../library/pickle.rst:315
msgid ""
"Read a pickled object representation from the open file object given in the "
"constructor, and return the reconstituted object hierarchy specified therein."
msgstr ""
"コンストラクタで渡されたファイルオブジェクトからオブジェクトの pickle 化表現"
"を読み出し、中に収められている再構築されたオブジェクト階層を返します。"

#: ../../library/pickle.rst:319
msgid ""
"This method automatically determines whether the data stream was written in "
"binary mode or not."
msgstr ""
"このメソッドは自動的にデータストリームがバイナリモードで書き出されているかど"
"うかを判別します。"

#: ../../library/pickle.rst:325
msgid ""
"This is just like :meth:`load` except that it doesn't actually create any "
"objects.  This is useful primarily for finding what's called \"persistent "
"ids\" that may be referenced in a pickle data stream.  See section :ref:"
"`pickle-protocol` below for more details."
msgstr ""
":meth:`load` に似ていますが、実際には何もオブジェクトを生成しないという点が違"
"います。この関数は第一に pickle 化データ列中で参照されている、\"永続化 id\" "
"と呼ばれている値を検索する上で便利です。詳細は以下の :ref:`pickle-protocol` "
"を参照してください。"

#: ../../library/pickle.rst:330
msgid ""
"**Note:** the :meth:`noload` method is currently only available on :class:"
"`Unpickler` objects created with the :mod:`cPickle` module. :mod:`pickle` "
"module :class:`Unpickler`\\ s do not have the :meth:`noload` method."
msgstr ""
"**注意:** :meth:`noload` メソッドは現在 :mod:`cPickle` モジュールで生成され"
"た :class:`Unpickler` オブジェクトのみで利用可能です。 :mod:`pickle` モジュー"
"ルの :class:`Unpickler` には、 :meth:`noload` メソッドがありません。"

#: ../../library/pickle.rst:337
msgid "What can be pickled and unpickled?"
msgstr "何を pickle 化したり unpickle 化できるのか?"

#: ../../library/pickle.rst:339
msgid "The following types can be pickled:"
msgstr "以下の型は pickle 化できます:"

#: ../../library/pickle.rst:341
msgid "``None``, ``True``, and ``False``"
msgstr "``None`` 、 ``True`` 、および ``False``"

#: ../../library/pickle.rst:343
msgid "integers, long integers, floating point numbers, complex numbers"
msgstr "整数、長整数、浮動小数点数、複素数"

#: ../../library/pickle.rst:345
msgid "normal and Unicode strings"
msgstr "通常文字列および Unicode 文字列"

#: ../../library/pickle.rst:347
msgid "tuples, lists, sets, and dictionaries containing only picklable objects"
msgstr "pickle 化可能なオブジェクトからなるタプル、リスト、集合および辞書"

#: ../../library/pickle.rst:349
msgid "functions defined at the top level of a module"
msgstr "モジュールのトップレベルで定義されている関数"

#: ../../library/pickle.rst:351
msgid "built-in functions defined at the top level of a module"
msgstr "モジュールのトップレベルで定義されている組込み関数"

#: ../../library/pickle.rst:353
msgid "classes that are defined at the top level of a module"
msgstr "モジュールのトップレベルで定義されているクラス"

#: ../../library/pickle.rst:355
msgid ""
"instances of such classes whose :attr:`~object.__dict__` or the result of "
"calling :meth:`__getstate__` is picklable  (see section :ref:`pickle-"
"protocol` for details)."
msgstr ""
":attr:`~object.__dict__` 属性を持つクラス、あるいは :meth:`__getstate__` メ"
"ソッドの返り値が pickle 化可能なクラス (詳細は :ref:`pickle-protocol` を参"
"照)。"

#: ../../library/pickle.rst:359
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file. Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a :exc:"
"`RuntimeError` will be raised in this case. You can carefully raise this "
"limit with :func:`sys.setrecursionlimit`."
msgstr ""
"pickle 化できないオブジェクトを pickle 化しようとすると、 :exc:"
"`PicklingError` 例外が送出されます; この例外が起きた場合、背後のファイルには"
"未知の長さのバイト列が書き込まれてしまいます。極端に再帰的なデータ構造を "
"pickle 化しようとした場合には再帰の深さ制限を越えてしまうかもしれず、この場合"
"には :exc:`RuntimeError` が送出されます。この制限は、 :func:`sys."
"setrecursionlimit` で慎重に上げていくことは可能です。"

#: ../../library/pickle.rst:366
msgid ""
"Note that functions (built-in and user-defined) are pickled by \"fully "
"qualified\" name reference, not by value.  This means that only the function "
"name is pickled, along with the name of the module the function is defined "
"in.  Neither the function's code, nor any of its function attributes are "
"pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""
"(組み込みおよびユーザ定義の) 関数は、値ではなく \"完全記述された\" 参照名とし"
"て pickle 化されるので注意してください。これは、関数の定義されているモジュー"
"ルの名前と一緒と併せ、関数名だけが pickle 化されることを意味します。関数の"
"コードや関数の属性は何も pickle化されません。従って、定義しているモジュール"
"は unpickle 化環境で import 可能でなければならず、そのモジュールには指定され"
"たオブジェクトが含まれていなければなりません。そうでない場合、例外が送出され"
"ます [#]_ 。"

#: ../../library/pickle.rst:373
msgid ""
"Similarly, classes are pickled by named reference, so the same restrictions "
"in the unpickling environment apply.  Note that none of the class's code or "
"data is pickled, so in the following example the class attribute ``attr`` is "
"not restored in the unpickling environment::"
msgstr ""
"クラスも同様に名前参照で pickle 化されるので、unpickle 化環境には同じ制限が課"
"せられます。クラス中のコードやデータは何も pickle 化されないので、以下の例で"
"はクラス属性 ``attr`` が unpickle 化環境で復元されないことに注意してくださ"
"い ::"

#: ../../library/pickle.rst:383
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"in the top level of a module."
msgstr ""
"pickle 化可能な関数やクラスがモジュールのトップレベルで定義されていなければな"
"らないのはこれらの制限のためです。"

#: ../../library/pickle.rst:386
msgid ""
"Similarly, when class instances are pickled, their class's code and data are "
"not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`__setstate__` "
"method."
msgstr ""
"同様に、クラスのインスタンスが pickle 化された際、そのクラスのコードおよび"
"データはオブジェクトと一緒に pickle 化されることはありません。インスタンスの"
"データのみが pickle 化されます。この仕様は、クラス内のバグを修正したりメソッ"
"ドを追加した後でも、そのクラスの以前のバージョンで作られたオブジェクトを読み"
"出せるように意図的に行われています。あるクラスの多くのバージョンで使われるよ"
"うな長命なオブジェクトを作ろうと計画しているなら、そのクラスの :meth:"
"`__setstate__` メソッドによって適切な変換が行われるようにオブジェクトのバー"
"ジョン番号を入れておくとよいかもしれません。"

#: ../../library/pickle.rst:398
msgid "The pickle protocol"
msgstr "pickle 化プロトコル"

#: ../../library/pickle.rst:402
msgid ""
"This section describes the \"pickling protocol\" that defines the interface "
"between the pickler/unpickler and the objects that are being serialized.  "
"This protocol provides a standard way for you to define, customize, and "
"control how your objects are serialized and de-serialized.  The description "
"in this section doesn't cover specific customizations that you can employ to "
"make the unpickling environment slightly safer from untrusted pickle data "
"streams; see section :ref:`pickle-sub` for more details."
msgstr ""
"この節では pickler/unpickler と直列化対象のオブジェクトとの間のインタフェース"
"を定義する \"pickle 化プロトコル\"について記述します。このプロトコルは自分の"
"オブジェクトがどのように直列化されたり非直列化されたりするかを定義し、カスタ"
"マイズし、制御するための標準的な方法を提供します。この節での記述は、unpickle "
"化環境を不信な pickle 化データに対して安全にするために使う特殊なカスタマイズ"
"化についてはカバーしていません; 詳細は :ref:`pickle-sub` を参照してください。"

#: ../../library/pickle.rst:414
msgid "Pickling and unpickling normal class instances"
msgstr "通常のクラスインスタンスの pickle 化および unpickle 化"

#: ../../library/pickle.rst:418
msgid ""
"When a pickled class instance is unpickled, its :meth:`__init__` method is "
"normally *not* invoked.  If it is desirable that the :meth:`__init__` method "
"be called on unpickling, an old-style class can define a method :meth:"
"`__getinitargs__`, which should return a *tuple* of positional arguments to "
"be passed to the class constructor (:meth:`__init__` for example).  Keyword "
"arguments are not supported.  The :meth:`__getinitargs__` method is called "
"at pickle time; the tuple it returns is incorporated in the pickle for the "
"instance."
msgstr ""
"pickle 化されたクラスインスタンスが unpickle 化されたとき、 :meth:`__init__` "
"メソッドは通常呼び出され *ません* 。\n"
"unpickle 化の際に :meth:`__init__` が呼び出される方が望ましい場合、旧スタイル"
"クラスではメソッド :meth:`__getinitargs__` を定義することができます。\n"
"このメソッドはクラスコンストラクタ (例えば :meth:`__init__`) に渡されるべき位"
"置引数からなる *タプル* を返さなければなりません。\n"
":meth:`__getinitargs__` メソッドは pickle 時に呼び出されます; この関数が返す"
"タプルはインスタンスの pickle 化データに組み込まれます。"

#: ../../library/pickle.rst:429
msgid ""
"New-style types can provide a :meth:`__getnewargs__` method that is used for "
"protocol 2.  Implementing this method is needed if the type establishes some "
"internal invariants when the instance is created, or if the memory "
"allocation is affected by the values passed to the :meth:`__new__` method "
"for the type (as it is for tuples and strings).  Instances of a :term:`new-"
"style class` ``C`` are created using ::"
msgstr ""
"新スタイルクラスでは、プロトコル 2 で呼び出される :meth:`__getnewargs__` を定"
"義する事ができます。インスタンス生成時に内部的な不変条件が成立する必要があっ"
"たり、（タプルや文字列のように）型の :meth:`__new__` メソッドに指定する引数に"
"よってメモリの割り当てを変更する必要がある場合には :meth:`__getnewargs__` を"
"定義してください。新スタイルクラス :class:`C` のインスタンスは、次のように生"
"成されます。::"

#: ../../library/pickle.rst:438
msgid ""
"where *args* is the result of calling :meth:`__getnewargs__` on the original "
"object; if there is no :meth:`__getnewargs__`, an empty tuple is assumed."
msgstr ""
"ここで *args* は元のオブジェクトの :meth:`__getnewargs__` メソッドを呼び出し"
"た時の戻り値となります。 :meth:`__getnewargs__` を定義していない場合、 "
"*args* は空のタプルとなります。"

#: ../../library/pickle.rst:443
msgid ""
"Classes can further influence how their instances are pickled; if the class "
"defines the method :meth:`__getstate__`, it is called and the return state "
"is pickled as the contents for the instance, instead of the contents of the "
"instance's dictionary.  If there is no :meth:`__getstate__` method, the "
"instance's :attr:`~object.__dict__` is pickled."
msgstr ""
"クラスは、インスタンスの pickle 化方法にさらに影響を与えることができます; ク"
"ラスが :meth:`__getstate__` メソッドを定義している場合、このメソッドが呼び出"
"され、返された状態値はインスタンスの内容として、インスタンスの辞書の代わりに "
"pickle 化されます。 :meth:`__getstate__` メソッドが定義されていない場合、イン"
"スタンスの :attr:`~object.__dict__` の内容が pickle 化されます。"

#: ../../library/pickle.rst:451
msgid ""
"Upon unpickling, if the class also defines the method :meth:`__setstate__`, "
"it is called with the unpickled state. [#]_ If there is no :meth:"
"`__setstate__` method, the pickled state must be a dictionary and its items "
"are assigned to the new instance's dictionary.  If a class defines both :"
"meth:`__getstate__` and :meth:`__setstate__`, the state object needn't be a "
"dictionary and these methods can do what they want. [#]_"
msgstr ""
"unpickle 化では、クラスが :meth:`__setstate__` も定義していた場合、 unpickle "
"化された状態値とともに呼び出されます。 [#]_ :meth:`__setstate__` メソッドが定"
"義されていない場合、pickle 化された状態は辞書型でなければならず、その要素は新"
"たなインスタンスの辞書に代入されます。クラスが :meth:`__getstate__` と :meth:"
"`__setstate__` の両方を定義している場合、状態値オブジェクトは辞書である必要は"
"なく、これらのメソッドは期待通りの動作を行います。 [#]_"

#: ../../library/pickle.rst:460
msgid ""
"For :term:`new-style class`\\es, if :meth:`__getstate__` returns a false "
"value, the :meth:`__setstate__` method will not be called."
msgstr ""
"新しいスタイルのクラスにおいて :meth:`__getstate__` が偽値を返す場合、 :meth:"
"`__setstate__` メソッドは呼ばれません。"

#: ../../library/pickle.rst:465
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, :meth:"
"`__getattribute__`, or :meth:`__setattr__` may be called upon the instance.  "
"In case those methods rely on some internal invariant being true, the type "
"should implement either :meth:`__getinitargs__` or :meth:`__getnewargs__` to "
"establish such an invariant; otherwise, neither :meth:`__new__` nor :meth:"
"`__init__` will be called."
msgstr ""
"unpickleするとき、 :meth:`__getattr__`, :meth:`__getattribute__`, :meth:"
"`__setattr__` といったメソッドがインスタンスに対して呼ばれます。これらのメ"
"ソッドが何か内部の不変条件に依存しているのであれば、その型は :meth:"
"`__getinitargs__` か :meth:`__getnewargs__` のどちらかを実装してその不変条件"
"を満たせるようにするべきです。それ以外の場合、 :meth:`__new__` も :meth:"
"`__init__` も呼ばれません。"

#: ../../library/pickle.rst:474
msgid "Pickling and unpickling extension types"
msgstr "拡張型の pickle 化および unpickle 化"

#: ../../library/pickle.rst:478
msgid ""
"When the :class:`Pickler` encounters an object of a type it knows nothing "
"about --- such as an extension type --- it looks in two places for a hint of "
"how to pickle it.  One alternative is for the object to implement a :meth:"
"`__reduce__` method.  If provided, at pickling time :meth:`__reduce__` will "
"be called with no arguments, and it must return either a string or a tuple."
msgstr ""
":class:`Pickler` が全く未知の型の --- 拡張型のような --- オブジェクトに遭遇し"
"た場合、pickle 化方法のヒントとして 2 個所を探します。第一は :meth:"
"`__reduce__` メソッドを実装しているかどうかです。もし実装されていれば、"
"pickle 化時に :meth:`__reduce__` メソッドが引数なしで呼び出されます。メソッド"
"はこの呼び出しに対して文字列またはタプルのどちらかを返さねばなりません。"

#: ../../library/pickle.rst:485
msgid ""
"If a string is returned, it names a global variable whose contents are "
"pickled as normal.  The string returned by :meth:`__reduce__` should be the "
"object's local name relative to its module; the pickle module searches the "
"module namespace to determine the object's module."
msgstr ""
"文字列を返す場合、その文字列は通常通りに pickle 化されるグローバル変数の名前"
"を指しています。 :meth:`__reduce__` の返す文字列は、モジュールにからみてオブ"
"ジェクトのローカルな名前でなければなりません; pickle モジュールはモジュールの"
"名前空間を検索して、オブジェクトの属するモジュールを決定します。"

#: ../../library/pickle.rst:490
msgid ""
"When a tuple is returned, it must be between two and five elements long. "
"Optional elements can either be omitted, or ``None`` can be provided as "
"their value.  The contents of this tuple are pickled as normal and used to "
"reconstruct the object at unpickling time.  The semantics of each element "
"are:"
msgstr ""
"タプルを返す場合、タプルの要素数は 2 から 5 でなければなりません。オプション"
"の要素は省略したり ``None`` を指定したりできます。各要素の意味づけは以下の通"
"りです:"

#: ../../library/pickle.rst:496
msgid ""
"A callable object that will be called to create the initial version of the "
"object.  The next element of the tuple will provide arguments for this "
"callable, and later elements provide additional state information that will "
"subsequently be used to fully reconstruct the pickled data."
msgstr ""
"オブジェクトの初期バージョンを生成するために呼び出される呼び出し可能オブジェ"
"クトです。この呼び出し可能オブジェクトへの引数はタプルの次の要素で与えられま"
"す。それ以降の要素では pickle 化されたデータを完全に再構築するために使われる"
"付加的な状態情報が与えられます。"

#: ../../library/pickle.rst:501
msgid ""
"In the unpickling environment this object must be either a class, a callable "
"registered as a \"safe constructor\" (see below), or it must have an "
"attribute :attr:`__safe_for_unpickling__` with a true value. Otherwise, an :"
"exc:`UnpicklingError` will be raised in the unpickling environment.  Note "
"that as usual, the callable itself is pickled by name."
msgstr ""
"逆 pickle 化の環境下では、このオブジェクトはクラスか、 \"安全なコンストラク"
"タ (safe constructor, 下記参照)\" として登録されていたり属性 :attr:"
"`__safe_for_unpickling__` の値が真であるような呼び出し可能オブジェクトでなけ"
"ればなりません。そうでない場合、逆 pickle 化を行う環境で :exc:"
"`UnpicklingError` が送出されます。通常通り、 callable は名前だけで pickle 化"
"されるので注意してください。"

#: ../../library/pickle.rst:507
msgid "A tuple of arguments for the callable object."
msgstr "呼び出し可能なオブジェクトのための引数からなるタプル"

#: ../../library/pickle.rst:509
msgid "Formerly, this argument could also be ``None``."
msgstr "以前は、この引数には ``None`` もあり得ました。"

#: ../../library/pickle.rst:512
msgid ""
"Optionally, the object's state, which will be passed to the object's :meth:"
"`__setstate__` method as described in section :ref:`pickle-inst`.  If the "
"object has no :meth:`__setstate__` method, then, as above, the value must be "
"a dictionary and it will be added to the object's :attr:`~object.__dict__`."
msgstr ""
"オプションとして、 :ref:`pickle-inst` 節で記述されているようにオブジェクト"
"の :meth:`__setstate__` メソッドに渡される、オブジェクトの状態。オブジェクト"
"が :meth:`__setstate__` メソッドを持たない場合、上記のように、この値は辞書で"
"なくてはならず、オブジェクトの :attr:`~object.__dict__` に追加されます。"

#: ../../library/pickle.rst:518
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive list "
"items.  These list items will be pickled, and appended to the object using "
"either ``obj.append(item)`` or ``obj.extend(list_of_items)``.  This is "
"primarily used for list subclasses, but may be used by other classes as long "
"as they have :meth:`append` and :meth:`extend` methods with the appropriate "
"signature.  (Whether :meth:`append` or :meth:`extend` is used depends on "
"which pickle protocol version is used as well as the number of items to "
"append, so both must be supported.)"
msgstr ""
"オプションとして、リスト中の連続する要素を返すイテレータ (シーケンスではあり"
"ません)。このリストの要素は pickle 化され、 ``obj.append(item)`` または "
"``obj.extend(list_of_items)`` のいずれかを使って追加されます。主にリストのサ"
"ブクラスで用いられていますが、他のクラスでも、適切なシグネチャの :meth:"
"`append` や :meth:`extend` を備えている限り利用できます。 (:meth:`append` "
"と :meth:`extend` のいずれを使うかは、どのバージョンの pickle プロトコルを"
"使っているか、そして追加する要素の数で決まります。従って両方のメソッドをサ"
"ポートしていなければなりません。)"

#: ../../library/pickle.rst:527
msgid ""
"Optionally, an iterator (not a sequence) yielding successive dictionary "
"items, which should be tuples of the form ``(key, value)``.  These items "
"will be pickled and stored to the object using ``obj[key] = value``. This is "
"primarily used for dictionary subclasses, but may be used by other classes "
"as long as they implement :meth:`__setitem__`."
msgstr ""
"オプションとして、辞書中の連続する要素を返すイテレータ (シーケンスではありま"
"せん)。このリストの要素は ``(key, value)`` という形式でなければなりません。要"
"素は pickle 化され、 ``obj[key] = value`` を使ってオブジェクトに格納されま"
"す。主に辞書のサブクラスで用いられていますが、他のクラスでも、 :meth:"
"`__setitem__` を備えている限り利用できます。"

#: ../../library/pickle.rst:535
msgid ""
"It is sometimes useful to know the protocol version when implementing :meth:"
"`__reduce__`.  This can be done by implementing a method named :meth:"
"`__reduce_ex__` instead of :meth:`__reduce__`. :meth:`__reduce_ex__`, when "
"it exists, is called in preference over :meth:`__reduce__` (you may still "
"provide :meth:`__reduce__` for backwards compatibility).  The :meth:"
"`__reduce_ex__` method will be called with a single integer argument, the "
"protocol version."
msgstr ""
":meth:`__reduce__` を実装する場合、プロトコルのバージョンを知っておくと便利な"
"ことがあります。これは :meth:`__reduce__` の代わりに :meth:`__reduce_ex__` を"
"使って実現できます。 :meth:`__reduce_ex__` が定義されている場合、 :meth:"
"`__reduce__` よりも優先して呼び出されます (以前のバージョンとの互換性のため"
"に :meth:`__reduce__` を残しておいてもかまいません)。 :meth:`__reduce_ex__` "
"はプロトコルのバージョンを表す整数の引数を一つ伴って呼び出されます。"

#: ../../library/pickle.rst:543
msgid ""
"The :class:`object` class implements both :meth:`__reduce__` and :meth:"
"`__reduce_ex__`; however, if a subclass overrides :meth:`__reduce__` but "
"not :meth:`__reduce_ex__`, the :meth:`__reduce_ex__` implementation detects "
"this and calls :meth:`__reduce__`."
msgstr ""
":class:`object` クラスでは :meth:`__reduce__` と :meth:`__reduce_ex__` の両方"
"を定義しています。とはいえ、サブクラスで :meth:`__reduce__` をオーバライドし"
"ており、 :meth:`__reduce_ex__` をオーバライドしていない場合には、 :meth:"
"`__reduce_ex__` の実装がそれを検出して :meth:`__reduce__` を呼び出すように"
"なっています。"

#: ../../library/pickle.rst:548
msgid ""
"An alternative to implementing a :meth:`__reduce__` method on the object to "
"be pickled, is to register the callable with the :mod:`copy_reg` module.  "
"This module provides a way for programs to register \"reduction functions\" "
"and constructors for user-defined types.   Reduction functions have the same "
"semantics and interface as the :meth:`__reduce__` method described above, "
"except that they are called with a single argument, the object to be pickled."
msgstr ""
"pickle 化するオブジェクト上で :meth:`__reduce__` メソッドを実装する代わり"
"に、 :mod:`copy_reg` モジュールを使って呼び出し可能オブジェクトを登録する方法"
"もあります。このモジュールはプログラムに \"縮小化関数 (reduction function)\" "
"とユーザ定義型のためのコンストラクタを登録する方法を提供します。縮小化関数"
"は、単一の引数として pickle 化するオブジェクトをとることを除き、上で述べた :"
"meth:`__reduce__` メソッドと同じ意味とインタフェースを持ちます。"

#: ../../library/pickle.rst:555
msgid ""
"The registered constructor is deemed a \"safe constructor\" for purposes of "
"unpickling as described above."
msgstr ""
"登録されたコンストラクタは上で述べたような unpickle 化については \"安全なコン"
"ストラクタ\" であると考えられます。"

#: ../../library/pickle.rst:560
msgid "Pickling and unpickling external objects"
msgstr "外部オブジェクトの pickle 化および unpickle 化"

#: ../../library/pickle.rst:566
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the "
"notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a \"persistent id\", which is just an arbitrary "
"string of printable ASCII characters. The resolution of such names is not "
"defined by the :mod:`pickle` module; it will delegate this resolution to "
"user defined functions on the pickler and unpickler. [#]_"
msgstr ""
"オブジェクトの永続化を便利にするために、 :mod:`pickle` は pickle 化されたデー"
"タ列上にないオブジェクトに対して参照を行うという概念をサポートしています。こ"
"れらのオブジェクトは \"永続化 id (persistent id)\" で参照されており、この id "
"は単に印字可能なASCII 文字からなる任意の文字列です。これらの名前の解決方法"
"は :mod:`pickle` モジュールでは定義されていません; オブジェクトはこの名前解決"
"を pickler および unpickler 上のユーザ定義関数にゆだねます [#]_ 。"

#: ../../library/pickle.rst:573
msgid ""
"To define external persistent id resolution, you need to set the :attr:"
"`~Pickler.persistent_id` attribute of the pickler object and the :attr:"
"`~Unpickler.persistent_load` attribute of the unpickler object."
msgstr ""
"外部永続化 id の解決を定義するには、pickler オブジェクトの :attr:`~Pickler."
"persistent_id` 属性と、 unpickler オブジェクトの :attr:`~Unpickler."
"persistent_load` 属性を設定する必要があります。"

#: ../../library/pickle.rst:577
msgid ""
"To pickle objects that have an external persistent id, the pickler must have "
"a custom :func:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent id for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent id string is returned, the pickler will pickle that "
"string, along with a marker so that the unpickler will recognize the string "
"as a persistent id."
msgstr ""
"外部永続化 id を持つオブジェクトを pickle 化するには、pickler は自作の :func:"
"`~Pickler.persistent_id` メソッドを持たなければなりません。このメソッドは一つ"
"の引数をとり、 ``None`` とオブジェクトの永続化 id のうちどちらかを返さなけれ"
"ばなりません。 ``None`` が返された場合、 pickler は単にオブジェクトを通常のよ"
"うに pickle 化するだけです。永続化 id 文字列が返された場合、 piclkler はその"
"文字列に対して、unpickler がこの文字列を永続化 id として認識できるように、"
"マーカと共に pickle 化します。"

#: ../../library/pickle.rst:585
msgid ""
"To unpickle external objects, the unpickler must have a custom :func:"
"`~Unpickler.persistent_load` function that takes a persistent id string and "
"returns the referenced object."
msgstr ""
"外部オブジェクトを unpickle 化するには、unpickler は自作の :func:`~Unpickler."
"persistent_load` 関数を持たなければなりません。この関数は永続化 id 文字列を引"
"数にとり、参照されているオブジェクトを返します。"

#: ../../library/pickle.rst:589
msgid "Here's a silly example that *might* shed more light::"
msgstr "*多分* より理解できるようになるようなちょっとした例を以下に示します::"

#: ../../library/pickle.rst:637
msgid ""
"In the :mod:`cPickle` module, the unpickler's :attr:`~Unpickler."
"persistent_load` attribute can also be set to a Python list, in which case, "
"when the unpickler reaches a persistent id, the persistent id string will "
"simply be appended to this list.  This functionality exists so that a pickle "
"data stream can be \"sniffed\" for object references without actually "
"instantiating all the objects in a pickle. [#]_  Setting :attr:`~Unpickler."
"persistent_load` to a list is usually used in conjunction with the :meth:"
"`~Unpickler.noload` method on the Unpickler."
msgstr ""
":mod:`cPickle` モジュール内では、 unpickler の :attr:`~Unpickler."
"persistent_load` 属性は Pythonリスト型として設定することができます。この場"
"合、 unpickler が永続化 id に遭遇しても、永続化 id 文字列は単にリストに追加さ"
"れるだけです。この仕様は、pickle データ中の全てのオブジェクトを実際にインスタ"
"ンス化しなくても、 pickle データ列中でオブジェクトに対する参照を \"嗅ぎ回る"
"\" ことができるようにするために存在しています [#]_ 。リストに :attr:"
"`~Unpickler.persistent_load` を設定するやり方は、よく Unpickler クラスの :"
"meth:`~Unpickler.noload` メソッドと共に使われます。"

#: ../../library/pickle.rst:655
msgid "Subclassing Unpicklers"
msgstr "Unpickler をサブクラス化する"

#: ../../library/pickle.rst:661
msgid ""
"By default, unpickling will import any class that it finds in the pickle "
"data. You can control exactly what gets unpickled and what gets called by "
"customizing your unpickler.  Unfortunately, exactly how you do this is "
"different depending on whether you're using :mod:`pickle` or :mod:`cPickle`. "
"[#]_"
msgstr ""
"デフォルトでは、逆 pickle 化は pickle 化されたデータ中に見つかったクラスを "
"import することになります。自前の unpickler をカスタマイズすることで、何が "
"unpickle 化されて、どのメソッドが呼び出されるかを厳密に制御することはできま"
"す。しかし不運なことに、厳密になにを行うべきかは :mod:`pickle` と :mod:"
"`cPickle` のどちらを使うかで異なります [#]_ 。"

#: ../../library/pickle.rst:666
msgid ""
"In the :mod:`pickle` module, you need to derive a subclass from :class:"
"`Unpickler`, overriding the :meth:`load_global` method. :meth:`load_global` "
"should read two lines from the pickle data stream where the first line will "
"the name of the module containing the class and the second line will be the "
"name of the instance's class.  It then looks up the class, possibly "
"importing the module and digging out the attribute, then it appends what it "
"finds to the unpickler's stack.  Later on, this class will be assigned to "
"the :attr:`__class__` attribute of an empty class, as a way of magically "
"creating an instance without calling its class's :meth:`__init__`. Your job "
"(should you choose to accept it), would be to have :meth:`load_global` push "
"onto the unpickler's stack, a known safe version of any class you deem safe "
"to unpickle. It is up to you to produce such a class.  Or you could raise an "
"error if you want to disallow all unpickling of instances.  If this sounds "
"like a hack, you're right.  Refer to the source code to make this work."
msgstr ""
":mod:`pickle` モジュールでは、 :class:`Unpickler` からサブクラスを派生し、 :"
"meth:`load_global` メソッドを上書きする必要があります。 :meth:`load_global` "
"は pickle データ列から最初の 2 行を読まなければならず、ここで最初の行はそのク"
"ラスを含むモジュールの名前、2 行目はそのインスタンスのクラス名になるはずで"
"す。次にこのメソッドは、例えばモジュールをインポートして属性を掘り起こすなど"
"してクラスを探し、発見されたものを unpickler のスタックに置きます。その後、こ"
"のクラスは空のクラスの :attr:`__class__` 属性に代入する方法で、クラスの :"
"meth:`__init__` を使わずにインスタンスを魔法のように生成します。あなたの作業"
"は (もしその作業を受け入れるなら)、unpickler のスタックの上に push された :"
"meth:`load_global` を、unpickle しても安全だと考えられる何らかのクラスの既知"
"の安全なバージョンにすることです。あるいは全てのインスタンスに対して "
"unpickling を許可したくないならエラーを送出してください。このからくりがハック"
"のように思えるなら、あなたは間違っていません。このからくりを動かすには、ソー"
"スコードを参照してください。"

#: ../../library/pickle.rst:681
msgid ""
"Things are a little cleaner with :mod:`cPickle`, but not by much. To control "
"what gets unpickled, you can set the unpickler's :attr:`~Unpickler."
"find_global` attribute to a function or ``None``.  If it is ``None`` then "
"any attempts to unpickle instances will raise an :exc:`UnpicklingError`.  If "
"it is a function, then it should accept a module name and a class name, and "
"return the corresponding class object.  It is responsible for looking up the "
"class and performing any necessary imports, and it may raise an error to "
"prevent instances of the class from being unpickled."
msgstr ""
":mod:`cPickle` では事情は多少すっきりしていますが、十分というわけではありませ"
"ん。何を unpickle 化するかを制御するには、 unpickler の :attr:`~Unpickler."
"find_global` 属性を関数か ``None`` に設定します。属性が ``None`` の場合、イン"
"スタンスを unpickle しようとする試みは全て :exc:`UnpicklingError` を送出しま"
"す。属性が関数の場合、この関数はモジュール名またはクラス名を受理し、対応する"
"クラスオブジェクトを返さなくてはなりません。このクラスが行わなくてはならない"
"のは、クラスの探索、必要な import のやり直しです。そしてそのクラスのインスタ"
"ンスが unpickle 化されるのを防ぐためにエラーを送出することもできます。"

#: ../../library/pickle.rst:690
msgid ""
"The moral of the story is that you should be really careful about the source "
"of the strings your application unpickles."
msgstr ""
"以上の話から言えることは、アプリケーションが unpickle 化する文字列の発信元に"
"ついては非常に高い注意をはらわなくてはならないということです。"

#: ../../library/pickle.rst:697
msgid "Example"
msgstr "例"

#: ../../library/pickle.rst:699
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions.  "
"Note that a self-referencing list is pickled and restored correctly. ::"
msgstr ""
"いちばん単純には、 :func:`dump` と :func:`load` を使用してください。自己参照"
"リストが正しく pickle 化およびリストアされることに注目してください。 ::"

#: ../../library/pickle.rst:721
msgid ""
"The following example reads the resulting pickled data.  When reading a "
"pickle-containing file, you should open the file in binary mode because you "
"can't be sure if the ASCII or binary format was used. ::"
msgstr ""
"以下の例は pickle 化された結果のデータを読み込みます。 pickle を含むデータを"
"読み込む場合、ファイルはバイナリモードでオープンしなければいけません。これは "
"ASCII 形式とバイナリ形式のどちらが使われているかは分からないからです。 ::"

#: ../../library/pickle.rst:737
msgid ""
"Here's a larger example that shows how to modify pickling behavior for a "
"class. The :class:`TextReader` class opens a text file, and returns the line "
"number and line contents each time its :meth:`!readline` method is called. "
"If a :class:`TextReader` instance is pickled, all attributes *except* the "
"file object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The :meth:"
"`__setstate__` and :meth:`__getstate__` methods are used to implement this "
"behavior. ::"
msgstr ""
"より大きな例で、クラスを pickle 化する挙動を変更するやり方を示します。 :"
"class:`TextReader` クラスはテキストファイルを開き、 :meth:`!readline` メソッ"
"ドが呼ばれるたびに行番号と行の内容を返します。 :class:`TextReader` インスタン"
"スが pickle 化された場合、ファイルオブジェクト *以外の* 全ての属性が保存され"
"ます。インスタンスが unpickle 化された際、ファイルは再度開かれ、以前のファイ"
"ル位置から読み出しを再開します。上記の動作を実装するために、 :meth:"
"`__setstate__` および :meth:`__getstate__` メソッドが使われています。 ::"

#: ../../library/pickle.rst:777
msgid "A sample usage might be something like this::"
msgstr "使用例は以下のようになるでしょう::"

#: ../../library/pickle.rst:790
msgid ""
"If you want to see that :mod:`pickle` works across Python processes, start "
"another Python session, before continuing.  What follows can happen from "
"either the same process or a new process. ::"
msgstr ""
":mod:`pickle` が Python プロセス間でうまく働くことを見たいなら、先に進む前に"
"他の Python セッションを開始してください。以下の振る舞いは同じプロセスでも新"
"たなプロセスでも起こります。 ::"

#: ../../library/pickle.rst:803
msgid "Module :mod:`copy_reg`"
msgstr ":mod:`copy_reg` モジュール"

#: ../../library/pickle.rst:803
msgid "Pickle interface constructor registration for extension types."
msgstr "拡張型を登録するための Pickle インタフェース構成機構。"

#: ../../library/pickle.rst:806
msgid "Module :mod:`shelve`"
msgstr ":mod:`shelve` モジュール"

#: ../../library/pickle.rst:806
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "オブジェクトのインデクス付きデータベース; :mod:`pickle` を使います。"

#: ../../library/pickle.rst:809
msgid "Module :mod:`copy`"
msgstr ":mod:`copy` モジュール"

#: ../../library/pickle.rst:809
msgid "Shallow and deep object copying."
msgstr "オブジェクトの浅いコピーおよび深いコピー。"

#: ../../library/pickle.rst:811
msgid "Module :mod:`marshal`"
msgstr ":mod:`marshal` モジュール"

#: ../../library/pickle.rst:812
msgid "High-performance serialization of built-in types."
msgstr "組み込み型の高性能な直列化。"

#: ../../library/pickle.rst:816
msgid ":mod:`cPickle` --- A faster :mod:`pickle`"
msgstr ":mod:`cPickle` --- より高速な :mod:`pickle`"

#: ../../library/pickle.rst:826
msgid ""
"The :mod:`cPickle` module supports serialization and de-serialization of "
"Python objects, providing an interface and functionality nearly identical to "
"the :mod:`pickle` module.  There are several differences, the most important "
"being performance and subclassability."
msgstr ""
":mod:`cPickle` モジュールは Python オブジェクトの直列化および非直列化をサポー"
"トし、 :mod:`pickle` モジュールとほとんど同じインタフェースと機能を提供しま"
"す。いくつか相違点がありますが、最も重要な違いはパフォーマンスとサブクラス化"
"が可能かどうかです。"

#: ../../library/pickle.rst:831
msgid ""
"First, :mod:`cPickle` can be up to 1000 times faster than :mod:`pickle` "
"because the former is implemented in C.  Second, in the :mod:`cPickle` "
"module the callables :func:`Pickler` and :func:`Unpickler` are functions, "
"not classes. This means that you cannot use them to derive custom pickling "
"and unpickling subclasses.  Most applications have no need for this "
"functionality and should benefit from the greatly improved performance of "
"the :mod:`cPickle` module."
msgstr ""
"第一に、 :mod:`cPickle` は C で実装されているため、 :mod:`pickle` よりも最大"
"で 1000 倍高速です。第二に、 :mod:`cPickle` モジュール内では、呼び出し可能オ"
"ブジェクト :func:`Pickler` および :func:`Unpickler` は関数で、クラスではあり"
"ません。つまり、pickle 化や unpickle 化を行うカスタムのサブクラスを派生するこ"
"とができないということです。多くのアプリケーションではこの機能は不要なの"
"で、 :mod:`cPickle` モジュールによる大きなパフォーマンス向上の恩恵を受けられ"
"るはずです。"

#: ../../library/pickle.rst:838
msgid ""
"The pickle data stream produced by :mod:`pickle` and :mod:`cPickle` are "
"identical, so it is possible to use :mod:`pickle` and :mod:`cPickle` "
"interchangeably with existing pickles. [#]_"
msgstr ""
":mod:`pickle` と :mod:`cPickle` で作られた pickle データ列は同じなので、既存"
"の pickle データに対して :mod:`pickle` と :mod:`cPickle` を互換に使用すること"
"ができます。 [#]_"

#: ../../library/pickle.rst:842
msgid ""
"There are additional minor differences in API between :mod:`cPickle` and :"
"mod:`pickle`, however for most applications, they are interchangeable.  More "
"documentation is provided in the :mod:`pickle` module documentation, which "
"includes a list of the documented differences."
msgstr ""
":mod:`cPickle` と :mod:`pickle` の API 間には他にも些細な相違がありますが、ほ"
"とんどのアプリケーションで互換性があります。より詳細なドキュメンテーション"
"は :mod:`pickle` のドキュメントにあり、そこでドキュメント化されている相違点に"
"ついて挙げています。"

#: ../../library/pickle.rst:848
msgid "Footnotes"
msgstr "脚注"

#: ../../library/pickle.rst:849
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr ":mod:`marshal` モジュールと間違えないように注意してください。"

#: ../../library/pickle.rst:851
msgid ""
"In the :mod:`pickle` module these callables are classes, which you could "
"subclass to customize the behavior.  However, in the :mod:`cPickle` module "
"these callables are factory functions and so cannot be subclassed.  One "
"common reason to subclass is to control what objects can actually be "
"unpickled.  See section :ref:`pickle-sub` for more details."
msgstr ""
":mod:`pickle` では、これらの呼び出し可能オブジェクトはクラスであり、サブクラ"
"ス化してその動作をカスタマイズすることができます。しかし、 :mod:`cPickle` モ"
"ジュールでは、これらの呼び出し可能オブジェクトはファクトリ関数であり、サブク"
"ラス化することができません。サブクラスを作成する共通の理由の一つは、どのオブ"
"ジェクトを実際に unpickle するかを制御することです。詳細については :ref:"
"`pickle-sub` を参照してください。"

#: ../../library/pickle.rst:857
msgid ""
"*Warning*: this is intended for pickling multiple objects without "
"intervening modifications to the objects or their parts.  If you modify an "
"object and then pickle it again using the same :class:`Pickler` instance, "
"the object is not pickled again --- a reference to it is pickled and the :"
"class:`Unpickler` will return the old value, not the modified one. There are "
"two problems here: (1) detecting changes, and (2) marshalling a minimal set "
"of changes.  Garbage Collection may also become a problem here."
msgstr ""
"*警告*: これは、複数のオブジェクトを pickle 化する際に、オブジェクトやそれら"
"の一部に対する変更を妨げないようにするための仕様です。あるオブジェクトに変更"
"を加えて、その後同じ :class:`Pickler` を使って再度 pickle 化しようとしても、"
"そのオブジェクトは pickle 化しなおされません --- そのオブジェクトに対する参照"
"が pickle 化され、 :class:`Unpickler` は変更された値ではなく、元の値を返しま"
"す。これには 2 つの問題点 : (1) 変更の検出、そして (2) 最小限の変更を整列化す"
"ること、があります。ガーベジコレクションもまた問題になります。"

#: ../../library/pickle.rst:865
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an :exc:"
"`AttributeError` but it could be something else."
msgstr ""
"送出される例外は :exc:`ImportError` や :exc:`AttributeError` になるはずです"
"が、他の例外も起こりえます。"

#: ../../library/pickle.rst:868
msgid "These methods can also be used to implement copying class instances."
msgstr ""
"これらのメソッドはクラスインスタンスのコピーを実装する際にも用いられます。"

#: ../../library/pickle.rst:870
msgid ""
"This protocol is also used by the shallow and deep copying operations "
"defined in the :mod:`copy` module."
msgstr ""
"このプロトコルはまた、 :mod:`copy` で定義されている浅いコピーや深いコピー操作"
"でも用いられます。"

#: ../../library/pickle.rst:873
msgid ""
"The actual mechanism for associating these user defined functions is "
"slightly different for :mod:`pickle` and :mod:`cPickle`.  The description "
"given here works the same for both implementations.  Users of the :mod:"
"`pickle` module could also use subclassing to effect the same results, "
"overriding the :meth:`persistent_id` and :meth:`persistent_load` methods in "
"the derived classes."
msgstr ""
"ユーザ定義関数に関連付けを行うための実際のメカニズムは、 :mod:`pickle` およ"
"び :mod:`cPickle` では少し異なります。 :mod:`pickle` のユーザは、サブクラス化"
"を行い、 :meth:`persistend_id` および :meth:`persistent_load` メソッドを上書"
"きすることで同じ効果を得ることができます。"

#: ../../library/pickle.rst:880
msgid ""
"We'll leave you with the image of Guido and Jim sitting around sniffing "
"pickles in their living rooms."
msgstr ""
"Guide と Jim が居間に座り込んでピクルス (pickles) を嗅いでいる光景を想像して"
"ください。"

#: ../../library/pickle.rst:883
msgid ""
"A word of caution: the mechanisms described here use internal attributes and "
"methods, which are subject to change in future versions of Python.  We "
"intend to someday provide a common interface for controlling this behavior, "
"which will work in either :mod:`pickle` or :mod:`cPickle`."
msgstr ""
"注意してください: ここで記述されている機構は内部の属性とメソッドを使ってお"
"り、これらはPython の将来のバージョンで変更される対象になっています。われわれ"
"は将来、この挙動を制御するための、 :mod:`pickle` および :mod:`cPickle` の両方"
"で動作する、共通のインタフェースを提供するつもりです。"

#: ../../library/pickle.rst:888
msgid ""
"Since the pickle data format is actually a tiny stack-oriented programming "
"language, and some freedom is taken in the encodings of certain objects, it "
"is possible that the two modules produce different data streams for the same "
"input objects.  However it is guaranteed that they will always be able to "
"read each other's data streams."
msgstr ""
"pickle データ形式は実際には小規模なスタック指向のプログラム言語であり、またあ"
"るオブジェクトをエンコードする際に多少の自由度があるため、二つのモジュールが"
"同じ入力オブジェクトに対して異なるデータ列を生成することもあります。しかし、"
"常に互いに他のデータ列を読み出せることが保証されています。"
