# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-10 13:34+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Shun Sakurai, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ":mod:`pickle` --- Python オブジェクトの直列化"

#: ../../library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**ソースコード:** :source:`Lib/pickle.py`"

#: ../../library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and "
"*\"unpickling\"* is the inverse operation, whereby a byte stream (from a "
":term:`binary file` or :term:`bytes-like object`) is converted back into an "
"object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
":mod:`pickle` モジュールは Python "
"オブジェクトの直列化および直列化されたオブジェクトの復元のためのバイナリプロトコルを実装しています。*\"Pickle 化\"* は Python "
"オブジェクト階層をバイトストリームに変換する処理、*\"非 pickle 化\"* は (:term:`バイナリファイル <binary file>` "
"または :term:`バイトライクオブジェクト <bytes-like object>` から) "
"バイトストリームをオブジェクト階層に復元する処理を意味します。pickle 化 (および非 pickle 化) は \"直列化 "
"(serialization)\"、\"整列化 (marshalling)\"、あるいは [#]_ \"平坦化 (flattening)\" "
"とも呼ばれますが、混乱を避けるため、ここでは \"Pickle 化\"、\"非 pickle 化\" で統一します。"

#: ../../library/pickle.rst:33
msgid ""
"The :mod:`pickle` module is not secure against erroneous or maliciously "
"constructed data.  Never unpickle data received from an untrusted or "
"unauthenticated source."
msgstr ""
":mod:`pickle` "
"モジュールはエラーや不正に生成されたデータに対して安全ではありません。信頼できない、あるいは認証されていないソースから受け取ったデータを非 pickle"
" 化してはいけません。"

#: ../../library/pickle.rst:39
msgid "Relationship to other Python modules"
msgstr "他の Python モジュールとの関係"

#: ../../library/pickle.rst:42
msgid "Comparison with ``marshal``"
msgstr "``marshal`` との比較"

#: ../../library/pickle.rst:44
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's "
":file:`.pyc` files."
msgstr ""
"Python には :mod:`marshal` と呼ばれるより原始的な直列化モジュールがありますが、一般的に Python "
"オブジェクトを直列化する方法としては :mod:`pickle` を選ぶべきです。 :mod:`marshal` は基本的に :file:`.pyc` "
"ファイルをサポートするために存在しています。"

#: ../../library/pickle.rst:49
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ":mod:`pickle` モジュールはいくつかの点で :mod:`marshal` と明確に異なります:"

#: ../../library/pickle.rst:51
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""
":mod:`pickle` "
"モジュールでは、同じオブジェクトが再度直列化されることのないよう、すでに直列化されたオブジェクトについて追跡情報を保持します。 "
":mod:`marshal` はこれを行いません。"

#: ../../library/pickle.rst:55
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"この機能は再帰的オブジェクトと共有オブジェクトの両方に重要な関わりをもっています。再帰的オブジェクトとは自分自身に対する参照を持っているオブジェクトです。再帰的オブジェクトは"
" marshal で扱うことができず、実際、再帰的オブジェクトを marshal 化しようとすると Python "
"インタプリタをクラッシュさせてしまいます。共有オブジェクトは、直列化しようとするオブジェクト階層の異なる複数の場所で同じオブジェクトに対する参照が存在する場合に生じます。共有オブジェクトを共有のままにしておくことは、変更可能なオブジェクトの場合には非常に重要です。"

#: ../../library/pickle.rst:64
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` はユーザ定義クラスやそのインスタンスを直列化するために使うことができません。 :mod:`pickle` "
"はクラスインスタンスを透過的に保存したり復元したりすることができますが、クラス定義をインポートすることが可能で、かつオブジェクトが保存された際と同じモジュールで定義されていなければなりません。"

#: ../../library/pickle.rst:69
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support "
":file:`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise."
" The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases."
msgstr ""
":mod:`marshal` の直列化フォーマットは Python の異なるバージョンで可搬性があることを保証していません。 "
":mod:`marshal` の本来の仕事は :file:`.pyc` ファイルのサポートなので、Python "
"を実装する人々には、必要に応じて直列化フォーマットを以前のバージョンと互換性のないものに変更する権限が残されています。 :mod:`pickle` "
"直列化フォーマットには、全ての Python リリース間で以前のバージョンとの互換性が保証されています。"

#: ../../library/pickle.rst:77
msgid "Comparison with ``json``"
msgstr "``json`` との比較"

#: ../../library/pickle.rst:79
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <http://json.org>`_:"
msgstr ""
"pickle プロトコルと `JSON (JavaScript Object Notation) <http://json.org>`_ "
"との基本的な違いは以下のとおりです:"

#: ../../library/pickle.rst:82
msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""
"JSON はテキストの直列化フォーマット (大抵の場合 ``utf-8`` にエンコードされますが、その出力は Unicode 文字列です) "
"で、pickle はバイナリの直列化フォーマットです;"

#: ../../library/pickle.rst:86
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON は人間が読める形式ですが、pickle はそうではありません;"

#: ../../library/pickle.rst:88
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while"
" pickle is Python-specific;"
msgstr "JSON は相互運用可能で Python 以外でも広く使用されていますが、pickle は Python 固有です;"

#: ../../library/pickle.rst:91
msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by implementing "
":ref:`specific object APIs <pickle-inst>`)."
msgstr ""
"JSON は、デフォルトでは Python の組み込み型の一部しか表現することができず、カスタムクラスに対しても行えません; pickle "
"は極めて多くの Python 組み込み型を表現できます (その多くは賢い Python 内省機構によって自動的に行われます; 複雑なケースでは "
":ref:`固有のオブジェクト API <pickle-inst>` によって対応できます)。"

#: ../../library/pickle.rst:98
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ":mod:`json` モジュール: JSON への直列化および復元を行うための標準ライブラリモジュール。"

#: ../../library/pickle.rst:105
msgid "Data stream format"
msgstr "データストリームの形式"

#: ../../library/pickle.rst:110
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON or XDR (which can't represent pointer sharing); however it means "
"that non-Python programs may not be able to reconstruct pickled Python "
"objects."
msgstr ""
":mod:`pickle` によって使用されるデータフォーマットは Python 固有です。これは、JSON や XDR のような外部標準によって "
"(例えばポインター共有を表わすことができないといったような) 制限を受けることがないという利点があります; ただし、これは非 Python プログラムが"
" pickle された Python オブジェクトを再構成することができないということも意味します。"

#: ../../library/pickle.rst:115
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"デフォルトでは、:mod:`pickle` "
"データフォーマットは比較的コンパクトなバイナリ表現を使用します。サイズの抑制目的の最適化が必要なら、pickel されたデータを効率的に "
":doc:`圧縮する <archiving>` ことができます。"

#: ../../library/pickle.rst:119
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""
":mod:`pickletools` モジュールには :mod:`pickle` "
"によって生成されたデータストリームを解析するためのツールが含まれます。:mod:`pickletools` のソースコードには、pickle "
"プロトコルで使用される命令コードに関する詳細なコメントがあります。"

#: ../../library/pickle.rst:123
msgid ""
"There are currently 5 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr ""
"現在 pickle 化には 5 種類のプロトコルを使用できます。より高いプロトコルを使用するほど、作成された pickle を読み込むためにより高い "
"Python のバージョンが必要になります。"

#: ../../library/pickle.rst:127
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr "プロトコルバージョン 0 はオリジナルの「人間に判読可能な」プロトコルで、Python の初期のバージョンとの後方互換性を持ちます。"

#: ../../library/pickle.rst:130
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr "プロトコルバージョン 1 は旧形式のバイナリフォーマットで、これも Python の初期バージョンと互換性があります。"

#: ../../library/pickle.rst:133
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style class`\\es.  Refer to :pep:`307` for "
"information about improvements brought by protocol 2."
msgstr ""
"プロトコルバージョン 2 は Python 2.3 で導入されました。このバージョンでは :term:`新方式のクラス <new-style "
"class>` のより効率的な pickle 化を提供しました。プロトコル 2 による改良に関する情報は :pep:`307` を参照してください。"

#: ../../library/pickle.rst:137
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for "
":class:`bytes` objects and cannot be unpickled by Python 2.x.  This is the "
"default protocol, and the recommended protocol when compatibility with other"
" Python 3 versions is required."
msgstr ""
"プロトコルバージョン 3 は Python 3.0 で追加されました。このバージョンで :class:`bytes` "
"オブジェクトをサポートしました。これは Python 2.x では非 pickle 化できません。これはデフォルトのプロトコルで、他の Python 3"
" バージョンとの互換性が求められる場合の推奨プロトコルです。"

#: ../../library/pickle.rst:142
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format optimizations."
"  Refer to :pep:`3154` for information about improvements brought by "
"protocol 4."
msgstr ""
"プロトコルバージョン 4 は Python 3.4 で追加されました。このバージョンでは巨大なオブジェクトのサポート、より多くの種類のオブジェクトの "
"pickle 化、および一部のデータ形式の最適化が行われました。プロトコル 4 による改良に関する情報は :pep:`3154` を参照してください。"

#: ../../library/pickle.rst:148
msgid ""
"Serialization is a more primitive notion than persistence; although "
":mod:`pickle` reads and writes file objects, it does not handle the issue of"
" naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"直列化は永続性より原始的な概念です。 :mod:`pickle` "
"はファイルオブジェクトの読み書きを行いますが、永続オブジェクトの命名に関する問題にも、(さらに困難な) "
"永続オブジェクトへの並列アクセスに関する問題にも対応しません。:mod:`pickle` "
"モジュールは複雑なオブジェクトをバイトストリームに変換し、バイトストリームから同じ内部構造のオブジェクトに復元することができます。これらのバイトストリームはファイルに出力されることが多いでしょうが、ネットワークを介して送信したり、データベースに格納することもありえます。:mod:`shelve`"
" モジュールは、オブジェクトを DBM 方式のデータベースファイル上で pickle 化および非 pickle "
"化するシンプルなインターフェイスを提供します。"

#: ../../library/pickle.rst:161
msgid "Module Interface"
msgstr "モジュールインタフェース"

#: ../../library/pickle.rst:163
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the "
":func:`loads` function. However, if you want more control over serialization"
" and de-serialization, you can create a :class:`Pickler` or an "
":class:`Unpickler` object, respectively."
msgstr ""
"オブジェクト階層を直列化するには、:func:`dumps` 関数を呼ぶだけです。同様に、データストリームを復元するには、:func:`loads` "
"関数を呼びます。しかし、直列化および復元に対してより多くのコントロールを行いたい場合、それぞれ :class:`Pickler` または "
":class:`Unpickler` オブジェクトを作成することができます。"

#: ../../library/pickle.rst:168
msgid "The :mod:`pickle` module provides the following constants:"
msgstr ":mod:`pickle` モジュールは以下の定数を提供しています:"

#: ../../library/pickle.rst:173
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions "
":func:`dump` and :func:`dumps` as well as the :class:`Pickler` constructor."
msgstr ""
"利用可能なうち最も高い :ref:`プロトコルバージョン <pickle-protocols>` (整数)。この値は *protocol* 値として関数"
" :func:`dump`  および :func:`dumps` と、:class:`Pickler` コンストラクターに渡すことができます。"

#: ../../library/pickle.rst:180
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default"
" protocol is 3, a new protocol designed for Python 3."
msgstr ""
"pickle 化で使用されるデフォルトの :ref:`プロトコルバージョン <pickle-protocols>` "
"(整数)。:data:`HIGHEST_PROTOCOL` より低い値になる場合があります。現在のデフォルトプロトコルは Python 3 "
"用に設計された 3 です。"

#: ../../library/pickle.rst:185
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr "この pickle 化の手続きを便利にするために、 :mod:`pickle` モジュールでは以下の関数を提供しています:"

#: ../../library/pickle.rst:190
msgid ""
"Write a pickled representation of *obj* to the open :term:`file object` "
"*file*. This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""
"*obj* を pickle 化し、すでにオープンしている :term:`ファイルオブジェクト <file object>` *file* "
"に書き込みます。``Pickler(file, protocol).dump(obj)`` と等価です。"

#: ../../library/pickle.rst:193 ../../library/pickle.rst:289
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"任意の引数 *protocol* は、整数で、pickle 化で使用するプロトコルを指定します; サポートされているプロトコルは 0 から "
":data:`HIGHEST_PROTOCOL` までになります。指定されない場合、:data:`DEFAULT_PROTOCOL` "
"が使用されます。負数が与えられた場合、:data:`HIGHEST_PROTOCOL` が使用されます。"

#: ../../library/pickle.rst:198 ../../library/pickle.rst:294
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, an "
":class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""
"引数 *file* は、1 バイトの引数一つを受け付ける write() メソッドを持たなければなりません。すなわち、*file* "
"には、バイナリの書き込み用にオープンされたファイルオブジェクト、:class:`io.BytesIO` "
"オブジェクト、このインタフェースに適合するその他のカスタムオブジェクトをとることができます。"

#: ../../library/pickle.rst:203 ../../library/pickle.rst:299
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that"
" the pickle data stream is readable with Python 2."
msgstr ""
"*fix_imports* が真であり、かつ、*protocol* が 3 未満の場合、pickle は新しい Python 3 の名前と Python"
" 2 で使用されていた古いモジュール名との対応付けを試みるので、pickle データストリームは Python 2 でも読み込み可能です。"

#: ../../library/pickle.rst:209
msgid ""
"Return the pickled representation of the object as a :class:`bytes` object, "
"instead of writing it to a file."
msgstr "ファイルに書く代わりに、:class:`bytes` オブジェクトとしてオブジェクトの pickle 表現を返します。"

#: ../../library/pickle.rst:212
msgid ""
"Arguments *protocol* and *fix_imports* have the same meaning as in "
":func:`dump`."
msgstr "引数 *protocol* および *fix_imports* は :func:`dump` では同じ意味になります。"

#: ../../library/pickle.rst:217
msgid ""
"Read a pickled object representation from the open :term:`file object` "
"*file* and return the reconstituted object hierarchy specified therein. This"
" is equivalent to ``Unpickler(file).load()``."
msgstr ""
"pickle オブジェクト表現を、オープンしている :term:`ファイルオブジェクト <file object>` *file* "
"から読み込み、その中で指定されているオブジェクト階層に再構成して返します。これは ``Unpickler(file).load()`` と等価です。"

#: ../../library/pickle.rst:221 ../../library/pickle.rst:244
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol"
" argument is needed.  Bytes past the pickled object's representation are "
"ignored."
msgstr ""
"pickle のプロトコルバージョンは自動的に検出されます。したがって protocol 引数は必要ありません。pickle "
"化オブジェクト表現より後のバイト列は無視されます。"

#: ../../library/pickle.rst:225
msgid ""
"The argument *file* must have two methods, a read() method that takes an "
"integer argument, and a readline() method that requires no arguments.  Both "
"methods should return bytes.  Thus *file* can be an on-disk file opened for "
"binary reading, an :class:`io.BytesIO` object, or any other custom object "
"that meets this interface."
msgstr ""
"引数 *file* には 2 つのメソッド、整数引数をとる read() と、引数を要求しない readline() "
"メソッドがなければなりません。両方のメソッドはバイト列を返す必要があります。そのため *file* "
"には、バイナリ読み込みとしてオープンされたディスク上のファイル、:class:`io.BytesIO` "
"オブジェクト、あるいはこのインタフェースに適合するその他のカスタムオブジェクトなどを指定できます。"

#: ../../library/pickle.rst:231 ../../library/pickle.rst:248
#: ../../library/pickle.rst:367
msgid ""
"Optional keyword arguments are *fix_imports*, *encoding* and *errors*, which"
" are used to control compatibility support for pickle stream generated by "
"Python 2.  If *fix_imports* is true, pickle will try to map the old Python 2"
" names to the new names used in Python 3.  The *encoding* and *errors* tell "
"pickle how to decode 8-bit string instances pickled by Python 2; these "
"default to 'ASCII' and 'strict', respectively.  The *encoding* can be "
"'bytes' to read these 8-bit string instances as bytes objects."
msgstr ""
"任意のキーワード引数 *fix_imports*、*encoding* および *errors* は Python 2 で作成された pickle "
"ストリームとの互換性を制御するために使用します。*fix_imports* が真の場合、pickle は古い Python 2 の名前と Python "
"3 で使用されている新しい名前との対応付けを試みます。*encoding* と *errors* は Python 2 で pickle 化された 8 "
"ビット文字列インスタンスのデコード方法を指定します; デフォルトではそれぞれ 'ASCII' および 'strict' になります。8 "
"ビット文字列インスタンスをバイト列オブジェクトとして読み込みたい場合には、*encoding* に 'bytes' を指定します。"

#: ../../library/pickle.rst:241
msgid ""
"Read a pickled object hierarchy from a :class:`bytes` object and return the "
"reconstituted object hierarchy specified therein."
msgstr ""
":class:`bytes` オブジェクトから pickle "
"化されたオブジェクト階層を読み込んで、その中で指定されたオブジェクト階層に再構成して返します。"

#: ../../library/pickle.rst:257
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr ":mod:`pickle` モジュールでは 3 つの例外を定義しています:"

#: ../../library/pickle.rst:261
msgid ""
"Common base class for the other pickling exceptions.  It inherits "
":exc:`Exception`."
msgstr "他の pickle 化例外の共通基底クラス。:exc:`Exception` を継承しています。"

#: ../../library/pickle.rst:266
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits :exc:`PickleError`."
msgstr ""
":class:`Pickler` が pickle 化不可能なオブジェクトに遭遇したときに送出されるエラー。:exc:`PickleError` "
"を継承しています。"

#: ../../library/pickle.rst:269
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr "どんな種類のオブジェクトが pickle 化できるのか確認するには :ref:`pickle-picklable` を参照してください。"

#: ../../library/pickle.rst:274
msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits :exc:`PickleError`."
msgstr ""
"データ破損やセキュリティ違反のような、オブジェクトを非 pickle 化するのに問題がある場合に送出されるエラー。:exc:`PickleError` "
"を継承します。"

#: ../../library/pickle.rst:277
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""
"非 picke 化の最中に他の例外が送出されることもあるので注意してください。これには AttributeError, EOFError, "
"ImportError, IndexError が含まれます (ただし必ずしもこれらに限定されません)。"

#: ../../library/pickle.rst:282
msgid ""
"The :mod:`pickle` module exports two classes, :class:`Pickler` and "
":class:`Unpickler`:"
msgstr ""
":mod:`pickle` モジュールでは、2 つのクラス :class:`Pickler` および :class:`Unpickler` "
"を提供しています:"

#: ../../library/pickle.rst:287
msgid "This takes a binary file for writing a pickle data stream."
msgstr "pickle 化されたオブジェクトのデータストリームを書き込むためのバイナリファイルを引数にとります。"

#: ../../library/pickle.rst:305
msgid ""
"Write a pickled representation of *obj* to the open file object given in the"
" constructor."
msgstr "*obj* の pickle 化表現を、コンストラクターで与えられた、すでにオープンしているファイルオブジェクトに書き込みます。"

#: ../../library/pickle.rst:310
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr "デフォルトでは何もしません。このメソッドはサブクラスがオーバーライドできるように存在します。"

#: ../../library/pickle.rst:312
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
":meth:`persistent_id` が ``None`` を返す場合、通常通り *obj* が pickle "
"化されます。それ以外の値を返した場合、:class:`Pickler` がその値を *obj* のために永続的な ID "
"として出力するようになります。この永続的な ID の意味は :meth:`Unpickler.persistent_load` "
"によって定義されています。:meth:`persistent_id` によって返された値自身は永続的な ID "
"を持つことができないことに注意してください。"

#: ../../library/pickle.rst:318 ../../library/pickle.rst:389
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr "詳細および使用例については :ref:`pickle-persistent` を参照してください。"

#: ../../library/pickle.rst:322
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`__reduce__` method."
msgstr ""
"pickler オブジェクトのディスパッチテーブルは :func:`copyreg.pickle` を使用して宣言できる種類の *reduction "
"functions* のレジストリです。これはキーがクラスでその値が減少関数のマッピング型オブジェクトです。減少関数は関連するクラスの引数を 1 "
"個とり、:meth:`__reduce__` メソッドと同じインタフェースでなければなりません。"

#: ../../library/pickle.rst:330
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by the "
":mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has a "
":attr:`dispatch_table` attribute then this will be used as the default "
"dispatch table for instances of that class."
msgstr ""
"デフォルトでは、pickler オブジェクトは :attr:`dispatch_table` 属性を持たず、代わりに :mod:`copyreg` "
"モジュールによって管理されるグローバルなディスパッチテーブルを使用します。しかし、特定の pickler オブジェクトによる pickle "
"化をカスタマイズするために :attr:`dispatch_table` 属性に dict-like "
"オブジェクトを設定することができます。あるいは、:class:`Pickler` のサブクラスが :attr:`dispatch_table` "
"属性を持てば、そのクラスのインスタンスに対するデフォルトのディスパッチテーブルとして使用されます。"

#: ../../library/pickle.rst:339
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "使用例については :ref:`pickle-dispatch` を参照してください。"

#: ../../library/pickle.rst:345
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables"
" the usage of memo, therefore speeding the pickling process by not "
"generating superfluous PUT opcodes.  It should not be used with self-"
"referential objects, doing otherwise will cause :class:`Pickler` to recurse "
"infinitely."
msgstr ""
"廃止予定です。真値が設定されれば高速モードを有効にします。高速モードは、メモの使用を無効にします。それにより余分な PUT "
"命令コードを生成しなくなるので pickle 化処理が高速化します。自己参照オブジェクトに対しては使用すべきではありません。さもなければ "
":class:`Pickler` に無限再帰を起こさせるでしょう。"

#: ../../library/pickle.rst:351
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr "よりコンパクトな pickle 化を必要とする場合は、:func:`pickletools.optimize` を使用してください。"

#: ../../library/pickle.rst:356
msgid "This takes a binary file for reading a pickle data stream."
msgstr "これは pickle データストリームの読み込みのためにバイナリファイルをとります。"

#: ../../library/pickle.rst:358
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol"
" argument is needed."
msgstr "pickle のプロトコルバージョンは自動的に検出されます。したがって protocol 引数は必要ありません。"

#: ../../library/pickle.rst:361
msgid ""
"The argument *file* must have two methods, a read() method that takes an "
"integer argument, and a readline() method that requires no arguments.  Both "
"methods should return bytes.  Thus *file* can be an on-disk file object "
"opened for binary reading, an :class:`io.BytesIO` object, or any other "
"custom object that meets this interface."
msgstr ""
"引数 *file* には2つのメソッド、整数引数をとる read() メソッドと、引数を要求しない readline() "
"引数がなければなりません。両方のメソッドはバイトを返す必要があります。そのため *file* "
"には、バイナリ読み込みのために開かれたディスク上のファイルオブジェクト、 :class:`io.BytesIO` "
"オブジェクト、あるいはこのインタフェースに適合するその他のカスタムオブジェクトなどを指定することが可能です。"

#: ../../library/pickle.rst:377
msgid ""
"Read a pickled object representation from the open file object given in the "
"constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled object's representation are ignored."
msgstr ""
"コンストラクターで与えられたオープンしたファイルオブジェクトから pickle "
"化オブジェクト表現を読み込み、その中で指定されたオブジェクト階層に再構成して返します。pickle 化オブジェクト表現より後のバイト列は無視されます。"

#: ../../library/pickle.rst:383
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "デフォルトで :exc:`UnpicklingError` を送出します。"

#: ../../library/pickle.rst:385
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an "
":exc:`UnpicklingError` should be raised."
msgstr ""
"もし定義されていれば、:meth:`persistent_load` は永続的な ID *pid* "
"によって指定されたオブジェクトを返す必要があります。永続的な ID が無効な場合、:exc:`UnpicklingError` "
"を送出しなければなりません。"

#: ../../library/pickle.rst:393
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"必要なら *module* をインポートして、そこから *name* という名前のオブジェクトを返します。ここで *module* および *name*"
" 引数は :class:`str` オブジェクトです。その名前が示唆することに反して :meth:`find_class` "
"は関数を探すためにも使われることに注意してください。"

#: ../../library/pickle.rst:398
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to :ref"
":`pickle-restrict` for details."
msgstr ""
"サブクラスは、どんな型のオブジェクトを、どのようにロードするか (潜在的にはセキュリティリスクの減少) "
"に関する制御を得るためにこれをオーバーライドすることができます。詳細に関しては :ref:`pickle-restrict` を参照してください。"

#: ../../library/pickle.rst:406
msgid "What can be pickled and unpickled?"
msgstr "pickle 化、非 pickle 化できるもの"

#: ../../library/pickle.rst:408
msgid "The following types can be pickled:"
msgstr "以下の型は pickle 化できます:"

#: ../../library/pickle.rst:410
msgid "``None``, ``True``, and ``False``"
msgstr "``None`` 、 ``True`` 、および ``False``"

#: ../../library/pickle.rst:412
msgid "integers, floating point numbers, complex numbers"
msgstr "整数、浮動小数点数、複素数"

#: ../../library/pickle.rst:414
msgid "strings, bytes, bytearrays"
msgstr "文字列、バイト列、バイト配列"

#: ../../library/pickle.rst:416
msgid ""
"tuples, lists, sets, and dictionaries containing only picklable objects"
msgstr "pickle 化可能なオブジェクトからなるタプル、リスト、集合および辞書"

#: ../../library/pickle.rst:418
msgid ""
"functions defined at the top level of a module (using :keyword:`def`, not "
":keyword:`lambda`)"
msgstr ""
"モジュールのトップレベルで定義された関数 (:keyword:`def` で定義されたもののみで :keyword:`lambda` "
"で定義されたものは含まない)"

#: ../../library/pickle.rst:421
msgid "built-in functions defined at the top level of a module"
msgstr "モジュールのトップレベルで定義されている組込み関数"

#: ../../library/pickle.rst:423
msgid "classes that are defined at the top level of a module"
msgstr "モジュールのトップレベルで定義されているクラス"

#: ../../library/pickle.rst:425
msgid ""
"instances of such classes whose :attr:`~object.__dict__` or the result of "
"calling :meth:`__getstate__` is picklable  (see section :ref:`pickle-inst` "
"for details)."
msgstr ""
":attr:`~object.__dict__` 属性を持つクラス、あるいは :meth:`__getstate__` メソッドの返り値が pickle"
" 化可能なクラス (詳細は :ref:`pickle-inst` を参照)。"

#: ../../library/pickle.rst:429
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a "
":exc:`RecursionError` will be raised in this case.  You can carefully raise "
"this limit with :func:`sys.setrecursionlimit`."
msgstr ""
"pickle 化できないオブジェクトを pickle 化しようとすると、:exc:`PicklingError` "
"例外が送出されます。この例外が起きたとき、すでに元のファイルには未知の長さのバイト列が書き込まれている場合があります。極端に再帰的なデータ構造を "
"pickle 化しようとした場合には再帰の深さ制限を越えてしまうかもしれず、この場合には :exc:`RecursionError` "
"が送出されます。この制限は、:func:`sys.setrecursionlimit` で慎重に上げていくことは可能です。"

#: ../../library/pickle.rst:436
msgid ""
"Note that functions (built-in and user-defined) are pickled by \"fully "
"qualified\" name reference, not by value. [#]_  This means that only the "
"function name is pickled, along with the name of the module the function is "
"defined in.  Neither the function's code, nor any of its function attributes"
" are pickled.  Thus the defining module must be importable in the unpickling"
" environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""
"関数 (組込みおよびユーザー定義) は、値ではなく、\"完全修飾\" された名前参照で pickle 化されます。[#]_  "
"これは関数が定義されたモジュールをともにした関数名のみが pickle 化されることを意味します。関数のコードやその属性は pickle "
"化されません。すなわち、非 pickle "
"化する環境で定義したモジュールがインポート可能な状態になっており、そのモジュール内に関数名のオブジェクトが含まれていなければなりません。この条件を満たさなかった場合は例外が送出されます。[#]_"

#: ../../library/pickle.rst:443
msgid ""
"Similarly, classes are pickled by named reference, so the same restrictions "
"in the unpickling environment apply.  Note that none of the class's code or "
"data is pickled, so in the following example the class attribute ``attr`` is"
" not restored in the unpickling environment::"
msgstr ""
"クラスも同様に名前参照で pickle 化されるので、unpickle 化環境には同じ制限が課せられます。クラス中のコードやデータは何も pickle "
"化されないので、以下の例ではクラス属性 ``attr`` が unpickle 化環境で復元されないことに注意してください ::"

#: ../../library/pickle.rst:453
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"in the top level of a module."
msgstr "pickle 化可能な関数やクラスがモジュールのトップレベルで定義されていなければならないのはこれらの制限のためです。"

#: ../../library/pickle.rst:456
msgid ""
"Similarly, when class instances are pickled, their class's code and data are"
" not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`__setstate__` "
"method."
msgstr ""
"同様に、クラスのインスタンスが pickle 化された際、そのクラスのコードおよびデータはオブジェクトと一緒に pickle "
"化されることはありません。インスタンスのデータのみが pickle "
"化されます。この仕様は、クラス内のバグを修正したりメソッドを追加した後でも、そのクラスの以前のバージョンで作られたオブジェクトを読み出せるように意図的に行われています。あるクラスの多くのバージョンで使われるような長命なオブジェクトを作ろうと計画しているなら、そのクラスの"
" :meth:`__setstate__` メソッドによって適切な変換が行われるようにオブジェクトのバージョン番号を入れておくとよいかもしれません。"

#: ../../library/pickle.rst:468
msgid "Pickling Class Instances"
msgstr "クラスインスタンスの pickle 化"

#: ../../library/pickle.rst:472
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and "
"unpickled."
msgstr ""
"この節では、クラスインスタンスがどのように pickle 化または非 pickle "
"化されるのかを定義したり、カスタマイズしたり、コントロールしたりするのに利用可能な一般的機構について説明します。"

#: ../../library/pickle.rst:475
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By"
" default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its :meth:`__init__` "
"method is usually *not* invoked.  The default behaviour first creates an "
"uninitialized instance and then restores the saved attributes.  The "
"following code shows an implementation of this behaviour::"
msgstr ""
"ほとんどの場合、インスタンスを pickle 化できるようにするために追加のコードは必要ありません。デフォルトで、pickle "
"はインスタンスのクラスと属性を内省によって検索します。クラスインスタンスが非 pickle 化される場合、通常その :meth:`__init__` "
"メソッドは実行 *されません* "
"。デフォルトの振る舞いは、最初に初期化されていないインスタンスを作成して、次に保存された属性を復元します。次のコードはこの振る舞いの実装を示しています::"

#: ../../library/pickle.rst:490
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr "クラスは、いくつかの特殊メソッドを提供することによって、デフォルトの振る舞いを変更することができます:"

#: ../../library/pickle.rst:495
msgid ""
"In protocols 2 and newer, classes that implements the "
":meth:`__getnewargs_ex__` method can dictate the values passed to the "
":meth:`__new__` method upon unpickling.  The method must return a pair "
"``(args, kwargs)`` where *args* is a tuple of positional arguments and "
"*kwargs* a dictionary of named arguments for constructing the object.  Those"
" will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""

#: ../../library/pickle.rst:503
msgid ""
"You should implement this method if the :meth:`__new__` method of your class"
" requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"クラスの :meth:`__new__` メソッドにキーワード引数のみ定義されている場合はこのメソッドを実装すべきです。そうしない場合、互換性のため "
":meth:`__getnewargs__` メソッドの実装を推奨します。"

#: ../../library/pickle.rst:507
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ""

#: ../../library/pickle.rst:513
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""

#: ../../library/pickle.rst:517
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr ""

#: ../../library/pickle.rst:520
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of "
":meth:`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""

#: ../../library/pickle.rst:527
msgid ""
"Classes can further influence how their instances are pickled; if the class "
"defines the method :meth:`__getstate__`, it is called and the returned "
"object is pickled as the contents for the instance, instead of the contents "
"of the instance's dictionary.  If the :meth:`__getstate__` method is absent,"
" the instance's :attr:`~object.__dict__` is pickled as usual."
msgstr ""
"クラスはそのインスタンスをどう pickle 化するかについてさらに影響を与えることができます; クラスに :meth:`__getstate__` "
"メソッドが定義されていた場合それが呼ばれ、返り値のオブジェクトはインスタンスの辞書ではなく、インスタンスの内容が pickle "
"化されたものになります。:meth:`__getstate__` がないときは通常通りインスタンスの :attr:`~object.__dict__` "
"が pickle 化されます。"

#: ../../library/pickle.rst:536
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"非 pickle 化に際して、クラスが :meth:`__setstate__` を定義している場合、それは非 pickle "
"化された状態とともに呼び出されます。その場合、状態オブジェクトが辞書でなければならないという要求はありません。そうでなければ、 pickle "
"された状態は辞書で、その要素は新しいインスタンスの辞書に割り当てられます。"

#: ../../library/pickle.rst:543
msgid ""
"If :meth:`__getstate__` returns a false value, the :meth:`__setstate__` "
"method will not be called upon unpickling."
msgstr ""
":meth:`__getstate__` が偽値を返す場合、非 pickle 化時に :meth:`__setstate__` メソッドは呼ばれません。"

#: ../../library/pickle.rst:547
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`__getstate__` and :meth:`__setstate__`."
msgstr ""
":meth:`__getstate__` および :meth:`__setstate__` メソッドの使い方に関する詳細な情報については :ref"
":`pickle-state` 節を参照してください。"

#: ../../library/pickle.rst:552
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, "
":meth:`__getattribute__`, or :meth:`__setattr__` may be called upon the "
"instance.  In case those methods rely on some internal invariant being true,"
" the type should implement :meth:`__getnewargs__` or "
":meth:`__getnewargs_ex__` to establish such an invariant; otherwise, neither"
" :meth:`__new__` nor :meth:`__init__` will be called."
msgstr ""
"非 pickle 化時、:meth:`__getattr__`、:meth:`__getattribute__` あるいは "
":meth:`__setattr__` "
"のような一部のメソッドがインスタンス上で呼び出されることがあります。この場合、これらのメソッドはいくつかの内部不変条件が真であることに依存しており、そのような不変条件を立証するために、データ型には"
" :meth:`__getnewargs__` または :meth:`__getnewargs_ex__` が実装されていなければなりません; "
"さもなくば、:meth:`__new__` も :meth:`__init__` も呼び出されません。"

#: ../../library/pickle.rst:561
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the "
":meth:`__reduce__` special method.  The copy protocol provides a unified "
"interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""
"これらから見るように、pickle は上記のメソッドを直接使用しません。実際には、これらのメソッドは :meth:`__reduce__` "
"特殊メソッドを実装するコピープロトコルの一部です。コピープロトコルは、pickle "
"化とオブジェクトのコピーに必要な、データを取得するための統一されたインタフェースを提供します。 [#]_"

#: ../../library/pickle.rst:567
msgid ""
"Although powerful, implementing :meth:`__reduce__` directly in your classes "
"is error prone.  For this reason, class designers should use the high-level "
"interface (i.e., :meth:`__getnewargs_ex__`, :meth:`__getstate__` and "
":meth:`__setstate__`) whenever possible.  We will show, however, cases where"
" using :meth:`__reduce__` is the only option or leads to more efficient "
"pickling or both."
msgstr ""
"強力ですが、クラスに :meth:`__reduce__` "
"メソッドを直接実装することはエラーを起こしやすくなります。この理由のため、クラスの設計者は可能なかぎり高レベルインタフェース "
"(:meth:`__getnewargs_ex__`、:meth:`__getstate__` および :meth:`__setstate__`) "
"を使用するべきです。公開はしているものの、:meth:`__reduce__` の使用は、あくまでオプションとして、より効果的な pickle "
"化につながる場合、あるいはその両方の場合のみにしてください。"

#: ../../library/pickle.rst:576
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""
"このインタフェースは現在、以下のように定義されています。 :meth:`__reduce__` メソッドは引数を取らず、文字列あるいは "
"(こちらの方が好まれますが) タプルのいずれかを返すべきです (返されたオブジェクトは、しばしば \"reduce value\" と呼ばれます)。"

#: ../../library/pickle.rst:580
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""
"文字列が返された場合、その文字列はグローバル変数の名前として解釈されます。それはオブジェクトのモジュールから見たローカル名であるべきです; pickle"
" モジュールは、オブジェクトのモジュールを決定するためにモジュールの名前空間を検索します。この振る舞いは、典型的にシングルトンで便利です。"

#: ../../library/pickle.rst:585
msgid ""
"When a tuple is returned, it must be between two and five items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr ""
"タプルが返された場合、それは 2〜5 要素長でなければなりません。オプションのアイテムは省略することができます。あるいはそれらの値として "
"``None`` を渡すことができます。各要素の意味は順に:"

#: ../../library/pickle.rst:591
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr "オブジェクトの初期バージョンを作成するために呼ばれる呼び出し可能オブジェクト。"

#: ../../library/pickle.rst:594
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr "呼出し可能オブジェクトに対する引数のタプル。呼出し可能オブジェクトが引数を受け取らない場合、空のタプルが与えられなければなりません。"

#: ../../library/pickle.rst:597
msgid ""
"Optionally, the object's state, which will be passed to the object's "
":meth:`__setstate__` method as previously described.  If the object has no "
"such method then, the value must be a dictionary and it will be added to the"
" object's :attr:`~object.__dict__` attribute."
msgstr ""
"任意で、前述のオブジェクトの :meth:`__setstate__` "
"メソッドに渡されるオブジェクトの状態。オブジェクトがそのようなメソッドを持たない場合、値は辞書でなければならず、それはオブジェクトの "
":attr:`~object.__dict__` 属性に追加されます。"

#: ../../library/pickle.rst:602
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)``"
" or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have "
":meth:`append` and :meth:`extend` methods with the appropriate signature.  "
"(Whether :meth:`append` or :meth:`extend` is used depends on which pickle "
"protocol version is used as well as the number of items to append, so both "
"must be supported.)"
msgstr ""
"任意で、連続した要素を yield する (シーケンスではなく) イテレーター。これらの要素は ``obj.append(item)`` "
"を使用して、あるいはバッチでは ``obj.extend(list_of_items)`` "
"を使用して、オブジェクトに追加されます。これは主としてリストのサブクラスに対して使用されますが、適切なシグネチャを持つ :meth:`append` "
"および :meth:`extend` メソッドがあるかぎり、他のクラスで使用することもできます。 (:meth:`append` または "
":meth:`extend` のどちらが使用されるかは、どの pickle "
"プロトコルバージョンが使われるかに加えて追加されるアイテムの数にも依存します。したがって、両方をサポートする必要があります)"

#: ../../library/pickle.rst:611
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = value``."
"  This is primarily used for dictionary subclasses, but may be used by other"
" classes as long as they implement :meth:`__setitem__`."
msgstr ""
"任意で、連続する key-value ペアを yield する (シーケンスでなく) イテレーター。これらの要素は ``obj[key] = "
"value`` を使用して、オブジェクトに格納されます。これは主として辞書のサブクラスに対して使用されますが、:meth:`__setitem__` "
"を実装しているかぎり他のクラスで使用することもできます。"

#: ../../library/pickle.rst:619
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the "
":meth:`__reduce__` method.  In addition, :meth:`__reduce__` automatically "
"becomes a synonym for the extended version.  The main use for this method is"
" to provide backwards-compatible reduce values for older Python releases."
msgstr ""
"別の方法として、:meth:`__reduce_ex__` "
"メソッドを定義することもできます。唯一の違いは、このメソッドは単一の整数引数、プロトコルバージョンを取る必要があるということです。もし定義された場合、pickle"
" は :meth:`__reduce__` メソッドよりもこのメソッドを優先します。さらに、:meth:`__reduce__` "
"は自動的に拡張版の同義語になります。このメソッドの主な用途は、古い Python リリースに対して後方互換性のある reduce value "
"を提供することです。"

#: ../../library/pickle.rst:631
msgid "Persistence of External Objects"
msgstr "外部オブジェクトの永続化"

#: ../../library/pickle.rst:637
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the"
" notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object"
" (for any newer protocol)."
msgstr ""
"オブジェクトの永続化のために、:mod:`pickle` モジュールは、pickle "
"データストリーム外のオブジェクトに対する参照の概念をサポートしています。そのようなオブジェクトは永続的 ID "
"によって参照されます。それは、英数文字の文字列 (プロトコル 0 に対して) [#]_ あるいは単に任意のオブジェクト "
"(より新しい任意のプロトコルに対して) のいずれかです。"

#: ../../library/pickle.rst:643
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` and "
":meth:`~Unpickler.persistent_load` respectively."
msgstr ""
"そのような永続的 ID の分解能は :mod:`pickle` モジュールでは定義されていません; これはこの分解能を pickler および "
"unpickler のそれぞれ :meth:`~Pickler.persistent_id` および "
":meth:`~Unpickler.persistent_load` 上でのユーザー定義メソッドに移譲します。"

#: ../../library/pickle.rst:648
msgid ""
"To pickle objects that have an external persistent id, the pickler must have"
" a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent id for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""
"外部の永続的 ID を持つ pickle オブジェクトの pickler は、引数にオブジェクトを取り、``None`` かオブジェクトの永続的 ID "
"を返すカスタム :meth:`~Pickler.persistent_id` メソッドを持たなくてはなりません。``None`` "
"を返す場合、pickler は通常通りマーカーとともにオブジェクトを pickle 化するため、unpickler はそれを永続的 ID "
"として認識します。"

#: ../../library/pickle.rst:655
msgid ""
"To unpickle external objects, the unpickler must have a custom "
":meth:`~Unpickler.persistent_load` method that takes a persistent ID object "
"and returns the referenced object."
msgstr ""
"外部オブジェクトを非 pickle 化するには、unpickler は永続的 ID オブジェクトを取り被参照オブジェクトを返すカスタム "
":meth:`~Unpickler.persistent_load` メソッドを持たなくてはなりません。"

#: ../../library/pickle.rst:659
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr "これは、外部のオブジェクトを参照によって pickle 化するために永続的 ID をどのように使用するかを示す包括的な例です。"

#: ../../library/pickle.rst:667
msgid "Dispatch Tables"
msgstr "ディスパッチテーブル"

#: ../../library/pickle.rst:669
msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr ""
"pickle 化に依存する他のコードの邪魔をせずに、一部のクラスの pickle "
"化だけをカスタマイズしたい場合、プライベートのディスパッチテーブルを持つ pickler を作成することができます。"

#: ../../library/pickle.rst:673
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`copyreg.dispatch_table` as a private dispatch table."
msgstr ""
":mod:`copyreg` モジュールによって管理されるグローバルなディスパッチテーブルは "
":data:`copyreg.dispatch_table` "
"として利用可能です。したがって、:data:`copyreg.dispatch_table` "
"の修正済のコピーをプライベートのディスパッチテーブルとして使用することを選択できます。"

#: ../../library/pickle.rst:678
msgid "For example ::"
msgstr "例えば ::"

#: ../../library/pickle.rst:685
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table"
" which handles the ``SomeClass`` class specially.  Alternatively, the code "
"::"
msgstr ""
"これは ``SomeClass`` クラスを特別に扱うプライベートのディスパッチテーブルを持つ :class:`pickle.Pickler` "
"のインスタンスを作成します。あるいは、次のコード ::"

#: ../../library/pickle.rst:695
msgid ""
"does the same, but all instances of ``MyPickler`` will by default share the "
"same dispatch table.  The equivalent code using the :mod:`copyreg` module is"
" ::"
msgstr ""
"も同じことをしますが、 ``MyPickler`` のすべてのインスタンスはデフォルトで同じディスパッチテーブルを共有します。 "
":mod:`copyreg` モジュールを使用する等価なコードは ::"

#: ../../library/pickle.rst:706
msgid "Handling Stateful Objects"
msgstr "状態を持つオブジェクトの扱い"

#: ../../library/pickle.rst:712
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`TextReader` class opens a text file, and returns the line number"
" and line contents each time its :meth:`!readline` method is called. If a "
":class:`TextReader` instance is pickled, all attributes *except* the file "
"object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The "
":meth:`__setstate__` and :meth:`__getstate__` methods are used to implement "
"this behavior. ::"
msgstr ""
"ここでは、クラスを pickle 化する振る舞いの変更手順を紹介しています。:class:`TextReader` "
"クラスはテキストファイルをオープンし、:meth:`!readline` "
"メソッドが呼ばれると、その度に行番号と行の内容を返します。:class:`TextReader` インスタンスが pickle "
"化されるとき、ファイルオブジェクトメンバーを *除く* すべての属性が保存されます。インスタンスが非 pickle "
"化されるとき、ファイルは再びオープンされ、最後に読み込んだ位置から読み込みを再開します。このような振る舞いを実装するには "
":meth:`__setstate__` および :meth:`__getstate__` メソッドを使用します。 ::"

#: ../../library/pickle.rst:758
msgid "A sample usage might be something like this::"
msgstr "使用例は以下のようになるでしょう::"

#: ../../library/pickle.rst:773
msgid "Restricting Globals"
msgstr "グローバル変数を制限する"

#: ../../library/pickle.rst:778
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider"
" what this hand-crafted pickle data stream does when loaded::"
msgstr ""
"デフォルトで、非 pickle 化は pickle "
"データ内で見つけたあらゆるクラスや関数をインポートします。多くのアプリケーションでは、この振る舞いは受け入れられません。なぜなら、それによって "
"unpickler が任意のコードをインポートして実行することが可能になるからです。この手の巧妙に作られた pickle "
"データストリームがロードされたときに何を行うかをちょっと考えてみてください::"

#: ../../library/pickle.rst:788
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""
"この例において、unpickler は :func:`os.system` 関数をインポートして、次に文字列の引数 \"echo hello "
"world\" を適用しています。この例は無害ですが、システムを破壊する例を想像するのは難しくありません。"

#: ../../library/pickle.rst:792
msgid ""
"For this reason, you may want to control what gets unpickled by customizing "
":meth:`Unpickler.find_class`.  Unlike its name suggests, "
":meth:`Unpickler.find_class` is called whenever a global (i.e., a class or a"
" function) is requested.  Thus it is possible to either completely forbid "
"globals or restrict them to a safe subset."
msgstr ""
"この理由のため、:meth:`Unpickler.find_class` をカスタマイズすることで非 pickle "
"化で何を得るかを制御したくなるかもしれません。その名前が示唆するのと異なり、:meth:`Unpickler.find_class` はグローバル "
"(クラスや関数) が必要とした時にはいつでも呼びだされます。したがって、グローバルを完全に禁止することも安全なサブセットに制限することも可能です。"

#: ../../library/pickle.rst:798
msgid ""
"Here is an example of an unpickler allowing only few safe classes from the "
":mod:`builtins` module to be loaded::"
msgstr ""
"これは、一部の安全なクラスについてのみ :mod:`builtins` モジュールからロードすることを許可する unpickler の例です::"

#: ../../library/pickle.rst:827
msgid "A sample usage of our unpickler working has intended::"
msgstr "この unpickler が働く使用例は次のように意図されます::"

#: ../../library/pickle.rst:846
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""
"この例が示すように、非 pickle 化を認めるものに注意しなければなりません。したがって、セキュリティが重要な場合は "
":mod:`xmlrpc.client` の marshal API や、サードパーティのソリューションのような別の選択肢を考慮した方がよいでしょう。"

#: ../../library/pickle.rst:853
msgid "Performance"
msgstr "性能"

#: ../../library/pickle.rst:855
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature"
" efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""
"pickle プロトコルの最近のバージョン (プロトコル 2 以降) "
"は一部の一般的な機能と組み込みデータ型を効率的にバイナリにエンコードするよう考慮されています。また、:mod:`pickle` モジュールは C "
"言語で書かれた透過的オプティマイザーを持っています。"

#: ../../library/pickle.rst:863
msgid "Examples"
msgstr "使用例"

#: ../../library/pickle.rst:865
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr "最も単純なコードでは、:func:`dump` および :func:`load` 関数を使用してください。 ::"

#: ../../library/pickle.rst:881
msgid "The following example reads the resulting pickled data. ::"
msgstr "次の例は、pickle 化されたデータを読み込みます。 ::"

#: ../../library/pickle.rst:898
msgid "Module :mod:`copyreg`"
msgstr ":mod:`copyreg` モジュール"

#: ../../library/pickle.rst:898
msgid "Pickle interface constructor registration for extension types."
msgstr "拡張型を登録するための Pickle インタフェース構成機構。"

#: ../../library/pickle.rst:901
msgid "Module :mod:`pickletools`"
msgstr ":mod:`pickletools` モジュール"

#: ../../library/pickle.rst:901
msgid "Tools for working with and analyzing pickled data."
msgstr "pickle データの処理や分析を行うためのツール。"

#: ../../library/pickle.rst:904
msgid "Module :mod:`shelve`"
msgstr ":mod:`shelve` モジュール"

#: ../../library/pickle.rst:904
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "オブジェクトのインデクス付きデータベース; :mod:`pickle` を使います。"

#: ../../library/pickle.rst:907
msgid "Module :mod:`copy`"
msgstr ":mod:`copy` モジュール"

#: ../../library/pickle.rst:907
msgid "Shallow and deep object copying."
msgstr "オブジェクトの浅いコピーおよび深いコピー。"

#: ../../library/pickle.rst:909
msgid "Module :mod:`marshal`"
msgstr ":mod:`marshal` モジュール"

#: ../../library/pickle.rst:910
msgid "High-performance serialization of built-in types."
msgstr "組み込み型の高性能な直列化。"

#: ../../library/pickle.rst:914
msgid "Footnotes"
msgstr "脚注"

#: ../../library/pickle.rst:915
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr ":mod:`marshal` モジュールと間違えないように注意してください。"

#: ../../library/pickle.rst:917
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all "
":keyword:`lambda` functions share the same name:  ``<lambda>``."
msgstr ""
"なぜ :keyword:`lambda` 関数を pickle 化できないかというと、すべての :keyword:`lambda` 関数は同じ名前: "
"``<lambda>`` を共有しているからです。"

#: ../../library/pickle.rst:920
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an "
":exc:`AttributeError` but it could be something else."
msgstr ""
"送出される例外は :exc:`ImportError` や :exc:`AttributeError` になるはずですが、他の例外も起こりえます。"

#: ../../library/pickle.rst:923
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ":mod:`copy` モジュールは、浅いコピーと深いコピーの操作にこのプロトコルを使用します。"

#: ../../library/pickle.rst:926
msgid ""
"The limitation on alphanumeric characters is due to the fact the persistent "
"IDs, in protocol 0, are delimited by the newline character.  Therefore if "
"any kind of newline characters occurs in persistent IDs, the resulting "
"pickle will become unreadable."
msgstr ""
"英数文字に関する制限は、プロトコル 0 では永続的な ID が改行文字によって区切られるという事実によります。そのため、永続的な ID "
"に何らかの改行文字が含まれると、結果として生じる pickle は判読不能になります。"
