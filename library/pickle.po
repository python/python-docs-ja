# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2017-09-22 17:57+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ":mod:`pickle` --- Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç›´åˆ—åŒ–"

#: ../../library/pickle.rst:17
msgid ""
"The :mod:`pickle` module implements a fundamental, but powerful algorithm "
"for serializing and de-serializing a Python object structure.  \"Pickling\" "
"is the process whereby a Python object hierarchy is converted into a byte "
"stream, and \"unpickling\" is the inverse operation, whereby a byte stream "
"is converted back into an object hierarchy.  Pickling (and unpickling) is "
"alternatively known as \"serialization\", \"marshalling,\" [#]_ or "
"\"flattening\", however, to avoid confusion, the terms used here are "
"\"pickling\" and \"unpickling\"."
msgstr ":mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ç›´åˆ—åŒ– (serialize) ã—ãŸã‚Šéç›´åˆ—åŒ– (de-serialize)ã™ã‚‹ãŸã‚ã®åŸºç¤çš„ã§ã™ãŒå¼·åŠ›ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚ \"Pickle åŒ– (Pickling)\" ã¯ Python ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆéšå±¤ã‚’ãƒã‚¤ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¤‰æ›ã™ã‚‹éç¨‹ã‚’æŒ‡ã—ã¾ã™ã€‚\"é Pickle åŒ– (unpickling)\" ã¯ãã®é€†ã®æ“ä½œã§ã€ãƒã‚¤ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆéšå±¤ã«æˆ»ã™ã‚ˆã†ã«å¤‰æ›ã—ã¾ã™ã€‚Pickle åŒ– (åŠã³é Pickle åŒ–) ã¯ã€åˆ¥å \"ç›´åˆ—åŒ– (serialization)\" ã‚„ \"æ•´åˆ—åŒ– (marshalling)\" [#]_ ã€ \"å¹³å¦åŒ– (flattening)\" ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ãŒã€ã“ã“ã§ã¯æ··ä¹±ã‚’é¿ã‘ã‚‹ãŸã‚ã€ç”¨èªã¨ã—ã¦ \"Pickle åŒ–\" ãŠã‚ˆã³ \"éPickle åŒ–\" ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/pickle.rst:25
msgid ""
"This documentation describes both the :mod:`pickle` module and the "
":mod:`cPickle` module."
msgstr "ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ :mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŠã‚ˆã³ :mod:`cPickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¸¡æ–¹ã«ã¤ã„ã¦è¨˜è¿°ã—ã¾ã™ã€‚"

#: ../../library/pickle.rst:30
msgid ""
"The :mod:`pickle` module is not secure against erroneous or maliciously "
"constructed data.  Never unpickle data received from an untrusted or "
"unauthenticated source."
msgstr ":mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã‚¨ãƒ©ãƒ¼ã‚„ä¸æ­£ã«ç”Ÿæˆã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¿¡é ¼ã§ããªã„ã€ã‚ã‚‹ã„ã¯èªè¨¼ã•ã‚Œã¦ã„ãªã„ã‚½ãƒ¼ã‚¹ã‹ã‚‰å—ã‘å–ã£ãŸã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ unpickle ã—ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../library/pickle.rst:36
msgid "Relationship to other Python modules"
msgstr "ä»–ã® Python ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã®é–¢ä¿‚"

#: ../../library/pickle.rst:38
msgid ""
"The :mod:`pickle` module has an optimized cousin called the :mod:`cPickle` "
"module.  As its name implies, :mod:`cPickle` is written in C, so it can be "
"up to 1000 times faster than :mod:`pickle`.  However it does not support "
"subclassing of the :func:`Pickler` and :func:`Unpickler` classes, because in"
" :mod:`cPickle` these are functions, not classes.  Most applications have no"
" need for this functionality, and can benefit from the improved performance "
"of :mod:`cPickle`. Other than that, the interfaces of the two modules are "
"nearly identical; the common interface is described in this manual and "
"differences are pointed out where necessary.  In the following discussions, "
"we use the term \"pickle\" to collectively describe the :mod:`pickle` and "
":mod:`cPickle` modules."
msgstr ":mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ :mod:`cPickle` ã¨å‘¼ã°ã‚Œã‚‹æœ€é©åŒ–ã®ãªã•ã‚ŒãŸè¦ªé¡ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚ã‚Šã¾ã™ã€‚åå‰ãŒç¤ºã™ã‚ˆã†ã«ã€ :mod:`cPickle` ã¯ C ã§æ›¸ã‹ã‚Œã¦ãŠã‚Šã€ã“ã®ãŸã‚ :mod:`pickle` ã‚ˆã‚Š 1000 å€ãã‚‰ã„ã¾ã§é«˜é€Ÿã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã—ã‹ã—ãªãŒã‚‰ :mod:`cPickle` ã§ã¯ :func:`Pickler` ãŠã‚ˆã³ :func:`Unpickler` ã‚¯ãƒ©ã‚¹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚ã“ã‚Œã¯ :mod:`cPickle` ã§ã¯ã€ã“ã‚Œã‚‰ã¯é–¢æ•°ã§ã‚ã£ã¦ã‚¯ãƒ©ã‚¹ã§ã¯ãªã„ã‹ã‚‰ã§ã™ã€‚ã»ã¨ã‚“ã©ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã“ã®æ©Ÿèƒ½ã¯ä¸è¦ã§ã‚ã‚Šã€ :mod:`cPickle` ã®æŒã¤é«˜ã„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æ©æµã‚’å—ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãã®ä»–ã®ç‚¹ã§ã¯ã€äºŒã¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ãŠã‘ã‚‹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¯ã»ã¨ã‚“ã©åŒã˜ã§ã™; ã“ã®ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã§ã¯å…±é€šã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’è¨˜è¿°ã—ã¦ãŠã‚Šã€å¿…è¦ã«å¿œã˜ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“ã®ç›¸é•ã«ã¤ã„ã¦æŒ‡æ‘˜ã—ã¾ã™ã€‚ä»¥ä¸‹ã®è­°è«–ã§ã¯ã€ :mod:`pickle` ã¨ :mod:`cPickle` ã®ç·ç§°ã¨ã—ã¦ \"pickle\" ã¨ã„ã†ç”¨èªã‚’ä½¿ã†ã“ã¨ã«ã—ã¾ã™ã€‚"

#: ../../library/pickle.rst:49
msgid ""
"The data streams the two modules produce are guaranteed to be "
"interchangeable."
msgstr "ã“ã‚Œã‚‰äºŒã¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒç”Ÿæˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ç›¸äº’äº¤æ›ã§ãã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/pickle.rst:51
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's "
":file:`.pyc` files."
msgstr "Python ã«ã¯ :mod:`marshal` ã¨å‘¼ã°ã‚Œã‚‹ã‚ˆã‚ŠåŸå§‹çš„ãªç›´åˆ—åŒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚ã‚Šã¾ã™ãŒã€ä¸€èˆ¬çš„ã« Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç›´åˆ—åŒ–ã™ã‚‹æ–¹æ³•ã¨ã—ã¦ã¯ :mod:`pickle` ã‚’é¸ã¶ã¹ãã§ã™ã€‚ :mod:`marshal` ã¯åŸºæœ¬çš„ã« :file:`.pyc` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«å­˜åœ¨ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/pickle.rst:56
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ":mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã„ãã¤ã‹ã®ç‚¹ã§ :mod:`marshal` ã¨æ˜ç¢ºã«ç•°ãªã‚Šã¾ã™:"

#: ../../library/pickle.rst:58
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ":mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå†åº¦ç›´åˆ—åŒ–ã•ã‚Œã‚‹ã“ã¨ã®ãªã„ã‚ˆã†ã€ã™ã§ã«ç›´åˆ—åŒ–ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦è¿½è·¡æƒ…å ±ã‚’ä¿æŒã—ã¾ã™ã€‚ :mod:`marshal` ã¯ã“ã‚Œã‚’è¡Œã„ã¾ã›ã‚“ã€‚"

#: ../../library/pickle.rst:62
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr "ã“ã®æ©Ÿèƒ½ã¯å†å¸°çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸¡æ–¹ã«é‡è¦ãªé–¢ã‚ã‚Šã‚’ã‚‚ã£ã¦ã„ã¾ã™ã€‚å†å¸°çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¯è‡ªåˆ†è‡ªèº«ã«å¯¾ã™ã‚‹å‚ç…§ã‚’æŒã£ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚å†å¸°çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ marshal ã§æ‰±ã†ã“ã¨ãŒã§ããšã€å®Ÿéš›ã€å†å¸°çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ marshal åŒ–ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã•ã›ã¦ã—ã¾ã„ã¾ã™ã€‚å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ç›´åˆ—åŒ–ã—ã‚ˆã†ã¨ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆéšå±¤ã®ç•°ãªã‚‹è¤‡æ•°ã®å ´æ‰€ã§åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ãŒå­˜åœ¨ã™ã‚‹å ´åˆã«ç”Ÿã˜ã¾ã™ã€‚å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å…±æœ‰ã®ã¾ã¾ã«ã—ã¦ãŠãã“ã¨ã¯ã€å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã«ã¯éå¸¸ã«é‡è¦ã§ã™ã€‚"

#: ../../library/pickle.rst:71
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ":mod:`marshal` ã¯ãƒ¦ãƒ¼ã‚¶å®šç¾©ã‚¯ãƒ©ã‚¹ã‚„ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç›´åˆ—åŒ–ã™ã‚‹ãŸã‚ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ :mod:`pickle` ã¯ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’é€éçš„ã«ä¿å­˜ã—ãŸã‚Šå¾©å…ƒã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€ã‚¯ãƒ©ã‚¹å®šç¾©ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã€ã‹ã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä¿å­˜ã•ã‚ŒãŸéš›ã¨åŒã˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/pickle.rst:76
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support "
":file:`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise."
" The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases."
msgstr ":mod:`marshal` ã®ç›´åˆ—åŒ–ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ Python ã®ç•°ãªã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§å¯æ¬æ€§ãŒã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¦ã„ã¾ã›ã‚“ã€‚ :mod:`marshal` ã®æœ¬æ¥ã®ä»•äº‹ã¯ :file:`.pyc` ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚µãƒãƒ¼ãƒˆãªã®ã§ã€Python ã‚’å®Ÿè£…ã™ã‚‹äººã€…ã«ã¯ã€å¿…è¦ã«å¿œã˜ã¦ç›´åˆ—åŒ–ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨äº’æ›æ€§ã®ãªã„ã‚‚ã®ã«å¤‰æ›´ã™ã‚‹æ¨©é™ãŒæ®‹ã•ã‚Œã¦ã„ã¾ã™ã€‚ :mod:`pickle` ç›´åˆ—åŒ–ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ã¯ã€å…¨ã¦ã® Python ãƒªãƒªãƒ¼ã‚¹é–“ã§ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã®äº’æ›æ€§ãŒä¿è¨¼ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/pickle.rst:83
msgid ""
"Note that serialization is a more primitive notion than persistence; "
"although :mod:`pickle` reads and writes file objects, it does not handle the"
" issue of naming persistent objects, nor the (even more complicated) issue "
"of concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The module :mod:`shelve` provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr "ç›´åˆ—åŒ–ã¯æ°¸ç¶šåŒ– (persisitence) ã‚ˆã‚Šã‚‚åŸå§‹çš„ãªæ¦‚å¿µã§ã™; :mod:`pickle` ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’èª­ã¿æ›¸ãã—ã¾ã™ãŒã€æ°¸ç¶šåŒ–ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åå‰ä»˜ã‘å•é¡Œã‚„ã€(ã‚ˆã‚Šè¤‡é›‘ãª) ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹ç«¶åˆã‚¢ã‚¯ã‚»ã‚¹ã®å•é¡Œã‚’æ‰±ã„ã¾ã›ã‚“ã€‚ :mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯è¤‡é›‘ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒã‚¤ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¤‰æ›ã™ã‚‹ã“ã¨ãŒã§ãã€ãƒã‚¤ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å¤‰æ›å‰ã¨åŒã˜å†…éƒ¨æ§‹é€ ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®ãƒã‚¤ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æœ€ã‚‚æ˜ç™½ãªç”¨é€”ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®æ›¸ãè¾¼ã¿ã§ã™ãŒã€ãã®ä»–ã«ã‚‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ä»‹ã—ã¦é€ä¿¡ã—ãŸã‚Šã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«è¨˜éŒ²ã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« :mod:`shelve` ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ DBM å½¢å¼ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ä¸Šã§ pickle åŒ–ã—ãŸã‚Š unpickle åŒ–ã—ãŸã‚Šã™ã‚‹ãŸã‚ã®å˜ç´”ãªã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/pickle.rst:96
msgid "Data stream format"
msgstr "ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å½¢å¼"

#: ../../library/pickle.rst:102
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as XDR (which can't represent pointer sharing); however it means that non-"
"Python programs may not be able to reconstruct pickled Python objects."
msgstr ":mod:`pickle` ãŒä½¿ã†ãƒ‡ãƒ¼ã‚¿å½¢å¼ã¯ Python ç‰¹æœ‰ã§ã™ã€‚ãã†ã™ã‚‹ã“ã¨ã§ã€XDR ã®ã‚ˆã†ãªå¤–éƒ¨ã®æ¨™æº–ãŒæŒã¤åˆ¶é™ (ä¾‹ãˆã° XDR ã§ã¯ãƒã‚¤ãƒ³ã‚¿ã®å…±æœ‰ã‚’è¡¨ç¾ã§ãã¾ã›ã‚“) ã‚’èª²ã›ã‚‰ã‚Œã‚‹ã“ã¨ãŒãªã„ã¨ã„ã†åˆ©ç‚¹ãŒã‚ã‚Šã¾ã™; ã—ã‹ã—ã“ã‚Œã¯ Python ã§æ›¸ã‹ã‚Œã¦ã„ãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒ pickle åŒ–ã•ã‚ŒãŸ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†æ§‹ç¯‰ã§ããªã„å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../library/pickle.rst:107
msgid ""
"By default, the :mod:`pickle` data format uses a printable ASCII "
"representation. This is slightly more voluminous than a binary "
"representation.  The big advantage of using printable ASCII (and of some "
"other characteristics of :mod:`pickle`'s representation) is that for "
"debugging or recovery purposes it is possible for a human to read the "
"pickled file with a standard text editor."
msgstr "æ¨™æº–ã§ã¯ã€ :mod:`pickle` ãƒ‡ãƒ¼ã‚¿å½¢å¼ã§ã¯å°å­—å¯èƒ½ãª ASCII è¡¨ç¾ã‚’ä½¿ã„ã¾ã™ã€‚ã“ã‚Œã¯ãƒã‚¤ãƒŠãƒªè¡¨ç¾ã‚ˆã‚Šã‚‚å°‘ã—ã‹ã•ã°ã‚‹ãƒ‡ãƒ¼ã‚¿ã«ãªã‚Šã¾ã™ã€‚å°å­—å¯èƒ½ãª ASCII ã®åˆ©ç”¨ (ã¨ãã®ä»–ã® :mod:`pickle` è¡¨ç¾å½¢å¼ãŒæŒã¤ç‰¹å¾´) ã®å¤§ããªåˆ©ç‚¹ã¯ã€ãƒ‡ãƒãƒƒã‚°ã‚„ãƒªã‚«ãƒãƒªã‚’ç›®çš„ã¨ã—ãŸå ´åˆã«ã€ pickle åŒ–ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¨™æº–çš„ãªãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ã§èª­ã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../library/pickle.rst:113
msgid ""
"There are currently 3 different protocols which can be used for pickling."
msgstr "ç¾åœ¨ã€pickleåŒ–ã«ä½¿ã‚ã‚Œã‚‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ã€ä»¥ä¸‹ã® 3 ç¨®é¡ã§ã™ã€‚"

#: ../../library/pickle.rst:115
msgid ""
"Protocol version 0 is the original ASCII protocol and is backwards "
"compatible with earlier versions of Python."
msgstr "ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 0 ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ã€æœ€åˆã® ASCII ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã€ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®Python ã¨å¾Œæ–¹äº’æ›ã§ã™ã€‚"

#: ../../library/pickle.rst:118
msgid ""
"Protocol version 1 is the old binary format which is also compatible with "
"earlier versions of Python."
msgstr "ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 1 ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ã€å¤ã„ãƒã‚¤ãƒŠãƒªå½¢å¼ã§ã€ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã¨å¾Œæ–¹äº’æ›ã§ã™ã€‚"

#: ../../library/pickle.rst:121
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style class`\\es."
msgstr "ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 2 ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ã€Python 2.3 ã§å°å…¥ã•ã‚Œã¾ã—ãŸã€‚ :term:`new-style class` ã‚’ã€ã‚ˆã‚ŠåŠ¹ç‡ã‚ˆã piclke åŒ–ã—ã¾ã™ã€‚"

#: ../../library/pickle.rst:124
msgid "Refer to :pep:`307` for more information."
msgstr "è©³ç´°ã¯ :pep:`307` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/pickle.rst:126
msgid ""
"If a *protocol* is not specified, protocol 0 is used. If *protocol* is "
"specified as a negative value or :const:`HIGHEST_PROTOCOL`, the highest "
"protocol version available will be used."
msgstr "*protocol* ã‚’æŒ‡å®šã—ãªã„å ´åˆã€ãƒ—ãƒ­ãƒˆã‚³ãƒ« 0 ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ *protocol* ã«è² å€¤ã‹ :const:`HIGHEST_PROTOCOL` ã‚’æŒ‡å®šã™ã‚‹ã¨ã€æœ‰åŠ¹ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®å†…ã€ã‚‚ã£ã¨ã‚‚é«˜ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã‚‚ã®ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:130 ../../library/pickle.rst:176
#: ../../library/pickle.rst:252
msgid "Introduced the *protocol* parameter."
msgstr "*protocol* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå°å…¥ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/pickle.rst:133
msgid ""
"A binary format, which is slightly more efficient, can be chosen by "
"specifying a *protocol* version >= 1."
msgstr "*protocol* version >= 1 ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ã€å°‘ã—ã ã‘åŠ¹ç‡ã®é«˜ã„ãƒã‚¤ãƒŠãƒªå½¢å¼ã‚’é¸ã¶ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/pickle.rst:138
msgid "Usage"
msgstr "ä½¿ç”¨æ³•"

#: ../../library/pickle.rst:140
msgid ""
"To serialize an object hierarchy, you first create a pickler, then you call "
"the pickler's :meth:`dump` method.  To de-serialize a data stream, you first"
" create an unpickler, then you call the unpickler's :meth:`load` method.  "
"The :mod:`pickle` module provides the following constant:"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆéšå±¤ã‚’ç›´åˆ—åŒ–ã™ã‚‹ã«ã¯ã€ã¾ãš pickler ã‚’ç”Ÿæˆã—ã€ç¶šã„ã¦pickler ã® :meth:`dump` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰éç›´åˆ—åŒ–ã™ã‚‹ã«ã¯ã€ã¾ãš unpickler ã‚’ç”Ÿæˆã—ã€ç¶šã„ã¦ unpicklerã® :meth:`load` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ :mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ä»¥ä¸‹ã®å®šæ•°ã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/pickle.rst:148
msgid ""
"The highest protocol version available.  This value can be passed as a "
"*protocol* value."
msgstr "æœ‰åŠ¹ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ã†ã¡ã€æœ€ã‚‚å¤§ãã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€‚ã“ã®å€¤ã¯ã€ *protocol* ã¨ã—ã¦æ¸¡ã›ã¾ã™ã€‚"

#: ../../library/pickle.rst:155
msgid ""
"Be sure to always open pickle files created with protocols >= 1 in binary "
"mode. For the old ASCII-based pickle protocol 0 you can use either text mode"
" or binary mode as long as you stay consistent."
msgstr "protocols >= 1 ã§ä½œã‚‰ã‚ŒãŸ pickle ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€å¸¸ã«ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§ã‚ªãƒ¼ãƒ—ãƒ³ã™ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚å¤ã„ ASCII ãƒ™ãƒ¼ã‚¹ã® pickle ãƒ—ãƒ­ãƒˆã‚³ãƒ« 0 ã§ã¯ã€çŸ›ç›¾ã—ãªã„é™ã‚Šã«ãŠã„ã¦ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã¨ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã®ã„ãšã‚Œã‚‚åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/pickle.rst:159
msgid ""
"A pickle file written with protocol 0 in binary mode will contain lone "
"linefeeds as line terminators and therefore will look \"funny\" when viewed "
"in Notepad or other editors which do not support this format."
msgstr "ãƒ—ãƒ­ãƒˆã‚³ãƒ« 0 ã§æ›¸ã‹ã‚ŒãŸãƒã‚¤ãƒŠãƒªã® pickle ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€è¡Œã‚¿ãƒ¼ãƒŸãƒãƒ¼ã‚¿ã¨ã—ã¦å˜ç‹¬ã®æ”¹è¡Œ(LF)ã‚’å«ã‚“ã§ã„ã¦ã€ã§ã™ã®ã§ã“ã®å½¢å¼ã‚’ã‚µãƒãƒ¼ãƒˆã—ãªã„ã€ Notepad ã‚„ä»–ã®ã‚¨ãƒ‡ã‚£ã‚¿ã§è¦‹ãŸã¨ãã«ã€ŒãŠã‹ã—ãã€è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/pickle.rst:163
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr "ã“ã® pickle åŒ–ã®æ‰‹ç¶šãã‚’ä¾¿åˆ©ã«ã™ã‚‹ãŸã‚ã«ã€ :mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ä»¥ä¸‹ã®é–¢æ•°ã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/pickle.rst:169
msgid ""
"Write a pickled representation of *obj* to the open file object *file*.  "
"This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr "ã™ã§ã«é–‹ã‹ã‚Œã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *file* ã«ã€ *obj* ã‚’ pickle åŒ–ã—ãŸã‚‚ã®ã‚’è¡¨ç¾ã™ã‚‹æ–‡å­—åˆ—ã‚’æ›¸ãè¾¼ã¿ã¾ã™ã€‚ ``Pickler(file, protocol).dump(obj)`` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/pickle.rst:172 ../../library/pickle.rst:205
#: ../../library/pickle.rst:248
msgid ""
"If the *protocol* parameter is omitted, protocol 0 is used. If *protocol* is"
" specified as a negative value or :const:`HIGHEST_PROTOCOL`, the highest "
"protocol version will be used."
msgstr "*protocol* ã‚’æŒ‡å®šã—ãªã„å ´åˆã€ãƒ—ãƒ­ãƒˆã‚³ãƒ« 0 ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ *protocol* ã«è² å€¤ã‹ :const:`HIGHEST_PROTOCOL` ã‚’æŒ‡å®šã™ã‚‹ã¨ã€æœ‰åŠ¹ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®å†…ã€ã‚‚ã£ã¨ã‚‚é«˜ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã‚‚ã®ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:179
msgid ""
"*file* must have a :meth:`write` method that accepts a single string "
"argument. It can thus be a file object opened for writing, a :mod:`StringIO`"
" object, or any other custom object that meets this interface."
msgstr "*file* ã¯ã€å˜ä¸€ã®æ–‡å­—åˆ—å¼•æ•°ã‚’å—ç†ã™ã‚‹ :meth:`write` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒãŸãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å¾“ã£ã¦ã€ *file* ã¨ã—ã¦ã¯ã€æ›¸ãè¾¼ã¿ã®ãŸã‚ã«é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ :mod:`StringIO` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ãã®ä»–å‰è¿°ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã«é©åˆã™ã‚‹ä»–ã®ã‚«ã‚¹ã‚¿ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã¨ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/pickle.rst:186
msgid ""
"Read a string from the open file object *file* and interpret it as a pickle "
"data stream, reconstructing and returning the original object hierarchy.  "
"This is equivalent to ``Unpickler(file).load()``."
msgstr "ã™ã§ã«é–‹ã‹ã‚Œã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *file* ã‹ã‚‰æ–‡å­—åˆ—ã‚’èª­ã¿å‡ºã—ã€èª­ã¿å‡ºã•ã‚ŒãŸæ–‡å­—åˆ—ã‚’ pickle åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿åˆ—ã¨ã—ã¦è§£é‡ˆã—ã¦ã€ã‚‚ã¨ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆéšå±¤ã‚’å†æ§‹ç¯‰ã—ã¦è¿”ã—ã¾ã™ã€‚ ``Unpickler(file).load()`` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/pickle.rst:190 ../../library/pickle.rst:304
msgid ""
"*file* must have two methods, a :meth:`read` method that takes an integer "
"argument, and a :meth:`readline` method that requires no arguments.  Both "
"methods should return a string.  Thus *file* can be a file object opened for"
" reading, a :mod:`StringIO` object, or any other custom object that meets "
"this interface."
msgstr "*file* ã¯ã€æ•´æ•°å¼•æ•°ã‚’ã¨ã‚‹ :meth:`read` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã€å¼•æ•°ã®å¿…è¦ãªã„ :meth:`readline` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒãŸãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä¸¡æ–¹ã¨ã‚‚æ–‡å­—åˆ—ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å¾“ã£ã¦ã€ *file* ã¨ã—ã¦ã¯ã€èª­ã¿å‡ºã—ã®ãŸã‚ã«é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ :mod:`StringIO` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ãã®ä»–å‰è¿°ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã«é©åˆã™ã‚‹ä»–ã®ã‚«ã‚¹ã‚¿ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã¨ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/pickle.rst:196
msgid ""
"This function automatically determines whether the data stream was written "
"in binary mode or not."
msgstr "ã“ã®é–¢æ•°ã¯ãƒ‡ãƒ¼ã‚¿åˆ—ã®æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹ãƒ¢ãƒ¼ãƒ‰ãŒãƒã‚¤ãƒŠãƒªã‹ãã†ã§ãªã„ã‹ã‚’è‡ªå‹•çš„ã«åˆ¤æ–­ã—ã¾ã™ã€‚"

#: ../../library/pickle.rst:202
msgid ""
"Return the pickled representation of the object as a string, instead of "
"writing it to a file."
msgstr "*obj* ã® pickle åŒ–ã•ã‚ŒãŸè¡¨ç¾ã‚’ã€ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã‚€ä»£ã‚ã‚Šã«æ–‡å­—åˆ—ã§è¿”ã—ã¾ã™ã€‚"

#: ../../library/pickle.rst:209
msgid "The *protocol* parameter was added."
msgstr "*protocol* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/pickle.rst:215
msgid ""
"Read a pickled object hierarchy from a string.  Characters in the string "
"past the pickled object's representation are ignored."
msgstr "pickle åŒ–ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆéšå±¤ã‚’æ–‡å­—åˆ—ã‹ã‚‰èª­ã¿å‡ºã—ã¾ã™ã€‚æ–‡å­—åˆ—ä¸­ã§ pickle åŒ–ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¾ã‚ˆã‚Šã‚‚å¾Œã«ç¶šãæ–‡å­—åˆ—ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:218
msgid "The :mod:`pickle` module also defines three exceptions:"
msgstr ":mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ä»¥ä¸‹ã® 3 ã¤ã®ä¾‹å¤–ã‚‚å®šç¾©ã—ã¦ã„ã¾ã™:"

#: ../../library/pickle.rst:223
msgid ""
"A common base class for the other exceptions defined below.  This inherits "
"from :exc:`Exception`."
msgstr "ä¸‹ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ä»–ã®ä¾‹å¤–ã§å…±é€šã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ :exc:`Exception` ã‚’ç¶™æ‰¿ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/pickle.rst:229
msgid ""
"This exception is raised when an unpicklable object is passed to the "
":meth:`dump` method."
msgstr "ã“ã®ä¾‹å¤–ã¯ unpickle ä¸å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ :meth:`dump` ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã•ã‚ŒãŸå ´åˆã«é€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:235
msgid ""
"This exception is raised when there is a problem unpickling an object. Note "
"that other exceptions may also be raised during unpickling, including (but "
"not necessarily limited to) :exc:`AttributeError`, :exc:`EOFError`, "
":exc:`ImportError`, and :exc:`IndexError`."
msgstr "ã“ã®ä¾‹å¤–ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ unpickle åŒ–ã™ã‚‹éš›ã«å•é¡ŒãŒç™ºç”Ÿã—ãŸå ´åˆã«é€å‡ºã•ã‚Œã¾ã™ã€‚ unpickle åŒ–ä¸­ã«ã¯ :exc:`AttributeError` ã€ :exc:`EOFError` ã€ :exc:`ImportError` ã€ãŠã‚ˆã³ :exc:`IndexError` ã¨ã„ã£ãŸä»–ã®ä¾‹å¤– (ã“ã‚Œã ã‘ã¨ã¯é™ã‚Šã¾ã›ã‚“) ã‚‚ç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/pickle.rst:240
msgid ""
"The :mod:`pickle` module also exports two callables [#]_, :class:`Pickler` "
"and :class:`Unpickler`:"
msgstr ":mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€2 ã¤ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ [#]_ ã¨ã—ã¦ã€ :class:`Pickler` ãŠã‚ˆã³ :class:`Unpickler` ã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/pickle.rst:246
msgid ""
"This takes a file-like object to which it will write a pickle data stream."
msgstr "pickle åŒ–ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿åˆ—ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ãƒ•ã‚¡ã‚¤ãƒ«é¡ä¼¼ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼•æ•°ã«ã¨ã‚Šã¾ã™ã€‚"

#: ../../library/pickle.rst:255
msgid ""
"*file* must have a :meth:`write` method that accepts a single string "
"argument. It can thus be an open file object, a :mod:`StringIO` object, or "
"any other custom object that meets this interface."
msgstr "*file* ã¯å˜ä¸€ã®æ–‡å­—åˆ—å¼•æ•°ã‚’å—ç†ã™ã‚‹ :meth:`write` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒãŸãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å¾“ã£ã¦ã€ *file* ã¨ã—ã¦ã¯ã€æ›¸ãè¾¼ã¿ã®ãŸã‚ã«é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ :mod:`StringIO` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ãã®ä»–å‰è¿°ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã«é©åˆã™ã‚‹ä»–ã®ã‚«ã‚¹ã‚¿ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã¨ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/pickle.rst:259
msgid ":class:`Pickler` objects define one (or two) public methods:"
msgstr ":class:`Pickler` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€ä¸€ã¤ (ã¾ãŸã¯äºŒã¤) ã® public ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã¾ã™:"

#: ../../library/pickle.rst:264
msgid ""
"Write a pickled representation of *obj* to the open file object given in the"
" constructor.  Either the binary or ASCII format will be used, depending on "
"the value of the *protocol* argument passed to the constructor."
msgstr "ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ä¸ãˆã‚‰ã‚ŒãŸã€ã™ã§ã«é–‹ã‹ã‚Œã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã« *obj* ã® pickle åŒ–ã•ã‚ŒãŸè¡¨ç¾ã‚’æ›¸ãè¾¼ã¿ã¾ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«æ¸¡ã•ã‚ŒãŸ *protocol* å¼•æ•°ã®å€¤ã«å¿œã˜ã¦ã€ãƒã‚¤ãƒŠãƒªãŠã‚ˆã³ASCII å½¢å¼ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:271
msgid ""
"Clears the pickler's \"memo\".  The memo is the data structure that "
"remembers which objects the pickler has already seen, so that shared or "
"recursive objects pickled by reference and not by value.  This method is "
"useful when re-using picklers."
msgstr "picller ã® \"ãƒ¡ãƒ¢\" ã‚’æ¶ˆå»ã—ã¾ã™ã€‚ãƒ¡ãƒ¢ã¨ã¯ã€å…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯å†å¸°çš„ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå€¤ã§ã¯ãªãå‚ç…§ã§è¨˜æ†¶ã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€ pickler ãŒã“ã‚Œã¾ã§ã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«é­é‡ã—ã¦ããŸã‹ã‚’è¨˜æ†¶ã™ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ pickler ã‚’å†åˆ©ç”¨ã™ã‚‹éš›ã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../library/pickle.rst:278
msgid ""
"Prior to Python 2.3, :meth:`clear_memo` was only available on the picklers "
"created by :mod:`cPickle`.  In the :mod:`pickle` module, picklers have an "
"instance variable called :attr:`memo` which is a Python dictionary.  So to "
"clear the memo for a :mod:`pickle` module pickler, you could do the "
"following::"
msgstr "Python 2.3 ä»¥å‰ã§ã¯ã€ :meth:`clear_memo` ã¯ :mod:`cPickle` ã§ç”Ÿæˆã•ã‚ŒãŸ pickler ã§ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã—ãŸã€‚ :mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€pickler ã¯ :attr:`memo` ã¨å‘¼ã°ã‚Œã‚‹ Python è¾æ›¸å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‚’æŒã¡ã¾ã™ã€‚å¾“ã£ã¦ã€ :mod:`pickler` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ãŠã‘ã‚‹ pickler ã®ãƒ¡ãƒ¢ã‚’æ¶ˆå»ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ã§ãã¾ã™::"

#: ../../library/pickle.rst:285
msgid ""
"Code that does not need to support older versions of Python should simply "
"use :meth:`clear_memo`."
msgstr "ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã§ã®å‹•ä½œã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ã®ãªã„ã‚³ãƒ¼ãƒ‰ã§ã¯ã€å˜ã« :meth:`clear_memo` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/pickle.rst:288
msgid ""
"It is possible to make multiple calls to the :meth:`dump` method of the same"
" :class:`Pickler` instance.  These must then be matched to the same number "
"of calls to the :meth:`load` method of the corresponding :class:`Unpickler` "
"instance.  If the same object is pickled by multiple :meth:`dump` calls, the"
" :meth:`load` will all yield references to the same object. [#]_"
msgstr "åŒã˜ :class:`Pickler` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã—ã€ :meth:`dump` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¤‡æ•°å›å‘¼ã³å‡ºã™ã“ã¨ã¯å¯èƒ½ã§ã™ã€‚ã“ã®å‘¼ã³å‡ºã—ã¯ã€å¯¾å¿œã™ã‚‹ :class:`Unpickler` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§åŒã˜å›æ•°ã ã‘ :meth:`load` ã‚’å‘¼ã³å‡ºã™æ“ä½œã«å¯¾å¿œã—ã¾ã™ã€‚åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ :meth:`dump` ã‚’è¤‡æ•°å›å‘¼ã³å‡ºã—ã¦ pickle åŒ–ã•ã‚ŒãŸå ´åˆã€ :meth:`load` ã¯å…¨ã¦åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦å‚ç…§ã‚’è¡Œã„ã¾ã™ [#]_ ã€‚"

#: ../../library/pickle.rst:294
msgid ":class:`Unpickler` objects are defined as:"
msgstr ":class:`Unpickler` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™:"

#: ../../library/pickle.rst:299
msgid ""
"This takes a file-like object from which it will read a pickle data stream. "
"This class automatically determines whether the data stream was written in "
"binary mode or not, so it does not need a flag as in the :class:`Pickler` "
"factory."
msgstr "pickle ãƒ‡ãƒ¼ã‚¿åˆ—ã‚’èª­ã¿å‡ºã™ãŸã‚ã®ãƒ•ã‚¡ã‚¤ãƒ«é¡ä¼¼ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼•æ•°ã«å–ã‚Šã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯ãƒ‡ãƒ¼ã‚¿åˆ—ãŒãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã‹ã©ã†ã‹ã‚’è‡ªå‹•çš„ã«åˆ¤åˆ¥ã—ã¾ã™ã€‚å¾“ã£ã¦ã€ :class:`Pickler` ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚ˆã†ãªãƒ•ãƒ©ã‚°ã‚’å¿…è¦ã¨ã—ã¾ã›ã‚“ã€‚"

#: ../../library/pickle.rst:310
msgid ":class:`Unpickler` objects have one (or two) public methods:"
msgstr ":class:`Unpickler` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ 1 ã¤ (ã¾ãŸã¯ 2 ã¤) ã® public ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¾ã™:"

#: ../../library/pickle.rst:315
msgid ""
"Read a pickled object representation from the open file object given in the "
"constructor, and return the reconstituted object hierarchy specified "
"therein."
msgstr "ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§æ¸¡ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® pickle åŒ–è¡¨ç¾ã‚’èª­ã¿å‡ºã—ã€ä¸­ã«åã‚ã‚‰ã‚Œã¦ã„ã‚‹å†æ§‹ç¯‰ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆéšå±¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/pickle.rst:319
msgid ""
"This method automatically determines whether the data stream was written in "
"binary mode or not."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯è‡ªå‹•çš„ã«ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§æ›¸ãå‡ºã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤åˆ¥ã—ã¾ã™ã€‚"

#: ../../library/pickle.rst:325
msgid ""
"This is just like :meth:`load` except that it doesn't actually create any "
"objects.  This is useful primarily for finding what's called \"persistent "
"ids\" that may be referenced in a pickle data stream.  See section :ref"
":`pickle-protocol` below for more details."
msgstr ":meth:`load` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€å®Ÿéš›ã«ã¯ä½•ã‚‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ãªã„ã¨ã„ã†ç‚¹ãŒé•ã„ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ç¬¬ä¸€ã« pickle åŒ–ãƒ‡ãƒ¼ã‚¿åˆ—ä¸­ã§å‚ç…§ã•ã‚Œã¦ã„ã‚‹ã€\"æ°¸ç¶šåŒ– id\" ã¨å‘¼ã°ã‚Œã¦ã„ã‚‹å€¤ã‚’æ¤œç´¢ã™ã‚‹ä¸Šã§ä¾¿åˆ©ã§ã™ã€‚è©³ç´°ã¯ä»¥ä¸‹ã® :ref:`pickle-protocol` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/pickle.rst:330
msgid ""
"**Note:** the :meth:`noload` method is currently only available on "
":class:`Unpickler` objects created with the :mod:`cPickle` module. "
":mod:`pickle` module :class:`Unpickler`\\ s do not have the :meth:`noload` "
"method."
msgstr "**æ³¨æ„:** :meth:`noload` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ç¾åœ¨ :mod:`cPickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ç”Ÿæˆã•ã‚ŒãŸ :class:`Unpickler` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ã§åˆ©ç”¨å¯èƒ½ã§ã™ã€‚ :mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :class:`Unpickler` ã«ã¯ã€ :meth:`noload` ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/pickle.rst:337
msgid "What can be pickled and unpickled?"
msgstr "ä½•ã‚’ pickle åŒ–ã—ãŸã‚Š unpickle åŒ–ã§ãã‚‹ã®ã‹?"

#: ../../library/pickle.rst:339
msgid "The following types can be pickled:"
msgstr "ä»¥ä¸‹ã®å‹ã¯ pickle åŒ–ã§ãã¾ã™:"

#: ../../library/pickle.rst:341
msgid "``None``, ``True``, and ``False``"
msgstr "``None`` ã€ ``True`` ã€ãŠã‚ˆã³ ``False``"

#: ../../library/pickle.rst:343
msgid "integers, long integers, floating point numbers, complex numbers"
msgstr "æ•´æ•°ã€é•·æ•´æ•°ã€æµ®å‹•å°æ•°ç‚¹æ•°ã€è¤‡ç´ æ•°"

#: ../../library/pickle.rst:345
msgid "normal and Unicode strings"
msgstr "é€šå¸¸æ–‡å­—åˆ—ãŠã‚ˆã³ Unicode æ–‡å­—åˆ—"

#: ../../library/pickle.rst:347
msgid ""
"tuples, lists, sets, and dictionaries containing only picklable objects"
msgstr "pickle åŒ–å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«ã€ãƒªã‚¹ãƒˆã€é›†åˆãŠã‚ˆã³è¾æ›¸"

#: ../../library/pickle.rst:349
msgid "functions defined at the top level of a module"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹é–¢æ•°"

#: ../../library/pickle.rst:351
msgid "built-in functions defined at the top level of a module"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹çµ„è¾¼ã¿é–¢æ•°"

#: ../../library/pickle.rst:353
msgid "classes that are defined at the top level of a module"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹"

#: ../../library/pickle.rst:355
msgid ""
"instances of such classes whose :attr:`~object.__dict__` or the result of "
"calling :meth:`__getstate__` is picklable  (see section :ref:`pickle-"
"protocol` for details)."
msgstr ":attr:`~object.__dict__` å±æ€§ã‚’æŒã¤ã‚¯ãƒ©ã‚¹ã€ã‚ã‚‹ã„ã¯ :meth:`__getstate__` ãƒ¡ã‚½ãƒƒãƒ‰ã®è¿”ã‚Šå€¤ãŒ pickle åŒ–å¯èƒ½ãªã‚¯ãƒ©ã‚¹ (è©³ç´°ã¯ :ref:`pickle-protocol` ã‚’å‚ç…§)ã€‚"

#: ../../library/pickle.rst:359
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file. Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a "
":exc:`RuntimeError` will be raised in this case. You can carefully raise "
"this limit with :func:`sys.setrecursionlimit`."
msgstr "pickle åŒ–ã§ããªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ pickle åŒ–ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ :exc:`PicklingError` ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™; ã“ã®ä¾‹å¤–ãŒèµ·ããŸå ´åˆã€èƒŒå¾Œã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯æœªçŸ¥ã®é•·ã•ã®ãƒã‚¤ãƒˆåˆ—ãŒæ›¸ãè¾¼ã¾ã‚Œã¦ã—ã¾ã„ã¾ã™ã€‚æ¥µç«¯ã«å†å¸°çš„ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ pickle åŒ–ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã«ã¯å†å¸°ã®æ·±ã•åˆ¶é™ã‚’è¶Šãˆã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œãšã€ã“ã®å ´åˆã«ã¯ :exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ã“ã®åˆ¶é™ã¯ã€ :func:`sys.setrecursionlimit` ã§æ…é‡ã«ä¸Šã’ã¦ã„ãã“ã¨ã¯å¯èƒ½ã§ã™ã€‚"

#: ../../library/pickle.rst:366
msgid ""
"Note that functions (built-in and user-defined) are pickled by \"fully "
"qualified\" name reference, not by value.  This means that only the function"
" name is pickled, along with the name of the module the function is defined "
"in.  Neither the function's code, nor any of its function attributes are "
"pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr "(çµ„ã¿è¾¼ã¿ãŠã‚ˆã³ãƒ¦ãƒ¼ã‚¶å®šç¾©ã®) é–¢æ•°ã¯ã€å€¤ã§ã¯ãªã \"å®Œå…¨è¨˜è¿°ã•ã‚ŒãŸ\" å‚ç…§åã¨ã—ã¦ pickle åŒ–ã•ã‚Œã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã¯ã€é–¢æ•°ã®å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã¨ä¸€ç·’ã¨ä½µã›ã€é–¢æ•°åã ã‘ãŒ pickle åŒ–ã•ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚é–¢æ•°ã®ã‚³ãƒ¼ãƒ‰ã‚„é–¢æ•°ã®å±æ€§ã¯ä½•ã‚‚ pickleåŒ–ã•ã‚Œã¾ã›ã‚“ã€‚å¾“ã£ã¦ã€å®šç¾©ã—ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ unpickle åŒ–ç’°å¢ƒã§ import å¯èƒ½ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯æŒ‡å®šã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå«ã¾ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã†ã§ãªã„å ´åˆã€ä¾‹å¤–ãŒé€å‡ºã•ã‚Œã¾ã™ [#]_ ã€‚"

#: ../../library/pickle.rst:373
msgid ""
"Similarly, classes are pickled by named reference, so the same restrictions "
"in the unpickling environment apply.  Note that none of the class's code or "
"data is pickled, so in the following example the class attribute ``attr`` is"
" not restored in the unpickling environment::"
msgstr "ã‚¯ãƒ©ã‚¹ã‚‚åŒæ§˜ã«åå‰å‚ç…§ã§ pickle åŒ–ã•ã‚Œã‚‹ã®ã§ã€unpickle åŒ–ç’°å¢ƒã«ã¯åŒã˜åˆ¶é™ãŒèª²ã›ã‚‰ã‚Œã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ä¸­ã®ã‚³ãƒ¼ãƒ‰ã‚„ãƒ‡ãƒ¼ã‚¿ã¯ä½•ã‚‚ pickle åŒ–ã•ã‚Œãªã„ã®ã§ã€ä»¥ä¸‹ã®ä¾‹ã§ã¯ã‚¯ãƒ©ã‚¹å±æ€§ ``attr`` ãŒ unpickle åŒ–ç’°å¢ƒã§å¾©å…ƒã•ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ ::"

#: ../../library/pickle.rst:383
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"in the top level of a module."
msgstr "pickle åŒ–å¯èƒ½ãªé–¢æ•°ã‚„ã‚¯ãƒ©ã‚¹ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã¯ã“ã‚Œã‚‰ã®åˆ¶é™ã®ãŸã‚ã§ã™ã€‚"

#: ../../library/pickle.rst:386
msgid ""
"Similarly, when class instances are pickled, their class's code and data are"
" not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`__setstate__` "
"method."
msgstr "åŒæ§˜ã«ã€ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ pickle åŒ–ã•ã‚ŒãŸéš›ã€ãã®ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ¼ãƒ‰ãŠã‚ˆã³ãƒ‡ãƒ¼ã‚¿ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ä¸€ç·’ã« pickle åŒ–ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã®ã¿ãŒ pickle åŒ–ã•ã‚Œã¾ã™ã€‚ã“ã®ä»•æ§˜ã¯ã€ã‚¯ãƒ©ã‚¹å†…ã®ãƒã‚°ã‚’ä¿®æ­£ã—ãŸã‚Šãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã—ãŸå¾Œã§ã‚‚ã€ãã®ã‚¯ãƒ©ã‚¹ã®ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ä½œã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’èª­ã¿å‡ºã›ã‚‹ã‚ˆã†ã«æ„å›³çš„ã«è¡Œã‚ã‚Œã¦ã„ã¾ã™ã€‚ã‚ã‚‹ã‚¯ãƒ©ã‚¹ã®å¤šãã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ä½¿ã‚ã‚Œã‚‹ã‚ˆã†ãªé•·å‘½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚ã†ã¨è¨ˆç”»ã—ã¦ã„ã‚‹ãªã‚‰ã€ãã®ã‚¯ãƒ©ã‚¹ã® :meth:`__setstate__` ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦é©åˆ‡ãªå¤‰æ›ãŒè¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã‚’å…¥ã‚Œã¦ãŠãã¨ã‚ˆã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/pickle.rst:398
msgid "The pickle protocol"
msgstr "pickle åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«"

#: ../../library/pickle.rst:402
msgid ""
"This section describes the \"pickling protocol\" that defines the interface "
"between the pickler/unpickler and the objects that are being serialized.  "
"This protocol provides a standard way for you to define, customize, and "
"control how your objects are serialized and de-serialized.  The description "
"in this section doesn't cover specific customizations that you can employ to"
" make the unpickling environment slightly safer from untrusted pickle data "
"streams; see section :ref:`pickle-sub` for more details."
msgstr "ã“ã®ç¯€ã§ã¯ pickler/unpickler ã¨ç›´åˆ—åŒ–å¯¾è±¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã®é–“ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®šç¾©ã™ã‚‹ \"pickle åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«\"ã«ã¤ã„ã¦è¨˜è¿°ã—ã¾ã™ã€‚ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯è‡ªåˆ†ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã©ã®ã‚ˆã†ã«ç›´åˆ—åŒ–ã•ã‚ŒãŸã‚Šéç›´åˆ—åŒ–ã•ã‚ŒãŸã‚Šã™ã‚‹ã‹ã‚’å®šç¾©ã—ã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ã€åˆ¶å¾¡ã™ã‚‹ãŸã‚ã®æ¨™æº–çš„ãªæ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã®ç¯€ã§ã®è¨˜è¿°ã¯ã€unpickle åŒ–ç’°å¢ƒã‚’ä¸ä¿¡ãª pickle åŒ–ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦å®‰å…¨ã«ã™ã‚‹ãŸã‚ã«ä½¿ã†ç‰¹æ®Šãªã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºåŒ–ã«ã¤ã„ã¦ã¯ã‚«ãƒãƒ¼ã—ã¦ã„ã¾ã›ã‚“; è©³ç´°ã¯ :ref:`pickle-sub` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/pickle.rst:414
msgid "Pickling and unpickling normal class instances"
msgstr "é€šå¸¸ã®ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® pickle åŒ–ãŠã‚ˆã³ unpickle åŒ–"

#: ../../library/pickle.rst:418
msgid ""
"When a pickled class instance is unpickled, its :meth:`__init__` method is "
"normally *not* invoked.  If it is desirable that the :meth:`__init__` method"
" be called on unpickling, an old-style class can define a method "
":meth:`__getinitargs__`, which should return a *tuple* of positional "
"arguments to be passed to the class constructor (:meth:`__init__` for "
"example).  Keyword arguments are not supported.  The :meth:`__getinitargs__`"
" method is called at pickle time; the tuple it returns is incorporated in "
"the pickle for the instance."
msgstr "pickle åŒ–ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ unpickle åŒ–ã•ã‚ŒãŸã¨ãã€ :meth:`__init__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯é€šå¸¸å‘¼ã³å‡ºã•ã‚Œ *ã¾ã›ã‚“* ã€‚\nunpickle åŒ–ã®éš›ã« :meth:`__init__` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹æ–¹ãŒæœ›ã¾ã—ã„å ´åˆã€æ—§ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã§ã¯ãƒ¡ã‚½ãƒƒãƒ‰ :meth:`__getinitargs__` ã‚’å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚\nã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¯ãƒ©ã‚¹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ (ä¾‹ãˆã° :meth:`__init__`) ã«æ¸¡ã•ã‚Œã‚‹ã¹ãä½ç½®å¼•æ•°ã‹ã‚‰ãªã‚‹ *ã‚¿ãƒ—ãƒ«* ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n:meth:`__getinitargs__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ pickle æ™‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™; ã“ã®é–¢æ•°ãŒè¿”ã™ã‚¿ãƒ—ãƒ«ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® pickle åŒ–ãƒ‡ãƒ¼ã‚¿ã«çµ„ã¿è¾¼ã¾ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:429
msgid ""
"New-style types can provide a :meth:`__getnewargs__` method that is used for"
" protocol 2.  Implementing this method is needed if the type establishes "
"some internal invariants when the instance is created, or if the memory "
"allocation is affected by the values passed to the :meth:`__new__` method "
"for the type (as it is for tuples and strings).  Instances of a :term:`new-"
"style class` ``C`` are created using ::"
msgstr "æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ã§ã¯ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ« 2 ã§å‘¼ã³å‡ºã•ã‚Œã‚‹ :meth:`__getnewargs__` ã‚’å®šç¾©ã™ã‚‹äº‹ãŒã§ãã¾ã™ã€‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆæ™‚ã«å†…éƒ¨çš„ãªä¸å¤‰æ¡ä»¶ãŒæˆç«‹ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸã‚Šã€ï¼ˆã‚¿ãƒ—ãƒ«ã‚„æ–‡å­—åˆ—ã®ã‚ˆã†ã«ï¼‰å‹ã® :meth:`__new__` ãƒ¡ã‚½ãƒƒãƒ‰ã«æŒ‡å®šã™ã‚‹å¼•æ•°ã«ã‚ˆã£ã¦ãƒ¡ãƒ¢ãƒªã®å‰²ã‚Šå½“ã¦ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã«ã¯ :meth:`__getnewargs__` ã‚’å®šç¾©ã—ã¦ãã ã•ã„ã€‚æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ :class:`C` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€æ¬¡ã®ã‚ˆã†ã«ç”Ÿæˆã•ã‚Œã¾ã™ã€‚::"

#: ../../library/pickle.rst:438
msgid ""
"where *args* is the result of calling :meth:`__getnewargs__` on the original"
" object; if there is no :meth:`__getnewargs__`, an empty tuple is assumed."
msgstr "ã“ã“ã§ *args* ã¯å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`__getnewargs__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ãŸæ™‚ã®æˆ»ã‚Šå€¤ã¨ãªã‚Šã¾ã™ã€‚ :meth:`__getnewargs__` ã‚’å®šç¾©ã—ã¦ã„ãªã„å ´åˆã€ *args* ã¯ç©ºã®ã‚¿ãƒ—ãƒ«ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/pickle.rst:443
msgid ""
"Classes can further influence how their instances are pickled; if the class "
"defines the method :meth:`__getstate__`, it is called and the return state "
"is pickled as the contents for the instance, instead of the contents of the "
"instance's dictionary.  If there is no :meth:`__getstate__` method, the "
"instance's :attr:`~object.__dict__` is pickled."
msgstr "ã‚¯ãƒ©ã‚¹ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® pickle åŒ–æ–¹æ³•ã«ã•ã‚‰ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™; ã‚¯ãƒ©ã‚¹ãŒ :meth:`__getstate__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã‚‹å ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã€è¿”ã•ã‚ŒãŸçŠ¶æ…‹å€¤ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å†…å®¹ã¨ã—ã¦ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è¾æ›¸ã®ä»£ã‚ã‚Šã« pickle åŒ–ã•ã‚Œã¾ã™ã€‚ :meth:`__getstate__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® :attr:`~object.__dict__` ã®å†…å®¹ãŒ pickle åŒ–ã•ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:451
msgid ""
"Upon unpickling, if the class also defines the method :meth:`__setstate__`, "
"it is called with the unpickled state. [#]_ If there is no "
":meth:`__setstate__` method, the pickled state must be a dictionary and its "
"items are assigned to the new instance's dictionary.  If a class defines "
"both :meth:`__getstate__` and :meth:`__setstate__`, the state object needn't"
" be a dictionary and these methods can do what they want. [#]_"
msgstr "unpickle åŒ–ã§ã¯ã€ã‚¯ãƒ©ã‚¹ãŒ :meth:`__setstate__` ã‚‚å®šç¾©ã—ã¦ã„ãŸå ´åˆã€ unpickle åŒ–ã•ã‚ŒãŸçŠ¶æ…‹å€¤ã¨ã¨ã‚‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ [#]_ :meth:`__setstate__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€pickle åŒ–ã•ã‚ŒãŸçŠ¶æ…‹ã¯è¾æ›¸å‹ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ãã®è¦ç´ ã¯æ–°ãŸãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è¾æ›¸ã«ä»£å…¥ã•ã‚Œã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ãŒ :meth:`__getstate__` ã¨ :meth:`__setstate__` ã®ä¸¡æ–¹ã‚’å®šç¾©ã—ã¦ã„ã‚‹å ´åˆã€çŠ¶æ…‹å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è¾æ›¸ã§ã‚ã‚‹å¿…è¦ã¯ãªãã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯æœŸå¾…é€šã‚Šã®å‹•ä½œã‚’è¡Œã„ã¾ã™ã€‚ [#]_"

#: ../../library/pickle.rst:460
msgid ""
"For :term:`new-style class`\\es, if :meth:`__getstate__` returns a false "
"value, the :meth:`__setstate__` method will not be called."
msgstr "æ–°ã—ã„ã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚¯ãƒ©ã‚¹ã«ãŠã„ã¦ :meth:`__getstate__` ãŒå½å€¤ã‚’è¿”ã™å ´åˆã€ :meth:`__setstate__` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å‘¼ã°ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/pickle.rst:465
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, "
":meth:`__getattribute__`, or :meth:`__setattr__` may be called upon the "
"instance.  In case those methods rely on some internal invariant being true,"
" the type should implement either :meth:`__getinitargs__` or "
":meth:`__getnewargs__` to establish such an invariant; otherwise, neither "
":meth:`__new__` nor :meth:`__init__` will be called."
msgstr "unpickleã™ã‚‹ã¨ãã€ :meth:`__getattr__`, :meth:`__getattribute__`, :meth:`__setattr__` ã¨ã„ã£ãŸãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã—ã¦å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒä½•ã‹å†…éƒ¨ã®ä¸å¤‰æ¡ä»¶ã«ä¾å­˜ã—ã¦ã„ã‚‹ã®ã§ã‚ã‚Œã°ã€ãã®å‹ã¯ :meth:`__getinitargs__` ã‹ :meth:`__getnewargs__` ã®ã©ã¡ã‚‰ã‹ã‚’å®Ÿè£…ã—ã¦ãã®ä¸å¤‰æ¡ä»¶ã‚’æº€ãŸã›ã‚‹ã‚ˆã†ã«ã™ã‚‹ã¹ãã§ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã€ :meth:`__new__` ã‚‚ :meth:`__init__` ã‚‚å‘¼ã°ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/pickle.rst:474
msgid "Pickling and unpickling extension types"
msgstr "æ‹¡å¼µå‹ã® pickle åŒ–ãŠã‚ˆã³ unpickle åŒ–"

#: ../../library/pickle.rst:478
msgid ""
"When the :class:`Pickler` encounters an object of a type it knows nothing "
"about --- such as an extension type --- it looks in two places for a hint of"
" how to pickle it.  One alternative is for the object to implement a "
":meth:`__reduce__` method.  If provided, at pickling time :meth:`__reduce__`"
" will be called with no arguments, and it must return either a string or a "
"tuple."
msgstr ":class:`Pickler` ãŒå…¨ãæœªçŸ¥ã®å‹ã® --- æ‹¡å¼µå‹ã®ã‚ˆã†ãª --- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«é­é‡ã—ãŸå ´åˆã€pickle åŒ–æ–¹æ³•ã®ãƒ’ãƒ³ãƒˆã¨ã—ã¦ 2 å€‹æ‰€ã‚’æ¢ã—ã¾ã™ã€‚ç¬¬ä¸€ã¯ :meth:`__reduce__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã§ã™ã€‚ã‚‚ã—å®Ÿè£…ã•ã‚Œã¦ã„ã‚Œã°ã€pickle åŒ–æ™‚ã« :meth:`__reduce__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¼•æ•°ãªã—ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã“ã®å‘¼ã³å‡ºã—ã«å¯¾ã—ã¦æ–‡å­—åˆ—ã¾ãŸã¯ã‚¿ãƒ—ãƒ«ã®ã©ã¡ã‚‰ã‹ã‚’è¿”ã•ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/pickle.rst:485
msgid ""
"If a string is returned, it names a global variable whose contents are "
"pickled as normal.  The string returned by :meth:`__reduce__` should be the "
"object's local name relative to its module; the pickle module searches the "
"module namespace to determine the object's module."
msgstr "æ–‡å­—åˆ—ã‚’è¿”ã™å ´åˆã€ãã®æ–‡å­—åˆ—ã¯é€šå¸¸é€šã‚Šã« pickle åŒ–ã•ã‚Œã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®åå‰ã‚’æŒ‡ã—ã¦ã„ã¾ã™ã€‚ :meth:`__reduce__` ã®è¿”ã™æ–‡å­—åˆ—ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‹ã‚‰ã¿ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ­ãƒ¼ã‚«ãƒ«ãªåå‰ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; pickle ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ã‚’æ¤œç´¢ã—ã¦ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ±ºå®šã—ã¾ã™ã€‚"

#: ../../library/pickle.rst:490
msgid ""
"When a tuple is returned, it must be between two and five elements long. "
"Optional elements can either be omitted, or ``None`` can be provided as "
"their value.  The contents of this tuple are pickled as normal and used to "
"reconstruct the object at unpickling time.  The semantics of each element "
"are:"
msgstr "ã‚¿ãƒ—ãƒ«ã‚’è¿”ã™å ´åˆã€ã‚¿ãƒ—ãƒ«ã®è¦ç´ æ•°ã¯ 2 ã‹ã‚‰ 5 ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®è¦ç´ ã¯çœç•¥ã—ãŸã‚Š ``None`` ã‚’æŒ‡å®šã—ãŸã‚Šã§ãã¾ã™ã€‚å„è¦ç´ ã®æ„å‘³ã¥ã‘ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™:"

#: ../../library/pickle.rst:496
msgid ""
"A callable object that will be called to create the initial version of the "
"object.  The next element of the tuple will provide arguments for this "
"callable, and later elements provide additional state information that will "
"subsequently be used to fully reconstruct the pickled data."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åˆæœŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã“ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¼•æ•°ã¯ã‚¿ãƒ—ãƒ«ã®æ¬¡ã®è¦ç´ ã§ä¸ãˆã‚‰ã‚Œã¾ã™ã€‚ãã‚Œä»¥é™ã®è¦ç´ ã§ã¯ pickle åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’å®Œå…¨ã«å†æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹ä»˜åŠ çš„ãªçŠ¶æ…‹æƒ…å ±ãŒä¸ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:501
msgid ""
"In the unpickling environment this object must be either a class, a callable"
" registered as a \"safe constructor\" (see below), or it must have an "
"attribute :attr:`__safe_for_unpickling__` with a true value. Otherwise, an "
":exc:`UnpicklingError` will be raised in the unpickling environment.  Note "
"that as usual, the callable itself is pickled by name."
msgstr "é€† pickle åŒ–ã®ç’°å¢ƒä¸‹ã§ã¯ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¯ãƒ©ã‚¹ã‹ã€ \"å®‰å…¨ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ (safe constructor, ä¸‹è¨˜å‚ç…§)\" ã¨ã—ã¦ç™»éŒ²ã•ã‚Œã¦ã„ãŸã‚Šå±æ€§ :attr:`__safe_for_unpickling__` ã®å€¤ãŒçœŸã§ã‚ã‚‹ã‚ˆã†ãªå‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã†ã§ãªã„å ´åˆã€é€† pickle åŒ–ã‚’è¡Œã†ç’°å¢ƒã§ :exc:`UnpicklingError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚é€šå¸¸é€šã‚Šã€ callable ã¯åå‰ã ã‘ã§ pickle åŒ–ã•ã‚Œã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/pickle.rst:507
msgid "A tuple of arguments for the callable object."
msgstr "å‘¼ã³å‡ºã—å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãŸã‚ã®å¼•æ•°ã‹ã‚‰ãªã‚‹ã‚¿ãƒ—ãƒ«"

#: ../../library/pickle.rst:509
msgid "Formerly, this argument could also be ``None``."
msgstr "ä»¥å‰ã¯ã€ã“ã®å¼•æ•°ã«ã¯ ``None`` ã‚‚ã‚ã‚Šå¾—ã¾ã—ãŸã€‚"

#: ../../library/pickle.rst:512
msgid ""
"Optionally, the object's state, which will be passed to the object's "
":meth:`__setstate__` method as described in section :ref:`pickle-inst`.  If "
"the object has no :meth:`__setstate__` method, then, as above, the value "
"must be a dictionary and it will be added to the object's "
":attr:`~object.__dict__`."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨ã—ã¦ã€ :ref:`pickle-inst` ç¯€ã§è¨˜è¿°ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :meth:`__setstate__` ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã•ã‚Œã‚‹ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®çŠ¶æ…‹ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ :meth:`__setstate__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒãŸãªã„å ´åˆã€ä¸Šè¨˜ã®ã‚ˆã†ã«ã€ã“ã®å€¤ã¯è¾æ›¸ã§ãªãã¦ã¯ãªã‚‰ãšã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :attr:`~object.__dict__` ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:518
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive list items."
"  These list items will be pickled, and appended to the object using either "
"``obj.append(item)`` or ``obj.extend(list_of_items)``.  This is primarily "
"used for list subclasses, but may be used by other classes as long as they "
"have :meth:`append` and :meth:`extend` methods with the appropriate "
"signature.  (Whether :meth:`append` or :meth:`extend` is used depends on "
"which pickle protocol version is used as well as the number of items to "
"append, so both must be supported.)"
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨ã—ã¦ã€ãƒªã‚¹ãƒˆä¸­ã®é€£ç¶šã™ã‚‹è¦ç´ ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ (ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“)ã€‚ã“ã®ãƒªã‚¹ãƒˆã®è¦ç´ ã¯ pickle åŒ–ã•ã‚Œã€ ``obj.append(item)`` ã¾ãŸã¯ ``obj.extend(list_of_items)`` ã®ã„ãšã‚Œã‹ã‚’ä½¿ã£ã¦è¿½åŠ ã•ã‚Œã¾ã™ã€‚ä¸»ã«ãƒªã‚¹ãƒˆã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ç”¨ã„ã‚‰ã‚Œã¦ã„ã¾ã™ãŒã€ä»–ã®ã‚¯ãƒ©ã‚¹ã§ã‚‚ã€é©åˆ‡ãªã‚·ã‚°ãƒãƒãƒ£ã® :meth:`append` ã‚„ :meth:`extend` ã‚’å‚™ãˆã¦ã„ã‚‹é™ã‚Šåˆ©ç”¨ã§ãã¾ã™ã€‚ (:meth:`append` ã¨ :meth:`extend` ã®ã„ãšã‚Œã‚’ä½¿ã†ã‹ã¯ã€ã©ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® pickle ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ä½¿ã£ã¦ã„ã‚‹ã‹ã€ãã—ã¦è¿½åŠ ã™ã‚‹è¦ç´ ã®æ•°ã§æ±ºã¾ã‚Šã¾ã™ã€‚å¾“ã£ã¦ä¸¡æ–¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚)"

#: ../../library/pickle.rst:527
msgid ""
"Optionally, an iterator (not a sequence) yielding successive dictionary "
"items, which should be tuples of the form ``(key, value)``.  These items "
"will be pickled and stored to the object using ``obj[key] = value``. This is"
" primarily used for dictionary subclasses, but may be used by other classes "
"as long as they implement :meth:`__setitem__`."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨ã—ã¦ã€è¾æ›¸ä¸­ã®é€£ç¶šã™ã‚‹è¦ç´ ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ (ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“)ã€‚ã“ã®ãƒªã‚¹ãƒˆã®è¦ç´ ã¯ ``(key, value)`` ã¨ã„ã†å½¢å¼ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚è¦ç´ ã¯ pickle åŒ–ã•ã‚Œã€ ``obj[key] = value`` ã‚’ä½¿ã£ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æ ¼ç´ã•ã‚Œã¾ã™ã€‚ä¸»ã«è¾æ›¸ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ç”¨ã„ã‚‰ã‚Œã¦ã„ã¾ã™ãŒã€ä»–ã®ã‚¯ãƒ©ã‚¹ã§ã‚‚ã€ :meth:`__setitem__` ã‚’å‚™ãˆã¦ã„ã‚‹é™ã‚Šåˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/pickle.rst:535
msgid ""
"It is sometimes useful to know the protocol version when implementing "
":meth:`__reduce__`.  This can be done by implementing a method named "
":meth:`__reduce_ex__` instead of :meth:`__reduce__`. :meth:`__reduce_ex__`, "
"when it exists, is called in preference over :meth:`__reduce__` (you may "
"still provide :meth:`__reduce__` for backwards compatibility).  The "
":meth:`__reduce_ex__` method will be called with a single integer argument, "
"the protocol version."
msgstr ":meth:`__reduce__` ã‚’å®Ÿè£…ã™ã‚‹å ´åˆã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’çŸ¥ã£ã¦ãŠãã¨ä¾¿åˆ©ãªã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ :meth:`__reduce__` ã®ä»£ã‚ã‚Šã« :meth:`__reduce_ex__` ã‚’ä½¿ã£ã¦å®Ÿç¾ã§ãã¾ã™ã€‚ :meth:`__reduce_ex__` ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ :meth:`__reduce__` ã‚ˆã‚Šã‚‚å„ªå…ˆã—ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ (ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã®äº’æ›æ€§ã®ãŸã‚ã« :meth:`__reduce__` ã‚’æ®‹ã—ã¦ãŠã„ã¦ã‚‚ã‹ã¾ã„ã¾ã›ã‚“)ã€‚ :meth:`__reduce_ex__` ã¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¡¨ã™æ•´æ•°ã®å¼•æ•°ã‚’ä¸€ã¤ä¼´ã£ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:543
msgid ""
"The :class:`object` class implements both :meth:`__reduce__` and "
":meth:`__reduce_ex__`; however, if a subclass overrides :meth:`__reduce__` "
"but not :meth:`__reduce_ex__`, the :meth:`__reduce_ex__` implementation "
"detects this and calls :meth:`__reduce__`."
msgstr ":class:`object` ã‚¯ãƒ©ã‚¹ã§ã¯ :meth:`__reduce__` ã¨ :meth:`__reduce_ex__` ã®ä¸¡æ–¹ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ã¨ã¯ã„ãˆã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ :meth:`__reduce__` ã‚’ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã—ã¦ãŠã‚Šã€ :meth:`__reduce_ex__` ã‚’ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã—ã¦ã„ãªã„å ´åˆã«ã¯ã€ :meth:`__reduce_ex__` ã®å®Ÿè£…ãŒãã‚Œã‚’æ¤œå‡ºã—ã¦ :meth:`__reduce__` ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/pickle.rst:548
msgid ""
"An alternative to implementing a :meth:`__reduce__` method on the object to "
"be pickled, is to register the callable with the :mod:`copy_reg` module.  "
"This module provides a way for programs to register \"reduction functions\" "
"and constructors for user-defined types.   Reduction functions have the same"
" semantics and interface as the :meth:`__reduce__` method described above, "
"except that they are called with a single argument, the object to be "
"pickled."
msgstr "pickle åŒ–ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸Šã§ :meth:`__reduce__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ä»£ã‚ã‚Šã«ã€ :mod:`copy_reg` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç™»éŒ²ã™ã‚‹æ–¹æ³•ã‚‚ã‚ã‚Šã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã« \"ç¸®å°åŒ–é–¢æ•° (reduction function)\" ã¨ãƒ¦ãƒ¼ã‚¶å®šç¾©å‹ã®ãŸã‚ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç™»éŒ²ã™ã‚‹æ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚ç¸®å°åŒ–é–¢æ•°ã¯ã€å˜ä¸€ã®å¼•æ•°ã¨ã—ã¦ pickle åŒ–ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã¨ã‚‹ã“ã¨ã‚’é™¤ãã€ä¸Šã§è¿°ã¹ãŸ :meth:`__reduce__` ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒã˜æ„å‘³ã¨ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æŒã¡ã¾ã™ã€‚"

#: ../../library/pickle.rst:555
msgid ""
"The registered constructor is deemed a \"safe constructor\" for purposes of "
"unpickling as described above."
msgstr "ç™»éŒ²ã•ã‚ŒãŸã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ä¸Šã§è¿°ã¹ãŸã‚ˆã†ãª unpickle åŒ–ã«ã¤ã„ã¦ã¯ \"å®‰å…¨ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿\" ã§ã‚ã‚‹ã¨è€ƒãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:560
msgid "Pickling and unpickling external objects"
msgstr "å¤–éƒ¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® pickle åŒ–ãŠã‚ˆã³ unpickle åŒ–"

#: ../../library/pickle.rst:566
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the"
" notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a \"persistent id\", which is just an arbitrary "
"string of printable ASCII characters. The resolution of such names is not "
"defined by the :mod:`pickle` module; it will delegate this resolution to "
"user defined functions on the pickler and unpickler. [#]_"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ°¸ç¶šåŒ–ã‚’ä¾¿åˆ©ã«ã™ã‚‹ãŸã‚ã«ã€ :mod:`pickle` ã¯ pickle åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿åˆ—ä¸Šã«ãªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦å‚ç…§ã‚’è¡Œã†ã¨ã„ã†æ¦‚å¿µã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ \"æ°¸ç¶šåŒ– id (persistent id)\" ã§å‚ç…§ã•ã‚Œã¦ãŠã‚Šã€ã“ã® id ã¯å˜ã«å°å­—å¯èƒ½ãªASCII æ–‡å­—ã‹ã‚‰ãªã‚‹ä»»æ„ã®æ–‡å­—åˆ—ã§ã™ã€‚ã“ã‚Œã‚‰ã®åå‰ã®è§£æ±ºæ–¹æ³•ã¯ :mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯å®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“; ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã“ã®åå‰è§£æ±ºã‚’ pickler ãŠã‚ˆã³ unpickler ä¸Šã®ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã«ã‚†ã ã­ã¾ã™ [#]_ ã€‚"

#: ../../library/pickle.rst:573
msgid ""
"To define external persistent id resolution, you need to set the "
":attr:`~Pickler.persistent_id` attribute of the pickler object and the "
":attr:`~Unpickler.persistent_load` attribute of the unpickler object."
msgstr "å¤–éƒ¨æ°¸ç¶šåŒ– id ã®è§£æ±ºã‚’å®šç¾©ã™ã‚‹ã«ã¯ã€pickler ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :attr:`~Pickler.persistent_id` å±æ€§ã¨ã€ unpickler ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® :attr:`~Unpickler.persistent_load` å±æ€§ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/pickle.rst:577
msgid ""
"To pickle objects that have an external persistent id, the pickler must have"
" a custom :func:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent id for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent id string is returned, the pickler will pickle that "
"string, along with a marker so that the unpickler will recognize the string "
"as a persistent id."
msgstr "å¤–éƒ¨æ°¸ç¶šåŒ– id ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ pickle åŒ–ã™ã‚‹ã«ã¯ã€pickler ã¯è‡ªä½œã® :func:`~Pickler.persistent_id` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒãŸãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä¸€ã¤ã®å¼•æ•°ã‚’ã¨ã‚Šã€ ``None`` ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ°¸ç¶šåŒ– id ã®ã†ã¡ã©ã¡ã‚‰ã‹ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ ``None`` ãŒè¿”ã•ã‚ŒãŸå ´åˆã€ pickler ã¯å˜ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é€šå¸¸ã®ã‚ˆã†ã« pickle åŒ–ã™ã‚‹ã ã‘ã§ã™ã€‚æ°¸ç¶šåŒ– id æ–‡å­—åˆ—ãŒè¿”ã•ã‚ŒãŸå ´åˆã€ piclkler ã¯ãã®æ–‡å­—åˆ—ã«å¯¾ã—ã¦ã€unpickler ãŒã“ã®æ–‡å­—åˆ—ã‚’æ°¸ç¶šåŒ– id ã¨ã—ã¦èªè­˜ã§ãã‚‹ã‚ˆã†ã«ã€ãƒãƒ¼ã‚«ã¨å…±ã« pickle åŒ–ã—ã¾ã™ã€‚"

#: ../../library/pickle.rst:585
msgid ""
"To unpickle external objects, the unpickler must have a custom "
":func:`~Unpickler.persistent_load` function that takes a persistent id "
"string and returns the referenced object."
msgstr "å¤–éƒ¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ unpickle åŒ–ã™ã‚‹ã«ã¯ã€unpickler ã¯è‡ªä½œã® :func:`~Unpickler.persistent_load` é–¢æ•°ã‚’æŒãŸãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®é–¢æ•°ã¯æ°¸ç¶šåŒ– id æ–‡å­—åˆ—ã‚’å¼•æ•°ã«ã¨ã‚Šã€å‚ç…§ã•ã‚Œã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/pickle.rst:589
msgid "Here's a silly example that *might* shed more light::"
msgstr "*å¤šåˆ†* ã‚ˆã‚Šç†è§£ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã‚ˆã†ãªã¡ã‚‡ã£ã¨ã—ãŸä¾‹ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™::"

#: ../../library/pickle.rst:637
msgid ""
"In the :mod:`cPickle` module, the unpickler's "
":attr:`~Unpickler.persistent_load` attribute can also be set to a Python "
"list, in which case, when the unpickler reaches a persistent id, the "
"persistent id string will simply be appended to this list.  This "
"functionality exists so that a pickle data stream can be \"sniffed\" for "
"object references without actually instantiating all the objects in a "
"pickle. [#]_  Setting :attr:`~Unpickler.persistent_load` to a list is "
"usually used in conjunction with the :meth:`~Unpickler.noload` method on the"
" Unpickler."
msgstr ":mod:`cPickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§ã¯ã€ unpickler ã® :attr:`~Unpickler.persistent_load` å±æ€§ã¯ Pythonãƒªã‚¹ãƒˆå‹ã¨ã—ã¦è¨­å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®å ´åˆã€ unpickler ãŒæ°¸ç¶šåŒ– id ã«é­é‡ã—ã¦ã‚‚ã€æ°¸ç¶šåŒ– id æ–‡å­—åˆ—ã¯å˜ã«ãƒªã‚¹ãƒˆã«è¿½åŠ ã•ã‚Œã‚‹ã ã‘ã§ã™ã€‚ã“ã®ä»•æ§˜ã¯ã€pickle ãƒ‡ãƒ¼ã‚¿ä¸­ã®å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿéš›ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã—ãªãã¦ã‚‚ã€ pickle ãƒ‡ãƒ¼ã‚¿åˆ—ä¸­ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ã‚’ \"å—…ãå›ã‚‹\" ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«å­˜åœ¨ã—ã¦ã„ã¾ã™ [#]_ ã€‚ãƒªã‚¹ãƒˆã« :attr:`~Unpickler.persistent_load` ã‚’è¨­å®šã™ã‚‹ã‚„ã‚Šæ–¹ã¯ã€ã‚ˆã Unpickler ã‚¯ãƒ©ã‚¹ã® :meth:`~Unpickler.noload` ãƒ¡ã‚½ãƒƒãƒ‰ã¨å…±ã«ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:655
msgid "Subclassing Unpicklers"
msgstr "Unpickler ã‚’ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã™ã‚‹"

#: ../../library/pickle.rst:661
msgid ""
"By default, unpickling will import any class that it finds in the pickle "
"data. You can control exactly what gets unpickled and what gets called by "
"customizing your unpickler.  Unfortunately, exactly how you do this is "
"different depending on whether you're using :mod:`pickle` or :mod:`cPickle`."
" [#]_"
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€é€† pickle åŒ–ã¯ pickle åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ä¸­ã«è¦‹ã¤ã‹ã£ãŸã‚¯ãƒ©ã‚¹ã‚’ import ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚è‡ªå‰ã® unpickler ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã“ã¨ã§ã€ä½•ãŒ unpickle åŒ–ã•ã‚Œã¦ã€ã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã‹ã‚’å³å¯†ã«åˆ¶å¾¡ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã™ã€‚ã—ã‹ã—ä¸é‹ãªã“ã¨ã«ã€å³å¯†ã«ãªã«ã‚’è¡Œã†ã¹ãã‹ã¯ :mod:`pickle` ã¨ :mod:`cPickle` ã®ã©ã¡ã‚‰ã‚’ä½¿ã†ã‹ã§ç•°ãªã‚Šã¾ã™ [#]_ ã€‚"

#: ../../library/pickle.rst:666
msgid ""
"In the :mod:`pickle` module, you need to derive a subclass from "
":class:`Unpickler`, overriding the :meth:`load_global` method. "
":meth:`load_global` should read two lines from the pickle data stream where "
"the first line will the name of the module containing the class and the "
"second line will be the name of the instance's class.  It then looks up the "
"class, possibly importing the module and digging out the attribute, then it "
"appends what it finds to the unpickler's stack.  Later on, this class will "
"be assigned to the :attr:`__class__` attribute of an empty class, as a way "
"of magically creating an instance without calling its class's "
":meth:`__init__`. Your job (should you choose to accept it), would be to "
"have :meth:`load_global` push onto the unpickler's stack, a known safe "
"version of any class you deem safe to unpickle. It is up to you to produce "
"such a class.  Or you could raise an error if you want to disallow all "
"unpickling of instances.  If this sounds like a hack, you're right.  Refer "
"to the source code to make this work."
msgstr ":mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ :class:`Unpickler` ã‹ã‚‰ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’æ´¾ç”Ÿã—ã€ :meth:`load_global` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¸Šæ›¸ãã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ :meth:`load_global` ã¯ pickle ãƒ‡ãƒ¼ã‚¿åˆ—ã‹ã‚‰æœ€åˆã® 2 è¡Œã‚’èª­ã¾ãªã‘ã‚Œã°ãªã‚‰ãšã€ã“ã“ã§æœ€åˆã®è¡Œã¯ãã®ã‚¯ãƒ©ã‚¹ã‚’å«ã‚€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã€2 è¡Œç›®ã¯ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¯ãƒ©ã‚¹åã«ãªã‚‹ã¯ãšã§ã™ã€‚æ¬¡ã«ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä¾‹ãˆã°ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦å±æ€§ã‚’æ˜ã‚Šèµ·ã“ã™ãªã©ã—ã¦ã‚¯ãƒ©ã‚¹ã‚’æ¢ã—ã€ç™ºè¦‹ã•ã‚ŒãŸã‚‚ã®ã‚’ unpickler ã®ã‚¹ã‚¿ãƒƒã‚¯ã«ç½®ãã¾ã™ã€‚ãã®å¾Œã€ã“ã®ã‚¯ãƒ©ã‚¹ã¯ç©ºã®ã‚¯ãƒ©ã‚¹ã® :attr:`__class__` å±æ€§ã«ä»£å…¥ã™ã‚‹æ–¹æ³•ã§ã€ã‚¯ãƒ©ã‚¹ã® :meth:`__init__` ã‚’ä½¿ã‚ãšã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’é­”æ³•ã®ã‚ˆã†ã«ç”Ÿæˆã—ã¾ã™ã€‚ã‚ãªãŸã®ä½œæ¥­ã¯ (ã‚‚ã—ãã®ä½œæ¥­ã‚’å—ã‘å…¥ã‚Œã‚‹ãªã‚‰)ã€unpickler ã®ã‚¹ã‚¿ãƒƒã‚¯ã®ä¸Šã« push ã•ã‚ŒãŸ :meth:`load_global` ã‚’ã€unpickle ã—ã¦ã‚‚å®‰å…¨ã ã¨è€ƒãˆã‚‰ã‚Œã‚‹ä½•ã‚‰ã‹ã®ã‚¯ãƒ©ã‚¹ã®æ—¢çŸ¥ã®å®‰å…¨ãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚ã‚ã‚‹ã„ã¯å…¨ã¦ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã—ã¦ unpickling ã‚’è¨±å¯ã—ãŸããªã„ãªã‚‰ã‚¨ãƒ©ãƒ¼ã‚’é€å‡ºã—ã¦ãã ã•ã„ã€‚ã“ã®ã‹ã‚‰ãã‚ŠãŒãƒãƒƒã‚¯ã®ã‚ˆã†ã«æ€ãˆã‚‹ãªã‚‰ã€ã‚ãªãŸã¯é–“é•ã£ã¦ã„ã¾ã›ã‚“ã€‚ã“ã®ã‹ã‚‰ãã‚Šã‚’å‹•ã‹ã™ã«ã¯ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/pickle.rst:681
msgid ""
"Things are a little cleaner with :mod:`cPickle`, but not by much. To control"
" what gets unpickled, you can set the unpickler's "
":attr:`~Unpickler.find_global` attribute to a function or ``None``.  If it "
"is ``None`` then any attempts to unpickle instances will raise an "
":exc:`UnpicklingError`.  If it is a function, then it should accept a module"
" name and a class name, and return the corresponding class object.  It is "
"responsible for looking up the class and performing any necessary imports, "
"and it may raise an error to prevent instances of the class from being "
"unpickled."
msgstr ":mod:`cPickle` ã§ã¯äº‹æƒ…ã¯å¤šå°‘ã™ã£ãã‚Šã—ã¦ã„ã¾ã™ãŒã€ååˆ†ã¨ã„ã†ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä½•ã‚’ unpickle åŒ–ã™ã‚‹ã‹ã‚’åˆ¶å¾¡ã™ã‚‹ã«ã¯ã€ unpickler ã® :attr:`~Unpickler.find_global` å±æ€§ã‚’é–¢æ•°ã‹ ``None`` ã«è¨­å®šã—ã¾ã™ã€‚å±æ€§ãŒ ``None`` ã®å ´åˆã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ unpickle ã—ã‚ˆã†ã¨ã™ã‚‹è©¦ã¿ã¯å…¨ã¦ :exc:`UnpicklingError` ã‚’é€å‡ºã—ã¾ã™ã€‚å±æ€§ãŒé–¢æ•°ã®å ´åˆã€ã“ã®é–¢æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã¾ãŸã¯ã‚¯ãƒ©ã‚¹åã‚’å—ç†ã—ã€å¯¾å¿œã™ã‚‹ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã•ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ãŒè¡Œã‚ãªãã¦ã¯ãªã‚‰ãªã„ã®ã¯ã€ã‚¯ãƒ©ã‚¹ã®æ¢ç´¢ã€å¿…è¦ãª import ã®ã‚„ã‚Šç›´ã—ã§ã™ã€‚ãã—ã¦ãã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ unpickle åŒ–ã•ã‚Œã‚‹ã®ã‚’é˜²ããŸã‚ã«ã‚¨ãƒ©ãƒ¼ã‚’é€å‡ºã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../library/pickle.rst:690
msgid ""
"The moral of the story is that you should be really careful about the source"
" of the strings your application unpickles."
msgstr "ä»¥ä¸Šã®è©±ã‹ã‚‰è¨€ãˆã‚‹ã“ã¨ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒ unpickle åŒ–ã™ã‚‹æ–‡å­—åˆ—ã®ç™ºä¿¡å…ƒã«ã¤ã„ã¦ã¯éå¸¸ã«é«˜ã„æ³¨æ„ã‚’ã¯ã‚‰ã‚ãªãã¦ã¯ãªã‚‰ãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../library/pickle.rst:697
msgid "Example"
msgstr "ä¾‹"

#: ../../library/pickle.rst:699
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions.  "
"Note that a self-referencing list is pickled and restored correctly. ::"
msgstr "ã„ã¡ã°ã‚“å˜ç´”ã«ã¯ã€ :func:`dump` ã¨ :func:`load` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚è‡ªå·±å‚ç…§ãƒªã‚¹ãƒˆãŒæ­£ã—ã pickle åŒ–ãŠã‚ˆã³ãƒªã‚¹ãƒˆã‚¢ã•ã‚Œã‚‹ã“ã¨ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚ ::"

#: ../../library/pickle.rst:721
msgid ""
"The following example reads the resulting pickled data.  When reading a "
"pickle-containing file, you should open the file in binary mode because you "
"can't be sure if the ASCII or binary format was used. ::"
msgstr "ä»¥ä¸‹ã®ä¾‹ã¯ pickle åŒ–ã•ã‚ŒãŸçµæœã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚ pickle ã‚’å«ã‚€ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«ã¯ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§ã‚ªãƒ¼ãƒ—ãƒ³ã—ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚ã“ã‚Œã¯ ASCII å½¢å¼ã¨ãƒã‚¤ãƒŠãƒªå½¢å¼ã®ã©ã¡ã‚‰ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ã‹ã¯åˆ†ã‹ã‚‰ãªã„ã‹ã‚‰ã§ã™ã€‚ ::"

#: ../../library/pickle.rst:737
msgid ""
"Here's a larger example that shows how to modify pickling behavior for a "
"class. The :class:`TextReader` class opens a text file, and returns the line"
" number and line contents each time its :meth:`!readline` method is called. "
"If a :class:`TextReader` instance is pickled, all attributes *except* the "
"file object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The "
":meth:`__setstate__` and :meth:`__getstate__` methods are used to implement "
"this behavior. ::"
msgstr "ã‚ˆã‚Šå¤§ããªä¾‹ã§ã€ã‚¯ãƒ©ã‚¹ã‚’ pickle åŒ–ã™ã‚‹æŒ™å‹•ã‚’å¤‰æ›´ã™ã‚‹ã‚„ã‚Šæ–¹ã‚’ç¤ºã—ã¾ã™ã€‚ :class:`TextReader` ã‚¯ãƒ©ã‚¹ã¯ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãã€ :meth:`!readline` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã‚‹ãŸã³ã«è¡Œç•ªå·ã¨è¡Œã®å†…å®¹ã‚’è¿”ã—ã¾ã™ã€‚ :class:`TextReader` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ pickle åŒ–ã•ã‚ŒãŸå ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *ä»¥å¤–ã®* å…¨ã¦ã®å±æ€§ãŒä¿å­˜ã•ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ unpickle åŒ–ã•ã‚ŒãŸéš›ã€ãƒ•ã‚¡ã‚¤ãƒ«ã¯å†åº¦é–‹ã‹ã‚Œã€ä»¥å‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ä½ç½®ã‹ã‚‰èª­ã¿å‡ºã—ã‚’å†é–‹ã—ã¾ã™ã€‚ä¸Šè¨˜ã®å‹•ä½œã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€ :meth:`__setstate__` ãŠã‚ˆã³ :meth:`__getstate__` ãƒ¡ã‚½ãƒƒãƒ‰ãŒä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ ::"

#: ../../library/pickle.rst:777
msgid "A sample usage might be something like this::"
msgstr "ä½¿ç”¨ä¾‹ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã§ã—ã‚‡ã†::"

#: ../../library/pickle.rst:790
msgid ""
"If you want to see that :mod:`pickle` works across Python processes, start "
"another Python session, before continuing.  What follows can happen from "
"either the same process or a new process. ::"
msgstr ":mod:`pickle` ãŒ Python ãƒ—ãƒ­ã‚»ã‚¹é–“ã§ã†ã¾ãåƒãã“ã¨ã‚’è¦‹ãŸã„ãªã‚‰ã€å…ˆã«é€²ã‚€å‰ã«ä»–ã® Python ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚ä»¥ä¸‹ã®æŒ¯ã‚‹èˆã„ã¯åŒã˜ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚‚æ–°ãŸãªãƒ—ãƒ­ã‚»ã‚¹ã§ã‚‚èµ·ã“ã‚Šã¾ã™ã€‚ ::"

#: ../../library/pickle.rst:803
msgid "Module :mod:`copy_reg`"
msgstr ":mod:`copy_reg` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/pickle.rst:803
msgid "Pickle interface constructor registration for extension types."
msgstr "æ‹¡å¼µå‹ã‚’ç™»éŒ²ã™ã‚‹ãŸã‚ã® Pickle ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹æ§‹æˆæ©Ÿæ§‹ã€‚"

#: ../../library/pickle.rst:806
msgid "Module :mod:`shelve`"
msgstr ":mod:`shelve` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/pickle.rst:806
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚¹ä»˜ããƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹; :mod:`pickle` ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/pickle.rst:809
msgid "Module :mod:`copy`"
msgstr ":mod:`copy` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/pickle.rst:809
msgid "Shallow and deep object copying."
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æµ…ã„ã‚³ãƒ”ãƒ¼ãŠã‚ˆã³æ·±ã„ã‚³ãƒ”ãƒ¼ã€‚"

#: ../../library/pickle.rst:811
msgid "Module :mod:`marshal`"
msgstr ":mod:`marshal` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"

#: ../../library/pickle.rst:812
msgid "High-performance serialization of built-in types."
msgstr "çµ„ã¿è¾¼ã¿å‹ã®é«˜æ€§èƒ½ãªç›´åˆ—åŒ–ã€‚"

#: ../../library/pickle.rst:816
msgid ":mod:`cPickle` --- A faster :mod:`pickle`"
msgstr ":mod:`cPickle` --- ã‚ˆã‚Šé«˜é€Ÿãª :mod:`pickle`"

#: ../../library/pickle.rst:826
msgid ""
"The :mod:`cPickle` module supports serialization and de-serialization of "
"Python objects, providing an interface and functionality nearly identical to"
" the :mod:`pickle` module.  There are several differences, the most "
"important being performance and subclassability."
msgstr ":mod:`cPickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç›´åˆ—åŒ–ãŠã‚ˆã³éç›´åˆ—åŒ–ã‚’ã‚µãƒãƒ¼ãƒˆã—ã€ :mod:`pickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã»ã¨ã‚“ã©åŒã˜ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¨æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚ã„ãã¤ã‹ç›¸é•ç‚¹ãŒã‚ã‚Šã¾ã™ãŒã€æœ€ã‚‚é‡è¦ãªé•ã„ã¯ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¨ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ãŒå¯èƒ½ã‹ã©ã†ã‹ã§ã™ã€‚"

#: ../../library/pickle.rst:831
msgid ""
"First, :mod:`cPickle` can be up to 1000 times faster than :mod:`pickle` "
"because the former is implemented in C.  Second, in the :mod:`cPickle` "
"module the callables :func:`Pickler` and :func:`Unpickler` are functions, "
"not classes. This means that you cannot use them to derive custom pickling "
"and unpickling subclasses.  Most applications have no need for this "
"functionality and should benefit from the greatly improved performance of "
"the :mod:`cPickle` module."
msgstr "ç¬¬ä¸€ã«ã€ :mod:`cPickle` ã¯ C ã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ :mod:`pickle` ã‚ˆã‚Šã‚‚æœ€å¤§ã§ 1000 å€é«˜é€Ÿã§ã™ã€‚ç¬¬äºŒã«ã€ :mod:`cPickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§ã¯ã€å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ :func:`Pickler` ãŠã‚ˆã³ :func:`Unpickler` ã¯é–¢æ•°ã§ã€ã‚¯ãƒ©ã‚¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šã€pickle åŒ–ã‚„ unpickle åŒ–ã‚’è¡Œã†ã‚«ã‚¹ã‚¿ãƒ ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’æ´¾ç”Ÿã™ã‚‹ã“ã¨ãŒã§ããªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚å¤šãã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã“ã®æ©Ÿèƒ½ã¯ä¸è¦ãªã®ã§ã€ :mod:`cPickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ˆã‚‹å¤§ããªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šã®æ©æµã‚’å—ã‘ã‚‰ã‚Œã‚‹ã¯ãšã§ã™ã€‚"

#: ../../library/pickle.rst:838
msgid ""
"The pickle data stream produced by :mod:`pickle` and :mod:`cPickle` are "
"identical, so it is possible to use :mod:`pickle` and :mod:`cPickle` "
"interchangeably with existing pickles. [#]_"
msgstr ":mod:`pickle` ã¨ :mod:`cPickle` ã§ä½œã‚‰ã‚ŒãŸ pickle ãƒ‡ãƒ¼ã‚¿åˆ—ã¯åŒã˜ãªã®ã§ã€æ—¢å­˜ã® pickle ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ :mod:`pickle` ã¨ :mod:`cPickle` ã‚’äº’æ›ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ [#]_"

#: ../../library/pickle.rst:842
msgid ""
"There are additional minor differences in API between :mod:`cPickle` and "
":mod:`pickle`, however for most applications, they are interchangeable.  "
"More documentation is provided in the :mod:`pickle` module documentation, "
"which includes a list of the documented differences."
msgstr ":mod:`cPickle` ã¨ :mod:`pickle` ã® API é–“ã«ã¯ä»–ã«ã‚‚äº›ç´°ãªç›¸é•ãŒã‚ã‚Šã¾ã™ãŒã€ã»ã¨ã‚“ã©ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§äº’æ›æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã‚ˆã‚Šè©³ç´°ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯ :mod:`pickle` ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚ã‚Šã€ãã“ã§ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŒ–ã•ã‚Œã¦ã„ã‚‹ç›¸é•ç‚¹ã«ã¤ã„ã¦æŒ™ã’ã¦ã„ã¾ã™ã€‚"

#: ../../library/pickle.rst:848
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../library/pickle.rst:849
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr ":mod:`marshal` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨é–“é•ãˆãªã„ã‚ˆã†ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/pickle.rst:851
msgid ""
"In the :mod:`pickle` module these callables are classes, which you could "
"subclass to customize the behavior.  However, in the :mod:`cPickle` module "
"these callables are factory functions and so cannot be subclassed.  One "
"common reason to subclass is to control what objects can actually be "
"unpickled.  See section :ref:`pickle-sub` for more details."
msgstr ":mod:`pickle` ã§ã¯ã€ã“ã‚Œã‚‰ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã—ã¦ãã®å‹•ä½œã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã—ã‹ã—ã€ :mod:`cPickle` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€ã“ã‚Œã‚‰ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ã§ã‚ã‚Šã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã™ã‚‹å…±é€šã®ç†ç”±ã®ä¸€ã¤ã¯ã€ã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿéš›ã« unpickle ã™ã‚‹ã‹ã‚’åˆ¶å¾¡ã™ã‚‹ã“ã¨ã§ã™ã€‚è©³ç´°ã«ã¤ã„ã¦ã¯ :ref:`pickle-sub` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/pickle.rst:857
msgid ""
"*Warning*: this is intended for pickling multiple objects without "
"intervening modifications to the objects or their parts.  If you modify an "
"object and then pickle it again using the same :class:`Pickler` instance, "
"the object is not pickled again --- a reference to it is pickled and the "
":class:`Unpickler` will return the old value, not the modified one. There "
"are two problems here: (1) detecting changes, and (2) marshalling a minimal "
"set of changes.  Garbage Collection may also become a problem here."
msgstr "*è­¦å‘Š*: ã“ã‚Œã¯ã€è¤‡æ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ pickle åŒ–ã™ã‚‹éš›ã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„ãã‚Œã‚‰ã®ä¸€éƒ¨ã«å¯¾ã™ã‚‹å¤‰æ›´ã‚’å¦¨ã’ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®ä»•æ§˜ã§ã™ã€‚ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›´ã‚’åŠ ãˆã¦ã€ãã®å¾ŒåŒã˜ :class:`Pickler` ã‚’ä½¿ã£ã¦å†åº¦ pickle åŒ–ã—ã‚ˆã†ã¨ã—ã¦ã‚‚ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ pickle åŒ–ã—ãªãŠã•ã‚Œã¾ã›ã‚“ --- ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å‚ç…§ãŒ pickle åŒ–ã•ã‚Œã€ :class:`Unpickler` ã¯å¤‰æ›´ã•ã‚ŒãŸå€¤ã§ã¯ãªãã€å…ƒã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã«ã¯ 2 ã¤ã®å•é¡Œç‚¹ : (1) å¤‰æ›´ã®æ¤œå‡ºã€ãã—ã¦ (2) æœ€å°é™ã®å¤‰æ›´ã‚’æ•´åˆ—åŒ–ã™ã‚‹ã“ã¨ã€ãŒã‚ã‚Šã¾ã™ã€‚ã‚¬ãƒ¼ãƒ™ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚‚ã¾ãŸå•é¡Œã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/pickle.rst:865
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an "
":exc:`AttributeError` but it could be something else."
msgstr "é€å‡ºã•ã‚Œã‚‹ä¾‹å¤–ã¯ :exc:`ImportError` ã‚„ :exc:`AttributeError` ã«ãªã‚‹ã¯ãšã§ã™ãŒã€ä»–ã®ä¾‹å¤–ã‚‚èµ·ã“ã‚Šãˆã¾ã™ã€‚"

#: ../../library/pickle.rst:868
msgid "These methods can also be used to implement copying class instances."
msgstr "ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚³ãƒ”ãƒ¼ã‚’å®Ÿè£…ã™ã‚‹éš›ã«ã‚‚ç”¨ã„ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:870
msgid ""
"This protocol is also used by the shallow and deep copying operations "
"defined in the :mod:`copy` module."
msgstr "ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ã¾ãŸã€ :mod:`copy` ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹æµ…ã„ã‚³ãƒ”ãƒ¼ã‚„æ·±ã„ã‚³ãƒ”ãƒ¼æ“ä½œã§ã‚‚ç”¨ã„ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/pickle.rst:873
msgid ""
"The actual mechanism for associating these user defined functions is "
"slightly different for :mod:`pickle` and :mod:`cPickle`.  The description "
"given here works the same for both implementations.  Users of the "
":mod:`pickle` module could also use subclassing to effect the same results, "
"overriding the :meth:`persistent_id` and :meth:`persistent_load` methods in "
"the derived classes."
msgstr "ãƒ¦ãƒ¼ã‚¶å®šç¾©é–¢æ•°ã«é–¢é€£ä»˜ã‘ã‚’è¡Œã†ãŸã‚ã®å®Ÿéš›ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã¯ã€ :mod:`pickle` ãŠã‚ˆã³ :mod:`cPickle` ã§ã¯å°‘ã—ç•°ãªã‚Šã¾ã™ã€‚ :mod:`pickle` ã®ãƒ¦ãƒ¼ã‚¶ã¯ã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã‚’è¡Œã„ã€ :meth:`persistend_id` ãŠã‚ˆã³ :meth:`persistent_load` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¸Šæ›¸ãã™ã‚‹ã“ã¨ã§åŒã˜åŠ¹æœã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/pickle.rst:880
msgid ""
"We'll leave you with the image of Guido and Jim sitting around sniffing "
"pickles in their living rooms."
msgstr "Guide ã¨ Jim ãŒå±…é–“ã«åº§ã‚Šè¾¼ã‚“ã§ãƒ”ã‚¯ãƒ«ã‚¹ (pickles) ã‚’å—…ã„ã§ã„ã‚‹å…‰æ™¯ã‚’æƒ³åƒã—ã¦ãã ã•ã„ã€‚"

#: ../../library/pickle.rst:883
msgid ""
"A word of caution: the mechanisms described here use internal attributes and"
" methods, which are subject to change in future versions of Python.  We "
"intend to someday provide a common interface for controlling this behavior, "
"which will work in either :mod:`pickle` or :mod:`cPickle`."
msgstr "æ³¨æ„ã—ã¦ãã ã•ã„: ã“ã“ã§è¨˜è¿°ã•ã‚Œã¦ã„ã‚‹æ©Ÿæ§‹ã¯å†…éƒ¨ã®å±æ€§ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ãŠã‚Šã€ã“ã‚Œã‚‰ã¯Python ã®å°†æ¥ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§å¤‰æ›´ã•ã‚Œã‚‹å¯¾è±¡ã«ãªã£ã¦ã„ã¾ã™ã€‚ã‚ã‚Œã‚ã‚Œã¯å°†æ¥ã€ã“ã®æŒ™å‹•ã‚’åˆ¶å¾¡ã™ã‚‹ãŸã‚ã®ã€ :mod:`pickle` ãŠã‚ˆã³ :mod:`cPickle` ã®ä¸¡æ–¹ã§å‹•ä½œã™ã‚‹ã€å…±é€šã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã™ã‚‹ã¤ã‚‚ã‚Šã§ã™ã€‚"

#: ../../library/pickle.rst:888
msgid ""
"Since the pickle data format is actually a tiny stack-oriented programming "
"language, and some freedom is taken in the encodings of certain objects, it "
"is possible that the two modules produce different data streams for the same"
" input objects.  However it is guaranteed that they will always be able to "
"read each other's data streams."
msgstr "pickle ãƒ‡ãƒ¼ã‚¿å½¢å¼ã¯å®Ÿéš›ã«ã¯å°è¦æ¨¡ãªã‚¹ã‚¿ãƒƒã‚¯æŒ‡å‘ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨€èªã§ã‚ã‚Šã€ã¾ãŸã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹éš›ã«å¤šå°‘ã®è‡ªç”±åº¦ãŒã‚ã‚‹ãŸã‚ã€äºŒã¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåŒã˜å…¥åŠ›ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ç•°ãªã‚‹ãƒ‡ãƒ¼ã‚¿åˆ—ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚ã—ã‹ã—ã€å¸¸ã«äº’ã„ã«ä»–ã®ãƒ‡ãƒ¼ã‚¿åˆ—ã‚’èª­ã¿å‡ºã›ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã¾ã™ã€‚"
