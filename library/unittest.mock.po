# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Takanori Suzuki <takanori@takanory.net>, 2021
# tomo, 2021
# yuta100101 <yuta07317776@gmail.com>, 2021
# Atsuo Ishimoto <atsuoishimoto@gmail.com>, 2022
# 石井明久, 2024
# Arihiro TAKASE, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-20 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:16+0000\n"
"Last-Translator: Arihiro TAKASE, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/unittest.mock.rst:2
msgid ":mod:`!unittest.mock` --- mock object library"
msgstr ":mod:`!unittest.mock` --- モックオブジェクトライブラリ"

#: ../../library/unittest.mock.rst:12
msgid "**Source code:** :source:`Lib/unittest/mock.py`"
msgstr "**ソースコード:** :source:`Lib/unittest/mock.py`"

#: ../../library/unittest.mock.rst:16
msgid ""
":mod:`unittest.mock` is a library for testing in Python. It allows you to "
"replace parts of your system under test with mock objects and make "
"assertions about how they have been used."
msgstr ""
":mod:`unittest.mock` はPython におけるソフトウェアテストのためのライブラリで"
"す。テスト中のシステムの一部をモックオブジェクトで置き換え、それらがどのよう"
"に使われるかをアサートすることができます。"

#: ../../library/unittest.mock.rst:20
msgid ""
":mod:`unittest.mock` provides a core :class:`Mock` class removing the need "
"to create a host of stubs throughout your test suite. After performing an "
"action, you can make assertions about which methods / attributes were used "
"and arguments they were called with. You can also specify return values and "
"set needed attributes in the normal way."
msgstr ""
":mod:`unittest.mock` はコア :class:`Mock` クラスを提供しており、それによって"
"テストスイート内でたくさんのスタブを作成しなくてすみます 。アクションの実行"
"後、メソッドや属性の使用や実引数についてアサートできます。また通常の方法で戻"
"り値を明記したり、必要な属性を設定することもできます。"

#: ../../library/unittest.mock.rst:26
msgid ""
"Additionally, mock provides a :func:`patch` decorator that handles patching "
"module and class level attributes within the scope of a test, along with :"
"const:`sentinel` for creating unique objects. See the `quick guide`_ for "
"some examples of how to use :class:`Mock`, :class:`MagicMock` and :func:"
"`patch`."
msgstr ""
"加えて、 mock はテストのスコープ内にあるモジュールやクラスの属性を変更する :"
"func:`patch` デコレータを提供します。さらに、ユニークなオブジェクトの作成に"
"は :const:`sentinel` が利用できます。 :class:`Mock` や :class:"
"`MagicMock` 、 :func:`patch` の利用例は `quick guide`_ を参照してください。"

#: ../../library/unittest.mock.rst:32
msgid ""
"Mock is designed for use with :mod:`unittest` and is based on the 'action -> "
"assertion' pattern instead of 'record -> replay' used by many mocking "
"frameworks."
msgstr ""
"Mock は :mod:`unittest` で利用するために設計されており、多くのモックフレーム"
"ワークで使われる 'record -> replay' パターンの代わりに、 'action -> "
"assertion' パターンに基づいています。"

#: ../../library/unittest.mock.rst:36
msgid ""
"There is a backport of :mod:`unittest.mock` for earlier versions of Python, "
"available as :pypi:`mock` on PyPI."
msgstr ""

#: ../../library/unittest.mock.rst:41
msgid "Quick Guide"
msgstr "クイックガイド"

#: ../../library/unittest.mock.rst:59
msgid ""
":class:`Mock` and :class:`MagicMock` objects create all attributes and "
"methods as you access them and store details of how they have been used. You "
"can configure them, to specify return values or limit what attributes are "
"available, and then make assertions about how they have been used:"
msgstr ""
":class:`Mock` および :class:`MagicMock` オブジェクトはアクセスしたすべての属"
"性とメソッドを作成し、どのように使用されたかについての詳細な情報を格納しま"
"す。戻り値を指定したり利用できる属性を制限するために :class:`Mock` および :"
"class:`MagicMock` を設定でき、どのよう使用されたかについてアサートできます:"

#: ../../library/unittest.mock.rst:71
msgid ""
":attr:`side_effect` allows you to perform side effects, including raising an "
"exception when a mock is called:"
msgstr ""
":attr:`side_effect` によって、モック呼び出し時の例外発生などの副作用を実行で"
"きます:"

#: ../../library/unittest.mock.rst:92
msgid ""
"Mock has many other ways you can configure it and control its behaviour. For "
"example the *spec* argument configures the mock to take its specification "
"from another object. Attempting to access attributes or methods on the mock "
"that don't exist on the spec will fail with an :exc:`AttributeError`."
msgstr ""
"モックには多くの設定法や挙動の制御法があります。例えば *spec* 引数によって別"
"のオブジェクトからの仕様を受け取るよう設定できます。 spec にないモックの属性"
"やメソッドにアクセスを試みた場合、 :exc:`AttributeError` で失敗します。"

#: ../../library/unittest.mock.rst:97
msgid ""
"The :func:`patch` decorator / context manager makes it easy to mock classes "
"or objects in a module under test. The object you specify will be replaced "
"with a mock (or other object) during the test and restored when the test "
"ends::"
msgstr ""
":func:`patch` デコレータ / コンテキストマネージャーによってテスト対象のモ"
"ジュール内のクラスやオブジェクトを簡単にモックできます。指定したオブジェクト"
"はテスト中はモック (または別のオブジェクト) に置換され、テスト終了時に復元さ"
"れます::"

#: ../../library/unittest.mock.rst:101
msgid ""
">>> from unittest.mock import patch\n"
">>> @patch('module.ClassName2')\n"
"... @patch('module.ClassName1')\n"
"... def test(MockClass1, MockClass2):\n"
"...     module.ClassName1()\n"
"...     module.ClassName2()\n"
"...     assert MockClass1 is module.ClassName1\n"
"...     assert MockClass2 is module.ClassName2\n"
"...     assert MockClass1.called\n"
"...     assert MockClass2.called\n"
"...\n"
">>> test()"
msgstr ""

#: ../../library/unittest.mock.rst:116
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``module.ClassName1`` is passed in first."
msgstr ""
"patch デコレータをネストした場合、モックは適用されるときと同じ順番 (デコレー"
"タを適用するときの通常の *Python* の順番) でデコレートされた関数に渡されま"
"す。 つまり下から順に適用されるため、上の例では ``module.ClassName1`` のモッ"
"クが最初に渡されます。"

#: ../../library/unittest.mock.rst:121
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
":func:`patch` では探索される名前空間内のオブジェクトにパッチをあてることが重"
"要です。通常は単純ですが、クイックガイドには :ref:`where-to-patch` を読んでく"
"ださい。"

#: ../../library/unittest.mock.rst:125
msgid ""
"As well as a decorator :func:`patch` can be used as a context manager in a "
"with statement:"
msgstr ""
":func:`patch` デコレータと同様に with 文でコンテキストマネージャーとして使用"
"できます:"

#: ../../library/unittest.mock.rst:135
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr ""
"また、 :func:`patch.dict` を使うと、スコープ内だけで辞書に値を設定し、テスト"
"終了時には元の状態に復元されます:"

#: ../../library/unittest.mock.rst:146
msgid ""
"Mock supports the mocking of Python :ref:`magic methods <magic-methods>`. "
"The easiest way of using magic methods is with the :class:`MagicMock` class. "
"It allows you to do things like:"
msgstr ""
"mock は Python の :ref:`マジックメソッド <magic-methods>` のモックをサポート"
"しています。 マジックメソッドのもっとも簡単な利用法は :class:`MagicMock` クラ"
"スと使うことです。以下のように利用します:"

#: ../../library/unittest.mock.rst:156
msgid ""
"Mock allows you to assign functions (or other Mock instances) to magic "
"methods and they will be called appropriately. The :class:`MagicMock` class "
"is just a Mock variant that has all of the magic methods pre-created for you "
"(well, all the useful ones anyway)."
msgstr ""
"mock によってマジックメソッドに関数 (あるいは他の Mock インスタンス) を割り当"
"てることができ、それらは適切に呼び出されます。\n"
":class:`MagicMock` クラスは、すべてのマジックメソッドがあらかじめ作成されてい"
"る点を除けば :class:`Mock` クラスと一緒です (まあ、とにかく便利ってこと)。"

#: ../../library/unittest.mock.rst:161
msgid ""
"The following is an example of using magic methods with the ordinary Mock "
"class:"
msgstr "以下は通常の Mock クラスでマジックメソッドを利用する例です:"

#: ../../library/unittest.mock.rst:169
msgid ""
"For ensuring that the mock objects in your tests have the same api as the "
"objects they are replacing, you can use :ref:`auto-speccing <auto-"
"speccing>`. Auto-speccing can be done through the *autospec* argument to "
"patch, or the :func:`create_autospec` function. Auto-speccing creates mock "
"objects that have the same attributes and methods as the objects they are "
"replacing, and any functions and methods (including constructors) have the "
"same call signature as the real object."
msgstr ""
"テスト内のモックオブジェクトが置換するオブジェクトと同じ API を持つことを保証"
"するには、 :ref:`auto-speccing <auto-speccing>` を使うことができます。パッチ"
"をあてる *autospec* 引数、または :func:`create_autospec` 関数を通じて auto-"
"speccing は行われます。\n"
"auto-speccing は置換するオブジェクトと同じ属性とメソッドを持つモックオブジェ"
"クトを作成し、すべての関数および (コンストラクタを含む) メソッドは本物のオブ"
"ジェクトと同じ呼び出しシグネチャを持ちます。"

#: ../../library/unittest.mock.rst:177
msgid ""
"This ensures that your mocks will fail in the same way as your production "
"code if they are used incorrectly:"
msgstr ""
"誤って使用された場合、モックは製品コードと同じように失敗されることが保証され"
"ています:"

#: ../../library/unittest.mock.rst:193
msgid ""
":func:`create_autospec` can also be used on classes, where it copies the "
"signature of the ``__init__`` method, and on callable objects where it "
"copies the signature of the ``__call__`` method."
msgstr ""
":func:`create_autospec` はクラスにおいても利用でき、 ``__init__`` メソッドの"
"シグニチャをコピーします。また、呼び出し可能オブジェクトについても "
"``__call__``  メソッドのシグニチャをコピーします。"

#: ../../library/unittest.mock.rst:200
msgid "The Mock Class"
msgstr "Mock クラス"

#: ../../library/unittest.mock.rst:213
msgid ""
":class:`Mock` is a flexible mock object intended to replace the use of stubs "
"and test doubles throughout your code. Mocks are callable and create "
"attributes as new mocks when you access them [#]_. Accessing the same "
"attribute will always return the same mock. Mocks record how you use them, "
"allowing you to make assertions about what your code has done to them."
msgstr ""
":class:`Mock` は、コードにおけるスタブの使用やテストダブルを置き換えるための"
"柔軟なモックオブジェクトです。モックは呼び出し可能で、属性にアクセスした場合"
"それを新たなモックとして作成します [#]_。同じ属性にアクセスした場合は常に同じ"
"モックを返します。\n"
"モックはどのように使われたかを記録するので、コードがモックに行うことについて"
"アサートできます。"

#: ../../library/unittest.mock.rst:219
msgid ""
":class:`MagicMock` is a subclass of :class:`Mock` with all the magic methods "
"pre-created and ready to use. There are also non-callable variants, useful "
"when you are mocking out objects that aren't callable: :class:"
"`NonCallableMock` and :class:`NonCallableMagicMock`"
msgstr ""
":class:`MagicMock` は :class:`Mock` のサブクラスで、すべてのマジックメソッド"
"が事前に作成され、利用できます。また、呼び出し不可能なモックを作成する場合に"
"は、呼び出し不能な変種の :class:`NonCallableMock` や :class:"
"`NonCallableMagicMock` があります。"

#: ../../library/unittest.mock.rst:224
msgid ""
"The :func:`patch` decorators makes it easy to temporarily replace classes in "
"a particular module with a :class:`Mock` object. By default :func:`patch` "
"will create a :class:`MagicMock` for you. You can specify an alternative "
"class of :class:`Mock` using the *new_callable* argument to :func:`patch`."
msgstr ""
":func:`patch` デコレータによって特定のモジュール内のクラスを :class:`Mock` オ"
"ブジェクトで一時的に置換することが簡単にできます。デフォルトでは :func:"
"`patch` は :class:`MagicMock` を作成します。 :func:`patch` に渡す "
"*new_callable* 引数によって、別の :class:`Mock` クラスを指定できます。"

#: ../../library/unittest.mock.rst:232
msgid ""
"Create a new :class:`Mock` object. :class:`Mock` takes several optional "
"arguments that specify the behaviour of the Mock object:"
msgstr ""
"新しい :class:`Mock` オブジェクトを作成します。 :class:`Mock` はモックオブ"
"ジェクトの挙動を指定するオプション引数をいくつか取ります:"

#: ../../library/unittest.mock.rst:235
msgid ""
"*spec*: This can be either a list of strings or an existing object (a class "
"or instance) that acts as the specification for the mock object. If you pass "
"in an object then a list of strings is formed by calling dir on the object "
"(excluding unsupported magic attributes and methods). Accessing any "
"attribute not in this list will raise an :exc:`AttributeError`."
msgstr ""
"*spec*: モックオブジェクトの仕様として働く文字列のリストもしくは存在するオブ"
"ジェクト (クラスもしくはインスタンス) を指定します。オブジェクトを渡した場合"
"には、 dir 関数によって文字列のリストが生成されます (サポートされない特殊属性"
"や特殊メソッドは除く) 。このリストにない属性にアクセスした際には  :exc:"
"`AttributeError` が発生します。"

#: ../../library/unittest.mock.rst:241
msgid ""
"If *spec* is an object (rather than a list of strings) then :attr:`~instance."
"__class__` returns the class of the spec object. This allows mocks to pass :"
"func:`isinstance` tests."
msgstr ""
"*spec* が (文字列のリストではなく) オブジェクトの場合、 :attr:`~instance."
"__class__` はスペックオブジェクトのクラスを返します。これによってモックが :"
"func:`isinstance` テストに通るようになります。"

#: ../../library/unittest.mock.rst:245
msgid ""
"*spec_set*: A stricter variant of *spec*. If used, attempting to *set* or "
"get an attribute on the mock that isn't on the object passed as *spec_set* "
"will raise an :exc:`AttributeError`."
msgstr ""
"*spec_set*: より厳しい *spec* です。こちらを利用した場合、 *spec_set* に渡さ"
"れたオブジェクトに存在しない属性に対し *設定* や取得をしようとした際に :exc:"
"`AttributeError` が発生します。"

#: ../../library/unittest.mock.rst:249
msgid ""
"*side_effect*: A function to be called whenever the Mock is called. See the :"
"attr:`~Mock.side_effect` attribute. Useful for raising exceptions or "
"dynamically changing return values. The function is called with the same "
"arguments as the mock, and unless it returns :data:`DEFAULT`, the return "
"value of this function is used as the return value."
msgstr ""
"*side_effect*: モックが呼び出された際に呼び出される関数を指定します。 :attr:"
"`~Mock.side_effect` 属性を参考にしてください。例外を発生させたり、動的に戻り"
"値を変更する場合に便利です。関数には、モックと同じ引数が渡され、 :data:"
"`DEFAULT` を返さない限りはこの関数の戻り値が使われます。"

#: ../../library/unittest.mock.rst:255
msgid ""
"Alternatively *side_effect* can be an exception class or instance. In this "
"case the exception will be raised when the mock is called."
msgstr ""
"一方で、 *side_effect* には、例外クラスやインスタンスを指定できます。この場合"
"は、モックが呼び出された際に指定された例外を発生します。"

#: ../../library/unittest.mock.rst:258
msgid ""
"If *side_effect* is an iterable then each call to the mock will return the "
"next value from the iterable."
msgstr ""
"もし、 *side_effect* にイテレート可能オブジェクトを指定した場合には、モックの"
"呼び出しごとに順に値を返します。"

#: ../../library/unittest.mock.rst:261
msgid "A *side_effect* can be cleared by setting it to ``None``."
msgstr "*side_effect* に ``None`` を指定した場合には、設定がクリアされます。"

#: ../../library/unittest.mock.rst:263
msgid ""
"*return_value*: The value returned when the mock is called. By default this "
"is a new Mock (created on first access). See the :attr:`return_value` "
"attribute."
msgstr ""
"*return_value*: モックが呼び出された際に返す値です。デフォルトでは (最初にア"
"クセスされた際に生成される) 新しい Mock を返します。 :attr:`return_value` を"
"参照してください。"

#: ../../library/unittest.mock.rst:267
msgid ""
"*unsafe*: By default, accessing any attribute whose name starts with "
"*assert*, *assret*, *asert*, *aseert* or *assrt* will raise an :exc:"
"`AttributeError`. Passing ``unsafe=True`` will allow access to these "
"attributes."
msgstr ""

#: ../../library/unittest.mock.rst:274
msgid ""
"*wraps*: Item for the mock object to wrap. If *wraps* is not ``None`` then "
"calling the Mock will pass the call through to the wrapped object (returning "
"the real result). Attribute access on the mock will return a Mock object "
"that wraps the corresponding attribute of the wrapped object (so attempting "
"to access an attribute that doesn't exist will raise an :exc:"
"`AttributeError`)."
msgstr ""
"*wraps*: このモックオブジェクトがラップするものです。 *wraps* が ``None`` で"
"なければ、このモックを呼び出すと、その呼び出しがラップされたオブジェクトに渡"
"され (て実際の結果を返し) ます。モックの属性アクセスは、ラップされたオブジェ"
"クトの対応する属性をラップする Mock オブジェクトを返します (なので、存在しな"
"い属性にアクセスしようとすると :exc:`AttributeError` を送出します)。"

#: ../../library/unittest.mock.rst:281
msgid ""
"If the mock has an explicit *return_value* set then calls are not passed to "
"the wrapped object and the *return_value* is returned instead."
msgstr ""
"モックが明示的に *return_value* を設定されていると、呼び出しはラップされたオ"
"ブジェクトに渡されず、代わりに *return_value* が返されます。"

#: ../../library/unittest.mock.rst:284
msgid ""
"*name*: If the mock has a name then it will be used in the repr of the mock. "
"This can be useful for debugging. The name is propagated to child mocks."
msgstr ""
"*name*: モックに名前があるなら、それがモックの repr として使われます。これは"
"デバッグの際に役立つでしょう。この名前は子のモックにも伝播します。"

#: ../../library/unittest.mock.rst:288
msgid ""
"Mocks can also be called with arbitrary keyword arguments. These will be "
"used to set attributes on the mock after it is created. See the :meth:"
"`configure_mock` method for details."
msgstr ""
"モックは、任意のキーワード引数を与えることができます。これらはモックの生成"
"後、属性の設定に使われます。詳細は :meth:`configure_mock` を参照してくださ"
"い。"

#: ../../library/unittest.mock.rst:294
msgid "Assert that the mock was called at least once."
msgstr "モックが少なくとも一度は呼び出されたことをアサートします。"

#: ../../library/unittest.mock.rst:305
msgid "Assert that the mock was called exactly once."
msgstr "モックが一度だけ呼び出されたことをアサートします。"

#: ../../library/unittest.mock.rst:324
msgid ""
"This method is a convenient way of asserting that the last call has been "
"made in a particular way:"
msgstr ""

#: ../../library/unittest.mock.rst:334
msgid ""
"Assert that the mock was called exactly once and that call was with the "
"specified arguments."
msgstr ""
"モックが一度だけ呼び出され、かつ指定された引数で呼び出されたことをアサートし"
"ます。"

#: ../../library/unittest.mock.rst:349
msgid "assert the mock has been called with the specified arguments."
msgstr "モックが特定の引数で呼び出されたことがあるのをアサートします。"

#: ../../library/unittest.mock.rst:351
msgid ""
"The assert passes if the mock has *ever* been called, unlike :meth:"
"`assert_called_with` and :meth:`assert_called_once_with` that only pass if "
"the call is the most recent one, and in the case of :meth:"
"`assert_called_once_with` it must also be the only call."
msgstr ""

#: ../../library/unittest.mock.rst:364
msgid ""
"assert the mock has been called with the specified calls. The :attr:"
"`mock_calls` list is checked for the calls."
msgstr ""
"モックが特定の呼び出しで呼ばれたことをアサートします。呼び出しでは :attr:"
"`mock_calls` のリストがチェックされます。"

#: ../../library/unittest.mock.rst:367
msgid ""
"If *any_order* is false then the calls must be sequential. There can be "
"extra calls before or after the specified calls."
msgstr ""
"*any_order* が false の場合、呼び出しは連続していなければなりません。指定され"
"た呼び出しの前、あるいは呼び出しの後に余分な呼び出しがある場合があります。"

#: ../../library/unittest.mock.rst:371
msgid ""
"If *any_order* is true then the calls can be in any order, but they must all "
"appear in :attr:`mock_calls`."
msgstr ""
"*any_order* が true の場合、呼び出しは任意の順番でも構いませんが、それらがす"
"べて :attr:`mock_calls` に現われなければなりません。"

#: ../../library/unittest.mock.rst:386
msgid "Assert the mock was never called."
msgstr "モックが一度も呼ばれなかったことをアサートします。"

#: ../../library/unittest.mock.rst:402
msgid "The reset_mock method resets all the call attributes on a mock object:"
msgstr "モックオブジェクトのすべての呼び出し属性をリセットします:"

#: ../../library/unittest.mock.rst:412
msgid "Added two keyword-only arguments to the reset_mock function."
msgstr "2つのキーワード専用引数が reset_mock 関数に追加されました。"

#: ../../library/unittest.mock.rst:415
msgid ""
"This can be useful where you want to make a series of assertions that reuse "
"the same object. Note that :meth:`reset_mock` *doesn't* clear the :attr:"
"`return_value`, :attr:`side_effect` or any child attributes you have set "
"using normal assignment by default. In case you want to reset :attr:"
"`return_value` or :attr:`side_effect`, then pass the corresponding parameter "
"as ``True``. Child mocks and the return value mock (if any) are reset as "
"well."
msgstr ""

#: ../../library/unittest.mock.rst:423
msgid "*return_value*, and *side_effect* are keyword-only arguments."
msgstr ""

#: ../../library/unittest.mock.rst:429
msgid ""
"Add a spec to a mock. *spec* can either be an object or a list of strings. "
"Only attributes on the *spec* can be fetched as attributes from the mock."
msgstr ""
"モックに仕様を追加します。 *spec* にはオブジェクトもしくは文字列のリストを指"
"定してください。 *spec* で設定した属性は、モックの属性としてのみアクセスでき"
"ます。"

#: ../../library/unittest.mock.rst:433
msgid "If *spec_set* is true then only attributes on the spec can be set."
msgstr "*spec_set* が真なら、 spec 以外の属性は設定できません。"

#: ../../library/unittest.mock.rst:438
msgid ""
"Attach a mock as an attribute of this one, replacing its name and parent. "
"Calls to the attached mock will be recorded in the :attr:`method_calls` and :"
"attr:`mock_calls` attributes of this one."
msgstr ""
"属性として mock を設定して、その名前と親を入れ替えます。設定されたモックの呼"
"び出しは、 :attr:`method_calls` や :attr:`mock_calls` 属性に記録されます。"

#: ../../library/unittest.mock.rst:445
msgid "Set attributes on the mock through keyword arguments."
msgstr "モックの属性をキーワード引数で設定します。"

#: ../../library/unittest.mock.rst:447
msgid ""
"Attributes plus return values and side effects can be set on child mocks "
"using standard dot notation and unpacking a dictionary in the method call:"
msgstr ""
"属性に加え、子の戻り値や副作用もドット表記を用いて設定でき、辞書はメソッドの"
"呼び出し時にアンパックされます:"

#: ../../library/unittest.mock.rst:461
msgid "The same thing can be achieved in the constructor call to mocks:"
msgstr "コンストラクタの呼び出しでも同様に行うことができます:"

#: ../../library/unittest.mock.rst:474
msgid ""
":meth:`configure_mock` exists to make it easier to do configuration after "
"the mock has been created."
msgstr ""
":meth:`configure_mock` は、モック生成後のコンフィギュレーションを容易に行うた"
"めに存在します。"

#: ../../library/unittest.mock.rst:480
msgid ""
":class:`Mock` objects limit the results of ``dir(some_mock)`` to useful "
"results. For mocks with a *spec* this includes all the permitted attributes "
"for the mock."
msgstr ""
":class:`Mock` オブジェクトは、有用な結果を得るために ``dir(some_mock)`` の結"
"果を制限します。 *spec* を設定したモックに対しては、許可された属性のみを含み"
"ます。"

#: ../../library/unittest.mock.rst:484
msgid ""
"See :data:`FILTER_DIR` for what this filtering does, and how to switch it "
"off."
msgstr ""
"このフィルタが何をしていて、どのように停止させるかは、 :data:`FILTER_DIR` を"
"参照してください。"

#: ../../library/unittest.mock.rst:490
msgid ""
"Create the child mocks for attributes and return value. By default child "
"mocks will be the same type as the parent. Subclasses of Mock may want to "
"override this to customize the way child mocks are made."
msgstr ""
"子のモックを作成し、その値を返すようにしてください。デフォルトでは親と同じタ"
"イプで作成されます。サブクラスで子モックの作成される方法をカスタマイズしたい"
"場合には、このメソッドをオーバーライドします。"

#: ../../library/unittest.mock.rst:495
msgid ""
"For non-callable mocks the callable variant will be used (rather than any "
"custom subclass)."
msgstr ""
"呼び出し不可能なモックに対しては、(カスタムのサブクラスではなく) 呼び出し可能"
"なモックが使われます。"

#: ../../library/unittest.mock.rst:501
msgid "A boolean representing whether or not the mock object has been called:"
msgstr "このモックが呼び出されたかどうかを表します:"

#: ../../library/unittest.mock.rst:512
msgid "An integer telling you how many times the mock object has been called:"
msgstr "このモックオブジェクトが呼び出された回数を返します:"

#: ../../library/unittest.mock.rst:524
msgid "Set this to configure the value returned by calling the mock:"
msgstr "モックが呼び出された際に返す値を設定します:"

#: ../../library/unittest.mock.rst:531
msgid ""
"The default return value is a mock object and you can configure it in the "
"normal way:"
msgstr ""
"デフォルトの戻り値はモックオブジェクトです。通常の方法で設定することもできま"
"す:"

#: ../../library/unittest.mock.rst:540
msgid ":attr:`return_value` can also be set in the constructor:"
msgstr ":attr:`return_value` は生成時にも設定可能です:"

#: ../../library/unittest.mock.rst:551
msgid ""
"This can either be a function to be called when the mock is called, an "
"iterable or an exception (class or instance) to be raised."
msgstr ""
"このモックが呼ばれた際に呼び出される関数、イテラブル、もしくは発生させる例外 "
"(クラスまたはインスタンス) を設定できます。"

#: ../../library/unittest.mock.rst:554
msgid ""
"If you pass in a function it will be called with same arguments as the mock "
"and unless the function returns the :data:`DEFAULT` singleton the call to "
"the mock will then return whatever the function returns. If the function "
"returns :data:`DEFAULT` then the mock will return its normal value (from "
"the :attr:`return_value`)."
msgstr ""
"関数を渡した場合はモックと同じ引数で呼び出され、 :data:`DEFAULT` を返さない限"
"りはその関数の戻り値が返されます。関数が :data:`DEFAULT` を返した場合は ( :"
"attr:`return_value` によって) モックの通常の値を返します。"

#: ../../library/unittest.mock.rst:560
msgid ""
"If you pass in an iterable, it is used to retrieve an iterator which must "
"yield a value on every call.  This value can either be an exception instance "
"to be raised, or a value to be returned from the call to the mock (:data:"
"`DEFAULT` handling is identical to the function case)."
msgstr ""
"iterable が渡された場合、その値はイテレータを取り出すために使用されます。イテ"
"レータは毎回の呼び出しにおいて値を yield しなければなりません。この値は、送出"
"される例外インスタンスか、呼び出しからモックに返される値のいずれかです (:"
"data:`DEFAULT` の処理は関数の場合と同一です)。"

#: ../../library/unittest.mock.rst:565
msgid ""
"An example of a mock that raises an exception (to test exception handling of "
"an API):"
msgstr ""
"以下はモックが (API による例外の扱いをテストするために) 例外を発生させる例で"
"す:"

#: ../../library/unittest.mock.rst:575
msgid "Using :attr:`side_effect` to return a sequence of values:"
msgstr ":attr:`side_effect` を使用して連続的に値を返します:"

#: ../../library/unittest.mock.rst:582
msgid "Using a callable:"
msgstr "呼び出し可能オブジェクトを使います:"

#: ../../library/unittest.mock.rst:592
msgid ""
":attr:`side_effect` can be set in the constructor. Here's an example that "
"adds one to the value the mock is called with and returns it:"
msgstr ""
":attr:`side_effect` は生成時にも設定可能です。呼び出し時の値に 1 を加えて返す"
"例を以下に示します:"

#: ../../library/unittest.mock.rst:602
msgid "Setting :attr:`side_effect` to ``None`` clears it:"
msgstr ":attr:`side_effect` に ``None`` を設定した場合はクリアされます:"

#: ../../library/unittest.mock.rst:616
msgid ""
"This is either ``None`` (if the mock hasn't been called), or the arguments "
"that the mock was last called with. This will be in the form of a tuple: the "
"first member, which can also be accessed through the ``args`` property, is "
"any ordered arguments the mock was called with (or an empty tuple) and the "
"second member, which can also be accessed through the ``kwargs`` property, "
"is any keyword arguments (or an empty dictionary)."
msgstr ""

#: ../../library/unittest.mock.rst:649
msgid ""
":attr:`call_args`, along with members of the lists :attr:`call_args_list`, :"
"attr:`method_calls` and :attr:`mock_calls` are :data:`call` objects. These "
"are tuples, so they can be unpacked to get at the individual arguments and "
"make more complex assertions. See :ref:`calls as tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args` は、 :attr:`call_args_list` や :attr:`method_calls` 、 :"
"attr:`mock_calls` と同様、 :data:`call` オブジェクトです。これらはタプルとし"
"てアンパックすることで個別に取り出すことができます。そして、より複雑なアサー"
"ションを行うことができます。 :ref:`calls as tuples <calls-as-tuples>` を参照"
"してください。"

#: ../../library/unittest.mock.rst:655
msgid "Added ``args`` and ``kwargs`` properties."
msgstr "``args`` と ``kwargs`` 属性が追加されました。"

#: ../../library/unittest.mock.rst:661
msgid ""
"This is a list of all the calls made to the mock object in sequence (so the "
"length of the list is the number of times it has been called). Before any "
"calls have been made it is an empty list. The :data:`call` object can be "
"used for conveniently constructing lists of calls to compare with :attr:"
"`call_args_list`."
msgstr ""
"モックの呼び出しを順に記録したリストです (よって、このリストの長さはモックが"
"呼び出された回数と等しくなります)。モックを作成してから一度も呼び出しを行なっ"
"ていない場合は、空のリストが返されます。 :data:`call` オブジェクトは、 :attr:"
"`call_args_list` の比較対象となる呼び出しのリストを作成する際に便利です。"

#: ../../library/unittest.mock.rst:677
msgid ""
"Members of :attr:`call_args_list` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args_list` のメンバは :data:`call` オブジェクトです。タプルとして"
"アンパックすることで個別に取り出すことができます。 :ref:`calls as tuples "
"<calls-as-tuples>` を参照してください。"

#: ../../library/unittest.mock.rst:684
msgid ""
"As well as tracking calls to themselves, mocks also track calls to methods "
"and attributes, and *their* methods and attributes:"
msgstr ""
"自身の呼び出しと同様に、モックはメソッドや属性、そして *それらの* メソッドや"
"属性の呼び出しも追跡します:"

#: ../../library/unittest.mock.rst:695
msgid ""
"Members of :attr:`method_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
":attr:`method_calls` のメンバは :data:`call` オブジェクトです。タプルとしてア"
"ンパックすることで個別に取り出すことができます。 :ref:`calls as tuples "
"<calls-as-tuples>` を参照してください。"

#: ../../library/unittest.mock.rst:702
msgid ""
":attr:`mock_calls` records *all* calls to the mock object, its methods, "
"magic methods *and* return value mocks."
msgstr ""
":attr:`mock_calls` は、メソッド、特殊メソッド、 *そして* 戻り値のモックまで、"
"モックオブジェクトに対する *すべての* 呼び出しを記録します。"

#: ../../library/unittest.mock.rst:720
msgid ""
"Members of :attr:`mock_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
":attr:`mock_calls` のメンバは :data:`call` オブジェクトです。タプルとしてアン"
"パックすることで個別に取り出すことができます。 :ref:`calls as tuples <calls-"
"as-tuples>` を参照してください。"

#: ../../library/unittest.mock.rst:726
msgid ""
"The way :attr:`mock_calls` are recorded means that where nested calls are "
"made, the parameters of ancestor calls are not recorded and so will always "
"compare equal:"
msgstr ""

#: ../../library/unittest.mock.rst:740
msgid ""
"Normally the :attr:`__class__` attribute of an object will return its type. "
"For a mock object with a :attr:`spec`, ``__class__`` returns the spec class "
"instead. This allows mock objects to pass :func:`isinstance` tests for the "
"object they are replacing / masquerading as:"
msgstr ""
"通常、オブジェクトの :attr:`__class__` 属性はその型を返します。 :attr:`spec` "
"を設定したオブジェクトの場合、 ``__class__`` は代わりに :attr:`spec` のクラス"
"を返します。これにより、置き換え / 偽装しているオブジェクトに対する :func:"
"`isinstance` も通過することができます:"

#: ../../library/unittest.mock.rst:749
msgid ""
":attr:`__class__` is assignable to, this allows a mock to pass an :func:"
"`isinstance` check without forcing you to use a spec:"
msgstr ""
":attr:`__class__` は書き換え可能で、 :func:`isinstance` を通るために必ず "
"spec を使う必要はありません:"

#: ../../library/unittest.mock.rst:759
msgid ""
"A non-callable version of :class:`Mock`. The constructor parameters have the "
"same meaning of :class:`Mock`, with the exception of *return_value* and "
"*side_effect* which have no meaning on a non-callable mock."
msgstr ""
"呼び出しができない :class:`Mock` です。コンストラクタのパラメータは :class:"
"`Mock` と同様ですが、 *return_value* や *side_effect* は意味を持ちません。"

#: ../../library/unittest.mock.rst:763
msgid ""
"Mock objects that use a class or an instance as a :attr:`spec` or :attr:"
"`spec_set` are able to pass :func:`isinstance` tests:"
msgstr ""
":attr:`spec` か :attr:`spec_set` にクラスかインスタンスを渡した mock は :"
"func:`isinstance` テストをパスします:"

#: ../../library/unittest.mock.rst:773
msgid ""
"The :class:`Mock` classes have support for mocking magic methods. See :ref:"
"`magic methods <magic-methods>` for the full details."
msgstr ""
":class:`Mock` クラスは、 特殊メソッドをサポートしています。すべての詳細は :"
"ref:`magic methods <magic-methods>` を参照してください。"

#: ../../library/unittest.mock.rst:776
msgid ""
"The mock classes and the :func:`patch` decorators all take arbitrary keyword "
"arguments for configuration. For the :func:`patch` decorators the keywords "
"are passed to the constructor of the mock being created. The keyword "
"arguments are for configuring attributes of the mock:"
msgstr ""
"モッククラスや :func:`patch` デコレータは、任意のキーワード引数を設定できま"
"す。 :func:`patch` デコレータへのキーワード引数は、モックが作られる際のコンス"
"トラクタに渡されます。キーワード引数は、モックの属性を設定します:"

#: ../../library/unittest.mock.rst:787
msgid ""
"The return value and side effect of child mocks can be set in the same way, "
"using dotted notation. As you can't use dotted names directly in a call you "
"have to create a dictionary and unpack it using ``**``:"
msgstr ""
"子の戻り値や副作用も、ドットで表記することで同様に設定できます。呼び出し時に"
"直接ドットのついた名前を使用できないので、作成した辞書を ``**`` でアンパック"
"する必要があります:"

#: ../../library/unittest.mock.rst:802
msgid ""
"A callable mock which was created with a *spec* (or a *spec_set*) will "
"introspect the specification object's signature when matching calls to the "
"mock.  Therefore, it can match the actual call's arguments regardless of "
"whether they were passed positionally or by name::"
msgstr ""
"*spec* (または *spec_set*) によって作成された呼び出し可能なモックは、モックへ"
"の呼び出しがマッチしたときに仕様オブジェクトのシグネチャを内省します。した"
"がって、引数を位置引数として渡したか名前で渡したかどうかに関わらず、実際の呼"
"び出しの引数とマッチすることができます::"

#: ../../library/unittest.mock.rst:807
msgid ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, c=3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(1, 2, 3)\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"
msgstr ""

#: ../../library/unittest.mock.rst:815
msgid ""
"This applies to :meth:`~Mock.assert_called_with`, :meth:`~Mock."
"assert_called_once_with`, :meth:`~Mock.assert_has_calls` and :meth:`~Mock."
"assert_any_call`.  When :ref:`auto-speccing`, it will also apply to method "
"calls on the mock object."
msgstr ""
"これは :meth:`~Mock.assert_called_with`, :meth:`~Mock."
"assert_called_once_with`, :meth:`~Mock.assert_has_calls` and :meth:`~Mock."
"assert_any_call` にも適用されます。 :ref:`auto-speccing` と、 モックオブジェ"
"クトのメソッド呼び出しにも適用されます。"

#: ../../library/unittest.mock.rst:820
msgid "Added signature introspection on specced and autospecced mock objects."
msgstr ""
"spec や autospec を用いて生成されたモックオブジェクトは、シグネチャを考慮する"
"ようになりました。"

#: ../../library/unittest.mock.rst:826
msgid ""
"A mock intended to be used as a :class:`property`, or other :term:"
"`descriptor`, on a class. :class:`PropertyMock` provides :meth:`~object."
"__get__` and :meth:`~object.__set__` methods so you can specify a return "
"value when it is fetched."
msgstr ""

#: ../../library/unittest.mock.rst:831
msgid ""
"Fetching a :class:`PropertyMock` instance from an object calls the mock, "
"with no args. Setting it calls the mock with the value being set. ::"
msgstr ""
"オブジェクトから :class:`PropertyMock` のインスタンスを取得することは、引数を"
"与えないモックの呼び出しに相当します。設定は、 設定する値を伴った呼び出しにな"
"ります。::"

#: ../../library/unittest.mock.rst:834
msgid ""
">>> class Foo:\n"
"...     @property\n"
"...     def foo(self):\n"
"...         return 'something'\n"
"...     @foo.setter\n"
"...     def foo(self, value):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Foo.foo', new_callable=PropertyMock) as mock_foo:\n"
"...     mock_foo.return_value = 'mockity-mock'\n"
"...     this_foo = Foo()\n"
"...     print(this_foo.foo)\n"
"...     this_foo.foo = 6\n"
"...\n"
"mockity-mock\n"
">>> mock_foo.mock_calls\n"
"[call(), call(6)]"
msgstr ""

#: ../../library/unittest.mock.rst:852
msgid ""
"Because of the way mock attributes are stored you can't directly attach a :"
"class:`PropertyMock` to a mock object. Instead you can attach it to the mock "
"type object::"
msgstr ""
":class:`PropertyMock` を直接モックに取り付ける方法は、モックの属性を保存する"
"方法によりうまく動作しません。代わりに、モック型に取り付けてください::"

#: ../../library/unittest.mock.rst:856
msgid ""
">>> m = MagicMock()\n"
">>> p = PropertyMock(return_value=3)\n"
">>> type(m).foo = p\n"
">>> m.foo\n"
"3\n"
">>> p.assert_called_once_with()"
msgstr ""

#: ../../library/unittest.mock.rst:865
msgid ""
"If an :exc:`AttributeError` is raised by :class:`PropertyMock`, it will be "
"interpreted as a missing descriptor and :meth:`~object.__getattr__` will be "
"called on the parent mock::"
msgstr ""

#: ../../library/unittest.mock.rst:869
msgid ""
">>> m = MagicMock()\n"
">>> no_attribute = PropertyMock(side_effect=AttributeError)\n"
">>> type(m).my_property = no_attribute\n"
">>> m.my_property\n"
"<MagicMock name='mock.my_property' id='140165240345424'>"
msgstr ""

#: ../../library/unittest.mock.rst:875
msgid "See :meth:`~object.__getattr__` for details."
msgstr ""

#: ../../library/unittest.mock.rst:880
msgid ""
"An asynchronous version of :class:`MagicMock`. The :class:`AsyncMock` object "
"will behave so the object is recognized as an async function, and the result "
"of a call is an awaitable."
msgstr ""

#: ../../library/unittest.mock.rst:890
msgid ""
"The result of ``mock()`` is an async function which will have the outcome of "
"``side_effect`` or ``return_value`` after it has been awaited:"
msgstr ""

#: ../../library/unittest.mock.rst:893
msgid ""
"if ``side_effect`` is a function, the async function will return the result "
"of that function,"
msgstr ""

#: ../../library/unittest.mock.rst:895
msgid ""
"if ``side_effect`` is an exception, the async function will raise the "
"exception,"
msgstr ""

#: ../../library/unittest.mock.rst:897
msgid ""
"if ``side_effect`` is an iterable, the async function will return the next "
"value of the iterable, however, if the sequence of result is exhausted, "
"``StopAsyncIteration`` is raised immediately,"
msgstr ""

#: ../../library/unittest.mock.rst:900
msgid ""
"if ``side_effect`` is not defined, the async function will return the value "
"defined by ``return_value``, hence, by default, the async function returns a "
"new :class:`AsyncMock` object."
msgstr ""

#: ../../library/unittest.mock.rst:905
msgid ""
"Setting the *spec* of a :class:`Mock` or :class:`MagicMock` to an async "
"function will result in a coroutine object being returned after calling."
msgstr ""

#: ../../library/unittest.mock.rst:917
msgid ""
"Setting the *spec* of a :class:`Mock`, :class:`MagicMock`, or :class:"
"`AsyncMock` to a class with asynchronous and synchronous functions will "
"automatically detect the synchronous functions and set them as :class:"
"`MagicMock` (if the parent mock is :class:`AsyncMock` or :class:`MagicMock`) "
"or :class:`Mock` (if the parent mock is :class:`Mock`). All asynchronous "
"functions will be :class:`AsyncMock`."
msgstr ""

#: ../../library/unittest.mock.rst:945
msgid ""
"Assert that the mock was awaited at least once. Note that this is separate "
"from the object having been called, the ``await`` keyword must be used:"
msgstr ""

#: ../../library/unittest.mock.rst:964
msgid "Assert that the mock was awaited exactly once."
msgstr ""

#: ../../library/unittest.mock.rst:980
msgid "Assert that the last await was with the specified arguments."
msgstr ""

#: ../../library/unittest.mock.rst:997
msgid ""
"Assert that the mock was awaited exactly once and with the specified "
"arguments."
msgstr ""

#: ../../library/unittest.mock.rst:1014
msgid "Assert the mock has ever been awaited with the specified arguments."
msgstr ""

#: ../../library/unittest.mock.rst:1030
msgid ""
"Assert the mock has been awaited with the specified calls. The :attr:"
"`await_args_list` list is checked for the awaits."
msgstr ""

#: ../../library/unittest.mock.rst:1033
msgid ""
"If *any_order* is false then the awaits must be sequential. There can be "
"extra calls before or after the specified awaits."
msgstr ""

#: ../../library/unittest.mock.rst:1037
msgid ""
"If *any_order* is true then the awaits can be in any order, but they must "
"all appear in :attr:`await_args_list`."
msgstr ""

#: ../../library/unittest.mock.rst:1057
msgid "Assert that the mock was never awaited."
msgstr ""

#: ../../library/unittest.mock.rst:1064
msgid ""
"See :func:`Mock.reset_mock`. Also sets :attr:`await_count` to 0, :attr:"
"`await_args` to None, and clears the :attr:`await_args_list`."
msgstr ""

#: ../../library/unittest.mock.rst:1069
msgid ""
"An integer keeping track of how many times the mock object has been awaited."
msgstr ""

#: ../../library/unittest.mock.rst:1084
msgid ""
"This is either ``None`` (if the mock hasn’t been awaited), or the arguments "
"that the mock was last awaited with. Functions the same as :attr:`Mock."
"call_args`."
msgstr ""

#: ../../library/unittest.mock.rst:1102
msgid ""
"This is a list of all the awaits made to the mock object in sequence (so the "
"length of the list is the number of times it has been awaited). Before any "
"awaits have been made it is an empty list."
msgstr ""

#: ../../library/unittest.mock.rst:1122
msgid ""
"A version of :class:`MagicMock` for multithreading tests. The :class:"
"`ThreadingMock` object provides extra methods to wait for a call to be "
"invoked, rather than assert on it immediately."
msgstr ""

#: ../../library/unittest.mock.rst:1126
msgid ""
"The default timeout is specified by the ``timeout`` argument, or if unset by "
"the :attr:`ThreadingMock.DEFAULT_TIMEOUT` attribute, which defaults to "
"blocking (``None``)."
msgstr ""

#: ../../library/unittest.mock.rst:1129
msgid ""
"You can configure the global default timeout by setting :attr:`ThreadingMock."
"DEFAULT_TIMEOUT`."
msgstr ""

#: ../../library/unittest.mock.rst:1133
msgid "Waits until the mock is called."
msgstr ""

#: ../../library/unittest.mock.rst:1135
msgid ""
"If a timeout was passed at the creation of the mock or if a timeout argument "
"is passed to this function, the function raises an :exc:`AssertionError` if "
"the call is not performed in time."
msgstr ""

#: ../../library/unittest.mock.rst:1147
msgid "Waits until the mock is called with the specified arguments."
msgstr ""

#: ../../library/unittest.mock.rst:1149
msgid ""
"If a timeout was passed at the creation of the mock the function raises an :"
"exc:`AssertionError` if the call is not performed in time."
msgstr ""

#: ../../library/unittest.mock.rst:1160
msgid ""
"Global default timeout in seconds to create instances of :class:"
"`ThreadingMock`."
msgstr ""

#: ../../library/unittest.mock.rst:1166
msgid "Calling"
msgstr "呼び出し"

#: ../../library/unittest.mock.rst:1168
msgid ""
"Mock objects are callable. The call will return the value set as the :attr:"
"`~Mock.return_value` attribute. The default return value is a new Mock "
"object; it is created the first time the return value is accessed (either "
"explicitly or by calling the Mock) - but it is stored and the same one "
"returned each time."
msgstr ""
"モックオブジェクトは呼び出し可能です。呼び出しの戻り値は :attr:`~Mock."
"return_value` 属性に設定された値です。デフォルトでは新しいモックオブジェクト"
"を返します。この新しいモックは、属性に最初にアクセスした際に作成されます (明"
"示もしくはモックの呼び出しによって)。 そしてそれは保存され、それ以降は同じも"
"のが返されます。"

#: ../../library/unittest.mock.rst:1174
msgid ""
"Calls made to the object will be recorded in the attributes like :attr:"
"`~Mock.call_args` and :attr:`~Mock.call_args_list`."
msgstr ""
"呼び出しはオブジェクトとして :attr:`~Mock.call_args` や :attr:`~Mock."
"call_args_list` に記録されます。"

#: ../../library/unittest.mock.rst:1177
msgid ""
"If :attr:`~Mock.side_effect` is set then it will be called after the call "
"has been recorded, so if :attr:`side_effect` raises an exception the call is "
"still recorded."
msgstr ""
"もし :attr:`~Mock.side_effect` が設定されている場合は、その呼び出しが記録され"
"た後に呼び出されます。よって、もし :attr:`side_effect` が例外を発生させても、"
"その呼び出しは記録されます。"

#: ../../library/unittest.mock.rst:1181
msgid ""
"The simplest way to make a mock raise an exception when called is to make :"
"attr:`~Mock.side_effect` an exception class or instance:"
msgstr ""
"呼び出された際に例外を発生させるモックを作成するためには、 :attr:`~Mock."
"side_effect` を例外クラスかインスタンスにする方法が最もシンプルです:"

#: ../../library/unittest.mock.rst:1199
msgid ""
"If :attr:`side_effect` is a function then whatever that function returns is "
"what calls to the mock return. The :attr:`side_effect` function is called "
"with the same arguments as the mock. This allows you to vary the return "
"value of the call dynamically, based on the input:"
msgstr ""
"もし :attr:`side_effect` が関数だった場合には、その関数の戻り値がモックを呼び"
"出した際の戻り値になります。 :attr:`side_effect` 関数には、モックの呼び出し時"
"に与えられた引数と同じ物があたえられます。これにより、入力によって動的に値を"
"返すことができます:"

#: ../../library/unittest.mock.rst:1215
msgid ""
"If you want the mock to still return the default return value (a new mock), "
"or any set return value, then there are two ways of doing this. Either "
"return :attr:`mock.return_value` from inside :attr:`side_effect`, or return :"
"data:`DEFAULT`:"
msgstr ""
"もし、モックにデフォルトの戻り値 (新しいモック)  や設定した値を返して欲しい場"
"合は、2つの方法があります。 :attr:`side_effect` の内部で :attr:`mock."
"return_value` を返すか :data:`DEFAULT` を返します:"

#: ../../library/unittest.mock.rst:1234
msgid ""
"To remove a :attr:`side_effect`, and return to the default behaviour, set "
"the :attr:`side_effect` to ``None``:"
msgstr ""
":attr:`side_effect` を削除し、デフォルトの挙動を行うようにするには、 :attr:"
"`side_effect` に ``None`` を設定します:"

#: ../../library/unittest.mock.rst:1248
msgid ""
"The :attr:`side_effect` can also be any iterable object. Repeated calls to "
"the mock will return values from the iterable (until the iterable is "
"exhausted and a :exc:`StopIteration` is raised):"
msgstr ""
":attr:`side_effect` には、イテレート可能オブジェクトを設定できます。モックが"
"呼び出されるごとに、イテレート可能オブジェクトから戻り値を得ます (イテレート"
"可能オブジェクトが尽きて :exc:`StopIteration` が発生するまで):"

#: ../../library/unittest.mock.rst:1264
msgid ""
"If any members of the iterable are exceptions they will be raised instead of "
"returned::"
msgstr ""
"もしイテレート可能オブジェクトの要素が例外だった場合には、戻り値として返され"
"る代わりに例外が発生します::"

#: ../../library/unittest.mock.rst:1267
msgid ""
">>> iterable = (33, ValueError, 66)\n"
">>> m = MagicMock(side_effect=iterable)\n"
">>> m()\n"
"33\n"
">>> m()\n"
"Traceback (most recent call last):\n"
" ...\n"
"ValueError\n"
">>> m()\n"
"66"
msgstr ""

#: ../../library/unittest.mock.rst:1282
msgid "Deleting Attributes"
msgstr "属性の削除"

#: ../../library/unittest.mock.rst:1284
msgid ""
"Mock objects create attributes on demand. This allows them to pretend to be "
"objects of any type."
msgstr ""
"モックオブジェクトは要求に応じて属性を生成することで，任意のオブジェクトとし"
"て振る舞うことができます。"

#: ../../library/unittest.mock.rst:1287
msgid ""
"You may want a mock object to return ``False`` to a :func:`hasattr` call, or "
"raise an :exc:`AttributeError` when an attribute is fetched. You can do this "
"by providing an object as a :attr:`spec` for a mock, but that isn't always "
"convenient."
msgstr ""
":func:`hasattr` の呼び出しの際に ``False`` を返したり，属性にアクセスした際"
"に :exc:`AttributeError` を発生させたりしたい場合， :attr:`spec` を用いる方法"
"があります．しかし，この方法は必ずしも便利ではありません．"

#: ../../library/unittest.mock.rst:1291
msgid ""
"You \"block\" attributes by deleting them. Once deleted, accessing an "
"attribute will raise an :exc:`AttributeError`."
msgstr ""
"属性を削除することで， :exc:`AttributeError` を発生させ，アクセスを \"妨げる"
"\" ようになります．"

#: ../../library/unittest.mock.rst:1308
msgid "Mock names and the name attribute"
msgstr "Mock の名前と name 属性"

#: ../../library/unittest.mock.rst:1310
msgid ""
"Since \"name\" is an argument to the :class:`Mock` constructor, if you want "
"your mock object to have a \"name\" attribute you can't just pass it in at "
"creation time. There are two alternatives. One option is to use :meth:`~Mock."
"configure_mock`::"
msgstr ""
"\"name\" は :class:`Mock` コンストラクタの引数なので、モックオブジェクトが "
"\"name\" 属性を持つことを望む場合、単に生成時にそれを渡すことはできません。2"
"つの選択肢があります。1つのオプションは :meth:`~Mock.configure_mock` を使用す"
"ることです::"

#: ../../library/unittest.mock.rst:1315
msgid ""
">>> mock = MagicMock()\n"
">>> mock.configure_mock(name='my_name')\n"
">>> mock.name\n"
"'my_name'"
msgstr ""

#: ../../library/unittest.mock.rst:1320
msgid ""
"A simpler option is to simply set the \"name\" attribute after mock "
"creation::"
msgstr ""
"より単純なオプションはモックの生成後に単に \"name\" 属性をセットすることで"
"す::"

#: ../../library/unittest.mock.rst:1322
msgid ""
">>> mock = MagicMock()\n"
">>> mock.name = \"foo\""
msgstr ""

#: ../../library/unittest.mock.rst:1327
msgid "Attaching Mocks as Attributes"
msgstr "属性として設定されるモック"

#: ../../library/unittest.mock.rst:1329
msgid ""
"When you attach a mock as an attribute of another mock (or as the return "
"value) it becomes a \"child\" of that mock. Calls to the child are recorded "
"in the :attr:`~Mock.method_calls` and :attr:`~Mock.mock_calls` attributes of "
"the parent. This is useful for configuring child mocks and then attaching "
"them to the parent, or for attaching mocks to a parent that records all "
"calls to the children and allows you to make assertions about the order of "
"calls between mocks:"
msgstr ""
"属性 (もしくは戻り値) に他のモックを設定した場合、このモックは \"子\" になり"
"ます。この子に対する呼び出しは、親の :attr:`~Mock.method_calls` や :attr:"
"`~Mock.mock_calls` に記録されます。これは、子のモックを構成し、親にそのモック"
"を設定する際に有用です。また、親に対して設定したすべての子の呼び出しを記録す"
"るため、それらの間の順番を確認する際にも有用です:"

#: ../../library/unittest.mock.rst:1347
msgid ""
"The exception to this is if the mock has a name. This allows you to prevent "
"the \"parenting\" if for some reason you don't want it to happen."
msgstr ""
"モックが名前をもつ場合は、例外的に扱われます。何らかの理由で \"子守り\" が発"
"生してほしくないときに、それを防ぐことができます。"

#: ../../library/unittest.mock.rst:1358
msgid ""
"Mocks created for you by :func:`patch` are automatically given names. To "
"attach mocks that have names to a parent you use the :meth:`~Mock."
"attach_mock` method::"
msgstr ""
":func:`patch` を用いて作成したモックには、自動的に名前が与えられます。名前を"
"持つモックを設定したい場合には、親に対して :meth:`~Mock.attach_mock` メソッド"
"を呼び出します::"

#: ../../library/unittest.mock.rst:1362
msgid ""
">>> thing1 = object()\n"
">>> thing2 = object()\n"
">>> parent = MagicMock()\n"
">>> with patch('__main__.thing1', return_value=None) as child1:\n"
"...     with patch('__main__.thing2', return_value=None) as child2:\n"
"...         parent.attach_mock(child1, 'child1')\n"
"...         parent.attach_mock(child2, 'child2')\n"
"...         child1('one')\n"
"...         child2('two')\n"
"...\n"
">>> parent.mock_calls\n"
"[call.child1('one'), call.child2('two')]"
msgstr ""

#: ../../library/unittest.mock.rst:1376
msgid ""
"The only exceptions are magic methods and attributes (those that have "
"leading and trailing double underscores). Mock doesn't create these but "
"instead raises an :exc:`AttributeError`. This is because the interpreter "
"will often implicitly request these methods, and gets *very* confused to get "
"a new Mock object when it expects a magic method. If you need magic method "
"support see :ref:`magic methods <magic-methods>`."
msgstr ""
"例外は特殊メソッドと属性だけです (これらは2つのアンダースコアで開始・終了しま"
"す)。モックはこれらの代わりに :exc:`AttributeError` を発生させます。これは、"
"インタープリタが暗黙的にこれらのメソッドを要求するためであり、特殊メソッドを"
"予測する際に *非常に* 混乱してしまいます。もし特殊メソッドのサポートが必要な"
"場合は、 :ref:`magic methods <magic-methods>` を参照してください。"

#: ../../library/unittest.mock.rst:1385
msgid "The patchers"
msgstr "patcher"

#: ../../library/unittest.mock.rst:1387
msgid ""
"The patch decorators are used for patching objects only within the scope of "
"the function they decorate. They automatically handle the unpatching for "
"you, even if exceptions are raised. All of these functions can also be used "
"in with statements or as class decorators."
msgstr ""
"patch デコレータは、その関数のスコープ内でパッチを適用するオブジェクトに対し"
"て使用されます。たとえ例外が発生したとしても、パッチは自動的に解除されます。"
"これらすべての機能は文やクラスのデコレータとしても使用できます。"

#: ../../library/unittest.mock.rst:1394
msgid "patch"
msgstr "patch"

#: ../../library/unittest.mock.rst:1398
msgid ""
"The key is to do the patching in the right namespace. See the section `where "
"to patch`_."
msgstr ""
"重要なのは正しい名前空間に対して patch することです。`where to patch`_ セク"
"ションを参照してください。"

#: ../../library/unittest.mock.rst:1402
msgid ""
":func:`patch` acts as a function decorator, class decorator or a context "
"manager. Inside the body of the function or with statement, the *target* is "
"patched with a *new* object. When the function/with statement exits the "
"patch is undone."
msgstr ""
":func:`patch` は関数デコレータ、クラスデコレータ、コンテキストマネージャーと"
"して利用できます。関数や with 文の body では、 *target* は *new* オブジェクト"
"にパッチされます。関数/with 文が終了すると、パッチは元に戻されます。"

#: ../../library/unittest.mock.rst:1407
msgid ""
"If *new* is omitted, then the target is replaced with an :class:`AsyncMock` "
"if the patched object is an async function or a :class:`MagicMock` "
"otherwise. If :func:`patch` is used as a decorator and *new* is omitted, the "
"created mock is passed in as an extra argument to the decorated function. "
"If :func:`patch` is used as a context manager the created mock is returned "
"by the context manager."
msgstr ""

#: ../../library/unittest.mock.rst:1415
msgid ""
"*target* should be a string in the form ``'package.module.ClassName'``. The "
"*target* is imported and the specified object replaced with the *new* "
"object, so the *target* must be importable from the environment you are "
"calling :func:`patch` from. The target is imported when the decorated "
"function is executed, not at decoration time."
msgstr ""
"*target* は ``'package.module.ClassName'`` の形式の文字列でなければなりませ"
"ん。 `target` はインポートされ、指定されたオブジェクトが `new` オブジェクトに"
"置き換えられます。なので、 *target* は :func:`patch` を呼び出した環境からイン"
"ポート可能でなければなりません。 target がインポートされるのは、デコレートし"
"た時ではなく、デコレートされた関数が呼び出された時です。"

#: ../../library/unittest.mock.rst:1421
msgid ""
"The *spec* and *spec_set* keyword arguments are passed to the :class:"
"`MagicMock` if patch is creating one for you."
msgstr ""
"patch が :class:`MagicMock` を生成する場合、 *spec* と *spec_set* キーワード"
"引数は :class:`MagicMock` に渡されます。"

#: ../../library/unittest.mock.rst:1424
msgid ""
"In addition you can pass ``spec=True`` or ``spec_set=True``, which causes "
"patch to pass in the object being mocked as the spec/spec_set object."
msgstr ""
"加えて、 ``spec=True`` もしくは ``spec_set=True`` を渡すことで、モック対象の"
"オブジェクトが spec/spec_set に渡されます。"

#: ../../library/unittest.mock.rst:1427
msgid ""
"*new_callable* allows you to specify a different class, or callable object, "
"that will be called to create the *new* object. By default :class:"
"`AsyncMock` is used for async functions and :class:`MagicMock` for the rest."
msgstr ""

#: ../../library/unittest.mock.rst:1431
msgid ""
"A more powerful form of *spec* is *autospec*. If you set ``autospec=True`` "
"then the mock will be created with a spec from the object being replaced. "
"All attributes of the mock will also have the spec of the corresponding "
"attribute of the object being replaced. Methods and functions being mocked "
"will have their arguments checked and will raise a :exc:`TypeError` if they "
"are called with the wrong signature. For mocks replacing a class, their "
"return value (the 'instance') will have the same spec as the class. See the :"
"func:`create_autospec` function and :ref:`auto-speccing`."
msgstr ""
"より強力な *spec* の形は *autospec* です。 ``autospec=True`` を指定した場"
"合、 mock は置換対象となるオブジェクトから得られる spec で生成されます。 "
"mock のすべての属性もまた置換対象となるオブジェクトの属性に応じた spec を持ち"
"ます。 mock されたメソッドや関数は引数をチェックし、間違ったシグネチャで呼び"
"出された場合は :exc:`TypeError` を発生させます。クラスを置き換える mock の場"
"合、その戻り値 (つまりインスタンス) はそのクラスと同じ spec を持ちます。 :"
"func:`create_autospec` 関数と :ref:`auto-speccing` を参照してください。"

#: ../../library/unittest.mock.rst:1441
msgid ""
"Instead of ``autospec=True`` you can pass ``autospec=some_object`` to use an "
"arbitrary object as the spec instead of the one being replaced."
msgstr ""
"置換対象ではなく任意のオブジェクトを spec として使うために、 "
"``autospec=True`` の代わりに、 ``autospec=some_object`` と指定することができ"
"ます。"

#: ../../library/unittest.mock.rst:1444
msgid ""
"By default :func:`patch` will fail to replace attributes that don't exist. "
"If you pass in ``create=True``, and the attribute doesn't exist, patch will "
"create the attribute for you when the patched function is called, and delete "
"it again after the patched function has exited. This is useful for writing "
"tests against attributes that your production code creates at runtime. It is "
"off by default because it can be dangerous. With it switched on you can "
"write passing tests against APIs that don't actually exist!"
msgstr ""

#: ../../library/unittest.mock.rst:1454
msgid ""
"If you are patching builtins in a module then you don't need to pass "
"``create=True``, it will be added by default."
msgstr ""
"モジュールのビルトインにパッチを当てようとしているなら、 ``create=True`` を渡"
"す必要はありません。それはデフォルトで追加されます。"

#: ../../library/unittest.mock.rst:1458
msgid ""
"Patch can be used as a :class:`TestCase` class decorator. It works by "
"decorating each test method in the class. This reduces the boilerplate code "
"when your test methods share a common patchings set. :func:`patch` finds "
"tests by looking for method names that start with ``patch.TEST_PREFIX``. By "
"default this is ``'test'``, which matches the way :mod:`unittest` finds "
"tests. You can specify an alternative prefix by setting ``patch."
"TEST_PREFIX``."
msgstr ""
"patch は :class:`TestCase` のクラスデコレータとして利用できます。この場合その"
"クラスの各テストメソッドをデコレートします。これによりテストメソッドが同じ "
"patch を共有している場合に退屈なコードを減らすことができます。 :func:`patch` "
"は ``patch.TEST_PREFIX`` で始まるメソッド名のメソッドを探します。デフォルトで"
"はこれは ``'test'`` で、 :mod:`unittest` がテストを探す方法とマッチしていま"
"す。 ``patch.TEST_PREFIX`` を設定することで異なる prefix を指定することもでき"
"ます。"

#: ../../library/unittest.mock.rst:1465
msgid ""
"Patch can be used as a context manager, with the with statement. Here the "
"patching applies to the indented block after the with statement. If you use "
"\"as\" then the patched object will be bound to the name after the \"as\"; "
"very useful if :func:`patch` is creating a mock object for you."
msgstr ""
"patch は with 文を使ってコンテキストマネージャーとして使うこともできます。そ"
"の場合パッチは with 文のブロック内でのみ適用されます。 \"as\" を使って、 "
"\"as\" に続いて指定した変数にパッチされたオブジェクトが代入されます。これは :"
"func:`patch` が mock オブジェクトを生成するときに便利です。"

#: ../../library/unittest.mock.rst:1470
msgid ""
":func:`patch` takes arbitrary keyword arguments. These will be passed to :"
"class:`AsyncMock` if the patched object is asynchronous, to :class:"
"`MagicMock` otherwise or to *new_callable* if specified."
msgstr ""

#: ../../library/unittest.mock.rst:1474
msgid ""
"``patch.dict(...)``, ``patch.multiple(...)`` and ``patch.object(...)`` are "
"available for alternate use-cases."
msgstr ""
"異なるユースケースのために、 ``patch.dict(...)``, ``patch.multiple(...)``, "
"``patch.object(...)`` が用意されています。"

#: ../../library/unittest.mock.rst:1477
msgid ""
":func:`patch` as function decorator, creating the mock for you and passing "
"it into the decorated function::"
msgstr ""
":func:`patch` を関数デコレータとして利用し、 mock を生成してそれをデコレート"
"された関数に渡します::"

#: ../../library/unittest.mock.rst:1480
msgid ""
">>> @patch('__main__.SomeClass')\n"
"... def function(normal_argument, mock_class):\n"
"...     print(mock_class is SomeClass)\n"
"...\n"
">>> function(None)\n"
"True"
msgstr ""

#: ../../library/unittest.mock.rst:1487
msgid ""
"Patching a class replaces the class with a :class:`MagicMock` *instance*. If "
"the class is instantiated in the code under test then it will be the :attr:"
"`~Mock.return_value` of the mock that will be used."
msgstr ""
"クラスをパッチするとそのクラスを :class:`MagicMock` の **インスタンス** に置"
"き換えます。テスト中のコードからそのクラスがインスタンス化される場合、 mock "
"の :attr:`~Mock.return_value` が利用されます。"

#: ../../library/unittest.mock.rst:1491
msgid ""
"If the class is instantiated multiple times you could use :attr:`~Mock."
"side_effect` to return a new mock each time. Alternatively you can set the "
"*return_value* to be anything you want."
msgstr ""
"クラスが複数回インスタンス化される場合、 :attr:`~Mock.side_effect` を利用して"
"毎回新しい mock を返すようにできます。もしくは、 *return_value* に、何でも好"
"きなものを設定できます。"

#: ../../library/unittest.mock.rst:1495
msgid ""
"To configure return values on methods of *instances* on the patched class "
"you must do this on the :attr:`return_value`. For example::"
msgstr ""
"パッチしたクラスの *インスタンス* のメソッドの戻り値をカスタマイズしたい場"
"合、 :attr:`return_value` に対して設定しなければなりません。例::"

#: ../../library/unittest.mock.rst:1498
msgid ""
">>> class Class:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Class') as MockClass:\n"
"...     instance = MockClass.return_value\n"
"...     instance.method.return_value = 'foo'\n"
"...     assert Class() is instance\n"
"...     assert Class().method() == 'foo'\n"
"..."
msgstr ""

#: ../../library/unittest.mock.rst:1509
msgid ""
"If you use *spec* or *spec_set* and :func:`patch` is replacing a *class*, "
"then the return value of the created mock will have the same spec. ::"
msgstr ""
"*spec* か *spec_set* を指定し、 :func:`patch` が *クラス* を置換するとき、生"
"成された mock の戻り値は同じ spec を持ちます。::"

#: ../../library/unittest.mock.rst:1512
msgid ""
">>> Original = Class\n"
">>> patcher = patch('__main__.Class', spec=True)\n"
">>> MockClass = patcher.start()\n"
">>> instance = MockClass()\n"
">>> assert isinstance(instance, Original)\n"
">>> patcher.stop()"
msgstr ""

#: ../../library/unittest.mock.rst:1519
msgid ""
"The *new_callable* argument is useful where you want to use an alternative "
"class to the default :class:`MagicMock` for the created mock. For example, "
"if you wanted a :class:`NonCallableMock` to be used::"
msgstr ""
"*new_callable* 引数は、デフォルトの :class:`MagicMock` の代わりに別のクラスを"
"モックとして生成したい場合に便利です。例えば、 :class:`NonCallableMock` を利"
"用したい場合::"

#: ../../library/unittest.mock.rst:1523
msgid ""
">>> thing = object()\n"
">>> with patch('__main__.thing', new_callable=NonCallableMock) as "
"mock_thing:\n"
"...     assert thing is mock_thing\n"
"...     thing()\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'NonCallableMock' object is not callable"
msgstr ""

#: ../../library/unittest.mock.rst:1532
msgid ""
"Another use case might be to replace an object with an :class:`io.StringIO` "
"instance::"
msgstr ""
"別のユースケースとしては、オブジェクトを :class:`io.StringIO` インスタンスで"
"置き換えることがあります::"

#: ../../library/unittest.mock.rst:1534
msgid ""
">>> from io import StringIO\n"
">>> def foo():\n"
"...     print('Something')\n"
"...\n"
">>> @patch('sys.stdout', new_callable=StringIO)\n"
"... def test(mock_stdout):\n"
"...     foo()\n"
"...     assert mock_stdout.getvalue() == 'Something\\n'\n"
"...\n"
">>> test()"
msgstr ""

#: ../../library/unittest.mock.rst:1545
msgid ""
"When :func:`patch` is creating a mock for you, it is common that the first "
"thing you need to do is to configure the mock. Some of that configuration "
"can be done in the call to patch. Any arbitrary keywords you pass into the "
"call will be used to set attributes on the created mock::"
msgstr ""
":func:`patch` に mock を生成させる場合、たいてい最初に必要なことはその mock "
"をセットアップすることです。幾らかのセットアップは patch の呼び出しから行うこ"
"とができます。任意のキーワード引数が、生成された mock の属性に設定されます::"

#: ../../library/unittest.mock.rst:1550
msgid ""
">>> patcher = patch('__main__.thing', first='one', second='two')\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.first\n"
"'one'\n"
">>> mock_thing.second\n"
"'two'"
msgstr ""

#: ../../library/unittest.mock.rst:1557
msgid ""
"As well as attributes on the created mock attributes, like the :attr:`~Mock."
"return_value` and :attr:`~Mock.side_effect`, of child mocks can also be "
"configured. These aren't syntactically valid to pass in directly as keyword "
"arguments, but a dictionary with these as keys can still be expanded into a :"
"func:`patch` call using ``**``::"
msgstr ""
"生成された mock の属性のさらに属性、 :attr:`~Mock.return_value` :attr:`~Mock."
"side_effect` などもセットアップできます。これらはキーワード引数のシンタックス"
"では直接指定できませんが、それらをキーとする辞書を ``**`` を使って :func:"
"`patch` に渡すことができます::"

#: ../../library/unittest.mock.rst:1563
msgid ""
">>> config = {'method.return_value': 3, 'other.side_effect': KeyError}\n"
">>> patcher = patch('__main__.thing', **config)\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.method()\n"
"3\n"
">>> mock_thing.other()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError"
msgstr ""

#: ../../library/unittest.mock.rst:1573
msgid ""
"By default, attempting to patch a function in a module (or a method or an "
"attribute in a class) that does not exist will fail with :exc:"
"`AttributeError`::"
msgstr ""

#: ../../library/unittest.mock.rst:1576
msgid ""
">>> @patch('sys.non_existing_attribute', 42)\n"
"... def test():\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: <module 'sys' (built-in)> does not have the attribute "
"'non_existing_attribute'"
msgstr ""

#: ../../library/unittest.mock.rst:1585
msgid ""
"but adding ``create=True`` in the call to :func:`patch` will make the "
"previous example work as expected::"
msgstr ""

#: ../../library/unittest.mock.rst:1588
msgid ""
">>> @patch('sys.non_existing_attribute', 42, create=True)\n"
"... def test(mock_stdout):\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()"
msgstr ""

#: ../../library/unittest.mock.rst:1596
msgid ""
":func:`patch` now returns an :class:`AsyncMock` if the target is an async "
"function."
msgstr ""

#: ../../library/unittest.mock.rst:1600
msgid "patch.object"
msgstr "patch.object"

#: ../../library/unittest.mock.rst:1604
msgid ""
"patch the named member (*attribute*) on an object (*target*) with a mock "
"object."
msgstr ""
"オブジェクト (*target*) の指定された名前のメンバー (*attribute*) を mock オブ"
"ジェクトでパッチします。"

#: ../../library/unittest.mock.rst:1607
msgid ""
":func:`patch.object` can be used as a decorator, class decorator or a "
"context manager. Arguments *new*, *spec*, *create*, *spec_set*, *autospec* "
"and *new_callable* have the same meaning as for :func:`patch`. Like :func:"
"`patch`, :func:`patch.object` takes arbitrary keyword arguments for "
"configuring the mock object it creates."
msgstr ""
":func:`patch.object` はデコレータ、クラスデコレータ、コンテキストマネージャー"
"として利用できます。引数の *new*, *spec*, *create*, *spec_set*, *autospec*, "
"*new_callable* は :func:`patch` と同じ意味を持ちます。 :func:`patch` と同じ"
"く、 :func:`patch.object` も mock を生成するための任意のキーワード引数を受け"
"取ります。"

#: ../../library/unittest.mock.rst:1613
msgid ""
"When used as a class decorator :func:`patch.object` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"クラスデコレータとして利用する場合、 :func:`patch.object` は ``patch."
"TEST_PREFIX`` にしたがってラップするメソッドを選択します。"

#: ../../library/unittest.mock.rst:1616
msgid ""
"You can either call :func:`patch.object` with three arguments or two "
"arguments. The three argument form takes the object to be patched, the "
"attribute name and the object to replace the attribute with."
msgstr ""
":func:`patch.object` の呼び出しには3引数の形式と2引数の形式があります。 3引数"
"の場合、 patch 対象のオブジェクト、属性名、その属性を置き換えるオブジェクトを"
"取ります。"

#: ../../library/unittest.mock.rst:1620
msgid ""
"When calling with the two argument form you omit the replacement object, and "
"a mock is created for you and passed in as an extra argument to the "
"decorated function:"
msgstr ""
"2引数の形式では、置き換えるオブジェクトを省略し、生成された mock がデコレート"
"対象となる関数に追加の引数として渡されます:"

#: ../../library/unittest.mock.rst:1631
msgid ""
"*spec*, *create* and the other arguments to :func:`patch.object` have the "
"same meaning as they do for :func:`patch`."
msgstr ""
"*spec*, *create* やその他の :func:`patch.object` の引数は :func:`patch` の引"
"数と同じ意味を持ちます。"

#: ../../library/unittest.mock.rst:1636
msgid "patch.dict"
msgstr "patch.dict"

#: ../../library/unittest.mock.rst:1640
msgid ""
"Patch a dictionary, or dictionary like object, and restore the dictionary to "
"its original state after the test."
msgstr ""
"辞書や辞書のようなオブジェクトにパッチし、テスト後に元の状態に戻します。"

#: ../../library/unittest.mock.rst:1643
msgid ""
"*in_dict* can be a dictionary or a mapping like container. If it is a "
"mapping then it must at least support getting, setting and deleting items "
"plus iterating over keys."
msgstr ""
"*in_dict* は辞書やその他のマップ型のコンテナです。マップ型の場合、最低限 "
"get, set, del 操作とキーに対するイテレートをサポートしている必要があります。"

#: ../../library/unittest.mock.rst:1647
msgid ""
"*in_dict* can also be a string specifying the name of the dictionary, which "
"will then be fetched by importing it."
msgstr ""
"*in_dict* に辞書を指定する文字列を渡した場合、それをインポートして取得しま"
"す。"

#: ../../library/unittest.mock.rst:1650
msgid ""
"*values* can be a dictionary of values to set in the dictionary. *values* "
"can also be an iterable of ``(key, value)`` pairs."
msgstr ""
"*values* は対象の辞書にセットする値を含む、辞書か ``(key, value)`` ペアの "
"iterable です。"

#: ../../library/unittest.mock.rst:1653
msgid ""
"If *clear* is true then the dictionary will be cleared before the new values "
"are set."
msgstr "*clear* が true なら、新しい値が設定される前に辞書がクリアされます。"

#: ../../library/unittest.mock.rst:1656
msgid ""
":func:`patch.dict` can also be called with arbitrary keyword arguments to "
"set values in the dictionary."
msgstr ""
":func:`patch.dict` はまた、任意のキーワード引数を受け取って辞書に設定します。"

#: ../../library/unittest.mock.rst:1661
msgid ""
":func:`patch.dict` now returns the patched dictionary when used as a context "
"manager."
msgstr ""

#: ../../library/unittest.mock.rst:1664
msgid ""
":func:`patch.dict` can be used as a context manager, decorator or class "
"decorator:"
msgstr ""

#: ../../library/unittest.mock.rst:1675
msgid ""
"When used as a class decorator :func:`patch.dict` honours ``patch."
"TEST_PREFIX`` (default to ``'test'``) for choosing which methods to wrap:"
msgstr ""

#: ../../library/unittest.mock.rst:1686
msgid ""
"If you want to use a different prefix for your test, you can inform the "
"patchers of the different prefix by setting ``patch.TEST_PREFIX``. For more "
"details about how to change the value of see :ref:`test-prefix`."
msgstr ""

#: ../../library/unittest.mock.rst:1690
msgid ""
":func:`patch.dict` can be used to add members to a dictionary, or simply let "
"a test change a dictionary, and ensure the dictionary is restored when the "
"test ends."
msgstr ""
":func:`patch.dict` を使うと、辞書にメンバーを追加するか、または単にテストが辞"
"書を変更して、その後テストが終了した時にその辞書が確実に復元されるようにする"
"ことができます。"

#: ../../library/unittest.mock.rst:1711
msgid ""
"Keywords can be used in the :func:`patch.dict` call to set values in the "
"dictionary:"
msgstr ""
":func:`patch.dict` を呼び出すときにキーワード引数を使って辞書に値をセットする"
"ことができます。"

#: ../../library/unittest.mock.rst:1721
msgid ""
":func:`patch.dict` can be used with dictionary like objects that aren't "
"actually dictionaries. At the very minimum they must support item getting, "
"setting, deleting and either iteration or membership test. This corresponds "
"to the magic methods :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__` and either :meth:`~container."
"__iter__` or :meth:`~object.__contains__`."
msgstr ""

#: ../../library/unittest.mock.rst:1751
msgid "patch.multiple"
msgstr "patch.multiple"

#: ../../library/unittest.mock.rst:1755
msgid ""
"Perform multiple patches in a single call. It takes the object to be patched "
"(either as an object or a string to fetch the object by importing) and "
"keyword arguments for the patches::"
msgstr ""
"1回の呼び出しで複数のパッチを実行します。パッチ対象のオブジェクト (あるいはそ"
"のオブジェクトをインポートするための文字列) と、パッチ用のキーワード引数を取"
"ります::"

#: ../../library/unittest.mock.rst:1759
msgid ""
"with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):\n"
"    ..."
msgstr ""

#: ../../library/unittest.mock.rst:1762
msgid ""
"Use :data:`DEFAULT` as the value if you want :func:`patch.multiple` to "
"create mocks for you. In this case the created mocks are passed into a "
"decorated function by keyword, and a dictionary is returned when :func:"
"`patch.multiple` is used as a context manager."
msgstr ""
":func:`patch.multiple` に mock を生成させたい場合、キーワード引数の値に :"
"data:`DEFAULT` を指定します。この場合生成されたモックはデコレート対象の関数に"
"キーワード引数として渡され、コンテキストマネージャーとして :func:`patch."
"multiple` が利用された場合は辞書として返します。"

#: ../../library/unittest.mock.rst:1767
msgid ""
":func:`patch.multiple` can be used as a decorator, class decorator or a "
"context manager. The arguments *spec*, *spec_set*, *create*, *autospec* and "
"*new_callable* have the same meaning as for :func:`patch`. These arguments "
"will be applied to *all* patches done by :func:`patch.multiple`."
msgstr ""
":func:`patch.multiple` はデコレータ、クラスデコレータ、コンテキストマネー"
"ジャーとして使えます。引数の *spec*, *spec_set*, *create*, *autospec*, "
"*new_callable* は :func:`patch` の引数と同じ意味を持ちます。これらの引数は :"
"func:`patch.multiple` によって適用される *すべての* パッチに対して適用されま"
"す。"

#: ../../library/unittest.mock.rst:1772
msgid ""
"When used as a class decorator :func:`patch.multiple` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"クラスデコレータとして利用する場合、 :func:`patch.multiple` は ``patch."
"TEST_PREFIX`` にしたがってラップするメソッドを選択します。"

#: ../../library/unittest.mock.rst:1775
msgid ""
"If you want :func:`patch.multiple` to create mocks for you, then you can "
"use :data:`DEFAULT` as the value. If you use :func:`patch.multiple` as a "
"decorator then the created mocks are passed into the decorated function by "
"keyword. ::"
msgstr ""
":func:`patch.multiple` に mock を生成させたい場合、キーワード引数の値に :"
"data:`DEFAULT` を指定します。:func:`patch.multiple` をデコレータとして使った"
"場合生成されたモックはデコレート対象の関数にキーワード引数として渡されま"
"す。::"

#: ../../library/unittest.mock.rst:1779
msgid ""
">>> thing = object()\n"
">>> other = object()\n"
"\n"
">>> @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(thing, other):\n"
"...     assert isinstance(thing, MagicMock)\n"
"...     assert isinstance(other, MagicMock)\n"
"...\n"
">>> test_function()"
msgstr ""

#: ../../library/unittest.mock.rst:1789
msgid ""
":func:`patch.multiple` can be nested with other ``patch`` decorators, but "
"put arguments passed by keyword *after* any of the standard arguments "
"created by :func:`patch`::"
msgstr ""
":func:`patch.multiple` は他の ``patch`` デコレータとネストして利用できます"
"が、キーワード引数は :func:`patch` によって作られる通常の引数の *後ろ* で受け"
"取る必要があります::"

#: ../../library/unittest.mock.rst:1792
msgid ""
">>> @patch('sys.exit')\n"
"... @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(mock_exit, other, thing):\n"
"...     assert 'other' in repr(other)\n"
"...     assert 'thing' in repr(thing)\n"
"...     assert 'exit' in repr(mock_exit)\n"
"...\n"
">>> test_function()"
msgstr ""

#: ../../library/unittest.mock.rst:1801
msgid ""
"If :func:`patch.multiple` is used as a context manager, the value returned "
"by the context manager is a dictionary where created mocks are keyed by "
"name::"
msgstr ""
":func:`patch.multiple` がコンテキストマネージャーとして利用される場合、コンテ"
"キストマネージャーが返す値は、名前がキーで値が生成された mock となる辞書で"
"す::"

#: ../../library/unittest.mock.rst:1804
msgid ""
">>> with patch.multiple('__main__', thing=DEFAULT, other=DEFAULT) as "
"values:\n"
"...     assert 'other' in repr(values['other'])\n"
"...     assert 'thing' in repr(values['thing'])\n"
"...     assert values['thing'] is thing\n"
"...     assert values['other'] is other\n"
"..."
msgstr ""

#: ../../library/unittest.mock.rst:1815
msgid "patch methods: start and stop"
msgstr "patch のメソッド: start と stop"

#: ../../library/unittest.mock.rst:1817
msgid ""
"All the patchers have :meth:`start` and :meth:`stop` methods. These make it "
"simpler to do patching in ``setUp`` methods or where you want to do multiple "
"patches without nesting decorators or with statements."
msgstr ""
"すべての patcher は :meth:`start` と :meth:`stop` メソッドを持ちます。これを"
"使うと、 with 文やデコレータをネストさせずに、 ``setUp`` メソッドで複数のパッ"
"チをシンプルに適用させることができます。"

#: ../../library/unittest.mock.rst:1821
msgid ""
"To use them call :func:`patch`, :func:`patch.object` or :func:`patch.dict` "
"as normal and keep a reference to the returned ``patcher`` object. You can "
"then call :meth:`start` to put the patch in place and :meth:`stop` to undo "
"it."
msgstr ""
"これらのメソッドを使うには、 :func:`patch`, :func:`patch.object`, :func:"
"`patch.dict` を通常の関数のように呼び出して、戻り値の ``patcher`` オブジェク"
"トを保持します。その :meth:`start` メソッドでパッチを適用し、 :meth:`stop` メ"
"ソッドで巻き戻すことができます。"

#: ../../library/unittest.mock.rst:1825
msgid ""
"If you are using :func:`patch` to create a mock for you then it will be "
"returned by the call to ``patcher.start``. ::"
msgstr ""
":func:`patch` に mock を生成させる場合、 ``patcher.start`` の呼び出しの戻り値"
"として mock を受け取れます。::"

#: ../../library/unittest.mock.rst:1828
msgid ""
">>> patcher = patch('package.module.ClassName')\n"
">>> from package import module\n"
">>> original = module.ClassName\n"
">>> new_mock = patcher.start()\n"
">>> assert module.ClassName is not original\n"
">>> assert module.ClassName is new_mock\n"
">>> patcher.stop()\n"
">>> assert module.ClassName is original\n"
">>> assert module.ClassName is not new_mock"
msgstr ""

#: ../../library/unittest.mock.rst:1839
msgid ""
"A typical use case for this might be for doing multiple patches in the "
"``setUp`` method of a :class:`TestCase`::"
msgstr ""
"この方式の典型的なユースケースは、 :class:`TestCase` の ``setUp`` メソッドで"
"複数のパッチを行うことです::"

#: ../../library/unittest.mock.rst:1842
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher1 = patch('package.module.Class1')\n"
"...         self.patcher2 = patch('package.module.Class2')\n"
"...         self.MockClass1 = self.patcher1.start()\n"
"...         self.MockClass2 = self.patcher2.start()\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher1.stop()\n"
"...         self.patcher2.stop()\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class1 is self.MockClass1\n"
"...         assert package.module.Class2 is self.MockClass2\n"
"...\n"
">>> MyTest('test_something').run()"
msgstr ""

#: ../../library/unittest.mock.rst:1861
msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the ``setUp`` then ``tearDown`` is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"この方式を使う場合、必ず ``stop`` メソッドを呼び出してパッチが解除する必要が"
"あります。 ``setUp`` の中で例外が発生した場合 ``tearDown`` が呼び出されないの"
"で、これは意外に面倒です。 :meth:`unittest.TestCase.addCleanup` を使うと簡単"
"にできます::"

#: ../../library/unittest.mock.rst:1866
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('package.module.Class')\n"
"...         self.MockClass = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class is self.MockClass\n"
"..."
msgstr ""

#: ../../library/unittest.mock.rst:1876
msgid ""
"As an added bonus you no longer need to keep a reference to the ``patcher`` "
"object."
msgstr ""
"この方式を使うと ``patcher`` オブジェクトの参照を維持する必要がなくなるという"
"特典も付きます。"

#: ../../library/unittest.mock.rst:1879
msgid ""
"It is also possible to stop all patches which have been started by using :"
"func:`patch.stopall`."
msgstr ""
":func:`patch.stopall` を利用してすべての start されたパッチを stop することも"
"できます。"

#: ../../library/unittest.mock.rst:1884
msgid "Stop all active patches. Only stops patches started with ``start``."
msgstr ""
"すべての有効なパッチを stop します。 ``start`` で開始したパッチしか stop しま"
"せん。"

#: ../../library/unittest.mock.rst:1890
msgid "patch builtins"
msgstr "ビルトインをパッチする"

#: ../../library/unittest.mock.rst:1891
msgid ""
"You can patch any builtins within a module. The following example patches "
"builtin :func:`ord`::"
msgstr ""
"モジュール内の任意のビルトインに対してパッチを当てることができます。以下の例"
"はビルトインの :func:`ord` を修正します::"

#: ../../library/unittest.mock.rst:1894
msgid ""
">>> @patch('__main__.ord')\n"
"... def test(mock_ord):\n"
"...     mock_ord.return_value = 101\n"
"...     print(ord('c'))\n"
"...\n"
">>> test()\n"
"101"
msgstr ""

#: ../../library/unittest.mock.rst:1906
msgid "TEST_PREFIX"
msgstr "TEST_PREFIX"

#: ../../library/unittest.mock.rst:1908
msgid ""
"All of the patchers can be used as class decorators. When used in this way "
"they wrap every test method on the class. The patchers recognise methods "
"that start with ``'test'`` as being test methods. This is the same way that "
"the :class:`unittest.TestLoader` finds test methods by default."
msgstr ""
"すべての patcher はクラスデコレータとして利用できます。この場合、そのクラスの"
"すべてのテストメソッドをラップします。 patcher は ``'test'`` で始まる名前のメ"
"ソッドをテストメソッドだと認識します。これはデフォルトで :class:`unittest."
"TestLoader` がテストメソッドを見つける方法と同じです。"

#: ../../library/unittest.mock.rst:1913
msgid ""
"It is possible that you want to use a different prefix for your tests. You "
"can inform the patchers of the different prefix by setting ``patch."
"TEST_PREFIX``::"
msgstr ""
"他の prefix を使う事もできます。その場合、 patcher にその prefix を ``patch."
"TEST_PREFIX`` に設定することで教えることができます::"

#: ../../library/unittest.mock.rst:1916
msgid ""
">>> patch.TEST_PREFIX = 'foo'\n"
">>> value = 3\n"
">>>\n"
">>> @patch('__main__.value', 'not three')\n"
"... class Thing:\n"
"...     def foo_one(self):\n"
"...         print(value)\n"
"...     def foo_two(self):\n"
"...         print(value)\n"
"...\n"
">>>\n"
">>> Thing().foo_one()\n"
"not three\n"
">>> Thing().foo_two()\n"
"not three\n"
">>> value\n"
"3"
msgstr ""

#: ../../library/unittest.mock.rst:1936
msgid "Nesting Patch Decorators"
msgstr "patch デコレータをネストする"

#: ../../library/unittest.mock.rst:1938
msgid ""
"If you want to perform multiple patches then you can simply stack up the "
"decorators."
msgstr ""
"複数のパッチを行いたい場合、シンプルにデコレータを重ねることができます。"

#: ../../library/unittest.mock.rst:1941
msgid "You can stack up multiple patch decorators using this pattern:"
msgstr "次のパターンのように patch デコレータを重ねることができます:"

#: ../../library/unittest.mock.rst:1957
msgid ""
"Note that the decorators are applied from the bottom upwards. This is the "
"standard way that Python applies decorators. The order of the created mocks "
"passed into your test function matches this order."
msgstr ""
"デコレータは下から上へと適用されることに注意してください。これは Python がデ"
"コレータを適用する標準的な方法です。テスト関数に渡される生成された mock の順"
"番もこれに一致します。"

#: ../../library/unittest.mock.rst:1965
msgid "Where to patch"
msgstr "どこにパッチするか"

#: ../../library/unittest.mock.rst:1967
msgid ""
":func:`patch` works by (temporarily) changing the object that a *name* "
"points to with another one. There can be many names pointing to any "
"individual object, so for patching to work you must ensure that you patch "
"the name used by the system under test."
msgstr ""
":func:`patch` は (一時的に) ある *名前* が参照しているオブジェクトを別のもの"
"に変更することで適用されます。任意のオブジェクトには、それを参照するたくさん"
"の名前が存在しえます。なので、必ずテスト対象のシステムが使っている名前に対し"
"て patch しなければなりません。"

#: ../../library/unittest.mock.rst:1972
msgid ""
"The basic principle is that you patch where an object is *looked up*, which "
"is not necessarily the same place as where it is defined. A couple of "
"examples will help to clarify this."
msgstr ""
"基本的な原則は、オブジェクトが *ルックアップ* されるところにパッチすることで"
"す。その場所はオブジェクトが定義されたところとは限りません。これを説明するた"
"めにいくつかの例を挙げます。"

#: ../../library/unittest.mock.rst:1976
msgid ""
"Imagine we have a project that we want to test with the following structure::"
msgstr ""
"次のような構造を持ったプロジェクトをテストしようとしていると仮定してくださ"
"い::"

#: ../../library/unittest.mock.rst:1978
msgid ""
"a.py\n"
"    -> Defines SomeClass\n"
"\n"
"b.py\n"
"    -> from a import SomeClass\n"
"    -> some_function instantiates SomeClass"
msgstr ""

#: ../../library/unittest.mock.rst:1985
msgid ""
"Now we want to test ``some_function`` but we want to mock out ``SomeClass`` "
"using :func:`patch`. The problem is that when we import module b, which we "
"will have to do then it imports ``SomeClass`` from module a. If we use :func:"
"`patch` to mock out ``a.SomeClass`` then it will have no effect on our test; "
"module b already has a reference to the *real* ``SomeClass`` and it looks "
"like our patching had no effect."
msgstr ""
"いま、 ``some_function`` をテストしようとしていて、そのために ``SomeClass`` "
"を :func:`patch` を使って mock しようとしています。\n"
"モジュール b をインポートした時点で、 b は ``SomeClass`` を a からインポート"
"しています。この状態で ``a.SomeClass`` を :func:`patch` を使って mock out し"
"てもテストには影響しません。モジュール b はすでに *本物の* ``SomeClass`` への"
"参照を持っていて、パッチの影響を受けないからです。"

#: ../../library/unittest.mock.rst:1992
msgid ""
"The key is to patch out ``SomeClass`` where it is used (or where it is "
"looked up). In this case ``some_function`` will actually look up "
"``SomeClass`` in module b, where we have imported it. The patching should "
"look like::"
msgstr ""
"重要なのは、 ``SomeClass`` が使われている (もしくはルックアップされている) 場"
"所にパッチすることです。この場合、 ``some_function`` はモジュール b の中にイ"
"ンポートされた ``SomeClass`` をルックアップしています。なのでパッチは次のよう"
"にしなければなりません::"

#: ../../library/unittest.mock.rst:1996
msgid "@patch('b.SomeClass')"
msgstr ""

#: ../../library/unittest.mock.rst:1998
msgid ""
"However, consider the alternative scenario where instead of ``from a import "
"SomeClass`` module b does ``import a`` and ``some_function`` uses ``a."
"SomeClass``. Both of these import forms are common. In this case the class "
"we want to patch is being looked up in the module and so we have to patch "
"``a.SomeClass`` instead::"
msgstr ""
"ですが、別のシナリオとして、module b が ``from a import SomeClass`` ではなく "
"``import a`` をしていて、 ``some_function`` が ``a.SomeClass`` を利用していた"
"とします。どちらのインポートも一般的なものです。この場合、パッチしたいクラス"
"はそのモジュールからルックアップされているので、 ``a.SomeClass`` をパッチする"
"必要があります::"

#: ../../library/unittest.mock.rst:2003
msgid "@patch('a.SomeClass')"
msgstr ""

#: ../../library/unittest.mock.rst:2007
msgid "Patching Descriptors and Proxy Objects"
msgstr "デスクリプタやプロキシオブジェクトにパッチする"

#: ../../library/unittest.mock.rst:2009
msgid ""
"Both patch_ and patch.object_ correctly patch and restore descriptors: class "
"methods, static methods and properties. You should patch these on the "
"*class* rather than an instance. They also work with *some* objects that "
"proxy attribute access, like the `django settings object <https://web."
"archive.org/web/20200603181648/http://www.voidspace.org.uk/python/weblog/"
"arch_d7_2010_12_04.shtml#e1198>`_."
msgstr ""
"patch_ と patch.object_ はどちらも デスクリプタ (クラスメソッド、static メ"
"ソッド、プロパティ) を正しく patch できます。デスクリプタに patch する場合、"
"インスタンスではなく *class* にパッチする必要があります。これらはまた *幾らか"
"の* 属性アクセスをプロキシするオブジェクト、例えば `django の setttings オブ"
"ジェクト <https://web.archive.org/web/20200603181648/http://www.voidspace."
"org.uk/python/weblog/arch_d7_2010_12_04.shtml#e1198>`_ に対しても機能します。"

#: ../../library/unittest.mock.rst:2017
msgid "MagicMock and magic method support"
msgstr "MagicMock と magic method のサポート"

#: ../../library/unittest.mock.rst:2022
msgid "Mocking Magic Methods"
msgstr "Magic Method をモックする"

#: ../../library/unittest.mock.rst:2024
msgid ""
":class:`Mock` supports mocking the Python protocol methods, also known as :"
"term:`\"magic methods\" <magic method>`. This allows mock objects to replace "
"containers or other objects that implement Python protocols."
msgstr ""

#: ../../library/unittest.mock.rst:2028
msgid ""
"Because magic methods are looked up differently from normal methods [#]_, "
"this support has been specially implemented. This means that only specific "
"magic methods are supported. The supported list includes *almost* all of "
"them. If there are any missing that you need please let us know."
msgstr ""
"magic method は通常のメソッドとはルックアップ方法が異なるので [#]_, magic "
"method のサポートは特別に実装されています。そのため、サポートされているのは特"
"定の magic method のみです。*ほとんど* すべてのメソッドをサポートしています"
"が、足りないものを見つけたら私達に教えてください。"

#: ../../library/unittest.mock.rst:2033
msgid ""
"You mock magic methods by setting the method you are interested in to a "
"function or a mock instance. If you are using a function then it *must* take "
"``self`` as the first argument [#]_."
msgstr ""
"magic method を mock するには、対象の method に対して関数や mock のインスタン"
"スをセットします。もし関数を使う場合、それは第一引数に ``self`` を取る *必要"
"があります* [#]_."

#: ../../library/unittest.mock.rst:2056
msgid ""
"One use case for this is for mocking objects used as context managers in a :"
"keyword:`with` statement:"
msgstr ""
"ユースケースの1つは :keyword:`with` 文の中でコンテキストマネージャーとして使"
"われるオブジェクトを mock することです。"

#: ../../library/unittest.mock.rst:2068
msgid ""
"Calls to magic methods do not appear in :attr:`~Mock.method_calls`, but they "
"are recorded in :attr:`~Mock.mock_calls`."
msgstr ""
"magic method の呼び出しは :attr:`~Mock.method_calls` に含まれませんが、 :"
"attr:`~Mock.mock_calls` には記録されます。"

#: ../../library/unittest.mock.rst:2073
msgid ""
"If you use the *spec* keyword argument to create a mock then attempting to "
"set a magic method that isn't in the spec will raise an :exc:"
"`AttributeError`."
msgstr ""
"mock を生成するのに *spec* キーワード引数を使った場合、 spec に含まれない "
"magic method を設定しようとすると :exc:`AttributeError` が発生します。"

#: ../../library/unittest.mock.rst:2076
msgid "The full list of supported magic methods is:"
msgstr "サポートしている magic method の完全なリスト:"

#: ../../library/unittest.mock.rst:2078
msgid "``__hash__``, ``__sizeof__``, ``__repr__`` and ``__str__``"
msgstr "``__hash__``, ``__sizeof__``, ``__repr__``, ``__str__``"

#: ../../library/unittest.mock.rst:2079
msgid "``__dir__``, ``__format__`` and ``__subclasses__``"
msgstr "``__dir__``, ``__format__``, ``__subclasses__``"

#: ../../library/unittest.mock.rst:2080
msgid "``__round__``, ``__floor__``, ``__trunc__`` and ``__ceil__``"
msgstr "``__round__``, ``__floor__``, ``__trunc__`` と ``__ceil__``"

#: ../../library/unittest.mock.rst:2081
msgid ""
"Comparisons: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` and "
"``__ne__``"
msgstr ""
"比較: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__``, ``__ne__``"

#: ../../library/unittest.mock.rst:2083
msgid ""
"Container methods: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` and "
"``__missing__``"
msgstr ""
"コンテナメソッド: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__``,  "
"``__missing__``"

#: ../../library/unittest.mock.rst:2086
msgid ""
"Context manager: ``__enter__``, ``__exit__``, ``__aenter__`` and "
"``__aexit__``"
msgstr ""

#: ../../library/unittest.mock.rst:2087
msgid "Unary numeric methods: ``__neg__``, ``__pos__`` and ``__invert__``"
msgstr "単項算術メソッド: ``__neg__``, ``__pos__``, ``__invert__``"

#: ../../library/unittest.mock.rst:2088
msgid ""
"The numeric methods (including right hand and in-place variants): "
"``__add__``, ``__sub__``, ``__mul__``, ``__matmul__``, ``__truediv__``, "
"``__floordiv__``, ``__mod__``, ``__divmod__``, ``__lshift__``, "
"``__rshift__``, ``__and__``, ``__xor__``, ``__or__``, and ``__pow__``"
msgstr ""

#: ../../library/unittest.mock.rst:2092
msgid ""
"Numeric conversion methods: ``__complex__``, ``__int__``, ``__float__`` and "
"``__index__``"
msgstr ""
"算術変換メソッド: ``__complex__``, ``__int__``, ``__float__``,  ``__index__``"

#: ../../library/unittest.mock.rst:2094
msgid "Descriptor methods: ``__get__``, ``__set__`` and ``__delete__``"
msgstr "デスクリプタメソッド: ``__get__``, ``__set__``, ``__delete__``"

#: ../../library/unittest.mock.rst:2095
msgid ""
"Pickling: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` and ``__setstate__``"
msgstr ""
"pickle: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__``, ``__setstate__``"

#: ../../library/unittest.mock.rst:2097
msgid "File system path representation: ``__fspath__``"
msgstr ""

#: ../../library/unittest.mock.rst:2098
msgid "Asynchronous iteration methods: ``__aiter__`` and ``__anext__``"
msgstr ""

#: ../../library/unittest.mock.rst:2100
msgid "Added support for :func:`os.PathLike.__fspath__`."
msgstr ""

#: ../../library/unittest.mock.rst:2103
msgid ""
"Added support for ``__aenter__``, ``__aexit__``, ``__aiter__`` and "
"``__anext__``."
msgstr ""

#: ../../library/unittest.mock.rst:2107
msgid ""
"The following methods exist but are *not* supported as they are either in "
"use by mock, can't be set dynamically, or can cause problems:"
msgstr ""
"以下のメソッドは存在しますが、mock が利用している、動的に設定不可能、その他の"
"問題が発生する可能性があるなどの理由で *サポートされていません*:"

#: ../../library/unittest.mock.rst:2110
msgid "``__getattr__``, ``__setattr__``, ``__init__`` and ``__new__``"
msgstr "``__getattr__``, ``__setattr__``, ``__init__``, ``__new__``"

#: ../../library/unittest.mock.rst:2111
msgid ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"
msgstr ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"

#: ../../library/unittest.mock.rst:2116
msgid "Magic Mock"
msgstr "Magic Mock"

#: ../../library/unittest.mock.rst:2118
msgid ""
"There are two ``MagicMock`` variants: :class:`MagicMock` and :class:"
"`NonCallableMagicMock`."
msgstr ""
"``MagicMock`` 系のクラスは2種類あります: :class:`MagicMock` と :class:"
"`NonCallableMagicMock` です。"

#: ../../library/unittest.mock.rst:2123
msgid ""
"``MagicMock`` is a subclass of :class:`Mock` with default implementations of "
"most of the :term:`magic methods <magic method>`. You can use ``MagicMock`` "
"without having to configure the magic methods yourself."
msgstr ""

#: ../../library/unittest.mock.rst:2127
msgid "The constructor parameters have the same meaning as for :class:`Mock`."
msgstr "コンストラクタの引数は :class:`Mock` と同じ意味を持っています。"

#: ../../library/unittest.mock.rst:2129
msgid ""
"If you use the *spec* or *spec_set* arguments then *only* magic methods that "
"exist in the spec will be created."
msgstr ""
"*spec* か *spec_set* 引数を利用した場合、 spec に存在する magic method *のみ"
"* が生成されます。"

#: ../../library/unittest.mock.rst:2135
msgid "A non-callable version of :class:`MagicMock`."
msgstr "callable でないバージョンの :class:`MagicMock`"

#: ../../library/unittest.mock.rst:2137
msgid ""
"The constructor parameters have the same meaning as for :class:`MagicMock`, "
"with the exception of *return_value* and *side_effect* which have no meaning "
"on a non-callable mock."
msgstr ""
"コンストラクタの引数は :class:`MagicMock` と同じ意味を持ちますが、 "
"*return_value* と *side_effect* は callable でない mock では意味を持ちませ"
"ん。"

#: ../../library/unittest.mock.rst:2141
msgid ""
"The magic methods are setup with :class:`MagicMock` objects, so you can "
"configure them and use them in the usual way:"
msgstr ""
":class:`MagicMock` が magic method をセットアップするので、あとは通常の方法で"
"構成したり利用したりできます:"

#: ../../library/unittest.mock.rst:2151
msgid ""
"By default many of the protocol methods are required to return objects of a "
"specific type. These methods are preconfigured with a default return value, "
"so that they can be used without you having to do anything if you aren't "
"interested in the return value. You can still *set* the return value "
"manually if you want to change the default."
msgstr ""
"デフォルトでは、多くのプロトコルメソッドは特定の型の戻り値を要求されます。そ"
"れらのメソッドではその型のデフォルトの戻り値がデフォルトの戻り値として設定さ"
"れているので、戻り値に興味が有る場合以外は何もしなくても利用可能です。デフォ"
"ルトの値を変更したい場合は手動で戻り値を設定可能です。"

#: ../../library/unittest.mock.rst:2157
msgid "Methods and their defaults:"
msgstr "メソッドとそのデフォルト値:"

#: ../../library/unittest.mock.rst:2159
msgid "``__lt__``: :data:`NotImplemented`"
msgstr ""

#: ../../library/unittest.mock.rst:2160
msgid "``__gt__``: :data:`!NotImplemented`"
msgstr ""

#: ../../library/unittest.mock.rst:2161
msgid "``__le__``: :data:`!NotImplemented`"
msgstr ""

#: ../../library/unittest.mock.rst:2162
msgid "``__ge__``: :data:`!NotImplemented`"
msgstr ""

#: ../../library/unittest.mock.rst:2163
msgid "``__int__``: ``1``"
msgstr "``__int__``: ``1``"

#: ../../library/unittest.mock.rst:2164
msgid "``__contains__``: ``False``"
msgstr "``__contains__``: ``False``"

#: ../../library/unittest.mock.rst:2165
msgid "``__len__``: ``0``"
msgstr "``__len__``: ``0``"

#: ../../library/unittest.mock.rst:2166
msgid "``__iter__``: ``iter([])``"
msgstr "``__iter__``: ``iter([])``"

#: ../../library/unittest.mock.rst:2167
msgid "``__exit__``: ``False``"
msgstr "``__exit__``: ``False``"

#: ../../library/unittest.mock.rst:2168
msgid "``__aexit__``: ``False``"
msgstr "``__aexit__``: ``False``"

#: ../../library/unittest.mock.rst:2169
msgid "``__complex__``: ``1j``"
msgstr "``__complex__``: ``1j``"

#: ../../library/unittest.mock.rst:2170
msgid "``__float__``: ``1.0``"
msgstr "``__float__``: ``1.0``"

#: ../../library/unittest.mock.rst:2171
msgid "``__bool__``: ``True``"
msgstr "``__bool__``: ``True``"

#: ../../library/unittest.mock.rst:2172
msgid "``__index__``: ``1``"
msgstr "``__index__``: ``1``"

#: ../../library/unittest.mock.rst:2173
msgid "``__hash__``: default hash for the mock"
msgstr "``__hash__``: mock のデフォルトの hash"

#: ../../library/unittest.mock.rst:2174
msgid "``__str__``: default str for the mock"
msgstr "``__str__``: mock のデフォルトの str"

#: ../../library/unittest.mock.rst:2175
msgid "``__sizeof__``: default sizeof for the mock"
msgstr "``__sizeof__``: mock のデフォルトの sizeof"

#: ../../library/unittest.mock.rst:2177
msgid "For example:"
msgstr "例えば:"

#: ../../library/unittest.mock.rst:2189
msgid ""
"The two equality methods, :meth:`!__eq__` and :meth:`!__ne__`, are special. "
"They do the default equality comparison on identity, using the :attr:`~Mock."
"side_effect` attribute, unless you change their return value to return "
"something else::"
msgstr ""

#: ../../library/unittest.mock.rst:2194
msgid ""
">>> MagicMock() == 3\n"
"False\n"
">>> MagicMock() != 3\n"
"True\n"
">>> mock = MagicMock()\n"
">>> mock.__eq__.return_value = True\n"
">>> mock == 3\n"
"True"
msgstr ""

#: ../../library/unittest.mock.rst:2203
msgid ""
"The return value of :meth:`MagicMock.__iter__` can be any iterable object "
"and isn't required to be an iterator:"
msgstr ""
":meth:`MagicMock.__iter__` の return_value は任意の iterable で、イテレータで"
"ある必要はありません:"

#: ../../library/unittest.mock.rst:2213
msgid ""
"If the return value *is* an iterator, then iterating over it once will "
"consume it and subsequent iterations will result in an empty list:"
msgstr ""
"return_value が iterator であった場合、最初のイテレートでその iterator を消費"
"してしまい、2回目以降のイテレートの結果が空になってしまいます:"

#: ../../library/unittest.mock.rst:2222
msgid ""
"``MagicMock`` has all of the supported magic methods configured except for "
"some of the obscure and obsolete ones. You can still set these up if you "
"want."
msgstr ""
"``MagicMock`` はいくつかの曖昧であったり時代遅れなものをのぞいて、対応してい"
"る magic method を事前にセットアップします。自動でセットアップされていないも"
"のも必要なら手動でセットアップすることができます。"

#: ../../library/unittest.mock.rst:2225
msgid ""
"Magic methods that are supported but not setup by default in ``MagicMock`` "
"are:"
msgstr ""
"``MagicMock`` がサポートしているもののデフォルトではセットアップしない magic "
"method:"

#: ../../library/unittest.mock.rst:2227
msgid "``__subclasses__``"
msgstr "``__subclasses__``"

#: ../../library/unittest.mock.rst:2228
msgid "``__dir__``"
msgstr "``__dir__``"

#: ../../library/unittest.mock.rst:2229
msgid "``__format__``"
msgstr "``__format__``"

#: ../../library/unittest.mock.rst:2230
msgid "``__get__``, ``__set__`` and ``__delete__``"
msgstr "``__get__``, ``__set__``, ``__delete__``"

#: ../../library/unittest.mock.rst:2231
msgid "``__reversed__`` and ``__missing__``"
msgstr "``__reversed__``, ``__missing__``"

#: ../../library/unittest.mock.rst:2232
msgid ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``__getnewargs__``, "
"``__getstate__`` and ``__setstate__``"
msgstr ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``__getnewargs__``, "
"``__getstate__``, ``__setstate__``"

#: ../../library/unittest.mock.rst:2234
msgid "``__getformat__``"
msgstr ""

#: ../../library/unittest.mock.rst:2238
msgid ""
"Magic methods *should* be looked up on the class rather than the instance. "
"Different versions of Python are inconsistent about applying this rule. The "
"supported protocol methods should work with all supported versions of Python."
msgstr ""
"Magic method はインスタンスではなくクラスからルックアップされるはずです。"
"Python のバージョンによってこのルールが適用されるかどうかに違いがあります。サ"
"ポートされているプロトコルメソッドは、サポートされているすべての Python の"
"バージョンで動作するはずです。"

#: ../../library/unittest.mock.rst:2242
msgid ""
"The function is basically hooked up to the class, but each ``Mock`` instance "
"is kept isolated from the others."
msgstr ""
"関数はクラスまで hook しますが、各 ``Mock`` インスタンス間の独立性は保たれま"
"す。"

#: ../../library/unittest.mock.rst:2247
msgid "Helpers"
msgstr "ヘルパー"

#: ../../library/unittest.mock.rst:2250
msgid "sentinel"
msgstr "sentinel"

#: ../../library/unittest.mock.rst:2254
msgid ""
"The ``sentinel`` object provides a convenient way of providing unique "
"objects for your tests."
msgstr ""
"``sentinel`` オブジェクトはテストで必要なユニークなオブジェクトを簡単に提供し"
"ます。"

#: ../../library/unittest.mock.rst:2257
msgid ""
"Attributes are created on demand when you access them by name. Accessing the "
"same attribute will always return the same object. The objects returned have "
"a sensible repr so that test failure messages are readable."
msgstr ""
"属性はアクセス時にオンデマンドで生成されます。同じ属性に複数回アクセスすると"
"必ず同じオブジェクトが返されます。返されるオブジェクトは、テスト失敗のメッ"
"セージがわかりやすくなるように気が利いた repr を持ちます。"

#: ../../library/unittest.mock.rst:2261
msgid ""
"The ``sentinel`` attributes now preserve their identity when they are :mod:"
"`copied <copy>` or :mod:`pickled <pickle>`."
msgstr ""

#: ../../library/unittest.mock.rst:2265
msgid ""
"Sometimes when testing you need to test that a specific object is passed as "
"an argument to another method, or returned. It can be common to create named "
"sentinel objects to test this. :data:`sentinel` provides a convenient way of "
"creating and testing the identity of objects like this."
msgstr ""
"特定のオブジェクトが他のメソッドに引数として渡されることをテストしたり、返さ"
"れることをテストしたい場合があります。このテストのために名前がついた "
"sentinel オブジェクトを作るのが一般的です。 :data:`sentinel` はこのようなオブ"
"ジェクトを生成し、同一性をテストするのに便利な方法を提供します。"

#: ../../library/unittest.mock.rst:2270
msgid ""
"In this example we monkey patch ``method`` to return ``sentinel."
"some_object``:"
msgstr ""
"次の例では、 ``method`` が ``sentinel.some_object`` を返すようにモンキーパッ"
"チしています:"

#: ../../library/unittest.mock.rst:2282
msgid "DEFAULT"
msgstr "DEFAULT"

#: ../../library/unittest.mock.rst:2287
msgid ""
"The :data:`DEFAULT` object is a pre-created sentinel (actually ``sentinel."
"DEFAULT``). It can be used by :attr:`~Mock.side_effect` functions to "
"indicate that the normal return value should be used."
msgstr ""
":data:`DEFAULT` オブジェクトは事前に生成された sentinel (実際には ``sentinel."
"DEFAULT``) オブジェクトです。 :attr:`~Mock.side_effect` 関数が、通常の戻り値"
"を使うことを示すために使います。"

#: ../../library/unittest.mock.rst:2293
msgid "call"
msgstr "call"

#: ../../library/unittest.mock.rst:2297
msgid ""
":func:`call` is a helper object for making simpler assertions, for comparing "
"with :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, :attr:`~Mock."
"mock_calls` and :attr:`~Mock.method_calls`. :func:`call` can also be used "
"with :meth:`~Mock.assert_has_calls`."
msgstr ""
":func:`call` は :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, :attr:"
"`~Mock.mock_calls`, :attr:`~Mock.method_calls` と比較してより下端に assert で"
"きるようにするためのヘルパーオブジェクトです。 :func:`call` は :meth:`~Mock."
"assert_has_calls` と組み合わせて使うこともできます。"

#: ../../library/unittest.mock.rst:2310
msgid ""
"For a call object that represents multiple calls, :meth:`call_list` returns "
"a list of all the intermediate calls as well as the final call."
msgstr ""
"複数回の呼び出しを表す call オブジェクトに対して、 :meth:`call_list` はすべて"
"の途中の呼び出しと最終の呼び出しを含むリストを返します。"

#: ../../library/unittest.mock.rst:2314
msgid ""
"``call_list`` is particularly useful for making assertions on \"chained "
"calls\". A chained call is multiple calls on a single line of code. This "
"results in multiple entries in :attr:`~Mock.mock_calls` on a mock. Manually "
"constructing the sequence of calls can be tedious."
msgstr ""
"``call_list`` は特に \"chained call\" に対して assert するのに便利です。 "
"\"chained call\" は1行のコードにおける複数の呼び出しです。この結果は mock "
"の :attr:`~Mock.mock_calls` に複数の call エントリとして格納されます。この "
"call のシーケンスを手動で構築するのは退屈な作業になります。"

#: ../../library/unittest.mock.rst:2319
msgid ""
":meth:`~call.call_list` can construct the sequence of calls from the same "
"chained call:"
msgstr ""
":meth:`~call.call_list` は同じ chained call からその call のシーケンスを構築"
"することができます:"

#: ../../library/unittest.mock.rst:2336
msgid ""
"A ``call`` object is either a tuple of (positional args, keyword args) or "
"(name, positional args, keyword args) depending on how it was constructed. "
"When you construct them yourself this isn't particularly interesting, but "
"the ``call`` objects that are in the :attr:`Mock.call_args`, :attr:`Mock."
"call_args_list` and :attr:`Mock.mock_calls` attributes can be introspected "
"to get at the individual arguments they contain."
msgstr ""
"``call`` オブジェクトは、どう構築されたかによって、 (位置引数、キーワード引"
"数) のタプルか、 (名前、位置引数、キーワード引数) のタプルになります。自分で "
"call オブジェクトを構築するときはこれを意識する必要はありませんが、 :attr:"
"`Mock.call_args`, :attr:`Mock.call_args_list`, :attr:`Mock.mock_calls` 属性の"
"中の ``call`` オブジェクトを解析して個々の引数を解析することができます。"

#: ../../library/unittest.mock.rst:2343
msgid ""
"The ``call`` objects in :attr:`Mock.call_args` and :attr:`Mock."
"call_args_list` are two-tuples of (positional args, keyword args) whereas "
"the ``call`` objects in :attr:`Mock.mock_calls`, along with ones you "
"construct yourself, are three-tuples of (name, positional args, keyword "
"args)."
msgstr ""
":attr:`Mock.call_args` と :attr:`Mock.call_args_list` の中の ``call`` オブ"
"ジェクトは (位置引数, キーワード引数) のタプルで、 :attr:`Mock.mock_calls` の"
"中の ``call`` オブジェクトや自分で構築したオブジェクトは (名前, 位置引数, "
"キーワード引数) のタプルになります。"

#: ../../library/unittest.mock.rst:2348
msgid ""
"You can use their \"tupleness\" to pull out the individual arguments for "
"more complex introspection and assertions. The positional arguments are a "
"tuple (an empty tuple if there are no positional arguments) and the keyword "
"arguments are a dictionary:"
msgstr ""
"call オブジェクトの \"タプル性\" を使って、より複雑な内省とアサートを行うため"
"に各引数を取り出しすことができます。位置引数はタプル (位置引数が存在しない場"
"合は空のタプル) で、キーワード引数は辞書になります:"

#: ../../library/unittest.mock.rst:2381
msgid "create_autospec"
msgstr "create_autospec"

#: ../../library/unittest.mock.rst:2385
msgid ""
"Create a mock object using another object as a spec. Attributes on the mock "
"will use the corresponding attribute on the *spec* object as their spec."
msgstr ""
"他のオブジェクトを spec として利用して mock オブジェクトを作ります。 mock の"
"属性も、 *spec* オブジェクトの該当する属性を spec として利用します。"

#: ../../library/unittest.mock.rst:2389
msgid ""
"Functions or methods being mocked will have their arguments checked to "
"ensure that they are called with the correct signature."
msgstr ""
"mock された関数やメソッドは、正しいシグネチャで呼び出されたことを確認するため"
"に引数をチェックします。"

#: ../../library/unittest.mock.rst:2392
msgid ""
"If *spec_set* is ``True`` then attempting to set attributes that don't exist "
"on the spec object will raise an :exc:`AttributeError`."
msgstr ""
"*spec_set* が ``True`` のとき、 spec オブジェクトにない属性をセットしようとす"
"ると :exc:`AttributeError` を発生させます。"

#: ../../library/unittest.mock.rst:2395
msgid ""
"If a class is used as a spec then the return value of the mock (the instance "
"of the class) will have the same spec. You can use a class as the spec for "
"an instance object by passing ``instance=True``. The returned mock will only "
"be callable if instances of the mock are callable."
msgstr ""
"spec にクラスが指定された場合、 mock の戻り値 (そのクラスのインスタンス) は同"
"じ spec を持ちます。 ``instance=True`` を指定すると、インスタンスオブジェクト"
"の spec としてクラスを利用できます。返される mock は、モックのインスタンスが "
"callable な場合にだけ callable となります。"

#: ../../library/unittest.mock.rst:2400
msgid ""
":func:`create_autospec` also takes arbitrary keyword arguments that are "
"passed to the constructor of the created mock."
msgstr ""
":func:`create_autospec` は任意のキーワード引数を受け取り、生成する mock のコ"
"ンストラクタに渡します。"

#: ../../library/unittest.mock.rst:2403
msgid ""
"See :ref:`auto-speccing` for examples of how to use auto-speccing with :func:"
"`create_autospec` and the *autospec* argument to :func:`patch`."
msgstr ""
":func:`create_autospec` や、 :func:`patch` の *autospec* 引数で autospec を使"
"うサンプルは :ref:`auto-speccing` を参照してください。"

#: ../../library/unittest.mock.rst:2409
msgid ""
":func:`create_autospec` now returns an :class:`AsyncMock` if the target is "
"an async function."
msgstr ""

#: ../../library/unittest.mock.rst:2414
msgid "ANY"
msgstr "ANY"

#: ../../library/unittest.mock.rst:2418
msgid ""
"Sometimes you may need to make assertions about *some* of the arguments in a "
"call to mock, but either not care about some of the arguments or want to "
"pull them individually out of :attr:`~Mock.call_args` and make more complex "
"assertions on them."
msgstr ""
"mock の呼び出しのうち *幾つか* の引数に対して assert したいけれども、それ以外"
"の引数は気にしない、あるいは :attr:`~Mock.call_args` から個別に取り出してより"
"高度な assert を行いたい場合があります。"

#: ../../library/unittest.mock.rst:2423
msgid ""
"To ignore certain arguments you can pass in objects that compare equal to "
"*everything*. Calls to :meth:`~Mock.assert_called_with` and :meth:`~Mock."
"assert_called_once_with` will then succeed no matter what was passed in."
msgstr ""
"特定の引数を無視するために、 *すべて* と等しくなるオブジェクトを使うことがで"
"きます。そうすると、 :meth:`~Mock.assert_called_with` と :meth:`~Mock."
"assert_called_once_with` は、実際の引数が何であったかに関わらず成功します。"

#: ../../library/unittest.mock.rst:2432
msgid ""
":data:`ANY` can also be used in comparisons with call lists like :attr:"
"`~Mock.mock_calls`:"
msgstr ""
":attr:`~Mock.mock_calls` などの call list との比較に :attr:`ANY` を使うことも"
"できます:"

#: ../../library/unittest.mock.rst:2442
msgid ""
":data:`ANY` is not limited to comparisons with call objects and so can also "
"be used in test assertions::"
msgstr ""

#: ../../library/unittest.mock.rst:2445
msgid ""
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', ANY])"
msgstr ""

#: ../../library/unittest.mock.rst:2453
msgid "FILTER_DIR"
msgstr "FILTER_DIR"

#: ../../library/unittest.mock.rst:2457
msgid ""
":data:`FILTER_DIR` is a module level variable that controls the way mock "
"objects respond to :func:`dir`. The default is ``True``, which uses the "
"filtering described below, to only show useful members. If you dislike this "
"filtering, or need to switch it off for diagnostic purposes, then set ``mock."
"FILTER_DIR = False``."
msgstr ""
":data:`FILTER_DIR` は mock オブジェクトが :func:`dir` に何を返すかを制御する"
"ためのモジュールレベル変数です。デフォルトは ``True`` で、以下に示すフィルタ"
"リングを行い、有用なメンバーだけを表示します。このフィルタリングが嫌な場合"
"や、何かの診断のためにフィルタリングを切りたい場合は、 ``mock.FILTER_DIR = "
"False`` と設定してください。"

#: ../../library/unittest.mock.rst:2463
msgid ""
"With filtering on, ``dir(some_mock)`` shows only useful attributes and will "
"include any dynamically created attributes that wouldn't normally be shown. "
"If the mock was created with a *spec* (or *autospec* of course) then all the "
"attributes from the original are shown, even if they haven't been accessed "
"yet:"
msgstr ""
"フィルタリングが有効な場合、 ``dir(some_mock)`` は有用な属性だけを表示し、ま"
"た通常は表示されない動的に生成される属性も表示します。 mock が *spec* を使っ"
"て(もちろん *autospec* でも)生成された場合、元のオブジェクトのすべての属性"
"が、まだアクセスされていなかったとしても、表示されます。"

#: ../../library/unittest.mock.rst:2469
msgid ""
">>> dir(Mock())\n"
"['assert_any_call',\n"
" 'assert_called',\n"
" 'assert_called_once',\n"
" 'assert_called_once_with',\n"
" 'assert_called_with',\n"
" 'assert_has_calls',\n"
" 'assert_not_called',\n"
" 'attach_mock',\n"
" ...\n"
">>> from urllib import request\n"
">>> dir(Mock(spec=request))\n"
"['AbstractBasicAuthHandler',\n"
" 'AbstractDigestAuthHandler',\n"
" 'AbstractHTTPHandler',\n"
" 'BaseHandler',\n"
" ..."
msgstr ""

#: ../../library/unittest.mock.rst:2490
msgid ""
"Many of the not-very-useful (private to :class:`Mock` rather than the thing "
"being mocked) underscore and double underscore prefixed attributes have been "
"filtered from the result of calling :func:`dir` on a :class:`Mock`. If you "
"dislike this behaviour you can switch it off by setting the module level "
"switch :data:`FILTER_DIR`:"
msgstr ""
"多くのあまり有用ではない (mock 対象のものではなく、 :class:`Mock` 自身のプラ"
"イベートな) 属性は、アンダースコアと2つのアンダースコアで prefix された属性"
"は :class:`Mock` に対して :func:`dir` した結果からフィルタリングされます。こ"
"の動作が嫌な場合は、モジュールレベルの :data:`FILTER_DIR` スイッチを設定する"
"ことでフィルターを切ることができます。"

#: ../../library/unittest.mock.rst:2496
msgid ""
">>> from unittest import mock\n"
">>> mock.FILTER_DIR = False\n"
">>> dir(mock.Mock())\n"
"['_NonCallableMock__get_return_value',\n"
" '_NonCallableMock__get_side_effect',\n"
" '_NonCallableMock__return_value_doc',\n"
" '_NonCallableMock__set_return_value',\n"
" '_NonCallableMock__set_side_effect',\n"
" '__call__',\n"
" '__class__',\n"
" ..."
msgstr ""

#: ../../library/unittest.mock.rst:2511
msgid ""
"Alternatively you can just use ``vars(my_mock)`` (instance members) and "
"``dir(type(my_mock))`` (type members) to bypass the filtering irrespective "
"of :const:`mock.FILTER_DIR`."
msgstr ""

#: ../../library/unittest.mock.rst:2517
msgid "mock_open"
msgstr "mock_open"

#: ../../library/unittest.mock.rst:2521
msgid ""
"A helper function to create a mock to replace the use of :func:`open`. It "
"works for :func:`open` called directly or used as a context manager."
msgstr ""
":func:`open` の利用を置き換えるための mock を作るヘルパー関数。 :func:`open` "
"を直接呼んだりコンテキストマネージャーとして利用する場合に使うことができま"
"す。"

#: ../../library/unittest.mock.rst:2524
msgid ""
"The *mock* argument is the mock object to configure. If ``None`` (the "
"default) then a :class:`MagicMock` will be created for you, with the API "
"limited to methods or attributes available on standard file handles."
msgstr ""
"*mock* 引数は構成する mock オブジェクトです。 ``None`` (デフォルト) なら、通"
"常のファイルハンドルと同じ属性やメソッドにAPIが制限された :class:`MagicMock` "
"が生成されます。"

#: ../../library/unittest.mock.rst:2528
msgid ""
"*read_data* is a string for the :meth:`~io.IOBase.read`, :meth:`~io.IOBase."
"readline`, and :meth:`~io.IOBase.readlines` methods of the file handle to "
"return.  Calls to those methods will take data from *read_data* until it is "
"depleted.  The mock of these methods is pretty simplistic: every time the "
"*mock* is called, the *read_data* is rewound to the start.  If you need more "
"control over the data that you are feeding to the tested code you will need "
"to customize this mock for yourself.  When that is insufficient, one of the "
"in-memory filesystem packages on `PyPI <https://pypi.org>`_ can offer a "
"realistic filesystem for testing."
msgstr ""
"*read_data* は、ファイルハンドルの :meth:`~io.IOBase.read`, :meth:`~io."
"IOBase.readline`, そして :meth:`~io.IOBase.readlines` のメソッドが返す文字列"
"です。これらのメソッドを呼び出すと、読み出し終わるまで *read_data* からデータ"
"が読み出されます。これらモックのメソッドはとても単純化されています: *mock* が"
"呼ばれるたびに *read_data* は先頭に巻き戻されます。テストコードに与えるデータ"
"をさらにコントロールするには自分自身でモックをカスタマイズする必要がありま"
"す。それでも不十分な場合は、 `PyPI <https://pypi.org>`_ にあるインメモリファ"
"イルシステムパッケージのうちのどれかを使えば、テストのための本物のファイルシ"
"ステムが得られるでしょう。"

#: ../../library/unittest.mock.rst:2538
msgid ""
"Added :meth:`~io.IOBase.readline` and :meth:`~io.IOBase.readlines` support. "
"The mock of :meth:`~io.IOBase.read` changed to consume *read_data* rather "
"than returning it on each call."
msgstr ""
":meth:`~io.IOBase.readline` および :meth:`~io.IOBase.readlines` のサポートが"
"追加されました。 :meth:`~io.IOBase.read` のモックは、個々の呼び出しで "
"*read_data* を返すのではなく、それを消費するように変わりました。"

#: ../../library/unittest.mock.rst:2543
msgid "*read_data* is now reset on each call to the *mock*."
msgstr ""
"*read_data* は *mock* を呼び出す度に毎回リセットされるようになりました。"

#: ../../library/unittest.mock.rst:2546
msgid ""
"Added :meth:`~container.__iter__` to implementation so that iteration (such "
"as in for loops) correctly consumes *read_data*."
msgstr ""

#: ../../library/unittest.mock.rst:2550
msgid ""
"Using :func:`open` as a context manager is a great way to ensure your file "
"handles are closed properly and is becoming common::"
msgstr ""
":func:`open` をコンテキストマネージャーとして使う方法は、ファイルが必ず適切に"
"閉じられるようにする素晴らしい方法で、今では一般的になっています::"

#: ../../library/unittest.mock.rst:2553
msgid ""
"with open('/some/path', 'w') as f:\n"
"    f.write('something')"
msgstr ""

#: ../../library/unittest.mock.rst:2556
msgid ""
"The issue is that even if you mock out the call to :func:`open` it is the "
"*returned object* that is used as a context manager (and has :meth:`~object."
"__enter__` and :meth:`~object.__exit__` called)."
msgstr ""

#: ../../library/unittest.mock.rst:2560
msgid ""
"Mocking context managers with a :class:`MagicMock` is common enough and "
"fiddly enough that a helper function is useful. ::"
msgstr ""
"コンテキストマネージャーを :class:`MagicMock` でモックするのは一般的かつ面倒"
"なので、ヘルパー関数を用意しています。::"

#: ../../library/unittest.mock.rst:2563
msgid ""
">>> m = mock_open()\n"
">>> with patch('__main__.open', m):\n"
"...     with open('foo', 'w') as h:\n"
"...         h.write('some stuff')\n"
"...\n"
">>> m.mock_calls\n"
"[call('foo', 'w'),\n"
" call().__enter__(),\n"
" call().write('some stuff'),\n"
" call().__exit__(None, None, None)]\n"
">>> m.assert_called_once_with('foo', 'w')\n"
">>> handle = m()\n"
">>> handle.write.assert_called_once_with('some stuff')"
msgstr ""

#: ../../library/unittest.mock.rst:2577
msgid "And for reading files::"
msgstr "ファイルの読み込みをモックする例::"

#: ../../library/unittest.mock.rst:2579
msgid ""
">>> with patch('__main__.open', mock_open(read_data='bibble')) as m:\n"
"...     with open('foo') as h:\n"
"...         result = h.read()\n"
"...\n"
">>> m.assert_called_once_with('foo')\n"
">>> assert result == 'bibble'"
msgstr ""

#: ../../library/unittest.mock.rst:2590
msgid "Autospeccing"
msgstr "autospec を使う"

#: ../../library/unittest.mock.rst:2592
msgid ""
"Autospeccing is based on the existing :attr:`spec` feature of mock. It "
"limits the api of mocks to the api of an original object (the spec), but it "
"is recursive (implemented lazily) so that attributes of mocks only have the "
"same api as the attributes of the spec. In addition mocked functions / "
"methods have the same call signature as the original so they raise a :exc:"
"`TypeError` if they are called incorrectly."
msgstr ""
"autospec は mock の :attr:`spec` 機能を基盤にしています。 autospec は mock "
"の API を元のオブジェクト (spec) に制限しますが、再帰的に適用される (lazy に"
"実装されている) ので、 mock の属性も spec の属性と同じ API だけを持つようにな"
"ります。さらに、 mock された関数/メソッドは元と同じシグネチャを持ち、正しくな"
"い引数で呼び出されると :exc:`TypeError` を発生させます。"

#: ../../library/unittest.mock.rst:2599
msgid "Before I explain how auto-speccing works, here's why it is needed."
msgstr ""
"autospec の動作について説明する前に、それが必要となる背景から説明していきま"
"す。"

#: ../../library/unittest.mock.rst:2601
msgid ""
":class:`Mock` is a very powerful and flexible object, but it suffers from a "
"flaw which is general to mocking. If you refactor some of your code, rename "
"members and so on, any tests for code that is still using the *old api* but "
"uses mocks instead of the real objects will still pass. This means your "
"tests can all pass even though your code is broken."
msgstr ""

#: ../../library/unittest.mock.rst:2609
msgid ""
"Before 3.5, tests with a typo in the word assert would silently pass when "
"they should raise an error. You can still achieve this behavior by passing "
"``unsafe=True`` to Mock."
msgstr ""

#: ../../library/unittest.mock.rst:2612
msgid ""
"Note that this is another reason why you need integration tests as well as "
"unit tests. Testing everything in isolation is all fine and dandy, but if "
"you don't test how your units are \"wired together\" there is still lots of "
"room for bugs that tests might have caught."
msgstr ""
"各ユニットが互いにどのように接続されるかをテストしない場合、依然としてテスト"
"で見つけることができるバグの余地が多く残っています。"

#: ../../library/unittest.mock.rst:2617
msgid ""
":mod:`mock` already provides a feature to help with this, called speccing. "
"If you use a class or instance as the :attr:`spec` for a mock then you can "
"only access attributes on the mock that exist on the real class:"
msgstr ""
":mod:`mock` はこの問題に対処するために spec と呼ばれる機能を提供しています。"
"何かクラスかインスタンスを :attr:`spec` として mock に渡すと、実際のクラスに"
"存在する属性にしか、 mock に対してもアクセスできなくなります:"

#: ../../library/unittest.mock.rst:2628
msgid ""
"The spec only applies to the mock itself, so we still have the same issue "
"with any methods on the mock:"
msgstr ""
"spec はその mock 自体にしか適用されません。なので、同じ問題がその mock のすべ"
"てのメソッドに対して発生します:"

#: ../../library/unittest.mock.rst:2631
msgid ""
">>> mock.has_data()\n"
"<mock.Mock object at 0x...>\n"
">>> mock.has_data.assret_called_with()  # Intentional typo!"
msgstr ""

#: ../../library/unittest.mock.rst:2637
msgid ""
"Auto-speccing solves this problem. You can either pass ``autospec=True`` to :"
"func:`patch` / :func:`patch.object` or use the :func:`create_autospec` "
"function to create a mock with a spec. If you use the ``autospec=True`` "
"argument to :func:`patch` then the object that is being replaced will be "
"used as the spec object. Because the speccing is done \"lazily\" (the spec "
"is created as attributes on the mock are accessed) you can use it with very "
"complex or deeply nested objects (like modules that import modules that "
"import modules) without a big performance hit."
msgstr ""
"autospec はこの問題を解決します。 :func:`patch` か :func:`patch.object` に "
"``autospec=True`` を渡すか、 :func:`create_autospec` 関数を使って spec をもと"
"に mock を作ることができます。 :func:`patch` の引数に ``autospec=True`` を渡"
"した場合、置換対象のオブジェクトが spec オブジェクトとして利用されます。 "
"spec は遅延処理される (mock の属性にアクセスされた時に spec が生成される) の"
"で、非常に複雑だったり深くネストしたオブジェクト (例えばモジュールをインポー"
"トするモジュールをインポートするモジュール) に対しても大きなパフォーマンスの"
"問題なしに autospec を使うことができます。"

#: ../../library/unittest.mock.rst:2646
msgid "Here's an example of it in use::"
msgstr "autospec の利用例::"

#: ../../library/unittest.mock.rst:2648
msgid ""
">>> from urllib import request\n"
">>> patcher = patch('__main__.request', autospec=True)\n"
">>> mock_request = patcher.start()\n"
">>> request is mock_request\n"
"True\n"
">>> mock_request.Request\n"
"<MagicMock name='request.Request' spec='Request' id='...'>"
msgstr ""

#: ../../library/unittest.mock.rst:2656
msgid ""
"You can see that :class:`request.Request` has a spec. :class:`request."
"Request` takes two arguments in the constructor (one of which is *self*). "
"Here's what happens if we try to call it incorrectly::"
msgstr ""
":class:`request.Request` が spec を持っているのが分かります。 :class:"
"`request.Request` のコンストラクタは2つの引数を持っています (片方は *self* で"
"す)。コンストラクタを間違って呼び出した時に何が起こるでしょうか::"

#: ../../library/unittest.mock.rst:2660
msgid ""
">>> req = request.Request()\n"
"Traceback (most recent call last):\n"
" ...\n"
"TypeError: <lambda>() takes at least 2 arguments (1 given)"
msgstr ""

#: ../../library/unittest.mock.rst:2665
msgid ""
"The spec also applies to instantiated classes (i.e. the return value of "
"specced mocks)::"
msgstr ""
"spec はクラスがインスタンス化されたとき (つまり spec が適用された mock の戻り"
"値) にも適用されます::"

#: ../../library/unittest.mock.rst:2668
msgid ""
">>> req = request.Request('foo')\n"
">>> req\n"
"<NonCallableMagicMock name='request.Request()' spec='Request' id='...'>"
msgstr ""

#: ../../library/unittest.mock.rst:2672
msgid ""
":class:`Request` objects are not callable, so the return value of "
"instantiating our mocked out :class:`request.Request` is a non-callable "
"mock. With the spec in place any typos in our asserts will raise the correct "
"error::"
msgstr ""
":class:`Request` オブジェクトは callable ではないので、 :class:`request."
"Request` の mock から返されたインスタンスの mock は callable ではなくなりま"
"す。 spec があれば、 assert のミススペルは正しいエラーを発生させます::"

#: ../../library/unittest.mock.rst:2676
msgid ""
">>> req.add_header('spam', 'eggs')\n"
"<MagicMock name='request.Request().add_header()' id='...'>\n"
">>> req.add_header.assret_called_with  # Intentional typo!\n"
"Traceback (most recent call last):\n"
" ...\n"
"AttributeError: Mock object has no attribute 'assret_called_with'\n"
">>> req.add_header.assert_called_with('spam', 'eggs')"
msgstr ""

#: ../../library/unittest.mock.rst:2684
msgid ""
"In many cases you will just be able to add ``autospec=True`` to your "
"existing :func:`patch` calls and then be protected against bugs due to typos "
"and api changes."
msgstr ""
"多くの場合、単に既存の :func:`patch` 呼び出しに ``autospec=True`` を加えるだ"
"けで、ミススペルやAPI変更に伴うバグから守られます。"

#: ../../library/unittest.mock.rst:2688
msgid ""
"As well as using *autospec* through :func:`patch` there is a :func:"
"`create_autospec` for creating autospecced mocks directly:"
msgstr ""
":func:`patch` を経由する以外にも、 :func:`create_autospec` を使って "
"*autospec* が適用された mock を直接作る方法もあります:"

#: ../../library/unittest.mock.rst:2696
msgid ""
"This isn't without caveats and limitations however, which is why it is not "
"the default behaviour. In order to know what attributes are available on the "
"spec object, autospec has to introspect (access attributes) the spec. As you "
"traverse attributes on the mock a corresponding traversal of the original "
"object is happening under the hood. If any of your specced objects have "
"properties or descriptors that can trigger code execution then you may not "
"be able to use autospec. On the other hand it is much better to design your "
"objects so that introspection is safe [#]_."
msgstr ""
"とはいえ、autospec には注意しなければならない点や制限があり、そのためデフォル"
"トでは無効になっています。spec オブジェクトでどんな属性が使えるかどうかを調べ"
"るために、autospec は spec オブジェクトをイントロスペクト (実際に属性にアクセ"
"スする) 必要があります。mock の属性を利用するとき、水面下で元のオブジェクトに"
"対しても同じ属性の探索が行われます。spec したオブジェクトのどれかがコードを実"
"行するプロパティやデスクリプタを持っている場合、autospec は正しく動きません。"
"もしくは、イントロスペクションしても安全なようにオブジェクトを設計するのがよ"
"いでしょう [#]_。"

#: ../../library/unittest.mock.rst:2705
msgid ""
"A more serious problem is that it is common for instance attributes to be "
"created in the :meth:`~object.__init__` method and not to exist on the class "
"at all. *autospec* can't know about any dynamically created attributes and "
"restricts the api to visible attributes. ::"
msgstr ""

#: ../../library/unittest.mock.rst:2710
msgid ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: Mock object has no attribute 'a'"
msgstr ""

#: ../../library/unittest.mock.rst:2722
msgid ""
"There are a few different ways of resolving this problem. The easiest, but "
"not necessarily the least annoying, way is to simply set the required "
"attributes on the mock after creation. Just because *autospec* doesn't allow "
"you to fetch attributes that don't exist on the spec it doesn't prevent you "
"setting them::"
msgstr ""
"この問題を解決するためにいくつかの方法があります。一番簡単な、ただし一番面倒"
"でないとは限らない方法は、必要とされる属性を mock が生成された後に設定するこ"
"とです。 *autospec* は属性を参照することを禁止しますが、設定することは禁止し"
"ていません::"

#: ../../library/unittest.mock.rst:2728
msgid ""
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a = 33\n"
"..."
msgstr ""

#: ../../library/unittest.mock.rst:2733
msgid ""
"There is a more aggressive version of both *spec* and *autospec* that *does* "
"prevent you setting non-existent attributes. This is useful if you want to "
"ensure your code only *sets* valid attributes too, but obviously it prevents "
"this particular scenario:"
msgstr ""
"*spec* と *autospec* にはよりアグレッシブなバージョンがあり、存在しない属性へ"
"の設定も禁止します。これはコードが正しい属性にのみ代入することを保証したいと"
"きに便利ですが、もちろん先ほどの方法も制限されてしまいます:"

#: ../../library/unittest.mock.rst:2746
msgid ""
"Probably the best way of solving the problem is to add class attributes as "
"default values for instance members initialised in :meth:`~object.__init__`. "
"Note that if you are only setting default attributes in :meth:`!__init__` "
"then providing them via class attributes (shared between instances of "
"course) is faster too. e.g."
msgstr ""

#: ../../library/unittest.mock.rst:2752
msgid ""
"class Something:\n"
"    a = 33"
msgstr ""

#: ../../library/unittest.mock.rst:2757
msgid ""
"This brings up another issue. It is relatively common to provide a default "
"value of ``None`` for members that will later be an object of a different "
"type. ``None`` would be useless as a spec because it wouldn't let you access "
"*any* attributes or methods on it. As ``None`` is *never* going to be useful "
"as a spec, and probably indicates a member that will normally of some other "
"type, autospec doesn't use a spec for members that are set to ``None``. "
"These will just be ordinary mocks (well - MagicMocks):"
msgstr ""
"クラス属性を使ってもまた別の問題があります。メンバーのデフォルト値に "
"``None`` を利用し、後から別の型のオブジェクトを代入するのは比較的よくあるパ"
"ターンです。 spec として ``None`` を使うと *すべての* 属性やメソッドへのアク"
"セスも許されなくなるので使い物になりません。 ``None`` を spec にすることが有"
"用な場面は *決して* なく、おそらくそのメンバーは他の何かの型のメンバーになる"
"ことを示すので、 autospec は ``None`` に設定されているメンバーには spec を使"
"いません。その属性は通常の mock (MagicMocks) になります。"

#: ../../library/unittest.mock.rst:2772
msgid ""
"If modifying your production classes to add defaults isn't to your liking "
"then there are more options. One of these is simply to use an instance as "
"the spec rather than the class. The other is to create a subclass of the "
"production class and add the defaults to the subclass without affecting the "
"production class. Both of these require you to use an alternative object as "
"the spec. Thankfully :func:`patch` supports this - you can simply pass the "
"alternative object as the *autospec* argument::"
msgstr ""
"すでに利用されているクラスにデフォルト値属性を追加するのが嫌な場合は、他の選"
"択肢もあります。選択肢の1つは、クラスではなくインスタンスを spec に使うことで"
"す。別の選択肢は、実際のクラスのサブクラスを作り、実際に利用されている方に影"
"響を与えずにデフォルト値属性を追加することです。どちらの方法も spec として代"
"替オブジェクトを利用することが必要です。 :func:`patch` はこれをサポートしてい"
"て、 *autospec* 引数に代替オブジェクトを渡すことができます::"

#: ../../library/unittest.mock.rst:2780
msgid ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> class SomethingForTest(Something):\n"
"...   a = 33\n"
"...\n"
">>> p = patch('__main__.Something', autospec=SomethingForTest)\n"
">>> mock = p.start()\n"
">>> mock.a\n"
"<NonCallableMagicMock name='Something.a' spec='int' id='...'>"
msgstr ""

#: ../../library/unittest.mock.rst:2793
msgid ""
"This only applies to classes or already instantiated objects. Calling a "
"mocked class to create a mock instance *does not* create a real instance. It "
"is only attribute lookups - along with calls to :func:`dir` - that are done."
msgstr ""
"これはクラスやすでにインスタンス化されたオブジェクトにだけ当てはまります。 "
"mock されたクラスを呼び出して mock インスタンスを作っても、実際のオブジェクト"
"のインスタンスは生成されません。\n"
"mock は属性を - :func:`dir` を呼び出して - 検索するだけです。"

#: ../../library/unittest.mock.rst:2798
msgid "Sealing mocks"
msgstr ""

#: ../../library/unittest.mock.rst:2807
msgid ""
"Seal will disable the automatic creation of mocks when accessing an "
"attribute of the mock being sealed or any of its attributes that are already "
"mocks recursively."
msgstr ""

#: ../../library/unittest.mock.rst:2810
msgid ""
"If a mock instance with a name or a spec is assigned to an attribute it "
"won't be considered in the sealing chain. This allows one to prevent seal "
"from fixing part of the mock object. ::"
msgstr ""

#: ../../library/unittest.mock.rst:2814
msgid ""
">>> mock = Mock()\n"
">>> mock.submock.attribute1 = 2\n"
">>> mock.not_submock = mock.Mock(name=\"sample_name\")\n"
">>> seal(mock)\n"
">>> mock.new_attribute  # This will raise AttributeError.\n"
">>> mock.submock.attribute2  # This will raise AttributeError.\n"
">>> mock.not_submock.attribute2  # This won't raise."
msgstr ""

#: ../../library/unittest.mock.rst:2826
msgid ""
"Order of precedence of :attr:`side_effect`, :attr:`return_value` and *wraps*"
msgstr ""

#: ../../library/unittest.mock.rst:2828
msgid "The order of their precedence is:"
msgstr ""

#: ../../library/unittest.mock.rst:2830
msgid ":attr:`~Mock.side_effect`"
msgstr ""

#: ../../library/unittest.mock.rst:2831
msgid ":attr:`~Mock.return_value`"
msgstr ""

#: ../../library/unittest.mock.rst:2832
msgid "*wraps*"
msgstr ""

#: ../../library/unittest.mock.rst:2834
msgid ""
"If all three are set, mock will return the value from :attr:`~Mock."
"side_effect`, ignoring :attr:`~Mock.return_value` and the wrapped object "
"altogether. If any two are set, the one with the higher precedence will "
"return the value. Regardless of the order of which was set first, the order "
"of precedence remains unchanged."
msgstr ""

#: ../../library/unittest.mock.rst:2852
msgid ""
"As ``None`` is the default value of :attr:`~Mock.side_effect`, if you "
"reassign its value back to ``None``, the order of precedence will be checked "
"between :attr:`~Mock.return_value` and the wrapped object, ignoring :attr:"
"`~Mock.side_effect`."
msgstr ""

#: ../../library/unittest.mock.rst:2861
msgid ""
"If the value being returned by :attr:`~Mock.side_effect` is :data:`DEFAULT`, "
"it is ignored and the order of precedence moves to the successor to obtain "
"the value to return."
msgstr ""

#: ../../library/unittest.mock.rst:2870
msgid ""
"When :class:`Mock` wraps an object, the default value of :attr:`~Mock."
"return_value` will be :data:`DEFAULT`."
msgstr ""

#: ../../library/unittest.mock.rst:2879
msgid ""
"The order of precedence will ignore this value and it will move to the last "
"successor which is the wrapped object."
msgstr ""

#: ../../library/unittest.mock.rst:2882
msgid ""
"As the real call is being made to the wrapped object, creating an instance "
"of this mock will return the real instance of the class. The positional "
"arguments, if any, required by the wrapped object must be passed."
msgstr ""

#: ../../library/unittest.mock.rst:2900
msgid ""
"But if you assign ``None`` to it, this will not be ignored as it is an "
"explicit assignment. So, the order of precedence will not move to the "
"wrapped object."
msgstr ""

#: ../../library/unittest.mock.rst:2908
msgid ""
"Even if you set all three at once when initializing the mock, the order of "
"precedence remains the same:"
msgstr ""

#: ../../library/unittest.mock.rst:2925
msgid ""
"If :attr:`~Mock.side_effect` is exhausted, the order of precedence will not "
"cause a value to be obtained from the successors. Instead, ``StopIteration`` "
"exception is raised."
msgstr ""
