# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# tomo, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 01:01+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: tomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/rfc822.rst:3
msgid ":mod:`rfc822` --- Parse RFC 2822 mail headers"
msgstr ":mod:`rfc822` --- RFC 2822 準拠のメールヘッダ読み出し"

#: ../../library/rfc822.rst:10
msgid ""
"The :mod:`email` package should be used in preference to the :mod:`rfc822` "
"module.  This module is present only to maintain backward compatibility, and "
"has been removed in Python 3."
msgstr ""
":mod:`rfc822` モジュールを使うよりも :mod:`email` パッケージを使うべきです。"
"このモジュールは以前のバージョンとの互換性のために保守されているにすぎませ"
"ん。 Python 3 ではこのモジュールは削除されました。"

#: ../../library/rfc822.rst:15
msgid ""
"This module defines a class, :class:`Message`, which represents an \"email "
"message\" as defined by the Internet standard :rfc:`2822`. [#]_  Such "
"messages consist of a collection of message headers, and a message body.  "
"This module also defines a helper class :class:`AddressList` for parsing :"
"rfc:`2822` addresses.  Please refer to the RFC for information on the "
"specific syntax of :rfc:`2822` messages."
msgstr ""
"このモジュールでは、インターネット標準 :rfc:`2822` [#]_ で定義されている \"電"
"子メールメッセージ\" を表現するクラス、 :class:`Message` を定義しています。こ"
"のメッセージはメッセージヘッダ群とメッセージボディの集まりからなります。この"
"モジュールではまた、ヘルパークラス :rfc:`2822` アドレス群を解釈するための :"
"class:`AddressList` クラスを定義しています。 :rfc:`2822` メッセージ固有の構文"
"に関する情報は RFC を参照してください。"

#: ../../library/rfc822.rst:24
msgid ""
"The :mod:`mailbox` module provides classes  to read mailboxes produced by "
"various end-user mail programs."
msgstr ""
":mod:`mailbox` モジュールでは、多くのエンドユーザメールプログラムによって生成"
"されるメールボックスを読み出すためのクラスを提供しています。"

#: ../../library/rfc822.rst:30
msgid ""
"A :class:`Message` instance is instantiated with an input object as "
"parameter. Message relies only on the input object having a :meth:`readline` "
"method; in particular, ordinary file objects qualify.  Instantiation reads "
"headers from the input object up to a delimiter line (normally a blank line) "
"and stores them in the instance.  The message body, following the headers, "
"is not consumed."
msgstr ""
":class:`Message` インスタンスは入力オブジェクトをパラメタに与えてインスタンス"
"化します。入力オブジェクトのメソッドのうち、Message が依存するのは :meth:"
"`readline` だけです; 通常のファイルオブジェクトは適格です。インスタンス化を行"
"うと、入力オブジェクトからデリミタ行 (通常は空行 1 行) に到達するまでヘッダを"
"読み出し、それらをインスタンス中に保持します。ヘッダの後のメッセージ本体は読"
"み出しません。"

#: ../../library/rfc822.rst:36
msgid ""
"This class can work with any input object that supports a :meth:`readline` "
"method.  If the input object has seek and tell capability, the :meth:"
"`rewindbody` method will work; also, illegal lines will be pushed back onto "
"the input stream.  If the input object lacks seek but has an :meth:`unread` "
"method that can push back a line of input, :class:`Message` will use that to "
"push back illegal lines.  Thus this class can be used to parse messages "
"coming from a buffered stream."
msgstr ""
"このクラスは :meth:`readline` メソッドをサポートする任意の入力オブジェクトを"
"扱うことができます。入力オブジェクトが seek および tell できる場合、 :meth:"
"`rewindbody` メソッドが動作します。また、不正な行データを入力ストリームにプッ"
"シュバックできます。入力オブジェクトが seek できない一方で、入力行をプッシュ"
"バックする :meth:`unread` メソッドを持っている場合、 :class:`Message` は不正"
"な行データにこのプッシュバックを使います。こうして、このクラスはバッファされ"
"ているストリームから来るメッセージを解釈するのに使うことができます。"

#: ../../library/rfc822.rst:44
msgid ""
"The optional *seekable* argument is provided as a workaround for certain "
"stdio libraries in which :c:func:`tell` discards buffered data before "
"discovering that the :c:func:`lseek` system call doesn't work.  For maximum "
"portability, you should set the seekable argument to zero to prevent that "
"initial :meth:`tell` when passing in an unseekable object such as a file "
"object created from a socket object."
msgstr ""
"オプションの *seekable* 引数は、 :c:func:`lseek` システムコールが動作しないと"
"分かるまでは :c:func:`tell` がバッファされたデータを無視するような、ある種の "
"stdio ライブラリでの回避手段として提供されています。可搬性を最大にするため"
"に、socket オブジェクトによって生成されたファイルのような、seek できないオブ"
"ジェクトを渡す際には、最初に :meth:`tell` が呼び出されないようにするために "
"seekable 引数をゼロに設定すべきです。"

#: ../../library/rfc822.rst:51
msgid ""
"Input lines as read from the file may either be terminated by CR-LF or by a "
"single linefeed; a terminating CR-LF is replaced by a single linefeed before "
"the line is stored."
msgstr ""
"ファイルとして読み出された入力行データは CR-LF と単一の改行 (line feed) のど"
"ちらで終端されていてもかまいません; 行データを記憶する前に、終端の CR-LF は単"
"一の改行と置き換えられます。"

#: ../../library/rfc822.rst:55
msgid ""
"All header matching is done independent of upper or lower case; e.g. "
"``m['From']``, ``m['from']`` and ``m['FROM']`` all yield the same result."
msgstr ""
"ヘッダに対するマッチは全て大小文字に依存しません。例えば、 ``m['From']`` 、 "
"``m['from']`` 、および ``m['FROM']`` は全て同じ結果になります。"

#: ../../library/rfc822.rst:61
msgid ""
"You may instantiate the :class:`AddressList` helper class using a single "
"string parameter, a comma-separated list of :rfc:`2822` addresses to be "
"parsed.  (The parameter ``None`` yields an empty list.)"
msgstr ""
":rfc:`2833` アドレスがカンマで区切られたものとして解釈できる単一の文字列パラ"
"メタを使って、 :class:`AddressList` ヘルパークラスをインスタンス化することが"
"できます。 (パラメタ ``None`` は空のリストを表します。)"

#: ../../library/rfc822.rst:68
msgid ""
"Return a new string with backslashes in *str* replaced by two backslashes "
"and double quotes replaced by backslash-double quote."
msgstr ""
"*str* 中のバックスラッシュが 2 つのバックスラッシュに置き換えられ、二重引用符"
"がバックスラッシュ付きの二重引用符に置き換えられた、新たな文字列を返します。"

#: ../../library/rfc822.rst:74
msgid ""
"Return a new string which is an *unquoted* version of *str*. If *str* ends "
"and begins with double quotes, they are stripped off.  Likewise if *str* "
"ends and begins with angle brackets, they are stripped off."
msgstr ""
"文字列 *str* を *逆クォート* した新しい文字列を返します。もし *str* の先頭あ"
"るいは末尾がダブルクォートだった場合、これらは単に切りおとされます。同様にも"
"し *str* の先頭あるいは末尾が角ブラケット (<、>) だった場合も切りおとされま"
"す。"

#: ../../library/rfc822.rst:81
msgid ""
"Parse *address*, which should be the value of some address-containing field "
"such as :mailheader:`To` or :mailheader:`Cc`, into its constituent "
"\"realname\" and \"email address\" parts. Returns a tuple of that "
"information, unless the parse fails, in which case a 2-tuple ``(None, "
"None)`` is returned."
msgstr ""
":mailheader:`To` や :mailheader:`Cc` といった、アドレスが入っているフィールド"
"の値 *address* を解析し、含まれている \"実名 (realname)\" 部分および \"電子"
"メールアドレス\" 部分に分けます。それらの情報からなるタプルを返します。解析が"
"失敗した場合には 2 要素のタプル ``(None, None)`` を返します。"

#: ../../library/rfc822.rst:89
msgid ""
"The inverse of :meth:`parseaddr`, this takes a 2-tuple of the form "
"``(realname, email_address)`` and returns the string value suitable for a :"
"mailheader:`To` or :mailheader:`Cc` header.  If the first element of *pair* "
"is false, then the second element is returned unmodified."
msgstr ""
":meth:`parseaddr` の逆で、実名と電子メールアドレスからなる 2要素のタプル\\ "
"``(realname, email_address)`` を引数にとり、 :mailheader:`To` あるいは :"
"mailheader:`Cc` ヘッダに適した形式の文字列を返します。タプル *pair* の第1要素"
"が偽である場合、第2要素の値をそのまま返します。"

#: ../../library/rfc822.rst:97
msgid ""
"Attempts to parse a date according to the rules in :rfc:`2822`. however, "
"some mailers don't follow that format as specified, so :func:`parsedate` "
"tries to guess correctly in such cases.  *date* is a string containing an :"
"rfc:`2822` date, such as  ``'Mon, 20 Nov 1995 19:12:08 -0500'``.  If it "
"succeeds in parsing the date, :func:`parsedate` returns a 9-tuple that can "
"be passed directly to :func:`time.mktime`; otherwise ``None`` will be "
"returned.  Note that indexes 6, 7, and 8 of the result tuple are not usable."
msgstr ""
":rfc:`2822` の規則に従っている日付を解析しようと試みます。しかしながら、メー"
"ラによっては :rfc:`2822` で指定されているような書式に従わないため、そのような"
"場合には :func:`parsedata` は正しい日付を推測しようと試みます。 *date* は "
"``'Mon, 20 Nov 1995 19:12:08 -0500'`` のような :rfc:`2822` 様式の日付を収めた"
"文字列です。日付の解析に成功した場合、 :func:`parsedate` は :func:`time."
"mktime` にそのまま渡すことができるような 9 要素のタプルを返します; そうでない"
"場合には ``None`` を返します。結果のインデックス 6、7、および 8 は有用な情報"
"ではありません。"

#: ../../library/rfc822.rst:108
msgid ""
"Performs the same function as :func:`parsedate`, but returns either ``None`` "
"or a 10-tuple; the first 9 elements make up a tuple that can be passed "
"directly to :func:`time.mktime`, and the tenth is the offset of the date's "
"timezone from UTC (which is the official term for Greenwich Mean Time).  "
"(Note that the sign of the timezone offset is the opposite of the sign of "
"the ``time.timezone`` variable for the same timezone; the latter variable "
"follows the POSIX standard while this module follows :rfc:`2822`.)  If the "
"input string has no timezone, the last element of the tuple returned is "
"``None``.  Note that indexes 6, 7, and 8 of the result tuple are not usable."
msgstr ""
":func:`parsedate` と同じ機能を実現しますが、 ``None`` または 10 要素のタプル"
"を返します; 最初の 9 要素は :func:`time.mktime` に直接渡すことができるような"
"タプルで、 10 番目の要素はその日のタイムゾーンにおける UTC (グリニッチ標準時"
"の公式名称) からのオフセットです。(タイムゾーンオフセットの符号は、同じタイム"
"ゾーンにおける ``time.timezone`` 変数の符号と反転しています; 後者の変数が "
"POSIX 標準に従っている一方、このモジュールは :rfc:`2822` に従っているからで"
"す。) 入力文字列がタイムゾーン情報を持たない場合、タプルの最後の要素は "
"``None`` になります。結果のインデックス 6、7、および 8 は有用な情報ではありま"
"せん。"

#: ../../library/rfc822.rst:121
msgid ""
"Turn a 10-tuple as returned by :func:`parsedate_tz` into a UTC timestamp.  "
"If the timezone item in the tuple is ``None``, assume local time.  Minor "
"deficiency: this first interprets the first 8 elements as a local time and "
"then compensates for the timezone difference; this may yield a slight error "
"around daylight savings time switch dates.  Not enough to worry about for "
"common use."
msgstr ""
":func:`parsedata_tz` が返す 10 要素のタプルを UTC タイムスタンプに変換しま"
"す。タプル内のタイムゾーン要素が ``None`` の場合、地域の時刻を表しているもの"
"と仮定します。些細な欠陥: この関数はまず最初の 8 要素を地域における時刻として"
"変換し、次にタイムゾーンの違いに対する補償を行います; これにより、夏時間の切"
"り替え日前後でちょっとしたエラーが生じるかもしれません。通常の利用に関しては"
"心配ありません。"

#: ../../library/rfc822.rst:131
msgid "Module :mod:`email`"
msgstr ":mod:`email` モジュール"

#: ../../library/rfc822.rst:131
msgid ""
"Comprehensive email handling package; supersedes the :mod:`rfc822` module."
msgstr ""
"包括的な e-mail 処理パッケージです。 :mod:`rfc822` に取って代わります。"

#: ../../library/rfc822.rst:134
msgid "Module :mod:`mailbox`"
msgstr ":mod:`mailbox` モジュール"

#: ../../library/rfc822.rst:134
msgid ""
"Classes to read various mailbox formats produced  by end-user mail programs."
msgstr ""
"エンドユーザのメールプログラムによって生成される、様々な mailbox 形式を読み出"
"すためのクラス群。"

#: ../../library/rfc822.rst:136
msgid "Module :mod:`mimetools`"
msgstr ":mod:`mimetools` モジュール"

#: ../../library/rfc822.rst:137
msgid "Subclass of :class:`rfc822.Message` that handles MIME encoded messages."
msgstr ""
"MIME エンコードされたメッセージを処理する :class:`rfc822.Message` のサブクラ"
"ス。"

#: ../../library/rfc822.rst:143
msgid "Message Objects"
msgstr "Message オブジェクト"

#: ../../library/rfc822.rst:145
msgid "A :class:`Message` instance has the following methods:"
msgstr ":class:`Message` インスタンスは以下のメソッドを持っています:"

#: ../../library/rfc822.rst:150
msgid ""
"Seek to the start of the message body.  This only works if the file object "
"is seekable."
msgstr ""
"メッセージ本体の先頭に seek します。このメソッドはファイルオブジェクトが "
"seek 可能である場合にのみ動作します。"

#: ../../library/rfc822.rst:156
msgid ""
"Returns a line's canonicalized fieldname (the dictionary key that will be "
"used to index it) if the line is a legal :rfc:`2822` header; otherwise "
"returns ``None`` (implying that parsing should stop here and the line be "
"pushed back on the input stream).  It is sometimes useful to override this "
"method in a subclass."
msgstr ""
"ある行が正しい :rfc:`2822` ヘッダである場合、その行の正規化されたフィールド"
"名 (インデクス指定の際に使われる辞書キー) を返します; そうでない場合 "
"``None`` を返します (解析をここで一度中断し、行データを入力ストリームに押し戻"
"すことを意味します)。このメソッドをサブクラスで上書きすると便利なことがありま"
"す。"

#: ../../library/rfc822.rst:165
msgid ""
"Return true if the given line is a delimiter on which Message should stop.  "
"The delimiter line is consumed, and the file object's read location "
"positioned immediately after it.  By default this method just checks that "
"the line is blank, but you can override it in a subclass."
msgstr ""
"与えられた line が Message の区切りとなるデリミタであった場合に真を返します。"
"このデリミタ行は消費され、ファイルオブジェクトの読み位置はその直後になりま"
"す。標準ではこのメソッドは単にその行が空行かどうかをチェックしますが、サブク"
"ラスで上書きすることもできます。"

#: ../../library/rfc822.rst:173
msgid ""
"Return ``True`` if the given line should be ignored entirely, just skipped. "
"By default this is a stub that always returns ``False``, but you can "
"override it in a subclass."
msgstr ""
"与えられた行全体を無視し、単に読み飛ばすときに真を返します。標準では、これは"
"控えメソッド (stub) であり、常に ``False`` を返しますが、サブクラスで上書きす"
"ることもできます。"

#: ../../library/rfc822.rst:180
msgid ""
"Return a list of lines consisting of all headers matching *name*, if any.  "
"Each physical line, whether it is a continuation line or not, is a separate "
"list item.  Return the empty list if no header matches *name*."
msgstr ""
"*name* に一致するヘッダ全てで構成される行のリストを返します。各物理行は継続行"
"であるか否かに関わらず別々のリスト要素になります。 *name* に一致するヘッダが"
"ない場合、空のリストを返します。"

#: ../../library/rfc822.rst:187
msgid ""
"Return a list of lines comprising the first header matching *name*, and its "
"continuation line(s), if any.  Return ``None`` if there is no header "
"matching *name*."
msgstr ""
"*name* に一致する最初のヘッダと、その行に継続する (複数) 行からなる行データの"
"リストを返します。 *name* に一致するヘッダがない場合 ``None`` を返します。"

#: ../../library/rfc822.rst:194
msgid ""
"Return a single string consisting of the text after the colon in the first "
"header matching *name*.  This includes leading whitespace, the trailing "
"linefeed, and internal linefeeds and whitespace if there any continuation "
"line(s) were present.  Return ``None`` if there is no header matching *name*."
msgstr ""
"*name* に一致する最初のヘッダにおけるコロン以降のテキストが入った単一の文字列"
"を返します。このテキストには、先頭の空白、末尾の改行、また継続の行がある場合"
"には途中の改行と空白が含まれます。 *name* に一致するヘッダが存在しない場合に"
"は ``None`` を返します。"

#: ../../library/rfc822.rst:202
msgid ""
"Return a single string consisting of the last header matching *name*, but "
"strip leading and trailing whitespace. Internal whitespace is not stripped.  "
"The optional *default* argument can be used to specify a different default "
"to be returned when there is no header matching *name*; it defaults to "
"``None``. This is the preferred way to get parsed headers."
msgstr ""
"*name* に一致する最後のヘッダから先頭および末尾の空白を剥ぎ取った単一の文字列"
"を返します。途中にある空白は剥ぎ取られません。オプションの *default* 引数"
"は、 *name* に一致するヘッダが存在しない場合に、別のデフォルト値を返すように"
"指定するために使われます。デフォルトは ``None`` です。パースされたヘッダを得"
"る方法としてはこれが好ましいでしょう。"

#: ../../library/rfc822.rst:212
msgid ""
"An alias for :meth:`getheader`, to make the interface more compatible  with "
"regular dictionaries."
msgstr "正規の辞書との互換性をより高めるための :meth:`getheader` の別名です。"

#: ../../library/rfc822.rst:218
msgid ""
"Return a pair ``(full name, email address)`` parsed from the string returned "
"by ``getheader(name)``.  If no header matching *name* exists, return "
"``(None, None)``; otherwise both the full name and the address are (possibly "
"empty) strings."
msgstr ""
"``getheader(name)`` が返した文字列を解析して、 ``(full name, email "
"address)`` からなるペアを返します。 *name* に一致するヘッダが無い場合、 "
"``(None, None)`` が返されます; そうでない場合、 *full name* および *address* "
"は (空文字列をとりうる) 文字列になります。"

#: ../../library/rfc822.rst:223
msgid ""
"Example: If *m*'s first :mailheader:`From` header contains the string "
"``'jack@cwi.nl (Jack Jansen)'``, then ``m.getaddr('From')`` will yield the "
"pair ``('Jack Jansen', 'jack@cwi.nl')``. If the header contained ``'Jack "
"Jansen <jack@cwi.nl>'`` instead, it would yield the exact same result."
msgstr ""
"例: *m* に最初の :mailheader:`From` ヘッダに文字列 ``'jack@cwi.nl (Jack "
"Jansen)'`` が入っている場合、 ``m.getaddr('From')`` はペア ``('Jack Jansen', "
"'jack@cwi.nl')`` になります。また、 ``'Jack Jansen <jack@cwi.nl>'`` であって"
"も、全く同じ結果になります。"

#: ../../library/rfc822.rst:231
msgid ""
"This is similar to ``getaddr(list)``, but parses a header containing a list "
"of email addresses (e.g. a :mailheader:`To` header) and returns a list of "
"``(full name, email address)`` pairs (even if there was only one address in "
"the header). If there is no header matching *name*, return an empty list."
msgstr ""
"``getaddr(list)`` に似ていますが、複数のメールアドレスからなるリストが入った"
"ヘッダ (例えば :mailheader:`To` ヘッダ) を解析し、 ``(full name, email "
"address)`` のペアからなるリストを (たとえヘッダには一つしかアドレスが入ってい"
"なかったとしても) 返します。 *name* に一致するヘッダが無かった場合、空のリス"
"トを返します。"

#: ../../library/rfc822.rst:236
msgid ""
"If multiple headers exist that match the named header (e.g. if there are "
"several :mailheader:`Cc` headers), all are parsed for addresses. Any "
"continuation lines the named headers contain are also parsed."
msgstr ""
"指定された名前に一致する複数のヘッダが存在する場合 (例えば、複数の :"
"mailheader:`Cc` ヘッダが存在する場合)、全てのアドレスを解析します。指定された"
"ヘッダが継続行で収められている場合も解析されます。"

#: ../../library/rfc822.rst:243
msgid ""
"Retrieve a header using :meth:`getheader` and parse it into a 9-tuple "
"compatible with :func:`time.mktime`; note that fields 6, 7, and 8  are not "
"usable.  If there is no header matching *name*, or it is unparsable, return "
"``None``."
msgstr ""
":meth:`getheader` を使ってヘッダを取得して解析し、 :func:`time.mktime` と互換"
"な 9 要素のタプルにします; フィールド 6、7、および 8 は有用な値ではないので注"
"意して下さい。 *name* に一致するヘッダが存在しなかったり、ヘッダが解析不能で"
"あった場合、 ``None`` を返します。"

#: ../../library/rfc822.rst:247
msgid ""
"Date parsing appears to be a black art, and not all mailers adhere to the "
"standard.  While it has been tested and found correct on a large collection "
"of email from many sources, it is still possible that this function may "
"occasionally yield an incorrect result."
msgstr ""
"日付の解析は黒魔術のようなものであり、全てのヘッダが標準に従っているとは限り"
"ません。このメソッドは多くの発信源から集められた膨大な数の電子メールでテスト"
"されており、正しく動作することが分かっていますが、間違った結果を出力してしま"
"う可能性はまだあります。"

#: ../../library/rfc822.rst:255
msgid ""
"Retrieve a header using :meth:`getheader` and parse it into a 10-tuple; the "
"first 9 elements will make a tuple compatible with :func:`time.mktime`, and "
"the 10th is a number giving the offset of the date's timezone from UTC.  "
"Note that fields 6, 7, and 8  are not usable.  Similarly to :meth:`getdate`, "
"if there is no header matching *name*, or it is unparsable, return ``None``."
msgstr ""
":meth:`getheader` を使ってヘッダを取得して解析し、10 要素のタプルにします; 最"
"初の 9 要素は :func:`time.mktime` と互換性のあるタプルを形成し、10 番目の要素"
"はその日におけるタイムゾーンの UTC からのオフセットを与える数字になります。"
"フィールド 6、7、および 8 は有用な値ではないので注意して下さい。 :meth:"
"`getdate` と同様に、 *name* に一致するヘッダがなかったり、解析不能であった場"
"合、 ``None`` を返します。"

#: ../../library/rfc822.rst:261
msgid ""
":class:`Message` instances also support a limited mapping interface. In "
"particular: ``m[name]`` is like ``m.getheader(name)`` but raises :exc:"
"`KeyError` if there is no matching header; and ``len(m)``, ``m.get(name[, "
"default])``, ``name in m``, ``m.keys()``, ``m.values()`` ``m.items()``, and "
"``m.setdefault(name[, default])`` act as expected, with the one difference "
"that :meth:`setdefault` uses an empty string as the default value. :class:"
"`Message` instances also support the mapping writable interface ``m[name] = "
"value`` and ``del m[name]``.  :class:`Message` objects do not support the :"
"meth:`clear`, :meth:`copy`, :meth:`popitem`, or :meth:`update` methods of "
"the mapping interface.  (Support for :meth:`get` and :meth:`setdefault` was "
"only added in Python 2.2.)"
msgstr ""
":class:`Message` インスタンスはまた、限定的なマップ型のインタフェースを持って"
"います。すなわち: ``m[name]`` は ``m.getheader(name)`` に似ていますが、一致す"
"るヘッダがない場合 :exc:`KeyError` を送出します; ``len(m)`` 、 ``m."
"get(name[, default])`` 、 ``name in m``, ``m.keys()`` 、 ``m.values()`` 、 "
"``m.items()`` 、および ``m.setdefault(name[, default])`` は期待通りに動作しま"
"す。ただし :meth:`setdefault` は標準の設定値として空文字列をとります。 :"
"class:`Message` インスタンスはまた、マップ型への書き込みを行えるインタフェー"
"ス ``m[name] = value`` および ``del m[name]`` をサポートしています。 :class:"
"`Message` オブジェクトでは、 :meth:`clear` 、 :meth:`copy` 、 :meth:"
"`popitem` 、あるいは :meth:`update` といったマップ型インタフェースのメソッド"
"はサポートしていません。 (:meth:`get` および :meth:`setdefault` のサポートは "
"Python 2.2 でしか追加されていません。)"

#: ../../library/rfc822.rst:273
msgid ""
"Finally, :class:`Message` instances have some public instance variables:"
msgstr ""
"最後に、 :class:`Message` インスタンスはいくつかの public なインスタンス変数"
"を持っています:"

#: ../../library/rfc822.rst:278
msgid ""
"A list containing the entire set of header lines, in the order in which they "
"were read (except that setitem calls may disturb this order). Each line "
"contains a trailing newline.  The blank line terminating the headers is not "
"contained in the list."
msgstr ""
"ヘッダ行のセット全体が、(setitem を呼び出して変更されない限り) 読み出された順"
"番に入れられたリストです。各行は末尾の改行を含んでいます。ヘッダを終端する空"
"行はリストに含まれません。"

#: ../../library/rfc822.rst:286
msgid ""
"The file or file-like object passed at instantiation time.  This can be used "
"to read the message content."
msgstr ""
"インスタンス化の際に渡されたファイルまたはファイル類似オブジェクトです。この"
"値はメッセージ本体を読み出すために使うことができます。"

#: ../../library/rfc822.rst:292
msgid ""
"The Unix ``From`` line, if the message had one, or an empty string.  This is "
"needed to regenerate the message in some contexts, such as an ``mbox``\\ -"
"style mailbox file."
msgstr ""
"メッセージに Unix ``From`` 行がある場合はその行、そうでなければ空文字列になり"
"ます。この値は例えば ``mbox`` 形式のメールボックスファイルのような、あるコン"
"テキスト中のメッセージを再生成するために必要です。"

#: ../../library/rfc822.rst:300
msgid "AddressList Objects"
msgstr "AddressList オブジェクト"

#: ../../library/rfc822.rst:302
msgid "An :class:`AddressList` instance has the following methods:"
msgstr ":class:`AddressList` インスタンスは以下のメソッドを持ちます:"

#: ../../library/rfc822.rst:307
msgid "Return the number of addresses in the address list."
msgstr "アドレスリスト中のアドレスの数を返します。"

#: ../../library/rfc822.rst:312
msgid ""
"Return a canonicalized string representation of the address list. Addresses "
"are rendered in \"name\" <host@domain> form, comma-separated."
msgstr ""
"アドレスリストの正規化 (canonicalize) された文字列表現を返します。アドレスは"
"カンマで分割された \"name\" <host@domain> 形式になります。"

#: ../../library/rfc822.rst:318
msgid ""
"Return a new :class:`AddressList` instance that contains all addresses in "
"both :class:`AddressList` operands, with duplicates removed (set union)."
msgstr ""
"二つの :class:`AddressList` 被演算子中の双方に含まれるアドレスについて、重複"
"を除いた (集合和の) 全てのアドレスを含む新たな :class:`AddressList` インスタ"
"ンスを返します。"

#: ../../library/rfc822.rst:324
msgid ""
"In-place version of :meth:`__add__`; turns this :class:`AddressList` "
"instance into the union of itself and the right-hand instance, *alist*."
msgstr ""
":meth:`__add__` のインプレース演算版です; :class:`AddressList` インスタンスと"
"右辺値 *alist* との集合和をとり、その結果をインスタンス自体と置き換えます。"

#: ../../library/rfc822.rst:330
msgid ""
"Return a new :class:`AddressList` instance that contains every address in "
"the left-hand :class:`AddressList` operand that is not present in the right-"
"hand address operand (set difference)."
msgstr ""
"左辺値の :class:`AddressList` インスタンスのアドレスのうち、右辺値中に含まれ"
"ていないもの全てを含む (集合差分の) 新たな :class:`AddressList` インスタンス"
"を返します。"

#: ../../library/rfc822.rst:337
msgid ""
"In-place version of :meth:`__sub__`, removing addresses in this list which "
"are also in *alist*."
msgstr ""
":meth:`__sub__` のインプレース演算版で、 *alist* にも含まれているアドレスを削"
"除します。"

#: ../../library/rfc822.rst:340
msgid ""
"Finally, :class:`AddressList` instances have one public instance variable:"
msgstr ""
"最後に、 :class:`AddressList` インスタンスは public なインスタンス変数を一つ"
"持ちます:"

#: ../../library/rfc822.rst:345
msgid ""
"A list of tuple string pairs, one per address.  In each member, the first is "
"the canonicalized name part, the second is the actual route-address "
"(``'@'``\\ -separated username-host.domain pair)."
msgstr ""
"アドレスあたり一つの文字列ペアで構成されるタプルからなるリストです。各メンバ"
"中では、最初の要素は正規化された名前部分で、二つ目は実際の配送アドレス "
"(``'@'`` で分割されたユーザ名とホスト.ドメインからなるペア) です。"

#: ../../library/rfc822.rst:350
msgid "Footnotes"
msgstr "脚注"

#: ../../library/rfc822.rst:351
msgid ""
"This module originally conformed to :rfc:`822`, hence the name.  Since "
"then, :rfc:`2822` has been released as an update to :rfc:`822`.  This module "
"should be considered :rfc:`2822`\\ -conformant, especially in cases where "
"the syntax or semantics have changed since :rfc:`822`."
msgstr ""
"このモジュールはもともと :rfc:`822` に適合していたので、そういう名前になって"
"います。その後、 :rfc:`2822` が :rfc:`822` に対する更新としてリリースされまし"
"た。このモジュールは :rfc:`2822` 適合であり、特に :rfc:`822` からの構文や意味"
"付けに対する変更がなされています。"
