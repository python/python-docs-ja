# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2018-03-23 16:04+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/gc.rst:3
msgid ":mod:`gc` --- Garbage Collector interface"
msgstr ":mod:`gc` --- ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹"

#: ../../library/gc.rst:11
msgid ""
"This module provides an interface to the optional garbage collector.  It "
"provides the ability to disable the collector, tune the collection "
"frequency, and set debugging options.  It also provides access to "
"unreachable objects that the collector found but cannot free.  Since the "
"collector supplements the reference counting already used in Python, you can"
" disable the collector if you are sure your program does not create "
"reference cycles.  Automatic collection can be disabled by calling "
"``gc.disable()``.  To debug a leaking program call "
"``gc.set_debug(gc.DEBUG_LEAK)``. Notice that this includes "
"``gc.DEBUG_SAVEALL``, causing garbage-collected objects to be saved in "
"gc.garbage for inspection."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€å¾ªç’°ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ã®ç„¡åŠ¹åŒ–ãƒ»æ¤œå‡ºé »åº¦ã®èª¿æ•´ãƒ»ãƒ‡ãƒãƒƒã‚°ã‚ªãƒ–ã‚·ãƒ§ãƒ³ã®è¨­å®šãªã©ã‚’è¡Œã†ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚ã¾ãŸã€æ¤œå‡ºã—ãŸåˆ°é”ä¸èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã†ã¡ã€è§£æ”¾ã™ã‚‹äº‹ãŒã§ããªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã™ã‚‹äº‹ã‚‚ã§ãã¾ã™ã€‚å¾ªç’°ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ã¯Pyhonã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’è£œã†ãŸã‚ã®ã‚‚ã®ãªã®ã§ã€ã‚‚ã—ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸­ã§å¾ªç’°å‚ç…§ãŒç™ºç”Ÿã—ãªã„äº‹ãŒæ˜ã‚‰ã‹ãªå ´åˆã«ã¯æ¤œå‡ºã‚’ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è‡ªå‹•æ¤œå‡ºã¯ã€ ``gc.disable()`` ã§åœæ­¢ã™ã‚‹äº‹ãŒã§ãã¾ã™ã€‚ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’ãƒ‡ãƒãƒƒã‚°ã™ã‚‹ã¨ãã«ã¯ã€ ``gc.set_debug(gc.DEBUG_LEAK)`` ã¨ã—ã¾ã™ã€‚ã“ã‚Œã¯ ``gc.DEBUG_SAVEALL`` ã‚’å«ã‚“ã§ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¾ã—ã‚‡ã†ã€‚ã‚¬ãƒ™ãƒ¼ã‚¸ã¨ã—ã¦æ¤œå‡ºã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚·ãƒ§ãƒ³ç”¨ã« gc.garbage ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚"

#: ../../library/gc.rst:22
msgid "The :mod:`gc` module provides the following functions:"
msgstr ":mod:`gc` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ä»¥ä¸‹ã®é–¢æ•°ã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/gc.rst:27
msgid "Enable automatic garbage collection."
msgstr "è‡ªå‹•ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’æœ‰åŠ¹ã«ã—ã¾ã™ã€‚"

#: ../../library/gc.rst:32
msgid "Disable automatic garbage collection."
msgstr "è‡ªå‹•ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç„¡åŠ¹ã«ã—ã¾ã™ã€‚"

#: ../../library/gc.rst:37
msgid "Returns true if automatic collection is enabled."
msgstr "è‡ªå‹•ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãŒæœ‰åŠ¹ãªã‚‰çœŸã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/gc.rst:42
msgid ""
"With no arguments, run a full collection.  The optional argument "
"*generation* may be an integer specifying which generation to collect (from "
"0 to 2).  A :exc:`ValueError` is raised if the generation number  is "
"invalid. The number of unreachable objects found is returned."
msgstr "å¼•æ•°ã‚’æŒ‡å®šã—ãªã„å ´åˆã¯ã€å…¨ã¦ã®æ¤œå‡ºã‚’è¡Œã„ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *generation* ã¯ã€ã©ã®ä¸–ä»£ã‚’æ¤œå‡ºã™ã‚‹ã‹ã‚’ (0 ã‹ã‚‰ 2 ã¾ã§ã®) æ•´æ•°å€¤ã§æŒ‡å®šã—ã¾ã™ã€‚ç„¡åŠ¹ãªä¸–ä»£ç•ªå·ã‚’æŒ‡å®šã—ãŸå ´åˆã¯ :exc:`ValueError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚æ¤œå‡ºã—ãŸåˆ°é”ä¸å¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/gc.rst:47
msgid "The optional *generation* argument was added."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¼•æ•° *generation* ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸ."

#: ../../library/gc.rst:50
msgid ""
"The free lists maintained for a number of built-in types are cleared "
"whenever a full collection or collection of the highest generation (2) is "
"run.  Not all items in some free lists may be freed due to the particular "
"implementation, in particular :class:`int` and :class:`float`."
msgstr "å¹¾ã¤ã‹ã®çµ„ã¿è¾¼ã¿å‹ã®ãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã¯ã€æœ€é«˜(ç¬¬äºŒ)ä¸–ä»£ã®GCã€ã‚ã‚‹ã„ã¯ãƒ•ãƒ«GCãŒå®Ÿè¡Œã•ã‚Œã‚‹ãŸã³ã«ã‚¯ãƒªã‚¢ã•ã‚Œã¾ã™ã€‚å¹¾ã¤ã‹ã®å‹(ç‰¹ã« :class:`int` ã¨ :class:`float`)ã§ã¯ã€å®Ÿè£…ã«ã‚ˆã£ã¦ã¯ã€ãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆå†…ã®å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè§£æ”¾ã•ã‚Œã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/gc.rst:59
msgid ""
"Set the garbage collection debugging flags. Debugging information will be "
"written to ``sys.stderr``.  See below for a list of debugging flags which "
"can be combined using bit operations to control debugging."
msgstr "ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ‡ãƒãƒƒã‚°ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã—ã¾ã™ã€‚ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã¯ ``sys.stderr`` ã«å‡ºåŠ›ã•ã‚Œã¾ã™ã€‚ãƒ‡ãƒãƒƒã‚°ãƒ•ãƒ©ã‚°ã¯ã€ä¸‹ã®å€¤ã®çµ„ã¿åˆã‚ã›ã‚’æŒ‡å®šã™ã‚‹äº‹ãŒã§ãã¾ã™ã€‚"

#: ../../library/gc.rst:66
msgid "Return the debugging flags currently set."
msgstr "ç¾åœ¨ã®ãƒ‡ãƒãƒƒã‚°ãƒ•ãƒ©ã‚°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/gc.rst:71
msgid ""
"Returns a list of all objects tracked by the collector, excluding the list "
"returned."
msgstr "ç¾åœ¨è¿½è·¡ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ãƒªã‚¹ãƒˆã«ã¯ã€æˆ»ã‚Šå€¤ã®ãƒªã‚¹ãƒˆè‡ªèº«ã¯å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/gc.rst:79
msgid ""
"Set the garbage collection thresholds (the collection frequency). Setting "
"*threshold0* to zero disables collection."
msgstr "ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®é–¾å€¤ï¼ˆæ¤œå‡ºé »åº¦ï¼‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚ *threshold0* ã‚’ 0 ã«ã™ã‚‹ã¨ã€æ¤œå‡ºã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/gc.rst:82
msgid ""
"The GC classifies objects into three generations depending on how many "
"collection sweeps they have survived.  New objects are placed in the "
"youngest generation (generation ``0``).  If an object survives a collection "
"it is moved into the next older generation.  Since generation ``2`` is the "
"oldest generation, objects in that generation remain there after a "
"collection.  In order to decide when to run, the collector keeps track of "
"the number object allocations and deallocations since the last collection.  "
"When the number of allocations minus the number of deallocations exceeds "
"*threshold0*, collection starts.  Initially only generation ``0`` is "
"examined.  If generation ``0`` has been examined more than *threshold1* "
"times since generation ``1`` has been examined, then generation ``1`` is "
"examined as well.  Similarly, *threshold2* controls the number of "
"collections of generation ``1`` before collecting generation ``2``."
msgstr "GCã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’èµ°æŸ»ã•ã‚ŒãŸå›æ•°ã«å¾“ã£ã¦3ä¸–ä»£ã«åˆ†é¡ã—ã¾ã™ã€‚æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æœ€ã‚‚è‹¥ã„(``0`` ä¸–ä»£)ã«åˆ†é¡ã•ã‚Œã¾ã™ã€‚ã‚‚ã—ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§å‰Šé™¤ã•ã‚Œãªã‘ã‚Œã°ã€æ¬¡ã«å¤ã„ä¸–ä»£ã«åˆ†é¡ã•ã‚Œã¾ã™ã€‚ã‚‚ã£ã¨ã‚‚å¤ã„ä¸–ä»£ã¯ ``2`` ä¸–ä»£ã§ã€ã“ã®ä¸–ä»£ã«å±ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä»–ã®ä¸–ä»£ã«ç§»å‹•ã—ã¾ã›ã‚“ã€‚ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ã¯ã€æœ€å¾Œã«æ¤œå‡ºã‚’è¡Œã£ã¦ã‹ã‚‰ç”Ÿæˆãƒ»å‰Šé™¤ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆã—ã¦ãŠã‚Šã€ã“ã®æ•°ã«ã‚ˆã£ã¦æ¤œå‡ºã‚’é–‹å§‹ã—ã¾ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆæ•° - å‰Šé™¤æ•°ãŒ *threshold0* ã‚ˆã‚Šå¤§ãããªã‚‹ã¨ã€æ¤œå‡ºã‚’é–‹å§‹ã—ã¾ã™ã€‚æœ€åˆã¯ ``0`` ä¸–ä»£ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ãŒæ¤œæŸ»ã•ã‚Œã¾ã™ã€‚ ``0`` ä¸–ä»£ã®æ¤œæŸ»ãŒ *threshold1* å›å®Ÿè¡Œã•ã‚Œã‚‹ã¨ã€ ``1`` ä¸–ä»£ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ¤œæŸ»ã‚’è¡Œã„ã¾ã™ã€‚åŒæ§˜ã«ã€ ``1`` ä¸–ä»£ãŒ *threshold2* å›æ¤œæŸ»ã•ã‚Œã‚‹ã¨ã€ ``2`` ä¸–ä»£ã®æ¤œæŸ»ã‚’è¡Œã„ã¾ã™ã€‚"

#: ../../library/gc.rst:99
msgid ""
"Return the current collection  counts as a tuple of ``(count0, count1, "
"count2)``."
msgstr "ç¾åœ¨ã®æ¤œå‡ºæ•°ã‚’ã€ ``(count0, count1, count2)`` ã®ã‚¿ãƒ—ãƒ«ã§è¿”ã—ã¾ã™ã€‚"

#: ../../library/gc.rst:107
msgid ""
"Return the current collection thresholds as a tuple of ``(threshold0, "
"threshold1, threshold2)``."
msgstr "ç¾åœ¨ã®æ¤œå‡ºé–¾å€¤ã‚’ã€ ``(threshold0, threshold1, threshold2)`` ã®ã‚¿ãƒ—ãƒ«ã§è¿”ã—ã¾ã™ã€‚"

#: ../../library/gc.rst:113
msgid ""
"Return the list of objects that directly refer to any of objs. This function"
" will only locate those containers which support garbage collection; "
"extension types which do refer to other objects but do not support garbage "
"collection will not be found."
msgstr "objsã§æŒ‡å®šã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã„ãšã‚Œã‹ã‚’å‚ç…§ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã§ã¯ã€ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‚³ãƒ³ãƒ†ãƒŠã®ã¿ã‚’è¿”ã—ã¾ã™ã€‚ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã—ã¦ã„ã¦ã‚‚ã€ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„æ‹¡å¼µå‹ã¯å«ã¾ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/gc.rst:118
msgid ""
"Note that objects which have already been dereferenced, but which live in "
"cycles and have not yet been collected by the garbage collector can be "
"listed among the resulting referrers.  To get only currently live objects, "
"call :func:`collect` before calling :func:`get_referrers`."
msgstr "å°šã€æˆ»ã‚Šå€¤ã®ãƒªã‚¹ãƒˆã«ã¯ã€ã™ã§ã«å‚ç…§ã•ã‚Œãªããªã£ã¦ã„ã‚‹ãŒã€å¾ªç’°å‚ç…§ã®ä¸€éƒ¨ã§ã¾ã ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§å›åã•ã‚Œã¦ã„ãªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚å«ã¾ã‚Œã‚‹ã®ã§æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚æœ‰åŠ¹ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ã‚’å–å¾—ã™ã‚‹å ´åˆã€ :func:`get_referrers` ã®å‰ã« :func:`collect` ã‚’å‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚"

#: ../../library/gc.rst:123
msgid ""
"Care must be taken when using objects returned by :func:`get_referrers` "
"because some of them could still be under construction and hence in a "
"temporarily invalid state. Avoid using :func:`get_referrers` for any purpose"
" other than debugging."
msgstr ":func:`get_referrers` ã‹ã‚‰è¿”ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä½œã‚Šã‹ã‘ã‚„åˆ©ç”¨ã§ããªã„çŠ¶æ…‹ã§ã‚ã‚‹å ´åˆãŒã‚ã‚‹ã®ã§ã€åˆ©ç”¨ã™ã‚‹éš›ã«ã¯æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚ :func:`get_referrers` ã‚’ãƒ‡ãƒãƒƒã‚°ä»¥å¤–ã®ç›®çš„ã§åˆ©ç”¨ã™ã‚‹ã®ã¯é¿ã‘ã¦ãã ã•ã„ã€‚"

#: ../../library/gc.rst:133
msgid ""
"Return a list of objects directly referred to by any of the arguments. The "
"referents returned are those objects visited by the arguments' C-level "
":c:member:`~PyTypeObject.tp_traverse` methods (if any), and may not be all "
"objects actually directly reachable.  :c:member:`~PyTypeObject.tp_traverse` "
"methods are supported only by objects that support garbage collection, and "
"are only required to visit objects that may be involved in a cycle.  So, for"
" example, if an integer is directly reachable from an argument, that integer"
" object may or may not appear in the result list."
msgstr "å¼•æ•°ã§æŒ‡å®šã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã„ãšã‚Œã‹ã‹ã‚‰å‚ç…§ã•ã‚Œã¦ã„ã‚‹ã€å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚å‚ç…§å…ˆã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€å¼•æ•°ã§æŒ‡å®šã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® Cãƒ¬ãƒ™ãƒ«ãƒ¡ã‚½ãƒƒãƒ‰ :c:member:`~PyTypeObject.tp_traverse` ã§å–å¾—ã—ã€å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç›´æ¥åˆ°é”å¯èƒ½ãªå…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ :c:member:`~PyTypeObject.tp_traverse` ã¯ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ãŒå®Ÿè£…ã—ã¦ãŠã‚Šã€ã“ã“ã§å–å¾—ã§ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¾ªç’°å‚ç…§ã®ä¸€éƒ¨ã¨ãªã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ã§ã™ã€‚å¾“ã£ã¦ã€ä¾‹ãˆã°æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç›´æ¥åˆ°é”å¯èƒ½ã§ã‚ã£ã¦ã‚‚ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æˆ»ã‚Šå€¤ã«ã¯å«ã¾ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/gc.rst:145
msgid ""
"Returns ``True`` if the object is currently tracked by the garbage "
"collector, ``False`` otherwise.  As a general rule, instances of atomic "
"types aren't tracked and instances of non-atomic types (containers, user-"
"defined objects...) are.  However, some type-specific optimizations can be "
"present in order to suppress the garbage collector footprint of simple "
"instances (e.g. dicts containing only atomic keys and values)::"
msgstr "``obj`` ãŒGCã«ç®¡ç†ã•ã‚Œã¦ã„ãŸã‚‰ ``True`` ã‚’è¿”ã—ã€ãã‚Œä»¥å¤–ã®å ´åˆã¯ ``False`` ã‚’è¿”ã—ã¾ã™ã€‚ä¸€èˆ¬çš„ãªãƒ«ãƒ¼ãƒ«ã¨ã—ã¦ã€ã‚¢ãƒˆãƒŸãƒƒã‚¯ãª(è¨³æ³¨:ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã—ãªã„ã§å˜ä¸€ã§å€¤ã‚’è¡¨ã™å‹ã€‚ int ã‚„ str ãªã©)å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ç®¡ç†ã•ã‚Œãšã€ãã‚Œä»¥å¤–ã®å‹ (ã‚³ãƒ³ãƒ†ãƒŠå‹ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©å‹ãªã©) ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ç®¡ç†ã•ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€ã„ãã¤ã‹ã®å‹ã§ã¯å°‚ç”¨ã®æœ€é©åŒ–ã‚’è¡Œã„ã€ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å ´åˆã« GCã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚’æ¸›ã‚‰ã—ã¦ã„ã¾ã™ã€‚ (ä¾‹: å…¨ã¦ã® key ã¨ value ãŒã‚¢ãƒˆãƒŸãƒƒã‚¯å‹ã®å€¤ã§ã‚ã‚‹ dict)"

#: ../../library/gc.rst:168
msgid ""
"The following variable is provided for read-only access (you can mutate its "
"value but should not rebind it):"
msgstr "ä»¥ä¸‹ã®å¤‰æ•°ã¯èª­ã¿è¾¼ã¿å°‚ç”¨ã§ã™ã€‚(å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã™ãŒã€å†ãƒã‚¤ãƒ³ãƒ‰ã™ã‚‹äº‹ã¯ã§ãã¾ã›ã‚“ã€‚ï¼‰"

#: ../../library/gc.rst:174
msgid ""
"A list of objects which the collector found to be unreachable but could not "
"be freed (uncollectable objects).  By default, this list contains only "
"objects with :meth:`__del__` methods. [#]_ Objects that have :meth:`__del__`"
" methods and are part of a reference cycle cause the entire reference cycle "
"to be uncollectable, including objects not necessarily in the cycle but "
"reachable only from it. Python doesn't collect such cycles automatically "
"because, in general, it isn't possible for Python to guess a safe order in "
"which to run the :meth:`__del__` methods.  If you know a safe order, you can"
" force the issue by examining the *garbage* list, and explicitly breaking "
"cycles due to your objects within the list.  Note that these objects are "
"kept alive even so by virtue of being in the *garbage* list, so they should "
"be removed from *garbage* too.  For example, after breaking cycles, do ``del"
" gc.garbage[:]`` to empty the list.  It's generally better to avoid the "
"issue by not creating cycles containing objects with :meth:`__del__` "
"methods, and *garbage* can be examined in that case to verify that no such "
"cycles are being created."
msgstr "åˆ°é”ä¸èƒ½ã§ã‚ã‚‹ã“ã¨ãŒæ¤œå‡ºã•ã‚ŒãŸãŒã€è§£æ”¾ã™ã‚‹äº‹ãŒã§ããªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆï¼ˆå›åä¸èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ãŒæ ¼ç´ã•ã‚Œã¾ã™ã€‚ [#]_ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¾ªç’°å‚ç…§ã«å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®å¾ªç’°å‚ç…§å…¨ä½“ã¨ã€å¾ªç’°å‚ç…§ã‹ã‚‰ã®ã¿åˆ°é”ã™ã‚‹äº‹ãŒã§ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å›åä¸èƒ½ã¨ãªã‚Šã¾ã™ã€‚ã“ã®ã‚ˆã†ãªå ´åˆã«ã¯ã€Pythonã¯å®‰å…¨ã« :meth:`__del__` ã‚’å‘¼ã³å‡ºã™é †ç•ªã‚’æ±ºå®šã™ã‚‹äº‹ãŒã§ããªã„ãŸã‚ã€è‡ªå‹•çš„ã«è§£æ”¾ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã‚‚ã—å®‰å…¨ãªè§£æ”¾é †åºãŒã‚ã‹ã‚‹ã®ã§ã‚ã‚Œã°ã€ *garbage* ãƒªã‚¹ãƒˆã‚’å‚ç…§ã—ã¦å¾ªç’°å‚ç…§ã‚’ç ´å£Šã™ã‚‹äº‹ãŒã§ãã¾ã™ã€‚å¾ªç’°å‚ç…§ã‚’ç ´å£Šã—ãŸå¾Œã§ã‚‚ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ *garbage* ãƒªã‚¹ãƒˆã‹ã‚‰å‚ç…§ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€è§£æ”¾ã•ã‚Œã¾ã›ã‚“ã€‚è§£æ”¾ã™ã‚‹ãŸã‚ã«ã¯ã€å¾ªç’°å‚ç…§ã‚’ç ´å£Šã—ãŸå¾Œã€ ``del gc.garbage[:]`` ã®ã‚ˆã†ã« *garbage* ã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¸€èˆ¬çš„ã«ã¯ :meth:`__del__` ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¾ªç’°å‚ç…§ã®ä¸€éƒ¨ã¨ã¯ãªã‚‰ãªã„ã‚ˆã†ã«é…æ…®ã—ã€ *garbage* ã¯ãã®ã‚ˆã†ãªå¾ªç’°å‚ç…§ãŒç™ºç”Ÿã—ã¦ã„ãªã„äº‹ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã™ã‚‹æ–¹ãŒè‰¯ã„ã§ã—ã‚‡ã†ã€‚"

#: ../../library/gc.rst:190
msgid ""
"If :const:`DEBUG_SAVEALL` is set, then all unreachable objects will be added"
" to this list rather than freed."
msgstr ":const:`DEBUG_SAVEALL` ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€å…¨ã¦ã®åˆ°é”ä¸èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è§£æ”¾ã•ã‚Œãšã«ã“ã®ãƒªã‚¹ãƒˆã«æ ¼ç´ã•ã‚Œã¾ã™ã€‚"

#: ../../library/gc.rst:193
msgid "The following constants are provided for use with :func:`set_debug`:"
msgstr "ä»¥ä¸‹ã¯ :func:`set_debug` ã«æŒ‡å®šã™ã‚‹ã“ã¨ã®ã§ãã‚‹å®šæ•°ã§ã™:"

#: ../../library/gc.rst:198
msgid ""
"Print statistics during collection.  This information can be useful when "
"tuning the collection frequency."
msgstr "æ¤œå‡ºä¸­ã«çµ±è¨ˆæƒ…å ±ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚ã“ã®æƒ…å ±ã¯ã€æ¤œå‡ºé »åº¦ã‚’æœ€é©åŒ–ã™ã‚‹éš›ã«æœ‰ç›Šã§ã™ã€‚"

#: ../../library/gc.rst:204
msgid "Print information on collectable objects found."
msgstr "è¦‹ã¤ã‹ã£ãŸå›åå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æƒ…å ±ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚"

#: ../../library/gc.rst:209
msgid ""
"Print information of uncollectable objects found (objects which are not "
"reachable but cannot be freed by the collector).  These objects will be "
"added to the ``garbage`` list."
msgstr "è¦‹ã¤ã‹ã£ãŸå›åä¸èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆåˆ°é”ä¸èƒ½ã ãŒã€ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§è§£æ”¾ã™ã‚‹äº‹ãŒã§ããªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰ã®æƒ…å ±ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚å›åä¸èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ ``garbage`` ãƒªã‚¹ãƒˆã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚"

#: ../../library/gc.rst:216
msgid ""
"When :const:`DEBUG_COLLECTABLE` or :const:`DEBUG_UNCOLLECTABLE` is set, "
"print information about instance objects found."
msgstr ":const:`DEBUG_COLLECTABLE` ã‹ :const:`DEBUG_UNCOLLECTABLE` ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€è¦‹ã¤ã‹ã£ãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æƒ…å ±ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚"

#: ../../library/gc.rst:222
msgid ""
"When :const:`DEBUG_COLLECTABLE` or :const:`DEBUG_UNCOLLECTABLE` is set, "
"print information about objects other than instance objects found."
msgstr ":const:`DEBUG_COLLECTABLE` ã‹ :const:`DEBUG_UNCOLLECTABLE` ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€è¦‹ã¤ã‹ã£ãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä»¥å¤–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æƒ…å ±ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚"

#: ../../library/gc.rst:228
msgid ""
"When set, all unreachable objects found will be appended to *garbage* rather"
" than being freed.  This can be useful for debugging a leaking program."
msgstr "è¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€å…¨ã¦ã®åˆ°é”ä¸èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è§£æ”¾ã•ã‚Œãšã« *garbage* ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’ãƒ‡ãƒãƒƒã‚°ã™ã‚‹ã¨ãã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../library/gc.rst:234
msgid ""
"The debugging flags necessary for the collector to print information about a"
" leaking program (equal to ``DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | "
"DEBUG_INSTANCES | DEBUG_OBJECTS | DEBUG_SAVEALL``)."
msgstr "ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’ãƒ‡ãƒãƒƒã‚°ã™ã‚‹ã¨ãã«æŒ‡å®šã—ã¾ã™ã€‚ï¼ˆ ``DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_INSTANCES | DEBUG_OBJECTS | DEBUG_SAVEALL`` ã¨åŒã˜ã€‚ï¼‰"

#: ../../library/gc.rst:239
msgid "Footnotes"
msgstr "è„šæ³¨"

#: ../../library/gc.rst:240
msgid ""
"Prior to Python 2.2, the list contained all instance objects in unreachable "
"cycles,  not only those with :meth:`__del__` methods."
msgstr "Python 2.2ã‚ˆã‚Šå‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ :meth:`__del__` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã ã‘ã§ãªãã€å…¨ã¦ã®åˆ°é”ä¸èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ ¼ç´ã•ã‚Œã¦ã„ãŸã€‚ï¼‰"
