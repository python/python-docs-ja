# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Takanori Suzuki <takanori@takanory.net>, 2021
# tomo, 2021
# 渋川よしき <yoshiki@shibu.jp>, 2022
# Takeshi Nakazato, 2023
# Arihiro TAKASE, 2023
# 石井明久, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-04 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:09+0000\n"
"Last-Translator: 石井明久, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/logging.handlers.rst:2
msgid ":mod:`!logging.handlers` --- Logging handlers"
msgstr ":mod:`!logging.handlers` --- ログ記録ハンドラー"

#: ../../library/logging.handlers.rst:10
msgid "**Source code:** :source:`Lib/logging/handlers.py`"
msgstr "**ソースコード:** :source:`Lib/logging/handlers.py`"

#: ../../library/logging.handlers.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ""
"このページには、リファレンス情報だけが含まれています。チュートリアルは、以下"
"のページを参照してください"

#: ../../library/logging.handlers.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`基本チュートリアル <logging-basic-tutorial>`"

#: ../../library/logging.handlers.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`上級チュートリアル <logging-advanced-tutorial>`"

#: ../../library/logging.handlers.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`ロギングクックブック <logging-cookbook>`"

#: ../../library/logging.handlers.rst:25
msgid ""
"The following useful handlers are provided in the package. Note that three "
"of the handlers (:class:`StreamHandler`, :class:`FileHandler` and :class:"
"`NullHandler`) are actually defined in the :mod:`logging` module itself, but "
"have been documented here along with the other handlers."
msgstr ""
"このパッケージでは、以下の便利なハンドラが提供されています。なお、これらのハ"
"ンドラのうち、3 つ (:class:`StreamHandler`, :class:`FileHandler` および :"
"class:`NullHandler`) は、実際には :mod:`logging` モジュール自身で定義されてい"
"ますが、他のハンドラと一緒にここでドキュメント化します。"

#: ../../library/logging.handlers.rst:33
msgid "StreamHandler"
msgstr "StreamHandler"

#: ../../library/logging.handlers.rst:35
msgid ""
"The :class:`StreamHandler` class, located in the core :mod:`logging` "
"package, sends logging output to streams such as *sys.stdout*, *sys.stderr* "
"or any file-like object (or, more precisely, any object which supports :meth:"
"`write` and :meth:`flush` methods)."
msgstr ""
":mod:`logging` コアパッケージに含まれる :class:`StreamHandler` クラスは、ログ"
"出力を *sys.stdout*, *sys.stderr* あるいは何らかのファイル風 (file-like) オブ"
"ジェクト (あるいは、より正確に言えば :meth:`write` および :meth:`flush` メ"
"ソッドをサポートする何らかのオブジェクト) といったストリームに送信します。"

#: ../../library/logging.handlers.rst:43
msgid ""
"Returns a new instance of the :class:`StreamHandler` class. If *stream* is "
"specified, the instance will use it for logging output; otherwise, *sys."
"stderr* will be used."
msgstr ""
":class:`StreamHandler` クラスの新たなインスタンスを返します。 *stream* が指定"
"された場合、インスタンスはログ出力先として指定されたストリームを使います; そ"
"うでない場合、 *sys.stderr* が使われます。"

#: ../../library/logging.handlers.rst:50
msgid ""
"If a formatter is specified, it is used to format the record. The record is "
"then written to the stream followed by :attr:`terminator`. If exception "
"information is present, it is formatted using :func:`traceback."
"print_exception` and appended to the stream."
msgstr ""
"フォーマッタが指定されていれば、フォーマッタを使ってレコードを書式化します。 "
"次に、レコードが :attr:`terminator` とともにストリームに書き込まれます。 例外"
"情報が存在する場合、 :func:`traceback.print_exception` を使って書式化され、 "
"ストリームの末尾につけられます。"

#: ../../library/logging.handlers.rst:58
msgid ""
"Flushes the stream by calling its :meth:`flush` method. Note that the :meth:"
"`close` method is inherited from :class:`~logging.Handler` and so does no "
"output, so an explicit :meth:`flush` call may be needed at times."
msgstr ""
"ストリームの :meth:`flush` メソッドを呼び出してバッファをフラッシュします。 :"
"meth:`close` メソッドは :class:`~logging.Handler` から継承しているため何も出"
"力を行わないので、 :meth:`flush` 呼び出しを明示的に行う必要があるかもしれませ"
"ん。"

#: ../../library/logging.handlers.rst:64
msgid ""
"Sets the instance's stream to the specified value, if it is different. The "
"old stream is flushed before the new stream is set."
msgstr ""
"このインスタンスの stream と指定された値が異なる場合、指定された値に設定しま"
"す。\n"
"新しい stream を設定する前に、古い stream はフラッシュされます。"

#: ../../library/logging.handlers.rst:0
msgid "Parameters"
msgstr "パラメーター"

#: ../../library/logging.handlers.rst:67
msgid "The stream that the handler should use."
msgstr "ハンドラがこれから使う stream 。"

#: ../../library/logging.handlers.rst:0
msgid "Returns"
msgstr "返り値"

#: ../../library/logging.handlers.rst:69
msgid "the old stream, if the stream was changed, or ``None`` if it wasn't."
msgstr ""

#: ../../library/logging.handlers.rst:75
msgid ""
"String used as the terminator when writing a formatted record to a stream. "
"Default value is ``'\\n'``."
msgstr ""
"フォーマット済みのレコードをストリームに出力するときの終端として使われる文字"
"列です。デフォルト値は ``'\\n'`` です。"

#: ../../library/logging.handlers.rst:78
msgid ""
"If you don't want a newline termination, you can set the handler instance's "
"``terminator`` attribute to the empty string."
msgstr ""
"もし改行区切りにしたくない場合はハンドラーインスタンスの ``terminator`` 属性"
"に空文字列を設定してください。"

#: ../../library/logging.handlers.rst:81
msgid "In earlier versions, the terminator was hardcoded as ``'\\n'``."
msgstr ""
"以前のバージョンでは、区切り文字は ``'\\n'`` にハードコードされていました。"

#: ../../library/logging.handlers.rst:89
msgid "FileHandler"
msgstr "FileHandler"

#: ../../library/logging.handlers.rst:91
msgid ""
"The :class:`FileHandler` class, located in the core :mod:`logging` package, "
"sends logging output to a disk file.  It inherits the output functionality "
"from :class:`StreamHandler`."
msgstr ""
":mod:`logging` コアパッケージに含まれる :class:`FileHandler` クラスは、ログ出"
"力をディスク上のファイルに送信します。このクラスは出力機能を :class:"
"`StreamHandler` から継承しています。"

#: ../../library/logging.handlers.rst:98
msgid ""
"Returns a new instance of the :class:`FileHandler` class. The specified file "
"is opened and used as the stream for logging. If *mode* is not specified, "
"``'a'`` is used.  If *encoding* is not ``None``, it is used to open the file "
"with that encoding.  If *delay* is true, then file opening is deferred until "
"the first call to :meth:`emit`. By default, the file grows indefinitely. If "
"*errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr ""

#: ../../library/logging.handlers.rst:105
#: ../../library/logging.handlers.rst:190
#: ../../library/logging.handlers.rst:338
#: ../../library/logging.handlers.rst:444
msgid ""
"As well as string values, :class:`~pathlib.Path` objects are also accepted "
"for the *filename* argument."
msgstr ""
"文字列値に加え、 :class:`~pathlib.Path` オブジェクトも *filename* 引数が受け"
"取るようになりました。"

#: ../../library/logging.handlers.rst:109
#: ../../library/logging.handlers.rst:194
#: ../../library/logging.handlers.rst:342
#: ../../library/logging.handlers.rst:448
msgid "The *errors* parameter was added."
msgstr "*errors* 引数が追加されました。"

#: ../../library/logging.handlers.rst:114
msgid "Closes the file."
msgstr "ファイルを閉じます。"

#: ../../library/logging.handlers.rst:118
msgid "Outputs the record to the file."
msgstr "*record* をファイルに出力します。"

#: ../../library/logging.handlers.rst:120
msgid ""
"Note that if the file was closed due to logging shutdown at exit and the "
"file mode is 'w', the record will not be emitted (see :issue:`42378`)."
msgstr ""
"終了時、ロギングがシャットダウンされたためにファイルがクローズされており、"
"ファイルのモードが 'w' である場合、 record は出力されません (:issue:`42378` "
"を参照してください)。"

#: ../../library/logging.handlers.rst:127
msgid "NullHandler"
msgstr "NullHandler"

#: ../../library/logging.handlers.rst:131
msgid ""
"The :class:`NullHandler` class, located in the core :mod:`logging` package, "
"does not do any formatting or output. It is essentially a 'no-op' handler "
"for use by library developers."
msgstr ""
":mod:`logging` コアパッケージに含まれる :class:`NullHandler` クラスは、いかな"
"る書式化も出力も行いません。これは本質的には、ライブラリ開発者に使われる 'no-"
"op' ハンドラです。"

#: ../../library/logging.handlers.rst:137
msgid "Returns a new instance of the :class:`NullHandler` class."
msgstr ":class:`NullHandler` クラスの新しいインスタンスを返します。"

#: ../../library/logging.handlers.rst:141
#: ../../library/logging.handlers.rst:145
msgid "This method does nothing."
msgstr "このメソッドは何もしません。"

#: ../../library/logging.handlers.rst:149
msgid ""
"This method returns ``None`` for the lock, since there is no underlying I/O "
"to which access needs to be serialized."
msgstr ""
"アクセスが特殊化される必要がある I/O が下にないので、このメソッドはロックに対"
"して ``None`` を返します。"

#: ../../library/logging.handlers.rst:153
msgid ""
"See :ref:`library-config` for more information on how to use :class:"
"`NullHandler`."
msgstr ""
":class:`NullHandler` の使い方の詳しい情報は、 :ref:`library-config` を参照し"
"てください。"

#: ../../library/logging.handlers.rst:159
msgid "WatchedFileHandler"
msgstr "WatchedFileHandler"

#: ../../library/logging.handlers.rst:163
msgid ""
"The :class:`WatchedFileHandler` class, located in the :mod:`logging."
"handlers` module, is a :class:`FileHandler` which watches the file it is "
"logging to. If the file changes, it is closed and reopened using the file "
"name."
msgstr ""
":mod:`logging.handlers` モジュールに含まれる :class:`WatchedFileHandler` クラ"
"スは、ログ記録先のファイルを監視する :class:`FileHandler` の一種です。ファイ"
"ルが変更された場合、ファイルを閉じてからファイル名を使って開き直します。"

#: ../../library/logging.handlers.rst:167
msgid ""
"A file change can happen because of usage of programs such as *newsyslog* "
"and *logrotate* which perform log file rotation. This handler, intended for "
"use under Unix/Linux, watches the file to see if it has changed since the "
"last emit. (A file is deemed to have changed if its device or inode have "
"changed.) If the file has changed, the old file stream is closed, and the "
"file opened to get a new stream."
msgstr ""
"ファイルはログファイルをローテーションさせる *newsyslog* や *logrotate* のよ"
"うなプログラムを使うことで変更されることがあります。このハンドラは、 Unix/"
"Linux で使われることを意図していますが、ファイルが最後にログを出力してから変"
"わったかどうかを監視します。 (ファイルはデバイスや inode が変わることで変わっ"
"たと判断します。) ファイルが変わったら古いファイルのストリームは閉じて、現在"
"のファイルを新しいストリームを取得するために開きます。"

#: ../../library/logging.handlers.rst:174
msgid ""
"This handler is not appropriate for use under Windows, because under Windows "
"open log files cannot be moved or renamed - logging opens the files with "
"exclusive locks - and so there is no need for such a handler. Furthermore, "
"*ST_INO* is not supported under Windows; :func:`~os.stat` always returns "
"zero for this value."
msgstr ""
"このハンドラを Windows で使うことは適切ではありません。というのも Windows で"
"は開いているログファイルを移動したり削除したりできないからです - logging は"
"ファイルを排他的ロックを掛けて開きます - そのためこうしたハンドラは必要ないの"
"です。さらに、 Windows では *ST_INO* がサポートされていません; :func:`~os."
"stat` はこの値として常に 0 を返します。"

#: ../../library/logging.handlers.rst:183
msgid ""
"Returns a new instance of the :class:`WatchedFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""

#: ../../library/logging.handlers.rst:199
msgid ""
"Checks to see if the file has changed.  If it has, the existing stream is "
"flushed and closed and the file opened again, typically as a precursor to "
"outputting the record to the file."
msgstr ""
"ファイルが変更されていないかチェックします。\n"
"もし変更されていれば、手始めにレコードをファイルに出力し、既存のストリームは"
"フラッシュして閉じられ、ファイルが再度開かれます。"

#: ../../library/logging.handlers.rst:208
msgid ""
"Outputs the record to the file, but first calls :meth:`reopenIfNeeded` to "
"reopen the file if it has changed."
msgstr ""
"レコードをファイルに出力しますが、最初に :meth:`reopenIfNeeded` を呼び出し"
"て、変更があった場合はファイルを再度開きます。"

#: ../../library/logging.handlers.rst:214
msgid "BaseRotatingHandler"
msgstr "BaseRotatingHandler"

#: ../../library/logging.handlers.rst:216
msgid ""
"The :class:`BaseRotatingHandler` class, located in the :mod:`logging."
"handlers` module, is the base class for the rotating file handlers, :class:"
"`RotatingFileHandler` and :class:`TimedRotatingFileHandler`. You should not "
"need to instantiate this class, but it has attributes and methods you may "
"need to override."
msgstr ""
":mod:`logging.handlers` モジュールに存在する :class:`BaseRotatingHandler` ク"
"ラスは、ローテートを行うファイルハンドラ :class:`RotatingFileHandler` と :"
"class:`TimedRotatingFileHandler` のベースクラスです。このクラスをインスタンス"
"化する必要はありませんが、オーバーライドすることになるかもしれない属性とメ"
"ソッドを持っています。"

#: ../../library/logging.handlers.rst:224
msgid "The parameters are as for :class:`FileHandler`. The attributes are:"
msgstr "パラメータは :class:`FileHandler` と同じです。属性は次の通りです:"

#: ../../library/logging.handlers.rst:228
msgid ""
"If this attribute is set to a callable, the :meth:`rotation_filename` method "
"delegates to this callable. The parameters passed to the callable are those "
"passed to :meth:`rotation_filename`."
msgstr ""
"この属性に callable がセットされた場合、 :meth:`rotation_filename` メソッドは"
"この callable に委譲されます。 callable に渡されるパラメータは :meth:"
"`rotation_filename` に渡されたものです。"

#: ../../library/logging.handlers.rst:232
msgid ""
"The namer function is called quite a few times during rollover, so it should "
"be as simple and as fast as possible. It should also return the same output "
"every time for a given input, otherwise the rollover behaviour may not work "
"as expected."
msgstr ""
"namer 関数はロールオーバー中にかなりの回数呼ばれます。そのため、できるだけ単"
"純で、速くあるべきです。さらに、それは与えられた入力に対しては常に同じ出力を"
"返すべきです。そうでなければ、ロールオーバーの振る舞いは期待通りに動かないか"
"もしれません。"

#: ../../library/logging.handlers.rst:237
msgid ""
"It's also worth noting that care should be taken when using a namer to "
"preserve certain attributes in the filename which are used during rotation. "
"For example, :class:`RotatingFileHandler` expects to have a set of log files "
"whose names contain successive integers, so that rotation works as expected, "
"and :class:`TimedRotatingFileHandler` deletes old log files (based on the "
"``backupCount`` parameter passed to the handler's initializer) by "
"determining the oldest files to delete. For this to happen, the filenames "
"should be sortable using the date/time portion of the filename, and a namer "
"needs to respect this. (If a namer is wanted that doesn't respect this "
"scheme, it will need to be used in a subclass of :class:"
"`TimedRotatingFileHandler` which overrides the :meth:"
"`~TimedRotatingFileHandler.getFilesToDelete` method to fit in with the "
"custom naming scheme.)"
msgstr ""
"namer 属性にローテーションの際に使われるファイル名に埋め込むための特定の属性"
"を保持しようとする場合に注意が必要なことは、注意喚起しておくべきでしょう。た"
"とえば :class:`RotatingFileHandler` は、ローテーションが期待通りに動作するた"
"めに、名前に連続した番号を含むようなファイル名のリストを持つことを期待しま"
"す。また :class:`TimedRotatingFileHandler` は (ハンドラの初期化時に渡された "
"``backupCount`` にもとづいて) 削除すべき古いファイルを決定しながら、古いログ"
"ファイルを削除します。この仕組みが動作するためには、ファイル名は名前に含まれ"
"る日付や時刻でソート可能である必要があり、 namer はそれを尊重しなければなりま"
"せん (namer がこの規則を尊重したくない場合、そのような namer は :meth:"
"`~TimedRotatingFileHandler.getFilesToDelete` メソッドが特定の命名規則に適合す"
"るようにオーバーライドされた :class:`TimedRotatingFileHandler` の派生クラス内"
"で使う必要があるでしょう)。"

#: ../../library/logging.handlers.rst:255
msgid ""
"If this attribute is set to a callable, the :meth:`rotate` method delegates "
"to this callable.  The parameters passed to the callable are those passed "
"to :meth:`rotate`."
msgstr ""
"この属性に callable がセットされた場合、 :meth:`rotate` メソッドはこの "
"callable に委譲されます。 callable に渡されるパラメータは :meth:`rotate` に渡"
"されたものです。"

#: ../../library/logging.handlers.rst:263
msgid "Modify the filename of a log file when rotating."
msgstr "ローテートを行う際にログファイルのファイル名を変更します。"

#: ../../library/logging.handlers.rst:265
msgid "This is provided so that a custom filename can be provided."
msgstr "このメソッドは、ファイル名をカスタマイズするために提供されます。"

#: ../../library/logging.handlers.rst:267
msgid ""
"The default implementation calls the 'namer' attribute of the handler, if "
"it's callable, passing the default name to it. If the attribute isn't "
"callable (the default is ``None``), the name is returned unchanged."
msgstr ""
"デフォルト実装は、ハンドラの 'namer' 属性が callable だった場合、その "
"callable を呼んでデフォルト名を渡します。属性が callable でない場合 (デフォル"
"トは ``None`` です)、名前は変更せずに返されます。"

#: ../../library/logging.handlers.rst:271
msgid "The default name for the log file."
msgstr "ログファイルのデフォルトのファイル名。"

#: ../../library/logging.handlers.rst:278
msgid "When rotating, rotate the current log."
msgstr "ローテートが行われる時、現在のログをローテートします。"

#: ../../library/logging.handlers.rst:280
msgid ""
"The default implementation calls the 'rotator' attribute of the handler, if "
"it's callable, passing the source and dest arguments to it. If the attribute "
"isn't callable (the default is ``None``), the source is simply renamed to "
"the destination."
msgstr ""
"デフォルト実装は、 ハンドラの 'rotator' 属性が callable だった場合、その "
"callable を呼んで source と dest 引数を渡します。属性が callable でない場合 "
"(デフォルトは ``None`` です)、単に source が destination に改名されます。"

#: ../../library/logging.handlers.rst:285
msgid ""
"The source filename. This is normally the base filename, e.g. 'test.log'."
msgstr ""
"ソースファイル名。これは通常ベースファイル名 、例えば 'test.log' となります。"

#: ../../library/logging.handlers.rst:287
msgid ""
"The destination filename. This is normally what the source is rotated to, e."
"g. 'test.log.1'."
msgstr ""
"変更先ファイル名。これは通常ソースファイルをローテートしたもの (例えば 'test."
"log.1') です。"

#: ../../library/logging.handlers.rst:292
msgid ""
"The reason the attributes exist is to save you having to subclass - you can "
"use the same callables for instances of :class:`RotatingFileHandler` and :"
"class:`TimedRotatingFileHandler`. If either the namer or rotator callable "
"raises an exception, this will be handled in the same way as any other "
"exception during an :meth:`emit` call, i.e. via the :meth:`handleError` "
"method of the handler."
msgstr ""
"これらの属性が存在する理由は、サブクラス化を省略できるようにするためです。 :"
"class:`RotatingFileHandler` と :class:`TimedRotatingFileHandler` のインスタン"
"スに対して同じ callable が使えます。もし namer や rotator callable が例外を上"
"げれば、 :meth:`emit` 呼び出しで発生した他の例外と同じ方法で、つまりハンドラ"
"の :meth:`handleError` メソッドによって扱われます。"

#: ../../library/logging.handlers.rst:299
msgid ""
"If you need to make more significant changes to rotation processing, you can "
"override the methods."
msgstr ""
"ローテート処理に大幅な変更を加える必要があれば、メソッドをオーバーライドする"
"ことができます。"

#: ../../library/logging.handlers.rst:302
msgid "For an example, see :ref:`cookbook-rotator-namer`."
msgstr "例えば、 :ref:`cookbook-rotator-namer` を参照してください。"

#: ../../library/logging.handlers.rst:308
msgid "RotatingFileHandler"
msgstr "RotatingFileHandler"

#: ../../library/logging.handlers.rst:310
msgid ""
"The :class:`RotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files."
msgstr ""
":mod:`logging.handlers` モジュールに含まれる :class:`RotatingFileHandler` ク"
"ラスは、ディスク上のログファイルに対するローテーション処理をサポートします。"

#: ../../library/logging.handlers.rst:316
msgid ""
"Returns a new instance of the :class:`RotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
":class:`RotatingFileHandler` クラスの新たなインスタンスを返します。\n"
"指定されたファイルが開かれ、ログ記録のためのストリームとして使われます。\n"
"*mode* が指定されなかった場合、 ``'a'`` が使われます。\n"
"*encoding* が ``None`` でない場合、その値はファイルを開くときのエンコーディン"
"グとして使われます。\n"
"*delay* が真ならば、ファイルを開くのは最初の :meth:`emit` 呼び出しまで遅らせ"
"られます。\n"
"デフォルトでは、ファイルは無制限に大きくなりつづけます。 *errors* が提供され"
"ると、エンコーディングエラーの処理方法を決定します。"

#: ../../library/logging.handlers.rst:323
msgid ""
"You can use the *maxBytes* and *backupCount* values to allow the file to :"
"dfn:`rollover` at a predetermined size. When the size is about to be "
"exceeded, the file is closed and a new file is silently opened for output. "
"Rollover occurs whenever the current log file is nearly *maxBytes* in "
"length; but if either of *maxBytes* or *backupCount* is zero, rollover never "
"occurs, so you generally want to set *backupCount* to at least 1, and have a "
"non-zero *maxBytes*. When *backupCount* is non-zero, the system will save "
"old log files by appending the extensions '.1', '.2' etc., to the filename. "
"For example, with a *backupCount* of 5 and a base file name of :file:`app."
"log`, you would get :file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, "
"up to :file:`app.log.5`. The file being written to is always :file:`app."
"log`.  When this file is filled, it is closed and renamed to :file:`app."
"log.1`, and if files :file:`app.log.1`, :file:`app.log.2`, etc. exist, then "
"they are renamed to :file:`app.log.2`, :file:`app.log.3` etc. respectively."
msgstr ""
"*maxBytes* および *backupCount* 値を指定することで、あらかじめ決められたサイ"
"ズでファイルをロールオーバ (:dfn:`rollover`) させることができます。\n"
"指定サイズを超えそうになると、ファイルは閉じられ、暗黙のうちに新たなファイル"
"が開かれます。\n"
"ロールオーバは現在のログファイルの長さが *maxBytes* に近くなると常に起きます"
"が、 *maxBytes* または *backupCount* がゼロならロールオーバは起きなくなってし"
"まうので、一般的には *backupCount* を少なくとも 1 に設定し *maxBytes* を非ゼ"
"ロにするのが良いでしょう。\n"
"*backupCount* が非ゼロのとき、システムは古いログファイルをファイル名に "
"\".1\", \".2\" といった拡張子を追加して保存します。\n"
"例えば、 *backupCount* が 5 で、基本のファイル名が :file:`app.log` なら、 :"
"file:`app.log`, :file:`app.log.1`, :file:`app.log.2` ... と続き、 :file:`app."
"log.5` までを得ることになります。\n"
"ログの書き込み対象になるファイルは常に :file:`app.log` です。このファイルが満"
"杯になると、ファイルは閉じられ、 :file:`app.log.1` に名前が変更されます。\n"
":file:`app.log.1`, :file:`app.log.2` などが存在する場合、それらのファイルはそ"
"れぞれ :file:`app.log.2`, :file:`app.log.3` といった具合に名前が変更されま"
"す。"

#: ../../library/logging.handlers.rst:347
#: ../../library/logging.handlers.rst:453
msgid "Does a rollover, as described above."
msgstr "上述のような方法でロールオーバを行います。"

#: ../../library/logging.handlers.rst:352
msgid ""
"Outputs the record to the file, catering for rollover as described "
"previously."
msgstr "上述のようなロールオーバを行いながら、レコードをファイルに出力します。"

#: ../../library/logging.handlers.rst:358
msgid "TimedRotatingFileHandler"
msgstr "TimedRotatingFileHandler"

#: ../../library/logging.handlers.rst:360
msgid ""
"The :class:`TimedRotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files at certain timed "
"intervals."
msgstr ""
":mod:`logging.handlers` モジュールに含まれる :class:"
"`TimedRotatingFileHandler` クラスは、特定の時間間隔でのログローテーションをサ"
"ポートしています。"

#: ../../library/logging.handlers.rst:367
msgid ""
"Returns a new instance of the :class:`TimedRotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. On rotating it "
"also sets the filename suffix. Rotating happens based on the product of "
"*when* and *interval*."
msgstr ""
":class:`TimedRotatingFileHandler` クラスの新たなインスタンスを返します。 "
"*filename* に指定したファイルを開き、ログ出力先のストリームとして使います。ロ"
"グファイルのローテーション時には、ファイル名に拡張子 (suffix) をつけます。ロ"
"グファイルのローテーションは *when* および *interval* の積に基づいて行いま"
"す。"

#: ../../library/logging.handlers.rst:372
msgid ""
"You can use the *when* to specify the type of *interval*. The list of "
"possible values is below.  Note that they are not case sensitive."
msgstr ""
"*when* は *interval* の単位を指定するために使います。使える値は下表の通りで"
"す。大小文字の区別は行いません。"

#: ../../library/logging.handlers.rst:376
msgid "Value"
msgstr "値"

#: ../../library/logging.handlers.rst:376
msgid "Type of interval"
msgstr "*interval* の単位"

#: ../../library/logging.handlers.rst:376
msgid "If/how *atTime* is used"
msgstr "*atTime* の使用有無/使用方法"

#: ../../library/logging.handlers.rst:378
msgid "``'S'``"
msgstr "``'S'``"

#: ../../library/logging.handlers.rst:378
msgid "Seconds"
msgstr "秒"

#: ../../library/logging.handlers.rst:378
#: ../../library/logging.handlers.rst:380
#: ../../library/logging.handlers.rst:382
#: ../../library/logging.handlers.rst:384
msgid "Ignored"
msgstr "無視"

#: ../../library/logging.handlers.rst:380
msgid "``'M'``"
msgstr "``'M'``"

#: ../../library/logging.handlers.rst:380
msgid "Minutes"
msgstr "分"

#: ../../library/logging.handlers.rst:382
msgid "``'H'``"
msgstr "``'H'``"

#: ../../library/logging.handlers.rst:382
msgid "Hours"
msgstr "時間"

#: ../../library/logging.handlers.rst:384
msgid "``'D'``"
msgstr "``'D'``"

#: ../../library/logging.handlers.rst:384
msgid "Days"
msgstr "日"

#: ../../library/logging.handlers.rst:386
msgid "``'W0'-'W6'``"
msgstr "``'W0'-'W6'``"

#: ../../library/logging.handlers.rst:386
msgid "Weekday (0=Monday)"
msgstr "曜日 (0=月曜)"

#: ../../library/logging.handlers.rst:386
#: ../../library/logging.handlers.rst:389
msgid "Used to compute initial rollover time"
msgstr "初期のロールオーバー時刻の算出に使用"

#: ../../library/logging.handlers.rst:389
msgid "``'midnight'``"
msgstr "``'midnight'``"

#: ../../library/logging.handlers.rst:389
msgid "Roll over at midnight, if *atTime* not specified, else at time *atTime*"
msgstr ""
"*atTime* が指定されなかった場合は深夜に、そうでない場合は *atTime* の時刻に"
"ロールオーバーされます"

#: ../../library/logging.handlers.rst:394
msgid ""
"When using weekday-based rotation, specify 'W0' for Monday, 'W1' for "
"Tuesday, and so on up to 'W6' for Sunday. In this case, the value passed for "
"*interval* isn't used."
msgstr ""
"曜日ベースのローテーションを使う場合は、月曜として 'W0' を、火曜として 'W1' "
"を、…、日曜として 'W6' を指定します。このケースの場合は、 *interval* は使われ"
"ません。"

#: ../../library/logging.handlers.rst:398
msgid ""
"The system will save old log files by appending extensions to the filename. "
"The extensions are date-and-time based, using the strftime format ``%Y-%m-"
"%d_%H-%M-%S`` or a leading portion thereof, depending on the rollover "
"interval."
msgstr ""
"古いログファイルの保存時、ロギングシステムによりファイル名に拡張子が付けられ"
"ます。 ロールオーバ間隔によって、strftime の ``%Y-%m-%d_%H-%M-%S`` 形式または"
"その前方の一部を使って、日付と時間に基づいた拡張子が付けられます。"

#: ../../library/logging.handlers.rst:403
msgid ""
"When computing the next rollover time for the first time (when the handler "
"is created), the last modification time of an existing log file, or else the "
"current time, is used to compute when the next rotation will occur."
msgstr ""
"最初に次のロールオーバー時間を計算するとき (ハンドラが生成されるとき)、次の"
"ローテーションがいつ起こるかを計算するために、既存のログファイルの最終変更時"
"刻または現在の時間が使用されます。"

#: ../../library/logging.handlers.rst:407
msgid ""
"If the *utc* argument is true, times in UTC will be used; otherwise local "
"time is used."
msgstr ""
"*utc* 引数が true の場合時刻は UTC になり、それ以外では現地時間が使われます。"

#: ../../library/logging.handlers.rst:410
msgid ""
"If *backupCount* is nonzero, at most *backupCount* files will be kept, and "
"if more would be created when rollover occurs, the oldest one is deleted. "
"The deletion logic uses the interval to determine which files to delete, so "
"changing the interval may leave old files lying around."
msgstr ""
"*backupCount* がゼロでない場合、保存されるファイル数は高々 *backupCount* 個"
"で、それ以上のファイルがロールオーバされる時に作られるならば、一番古いものが"
"削除されます。削除のロジックは interval で決まるファイルを削除するので、 "
"interval を変えると古いファイルが残ったままになることもあります。"

#: ../../library/logging.handlers.rst:415
msgid ""
"If *delay* is true, then file opening is deferred until the first call to :"
"meth:`emit`."
msgstr ""
"*delay* が true なら、ファイルを開くのは :meth:`emit` の最初の呼び出しまで延"
"期されます。"

#: ../../library/logging.handlers.rst:418
msgid ""
"If *atTime* is not ``None``, it must be a ``datetime.time`` instance which "
"specifies the time of day when rollover occurs, for the cases where rollover "
"is set to happen \"at midnight\" or \"on a particular weekday\". Note that "
"in these cases, the *atTime* value is effectively used to compute the "
"*initial* rollover, and subsequent rollovers would be calculated via the "
"normal interval calculation."
msgstr ""
"*atTime* が ``None`` でない場合、それは ``datetime.time`` インスタンスでなけ"
"ればなりません。ロールオーバーが「夜中」「特定の曜日」に設定されていて、ロー"
"ルが発生する時刻を指定します。 *atTime* の値は *初期* のロールオーバーの計算"
"に使われますが、後続のロールオーバーは通常の間隔の計算で算出されます。"

#: ../../library/logging.handlers.rst:425
msgid ""
"If *errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr ""
"*errors* が指定されると、エンコーディングエラーの取り扱い方法を決定します。"

#: ../../library/logging.handlers.rst:428
msgid ""
"Calculation of the initial rollover time is done when the handler is "
"initialised. Calculation of subsequent rollover times is done only when "
"rollover occurs, and rollover occurs only when emitting output. If this is "
"not kept in mind, it might lead to some confusion. For example, if an "
"interval of \"every minute\" is set, that does not mean you will always see "
"log files with times (in the filename) separated by a minute; if, during "
"application execution, logging output is generated more frequently than once "
"a minute, *then* you can expect to see log files with times separated by a "
"minute. If, on the other hand, logging messages are only output once every "
"five minutes (say), then there will be gaps in the file times corresponding "
"to the minutes where no output (and hence no rollover) occurred."
msgstr ""
"最初のロールオーバーの計算はハンドラーが初期化されたときに行われます。後続の"
"ロールオーバーは、ロールオーバーが発生し、ロールオーバーが出力した時にのみ行"
"われます。これを念頭に置いておかないと混乱する可能性があります。例えば、イン"
"ターバルが *毎分* に設定されていて、1分ごとにログファイルが常に生成されるとは"
"限りません。アプリケーションが実行されている間、1分に1回以上のログ出力されて "
"*いるとすると* 毎分、分割されたログファイルが出力されますが、そうでなく、5分"
"ごとに出力される場合は、出力されずにロールオーバーが実行されなかった時間分の"
"ギャップが生じます。"

#: ../../library/logging.handlers.rst:441
msgid "*atTime* parameter was added."
msgstr "*atTime* パラメータが追加されました。"

#: ../../library/logging.handlers.rst:457
msgid ""
"Outputs the record to the file, catering for rollover as described above."
msgstr ""
"上で説明した方法でロールオーバを行いながら、レコードをファイルに出力します。"

#: ../../library/logging.handlers.rst:461
msgid ""
"Returns a list of filenames which should be deleted as part of rollover. "
"These are the absolute paths of the oldest backup log files written by the "
"handler."
msgstr ""
"ロールオーバーの一環として削除されるファイル名のリストを返します。それらの"
"ファイルは、ハンドラによって書き込まれた最も古いバックアップログファイルの絶"
"対パスです。"

#: ../../library/logging.handlers.rst:467
msgid "SocketHandler"
msgstr "SocketHandler"

#: ../../library/logging.handlers.rst:469
msgid ""
"The :class:`SocketHandler` class, located in the :mod:`logging.handlers` "
"module, sends logging output to a network socket. The base class uses a TCP "
"socket."
msgstr ""
":mod:`logging.handlers` モジュールに含まれる :class:`SocketHandler` クラス"
"は、ログ出力をネットワークソケットに送信します。基底クラスでは TCP ソケットを"
"用います。"

#: ../../library/logging.handlers.rst:475
msgid ""
"Returns a new instance of the :class:`SocketHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"アドレスが *host* および *port* で与えられた遠隔のマシンと通信するようにし"
"た :class:`SocketHandler` クラスのインスタンスを生成して返します。"

#: ../../library/logging.handlers.rst:478
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a TCP socket is created."
msgstr ""
"``port`` に ``None`` を指定すると、Unix ドメインソケットが ``host`` 値を用い"
"て作られます - そうでない場合は TCP ソケットが作られます。"

#: ../../library/logging.handlers.rst:484
msgid "Closes the socket."
msgstr "ソケットを閉じます。"

#: ../../library/logging.handlers.rst:489
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. If the connection was previously lost, re-establishes the "
"connection. To unpickle the record at the receiving end into a :class:"
"`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"レコードの属性辞書を pickle して、バイナリ形式でソケットに書き込みます。ソ"
"ケット操作でエラーが生じた場合、暗黙のうちにパケットは捨てられます。事前に接"
"続が失われていた場合、接続を再度確立します。受信端でレコードを unpickle し"
"て :class:`~logging.LogRecord` にするには、 :func:`~logging.makeLogRecord` 関"
"数を使ってください。"

#: ../../library/logging.handlers.rst:499
msgid ""
"Handles an error which has occurred during :meth:`emit`. The most likely "
"cause is a lost connection. Closes the socket so that we can retry on the "
"next event."
msgstr ""
":meth:`emit` の処理中に発生したエラーを処理します。よくある原因は接続の消失で"
"す。次のイベント発生時に再試行できるようにソケットを閉じます。"

#: ../../library/logging.handlers.rst:506
msgid ""
"This is a factory method which allows subclasses to define the precise type "
"of socket they want. The default implementation creates a TCP socket (:const:"
"`socket.SOCK_STREAM`)."
msgstr ""
"サブクラスで必要なソケット形式を詳細に定義できるようにするためのファクトリメ"
"ソッドです。デフォルトの実装では、 TCP ソケット (:const:`socket."
"SOCK_STREAM`) を生成します。"

#: ../../library/logging.handlers.rst:513
msgid ""
"Pickles the record's attribute dictionary in binary format with a length "
"prefix, and returns it ready for transmission across the socket. The details "
"of this operation are equivalent to::"
msgstr ""
"レコードの属性辞書をバイナリ形式に pickle したものの先頭に長さ情報を付け、ソ"
"ケットを介して送信できるようにして返します。\n"
"この操作の詳細は次のコードと同等です::"

#: ../../library/logging.handlers.rst:517
msgid ""
"data = pickle.dumps(record_attr_dict, 1)\n"
"datalen = struct.pack('>L', len(data))\n"
"return datalen + data"
msgstr ""

#: ../../library/logging.handlers.rst:521
msgid ""
"Note that pickles aren't completely secure. If you are concerned about "
"security, you may want to override this method to implement a more secure "
"mechanism. For example, you can sign pickles using HMAC and then verify them "
"on the receiving end, or alternatively you can disable unpickling of global "
"objects on the receiving end."
msgstr ""
"pickle が完全に安全というわけではないことに注意してください。セキュリティに関"
"して心配なら、より安全なメカニズムを実装するためにこのメソッドをオーバーライ"
"ドすると良いでしょう。例えば、 HMAC を使って pickle に署名して、受け取る側で"
"はそれを検証することができます。あるいはまた、受け取る側でグローバルなオブ"
"ジェクトの unpickle を無効にすることができます。"

#: ../../library/logging.handlers.rst:530
msgid ""
"Send a pickled byte-string *packet* to the socket. The format of the sent "
"byte-string is as described in the documentation for :meth:`~SocketHandler."
"makePickle`."
msgstr ""
"pickle したバイト文字列 *packet* をソケットに送信します。\n"
"送信するバイト文字列のフォーマットは、 :meth:`~SocketHandler.makePickle` のド"
"キュメントで解説されています。"

#: ../../library/logging.handlers.rst:534
msgid ""
"This function allows for partial sends, which can happen when the network is "
"busy."
msgstr ""
"この関数はネットワークがビジーの時に発生する部分的送信に対応しています。"

#: ../../library/logging.handlers.rst:540
msgid ""
"Tries to create a socket; on failure, uses an exponential back-off "
"algorithm.  On initial failure, the handler will drop the message it was "
"trying to send.  When subsequent messages are handled by the same instance, "
"it will not try connecting until some time has passed.  The default "
"parameters are such that the initial delay is one second, and if after that "
"delay the connection still can't be made, the handler will double the delay "
"each time up to a maximum of 30 seconds."
msgstr ""
"ソケットの生成を試みます。失敗時には、指数的な減速アルゴリズムを使います。最"
"初の失敗時には、ハンドラは送ろうとしていたメッセージを落とします。続くメッ"
"セージが同じインスタンスで扱われたとき、幾らかの時間が経過するまで接続を試み"
"ません。デフォルトのパラメタは、最初の遅延時間が 1 秒で、その遅延時間の後でそ"
"れでも接続が確保できないなら、遅延時間は 2 倍づつになり、最大で 30 秒になりま"
"す。"

#: ../../library/logging.handlers.rst:548
msgid "This behaviour is controlled by the following handler attributes:"
msgstr "この働きは、以下のハンドラ属性で制御されます:"

#: ../../library/logging.handlers.rst:550
msgid "``retryStart`` (initial delay, defaulting to 1.0 seconds)."
msgstr "``retryStart`` (最初の遅延時間、デフォルトは 1.0 秒)。"

#: ../../library/logging.handlers.rst:551
msgid "``retryFactor`` (multiplier, defaulting to 2.0)."
msgstr "``retryFactor`` (乗数、デフォルトは 2.0)。"

#: ../../library/logging.handlers.rst:552
msgid "``retryMax`` (maximum delay, defaulting to 30.0 seconds)."
msgstr "``retryMax`` (最大遅延時間、デフォルトは 30.0 秒)。"

#: ../../library/logging.handlers.rst:554
msgid ""
"This means that if the remote listener starts up *after* the handler has "
"been used, you could lose messages (since the handler won't even attempt a "
"connection until the delay has elapsed, but just silently drop messages "
"during the delay period)."
msgstr ""
"つまり、ハンドラが使われた *後に* リモートリスナが起動した場合、メッセージが"
"失われてしまうことがあります (ハンドラは、遅延時間が経過するまで接続を試みよ"
"うとさえせず、その遅延時間中に通知なくメッセージを捨てるので)。"

#: ../../library/logging.handlers.rst:563
msgid "DatagramHandler"
msgstr "DatagramHandler"

#: ../../library/logging.handlers.rst:565
msgid ""
"The :class:`DatagramHandler` class, located in the :mod:`logging.handlers` "
"module, inherits from :class:`SocketHandler` to support sending logging "
"messages over UDP sockets."
msgstr ""
":mod:`logging.handlers` モジュールに含まれる :class:`DatagramHandler` クラス"
"は、 :class:`SocketHandler` を継承しており、 UDP ソケットを介したログ記録メッ"
"セージの送信をサポートしています。"

#: ../../library/logging.handlers.rst:572
msgid ""
"Returns a new instance of the :class:`DatagramHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"アドレスが *host* および *port* で与えられた遠隔のマシンと通信するようにし"
"た :class:`DatagramHandler` クラスのインスタンスを生成して返します。"

#: ../../library/logging.handlers.rst:575
msgid ""
"As UDP is not a streaming protocol, there is no persistent connection "
"between an instance of this handler and *host*. For this reason, when using "
"a network socket, a DNS lookup might have to be made each time an event is "
"logged, which can introduce some latency into the system. If this affects "
"you, you can do a lookup yourself and initialize this handler using the "
"looked-up IP address rather than the hostname."
msgstr ""
"UDP はストリーミングプロトコルではないため、このハンドラのインスタンスと "
"*host* に指定したホストとの間に持続的なコネクションはありません。この理由か"
"ら、ネットワークソケットを使う場合、イベントがログされるごとに DNS のルック"
"アップを行わなければならないかもしれず、それによりシステムにある程度の待ち時"
"間をもたらす可能性があります。この待ち時間が問題になる場合、自身でルックアッ"
"プを行い、ホスト名の代わりにルックアップの結果得られた IP アドレスを使ってハ"
"ンドラを初期化することができます。"

#: ../../library/logging.handlers.rst:582
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a UDP socket is created."
msgstr ""
"``port`` に ``None`` を指定すると、Unix ドメインソケットが ``host`` 値を用い"
"て作られます - そうでない場合は UDP ソケットが作られます。"

#: ../../library/logging.handlers.rst:588
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. To unpickle the record at the receiving end into a :class:`~logging."
"LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"レコードの属性辞書を pickle して、バイナリ形式でソケットに書き込みます。ソ"
"ケット操作でエラーが生じた場合、暗黙のうちにパケットは捨てられます。事前に接"
"続が失われていた場合、接続を再度確立します。受信端でレコードを unpickle し"
"て :class:`~logging.LogRecord` にするには、 :func:`~logging.makeLogRecord` 関"
"数を使ってください。"

#: ../../library/logging.handlers.rst:597
msgid ""
"The factory method of :class:`SocketHandler` is here overridden to create a "
"UDP socket (:const:`socket.SOCK_DGRAM`)."
msgstr ""
"ここで :class:`SocketHandler` のファクトリメソッドをオーバライドして、 UDP ソ"
"ケット (:const:`socket.SOCK_DGRAM`) を生成しています。"

#: ../../library/logging.handlers.rst:603
msgid ""
"Send a pickled byte-string to a socket. The format of the sent byte-string "
"is as described in the documentation for :meth:`SocketHandler.makePickle`."
msgstr ""
"pickle したバイト文字列をソケットに送信します。\n"
"送信するバイト文字列のフォーマットは、 :meth:`SocketHandler.makePickle` のド"
"キュメントで解説されています。"

#: ../../library/logging.handlers.rst:610
msgid "SysLogHandler"
msgstr "SysLogHandler"

#: ../../library/logging.handlers.rst:612
msgid ""
"The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a remote or local Unix syslog."
msgstr ""
":mod:`logging.handlers` モジュールに含まれる :class:`SysLogHandler` クラス"
"は、ログ記録メッセージを遠隔またはローカルの Unix syslog に送信する機能をサ"
"ポートしています。"

#: ../../library/logging.handlers.rst:618
msgid ""
"Returns a new instance of the :class:`SysLogHandler` class intended to "
"communicate with a remote Unix machine whose address is given by *address* "
"in the form of a ``(host, port)`` tuple.  If *address* is not specified, "
"``('localhost', 514)`` is used.  The address is used to open a socket.  An "
"alternative to providing a ``(host, port)`` tuple is providing an address as "
"a string, for example '/dev/log'. In this case, a Unix domain socket is used "
"to send the message to the syslog. If *facility* is not specified, :const:"
"`LOG_USER` is used. The type of socket opened depends on the *socktype* "
"argument, which defaults to :const:`socket.SOCK_DGRAM` and thus opens a UDP "
"socket. To open a TCP socket (for use with the newer syslog daemons such as "
"rsyslog), specify a value of :const:`socket.SOCK_STREAM`."
msgstr ""
"遠隔の Unix マシンと通信するための、 :class:`SysLogHandler` クラスの新たなイ"
"ンスタンスを返します。マシンのアドレスは ``(host, port)`` のタプル形式をとる "
"*address* で与えられます。 *address* が指定されない場合、 ``('localhost', "
"514)`` が使われます。アドレスは UDP ソケットを使って開かれます。 ``(host, "
"port)`` のタプル形式の代わりに文字列で \"/dev/log\" のように与えることもでき"
"ます。この場合、 Unix ドメインソケットが syslog にメッセージを送るのに使われ"
"ます。 *facility* が指定されない場合、 :const:`LOG_USER` が使われます。開かれ"
"るソケットの型は、 *socktype* 引数に依り、デフォルトは :const:`socket."
"SOCK_DGRAM` で、UDP ソケットを開きます。 (rsyslog のような新しい syslog デー"
"モンと使うために) TCP ソケットを開くには、 :const:`socket.SOCK_STREAM` の値を"
"指定してください。"

#: ../../library/logging.handlers.rst:630
msgid ""
"Note that if your server is not listening on UDP port 514, :class:"
"`SysLogHandler` may appear not to work. In that case, check what address you "
"should be using for a domain socket - it's system dependent. For example, on "
"Linux it's usually '/dev/log' but on OS/X it's '/var/run/syslog'. You'll "
"need to check your platform and use the appropriate address (you may need to "
"do this check at runtime if your application needs to run on several "
"platforms). On Windows, you pretty much have to use the UDP option."
msgstr ""
"使用中のサーバが UDP ポート 514 を待機していない場合、 :class:"
"`SysLogHandler` が正常に動作していないように見える場合があります。その場合、"
"ドメインソケットに使うべきアドレスを調べてください。そのアドレスはシステムに"
"よって異なります。例えば、Linux システムでは通常 '/dev/log' ですが、 OS X で"
"は '/var/run/syslog' です。プラットフォームを確認し、適切なアドレスを使う必要"
"があります (アプリケーションを複数のプラットフォーム上で動作させる必要がある"
"場合、実行時に確認する必要があるかもしれません)。Windows では、多くの場合、"
"UDP オプションを使用する必要があります。"

#: ../../library/logging.handlers.rst:639
msgid ""
"On macOS 12.x (Monterey), Apple has changed the behaviour of their syslog "
"daemon - it no longer listens on a domain socket. Therefore, you cannot "
"expect :class:`SysLogHandler` to work on this system."
msgstr ""
"macOS 12.x (Monterey) において、 Apple 社は syslog デーモンの振る舞いを変更し"
"ました - デーモンはドメインソケットをの待ち受けを行いません。したがって、この"
"システム上では :class:`SysLogHandler` が動作することは期待できません。"

#: ../../library/logging.handlers.rst:643
msgid "See :gh:`91070` for more information."
msgstr "より詳細な情報は :gh:`91070` を参照して下さい。"

#: ../../library/logging.handlers.rst:645
msgid "*socktype* was added."
msgstr "*socktype* が追加されました。"

#: ../../library/logging.handlers.rst:651
msgid "Closes the socket to the remote host."
msgstr "遠隔ホストへのソケットを閉じます。"

#: ../../library/logging.handlers.rst:655
msgid ""
"Tries to create a socket and, if it's not a datagram socket, connect it to "
"the other end. This method is called during handler initialization, but it's "
"not regarded as an error if the other end isn't listening at this point - "
"the method will be called again when emitting an event, if there is no "
"socket at that point."
msgstr ""

#: ../../library/logging.handlers.rst:665
msgid ""
"The record is formatted, and then sent to the syslog server. If exception "
"information is present, it is *not* sent to the server."
msgstr ""
"レコードは書式化された後、 syslog サーバに送信されます。例外情報が存在して"
"も、サーバには *送信されません* 。"

#: ../../library/logging.handlers.rst:668
msgid ""
"(See: :issue:`12168`.) In earlier versions, the message sent to the syslog "
"daemons was always terminated with a NUL byte, because early versions of "
"these daemons expected a NUL terminated message - even though it's not in "
"the relevant specification (:rfc:`5424`). More recent versions of these "
"daemons don't expect the NUL byte but strip it off if it's there, and even "
"more recent daemons (which adhere more closely to RFC 5424) pass the NUL "
"byte on as part of the message."
msgstr ""
"(参照: :issue:`12168`) 初期のバージョンでは、 syslog デーモンに送られるメッ"
"セージは常に NUL バイトで終端していました。初期のバージョンの syslog デーモン"
"が NUL 終端されたメッセージを期待していたからです - たとえ、それが適切な仕様 "
"(:rfc:`5424`) にはなかったとしても。 syslog デーモンの新しいバージョンは NUL "
"バイトを期待せず、代わりにもしそれがある場合は削除します。さらに、より最近の"
"デーモン (RFC 5424 により忠実なバージョン) は、メッセージの一部として NUL バ"
"イトを通します。"

#: ../../library/logging.handlers.rst:677
msgid ""
"To enable easier handling of syslog messages in the face of all these "
"differing daemon behaviours, the appending of the NUL byte has been made "
"configurable, through the use of a class-level attribute, ``append_nul``. "
"This defaults to ``True`` (preserving the existing behaviour) but can be set "
"to ``False`` on a ``SysLogHandler`` instance in order for that instance to "
"*not* append the NUL terminator."
msgstr ""
"このような異なるデーモンの振る舞いすべてに対して syslog メッセージの取り扱い"
"をより容易にするため、 NUL バイトの追加はクラスレベル属性 ``append_nul`` を使"
"用して設定できるようになりました。これはデフォルトで ``True`` (既存の振る舞い"
"を保持) ですが、 ``SysLogHandler`` インスタンスが NUL 終端文字を追加 *しない"
"* ように ``False`` にセットすることができます。"

#: ../../library/logging.handlers.rst:684
msgid ""
"(See: :issue:`12419`.) In earlier versions, there was no facility for an "
"\"ident\" or \"tag\" prefix to identify the source of the message. This can "
"now be specified using a class-level attribute, defaulting to ``\"\"`` to "
"preserve existing behaviour, but which can be overridden on a "
"``SysLogHandler`` instance in order for that instance to prepend the ident "
"to every message handled. Note that the provided ident must be text, not "
"bytes, and is prepended to the message exactly as is."
msgstr ""
"(参照: :issue:`12419`) 以前のバージョンでは、メッセージソースを識別するため"
"の \"ident\" あるいは \"tag\" プリフィックス機能はありませんでした。これは、"
"今ではクラスレベル属性を使用して指定することができるようになりました。デフォ"
"ルトでは既存の振る舞いを保持するために ``\"\"`` ですが、特定の "
"``SysLogHandler`` インスタンスが扱うすべてのメッセージに識別子を前置するよう"
"にそれをオーバーライドすることができます。識別子はバイトではなくテキストでな"
"ければならず、正確にそのままメッセージに前置されることに注意してください。"

#: ../../library/logging.handlers.rst:695
msgid ""
"Encodes the facility and priority into an integer. You can pass in strings "
"or integers - if strings are passed, internal mapping dictionaries are used "
"to convert them to integers."
msgstr ""
"ファシリティおよび優先度を整数に符号化します。値は文字列でも整数でも渡すこと"
"ができます。文字列が渡された場合、内部の対応付け辞書が使われ、整数に変換され"
"ます。"

#: ../../library/logging.handlers.rst:699
msgid ""
"The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and "
"mirror the values defined in the ``sys/syslog.h`` header file."
msgstr ""
"シンボリックな ``LOG_`` 値は :class:`SysLogHandler` で定義されています。これ"
"は ``sys/syslog.h`` ヘッダーファイルで定義された値を反映しています。"

#: ../../library/logging.handlers.rst:702
msgid "**Priorities**"
msgstr "**優先度**"

#: ../../library/logging.handlers.rst:705
#: ../../library/logging.handlers.rst:727
msgid "Name (string)"
msgstr "名前 (文字列)"

#: ../../library/logging.handlers.rst:705
#: ../../library/logging.handlers.rst:727
msgid "Symbolic value"
msgstr "シンボル値"

#: ../../library/logging.handlers.rst:707
msgid "``alert``"
msgstr "``alert``"

#: ../../library/logging.handlers.rst:707
msgid "LOG_ALERT"
msgstr "LOG_ALERT"

#: ../../library/logging.handlers.rst:709
msgid "``crit`` or ``critical``"
msgstr "``crit`` or ``critical``"

#: ../../library/logging.handlers.rst:709
msgid "LOG_CRIT"
msgstr "LOG_CRIT"

#: ../../library/logging.handlers.rst:711
msgid "``debug``"
msgstr "``debug``"

#: ../../library/logging.handlers.rst:711
msgid "LOG_DEBUG"
msgstr "LOG_DEBUG"

#: ../../library/logging.handlers.rst:713
msgid "``emerg`` or ``panic``"
msgstr "``emerg`` or ``panic``"

#: ../../library/logging.handlers.rst:713
msgid "LOG_EMERG"
msgstr "LOG_EMERG"

#: ../../library/logging.handlers.rst:715
msgid "``err`` or ``error``"
msgstr "``err`` or ``error``"

#: ../../library/logging.handlers.rst:715
msgid "LOG_ERR"
msgstr "LOG_ERR"

#: ../../library/logging.handlers.rst:717
msgid "``info``"
msgstr "``info``"

#: ../../library/logging.handlers.rst:717
msgid "LOG_INFO"
msgstr "LOG_INFO"

#: ../../library/logging.handlers.rst:719
msgid "``notice``"
msgstr "``notice``"

#: ../../library/logging.handlers.rst:719
msgid "LOG_NOTICE"
msgstr "LOG_NOTICE"

#: ../../library/logging.handlers.rst:721
msgid "``warn`` or ``warning``"
msgstr "``warn`` or ``warning``"

#: ../../library/logging.handlers.rst:721
msgid "LOG_WARNING"
msgstr "LOG_WARNING"

#: ../../library/logging.handlers.rst:724
msgid "**Facilities**"
msgstr "**ファシリティ**"

#: ../../library/logging.handlers.rst:729
msgid "``auth``"
msgstr "``auth``"

#: ../../library/logging.handlers.rst:729
msgid "LOG_AUTH"
msgstr "LOG_AUTH"

#: ../../library/logging.handlers.rst:731
msgid "``authpriv``"
msgstr "``authpriv``"

#: ../../library/logging.handlers.rst:731
msgid "LOG_AUTHPRIV"
msgstr "LOG_AUTHPRIV"

#: ../../library/logging.handlers.rst:733
msgid "``cron``"
msgstr "``cron``"

#: ../../library/logging.handlers.rst:733
msgid "LOG_CRON"
msgstr "LOG_CRON"

#: ../../library/logging.handlers.rst:735
msgid "``daemon``"
msgstr "``daemon``"

#: ../../library/logging.handlers.rst:735
msgid "LOG_DAEMON"
msgstr "LOG_DAEMON"

#: ../../library/logging.handlers.rst:737
msgid "``ftp``"
msgstr "``ftp``"

#: ../../library/logging.handlers.rst:737
msgid "LOG_FTP"
msgstr "LOG_FTP"

#: ../../library/logging.handlers.rst:739
msgid "``kern``"
msgstr "``kern``"

#: ../../library/logging.handlers.rst:739
msgid "LOG_KERN"
msgstr "LOG_KERN"

#: ../../library/logging.handlers.rst:741
msgid "``lpr``"
msgstr "``lpr``"

#: ../../library/logging.handlers.rst:741
msgid "LOG_LPR"
msgstr "LOG_LPR"

#: ../../library/logging.handlers.rst:743
msgid "``mail``"
msgstr "``mail``"

#: ../../library/logging.handlers.rst:743
msgid "LOG_MAIL"
msgstr "LOG_MAIL"

#: ../../library/logging.handlers.rst:745
msgid "``news``"
msgstr "``news``"

#: ../../library/logging.handlers.rst:745
msgid "LOG_NEWS"
msgstr "LOG_NEWS"

#: ../../library/logging.handlers.rst:747
msgid "``syslog``"
msgstr "``syslog``"

#: ../../library/logging.handlers.rst:747
msgid "LOG_SYSLOG"
msgstr "LOG_SYSLOG"

#: ../../library/logging.handlers.rst:749
msgid "``user``"
msgstr "``user``"

#: ../../library/logging.handlers.rst:749
msgid "LOG_USER"
msgstr "LOG_USER"

#: ../../library/logging.handlers.rst:751
msgid "``uucp``"
msgstr "``uucp``"

#: ../../library/logging.handlers.rst:751
msgid "LOG_UUCP"
msgstr "LOG_UUCP"

#: ../../library/logging.handlers.rst:753
msgid "``local0``"
msgstr "``local0``"

#: ../../library/logging.handlers.rst:753
msgid "LOG_LOCAL0"
msgstr "LOG_LOCAL0"

#: ../../library/logging.handlers.rst:755
msgid "``local1``"
msgstr "``local1``"

#: ../../library/logging.handlers.rst:755
msgid "LOG_LOCAL1"
msgstr "LOG_LOCAL1"

#: ../../library/logging.handlers.rst:757
msgid "``local2``"
msgstr "``local2``"

#: ../../library/logging.handlers.rst:757
msgid "LOG_LOCAL2"
msgstr "LOG_LOCAL2"

#: ../../library/logging.handlers.rst:759
msgid "``local3``"
msgstr "``local3``"

#: ../../library/logging.handlers.rst:759
msgid "LOG_LOCAL3"
msgstr "LOG_LOCAL3"

#: ../../library/logging.handlers.rst:761
msgid "``local4``"
msgstr "``local4``"

#: ../../library/logging.handlers.rst:761
msgid "LOG_LOCAL4"
msgstr "LOG_LOCAL4"

#: ../../library/logging.handlers.rst:763
msgid "``local5``"
msgstr "``local5``"

#: ../../library/logging.handlers.rst:763
msgid "LOG_LOCAL5"
msgstr "LOG_LOCAL5"

#: ../../library/logging.handlers.rst:765
msgid "``local6``"
msgstr "``local6``"

#: ../../library/logging.handlers.rst:765
msgid "LOG_LOCAL6"
msgstr "LOG_LOCAL6"

#: ../../library/logging.handlers.rst:767
msgid "``local7``"
msgstr "``local7``"

#: ../../library/logging.handlers.rst:767
msgid "LOG_LOCAL7"
msgstr "LOG_LOCAL7"

#: ../../library/logging.handlers.rst:772
msgid ""
"Maps a logging level name to a syslog priority name. You may need to "
"override this if you are using custom levels, or if the default algorithm is "
"not suitable for your needs. The default algorithm maps ``DEBUG``, ``INFO``, "
"``WARNING``, ``ERROR`` and ``CRITICAL`` to the equivalent syslog names, and "
"all other level names to 'warning'."
msgstr ""
"ログレベル名を syslog 優先度名に対応付けます。カスタムレベルを使用している場"
"合や、デフォルトアルゴリズムがニーズに適していない場合には、このメソッドを"
"オーバーライドする必要があるかもしれません。デフォルトアルゴリズムは、 "
"``DEBUG``, ``INFO``, ``WARNING``, ``ERROR``, ``CRITICAL`` を等価な syslog 名"
"に、他のすべてのレベル名を \"warning\" に対応付けます。"

#: ../../library/logging.handlers.rst:782
msgid "NTEventLogHandler"
msgstr "NTEventLogHandler"

#: ../../library/logging.handlers.rst:784
msgid ""
"The :class:`NTEventLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a local Windows NT, Windows "
"2000 or Windows XP event log. Before you can use it, you need Mark Hammond's "
"Win32 extensions for Python installed."
msgstr ""
":mod:`logging.handlers` モジュールに含まれる :class:`NTEventLogHandler` クラ"
"スは、ログ記録メッセージをローカルな Windows NT, Windows 2000, または "
"Windows XP のイベントログに送信する機能をサポートします。この機能を使えるよう"
"にするには、 Mark Hammond による Python 用 Win32 拡張パッケージをインストール"
"する必要があります。"

#: ../../library/logging.handlers.rst:792
msgid ""
"Returns a new instance of the :class:`NTEventLogHandler` class. The "
"*appname* is used to define the application name as it appears in the event "
"log. An appropriate registry entry is created using this name. The *dllname* "
"should give the fully qualified pathname of a .dll or .exe which contains "
"message definitions to hold in the log (if not specified, ``'win32service."
"pyd'`` is used - this is installed with the Win32 extensions and contains "
"some basic placeholder message definitions. Note that use of these "
"placeholders will make your event logs big, as the entire message source is "
"held in the log. If you want slimmer logs, you have to pass in the name of "
"your own .dll or .exe which contains the message definitions you want to use "
"in the event log). The *logtype* is one of ``'Application'``, ``'System'`` "
"or ``'Security'``, and defaults to ``'Application'``."
msgstr ""
":class:`NTEventLogHandler` クラスの新たなインスタンスを返します。 *appname* "
"はイベントログに表示する際のアプリケーション名を定義するために使われます。こ"
"の名前を使って適切なレジストリエントリが生成されます。 *dllname* はログに保存"
"するメッセージ定義の入った .dll または .exe ファイルへの完全修飾パス名を与え"
"なければなりません (指定されない場合、 ``'win32service.pyd'`` が使われます - "
"このライブラリは Win32 拡張とともにインストールされ、いくつかのプレースホルダ"
"となるメッセージ定義を含んでいます)。これらのプレースホルダを利用すると、メッ"
"セージの発信源全体がログに記録されるため、イベントログは巨大になるので注意し"
"てください。 *logtype* は ``'Application'``, ``'System'``, ``'Security'`` の"
"いずれかで、デフォルトは ``'Application'`` です。"

#: ../../library/logging.handlers.rst:808
msgid ""
"At this point, you can remove the application name from the registry as a "
"source of event log entries. However, if you do this, you will not be able "
"to see the events as you intended in the Event Log Viewer - it needs to be "
"able to access the registry to get the .dll name. The current version does "
"not do this."
msgstr ""
"現時点では、イベントログエントリの発信源としてのアプリケーション名をレジスト"
"リから除去することはできます。しかしこれを行うと、イベントログビューアで意図"
"した通りにログが見えなくなるでしょう - これはイベントログが .dll 名を取得する"
"ためにレジストリにアクセスできなければならないからです。現在のバージョンでは"
"この操作を行いません。"

#: ../../library/logging.handlers.rst:817
msgid ""
"Determines the message ID, event category and event type, and then logs the "
"message in the NT event log."
msgstr ""
"メッセージ ID\\ 、イベントカテゴリ、イベント型を決定し、メッセージを NT イベ"
"ントログに記録します。"

#: ../../library/logging.handlers.rst:823
msgid ""
"Returns the event category for the record. Override this if you want to "
"specify your own categories. This version returns 0."
msgstr ""
"レコードに対するイベントカテゴリを返します。自作のカテゴリを指定したい場合、"
"このメソッドをオーバライドしてください。このクラスのバージョンのメソッドは 0 "
"を返します。"

#: ../../library/logging.handlers.rst:829
msgid ""
"Returns the event type for the record. Override this if you want to specify "
"your own types. This version does a mapping using the handler's typemap "
"attribute, which is set up in :meth:`__init__` to a dictionary which "
"contains mappings for :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :"
"const:`ERROR` and :const:`CRITICAL`. If you are using your own levels, you "
"will either need to override this method or place a suitable dictionary in "
"the handler's *typemap* attribute."
msgstr ""
"レコードのイベント型を返します。自作の型を指定したい場合、このメソッドをオー"
"バライドしてください。このクラスのバージョンのメソッドは、ハンドラの "
"*typemap* 属性を使って対応付けを行います。この属性は :meth:`__init__` で初期"
"化され、 :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :const:`ERROR`, :"
"const:`CRITICAL` が入っています。自作のレベルを使っているのなら、このメソッド"
"をオーバライドするか、ハンドラの *typemap* 属性に適切な辞書を配置する必要があ"
"るでしょう。"

#: ../../library/logging.handlers.rst:840
msgid ""
"Returns the message ID for the record. If you are using your own messages, "
"you could do this by having the *msg* passed to the logger being an ID "
"rather than a format string. Then, in here, you could use a dictionary "
"lookup to get the message ID. This version returns 1, which is the base "
"message ID in :file:`win32service.pyd`."
msgstr ""
"レコードのメッセージ ID を返します。自作のメッセージを使っているのなら、ロ"
"ガーに渡される *msg* を書式化文字列ではなく ID にします。その上で、辞書参照を"
"行ってメッセージ ID を得ます。このクラスのバージョンでは 1 を返します。この値"
"は :file:`win32service.pyd` における基本メッセージ ID です。"

#: ../../library/logging.handlers.rst:849
msgid "SMTPHandler"
msgstr "SMTPHandler"

#: ../../library/logging.handlers.rst:851
msgid ""
"The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to an email address via SMTP."
msgstr ""
":mod:`logging.handlers` モジュールに含まれる :class:`SMTPHandler` クラスは、 "
"SMTP を介したログ記録メッセージの送信機能をサポートします。"

#: ../../library/logging.handlers.rst:857
msgid ""
"Returns a new instance of the :class:`SMTPHandler` class. The instance is "
"initialized with the from and to addresses and subject line of the email. "
"The *toaddrs* should be a list of strings. To specify a non-standard SMTP "
"port, use the (host, port) tuple format for the *mailhost* argument. If you "
"use a string, the standard SMTP port is used. If your SMTP server requires "
"authentication, you can specify a (username, password) tuple for the "
"*credentials* argument."
msgstr ""
"新たな :class:`SMTPHandler` クラスのインスタンスを返します。インスタンスは "
"email の from および to アドレス行、および subject 行とともに初期化されま"
"す。 *toaddrs* は文字列からなるリストでなければなりません。非標準の SMTP ポー"
"トを指定するには、 *mailhost* 引数に (host, port) のタプル形式を指定します。"
"文字列を使った場合、標準の SMTP ポートが使われます。もし SMTP サーバが認証を"
"必要とするならば、 (username, password) のタプル形式を *credentials* 引数に指"
"定することができます。"

#: ../../library/logging.handlers.rst:864
msgid ""
"To specify the use of a secure protocol (TLS), pass in a tuple to the "
"*secure* argument. This will only be used when authentication credentials "
"are supplied. The tuple should be either an empty tuple, or a single-value "
"tuple with the name of a keyfile, or a 2-value tuple with the names of the "
"keyfile and certificate file. (This tuple is passed to the :meth:`smtplib."
"SMTP.starttls` method.)"
msgstr ""
"セキュアプロトコル (TLS) の使用を指定するには *secure* 引数にタプルを渡してく"
"ださい。これは認証情報が渡された場合のみ使用されます。タプルは、空のタプル"
"か、キーファイルの名前を持つ1要素のタプルか、またはキーファイルと証明書ファイ"
"ルの名前を持つ2要素のタプルのいずれかでなければなりません。 (このタプルは :"
"meth:`smtplib.SMTP.starttls` メソッドに渡されます。)"

#: ../../library/logging.handlers.rst:871
msgid ""
"A timeout can be specified for communication with the SMTP server using the "
"*timeout* argument."
msgstr ""
"SMTP サーバとのコミュニケーションのために、 *timeout* 引数を使用してタイムア"
"ウトを指定することができます。"

#: ../../library/logging.handlers.rst:874
msgid "Added the *timeout* parameter."
msgstr ""

#: ../../library/logging.handlers.rst:879
msgid "Formats the record and sends it to the specified addressees."
msgstr "レコードを書式化し、指定されたアドレスに送信します。"

#: ../../library/logging.handlers.rst:884
msgid ""
"If you want to specify a subject line which is record-dependent, override "
"this method."
msgstr ""
"レコードに応じたサブジェクト行を指定したいなら、このメソッドをオーバライドし"
"てください。"

#: ../../library/logging.handlers.rst:890
msgid "MemoryHandler"
msgstr "MemoryHandler"

#: ../../library/logging.handlers.rst:892
msgid ""
"The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` "
"module, supports buffering of logging records in memory, periodically "
"flushing them to a :dfn:`target` handler. Flushing occurs whenever the "
"buffer is full, or when an event of a certain severity or greater is seen."
msgstr ""
":mod:`logging.handlers` モジュールに含まれる :class:`MemoryHandler` は、ログ"
"記録するレコードをメモリ上にバッファリングし、定期的にその内容をターゲット (:"
"dfn:`target`) となるハンドラにフラッシュする機能をサポートしています。フラッ"
"シュ処理はバッファが一杯になるか、ある深刻度かそれ以上のレベルを持つイベント"
"が観測された際に行われます。"

#: ../../library/logging.handlers.rst:897
msgid ""
":class:`MemoryHandler` is a subclass of the more general :class:"
"`BufferingHandler`, which is an abstract class. This buffers logging records "
"in memory. Whenever each record is added to the buffer, a check is made by "
"calling :meth:`shouldFlush` to see if the buffer should be flushed.  If it "
"should, then :meth:`flush` is expected to do the flushing."
msgstr ""
":class:`MemoryHandler` はより一般的な抽象クラス、 :class:`BufferingHandler` "
"のサブクラスです。この抽象クラスでは、ログ記録するレコードをメモリ上にバッ"
"ファリングします。各レコードがバッファに追加される毎に、 :meth:`shouldFlush` "
"を呼び出してバッファをフラッシュすべきかどうか調べます。フラッシュする必要が"
"ある場合、 :meth:`flush` がフラッシュ処理を行うものと想定されます。"

#: ../../library/logging.handlers.rst:906
msgid ""
"Initializes the handler with a buffer of the specified capacity. Here, "
"*capacity* means the number of logging records buffered."
msgstr ""
"容量つきのバッファーを設定してハンドラーが初期化されます。 *capacity* はバッ"
"ファ可能なログレコード数を意味します。"

#: ../../library/logging.handlers.rst:912
msgid ""
"Append the record to the buffer. If :meth:`shouldFlush` returns true, call :"
"meth:`flush` to process the buffer."
msgstr ""
"レコードをバッファに追加します。 :meth:`shouldFlush` が true を返す場合、バッ"
"ファを処理するために :meth:`flush` を呼び出します。"

#: ../../library/logging.handlers.rst:918
msgid ""
"For a :class:`BufferingHandler` instance, flushing means that it sets the "
"buffer to an empty list. This method can be overwritten to implement more "
"useful flushing behavior."
msgstr ""

#: ../../library/logging.handlers.rst:925
msgid ""
"Return ``True`` if the buffer is up to capacity. This method can be "
"overridden to implement custom flushing strategies."
msgstr ""
"バッファが許容量に達している場合に ``True`` を返します。このメソッドは自作の"
"フラッシュ処理方針を実装するためにオーバライドすることができます。"

#: ../../library/logging.handlers.rst:931
msgid ""
"Returns a new instance of the :class:`MemoryHandler` class. The instance is "
"initialized with a buffer size of *capacity* (number of records buffered). "
"If *flushLevel* is not specified, :const:`ERROR` is used. If no *target* is "
"specified, the target will need to be set using :meth:`setTarget` before "
"this handler does anything useful. If *flushOnClose* is specified as "
"``False``, then the buffer is *not* flushed when the handler is closed. If "
"not specified or specified as ``True``, the previous behaviour of flushing "
"the buffer will occur when the handler is closed."
msgstr ""
":class:`MemoryHandler` クラスの新たなインスタンスを返します。\n"
"インスタンスはサイズ *capacity* （バッファされるレコード数）のバッファととも"
"に初期化されます。\n"
"*flushLevel* が指定されていない場合、 :const:`ERROR` が使われます。\n"
"*target* が指定されていない場合、ハンドラが何らかの意味のある処理を行う前に :"
"meth:`setTarget` でターゲットを指定する必要があります。\n"
"*flushOnClose* が ``False`` に指定されていた場合、ハンドラが閉じられるときに"
"バッファはフラッシュ *されません* 。\n"
"*flushOnClose* が指定されていないか ``True`` に指定されていた場合、ハンドラが"
"閉じられるときのバッファのフラッシュは以前の挙動になります。"

#: ../../library/logging.handlers.rst:940
msgid "The *flushOnClose* parameter was added."
msgstr "*flushOnClose* パラメータが追加されました。"

#: ../../library/logging.handlers.rst:946
msgid "Calls :meth:`flush`, sets the target to ``None`` and clears the buffer."
msgstr ""
":meth:`flush` を呼び出し、ターゲットを ``None`` に設定してバッファを消去しま"
"す。"

#: ../../library/logging.handlers.rst:952
msgid ""
"For a :class:`MemoryHandler` instance, flushing means just sending the "
"buffered records to the target, if there is one. The buffer is also cleared "
"when buffered records are sent to the target. Override if you want different "
"behavior."
msgstr ""

#: ../../library/logging.handlers.rst:959
msgid "Sets the target handler for this handler."
msgstr "ターゲットハンドラをこのハンドラに設定します。"

#: ../../library/logging.handlers.rst:964
msgid "Checks for buffer full or a record at the *flushLevel* or higher."
msgstr ""
"バッファが一杯になっているか、 *flushLevel* またはそれ以上のレコードでないか"
"を調べます。"

#: ../../library/logging.handlers.rst:970
msgid "HTTPHandler"
msgstr "HTTPHandler"

#: ../../library/logging.handlers.rst:972
msgid ""
"The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a web server, using either "
"``GET`` or ``POST`` semantics."
msgstr ""
":mod:`logging.handlers` モジュールに含まれる :class:`HTTPHandler` クラスは、"
"ログ記録メッセージを ``GET`` または ``POST`` セマンティクスを使って Web サー"
"バに送信する機能をサポートしています。"

#: ../../library/logging.handlers.rst:979
msgid ""
"Returns a new instance of the :class:`HTTPHandler` class. The *host* can be "
"of the form ``host:port``, should you need to use a specific port number.  "
"If no *method* is specified, ``GET`` is used. If *secure* is true, a HTTPS "
"connection will be used. The *context* parameter may be set to a :class:`ssl."
"SSLContext` instance to configure the SSL settings used for the HTTPS "
"connection. If *credentials* is specified, it should be a 2-tuple consisting "
"of userid and password, which will be placed in a HTTP 'Authorization' "
"header using Basic authentication. If you specify credentials, you should "
"also specify secure=True so that your userid and password are not passed in "
"cleartext across the wire."
msgstr ""
":class:`HTTPHandler` クラスの新たなインスタンスを返します。特別なポートを使う"
"必要がある場合、*host* は ``host:port`` の形式で使うことができます。 "
"*method* が指定されない場合、 ``GET`` が使われます。 *secure* が真の場合、"
"HTTPS 接続が使われます。 HTTPS 接続で使用する SSL 設定のために *context* 引数"
"を :class:`ssl.SSLContext` のインスタンスに設定することができます。 "
"*credentials* を指定する場合、BASIC 認証の際の HTTP 'Authorization' ヘッダに"
"使われるユーザIDとパスワードからなる 2要素タプルを渡してください。 "
"credentials を指定する場合、ユーザIDとパスワードが通信中に平文として剥き出し"
"にならないよう、secure=True も指定すべきです。"

#: ../../library/logging.handlers.rst:990
msgid "The *context* parameter was added."
msgstr "*context* パラメータが追加されました。"

#: ../../library/logging.handlers.rst:995
msgid ""
"Provides a dictionary, based on ``record``, which is to be URL-encoded and "
"sent to the web server. The default implementation just returns ``record."
"__dict__``. This method can be overridden if e.g. only a subset of :class:"
"`~logging.LogRecord` is to be sent to the web server, or if more specific "
"customization of what's sent to the server is required."
msgstr ""
"URL エンコードされて Web サーバに送信することになる、 ``record`` に基づく辞書"
"を供給します。デフォルトの実装では単に ``record.__dict__`` を返します。例え"
"ば :class:`~logging.LogRecord` のサブセットのみを Web サーバに送信する場合"
"や、 サーバーに送信する内容を特別にカスタマイズする必要がある場合には、このメ"
"ソッドをオーバライドできます。"

#: ../../library/logging.handlers.rst:1003
msgid ""
"Sends the record to the web server as a URL-encoded dictionary. The :meth:"
"`mapLogRecord` method is used to convert the record to the dictionary to be "
"sent."
msgstr ""
"レコードを URL エンコードされた辞書形式で Web サーバに送信します。レコードを"
"送信のために辞書に変換するために :meth:`mapLogRecord` が呼び出されます。"

#: ../../library/logging.handlers.rst:1007
msgid ""
"Since preparing a record for sending it to a web server is not the same as a "
"generic formatting operation, using :meth:`~logging.Handler.setFormatter` to "
"specify a :class:`~logging.Formatter` for a :class:`HTTPHandler` has no "
"effect. Instead of calling :meth:`~logging.Handler.format`, this handler "
"calls :meth:`mapLogRecord` and then :func:`urllib.parse.urlencode` to encode "
"the dictionary in a form suitable for sending to a web server."
msgstr ""
"Web server に送信するためのレコードを準備することは一般的な書式化操作とは同じ"
"ではありませんので、 :meth:`~logging.Handler.setFormatter` を使って :class:"
"`~logging.Formatter` を指定することは、 :class:`HTTPHandler` には効果はありま"
"せん。 :meth:`~logging.Handler.format` を呼び出す代わりに、このハンドラは :"
"meth:`mapLogRecord` を呼び出し、その後その返却辞書を Web server に送信するの"
"に適した様式にエンコードするために :func:`urllib.parse.urlencode`  を呼び出し"
"ます。"

#: ../../library/logging.handlers.rst:1020
msgid "QueueHandler"
msgstr "QueueHandler"

#: ../../library/logging.handlers.rst:1024
msgid ""
"The :class:`QueueHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
":mod:`logging.handlers` モジュールに含まれる :class:`QueueHandler` クラス"
"は、 :mod:`queue` モジュールや :mod:`multiprocessing` のモジュールで実装され"
"るようなキューにログメッセージを送信する機能をサポートしています。"

#: ../../library/logging.handlers.rst:1028
msgid ""
"Along with the :class:`QueueListener` class, :class:`QueueHandler` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
":class:`QueueListener` クラスとともに :class:`QueueHandler` を使うと、ロギン"
"グを行うスレッドから分離されたスレッド上でハンドラを動かすことができます。こ"
"れは、クライアントに対してサービスするスレッドができるだけ速く応答する必要が"
"ある一方、別のスレッド上で (:class:`SMTPHandler` によって電子メールを送信する"
"ような) 潜在的に遅い操作が行われるような、ウェブアプリケーションおよびその他"
"のサービスアプリケーションにおいて重要です。"

#: ../../library/logging.handlers.rst:1037
msgid ""
"Returns a new instance of the :class:`QueueHandler` class. The instance is "
"initialized with the queue to send messages to. The *queue* can be any queue-"
"like object; it's used as-is by the :meth:`enqueue` method, which needs to "
"know how to send messages to it. The queue is not *required* to have the "
"task tracking API, which means that you can use :class:`~queue.SimpleQueue` "
"instances for *queue*."
msgstr ""
":class:`QueueHandler` クラスの新しいインスタンスを返します。インスタンスは、"
"キューにメッセージを送るように初期化されます。キューは任意のキューのようなオ"
"ブジェクトが可能です; それはそのまま :meth:`enqueue` メソッドによって使用され"
"ます。そのメソッドはメッセージを送る方法を知っている必要があります。もしタス"
"クのトラッキングAPIにキューが必要でない場合はキューとして :class:`~queue."
"SimpleQueue` のインスタンスが使用できます。"

#: ../../library/logging.handlers.rst:1044
#: ../../library/logging.handlers.rst:1133
msgid ""
"If you are using :mod:`multiprocessing`, you should avoid using :class:"
"`~queue.SimpleQueue` and instead use :class:`multiprocessing.Queue`."
msgstr ""
":mod:`multiprocessing` を使っている場合、 :class:`~queue.SimpleQueue` を使う"
"ことは避けてください。代わりに :class:`multiprocessing.Queue` を使ってくださ"
"い。"

#: ../../library/logging.handlers.rst:1049
msgid ""
"Enqueues the result of preparing the LogRecord. Should an exception occur (e."
"g. because a bounded queue has filled up), the :meth:`~logging.Handler."
"handleError` method is called to handle the error. This can result in the "
"record silently being dropped (if :data:`logging.raiseExceptions` is "
"``False``) or a message printed to ``sys.stderr`` (if :data:`logging."
"raiseExceptions` is ``True``)."
msgstr ""

#: ../../library/logging.handlers.rst:1058
msgid ""
"Prepares a record for queuing. The object returned by this method is "
"enqueued."
msgstr ""
"キューに追加するためレコードを準備します。このメソッドが返したオブジェクトが"
"キューに追加されます。"

#: ../../library/logging.handlers.rst:1061
msgid ""
"The base implementation formats the record to merge the message, arguments, "
"exception and stack information, if present.  It also removes unpickleable "
"items from the record in-place. Specifically, it overwrites the record's :"
"attr:`msg` and :attr:`message` attributes with the merged message (obtained "
"by calling the handler's :meth:`format` method), and sets the :attr:`args`, :"
"attr:`exc_info` and :attr:`exc_text` attributes to ``None``."
msgstr ""
"基底の実装はレコードがメッセージや引数と、またもし存在すれば、発生した例外お"
"よびスタック情報と統合されるようにフォーマットします。またこの実装では非 "
"pickle 化不可能な要素をレコードから削除します。特に、この実装はレコードの :"
"attr:`msg` と :attr:`message` 属性を (ハンドラの :meth:`format` メソッドを呼"
"び出すことによって得られる) 統合されたメッセージで上書きし、同時に :attr:"
"`args`, :attr:`exc_info`, :attr:`exc_text` の3つの属性値をすべて ``None`` に"
"設定します。"

#: ../../library/logging.handlers.rst:1069
msgid ""
"You might want to override this method if you want to convert the record to "
"a dict or JSON string, or send a modified copy of the record while leaving "
"the original intact."
msgstr ""
"レコードを dict や JSON 文字列に変換したい場合や、オリジナルのレコードを変更"
"せずに修正済のコピーを送りたい場合は、このメソッドをオーバーライドすると良い"
"でしょう。"

#: ../../library/logging.handlers.rst:1073
msgid ""
"The base implementation formats the message with arguments, sets the "
"``message`` and ``msg`` attributes to the formatted message and sets the "
"``args`` and ``exc_text`` attributes to ``None`` to allow pickling and to "
"prevent further attempts at formatting. This means that a handler on the :"
"class:`QueueListener` side won't have the information to do custom "
"formatting, e.g. of exceptions. You may wish to subclass ``QueueHandler`` "
"and override this method to e.g. avoid setting ``exc_text`` to ``None``. "
"Note that the ``message`` / ``msg`` / ``args`` changes are related to "
"ensuring the record is pickleable, and you might or might not be able to "
"avoid doing that depending on whether your ``args`` are pickleable. (Note "
"that you may have to consider not only your own code but also code in any "
"libraries that you use.)"
msgstr ""
"基底の実装は、レコードを pickle 化可能にしつつ、さらなるフォーマット処理を防"
"ぐために、メッセージを引数でフォーマットしてフォーマットされたメッセージを "
"``message`` と ``msg`` 属性に設定し、同時に ``args`` と ``exc_text`` 属性を "
"``None`` に設定します。このことは、 :class:`QueueListener` 側のハンドラが必要"
"なフォーマット処理を行う、たとえば例外のフォーマット処理を行う、ための必要な"
"情報が得られないかもしれないことを意味します。そのため、 ``QueueHandler`` の"
"派生クラスにおいてこのメソッドを、たとえば ``exc_text`` 属性が ``None`` に設"
"定されないように、オーバーライドしたいと考えるかもしれません。この場合、 "
"``message`` / ``msg`` / ``args`` といった属性の変更はレコードが pickle 化可能"
"であることを保証することと関係しており、元の ``args`` の値が pickle 化可能か"
"どうかによって、これらの属性の変更が避けられないかもしれないということに注意"
"してください (この点については、自分のコードだけでなく依存するライブラリの"
"コードも考慮しなければならないことにも注意してください)"

#: ../../library/logging.handlers.rst:1089
msgid ""
"Enqueues the record on the queue using ``put_nowait()``; you may want to "
"override this if you want to use blocking behaviour, or a timeout, or a "
"customized queue implementation."
msgstr ""
"キューにレコードを  ``put_nowait()`` を使ってエンキューします; ブロッキングや"
"タイムアウト、あるいはなにか特別なキューの実装を使いたければ、これをオーバラ"
"イドしてみてください。"

#: ../../library/logging.handlers.rst:1095
msgid ""
"When created via configuration using :func:`~logging.config.dictConfig`, "
"this attribute will contain a :class:`QueueListener` instance for use with "
"this handler. Otherwise, it will be ``None``."
msgstr ""

#: ../../library/logging.handlers.rst:1104
msgid "QueueListener"
msgstr "QueueListener"

#: ../../library/logging.handlers.rst:1108
msgid ""
"The :class:`QueueListener` class, located in the :mod:`logging.handlers` "
"module, supports receiving logging messages from a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules. The "
"messages are received from a queue in an internal thread and passed, on the "
"same thread, to one or more handlers for processing. While :class:"
"`QueueListener` is not itself a handler, it is documented here because it "
"works hand-in-hand with :class:`QueueHandler`."
msgstr ""
":mod:`logging.handlers` モジュールに含まれる :class:`QueueListener` クラス"
"は、 :mod:`queue` モジュールや :mod:`multiprocessing` のモジュールで実装され"
"るようなキューからログメッセージを受信する機能をサポートしています。メッセー"
"ジは内部スレッドのキューから受信され、同じスレッド上の複数のハンドラに渡され"
"て処理されます。 :class:`QueueListener` それ自体はハンドラではありません"
"が、 :class:`QueueHandler` と連携して動作するのでここで文書化されています。"

#: ../../library/logging.handlers.rst:1116
msgid ""
"Along with the :class:`QueueHandler` class, :class:`QueueListener` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
":class:`QueueHandler` クラスとともに :class:`QueueListener` を使うと、ロギン"
"グを行うスレッドから分離されたスレッド上でハンドラを動かすことができます。こ"
"れは、クライアントに対してサービスするスレッドができるだけ速く応答する必要が"
"ある一方、別のスレッド上で (:class:`SMTPHandler` によって電子メールを送信する"
"ような) 潜在的に遅い操作が行われるような、ウェブアプリケーションおよびその他"
"のサービスアプリケーションにおいて重要です。"

#: ../../library/logging.handlers.rst:1125
msgid ""
"Returns a new instance of the :class:`QueueListener` class. The instance is "
"initialized with the queue to send messages to and a list of handlers which "
"will handle entries placed on the queue. The queue can be any queue-like "
"object; it's passed as-is to the :meth:`dequeue` method, which needs to know "
"how to get messages from it. The queue is not *required* to have the task "
"tracking API (though it's used if available), which means that you can use :"
"class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""
":class:`QueueListener` クラスの新しいインスタンスを返します。インスタンスは、"
"メッセージを送るためのキューと、キューに格納されたエントリーを処理するハンド"
"ラーのリストが設定されて初期化されます。キューは任意のキューのようなオブジェ"
"クトが可能です; それはそのまま :meth:`dequeue` メソッドによって使用されます。"
"そのメソッドはメッセージを送る方法を知っている必要があります。もしタスクのト"
"ラッキングAPIにキューが必要でない場合はキューとして :class:`~queue."
"SimpleQueue` のインスタンスが使用できます（トラッキングAPIが使用可能な場合は"
"使用されます）。"

#: ../../library/logging.handlers.rst:1136
msgid ""
"If ``respect_handler_level`` is ``True``, a handler's level is respected "
"(compared with the level for the message) when deciding whether to pass "
"messages to that handler; otherwise, the behaviour is as in previous Python "
"versions - to always pass each message to each handler."
msgstr ""
"もし ``respect_handler_level`` が ``True`` なら、メッセージをハンドラーに渡す"
"か決める時に（メッセージのレベルに比べて）ハンドラーのレベルが尊重されます。"
"そうでない場合は依然のPythonバージョンと同様にすべてのメッセージは常にハンド"
"ラーに渡されます。"

#: ../../library/logging.handlers.rst:1141
msgid "The ``respect_handler_level`` argument was added."
msgstr " ``respect_handler_level`` 引数が追加されました。"

#: ../../library/logging.handlers.rst:1146
msgid "Dequeues a record and return it, optionally blocking."
msgstr ""
"キューからレコードを取り除き、それを返します。ブロッキングすることがありま"
"す。"

#: ../../library/logging.handlers.rst:1148
msgid ""
"The base implementation uses ``get()``. You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""
"ベース実装は ``get()`` を使用します。タイムアウトを有効にしたい場合や、カスタ"
"ムのキュー実装を使いたい場合は、このメソッドをオーバーライドすると良いでしょ"
"う。"

#: ../../library/logging.handlers.rst:1154
msgid "Prepare a record for handling."
msgstr "レコードを扱うための準備をします。"

#: ../../library/logging.handlers.rst:1156
msgid ""
"This implementation just returns the passed-in record. You may want to "
"override this method if you need to do any custom marshalling or "
"manipulation of the record before passing it to the handlers."
msgstr ""
"この実装は渡されたレコードをそのまま返します。その値をハンドラに渡す前に何ら"
"かのカスタムな整列化 (marshalling) あるいはレコードに対する操作を行う必要があ"
"れば、このメソッドをオーバーライドすると良いでしょう。"

#: ../../library/logging.handlers.rst:1162
msgid "Handle a record."
msgstr "レコードを処理します。"

#: ../../library/logging.handlers.rst:1164
msgid ""
"This just loops through the handlers offering them the record to handle. The "
"actual object passed to the handlers is that which is returned from :meth:"
"`prepare`."
msgstr ""
"これは、ハンドラをループしてそれらに処理すべきレコードを渡します。ハンドラに"
"渡される実際のオブジェクトは、 :meth:`prepare` から返されたものです。"

#: ../../library/logging.handlers.rst:1170
msgid "Starts the listener."
msgstr "リスナーを開始します。"

#: ../../library/logging.handlers.rst:1172
msgid ""
"This starts up a background thread to monitor the queue for LogRecords to "
"process."
msgstr ""
"これは、 LogRecord を処理するキューを監視するために、バックグラウンドスレッド"
"を開始します。"

#: ../../library/logging.handlers.rst:1177
msgid "Stops the listener."
msgstr "リスナーを停止します。"

#: ../../library/logging.handlers.rst:1179
msgid ""
"This asks the thread to terminate, and then waits for it to do so. Note that "
"if you don't call this before your application exits, there may be some "
"records still left on the queue, which won't be processed."
msgstr ""
"スレッドに終了するように依頼し、終了するまで待ちます。アプリケーションの終了"
"前にこのメソッドを呼ばないと、いくつかのレコードがキューに残り、処理されなく"
"なるかもしれないことに注意してください。"

#: ../../library/logging.handlers.rst:1185
msgid ""
"Writes a sentinel to the queue to tell the listener to quit. This "
"implementation uses ``put_nowait()``.  You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""
"リスナーに停止するように指示するためキューに番兵を書き込みます。この実装は "
"``put_nowait()`` を使用します。タイムアウトを有効にしたい場合や、カスタムの"
"キュー実装を使いたい場合は、このメソッドをオーバーライドすると良いでしょう。"

#: ../../library/logging.handlers.rst:1195
msgid "Module :mod:`logging`"
msgstr ":mod:`logging` モジュール"

#: ../../library/logging.handlers.rst:1196
msgid "API reference for the logging module."
msgstr "logging モジュールの API リファレンス。"

#: ../../library/logging.handlers.rst:1198
msgid "Module :mod:`logging.config`"
msgstr ":mod:`logging.config` モジュール"

#: ../../library/logging.handlers.rst:1199
msgid "Configuration API for the logging module."
msgstr "logging モジュールの環境設定 API です。"
