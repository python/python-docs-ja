# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2017
# Shun Sakurai, 2017
# Yuma.M, 2017
# Naoki INADA <songofacandy@gmail.com>, 2017
# E. Kawashima, 2017
# Yusuke Miyazaki <miyazaki.dev@gmail.com>, 2017
# yudetamago <yudetamago.orz@gmail.com>, 2018
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-29 09:36+0900\n"
"PO-Revision-Date: 2017-02-16 23:32+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/typing.rst:2
msgid ":mod:`typing` --- Support for type hints"
msgstr ":mod:`typing` --- å‹ãƒ’ãƒ³ãƒˆã®ã‚µãƒãƒ¼ãƒˆ"

#: ../../library/typing.rst:9
msgid "**Source code:** :source:`Lib/typing.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/typing.py`"

#: ../../library/typing.rst:13
msgid ""
"The typing module has been included in the standard library on a "
":term:`provisional basis <provisional api>`. New features might be added and"
" API may change even between minor releases if deemed necessary by the core "
"developers."
msgstr ""
"typing ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :term:`æš«å®šçš„ã« <provisional package>` "
"æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ãƒã‚¤ãƒŠãƒ¼ãƒªãƒªãƒ¼ã‚¹ã®é–“ã§ã‚‚ã‚³ã‚¢ãƒ‡ãƒ™ãƒ­ãƒƒãƒ‘ãƒ¼ãŒå¿…è¦ã ã¨åˆ¤æ–­ã—ãŸå ´åˆã¯ã€æ–°æ©Ÿèƒ½ã®è¿½åŠ ã‚„ API "
"ã®å¤‰æ›´ãŒãªã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/typing.rst:20
msgid ""
"This module supports type hints as specified by :pep:`484` and :pep:`526`. "
"The most fundamental support consists of the types :data:`Any`, "
":data:`Union`, :data:`Tuple`, :data:`Callable`, :class:`TypeVar`, and "
":class:`Generic`.  For full specification please see :pep:`484`.  For a "
"simplified introduction to type hints see :pep:`483`."
msgstr ""
"ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ :pep:`484` ã¨ :pep:`526` ã«ã‚ˆã£ã¦è¦å®šã•ã‚ŒãŸå‹ãƒ’ãƒ³ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚æœ€ã‚‚åŸºæœ¬çš„ãªã‚µãƒãƒ¼ãƒˆã¨ã—ã¦ "
":data:`Any`ã€ :data:`Union`ã€ :data:`Tuple`ã€ :data:`Callable`ã€ "
":class:`TypeVar` ãŠã‚ˆã³ :class:`Generic` å‹ã‚’å«ã¿ã¾ã™ã€‚å®Œå…¨ãªä»•æ§˜ã¯ :pep:`484` "
"ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚å‹ãƒ’ãƒ³ãƒˆã®ç°¡å˜ãªå°å…¥ã¯ :pep:`483` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/typing.rst:27
msgid ""
"The function below takes and returns a string and is annotated as follows::"
msgstr "ä»¥ä¸‹ã®é–¢æ•°ã¯æ–‡å­—åˆ—ã‚’å—ã‘å–ã£ã¦æ–‡å­—åˆ—ã‚’è¿”ã™é–¢æ•°ã§ã€æ¬¡ã®ã‚ˆã†ã«ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãŒã¤ã‘ã‚‰ã‚Œã¾ã™::"

#: ../../library/typing.rst:32
msgid ""
"In the function ``greeting``, the argument ``name`` is expected to be of "
"type :class:`str` and the return type :class:`str`. Subtypes are accepted as"
" arguments."
msgstr ""
"é–¢æ•° ``greeting`` ã§ã€å®Ÿå¼•æ•° ``name`` ã®å‹ã¯ :class:`str` ã§ã‚ã‚Šã€è¿”ã‚Šå€¤ã®å‹ã¯ :class:`str` "
"ã§ã‚ã‚‹ã“ã¨ãŒæœŸå¾…ã•ã‚Œã¾ã™ã€‚ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã‚‚å®Ÿå¼•æ•°ã¨ã—ã¦è¨±å®¹ã•ã‚Œã¾ã™ã€‚"

#: ../../library/typing.rst:37
msgid "Type aliases"
msgstr "å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹"

#: ../../library/typing.rst:39
msgid ""
"A type alias is defined by assigning the type to the alias. In this example,"
" ``Vector`` and ``List[float]`` will be treated as interchangeable "
"synonyms::"
msgstr ""
"å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã¯å‹ã‚’ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã«ä»£å…¥ã™ã‚‹ã“ã¨ã§å®šç¾©ã•ã‚Œã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯ ``Vector`` ã¨ ``List[float]`` "
"ã¯äº¤æ›å¯èƒ½ãªåŒç¾©èªã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/typing.rst:51
msgid ""
"Type aliases are useful for simplifying complex type signatures. For "
"example::"
msgstr "å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã¯è¤‡é›‘ãªå‹ã‚·ã‚°ãƒãƒãƒ£ã‚’å˜ç´”åŒ–ã™ã‚‹ã®ã«æœ‰ç”¨ã§ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/typing.rst:69
msgid ""
"Note that ``None`` as a type hint is a special case and is replaced by "
"``type(None)``."
msgstr "å‹ãƒ’ãƒ³ãƒˆã¨ã—ã¦ã® ``None`` ã¯ç‰¹åˆ¥ãªã‚±ãƒ¼ã‚¹ã§ã‚ã‚Šã€ ``type(None)`` ã«ã‚ˆã£ã¦ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/typing.rst:75
msgid "NewType"
msgstr "NewType"

#: ../../library/typing.rst:77
msgid "Use the :func:`NewType` helper function to create distinct types::"
msgstr "ç•°ãªã‚‹å‹ã‚’ä½œã‚‹ãŸã‚ã«ã¯ :func:`NewType` ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã‚’ä½¿ã„ã¾ã™::"

#: ../../library/typing.rst:84
msgid ""
"The static type checker will treat the new type as if it were a subclass of "
"the original type. This is useful in helping catch logical errors::"
msgstr "é™çš„å‹æ¤œæŸ»å™¨ã¯æ–°ã—ã„å‹ã‚’å…ƒã€…ã®å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚ˆã†ã«æ‰±ã„ã¾ã™ã€‚ã“ã®æŒ¯ã‚‹èˆã„ã¯è«–ç†çš„ãªèª¤ã‚Šã‚’è¦‹ã¤ã‘ã‚‹æ‰‹åŠ©ã‘ã¨ã—ã¦å½¹ã«ç«‹ã¡ã¾ã™ã€‚"

#: ../../library/typing.rst:96
msgid ""
"You may still perform all ``int`` operations on a variable of type "
"``UserId``, but the result will always be of type ``int``. This lets you "
"pass in a ``UserId`` wherever an ``int`` might be expected, but will prevent"
" you from accidentally creating a ``UserId`` in an invalid way::"
msgstr ""
"``UserId`` å‹ã®å¤‰æ•°ã‚‚ ``int`` ã®å…¨ã¦ã®æ¼”ç®—ãŒè¡Œãˆã¾ã™ãŒã€ãã®çµæœã¯å¸¸ã« ``int`` å‹ã«ãªã‚Šã¾ã™ã€‚\n"
"ã“ã®æŒ¯ã‚‹èˆã„ã«ã‚ˆã‚Šã€ ``int`` ãŒæœŸå¾…ã•ã‚Œã‚‹ã¨ã“ã‚ã« ``UserId`` ã‚’æ¸¡ã›ã¾ã™ãŒã€ä¸æ­£ãªæ–¹æ³•ã§ ``UserId`` ã‚’ä½œã£ã¦ã—ã¾ã†ã“ã¨ã‚’é˜²ãã¾ã™ã€‚"

#: ../../library/typing.rst:104
msgid ""
"Note that these checks are enforced only by the static type checker. At "
"runtime the statement ``Derived = NewType('Derived', Base)`` will make "
"``Derived`` a function that immediately returns whatever parameter you pass "
"it. That means the expression ``Derived(some_value)`` does not create a new "
"class or introduce any overhead beyond that of a regular function call."
msgstr ""
"ã“ã‚Œã‚‰ã®ãƒã‚§ãƒƒã‚¯ã¯é™çš„å‹æ¤œæŸ»å™¨ã®ã¿ã«ã‚ˆã£ã¦å¼·åˆ¶ã•ã‚Œã‚‹ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚å®Ÿè¡Œæ™‚ã« ``Derived = NewType('Derived',"
" Base)`` ã¨ã„ã†æ–‡ã¯æ¸¡ã•ã‚ŒãŸä»®å¼•æ•°ã‚’ãŸã ã¡ã«è¿”ã™ ``Derived`` é–¢æ•°ã‚’ä½œã‚Šã¾ã™ã€‚ã¤ã¾ã‚Š ``Derived(some_value)``"
" ã¨ã„ã†å¼ã¯æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‹ã“ã¨ã¯ãªãã€é€šå¸¸ã®é–¢æ•°å‘¼ã³å‡ºã—ä»¥ä¸Šã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ãŒãªã„ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚"

#: ../../library/typing.rst:110
msgid ""
"More precisely, the expression ``some_value is Derived(some_value)`` is "
"always true at runtime."
msgstr "ã‚ˆã‚Šæ­£ç¢ºã«è¨€ã†ã¨ã€å¼ ``some_value is Derived(some_value)`` ã¯å®Ÿè¡Œæ™‚ã«å¸¸ã«çœŸã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/typing.rst:113
msgid ""
"This also means that it is not possible to create a subtype of ``Derived`` "
"since it is an identity function at runtime, not an actual type::"
msgstr ""
"ã“ã‚Œã¯ ``Derived`` ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã‚’ä½œã‚‹ã“ã¨ãŒå‡ºæ¥ãªã„ã¨ã„ã†ã“ã¨ã‚‚æ„å‘³ã—ã¦ã„ã¾ã™ã€‚\n"
"``Derived`` ã¯å®Ÿè¡Œæ™‚ã«ã¯æ’ç­‰é–¢æ•°ã«ãªã£ã¦ã„ã¦ã€å®Ÿéš›ã®å‹ã§ã¯ãªã„ã‹ã‚‰ã§ã™::"

#: ../../library/typing.rst:123
msgid ""
"However, it is possible to create a :func:`NewType` based on a 'derived' "
"``NewType``::"
msgstr "ã—ã‹ã—ã€ 'derived' ã§ã‚ã‚‹ ``NewType`` ã‚’ã‚‚ã¨ã«ã—ãŸ :func:`NewType` ã¯ä½œã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™::"

#: ../../library/typing.rst:131
msgid "and typechecking for ``ProUserId`` will work as expected."
msgstr "ãã—ã¦ ``ProUserId`` ã«å¯¾ã™ã‚‹å‹æ¤œæŸ»ã¯æœŸå¾…é€šã‚Šã«å‹•ä½œã—ã¾ã™ã€‚"

#: ../../library/typing.rst:133
msgid "See :pep:`484` for more details."
msgstr "ã‚ˆã‚Šè©³ã—ãã¯ :pep:`484` ã‚’å‚ç…§ã‚’ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/typing.rst:137
msgid ""
"Recall that the use of a type alias declares two types to be *equivalent* to"
" one another. Doing ``Alias = Original`` will make the static type checker "
"treat ``Alias`` as being *exactly equivalent* to ``Original`` in all cases. "
"This is useful when you want to simplify complex type signatures."
msgstr ""
"å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã®ä½¿ç”¨ã¯äºŒã¤ã®å‹ãŒäº’ã„ã« *ç­‰ä¾¡* ã ã¨å®£è¨€ã—ã¦ã„ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’æ€ã„å‡ºã—ã¦ãã ã•ã„ã€‚ ``Alias = Original`` "
"ã¨ã™ã‚‹ã¨ã€é™çš„å‹æ¤œæŸ»å™¨ã¯ ``Alias`` ã‚’ã™ã¹ã¦ã®å ´åˆã«ãŠã„ã¦ ``Original`` ã¨ *å®Œå…¨ã«ç­‰ä¾¡* "
"ãªã‚‚ã®ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚ã“ã‚Œã¯è¤‡é›‘ãªå‹ã‚·ã‚°ãƒãƒãƒ£ã‚’å˜ç´”åŒ–ã—ãŸã„æ™‚ã«æœ‰ç”¨ã§ã™ã€‚"

#: ../../library/typing.rst:142
msgid ""
"In contrast, ``NewType`` declares one type to be a *subtype* of another. "
"Doing ``Derived = NewType('Derived', Original)`` will make the static type "
"checker treat ``Derived`` as a *subclass* of ``Original``, which means a "
"value of type ``Original`` cannot be used in places where a value of type "
"``Derived`` is expected. This is useful when you want to prevent logic "
"errors with minimal runtime cost."
msgstr ""
"ã“ã‚Œã«å¯¾ã—ã€ ``NewType`` ã¯ã‚ã‚‹å‹ã‚’ã‚‚ã†ä¸€æ–¹ã®å‹ã® *ã‚µãƒ–ã‚¿ã‚¤ãƒ—* ã¨ã—ã¦å®£è¨€ã—ã¾ã™ã€‚ ``Derived = "
"NewType('Derived', Original)`` ã¨ã™ã‚‹ã¨é™çš„å‹æ¤œæŸ»å™¨ã¯ ``Derived`` ã‚’ ``Original`` ã® "
"*ã‚µãƒ–ã‚¯ãƒ©ã‚¹* ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚ã¤ã¾ã‚Š ``Original`` å‹ã®å€¤ã¯ ``Derived`` "
"å‹ã®å€¤ãŒæœŸå¾…ã•ã‚Œã‚‹å ´æ‰€ã§ä½¿ã†ã“ã¨ãŒå‡ºæ¥ãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚ã“ã‚Œã¯è«–ç†çš„ãªèª¤ã‚Šã‚’æœ€å°ã®å®Ÿè¡Œæ™‚ã®ã‚³ã‚¹ãƒˆã§é˜²ããŸã„æ™‚ã«æœ‰ç”¨ã§ã™ã€‚"

#: ../../library/typing.rst:152
msgid "Callable"
msgstr "å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/typing.rst:154
msgid ""
"Frameworks expecting callback functions of specific signatures might be type"
" hinted using ``Callable[[Arg1Type, Arg2Type], ReturnType]``."
msgstr ""
"ç‰¹å®šã®ã‚·ã‚°ãƒãƒãƒ£ã‚’æŒã¤ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’è¦æ±‚ã•ã‚Œã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã¯ã€ ``Callable[[Arg1Type, Arg2Type], "
"ReturnType]`` ã‚’ä½¿ã£ã¦å‹ãƒ’ãƒ³ãƒˆã‚’ä»˜ã‘ã¾ã™ã€‚"

#: ../../library/typing.rst:157
msgid "For example::"
msgstr "ä¾‹ãˆã°::"

#: ../../library/typing.rst:168
msgid ""
"It is possible to declare the return type of a callable without specifying "
"the call signature by substituting a literal ellipsis for the list of "
"arguments in the type hint: ``Callable[..., ReturnType]``."
msgstr ""
"å‹ãƒ’ãƒ³ãƒˆã®å®Ÿå¼•æ•°ã®å‹ã‚’ ellipsis ã§ç½®ãæ›ãˆã‚‹ã“ã¨ã§å‘¼ã³å‡ºã—ã‚·ã‚°ãƒ‹ãƒãƒ£ã‚’æŒ‡å®šã›ãšã« callable ã®æˆ»ã‚Šå€¤ã®å‹ã‚’å®£è¨€ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™: "
"``Callable[..., ReturnType]``ã€‚"

#: ../../library/typing.rst:175
msgid "Generics"
msgstr "ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹"

#: ../../library/typing.rst:177
msgid ""
"Since type information about objects kept in containers cannot be statically"
" inferred in a generic way, abstract base classes have been extended to "
"support subscription to denote expected types for container elements."
msgstr ""
"ã‚³ãƒ³ãƒ†ãƒŠå†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã®å‹æƒ…å ±ã¯ä¸€èˆ¬çš„ãªæ–¹æ³•ã§ã¯é™çš„ã«æ¨è«–ã§ããªã„ãŸã‚ã€æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’ç¶™æ‰¿ã—ãŸã‚¯ãƒ©ã‚¹ãŒå®Ÿè£…ã•ã‚Œã€æœŸå¾…ã•ã‚Œã‚‹ã‚³ãƒ³ãƒ†ãƒŠã®è¦ç´ ã®å‹ã‚’ç¤ºã™ãŸã‚ã«æ·»å­—è¡¨è¨˜ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/typing.rst:188
msgid ""
"Generics can be parameterized by using a new factory available in typing "
"called :class:`TypeVar`."
msgstr ""
"ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã¯ã€ typing ã«ã‚ã‚‹ :class:`TypeVar` ã¨å‘¼ã°ã‚Œã‚‹æ–°ã—ã„ãƒ•ã‚¡ã‚¯ãƒˆãƒªã‚’ä½¿ã£ã¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/typing.rst:202
msgid "User-defined generic types"
msgstr "ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹"

#: ../../library/typing.rst:204
msgid "A user-defined class can be defined as a generic class."
msgstr "ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ã®ã‚¯ãƒ©ã‚¹ã‚’ã€ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚¯ãƒ©ã‚¹ã¨ã—ã¦å®šç¾©ã§ãã¾ã™ã€‚"

#: ../../library/typing.rst:230
msgid ""
"``Generic[T]`` as a base class defines that the class ``LoggedVar`` takes a "
"single type parameter ``T`` . This also makes ``T`` valid as a type within "
"the class body."
msgstr ""
"``Generic[T]`` ã‚’åŸºåº•ã‚¯ãƒ©ã‚¹ã«ã™ã‚‹ã“ã¨ã§ã€ ``LoggedVar`` ã‚¯ãƒ©ã‚¹ãŒ 1 ã¤ã®å‹å¼•æ•° ``T`` ã‚’ã¨ã‚‹ã€ã¨å®šç¾©ã§ãã¾ã™ã€‚\n"
"ã“ã®å®šç¾©ã«ã‚ˆã‚Šã€ã‚¯ãƒ©ã‚¹ã®æœ¬ä½“ã®ä¸­ã§ã‚‚ ``T`` ãŒå‹ã¨ã—ã¦æœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/typing.rst:234
msgid ""
"The :class:`Generic` base class uses a metaclass that defines "
":meth:`__getitem__` so that ``LoggedVar[t]`` is valid as a type::"
msgstr ""
"åŸºåº•ã‚¯ãƒ©ã‚¹ :class:`Generic` ã¯ ``LoggedVar[t]`` ãŒå‹ã¨ã—ã¦æœ‰åŠ¹ã«ãªã‚‹ã‚ˆã†ã« :meth:`__getitem__` "
"ã‚’å®šç¾©ã—ãŸãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/typing.rst:243
msgid ""
"A generic type can have any number of type variables, and type variables may"
" be constrained::"
msgstr "ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ã¯ä»»æ„ã®æ•°ã®å‹å¤‰æ•°ã‚’ã¨ã‚Œã¾ã™ã€ã¾ãŸå‹å¤‰æ•°ã«åˆ¶ç´„ã‚’ã¤ã‘ã‚‰ã‚Œã¾ã™::"

#: ../../library/typing.rst:255
msgid ""
"Each type variable argument to :class:`Generic` must be distinct. This is "
"thus invalid::"
msgstr ":class:`Generic` ã®å¼•æ•°ã®ãã‚Œãã‚Œã®å‹å¤‰æ•°ã¯åˆ¥ã®ã‚‚ã®ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ãŸã‚æ¬¡ã®ã‚¯ãƒ©ã‚¹å®šç¾©ã¯ç„¡åŠ¹ã§ã™::"

#: ../../library/typing.rst:266
msgid "You can use multiple inheritance with :class:`Generic`::"
msgstr ":class:`Generic` ã‚’ç”¨ã„ã¦å¤šé‡ç¶™æ‰¿ãŒå¯èƒ½ã§ã™::"

#: ../../library/typing.rst:275
msgid ""
"When inheriting from generic classes, some type variables could be fixed::"
msgstr "ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚¯ãƒ©ã‚¹ã‚’ç¶™æ‰¿ã™ã‚‹ã¨ãã€ã„ãã¤ã‹ã®å‹å¤‰æ•°ã‚’å›ºå®šã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™::"

#: ../../library/typing.rst:284
msgid "In this case ``MyDict`` has a single parameter, ``T``."
msgstr "ã“ã®å ´åˆã§ã¯ ``MyDict`` ã¯ä»®å¼•æ•° ``T`` ã‚’ 1 ã¤ã¨ã‚Šã¾ã™ã€‚"

#: ../../library/typing.rst:286
msgid ""
"Using a generic class without specifying type parameters assumes :data:`Any`"
" for each position. In the following example, ``MyIterable`` is not generic "
"but implicitly inherits from ``Iterable[Any]``::"
msgstr ""
"å‹å¼•æ•°ã‚’æŒ‡å®šã›ãšã«ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã†å ´åˆã€ãã‚Œãã‚Œã®å‹å¼•æ•°ã« :data:`Any` ã‚’ä¸ãˆã‚‰ã‚ŒãŸã‚‚ã®ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚\n"
"æ¬¡ã®ä¾‹ã§ã¯ã€``MyIterable`` ã¯ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒ ``Iterable[Any]`` ã‚’æš—é»™çš„ã«ç¶™æ‰¿ã—ã¦ã„ã¾ã™::"

#: ../../library/typing.rst:294
msgid "User defined generic type aliases are also supported. Examples::"
msgstr "ãƒ¦ãƒ¼ã‚¶å®šç¾©ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚‚ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚ä¾‹::"

#: ../../library/typing.rst:310
msgid ""
"The metaclass used by :class:`Generic` is a subclass of "
":class:`abc.ABCMeta`. A generic class can be an ABC by including abstract "
"methods or properties, and generic classes can also have ABCs as base "
"classes without a metaclass conflict. Generic metaclasses are not supported."
" The outcome of parameterizing generics is cached, and most types in the "
"typing module are hashable and comparable for equality."
msgstr ""
":class:`Generic` ã«ç”¨ã„ã‚‰ã‚Œã¦ã„ã‚‹ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã¯ :class:`abc.ABCMeta` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã™ã€‚\n"
"ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚¯ãƒ©ã‚¹ã¯æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã‚„æŠ½è±¡ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã¤ã“ã¨ã§æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã«ãªã‚Œã€ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚¯ãƒ©ã‚¹ã¯ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã®è¡çªã‚’èµ·ã“ã™ã“ã¨ãªãåŸºåº•ã‚¯ãƒ©ã‚¹ã«æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’ã¨ã‚Œã¾ã™ã€‚\n"
"ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚\n"
"ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã‚’è¡Œã†ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®çµæœã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¦ã„ã¦ã€ typing ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã»ã¨ã‚“ã©ã®å‹ã¯ãƒãƒƒã‚·ãƒ¥åŒ–ã§ãã€ç­‰ä¾¡æ¯”è¼ƒã§ãã¾ã™ã€‚"

#: ../../library/typing.rst:319
msgid "The :data:`Any` type"
msgstr ":data:`Any` å‹"

#: ../../library/typing.rst:321
msgid ""
"A special kind of type is :data:`Any`. A static type checker will treat "
"every type as being compatible with :data:`Any` and :data:`Any` as being "
"compatible with every type."
msgstr ""
":data:`Any` ã¯ç‰¹åˆ¥ãªç¨®é¡ã®å‹ã§ã™ã€‚é™çš„å‹æ¤œæŸ»å™¨ã¯ã™ã¹ã¦ã®å‹ã‚’ :data:`Any` ã¨äº’æ›ã¨ã—ã¦æ‰±ã„ã€ :data:`Any` "
"ã‚’ã™ã¹ã¦ã®å‹ã¨äº’æ›ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚"

#: ../../library/typing.rst:325
msgid ""
"This means that it is possible to perform any operation or method call on a "
"value of type on :data:`Any` and assign it to any variable::"
msgstr "ã¤ã¾ã‚Šã€ :data:`Any` å‹ã®å€¤ã«å¯¾ã—ä»»æ„ã®æ¼”ç®—ã‚„ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—ãŒã§ãã€ä»»æ„ã®å¤‰æ•°ã«ä»£å…¥ã§ãã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../library/typing.rst:343
msgid ""
"Notice that no typechecking is performed when assigning a value of type "
":data:`Any` to a more precise type. For example, the static type checker did"
" not report an error when assigning ``a`` to ``s`` even though ``s`` was "
"declared to be of type :class:`str` and receives an :class:`int` value at "
"runtime!"
msgstr ""
":data:`Any` å‹ã®å€¤ã‚’ã‚ˆã‚Šè©³ç´°ãªå‹ã«ä»£å…¥ã™ã‚‹æ™‚ã«å‹æ¤œæŸ»ãŒè¡Œã‚ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ä¾‹ãˆã°ã€é™çš„å‹æ¤œæŸ»å™¨ã¯ ``a`` ã‚’ ``s`` "
"ã«ä»£å…¥ã™ã‚‹æ™‚ã€``s`` ãŒ :class:`str` å‹ã¨ã—ã¦å®£è¨€ã•ã‚Œã¦ã„ã¦å®Ÿè¡Œæ™‚ã« :class:`int` "
"ã®å€¤ã‚’å—ã‘å–ã‚‹ã¨ã—ã¦ã‚‚ã€ã‚¨ãƒ©ãƒ¼ã‚’å ±å‘Šã—ã¾ã›ã‚“ã€‚"

#: ../../library/typing.rst:349
msgid ""
"Furthermore, all functions without a return type or parameter types will "
"implicitly default to using :data:`Any`::"
msgstr "ã•ã‚‰ã«ã€è¿”ã‚Šå€¤ã‚„å¼•æ•°ã®å‹ã®ãªã„ã™ã¹ã¦ã®é–¢æ•°ã¯æš—é»™çš„ã« :data:`Any` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/typing.rst:362
msgid ""
"This behavior allows :data:`Any` to be used as an *escape hatch* when you "
"need to mix dynamically and statically typed code."
msgstr ""
"ã“ã®æŒ™å‹•ã«ã‚ˆã‚Šã€å‹•çš„å‹ä»˜ã‘ã¨é™çš„å‹ä»˜ã‘ãŒæ··åœ¨ã—ãŸã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã‹ãªã‘ã‚Œã°ãªã‚‰ãªã„æ™‚ã« :data:`Any` ã‚’ *éå¸¸å£* ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"

#: ../../library/typing.rst:365
msgid ""
"Contrast the behavior of :data:`Any` with the behavior of :class:`object`. "
"Similar to :data:`Any`, every type is a subtype of :class:`object`. However,"
" unlike :data:`Any`, the reverse is not true: :class:`object` is *not* a "
"subtype of every other type."
msgstr ""
":data:`Any` ã®æŒ™å‹•ã¨ :class:`object` ã®æŒ™å‹•ã‚’å¯¾æ¯”ã—ã¾ã—ã‚‡ã†ã€‚ :data:`Any` ã¨åŒæ§˜ã«ã€ã™ã¹ã¦ã®å‹ã¯ "
":class:`object` ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ã™ã€‚ã—ã‹ã—ãªãŒã‚‰ã€ :data:`Any` ã¨ç•°ãªã‚Šã€é€†ã¯æˆã‚Šç«‹ã¡ã¾ã›ã‚“: :class:`object`"
" ã¯ã™ã¹ã¦ã®ä»–ã®å‹ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ã¯ *ã‚ã‚Šã¾ã›ã‚“*ã€‚"

#: ../../library/typing.rst:370
msgid ""
"That means when the type of a value is :class:`object`, a type checker will "
"reject almost all operations on it, and assigning it to a variable (or using"
" it as a return value) of a more specialized type is a type error. For "
"example::"
msgstr ""
"ã“ã‚Œã¯ã€ã‚ã‚‹å€¤ã®å‹ãŒ :class:`object` ã®ã¨ãã€å‹æ¤œæŸ»å™¨ã¯ã“ã‚Œã«ã¤ã„ã¦ã®ã»ã¨ã‚“ã©ã™ã¹ã¦ã®æ“ä½œã‚’æ‹’å¦ã—ã€ã“ã‚Œã‚’ã‚ˆã‚Šç‰¹æ®ŠåŒ–ã•ã‚ŒãŸå¤‰æ•°ã«ä»£å…¥ã™ã‚‹"
" (ã¾ãŸã¯è¿”ã‚Šå€¤ã¨ã—ã¦åˆ©ç”¨ã™ã‚‹) ã“ã¨ã¯å‹ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/typing.rst:392
msgid ""
"Use :class:`object` to indicate that a value could be any type in a typesafe"
" manner. Use :data:`Any` to indicate that a value is dynamically typed."
msgstr ""
":class:`object` ã¯ã€ã‚ã‚‹å€¤ãŒå‹å®‰å…¨ãªæ–¹æ³•ã§ä»»æ„ã®å‹ã¨ã—ã¦ä½¿ãˆã‚‹ã“ã¨ã‚’ç¤ºã™ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™ã€‚ :data:`Any` "
"ã¯ã‚ã‚‹å€¤ãŒå‹•çš„ã«å‹ä»˜ã‘ã‚‰ã‚Œã‚‹ã“ã¨ã‚’ç¤ºã™ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/typing.rst:396
msgid "Classes, functions, and decorators"
msgstr "ã‚¯ãƒ©ã‚¹ã€é–¢æ•°ã€ãŠã‚ˆã³ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿"

#: ../../library/typing.rst:398
msgid "The module defines the following classes, functions and decorators:"
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ä»¥ä¸‹ã®ã‚¯ãƒ©ã‚¹ã€é–¢æ•°ã¨ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã‚’å®šç¾©ã—ã¾ã™:"

#: ../../library/typing.rst:402
msgid "Type variable."
msgstr "å‹å¤‰æ•°ã§ã™ã€‚"

#: ../../library/typing.rst:404 ../../library/typing.rst:805
msgid "Usage::"
msgstr "ä½¿ã„æ–¹::"

#: ../../library/typing.rst:409
msgid ""
"Type variables exist primarily for the benefit of static type checkers.  "
"They serve as the parameters for generic types as well as for generic "
"function definitions.  See class Generic for more information on generic "
"types.  Generic functions work as follows::"
msgstr ""
"å‹å¤‰æ•°ã¯ä¸»ã¨ã—ã¦é™çš„å‹æ¤œæŸ»å™¨ã®ãŸã‚ã«å­˜åœ¨ã—ã¾ã™ã€‚å‹å¤‰æ•°ã¯ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ã‚„ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°ã®å®šç¾©ã®å¼•æ•°ã¨ã—ã¦å½¹ã«ç«‹ã¡ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ã«ã¤ã„ã¦ã®è©³ç´°ã¯ "
"Generic ã‚¯ãƒ©ã‚¹ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å‹•ä½œã—ã¾ã™::"

#: ../../library/typing.rst:422
msgid ""
"The latter example's signature is essentially the overloading of ``(str, "
"str) -> str`` and ``(bytes, bytes) -> bytes``.  Also note that if the "
"arguments are instances of some subclass of :class:`str`, the return type is"
" still plain :class:`str`."
msgstr ""
"å¾Œè€…ã®ä¾‹ã®ã‚·ã‚°ãƒãƒãƒ£ã¯æœ¬è³ªçš„ã« ``(str, str) -> str`` ã¨ ``(bytes, bytes) -> bytes`` "
"ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã§ã™ã€‚ã‚‚ã—å¼•æ•°ãŒ :class:`str` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å ´åˆã€è¿”ã‚Šå€¤ã¯æ™®é€šã® :class:`str` "
"ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/typing.rst:427
msgid ""
"At runtime, ``isinstance(x, T)`` will raise :exc:`TypeError`.  In general, "
":func:`isinstance` and :func:`issubclass` should not be used with types."
msgstr ""
"å®Ÿè¡Œæ™‚ã«ã€``isinstance(x, T)`` ã¯ :exc:`TypeError` "
"ã‚’é€å‡ºã™ã‚‹ã§ã—ã‚‡ã†ã€‚ä¸€èˆ¬çš„ã«ã€:func:`isinstance` ã¨ :func:`issubclass` ã¯å‹ã«å¯¾ã—ã¦ä½¿ç”¨ã™ã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/typing.rst:430
msgid ""
"Type variables may be marked covariant or contravariant by passing "
"``covariant=True`` or ``contravariant=True``.  See :pep:`484` for more "
"details.  By default type variables are invariant.  Alternatively, a type "
"variable may specify an upper bound using ``bound=<type>``. This means that "
"an actual type substituted (explicitly or implicitly) for the type variable "
"must be a subclass of the boundary type, see :pep:`484`."
msgstr ""
"å‹å¤‰æ•°ã¯ ``covariant=True`` ã¾ãŸã¯ ``contravariant=True`` "
"ã‚’æ¸¡ã™ã“ã¨ã«ã‚ˆã£ã¦å…±å¤‰ã¾ãŸã¯åå¤‰ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã›ã¾ã™ã€‚è©³ç´°ã¯ :pep:`484` ã‚’å‚ç…§ã—ã¦ä¸‹ã•ã„ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹å¤‰æ•°ã¯ä¸å¤‰ã§ã™ã€‚ã‚ã‚‹ã„ã¯ã€å‹å¤‰æ•°ã¯ "
"``bound=<type>`` ã‚’ä½¿ã†ã“ã¨ã§ä¸Šç•Œã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚ã“ã‚Œã¯ã€å‹å¤‰æ•°ã« (æ˜ç¤ºçš„ã¾ãŸã¯éæ˜ç¤ºçš„ã«) "
"ä»£å…¥ã•ã‚ŒãŸå®Ÿéš›ã®å‹ãŒå¢ƒç•Œã®å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€:pep:`484` ã‚‚å‚ç…§ã€‚"

#: ../../library/typing.rst:440
msgid "Abstract base class for generic types."
msgstr "ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ã®ãŸã‚ã®æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/typing.rst:442
msgid ""
"A generic type is typically declared by inheriting from an instantiation of "
"this class with one or more type variables. For example, a generic mapping "
"type might be defined as::"
msgstr ""
"ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ã¯å…¸å‹çš„ã«ã¯ã“ã®ã‚¯ãƒ©ã‚¹ã‚’1ã¤ä»¥ä¸Šã®å‹å¤‰æ•°ã«ã‚ˆã£ã¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã—ãŸã‚‚ã®ã‚’ç¶™æ‰¿ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦å®£è¨€ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒãƒƒãƒ—å‹ã¯æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™::"

#: ../../library/typing.rst:451
msgid "This class can then be used as follows::"
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã¯æ¬¡ã®ã‚ˆã†ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™::"

#: ../../library/typing.rst:464
msgid ""
"A variable annotated with ``C`` may accept a value of type ``C``. In "
"contrast, a variable annotated with ``Type[C]`` may accept values that are "
"classes themselves -- specifically, it will accept the *class object* of "
"``C``. For example::"
msgstr ""
"``C`` ã¨æ³¨é‡ˆãŒä»˜ã‘ã•ã‚ŒãŸå¤‰æ•°ã¯ ``C`` å‹ã®å€¤ã‚’å—ç†ã—ã¾ã™ã€‚ä¸€æ–¹ã§ ``Type[C]`` "
"ã¨æ³¨é‡ˆãŒä»˜ã‘ã‚‰ã‚ŒãŸå¤‰æ•°ã¯ã€ãã®ã‚¯ãƒ©ã‚¹è‡ªèº«ã‚’å—ç†ã—ã¾ã™ -- å…·ä½“çš„ã«ã¯ã€ãã‚Œã¯ ``C`` ã® *ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ* ã‚’å—ç†ã—ã¾ã™ã€‚ä¾‹::"

#: ../../library/typing.rst:473
msgid "Note that ``Type[C]`` is covariant::"
msgstr "``Type[C]`` ã¯å…±å¤‰ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„::"

#: ../../library/typing.rst:485
msgid ""
"The fact that ``Type[C]`` is covariant implies that all subclasses of ``C`` "
"should implement the same constructor signature and class method signatures "
"as ``C``. The type checker should flag violations of this, but should also "
"allow constructor calls in subclasses that match the constructor calls in "
"the indicated base class. How the type checker is required to handle this "
"particular case may change in future revisions of :pep:`484`."
msgstr ""
"``Type[C]`` ãŒå…±å¤‰ã ã¨ã„ã†ã“ã¨ã¯ã€ ``C`` ã®å…¨ã¦ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã¯ã€ ``C`` ã¨åŒã˜ã‚·ã‚°ãƒãƒãƒ£ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã¹ãã ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚\n"
"å‹ãƒã‚§ãƒƒã‚«ãƒ¼ã¯ã“ã®è¦å‰‡ã¸ã®é•åã«å°ã‚’ä»˜ã‘ã‚‹ã¹ãã§ã™ãŒã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—ã§ã€æŒ‡å®šã•ã‚ŒãŸåŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—ã«é©åˆã™ã‚‹ã‚‚ã®ã¯è¨±å¯ã™ã¹ãã§ã™ã€‚\n"
"ã“ã®ç‰¹åˆ¥ãªå ´åˆã‚’å‹ãƒã‚§ãƒƒã‚«ãƒ¼ãŒã©ã†æ‰±ã†ã¹ãã‹ã«ã¤ã„ã¦ã¯ã€ :pep:`484` ã®å°†æ¥ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§å¤‰æ›´ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/typing.rst:493
msgid ""
"The only legal parameters for :class:`Type` are classes, :data:`Any`, "
":ref:`type variables <generics>`, and unions of any of these types. For "
"example::"
msgstr ""
":class:`Type` ã§è¨±ã•ã‚Œã¦ã„ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ã€ã‚¯ãƒ©ã‚¹ã€ :data:`Any` ã€ :ref:`å‹å¤‰æ•° <generics>` ã‚ã‚‹ã„ã¯ã€ãã‚Œã‚‰ã®ç›´å’Œå‹ã ã‘ã§ã™ã€‚\n"
"ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/typing.rst:499
msgid ""
"``Type[Any]`` is equivalent to ``Type`` which in turn is equivalent to "
"``type``, which is the root of Python's metaclass hierarchy."
msgstr ""
"``Type[Any]`` ã¯ ``Type`` ã¨ç­‰ä¾¡ã§ã€åŒæ§˜ã« ``Type`` ã¯ ``type`` ã¨ç­‰ä¾¡ã§ã™ã€‚``type`` ã¯ "
"Python ã®ãƒ¡ã‚¿ã‚¯ãƒ©ã‚¹éšå±¤ã®ãƒ«ãƒ¼ãƒˆã§ã™ã€‚"

#: ../../library/typing.rst:506
msgid "A generic version of :class:`collections.abc.Iterable`."
msgstr ":class:`collections.abc.Iterable` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:510
msgid "A generic version of :class:`collections.abc.Iterator`."
msgstr ":class:`collections.abc.Iterator` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:514
msgid "A generic version of :class:`collections.abc.Reversible`."
msgstr ":class:`collections.abc.Reversible` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:518
msgid "An ABC with one abstract method ``__int__``."
msgstr "æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ ``__int__`` ã‚’å‚™ãˆãŸ ABC ã§ã™ã€‚"

#: ../../library/typing.rst:522
msgid "An ABC with one abstract method ``__float__``."
msgstr "æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ ``__float__`` ã‚’å‚™ãˆãŸ ABC ã§ã™ã€‚"

#: ../../library/typing.rst:526
msgid "An ABC with one abstract method ``__complex__``."
msgstr "æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ ``__complex__`` ã‚’å‚™ãˆãŸ ABC ã§ã™ã€‚"

#: ../../library/typing.rst:530
msgid "An ABC with one abstract method ``__bytes__``."
msgstr "æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ ``__bytes__`` ã‚’å‚™ãˆãŸ ABC ã§ã™ã€‚"

#: ../../library/typing.rst:534
msgid ""
"An ABC with one abstract method ``__abs__`` that is covariant in its return "
"type."
msgstr "è¿”ã‚Šå€¤ã®å‹ã¨å…±å¤‰ãªæŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ ``__abs__`` ã‚’å‚™ãˆãŸ ABC ã§ã™ã€‚"

#: ../../library/typing.rst:539
msgid ""
"An ABC with one abstract method ``__round__`` that is covariant in its "
"return type."
msgstr "è¿”ã‚Šå€¤ã®å‹ã¨å…±å¤‰ãªæŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ ``__round__`` ã‚’å‚™ãˆãŸ ABC ã§ã™ã€‚"

#: ../../library/typing.rst:544
msgid "A generic version of :class:`collections.abc.Container`."
msgstr ":class:`collections.abc.Container` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:548
msgid "An alias to :class:`collections.abc.Hashable`"
msgstr ":class:`collections.abc.Hashable` ã¸ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹"

#: ../../library/typing.rst:552
msgid "An alias to :class:`collections.abc.Sized`"
msgstr ":class:`collections.abc.Sized` ã¸ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹"

#: ../../library/typing.rst:556
msgid "A generic version of :class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:562
msgid "A generic version of :class:`collections.abc.Set`."
msgstr ":class:`collections.abc.Set` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:566
msgid "A generic version of :class:`collections.abc.MutableSet`."
msgstr ":class:`collections.abc.MutableSet` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:570
msgid "A generic version of :class:`collections.abc.Mapping`."
msgstr ":class:`collections.abc.Mapping` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:574
msgid "A generic version of :class:`collections.abc.MutableMapping`."
msgstr ":class:`collections.abc.MutableMapping` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:578
msgid "A generic version of :class:`collections.abc.Sequence`."
msgstr ":class:`collections.abc.Sequence` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:582
msgid "A generic version of :class:`collections.abc.MutableSequence`."
msgstr ":class:`collections.abc.MutableSequence` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:586
msgid "A generic version of :class:`collections.abc.ByteString`."
msgstr ":class:`collections.abc.ByteString` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:588
msgid ""
"This type represents the types :class:`bytes`, :class:`bytearray`, and "
":class:`memoryview`."
msgstr "ã“ã®å‹ã¯ :class:`bytes` ã¨ :class:`bytearray` ã€ :class:`memoryview` ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/typing.rst:591
msgid ""
"As a shorthand for this type, :class:`bytes` can be used to annotate "
"arguments of any of the types mentioned above."
msgstr "ã“ã®å‹ã®çœç•¥å½¢ã¨ã—ã¦ã€ :class:`bytes` ã‚’ä¸Šã«æŒ™ã’ãŸä»»æ„ã®å‹ã®å¼•æ•°ã«ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã¤ã‘ã‚‹ã“ã¨ã«ä½¿ãˆã¾ã™ã€‚"

#: ../../library/typing.rst:596
msgid "A generic version of :class:`collections.deque`."
msgstr ":class:`collections.deque` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:602
msgid ""
"Generic version of :class:`list`. Useful for annotating return types. To "
"annotate arguments it is preferred to use abstract collection types such as "
":class:`Mapping`, :class:`Sequence`, or :class:`AbstractSet`."
msgstr ""
":class:`list` "
"ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚è¿”ã‚Šå€¤ã®å‹ã®ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã¤ã‘ã‚‹ã“ã¨ã«ä¾¿åˆ©ã§ã™ã€‚å¼•æ•°ã«ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã¤ã‘ã‚‹ãŸã‚ã«ã¯ã€:class:`Mapping` ã‚„ "
":class:`Sequence` ã€ :class:`AbstractSet` ã®ã‚ˆã†ãªæŠ½è±¡ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹ã‚’ä½¿ã†ã“ã¨ãŒå¥½ã¾ã—ã„ã§ã™ã€‚"

#: ../../library/typing.rst:607
msgid "This type may be used as follows::"
msgstr "ã“ã®å‹ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ä½¿ã†ã“ã¨ãŒå‡ºæ¥ã¾ã™::"

#: ../../library/typing.rst:619
msgid "A generic version of :class:`builtins.set <set>`."
msgstr ":class:`builtins.set <set>` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:623
msgid "A generic version of :class:`builtins.frozenset <frozenset>`."
msgstr ":class:`builtins.frozenset <frozenset>` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:627
msgid "A generic version of :class:`collections.abc.MappingView`."
msgstr ":class:`collections.abc.MappingView` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:631
msgid "A generic version of :class:`collections.abc.KeysView`."
msgstr ":class:`collections.abc.KeysView` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:635
msgid "A generic version of :class:`collections.abc.ItemsView`."
msgstr ":class:`collections.abc.ItemsView` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:639
msgid "A generic version of :class:`collections.abc.ValuesView`."
msgstr ":class:`collections.abc.ValuesView` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:643
msgid "A generic version of :class:`collections.abc.Awaitable`."
msgstr ":class:`collections.abc.Awaitable` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:647
msgid ""
"A generic version of :class:`collections.abc.Coroutine`. The variance and "
"order of type variables correspond to those of :class:`Generator`, for "
"example::"
msgstr ""
":class:`collections.abc.Coroutine` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚\n"
"å¤‰æ€§ã¨å‹å¤‰æ•°ã®é †åºã¯ :class:`Generator` ã®ã‚‚ã®ã¨å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/typing.rst:660
msgid "A generic version of :class:`collections.abc.AsyncIterable`."
msgstr ":class:`collections.abc.AsyncIterable` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:664
msgid "A generic version of :class:`collections.abc.AsyncIterator`."
msgstr ":class:`collections.abc.AsyncIterator` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:668
msgid "A generic version of :class:`contextlib.AbstractContextManager`."
msgstr ":class:`contextlib.AbstractContextManager` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:674
msgid "A generic version of :class:`contextlib.AbstractAsyncContextManager`."
msgstr ":class:`contextlib.AbstractAsyncContextManager` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:680
msgid ""
"A generic version of :class:`dict`. The usage of this type is as follows::"
msgstr ":class:`dict` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚ã“ã®å‹ã®ä½¿ã„æ–¹ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™::"

#: ../../library/typing.rst:688
msgid "A generic version of :class:`collections.defaultdict`."
msgstr ":class:`collections.defaultdict` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:694
msgid "A generic version of :class:`collections.Counter`."
msgstr ":class:`collections.Counter` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:700
msgid "A generic version of :class:`collections.ChainMap`."
msgstr ":class:`collections.ChainMap` ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:706
msgid ""
"A generator can be annotated by the generic type ``Generator[YieldType, "
"SendType, ReturnType]``. For example::"
msgstr ""
"ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ ``Generator[YieldType, SendType, ReturnType]`` "
"ã«ã‚ˆã£ã¦ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/typing.rst:715
msgid ""
"Note that unlike many other generics in the typing module, the ``SendType`` "
"of :class:`Generator` behaves contravariantly, not covariantly or "
"invariantly."
msgstr ""
"typing ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å¤šãã®ä»–ã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã¨é•ã„ :class:`Generator` ã® ``SendType`` "
"ã¯å…±å¤‰ã‚„ä¸å¤‰ã§ã¯ãªãã€åå¤‰ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/typing.rst:719
msgid ""
"If your generator will only yield values, set the ``SendType`` and "
"``ReturnType`` to ``None``::"
msgstr ""
"ã‚‚ã—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒå€¤ã‚’è¿”ã™ã ã‘ã®å ´åˆã¯ã€ ``SendType`` ã¨ ``ReturnType`` ã« ``None`` ã‚’è¨­å®šã—ã¦ãã ã•ã„::"

#: ../../library/typing.rst:727
msgid ""
"Alternatively, annotate your generator as having a return type of either "
"``Iterable[YieldType]`` or ``Iterator[YieldType]``::"
msgstr ""
"ä»£ã‚ã‚Šã«ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚’ ``Iterable[YieldType]`` ã‚„ ``Iterator[YieldType]`` "
"ã¨ã„ã†è¿”ã‚Šå€¤ã®å‹ã§ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã¤ã‘ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™::"

#: ../../library/typing.rst:737
msgid ""
"An async generator can be annotated by the generic type "
"``AsyncGenerator[YieldType, SendType]``. For example::"
msgstr ""
"éåŒæœŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ ``AsyncGenerator[YieldType, SendType]`` "
"ã«ã‚ˆã£ã¦ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/typing.rst:746
msgid ""
"Unlike normal generators, async generators cannot return a value, so there "
"is no ``ReturnType`` type parameter. As with :class:`Generator`, the "
"``SendType`` behaves contravariantly."
msgstr ""
"é€šå¸¸ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¨é•ã£ã¦éåŒæœŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯å€¤ã‚’è¿”ã›ãªã„ã®ã§ã€``ReturnType`` å‹å¼•æ•°ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚:class:`Generator` "
"ã¨åŒæ§˜ã«ã€``SendType`` ã¯åå¤‰çš„ã«æŒ¯ã‚‹èˆã„ã¾ã™ã€‚"

#: ../../library/typing.rst:750
msgid ""
"If your generator will only yield values, set the ``SendType`` to ``None``::"
msgstr "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒå€¤ã‚’ yield ã™ã‚‹ã ã‘ãªã‚‰ã€``SendType`` ã‚’ ``None`` ã«ã—ã¾ã™::"

#: ../../library/typing.rst:758
msgid ""
"Alternatively, annotate your generator as having a return type of either "
"``AsyncIterable[YieldType]`` or ``AsyncIterator[YieldType]``::"
msgstr ""
"ã‚ã‚‹ã„ã¯ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒ ``AsyncIterable[YieldType]`` ã¨ ``AsyncIterator[YieldType]`` "
"ã®ã„ãšã‚Œã‹ã®æˆ»ã‚Šå€¤å‹ã‚’æŒã¤ã¨ã‚¢ãƒãƒ†ãƒ¼ãƒˆã—ã¾ã™::"

#: ../../library/typing.rst:770
msgid ""
"``Text`` is an alias for ``str``. It is provided to supply a forward "
"compatible path for Python 2 code: in Python 2, ``Text`` is an alias for "
"``unicode``."
msgstr ""
"``Text`` ã¯ ``str`` ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã™ã€‚ã“ã‚Œã¯ Python 2 ã®ã‚³ãƒ¼ãƒ‰ã®å‰æ–¹äº’æ›æ€§ã‚’æä¾›ã™ã‚‹ãŸã‚ã«è¨­ã‘ã‚‰ã‚Œã¦ã„ã¾ã™: Python "
"2 ã§ã¯ ``Text`` ã¯ ``unicode`` ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã™ã€‚"

#: ../../library/typing.rst:774
msgid ""
"Use ``Text`` to indicate that a value must contain a unicode string in a "
"manner that is compatible with both Python 2 and Python 3::"
msgstr ""
"``Text`` ã¯ Python 2 ã¨ Python 3 ã®ä¸¡æ–¹ã¨äº’æ›æ€§ã®ã‚ã‚‹æ–¹æ³•ã§å€¤ãŒ unicode "
"æ–‡å­—åˆ—ã‚’å«ã‚“ã§ã„ãªã‘ã‚Œã°ãªã‚‰ãªã„å ´åˆã«ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/typing.rst:786
msgid ""
"Generic type ``IO[AnyStr]`` and its subclasses ``TextIO(IO[str])`` and "
"``BinaryIO(IO[bytes])`` represent the types of I/O streams such as returned "
"by :func:`open`."
msgstr ""
"ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ ``IO[AnyStr]`` ã¨ãã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã® ``TextIO(IO[str])`` ãŠã‚ˆã³ "
"``BinaryIO(IO[bytes])`` ã¯ã€ :func:`open` é–¢æ•°ãŒè¿”ã™ã‚ˆã†ãª I/O ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å‹ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/typing.rst:794
msgid ""
"These type aliases correspond to the return types from :func:`re.compile` "
"and :func:`re.match`.  These types (and the corresponding functions) are "
"generic in ``AnyStr`` and can be made specific by writing ``Pattern[str]``, "
"``Pattern[bytes]``, ``Match[str]``, or ``Match[bytes]``."
msgstr ""
"ã“ã‚Œã‚‰ã®å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã¯ :func:`re.compile` ã¨ :func:`re.match` ã®è¿”ã‚Šå€¤ã®å‹ã«å¯¾å¿œã—ã¾ã™ã€‚\n"
"ã“ã‚Œã‚‰ã®å‹ (ã¨å¯¾å¿œã™ã‚‹é–¢æ•°) ã¯ ``AnyStr`` ã«ã¤ã„ã¦ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã§ã€``Pattern[str]`` ã€ ``Pattern[bytes]`` ã€ ``Match[str]`` ã€ ``Match[bytes]`` ã¨æ›¸ãã“ã¨ã§å…·ä½“å‹ã«ã§ãã¾ã™ã€‚"

#: ../../library/typing.rst:803
msgid "Typed version of namedtuple."
msgstr "namedtuple ã®å‹ä»˜ãç‰ˆã§ã™ã€‚"

#: ../../library/typing.rst:811
msgid "This is equivalent to::"
msgstr "ã“ã‚Œã¯æ¬¡ã¨ç­‰ä¾¡ã§ã™::"

#: ../../library/typing.rst:815
msgid ""
"To give a field a default value, you can assign to it in the class body::"
msgstr "ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä¸ãˆã‚‹ã«ã¯ã‚¯ãƒ©ã‚¹æœ¬ä½“ã§ä»£å…¥ã—ã¦ãã ã•ã„::"

#: ../../library/typing.rst:824
msgid ""
"Fields with a default value must come after any fields without a default."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®ã‚ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®ãªã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å¾Œã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/typing.rst:826
msgid ""
"The resulting class has two extra attributes: ``_field_types``, giving a "
"dict mapping field names to types, and ``_field_defaults``, a dict mapping "
"field names to default values.  (The field names are in the ``_fields`` "
"attribute, which is part of the namedtuple API.)"
msgstr ""
"çµæœã¨ã—ã¦ã§ãã‚‹ã‚¯ãƒ©ã‚¹ã¯äºŒã¤ã®è¿½åŠ ã®å±æ€§ã‚’æŒã¡ã¾ã™ã€‚ä¸€ã¤ã¯ ``_field_types`` ã§ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’å‹ã«çµã³ã¤ã‘ã‚‹è¾æ›¸ã§ã™ã€‚\n"
"ã‚‚ã†ä¸€ã¤ã¯ ``_field_defaults`` ã§ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã«çµã³ã¤ã‘ã‚‹è¾æ›¸ã§ã™ã€‚\n"
"(ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã¯ namedtuple API ã®ä¸€ã¤ã§ã‚ã‚‹ ``_fields`` å±æ€§ã«ã‚ã‚Šã¾ã™ã€‚)"

#: ../../library/typing.rst:831
msgid "``NamedTuple`` subclasses can also have docstrings and methods::"
msgstr "``NamedTuple`` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã¯ docstring ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚æŒã¦ã¾ã™::"

#: ../../library/typing.rst:841
msgid "Backward-compatible usage::"
msgstr "å¾Œæ–¹äº’æ›ãªä½¿ç”¨æ³•::"

#: ../../library/typing.rst:845
msgid "Added support for :pep:`526` variable annotation syntax."
msgstr ":pep:`526` å¤‰æ•°ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/typing.rst:848
msgid "Added support for default values, methods, and docstrings."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã€ãƒ¡ã‚½ãƒƒãƒ‰ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—ã¸ã®å¯¾å¿œãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/typing.rst:853
msgid ""
"A helper function to indicate a distinct types to a typechecker, see "
":ref:`distinct`. At runtime it returns a function that returns its argument."
" Usage::"
msgstr ""
"ç•°ãªã‚‹å‹ã§ã‚ã‚‹ã“ã¨ã‚’å‹ãƒã‚§ãƒƒã‚«ãƒ¼ã«æ•™ãˆã‚‹ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã§ã™ã€‚\n"
":ref:`distinct` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚\n"
"å®Ÿè¡Œæ™‚ã«ã¯ã€ãã®å¼•æ•°ã‚’è¿”ã™é–¢æ•°ã‚’è¿”ã—ã¾ã™ã€‚\n"
"ä½¿ã„æ–¹ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/typing.rst:864
msgid "Cast a value to a type."
msgstr "å€¤ã‚’ã‚ã‚‹å‹ã«ã‚­ãƒ£ã‚¹ãƒˆã—ã¾ã™ã€‚"

#: ../../library/typing.rst:866
msgid ""
"This returns the value unchanged.  To the type checker this signals that the"
" return value has the designated type, but at runtime we intentionally don't"
" check anything (we want this to be as fast as possible)."
msgstr ""
"ã“ã®é–¢æ•°ã¯å€¤ã‚’å¤‰æ›´ã›ãšã«è¿”ã—ã¾ã™ã€‚\n"
"å‹æ¤œæŸ»å™¨ã«å¯¾ã—ã¦ã€è¿”ã‚Šå€¤ãŒæŒ‡å®šã•ã‚ŒãŸå‹ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ã‚’é€šçŸ¥ã—ã¾ã™ãŒã€å®Ÿè¡Œæ™‚ã«ã¯æ„å›³çš„ã«ä½•ã‚‚æ¤œæŸ»ã—ã¾ã›ã‚“ã€‚\n"
"(ãã®ç†ç”±ã¯ã€å‡¦ç†ã‚’ã§ãã‚‹é™ã‚Šé€Ÿãã—ãŸã‹ã£ãŸãŸã‚ã§ã™ã€‚)"

#: ../../library/typing.rst:873
msgid ""
"Return a dictionary containing type hints for a function, method, module or "
"class object."
msgstr "é–¢æ•°ã€ãƒ¡ã‚½ãƒƒãƒ‰ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¾ãŸã¯ã‚¯ãƒ©ã‚¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ãƒ’ãƒ³ãƒˆã‚’å«ã‚€è¾æ›¸ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/typing.rst:876
msgid ""
"This is often the same as ``obj.__annotations__``. In addition, forward "
"references encoded as string literals are handled by evaluating them in "
"``globals`` and ``locals`` namespaces. If necessary, ``Optional[t]`` is "
"added for function and method annotations if a default value equal to "
"``None`` is set. For a class ``C``, return a dictionary constructed by "
"merging all the ``__annotations__`` along ``C.__mro__`` in reverse order."
msgstr ""
"ã“ã®è¾æ›¸ã¯ãŸã„ã¦ã„ ``obj.__annotations__`` ã¨åŒã˜ã‚‚ã®ã§ã™ã€‚\n"
"ãã‚Œã«åŠ ãˆã¦ã€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸé †æ–¹å‘å‚ç…§ã¯ ``globals`` åå‰ç©ºé–“ãŠã‚ˆã³ ``locals`` åå‰ç©ºé–“ã§è©•ä¾¡ã•ã‚Œã¾ã™ã€‚\n"
"å¿…è¦ã§ã‚ã‚Œã°ã€ ``None`` ã¨ç­‰ä¾¡ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã€é–¢æ•°ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã« ``Optional[t]`` ãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚\n"
"ã‚¯ãƒ©ã‚¹ ``C`` ã«ã¤ã„ã¦ã¯ã€ ``C.__mro__`` ã®é€†é †ã«æ²¿ã£ã¦å…¨ã¦ã® ``__annotations__`` ã‚’åˆä½µã—ã¦æ§‹ç¯‰ã•ã‚ŒãŸè¾æ›¸ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/typing.rst:886
msgid ""
"The ``@overload`` decorator allows describing functions and methods that "
"support multiple different combinations of argument types. A series of "
"``@overload``-decorated definitions must be followed by exactly one "
"non-``@overload``-decorated definition (for the same function/method). The "
"``@overload``-decorated definitions are for the benefit of the type checker "
"only, since they will be overwritten by the non-``@overload``-decorated "
"definition, while the latter is used at runtime but should be ignored by a "
"type checker.  At runtime, calling a ``@overload``-decorated function "
"directly will raise :exc:`NotImplementedError`. An example of overload that "
"gives a more precise type than can be expressed using a union or a type "
"variable::"
msgstr ""
"``@overload`` ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ã†ã¨ã€å¼•æ•°ã®å‹ã®è¤‡æ•°ã®çµ„ã¿åˆã‚ã›ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹é–¢æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ›¸ã‘ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚\n"
"``@overload`` ä»˜ãã®å®šç¾©ã‚’ä¸¦ã¹ãŸå¾Œã‚ã«ã€(åŒã˜é–¢æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã®) ``@overload`` ç„¡ã—ã®å®šç¾©ãŒæ¥ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"``@overload`` ä»˜ãã®å®šç¾©ã¯å‹ãƒã‚§ãƒƒã‚«ãƒ¼ã®ãŸã‚ã§ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚\n"
"ã¨ã„ã†ã®ã‚‚ã€ ``@overload`` ä»˜ãã®å®šç¾©ã¯ ``@overload`` ç„¡ã—ã®å®šç¾©ã§ä¸Šæ›¸ãã•ã‚Œã‚‹ã‹ã‚‰ã§ã™ã€‚\n"
"å¾Œè€…ã¯å®Ÿè¡Œæ™‚ã«ä½¿ã‚ã‚Œã¾ã™ãŒã€å‹ãƒã‚§ãƒƒã‚«ãƒ¼ã‹ã‚‰ã¯ç„¡è¦–ã•ã‚Œã‚‹ã¹ããªã®ã§ã™ã€‚\n"
"å®Ÿè¡Œæ™‚ã«ã¯ã€ ``@overload`` ä»˜ãã®é–¢æ•°ã‚’ç›´æ¥å‘¼ã³å‡ºã™ã¨ :exc:`NotImplementedError` ã‚’é€å‡ºã—ã¾ã™ã€‚\n"
"æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã‚’ä½¿ã†ã“ã¨ã§ç›´å’Œå‹ã‚„å‹å¤‰æ•°ã‚’ä½¿ã†ã‚ˆã‚Šã‚‚ã‚ˆã‚Šæ­£ç¢ºãªå‹ãŒè¡¨ç¾ã§ãã‚‹ä¾‹ã§ã™::"

#: ../../library/typing.rst:910
msgid "See :pep:`484` for details and comparison with other typing semantics."
msgstr "è©³ç´°ã¨ä»–ã®å‹ä»˜ã‘æ„å‘³è«–ã¨ã®æ¯”è¼ƒã¯ :pep:`484` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/typing.rst:914
msgid "Decorator to indicate that annotations are not type hints."
msgstr "ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãŒå‹ãƒ’ãƒ³ãƒˆã§ãªã„ã“ã¨ã‚’ç¤ºã™ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã§ã™ã€‚"

#: ../../library/typing.rst:916
msgid ""
"This works as class or function :term:`decorator`.  With a class, it applies"
" recursively to all methods defined in that class (but not to methods "
"defined in its superclasses or subclasses)."
msgstr ""
"ã“ã‚Œã¯ã‚¯ãƒ©ã‚¹ :term:`decorator` ã¾ãŸã¯é–¢æ•° :term:`decorator` ã¨ã—ã¦å‹•ä½œã—ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ "
":term:`decorator` "
"ã¨ã—ã¦å‹•ä½œã™ã‚‹å ´åˆã¯ã€ãã®ã‚¯ãƒ©ã‚¹å†…ã«å®šç¾©ã•ã‚ŒãŸã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«å¯¾ã—ã¦å†å¸°çš„ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚ï¼ˆãŸã ã—ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹ã‚„ã‚µãƒ–ã‚¯ãƒ©ã‚¹å†…ã«å®šç¾©ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯é©ç”¨ã•ã‚Œã¾ã›ã‚“ã€‚ï¼‰"

#: ../../library/typing.rst:920
msgid "This mutates the function(s) in place."
msgstr "ã“ã‚Œã¯é–¢æ•°ã‚’é©åˆ‡ã«å¤‰æ›´ã—ã¾ã™ã€‚"

#: ../../library/typing.rst:924
msgid "Decorator to give another decorator the :func:`no_type_check` effect."
msgstr "åˆ¥ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã« :func:`no_type_check` ã®åŠ¹æœã‚’ä¸ãˆã‚‹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã§ã™ã€‚"

#: ../../library/typing.rst:926
msgid ""
"This wraps the decorator with something that wraps the decorated function in"
" :func:`no_type_check`."
msgstr "ã“ã‚Œã¯ä½•ã‹ã®é–¢æ•°ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã‚’ :func:`no_type_check` ã§ãƒ©ãƒƒãƒ—ã—ã¾ã™ã€‚"

#: ../../library/typing.rst:931
msgid "Special type indicating an unconstrained type."
msgstr "åˆ¶ç´„ã®ãªã„å‹ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ç‰¹åˆ¥ãªå‹ã§ã™ã€‚"

#: ../../library/typing.rst:933
msgid "Every type is compatible with :data:`Any`."
msgstr "ä»»æ„ã®å‹ã¯ :data:`Any` ã¨äº’æ›ã§ã™ã€‚"

#: ../../library/typing.rst:934
msgid ":data:`Any` is compatible with every type."
msgstr ":data:`Any` ã¯ä»»æ„ã®å‹ã¨äº’æ›ã§ã™ã€‚"

#: ../../library/typing.rst:938
msgid "Special type indicating that a function never returns. For example::"
msgstr "é–¢æ•°ãŒè¿”ã‚Šå€¤ã‚’æŒãŸãªã„ã“ã¨ã‚’ç¤ºã™ç‰¹åˆ¥ãªå‹ã§ã™ã€‚ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ä½¿ã„ã¾ã™::"

#: ../../library/typing.rst:950
msgid "Union type; ``Union[X, Y]`` means either X or Y."
msgstr "ãƒ¦ãƒ‹ã‚ªãƒ³å‹; ``Union[X, Y]`` ã¯ X ã¾ãŸã¯ Y ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/typing.rst:952
msgid "To define a union, use e.g. ``Union[int, str]``.  Details:"
msgstr "ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã‚’å®šç¾©ã—ã¾ã™ã€ä¾‹ãˆã° ``Union[int, str]`` ã®ã‚ˆã†ã«ä½¿ã„ã¾ã™ã€‚è©³ç´°:"

#: ../../library/typing.rst:954
msgid "The arguments must be types and there must be at least one."
msgstr "å¼•æ•°ã¯å‹ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€å°‘ãªãã¨ã‚‚ä¸€ã¤å¿…è¦ã§ã™ã€‚"

#: ../../library/typing.rst:956
msgid "Unions of unions are flattened, e.g.::"
msgstr "ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã®ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã¯å¹³æ»‘åŒ–ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/typing.rst:960
msgid "Unions of a single argument vanish, e.g.::"
msgstr "å¼•æ•°ãŒä¸€ã¤ã®ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã¯æ¶ˆãˆã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/typing.rst:964
msgid "Redundant arguments are skipped, e.g.::"
msgstr "å†—é•·ãªå®Ÿå¼•æ•°ã¯é£›ã°ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/typing.rst:968
msgid "When comparing unions, the argument order is ignored, e.g.::"
msgstr "ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã‚’æ¯”è¼ƒã™ã‚‹ã¨ãå¼•æ•°ã®é †åºã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°::"

#: ../../library/typing.rst:972
msgid "You cannot subclass or instantiate a union."
msgstr "ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ãŸã‚Šã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ã“ã¨ã¯å‡ºæ¥ã¾ã›ã‚“ã€‚"

#: ../../library/typing.rst:974
msgid "You cannot write ``Union[X][Y]``."
msgstr "``Union[X][Y]`` ã¨æ›¸ãã“ã¨ã¯å‡ºæ¥ã¾ã›ã‚“ã€‚"

#: ../../library/typing.rst:976
msgid "You can use ``Optional[X]`` as a shorthand for ``Union[X, None]``."
msgstr "``Optional[X]`` ã‚’ ``Union[X, None]`` ã®ç•¥è¨˜ã¨ã—ã¦åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚"

#: ../../library/typing.rst:978
msgid "Don't remove explicit subclasses from unions at runtime."
msgstr "æ˜ç¤ºçš„ã«æ›¸ã‹ã‚Œã¦ã„ã‚‹ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ã€å®Ÿè¡Œæ™‚ã«ç›´å’Œå‹ã‹ã‚‰å–ã‚Šé™¤ã‹ãªããªã‚Šã¾ã—ãŸã€‚"

#: ../../library/typing.rst:983
msgid "Optional type."
msgstr "ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«å‹ã€‚"

#: ../../library/typing.rst:985
msgid "``Optional[X]`` is equivalent to ``Union[X, None]``."
msgstr "``Optional[X]`` ã¯ ``Union[X, None]`` ã¨åŒå€¤ã§ã™ã€‚"

#: ../../library/typing.rst:987
msgid ""
"Note that this is not the same concept as an optional argument, which is one"
" that has a default.  An optional argument with a default does not require "
"the ``Optional`` qualifier on its type annotation just because it is "
"optional. For example::"
msgstr ""
"ã“ã‚ŒãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒã¤ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•°ã¨ã¯åŒã˜æ¦‚å¿µã§ã¯ãªã„ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚\n"
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒã¤ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•°ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•°ã§ã‚ã‚‹ãŸã‚ã«ã€å‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã« ``Optional`` ä¿®é£¾å­ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚\n"
"ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/typing.rst:995
msgid ""
"On the other hand, if an explicit value of ``None`` is allowed, the use of "
"``Optional`` is appropriate, whether the argument is optional or not. For "
"example::"
msgstr ""
"ãã‚Œã¨ã¯é€†ã«ã€ ``None`` ã¨ã„ã†å€¤ãŒè¨±ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒæ˜ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€å¼•æ•°ãŒã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã‚ã‚ã†ã¨ãªã‹ã‚ã†ã¨ã€ ``Optional`` ã‚’ä½¿ã†ã®ãŒå¥½ã¾ã—ã„ã§ã™ã€‚\n"
"ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/typing.rst:1004
msgid ""
"Tuple type; ``Tuple[X, Y]`` is the type of a tuple of two items with the "
"first item of type X and the second of type Y."
msgstr ""
"ã‚¿ãƒ—ãƒ«å‹; ``Tuple[X, Y]`` ã¯ã€æœ€åˆã®è¦ç´ ã®å‹ãŒ X ã§ã€2ã¤ç›®ã®è¦ç´ ã®å‹ãŒ Y ã§ã‚ã‚‹ã‚ˆã†ãªã€2ã¤ã®è¦ç´ ã‚’æŒã¤ã‚¿ãƒ—ãƒ«ã®å‹ã§ã™ã€‚"

#: ../../library/typing.rst:1007
msgid ""
"Example: ``Tuple[T1, T2]`` is a tuple of two elements corresponding to type "
"variables T1 and T2.  ``Tuple[int, float, str]`` is a tuple of an int, a "
"float and a string."
msgstr ""
"ä¾‹: ``Tuple[T1, T2]``  ã¯å‹å¤‰æ•° T1 ã¨ T2 ã«å¯¾å¿œã™ã‚‹2ã¤ã®è¦ç´ ã‚’æŒã¤ã‚¿ãƒ—ãƒ«ã§ã™ã€‚``Tuple[int, float, "
"str]`` ã¯ int ã¨ floatã€ string ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚"

#: ../../library/typing.rst:1011
msgid ""
"To specify a variable-length tuple of homogeneous type, use literal "
"ellipsis, e.g. ``Tuple[int, ...]``. A plain :data:`Tuple` is equivalent to "
"``Tuple[Any, ...]``, and in turn to :class:`tuple`."
msgstr ""
"åŒã˜å‹ã®ä»»æ„ã®é•·ã•ã®ã‚¿ãƒ—ãƒ«ã‚’æŒ‡å®šã™ã‚‹ã«ã¯ ellipsis ãƒªãƒ†ãƒ©ãƒ«ã‚’ç”¨ã„ã¾ã™ã€‚ä¾‹:  ``Tuple[int, ...]``ã€‚ãŸã ã® "
":data:`Tuple` ã¯ ``Tuple[Any, ...]`` ã¨ç­‰ä¾¡ã§ã€ã•ã‚‰ã« :class:`tuple` ã¨ç­‰ä¾¡ã§ã™ã€‚."

#: ../../library/typing.rst:1017
msgid "Callable type; ``Callable[[int], str]`` is a function of (int) -> str."
msgstr "å‘¼ã³å‡ºã—å¯èƒ½å‹; ``Callable[[int], str]`` ã¯ (int) -> str ã®é–¢æ•°ã§ã™ã€‚"

#: ../../library/typing.rst:1019
msgid ""
"The subscription syntax must always be used with exactly two values: the "
"argument list and the return type.  The argument list must be a list of "
"types or an ellipsis; the return type must be a single type."
msgstr ""
"æ·»å­—è¡¨è¨˜ã¯å¸¸ã«2ã¤ã®å€¤ã¨ã¨ã‚‚ã«ä½¿ã‚ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“: å®Ÿå¼•æ•°ã®ãƒªã‚¹ãƒˆã¨è¿”ã‚Šå€¤ã®å‹ã§ã™ã€‚\n"
"å®Ÿå¼•æ•°ã®ãƒªã‚¹ãƒˆã¯å‹ã®ãƒªã‚¹ãƒˆã‹ ellipsis ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“; è¿”ã‚Šå€¤ã®å‹ã¯å˜ä¸€ã®å‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/typing.rst:1024
msgid ""
"There is no syntax to indicate optional or keyword arguments; such function "
"types are rarely used as callback types. ``Callable[..., ReturnType]`` "
"(literal ellipsis) can be used to type hint a callable taking any number of "
"arguments and returning ``ReturnType``.  A plain :data:`Callable` is "
"equivalent to ``Callable[..., Any]``, and in turn to "
":class:`collections.abc.Callable`."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«å¼•æ•°ã‚„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’è¡¨ã™ãŸã‚ã®æ–‡æ³•ã¯ã‚ã‚Šã¾ã›ã‚“; ãã®ã‚ˆã†ãªé–¢æ•°å‹ã¯ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®å‹ã¨ã—ã¦æ»…å¤šã«ä½¿ã‚ã‚Œã¾ã›ã‚“ã€‚\n"
"``Callable[..., ReturnType]`` (ãƒªãƒ†ãƒ©ãƒ«ã® Ellipsis) ã¯ä»»æ„ã®å€‹æ•°ã®å¼•æ•°ã‚’ã¨ã‚Š ``ReturnType`` ã‚’è¿”ã™å‹ãƒ’ãƒ³ãƒˆã‚’ä¸ãˆã‚‹ãŸã‚ã«ä½¿ãˆã¾ã™ã€‚\n"
"æ™®é€šã® :data:`Callable` ã¯ ``Callable[..., Any]`` ã¨åŒç­‰ã§ã€ :class:`collections.abc.Callable` ã§ã‚‚åŒæ§˜ã§ã™ã€‚"

#: ../../library/typing.rst:1034
msgid "Special type construct to mark class variables."
msgstr "ã‚¯ãƒ©ã‚¹å¤‰æ•°ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ç‰¹åˆ¥ãªå‹æ§‹ç¯‰å­ã§ã™ã€‚"

#: ../../library/typing.rst:1036
msgid ""
"As introduced in :pep:`526`, a variable annotation wrapped in ClassVar "
"indicates that a given attribute is intended to be used as a class variable "
"and should not be set on instances of that class. Usage::"
msgstr ""
":pep:`526` ã§å°å…¥ã•ã‚ŒãŸé€šã‚Šã€ ClassVar "
"ã§ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸå¤‰æ•°ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚ˆã£ã¦ã€ã‚ã‚‹å±æ€§ã¯ã‚¯ãƒ©ã‚¹å¤‰æ•°ã¨ã—ã¦ä½¿ã†ã¤ã‚‚ã‚Šã§ã‚ã‚Šã€ãã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰è¨­å®šã™ã¹ãã§ã¯ãªã„ã¨ã„ã†ã“ã¨ã‚’ç¤ºã›ã¾ã™ã€‚ä½¿ã„æ–¹ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/typing.rst:1044
msgid ":data:`ClassVar` accepts only types and cannot be further subscribed."
msgstr ":data:`ClassVar` ã¯å‹ã®ã¿ã‚’å—ã‘å…¥ã‚Œã€ãã‚Œä»¥å¤–ã¯å—ã‘ä»˜ã‘ã‚‰ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/typing.rst:1046
msgid ""
":data:`ClassVar` is not a class itself, and should not be used with "
":func:`isinstance` or :func:`issubclass`. :data:`ClassVar` does not change "
"Python runtime behavior, but it can be used by third-party type checkers. "
"For example, a type checker might flag the following code as an error::"
msgstr ""
"ClassVar ã¯ã‚¯ãƒ©ã‚¹ãã®ã‚‚ã®ã§ã¯ãªãã€:func:`isinstance` ã‚„ :func:`issubclass` ã§ä½¿ã†ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚\n"
":data:`ClassVar` ã¯ Python ã®å®Ÿè¡Œæ™‚ã®æŒ™å‹•ã‚’å¤‰ãˆã¾ã›ã‚“ãŒã€ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã®å‹æ¤œæŸ»å™¨ã§ä½¿ãˆã¾ã™ã€‚\n"
"ä¾‹ãˆã°ã€å‹ãƒã‚§ãƒƒã‚«ãƒ¼ã¯æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã‚’ã‚¨ãƒ©ãƒ¼ã¨ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“::"

#: ../../library/typing.rst:1060
msgid ""
"``AnyStr`` is a type variable defined as ``AnyStr = TypeVar('AnyStr', str, "
"bytes)``."
msgstr ""
"``AnyStr`` ã¯ ``AnyStr = TypeVar('AnyStr', str, bytes)`` ã¨ã—ã¦å®šç¾©ã•ã‚Œã‚‹å‹å¤‰æ•°ã§ã™ã€‚"

#: ../../library/typing.rst:1063
msgid ""
"It is meant to be used for functions that may accept any kind of string "
"without allowing different kinds of strings to mix. For example::"
msgstr "ä»–ã®ç¨®é¡ã®æ–‡å­—åˆ—ã‚’æ··ãœã‚‹ã“ã¨ãªãã€ä»»æ„ã®ç¨®é¡ã®æ–‡å­—åˆ—ã‚’è¨±ã™é–¢æ•°ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã‚‹ã“ã¨ã‚’æ„å›³ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/typing.rst:1075
msgid ""
"A special constant that is assumed to be ``True`` by 3rd party static type "
"checkers. It is ``False`` at runtime. Usage::"
msgstr "ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¼ã®é™çš„å‹æ¤œæŸ»å™¨ãŒ ``True`` ã¨ä»®å®šã™ã‚‹ç‰¹åˆ¥ãªå®šæ•°ã§ã™ã€‚ å®Ÿè¡Œæ™‚ã«ã¯ ``False`` ã«ãªã‚Šã¾ã™ã€‚ä½¿ç”¨ä¾‹::"

#: ../../library/typing.rst:1084
msgid ""
"Note that the first type annotation must be enclosed in quotes, making it a "
"\"forward reference\", to hide the ``expensive_mod`` reference from the "
"interpreter runtime.  Type annotations for local variables are not "
"evaluated, so the second annotation does not need to be enclosed in quotes."
msgstr ""
"1ã¤ç›®ã®å‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯å¼•ç”¨ç¬¦ã§å›²ã£ã¦ \"å‰æ–¹å‚ç…§ (forward reference)\" ã«ã—ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‹ã‚‰ ``expensive_mod`` ã¸ã®å‚ç…§ã‚’éš ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã¸ã®å‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯è©•ä¾¡ã•ã‚Œãªã„ã®ã§ã€2ã¤ç›®ã®ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯å¼•ç”¨ç¬¦ã§å›²ã†å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"
