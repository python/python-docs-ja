# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-05 15:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-sync.rst:5
msgid "Synchronization primitives"
msgstr "åŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–"

#: ../../library/asyncio-sync.rst:7
msgid "**Source code:** :source:`Lib/asyncio/locks.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/asyncio/locks.py`"

#: ../../library/asyncio-sync.rst:9
msgid "Locks:"
msgstr "ãƒ­ãƒƒã‚¯:"

#: ../../library/asyncio-sync.rst:11
msgid ":class:`Lock`"
msgstr ":class:`Lock`"

#: ../../library/asyncio-sync.rst:12
msgid ":class:`Event`"
msgstr ":class:`Event`"

#: ../../library/asyncio-sync.rst:13
msgid ":class:`Condition`"
msgstr ":class:`Condition`"

#: ../../library/asyncio-sync.rst:15
msgid "Semaphores:"
msgstr "ã‚»ãƒãƒ•ã‚©:"

#: ../../library/asyncio-sync.rst:17
msgid ":class:`Semaphore`"
msgstr ":class:`Semaphore`"

#: ../../library/asyncio-sync.rst:18
msgid ":class:`BoundedSemaphore`"
msgstr ":class:`BoundedSemaphore`"

#: ../../library/asyncio-sync.rst:20
msgid ""
"asyncio lock API was designed to be close to classes of the :mod:`threading`"
" module (:class:`~threading.Lock`, :class:`~threading.Event`, "
":class:`~threading.Condition`, :class:`~threading.Semaphore`, "
":class:`~threading.BoundedSemaphore`), but it has no *timeout* parameter. "
"The :func:`asyncio.wait_for` function can be used to cancel a task after a "
"timeout."
msgstr ""
"asyncio lock API ã¯ :mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¯ãƒ©ã‚¹ (:class:`~threading.Lock`, :class:`~threading.Event`, :class:`~threading.Condition`, :class:`~threading.Semaphore`, :class:`~threading.BoundedSemaphore`) ã«è¿‘ããªã‚‹ã‚ˆã†è¨­è¨ˆã•ã‚Œã¾ã—ãŸãŒã€ *timeout* å¼•æ•°ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚\n"
":func:`asyncio.wait_for` é–¢æ•°ã‚’ç”¨ã„ã¦ã‚¿ã‚¤ãƒ ã‚¢ã‚ªã‚¦ãƒˆå¾Œã«ã‚¿ã‚¹ã‚¯ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:27
msgid "Locks"
msgstr "ãƒ­ãƒƒã‚¯"

#: ../../library/asyncio-sync.rst:30
msgid "Lock"
msgstr "Lock"

#: ../../library/asyncio-sync.rst:34
msgid "Primitive lock objects."
msgstr "ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãªãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/asyncio-sync.rst:36
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular coroutine when locked.  A primitive lock is in one of two states,"
" 'locked' or 'unlocked'."
msgstr ""
"ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒ­ãƒƒã‚¯ã¯ã€ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸã¨ãã«ç‰¹å®šã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ã«æ‰€æœ‰ã•ã‚Œãªã„åŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã§ã™ã€‚ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒ­ãƒƒã‚¯ã¯ 'ãƒ­ãƒƒã‚¯çŠ¶æ…‹' ã‹ 'ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹'"
" ã®ã©ã¡ã‚‰ã‹ã®çŠ¶æ…‹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:40
msgid ""
"It is created in the unlocked state.  It has two basic methods, "
":meth:`acquire` and :meth:`release`.  When the state is unlocked, acquire() "
"changes the state to locked and returns immediately.  When the state is "
"locked, acquire() blocks until a call to release() in another coroutine "
"changes it to unlocked, then the acquire() call resets it to locked and "
"returns.  The release() method should only be called in the locked state; it"
" changes the state to unlocked and returns immediately.  If an attempt is "
"made to release an unlocked lock, a :exc:`RuntimeError` will be raised."
msgstr ""
"ã“ã‚Œã¯ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã§ä½œæˆã•ã‚Œã¾ã™ã€‚åŸºæœ¬ãƒ¡ã‚½ãƒƒãƒ‰ :meth:`acquire` ã¨ :meth:`release` "
"ã‚’æŒã¡ã¾ã™ã€‚ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ã¨ãã€acquire() ã§ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«å¤‰æ›´ã—ç›´ã¡ã«è¿”ã—ã¾ã™ã€‚ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ã¨ãã€acquire() ã¯ã€ä»–ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒ "
"release() ã‚’å‘¼ã³å‡ºã—ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«å¤‰æ›´ã™ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ãã®å¾Œ acquire() "
"ã¯ãã‚Œã‚’ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ã—ã¦è¿”ã—ã¾ã™ã€‚release() ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ã¨ãä»¥å¤–ã«å‘¼ã³å‡ºã—ã¦ã¯ãªã‚Šã¾ã›ã‚“; "
"ã“ã‚Œã¯çŠ¶æ…‹ã‚’ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«å¤‰æ›´ã—ã¦ç›´ã¡ã«è¿”ã—ã¾ã™ã€‚ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã§ãƒ­ãƒƒã‚¯è§£é™¤ã‚’è¡ŒãŠã†ã¨ã™ã‚‹ã¨ :exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:49
msgid ""
"When more than one coroutine is blocked in acquire() waiting for the state "
"to turn to unlocked, only one coroutine proceeds when a release() call "
"resets the state to unlocked; first coroutine which is blocked in acquire() "
"is being processed."
msgstr ""
"1 å€‹ä»¥ä¸Šã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒ acquire() ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã€ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã¸ã®å¤‰æ›´ã‚’å¾…ã£ã¦ã„ã‚‹å ´åˆã€release() "
"ãŒå‘¼ã³å‡ºã•ã‚Œã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã•ã‚ŒãŸã¨ã 1 å€‹ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ã®ã¿ãŒé–‹å§‹ã•ã‚Œã¾ã™; æœ€åˆã« acquire() "
"ã§ãƒ—ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒé–‹å§‹ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:54
msgid ""
":meth:`acquire` is a coroutine and should be called with ``yield from``."
msgstr ":meth:`acquire` ã¯ã‚³ãƒ«ãƒ¼ãƒãƒ³ã§ã‚ã‚Šã€``yield from`` ã§å‘¼ã³å‡ºã™ã¹ãã§ã™ã€‚"

#: ../../library/asyncio-sync.rst:56
msgid ""
"Locks also support the context management protocol.  ``(yield from lock)`` "
"should be used as the context manager expression."
msgstr ""
"ãƒ­ãƒƒã‚¯ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼è¡¨ç¾ã§ã¯ã€``(yield from lock)`` "
"ã®ã‚ˆã†ã«ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:59 ../../library/asyncio-sync.rst:124
#: ../../library/asyncio-sync.rst:169 ../../library/asyncio-sync.rst:263
msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã¯ :ref:`ã‚¹ãƒ¬ãƒƒãƒ‰å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ <asyncio-multithreading>`ã€‚"

#: ../../library/asyncio-sync.rst:61
msgid "Usage::"
msgstr "ä½¿ã„æ–¹::"

#: ../../library/asyncio-sync.rst:71
msgid "Context manager usage::"
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã§ã®ä½¿ç”¨æ³•::"

#: ../../library/asyncio-sync.rst:78
msgid "Lock objects can be tested for locking state::"
msgstr "ãƒ­ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‹å¦ã‹ã‚’ç¢ºèªã§ãã¾ã™::"

#: ../../library/asyncio-sync.rst:88
msgid "Return ``True`` if the lock is acquired."
msgstr "ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ã¨ã ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:92
msgid "Acquire a lock."
msgstr "ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:94 ../../library/asyncio-sync.rst:175
msgid ""
"This method blocks until the lock is unlocked, then sets it to locked and "
"returns ``True``."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ­ãƒƒã‚¯ãŒè§£é™¤ã•ã‚Œã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã€ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«å¤‰æ›´ã—ã¦ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:97 ../../library/asyncio-sync.rst:150
#: ../../library/asyncio-sync.rst:178 ../../library/asyncio-sync.rst:230
#: ../../library/asyncio-sync.rst:239 ../../library/asyncio-sync.rst:274
msgid "This method is a :ref:`coroutine <coroutine>`."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ <coroutine>` ã§ã™ã€‚"

#: ../../library/asyncio-sync.rst:101
msgid "Release a lock."
msgstr "ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:103
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"coroutines are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed."
msgstr ""
"ãƒ­ãƒƒã‚¯ãŒãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ã¨ãã€ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã—ã¦è¿”ã—ã¾ã™ã€‚ä»–ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒãƒ—ãƒ­ãƒƒã‚¯ã•ã‚Œãƒ­ãƒƒã‚¯è§£é™¤ã‚’å¾…ã£ã¦ã„ã‚‹å ´åˆã€ãã®ã†ã¡ã®ã²ã¨ã¤ã ã‘é–‹å§‹ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:107 ../../library/asyncio-sync.rst:214
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr "ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ãƒ­ãƒƒã‚¯ã«å¯¾ã—ã¦å‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆã€:exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:109 ../../library/asyncio-sync.rst:216
msgid "There is no return value."
msgstr "æˆ»ã‚Šå€¤ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-sync.rst:113
msgid "Event"
msgstr "Event"

#: ../../library/asyncio-sync.rst:117
msgid ""
"An Event implementation, asynchronous equivalent to "
":class:`threading.Event`."
msgstr ":class:`threading.Event` ã¨ç­‰ä¾¡ã§éåŒæœŸãª Event å®Ÿè£…ã§ã™ã€‚"

#: ../../library/asyncio-sync.rst:119
msgid ""
"Class implementing event objects. An event manages a flag that can be set to"
" true with the :meth:`set` method and reset to false with the :meth:`clear` "
"method.  The :meth:`wait` method blocks until the flag is true. The flag is "
"initially false."
msgstr ""
"ã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ã‚¤ãƒ™ãƒ³ãƒˆã¯ :meth:`set` ãƒ¡ã‚½ãƒƒãƒ‰ã§çœŸã«è¨­å®šã•ã‚Œã€:meth:`clear` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã§å½ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹ãƒ•ãƒ©ã‚°ã‚’ç®¡ç†ã—ã¾ã™ã€‚:meth:`wait` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ•ãƒ©ã‚°ãŒçœŸã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ãƒ•ãƒ©ã‚°ã®æœ€åˆã®å€¤ã¯å½ã§ã™ã€‚"

#: ../../library/asyncio-sync.rst:128
msgid ""
"Reset the internal flag to false. Subsequently, coroutines calling "
":meth:`wait` will block until :meth:`set` is called to set the internal flag"
" to true again."
msgstr ""
"å†…éƒ¨ãƒ•ãƒ©ã‚°ã‚’å½ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚ãã®å¾Œ :meth:`wait` ã‚’å‘¼ã‚“ã§ã„ã‚‹ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯ :meth:`set` "
"ãŒå‘¼ã³å‡ºã•ã‚Œã¦å†…éƒ¨ãƒ•ãƒ©ã‚°ãŒçœŸã«è¨­å®šã•ã‚Œã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:134
msgid "Return ``True`` if and only if the internal flag is true."
msgstr "å†…éƒ¨ãƒ•ãƒ©ã‚°ãŒçœŸã®ã¨ã ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:138
msgid ""
"Set the internal flag to true. All coroutines waiting for it to become true "
"are awakened. Coroutine that call :meth:`wait` once the flag is true will "
"not block at all."
msgstr ""
"å†…éƒ¨ãƒ•ãƒ©ã‚°ã‚’çœŸã«è¨­å®šã—ã¾ã™ã€‚ãã‚Œã‚’å¾…ã£ã¦ã„ãŸã™ã¹ã¦ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒå†é–‹ã—ã¾ã™ã€‚:meth:`wait` "
"ã‚’å‘¼ã³å‡ºã—ã¦ã„ãŸã‚³ãƒ«ãƒ¼ãƒãƒ³ã¸ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒè§£é™¤ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:144
msgid "Block until the internal flag is true."
msgstr "å†…éƒ¨ãƒ•ãƒ©ã‚°ãŒçœŸã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:146
msgid ""
"If the internal flag is true on entry, return ``True`` immediately. "
"Otherwise, block until another coroutine calls :meth:`set` to set the flag "
"to true, then return ``True``."
msgstr ""
"å…¥åŠ›æ™‚ã«å†…éƒ¨ãƒ•ãƒ©ã‚°ãŒçœŸã®ã¨ãç›´ã¡ã« ``True`` ã‚’è¿”ã—ã¾ã™ã€‚å½ã®ã¨ãã¯ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒ :meth:`set` "
"ã‚’å‘¼ã³å‡ºã—ã¦ãƒ•ãƒ©ã‚°ãŒçœŸã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã€çœŸã«ãªã£ãŸæ™‚ç‚¹ã§ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:154
msgid "Condition"
msgstr "Condition"

#: ../../library/asyncio-sync.rst:158
msgid ""
"A Condition implementation, asynchronous equivalent to "
":class:`threading.Condition`."
msgstr ":class:`threading.Condition` ã¨ç­‰ä¾¡ã§éåŒæœŸãª Condition å®Ÿè£…ã§ã™ã€‚"

#: ../../library/asyncio-sync.rst:161
msgid ""
"This class implements condition variable objects. A condition variable "
"allows one or more coroutines to wait until they are notified by another "
"coroutine."
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹ã¯æ¡ä»¶å¤‰æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚æ¡ä»¶å¤‰æ•°ã¯ 1 å€‹ä»¥ä¸Šã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒä»–ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‹ã‚‰é€šçŸ¥ã‚’å—ã‘ã‚‹ã¾ã§å¾…æ©Ÿã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:165
msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock`"
" object, and it is used as the underlying lock.  Otherwise, a new "
":class:`Lock` object is created and used as the underlying lock."
msgstr ""
"å¼•æ•° *lock* ã«é ``None`` ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ãã‚Œã¯ :class:`Lock` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ä¸‹å±¤ã®ãƒ­ãƒƒã‚¯ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ä¸ãˆã‚‰ã‚Œãªã„å ´åˆã€æ–°ã—ã :class:`Lock` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:173
msgid "Acquire the underlying lock."
msgstr "ä¸‹å±¤ã§ã®ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:182
msgid ""
"By default, wake up one coroutine waiting on this condition, if any. If the "
"calling coroutine has not acquired the lock when this method is called, a "
":exc:`RuntimeError` is raised."
msgstr ""
"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã“ã®æ¡ä»¶ã‚’å¾…æ©Ÿã—ã¦ã„ã‚‹ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒã‚ã‚Œã°ãã‚ŒãŒå†é–‹ã•ã‚Œã¾ã™ã€‚å‘¼ã³å‡ºã—ãŸã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒã“ã®ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¦ã„ãªã„çŠ¶æ…‹ã§ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¨"
" :exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:186
msgid ""
"This method wakes up at most *n* of the coroutines waiting for the condition"
" variable; it is a no-op if no coroutines are waiting."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ã“ã®æ¡ä»¶å¤‰æ•°ã‚’å¾…æ©Ÿã—ã¦ã„ã‚‹ã†ã¡æœ€å¤§ã§ *n* å€‹ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒå†é–‹ã•ã‚Œã¾ã™; å¾…æ©Ÿã—ã¦ã„ã‚‹ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒãªã‘ã‚Œã°ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-sync.rst:191
msgid ""
"An awakened coroutine does not actually return from its :meth:`wait` call "
"until it can reacquire the lock. Since :meth:`notify` does not release the "
"lock, its caller should."
msgstr ""
"ãã®ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã§ãã‚‹ã¾ã§ã€å†é–‹ã•ã‚ŒãŸã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯å®Ÿéš›ã«ã¯è‡ªèº«ã® :meth:`wait` å‘¼ã³å‡ºã—ã‹ã‚‰å¾©å¸°ã—ã¾ã›ã‚“ã€‚:meth:`notify` "
"ã¯ãƒ­ãƒƒã‚¯ã®è§£é™¤ã‚’è¡Œã‚ãªã„ãŸã‚ã€å‘¼ã³å‡ºã—å…ƒãŒãã‚Œã‚’è¡Œã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-sync.rst:197
msgid "Return ``True`` if the underlying lock is acquired."
msgstr "ä¸‹å±¤ã®ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¦ã„ã‚Œã° ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:201
msgid ""
"Wake up all coroutines waiting on this condition. This method acts like "
":meth:`notify`, but wakes up all waiting coroutines instead of one. If the "
"calling coroutine has not acquired the lock when this method is called, a "
":exc:`RuntimeError` is raised."
msgstr ""
"ã“ã®æ¡ä»¶ã‚’å¾…æ©Ÿã—ã¦ã„ã‚‹ã™ã¹ã¦ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚’å†é–‹ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :meth:`notify` ã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã„ã¾ã™ãŒã€1 "
"å€‹ã§ã¯ãªãã™ã¹ã¦ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒå†é–‹ã•ã‚Œã¾ã™ã€‚å‘¼ã³å‡ºã—ãŸã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¦ã„ãªã„çŠ¶æ…‹ã§ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ "
":exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:208
msgid "Release the underlying lock."
msgstr "ä¸‹å±¤ã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:210
msgid ""
"When the lock is locked, reset it to unlocked, and return. If any other "
"coroutines are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed."
msgstr ""
"ãƒ­ãƒƒã‚¯ãŒãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ã¨ãã€ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚ä»–ã«ã“ã®ãƒ­ãƒƒã‚¯ã®è§£é™¤ã‚’å¾…æ©Ÿã—ã¦ã„ãŸã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒå­˜åœ¨ã—ã¦ã„ãŸå ´åˆã€ãã®ã†ã¡ã®ä¸€ã¤ãŒå†é–‹ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:220
msgid "Wait until notified."
msgstr "é€šçŸ¥ã‚’å—ã‘ã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:222
msgid ""
"If the calling coroutine has not acquired the lock when this method is "
"called, a :exc:`RuntimeError` is raised."
msgstr "å‘¼ã³å‡ºã—ãŸã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¦ã„ãªã„çŠ¶æ…‹ã§ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ã€:exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:225
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another coroutine.  Once awakened, it re-acquires the "
"lock and returns ``True``."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä¸‹å±¤ã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã€ãã®å¾Œãã‚ŒãŒä»–ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ã§åŒã˜æ¡ä»¶å¤‰æ•°ã® :meth:`notify` ã‹ :meth:`notify_all` "
"ã«ã‚ˆã£ã¦å†é–‹ã•ã‚Œã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚å†é–‹ã•ã‚Œã‚‹ã¨ã€å†ã³ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¦ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:234
msgid "Wait until a predicate becomes true."
msgstr "*predicate* ãŒçœŸã«ãªã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:236
msgid ""
"The predicate should be a callable which result will be interpreted as a "
"boolean value. The final predicate value is the return value."
msgstr ""
"*predicate* ã¯å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€çµæœãŒãƒ–ãƒ¼ãƒ«å€¤ã§è§£æã§ããªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æœ€çµ‚çš„ãª *predicate* "
"ã®çµæœãŒæˆ»ã‚Šå€¤ã¨ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:243
msgid "Semaphores"
msgstr "ã‚»ãƒãƒ•ã‚©"

#: ../../library/asyncio-sync.rst:246
msgid "Semaphore"
msgstr "Semaphore"

#: ../../library/asyncio-sync.rst:250
msgid "A Semaphore implementation."
msgstr "Semaphore å®Ÿè£…ã§ã™ã€‚"

#: ../../library/asyncio-sync.rst:252
msgid ""
"A semaphore manages an internal counter which is decremented by each "
":meth:`acquire` call and incremented by each :meth:`release` call. The "
"counter can never go below zero; when :meth:`acquire` finds that it is zero,"
" it blocks, waiting until some other coroutine calls :meth:`release`."
msgstr ""
"ã‚»ãƒãƒ•ã‚©ã¯ :meth:`acquire` ã®å‘¼ã³å‡ºã—ã§æ¸›ç®—ã—ã€:meth:`release` "
"ã§åŠ ç®—ã™ã‚‹å†…éƒ¨ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ç®¡ç†ã—ã¾ã™ã€‚ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã¯è² æ•°ã«ãªã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“;  :meth:`acquire` "
"ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã«ã‚»ãƒãƒ•ã‚©ãŒã‚¼ãƒ­ã§ã‚ã‚Œã°ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã€ä»–ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒ :meth:`release` ã‚’å‘¼ã³å‡ºã™ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:257
msgid "Semaphores also support the context management protocol."
msgstr "ã‚»ãƒãƒ•ã‚©ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:259
msgid ""
"The optional argument gives the initial value for the internal counter; it "
"defaults to ``1``. If the value given is less than ``0``, :exc:`ValueError` "
"is raised."
msgstr ""
"ä»»æ„ã®å¼•æ•° *value* ã§å†…éƒ¨ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã®åˆæœŸå€¤ã‚’æŒ‡å®šã§ãã¾ã™; ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``1`` ã§ã™ã€‚value ã« ``0`` "
"æœªæº€ã®å€¤ãŒæŒ‡å®šã•ã‚Œã‚‹ã¨ã€:exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:267
msgid "Acquire a semaphore."
msgstr "ã‚»ãƒãƒ•ã‚©ã‚’ç²å¾—ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:269
msgid ""
"If the internal counter is larger than zero on entry, decrement it by one "
"and return ``True`` immediately.  If it is zero on entry, block, waiting "
"until some other coroutine has called :meth:`release` to make it larger than"
" ``0``, and then return ``True``."
msgstr ""
"å…¥åŠ›æ™‚å†…éƒ¨ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãŒã‚¼ãƒ­ã‚ˆã‚Šå¤§ãã‹ã£ãŸå ´åˆã€1 æ¸›ç®—ã•ã‚Œã€ç›´ã¡ã« ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ã‚¼ãƒ­ã ã£ãŸå ´åˆã€ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã€ä»–ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒ "
":meth:`release` ã‚’å‘¼ã³å‡ºã—ã¦ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å€¤ãŒ ``0`` ã‚ˆã‚Šå¤§ãããªã‚‹ã¾ã§å¾…æ©Ÿã—ã€ç²å¾—ã§ãã‚‹ã¨ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:278
msgid "Returns ``True`` if semaphore can not be acquired immediately."
msgstr "ã‚»ãƒãƒ•ã‚©ã‚’ç›´ã¡ã«ç²å¾—ã§ããªã„å ´åˆ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:282
msgid ""
"Release a semaphore, incrementing the internal counter by one. When it was "
"zero on entry and another coroutine is waiting for it to become larger than "
"zero again, wake up that coroutine."
msgstr ""
"ã‚»ãƒãƒ•ã‚©ã‚’è§£æ”¾ã—ã€å†…éƒ¨ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ 1 åŠ ç®—ã—ã¾ã™ã€‚ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å€¤ãŒã‚¼ãƒ­ã§ä»–ã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒå¾…æ©ŸçŠ¶æ…‹ã«ã‚ã£ãŸå ´åˆã€åŠ ç®—å¾Œãã®ã‚³ãƒ«ãƒ¼ãƒãƒ³ãŒå†é–‹ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-sync.rst:288
msgid "BoundedSemaphore"
msgstr "BoundedSemaphore"

#: ../../library/asyncio-sync.rst:292
msgid "A bounded semaphore implementation. Inherit from :class:`Semaphore`."
msgstr ":class:`Semaphore` ã‚’ç¶™æ‰¿ã—ãŸæœ‰é™ã‚»ãƒãƒ•ã‚©ã®å®Ÿè£…ã§ã™ã€‚"

#: ../../library/asyncio-sync.rst:294
msgid ""
"This raises :exc:`ValueError` in :meth:`~Semaphore.release` if it would "
"increase the value above the initial value."
msgstr ""
":meth:`~Semaphore.release` å†…ã§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å€¤ãŒåŠ ç®—ã•ã‚Œã¦å¼•æ•° *value* ã‚’è¶…ãˆã‚‹ã¨ :exc:`ValueError` "
"ã‚’é€å‡ºã—ã¾ã™ã€‚"
