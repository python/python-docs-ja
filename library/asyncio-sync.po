# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-30 14:59+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-sync.rst:7
msgid "Synchronization Primitives"
msgstr "同期プリミティブ"

#: ../../library/asyncio-sync.rst:9
msgid "**Source code:** :source:`Lib/asyncio/locks.py`"
msgstr "**ソースコード:** :source:`Lib/asyncio/locks.py`"

#: ../../library/asyncio-sync.rst:13
msgid ""
"asyncio synchronization primitives are designed to be similar to those of "
"the :mod:`threading` module with two important caveats:"
msgstr ""
"asyncio の同期プリミティブは :mod:`threading` モジュールのそれと類似するよう"
"にデザインされていますが、2つの重要な注意事項があります:"

#: ../../library/asyncio-sync.rst:16
msgid ""
"asyncio primitives are not thread-safe, therefore they should not be used "
"for OS thread synchronization (use :mod:`threading` for that);"
msgstr ""
"asyncio の同期プリミティブはスレッドセーフではありません。従って OS スレッド"
"の同期に使うべきではありません (代わりに :mod:`threading` を使ってください);"

#: ../../library/asyncio-sync.rst:20
msgid ""
"methods of these synchronization primitives do not accept the *timeout* "
"argument; use the :func:`asyncio.wait_for` function to perform operations "
"with timeouts."
msgstr ""
"同期プリミティブのメソッドは *timeout* 引数を受け付けません; タイムアウトを伴"
"う操作を実行するには :func:`asyncio.wait_for` 関数を使ってください。"

#: ../../library/asyncio-sync.rst:24
msgid "asyncio has the following basic synchronization primitives:"
msgstr "asyncio モジュールは以下の基本的な同期プリミティブを持っています:"

#: ../../library/asyncio-sync.rst:26
msgid ":class:`Lock`"
msgstr ":class:`Lock`"

#: ../../library/asyncio-sync.rst:27
msgid ":class:`Event`"
msgstr ":class:`Event`"

#: ../../library/asyncio-sync.rst:28
msgid ":class:`Condition`"
msgstr ":class:`Condition`"

#: ../../library/asyncio-sync.rst:29
msgid ":class:`Semaphore`"
msgstr ":class:`Semaphore`"

#: ../../library/asyncio-sync.rst:30
msgid ":class:`BoundedSemaphore`"
msgstr ":class:`BoundedSemaphore`"

#: ../../library/asyncio-sync.rst:37
msgid "Lock"
msgstr "Lock"

#: ../../library/asyncio-sync.rst:41
msgid "Implements a mutex lock for asyncio tasks.  Not thread-safe."
msgstr ""
"asyncio タスクのためのミューテックスロックを実装しています。スレッドセーフで"
"はありません。"

#: ../../library/asyncio-sync.rst:43
msgid ""
"An asyncio lock can be used to guarantee exclusive access to a shared "
"resource."
msgstr ""
"asyncio ロックは、共有リソースに対する排他的なアクセスを保証するために使うこ"
"とができます。"

#: ../../library/asyncio-sync.rst:46
msgid "The preferred way to use a Lock is an :keyword:`async with` statement::"
msgstr ""
"Lock の望ましい使用方法は、 :keyword:`async with` 文と組み合わせて使うことで"
"す::"

#: ../../library/asyncio-sync.rst:55 ../../library/asyncio-sync.rst:198
#: ../../library/asyncio-sync.rst:297
msgid "which is equivalent to::"
msgstr "これは以下のコードと等価です::"

#: ../../library/asyncio-sync.rst:66 ../../library/asyncio-sync.rst:111
#: ../../library/asyncio-sync.rst:186 ../../library/asyncio-sync.rst:285
#: ../../library/asyncio-sync.rst:340
msgid "Removed the *loop* parameter."
msgstr ""

#: ../../library/asyncio-sync.rst:71
msgid "Acquire the lock."
msgstr "ロックを獲得します。"

#: ../../library/asyncio-sync.rst:73
msgid ""
"This method waits until the lock is *unlocked*, sets it to *locked* and "
"returns ``True``."
msgstr ""
"このメソッドはロックが *解除される* まで待機し、ロックを *ロック状態* に変更"
"して ``True`` を返します。"

#: ../../library/asyncio-sync.rst:76
msgid ""
"When more than one coroutine is blocked in :meth:`acquire` waiting for the "
"lock to be unlocked, only one coroutine eventually proceeds."
msgstr ""
"複数のコルーチンが :meth:`acquire` メソッドによりロックの解除を待ち受けている"
"場合、最終的にただひとつのコルーチンが実行されます。"

#: ../../library/asyncio-sync.rst:80
msgid ""
"Acquiring a lock is *fair*: the coroutine that proceeds will be the first "
"coroutine that started waiting on the lock."
msgstr ""
"ロックの獲得は *公平* です: すなわちロックを獲得して実行されるコルーチンは、"
"最初にロックの待ち受けを開始したコルーチンです。"

#: ../../library/asyncio-sync.rst:85
msgid "Release the lock."
msgstr "ロックを解放します。"

#: ../../library/asyncio-sync.rst:87
msgid "When the lock is *locked*, reset it to *unlocked* and return."
msgstr ""
"ロックが *ロック状態* の場合、 ロックを *解除状態* にしてリターンします。"

#: ../../library/asyncio-sync.rst:89
msgid "If the lock is *unlocked*, a :exc:`RuntimeError` is raised."
msgstr "ロックが *解除状態* の場合、 :exc:`RuntimeError` 例外が送出されます。"

#: ../../library/asyncio-sync.rst:93
msgid "Return ``True`` if the lock is *locked*."
msgstr "*ロック状態* の場合に ``True`` を返します。"

#: ../../library/asyncio-sync.rst:97
msgid "Event"
msgstr "Event"

#: ../../library/asyncio-sync.rst:101
msgid "An event object.  Not thread-safe."
msgstr "イベントオブジェクトです。スレッドセーフではありません。"

#: ../../library/asyncio-sync.rst:103
msgid ""
"An asyncio event can be used to notify multiple asyncio tasks that some "
"event has happened."
msgstr ""
"asyncio イベントは、複数の asyncio タスクに対して何らかのイベントが発生したこ"
"とを通知するために使うことができます。"

#: ../../library/asyncio-sync.rst:106
msgid ""
"An Event object manages an internal flag that can be set to *true* with the :"
"meth:`~Event.set` method and reset to *false* with the :meth:`clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is set to "
"*true*.  The flag is set to *false* initially."
msgstr ""
"Event オブジェクトは内部フラグを管理します。フラグの値は :meth:`~Event.set` "
"メソッドにより *true* に、また :meth:`clear` メソッドにより *false* に設定す"
"ることができます。 :meth:`~Event.wait` メソッドはフラグが *true* になるまで処"
"理をブロックします。フラグの初期値は *false* です。"

#: ../../library/asyncio-sync.rst:116
msgid "Example::"
msgstr "以下はプログラム例です::"

#: ../../library/asyncio-sync.rst:141
msgid "Wait until the event is set."
msgstr "イベントがセットされるまで待機します。"

#: ../../library/asyncio-sync.rst:143
msgid ""
"If the event is set, return ``True`` immediately. Otherwise block until "
"another task calls :meth:`~Event.set`."
msgstr ""
"イベントがセットされると、即座に ``True`` を返します。 そうでなければ、他のタ"
"スクが :meth:`~Event.set` メソッドを呼び出すまで処理をブロックします。"

#: ../../library/asyncio-sync.rst:148
msgid "Set the event."
msgstr "イベントをセットします。"

#: ../../library/asyncio-sync.rst:150
msgid "All tasks waiting for event to be set will be immediately awakened."
msgstr ""
"イベントがセットされるまで待機している全てのタスクは、即座に通知を受けて実行"
"を再開します。"

#: ../../library/asyncio-sync.rst:155
msgid "Clear (unset) the event."
msgstr "イベントをクリア (アンセット) します"

#: ../../library/asyncio-sync.rst:157
msgid ""
"Tasks awaiting on :meth:`~Event.wait` will now block until the :meth:`~Event."
"set` method is called again."
msgstr ""
":meth:`~Event.wait` メソッドで待ち受けを行うタスクは :meth:`~Event.set` メ"
"ソッドが再度呼び出されるまで処理をブロックします。"

#: ../../library/asyncio-sync.rst:162
msgid "Return ``True`` if the event is set."
msgstr "イベントがセットされている場合 ``True`` を返します。"

#: ../../library/asyncio-sync.rst:166
msgid "Condition"
msgstr "Condition"

#: ../../library/asyncio-sync.rst:170
msgid "A Condition object.  Not thread-safe."
msgstr "条件変数オブジェクトです。スレッドセーフではありません。"

#: ../../library/asyncio-sync.rst:172
msgid ""
"An asyncio condition primitive can be used by a task to wait for some event "
"to happen and then get exclusive access to a shared resource."
msgstr ""
"asyncio 条件プリミティブは何らかのイベントが発生するのを待ち受け、そのイベン"
"トを契機として共有リソースへの排他的なアクセスを得るために利用することができ"
"ます。"

#: ../../library/asyncio-sync.rst:176
msgid ""
"In essence, a Condition object combines the functionality of an :class:"
"`Event` and a :class:`Lock`.  It is possible to have multiple Condition "
"objects share one Lock, which allows coordinating exclusive access to a "
"shared resource between different tasks interested in particular states of "
"that shared resource."
msgstr ""
"本質的に、 Condition オブジェクトは :class:`Event` と a :class:`Lock` の2つの"
"クラスの機能を組み合わせたものです。複数の Condition オブジェクトが単一の "
"Lock を共有することでができます。これにより、共有リソースのそれぞれの状態に関"
"連する異なるタスクの間で、そのリソースへの排他的アクセスを調整することが可能"
"になります。"

#: ../../library/asyncio-sync.rst:182
msgid ""
"The optional *lock* argument must be a :class:`Lock` object or ``None``.  In "
"the latter case a new Lock object is created automatically."
msgstr ""
"オプション引数 *lock* は :class:`Lock` または ``None`` でなければなりません。"
"後者の場合自動的に新しい Lock オブジェクトが生成されます。"

#: ../../library/asyncio-sync.rst:189
msgid ""
"The preferred way to use a Condition is an :keyword:`async with` statement::"
msgstr ""
"Condition の望ましい使用方法は :keyword:`async with` 文と組み合わせて使うこと"
"です::"

#: ../../library/asyncio-sync.rst:211
msgid "Acquire the underlying lock."
msgstr "下層でのロックを獲得します。"

#: ../../library/asyncio-sync.rst:213
msgid ""
"This method waits until the underlying lock is *unlocked*, sets it to "
"*locked* and returns ``True``."
msgstr ""
"このメソッドは下層のロックが  *解除される* まで待機し、ロックを *ロック状態* "
"に変更して ``True`` を返します。"

#: ../../library/asyncio-sync.rst:218
msgid ""
"Wake up at most *n* tasks (1 by default) waiting on this condition.  The "
"method is no-op if no tasks are waiting."
msgstr ""
"この条件を待ち受けている最大で *n* 個のタスク (*n* のデフォルト値は 1) を起動"
"します。待ち受けているタスクがいない場合、このメソッドは何もしません。"

#: ../../library/asyncio-sync.rst:221 ../../library/asyncio-sync.rst:236
msgid ""
"The lock must be acquired before this method is called and released shortly "
"after.  If called with an *unlocked* lock a :exc:`RuntimeError` error is "
"raised."
msgstr ""
"このメソッドが呼び出される前にロックを獲得しておかなければなりません。また、"
"メソッド呼び出し後速やかにロックを解除しなければなりません。 *解除された* "
"ロックとと共に呼び出された場合、 :exc:`RuntimeError` 例外が送出されます。"

#: ../../library/asyncio-sync.rst:227
msgid "Return ``True`` if the underlying lock is acquired."
msgstr "下層のロックを獲得していれば ``True`` を返します。"

#: ../../library/asyncio-sync.rst:231
msgid "Wake up all tasks waiting on this condition."
msgstr "この条件を待ち受けている全てのタスクを起動します。"

#: ../../library/asyncio-sync.rst:233
msgid "This method acts like :meth:`notify`, but wakes up all waiting tasks."
msgstr ""
"このメソッドは :meth:`notify` と同じように振る舞いますが、待ち受けている全て"
"のタスクを起動します。"

#: ../../library/asyncio-sync.rst:242
msgid "Release the underlying lock."
msgstr "下層のロックを解除します。"

#: ../../library/asyncio-sync.rst:244
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr ""
"アンロック状態のロックに対して呼び出された場合、:exc:`RuntimeError` が送出さ"
"れます。"

#: ../../library/asyncio-sync.rst:249
msgid "Wait until notified."
msgstr "通知を受けるまで待機します。"

#: ../../library/asyncio-sync.rst:251
msgid ""
"If the calling task has not acquired the lock when this method is called, a :"
"exc:`RuntimeError` is raised."
msgstr ""
"このメソッドが呼び出された時点で呼び出し元のタスクがロックを獲得していない場"
"合、 :exc:`RuntimeError` 例外が送出されます。"

#: ../../library/asyncio-sync.rst:254
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call. Once awakened, the "
"Condition re-acquires its lock and this method returns ``True``."
msgstr ""
"このメソッドは下層のロックを解除し、その後 :meth:`notify` または :meth:"
"`notify_all` の呼び出しによって起動されるまで処理をブロックします。いったん起"
"動されると、  Condition は再びロックを獲得し、メソッドは ``True`` を返しま"
"す。"

#: ../../library/asyncio-sync.rst:261
msgid "Wait until a predicate becomes *true*."
msgstr "引数 predicate の条件が *真* になるまで待機します。"

#: ../../library/asyncio-sync.rst:263
msgid ""
"The predicate must be a callable which result will be interpreted as a "
"boolean value.  The final value is the return value."
msgstr ""
"引数 predicate は戻り値が真偽地として解釈可能な呼び出し可能オブジェクトでなけ"
"ればなりません。 predicate の最終的な値が戻り値になります。"

#: ../../library/asyncio-sync.rst:269
msgid "Semaphore"
msgstr "Semaphore"

#: ../../library/asyncio-sync.rst:273
msgid "A Semaphore object.  Not thread-safe."
msgstr "セマフォオブジェクトです。スレッドセーフではありません。"

#: ../../library/asyncio-sync.rst:275
msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`acquire` call and incremented by each :meth:`release` call. The counter can "
"never go below zero; when :meth:`acquire` finds that it is zero, it blocks, "
"waiting until some task calls :meth:`release`."
msgstr ""
"セマフォは内部のカウンターを管理しています。カウンターは :meth:`acquire` メ"
"ソッドの呼び出しによって減算され、 :meth:`release` メソッドの呼び出しによって"
"加算されます。カウンターがゼロを下回ることはありません。 :meth:`acquire` メ"
"ソッドが呼び出された時にカウンターがゼロになっていると、セマフォは処理をブ"
"ロックし、他のタスクが :meth:`release` メソッドを呼び出すまで待機します。"

#: ../../library/asyncio-sync.rst:281
msgid ""
"The optional *value* argument gives the initial value for the internal "
"counter (``1`` by default). If the given value is less than ``0`` a :exc:"
"`ValueError` is raised."
msgstr ""
"オプション引数 *value* は内部カウンターの初期値を与えます (デフォルトは "
"``1`` です)。 指定された値が ``0`` より小さい場合、 :exc:`ValueError` 例外が"
"送出されます。"

#: ../../library/asyncio-sync.rst:288
msgid ""
"The preferred way to use a Semaphore is an :keyword:`async with` statement::"
msgstr ""
"Semaphore 望ましい使用方法は、 :keyword:`async with` 文と組み合わせて使うこと"
"です::"

#: ../../library/asyncio-sync.rst:310
msgid "Acquire a semaphore."
msgstr "セマフォを獲得します。"

#: ../../library/asyncio-sync.rst:312
msgid ""
"If the internal counter is greater than zero, decrement it by one and return "
"``True`` immediately.  If it is zero, wait until a :meth:`release` is called "
"and return ``True``."
msgstr ""
"内部カウンターがゼロより大きい場合、カウンターを1つ減算して即座に ``True`` を"
"返します。内部カウンターがゼロの場合、 :meth:`release` が呼び出されるまで待機"
"してから ``True`` を返します。"

#: ../../library/asyncio-sync.rst:318
msgid "Returns ``True`` if semaphore can not be acquired immediately."
msgstr "セマフォを直ちに獲得できない場合 ``True`` を返します。"

#: ../../library/asyncio-sync.rst:322
msgid ""
"Release a semaphore, incrementing the internal counter by one. Can wake up a "
"task waiting to acquire the semaphore."
msgstr ""
"セマフォを解放し、内部カウンターを1つ加算します。セマフォ待ちをしているタスク"
"を起動する可能性があります。"

#: ../../library/asyncio-sync.rst:325
msgid ""
"Unlike :class:`BoundedSemaphore`, :class:`Semaphore` allows making more "
"``release()`` calls than ``acquire()`` calls."
msgstr ""
":class:`BoundedSemaphore` と異なり、 :class:`Semaphore` は ``release()`` を "
"``acquire()`` よりも多く呼び出すことを許容します。"

#: ../../library/asyncio-sync.rst:330
msgid "BoundedSemaphore"
msgstr "BoundedSemaphore"

#: ../../library/asyncio-sync.rst:334
msgid "A bounded semaphore object.  Not thread-safe."
msgstr "有限セマフォオブジェクトです。スレッドセーフではありません。"

#: ../../library/asyncio-sync.rst:336
msgid ""
"Bounded Semaphore is a version of :class:`Semaphore` that raises a :exc:"
"`ValueError` in :meth:`~Semaphore.release` if it increases the internal "
"counter above the initial *value*."
msgstr ""
"有限セマフォは :class:`Semaphore` の一種で、 :meth:`~Semaphore.release` メ"
"ソッドの呼び出しにより内部カウンターが *初期値* よりも増加してしまう場合は :"
"exc:`ValueError` 例外を送出します。"

#: ../../library/asyncio-sync.rst:348
msgid ""
"Acquiring a lock using ``await lock`` or ``yield from lock`` and/or :keyword:"
"`with` statement (``with await lock``, ``with (yield from lock)``) was "
"removed.  Use ``async with lock`` instead."
msgstr ""
"``await lock`` や ``yield from lock`` およびそれらと :keyword:`with` 文との組"
"み合わせ (すなわち ``with await lock`` や ``with (yield from lock)``) による"
"ロックの獲得は削除されました。代わりに ``async with lock`` を使ってください。"
