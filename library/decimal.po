# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-30 14:59+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/decimal.rst:2
msgid ":mod:`decimal` --- Decimal fixed point and floating point arithmetic"
msgstr ":mod:`decimal` --- 十進固定及び浮動小数点数の算術演算"

#: ../../library/decimal.rst:15
msgid "**Source code:** :source:`Lib/decimal.py`"
msgstr "**ソースコード:** :source:`Lib/decimal.py`"

#: ../../library/decimal.rst:33
msgid ""
"The :mod:`decimal` module provides support for fast correctly rounded "
"decimal floating point arithmetic. It offers several advantages over the :"
"class:`float` datatype:"
msgstr ""

#: ../../library/decimal.rst:37
msgid ""
"Decimal \"is based on a floating-point model which was designed with people "
"in mind, and necessarily has a paramount guiding principle -- computers must "
"provide an arithmetic that works in the same way as the arithmetic that "
"people learn at school.\" -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"「(Decimal は) 人々を念頭にデザインされた浮動小数点モデルを元にしており、必然"
"的に最も重要な指針があります -- コンピュータは人々が学校で習った算術と同じよ"
"うに動作する算術を提供しなければならない」 -- 十進数演算仕様より。"

#: ../../library/decimal.rst:42
msgid ""
"Decimal numbers can be represented exactly.  In contrast, numbers like :"
"const:`1.1` and :const:`2.2` do not have exact representations in binary "
"floating point. End users typically would not expect ``1.1 + 2.2`` to "
"display as :const:`3.3000000000000003` as it does with binary floating point."
msgstr ""
"十進数を正確に表現できます。 :const:`1.1` や :const:`2.2` のような数は、二進"
"数の浮動小数点型では正しく表現できません。エンドユーザは普通、 二進数におけ"
"る ``1.1 + 2.2`` の近似値が :const:`3.3000000000000003` だからといって、その"
"ように表示してほしいとは考えないものです。"

#: ../../library/decimal.rst:47
msgid ""
"The exactness carries over into arithmetic.  In decimal floating point, "
"``0.1 + 0.1 + 0.1 - 0.3`` is exactly equal to zero.  In binary floating "
"point, the result is :const:`5.5511151231257827e-017`.  While near to zero, "
"the differences prevent reliable equality testing and differences can "
"accumulate. For this reason, decimal is preferred in accounting applications "
"which have strict equality invariants."
msgstr ""
"値の正確さは算術にも及びます。十進の浮動小数点による計算では、 ``0.1 + 0.1 + "
"0.1 - 0.3`` は厳密にゼロに等しくなります。 二進浮動小数点では :const:"
"`5.5511151231257827e-017` になってしまいます。ゼロに近い値とはいえ、この誤差"
"は数値間の等価性テストの信頼性を阻害します。また、誤差が蓄積されることもあり"
"ます。こうした理由から、数値間の等価性を厳しく保たなければならないようなアプ"
"リケーションを考えるなら、十進数による数値表現が望ましいということになりま"
"す。"

#: ../../library/decimal.rst:54
msgid ""
"The decimal module incorporates a notion of significant places so that "
"``1.30 + 1.20`` is :const:`2.50`.  The trailing zero is kept to indicate "
"significance. This is the customary presentation for monetary applications. "
"For multiplication, the \"schoolbook\" approach uses all the figures in the "
"multiplicands.  For instance, ``1.3 * 1.2`` gives :const:`1.56` while ``1.30 "
"* 1.20`` gives :const:`1.5600`."
msgstr ""
":mod:`decimal` モジュールでは、有効桁数の表記が取り入れられており、例えば "
"``1.30 + 1.20`` は :const:`2.50` になります。すなわち、末尾のゼロは有効数字を"
"示すために残されます。こうした仕様は通貨計算を行うアプリケーションでは慣例で"
"す。乗算の場合、「教科書的な」アプローチでは、乗算の被演算子すべての桁数を使"
"います。例えば、 ``1.3 * 1.2`` は :const:`1.56` になり、 ``1.30 * 1.20`` は :"
"const:`1.5600` になります。"

#: ../../library/decimal.rst:61
msgid ""
"Unlike hardware based binary floating point, the decimal module has a user "
"alterable precision (defaulting to 28 places) which can be as large as "
"needed for a given problem:"
msgstr ""
"ハードウェアによる 2 進浮動小数点表現と違い、:mod:`decimal` モジュールでは計"
"算精度をユーザが変更できます(デフォルトでは 28 桁です)。この桁数はほとんどの"
"問題解決に十分な大きさです:"

#: ../../library/decimal.rst:73
msgid ""
"Both binary and decimal floating point are implemented in terms of published "
"standards.  While the built-in float type exposes only a modest portion of "
"its capabilities, the decimal module exposes all required parts of the "
"standard. When needed, the programmer has full control over rounding and "
"signal handling. This includes an option to enforce exact arithmetic by "
"using exceptions to block any inexact operations."
msgstr ""
"二進と十進の浮動小数点は、いずれも広く公開されている標準仕様のもとに実装され"
"ています。組み込みの浮動小数点型では、標準仕様で提唱されている機能のほんのさ"
"さやかな部分を利用できるにすぎませんが、:mod:`decimal` では標準仕様が要求して"
"いる全ての機能を利用できます。必要に応じて、プログラマは値の丸めやシグナル処"
"理を完全に制御できます。この中には全ての不正確な操作を例外でブロックして正確"
"な算術を遵守させるオプションもあります。"

#: ../../library/decimal.rst:80
msgid ""
"The decimal module was designed to support \"without prejudice, both exact "
"unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and "
"rounded floating-point arithmetic.\"  -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"decimal モジュールは「偏見なく、正確な丸めなしの十進算術(固定小数点算術と呼ば"
"れることもある)と丸めありの浮動小数点数算術」(十進数演算仕様より引用)をサポー"
"トするようにデザインされました。"

#: ../../library/decimal.rst:85
msgid ""
"The module design is centered around three concepts:  the decimal number, "
"the context for arithmetic, and signals."
msgstr ""
"このモジュールは、十進数型、算術コンテキスト (context for arithmetic)、そして"
"シグナル (signal) という三つの概念を中心に設計されています。"

#: ../../library/decimal.rst:88
msgid ""
"A decimal number is immutable.  It has a sign, coefficient digits, and an "
"exponent.  To preserve significance, the coefficient digits do not truncate "
"trailing zeros.  Decimals also include special values such as :const:"
"`Infinity`, :const:`-Infinity`, and :const:`NaN`.  The standard also "
"differentiates :const:`-0` from :const:`+0`."
msgstr ""
"十進数型は変更不能です。これは符号、係数部、そして指数を持ちます。有効桁数を"
"残すために、仮数部の末尾にあるゼロは切り詰められません。 :mod:`decimal` で"
"は、 :const:`Infinity`, :const:`-Infinity`, および :const:`NaN` といった特殊"
"な値も定義されています。標準仕様では :const:`-0` と :const:`+0` も区別しま"
"す。"

#: ../../library/decimal.rst:94
msgid ""
"The context for arithmetic is an environment specifying precision, rounding "
"rules, limits on exponents, flags indicating the results of operations, and "
"trap enablers which determine whether signals are treated as exceptions.  "
"Rounding options include :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:"
"`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:"
"`ROUND_HALF_UP`, :const:`ROUND_UP`, and :const:`ROUND_05UP`."
msgstr ""
"算術コンテキストとは、精度や値丸めの規則、指数部の制限を決めている環境です。"
"この環境では、演算結果を表すためのフラグや、演算上発生した特定のシグナルを例"
"外として扱うかどうかを決めるトラップイネーブラも定義しています。丸め規則に"
"は :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:`ROUND_FLOOR`, :const:"
"`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:`ROUND_HALF_UP`, :const:"
"`ROUND_UP`, および :const:`ROUND_05UP` があります。"

#: ../../library/decimal.rst:101
msgid ""
"Signals are groups of exceptional conditions arising during the course of "
"computation.  Depending on the needs of the application, signals may be "
"ignored, considered as informational, or treated as exceptions. The signals "
"in the decimal module are: :const:`Clamped`, :const:`InvalidOperation`, :"
"const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:"
"`Subnormal`, :const:`Overflow`, :const:`Underflow` and :const:"
"`FloatOperation`."
msgstr ""
"シグナルとは、演算の過程で生じる例外的条件です。個々のシグナルは、アプリケー"
"ションそれぞれの要求に従って、無視されたり、単なる情報とみなされたり、例外と"
"して扱われたりします。 :mod:`decimal` モジュールには、 :const:`Clamped`, :"
"const:`InvalidOperation`, :const:`DivisionByZero`, :const:`Inexact`, :const:"
"`Rounded`, :const:`Subnormal`, :const:`Overflow`, :const:`Underflow`, およ"
"び :const:`FloatOperation` といったシグナルがあります。"

#: ../../library/decimal.rst:108
msgid ""
"For each signal there is a flag and a trap enabler.  When a signal is "
"encountered, its flag is set to one, then, if the trap enabler is set to "
"one, an exception is raised.  Flags are sticky, so the user needs to reset "
"them before monitoring a calculation."
msgstr ""
"各シグナルには、フラグとトラップイネーブラがあります。演算上何らかのシグナル"
"に遭遇すると、フラグは 1 にセットされます。このとき、もしトラップイネーブラ"
"が 1 にセットされていれば、例外を送出します。フラグの値は膠着型 (sticky) なの"
"で、演算によるフラグの変化をモニタしたければ、予めフラグをリセットしておかな"
"ければなりません。"

#: ../../library/decimal.rst:116
msgid ""
"IBM's General Decimal Arithmetic Specification, `The General Decimal "
"Arithmetic Specification <https://speleotrove.com/decimal/decarith.html>`_."
msgstr ""

#: ../../library/decimal.rst:125
msgid "Quick-start Tutorial"
msgstr "クイックスタートチュートリアル"

#: ../../library/decimal.rst:127
msgid ""
"The usual start to using decimals is importing the module, viewing the "
"current context with :func:`getcontext` and, if necessary, setting new "
"values for precision, rounding, or enabled traps::"
msgstr ""
"普通、 :mod:`decimal` を使うときには、モジュールをインポートし、現在の演算コ"
"ンテキストを :func:`getcontext` で調べ、必要なら、精度、丸め、有効なトラップ"
"を設定します::"

#: ../../library/decimal.rst:139
msgid ""
"Decimal instances can be constructed from integers, strings, floats, or "
"tuples. Construction from an integer or a float performs an exact conversion "
"of the value of that integer or float.  Decimal numbers include special "
"values such as :const:`NaN` which stands for \"Not a number\", positive and "
"negative :const:`Infinity`, and :const:`-0`::"
msgstr ""
":class:`Decimal` インスタンスは、整数、文字列、浮動小数点数、またはタプルから"
"構成できます。整数や浮動小数点数からの構成は、整数や浮動小数点数の値を正確に"
"変換します。 :class:`Decimal` は \"非数 (Not a Number)\" を表す :const:`NaN` "
"や正負の :const:`Infinity` (無限大)、 :const:`-0` といった特殊な値も表現でき"
"ます::"

#: ../../library/decimal.rst:163
msgid ""
"If the :exc:`FloatOperation` signal is trapped, accidental mixing of "
"decimals and floats in constructors or ordering comparisons raises an "
"exception::"
msgstr ""
":exc:`FloatOperation` シグナルがトラップされる場合、コンストラクタや順序比較"
"において誤って decimal と float が混ざると、例外が送出されます::"

#: ../../library/decimal.rst:182
msgid ""
"The significance of a new Decimal is determined solely by the number of "
"digits input.  Context precision and rounding only come into play during "
"arithmetic operations."
msgstr ""
"新たな :class:`Decimal` の有効桁数は入力の桁数だけで決まります。演算コンテキ"
"ストにおける精度や値丸めの設定が影響するのは算術演算の間だけです。"

#: ../../library/decimal.rst:199
msgid ""
"If the internal limits of the C version are exceeded, constructing a decimal "
"raises :class:`InvalidOperation`::"
msgstr ""
"C バージョンの内部制限を超えた場合、decimal の構成は :class:"
"`InvalidOperation` を送出します::"

#: ../../library/decimal.rst:209
msgid ""
"Decimals interact well with much of the rest of Python.  Here is a small "
"decimal floating point flying circus:"
msgstr ""
"decimal はほとんどの場面で Python の他の機能とうまくやりとりできます。"
"decimal 浮動小数点の空飛ぶサーカス (flying circus) をお見せしましょう:"

#: ../../library/decimal.rst:241
msgid "And some mathematical functions are also available to Decimal:"
msgstr "いくつかの数学的関数も Decimal には用意されています:"

#: ../../library/decimal.rst:253
msgid ""
"The :meth:`quantize` method rounds a number to a fixed exponent.  This "
"method is useful for monetary applications that often round results to a "
"fixed number of places:"
msgstr ""
":meth:`quantize` メソッドは位を固定して数値を丸めます。このメソッドは、結果を"
"固定の桁数で丸めることがよくある、金融アプリケーションで便利です:"

#: ../../library/decimal.rst:262
msgid ""
"As shown above, the :func:`getcontext` function accesses the current context "
"and allows the settings to be changed.  This approach meets the needs of "
"most applications."
msgstr ""
"前述のように、 :func:`getcontext` 関数を使うと現在の演算コンテキストにアクセ"
"スでき、設定を変更できます。ほとんどのアプリケーションはこのアプローチで十分"
"です。"

#: ../../library/decimal.rst:266
msgid ""
"For more advanced work, it may be useful to create alternate contexts using "
"the Context() constructor.  To make an alternate active, use the :func:"
"`setcontext` function."
msgstr ""
"より高度な作業を行う場合、 :func:`Context` コンストラクタを使って別の演算コン"
"テキストを作っておくと便利なことがあります。別の演算コンテキストをアクティブ"
"にしたければ、 :func:`setcontext` を使います。"

#: ../../library/decimal.rst:270
msgid ""
"In accordance with the standard, the :mod:`decimal` module provides two "
"ready to use standard contexts, :const:`BasicContext` and :const:"
"`ExtendedContext`. The former is especially useful for debugging because "
"many of the traps are enabled:"
msgstr ""
":mod:`decimal` モジュールでは、標準仕様に従って、すぐ利用できる二つの標準コン"
"テキスト、 :const:`BasicContext` および :const:`ExtendedContext` を提供してい"
"ます。前者はほとんどのトラップが有効になっており、とりわけデバッグの際に便利"
"です:"

#: ../../library/decimal.rst:299
msgid ""
"Contexts also have signal flags for monitoring exceptional conditions "
"encountered during computations.  The flags remain set until explicitly "
"cleared, so it is best to clear the flags before each set of monitored "
"computations by using the :meth:`clear_flags` method. ::"
msgstr ""
"演算コンテキストには、演算中に遭遇した例外的状況をモニタするためのシグナルフ"
"ラグがあります。フラグが一度セットされると、明示的にクリアするまで残り続けま"
"す。そのため、フラグのモニタを行いたいような演算の前には :meth:`clear_flags` "
"メソッドでフラグをクリアしておくのがベストです。 ::"

#: ../../library/decimal.rst:312
msgid ""
"The *flags* entry shows that the rational approximation to :const:`Pi` was "
"rounded (digits beyond the context precision were thrown away) and that the "
"result is inexact (some of the discarded digits were non-zero)."
msgstr ""
"*flags* エントリから、 :const:`Pi` の有理数による近似値が丸められた (コンテキ"
"スト内で決められた精度を超えた桁数が捨てられた) ことと、計算結果が厳密でない "
"(無視された桁の値に非ゼロのものがあった) ことがわかります。"

#: ../../library/decimal.rst:316
msgid ""
"Individual traps are set using the dictionary in the :attr:`traps` field of "
"a context:"
msgstr ""
"コンテキストの :attr:`traps` フィールドに入っている辞書を使うと、個々のトラッ"
"プをセットできます:"

#: ../../library/decimal.rst:331
msgid ""
"Most programs adjust the current context only once, at the beginning of the "
"program.  And, in many applications, data is converted to :class:`Decimal` "
"with a single cast inside a loop.  With context set and decimals created, "
"the bulk of the program manipulates the data no differently than with other "
"Python numeric types."
msgstr ""
"ほとんどのプログラムでは、開始時に一度だけ現在の演算コンテキストを修正しま"
"す。また、多くのアプリケーションでは、データから :class:`Decimal` への変換は"
"ループ内で一度だけキャストして行います。コンテキストを設定し、 :class:"
"`Decimal` オブジェクトを生成できたら、ほとんどのプログラムは他の Python 数値"
"型と全く変わらないかのように :class:`Decimal` を操作できます。"

#: ../../library/decimal.rst:343
msgid "Decimal objects"
msgstr "Decimal オブジェクト"

#: ../../library/decimal.rst:348
msgid "Construct a new :class:`Decimal` object based from *value*."
msgstr "*value* に基づいて新たな :class:`Decimal` オブジェクトを構築します。"

#: ../../library/decimal.rst:350
msgid ""
"*value* can be an integer, string, tuple, :class:`float`, or another :class:"
"`Decimal` object. If no *value* is given, returns ``Decimal('0')``.  If "
"*value* is a string, it should conform to the decimal numeric string syntax "
"after leading and trailing whitespace characters, as well as underscores "
"throughout, are removed::"
msgstr ""
"*value* は整数、文字列、タプル、 :class:`float` および他の :class:`Decimal` "
"オブジェクトにできます。 *value* を指定しない場合、 ``Decimal('0')`` を返しま"
"す。 *value* が文字列の場合、先頭と末尾の空白および全てのアンダースコアを取り"
"除いた後には以下の 10進数文字列の文法に従わなければなりません::"

#: ../../library/decimal.rst:366
msgid ""
"Other Unicode decimal digits are also permitted where ``digit`` appears "
"above.  These include decimal digits from various other alphabets (for "
"example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits "
"``'\\uff10'`` through ``'\\uff19'``."
msgstr ""
"他の Unicode 数字も上の ``digit`` の場所に使うことができます。つまり各書記体"
"系における(アラビア-インド系やデーヴァナーガリーなど)の数字や、全角数字０"
"(``'\\uff10'``)から９(``'\\uff19'``)までなどです。"

#: ../../library/decimal.rst:371
msgid ""
"If *value* is a :class:`tuple`, it should have three components, a sign (:"
"const:`0` for positive or :const:`1` for negative), a :class:`tuple` of "
"digits, and an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), "
"-3))`` returns ``Decimal('1.414')``."
msgstr ""
"*value* を :class:`tuple` にする場合、タプルは三つの要素を持ち、それぞれ符号 "
"(正なら :const:`0` 、負なら :const:`1`)、仮数部を表す数字の :class:`tuple` 、"
"そして指数を表す整数でなければなりません。例えば、 ``Decimal((0, (1, 4, 1, "
"4), -3))`` は ``Decimal('1.414')`` を返します。"

#: ../../library/decimal.rst:376
msgid ""
"If *value* is a :class:`float`, the binary floating point value is "
"losslessly converted to its exact decimal equivalent.  This conversion can "
"often require 53 or more digits of precision.  For example, "
"``Decimal(float('1.1'))`` converts to "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."
msgstr ""
"*value* を :class:`float` にする場合、二進浮動小数点数値が損失なく正確に等価"
"な Decimal に変換されます。この変換はしばしば 53 桁以上の精度を要求します。例"
"えば、 ``Decimal(float('1.1'))`` は "
"``Decimal('1.100000000000000088817841970012523233890533447265625')`` に変換さ"
"れます。"

#: ../../library/decimal.rst:382
msgid ""
"The *context* precision does not affect how many digits are stored. That is "
"determined exclusively by the number of digits in *value*. For example, "
"``Decimal('3.00000')`` records all five zeros even if the context precision "
"is only three."
msgstr ""
"*context* の精度 (precision) は、記憶される桁数には影響しません。桁数は "
"*value* に指定した桁数だけから決定されます。例えば、演算コンテキストに指定さ"
"れた精度が 3 桁しかなくても、``Decimal('3.00000')`` は 5 つのゼロを全て記憶し"
"ます。"

#: ../../library/decimal.rst:387
msgid ""
"The purpose of the *context* argument is determining what to do if *value* "
"is a malformed string.  If the context traps :const:`InvalidOperation`, an "
"exception is raised; otherwise, the constructor returns a new Decimal with "
"the value of :const:`NaN`."
msgstr ""
"*context* 引数の目的は、 *value* が正しくない形式の文字列であった場合に行う処"
"理を決めることにあります; 演算コンテキストが :const:`InvalidOperation` をト"
"ラップするようになっていれば、例外を送出します。それ以外の場合には、コンスト"
"ラクタは値が :const:`NaN` の :class:`Decimal` を返します。"

#: ../../library/decimal.rst:392
msgid "Once constructed, :class:`Decimal` objects are immutable."
msgstr ""
"一度生成すると、 :class:`Decimal` オブジェクトは変更不能 (immutable) になりま"
"す。"

#: ../../library/decimal.rst:394
msgid ""
"The argument to the constructor is now permitted to be a :class:`float` "
"instance."
msgstr ""
"コンストラクタに対する引数に :class:`float` インスタンスも許されるようになり"
"ました。"

#: ../../library/decimal.rst:398
msgid ""
":class:`float` arguments raise an exception if the :exc:`FloatOperation` "
"trap is set. By default the trap is off."
msgstr ""
":exc:`FloatOperation` トラップがセットされていた場合 :class:`float` 引数は例"
"外を送出します。デフォルトでトラップはオフです。"

#: ../../library/decimal.rst:402
msgid ""
"Underscores are allowed for grouping, as with integral and floating-point "
"literals in code."
msgstr ""
"コード中の整数リテラルや浮動小数点リテラルと同様に、アンダースコアを用いて桁"
"をグルーピングできます。"

#: ../../library/decimal.rst:406
msgid ""
"Decimal floating point objects share many properties with the other built-in "
"numeric types such as :class:`float` and :class:`int`.  All of the usual "
"math operations and special methods apply.  Likewise, decimal objects can be "
"copied, pickled, printed, used as dictionary keys, used as set elements, "
"compared, sorted, and coerced to another type (such as :class:`float` or :"
"class:`int`)."
msgstr ""
"十進浮動小数点オブジェクトは、 :class:`float` や :class:`int` のような他の組"
"み込み型と多くの点で似ています。通常の数学演算や特殊メソッドを適用できます。"
"また、 :class:`Decimal` オブジェクトはコピーでき、pickle 化でき、print で出力"
"でき、辞書のキーにでき、集合の要素にでき、比較、保存、他の型 (:class:`float` "
"や :class:`int`) への型強制を行えます。"

#: ../../library/decimal.rst:413
msgid ""
"There are some small differences between arithmetic on Decimal objects and "
"arithmetic on integers and floats.  When the remainder operator ``%`` is "
"applied to Decimal objects, the sign of the result is the sign of the "
"*dividend* rather than the sign of the divisor::"
msgstr ""
"十進オブジェクトの算術演算と整数や浮動小数点数の算術演算には少々違いがありま"
"す。十進オブジェクトに対して剰余演算を適用すると、計算結果の符号は除数の符号"
"ではなく *被除数* の符号と一致します::"

#: ../../library/decimal.rst:423
msgid ""
"The integer division operator ``//`` behaves analogously, returning the "
"integer part of the true quotient (truncating towards zero) rather than its "
"floor, so as to preserve the usual identity ``x == (x // y) * y + x % y``::"
msgstr ""
"整数除算演算子 ``//`` も同様に、実際の商の切り捨てではなく (0に近付くように丸"
"めた) 整数部分を返します。そのため通常の恒等式 ``x == (x // y) * y + x % y`` "
"が維持されます::"

#: ../../library/decimal.rst:432
msgid ""
"The ``%`` and ``//`` operators implement the ``remainder`` and ``divide-"
"integer`` operations (respectively) as described in the specification."
msgstr ""
"演算子 ``%`` と演算子 ``//`` は (それぞれ) 仕様にあるような ``剰余`` 操作と "
"``整数除算`` 操作を実装しています。"

#: ../../library/decimal.rst:436
msgid ""
"Decimal objects cannot generally be combined with floats or instances of :"
"class:`fractions.Fraction` in arithmetic operations: an attempt to add a :"
"class:`Decimal` to a :class:`float`, for example, will raise a :exc:"
"`TypeError`.  However, it is possible to use Python's comparison operators "
"to compare a :class:`Decimal` instance ``x`` with another number ``y``.  "
"This avoids confusing results when doing equality comparisons between "
"numbers of different types."
msgstr ""
"Decimal オブジェクトは一般に、算術演算で浮動小数点数や :class:`fractions."
"Fraction` オブジェクトと組み合わせることができません。例えば、 :class:"
"`Decimal` に :class:`float` を足そうとすると、 :exc:`TypeError` が送出されま"
"す。ただし、Python の比較演算子を使って :class:`Decimal` インスタンス ``x`` "
"と別の数 ``y`` を比較することができます。これにより、異なる型の数間の等価比較"
"の際に、紛らわしい結果を避けます。"

#: ../../library/decimal.rst:444
msgid ""
"Mixed-type comparisons between :class:`Decimal` instances and other numeric "
"types are now fully supported."
msgstr ""
":class:`Decimal` インスタンスと他の数値型が混在する比較が完全にサポートされる"
"ようになりました。"

#: ../../library/decimal.rst:448
msgid ""
"In addition to the standard numeric properties, decimal floating point "
"objects also have a number of specialized methods:"
msgstr ""
"こうした標準的な数値型の特性の他に、十進浮動小数点オブジェクトには様々な特殊"
"メソッドがあります:"

#: ../../library/decimal.rst:454
msgid ""
"Return the adjusted exponent after shifting out the coefficient's rightmost "
"digits until only the lead digit remains: ``Decimal('321e+5').adjusted()`` "
"returns seven.  Used for determining the position of the most significant "
"digit with respect to the decimal point."
msgstr ""
"仮数の先頭の一桁だけが残るように右側の数字を追い出す桁シフトを行い、その結果"
"の指数部を返します: ``Decimal('321e+5').adjusted()`` は 7 を返します。最上桁"
"の小数点からの相対位置を調べる際に使います。"

#: ../../library/decimal.rst:461
msgid ""
"Return a pair ``(n, d)`` of integers that represent the given :class:"
"`Decimal` instance as a fraction, in lowest terms and with a positive "
"denominator::"
msgstr ""
"与えられた :class:`Decimal` インスタンスを、既約分数で分母が正数の分数として"
"表現した整数のペア ``(n, d)`` を返します。"

#: ../../library/decimal.rst:468
msgid ""
"The conversion is exact.  Raise OverflowError on infinities and ValueError "
"on NaNs."
msgstr ""
"変換は正確に行われます。無限大に対してはOverflowErrorを、NaNに対しては"
"ValueError を送出します。"

#: ../../library/decimal.rst:475
msgid ""
"Return a :term:`named tuple` representation of the number: "
"``DecimalTuple(sign, digits, exponent)``."
msgstr ""
"数値を表現するための :term:`名前付きタプル <named tuple>`: "
"``DecimalTuple(sign, digittuple, exponent)`` を返します。"

#: ../../library/decimal.rst:481
msgid ""
"Return the canonical encoding of the argument.  Currently, the encoding of "
"a :class:`Decimal` instance is always canonical, so this operation returns "
"its argument unchanged."
msgstr ""
"引数の標準的(canonical)エンコーディングを返します。現在のところ、 :class:"
"`Decimal` インスタンスのエンコーディングは常に標準的なので、この操作は引数に"
"手を加えずに返します。"

#: ../../library/decimal.rst:487
msgid ""
"Compare the values of two Decimal instances.  :meth:`compare` returns a "
"Decimal instance, and if either operand is a NaN then the result is a NaN::"
msgstr ""
"二つの Decimal インスタンスの値を比較します。 :meth:`compare` は Decimal イン"
"スタンスを返し、被演算子のどちらかが NaN ならば結果は NaN です::"

#: ../../library/decimal.rst:498
msgid ""
"This operation is identical to the :meth:`compare` method, except that all "
"NaNs signal.  That is, if neither operand is a signaling NaN then any quiet "
"NaN operand is treated as though it were a signaling NaN."
msgstr ""
"この演算は :meth:`compare` とほとんど同じですが、全ての NaN がシグナルを送る"
"ところが異なります。すなわち、どちらの比較対象も発信 (signaling) NaN でないな"
"らば無言 (quiet) NaN である比較対象があたかも発信 NaN であるかのように扱われ"
"ます。"

#: ../../library/decimal.rst:504
msgid ""
"Compare two operands using their abstract representation rather than their "
"numerical value.  Similar to the :meth:`compare` method, but the result "
"gives a total ordering on :class:`Decimal` instances.  Two :class:`Decimal` "
"instances with the same numeric value but different representations compare "
"unequal in this ordering:"
msgstr ""
"二つの対象を数値によらず抽象表現によって比較します。 :meth:`compare` に似てい"
"ますが、結果は :class:`Decimal` に全順序を与えます。この順序づけによると、数"
"値的に等しくても異なった表現を持つ二つの :class:`Decimal` インスタンスの比較"
"は等しくなりません:"

#: ../../library/decimal.rst:513
msgid ""
"Quiet and signaling NaNs are also included in the total ordering.  The "
"result of this function is ``Decimal('0')`` if both operands have the same "
"representation, ``Decimal('-1')`` if the first operand is lower in the total "
"order than the second, and ``Decimal('1')`` if the first operand is higher "
"in the total order than the second operand.  See the specification for "
"details of the total order."
msgstr ""
"無言 NaN と発信 NaN もこの全順序に位置付けられます。この関数の結果は、もし比"
"較対象が同じ表現を持つならば ``Decimal('0')`` であり、一つめの比較対象が二つ"
"めより下位にあれば ``Decimal('-1')``、上位にあれば ``Decimal('1')`` です。全"
"順序の詳細については仕様を参照してください。"

#: ../../library/decimal.rst:520 ../../library/decimal.rst:531
#: ../../library/decimal.rst:559 ../../library/decimal.rst:835
msgid ""
"This operation is unaffected by context and is quiet: no flags are changed "
"and no rounding is performed.  As an exception, the C version may raise "
"InvalidOperation if the second operand cannot be converted exactly."
msgstr ""
"この演算はコンテキストに影響されず、静かです。すなわち、フラグは変更されず、"
"丸めは行われません。例外として、2番目の比較対象の厳密な変換ができない場合、C "
"バージョンのライブラリでは InvalidOperation 例外を送出するかもしれません。"

#: ../../library/decimal.rst:526
msgid ""
"Compare two operands using their abstract representation rather than their "
"value as in :meth:`compare_total`, but ignoring the sign of each operand. "
"``x.compare_total_mag(y)`` is equivalent to ``x.copy_abs().compare_total(y."
"copy_abs())``."
msgstr ""
"二つの対象を :meth:`compare_total` のように数値によらず抽象表現によって比較し"
"ますが、両者の符号を無視します。 ``x.compare_total_mag(y)`` は ``x."
"copy_abs().compare_total(y.copy_abs())`` と等価です。"

#: ../../library/decimal.rst:537
msgid ""
"Just returns self, this method is only to comply with the Decimal "
"Specification."
msgstr ""
"self を返すだけです。このメソッドは十進演算仕様に適合するためだけのものです。"

#: ../../library/decimal.rst:542
msgid ""
"Return the absolute value of the argument.  This operation is unaffected by "
"the context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"引数の絶対値を返します。この演算はコンテキストに影響されず、静かです。すなわ"
"ち、フラグは変更されず、丸めは行われません。"

#: ../../library/decimal.rst:548
msgid ""
"Return the negation of the argument.  This operation is unaffected by the "
"context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"引数の符号を変えて返します。この演算はコンテキストに影響されず、静かです。す"
"なわち、フラグは変更されず、丸めは行われません。"

#: ../../library/decimal.rst:553
msgid ""
"Return a copy of the first operand with the sign set to be the same as the "
"sign of the second operand.  For example:"
msgstr "最初の演算対象のコピーに二つめと同じ符号を付けて返します。たとえば:"

#: ../../library/decimal.rst:565
msgid ""
"Return the value of the (natural) exponential function ``e**x`` at the given "
"number.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN` "
"rounding mode."
msgstr ""
"与えられた数での(自然)指数関数 ``e**x`` の値を返します。結果は :const:"
"`ROUND_HALF_EVEN` 丸めモードで正しく丸められます。"

#: ../../library/decimal.rst:576
msgid ""
"Alternative constructor that only accepts instances of :class:`float` or :"
"class:`int`."
msgstr ""

#: ../../library/decimal.rst:579
msgid ""
"Note ``Decimal.from_float(0.1)`` is not the same as ``Decimal('0.1')``. "
"Since 0.1 is not exactly representable in binary floating point, the value "
"is stored as the nearest representable value which is "
"``0x1.999999999999ap-4``.  That equivalent value in decimal is "
"``0.1000000000000000055511151231257827021181583404541015625``."
msgstr ""

#: ../../library/decimal.rst:585
msgid ""
"From Python 3.2 onwards, a :class:`Decimal` instance can also be constructed "
"directly from a :class:`float`."
msgstr ""
"Python 3.2 以降では、 :class:`Decimal` インスタンスは :class:`float` から直接"
"構成できるようになりました。"

#: ../../library/decimal.rst:603
msgid ""
"Fused multiply-add.  Return self*other+third with no rounding of the "
"intermediate product self*other."
msgstr ""
"融合積和(fused multiply-add)です。self*other+third を途中結果の積 self*other "
"で丸めを行わずに計算して返します。"

#: ../../library/decimal.rst:611
msgid ""
"Return :const:`True` if the argument is canonical and :const:`False` "
"otherwise.  Currently, a :class:`Decimal` instance is always canonical, so "
"this operation always returns :const:`True`."
msgstr ""
"引数が標準的(canonical)ならば :const:`True` を返し、そうでなければ :const:"
"`False` を返します。現在のところ、 :class:`Decimal` のインスタンスは常に標準"
"的なのでこのメソッドの結果はいつでも :const:`True` です。"

#: ../../library/decimal.rst:617
msgid ""
"Return :const:`True` if the argument is a finite number, and :const:`False` "
"if the argument is an infinity or a NaN."
msgstr ""
"引数が有限の数値ならば :const:`True` を、無限大か NaN ならば :const:`False` "
"を返します。"

#: ../../library/decimal.rst:622
msgid ""
"Return :const:`True` if the argument is either positive or negative infinity "
"and :const:`False` otherwise."
msgstr ""
"引数が正または負の無限大ならば :const:`True` を、そうでなければ :const:"
"`False` を返します。"

#: ../../library/decimal.rst:627
msgid ""
"Return :const:`True` if the argument is a (quiet or signaling) NaN and :"
"const:`False` otherwise."
msgstr ""
"引数が (無言か発信かは問わず) NaN であれば :const:`True` を、そうでなければ :"
"const:`False` を返します。"

#: ../../library/decimal.rst:632
msgid ""
"Return :const:`True` if the argument is a *normal* finite number.  Return :"
"const:`False` if the argument is zero, subnormal, infinite or a NaN."
msgstr ""
"引数が *正規(normal)* の有限数値ならば :const:`True` を返します。引数がゼロ、"
"非正規(subnormal)、無限大または NaN であれば :const:`False` を返します。"

#: ../../library/decimal.rst:637
msgid ""
"Return :const:`True` if the argument is a quiet NaN, and :const:`False` "
"otherwise."
msgstr ""
"引数が無言 NaN であれば :const:`True` を、そうでなければ :const:`False` を返"
"します。"

#: ../../library/decimal.rst:642
msgid ""
"Return :const:`True` if the argument has a negative sign and :const:`False` "
"otherwise.  Note that zeros and NaNs can both carry signs."
msgstr ""
"引数に負の符号がついていれば :const:`True` を、そうでなければ :const:`False` "
"を返します。注意すべきはゼロや NaN なども符号を持ち得ることです。"

#: ../../library/decimal.rst:647
msgid ""
"Return :const:`True` if the argument is a signaling NaN and :const:`False` "
"otherwise."
msgstr ""
"引数が発信 NaN であれば :const:`True` を、そうでなければ :const:`False` を返"
"します。"

#: ../../library/decimal.rst:652
msgid ""
"Return :const:`True` if the argument is subnormal, and :const:`False` "
"otherwise."
msgstr ""
"引数が非正規数(subnormal)であれば :const:`True` を、そうでなければ :const:"
"`False` を返します。"

#: ../../library/decimal.rst:657
msgid ""
"Return :const:`True` if the argument is a (positive or negative) zero and :"
"const:`False` otherwise."
msgstr ""
"引数が(正または負の)ゼロであれば :const:`True` を、そうでなければ :const:"
"`False` を返します。"

#: ../../library/decimal.rst:662
msgid ""
"Return the natural (base e) logarithm of the operand.  The result is "
"correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"演算対象の自然対数(底 e の対数)を返します。結果は :const:`ROUND_HALF_EVEN` 丸"
"めモードで正しく丸められます。"

#: ../../library/decimal.rst:667
msgid ""
"Return the base ten logarithm of the operand.  The result is correctly "
"rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"演算対象の底 10 の対数を返します。結果は :const:`ROUND_HALF_EVEN` 丸めモード"
"で正しく丸められます。"

#: ../../library/decimal.rst:672
msgid ""
"For a nonzero number, return the adjusted exponent of its operand as a :"
"class:`Decimal` instance.  If the operand is a zero then ``Decimal('-"
"Infinity')`` is returned and the :const:`DivisionByZero` flag is raised.  If "
"the operand is an infinity then ``Decimal('Infinity')`` is returned."
msgstr ""
"非零の数値については、 :class:`Decimal` インスタンスとして調整された指数を返"
"します。演算対象がゼロだった場合、 ``Decimal('-Infinity')`` が返され :const:"
"`DivisionByZero` フラグが送出されます。演算対象が無限大だった場合、 "
"``Decimal('Infinity')`` が返されます。"

#: ../../library/decimal.rst:680
msgid ""
":meth:`logical_and` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"``and`` of the two operands."
msgstr ""
":meth:`logical_and` は二つの *論理引数* (:ref:`logical_operands_label` 参照)"
"を取る論理演算です。結果は二つの引数の数字ごとの ``and`` です。"

#: ../../library/decimal.rst:686
msgid ""
":meth:`logical_invert` is a logical operation.  The result is the digit-wise "
"inversion of the operand."
msgstr ""
":meth:`logical_invert` は論理演算です。結果は引数の数字ごとの反転です。"

#: ../../library/decimal.rst:691
msgid ""
":meth:`logical_or` is a logical operation which takes two *logical operands* "
"(see :ref:`logical_operands_label`).  The result is the digit-wise ``or`` of "
"the two operands."
msgstr ""
":meth:`logical_or` は二つの *論理引数* (:ref:`logical_operands_label` 参照)を"
"取る論理演算です。結果は二つの引数の数字ごとの ``or`` です。"

#: ../../library/decimal.rst:697
msgid ""
":meth:`logical_xor` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"exclusive or of the two operands."
msgstr ""
":meth:`logical_xor` は二つの *論理引数* (:ref:`logical_operands_label` 参照)"
"を取る論理演算です。結果は二つの引数の数字ごとの排他的論理和です。"

#: ../../library/decimal.rst:703
msgid ""
"Like ``max(self, other)`` except that the context rounding rule is applied "
"before returning and that :const:`NaN` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"``max(self, other)`` と同じですが、値を返す前に現在のコンテキストに即した丸め"
"規則を適用します。また、 :const:`NaN` に対して、(コンテキストの設定と、発信か"
"無言どちらのタイプであるかに応じて) シグナルを発行するか無視します。"

#: ../../library/decimal.rst:710
msgid ""
"Similar to the :meth:`.max` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ":meth:`.max` メソッドに似ていますが、比較は絶対値で行われます。"

#: ../../library/decimal.rst:715
msgid ""
"Like ``min(self, other)`` except that the context rounding rule is applied "
"before returning and that :const:`NaN` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"``min(self, other)`` と同じですが、値を返す前に現在のコンテキストに即した丸め"
"規則を適用します。また、 :const:`NaN` に対して、(コンテキストの設定と、発信か"
"無言どちらのタイプであるかに応じて) シグナルを発行するか無視します。"

#: ../../library/decimal.rst:722
msgid ""
"Similar to the :meth:`.min` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ":meth:`.min` メソッドに似ていますが、比較は絶対値で行われます。"

#: ../../library/decimal.rst:727
msgid ""
"Return the largest number representable in the given context (or in the "
"current thread's context if no context is given) that is smaller than the "
"given operand."
msgstr ""
"与えられたコンテキスト(またはコンテキストが渡されなければ現スレッドのコンテキ"
"スト)において表現可能な、操作対象より小さい最大の数を返します。"

#: ../../library/decimal.rst:733
msgid ""
"Return the smallest number representable in the given context (or in the "
"current thread's context if no context is given) that is larger than the "
"given operand."
msgstr ""
"与えられたコンテキスト(またはコンテキストが渡されなければ現スレッドのコンテキ"
"スト)において表現可能な、操作対象より大きい最小の数を返します。"

#: ../../library/decimal.rst:739
msgid ""
"If the two operands are unequal, return the number closest to the first "
"operand in the direction of the second operand.  If both operands are "
"numerically equal, return a copy of the first operand with the sign set to "
"be the same as the sign of the second operand."
msgstr ""
"二つの比較対象が等しくなければ、一つめの対象に最も近く二つめの対象へ近付く方"
"向の数を返します。もし両者が数値的に等しければ、二つめの対象の符号を採った一"
"つめの対象のコピーを返します。"

#: ../../library/decimal.rst:746
msgid ""
"Normalize the number by stripping the rightmost trailing zeros and "
"converting any result equal to :const:`Decimal('0')` to :const:"
"`Decimal('0e0')`. Used for producing canonical values for attributes of an "
"equivalence class. For example, ``Decimal('32.100')`` and "
"``Decimal('0.321000e+2')`` both normalize to the equivalent value "
"``Decimal('32.1')``."
msgstr ""
"数値を正規化 (normalize) して、右端に連続しているゼロを除去し、 :const:"
"`Decimal('0')` と同じ結果はすべて :const:`Decimal('0e0')` に変換します。等価"
"クラスの属性から基準表現を生成する際に用います。たとえば、 "
"``Decimal('32.100')`` と ``Decimal('0.321000e+2')`` の正規化は、いずれも同じ"
"値 ``Decimal('32.1')`` になります。"

#: ../../library/decimal.rst:755
msgid ""
"Return a string describing the *class* of the operand.  The returned value "
"is one of the following ten strings."
msgstr ""
"操作対象の *クラス* を表す文字列を返します。返されるのは以下の10種類のいずれ"
"かです。"

#: ../../library/decimal.rst:758
msgid "``\"-Infinity\"``, indicating that the operand is negative infinity."
msgstr "``\"-Infinity\"``, 負の無限大であることを示します。"

#: ../../library/decimal.rst:759
msgid ""
"``\"-Normal\"``, indicating that the operand is a negative normal number."
msgstr "``\"-Normal\"``, 負の通常数であることを示します。"

#: ../../library/decimal.rst:760
msgid ""
"``\"-Subnormal\"``, indicating that the operand is negative and subnormal."
msgstr "``\"-Subnormal\"``, 負の非正規数であることを示します。"

#: ../../library/decimal.rst:761
msgid "``\"-Zero\"``, indicating that the operand is a negative zero."
msgstr "``\"-Zero\"``, 負のゼロであることを示します。"

#: ../../library/decimal.rst:762
msgid "``\"+Zero\"``, indicating that the operand is a positive zero."
msgstr "``\"+Zero\"``, 正のゼロであることを示します。"

#: ../../library/decimal.rst:763
msgid ""
"``\"+Subnormal\"``, indicating that the operand is positive and subnormal."
msgstr "``\"+Subnormal\"``, 正の非正規数であることを示します。"

#: ../../library/decimal.rst:764
msgid ""
"``\"+Normal\"``, indicating that the operand is a positive normal number."
msgstr "``\"+Normal\"``, 正の通常数であることを示します。"

#: ../../library/decimal.rst:765
msgid "``\"+Infinity\"``, indicating that the operand is positive infinity."
msgstr "``\"+Infinity\"``, 正の無限大であることを示します。"

#: ../../library/decimal.rst:766
msgid "``\"NaN\"``, indicating that the operand is a quiet NaN (Not a Number)."
msgstr "``\"NaN\"``, 無言 (quiet) NaN (Not a Number) であることを示します。"

#: ../../library/decimal.rst:767
msgid "``\"sNaN\"``, indicating that the operand is a signaling NaN."
msgstr "``\"sNaN\"``, 発信(signaling) NaN であることを示します。"

#: ../../library/decimal.rst:771
msgid ""
"Return a value equal to the first operand after rounding and having the "
"exponent of the second operand."
msgstr ""
"二つ目の操作対象と同じ指数を持つように丸めを行った、一つめの操作対象と等しい"
"値を返します。"

#: ../../library/decimal.rst:777
msgid ""
"Unlike other operations, if the length of the coefficient after the quantize "
"operation would be greater than precision, then an :const:`InvalidOperation` "
"is signaled. This guarantees that, unless there is an error condition, the "
"quantized exponent is always equal to that of the right-hand operand."
msgstr ""
"他の操作と違い、打ち切り(quantize)操作後の係数の長さが精度を越えた場合に"
"は、 :const:`InvalidOperation` がシグナルされます。これによりエラー条件がない"
"限り打ち切られた指数が常に右側の引数と同じになることが保証されます。"

#: ../../library/decimal.rst:783
msgid ""
"Also unlike other operations, quantize never signals Underflow, even if the "
"result is subnormal and inexact."
msgstr ""
"同様に、他の操作と違い、quantize は Underflow を、たとえ結果が非正規になった"
"り不正確になったとしても、シグナルしません。"

#: ../../library/decimal.rst:786
msgid ""
"If the exponent of the second operand is larger than that of the first then "
"rounding may be necessary.  In this case, the rounding mode is determined by "
"the ``rounding`` argument if given, else by the given ``context`` argument; "
"if neither argument is given the rounding mode of the current thread's "
"context is used."
msgstr ""
"二つ目の演算対象の指数が一つ目のそれよりも大きければ丸めが必要かもしれませ"
"ん。この場合、丸めモードは以下のように決められます。``rounding`` 引数が与えら"
"れていればそれが使われます。そうでなければ ``context`` 引数で決まります。どち"
"らの引数も渡されなければ現在のスレッドのコンテキストの丸めモードが使われま"
"す。"

#: ../../library/decimal.rst:792
msgid ""
"An error is returned whenever the resulting exponent is greater than :attr:"
"`Emax` or less than :attr:`Etiny`."
msgstr ""
"処理結果の指数が :attr:`Emax` よりも大きい場合や :attr:`Etiny` よりも小さい場"
"合にエラーが返されます。"

#: ../../library/decimal.rst:797
msgid ""
"Return ``Decimal(10)``, the radix (base) in which the :class:`Decimal` class "
"does all its arithmetic.  Included for compatibility with the specification."
msgstr ""
"``Decimal(10)`` つまり :class:`Decimal` クラスがその全ての算術を実行する基数"
"を返します。仕様との互換性のために取り入れられています。"

#: ../../library/decimal.rst:803
msgid ""
"Return the remainder from dividing *self* by *other*.  This differs from "
"``self % other`` in that the sign of the remainder is chosen so as to "
"minimize its absolute value.  More precisely, the return value is ``self - n "
"* other`` where ``n`` is the integer nearest to the exact value of ``self / "
"other``, and if two integers are equally near then the even one is chosen."
msgstr ""
"*self* を *other* で割った剰余を返します。これは ``self % other`` とは違っ"
"て、剰余の絶対値を小さくするように符号が選ばれます。より詳しく言うと、``n`` "
"を ``self / other`` の正確な値に最も近い整数としたときの ``self - n * "
"other`` が返り値になります。最も近い整数が2つある場合には偶数のものが選ばれま"
"す。"

#: ../../library/decimal.rst:810
msgid "If the result is zero then its sign will be the sign of *self*."
msgstr "結果が0になる場合の符号は *self* の符号と同じになります。"

#: ../../library/decimal.rst:821
msgid ""
"Return the result of rotating the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to rotate.  If the second operand is "
"positive then rotation is to the left; otherwise rotation is to the right. "
"The coefficient of the first operand is padded on the left with zeros to "
"length precision if necessary.  The sign and exponent of the first operand "
"are unchanged."
msgstr ""
"一つ目の演算対象の数字を二つ目で指定された量だけ巡回(rotate)した結果を返しま"
"す。二つめの演算対象は -precision から precision までの範囲の整数でなければな"
"りません。この二つ目の演算対象の絶対値を何桁ずらすかを決めます。そしてもし正"
"の数ならば巡回の方向は左に、そうでなければ右になります。一つ目の演算対象の仮"
"数部は必要ならば精度いっぱいまでゼロで埋められます。符号と指数は変えられませ"
"ん。"

#: ../../library/decimal.rst:832
msgid ""
"Test whether self and other have the same exponent or whether both are :"
"const:`NaN`."
msgstr ""
"*self* と *other* が同じ指数を持っているか、あるいは双方とも :const:`NaN` で"
"ある場合に真を返します。"

#: ../../library/decimal.rst:841
msgid ""
"Return the first operand with exponent adjusted by the second. Equivalently, "
"return the first operand multiplied by ``10**other``.  The second operand "
"must be an integer."
msgstr ""
"二つ目の演算対象で調整された指数の一つ目の演算対象を返します。同じことです"
"が、一つめの演算対象を ``10**other`` 倍したものを返します。二つ目の演算対象は"
"整数でなければなりません。"

#: ../../library/decimal.rst:847
msgid ""
"Return the result of shifting the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to shift.  If the second operand is "
"positive then the shift is to the left; otherwise the shift is to the "
"right.  Digits shifted into the coefficient are zeros.  The sign and "
"exponent of the first operand are unchanged."
msgstr ""
"一つ目の演算対象の数字を二つ目で指定された量だけシフトした結果を返します。二"
"つ目の演算対象は -precision から precision までの範囲の整数でなければなりませ"
"ん。この二つ目の演算対象の絶対値が何桁ずらすかを決めます。そしてもし正の数な"
"らばシフトの方向は左に、そうでなければ右になります。一つ目の演算対象の係数は"
"必要ならば精度いっぱいまでゼロで埋められます。符号と指数は変えられません。"

#: ../../library/decimal.rst:857
msgid "Return the square root of the argument to full precision."
msgstr "引数の平方根を最大精度で求めます。"

#: ../../library/decimal.rst:862 ../../library/decimal.rst:1441
msgid ""
"Convert to a string, using engineering notation if an exponent is needed."
msgstr "文字列に変換します。指数が必要なら工学表記が使われます。"

#: ../../library/decimal.rst:864 ../../library/decimal.rst:1443
msgid ""
"Engineering notation has an exponent which is a multiple of 3.  This can "
"leave up to 3 digits to the left of the decimal place and may require the "
"addition of either one or two trailing zeros."
msgstr ""
"工学表記法では指数は 3 の倍数になります。これにより、基数の小数部には最大で "
"3 桁までの数字が残されるとともに、末尾に 1 つまたは 2 つの 0 の付加が必要とさ"
"れるかもしれません。"

#: ../../library/decimal.rst:868
msgid ""
"For example, this converts ``Decimal('123E+1')`` to ``Decimal('1.23E+3')``."
msgstr ""
"たとえば、``Decimal('123E+1')`` は ``Decimal('1.23E+3')`` に変換されます。"

#: ../../library/decimal.rst:872
msgid ""
"Identical to the :meth:`to_integral_value` method.  The ``to_integral`` name "
"has been kept for compatibility with older versions."
msgstr ""
":meth:`to_integral_value` メソッドと同じです。``to_integral`` の名前は古い"
"バージョンとの互換性のために残されています。"

#: ../../library/decimal.rst:877
msgid ""
"Round to the nearest integer, signaling :const:`Inexact` or :const:`Rounded` "
"as appropriate if rounding occurs.  The rounding mode is determined by the "
"``rounding`` parameter if given, else by the given ``context``.  If neither "
"parameter is given then the rounding mode of the current context is used."
msgstr ""
"最近傍の整数に値を丸め、丸めが起こった場合には :const:`Inexact` または :"
"const:`Rounded` のシグナルを適切に出します。丸めモードは以下のように決められ"
"ます。 ``rounding`` 引数が与えられていればそれが使われます。そうでなければ "
"``context`` 引数で決まります。どちらの引数も渡されなければ現在のスレッドのコ"
"ンテキストの丸めモードが使われます。"

#: ../../library/decimal.rst:885
msgid ""
"Round to the nearest integer without signaling :const:`Inexact` or :const:"
"`Rounded`.  If given, applies *rounding*; otherwise, uses the rounding "
"method in either the supplied *context* or the current context."
msgstr ""
":const:`Inexact` や :const:`Rounded` といったシグナルを出さずに最近傍の整数に"
"値を丸めます。 *rounding* が指定されていれば適用されます; それ以外の場合、値"
"丸めの方法は *context* の設定か現在のコンテキストの設定になります。"

#: ../../library/decimal.rst:893
msgid "Logical operands"
msgstr "論理引数"

#: ../../library/decimal.rst:895
msgid ""
"The :meth:`logical_and`, :meth:`logical_invert`, :meth:`logical_or`, and :"
"meth:`logical_xor` methods expect their arguments to be *logical operands*.  "
"A *logical operand* is a :class:`Decimal` instance whose exponent and sign "
"are both zero, and whose digits are all either :const:`0` or :const:`1`."
msgstr ""
":meth:`logical_and`, :meth:`logical_invert`, :meth:`logical_or`, および :"
"meth:`logical_xor` メソッドはその引数が *論理引数* であると想定しています。 *"
"論理引数* とは :class:`Decimal` インスタンスで指数と符号は共にゼロであり、各"
"桁の数字が :const:`0` か :const:`1` であるものです。"

#: ../../library/decimal.rst:907
msgid "Context objects"
msgstr "Context オブジェクト"

#: ../../library/decimal.rst:909
msgid ""
"Contexts are environments for arithmetic operations.  They govern precision, "
"set rules for rounding, determine which signals are treated as exceptions, "
"and limit the range for exponents."
msgstr ""
"コンテキスト (context) とは、算術演算における環境設定です。コンテキストは計算"
"精度を決定し、値丸めの方法を設定し、シグナルのどれが例外になるかを決め、指数"
"の範囲を制限しています。"

#: ../../library/decimal.rst:913
msgid ""
"Each thread has its own current context which is accessed or changed using "
"the :func:`getcontext` and :func:`setcontext` functions:"
msgstr ""
"多重スレッドで処理を行う場合には各スレッドごとに現在のコンテキストがあり、 :"
"func:`getcontext` や :func:`setcontext` といった関数でアクセスしたり設定変更"
"できます:"

#: ../../library/decimal.rst:919
msgid "Return the current context for the active thread."
msgstr "アクティブなスレッドの現在のコンテキストを返します。"

#: ../../library/decimal.rst:924
msgid "Set the current context for the active thread to *c*."
msgstr "アクティブなスレッドのコンテキストを *c* に設定します。"

#: ../../library/decimal.rst:926
msgid ""
"You can also use the :keyword:`with` statement and the :func:`localcontext` "
"function to temporarily change the active context."
msgstr ""
":keyword:`with` 文と :func:`localcontext` 関数を使って実行するコンテキストを"
"一時的に変更することもできます。"

#: ../../library/decimal.rst:931
msgid ""
"Return a context manager that will set the current context for the active "
"thread to a copy of *ctx* on entry to the with-statement and restore the "
"previous context when exiting the with-statement. If no context is "
"specified, a copy of the current context is used."
msgstr ""
"with 文の入口でアクティブなスレッドのコンテキストを *ctx* のコピーに設定し、"
"with 文を抜ける時に元のコンテキストに復旧する、コンテキストマネージャを返しま"
"す。コンテキストが指定されなければ、現在のコンテキストのコピーが使われます。"

#: ../../library/decimal.rst:936
msgid ""
"For example, the following code sets the current decimal precision to 42 "
"places, performs a calculation, and then automatically restores the previous "
"context::"
msgstr ""
"たとえば、以下のコードでは精度を42桁に設定し、計算を実行し、そして元のコンテ"
"キストに復帰します::"

#: ../../library/decimal.rst:946
msgid ""
"New contexts can also be created using the :class:`Context` constructor "
"described below. In addition, the module provides three pre-made contexts:"
msgstr ""
"新たなコンテキストは、以下で説明する :class:`Context` コンストラクタを使って"
"生成できます。その他にも、 :mod:`decimal` モジュールでは作成済みのコンテキス"
"トを提供しています:"

#: ../../library/decimal.rst:952
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_UP`.  All flags are cleared.  All traps are enabled (treated as "
"exceptions) except :const:`Inexact`, :const:`Rounded`, and :const:"
"`Subnormal`."
msgstr ""
"汎用十進演算仕様で定義されている標準コンテキストの一つです。精度は 9 桁に設定"
"されています。丸め規則は :const:`ROUND_HALF_UP` です。すべての演算結果フラグ"
"はクリアされています。 :const:`Inexact`, :const:`Rounded`, :const:"
"`Subnormal` を除く全ての演算エラートラップが有効 (例外として扱う) になってい"
"ます。"

#: ../../library/decimal.rst:958
msgid ""
"Because many of the traps are enabled, this context is useful for debugging."
msgstr ""
"多くのトラップが有効になっているので、デバッグの際に便利なコンテキストです。"

#: ../../library/decimal.rst:963
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_EVEN`.  All flags are cleared.  No traps are enabled (so that "
"exceptions are not raised during computations)."
msgstr ""
"汎用十進演算仕様で定義されている標準コンテキストの一つです。精度は 9 桁に設定"
"されています。丸め規則は :const:`ROUND_HALF_EVEN` です。すべての演算結果フラ"
"グはクリアされています。トラップは全て無効(演算中に一切例外を送出しない) に"
"なっています。"

#: ../../library/decimal.rst:968
msgid ""
"Because the traps are disabled, this context is useful for applications that "
"prefer to have result value of :const:`NaN` or :const:`Infinity` instead of "
"raising exceptions.  This allows an application to complete a run in the "
"presence of conditions that would otherwise halt the program."
msgstr ""
"トラップが無効になっているので、エラーの伴う演算結果を :const:`NaN` や :"
"const:`Infinity` にし、例外を送出しないようにしたいアプリケーションに向いたコ"
"ンテキストです。このコンテキストを使うと、他の場合にはプログラムが停止してし"
"まうような状況があっても実行を完了させられます。"

#: ../../library/decimal.rst:976
msgid ""
"This context is used by the :class:`Context` constructor as a prototype for "
"new contexts.  Changing a field (such a precision) has the effect of "
"changing the default for new contexts created by the :class:`Context` "
"constructor."
msgstr ""
":class:`Context` コンストラクタが新たなコンテキストを作成するさいに雛形にする"
"コンテキストです。このコンテキストのフィールド (精度の設定など) を変更する"
"と、 :class:`Context` コンストラクタが生成する新たなコンテキストに影響を及ぼ"
"します。"

#: ../../library/decimal.rst:980
msgid ""
"This context is most useful in multi-threaded environments.  Changing one of "
"the fields before threads are started has the effect of setting system-wide "
"defaults.  Changing the fields after threads have started is not recommended "
"as it would require thread synchronization to prevent race conditions."
msgstr ""
"このコンテキストは、主に多重スレッド環境で便利です。スレッドを開始する前に何"
"らかのフィールドを変更しておくと、システム全体のデフォルト設定に効果を及ぼす"
"ことができます。スレッドを開始した後にフィールドを変更すると、競合条件を抑制"
"するためにスレッドを同期化しなければならないので、推奨しません。"

#: ../../library/decimal.rst:985
msgid ""
"In single threaded environments, it is preferable to not use this context at "
"all.  Instead, simply create contexts explicitly as described below."
msgstr ""
"単一スレッドの環境では、このコンテキストを使わないよう薦めます。下で述べるよ"
"うに明示的にコンテキストを作成してください。"

#: ../../library/decimal.rst:988
msgid ""
"The default values are :attr:`prec`\\ =\\ :const:`28`, :attr:`rounding`\\ "
"=\\ :const:`ROUND_HALF_EVEN`, and enabled traps for :class:`Overflow`, :"
"class:`InvalidOperation`, and :class:`DivisionByZero`."
msgstr ""
"デフォルトの値は、 :attr:`prec`\\ =\\ :const:`28`, :attr:`rounding`\\ =\\ :"
"const:`ROUND_HALF_EVEN` で、トラップ :class:`Overflow`, :class:"
"`InvalidOperation`, および :class:`DivisionByZero` が有効になっています。"

#: ../../library/decimal.rst:993
msgid ""
"In addition to the three supplied contexts, new contexts can be created with "
"the :class:`Context` constructor."
msgstr ""
"上に挙げた三つのコンテキストに加え、 :class:`Context` コンストラクタを使って"
"新たなコンテキストを生成できます。"

#: ../../library/decimal.rst:999
msgid ""
"Creates a new context.  If a field is not specified or is :const:`None`, the "
"default values are copied from the :const:`DefaultContext`.  If the *flags* "
"field is not specified or is :const:`None`, all flags are cleared."
msgstr ""
"新たなコンテキストを生成します。あるフィールドが定義されていないか :const:"
"`None` であれば、 :const:`DefaultContext` からデフォルト値をコピーします。 "
"*flags* フィールドが設定されていいか :const:`None` の場合には、全てのフラグが"
"クリアされます。"

#: ../../library/decimal.rst:1003
msgid ""
"*prec* is an integer in the range [:const:`1`, :const:`MAX_PREC`] that sets "
"the precision for arithmetic operations in the context."
msgstr ""
"*prec* フィールドは範囲 [:const:`1`, :const:`MAX_PREC`] 内の整数で、コンテキ"
"ストにおける算術演算の計算精度を設定します。"

#: ../../library/decimal.rst:1006
msgid ""
"The *rounding* option is one of the constants listed in the section "
"`Rounding Modes`_."
msgstr "*rounding* オプションは、節 `丸めモード`_ で挙げられる定数の一つです。"

#: ../../library/decimal.rst:1009
msgid ""
"The *traps* and *flags* fields list any signals to be set. Generally, new "
"contexts should only set traps and leave the flags clear."
msgstr ""
"*traps* および *flags* フィールドには、セットしたいシグナルを列挙します。一般"
"的に、新たなコンテキストを作成するときにはトラップだけを設定し、フラグはクリ"
"アしておきます。"

#: ../../library/decimal.rst:1012
msgid ""
"The *Emin* and *Emax* fields are integers specifying the outer limits "
"allowable for exponents. *Emin* must be in the range [:const:`MIN_EMIN`, :"
"const:`0`], *Emax* in the range [:const:`0`, :const:`MAX_EMAX`]."
msgstr ""
"*Emin* および *Emax* フィールドは、許容する指数の外限を指定する整数です。 "
"*Emin* は範囲 [:const:`MIN_EMIN`, :const:`0`] 内で、 *Emax* は範囲 [:const:"
"`0`, :const:`MAX_EMAX`] 内でなければなりません。"

#: ../../library/decimal.rst:1016
msgid ""
"The *capitals* field is either :const:`0` or :const:`1` (the default). If "
"set to :const:`1`, exponents are printed with a capital :const:`E`; "
"otherwise, a lowercase :const:`e` is used: :const:`Decimal('6.02e+23')`."
msgstr ""
"*capitals* フィールドは :const:`0` または :const:`1` (デフォルト) にしま"
"す。 :const:`1` に設定すると、指数記号を大文字 :const:`E` で出力します。それ"
"以外の場合には :const:`Decimal('6.02e+23')` のように :const:`e` を使います。"

#: ../../library/decimal.rst:1020
msgid ""
"The *clamp* field is either :const:`0` (the default) or :const:`1`. If set "
"to :const:`1`, the exponent ``e`` of a :class:`Decimal` instance "
"representable in this context is strictly limited to the range ``Emin - prec "
"+ 1 <= e <= Emax - prec + 1``.  If *clamp* is :const:`0` then a weaker "
"condition holds: the adjusted exponent of the :class:`Decimal` instance is "
"at most ``Emax``.  When *clamp* is :const:`1`, a large normal number will, "
"where possible, have its exponent reduced and a corresponding number of "
"zeros added to its coefficient, in order to fit the exponent constraints; "
"this preserves the value of the number but loses information about "
"significant trailing zeros.  For example::"
msgstr ""
"*clamp* フィールドは、 :const:`0` (デフォルト) または :const:`1` です。 :"
"const:`1` に設定されると、このコンテキストにおける :class:`Decimal` インスタ"
"ンスの指数 ``e`` は厳密に範囲 ``Emin - prec + 1 <= e <= Emax - prec + 1`` に"
"制限されます。 *clamp* が :const:`0` なら、それより弱い条件が支配します: 調整"
"された :class:`Decimal` インスタンスの指数は最大で ``Emax`` です。 *clamp* "
"が :const:`1` なら、大きな正規数は、可能なら、指数が減らされ、対応する数の 0 "
"が係数に加えられ、指数の制約に合わせられます; これは数の値を保存しますが、有"
"効な末尾の 0 に関する情報を失います。例えば::"

#: ../../library/decimal.rst:1035
msgid ""
"A *clamp* value of :const:`1` allows compatibility with the fixed-width "
"decimal interchange formats specified in IEEE 754."
msgstr ""
"*clamp* の値 :const:`1` は、IEEE 754 で規定された固定幅十進交換形式と互換にで"
"きます。"

#: ../../library/decimal.rst:1038
msgid ""
"The :class:`Context` class defines several general purpose methods as well "
"as a large number of methods for doing arithmetic directly in a given "
"context. In addition, for each of the :class:`Decimal` methods described "
"above (with the exception of the :meth:`adjusted` and :meth:`as_tuple` "
"methods) there is a corresponding :class:`Context` method.  For example, for "
"a :class:`Context` instance ``C`` and :class:`Decimal` instance ``x``, ``C."
"exp(x)`` is equivalent to ``x.exp(context=C)``.  Each :class:`Context` "
"method accepts a Python integer (an instance of :class:`int`) anywhere that "
"a Decimal instance is accepted."
msgstr ""
":class:`Context` クラスでは、いくつかの汎用のメソッドの他、現在のコンテキスト"
"で算術演算を直接行うためのメソッドを数多く定義しています。加えて、 :class:"
"`Decimal` の各メソッドについて(:meth:`adjusted` および :meth:`as_tuple` メ"
"ソッドを例外として)対応する :class:`Context` のメソッドが存在します。たとえ"
"ば、 :class:`Context` インスタンス  ``C`` と :class:`Decimal` インスタンス "
"``x`` に対して、 ``C.exp(x)`` は ``x.exp(context=C)`` と等価です。それぞれ"
"の :class:`Context` メソッドは、Decimal インスタンスが受け付けられるところな"
"らどこでも、Python の整数 (:class:`int` のインスタンス) を受け付けます。"

#: ../../library/decimal.rst:1051
msgid "Resets all of the flags to :const:`0`."
msgstr "フラグを全て :const:`0` にリセットします。"

#: ../../library/decimal.rst:1055
msgid "Resets all of the traps to :const:`0`."
msgstr "トラップを全て :const:`0` にリセットします。"

#: ../../library/decimal.rst:1061
msgid "Return a duplicate of the context."
msgstr "コンテキストの複製を返します。"

#: ../../library/decimal.rst:1065
msgid "Return a copy of the Decimal instance num."
msgstr "Decimal インスタンス num のコピーを返します。"

#: ../../library/decimal.rst:1069
msgid ""
"Creates a new Decimal instance from *num* but using *self* as context. "
"Unlike the :class:`Decimal` constructor, the context precision, rounding "
"method, flags, and traps are applied to the conversion."
msgstr ""
"*self* をコンテキストとする新たな Decimal インスタンスを *num* から生成しま"
"す。 :class:`Decimal` コンストラクタと違い、数値を変換する際にコンテキストの"
"精度、値丸め方法、フラグ、トラップを適用します。"

#: ../../library/decimal.rst:1073
msgid ""
"This is useful because constants are often given to a greater precision than "
"is needed by the application.  Another benefit is that rounding immediately "
"eliminates unintended effects from digits beyond the current precision. In "
"the following example, using unrounded inputs means that adding zero to a "
"sum can change the result:"
msgstr ""
"定数値はしばしばアプリケーションの要求よりも高い精度を持っているため、このメ"
"ソッドが役に立ちます。また、値丸めを即座に行うため、例えば以下のように、入力"
"値に値丸めを行わないために合計値にゼロの加算を追加するだけで結果が変わってし"
"まうといった、現在の精度よりも細かい値の影響が紛れ込む問題を防げるという恩恵"
"もあります。以下の例は、丸められていない入力を使うということは和にゼロを加え"
"ると結果が変わり得るという見本です:"

#: ../../library/decimal.rst:1087
msgid ""
"This method implements the to-number operation of the IBM specification. If "
"the argument is a string, no leading or trailing whitespace or underscores "
"are permitted."
msgstr ""
"このメソッドは IBM 仕様の to-number 演算を実装したものです。引数が文字列の場"
"合、前や後ろに余計な空白を付けたり、アンダースコアを含めたりすることは許され"
"ません。"

#: ../../library/decimal.rst:1093
msgid ""
"Creates a new Decimal instance from a float *f* but rounding using *self* as "
"the context.  Unlike the :meth:`Decimal.from_float` class method, the "
"context precision, rounding method, flags, and traps are applied to the "
"conversion."
msgstr ""
"浮動小数点数 *f* から新しい Decimal インスタンスを生成しますが、 *self* をコ"
"ンテキストとして丸めます。 :meth:`Decimal.from_float` クラスメソッドとは違"
"い、変換にコンテキストの精度、丸めメソッド、フラグ、そしてトラップが適用され"
"ます。"

#: ../../library/decimal.rst:1113
msgid ""
"Returns a value equal to ``Emin - prec + 1`` which is the minimum exponent "
"value for subnormal results.  When underflow occurs, the exponent is set to :"
"const:`Etiny`."
msgstr ""
"``Emin - prec + 1`` に等しい値を返します。演算結果の劣化が起こる桁の最小値で"
"す。アンダーフローが起きた場合、指数は :const:`Etiny` に設定されます。"

#: ../../library/decimal.rst:1119
msgid "Returns a value equal to ``Emax - prec + 1``."
msgstr "``Emax - prec + 1`` に等しい値を返します。"

#: ../../library/decimal.rst:1121
msgid ""
"The usual approach to working with decimals is to create :class:`Decimal` "
"instances and then apply arithmetic operations which take place within the "
"current context for the active thread.  An alternative approach is to use "
"context methods for calculating within a specific context.  The methods are "
"similar to those for the :class:`Decimal` class and are only briefly "
"recounted here."
msgstr ""
":class:`Decimal` を使った処理を行う場合、通常は :class:`Decimal` インスタンス"
"を生成して、算術演算を適用するというアプローチをとります。演算はアクティブな"
"スレッドにおける現在のコンテキストの下で行われます。もう一つのアプローチは、"
"コンテキストのメソッドを使った特定のコンテキスト下での計算です。コンテキスト"
"のメソッドは :class:`Decimal` クラスのメソッドに似ているので、ここでは簡単な"
"説明にとどめます。"

#: ../../library/decimal.rst:1131
msgid "Returns the absolute value of *x*."
msgstr "*x* の絶対値を返します。"

#: ../../library/decimal.rst:1136
msgid "Return the sum of *x* and *y*."
msgstr "*x* と *y* の和を返します。"

#: ../../library/decimal.rst:1141
msgid "Returns the same Decimal object *x*."
msgstr "同じ Decimal オブジェクト *x* を返します。"

#: ../../library/decimal.rst:1146
msgid "Compares *x* and *y* numerically."
msgstr "*x* と *y* を数値として比較します。"

#: ../../library/decimal.rst:1151
msgid "Compares the values of the two operands numerically."
msgstr "二つの演算対象の値を数値として比較します。"

#: ../../library/decimal.rst:1156
msgid "Compares two operands using their abstract representation."
msgstr "二つの演算対象を抽象的な表現を使って比較します。"

#: ../../library/decimal.rst:1161
msgid ""
"Compares two operands using their abstract representation, ignoring sign."
msgstr "二つの演算対象を抽象的な表現を使い符号を無視して比較します。"

#: ../../library/decimal.rst:1166
msgid "Returns a copy of *x* with the sign set to 0."
msgstr "*x* のコピーの符号を 0 にセットして返します。"

#: ../../library/decimal.rst:1171
msgid "Returns a copy of *x* with the sign inverted."
msgstr "*x* のコピーの符号を反転して返します。"

#: ../../library/decimal.rst:1176
msgid "Copies the sign from *y* to *x*."
msgstr "*y* から *x* に符号をコピーします。"

#: ../../library/decimal.rst:1181
msgid "Return *x* divided by *y*."
msgstr "*x* を *y* で除算した値を返します。"

#: ../../library/decimal.rst:1186
msgid "Return *x* divided by *y*, truncated to an integer."
msgstr "*x* を *y* で除算した値を整数に切り捨てて返します。"

#: ../../library/decimal.rst:1191
msgid "Divides two numbers and returns the integer part of the result."
msgstr "二つの数値間の除算を行い、結果の整数部を返します。"

#: ../../library/decimal.rst:1196
msgid "Returns ``e ** x``."
msgstr ""

#: ../../library/decimal.rst:1201
msgid "Returns *x* multiplied by *y*, plus *z*."
msgstr "*x* を *y* 倍したものに *z* を加えて返します。"

#: ../../library/decimal.rst:1206
msgid "Returns ``True`` if *x* is canonical; otherwise returns ``False``."
msgstr ""
"*x* が標準的(canonical)ならば ``True`` を返します。そうでなければ ``False`` "
"です。"

#: ../../library/decimal.rst:1211
msgid "Returns ``True`` if *x* is finite; otherwise returns ``False``."
msgstr "*x* が有限ならば ``True`` を返します。そうでなければ ``False`` です。"

#: ../../library/decimal.rst:1216
msgid "Returns ``True`` if *x* is infinite; otherwise returns ``False``."
msgstr "*x* が無限ならば ``True`` を返します。そうでなければ ``False`` です。"

#: ../../library/decimal.rst:1221
msgid "Returns ``True`` if *x* is a qNaN or sNaN; otherwise returns ``False``."
msgstr ""
"*x* が qNaN か sNaN であれば ``True`` を返します。そうでなければ ``False`` で"
"す。"

#: ../../library/decimal.rst:1226
msgid ""
"Returns ``True`` if *x* is a normal number; otherwise returns ``False``."
msgstr ""
"*x* が通常の数ならば ``True`` を返します。そうでなければ ``False`` です。"

#: ../../library/decimal.rst:1231
msgid "Returns ``True`` if *x* is a quiet NaN; otherwise returns ``False``."
msgstr ""
"*x* が無言 NaN であれば ``True`` を返します。そうでなければ ``False`` です。"

#: ../../library/decimal.rst:1236
msgid "Returns ``True`` if *x* is negative; otherwise returns ``False``."
msgstr ""
"*x* が負の数であれば ``True`` を返します。そうでなければ ``False`` です。"

#: ../../library/decimal.rst:1241
msgid ""
"Returns ``True`` if *x* is a signaling NaN; otherwise returns ``False``."
msgstr ""
"*x* が発信 NaN であれば ``True`` を返します。そうでなければ ``False`` です。"

#: ../../library/decimal.rst:1246
msgid "Returns ``True`` if *x* is subnormal; otherwise returns ``False``."
msgstr ""
"*x* が非正規数であれば ``True`` を返します。そうでなければ ``False`` です。"

#: ../../library/decimal.rst:1251
msgid "Returns ``True`` if *x* is a zero; otherwise returns ``False``."
msgstr ""
"*x* がゼロであれば ``True`` を返します。そうでなければ ``False`` です。"

#: ../../library/decimal.rst:1256
msgid "Returns the natural (base e) logarithm of *x*."
msgstr "*x* の自然対数(底 e の対数)を返します。"

#: ../../library/decimal.rst:1261
msgid "Returns the base 10 logarithm of *x*."
msgstr "*x* の底 10 の対数を返します。"

#: ../../library/decimal.rst:1266
msgid "Returns the exponent of the magnitude of the operand's MSD."
msgstr "演算対象の MSD の大きさの指数部を返します。"

#: ../../library/decimal.rst:1271
msgid "Applies the logical operation *and* between each operand's digits."
msgstr "それぞれの桁に論理演算 *and* を当てはめます。"

#: ../../library/decimal.rst:1276
msgid "Invert all the digits in *x*."
msgstr "*x* の全ての桁を反転させます。"

#: ../../library/decimal.rst:1281
msgid "Applies the logical operation *or* between each operand's digits."
msgstr "それぞれの桁に論理演算 *or* を当てはめます。"

#: ../../library/decimal.rst:1286
msgid "Applies the logical operation *xor* between each operand's digits."
msgstr "それぞれの桁に論理演算 *xor* を当てはめます。"

#: ../../library/decimal.rst:1291
msgid "Compares two values numerically and returns the maximum."
msgstr "二つの値を数値として比較し、大きいほうを返します。"

#: ../../library/decimal.rst:1296 ../../library/decimal.rst:1306
msgid "Compares the values numerically with their sign ignored."
msgstr "値を符号を無視して数値として比較します。"

#: ../../library/decimal.rst:1301
msgid "Compares two values numerically and returns the minimum."
msgstr "二つの値を数値として比較し、小さいほうを返します。"

#: ../../library/decimal.rst:1311
msgid "Minus corresponds to the unary prefix minus operator in Python."
msgstr "Python における単項マイナス演算子に対応する演算です。"

#: ../../library/decimal.rst:1316
msgid "Return the product of *x* and *y*."
msgstr "*x* と *y* の積を返します。"

#: ../../library/decimal.rst:1321
msgid "Returns the largest representable number smaller than *x*."
msgstr "*x* より小さい最大の表現可能な数を返します。"

#: ../../library/decimal.rst:1326
msgid "Returns the smallest representable number larger than *x*."
msgstr "*x* より大きい最小の表現可能な数を返します。"

#: ../../library/decimal.rst:1331
msgid "Returns the number closest to *x*, in direction towards *y*."
msgstr "*x* に *y* の方向に向かって最も近い数を返します。"

#: ../../library/decimal.rst:1336
msgid "Reduces *x* to its simplest form."
msgstr "*x* をもっとも単純な形にします。"

#: ../../library/decimal.rst:1341
msgid "Returns an indication of the class of *x*."
msgstr "*x* のクラスを指し示すものを返します。"

#: ../../library/decimal.rst:1346
msgid ""
"Plus corresponds to the unary prefix plus operator in Python.  This "
"operation applies the context precision and rounding, so it is *not* an "
"identity operation."
msgstr ""
"Python における単項のプラス演算子に対応する演算です。コンテキストにおける精度"
"や値丸めを適用するので、等値 (identity) 演算とは *違います*。"

#: ../../library/decimal.rst:1353
msgid "Return ``x`` to the power of ``y``, reduced modulo ``modulo`` if given."
msgstr ""
"``x`` の ``y`` 乗を計算します。``modulo`` が指定されていればモジュロを取りま"
"す。"

#: ../../library/decimal.rst:1355
msgid ""
"With two arguments, compute ``x**y``.  If ``x`` is negative then ``y`` must "
"be integral.  The result will be inexact unless ``y`` is integral and the "
"result is finite and can be expressed exactly in 'precision' digits. The "
"rounding mode of the context is used. Results are always correctly rounded "
"in the Python version."
msgstr ""

#: ../../library/decimal.rst:1361
msgid ""
"``Decimal(0) ** Decimal(0)`` results in ``InvalidOperation``, and if "
"``InvalidOperation`` is not trapped, then results in ``Decimal('NaN')``."
msgstr ""

#: ../../library/decimal.rst:1364
msgid ""
"The C module computes :meth:`power` in terms of the correctly rounded :meth:"
"`exp` and :meth:`ln` functions. The result is well-defined but only \"almost "
"always correctly rounded\"."
msgstr ""

#: ../../library/decimal.rst:1369
msgid ""
"With three arguments, compute ``(x**y) % modulo``.  For the three argument "
"form, the following restrictions on the arguments hold:"
msgstr ""
"引数が 3 つの場合、 ``(x**y) % modulo`` を計算します。この 3 引数の形式の場"
"合、引数には以下の制限が課せられます。"

#: ../../library/decimal.rst:1372
msgid "all three arguments must be integral"
msgstr "全ての引数は整数"

#: ../../library/decimal.rst:1373
msgid "``y`` must be nonnegative"
msgstr "``y`` は非負でなければならない"

#: ../../library/decimal.rst:1374
msgid "at least one of ``x`` or ``y`` must be nonzero"
msgstr "``x`` と ``y`` の少なくともどちらかはゼロでない"

#: ../../library/decimal.rst:1375
msgid "``modulo`` must be nonzero and have at most 'precision' digits"
msgstr "``modulo`` は非零で大きくても 'precision' 桁"

#: ../../library/decimal.rst:1377
msgid ""
"The value resulting from ``Context.power(x, y, modulo)`` is equal to the "
"value that would be obtained by computing ``(x**y) % modulo`` with unbounded "
"precision, but is computed more efficiently.  The exponent of the result is "
"zero, regardless of the exponents of ``x``, ``y`` and ``modulo``.  The "
"result is always exact."
msgstr ""
"``Context.power(x, y, modulo)`` で得られる値は ``(x**y) % modulo`` を精度無制"
"限で計算して得られるものと同じ値ですが、より効率的に計算されます。結果の指数"
"は ``x``, ``y``, ``modulo`` の指数に関係なくゼロです。この計算は常に正確で"
"す。"

#: ../../library/decimal.rst:1387
msgid "Returns a value equal to *x* (rounded), having the exponent of *y*."
msgstr "*x* に値丸めを適用し、指数を *y* にした値を返します。"

#: ../../library/decimal.rst:1392
msgid "Just returns 10, as this is Decimal, :)"
msgstr "単に 10 を返します。何せ十進ですから :)"

#: ../../library/decimal.rst:1397
msgid "Returns the remainder from integer division."
msgstr "整数除算の剰余を返します。"

#: ../../library/decimal.rst:1399
msgid ""
"The sign of the result, if non-zero, is the same as that of the original "
"dividend."
msgstr "剰余がゼロでない場合、符号は割られる数の符号と同じになります。"

#: ../../library/decimal.rst:1405
msgid ""
"Returns ``x - y * n``, where *n* is the integer nearest the exact value of "
"``x / y`` (if the result is 0 then its sign will be the sign of *x*)."
msgstr ""
"``x - y * n`` を返します。ここで *n* は ``x / y`` の正確な値に一番近い整数で"
"す (この結果が 0 ならばその符号は *x* の符号と同じです)。"

#: ../../library/decimal.rst:1411
msgid "Returns a rotated copy of *x*, *y* times."
msgstr "*x* の *y* 回巡回したコピーを返します。"

#: ../../library/decimal.rst:1416
msgid "Returns ``True`` if the two operands have the same exponent."
msgstr "2つの演算対象が同じ指数を持っている場合に ``True`` を返します。"

#: ../../library/decimal.rst:1421
msgid "Returns the first operand after adding the second value its exp."
msgstr "一つめの演算対象の指数部に二つめの値を加えたものを返します。"

#: ../../library/decimal.rst:1426
msgid "Returns a shifted copy of *x*, *y* times."
msgstr "*x* を *y* 回シフトしたコピーを返します。"

#: ../../library/decimal.rst:1431
msgid "Square root of a non-negative number to context precision."
msgstr "*x* の平方根を精度いっぱいまで求めます。"

#: ../../library/decimal.rst:1436
msgid "Return the difference between *x* and *y*."
msgstr "*x* と *y* の間の差を返します。"

#: ../../library/decimal.rst:1450
msgid "Rounds to an integer."
msgstr "最近傍の整数に値を丸めます。"

#: ../../library/decimal.rst:1455
msgid "Converts a number to a string using scientific notation."
msgstr "数値を科学表記で文字列に変換します。"

#: ../../library/decimal.rst:1462
msgid "Constants"
msgstr "定数"

#: ../../library/decimal.rst:1464
msgid ""
"The constants in this section are only relevant for the C module. They are "
"also included in the pure Python version for compatibility."
msgstr ""
"この節の定数は C モジュールにのみ意味があります。互換性のために、pure Python "
"版も含まれます。"

#: ../../library/decimal.rst:1468
msgid "32-bit"
msgstr "32-bit"

#: ../../library/decimal.rst:1468
msgid "64-bit"
msgstr "64-bit"

#: ../../library/decimal.rst:1470 ../../library/decimal.rst:1472
msgid ":const:`425000000`"
msgstr ":const:`425000000`"

#: ../../library/decimal.rst:1470 ../../library/decimal.rst:1472
msgid ":const:`999999999999999999`"
msgstr ":const:`999999999999999999`"

#: ../../library/decimal.rst:1474
msgid ":const:`-425000000`"
msgstr ":const:`-425000000`"

#: ../../library/decimal.rst:1474
msgid ":const:`-999999999999999999`"
msgstr ":const:`-999999999999999999`"

#: ../../library/decimal.rst:1476
msgid ":const:`-849999999`"
msgstr ":const:`-849999999`"

#: ../../library/decimal.rst:1476
msgid ":const:`-1999999999999999997`"
msgstr ":const:`-1999999999999999997`"

#: ../../library/decimal.rst:1482
msgid ""
"The value is ``True``.  Deprecated, because Python now always has threads."
msgstr ""
"値は ``True`` です。現在のPythonは常にスレッドを持っているので、非推奨になり"
"ました。"

#: ../../library/decimal.rst:1488
msgid ""
"The default value is ``True``. If Python is :option:`configured using the --"
"without-decimal-contextvar option <--without-decimal-contextvar>`, the C "
"version uses a thread-local rather than a coroutine-local context and the "
"value is ``False``.  This is slightly faster in some nested context "
"scenarios."
msgstr ""

#: ../../library/decimal.rst:1493
msgid "backported to 3.7 and 3.8."
msgstr "3.7 と 3.8 にバックポートされました。"

#: ../../library/decimal.rst:1497
msgid "Rounding modes"
msgstr "丸めモード"

#: ../../library/decimal.rst:1501
msgid "Round towards :const:`Infinity`."
msgstr ":const:`Infinity` 方向に丸めます。"

#: ../../library/decimal.rst:1505
msgid "Round towards zero."
msgstr "ゼロ方向に丸めます。"

#: ../../library/decimal.rst:1509
msgid "Round towards :const:`-Infinity`."
msgstr ":const:`-Infinity` 方向に丸めます。"

#: ../../library/decimal.rst:1513
msgid "Round to nearest with ties going towards zero."
msgstr "近い方に、引き分けはゼロ方向に向けて丸めます。"

#: ../../library/decimal.rst:1517
msgid "Round to nearest with ties going to nearest even integer."
msgstr "近い方に、引き分けは偶数整数方向に向けて丸めます。"

#: ../../library/decimal.rst:1521
msgid "Round to nearest with ties going away from zero."
msgstr "近い方に、引き分けはゼロから遠い方向に向けて丸めます。"

#: ../../library/decimal.rst:1525
msgid "Round away from zero."
msgstr "ゼロから遠い方向に丸めます。"

#: ../../library/decimal.rst:1529
msgid ""
"Round away from zero if last digit after rounding towards zero would have "
"been 0 or 5; otherwise round towards zero."
msgstr ""
"ゼロ方向に丸めた後の最後の桁が 0 または 5 ならばゼロから遠い方向に、そうでな"
"ければゼロ方向に丸めます。"

#: ../../library/decimal.rst:1536
msgid "Signals"
msgstr "シグナル"

#: ../../library/decimal.rst:1538
msgid ""
"Signals represent conditions that arise during computation. Each corresponds "
"to one context flag and one context trap enabler."
msgstr ""
"シグナルは、計算中に生じた様々なエラー条件を表現します。各々のシグナルは一つ"
"のコンテキストフラグと一つのトラップイネーブラに対応しています。"

#: ../../library/decimal.rst:1541
msgid ""
"The context flag is set whenever the condition is encountered. After the "
"computation, flags may be checked for informational purposes (for instance, "
"to determine whether a computation was exact). After checking the flags, be "
"sure to clear all flags before starting the next computation."
msgstr ""
"コンテキストフラグは、該当するエラー条件に遭遇するたびにセットされます。演算"
"後にフラグを調べれば、演算に関する情報 (例えば計算が厳密だったかどうか) がわ"
"かります。フラグを調べたら、次の計算を始める前にフラグを全てクリアするように"
"してください。"

#: ../../library/decimal.rst:1546
msgid ""
"If the context's trap enabler is set for the signal, then the condition "
"causes a Python exception to be raised.  For example, if the :class:"
"`DivisionByZero` trap is set, then a :exc:`DivisionByZero` exception is "
"raised upon encountering the condition."
msgstr ""
"あるコンテキストのトラップイネーブラがあるシグナルに対してセットされている場"
"合、該当するエラー条件が生じると Python の例外を送出します。例えば、 :class:"
"`DivisionByZero` が設定されていると、エラー条件が生じた際に :exc:"
"`DivisionByZero` 例外を送出します。"

#: ../../library/decimal.rst:1554
msgid "Altered an exponent to fit representation constraints."
msgstr "値の表現上の制限に沿わせるために指数部が変更されたことを通知します。"

#: ../../library/decimal.rst:1556
msgid ""
"Typically, clamping occurs when an exponent falls outside the context's :"
"attr:`Emin` and :attr:`Emax` limits.  If possible, the exponent is reduced "
"to fit by adding zeros to the coefficient."
msgstr ""
"通常、クランプ (clamp) は、指数部がコンテキストにおける指数桁の制限値 :attr:"
"`Emin` および :attr:`Emax` を越えた場合に発生します。可能な場合には、係数部に"
"ゼロを加えた表現に合わせて指数部を減らします。"

#: ../../library/decimal.rst:1563
msgid "Base class for other signals and a subclass of :exc:`ArithmeticError`."
msgstr "他のシグナルの基底クラスで、 :exc:`ArithmeticError` のサブクラスです。"

#: ../../library/decimal.rst:1568
msgid "Signals the division of a non-infinite number by zero."
msgstr "有限値をゼロで除算したときのシグナルです。"

#: ../../library/decimal.rst:1570
msgid ""
"Can occur with division, modulo division, or when raising a number to a "
"negative power.  If this signal is not trapped, returns :const:`Infinity` "
"or :const:`-Infinity` with the sign determined by the inputs to the "
"calculation."
msgstr ""
"除算やモジュロ除算、数を負の値で累乗した場合に起きることがあります。このシグ"
"ナルをトラップしない場合、演算結果は :const:`Infinity` または :const:`-"
"Infinity` になり、その符号は演算に使った入力に基づいて決まります。"

#: ../../library/decimal.rst:1577
msgid "Indicates that rounding occurred and the result is not exact."
msgstr "値の丸めによって演算結果から厳密さが失われたことを通知します。"

#: ../../library/decimal.rst:1579
msgid ""
"Signals when non-zero digits were discarded during rounding. The rounded "
"result is returned.  The signal flag or trap is used to detect when results "
"are inexact."
msgstr ""
"このシグナルは値丸め操作中にゼロでない桁を無視した際に生じます。演算結果は値"
"丸め後の値です。シグナルのフラグやトラップは、演算結果の厳密さが失われたこと"
"を検出するために使えるだけです。"

#: ../../library/decimal.rst:1586
msgid "An invalid operation was performed."
msgstr "無効な演算が実行されたことを通知します。"

#: ../../library/decimal.rst:1588
msgid ""
"Indicates that an operation was requested that does not make sense. If not "
"trapped, returns :const:`NaN`.  Possible causes include::"
msgstr ""
"ユーザが有意な演算結果にならないような操作を要求したことを示します。このシグ"
"ナルをトラップしない場合、 :const:`NaN` を返します。このシグナルの発生原因と"
"して考えられるのは、以下のような状況です::"

#: ../../library/decimal.rst:1604
msgid "Numerical overflow."
msgstr "数値オーバフローを示すシグナルです。"

#: ../../library/decimal.rst:1606
msgid ""
"Indicates the exponent is larger than :attr:`Emax` after rounding has "
"occurred.  If not trapped, the result depends on the rounding mode, either "
"pulling inward to the largest representable finite number or rounding "
"outward to :const:`Infinity`.  In either case, :class:`Inexact` and :class:"
"`Rounded` are also signaled."
msgstr ""
"このシグナルは、値丸めを行った後の指数部が :attr:`Emax` より大きいことを示し"
"ます。シグナルをトラップしない場合、演算結果は値丸めのモードにより、表現可能"
"な最大の数値になるように内側へ引き込んで丸めを行った値か、 :const:`Infinity` "
"になるように外側に丸めた値のいずれかになります。いずれの場合も、 :class:"
"`Inexact` および :class:`Rounded` が同時にシグナルされます。"

#: ../../library/decimal.rst:1615
msgid "Rounding occurred though possibly no information was lost."
msgstr "情報が全く失われていない場合も含み、値丸めが起きたときのシグナルです。"

#: ../../library/decimal.rst:1617
msgid ""
"Signaled whenever rounding discards digits; even if those digits are zero "
"(such as rounding :const:`5.00` to :const:`5.0`).  If not trapped, returns "
"the result unchanged.  This signal is used to detect loss of significant "
"digits."
msgstr ""
"このシグナルは、値丸めによって桁がなくなると常に発生します。なくなった桁がゼ"
"ロ (例えば :const:`5.00` を丸めて :const:`5.0` になった場合) であってもです。"
"このシグナルをトラップしなければ、演算結果をそのまま返します。このシグナルは"
"有効桁数の減少を検出する際に使います。"

#: ../../library/decimal.rst:1625
msgid "Exponent was lower than :attr:`Emin` prior to rounding."
msgstr ""
"値丸めを行う前に指数部が :attr:`Emin` より小さかったことを示すシグナルです。"

#: ../../library/decimal.rst:1627
msgid ""
"Occurs when an operation result is subnormal (the exponent is too small). If "
"not trapped, returns the result unchanged."
msgstr ""
"演算結果が微小である場合 (指数が小さすぎる場合) に発生します。このシグナルを"
"トラップしなければ、演算結果をそのまま返します。"

#: ../../library/decimal.rst:1633
msgid "Numerical underflow with result rounded to zero."
msgstr "演算結果が値丸めによってゼロになった場合に生じる数値アンダフローです。"

#: ../../library/decimal.rst:1635
msgid ""
"Occurs when a subnormal result is pushed to zero by rounding. :class:"
"`Inexact` and :class:`Subnormal` are also signaled."
msgstr ""
"演算結果が微小なため、値丸めによってゼロになった場合に発生します。 :class:"
"`Inexact` および :class:`Subnormal` シグナルも同時に発生します。"

#: ../../library/decimal.rst:1641
msgid "Enable stricter semantics for mixing floats and Decimals."
msgstr "float と Decimal の混合の厳密なセマンティクスを有効にします。"

#: ../../library/decimal.rst:1643
msgid ""
"If the signal is not trapped (default), mixing floats and Decimals is "
"permitted in the :class:`~decimal.Decimal` constructor, :meth:`~decimal."
"Context.create_decimal` and all comparison operators. Both conversion and "
"comparisons are exact. Any occurrence of a mixed operation is silently "
"recorded by setting :exc:`FloatOperation` in the context flags. Explicit "
"conversions with :meth:`~decimal.Decimal.from_float` or :meth:`~decimal."
"Context.create_decimal_from_float` do not set the flag."
msgstr ""
"シグナルがトラップされなかった場合 (デフォルト)、:class:`~decimal.Decimal` コ"
"ンストラクタ、 :meth:`~decimal.Context.create_decimal` 、およびすべての比較演"
"算子において float と Decimal の混合が許されます。変換も比較も正確です。コン"
"テキストフラグ内に :exc:`FloatOperation` を設定することで、混合操作は現れるた"
"びに暗黙に記録されます。 :meth:`~decimal.Decimal.from_float` や :meth:"
"`~decimal.Context.create_decimal_from_float` による明示的な変換はフラグを設定"
"しません。"

#: ../../library/decimal.rst:1651
msgid ""
"Otherwise (the signal is trapped), only equality comparisons and explicit "
"conversions are silent. All other mixed operations raise :exc:"
"`FloatOperation`."
msgstr ""
"そうでなければ (シグナルがトラップされれば)、等価性比較および明示的な変換のみ"
"が静かにに行われ、その他の混合演算は :exc:`FloatOperation` を送出します。"

#: ../../library/decimal.rst:1655
msgid "The following table summarizes the hierarchy of signals::"
msgstr "これらのシグナルの階層構造をまとめると、以下の表のようになります::"

#: ../../library/decimal.rst:1676
msgid "Floating Point Notes"
msgstr "浮動小数点数に関する注意"

#: ../../library/decimal.rst:1680
msgid "Mitigating round-off error with increased precision"
msgstr "精度を上げて丸め誤差を抑制する"

#: ../../library/decimal.rst:1682
msgid ""
"The use of decimal floating point eliminates decimal representation error "
"(making it possible to represent :const:`0.1` exactly); however, some "
"operations can still incur round-off error when non-zero digits exceed the "
"fixed precision."
msgstr ""
"十進浮動小数点数を使うと、十進数表現による誤差を抑制できます (:const:`0.1` を"
"正確に表現できるようになります); しかし、ゼロでない桁が一定の精度を越えている"
"場合には、演算によっては依然として値丸めによる誤差を引き起こします。"

#: ../../library/decimal.rst:1686
msgid ""
"The effects of round-off error can be amplified by the addition or "
"subtraction of nearly offsetting quantities resulting in loss of "
"significance.  Knuth provides two instructive examples where rounded "
"floating point arithmetic with insufficient precision causes the breakdown "
"of the associative and distributive properties of addition:"
msgstr ""
"値丸めによる誤差の影響は、桁落ちを生じるような、ほとんど相殺される量での加算"
"や減算によって増幅されます。Knuth は、十分でない計算精度の下で値丸めを伴う浮"
"動小数点演算を行った結果、加算の結合則や分配則における恒等性が崩れてしまう例"
"を二つ示しています:"

#: ../../library/decimal.rst:1710
msgid ""
"The :mod:`decimal` module makes it possible to restore the identities by "
"expanding the precision sufficiently to avoid loss of significance:"
msgstr ""
":mod:`decimal` モジュールでは、最下桁を失わないように十分に計算精度を広げるこ"
"とで、上で問題にしたような恒等性をとりもどせます:"

#: ../../library/decimal.rst:1730
msgid "Special values"
msgstr "特殊値"

#: ../../library/decimal.rst:1732
msgid ""
"The number system for the :mod:`decimal` module provides special values "
"including :const:`NaN`, :const:`sNaN`, :const:`-Infinity`, :const:"
"`Infinity`, and two zeros, :const:`+0` and :const:`-0`."
msgstr ""
":mod:`decimal` モジュールの数体系では、 :const:`NaN`, :const:`sNaN`, :const:"
"`-Infinity`, :const:`Infinity`, および二つのゼロ、 :const:`+0` と :const:"
"`-0` といった特殊な値を提供しています。"

#: ../../library/decimal.rst:1736
msgid ""
"Infinities can be constructed directly with:  ``Decimal('Infinity')``. Also, "
"they can arise from dividing by zero when the :exc:`DivisionByZero` signal "
"is not trapped.  Likewise, when the :exc:`Overflow` signal is not trapped, "
"infinity can result from rounding beyond the limits of the largest "
"representable number."
msgstr ""
"無限大 (Infinity) は ``Decimal('Infinity')`` で直接構築できます。また、 :exc:"
"`DivisionByZero` をトラップせずにゼロで除算を行った場合にも出てきます。同様"
"に、 :exc:`Overflow` シグナルをトラップしなければ、表現可能な最大の数値の制限"
"を越えた値を丸めたときに出てきます。"

#: ../../library/decimal.rst:1741
msgid ""
"The infinities are signed (affine) and can be used in arithmetic operations "
"where they get treated as very large, indeterminate numbers.  For instance, "
"adding a constant to infinity gives another infinite result."
msgstr ""
"無限大には符号があり (アフィン: affine であり)、算術演算に使用でき、非常に巨"
"大で不確定の(indeterminate)値として扱われます。例えば、無限大に何らかの定数を"
"加算すると、演算結果は別の無限大になります。"

#: ../../library/decimal.rst:1745
msgid ""
"Some operations are indeterminate and return :const:`NaN`, or if the :exc:"
"`InvalidOperation` signal is trapped, raise an exception.  For example, "
"``0/0`` returns :const:`NaN` which means \"not a number\".  This variety of :"
"const:`NaN` is quiet and, once created, will flow through other computations "
"always resulting in another :const:`NaN`.  This behavior can be useful for a "
"series of computations that occasionally have missing inputs --- it allows "
"the calculation to proceed while flagging specific results as invalid."
msgstr ""
"演算によっては結果が不確定になるものがあり、 :const:`NaN` を返します。ただ"
"し、 :exc:`InvalidOperation` シグナルをトラップするようになっていれば例外を送"
"出します。例えば、 ``0/0`` は :const:`NaN` を返します。 :const:`NaN` は「非数"
"値 (not a number)」を表します。このような :const:`NaN` は暗黙のうちに生成さ"
"れ、一度生成されるとそれを他の計算にも流れてゆき、関係する個々の演算全てが個"
"別の :const:`NaN` を返すようになります。この挙動は、たまに入力値が欠けるよう"
"な状況で一連の計算を行う際に便利です --- 特定の計算に対しては無効な結果を示す"
"フラグを立てつつ計算を進められるからです。"

#: ../../library/decimal.rst:1753
msgid ""
"A variant is :const:`sNaN` which signals rather than remaining quiet after "
"every operation.  This is a useful return value when an invalid result needs "
"to interrupt a calculation for special handling."
msgstr ""
"一方、 :const:`NaN` の変種である :const:`sNaN` は関係する全ての演算で演算後に"
"シグナルを送出します。 :const:`sNaN` は、無効な演算結果に対して特別な処理を行"
"うために計算を停止する必要がある場合に便利です。"

#: ../../library/decimal.rst:1757
msgid ""
"The behavior of Python's comparison operators can be a little surprising "
"where a :const:`NaN` is involved.  A test for equality where one of the "
"operands is a quiet or signaling :const:`NaN` always returns :const:`False` "
"(even when doing ``Decimal('NaN')==Decimal('NaN')``), while a test for "
"inequality always returns :const:`True`.  An attempt to compare two Decimals "
"using any of the ``<``, ``<=``, ``>`` or ``>=`` operators will raise the :"
"exc:`InvalidOperation` signal if either operand is a :const:`NaN`, and "
"return :const:`False` if this signal is not trapped.  Note that the General "
"Decimal Arithmetic specification does not specify the behavior of direct "
"comparisons; these rules for comparisons involving a :const:`NaN` were taken "
"from the IEEE 854 standard (see Table 3 in section 5.7).  To ensure strict "
"standards-compliance, use the :meth:`compare` and :meth:`compare-signal` "
"methods instead."
msgstr ""
"Python の比較演算は :const:`NaN` が関わってくると少し驚くようなことがありま"
"す。等価性のテストの一方の対象が無言または発信 :const:`NaN` である場合いつで"
"も :const:`False` を返し(たとえ ``Decimal('NaN')==Decimal('NaN')`` でも)、一"
"方で不等価をテストするといつでも :const:`True` を返します。二つの Decimal を "
"``<``, ``<=``, ``>`` または ``>=`` を使って比較する試みは一方が :const:`NaN` "
"である場合には :exc:`InvalidOperation` シグナルを送出し、このシグナルをトラッ"
"プしなければ結果は :const:`False` に終わります。汎用十進演算仕様は直接の比較"
"の振る舞いについて定めていないことに注意しておきましょう。ここでの :const:"
"`NaN` が関係する比較ルールは IEEE 854 標準から持ってきました (section 5.7 の "
"Table 3 を見て下さい)。厳格に標準遵守を貫くなら、 :meth:`compare` および :"
"meth:`compare-signal` メソッドを代わりに使いましょう。"

#: ../../library/decimal.rst:1770
msgid ""
"The signed zeros can result from calculations that underflow. They keep the "
"sign that would have resulted if the calculation had been carried out to "
"greater precision.  Since their magnitude is zero, both positive and "
"negative zeros are treated as equal and their sign is informational."
msgstr ""
"アンダフローの起きた計算は、符号付きのゼロ (signed zero) を返すことがありま"
"す。符号は、より高い精度で計算を行った結果の符号と同じになります。符号付きゼ"
"ロの大きさはやはりゼロなので、正のゼロと負のゼロは等しいとみなされ、符号は単"
"なる参考にすぎません。"

#: ../../library/decimal.rst:1775
msgid ""
"In addition to the two signed zeros which are distinct yet equal, there are "
"various representations of zero with differing precisions yet equivalent in "
"value.  This takes a bit of getting used to.  For an eye accustomed to "
"normalized floating point representations, it is not immediately obvious "
"that the following calculation returns a value equal to zero:"
msgstr ""
"二つの符号付きゼロが区別されているのに等価であることに加えて、異なる精度にお"
"けるゼロの表現はまちまちなのに、値は等価とみなされるということがあります。こ"
"れに慣れるには多少時間がかかります。正規化浮動小数点表現に目が慣れてしまう"
"と、以下の計算でゼロに等しい値が返っているとは即座に分かりません:"

#: ../../library/decimal.rst:1790
msgid "Working with threads"
msgstr "スレッドを使った処理"

#: ../../library/decimal.rst:1792
msgid ""
"The :func:`getcontext` function accesses a different :class:`Context` object "
"for each thread.  Having separate thread contexts means that threads may "
"make changes (such as ``getcontext().prec=10``) without interfering with "
"other threads."
msgstr ""
"関数 :func:`getcontext` は、スレッド毎に別々の :class:`Context` オブジェクト"
"にアクセスします。別のスレッドコンテキストを持つということは、複数のスレッド"
"が互いに影響を及ぼさずに (``getcontext().prec=10`` のような) 変更を適用できる"
"ということです。"

#: ../../library/decimal.rst:1796
msgid ""
"Likewise, the :func:`setcontext` function automatically assigns its target "
"to the current thread."
msgstr ""
"同様に、:func:`setcontext` 関数は自動的に引数のコンテキストを現在のスレッドの"
"コンテキストに設定します。"

#: ../../library/decimal.rst:1799
msgid ""
"If :func:`setcontext` has not been called before :func:`getcontext`, then :"
"func:`getcontext` will automatically create a new context for use in the "
"current thread."
msgstr ""
":func:`getcontext` を呼び出す前に :func:`setcontext` が呼び出されていなけれ"
"ば、現在のスレッドで使うための新たなコンテキストを生成するために :func:"
"`getcontext` が自動的に呼び出されます。"

#: ../../library/decimal.rst:1803
msgid ""
"The new context is copied from a prototype context called *DefaultContext*. "
"To control the defaults so that each thread will use the same values "
"throughout the application, directly modify the *DefaultContext* object. "
"This should be done *before* any threads are started so that there won't be "
"a race condition between threads calling :func:`getcontext`. For example::"
msgstr ""
"新たなコンテキストは、*DefaultContext* と呼ばれる雛形からコピーされます。アプ"
"リケーションを通じて全てのスレッドに同じ値を使うようにデフォルトを設定したけ"
"れば、*DefaultContext* オブジェクトを直接変更します。 :func:`getcontext` を呼"
"び出すスレッド間で競合条件が生じないようにするため、*DefaultContext* への変更"
"はいかなるスレッドを開始するよりも *前に* 行わなければなりません。以下に例を"
"示します::"

#: ../../library/decimal.rst:1828
msgid "Recipes"
msgstr "レシピ"

#: ../../library/decimal.rst:1830
msgid ""
"Here are a few recipes that serve as utility functions and that demonstrate "
"ways to work with the :class:`Decimal` class::"
msgstr ""
":class:`Decimal` クラスの利用を実演している例をいくつか示します。これらはユー"
"ティリティ関数としても利用できます::"

#: ../../library/decimal.rst:1985
msgid "Decimal FAQ"
msgstr "Decimal FAQ"

#: ../../library/decimal.rst:1987
msgid ""
"Q. It is cumbersome to type ``decimal.Decimal('1234.5')``.  Is there a way "
"to minimize typing when using the interactive interpreter?"
msgstr ""
"Q. ``decimal.Decimal('1234.5')`` などと打ち込むのは煩わしいのですが、対話式イ"
"ンタプリタを使う際にタイプ量を少なくする方法はありませんか?"

#: ../../library/decimal.rst:1990
msgid "A. Some users abbreviate the constructor to just a single letter:"
msgstr "A. コンストラクタを1文字に縮める人もいるようです:"

#: ../../library/decimal.rst:1996
msgid ""
"Q. In a fixed-point application with two decimal places, some inputs have "
"many places and need to be rounded.  Others are not supposed to have excess "
"digits and need to be validated.  What methods should be used?"
msgstr ""
"Q. 小数点以下2桁の固定小数点数のアプリケーションの中で、いくつかの入力が余計"
"な桁を保持しているのでこれを丸めなければなりません。その他のものに余計な桁は"
"なくそのまま使えます。どのメソッドを使うのがいいでしょうか?"

#: ../../library/decimal.rst:2000
msgid ""
"A. The :meth:`quantize` method rounds to a fixed number of decimal places. "
"If the :const:`Inexact` trap is set, it is also useful for validation:"
msgstr ""
"A. :meth:`quantize` メソッドで固定した桁に丸められます。 :const:`Inexact` ト"
"ラップを設定しておけば、確認にも有用です:"

#: ../../library/decimal.rst:2018
msgid ""
"Q. Once I have valid two place inputs, how do I maintain that invariant "
"throughout an application?"
msgstr ""
"Q. 正当な2桁の入力が得られたとして、その正当性をアプリケーション実行中も変わ"
"らず保ち続けるにはどうすればいいでしょうか?"

#: ../../library/decimal.rst:2021
msgid ""
"A. Some operations like addition, subtraction, and multiplication by an "
"integer will automatically preserve fixed point.  Others operations, like "
"division and non-integer multiplication, will change the number of decimal "
"places and need to be followed-up with a :meth:`quantize` step:"
msgstr ""
"A. 加減算あるいは整数との乗算のような演算は自動的に固定小数点を守ります。その"
"他の除算や整数以外の乗算などは小数点以下の桁を変えてしまいますので実行後は :"
"meth:`quantize` ステップが必要です:"

#: ../../library/decimal.rst:2039
msgid ""
"In developing fixed-point applications, it is convenient to define functions "
"to handle the :meth:`quantize` step:"
msgstr ""
"固定小数点のアプリケーションを開発する際は、 :meth:`quantize` の段階を扱う関"
"数を定義しておくと便利です:"

#: ../../library/decimal.rst:2052
msgid ""
"Q. There are many ways to express the same value.  The numbers :const:"
"`200`, :const:`200.000`, :const:`2E2`, and :const:`.02E+4` all have the same "
"value at various precisions. Is there a way to transform them to a single "
"recognizable canonical value?"
msgstr ""
"Q. 一つの値に対して多くの表現方法があります。 :const:`200` と :const:"
"`200.000` と :const:`2E2` と :const:`.02E+4` は全て同じ値で違った精度の数で"
"す。これらをただ一つの正規化された値に変換することはできますか?"

#: ../../library/decimal.rst:2057
msgid ""
"A. The :meth:`normalize` method maps all equivalent values to a single "
"representative:"
msgstr ""
"A. :meth:`normalize` メソッドは全ての等しい値をただ一つの表現に直します:"

#: ../../library/decimal.rst:2064
msgid ""
"Q. Some decimal values always print with exponential notation.  Is there a "
"way to get a non-exponential representation?"
msgstr ""
"Q. ある種の十進数値はいつも指数表記で表示されます。指数表記以外の表示にする方"
"法はありますか?"

#: ../../library/decimal.rst:2067
msgid ""
"A. For some values, exponential notation is the only way to express the "
"number of significant places in the coefficient.  For example, expressing :"
"const:`5.0E+3` as :const:`5000` keeps the value constant but cannot show the "
"original's two-place significance."
msgstr ""
"A. 値によっては、指数表記だけが有効桁数を表せる表記法なのです。たとえば、 :"
"const:`5.0E+3` を :const:`5000` と表してしまうと、値は変わりませんが元々の2桁"
"という有効数字が反映されません。"

#: ../../library/decimal.rst:2072
msgid ""
"If an application does not care about tracking significance, it is easy to "
"remove the exponent and trailing zeroes, losing significance, but keeping "
"the value unchanged:"
msgstr ""
"もしアプリケーションが有効数字の追跡を等閑視するならば、指数部や末尾のゼロを"
"取り除き、有効数字を忘れ、しかし値を変えずにおくことは容易です:"

#: ../../library/decimal.rst:2082
msgid "Q. Is there a way to convert a regular float to a :class:`Decimal`?"
msgstr "Q. 普通の float を :class:`Decimal` に変換できますか?"

#: ../../library/decimal.rst:2084
msgid ""
"A. Yes, any binary floating point number can be exactly expressed as a "
"Decimal though an exact conversion may take more precision than intuition "
"would suggest:"
msgstr ""
"A. はい。どんな 2 進浮動小数点数も Decimal として正確に表現できます。ただし、"
"正確な変換は直感的に考えたよりも多い桁になることがあります:"

#: ../../library/decimal.rst:2093
msgid ""
"Q. Within a complex calculation, how can I make sure that I haven't gotten a "
"spurious result because of insufficient precision or rounding anomalies."
msgstr ""
"Q. 複雑な計算の中で、精度不足や丸めの異常で間違った結果になっていないことをど"
"うやって保証すれば良いでしょうか。"

#: ../../library/decimal.rst:2096
msgid ""
"A. The decimal module makes it easy to test results.  A best practice is to "
"re-run calculations using greater precision and with various rounding modes. "
"Widely differing results indicate insufficient precision, rounding mode "
"issues, ill-conditioned inputs, or a numerically unstable algorithm."
msgstr ""
"A. decimal モジュールでは検算は容易です。一番良い方法は、大きめの精度や様々な"
"丸めモードで再計算してみることです。大きく異なった結果が出てきたら、精度不足"
"や丸めの問題や悪条件の入力、または数値計算的に不安定なアルゴリズムを示唆して"
"います。"

#: ../../library/decimal.rst:2101
msgid ""
"Q. I noticed that context precision is applied to the results of operations "
"but not to the inputs.  Is there anything to watch out for when mixing "
"values of different precisions?"
msgstr ""
"Q. コンテキストの精度は計算結果には適用されていますが入力には適用されていない"
"ようです。様々に異なる精度の入力値を混ぜて計算する時に注意すべきことはありま"
"すか?"

#: ../../library/decimal.rst:2105
msgid ""
"A. Yes.  The principle is that all values are considered to be exact and so "
"is the arithmetic on those values.  Only the results are rounded.  The "
"advantage for inputs is that \"what you type is what you get\".  A "
"disadvantage is that the results can look odd if you forget that the inputs "
"haven't been rounded:"
msgstr ""
"A. はい。原則として入力値は正確であると見做しておりそれらの値を使った計算も同"
"様です。結果だけが丸められます。入力の強みは \"what you type is what you "
"get\" (打ち込んだ値が得られる値)という点にあります。入力が丸められないという"
"ことを忘れていると結果が奇妙に見えるというのは弱点です:"

#: ../../library/decimal.rst:2118
msgid ""
"The solution is either to increase precision or to force rounding of inputs "
"using the unary plus operation:"
msgstr ""
"解決策は、精度を増やすか、単項プラス演算子を使って入力の丸めを強制することで"
"す:"

#: ../../library/decimal.rst:2127
msgid ""
"Alternatively, inputs can be rounded upon creation using the :meth:`Context."
"create_decimal` method:"
msgstr ""
"もしくは、入力を :meth:`Context.create_decimal` を使って生成時に丸めてしまう"
"こともできます:"

#: ../../library/decimal.rst:2133
msgid "Q. Is the CPython implementation fast for large numbers?"
msgstr "Q. CPython 実装は大きな数に対しても速いでしょうか?"

#: ../../library/decimal.rst:2135
msgid ""
"A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of "
"the decimal module integrate the high speed `libmpdec <https://www.bytereef."
"org/mpdecimal/doc/libmpdec/index.html>`_ library for arbitrary precision "
"correctly rounded decimal floating point arithmetic [#]_. ``libmpdec`` uses "
"`Karatsuba multiplication <https://en.wikipedia.org/wiki/"
"Karatsuba_algorithm>`_ for medium-sized numbers and the `Number Theoretic "
"Transform <https://en.wikipedia.org/wiki/"
"Discrete_Fourier_transform_(general)#Number-theoretic_transform>`_ for very "
"large numbers."
msgstr ""

#: ../../library/decimal.rst:2145
msgid ""
"The context must be adapted for exact arbitrary precision arithmetic. :attr:"
"`Emin` and :attr:`Emax` should always be set to the maximum values, :attr:"
"`clamp` should always be 0 (the default).  Setting :attr:`prec` requires "
"some care."
msgstr ""

#: ../../library/decimal.rst:2149
msgid ""
"The easiest approach for trying out bignum arithmetic is to use the maximum "
"value for :attr:`prec` as well [#]_::"
msgstr ""

#: ../../library/decimal.rst:2158
msgid ""
"For inexact results, :attr:`MAX_PREC` is far too large on 64-bit platforms "
"and the available memory will be insufficient::"
msgstr ""

#: ../../library/decimal.rst:2166
msgid ""
"On systems with overallocation (e.g. Linux), a more sophisticated approach "
"is to adjust :attr:`prec` to the amount of available RAM.  Suppose that you "
"have 8GB of RAM and expect 10 simultaneous operands using a maximum of 500MB "
"each::"
msgstr ""

#: ../../library/decimal.rst:2190
msgid ""
"In general (and especially on systems without overallocation), it is "
"recommended to estimate even tighter bounds and set the :attr:`Inexact` trap "
"if all calculations are expected to be exact."
msgstr ""

#: ../../library/decimal.rst:2199
msgid ""
"This approach now works for all exact results except for non-integer powers."
msgstr ""
