# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2017-09-22 17:56+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/decimal.rst:3
msgid ":mod:`decimal` --- Decimal fixed point and floating point arithmetic"
msgstr ":mod:`decimal` --- 10é€²å›ºå®šåŠã³æµ®å‹•å°æ•°ç‚¹æ•°ã®ç®—è¡“æ¼”ç®—"

#: ../../library/decimal.rst:29
msgid ""
"The :mod:`decimal` module provides support for decimal floating point "
"arithmetic.  It offers several advantages over the :class:`float` datatype:"
msgstr ":mod:`decimal` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯10é€²ã®æµ®å‹•å°æ•°ç‚¹ç®—è¡“ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ :mod:`decimal` ã«ã¯ã€ :class:`float` ãƒ‡ãƒ¼ã‚¿å‹ã«æ¯”ã¹ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ãªåˆ©ç‚¹ãŒã‚ã‚Šã¾ã™:"

#: ../../library/decimal.rst:32
msgid ""
"Decimal \"is based on a floating-point model which was designed with people "
"in mind, and necessarily has a paramount guiding principle -- computers must"
" provide an arithmetic that works in the same way as the arithmetic that "
"people learn at school.\" -- excerpt from the decimal arithmetic "
"specification."
msgstr "Decimal ã€Œã¯äººã€…ã‚’å¿µé ­ã«ãƒ‡ã‚¶ã‚¤ãƒ³ã•ã‚ŒãŸæµ®å‹•å°æ•°ç‚¹ãƒ¢ãƒ‡ãƒ«ã‚’å…ƒã«ã—ã¦ãŠã‚Šã€å¿…ç„¶çš„ã«æœ€ã‚‚é‡è¦ãªæŒ‡é‡ãŒã‚ã‚Šã¾ã™ -- ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã¯äººã€…ãŒå­¦æ ¡ã§ç¿’ã£ãŸç®—è¡“ã¨åŒã˜ã‚ˆã†ã«å‹•ä½œã™ã‚‹ç®—è¡“ã‚’æä¾›ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€ -- 10é€²æ•°æ¼”ç®—ä»•æ§˜ã‚ˆã‚Šã€‚"

#: ../../library/decimal.rst:37
msgid ""
"Decimal numbers can be represented exactly.  In contrast, numbers like "
":const:`1.1` and :const:`2.2` do not have exact representations in binary "
"floating point.  End users typically would not expect ``1.1 + 2.2`` to "
"display as :const:`3.3000000000000003` as it does with binary floating "
"point."
msgstr "10é€²æ•°ã‚’æ­£ç¢ºã«è¡¨ç¾ã§ãã¾ã™ã€‚ :const:`1.1` ã‚„ :const:`2.2` ã®ã‚ˆã†ãªæ•°ã¯ã€2 é€²æ•°ã®æµ®å‹•å°æ•°ç‚¹å‹ã§ã¯æ­£ã—ãè¡¨ç¾ã§ãã¾ã›ã‚“ã€‚ã‚¨ãƒ³ãƒ‰ãƒ¦ãƒ¼ã‚¶ã¯æ™®é€šã€ 2 é€²æ•°ã«ãŠã‘ã‚‹ ``1.1 + 2.2`` ã®è¿‘ä¼¼å€¤ãŒ :const:`3.3000000000000003` ã ã‹ã‚‰ã¨ã„ã£ã¦ã€ãã®ã‚ˆã†ã«è¡¨ç¤ºã—ã¦ã»ã—ã„ã¨ã¯è€ƒãˆãªã„ã‚‚ã®ã§ã™ã€‚"

#: ../../library/decimal.rst:42
msgid ""
"The exactness carries over into arithmetic.  In decimal floating point, "
"``0.1 + 0.1 + 0.1 - 0.3`` is exactly equal to zero.  In binary floating "
"point, the result is :const:`5.5511151231257827e-017`.  While near to zero, "
"the differences prevent reliable equality testing and differences can "
"accumulate. For this reason, decimal is preferred in accounting applications"
" which have strict equality invariants."
msgstr "å€¤ã®æ­£ç¢ºã•ã¯ç®—è¡“ã«ã‚‚åŠã³ã¾ã™ã€‚10é€²ã®æµ®å‹•å°æ•°ç‚¹ã«ã‚ˆã‚‹è¨ˆç®—ã§ã¯ã€ ``0.1 + 0.1 + 0.1 - 0.3`` ã¯å³å¯†ã«ã‚¼ãƒ­ã«ç­‰ã—ããªã‚Šã¾ã™ã€‚ 2 é€²æµ®å‹•å°æ•°ç‚¹ã§ã¯ :const:`5.5511151231257827e-017` ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚ã‚¼ãƒ­ã«è¿‘ã„å€¤ã¨ã¯ã„ãˆã€ã“ã®èª¤å·®ã¯æ•°å€¤é–“ã®ç­‰ä¾¡æ€§ãƒ†ã‚¹ãƒˆã®ä¿¡é ¼æ€§ã‚’é˜»å®³ã—ã¾ã™ã€‚ã¾ãŸã€èª¤å·®ãŒè“„ç©ã•ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚ã“ã†ã—ãŸç†ç”±ã‹ã‚‰ã€æ•°å€¤é–“ã®ç­‰ä¾¡æ€§ã‚’å³ã—ãä¿ãŸãªã‘ã‚Œã°ãªã‚‰ãªã„ã‚ˆã†ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è€ƒãˆã‚‹ãªã‚‰ã€10é€²æ•°ã«ã‚ˆã‚‹æ•°å€¤è¡¨ç¾ãŒæœ›ã¾ã—ã„ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:49
msgid ""
"The decimal module incorporates a notion of significant places so that "
"``1.30 + 1.20`` is :const:`2.50`.  The trailing zero is kept to indicate "
"significance. This is the customary presentation for monetary applications. "
"For multiplication, the \"schoolbook\" approach uses all the figures in the "
"multiplicands.  For instance, ``1.3 * 1.2`` gives :const:`1.56` while ``1.30"
" * 1.20`` gives :const:`1.5600`."
msgstr ":mod:`decimal` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€æœ‰åŠ¹æ¡æ•°ã®è¡¨è¨˜ãŒå–ã‚Šå…¥ã‚Œã‚‰ã‚Œã¦ãŠã‚Šã€ä¾‹ãˆã° ``1.30 + 1.20`` ã¯ :const:`2.50` ã«ãªã‚Šã¾ã™ã€‚ã™ãªã‚ã¡ã€æœ«å°¾ã®ã‚¼ãƒ­ã¯æœ‰åŠ¹æ•°å­—ã‚’ç¤ºã™ãŸã‚ã«æ®‹ã•ã‚Œã¾ã™ã€‚ã“ã†ã—ãŸä»•æ§˜ã¯é€šè²¨è¨ˆç®—ã‚’è¡Œã†ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯æ…£ä¾‹ã§ã™ã€‚ä¹—ç®—ã®å ´åˆã€ã€Œæ•™ç§‘æ›¸çš„ãªã€ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã¯ã€ä¹—ç®—ã®è¢«æ¼”ç®—å­ã™ã¹ã¦ã®æ¡æ•°ã‚’ä½¿ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``1.3 * 1.2`` ã¯ :const:`1.56` ã«ãªã‚Šã€ ``1.30 * 1.20`` ã¯ :const:`1.5600` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:56
msgid ""
"Unlike hardware based binary floating point, the decimal module has a user "
"alterable precision (defaulting to 28 places) which can be as large as "
"needed for a given problem:"
msgstr "ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã«ã‚ˆã‚‹ 2 é€²æµ®å‹•å°æ•°ç‚¹è¡¨ç¾ã¨é•ã„ã€:mod:`decimal` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯è¨ˆç®—ç²¾åº¦ã‚’ãƒ¦ãƒ¼ã‚¶ãŒå¤‰æ›´ã§ãã¾ã™(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ 28 æ¡ã§ã™)ã€‚ã“ã®æ¡æ•°ã¯ã»ã¨ã‚“ã©ã®å•é¡Œè§£æ±ºã«ååˆ†ãªå¤§ãã•ã§ã™:"

#: ../../library/decimal.rst:68
msgid ""
"Both binary and decimal floating point are implemented in terms of published"
" standards.  While the built-in float type exposes only a modest portion of "
"its capabilities, the decimal module exposes all required parts of the "
"standard. When needed, the programmer has full control over rounding and "
"signal handling. This includes an option to enforce exact arithmetic by "
"using exceptions to block any inexact operations."
msgstr "2é€²ã¨10é€²ã®æµ®å‹•å°æ•°ç‚¹ã¯ã€ã„ãšã‚Œã‚‚åºƒãå…¬é–‹ã•ã‚Œã¦ã„ã‚‹æ¨™æº–ä»•æ§˜ã®ã‚‚ã¨ã«å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚çµ„ã¿è¾¼ã¿ã®æµ®å‹•å°æ•°ç‚¹å‹ã§ã¯ã€æ¨™æº–ä»•æ§˜ã§æå”±ã•ã‚Œã¦ã„ã‚‹æ©Ÿèƒ½ã®ã»ã‚“ã®ã•ã•ã‚„ã‹ãªéƒ¨åˆ†ã‚’åˆ©ç”¨ã§ãã‚‹ã«ã™ãã¾ã›ã‚“ãŒã€:mod:`decimal` ã§ã¯æ¨™æº–ä»•æ§˜ãŒè¦æ±‚ã—ã¦ã„ã‚‹å…¨ã¦ã®æ©Ÿèƒ½ã‚’åˆ©ç”¨ã§ãã¾ã™ã€‚å¿…è¦ã«å¿œã˜ã¦ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯å€¤ã®ä¸¸ã‚ã‚„ã‚·ã‚°ãƒŠãƒ«å‡¦ç†ã‚’å®Œå…¨ã«åˆ¶å¾¡ã§ãã¾ã™ã€‚ã“ã®ä¸­ã«ã¯å…¨ã¦ã®ä¸æ­£ç¢ºãªæ“ä½œã‚’ä¾‹å¤–ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦æ­£ç¢ºãªç®—è¡“ã‚’éµå®ˆã•ã›ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:75
msgid ""
"The decimal module was designed to support \"without prejudice, both exact "
"unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and "
"rounded floating-point arithmetic.\"  -- excerpt from the decimal arithmetic"
" specification."
msgstr "decimal ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€Œåè¦‹ãªãã€æ­£ç¢ºãªä¸¸ã‚ãªã—ã®åé€²ç®—è¡“(å›ºå®šå°æ•°ç‚¹ç®—è¡“ã¨å‘¼ã°ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚‹)ã¨ä¸¸ã‚ã‚ã‚Šã®æµ®å‹•å°æ•°ç‚¹æ•°ç®—è¡“ã€(10é€²æ•°æ¼”ç®—ä»•æ§˜ã‚ˆã‚Šå¼•ç”¨)ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ãƒ‡ã‚¶ã‚¤ãƒ³ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/decimal.rst:80
msgid ""
"The module design is centered around three concepts:  the decimal number, "
"the context for arithmetic, and signals."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€10é€²æ•°å‹ã€ç®—è¡“ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ (context for arithmetic)ã€ãã—ã¦ã‚·ã‚°ãƒŠãƒ« (signal) ã¨ã„ã†ä¸‰ã¤ã®æ¦‚å¿µã‚’ä¸­å¿ƒã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:83
msgid ""
"A decimal number is immutable.  It has a sign, coefficient digits, and an "
"exponent.  To preserve significance, the coefficient digits do not truncate "
"trailing zeros.  Decimals also include special values such as "
":const:`Infinity`, :const:`-Infinity`, and :const:`NaN`.  The standard also "
"differentiates :const:`-0` from :const:`+0`."
msgstr "10é€²æ•°å‹ã¯å¤‰æ›´ä¸å¯èƒ½ãªå‹ã§ã™ã€‚ã“ã‚Œã¯ç¬¦å·ã€ä¿‚æ•°éƒ¨ã€ãã—ã¦æŒ‡æ•°ã‚’æŒã¡ã¾ã™ã€‚æœ‰åŠ¹æ¡æ•°ã‚’æ®‹ã™ãŸã‚ã«ã€ä»®æ•°éƒ¨ã®æœ«å°¾ã«ã‚ã‚‹ã‚¼ãƒ­ã¯åˆ‡ã‚Šè©°ã‚ã‚‰ã‚Œã¾ã›ã‚“ã€‚ :mod:`decimal` ã§ã¯ã€ :const:`Infinity`, :const:`-Infinity`, ãŠã‚ˆã³ :const:`NaN` ã¨ã„ã£ãŸç‰¹æ®Šãªå€¤ã‚‚å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚æ¨™æº–ä»•æ§˜ã§ã¯ :const:`-0` ã¨ :const:`+0` ã‚‚åŒºåˆ¥ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:89
msgid ""
"The context for arithmetic is an environment specifying precision, rounding "
"rules, limits on exponents, flags indicating the results of operations, and "
"trap enablers which determine whether signals are treated as exceptions.  "
"Rounding options include :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, "
":const:`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, "
":const:`ROUND_HALF_UP`, :const:`ROUND_UP`, and :const:`ROUND_05UP`."
msgstr "ç®—è¡“ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨ã¯ã€ç²¾åº¦ã‚„å€¤ä¸¸ã‚ã®è¦å‰‡ã€æŒ‡æ•°éƒ¨ã®åˆ¶é™ã‚’æ±ºã‚ã¦ã„ã‚‹ç’°å¢ƒã§ã™ã€‚ã“ã®ç’°å¢ƒã§ã¯ã€æ¼”ç®—çµæœã‚’è¡¨ã™ãŸã‚ã®ãƒ•ãƒ©ã‚°ã‚„ã€æ¼”ç®—ä¸Šç™ºç”Ÿã—ãŸç‰¹å®šã®ã‚·ã‚°ãƒŠãƒ«ã‚’ä¾‹å¤–ã¨ã—ã¦æ‰±ã†ã‹ã©ã†ã‹ã‚’æ±ºã‚ã‚‹ãƒˆãƒ©ãƒƒãƒ—ã‚¤ãƒãƒ¼ãƒ–ãƒ©ã‚‚å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ä¸¸ã‚è¦å‰‡ã«ã¯ :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:`ROUND_HALF_UP`, :const:`ROUND_UP`, ãŠã‚ˆã³ :const:`ROUND_05UP` ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:96
msgid ""
"Signals are groups of exceptional conditions arising during the course of "
"computation.  Depending on the needs of the application, signals may be "
"ignored, considered as informational, or treated as exceptions. The signals "
"in the decimal module are: :const:`Clamped`, :const:`InvalidOperation`, "
":const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, "
":const:`Subnormal`, :const:`Overflow`, and :const:`Underflow`."
msgstr "ã‚·ã‚°ãƒŠãƒ«ã¨ã¯ã€æ¼”ç®—ã®éç¨‹ã§ç”Ÿã˜ã‚‹ä¾‹å¤–çš„æ¡ä»¶ã§ã™ã€‚å€‹ã€…ã®ã‚·ã‚°ãƒŠãƒ«ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãã‚Œãã‚Œã®è¦æ±‚ã«å¾“ã£ã¦ã€ç„¡è¦–ã•ã‚ŒãŸã‚Šã€å˜ãªã‚‹æƒ…å ±ã¨ã¿ãªã•ã‚ŒãŸã‚Šã€ä¾‹å¤–ã¨ã—ã¦æ‰±ã‚ã‚ŒãŸã‚Šã—ã¾ã™ã€‚ :mod:`decimal` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã€ :const:`Clamped`, :const:`InvalidOperation`, :const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:`Subnormal`, :const:`Overflow`, :const:`Underflow` ã¨ã„ã£ãŸã‚·ã‚°ãƒŠãƒ«ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:103
msgid ""
"For each signal there is a flag and a trap enabler.  When a signal is "
"encountered, its flag is set to one, then, if the trap enabler is set to "
"one, an exception is raised.  Flags are sticky, so the user needs to reset "
"them before monitoring a calculation."
msgstr "å„ã‚·ã‚°ãƒŠãƒ«ã«ã¯ã€ãƒ•ãƒ©ã‚°ã¨ãƒˆãƒ©ãƒƒãƒ—ã‚¤ãƒãƒ¼ãƒ–ãƒ©ãŒã‚ã‚Šã¾ã™ã€‚æ¼”ç®—ä¸Šä½•ã‚‰ã‹ã®ã‚·ã‚°ãƒŠãƒ«ã«é­é‡ã™ã‚‹ã¨ã€ãƒ•ãƒ©ã‚°ã¯ 1 ã«ã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚ã“ã®ã¨ãã€ã‚‚ã—ãƒˆãƒ©ãƒƒãƒ—ã‚¤ãƒãƒ¼ãƒ–ãƒ©ãŒ 1 ã«ã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã‚Œã°ã€ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚ãƒ•ãƒ©ã‚°ã®å€¤ã¯è† ç€å‹ (sticky) ãªã®ã§ã€æ¼”ç®—ã«ã‚ˆã‚‹ãƒ•ãƒ©ã‚°ã®å¤‰åŒ–ã‚’ãƒ¢ãƒ‹ã‚¿ã—ãŸã‘ã‚Œã°ã€äºˆã‚ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ãŠã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/decimal.rst:111
msgid ""
"IBM's General Decimal Arithmetic Specification, `The General Decimal "
"Arithmetic Specification <http://speleotrove.com/decimal/>`_."
msgstr "IBM ã«ã‚ˆã‚‹æ±ç”¨10é€²æ¼”ç®—ä»•æ§˜ã€ `The General Decimal Arithmetic Specification <http://speleotrove.com/decimal/>`_ ã€‚"

#: ../../library/decimal.rst:120
msgid "Quick-start Tutorial"
msgstr "ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«"

#: ../../library/decimal.rst:122
msgid ""
"The usual start to using decimals is importing the module, viewing the "
"current context with :func:`getcontext` and, if necessary, setting new "
"values for precision, rounding, or enabled traps::"
msgstr "æ™®é€šã€ :mod:`decimal` ã‚’ä½¿ã†ã¨ãã«ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ import ã—ã€ç¾åœ¨ã®æ¼”ç®—ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ :func:`getcontext` ã§èª¿ã¹ã€å¿…è¦ãªã‚‰ã€ç²¾åº¦ã€ä¸¸ã‚ã€æœ‰åŠ¹ãªãƒˆãƒ©ãƒƒãƒ—ã‚’è¨­å®šã—ã¾ã™::"

#: ../../library/decimal.rst:134
msgid ""
"Decimal instances can be constructed from integers, strings, floats, or "
"tuples. Construction from an integer or a float performs an exact conversion"
" of the value of that integer or float.  Decimal numbers include special "
"values such as :const:`NaN` which stands for \"Not a number\", positive and "
"negative :const:`Infinity`, and :const:`-0`."
msgstr ":class:`Decimal` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€æ•´æ•°ã€æ–‡å­—åˆ—ã€æµ®å‹•å°æ•°ç‚¹æ•°ã€ã¾ãŸã¯ã‚¿ãƒ—ãƒ«ã‹ã‚‰æ§‹æˆã§ãã¾ã™ã€‚æ•´æ•°ã‚„æµ®å‹•å°æ•°ç‚¹æ•°ã‹ã‚‰ã®æ§‹æˆã¯ã€æ•´æ•°ã‚„æµ®å‹•å°æ•°ç‚¹æ•°ã®å€¤ã‚’æ­£ç¢ºã«å¤‰æ›ã—ã¾ã™ã€‚ :class:`Decimal` ã¯ \"æ•°å€¤ã§ã¯ãªã„ (Not a Number)\" ã‚’è¡¨ã™ :const:`NaN` ã‚„æ­£è² ã® :const:`Infinity` (ç„¡é™å¤§)ã€ :const:`-0` ã¨ã„ã£ãŸç‰¹æ®Šãªå€¤ã‚‚è¡¨ç¾ã§ãã¾ã™::"

#: ../../library/decimal.rst:158
msgid ""
"The significance of a new Decimal is determined solely by the number of "
"digits input.  Context precision and rounding only come into play during "
"arithmetic operations."
msgstr "æ–°ãŸãª :class:`Decimal` ã®æœ‰åŠ¹æ¡æ•°ã¯å…¥åŠ›ã®æ¡æ•°ã ã‘ã§æ±ºã¾ã‚Šã¾ã™ã€‚æ¼”ç®—ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ãŠã‘ã‚‹ç²¾åº¦ã‚„å€¤ä¸¸ã‚ã®è¨­å®šãŒå½±éŸ¿ã™ã‚‹ã®ã¯ç®—è¡“æ¼”ç®—ã®é–“ã ã‘ã§ã™ã€‚"

#: ../../library/decimal.rst:175
msgid ""
"Decimals interact well with much of the rest of Python.  Here is a small "
"decimal floating point flying circus:"
msgstr "decimal ã¯ã»ã¨ã‚“ã©ã®å ´é¢ã§ Python ã®ä»–ã®æ©Ÿèƒ½ã¨ã†ã¾ãã‚„ã‚Šã¨ã‚Šã§ãã¾ã™ã€‚decimal æµ®å‹•å°æ•°ç‚¹å°åŠ‡å ´ (flying circus) ã‚’ãŠè¦‹ã›ã—ã¾ã—ã‚‡ã†:"

#: ../../library/decimal.rst:207
msgid "And some mathematical functions are also available to Decimal:"
msgstr "ã„ãã¤ã‹ã®æ•°å­¦çš„é–¢æ•°ã‚‚ Decimal ã«ã¯ç”¨æ„ã•ã‚Œã¦ã„ã¾ã™:"

#: ../../library/decimal.rst:219
msgid ""
"The :meth:`quantize` method rounds a number to a fixed exponent.  This "
"method is useful for monetary applications that often round results to a "
"fixed number of places:"
msgstr ":meth:`quantize` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä½ã‚’å›ºå®šã—ã¦æ•°å€¤ã‚’ä¸¸ã‚ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€çµæœã‚’å›ºå®šã®æ¡æ•°ã§ä¸¸ã‚ã‚‹ã“ã¨ãŒã‚ˆãã‚ã‚‹ã€é‡‘èã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ä¾¿åˆ©ã§ã™:"

#: ../../library/decimal.rst:228
msgid ""
"As shown above, the :func:`getcontext` function accesses the current context"
" and allows the settings to be changed.  This approach meets the needs of "
"most applications."
msgstr "å‰è¿°ã®ã‚ˆã†ã«ã€ :func:`getcontext` é–¢æ•°ã‚’ä½¿ã†ã¨ç¾åœ¨ã®æ¼”ç®—ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã€è¨­å®šã‚’å¤‰æ›´ã§ãã¾ã™ã€‚ã»ã¨ã‚“ã©ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ååˆ†ã§ã™ã€‚"

#: ../../library/decimal.rst:232
msgid ""
"For more advanced work, it may be useful to create alternate contexts using "
"the Context() constructor.  To make an alternate active, use the "
":func:`setcontext` function."
msgstr "ã‚ˆã‚Šé«˜åº¦ãªä½œæ¥­ã‚’è¡Œã†å ´åˆã€ :func:`Context` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½¿ã£ã¦åˆ¥ã®æ¼”ç®—ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œã£ã¦ãŠãã¨ä¾¿åˆ©ãªã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚åˆ¥ã®æ¼”ç®—ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ãŸã‘ã‚Œã°ã€ :func:`setcontext` ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:236
msgid ""
"In accordance with the standard, the :mod:`decimal` module provides two "
"ready to use standard contexts, :const:`BasicContext` and "
":const:`ExtendedContext`. The former is especially useful for debugging "
"because many of the traps are enabled:"
msgstr ":mod:`decimal` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€æ¨™æº–ä»•æ§˜ã«å¾“ã£ã¦ã€ã™ãåˆ©ç”¨ã§ãã‚‹äºŒã¤ã®æ¨™æº–ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã€ :const:`BasicContext` ãŠã‚ˆã³ :const:`ExtendedContext` ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚å‰è€…ã¯ã»ã¨ã‚“ã©ã®ãƒˆãƒ©ãƒƒãƒ—ãŒæœ‰åŠ¹ã«ãªã£ã¦ãŠã‚Šã€ã¨ã‚Šã‚ã‘ãƒ‡ãƒãƒƒã‚°ã®éš›ã«ä¾¿åˆ©ã§ã™:"

#: ../../library/decimal.rst:265
msgid ""
"Contexts also have signal flags for monitoring exceptional conditions "
"encountered during computations.  The flags remain set until explicitly "
"cleared, so it is best to clear the flags before each set of monitored "
"computations by using the :meth:`clear_flags` method. ::"
msgstr "æ¼”ç®—ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ã¯ã€æ¼”ç®—ä¸­ã«é­é‡ã—ãŸä¾‹å¤–çš„çŠ¶æ³ã‚’ãƒ¢ãƒ‹ã‚¿ã™ã‚‹ãŸã‚ã®ã‚·ã‚°ãƒŠãƒ«ãƒ•ãƒ©ã‚°ãŒã‚ã‚Šã¾ã™ã€‚ãƒ•ãƒ©ã‚°ãŒä¸€åº¦ã‚»ãƒƒãƒˆã•ã‚Œã‚‹ã¨ã€æ˜ç¤ºçš„ã«ã‚¯ãƒªã‚¢ã™ã‚‹ã¾ã§æ®‹ã‚Šç¶šã‘ã¾ã™ã€‚ãã®ãŸã‚ã€ãƒ•ãƒ©ã‚°ã®ãƒ¢ãƒ‹ã‚¿ã‚’è¡Œã„ãŸã„ã‚ˆã†ãªæ¼”ç®—ã®å‰ã«ã¯ :meth:`clear_flags` ãƒ¡ã‚½ãƒƒãƒ‰ã§ãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¦ãŠãã®ãŒãƒ™ã‚¹ãƒˆã§ã™ã€‚ ::"

#: ../../library/decimal.rst:278
msgid ""
"The *flags* entry shows that the rational approximation to :const:`Pi` was "
"rounded (digits beyond the context precision were thrown away) and that the "
"result is inexact (some of the discarded digits were non-zero)."
msgstr "*flags* ã‚¨ãƒ³ãƒˆãƒªã‹ã‚‰ã€ :const:`Pi` ã®æœ‰ç†æ•°ã«ã‚ˆã‚‹è¿‘ä¼¼å€¤ãŒä¸¸ã‚ã‚‰ã‚ŒãŸ (ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå†…ã§æ±ºã‚ã‚‰ã‚ŒãŸç²¾åº¦ã‚’è¶…ãˆãŸæ¡æ•°ãŒæ¨ã¦ã‚‰ã‚ŒãŸ) ã“ã¨ã¨ã€è¨ˆç®—çµæœãŒå³å¯†ã§ãªã„ (ç„¡è¦–ã•ã‚ŒãŸæ¡ã®å€¤ã«éã‚¼ãƒ­ã®ã‚‚ã®ãŒã‚ã£ãŸ) ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:282
msgid ""
"Individual traps are set using the dictionary in the :attr:`traps` field of "
"a context:"
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã® :attr:`traps` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å…¥ã£ã¦ã„ã‚‹è¾æ›¸ã‚’ä½¿ã†ã¨ã€å€‹ã€…ã®ãƒˆãƒ©ãƒƒãƒ—ã‚’ã‚»ãƒƒãƒˆã§ãã¾ã™:"

#: ../../library/decimal.rst:297
msgid ""
"Most programs adjust the current context only once, at the beginning of the "
"program.  And, in many applications, data is converted to :class:`Decimal` "
"with a single cast inside a loop.  With context set and decimals created, "
"the bulk of the program manipulates the data no differently than with other "
"Python numeric types."
msgstr "ã»ã¨ã‚“ã©ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã€é–‹å§‹æ™‚ã«ä¸€åº¦ã ã‘ç¾åœ¨ã®æ¼”ç®—ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿®æ­£ã—ã¾ã™ã€‚ã¾ãŸã€å¤šãã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ :class:`Decimal` ã¸ã®å¤‰æ›ã¯ãƒ«ãƒ¼ãƒ—å†…ã§ä¸€åº¦ã ã‘ã‚­ãƒ£ã‚¹ãƒˆã—ã¦è¡Œã„ã¾ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¨­å®šã—ã€ :class:`Decimal` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã§ããŸã‚‰ã€ã»ã¨ã‚“ã©ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ä»–ã® Python æ•°å€¤å‹ã¨å…¨ãå¤‰ã‚ã‚‰ãªã„ã‹ã®ã‚ˆã†ã« :class:`Decimal` ã‚’æ“ä½œã§ãã¾ã™ã€‚"

#: ../../library/decimal.rst:309
msgid "Decimal objects"
msgstr "Decimal ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/decimal.rst:314
msgid "Construct a new :class:`Decimal` object based from *value*."
msgstr "*value* ã«åŸºã¥ã„ã¦æ–°ãŸãª :class:`Decimal` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:316
msgid ""
"*value* can be an integer, string, tuple, :class:`float`, or another "
":class:`Decimal` object. If no *value* is given, returns ``Decimal('0')``.  "
"If *value* is a string, it should conform to the decimal numeric string "
"syntax after leading and trailing whitespace characters are removed::"
msgstr "*value* ã¯æ•´æ•°ã€æ–‡å­—åˆ—ã€ã‚¿ãƒ—ãƒ«ã€ :class:`float` ãŠã‚ˆã³ä»–ã® :class:`Decimal` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã§ãã¾ã™ã€‚ *value* ã‚’æŒ‡å®šã—ãªã„å ´åˆã€ ``Decimal('0')`` ã‚’è¿”ã—ã¾ã™ã€‚ *value* ãŒæ–‡å­—åˆ—ã®å ´åˆã€å…ˆé ­ã¨æœ«å°¾ã®ç©ºç™½ã‚’å–ã‚Šé™¤ã„ãŸå¾Œã«ã¯ä»¥ä¸‹ã® 10é€²æ•°æ–‡å­—åˆ—ã®æ–‡æ³•ã«å¾“ã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“::"

#: ../../library/decimal.rst:332
msgid ""
"If *value* is a unicode string then other Unicode decimal digits are also "
"permitted where ``digit`` appears above.  These include decimal digits from "
"various other alphabets (for example, Arabic-Indic and DevanÄgarÄ« digits) "
"along with the fullwidth digits ``u'\\uff10'`` through ``u'\\uff19'``."
msgstr "*value* ã‚’ Unicode æ–‡å­—åˆ—ã«ã—ãŸå ´åˆã€ä»–ã® Unicode æ•°å­—ã‚‚ä¸Šã® ``digit`` ã®å ´æ‰€ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ã¤ã¾ã‚Šå„æ›¸è¨˜ä½“ç³»ã«ãŠã‘ã‚‹ (ã‚¢ãƒ©ãƒ“ã‚¢-ã‚¤ãƒ³ãƒ‰ç³»ã‚„ãƒ‡ãƒ¼ãƒ´ã‚¡ãƒŠãƒ¼ã‚¬ãƒªãƒ¼ãªã©) ã®æ•°å­—ã‚„ã€å…¨è§’æ•°å­—ï¼ (``u'\\uff10'``) ã‹ã‚‰ï¼™ (``u'\\uff19'``) ã¾ã§ãªã©ã§ã™ã€‚"

#: ../../library/decimal.rst:338
msgid ""
"If *value* is a :class:`tuple`, it should have three components, a sign "
"(:const:`0` for positive or :const:`1` for negative), a :class:`tuple` of "
"digits, and an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), "
"-3))`` returns ``Decimal('1.414')``."
msgstr "*value* ã‚’ :class:`tuple` ã«ã™ã‚‹å ´åˆã€ã‚¿ãƒ—ãƒ«ã¯ä¸‰ã¤ã®è¦ç´ ã‚’æŒã¡ã€ãã‚Œãã‚Œç¬¦å· (æ­£ãªã‚‰ :const:`0` ã€è² ãªã‚‰ :const:`1`)ã€ä»®æ•°éƒ¨ã‚’è¡¨ã™æ•°å­—ã® :class:`tuple` ã€ãã—ã¦æŒ‡æ•°ã‚’è¡¨ã™æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ ``Decimal((0, (1, 4, 1, 4), -3))`` ã¯ ``Decimal('1.414')`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:343
msgid ""
"If *value* is a :class:`float`, the binary floating point value is "
"losslessly converted to its exact decimal equivalent.  This conversion can "
"often require 53 or more digits of precision.  For example, "
"``Decimal(float('1.1'))`` converts to "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."
msgstr "*value* ã‚’ :class:`float` ã«ã™ã‚‹å ´åˆã€2é€²æµ®å‹•å°æ•°ç‚¹æ•°å€¤ãŒæå¤±ãªãæ­£ç¢ºã«ç­‰ä¾¡ãª Decimal ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚ã“ã®å¤‰æ›ã¯ã—ã°ã—ã° 53 æ¡ä»¥ä¸Šã®ç²¾åº¦ã‚’è¦æ±‚ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``Decimal(float('1.1'))`` ã¯ ``Decimal('1.100000000000000088817841970012523233890533447265625')`` ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:349
msgid ""
"The *context* precision does not affect how many digits are stored. That is "
"determined exclusively by the number of digits in *value*. For example, "
"``Decimal('3.00000')`` records all five zeros even if the context precision "
"is only three."
msgstr "*context* ã®ç²¾åº¦ (precision) ã¯ã€è¨˜æ†¶ã•ã‚Œã‚‹æ¡æ•°ã«ã¯å½±éŸ¿ã—ã¾ã›ã‚“ã€‚æ¡æ•°ã¯ *value* ã«æŒ‡å®šã—ãŸæ¡æ•°ã ã‘ã‹ã‚‰æ±ºå®šã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€æ¼”ç®—ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«æŒ‡å®šã•ã‚ŒãŸç²¾åº¦ãŒ 3 æ¡ã—ã‹ãªãã¦ã‚‚ã€``Decimal('3.00000')`` ã¯ 5 ã¤ã®ã‚¼ãƒ­ã‚’å…¨ã¦è¨˜æ†¶ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:354
msgid ""
"The purpose of the *context* argument is determining what to do if *value* "
"is a malformed string.  If the context traps :const:`InvalidOperation`, an "
"exception is raised; otherwise, the constructor returns a new Decimal with "
"the value of :const:`NaN`."
msgstr "*context* å¼•æ•°ã®ç›®çš„ã¯ã€ *value* ãŒæ­£ã—ããªã„å½¢å¼ã®æ–‡å­—åˆ—ã§ã‚ã£ãŸå ´åˆã«è¡Œã†å‡¦ç†ã‚’æ±ºã‚ã‚‹ã“ã¨ã«ã‚ã‚Šã¾ã™; æ¼”ç®—ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒ :const:`InvalidOperation` ã‚’ãƒˆãƒ©ãƒƒãƒ—ã™ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚Œã°ã€ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯å€¤ãŒ :const:`NaN` ã® :class:`Decimal` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:359
msgid "Once constructed, :class:`Decimal` objects are immutable."
msgstr "ä¸€åº¦ç”Ÿæˆã™ã‚‹ã¨ã€ :class:`Decimal` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤‰æ›´ä¸èƒ½ (immutable) ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:361
msgid ""
"leading and trailing whitespace characters are permitted when creating a "
"Decimal instance from a string."
msgstr "æ–‡å­—åˆ—ã‹ã‚‰ Decimal ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹éš›ã«å…ˆé ­ã¨æœ«å°¾ã®ç©ºç™½ãŒè¨±ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/decimal.rst:365
msgid ""
"The argument to the constructor is now permitted to be a :class:`float` "
"instance."
msgstr "ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«å¯¾ã™ã‚‹å¼•æ•°ã« :class:`float` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚‚è¨±ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/decimal.rst:368
msgid ""
"Decimal floating point objects share many properties with the other built-in"
" numeric types such as :class:`float` and :class:`int`.  All of the usual "
"math operations and special methods apply.  Likewise, decimal objects can be"
" copied, pickled, printed, used as dictionary keys, used as set elements, "
"compared, sorted, and coerced to another type (such as :class:`float` or "
":class:`long`)."
msgstr "10é€²æµ®å‹•å°æ•°ç‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ :class:`float` ã‚„ :class:`int` ã®ã‚ˆã†ãªä»–ã®çµ„ã¿è¾¼ã¿å‹ã¨å¤šãã®ç‚¹ã§ä¼¼ã¦ã„ã¾ã™ã€‚é€šå¸¸ã®æ•°å­¦æ¼”ç®—ã‚„ç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ã‚’é©ç”¨ã§ãã¾ã™ã€‚ã¾ãŸã€ :class:`Decimal` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚³ãƒ”ãƒ¼ã§ãã€pickle åŒ–ã§ãã€print ã§å‡ºåŠ›ã§ãã€è¾æ›¸ã®ã‚­ãƒ¼ã«ã§ãã€é›†åˆã®è¦ç´ ã«ã§ãã€æ¯”è¼ƒã€ä¿å­˜ã€ä»–ã®å‹ (:class:`float` ã‚„ :class:`long`) ã¸ã®å‹å¼·åˆ¶ã‚’è¡Œãˆã¾ã™ã€‚"

#: ../../library/decimal.rst:375
msgid ""
"There are some small differences between arithmetic on Decimal objects and "
"arithmetic on integers and floats.  When the remainder operator ``%`` is "
"applied to Decimal objects, the sign of the result is the sign of the "
"*dividend* rather than the sign of the divisor::"
msgstr "10é€²ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç®—è¡“æ¼”ç®—ã¨æ•´æ•°ã‚„æµ®å‹•å°æ•°ç‚¹æ•°ã®ç®—è¡“æ¼”ç®—ã«ã¯å°‘ã€…é•ã„ãŒã‚ã‚Šã¾ã™ã€‚10é€²ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦å‰°ä½™æ¼”ç®—ã‚’é©ç”¨ã™ã‚‹ã¨ã€è¨ˆç®—çµæœã®ç¬¦å·ã¯é™¤æ•°ã®ç¬¦å·ã§ã¯ãªã *è¢«é™¤æ•°* ã®ç¬¦å·ã¨ä¸€è‡´ã—ã¾ã™::"

#: ../../library/decimal.rst:385
msgid ""
"The integer division operator ``//`` behaves analogously, returning the "
"integer part of the true quotient (truncating towards zero) rather than its "
"floor, so as to preserve the usual identity ``x == (x // y) * y + x % y``::"
msgstr "æ•´æ•°é™¤ç®—æ¼”ç®—å­ ``//`` ã‚‚åŒæ§˜ã«ã€å®Ÿéš›ã®å•†ã®åˆ‡ã‚Šæ¨ã¦ã§ã¯ãªã (0ã«è¿‘ä»˜ãã‚ˆã†ã«ä¸¸ã‚ãŸ) æ•´æ•°éƒ¨åˆ†ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã™ã‚‹ã“ã¨ã§é€šå¸¸ã®æ’ç­‰å¼ ``x == (x // y) * y + x % y`` ãŒä¿æŒã•ã‚Œã¾ã™::"

#: ../../library/decimal.rst:394
msgid ""
"The ``%`` and ``//`` operators implement the ``remainder`` and ``divide-"
"integer`` operations (respectively) as described in the specification."
msgstr "æ¼”ç®—å­ ``%`` ã¨æ¼”ç®—å­ ``//`` ã¯ (ãã‚Œãã‚Œ) ä»•æ§˜ã«ã‚ã‚‹ã‚ˆã†ãª ``å‰°ä½™`` æ“ä½œã¨ ``æ•´æ•°é™¤ç®—`` æ“ä½œã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:398
msgid ""
"Decimal objects cannot generally be combined with floats in arithmetic "
"operations: an attempt to add a :class:`Decimal` to a :class:`float`, for "
"example, will raise a :exc:`TypeError`. There's one exception to this rule: "
"it's possible to use Python's comparison operators to compare a "
":class:`float` instance ``x`` with a :class:`Decimal` instance ``y``.  "
"Without this exception, comparisons between :class:`Decimal` and "
":class:`float` instances would follow the general rules for comparing "
"objects of different types described in the :ref:`expressions` section of "
"the reference manual, leading to confusing results."
msgstr "Decimal ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸€èˆ¬ã«ã€ç®—è¡“æ¼”ç®—ã§æµ®å‹•å°æ•°ç‚¹æ•°ã¨çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ :class:`Decimal` ã« :class:`float` ã‚’è¶³ãã†ã¨ã™ã‚‹ã¨ã€ :exc:`TypeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ãŸã ã—ã“ã®è¦å‰‡ã«ã¯ä¾‹å¤–ãŒã‚ã‚Šã¾ã™ã€‚ :class:`float` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ ``x`` ã¨ :class:`Decimal` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ ``y`` ã‚’æ¯”è¼ƒã™ã‚‹æ¯”è¼ƒæ¼”ç®—å­ã§ã™ã€‚ã“ã®ä¾‹å¤–ãŒãªã‹ã£ãŸã¨ã™ã‚‹ã¨ã€ :class:`Decimal` ã¨ :class:`float` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ¯”è¼ƒã¯ã€ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã® :ref:`expressions` ç¯€ã§è¨˜è¿°ã•ã‚Œã¦ã„ã‚‹ã€ç•°ãªã‚‹å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¯”è¼ƒã™ã‚‹ã¨ãã®ä¸€èˆ¬ã®è¦å‰‡ã«å¾“ã†ã“ã¨ã«ãªã‚Šã€ç´›ã‚‰ã‚ã—ã„çµæœã«ã¤ãªãŒã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:409
msgid ""
"A comparison between a :class:`float` instance ``x`` and a :class:`Decimal` "
"instance ``y`` now returns a result based on the values of ``x`` and ``y``."
"  In earlier versions ``x < y`` returned the same (arbitrary) result for any"
" :class:`Decimal` instance ``x`` and any :class:`float` instance ``y``."
msgstr ":class:`float` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ ``x`` ã¨ :class:`Decimal` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ ``y`` ã®æ¯”è¼ƒã¯ã€ ``x`` ã¨ ``y`` ã®å€¤ã«åŸºã¥ãçµæœã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ã©ã‚“ãª :class:`float` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ ``x`` ã¨ã©ã‚“ãª :class:`Decimal` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ ``y`` ã«å¯¾ã—ã¦ã‚‚ã€ ``x < y`` ã¯åŒã˜ (ä»»æ„ã®) çµæœã‚’è¿”ã—ã¦ã„ã¾ã—ãŸã€‚"

#: ../../library/decimal.rst:416
msgid ""
"In addition to the standard numeric properties, decimal floating point "
"objects also have a number of specialized methods:"
msgstr "ã“ã†ã—ãŸæ¨™æº–çš„ãªæ•°å€¤å‹ã®ç‰¹æ€§ã®ä»–ã«ã€10é€²æµ®å‹•å°æ•°ç‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯æ§˜ã€…ãªç‰¹æ®Šãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™:"

#: ../../library/decimal.rst:422
msgid ""
"Return the adjusted exponent after shifting out the coefficient's rightmost "
"digits until only the lead digit remains: ``Decimal('321e+5').adjusted()`` "
"returns seven.  Used for determining the position of the most significant "
"digit with respect to the decimal point."
msgstr "ä»®æ•°ã®å…ˆé ­ã®ä¸€æ¡ã ã‘ãŒæ®‹ã‚‹ã‚ˆã†ã«å³å´ã®æ•°å­—ã‚’è¿½ã„å‡ºã™æ¡ã‚·ãƒ•ãƒˆã‚’è¡Œã„ã€ãã®çµæœã®æŒ‡æ•°éƒ¨ã‚’è¿”ã—ã¾ã™: ``Decimal('321e+5').adjusted()`` ã¯ 7 ã‚’è¿”ã—ã¾ã™ã€‚æœ€ä¸Šæ¡ã®å°æ•°ç‚¹ã‹ã‚‰ã®ç›¸å¯¾ä½ç½®ã‚’èª¿ã¹ã‚‹éš›ã«ä½¿ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:430
msgid ""
"Return a :term:`named tuple` representation of the number: "
"``DecimalTuple(sign, digits, exponent)``."
msgstr "æ•°å€¤ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®åå‰ä»˜ãã‚¿ãƒ—ãƒ«(:term:`named tuple`): ``DecimalTuple(sign, digittuple, exponent)`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:433
msgid "Use a named tuple."
msgstr "åå‰ä»˜ãã‚¿ãƒ—ãƒ« (named tuple) ã‚’ä½¿ã†ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/decimal.rst:439
msgid ""
"Return the canonical encoding of the argument.  Currently, the encoding of a"
" :class:`Decimal` instance is always canonical, so this operation returns "
"its argument unchanged."
msgstr "å¼•æ•°ã®æ¨™æº–çš„(canonical)ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿”ã—ã¾ã™ã€‚ç¾åœ¨ã®ã¨ã“ã‚ã€ :class:`Decimal` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯å¸¸ã«æ¨™æº–çš„ãªã®ã§ã€ã“ã®æ“ä½œã¯å¼•æ•°ã«æ‰‹ã‚’åŠ ãˆãšã«è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:447
msgid ""
"Compare the values of two Decimal instances.  This operation behaves in the "
"same way as the usual comparison method :meth:`__cmp__`, except that "
":meth:`compare` returns a Decimal instance rather than an integer, and if "
"either operand is a NaN then the result is a NaN::"
msgstr "äºŒã¤ã® Decimal ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å€¤ã‚’æ¯”è¼ƒã—ã¾ã™ã€‚ã“ã®æ¼”ç®—ã¯æ™®é€šã®æ¯”è¼ƒãƒ¡ã‚½ãƒƒãƒ‰ :meth:`__cmp__` ã¨åŒã˜ã‚ˆã†ã«æŒ¯èˆã„ã¾ã™ãŒã€ :meth:`compare` ã¯æ•´æ•°ã§ã¯ãªã Decimal ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã€ã¾ãŸã€è¢«æ¼”ç®—å­ã®ã©ã¡ã‚‰ã‹ãŒ NaN ãªã‚‰ã° NaN ã‚’è¿”ã—ã¾ã™::"

#: ../../library/decimal.rst:459
msgid ""
"This operation is identical to the :meth:`compare` method, except that all "
"NaNs signal.  That is, if neither operand is a signaling NaN then any quiet "
"NaN operand is treated as though it were a signaling NaN."
msgstr "ã“ã®æ¼”ç®—ã¯ :meth:`compare` ã¨ã»ã¨ã‚“ã©åŒã˜ã§ã™ãŒã€å…¨ã¦ã® NaN ãŒã‚·ã‚°ãƒŠãƒ«ã‚’é€ã‚‹ã¨ã“ã‚ãŒç•°ãªã‚Šã¾ã™ã€‚ã™ãªã‚ã¡ã€ã©ã¡ã‚‰ã®æ¯”è¼ƒå¯¾è±¡ã‚‚ç™ºä¿¡ (signaling) NaN ã§ãªã„ãªã‚‰ã°ç„¡è¨€ (quiet) NaN ã§ã‚ã‚‹æ¯”è¼ƒå¯¾è±¡ãŒã‚ãŸã‹ã‚‚ç™ºä¿¡ NaN ã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«æ‰±ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:467
msgid ""
"Compare two operands using their abstract representation rather than their "
"numerical value.  Similar to the :meth:`compare` method, but the result "
"gives a total ordering on :class:`Decimal` instances.  Two :class:`Decimal` "
"instances with the same numeric value but different representations compare "
"unequal in this ordering:"
msgstr "äºŒã¤ã®å¯¾è±¡ã‚’æ•°å€¤ã«ã‚ˆã‚‰ãšæŠ½è±¡è¡¨ç¾ã«ã‚ˆã£ã¦æ¯”è¼ƒã—ã¾ã™ã€‚ :meth:`compare` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€çµæœã¯ :class:`Decimal` ã«å…¨é †åºã‚’ä¸ãˆã¾ã™ã€‚ã“ã®é †åºã¥ã‘ã«ã‚ˆã‚‹ã¨ã€æ•°å€¤çš„ã«ç­‰ã—ãã¦ã‚‚ç•°ãªã£ãŸè¡¨ç¾ã‚’æŒã¤äºŒã¤ã® :class:`Decimal` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ¯”è¼ƒã¯ç­‰ã—ããªã‚Šã¾ã›ã‚“:"

#: ../../library/decimal.rst:476
msgid ""
"Quiet and signaling NaNs are also included in the total ordering.  The "
"result of this function is ``Decimal('0')`` if both operands have the same "
"representation, ``Decimal('-1')`` if the first operand is lower in the total"
" order than the second, and ``Decimal('1')`` if the first operand is higher "
"in the total order than the second operand.  See the specification for "
"details of the total order."
msgstr "ç„¡è¨€ NaN ã¨ç™ºä¿¡ NaN ã‚‚ã“ã®å…¨é †åºã«ä½ç½®ä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚ã“ã®é–¢æ•°ã®çµæœã¯ã€ã‚‚ã—æ¯”è¼ƒå¯¾è±¡ãŒåŒã˜è¡¨ç¾ã‚’æŒã¤ãªã‚‰ã° ``Decimal('0')`` ã§ã‚ã‚Šã€ä¸€ã¤ã‚ã®æ¯”è¼ƒå¯¾è±¡ãŒäºŒã¤ã‚ã‚ˆã‚Šä¸‹ä½ã«ã‚ã‚Œã° ``Decimal('-1')``ã€ä¸Šä½ã«ã‚ã‚Œã° ``Decimal('1')`` ã§ã™ã€‚å…¨é †åºã®è©³ç´°ã«ã¤ã„ã¦ã¯ä»•æ§˜ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/decimal.rst:487
msgid ""
"Compare two operands using their abstract representation rather than their "
"value as in :meth:`compare_total`, but ignoring the sign of each operand. "
"``x.compare_total_mag(y)`` is equivalent to "
"``x.copy_abs().compare_total(y.copy_abs())``."
msgstr "äºŒã¤ã®å¯¾è±¡ã‚’ :meth:`compare_total` ã®ã‚ˆã†ã«æ•°å€¤ã«ã‚ˆã‚‰ãšæŠ½è±¡è¡¨ç¾ã«ã‚ˆã£ã¦æ¯”è¼ƒã—ã¾ã™ãŒã€ä¸¡è€…ã®ç¬¦å·ã‚’ç„¡è¦–ã—ã¾ã™ã€‚ ``x.compare_total_mag(y)`` ã¯ ``x.copy_abs().compare_total(y.copy_abs())`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/decimal.rst:496
msgid ""
"Just returns self, this method is only to comply with the Decimal "
"Specification."
msgstr "self ã‚’è¿”ã™ã ã‘ã§ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯åé€²æ¼”ç®—ä»•æ§˜ã«é©åˆã™ã‚‹ãŸã‚ã ã‘ã®ã‚‚ã®ã§ã™ã€‚"

#: ../../library/decimal.rst:503
msgid ""
"Return the absolute value of the argument.  This operation is unaffected by "
"the context and is quiet: no flags are changed and no rounding is performed."
msgstr "å¼•æ•°ã®çµ¶å¯¾å€¤ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®æ¼”ç®—ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å½±éŸ¿ã•ã‚Œãšã€é™ã‹ã§ã™ã€‚ã™ãªã‚ã¡ã€ãƒ•ãƒ©ã‚°ã¯å¤‰æ›´ã•ã‚Œãšã€ä¸¸ã‚ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/decimal.rst:511
msgid ""
"Return the negation of the argument.  This operation is unaffected by the "
"context and is quiet: no flags are changed and no rounding is performed."
msgstr "å¼•æ•°ã®ç¬¦å·ã‚’å¤‰ãˆã¦è¿”ã—ã¾ã™ã€‚ã“ã®æ¼”ç®—ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å½±éŸ¿ã•ã‚Œãšã€é™ã‹ã§ã™ã€‚ã™ãªã‚ã¡ã€ãƒ•ãƒ©ã‚°ã¯å¤‰æ›´ã•ã‚Œãšã€ä¸¸ã‚ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/decimal.rst:518
msgid ""
"Return a copy of the first operand with the sign set to be the same as the "
"sign of the second operand.  For example:"
msgstr "æœ€åˆã®æ¼”ç®—å¯¾è±¡ã®ã‚³ãƒ”ãƒ¼ã«äºŒã¤ã‚ã¨åŒã˜ç¬¦å·ã‚’ä»˜ã‘ã¦è¿”ã—ã¾ã™ã€‚ãŸã¨ãˆã°:"

#: ../../library/decimal.rst:524
msgid ""
"This operation is unaffected by the context and is quiet: no flags are "
"changed and no rounding is performed."
msgstr "ã“ã®æ¼”ç®—ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å½±éŸ¿ã•ã‚Œãšã€é™ã‹ã§ã™ã€‚ã™ãªã‚ã¡ã€ãƒ•ãƒ©ã‚°ã¯å¤‰æ›´ã•ã‚Œãšã€ä¸¸ã‚ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/decimal.rst:531
msgid ""
"Return the value of the (natural) exponential function ``e**x`` at the given"
" number.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN`"
" rounding mode."
msgstr "ä¸ãˆã‚‰ã‚ŒãŸæ•°ã§ã®(è‡ªç„¶)æŒ‡æ•°é–¢æ•° ``e**x`` ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚çµæœã¯ :const:`ROUND_HALF_EVEN` ä¸¸ã‚ãƒ¢ãƒ¼ãƒ‰ã§æ­£ã—ãä¸¸ã‚ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:544
msgid "Classmethod that converts a float to a decimal number, exactly."
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã‚’æ­£ç¢ºã«å°æ•°ã«å¤‰æ›ã™ã‚‹ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚"

#: ../../library/decimal.rst:546
msgid ""
"Note `Decimal.from_float(0.1)` is not the same as `Decimal('0.1')`. Since "
"0.1 is not exactly representable in binary floating point, the value is "
"stored as the nearest representable value which is `0x1.999999999999ap-4`.  "
"That equivalent value in decimal is "
"`0.1000000000000000055511151231257827021181583404541015625`."
msgstr "ãªãŠã€`Decimal.from_float(0.1)` ã¯ `Decimal('0.1')` ã¨åŒã˜ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚0.1 ã¯äºŒé€²æµ®å‹•å°æ•°ç‚¹æ•°ã§æ­£ç¢ºã«è¡¨ã›ãªã„ã®ã§ã€ãã®å€¤ã¯è¡¨ç¾ã§ãã‚‹æœ€ã‚‚è¿‘ã„å€¤ã€`0x1.999999999999ap-4` ã¨ã—ã¦è¨˜æ†¶ã•ã‚Œã¾ã™ã€‚æµ®å‹•å°æ•°ç‚¹æ•°ã§ã®ç­‰ä¾¡ãªå€¤ã¯ `0.1000000000000000055511151231257827021181583404541015625` ã§ã™ã€‚"

#: ../../library/decimal.rst:552
msgid ""
"From Python 2.7 onwards, a :class:`Decimal` instance can also be constructed"
" directly from a :class:`float`."
msgstr "Python 2.7 ä»¥é™ã§ã¯ã€ :class:`Decimal` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ :class:`float` ã‹ã‚‰ç›´æ¥æ§‹ç¯‰ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/decimal.rst:570
msgid ""
"Fused multiply-add.  Return self*other+third with no rounding of the "
"intermediate product self*other."
msgstr "èåˆç©å’Œ(fused multiply-add)ã§ã™ã€‚self*other+third ã‚’é€”ä¸­çµæœã®ç© self*other ã§ä¸¸ã‚ã‚’è¡Œã‚ãšã«è¨ˆç®—ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:580
msgid ""
"Return :const:`True` if the argument is canonical and :const:`False` "
"otherwise.  Currently, a :class:`Decimal` instance is always canonical, so "
"this operation always returns :const:`True`."
msgstr "å¼•æ•°ãŒæ¨™æº–çš„(canonical)ãªã‚‰ã° :const:`True` ã‚’è¿”ã—ã€ãã†ã§ãªã‘ã‚Œã° :const:`False` ã‚’è¿”ã—ã¾ã™ã€‚ç¾åœ¨ã®ã¨ã“ã‚ã€ :class:`Decimal` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯å¸¸ã«æ¨™æº–çš„ãªã®ã§ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®çµæœã¯ã„ã¤ã§ã‚‚ :const:`True` ã§ã™ã€‚"

#: ../../library/decimal.rst:588
msgid ""
"Return :const:`True` if the argument is a finite number, and :const:`False` "
"if the argument is an infinity or a NaN."
msgstr "å¼•æ•°ãŒæœ‰é™ã®æ•°å€¤ãªã‚‰ã° :const:`True` ã‚’ã€ç„¡é™å¤§ã‹ NaN ãªã‚‰ã° :const:`False` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:595
msgid ""
"Return :const:`True` if the argument is either positive or negative infinity"
" and :const:`False` otherwise."
msgstr "å¼•æ•°ãŒæ­£ã¾ãŸã¯è² ã®ç„¡é™å¤§ãªã‚‰ã° :const:`True` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° :const:`False` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:602
msgid ""
"Return :const:`True` if the argument is a (quiet or signaling) NaN and "
":const:`False` otherwise."
msgstr "å¼•æ•°ãŒ (ç„¡è¨€ã‹ç™ºä¿¡ã‹ã¯å•ã‚ãš) NaN ã§ã‚ã‚Œã° :const:`True` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° :const:`False` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:609
msgid ""
"Return :const:`True` if the argument is a *normal* finite non-zero number "
"with an adjusted exponent greater than or equal to *Emin*. Return "
":const:`False` if the argument is zero, subnormal, infinite or a NaN.  Note,"
" the term *normal* is used here in a different sense with the "
":meth:`normalize` method which is used to create canonical values."
msgstr "å¼•æ•°ãŒ *æ­£è¦(normal)* ã®ã‚¼ãƒ­ã§ãªã„æœ‰é™æ•°å€¤ã§èª¿æ•´ã•ã‚ŒãŸæŒ‡æ•°ãŒ *Emin* ä»¥ä¸Šãªã‚‰ã° :const:`True` ã‚’è¿”ã—ã¾ã™ã€‚å¼•æ•°ãŒã‚¼ãƒ­ã€éæ­£è¦(subnormal)ã€ç„¡é™å¤§ã¾ãŸã¯ NaN ã§ã‚ã‚Œã° :const:`False` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã“ã§ã® *æ­£è¦* ã¨ã„ã†ç”¨èªã¯æ¨™æº–çš„ãª(canonical)å€¤ã‚’ä½œã‚Šå‡ºã™ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹ :meth:`normalize` ãƒ¡ã‚½ãƒƒãƒ‰ã«ãŠã‘ã‚‹æ„å‘³åˆã„ã¨ã¯ç•°ãªã‚Šã¾ã™ã®ã§æ³¨æ„ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/decimal.rst:619
msgid ""
"Return :const:`True` if the argument is a quiet NaN, and :const:`False` "
"otherwise."
msgstr "å¼•æ•°ãŒç„¡è¨€ NaN ã§ã‚ã‚Œã° :const:`True` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° :const:`False` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:626
msgid ""
"Return :const:`True` if the argument has a negative sign and :const:`False` "
"otherwise.  Note that zeros and NaNs can both carry signs."
msgstr "å¼•æ•°ã«è² ã®ç¬¦å·ãŒã¤ã„ã¦ã„ã‚Œã° :const:`True` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° :const:`False` ã‚’è¿”ã—ã¾ã™ã€‚æ³¨æ„ã™ã¹ãã¯ã‚¼ãƒ­ã‚„ NaN ãªã©ã‚‚ç¬¦å·ã‚’æŒã¡å¾—ã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../library/decimal.rst:633
msgid ""
"Return :const:`True` if the argument is a signaling NaN and :const:`False` "
"otherwise."
msgstr "å¼•æ•°ãŒç™ºä¿¡ NaN ã§ã‚ã‚Œã° :const:`True` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° :const:`False` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:640
msgid ""
"Return :const:`True` if the argument is subnormal, and :const:`False` "
"otherwise. A number is subnormal is if it is nonzero, finite, and has an "
"adjusted exponent less than *Emin*."
msgstr "å¼•æ•°ãŒéæ­£è¦æ•°(subnormal)ã§ã‚ã‚Œã° :const:`True` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° :const:`False` ã‚’è¿”ã—ã¾ã™ã€‚éæ­£è¦ãªæ•°å€¤ã¨ã¯ã€ã‚¼ãƒ­ã§ãªãã€æœ‰é™ã§ã€èª¿æ•´ã•ã‚ŒãŸæŒ‡æ•°ãŒ *Emin* æœªæº€ã®ã‚‚ã®ã‚’æŒ‡ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:648
msgid ""
"Return :const:`True` if the argument is a (positive or negative) zero and "
":const:`False` otherwise."
msgstr "å¼•æ•°ãŒ(æ­£ã¾ãŸã¯è² ã®)ã‚¼ãƒ­ã§ã‚ã‚Œã° :const:`True` ã‚’ã€ãã†ã§ãªã‘ã‚Œã° :const:`False` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:655
msgid ""
"Return the natural (base e) logarithm of the operand.  The result is "
"correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr "æ¼”ç®—å¯¾è±¡ã®è‡ªç„¶å¯¾æ•°(åº• e ã®å¯¾æ•°)ã‚’è¿”ã—ã¾ã™ã€‚çµæœã¯ :const:`ROUND_HALF_EVEN` ä¸¸ã‚ãƒ¢ãƒ¼ãƒ‰ã§æ­£ã—ãä¸¸ã‚ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:662
msgid ""
"Return the base ten logarithm of the operand.  The result is correctly "
"rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr "æ¼”ç®—å¯¾è±¡ã®åº• 10 ã®å¯¾æ•°ã‚’è¿”ã—ã¾ã™ã€‚çµæœã¯ :const:`ROUND_HALF_EVEN` ä¸¸ã‚ãƒ¢ãƒ¼ãƒ‰ã§æ­£ã—ãä¸¸ã‚ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:669
msgid ""
"For a nonzero number, return the adjusted exponent of its operand as a "
":class:`Decimal` instance.  If the operand is a zero then "
"``Decimal('-Infinity')`` is returned and the :const:`DivisionByZero` flag is"
" raised.  If the operand is an infinity then ``Decimal('Infinity')`` is "
"returned."
msgstr "éé›¶ã®æ•°å€¤ã«ã¤ã„ã¦ã¯ã€ :class:`Decimal` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã—ã¦èª¿æ•´ã•ã‚ŒãŸæŒ‡æ•°ã‚’è¿”ã—ã¾ã™ã€‚æ¼”ç®—å¯¾è±¡ãŒã‚¼ãƒ­ã ã£ãŸå ´åˆã€ ``Decimal('-Infinity')`` ãŒè¿”ã•ã‚Œ :const:`DivisionByZero` ãƒ•ãƒ©ã‚°ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚æ¼”ç®—å¯¾è±¡ãŒç„¡é™å¤§ã ã£ãŸå ´åˆã€ ``Decimal('Infinity')`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:679
msgid ""
":meth:`logical_and` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise"
" ``and`` of the two operands."
msgstr ":meth:`logical_and` ã¯äºŒã¤ã® *è«–ç†å¼•æ•°* (:ref:`logical_operands_label` å‚ç…§)ã‚’å–ã‚‹è«–ç†æ¼”ç®—ã§ã™ã€‚çµæœã¯äºŒã¤ã®å¼•æ•°ã®æ•°å­—ã”ã¨ã® ``and`` ã§ã™ã€‚"

#: ../../library/decimal.rst:687
msgid ""
":meth:`logical_invert` is a logical operation.  The result is the digit-wise"
" inversion of the operand."
msgstr ":meth:`logical_invert` ã¯è«–ç†æ¼”ç®—ã§ã™ã€‚çµæœã¯å¼•æ•°ã®æ•°å­—ã”ã¨ã®åè»¢ã§ã™ã€‚"

#: ../../library/decimal.rst:694
msgid ""
":meth:`logical_or` is a logical operation which takes two *logical operands*"
" (see :ref:`logical_operands_label`).  The result is the digit-wise ``or`` "
"of the two operands."
msgstr ":meth:`logical_or` ã¯äºŒã¤ã® *è«–ç†å¼•æ•°* (:ref:`logical_operands_label` å‚ç…§)ã‚’å–ã‚‹è«–ç†æ¼”ç®—ã§ã™ã€‚çµæœã¯äºŒã¤ã®å¼•æ•°ã®æ•°å­—ã”ã¨ã® ``or`` ã§ã™ã€‚"

#: ../../library/decimal.rst:702
msgid ""
":meth:`logical_xor` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise"
" exclusive or of the two operands."
msgstr ":meth:`logical_xor` ã¯äºŒã¤ã® *è«–ç†å¼•æ•°* (:ref:`logical_operands_label` å‚ç…§)ã‚’å–ã‚‹è«–ç†æ¼”ç®—ã§ã™ã€‚çµæœã¯äºŒã¤ã®å¼•æ•°ã®æ•°å­—ã”ã¨ã®æ’ä»–çš„è«–ç†å’Œã§ã™ã€‚"

#: ../../library/decimal.rst:710
msgid ""
"Like ``max(self, other)`` except that the context rounding rule is applied "
"before returning and that :const:`NaN` values are either signaled or ignored"
" (depending on the context and whether they are signaling or quiet)."
msgstr "``max(self, other)`` ã¨åŒã˜ã§ã™ãŒã€å€¤ã‚’è¿”ã™å‰ã«ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å³ã—ãŸä¸¸ã‚è¦å‰‡ã‚’é©ç”¨ã—ã¾ã™ã€‚ã¾ãŸã€ :const:`NaN` ã«å¯¾ã—ã¦ã€(ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®è¨­å®šã¨ã€ç™ºä¿¡ã‹ç„¡è¨€ã©ã¡ã‚‰ã®ã‚¿ã‚¤ãƒ—ã§ã‚ã‚‹ã‹ã«å¿œã˜ã¦) ã‚·ã‚°ãƒŠãƒ«ã‚’ç™ºè¡Œã™ã‚‹ã‹ç„¡è¦–ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:717
msgid ""
"Similar to the :meth:`.max` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ":meth:`.max` ãƒ¡ã‚½ãƒƒãƒ‰ã«ä¼¼ã¦ã„ã¾ã™ãŒã€æ¯”è¼ƒã¯çµ¶å¯¾å€¤ã§è¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:724
msgid ""
"Like ``min(self, other)`` except that the context rounding rule is applied "
"before returning and that :const:`NaN` values are either signaled or ignored"
" (depending on the context and whether they are signaling or quiet)."
msgstr "``min(self, other)`` ã¨åŒã˜ã§ã™ãŒã€å€¤ã‚’è¿”ã™å‰ã«ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å³ã—ãŸä¸¸ã‚è¦å‰‡ã‚’é©ç”¨ã—ã¾ã™ã€‚ã¾ãŸã€ :const:`NaN` ã«å¯¾ã—ã¦ã€(ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®è¨­å®šã¨ã€ç™ºä¿¡ã‹ç„¡è¨€ã©ã¡ã‚‰ã®ã‚¿ã‚¤ãƒ—ã§ã‚ã‚‹ã‹ã«å¿œã˜ã¦) ã‚·ã‚°ãƒŠãƒ«ã‚’ç™ºè¡Œã™ã‚‹ã‹ç„¡è¦–ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:731
msgid ""
"Similar to the :meth:`.min` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ":meth:`.min` ãƒ¡ã‚½ãƒƒãƒ‰ã«ä¼¼ã¦ã„ã¾ã™ãŒã€æ¯”è¼ƒã¯çµ¶å¯¾å€¤ã§è¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:738
msgid ""
"Return the largest number representable in the given context (or in the "
"current thread's context if no context is given) that is smaller than the "
"given operand."
msgstr "ä¸ãˆã‚‰ã‚ŒãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ(ã¾ãŸã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒæ¸¡ã•ã‚Œãªã‘ã‚Œã°ç¾ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ)ã«ãŠã„ã¦è¡¨ç¾å¯èƒ½ãªã€æ“ä½œå¯¾è±¡ã‚ˆã‚Šå°ã•ã„æœ€å¤§ã®æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:746
msgid ""
"Return the smallest number representable in the given context (or in the "
"current thread's context if no context is given) that is larger than the "
"given operand."
msgstr "ä¸ãˆã‚‰ã‚ŒãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ(ã¾ãŸã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒæ¸¡ã•ã‚Œãªã‘ã‚Œã°ç¾ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ)ã«ãŠã„ã¦è¡¨ç¾å¯èƒ½ãªã€æ“ä½œå¯¾è±¡ã‚ˆã‚Šå¤§ãã„æœ€å°ã®æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:754
msgid ""
"If the two operands are unequal, return the number closest to the first "
"operand in the direction of the second operand.  If both operands are "
"numerically equal, return a copy of the first operand with the sign set to "
"be the same as the sign of the second operand."
msgstr "äºŒã¤ã®æ¯”è¼ƒå¯¾è±¡ãŒç­‰ã—ããªã‘ã‚Œã°ã€ä¸€ã¤ã‚ã®å¯¾è±¡ã«æœ€ã‚‚è¿‘ãäºŒã¤ã‚ã®å¯¾è±¡ã¸è¿‘ä»˜ãæ–¹å‘ã®æ•°ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—ä¸¡è€…ãŒæ•°å€¤çš„ã«ç­‰ã—ã‘ã‚Œã°ã€äºŒã¤ã‚ã®å¯¾è±¡ã®ç¬¦å·ã‚’æ¡ã£ãŸä¸€ã¤ã‚ã®å¯¾è±¡ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:763
msgid ""
"Normalize the number by stripping the rightmost trailing zeros and "
"converting any result equal to :const:`Decimal('0')` to "
":const:`Decimal('0e0')`. Used for producing canonical values for attributes "
"of an equivalence class. For example, ``Decimal('32.100')`` and "
"``Decimal('0.321000e+2')`` both normalize to the equivalent value "
"``Decimal('32.1')``."
msgstr "æ•°å€¤ã‚’æ­£è¦åŒ– (normalize) ã—ã¦ã€å³ç«¯ã«é€£ç¶šã—ã¦ã„ã‚‹ã‚¼ãƒ­ã‚’é™¤å»ã—ã€ :const:`Decimal('0')` ã¨åŒã˜çµæœã¯ã™ã¹ã¦ :const:`Decimal('0e0')` ã«å¤‰æ›ã—ã¾ã™ã€‚ç­‰ä¾¡ã‚¯ãƒ©ã‚¹ã®å±æ€§ã‹ã‚‰åŸºæº–è¡¨ç¾ã‚’ç”Ÿæˆã™ã‚‹éš›ã«ç”¨ã„ã¾ã™ã€‚ãŸã¨ãˆã°ã€ ``Decimal('32.100')`` ã¨ ``Decimal('0.321000e+2')`` ã®æ­£è¦åŒ–ã¯ã€ã„ãšã‚Œã‚‚åŒã˜å€¤ ``Decimal('32.1')`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:772
msgid ""
"Return a string describing the *class* of the operand.  The returned value "
"is one of the following ten strings."
msgstr "æ“ä½œå¯¾è±¡ã® *ã‚¯ãƒ©ã‚¹* ã‚’è¡¨ã™æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚è¿”ã•ã‚Œã‚‹ã®ã¯ä»¥ä¸‹ã®10ç¨®é¡ã®ã„ãšã‚Œã‹ã§ã™ã€‚"

#: ../../library/decimal.rst:775
msgid "``\"-Infinity\"``, indicating that the operand is negative infinity."
msgstr "``\"-Infinity\"``, è² ã®ç„¡é™å¤§ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:776
msgid "``\"-Normal\"``, indicating that the operand is a negative normal number."
msgstr "``\"-Normal\"``, è² ã®é€šå¸¸æ•°ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:777
msgid "``\"-Subnormal\"``, indicating that the operand is negative and subnormal."
msgstr "``\"-Subnormal\"``, è² ã®éæ­£è¦æ•°ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:778
msgid "``\"-Zero\"``, indicating that the operand is a negative zero."
msgstr "``\"-Zero\"``, è² ã®ã‚¼ãƒ­ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:779
msgid "``\"+Zero\"``, indicating that the operand is a positive zero."
msgstr "``\"+Zero\"``, æ­£ã®ã‚¼ãƒ­ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:780
msgid "``\"+Subnormal\"``, indicating that the operand is positive and subnormal."
msgstr "``\"+Subnormal\"``, æ­£ã®éæ­£è¦æ•°ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:781
msgid "``\"+Normal\"``, indicating that the operand is a positive normal number."
msgstr "``\"+Normal\"``, æ­£ã®é€šå¸¸æ•°ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:782
msgid "``\"+Infinity\"``, indicating that the operand is positive infinity."
msgstr "``\"+Infinity\"``, æ­£ã®ç„¡é™å¤§ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:783
msgid "``\"NaN\"``, indicating that the operand is a quiet NaN (Not a Number)."
msgstr "``\"NaN\"``, ç„¡è¨€ (quiet) NaN (Not a Number) ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:784
msgid "``\"sNaN\"``, indicating that the operand is a signaling NaN."
msgstr "``\"sNaN\"``, ç™ºä¿¡(signaling) NaN ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:790
msgid ""
"Return a value equal to the first operand after rounding and having the "
"exponent of the second operand."
msgstr "äºŒã¤ã‚ã®æ“ä½œå¯¾è±¡ã¨åŒã˜æŒ‡æ•°ã‚’æŒã¤ã‚ˆã†ã«ä¸¸ã‚ã‚’è¡Œã£ãŸã€ä¸€ã¤ã‚ã®æ“ä½œå¯¾è±¡ã¨ç­‰ã—ã„å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:796
msgid ""
"Unlike other operations, if the length of the coefficient after the quantize"
" operation would be greater than precision, then an "
":const:`InvalidOperation` is signaled. This guarantees that, unless there is"
" an error condition, the quantized exponent is always equal to that of the "
"right-hand operand."
msgstr "ä»–ã®æ“ä½œã¨é•ã„ã€æ‰“ã¡åˆ‡ã‚Š(quantize)æ“ä½œå¾Œã®ä¿‚æ•°ã®é•·ã•ãŒç²¾åº¦ã‚’è¶ŠãˆãŸå ´åˆã«ã¯ã€ :const:`InvalidOperation` ãŒã‚·ã‚°ãƒŠãƒ«ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã‚¨ãƒ©ãƒ¼æ¡ä»¶ãŒãªã„é™ã‚Šæ‰“ã¡åˆ‡ã‚‰ã‚ŒãŸæŒ‡æ•°ãŒå¸¸ã«å³å´ã®å¼•æ•°ã¨åŒã˜ã«ãªã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:802
msgid ""
"Also unlike other operations, quantize never signals Underflow, even if the "
"result is subnormal and inexact."
msgstr "åŒæ§˜ã«ã€ä»–ã®æ“ä½œã¨é•ã„ã€quantize ã¯ Underflow ã‚’ã€ãŸã¨ãˆçµæœãŒéæ­£è¦ã«ãªã£ãŸã‚Šä¸æ­£ç¢ºã«ãªã£ãŸã¨ã—ã¦ã‚‚ã€ã‚·ã‚°ãƒŠãƒ«ã—ã¾ã›ã‚“ã€‚"

#: ../../library/decimal.rst:805
msgid ""
"If the exponent of the second operand is larger than that of the first then "
"rounding may be necessary.  In this case, the rounding mode is determined by"
" the ``rounding`` argument if given, else by the given ``context`` argument;"
" if neither argument is given the rounding mode of the current thread's "
"context is used."
msgstr "äºŒã¤ç›®ã®æ¼”ç®—å¯¾è±¡ã®æŒ‡æ•°ãŒä¸€ã¤ç›®ã®ãã‚Œã‚ˆã‚Šã‚‚å¤§ãã‘ã‚Œã°ä¸¸ã‚ãŒå¿…è¦ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã®å ´åˆã€ä¸¸ã‚ãƒ¢ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«æ±ºã‚ã‚‰ã‚Œã¾ã™ã€‚``rounding`` å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œã¦ã„ã‚Œã°ãã‚ŒãŒä½¿ã‚ã‚Œã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° ``context`` å¼•æ•°ã§æ±ºã¾ã‚Šã¾ã™ã€‚ã©ã¡ã‚‰ã®å¼•æ•°ã‚‚æ¸¡ã•ã‚Œãªã‘ã‚Œã°ç¾åœ¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä¸¸ã‚ãƒ¢ãƒ¼ãƒ‰ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:811
msgid ""
"If *watchexp* is set (default), then an error is returned whenever the "
"resulting exponent is greater than :attr:`Emax` or less than :attr:`Etiny`."
msgstr "*watchexp* ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆ(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)ã€å‡¦ç†çµæœã®æŒ‡æ•°ãŒ :attr:`Emax` ã‚ˆã‚Šã‚‚å¤§ãã„å ´åˆã‚„ :attr:`Etiny` ã‚ˆã‚Šã‚‚å°ã•ã„å ´åˆã«ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:817
msgid ""
"Return ``Decimal(10)``, the radix (base) in which the :class:`Decimal` class"
" does all its arithmetic.  Included for compatibility with the "
"specification."
msgstr "``Decimal(10)`` ã¤ã¾ã‚Š :class:`Decimal` ã‚¯ãƒ©ã‚¹ãŒãã®å…¨ã¦ã®ç®—è¡“ã‚’å®Ÿè¡Œã™ã‚‹åŸºæ•°ã‚’è¿”ã—ã¾ã™ã€‚ä»•æ§˜ã¨ã®äº’æ›æ€§ã®ãŸã‚ã«å–ã‚Šå…¥ã‚Œã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:825
msgid ""
"Return the remainder from dividing *self* by *other*.  This differs from "
"``self % other`` in that the sign of the remainder is chosen so as to "
"minimize its absolute value.  More precisely, the return value is ``self - n"
" * other`` where ``n`` is the integer nearest to the exact value of ``self /"
" other``, and if two integers are equally near then the even one is chosen."
msgstr "*self* ã‚’ *other* ã§å‰²ã£ãŸå‰°ä½™ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯ ``self % other`` ã¨ã¯é•ã£ã¦ã€å‰°ä½™ã®çµ¶å¯¾å€¤ã‚’å°ã•ãã™ã‚‹ã‚ˆã†ã«ç¬¦å·ãŒé¸ã°ã‚Œã¾ã™ã€‚ã‚ˆã‚Šè©³ã—ãè¨€ã†ã¨ã€``n`` ã‚’ ``self / other`` ã®æ­£ç¢ºãªå€¤ã«æœ€ã‚‚è¿‘ã„æ•´æ•°ã¨ã—ãŸã¨ãã® ``self - n * other`` ãŒè¿”ã‚Šå€¤ã«ãªã‚Šã¾ã™ã€‚æœ€ã‚‚è¿‘ã„æ•´æ•°ãŒ2ã¤ã‚ã‚‹å ´åˆã«ã¯å¶æ•°ã®ã‚‚ã®ãŒé¸ã°ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:832
msgid "If the result is zero then its sign will be the sign of *self*."
msgstr "çµæœãŒ0ã«ãªã‚‹å ´åˆã®ç¬¦å·ã¯ *self* ã®ç¬¦å·ã¨åŒã˜ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:843
msgid ""
"Return the result of rotating the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to rotate.  If the second operand is "
"positive then rotation is to the left; otherwise rotation is to the right. "
"The coefficient of the first operand is padded on the left with zeros to "
"length precision if necessary.  The sign and exponent of the first operand "
"are unchanged."
msgstr "ä¸€ã¤ã‚ã®æ¼”ç®—å¯¾è±¡ã®æ•°å­—ã‚’äºŒã¤ã‚ã®ã§æŒ‡å®šã•ã‚ŒãŸé‡ã ã‘å·¡å›(rotate)ã—ãŸçµæœã‚’è¿”ã—ã¾ã™ã€‚äºŒã¤ã‚ã®æ¼”ç®—å¯¾è±¡ã¯ -precision ã‹ã‚‰ precision ã¾ã§ã®ç¯„å›²ã®æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®äºŒã¤ã‚ã®æ¼”ç®—å¯¾è±¡ã®çµ¶å¯¾å€¤ãŒä½•æ¡ãšã‚‰ã™ã‹ã‚’æ±ºã‚ã¾ã™ã€‚ãã—ã¦ã‚‚ã—æ­£ã®æ•°ãªã‚‰ã°å·¡å›ã®æ–¹å‘ã¯å·¦ã«ã€ãã†ã§ãªã‘ã‚Œã°å³ã«ãªã‚Šã¾ã™ã€‚ä¸€ã¤ã‚ã®æ¼”ç®—å¯¾è±¡ã®ä»®æ•°éƒ¨ã¯å¿…è¦ãªã‚‰ã°ç²¾åº¦ã„ã£ã±ã„ã¾ã§ã‚¼ãƒ­ã§åŸ‹ã‚ã‚‰ã‚Œã¾ã™ã€‚ç¬¦å·ã¨æŒ‡æ•°ã¯å¤‰ãˆã‚‰ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/decimal.rst:856
msgid ""
"Test whether self and other have the same exponent or whether both are "
":const:`NaN`."
msgstr "*self* ã¨ *other* ãŒåŒã˜æŒ‡æ•°ã‚’æŒã£ã¦ã„ã‚‹ã‹ã€ã‚ã‚‹ã„ã¯åŒæ–¹ã¨ã‚‚ :const:`NaN` ã§ã‚ã‚‹å ´åˆã«çœŸã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:861
msgid ""
"Return the first operand with exponent adjusted by the second. Equivalently,"
" return the first operand multiplied by ``10**other``.  The second operand "
"must be an integer."
msgstr "äºŒã¤ã‚ã®æ¼”ç®—å¯¾è±¡ã§èª¿æ•´ã•ã‚ŒãŸæŒ‡æ•°ã®ä¸€ã¤ã‚ã®æ¼”ç®—å¯¾è±¡ã‚’è¿”ã—ã¾ã™ã€‚åŒã˜ã“ã¨ã§ã™ãŒã€ä¸€ã¤ã‚ã®æ¼”ç®—å¯¾è±¡ã‚’ ``10**other`` å€ã—ãŸã‚‚ã®ã‚’è¿”ã—ã¾ã™ã€‚äºŒã¤ã‚ã®æ¼”ç®—å¯¾è±¡ã¯æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/decimal.rst:869
msgid ""
"Return the result of shifting the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to shift.  If the second operand is "
"positive then the shift is to the left; otherwise the shift is to the right."
"  Digits shifted into the coefficient are zeros.  The sign and exponent of "
"the first operand are unchanged."
msgstr "ä¸€ã¤ã‚ã®æ¼”ç®—å¯¾è±¡ã®æ•°å­—ã‚’äºŒã¤ã‚ã®ã§æŒ‡å®šã•ã‚ŒãŸé‡ã ã‘ã‚·ãƒ•ãƒˆã—ãŸçµæœã‚’è¿”ã—ã¾ã™ã€‚äºŒã¤ã‚ã®æ¼”ç®—å¯¾è±¡ã¯ -precision ã‹ã‚‰ precision ã¾ã§ã®ç¯„å›²ã®æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®äºŒã¤ã‚ã®æ¼”ç®—å¯¾è±¡ã®çµ¶å¯¾å€¤ãŒä½•æ¡ãšã‚‰ã™ã‹ã‚’æ±ºã‚ã¾ã™ã€‚ãã—ã¦ã‚‚ã—æ­£ã®æ•°ãªã‚‰ã°ã‚·ãƒ•ãƒˆã®æ–¹å‘ã¯å·¦ã«ã€ãã†ã§ãªã‘ã‚Œã°å³ã«ãªã‚Šã¾ã™ã€‚ä¸€ã¤ã‚ã®æ¼”ç®—å¯¾è±¡ã®ä¿‚æ•°ã¯å¿…è¦ãªã‚‰ã°ç²¾åº¦ã„ã£ã±ã„ã¾ã§ã‚¼ãƒ­ã§åŸ‹ã‚ã‚‰ã‚Œã¾ã™ã€‚ç¬¦å·ã¨æŒ‡æ•°ã¯å¤‰ãˆã‚‰ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/decimal.rst:881
msgid "Return the square root of the argument to full precision."
msgstr "å¹³æ–¹æ ¹ã‚’ç²¾åº¦ã„ã£ã±ã„ã¾ã§æ±‚ã‚ã¾ã™ã€‚"

#: ../../library/decimal.rst:886 ../../library/decimal.rst:1458
msgid ""
"Convert to a string, using engineering notation if an exponent is needed."
msgstr "æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¾ã™ã€‚æŒ‡æ•°ãŒå¿…è¦ãªã‚‰å·¥å­¦è¡¨è¨˜ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:888 ../../library/decimal.rst:1460
msgid ""
"Engineering notation has an exponent which is a multiple of 3.  This can "
"leave up to 3 digits to the left of the decimal place and may require the "
"addition of either one or two trailing zeros."
msgstr "å·¥å­¦è¡¨è¨˜æ³•ã§ã¯æŒ‡æ•°ã¯ 3 ã®å€æ•°ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€åŸºæ•°ã®å°æ•°éƒ¨ã«ã¯æœ€å¤§ã§ 3 æ¡ã¾ã§ã®æ•°å­—ãŒæ®‹ã•ã‚Œã‚‹ã¨ã¨ã‚‚ã«ã€æœ«å°¾ã« 1 ã¤ã¾ãŸã¯ 2 ã¤ã® 0 ã®ä»˜åŠ ãŒå¿…è¦ã¨ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/decimal.rst:892
msgid ""
"For example, this converts ``Decimal('123E+1')`` to ``Decimal('1.23E+3')``."
msgstr "ãŸã¨ãˆã°ã€``Decimal('123E+1')`` ã¯ ``Decimal('1.23E+3')`` ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:896
msgid ""
"Identical to the :meth:`to_integral_value` method.  The ``to_integral`` name"
" has been kept for compatibility with older versions."
msgstr ":meth:`to_integral_value` ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒã˜ã§ã™ã€‚``to_integral`` ã®åå‰ã¯å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã®äº’æ›æ€§ã®ãŸã‚ã«æ®‹ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:901
msgid ""
"Round to the nearest integer, signaling :const:`Inexact` or :const:`Rounded`"
" as appropriate if rounding occurs.  The rounding mode is determined by the "
"``rounding`` parameter if given, else by the given ``context``.  If neither "
"parameter is given then the rounding mode of the current context is used."
msgstr "æœ€è¿‘å‚ã®æ•´æ•°ã«å€¤ã‚’ä¸¸ã‚ã€ä¸¸ã‚ãŒèµ·ã“ã£ãŸå ´åˆã«ã¯ :const:`Inexact` ã¾ãŸã¯ :const:`Rounded` ã®ã‚·ã‚°ãƒŠãƒ«ã‚’é©åˆ‡ã«å‡ºã—ã¾ã™ã€‚ä¸¸ã‚ãƒ¢ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«æ±ºã‚ã‚‰ã‚Œã¾ã™ã€‚ ``rounding`` å¼•æ•°ãŒä¸ãˆã‚‰ã‚Œã¦ã„ã‚Œã°ãã‚ŒãŒä½¿ã‚ã‚Œã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° ``context`` å¼•æ•°ã§æ±ºã¾ã‚Šã¾ã™ã€‚ã©ã¡ã‚‰ã®å¼•æ•°ã‚‚æ¸¡ã•ã‚Œãªã‘ã‚Œã°ç¾åœ¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä¸¸ã‚ãƒ¢ãƒ¼ãƒ‰ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:911
msgid ""
"Round to the nearest integer without signaling :const:`Inexact` or "
":const:`Rounded`.  If given, applies *rounding*; otherwise, uses the "
"rounding method in either the supplied *context* or the current context."
msgstr ":const:`Inexact` ã‚„ :const:`Rounded` ã¨ã„ã£ãŸã‚·ã‚°ãƒŠãƒ«ã‚’å‡ºã•ãšã«æœ€è¿‘å‚ã®æ•´æ•°ã«å€¤ã‚’ä¸¸ã‚ã¾ã™ã€‚ *rounding* ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚Œã°é©ç”¨ã•ã‚Œã¾ã™; ãã‚Œä»¥å¤–ã®å ´åˆã€å€¤ä¸¸ã‚ã®æ–¹æ³•ã¯ *context* ã®è¨­å®šã‹ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®è¨­å®šã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:915
msgid ""
"renamed from ``to_integral`` to ``to_integral_value``.  The old name remains"
" valid for compatibility."
msgstr "``to_integral`` ã‹ã‚‰ ``to_integral_value`` ã«æ”¹åã•ã‚Œã¾ã—ãŸã€‚å¤ã„åå‰ã‚‚äº’æ›æ€§ã®ãŸã‚ã«æ®‹ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:922
msgid "Logical operands"
msgstr "è«–ç†å¼•æ•°"

#: ../../library/decimal.rst:924
msgid ""
"The :meth:`logical_and`, :meth:`logical_invert`, :meth:`logical_or`, and "
":meth:`logical_xor` methods expect their arguments to be *logical operands*."
"  A *logical operand* is a :class:`Decimal` instance whose exponent and sign"
" are both zero, and whose digits are all either :const:`0` or :const:`1`."
msgstr ":meth:`logical_and`, :meth:`logical_invert`, :meth:`logical_or`, ãŠã‚ˆã³ :meth:`logical_xor` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãã®å¼•æ•°ãŒ *è«–ç†å¼•æ•°* ã§ã‚ã‚‹ã¨æƒ³å®šã—ã¦ã„ã¾ã™ã€‚ *è«–ç†å¼•æ•°* ã¨ã¯ :class:`Decimal` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§æŒ‡æ•°ã¨ç¬¦å·ã¯å…±ã«ã‚¼ãƒ­ã§ã‚ã‚Šã€å„æ¡ã®æ•°å­—ãŒ :const:`0` ã‹ :const:`1` ã§ã‚ã‚‹ã‚‚ã®ã§ã™ã€‚"

#: ../../library/decimal.rst:936
msgid "Context objects"
msgstr "Context ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/decimal.rst:938
msgid ""
"Contexts are environments for arithmetic operations.  They govern precision,"
" set rules for rounding, determine which signals are treated as exceptions, "
"and limit the range for exponents."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ (context) ã¨ã¯ã€ç®—è¡“æ¼”ç®—ã«ãŠã‘ã‚‹ç’°å¢ƒè¨­å®šã§ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯è¨ˆç®—ç²¾åº¦ã‚’æ±ºå®šã—ã€å€¤ä¸¸ã‚ã®æ–¹æ³•ã‚’è¨­å®šã—ã€ã‚·ã‚°ãƒŠãƒ«ã®ã©ã‚ŒãŒä¾‹å¤–ã«ãªã‚‹ã‹ã‚’æ±ºã‚ã€æŒ‡æ•°ã®ç¯„å›²ã‚’åˆ¶é™ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:942
msgid ""
"Each thread has its own current context which is accessed or changed using "
"the :func:`getcontext` and :func:`setcontext` functions:"
msgstr "å¤šé‡ã‚¹ãƒ¬ãƒƒãƒ‰ã§å‡¦ç†ã‚’è¡Œã†å ´åˆã«ã¯å„ã‚¹ãƒ¬ãƒƒãƒ‰ã”ã¨ã«ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒã‚ã‚Šã€ :func:`getcontext` ã‚„ :func:`setcontext` ã¨ã„ã£ãŸé–¢æ•°ã§ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã‚Šè¨­å®šå¤‰æ›´ã§ãã¾ã™:"

#: ../../library/decimal.rst:948
msgid "Return the current context for the active thread."
msgstr "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¹ãƒ¬ãƒƒãƒ‰ã®ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:953
msgid "Set the current context for the active thread to *c*."
msgstr "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ *c* ã«è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:955
msgid ""
"Beginning with Python 2.5, you can also use the :keyword:`with` statement "
"and the :func:`localcontext` function to temporarily change the active "
"context."
msgstr "Python 2.5 ã‹ã‚‰ã€ :keyword:`with` æ–‡ã¨ :func:`localcontext` é–¢æ•°ã‚’ä½¿ã£ã¦å®Ÿè¡Œã™ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¸€æ™‚çš„ã«å¤‰æ›´ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/decimal.rst:961
msgid ""
"Return a context manager that will set the current context for the active "
"thread to a copy of *c* on entry to the with-statement and restore the "
"previous context when exiting the with-statement. If no context is "
"specified, a copy of the current context is used."
msgstr "with æ–‡ã®å…¥å£ã§ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ *c* ã®ã‚³ãƒ”ãƒ¼ã«è¨­å®šã—ã€with æ–‡ã‚’æŠœã‘ã‚‹æ™‚ã«å…ƒã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å¾©æ—§ã™ã‚‹ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’è¿”ã—ã¾ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒæŒ‡å®šã•ã‚Œãªã‘ã‚Œã°ã€ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ã‚³ãƒ”ãƒ¼ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:968
msgid ""
"For example, the following code sets the current decimal precision to 42 "
"places, performs a calculation, and then automatically restores the previous"
" context::"
msgstr "ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ç²¾åº¦ã‚’42æ¡ã«è¨­å®šã—ã€è¨ˆç®—ã‚’å®Ÿè¡Œã—ã€ãã—ã¦å…ƒã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å¾©å¸°ã—ã¾ã™::"

#: ../../library/decimal.rst:982
msgid ""
"New contexts can also be created using the :class:`Context` constructor "
"described below. In addition, the module provides three pre-made contexts:"
msgstr "æ–°ãŸãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯ã€ä»¥ä¸‹ã§èª¬æ˜ã™ã‚‹ :class:`Context` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½¿ã£ã¦ç”Ÿæˆã§ãã¾ã™ã€‚ãã®ä»–ã«ã‚‚ã€ :mod:`decimal` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ä½œæˆæ¸ˆã¿ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/decimal.rst:988
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to "
":const:`ROUND_HALF_UP`.  All flags are cleared.  All traps are enabled "
"(treated as exceptions) except :const:`Inexact`, :const:`Rounded`, and "
":const:`Subnormal`."
msgstr "æ±ç”¨10é€²æ¼”ç®—ä»•æ§˜ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹æ¨™æº–ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä¸€ã¤ã§ã™ã€‚ç²¾åº¦ã¯ 9 æ¡ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã™ã€‚ä¸¸ã‚è¦å‰‡ã¯ :const:`ROUND_HALF_UP` ã§ã™ã€‚ã™ã¹ã¦ã®æ¼”ç®—çµæœãƒ•ãƒ©ã‚°ã¯ã‚¯ãƒªã‚¢ã•ã‚Œã¦ã„ã¾ã™ã€‚ :const:`Inexact`, :const:`Rounded`, :const:`Subnormal` ã‚’é™¤ãå…¨ã¦ã®æ¼”ç®—ã‚¨ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒãƒ—ãŒæœ‰åŠ¹ (ä¾‹å¤–ã¨ã—ã¦æ‰±ã†) ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:994
msgid ""
"Because many of the traps are enabled, this context is useful for debugging."
msgstr "å¤šãã®ãƒˆãƒ©ãƒƒãƒ—ãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹ã®ã§ã€ãƒ‡ãƒãƒƒã‚°ã®éš›ã«ä¾¿åˆ©ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã™ã€‚"

#: ../../library/decimal.rst:999
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to "
":const:`ROUND_HALF_EVEN`.  All flags are cleared.  No traps are enabled (so "
"that exceptions are not raised during computations)."
msgstr "æ±ç”¨10é€²æ¼”ç®—ä»•æ§˜ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹æ¨™æº–ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä¸€ã¤ã§ã™ã€‚ç²¾åº¦ã¯ 9 æ¡ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã™ã€‚ä¸¸ã‚è¦å‰‡ã¯ :const:`ROUND_HALF_EVEN` ã§ã™ã€‚ã™ã¹ã¦ã®æ¼”ç®—çµæœãƒ•ãƒ©ã‚°ã¯ã‚¯ãƒªã‚¢ã•ã‚Œã¦ã„ã¾ã™ã€‚ãƒˆãƒ©ãƒƒãƒ—ã¯å…¨ã¦ç„¡åŠ¹(æ¼”ç®—ä¸­ã«ä¸€åˆ‡ä¾‹å¤–ã‚’é€å‡ºã—ãªã„) ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:1004
msgid ""
"Because the traps are disabled, this context is useful for applications that"
" prefer to have result value of :const:`NaN` or :const:`Infinity` instead of"
" raising exceptions.  This allows an application to complete a run in the "
"presence of conditions that would otherwise halt the program."
msgstr "ãƒˆãƒ©ãƒƒãƒ—ãŒç„¡åŠ¹ã«ãªã£ã¦ã„ã‚‹ã®ã§ã€ã‚¨ãƒ©ãƒ¼ã®ä¼´ã†æ¼”ç®—çµæœã‚’ :const:`NaN` ã‚„ :const:`Infinity` ã«ã—ã€ä¾‹å¤–ã‚’é€å‡ºã—ãªã„ã‚ˆã†ã«ã—ãŸã„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«å‘ã„ãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã™ã€‚ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½¿ã†ã¨ã€ä»–ã®å ´åˆã«ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒåœæ­¢ã—ã¦ã—ã¾ã†ã‚ˆã†ãªçŠ¶æ³ãŒã‚ã£ã¦ã‚‚å®Ÿè¡Œã‚’å®Œäº†ã•ã›ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:1012
msgid ""
"This context is used by the :class:`Context` constructor as a prototype for "
"new contexts.  Changing a field (such a precision) has the effect of "
"changing the default for new contexts created by the :class:`Context` "
"constructor."
msgstr ":class:`Context` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒæ–°ãŸãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆã™ã‚‹ã•ã„ã«é››å½¢ã«ã™ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã™ã€‚ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ (ç²¾åº¦ã®è¨­å®šãªã©) ã‚’å¤‰æ›´ã™ã‚‹ã¨ã€ :class:`Context` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒç”Ÿæˆã™ã‚‹æ–°ãŸãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å½±éŸ¿ã‚’åŠã¼ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1016
msgid ""
"This context is most useful in multi-threaded environments.  Changing one of"
" the fields before threads are started has the effect of setting system-wide"
" defaults.  Changing the fields after threads have started is not "
"recommended as it would require thread synchronization to prevent race "
"conditions."
msgstr "ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯ã€ä¸»ã«å¤šé‡ã‚¹ãƒ¬ãƒƒãƒ‰ç’°å¢ƒã§ä¾¿åˆ©ã§ã™ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é–‹å§‹ã™ã‚‹å‰ã«ä½•ã‚‰ã‹ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å¤‰æ›´ã—ã¦ãŠãã¨ã€ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã«åŠ¹æœã‚’åŠã¼ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é–‹å§‹ã—ãŸå¾Œã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å¤‰æ›´ã™ã‚‹ã¨ã€ç«¶åˆæ¡ä»¶ã‚’æŠ‘åˆ¶ã™ã‚‹ãŸã‚ã«ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’åŒæœŸåŒ–ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã§ã€æ¨å¥¨ã—ã¾ã›ã‚“ã€‚"

#: ../../library/decimal.rst:1021
msgid ""
"In single threaded environments, it is preferable to not use this context at"
" all.  Instead, simply create contexts explicitly as described below."
msgstr "å˜ä¸€ã‚¹ãƒ¬ãƒƒãƒ‰ã®ç’°å¢ƒã§ã¯ã€ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½¿ã‚ãªã„ã‚ˆã†è–¦ã‚ã¾ã™ã€‚ä¸‹ã§è¿°ã¹ã‚‹ã‚ˆã†ã«æ˜ç¤ºçš„ã«ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚"

#: ../../library/decimal.rst:1024
msgid ""
"The default values are precision=28, rounding=ROUND_HALF_EVEN, and enabled "
"traps for Overflow, InvalidOperation, and DivisionByZero."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å€¤ã¯ç²¾åº¦ 28 æ¡ã€ä¸¸ã‚è¦å‰‡ :const:`ROUND_HALF_EVEN` ã§ã€ãƒˆãƒ©ãƒƒãƒ— :const:`Overflow`, :const:`InvalidOperation`, ãŠã‚ˆã³ :const:`DivisionByZero` ãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:1027
msgid ""
"In addition to the three supplied contexts, new contexts can be created with"
" the :class:`Context` constructor."
msgstr "ä¸Šã«æŒ™ã’ãŸä¸‰ã¤ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«åŠ ãˆã€ :class:`Context` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½¿ã£ã¦æ–°ãŸãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆã§ãã¾ã™ã€‚"

#: ../../library/decimal.rst:1033
msgid ""
"Creates a new context.  If a field is not specified or is :const:`None`, the"
" default values are copied from the :const:`DefaultContext`.  If the *flags*"
" field is not specified or is :const:`None`, all flags are cleared."
msgstr "æ–°ãŸãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚ã‚ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„ã‹ :const:`None` ã§ã‚ã‚Œã°ã€ :const:`DefaultContext` ã‹ã‚‰ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚ *flags* ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¨­å®šã•ã‚Œã¦ã„ã„ã‹ :const:`None` ã®å ´åˆã«ã¯ã€å…¨ã¦ã®ãƒ•ãƒ©ã‚°ãŒã‚¯ãƒªã‚¢ã•ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:1037
msgid ""
"The *prec* field is a positive integer that sets the precision for "
"arithmetic operations in the context."
msgstr "*prec* ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯æ­£ã®æ•´æ•°ã§ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ãŠã‘ã‚‹ç®—è¡“æ¼”ç®—ã®è¨ˆç®—ç²¾åº¦ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1040
msgid "The *rounding* option is one of:"
msgstr "*rounding* ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ä»¥ä¸‹ã®ã©ã‚Œã‹ä¸€ã¤ã§ã™:"

#: ../../library/decimal.rst:1042
msgid ":const:`ROUND_CEILING` (towards :const:`Infinity`),"
msgstr ":const:`ROUND_CEILING` (:const:`Infinity` å¯„ã‚Šã®å€¤ã«ä¸¸ã‚ã‚‹),"

#: ../../library/decimal.rst:1043
msgid ":const:`ROUND_DOWN` (towards zero),"
msgstr ":const:`ROUND_DOWN` (ã‚¼ãƒ­å¯„ã‚Šã®å€¤ã«ä¸¸ã‚ã‚‹),"

#: ../../library/decimal.rst:1044
msgid ":const:`ROUND_FLOOR` (towards :const:`-Infinity`),"
msgstr ":const:`ROUND_FLOOR` (:const:`-Infinity` å¯„ã‚Šã®å€¤ã«ä¸¸ã‚ã‚‹),"

#: ../../library/decimal.rst:1045
msgid ":const:`ROUND_HALF_DOWN` (to nearest with ties going towards zero),"
msgstr ":const:`ROUND_HALF_DOWN` (è¿‘ã„æ–¹ã«ã€å¼•ãåˆ†ã‘ã¯ã‚¼ãƒ­æ–¹å‘ã«å‘ã‘ã¦ä¸¸ã‚ã‚‹),"

#: ../../library/decimal.rst:1046
msgid ""
":const:`ROUND_HALF_EVEN` (to nearest with ties going to nearest even "
"integer),"
msgstr ":const:`ROUND_HALF_EVEN` (è¿‘ã„æ–¹ã«ã€å¼•ãåˆ†ã‘ã¯å¶æ•°æ•´æ•°æ–¹å‘ã«å‘ã‘ã¦ä¸¸ã‚ã‚‹),"

#: ../../library/decimal.rst:1047
msgid ":const:`ROUND_HALF_UP` (to nearest with ties going away from zero), or"
msgstr ":const:`ROUND_HALF_UP` (è¿‘ã„æ–¹ã«ã€å¼•ãåˆ†ã‘ã¯ã‚¼ãƒ­ã‹ã‚‰é ã„æ–¹å‘ã«å‘ã‘ã¦ä¸¸ã‚ã‚‹),"

#: ../../library/decimal.rst:1048
msgid ":const:`ROUND_UP` (away from zero)."
msgstr ":const:`ROUND_UP` (ã‚¼ãƒ­ã‹ã‚‰é ã„å€¤ã«ä¸¸ã‚ã‚‹), ã¾ãŸã¯"

#: ../../library/decimal.rst:1049
msgid ""
":const:`ROUND_05UP` (away from zero if last digit after rounding towards "
"zero would have been 0 or 5; otherwise towards zero)"
msgstr ":const:`ROUND_05UP` (ã‚¼ãƒ­æ–¹å‘ã«ä¸¸ã‚ãŸå¾Œã®æœ€å¾Œã®æ¡ãŒ 0 ã¾ãŸã¯ 5 ãªã‚‰ã°ã‚¼ãƒ­ã‹ã‚‰é ã„æ–¹å‘ã«ã€ãã†ã§ãªã‘ã‚Œã°ã‚¼ãƒ­æ–¹å‘ã«ä¸¸ã‚ã‚‹)"

#: ../../library/decimal.rst:1052
msgid ""
"The *traps* and *flags* fields list any signals to be set. Generally, new "
"contexts should only set traps and leave the flags clear."
msgstr "*traps* ãŠã‚ˆã³ *flags* ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¯ã€ã‚»ãƒƒãƒˆã—ãŸã„ã‚·ã‚°ãƒŠãƒ«ã‚’åˆ—æŒ™ã—ã¾ã™ã€‚ä¸€èˆ¬çš„ã«ã€æ–°ãŸãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆã™ã‚‹ã¨ãã«ã¯ãƒˆãƒ©ãƒƒãƒ—ã ã‘ã‚’è¨­å®šã—ã€ãƒ•ãƒ©ã‚°ã¯ã‚¯ãƒªã‚¢ã—ã¦ãŠãã¾ã™ã€‚"

#: ../../library/decimal.rst:1055
msgid ""
"The *Emin* and *Emax* fields are integers specifying the outer limits "
"allowable for exponents."
msgstr "*Emin* ãŠã‚ˆã³ *Emax* ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¯ã€æŒ‡æ•°ã®å¤–é™ã‚’æ•´æ•°ã§æŒ‡å®šã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1058
msgid ""
"The *capitals* field is either :const:`0` or :const:`1` (the default). If "
"set to :const:`1`, exponents are printed with a capital :const:`E`; "
"otherwise, a lowercase :const:`e` is used: :const:`Decimal('6.02e+23')`."
msgstr "*capitals* ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ :const:`0` ã¾ãŸã¯ :const:`1` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã«ã—ã¾ã™ã€‚ :const:`1` ã«è¨­å®šã™ã‚‹ã¨ã€æŒ‡æ•°è¨˜å·ã‚’å¤§æ–‡å­— :const:`E` ã§å‡ºåŠ›ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ :const:`Decimal('6.02e+23')` ã®ã‚ˆã†ã« :const:`e` ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:1062
msgid "The :const:`ROUND_05UP` rounding mode was added."
msgstr ":const:`ROUND_05UP` ä¸¸ã‚ãƒ¢ãƒ¼ãƒ‰ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/decimal.rst:1065
msgid ""
"The :class:`Context` class defines several general purpose methods as well "
"as a large number of methods for doing arithmetic directly in a given "
"context. In addition, for each of the :class:`Decimal` methods described "
"above (with the exception of the :meth:`adjusted` and :meth:`as_tuple` "
"methods) there is a corresponding :class:`Context` method.  For example, for"
" a :class:`Context` instance ``C`` and :class:`Decimal` instance ``x``, "
"``C.exp(x)`` is equivalent to ``x.exp(context=C)``.  Each :class:`Context` "
"method accepts a Python integer (an instance of :class:`int` or "
":class:`long`) anywhere that a Decimal instance is accepted."
msgstr ":class:`Context` ã‚¯ãƒ©ã‚¹ã§ã¯ã€ã„ãã¤ã‹ã®æ±ç”¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ä»–ã€ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ç®—è¡“æ¼”ç®—ã‚’ç›´æ¥è¡Œã†ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ•°å¤šãå®šç¾©ã—ã¦ã„ã¾ã™ã€‚åŠ ãˆã¦ã€ :class:`Decimal` ã®å„ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¤ã„ã¦ (:meth:`adjusted` ãŠã‚ˆã³ :meth:`as_tuple` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¾‹å¤–ã¨ã—ã¦) å¯¾å¿œã™ã‚‹ :class:`Context` ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå­˜åœ¨ã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€ :class:`Context` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹  ``C`` ã¨ :class:`Decimal` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ ``x`` ã«å¯¾ã—ã¦ã€ ``C.exp(x)`` ã¯ ``x.exp(context=C)`` ã¨ç­‰ä¾¡ã§ã™ã€‚ãã‚Œãã‚Œã® :class:`Context` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€Decimal ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒå—ã‘ä»˜ã‘ã‚‰ã‚Œã‚‹ã¨ã“ã‚ãªã‚‰ã©ã“ã§ã‚‚ã€Python ã®æ•´æ•° (:class:`int` ã¾ãŸã¯ :class:`long` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹) ã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚"

#: ../../library/decimal.rst:1078
msgid "Resets all of the flags to :const:`0`."
msgstr "ãƒ•ãƒ©ã‚°ã‚’å…¨ã¦ :const:`0` ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1082
msgid "Return a duplicate of the context."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®è¤‡è£½ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1086
msgid "Return a copy of the Decimal instance num."
msgstr "Decimal ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ num ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1090
msgid ""
"Creates a new Decimal instance from *num* but using *self* as context. "
"Unlike the :class:`Decimal` constructor, the context precision, rounding "
"method, flags, and traps are applied to the conversion."
msgstr "*self* ã‚’ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨ã™ã‚‹æ–°ãŸãª Decimal ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ *num* ã‹ã‚‰ç”Ÿæˆã—ã¾ã™ã€‚ :class:`Decimal` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨é•ã„ã€æ•°å€¤ã‚’å¤‰æ›ã™ã‚‹éš›ã«ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ç²¾åº¦ã€å€¤ä¸¸ã‚æ–¹æ³•ã€ãƒ•ãƒ©ã‚°ã€ãƒˆãƒ©ãƒƒãƒ—ã‚’é©ç”¨ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1094
msgid ""
"This is useful because constants are often given to a greater precision than"
" is needed by the application.  Another benefit is that rounding immediately"
" eliminates unintended effects from digits beyond the current precision. In "
"the following example, using unrounded inputs means that adding zero to a "
"sum can change the result:"
msgstr "å®šæ•°å€¤ã¯ã—ã°ã—ã°ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®è¦æ±‚ã‚ˆã‚Šã‚‚é«˜ã„ç²¾åº¦ã‚’æŒã£ã¦ã„ã‚‹ãŸã‚ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå½¹ã«ç«‹ã¡ã¾ã™ã€‚ã¾ãŸã€å€¤ä¸¸ã‚ã‚’å³åº§ã«è¡Œã†ãŸã‚ã€ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã€å…¥åŠ›å€¤ã«å€¤ä¸¸ã‚ã‚’è¡Œã‚ãªã„ãŸã‚ã«åˆè¨ˆå€¤ã«ã‚¼ãƒ­ã®åŠ ç®—ã‚’è¿½åŠ ã™ã‚‹ã ã‘ã§çµæœãŒå¤‰ã‚ã£ã¦ã—ã¾ã†ã¨ã„ã£ãŸã€ç¾åœ¨ã®ç²¾åº¦ã‚ˆã‚Šã‚‚ç´°ã‹ã„å€¤ã®å½±éŸ¿ãŒç´›ã‚Œè¾¼ã‚€å•é¡Œã‚’é˜²ã’ã‚‹ã¨ã„ã†æ©æµã‚‚ã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®ä¾‹ã¯ã€ä¸¸ã‚ã‚‰ã‚Œã¦ã„ãªã„å…¥åŠ›ã‚’ä½¿ã†ã¨ã„ã†ã“ã¨ã¯å’Œã«ã‚¼ãƒ­ã‚’åŠ ãˆã‚‹ã¨çµæœãŒå¤‰ã‚ã‚Šå¾—ã‚‹ã¨ã„ã†è¦‹æœ¬ã§ã™:"

#: ../../library/decimal.rst:1108
msgid ""
"This method implements the to-number operation of the IBM specification. If "
"the argument is a string, no leading or trailing whitespace is permitted."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ IBM ä»•æ§˜ã® to-number æ¼”ç®—ã‚’å®Ÿè£…ã—ãŸã‚‚ã®ã§ã™ã€‚å¼•æ•°ãŒæ–‡å­—åˆ—ã®å ´åˆã€å‰ã‚„å¾Œã‚ã«ä½™è¨ˆãªç©ºç™½ã‚’ä»˜ã‘ã‚‹ã“ã¨ã¯è¨±ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/decimal.rst:1114
msgid ""
"Creates a new Decimal instance from a float *f* but rounding using *self* as"
" the context.  Unlike the :meth:`Decimal.from_float` class method, the "
"context precision, rounding method, flags, and traps are applied to the "
"conversion."
msgstr "æµ®å‹•å°æ•°ç‚¹æ•° *f* ã‹ã‚‰æ–°ã—ã„ Decimal ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ãŒã€ *self* ã‚’ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦ä¸¸ã‚ã¾ã™ã€‚ :meth:`Decimal.from_float` ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã¯é•ã„ã€å¤‰æ›ã«ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ç²¾åº¦ã€ä¸¸ã‚ãƒ¡ã‚½ãƒƒãƒ‰ã€ãƒ•ãƒ©ã‚°ã€ãã—ã¦ãƒˆãƒ©ãƒƒãƒ—ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:1134
msgid ""
"Returns a value equal to ``Emin - prec + 1`` which is the minimum exponent "
"value for subnormal results.  When underflow occurs, the exponent is set to "
":const:`Etiny`."
msgstr "``Emin - prec + 1`` ã«ç­‰ã—ã„å€¤ã‚’è¿”ã—ã¾ã™ã€‚æ¼”ç®—çµæœã®åŠ£åŒ–ãŒèµ·ã“ã‚‹æ¡ã®æœ€å°å€¤ã§ã™ã€‚ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ•ãƒ­ãƒ¼ãŒèµ·ããŸå ´åˆã€æŒ‡æ•°ã¯ :const:`Etiny` ã«è¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:1141
msgid "Returns a value equal to ``Emax - prec + 1``."
msgstr "``Emax - prec + 1`` ã«ç­‰ã—ã„å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1143
msgid ""
"The usual approach to working with decimals is to create :class:`Decimal` "
"instances and then apply arithmetic operations which take place within the "
"current context for the active thread.  An alternative approach is to use "
"context methods for calculating within a specific context.  The methods are "
"similar to those for the :class:`Decimal` class and are only briefly "
"recounted here."
msgstr ":class:`Decimal` ã‚’ä½¿ã£ãŸå‡¦ç†ã‚’è¡Œã†å ´åˆã€é€šå¸¸ã¯ :class:`Decimal` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¦ã€ç®—è¡“æ¼”ç®—ã‚’é©ç”¨ã™ã‚‹ã¨ã„ã†ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’ã¨ã‚Šã¾ã™ã€‚æ¼”ç®—ã¯ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¹ãƒ¬ãƒƒãƒ‰ã«ãŠã‘ã‚‹ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä¸‹ã§è¡Œã‚ã‚Œã¾ã™ã€‚ã‚‚ã†ä¸€ã¤ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ãŸç‰¹å®šã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä¸‹ã§ã®è¨ˆç®—ã§ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :class:`Decimal` ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ä¼¼ã¦ã„ã‚‹ã®ã§ã€ã“ã“ã§ã¯ç°¡å˜ãªèª¬æ˜ã«ã¨ã©ã‚ã¾ã™ã€‚"

#: ../../library/decimal.rst:1153
msgid "Returns the absolute value of *x*."
msgstr "*x* ã®çµ¶å¯¾å€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1158
msgid "Return the sum of *x* and *y*."
msgstr "*x* ã¨ *y* ã®å’Œã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1163
msgid "Returns the same Decimal object *x*."
msgstr "åŒã˜ Decimal ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *x* ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1168
msgid "Compares *x* and *y* numerically."
msgstr "*x* ã¨ *y* ã‚’æ•°å€¤ã¨ã—ã¦æ¯”è¼ƒã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1173
msgid "Compares the values of the two operands numerically."
msgstr "äºŒã¤ã®æ¼”ç®—å¯¾è±¡ã®å€¤ã‚’æ•°å€¤ã¨ã—ã¦æ¯”è¼ƒã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1178
msgid "Compares two operands using their abstract representation."
msgstr "äºŒã¤ã®æ¼”ç®—å¯¾è±¡ã‚’æŠ½è±¡çš„ãªè¡¨ç¾ã‚’ä½¿ã£ã¦æ¯”è¼ƒã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1183
msgid ""
"Compares two operands using their abstract representation, ignoring sign."
msgstr "äºŒã¤ã®æ¼”ç®—å¯¾è±¡ã‚’æŠ½è±¡çš„ãªè¡¨ç¾ã‚’ä½¿ã„ç¬¦å·ã‚’ç„¡è¦–ã—ã¦æ¯”è¼ƒã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1188
msgid "Returns a copy of *x* with the sign set to 0."
msgstr "*x* ã®ã‚³ãƒ”ãƒ¼ã®ç¬¦å·ã‚’ 0 ã«ã‚»ãƒƒãƒˆã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1193
msgid "Returns a copy of *x* with the sign inverted."
msgstr "*x* ã®ã‚³ãƒ”ãƒ¼ã®ç¬¦å·ã‚’åè»¢ã—ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1198
msgid "Copies the sign from *y* to *x*."
msgstr "*y* ã‹ã‚‰ *x* ã«ç¬¦å·ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1203
msgid "Return *x* divided by *y*."
msgstr "*x* ã‚’ *y* ã§é™¤ç®—ã—ãŸå€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1208
msgid "Return *x* divided by *y*, truncated to an integer."
msgstr "*x* ã‚’ *y* ã§é™¤ç®—ã—ãŸå€¤ã‚’æ•´æ•°ã«åˆ‡ã‚Šæ¨ã¦ã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1213
msgid "Divides two numbers and returns the integer part of the result."
msgstr "äºŒã¤ã®æ•°å€¤é–“ã®é™¤ç®—ã‚’è¡Œã„ã€çµæœã®æ•´æ•°éƒ¨ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1218
msgid "Returns `e ** x`."
msgstr "`e ** x` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1223
msgid "Returns *x* multiplied by *y*, plus *z*."
msgstr "*x* ã‚’ *y* å€ã—ãŸã‚‚ã®ã« *z* ã‚’åŠ ãˆã¦è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1228
msgid "Returns ``True`` if *x* is canonical; otherwise returns ``False``."
msgstr "*x* ãŒæ¨™æº–çš„(canonical)ãªã‚‰ã° ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° ``False`` ã§ã™ã€‚"

#: ../../library/decimal.rst:1233
msgid "Returns ``True`` if *x* is finite; otherwise returns ``False``."
msgstr "*x* ãŒæœ‰é™ãªã‚‰ã° ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° ``False`` ã§ã™ã€‚"

#: ../../library/decimal.rst:1238
msgid "Returns ``True`` if *x* is infinite; otherwise returns ``False``."
msgstr "*x* ãŒç„¡é™ãªã‚‰ã° ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° ``False`` ã§ã™ã€‚"

#: ../../library/decimal.rst:1243
msgid ""
"Returns ``True`` if *x* is a qNaN or sNaN; otherwise returns ``False``."
msgstr "*x* ãŒ qNaN ã‹ sNaN ã§ã‚ã‚Œã° ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° ``False`` ã§ã™ã€‚"

#: ../../library/decimal.rst:1248
msgid ""
"Returns ``True`` if *x* is a normal number; otherwise returns ``False``."
msgstr "*x* ãŒé€šå¸¸ã®æ•°ãªã‚‰ã° ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° ``False`` ã§ã™ã€‚"

#: ../../library/decimal.rst:1253
msgid "Returns ``True`` if *x* is a quiet NaN; otherwise returns ``False``."
msgstr "*x* ãŒç„¡è¨€ NaN ã§ã‚ã‚Œã° ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° ``False`` ã§ã™ã€‚"

#: ../../library/decimal.rst:1258
msgid "Returns ``True`` if *x* is negative; otherwise returns ``False``."
msgstr "*x* ãŒè² ã®æ•°ã§ã‚ã‚Œã° ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° ``False`` ã§ã™ã€‚"

#: ../../library/decimal.rst:1263
msgid ""
"Returns ``True`` if *x* is a signaling NaN; otherwise returns ``False``."
msgstr "*x* ãŒç™ºä¿¡ NaN ã§ã‚ã‚Œã° ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° ``False`` ã§ã™ã€‚"

#: ../../library/decimal.rst:1268
msgid "Returns ``True`` if *x* is subnormal; otherwise returns ``False``."
msgstr "*x* ãŒéæ­£è¦æ•°ã§ã‚ã‚Œã° ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° ``False`` ã§ã™ã€‚"

#: ../../library/decimal.rst:1273
msgid "Returns ``True`` if *x* is a zero; otherwise returns ``False``."
msgstr "*x* ãŒã‚¼ãƒ­ã§ã‚ã‚Œã° ``True`` ã‚’è¿”ã—ã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã° ``False`` ã§ã™ã€‚"

#: ../../library/decimal.rst:1278
msgid "Returns the natural (base e) logarithm of *x*."
msgstr "*x* ã®è‡ªç„¶å¯¾æ•°(åº• e ã®å¯¾æ•°)ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1283
msgid "Returns the base 10 logarithm of *x*."
msgstr "*x* ã®åº• 10 ã®å¯¾æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1288
msgid "Returns the exponent of the magnitude of the operand's MSD."
msgstr "æ¼”ç®—å¯¾è±¡ã® MSD ã®å¤§ãã•ã®æŒ‡æ•°éƒ¨ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1293
msgid "Applies the logical operation *and* between each operand's digits."
msgstr "ãã‚Œãã‚Œã®æ¡ã«è«–ç†æ¼”ç®— *and* ã‚’å½“ã¦ã¯ã‚ã¾ã™ã€‚"

#: ../../library/decimal.rst:1298
msgid "Invert all the digits in *x*."
msgstr "*x* ã®å…¨ã¦ã®æ¡ã‚’åè»¢ã•ã›ã¾ã™ã€‚"

#: ../../library/decimal.rst:1303
msgid "Applies the logical operation *or* between each operand's digits."
msgstr "ãã‚Œãã‚Œã®æ¡ã«è«–ç†æ¼”ç®— *or* ã‚’å½“ã¦ã¯ã‚ã¾ã™ã€‚"

#: ../../library/decimal.rst:1308
msgid "Applies the logical operation *xor* between each operand's digits."
msgstr "ãã‚Œãã‚Œã®æ¡ã«è«–ç†æ¼”ç®— *xor* ã‚’å½“ã¦ã¯ã‚ã¾ã™ã€‚"

#: ../../library/decimal.rst:1313
msgid "Compares two values numerically and returns the maximum."
msgstr "äºŒã¤ã®å€¤ã‚’æ•°å€¤ã¨ã—ã¦æ¯”è¼ƒã—ã€å¤§ãã„ã»ã†ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1318 ../../library/decimal.rst:1328
msgid "Compares the values numerically with their sign ignored."
msgstr "å€¤ã‚’ç¬¦å·ã‚’ç„¡è¦–ã—ã¦æ•°å€¤ã¨ã—ã¦æ¯”è¼ƒã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1323
msgid "Compares two values numerically and returns the minimum."
msgstr "äºŒã¤ã®å€¤ã‚’æ•°å€¤ã¨ã—ã¦æ¯”è¼ƒã—ã€å°ã•ã„ã»ã†ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1333
msgid "Minus corresponds to the unary prefix minus operator in Python."
msgstr "Python ã«ãŠã‘ã‚‹å˜é …ãƒã‚¤ãƒŠã‚¹æ¼”ç®—å­ã«å¯¾å¿œã™ã‚‹æ¼”ç®—ã§ã™ã€‚"

#: ../../library/decimal.rst:1338
msgid "Return the product of *x* and *y*."
msgstr "*x* ã¨ *y* ã®ç©ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1343
msgid "Returns the largest representable number smaller than *x*."
msgstr "*x* ã‚ˆã‚Šå°ã•ã„æœ€å¤§ã®è¡¨ç¾å¯èƒ½ãªæ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1348
msgid "Returns the smallest representable number larger than *x*."
msgstr "*x* ã‚ˆã‚Šå¤§ãã„æœ€å°ã®è¡¨ç¾å¯èƒ½ãªæ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1353
msgid "Returns the number closest to *x*, in direction towards *y*."
msgstr "*x* ã« *y* ã®æ–¹å‘ã«å‘ã‹ã£ã¦æœ€ã‚‚è¿‘ã„æ•°ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1358
msgid "Reduces *x* to its simplest form."
msgstr "*x* ã‚’ã‚‚ã£ã¨ã‚‚å˜ç´”ãªå½¢ã«ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1363
msgid "Returns an indication of the class of *x*."
msgstr "*x* ã®ã‚¯ãƒ©ã‚¹ã‚’æŒ‡ã—ç¤ºã™ã‚‚ã®ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1368
msgid ""
"Plus corresponds to the unary prefix plus operator in Python.  This "
"operation applies the context precision and rounding, so it is *not* an "
"identity operation."
msgstr "Python ã«ãŠã‘ã‚‹å˜é …ã®ãƒ—ãƒ©ã‚¹æ¼”ç®—å­ã«å¯¾å¿œã™ã‚‹æ¼”ç®—ã§ã™ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ãŠã‘ã‚‹ç²¾åº¦ã‚„å€¤ä¸¸ã‚ã‚’é©ç”¨ã™ã‚‹ã®ã§ã€ç­‰å€¤ (identity) æ¼”ç®—ã¨ã¯ *é•ã„ã¾ã™*ã€‚"

#: ../../library/decimal.rst:1375
msgid ""
"Return ``x`` to the power of ``y``, reduced modulo ``modulo`` if given."
msgstr "``x`` ã® ``y`` ä¹—ã‚’è¨ˆç®—ã—ã¾ã™ã€‚``modulo`` ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚Œã°ãƒ¢ã‚¸ãƒ¥ãƒ­ã‚’å–ã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:1377
msgid ""
"With two arguments, compute ``x**y``.  If ``x`` is negative then ``y`` must "
"be integral.  The result will be inexact unless ``y`` is integral and the "
"result is finite and can be expressed exactly in 'precision' digits. The "
"result should always be correctly rounded, using the rounding mode of the "
"current thread's context."
msgstr "äºŒå¼•æ•°ã§ã‚ã‚Œã° ``x**y`` ã‚’è¨ˆç®—ã—ã¾ã™ã€‚ ``x`` ãŒè² ã§ã‚ã‚Œã° ``y`` ã¯æ•´ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚çµæœã¯ ``y`` ãŒæ•´æ•°ã§ã‚ã£ã¦çµæœãŒæœ‰é™ã«ãªã‚Š 'precision' æ¡ã§æ­£ç¢ºã«è¡¨ç¾ã§ãã‚‹ã®ã§ãªã‘ã‚Œã°ä¸æ­£ç¢ºã«ãªã‚Šã¾ã™ã€‚ãã®çµæœã¯ç¾ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä¸¸ã‚ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦æ­£ã—ãä¸¸ã‚ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:1383
msgid ""
"With three arguments, compute ``(x**y) % modulo``.  For the three argument "
"form, the following restrictions on the arguments hold:"
msgstr "ä¸‰å¼•æ•°ã§ã‚ã‚Œã° ``(x**y) % modulo`` ã‚’è¨ˆç®—ã—ã¾ã™ã€‚ã“ã®å½¢å¼ã®å ´åˆã€ä»¥ä¸‹ã®åˆ¶é™ãŒå¼•æ•°ã«æ›ã‹ã‚Šã¾ã™:"

#: ../../library/decimal.rst:1386
msgid "all three arguments must be integral"
msgstr "å…¨ã¦ã®å¼•æ•°ã¯æ•´"

#: ../../library/decimal.rst:1387
msgid "``y`` must be nonnegative"
msgstr "``y`` ã¯éè² ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„"

#: ../../library/decimal.rst:1388
msgid "at least one of ``x`` or ``y`` must be nonzero"
msgstr "``x`` ã¨ ``y`` ã®å°‘ãªãã¨ã‚‚ã©ã¡ã‚‰ã‹ã¯ã‚¼ãƒ­ã§ãªã„"

#: ../../library/decimal.rst:1389
msgid "``modulo`` must be nonzero and have at most 'precision' digits"
msgstr "``modulo`` ã¯éé›¶ã§å¤§ããã¦ã‚‚ 'precision' æ¡"

#: ../../library/decimal.rst:1391
msgid ""
"The value resulting from ``Context.power(x, y, modulo)`` is equal to the "
"value that would be obtained by computing ``(x**y) % modulo`` with unbounded"
" precision, but is computed more efficiently.  The exponent of the result is"
" zero, regardless of the exponents of ``x``, ``y`` and ``modulo``.  The "
"result is always exact."
msgstr "``Context.power(x, y, modulo)`` ã§å¾—ã‚‰ã‚Œã‚‹å€¤ã¯ ``(x**y) % modulo`` ã‚’ç²¾åº¦ç„¡åˆ¶é™ã§è¨ˆç®—ã—ã¦å¾—ã‚‰ã‚Œã‚‹ã‚‚ã®ã¨åŒã˜å€¤ã§ã™ãŒã€ã‚ˆã‚ŠåŠ¹ç‡çš„ã«è¨ˆç®—ã•ã‚Œã¾ã™ã€‚çµæœã®æŒ‡æ•°ã¯ ``x``, ``y``, ``modulo`` ã®æŒ‡æ•°ã«é–¢ä¿‚ãªãã‚¼ãƒ­ã§ã™ã€‚ã“ã®è¨ˆç®—ã¯å¸¸ã«æ­£ç¢ºã§ã™ã€‚"

#: ../../library/decimal.rst:1398
msgid ""
"``y`` may now be nonintegral in ``x**y``. Stricter requirements for the "
"three-argument version."
msgstr "``x**y`` å½¢å¼ã§ ``y`` ãŒéæ•´æ•°ã§æ§‹ã‚ãªã„ã“ã¨ã«ãªã‚Šã¾ã—ãŸã€‚ä¸‰å¼•æ•°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒã‚ˆã‚Šå³æ ¼ãªè¦æ±‚ã‚’ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/decimal.rst:1405
msgid "Returns a value equal to *x* (rounded), having the exponent of *y*."
msgstr "*x* ã«å€¤ä¸¸ã‚ã‚’é©ç”¨ã—ã€æŒ‡æ•°ã‚’ *y* ã«ã—ãŸå€¤ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1410
msgid "Just returns 10, as this is Decimal, :)"
msgstr "å˜ã« 10 ã‚’è¿”ã—ã¾ã™ã€‚ä½•ã›åé€²ã§ã™ã‹ã‚‰ :)"

#: ../../library/decimal.rst:1415
msgid "Returns the remainder from integer division."
msgstr "æ•´æ•°é™¤ç®—ã®å‰°ä½™ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1417
msgid ""
"The sign of the result, if non-zero, is the same as that of the original "
"dividend."
msgstr "å‰°ä½™ãŒã‚¼ãƒ­ã§ãªã„å ´åˆã€ç¬¦å·ã¯å‰²ã‚‰ã‚Œã‚‹æ•°ã®ç¬¦å·ã¨åŒã˜ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:1422
msgid ""
"Returns ``x - y * n``, where *n* is the integer nearest the exact value of "
"``x / y`` (if the result is 0 then its sign will be the sign of *x*)."
msgstr "``x - y * n`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã“ã§ *n* ã¯ ``x / y`` ã®æ­£ç¢ºãªå€¤ã«ä¸€ç•ªè¿‘ã„æ•´æ•°ã§ã™ (ã“ã®çµæœãŒ 0 ãªã‚‰ã°ãã®ç¬¦å·ã¯ *x* ã®ç¬¦å·ã¨åŒã˜ã§ã™)ã€‚"

#: ../../library/decimal.rst:1428
msgid "Returns a rotated copy of *x*, *y* times."
msgstr "*x* ã® *y* å›å·¡å›ã—ãŸã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1433
msgid "Returns ``True`` if the two operands have the same exponent."
msgstr "2ã¤ã®æ¼”ç®—å¯¾è±¡ãŒåŒã˜æŒ‡æ•°ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã« ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1438
msgid "Returns the first operand after adding the second value its exp."
msgstr "ä¸€ã¤ã‚ã®æ¼”ç®—å¯¾è±¡ã®æŒ‡æ•°éƒ¨ã«äºŒã¤ã‚ã®å€¤ã‚’åŠ ãˆãŸã‚‚ã®ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1443
msgid "Returns a shifted copy of *x*, *y* times."
msgstr "*x* ã‚’ *y* å›ã‚·ãƒ•ãƒˆã—ãŸã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1448
msgid "Square root of a non-negative number to context precision."
msgstr "*x* ã®å¹³æ–¹æ ¹ã‚’ç²¾åº¦ã„ã£ã±ã„ã¾ã§æ±‚ã‚ã¾ã™ã€‚"

#: ../../library/decimal.rst:1453
msgid "Return the difference between *x* and *y*."
msgstr "*x* ã¨ *y* ã®é–“ã®å·®ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1467
msgid "Rounds to an integer."
msgstr "æœ€è¿‘å‚ã®æ•´æ•°ã«å€¤ã‚’ä¸¸ã‚ã¾ã™ã€‚"

#: ../../library/decimal.rst:1472
msgid "Converts a number to a string using scientific notation."
msgstr "æ•°å€¤ã‚’ç§‘å­¦è¡¨è¨˜ã§æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1480
msgid "Signals"
msgstr "ã‚·ã‚°ãƒŠãƒ«"

#: ../../library/decimal.rst:1482
msgid ""
"Signals represent conditions that arise during computation. Each corresponds"
" to one context flag and one context trap enabler."
msgstr "ã‚·ã‚°ãƒŠãƒ«ã¯ã€è¨ˆç®—ä¸­ã«ç”Ÿã˜ãŸæ§˜ã€…ãªã‚¨ãƒ©ãƒ¼æ¡ä»¶ã‚’è¡¨ç¾ã—ã¾ã™ã€‚å„ã€…ã®ã‚·ã‚°ãƒŠãƒ«ã¯ä¸€ã¤ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ•ãƒ©ã‚°ã¨ä¸€ã¤ã®ãƒˆãƒ©ãƒƒãƒ—ã‚¤ãƒãƒ¼ãƒ–ãƒ©ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:1485
msgid ""
"The context flag is set whenever the condition is encountered. After the "
"computation, flags may be checked for informational purposes (for instance, "
"to determine whether a computation was exact). After checking the flags, be "
"sure to clear all flags before starting the next computation."
msgstr "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ•ãƒ©ã‚°ã¯ã€è©²å½“ã™ã‚‹ã‚¨ãƒ©ãƒ¼æ¡ä»¶ã«é­é‡ã™ã‚‹ãŸã³ã«ã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚æ¼”ç®—å¾Œã«ãƒ•ãƒ©ã‚°ã‚’èª¿ã¹ã‚Œã°ã€æ¼”ç®—ã«é–¢ã™ã‚‹æƒ…å ± (ä¾‹ãˆã°è¨ˆç®—ãŒå³å¯†ã ã£ãŸã‹ã©ã†ã‹) ãŒã‚ã‹ã‚Šã¾ã™ã€‚ãƒ•ãƒ©ã‚°ã‚’èª¿ã¹ãŸã‚‰ã€æ¬¡ã®è¨ˆç®—ã‚’å§‹ã‚ã‚‹å‰ã«ãƒ•ãƒ©ã‚°ã‚’å…¨ã¦ã‚¯ãƒªã‚¢ã™ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/decimal.rst:1490
msgid ""
"If the context's trap enabler is set for the signal, then the condition "
"causes a Python exception to be raised.  For example, if the "
":class:`DivisionByZero` trap is set, then a :exc:`DivisionByZero` exception "
"is raised upon encountering the condition."
msgstr "ã‚ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ãƒˆãƒ©ãƒƒãƒ—ã‚¤ãƒãƒ¼ãƒ–ãƒ©ãŒã‚ã‚‹ã‚·ã‚°ãƒŠãƒ«ã«å¯¾ã—ã¦ã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã€è©²å½“ã™ã‚‹ã‚¨ãƒ©ãƒ¼æ¡ä»¶ãŒç”Ÿã˜ã‚‹ã¨ Python ã®ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ :class:`DivisionByZero` ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã¨ã€ã‚¨ãƒ©ãƒ¼æ¡ä»¶ãŒç”Ÿã˜ãŸéš›ã« :exc:`DivisionByZero` ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1498
msgid "Altered an exponent to fit representation constraints."
msgstr "å€¤ã®è¡¨ç¾ä¸Šã®åˆ¶é™ã«æ²¿ã‚ã›ã‚‹ãŸã‚ã«æŒ‡æ•°éƒ¨ãŒå¤‰æ›´ã•ã‚ŒãŸã“ã¨ã‚’é€šçŸ¥ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1500
msgid ""
"Typically, clamping occurs when an exponent falls outside the context's "
":attr:`Emin` and :attr:`Emax` limits.  If possible, the exponent is reduced "
"to fit by adding zeros to the coefficient."
msgstr "é€šå¸¸ã€ã‚¯ãƒ©ãƒ³ãƒ— (clamp) ã¯ã€æŒ‡æ•°éƒ¨ãŒã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ãŠã‘ã‚‹æŒ‡æ•°æ¡ã®åˆ¶é™å€¤ :attr:`Emin` ãŠã‚ˆã³ :attr:`Emax` ã‚’è¶ŠãˆãŸå ´åˆã«ç™ºç”Ÿã—ã¾ã™ã€‚å¯èƒ½ãªå ´åˆã«ã¯ã€ä¿‚æ•°éƒ¨ã«ã‚¼ãƒ­ã‚’åŠ ãˆãŸè¡¨ç¾ã«åˆã‚ã›ã¦æŒ‡æ•°éƒ¨ã‚’æ¸›ã‚‰ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1507
msgid "Base class for other signals and a subclass of :exc:`ArithmeticError`."
msgstr "ä»–ã®ã‚·ã‚°ãƒŠãƒ«ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã€ :exc:`ArithmeticError` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/decimal.rst:1512
msgid "Signals the division of a non-infinite number by zero."
msgstr "æœ‰é™å€¤ã‚’ã‚¼ãƒ­ã§é™¤ç®—ã—ãŸã¨ãã®ã‚·ã‚°ãƒŠãƒ«ã§ã™ã€‚"

#: ../../library/decimal.rst:1514
msgid ""
"Can occur with division, modulo division, or when raising a number to a "
"negative power.  If this signal is not trapped, returns :const:`Infinity` or"
" :const:`-Infinity` with the sign determined by the inputs to the "
"calculation."
msgstr "é™¤ç®—ã‚„ãƒ¢ã‚¸ãƒ¥ãƒ­é™¤ç®—ã€æ•°ã‚’è² ã®å€¤ã§ç´¯ä¹—ã—ãŸå ´åˆã«èµ·ãã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚·ã‚°ãƒŠãƒ«ã‚’ãƒˆãƒ©ãƒƒãƒ—ã—ãªã„å ´åˆã€æ¼”ç®—çµæœã¯ :const:`Infinity` ã¾ãŸã¯ :const:`-Infinity` ã«ãªã‚Šã€ãã®ç¬¦å·ã¯æ¼”ç®—ã«ä½¿ã£ãŸå…¥åŠ›ã«åŸºã¥ã„ã¦æ±ºã¾ã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:1521
msgid "Indicates that rounding occurred and the result is not exact."
msgstr "å€¤ã®ä¸¸ã‚ã«ã‚ˆã£ã¦æ¼”ç®—çµæœã‹ã‚‰å³å¯†ã•ãŒå¤±ã‚ã‚ŒãŸã“ã¨ã‚’é€šçŸ¥ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1523
msgid ""
"Signals when non-zero digits were discarded during rounding. The rounded "
"result is returned.  The signal flag or trap is used to detect when results "
"are inexact."
msgstr "ã“ã®ã‚·ã‚°ãƒŠãƒ«ã¯å€¤ä¸¸ã‚æ“ä½œä¸­ã«ã‚¼ãƒ­ã§ãªã„æ¡ã‚’ç„¡è¦–ã—ãŸéš›ã«ç”Ÿã˜ã¾ã™ã€‚æ¼”ç®—çµæœã¯å€¤ä¸¸ã‚å¾Œã®å€¤ã§ã™ã€‚ã‚·ã‚°ãƒŠãƒ«ã®ãƒ•ãƒ©ã‚°ã‚„ãƒˆãƒ©ãƒƒãƒ—ã¯ã€æ¼”ç®—çµæœã®å³å¯†ã•ãŒå¤±ã‚ã‚ŒãŸã“ã¨ã‚’æ¤œå‡ºã™ã‚‹ãŸã‚ã«ä½¿ãˆã‚‹ã ã‘ã§ã™ã€‚"

#: ../../library/decimal.rst:1530
msgid "An invalid operation was performed."
msgstr "ç„¡åŠ¹ãªæ¼”ç®—ãŒå®Ÿè¡Œã•ã‚ŒãŸã“ã¨ã‚’é€šçŸ¥ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1532
msgid ""
"Indicates that an operation was requested that does not make sense. If not "
"trapped, returns :const:`NaN`.  Possible causes include::"
msgstr "ãƒ¦ãƒ¼ã‚¶ãŒæœ‰æ„ãªæ¼”ç®—çµæœã«ãªã‚‰ãªã„ã‚ˆã†ãªæ“ä½œã‚’è¦æ±‚ã—ãŸã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚ã“ã®ã‚·ã‚°ãƒŠãƒ«ã‚’ãƒˆãƒ©ãƒƒãƒ—ã—ãªã„å ´åˆã€ :const:`NaN` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ã‚·ã‚°ãƒŠãƒ«ã®ç™ºç”ŸåŸå› ã¨ã—ã¦è€ƒãˆã‚‰ã‚Œã‚‹ã®ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªçŠ¶æ³ã§ã™::"

#: ../../library/decimal.rst:1549
msgid "Numerical overflow."
msgstr "æ•°å€¤ã‚ªãƒ¼ãƒãƒ•ãƒ­ãƒ¼ã‚’ç¤ºã™ã‚·ã‚°ãƒŠãƒ«ã§ã™ã€‚"

#: ../../library/decimal.rst:1551
msgid ""
"Indicates the exponent is larger than :attr:`Emax` after rounding has "
"occurred.  If not trapped, the result depends on the rounding mode, either "
"pulling inward to the largest representable finite number or rounding "
"outward to :const:`Infinity`.  In either case, :class:`Inexact` and "
":class:`Rounded` are also signaled."
msgstr "ã“ã®ã‚·ã‚°ãƒŠãƒ«ã¯ã€å€¤ä¸¸ã‚ã‚’è¡Œã£ãŸå¾Œã®æŒ‡æ•°éƒ¨ãŒ :attr:`Emax` ã‚ˆã‚Šå¤§ãã„ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚ã‚·ã‚°ãƒŠãƒ«ã‚’ãƒˆãƒ©ãƒƒãƒ—ã—ãªã„å ´åˆã€æ¼”ç®—çµæœã¯å€¤ä¸¸ã‚ã®ãƒ¢ãƒ¼ãƒ‰ã«ã‚ˆã‚Šã€è¡¨ç¾å¯èƒ½ãªæœ€å¤§ã®æ•°å€¤ã«ãªã‚‹ã‚ˆã†ã«å†…å´ã¸å¼•ãè¾¼ã‚“ã§ä¸¸ã‚ã‚’è¡Œã£ãŸå€¤ã‹ã€ :const:`Infinity` ã«ãªã‚‹ã‚ˆã†ã«å¤–å´ã«ä¸¸ã‚ãŸå€¤ã®ã„ãšã‚Œã‹ã«ãªã‚Šã¾ã™ã€‚ã„ãšã‚Œã®å ´åˆã‚‚ã€ :class:`Inexact` ãŠã‚ˆã³ :class:`Rounded` ãŒåŒæ™‚ã«ã‚·ã‚°ãƒŠãƒ«ã•ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:1560
msgid "Rounding occurred though possibly no information was lost."
msgstr "æƒ…å ±ãŒå…¨ãå¤±ã‚ã‚Œã¦ã„ãªã„å ´åˆã‚‚å«ã¿ã€å€¤ä¸¸ã‚ãŒèµ·ããŸã¨ãã®ã‚·ã‚°ãƒŠãƒ«ã§ã™ã€‚"

#: ../../library/decimal.rst:1562
msgid ""
"Signaled whenever rounding discards digits; even if those digits are zero "
"(such as rounding :const:`5.00` to :const:`5.0`).  If not trapped, returns "
"the result unchanged.  This signal is used to detect loss of significant "
"digits."
msgstr "ã“ã®ã‚·ã‚°ãƒŠãƒ«ã¯ã€å€¤ä¸¸ã‚ã«ã‚ˆã£ã¦æ¡ãŒãªããªã‚‹ã¨å¸¸ã«ç™ºç”Ÿã—ã¾ã™ã€‚ãªããªã£ãŸæ¡ãŒã‚¼ãƒ­ (ä¾‹ãˆã° :const:`5.00` ã‚’ä¸¸ã‚ã¦ :const:`5.0` ã«ãªã£ãŸå ´åˆ) ã§ã‚ã£ã¦ã‚‚ã§ã™ã€‚ã“ã®ã‚·ã‚°ãƒŠãƒ«ã‚’ãƒˆãƒ©ãƒƒãƒ—ã—ãªã‘ã‚Œã°ã€æ¼”ç®—çµæœã‚’ãã®ã¾ã¾è¿”ã—ã¾ã™ã€‚ã“ã®ã‚·ã‚°ãƒŠãƒ«ã¯æœ‰åŠ¹æ¡æ•°ã®æ¸›å°‘ã‚’æ¤œå‡ºã™ã‚‹éš›ã«ä½¿ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:1570
msgid "Exponent was lower than :attr:`Emin` prior to rounding."
msgstr "å€¤ä¸¸ã‚ã‚’è¡Œã†å‰ã«æŒ‡æ•°éƒ¨ãŒ :attr:`Emin` ã‚ˆã‚Šå°ã•ã‹ã£ãŸã“ã¨ã‚’ç¤ºã™ã‚·ã‚°ãƒŠãƒ«ã§ã™ã€‚"

#: ../../library/decimal.rst:1572
msgid ""
"Occurs when an operation result is subnormal (the exponent is too small). If"
" not trapped, returns the result unchanged."
msgstr "æ¼”ç®—çµæœãŒå¾®å°ã§ã‚ã‚‹å ´åˆ (æŒ‡æ•°ãŒå°ã•ã™ãã‚‹å ´åˆ) ã«ç™ºç”Ÿã—ã¾ã™ã€‚ã“ã®ã‚·ã‚°ãƒŠãƒ«ã‚’ãƒˆãƒ©ãƒƒãƒ—ã—ãªã‘ã‚Œã°ã€æ¼”ç®—çµæœã‚’ãã®ã¾ã¾è¿”ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1578
msgid "Numerical underflow with result rounded to zero."
msgstr "æ¼”ç®—çµæœãŒå€¤ä¸¸ã‚ã«ã‚ˆã£ã¦ã‚¼ãƒ­ã«ãªã£ãŸå ´åˆã«ç”Ÿã˜ã‚‹æ•°å€¤ã‚¢ãƒ³ãƒ€ãƒ•ãƒ­ãƒ¼ã§ã™ã€‚"

#: ../../library/decimal.rst:1580
msgid ""
"Occurs when a subnormal result is pushed to zero by rounding. "
":class:`Inexact` and :class:`Subnormal` are also signaled."
msgstr "æ¼”ç®—çµæœãŒå¾®å°ãªãŸã‚ã€å€¤ä¸¸ã‚ã«ã‚ˆã£ã¦ã‚¼ãƒ­ã«ãªã£ãŸå ´åˆã«ç™ºç”Ÿã—ã¾ã™ã€‚ :class:`Inexact` ãŠã‚ˆã³ :class:`Subnormal` ã‚·ã‚°ãƒŠãƒ«ã‚‚åŒæ™‚ã«ç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1583
msgid "The following table summarizes the hierarchy of signals::"
msgstr "ã“ã‚Œã‚‰ã®ã‚·ã‚°ãƒŠãƒ«ã®éšå±¤æ§‹é€ ã‚’ã¾ã¨ã‚ã‚‹ã¨ã€ä»¥ä¸‹ã®è¡¨ã®ã‚ˆã†ã«ãªã‚Šã¾ã™::"

#: ../../library/decimal.rst:1602
msgid "Floating Point Notes"
msgstr "æµ®å‹•å°æ•°ç‚¹æ•°ã«é–¢ã™ã‚‹æ³¨æ„"

#: ../../library/decimal.rst:1606
msgid "Mitigating round-off error with increased precision"
msgstr "ç²¾åº¦ã‚’ä¸Šã’ã¦ä¸¸ã‚èª¤å·®ã‚’æŠ‘åˆ¶ã™ã‚‹"

#: ../../library/decimal.rst:1608
msgid ""
"The use of decimal floating point eliminates decimal representation error "
"(making it possible to represent :const:`0.1` exactly); however, some "
"operations can still incur round-off error when non-zero digits exceed the "
"fixed precision."
msgstr "10é€²æµ®å‹•å°æ•°ç‚¹æ•°ã‚’ä½¿ã†ã¨ã€10é€²æ•°è¡¨ç¾ã«ã‚ˆã‚‹èª¤å·®ã‚’æŠ‘åˆ¶ã§ãã¾ã™ (:const:`0.1` ã‚’æ­£ç¢ºã«è¡¨ç¾ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™); ã—ã‹ã—ã€ã‚¼ãƒ­ã§ãªã„æ¡ãŒä¸€å®šã®ç²¾åº¦ã‚’è¶Šãˆã¦ã„ã‚‹å ´åˆã«ã¯ã€æ¼”ç®—ã«ã‚ˆã£ã¦ã¯ä¾ç„¶ã¨ã—ã¦å€¤ä¸¸ã‚ã«ã‚ˆã‚‹èª¤å·®ã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1612
msgid ""
"The effects of round-off error can be amplified by the addition or "
"subtraction of nearly offsetting quantities resulting in loss of "
"significance.  Knuth provides two instructive examples where rounded "
"floating point arithmetic with insufficient precision causes the breakdown "
"of the associative and distributive properties of addition:"
msgstr "å€¤ä¸¸ã‚ã«ã‚ˆã‚‹èª¤å·®ã®å½±éŸ¿ã¯ã€æ¡è½ã¡ã‚’ç”Ÿã˜ã‚‹ã‚ˆã†ãªã€ã»ã¨ã‚“ã©ç›¸æ®ºã•ã‚Œã‚‹é‡ã§ã®åŠ ç®—ã‚„æ¸›ç®—ã«ã‚ˆã£ã¦å¢—å¹…ã•ã‚Œã¾ã™ã€‚Knuth ã¯ã€ååˆ†ã§ãªã„è¨ˆç®—ç²¾åº¦ã®ä¸‹ã§å€¤ä¸¸ã‚ã‚’ä¼´ã†æµ®å‹•å°æ•°ç‚¹æ¼”ç®—ã‚’è¡Œã£ãŸçµæœã€åŠ ç®—ã®çµåˆå‰‡ã‚„åˆ†é…å‰‡ã«ãŠã‘ã‚‹æ’ç­‰æ€§ãŒå´©ã‚Œã¦ã—ã¾ã†ä¾‹ã‚’äºŒã¤ç¤ºã—ã¦ã„ã¾ã™:"

#: ../../library/decimal.rst:1636
msgid ""
"The :mod:`decimal` module makes it possible to restore the identities by "
"expanding the precision sufficiently to avoid loss of significance:"
msgstr ":mod:`decimal` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€æœ€ä¸‹æ¡ã‚’å¤±ã‚ãªã„ã‚ˆã†ã«ååˆ†ã«è¨ˆç®—ç²¾åº¦ã‚’åºƒã’ã‚‹ã“ã¨ã§ã€ä¸Šã§å•é¡Œã«ã—ãŸã‚ˆã†ãªæ’ç­‰æ€§ã‚’ã¨ã‚Šã‚‚ã©ã›ã¾ã™:"

#: ../../library/decimal.rst:1656
msgid "Special values"
msgstr "ç‰¹æ®Šå€¤"

#: ../../library/decimal.rst:1658
msgid ""
"The number system for the :mod:`decimal` module provides special values "
"including :const:`NaN`, :const:`sNaN`, :const:`-Infinity`, "
":const:`Infinity`, and two zeros, :const:`+0` and :const:`-0`."
msgstr ":mod:`decimal` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ•°ä½“ç³»ã§ã¯ã€ :const:`NaN`, :const:`sNaN`, :const:`-Infinity`, :const:`Infinity`, ãŠã‚ˆã³äºŒã¤ã®ã‚¼ãƒ­ã€ :const:`+0` ã¨ :const:`-0` ã¨ã„ã£ãŸç‰¹æ®Šãªå€¤ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:1662
msgid ""
"Infinities can be constructed directly with:  ``Decimal('Infinity')``. Also,"
" they can arise from dividing by zero when the :exc:`DivisionByZero` signal "
"is not trapped.  Likewise, when the :exc:`Overflow` signal is not trapped, "
"infinity can result from rounding beyond the limits of the largest "
"representable number."
msgstr "ç„¡é™å¤§ (Infinity) ã¯ ``Decimal('Infinity')`` ã§ç›´æ¥æ§‹ç¯‰ã§ãã¾ã™ã€‚ã¾ãŸã€ :exc:`DivisionByZero` ã‚’ãƒˆãƒ©ãƒƒãƒ—ã›ãšã«ã‚¼ãƒ­ã§é™¤ç®—ã‚’è¡Œã£ãŸå ´åˆã«ã‚‚å‡ºã¦ãã¾ã™ã€‚åŒæ§˜ã«ã€ :exc:`Overflow` ã‚·ã‚°ãƒŠãƒ«ã‚’ãƒˆãƒ©ãƒƒãƒ—ã—ãªã‘ã‚Œã°ã€è¡¨ç¾å¯èƒ½ãªæœ€å¤§ã®æ•°å€¤ã®åˆ¶é™ã‚’è¶ŠãˆãŸå€¤ã‚’ä¸¸ã‚ãŸã¨ãã«å‡ºã¦ãã¾ã™ã€‚"

#: ../../library/decimal.rst:1667
msgid ""
"The infinities are signed (affine) and can be used in arithmetic operations "
"where they get treated as very large, indeterminate numbers.  For instance, "
"adding a constant to infinity gives another infinite result."
msgstr "ç„¡é™å¤§ã«ã¯ç¬¦å·ãŒã‚ã‚Š (ã‚¢ãƒ•ã‚£ãƒ³: affine ã§ã‚ã‚Š)ã€ç®—è¡“æ¼”ç®—ã«ä½¿ç”¨ã§ãã€éå¸¸ã«å·¨å¤§ã§ä¸ç¢ºå®šã®(indeterminate)å€¤ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ç„¡é™å¤§ã«ä½•ã‚‰ã‹ã®å®šæ•°ã‚’åŠ ç®—ã™ã‚‹ã¨ã€æ¼”ç®—çµæœã¯åˆ¥ã®ç„¡é™å¤§ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/decimal.rst:1671
msgid ""
"Some operations are indeterminate and return :const:`NaN`, or if the "
":exc:`InvalidOperation` signal is trapped, raise an exception.  For example,"
" ``0/0`` returns :const:`NaN` which means \"not a number\".  This variety of"
" :const:`NaN` is quiet and, once created, will flow through other "
"computations always resulting in another :const:`NaN`.  This behavior can be"
" useful for a series of computations that occasionally have missing inputs "
"--- it allows the calculation to proceed while flagging specific results as "
"invalid."
msgstr "æ¼”ç®—ã«ã‚ˆã£ã¦ã¯çµæœãŒä¸ç¢ºå®šã«ãªã‚‹ã‚‚ã®ãŒã‚ã‚Šã€ :const:`NaN` ã‚’è¿”ã—ã¾ã™ã€‚ãŸã ã—ã€ :exc:`InvalidOperation` ã‚·ã‚°ãƒŠãƒ«ã‚’ãƒˆãƒ©ãƒƒãƒ—ã™ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚Œã°ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ ``0/0`` ã¯ :const:`NaN` ã‚’è¿”ã—ã¾ã™ã€‚ :const:`NaN` ã¯ã€Œéæ•°å€¤ (not a number)ã€ã‚’è¡¨ã—ã¾ã™ã€‚ã“ã®ã‚ˆã†ãª :const:`NaN` ã¯æš—é»™ã®ã†ã¡ã«ç”Ÿæˆã•ã‚Œã€ä¸€åº¦ç”Ÿæˆã•ã‚Œã‚‹ã¨ãã‚Œã‚’ä»–ã®è¨ˆç®—ã«ã‚‚æµã‚Œã¦ã‚†ãã€é–¢ä¿‚ã™ã‚‹å€‹ã€…ã®æ¼”ç®—å…¨ã¦ãŒå€‹åˆ¥ã® :const:`NaN` ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ã“ã®æŒ™å‹•ã¯ã€ãŸã¾ã«å…¥åŠ›å€¤ãŒæ¬ ã‘ã‚‹ã‚ˆã†ãªçŠ¶æ³ã§ä¸€é€£ã®è¨ˆç®—ã‚’è¡Œã†éš›ã«ä¾¿åˆ©ã§ã™ --- ç‰¹å®šã®è¨ˆç®—ã«å¯¾ã—ã¦ã¯ç„¡åŠ¹ãªçµæœã‚’ç¤ºã™ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã¤ã¤è¨ˆç®—ã‚’é€²ã‚ã‚‰ã‚Œã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/decimal.rst:1679
msgid ""
"A variant is :const:`sNaN` which signals rather than remaining quiet after "
"every operation.  This is a useful return value when an invalid result needs"
" to interrupt a calculation for special handling."
msgstr "ä¸€æ–¹ã€ :const:`NaN` ã®å¤‰ç¨®ã§ã‚ã‚‹ :const:`sNaN` ã¯é–¢ä¿‚ã™ã‚‹å…¨ã¦ã®æ¼”ç®—ã§æ¼”ç®—å¾Œã«ã‚·ã‚°ãƒŠãƒ«ã‚’é€å‡ºã—ã¾ã™ã€‚ :const:`sNaN` ã¯ã€ç„¡åŠ¹ãªæ¼”ç®—çµæœã«å¯¾ã—ã¦ç‰¹åˆ¥ãªå‡¦ç†ã‚’è¡Œã†ãŸã‚ã«è¨ˆç®—ã‚’åœæ­¢ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../library/decimal.rst:1683
msgid ""
"The behavior of Python's comparison operators can be a little surprising "
"where a :const:`NaN` is involved.  A test for equality where one of the "
"operands is a quiet or signaling :const:`NaN` always returns :const:`False` "
"(even when doing ``Decimal('NaN')==Decimal('NaN')``), while a test for "
"inequality always returns :const:`True`.  An attempt to compare two Decimals"
" using any of the ``<``, ``<=``, ``>`` or ``>=`` operators will raise the "
":exc:`InvalidOperation` signal if either operand is a :const:`NaN`, and "
"return :const:`False` if this signal is not trapped.  Note that the General "
"Decimal Arithmetic specification does not specify the behavior of direct "
"comparisons; these rules for comparisons involving a :const:`NaN` were taken"
" from the IEEE 854 standard (see Table 3 in section 5.7).  To ensure strict "
"standards-compliance, use the :meth:`compare` and :meth:`compare-signal` "
"methods instead."
msgstr "Python ã®æ¯”è¼ƒæ¼”ç®—ã¯ :const:`NaN` ãŒé–¢ã‚ã£ã¦ãã‚‹ã¨å°‘ã—é©šãã‚ˆã†ãªã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ç­‰ä¾¡æ€§ã®ãƒ†ã‚¹ãƒˆã®ä¸€æ–¹ã®å¯¾è±¡ãŒç„¡è¨€ã¾ãŸã¯ç™ºä¿¡ :const:`NaN` ã§ã‚ã‚‹å ´åˆã„ã¤ã§ã‚‚ :const:`False` ã‚’è¿”ã—(ãŸã¨ãˆ ``Decimal('NaN')==Decimal('NaN')`` ã§ã‚‚)ã€ä¸€æ–¹ã§ä¸ç­‰ä¾¡ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã¨ã„ã¤ã§ã‚‚ :const:`True` ã‚’è¿”ã—ã¾ã™ã€‚äºŒã¤ã® Decimal ã‚’ ``<``, ``<=``, ``>`` ã¾ãŸã¯ ``>=`` ã‚’ä½¿ã£ã¦æ¯”è¼ƒã™ã‚‹è©¦ã¿ã¯ä¸€æ–¹ãŒ :const:`NaN` ã§ã‚ã‚‹å ´åˆã«ã¯ :exc:`InvalidOperation` ã‚·ã‚°ãƒŠãƒ«ã‚’é€å‡ºã—ã€ã“ã®ã‚·ã‚°ãƒŠãƒ«ã‚’ãƒˆãƒ©ãƒƒãƒ—ã—ãªã‘ã‚Œã°çµæœã¯ :const:`False` ã«çµ‚ã‚ã‚Šã¾ã™ã€‚æ±ç”¨10é€²æ¼”ç®—ä»•æ§˜ã¯ç›´æ¥ã®æ¯”è¼ƒã®æŒ¯ã‚‹èˆã„ã«ã¤ã„ã¦å®šã‚ã¦ã„ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãŠãã¾ã—ã‚‡ã†ã€‚ã“ã“ã§ã® :const:`NaN` ãŒé–¢ä¿‚ã™ã‚‹æ¯”è¼ƒãƒ«ãƒ¼ãƒ«ã¯ IEEE 854 æ¨™æº–ã‹ã‚‰æŒã£ã¦ãã¾ã—ãŸ (section 5.7 ã® Table 3 ã‚’è¦‹ã¦ä¸‹ã•ã„)ã€‚å³æ ¼ã«æ¨™æº–éµå®ˆã‚’è²«ããªã‚‰ã€ :meth:`compare` ãŠã‚ˆã³ :meth:`compare-signal` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä»£ã‚ã‚Šã«ä½¿ã„ã¾ã—ã‚‡ã†ã€‚"

#: ../../library/decimal.rst:1696
msgid ""
"The signed zeros can result from calculations that underflow. They keep the "
"sign that would have resulted if the calculation had been carried out to "
"greater precision.  Since their magnitude is zero, both positive and "
"negative zeros are treated as equal and their sign is informational."
msgstr "ã‚¢ãƒ³ãƒ€ãƒ•ãƒ­ãƒ¼ã®èµ·ããŸè¨ˆç®—ã¯ã€ç¬¦å·ä»˜ãã®ã‚¼ãƒ­ (signed zero) ã‚’è¿”ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ç¬¦å·ã¯ã€ã‚ˆã‚Šé«˜ã„ç²¾åº¦ã§è¨ˆç®—ã‚’è¡Œã£ãŸçµæœã®ç¬¦å·ã¨åŒã˜ã«ãªã‚Šã¾ã™ã€‚ç¬¦å·ä»˜ãã‚¼ãƒ­ã®å¤§ãã•ã¯ã‚„ã¯ã‚Šã‚¼ãƒ­ãªã®ã§ã€æ­£ã®ã‚¼ãƒ­ã¨è² ã®ã‚¼ãƒ­ã¯ç­‰ã—ã„ã¨ã¿ãªã•ã‚Œã€ç¬¦å·ã¯å˜ãªã‚‹å‚è€ƒã«ã™ãã¾ã›ã‚“ã€‚"

#: ../../library/decimal.rst:1701
msgid ""
"In addition to the two signed zeros which are distinct yet equal, there are "
"various representations of zero with differing precisions yet equivalent in "
"value.  This takes a bit of getting used to.  For an eye accustomed to "
"normalized floating point representations, it is not immediately obvious "
"that the following calculation returns a value equal to zero:"
msgstr "äºŒã¤ã®ç¬¦å·ä»˜ãã‚¼ãƒ­ãŒåŒºåˆ¥ã•ã‚Œã¦ã„ã‚‹ã®ã«ç­‰ä¾¡ã§ã‚ã‚‹ã“ã¨ã«åŠ ãˆã¦ã€ç•°ãªã‚‹ç²¾åº¦ã«ãŠã‘ã‚‹ã‚¼ãƒ­ã®è¡¨ç¾ã¯ã¾ã¡ã¾ã¡ãªã®ã«ã€å€¤ã¯ç­‰ä¾¡ã¨ã¿ãªã•ã‚Œã‚‹ã¨ã„ã†ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã«æ…£ã‚Œã‚‹ã«ã¯å¤šå°‘æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™ã€‚æ­£è¦åŒ–æµ®å‹•å°æ•°ç‚¹è¡¨ç¾ã«ç›®ãŒæ…£ã‚Œã¦ã—ã¾ã†ã¨ã€ä»¥ä¸‹ã®è¨ˆç®—ã§ã‚¼ãƒ­ã«ç­‰ã—ã„å€¤ãŒè¿”ã£ã¦ã„ã‚‹ã¨ã¯å³åº§ã«åˆ†ã‹ã‚Šã¾ã›ã‚“:"

#: ../../library/decimal.rst:1716
msgid "Working with threads"
msgstr "ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½¿ã£ãŸå‡¦ç†"

#: ../../library/decimal.rst:1718
msgid ""
"The :func:`getcontext` function accesses a different :class:`Context` object"
" for each thread.  Having separate thread contexts means that threads may "
"make changes (such as ``getcontext.prec=10``) without interfering with other"
" threads."
msgstr "é–¢æ•° :func:`getcontext` ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰æ¯ã«åˆ¥ã€…ã® :class:`Context` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æŒã¤ã¨ã„ã†ã“ã¨ã¯ã€è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒäº’ã„ã«å½±éŸ¿ã‚’åŠã¼ã•ãšã« (``getcontext().prec=10`` ã®ã‚ˆã†ãª) å¤‰æ›´ã‚’é©ç”¨ã§ãã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../library/decimal.rst:1722
msgid ""
"Likewise, the :func:`setcontext` function automatically assigns its target "
"to the current thread."
msgstr "åŒæ§˜ã«ã€:func:`setcontext` é–¢æ•°ã¯è‡ªå‹•çš„ã«å¼•æ•°ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç¾åœ¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/decimal.rst:1725
msgid ""
"If :func:`setcontext` has not been called before :func:`getcontext`, then "
":func:`getcontext` will automatically create a new context for use in the "
"current thread."
msgstr ":func:`getcontext` ã‚’å‘¼ã³å‡ºã™å‰ã« :func:`setcontext` ãŒå‘¼ã³å‡ºã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ç¾åœ¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§ä½¿ã†ãŸã‚ã®æ–°ãŸãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã« :func:`getcontext` ãŒè‡ªå‹•çš„ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/decimal.rst:1729
msgid ""
"The new context is copied from a prototype context called *DefaultContext*. "
"To control the defaults so that each thread will use the same values "
"throughout the application, directly modify the *DefaultContext* object. "
"This should be done *before* any threads are started so that there won't be "
"a race condition between threads calling :func:`getcontext`. For example::"
msgstr "æ–°ãŸãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯ã€*DefaultContext* ã¨å‘¼ã°ã‚Œã‚‹é››å½¢ã‹ã‚‰ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é€šã˜ã¦å…¨ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«åŒã˜å€¤ã‚’ä½¿ã†ã‚ˆã†ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’è¨­å®šã—ãŸã‘ã‚Œã°ã€*DefaultContext* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç›´æ¥å¤‰æ›´ã—ã¾ã™ã€‚ :func:`getcontext` ã‚’å‘¼ã³å‡ºã™ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§ç«¶åˆæ¡ä»¶ãŒç”Ÿã˜ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã€*DefaultContext* ã¸ã®å¤‰æ›´ã¯ã„ã‹ãªã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é–‹å§‹ã™ã‚‹ã‚ˆã‚Šã‚‚ *å‰ã«* è¡Œã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™::"

#: ../../library/decimal.rst:1754
msgid "Recipes"
msgstr "ãƒ¬ã‚·ãƒ”"

#: ../../library/decimal.rst:1756
msgid ""
"Here are a few recipes that serve as utility functions and that demonstrate "
"ways to work with the :class:`Decimal` class::"
msgstr ":class:`Decimal` ã‚¯ãƒ©ã‚¹ã®åˆ©ç”¨ã‚’å®Ÿæ¼”ã—ã¦ã„ã‚‹ä¾‹ã‚’ã„ãã¤ã‹ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã¯ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã¨ã—ã¦ã‚‚åˆ©ç”¨ã§ãã¾ã™::"

#: ../../library/decimal.rst:1904
msgid "Decimal FAQ"
msgstr "Decimal FAQ"

#: ../../library/decimal.rst:1906
msgid ""
"Q. It is cumbersome to type ``decimal.Decimal('1234.5')``.  Is there a way "
"to minimize typing when using the interactive interpreter?"
msgstr "Q. ``decimal.Decimal('1234.5')`` ãªã©ã¨æ‰“ã¡è¾¼ã‚€ã®ã¯ç…©ã‚ã—ã„ã®ã§ã™ãŒã€å¯¾è©±å¼ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ä½¿ã†éš›ã«ã‚¿ã‚¤ãƒ—é‡ã‚’å°‘ãªãã™ã‚‹æ–¹æ³•ã¯ã‚ã‚Šã¾ã›ã‚“ã‹?"

#: ../../library/decimal.rst:1909
msgid "A. Some users abbreviate the constructor to just a single letter:"
msgstr "A. ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’1æ–‡å­—ã«ç¸®ã‚ã‚‹äººã‚‚ã„ã‚‹ã‚ˆã†ã§ã™:"

#: ../../library/decimal.rst:1915
msgid ""
"Q. In a fixed-point application with two decimal places, some inputs have "
"many places and need to be rounded.  Others are not supposed to have excess "
"digits and need to be validated.  What methods should be used?"
msgstr "Q. å°æ•°ç‚¹ä»¥ä¸‹2æ¡ã®å›ºå®šå°æ•°ç‚¹æ•°ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ä¸­ã§ã€ã„ãã¤ã‹ã®å…¥åŠ›ãŒä½™è¨ˆãªæ¡ã‚’ä¿æŒã—ã¦ã„ã‚‹ã®ã§ã“ã‚Œã‚’ä¸¸ã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã®ä»–ã®ã‚‚ã®ã«ä½™è¨ˆãªæ¡ã¯ãªããã®ã¾ã¾ä½¿ãˆã¾ã™ã€‚ã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã®ãŒã„ã„ã§ã—ã‚‡ã†ã‹?"

#: ../../library/decimal.rst:1919
msgid ""
"A. The :meth:`quantize` method rounds to a fixed number of decimal places. "
"If the :const:`Inexact` trap is set, it is also useful for validation:"
msgstr "A. :meth:`quantize` ãƒ¡ã‚½ãƒƒãƒ‰ã§å›ºå®šã—ãŸæ¡ã«ä¸¸ã‚ã‚‰ã‚Œã¾ã™ã€‚ :const:`Inexact` ãƒˆãƒ©ãƒƒãƒ—ã‚’è¨­å®šã—ã¦ãŠã‘ã°ã€ç¢ºèªã«ã‚‚æœ‰ç”¨ã§ã™:"

#: ../../library/decimal.rst:1937
msgid ""
"Q. Once I have valid two place inputs, how do I maintain that invariant "
"throughout an application?"
msgstr "Q. æ­£å½“ãª2æ¡ã®å…¥åŠ›ãŒå¾—ã‚‰ã‚ŒãŸã¨ã—ã¦ã€ãã®æ­£å½“æ€§ã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œä¸­ã‚‚å¤‰ã‚ã‚‰ãšä¿ã¡ç¶šã‘ã‚‹ã«ã¯ã©ã†ã™ã‚Œã°ã„ã„ã§ã—ã‚‡ã†ã‹?"

#: ../../library/decimal.rst:1940
msgid ""
"A. Some operations like addition, subtraction, and multiplication by an "
"integer will automatically preserve fixed point.  Others operations, like "
"division and non-integer multiplication, will change the number of decimal "
"places and need to be followed-up with a :meth:`quantize` step:"
msgstr "A. åŠ æ¸›ç®—ã‚ã‚‹ã„ã¯æ•´æ•°ã¨ã®ä¹—ç®—ã®ã‚ˆã†ãªæ¼”ç®—ã¯è‡ªå‹•çš„ã«å›ºå®šå°æ•°ç‚¹ã‚’å®ˆã‚Šã¾ã™ã€‚ãã®ä»–ã®é™¤ç®—ã‚„æ•´æ•°ä»¥å¤–ã®ä¹—ç®—ãªã©ã¯å°æ•°ç‚¹ä»¥ä¸‹ã®æ¡ã‚’å¤‰ãˆã¦ã—ã¾ã„ã¾ã™ã®ã§å®Ÿè¡Œå¾Œã¯ :meth:`quantize` ã‚¹ãƒ†ãƒƒãƒ—ãŒå¿…è¦ã§ã™:"

#: ../../library/decimal.rst:1958
msgid ""
"In developing fixed-point applications, it is convenient to define functions"
" to handle the :meth:`quantize` step:"
msgstr "å›ºå®šå°æ•°ç‚¹ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹ç™ºã™ã‚‹éš›ã¯ã€ :meth:`quantize` ã®æ®µéšã‚’æ‰±ã†é–¢æ•°ã‚’å®šç¾©ã—ã¦ãŠãã¨ä¾¿åˆ©ã§ã™:"

#: ../../library/decimal.rst:1971
msgid ""
"Q. There are many ways to express the same value.  The numbers :const:`200`,"
" :const:`200.000`, :const:`2E2`, and :const:`.02E+4` all have the same value"
" at various precisions. Is there a way to transform them to a single "
"recognizable canonical value?"
msgstr "Q. ä¸€ã¤ã®å€¤ã«å¯¾ã—ã¦å¤šãã®è¡¨ç¾æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚ :const:`200` ã¨ :const:`200.000` ã¨ :const:`2E2` ã¨ :const:`.02E+4` ã¯å…¨ã¦åŒã˜å€¤ã§é•ã£ãŸç²¾åº¦ã®æ•°ã§ã™ã€‚ã“ã‚Œã‚‰ã‚’ãŸã ä¸€ã¤ã®æ­£è¦åŒ–ã•ã‚ŒãŸå€¤ã«å¤‰æ›ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã™ã‹?"

#: ../../library/decimal.rst:1976
msgid ""
"A. The :meth:`normalize` method maps all equivalent values to a single "
"representative:"
msgstr "A. :meth:`normalize` ãƒ¡ã‚½ãƒƒãƒ‰ã¯å…¨ã¦ã®ç­‰ã—ã„å€¤ã‚’ãŸã ä¸€ã¤ã®è¡¨ç¾ã«ç›´ã—ã¾ã™:"

#: ../../library/decimal.rst:1983
msgid ""
"Q. Some decimal values always print with exponential notation.  Is there a "
"way to get a non-exponential representation?"
msgstr "Q. ã‚ã‚‹ç¨®ã®10é€²æ•°å€¤ã¯ã„ã¤ã‚‚æŒ‡æ•°è¡¨è¨˜ã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚æŒ‡æ•°è¡¨è¨˜ä»¥å¤–ã®è¡¨ç¤ºã«ã™ã‚‹æ–¹æ³•ã¯ã‚ã‚Šã¾ã™ã‹?"

#: ../../library/decimal.rst:1986
msgid ""
"A. For some values, exponential notation is the only way to express the "
"number of significant places in the coefficient.  For example, expressing "
":const:`5.0E+3` as :const:`5000` keeps the value constant but cannot show "
"the original's two-place significance."
msgstr "A. å€¤ã«ã‚ˆã£ã¦ã¯ã€æŒ‡æ•°è¡¨è¨˜ã ã‘ãŒæœ‰åŠ¹æ¡æ•°ã‚’è¡¨ã›ã‚‹è¡¨è¨˜æ³•ãªã®ã§ã™ã€‚ãŸã¨ãˆã°ã€ :const:`5.0E+3` ã‚’ :const:`5000` ã¨è¡¨ã—ã¦ã—ã¾ã†ã¨ã€å€¤ã¯å¤‰ã‚ã‚Šã¾ã›ã‚“ãŒå…ƒã€…ã®2æ¡ã¨ã„ã†æœ‰åŠ¹æ•°å­—ãŒåæ˜ ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/decimal.rst:1991
msgid ""
"If an application does not care about tracking significance, it is easy to "
"remove the exponent and trailing zeros, losing significance, but keeping the"
" value unchanged::"
msgstr "ã‚‚ã—ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒæœ‰åŠ¹æ•°å­—ã®è¿½è·¡ã‚’ç­‰é–‘è¦–ã™ã‚‹ãªã‚‰ã°ã€æŒ‡æ•°éƒ¨ã‚„æœ«å°¾ã®ã‚¼ãƒ­ã‚’å–ã‚Šé™¤ãã€æœ‰åŠ¹æ•°å­—ã‚’å¿˜ã‚Œã€ã—ã‹ã—å€¤ã‚’å¤‰ãˆãšã«ãŠãã“ã¨ã¯å®¹æ˜“ã§ã™:"

#: ../../library/decimal.rst:2004
msgid "Q. Is there a way to convert a regular float to a :class:`Decimal`?"
msgstr "Q. æ™®é€šã® float ã‚’ :class:`Decimal` ã«å¤‰æ›ã§ãã¾ã™ã‹?"

#: ../../library/decimal.rst:2006
msgid ""
"A. Yes, any binary floating point number can be exactly expressed as a "
"Decimal though an exact conversion may take more precision than intuition "
"would suggest:"
msgstr "A. ã¯ã„ã€‚ã©ã‚“ãª 2 é€²æµ®å‹•å°æ•°ç‚¹æ•°ã‚‚ Decimal ã¨ã—ã¦æ­£ç¢ºã«è¡¨ç¾ã§ãã¾ã™ã€‚ãŸã ã—ã€æ­£ç¢ºãªå¤‰æ›ã¯ç›´æ„Ÿçš„ã«è€ƒãˆãŸã‚ˆã‚Šã‚‚å¤šã„æ¡ã«ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™:"

#: ../../library/decimal.rst:2015
msgid ""
"Q. Within a complex calculation, how can I make sure that I haven't gotten a"
" spurious result because of insufficient precision or rounding anomalies."
msgstr "Q. è¤‡é›‘ãªè¨ˆç®—ã®ä¸­ã§ã€ç²¾åº¦ä¸è¶³ã‚„ä¸¸ã‚ã®ç•°å¸¸ã§é–“é•ã£ãŸçµæœã«ãªã£ã¦ã„ãªã„ã“ã¨ã‚’ã©ã†ã‚„ã£ã¦ä¿è¨¼ã™ã‚Œã°è‰¯ã„ã§ã—ã‚‡ã†ã‹ã€‚"

#: ../../library/decimal.rst:2018
msgid ""
"A. The decimal module makes it easy to test results.  A best practice is to "
"re-run calculations using greater precision and with various rounding modes."
" Widely differing results indicate insufficient precision, rounding mode "
"issues, ill-conditioned inputs, or a numerically unstable algorithm."
msgstr "A. decimal ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯æ¤œç®—ã¯å®¹æ˜“ã§ã™ã€‚ä¸€ç•ªè‰¯ã„æ–¹æ³•ã¯ã€å¤§ãã‚ã®ç²¾åº¦ã‚„æ§˜ã€…ãªä¸¸ã‚ãƒ¢ãƒ¼ãƒ‰ã§å†è¨ˆç®—ã—ã¦ã¿ã‚‹ã“ã¨ã§ã™ã€‚å¤§ããç•°ãªã£ãŸçµæœãŒå‡ºã¦ããŸã‚‰ã€ç²¾åº¦ä¸è¶³ã‚„ä¸¸ã‚ã®å•é¡Œã‚„æ‚ªæ¡ä»¶ã®å…¥åŠ›ã€ã¾ãŸã¯æ•°å€¤è¨ˆç®—çš„ã«ä¸å®‰å®šãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ç¤ºå”†ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/decimal.rst:2023
msgid ""
"Q. I noticed that context precision is applied to the results of operations "
"but not to the inputs.  Is there anything to watch out for when mixing "
"values of different precisions?"
msgstr "Q. ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ç²¾åº¦ã¯è¨ˆç®—çµæœã«ã¯é©ç”¨ã•ã‚Œã¦ã„ã¾ã™ãŒå…¥åŠ›ã«ã¯é©ç”¨ã•ã‚Œã¦ã„ãªã„ã‚ˆã†ã§ã™ã€‚æ§˜ã€…ã«ç•°ãªã‚‹ç²¾åº¦ã®å…¥åŠ›å€¤ã‚’æ··ãœã¦è¨ˆç®—ã™ã‚‹æ™‚ã«æ³¨æ„ã™ã¹ãã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹?"

#: ../../library/decimal.rst:2027
msgid ""
"A. Yes.  The principle is that all values are considered to be exact and so "
"is the arithmetic on those values.  Only the results are rounded.  The "
"advantage for inputs is that \"what you type is what you get\".  A "
"disadvantage is that the results can look odd if you forget that the inputs "
"haven't been rounded:"
msgstr "A. ã¯ã„ã€‚åŸå‰‡ã¨ã—ã¦å…¥åŠ›å€¤ã¯æ­£ç¢ºã§ã‚ã‚‹ã¨è¦‹åšã—ã¦ãŠã‚Šãã‚Œã‚‰ã®å€¤ã‚’ä½¿ã£ãŸè¨ˆç®—ã‚‚åŒæ§˜ã§ã™ã€‚çµæœã ã‘ãŒä¸¸ã‚ã‚‰ã‚Œã¾ã™ã€‚å…¥åŠ›ã®å¼·ã¿ã¯ \"what you type is what you get\" (æ‰“ã¡è¾¼ã‚“ã å€¤ãŒå¾—ã‚‰ã‚Œã‚‹å€¤)ã¨ã„ã†ç‚¹ã«ã‚ã‚Šã¾ã™ã€‚å…¥åŠ›ãŒä¸¸ã‚ã‚‰ã‚Œãªã„ã¨ã„ã†ã“ã¨ã‚’å¿˜ã‚Œã¦ã„ã‚‹ã¨çµæœãŒå¥‡å¦™ã«è¦‹ãˆã‚‹ã¨ã„ã†ã®ã¯å¼±ç‚¹ã§ã™:"

#: ../../library/decimal.rst:2040
msgid ""
"The solution is either to increase precision or to force rounding of inputs "
"using the unary plus operation:"
msgstr "è§£æ±ºç­–ã¯ã€ç²¾åº¦ã‚’å¢—ã‚„ã™ã‹ã€å˜é …ãƒ—ãƒ©ã‚¹æ¼”ç®—å­ã‚’ä½¿ã£ã¦å…¥åŠ›ã®ä¸¸ã‚ã‚’å¼·åˆ¶ã™ã‚‹ã“ã¨ã§ã™:"

#: ../../library/decimal.rst:2049
msgid ""
"Alternatively, inputs can be rounded upon creation using the "
":meth:`Context.create_decimal` method:"
msgstr "ã‚‚ã—ãã¯ã€å…¥åŠ›ã‚’ :meth:`Context.create_decimal` ã‚’ä½¿ã£ã¦ç”Ÿæˆæ™‚ã«ä¸¸ã‚ã¦ã—ã¾ã†ã“ã¨ã‚‚ã§ãã¾ã™:"
