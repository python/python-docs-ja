# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2017-09-22 17:57+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/json.rst:2
msgid ":mod:`json` --- JSON encoder and decoder"
msgstr ":mod:`json` --- JSON ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãŠã‚ˆã³ãƒ‡ã‚³ãƒ¼ãƒ€"

#: ../../library/json.rst:10
msgid ""
"`JSON (JavaScript Object Notation) <http://json.org>`_, specified by "
":rfc:`7159` (which obsoletes :rfc:`4627`) and by `ECMA-404 <http://www.ecma-"
"international.org/publications/standards/Ecma-404.htm>`_, is a lightweight "
"data interchange format inspired by `JavaScript "
"<https://en.wikipedia.org/wiki/JavaScript>`_ object literal syntax (although"
" it is not a strict subset of JavaScript [#rfc-errata]_ )."
msgstr "`JSON (JavaScript Object Notation) <http://json.org>`_ ã¯ã€ :rfc:`7159` (:rfc:`4627` ã‚’ obsolete) ã¨ `ECMA-404 <http://www.ecma-international.org/publications/standards/Ecma-404.htm>`_ ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚ŒãŸè»½é‡ã®ãƒ‡ãƒ¼ã‚¿äº¤æ›ç”¨ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã™ã€‚ JavaScript ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªãƒ†ãƒ©ãƒ«è¨˜æ³•ã«ç”±æ¥ã—ã¦ã„ã¾ã™ (`JavaScript <https://en.wikipedia.org/wiki/JavaScript>`_ ã®å³å¯†ãªã‚µãƒ–ã‚»ãƒƒãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒ [#rfc-errata]_)ã€‚"

#: ../../library/json.rst:17
msgid ""
":mod:`json` exposes an API familiar to users of the standard library "
":mod:`marshal` and :mod:`pickle` modules."
msgstr ":mod:`json` ã® API ã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® :mod:`marshal` ã‚„ :mod:`pickle` ã®ãƒ¦ãƒ¼ã‚¶ã«é¦´æŸ“ã¿æ·±ã„ã‚‚ã®ã§ã™ã€‚"

#: ../../library/json.rst:20
msgid "Encoding basic Python object hierarchies::"
msgstr "åŸºæœ¬çš„ãª Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆéšå±¤ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°::"

#: ../../library/json.rst:39
msgid "Compact encoding::"
msgstr "ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°::"

#: ../../library/json.rst:45
msgid "Pretty printing::"
msgstr "è¦‹ã‚„ã™ã„è¡¨ç¤º::"

#: ../../library/json.rst:55
msgid "Decoding JSON::"
msgstr "JSON ã®ãƒ‡ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°::"

#: ../../library/json.rst:67
msgid "Specializing JSON object decoding::"
msgstr "JSON ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æ–¹æ³•ã‚’èª‚ãˆã‚‹::"

#: ../../library/json.rst:82
msgid "Extending :class:`JSONEncoder`::"
msgstr ":class:`JSONEncoder` ã®æ‹¡å¼µ::"

#: ../../library/json.rst:102
msgid "Using :mod:`json.tool` from the shell to validate and pretty-print::"
msgstr "ã‚·ã‚§ãƒ«ã‹ã‚‰  :mod:`json.tool` ã‚’ä½¿ã£ã¦å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ã‚’ã—ã¦è¦‹ã‚„ã™ãè¡¨ç¤º::"

#: ../../library/json.rst:115
msgid ""
"JSON is a subset of `YAML <http://yaml.org/>`_ 1.2.  The JSON produced by "
"this module's default settings (in particular, the default *separators* "
"value) is also a subset of YAML 1.0 and 1.1.  This module can thus also be "
"used as a YAML serializer."
msgstr "JSON ã¯ `YAML <http://yaml.org/>`_ 1.2 ã®ã‚µãƒ–ã‚»ãƒƒãƒˆã§ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š (ç‰¹ã«ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® *ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿* å€¤) ã§ç”Ÿæˆã•ã‚Œã‚‹ JSON ã¯ YAML 1.0 ãŠã‚ˆã³ 1.1 ã®ã‚µãƒ–ã‚»ãƒƒãƒˆã§ã‚‚ã‚ã‚Šã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ YAML ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã¨ã—ã¦ã‚‚ä½¿ãˆã¾ã™ã€‚"

#: ../../library/json.rst:122
msgid "Basic Usage"
msgstr "åŸºæœ¬çš„ãªä½¿ã„æ–¹"

#: ../../library/json.rst:129
msgid ""
"Serialize *obj* as a JSON formatted stream to *fp* (a "
"``.write()``-supporting :term:`file-like object`) using this "
":ref:`conversion table <py-to-json-table>`."
msgstr "ã“ã® :ref:`å¤‰æ›è¡¨ <py-to-json-table>` ã‚’ä½¿ã£ã¦ã€ *obj* ã‚’ JSON å½¢å¼ã® *fp* (``.write()`` ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ :term:`file-like object`) ã¸ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦ç›´åˆ—åŒ–ã—ã¾ã™ã€‚"

#: ../../library/json.rst:133
msgid ""
"If *skipkeys* is true (default: ``False``), then dict keys that are not of a"
" basic type (:class:`str`, :class:`unicode`, :class:`int`, :class:`long`, "
":class:`float`, :class:`bool`, ``None``) will be skipped instead of raising "
"a :exc:`TypeError`."
msgstr "*skipkeys* ãŒçœŸ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``False``) ãªã‚‰ã°ã€åŸºæœ¬å‹ (:class:`str`, :class:`unicode`, :class:`int`, :class:`long`, :class:`float`, :class:`bool`, ``None``) ä»¥å¤–ã®è¾æ›¸ã®ã‚­ãƒ¼ã¯ :exc:`TypeError` ã‚’é€å‡ºã›ãšã«èª­ã¿é£›ã°ã•ã‚Œã¾ã™ã€‚"

#: ../../library/json.rst:138
msgid ""
"If *ensure_ascii* is true (the default), all non-ASCII characters in the "
"output are escaped with ``\\uXXXX`` sequences, and the result is a "
":class:`str` instance consisting of ASCII characters only.  If "
"*ensure_ascii* is false, some chunks written to *fp* may be :class:`unicode`"
" instances.  This usually happens because the input contains unicode strings"
" or the *encoding* parameter is used.  Unless ``fp.write()`` explicitly "
"understands :class:`unicode` (as in :func:`codecs.getwriter`) this is likely"
" to cause an error."
msgstr "*ensure_ascii* ãŒçœŸ (ã“ã‚ŒãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã™) ãªã‚‰ã°å…¨ã¦ã®é ASCII æ–‡å­—ã¯å‡ºåŠ›ã«ãŠã„ã¦ ``\\uXXXX`` ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¦ã€çµæœã¯ ASCII æ–‡å­—ã®ã¿ã‹ã‚‰ãªã‚‹ :class:`str` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚Šã¾ã™ã€‚ *ensure_ascii* ãŒå½ã®å ´åˆã€ *fp* ã¸æ›¸ãè¾¼ã¾ã‚Œã‚‹ãƒãƒ£ãƒ³ã‚¯ã¯ :class:`unicode` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯æ™®é€šã¯å…¥åŠ›ã« Unicode æ–‡å­—åˆ—ã‚’å«ã‚€ã‹ã€ *encoding* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ä½¿ã†å ´åˆã«èµ·ã“ã‚Šã¾ã™ã€‚ ``fp.write()`` ãŒ (:func:`codecs.getwriter` ã§ã®ã‚ˆã†ã«)  :class:`unicode` ã§ã‚ã‚‹ã¨æ˜ç¤ºçš„ã«ç†è§£ã—ã¦ã„ãªã„é™ã‚Šã€ã“ã‚Œã¯ã‚¨ãƒ©ãƒ¼ã‚’å¼•ãèµ·ã“ã™ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/json.rst:147
msgid ""
"If *check_circular* is false (default: ``True``), then the circular "
"reference check for container types will be skipped and a circular reference"
" will result in an :exc:`OverflowError` (or worse)."
msgstr "*check_circular* ãŒ false (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``True``) ãªã‚‰ã°ã€ã‚³ãƒ³ãƒ†ãƒŠå‹ã®å¾ªç’°å‚ç…§ãƒã‚§ãƒƒã‚¯ãŒçœã‹ã‚Œã€å¾ªç’°å‚ç…§ãŒã‚ã‚Œã° :exc:`OverflowError` (ã¾ãŸã¯ã‚‚ã£ã¨æ‚ªã„çµæœ) ã«çµ‚ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/json.rst:151
msgid ""
"If *allow_nan* is false (default: ``True``), then it will be a "
":exc:`ValueError` to serialize out of range :class:`float` values (``nan``, "
"``inf``, ``-inf``) in strict compliance of the JSON specification. If "
"*allow_nan* is true, their JavaScript equivalents (``NaN``, ``Infinity``, "
"``-Infinity``) will be used."
msgstr "*allow_nan* ãŒå½ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``True``) ã®å ´åˆã€è¨±å®¹ç¯„å›²å¤–ã® :class:`float` å€¤ (``nan``, ``inf``, ``-inf``) ã‚’ JSON ä»•æ§˜ã‚’å³æ ¼ã«å®ˆã£ã¦ ç›´åˆ—åŒ–ã™ã‚‹ã¨ã€:exc:`ValueError` ã«ãªã‚Šã¾ã™ã€‚\n*allow_non* ãŒçœŸã®å ´åˆã¯ã€ JavaScript ã§ã®ç­‰ä¾¡ãªã‚‚ã® (``NaN``, ``Infinity``, ``-Infinity``) ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/json.rst:157
msgid ""
"If *indent* is a non-negative integer, then JSON array elements and object "
"members will be pretty-printed with that indent level.  An indent level of "
"0, or negative, will only insert newlines.  ``None`` (the default) selects "
"the most compact representation."
msgstr "*indent* ãŒéè² ã®æ•´æ•°ã§ã‚ã‚Œã°ã€JSON ã®é…åˆ—è¦ç´ ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ãƒ³ãƒã¯ãã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãƒ¬ãƒ™ãƒ«ã§è¦‹ã‚„ã™ãè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãƒ¬ãƒ™ãƒ«ãŒ 0 ã‹è² ã§ã‚ã‚Œã°æ”¹è¡Œã ã‘ãŒæŒ¿å…¥ã•ã‚Œã¾ã™ã€‚ ``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã§ã¯æœ€ã‚‚ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªè¡¨ç¾ãŒé¸æŠã•ã‚Œã¾ã™ã€‚"

#: ../../library/json.rst:164 ../../library/json.rst:438
msgid ""
"Since the default item separator is ``', '``,  the output might include "
"trailing whitespace when *indent* is specified.  You can use "
"``separators=(',', ': ')`` to avoid this."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¦ç´ ã®ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ãŒ ``', '`` ãªã®ã§ã€ *indent* ãŒæŒ‡å®šã•ã‚ŒãŸã¨ãã¯å‡ºåŠ›ã®æœ«å°¾ã«ç©ºç™½æ–‡å­—ãŒä»˜ãã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚\nã“ã‚Œã‚’é¿ã‘ã‚‹ãŸã‚ã« ``separators=(',', ': ')`` ãŒä½¿ãˆã¾ã™ã€‚"

#: ../../library/json.rst:168 ../../library/json.rst:442
msgid ""
"If specified, *separators* should be an ``(item_separator, key_separator)`` "
"tuple.  By default, ``(', ', ': ')`` are used.  To get the most compact JSON"
" representation, you should specify ``(',', ':')`` to eliminate whitespace."
msgstr "*separators* ã‚’æŒ‡å®šã™ã‚‹å ´åˆã¯ã€ ``(item_separator, key_separator)`` ã¨ã„ã†ã‚¿ãƒ—ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\nãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``(', ', ': ')`` ãŒä½¿ã‚ã‚Œã¾ã™ã€‚\næœ€ã‚‚ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãª JSON ã®è¡¨ç¾ã‚’å¾—ãŸã‘ã‚Œã°ç©ºç™½ã‚’å‰Šã£ãŸ ``(',', ':')`` ã‚’æŒ‡å®šã™ã‚Œã°ã„ã„ã§ã—ã‚‡ã†ã€‚"

#: ../../library/json.rst:172
msgid ""
"*encoding* is the character encoding for str instances, default is UTF-8."
msgstr "*encoding* ã¯æ–‡å­—åˆ—ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ UTF-8 ã§ã™ã€‚"

#: ../../library/json.rst:174 ../../library/json.rst:446
msgid ""
"If specified, *default* should be a function that gets called for objects "
"that can't otherwise be serialized.  It should return a JSON encodable "
"version of the object or raise a :exc:`TypeError`.  If not specified, "
":exc:`TypeError` is raised."
msgstr "*default* ã‚’æŒ‡å®šã™ã‚‹å ´åˆã¯é–¢æ•°ã‚’æŒ‡å®šã—ã¦ã€ã“ã®é–¢æ•°ã¯ãã‚Œä»¥å¤–ã§ã¯ç›´åˆ—åŒ–ã§ããªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚\nãã®é–¢æ•°ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ JSON ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ãã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã—ã¦è¿”ã™ã‹ã€ã•ã‚‚ãªã‘ã‚Œã° :exc:`TypeError` ã‚’é€å‡ºã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\næŒ‡å®šã—ãªã„å ´åˆã¯ã€ :exc:`TypeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/json.rst:179
msgid ""
"If *sort_keys* is true (default: ``False``), then the output of dictionaries"
" will be sorted by key."
msgstr "*sort_keys* ãŒ true (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ ``False`` ã§ã™)ã§ã‚ã‚Œã°ã€è¾æ›¸ã®å‡ºåŠ›ãŒã‚­ãƒ¼ã§ã‚½ãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/json.rst:182
msgid ""
"To use a custom :class:`JSONEncoder` subclass (e.g. one that overrides the "
":meth:`default` method to serialize additional types), specify it with the "
"*cls* kwarg; otherwise :class:`JSONEncoder` is used."
msgstr "ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã•ã‚ŒãŸ :class:`JSONEncoder` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ (ãŸã¨ãˆã°è¿½åŠ ã®å‹ã‚’ç›´åˆ—åŒ–ã™ã‚‹ã‚ˆã†ã« :meth:`default` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ãŸã‚‚ã®) ã‚’ä½¿ã†ã«ã¯ã€ *cls* ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã«æŒ‡å®šã—ã¾ã™; æŒ‡å®šã—ãªã‘ã‚Œã° :class:`JSONEncoder` ãŒä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/json.rst:188
msgid ""
"Unlike :mod:`pickle` and :mod:`marshal`, JSON is not a framed protocol so "
"trying to serialize more objects with repeated calls to :func:`dump` and the"
" same *fp* will result in an invalid JSON file."
msgstr ":mod:`pickle` ã‚„ :mod:`marshal` ã¨é•ã£ã¦ã€JSON ã¯ãƒ•ãƒ¬ãƒ¼ãƒ ä»˜ãã®ãƒ—ãƒ­ãƒˆã‚³ãƒ« (framed protocol) ã§ã¯ãªã„ã®ã§ã€åŒã˜ *fp* ã«å¯¾ã—ã¦ç¹°ã‚Šè¿”ã— :func:`dump` ã‚’å‘¼ã³ã€ãŸãã•ã‚“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç›´åˆ—åŒ–ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ä¸æ­£ãª JSON ãƒ•ã‚¡ã‚¤ãƒ«ãŒä½œã‚‰ã‚Œã¦ã—ã¾ã„ã¾ã™ã€‚"

#: ../../library/json.rst:197
msgid ""
"Serialize *obj* to a JSON formatted :class:`str` using this :ref:`conversion"
" table <py-to-json-table>`.  If *ensure_ascii* is false, the result may "
"contain non-ASCII characters and the return value may be a :class:`unicode` "
"instance."
msgstr "ã“ã® :ref:`å¤‰æ›è¡¨ <py-to-json-table>` ã‚’ä½¿ã£ã¦ã€ *obj* ã‚’ JSON å½¢å¼ã® :class:`str` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ç›´åˆ—åŒ–ã—ã¾ã™ã€‚\n*ensure_ascii* ãŒå½ã®å ´åˆã¯ã€çµæœã¯é ASCII ã‚’å«ã‚€ã‹ã‚‚ã—ã‚Œãšã€æˆ»ã‚Šå€¤ãŒ :class:`unicode` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/json.rst:202
msgid "The arguments have the same meaning as in :func:`dump`."
msgstr "å¼•æ•°ã¯ :func:`dump` ã®ã‚‚ã®ã¨åŒã˜æ„å‘³ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/json.rst:206
msgid ""
"Keys in key/value pairs of JSON are always of the type :class:`str`. When a "
"dictionary is converted into JSON, all the keys of the dictionary are "
"coerced to strings. As a result of this, if a dictionary is converted into "
"JSON and then back into a dictionary, the dictionary may not equal the "
"original one. That is, ``loads(dumps(x)) != x`` if x has non-string keys."
msgstr "JSON ã®ã‚­ãƒ¼å€¤ãƒšã‚¢ã®ã‚­ãƒ¼ã¯ã€å¸¸ã« :class:`str` å‹ã§ã™ã€‚è¾æ›¸ãŒ JSON ã«å¤‰æ›ã•ã‚Œã‚‹ã¨ãã€è¾æ›¸ã®å…¨ã¦ã®ã‚­ãƒ¼ã¯æ–‡å­—åˆ—ã¸å¼·åˆ¶çš„ã«å¤‰æ›ãŒè¡Œã‚ã‚Œã¾ã™ã€‚ã“ã®çµæœã¨ã—ã¦ã€è¾æ›¸ãŒ JSON ã«å¤‰æ›ã•ã‚Œã€ãã‚Œã‹ã‚‰è¾æ›¸ã«æˆ»ã•ã‚ŒãŸå ´åˆã€è¾æ›¸ã¯å…ƒã®ã‚‚ã®ã¨åŒã˜ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šæ–‡å­—åˆ—ã§ã¯ãªã„ã‚­ãƒ¼ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã€ ``loads(dumps(x)) != x`` ã¨ãªã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚"

#: ../../library/json.rst:215
msgid ""
"Deserialize *fp* (a ``.read()``-supporting :term:`file-like object` "
"containing a JSON document) to a Python object using this :ref:`conversion "
"table <json-to-py-table>`."
msgstr "ã“ã® :ref:`å¤‰æ›è¡¨ <json-to-py-table>` ã‚’ä½¿ã„ã€ *fp* (``.read()`` ã‚’ã‚µãƒãƒ¼ãƒˆã— JSON ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å«ã‚“ã§ã„ã‚‹ :term:`file-like object`) ã‚’ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸è„±ç›´åˆ—åŒ–ã—ã¾ã™ã€‚"

#: ../../library/json.rst:219
msgid ""
"If the contents of *fp* are encoded with an ASCII based encoding other than "
"UTF-8 (e.g. latin-1), then an appropriate *encoding* name must be specified."
" Encodings that are not ASCII based (such as UCS-2) are not allowed, and "
"should be wrapped with ``codecs.getreader(encoding)(fp)``, or simply decoded"
" to a :class:`unicode` object and passed to :func:`loads`."
msgstr "*fp* ã®å†…å®¹ãŒ ASCII ã«åŸºã¥ã„ãŸã—ã‹ã— UTF-8 ã§ã¯ãªã„ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° (ãŸã¨ãˆã° latin-1) ã‚’ä½¿ã£ã¦ã„ã‚‹ãªã‚‰ã°ã€é©åˆ‡ãª *encoding* åãŒæŒ‡å®šã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒ ASCII ã«åŸºã¥ã‹ãªã„ã‚‚ã® (UCS-2 ãªã©) ã§ã‚ã‚‹ã“ã¨ã¯è¨±ã•ã‚Œãªã„ã®ã§ã€ ``codecs.getreader(encoding)(fp)`` ã¨ã„ã†ã‚ˆã†ã«åŒ…ã‚€ã‹ã€ã¾ãŸã¯å˜ã« :class:`unicode` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ãŸã‚‚ã®ã‚’ :func:`loads` ã«æ¸¡ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/json.rst:225
msgid ""
"*object_hook* is an optional function that will be called with the result of"
" any object literal decoded (a :class:`dict`).  The return value of "
"*object_hook* will be used instead of the :class:`dict`.  This feature can "
"be used to implement custom decoders (e.g. `JSON-RPC "
"<http://www.jsonrpc.org>`_ class hinting)."
msgstr "*object_hook* ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®é–¢æ•°ã§ã€ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªãƒ†ãƒ©ãƒ«ãŒãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸçµæœ (:class:`dict`) ã«å¯¾ã—å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ *object_hook* ã®è¿”ã‚Šå€¤ã¯ :class:`dict` ã®ä»£ã‚ã‚Šã«ä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã¯ç‹¬è‡ªã®ãƒ‡ã‚³ãƒ¼ãƒ€ (ä¾‹ãˆã° `JSON-RPC <http://www.jsonrpc.org>`_ ã‚¯ãƒ©ã‚¹ãƒ’ãƒ³ãƒ†ã‚£ãƒ³ã‚°) ã‚’å®Ÿè£…ã™ã‚‹ã®ã«ä½¿ãˆã¾ã™ã€‚"

#: ../../library/json.rst:231
msgid ""
"*object_pairs_hook* is an optional function that will be called with the "
"result of any object literal decoded with an ordered list of pairs.  The "
"return value of *object_pairs_hook* will be used instead of the "
":class:`dict`.  This feature can be used to implement custom decoders that "
"rely on the order that the key and value pairs are decoded (for example, "
":func:`collections.OrderedDict` will remember the order of insertion). If "
"*object_hook* is also defined, the *object_pairs_hook* takes priority."
msgstr "*object_pairs_hook* ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§æ¸¡ã™é–¢æ•°ã§ã€ãƒšã‚¢ã®é †åºä»˜ããƒªã‚¹ãƒˆã®ãƒ‡ã‚³ãƒ¼ãƒ‰çµæœã«å¯¾ã—ã¦å‘¼ã°ã‚Œã¾ã™ã€‚ *object_pairs_hook* ã®è¿”ã‚Šå€¤ã¯ :class:`dict` ã®ä»£ã‚ã‚Šã«ä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã¯ã‚­ãƒ¼ã¨å€¤ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚Œã‚‹é †åºã«ä¾å­˜ã™ã‚‹ç‹¬è‡ªã®ãƒ‡ã‚³ãƒ¼ãƒ€ (ãŸã¨ãˆã° :func:`collections.OrderedDict` ã¯æŒ¿å…¥ã®é †åºã‚’è¨˜æ†¶ã—ã¾ã™) ã‚’å®Ÿè£…ã™ã‚‹ã®ã«ä½¿ãˆã¾ã™ã€‚ *object_hook* ã‚‚å®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ *object_pairs_hook* ãŒå„ªå…ˆã—ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/json.rst:239 ../../library/json.rst:333
msgid "Added support for *object_pairs_hook*."
msgstr "*object_pairs_hook* ã®ã‚µãƒãƒ¼ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/json.rst:242 ../../library/json.rst:336
msgid ""
"*parse_float*, if specified, will be called with the string of every JSON "
"float to be decoded.  By default, this is equivalent to ``float(num_str)``. "
"This can be used to use another datatype or parser for JSON floats (e.g. "
":class:`decimal.Decimal`)."
msgstr "*parse_float* ã¯ã€ã‚‚ã—æŒ‡å®šã•ã‚Œã‚Œã°ã€å…¨ã¦ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚Œã‚‹ JSON ã®æµ®å‹•å°æ•°ç‚¹æ•°æ–‡å­—åˆ—ã«å¯¾ã—ã¦å‘¼ã°ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ ``float(num_str)`` ã¨ç­‰ä¾¡ã§ã™ã€‚ã“ã‚Œã¯ JSON æµ®å‹•å°æ•°ç‚¹æ•°ã«å¯¾ã—ã¦ä»–ã®ãƒ‡ãƒ¼ã‚¿å‹ã‚„ãƒ‘ãƒ¼ã‚µ (ãŸã¨ãˆã° :class:`decimal.Decimal`) ã‚’ä½¿ã†ã®ã«ä½¿ãˆã¾ã™ã€‚"

#: ../../library/json.rst:247 ../../library/json.rst:341
msgid ""
"*parse_int*, if specified, will be called with the string of every JSON int "
"to be decoded.  By default, this is equivalent to ``int(num_str)``.  This "
"can be used to use another datatype or parser for JSON integers (e.g. "
":class:`float`)."
msgstr "*parse_int* ã¯ã€ã‚‚ã—æŒ‡å®šã•ã‚Œã‚Œã°ã€å…¨ã¦ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚Œã‚‹ JSON ã®æ•´æ•°æ–‡å­—åˆ—ã«å¯¾ã—ã¦å‘¼ã°ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ ``int(num_str)`` ã¨ç­‰ä¾¡ã§ã™ã€‚ã“ã‚Œã¯ JSON æ•´æ•°ã«å¯¾ã—ã¦ä»–ã®ãƒ‡ãƒ¼ã‚¿å‹ã‚„ãƒ‘ãƒ¼ã‚µ (ãŸã¨ãˆã° :class:`float`) ã‚’ä½¿ã†ã®ã«ä½¿ãˆã¾ã™ã€‚"

#: ../../library/json.rst:252 ../../library/json.rst:346
msgid ""
"*parse_constant*, if specified, will be called with one of the following "
"strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``. This can be used to "
"raise an exception if invalid JSON numbers are encountered."
msgstr "*parse_constant* ã¯ã€ã‚‚ã—æŒ‡å®šã•ã‚Œã‚Œã°ã€æ¬¡ã®æ–‡å­—åˆ—ã«å¯¾ã—ã¦å‘¼ã°ã‚Œã¾ã™: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``, ``'null'``, ``'true'``, ``'false'``ã€‚ã“ã‚Œã¯ä¸æ­£ãª JSON æ•°å€¤ã«é­é‡ã—ãŸã¨ãã«ä¾‹å¤–ã‚’é€å‡ºã™ã‚‹ã®ã«ä½¿ãˆã¾ã™ã€‚"

#: ../../library/json.rst:257
msgid ""
"*parse_constant* doesn't get called on 'null', 'true', 'false' anymore."
msgstr "'null', 'true', 'false' ã«å¯¾ã—ã¦ *parse_constant* ã¯å‘¼ã³ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/json.rst:260
msgid ""
"To use a custom :class:`JSONDecoder` subclass, specify it with the ``cls`` "
"kwarg; otherwise :class:`JSONDecoder` is used.  Additional keyword arguments"
" will be passed to the constructor of the class."
msgstr "ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã•ã‚ŒãŸ :class:`JSONDecoder` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã†ã«ã¯ã€ *cls* ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã«æŒ‡å®šã—ã¾ã™; æŒ‡å®šã—ãªã‹ã£ãŸå ´åˆã¯ :class:`JSONDecoder` ãŒä½¿ã‚ã‚Œã¾ã™ã€‚è¿½åŠ ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¯ã“ã®ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«å¼•ãæ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/json.rst:267
msgid ""
"Deserialize *s* (a :class:`str` or :class:`unicode` instance containing a "
"JSON document) to a Python object using this :ref:`conversion table <json-"
"to-py-table>`."
msgstr "ã“ã® :ref:`å¤‰æ›è¡¨ <json-to-py-table>` ã‚’ä½¿ã„ã€ *s* (JSON ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å«ã‚“ã§ã„ã‚‹ :class:`str` ã¾ãŸã¯ :class:`unicode` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹) ã‚’ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸è„±ç›´åˆ—åŒ–ã—ã¾ã™ã€‚"

#: ../../library/json.rst:271
msgid ""
"If *s* is a :class:`str` instance and is encoded with an ASCII based "
"encoding other than UTF-8 (e.g. latin-1), then an appropriate *encoding* "
"name must be specified.  Encodings that are not ASCII based (such as UCS-2) "
"are not allowed and should be decoded to :class:`unicode` first."
msgstr "*s* ãŒ ASCII ã«åŸºã¥ã„ãŸã—ã‹ã— UTF-8 ã§ã¯ãªã„ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° (ãŸã¨ãˆã° latin-1) ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸ :class:`str` ãªã‚‰ã°ã€é©åˆ‡ãª *encoding* åãŒæŒ‡å®šã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒ ASCII ã«åŸºã¥ã‹ãªã„ã‚‚ã® (UCS-2 ãªã©) ã§ã‚ã‚‹ã“ã¨ã¯è¨±ã•ã‚Œãªã„ã®ã§ã€ã¾ãš :class:`unicode` ã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/json.rst:276
msgid "The other arguments have the same meaning as in :func:`load`."
msgstr "ãã®ä»–ã®å¼•æ•°ã¯ :func:`load` ã®ã‚‚ã®ã¨åŒã˜æ„å‘³ã§ã™ã€‚"

#: ../../library/json.rst:280
msgid "Encoders and Decoders"
msgstr "ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ã¨ãƒ‡ã‚³ãƒ¼ãƒ€"

#: ../../library/json.rst:284
msgid "Simple JSON decoder."
msgstr "å˜ç´”ãª JSON ãƒ‡ã‚³ãƒ¼ãƒ€ã€‚"

#: ../../library/json.rst:286
msgid "Performs the following translations in decoding by default:"
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ãƒ‡ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®éš›ã€ä»¥ä¸‹ã®å¤‰æ›ã‚’è¡Œã„ã¾ã™:"

#: ../../library/json.rst:291 ../../library/json.rst:383
msgid "JSON"
msgstr "JSON"

#: ../../library/json.rst:291 ../../library/json.rst:383
msgid "Python"
msgstr "Python"

#: ../../library/json.rst:293 ../../library/json.rst:385
msgid "object"
msgstr "object"

#: ../../library/json.rst:293 ../../library/json.rst:385
msgid "dict"
msgstr "dict"

#: ../../library/json.rst:295 ../../library/json.rst:387
msgid "array"
msgstr "array"

#: ../../library/json.rst:295
msgid "list"
msgstr "list"

#: ../../library/json.rst:297 ../../library/json.rst:389
msgid "string"
msgstr "string"

#: ../../library/json.rst:297
msgid "unicode"
msgstr "unicode"

#: ../../library/json.rst:299
msgid "number (int)"
msgstr "number (int)"

#: ../../library/json.rst:299
msgid "int, long"
msgstr "int, long"

#: ../../library/json.rst:301
msgid "number (real)"
msgstr "number (real)"

#: ../../library/json.rst:301
msgid "float"
msgstr "float"

#: ../../library/json.rst:303 ../../library/json.rst:393
msgid "true"
msgstr "true"

#: ../../library/json.rst:303 ../../library/json.rst:393
msgid "True"
msgstr "True"

#: ../../library/json.rst:305 ../../library/json.rst:395
msgid "false"
msgstr "false"

#: ../../library/json.rst:305 ../../library/json.rst:395
msgid "False"
msgstr "False"

#: ../../library/json.rst:307 ../../library/json.rst:397
msgid "null"
msgstr "null"

#: ../../library/json.rst:307 ../../library/json.rst:397
msgid "None"
msgstr "None"

#: ../../library/json.rst:310
msgid ""
"It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as their "
"corresponding ``float`` values, which is outside the JSON spec."
msgstr "ã¾ãŸã€ã“ã®ãƒ‡ã‚³ãƒ¼ãƒ€ã¯ ``NaN``, ``Infinity``, ``-Infinity`` ã‚’å¯¾å¿œã™ã‚‹ ``float`` ã®å€¤ã¨ã—ã¦ã€JSON ã®ä»•æ§˜ã‹ã‚‰ã¯å¤–ã‚Œã¾ã™ãŒã€ç†è§£ã—ã¾ã™ã€‚"

#: ../../library/json.rst:313
msgid ""
"*encoding* determines the encoding used to interpret any :class:`str` "
"objects decoded by this instance (UTF-8 by default).  It has no effect when "
"decoding :class:`unicode` objects."
msgstr "*encoding* ã¯ã“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚Œã‚‹ :class:`str` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è§£é‡ˆã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ UTF-8) ã‚’å®šã‚ã¾ã™ã€‚ :class:`unicode` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«ã¯å½±éŸ¿ã‚’ä¸ãˆã¾ã›ã‚“ã€‚"

#: ../../library/json.rst:317
msgid ""
"Note that currently only encodings that are a superset of ASCII work, "
"strings of other encodings should be passed in as :class:`unicode`."
msgstr "æ³¨æ„ã—ã¦æ¬²ã—ã„ã®ã¯ç¾çŠ¶ã§ã¯ ASCII ã®ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚»ãƒƒãƒˆã§ã‚ã‚‹ã‚ˆã†ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã ã‘ã†ã¾ãå‹•ãã¨ã„ã†ã“ã¨ã§ã™ã€‚ä»–ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®æ–‡å­—åˆ—ã¯ :class:`unicode` ã«ã—ã¦æ¸¡ã—ã¦ä¸‹ã•ã„ã€‚"

#: ../../library/json.rst:320
msgid ""
"*object_hook*, if specified, will be called with the result of every JSON "
"object decoded and its return value will be used in place of the given "
":class:`dict`.  This can be used to provide custom deserializations (e.g. to"
" support JSON-RPC class hinting)."
msgstr "*object_hook* ã¯ã€ã‚‚ã—æŒ‡å®šã•ã‚Œã‚Œã°ã€å…¨ã¦ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸ JSON ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦å‘¼ã°ã‚Œãã®è¿”å€¤ã¯ä¸ãˆã‚‰ã‚ŒãŸ :class:`dict` ã®ä»£ã‚ã‚Šã«ä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã¯ç‹¬è‡ªã®è„±ç›´åˆ—åŒ– (ãŸã¨ãˆã° JSON-RPC ã‚¯ãƒ©ã‚¹ãƒ’ãƒ³ãƒ†ã‚£ãƒ³ã‚°ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ãª) ã‚’æä¾›ã™ã‚‹ã®ã«ä½¿ãˆã¾ã™ã€‚"

#: ../../library/json.rst:325
msgid ""
"*object_pairs_hook*, if specified will be called with the result of every "
"JSON object decoded with an ordered list of pairs.  The return value of "
"*object_pairs_hook* will be used instead of the :class:`dict`.  This feature"
" can be used to implement custom decoders that rely on the order that the "
"key and value pairs are decoded (for example, "
":func:`collections.OrderedDict` will remember the order of insertion). If "
"*object_hook* is also defined, the *object_pairs_hook* takes priority."
msgstr "*object_pairs_hook* ã¯ã€ã‚‚ã—æŒ‡å®šã•ã‚Œã‚Œã°ã€å…¨ã¦ã®ãƒšã‚¢ã®é †åºä»˜ããƒªã‚¹ãƒˆã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸ JSON ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦å‘¼ã°ã‚Œã¾ã™ã€‚ *object_pairs_hook* ã®è¿”ã‚Šå€¤ã¯ :class:`dict` ã®ä»£ã‚ã‚Šã«ä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã¯ã‚­ãƒ¼ã¨å€¤ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚Œã‚‹é †åºã«ä¾å­˜ã™ã‚‹ç‹¬è‡ªã®ãƒ‡ã‚³ãƒ¼ãƒ€ (ãŸã¨ãˆã° :func:`collections.OrderedDict` ã¯æŒ¿å…¥ã®é †åºã‚’è¨˜æ†¶ã—ã¾ã™) ã‚’å®Ÿè£…ã™ã‚‹ã®ã«ä½¿ãˆã¾ã™ã€‚ *object_hook* ã‚‚å®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ *object_pairs_hook* ãŒå„ªå…ˆã—ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/json.rst:351
msgid ""
"If *strict* is false (``True`` is the default), then control characters will"
" be allowed inside strings.  Control characters in this context are those "
"with character codes in the 0--31 range, including ``'\\t'`` (tab), "
"``'\\n'``, ``'\\r'`` and ``'\\0'``."
msgstr "*strict* ãŒ false (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``True``) ã®å ´åˆã€åˆ¶å¾¡æ–‡å­—ã‚’æ–‡å­—åˆ—ã«å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã“ã§è¨€ã†åˆ¶å¾¡æ–‡å­—ã¨ã¯ã€``'\\t'`` (ã‚¿ãƒ–)ã€``'\\n'``ã€``'\\r'``ã€``'\\0'`` ã‚’å«ã‚€ 0-31 ã®ç¯„å›²ã®ã‚³ãƒ¼ãƒ‰ã‚’æŒã¤æ–‡å­—ã®ã“ã¨ã§ã™ã€‚"

#: ../../library/json.rst:356
msgid ""
"If the data being deserialized is not a valid JSON document, a "
":exc:`ValueError` will be raised."
msgstr "è„±ç›´åˆ—åŒ–ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒä¸æ­£ãª JSON ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã ã£ãŸå ´åˆã€ :exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/json.rst:361
msgid ""
"Return the Python representation of *s* (a :class:`str` or :class:`unicode` "
"instance containing a JSON document)."
msgstr "*s* (:class:`str` ã¾ãŸã¯ :class:`unicode` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ JSON æ–‡æ›¸ã‚’å«ã‚€ã‚‚ã®) ã® Python è¡¨ç¾ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/json.rst:366
msgid ""
"Decode a JSON document from *s* (a :class:`str` or :class:`unicode` "
"beginning with a JSON document) and return a 2-tuple of the Python "
"representation and the index in *s* where the document ended."
msgstr "*s* (:class:`str` ã¾ãŸã¯ :class:`unicode` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ JSON æ–‡æ›¸ã§å§‹ã¾ã‚‹ã‚‚ã®) ã‹ã‚‰ JSON æ–‡æ›¸ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã€Python è¡¨ç¾ã¨ *s* ã®æ–‡æ›¸ã®çµ‚ã‚ã‚‹ã¨ã“ã‚ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰ãªã‚‹ 2 è¦ç´ ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/json.rst:370
msgid ""
"This can be used to decode a JSON document from a string that may have "
"extraneous data at the end."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¾Œã‚ã«ä½™åˆ†ãªãƒ‡ãƒ¼ã‚¿ã‚’å¾“ãˆãŸæ–‡å­—åˆ—ã‹ã‚‰ JSON æ–‡æ›¸ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã™ã‚‹ã®ã«ä½¿ãˆã¾ã™ã€‚"

#: ../../library/json.rst:376
msgid "Extensible JSON encoder for Python data structures."
msgstr "Python ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«å¯¾ã™ã‚‹æ‹¡å¼µå¯èƒ½ãª JSON ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ã€‚"

#: ../../library/json.rst:378
msgid "Supports the following objects and types by default:"
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ä»¥ä¸‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨å‹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™:"

#: ../../library/json.rst:387
msgid "list, tuple"
msgstr "list, tuple"

#: ../../library/json.rst:389
msgid "str, unicode"
msgstr "str, unicode"

#: ../../library/json.rst:391
msgid "int, long, float"
msgstr "int, long, float"

#: ../../library/json.rst:391
msgid "number"
msgstr "number"

#: ../../library/json.rst:400
msgid ""
"To extend this to recognize other objects, subclass and implement a "
":meth:`default` method with another method that returns a serializable "
"object for ``o`` if possible, otherwise it should call the superclass "
"implementation (to raise :exc:`TypeError`)."
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã‚’æ‹¡å¼µã—ã¦ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚èªè­˜ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ã«ã¯ã€ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½œã£ã¦ :meth:`default` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ¬¡ã®ã‚ˆã†ã«å®Ÿè£…ã—ã¾ã™ã€‚ã‚‚ã†ä¸€ã¤åˆ¥ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ``o`` ã«å¯¾ã™ã‚‹ç›´åˆ—åŒ–å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã‚‚ã®ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«ã—ã¾ã™ã€‚å¤‰æ›ã§ããªã„æ™‚ã¯ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹ã®å®Ÿè£…ã‚’ (:exc:`TypeError` ã‚’é€å‡ºã•ã›ã‚‹ãŸã‚ã«) å‘¼ã°ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/json.rst:405
msgid ""
"If *skipkeys* is false (the default), then it is a :exc:`TypeError` to "
"attempt encoding of keys that are not str, int, long, float or ``None``.  If"
" *skipkeys* is true, such items are simply skipped."
msgstr "*skipkeys* ãŒå½ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã°ã€str, int, long, float, ``None`` ä»¥å¤–ã®ã‚­ãƒ¼ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹è©¦ã¿ã¯ :exc:`TypeError` ã«çµ‚ã‚ã‚Šã¾ã™ã€‚ *skipkeys* ãŒçœŸã®å ´åˆã¯ã€ãã‚Œã‚‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã¯å˜ã«èª­ã¿é£›ã°ã•ã‚Œã¾ã™ã€‚"

#: ../../library/json.rst:409
msgid ""
"If *ensure_ascii* is true (the default), all non-ASCII characters in the "
"output are escaped with ``\\uXXXX`` sequences, and the results are "
":class:`str` instances consisting of ASCII characters only. If "
"*ensure_ascii* is false, a result may be a :class:`unicode` instance. This "
"usually happens if the input contains unicode strings or the *encoding* "
"parameter is used."
msgstr "*ensure_ascii* ãŒçœŸ (ã“ã‚ŒãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã™) ã®å ´åˆã€å…¨ã¦ã®é ASCII æ–‡å­—ã¯å‡ºåŠ›ã«ãŠã„ã¦ ``\\uXXXX`` ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¦ã€çµæœã¯ ASCII æ–‡å­—ã®ã¿ã‹ã‚‰ãªã‚‹ :class:`str` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚Šã¾ã™ã€‚\n*ensure_ascii* ãŒå½ã®å ´åˆã€ çµæœã¯ :class:`unicode` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚\nã“ã‚Œã¯æ™®é€šã¯å…¥åŠ›ã« Unicode æ–‡å­—åˆ—ã‚’å«ã‚€ã‹ã€ *encoding* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ä½¿ã†å ´åˆã«èµ·ã“ã‚Šã¾ã™ã€‚"

#: ../../library/json.rst:416
msgid ""
"If *check_circular* is true (the default), then lists, dicts, and custom "
"encoded objects will be checked for circular references during encoding to "
"prevent an infinite recursion (which would cause an :exc:`OverflowError`). "
"Otherwise, no such check takes place."
msgstr "*check_circular* ãŒ true (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã°ã€ãƒªã‚¹ãƒˆã€è¾æ›¸ãŠã‚ˆã³è‡ªä½œã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¾ªç’°å‚ç…§ãŒãªã„ã‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ä¸­ã«ãƒã‚§ãƒƒã‚¯ã•ã‚Œã€ç„¡é™å†å¸° (ã“ã‚Œã¯ :exc:`OverflowError` ã‚’å¼•ãèµ·ã“ã—ã¾ã™) ã‚’é˜²æ­¢ã—ã¾ã™ã€‚ ``True`` ã§ãªã„å ´åˆã¯ã€ãã†ã„ã£ãŸãƒã‚§ãƒƒã‚¯ã¯æ–½ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/json.rst:421
msgid ""
"If *allow_nan* is true (the default), then ``NaN``, ``Infinity``, and "
"``-Infinity`` will be encoded as such.  This behavior is not JSON "
"specification compliant, but is consistent with most JavaScript based "
"encoders and decoders.  Otherwise, it will be a :exc:`ValueError` to encode "
"such floats."
msgstr "*allow_nan* ãŒ true (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ãªã‚‰ã°ã€ ``NaN``, ``Infinity``, ``-Infinity`` ã¯ãã®ã¾ã¾ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ã€‚ã“ã®æŒ¯ã‚‹èˆã„ã¯ JSON ä»•æ§˜ã«å¾“ã£ã¦ã„ã¾ã›ã‚“ãŒã€å¤§åŠã® JavaScript ãƒ™ãƒ¼ã‚¹ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ã€ãƒ‡ã‚³ãƒ¼ãƒ€ã¨çŸ›ç›¾ã—ã¾ã›ã‚“ã€‚ ``True`` ã§ãªã„å ´åˆã¯ã€ãã®ã‚ˆã†ãªæµ®å‹•å°æ•°ç‚¹æ•°ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ã¨ :exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/json.rst:427
msgid ""
"If *sort_keys* is true (default: ``False``), then the output of dictionaries"
" will be sorted by key; this is useful for regression tests to ensure that "
"JSON serializations can be compared on a day-to-day basis."
msgstr "*sort_keys* ãŒ true (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``False``) ãªã‚‰ã°ã€è¾æ›¸ã®å‡ºåŠ›ãŒã‚­ãƒ¼ã§ã‚½ãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ JSON ã®ç›´åˆ—åŒ–ãŒã„ã¤ã§ã‚‚æ¯”è¼ƒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã®ã§å›å¸°è©¦é¨“ã®éš›ã«ä¾¿åˆ©ã§ã™ã€‚"

#: ../../library/json.rst:431
msgid ""
"If *indent* is a non-negative integer (it is ``None`` by default), then JSON"
" array elements and object members will be pretty-printed with that indent "
"level.  An indent level of 0 will only insert newlines.  ``None`` is the "
"most compact representation."
msgstr "*indent* ãŒéè² ã®æ•´æ•°ã§ã‚ã‚Œã° (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ ``None`` ã§ã™)ã€JSON ã®é…åˆ—è¦ç´ ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ãƒ³ãƒã¯ãã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãƒ¬ãƒ™ãƒ«ã§è¦‹ã‚„ã™ãè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãƒ¬ãƒ™ãƒ«ãŒ 0 ã§ã‚ã‚Œã° æ”¹è¡Œã ã‘ãŒæŒ¿å…¥ã•ã‚Œã¾ã™ã€‚``None`` ã§ã¯æœ€ã‚‚ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªè¡¨ç¾ãŒé¸æŠã•ã‚Œã¾ã™ã€‚"

#: ../../library/json.rst:451
msgid ""
"If *encoding* is not ``None``, then all input strings will be transformed "
"into unicode using that encoding prior to JSON-encoding.  The default is "
"UTF-8."
msgstr "*encoding* ãŒ ``None`` ã§ãªã‘ã‚Œã°ã€å…¥åŠ›æ–‡å­—åˆ—ã¯å…¨ã¦ JSON ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«å…ˆç«‹ã£ã¦ã“ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ Unicode ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ UTF-8 ã§ã™ã€‚"

#: ../../library/json.rst:458
msgid ""
"Implement this method in a subclass such that it returns a serializable "
"object for *o*, or calls the base implementation (to raise a "
":exc:`TypeError`)."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ã™ã‚‹éš›ã«ã¯ *o* ã«å¯¾ã—ã¦ç›´åˆ—åŒ–å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã‹ã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®å®Ÿè£…ã‚’ (:exc:`TypeError` ã‚’é€å‡ºã™ã‚‹ãŸã‚ã«) å‘¼ã³å‡ºã™ã‹ã—ã¾ã™ã€‚"

#: ../../library/json.rst:462
msgid ""
"For example, to support arbitrary iterators, you could implement default "
"like this::"
msgstr "ãŸã¨ãˆã°ã€ä»»æ„ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ã€æ¬¡ã®ã‚ˆã†ã«å®Ÿè£…ã—ã¾ã™::"

#: ../../library/json.rst:478
msgid ""
"Return a JSON string representation of a Python data structure, *o*.  For "
"example::"
msgstr "Python ãƒ‡ãƒ¼ã‚¿æ§‹é€  *o* ã® JSON æ–‡å­—åˆ—è¡¨ç¾ã‚’è¿”ã—ã¾ã™ã€‚ãŸã¨ãˆã°::"

#: ../../library/json.rst:487
msgid ""
"Encode the given object, *o*, and yield each string representation as "
"available.  For example::"
msgstr "ä¸ãˆã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ *o* ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã€å¾—ã‚‰ã‚ŒãŸæ–‡å­—åˆ—è¡¨ç¾ã”ã¨ã« yield ã—ã¾ã™ã€‚ãŸã¨ãˆã°::"

#: ../../library/json.rst:495
msgid "Standard Compliance and Interoperability"
msgstr "æ¨™æº–ã¸ã®æº–æ‹ ã¨äº’æ›æ€§"

#: ../../library/json.rst:497
msgid ""
"The JSON format is specified by :rfc:`7159` and by `ECMA-404 <http://www"
".ecma-international.org/publications/standards/Ecma-404.htm>`_. This section"
" details this module's level of compliance with the RFC. For simplicity, "
":class:`JSONEncoder` and :class:`JSONDecoder` subclasses, and parameters "
"other than those explicitly mentioned, are not considered."
msgstr "JSON å½¢å¼ã®ä»•æ§˜ã¯ :rfc:`7159` ã¨ `ECMA-404 <http://www.ecma-international.org/publications/standards/Ecma-404.htm>`_ ã§è¦å®šã•ã‚Œã¦ã„ã¾ã™ã€‚ ã“ã®ç¯€ã§ã¯ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® RFC ã¸ã®æº–æ‹ æ°´æº–ã«ã¤ã„ã¦è©³ã—ãè¿°ã¹ã¾ã™ã€‚ ç°¡å˜ã®ãŸã‚ã«ã€ :class:`JSONEncoder` ãŠã‚ˆã³ :class:`JSONDecoder` ã®å­ã‚¯ãƒ©ã‚¹ã¨ã€æ˜ç¤ºçš„ã«è§¦ã‚Œã‚‰ã‚Œã¦ã„ãªã„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã¤ã„ã¦ã¯è€ƒæ…®ã—ãªã„ã“ã¨ã«ã—ã¾ã™ã€‚"

#: ../../library/json.rst:503
msgid ""
"This module does not comply with the RFC in a strict fashion, implementing "
"some extensions that are valid JavaScript but not valid JSON.  In "
"particular:"
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€JavaScript ã§ã¯æ­£ã—ã„ãŒ JSON ã§ã¯ä¸æ­£ãªã„ãã¤ã‹ã®æ‹¡å¼µãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€å³å¯†ãªæ„å‘³ã§ã¯ RFC ã«æº–æ‹ ã—ã¦ã„ã¾ã›ã‚“ã€‚ç‰¹ã«:"

#: ../../library/json.rst:506
msgid "Infinite and NaN number values are accepted and output;"
msgstr "ç„¡é™ãŠã‚ˆã³ NaN ã®æ•°å€¤ã‚’å—ã‘ä»˜ã‘ã€ã¾ãŸå‡ºåŠ›ã—ã¾ã™;"

#: ../../library/json.rst:507
msgid ""
"Repeated names within an object are accepted, and only the value of the last"
" name-value pair is used."
msgstr "ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå†…ã§ã®åŒã˜åå‰ã®ç¹°ã‚Šè¿”ã—ã‚’å—ã‘ä»˜ã‘ã€æœ€å¾Œã®åå‰ã¨å€¤ã®ãƒšã‚¢ã®å€¤ã®ã¿ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/json.rst:510
msgid ""
"Since the RFC permits RFC-compliant parsers to accept input texts that are "
"not RFC-compliant, this module's deserializer is technically RFC-compliant "
"under default settings."
msgstr "ã“ã® RFC ã¯ã€RFC æº–æ‹ ã®ãƒ‘ãƒ¼ã‚µãŒ RFC æº–æ‹ ã§ãªã„å…¥åŠ›ãƒ†ã‚­ã‚¹ãƒˆã‚’å—ã‘ä»˜ã‘ã‚‹ã“ã¨ã‚’è¨±å®¹ã—ã¦ã„ã‚‹ã®ã§ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è„±ç›´åˆ—åŒ–ã¯æŠ€è¡“çš„ã«è¨€ãˆã°ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¨­å®šã§ã¯ RFC ã«æº–æ‹ ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/json.rst:515
msgid "Character Encodings"
msgstr "æ–‡å­—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°"

#: ../../library/json.rst:517
msgid ""
"The RFC requires that JSON be represented using either UTF-8, UTF-16, or "
"UTF-32, with UTF-8 being the recommended default for maximum "
"interoperability. Accordingly, this module uses UTF-8 as the default for its"
" *encoding* parameter."
msgstr "RFC ã¯ã€UTF-8ã€UTF-16ã€UTF-32ã®ã„ãšã‚Œã‹ã§JSONã‚’è¡¨ç¾ã™ã‚‹ã‚ˆã†ã«è¦æ±‚ã—ã¦ãŠã‚Šã€UTF-8 ãŒæœ€å¤§ã®äº’æ›æ€§ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã«æ¨å¥¨ã•ã‚Œã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã™ã€‚ã“ã®ãŸã‚ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ *encoding* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã« UTF-8 ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/json.rst:521
msgid ""
"This module's deserializer only directly works with ASCII-compatible "
"encodings; UTF-16, UTF-32, and other ASCII-incompatible encodings require "
"the use of workarounds described in the documentation for the deserializer's"
" *encoding* parameter."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã¯ç›´æ¥çš„ã«ã¯ã€ASCII äº’æ›ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã®ã¿å‹•ä½œã—ã¾ã™ã€‚UTF-16, UTF-32 ã‚„ã»ã‹ã® ASCII éäº’æ›ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«ã¯ã€ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå†…ã§ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã® *encoding* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã¤ã„ã¦èª¬æ˜ã—ãŸå›é¿æ–¹æ³•ã‚’å–ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/json.rst:526
msgid ""
"As permitted, though not required, by the RFC, this module's serializer sets"
" *ensure_ascii=True* by default, thus escaping the output so that the "
"resulting strings only contain ASCII characters."
msgstr "RFC ã§è¦æ±‚ã§ã¯ãªãè¨±å¯ã•ã‚Œã¦ã„ã‚‹é€šã‚Šã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ *ensure_ascii=True* ã¨ã„ã†è¨­å®šã‚’ç”¨ã„ã€å¾“ã£ã¦ã€çµæœã®æ–‡å­—åˆ—ãŒ ASCII æ–‡å­—ã—ã‹å«ã¾ãªã„ã‚ˆã†ã«å‡ºåŠ›ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã—ã¾ã™ã€‚"

#: ../../library/json.rst:530
msgid ""
"The RFC prohibits adding a byte order mark (BOM) to the start of a JSON "
"text, and this module's serializer does not add a BOM to its output. The RFC"
" permits, but does not require, JSON deserializers to ignore an initial BOM "
"in their input.  This module's deserializer raises a :exc:`ValueError` when "
"an initial BOM is present."
msgstr "RFC ã¯ JSON ãƒ†ã‚­ã‚¹ãƒˆã®æœ€åˆã«ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒãƒ¼ã‚¯(BOM)ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã‚’ç¦æ­¢ã—ã¦ã„ã¾ã™ã®ã§ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãã®å‡ºåŠ›ã« BOM ã‚’è¿½åŠ ã—ã¾ã›ã‚“ã€‚RFC ã¯ JSON ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ãŒå…¥åŠ›ã®ä¸€ç•ªæœ€åˆã® BOM ã‚’ç„¡è¦–ã™ã‚‹ã“ã¨ã‚’ã€è¨±å®¹ã¯ã—ã¾ã™ãŒæ±‚ã‚ã¦ã¯ã„ã¾ã›ã‚“ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã¯ä¸€ç•ªæœ€åˆã® BOM ã‚’è¦‹ã¤ã‘ã‚‹ã¨ :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/json.rst:536
msgid ""
"The RFC does not explicitly forbid JSON strings which contain byte sequences"
" that don't correspond to valid Unicode characters (e.g. unpaired UTF-16 "
"surrogates), but it does note that they may cause interoperability problems."
" By default, this module accepts and outputs (when present in the original "
":class:`str`) code points for such sequences."
msgstr "RFC ã¯ JSON æ–‡å­—åˆ—ã«æ­£å½“ãª Unicode æ–‡å­—ã«å¯¾å¿œä»˜ã‹ãªã„ãƒã‚¤ãƒˆåˆ—(ä¾‹ãˆã°ãƒšã‚¢ã«ãªã‚‰ãªã„ UTF-16 ã‚µãƒ­ã‚²ãƒ¼ãƒˆã®ã‹ãŸã‚ã‚Œ)ãŒå«ã¾ã‚Œã‚‹ã“ã¨ã‚’æ˜ç¤ºçš„ã«ç¦æ­¢ã—ã¦ã¯ãŠã‚‰ãšã€ã‚‚ã¡ã‚ã‚“ã“ã‚Œã¯ç›¸äº’é‹ç”¨æ€§ã®å•é¡Œã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯(ã‚ªãƒªã‚¸ãƒŠãƒ«ã® :class:`str` ã«ã‚ã‚‹å ´åˆ)ãã®ã‚ˆã†ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å—ã‘å–ã‚Šã€å‡ºåŠ›ã—ã¾ã™ã€‚"

#: ../../library/json.rst:544
msgid "Infinite and NaN Number Values"
msgstr "ç„¡é™ãŠã‚ˆã³ NaN ã®æ•°å€¤"

#: ../../library/json.rst:546
msgid ""
"The RFC does not permit the representation of infinite or NaN number values."
" Despite that, by default, this module accepts and outputs ``Infinity``, "
"``-Infinity``, and ``NaN`` as if they were valid JSON number literal "
"values::"
msgstr "RFC ã¯ã€ç„¡é™ã‚‚ã—ãã¯ NaN ã®æ•°å€¤ã®è¡¨ç¾ã¯è¨±å¯ã—ã¦ã„ã¾ã›ã‚“ã€‚ãã‚Œã«ã‚‚é–¢ã‚ã‚‰ãšãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ ``Infinity``ã€``-Infinity``ã€``NaN`` ã‚’æ­£ã—ã„ JSON ã®æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã®å€¤ã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«å—ã‘ä»˜ã‘ã€å‡ºåŠ›ã—ã¾ã™::"

#: ../../library/json.rst:561
msgid ""
"In the serializer, the *allow_nan* parameter can be used to alter this "
"behavior.  In the deserializer, the *parse_constant* parameter can be used "
"to alter this behavior."
msgstr "ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã§ã¯ã€ã“ã®æŒ¯ã‚‹èˆã„ã‚’å¤‰æ›´ã™ã‚‹ã®ã« *allow_nan* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒä½¿ãˆã¾ã™ã€‚ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã§ã¯ã€ã“ã®æŒ¯ã‚‹èˆã„ã‚’å¤‰æ›´ã™ã‚‹ã®ã« *parse_constant* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒä½¿ãˆã¾ã™ã€‚"

#: ../../library/json.rst:567
msgid "Repeated Names Within an Object"
msgstr "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸­ã«é‡è¤‡ã—ãŸåå‰ã®æ‰±ã„"

#: ../../library/json.rst:569
msgid ""
"The RFC specifies that the names within a JSON object should be unique, but "
"does not mandate how repeated names in JSON objects should be handled.  By "
"default, this module does not raise an exception; instead, it ignores all "
"but the last name-value pair for a given name::"
msgstr "RFC ã¯ JSON ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸­ã®åå‰ã¯ãƒ¦ãƒ‹ãƒ¼ã‚¯ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨è¦å®šã—ã¦ã„ã¾ã™ãŒã€JSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§åå‰ãŒç¹°ã‚Šè¿”ã•ã‚ŒãŸå ´åˆã®æ‰±ã„ã«ã¤ã„ã¦æŒ‡å®šã—ã¦ã„ã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ä¾‹å¤–ã‚’é€å‡ºã›ãšã€ã‹ã‚ã‚Šã«é‡è¤‡ã—ãŸåå‰ã®ã†ã¡ã€æœ€å¾Œã«å‡ºç¾ã—ãŸåå‰ã¨å€¤ã®ãƒšã‚¢ä»¥å¤–ã‚’ç„¡è¦–ã—ã¾ã™ã€‚"

#: ../../library/json.rst:578
msgid "The *object_pairs_hook* parameter can be used to alter this behavior."
msgstr "*object_pairs_hook* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ã“ã®å‹•ä½œã‚’å¤‰æ›´ã§ãã¾ã™ã€‚"

#: ../../library/json.rst:582
msgid "Top-level Non-Object, Non-Array Values"
msgstr "ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®éã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€éé…åˆ—ã®å€¤ã®æ‰±ã„"

#: ../../library/json.rst:584
msgid ""
"The old version of JSON specified by the obsolete :rfc:`4627` required that "
"the top-level value of a JSON text must be either a JSON object or array "
"(Python :class:`dict` or :class:`list`), and could not be a JSON null, "
"boolean, number, or string value.  :rfc:`7159` removed that restriction, and"
" this module does not and has never implemented that restriction in either "
"its serializer or its deserializer."
msgstr "å»ƒæ­¢ã•ã‚ŒãŸ :rfc:`4627` ã«ã‚ˆã£ã¦è¦å®šã•ã‚ŒãŸå¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® JSON ã§ã¯ã€JSON ãƒ†ã‚­ã‚¹ãƒˆã®ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®å€¤ã¯ JSON ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹é…åˆ—(Python ã§ã® :class:`dict` ã‹ :class:`list`)ã§ã‚ã‚‹ã“ã¨ã‚’è¦æ±‚ã—ã¦ã„ã¦ã€JSON ã® null, boolean, number, string ã§ã‚ã‚‹ã“ã¨ã¯è¨±ã•ã‚Œã¦ã„ã¾ã›ã‚“ã§ã—ãŸãŒã€ã“ã®åˆ¶é™ã¯ :rfc:`7159` ã«ã‚ˆã‚Šå–ã‚Šæ‰•ã‚ã‚Œã¾ã—ãŸã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã“ã®åˆ¶é™ã‚’æŒã£ã¦ã„ã¾ã›ã‚“ã—ã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã§ã‚‚ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã§ã‚‚ã€ä¸€åº¦ã¨ã—ã¦ã“ã®åˆ¶é™ã§å®Ÿè£…ã•ã‚ŒãŸã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/json.rst:591
msgid ""
"Regardless, for maximum interoperability, you may wish to voluntarily adhere"
" to the restriction yourself."
msgstr "ãã‚Œã«ã‚‚é–¢ã‚ã‚‰ãšã€ç›¸äº’é‹ç”¨å¯èƒ½æ€§ã‚’æœ€å¤§åŒ–ã—ãŸã„ãªã‚‰ã°ã€ã‚ãªãŸè‡ªèº«ã®æ‰‹ã§è‡ªç™ºçš„ã«ãã®åˆ¶ç´„ã«å¿ å®Ÿã«å¾“ã„ãŸã„ã¨æ€ã†ã§ã—ã‚‡ã†ã€‚"

#: ../../library/json.rst:596
msgid "Implementation Limitations"
msgstr "å®Ÿè£…ã®åˆ¶é™"

#: ../../library/json.rst:598
msgid "Some JSON deserializer implementations may set limits on:"
msgstr "ã„ãã¤ã‹ã® JSON ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã®å®Ÿè£…ã¯ã€ä»¥ä¸‹ã®åˆ¶é™ã‚’è¨­å®šã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/json.rst:600
msgid "the size of accepted JSON texts"
msgstr "å—ã‘å…¥ã‚Œã‚‰ã‚Œã‚‹ JSON ãƒ†ã‚­ã‚¹ãƒˆã®ã‚µã‚¤ã‚º"

#: ../../library/json.rst:601
msgid "the maximum level of nesting of JSON objects and arrays"
msgstr "JSON ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨é…åˆ—ã®ãƒã‚¹ãƒˆã®æœ€å¤§ã®æ·±ã•"

#: ../../library/json.rst:602
msgid "the range and precision of JSON numbers"
msgstr "JSON æ•°å€¤ã®ç¯„å›²ã¨ç²¾åº¦"

#: ../../library/json.rst:603
msgid "the content and maximum length of JSON strings"
msgstr "JSON æ–‡å­—åˆ—ã®å†…å®¹ã¨æœ€å¤§ã®é•·ã•"

#: ../../library/json.rst:605
msgid ""
"This module does not impose any such limits beyond those of the relevant "
"Python datatypes themselves or the Python interpreter itself."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯é–¢é€£ã™ã‚‹ Python ãƒ‡ãƒ¼ã‚¿å‹ã‚„ Python ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿è‡ªèº«ã®åˆ¶ç´„ã®ä¸–ç•Œã‚’è¶…ãˆãŸãã®ã‚ˆã†ãªåˆ¶ç´„ã‚’å¼·è¦ã¯ã—ã¾ã›ã‚“ã€‚"

#: ../../library/json.rst:608
msgid ""
"When serializing to JSON, beware any such limitations in applications that "
"may consume your JSON.  In particular, it is common for JSON numbers to be "
"deserialized into IEEE 754 double precision numbers and thus subject to that"
" representation's range and precision limitations.  This is especially "
"relevant when serializing Python :class:`int` values of extremely large "
"magnitude, or when serializing instances of \"exotic\" numerical types such "
"as :class:`decimal.Decimal`."
msgstr "JSON ã«ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã™ã‚‹éš›ã«ã¯ã€ã‚ãªãŸã® JSON ã‚’æ¶ˆè²»ã™ã‚‹å´ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒæŒã¤å½“è©²åˆ¶ç´„ã«æ€ã„ã‚’é¦³ã›ã¦ãã ã•ã„ã€‚ã¨ã‚Šã‚ã‘JSON æ•°å€¤ã‚’ IEEE 754 å€ç²¾åº¦æµ®å‹•å°æ•°ã«ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã™ã‚‹éš›ã®å•é¡Œã¯ã‚ã‚ŠãŒã¡ã§ã€ã™ãªã‚ã¡ãã®æœ‰åŠ¹æ¡æ•°ã¨ç²¾åº¦ã®åˆ¶é™ã®å½±éŸ¿ã‚’å—ã‘ã¾ã™ã€‚ã“ã‚Œã¯ã€æ¥µç«¯ã«å¤§ããªå€¤ã‚’æŒã£ãŸ Python :class:`int` ã‚’ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã™ã‚‹ã¨ãã€ã‚ã‚‹ã„ã¯ :class:`decimal.Decimal` ã®ã‚ˆã†ãª \"é¢¨å¤‰ã‚ã‚Šãª\" æ•°å€¤å‹ã‚’ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã™ã‚‹ã¨ãã€ã«ç‰¹ã«é–¢ä¿‚ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/json.rst:618
msgid "Footnotes"
msgstr "æ³¨è¨˜"

#: ../../library/json.rst:619
msgid ""
"As noted in `the errata for RFC 7159 <https://www.rfc-"
"editor.org/errata_search.php?rfc=7159>`_, JSON permits literal U+2028 (LINE "
"SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR) characters in strings, whereas "
"JavaScript (as of ECMAScript Edition 5.1) does not."
msgstr "`RFC 7159 æ­£èª¤è¡¨ <https://www.rfc-editor.org/errata_search.php?rfc=7159>`_ ã§è¿°ã¹ã‚‰ã‚Œã¦ã„ã‚‹é€šã‚Šã€JSON ã¯ (ECMAScript Edition 5.1 ã®) JavaScript ã¨ã¯é€†ã«ã€ U+2028 (LINE SEPARATOR) ã¨ U+2029 (PARAGRAPH SEPARATOR) ãŒæ–‡å­—åˆ—å†…ã«å«ã¾ã‚Œã‚‹ã“ã¨ã‚’è¨±å®¹ã—ã¦ã„ã¾ã™ã€‚"
