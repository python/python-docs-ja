# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# tomoğŸ§, 2017
# ç§˜æ¹¯ <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: 2017-09-22 17:56+0000\n"
"Last-Translator: tomoğŸ§\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/queue.rst:2
msgid ":mod:`Queue` --- A synchronized queue class"
msgstr ":mod:`Queue` --- åŒæœŸã‚­ãƒ¥ãƒ¼ã‚¯ãƒ©ã‚¹"

#: ../../library/queue.rst:8
msgid ""
"The :mod:`Queue` module has been renamed to :mod:`queue` in Python 3.  The "
":term:`2to3` tool will automatically adapt imports when converting your "
"sources to Python 3."
msgstr ":mod:`Queue` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€Python 3 ã§ã¯ :mod:`queue` ã«ãƒªãƒãƒ¼ãƒ ã•ã‚Œã¾ã—ãŸã€‚ :term:`2to3` ãƒ„ãƒ¼ãƒ«ãŒè‡ªå‹•çš„ã«ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã® import ã‚’ä¿®æ­£ã—ã¾ã™ã€‚"

#: ../../library/queue.rst:12
msgid "**Source code:** :source:`Lib/Queue.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/Queue.py`"

#: ../../library/queue.rst:16
msgid ""
"The :mod:`Queue` module implements multi-producer, multi-consumer queues. It"
" is especially useful in threaded programming when information must be "
"exchanged safely between multiple threads.  The :class:`~Queue.Queue` class "
"in this module implements all the required locking semantics.  It depends on"
" the availability of thread support in Python; see the :mod:`threading` "
"module."
msgstr ":mod:`Queue` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€è¤‡æ•°ãƒ—ãƒ­ãƒ‡ãƒ¥ãƒ¼ã‚µ-è¤‡æ•°ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒ (multi-producer, multi-consumer) ã‚­ãƒ¥ãƒ¼ã‚’å®Ÿè£…ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®é–“ã§æƒ…å ±ã‚’å®‰å…¨ã«äº¤æ›ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ãã®ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§ç‰¹ã«æœ‰ç›Šã§ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :class:`~Queue.Queue` ã‚¯ãƒ©ã‚¹ã¯ã€å¿…è¦ãªã™ã¹ã¦ã®ãƒ­ãƒƒã‚¯ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯Pythonã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚µãƒãƒ¼ãƒˆã®çŠ¶æ³ã«ä¾å­˜ã—ã¾ã™ã€‚ :mod:`threading` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/queue.rst:23
msgid ""
"The module implements three types of queue, which differ only in the order "
"in which the entries are retrieved.  In a FIFO queue, the first tasks added "
"are the first retrieved. In a LIFO queue, the most recently added entry is "
"the first retrieved (operating like a stack).  With a priority queue, the "
"entries are kept sorted (using the :mod:`heapq` module) and the lowest "
"valued entry is retrieved first."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯3ç¨®é¡ã®ã‚­ãƒ¥ãƒ¼ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚ãã‚Œã‚‰ã¯ã‚­ãƒ¥ãƒ¼ã‹ã‚‰å–ã‚Šå‡ºã•ã‚Œã‚‹ã‚¨ãƒ³ãƒˆãƒªã®é †ç•ªã ã‘ãŒé•ã„ã¾ã™ã€‚ FIFOã‚­ãƒ¥ãƒ¼ã§ã¯ã€æœ€åˆã«è¿½åŠ ã•ã‚ŒãŸã‚¨ãƒ³ãƒˆãƒªãŒæœ€åˆã«å–ã‚Šå‡ºã•ã‚Œã¾ã™ã€‚ LIFOã‚­ãƒ¥ãƒ¼ã§ã¯ã€æœ€å¾Œã«è¿½åŠ ã•ã‚ŒãŸã‚¨ãƒ³ãƒˆãƒªãŒæœ€åˆã«å–ã‚Šå‡ºã•ã‚Œã¾ã™(ã‚¹ã‚¿ãƒƒã‚¯ã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã„ã¾ã™)ã€‚ å„ªå…ˆé †ä½ä»˜ãã‚­ãƒ¥ãƒ¼(priority queue)ã§ã¯ã€ã‚¨ãƒ³ãƒˆãƒªã¯(:mod:`heapq` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆ©ç”¨ã—ã¦)ã‚½ãƒ¼ãƒˆã•ã‚Œã€ æœ€ã‚‚ä½ã„å€¤ã®ã‚¨ãƒ³ãƒˆãƒªãŒæœ€åˆã«å–ã‚Šå‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/queue.rst:30
msgid "The :mod:`Queue` module defines the following classes and exceptions:"
msgstr ":mod:`Queue` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ä»¥ä¸‹ã®ã‚¯ãƒ©ã‚¹ã¨ä¾‹å¤–ã‚’å®šç¾©ã—ã¾ã™:"

#: ../../library/queue.rst:34
msgid ""
"Constructor for a FIFO queue.  *maxsize* is an integer that sets the "
"upperbound limit on the number of items that can be placed in the queue.  "
"Insertion will block once this size has been reached, until queue items are "
"consumed.  If *maxsize* is less than or equal to zero, the queue size is "
"infinite."
msgstr "FIFOã‚­ãƒ¥ãƒ¼ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã™ã€‚*maxsize* ã¯ã‚­ãƒ¥ãƒ¼ã«ç½®ãã“ã¨ã®ã§ãã‚‹è¦ç´ æ•°ã®ä¸Šé™ã‚’è¨­å®šã™ã‚‹æ•´æ•°ã§ã™ã€‚ã„ã£ãŸã‚“ã“ã®å¤§ãã•ã«é”ã—ãŸã‚‰ã€æŒ¿å…¥ã¯ã‚­ãƒ¥ãƒ¼ã®è¦ç´ ãŒæ¶ˆè²»ã•ã‚Œã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚ã‚‚ã— *maxsize* ãŒ0ä»¥ä¸‹ã§ã‚ã‚‹ãªã‚‰ã°ã€ã‚­ãƒ¥ãƒ¼ã®å¤§ãã•ã¯ç„¡é™ã§ã™ã€‚"

#: ../../library/queue.rst:41
msgid ""
"Constructor for a LIFO queue.  *maxsize* is an integer that sets the "
"upperbound limit on the number of items that can be placed in the queue.  "
"Insertion will block once this size has been reached, until queue items are "
"consumed.  If *maxsize* is less than or equal to zero, the queue size is "
"infinite."
msgstr "LIFOã‚­ãƒ¥ãƒ¼ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã™ã€‚*maxsize* ã¯ã‚­ãƒ¥ãƒ¼ã«ç½®ãã“ã¨ã®ã§ãã‚‹è¦ç´ æ•°ã®ä¸Šé™ã‚’è¨­å®šã™ã‚‹æ•´æ•°ã§ã™ã€‚ã„ã£ãŸã‚“ã“ã®å¤§ãã•ã«é”ã—ãŸã‚‰ã€æŒ¿å…¥ã¯ã‚­ãƒ¥ãƒ¼ã®è¦ç´ ãŒæ¶ˆè²»ã•ã‚Œã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚ã‚‚ã— *maxsize* ãŒ0ä»¥ä¸‹ã§ã‚ã‚‹ãªã‚‰ã°ã€ã‚­ãƒ¥ãƒ¼ã®å¤§ãã•ã¯ç„¡é™ã§ã™ã€‚"

#: ../../library/queue.rst:50
msgid ""
"Constructor for a priority queue.  *maxsize* is an integer that sets the "
"upperbound limit on the number of items that can be placed in the queue.  "
"Insertion will block once this size has been reached, until queue items are "
"consumed.  If *maxsize* is less than or equal to zero, the queue size is "
"infinite."
msgstr "å„ªå…ˆé †ä½ä»˜ãã‚­ãƒ¥ãƒ¼ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã™ã€‚*maxsize* ã¯ã‚­ãƒ¥ãƒ¼ã«ç½®ãã“ã¨ã®ã§ãã‚‹è¦ç´ æ•°ã®ä¸Šé™ã‚’è¨­å®šã™ã‚‹æ•´æ•°ã§ã™ã€‚ã„ã£ãŸã‚“ã“ã®å¤§ãã•ã«é”ã—ãŸã‚‰ã€æŒ¿å…¥ã¯ã‚­ãƒ¥ãƒ¼ã®è¦ç´ ãŒæ¶ˆè²»ã•ã‚Œã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚ã‚‚ã— *maxsize* ãŒ0ä»¥ä¸‹ã§ã‚ã‚‹ãªã‚‰ã°ã€ã‚­ãƒ¥ãƒ¼ã®å¤§ãã•ã¯ç„¡é™ã§ã™ã€‚"

#: ../../library/queue.rst:55
msgid ""
"The lowest valued entries are retrieved first (the lowest valued entry is "
"the one returned by ``sorted(list(entries))[0]``).  A typical pattern for "
"entries is a tuple in the form: ``(priority_number, data)``."
msgstr "æœ€å°ã®å€¤ã‚’æŒã¤è¦ç´ ãŒæœ€åˆã«æ¤œç´¢ã•ã‚Œã¾ã™ (æœ€å°ã®å€¤ã‚’æŒã¤å€¤ã¯ã€``sorted(list(entries))[0]`` ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ã‚‚ã®ã§ã™)ã€‚å…¸å‹çš„ãªè¦ç´ ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€``(priority_number, data)`` å½¢å¼ã®ã‚¿ãƒ—ãƒ«ã§ã™ã€‚"

#: ../../library/queue.rst:63
msgid ""
"Exception raised when non-blocking :meth:`~Queue.get` (or "
":meth:`~Queue.get_nowait`) is called on a :class:`~Queue.Queue` object which"
" is empty."
msgstr "ç©ºãª :class:`~Queue.Queue` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€éãƒ–ãƒ­ãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦ :meth:`~Queue.get` (ã¾ãŸã¯ :meth:`~Queue.get_nowait`) ãŒå‘¼ã°ã‚ŒãŸã¨ãã€é€å‡ºã•ã‚Œã‚‹ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/queue.rst:70
msgid ""
"Exception raised when non-blocking :meth:`~Queue.put` (or "
":meth:`~Queue.put_nowait`) is called on a :class:`~Queue.Queue` object which"
" is full."
msgstr "æº€æ¯ãª :class:`~Queue.Queue` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã€éãƒ–ãƒ­ãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦ :meth:`~Queue.put` (ã¾ãŸã¯ :meth:`~Queue.put_nowait`) ãŒå‘¼ã°ã‚ŒãŸã¨ãã€é€å‡ºã•ã‚Œã‚‹ä¾‹å¤–ã§ã™ã€‚"

#: ../../library/queue.rst:76
msgid ""
":class:`collections.deque` is an alternative implementation of unbounded "
"queues with fast atomic :func:`append` and :func:`popleft` operations that "
"do not require locking."
msgstr ":class:`collections.deque` ã¯ã€ãƒ­ãƒƒã‚¯ãªã—ã§ :func:`popleft` ã‚„ :func:`append` ã¨ã„ã£ãŸã‚¢ãƒˆãƒŸãƒƒã‚¯æ“ä½œãŒå¯èƒ½ãªã‚­ãƒ¥ãƒ¼ã®å®Ÿè£…ã§ã™ã€‚"

#: ../../library/queue.rst:84
msgid "Queue Objects"
msgstr "ã‚­ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"

#: ../../library/queue.rst:86
msgid ""
"Queue objects (:class:`~Queue.Queue`, :class:`LifoQueue`, or "
":class:`PriorityQueue`) provide the public methods described below."
msgstr "ã‚­ãƒ¥ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (:class:`~Queue.Queue`, :class:`LifoQueue`, :class:`PriorityQueue`) ã¯ã€ä»¥ä¸‹ã®publicãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/queue.rst:92
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block, nor will qsize() < maxsize"
" guarantee that put() will not block."
msgstr "ã‚­ãƒ¥ãƒ¼ã®è¿‘ä¼¼ã‚µã‚¤ã‚ºã‚’è¿”ã—ã¾ã™ã€‚ã“ã“ã§ã€qsize() > 0 ã¯å¾Œç¶šã® get() ãŒãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ã“ã¨ã‚’ä¿è¨¼ã—ãªã„ã“ã¨ã€ã¾ãŸ qsize() < maxsize ãŒ put() ãŒãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ã“ã¨ã‚’ä¿è¨¼ã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/queue.rst:99
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``True`` it doesn't guarantee that a subsequent call to put() will "
"not block.  Similarly, if empty() returns ``False`` it doesn't guarantee "
"that a subsequent call to get() will not block."
msgstr "ã‚­ãƒ¥ãƒ¼ãŒç©ºã®å ´åˆã¯ ``True`` ã‚’è¿”ã—ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™ã€‚empty() ãŒ ``True`` ã‚’è¿”ã—ã¦ã‚‚ã€å¾Œç¶šã® put() ã®å‘¼ã³å‡ºã—ãŒãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ã“ã¨ã¯ä¿è¨¼ã•ã‚Œã¾ã›ã‚“ã€‚åŒæ§˜ã«ã€empty() ãŒ ``False`` ã‚’è¿”ã—ã¦ã‚‚ã€å¾Œç¶šã® get() ã®å‘¼ã³å‡ºã—ãŒãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ã“ã¨ã¯ä¿è¨¼ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/queue.rst:107
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  If full() "
"returns ``True`` it doesn't guarantee that a subsequent call to get() will "
"not block.  Similarly, if full() returns ``False`` it doesn't guarantee that"
" a subsequent call to put() will not block."
msgstr "ã‚­ãƒ¥ãƒ¼ãŒä¸€æ¯ã®å ´åˆã¯ ``True`` ã‚’è¿”ã—ã€ãã†ã§ãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™ã€‚full() ãŒ ``True`` ã‚’è¿”ã—ã¦ã‚‚ã€å¾Œç¶šã® get() ã®å‘¼ã³å‡ºã—ãŒãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ã“ã¨ã¯ä¿è¨¼ã•ã‚Œã¾ã›ã‚“ã€‚åŒæ§˜ã«ã€full() ãŒ ``False`` ã‚’è¿”ã—ã¦ã‚‚ã€å¾Œç¶šã® put() ã®å‘¼ã³å‡ºã—ãŒãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ã“ã¨ã¯ä¿è¨¼ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/queue.rst:115
msgid ""
"Put *item* into the queue. If optional args *block* is true and *timeout* is"
" ``None`` (the default), block if necessary until a free slot is available. "
"If *timeout* is a positive number, it blocks at most *timeout* seconds and "
"raises the :exc:`Full` exception if no free slot was available within that "
"time. Otherwise (*block* is false), put an item on the queue if a free slot "
"is immediately available, else raise the :exc:`Full` exception (*timeout* is"
" ignored in that case)."
msgstr "*item* ã‚’ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã¾ã™ã€‚\nã‚‚ã—ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *block* ãŒçœŸã§ *timeout* ãŒ ``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã®å ´åˆã¯ã€å¿…è¦ã§ã‚ã‚Œã°ãƒ•ãƒªãƒ¼ã‚¹ãƒ­ãƒƒãƒˆãŒåˆ©ç”¨å¯èƒ½ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚\n*timeout* ãŒæ­£ã®æ•°ã®å ´åˆã¯ã€æœ€å¤§ã§ *timeout* ç§’é–“ãƒ–ãƒ­ãƒƒã‚¯ã—ã€ãã®æ™‚é–“å†…ã«ç©ºãã‚¹ãƒ­ãƒƒãƒˆãŒåˆ©ç”¨å¯èƒ½ã«ãªã‚‰ãªã‘ã‚Œã°ã€ä¾‹å¤– :exc:`Full` ã‚’é€å‡ºã—ã¾ã™ã€‚\nãã†ã§ãªã„å ´åˆ (*block* ãŒå½) ã¯ã€ç©ºãã‚¹ãƒ­ãƒƒãƒˆãŒç›´ã¡ã«åˆ©ç”¨ã§ãã‚‹ãªã‚‰ã°ã€ã‚­ãƒ¥ãƒ¼ã«ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç½®ãã¾ã™ã€‚\nã§ããªã„ãªã‚‰ã°ã€ä¾‹å¤– :exc:`Full` ã‚’é€å‡ºã—ã¾ã™ (ã“ã®å ´åˆ *timeout* ã¯ç„¡è¦–ã•ã‚Œã¾ã™)ã€‚"

#: ../../library/queue.rst:123 ../../library/queue.rst:141
msgid "The *timeout* parameter."
msgstr "*timeout* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/queue.rst:129
msgid "Equivalent to ``put(item, False)``."
msgstr "``put(item, False)`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/queue.rst:134
msgid ""
"Remove and return an item from the queue. If optional args *block* is true "
"and *timeout* is ``None`` (the default), block if necessary until an item is"
" available. If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Empty` exception if no item was available "
"within that time. Otherwise (*block* is false), return an item if one is "
"immediately available, else raise the :exc:`Empty` exception (*timeout* is "
"ignored in that case)."
msgstr "ã‚­ãƒ¥ãƒ¼ã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–ã‚Šé™¤ãã€ãã‚Œã‚’è¿”ã—ã¾ã™ã€‚\nã‚ªãƒ—ã‚·ãƒ§ãƒ³å¼•æ•° *block* ãŒçœŸã§ *timeout* ãŒ ``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã®å ´åˆã¯ã€å¿…è¦ã§ã‚ã‚Œã°ã‚¢ã‚¤ãƒ†ãƒ ãŒå–ã‚Šå‡ºã›ã‚‹ã‚ˆã†ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚\nã‚‚ã— *timeout* ãŒæ­£ã®æ•°ã®å ´åˆã¯ã€æœ€å¤§ã§ *timeout* ç§’é–“ãƒ–ãƒ­ãƒƒã‚¯ã—ã€ãã®æ™‚é–“å†…ã§ã‚¢ã‚¤ãƒ†ãƒ ãŒå–ã‚Šå‡ºã›ã‚‹ã‚ˆã†ã«ãªã‚‰ãªã‘ã‚Œã°ã€ä¾‹å¤– :exc:`Empty` ã‚’é€å‡ºã—ã¾ã™ã€‚\nãã†ã§ãªã„å ´åˆ (*block* ãŒå½) ã¯ã€ç›´ã¡ã«ã‚¢ã‚¤ãƒ†ãƒ ãŒå–ã‚Šå‡ºã›ã‚‹ãªã‚‰ã°ã€ãã‚Œã‚’è¿”ã—ã¾ã™ã€‚\nã§ããªã„ãªã‚‰ã°ã€ä¾‹å¤– :exc:`Empty` ã‚’é€å‡ºã—ã¾ã™ (ã“ã®å ´åˆ *timeout* ã¯ç„¡è¦–ã•ã‚Œã¾ã™)ã€‚"

#: ../../library/queue.rst:147
msgid "Equivalent to ``get(False)``."
msgstr "``get(False)`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/queue.rst:149
msgid ""
"Two methods are offered to support tracking whether enqueued tasks have been"
" fully processed by daemon consumer threads."
msgstr "ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã‚‰ã‚ŒãŸã‚¿ã‚¹ã‚¯ãŒå…¨ã¦ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã«å‡¦ç†ã•ã‚ŒãŸã‹ã©ã†ã‹ã‚’è¿½è·¡ã™ã‚‹ãŸã‚ã« 2ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒæä¾›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/queue.rst:155
msgid ""
"Indicate that a formerly enqueued task is complete.  Used by queue consumer "
"threads.  For each :meth:`get` used to fetch a task, a subsequent call to "
":meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr "éå»ã«ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã‚‰ã‚ŒãŸã‚¿ã‚¹ã‚¯ãŒå®Œäº†ã—ãŸäº‹ã‚’ç¤ºã—ã¾ã™ã€‚ã‚­ãƒ¥ãƒ¼ã®ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã«åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚ã‚¿ã‚¹ã‚¯ã®å–ã‚Šå‡ºã—ã«ä½¿ã‚ã‚ŒãŸã€å„ :meth:`get` ã«å¯¾ã—ã¦ã€ãã‚Œã«ç¶šã :meth:`task_done` ã®å‘¼ã³å‡ºã—ã¯ã€å–ã‚Šå‡ºã—ãŸã‚¿ã‚¹ã‚¯ã«å¯¾ã™ã‚‹å‡¦ç†ãŒå®Œäº†ã—ãŸäº‹ã‚’ã‚­ãƒ¥ãƒ¼ã«æ•™ãˆã¾ã™ã€‚"

#: ../../library/queue.rst:159
msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every"
" item that had been :meth:`put` into the queue)."
msgstr ":meth:`join` ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãŸå ´åˆã€å…¨itemãŒå‡¦ç†ã•ã‚ŒãŸ (ã‚­ãƒ¥ãƒ¼ã« :meth:`put` ã•ã‚ŒãŸå…¨ã¦ã®itemã«å¯¾ã—ã¦ :meth:`task_done` ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã“ã¨ã‚’æ„å‘³ã—ã¾ã™) æ™‚ã«å¾©å¸°ã—ã¾ã™ã€‚"

#: ../../library/queue.rst:163
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed"
" in the queue."
msgstr "ã‚­ãƒ¥ãƒ¼ã«ã‚ã‚‹è¦ç´ ã‚ˆã‚Šå¤šãå‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆ :exc:`ValueError` ãŒç™ºç”Ÿã—ã¾ã™ã€‚"

#: ../../library/queue.rst:171
msgid "Blocks until all items in the queue have been gotten and processed."
msgstr "ã‚­ãƒ¥ãƒ¼ã®ä¸­ã®å…¨ã‚¢ã‚¤ãƒ†ãƒ ãŒå‡¦ç†ã•ã‚Œã‚‹é–“ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚"

#: ../../library/queue.rst:173
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer thread calls "
":meth:`task_done` to indicate that the item was retrieved and all work on it"
" is complete. When the count of unfinished tasks drops to zero, :meth:`join`"
" unblocks."
msgstr "ã‚­ãƒ¥ãƒ¼ã«itemãŒè¿½åŠ ã•ã‚Œã‚‹åº¦ã«ã€æœªå®Œäº†ã‚¿ã‚¹ã‚¯ã‚«ã‚¦ãƒ³ãƒˆãŒå¢—ã‚„ã•ã‚Œã¾ã™ã€‚ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãŒ :meth:`task_done` ã‚’å‘¼ã³å‡ºã—ã¦ã€itemã‚’å—ã‘å–ã£ã¦ãã‚Œã«å¯¾ã™ã‚‹å‡¦ç†ãŒå®Œäº†ã—ãŸäº‹ã‚’çŸ¥ã‚‰ã›ã‚‹åº¦ã«ã€æœªå®Œäº†ã‚¿ã‚¹ã‚¯ã‚«ã‚¦ãƒ³ãƒˆãŒæ¸›ã‚‰ã•ã‚Œã¾ã™ã€‚æœªå®Œäº†ã‚¿ã‚¹ã‚¯ã‚«ã‚¦ãƒ³ãƒˆãŒ0ã«ãªã£ãŸã¨ãã«ã€ :meth:`join`  ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒè§£é™¤ã•ã‚Œã¾ã™ã€‚"

#: ../../library/queue.rst:180
msgid "Example of how to wait for enqueued tasks to be completed::"
msgstr "ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚ŒãŸã‚¿ã‚¹ã‚¯ãŒå®Œäº†ã™ã‚‹ã®ã‚’å¾…ã¤ä¾‹::"
