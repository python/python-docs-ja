# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2019
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 18:48+0900\n"
"PO-Revision-Date: 2018-06-29 17:34+0000\n"
"Last-Translator: tomo, 2019\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/queue.rst:2
msgid ":mod:`queue` --- A synchronized queue class"
msgstr ":mod:`queue` --- 同期キュークラス"

#: ../../library/queue.rst:7
msgid "**Source code:** :source:`Lib/queue.py`"
msgstr "**ソースコード:** :source:`Lib/queue.py`"

#: ../../library/queue.rst:11
msgid ""
"The :mod:`queue` module implements multi-producer, multi-consumer queues. It "
"is especially useful in threaded programming when information must be "
"exchanged safely between multiple threads.  The :class:`Queue` class in this "
"module implements all the required locking semantics.  It depends on the "
"availability of thread support in Python; see the :mod:`threading` module."
msgstr ""
":mod:`queue` モジュールは、複数プロデューサ-複数コンシューマ(multi-producer, "
"multi-consumer)キューを実装します。これは、複数のスレッドの間で情報を安全に交"
"換しなければならないときのマルチスレッドプログラミングで特に有益です。このモ"
"ジュールの :class:`Queue` クラスは、必要なすべてのロックセマンティクスを実装"
"しています。これはPythonのスレッドサポートの状況に依存します。 :mod:"
"`threading` モジュールを参照してください。"

#: ../../library/queue.rst:18
msgid ""
"The module implements three types of queue, which differ only in the order "
"in which the entries are retrieved.  In a :abbr:`FIFO (first-in, first-out)` "
"queue, the first tasks added are the first retrieved. In a :abbr:`LIFO (last-"
"in, first-out)` queue, the most recently added entry is the first retrieved "
"(operating like a stack).  With a priority queue, the entries are kept "
"sorted (using the :mod:`heapq` module) and the lowest valued entry is "
"retrieved first."
msgstr ""
"このモジュールでは3種類のキューが実装されています。それらはキューから取り出さ"
"れるエントリの順番だけが違います。 :abbr:`FIFO (first-in, first-out, 先入れ先"
"出し)` キューでは、最初に追加されたエントリが最初に取り出されます。  :abbr:"
"`LIFO (last-in, first-out, 後入れ先出し)` キューでは、最後に追加されたエント"
"リが最初に取り出されます(スタックのように振る舞います)。 優先順位付きキュー"
"(priority queue)では、エントリは(:mod:`heapq` モジュールを利用して)ソートさ"
"れ、 最も低い値のエントリが最初に取り出されます。"

#: ../../library/queue.rst:26
msgid ""
"Internally, the module uses locks to temporarily block competing threads; "
"however, it is not designed to handle reentrancy within a thread."
msgstr ""
"内部的には、このモジュールは競争スレッドを一時的にブロックするためにロックを"
"使っています; しかし、スレッド内での再入を扱うようには設計されていません。"

#: ../../library/queue.rst:29
msgid "The :mod:`queue` module defines the following classes and exceptions:"
msgstr ":mod:`queue` モジュールは以下のクラスと例外を定義します:"

#: ../../library/queue.rst:33
msgid ""
"Constructor for a :abbr:`FIFO (first-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
":abbr:`FIFO (first-in, first-out, 先入れ先出し)` キューのコンストラクタで"
"す。\n"
"*maxsize* はキューに入れられる要素数の上限を設定する整数です。\n"
"いったんこの大きさに達したら、挿入処理はキューの要素が消費されるまでブロック"
"されます。\n"
"*maxsize* が0以下の場合は、キューの大きさは無限です。"

#: ../../library/queue.rst:41
msgid ""
"Constructor for a :abbr:`LIFO (last-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
":abbr:`LIFO (last-in, first-out, 後入れ先出し)` キューのコンストラクタで"
"す。\n"
"*maxsize* はキューに入れられる要素数の上限を設定する整数です。\n"
"いったんこの大きさに達したら、挿入処理はキューの要素が消費されるまでブロック"
"されます。\n"
"*maxsize* が0以下の場合は、キューの大きさは無限です。"

#: ../../library/queue.rst:50
msgid ""
"Constructor for a priority queue.  *maxsize* is an integer that sets the "
"upperbound limit on the number of items that can be placed in the queue.  "
"Insertion will block once this size has been reached, until queue items are "
"consumed.  If *maxsize* is less than or equal to zero, the queue size is "
"infinite."
msgstr ""
"優先順位付きキューのコンストラクタです。*maxsize* はキューに置くことのできる"
"要素数の上限を設定する整数です。いったんこの大きさに達したら、挿入はキューの"
"要素が消費されるまでブロックされます。もし *maxsize* が0以下であるならば、"
"キューの大きさは無限です。"

#: ../../library/queue.rst:55
msgid ""
"The lowest valued entries are retrieved first (the lowest valued entry is "
"the one returned by ``sorted(list(entries))[0]``).  A typical pattern for "
"entries is a tuple in the form: ``(priority_number, data)``."
msgstr ""
"最小の値を持つ要素が最初に検索されます (最小の値を持つ値は、"
"``sorted(list(entries))[0]`` によって返されるものです)。典型的な要素のパター"
"ンは、``(priority_number, data)`` 形式のタプルです。"

#: ../../library/queue.rst:62
msgid ""
"Exception raised when non-blocking :meth:`~Queue.get` (or :meth:`~Queue."
"get_nowait`) is called on a :class:`Queue` object which is empty."
msgstr ""
"空の :class:`Queue` オブジェクトで、非ブロックメソッド :meth:`~Queue.get` (ま"
"たは :meth:`~Queue.get_nowait`) が呼ばれたとき、送出される例外です。"

#: ../../library/queue.rst:69
msgid ""
"Exception raised when non-blocking :meth:`~Queue.put` (or :meth:`~Queue."
"put_nowait`) is called on a :class:`Queue` object which is full."
msgstr ""
"満杯の :class:`Queue` オブジェクトで、非ブロックメソッド :meth:`~Queue.put` "
"(または :meth:`~Queue.put_nowait`) が呼ばれたとき、送出される例外です。"

#: ../../library/queue.rst:77
msgid "Queue Objects"
msgstr "キューオブジェクト"

#: ../../library/queue.rst:79
msgid ""
"Queue objects (:class:`Queue`, :class:`LifoQueue`, or :class:"
"`PriorityQueue`) provide the public methods described below."
msgstr ""
"キューオブジェクト(:class:`Queue`, :class:`LifoQueue`, :class:"
"`PriorityQueue`)は、以下のpublicメソッドを提供しています。"

#: ../../library/queue.rst:85
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block, nor will qsize() < maxsize "
"guarantee that put() will not block."
msgstr ""
"キューの近似サイズを返します。ここで、qsize() > 0 は後続の get() がブロックし"
"ないことを保証しないこと、また qsize() < maxsize が put() がブロックしないこ"
"とを保証しないことに注意してください。"

#: ../../library/queue.rst:92
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``True`` it doesn't guarantee that a subsequent call to put() will "
"not block.  Similarly, if empty() returns ``False`` it doesn't guarantee "
"that a subsequent call to get() will not block."
msgstr ""
"キューが空の場合は ``True`` を返し、そうでなければ ``False`` を返します。"
"empty() が ``True`` を返しても、後続の put() の呼び出しがブロックしないことは"
"保証されません。同様に、empty() が ``False`` を返しても、後続の get() の呼び"
"出しがブロックしないことは保証されません。"

#: ../../library/queue.rst:100
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  If full() "
"returns ``True`` it doesn't guarantee that a subsequent call to get() will "
"not block.  Similarly, if full() returns ``False`` it doesn't guarantee that "
"a subsequent call to put() will not block."
msgstr ""
"キューが一杯の場合は ``True`` を返し、そうでなければ ``False`` を返します。"
"full() が ``True`` を返しても、後続の get() の呼び出しがブロックしないことは"
"保証されません。同様に、full() が ``False`` を返しても、後続の put() の呼び出"
"しがブロックしないことは保証されません。"

#: ../../library/queue.rst:108
msgid ""
"Put *item* into the queue. If optional args *block* is true and *timeout* is "
"``None`` (the default), block if necessary until a free slot is available. "
"If *timeout* is a positive number, it blocks at most *timeout* seconds and "
"raises the :exc:`Full` exception if no free slot was available within that "
"time. Otherwise (*block* is false), put an item on the queue if a free slot "
"is immediately available, else raise the :exc:`Full` exception (*timeout* is "
"ignored in that case)."
msgstr ""
"*item* をキューに入れます。\n"
"もしオプション引数 *block* が真で *timeout* が ``None`` (デフォルト) の場合"
"は、必要であればフリースロットが利用可能になるまでブロックします。\n"
"*timeout* が正の数の場合は、最大で *timeout* 秒間ブロックし、その時間内に空き"
"スロットが利用可能にならなければ、例外 :exc:`Full` を送出します。\n"
"そうでない場合 (*block* が偽) は、空きスロットが直ちに利用できるならば、"
"キューにアイテムを置きます。\n"
"できないならば、例外 :exc:`Full` を送出します (この場合 *timeout* は無視され"
"ます)。"

#: ../../library/queue.rst:119
msgid "Equivalent to ``put(item, False)``."
msgstr "``put(item, False)`` と等価です。"

#: ../../library/queue.rst:124
msgid ""
"Remove and return an item from the queue. If optional args *block* is true "
"and *timeout* is ``None`` (the default), block if necessary until an item is "
"available. If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Empty` exception if no item was available "
"within that time. Otherwise (*block* is false), return an item if one is "
"immediately available, else raise the :exc:`Empty` exception (*timeout* is "
"ignored in that case)."
msgstr ""
"キューからアイテムを取り除き、それを返します。\n"
"オプション引数 *block* が真で *timeout* が ``None`` (デフォルト) の場合は、必"
"要であればアイテムが取り出せるようになるまでブロックします。\n"
"もし *timeout* が正の数の場合は、最大で *timeout* 秒間ブロックし、その時間内"
"でアイテムが取り出せるようにならなければ、例外 :exc:`Empty` を送出します。\n"
"そうでない場合 (*block* が偽) は、直ちにアイテムが取り出せるならば、それを返"
"します。\n"
"できないならば、例外 :exc:`Empty` を送出します (この場合 *timeout* は無視され"
"ます)。"

#: ../../library/queue.rst:134
msgid "Equivalent to ``get(False)``."
msgstr "``get(False)`` と等価です。"

#: ../../library/queue.rst:136
msgid ""
"Two methods are offered to support tracking whether enqueued tasks have been "
"fully processed by daemon consumer threads."
msgstr ""
"キューに入れられたタスクが全てコンシューマスレッドに処理されたかどうかを追跡"
"するために 2つのメソッドが提供されます。"

#: ../../library/queue.rst:142
msgid ""
"Indicate that a formerly enqueued task is complete.  Used by queue consumer "
"threads.  For each :meth:`get` used to fetch a task, a subsequent call to :"
"meth:`task_done` tells the queue that the processing on the task is complete."
msgstr ""
"過去にキューに入れられたタスクが完了した事を示します。キューのコンシューマス"
"レッドに利用されます。タスクの取り出しに使われた各 :meth:`get` の後に :meth:"
"`task_done` を呼び出すと、取り出したタスクに対する処理が完了した事をキューに"
"教えます。"

#: ../../library/queue.rst:146
msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every "
"item that had been :meth:`put` into the queue)."
msgstr ""
":meth:`join` がブロックされていた場合、全itemが処理された (キューに :meth:"
"`put` された全てのitemに対して :meth:`task_done` が呼び出されたことを意味しま"
"す) 時に復帰します。"

#: ../../library/queue.rst:150
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"キューにある要素より多く呼び出された場合 :exc:`ValueError` が発生します。"

#: ../../library/queue.rst:156
msgid "Blocks until all items in the queue have been gotten and processed."
msgstr ""
"キューにあるすべてのアイテムが取り出されて処理されるまでブロックします。"

#: ../../library/queue.rst:158
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer thread calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete. When the count of unfinished tasks drops to zero, :meth:`join` "
"unblocks."
msgstr ""
"キューにitemが追加される度に、未完了タスクカウントが増やされます。コンシュー"
"マスレッドが :meth:`task_done` を呼び出して、itemを受け取ってそれに対する処理"
"が完了した事を知らせる度に、未完了タスクカウントが減らされます。未完了タスク"
"カウントが0になったときに、 :meth:`join`  のブロックが解除されます。"

#: ../../library/queue.rst:164
msgid "Example of how to wait for enqueued tasks to be completed::"
msgstr "キューに入れたタスクが完了するのを待つ例::"

#: ../../library/queue.rst:198
msgid "Class :class:`multiprocessing.Queue`"
msgstr ":class:`multiprocessing.Queue` クラス"

#: ../../library/queue.rst:197
msgid ""
"A queue class for use in a multi-processing (rather than multi-threading) "
"context."
msgstr ""
"(マルチスレッドではなく) マルチプロセスの文脈で使用されるキュークラス。"

#: ../../library/queue.rst:200
msgid ""
":class:`collections.deque` is an alternative implementation of unbounded "
"queues with fast atomic :meth:`~collections.deque.append` and :meth:"
"`~collections.deque.popleft` operations that do not require locking."
msgstr ""
":class:`collections.deque` は、ロックなしで :meth:`~collections.deque."
"append` や :meth:`~collections.deque.popleft` といったアトミック操作が可能な"
"キューの実装です。"
