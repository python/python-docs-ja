# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト)
# This file is distributed under the same license as the Python package.
# 
# Translators:
# cocoatomo, 2017
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: 2017-10-19 14:19+0000\n"
"Last-Translator: cocoatomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/collections.rst:2
msgid ":mod:`collections` --- High-performance container datatypes"
msgstr ":mod:`collections` --- 高性能なコンテナ・データ型"

#: ../../library/collections.rst:17
msgid ""
"**Source code:** :source:`Lib/collections.py` and :source:`Lib/_abcoll.py`"
msgstr "**Source code:** :source:`Lib/collections.py` and :source:`Lib/_abcoll.py`"

#: ../../library/collections.rst:21
msgid ""
"This module implements specialized container datatypes providing "
"alternatives to Python's general purpose built-in containers, :class:`dict`,"
" :class:`list`, :class:`set`, and :class:`tuple`."
msgstr "このモジュールは、汎用の Python 組み込みコンテナ :class:`dict`, :class:`list`, :class:`set`, および :class:`tuple` に代わる、特殊なコンテナデータ型を実装しています。"

#: ../../library/collections.rst:26
msgid ":func:`namedtuple`"
msgstr ":func:`namedtuple`"

#: ../../library/collections.rst:26
msgid "factory function for creating tuple subclasses with named fields"
msgstr "名前付きフィールドを持つタプルのサブクラスを作成するファクトリ関数"

#: ../../library/collections.rst:27
msgid ":class:`deque`"
msgstr ":class:`deque`"

#: ../../library/collections.rst:27
msgid "list-like container with fast appends and pops on either end"
msgstr "両端における append や pop を高速に行えるリスト風のコンテナ"

#: ../../library/collections.rst:28
msgid ":class:`Counter`"
msgstr ":class:`Counter`"

#: ../../library/collections.rst:28
msgid "dict subclass for counting hashable objects"
msgstr "ハッシュ可能なオブジェクトを数え上げる辞書のサブクラス"

#: ../../library/collections.rst:29
msgid ":class:`OrderedDict`"
msgstr ":class:`OrderedDict`"

#: ../../library/collections.rst:29
msgid "dict subclass that remembers the order entries were added"
msgstr "項目が追加された順序を記憶する辞書のサブクラス"

#: ../../library/collections.rst:30
msgid ":class:`defaultdict`"
msgstr ":class:`defaultdict`"

#: ../../library/collections.rst:30
msgid "dict subclass that calls a factory function to supply missing values"
msgstr "ファクトリ関数を呼び出して存在しない値を供給する辞書のサブクラス"

#: ../../library/collections.rst:33
msgid ""
"In addition to the concrete container classes, the collections module "
"provides :ref:`abstract base classes <collections-abstract-base-classes>` "
"that can be used to test whether a class provides a particular interface, "
"for example, whether it is hashable or a mapping."
msgstr "コンテナ型の作成に加えて、 collections モジュールは幾つかの ABC (:ref:`abstract base classes <collections-abstract-base-classes>` = 抽象基底クラス) を提供しています。 ABC はクラスが特定のインタフェース持っているかどうか、たとえばハッシュ可能であるかやマッピングであるかを判定するのに利用します。"

#: ../../library/collections.rst:40
msgid ":class:`Counter` objects"
msgstr ":class:`Counter` オブジェクト"

#: ../../library/collections.rst:42
msgid ""
"A counter tool is provided to support convenient and rapid tallies. For "
"example::"
msgstr "便利で迅速な検数をサポートするカウンタツールが提供されています。例えば::"

#: ../../library/collections.rst:61
msgid ""
"A :class:`Counter` is a :class:`dict` subclass for counting hashable "
"objects. It is an unordered collection where elements are stored as "
"dictionary keys and their counts are stored as dictionary values.  Counts "
"are allowed to be any integer value including zero or negative counts.  The "
":class:`Counter` class is similar to bags or multisets in other languages."
msgstr ":class:`Counter` はハッシュ可能なオブジェクトをカウントする :class:`dict` のサブクラスです。これは、要素を辞書のキーとして保存し、そのカウントを辞書の値として保存する、順序付けされていないコレクションです。カウントは、0 や負のカウントを含む整数値をとれます。 :class:`Counter` クラスは、他の言語のバッグや多重集合のようなものです。"

#: ../../library/collections.rst:67
msgid ""
"Elements are counted from an *iterable* or initialized from another "
"*mapping* (or counter):"
msgstr "要素は、 *iterable* から数え上げられたり、他の *mapping* (やカウンタ) から初期化されます:"

#: ../../library/collections.rst:75
msgid ""
"Counter objects have a dictionary interface except that they return a zero "
"count for missing items instead of raising a :exc:`KeyError`:"
msgstr "カウンタオブジェクトは辞書のインタフェースを持ちますが、存在しない要素に対して :exc:`KeyError` を送出する代わりに 0 を返すという違いがあります:"

#: ../../library/collections.rst:82
msgid ""
"Setting a count to zero does not remove an element from a counter. Use "
"``del`` to remove it entirely:"
msgstr "カウントを 0 に設定しても、要素はカウンタから取り除かれません。完全に取り除くには、 ``del`` を使ってください:"

#: ../../library/collections.rst:91
msgid ""
"Counter objects support three methods beyond those available for all "
"dictionaries:"
msgstr "カウンタオブジェクトは、すべての辞書に利用できるものに加え、 3 つのメソッドをサポートしています:"

#: ../../library/collections.rst:96
msgid ""
"Return an iterator over elements repeating each as many times as its count."
"  Elements are returned in arbitrary order.  If an element's count is less "
"than one, :meth:`elements` will ignore it."
msgstr "それぞれの要素を、そのカウント分の回数だけ繰り返すイテレータを返します。要素は任意の順序で返されます。ある要素のカウントが 1 未満なら、 :meth:`elements` はそれを無視します。"

#: ../../library/collections.rst:106
msgid ""
"Return a list of the *n* most common elements and their counts from the most"
" common to the least.  If *n* is omitted or ``None``, :func:`most_common` "
"returns *all* elements in the counter. Elements with equal counts are "
"ordered arbitrarily:"
msgstr "最も多い *n* 要素を、カウントが多いものから少ないものまで順に並べたリストを返します。 *n* が省略されるか ``None`` であれば、 :func:`most_common` はカウンタの *すべての* 要素を返します。等しいカウントの要素は任意に並べられます:"

#: ../../library/collections.rst:116
msgid ""
"Elements are subtracted from an *iterable* or from another *mapping* (or "
"counter).  Like :meth:`dict.update` but subtracts counts instead of "
"replacing them.  Both inputs and outputs may be zero or negative."
msgstr "要素から *iterable* の要素または *mapping* の要素が引かれます。 :meth:`dict.update` に似ていますが、カウントを置き換えるのではなく引きます。入力も出力も、 0 や負になりえます。"

#: ../../library/collections.rst:126
msgid ""
"The usual dictionary methods are available for :class:`Counter` objects "
"except for two which work differently for counters."
msgstr "普通の辞書のメソッドは、以下の 2 つのメソッドがカウンタに対して異なる振る舞いをするのを除き、 :class:`Counter` オブジェクトにも利用できます。"

#: ../../library/collections.rst:131
msgid "This class method is not implemented for :class:`Counter` objects."
msgstr "このクラスメソッドは :class:`Counter` オブジェクトには実装されていません。"

#: ../../library/collections.rst:135
msgid ""
"Elements are counted from an *iterable* or added-in from another *mapping* "
"(or counter).  Like :meth:`dict.update` but adds counts instead of replacing"
" them.  Also, the *iterable* is expected to be a sequence of elements, not a"
" sequence of ``(key, value)`` pairs."
msgstr "要素が *iterable* からカウントされるか、別の *mapping* (やカウンタ) が追加されます。 :meth:`dict.update` に似ていますが、カウントを置き換えるのではなく追加します。また、 *iterable* には ``(key, value)`` 対のシーケンスではなく、要素のシーケンスが求められます。"

#: ../../library/collections.rst:140
msgid "Common patterns for working with :class:`Counter` objects::"
msgstr ":class:`Counter` オブジェクトを使ったよくあるパターン::"

#: ../../library/collections.rst:152
msgid ""
"Several mathematical operations are provided for combining :class:`Counter` "
"objects to produce multisets (counters that have counts greater than zero). "
"Addition and subtraction combine counters by adding or subtracting the "
"counts of corresponding elements.  Intersection and union return the minimum"
" and maximum of corresponding counts.  Each operation can accept inputs with"
" signed counts, but the output will exclude results with counts of zero or "
"less."
msgstr ":class:`Counter` オブジェクトを組み合わせて多重集合 (1 以上のカウントをもつカウンタ) を作るために、いくつかの数学演算が提供されています。足し算と引き算は、対応する要素を足したり引いたりすることによってカウンタを組み合わせます。共通部分と合併集合は、対応するカウントの最大値と最小値を返します。それぞれの演算はカウントに符号がついた入力を受け付けますが、カウントが 0 以下である結果は出力から除かれます。"

#: ../../library/collections.rst:172
msgid ""
"Counters were primarily designed to work with positive integers to represent"
" running counts; however, care was taken to not unnecessarily preclude use "
"cases needing other types or negative values.  To help with those use cases,"
" this section documents the minimum range and type restrictions."
msgstr "カウンタはもともと、推移するカウントを正の整数で表すために設計されました。しかし、他の型や負の値を必要とするユースケースを不必要に排除することがないように配慮されています。このようなユースケースの助けになるように、この節で最低限の範囲と型の制限について記述します。"

#: ../../library/collections.rst:177
msgid ""
"The :class:`Counter` class itself is a dictionary subclass with no "
"restrictions on its keys and values.  The values are intended to be numbers "
"representing counts, but you *could* store anything in the value field."
msgstr ":class:`Counter` クラス自体は辞書のサブクラスで、キーと値に制限はありません。値はカウントを表す数であることを意図していますが、値フィールドに任意のものを保存 *できます* 。"

#: ../../library/collections.rst:181
msgid ""
"The :meth:`most_common` method requires only that the values be orderable."
msgstr ":meth:`most_common` メソッドが要求するのは、値が順序付け可能なことだけです。"

#: ../../library/collections.rst:183
msgid ""
"For in-place operations such as ``c[key] += 1``, the value type need only "
"support addition and subtraction.  So fractions, floats, and decimals would "
"work and negative values are supported.  The same is also true for "
":meth:`update` and :meth:`subtract` which allow negative and zero values for"
" both inputs and outputs."
msgstr "``c[key] += 1`` のようなインプレース演算では、値の型に必要なのは足し算と引き算ができることだけです。よって分数、浮動小数点数、小数も使え、負の値がサポートされています。これと同じことが、負や 0 の値を入力と出力に許す :meth:`update` と :meth:`subtract` メソッドにも言えます。"

#: ../../library/collections.rst:189
msgid ""
"The multiset methods are designed only for use cases with positive values. "
"The inputs may be negative or zero, but only outputs with positive values "
"are created.  There are no type restrictions, but the value type needs to "
"support addition, subtraction, and comparison."
msgstr "多重集合メソッドは正の値を扱うユースケースに対してのみ設計されています。入力は負や 0 に出来ますが、正の値の出力のみが生成されます。型の制限はありませんが、値の型は足し算、引き算、比較をサポートしている必要があります。"

#: ../../library/collections.rst:194
msgid ""
"The :meth:`elements` method requires integer counts.  It ignores zero and "
"negative counts."
msgstr ":meth:`elements` メソッドは整数のカウントを要求します。これは 0 と負のカウントを無視します。"

#: ../../library/collections.rst:199
msgid ""
"`Counter class <https://code.activestate.com/recipes/576611/>`_ adapted for "
"Python 2.5 and an early `Bag recipe "
"<https://code.activestate.com/recipes/259174/>`_ for Python 2.4."
msgstr "Python 2.5 向けの `Counter class <https://code.activestate.com/recipes/576611/>`_ と、それより前の Python 2.4 向けの `Bag recipe <https://code.activestate.com/recipes/259174/>`_ 。"

#: ../../library/collections.rst:203
msgid ""
"`Bag class <https://www.gnu.org/software/smalltalk/manual-"
"base/html_node/Bag.html>`_ in Smalltalk."
msgstr "Smalltalk の `Bag class <https://www.gnu.org/software/smalltalk/manual-base/html_node/Bag.html>`_ 。"

#: ../../library/collections.rst:206
msgid ""
"Wikipedia entry for `Multisets <https://en.wikipedia.org/wiki/Multiset>`_."
msgstr "Wikipedia の `Multisets <https://en.wikipedia.org/wiki/Multiset>`_ の項目。"

#: ../../library/collections.rst:208
msgid ""
"`C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-multiset"
"/Catalog0380__set-multiset.htm>`_ tutorial with examples."
msgstr "`C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-multiset/Catalog0380__set-multiset.htm>`_ の例を交えたチュートリアル。"

#: ../../library/collections.rst:211
msgid ""
"For mathematical operations on multisets and their use cases, see *Knuth, "
"Donald. The Art of Computer Programming Volume II, Section 4.6.3, Exercise "
"19*."
msgstr "数学的な多重集合の演算とそのユースケースは、 *Knuth, Donald. The Art of Computer Programming Volume II, Section 4.6.3, Exercise 19* を参照してください。"

#: ../../library/collections.rst:215
msgid ""
"To enumerate all distinct multisets of a given size over a given set of "
"elements, see :func:`itertools.combinations_with_replacement`."
msgstr "与えられた要素の集まりから与えられた大きさの別個の多重集合をすべて数え上げるには、 :func:`itertools.combinations_with_replacement` を参照してください。"

#: ../../library/collections.rst:218
msgid ""
"map(Counter, combinations_with_replacement('ABC', 2)) --> AA AB AC BB BC CC"
msgstr "map(Counter, combinations_with_replacement('ABC', 2)) --> AA AB AC BB BC CC"

#: ../../library/collections.rst:222
msgid ":class:`deque` objects"
msgstr ":class:`deque` オブジェクト"

#: ../../library/collections.rst:226
msgid ""
"Returns a new deque object initialized left-to-right (using :meth:`append`) "
"with data from *iterable*.  If *iterable* is not specified, the new deque is"
" empty."
msgstr "*iterable* で与えられるデータから、新しい deque オブジェクトを (:meth:`append` をつかって) 左から右に初期化して返します。 *iterable* が指定されない場合、新しい deque オブジェクトは空になります。"

#: ../../library/collections.rst:229
msgid ""
"Deques are a generalization of stacks and queues (the name is pronounced "
"\"deck\" and is short for \"double-ended queue\").  Deques support thread-"
"safe, memory efficient appends and pops from either side of the deque with "
"approximately the same O(1) performance in either direction."
msgstr "Deque とは、スタックとキューを一般化したものです (この名前は「デック」と発音され、これは「double-ended queue」の省略形です)。Deque はどちらの側からも append と pop が可能で、スレッドセーフでメモリ効率がよく、どちらの方向からもおよそ ``O(1)`` のパフォーマンスで実行できます。"

#: ../../library/collections.rst:234
msgid ""
"Though :class:`list` objects support similar operations, they are optimized "
"for fast fixed-length operations and incur O(n) memory movement costs for "
"``pop(0)`` and ``insert(0, v)`` operations which change both the size and "
"position of the underlying data representation."
msgstr ":class:`list` オブジェクトでも同様の操作を実現できますが、これは高速な固定長の操作に特化されており、内部のデータ表現形式のサイズと位置を両方変えるような ``pop(0)`` や ``insert(0, v)`` などの操作ではメモリ移動のために ``O(n)`` のコストを必要とします。"

#: ../../library/collections.rst:241
msgid ""
"If *maxlen* is not specified or is ``None``, deques may grow to an arbitrary"
" length.  Otherwise, the deque is bounded to the specified maximum length.  "
"Once a bounded length deque is full, when new items are added, a "
"corresponding number of items are discarded from the opposite end.  Bounded "
"length deques provide functionality similar to the ``tail`` filter in Unix. "
"They are also useful for tracking transactions and other pools of data where"
" only the most recent activity is of interest."
msgstr "*maxlen* が指定され無かったり ``None``* だった場合、 deque は任意のサイズまで大きくなります。\nそうでない場合、 deque のサイズは指定された最大長に制限されます。\n長さが制限された deque がいっぱいになると、新しい要素を追加するときに追加した要素数分だけ追加したのと反対側から要素が捨てられます。\n長さが制限された deque は Unix における ``tail`` フィルタと似た機能を提供します。\nトランザクションの tracking や最近使った要素だけを残したいデータプール (pool of data) などにも便利です。"

#: ../../library/collections.rst:249
msgid "Added *maxlen* parameter."
msgstr "*maxlen* パラメータを追加しました。"

#: ../../library/collections.rst:252
msgid "Deque objects support the following methods:"
msgstr "Deque オブジェクトは以下のようなメソッドをサポートしています:"

#: ../../library/collections.rst:257
msgid "Add *x* to the right side of the deque."
msgstr "*x* を deque の右側につけ加えます。"

#: ../../library/collections.rst:262
msgid "Add *x* to the left side of the deque."
msgstr "*x* を deque の左側につけ加えます。"

#: ../../library/collections.rst:267
msgid "Remove all elements from the deque leaving it with length 0."
msgstr "deque からすべての要素を削除し、長さを 0 にします。"

#: ../../library/collections.rst:272
msgid "Count the number of deque elements equal to *x*."
msgstr "*x* に等しい deque の要素を数え上げます。"

#: ../../library/collections.rst:278
msgid ""
"Extend the right side of the deque by appending elements from the iterable "
"argument."
msgstr "イテレータ化可能な引数 iterable から得られる要素を deque の右側に追加し拡張します。"

#: ../../library/collections.rst:284
msgid ""
"Extend the left side of the deque by appending elements from *iterable*. "
"Note, the series of left appends results in reversing the order of elements "
"in the iterable argument."
msgstr "イテレータ化可能な引数 iterable から得られる要素を deque の左側に追加し拡張します。注意: 左から追加した結果は、イテレータ引数の順序とは逆になります。"

#: ../../library/collections.rst:291
msgid ""
"Remove and return an element from the right side of the deque. If no "
"elements are present, raises an :exc:`IndexError`."
msgstr "deque の右側から要素をひとつ削除し、その要素を返します。要素がひとつも存在しない場合は :exc:`IndexError` を発生させます。"

#: ../../library/collections.rst:297
msgid ""
"Remove and return an element from the left side of the deque. If no elements"
" are present, raises an :exc:`IndexError`."
msgstr "deque の左側から要素をひとつ削除し、その要素を返します。要素がひとつも存在しない場合は :exc:`IndexError` を発生させます。"

#: ../../library/collections.rst:303
msgid ""
"Removed the first occurrence of *value*.  If not found, raises a "
":exc:`ValueError`."
msgstr "最初に現れる value を削除します。要素がみつからないない場合は :exc:`ValueError` を発生させます。"

#: ../../library/collections.rst:310
msgid "Reverse the elements of the deque in-place and then return ``None``."
msgstr "deque の要素をインプレースに逆転し、 ``None`` を返します。"

#: ../../library/collections.rst:316
msgid ""
"Rotate the deque *n* steps to the right.  If *n* is negative, rotate to the "
"left.  Rotating one step to the right is equivalent to: "
"``d.appendleft(d.pop())``."
msgstr "deque の要素を全体で *n* ステップだけ右にローテートします。 *n* が負の値の場合は、左にローテートします。Deque をひとつ右にローテートすることは ``d.appendleft(d.pop())`` と同じです。"

#: ../../library/collections.rst:321
msgid "Deque objects also provide one read-only attribute:"
msgstr "deque オブジェクトは読み取り専用属性も 1 つ提供しています:"

#: ../../library/collections.rst:325
msgid "Maximum size of a deque or ``None`` if unbounded."
msgstr "deque の最大長で、制限されていなければ ``None`` です。"

#: ../../library/collections.rst:330
msgid ""
"In addition to the above, deques support iteration, pickling, ``len(d)``, "
"``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, membership testing "
"with the :keyword:`in` operator, and subscript references such as ``d[-1]``."
"  Indexed access is O(1) at both ends but slows to O(n) in the middle.  For "
"fast random access, use lists instead."
msgstr "上記の操作のほかにも、deque は次のような操作をサポートしています: イテレータ化、pickle、 ``len(d)``, ``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, :keyword:`in` 演算子による包含検査、そして ``d[-1]`` などの添え字による参照。両端についてインデックスアクセスは O(1) ですが、中央部分については O(n) の遅さです。高速なランダムアクセスが必要ならリストを使ってください。"

#: ../../library/collections.rst:336 ../../library/collections.rst:598
msgid "Example:"
msgstr "例:"

#: ../../library/collections.rst:393
msgid ":class:`deque` Recipes"
msgstr ":class:`deque` のレシピ"

#: ../../library/collections.rst:395
msgid "This section shows various approaches to working with deques."
msgstr "この節では deque をつかったさまざまなアプローチを紹介します。"

#: ../../library/collections.rst:397
msgid ""
"Bounded length deques provide functionality similar to the ``tail`` filter "
"in Unix::"
msgstr "長さが制限された deque は Unix における ``tail`` フィルタに相当する機能を提供します::"

#: ../../library/collections.rst:404
msgid ""
"Another approach to using deques is to maintain a sequence of recently added"
" elements by appending to the right and popping to the left::"
msgstr "別のアプローチとして deque を右に append して左に pop して使うことで追加した要素を維持するのに使えます::"

#: ../../library/collections.rst:419
msgid ""
"The :meth:`rotate` method provides a way to implement :class:`deque` slicing"
" and deletion.  For example, a pure Python implementation of ``del d[n]`` "
"relies on the :meth:`rotate` method to position elements to be popped::"
msgstr ":meth:`rotate` メソッドのおかげで、 :class:`deque` の一部を切り出したり削除したりできることになります。たとえば ``del d[n]`` の純粋な Python 実装では pop したい要素まで :meth:`rotate` します ::"

#: ../../library/collections.rst:428
msgid ""
"To implement :class:`deque` slicing, use a similar approach applying "
":meth:`rotate` to bring a target element to the left side of the deque. "
"Remove old entries with :meth:`popleft`, add new entries with "
":meth:`extend`, and then reverse the rotation. With minor variations on that"
" approach, it is easy to implement Forth style stack manipulations such as "
"``dup``, ``drop``, ``swap``, ``over``, ``pick``, ``rot``, and ``roll``."
msgstr ":class:`deque` の切り出しを実装するのにも、同様のアプローチを使います。まず対象となる要素を :meth:`rotate` によって deque の左端までもってきてから、 :meth:`popleft` をつかって古い要素を消します。そして、 :meth:`extend` で新しい要素を追加したのち、逆のローテートでもとに戻せばよいのです。このアプローチをやや変えたものとして、Forth スタイルのスタック操作、つまり ``dup``, ``drop``, ``swap``, ``over``, ``pick``, ``rot``, および ``roll`` を実装するのも簡単です。"

#: ../../library/collections.rst:438
msgid ":class:`defaultdict` objects"
msgstr ":class:`defaultdict` オブジェクト"

#: ../../library/collections.rst:442
msgid ""
"Returns a new dictionary-like object.  :class:`defaultdict` is a subclass of"
" the built-in :class:`dict` class.  It overrides one method and adds one "
"writable instance variable.  The remaining functionality is the same as for "
"the :class:`dict` class and is not documented here."
msgstr "新しいディクショナリ状のオブジェクトを返します。 :class:`defaultdict` は組込みの :class:`dict` のサブクラスです。メソッドをオーバーライドし、書き込み可能なインスタンス変数を1つ追加している以外は :class:`dict` クラスと同じです。同じ部分については以下では省略されています。"

#: ../../library/collections.rst:447
msgid ""
"The first argument provides the initial value for the "
":attr:`default_factory` attribute; it defaults to ``None``. All remaining "
"arguments are treated the same as if they were passed to the :class:`dict` "
"constructor, including keyword arguments."
msgstr "1つめの引数は :attr:`default_factory` 属性の初期値です。デフォルトは ``None`` です。残りの引数はキーワード引数もふくめ、 :class:`dict` のコンストラクタにあたえられた場合と同様に扱われます。"

#: ../../library/collections.rst:454
msgid ""
":class:`defaultdict` objects support the following method in addition to the"
" standard :class:`dict` operations:"
msgstr ":class:`defaultdict` オブジェクトは標準の :class:`dict` に加えて、以下のメソッドを実装しています:"

#: ../../library/collections.rst:459
msgid ""
"If the :attr:`default_factory` attribute is ``None``, this raises a "
":exc:`KeyError` exception with the *key* as argument."
msgstr "もし :attr:`default_factory` 属性が ``None`` であれば、このメソッドは :exc:`KeyError` 例外を、 *key* を引数として発生させます。"

#: ../../library/collections.rst:462
msgid ""
"If :attr:`default_factory` is not ``None``, it is called without arguments "
"to provide a default value for the given *key*, this value is inserted in "
"the dictionary for the *key*, and returned."
msgstr "もし :attr:`default_factory` 属性が ``None`` でなければ、このメソッドは :attr:`default_factory` を引数なしで呼び出し、あたえられた *key* に対応するデフォルト値を作ります。そしてこの値を *key* に対応する値を辞書に登録して返ります。"

#: ../../library/collections.rst:466
msgid ""
"If calling :attr:`default_factory` raises an exception this exception is "
"propagated unchanged."
msgstr "もし :attr:`default_factory` の呼出が例外を発生させた場合には、変更せずそのまま例外を投げます。"

#: ../../library/collections.rst:469
msgid ""
"This method is called by the :meth:`__getitem__` method of the :class:`dict`"
" class when the requested key is not found; whatever it returns or raises is"
" then returned or raised by :meth:`__getitem__`."
msgstr "このメソッドは :class:`dict` クラスの :meth:`__getitem__` メソッドで、キーが存在しなかった場合によびだされます。値を返すか例外を発生させるのどちらにしても、 :meth:`__getitem__` からもそのまま値が返るか例外が発生します。"

#: ../../library/collections.rst:473
msgid ""
"Note that :meth:`__missing__` is *not* called for any operations besides "
":meth:`__getitem__`. This means that :meth:`get` will, like normal "
"dictionaries, return ``None`` as a default rather than using "
":attr:`default_factory`."
msgstr "なお、 :meth:`__missing__` は :meth:`__getitem__` 以外のいかなる演算に対しても呼び出され *ません* 。よって :meth:`get` は、普通の辞書と同様に、 :attr:`default_factory` を使うのではなくデフォルトとして ``None`` を返します。"

#: ../../library/collections.rst:479
msgid ":class:`defaultdict` objects support the following instance variable:"
msgstr ":class:`defaultdict` オブジェクトは以下のインスタンス変数をサポートしています:"

#: ../../library/collections.rst:484
msgid ""
"This attribute is used by the :meth:`__missing__` method; it is initialized "
"from the first argument to the constructor, if present, or to ``None``, if "
"absent."
msgstr "この属性は :meth:`__missing__` メソッドによって使われます。これは存在すればコンストラクタの第1引数によって初期化され、そうでなければ ``None`` になります。"

#: ../../library/collections.rst:490
msgid ":class:`defaultdict` Examples"
msgstr ":class:`defaultdict` の使用例"

#: ../../library/collections.rst:492
msgid ""
"Using :class:`list` as the :attr:`default_factory`, it is easy to group a "
"sequence of key-value pairs into a dictionary of lists:"
msgstr ":class:`list` を :attr:`default_factory` とすることで、キー=値ペアのシーケンスをリストの辞書へ簡単にグループ化できます。:"

#: ../../library/collections.rst:503
msgid ""
"When each key is encountered for the first time, it is not already in the "
"mapping; so an entry is automatically created using the "
":attr:`default_factory` function which returns an empty :class:`list`.  The "
":meth:`list.append` operation then attaches the value to the new list.  When"
" keys are encountered again, the look-up proceeds normally (returning the "
"list for that key) and the :meth:`list.append` operation adds another value "
"to the list. This technique is simpler and faster than an equivalent "
"technique using :meth:`dict.setdefault`:"
msgstr "それぞれのキーが最初に登場したとき、マッピングにはまだ存在しません。そのためエントリは :attr:`default_factory` 関数が返す空の :class:`list` を使って自動的に作成されます。 :meth:`list.append` 操作は新しいリストに紐付けられます。キーが再度出現下場合には、通常の参照動作が行われます(そのキーに対応するリストが返ります)。そして :meth:`list.append` 操作で別の値をリストに追加します。このテクニックは :meth:`dict.setdefault` を使った等価なものよりシンプルで速いです:"

#: ../../library/collections.rst:518
msgid ""
"Setting the :attr:`default_factory` to :class:`int` makes the "
":class:`defaultdict` useful for counting (like a bag or multiset in other "
"languages):"
msgstr ":attr:`default_factory` を :class:`int` にすると、 :class:`defaultdict` を(他の言語の bag や multisetのように)要素の数え上げに便利に使うことができます:"

#: ../../library/collections.rst:530
msgid ""
"When a letter is first encountered, it is missing from the mapping, so the "
":attr:`default_factory` function calls :func:`int` to supply a default count"
" of zero.  The increment operation then builds up the count for each letter."
msgstr "最初に文字が出現したときは、マッピングが存在しないので :attr:`default_factory` 関数が :func:`int` を呼んでデフォルトのカウント0を生成します。インクリメント操作が各文字を数え上げます。"

#: ../../library/collections.rst:534
msgid ""
"The function :func:`int` which always returns zero is just a special case of"
" constant functions.  A faster and more flexible way to create constant "
"functions is to use :func:`itertools.repeat` which can supply any constant "
"value (not just zero):"
msgstr "常に0を返す :func:`int` は特殊な関数でした。定数を生成するより速くて柔軟な方法は、 0に限らず何でも定数を生成する :func:`itertools.repeat` を使うことです。"

#: ../../library/collections.rst:546
msgid ""
"Setting the :attr:`default_factory` to :class:`set` makes the "
":class:`defaultdict` useful for building a dictionary of sets:"
msgstr ":attr:`default_factory` を :class:`set` に設定することで、 :class:`defaultdict` をセットの辞書を作るために利用することができます:"

#: ../../library/collections.rst:559
msgid ":func:`namedtuple` Factory Function for Tuples with Named Fields"
msgstr ":func:`namedtuple` 名前付きフィールドを持つタプルのファクトリ関数"

#: ../../library/collections.rst:561
msgid ""
"Named tuples assign meaning to each position in a tuple and allow for more "
"readable, self-documenting code.  They can be used wherever regular tuples "
"are used, and they add the ability to access fields by name instead of "
"position index."
msgstr "名前付きタプルはタプルの中の場所に意味を割り当てて、より読みやすく自己解説的なコードを書けるようにします。通常のタプルが利用されていた場所で利用でき、場所に対するインデックスの代わりに名前を使ってフィールドにアクセスできます。"

#: ../../library/collections.rst:567
msgid ""
"Returns a new tuple subclass named *typename*.  The new subclass is used to "
"create tuple-like objects that have fields accessible by attribute lookup as"
" well as being indexable and iterable.  Instances of the subclass also have "
"a helpful docstring (with typename and field_names) and a helpful "
":meth:`__repr__` method which lists the tuple contents in a ``name=value`` "
"format."
msgstr "*typename* という名前の tuple の新しいサブクラスを返します。新しいサブクラスは、 tuple に似ているけれどもインデックスやイテレータだけでなく属性名によるアクセスもできるオブジェクトを作るのに使います。このサブクラスのインスタンスは、わかりやすい docstring (型名と属性名が入っています) や、 tuple の内容を ``name=value`` という形のリストで返す使いやすい :meth:`__repr__` も持っています。"

#: ../../library/collections.rst:573
msgid ""
"The *field_names* are a sequence of strings such as ``['x', 'y']``. "
"Alternatively, *field_names* can be a single string with each fieldname "
"separated by whitespace and/or commas, for example ``'x y'`` or ``'x, y'``."
msgstr "*field_names* は ``['x', 'y']`` のような文字列のシーケンスです。 *field_names* には、代わりに各属性名を空白文字 (whitespace) および/またはカンマ (,) で区切った文字列を渡すこともできます。例えば、 ``'x y'`` や ``'x, y'`` です。"

#: ../../library/collections.rst:577
msgid ""
"Any valid Python identifier may be used for a fieldname except for names "
"starting with an underscore.  Valid identifiers consist of letters, digits, "
"and underscores but do not start with a digit or underscore and cannot be a "
":mod:`keyword` such as *class*, *for*, *return*, *global*, *pass*, *print*, "
"or *raise*."
msgstr "アンダースコア (_) で始まる名前を除いて、 Python の正しい識別子 (identifier) ならなんでも属性名として使うことができます。正しい識別子とはアルファベット(letters), 数字(digits), アンダースコア(_) を含みますが、数字やアンダースコアで始まる名前や、 *class*, *for*, *return*, *global*, *pass*, *print*, *raise* などといった :mod:`keyword` は使えません。"

#: ../../library/collections.rst:583
msgid ""
"If *rename* is true, invalid fieldnames are automatically replaced with "
"positional names.  For example, ``['abc', 'def', 'ghi', 'abc']`` is "
"converted to ``['abc', '_1', 'ghi', '_3']``, eliminating the keyword ``def``"
" and the duplicate fieldname ``abc``."
msgstr "*rename* が真なら、不適切なフィールド名は自動的に位置引数に置き換えられます。例えば ``['abc', 'def', 'ghi', 'abc']`` は、予約語 ``def`` と重複しているフィールド名 ``abc`` が除去され、 ``['abc', '_1', 'ghi', '_3']`` に変換されます。"

#: ../../library/collections.rst:588
msgid ""
"If *verbose* is true, the class definition is printed just before being "
"built."
msgstr "*verbose* が真なら、クラスを作る直前にクラス定義が表示されます。"

#: ../../library/collections.rst:590
msgid ""
"Named tuple instances do not have per-instance dictionaries, so they are "
"lightweight and require no more memory than regular tuples."
msgstr "名前付きタプルのインスタンスはインスタンスごとの辞書を持たないので、軽量で、普通のタプル以上のメモリを使用しません。"

#: ../../library/collections.rst:595
msgid "added support for *rename*."
msgstr "*rename* のサポートを追加しました。"

#: ../../library/collections.rst:665
msgid ""
"Named tuples are especially useful for assigning field names to result "
"tuples returned by the :mod:`csv` or :mod:`sqlite3` modules::"
msgstr "名前付きタプルは :mod:`csv` や :mod:`sqlite3` モジュールが返すタプルのフィールドに名前を付けるときにとても便利です::"

#: ../../library/collections.rst:681
msgid ""
"In addition to the methods inherited from tuples, named tuples support three"
" additional methods and one attribute.  To prevent conflicts with field "
"names, the method and attribute names start with an underscore."
msgstr "タプルから継承したメソッドに加えて、名前付きタプルは3つの追加メソッドと一つの属性をサポートしています。フィールド名との衝突を避けるためにメソッド名と属性名はアンダースコアで始まります。"

#: ../../library/collections.rst:687
msgid ""
"Class method that makes a new instance from an existing sequence or "
"iterable."
msgstr "既存の sequence や Iterable から新しいインスタンスを作るクラスメソッド."

#: ../../library/collections.rst:697
msgid ""
"Return a new :class:`OrderedDict` which maps field names to their "
"corresponding values::"
msgstr "フィールド名を対応する値にマッピングする新しい順序付き辞書 (:class:`OrderedDict`) を返します::"

#: ../../library/collections.rst:704
msgid "Returns an :class:`OrderedDict` instead of a regular :class:`dict`."
msgstr "通常の :class:`dict` の代わりに :class:`OrderedDict` を返すようになりました。"

#: ../../library/collections.rst:709
msgid ""
"Return a new instance of the named tuple replacing specified fields with new"
" values::"
msgstr "指定されたフィールドを新しい値で置き換えた、新しい名前付きタプルを作って返します::"

#: ../../library/collections.rst:721
msgid ""
"Tuple of strings listing the field names.  Useful for introspection and for "
"creating new named tuple types from existing named tuples."
msgstr "フィールド名をリストにしたタプル. 内省 (introspection) したり、既存の名前付きタプルをもとに新しい名前つきタプルを作成する時に便利です。"

#: ../../library/collections.rst:734
msgid ""
"To retrieve a field whose name is stored in a string, use the "
":func:`getattr` function:"
msgstr "文字列に格納された名前を使って名前つきタプルから値を取得するには :func:`getattr` 関数を使います:"

#: ../../library/collections.rst:740
msgid ""
"To convert a dictionary to a named tuple, use the double-star-operator (as "
"described in :ref:`tut-unpacking-arguments`):"
msgstr "辞書を名前付きタプルに変換するには、 ``**`` 演算子 (double-star-operator, :ref:`tut-unpacking-arguments` で説明しています) を使います。:"

#: ../../library/collections.rst:747
msgid ""
"Since a named tuple is a regular Python class, it is easy to add or change "
"functionality with a subclass.  Here is how to add a calculated field and a "
"fixed-width print format:"
msgstr "名前付きタプルは通常の Python クラスなので、継承して機能を追加したり変更するのは容易です。次の例では計算済みフィールドと固定幅の print format を追加しています:"

#: ../../library/collections.rst:764
msgid ""
"The subclass shown above sets ``__slots__`` to an empty tuple.  This helps "
"keep memory requirements low by preventing the creation of instance "
"dictionaries."
msgstr "このサブクラスは ``__slots__`` に空のタプルをセットしています。これにより、インスタンス辞書の作成を抑制してメモリ使用量を低く保つのに役立ちます。"

#: ../../library/collections.rst:767
msgid ""
"Subclassing is not useful for adding new, stored fields.  Instead, simply "
"create a new named tuple type from the :attr:`_fields` attribute:"
msgstr "サブクラス化は新しいフィールドを追加するのには適していません。代わりに、新しい名前付きタプルを :attr:`_fields` 属性を元に作成してください:"

#: ../../library/collections.rst:772
msgid ""
"Default values can be implemented by using :meth:`_replace` to customize a "
"prototype instance:"
msgstr ":meth:`_replace` でプロトタイプのインスタンスをカスタマイズする方法で、デフォルト値を実現できます:"

#: ../../library/collections.rst:779
msgid ""
"Enumerated constants can be implemented with named tuples, but it is simpler"
" and more efficient to use a simple class declaration:"
msgstr "列挙型定数は名前付きタプルでも実装できますが、クラス定義を利用した方がシンプルで効率的です:"

#: ../../library/collections.rst:790
msgid ""
"`Named tuple recipe <https://code.activestate.com/recipes/500261/>`_ adapted"
" for Python 2.4."
msgstr "Python 2.4 向けの `Named tuple recipe <https://code.activestate.com/recipes/500261/>`_ 。"

#: ../../library/collections.rst:795
msgid ":class:`OrderedDict` objects"
msgstr ":class:`OrderedDict` オブジェクト"

#: ../../library/collections.rst:797
msgid ""
"Ordered dictionaries are just like regular dictionaries but they remember "
"the order that items were inserted.  When iterating over an ordered "
"dictionary, the items are returned in the order their keys were first added."
msgstr "順序付き辞書 (ordered dictionary) は、ちょうど普通の辞書と同じようなものですが、項目が挿入された順序を記憶します。順序付き辞書に渡ってイテレートするとき、項目はそのキーが最初に追加された順序で返されます。"

#: ../../library/collections.rst:803
msgid ""
"Return an instance of a dict subclass, supporting the usual :class:`dict` "
"methods.  An *OrderedDict* is a dict that remembers the order that keys were"
" first inserted. If a new entry overwrites an existing entry, the original "
"insertion position is left unchanged.  Deleting an entry and reinserting it "
"will move it to the end."
msgstr "通常の :class:`dict` メソッドをサポートする、辞書のサブクラスのインスタンスを返します。 *OrderedDict* は、キーが最初に追加された順序を記憶します。新しい項目が既存の項目を上書きしても、元の挿入位置は変わらないままです。項目を削除して再挿入するとそれが最後に移動します。"

#: ../../library/collections.rst:813
msgid ""
"The :meth:`popitem` method for ordered dictionaries returns and removes a "
"(key, value) pair.  The pairs are returned in LIFO order if *last* is true "
"or FIFO order if false."
msgstr "順序付き辞書の :meth:`popitem` メソッドは、(key, value) 対を返して消去します。この対は *last* が真なら後入先出で、偽なら先入先出で返されます。"

#: ../../library/collections.rst:817
msgid ""
"In addition to the usual mapping methods, ordered dictionaries also support "
"reverse iteration using :func:`reversed`."
msgstr "通常のマッピングのメソッドに加え、順序付き辞書は :func:`reversed` による逆順の反復もサポートしています。"

#: ../../library/collections.rst:820
msgid ""
"Equality tests between :class:`OrderedDict` objects are order-sensitive and "
"are implemented as ``list(od1.items())==list(od2.items())``. Equality tests "
"between :class:`OrderedDict` objects and other :class:`Mapping` objects are "
"order-insensitive like regular dictionaries.  This allows "
":class:`OrderedDict` objects to be substituted anywhere a regular dictionary"
" is used."
msgstr ":class:`OrderedDict` 間の等価判定は順序が影響し、 ``list(od1.items())==list(od2.items())`` のように実装されます。 :class:`OrderedDict` オブジェクトと他のマッピング (:class:`Mapping`) オブジェクトの等価判定は、順序に影響されず、通常の辞書と同様です。これによって、 :class:`OrderedDict` オブジェクトは通常の辞書が使われるところならどこでも使用できます。"

#: ../../library/collections.rst:827
msgid ""
"The :class:`OrderedDict` constructor and :meth:`update` method both accept "
"keyword arguments, but their order is lost because Python's function call "
"semantics pass-in keyword arguments using a regular unordered dictionary."
msgstr ":class:`OrderedDict` コンストラクタと :meth:`update` メソッドは、どちらもキーワード引数を受け付けますが、その順序は失われます。これは、Python の関数呼び出しの意味づけにおいて、キーワード引数は順序付けされていない辞書を用いて渡されるからです。"

#: ../../library/collections.rst:833
msgid ""
"`Equivalent OrderedDict recipe "
"<https://code.activestate.com/recipes/576693/>`_ that runs on Python 2.4 or "
"later."
msgstr "Python 2.4 以降で動作する、 `Equivalent OrderedDict recipe <https://code.activestate.com/recipes/576693/>`_ 。"

#: ../../library/collections.rst:837
msgid ":class:`OrderedDict` Examples and Recipes"
msgstr ":class:`OrderedDict` の例とレシピ"

#: ../../library/collections.rst:839
msgid ""
"Since an ordered dictionary remembers its insertion order, it can be used in"
" conjunction with sorting to make a sorted dictionary::"
msgstr "順序付き辞書は挿入順序を記憶するので、ソートと組み合わせて使うことで、ソートされた辞書を作れます::"

#: ../../library/collections.rst:857
msgid ""
"The new sorted dictionaries maintain their sort order when entries are "
"deleted.  But when new keys are added, the keys are appended to the end and "
"the sort is not maintained."
msgstr "この新しい順序付き辞書は、項目が削除されてもソートされた順序を保持します。しかし、キーが追加されるとき、そのキーは最後に追加され、ソートは保持されません。"

#: ../../library/collections.rst:861
msgid ""
"It is also straight-forward to create an ordered dictionary variant that "
"remembers the order the keys were *last* inserted. If a new entry overwrites"
" an existing entry, the original insertion position is changed and moved to "
"the end::"
msgstr "キーが *最後に* 挿入された順序を記憶するような、順序付き辞書の変種を作るのも簡単です。新しい項目が既存の項目を上書きしたら、元の挿入位置は最後に移動します::"

#: ../../library/collections.rst:874
msgid ""
"An ordered dictionary can be combined with the :class:`Counter` class so "
"that the counter remembers the order elements are first encountered::"
msgstr "順序付き辞書と :class:`Counter` クラスを組み合わせると、要素が最初に現れた順を記憶するカウンタができます::"

#: ../../library/collections.rst:890
msgid "Collections Abstract Base Classes"
msgstr "コレクション抽象基底クラス"

#: ../../library/collections.rst:892
msgid ""
"The collections module offers the following :term:`ABCs <abstract base "
"class>`:"
msgstr "collections モジュールは以下の :term:`ABC (抽象基底クラス) <abstract base class>` を提供します:"

#: ../../library/collections.rst:895
msgid "ABC"
msgstr "ABC"

#: ../../library/collections.rst:895
msgid "Inherits from"
msgstr "継承しているクラス"

#: ../../library/collections.rst:895
msgid "Abstract Methods"
msgstr "抽象メソッド"

#: ../../library/collections.rst:895
msgid "Mixin Methods"
msgstr "mixin メソッド"

#: ../../library/collections.rst:897
msgid ":class:`Container`"
msgstr ":class:`Container`"

#: ../../library/collections.rst:897
msgid "``__contains__``"
msgstr "``__contains__``"

#: ../../library/collections.rst:898
msgid ":class:`Hashable`"
msgstr ":class:`Hashable`"

#: ../../library/collections.rst:898
msgid "``__hash__``"
msgstr "``__hash__``"

#: ../../library/collections.rst:899 ../../library/collections.rst:900
msgid ":class:`Iterable`"
msgstr ":class:`Iterable`"

#: ../../library/collections.rst:899 ../../library/collections.rst:900
msgid "``__iter__``"
msgstr "``__iter__``"

#: ../../library/collections.rst:900
msgid ":class:`Iterator`"
msgstr ":class:`Iterator`"

#: ../../library/collections.rst:900
msgid "``next``"
msgstr "``next``"

#: ../../library/collections.rst:901 ../../library/collections.rst:935
msgid ":class:`Sized`"
msgstr ":class:`Sized`"

#: ../../library/collections.rst:901 ../../library/collections.rst:935
msgid "``__len__``"
msgstr "``__len__``"

#: ../../library/collections.rst:902
msgid ":class:`Callable`"
msgstr ":class:`Callable`"

#: ../../library/collections.rst:902
msgid "``__call__``"
msgstr "``__call__``"

#: ../../library/collections.rst:904 ../../library/collections.rst:908
msgid ":class:`Sequence`"
msgstr ":class:`Sequence`"

#: ../../library/collections.rst:904 ../../library/collections.rst:914
#: ../../library/collections.rst:924
msgid ":class:`Sized`, :class:`Iterable`, :class:`Container`"
msgstr ":class:`Sized`, :class:`Iterable`, :class:`Container`"

#: ../../library/collections.rst:904
msgid "``__getitem__``, ``__len__``"
msgstr "``__getitem__``, ``__len__``"

#: ../../library/collections.rst:904
msgid ""
"``__contains__``, ``__iter__``, ``__reversed__``, ``index``, and ``count``"
msgstr "``__contains__``, ``__iter__``, ``__reversed__``, ``index``, ``count``"

#: ../../library/collections.rst:908
msgid ":class:`MutableSequence`"
msgstr ":class:`MutableSequence`"

#: ../../library/collections.rst:908
msgid ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__len__``, ``insert``"
msgstr "``__getitem__``, ``__setitem__``, ``__delitem__``, ``__len__``, ``insert``"

#: ../../library/collections.rst:908
msgid ""
"Inherited :class:`Sequence` methods and ``append``, ``reverse``, ``extend``,"
" ``pop``, ``remove``, and ``__iadd__``"
msgstr ":class:`Sequence` から継承したメソッドと、 ``append``, ``reverse``, ``extend``, ``pop``, ``remove``, ``__iadd__``"

#: ../../library/collections.rst:914 ../../library/collections.rst:918
msgid ":class:`Set`"
msgstr ":class:`Set`"

#: ../../library/collections.rst:914
msgid "``__contains__``, ``__iter__``, ``__len__``"
msgstr "``__contains__``, ``__iter__``, ``__len__``"

#: ../../library/collections.rst:914
msgid ""
"``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, "
"``__and__``, ``__or__``, ``__sub__``, ``__xor__``, and ``isdisjoint``"
msgstr "``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, ``__and__``, ``__or__``, ``__sub__``, ``__xor__``, ``isdisjoint``"

#: ../../library/collections.rst:918
msgid ":class:`MutableSet`"
msgstr ":class:`MutableSet`"

#: ../../library/collections.rst:918
msgid "``__contains__``, ``__iter__``, ``__len__``, ``add``, ``discard``"
msgstr "``__contains__``, ``__iter__``, ``__len__``, ``add``, ``discard``"

#: ../../library/collections.rst:918
msgid ""
"Inherited :class:`Set` methods and ``clear``, ``pop``, ``remove``, "
"``__ior__``, ``__iand__``, ``__ixor__``, and ``__isub__``"
msgstr ":class:`Set` から継承したメソッドと、 ``clear``, ``pop``, ``remove``, ``__ior__``, ``__iand__``, ``__ixor__``, ``__isub__``"

#: ../../library/collections.rst:924 ../../library/collections.rst:928
msgid ":class:`Mapping`"
msgstr ":class:`Mapping`"

#: ../../library/collections.rst:924
msgid "``__getitem__``, ``__iter__``, ``__len__``"
msgstr "``__getitem__``, ``__iter__``, ``__len__``"

#: ../../library/collections.rst:924
msgid ""
"``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__``, and "
"``__ne__``"
msgstr "``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__``, ``__ne__``"

#: ../../library/collections.rst:928
msgid ":class:`MutableMapping`"
msgstr ":class:`MutableMapping`"

#: ../../library/collections.rst:928
msgid ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__iter__``, ``__len__``"
msgstr "``__getitem__``, ``__setitem__``, ``__delitem__``, ``__iter__``, ``__len__``"

#: ../../library/collections.rst:928
msgid ""
"Inherited :class:`Mapping` methods and ``pop``, ``popitem``, ``clear``, "
"``update``, and ``setdefault``"
msgstr ":class:`Mapping` から継承したメソッドと、 ``pop``, ``popitem``, ``clear``, ``update``, ``setdefault``"

#: ../../library/collections.rst:935 ../../library/collections.rst:940
msgid ":class:`MappingView`"
msgstr ":class:`MappingView`"

#: ../../library/collections.rst:936
msgid ":class:`ItemsView`"
msgstr ":class:`ItemsView`"

#: ../../library/collections.rst:936 ../../library/collections.rst:938
msgid ":class:`MappingView`, :class:`Set`"
msgstr ":class:`MappingView`, :class:`Set`"

#: ../../library/collections.rst:936 ../../library/collections.rst:938
#: ../../library/collections.rst:940
msgid "``__contains__``, ``__iter__``"
msgstr "``__contains__``, ``__iter__``"

#: ../../library/collections.rst:938
msgid ":class:`KeysView`"
msgstr ":class:`KeysView`"

#: ../../library/collections.rst:940
msgid ":class:`ValuesView`"
msgstr ":class:`ValuesView`"

#: ../../library/collections.rst:949
msgid ""
"ABCs for classes that provide respectively the methods :meth:`__contains__`,"
" :meth:`__hash__`, :meth:`__len__`, and :meth:`__call__`."
msgstr "それぞれメソッド :meth:`__contains__`, :meth:`__hash__`, :meth:`__len__`,  :meth:`__call__` を提供するクラスの ABC です。"

#: ../../library/collections.rst:954
msgid ""
"ABC for classes that provide the :meth:`__iter__` method. See also the "
"definition of :term:`iterable`."
msgstr ":meth:`__iter__` メソッドを提供するクラスの ABC です。 :term:`iterable` の定義も参照してください。"

#: ../../library/collections.rst:959
msgid ""
"ABC for classes that provide the :meth:`~iterator.__iter__` and "
":meth:`~iterator.next` methods.  See also the definition of "
":term:`iterator`."
msgstr ":meth:`~iterator.__iter__` メソッドと :meth:`~iterator.next` メソッドを提供するクラスの ABC です。 :term:`iterator` の定義も参照してください。"

#: ../../library/collections.rst:965
msgid "ABCs for read-only and mutable :term:`sequences <sequence>`."
msgstr "読み込み専用と、ミュータブルな :term:`シーケンス <sequence>` の ABC です。"

#: ../../library/collections.rst:970
msgid "ABCs for read-only and mutable sets."
msgstr "読み込み専用と、ミュータブルな集合の ABC です。"

#: ../../library/collections.rst:975
msgid "ABCs for read-only and mutable :term:`mappings <mapping>`."
msgstr "読み込み専用と、ミュータブルな :term:`マッピング <mapping>` の ABC です。"

#: ../../library/collections.rst:982
msgid ""
"ABCs for mapping, items, keys, and values :term:`views <dictionary view>`."
msgstr "マッピング、要素、キー、値の :term:`ビュー <dictionary view>` の ABC です。"

#: ../../library/collections.rst:985
msgid ""
"These ABCs allow us to ask classes or instances if they provide particular "
"functionality, for example::"
msgstr "これらの ABC はクラスやインスタンスが特定の機能を提供しているかどうかを調べるのに使えます。例えば::"

#: ../../library/collections.rst:992
msgid ""
"Several of the ABCs are also useful as mixins that make it easier to develop"
" classes supporting container APIs.  For example, to write a class "
"supporting the full :class:`Set` API, it only necessary to supply the three "
"underlying abstract methods: :meth:`__contains__`, :meth:`__iter__`, and "
":meth:`__len__`. The ABC supplies the remaining methods such as "
":meth:`__and__` and :meth:`isdisjoint` ::"
msgstr "幾つかの ABC はコンテナ型 API を提供するクラスを開発するのを助ける mixin 型としても使えます。例えば、 :class:`Set` API を提供するクラスを作る場合、3つの基本になる抽象メソッド :meth:`__contains__`, :meth:`__iter__`, :meth:`__len__` だけが必要です。 ABC が残りの :meth:`__and__` や :meth:`isdisjoint` といったメソッドを提供します::"

#: ../../library/collections.rst:1021
msgid "Notes on using :class:`Set` and :class:`MutableSet` as a mixin:"
msgstr ":class:`Set` と :class:`MutableSet` を mixin 型として利用するときの注意点:"

#: ../../library/collections.rst:1024
msgid ""
"Since some set operations create new sets, the default mixin methods need a "
"way to create new instances from an iterable. The class constructor is "
"assumed to have a signature in the form ``ClassName(iterable)``. That "
"assumption is factored-out to an internal classmethod called "
":meth:`_from_iterable` which calls ``cls(iterable)`` to produce a new set. "
"If the :class:`Set` mixin is being used in a class with a different "
"constructor signature, you will need to override :meth:`_from_iterable` with"
" a classmethod that can construct new instances from an iterable argument."
msgstr "幾つかの set の操作は新しい set を作るので、デフォルトの mixin メソッドは iterable から新しいインスタンスを作成する方法を必要とします。クラスのコンストラクタは ``ClassName(iterable)`` の形のシグネチャを持つと仮定されます。内部の :meth:`_from_iterable` というクラスメソッドが ``cls(iterable)`` を呼び出して新しい set を作る部分でこの仮定が使われています。コンストラクタのシグネチャが異なるクラスで :class:`Set` を使う場合は、 iterable 引数から新しいインスタンスを生成するように :meth:`_from_iterable` をオーバーライドする必要があります。"

#: ../../library/collections.rst:1035
msgid ""
"To override the comparisons (presumably for speed, as the semantics are "
"fixed), redefine :meth:`__le__` and :meth:`__ge__`, then the other "
"operations will automatically follow suit."
msgstr "(たぶん意味はそのままに速度を向上する目的で)比較をオーバーライドする場合、 :meth:`__le__` と :meth:`__ge__` だけを再定義すれば、その他の演算は自動的に追随します。"

#: ../../library/collections.rst:1040
msgid ""
"The :class:`Set` mixin provides a :meth:`_hash` method to compute a hash "
"value for the set; however, :meth:`__hash__` is not defined because not all "
"sets are hashable or immutable.  To add set hashability using mixins, "
"inherit from both :meth:`Set` and :meth:`Hashable`, then define ``__hash__ ="
" Set._hash``."
msgstr ":class:`Set` mixin型は set のハッシュ値を計算する :meth:`_hash` メソッドを提供しますが、すべての set が hashable や immutable とは限らないので、 :meth:`__hash__` は提供しません。 mixin を使ってハッシュ可能な set を作る場合は、 :class:`Set` と :class:`Hashable` の両方を継承して、 ``__hash__ = Set._hash`` と定義してください。"

#: ../../library/collections.rst:1048
msgid ""
"`OrderedSet recipe <https://code.activestate.com/recipes/576694/>`_ for an "
"example built on :class:`MutableSet`."
msgstr ":class:`MutableSet` を使った例として `OrderedSet recipe <https://code.activestate.com/recipes/576694/>`_。"

#: ../../library/collections.rst:1051
msgid "For more about ABCs, see the :mod:`abc` module and :pep:`3119`."
msgstr "ABCs についての詳細は、 :mod:`abc` モジュールと :pep:`3119` を参照してください。"
