# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# mollinaca, 2021
# Takanori Suzuki <takanori@takanory.net>, 2021
# tomo, 2021
# Takeshi Nakazato, 2022
# souma987, 2023
# Arihiro TAKASE, 2023
# 石井明久, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-18 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 00:56+0000\n"
"Last-Translator: 石井明久, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/collections.rst:2
msgid ":mod:`!collections` --- Container datatypes"
msgstr ":mod:`!collections` --- コンテナデータ型"

#: ../../library/collections.rst:10
msgid "**Source code:** :source:`Lib/collections/__init__.py`"
msgstr "**ソースコード:** :source:`Lib/collections/__init__.py`"

#: ../../library/collections.rst:20
msgid ""
"This module implements specialized container datatypes providing "
"alternatives to Python's general purpose built-in containers, :class:"
"`dict`, :class:`list`, :class:`set`, and :class:`tuple`."
msgstr ""
"このモジュールは、汎用の Python 組み込みコンテナ :class:`dict`, :class:"
"`list`, :class:`set`, および :class:`tuple` に代わる、特殊なコンテナデータ型"
"を実装しています。"

#: ../../library/collections.rst:25
msgid ":func:`namedtuple`"
msgstr ":func:`namedtuple`"

#: ../../library/collections.rst:25
msgid "factory function for creating tuple subclasses with named fields"
msgstr "名前付きフィールドを持つタプルのサブクラスを作成するファクトリ関数"

#: ../../library/collections.rst:26
msgid ":class:`deque`"
msgstr ":class:`deque`"

#: ../../library/collections.rst:26
msgid "list-like container with fast appends and pops on either end"
msgstr "両端における append や pop を高速に行えるリスト風のコンテナ"

#: ../../library/collections.rst:27
msgid ":class:`ChainMap`"
msgstr ":class:`ChainMap`"

#: ../../library/collections.rst:27
msgid "dict-like class for creating a single view of multiple mappings"
msgstr "複数のマッピングの一つのビューを作成する辞書風のクラス"

#: ../../library/collections.rst:28
msgid ":class:`Counter`"
msgstr ":class:`Counter`"

#: ../../library/collections.rst:28
msgid "dict subclass for counting :term:`hashable` objects"
msgstr ""
":term:`ハッシュ可能 <hashable>` なオブジェクトを数え上げる辞書のサブクラス"

#: ../../library/collections.rst:29
msgid ":class:`OrderedDict`"
msgstr ":class:`OrderedDict`"

#: ../../library/collections.rst:29
msgid "dict subclass that remembers the order entries were added"
msgstr "項目が追加された順序を記憶する辞書のサブクラス"

#: ../../library/collections.rst:30
msgid ":class:`defaultdict`"
msgstr ":class:`defaultdict`"

#: ../../library/collections.rst:30
msgid "dict subclass that calls a factory function to supply missing values"
msgstr "ファクトリ関数を呼び出して存在しない値を供給する辞書のサブクラス"

#: ../../library/collections.rst:31
msgid ":class:`UserDict`"
msgstr ":class:`UserDict`"

#: ../../library/collections.rst:31
msgid "wrapper around dictionary objects for easier dict subclassing"
msgstr "辞書のサブクラス化を簡単にする辞書オブジェクトのラッパ"

#: ../../library/collections.rst:32
msgid ":class:`UserList`"
msgstr ":class:`UserList`"

#: ../../library/collections.rst:32
msgid "wrapper around list objects for easier list subclassing"
msgstr "リストのサブクラス化を簡単にするリストオブジェクトのラッパ"

#: ../../library/collections.rst:33
msgid ":class:`UserString`"
msgstr ":class:`UserString`"

#: ../../library/collections.rst:33
msgid "wrapper around string objects for easier string subclassing"
msgstr "文字列のサブクラス化を簡単にする文字列オブジェクトのラッパ"

#: ../../library/collections.rst:38
msgid ":class:`ChainMap` objects"
msgstr ":class:`ChainMap` オブジェクト"

#: ../../library/collections.rst:42
msgid ""
"A :class:`ChainMap` class is provided for quickly linking a number of "
"mappings so they can be treated as a single unit.  It is often much faster "
"than creating a new dictionary and running multiple :meth:`~dict.update` "
"calls."
msgstr ""
":class:`ChainMap` クラスは、複数のマッピングを素早く連結し、一つの単位として"
"扱うために提供されています。これはたいてい、新しい辞書を作成して :meth:"
"`~dict.update` を繰り返すよりも早いです。"

#: ../../library/collections.rst:46
msgid ""
"The class can be used to simulate nested scopes and is useful in templating."
msgstr ""
"このクラスはネストされたスコープをシミュレートするのに使え、テンプレート化に"
"便利です。"

#: ../../library/collections.rst:50
msgid ""
"A :class:`ChainMap` groups multiple dicts or other mappings together to "
"create a single, updateable view.  If no *maps* are specified, a single "
"empty dictionary is provided so that a new chain always has at least one "
"mapping."
msgstr ""
":class:`ChainMap` は、複数の辞書やその他のマッピングをまとめて、一つの、更新"
"可能なビューを作成します。 *maps* が指定されないなら、一つの空辞書が与えられ"
"ますから、新しいチェーンは必ず一つ以上のマッピングをもちます。"

#: ../../library/collections.rst:54
msgid ""
"The underlying mappings are stored in a list.  That list is public and can "
"be accessed or updated using the *maps* attribute.  There is no other state."
msgstr ""
"根底のマッピングはリストに保存されます。このリストはパブリックで、 *maps* 属"
"性を使ってアクセスや更新できます。それ以外に状態はありません。"

#: ../../library/collections.rst:57
msgid ""
"Lookups search the underlying mappings successively until a key is found.  "
"In contrast, writes, updates, and deletions only operate on the first "
"mapping."
msgstr ""
"探索は、根底のマッピングをキーが見つかるまで引き続き探します。対して、書き込"
"み、更新、削除は、最初のマッピングのみ操作します。"

#: ../../library/collections.rst:60
msgid ""
"A :class:`ChainMap` incorporates the underlying mappings by reference.  So, "
"if one of the underlying mappings gets updated, those changes will be "
"reflected in :class:`ChainMap`."
msgstr ""
":class:`ChainMap` は、根底のマッピングを参照によって組み込みます。ですから、"
"根底のマッピングの一つが更新されると、その変更は :class:`ChainMap` に反映され"
"ます。"

#: ../../library/collections.rst:64
msgid ""
"All of the usual dictionary methods are supported.  In addition, there is a "
"*maps* attribute, a method for creating new subcontexts, and a property for "
"accessing all but the first mapping:"
msgstr ""
"通常の辞書のメソッドすべてがサポートされています。さらに、*maps* 属性、新しい"
"サブコンテキストを作成するメソッド、最初のマッピング以外のすべてにアクセスす"
"るためのプロパティがあります:"

#: ../../library/collections.rst:70
msgid ""
"A user updateable list of mappings.  The list is ordered from first-searched "
"to last-searched.  It is the only stored state and can be modified to change "
"which mappings are searched.  The list should always contain at least one "
"mapping."
msgstr ""
"マッピングのユーザがアップデートできるリストです。このリストは最初に探される"
"ものから最後に探されるものの順に並んでいます。これが唯一のソートされた状態で"
"あり、変更してマッピングが探される順番を変更できます。このリストは常に一つ以"
"上のマッピングを含んでいなければなりません。"

#: ../../library/collections.rst:77
msgid ""
"Returns a new :class:`ChainMap` containing a new map followed by all of the "
"maps in the current instance.  If ``m`` is specified, it becomes the new map "
"at the front of the list of mappings; if not specified, an empty dict is "
"used, so that a call to ``d.new_child()`` is equivalent to: ``ChainMap({}, "
"*d.maps)``. If any keyword arguments are specified, they update passed map "
"or new empty dict. This method is used for creating subcontexts that can be "
"updated without altering values in any of the parent mappings."
msgstr ""
"新しいマッピングに現在のインスタンスが持つ全てのマッピングを追加したものを持"
"つ新しい :class:`ChainMap` インスタンスを返します。 ``m`` が指定された場合、"
"新しいマッピングのリストの先頭部分になります; 指定されない場合は空の辞書が使"
"われます。すなわち ``d.new_child()`` は ``ChainMap({}, *d.maps)`` と等価にな"
"ります。キーワード引数が指定された場合、それらによって指定されたマッピングま"
"たは空の辞書が更新されます。このメソッドは、元のマッピングに変更を加えること"
"なく値を更新できるサブコンテキストを生成するのに使われます。"

#: ../../library/collections.rst:86
msgid "The optional ``m`` parameter was added."
msgstr "オプションの ``m`` 引数が追加されました。"

#: ../../library/collections.rst:89
msgid "Keyword arguments support was added."
msgstr "キーワード引数のサポートが追加されました。"

#: ../../library/collections.rst:94
msgid ""
"Property returning a new :class:`ChainMap` containing all of the maps in the "
"current instance except the first one.  This is useful for skipping the "
"first map in the search.  Use cases are similar to those for the :keyword:"
"`nonlocal` keyword used in :term:`nested scopes <nested scope>`.  The use "
"cases also parallel those for the built-in :func:`super` function.  A "
"reference to ``d.parents`` is equivalent to: ``ChainMap(*d.maps[1:])``."
msgstr ""
"現在のインスタンスの最初のマッピング以外のすべてのマッピングを含む新しい :"
"class:`ChainMap` を返すプロパティです。これは最初のマッピングを検索から飛ばす"
"のに便利です。使用例は :keyword:`nonlocal` キーワードを :term:`ネストされたス"
"コープ <nested scope>` に使う例と似ています。この使用例はまた、組み込み :"
"func:`super` 関数にも似ています。 ``d.parents`` への参照は ``ChainMap(*d."
"maps[1:])`` と等価です。"

#: ../../library/collections.rst:102
msgid ""
"Note, the iteration order of a :class:`ChainMap` is determined by scanning "
"the mappings last to first::"
msgstr ""
":class:`ChainMap` の反復順序は、マッピングを最後から最初へスキャンして決定さ"
"れることに注意してください。"

#: ../../library/collections.rst:105
msgid ""
">>> baseline = {'music': 'bach', 'art': 'rembrandt'}\n"
">>> adjustments = {'art': 'van gogh', 'opera': 'carmen'}\n"
">>> list(ChainMap(adjustments, baseline))\n"
"['music', 'art', 'opera']"
msgstr ""

#: ../../library/collections.rst:110
msgid ""
"This gives the same ordering as a series of :meth:`dict.update` calls "
"starting with the last mapping::"
msgstr ""
"これは、末尾のマッピングオブジェクトから始めた一連の :meth:`dict.update` の呼"
"び出しと同じ順序になります。"

#: ../../library/collections.rst:113
msgid ""
">>> combined = baseline.copy()\n"
">>> combined.update(adjustments)\n"
">>> list(combined)\n"
"['music', 'art', 'opera']"
msgstr ""

#: ../../library/collections.rst:118
msgid "Added support for ``|`` and ``|=`` operators, specified in :pep:`584`."
msgstr ""
":pep:`584` で規定されている ``|`` 演算子と ``|=`` 演算子のサポートを追加しま"
"した。"

#: ../../library/collections.rst:123
msgid ""
"The `MultiContext class <https://github.com/enthought/codetools/blob/4.0.0/"
"codetools/contexts/multi_context.py>`_ in the Enthought `CodeTools package "
"<https://github.com/enthought/codetools>`_ has options to support writing to "
"any mapping in the chain."
msgstr ""
"Enthought 社の `CodeTools パッケージ <https://github.com/enthought/"
"codetools>`_ に含まれる `MultiContext クラス <https://github.com/enthought/"
"codetools/blob/4.0.0/codetools/contexts/multi_context.py>`_ は、チェーン内の"
"すべてのマッピングへの書き込みをサポートするオプションを持ちます。"

#: ../../library/collections.rst:129
msgid ""
"Django's `Context class <https://github.com/django/django/blob/main/django/"
"template/context.py>`_ for templating is a read-only chain of mappings.  It "
"also features pushing and popping of contexts similar to the :meth:"
"`~collections.ChainMap.new_child` method and the :attr:`~collections."
"ChainMap.parents` property."
msgstr ""
"Django のテンプレート用の `Context class <https://github.com/django/django/"
"blob/main/django/template/context.py>`_ は、読み出し専用のマッピングのチェー"
"ンです。 :meth:`~collections.ChainMap.new_child` メソッドや :attr:"
"`~collections.ChainMap.parents` プロパティに似た push や pop の機能もありま"
"す。"

#: ../../library/collections.rst:136
msgid ""
"The `Nested Contexts recipe <https://code.activestate.com/recipes/577434-"
"nested-contexts-a-chain-of-mapping-objects/>`_ has options to control "
"whether writes and other mutations apply only to the first mapping or to any "
"mapping in the chain."
msgstr ""
"`Nested Contexts recipe <https://code.activestate.com/recipes/577434-nested-"
"contexts-a-chain-of-mapping-objects/>`_ は、書き込み・その他の変更が最初の"
"マッピングにのみ適用されるか、チェーンのすべてのマッピングに適用されるか、制"
"御するオプションを持ちます。"

#: ../../library/collections.rst:141
msgid ""
"A `greatly simplified read-only version of Chainmap <https://code."
"activestate.com/recipes/305268/>`_."
msgstr ""
"`非常に単純化した読み出し専用バージョンの Chainmap <https://code.activestate."
"com/recipes/305268/>`_。"

#: ../../library/collections.rst:146
msgid ":class:`ChainMap` Examples and Recipes"
msgstr ":class:`ChainMap` の例とレシピ"

#: ../../library/collections.rst:148
msgid "This section shows various approaches to working with chained maps."
msgstr "この節では、チェーンされたマッピングを扱う様々な手法を示します。"

#: ../../library/collections.rst:151
msgid "Example of simulating Python's internal lookup chain::"
msgstr "Python の内部探索チェーンをシミュレートする例::"

#: ../../library/collections.rst:153
msgid ""
"import builtins\n"
"pylookup = ChainMap(locals(), globals(), vars(builtins))"
msgstr ""

#: ../../library/collections.rst:156
msgid ""
"Example of letting user specified command-line arguments take precedence "
"over environment variables which in turn take precedence over default "
"values::"
msgstr ""
"ユーザ指定のコマンドライン引数、環境変数、デフォルト値、の順に優先させる例::"

#: ../../library/collections.rst:159
msgid ""
"import os, argparse\n"
"\n"
"defaults = {'color': 'red', 'user': 'guest'}\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('-u', '--user')\n"
"parser.add_argument('-c', '--color')\n"
"namespace = parser.parse_args()\n"
"command_line_args = {k: v for k, v in vars(namespace).items() if v is not "
"None}\n"
"\n"
"combined = ChainMap(command_line_args, os.environ, defaults)\n"
"print(combined['color'])\n"
"print(combined['user'])"
msgstr ""

#: ../../library/collections.rst:173
msgid ""
"Example patterns for using the :class:`ChainMap` class to simulate nested "
"contexts::"
msgstr ""
":class:`ChainMap` を使ってネストされたコンテキストをシミュレートするパターン"
"の例::"

#: ../../library/collections.rst:176
msgid ""
"c = ChainMap()        # Create root context\n"
"d = c.new_child()     # Create nested child context\n"
"e = c.new_child()     # Child of c, independent from d\n"
"e.maps[0]             # Current context dictionary -- like Python's "
"locals()\n"
"e.maps[-1]            # Root context -- like Python's globals()\n"
"e.parents             # Enclosing context chain -- like Python's nonlocals\n"
"\n"
"d['x'] = 1            # Set value in current context\n"
"d['x']                # Get first key in the chain of contexts\n"
"del d['x']            # Delete from current context\n"
"list(d)               # All nested values\n"
"k in d                # Check all nested values\n"
"len(d)                # Number of nested values\n"
"d.items()             # All nested items\n"
"dict(d)               # Flatten into a regular dictionary"
msgstr ""

#: ../../library/collections.rst:192
msgid ""
"The :class:`ChainMap` class only makes updates (writes and deletions) to the "
"first mapping in the chain while lookups will search the full chain.  "
"However, if deep writes and deletions are desired, it is easy to make a "
"subclass that updates keys found deeper in the chain::"
msgstr ""
":class:`ChainMap` クラスは、探索はチェーン全体に対して行いますが、更新 (書き"
"込みと削除) は最初のマッピングに対してのみ行います。しかし、深い書き込みと削"
"除を望むなら、チェーンの深いところで見つかったキーを更新するサブクラスを簡単"
"に作れます::"

#: ../../library/collections.rst:197
msgid ""
"class DeepChainMap(ChainMap):\n"
"    'Variant of ChainMap that allows direct updates to inner scopes'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                mapping[key] = value\n"
"                return\n"
"        self.maps[0][key] = value\n"
"\n"
"    def __delitem__(self, key):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                del mapping[key]\n"
"                return\n"
"        raise KeyError(key)\n"
"\n"
">>> d = DeepChainMap({'zebra': 'black'}, {'elephant': 'blue'}, {'lion': "
"'yellow'})\n"
">>> d['lion'] = 'orange'         # update an existing key two levels down\n"
">>> d['snake'] = 'red'           # new keys get added to the topmost dict\n"
">>> del d['elephant']            # remove an existing key one level down\n"
">>> d                            # display result\n"
"DeepChainMap({'zebra': 'black', 'snake': 'red'}, {}, {'lion': 'orange'})"
msgstr ""

#: ../../library/collections.rst:223
msgid ":class:`Counter` objects"
msgstr ":class:`Counter` オブジェクト"

#: ../../library/collections.rst:225
msgid ""
"A counter tool is provided to support convenient and rapid tallies. For "
"example::"
msgstr ""
"便利で迅速な検数をサポートするカウンタツールが提供されています。例えば::"

#: ../../library/collections.rst:228
msgid ""
">>> # Tally occurrences of words in a list\n"
">>> cnt = Counter()\n"
">>> for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']:\n"
"...     cnt[word] += 1\n"
"...\n"
">>> cnt\n"
"Counter({'blue': 3, 'red': 2, 'green': 1})\n"
"\n"
">>> # Find the ten most common words in Hamlet\n"
">>> import re\n"
">>> words = re.findall(r'\\w+', open('hamlet.txt').read().lower())\n"
">>> Counter(words).most_common(10)\n"
"[('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),\n"
" ('you', 554),  ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)]"
msgstr ""

#: ../../library/collections.rst:245
msgid ""
"A :class:`Counter` is a :class:`dict` subclass for counting :term:`hashable` "
"objects. It is a collection where elements are stored as dictionary keys and "
"their counts are stored as dictionary values.  Counts are allowed to be any "
"integer value including zero or negative counts.  The :class:`Counter` class "
"is similar to bags or multisets in other languages."
msgstr ""
":class:`Counter` は :term:`ハッシュ可能 <hashable>` なオブジェクトをカウント"
"する :class:`dict` のサブクラスです。これは、要素を辞書のキーとして保存し、そ"
"のカウントを辞書の値として保存するコレクションです。カウントは、0 や負のカウ"
"ントを含む整数値をとれます。 :class:`Counter` クラスは、他の言語のバッグや多"
"重集合のようなものです。"

#: ../../library/collections.rst:251
msgid ""
"Elements are counted from an *iterable* or initialized from another "
"*mapping* (or counter):"
msgstr ""
"要素は、 *iterable* から数え上げられたり、他の *mapping* (やカウンタ) から初"
"期化されます:"

#: ../../library/collections.rst:259
msgid ""
"Counter objects have a dictionary interface except that they return a zero "
"count for missing items instead of raising a :exc:`KeyError`:"
msgstr ""
"カウンタオブジェクトは辞書のインターフェースを持ちますが、存在しない要素に対"
"して :exc:`KeyError` を送出する代わりに 0 を返すという違いがあります:"

#: ../../library/collections.rst:266
msgid ""
"Setting a count to zero does not remove an element from a counter. Use "
"``del`` to remove it entirely:"
msgstr ""
"カウントを 0 に設定しても、要素はカウンタから取り除かれません。完全に取り除く"
"には、 ``del`` を使ってください:"

#: ../../library/collections.rst:274
msgid ""
"As a :class:`dict` subclass, :class:`Counter` inherited the capability to "
"remember insertion order.  Math operations on *Counter* objects also "
"preserve order.  Results are ordered according to when an element is first "
"encountered in the left operand and then by the order encountered in the "
"right operand."
msgstr ""
":class:`Counter` は :class:`dict` のサブクラスとして要素の挿入順を維持する機"
"能を継承しました。 *Counter* オブジェクトに対する数学演算も順序を維持します。"
"結果の順序はまず左の被演算子における要素の出現順に従い、その後右の被演算子に"
"おいて要素が出現する順序になります。"

#: ../../library/collections.rst:280
msgid ""
"Counter objects support additional methods beyond those available for all "
"dictionaries:"
msgstr ""
"カウンタオブジェクトは全ての辞書で利用できるメソッドに加えて、以下に示す追加"
"のメソッドをサポートしています。"

#: ../../library/collections.rst:285
msgid ""
"Return an iterator over elements repeating each as many times as its count.  "
"Elements are returned in the order first encountered. If an element's count "
"is less than one, :meth:`elements` will ignore it."
msgstr ""
"それぞれの要素を、そのカウント分の回数だけ繰り返すイテレータを返します。要素"
"は挿入した順番で返されます。ある要素のカウントが 1 未満なら、 :meth:"
"`elements` はそれを無視します。"

#: ../../library/collections.rst:295
msgid ""
"Return a list of the *n* most common elements and their counts from the most "
"common to the least.  If *n* is omitted or ``None``, :meth:`most_common` "
"returns *all* elements in the counter. Elements with equal counts are "
"ordered in the order first encountered:"
msgstr ""
"最も多い *n* 要素を、カウントが多いものから少ないものまで順に並べたリストを返"
"します。 *n* が省略されるか ``None`` であれば、 :meth:`most_common` はカウン"
"タの *すべての* 要素を返します。等しいカウントの要素は挿入順に並べられます:"

#: ../../library/collections.rst:305
msgid ""
"Elements are subtracted from an *iterable* or from another *mapping* (or "
"counter).  Like :meth:`dict.update` but subtracts counts instead of "
"replacing them.  Both inputs and outputs may be zero or negative."
msgstr ""
"要素から *iterable* の要素または *mapping* の要素が引かれます。 :meth:`dict."
"update` に似ていますが、カウントを置き換えるのではなく引きます。入力も出力"
"も、 0 や負になりえます。"

#: ../../library/collections.rst:319
msgid "Compute the sum of the counts."
msgstr "カウントの合計を計算します。"

#: ../../library/collections.rst:327
msgid ""
"The usual dictionary methods are available for :class:`Counter` objects "
"except for two which work differently for counters."
msgstr ""
"普通の辞書のメソッドは、以下の 2 つのメソッドがカウンタに対して異なる振る舞い"
"をするのを除き、 :class:`Counter` オブジェクトにも利用できます。"

#: ../../library/collections.rst:332
msgid "This class method is not implemented for :class:`Counter` objects."
msgstr ""
"このクラスメソッドは :class:`Counter` オブジェクトには実装されていません。"

#: ../../library/collections.rst:336
msgid ""
"Elements are counted from an *iterable* or added-in from another *mapping* "
"(or counter).  Like :meth:`dict.update` but adds counts instead of replacing "
"them.  Also, the *iterable* is expected to be a sequence of elements, not a "
"sequence of ``(key, value)`` pairs."
msgstr ""
"要素が *iterable* からカウントされるか、別の *mapping* (やカウンタ) が追加さ"
"れます。 :meth:`dict.update` に似ていますが、カウントを置き換えるのではなく追"
"加します。また、 *iterable* には ``(key, value)`` 対のシーケンスではなく、要"
"素のシーケンスが求められます。"

#: ../../library/collections.rst:341
msgid ""
"Counters support rich comparison operators for equality, subset, and "
"superset relationships: ``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``. All of "
"those tests treat missing elements as having zero counts so that "
"``Counter(a=1) == Counter(a=1, b=0)`` returns true."
msgstr ""
"カウンタオブジェクトは等価、部分集合、上位集合のための次の拡張比較 (rich "
"comparison) 演算子をサポートします: ``==``, ``!=``, ``<``, ``<=``, ``>``, "
"``>=``。これらの比較は、存在しない要素をカウントがゼロであるとみなします。す"
"なわち、 ``Counter(a=1) == Counter(a=1, b=0)`` は真を返します。"

#: ../../library/collections.rst:346
msgid "Rich comparison operations were added."
msgstr "拡張比較 (rich comparison) 演算が追加されました。"

#: ../../library/collections.rst:349
msgid ""
"In equality tests, missing elements are treated as having zero counts. "
"Formerly, ``Counter(a=3)`` and ``Counter(a=3, b=0)`` were considered "
"distinct."
msgstr ""
"等価比較において、存在しない要素はカウントがゼロであるとみなされるようになり"
"ました。かつては ``Counter(a=3)`` と ``Counter(a=3, b=0)`` は異なるとみなされ"
"ていました。"

#: ../../library/collections.rst:354
msgid "Common patterns for working with :class:`Counter` objects::"
msgstr ":class:`Counter` オブジェクトを使ったよくあるパターン::"

#: ../../library/collections.rst:356
msgid ""
"c.total()                       # total of all counts\n"
"c.clear()                       # reset all counts\n"
"list(c)                         # list unique elements\n"
"set(c)                          # convert to a set\n"
"dict(c)                         # convert to a regular dictionary\n"
"c.items()                       # access the (elem, cnt) pairs\n"
"Counter(dict(list_of_pairs))    # convert from a list of (elem, cnt) pairs\n"
"c.most_common()[:-n-1:-1]       # n least common elements\n"
"+c                              # remove zero and negative counts"
msgstr ""

#: ../../library/collections.rst:366
msgid ""
"Several mathematical operations are provided for combining :class:`Counter` "
"objects to produce multisets (counters that have counts greater than zero). "
"Addition and subtraction combine counters by adding or subtracting the "
"counts of corresponding elements.  Intersection and union return the minimum "
"and maximum of corresponding counts.  Equality and inclusion compare "
"corresponding counts.  Each operation can accept inputs with signed counts, "
"but the output will exclude results with counts of zero or less."
msgstr ""
":class:`Counter` オブジェクトを組み合わせて多重集合 (0より大きいカウントを持"
"つカウンタ) を作るためのいくつかの数学演算が提供されています。加算と減算はそ"
"れぞれの要素のカウンタを加算または減算することによりカウンタオブジェクトを組"
"み合わせます。積集合と和集合は、それぞれのカウントの最大値と最小値を返しま"
"す。等価と包含はそれぞれのカウントを比較します。それぞれの演算は符号付きカウ"
"ントを持った入力を受け付けますが、カウントが0以下の要素は結果から取り除かれま"
"す。"

#: ../../library/collections.rst:374
msgid ""
">>> c = Counter(a=3, b=1)\n"
">>> d = Counter(a=1, b=2)\n"
">>> c + d                       # add two counters together:  c[x] + d[x]\n"
"Counter({'a': 4, 'b': 3})\n"
">>> c - d                       # subtract (keeping only positive counts)\n"
"Counter({'a': 2})\n"
">>> c & d                       # intersection:  min(c[x], d[x])\n"
"Counter({'a': 1, 'b': 1})\n"
">>> c | d                       # union:  max(c[x], d[x])\n"
"Counter({'a': 3, 'b': 2})\n"
">>> c == d                      # equality:  c[x] == d[x]\n"
"False\n"
">>> c <= d                      # inclusion:  c[x] <= d[x]\n"
"False"
msgstr ""

#: ../../library/collections.rst:391
msgid ""
"Unary addition and subtraction are shortcuts for adding an empty counter or "
"subtracting from an empty counter."
msgstr ""
"単項加算および減算は、空カウンタの加算や空カウンタからの減算へのショートカッ"
"トです。"

#: ../../library/collections.rst:400
msgid ""
"Added support for unary plus, unary minus, and in-place multiset operations."
msgstr ""
"単項加算、単項減算、in-place の多重集合操作のサポートが追加されました。"

#: ../../library/collections.rst:405
msgid ""
"Counters were primarily designed to work with positive integers to represent "
"running counts; however, care was taken to not unnecessarily preclude use "
"cases needing other types or negative values.  To help with those use cases, "
"this section documents the minimum range and type restrictions."
msgstr ""
"カウンタはもともと、推移するカウントを正の整数で表すために設計されました。し"
"かし、他の型や負の値を必要とするユースケースを不必要に排除することがないよう"
"に配慮されています。このようなユースケースの助けになるように、この節で最低限"
"の範囲と型の制限について記述します。"

#: ../../library/collections.rst:410
msgid ""
"The :class:`Counter` class itself is a dictionary subclass with no "
"restrictions on its keys and values.  The values are intended to be numbers "
"representing counts, but you *could* store anything in the value field."
msgstr ""
":class:`Counter` クラス自体は辞書のサブクラスで、キーと値に制限はありません。"
"値はカウントを表す数であることを意図していますが、値フィールドに任意のものを"
"保存 *できます* 。"

#: ../../library/collections.rst:414
msgid ""
"The :meth:`~Counter.most_common` method requires only that the values be "
"orderable."
msgstr ""
":meth:`~Counter.most_common` メソッドが要求するのは、値が順序付け可能なことだ"
"けです。"

#: ../../library/collections.rst:416
msgid ""
"For in-place operations such as ``c[key] += 1``, the value type need only "
"support addition and subtraction.  So fractions, floats, and decimals would "
"work and negative values are supported.  The same is also true for :meth:"
"`~Counter.update` and :meth:`~Counter.subtract` which allow negative and "
"zero values for both inputs and outputs."
msgstr ""
"``c[key] += 1`` のようなインプレース演算では、値の型に必要なのは 足し算と引き"
"算ができることだけです。よって分数、浮動小数点数、 小数も使え、負の値がサポー"
"トされています。これと同じことが、 負や 0 の値を入力と出力に許す :meth:"
"`~Counter.update` と :meth:`~Counter.subtract` メソッド にも言えます。"

#: ../../library/collections.rst:422
msgid ""
"The multiset methods are designed only for use cases with positive values. "
"The inputs may be negative or zero, but only outputs with positive values "
"are created.  There are no type restrictions, but the value type needs to "
"support addition, subtraction, and comparison."
msgstr ""
"多重集合メソッドは正の値を扱うユースケースに対してのみ設計されています。入力"
"は負や 0 に出来ますが、正の値の出力のみが生成されます。型の制限はありません"
"が、値の型は足し算、引き算、比較をサポートしている必要があります。"

#: ../../library/collections.rst:427
msgid ""
"The :meth:`~Counter.elements` method requires integer counts.  It ignores "
"zero and negative counts."
msgstr ""
":meth:`~Counter.elements` メソッドは整数のカウントを要求します。これは 0 と負"
"のカウントを無視します。"

#: ../../library/collections.rst:432
msgid ""
"`Bag class <https://www.gnu.org/software/smalltalk/manual-base/html_node/Bag."
"html>`_ in Smalltalk."
msgstr ""
"Smalltalk の `Bag class <https://www.gnu.org/software/smalltalk/manual-base/"
"html_node/Bag.html>`_ 。"

#: ../../library/collections.rst:435
msgid ""
"Wikipedia entry for `Multisets <https://en.wikipedia.org/wiki/Multiset>`_."
msgstr ""
"Wikipedia の `Multisets <https://en.wikipedia.org/wiki/Multiset>`_ の項目。"

#: ../../library/collections.rst:437
msgid ""
"`C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-multiset/"
"Catalog0380__set-multiset.htm>`_ tutorial with examples."
msgstr ""
"`C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-multiset/"
"Catalog0380__set-multiset.htm>`_ の例を交えたチュートリアル。"

#: ../../library/collections.rst:440
msgid ""
"For mathematical operations on multisets and their use cases, see *Knuth, "
"Donald. The Art of Computer Programming Volume II, Section 4.6.3, Exercise "
"19*."
msgstr ""
"数学的な多重集合の演算とそのユースケースは、 *Knuth, Donald. The Art of "
"Computer Programming Volume II, Section 4.6.3, Exercise 19* を参照してくださ"
"い。"

#: ../../library/collections.rst:444
msgid ""
"To enumerate all distinct multisets of a given size over a given set of "
"elements, see :func:`itertools.combinations_with_replacement`::"
msgstr ""
"与えられた要素の集まりからなる与えられた大きさの相違なる多重集合をすべて数え"
"上げるには、 :func:`itertools.combinations_with_replacement` を参照してくださ"
"い::"

#: ../../library/collections.rst:447
msgid ""
"map(Counter, combinations_with_replacement('ABC', 2)) # --> AA AB AC BB BC CC"
msgstr ""

#: ../../library/collections.rst:451
msgid ":class:`deque` objects"
msgstr ":class:`deque` オブジェクト"

#: ../../library/collections.rst:455
msgid ""
"Returns a new deque object initialized left-to-right (using :meth:`append`) "
"with data from *iterable*.  If *iterable* is not specified, the new deque is "
"empty."
msgstr ""
"*iterable* で与えられるデータから、新しい deque オブジェクトを (:meth:"
"`append` をつかって) 左から右に初期化して返します。 *iterable* が指定されない"
"場合、新しい deque オブジェクトは空になります。"

#: ../../library/collections.rst:458
msgid ""
"Deques are a generalization of stacks and queues (the name is pronounced "
"\"deck\" and is short for \"double-ended queue\").  Deques support thread-"
"safe, memory efficient appends and pops from either side of the deque with "
"approximately the same *O*\\ (1) performance in either direction."
msgstr ""
"Deque とは、スタックとキューを一般化したものです (この名前は「デック」と発音"
"され、これは「double-ended queue」の省略形です)。Deque はどちらの側からも "
"append と pop が可能で、スレッドセーフでメモリ効率がよく、どちらの方向からも"
"およそ *O*\\ (1) のパフォーマンスで実行できます。"

#: ../../library/collections.rst:463
msgid ""
"Though :class:`list` objects support similar operations, they are optimized "
"for fast fixed-length operations and incur *O*\\ (*n*) memory movement costs "
"for ``pop(0)`` and ``insert(0, v)`` operations which change both the size "
"and position of the underlying data representation."
msgstr ""
":class:`list` オブジェクトでも同様の操作を実現できますが、これは高速な固定長"
"の操作に特化されており、基礎のデータ表現形式のサイズと位置を両方変えるような "
"``pop(0)`` や ``insert(0, v)`` などの操作ではメモリ移動のために *O*\\ (*n*) "
"のコストを必要とします。"

#: ../../library/collections.rst:469
msgid ""
"If *maxlen* is not specified or is ``None``, deques may grow to an arbitrary "
"length.  Otherwise, the deque is bounded to the specified maximum length.  "
"Once a bounded length deque is full, when new items are added, a "
"corresponding number of items are discarded from the opposite end.  Bounded "
"length deques provide functionality similar to the ``tail`` filter in Unix. "
"They are also useful for tracking transactions and other pools of data where "
"only the most recent activity is of interest."
msgstr ""
"*maxlen* が指定されなかったり ``None`` だった場合、 deque は任意のサイズまで"
"大きくなります。\n"
"そうでない場合、 deque のサイズは指定された最大長に制限されます。\n"
"長さが制限された deque がいっぱいになると、新しい要素を追加するときに追加した"
"要素数分だけ追加したのと反対側から要素が捨てられます。\n"
"長さが制限された deque は Unix における ``tail`` フィルタと似た機能を提供しま"
"す。\n"
"トランザクションの tracking や最近使った要素だけを残したいデータプール (pool "
"of data) などにも便利です。"

#: ../../library/collections.rst:478
msgid "Deque objects support the following methods:"
msgstr "Deque オブジェクトは以下のようなメソッドをサポートしています:"

#: ../../library/collections.rst:482
msgid "Add *x* to the right side of the deque."
msgstr "*x* を deque の右側につけ加えます。"

#: ../../library/collections.rst:487
msgid "Add *x* to the left side of the deque."
msgstr "*x* を deque の左側につけ加えます。"

#: ../../library/collections.rst:492
msgid "Remove all elements from the deque leaving it with length 0."
msgstr "deque からすべての要素を削除し、長さを 0 にします。"

#: ../../library/collections.rst:497
msgid "Create a shallow copy of the deque."
msgstr "deque の浅いコピーを作成します。"

#: ../../library/collections.rst:504
msgid "Count the number of deque elements equal to *x*."
msgstr "deque の *x* に等しい要素を数え上げます。"

#: ../../library/collections.rst:511
msgid ""
"Extend the right side of the deque by appending elements from the iterable "
"argument."
msgstr ""
"イテラブルな引数 iterable から得られる要素を deque の右側に追加し拡張します。"

#: ../../library/collections.rst:517
msgid ""
"Extend the left side of the deque by appending elements from *iterable*. "
"Note, the series of left appends results in reversing the order of elements "
"in the iterable argument."
msgstr ""
"イテラブルな引数 iterable から得られる要素を deque の左側に追加し拡張します。"
"注意: 左から追加した結果は、イテラブルな引数の順序とは逆になります。"

#: ../../library/collections.rst:524
msgid ""
"Return the position of *x* in the deque (at or after index *start* and "
"before index *stop*).  Returns the first match or raises :exc:`ValueError` "
"if not found."
msgstr ""
"deque 内の *x* の位置を返します (インデックス *start* からインデックス "
"*stop* の両端を含む範囲で)。最初のマッチを返すか、見つからない場合には :exc:"
"`ValueError` を発生させます。"

#: ../../library/collections.rst:533
msgid "Insert *x* into the deque at position *i*."
msgstr "*x* を deque の位置 *i* に挿入します。"

#: ../../library/collections.rst:535
msgid ""
"If the insertion would cause a bounded deque to grow beyond *maxlen*, an :"
"exc:`IndexError` is raised."
msgstr ""
"挿入によって、長さに制限のある deque の長さが *maxlen* を超える場合、:exc:"
"`IndexError` が発生します。"

#: ../../library/collections.rst:543
msgid ""
"Remove and return an element from the right side of the deque. If no "
"elements are present, raises an :exc:`IndexError`."
msgstr ""
"deque の右側から要素をひとつ削除し、その要素を返します。要素がひとつも存在し"
"ない場合は :exc:`IndexError` を発生させます。"

#: ../../library/collections.rst:549
msgid ""
"Remove and return an element from the left side of the deque. If no elements "
"are present, raises an :exc:`IndexError`."
msgstr ""
"deque の左側から要素をひとつ削除し、その要素を返します。要素がひとつも存在し"
"ない場合は :exc:`IndexError` を発生させます。"

#: ../../library/collections.rst:555
msgid ""
"Remove the first occurrence of *value*.  If not found, raises a :exc:"
"`ValueError`."
msgstr ""
"*value* の最初に現れるものを削除します。要素が見付からないない場合は :exc:"
"`ValueError` を送出します。"

#: ../../library/collections.rst:561
msgid "Reverse the elements of the deque in-place and then return ``None``."
msgstr "deque の要素をインプレースに反転し、``None`` を返します。"

#: ../../library/collections.rst:568
msgid ""
"Rotate the deque *n* steps to the right.  If *n* is negative, rotate to the "
"left."
msgstr ""
"deque の要素を全体で *n* ステップだけ右にローテートします。*n* が負の値の場合"
"は、左にローテートします。"

#: ../../library/collections.rst:571
msgid ""
"When the deque is not empty, rotating one step to the right is equivalent to "
"``d.appendleft(d.pop())``, and rotating one step to the left is equivalent "
"to ``d.append(d.popleft())``."
msgstr ""
"deque が空でないときは、 deque をひとつ右にローテートすることは ``d."
"appendleft(d.pop())`` と同じで、 deque をひとつ左にローテートすることは ``d."
"append(d.popleft())`` と同じです。"

#: ../../library/collections.rst:576
msgid "Deque objects also provide one read-only attribute:"
msgstr "deque オブジェクトは読み出し専用属性も 1 つ提供しています:"

#: ../../library/collections.rst:580
msgid "Maximum size of a deque or ``None`` if unbounded."
msgstr "deque の最大長で、制限されていなければ ``None`` です。"

#: ../../library/collections.rst:585
msgid ""
"In addition to the above, deques support iteration, pickling, ``len(d)``, "
"``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, membership testing "
"with the :keyword:`in` operator, and subscript references such as ``d[0]`` "
"to access the first element.  Indexed access is *O*\\ (1) at both ends but "
"slows to *O*\\ (*n*) in the middle.  For fast random access, use lists "
"instead."
msgstr ""
"上記に加え、 deque はイテレーション, pickle 化, ``len(d)``, ``reversed(d)``, "
"``copy.copy(d)``, ``copy.deepcopy(d)``, :keyword:`in` 演算子による包含の検"
"査,  ``d[0]`` のような添字による参照をサポートしています。添字によるアクセス"
"は、両端の要素では *O*\\ (1) ですが、中央部分の要素では *O*\\ (*n*) と遅くな"
"ります。高速なランダムアクセスのためには、代わりにリストを使ってください。"

#: ../../library/collections.rst:591
msgid ""
"Starting in version 3.5, deques support ``__add__()``, ``__mul__()``, and "
"``__imul__()``."
msgstr ""
"バージョン 3.5 から deque は ``__add__()``, ``__mul__()``, ``__imul__()`` を"
"サポートしました。"

#: ../../library/collections.rst:594
msgid "Example:"
msgstr "例:"

#: ../../library/collections.rst:596
msgid ""
">>> from collections import deque\n"
">>> d = deque('ghi')                 # make a new deque with three items\n"
">>> for elem in d:                   # iterate over the deque's elements\n"
"...     print(elem.upper())\n"
"G\n"
"H\n"
"I\n"
"\n"
">>> d.append('j')                    # add a new entry to the right side\n"
">>> d.appendleft('f')                # add a new entry to the left side\n"
">>> d                                # show the representation of the deque\n"
"deque(['f', 'g', 'h', 'i', 'j'])\n"
"\n"
">>> d.pop()                          # return and remove the rightmost item\n"
"'j'\n"
">>> d.popleft()                      # return and remove the leftmost item\n"
"'f'\n"
">>> list(d)                          # list the contents of the deque\n"
"['g', 'h', 'i']\n"
">>> d[0]                             # peek at leftmost item\n"
"'g'\n"
">>> d[-1]                            # peek at rightmost item\n"
"'i'\n"
"\n"
">>> list(reversed(d))                # list the contents of a deque in "
"reverse\n"
"['i', 'h', 'g']\n"
">>> 'h' in d                         # search the deque\n"
"True\n"
">>> d.extend('jkl')                  # add multiple elements at once\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
">>> d.rotate(1)                      # right rotation\n"
">>> d\n"
"deque(['l', 'g', 'h', 'i', 'j', 'k'])\n"
">>> d.rotate(-1)                     # left rotation\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
"\n"
">>> deque(reversed(d))               # make a new deque in reverse order\n"
"deque(['l', 'k', 'j', 'i', 'h', 'g'])\n"
">>> d.clear()                        # empty the deque\n"
">>> d.pop()                          # cannot pop from an empty deque\n"
"Traceback (most recent call last):\n"
"    File \"<pyshell#6>\", line 1, in -toplevel-\n"
"        d.pop()\n"
"IndexError: pop from an empty deque\n"
"\n"
">>> d.extendleft('abc')              # extendleft() reverses the input "
"order\n"
">>> d\n"
"deque(['c', 'b', 'a'])"
msgstr ""

#: ../../library/collections.rst:651
msgid ":class:`deque` Recipes"
msgstr ":class:`deque` のレシピ"

#: ../../library/collections.rst:653
msgid "This section shows various approaches to working with deques."
msgstr "この節では deque を使った様々なアプローチを紹介します。"

#: ../../library/collections.rst:655
msgid ""
"Bounded length deques provide functionality similar to the ``tail`` filter "
"in Unix::"
msgstr ""
"長さが制限された deque は Unix における ``tail`` フィルタに相当する機能を提供"
"します::"

#: ../../library/collections.rst:658
msgid ""
"def tail(filename, n=10):\n"
"    'Return the last n lines of a file'\n"
"    with open(filename) as f:\n"
"        return deque(f, n)"
msgstr ""

#: ../../library/collections.rst:663
msgid ""
"Another approach to using deques is to maintain a sequence of recently added "
"elements by appending to the right and popping to the left::"
msgstr ""
"deque  を使用する別のアプローチは、右に要素を追加し左から要素を取り出すことで"
"最近追加した要素のシーケンスを保持することです::"

#: ../../library/collections.rst:666
msgid ""
"def moving_average(iterable, n=3):\n"
"    # moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0\n"
"    # https://en.wikipedia.org/wiki/Moving_average\n"
"    it = iter(iterable)\n"
"    d = deque(itertools.islice(it, n-1))\n"
"    d.appendleft(0)\n"
"    s = sum(d)\n"
"    for elem in it:\n"
"        s += elem - d.popleft()\n"
"        d.append(elem)\n"
"        yield s / n"
msgstr ""

#: ../../library/collections.rst:678
msgid ""
"A `round-robin scheduler <https://en.wikipedia.org/wiki/Round-"
"robin_scheduling>`_ can be implemented with input iterators stored in a :"
"class:`deque`.  Values are yielded from the active iterator in position "
"zero.  If that iterator is exhausted, it can be removed with :meth:`~deque."
"popleft`; otherwise, it can be cycled back to the end with the :meth:`~deque."
"rotate` method::"
msgstr ""
"`ラウンドロビンスケジューラ <https://en.wikipedia.org/wiki/Round-"
"robin_scheduling>`_ は、入力されたイテレータを :class:`deque` に格納すること"
"で実装できます。\n"
"値は、位置0にある選択中のイテレータから取り出されます。\n"
"そのイテレータが値を出し切った場合は、 :meth:`~deque.popleft` で除去できま"
"す; そうでない場合は、 :meth:`~deque.rotate` メソッドで末尾に回せます::"

#: ../../library/collections.rst:685
msgid ""
"def roundrobin(*iterables):\n"
"    \"roundrobin('ABC', 'D', 'EF') --> A D E B F C\"\n"
"    iterators = deque(map(iter, iterables))\n"
"    while iterators:\n"
"        try:\n"
"            while True:\n"
"                yield next(iterators[0])\n"
"                iterators.rotate(-1)\n"
"        except StopIteration:\n"
"            # Remove an exhausted iterator.\n"
"            iterators.popleft()"
msgstr ""

#: ../../library/collections.rst:697
msgid ""
"The :meth:`~deque.rotate` method provides a way to implement :class:`deque` "
"slicing and deletion.  For example, a pure Python implementation of ``del "
"d[n]`` relies on the ``rotate()`` method to position elements to be popped::"
msgstr ""
":meth:`~deque.rotate` メソッドは、 :class:`deque` のスライスや削除の機能を提"
"供します。\n"
"例えば、 純粋な Python 実装の ``del d[n]`` は ``rotate()`` メソッドを頼りに、"
"pop される要素の位置を割り出します::"

#: ../../library/collections.rst:701
msgid ""
"def delete_nth(d, n):\n"
"    d.rotate(-n)\n"
"    d.popleft()\n"
"    d.rotate(n)"
msgstr ""

#: ../../library/collections.rst:706
msgid ""
"To implement :class:`deque` slicing, use a similar approach applying :meth:"
"`~deque.rotate` to bring a target element to the left side of the deque. "
"Remove old entries with :meth:`~deque.popleft`, add new entries with :meth:"
"`~deque.extend`, and then reverse the rotation. With minor variations on "
"that approach, it is easy to implement Forth style stack manipulations such "
"as ``dup``, ``drop``, ``swap``, ``over``, ``pick``, ``rot``, and ``roll``."
msgstr ""
":class:`deque` のスライスの実装でも、同様のアプローチを使います。まず対象とな"
"る要素を :meth:`~deque.rotate` によって deque の左端まで移動させてから、 :"
"meth:`~deque.popleft` で古い要素を削除します。そして、 :meth:`~deque.extend` "
"で新しい要素を追加したのち、循環を逆にします。このアプローチをやや変えたもの"
"として、Forth スタイルのスタック操作、つまり ``dup``, ``drop``, ``swap``, "
"``over``, ``pick``, ``rot``, および ``roll`` を実装するのも簡単です。"

#: ../../library/collections.rst:716
msgid ":class:`defaultdict` objects"
msgstr ":class:`defaultdict` オブジェクト"

#: ../../library/collections.rst:720
msgid ""
"Return a new dictionary-like object.  :class:`defaultdict` is a subclass of "
"the built-in :class:`dict` class.  It overrides one method and adds one "
"writable instance variable.  The remaining functionality is the same as for "
"the :class:`dict` class and is not documented here."
msgstr ""
"新しい辞書に似たオブジェクトを返します。 :class:`defaultdict` は組み込みの :"
"class:`dict` クラスのサブクラスです。これはメソッドをひとつオーバーライドし、"
"書き込み可能なインスタンス変数をひとつ追加しています。それ以外の機能は :"
"class:`dict` クラスと同じですので、ここでは説明しません。"

#: ../../library/collections.rst:725
msgid ""
"The first argument provides the initial value for the :attr:"
"`default_factory` attribute; it defaults to ``None``. All remaining "
"arguments are treated the same as if they were passed to the :class:`dict` "
"constructor, including keyword arguments."
msgstr ""
"1つ目の引数は :attr:`default_factory` 属性の初期値です。デフォルトは "
"``None`` です。残りの引数はキーワード引数も含め、 :class:`dict` のコンストラ"
"クタに与えられた場合と同様に扱われます。"

#: ../../library/collections.rst:731
msgid ""
":class:`defaultdict` objects support the following method in addition to the "
"standard :class:`dict` operations:"
msgstr ""
":class:`defaultdict` オブジェクトは標準の :class:`dict` に加えて、以下のメ"
"ソッドを実装しています:"

#: ../../library/collections.rst:736
msgid ""
"If the :attr:`default_factory` attribute is ``None``, this raises a :exc:"
"`KeyError` exception with the *key* as argument."
msgstr ""
"もし :attr:`default_factory` 属性が ``None`` であれば、このメソッドは :exc:"
"`KeyError` 例外を、 *key* を引数として発生させます。"

#: ../../library/collections.rst:739
msgid ""
"If :attr:`default_factory` is not ``None``, it is called without arguments "
"to provide a default value for the given *key*, this value is inserted in "
"the dictionary for the *key*, and returned."
msgstr ""
"もし :attr:`default_factory` 属性が ``None`` でない場合、このメソッドは引数な"
"しで呼び出され、与えらえた *key* に対応するデフォルト値を提供します。この値"
"は、辞書内に *key* に対応して登録され、最後に返されます。"

#: ../../library/collections.rst:743
msgid ""
"If calling :attr:`default_factory` raises an exception this exception is "
"propagated unchanged."
msgstr ""
"もし :attr:`default_factory` の呼出が例外を発生させた場合には、変更せずそのま"
"ま例外を投げます。"

#: ../../library/collections.rst:746
msgid ""
"This method is called by the :meth:`~object.__getitem__` method of the :"
"class:`dict` class when the requested key is not found; whatever it returns "
"or raises is then returned or raised by :meth:`~object.__getitem__`."
msgstr ""
"このメソッドは :class:`dict` クラスの :meth:`~object.__getitem__` メソッド"
"で、キーが存在しなかった場合によびだされます。値を返すか例外を発生させるのど"
"ちらにしても、 :meth:`~object.__getitem__` からもそのまま値が返るか例外が発生"
"します。"

#: ../../library/collections.rst:750
msgid ""
"Note that :meth:`__missing__` is *not* called for any operations besides :"
"meth:`~object.__getitem__`. This means that :meth:`get` will, like normal "
"dictionaries, return ``None`` as a default rather than using :attr:"
"`default_factory`."
msgstr ""
"なお、 :meth:`__missing__` は :meth:`~object.__getitem__` 以外のいかなる演算"
"に対しても呼び出され *ません* 。よって :meth:`get` は、普通の辞書と同様に、 :"
"attr:`default_factory` を使うのではなくデフォルトとして ``None`` を返します。"

#: ../../library/collections.rst:756
msgid ":class:`defaultdict` objects support the following instance variable:"
msgstr ""
":class:`defaultdict` オブジェクトは以下のインスタンス変数をサポートしていま"
"す:"

#: ../../library/collections.rst:761
msgid ""
"This attribute is used by the :meth:`__missing__` method; it is initialized "
"from the first argument to the constructor, if present, or to ``None``, if "
"absent."
msgstr ""
"この属性は :meth:`__missing__` メソッドによって使われます。これは存在すればコ"
"ンストラクタの第1引数によって初期化され、そうでなければ ``None`` になります。"

#: ../../library/collections.rst:765 ../../library/collections.rst:1191
msgid ""
"Added merge (``|``) and update (``|=``) operators, specified in :pep:`584`."
msgstr ""
":pep:`584` で規定されている合成演算子 (``|``) と更新演算子 (``|=``)が追加され"
"ました。"

#: ../../library/collections.rst:771
msgid ":class:`defaultdict` Examples"
msgstr ":class:`defaultdict` の使用例"

#: ../../library/collections.rst:773
msgid ""
"Using :class:`list` as the :attr:`~defaultdict.default_factory`, it is easy "
"to group a sequence of key-value pairs into a dictionary of lists:"
msgstr ""
":class:`list` を :attr:`~defaultdict.default_factory` とすることで、キー=値ペ"
"アのシーケンスをリストの辞書へ簡単にグループ化できます。:"

#: ../../library/collections.rst:784
msgid ""
"When each key is encountered for the first time, it is not already in the "
"mapping; so an entry is automatically created using the :attr:`~defaultdict."
"default_factory` function which returns an empty :class:`list`.  The :meth:"
"`list.append` operation then attaches the value to the new list.  When keys "
"are encountered again, the look-up proceeds normally (returning the list for "
"that key) and the :meth:`list.append` operation adds another value to the "
"list. This technique is simpler and faster than an equivalent technique "
"using :meth:`dict.setdefault`:"
msgstr ""
"それぞれのキーが最初に登場したとき、マッピングにはまだ存在しません。そのため"
"エントリは :attr:`~defaultdict.default_factory` 関数が返す空の :class:`list` "
"を使って自動的に作成されます。 :meth:`list.append` 操作は新しいリストに紐付け"
"られます。キーが再度出現した場合には、通常の参照動作が行われます(そのキーに対"
"応するリストが返ります)。そして :meth:`list.append` 操作で別の値をリストに追"
"加します。このテクニックは :meth:`dict.setdefault` を使った等価なものよりシン"
"プルで速いです:"

#: ../../library/collections.rst:799
msgid ""
"Setting the :attr:`~defaultdict.default_factory` to :class:`int` makes the :"
"class:`defaultdict` useful for counting (like a bag or multiset in other "
"languages):"
msgstr ""
":attr:`~defaultdict.default_factory` を :class:`int` にすると、 :class:"
"`defaultdict` を(他の言語の bag や multisetのように)要素の数え上げに便利に使"
"うことができます:"

#: ../../library/collections.rst:811
msgid ""
"When a letter is first encountered, it is missing from the mapping, so the :"
"attr:`~defaultdict.default_factory` function calls :func:`int` to supply a "
"default count of zero.  The increment operation then builds up the count for "
"each letter."
msgstr ""
"最初に文字が出現したときは、マッピングが存在しないので :attr:`~defaultdict."
"default_factory` 関数が :func:`int` を呼んでデフォルトのカウント0を生成しま"
"す。インクリメント操作が各文字を数え上げます。"

#: ../../library/collections.rst:815
msgid ""
"The function :func:`int` which always returns zero is just a special case of "
"constant functions.  A faster and more flexible way to create constant "
"functions is to use a lambda function which can supply any constant value "
"(not just zero):"
msgstr ""
"常に0を返す :func:`int` は特殊な関数でした。定数を生成するより速くて柔軟な方"
"法は、 0に限らず何でも定数を生成するラムダ関数を使うことです:"

#: ../../library/collections.rst:828
msgid ""
"Setting the :attr:`~defaultdict.default_factory` to :class:`set` makes the :"
"class:`defaultdict` useful for building a dictionary of sets:"
msgstr ""
":attr:`~defaultdict.default_factory` を :class:`set` に設定することで、 :"
"class:`defaultdict` をセットの辞書を作るために利用することができます:"

#: ../../library/collections.rst:841
msgid ":func:`namedtuple` Factory Function for Tuples with Named Fields"
msgstr ":func:`namedtuple` 名前付きフィールドを持つタプルのファクトリ関数"

#: ../../library/collections.rst:843
msgid ""
"Named tuples assign meaning to each position in a tuple and allow for more "
"readable, self-documenting code.  They can be used wherever regular tuples "
"are used, and they add the ability to access fields by name instead of "
"position index."
msgstr ""
"名前付きタプルは、タプルの中のすべての場所に意味を割り当てて、より読みやすく"
"自己解説的なコードを書けるようにします。通常のタプルが利用される場所ならどこ"
"でも利用でき、場所に対するインデックスの代わりに名前を使ってフィールドにアク"
"セスできるようになります。"

#: ../../library/collections.rst:849
msgid ""
"Returns a new tuple subclass named *typename*.  The new subclass is used to "
"create tuple-like objects that have fields accessible by attribute lookup as "
"well as being indexable and iterable.  Instances of the subclass also have a "
"helpful docstring (with typename and field_names) and a helpful :meth:"
"`__repr__` method which lists the tuple contents in a ``name=value`` format."
msgstr ""
"*typename* という名前の tuple の新しいサブクラスを返します。新しいサブクラス"
"は、 tuple に似ているけれどもインデックスやイテレータだけでなく属性名によるア"
"クセスもできるオブジェクトを作るのに使います。このサブクラスのインスタンス"
"は、わかりやすい docstring (型名と属性名が入っています) や、 tuple の内容を "
"``name=value`` という形のリストで返す使いやすい :meth:`__repr__` も持っていま"
"す。"

#: ../../library/collections.rst:855
msgid ""
"The *field_names* are a sequence of strings such as ``['x', 'y']``. "
"Alternatively, *field_names* can be a single string with each fieldname "
"separated by whitespace and/or commas, for example ``'x y'`` or ``'x, y'``."
msgstr ""
"*field_names* は ``['x', 'y']`` のような文字列のシーケンスです。 "
"*field_names* には、代わりに各属性名を空白文字 (whitespace) および/またはカン"
"マ (,) で区切った文字列を渡すこともできます。例えば、 ``'x y'`` や ``'x, "
"y'`` です。"

#: ../../library/collections.rst:859
msgid ""
"Any valid Python identifier may be used for a fieldname except for names "
"starting with an underscore.  Valid identifiers consist of letters, digits, "
"and underscores but do not start with a digit or underscore and cannot be a :"
"mod:`keyword` such as *class*, *for*, *return*, *global*, *pass*, or *raise*."
msgstr ""
"アンダースコア (_) で始まる名前を除いて、 Python の正しい識別子 (identifier) "
"ならなんでも属性名として使うことができます。正しい識別子とはアルファベット"
"(letters), 数字(digits), アンダースコア(_) を含みますが、数字やアンダースコア"
"で始まる名前や、 *class*, *for*, *return*, *global*, *pass*, *raise* などと"
"いった :mod:`keyword` は使えません。"

#: ../../library/collections.rst:865
msgid ""
"If *rename* is true, invalid fieldnames are automatically replaced with "
"positional names.  For example, ``['abc', 'def', 'ghi', 'abc']`` is "
"converted to ``['abc', '_1', 'ghi', '_3']``, eliminating the keyword ``def`` "
"and the duplicate fieldname ``abc``."
msgstr ""
"*rename* が真の場合、不適切なフィールド名は自動的に位置を示す名前に置き換えら"
"れます。例えば ``['abc', 'def', 'ghi', 'abc']`` は、予約語の ``def`` と、重複"
"しているフィールド名の ``abc`` が除去され、``['abc', '_1', 'ghi', '_3']`` に"
"変換されます。"

#: ../../library/collections.rst:870
msgid ""
"*defaults* can be ``None`` or an :term:`iterable` of default values. Since "
"fields with a default value must come after any fields without a default, "
"the *defaults* are applied to the rightmost parameters.  For example, if the "
"fieldnames are ``['x', 'y', 'z']`` and the defaults are ``(1, 2)``, then "
"``x`` will be a required argument, ``y`` will default to ``1``, and ``z`` "
"will default to ``2``."
msgstr ""
"*defaults* には ``None`` あるいはデフォルト値の :term:`iterable` が指定できま"
"す。\n"
"デフォルト値を持つフィールドはデフォルト値を持たないフィールドより後ろに来な"
"ければならないので、 *defaults* は最も右にある変数に適用されます。\n"
"例えば、 field_names が ``['x', 'y', 'z']`` で defaults が ``(1, 2)`` の場"
"合、 ``x`` は必須の引数、 ``y`` は ``1`` がデフォルト、 ``z`` は ``2`` がデ"
"フォルトとなります。"

#: ../../library/collections.rst:877
msgid ""
"If *module* is defined, the :attr:`~type.__module__` attribute of the named "
"tuple is set to that value."
msgstr ""

#: ../../library/collections.rst:880
msgid ""
"Named tuple instances do not have per-instance dictionaries, so they are "
"lightweight and require no more memory than regular tuples."
msgstr ""
"名前付きタプルのインスタンスはインスタンスごとの辞書を持たないので、軽量で、"
"普通のタプル以上のメモリを使用しません。"

#: ../../library/collections.rst:883
msgid ""
"To support pickling, the named tuple class should be assigned to a variable "
"that matches *typename*."
msgstr ""
"pickle 化をサポートするには、名前付きタプルのクラス定義は *typename* と同じ名"
"前の変数に割り当てなければなりません。"

#: ../../library/collections.rst:886
msgid "Added support for *rename*."
msgstr "*rename* のサポートが追加されました。"

#: ../../library/collections.rst:889
msgid ""
"The *verbose* and *rename* parameters became :ref:`keyword-only arguments "
"<keyword-only_parameter>`."
msgstr ""
"*verbose* と *rename* 引数が :ref:`キーワード専用引数 <keyword-"
"only_parameter>` になりました."

#: ../../library/collections.rst:893
msgid "Added the *module* parameter."
msgstr "*module* 引数が追加されました。"

#: ../../library/collections.rst:896
msgid "Removed the *verbose* parameter and the :attr:`_source` attribute."
msgstr "*verbose* 引数と :attr:`_source` 属性が削除されました。"

#: ../../library/collections.rst:899
msgid ""
"Added the *defaults* parameter and the :attr:`_field_defaults` attribute."
msgstr "*defaults* 引数と :attr:`_field_defaults` 属性が追加されました。"

#: ../../library/collections.rst:903
msgid ""
">>> # Basic example\n"
">>> Point = namedtuple('Point', ['x', 'y'])\n"
">>> p = Point(11, y=22)     # instantiate with positional or keyword "
"arguments\n"
">>> p[0] + p[1]             # indexable like the plain tuple (11, 22)\n"
"33\n"
">>> x, y = p                # unpack like a regular tuple\n"
">>> x, y\n"
"(11, 22)\n"
">>> p.x + p.y               # fields also accessible by name\n"
"33\n"
">>> p                       # readable __repr__ with a name=value style\n"
"Point(x=11, y=22)"
msgstr ""

#: ../../library/collections.rst:919
msgid ""
"Named tuples are especially useful for assigning field names to result "
"tuples returned by the :mod:`csv` or :mod:`sqlite3` modules::"
msgstr ""
"名前付きタプルは :mod:`csv` や :mod:`sqlite3` モジュールが返すタプルのフィー"
"ルドに名前を付けるときにとても便利です::"

#: ../../library/collections.rst:922
msgid ""
"EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, department, "
"paygrade')\n"
"\n"
"import csv\n"
"for emp in map(EmployeeRecord._make, csv.reader(open(\"employees.csv\", "
"\"rb\"))):\n"
"    print(emp.name, emp.title)\n"
"\n"
"import sqlite3\n"
"conn = sqlite3.connect('/companydata')\n"
"cursor = conn.cursor()\n"
"cursor.execute('SELECT name, age, title, department, paygrade FROM "
"employees')\n"
"for emp in map(EmployeeRecord._make, cursor.fetchall()):\n"
"    print(emp.name, emp.title)"
msgstr ""

#: ../../library/collections.rst:935
msgid ""
"In addition to the methods inherited from tuples, named tuples support three "
"additional methods and two attributes.  To prevent conflicts with field "
"names, the method and attribute names start with an underscore."
msgstr ""
"タプルから継承したメソッドに加えて、名前付きタプルは3つの追加メソッドと2つの"
"属性をサポートしています。フィールド名との衝突を避けるために、メソッド名と属"
"性名はアンダースコアで始まります。"

#: ../../library/collections.rst:941
msgid ""
"Class method that makes a new instance from an existing sequence or iterable."
msgstr ""
"既存の sequence や Iterable から新しいインスタンスを作るクラスメソッド."

#: ../../library/collections.rst:943
msgid ""
">>> t = [11, 22]\n"
">>> Point._make(t)\n"
"Point(x=11, y=22)"
msgstr ""

#: ../../library/collections.rst:951
msgid ""
"Return a new :class:`dict` which maps field names to their corresponding "
"values:"
msgstr ""
"フィールド名を対応する値にマッピングする新しい :class:`dict` を返します::"

#: ../../library/collections.rst:954
msgid ""
">>> p = Point(x=11, y=22)\n"
">>> p._asdict()\n"
"{'x': 11, 'y': 22}"
msgstr ""

#: ../../library/collections.rst:960
msgid "Returns an :class:`OrderedDict` instead of a regular :class:`dict`."
msgstr ""
"通常の :class:`dict` の代わりに :class:`OrderedDict` を返すようになりました。"

#: ../../library/collections.rst:963
msgid ""
"Returns a regular :class:`dict` instead of an :class:`OrderedDict`. As of "
"Python 3.7, regular dicts are guaranteed to be ordered.  If the extra "
"features of :class:`OrderedDict` are required, the suggested remediation is "
"to cast the result to the desired type: ``OrderedDict(nt._asdict())``."
msgstr ""
":class:`collections.OrderedDict` ではなく :class:`dict` を返すようになりまし"
"た。Python 3.7以降は、通常の辞書で順番が保証されています。 :class:"
"`OrderedDict` 特有の機能を使いたい場合は、結果を ``OrderedDict(nt."
"_asdict())`` 型にキャストして使用することを推奨します。"

#: ../../library/collections.rst:972
msgid ""
"Return a new instance of the named tuple replacing specified fields with new "
"values::"
msgstr ""
"指定されたフィールドを新しい値で置き換えた、新しい名前付きタプルを作って返し"
"ます::"

#: ../../library/collections.rst:975
msgid ""
">>> p = Point(x=11, y=22)\n"
">>> p._replace(x=33)\n"
"Point(x=33, y=22)\n"
"\n"
">>> for partnum, record in inventory.items():\n"
"...     inventory[partnum] = record._replace(price=newprices[partnum], "
"timestamp=time.now())"
msgstr ""

#: ../../library/collections.rst:982
msgid ""
"Named tuples are also supported by generic function :func:`copy.replace`."
msgstr ""
"名前付きタプルは汎用的な関数 :func:`copy.replace` にもサポートされています。"

#: ../../library/collections.rst:984
msgid ""
"Raise :exc:`TypeError` instead of :exc:`ValueError` for invalid keyword "
"arguments."
msgstr ""
"キーワード引数が無効な場合は :exc:`ValueError` のかわりに :exc:`TypeError` が"
"発生します。"

#: ../../library/collections.rst:990
msgid ""
"Tuple of strings listing the field names.  Useful for introspection and for "
"creating new named tuple types from existing named tuples."
msgstr ""
"フィールド名をリストにしたタプルです。内省 (introspection) したり、既存の名前"
"付きタプルをもとに新しい名前つきタプルを作成する時に便利です。"

#: ../../library/collections.rst:993
msgid ""
">>> p._fields            # view the field names\n"
"('x', 'y')\n"
"\n"
">>> Color = namedtuple('Color', 'red green blue')\n"
">>> Pixel = namedtuple('Pixel', Point._fields + Color._fields)\n"
">>> Pixel(11, 22, 128, 255, 0)\n"
"Pixel(x=11, y=22, red=128, green=255, blue=0)"
msgstr ""

#: ../../library/collections.rst:1005
msgid "Dictionary mapping field names to default values."
msgstr "フィールド名からデフォルト値への対応を持つ辞書です。"

#: ../../library/collections.rst:1007
msgid ""
">>> Account = namedtuple('Account', ['type', 'balance'], defaults=[0])\n"
">>> Account._field_defaults\n"
"{'balance': 0}\n"
">>> Account('premium')\n"
"Account(type='premium', balance=0)"
msgstr ""

#: ../../library/collections.rst:1015
msgid ""
"To retrieve a field whose name is stored in a string, use the :func:"
"`getattr` function:"
msgstr ""
"文字列に格納された名前を使って名前つきタプルから値を取得するには :func:"
"`getattr` 関数を使います:"

#: ../../library/collections.rst:1021
msgid ""
"To convert a dictionary to a named tuple, use the double-star-operator (as "
"described in :ref:`tut-unpacking-arguments`):"
msgstr ""
"辞書を名前付きタプルに変換するには、 ``**`` 演算子 (double-star-operator, :"
"ref:`tut-unpacking-arguments` で説明しています) を使います。:"

#: ../../library/collections.rst:1028
msgid ""
"Since a named tuple is a regular Python class, it is easy to add or change "
"functionality with a subclass.  Here is how to add a calculated field and a "
"fixed-width print format:"
msgstr ""
"名前付きタプルは通常の Python クラスなので、継承して機能を追加したり変更する"
"のは容易です。次の例では計算済みフィールドと固定幅の print format を追加して"
"います:"

#: ../../library/collections.rst:1032
msgid ""
">>> class Point(namedtuple('Point', ['x', 'y'])):\n"
"...     __slots__ = ()\n"
"...     @property\n"
"...     def hypot(self):\n"
"...         return (self.x ** 2 + self.y ** 2) ** 0.5\n"
"...     def __str__(self):\n"
"...         return 'Point: x=%6.3f  y=%6.3f  hypot=%6.3f' % (self.x, self.y, "
"self.hypot)\n"
"\n"
">>> for p in Point(3, 4), Point(14, 5/7):\n"
"...     print(p)\n"
"Point: x= 3.000  y= 4.000  hypot= 5.000\n"
"Point: x=14.000  y= 0.714  hypot=14.018"
msgstr ""

#: ../../library/collections.rst:1047
msgid ""
"The subclass shown above sets ``__slots__`` to an empty tuple.  This helps "
"keep memory requirements low by preventing the creation of instance "
"dictionaries."
msgstr ""
"このサブクラスは ``__slots__`` に空のタプルをセットしています。これにより、イ"
"ンスタンス辞書の作成を抑制してメモリ使用量を低く保つのに役立ちます。"

#: ../../library/collections.rst:1050
msgid ""
"Subclassing is not useful for adding new, stored fields.  Instead, simply "
"create a new named tuple type from the :attr:`~somenamedtuple._fields` "
"attribute:"
msgstr ""
"サブクラス化は新しいフィールドを追加するのには適していません。代わりに、新し"
"い名前付きタプルを :attr:`~somenamedtuple._fields` 属性を元に作成してくださ"
"い:"

#: ../../library/collections.rst:1055
msgid ""
"Docstrings can be customized by making direct assignments to the ``__doc__`` "
"fields:"
msgstr ""
"``__doc__`` フィールドに直接代入することでドックストリングをカスタマイズする"
"ことが出来ます:"

#: ../../library/collections.rst:1064
msgid "Property docstrings became writeable."
msgstr "属性ドックストリングが書き込み可能になりました。"

#: ../../library/collections.rst:1069
msgid ""
"See :class:`typing.NamedTuple` for a way to add type hints for named "
"tuples.  It also provides an elegant notation using the :keyword:`class` "
"keyword::"
msgstr ""
"名前付きタプルに型ヒントを追加する方法については、 :class:`typing."
"NamedTuple` を参照してください。\n"
":keyword:`class` キーワードを使った洗練された記法も紹介されています::"

#: ../../library/collections.rst:1073
msgid ""
"class Component(NamedTuple):\n"
"    part_number: int\n"
"    weight: float\n"
"    description: Optional[str] = None"
msgstr ""

#: ../../library/collections.rst:1078
msgid ""
"See :meth:`types.SimpleNamespace` for a mutable namespace based on an "
"underlying dictionary instead of a tuple."
msgstr ""
"タプルではなく、辞書をもとにした変更可能な名前空間を作成するには :meth:"
"`types.SimpleNamespace` を参照してください。"

#: ../../library/collections.rst:1081
msgid ""
"The :mod:`dataclasses` module provides a decorator and functions for "
"automatically adding generated special methods to user-defined classes."
msgstr ""
":mod:`dataclasses` モジュールは、生成される特殊メソッドをユーザー定義クラスに"
"自動的に追加するためのデコレータや関数を提供しています。"

#: ../../library/collections.rst:1086
msgid ":class:`OrderedDict` objects"
msgstr ":class:`OrderedDict` オブジェクト"

#: ../../library/collections.rst:1088
msgid ""
"Ordered dictionaries are just like regular dictionaries but have some extra "
"capabilities relating to ordering operations.  They have become less "
"important now that the built-in :class:`dict` class gained the ability to "
"remember insertion order (this new behavior became guaranteed in Python 3.7)."
msgstr ""
"順序付き辞書は普通の辞書のようですが、順序操作に関係する追加の機能がありま"
"す。\n"
"組み込みの :class:`dict` クラスが挿入順序を記憶しておく機能 (この新しい振る舞"
"いは Python 3.7 で保証されるようになりました) を獲得した今となっては、順序付"
"き辞書の重要性は薄れました。"

#: ../../library/collections.rst:1094
msgid "Some differences from :class:`dict` still remain:"
msgstr "いまだ残っている :class:`dict` との差分:"

#: ../../library/collections.rst:1096
msgid ""
"The regular :class:`dict` was designed to be very good at mapping "
"operations.  Tracking insertion order was secondary."
msgstr ""
"通常の :class:`dict` は対応付けに向いているように設計されました。\n"
"挿入順序の追跡は二の次です。"

#: ../../library/collections.rst:1099
msgid ""
"The :class:`OrderedDict` was designed to be good at reordering operations. "
"Space efficiency, iteration speed, and the performance of update operations "
"were secondary."
msgstr ""
":class:`OrderedDict` は並べ替え操作に向いているように設計されました。\n"
"空間効率、反復処理の速度、更新操作のパフォーマンスは二の次です。"

#: ../../library/collections.rst:1103
msgid ""
"The :class:`OrderedDict` algorithm can handle frequent reordering operations "
"better than :class:`dict`.  As shown in the recipes below, this makes it "
"suitable for implementing various kinds of LRU caches."
msgstr ""
":class:`OrderedDict` のアルゴリズムは、頻繁な並べ替え処理を :class:`dict` よ"
"りもうまく扱うことができます。後述のレシピに示されている通り、この性質はさま"
"ざまな種類の LRU キャッシュの実装に適しています。"

#: ../../library/collections.rst:1107
msgid ""
"The equality operation for :class:`OrderedDict` checks for matching order."
msgstr ""
":class:`OrderedDict` に対する等価演算は突き合わせ順序もチェックします。"

#: ../../library/collections.rst:1109
msgid ""
"A regular :class:`dict` can emulate the order sensitive equality test with "
"``p == q and all(k1 == k2 for k1, k2 in zip(p, q))``."
msgstr ""
"組み込みの :class:`dict` では、順序を考慮した等価演算は ``p == q and all(k1 "
"== k2 for k1, k2 in zip(p, q))`` で実現することができます。"

#: ../../library/collections.rst:1112
msgid ""
"The :meth:`popitem` method of :class:`OrderedDict` has a different "
"signature.  It accepts an optional argument to specify which item is popped."
msgstr ""
":class:`OrderedDict` の :meth:`popitem` メソッドはシグネチャが異なります。\n"
"どの要素を取り出すかを指定するオプション引数を受け付けます。"

#: ../../library/collections.rst:1115
msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.popitem(last=True)`` "
"with ``d.popitem()`` which is guaranteed to pop the rightmost (last) item."
msgstr ""
"組み込みの :class:`dict` の場合、 OrderedDict の ``od.popitem(last=True)`` と"
"同じ機能は、最も右側の (最後の) 要素を取り出すことが保証されている ``d."
"popitem()`` が果たします。"

#: ../../library/collections.rst:1118
msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.popitem(last=False)`` "
"with ``(k := next(iter(d)), d.pop(k))`` which will return and remove the "
"leftmost (first) item if it exists."
msgstr ""
"組み込みの :class:`dict` の場合、 OrderedDict の ``od.popitem(last=False)`` "
"は ``(k := next(iter(d)), d.pop(k))`` で実現できます。これにより、該当する要"
"素のうちで最も左側の (先頭の) ものを辞書から削除して返すことができます。"

#: ../../library/collections.rst:1122
msgid ""
":class:`OrderedDict` has a :meth:`move_to_end` method to efficiently "
"reposition an element to an endpoint."
msgstr ""
":class:`OrderedDict` には、 効率的に要素を末尾に置き直す :meth:`move_to_end` "
"メソッドがあります。"

#: ../../library/collections.rst:1125
msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.move_to_end(k, "
"last=True)`` with ``d[k] = d.pop(k)`` which will move the key and its "
"associated value to the rightmost (last) position."
msgstr ""
"組み込みの :class:`dict` の場合、キーと値のペアを最も右側 (末尾) に移動する "
"OrderedDict の ``od.move_to_end(k, last=True)`` は ``d[k] = d.pop(k)`` で実現"
"できます。"

#: ../../library/collections.rst:1129
msgid ""
"A regular :class:`dict` does not have an efficient equivalent for "
"OrderedDict's ``od.move_to_end(k, last=False)`` which moves the key and its "
"associated value to the leftmost (first) position."
msgstr ""
"組み込みの :class:`dict` では、キーと値のペアを最も左側 (先頭) に移動する "
"OrderedDict の ``od.move_to_end(k, last=False)`` を実現する効率の良い方法はあ"
"りません。 "

#: ../../library/collections.rst:1133
msgid "Until Python 3.8, :class:`dict` lacked a :meth:`__reversed__` method."
msgstr ""
"Python 3.8 以前は、 :class:`dict` には :meth:`__reversed__` メソッドが欠けて"
"います。"

#: ../../library/collections.rst:1138
msgid ""
"Return an instance of a :class:`dict` subclass that has methods specialized "
"for rearranging dictionary order."
msgstr ""
"辞書の順序を並べ直すためのメソッドを持つ :class:`dict` のサブクラスのインスタ"
"ンスを返します。"

#: ../../library/collections.rst:1145
msgid ""
"The :meth:`popitem` method for ordered dictionaries returns and removes a "
"(key, value) pair.  The pairs are returned in :abbr:`LIFO (last-in, first-"
"out)` order if *last* is true or :abbr:`FIFO (first-in, first-out)` order if "
"false."
msgstr ""
"順序付き辞書の :meth:`popitem` メソッドは、(key, value) 対を返して消去しま"
"す。この対は *last* が真なら :abbr:`LIFO (last-in, first-out, 後入先出)` で、"
"偽なら :abbr:`FIFO (first-in, first-out, 先入先出)`  で返されます。"

#: ../../library/collections.rst:1152
msgid ""
"Move an existing *key* to either end of an ordered dictionary.  The item is "
"moved to the right end if *last* is true (the default) or to the beginning "
"if *last* is false.  Raises :exc:`KeyError` if the *key* does not exist:"
msgstr ""
"存在する *key* を順序付き辞書の先頭または末尾に移動します。要素は *last* が"
"真 (デフォルト) の場合に最も右側すなわち末尾に移動します。また *last* が偽の"
"場合には先頭に移動します。指定した *key* が存在しない場合は :exc:`KeyError` "
"を送出します。"

#: ../../library/collections.rst:1157
msgid ""
">>> d = OrderedDict.fromkeys('abcde')\n"
">>> d.move_to_end('b')\n"
">>> ''.join(d)\n"
"'acdeb'\n"
">>> d.move_to_end('b', last=False)\n"
">>> ''.join(d)\n"
"'bacde'"
msgstr ""

#: ../../library/collections.rst:1169
msgid ""
"In addition to the usual mapping methods, ordered dictionaries also support "
"reverse iteration using :func:`reversed`."
msgstr ""
"通常のマッピングのメソッドに加え、順序付き辞書は :func:`reversed` による逆順"
"の反復もサポートしています。"

#: ../../library/collections.rst:1174
msgid ""
"Equality tests between :class:`OrderedDict` objects are order-sensitive and "
"are roughly equivalent to ``list(od1.items())==list(od2.items())``."
msgstr ""

#: ../../library/collections.rst:1177
msgid ""
"Equality tests between :class:`OrderedDict` objects and other :class:"
"`~collections.abc.Mapping` objects are order-insensitive like regular "
"dictionaries.  This allows :class:`OrderedDict` objects to be substituted "
"anywhere a regular dictionary is used."
msgstr ""

#: ../../library/collections.rst:1182
msgid ""
"The items, keys, and values :term:`views <dictionary view>` of :class:"
"`OrderedDict` now support reverse iteration using :func:`reversed`."
msgstr ""
":class:`OrderedDict` の項目、キー、値の :term:`ビュー <dictionary view>` が :"
"func:`reversed` による逆順の反復をサポートするようになりました。"

#: ../../library/collections.rst:1186
msgid ""
"With the acceptance of :pep:`468`, order is retained for keyword arguments "
"passed to the :class:`OrderedDict` constructor and its :meth:`update` method."
msgstr ""
":pep:`468` の受理によって、:class:`OrderedDict` のコンストラクタと、:meth:"
"`update` メソッドに渡したキーワード引数の順序は保持されます。"

#: ../../library/collections.rst:1196
msgid ":class:`OrderedDict` Examples and Recipes"
msgstr ":class:`OrderedDict` の例とレシピ"

#: ../../library/collections.rst:1198
msgid ""
"It is straightforward to create an ordered dictionary variant that remembers "
"the order the keys were *last* inserted. If a new entry overwrites an "
"existing entry, the original insertion position is changed and moved to the "
"end::"
msgstr ""
"キーが *最後に* 追加されたときの順序を記憶する、順序付き辞書の変種を作るのは"
"簡単です。\n"
"新しい値が既存の値を上書きする場合、元々の挿入位置が最後尾へ変更されます::"

#: ../../library/collections.rst:1203
msgid ""
"class LastUpdatedOrderedDict(OrderedDict):\n"
"    'Store items in the order the keys were last added'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        super().__setitem__(key, value)\n"
"        self.move_to_end(key)"
msgstr ""

#: ../../library/collections.rst:1210
msgid ""
"An :class:`OrderedDict` would also be useful for implementing variants of :"
"func:`functools.lru_cache`:"
msgstr ""
":class:`OrderedDict` は :func:`functools.lru_cache` の変種を実装するのにも役"
"に立ちます:"

#: ../../library/collections.rst:1213
msgid ""
"from collections import OrderedDict\n"
"from time import time\n"
"\n"
"class TimeBoundedLRU:\n"
"    \"LRU Cache that invalidates and refreshes old entries.\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxage=30):\n"
"        self.cache = OrderedDict()      # { args : (timestamp, result)}\n"
"        self.func = func\n"
"        self.maxsize = maxsize\n"
"        self.maxage = maxage\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            timestamp, result = self.cache[args]\n"
"            if time() - timestamp <= self.maxage:\n"
"                return result\n"
"        result = self.func(*args)\n"
"        self.cache[args] = time(), result\n"
"        if len(self.cache) > self.maxsize:\n"
"            self.cache.popitem(last=False)\n"
"        return result"
msgstr ""

#: ../../library/collections.rst:1240
msgid ""
"class MultiHitLRUCache:\n"
"    \"\"\" LRU cache that defers caching a result until\n"
"        it has been requested multiple times.\n"
"\n"
"        To avoid flushing the LRU cache with one-time requests,\n"
"        we don't cache until a request has been made more than once.\n"
"\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxrequests=4096, cache_after=1):\n"
"        self.requests = OrderedDict()   # { uncached_key : request_count }\n"
"        self.cache = OrderedDict()      # { cached_key : function_result }\n"
"        self.func = func\n"
"        self.maxrequests = maxrequests  # max number of uncached requests\n"
"        self.maxsize = maxsize          # max number of stored return "
"values\n"
"        self.cache_after = cache_after\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            return self.cache[args]\n"
"        result = self.func(*args)\n"
"        self.requests[args] = self.requests.get(args, 0) + 1\n"
"        if self.requests[args] <= self.cache_after:\n"
"            self.requests.move_to_end(args)\n"
"            if len(self.requests) > self.maxrequests:\n"
"                self.requests.popitem(last=False)\n"
"        else:\n"
"            self.requests.pop(args, None)\n"
"            self.cache[args] = result\n"
"            if len(self.cache) > self.maxsize:\n"
"                self.cache.popitem(last=False)\n"
"        return result"
msgstr ""

#: ../../library/collections.rst:1309
msgid ":class:`UserDict` objects"
msgstr ":class:`UserDict` オブジェクト"

#: ../../library/collections.rst:1311
msgid ""
"The class, :class:`UserDict` acts as a wrapper around dictionary objects. "
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`dict`; however, this class can be easier to "
"work with because the underlying dictionary is accessible as an attribute."
msgstr ""
"クラス :class:`UserDict` は、辞書オブジェクトのラッパとしてはたらきます。この"
"クラスの必要性は、 :class:`dict` から直接的にサブクラス化できる能力に部分的に"
"取って代わられました; しかし、根底の辞書に属性としてアクセスできるので、この"
"クラスを使った方が簡単になることもあります。"

#: ../../library/collections.rst:1319
msgid ""
"Class that simulates a dictionary.  The instance's contents are kept in a "
"regular dictionary, which is accessible via the :attr:`data` attribute of :"
"class:`UserDict` instances.  If *initialdata* is provided, :attr:`data` is "
"initialized with its contents; note that a reference to *initialdata* will "
"not be kept, allowing it to be used for other purposes."
msgstr ""
"辞書をシミュレートするクラスです。インスタンスの内容は通常の辞書に保存さ"
"れ、 :class:`UserDict` インスタンスの :attr:`data` 属性を通してアクセスできま"
"す。 *initialdata* が与えられれば、 :attr:`data` はその内容で初期化されます。"
"他の目的のために使えるように、 *initialdata* への参照が保存されないことに注意"
"してください。"

#: ../../library/collections.rst:1325
msgid ""
"In addition to supporting the methods and operations of mappings, :class:"
"`UserDict` instances provide the following attribute:"
msgstr ""
"マッピングのメソッドと演算をサポートするのに加え、 :class:`UserDict` インスタ"
"ンスは以下の属性を提供します:"

#: ../../library/collections.rst:1330
msgid ""
"A real dictionary used to store the contents of the :class:`UserDict` class."
msgstr ":class:`UserDict` クラスの内容を保存するために使われる実際の辞書です。"

#: ../../library/collections.rst:1336
msgid ":class:`UserList` objects"
msgstr ":class:`UserList` オブジェクト"

#: ../../library/collections.rst:1338
msgid ""
"This class acts as a wrapper around list objects.  It is a useful base class "
"for your own list-like classes which can inherit from them and override "
"existing methods or add new ones.  In this way, one can add new behaviors to "
"lists."
msgstr ""
"このクラスはリストオブジェクトのラッパとしてはたらきます。これは独自のリスト"
"風クラスの基底クラスとして便利で、既存のメソッドをオーバーライドしたり新しい"
"メソッドを加えたりできます。こうして、リストに新しい振る舞いを加えられます。"

#: ../../library/collections.rst:1343
msgid ""
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`list`; however, this class can be easier to "
"work with because the underlying list is accessible as an attribute."
msgstr ""
"このクラスの必要性は、 :class:`list` から直接的にサブクラス化できる能力に部分"
"的に取って代わられました; しかし、根底のリストに属性としてアクセスできるの"
"で、このクラスを使った方が簡単になることもあります。"

#: ../../library/collections.rst:1349
msgid ""
"Class that simulates a list.  The instance's contents are kept in a regular "
"list, which is accessible via the :attr:`data` attribute of :class:"
"`UserList` instances.  The instance's contents are initially set to a copy "
"of *list*, defaulting to the empty list ``[]``.  *list* can be any iterable, "
"for example a real Python list or a :class:`UserList` object."
msgstr ""
"リストをシミュレートするクラスです。インスタンスの内容は通常のリストに保存さ"
"れ、 :class:`UserList` インスタンスの :attr:`data` 属性を通してアクセスできま"
"す。インスタンスの内容は最初に *list* のコピーに設定されますが、デフォルトで"
"は空リスト ``[]`` です。 *list* は何らかのイテラブル、例えば通常の Python リ"
"ストや :class:`UserList` オブジェクト、です。"

#: ../../library/collections.rst:1355
msgid ""
"In addition to supporting the methods and operations of mutable sequences, :"
"class:`UserList` instances provide the following attribute:"
msgstr ""
"ミュータブルシーケンスのメソッドと演算をサポートするのに加え、 :class:"
"`UserList` インスタンスは以下の属性を提供します:"

#: ../../library/collections.rst:1360
msgid ""
"A real :class:`list` object used to store the contents of the :class:"
"`UserList` class."
msgstr ""
":class:`UserList` クラスの内容を保存するために使われる実際の :class:`list` オ"
"ブジェクトです。"

#: ../../library/collections.rst:1363
msgid ""
"**Subclassing requirements:** Subclasses of :class:`UserList` are expected "
"to offer a constructor which can be called with either no arguments or one "
"argument.  List operations which return a new sequence attempt to create an "
"instance of the actual implementation class.  To do so, it assumes that the "
"constructor can be called with a single parameter, which is a sequence "
"object used as a data source."
msgstr ""
"**サブクラス化の要件:** :class:`UserList` のサブクラスは引数なしか、あるいは"
"一つの引数のどちらかとともに呼び出せるコンストラクタを提供することが期待され"
"ています。新しいシーケンスを返すリスト演算は現在の実装クラスのインスタンスを"
"作成しようとします。そのために、データ元として使われるシーケンスオブジェクト"
"である一つのパラメータとともにコンストラクタを呼び出せると想定しています。"

#: ../../library/collections.rst:1370
msgid ""
"If a derived class does not wish to comply with this requirement, all of the "
"special methods supported by this class will need to be overridden; please "
"consult the sources for information about the methods which need to be "
"provided in that case."
msgstr ""
"派生クラスがこの要求に従いたくないならば、このクラスがサポートしているすべて"
"の特殊メソッドはオーバーライドされる必要があります。その場合に提供される必要"
"のあるメソッドについての情報は、ソースを参考にしてください。"

#: ../../library/collections.rst:1376
msgid ":class:`UserString` objects"
msgstr ":class:`UserString` オブジェクト"

#: ../../library/collections.rst:1378
msgid ""
"The class, :class:`UserString` acts as a wrapper around string objects. The "
"need for this class has been partially supplanted by the ability to subclass "
"directly from :class:`str`; however, this class can be easier to work with "
"because the underlying string is accessible as an attribute."
msgstr ""
"クラス :class:`UserString` は、文字列オブジェクトのラッパとしてはたらきます。"
"このクラスの必要性は、 :class:`str` から直接的にサブクラス化できる能力に部分"
"的に取って代わられました; しかし、根底の文字列に属性としてアクセスできるの"
"で、このクラスを使った方が簡単になることもあります。"

#: ../../library/collections.rst:1386
msgid ""
"Class that simulates a string object.  The instance's content is kept in a "
"regular string object, which is accessible via the :attr:`data` attribute "
"of :class:`UserString` instances.  The instance's contents are initially set "
"to a copy of *seq*.  The *seq* argument can be any object which can be "
"converted into a string using the built-in :func:`str` function."
msgstr ""
"文字列オブジェクトをシミュレートするクラスです。\n"
"インスタンスの内容は通常の文字列に保存され、 :class:`UserString` インスタンス"
"の :attr:`data` 属性を通してアクセスできます。\n"
"インスタンスの内容には最初に *seq* のコピーが設定されます。\n"
"*seq* 引数は、組み込みの :func:`str` 関数で文字列に変換できる任意のオブジェク"
"トです。"

#: ../../library/collections.rst:1393
msgid ""
"In addition to supporting the methods and operations of strings, :class:"
"`UserString` instances provide the following attribute:"
msgstr ""
"文字列のメソッドと演算をサポートするのに加え、 :class:`UserString` インスタン"
"スは次の属性を提供します:"

#: ../../library/collections.rst:1398
msgid ""
"A real :class:`str` object used to store the contents of the :class:"
"`UserString` class."
msgstr ""
":class:`UserString` クラスの内容を保存するために使われる実際の :class:`str` "
"オブジェクトです。"

#: ../../library/collections.rst:1401
msgid ""
"New methods ``__getnewargs__``, ``__rmod__``, ``casefold``, ``format_map``, "
"``isprintable``, and ``maketrans``."
msgstr ""
"新たなメソッド ``__getnewargs__``, ``__rmod__``, ``casefold``, "
"``format_map``, ``isprintable``, ``maketrans``。"
