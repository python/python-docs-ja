# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト)
# This file is distributed under the same license as the Python package.
# 
# Translators:
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: 2017-02-19 15:58+0000\n"
"Last-Translator: cocoatomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/multifile.rst:3
msgid ":mod:`multifile` --- Support for files containing distinct parts"
msgstr ":mod:`multifile` --- 個別の部分を含んだファイル群のサポート"

#: ../../library/multifile.rst:11
msgid ""
"The :mod:`email` package should be used in preference to the "
":mod:`multifile` module. This module is present only to maintain backward "
"compatibility."
msgstr ":mod:`multifile` モジュールよりも :mod:`email` パッケージを使うべきです。このモジュールは後方互換性のためだけに存在しています。"

#: ../../library/multifile.rst:15
msgid ""
"The :class:`MultiFile` object enables you to treat sections of a text file "
"as file-like input objects, with ``''`` being returned by :meth:`readline` "
"when a given delimiter pattern is encountered.  The defaults of this class "
"are designed to make it useful for parsing MIME multipart messages, but by "
"subclassing it and overriding methods  it can be easily adapted for more "
"general use."
msgstr ":class:`MultiFile` オブジェクトは、テキストファイルのセクション分割をファイル類似の入力オブジェクトのように扱えるようにします。指定したデリミタのパターンに遭遇すると :meth:`readline` が ``''`` を返します。このクラスの標準設定は MIME マルチパートメッセージを解釈する上で便利となるように設計されていますが、サブクラス化を行って幾つかのメソッドを上書きすることで、簡単に汎用目的に対応させることができます。"

#: ../../library/multifile.rst:24
msgid ""
"Create a multi-file.  You must instantiate this class with an input object "
"argument for the :class:`MultiFile` instance to get lines from, such as a "
"file object returned by :func:`open`."
msgstr "マルチファイルを生成します。*fp* 引数には、例えば :func:`open` が返すファイルオブジェクトのような、:class:`MultiFile` インスタンスが行データを取得出来るオブジェクトを渡す必要があります。"

#: ../../library/multifile.rst:28
msgid ""
":class:`MultiFile` only ever looks at the input object's :meth:`readline`, "
":meth:`seek` and :meth:`tell` methods, and the latter two are only needed if"
" you want random access to the individual MIME parts. To use "
":class:`MultiFile` on a non-seekable stream object, set the optional "
"*seekable* argument to false; this will prevent using the input object's "
":meth:`seek` and :meth:`tell` methods."
msgstr ":class:`MultiFile` は入力オブジェクトの :meth:`readline` 、 :meth:`seek` 、および :meth:`tell` メソッドしか参照せず、後者の二つのメソッドは個々の MIME パートにランダムアクセスしたい場合にのみ必要です。 :class:`MultiFile` を seek できないストリームオブジェクトで使うには、オプションの *seekable* 引数の値を偽にしてください; これにより、入力オブジェクトの :meth:`seek` および :meth:`tell` メソッドを使わないようになります。"

#: ../../library/multifile.rst:34
msgid ""
"It will be useful to know that in :class:`MultiFile`'s view of the world, "
"text is composed of three kinds of lines: data, section-dividers, and end-"
"markers. MultiFile is designed to support parsing of messages that may have "
"multiple nested message parts, each with its own pattern for section-divider"
" and end-marker lines."
msgstr ":class:`MultiFile` の視点から見ると、テキストは三種類の行データ: データ、セクション分割子、終了マーカ、からなることを知っていると役に立つでしょう。 MultiFile は、多重入れ子構造になっている可能性のある、それぞれが独自のセクション分割子および終了マーカのパターンを持つメッセージパートをサポートするように設計されています。"

#: ../../library/multifile.rst:43
msgid "Module :mod:`email`"
msgstr ":mod:`email` モジュール"

#: ../../library/multifile.rst:44
msgid ""
"Comprehensive email handling package; supersedes the :mod:`multifile` "
"module."
msgstr "包括的な e-mail 処理パッケージです。 :mod:`multifile` に取って代わります。"

#: ../../library/multifile.rst:50
msgid "MultiFile Objects"
msgstr "MultiFile オブジェクト"

#: ../../library/multifile.rst:52
msgid "A :class:`MultiFile` instance has the following methods:"
msgstr ":class:`MultiFile` インスタンスは以下のメソッドを持っています:"

#: ../../library/multifile.rst:57
msgid ""
"Read a line.  If the line is data (not a section-divider or end-marker or "
"real EOF) return it.  If the line matches the most-recently-stacked "
"boundary, return ``''`` and set ``self.last`` to 1 or 0 according as the "
"match is or is not an end-marker.  If the line matches any other stacked "
"boundary, raise an error.  On encountering end-of-file on the underlying "
"stream object, the method raises :exc:`Error` unless all boundaries have "
"been popped."
msgstr "一行データを読みます。その行が (セクション分割子や終了マーカや本物の EOF でない) データの場合、行データを返します。その行がもっとも最近スタックにプッシュされた境界パターンにマッチした場合、 ``''`` を返し、マッチした内容が終了マーカかそうでないかによって ``self.last`` を 1 か 0 に設定します。行がその他のスタックされている境界パターンにマッチした場合、エラーが送出されます。背後のストリームオブジェクトにおけるファイルの終端に到達した場合、全ての境界がスタックから除去されていない限りこのメソッドは :exc:`Error` を送出します。"

#: ../../library/multifile.rst:67
msgid "Return all lines remaining in this part as a list of strings."
msgstr "このパートの残りの全ての行を文字列のリストとして返します。"

#: ../../library/multifile.rst:72
msgid ""
"Read all lines, up to the next section.  Return them as a single (multiline)"
" string.  Note that this doesn't take a size argument!"
msgstr "次のセクションまでの全ての行を読みます。読んだ内容を単一の (複数行にわたる) 文字列として返します。このメソッドには size 引数をとらないので注意してください!"

#: ../../library/multifile.rst:78
msgid ""
"Seek.  Seek indices are relative to the start of the current section. The "
"*pos* and *whence* arguments are interpreted as for a file seek."
msgstr "ファイルを seek します。 seek する際のインデクスは現在のセクションの開始位置からの相対位置になります。 *pos* および *whence* 引数はファイルの seek における引数と同じように解釈されます。"

#: ../../library/multifile.rst:84
msgid "Return the file position relative to the start of the current section."
msgstr "現在のセクションの先頭に対して相対的なファイル位置を返します。"

#: ../../library/multifile.rst:89
msgid ""
"Skip lines to the next section (that is, read lines until a section-divider "
"or end-marker has been consumed).  Return true if there is such a section, "
"false if an end-marker is seen.  Re-enable the most-recently-pushed "
"boundary."
msgstr "次のセクションまで行を読み飛ばします (すなわち、セクション分割子または終了マーカが消費されるまで行データを読みます)。次のセクションがあった場合には真を、終了マーカが発見された場合には偽を返します。最も最近スタックにプッシュされた境界パターンを最有効化します。"

#: ../../library/multifile.rst:96
msgid ""
"Return true if *str* is data and false if it might be a section boundary.  "
"As written, it tests for a prefix other than ``'-``\\ ``-'`` at start of "
"line (which all MIME boundaries have) but it is declared so it can be "
"overridden in derived classes."
msgstr "*str* がデータの場合に真を返し、セクション分割子の可能性がある場合には偽を返します。このメソッドは行の先頭が (全ての MIME 境界が持っている) ``'-``\\ ``-'`` 以外になっているかを調べるように実装されていますが、派生クラスで上書きできるように宣言されています。"

#: ../../library/multifile.rst:101
msgid ""
"Note that this test is used intended as a fast guard for the real boundary "
"tests; if it always returns false it will merely slow processing, not cause "
"it to fail."
msgstr "このテストは実際の境界テストにおいて高速性を保つために使われているので注意してください; このテストが常に false を返す場合、テストが失敗するのではなく、単に処理が遅くなるだけです。"

#: ../../library/multifile.rst:108
msgid ""
"Push a boundary string.  When a decorated version of this boundary  is found"
" as an input line, it will be interpreted as a section-divider  or end-"
"marker (depending on the decoration, see :rfc:`2045`).  All subsequent reads"
" will return the empty string to indicate end-of-file, until a call to "
":meth:`pop` removes the boundary a or :meth:`.next` call reenables it."
msgstr "境界文字列をスタックにプッシュします。この境界文字列の修飾されたバージョンが入力行に見つかった場合、セクション分割子または終了マーカであると解釈されます(どちらであるかは修飾に依存します。 :rfc:`2045` を参照してください)。それ以降の全てのデータ読み出しは、 :meth:`pop` を呼んで境界文字列を除去するか、 :meth:`.next` を呼んで境界文字列を再有効化しないかぎり、ファイル終端を示す空文字列を返します。"

#: ../../library/multifile.rst:114
msgid ""
"It is possible to push more than one boundary.  Encountering the most-"
"recently-pushed boundary will return EOF; encountering any other boundary "
"will raise an error."
msgstr "一つ以上の境界をプッシュすることは可能です。もっとも最近プッシュされた境界に遭遇すると EOF が返ります; その他の境界に遭遇するとエラーが送出されます。"

#: ../../library/multifile.rst:121
msgid ""
"Pop a section boundary.  This boundary will no longer be interpreted as EOF."
msgstr "セクション境界をポップします。この境界はもはや EOF として解釈されません。"

#: ../../library/multifile.rst:126
msgid ""
"Turn a boundary into a section-divider line.  By default, this method "
"prepends ``'--'`` (which MIME section boundaries have) but it is declared so"
" it can be overridden in derived classes.  This method need not append LF or"
" CR-LF, as comparison with the result ignores trailing whitespace."
msgstr "境界をセクション分割子にします。標準では、このメソッドは (全ての MIME 境界が持っている) ``'--'`` を境界文字列の先頭に追加しますが、これは派生クラスで上書きできるように宣言されています。末尾の空白は無視されることから考えて、このメソッドでは LF や CR-LF を追加する必要はありません。"

#: ../../library/multifile.rst:134
msgid ""
"Turn a boundary string into an end-marker line.  By default, this method "
"prepends ``'--'`` and appends ``'--'`` (like a MIME-multipart end-of-message"
" marker) but it is declared so it can be overridden in derived classes.  "
"This method need not append LF or CR-LF, as comparison with the result "
"ignores trailing whitespace."
msgstr "境界文字列を終了マーカ行にします。標準では、このメソッドは (MIME マルチパートデータのメッセージ終了マーカのように) ``'--'`` を境界文字列の先頭に追加し、かつ ``'--'`` を境界文字列の末尾に追加しますが、これは派生クラスで上書きできるように宣言されています。末尾の空白は無視されることから考えて、このメソッドでは LF や CR-LF を追加する必要はありません。"

#: ../../library/multifile.rst:140
msgid ""
"Finally, :class:`MultiFile` instances have two public instance variables:"
msgstr "最後に、 :class:`MultiFile` インスタンスは二つの公開されたインスタンス変数を持っています:"

#: ../../library/multifile.rst:145
msgid "Nesting depth of the current part."
msgstr "現在のパートにおける入れ子の深さです。"

#: ../../library/multifile.rst:150
msgid "True if the last end-of-file was for an end-of-message marker."
msgstr "最後に見つかったファイル終了イベントがメッセージ終了マーカであった場合に真となります。"

#: ../../library/multifile.rst:156
msgid ":class:`MultiFile` Example"
msgstr ":class:`MultiFile` の例"
