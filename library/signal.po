# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-30 14:59+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/signal.rst:2
msgid ":mod:`signal` --- Set handlers for asynchronous events"
msgstr ":mod:`signal` --- 非同期イベントにハンドラを設定する"

#: ../../library/signal.rst:7
msgid "**Source code:** :source:`Lib/signal.py`"
msgstr "**ソースコード:** :source:`Lib/signal.py`"

#: ../../library/signal.rst:11
msgid "This module provides mechanisms to use signal handlers in Python."
msgstr ""
"このモジュールでは Python でシグナルハンドラを使うための機構を提供します。"

#: ../../library/signal.rst:15
msgid "General rules"
msgstr "一般的なルール"

#: ../../library/signal.rst:17
msgid ""
"The :func:`signal.signal` function allows defining custom handlers to be "
"executed when a signal is received.  A small number of default handlers are "
"installed: :const:`SIGPIPE` is ignored (so write errors on pipes and sockets "
"can be reported as ordinary Python exceptions) and :const:`SIGINT` is "
"translated into a :exc:`KeyboardInterrupt` exception if the parent process "
"has not changed it."
msgstr ""

#: ../../library/signal.rst:24
msgid ""
"A handler for a particular signal, once set, remains installed until it is "
"explicitly reset (Python emulates the BSD style interface regardless of the "
"underlying implementation), with the exception of the handler for :const:"
"`SIGCHLD`, which follows the underlying implementation."
msgstr ""
"特定のシグナルに対するハンドラが一度設定されると、明示的にリセットしないかぎ"
"り設定されたままになります (Python は背後の実装系に関係なく BSD 形式のイン"
"ターフェースをエミュレートします)。例外は :const:`SIGCHLD` のハンドラで、この"
"場合は背後の実装系の仕様に従います。"

#: ../../library/signal.rst:31
msgid "Execution of Python signal handlers"
msgstr "Python のシグナルハンドラの実行"

#: ../../library/signal.rst:33
msgid ""
"A Python signal handler does not get executed inside the low-level (C) "
"signal handler.  Instead, the low-level signal handler sets a flag which "
"tells the :term:`virtual machine` to execute the corresponding Python signal "
"handler at a later point(for example at the next :term:`bytecode` "
"instruction). This has consequences:"
msgstr ""
"Python のシグナルハンドラは、低水準 (C言語) のシグナルハンドラ内で実行される"
"わけではありません。代わりに、低水準のシグナルハンドラが :term:`virtual "
"machine` が対応する Python のシグナルハンドラを後から (例えば次の :term:"
"`bytecode` 命令時に) 実行するようにフラグを立てます:"

#: ../../library/signal.rst:39
msgid ""
"It makes little sense to catch synchronous errors like :const:`SIGFPE` or :"
"const:`SIGSEGV` that are caused by an invalid operation in C code.  Python "
"will return from the signal handler to the C code, which is likely to raise "
"the same signal again, causing Python to apparently hang.  From Python 3.3 "
"onwards, you can use the :mod:`faulthandler` module to report on synchronous "
"errors."
msgstr ""

#: ../../library/signal.rst:46
msgid ""
"A long-running calculation implemented purely in C (such as regular "
"expression matching on a large body of text) may run uninterrupted for an "
"arbitrary amount of time, regardless of any signals received.  The Python "
"signal handlers will be called when the calculation finishes."
msgstr ""
"完全にCで実装された長時間かかる計算 (大きいテキストに対する正規表現のマッチな"
"ど) は、どのシグナルを受信しても中断されないまま長時間実行され続ける可能性が"
"あります。Python のシグナルハンドラはその計算が終了してから呼び出されます。"

#: ../../library/signal.rst:51
msgid ""
"If the handler raises an exception, it will be raised \"out of thin air\" in "
"the main thread. See the :ref:`note below <handlers-and-exceptions>` for a "
"discussion."
msgstr ""

#: ../../library/signal.rst:59
msgid "Signals and threads"
msgstr "シグナルとスレッド"

#: ../../library/signal.rst:61
msgid ""
"Python signal handlers are always executed in the main Python thread of the "
"main interpreter, even if the signal was received in another thread.  This "
"means that signals can't be used as a means of inter-thread communication.  "
"You can use the synchronization primitives from the :mod:`threading` module "
"instead."
msgstr ""
"Python のシグナルハンドラは、もしシグナルを受け取ったのが別のスレッドだったと"
"しても、常にメインインタープリターの Python のメインスレッドで実行されます。"
"このためシグナルをスレッド間通信に使うことはできません。代わりに :mod:"
"`threading` モジュールが提供している同期プリミティブを利用できます。"

#: ../../library/signal.rst:66
msgid ""
"Besides, only the main thread of the main interpreter is allowed to set a "
"new signal handler."
msgstr ""
"また、メインインタープリターのメインスレッドだけが新しいシグナルハンドラを登"
"録できます。"

#: ../../library/signal.rst:70
msgid "Module contents"
msgstr "モジュールの内容"

#: ../../library/signal.rst:72
msgid ""
"signal (SIG*), handler (:const:`SIG_DFL`, :const:`SIG_IGN`) and sigmask (:"
"const:`SIG_BLOCK`, :const:`SIG_UNBLOCK`, :const:`SIG_SETMASK`) related "
"constants listed below were turned into :class:`enums <enum.IntEnum>`. :func:"
"`getsignal`, :func:`pthread_sigmask`, :func:`sigpending` and :func:`sigwait` "
"functions return human-readable :class:`enums <enum.IntEnum>`."
msgstr ""

#: ../../library/signal.rst:82
msgid "The variables defined in the :mod:`signal` module are:"
msgstr "以下に :mod:`signal` モジュールで定義されている変数を示します:"

#: ../../library/signal.rst:87
msgid ""
"This is one of two standard signal handling options; it will simply perform "
"the default function for the signal.  For example, on most systems the "
"default action for :const:`SIGQUIT` is to dump core and exit, while the "
"default action for :const:`SIGCHLD` is to simply ignore it."
msgstr ""
"二つある標準シグナル処理オプションのうちの一つです; 単純にシグナルに対する標"
"準の関数を実行します。例えば、ほとんどのシステムでは、 :const:`SIGQUIT` に対"
"する標準の動作はコアダンプと終了で、 :const:`SIGCHLD` に対する標準の動作は単"
"にシグナルの無視です。"

#: ../../library/signal.rst:95
msgid ""
"This is another standard signal handler, which will simply ignore the given "
"signal."
msgstr ""
"もう一つの標準シグナル処理オプションで、受け取ったシグナルを単に無視します。"

#: ../../library/signal.rst:101
msgid "Abort signal from :manpage:`abort(3)`."
msgstr ""

#: ../../library/signal.rst:105
msgid "Timer signal from :manpage:`alarm(2)`."
msgstr ""

#: ../../library/signal.rst:107 ../../library/signal.rst:119
#: ../../library/signal.rst:125 ../../library/signal.rst:135
#: ../../library/signal.rst:149 ../../library/signal.rst:167
#: ../../library/signal.rst:175 ../../library/signal.rst:189
#: ../../library/signal.rst:195 ../../library/signal.rst:201
#: ../../library/signal.rst:452 ../../library/signal.rst:459
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`利用可能な環境 <availability>`: Unix。"

#: ../../library/signal.rst:111
msgid "Interrupt from keyboard (CTRL + BREAK)."
msgstr ""

#: ../../library/signal.rst:113 ../../library/signal.rst:220
#: ../../library/signal.rst:230
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`利用可能な環境 <availability>`: Windows 。"

#: ../../library/signal.rst:117
msgid "Bus error (bad memory access)."
msgstr ""

#: ../../library/signal.rst:123
msgid "Child process stopped or terminated."
msgstr ""

#: ../../library/signal.rst:129
msgid "Alias to :data:`SIGCHLD`."
msgstr ":data:`SIGCHLD` のエイリアスです。"

#: ../../library/signal.rst:133
msgid "Continue the process if it is currently stopped"
msgstr ""

#: ../../library/signal.rst:139
msgid "Floating-point exception. For example, division by zero."
msgstr ""

#: ../../library/signal.rst:142
msgid ""
":exc:`ZeroDivisionError` is raised when the second argument of a division or "
"modulo operation is zero."
msgstr ""

#: ../../library/signal.rst:147
msgid ""
"Hangup detected on controlling terminal or death of controlling process."
msgstr ""

#: ../../library/signal.rst:153
msgid "Illegal instruction."
msgstr ""

#: ../../library/signal.rst:157
msgid "Interrupt from keyboard (CTRL + C)."
msgstr ""

#: ../../library/signal.rst:159
msgid "Default action is to raise :exc:`KeyboardInterrupt`."
msgstr ""

#: ../../library/signal.rst:163
msgid "Kill signal."
msgstr ""

#: ../../library/signal.rst:165
msgid "It cannot be caught, blocked, or ignored."
msgstr ""

#: ../../library/signal.rst:171
msgid "Broken pipe: write to pipe with no readers."
msgstr ""

#: ../../library/signal.rst:173
msgid "Default action is to ignore the signal."
msgstr ""

#: ../../library/signal.rst:179
msgid "Segmentation fault: invalid memory reference."
msgstr ""

#: ../../library/signal.rst:183
msgid "Termination signal."
msgstr ""

#: ../../library/signal.rst:187
msgid "User-defined signal 1."
msgstr ""

#: ../../library/signal.rst:193
msgid "User-defined signal 2."
msgstr ""

#: ../../library/signal.rst:199
msgid "Window resize signal."
msgstr ""

#: ../../library/signal.rst:205
msgid ""
"All the signal numbers are defined symbolically.  For example, the hangup "
"signal is defined as :const:`signal.SIGHUP`; the variable names are "
"identical to the names used in C programs, as found in ``<signal.h>``.  The "
"Unix man page for ':c:func:`signal`' lists the existing signals (on some "
"systems this is :manpage:`signal(2)`, on others the list is in :manpage:"
"`signal(7)`). Note that not all systems define the same set of signal names; "
"only those names defined by the system are defined by this module."
msgstr ""
"全てのシグナル番号はシンボル定義されています。例えば、ハングアップシグナル"
"は :const:`signal.SIGHUP` で定義されています; 変数名は C 言語のプログラムで使"
"われているのと同じ名前で、 ``<signal.h>`` にあります。 ':c:func:`signal`' に"
"関する Unix マニュアルページでは、システムで定義されているシグナルを列挙して"
"います (あるシステムではリストは :manpage:`signal(2)` に、別のシステムでは :"
"manpage:`signal(7)` に列挙されています)。全てのシステムで同じシグナル名のセッ"
"トを定義しているわけではないので注意してください; このモジュールでは、システ"
"ムで定義されているシグナル名だけを定義しています。"

#: ../../library/signal.rst:216
msgid ""
"The signal corresponding to the :kbd:`Ctrl+C` keystroke event. This signal "
"can only be used with :func:`os.kill`."
msgstr ""
":kbd:`CTRL+C` キーストロークに該当するシグナル。このシグナルは :func:`os."
"kill` でだけ利用できます。"

#: ../../library/signal.rst:226
msgid ""
"The signal corresponding to the :kbd:`Ctrl+Break` keystroke event. This "
"signal can only be used with :func:`os.kill`."
msgstr ""
":kbd:`CTRL+BREAK` キーストロークに該当するシグナル。このシグナルは :func:`os."
"kill` でだけ利用できます。"

#: ../../library/signal.rst:236
msgid "One more than the number of the highest signal number."
msgstr "最も大きいシグナル番号に 1 を足した値です。"

#: ../../library/signal.rst:241
msgid ""
"Decrements interval timer in real time, and delivers :const:`SIGALRM` upon "
"expiration."
msgstr ""
"実時間でデクリメントするインターバルタイマーです。タイマーが発火したときに :"
"const:`SIGALRM` を送ります。"

#: ../../library/signal.rst:247
msgid ""
"Decrements interval timer only when the process is executing, and delivers "
"SIGVTALRM upon expiration."
msgstr ""
"プロセスの実行時間だけデクリメントするインターバルタイマーです。タイマーが発"
"火したときに :const:`SIGVTALRM` を送ります。"

#: ../../library/signal.rst:253
msgid ""
"Decrements interval timer both when the process executes and when the system "
"is executing on behalf of the process. Coupled with ITIMER_VIRTUAL, this "
"timer is usually used to profile the time spent by the application in user "
"and kernel space. SIGPROF is delivered upon expiration."
msgstr ""
"プロセスの実行中と、システムがそのプロセスのために実行している時間だけデクリ"
"メントするインターバルタイマーです。ITIMER_VIRTUAL と組み合わせて、このタイ"
"マーはよくアプリケーションがユーザー空間とカーネル空間で消費した時間のプロ"
"ファイリングに利用されます。タイマーが発火したときに :const:`SIGPROF` を送り"
"ます。"

#: ../../library/signal.rst:261
msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that signals are to be blocked."
msgstr ""
":func:`pthread_sigmask` の *how* 引数に渡せる値で、シグナルがブロックされるこ"
"とを意味します。"

#: ../../library/signal.rst:268
msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that signals are to be unblocked."
msgstr ""
":func:`pthread_sigmask` の *how* 引数に渡せる値で、シグナルがブロック解除され"
"ることを意味します。"

#: ../../library/signal.rst:275
msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that the signal mask is to be replaced."
msgstr ""
":func:`pthread_sigmask` の *how* 引数に渡せる値で、シグナルが置換されることを"
"意味します。"

#: ../../library/signal.rst:281
msgid "The :mod:`signal` module defines one exception:"
msgstr ":mod:`signal` モジュールは1つの例外を定義しています:"

#: ../../library/signal.rst:285
msgid ""
"Raised to signal an error from the underlying :func:`setitimer` or :func:"
"`getitimer` implementation. Expect this error if an invalid interval timer "
"or a negative time is passed to :func:`setitimer`. This error is a subtype "
"of :exc:`OSError`."
msgstr ""
"背後の :func:`setitimer` または :func:`getitimer` 実装からエラーを通知するた"
"めに送出されます。無効なインタバルタイマーや負の時間が :func:`setitimer` に渡"
"された場合、このエラーを予期してください。このエラーは :exc:`OSError` を継承"
"しています。"

#: ../../library/signal.rst:290
msgid ""
"This error used to be a subtype of :exc:`IOError`, which is now an alias of :"
"exc:`OSError`."
msgstr ""
"このエラーは以前は :exc:`IOError` のサブタイプでしたが、 :exc:`OSError` のエ"
"イリアスになりました。"

#: ../../library/signal.rst:295
msgid "The :mod:`signal` module defines the following functions:"
msgstr ":mod:`signal` モジュールでは以下の関数を定義しています:"

#: ../../library/signal.rst:300
msgid ""
"If *time* is non-zero, this function requests that a :const:`SIGALRM` signal "
"be sent to the process in *time* seconds. Any previously scheduled alarm is "
"canceled (only one alarm can be scheduled at any time).  The returned value "
"is then the number of seconds before any previously set alarm was to have "
"been delivered. If *time* is zero, no alarm is scheduled, and any scheduled "
"alarm is canceled.  If the return value is zero, no alarm is currently "
"scheduled."
msgstr ""
"*time* がゼロでない値の場合、この関数は *time* 秒後頃に :const:`SIGALRM` をプ"
"ロセスに送るように要求します。それ以前にスケジュールしたアラームはキャンセル"
"されます (常に一つのアラームしかスケジュールできません)。この場合、戻り値は以"
"前に設定されたアラームシグナルが通知されるまであと何秒だったかを示す値です。 "
"*time* がゼロの場合、アラームは一切スケジュールされず、現在スケジュールされて"
"いるアラームがキャンセルされます。戻り値がゼロの場合、現在アラームがスケ"
"ジュールされていないことを示します。"

#: ../../library/signal.rst:308
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`alarm(2)` for further information."
msgstr ""
":ref:`利用可能な環境 <availability>`: Unix。さらに詳しい情報についてはオンラ"
"インマニュアルページ :manpage:`alarm(2)` を参照してください。"

#: ../../library/signal.rst:313
msgid ""
"Return the current signal handler for the signal *signalnum*. The returned "
"value may be a callable Python object, or one of the special values :const:"
"`signal.SIG_IGN`, :const:`signal.SIG_DFL` or :const:`None`.  Here, :const:"
"`signal.SIG_IGN` means that the signal was previously ignored, :const:"
"`signal.SIG_DFL` means that the default way of handling the signal was "
"previously in use, and ``None`` means that the previous signal handler was "
"not installed from Python."
msgstr ""
"シグナル *signalnum* に対する現在のシグナルハンドラを返します。戻り値は呼び出"
"し可能な Python オブジェクトか、 :const:`signal.SIG_IGN`\\ 、 :const:`signal."
"SIG_DFL`\\ 、および :const:`None` といった特殊な値のいずれかです。ここで :"
"const:`signal.SIG_IGN` は以前そのシグナルが無視されていたことを示し、 :const:"
"`signal.SIG_DFL` は以前そのシグナルの標準の処理方法が使われていたことを示"
"し、 ``None`` はシグナルハンドラがまだ Python によってインストールされていな"
"いことを示します。"

#: ../../library/signal.rst:324
msgid ""
"Return the system description of the signal *signalnum*, such as "
"\"Interrupt\", \"Segmentation fault\", etc. Returns :const:`None` if the "
"signal is not recognized."
msgstr ""

#: ../../library/signal.rst:333
msgid ""
"Return the set of valid signal numbers on this platform.  This can be less "
"than ``range(1, NSIG)`` if some signals are reserved by the system for "
"internal use."
msgstr ""

#: ../../library/signal.rst:342
msgid ""
"Cause the process to sleep until a signal is received; the appropriate "
"handler will then be called.  Returns nothing."
msgstr ""
"シグナルを受け取るまでプロセスを一時停止します; その後、適切なハンドラが呼び"
"出されます。戻り値はありません。"

#: ../../library/signal.rst:347
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`signal(2)` for further information."
msgstr ""
":ref:`利用可能な環境 <availability>`: Unix。さらに詳しい情報についてはオンラ"
"インマニュアルページ :manpage:`signal(2)` を参照してください。"

#: ../../library/signal.rst:348
msgid ""
"See also :func:`sigwait`, :func:`sigwaitinfo`, :func:`sigtimedwait` and :"
"func:`sigpending`."
msgstr ""
":func:`sigwait`, :func:`sigwaitinfo`, :func:`sigtimedwait` :func:"
"`sigpending` も参照してください。"

#: ../../library/signal.rst:354
msgid "Sends a signal to the calling process. Returns nothing."
msgstr ""

#: ../../library/signal.rst:361
msgid ""
"Send signal *sig* to the process referred to by file descriptor *pidfd*. "
"Python does not currently support the *siginfo* parameter; it must be "
"``None``.  The *flags* argument is provided for future extensions; no flag "
"values are currently defined."
msgstr ""

#: ../../library/signal.rst:366
msgid "See the :manpage:`pidfd_send_signal(2)` man page for more information."
msgstr ""
"さらに詳しい情報についてはオンラインマニュアルページ :manpage:"
"`pidfd_send_signal(2)` を参照してください。"

#: ../../library/signal.rst:368
msgid ":ref:`Availability <availability>`: Linux 5.1+"
msgstr ":ref:`利用可能な環境 <availability>`: Linux 5.1以上"

#: ../../library/signal.rst:374
msgid ""
"Send the signal *signalnum* to the thread *thread_id*, another thread in the "
"same process as the caller.  The target thread can be executing any code "
"(Python or not).  However, if the target thread is executing the Python "
"interpreter, the Python signal handlers will be :ref:`executed by the main "
"thread of the main interpreter <signals-and-threads>`.  Therefore, the only "
"point of sending a signal to a particular Python thread would be to force a "
"running system call to fail with :exc:`InterruptedError`."
msgstr ""

#: ../../library/signal.rst:382
msgid ""
"Use :func:`threading.get_ident()` or the :attr:`~threading.Thread.ident` "
"attribute of :class:`threading.Thread` objects to get a suitable value for "
"*thread_id*."
msgstr ""

#: ../../library/signal.rst:386
msgid ""
"If *signalnum* is 0, then no signal is sent, but error checking is still "
"performed; this can be used to check if the target thread is still running."
msgstr ""

#: ../../library/signal.rst:389
msgid ""
"Raises an :ref:`auditing event <auditing>` ``signal.pthread_kill`` with "
"arguments ``thread_id``, ``signalnum``."
msgstr ""
"引数 ``thread_id``, ``signalnum`` を指定して :ref:`監査イベント <auditing>` "
"``signal.pthread_kill`` を送出します。 "

#: ../../library/signal.rst:393
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`pthread_kill(3)` for further information."
msgstr ""
":ref:`利用可能な環境 <availability>`: Unix。さらに詳しい情報についてはオンラ"
"インマニュアルページ :manpage:`pthread_kill(3)` を参照してください。"

#: ../../library/signal.rst:394
msgid "See also :func:`os.kill`."
msgstr ":func:`os.kill` を参照してください。"

#: ../../library/signal.rst:401
msgid ""
"Fetch and/or change the signal mask of the calling thread.  The signal mask "
"is the set of signals whose delivery is currently blocked for the caller. "
"Return the old signal mask as a set of signals."
msgstr ""
"これを呼び出すスレッドにセットされているシグナルマスクを取り出したり変更した"
"りします。シグナルマスクは、呼び出し側のために現在どのシグナルの配送がブロッ"
"クされているかを示す集合 (set) です。呼び出し前のもとのシグナルマスクを集合と"
"して返却します。"

#: ../../library/signal.rst:405
msgid ""
"The behavior of the call is dependent on the value of *how*, as follows."
msgstr "この関数の振る舞いは *how* に依存して以下のようになります。"

#: ../../library/signal.rst:407
msgid ""
":data:`SIG_BLOCK`: The set of blocked signals is the union of the current "
"set and the *mask* argument."
msgstr ""
":data:`SIG_BLOCK`: *mask* で指定されるシグナルが現時点のシグナルマスクに追加"
"されます。"

#: ../../library/signal.rst:409
msgid ""
":data:`SIG_UNBLOCK`: The signals in *mask* are removed from the current set "
"of blocked signals.  It is permissible to attempt to unblock a signal which "
"is not blocked."
msgstr ""
":data:`SIG_UNBLOCK`: *mask* で指定されるシグナルが現時点のシグナルマスクから"
"取り除かれます。もともとブロックされていないシグナルをブロック解除しようとし"
"ても問題ありません。"

#: ../../library/signal.rst:412
msgid ""
":data:`SIG_SETMASK`: The set of blocked signals is set to the *mask* "
"argument."
msgstr ":data:`SIG_SETMASK`: シグナルマスク全体を *mask* としてセットします。"

#: ../../library/signal.rst:415
msgid ""
"*mask* is a set of signal numbers (e.g. {:const:`signal.SIGINT`, :const:"
"`signal.SIGTERM`}). Use :func:`~signal.valid_signals` for a full mask "
"including all signals."
msgstr ""
"*mask* はシグナル番号の集合です (例えば {:const:`signal.SIGINT`, :const:"
"`signal.SIGTERM`})。全てのシグナルを含む全集合として :func:`~signal."
"valid_signals` を使うことが出来ます。"

#: ../../library/signal.rst:419
msgid ""
"For example, ``signal.pthread_sigmask(signal.SIG_BLOCK, [])`` reads the "
"signal mask of the calling thread."
msgstr ""
"呼び出しスレッドにセットされたシグナルマスクを問い合わせるには例えば "
"``signal.pthread_sigmask(signal.SIG_BLOCK, [])`` とします。"

#: ../../library/signal.rst:422
msgid ":data:`SIGKILL` and :data:`SIGSTOP` cannot be blocked."
msgstr ""

#: ../../library/signal.rst:426
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`sigprocmask(2)` and :manpage:`pthread_sigmask(3)` for further information."
msgstr ""

#: ../../library/signal.rst:427
msgid "See also :func:`pause`, :func:`sigpending` and :func:`sigwait`."
msgstr ":func:`pause`, :func:`sigpending`, :func:`sigwait` も参照して下さい。"

#: ../../library/signal.rst:434
msgid ""
"Sets given interval timer (one of :const:`signal.ITIMER_REAL`, :const:"
"`signal.ITIMER_VIRTUAL` or :const:`signal.ITIMER_PROF`) specified by *which* "
"to fire after *seconds* (float is accepted, different from :func:`alarm`) "
"and after that every *interval* seconds (if *interval* is non-zero). The "
"interval timer specified by *which* can be cleared by setting *seconds* to "
"zero."
msgstr ""
"*which* で指定されたタイマー (:const:`signal.ITIMER_REAL`, :const:`signal."
"ITIMER_VIRTUAL`, :const:`signal.ITIMER_PROF` のどれか) を、 *seconds* 秒後と "
"(:func:`alarm` と異なり、floatを指定できます)、それから (*interval* が0でなけ"
"れば) *interval* 秒間隔で起動するように設定します。 *seconds* に0を指定する"
"と、*which* で指定されたタイマーをクリアすることができます。"

#: ../../library/signal.rst:441
msgid ""
"When an interval timer fires, a signal is sent to the process. The signal "
"sent is dependent on the timer being used; :const:`signal.ITIMER_REAL` will "
"deliver :const:`SIGALRM`, :const:`signal.ITIMER_VIRTUAL` sends :const:"
"`SIGVTALRM`, and :const:`signal.ITIMER_PROF` will deliver :const:`SIGPROF`."
msgstr ""
"インターバルタイマーが起動したとき、シグナルがプロセスに送られます。送られる"
"シグナルは利用されたタイマーの種類に依存します。 :const:`signal.ITIMER_REAL` "
"の場合は :const:`SIGALRM` が、 :const:`signal.ITIMER_VIRTUAL` の場合は :"
"const:`SIGVTALRM` が、 :const:`signal.ITIMER_PROF` の場合は :const:`SIGPROF` "
"が送られます。"

#: ../../library/signal.rst:447
msgid "The old values are returned as a tuple: (delay, interval)."
msgstr "以前の値が (delay, interval) のタプルとして返されます。"

#: ../../library/signal.rst:449
msgid ""
"Attempting to pass an invalid interval timer will cause an :exc:"
"`ItimerError`."
msgstr ""
"無効なインターバルタイマーを渡すと :exc:`ItimerError` 例外が発生します。"

#: ../../library/signal.rst:457
msgid "Returns current value of a given interval timer specified by *which*."
msgstr "*which* で指定されたインターバルタイマーの現在の値を返します。"

#: ../../library/signal.rst:464
msgid ""
"Set the wakeup file descriptor to *fd*.  When a signal is received, the "
"signal number is written as a single byte into the fd.  This can be used by "
"a library to wakeup a poll or select call, allowing the signal to be fully "
"processed."
msgstr ""

#: ../../library/signal.rst:469
msgid ""
"The old wakeup fd is returned (or -1 if file descriptor wakeup was not "
"enabled).  If *fd* is -1, file descriptor wakeup is disabled. If not -1, "
"*fd* must be non-blocking.  It is up to the library to remove any bytes from "
"*fd* before calling poll or select again."
msgstr ""

#: ../../library/signal.rst:474 ../../library/signal.rst:528
msgid ""
"When threads are enabled, this function can only be called from :ref:`the "
"main thread of the main interpreter <signals-and-threads>`; attempting to "
"call it from other threads will cause a :exc:`ValueError` exception to be "
"raised."
msgstr ""
"スレッドが有効な場合、この関数は `メインインタープリターのメインスレッド "
"<signals-and-threads>` からしか実行できません。それ以外のスレッドからこの関数"
"を実行しようとすると :exc:`ValueError` 例外が発生します。"

#: ../../library/signal.rst:479
msgid ""
"There are two common ways to use this function. In both approaches, you use "
"the fd to wake up when a signal arrives, but then they differ in how they "
"determine *which* signal or signals have arrived."
msgstr ""

#: ../../library/signal.rst:484
msgid ""
"In the first approach, we read the data out of the fd's buffer, and the byte "
"values give you the signal numbers. This is simple, but in rare cases it can "
"run into a problem: generally the fd will have a limited amount of buffer "
"space, and if too many signals arrive too quickly, then the buffer may "
"become full, and some signals may be lost. If you use this approach, then "
"you should set ``warn_on_full_buffer=True``, which will at least cause a "
"warning to be printed to stderr when signals are lost."
msgstr ""

#: ../../library/signal.rst:493
msgid ""
"In the second approach, we use the wakeup fd *only* for wakeups, and ignore "
"the actual byte values. In this case, all we care about is whether the fd's "
"buffer is empty or non-empty; a full buffer doesn't indicate a problem at "
"all. If you use this approach, then you should set "
"``warn_on_full_buffer=False``, so that your users are not confused by "
"spurious warning messages."
msgstr ""

#: ../../library/signal.rst:500
msgid "On Windows, the function now also supports socket handles."
msgstr "Windowsで、この関数はソケットハンドルをサポートするようになりました。"

#: ../../library/signal.rst:503
msgid "Added ``warn_on_full_buffer`` parameter."
msgstr "``warn_on_full_buffer`` 引数が追加されました。"

#: ../../library/signal.rst:508
msgid ""
"Change system call restart behaviour: if *flag* is :const:`False`, system "
"calls will be restarted when interrupted by signal *signalnum*, otherwise "
"system calls will be interrupted.  Returns nothing."
msgstr ""
"システムコールのリスタートの動作を変更します。 *flag* が :const:`False` の場"
"合、 *signalnum* シグナルに中断されたシステムコールは再実行されます。それ以外"
"の場合、システムコールは中断されます。戻り値はありません。"

#: ../../library/signal.rst:514
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`siginterrupt(3)` for further information."
msgstr ""
":ref:`利用可能な環境 <availability>`: Unix。さらに詳しい情報についてはオンラ"
"インマニュアルページ :manpage:`siginterrupt(3)` を参照してください。"

#: ../../library/signal.rst:515
msgid ""
"Note that installing a signal handler with :func:`signal` will reset the "
"restart behaviour to interruptible by implicitly calling :c:func:"
"`siginterrupt` with a true *flag* value for the given signal."
msgstr ""
":func:`signal` を使ってシグナルハンドラを設定したときに、暗黙のうちに *flag* "
"に true を指定して :c:func:`siginterrupt` が実行されるため、中断に対するリス"
"タートの動作がリセットされることに注意してください。"

#: ../../library/signal.rst:522
msgid ""
"Set the handler for signal *signalnum* to the function *handler*.  *handler* "
"can be a callable Python object taking two arguments (see below), or one of "
"the special values :const:`signal.SIG_IGN` or :const:`signal.SIG_DFL`.  The "
"previous signal handler will be returned (see the description of :func:"
"`getsignal` above).  (See the Unix man page :manpage:`signal(2)` for further "
"information.)"
msgstr ""
"シグナル *signalnum* に対するハンドラを関数 *handler* にします。 *handler* は"
"二つの引数 (下記参照) を取る呼び出し可能な Python オブジェクトか、 :const:"
"`signal.SIG_IGN` あるいは :const:`signal.SIG_DFL` といった特殊な値にすること"
"ができます。以前に使われていたシグナルハンドラが返されます (上記の :func:"
"`getsignal` の記述を参照してください)。 (さらに詳しい情報については Unix マ"
"ニュアルページ :manpage:`signal(2)` を参照してください。)"

#: ../../library/signal.rst:533
msgid ""
"The *handler* is called with two arguments: the signal number and the "
"current stack frame (``None`` or a frame object; for a description of frame "
"objects, see the :ref:`description in the type hierarchy <frame-objects>` or "
"see the attribute descriptions in the :mod:`inspect` module)."
msgstr ""
"*handler* は二つの引数とともに呼び出されます: シグナル番号、および現在のス"
"タックフレーム (``None`` またはフレームオブジェクト; フレームオブジェクトにつ"
"いての記述は :ref:`標準型の階層における説明 <frame-objects>` か、 :mod:"
"`inspect` モジュールの属性の説明を参照してください)。"

#: ../../library/signal.rst:538
msgid ""
"On Windows, :func:`signal` can only be called with :const:`SIGABRT`, :const:"
"`SIGFPE`, :const:`SIGILL`, :const:`SIGINT`, :const:`SIGSEGV`, :const:"
"`SIGTERM`, or :const:`SIGBREAK`. A :exc:`ValueError` will be raised in any "
"other case. Note that not all systems define the same set of signal names; "
"an :exc:`AttributeError` will be raised if a signal name is not defined as "
"``SIG*`` module level constant."
msgstr ""

#: ../../library/signal.rst:549
msgid ""
"Examine the set of signals that are pending for delivery to the calling "
"thread (i.e., the signals which have been raised while blocked).  Return the "
"set of the pending signals."
msgstr ""
"呼び出しスレッドで配送が保留されているシグナル (つまり配送がブロックされてい"
"る間に発生したシグナル) の集合を調べます。保留中のシグナルの集合を返します。"

#: ../../library/signal.rst:555
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`sigpending(2)` for further information."
msgstr ""
":ref:`利用可能な環境 <availability>`: Unix。さらに詳しい情報についてはオンラ"
"インマニュアルページ :manpage:`sigpending(2)` を参照してください。"

#: ../../library/signal.rst:556
msgid "See also :func:`pause`, :func:`pthread_sigmask` and :func:`sigwait`."
msgstr ""
":func:`pause`, :func:`pthread_sigmask`, :func:`sigwait` も参照して下さい。"

#: ../../library/signal.rst:563
msgid ""
"Suspend execution of the calling thread until the delivery of one of the "
"signals specified in the signal set *sigset*.  The function accepts the "
"signal (removes it from the pending list of signals), and returns the signal "
"number."
msgstr ""
"*sigset* 集合で指定されたシグナルのうちどれか一つが届くまで呼び出しスレッドを"
"一時停止します。この関数はそのシグナルを受け取ると (それを保留シグナルリスト"
"から取り除いて) そのシグナル番号を返します。"

#: ../../library/signal.rst:569
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`sigwait(3)` for further information."
msgstr ""
":ref:`利用可能な環境 <availability>`: Unix。さらに詳しい情報についてはオンラ"
"インマニュアルページ :manpage:`sigwait(3)` を参照してください。"

#: ../../library/signal.rst:570
msgid ""
"See also :func:`pause`, :func:`pthread_sigmask`, :func:`sigpending`, :func:"
"`sigwaitinfo` and :func:`sigtimedwait`."
msgstr ""
":func:`pause`, :func:`pthread_sigmask`, :func:`sigpending`, :func:"
"`sigwaitinfo`, :func:`sigtimedwait` も参照して下さい。"

#: ../../library/signal.rst:578
msgid ""
"Suspend execution of the calling thread until the delivery of one of the "
"signals specified in the signal set *sigset*.  The function accepts the "
"signal and removes it from the pending list of signals. If one of the "
"signals in *sigset* is already pending for the calling thread, the function "
"will return immediately with information about that signal. The signal "
"handler is not called for the delivered signal. The function raises an :exc:"
"`InterruptedError` if it is interrupted by a signal that is not in *sigset*."
msgstr ""

#: ../../library/signal.rst:587
msgid ""
"The return value is an object representing the data contained in the :c:type:"
"`siginfo_t` structure, namely: :attr:`si_signo`, :attr:`si_code`, :attr:"
"`si_errno`, :attr:`si_pid`, :attr:`si_uid`, :attr:`si_status`, :attr:"
"`si_band`."
msgstr ""

#: ../../library/signal.rst:594
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`sigwaitinfo(2)` for further information."
msgstr ""
":ref:`利用可能な環境 <availability>`: Unix。さらに詳しい情報についてはオンラ"
"インマニュアルページ :manpage:`sigwaitinfo(2)` を参照してください。"

#: ../../library/signal.rst:595
msgid "See also :func:`pause`, :func:`sigwait` and :func:`sigtimedwait`."
msgstr ""
":func:`pause`, :func:`sigwait`, :func:`sigtimedwait` も参照して下さい。"

#: ../../library/signal.rst:599
msgid ""
"The function is now retried if interrupted by a signal not in *sigset* and "
"the signal handler does not raise an exception (see :pep:`475` for the "
"rationale)."
msgstr ""

#: ../../library/signal.rst:607
msgid ""
"Like :func:`sigwaitinfo`, but takes an additional *timeout* argument "
"specifying a timeout. If *timeout* is specified as :const:`0`, a poll is "
"performed. Returns :const:`None` if a timeout occurs."
msgstr ""

#: ../../library/signal.rst:613
msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`sigtimedwait(2)` for further information."
msgstr ""
":ref:`利用可能な環境 <availability>`: Unix。さらに詳しい情報についてはオンラ"
"インマニュアルページ :manpage:`sigtimedwait(2)` を参照してください。"

#: ../../library/signal.rst:614
msgid "See also :func:`pause`, :func:`sigwait` and :func:`sigwaitinfo`."
msgstr ":func:`pause`, :func:`sigwait`, :func:`sigwaitinfo` も参照して下さい。"

#: ../../library/signal.rst:618
msgid ""
"The function is now retried with the recomputed *timeout* if interrupted by "
"a signal not in *sigset* and the signal handler does not raise an exception "
"(see :pep:`475` for the rationale)."
msgstr ""

#: ../../library/signal.rst:627
msgid "Example"
msgstr "使用例"

#: ../../library/signal.rst:629
msgid ""
"Here is a minimal example program. It uses the :func:`alarm` function to "
"limit the time spent waiting to open a file; this is useful if the file is "
"for a serial device that may not be turned on, which would normally cause "
"the :func:`os.open` to hang indefinitely.  The solution is to set a 5-second "
"alarm before opening the file; if the operation takes too long, the alarm "
"signal will be sent, and the handler raises an exception. ::"
msgstr ""
"以下は最小限のプログラム例です。この例では :func:`alarm` を使ってファイルを開"
"く処理を待つのに費やす時間を制限します; 例えば、電源の入っていないシリアルデ"
"バイスを開こうとすると、通常 :func:`os.open` は未定義の期間ハングアップしてし"
"まいますが、この方法はそうした場合に便利です。ここではファイルを開くまで 5 秒"
"間のアラームを設定することで解決しています; ファイルを開く処理が長くかかりす"
"ぎると、アラームシグナルが送信され、ハンドラが例外を送出するようになっていま"
"す。 ::"

#: ../../library/signal.rst:652
msgid "Note on SIGPIPE"
msgstr ""

#: ../../library/signal.rst:654
msgid ""
"Piping output of your program to tools like :manpage:`head(1)` will cause a :"
"const:`SIGPIPE` signal to be sent to your process when the receiver of its "
"standard output closes early.  This results in an exception like :code:"
"`BrokenPipeError: [Errno 32] Broken pipe`.  To handle this case, wrap your "
"entry point to catch this exception as follows::"
msgstr ""

#: ../../library/signal.rst:681
msgid ""
"Do not set :const:`SIGPIPE`'s disposition to :const:`SIG_DFL` in order to "
"avoid :exc:`BrokenPipeError`.  Doing that would cause your program to exit "
"unexpectedly whenever any socket connection is interrupted while your "
"program is still writing to it."
msgstr ""

#: ../../library/signal.rst:690
msgid "Note on Signal Handlers and Exceptions"
msgstr ""

#: ../../library/signal.rst:692
msgid ""
"If a signal handler raises an exception, the exception will be propagated to "
"the main thread and may be raised after any :term:`bytecode` instruction. "
"Most notably, a :exc:`KeyboardInterrupt` may appear at any point during "
"execution. Most Python code, including the standard library, cannot be made "
"robust against this, and so a :exc:`KeyboardInterrupt` (or any other "
"exception resulting from a signal handler) may on rare occasions put the "
"program in an unexpected state."
msgstr ""

#: ../../library/signal.rst:699
msgid "To illustrate this issue, consider the following code::"
msgstr ""

#: ../../library/signal.rst:716
msgid ""
"For many programs, especially those that merely want to exit on :exc:"
"`KeyboardInterrupt`, this is not a problem, but applications that are "
"complex or require high reliability should avoid raising exceptions from "
"signal handlers. They should also avoid catching :exc:`KeyboardInterrupt` as "
"a means of gracefully shutting down.  Instead, they should install their "
"own :const:`SIGINT` handler. Below is an example of an HTTP server that "
"avoids :exc:`KeyboardInterrupt`::"
msgstr ""
