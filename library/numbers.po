# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-05 15:01+0000\n"
"PO-Revision-Date: 2018-06-29 17:32+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/numbers.rst:2
msgid ":mod:`numbers` --- Numeric abstract base classes"
msgstr ":mod:`numbers` --- æ•°ã®æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹"

#: ../../library/numbers.rst:7
msgid "**Source code:** :source:`Lib/numbers.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/numbers.py`"

#: ../../library/numbers.rst:11
msgid ""
"The :mod:`numbers` module (:pep:`3141`) defines a hierarchy of numeric "
":term:`abstract base classes <abstract base class>` which progressively "
"define more operations.  None of the types defined in this module can be "
"instantiated."
msgstr ""
":mod:`numbers` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (:pep:`3141`) ã¯æ•°ã® :term:`æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ <abstract base class>`"
" ã®éšå±¤ã‚’å®šç¾©ã—ã¾ã™ã€‚ã“ã®éšå±¤ã§ã¯ã€ã•ã‚‰ã«å¤šãã®æ¼”ç®—ãŒé †ç•ªã«å®šç¾©ã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã‚‹å‹ã¯ã©ã‚Œã‚‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/numbers.rst:18
msgid ""
"The root of the numeric hierarchy. If you just want to check if an argument "
"*x* is a number, without caring what kind, use ``isinstance(x, Number)``."
msgstr ""
"æ•°ã®éšå±¤ã®æ ¹ã€‚å¼•æ•° *x* ãŒã€ç¨®é¡ã¯ä½•ã§ã‚ã‚Œã€æ•°ã§ã‚ã‚‹ã¨ã„ã†ã“ã¨ã ã‘ãƒã‚§ãƒƒã‚¯ã—ãŸã„å ´åˆã€``isinstance(x, Number)`` "
"ãŒä½¿ãˆã¾ã™ã€‚"

#: ../../library/numbers.rst:23
msgid "The numeric tower"
msgstr "æ•°å€¤å¡”"

#: ../../library/numbers.rst:27
msgid ""
"Subclasses of this type describe complex numbers and include the operations "
"that work on the built-in :class:`complex` type. These are: conversions to "
":class:`complex` and :class:`bool`, :attr:`.real`, :attr:`.imag`, ``+``, "
"``-``, ``*``, ``/``, :func:`abs`, :meth:`conjugate`, ``==``, and ``!=``. All"
" except ``-`` and ``!=`` are abstract."
msgstr ""
"ã“ã®å‹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã¯è¤‡ç´ æ•°ã‚’è¡¨ã—ã€çµ„ã¿è¾¼ã¿ã® :class:`complex` å‹ã‚’å—ã‘ä»˜ã‘ã‚‹æ¼”ç®—ã‚’å«ã¿ã¾ã™ã€‚ãã‚Œã‚‰ã¯: "
":class:`complex` ãŠã‚ˆã³ :class:`bool` ã¸ã®å¤‰æ›ã€ :attr:`.real`, :attr:`.imag`, "
"``+``, ``-``, ``*``, ``/``, :func:`abs`, :meth:`conjugate`, ``==``, ``!=`` "
"ã§ã™ã€‚ ``-`` ã¨ ``!=`` ä»¥å¤–ã®å…¨ã¦ã®ã‚‚ã®ã¯æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã‚„æŠ½è±¡ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§ã™ã€‚"

#: ../../library/numbers.rst:35
msgid "Abstract. Retrieves the real component of this number."
msgstr "æŠ½è±¡ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã€‚ã“ã®æ•°ã®å®Ÿéƒ¨ã‚’å–ã‚Šå‡ºã—ã¾ã™ã€‚"

#: ../../library/numbers.rst:39
msgid "Abstract. Retrieves the imaginary component of this number."
msgstr "æŠ½è±¡ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã€‚ã“ã®æ•°ã®è™šéƒ¨ã‚’å–ã‚Šå‡ºã—ã¾ã™ã€‚"

#: ../../library/numbers.rst:43
msgid ""
"Abstract. Returns the complex conjugate. For example, ``(1+3j).conjugate() "
"== (1-3j)``."
msgstr "æŠ½è±¡ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã€‚è¤‡ç´ å…±å½¹ã‚’è¿”ã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€``(1+3j).conjugate() == (1-3j)`` ã§ã™ã€‚"

#: ../../library/numbers.rst:48
msgid ""
"To :class:`Complex`, :class:`Real` adds the operations that work on real "
"numbers."
msgstr ":class:`Real` ã¯ã€:class:`Complex` ä¸Šã«ã€ å®Ÿæ•°ã«å¯¾ã—ã¦è¡Œãˆã‚‹æ¼”ç®—ã‚’åŠ ãˆã¾ã™ã€‚"

#: ../../library/numbers.rst:51
msgid ""
"In short, those are: a conversion to :class:`float`, :func:`math.trunc`, "
":func:`round`, :func:`math.floor`, :func:`math.ceil`, :func:`divmod`, "
"``//``, ``%``, ``<``, ``<=``, ``>``, and ``>=``."
msgstr ""
"ç°¡æ½”ã«è¨€ã†ã¨ãã‚Œã‚‰ã¯: :class:`float` ã¸ã®å¤‰æ›, :func:`math.trunc`, :func:`round`, "
":func:`math.floor`, :func:`math.ceil`, :func:`divmod`, ``//``, ``%``, ``<``,"
" ``<=``, ``>`` ãŠã‚ˆã³ ``>=`` ã§ã™ã€‚"

#: ../../library/numbers.rst:55
msgid ""
"Real also provides defaults for :func:`complex`, :attr:`~Complex.real`, "
":attr:`~Complex.imag`, and :meth:`~Complex.conjugate`."
msgstr ""
"Real ã¯ã¾ãŸ :func:`complex`, :attr:`~Complex.real`, :attr:`~Complex.imag` ãŠã‚ˆã³ "
":meth:`~Complex.conjugate` ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/numbers.rst:61
msgid ""
"Subtypes :class:`Real` and adds :attr:`~Rational.numerator` and "
":attr:`~Rational.denominator` properties, which should be in lowest terms. "
"With these, it provides a default for :func:`float`."
msgstr ""
":class:`Real` ã‚’ã‚µãƒ–ã‚¿ã‚¤ãƒ—åŒ–ã— :attr:`~Rational.numerator` ã¨ "
":attr:`~Rational.denominator` ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’åŠ ãˆãŸã‚‚ã®ã§ã™ã€‚ã“ã‚Œã‚‰ã¯æ—¢ç´„åˆ†æ•°ã®ã‚‚ã®ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ä»–ã« "
":func:`float` ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚‚æä¾›ã—ã¾ã™ã€‚"

#: ../../library/numbers.rst:68 ../../library/numbers.rst:72
msgid "Abstract."
msgstr "æŠ½è±¡ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã€‚"

#: ../../library/numbers.rst:77
msgid ""
"Subtypes :class:`Rational` and adds a conversion to :class:`int`.  Provides "
"defaults for :func:`float`, :attr:`~Rational.numerator`, and "
":attr:`~Rational.denominator`.  Adds abstract methods for ``**`` and bit-"
"string operations: ``<<``, ``>>``, ``&``, ``^``, ``|``, ``~``."
msgstr ""
":class:`Rational` ã‚’ã‚µãƒ–ã‚¿ã‚¤ãƒ—åŒ–ã— :class:`int` ã¸ã®å¤‰æ›ãŒåŠ ã‚ã‚Šã¾ã™ã€‚ :func:`float`, "
":attr:`~Rational.numerator`, :attr:`~Rational.denominator` ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚ "
"``**`` ã«å¯¾ã™ã‚‹æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã€ãƒ“ãƒƒãƒˆåˆ—æ¼”ç®— ``<<``, ``>>``, ``&``, ``^``, ``|``, ``~`` ã‚’è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../library/numbers.rst:84
msgid "Notes for type implementors"
msgstr "å‹å®Ÿè£…è€…ã®ãŸã‚ã®æ³¨æ„äº‹é …"

#: ../../library/numbers.rst:86
msgid ""
"Implementors should be careful to make equal numbers equal and hash them to "
"the same values. This may be subtle if there are two different extensions of"
" the real numbers. For example, :class:`fractions.Fraction` implements "
":func:`hash` as follows::"
msgstr ""
"å®Ÿè£…ã™ã‚‹äººã¯ç­‰ã—ã„æ•°ãŒç­‰ã—ãæ‰±ã‚ã‚Œã‚‹ã‚ˆã†ã«åŒã˜ãƒãƒƒã‚·ãƒ¥ã‚’ä¸ãˆã‚‹ã‚ˆã†ã«æ°—ã‚’ä»˜ã‘ã­ã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯äºŒã¤ã®ç•°ãªã£ãŸå®Ÿæ•°ã®æ‹¡å¼µãŒã‚ã‚‹ã‚ˆã†ãªå ´åˆã«ã¯ã‚„ã‚„ã“ã—ã„ã“ã¨ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãŸã¨ãˆã°ã€"
" :class:`fractions.Fraction` ã¯ :func:`hash` ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã—ã¦ã„ã¾ã™::"

#: ../../library/numbers.rst:105
msgid "Adding More Numeric ABCs"
msgstr "ã•ã‚‰ã«æ•°ã®ABCã‚’è¿½åŠ ã™ã‚‹"

#: ../../library/numbers.rst:107
msgid ""
"There are, of course, more possible ABCs for numbers, and this would be a "
"poor hierarchy if it precluded the possibility of adding those. You can add "
"``MyFoo`` between :class:`Complex` and :class:`Real` with::"
msgstr ""
"æ•°ã«å¯¾ã™ã‚‹ ABC ãŒä»–ã«ã‚‚å¤šãå­˜åœ¨ã—ã†ã‚‹ã“ã¨ã¯ã€è¨€ã†ã¾ã§ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚ãã‚Œã‚‰ã® ABC "
"ã‚’éšå±¤ã«è¿½åŠ ã™ã‚‹å¯èƒ½æ€§ãŒé–‰ã–ã•ã‚Œã‚‹ã¨ã—ãŸã‚‰ã€ãã®éšå±¤ã¯è²§ç›¸ãªéšå±¤ã§ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ãŸã¨ãˆã°ã€ ``MyFoo`` ã‚’ :class:`Complex` "
"ã¨ :class:`Real` ã®é–“ã«ä»˜ã‘åŠ ãˆã‚‹ã«ã¯ã€æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™::"

#: ../../library/numbers.rst:119
msgid "Implementing the arithmetic operations"
msgstr "ç®—è¡“æ¼”ç®—ã®å®Ÿè£…"

#: ../../library/numbers.rst:121
msgid ""
"We want to implement the arithmetic operations so that mixed-mode operations"
" either call an implementation whose author knew about the types of both "
"arguments, or convert both to the nearest built in type and do the operation"
" there. For subtypes of :class:`Integral`, this means that :meth:`__add__` "
"and :meth:`__radd__` should be defined as::"
msgstr ""
"ç®—è¡“æ¼”ç®—ã‚’å®Ÿè£…ã™ã‚‹éš›ã«ã¯ã€å‹æ··åˆ(mixed-"
"mode)æ¼”ç®—ã‚’è¡Œã†ã¨ã€ä½œè€…ãŒä¸¡æ–¹ã®å¼•æ•°ã®å‹ã«ã¤ã„ã¦çŸ¥ã£ã¦ã„ã‚‹ã‚ˆã†ãªå®Ÿè£…ã‚’å‘¼ã³å‡ºã™ã‹ã€ä¸¡æ–¹ã®å¼•æ•°ã‚’ãã‚Œãã‚Œæœ€ã‚‚ä¼¼ã¦ã„ã‚‹çµ„ã¿è¾¼ã¿å‹ã«å¤‰æ›ã—ã¦ãã®å‹ã§æ¼”ç®—ã‚’è¡Œã†ã‹ã€ã©ã¡ã‚‰ã«ãªã‚‹ã®ãŒæœ›ã¾ã—ã„å®Ÿè£…ã§ã™ã€‚ã¤ã¾ã‚Šã€"
" :class:`Integral` ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã«å¯¾ã—ã¦ã¯ :meth:`__add__` ã¨ :meth:`__radd__` "
"ã‚’æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã™ã‚‹ã¹ãã§ã™::"

#: ../../library/numbers.rst:152
msgid ""
"There are 5 different cases for a mixed-type operation on subclasses of "
":class:`Complex`. I'll refer to all of the above code that doesn't refer to "
"``MyIntegral`` and ``OtherTypeIKnowAbout`` as \"boilerplate\". ``a`` will be"
" an instance of ``A``, which is a subtype of :class:`Complex` (``a : A <: "
"Complex``), and ``b : B <: Complex``. I'll consider ``a + b``:"
msgstr ""
"ã“ã“ã«ã¯5ã¤ã®ç•°ãªã‚‹ :class:`Complex` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹é–“ã®æ··åœ¨å‹ã®æ¼”ç®—ãŒã‚ã‚Šã¾ã™ã€‚ä¸Šã®ã‚³ãƒ¼ãƒ‰ã®ä¸­ã§ ``MyIntegral`` ã¨ "
"``OtherTypeIKnowAbout`` ã«è§¦ã‚Œãªã„éƒ¨åˆ†ã‚’ \"ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆ\" ã¨å‘¼ã¶ã“ã¨ã«ã—ã¾ã—ã‚‡ã†ã€‚ ``a`` ã‚’ "
":class:`Complex` ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã§ã‚ã‚‹ ``A`` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ (``a : A <: Complex``)ã€åŒæ§˜ã« ``b : B "
"<: Complex`` ã¨ã—ã¦ã€ ``a + b`` ã‚’è€ƒãˆã¾ã™:"

#: ../../library/numbers.rst:159
msgid "If ``A`` defines an :meth:`__add__` which accepts ``b``, all is well."
msgstr "``A`` ãŒ ``b`` ã‚’å—ã‘ä»˜ã‘ã‚‹ :meth:`__add__` ã‚’å®šç¾©ã—ã¦ã„ã‚‹å ´åˆã€ä½•ã‚‚å•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/numbers.rst:161
msgid ""
"If ``A`` falls back to the boilerplate code, and it were to return a value "
"from :meth:`__add__`, we'd miss the possibility that ``B`` defines a more "
"intelligent :meth:`__radd__`, so the boilerplate should return "
":const:`NotImplemented` from :meth:`__add__`. (Or ``A`` may not implement "
":meth:`__add__` at all.)"
msgstr ""
"``A`` ã§ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆéƒ¨åˆ†ã«è½ã¡è¾¼ã¿ã€ãã®çµæœ :meth:`__add__` ãŒå€¤ã‚’è¿”ã™ãªã‚‰ã°ã€ ``B`` ã«è‰¯ãè€ƒãˆã‚‰ã‚ŒãŸ "
":meth:`__radd__` ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ã‚’è¦‹é€ƒã—ã¦ã—ã¾ã„ã¾ã™ã®ã§ã€ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã¯ :meth:`__add__` ã‹ã‚‰ "
":const:`NotImplemented` ã‚’è¿”ã™ã®ãŒè‰¯ã„ã§ã—ã‚‡ã†ã€‚(è‹¥ã—ãã¯ã€ ``A`` ã¯ã¾ã£ãŸã :meth:`__add__` "
"ã‚’å®Ÿè£…ã™ã¹ãã§ã¯ãªã‹ã£ãŸã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚)"

#: ../../library/numbers.rst:167
msgid ""
"Then ``B``'s :meth:`__radd__` gets a chance. If it accepts ``a``, all is "
"well."
msgstr ""
"ãã†ã™ã‚‹ã¨ã€ ``B`` ã® :meth:`__radd__` ã«ãƒãƒ£ãƒ³ã‚¹ãŒå·¡ã£ã¦ãã¾ã™ã€‚ã“ã“ã§ ``a`` ãŒå—ã‘ä»˜ã‘ã‚‰ã‚Œã‚‹ãªã‚‰ã°ã€çµæœã¯ä¸Šã€…ã§ã™ã€‚"

#: ../../library/numbers.rst:169
msgid ""
"If it falls back to the boilerplate, there are no more possible methods to "
"try, so this is where the default implementation should live."
msgstr "ã“ã“ã§ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã«è½ã¡è¾¼ã‚€ãªã‚‰ã°ã€ã‚‚ã†ä»–ã«è©¦ã™ã¹ããƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“ã®ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã®å‡ºç•ªã§ã™ã€‚"

#: ../../library/numbers.rst:172
msgid ""
"If ``B <: A``, Python tries ``B.__radd__`` before ``A.__add__``. This is ok,"
" because it was implemented with knowledge of ``A``, so it can handle those "
"instances before delegating to :class:`Complex`."
msgstr ""
"ã‚‚ã— ``B <: A`` ãªã‚‰ã°ã€Python ã¯ ``A.__add__`` ã®å‰ã« ``B.__radd__`` ã‚’è©¦ã—ã¾ã™ã€‚ã“ã‚Œã§è‰¯ã„ç†ç”±ã¯ã€ "
"``A`` ã«ã¤ã„ã¦ã®çŸ¥è­˜ã‚’æŒã£ã¦å®Ÿè£…ã—ã¦ãŠã‚Šã€ :class:`Complex` ã«å§”ã­ã‚‹å‰ã«ã“ã‚Œã‚‰ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ‰±ãˆã‚‹ã¯ãšã ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/numbers.rst:177
msgid ""
"If ``A <: Complex`` and ``B <: Real`` without sharing any other knowledge, "
"then the appropriate shared operation is the one involving the built in "
":class:`complex`, and both :meth:`__radd__` s land there, so ``a+b == b+a``."
msgstr ""
"ã‚‚ã— ``A <: Complex`` ã‹ã¤ ``B <: Real`` ã§ä»–ã«å…±æœ‰ã•ã‚ŒãŸçŸ¥è­˜ãŒç„¡ã„ãªã‚‰ã°ã€é©åˆ‡ãªå…±é€šã®æ¼”ç®—ã¯çµ„ã¿è¾¼ã¿ã® "
":class:`complex` ã‚’ä½¿ã£ãŸã‚‚ã®ã«ãªã‚Šã€ã©ã¡ã‚‰ã® :meth:`__radd__` ã¨ã‚‚ãã“ã«ç€åœ°ã™ã‚‹ã§ã—ã‚‡ã†ã‹ã‚‰ã€ ``a+b == "
"b+a`` ã§ã™ã€‚"

#: ../../library/numbers.rst:182
msgid ""
"Because most of the operations on any given type will be very similar, it "
"can be useful to define a helper function which generates the forward and "
"reverse instances of any given operator. For example, "
":class:`fractions.Fraction` uses::"
msgstr ""
"ã»ã¨ã‚“ã©ã®æ¼”ç®—ã¯ã©ã®ã‚ˆã†ãªå‹ã«ã¤ã„ã¦ã‚‚éå¸¸ã«è‰¯ãä¼¼ã¦ã„ã¾ã™ã®ã§ã€ä¸ãˆã‚‰ã‚ŒãŸæ¼”ç®—å­ã«ã¤ã„ã¦é †çµåˆ(forward)ãŠã‚ˆã³é€†çµåˆ(reverse)ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç”Ÿæˆã™ã‚‹æ”¯æ´é–¢æ•°ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã¯å½¹ã«ç«‹ã¡ã¾ã™ã€‚ãŸã¨ãˆã°ã€"
" :class:`fractions.Fraction` ã§ã¯æ¬¡ã®ã‚ˆã†ãªã‚‚ã®ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™::"
