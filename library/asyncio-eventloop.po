# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-30 05:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: tomoğŸ§, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-eventloop.rst:6
msgid "Base Event Loop"
msgstr "åŸºåº•ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—"

#: ../../library/asyncio-eventloop.rst:8
msgid "**Source code:** :source:`Lib/asyncio/events.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/asyncio/events.py`"

#: ../../library/asyncio-eventloop.rst:10
msgid ""
"The event loop is the central execution device provided by :mod:`asyncio`. "
"It provides multiple facilities, including:"
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã¯ :mod:`asyncio`  ãŒæä¾›ã™ã‚‹ä¸­å¿ƒå®Ÿè¡Œãƒ‡ãƒã‚¤ã‚¹ã§ã™ã€‚ä»¥ä¸‹ã®å¤šãã®æ©Ÿèƒ½ã‚’æä¾›ã—ã¦ã„ã¾ã™:"

#: ../../library/asyncio-eventloop.rst:13
msgid "Registering, executing and cancelling delayed calls (timeouts)."
msgstr "é…å»¶å‘¼ã³å‡ºã—ã®ç™»éŒ²ã€å®Ÿè¡ŒãŠã‚ˆã³ã‚­ãƒ£ãƒ³ã‚»ãƒ« (ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ)ã€‚"

#: ../../library/asyncio-eventloop.rst:15
msgid ""
"Creating client and server :ref:`transports <asyncio-transport>` for various"
" kinds of communication."
msgstr "ã•ã¾ã–ã¾ãªç¨®é¡ã®é€šä¿¡ã®ãŸã‚ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŠã‚ˆã³ã‚µãƒ¼ãƒãƒ¼ :ref:`ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆ <asyncio-transport>` ã®ä½œæˆã€‚"

#: ../../library/asyncio-eventloop.rst:18
msgid ""
"Launching subprocesses and the associated :ref:`transports <asyncio-"
"transport>` for communication with an external program."
msgstr "å¤–éƒ¨ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã®é€šä¿¡ã®ãŸã‚ã®ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ãŠã‚ˆã³é–¢é€£ã™ã‚‹ :ref:`ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆ <asyncio-transport>` ã®èµ·å‹•ã€‚"

#: ../../library/asyncio-eventloop.rst:21
msgid "Delegating costly function calls to a pool of threads."
msgstr "ã‚¹ãƒ¬ãƒƒãƒ‰ã®ãƒ—ãƒ¼ãƒ«ã¸å‘¼ã³å‡ºã™ã€ã‚³ã‚¹ãƒˆã®å¤§ãã„é–¢æ•°ã®å§”è­²ã€‚"

#: ../../library/asyncio-eventloop.rst:25
msgid ""
"This class is an implementation detail.  It is a subclass of "
":class:`AbstractEventLoop` and may be a base class of concrete event loop "
"implementations found in :mod:`asyncio`.  It should not be used directly; "
"use :class:`AbstractEventLoop` instead. ``BaseEventLoop`` should not be "
"subclassed by third-party code; the internal interface is not stable."
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹ã¯å®Ÿè£…è©³ç´°ã§ã™ã€‚ :class:`AbstractEventLoop` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€ :mod:`asyncio` "
"ã«ã‚ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã‚’å®Ÿè£…ã—ãŸå…·è±¡ã‚¯ãƒ©ã‚¹ã®åŸºåº•ã‚¯ãƒ©ã‚¹ã«ãªã£ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯ç›´æ¥ä½¿ã†ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ "
":class:`AbstractEventLoop` ã‚’ä»£ã‚ã‚Šã«ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã®ã‚³ãƒ¼ãƒ‰ã§ ``BaseEventLoop`` "
"ã‚’ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã®å†…éƒ¨ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¯å®‰å®šã—ã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:34
msgid "Abstract base class of event loops."
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:36
msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr "ã“ã®ã‚¯ãƒ©ã‚¹ã¯ :ref:`ã‚¹ãƒ¬ãƒƒãƒ‰å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ <asyncio-multithreading>`ã€‚"

#: ../../library/asyncio-eventloop.rst:39
msgid "Run an event loop"
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®å®Ÿè¡Œ"

#: ../../library/asyncio-eventloop.rst:43
msgid ""
"Run until :meth:`stop` is called.  If :meth:`stop` is called before "
":meth:`run_forever()` is called, this polls the I/O selector once with a "
"timeout of zero, runs all callbacks scheduled in response to I/O events (and"
" those that were already scheduled), and then exits. If :meth:`stop` is "
"called while :meth:`run_forever` is running, this will run the current batch"
" of callbacks and then exit.  Note that callbacks scheduled by callbacks "
"will not run in that case; they will run the next time :meth:`run_forever` "
"is called."
msgstr ""
":meth:`stop` ãŒå‘¼ã°ã‚Œã‚‹ã¾ã§å®Ÿè¡Œã—ã¾ã™ã€‚ã‚‚ã— :meth:`run_forever()` ãŒå‘¼ã°ã‚Œã‚‹å‰ã« :meth:`stop` "
"ãŒå‘¼ã°ã‚ŒãŸå ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ I/O ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“ã‚¼ãƒ­ã§ä¸€åº¦ãƒãƒ¼ãƒªãƒ³ã‚°ã—ã¦ã€ãã“ã§æ¤œå‡ºã•ã‚ŒãŸ I/O "
"ã‚¤ãƒ™ãƒ³ãƒˆã«å¿œã˜ã¦å®Ÿè¡ŒãŒã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã™ã¹ã¦ (ã«åŠ ãˆã¦å…ƒã€…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚Œã¦ã„ãŸã‚‚ã®) ã‚’å®Ÿè¡Œã—ãŸå¾Œã€çµ‚äº†ã—ã¾ã™ã€‚ã‚‚ã— "
":meth:`run_forever` ã®å®Ÿè¡Œä¸­ã« :meth:`stop` "
"ãŒå‘¼ã°ã‚ŒãŸå ´åˆã€ç¾åœ¨ãƒãƒƒãƒå‡¦ç†ä¸­ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å®Ÿè¡Œã—ãŸå¾Œã«çµ‚äº†ã—ã¾ã™ã€‚ãªãŠã€ã“ã®å ´åˆã¯ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å†…ã§ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã€‚ãã‚Œã‚‰ã¯æ¬¡ã«"
" :meth:`run_forever` ãŒå‘¼ã°ã‚ŒãŸã¨ãã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:56
msgid "Run until the :class:`Future` is done."
msgstr ":class:`Future` ãŒå®Œäº†ã™ã‚‹ã¾ã§å®Ÿè¡Œã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:58
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>`, it is wrapped by "
":func:`ensure_future`."
msgstr ""
"å¼•æ•°ãŒ :ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <coroutine>` ã®å ´åˆã€:func:`ensure_future` ã§ãƒ©ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:61
msgid "Return the Future's result, or raise its exception."
msgstr "Future ã®çµæœã‚’è¿”ã™ã‹ã€ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:65
msgid "Returns running status of event loop."
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®å®Ÿè¡ŒçŠ¶æ…‹ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:69
msgid "Stop running the event loop."
msgstr "å®Ÿè¡Œä¸­ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã‚’åœæ­¢ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:71
msgid ""
"This causes :meth:`run_forever` to exit at the next suitable opportunity "
"(see there for more details)."
msgstr "ã“ã‚Œã«ã‚ˆã‚Šã€ :meth:`run_forever` ã¯æ¬¡ã®é©å½“ãªæ™‚ã«çµ‚äº†ã—ã¾ã™ (è©³ç´°ã¯ãã¡ã‚‰ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../library/asyncio-eventloop.rst:78
msgid "Returns ``True`` if the event loop was closed."
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ãŸå ´åˆ ``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:84
msgid ""
"Close the event loop. The loop must not be running.  Pending callbacks will "
"be lost."
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã‚’é–‰ã˜ã¾ã™ã€‚ãƒ«ãƒ¼ãƒ—ã¯å®Ÿè¡Œä¸­ã§ã¯ã„ã‘ã¾ã›ã‚“ã€‚ä¿ç•™ä¸­ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯å¤±ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:87
msgid ""
"This clears the queues and shuts down the executor, but does not wait for "
"the executor to finish."
msgstr "ã“ã‚Œã¯ã‚­ãƒ¥ãƒ¼ã‚’ã‚¯ãƒªã‚¢ã—å®Ÿè¡Œè€…ã‚’ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã—ã¾ã™ãŒã€å®Ÿè¡Œè€…ã®çµ‚äº†ã‚’å¾…ã¡ã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:90
msgid ""
"This is idempotent and irreversible. No other methods should be called after"
" this one."
msgstr "ã“ã‚Œã¯å†ªç­‰ (è¨³æ³¨ï¼š ä½•å›è¡Œã£ã¦ã‚‚çµæœãŒåŒã˜) ã§ã‚ã‚Šå–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚ã“ã®å¾Œä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:96
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose()` call.  After calling this method, the event "
"loop will issue a warning whenever a new asynchronous generator is iterated."
"  Should be used to finalize all scheduled asynchronous generators reliably."
"  Example::"
msgstr ""
"ç¾åœ¨ã‚ªãƒ¼ãƒ—ãƒ³ã®å…¨ã¦ã® :term:`asynchronous generator`Â "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã—ã€:meth:`~agen.aclose()`Â "
"å‘¼ã³å‡ºã—ã«ã‚ˆã‚Šã‚¯ãƒ­ãƒ¼ã‚ºã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—å¾Œã€ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã¯æ–°ã—ã„éåŒæœŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆã•ã‚Œã‚‹ã¨æ¯å›è­¦å‘Šã‚’ç™ºã—ã¾ã™ã€‚å…¨ã¦ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚ŒãŸéåŒæœŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®çµ‚äº†å‡¦ç†ã‚’ç¢ºå®Ÿã«è¡Œã†ãŸã‚ã«ä½¿ç”¨ã™ã¹ãã§ã™ã€‚ä»¥ä¸‹ã«ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:114
msgid "Calls"
msgstr "å‘¼ã³å‡ºã— (call)"

#: ../../library/asyncio-eventloop.rst:116
msgid ""
"Most :mod:`asyncio` functions don't accept keywords. If you want to pass "
"keywords to your callback, use :func:`functools.partial`. For example, "
"``loop.call_soon(functools.partial(print, \"Hello\", flush=True))`` will "
"call ``print(\"Hello\", flush=True)``."
msgstr ""
":mod:`asyncio` é–¢æ•°ã®å¤§åŠã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å—ã‘ä»˜ã‘ã¾ã›ã‚“ã€‚\n"
"ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã«å¼•æ•°ã‚’æ¸¡ã—ãŸã„å ´åˆã¯ :func:`functools.partial` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚\n"
"ä¾‹ãˆã° ``loop.call_soon(functools.partial(print, \"Hello\", flush=True))`` ã¯ ``print(\"Hello\", flush=True)`` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:122
msgid ""
":func:`functools.partial` is better than ``lambda`` functions, because "
":mod:`asyncio` can inspect :func:`functools.partial` object to display "
"parameters in debug mode, whereas ``lambda`` functions have a poor "
"representation."
msgstr ""
"``lambda`` é–¢æ•°ã‚ˆã‚Šã‚‚ :func:`functools.partial` ã‚’ä½¿ç”¨ã—ã¾ã—ã‚‡ã†ã€‚\n"
":mod:`asyncio` ã¯ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã§å¼•æ•°ã‚’è¡¨ç¤ºã™ã‚‹ã‚ˆã† :func:`functools.partial` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç²¾æŸ»ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ãŒã€``lambda`` é–¢æ•°ã®è¡¨ç¾ã¯è²§å¼±ã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:129
msgid ""
"Arrange for a callback to be called as soon as possible.  The callback is "
"called after :meth:`call_soon` returns, when control returns to the event "
"loop."
msgstr ""
"ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã™ãã«å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«æº–å‚™ã—ã¾ã™ã€‚\n"
"ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ :meth:`call_soon` ãŒè¿”ã‚‹ã¨å‘¼ã³å‡ºã•ã‚Œã€åˆ¶å¾¡ã¯ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã«è¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:133
msgid ""
"This operates as a :abbr:`FIFO (first-in, first-out)` queue, callbacks are "
"called in the order in which they are registered.  Each callback will be "
"called exactly once."
msgstr ""
"ã“ã‚Œã¯ :abbr:`FIFO (first-in, first-out)` "
"ã‚­ãƒ¥ãƒ¼ã®ã‚ˆã†ã«å‡¦ç†ã•ã‚Œã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ç™»éŒ²ã•ã‚ŒãŸé †ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚å„ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯å³å¯†ã« 1 å›ã ã‘å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:137
msgid ""
"Any positional arguments after the callback will be passed to the callback "
"when it is called."
msgstr "*callback* ã®å¾Œã®ä½ç½®å¼•æ•° *args* ã¯ã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã«æ¸¡ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:140
#: ../../library/asyncio-eventloop.rst:197
msgid ""
"An optional keyword-only *context* argument allows specifying a custom "
":class:`contextvars.Context` for the *callback* to run in.  The current "
"context is used when no *context* is provided."
msgstr ""

#: ../../library/asyncio-eventloop.rst:144
msgid ""
"An instance of :class:`asyncio.Handle` is returned, which can be used to "
"cancel the callback."
msgstr ":class:`asyncio.Handle` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:147
#: ../../library/asyncio-eventloop.rst:201
#: ../../library/asyncio-eventloop.rst:219
#: ../../library/asyncio-eventloop.rst:649
#: ../../library/asyncio-eventloop.rst:661
#: ../../library/asyncio-eventloop.rst:867
msgid ""
":ref:`Use functools.partial to pass keywords to the callback <asyncio-pass-"
"keywords>`."
msgstr ""
":ref:`ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã«å¼•æ•°ã‚’æ¸¡ã™ã«ã¯ functools.partial ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ <asyncio-pass-keywords>`ã€‚"

#: ../../library/asyncio-eventloop.rst:150
#: ../../library/asyncio-eventloop.rst:161
#: ../../library/asyncio-eventloop.rst:204
#: ../../library/asyncio-eventloop.rst:222
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""

#: ../../library/asyncio-eventloop.rst:156
msgid "Like :meth:`call_soon`, but thread safe."
msgstr ":meth:`call_soon` ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:158
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr "ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã® :ref:`asyncio-multithreading` ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncio-eventloop.rst:169
msgid "Delayed calls"
msgstr "é…å»¶å‘¼ã³å‡ºã—"

#: ../../library/asyncio-eventloop.rst:171
msgid ""
"The event loop has its own internal clock for computing timeouts. Which "
"clock is used depends on the (platform-specific) event loop implementation; "
"ideally it is a monotonic clock.  This will generally be a different clock "
"than :func:`time.time`."
msgstr ""
"ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨ˆæ¸¬ã™ã‚‹ãŸã‚ã«è‡ªèº«ã«å†…éƒ¨æ™‚è¨ˆã‚’æŒã£ã¦ã„ã¾ã™ã€‚å†…éƒ¨æ™‚è¨ˆã¯ (ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å›ºæœ‰ã®) "
"ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®å®Ÿè£…ã«ä¾å­˜ã—ãŸã‚‚ã®ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ç†æƒ³çš„ã«ã¯ã€ã“ã‚Œã¯å˜èª¿æ™‚è¨ˆ (è¨³æ³¨: å·»ãæˆ»ã‚‹ã“ã¨ã®ãªã„æ™‚è¨ˆ) ã§ã™ã€‚ã“ã‚Œã¯é€šå¸¸ "
":func:`time.time` ã¨ã¯ç•°ãªã‚‹æ™‚è¨ˆã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:178
msgid ""
"Timeouts (relative *delay* or absolute *when*) should not exceed one day."
msgstr "ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ (ç›¸å¯¾å€¤ *delay* ã¾ãŸã¯çµ¶å¯¾å€¤ *when*) ã¯ 1 æ—¥ã‚’è¶…ãˆã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:183
msgid ""
"Arrange for the *callback* to be called after the given *delay* seconds "
"(either an int or float)."
msgstr "å¼•æ•° *delay* ç§’å¾Œã« *callback* ã‚’å‘¼ã³å‡ºã™æº–å‚™ã‚’ã—ã¾ã™ã€‚*delay* ã¯ int ã¾ãŸã¯ float ã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:186
#: ../../library/asyncio-eventloop.rst:216
msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned, which can be used "
"to cancel the callback."
msgstr ""

#: ../../library/asyncio-eventloop.rst:189
msgid ""
"*callback* will be called exactly once per call to :meth:`call_later`. If "
"two callbacks are scheduled for exactly the same time, it is undefined which"
" will be called first."
msgstr ""
"*callback* ã¯ :meth:`call_later` ã‚’å‘¼ã³å‡ºã™ãŸã³ã«å³å¯†ã« 1 åº¦ã ã‘å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚2 "
"å€‹ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒå®Œå…¨ã«åŒã˜æ™‚é–“ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ã©ã¡ã‚‰ãŒå…ˆã«å®Ÿè¡Œã•ã‚Œã‚‹ã‹ã¯ä¿è¨¼ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:193
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with some named arguments, use"
" a closure or :func:`functools.partial`."
msgstr ""
"ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã«ä»»æ„ã®ä½ç½®å¼•æ•° *args* ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚åå‰ä»˜ãå¼•æ•°ã‚’ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã«æ¸¡ã—ãŸã„å ´åˆã€ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‹ "
":func:`functools.partial` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncio-eventloop.rst:210
msgid ""
"Arrange for the *callback* to be called at the given absolute timestamp "
"*when* (an int or float), using the same time reference as "
":meth:`AbstractEventLoop.time`."
msgstr ""
"çµ¶å¯¾ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ— *when* (int ã¾ãŸã¯ float) ã«ãªã£ãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã‚‹ *callback* ã‚’æº–å‚™ã—ã¾ã™ã€‚\n"
"æ™‚åˆ»ã¯ :meth:`AbstractEventLoop.time` ã‚’å‚ç…§ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:214
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®æŒ¯ã‚‹èˆã„ã¯ :meth:`call_later` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:228
msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal clock."
msgstr "ç¾åœ¨ã®æ™‚åˆ»ã‚’ :class:`float` å€¤ã§è¿”ã—ã¾ã™ã€‚æ™‚åˆ»ã¯ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®å†…éƒ¨æ™‚è¨ˆã«å¾“ã„ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:233
msgid "The :func:`asyncio.sleep` function."
msgstr "é–¢æ•° :func:`asyncio.sleep`ã€‚"

#: ../../library/asyncio-eventloop.rst:237
msgid "Futures"
msgstr "Future"

#: ../../library/asyncio-eventloop.rst:241
msgid "Create an :class:`asyncio.Future` object attached to the loop."
msgstr "ãƒ«ãƒ¼ãƒ—ã«ä»˜å±ã—ãŸ :class:`asyncio.Future` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:243
msgid ""
"This is a preferred way to create futures in asyncio, as event loop "
"implementations can provide alternative implementations of the Future class "
"(with better performance or instrumentation)."
msgstr ""
"asyncio ã§ Futures ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«æ¨å¥¨ã•ã‚Œã‚‹æ–¹æ³•ã§ã™ã€‚ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€Futures "
"ã‚¯ãƒ©ã‚¹ã®(ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚„è¨ˆæ¸¬æ–¹æ³•ãŒå„ªã‚ŒãŸ) ä»£æ›¿å®Ÿè£… ãŒæä¾›ã•ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ãŸã‚ã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:251
msgid "Tasks"
msgstr "ã‚¿ã‚¹ã‚¯"

#: ../../library/asyncio-eventloop.rst:255
msgid ""
"Schedule the execution of a :ref:`coroutine object <coroutine>`: wrap it in "
"a future. Return a :class:`Task` object."
msgstr ""
":ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <coroutine>` ã®å®Ÿè¡Œã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã—ã¾ã™: ã“ã®ã¨ããƒ•ãƒ¥ãƒ¼ãƒãƒ£ã«ãƒ©ãƒƒãƒ—ã—ã¾ã™ã€‚:class:`Task`"
" ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:258
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of "
":class:`Task`."
msgstr ""
"ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã¯ç›¸äº’é‹ç”¨ã®ãŸã‚ã®è‡ªèº«ã® :class:`Task` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚ã“ã®å ´åˆã€çµæœã¯ "
":class:`Task` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:266
msgid ""
"Set a task factory that will be used by "
":meth:`AbstractEventLoop.create_task`."
msgstr ":meth:`AbstractEventLoop.create_task` ãŒä½¿ç”¨ã™ã‚‹ã‚¿ã‚¹ã‚¯ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:269
msgid "If *factory* is ``None`` the default task factory will be set."
msgstr "*factory* ãŒ ``None`` ã®å ´åˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ã‚¹ã‚¯ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:271
msgid ""
"If *factory* is a *callable*, it should have a signature matching ``(loop, "
"coro)``, where *loop* will be a reference to the active event loop, *coro* "
"will be a coroutine object.  The callable must return an "
":class:`asyncio.Future` compatible object."
msgstr ""
"*factory* ãŒ *å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ* ã®å ´åˆã€ ``(loop, coro)`` ã«ä¸€è‡´ã™ã‚‹ã‚·ã‚°ãƒ‹ãƒãƒ£ã‚’æŒã£ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"*loop* ã¯æœ‰åŠ¹ãªã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã¸ã®å‚ç…§ã§ã€ *coro* ã¯ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚\n"
"å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ :class:`asyncio.Future` äº’æ›ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:280
msgid "Return a task factory, or ``None`` if the default one is in use."
msgstr "ã‚¿ã‚¹ã‚¯ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚‚ã®ãŒä½¿ç”¨ã•ã‚ŒãŸå ´åˆã¯ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:286
msgid "Creating connections"
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ä½œæˆ"

#: ../../library/asyncio-eventloop.rst:290
msgid ""
"Create a streaming transport connection to a given Internet *host* and "
"*port*: socket family :py:data:`~socket.AF_INET` or "
":py:data:`~socket.AF_INET6` depending on *host* (or *family* if specified), "
"socket type :py:data:`~socket.SOCK_STREAM`.  *protocol_factory* must be a "
"callable returning a :ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆ *host* ãŠã‚ˆã³ *port* ã¸ã®ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°è»¢é€ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½œæˆã—ã¾ã™: ã‚½ã‚±ãƒƒãƒˆãƒ•ã‚¡ãƒŸãƒª "
":py:data:`~socket.AF_INET` ã¾ãŸã¯ :py:data:`~socket.AF_INET6` ã¯ *host* "
"(ã¾ãŸã¯æŒ‡å®šã•ã‚Œã¦ã„ã‚Œã° *family*) ã«ä¾å­˜ã—ã€ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã¯ :py:data:`~socket.SOCK_STREAM` "
"ã«ãªã‚Šã¾ã™ã€‚*protocol_factory* ã¯ :ref:`ãƒ—ãƒ­ãƒˆã‚³ãƒ« <asyncio-protocol>` "
"ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:296
#: ../../library/asyncio-eventloop.rst:378
#: ../../library/asyncio-eventloop.rst:431
msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr ""

#: ../../library/asyncio-eventloop.rst:299
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "æ™‚ç³»åˆ—ã§ã®ä¸‹å±¤å‡¦ç†ã®æ¦‚è¦ã¯ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã™:"

#: ../../library/asyncio-eventloop.rst:301
msgid ""
"The connection is established, and a :ref:`transport <asyncio-transport>` is"
" created to represent it."
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ç¢ºç«‹ã—ã€ãã‚Œã‚’è¡¨ã™ :ref:`ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆ <asyncio-transport>` ãŒä½œæˆã•ã‚Œã‚‹ã€‚"

#: ../../library/asyncio-eventloop.rst:304
msgid ""
"*protocol_factory* is called without arguments and must return a "
":ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* ãŒå¼•æ•°ãªã—ã§å‘¼ã³å‡ºã•ã‚Œã€:ref:`ãƒ—ãƒ­ãƒˆã‚³ãƒ« <asyncio-protocol>` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:307
msgid ""
"The protocol instance is tied to the transport, and its "
":meth:`connection_made` method is called."
msgstr "ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã¨ç´ä»˜ã‘ã‚‰ã‚Œã€ãã‚Œã® :meth:`connection_made` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚"

#: ../../library/asyncio-eventloop.rst:310
msgid ""
"The coroutine returns successfully with the ``(transport, protocol)`` pair."
msgstr "ã‚³ãƒ«ãƒ¼ãƒãƒ³ã¯ ``(ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆ, ãƒ—ãƒ­ãƒˆã‚³ãƒ«)`` ã®ãƒšã‚¢ã‚’è¿”ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:313
msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr "ä½œæˆã•ã‚ŒãŸãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã¯å®Ÿè£…ä¾å­˜ã®åŒæ–¹å‘ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:316
msgid ""
"*protocol_factory* can be any kind of callable, not necessarily a class.  "
"For example, if you want to use a pre-created protocol instance, you can "
"pass ``lambda: my_protocol``."
msgstr ""
"*protocol_factory* "
"ã¯ã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹å¿…è¦ã¯ãªãã€ã‚ã‚‰ã‚†ã‚‹ç¨®é¡ã®å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨å¯èƒ½ã§ã™ã€‚ä¾‹ãˆã°ã€ã‚ã‚‰ã‹ã˜ã‚ä½œæˆã—ã¦ãŠã„ãŸãƒ—ãƒ­ã‚³ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½¿ç”¨ã—ãŸã„å ´åˆã€``lambda:"
" my_protocol`` ã‚’æ¸¡ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:320
msgid "Options that change how the connection is created:"
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ä½œæˆæ–¹æ³•ã‚’å¤‰æ›´ã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™:"

#: ../../library/asyncio-eventloop.rst:322
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is "
":const:`True`, a context with some unspecified default settings is used."
msgstr ""
"*ssl*: å½å€¤ä»¥å¤–ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€SSL/TLS ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆãŒä½œæˆã•ã‚Œã¾ã™ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ãƒ—ãƒ¬ãƒ¼ãƒ³ TCP "
"ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆãŒä½œæˆã•ã‚Œã¾ã™)ã€‚*ssl* ãŒ :class:`ssl.SSLContext` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™; *ssl* ãŒ :const:`True` "
"ã®å ´åˆã€ã„ãã¤ã‹ã®æœªå®šç¾©ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:328
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`SSL/TLS ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã«ã¤ã„ã¦ã®è€ƒå¯Ÿ <ssl-security>`"

#: ../../library/asyncio-eventloop.rst:330
msgid ""
"*server_hostname*, is only for use together with *ssl*, and sets or "
"overrides the hostname that the target server's certificate will be matched "
"against.  By default the value of the *host* argument is used.  If *host* is"
" empty, there is no default and you must pass a value for *server_hostname*."
"  If *server_hostname* is an empty string, hostname matching is disabled "
"(which is a serious security risk, allowing for man-in-the-middle-attacks)."
msgstr ""
"*server_hostname* ã¯ *ssl* "
"æŒ‡å®šæ™‚ã®ã¿ä½¿ç”¨ã—ã€å¯¾è±¡ã‚µãƒ¼ãƒãƒ¼ã®è¨¼æ˜æ›¸ã«ä¸€è‡´ã™ã‚‹ãƒ›ã‚¹ãƒˆåã‚’è¨­å®šã¾ãŸã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯å¼•æ•° *host* "
"ã®å€¤ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚*host* ãŒç©ºã®å ´åˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ãªãã€*server_hostname* "
"ã«å€¤ã‚’æ¸¡ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚*server_hostname* ãŒç©ºã®å ´åˆã€ãƒ›ã‚¹ãƒˆåã®ãƒãƒƒãƒãƒ³ã‚°ã¯ç„¡åŠ¹ã«ãªã‚Šã¾ã™ "
"(æ·±åˆ»ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ã«ãªã‚Šã€ä¸­é–“è€…æ”»æ’ƒã«å¯¾ã™ã‚‹è„†å¼±æ€§ã«ãªã‚Šã¾ã™)ã€‚"

#: ../../library/asyncio-eventloop.rst:338
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given,"
" these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*, *proto*, *flags* ã¯ä»»æ„ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã§ã‚ã‚Šã€*host* è§£æ±ºã®ãŸã‚ã® getaddrinfo() "
"çµŒç”±ã§æ¸¡ã•ã‚Œã‚‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŠã‚ˆã³ãƒ•ãƒ©ã‚°ã«ãªã‚Šã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ã“ã‚Œã‚‰ã¯ã™ã¹ã¦ :mod:`socket` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šæ•°ã«å¾“ã£ãŸæ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:343
msgid ""
"*sock*, if given, should be an existing, already connected "
":class:`socket.socket` object to be used by the transport. If *sock* is "
"given, none of *host*, *port*, *family*, *proto*, *flags* and *local_addr* "
"should be specified."
msgstr ""
"*sock* ã‚’ä¸ãˆã‚‹å ´åˆã€ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã«ä½¿ç”¨ã•ã‚Œã‚‹ã€æ—¢å­˜ã®ã€ã™ã§ã«æ¥ç¶šæ¸ˆã® :class:`socket.socket` "
"ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã—ã¾ã™ã€‚*sock* ã‚’æŒ‡å®šã™ã‚‹å ´åˆã€*host*ã€*port*ã€*family*ã€*proto*ã€*flags* ãŠã‚ˆã³ "
"*local_addr* ã‚’æŒ‡å®šã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:348
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind"
" the socket to locally.  The *local_host* and *local_port* are looked up "
"using getaddrinfo(), similarly to *host* and *port*."
msgstr ""
"*local_addr* ã‚’ä¸ãˆã‚‹å ´åˆã€ã‚½ã‚±ãƒƒãƒˆã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã«æŸç¸›ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã™ã‚‹ ``(local_host, local_port)`` "
"ã®ã‚¿ãƒ—ãƒ«ã‚’æŒ‡å®šã—ã¾ã™ã€‚*local_host* ãŠã‚ˆã³ *local_port* ã¯ *host* ãŠã‚ˆã³ *port* ã¨åŒæ§˜ã« "
"getaddrinfo() ã‚’ä½¿ç”¨ã—ã¦ãƒ«ãƒƒã‚¯ã‚¢ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:352
#: ../../library/asyncio-eventloop.rst:560
#: ../../library/asyncio-eventloop.rst:629
msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to "
"wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:358
#: ../../library/asyncio-eventloop.rst:444
#: ../../library/asyncio-eventloop.rst:568
msgid "The *ssl_handshake_timeout* parameter."
msgstr ""

#: ../../library/asyncio-eventloop.rst:362
#: ../../library/asyncio-eventloop.rst:514
msgid "On Windows with :class:`ProactorEventLoop`, SSL/TLS is now supported."
msgstr "Windows ã® :class:`ProactorEventLoop` ã§ SSL/TLS ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/asyncio-eventloop.rst:366
msgid ""
"The :func:`open_connection` function can be used to get a pair of "
"(:class:`StreamReader`, :class:`StreamWriter`) instead of a protocol."
msgstr ""
"é–¢æ•° :func:`open_connection` ã¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã¯ãªã (:class:`StreamReader`, "
":class:`StreamWriter`) ã®ãƒšã‚¢ã®å–å¾—ã«ä½¿ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:372
msgid ""
"Create datagram connection: socket family :py:data:`~socket.AF_INET`, "
":py:data:`~socket.AF_INET6` or :py:data:`~socket.AF_UNIX` depending on "
"*host* (or *family* if specified), socket type "
":py:data:`~socket.SOCK_DGRAM`. *protocol_factory* must be a callable "
"returning a :ref:`protocol <asyncio-protocol>` instance."
msgstr ""

#: ../../library/asyncio-eventloop.rst:381
msgid "Options changing how the connection is created:"
msgstr "ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ä½œæˆæ–¹æ³•ã‚’å¤‰æ›´ã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™:"

#: ../../library/asyncio-eventloop.rst:383
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind"
" the socket to locally.  The *local_host* and *local_port* are looked up "
"using :meth:`getaddrinfo`."
msgstr ""
"*local_addr* ãŒæŒ‡å®šã•ã‚Œã‚‹å ´åˆã€``(local_host, local_port)`` "
"ã®ã‚¿ãƒ—ãƒ«ã§ã€ã‚½ã‚±ãƒƒãƒˆã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã§æŸç¸›ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚*local_host* ã¨ *local_port* ã¯ "
":meth:`getaddrinfo` ã‚’ä½¿ç”¨ã—ã¦æ¤œç´¢ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:387
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port*"
" are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr* ãŒæŒ‡å®šã•ã‚Œã‚‹å ´åˆã€``(remote_host, remote_por)`` "
"ã®ã‚¿ãƒ—ãƒ«ã§ã€ã‚½ã‚±ãƒƒãƒˆã‚’ãƒªãƒ¢ãƒ¼ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã«æŸç¸›ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚*remote_host* ã¨ *remote_port* ã¯ "
":meth:`getaddrinfo` ã‚’ä½¿ç”¨ã—ã¦æ¤œç´¢ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:391
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* ã¯ä»»æ„ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ•ã‚¡ãƒŸãƒªã§ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ•ã‚¡ãƒŸãƒªã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã€ãƒ•ãƒ©ã‚°ã¯ã€*host* è§£æ±ºã®ãŸã‚ "
":meth:`getaddrinfo` çµŒç”±ã§ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§æ¸¡ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æŒ‡å®šã™ã‚‹å ´åˆã€ã™ã¹ã¦ :mod:`socket` "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šæ•°ã«å¾“ã£ãŸæ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:396
#: ../../library/asyncio-eventloop.rst:488
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in TIME_WAIT state,"
" without waiting for its natural timeout to expire. If not specified will "
"automatically be set to ``True`` on UNIX."
msgstr ""
"*reuse_address* ã¯ã€ TIME_WAIT "
"çŠ¶æ…‹ã«ã‚ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«ã‚½ã‚±ãƒƒãƒˆã‚’ã€ãã®çŠ¶æ…‹ãŒè‡ªç„¶ã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã™ã‚‹ã®ã‚’å¾…ã¤ã“ã¨ãªãå†åˆ©ç”¨ã™ã‚‹ã‚ˆã†ã‚«ãƒ¼ãƒãƒ«ã«æŒ‡ç¤ºã—ã¾ã™ï¼ˆè¨³è¨»: ã‚½ã‚±ãƒƒãƒˆã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ "
"SO_REUSEADDR ã‚’ä½¿ç”¨ã—ã¾ã™ï¼‰ã€‚æŒ‡å®šã—ãªã„å ´åˆã€UNIX ã§ã¯è‡ªå‹•çš„ã« ``True`` ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:401
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same"
" port as other existing endpoints are bound to, so long as they all set this"
" flag when being created. This option is not supported on Windows and some "
"UNIX's. If the :py:data:`~socket.SO_REUSEPORT` constant is not defined then "
"this capability is unsupported."
msgstr ""
"*reuse_port* "
"ã¯ã€åŒã˜ãƒãƒ¼ãƒˆã«ãƒã‚¤ãƒ³ãƒ‰ã•ã‚ŒãŸæ—¢å­˜ã®ç«¯ç‚¹ã™ã¹ã¦ãŒã“ã®ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã—ã¦ç”Ÿæˆã•ã‚Œã¦ã„ã‚‹å ´åˆã«é™ã‚Šã€ã“ã®ç«¯ç‚¹ã‚’æ—¢å­˜ã®ç«¯ç‚¹ã¨åŒã˜ãƒãƒ¼ãƒˆã«ãƒã‚¤ãƒ³ãƒ‰ã™ã‚‹ã“ã¨ã‚’ã‚«ãƒ¼ãƒãƒ«ã«è¨±å¯ã—ã¾ã™ï¼ˆè¨³è¨»:"
" ã‚½ã‚±ãƒƒãƒˆã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ SO_REUSEPORT ã‚’ä½¿ç”¨ã—ã¾ã™ï¼‰ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã€Windows ã‚„ã„ãã¤ã‹ã® UNIX "
"ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã›ã‚“ã€‚ã‚‚ã—å®šæ•° :py:data:`~socket.SO_REUSEPORT` "
"ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ã“ã®æ©Ÿèƒ½ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:407
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr ""
"*allow_broadcast* ã¯ã€ã‚«ãƒ¼ãƒãƒ«ã«ã€ã“ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã™ã‚‹ã“ã¨ã‚’è¨±å¯ã™ã‚‹ã‚ˆã†ã«æŒ‡ç¤ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:410
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be "
":const:`None`)."
msgstr ""
"ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® *sock* ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ã€æ—¢å­˜ã®ã€ã™ã§ã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ :class:`socket.socket` "
"ã‚’ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã§ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€*local_addr* ã¨ *remote_addr* ã¯çœç•¥ã—ã¦ãã ã•ã„ "
"(:const:`None` ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“)ã€‚"

#: ../../library/asyncio-eventloop.rst:415
msgid ""
"On Windows with :class:`ProactorEventLoop`, this method is not supported."
msgstr "Windows ã® :class:`ProactorEventLoop` ã§ã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:417
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and "
":ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""
":ref:`UDP echo ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ« <asyncio-udp-echo-client-protocol>` ãŠã‚ˆã³ :ref:`UDP"
" echo ã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ãƒˆã‚³ãƒ« <asyncio-udp-echo-server-protocol>` ã®ä¾‹ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncio-eventloop.rst:420
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""
"*family*, *proto*, *flags*, *reuse_address*, *reuse_port, *allow_broadcast*,"
" *sock* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚"

#: ../../library/asyncio-eventloop.rst:426
msgid ""
"Create UNIX connection: socket family :py:data:`~socket.AF_UNIX`, socket "
"type :py:data:`~socket.SOCK_STREAM`. The :py:data:`~socket.AF_UNIX` socket "
"family is used to communicate between processes on the same machine "
"efficiently."
msgstr ""
"UNIX ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½œæˆã—ã¾ã™: ã‚½ã‚±ãƒƒãƒˆãƒ•ã‚¡ãƒŸãƒªã¯ :py:data:`~socket.AF_UNIX`ã€ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã¯ "
":py:data:`~socket.SOCK_STREAM` ã«ãªã‚Šã¾ã™ã€‚:py:data:`~socket.AF_UNIX` "
"ã‚½ã‚±ãƒƒãƒˆãƒ•ã‚¡ãƒŸãƒªã¯åŒä¸€ãƒã‚·ãƒ³ä¸Šã®ãƒ—ãƒ­ã‚»ã‚¹é–“ã§åŠ¹ç‡çš„ã«é€šä¿¡ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:434
#: ../../library/asyncio-eventloop.rst:531
msgid ""
"*path* is the name of a UNIX domain socket, and is required unless a *sock* "
"parameter is specified.  Abstract UNIX sockets, :class:`str`, "
":class:`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""

#: ../../library/asyncio-eventloop.rst:438
msgid ""
"See the :meth:`AbstractEventLoop.create_connection` method for parameters."
msgstr "å¼•æ•°ã«ã¤ã„ã¦ã¯ :meth:`AbstractEventLoop.create_connection` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncio-eventloop.rst:440
#: ../../library/asyncio-eventloop.rst:535
msgid "Availability: UNIX."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ: UNIXã€‚"

#: ../../library/asyncio-eventloop.rst:448
msgid "The *path* parameter can now be a :term:`path-like object`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:452
msgid "Creating listening connections"
msgstr "å¾…ã¡å—ã‘ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ä½œæˆ"

#: ../../library/asyncio-eventloop.rst:456
msgid ""
"Create a TCP server (socket type :data:`~socket.SOCK_STREAM`) bound to "
"*host* and *port*."
msgstr ""
"*host* ãŠã‚ˆã³ *port* ã«æŸç¸›ã•ã‚ŒãŸ TCP ã‚µãƒ¼ãƒãƒ¼ (ã‚½ã‚±ãƒƒãƒˆã‚¿ã‚¤ãƒ— :data:`~socket.SOCK_STREAM`) "
"ã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:459
msgid ""
"Return a :class:`Server` object, its :attr:`~Server.sockets` attribute "
"contains created sockets. Use the :meth:`Server.close` method to stop the "
"server: close listening sockets."
msgstr ""
":class:`Server` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã® :attr:`~Server.sockets` "
"å±æ€§ã«ã¯ä½œæˆã•ã‚ŒãŸã‚½ã‚±ãƒƒãƒˆãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚ã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢ã™ã‚‹ã«ã¯ :meth:`Server.close` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™: "
"å¾…å—ä¸­ã®ã‚½ã‚±ãƒƒãƒˆã‚’é–‰ã˜ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:463
#: ../../library/asyncio-eventloop.rst:552
#: ../../library/asyncio-eventloop.rst:615
msgid "Parameters:"
msgstr "å¼•æ•°:"

#: ../../library/asyncio-eventloop.rst:465
msgid ""
"The *host* parameter can be a string, in that case the TCP server is bound "
"to *host* and *port*. The *host* parameter can also be a sequence of strings"
" and in that case the TCP server is bound to all hosts of the sequence. If "
"*host* is an empty string or ``None``, all interfaces are assumed and a list"
" of multiple sockets will be returned (most likely one for IPv4 and another "
"one for IPv6)."
msgstr ""
"*host* å¼•æ•°ã«ã¯æ–‡å­—åˆ—ã‚’æ¸¡ã™ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚\n"
"ãã®å ´åˆã€TCP ã‚µãƒ¼ãƒã¯ *host* ã¨ *port* ã«æŸç¸›ã•ã‚Œã¾ã™ã€‚\n"
"*host* å¼•æ•°ã«ã¯æ–‡å­—åˆ—ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’æ¸¡ã™ã“ã¨ã‚‚å‡ºæ¥ã¾ã™ã€‚\n"
"ãã®å ´åˆ TCP ã‚µãƒ¼ãƒã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å…¨ãƒ›ã‚¹ãƒˆã«æŸç¸›ã•ã‚Œã¾ã™ã€‚\n"
"*host* ãŒç©ºã®æ–‡å­—åˆ—ã‚„ ``None`` ã®å ´åˆã€å…¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ãŒæƒ³å®šã•ã‚Œã€è¤‡æ•°ã®ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ (æœ€ã‚‚è¿‘ã„ã®ã¯ IPv4 ã‚„ IPv6 ã®ã‚‚ã®ã§ã™)ã€‚"

#: ../../library/asyncio-eventloop.rst:472
msgid ""
"*family* can be set to either :data:`socket.AF_INET` or "
":data:`~socket.AF_INET6` to force the socket to use IPv4 or IPv6. If not set"
" it will be determined from host (defaults to :data:`socket.AF_UNSPEC`)."
msgstr ""
"*family* ã«ã¯ :data:`socket.AF_INET` ã¾ãŸã¯ :data:`~socket.AF_INET6` ã‚’æŒ‡å®šã—ã€ã‚½ã‚±ãƒƒãƒˆã§ "
"IPv4 ã‚’ä½¿ç”¨ã™ã‚‹ã‹ IPv6 ã‚’ä½¿ç”¨ã™ã‚‹ã‹å¼·åˆ¶çš„ã«è¨­å®šã§ãã¾ã™ã€‚è¨­å®šã•ã‚Œãªã„å ´åˆãƒ›ã‚¹ãƒˆã‹ã‚‰æ±ºå®šã•ã‚Œã¾ã™ "
"(:data:`socket.AF_UNSPEC` ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãªã‚Šã¾ã™)ã€‚"

#: ../../library/asyncio-eventloop.rst:476
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* ã¯ :meth:`getaddrinfo` ã®ãŸã‚ã®ãƒ“ãƒƒãƒˆãƒã‚¹ã‚¯ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:478
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* should be omitted (must be "
":const:`None`)."
msgstr ""
"ä»»æ„ã®å¼•æ•° *sock* ã«ã¯ã€æ—¢å­˜ã®ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½¿ç”¨é †ã‚’æŒ‡å®šã§ãã¾ã™ã€‚æŒ‡å®šã—ãŸå ´åˆã€*host* ãŠã‚ˆã³ *port* "
"ã‚’æŒ‡å®šã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ (:const:`None` ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“)ã€‚"

#: ../../library/asyncio-eventloop.rst:482
msgid ""
"*backlog* is the maximum number of queued connections passed to "
":meth:`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* ã¯ :meth:`~socket.socket.listen` ã«æ¸¡ã•ã‚Œã‚‹ã€ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚‹ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®æœ€å¤§æ•°ã«ãªã‚Šã¾ã™ "
"(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ 100)ã€‚"

#: ../../library/asyncio-eventloop.rst:485
#: ../../library/asyncio-eventloop.rst:557
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr ""
"*ssl* ã«ã¯ :class:`~ssl.SSLContext` ã‚’æŒ‡å®šã§ãã¾ã™ã€‚æŒ‡å®šã™ã‚‹ã¨ã€å—ã‘ä»˜ã‘ãŸã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ä¸Šã§ã® SSL ã‚’æœ‰åŠ¹ã«ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:493
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same"
" port as other existing endpoints are bound to, so long as they all set this"
" flag when being created. This option is not supported on Windows."
msgstr ""
"*reuse_port* "
"ã¯ã€åŒã˜ãƒãƒ¼ãƒˆã«ãƒã‚¤ãƒ³ãƒ‰ã•ã‚ŒãŸæ—¢å­˜ã®ç«¯ç‚¹ã™ã¹ã¦ãŒã“ã®ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã—ã¦ç”Ÿæˆã•ã‚Œã¦ã„ã‚‹å ´åˆã«é™ã‚Šã€ã“ã®ç«¯ç‚¹ã‚’æ—¢å­˜ã®ç«¯ç‚¹ã¨åŒã˜ãƒãƒ¼ãƒˆã«ãƒã‚¤ãƒ³ãƒ‰ã™ã‚‹ã“ã¨ã‚’è¨±å¯ã™ã‚‹ã‚ˆã†ã€ã‚«ãƒ¼ãƒãƒ«ã«æŒ‡ç¤ºã—ã¾ã™ï¼ˆè¨³è¨»:"
" ã‚½ã‚±ãƒƒãƒˆã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ SO_REUSEPORT ã‚’ä½¿ç”¨ã—ã¾ã™ï¼‰ã€‚ã“ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã€Windows ã§ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:498
msgid ""
"*ssl_handshake_timeout* is (for an SSL server) the time in seconds to wait "
"for the SSL handshake to complete before aborting the connection. ``60.0`` "
"seconds if ``None`` (default)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:502
msgid ""
"*start_serving* set to ``True`` (the default) causes the created server to "
"start accepting connections immediately.  When set to ``False``, the user "
"should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever`"
" to make the server to start accepting connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:510
msgid "*ssl_handshake_timeout* and *start_serving* parameters."
msgstr ""

#: ../../library/asyncio-eventloop.rst:518
msgid ""
"The function :func:`start_server` creates a (:class:`StreamReader`, "
":class:`StreamWriter`) pair and calls back a function with this pair."
msgstr ""
"é–¢æ•° :func:`start_server` ã¯ (:class:`StreamReader`, :class:`StreamWriter`) "
"ã®ãƒšã‚¢ã‚’ä½œæˆã—ã€ã“ã®ãƒšã‚¢ã§é–¢æ•°ã‚’å†åº¦å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:523
msgid "The *host* parameter can now be a sequence of strings."
msgstr "*host* å¼•æ•°ã«æ–‡å­—åˆ—ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ä¸ãˆã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/asyncio-eventloop.rst:528
msgid ""
"Similar to :meth:`AbstractEventLoop.create_server`, but specific to the "
"socket family :py:data:`~socket.AF_UNIX`."
msgstr ""
":meth:`AbstractEventLoop.create_server` ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€ã‚½ã‚±ãƒƒãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼ "
":py:data:`~socket.AF_UNIX` å›ºæœ‰ã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:539
msgid "The *ssl_handshake_timeout* and *start_serving* parameters."
msgstr ""

#: ../../library/asyncio-eventloop.rst:543
msgid "The *path* parameter can now be a :class:`~pathlib.Path` object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:547
msgid "Handle an accepted connection."
msgstr "å—ã‘ä»˜ã‘ã‚‰ã‚ŒãŸæ¥ç¶šã‚’æ‰±ã„ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:549
msgid ""
"This is used by servers that accept connections outside of asyncio but that "
"use asyncio to handle them."
msgstr "asyncio ã®ç¯„å›²å¤–ã§æ¥ç¶šã‚’å—ã‘ä»˜ã‘ã‚‹ãŒã€asyncio ã‚’ä½¿ç”¨ã—ã¦ãã‚Œã‚‰ã‚’æ‰±ã†ã‚µãƒ¼ãƒã«ã‚ˆã‚Šä½¿ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:554
msgid ""
"*sock* is a preexisting socket object returned from an ``accept`` call."
msgstr "*sock* ã¯ã€ ``accept`` å‘¼ã³å‡ºã—ãŒè¿”ã™æ—¢å­˜ã®ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:564
msgid "When completed it returns a ``(transport, protocol)`` pair."
msgstr ""

#: ../../library/asyncio-eventloop.rst:574
msgid "File Transferring"
msgstr ""

#: ../../library/asyncio-eventloop.rst:580
msgid ""
"Send a *file* to *transport*, return the total number of bytes which were "
"sent."
msgstr ""

#: ../../library/asyncio-eventloop.rst:583
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr ""

#: ../../library/asyncio-eventloop.rst:585
#: ../../library/asyncio-eventloop.rst:780
msgid "*file* must be a regular file object opened in binary mode."
msgstr ""

#: ../../library/asyncio-eventloop.rst:587
#: ../../library/asyncio-eventloop.rst:782
msgid ""
"*offset* tells from where to start reading the file. If specified, *count* "
"is the total number of bytes to transmit as opposed to sending the file "
"until EOF is reached. File position is updated on return or also in case of "
"error in which case :meth:`file.tell() <io.IOBase.tell>` can be used to "
"figure out the number of bytes which were sent."
msgstr ""

#: ../../library/asyncio-eventloop.rst:594
#: ../../library/asyncio-eventloop.rst:789
msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the file "
"when the platform does not support the sendfile syscall (e.g. Windows or SSL"
" socket on Unix)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:598
#: ../../library/asyncio-eventloop.rst:793
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""

#: ../../library/asyncio-eventloop.rst:605
msgid "TLS Upgrade"
msgstr ""

#: ../../library/asyncio-eventloop.rst:609
msgid "Upgrades an existing connection to TLS."
msgstr ""

#: ../../library/asyncio-eventloop.rst:611
msgid ""
"Returns a new transport instance, that the *protocol* must start using "
"immediately after the *await*.  The *transport* instance passed to the "
"*start_tls* method should never be used again."
msgstr ""

#: ../../library/asyncio-eventloop.rst:617
msgid ""
"*transport* and *protocol* instances that methods like "
":meth:`~AbstractEventLoop.create_server` and "
":meth:`~AbstractEventLoop.create_connection` return."
msgstr ""

#: ../../library/asyncio-eventloop.rst:621
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:623
msgid ""
"*server_side* pass ``True`` when a server-side connection is being upgraded "
"(like the one created by :meth:`~AbstractEventLoop.create_server`)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:626
msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""

#: ../../library/asyncio-eventloop.rst:637
msgid "Watch file descriptors"
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã®ç›£è¦–"

#: ../../library/asyncio-eventloop.rst:639
msgid ""
"On Windows with :class:`SelectorEventLoop`, only socket handles are "
"supported (ex: pipe file descriptors are not supported)."
msgstr ""
"Windows ã® :class:`SelectorEventLoop` ã§ã¯ã€ã‚½ã‚±ãƒƒãƒˆã®æ‰±ã„ã®ã¿ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ "
"(ä¾‹ãˆã°ãƒ‘ã‚¤ãƒ—ã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã›ã‚“)ã€‚"

#: ../../library/asyncio-eventloop.rst:642
msgid ""
"On Windows with :class:`ProactorEventLoop`, these methods are not supported."
msgstr "Wndows ã® :class:`ProactorEventLoop` ã§ã¯ã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:646
msgid ""
"Start watching the file descriptor for read availability and then call the "
"*callback* with specified arguments."
msgstr "èª­ã¿è¾¼ã¿å¯èƒ½ãªãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã®ç›£è¦–ã‚’é–‹å§‹ã—ã€æŒ‡å®šã•ã‚ŒãŸå¼•æ•°ã§ *callback* ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:654
msgid "Stop watching the file descriptor for read availability."
msgstr "èª­ã¿è¾¼ã¿å¯èƒ½ãªãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã®ç›£è¦–ã‚’åœæ­¢ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:658
msgid ""
"Start watching the file descriptor for write availability and then call the "
"*callback* with specified arguments."
msgstr "æ›¸ãè¾¼ã¿å¯èƒ½ãªãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã®ç›£è¦–ã‚’é–‹å§‹ã—ã€æŒ‡å®šã•ã‚ŒãŸå¼•æ•°ã§ *callback* ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:666
msgid "Stop watching the file descriptor for write availability."
msgstr "æ›¸ãè¾¼ã¿å¯èƒ½ãªãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã®ç›£è¦–ã‚’åœæ­¢ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:668
msgid ""
"The :ref:`watch a file descriptor for read events <asyncio-watch-read-"
"event>` example uses the low-level :meth:`AbstractEventLoop.add_reader` "
"method to register the file descriptor of a socket."
msgstr ""
":ref:`èª­ã¿è¾¼ã¿ã‚¤ãƒ™ãƒ³ãƒˆç”¨ã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã®ç›£è¦– <asyncio-watch-read-event>` "
"ã®ä¾‹ã§ã¯ã€ã‚½ã‚±ãƒƒãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã‚’ç™»éŒ²ã™ã‚‹ã®ã«ä½æ°´æº–ã® :meth:`AbstractEventLoop.add_reader` "
"ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:674
msgid "Low-level socket operations"
msgstr "ä½æ°´æº–ã®ã‚½ã‚±ãƒƒãƒˆæ“ä½œ"

#: ../../library/asyncio-eventloop.rst:678
msgid ""
"Receive data from the socket.  Modeled after blocking "
":meth:`socket.socket.recv` method."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚\n"
":meth:`socket.socket.recv` ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒ¢ãƒ‡ãƒ«ã«ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:681
msgid ""
"The return value is a bytes object representing the data received.  The "
"maximum amount of data to be received at once is specified by *nbytes*."
msgstr ""
"å—ã‘å–ã£ãŸãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ bytes ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚\n"
"ä¸€åº¦ã«å—ã‘å–ã‚‹ãƒ‡ãƒ¼ã‚¿ã®æœ€å¤§é‡ã‚’ *nbytes* ã§æŒ‡å®šã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:685
#: ../../library/asyncio-eventloop.rst:701
#: ../../library/asyncio-eventloop.rst:717
#: ../../library/asyncio-eventloop.rst:730
msgid ""
"With :class:`SelectorEventLoop` event loop, the socket *sock* must be non-"
"blocking."
msgstr ":class:`SelectorEventLoop` ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®å ´åˆã€ã‚½ã‚±ãƒƒãƒˆ *sock* ã¯éãƒ–ãƒ­ãƒƒã‚¯ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:688
#: ../../library/asyncio-eventloop.rst:759
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:695
msgid ""
"Receive data from the socket.  Modeled after blocking "
":meth:`socket.socket.recv_into` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:698
msgid ""
"The received data is written into *buf* (a writable buffer). The return "
"value is the number of bytes written."
msgstr ""

#: ../../library/asyncio-eventloop.rst:708
msgid ""
"Send data to the socket.  Modeled after blocking "
":meth:`socket.socket.sendall` method."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚Šã¾ã™ã€‚\n"
":meth:`socket.socket.sendall` ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒ¢ãƒ‡ãƒ«ã«ã„ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:711
msgid ""
"The socket must be connected to a remote socket. This method continues to "
"send data from *data* until either all data has been sent or an error "
"occurs.  ``None`` is returned on success.  On error, an exception is raised,"
" and there is no way to determine how much data, if any, was successfully "
"processed by the receiving end of the connection."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã¯ãƒªãƒ¢ãƒ¼ãƒˆã‚½ã‚±ãƒƒãƒˆã«æ¥ç¶šã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å…¨ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã™ã‚‹ã‹ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã¾ã§ã€ *data* ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ç¶šã‘ã¾ã™ã€‚\n"
"æ­£å¸¸çµ‚äº†ã™ã‚‹ã¨ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚\n"
"ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã¯ä¾‹å¤–ã‚’é€å‡ºã—ã¾ã™ãŒã€æ­£å¸¸ã«å‡¦ç†ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿é‡ã‚’ç¢ºèªã™ã‚‹æ‰‹æ®µã¯ã‚ã‚Šã¾ã›ã‚“ã€‚\n"
"ãŸã¨ãˆã‚ã£ãŸã¨ã—ã¦ã‚‚ã€æ¥ç¶šã®çµ‚äº†ã‚’å—ä¿¡ã™ã‚‹ã¾ã§ã¯ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:720
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned an :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:727
msgid ""
"Connect to a remote socket at *address*.  Modeled after blocking "
":meth:`socket.socket.connect` method."
msgstr ""
"*address* ã®ã‚½ã‚±ãƒƒãƒˆã«æ¥ç¶šã—ã¾ã™ã€‚\n"
":meth:`socket.socket.connect` ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒ¢ãƒ‡ãƒ«ã«ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:733
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling "
":func:`socket.inet_pton`.  If not, :meth:`AbstractEventLoop.getaddrinfo` "
"will be used to resolve the *address*."
msgstr ""
"``address`` ã‚’è§£æ±ºã™ã‚‹å¿…è¦ã¯ãªããªã‚Šã¾ã—ãŸã€‚\n"
"``sock_connect`` ã¯ :func:`socket.inet_pton` ã®å‘¼ã³å‡ºã—ã§ *address* ãŒæ—¢ã«è§£æ±ºã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚\n"
"è§£æ±ºã•ã‚Œã¦ã„ãªã„å ´åˆ :meth:`AbstractEventLoop.getaddrinfo` ã‚’ä½¿ç”¨ã—ã¦ *address* ã‚’è§£æ±ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:742
msgid ""
":meth:`AbstractEventLoop.create_connection` and  "
":func:`asyncio.open_connection() <open_connection>`."
msgstr ""
":meth:`AbstractEventLoop.create_connection` ãŠã‚ˆã³ "
":func:`asyncio.open_connection() <open_connection>`ã€‚"

#: ../../library/asyncio-eventloop.rst:748
msgid ""
"Accept a connection.  Modeled after blocking :meth:`socket.socket.accept`."
msgstr "æ¥ç¶šã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚ :meth:`socket.socket.accept` ã®ãƒ–ãƒ­ãƒƒã‚¯ ã‚’ãƒ¢ãƒ‡ãƒ«ã«ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:751
msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""
"ã‚½ã‚±ãƒƒãƒˆã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ã«æŸç¸›æ¸ˆã¿ã§ã€æ¥ç¶šã‚’ listen ä¸­ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚æˆ»ã‚Šå€¤ã¯ ``(conn, address)`` ã®ãƒšã‚¢ã§ã€*conn* "
"ã¯æ¥ç¶šã‚’é€šã˜ã¦ãƒ‡ãƒ¼ã‚¿ã®é€å—ä¿¡ã‚’è¡Œã†ãŸã‚ã® *æ–°ã—ã„* ã‚½ã‚±ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€*address* "
"ã¯æ¥ç¶šå…ˆã®ç«¯ç‚¹ã§ã‚½ã‚±ãƒƒãƒˆã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:757
msgid "The socket *sock* must be non-blocking."
msgstr "ã‚½ã‚±ãƒƒãƒˆ *sock* ã¯éãƒ–ãƒ­ãƒƒã‚¯ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:766
msgid ":meth:`AbstractEventLoop.create_server` and :func:`start_server`."
msgstr ":meth:`AbstractEventLoop.create_server` ãŠã‚ˆã³ :func:`start_server`ã€‚"

#: ../../library/asyncio-eventloop.rst:772
msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible and return"
" the total number of bytes which were sent."
msgstr ""

#: ../../library/asyncio-eventloop.rst:775
msgid "Asynchronous version of :meth:`socket.socket.sendfile`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:777
msgid ""
"*sock* must be non-blocking :class:`~socket.socket` of "
":const:`socket.SOCK_STREAM` type."
msgstr ""

#: ../../library/asyncio-eventloop.rst:800
msgid "Resolve host name"
msgstr "ãƒ›ã‚¹ãƒˆåã®è§£æ±º"

#: ../../library/asyncio-eventloop.rst:804
msgid ""
"This method is a :ref:`coroutine <coroutine>`, similar to "
":meth:`socket.getaddrinfo` function but non-blocking."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ <coroutine>` ã§ã€:meth:`socket.getaddrinfo` "
"é–¢æ•°ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:809
msgid ""
"This method is a :ref:`coroutine <coroutine>`, similar to "
":meth:`socket.getnameinfo` function but non-blocking."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ :ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ <coroutine>` ã§ã€:meth:`socket.getnameinfo` "
"é–¢æ•°ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:812
msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning "
":class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are "
"coroutines."
msgstr ""

#: ../../library/asyncio-eventloop.rst:820
msgid "Connect pipes"
msgstr "ãƒ‘ã‚¤ãƒ—ã®æ¥ç¶š"

#: ../../library/asyncio-eventloop.rst:822
msgid ""
"On Windows with :class:`SelectorEventLoop`, these methods are not supported."
" Use :class:`ProactorEventLoop` to support pipes on Windows."
msgstr ""
"Windows ã® :class:`SelectorEventLoop` ã§ã¯ã€ã“ã‚Œã‚‰ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚Windows "
"ã§ãƒ‘ã‚¤ãƒ—ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã«ã¯ã€:class:`ProactorEventLoop` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncio-eventloop.rst:827
msgid "Register read pipe in eventloop."
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—å†…ã§èª­ã¿è¾¼ã¿ãƒ‘ã‚¤ãƒ—ã‚’ç™»éŒ²ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:829
msgid ""
"*protocol_factory* should instantiate object with :class:`Protocol` "
"interface.  *pipe* is a :term:`file-like object <file object>`. Return pair "
"``(transport, protocol)``, where *transport* supports the "
":class:`ReadTransport` interface."
msgstr ""
"*protocol_factory* ã¯ :class:`Protocol` "
"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ *pipe* ã¯ :term:`ãƒ•ã‚¡ã‚¤ãƒ«ãƒ©ã‚¤ã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <file "
"object>` ã§ã™ã€‚ ``(ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆ, ãƒ—ãƒ­ãƒˆã‚³ãƒ«)`` ã®ãƒšã‚¢ã‚’è¿”ã—ã€ *ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆ* ã¯ :class:`ReadTransport`"
" ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:834
#: ../../library/asyncio-eventloop.rst:846
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ""
":class:`SelectorEventLoop` ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®å ´åˆã€*pipe* ã¯éãƒ–ãƒ­ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ã«è¨­å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:839
msgid "Register write pipe in eventloop."
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—å†…ã®æ›¸ãè¾¼ã¿ãƒ‘ã‚¤ãƒ—ã‚’ç™»éŒ²ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:841
msgid ""
"*protocol_factory* should instantiate object with :class:`BaseProtocol` "
"interface. *pipe* is :term:`file-like object <file object>`. Return pair "
"``(transport, protocol)``, where *transport* supports "
":class:`WriteTransport` interface."
msgstr ""
"*protocol_factory* ã¯ :class:`BaseProtocol` "
"ã§ä½œæˆã•ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚*pipe* ã¯ :term:`ãƒ•ã‚¡ã‚¤ãƒ«ãƒ©ã‚¤ã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <file object>` "
"ã§ã™ã€‚``(transport, protocol)`` ã®ãƒšã‚¢ã‚’è¿”ã—ã¾ã™ã€‚*transport* ã¯ :class:`WriteTransport` "
"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:851
msgid ""
"The :meth:`AbstractEventLoop.subprocess_exec` and "
":meth:`AbstractEventLoop.subprocess_shell` methods."
msgstr ""
":meth:`AbstractEventLoop.subprocess_exec` ãƒ¡ã‚½ãƒƒãƒ‰ãŠã‚ˆã³ "
":meth:`AbstractEventLoop.subprocess_shell` ãƒ¡ã‚½ãƒƒãƒ‰ã€‚"

#: ../../library/asyncio-eventloop.rst:856
msgid "UNIX signals"
msgstr "UNIX ã‚·ã‚°ãƒŠãƒ«"

#: ../../library/asyncio-eventloop.rst:858
msgid "Availability: UNIX only."
msgstr "åˆ©ç”¨ã§ãã‚‹ç’°å¢ƒ: UNIX ã®ã¿ã€‚"

#: ../../library/asyncio-eventloop.rst:862
msgid "Add a handler for a signal."
msgstr "ã‚·ã‚°ãƒŠãƒ«ç”¨ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’è¿½åŠ ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:864
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"ã‚·ã‚°ãƒŠãƒ«ãƒŠãƒ³ãƒãƒ¼ãŒèª¤ã£ã¦ã„ã‚‹ã‹æ•æ‰ä¸å¯èƒ½ãªå ´åˆ :exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®è¨­å®šã«å•é¡ŒãŒã‚ã£ãŸå ´åˆ "
":exc:`RuntimeError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:872
msgid "Remove a handler for a signal."
msgstr "ã‚·ã‚°ãƒŠãƒ«ç”¨ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:874
msgid "Return ``True`` if a signal handler was removed, ``False`` if not."
msgstr "ã‚·ã‚°ãƒŠãƒ«ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒå‰Šé™¤ã•ã‚Œã‚‹ã¨ ``True`` ãŒã€ã•ã‚Œãªã‘ã‚Œã° ``False`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:878
msgid "The :mod:`signal` module."
msgstr ":mod:`signal` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã€‚"

#: ../../library/asyncio-eventloop.rst:882
msgid "Executor"
msgstr "å®Ÿè¡Œè€…"

#: ../../library/asyncio-eventloop.rst:884
msgid ""
"Call a function in an :class:`~concurrent.futures.Executor` (pool of threads"
" or pool of processes). By default, an event loop uses a thread pool "
"executor (:class:`~concurrent.futures.ThreadPoolExecutor`)."
msgstr ""
":class:`~concurrent.futures.Executor` (ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ã¾ãŸã¯ãƒ—ãƒ­ã‚»ã‚¹ãƒ—ãƒ¼ãƒ«) "
"å†…ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ä¸€ã¤ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã¯ä¸€ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«å®Ÿè¡Œè€… "
"(:class:`~concurrent.futures.ThreadPoolExecutor`) ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:890
msgid "Arrange for a *func* to be called in the specified executor."
msgstr "ç‰¹å®šã®å®Ÿè¡Œè€…ã§ *func* ã‚’å‘¼ã³å‡ºã™æº–å‚™ã‚’ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:892
msgid ""
"The *executor* argument should be an :class:`~concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``."
msgstr ""
"å¼•æ•° *executor* ã¯ :class:`~concurrent.futures.Executor` "
"ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚*executor* ãŒ ``None`` ã®ã¨ããƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè¡Œè€…ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:895
msgid ""
":ref:`Use functools.partial to pass keywords to the *func* <asyncio-pass-"
"keywords>`."
msgstr ""
":ref:`*func* ã«ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æ¸¡ã™ã«ã¯ã€functools.partial ã‚’ä½¿ç”¨ã—ã¾ã™ <asyncio-pass-keywords>`ã€‚"

#: ../../library/asyncio-eventloop.rst:898
msgid "This method returns a :class:`asyncio.Future` object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:900
msgid ""
":meth:`BaseEventLoop.run_in_executor` no longer configures the "
"``max_workers`` of the thread pool executor it creates, instead leaving it "
"up to the thread pool executor "
"(:class:`~concurrent.futures.ThreadPoolExecutor`) to set the default."
msgstr ""
":meth:`BaseEventLoop.run_in_executor` ã¯ã€ä½œæˆã™ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«å®Ÿè¡Œè€…ã® ``max_workers`` "
"ã‚’ä½œæˆã—ãªããªã‚Šã€ä»£ã‚ã‚Šã«ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«å®Ÿè¡Œè€… (:class:`~concurrent.futures.ThreadPoolExecutor`) "
"ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’è¨­å®šã•ã›ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/asyncio-eventloop.rst:909
msgid "Set the default executor used by :meth:`run_in_executor`."
msgstr ":meth:`run_in_executor` ã§ä½¿ç”¨ã•ã‚Œã‚‹å®Ÿè¡Œè€…ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:913
msgid "Error Handling API"
msgstr "ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° API"

#: ../../library/asyncio-eventloop.rst:915
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—å†…ã§ã®ä¾‹å¤–ã®æ‰±ã„æ–¹ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:919
msgid "Set *handler* as the new event loop exception handler."
msgstr "*handler* ã‚’æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã¨ã—ã¦è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:921
msgid "If *handler* is ``None``, the default exception handler will be set."
msgstr "*handler* ãŒ ``None`` ã®å ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:924
msgid ""
"If *handler* is a callable object, it should have a matching signature to "
"``(loop, context)``, where ``loop`` will be a reference to the active event "
"loop, ``context`` will be a ``dict`` object (see "
":meth:`call_exception_handler` documentation for details about context)."
msgstr ""
"*handler* ãŒå‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€``(loop, context)`` ã«ä¸€è‡´ã™ã‚‹ã‚·ã‚°ãƒ‹ãƒãƒ£ã‚’æŒã£ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n"
"``loop`` ã¯æœ‰åŠ¹ãªã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã¸ã®å‚ç…§ã§ã€``context`` ã¯ ``dict`` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ (ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®è©³ç´°ã«ã¤ã„ã¦ã¯ :meth:`call_exception_handler` ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../library/asyncio-eventloop.rst:932
msgid ""
"Return the exception handler, or ``None`` if the default one is in use."
msgstr "ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã‚’è¿”ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚‚ã®ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:939
msgid "Default exception handler."
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:941
msgid ""
"This is called when an exception occurs and no exception handler is set, and"
" can be called by a custom exception handler that wants to defer to the "
"default behavior."
msgstr ""
"ã“ã‚Œã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸã¨ããŠã‚ˆã³ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„ã¨ãã«å‘¼ã³å‡ºã•ã‚Œã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã¯æŒ¯ã‚‹èˆã„ã®ç•°ãªã‚‹ã‚«ã‚¹ã‚¿ãƒ ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’å‘¼ã³å‡ºã™ã“ã¨ã‚‚ã§ãã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:945
msgid ""
"*context* parameter has the same meaning as in "
":meth:`call_exception_handler`."
msgstr "å¼•æ•° *context* ã®æ„å‘³ã¯ :meth:`call_exception_handler` ã¨åŒã˜ã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:950
msgid "Call the current event loop exception handler."
msgstr "ç¾åœ¨ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:952
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced later):"
msgstr "*context* ã¯ä»¥ä¸‹ã®ã‚­ãƒ¼ã‚’å«ã‚€ ``dict`` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ (æ–°ã—ã„ã‚­ãƒ¼ã¯å¾Œã§å°å…¥ã•ã‚Œã¾ã™):"

#: ../../library/asyncio-eventloop.rst:955
msgid "'message': Error message;"
msgstr "'message': ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸;"

#: ../../library/asyncio-eventloop.rst:956
msgid "'exception' (optional): Exception object;"
msgstr "'exception' (ä»»æ„): ä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ;"

#: ../../library/asyncio-eventloop.rst:957
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "'future' (ä»»æ„): :class:`asyncio.Future` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹;"

#: ../../library/asyncio-eventloop.rst:958
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "'handle' (ä»»æ„): :class:`asyncio.Handle` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹;"

#: ../../library/asyncio-eventloop.rst:959
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr "'protocol' (ä»»æ„): :ref:`ãƒ—ãƒ­ãƒˆã‚³ãƒ« <asyncio-protocol>` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹;"

#: ../../library/asyncio-eventloop.rst:960
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr "'transport' (ä»»æ„): :ref:`ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆ <asyncio-transport>` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹;"

#: ../../library/asyncio-eventloop.rst:961
msgid "'socket' (optional): :class:`socket.socket` instance."
msgstr "'socket' (ä»»æ„): :class:`socket.socket` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹;"

#: ../../library/asyncio-eventloop.rst:965
msgid ""
"Note: this method should not be overloaded in subclassed event loops.  For "
"any custom exception handling, use :meth:`set_exception_handler()` method."
msgstr ""
"æ³¨æ„: "
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—å†…ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã‚ã‚‰ã‚†ã‚‹ã‚«ã‚¹ã‚¿ãƒ ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã«ã¯ã€:meth:`set_exception_handler()`"
" ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/asyncio-eventloop.rst:970
msgid "Debug mode"
msgstr "ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰"

#: ../../library/asyncio-eventloop.rst:974
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ (:class:`bool`) ã‚’å–å¾—ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:976
msgid ""
"The default value is ``True`` if the environment variable "
":envvar:`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` "
"otherwise."
msgstr ""
"ç’°å¢ƒå¤‰æ•° :envvar:`PYTHONASYNCIODEBUG` ã«ç©ºã§ãªã„æ–‡å­—åˆ—ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ "
"``True``ã€ãã†ã§ãªã„å ´åˆã¯ ``False`` ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:984
msgid "Set the debug mode of the event loop."
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:990
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ":ref:`asyncio ã®ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ <asyncio-debug-mode>`ã€‚"

#: ../../library/asyncio-eventloop.rst:993
msgid "Server"
msgstr "ã‚µãƒ¼ãƒãƒ¼"

#: ../../library/asyncio-eventloop.rst:997
msgid "Server listening on sockets."
msgstr "ã‚½ã‚±ãƒƒãƒˆä¸Šã§å¾…æ©Ÿã—ã¦ã„ã‚‹ã‚µãƒ¼ãƒãƒ¼ã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:999
msgid ""
"Object created by :meth:`AbstractEventLoop.create_server`, "
":meth:`AbstractEventLoop.create_unix_server`, :func:`start_server`, and "
":func:`start_unix_server` functions.  Don't instantiate the class directly."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1004
msgid ""
"*Server* objects are asynchronous context managers.  When used in an ``async"
" with`` statement, it's guaranteed that the Server object is closed and not "
"accepting new connections when the ``async with`` statement is completed::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1017
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1022
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr "ã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢ã—ã¾ã™: å¾…æ©Ÿã—ã¦ã„ã‚‹ã‚½ã‚±ãƒƒãƒˆã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã— :attr:`sockets` å±æ€§ã« ``None`` ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:1025
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr "æ—¢å­˜ã®å—ä¿¡ä¸­ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã®æ¥ç¶šã‚’è¡¨ã™ã‚½ã‚±ãƒƒãƒˆã¯ã‚ªãƒ¼ãƒ—ãƒ³ã®ã¾ã¾ã§ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:1028
msgid ""
"The server is closed asynchronously, use the :meth:`wait_closed` coroutine "
"to wait until the server is closed."
msgstr "ã‚µãƒ¼ãƒãƒ¼ã¯éåŒæœŸã«åœæ­¢ã•ã‚Œã¾ã™ã€‚ã‚µãƒ¼ãƒãƒ¼ã®åœæ­¢ã‚’å¾…ã¡ãŸã„å ´åˆã¯ :meth:`wait_closed` ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:1033
msgid "Gives the event loop associated with the server object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1039
msgid "Start accepting connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1041
msgid ""
"This method is idempotent, so it can be called when the server is already "
"being serving."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1044
msgid ""
"The new *start_serving* keyword-only parameter to "
":meth:`AbstractEventLoop.create_server` and :meth:`asyncio.start_server` "
"allows to create a Server object that is not accepting connections right "
"away.  In which case this method, or :meth:`Server.serve_forever` can be "
"used to make the Server object to start accepting connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1055
msgid ""
"Start accepting connections until the coroutine is cancelled. Cancellation "
"of ``serve_forever`` task causes the server to be closed."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1059
msgid ""
"This method can be called if the server is already accepting connections.  "
"Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1063
msgid "Example::"
msgstr "ä»¥ä¸‹ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¾‹ã§ã™::"

#: ../../library/asyncio-eventloop.rst:1081
msgid "Return ``True`` if the server is accepting new connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1087
msgid "Wait until the :meth:`close` method completes."
msgstr ":meth:`close` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…ã¡ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:1091
msgid ""
"List of :class:`socket.socket` objects the server is listening to, or "
"``None`` if the server is closed."
msgstr ""
"ã‚µãƒ¼ãƒãƒ¼ãŒå¾…æ©Ÿã—ã¦ã„ã‚‹ :class:`socket.socket` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆã§ã™ã€‚ã‚µãƒ¼ãƒãƒ¼ãŒåœæ­¢ã—ã¦ã„ã‚‹ã¨ãã¯ ``None`` "
"ã«ãªã‚Šã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:1094
msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return the internal list of "
"server's sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1101
msgid "Handle"
msgstr "ãƒãƒ³ãƒ‰ãƒ«"

#: ../../library/asyncio-eventloop.rst:1105
msgid ""
"A callback wrapper object returned by :func:`AbstractEventLoop.call_soon`, "
":func:`AbstractEventLoop.call_soon_threadsafe`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1110
msgid ""
"Cancel the call.  If the callback is already canceled or executed, this "
"method has no effect."
msgstr "å‘¼ã³å‡ºã—ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã™ã€‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒæ—¢ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¦ã„ãŸã‚Šå®Ÿè¡Œã•ã‚Œã¦ã„ãŸå ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å½±éŸ¿ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/asyncio-eventloop.rst:1115
msgid "Return ``True`` if the call was cancelled."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1121
msgid ""
"A callback wrapper object returned by :func:`AbstractEventLoop.call_later`, "
"and :func:`AbstractEventLoop.call_at`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1124
msgid "The class is inherited from :class:`Handle`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1128
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1130
msgid ""
"The time is an absolute timestamp, using the same time reference as "
":meth:`AbstractEventLoop.time`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1137
msgid "SendfileNotAvailableError"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1142
msgid "Sendfile syscall is not available, subclass of :exc:`RuntimeError`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1144
msgid ""
"Raised if the OS does not support sendfile syscall for given socket or file "
"type."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1149
msgid "Event loop examples"
msgstr "ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®ä¾‹"

#: ../../library/asyncio-eventloop.rst:1154
msgid "Hello World with call_soon()"
msgstr "call_soon() ã‚’ä½¿ã£ãŸ Hello World"

#: ../../library/asyncio-eventloop.rst:1156
msgid ""
"Example using the :meth:`AbstractEventLoop.call_soon` method to schedule a "
"callback. The callback displays ``\"Hello World\"`` and then stops the event"
" loop::"
msgstr ""
":meth:`AbstractEventLoop.call_soon` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã™ã‚‹ä¾‹ã§ã™ã€‚\n"
"ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ ``\"Hello World\"`` ã‚’è¡¨ç¤ºã—ã¦ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã‚’åœæ­¢ã—ã¾ã™::"

#: ../../library/asyncio-eventloop.rst:1177
msgid ""
"The :ref:`Hello World coroutine <asyncio-hello-world-coroutine>` example "
"uses a :ref:`coroutine <coroutine>`."
msgstr ""
":ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ã‚’ä½¿ã£ãŸ Hello World <asyncio-hello-world-coroutine>` ã®ä¾‹ã§ã¯ "
":ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³ <coroutine>` ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:1184
msgid "Display the current date with call_later()"
msgstr "call_later() ã§ç¾åœ¨ã®æ—¥æ™‚ã‚’è¡¨ç¤ºã™ã‚‹"

#: ../../library/asyncio-eventloop.rst:1186
msgid ""
"Example of callback displaying the current date every second. The callback "
"uses the :meth:`AbstractEventLoop.call_later` method to reschedule itself "
"during 5 seconds, and then stops the event loop::"
msgstr ""
"ç¾åœ¨ã®æ—¥æ™‚ã‚’æ¯ç§’è¡¨ç¤ºã™ã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®ä¾‹ã§ã™ã€‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ :meth:`AbstractEventLoop.call_later` ã‚’ä½¿ç”¨ã—ã¦ 5 "
"ç§’é–“è‡ªèº«ã‚’å†ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã—ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã‚’åœæ­¢ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:1212
msgid ""
"The :ref:`coroutine displaying the current date <asyncio-date-coroutine>` "
"example uses a :ref:`coroutine <coroutine>`."
msgstr ""
":ref:`ç¾åœ¨ã®æ—¥æ™‚ã‚’è¡¨ç¤ºã™ã‚‹ã‚³ãƒ«ãƒ¼ãƒãƒ³ <asyncio-date-coroutine>` ã®ä¾‹ã¯ :ref:`ã‚³ãƒ«ãƒ¼ãƒãƒ³<coroutine>` "
"ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:1220
msgid "Watch a file descriptor for read events"
msgstr "èª­ã¿è¾¼ã¿ã‚¤ãƒ™ãƒ³ãƒˆç”¨ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã®ç›£è¦–"

#: ../../library/asyncio-eventloop.rst:1222
msgid ""
"Wait until a file descriptor received some data using the "
":meth:`AbstractEventLoop.add_reader` method and then close the event loop::"
msgstr ""
"ãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ãŒ :meth:`AbstractEventLoop.add_reader` "
"ã‚’ä½¿ç”¨ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã™ã‚‹ã¾ã§å¾…æ©Ÿã—ã€ãã®å¾Œã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã‚’é–‰ã˜ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:1256
msgid ""
"The :ref:`register an open socket to wait for data using a protocol "
"<asyncio-register-socket>` example uses a low-level protocol created by the "
":meth:`AbstractEventLoop.create_connection` method."
msgstr ""
":ref:`ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ä½¿ã£ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å¾…ã¤ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ã‚±ãƒƒãƒˆã®ç™»éŒ² <asyncio-register-socket>` ã®ä¾‹ã§ã¯ "
":meth:`AbstractEventLoop.create_connection` ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦ä½œæˆã•ã‚ŒãŸä½ãƒ¬ãƒ™ãƒ«ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:1260
msgid ""
"The :ref:`register an open socket to wait for data using streams <asyncio-"
"register-socket-streams>` example uses high-level streams created by the "
":func:`open_connection` function in a coroutine."
msgstr ""
":ref:`ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã£ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å¾…ã¤ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ã‚±ãƒƒãƒˆã®ç™»éŒ² <asyncio-register-socket-streams>` "
"ã®ä¾‹ã§ã¯ã‚³ãƒ«ãƒ¼ãƒãƒ³ã® :func:`open_connection` é–¢æ•°ã«ã‚ˆã£ã¦ä½œæˆã•ã‚ŒãŸé«˜æ°´æº–ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:1266
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "SIGINT ãŠã‚ˆã³ SIGTERM ç”¨ã®ã‚·ã‚°ãƒŠãƒ«ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®è¨­å®š"

#: ../../library/asyncio-eventloop.rst:1268
msgid ""
"Register handlers for signals :py:data:`SIGINT` and :py:data:`SIGTERM` using"
" the :meth:`AbstractEventLoop.add_signal_handler` method::"
msgstr ""
":meth:`AbstractEventLoop.add_signal_handler` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ãŸã€ã‚·ã‚°ãƒŠãƒ« "
":py:data:`SIGINT` ãŠã‚ˆã³ :py:data:`SIGTERM` ç”¨ã®ãƒãƒ³ãƒ‰ãƒ©ã‚’ç™»éŒ²ã—ã¾ã™ã€‚"

#: ../../library/asyncio-eventloop.rst:1292
msgid "This example only works on UNIX."
msgstr "ã“ã®ä¾‹ã¯ UNIX ã§ã®ã¿å‹•ãã¾ã™ã€‚"
