# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2018
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 18:48+0900\n"
"PO-Revision-Date: 2018-06-29 17:39+0000\n"
"Last-Translator: tomo, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-eventloop.rst:6
msgid "Base Event Loop"
msgstr "基底イベントループ"

#: ../../library/asyncio-eventloop.rst:8
msgid "**Source code:** :source:`Lib/asyncio/events.py`"
msgstr "**ソースコード:** :source:`Lib/asyncio/events.py`"

#: ../../library/asyncio-eventloop.rst:10
msgid ""
"The event loop is the central execution device provided by :mod:`asyncio`. "
"It provides multiple facilities, including:"
msgstr ""
"イベントループは :mod:`asyncio`  が提供する中心実行デバイスです。以下の多くの"
"機能を提供しています:"

#: ../../library/asyncio-eventloop.rst:13
msgid "Registering, executing and cancelling delayed calls (timeouts)."
msgstr "遅延呼び出しの登録、実行およびキャンセル (タイムアウト)。"

#: ../../library/asyncio-eventloop.rst:15
msgid ""
"Creating client and server :ref:`transports <asyncio-transport>` for various "
"kinds of communication."
msgstr ""
"さまざまな種類の通信のためのクライアントおよびサーバー :ref:`トランスポート "
"<asyncio-transport>` の作成。"

#: ../../library/asyncio-eventloop.rst:18
msgid ""
"Launching subprocesses and the associated :ref:`transports <asyncio-"
"transport>` for communication with an external program."
msgstr ""
"外部プログラムとの通信のためのサブプロセスおよび関連する :ref:`トランスポー"
"ト <asyncio-transport>` の起動。"

#: ../../library/asyncio-eventloop.rst:21
msgid "Delegating costly function calls to a pool of threads."
msgstr "スレッドのプールへ呼び出す、コストの大きい関数の委譲。"

#: ../../library/asyncio-eventloop.rst:25
msgid ""
"This class is an implementation detail.  It is a subclass of :class:"
"`AbstractEventLoop` and may be a base class of concrete event loop "
"implementations found in :mod:`asyncio`.  It should not be used directly; "
"use :class:`AbstractEventLoop` instead. ``BaseEventLoop`` should not be "
"subclassed by third-party code; the internal interface is not stable."
msgstr ""
"このクラスは実装詳細です。 :class:`AbstractEventLoop` のサブクラスであり、 :"
"mod:`asyncio` にあるイベントループを実装した具象クラスの基底クラスになってい"
"ることがあります。このクラスは直接使うべきではありません。 :class:"
"`AbstractEventLoop` を代わりに使用してください。サードパーティのコードで "
"``BaseEventLoop`` をサブクラス化すべきではありません。このクラスの内部のイン"
"タフェースは安定していません。"

#: ../../library/asyncio-eventloop.rst:34
msgid "Abstract base class of event loops."
msgstr "イベントループの抽象基底クラスです。"

#: ../../library/asyncio-eventloop.rst:36
msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""
"このクラスは :ref:`スレッド安全ではありません <asyncio-multithreading>`。"

#: ../../library/asyncio-eventloop.rst:39
msgid "Run an event loop"
msgstr "イベントループの実行"

#: ../../library/asyncio-eventloop.rst:43
msgid ""
"Run until :meth:`stop` is called.  If :meth:`stop` is called before :meth:"
"`run_forever()` is called, this polls the I/O selector once with a timeout "
"of zero, runs all callbacks scheduled in response to I/O events (and those "
"that were already scheduled), and then exits. If :meth:`stop` is called "
"while :meth:`run_forever` is running, this will run the current batch of "
"callbacks and then exit.  Note that callbacks scheduled by callbacks will "
"not run in that case; they will run the next time :meth:`run_forever` is "
"called."
msgstr ""
":meth:`stop` が呼ばれるまで実行します。もし :meth:`run_forever()` が呼ばれる"
"前に :meth:`stop` が呼ばれた場合、このメソッドは I/O セレクターをタイムアウト"
"時間ゼロで一度ポーリングして、そこで検出された I/O イベントに応じて実行がスケ"
"ジュールされたコールバックすべて (に加えて元々スケジュールされていたもの) を"
"実行した後、終了します。もし :meth:`run_forever` の実行中に :meth:`stop` が呼"
"ばれた場合、現在バッチ処理中のコールバックを実行した後に終了します。なお、こ"
"の場合はコールバック内でスケジュールされたコールバックは実行されません。それ"
"らは次に :meth:`run_forever` が呼ばれたときに実行されます。"

#: ../../library/asyncio-eventloop.rst:56
msgid "Run until the :class:`Future` is done."
msgstr ":class:`Future` が完了するまで実行します。"

#: ../../library/asyncio-eventloop.rst:58
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>`, it is wrapped by :"
"func:`ensure_future`."
msgstr ""
"引数が :ref:`コルーチンオブジェクト <coroutine>` の場合、:func:"
"`ensure_future` でラップされます。"

#: ../../library/asyncio-eventloop.rst:61
msgid "Return the Future's result, or raise its exception."
msgstr "Future の結果を返すか、例外を送出します。"

#: ../../library/asyncio-eventloop.rst:65
msgid "Returns running status of event loop."
msgstr "イベントループの実行状態を返します。"

#: ../../library/asyncio-eventloop.rst:69
msgid "Stop running the event loop."
msgstr "実行中のイベントループを停止します。"

#: ../../library/asyncio-eventloop.rst:71
msgid ""
"This causes :meth:`run_forever` to exit at the next suitable opportunity "
"(see there for more details)."
msgstr ""
"これにより、 :meth:`run_forever` は次の適当な時に終了します (詳細はそちらを参"
"照してください)。"

#: ../../library/asyncio-eventloop.rst:78
msgid "Returns ``True`` if the event loop was closed."
msgstr "イベントループが閉じられていた場合 ``True`` を返します。"

#: ../../library/asyncio-eventloop.rst:84
msgid ""
"Close the event loop. The loop must not be running.  Pending callbacks will "
"be lost."
msgstr ""
"イベントループを閉じます。ループは実行中ではいけません。保留中のコールバック"
"は失われます。"

#: ../../library/asyncio-eventloop.rst:87
msgid ""
"This clears the queues and shuts down the executor, but does not wait for "
"the executor to finish."
msgstr ""
"これはキューをクリアし実行者をシャットダウンしますが、実行者の終了を待ちませ"
"ん。"

#: ../../library/asyncio-eventloop.rst:90
msgid ""
"This is idempotent and irreversible. No other methods should be called after "
"this one."
msgstr ""
"これは冪等 (訳注： 何回行っても結果が同じ) であり取り消せません。この後他のメ"
"ソッドを呼び出してはなりません。"

#: ../../library/asyncio-eventloop.rst:96
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose()` call.  After calling this method, the event "
"loop will issue a warning whenever a new asynchronous generator is "
"iterated.  Should be used to finalize all scheduled asynchronous generators "
"reliably.  Example::"
msgstr ""
"現在オープンの全ての :term:`asynchronous generator` オブジェクトをスケジュー"
"ルし、:meth:`~agen.aclose()` 呼び出しによりクローズするようにします。このメ"
"ソッドの呼び出し後、イベントループは新しい非同期ジェネレータがイテレートされ"
"ると毎回警告を発します。全てのスケジュールされた非同期ジェネレータの終了処理"
"を確実に行うために使用すべきです。以下に例を示します。"

#: ../../library/asyncio-eventloop.rst:114
msgid "Calls"
msgstr "呼び出し (call)"

#: ../../library/asyncio-eventloop.rst:116
msgid ""
"Most :mod:`asyncio` functions don't accept keywords. If you want to pass "
"keywords to your callback, use :func:`functools.partial`. For example, "
"``loop.call_soon(functools.partial(print, \"Hello\", flush=True))`` will "
"call ``print(\"Hello\", flush=True)``."
msgstr ""
":mod:`asyncio` 関数の大半はキーワードを受け付けません。\n"
"コールバックに引数を渡したい場合は :func:`functools.partial` を使用してくださ"
"い。\n"
"例えば ``loop.call_soon(functools.partial(print, \"Hello\", flush=True))`` "
"は ``print(\"Hello\", flush=True)`` を呼び出します。"

#: ../../library/asyncio-eventloop.rst:122
msgid ""
":func:`functools.partial` is better than ``lambda`` functions, because :mod:"
"`asyncio` can inspect :func:`functools.partial` object to display parameters "
"in debug mode, whereas ``lambda`` functions have a poor representation."
msgstr ""
"``lambda`` 関数よりも :func:`functools.partial` を使用しましょう。\n"
":mod:`asyncio` はデバッグモードで引数を表示するよう :func:`functools."
"partial` オブジェクトを精査することが出来ますが、``lambda`` 関数の表現は貧弱"
"です。"

#: ../../library/asyncio-eventloop.rst:129
msgid ""
"Arrange for a callback to be called as soon as possible.  The callback is "
"called after :meth:`call_soon` returns, when control returns to the event "
"loop."
msgstr ""
"コールバックをすぐに呼び出せるように準備します。\n"
"コールバックは :meth:`call_soon` が返ると呼び出され、制御はイベントループに返"
"されます。"

#: ../../library/asyncio-eventloop.rst:133
msgid ""
"This operates as a :abbr:`FIFO (first-in, first-out)` queue, callbacks are "
"called in the order in which they are registered.  Each callback will be "
"called exactly once."
msgstr ""
"これは :abbr:`FIFO (first-in, first-out)` キューのように処理され、コールバッ"
"クは登録された順に呼び出されます。各コールバックは厳密に 1 回だけ呼び出されま"
"す。"

#: ../../library/asyncio-eventloop.rst:137
msgid ""
"Any positional arguments after the callback will be passed to the callback "
"when it is called."
msgstr ""
"*callback* の後の位置引数 *args* は、コールバックが呼び出されたときに渡されま"
"す。"

#: ../../library/asyncio-eventloop.rst:140
#: ../../library/asyncio-eventloop.rst:174
#: ../../library/asyncio-eventloop.rst:196
msgid ""
"An instance of :class:`asyncio.Handle` is returned, which can be used to "
"cancel the callback."
msgstr ""
":class:`asyncio.Handle` のインスタンスを返します。それを使用してコールバック"
"をキャンセルすることが出来ます。"

#: ../../library/asyncio-eventloop.rst:143
#: ../../library/asyncio-eventloop.rst:185
#: ../../library/asyncio-eventloop.rst:199
#: ../../library/asyncio-eventloop.rst:539
#: ../../library/asyncio-eventloop.rst:551
#: ../../library/asyncio-eventloop.rst:705
msgid ""
":ref:`Use functools.partial to pass keywords to the callback <asyncio-pass-"
"keywords>`."
msgstr ""
":ref:`コールバックに引数を渡すには functools.partial を使用してください "
"<asyncio-pass-keywords>`。"

#: ../../library/asyncio-eventloop.rst:148
msgid "Like :meth:`call_soon`, but thread safe."
msgstr ":meth:`call_soon` に似ていますが、スレッドセーフです。"

#: ../../library/asyncio-eventloop.rst:150
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"このドキュメントの :ref:`asyncio-multithreading` 節を参照してください。"

#: ../../library/asyncio-eventloop.rst:157
msgid "Delayed calls"
msgstr "遅延呼び出し"

#: ../../library/asyncio-eventloop.rst:159
msgid ""
"The event loop has its own internal clock for computing timeouts. Which "
"clock is used depends on the (platform-specific) event loop implementation; "
"ideally it is a monotonic clock.  This will generally be a different clock "
"than :func:`time.time`."
msgstr ""
"イベントループはタイムアウトを計測するために自身に内部時計を持っています。内"
"部時計は (プラットフォーム固有の) イベントループの実装に依存したものが使用さ"
"れます。理想的には、これは単調時計 (訳注: 巻き戻ることのない時計) です。これ"
"は通常 :func:`time.time` とは異なる時計です。"

#: ../../library/asyncio-eventloop.rst:166
msgid ""
"Timeouts (relative *delay* or absolute *when*) should not exceed one day."
msgstr ""
"タイムアウト (相対値 *delay* または絶対値 *when*) は 1 日を超えてはいけませ"
"ん。"

#: ../../library/asyncio-eventloop.rst:171
msgid ""
"Arrange for the *callback* to be called after the given *delay* seconds "
"(either an int or float)."
msgstr ""
"引数 *delay* 秒後に *callback* を呼び出す準備をします。*delay* は int または "
"float です。"

#: ../../library/asyncio-eventloop.rst:177
msgid ""
"*callback* will be called exactly once per call to :meth:`call_later`. If "
"two callbacks are scheduled for exactly the same time, it is undefined which "
"will be called first."
msgstr ""
"*callback* は :meth:`call_later` を呼び出すたびに厳密に 1 度だけ呼び出されま"
"す。2 個のコールバックが完全に同じ時間にスケジュールされている場合、どちらが"
"先に実行されるかは保証されません。"

#: ../../library/asyncio-eventloop.rst:181
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with some named arguments, use "
"a closure or :func:`functools.partial`."
msgstr ""
"コールバックが呼び出されたときに任意の位置引数 *args* が渡されます。名前付き"
"引数をコールバックに渡したい場合、クロージャか :func:`functools.partial` を使"
"用してください。"

#: ../../library/asyncio-eventloop.rst:190
msgid ""
"Arrange for the *callback* to be called at the given absolute timestamp "
"*when* (an int or float), using the same time reference as :meth:"
"`AbstractEventLoop.time`."
msgstr ""
"絶対タイムスタンプ *when* (int または float) になったときに呼び出される "
"*callback* を準備します。\n"
"時刻は :meth:`AbstractEventLoop.time` を参照します。"

#: ../../library/asyncio-eventloop.rst:194
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "このメソッドの振る舞いは :meth:`call_later` と同じです。"

#: ../../library/asyncio-eventloop.rst:204
msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal clock."
msgstr ""
"現在の時刻を :class:`float` 値で返します。時刻はイベントループの内部時計に従"
"います。"

#: ../../library/asyncio-eventloop.rst:209
msgid "The :func:`asyncio.sleep` function."
msgstr "関数 :func:`asyncio.sleep`。"

#: ../../library/asyncio-eventloop.rst:213
msgid "Futures"
msgstr "Future"

#: ../../library/asyncio-eventloop.rst:217
msgid "Create an :class:`asyncio.Future` object attached to the loop."
msgstr "ループに付属した :class:`asyncio.Future` オブジェクトを作成します。"

#: ../../library/asyncio-eventloop.rst:219
msgid ""
"This is a preferred way to create futures in asyncio, as event loop "
"implementations can provide alternative implementations of the Future class "
"(with better performance or instrumentation)."
msgstr ""
"asyncio で Futures を作成するために推奨される方法です。イベントループを実装す"
"ることにより、Futures クラスの(パフォーマンスや計測方法が優れた) 代替実装 が"
"提供される場合があるためです。"

#: ../../library/asyncio-eventloop.rst:227
msgid "Tasks"
msgstr "タスク"

#: ../../library/asyncio-eventloop.rst:231
msgid ""
"Schedule the execution of a :ref:`coroutine object <coroutine>`: wrap it in "
"a future. Return a :class:`Task` object."
msgstr ""
":ref:`コルーチンオブジェクト <coroutine>` の実行をスケジュールします: このと"
"きフューチャにラップします。:class:`Task` オブジェクトを返します。"

#: ../../library/asyncio-eventloop.rst:234
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of :class:"
"`Task`."
msgstr ""
"サードパーティのイベントループは相互運用のための自身の :class:`Task` のサブク"
"ラスを使用できます。この場合、結果は :class:`Task` のサブクラスになります。"

#: ../../library/asyncio-eventloop.rst:238
msgid ""
"This method was added in Python 3.4.2. Use the :func:`async` function to "
"support also older Python versions."
msgstr ""
"このメソッドは Python 3.4.2 で追加されました。Python の過去のバージョンもサ"
"ポートするには :func:`async` 関数を使用してください。"

#: ../../library/asyncio-eventloop.rst:245
msgid ""
"Set a task factory that will be used by :meth:`AbstractEventLoop."
"create_task`."
msgstr ""
":meth:`AbstractEventLoop.create_task` が使用するタスクファクトリーを設定しま"
"す。"

#: ../../library/asyncio-eventloop.rst:248
msgid "If *factory* is ``None`` the default task factory will be set."
msgstr ""
"*factory* が ``None`` の場合デフォルトのタスクファクトリーが設定されます。"

#: ../../library/asyncio-eventloop.rst:250
msgid ""
"If *factory* is a *callable*, it should have a signature matching ``(loop, "
"coro)``, where *loop* will be a reference to the active event loop, *coro* "
"will be a coroutine object.  The callable must return an :class:`asyncio."
"Future` compatible object."
msgstr ""
"*factory* が *呼び出し可能オブジェクト* の場合、 ``(loop, coro)`` に一致する"
"シグニチャを持っていなければなりません。\n"
"*loop* は有効なイベントループへの参照で、 *coro* はコルーチンオブジェクトで"
"す。\n"
"呼び出し可能オブジェクトは :class:`asyncio.Future` 互換のオブジェクトを返さな"
"ければなりません。"

#: ../../library/asyncio-eventloop.rst:259
msgid "Return a task factory, or ``None`` if the default one is in use."
msgstr ""
"タスクファクトリーを返します。デフォルトのものが使用された場合は ``None`` を"
"返します。"

#: ../../library/asyncio-eventloop.rst:265
msgid "Creating connections"
msgstr "コネクションの作成"

#: ../../library/asyncio-eventloop.rst:269
msgid ""
"Create a streaming transport connection to a given Internet *host* and "
"*port*: socket family :py:data:`~socket.AF_INET` or :py:data:`~socket."
"AF_INET6` depending on *host* (or *family* if specified), socket type :py:"
"data:`~socket.SOCK_STREAM`.  *protocol_factory* must be a callable returning "
"a :ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"インターネット *host* および *port* へのストリーミング転送コネクションを作成"
"します: ソケットファミリ :py:data:`~socket.AF_INET` または :py:data:`~socket."
"AF_INET6` は *host* (または指定されていれば *family*) に依存し、ソケットタイ"
"プは :py:data:`~socket.SOCK_STREAM` になります。*protocol_factory* は :ref:`"
"プロトコル <asyncio-protocol>` のインスタンスを返す呼び出し可能オブジェクトで"
"なければなりません。"

#: ../../library/asyncio-eventloop.rst:275
#: ../../library/asyncio-eventloop.rst:366
#: ../../library/asyncio-eventloop.rst:420
msgid ""
"This method is a :ref:`coroutine <coroutine>` which will try to establish "
"the connection in the background.  When successful, the coroutine returns a "
"``(transport, protocol)`` pair."
msgstr ""
"このメソッドはバックグラウンドでコネクションの確立を試みる :ref:`コルーチン "
"<coroutine>` です。成功すると、コルーチンは ``(トランスポート, プロトコル)`` "
"のペアを返します。"

#: ../../library/asyncio-eventloop.rst:279
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "時系列での下層処理の概要は以下のとおりです:"

#: ../../library/asyncio-eventloop.rst:281
msgid ""
"The connection is established, and a :ref:`transport <asyncio-transport>` is "
"created to represent it."
msgstr ""
"コネクションを確立し、それを表す :ref:`トランスポート <asyncio-transport>` が"
"作成される。"

#: ../../library/asyncio-eventloop.rst:284
msgid ""
"*protocol_factory* is called without arguments and must return a :ref:"
"`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* が引数なしで呼び出され、:ref:`プロトコル <asyncio-"
"protocol>` のインスタンスを返す。"

#: ../../library/asyncio-eventloop.rst:287
msgid ""
"The protocol instance is tied to the transport, and its :meth:"
"`connection_made` method is called."
msgstr ""
"プロトコルインスタンスはトランスポートと紐付けられ、それの :meth:"
"`connection_made` メソッドが呼び出される。"

#: ../../library/asyncio-eventloop.rst:290
msgid ""
"The coroutine returns successfully with the ``(transport, protocol)`` pair."
msgstr "コルーチンは ``(トランスポート, プロトコル)`` のペアを返す。"

#: ../../library/asyncio-eventloop.rst:293
msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr "作成されたトランスポートは実装依存の双方向ストリームです。"

#: ../../library/asyncio-eventloop.rst:296
msgid ""
"*protocol_factory* can be any kind of callable, not necessarily a class.  "
"For example, if you want to use a pre-created protocol instance, you can "
"pass ``lambda: my_protocol``."
msgstr ""
"*protocol_factory* はクラスである必要はなく、あらゆる種類の呼び出し可能オブ"
"ジェクトを使用可能です。例えば、あらかじめ作成しておいたプロコルインスタンス"
"を使用したい場合、``lambda: my_protocol`` を渡します。"

#: ../../library/asyncio-eventloop.rst:300
msgid "Options that change how the connection is created:"
msgstr "コネクションの作成方法を変更するオプションは以下の通りです:"

#: ../../library/asyncio-eventloop.rst:302
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is :const:"
"`True`, a context with some unspecified default settings is used."
msgstr ""
"*ssl*: 偽値以外が与えられた場合、SSL/TLS トランスポートが作成されます (デフォ"
"ルトではプレーン TCP トランスポートが作成されます)。*ssl* が :class:`ssl."
"SSLContext` オブジェクトの場合、このコンテキストはトランスポートを作成するた"
"めに使用されます; *ssl* が :const:`True` の場合、いくつかの未定義のデフォルト"
"値が使用されます。"

#: ../../library/asyncio-eventloop.rst:308
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`SSL/TLS セキュリティについての考察 <ssl-security>`"

#: ../../library/asyncio-eventloop.rst:310
msgid ""
"*server_hostname*, is only for use together with *ssl*, and sets or "
"overrides the hostname that the target server's certificate will be matched "
"against.  By default the value of the *host* argument is used.  If *host* is "
"empty, there is no default and you must pass a value for *server_hostname*.  "
"If *server_hostname* is an empty string, hostname matching is disabled "
"(which is a serious security risk, allowing for man-in-the-middle-attacks)."
msgstr ""
"*server_hostname* は *ssl* 指定時のみ使用し、対象サーバーの証明書に一致するホ"
"スト名を設定またはオーバーライドします。デフォルトでは引数 *host* の値が使用"
"されます。*host* が空の場合デフォルト値はなく、*server_hostname* に値を渡さな"
"ければなりません。*server_hostname* が空の場合、ホスト名のマッチングは無効に"
"なります (深刻なセキュリティリスクになり、中間者攻撃に対する脆弱性になりま"
"す)。"

#: ../../library/asyncio-eventloop.rst:318
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given, "
"these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*, *proto*, *flags* は任意のアドレスファミリであり、*host* 解決のため"
"の getaddrinfo() 経由で渡されるプロトコルおよびフラグになります。このオプショ"
"ンが与えられた場合、これらはすべて :mod:`socket` モジュール定数に従った整数で"
"なければなりません。"

#: ../../library/asyncio-eventloop.rst:323
msgid ""
"*sock*, if given, should be an existing, already connected :class:`socket."
"socket` object to be used by the transport. If *sock* is given, none of "
"*host*, *port*, *family*, *proto*, *flags* and *local_addr* should be "
"specified."
msgstr ""
"*sock* を与える場合、トランスポートに使用される、既存の、すでに接続済の :"
"class:`socket.socket` オブジェクトを指定します。*sock* を指定する場合、"
"*host*、*port*、*family*、*proto*、*flags* および *local_addr* を指定してはな"
"りません。"

#: ../../library/asyncio-eventloop.rst:328
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket to locally.  The *local_host* and *local_port* are looked up "
"using getaddrinfo(), similarly to *host* and *port*."
msgstr ""
"*local_addr* を与える場合、ソケットをローカルに束縛するために使用する "
"``(local_host, local_port)`` のタプルを指定します。*local_host* および "
"*local_port* は *host* および *port* と同様に getaddrinfo() を使用してルック"
"アップされます。"

#: ../../library/asyncio-eventloop.rst:334
#: ../../library/asyncio-eventloop.rst:484
msgid "On Windows with :class:`ProactorEventLoop`, SSL/TLS is now supported."
msgstr ""
"Windows の :class:`ProactorEventLoop` で SSL/TLS がサポートされました。"

#: ../../library/asyncio-eventloop.rst:338
msgid ""
"The :func:`open_connection` function can be used to get a pair of (:class:"
"`StreamReader`, :class:`StreamWriter`) instead of a protocol."
msgstr ""
"関数 :func:`open_connection` はプロトコルではなく (:class:`StreamReader`, :"
"class:`StreamWriter`) のペアの取得に使用できます。"

#: ../../library/asyncio-eventloop.rst:345
msgid ""
"The parameter *reuse_address* is no longer supported, as using :py:data:"
"`~sockets.SO_REUSEADDR` poses a significant security concern for UDP. "
"Explicitly passing ``reuse_address=True`` will raise an exception."
msgstr ""
":py:data:`~sockets.SO_REUSEADDR` の利用が UDP に対して重大なセキュリティ上の"
"懸念をもたらすため、 *reuse_address* パラメータはサポートされなくなりました。"
"明示的に ``reuse_address=True`` を設定すると例外を送出します。"

#: ../../library/asyncio-eventloop.rst:349
msgid ""
"When multiple processes with differing UIDs assign sockets to an indentical "
"UDP socket address with ``SO_REUSEADDR``, incoming packets can become "
"randomly distributed among the sockets."
msgstr ""

#: ../../library/asyncio-eventloop.rst:353
msgid ""
"For supported platforms, *reuse_port* can be used as a replacement for "
"similar functionality. With *reuse_port*, :py:data:`~sockets.SO_REUSEPORT` "
"is used instead, which specifically prevents processes with differing UIDs "
"from assigning sockets to the same socket address."
msgstr ""
"サポートされているプラットフォームでは、 *reuse_port* が同様の機能に対する代"
"用品として利用できます。 *reuse_port* は代替機能として :py:data:`~sockets."
"SO_REUSEPORT` を使っており、複数のプロセスが異なる UID で同一のソケットに対し"
"て割り当てられるのを明確に禁止します。"

#: ../../library/asyncio-eventloop.rst:359
msgid "Create a datagram connection."
msgstr "データグラム接続 (UDP) を生成します。"

#: ../../library/asyncio-eventloop.rst:361
msgid ""
"Create datagram connection: socket family :py:data:`~socket.AF_INET` or :py:"
"data:`~socket.AF_INET6` depending on *host* (or *family* if specified), "
"socket type :py:data:`~socket.SOCK_DGRAM`. *protocol_factory* must be a "
"callable returning a :ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"データグラム接続を作成します: ソケットファミリー :py:data:`~socket.AF_INET` "
"または :py:data:`~socket.AF_INET6` は *host* (または指定されていれば "
"*family*) に依存し、ソケットタイプは :py:data:`~socket.SOCK_DGRAM` です。\n"
"*protocol_factory* は :ref:`プロトコル <asyncio-protocol>` のインスタンスを返"
"す呼び出し可能オブジェクトでなければなりません。"

#: ../../library/asyncio-eventloop.rst:370
msgid "Options changing how the connection is created:"
msgstr "コネクションの作成方法を変更するオプションは以下の通りです:"

#: ../../library/asyncio-eventloop.rst:372
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket to locally.  The *local_host* and *local_port* are looked up "
"using :meth:`getaddrinfo`."
msgstr ""
"*local_addr* が指定される場合、``(local_host, local_port)`` のタプルで、ソ"
"ケットをローカルで束縛するために使用されます。*local_host* と *local_port* "
"は :meth:`getaddrinfo` を使用して検索されます。"

#: ../../library/asyncio-eventloop.rst:376
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port* "
"are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr* が指定される場合、``(remote_host, remote_por)`` のタプルで、ソ"
"ケットをリモートアドレスに束縛するために使用されます。*remote_host* と "
"*remote_port* は :meth:`getaddrinfo` を使用して検索されます。"

#: ../../library/asyncio-eventloop.rst:380
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* は任意のアドレスファミリです。これらのファミリ、プ"
"ロトコル、フラグは、*host* 解決のため :meth:`getaddrinfo` 経由でオプションで"
"渡されます。これらのオプションを指定する場合、すべて :mod:`socket` モジュール"
"定数に従った整数でなければなりません。"

#: ../../library/asyncio-eventloop.rst:385
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows and some "
"UNIX's. If the :py:data:`~socket.SO_REUSEPORT` constant is not defined then "
"this capability is unsupported."
msgstr ""
"*reuse_port* は、同じポートにバインドされた既存の端点すべてがこのフラグを設定"
"して生成されている場合に限り、この端点を既存の端点と同じポートにバインドする"
"ことをカーネルに許可します（訳註: ソケットのオプション SO_REUSEPORT を使用し"
"ます）。このオプションは、Windows やいくつかの UNIX システムではサポートされ"
"ません。もし定数 :py:data:`~socket.SO_REUSEPORT` が定義されていなければ、この"
"機能はサポートされません。"

#: ../../library/asyncio-eventloop.rst:391
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr ""
"*allow_broadcast* は、カーネルに、このエンドポイントがブロードキャストアドレ"
"スにメッセージを送信することを許可するように指示します。"

#: ../../library/asyncio-eventloop.rst:394
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be :const:"
"`None`)."
msgstr ""
"オプションの *sock* を指定することで、既存の、すでに接続されている :class:"
"`socket.socket` をトランスポートで使用することができます。このオプションを使"
"用する場合、*local_addr* と *remote_addr* は省略してください (:const:`None` "
"でなければなりません)。"

#: ../../library/asyncio-eventloop.rst:399
msgid ""
"On Windows with :class:`ProactorEventLoop`, this method is not supported."
msgstr ""
"Windows の :class:`ProactorEventLoop` では、このメソッドはサポートされていま"
"せん。"

#: ../../library/asyncio-eventloop.rst:401
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and :"
"ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""
":ref:`UDP echo クライアントプロトコル <asyncio-udp-echo-client-protocol>` お"
"よび :ref:`UDP echo サーバープロトコル <asyncio-udp-echo-server-protocol>` の"
"例を参照してください。"

#: ../../library/asyncio-eventloop.rst:404
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""
"*family*, *proto*, *flags*, *reuse_address*, *reuse_port, *allow_broadcast*, "
"*sock* パラメータが追加されました。"

#: ../../library/asyncio-eventloop.rst:408
msgid ""
"The *reuse_address* parameter is no longer supporter due to security concerns"
msgstr ""

#: ../../library/asyncio-eventloop.rst:415
msgid ""
"Create UNIX connection: socket family :py:data:`~socket.AF_UNIX`, socket "
"type :py:data:`~socket.SOCK_STREAM`. The :py:data:`~socket.AF_UNIX` socket "
"family is used to communicate between processes on the same machine "
"efficiently."
msgstr ""
"UNIX コネクションを作成します: ソケットファミリは :py:data:`~socket."
"AF_UNIX`、ソケットタイプは :py:data:`~socket.SOCK_STREAM` になります。:py:"
"data:`~socket.AF_UNIX` ソケットファミリは同一マシン上のプロセス間で効率的に通"
"信するために使用されます。"

#: ../../library/asyncio-eventloop.rst:424
msgid ""
"*path* is the name of a UNIX domain socket, and is required unless a *sock* "
"parameter is specified.  Abstract UNIX sockets, :class:`str`, and :class:"
"`bytes` paths are supported."
msgstr ""
"*path* は UNIX ドメインソケットの名前で、 *sock* パラメータが指定されない限り"
"指定する必要があります。抽象化された UNIX ソケット、 :class:`str` 、そして :"
"class:`bytes` のパスを指定できます。"

#: ../../library/asyncio-eventloop.rst:428
msgid ""
"See the :meth:`AbstractEventLoop.create_connection` method for parameters."
msgstr ""
"引数については :meth:`AbstractEventLoop.create_connection` メソッドを参照して"
"ください。"

#: ../../library/asyncio-eventloop.rst:430
#: ../../library/asyncio-eventloop.rst:503
msgid "Availability: UNIX."
msgstr "利用できる環境: UNIX。"

#: ../../library/asyncio-eventloop.rst:434
msgid "Creating listening connections"
msgstr "待ち受けコネクションの作成"

#: ../../library/asyncio-eventloop.rst:438
msgid ""
"Create a TCP server (socket type :data:`~socket.SOCK_STREAM`) bound to "
"*host* and *port*."
msgstr ""
"*host* および *port* に束縛された TCP サーバー (ソケットタイプ :data:"
"`~socket.SOCK_STREAM`) を作成します。"

#: ../../library/asyncio-eventloop.rst:441
msgid ""
"Return a :class:`Server` object, its :attr:`~Server.sockets` attribute "
"contains created sockets. Use the :meth:`Server.close` method to stop the "
"server: close listening sockets."
msgstr ""
":class:`Server` オブジェクトを返します。これの :attr:`~Server.sockets` 属性に"
"は作成されたソケットが含まれています。サーバーを停止するには :meth:`Server."
"close` メソッドを使用します: 待受中のソケットを閉じます。"

#: ../../library/asyncio-eventloop.rst:445
#: ../../library/asyncio-eventloop.rst:512
msgid "Parameters:"
msgstr "引数:"

#: ../../library/asyncio-eventloop.rst:447
msgid ""
"The *host* parameter can be a string, in that case the TCP server is bound "
"to *host* and *port*. The *host* parameter can also be a sequence of strings "
"and in that case the TCP server is bound to all hosts of the sequence. If "
"*host* is an empty string or ``None``, all interfaces are assumed and a list "
"of multiple sockets will be returned (most likely one for IPv4 and another "
"one for IPv6)."
msgstr ""
"*host* 引数には文字列を渡すことが出来ます。\n"
"その場合、TCP サーバは *host* と *port* に束縛されます。\n"
"*host* 引数には文字列のシーケンスを渡すことも出来ます。\n"
"その場合 TCP サーバはシーケンスの全ホストに束縛されます。\n"
"*host* が空の文字列や ``None`` の場合、全インターフェイスが想定され、複数のソ"
"ケットからなるリストを返します (最も近いのは IPv4 や IPv6 のものです)。"

#: ../../library/asyncio-eventloop.rst:454
msgid ""
"*family* can be set to either :data:`socket.AF_INET` or :data:`~socket."
"AF_INET6` to force the socket to use IPv4 or IPv6. If not set it will be "
"determined from host (defaults to :data:`socket.AF_UNSPEC`)."
msgstr ""
"*family* には :data:`socket.AF_INET` または :data:`~socket.AF_INET6` を指定"
"し、ソケットで IPv4 を使用するか IPv6 を使用するか強制的に設定できます。設定"
"されない場合ホストから決定されます (:data:`socket.AF_UNSPEC` がデフォルトにな"
"ります)。"

#: ../../library/asyncio-eventloop.rst:458
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* は :meth:`getaddrinfo` のためのビットマスクになります。"

#: ../../library/asyncio-eventloop.rst:460
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* should be omitted (must be :const:"
"`None`)."
msgstr ""
"任意の引数 *sock* には、既存のソケットオブジェクトの使用順を指定できます。指"
"定した場合、*host* および *port* を指定してはなりません (:const:`None` でなけ"
"ればなりません)。"

#: ../../library/asyncio-eventloop.rst:464
msgid ""
"*backlog* is the maximum number of queued connections passed to :meth:"
"`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* は :meth:`~socket.socket.listen` に渡される、キューに入るコネクショ"
"ンの最大数になります (デフォルトは 100)。"

#: ../../library/asyncio-eventloop.rst:467
#: ../../library/asyncio-eventloop.rst:517
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr ""
"*ssl* には :class:`~ssl.SSLContext` を指定できます。指定すると、受け付けたコ"
"ネクション上での SSL を有効にします。"

#: ../../library/asyncio-eventloop.rst:470
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in TIME_WAIT state, "
"without waiting for its natural timeout to expire. If not specified will "
"automatically be set to ``True`` on UNIX."
msgstr ""
"*reuse_address* は、 TIME_WAIT 状態にあるローカルソケットを、その状態が自然に"
"タイムアウトするのを待つことなく再利用するようカーネルに指示します（訳註: ソ"
"ケットのオプション SO_REUSEADDR を使用します）。指定しない場合、UNIX では自動"
"的に ``True`` が設定されます。"

#: ../../library/asyncio-eventloop.rst:475
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows."
msgstr ""
"*reuse_port* は、同じポートにバインドされた既存の端点すべてがこのフラグを設定"
"して生成されている場合に限り、この端点を既存の端点と同じポートにバインドする"
"ことを許可するよう、カーネルに指示します（訳註: ソケットのオプション "
"SO_REUSEPORT を使用します）。このオプションは、Windows ではサポートされていま"
"せん。"

#: ../../library/asyncio-eventloop.rst:480
#: ../../library/asyncio-eventloop.rst:501
#: ../../library/asyncio-eventloop.rst:578
#: ../../library/asyncio-eventloop.rst:594
#: ../../library/asyncio-eventloop.rst:604
#: ../../library/asyncio-eventloop.rst:632
#: ../../library/asyncio-eventloop.rst:671
#: ../../library/asyncio-eventloop.rst:685
#: ../../library/asyncio-eventloop.rst:736
#: ../../library/asyncio-eventloop.rst:855
msgid "This method is a :ref:`coroutine <coroutine>`."
msgstr "このメソッドは :ref:`コルーチン <coroutine>` です。"

#: ../../library/asyncio-eventloop.rst:488
msgid ""
"The function :func:`start_server` creates a (:class:`StreamReader`, :class:"
"`StreamWriter`) pair and calls back a function with this pair."
msgstr ""
"関数 :func:`start_server` は (:class:`StreamReader`, :class:`StreamWriter`) "
"のペアを作成し、このペアで関数を再度呼び出します。"

#: ../../library/asyncio-eventloop.rst:493
msgid "The *host* parameter can now be a sequence of strings."
msgstr "*host* 引数に文字列のシーケンスを与えられるようになりました。"

#: ../../library/asyncio-eventloop.rst:498
msgid ""
"Similar to :meth:`AbstractEventLoop.create_server`, but specific to the "
"socket family :py:data:`~socket.AF_UNIX`."
msgstr ""
":meth:`AbstractEventLoop.create_server` と似ていますが、ソケットファミリー :"
"py:data:`~socket.AF_UNIX` 固有です。"

#: ../../library/asyncio-eventloop.rst:507
msgid "Handle an accepted connection."
msgstr "受け付けられた接続を扱います。"

#: ../../library/asyncio-eventloop.rst:509
msgid ""
"This is used by servers that accept connections outside of asyncio but that "
"use asyncio to handle them."
msgstr ""
"asyncio の範囲外で接続を受け付けるが、asyncio を使用してそれらを扱うサーバに"
"より使用されます。"

#: ../../library/asyncio-eventloop.rst:514
msgid "*sock* is a preexisting socket object returned from an ``accept`` call."
msgstr "*sock* は、 ``accept`` 呼び出しが返す既存のソケットオブジェクトです。"

#: ../../library/asyncio-eventloop.rst:520
msgid ""
"This method is a :ref:`coroutine <coroutine>`.  When completed, the "
"coroutine returns a ``(transport, protocol)`` pair."
msgstr ""
"このメソッドは :ref:`coroutine <coroutine>` です。完了すると、このコルーチン"
"は ``(transport, protocol)`` のペアを返します。"

#: ../../library/asyncio-eventloop.rst:527
msgid "Watch file descriptors"
msgstr "ファイル記述子の監視"

#: ../../library/asyncio-eventloop.rst:529
msgid ""
"On Windows with :class:`SelectorEventLoop`, only socket handles are "
"supported (ex: pipe file descriptors are not supported)."
msgstr ""
"Windows の :class:`SelectorEventLoop` では、ソケットの扱いのみサポートされて"
"います (例えばパイプのファイル記述子はサポートされません)。"

#: ../../library/asyncio-eventloop.rst:532
msgid ""
"On Windows with :class:`ProactorEventLoop`, these methods are not supported."
msgstr ""
"Wndows の :class:`ProactorEventLoop` では、これらのメソッドはサポートされませ"
"ん。"

#: ../../library/asyncio-eventloop.rst:536
msgid ""
"Start watching the file descriptor for read availability and then call the "
"*callback* with specified arguments."
msgstr ""
"読み込み可能なファイル記述子の監視を開始し、指定された引数で *callback* を呼"
"び出します。"

#: ../../library/asyncio-eventloop.rst:544
msgid "Stop watching the file descriptor for read availability."
msgstr "読み込み可能なファイル記述子の監視を停止します。"

#: ../../library/asyncio-eventloop.rst:548
msgid ""
"Start watching the file descriptor for write availability and then call the "
"*callback* with specified arguments."
msgstr ""
"書き込み可能なファイル記述子の監視を開始し、指定された引数で *callback* を呼"
"び出します。"

#: ../../library/asyncio-eventloop.rst:556
msgid "Stop watching the file descriptor for write availability."
msgstr "書き込み可能なファイル記述子の監視を停止します。"

#: ../../library/asyncio-eventloop.rst:558
msgid ""
"The :ref:`watch a file descriptor for read events <asyncio-watch-read-"
"event>` example uses the low-level :meth:`AbstractEventLoop.add_reader` "
"method to register the file descriptor of a socket."
msgstr ""
":ref:`読み込みイベント用のファイル記述子の監視 <asyncio-watch-read-event>` の"
"例では、ソケットのファイル記述子を登録するのに低水準の :meth:"
"`AbstractEventLoop.add_reader` メソッドを使用しています。"

#: ../../library/asyncio-eventloop.rst:564
msgid "Low-level socket operations"
msgstr "低水準のソケット操作"

#: ../../library/asyncio-eventloop.rst:568
msgid ""
"Receive data from the socket.  Modeled after blocking :meth:`socket.socket."
"recv` method."
msgstr ""
"ソケットからデータを受け取ります。\n"
":meth:`socket.socket.recv` メソッドのブロックをモデルにしています。"

#: ../../library/asyncio-eventloop.rst:571
msgid ""
"The return value is a bytes object representing the data received.  The "
"maximum amount of data to be received at once is specified by *nbytes*."
msgstr ""
"受け取ったデータを表す bytes オブジェクトを返します。\n"
"一度に受け取るデータの最大量を *nbytes* で指定します。"

#: ../../library/asyncio-eventloop.rst:575
#: ../../library/asyncio-eventloop.rst:591
#: ../../library/asyncio-eventloop.rst:601
msgid ""
"With :class:`SelectorEventLoop` event loop, the socket *sock* must be non-"
"blocking."
msgstr ""
":class:`SelectorEventLoop` イベントループの場合、ソケット *sock* は非ブロック"
"でなければなりません。"

#: ../../library/asyncio-eventloop.rst:582
msgid ""
"Send data to the socket.  Modeled after blocking :meth:`socket.socket."
"sendall` method."
msgstr ""
"ソケットにデータを送ります。\n"
":meth:`socket.socket.sendall` メソッドのブロックをモデルにいています。"

#: ../../library/asyncio-eventloop.rst:585
msgid ""
"The socket must be connected to a remote socket. This method continues to "
"send data from *data* until either all data has been sent or an error "
"occurs.  ``None`` is returned on success.  On error, an exception is raised, "
"and there is no way to determine how much data, if any, was successfully "
"processed by the receiving end of the connection."
msgstr ""
"ソケットはリモートソケットに接続されていなければなりません。\n"
"このメソッドは全データを送信するかエラーが発生するまで、 *data* からのデータ"
"を送信し続けます。\n"
"正常終了すると ``None`` を返します。\n"
"エラー発生時は例外を送出しますが、正常に処理されたデータ量を確認する手段はあ"
"りません。\n"
"たとえあったとしても、接続の終了を受信するまではできません。"

#: ../../library/asyncio-eventloop.rst:598
msgid ""
"Connect to a remote socket at *address*.  Modeled after blocking :meth:"
"`socket.socket.connect` method."
msgstr ""
"*address* のソケットに接続します。\n"
":meth:`socket.socket.connect` メソッドのブロックをモデルにしています。"

#: ../../library/asyncio-eventloop.rst:606
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling :func:`socket."
"inet_pton`.  If not, :meth:`AbstractEventLoop.getaddrinfo` will be used to "
"resolve the *address*."
msgstr ""
"``address`` を解決する必要はなくなりました。\n"
"``sock_connect`` は :func:`socket.inet_pton` の呼び出しで *address* が既に解"
"決されているかチェックしようとします。\n"
"解決されていない場合 :meth:`AbstractEventLoop.getaddrinfo` を使用して "
"*address* を解決します。"

#: ../../library/asyncio-eventloop.rst:615
msgid ""
":meth:`AbstractEventLoop.create_connection` and  :func:`asyncio."
"open_connection() <open_connection>`."
msgstr ""
":meth:`AbstractEventLoop.create_connection` および :func:`asyncio."
"open_connection() <open_connection>`。"

#: ../../library/asyncio-eventloop.rst:621
msgid ""
"Accept a connection.  Modeled after blocking :meth:`socket.socket.accept`."
msgstr ""
"接続を受け付けます。 :meth:`socket.socket.accept` のブロック をモデルにしてい"
"ます。"

#: ../../library/asyncio-eventloop.rst:624
msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""
"ソケットはアドレスに束縛済みで、接続を listen 中である必要があります。戻り値"
"は ``(conn, address)`` のペアで、*conn* は接続を通じてデータの送受信を行うた"
"めの *新しい* ソケットオブジェクト、*address* は接続先の端点でソケットに束縛"
"されているアドレスを示します。"

#: ../../library/asyncio-eventloop.rst:630
msgid "The socket *sock* must be non-blocking."
msgstr "ソケット *sock* は非ブロックでなければなりません。"

#: ../../library/asyncio-eventloop.rst:636
msgid ":meth:`AbstractEventLoop.create_server` and :func:`start_server`."
msgstr ":meth:`AbstractEventLoop.create_server` および :func:`start_server`。"

#: ../../library/asyncio-eventloop.rst:640
msgid "Resolve host name"
msgstr "ホスト名の解決"

#: ../../library/asyncio-eventloop.rst:644
msgid ""
"This method is a :ref:`coroutine <coroutine>`, similar to :meth:`socket."
"getaddrinfo` function but non-blocking."
msgstr ""
"このメソッドは :ref:`コルーチン <coroutine>` で、:meth:`socket.getaddrinfo` "
"関数に似ていますが、ブロックされません。"

#: ../../library/asyncio-eventloop.rst:649
msgid ""
"This method is a :ref:`coroutine <coroutine>`, similar to :meth:`socket."
"getnameinfo` function but non-blocking."
msgstr ""
"このメソッドは :ref:`コルーチン <coroutine>` で、:meth:`socket.getnameinfo` "
"関数に似ていますが、ブロックされません。"

#: ../../library/asyncio-eventloop.rst:654
msgid "Connect pipes"
msgstr "パイプの接続"

#: ../../library/asyncio-eventloop.rst:656
msgid ""
"On Windows with :class:`SelectorEventLoop`, these methods are not supported. "
"Use :class:`ProactorEventLoop` to support pipes on Windows."
msgstr ""
"Windows の :class:`SelectorEventLoop` では、これらメソッドはサポートされてい"
"ません。Windows でパイプをサポートするには、:class:`ProactorEventLoop` を使用"
"してください。"

#: ../../library/asyncio-eventloop.rst:661
msgid "Register read pipe in eventloop."
msgstr "イベントループ内で読み込みパイプを登録します。"

#: ../../library/asyncio-eventloop.rst:663
msgid ""
"*protocol_factory* should instantiate object with :class:`Protocol` "
"interface.  *pipe* is a :term:`file-like object <file object>`. Return pair "
"``(transport, protocol)``, where *transport* supports the :class:"
"`ReadTransport` interface."
msgstr ""
"*protocol_factory* は :class:`Protocol` インターフェースを持つオブジェクトの"
"インスタンスを作成しなければなりません。 *pipe* は :term:`ファイルライクオブ"
"ジェクト <file object>` です。 ``(トランスポート, プロトコル)`` のペアを返"
"し、 *トランスポート* は :class:`ReadTransport` インターフェースをサポートし"
"ます。"

#: ../../library/asyncio-eventloop.rst:668
#: ../../library/asyncio-eventloop.rst:682
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ""
":class:`SelectorEventLoop` イベントループの場合、*pipe* は非ブロックモードに"
"設定されていなければなりません。"

#: ../../library/asyncio-eventloop.rst:675
msgid "Register write pipe in eventloop."
msgstr "イベントループ内の書き込みパイプを登録します。"

#: ../../library/asyncio-eventloop.rst:677
msgid ""
"*protocol_factory* should instantiate object with :class:`BaseProtocol` "
"interface. *pipe* is :term:`file-like object <file object>`. Return pair "
"``(transport, protocol)``, where *transport* supports :class:"
"`WriteTransport` interface."
msgstr ""
"*protocol_factory* は :class:`BaseProtocol` で作成されたインスタンスオブジェ"
"クトでなければなりません。*pipe* は :term:`ファイルライクオブジェクト <file "
"object>` です。``(transport, protocol)`` のペアを返します。*transport* は :"
"class:`WriteTransport` インターフェースをサポートしています。"

#: ../../library/asyncio-eventloop.rst:689
msgid ""
"The :meth:`AbstractEventLoop.subprocess_exec` and :meth:`AbstractEventLoop."
"subprocess_shell` methods."
msgstr ""
":meth:`AbstractEventLoop.subprocess_exec` メソッドおよび :meth:"
"`AbstractEventLoop.subprocess_shell` メソッド。"

#: ../../library/asyncio-eventloop.rst:694
msgid "UNIX signals"
msgstr "UNIX シグナル"

#: ../../library/asyncio-eventloop.rst:696
msgid "Availability: UNIX only."
msgstr "利用できる環境: UNIX のみ。"

#: ../../library/asyncio-eventloop.rst:700
msgid "Add a handler for a signal."
msgstr "シグナル用のハンドラーを追加します。"

#: ../../library/asyncio-eventloop.rst:702
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"シグナルナンバーが誤っているか捕捉不可能な場合 :exc:`ValueError` が送出されま"
"す。ハンドラーの設定に問題があった場合 :exc:`RuntimeError` が送出されます。"

#: ../../library/asyncio-eventloop.rst:710
msgid "Remove a handler for a signal."
msgstr "シグナル用のハンドラーを削除します。"

#: ../../library/asyncio-eventloop.rst:712
msgid "Return ``True`` if a signal handler was removed, ``False`` if not."
msgstr ""
"シグナルハンドラーが削除されると ``True`` が、されなければ ``False`` を返しま"
"す。"

#: ../../library/asyncio-eventloop.rst:716
msgid "The :mod:`signal` module."
msgstr ":mod:`signal` モジュール。"

#: ../../library/asyncio-eventloop.rst:720
msgid "Executor"
msgstr "実行者"

#: ../../library/asyncio-eventloop.rst:722
msgid ""
"Call a function in an :class:`~concurrent.futures.Executor` (pool of threads "
"or pool of processes). By default, an event loop uses a thread pool executor "
"(:class:`~concurrent.futures.ThreadPoolExecutor`)."
msgstr ""
":class:`~concurrent.futures.Executor` (スレッドプールまたはプロセスプール) 内"
"の関数を呼び出します。デフォルトでは、一つのイベントループは一つのスレッド"
"プール実行者 (:class:`~concurrent.futures.ThreadPoolExecutor`) を使用します。"

#: ../../library/asyncio-eventloop.rst:728
msgid "Arrange for a *func* to be called in the specified executor."
msgstr "特定の実行者で *func* を呼び出す準備をします。"

#: ../../library/asyncio-eventloop.rst:730
msgid ""
"The *executor* argument should be an :class:`~concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``."
msgstr ""
"引数 *executor* は :class:`~concurrent.futures.Executor` のインスタンスでなけ"
"ればなりません。*executor* が ``None`` のときデフォルトの実行者が使用されま"
"す。"

#: ../../library/asyncio-eventloop.rst:733
msgid ""
":ref:`Use functools.partial to pass keywords to the *func* <asyncio-pass-"
"keywords>`."
msgstr ""
":ref:`*func* にキーワードを渡すには、functools.partial を使用します <asyncio-"
"pass-keywords>`。"

#: ../../library/asyncio-eventloop.rst:738
msgid ""
":meth:`BaseEventLoop.run_in_executor` no longer configures the "
"``max_workers`` of the thread pool executor it creates, instead leaving it "
"up to the thread pool executor (:class:`~concurrent.futures."
"ThreadPoolExecutor`) to set the default."
msgstr ""
":meth:`BaseEventLoop.run_in_executor` は、作成するスレッドプール実行者の "
"``max_workers`` を作成しなくなり、代わりにスレッドプール実行者 (:class:"
"`~concurrent.futures.ThreadPoolExecutor`) にデフォルトを設定させるようになり"
"ました。"

#: ../../library/asyncio-eventloop.rst:747
msgid "Set the default executor used by :meth:`run_in_executor`."
msgstr ":meth:`run_in_executor` で使用される実行者を設定します。"

#: ../../library/asyncio-eventloop.rst:751
msgid "Error Handling API"
msgstr "エラーハンドリング API"

#: ../../library/asyncio-eventloop.rst:753
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr "イベントループ内での例外の扱い方をカスタマイズできます。"

#: ../../library/asyncio-eventloop.rst:757
msgid "Set *handler* as the new event loop exception handler."
msgstr "*handler* を新しいイベントループ例外ハンドラーとして設定します。"

#: ../../library/asyncio-eventloop.rst:759
msgid "If *handler* is ``None``, the default exception handler will be set."
msgstr ""
"*handler* が ``None`` の場合、デフォルトの例外ハンドラーが設定されます。"

#: ../../library/asyncio-eventloop.rst:762
msgid ""
"If *handler* is a callable object, it should have a matching signature to "
"``(loop, context)``, where ``loop`` will be a reference to the active event "
"loop, ``context`` will be a ``dict`` object (see :meth:"
"`call_exception_handler` documentation for details about context)."
msgstr ""
"*handler* が呼び出し可能オブジェクトの場合、``(loop, context)`` に一致するシ"
"グニチャを持っていなければなりません。\n"
"``loop`` は有効なイベントループへの参照で、``context`` は ``dict`` オブジェク"
"トです (コンテキストの詳細については :meth:`call_exception_handler` ドキュメ"
"ントを参照してください)。"

#: ../../library/asyncio-eventloop.rst:770
msgid "Return the exception handler, or ``None`` if the default one is in use."
msgstr ""
"例外ハンドラを返します。デフォルトのものが使用されている場合は ``None`` を返"
"します。"

#: ../../library/asyncio-eventloop.rst:777
msgid "Default exception handler."
msgstr "デフォルトの例外ハンドラーです。"

#: ../../library/asyncio-eventloop.rst:779
msgid ""
"This is called when an exception occurs and no exception handler is set, and "
"can be called by a custom exception handler that wants to defer to the "
"default behavior."
msgstr ""
"これは例外が発生したときおよび例外ハンドラーが設定されていないときに呼び出さ"
"れ、デフォルトとは振る舞いの異なるカスタム例外ハンドラーを呼び出すこともでき"
"ます。"

#: ../../library/asyncio-eventloop.rst:783
msgid ""
"*context* parameter has the same meaning as in :meth:"
"`call_exception_handler`."
msgstr "引数 *context* の意味は :meth:`call_exception_handler` と同じです。"

#: ../../library/asyncio-eventloop.rst:788
msgid "Call the current event loop exception handler."
msgstr "現在のイベントループ例外ハンドラーを呼び出します。"

#: ../../library/asyncio-eventloop.rst:790
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced later):"
msgstr ""
"*context* は以下のキーを含む ``dict`` オブジェクトです (新しいキーは後で導入"
"されます):"

#: ../../library/asyncio-eventloop.rst:793
msgid "'message': Error message;"
msgstr "'message': エラーメッセージ;"

#: ../../library/asyncio-eventloop.rst:794
msgid "'exception' (optional): Exception object;"
msgstr "'exception' (任意): 例外オブジェクト;"

#: ../../library/asyncio-eventloop.rst:795
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "'future' (任意): :class:`asyncio.Future` インスタンス;"

#: ../../library/asyncio-eventloop.rst:796
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "'handle' (任意): :class:`asyncio.Handle` インスタンス;"

#: ../../library/asyncio-eventloop.rst:797
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr "'protocol' (任意): :ref:`プロトコル <asyncio-protocol>` インスタンス;"

#: ../../library/asyncio-eventloop.rst:798
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr ""
"'transport' (任意): :ref:`トランスポート <asyncio-transport>` インスタンス;"

#: ../../library/asyncio-eventloop.rst:799
msgid "'socket' (optional): :class:`socket.socket` instance."
msgstr "'socket' (任意): :class:`socket.socket` インスタンス;"

#: ../../library/asyncio-eventloop.rst:803
msgid ""
"Note: this method should not be overloaded in subclassed event loops.  For "
"any custom exception handling, use :meth:`set_exception_handler()` method."
msgstr ""
"注意: このメソッドはサブクラス化されたイベントループ内でオーバーロードされて"
"はなりません。あらゆるカスタム例外ハンドリングには、:meth:"
"`set_exception_handler()` メソッドを使用してください。"

#: ../../library/asyncio-eventloop.rst:808
msgid "Debug mode"
msgstr "デバッグモード"

#: ../../library/asyncio-eventloop.rst:812
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "イベントループのデバッグモード (:class:`bool`) を取得します。"

#: ../../library/asyncio-eventloop.rst:814
msgid ""
"The default value is ``True`` if the environment variable :envvar:"
"`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` otherwise."
msgstr ""
"環境変数 :envvar:`PYTHONASYNCIODEBUG` に空でない文字列が設定されている場合の"
"デフォルト値は ``True``、そうでない場合は ``False`` になります。"

#: ../../library/asyncio-eventloop.rst:822
msgid "Set the debug mode of the event loop."
msgstr "イベントループのデバッグモードを設定します。"

#: ../../library/asyncio-eventloop.rst:828
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ":ref:`asyncio のデバッグモード <asyncio-debug-mode>`。"

#: ../../library/asyncio-eventloop.rst:831
msgid "Server"
msgstr "サーバー"

#: ../../library/asyncio-eventloop.rst:835
msgid "Server listening on sockets."
msgstr "ソケット上で待機しているサーバーです。"

#: ../../library/asyncio-eventloop.rst:837
msgid ""
"Object created by the :meth:`AbstractEventLoop.create_server` method and "
"the :func:`start_server` function. Don't instantiate the class directly."
msgstr ""
":meth:`AbstractEventLoop.create_server` メソッドおよび :func:`start_server` "
"関数によって作成されたオブジェクトです。クラスから直接インスタンスを作成しな"
"いでください。"

#: ../../library/asyncio-eventloop.rst:842
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr ""
"サーバーを停止します: 待機しているソケットをクローズし :attr:`sockets` 属性"
"に ``None`` を設定します。"

#: ../../library/asyncio-eventloop.rst:845
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr "既存の受信中のクライアントとの接続を表すソケットはオープンのままです。"

#: ../../library/asyncio-eventloop.rst:848
msgid ""
"The server is closed asynchronously, use the :meth:`wait_closed` coroutine "
"to wait until the server is closed."
msgstr ""
"サーバーは非同期に停止されます。サーバーの停止を待ちたい場合は :meth:"
"`wait_closed` コルーチンを使用します。"

#: ../../library/asyncio-eventloop.rst:853
msgid "Wait until the :meth:`close` method completes."
msgstr ":meth:`close` メソッドが完了するまで待ちます。"

#: ../../library/asyncio-eventloop.rst:859
msgid ""
"List of :class:`socket.socket` objects the server is listening to, or "
"``None`` if the server is closed."
msgstr ""
"サーバーが待機している :class:`socket.socket` オブジェクトのリストです。サー"
"バーが停止しているときは ``None`` になります。"

#: ../../library/asyncio-eventloop.rst:864
msgid "Handle"
msgstr "ハンドル"

#: ../../library/asyncio-eventloop.rst:868
msgid ""
"A callback wrapper object returned by :func:`AbstractEventLoop.call_soon`, :"
"func:`AbstractEventLoop.call_soon_threadsafe`, :func:`AbstractEventLoop."
"call_later`, and :func:`AbstractEventLoop.call_at`."
msgstr ""
":func:`AbstractEventLoop.call_soon`, :func:`AbstractEventLoop."
"call_soon_threadsafe`, :func:`AbstractEventLoop.call_later`, および :func:"
"`AbstractEventLoop.call_at` が返すコールバックラッパです。"

#: ../../library/asyncio-eventloop.rst:874
msgid ""
"Cancel the call.  If the callback is already canceled or executed, this "
"method has no effect."
msgstr ""
"呼び出しをキャンセルします。コールバックが既にキャンセルされていたり実行され"
"ていた場合、このメソッドの影響はありません。"

#: ../../library/asyncio-eventloop.rst:879
msgid "Event loop examples"
msgstr "イベントループの例"

#: ../../library/asyncio-eventloop.rst:884
msgid "Hello World with call_soon()"
msgstr "call_soon() を使った Hello World"

#: ../../library/asyncio-eventloop.rst:886
msgid ""
"Example using the :meth:`AbstractEventLoop.call_soon` method to schedule a "
"callback. The callback displays ``\"Hello World\"`` and then stops the event "
"loop::"
msgstr ""
":meth:`AbstractEventLoop.call_soon` メソッドを使用してコールバックをスケ"
"ジュールする例です。\n"
"コールバックは ``\"Hello World\"`` を表示してイベントループを停止します::"

#: ../../library/asyncio-eventloop.rst:907
msgid ""
"The :ref:`Hello World coroutine <asyncio-hello-world-coroutine>` example "
"uses a :ref:`coroutine <coroutine>`."
msgstr ""
":ref:`コルーチンを使った Hello World <asyncio-hello-world-coroutine>` の例で"
"は :ref:`コルーチン <coroutine>` を使用しています。"

#: ../../library/asyncio-eventloop.rst:914
msgid "Display the current date with call_later()"
msgstr "call_later() で現在の日時を表示する"

#: ../../library/asyncio-eventloop.rst:916
msgid ""
"Example of callback displaying the current date every second. The callback "
"uses the :meth:`AbstractEventLoop.call_later` method to reschedule itself "
"during 5 seconds, and then stops the event loop::"
msgstr ""
"現在の日時を毎秒表示するコールバックの例です。コールバックは :meth:"
"`AbstractEventLoop.call_later` を使用して 5 秒間自身を再スケジュールし、イベ"
"ントループを停止します。"

#: ../../library/asyncio-eventloop.rst:942
msgid ""
"The :ref:`coroutine displaying the current date <asyncio-date-coroutine>` "
"example uses a :ref:`coroutine <coroutine>`."
msgstr ""
":ref:`現在の日時を表示するコルーチン <asyncio-date-coroutine>` の例は :ref:`"
"コルーチン<coroutine>` を使用しています。"

#: ../../library/asyncio-eventloop.rst:950
msgid "Watch a file descriptor for read events"
msgstr "読み込みイベント用ファイル記述子の監視"

#: ../../library/asyncio-eventloop.rst:952
msgid ""
"Wait until a file descriptor received some data using the :meth:"
"`AbstractEventLoop.add_reader` method and then close the event loop::"
msgstr ""
"ファイル記述子が :meth:`AbstractEventLoop.add_reader` を使用してデータを受信"
"するまで待機し、その後イベントループを閉じます。"

#: ../../library/asyncio-eventloop.rst:989
msgid ""
"The :ref:`register an open socket to wait for data using a protocol <asyncio-"
"register-socket>` example uses a low-level protocol created by the :meth:"
"`AbstractEventLoop.create_connection` method."
msgstr ""
":ref:`プロトコルを使ってデータを待つオープンソケットの登録 <asyncio-register-"
"socket>` の例では :meth:`AbstractEventLoop.create_connection` メソッドによっ"
"て作成された低レベルプロトコルを使用しています。"

#: ../../library/asyncio-eventloop.rst:993
msgid ""
"The :ref:`register an open socket to wait for data using streams <asyncio-"
"register-socket-streams>` example uses high-level streams created by the :"
"func:`open_connection` function in a coroutine."
msgstr ""
":ref:`ストリームを使ってデータを待つオープンソケットの登録 <asyncio-register-"
"socket-streams>` の例ではコルーチンの :func:`open_connection` 関数によって作"
"成された高水準ストリームを使用しています。"

#: ../../library/asyncio-eventloop.rst:999
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "SIGINT および SIGTERM 用のシグナルハンドラーの設定"

#: ../../library/asyncio-eventloop.rst:1001
msgid ""
"Register handlers for signals :py:data:`SIGINT` and :py:data:`SIGTERM` using "
"the :meth:`AbstractEventLoop.add_signal_handler` method::"
msgstr ""
":meth:`AbstractEventLoop.add_signal_handler` メソッドを使用した、シグナル :"
"py:data:`SIGINT` および :py:data:`SIGTERM` 用のハンドラを登録します。"

#: ../../library/asyncio-eventloop.rst:1025
msgid "This example only works on UNIX."
msgstr "この例は UNIX でのみ動きます。"
