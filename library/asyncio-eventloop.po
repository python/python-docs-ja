# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-30 14:59+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2022\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-eventloop.rst:8
msgid "Event Loop"
msgstr "イベントループ"

#: ../../library/asyncio-eventloop.rst:10
msgid ""
"**Source code:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"
msgstr ""
"**ソースコード:** :source:`Lib/asyncio/profile.py` と :source:`Lib/asyncio/"
"pstats.py`"

#: ../../library/asyncio-eventloop.rst:16
msgid "Preface"
msgstr "まえがき"

#: ../../library/asyncio-eventloop.rst:17
msgid ""
"The event loop is the core of every asyncio application. Event loops run "
"asynchronous tasks and callbacks, perform network IO operations, and run "
"subprocesses."
msgstr ""
"イベントループは全ての asyncio アプリケーションの中核をなす存在です。イベント"
"ループは非同期タスクやコールバックを実行し、ネットワーク I/O を処理し、サブプ"
"ロセスを実行します。"

#: ../../library/asyncio-eventloop.rst:21
msgid ""
"Application developers should typically use the high-level asyncio "
"functions, such as :func:`asyncio.run`, and should rarely need to reference "
"the loop object or call its methods.  This section is intended mostly for "
"authors of lower-level code, libraries, and frameworks, who need finer "
"control over the event loop behavior."
msgstr ""
"アプリケーション開発者は通常 :func:`asyncio.run` のような高水準の ayncio 関数"
"だけを利用し、ループオブジェクトを参照したり、ループオブジェクトのメソッドを"
"呼び出したりすることはほとんどありません。この節は、イベントループの振る舞い"
"に対して細かい調整が必要な、低水準のコード、ライブラリ、フレームワークの開発"
"者向けです。"

#: ../../library/asyncio-eventloop.rst:28
msgid "Obtaining the Event Loop"
msgstr "イベントループの取得"

#: ../../library/asyncio-eventloop.rst:29
msgid ""
"The following low-level functions can be used to get, set, or create an "
"event loop:"
msgstr "以下の低水準関数はイベントループの取得、設定、生成するために使います:"

#: ../../library/asyncio-eventloop.rst:34
msgid "Return the running event loop in the current OS thread."
msgstr "現在の OS スレッドで実行中のイベントループを取得します。"

#: ../../library/asyncio-eventloop.rst:36
msgid "Raise a :exc:`RuntimeError` if there is no running event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:38
msgid "This function can only be called from a coroutine or a callback."
msgstr ""

#: ../../library/asyncio-eventloop.rst:44
msgid "Get the current event loop."
msgstr "現在のイベントループを取得します。"

#: ../../library/asyncio-eventloop.rst:46
msgid ""
"When called from a coroutine or a callback (e.g. scheduled with call_soon or "
"similar API), this function will always return the running event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:50
msgid ""
"If there is no running event loop set, the function will return the result "
"of ``get_event_loop_policy().get_event_loop()`` call."
msgstr ""

#: ../../library/asyncio-eventloop.rst:53
msgid ""
"Because this function has rather complex behavior (especially when custom "
"event loop policies are in use), using the :func:`get_running_loop` function "
"is preferred to :func:`get_event_loop` in coroutines and callbacks."
msgstr ""
"この関数の振る舞いは (特にイベントループポリシーをカスタマイズした場合) 複雑"
"なため、コルーチンやコールバックでは :func:`get_event_loop`  よりも :func:"
"`get_running_loop` を使うほうが好ましいと考えられます。"

#: ../../library/asyncio-eventloop.rst:58
msgid ""
"As noted above, consider using the higher-level :func:`asyncio.run` "
"function, instead of using these lower level functions to manually create "
"and close an event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:62
msgid ""
"Deprecation warning is emitted if there is no current event loop. In Python "
"3.12 it will be an error."
msgstr ""

#: ../../library/asyncio-eventloop.rst:67
msgid ""
"In Python versions 3.10.0--3.10.8 this function (and other functions which "
"used it implicitly) emitted a :exc:`DeprecationWarning` if there was no "
"running event loop, even if the current loop was set."
msgstr ""

#: ../../library/asyncio-eventloop.rst:74
msgid "Set *loop* as the current event loop for the current OS thread."
msgstr ""

#: ../../library/asyncio-eventloop.rst:78
msgid "Create and return a new event loop object."
msgstr "新しいイベントループオブジェクトを生成して返します。"

#: ../../library/asyncio-eventloop.rst:80
msgid ""
"Note that the behaviour of :func:`get_event_loop`, :func:`set_event_loop`, "
"and :func:`new_event_loop` functions can be altered by :ref:`setting a "
"custom event loop policy <asyncio-policies>`."
msgstr ""
":func:`get_event_loop`, :func:`set_event_loop`, および :func:"
"`new_event_loop` 関数の振る舞いは、 :ref:`カスタムイベントループポリシーを設"
"定する <asyncio-policies>` ことにより変更することができます。"

#: ../../library/asyncio-eventloop.rst:86
msgid "Contents"
msgstr "内容"

#: ../../library/asyncio-eventloop.rst:87
msgid "This documentation page contains the following sections:"
msgstr "このページは以下の節から構成されます:"

#: ../../library/asyncio-eventloop.rst:89
msgid ""
"The `Event Loop Methods`_ section is the reference documentation of the "
"event loop APIs;"
msgstr ""
"`イベントループのメソッド`_ 節は、イベントループ API のリファレンスです。"

#: ../../library/asyncio-eventloop.rst:92
msgid ""
"The `Callback Handles`_ section documents the :class:`Handle` and :class:"
"`TimerHandle` instances which are returned from scheduling methods such as :"
"meth:`loop.call_soon` and :meth:`loop.call_later`;"
msgstr ""
"`コールバックハンドル`_ 節は :meth:`loop.call_soon` や :meth:`loop."
"call_later` などのスケジューリングメソッドが返す :class:`Handle` や :class:"
"`TimerHandle` インスタンスについて解説しています。 "

#: ../../library/asyncio-eventloop.rst:96
msgid ""
"The `Server Objects`_ section documents types returned from event loop "
"methods like :meth:`loop.create_server`;"
msgstr ""
"`サーバーオブジェクト`_ 節は :meth:`loop.create_server` のようなメソッドが返"
"す型について解説しています。"

#: ../../library/asyncio-eventloop.rst:99
msgid ""
"The `Event Loop Implementations`_ section documents the :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop` classes;"
msgstr ""
"`イベントループの実装`_ 節は :class:`SelectorEventLoop` と :class:"
"`ProactorEventLoop` の2つのクラスについて解説しています。"

#: ../../library/asyncio-eventloop.rst:102
msgid ""
"The `Examples`_ section showcases how to work with some event loop APIs."
msgstr "`使用例`_ 節ではイベントループ API の具体的な使い方を紹介しています。"

#: ../../library/asyncio-eventloop.rst:109
msgid "Event Loop Methods"
msgstr "イベントループのメソッド"

#: ../../library/asyncio-eventloop.rst:111
msgid "Event loops have **low-level** APIs for the following:"
msgstr "イベントループは以下の **低水準な** API を持っています:"

#: ../../library/asyncio-eventloop.rst:119
msgid "Running and stopping the loop"
msgstr "ループの開始と停止"

#: ../../library/asyncio-eventloop.rst:123
msgid "Run until the *future* (an instance of :class:`Future`) has completed."
msgstr ""
"*フューチャー* (:class:`Future` インスタンス) が完了するまで実行します。"

#: ../../library/asyncio-eventloop.rst:126
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>` it is implicitly "
"scheduled to run as a :class:`asyncio.Task`."
msgstr ""
"引数が :ref:`コルーチンオブジェクト <coroutine>` の場合、暗黙のうちに :class:"
"`asyncio.Task` として実行されるようにスケジュールされます。"

#: ../../library/asyncio-eventloop.rst:129
msgid "Return the Future's result or raise its exception."
msgstr "Future の結果を返すか、例外を送出します。"

#: ../../library/asyncio-eventloop.rst:133
msgid "Run the event loop until :meth:`stop` is called."
msgstr ":meth:`stop` が呼び出されるまでイベントループを実行します。"

#: ../../library/asyncio-eventloop.rst:135
msgid ""
"If :meth:`stop` is called before :meth:`run_forever()` is called, the loop "
"will poll the I/O selector once with a timeout of zero, run all callbacks "
"scheduled in response to I/O events (and those that were already scheduled), "
"and then exit."
msgstr ""
":meth:`run_forever()` メソッドが呼ばれるより前に :meth:`stop` メソッドが呼ば"
"れた場合、イベントループはタイムアウトをゼロにして一度だけ I/O セレクタの問い"
"合わせ処理を行い、 I/O イベントに対してスケジュールされた全てのコールバック "
"(および既にスケジュール済みのコールバック) を実行したのち、終了します。"

#: ../../library/asyncio-eventloop.rst:140
msgid ""
"If :meth:`stop` is called while :meth:`run_forever` is running, the loop "
"will run the current batch of callbacks and then exit. Note that new "
"callbacks scheduled by callbacks will not run in this case; instead, they "
"will run the next time :meth:`run_forever` or :meth:`run_until_complete` is "
"called."
msgstr ""
":meth:`run_forever` メソッドを実行中に :meth:`stop` メソッドが呼び出された場"
"合、イベントループは現在処理されているすべてのコールバックを実行してから終了"
"します。 この場合、コールバックにより新たにスケジュールされるコールバックは実"
"行されないことに注意してください; これら新たにスケジュールされたコールバック"
"は、次に :meth:`run_forever` または :meth:`run_until_complete` が呼び出された"
"ときに実行されます。"

#: ../../library/asyncio-eventloop.rst:148
msgid "Stop the event loop."
msgstr "イベントループを停止します。"

#: ../../library/asyncio-eventloop.rst:152
msgid "Return ``True`` if the event loop is currently running."
msgstr "イベントループが現在実行中の場合 ``True`` を返します。"

#: ../../library/asyncio-eventloop.rst:156
msgid "Return ``True`` if the event loop was closed."
msgstr "イベントループが閉じられていた場合 ``True`` を返します。"

#: ../../library/asyncio-eventloop.rst:160
msgid "Close the event loop."
msgstr "イベントループをクローズします。"

#: ../../library/asyncio-eventloop.rst:162
msgid ""
"The loop must not be running when this function is called. Any pending "
"callbacks will be discarded."
msgstr ""
"この関数が呼び出される時点で、イベントループが実行中であってはいけません。保"
"留中のコールバックはすべて破棄されます。"

#: ../../library/asyncio-eventloop.rst:165
msgid ""
"This method clears all queues and shuts down the executor, but does not wait "
"for the executor to finish."
msgstr ""
"このメソッドは全てのキューをクリアし、エグゼキューターが実行完了するのを待た"
"ずにシャットダウンします。"

#: ../../library/asyncio-eventloop.rst:168
msgid ""
"This method is idempotent and irreversible.  No other methods should be "
"called after the event loop is closed."
msgstr ""
"このメソッドはべき等 (何回実行しても結果は同じ) であり取り消せません。イベン"
"トループがクローズされた後、他のいかなるメソッドも呼び出すべきではありませ"
"ん。"

#: ../../library/asyncio-eventloop.rst:173
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose()` call.  After calling this method, the event "
"loop will issue a warning if a new asynchronous generator is iterated. This "
"should be used to reliably finalize all scheduled asynchronous generators."
msgstr ""
"現在オープンになっているすべての :term:`asynchronous generator` (非同期ジェネ"
"レータ) オブジェクトをスケジュールし、 :meth:`~agen.aclose()` メソッドを呼び"
"出すことでそれらをクローズします。 このメソッドの呼び出し後に新しい非同期ジェ"
"ネレータがイテレートされると、イベントループは警告を発します。このメソッドは"
"スケジュールされたすべての非同期ジェネレータの終了処理を確実に行うために使用"
"すべきです。"

#: ../../library/asyncio-eventloop.rst:179
#: ../../library/asyncio-eventloop.rst:199
msgid ""
"Note that there is no need to call this function when :func:`asyncio.run` is "
"used."
msgstr ":func:`asyncio.run` を使った場合はこの関数を呼び出す必要はありません。"

#: ../../library/asyncio-eventloop.rst:182
#: ../../library/asyncio-eventloop.rst:1120
#: ../../library/asyncio-eventloop.rst:1512
msgid "Example::"
msgstr "以下はプログラム例です::"

#: ../../library/asyncio-eventloop.rst:194
msgid ""
"Schedule the closure of the default executor and wait for it to join all of "
"the threads in the :class:`ThreadPoolExecutor`. After calling this method, "
"a :exc:`RuntimeError` will be raised if :meth:`loop.run_in_executor` is "
"called while using the default executor."
msgstr ""
"デフォルトエグゼキューターのクローズをスケジュールし、 :class:"
"`ThreadPoolExecutor` 内の全てのスレッドの処理が完了するまで待機 (join同期処"
"理) します。 この関数呼び出し後、デフォルトエグゼキューターを使っている状態"
"で :meth:`loop.run_in_executor`  メソッドが呼び出されると、 :exc:"
"`RuntimeError` 例外を送出します。"

#: ../../library/asyncio-eventloop.rst:206
msgid "Scheduling callbacks"
msgstr "コールバックのスケジューリング"

#: ../../library/asyncio-eventloop.rst:210
msgid ""
"Schedule the *callback* :term:`callback` to be called with *args* arguments "
"at the next iteration of the event loop."
msgstr ""
"イベントループの次のイテレーションで *callback* に指定したコールバック (:"
"term:`callback`) を *args* 引数で呼び出すようにスケジュールします。"

#: ../../library/asyncio-eventloop.rst:213
msgid ""
"Callbacks are called in the order in which they are registered. Each "
"callback will be called exactly once."
msgstr ""
"コールバックは登録された順に呼び出されます。各コールバックは厳密に1回だけ呼び"
"出されます。"

#: ../../library/asyncio-eventloop.rst:216
#: ../../library/asyncio-eventloop.rst:283
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"オプションのキーワード引数 *context* を使って、コールバック*callback* を実行"
"する際のコンテキスト :class:`contextvars.Context` を設定することができます。"
"コンテキスト *context* が指定されない場合は現在のコンテキストが使われます。"

#: ../../library/asyncio-eventloop.rst:220
msgid ""
"An instance of :class:`asyncio.Handle` is returned, which can be used later "
"to cancel the callback."
msgstr ""
":class:`asyncio.Handle` のインスタンスを返します。このインスタンスを使ってス"
"ケジュールしたコールバックをキャンセルすることができます。"

#: ../../library/asyncio-eventloop.rst:223
msgid "This method is not thread-safe."
msgstr "このメソッドはスレッドセーフではありません。"

#: ../../library/asyncio-eventloop.rst:227
msgid ""
"A thread-safe variant of :meth:`call_soon`.  Must be used to schedule "
"callbacks *from another thread*."
msgstr ""
":meth:`call_soon` のスレッドセーフ版です。必ず *別のスレッドから* コールバッ"
"クをスケジュールする際に使ってください。"

#: ../../library/asyncio-eventloop.rst:230
msgid ""
"Raises :exc:`RuntimeError` if called on a loop that's been closed. This can "
"happen on a secondary thread when the main application is shutting down."
msgstr ""
"すでにクローズされたイベントループに対してこのメソッドが呼び出された場合 :"
"exc:`RuntimeError` 例外を送出します。これはメインアプリケーションが終了してい"
"るにもかかわらずセカンダリスレッドでメソッドが呼び出されるといった場合に起こ"
"りえます。"

#: ../../library/asyncio-eventloop.rst:234
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"このドキュメントの :ref:`asyncio-multithreading` 節を参照してください。"

#: ../../library/asyncio-eventloop.rst:237
#: ../../library/asyncio-eventloop.rst:287
#: ../../library/asyncio-eventloop.rst:307
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"キーワード引数 *context* が追加されました。詳細は :pep:`567` を参照してくださ"
"い。"

#: ../../library/asyncio-eventloop.rst:245
msgid ""
"Most :mod:`asyncio` scheduling functions don't allow passing keyword "
"arguments.  To do that, use :func:`functools.partial`::"
msgstr ""
"ほとんどの :mod:`asyncio` モジュールのスケジューリング関数は、キーワード引数"
"をコールバックに渡すことを許していません。キーワード引数を渡すためには :func:"
"`functools.partial` を使ってください:"

#: ../../library/asyncio-eventloop.rst:252
msgid ""
"Using partial objects is usually more convenient than using lambdas, as "
"asyncio can render partial objects better in debug and error messages."
msgstr ""
"asyncio は partial オブジェクトのデバッグメッセージやエラーメッセージをよりよ"
"く可視化することができるため、通常はラムダ式よりも partial オブジェクトを使う"
"方が便利です。"

#: ../../library/asyncio-eventloop.rst:260
msgid "Scheduling delayed callbacks"
msgstr "遅延コールバックのスケジューリング"

#: ../../library/asyncio-eventloop.rst:262
msgid ""
"Event loop provides mechanisms to schedule callback functions to be called "
"at some point in the future.  Event loop uses monotonic clocks to track time."
msgstr ""
"イベントループは、コールバック関数を未来のある時点で呼び出されるようにスケ"
"ジュールする仕組みを提供します。イベントループは時刻が戻らない単調な時計 "
"(monotonic clock) を使って時刻を追跡します。"

#: ../../library/asyncio-eventloop.rst:269
msgid ""
"Schedule *callback* to be called after the given *delay* number of seconds "
"(can be either an int or a float)."
msgstr ""
"*delay* 秒経過後にコールバック関数 *callback* を呼び出すようにスケジュールし"
"ます。 *delay* には整数または浮動小数点数を指定します。"

#: ../../library/asyncio-eventloop.rst:272
#: ../../library/asyncio-eventloop.rst:304
msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned which can be used to "
"cancel the callback."
msgstr ""
":class:`asyncio.TimerHandle` のインスタンスを返します。このインスタンスを使っ"
"てスケジュールしたコールバックをキャンセルすることができます。"

#: ../../library/asyncio-eventloop.rst:275
msgid ""
"*callback* will be called exactly once.  If two callbacks are scheduled for "
"exactly the same time, the order in which they are called is undefined."
msgstr ""
"*callback* は厳密に一度だけ呼び出されます。2つのコールバックが完全に同じ時間"
"にスケジュールされた場合、呼び出しの順序は未定義です。"

#: ../../library/asyncio-eventloop.rst:279
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with keyword arguments use :"
"func:`functools.partial`."
msgstr ""
"オプションの位置引数 *args* はコールバックが呼び出されるときに位置引数として"
"渡されます。キーワード引数を指定してコールバックを呼び出したい場合は :func:"
"`functools.partial` を使用してください。"

#: ../../library/asyncio-eventloop.rst:291
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"*delay* could not exceed one day. This has been fixed in Python 3.8."
msgstr ""
"Python 3.7 またはそれ以前のバージョンでは、デフォルトイベントループの実装を利"
"用した場合に遅延時間 *delay* が1日を超えることができませんでした。この問題は "
"Python 3.8 で修正されました。"

#: ../../library/asyncio-eventloop.rst:298
msgid ""
"Schedule *callback* to be called at the given absolute timestamp *when* (an "
"int or a float), using the same time reference as :meth:`loop.time`."
msgstr ""
"絶対値の時刻 *when* (整数または浮動小数点数) にコールバックを呼び出すようにス"
"ケジュールします。 :meth:`loop.time` と同じ参照時刻を使用します。"

#: ../../library/asyncio-eventloop.rst:302
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "このメソッドの振る舞いは :meth:`call_later` と同じです。"

#: ../../library/asyncio-eventloop.rst:311
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"difference between *when* and the current time could not exceed one day.  "
"This has been fixed in Python 3.8."
msgstr ""
"Python 3.7 またはそれ以前のバージョンでは、デフォルトイベントループの実装を利"
"用した場合に現在の時刻と *when* との差が1日を超えることができませんでした。こ"
"の問題は Python 3.8 で修正されました。"

#: ../../library/asyncio-eventloop.rst:318
msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal monotonic clock."
msgstr ""
"現在の時刻を :class:`float` 値で返します。時刻はイベントループが内部で参照し"
"ている時刻が戻らない単調な時計 (monotonic clock) に従います。"

#: ../../library/asyncio-eventloop.rst:322
msgid ""
"In Python 3.7 and earlier timeouts (relative *delay* or absolute *when*) "
"should not exceed one day.  This has been fixed in Python 3.8."
msgstr ""
"Python 3.7 またはそれ以前のバージョンでは、タイムアウト (相対値 *delay* もし"
"くは絶対値 *when*) は1日を超えることができませんでした。この問題は Python "
"3.8 で修正されました。"

#: ../../library/asyncio-eventloop.rst:328
msgid "The :func:`asyncio.sleep` function."
msgstr "関数 :func:`asyncio.sleep`。"

#: ../../library/asyncio-eventloop.rst:332
msgid "Creating Futures and Tasks"
msgstr "フューチャーとタスクの生成"

#: ../../library/asyncio-eventloop.rst:336
msgid "Create an :class:`asyncio.Future` object attached to the event loop."
msgstr ""
"イベントループに接続した :class:`asyncio.Future` オブジェクトを生成します。"

#: ../../library/asyncio-eventloop.rst:338
msgid ""
"This is the preferred way to create Futures in asyncio. This lets third-"
"party event loops provide alternative implementations of the Future object "
"(with better performance or instrumentation)."
msgstr ""
"asyncio でフューチャーオブジェクトを作成するために推奨される方法です。このメ"
"ソッドにより、サードパーティ製のイベントループがFutures クラスの(パフォーマン"
"スや計測方法が優れた) 代替実装を提供することを可能にします。 "

#: ../../library/asyncio-eventloop.rst:346
msgid ""
"Schedule the execution of :ref:`coroutine <coroutine>` *coro*. Return a :"
"class:`Task` object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:349
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of :class:"
"`Task`."
msgstr ""
"サードパーティのイベントループは相互運用のための自身の :class:`Task` のサブク"
"ラスを使用できます。この場合、結果は :class:`Task` のサブクラスになります。"

#: ../../library/asyncio-eventloop.rst:353
msgid ""
"If the *name* argument is provided and not ``None``, it is set as the name "
"of the task using :meth:`Task.set_name`."
msgstr ""
"*name* 引数が指定され、値が ``None`` でない場合、 :meth:`Task.set_name` メ"
"ソッドにより *name* がタスクの名前として設定されます。"

#: ../../library/asyncio-eventloop.rst:356
msgid "Added the *name* parameter."
msgstr "*name* パラメータを追加しました。"

#: ../../library/asyncio-eventloop.rst:361
msgid "Set a task factory that will be used by :meth:`loop.create_task`."
msgstr ":meth:`loop.create_task` が使用するタスクファクトリーを設定します。"

#: ../../library/asyncio-eventloop.rst:364
msgid ""
"If *factory* is ``None`` the default task factory will be set. Otherwise, "
"*factory* must be a *callable* with the signature matching ``(loop, coro)``, "
"where *loop* is a reference to the active event loop, and *coro* is a "
"coroutine object.  The callable must return a :class:`asyncio.Future`-"
"compatible object."
msgstr ""
"*factory* が ``None`` の場合、デフォルトのタスクファクトリーが設定されます。"
"そうでなければ、 *factory* は ``(loop, coro)`` に一致する関数シグネチャを持っ"
"た *呼び出し可能オブジェクト* でなければなりません。ここで *loop* はアクティ"
"ブなイベントループへの参照であり、 *coro* はコルーチンオブジェクトです。呼び"
"出し可能オブジェクトは :class:`asyncio.Future` と互換性のあるオブジェクトを返"
"さなければなりません。"

#: ../../library/asyncio-eventloop.rst:372
msgid "Return a task factory or ``None`` if the default one is in use."
msgstr ""
"タスクファクトリを返します。デフォルトのタスクファクトリを使用中の場合は "
"``None`` を返します。"

#: ../../library/asyncio-eventloop.rst:376
msgid "Opening network connections"
msgstr "ネットワーク接続の確立"

#: ../../library/asyncio-eventloop.rst:385
msgid ""
"Open a streaming transport connection to a given address specified by *host* "
"and *port*."
msgstr ""
"*host* と *port* で指定されたアドレスとのストリーミングトランスポート接続を"
"オープンします。"

#: ../../library/asyncio-eventloop.rst:388
msgid ""
"The socket family can be either :py:data:`~socket.AF_INET` or :py:data:"
"`~socket.AF_INET6` depending on *host* (or the *family* argument, if "
"provided)."
msgstr ""
"ソケットファミリーは *host* (または *family* 引数が与えられた場合は "
"*family*) に依存し、 :py:data:`~socket.AF_INET` か :py:data:`~socket."
"AF_INET6` のいずれかを指定します。"

#: ../../library/asyncio-eventloop.rst:392
msgid "The socket type will be :py:data:`~socket.SOCK_STREAM`."
msgstr "ソケットタイプは :py:data:`~socket.SOCK_STREAM` になります。"

#: ../../library/asyncio-eventloop.rst:394
#: ../../library/asyncio-eventloop.rst:1036
#: ../../library/asyncio-eventloop.rst:1052
msgid ""
"*protocol_factory* must be a callable returning an :ref:`asyncio protocol "
"<asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* は :ref:`asyncio プロトコル <asyncio-protocol>` の実装を返"
"す呼び出し可能オブジェクトでなければなりません。"

#: ../../library/asyncio-eventloop.rst:397
msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr ""
"このメソッドはバックグラウンドで接続の確立を試みます。成功した場合、メソッド"
"は ``(transport, protocol)`` のペアを返します。"

#: ../../library/asyncio-eventloop.rst:400
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "時系列での下層処理の概要は以下のとおりです:"

#: ../../library/asyncio-eventloop.rst:402
msgid ""
"The connection is established and a :ref:`transport <asyncio-transport>` is "
"created for it."
msgstr ""
"接続を確立し、その接続に対する :ref:`トランスポート <asyncio-transport>` が生"
"成されます。"

#: ../../library/asyncio-eventloop.rst:405
msgid ""
"*protocol_factory* is called without arguments and is expected to return a :"
"ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* が引数なしで呼び出され、ファクトリが :ref:`プロトコル "
"<asyncio-protocol>` インスタンスを返すよう要求します。"

#: ../../library/asyncio-eventloop.rst:408
msgid ""
"The protocol instance is coupled with the transport by calling its :meth:"
"`~BaseProtocol.connection_made` method."
msgstr ""
"プロトコルインスタンスが :meth:`~BaseProtocol.connection_made` メソッドを呼び"
"出すことにより、トランスポートと紐付けられます。"

#: ../../library/asyncio-eventloop.rst:411
msgid "A ``(transport, protocol)`` tuple is returned on success."
msgstr "成功すると ``(transport, protocol)`` タプルが返されます。"

#: ../../library/asyncio-eventloop.rst:413
msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr "作成されたトランスポートは実装依存の双方向ストリームです。"

#: ../../library/asyncio-eventloop.rst:416
#: ../../library/asyncio-eventloop.rst:544
msgid "Other arguments:"
msgstr "その他の引数:"

#: ../../library/asyncio-eventloop.rst:418
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is :const:"
"`True`, a default context returned from :func:`ssl.create_default_context` "
"is used."
msgstr ""
"*ssl*: 偽値以外が与えられた場合、SSL/TLS トランスポートが作成されます (デフォ"
"ルトでは暗号化なしの TCP トランスポートが作成されます)。 *ssl* が :class:"
"`ssl.SSLContext` オブジェクトの場合、このコンテキストがトランスポートを作成す"
"るために使用されます; *ssl* が :const:`True` の場合、 :func:`ssl."
"create_default_context` が返すデフォルトのコンテキストが使われます。"

#: ../../library/asyncio-eventloop.rst:424
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`SSL/TLS セキュリティについての考察 <ssl-security>`"

#: ../../library/asyncio-eventloop.rst:426
msgid ""
"*server_hostname* sets or overrides the hostname that the target server's "
"certificate will be matched against.  Should only be passed if *ssl* is not "
"``None``.  By default the value of the *host* argument is used.  If *host* "
"is empty, there is no default and you must pass a value for "
"*server_hostname*.  If *server_hostname* is an empty string, hostname "
"matching is disabled (which is a serious security risk, allowing for "
"potential man-in-the-middle attacks)."
msgstr ""
"*server_hostname* は対象サーバーの証明書との一致を確認するためのホスト名を設"
"定または上書きします。この引数は *ssl* が ``None`` でない場合のみ設定すべきで"
"す。デフォルトでは *host* に指定したサーバー名が使用されます。 *host* が空の"
"文字列の場合のデフォルト値は設定されていません。その場合、 *server_hostname* "
"を必ず指定してください。 *server_hostname* も空の文字列の場合は、ホスト名の一"
"致確認は行われません (これは深刻なセキュリティリスクであり、中間者攻撃を受け"
"る可能性があります)。"

#: ../../library/asyncio-eventloop.rst:434
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given, "
"these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*, *proto*, *flags* は任意のアドレスファミリであり、*host* 解決のため"
"の getaddrinfo() 経由で渡されるプロトコルおよびフラグになります。このオプショ"
"ンが与えられた場合、これらはすべて :mod:`socket` モジュール定数に従った整数で"
"なければなりません。"

#: ../../library/asyncio-eventloop.rst:439
msgid ""
"*happy_eyeballs_delay*, if given, enables Happy Eyeballs for this "
"connection. It should be a floating-point number representing the amount of "
"time in seconds to wait for a connection attempt to complete, before "
"starting the next attempt in parallel. This is the \"Connection Attempt "
"Delay\" as defined in :rfc:`8305`. A sensible default value recommended by "
"the RFC is ``0.25`` (250 milliseconds)."
msgstr ""
"*happy_eyeballs_delay* が設定されると、この接続に対して Happy Eyeballs が有効"
"化されます。設定する値は浮動小数点数であり、次の接続試行を開始する前に、現在"
"の接続試行が完了するのを待つ時間を秒単位で表現します。この値は :rfc:`8305` で"
"定義されている \"接続試行遅延\" に相当します。RFC で推奨されている実用的なデ"
"フォルト値は ``0.25`` (250 ミリ秒) です。"

#: ../../library/asyncio-eventloop.rst:447
msgid ""
"*interleave* controls address reordering when a host name resolves to "
"multiple IP addresses. If ``0`` or unspecified, no reordering is done, and "
"addresses are tried in the order returned by :meth:`getaddrinfo`. If a "
"positive integer is specified, the addresses are interleaved by address "
"family, and the given integer is interpreted as \"First Address Family "
"Count\" as defined in :rfc:`8305`. The default is ``0`` if "
"*happy_eyeballs_delay* is not specified, and ``1`` if it is."
msgstr ""
"*interleave* はホスト名が複数の IP アドレスに名前解決される場合のアドレスの並"
"べ替えを制御します。 ``0`` または未指定の場合並べ替えは行われず、 :meth:"
"`getaddrinfo` が返す順番にしたがってアドレスへの接続を試行します。正の整数が"
"指定されると、アドレスはアドレスファミリに応じてインターリーブされます。この"
"とき、与えられた整数は :rfc:`8305` で定義される \"最初のアドレスファミリカウ"
"ント (First Address Family Count)\" として解釈されます。デフォルト値は、 "
"*happy_eyeballs_delay* が指定されない場合は ``0`` であり、指定された場合は "
"``1`` です。"

#: ../../library/asyncio-eventloop.rst:456
msgid ""
"*sock*, if given, should be an existing, already connected :class:`socket."
"socket` object to be used by the transport. If *sock* is given, none of "
"*host*, *port*, *family*, *proto*, *flags*, *happy_eyeballs_delay*, "
"*interleave* and *local_addr* should be specified."
msgstr ""
"*sock* を与える場合、トランスポートに使用される、既存の、かつ接続済の :class:"
"`socket.socket` オブジェクトを指定します。*sock* を指定する場合、*host*、 "
"*port*、 *family*、 *proto*、 *flags*、 *happy_eyeballs_delay*、 "
"*interleave* および *local_addr* のいずれも指定してはいけません。"

#: ../../library/asyncio-eventloop.rst:464
#: ../../library/asyncio-eventloop.rst:575
#: ../../library/asyncio-eventloop.rst:761
msgid ""
"The *sock* argument transfers ownership of the socket to the transport "
"created. To close the socket, call the transport's :meth:`~asyncio."
"BaseTransport.close` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:468
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using "
"``getaddrinfo()``, similarly to *host* and *port*."
msgstr ""
"*local_addr* を与える場合、ソケットをローカルにバインドするために使用する "
"``(local_host, local_port)`` タプルを指定します。 *local_host* と "
"*local_port* は、 *host* および *port* と同じく ``getaddrinfo()`` を使って"
"ルックアップされます。"

#: ../../library/asyncio-eventloop.rst:472
#: ../../library/asyncio-eventloop.rst:843
msgid ""
"*ssl_handshake_timeout* is (for a TLS connection) the time in seconds to "
"wait for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* は TLS ハンドシェイクが完了するまでの (TLS 接続のため"
"の) 待ち時間を秒単位で指定します。指定した待ち時間を超えると接続は中断しま"
"す。 ``None`` が与えられた場合はデフォルト値 ``60.0`` が使われます。"

#: ../../library/asyncio-eventloop.rst:478
#: ../../library/asyncio-eventloop.rst:702
msgid "Added support for SSL/TLS in :class:`ProactorEventLoop`."
msgstr ""
":class:`ProactorEventLoop` において SSL/TLS のサポートが追加されました。"

#: ../../library/asyncio-eventloop.rst:482
msgid ""
"The socket option :py:data:`~socket.TCP_NODELAY` is set by default for all "
"TCP connections."
msgstr ""
"全ての TCP 接続に対してデフォルトでソケットオプション :py:data:`~socket."
"TCP_NODELAY` が設定されるようになりました。"

#: ../../library/asyncio-eventloop.rst:487
#: ../../library/asyncio-eventloop.rst:778
msgid "Added the *ssl_handshake_timeout* parameter."
msgstr ""

#: ../../library/asyncio-eventloop.rst:491
msgid "Added the *happy_eyeballs_delay* and *interleave* parameters."
msgstr "*happy_eyeballs_delay* と *interleave* が追加されました。"

#: ../../library/asyncio-eventloop.rst:493
msgid ""
"Happy Eyeballs Algorithm: Success with Dual-Stack Hosts. When a server's "
"IPv4 path and protocol are working, but the server's IPv6 path and protocol "
"are not working, a dual-stack client application experiences significant "
"connection delay compared to an IPv4-only client.  This is undesirable "
"because it causes the dual- stack client to have a worse user experience.  "
"This document specifies requirements for algorithms that reduce this user-"
"visible delay and provides an algorithm."
msgstr ""

#: ../../library/asyncio-eventloop.rst:502
msgid "For more information: https://tools.ietf.org/html/rfc6555"
msgstr "詳しくは右記を参照してください: https://tools.ietf.org/html/rfc6555"

#: ../../library/asyncio-eventloop.rst:506
msgid ""
"The :func:`open_connection` function is a high-level alternative API.  It "
"returns a pair of (:class:`StreamReader`, :class:`StreamWriter`) that can be "
"used directly in async/await code."
msgstr ""
":func:`open_connection` 関数は高水準の代替 API です。この関数は(:class:"
"`StreamReader`, :class:`StreamWriter`) のペアを返し、 async/await コードから"
"直接使うことができます。"

#: ../../library/asyncio-eventloop.rst:517
msgid ""
"The parameter *reuse_address* is no longer supported, as using :py:data:"
"`~sockets.SO_REUSEADDR` poses a significant security concern for UDP. "
"Explicitly passing ``reuse_address=True`` will raise an exception."
msgstr ""
":py:data:`~sockets.SO_REUSEADDR` の利用が UDP に対して重大なセキュリティ上の"
"懸念をもたらすため、 *reuse_address* パラメータはサポートされなくなりました。"
"明示的に ``reuse_address=True`` を設定すると例外を送出します。"

#: ../../library/asyncio-eventloop.rst:521
msgid ""
"When multiple processes with differing UIDs assign sockets to an identical "
"UDP socket address with ``SO_REUSEADDR``, incoming packets can become "
"randomly distributed among the sockets."
msgstr ""
"``SO_REUSEADDR`` を使って、同一の UDP ソケットアドレスに対して複数のプロセス"
"が異なる UID でソケットを割り当てている場合、受信パケットは複数のソケット間に"
"ランダムに分散する可能性があります。"

#: ../../library/asyncio-eventloop.rst:525
msgid ""
"For supported platforms, *reuse_port* can be used as a replacement for "
"similar functionality. With *reuse_port*, :py:data:`~sockets.SO_REUSEPORT` "
"is used instead, which specifically prevents processes with differing UIDs "
"from assigning sockets to the same socket address."
msgstr ""
"サポートされているプラットフォームでは、 *reuse_port* が同様の機能に対する代"
"用品として利用できます。 *reuse_port* は代替機能として :py:data:`~sockets."
"SO_REUSEPORT` を使っており、複数のプロセスが異なる UID で同一のソケットに対し"
"て割り当てられるのを明確に禁止します。"

#: ../../library/asyncio-eventloop.rst:531
msgid "Create a datagram connection."
msgstr "データグラム接続 (UDP) を生成します。"

#: ../../library/asyncio-eventloop.rst:533
msgid ""
"The socket family can be either :py:data:`~socket.AF_INET`, :py:data:"
"`~socket.AF_INET6`, or :py:data:`~socket.AF_UNIX`, depending on *host* (or "
"the *family* argument, if provided)."
msgstr ""
"ソケットファミリーは *host* (または *family* 引数が与えられた場合は "
"*family*) に依存し、 :py:data:`~socket.AF_INET`、 :py:data:`~socket."
"AF_INET6`、 :py:data:`~socket.AF_UNIX` のいずれかを指定します。"

#: ../../library/asyncio-eventloop.rst:537
msgid "The socket type will be :py:data:`~socket.SOCK_DGRAM`."
msgstr "ソケットタイプは :py:data:`~socket.SOCK_DGRAM` になります。"

#: ../../library/asyncio-eventloop.rst:539
#: ../../library/asyncio-eventloop.rst:637
#: ../../library/asyncio-eventloop.rst:753
msgid ""
"*protocol_factory* must be a callable returning a :ref:`protocol <asyncio-"
"protocol>` implementation."
msgstr ""
"*protocol_factory* は :ref:`asyncio プロトコル <asyncio-protocol>` の実装を返"
"す呼び出し可能オブジェクトでなければなりません。"

#: ../../library/asyncio-eventloop.rst:542
#: ../../library/asyncio-eventloop.rst:602
msgid "A tuple of ``(transport, protocol)`` is returned on success."
msgstr "成功すると ``(transport, protocol)`` タプルが返されます。"

#: ../../library/asyncio-eventloop.rst:546
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using :"
"meth:`getaddrinfo`."
msgstr ""
"*local_addr* が指定される場合、ソケットをローカルにバインドするための "
"``(local_host, local_port)`` のタプルを指定します。 *local_host* と "
"*local_port* は :meth:`getaddrinfo` メソッドを使用して検索されます。"

#: ../../library/asyncio-eventloop.rst:550
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port* "
"are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr* が指定される場合、``(remote_host, remote_por)`` のタプルで、ソ"
"ケットをリモートアドレスに束縛するために使用されます。*remote_host* と "
"*remote_port* は :meth:`getaddrinfo` を使用して検索されます。"

#: ../../library/asyncio-eventloop.rst:554
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* は任意のアドレスファミリです。これらのファミリ、プ"
"ロトコル、フラグは、*host* 解決のため :meth:`getaddrinfo` 経由でオプションで"
"渡されます。これらのオプションを指定する場合、すべて :mod:`socket` モジュール"
"定数に従った整数でなければなりません。"

#: ../../library/asyncio-eventloop.rst:559
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows and some "
"Unixes. If the :py:data:`~socket.SO_REUSEPORT` constant is not defined then "
"this capability is unsupported."
msgstr ""
"*reuse_port* は、同じポートにバインドされた既存の端点すべてがこのフラグを設定"
"して生成されている場合に限り、この端点を既存の端点と同じポートにバインドする"
"ことを許可するよう、カーネルに指示します（訳註: ソケットのオプション "
"SO_REUSEPORT を使用します）。このオプションは、Windows やいくつかの UNIX シス"
"テムではサポートされていません。:py:data:`~socket.SO_REUSEPORT` 定数が定義さ"
"れていなければ、この機能はサポートされません。"

#: ../../library/asyncio-eventloop.rst:565
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr ""
"*allow_broadcast* は、カーネルに、このエンドポイントがブロードキャストアドレ"
"スにメッセージを送信することを許可するように指示します。"

#: ../../library/asyncio-eventloop.rst:568
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be :const:"
"`None`)."
msgstr ""
"オプションの *sock* を指定することで、既存の、すでに接続されている :class:"
"`socket.socket` をトランスポートで使用することができます。このオプションを使"
"用する場合、*local_addr* と *remote_addr* は省略してください (:const:`None` "
"でなければなりません)。"

#: ../../library/asyncio-eventloop.rst:579
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and :"
"ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""
":ref:`UDP echo クライアントプロトコル <asyncio-udp-echo-client-protocol>` お"
"よび :ref:`UDP echo サーバープロトコル <asyncio-udp-echo-server-protocol>` の"
"例を参照してください。"

#: ../../library/asyncio-eventloop.rst:582
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""
"*family*, *proto*, *flags*, *reuse_address*, *reuse_port, *allow_broadcast*, "
"*sock* パラメータが追加されました。"

#: ../../library/asyncio-eventloop.rst:586
msgid ""
"The *reuse_address* parameter is no longer supported due to security "
"concerns."
msgstr ""
"セキュリティ上の懸念により、 *reuse_address* パラメータはサポートされなくなり"
"ました。"

#: ../../library/asyncio-eventloop.rst:590
msgid "Added support for Windows."
msgstr "Windows サポートが追加されました。"

#: ../../library/asyncio-eventloop.rst:597
msgid "Create a Unix connection."
msgstr "Unix 接続を生成します。"

#: ../../library/asyncio-eventloop.rst:599
msgid ""
"The socket family will be :py:data:`~socket.AF_UNIX`; socket type will be :"
"py:data:`~socket.SOCK_STREAM`."
msgstr ""
"ソケットファミリーは :py:data:`~socket.AF_UNIX` になります; また、ソケットタ"
"イプは :py:data:`~socket.SOCK_STREAM` になります。"

#: ../../library/asyncio-eventloop.rst:604
msgid ""
"*path* is the name of a Unix domain socket and is required, unless a *sock* "
"parameter is specified.  Abstract Unix sockets, :class:`str`, :class:"
"`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* は Unix ドメインソケット名で、 *sock* パラメータが指定されない場合は必"
"須です。 抽象 Unix ソケット、 :class:`str`、 :class:`bytes`、 and :class:"
"`~pathlib.Path` 形式でのパスがサポートされています。"

#: ../../library/asyncio-eventloop.rst:609
msgid ""
"See the documentation of the :meth:`loop.create_connection` method for "
"information about arguments to this method."
msgstr ""
"このメソッドの引数についての詳細は :meth:`loop.create_connection` メソッドの"
"ドキュメントを参照してください。"

#: ../../library/asyncio-eventloop.rst:613
#: ../../library/asyncio-eventloop.rst:737
#: ../../library/asyncio-eventloop.rst:1103
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`利用可能な環境 <availability>`: Unix。"

#: ../../library/asyncio-eventloop.rst:614
msgid ""
"Added the *ssl_handshake_timeout* parameter. The *path* parameter can now be "
"a :term:`path-like object`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:620
msgid "Creating network servers"
msgstr "ネットワークサーバの生成"

#: ../../library/asyncio-eventloop.rst:630
msgid ""
"Create a TCP server (socket type :data:`~socket.SOCK_STREAM`) listening on "
"*port* of the *host* address."
msgstr ""
"アドレス *host* のポート *port* をリッスンする (ソケットタイプが :data:"
"`~socket.SOCK_STREAM` である) TCP サーバーを生成します。"

#: ../../library/asyncio-eventloop.rst:633
msgid "Returns a :class:`Server` object."
msgstr ":class:`Server` オブジェクトを返します。"

#: ../../library/asyncio-eventloop.rst:635
msgid "Arguments:"
msgstr "引数:"

#: ../../library/asyncio-eventloop.rst:640
msgid ""
"The *host* parameter can be set to several types which determine where the "
"server would be listening:"
msgstr ""
"*host* パラメータはいくつかの方法で指定することができ、その値によってサーバー"
"がどこをリッスンするかが決まります。"

#: ../../library/asyncio-eventloop.rst:643
msgid ""
"If *host* is a string, the TCP server is bound to a single network interface "
"specified by *host*."
msgstr ""
"*host* が文字列の場合、 TCP サーバーは *host* で指定した単一のネットワークイ"
"ンターフェースに束縛されます。"

#: ../../library/asyncio-eventloop.rst:646
msgid ""
"If *host* is a sequence of strings, the TCP server is bound to all network "
"interfaces specified by the sequence."
msgstr ""
"*host* が文字列のシーケンスである場合、 TCP サーバーはそのシーケンスで指定さ"
"れた全てのネットワークインターフェースに束縛されます。"

#: ../../library/asyncio-eventloop.rst:649
msgid ""
"If *host* is an empty string or ``None``, all interfaces are assumed and a "
"list of multiple sockets will be returned (most likely one for IPv4 and "
"another one for IPv6)."
msgstr ""
"*host* が空の文字列か ``None`` の場合、すべてのインターフェースが想定され、複"
"合的なソケットのリスト (通常は一つが IPv4、もう一つが IPv6) が返されます。"

#: ../../library/asyncio-eventloop.rst:653
msgid ""
"The *port* parameter can be set to specify which port the server should "
"listen on. If ``0`` or ``None`` (the default), a random unused port will be "
"selected (note that if *host* resolves to multiple network interfaces, a "
"different random port will be selected for each interface)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:658
msgid ""
"*family* can be set to either :data:`socket.AF_INET` or :data:`~socket."
"AF_INET6` to force the socket to use IPv4 or IPv6. If not set, the *family* "
"will be determined from host name (defaults to :data:`~socket.AF_UNSPEC`)."
msgstr ""
"*family* に :data:`socket.AF_INET` または :data:`~socket.AF_INET6` を指定する"
"ことにより、ソケットでそれぞれ IPv4 または IPv6 の使用を強制することができま"
"す。設定されない場合、 *family* はホスト名から決定されます (:data:`socket."
"AF_UNSPEC` がデフォルトになります)。"

#: ../../library/asyncio-eventloop.rst:663
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* は :meth:`getaddrinfo` のためのビットマスクになります。"

#: ../../library/asyncio-eventloop.rst:665
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* must not be specified."
msgstr ""
"サーバーで既存のソケットオブジェクトを使用するために、オプションの引数 "
"*sock* にソケットオブジェクトを設定することができます。指定した場合、 *host* "
"と *port* を指定してはいけません。"

#: ../../library/asyncio-eventloop.rst:670
msgid ""
"The *sock* argument transfers ownership of the socket to the server created. "
"To close the socket, call the server's :meth:`~asyncio.Server.close` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:674
msgid ""
"*backlog* is the maximum number of queued connections passed to :meth:"
"`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* は :meth:`~socket.socket.listen` に渡される、キューに入るコネクショ"
"ンの最大数になります (デフォルトは 100)。"

#: ../../library/asyncio-eventloop.rst:677
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` instance to enable TLS over "
"the accepted connections."
msgstr ""
"確立した接続の上で TLS を有効化するために、 *ssl* に :class:`~ssl."
"SSLContext` のインスタンスを指定することができます。"

#: ../../library/asyncio-eventloop.rst:680
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in ``TIME_WAIT`` "
"state, without waiting for its natural timeout to expire. If not specified "
"will automatically be set to ``True`` on Unix."
msgstr ""
"*reuse_address* は、``TIME_WAIT`` 状態にあるローカルソケットを、その状態が自"
"然にタイムアウトするのを待つことなく再利用するようカーネルに指示します（訳"
"註: ソケットのオプション SO_REUSEADDR を使用します）。指定しない場合、UNIX で"
"は自動的に ``True`` が設定されます。"

#: ../../library/asyncio-eventloop.rst:685
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows."
msgstr ""
"*reuse_port* は、同じポートにバインドされた既存の端点すべてがこのフラグを設定"
"して生成されている場合に限り、この端点を既存の端点と同じポートにバインドする"
"ことを許可するよう、カーネルに指示します（訳註: ソケットのオプション "
"SO_REUSEPORT を使用します）。このオプションは、Windows ではサポートされていま"
"せん。"

#: ../../library/asyncio-eventloop.rst:690
msgid ""
"*ssl_handshake_timeout* is (for a TLS server) the time in seconds to wait "
"for the TLS handshake to complete before aborting the connection. ``60.0`` "
"seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* は TLS ハンドシェイクが完了するまでの (TLS サーバーの"
"ための) 待ち時間を秒単位で指定します。指定した待ち時間を超えると接続は中断し"
"ます。 ``None`` が与えられた場合はデフォルト値 ``60.0`` が使われます。"

#: ../../library/asyncio-eventloop.rst:694
msgid ""
"*start_serving* set to ``True`` (the default) causes the created server to "
"start accepting connections immediately.  When set to ``False``, the user "
"should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever` "
"to make the server to start accepting connections."
msgstr ""
"*start_serving* が ``True`` に設定された場合 (これがデフォルトです)、 生成さ"
"れたサーバーは即座に接続の受け付けを開始します。 ``False`` が指定された場合、"
"ユーザーは接続の受け付けを開始するために :meth:`Server.start_serving` また"
"は :meth:`Server.serve_forever` を待ち受け (await) る必要があります。"

#: ../../library/asyncio-eventloop.rst:706
msgid "The *host* parameter can be a sequence of strings."
msgstr "*host* パラメータに文字列のシーケンスを指定できるようになりました。"

#: ../../library/asyncio-eventloop.rst:710
msgid ""
"Added *ssl_handshake_timeout* and *start_serving* parameters. The socket "
"option :py:data:`~socket.TCP_NODELAY` is set by default for all TCP "
"connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:716
msgid ""
"The :func:`start_server` function is a higher-level alternative API that "
"returns a pair of :class:`StreamReader` and :class:`StreamWriter` that can "
"be used in an async/await code."
msgstr ""
":func:`start_server` 関数は高水準の代替 API です。この関数は :class:"
"`StreamReader` と :class:`StreamWriter` のペアを返し、async/await コードから"
"使うことができます。"

#: ../../library/asyncio-eventloop.rst:725
msgid ""
"Similar to :meth:`loop.create_server` but works with the :py:data:`~socket."
"AF_UNIX` socket family."
msgstr ""
":meth:`loop.create_server` と似ていますが、 :py:data:`~socket.AF_UNIX` ソケッ"
"トファミリーとともに動作します。"

#: ../../library/asyncio-eventloop.rst:728
msgid ""
"*path* is the name of a Unix domain socket, and is required, unless a *sock* "
"argument is provided.  Abstract Unix sockets, :class:`str`, :class:`bytes`, "
"and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* は Unix ドメインソケット名で、 *sock* パラメータが指定されない場合は必"
"須です。 抽象 Unix ソケット、 :class:`str`、 :class:`bytes`、 and :class:"
"`~pathlib.Path` 形式でのパスがサポートされています。"

#: ../../library/asyncio-eventloop.rst:733
msgid ""
"See the documentation of the :meth:`loop.create_server` method for "
"information about arguments to this method."
msgstr ""
"このメソッドの引数についての詳細は :meth:`loop.create_server` メソッドのド"
"キュメントを参照してください。"

#: ../../library/asyncio-eventloop.rst:740
msgid ""
"Added the *ssl_handshake_timeout* and *start_serving* parameters. The *path* "
"parameter can now be a :class:`~pathlib.Path` object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:746
msgid "Wrap an already accepted connection into a transport/protocol pair."
msgstr "すでに確立した接続を transport と protocol のペアでラップします。"

#: ../../library/asyncio-eventloop.rst:748
msgid ""
"This method can be used by servers that accept connections outside of "
"asyncio but that use asyncio to handle them."
msgstr ""
"このメソッドは asyncio の範囲外で確立された接続を使うサーバーに対しても使えま"
"すが、その場合でも接続は asyncio を使って処理されます。"

#: ../../library/asyncio-eventloop.rst:751
#: ../../library/asyncio-eventloop.rst:829
msgid "Parameters:"
msgstr "引数:"

#: ../../library/asyncio-eventloop.rst:756
msgid ""
"*sock* is a preexisting socket object returned from :meth:`socket.accept "
"<socket.socket.accept>`."
msgstr ""
"*sock* は :meth:`socket.accept <socket.socket.accept>` メソッドが返す既存のソ"
"ケットオブジェクトです。"

#: ../../library/asyncio-eventloop.rst:765
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr ""
"*ssl* には :class:`~ssl.SSLContext` を指定できます。指定すると、受け付けたコ"
"ネクション上での SSL を有効にします。"

#: ../../library/asyncio-eventloop.rst:768
msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to "
"wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* は SSL ハンドシェイクが完了するまでの (SSL 接続のため"
"の) 待ち時間を秒単位で指定します。 ``None`` が与えられた場合はデフォルト値 "
"``60.0`` が使われます。"

#: ../../library/asyncio-eventloop.rst:772
msgid "Returns a ``(transport, protocol)`` pair."
msgstr "``(transport, protocol)`` のペアを返します。"

#: ../../library/asyncio-eventloop.rst:782
msgid "Transferring files"
msgstr "ファイルの転送"

#: ../../library/asyncio-eventloop.rst:787
msgid ""
"Send a *file* over a *transport*.  Return the total number of bytes sent."
msgstr ""
"*transport* を通じて *file* を送信します。送信したデータの総バイト数を返しま"
"す。"

#: ../../library/asyncio-eventloop.rst:790
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr ""
"このメソッドは、もし利用可能であれば高性能な :meth:`os.sendfile` を利用しま"
"す。"

#: ../../library/asyncio-eventloop.rst:792
msgid "*file* must be a regular file object opened in binary mode."
msgstr ""
"*file* はバイナリモードでオープンされた通常のファイルオブジェクトでなければな"
"りません。"

#: ../../library/asyncio-eventloop.rst:794
#: ../../library/asyncio-eventloop.rst:991
msgid ""
"*offset* tells from where to start reading the file. If specified, *count* "
"is the total number of bytes to transmit as opposed to sending the file "
"until EOF is reached. File position is always updated, even when this method "
"raises an error, and :meth:`file.tell() <io.IOBase.tell>` can be used to "
"obtain the actual number of bytes sent."
msgstr ""
"*offset* はファイルの読み込み開始位置を指定します。 *count* が指定された場"
"合、ファイルの EOF までファイルを送信する代わりに、 *count* で指定された総バ"
"イト数の分だけ送信します。ファイルオブジェクトが指し示す位置は、メソッドがエ"
"ラーを送出した場合でも更新されます。この場合実際に送信されたバイト数は :meth:"
"`file.tell() <io.IOBase.tell>` メソッドで取得することができます。"

#: ../../library/asyncio-eventloop.rst:801
msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the file "
"when the platform does not support the sendfile system call (e.g. Windows or "
"SSL socket on Unix)."
msgstr ""
"*fallback* を ``True`` に指定することで、 asyncio がプラットフォームが "
"sendfile システムコールをサポートしていない場合 (たとえば Windows や Unix の "
"SSL ソケットなど) に別の方法でファイルの読み込みと送信を行うようにすることが"
"できます。"

#: ../../library/asyncio-eventloop.rst:805
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support the "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"システムが *sendfile* システムコールをサポートしておらず、かつ *fallback* が "
"``False`` の場合、 :exc:`SendfileNotAvailableError` 例外を送出します。"

#: ../../library/asyncio-eventloop.rst:812
msgid "TLS Upgrade"
msgstr "TLS へのアップグレード"

#: ../../library/asyncio-eventloop.rst:818
msgid "Upgrade an existing transport-based connection to TLS."
msgstr "既存のトランスポートベースの接続を TLS にアップグレードします。"

#: ../../library/asyncio-eventloop.rst:820
msgid ""
"Create a TLS coder/decoder instance and insert it between the *transport* "
"and the *protocol*. The coder/decoder implements both *transport*-facing "
"protocol and *protocol*-facing transport."
msgstr ""

#: ../../library/asyncio-eventloop.rst:824
msgid ""
"Return the created two-interface instance. After *await*, the *protocol* "
"must stop using the original *transport* and communicate with the returned "
"object only because the coder caches *protocol*-side data and sporadically "
"exchanges extra TLS session packets with *transport*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:831
msgid ""
"*transport* and *protocol* instances that methods like :meth:`~loop."
"create_server` and :meth:`~loop.create_connection` return."
msgstr ""
"*transport* と *protocol* には、 :meth:`~loop.create_server` や :meth:`~loop."
"create_connection` が返すものと同等のインスタンスを指定します。"

#: ../../library/asyncio-eventloop.rst:835
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext*: 構成済みの :class:`~ssl.SSLContext` インスタンスです。"

#: ../../library/asyncio-eventloop.rst:837
msgid ""
"*server_side* pass ``True`` when a server-side connection is being upgraded "
"(like the one created by :meth:`~loop.create_server`)."
msgstr ""
"(:meth:`~loop.create_server` で生成されたような) サーバーサイドの接続をアップ"
"グレードする場合は *server_side* に ``True`` を渡します。"

#: ../../library/asyncio-eventloop.rst:840
msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""
"*server_hostname*: 対象のサーバーの証明書との照合に使われるホスト名を設定また"
"は上書きします。"

#: ../../library/asyncio-eventloop.rst:851
msgid "Watching file descriptors"
msgstr "ファイル記述子の監視"

#: ../../library/asyncio-eventloop.rst:855
msgid ""
"Start monitoring the *fd* file descriptor for read availability and invoke "
"*callback* with the specified arguments once *fd* is available for reading."
msgstr ""
"ファイル記述子 *fd* に対する読み込みが可能かどうかの監視を開始し、 *fd* が読"
"み込み可能になると、指定した引数でコールバック *callback* を呼び出します。"

#: ../../library/asyncio-eventloop.rst:861
msgid ""
"Stop monitoring the *fd* file descriptor for read availability. Returns "
"``True`` if *fd* was previously being monitored for reads."
msgstr ""

#: ../../library/asyncio-eventloop.rst:866
msgid ""
"Start monitoring the *fd* file descriptor for write availability and invoke "
"*callback* with the specified arguments once *fd* is available for writing."
msgstr ""
"ファイル記述子 *fd* に対する書き込みが可能かどうかの監視を開始し、 *fd* が書"
"き込み可能になると、指定した引数でコールバック *callback* を呼び出します。"

#: ../../library/asyncio-eventloop.rst:870
#: ../../library/asyncio-eventloop.rst:1090
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *callback*."
msgstr ""
"コールバック *callback* に :ref:`キーワード引数を渡す <asyncio-pass-"
"keywords>` 場合は :func:`functools.partial` を使ってください。"

#: ../../library/asyncio-eventloop.rst:875
msgid ""
"Stop monitoring the *fd* file descriptor for write availability. Returns "
"``True`` if *fd* was previously being monitored for writes."
msgstr ""

#: ../../library/asyncio-eventloop.rst:878
msgid ""
"See also :ref:`Platform Support <asyncio-platform-support>` section for some "
"limitations of these methods."
msgstr ""
"これらのメソッドに対する制限事項については :ref:`プラットフォームのサポート状"
"況 <asyncio-platform-support>` 節も参照してください。"

#: ../../library/asyncio-eventloop.rst:883
msgid "Working with socket objects directly"
msgstr "ソケットオブジェクトと直接やりとりする"

#: ../../library/asyncio-eventloop.rst:885
msgid ""
"In general, protocol implementations that use transport-based APIs such as :"
"meth:`loop.create_connection` and :meth:`loop.create_server` are faster than "
"implementations that work with sockets directly. However, there are some use "
"cases when performance is not critical, and working with :class:`~socket."
"socket` objects directly is more convenient."
msgstr ""
"一般に、 :meth:`loop.create_connection` や :meth:`loop.create_server` のよう"
"なトランスポートベースの API を使ったプロトコルの実装はソケットと直接やり取り"
"する実装に比べて高速です。しかしながら、パフォーマンスが重要でなく、直接 :"
"class:`~socket.socket` オブジェクトとやりとりした方が便利なユースケースがいく"
"つかあります。"

#: ../../library/asyncio-eventloop.rst:894
msgid ""
"Receive up to *nbytes* from *sock*.  Asynchronous version of :meth:`socket."
"recv() <socket.socket.recv>`."
msgstr ""
"*nbytes* で指定したバイト数までのデータをソケット *sock* から受信します。 こ"
"のメソッドは :meth:`socket.recv() <socket.socket.recv>` の非同期版です。"

#: ../../library/asyncio-eventloop.rst:897
msgid "Return the received data as a bytes object."
msgstr "受信したデータをバイトオブジェクトとして返します。"

#: ../../library/asyncio-eventloop.rst:899
#: ../../library/asyncio-eventloop.rst:913
#: ../../library/asyncio-eventloop.rst:928
#: ../../library/asyncio-eventloop.rst:941
#: ../../library/asyncio-eventloop.rst:967
#: ../../library/asyncio-eventloop.rst:1005
msgid "*sock* must be a non-blocking socket."
msgstr "*sock* はノンブロッキングソケットでなければなりません。"

#: ../../library/asyncio-eventloop.rst:901
msgid ""
"Even though this method was always documented as a coroutine method, "
"releases before Python 3.7 returned a :class:`Future`. Since Python 3.7 this "
"is an ``async def`` method."
msgstr ""
"このメソッドは常にコルーチンメソッドとしてドキュメントに記載されてきました"
"が、 Python 3.7 以前のリリースでは :class:`Future` オブジェクトを返していまし"
"た。 Python 3.7 からは ``async def`` メソッドになりました。"

#: ../../library/asyncio-eventloop.rst:908
msgid ""
"Receive data from *sock* into the *buf* buffer.  Modeled after the blocking :"
"meth:`socket.recv_into() <socket.socket.recv_into>` method."
msgstr ""
"ソケット *sock* からデータを受信してバッファ *buf* に格納します。ブロッキング"
"コードの :meth:`socket.recv_into() <socket.socket.recv_into>` メソッドをモデ"
"ルとしています。"

#: ../../library/asyncio-eventloop.rst:911
msgid "Return the number of bytes written to the buffer."
msgstr "バッファに書き込んだデータのバイト数を返します。"

#: ../../library/asyncio-eventloop.rst:919
msgid ""
"Send *data* to the *sock* socket. Asynchronous version of :meth:`socket."
"sendall() <socket.socket.sendall>`."
msgstr ""
"データ *data* をソケット *sock* に送信します。 :meth:`socket.sendall() "
"<socket.socket.sendall>` メソッドの非同期版です。"

#: ../../library/asyncio-eventloop.rst:922
msgid ""
"This method continues to send to the socket until either all data in *data* "
"has been sent or an error occurs.  ``None`` is returned on success.  On "
"error, an exception is raised. Additionally, there is no way to determine "
"how much data, if any, was successfully processed by the receiving end of "
"the connection."
msgstr ""
"このメソッドは *data* をすべて送信し終えるか、またはエラーが起きるまでデータ"
"をソケットに送信し続けます。送信に成功した場合 ``None`` を返します。エラーの"
"場合は例外が送出されます。エラーとなった場合、接続の受信側で正しく処理された"
"データの総量を特定する方法はありません。"

#: ../../library/asyncio-eventloop.rst:930
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned an :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""
"このメソッドは常にコルーチンメソッドとしてドキュメントに記載されてきました"
"が、 Python 3.7 以前のリリースでは :class:`Future` オブジェクトを返していまし"
"た。 Python 3.7 からは ``async def`` メソッドになりました。"

#: ../../library/asyncio-eventloop.rst:937
msgid "Connect *sock* to a remote socket at *address*."
msgstr "ソケット *sock* をアドレス *address* のリモートソケットに接続します。"

#: ../../library/asyncio-eventloop.rst:939
msgid ""
"Asynchronous version of :meth:`socket.connect() <socket.socket.connect>`."
msgstr ":meth:`socket.connect() <socket.socket.connect>` の非同期版です。"

#: ../../library/asyncio-eventloop.rst:943
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling :func:`socket."
"inet_pton`.  If not, :meth:`loop.getaddrinfo` will be used to resolve the "
"*address*."
msgstr ""
"``address`` を名前解決する必要はなくなりました。 ``sock_connect`` は :func:"
"`socket.inet_pton` を呼び出して *address* が解決済みかどうかを確認します。未"
"解決の場合、 *address* の名前解決には :meth:`loop.getaddrinfo` メソッドが使わ"
"れます。"

#: ../../library/asyncio-eventloop.rst:952
msgid ""
":meth:`loop.create_connection` and  :func:`asyncio.open_connection() "
"<open_connection>`."
msgstr ""
":meth:`loop.create_connection` および  :func:`asyncio.open_connection() "
"<open_connection>`。"

#: ../../library/asyncio-eventloop.rst:958
msgid ""
"Accept a connection.  Modeled after the blocking :meth:`socket.accept() "
"<socket.socket.accept>` method."
msgstr ""
"接続を受け付けます。ブロッキングコールの :meth:`socket.accept() <socket."
"socket.accept>` メソッドをモデルとしています。"

#: ../../library/asyncio-eventloop.rst:961
msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""
"ソケットはアドレスに束縛済みで、接続を listen 中である必要があります。戻り値"
"は ``(conn, address)`` のペアで、*conn* は接続を通じてデータの送受信を行うた"
"めの *新しい* ソケットオブジェクト、*address* は接続先の端点でソケットに束縛"
"されているアドレスを示します。"

#: ../../library/asyncio-eventloop.rst:969
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""
"このメソッドは常にコルーチンメソッドとしてドキュメントに記載されてきました"
"が、 Python 3.7 以前のリリースでは :class:`Future` オブジェクトを返していまし"
"た。 Python 3.7 からは ``async def`` メソッドになりました。"

#: ../../library/asyncio-eventloop.rst:976
msgid ":meth:`loop.create_server` and :func:`start_server`."
msgstr ":meth:`loop.create_server` および :func:`start_server`。"

#: ../../library/asyncio-eventloop.rst:981
msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible. Return "
"the total number of bytes sent."
msgstr ""
"ファイルを送信します。利用可能なら高性能な :mod:`os.sendfile` を使います。送"
"信したデータの総バイト数を返します。"

#: ../../library/asyncio-eventloop.rst:984
msgid ""
"Asynchronous version of :meth:`socket.sendfile() <socket.socket.sendfile>`."
msgstr ""
":meth:`socket.sendfile() <socket.socket.sendfile>` メソッドの非同期版です。"

#: ../../library/asyncio-eventloop.rst:986
msgid ""
"*sock* must be a non-blocking :const:`socket.SOCK_STREAM` :class:`~socket."
"socket`."
msgstr ""
"*sock* は :const:`socket.SOCK_STREAM` タイプのノンブロッキングな :class:"
"`~socket.socket` でなければなりません。"

#: ../../library/asyncio-eventloop.rst:989
msgid "*file* must be a regular file object open in binary mode."
msgstr ""
"*file* はバイナリモードでオープンされた通常のファイルオブジェクトでなければな"
"りません。"

#: ../../library/asyncio-eventloop.rst:998
msgid ""
"*fallback*, when set to ``True``, makes asyncio manually read and send the "
"file when the platform does not support the sendfile syscall (e.g. Windows "
"or SSL socket on Unix)."
msgstr ""
"*fallback* が ``True`` に設定された場合、 プラットフォームが sendfile システ"
"ムコールをサポートしていない場合 (たとえば Windows や Unix の SSL ソケットな"
"ど) に asyncio が別の方法でファイルの読み込みと送信を行うようにすることができ"
"ます。"

#: ../../library/asyncio-eventloop.rst:1002
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"システムが *sendfile* システムコールをサポートしておらず、かつ *fallback* が "
"``False`` の場合、 :exc:`SendfileNotAvailableError` 例外を送出します。"

#: ../../library/asyncio-eventloop.rst:1011
msgid "DNS"
msgstr "DNS"

#: ../../library/asyncio-eventloop.rst:1016
msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr ":meth:`socket.getaddrinfo` の非同期版です。"

#: ../../library/asyncio-eventloop.rst:1020
msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr ":meth:`socket.getnameinfo` の非同期版です。"

#: ../../library/asyncio-eventloop.rst:1022
msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning :"
"class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are "
"coroutines."
msgstr ""
"*getaddrinfo* と *getnameinfo* の2つのメソッドは、いずれも常にコルーチンメ"
"ソッドとしてドキュメントに記載されてきましたが、 Python 3.7 以前のリリースで"
"は、実際には :class:`asyncio.Future` オブジェクトを返していました。 Python "
"3.7 からはどちらのメソッドもコルーチンになりました。"

#: ../../library/asyncio-eventloop.rst:1030
msgid "Working with pipes"
msgstr "パイプとやりとりする"

#: ../../library/asyncio-eventloop.rst:1034
msgid "Register the read end of *pipe* in the event loop."
msgstr "イベントループの読み込み側終端に *pipe* を登録します。"

#: ../../library/asyncio-eventloop.rst:1039
msgid "*pipe* is a :term:`file-like object <file object>`."
msgstr ""
"*pipe* には :term:`file-like オブジェクト <file object>` を指定します。"

#: ../../library/asyncio-eventloop.rst:1041
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports the :class:"
"`ReadTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"``(transport, protocol)`` のペアを返します。ここで *transport* は :class:"
"`ReadTransport` のインターフェースをサポートし、 *protocol* は "
"*protocol_factory* ファクトリでインスタンス化されたオブジェクトです。"

#: ../../library/asyncio-eventloop.rst:1045
#: ../../library/asyncio-eventloop.rst:1061
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ""
":class:`SelectorEventLoop` イベントループの場合、*pipe* は非ブロックモードに"
"設定されていなければなりません。"

#: ../../library/asyncio-eventloop.rst:1050
msgid "Register the write end of *pipe* in the event loop."
msgstr "*pipe* の書き込み側終端をイベントループに登録します。"

#: ../../library/asyncio-eventloop.rst:1055
msgid "*pipe* is :term:`file-like object <file object>`."
msgstr "*pipe* は :term:`file-like オブジェクト <file object>` です。"

#: ../../library/asyncio-eventloop.rst:1057
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports :class:"
"`WriteTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"``(transport, protocol)`` のペアを返します。ここで *transport* は :class:"
"`WriteTransport` のインスタンスであり、 *protocol* は *protocol_factory* ファ"
"クトリでインスタンス化されたオブジェクトです。"

#: ../../library/asyncio-eventloop.rst:1066
msgid ""
":class:`SelectorEventLoop` does not support the above methods on Windows.  "
"Use :class:`ProactorEventLoop` instead for Windows."
msgstr ""
":class:`SelectorEventLoop` は Windows 上で上記のメソッドをサポートしていませ"
"ん。 Windowsでは代わりに :class:`ProactorEventLoop` を使ってください。"

#: ../../library/asyncio-eventloop.rst:1071
msgid ""
"The :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` methods."
msgstr ""
":meth:`loop.subprocess_exec` および :meth:`loop.subprocess_shell` メソッド。"

#: ../../library/asyncio-eventloop.rst:1076
msgid "Unix signals"
msgstr "Unix シグナル"

#: ../../library/asyncio-eventloop.rst:1080
msgid "Set *callback* as the handler for the *signum* signal."
msgstr ""
"コールバック *callback* をシグナル *signum* に対するハンドラに設定します。"

#: ../../library/asyncio-eventloop.rst:1082
msgid ""
"The callback will be invoked by *loop*, along with other queued callbacks "
"and runnable coroutines of that event loop. Unlike signal handlers "
"registered using :func:`signal.signal`, a callback registered with this "
"function is allowed to interact with the event loop."
msgstr ""
"コールバックは *loop*、登録された他のコールバック、およびイベントループの実行"
"可能なコルーチンから呼び出されます。 :func:`signal.signal` を使って登録された"
"シグナルハンドラと異なり、この関数で登録されたコールバックはイベントループと"
"相互作用することが可能です。"

#: ../../library/asyncio-eventloop.rst:1087
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"シグナルナンバーが誤っているか捕捉不可能な場合 :exc:`ValueError` が送出されま"
"す。ハンドラーの設定に問題があった場合 :exc:`RuntimeError` が送出されます。"

#: ../../library/asyncio-eventloop.rst:1093
msgid ""
"Like :func:`signal.signal`, this function must be invoked in the main thread."
msgstr ""
":func:`signal.signal` と同じく、この関数はメインスレッドから呼び出されなけれ"
"ばなりません。"

#: ../../library/asyncio-eventloop.rst:1098
msgid "Remove the handler for the *sig* signal."
msgstr "シグナル *sig* に対するハンドラを削除します。"

#: ../../library/asyncio-eventloop.rst:1100
msgid ""
"Return ``True`` if the signal handler was removed, or ``False`` if no "
"handler was set for the given signal."
msgstr ""
"シグナルハンドラが削除された場合 ``True`` を返します。シグナルに対してハンド"
"ラが設定されていない場合には ``False`` を返します。"

#: ../../library/asyncio-eventloop.rst:1107
msgid "The :mod:`signal` module."
msgstr ":mod:`signal` モジュール。"

#: ../../library/asyncio-eventloop.rst:1111
msgid "Executing code in thread or process pools"
msgstr "スレッドまたはプロセスプールでコードを実行する"

#: ../../library/asyncio-eventloop.rst:1115
msgid "Arrange for *func* to be called in the specified executor."
msgstr "指定したエグゼキュータで関数 *func* が実行されるように準備します。"

#: ../../library/asyncio-eventloop.rst:1117
msgid ""
"The *executor* argument should be an :class:`concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``."
msgstr ""
"引数 *executor* は :class:`concurrent.futures.Executor` のインスタンスでなけ"
"ればなりません。 *executor* が ``None`` の場合はデフォルトのエグゼキュータが"
"使われます。"

#: ../../library/asyncio-eventloop.rst:1162
msgid ""
"Note that the entry point guard (``if __name__ == '__main__'``) is required "
"for option 3 due to the peculiarities of :mod:`multiprocessing`, which is "
"used by :class:`~concurrent.futures.ProcessPoolExecutor`. See :ref:`Safe "
"importing of main module <multiprocessing-safe-main-import>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1167
msgid "This method returns a :class:`asyncio.Future` object."
msgstr "このメソッドは :class:`asyncio.Future` オブジェクトを返します。"

#: ../../library/asyncio-eventloop.rst:1169
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *func*."
msgstr ""
"関数 *func* に :ref:`キーワード引数を渡す <asyncio-pass-keywords>` 場合は :"
"func:`functools.partial` を使ってください。"

#: ../../library/asyncio-eventloop.rst:1172
msgid ""
":meth:`loop.run_in_executor` no longer configures the ``max_workers`` of the "
"thread pool executor it creates, instead leaving it up to the thread pool "
"executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set the "
"default."
msgstr ""
":meth:`loop.run_in_executor` は内部で生成するスレッドプールエグゼキュータの "
"``max_workers`` を設定せず、代わりにスレッドプールエグゼキュータ (:class:"
"`~concurrent.futures.ThreadPoolExecutor`) にデフォルト値を設定させるようにな"
"りました。"

#: ../../library/asyncio-eventloop.rst:1181
msgid ""
"Set *executor* as the default executor used by :meth:`run_in_executor`. "
"*executor* should be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""
"*executor* を :meth:`run_in_executor` が使うデフォルトのエグゼキュータに設定"
"します。 *executor* は :class:`~concurrent.futures.ThreadPoolExecutor` のイン"
"スタンスでなければなりません。"

#: ../../library/asyncio-eventloop.rst:1185
msgid ""
"Using an executor that is not an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor` is deprecated and will trigger an error in Python 3.9."
msgstr ""
":class:`~concurrent.futures.ThreadPoolExecutor` のインスタンスでないエグゼ"
"キュータの使用は非推奨となり、 Python 3.9 ではエラーになります。"

#: ../../library/asyncio-eventloop.rst:1190
msgid ""
"*executor* must be an instance of :class:`concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""
"*executor* は :class:`concurrent.futures.ThreadPoolExecutor` のインスタンスで"
"なければなりません。"

#: ../../library/asyncio-eventloop.rst:1195
msgid "Error Handling API"
msgstr "エラーハンドリング API"

#: ../../library/asyncio-eventloop.rst:1197
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr "イベントループ内での例外の扱い方をカスタマイズできます。"

#: ../../library/asyncio-eventloop.rst:1201
msgid "Set *handler* as the new event loop exception handler."
msgstr "*handler* を新しいイベントループ例外ハンドラーとして設定します。"

#: ../../library/asyncio-eventloop.rst:1203
msgid ""
"If *handler* is ``None``, the default exception handler will be set.  "
"Otherwise, *handler* must be a callable with the signature matching ``(loop, "
"context)``, where ``loop`` is a reference to the active event loop, and "
"``context`` is a ``dict`` object containing the details of the exception "
"(see :meth:`call_exception_handler` documentation for details about context)."
msgstr ""
"*handler* が ``None`` の場合、デフォルトの例外ハンドラが設定されます。そうで"
"なければ、 *handler* は ``(loop, context)`` に一致する関数シグネチャを持った"
"呼び出し可能オブジェクトでなければなりません。ここで ``loop`` はアクティブな"
"イベントループへの参照であり、 ``context`` は例外の詳細な記述からなる "
"``dict`` オブジェクトです (*context* についての詳細は :meth:"
"`call_exception_handler` メソッドのドキュメントを参照してください)。"

#: ../../library/asyncio-eventloop.rst:1213
msgid ""
"Return the current exception handler, or ``None`` if no custom exception "
"handler was set."
msgstr ""
"現在の例外ハンドラを返します。カスタム例外ハンドラが設定されていない場合は "
"``None`` を返します。"

#: ../../library/asyncio-eventloop.rst:1220
msgid "Default exception handler."
msgstr "デフォルトの例外ハンドラーです。"

#: ../../library/asyncio-eventloop.rst:1222
msgid ""
"This is called when an exception occurs and no exception handler is set. "
"This can be called by a custom exception handler that wants to defer to the "
"default handler behavior."
msgstr ""
"デフォルト例外ハンドラは、例外ハンドラが未設定の場合、例外が発生した時に呼び"
"出されます。デフォルト例外ハンドラの挙動を受け入れるために、カスタム例外ハン"
"ドラから呼び出すことも可能です。"

#: ../../library/asyncio-eventloop.rst:1226
msgid ""
"*context* parameter has the same meaning as in :meth:"
"`call_exception_handler`."
msgstr "引数 *context* の意味は :meth:`call_exception_handler` と同じです。"

#: ../../library/asyncio-eventloop.rst:1231
msgid "Call the current event loop exception handler."
msgstr "現在のイベントループ例外ハンドラーを呼び出します。"

#: ../../library/asyncio-eventloop.rst:1233
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced in future Python versions):"
msgstr ""
"*context* は以下のキーを含む ``dict`` オブジェクトです (将来の Python バー"
"ジョンで新しいキーが追加される可能性があります):"

#: ../../library/asyncio-eventloop.rst:1236
msgid "'message': Error message;"
msgstr "'message': エラーメッセージ;"

#: ../../library/asyncio-eventloop.rst:1237
msgid "'exception' (optional): Exception object;"
msgstr "'exception' (任意): 例外オブジェクト;"

#: ../../library/asyncio-eventloop.rst:1238
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "'future' (任意): :class:`asyncio.Future` インスタンス;"

#: ../../library/asyncio-eventloop.rst:1239
msgid "'task' (optional): :class:`asyncio.Task` instance;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1240
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "'handle' (任意): :class:`asyncio.Handle` インスタンス;"

#: ../../library/asyncio-eventloop.rst:1241
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr "'protocol' (任意): :ref:`プロトコル <asyncio-protocol>` インスタンス;"

#: ../../library/asyncio-eventloop.rst:1242
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr ""
"'transport' (任意): :ref:`トランスポート <asyncio-transport>` インスタンス;"

#: ../../library/asyncio-eventloop.rst:1243
msgid "'socket' (optional): :class:`socket.socket` instance;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1245
msgid "'asyncgen' (optional): Asynchronous generator that caused"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1245
msgid "the exception."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1249
msgid ""
"This method should not be overloaded in subclassed event loops.  For custom "
"exception handling, use the :meth:`set_exception_handler()` method."
msgstr ""
"このメソッドはイベントループの派生クラスでオーバーロードされてはいけません。"
"カスタム例外ハンドラの設定には :meth:`set_exception_handler()` メソッドを使っ"
"てください。"

#: ../../library/asyncio-eventloop.rst:1254
msgid "Enabling debug mode"
msgstr "デバッグモードの有効化"

#: ../../library/asyncio-eventloop.rst:1258
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "イベントループのデバッグモード (:class:`bool`) を取得します。"

#: ../../library/asyncio-eventloop.rst:1260
msgid ""
"The default value is ``True`` if the environment variable :envvar:"
"`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` otherwise."
msgstr ""
"環境変数 :envvar:`PYTHONASYNCIODEBUG` に空でない文字列が設定されている場合の"
"デフォルト値は ``True``、そうでない場合は ``False`` になります。"

#: ../../library/asyncio-eventloop.rst:1266
msgid "Set the debug mode of the event loop."
msgstr "イベントループのデバッグモードを設定します。"

#: ../../library/asyncio-eventloop.rst:1270
msgid ""
"The new :ref:`Python Development Mode <devmode>` can now also be used to "
"enable the debug mode."
msgstr ""
"新しい :ref:`Python 開発モード <devmode>` を使ってデバッグモードを有効化する"
"ことができるようになりました。"

#: ../../library/asyncio-eventloop.rst:1275
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ":ref:`asyncio のデバッグモード <asyncio-debug-mode>`。"

#: ../../library/asyncio-eventloop.rst:1279
msgid "Running Subprocesses"
msgstr "サブプロセスの実行"

#: ../../library/asyncio-eventloop.rst:1281
msgid ""
"Methods described in this subsections are low-level.  In regular async/await "
"code consider using the high-level :func:`asyncio.create_subprocess_shell` "
"and :func:`asyncio.create_subprocess_exec` convenience functions instead."
msgstr ""
"この節で解説しているのは低水準のメソッドです。通常の async/await コードでは、"
"高水準の関数である :func:`asyncio.create_subprocess_shell` や :func:`asyncio."
"create_subprocess_exec` を代わりに使うことを検討してください。"

#: ../../library/asyncio-eventloop.rst:1288
msgid ""
"On Windows, the default event loop :class:`ProactorEventLoop` supports "
"subprocesses, whereas :class:`SelectorEventLoop` does not. See :ref:"
"`Subprocess Support on Windows <asyncio-windows-subprocess>` for details."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1297
msgid ""
"Create a subprocess from one or more string arguments specified by *args*."
msgstr ""
"*args* で指定されたひとつの、または複数の文字列引数からサブプロセスを生成しま"
"す。"

#: ../../library/asyncio-eventloop.rst:1300
msgid "*args* must be a list of strings represented by:"
msgstr "*args* は下記のいずれかに当てはまる文字列のリストでなければなりません:"

#: ../../library/asyncio-eventloop.rst:1302
msgid ":class:`str`;"
msgstr ":class:`str`;"

#: ../../library/asyncio-eventloop.rst:1303
msgid ""
"or :class:`bytes`, encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`."
msgstr ""
"または :ref:`ファイルシステムのエンコーディング <filesystem-encoding>` にエン"
"コードされた :class:`bytes`"

#: ../../library/asyncio-eventloop.rst:1306
msgid ""
"The first string specifies the program executable, and the remaining strings "
"specify the arguments.  Together, string arguments form the ``argv`` of the "
"program."
msgstr ""
"引数の最初の文字列はプログラムの実行ファイルを指定します。それに続く残りの文"
"字列は引数を指定し、そのプログラムに対する ``argv`` を構成します。"

#: ../../library/asyncio-eventloop.rst:1310
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=False`` and the list of strings passed as the first "
"argument; however, where :class:`~subprocess.Popen` takes a single argument "
"which is list of strings, *subprocess_exec* takes multiple string arguments."
msgstr ""
"このメソッドは標準ライブラリの :class:`subprocess.Popen` クラスを、 "
"``shell=False`` かつ最初の引数に文字列のリストを渡して呼び出した場合に似てい"
"ます。しかし、 :class:`~subprocess.Popen` クラスは文字列のリストを引数として"
"ひとつだけ取るのに対して、 *subprocess_exec* は複数の文字列引数をとることがで"
"きます。"

#: ../../library/asyncio-eventloop.rst:1316
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`asyncio.SubprocessProtocol` class."
msgstr ""
"*protocol_factory* は :class:`asyncio.SubprocessProtocol` クラスの派生クラス"
"を返す呼び出し可能オブジェクトでなければなりません。"

#: ../../library/asyncio-eventloop.rst:1319
msgid "Other parameters:"
msgstr "その他の引数:"

#: ../../library/asyncio-eventloop.rst:1321
msgid "*stdin* can be any of these:"
msgstr "*stdin* 下記のいずれかをとることができます:"

#: ../../library/asyncio-eventloop.rst:1323
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard input stream using :meth:`~loop.connect_write_pipe`"
msgstr ""
":meth:`~loop.connect_write_pipe` メソッドを使ってサブプロセスの標準入力スト"
"リームに接続されたパイプを表す file-like オブジェクト"

#: ../../library/asyncio-eventloop.rst:1326
#: ../../library/asyncio-eventloop.rst:1338
#: ../../library/asyncio-eventloop.rst:1350
msgid ""
"the :const:`subprocess.PIPE` constant (default) which will create a new pipe "
"and connect it,"
msgstr ""
"デフォルト値は :const:`subprocess.PIPE` 定数で、この場合新規にパイプを生成し"
"て接続します。"

#: ../../library/asyncio-eventloop.rst:1328
#: ../../library/asyncio-eventloop.rst:1340
#: ../../library/asyncio-eventloop.rst:1352
msgid ""
"the value ``None`` which will make the subprocess inherit the file "
"descriptor from this process"
msgstr ""
"``None`` が設定された場合、サブプロセスは元のプロセスのファイルデスクリプタを"
"引き継ぎます。"

#: ../../library/asyncio-eventloop.rst:1330
#: ../../library/asyncio-eventloop.rst:1342
#: ../../library/asyncio-eventloop.rst:1354
msgid ""
"the :const:`subprocess.DEVNULL` constant which indicates that the special :"
"data:`os.devnull` file will be used"
msgstr ""
":const:`subprocess.DEVNULL` 定数を設定すると、特別なファイル :data:`os."
"devnull` を使います。"

#: ../../library/asyncio-eventloop.rst:1333
msgid "*stdout* can be any of these:"
msgstr "*stdout* は下記のいずれかをとることができます:"

#: ../../library/asyncio-eventloop.rst:1335
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard output stream using :meth:`~loop.connect_write_pipe`"
msgstr ""
":meth:`~loop.connect_write_pipe` メソッドを使ってサブプロセスの標準出力スト"
"リームに接続されたパイプを表す file-like オブジェクト"

#: ../../library/asyncio-eventloop.rst:1345
msgid "*stderr* can be any of these:"
msgstr "*stderr* は下記のいずれかをとることができます:"

#: ../../library/asyncio-eventloop.rst:1347
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard error stream using :meth:`~loop.connect_write_pipe`"
msgstr ""
":meth:`~loop.connect_write_pipe` メソッドを使ってサブプロセスの標準エラー出力"
"ストリームに接続されたパイプを表す file-like オブジェクト"

#: ../../library/asyncio-eventloop.rst:1356
msgid ""
"the :const:`subprocess.STDOUT` constant which will connect the standard "
"error stream to the process' standard output stream"
msgstr ""
":const:`subprocess.STDOUT` 定数を設定すると、標準エラー出力ストリームをプロセ"
"スの標準出力ストリームに接続します。"

#: ../../library/asyncio-eventloop.rst:1359
msgid ""
"All other keyword arguments are passed to :class:`subprocess.Popen` without "
"interpretation, except for *bufsize*, *universal_newlines*, *shell*, *text*, "
"*encoding* and *errors*, which should not be specified at all."
msgstr ""
"その他のすべてのキーワード引数は解釈されずにそのまま :class:`subprocess."
"Popen` に渡されます。ただし、 *bufsize*、 *universal_newlines*、 *shell*、 "
"*text*、 *encoding* および *errors* は指定してはいけません。"

#: ../../library/asyncio-eventloop.rst:1364
msgid ""
"The ``asyncio`` subprocess API does not support decoding the streams as "
"text. :func:`bytes.decode` can be used to convert the bytes returned from "
"the stream to text."
msgstr ""
"``asyncio`` のサブプロセス API はストリームからテキストへのデコードをサポ0と"
"していません。ストリームからテキストに変換するには :func:`bytes.decode` 関数"
"を使ってください。"

#: ../../library/asyncio-eventloop.rst:1368
msgid ""
"See the constructor of the :class:`subprocess.Popen` class for documentation "
"on other arguments."
msgstr ""
"他の引数についての詳細は :class:`subprocess.Popen` クラスのコンストラクタを参"
"照してください。"

#: ../../library/asyncio-eventloop.rst:1371
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`asyncio.SubprocessTransport` base class and *protocol* is an "
"object instantiated by the *protocol_factory*."
msgstr ""
"``(transport, protocol)`` のペアを返します。ここで *transport* は :class:"
"`asyncio.SubprocessTransport` 基底クラスに適合するオブジェクトで、 "
"*protocol* は *protocol_factory* によりインスタンス化されたオブジェクトです。"

#: ../../library/asyncio-eventloop.rst:1379
msgid ""
"Create a subprocess from *cmd*, which can be a :class:`str` or a :class:"
"`bytes` string encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`, using the platform's \"shell\" syntax."
msgstr ""
"コマンド *cmd* からプラットフォームの \"シェル\" シンタックスを使ってサブプロ"
"セスを生成します。 *cmd* は :class:`str` 文字列もしくは :ref:`ファイルシステ"
"ムのエンコーディング <filesystem-encoding>` でエンコードされた :class:"
"`bytes` 文字列です。"

#: ../../library/asyncio-eventloop.rst:1384
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=True``."
msgstr ""
"これは標準ライブラリの :class:`subprocess.Popen` クラスを ``shell=True`` で呼"
"び出した場合と似ています。"

#: ../../library/asyncio-eventloop.rst:1387
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`SubprocessProtocol` class."
msgstr ""
"*protocol_factory* は :class:`SubprocessProtocol` の派生クラスを返す呼び出し"
"可能オブジェクトでなければなりません。"

#: ../../library/asyncio-eventloop.rst:1390
msgid ""
"See :meth:`~loop.subprocess_exec` for more details about the remaining "
"arguments."
msgstr ""
"その他の引数についての詳細は :meth:`~loop.subprocess_exec` メソッドを参照して"
"ください。"

#: ../../library/asyncio-eventloop.rst:1393
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`SubprocessTransport` base class and *protocol* is an object "
"instantiated by the *protocol_factory*."
msgstr ""
"``(transport, protocol)``のペアを返します。ここで *transport* は :class:"
"`SubprocessTransport` 基底クラスに適合するオブジェクトで、 *protocol* は "
"*protocol_factory* によりインスタンス化されたオブジェクトです。"

#: ../../library/asyncio-eventloop.rst:1398
msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly "
"escape whitespace and special characters in strings that are going to be "
"used to construct shell commands."
msgstr ""
"`シェルインジェクション <https://en.wikipedia.org/wiki/"
"Shell_injection#Shell_injection>`_ の脆弱性を回避するために全ての空白文字およ"
"び特殊文字を適切にクオートすることは、アプリケーション側の責任で確実に行って"
"ください。シェルコマンドを構成する文字列内の空白文字と特殊文字のエスケープ"
"は、 :func:`shlex.quote` 関数を使うと適切に行うことができます。"

#: ../../library/asyncio-eventloop.rst:1407
msgid "Callback Handles"
msgstr "コールバックのハンドル"

#: ../../library/asyncio-eventloop.rst:1411
msgid ""
"A callback wrapper object returned by :meth:`loop.call_soon`, :meth:`loop."
"call_soon_threadsafe`."
msgstr ""
":meth:`loop.call_soon` や :meth:`loop.call_soon_threadsafe` が返すコールバッ"
"クのラッパーです。"

#: ../../library/asyncio-eventloop.rst:1416
msgid ""
"Cancel the callback.  If the callback has already been canceled or executed, "
"this method has no effect."
msgstr ""
"コールバックをキャンセルします。コールバックがキャンセル済みまたは実行済みの"
"場合、このメソッドは何の影響もありません。"

#: ../../library/asyncio-eventloop.rst:1421
msgid "Return ``True`` if the callback was cancelled."
msgstr "コールバックがキャンセルされた場合 ``True`` を返します。"

#: ../../library/asyncio-eventloop.rst:1427
msgid ""
"A callback wrapper object returned by :meth:`loop.call_later`, and :meth:"
"`loop.call_at`."
msgstr ""
" :meth:`loop.call_later` や :meth:`loop.call_at` が返すコールバックのラッパー"
"オブジェクトです。"

#: ../../library/asyncio-eventloop.rst:1430
msgid "This class is a subclass of :class:`Handle`."
msgstr "このクラスは :class:`Handle` の派生クラスです。"

#: ../../library/asyncio-eventloop.rst:1434
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr "コールバックのスケジュール時刻を秒単位の :class:`float` で返します。"

#: ../../library/asyncio-eventloop.rst:1436
msgid ""
"The time is an absolute timestamp, using the same time reference as :meth:"
"`loop.time`."
msgstr ""
"戻り値の時刻は絶対値で、 :meth:`loop.time` と同じ参照時刻を使って定義されてい"
"ます。"

#: ../../library/asyncio-eventloop.rst:1443
msgid "Server Objects"
msgstr "Serverオブジェクト"

#: ../../library/asyncio-eventloop.rst:1445
msgid ""
"Server objects are created by :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :func:`start_server`, and :func:`start_unix_server` "
"functions."
msgstr ""
"Server オブジェクトは :meth:`loop.create_server`、 :meth:`loop."
"create_unix_server`、 :func:`start_server` および :func:`start_unix_server` "
"関数により生成されます。"

#: ../../library/asyncio-eventloop.rst:1449
msgid "Do not instantiate the class directly."
msgstr "クラスを直接インスタンス化しないでください。"

#: ../../library/asyncio-eventloop.rst:1453
msgid ""
"*Server* objects are asynchronous context managers.  When used in an ``async "
"with`` statement, it's guaranteed that the Server object is closed and not "
"accepting new connections when the ``async with`` statement is completed::"
msgstr ""
"*Server* オブジェクトは非同期のコンテキストマネージャです。 ``async with`` 文"
"の中で使われた場合、 ``async with`` 文が完了した時に Server オブジェクトがク"
"ローズされること、およびそれ以降に接続を受け付けないことが保証されます。"

#: ../../library/asyncio-eventloop.rst:1466
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr ""
"Python 3.7 から、 Server オブジェクトは非同期のコンテキストマネージャになりま"
"した。"

#: ../../library/asyncio-eventloop.rst:1471
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr ""
"サーバーを停止します: 待機しているソケットをクローズし :attr:`sockets` 属性"
"に ``None`` を設定します。"

#: ../../library/asyncio-eventloop.rst:1474
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr "既存の受信中のクライアントとの接続を表すソケットはオープンのままです。"

#: ../../library/asyncio-eventloop.rst:1477
msgid ""
"The server is closed asynchronously, use the :meth:`wait_closed` coroutine "
"to wait until the server is closed."
msgstr ""
"サーバーは非同期に停止されます。サーバーの停止を待ちたい場合は :meth:"
"`wait_closed` コルーチンを使用します。"

#: ../../library/asyncio-eventloop.rst:1482
msgid "Return the event loop associated with the server object."
msgstr "サーバオブジェクトに付随するイベントループを返します。"

#: ../../library/asyncio-eventloop.rst:1488
msgid "Start accepting connections."
msgstr "接続の受け付けを開始します。"

#: ../../library/asyncio-eventloop.rst:1490
msgid ""
"This method is idempotent, so it can be called when the server is already "
"being serving."
msgstr ""
"このメソッドはべき等です。すなわちサーバがすでにサービスを開始した後でも呼び"
"出すことができます。"

#: ../../library/asyncio-eventloop.rst:1493
msgid ""
"The *start_serving* keyword-only parameter to :meth:`loop.create_server` "
"and :meth:`asyncio.start_server` allows creating a Server object that is not "
"accepting connections initially.  In this case ``Server.start_serving()``, "
"or :meth:`Server.serve_forever` can be used to make the Server start "
"accepting connections."
msgstr ""
"キーワード専用のパラメータ *start_serving* を :meth:`loop.create_server` や :"
"meth:`asyncio.start_server` メソッドに対して使用することにより、初期に接続を"
"受け付けない Server オブジェクトを生成することができます。この場合 ``Server."
"start_serving()`` または :meth:`Server.serve_forever` メソッドを使ってオブ"
"ジェクトが接続の受け付けを開始するようにすることができます。"

#: ../../library/asyncio-eventloop.rst:1504
msgid ""
"Start accepting connections until the coroutine is cancelled. Cancellation "
"of ``serve_forever`` task causes the server to be closed."
msgstr ""
"接続の受け入れを開始し、コルーチンがキャンセルされるまで継続します。 "
"``serve_forever`` タスクのキャンセルによりサーバーもクローズされます。 "

#: ../../library/asyncio-eventloop.rst:1508
msgid ""
"This method can be called if the server is already accepting connections.  "
"Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""
"このメソッドはサーバーがすでに接続の受け入れを開始していても呼び出し可能で"
"す。ひとつの *Server* オブジェクトにつき ``serve_forever`` タスクはひとつだけ"
"存在できます。"

#: ../../library/asyncio-eventloop.rst:1530
msgid "Return ``True`` if the server is accepting new connections."
msgstr "サーバーが新規に接続の受け入れを開始した場合 ``True`` を返します。"

#: ../../library/asyncio-eventloop.rst:1536
msgid "Wait until the :meth:`close` method completes."
msgstr ":meth:`close` メソッドが完了するまで待ちます。"

#: ../../library/asyncio-eventloop.rst:1540
msgid "List of :class:`socket.socket` objects the server is listening on."
msgstr ""
"サーバーがリッスンしている :class:`socket.socket` オブジェクトのリストです。 "

#: ../../library/asyncio-eventloop.rst:1542
msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return an internal list of "
"server sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""
"Python 3.7 より前のバージョンでは、 ``Server.sockets`` は内部に持っているサー"
"バーソケットのリストを直接返していました。 Python 3.7 ではリストのコピーが返"
"されるようになりました。"

#: ../../library/asyncio-eventloop.rst:1552
msgid "Event Loop Implementations"
msgstr "イベントループの実装"

#: ../../library/asyncio-eventloop.rst:1554
msgid ""
"asyncio ships with two different event loop implementations: :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr ""
"asyncio は2つの異なるイベントループの実装、 class:`SelectorEventLoop` と :"
"class:`ProactorEventLoop`、 を提供します: "

#: ../../library/asyncio-eventloop.rst:1557
msgid ""
"By default asyncio is configured to use :class:`SelectorEventLoop` on Unix "
"and :class:`ProactorEventLoop` on Windows."
msgstr ""
"デフォルトでは、 asyncio は Unix では :class:`SelectorEventLoop` 、 Windows "
"では :class:`ProactorEventLoop` 、をそれぞれ使うように構成されています。"

#: ../../library/asyncio-eventloop.rst:1563
msgid "An event loop based on the :mod:`selectors` module."
msgstr ":mod:`selectors` に基づくイベントループです。"

#: ../../library/asyncio-eventloop.rst:1565
msgid ""
"Uses the most efficient *selector* available for the given platform.  It is "
"also possible to manually configure the exact selector implementation to be "
"used::"
msgstr ""
"プラットフォーム上で利用可能な最も効率の良い *selector* を使います。特定のセ"
"レクタ実装を使うように手動で構成することも可能です::"

#: ../../library/asyncio-eventloop.rst:1580
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Availability <availability>`: Unix, Windows。"

#: ../../library/asyncio-eventloop.rst:1585
msgid "An event loop for Windows that uses \"I/O Completion Ports\" (IOCP)."
msgstr "\"I/O 完了ポート\" (IOCP) を使った Windows 向けのイベントループです。"

#: ../../library/asyncio-eventloop.rst:1588
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`利用可能な環境 <availability>`: Windows 。"

#: ../../library/asyncio-eventloop.rst:1591
msgid ""
"`MSDN documentation on I/O Completion Ports <https://docs.microsoft.com/en-"
"ca/windows/desktop/FileIO/i-o-completion-ports>`_."
msgstr ""
"`I/O 完了ポートに関する MSDN のドキュメント <https://docs.microsoft.com/en-"
"ca/windows/desktop/FileIO/i-o-completion-ports>`_."

#: ../../library/asyncio-eventloop.rst:1597
msgid "Abstract base class for asyncio-compliant event loops."
msgstr "asyncio に適合するイベントループの抽象基底クラスです。"

#: ../../library/asyncio-eventloop.rst:1599
msgid ""
"The :ref:`asyncio-event-loop-methods` section lists all methods that an "
"alternative implementation of ``AbstractEventLoop`` should have defined."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1605
msgid "Examples"
msgstr "使用例"

#: ../../library/asyncio-eventloop.rst:1607
msgid ""
"Note that all examples in this section **purposefully** show how to use the "
"low-level event loop APIs, such as :meth:`loop.run_forever` and :meth:`loop."
"call_soon`.  Modern asyncio applications rarely need to be written this way; "
"consider using the high-level functions like :func:`asyncio.run`."
msgstr ""
"この節の全ての使用例は **意図的に**  :meth:`loop.run_forever` や :meth:`loop."
"call_soon` のような 低水準のイベントループ API の使用法を示しています。一方で"
"現代的な asyncio アプリケーションはここに示すような方法をほとんど必要としませ"
"ん。 :func:`asyncio.run` のような高水準の関数の使用を検討してください。"

#: ../../library/asyncio-eventloop.rst:1617
msgid "Hello World with call_soon()"
msgstr "call_soon() を使った Hello World"

#: ../../library/asyncio-eventloop.rst:1619
msgid ""
"An example using the :meth:`loop.call_soon` method to schedule a callback. "
"The callback displays ``\"Hello World\"`` and then stops the event loop::"
msgstr ""
":meth:`loop.call_soon` メソッドを使ってコールバックをスケジュールする例です。"
"コールバックは ``\"Hello World\"`` を出力しイベントループを停止します::"

#: ../../library/asyncio-eventloop.rst:1643
msgid ""
"A similar :ref:`Hello World <coroutine>` example created with a coroutine "
"and the :func:`run` function."
msgstr ""
"コルーチンと :func:`run` 関数を使用した同じような :ref:`Hello World "
"<coroutine>` の例。"

#: ../../library/asyncio-eventloop.rst:1650
msgid "Display the current date with call_later()"
msgstr "call_later() で現在の日時を表示する"

#: ../../library/asyncio-eventloop.rst:1652
msgid ""
"An example of a callback displaying the current date every second. The "
"callback uses the :meth:`loop.call_later` method to reschedule itself after "
"5 seconds, and then stops the event loop::"
msgstr ""
"毎秒現在時刻を表示するコールバックの例です。コールバックは :meth:`loop."
"call_later` メソッドを使って自身を5秒後に実行するよう再スケジュールし、イベン"
"トループを停止します::"

#: ../../library/asyncio-eventloop.rst:1680
msgid ""
"A similar :ref:`current date <asyncio_example_sleep>` example created with a "
"coroutine and the :func:`run` function."
msgstr ""
"コルーチンと :func:`run` 関数を使用した同じような :ref:`現在時刻出力 "
"<asyncio_example_sleep>` の例。"

#: ../../library/asyncio-eventloop.rst:1687
msgid "Watch a file descriptor for read events"
msgstr "読み込みイベント用ファイル記述子の監視"

#: ../../library/asyncio-eventloop.rst:1689
msgid ""
"Wait until a file descriptor received some data using the :meth:`loop."
"add_reader` method and then close the event loop::"
msgstr ""
"ファイル記述子が :meth:`loop.add_reader` メソッドを使って何らかのデータを受信"
"するまで待機し、その後イベントループをクローズします::"

#: ../../library/asyncio-eventloop.rst:1727
msgid ""
"A similar :ref:`example <asyncio_example_create_connection>` using "
"transports, protocols, and the :meth:`loop.create_connection` method."
msgstr ""
"トランスポート、プロトコル、および :meth:`loop.create_connection` メソッドを"
"使用した同じような :ref:`例 <asyncio_example_create_connection>`。 "

#: ../../library/asyncio-eventloop.rst:1731
msgid ""
"Another similar :ref:`example <asyncio_example_create_connection-streams>` "
"using the high-level :func:`asyncio.open_connection` function and streams."
msgstr ""
"高水準の :func:`asyncio.open_connection` 関数とストリームを使用したもうひとつ"
"の :ref:`実装例 <asyncio_example_create_connection-streams>`。"

#: ../../library/asyncio-eventloop.rst:1739
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "SIGINT および SIGTERM 用のシグナルハンドラーの設定"

#: ../../library/asyncio-eventloop.rst:1741
msgid "(This ``signals`` example only works on Unix.)"
msgstr "(ここに挙げる ``signals`` の例は Unix でのみ動きます。)"

#: ../../library/asyncio-eventloop.rst:1743
msgid ""
"Register handlers for signals :py:data:`SIGINT` and :py:data:`SIGTERM` using "
"the :meth:`loop.add_signal_handler` method::"
msgstr ""
":meth:`loop.add_signal_handler` メソッドを使用して :py:data:`SIGINT` と :py:"
"data:`SIGTERM` の2つのシグナルに対するハンドラを登録します::"
