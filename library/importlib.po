# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Arihiro TAKASE, 2023
# tomo, 2023
# 石井明久, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-04 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:08+0000\n"
"Last-Translator: 石井明久, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/importlib.rst:2
msgid ":mod:`!importlib` --- The implementation of :keyword:`!import`"
msgstr ":mod:`!importlib` --- :keyword:`!import` の実装"

#: ../../library/importlib.rst:12
msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**ソースコード:** :source:`Lib/importlib/__init__.py`"

#: ../../library/importlib.rst:18
msgid "Introduction"
msgstr "はじめに"

#: ../../library/importlib.rst:20
msgid "The purpose of the :mod:`importlib` package is three-fold."
msgstr ":mod:`importlib` パッケージの目的は3つあります。"

#: ../../library/importlib.rst:22
msgid ""
"One is to provide the implementation of the :keyword:`import` statement (and "
"thus, by extension, the :func:`__import__` function) in Python source code. "
"This provides an implementation of :keyword:`!import` which is portable to "
"any Python interpreter. This also provides an implementation which is easier "
"to comprehend than one implemented in a programming language other than "
"Python."
msgstr ""
"1つ目は Python ソースコード中にある :keyword:`import` 文の(そして、拡張とし"
"て、 :func:`__import__` 関数の)実装を提供することです。このパッケージは :"
"keyword:`!import` 文の、どの Python インタープリターでも動作する実装を提供し"
"ます。また、 Python 以外の言語で実装されたどの実装よりも把握しやすい実装を提"
"供します。"

#: ../../library/importlib.rst:29
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"2つ目の目的は、このパッケージが公開している :keyword:`import` を実装するため"
"の要素を利用して、(:term:`インポーター <importer>` として知られる) インポート"
"プロセスで動作するカスタムのオブジェクトを実装しやすくすることです。"

#: ../../library/importlib.rst:33
msgid ""
"Three, the package contains modules exposing additional functionality for "
"managing aspects of Python packages:"
msgstr ""

#: ../../library/importlib.rst:36
msgid ""
":mod:`importlib.metadata` presents access to metadata from third-party "
"distributions."
msgstr ""

#: ../../library/importlib.rst:38
msgid ""
":mod:`importlib.resources` provides routines for accessing non-code "
"\"resources\" from Python packages."
msgstr ""

#: ../../library/importlib.rst:43
msgid ":ref:`import`"
msgstr ":ref:`import`"

#: ../../library/importlib.rst:44
msgid "The language reference for the :keyword:`import` statement."
msgstr ":keyword:`import` 文の言語リファレンス。"

#: ../../library/importlib.rst:46
msgid ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"

#: ../../library/importlib.rst:47
msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in :data:`sys."
"modules`)."
msgstr ""
"パッケージの元の仕様。幾つかの動作はこの仕様が書かれた頃から変更されています "
"(例: :data:`sys.modules` で ``None`` に基づくリダイレクト)。"

#: ../../library/importlib.rst:51
msgid "The :func:`.__import__` function"
msgstr ":func:`.__import__` 関数"

#: ../../library/importlib.rst:52
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr ":keyword:`import` 文はこの関数のシンタックスシュガーです。"

#: ../../library/importlib.rst:54
msgid ":ref:`sys-path-init`"
msgstr ""

#: ../../library/importlib.rst:55
msgid "The initialization of :data:`sys.path`."
msgstr ""

#: ../../library/importlib.rst:57
msgid ":pep:`235`"
msgstr ":pep:`235`"

#: ../../library/importlib.rst:58
msgid "Import on Case-Insensitive Platforms"
msgstr "大文字小文字を区別しないプラットフォームでのインポート"

#: ../../library/importlib.rst:60
msgid ":pep:`263`"
msgstr ":pep:`263`"

#: ../../library/importlib.rst:61
msgid "Defining Python Source Code Encodings"
msgstr "Python のソースコードのエンコーディング"

#: ../../library/importlib.rst:63
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../../library/importlib.rst:64
msgid "New Import Hooks"
msgstr "新しいインポートフック"

#: ../../library/importlib.rst:66
msgid ":pep:`328`"
msgstr ":pep:`328`"

#: ../../library/importlib.rst:67
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "複数行のインポートと、絶対/相対インポート"

#: ../../library/importlib.rst:69
msgid ":pep:`366`"
msgstr ":pep:`366`"

#: ../../library/importlib.rst:70
msgid "Main module explicit relative imports"
msgstr "main モジュールの明示的な相対インポート"

#: ../../library/importlib.rst:72
msgid ":pep:`420`"
msgstr ":pep:`420`"

#: ../../library/importlib.rst:73
msgid "Implicit namespace packages"
msgstr "暗黙的な名前空間パッケージ"

#: ../../library/importlib.rst:75
msgid ":pep:`451`"
msgstr ":pep:`451`"

#: ../../library/importlib.rst:76
msgid "A ModuleSpec Type for the Import System"
msgstr "インポートシステムのための ModuleSpec 型"

#: ../../library/importlib.rst:78
msgid ":pep:`488`"
msgstr ":pep:`488`"

#: ../../library/importlib.rst:79
msgid "Elimination of PYO files"
msgstr "PYO ファイルの撤廃"

#: ../../library/importlib.rst:81
msgid ":pep:`489`"
msgstr ":pep:`489`"

#: ../../library/importlib.rst:82
msgid "Multi-phase extension module initialization"
msgstr "複数フェーズでの拡張モジュールの初期化"

#: ../../library/importlib.rst:84
msgid ":pep:`552`"
msgstr ":pep:`552`"

#: ../../library/importlib.rst:85
msgid "Deterministic pycs"
msgstr "決定論的 pyc"

#: ../../library/importlib.rst:87
msgid ":pep:`3120`"
msgstr ":pep:`3120`"

#: ../../library/importlib.rst:88
msgid "Using UTF-8 as the Default Source Encoding"
msgstr "デフォルトのソースエンコーディングとして UTF-8 を使用"

#: ../../library/importlib.rst:90
msgid ":pep:`3147`"
msgstr ":pep:`3147`"

#: ../../library/importlib.rst:91
msgid "PYC Repository Directories"
msgstr "PYC リポジトリディレクトリ"

#: ../../library/importlib.rst:95
msgid "Functions"
msgstr "関数"

#: ../../library/importlib.rst:99
msgid "An implementation of the built-in :func:`__import__` function."
msgstr "組み込みの :func:`__import__` 関数の実装です。"

#: ../../library/importlib.rst:102
msgid ""
"Programmatic importing of modules should use :func:`import_module` instead "
"of this function."
msgstr ""
"プログラムからモジュールをインポートする場合はこの関数の代わりに :func:"
"`import_module` を使ってください。"

#: ../../library/importlib.rst:107
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set "
"to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""
"モジュールをインポートします。*name* 引数は、インポートするモジュールを絶対ま"
"たは相対表現 (例えば ``pkg.mod`` または ``..mod``) で指定します。name が相対"
"表現で与えられたら、*package* 引数を、パッケージ名を解決するためのアンカーと"
"なるパッケージの名前に設定する必要があります (例えば ``import_module('.."
"mod', 'pkg.subpkg')`` は ``pkg.mod`` をインポートします)。"

#: ../../library/importlib.rst:115
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around :"
"func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`. The most important difference "
"between these two functions is that :func:`import_module` returns the "
"specified package or module (e.g. ``pkg.mod``), while :func:`__import__` "
"returns the top-level package or module (e.g. ``pkg``)."
msgstr ""
":func:`import_module` 関数は :func:`importlib.__import__` を単純化するラッ"
"パーとして働きます。つまり、この関数のすべての意味は :func:`importlib."
"__import__` から受け継いでいます。これらの2つの関数の最も重要な違いは、 :"
"func:`import_module` が指定されたパッケージやモジュール (例えば ``pkg.mod``) "
"を返すのに対し、 :func:`__import__` はトップレベルのパッケージやモジュール "
"(例えば ``pkg``) を返すことです。"

#: ../../library/importlib.rst:122
msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may "
"need to call :func:`invalidate_caches` in order for the new module to be "
"noticed by the import system."
msgstr ""
"もしモジュールを動的にインポートしていて、インタープリタの実行開始後にモ"
"ジュールが作成された (例えば、 Python ソースファイルを作成した) 場合、イン"
"ポートシステムが新しいモジュールを見つけられるように、 :func:"
"`invalidate_caches` を呼ぶ必要があるでしょう。"

#: ../../library/importlib.rst:127
msgid "Parent packages are automatically imported."
msgstr "親パッケージは自動的にインポートされます。"

#: ../../library/importlib.rst:132
msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are "
"created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""
":data:`sys.meta_path` に保存されたファインダーの内部キャッシュを無効にしま"
"す。ファインダーが ``invalidate_caches()`` を実装していれば、無効化を行うため"
"にそれが呼び出されます。すべてのファインダーが新しいモジュールの存在に気づく"
"ことを保証しているプログラムの実行中に、モジュールが作成またはインストールさ"
"れたなら、この関数が呼び出されるべきです。"

#: ../../library/importlib.rst:140
msgid ""
"Namespace packages created/installed in a different :data:`sys.path` "
"location after the same namespace was already imported are noticed."
msgstr ""

#: ../../library/importlib.rst:146
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (which can be different if re-importing "
"causes a different object to be placed in :data:`sys.modules`)."
msgstr ""
"以前にインポートされた *module* をリロードします。引数はモジュールオブジェク"
"トでなければならず、したがってそれ以前に必ずインポートに成功していなければな"
"りません。この関数は、モジュールのソースファイルを外部エディタで編集していて "
"Python インタープリタから離れることなく新しいバージョンを試したい際に便利で"
"す。戻り値はモジュールオブジェクトです。 (もし再インポートが異なるオブジェク"
"トを :data:`sys.modules` に配置したら、元の *module* とは異なるかもしれませ"
"ん。)"

#: ../../library/importlib.rst:153
msgid "When :func:`reload` is executed:"
msgstr ":func:`reload` が実行された場合:"

#: ../../library/importlib.rst:155
msgid ""
"Python module's code is recompiled and the module-level code re-executed, "
"defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the "
"module.  The ``init`` function of extension modules is not called a second "
"time."
msgstr ""
"Python モジュールのコードは再コンパイルされ、モジュールレベルのコードが再度実"
"行されます。モジュールの辞書中にある何らかの名前に結び付けられたオブジェクト"
"は、そのモジュールを最初にロードしたときの :term:`ローダー <loader>` を再利用"
"して新たに定義されます。拡張モジュールの ``init`` 関数が二度呼び出されること"
"はありません。"

#: ../../library/importlib.rst:161
msgid ""
"As with all other objects in Python the old objects are only reclaimed after "
"their reference counts drop to zero."
msgstr ""
"Python における他のオブジェクトと同様、以前のオブジェクトのメモリ領域は、参照"
"カウントがゼロにならないかぎり再利用されません。"

#: ../../library/importlib.rst:164
msgid ""
"The names in the module namespace are updated to point to any new or changed "
"objects."
msgstr ""
"モジュール名前空間内の名前は新しいオブジェクト (または更新されたオブジェク"
"ト) を指すよう更新されます。"

#: ../../library/importlib.rst:167
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"以前のオブジェクトが (外部の他のモジュールなどからの) 参照を受けている場合、"
"それらを新たなオブジェクトに再束縛し直すことはないので、必要なら自分で名前空"
"間を更新しなければなりません。"

#: ../../library/importlib.rst:171
msgid "There are a number of other caveats:"
msgstr "いくつか補足説明があります:"

#: ../../library/importlib.rst:173
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"モジュールが再ロードされた際、その辞書 (モジュールのグローバル変数を含みま"
"す) はそのまま残ります。名前の再定義を行うと、以前の定義を上書きするので、一"
"般的には問題はありません。新たなバージョンのモジュールが古いバージョンで定義"
"された名前を定義していない場合、古い定義がそのまま残ります。辞書がグローバル"
"テーブルやオブジェクトのキャッシュを維持していれば、この機能をモジュールを有"
"効性を引き出すために使うことができます --- つまり、 :keyword:`try` 文を使え"
"ば、必要に応じてテーブルがあるかどうかをテストし、その初期化を飛ばすことがで"
"きます::"

#: ../../library/importlib.rst:182
msgid ""
"try:\n"
"    cache\n"
"except NameError:\n"
"    cache = {}"
msgstr ""

#: ../../library/importlib.rst:187
msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and other "
"key modules is not recommended.  In many cases extension modules are not "
"designed to be initialized more than once, and may fail in arbitrary ways "
"when reloaded."
msgstr ""
"組み込みモジュールや動的にロードされるモジュールを再ロードすることは、一般的"
"にそれほど便利ではありません。 :mod:`sys`, :mod:`__main__`, :mod:`builtins` "
"やその他重要なモジュールの再ロードはお勧め出来ません。多くの場合、拡張モ"
"ジュールは 1 度以上初期化されるようには設計されておらず、再ロードされた場合に"
"は何らかの理由で失敗するかもしれません。"

#: ../../library/importlib.rst:193
msgid ""
"If a module imports objects from another module using :keyword:`from` ... :"
"keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import` "
"and qualified names (*module.name*) instead."
msgstr ""
"一方のモジュールが :keyword:`from` ... :keyword:`import` ... を使って、オブ"
"ジェクトを他方のモジュールからインポートしているなら、他方のモジュールを :"
"func:`reload` で呼び出しても、そのモジュールからインポートされたオブジェクト"
"を再定義することはできません --- この問題を回避する一つの方法は、 :keyword:"
"`from` 文を再度実行することで、もう一つの方法は :keyword:`!from` 文の代わり"
"に :keyword:`!import` と限定的な名前 (*module.name*) を使うことです。"

#: ../../library/importlib.rst:199
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"あるモジュールがクラスのインスタンスを生成している場合、そのクラスを定義して"
"いるモジュールの再ロードはそれらインスタンスのメソッド定義に影響しません --- "
"それらは古いクラス定義を使い続けます。これは派生クラスの場合でも同じです。"

#: ../../library/importlib.rst:205
msgid ""
":exc:`ModuleNotFoundError` is raised when the module being reloaded lacks a :"
"class:`~importlib.machinery.ModuleSpec`."
msgstr ""
"リロードされたモジュールの :class:`~importlib.machinery.ModuleSpec` が欠けて"
"いたときは :exc:`ModuleNotFoundError` が送出されます。"

#: ../../library/importlib.rst:211
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ":mod:`importlib.abc` -- インポートに関連する抽象基底クラス"

#: ../../library/importlib.rst:216
msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**ソースコード:** :source:`Lib/importlib/abc.py`"

#: ../../library/importlib.rst:221
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base "
"classes are also provided to help in implementing the core ABCs."
msgstr ""
":mod:`importlib.abc` モジュールは、 :keyword:`import` に使われるすべてのコア"
"抽象基底クラス含みます。コア抽象基底クラスの実装を助けるために、コア抽象基底"
"クラスのサブクラスもいくつか提供されています。"

#: ../../library/importlib.rst:225
msgid "ABC hierarchy::"
msgstr "抽象基底クラス階層::"

#: ../../library/importlib.rst:227
msgid ""
"object\n"
" +-- MetaPathFinder\n"
" +-- PathEntryFinder\n"
" +-- Loader\n"
"      +-- ResourceLoader --------+\n"
"      +-- InspectLoader          |\n"
"           +-- ExecutionLoader --+\n"
"                                 +-- FileLoader\n"
"                                 +-- SourceLoader"
msgstr ""

#: ../../library/importlib.rst:240
msgid "An abstract base class representing a :term:`meta path finder`."
msgstr ":term:`meta path finder` を表す抽象基底クラスです。"

#: ../../library/importlib.rst:244 ../../library/importlib.rst:280
msgid "No longer a subclass of :class:`!Finder`."
msgstr ""

#: ../../library/importlib.rst:249
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be ``None``.  "
"Otherwise, this is a search for a subpackage or module and *path* will be "
"the value of :attr:`__path__` from the parent package. If a spec cannot be "
"found, ``None`` is returned. When passed in, ``target`` is a module object "
"that the finder may use to make a more educated guess about what spec to "
"return. :func:`importlib.util.spec_from_loader` may be useful for "
"implementing concrete ``MetaPathFinders``."
msgstr ""
"指定されたモジュールに対応する :term:`スペック <module spec>` を検索する抽象"
"メソッド。もしこれがトップレベルのインポートなら、 *path* は ``None`` です。"
"そうでなければ、これはサブパッケージまたはモジュールのための検索で、 *path* "
"は親パッケージの :attr:`__path__` の値です。スペックが見つからなければ "
"``None`` が返されます。 ``target`` は、渡されてきたならモジュールオブジェクト"
"です。これはファインダーがどのようなスペックを返せばよいか推測するために使用"
"します。具体的な ``MetaPathFinders`` を実装するためには :func:`importlib."
"util.spec_from_loader` が便利かもしれません。"

#: ../../library/importlib.rst:263
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"このファインダーで使われている内部キャッシュがあれば無効にするオプションのメ"
"ソッドです。 :data:`sys.meta_path` 上のすべてのファインダーのキャッシュを無効"
"化する際、 :func:`importlib.invalidate_caches` によって使われます。"

#: ../../library/importlib.rst:267
msgid "Returns ``None`` when called instead of :data:`NotImplemented`."
msgstr ""

#: ../../library/importlib.rst:273
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by :class:"
"`importlib.machinery.PathFinder`."
msgstr ""
":term:`path entry finder` を表す抽象基底クラスです。 :class:`MetaPathFinder` "
"と似ているところがありますが、 ``PathEntryFinder`` は :class:`importlib."
"machinery.PathFinder` が提供するパスに基づく import サブシステムの中でのみ使"
"うことが意図されています。"

#: ../../library/importlib.rst:285
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the :"
"term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that "
"the finder may use to make a more educated guess about what spec to return. :"
"func:`importlib.util.spec_from_loader` may be useful for implementing "
"concrete ``PathEntryFinders``."
msgstr ""
"指定されたモジュールに対応する :term:`スペック <module spec>` を検索する抽象"
"メソッド。ファインダーは、割り当てられている :term:`パス・エントリー <path "
"entry>` 内のモジュールだけを検索します。スペックが見つからなければ ``None`` "
"が返されます。 ``target`` は、渡されてきたならモジュールオブジェクトです。こ"
"れはファインダーがどのようなスペックを返せばよいか推測するために使用します。"
"具体的な ``PathEntryFinders`` を実装するためには :func:`importlib.util."
"spec_from_loader` が便利かもしれません。"

#: ../../library/importlib.rst:297
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :meth:`importlib.machinery.PathFinder."
"invalidate_caches` when invalidating the caches of all cached finders."
msgstr ""
"このファインダーで使われている内部キャッシュがあれば無効にするオプションのメ"
"ソッドです。キャッシュされたすべてのファインダーの無効化する際、 :meth:"
"`importlib.machinery.PathFinder.invalidate_caches` によって使われます。"

#: ../../library/importlib.rst:305
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ""
":term:`loader` の抽象基底クラスです。ローダーの厳密な定義は :pep:`302` を参照"
"してください。"

#: ../../library/importlib.rst:308
msgid ""
"Loaders that wish to support resource reading should implement a :meth:"
"`get_resource_reader` method as specified by :class:`importlib.resources.abc."
"ResourceReader`."
msgstr ""
"リソースの読み出しをサポートさせたいローダーには、 :class:`importlib."
"resources.abc.ResourceReader` で指定されている :meth:`get_resource_reader` メ"
"ソッドを実装してください。"

#: ../../library/importlib.rst:312
msgid "Introduced the optional :meth:`get_resource_reader` method."
msgstr "オプションの :meth:`get_resource_reader` メソッドが導入されました。"

#: ../../library/importlib.rst:317
msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr ""
"モジュールをインポートする際に使用されるモジュールオブジェクトを返すメソッ"
"ド。このメソッドは ``None`` を戻すことができ、その場合はデフォルトのモジュー"
"ル作成のセマンティクスが適用されることを示します。"

#: ../../library/importlib.rst:323
msgid "This method is no longer optional when :meth:`exec_module` is defined."
msgstr ""
":meth:`exec_module` が定義されている場合は、このメソッドはオプションではなく"
"なりました。"

#: ../../library/importlib.rst:329
msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized "
"when :meth:`exec_module` is called.  When this method exists, :meth:"
"`create_module` must be defined."
msgstr ""
"モジュールがインポートまたはリロードされる際に、そのモジュールをモジュール自"
"身の名前空間の中で実行する抽象的なメソッド。\n"
":meth:`exec_module` が呼ばれる時点で、モジュールはすでに初期設定されている必"
"要があります。\n"
"このメソッドが存在するときは、 :meth:`create_module` の定義が必須です。"

#: ../../library/importlib.rst:336
msgid ":meth:`create_module` must also be defined."
msgstr ":meth:`create_module` の定義が必須となりました。"

#: ../../library/importlib.rst:341
msgid ""
"A legacy method for loading a module.  If the module cannot be loaded, :exc:"
"`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""
"モジュールをロードするためのレガシーなメソッドです。モジュールがロードできな"
"ければ :exc:`ImportError` を送出し、ロードできればロードされたモジュールを返"
"します。"

#: ../../library/importlib.rst:345
msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module "
"and insert it into :data:`sys.modules` before any loading begins, to prevent "
"recursion from the import.  If the loader inserted a module and the load "
"fails, it must be removed by the loader from :data:`sys.modules`; modules "
"already in :data:`sys.modules` before the loader began execution should be "
"left alone."
msgstr ""

#: ../../library/importlib.rst:354
msgid ""
"The loader should set several attributes on the module (note that some of "
"these attributes can change when a module is reloaded):"
msgstr ""
"ローダーはモジュールにいくつかの属性を設定する必要があります。(なお、これらの"
"属性には、モジュールがリロードされた際に変化するものがあります):"

#: ../../library/importlib.rst:358
msgid ":attr:`__name__`"
msgstr ":attr:`__name__`"

#: ../../library/importlib.rst:359
msgid ""
"The module's fully qualified name. It is ``'__main__'`` for an executed "
"module."
msgstr ""

#: ../../library/importlib.rst:362
msgid ":attr:`__file__`"
msgstr ":attr:`__file__`"

#: ../../library/importlib.rst:363
msgid ""
"The location the :term:`loader` used to load the module. For example, for "
"modules loaded from a .py file this is the filename. It is not set on all "
"modules (e.g. built-in modules)."
msgstr ""

#: ../../library/importlib.rst:367
msgid ":attr:`__cached__`"
msgstr ":attr:`__cached__`"

#: ../../library/importlib.rst:368
msgid ""
"The filename of a compiled version of the module's code. It is not set on "
"all modules (e.g. built-in modules)."
msgstr ""

#: ../../library/importlib.rst:371
msgid ":attr:`__path__`"
msgstr ":attr:`__path__`"

#: ../../library/importlib.rst:372
msgid ""
"The list of locations where the package's submodules will be found. Most of "
"the time this is a single directory. The import system passes this attribute "
"to ``__import__()`` and to finders in the same way as :data:`sys.path` but "
"just for the package. It is not set on non-package modules so it can be used "
"as an indicator that the module is a package."
msgstr ""

#: ../../library/importlib.rst:379
msgid ":attr:`__package__`"
msgstr ":attr:`__package__`"

#: ../../library/importlib.rst:380
msgid ""
"The fully qualified name of the package the module is in (or the empty "
"string for a top-level module). If the module is a package then this is the "
"same as :attr:`__name__`."
msgstr ""

#: ../../library/importlib.rst:384
msgid ":attr:`__loader__`"
msgstr ":attr:`__loader__`"

#: ../../library/importlib.rst:385
msgid "The :term:`loader` used to load the module."
msgstr ""

#: ../../library/importlib.rst:387
msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr ":meth:`exec_module` が利用可能な場合、後方互換な機能が提供されます。"

#: ../../library/importlib.rst:390
msgid ""
"Raise :exc:`ImportError` when called instead of :exc:`NotImplementedError`.  "
"Functionality provided when :meth:`exec_module` is available."
msgstr ""

#: ../../library/importlib.rst:395
msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and :meth:"
"`create_module`).  Loaders should implement it instead of :meth:"
"`load_module`.  The import machinery takes care of all the other "
"responsibilities of :meth:`load_module` when :meth:`exec_module` is "
"implemented."
msgstr ""
"モジュールをロードするための推奨される API は、 :meth:`exec_module` (および :"
"meth:`create_module`) です。ローダーは :meth:`load_module` の代わりにそれを実"
"装するべきです。 :meth:`exec_module` が実装されている場合、インポート機構は :"
"meth:`load_module` の他のすべての責任を肩代わりします。"

#: ../../library/importlib.rst:405
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loading arbitrary resources from the storage back-end."
msgstr ""
":term:`loader` の抽象基底クラスで、ストレージバックエンドから任意のリソースを"
"ロードするオプションの :pep:`302` プロトコルを実装します。"

#: ../../library/importlib.rst:409
msgid ""
"This ABC is deprecated in favour of supporting resource loading through :"
"class:`importlib.resources.abc.ResourceReader`."
msgstr ""

#: ../../library/importlib.rst:415
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary "
"data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's :attr:`__file__` "
"attribute or an item from a package's :attr:`__path__`."
msgstr ""
"*path* に割り当てられたデータのバイト列を返す抽象メソッドです。任意のデータを"
"保管できるファイル的なストレージバックエンドをもつローダーは、この抽象メソッ"
"ドを実装して、保管されたデータに直接アクセスさせるようにできます。 *path* が"
"見つからなければ :exc:`OSError` を送出する必要があります。 *path* は、モ"
"ジュールの :attr:`__file__` 属性を使って、またはパッケージの :attr:"
"`__path__` の要素を使って、構成されることが期待されます。"

#: ../../library/importlib.rst:423
msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` の代わりに :exc:`OSError` を送出します。"

#: ../../library/importlib.rst:429
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loaders that inspect modules."
msgstr ""
":term:`loader` の抽象基底クラスで、ローダーがモジュールを検査するためのオプ"
"ションの :pep:`302` プロトコルを実装します。"

#: ../../library/importlib.rst:434
msgid ""
"Return the code object for a module, or ``None`` if the module does not have "
"a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"モジュールの :class:`code` オブジェクトを返すか、 (例えば組み込みモジュールの"
"場合に) モジュールがコードオブジェクトを持たなければ ``None`` を返します。要"
"求されたモジュールをローダーが見つけられなかった場合は :exc:`ImportError` を"
"送出します。"

#: ../../library/importlib.rst:440
msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr ""
"このメソッドにはデフォルト実装がありますが、とはいえパフォーマンスのために、"
"可能ならばオーバライドしたほうが良いです。"

#: ../../library/importlib.rst:446
msgid "No longer abstract and a concrete implementation is provided."
msgstr "このメソッドはもはや抽象メソッドではなく、具象実装が提供されます。"

#: ../../library/importlib.rst:451
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is "
"available (e.g. a built-in module). Raises :exc:`ImportError` if the loader "
"cannot find the module specified."
msgstr ""
"モジュールのソースを返す抽象メソッドです。これは認識されたすべての行セパレー"
"タを ``'\\n'`` 文字に変換し、 :term:`universal newlines` を使ったテキスト文字"
"列として返されます。利用できるソースがなければ (例えば組み込みモジュール)、 "
"``None`` を返します。指定されたモジュールが見つからなければ、 :exc:"
"`ImportError` を送出します。"

#: ../../library/importlib.rst:457 ../../library/importlib.rst:466
#: ../../library/importlib.rst:516
msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr ""
":exc:`NotImplementedError` の代わりに :exc:`ImportError` を送出します。"

#: ../../library/importlib.rst:462
msgid ""
"An optional method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""
"モジュールがパッケージであれば True を返し、そうでなければ False を返すオプ"
"ションのメソッドです。 :term:`ローダー <loader>` がモジュールを見つけられな"
"かったなら :exc:`ImportError` が送出されます。"

#: ../../library/importlib.rst:471
msgid "Create a code object from Python source."
msgstr "Python のソースからコードオブジェクトを作ります。"

#: ../../library/importlib.rst:473
msgid ""
"The *data* argument can be whatever the :func:`compile` function supports (i."
"e. string or bytes). The *path* argument should be the \"path\" to where the "
"source code originated from, which can be an abstract concept (e.g. location "
"in a zip file)."
msgstr ""
"*data* 引数は :func:`compile` 関数がサポートするもの (すなわち文字列かバイ"
"ト) なら何でも構いません。*path* 引数はソースコードの元々の場所への \"パス\" "
"でなければなりませんが、抽象概念 (例えば zip ファイル内の場所) でも構いませ"
"ん。"

#: ../../library/importlib.rst:478
msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr ""
"結果のコードオブジェクトを使って、 ``exec(code, module.__dict__)`` を呼ぶこと"
"でモジュール内でコードを実行できます。"

#: ../../library/importlib.rst:483
msgid "Made the method static."
msgstr "スタティックメソッドになりました。"

#: ../../library/importlib.rst:488
msgid "Implementation of :meth:`Loader.exec_module`."
msgstr ":meth:`Loader.exec_module` の実装です。"

#: ../../library/importlib.rst:494
msgid "Implementation of :meth:`Loader.load_module`."
msgstr ":meth:`Loader.load_module` の実装です。"

#: ../../library/importlib.rst:496
msgid "use :meth:`exec_module` instead."
msgstr "代わりに :meth:`exec_module` を使用してください。"

#: ../../library/importlib.rst:502
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when "
"implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""
":class:`InspectLoader` から継承された抽象基底クラスで、実装されていれば、モ"
"ジュールをスクリプトとして実行する助けになります。この抽象基底クラスはオプ"
"ションの :pep:`302` プロトコルを表します。"

#: ../../library/importlib.rst:508
msgid ""
"An abstract method that is to return the value of :attr:`__file__` for the "
"specified module. If no path is available, :exc:`ImportError` is raised."
msgstr ""
"指定されたモジュールの :attr:`__file__` の値を返す抽象メソッドです。利用でき"
"るパスがなければ、 :exc:`ImportError` が送出されます。"

#: ../../library/importlib.rst:512
msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr ""
"ソースコードが利用できるなら、そのモジュールのロードにバイトコードが使われた"
"かにかかわらず、このメソッドはそのソースファイルへのパスを返す必要がありま"
"す。"

#: ../../library/importlib.rst:522
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, providing concrete implementations of :meth:"
"`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
":class:`ResourceLoader` と :class:`ExecutionLoader` から継承された抽象基底ク"
"ラスで、 :meth:`ResourceLoader.get_data` および :meth:`ExecutionLoader."
"get_filename` の具象実装を提供します。"

#: ../../library/importlib.rst:526
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is "
"to handle. The *path* argument is the path to the file for the module."
msgstr ""
"*fullname* 引数は、ローダーが解決しようとするモジュールの、完全に解決された名"
"前です。*path* 引数は、モジュールのファイルへのパスです。"

#: ../../library/importlib.rst:533
msgid "The name of the module the loader can handle."
msgstr "ローダーが扱えるモジュールの名前です。"

#: ../../library/importlib.rst:537
msgid "Path to the file of the module."
msgstr "モジュールのファイルへのパスです。"

#: ../../library/importlib.rst:541
msgid "Calls super's ``load_module()``."
msgstr "親クラスの ``load_module()`` を呼び出します。"

#: ../../library/importlib.rst:543
msgid "Use :meth:`Loader.exec_module` instead."
msgstr "代わりに :meth:`Loader.exec_module` を使用してください。"

#: ../../library/importlib.rst:548 ../../library/importlib.rst:1143
msgid "Returns :attr:`path`."
msgstr ":attr:`path` を返します。"

#: ../../library/importlib.rst:552
msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "*path* をバイナリファイルとして読み込み、そのバイト列を返します。"

#: ../../library/importlib.rst:557
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"ソース (オプションでバイトコード) ファイルのロードを実装する抽象基底クラスで"
"す。このクラスは、 :class:`ResourceLoader` と :class:`ExecutionLoader` の両方"
"を継承し、以下の実装が必要です:"

#: ../../library/importlib.rst:561
msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

#: ../../library/importlib.rst:562
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

#: ../../library/importlib.rst:563
msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr ""
"ソースファイルへのパスのみを返す必要があります。ソースなしのロードはサポート"
"されていません。"

#: ../../library/importlib.rst:566
msgid ""
"The abstract methods defined by this class are to add optional bytecode file "
"support. Not implementing these optional methods (or causing them to raise :"
"exc:`NotImplementedError`) causes the loader to only work with source code. "
"Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"このクラスでこれらの抽象メソッドを定義することで、バイトコードファイルを追加"
"でサポートします。これらのメソッドを定義しなければ (またはそのモジュールが :"
"exc:`NotImplementedError` を送出すれば)、このローダーはソースコードに対しての"
"み働きます。これらのメソッドを実装することで、ローダーはソースとバイトコード"
"ファイル *の組み合わせ* に対して働きます。バイトコードのみを与えた *ソースの"
"ない* ロードは認められません。バイトコードファイルは、 Python コンパイラによ"
"る解析の工程をなくして速度を上げる最適化です。ですから、バイトコード特有の "
"API は公開されていません。"

#: ../../library/importlib.rst:577
msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr ""
"指定されたパスについてのメタデータを含む :class:`dict` を返す、オプションの抽"
"象メソッドです。サポートされる辞書のキーは:"

#: ../../library/importlib.rst:580
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr ""
"``'mtime'`` (必須): ソースコードの更新時刻を表す整数または浮動小数点数です。"

#: ../../library/importlib.rst:582
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (任意): バイト数で表したソースコードのサイズです。"

#: ../../library/importlib.rst:584
msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr ""
"未来の拡張のため、辞書内の他のキーは無視されます。パスが扱えなければ、 :exc:"
"`OSError` が送出されます。"

#: ../../library/importlib.rst:589 ../../library/importlib.rst:602
msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` の代わりに :exc:`OSError` を送出します。"

#: ../../library/importlib.rst:594
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr "指定されたパスの更新時刻を返す、オプションの抽象メソッドです。"

#: ../../library/importlib.rst:597
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. "
"Raise :exc:`OSError` if the path cannot be handled."
msgstr ""
"このメソッドは廃止され、 :meth:`path_stats` が推奨されます。このモジュールを"
"実装する必要はありませんが、互換性のため現在も利用できます。パスが扱えなけれ"
"ば、 :exc:`OSError` が送出されます。"

#: ../../library/importlib.rst:607
msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr ""
"ファイルパスに指定されたバイト列を書き込むオプションの抽象メソッドです。存在"
"しない中間ディレクトリがあれば、自動で作成されます。"

#: ../../library/importlib.rst:611
msgid ""
"When writing to the path fails because the path is read-only (:const:`errno."
"EACCES`/:exc:`PermissionError`), do not propagate the exception."
msgstr ""

#: ../../library/importlib.rst:615
msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr ""
"呼ばれたときに :exc:`NotImplementedError` を送出することは最早ありません。"

#: ../../library/importlib.rst:620
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr ":meth:`InspectLoader.get_code` の具象実装です。"

#: ../../library/importlib.rst:624
msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr ":meth:`Loader.exec_module` の具象実装です。"

#: ../../library/importlib.rst:630
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr ":meth:`Loader.load_module` の具象実装です。"

#: ../../library/importlib.rst:632
msgid "Use :meth:`exec_module` instead."
msgstr "代わりに :meth:`exec_module` を使用してください。"

#: ../../library/importlib.rst:637
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr ":meth:`InspectLoader.get_source` の具象実装です。"

#: ../../library/importlib.rst:641
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by :meth:"
"`ExecutionLoader.get_filename`) is a file named ``__init__`` when the file "
"extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
":meth:`InspectLoader.is_package` の具象実装です。モジュールは、次の *両方* を"
"満たすならパッケージであると決定されます。モジュールの (:meth:"
"`ExecutionLoader.get_filename` で与えられる) ファイルパスが、ファイル拡張子を"
"除くと ``__init__`` という名のファイルであること。モジュール名自体が "
"``__init__`` で終わらないこと。"

#: ../../library/importlib.rst:650
msgid "*Superseded by TraversableResources*"
msgstr "*TraversableResources に取って代わられました*"

#: ../../library/importlib.rst:652
msgid ""
"An :term:`abstract base class` to provide the ability to read *resources*."
msgstr ""
"*resources* の読み出し機能を提供する :term:`抽象基底クラス (abstract base "
"class, ABC) <abstract base class>` です。"

#: ../../library/importlib.rst:655
msgid ""
"From the perspective of this ABC, a *resource* is a binary artifact that is "
"shipped within a package. Typically this is something like a data file that "
"lives next to the ``__init__.py`` file of the package. The purpose of this "
"class is to help abstract out the accessing of such data files so that it "
"does not matter if the package and its data file(s) are stored e.g. in a zip "
"file versus on the file system."
msgstr ""

#: ../../library/importlib.rst:663
msgid ""
"For any of methods of this class, a *resource* argument is expected to be a :"
"term:`path-like object` which represents conceptually just a file name. This "
"means that no subdirectory paths should be included in the *resource* "
"argument. This is because the location of the package the reader is for, "
"acts as the \"directory\". Hence the metaphor for directories and file names "
"is packages and resources, respectively. This is also why instances of this "
"class are expected to directly correlate to a specific package (instead of "
"potentially representing multiple packages or a module)."
msgstr ""

#: ../../library/importlib.rst:674
msgid ""
"Loaders that wish to support resource reading are expected to provide a "
"method called ``get_resource_reader(fullname)`` which returns an object "
"implementing this ABC's interface. If the module specified by fullname is "
"not a package, this method should return :const:`None`. An object compatible "
"with this ABC should only be returned when the specified module is a package."
msgstr ""

#: ../../library/importlib.rst:683 ../../library/importlib.rst:793
msgid "Use :class:`importlib.resources.abc.TraversableResources` instead."
msgstr ""

#: ../../library/importlib.rst:688
msgid ""
"Returns an opened, :term:`file-like object` for binary reading of the "
"*resource*."
msgstr ""

#: ../../library/importlib.rst:691
msgid "If the resource cannot be found, :exc:`FileNotFoundError` is raised."
msgstr ""
"リソースが見付からない場合は、 :exc:`FileNotFoundError` が送出されます。"

#: ../../library/importlib.rst:696
msgid "Returns the file system path to the *resource*."
msgstr "*resource* へのファイルシステムパスを返します。"

#: ../../library/importlib.rst:698
msgid ""
"If the resource does not concretely exist on the file system, raise :exc:"
"`FileNotFoundError`."
msgstr ""
"リソースの実体がファイルシステムに存在しない場合、 :exc:`FileNotFoundError` "
"が送出されます。"

#: ../../library/importlib.rst:703
msgid ""
"Returns ``True`` if the named *name* is considered a resource. :exc:"
"`FileNotFoundError` is raised if *name* does not exist."
msgstr ""
"*name* という名前がリソースだと見なせるなら ``True`` を返します。\n"
"*name* が存在しない場合は :exc:`FileNotFoundError` が送出されます。"

#: ../../library/importlib.rst:708
msgid ""
"Returns an :term:`iterable` of strings over the contents of the package. Do "
"note that it is not required that all names returned by the iterator be "
"actual resources, e.g. it is acceptable to return names for which :meth:"
"`is_resource` would be false."
msgstr ""

#: ../../library/importlib.rst:714
msgid ""
"Allowing non-resource names to be returned is to allow for situations where "
"how a package and its resources are stored are known a priori and the non-"
"resource names would be useful. For instance, returning subdirectory names "
"is allowed so that when it is known that the package and resources are "
"stored on the file system then those subdirectory names can be used directly."
msgstr ""

#: ../../library/importlib.rst:722
msgid "The abstract method returns an iterable of no items."
msgstr ""

#: ../../library/importlib.rst:727
msgid ""
"An object with a subset of :class:`pathlib.Path` methods suitable for "
"traversing directories and opening files."
msgstr ""

#: ../../library/importlib.rst:730
msgid ""
"For a representation of the object on the file-system, use :meth:`importlib."
"resources.as_file`."
msgstr ""

#: ../../library/importlib.rst:735
msgid "Use :class:`importlib.resources.abc.Traversable` instead."
msgstr ""

#: ../../library/importlib.rst:740
msgid "Abstract. The base name of this object without any parent references."
msgstr ""

#: ../../library/importlib.rst:744
msgid "Yield ``Traversable`` objects in ``self``."
msgstr ""

#: ../../library/importlib.rst:748
msgid "Return ``True`` if ``self`` is a directory."
msgstr ""

#: ../../library/importlib.rst:752
msgid "Return ``True`` if ``self`` is a file."
msgstr ""

#: ../../library/importlib.rst:756
msgid "Return Traversable child in ``self``."
msgstr ""

#: ../../library/importlib.rst:760
msgid "Return ``Traversable`` child in ``self``."
msgstr ""

#: ../../library/importlib.rst:764
msgid ""
"*mode* may be 'r' or 'rb' to open as text or binary. Return a handle "
"suitable for reading (same as :attr:`pathlib.Path.open`)."
msgstr ""

#: ../../library/importlib.rst:767
msgid ""
"When opening as text, accepts encoding parameters such as those accepted by :"
"attr:`io.TextIOWrapper`."
msgstr ""

#: ../../library/importlib.rst:772
msgid "Read contents of ``self`` as bytes."
msgstr ""

#: ../../library/importlib.rst:776
msgid "Read contents of ``self`` as text."
msgstr ""

#: ../../library/importlib.rst:781
msgid ""
"An abstract base class for resource readers capable of serving the :meth:"
"`importlib.resources.files` interface. Subclasses :class:`importlib."
"resources.abc.ResourceReader` and provides concrete implementations of the :"
"class:`importlib.resources.abc.ResourceReader`'s abstract methods. "
"Therefore, any loader supplying :class:`importlib.abc.TraversableResources` "
"also supplies ResourceReader."
msgstr ""

#: ../../library/importlib.rst:788
msgid ""
"Loaders that wish to support resource reading are expected to implement this "
"interface."
msgstr ""

#: ../../library/importlib.rst:798
msgid ""
"Returns a :class:`importlib.resources.abc.Traversable` object for the loaded "
"package."
msgstr ""

#: ../../library/importlib.rst:804
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` -- インポータおよびパスフック"

#: ../../library/importlib.rst:809
msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**ソースコード:** :source:`Lib/importlib/machinery.py`"

#: ../../library/importlib.rst:813
msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr ""
"このモジュールには、 :keyword:`import` がモジュールを検索してロードするのに役"
"立つ様々なオブジェクトがあります。"

#: ../../library/importlib.rst:818
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr ""
"認識されているソースモジュールのファイル接尾辞を表す文字列のリストです。"

#: ../../library/importlib.rst:825
msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr ""
"最適化されていないバイトコードモジュールのファイル接尾辞を表す文字列のリスト"
"です。"

#: ../../library/importlib.rst:830 ../../library/importlib.rst:840
msgid "Use :attr:`BYTECODE_SUFFIXES` instead."
msgstr "代わりに :attr:`BYTECODE_SUFFIXES` を使ってください。"

#: ../../library/importlib.rst:835
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr ""
"最適化されたバイトコードモジュールのファイル接尾辞を表す文字列のリストです。"

#: ../../library/importlib.rst:845
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr ""
"認識されているバイトコードモジュールのファイル接尾辞を表す文字列のリストです "
"(先頭のドットを含みます)。"

#: ../../library/importlib.rst:850
msgid "The value is no longer dependent on ``__debug__``."
msgstr "この値は ``__debug__`` に依存しなくなりました。"

#: ../../library/importlib.rst:855
msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr ""
"認識されている最適化された拡張モジュールのファイル接尾辞を表す文字列のリスト"
"です。"

#: ../../library/importlib.rst:862
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a "
"module without needing any details on the kind of module (for example, :func:"
"`inspect.getmodulename`)."
msgstr ""
"標準のインポート機構によって認識されているすべてのファイル接尾辞を表す文字列"
"の組み合わせられたリストを返します。これが役立つのは、あるファイルシステムパ"
"スがモジュールを参照する可能性があるかだけを知りたくて、そのモジュールの種類"
"を詳しく知る必要はないコード (例えば :func:`inspect.getmodulename`) です。"

#: ../../library/importlib.rst:873
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"組み込みモジュールの :term:`importer` です。すべての既知のモジュールは :data:"
"`sys.builtin_module_names` に列挙されています。このクラスは :class:"
"`importlib.abc.MetaPathFinder` および :class:`importlib.abc.InspectLoader` 抽"
"象基底クラスを実装します。"

#: ../../library/importlib.rst:878 ../../library/importlib.rst:892
#: ../../library/importlib.rst:905 ../../library/importlib.rst:920
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr ""
"インスタンス化の必要性を軽減するため、このクラスにはクラスメソッドだけが定義"
"されています。"

#: ../../library/importlib.rst:881
msgid ""
"As part of :pep:`489`, the builtin importer now implements :meth:`Loader."
"create_module` and :meth:`Loader.exec_module`"
msgstr ""
":pep:`489` の一環として、ビルトインインポーターは :meth:`Loader."
"create_module` と :meth:`Loader.exec_module` を実装しています。"

#: ../../library/importlib.rst:888
msgid ""
"An :term:`importer` for frozen modules. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"フリーズされたモジュールの :term:`インポーター <importer>` です。このクラス"
"は :class:`importlib.abc.MetaPathFinder` および :class:`importlib.abc."
"InspectLoader` 抽象基底クラスを実装します。"

#: ../../library/importlib.rst:895
msgid ""
"Gained :meth:`~Loader.create_module` and :meth:`~Loader.exec_module` methods."
msgstr ""

#: ../../library/importlib.rst:902
msgid ""
":term:`Finder <finder>` for modules declared in the Windows registry.  This "
"class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
"Windows レジストリで宣言されたモジュールの :term:`finder <finder>` です。この"
"クラスは :class:`importlib.abc.MetaPathFinder` 抽象基底クラスを実装します。"

#: ../../library/importlib.rst:910
msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr ""
"代わりに :mod:`site` の設定を使ってください。\n"
"Python の将来のバージョンでは、デフォルトでこのファインダーが使えなくなるかも"
"しれません。"

#: ../../library/importlib.rst:917
msgid ""
"A :term:`Finder <finder>` for :data:`sys.path` and package ``__path__`` "
"attributes. This class implements the :class:`importlib.abc.MetaPathFinder` "
"ABC."
msgstr ""
":data:`sys.path` およびパッケージの ``__path__`` 属性の :term:`Finder "
"<finder>` です。このクラスは :class:`importlib.abc.MetaPathFinder` 抽象基底ク"
"ラスを実装します。"

#: ../../library/importlib.rst:925
msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, :data:`sys."
"path_importer_cache` is checked. If a non-false object is found then it is "
"used as the :term:`path entry finder` to look for the module being searched "
"for. If no entry is found in :data:`sys.path_importer_cache`, then :data:"
"`sys.path_hooks` is searched for a finder for the path entry and, if found, "
"is stored in :data:`sys.path_importer_cache` along with being queried about "
"the module. If no finder is ever found then ``None`` is both stored in the "
"cache and returned."
msgstr ""
":data:`sys.path` または定義されていれば *path* から、 *fullname* で指定された"
"モジュールの :term:`スペック <module spec>` の検索を試みるクラスメソッドで"
"す。検索されるそれぞれのパスエントリに対して :data:`sys.path_importer_cache` "
"が検査されます。偽でないオブジェクトが見つかれば、それが目的のモジュールを検"
"索するための :term:`パスエントリ・ファインダー <path entry finder>` として使"
"われます。 :data:`sys.path_importer_cache` に目的のエントリが見つからなけれ"
"ば、パスエントリに対するファインダーが :data:`sys.path_hooks` から検索され、"
"見つかれば、それが :data:`sys.path_importer_cache` に保管されるとともに、モ"
"ジュールについて問い合わせられます。それでもファインダーが見つからなければ "
"``None`` が保管され、また返されます。"

#: ../../library/importlib.rst:939
msgid ""
"If the current working directory -- represented by an empty string -- is no "
"longer valid then ``None`` is returned but no value is cached in :data:`sys."
"path_importer_cache`."
msgstr ""
"もしカレントワーキングディレクトリ -- 空の文字列によって表されている -- がす"
"でに有効でなければ、 ``None`` が返されますが値は :data:`sys."
"path_importer_cache` にキャッシュされません。"

#: ../../library/importlib.rst:946
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders "
"stored in :data:`sys.path_importer_cache` that define the method. Otherwise "
"entries in :data:`sys.path_importer_cache` set to ``None`` are deleted."
msgstr ""

#: ../../library/importlib.rst:951
msgid "Entries of ``None`` in :data:`sys.path_importer_cache` are deleted."
msgstr ""

#: ../../library/importlib.rst:954
msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working directory "
"for ``''`` (i.e. the empty string)."
msgstr ""
"``''`` (すなわち空の文字列) に対してはカレントワーキングディレクトリととも"
"に :data:`sys.path_hooks` のオブジェクトを呼び出します。"

#: ../../library/importlib.rst:961
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr ""
"ファイルシステムからの結果をキャッシュする :class:`importlib.abc."
"PathEntryFinder` の具象実装です。"

#: ../../library/importlib.rst:964
msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr "*path* 引数は検索を担当するファインダーのディレクトリです。"

#: ../../library/importlib.rst:967
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""
"*loader_details* 引数は、可変個の 2 要素タプルで、それぞれがローダーとロー"
"ダーが認識するファイル接尾辞のシーケンスとを含みます。ローダーは、呼び出し可"
"能でモジュール名と見つかったファイルのパスとの 2 引数を受け付けることを期待さ"
"れます。"

#: ../../library/importlib.rst:972
msgid ""
"The finder will cache the directory contents as necessary, making stat calls "
"for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure "
"to call :func:`importlib.invalidate_caches`."
msgstr ""
"ファインダーはモジュール検索のたびに stat を呼び出し、必要に応じてディレクト"
"リの内容をキャッシュすることで、コードキャッシュが古くなっていないことを確か"
"めます。キャッシュの古さはオペレーティングシステムのファイルシステムのステー"
"ト情報の粒度に依存しますから、モジュールを検索し、新しいファイルを作成し、そ"
"の後に新しいファイルが表すモジュールを検索する、という競合状態の可能性があり"
"ます。この操作が stat の呼び出しの粒度に収まるほど速く起こると、モジュールの"
"検索が失敗します。これを防ぐためには、モジュールを動的に作成する際に、必ず :"
"func:`importlib.invalidate_caches` を呼び出してください。"

#: ../../library/importlib.rst:986
msgid "The path the finder will search in."
msgstr "ファインダーが検索されるパスです。"

#: ../../library/importlib.rst:990
msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr ":attr:`path` 内で *fullname* を扱うスペックの探索を試みます。"

#: ../../library/importlib.rst:996
msgid "Clear out the internal cache."
msgstr "内部キャッシュを完全に消去します。"

#: ../../library/importlib.rst:1000
msgid ""
"A class method which returns a closure for use on :data:`sys.path_hooks`. An "
"instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""

#: ../../library/importlib.rst:1005
msgid ""
"If the argument to the closure is not an existing directory, :exc:"
"`ImportError` is raised."
msgstr ""
"クロージャへの引数が存在するディレクトリでなければ、 :exc:`ImportError` が送"
"出されます。"

#: ../../library/importlib.rst:1011
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""
":class:`importlib.abc.FileLoader` を継承し、その他いくつかのメソッドの具象実"
"装を提供する、 :class:`importlib.abc.SourceLoader` の具象実装です。"

#: ../../library/importlib.rst:1019
msgid "The name of the module that this loader will handle."
msgstr "このローダーが扱うモジュールの名前です。"

#: ../../library/importlib.rst:1023
msgid "The path to the source file."
msgstr "ソースファイルへのパスです。"

#: ../../library/importlib.rst:1027
msgid "Return ``True`` if :attr:`path` appears to be for a package."
msgstr ":attr:`path` がパッケージを表すとき ``True`` を返します。"

#: ../../library/importlib.rst:1031
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr ":meth:`importlib.abc.SourceLoader.path_stats` の具象実装です。"

#: ../../library/importlib.rst:1035
msgid "Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr ":meth:`importlib.abc.SourceLoader.set_data` の具象実装です。"

#: ../../library/importlib.rst:1039 ../../library/importlib.rst:1082
msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where "
"specifying the name of the module to load is optional."
msgstr ""
"ロードするモジュールの名前指定がオプションの、 :meth:`importlib.abc.Loader."
"load_module` の具象実装です。"

#: ../../library/importlib.rst:1044 ../../library/importlib.rst:1087
msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr "代わりに :meth:`importlib.abc.Loader.exec_module` を使用してください。"

#: ../../library/importlib.rst:1049
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""
"バイトコードファイル (すなわちソースコードファイルが存在しない) をインポート"
"できる :class:`importlib.abc.FileLoader` の具象実装です。"

#: ../../library/importlib.rst:1052
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations "
"or new versions of Python which change the bytecode format."
msgstr ""
"注意として、バイトコードを直接使う (つまりソースコードファイルがない) と、そ"
"のモジュールはすべての Python 実装では使用できないし、新しいバージョンの "
"Python ではバイトコードフォーマットが変更されていたら使用できません。"

#: ../../library/importlib.rst:1061
msgid "The name of the module the loader will handle."
msgstr "ローダーが扱うモジュールの名前です。"

#: ../../library/importlib.rst:1065
msgid "The path to the bytecode file."
msgstr "バイトコードファイルへのパスです。"

#: ../../library/importlib.rst:1069
msgid "Determines if the module is a package based on :attr:`path`."
msgstr ""
"そのモジュールがパッケージであるかを :attr:`path` に基づいて決定します。"

#: ../../library/importlib.rst:1073
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr ""
":attr:`path` から作成された :attr:`name` のコードオブジェクトを返します。"

#: ../../library/importlib.rst:1077
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr ""
"このローダーが使われたとき、バイトコードファイルのソースがなければ ``None`` "
"を返します。"

#: ../../library/importlib.rst:1092
msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr ""
"拡張モジュールのための :class:`importlib.abc.ExecutionLoader` の具象実装で"
"す。"

#: ../../library/importlib.rst:1095
msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr ""
"*fullname* 引数はローダーがサポートするモジュールの名前を指定します。*path* "
"引数は拡張モジュールのファイルへのパスです。"

#: ../../library/importlib.rst:1098
msgid ""
"Note that, by default, importing an extension module will fail in "
"subinterpreters if it doesn't implement multi-phase init (see :pep:`489`), "
"even if it would otherwise import successfully."
msgstr ""

#: ../../library/importlib.rst:1104
msgid "Multi-phase init is now required for use in subinterpreters."
msgstr ""

#: ../../library/importlib.rst:1109 ../../library/importlib.rst:1293
msgid "Name of the module the loader supports."
msgstr "ローダーがサポートするモジュールの名前です。"

#: ../../library/importlib.rst:1113
msgid "Path to the extension module."
msgstr "拡張モジュールへのパスです。"

#: ../../library/importlib.rst:1117
msgid ""
"Creates the module object from the given specification in accordance with :"
"pep:`489`."
msgstr ""
"与えられたスペックから :pep:`489` に従ってモジュールオブジェクトを作成しま"
"す。"

#: ../../library/importlib.rst:1124
msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr "与えられたモジュールオブジェクトを :pep:`489` に従って初期化します。"

#: ../../library/importlib.rst:1130
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :attr:`EXTENSION_SUFFIXES`."
msgstr ""
":attr:`EXTENSION_SUFFIXES` に基づいて、ファイルパスがパッケージの "
"``__init__`` モジュールを指していれば ``True`` を返します。"

#: ../../library/importlib.rst:1135
msgid "Returns ``None`` as extension modules lack a code object."
msgstr "拡張モジュールにコードオブジェクトがなければ ``None`` を返します。"

#: ../../library/importlib.rst:1139
msgid "Returns ``None`` as extension modules do not have source code."
msgstr "拡張モジュールにソースコードがなければ ``None`` を返します。"

#: ../../library/importlib.rst:1150
msgid ""
"A concrete implementation of :class:`importlib.abc.InspectLoader` for "
"namespace packages.  This is an alias for a private class and is only made "
"public for introspecting the ``__loader__`` attribute on namespace packages::"
msgstr ""

#: ../../library/importlib.rst:1155
msgid ""
">>> from importlib.machinery import NamespaceLoader\n"
">>> import my_namespace\n"
">>> isinstance(my_namespace.__loader__, NamespaceLoader)\n"
"True\n"
">>> import importlib.abc\n"
">>> isinstance(my_namespace.__loader__, importlib.abc.Loader)\n"
"True"
msgstr ""

#: ../../library/importlib.rst:1168
msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's :attr:`__spec__` attribute.  Many of these "
"attributes are also available directly on a module: for example, ``module."
"__spec__.origin == module.__file__``.  Note, however, that while the "
"*values* are usually equivalent, they can differ since there is no "
"synchronization between the two objects.  For example, it is possible to "
"update the module's :attr:`__file__` at runtime and this will not be "
"automatically reflected in the module's :attr:`__spec__.origin`, and vice "
"versa."
msgstr ""

#: ../../library/importlib.rst:1181
msgid ""
"The module's fully qualified name (see :attr:`__name__` attributes on "
"modules). The :term:`finder` should always set this attribute to a non-empty "
"string."
msgstr ""

#: ../../library/importlib.rst:1187
msgid ""
"The :term:`loader` used to load the module (see :attr:`__loader__` "
"attributes on modules). The :term:`finder` should always set this attribute."
msgstr ""

#: ../../library/importlib.rst:1193
msgid ""
"The location the :term:`loader` should use to load the module (see :attr:"
"`__file__` attributes on modules). For example, for modules loaded from a ."
"py file this is the filename. The :term:`finder` should always set this "
"attribute to a meaningful value for the :term:`loader` to use.  In the "
"uncommon case that there is not one (like for namespace packages), it should "
"be set to ``None``."
msgstr ""

#: ../../library/importlib.rst:1202
msgid ""
"The list of locations where the package's submodules will be found (see :"
"attr:`__path__` attributes on modules). Most of the time this is a single "
"directory. The :term:`finder` should set this attribute to a list, even an "
"empty one, to indicate to the import system that the module is a package.  "
"It should be set to ``None`` for non-package modules.  It is set "
"automatically later to a special object for namespace packages."
msgstr ""

#: ../../library/importlib.rst:1212
msgid ""
"The :term:`finder` may set this attribute to an object containing "
"additional, module-specific data to use when loading the module.  Otherwise "
"it should be set to ``None``."
msgstr ""

#: ../../library/importlib.rst:1218
msgid ""
"The filename of a compiled version of the module's code (see :attr:"
"`__cached__` attributes on modules). The :term:`finder` should always set "
"this attribute but it may be ``None`` for modules that do not need compiled "
"code stored."
msgstr ""

#: ../../library/importlib.rst:1225
msgid ""
"(Read-only) The fully qualified name of the package the module is in (or the "
"empty string for a top-level module). See :attr:`__package__` attributes on "
"modules. If the module is a package then this is the same as :attr:`name`."
msgstr ""

#: ../../library/importlib.rst:1232
msgid ""
"``True`` if the spec's :attr:`origin` refers to a loadable location, "
"``False`` otherwise.  This value impacts how :attr:`origin` is interpreted "
"and how the module's :attr:`__file__` is populated."
msgstr ""

#: ../../library/importlib.rst:1239
msgid ""
"A specialization of :class:`importlib.machinery.ExtensionFileLoader` that is "
"able to load extension modules in Framework format."
msgstr ""
"フレームワーク形式の拡張モジュールを読み込み事ができる、特殊な :class:"
"`importlib.machinery.ExtensionFileLoader` です。"

#: ../../library/importlib.rst:1242
msgid ""
"For compatibility with the iOS App Store, *all* binary modules in an iOS app "
"must be dynamic libraries, contained in a framework with appropriate "
"metadata, stored in the ``Frameworks`` folder of the packaged app. There can "
"be only a single binary per framework, and there can be no executable binary "
"material outside the Frameworks folder."
msgstr ""
"iOS App Store との互換性のため、 iOS アプリの *すべての* バイナリモジュール"
"は、パッケージ化されたアプリの ``Frameworks`` フォルダーに保存された、適切な"
"メタデータ付きのフレームワークにある動的ライブラリである必要があります。フ"
"レームワークごとにバイナリは一つだけで、 Frameworks フォルダーの外に実行可能"
"バイナリデータを設置することはできません。"

#: ../../library/importlib.rst:1248
msgid ""
"To accommodate this requirement, when running on iOS, extension module "
"binaries are *not* packaged as ``.so`` files on ``sys.path``, but as "
"individual standalone frameworks. To discover those frameworks, this loader "
"is be registered against the ``.fwork`` file extension, with a ``.fwork`` "
"file acting as a placeholder in the original location of the binary on ``sys."
"path``. The ``.fwork`` file contains the path of the actual binary in the "
"``Frameworks`` folder, relative to the app bundle. To allow for resolving a "
"framework-packaged binary back to the original location, the framework is "
"expected to contain a ``.origin`` file that contains the location of the ``."
"fwork`` file, relative to the app bundle."
msgstr ""

#: ../../library/importlib.rst:1259
msgid ""
"For example, consider the case of an import ``from foo.bar import _whiz``, "
"where ``_whiz`` is implemented with the binary module ``sources/foo/bar/"
"_whiz.abi3.so``, with ``sources`` being the location registered on ``sys."
"path``, relative to the application bundle. This module *must* be "
"distributed as ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` "
"(creating the framework name from the full import path of the module), with "
"an ``Info.plist`` file in the ``.framework`` directory identifying the "
"binary as a framework. The ``foo.bar._whiz`` module would be represented in "
"the original location with a ``sources/foo/bar/_whiz.abi3.fwork`` marker "
"file, containing the path ``Frameworks/foo.bar._whiz/foo.bar._whiz``. The "
"framework would also contain ``Frameworks/foo.bar._whiz.framework/foo.bar."
"_whiz.origin``, containing the path to the ``.fwork`` file."
msgstr ""
"例えば、``from foo.bar import _whiz`` をインポートする場合を考えてみましょ"
"う。 ``_whiz`` がバイナリモジュール ``sources/foo/bar/_whiz.abi3.so`` で実装"
"されており、 ``sources`` のアプリケーションバンドルからの相対パスが ``sys."
"path`` に登録されています。このモジュールは ``Frameworks/foo.bar._whiz."
"framework/foo.bar._whiz`` （フレームワーク名はモジュールの完全なインポートパ"
"スから命名されています）として、 ``Info.plist`` ファイルをバイナリをフレーム"
"ワークとして識別する ``.framework`` ディレクトリ内に設置して配布しなければな"
"りません。 ``foo.bar._whiz`` モジュールは、元の場所で、 ``Frameworks/foo.bar."
"_whiz/foo.bar._whiz`` のパスを含む ``sources/foo/bar/_whiz.abi3.fwork`` マー"
"カーファイルに記述されます。 また、フレームワークは、 ``.fwork`` へのパスを含"
"む ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin`` も含まなければ"
"なりません。"

#: ../../library/importlib.rst:1273
msgid ""
"When a module is loaded with this loader, the ``__file__`` for the module "
"will report as the location of the ``.fwork`` file. This allows code to use "
"the ``__file__`` of a  module as an anchor for file system traveral. "
"However, the spec origin will reference the location of the *actual* binary "
"in the ``.framework`` folder."
msgstr ""
"モジュールがこのローダーで読み込まれるとき、モジュールの ``__file__`` は ``."
"fwork`` ファイルの場所となります。これにより、コードはモジュールの "
"``__file__`` をファイルシステム横断用のアンカーとして使用できます。しかし、 "
"spec origin は、 ``.framework`` フォルダー下のバイナリの *実際の* 場所を参照"
"します。"

#: ../../library/importlib.rst:1279
msgid ""
"The Xcode project building the app is responsible for converting any ``.so`` "
"files from wherever they exist in the ``PYTHONPATH`` into frameworks in the "
"``Frameworks`` folder (including stripping extensions from the module file, "
"the addition of framework metadata, and signing the resulting framework), "
"and creating the ``.fwork`` and ``.origin`` files. This will usually be done "
"with a build step in the Xcode project; see the iOS documentation for "
"details on how to construct this build step."
msgstr ""

#: ../../library/importlib.rst:1289
msgid ":ref:`Availability <availability>`: iOS."
msgstr ":ref:`利用可能な環境 <availability>`: iOS"

#: ../../library/importlib.rst:1297
msgid "Path to the ``.fwork`` file for the extension module."
msgstr "拡張モジュールの ``.fwork`` ファイルへのパス。"

#: ../../library/importlib.rst:1301
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` -- インポータのためのユーティリティコード"

#: ../../library/importlib.rst:1307
msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**ソースコード:** :source:`Lib/importlib/util.py`"

#: ../../library/importlib.rst:1311
msgid ""
"This module contains the various objects that help in the construction of "
"an :term:`importer`."
msgstr ""
"このモジュールには、 :term:`インポーター <importer>` の構築を助ける様々なオブ"
"ジェクトがあります。"

#: ../../library/importlib.rst:1316
msgid ""
"The bytes which represent the bytecode version number. If you need help with "
"loading/writing bytecode then consider :class:`importlib.abc.SourceLoader`."
msgstr ""
"バイトコードバージョン番号を表しているバイト列。バイトコードのロード／書き込"
"みについてヘルプが必要なら :class:`importlib.abc.SourceLoader` を参照してくだ"
"さい。"

#: ../../library/importlib.rst:1323
msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file associated "
"with the source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the "
"return value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python "
"3.2. The ``cpython-32`` string comes from the current magic tag (see :func:"
"`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then :exc:"
"`NotImplementedError` will be raised)."
msgstr ""
"ソース *path* に関連付けられたバイトコンパイルされたファイルの :pep:`3147`/:"
"pep:`488` パスを返します。例えば、 *path* が ``/foo/bar/baz.py`` なら、 "
"Python 3.2 の場合返り値は ``/foo/bar/__pycache__/baz.cpython-32.pyc`` になり"
"ます。 ``cpython-32`` という文字列は、現在のマジックタグから得られます (マ"
"ジックタグについては :func:`get_tag` を参照; :attr:`sys.implementation."
"cache_tag` が未定義なら :exc:`NotImplementedError` が送出されます。)"

#: ../../library/importlib.rst:1330
msgid ""
"The *optimization* parameter is used to specify the optimization level of "
"the bytecode file. An empty string represents no optimization, so ``/foo/bar/"
"baz.py`` with an *optimization* of ``''`` will result in a bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` causes the "
"interpreter's optimization level to be used. Any other value's string "
"representation is used, so ``/foo/bar/baz.py`` with an *optimization* of "
"``2`` will lead to the bytecode path of ``/foo/bar/__pycache__/baz."
"cpython-32.opt-2.pyc``. The string representation of *optimization* can only "
"be alphanumeric, else :exc:`ValueError` is raised."
msgstr ""
"*optimization* パラメータは、バイトコードファイルの最適化レベルを指定するため"
"に使われます。空文字列は最適化しないことを表します。したがって、 "
"*optimization* が ``''`` のとき ``/foo/bar/baz.py`` に対して ``/foo/bar/"
"__pycache__/baz.cpython-32.pyc`` というバイトコードパスが返ります。 ``None`` "
"にするとインタープリタの最適化レベルが使われます。それ以外では値の文字列表現"
"が使われます。したがって、 *optimization* が ``2`` のとき  ``/foo/bar/baz."
"py`` に対して ``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc`` というバイト"
"コードパスが返ります。 *optimization* の文字列表現は英数字だけが可能で、そう"
"でなければ :exc:`ValueError` が上げられます。"

#: ../../library/importlib.rst:1340
msgid ""
"The *debug_override* parameter is deprecated and can be used to override the "
"system's value for ``__debug__``. A ``True`` value is the equivalent of "
"setting *optimization* to the empty string. A ``False`` value is the same as "
"setting *optimization* to ``1``. If both *debug_override* an *optimization* "
"are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"*debug_override* パラメータは deprecated で、システムの ``__debug__`` 値を"
"オーバーライドするために使用できます。 ``True`` 値は *optimization* を空文字"
"列に設定するのと等価です。 ``False`` 値は *optimization* を ``1`` に設定する"
"のと同等です。もし *debug_override* と *optimization* のどちらも ``None`` 以"
"外であれば :exc:`TypeError` が上げられます。"

#: ../../library/importlib.rst:1348
msgid ""
"The *optimization* parameter was added and the *debug_override* parameter "
"was deprecated."
msgstr ""
"*optimization* パラメータが追加され、 *debug_override* パラメータは "
"deprecated になりました。"

#: ../../library/importlib.rst:1352 ../../library/importlib.rst:1368
#: ../../library/importlib.rst:1457
msgid "Accepts a :term:`path-like object`."
msgstr ":term:`path-like object` を受け入れるようになりました。"

#: ../../library/importlib.rst:1358
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is ``/foo/bar/__pycache__/baz."
"cpython-32.pyc`` the returned path would be ``/foo/bar/baz.py``.  *path* "
"need not exist, however if it does not conform to :pep:`3147` or :pep:`488` "
"format, a :exc:`ValueError` is raised. If :attr:`sys.implementation."
"cache_tag` is not defined, :exc:`NotImplementedError` is raised."
msgstr ""
":pep:`3147` ファイル名への *path* が与えられると、関連するソースコードのファ"
"イルパスを返します。例えば、 *path* が ``/foo/bar/__pycache__/baz.cpython-32."
"pyc`` なら、返されるパスは ``/foo/bar/baz.py`` になります。 *path* は存在する"
"必要はありませんが、 :pep:`3147` または :pep:`488` フォーマットに一致しない場"
"合は :exc:`ValueError` が送出されます。 :attr:`sys.implementation.cache_tag` "
"が定義されていない場合、 :exc:`NotImplementedError` が送出されます。"

#: ../../library/importlib.rst:1373
msgid ""
"Decode the given bytes representing source code and return it as a string "
"with universal newlines (as required by :meth:`importlib.abc.InspectLoader."
"get_source`)."
msgstr ""
"与えられたソースコードを表すバイト列をデコードして、文字列としてそれを一般的"
"な改行形式 (universal newlines) で返します (:meth:`importlib.abc."
"InspectLoader.get_source` で要求されるように)。"

#: ../../library/importlib.rst:1381
msgid "Resolve a relative module name to an absolute one."
msgstr "相対的なモジュール名を解決して絶対的なものにします。"

#: ../../library/importlib.rst:1383
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', __spec__."
"parent)`` without doing a check to see if the **package** argument is needed."
msgstr ""
"**name** の先頭にドットがなければ、単に **name** が返されます。これにより、例"
"えば ``importlib.util.resolve_name('sys', __spec__.parent)`` を使うときに "
"**package** 変数が必要かどうかを確認する必要がなくなります。"

#: ../../library/importlib.rst:1388
msgid ""
":exc:`ImportError` is raised if **name** is a relative module name but "
"**package** is a false value (e.g. ``None`` or the empty string). :exc:"
"`ImportError` is also raised if a relative name would escape its containing "
"package (e.g. requesting ``..bacon`` from within the ``spam`` package)."
msgstr ""
"**name** が相対的なモジュール名であるにもかかわらず **package** が偽値 (例え"
"ば ``None`` や空文字列) ならば、 :exc:`ImportError` が送出されます。相対的な"
"名前がそれを含むパッケージから抜け出る (例えば ``spam`` パッケージ内から ``.."
"bacon`` を要求する) 場合にも :exc:`ImportError` が送出されます。"

#: ../../library/importlib.rst:1396
msgid ""
"To improve consistency with import statements, raise :exc:`ImportError` "
"instead of :exc:`ValueError` for invalid relative import attempts."
msgstr ""

#: ../../library/importlib.rst:1403
msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to the "
"specified **package** name. If the module is in :data:`sys.modules`, then "
"``sys.modules[name].__spec__`` is returned (unless the spec would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :data:`sys.meta_path` is done. ``None`` is returned "
"if no spec is found."
msgstr ""

#: ../../library/importlib.rst:1410
msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr ""
"**name** がサブモジュールを示している  (ドットを含む) 場合、親モジュールは自"
"動的にインポートされます。"

#: ../../library/importlib.rst:1413
msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr ""
"**name** と **package** は :func:`import_module` に対するものと同じように機能"
"します。"

#: ../../library/importlib.rst:1417
msgid ""
"Raises :exc:`ModuleNotFoundError` instead of :exc:`AttributeError` if "
"**package** is in fact not a package (i.e. lacks a :attr:`__path__` "
"attribute)."
msgstr ""

#: ../../library/importlib.rst:1424
msgid ""
"Create a new module based on **spec** and :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."
msgstr ""
"**spec** と :meth:`spec.loader.create_module <importlib.abc.Loader."
"create_module>` に基づいて新しいモジュールを作ります。"

#: ../../library/importlib.rst:1427
msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""
":meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` が "
"``None`` を返さない場合は、既に存在するどの属性もリセットされません。また、 "
"**spec** にアクセスしたり属性をモジュールに設定したりする際に :exc:"
"`AttributeError` 例外が起きても例外は送出されません。"

#: ../../library/importlib.rst:1432
msgid ""
"This function is preferred over using :class:`types.ModuleType` to create a "
"new module as **spec** is used to set as many import-controlled attributes "
"on the module as possible."
msgstr ""
"この関数は、新しいモジュールを作る方法として :class:`types.ModuleType` よりも"
"推奨されます。なぜなら、できるだけ多くのインポートコントロールされた属性をモ"
"ジュールに設定するために **spec** が使用されるからです。"

#: ../../library/importlib.rst:1440
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on a loader.  The parameters have the same meaning as they do "
"for ModuleSpec.  The function uses available :term:`loader` APIs, such as :"
"meth:`InspectLoader.is_package`, to fill in any missing information on the "
"spec."
msgstr ""
"この関数は、スペックに不足している情報を埋めるために :class:`~importlib."
"machinery.ModuleSpec` のような利用可能な :term:`loader` API を使います。"

#: ../../library/importlib.rst:1450
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on the path to a file.  Missing information will be filled in "
"on the spec by making use of loader APIs and by the implication that the "
"module will be file-based."
msgstr ""
"ファイルへのパスにもとづいて :class:`~importlib.machinery.ModuleSpec` インス"
"タンスを生成するためのファクトリー関数。不足している情報は、ローダー API を利"
"用してスペックから得られる情報と、モジュールがファイルベースであるという暗黙"
"的な情報によって埋められます。"

#: ../../library/importlib.rst:1462
msgid ""
"Return the hash of *source_bytes* as bytes. A hash-based ``.pyc`` file "
"embeds the :func:`source_hash` of the corresponding source file's contents "
"in its header."
msgstr ""

#: ../../library/importlib.rst:1470
msgid ""
"A context manager that can temporarily skip the compatibility check for "
"extension modules.  By default the check is enabled and will fail when a "
"single-phase init module is imported in a subinterpreter. It will also fail "
"for a multi-phase init module that doesn't explicitly support a per-"
"interpreter GIL, when imported in an interpreter with its own GIL."
msgstr ""

#: ../../library/importlib.rst:1477
msgid ""
"Note that this function is meant to accommodate an unusual case; one which "
"is likely to eventually go away.  There's is a pretty good chance this is "
"not what you were looking for."
msgstr ""

#: ../../library/importlib.rst:1481
msgid ""
"You can get the same effect as this function by implementing the basic "
"interface of multi-phase init (:pep:`489`) and lying about support for "
"multiple interpreters (or per-interpreter GIL)."
msgstr ""

#: ../../library/importlib.rst:1486
msgid ""
"Using this function to disable the check can lead to unexpected behavior and "
"even crashes.  It should only be used during extension module development."
msgstr ""

#: ../../library/importlib.rst:1494
msgid ""
"A class which postpones the execution of the loader of a module until the "
"module has an attribute accessed."
msgstr ""
"モジュールが属性アクセスできるようになるまで、モジュールのローダーの実行を遅"
"延するクラス。"

#: ../../library/importlib.rst:1497
msgid ""
"This class **only** works with loaders that define :meth:`~importlib.abc."
"Loader.exec_module` as control over what module type is used for the module "
"is required. For those same reasons, the loader's :meth:`~importlib.abc."
"Loader.create_module` method must return ``None`` or a type for which its "
"``__class__`` attribute can be mutated along with not using :term:`slots "
"<__slots__>`. Finally, modules which substitute the object placed into :data:"
"`sys.modules` will not work as there is no way to properly replace the "
"module references throughout the interpreter safely; :exc:`ValueError` is "
"raised if such a substitution is detected."
msgstr ""

#: ../../library/importlib.rst:1508
msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. For "
"projects where startup time is not essential then use of this class is "
"**heavily** discouraged due to error messages created during loading being "
"postponed and thus occurring out of context."
msgstr ""
"起動時間が重要なプロジェクトでは、もし決して使われないモジュールがあれば、こ"
"のクラスを使ってモジュールをロードするコストを最小化できるかもしれません。ス"
"タートアップ時間が重要でないプロジェクトでは、遅延されたロードの際に発生して"
"文脈の外で起こるエラーメッセージのため、このクラスの使用は **著しく** 推奨さ"
"れません。"

#: ../../library/importlib.rst:1516
msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` and :"
"class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""

#: ../../library/importlib.rst:1523
msgid ""
"A class method which returns a callable that creates a lazy loader. This is "
"meant to be used in situations where the loader is passed by class instead "
"of by instance. ::"
msgstr ""
"遅延ローダを生成する callable を返すクラスメソッド。これは、ローダーをインス"
"タンスとしてではなくクラスとして渡すような状況において使われることを意図して"
"います。 ::"

#: ../../library/importlib.rst:1528
msgid ""
"suffixes = importlib.machinery.SOURCE_SUFFIXES\n"
"loader = importlib.machinery.SourceFileLoader\n"
"lazy_loader = importlib.util.LazyLoader.factory(loader)\n"
"finder = importlib.machinery.FileFinder(path, (lazy_loader, suffixes))"
msgstr ""

#: ../../library/importlib.rst:1536
msgid "Examples"
msgstr "使用例"

#: ../../library/importlib.rst:1539
msgid "Importing programmatically"
msgstr "プログラムからのインポート"

#: ../../library/importlib.rst:1541
msgid ""
"To programmatically import a module, use :func:`importlib.import_module`. ::"
msgstr ""
"プログラムからモジュールをインポートするには、 :func:`importlib."
"import_module` を使ってください。 ::"

#: ../../library/importlib.rst:1544
msgid ""
"import importlib\n"
"\n"
"itertools = importlib.import_module('itertools')"
msgstr ""

#: ../../library/importlib.rst:1550
msgid "Checking if a module can be imported"
msgstr "モジュールがインポートできるか確認する"

#: ../../library/importlib.rst:1552
msgid ""
"If you need to find out if a module can be imported without actually doing "
"the import, then you should use :func:`importlib.util.find_spec`."
msgstr ""
"インポートを実際に行わずに、あるモジュールがインポートできるかを知る必要があ"
"る場合は、 :func:`importlib.util.find_spec` を使ってください。"

#: ../../library/importlib.rst:1555
msgid ""
"Note that if ``name`` is a submodule (contains a dot), :func:`importlib.util."
"find_spec` will import the parent module. ::"
msgstr ""

#: ../../library/importlib.rst:1559
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"# For illustrative purposes.\n"
"name = 'itertools'\n"
"\n"
"if name in sys.modules:\n"
"    print(f\"{name!r} already in sys.modules\")\n"
"elif (spec := importlib.util.find_spec(name)) is not None:\n"
"    # If you chose to perform the actual import ...\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[name] = module\n"
"    spec.loader.exec_module(module)\n"
"    print(f\"{name!r} has been imported\")\n"
"else:\n"
"    print(f\"can't find the {name!r} module\")"
msgstr ""

#: ../../library/importlib.rst:1578
msgid "Importing a source file directly"
msgstr "ソースファイルから直接インポートする"

#: ../../library/importlib.rst:1580
msgid ""
"This recipe should be used with caution: it is an approximation of an import "
"statement where the file path is specified directly, rather than :data:`sys."
"path` being searched. Alternatives should first be considered first, such as "
"modifying :data:`sys.path` when a proper module is required, or using :func:"
"`runpy.run_path` when the global namespace resulting from running a Python "
"file is appropriate."
msgstr ""

#: ../../library/importlib.rst:1587
msgid ""
"To import a Python source file directly from a path, use the following "
"recipe::"
msgstr ""

#: ../../library/importlib.rst:1589
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"\n"
"def import_from_path(module_name, file_path):\n"
"    spec = importlib.util.spec_from_file_location(module_name, file_path)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[module_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    return module\n"
"\n"
"\n"
"# For illustrative purposes only (use of `json` is arbitrary).\n"
"import json\n"
"file_path = json.__file__\n"
"module_name = json.__name__\n"
"\n"
"# Similar outcome as `import json`.\n"
"json = import_from_path(module_name, file_path)"
msgstr ""

#: ../../library/importlib.rst:1611
msgid "Implementing lazy imports"
msgstr ""

#: ../../library/importlib.rst:1613
msgid "The example below shows how to implement lazy imports::"
msgstr ""

#: ../../library/importlib.rst:1615
msgid ""
">>> import importlib.util\n"
">>> import sys\n"
">>> def lazy_import(name):\n"
"...     spec = importlib.util.find_spec(name)\n"
"...     loader = importlib.util.LazyLoader(spec.loader)\n"
"...     spec.loader = loader\n"
"...     module = importlib.util.module_from_spec(spec)\n"
"...     sys.modules[name] = module\n"
"...     loader.exec_module(module)\n"
"...     return module\n"
"...\n"
">>> lazy_typing = lazy_import(\"typing\")\n"
">>> #lazy_typing is a real module object,\n"
">>> #but it is not loaded in memory yet.\n"
">>> lazy_typing.TYPE_CHECKING\n"
"False"
msgstr ""

#: ../../library/importlib.rst:1634
msgid "Setting up an importer"
msgstr "インポーターのセットアップ"

#: ../../library/importlib.rst:1636
msgid ""
"For deep customizations of import, you typically want to implement an :term:"
"`importer`. This means managing both the :term:`finder` and :term:`loader` "
"side of things. For finders there are two flavours to choose from depending "
"on your needs: a :term:`meta path finder` or a :term:`path entry finder`. "
"The former is what you would put on :data:`sys.meta_path` while the latter "
"is what you create using a :term:`path entry hook` on :data:`sys.path_hooks` "
"which works with :data:`sys.path` entries to potentially create a finder. "
"This example will show you how to register your own importers so that import "
"will use them (for creating an importer for yourself, read the documentation "
"for the appropriate classes defined within this package)::"
msgstr ""

#: ../../library/importlib.rst:1647
msgid ""
"import importlib.machinery\n"
"import sys\n"
"\n"
"# For illustrative purposes only.\n"
"SpamMetaPathFinder = importlib.machinery.PathFinder\n"
"SpamPathEntryFinder = importlib.machinery.FileFinder\n"
"loader_details = (importlib.machinery.SourceFileLoader,\n"
"                  importlib.machinery.SOURCE_SUFFIXES)\n"
"\n"
"# Setting up a meta path finder.\n"
"# Make sure to put the finder in the proper location in the list in terms "
"of\n"
"# priority.\n"
"sys.meta_path.append(SpamMetaPathFinder)\n"
"\n"
"# Setting up a path entry finder.\n"
"# Make sure to put the path hook in the proper location in the list in "
"terms\n"
"# of priority.\n"
"sys.path_hooks.append(SpamPathEntryFinder.path_hook(loader_details))"
msgstr ""

#: ../../library/importlib.rst:1668
msgid "Approximating :func:`importlib.import_module`"
msgstr ""

#: ../../library/importlib.rst:1670
msgid ""
"Import itself is implemented in Python code, making it possible to expose "
"most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module`::"
msgstr ""

#: ../../library/importlib.rst:1676
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"def import_module(name, package=None):\n"
"    \"\"\"An approximate implementation of import.\"\"\"\n"
"    absolute_name = importlib.util.resolve_name(name, package)\n"
"    try:\n"
"        return sys.modules[absolute_name]\n"
"    except KeyError:\n"
"        pass\n"
"\n"
"    path = None\n"
"    if '.' in absolute_name:\n"
"        parent_name, _, child_name = absolute_name.rpartition('.')\n"
"        parent_module = import_module(parent_name)\n"
"        path = parent_module.__spec__.submodule_search_locations\n"
"    for finder in sys.meta_path:\n"
"        spec = finder.find_spec(absolute_name, path)\n"
"        if spec is not None:\n"
"            break\n"
"    else:\n"
"        msg = f'No module named {absolute_name!r}'\n"
"        raise ModuleNotFoundError(msg, name=absolute_name)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[absolute_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    if path is not None:\n"
"        setattr(parent_module, child_name, module)\n"
"    return module"
msgstr ""

#: ../../library/importlib.rst:443
msgid "universal newlines"
msgstr "universal newlines"

#: ../../library/importlib.rst:443
msgid "importlib.abc.InspectLoader.get_source method"
msgstr "importlib.abc.InspectLoader.get_source メソッド"
