# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# tomoğŸ§, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-17 13:42+0900\n"
"PO-Revision-Date: 2018-06-29 17:31+0000\n"
"Last-Translator: tomoğŸ§, 2018\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/importlib.rst:2
msgid ":mod:`importlib` --- The implementation of :keyword:`import`"
msgstr ":mod:`importlib` --- :keyword:`import` ã®å®Ÿè£…"

#: ../../library/importlib.rst:12
msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/importlib/__init__.py`"

#: ../../library/importlib.rst:17
msgid "Introduction"
msgstr "ã¯ã˜ã‚ã«"

#: ../../library/importlib.rst:19
msgid ""
"The purpose of the :mod:`importlib` package is two-fold. One is to provide "
"the implementation of the :keyword:`import` statement (and thus, by "
"extension, the :func:`__import__` function) in Python source code. This "
"provides an implementation of :keyword:`import` which is portable to any "
"Python interpreter. This also provides an implementation which is easier to "
"comprehend than one implemented in a programming language other than Python."
msgstr ""
":mod:`importlib` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ç›®çš„ã¯2ã¤ã‚ã‚Šã¾ã™ã€‚1ã¤ç›®ã¯ Python ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ä¸­ã«ã‚ã‚‹ :keyword:`import` "
"æ–‡ã®(ãã—ã¦ã€æ‹¡å¼µã¨ã—ã¦ã€ :func:`__import__` é–¢æ•°ã®)å®Ÿè£…ã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ :keyword:`import` "
"æ–‡ã®ã€ã©ã® Python ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã§ã‚‚å‹•ä½œã™ã‚‹å®Ÿè£…ã‚’æä¾›ã—ã¾ã™ã€‚ã¾ãŸã€ Python "
"ä»¥å¤–ã®è¨€èªã§å®Ÿè£…ã•ã‚ŒãŸã©ã®å®Ÿè£…ã‚ˆã‚Šã‚‚æŠŠæ¡ã—ã‚„ã™ã„å®Ÿè£…ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:26
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"2ã¤ç›®ã®ç›®çš„ã¯ã€ã“ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒå…¬é–‹ã—ã¦ã„ã‚‹ :keyword:`import` ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®è¦ç´ ã‚’åˆ©ç”¨ã—ã¦ã€(:term:`ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ "
"<importer>` ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹) ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã§å‹•ä½œã™ã‚‹ã‚«ã‚¹ã‚¿ãƒ ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿè£…ã—ã‚„ã™ãã™ã‚‹ã“ã¨ã§ã™ã€‚"

#: ../../library/importlib.rst:33
msgid ":ref:`import`"
msgstr ":ref:`import`"

#: ../../library/importlib.rst:33
msgid "The language reference for the :keyword:`import` statement."
msgstr ":keyword:`import` æ–‡ã®è¨€èªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã€‚"

#: ../../library/importlib.rst:38
msgid ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"

#: ../../library/importlib.rst:36
msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in "
":data:`sys.modules`)."
msgstr ""
"ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å…ƒã®ä»•æ§˜ã€‚å¹¾ã¤ã‹ã®å‹•ä½œã¯ã“ã®ä»•æ§˜ãŒæ›¸ã‹ã‚ŒãŸé ƒã‹ã‚‰å¤‰æ›´ã•ã‚Œã¦ã„ã¾ã™ (ä¾‹: :data:`sys.modules` ã§ ``None`` "
"ã«åŸºã¥ããƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ)ã€‚"

#: ../../library/importlib.rst:41
msgid "The :func:`.__import__` function"
msgstr ":func:`.__import__` é–¢æ•°"

#: ../../library/importlib.rst:41
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr ":keyword:`import` æ–‡ã¯ã“ã®é–¢æ•°ã®ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚·ãƒ¥ã‚¬ãƒ¼ã§ã™ã€‚"

#: ../../library/importlib.rst:44
msgid ":pep:`235`"
msgstr ":pep:`235`"

#: ../../library/importlib.rst:44
msgid "Import on Case-Insensitive Platforms"
msgstr "å¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ"

#: ../../library/importlib.rst:47
msgid ":pep:`263`"
msgstr ":pep:`263`"

#: ../../library/importlib.rst:47
msgid "Defining Python Source Code Encodings"
msgstr "Python ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°"

#: ../../library/importlib.rst:50
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../../library/importlib.rst:50
msgid "New Import Hooks"
msgstr "æ–°ã—ã„ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ•ãƒƒã‚¯"

#: ../../library/importlib.rst:53
msgid ":pep:`328`"
msgstr ":pep:`328`"

#: ../../library/importlib.rst:53
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "è¤‡æ•°è¡Œã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¨ã€çµ¶å¯¾/ç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆ"

#: ../../library/importlib.rst:56
msgid ":pep:`366`"
msgstr ":pep:`366`"

#: ../../library/importlib.rst:56
msgid "Main module explicit relative imports"
msgstr "main ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ˜ç¤ºçš„ãªç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆ"

#: ../../library/importlib.rst:59
msgid ":pep:`420`"
msgstr ":pep:`420`"

#: ../../library/importlib.rst:59
msgid "Implicit namespace packages"
msgstr "æš—é»™çš„ãªåå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸"

#: ../../library/importlib.rst:62
msgid ":pep:`451`"
msgstr ":pep:`451`"

#: ../../library/importlib.rst:62
msgid "A ModuleSpec Type for the Import System"
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®ãŸã‚ã® ModuleSpec å‹"

#: ../../library/importlib.rst:65
msgid ":pep:`488`"
msgstr ":pep:`488`"

#: ../../library/importlib.rst:65
msgid "Elimination of PYO files"
msgstr "PYO ãƒ•ã‚¡ã‚¤ãƒ«ã®æ’¤å»ƒ"

#: ../../library/importlib.rst:68
msgid ":pep:`489`"
msgstr ":pep:`489`"

#: ../../library/importlib.rst:68
msgid "Multi-phase extension module initialization"
msgstr "è¤‡æ•°ãƒ•ã‚§ãƒ¼ã‚ºã§ã®æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–"

#: ../../library/importlib.rst:71
msgid ":pep:`3120`"
msgstr ":pep:`3120`"

#: ../../library/importlib.rst:71
msgid "Using UTF-8 as the Default Source Encoding"
msgstr "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚½ãƒ¼ã‚¹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¨ã—ã¦ UTF-8 ã‚’ä½¿ç”¨"

#: ../../library/importlib.rst:73
msgid ":pep:`3147`"
msgstr ":pep:`3147`"

#: ../../library/importlib.rst:74
msgid "PYC Repository Directories"
msgstr "PYC ãƒªãƒã‚¸ãƒˆãƒªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª"

#: ../../library/importlib.rst:78
msgid "Functions"
msgstr "é–¢æ•°"

#: ../../library/importlib.rst:82
msgid "An implementation of the built-in :func:`__import__` function."
msgstr "çµ„ã¿è¾¼ã¿ã® :func:`__import__` é–¢æ•°ã®å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:85
msgid ""
"Programmatic importing of modules should use :func:`import_module` instead "
"of this function."
msgstr "ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã¯ã“ã®é–¢æ•°ã®ä»£ã‚ã‚Šã« :func:`import_module` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/importlib.rst:90
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set"
" to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚*name* å¼•æ•°ã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’çµ¶å¯¾ã¾ãŸã¯ç›¸å¯¾è¡¨ç¾ (ä¾‹ãˆã° ``pkg.mod`` ã¾ãŸã¯ "
"``..mod``) ã§æŒ‡å®šã—ã¾ã™ã€‚name ãŒç›¸å¯¾è¡¨ç¾ã§ä¸ãˆã‚‰ã‚ŒãŸã‚‰ã€*package* "
"å¼•æ•°ã‚’ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åã‚’è§£æ±ºã™ã‚‹ãŸã‚ã®ã‚¢ãƒ³ã‚«ãƒ¼ã¨ãªã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®åå‰ã«è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ (ä¾‹ãˆã° ``import_module('..mod', "
"'pkg.subpkg')`` ã¯ ``pkg.mod`` ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™)ã€‚"

#: ../../library/importlib.rst:98
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around "
":func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`. The most important difference "
"between these two functions is that :func:`import_module` returns the "
"specified package or module (e.g. ``pkg.mod``), while :func:`__import__` "
"returns the top-level package or module (e.g. ``pkg``)."
msgstr ""
":func:`import_module` é–¢æ•°ã¯ :func:`importlib.__import__` "
"ã‚’å˜ç´”åŒ–ã™ã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼ã¨ã—ã¦åƒãã¾ã™ã€‚ã¤ã¾ã‚Šã€ã“ã®é–¢æ•°ã®ã™ã¹ã¦ã®æ„å‘³ã¯ :func:`importlib.__import__` "
"ã‹ã‚‰å—ã‘ç¶™ã„ã§ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®2ã¤ã®é–¢æ•°ã®æœ€ã‚‚é‡è¦ãªé•ã„ã¯ã€ :func:`import_module` ãŒæŒ‡å®šã•ã‚ŒãŸãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (ä¾‹ãˆã° "
"``pkg.mod``) ã‚’è¿”ã™ã®ã«å¯¾ã—ã€ :func:`__import__` ã¯ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (ä¾‹ãˆã° ``pkg``) "
"ã‚’è¿”ã™ã“ã¨ã§ã™ã€‚"

#: ../../library/importlib.rst:105
msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may "
"need to call :func:`invalidate_caches` in order for the new module to be "
"noticed by the import system."
msgstr ""
"ã‚‚ã—ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‹•çš„ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã„ã¦ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã®å®Ÿè¡Œé–‹å§‹å¾Œã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä½œæˆã•ã‚ŒãŸ (ä¾‹ãˆã°ã€ Python ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ãŸ) "
"å ´åˆã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ãŒæ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã€ :func:`invalidate_caches` ã‚’å‘¼ã¶å¿…è¦ãŒã‚ã‚‹ã§ã—ã‚‡ã†ã€‚"

#: ../../library/importlib.rst:110
msgid "Parent packages are automatically imported."
msgstr "è¦ªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯è‡ªå‹•çš„ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:115
msgid ""
"Find the loader for a module, optionally within the specified *path*. If the"
" module is in :attr:`sys.modules`, then ``sys.modules[name].__loader__`` is "
"returned (unless the loader would be ``None`` or is not set, in which case "
":exc:`ValueError` is raised). Otherwise a search using :attr:`sys.meta_path`"
" is done. ``None`` is returned if no loader is found."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ­ãƒ¼ãƒ€ãƒ¼ã‚’ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§æŒ‡å®šã•ã‚ŒãŸ *path* å†…ã‹ã‚‰ã€æ¤œç´¢ã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ :attr:`sys.modules` ã«ã‚ã‚Œã°ã€ "
"``sys.modules[name].__loader__`` ãŒè¿”ã•ã‚Œã¾ã™ (ãŸã ã—ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒ ``None`` ã§ã‚ã‚‹ã‹è¨­å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã° "
":exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™)ã€‚ãªã‘ã‚Œã°ã€ :attr:`sys.meta_path` "
"ã‚’ä½¿ã£ãŸæ¤œç´¢ãŒãªã•ã‚Œã¾ã™ã€‚ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã° ``None`` ãŒè¿”ã‚Šã¾ã™ã€‚"

#: ../../library/importlib.rst:121
msgid ""
"A dotted name does not have its parents implicitly imported as that requires"
" loading them and that may not be desired. To properly import a submodule "
"you will need to import all parent packages of the submodule and use the "
"correct argument to *path*."
msgstr ""
"ãƒ‰ãƒƒãƒˆã®ã¤ã„ãŸåå‰è¡¨è¨˜ã¯ã€è¦ªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ­ãƒ¼ãƒ‰ãŒå¿…è¦ãªã¨ãã«æš—é»™ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ãªã„ã®ã§ã€æœ›ã¾ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚\n"
"ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’é©åˆ‡ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã«ã¯ã€ãã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å…¨ã¦ã®è¦ªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã€ *path* ã«æ­£ã—ã„å¼•æ•°ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/importlib.rst:128
msgid ""
"If ``__loader__`` is not set, raise :exc:`ValueError`, just like when the "
"attribute is set to ``None``."
msgstr ""
"``__loader__`` ãŒ set ã§ãªã„å ´åˆã€``None`` ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã¨ãã¨åŒæ§˜ã« :exc:`ValueError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:132
msgid "Use :func:`importlib.util.find_spec` instead."
msgstr "ä»£ã‚ã‚Šã« :func:`importlib.util.find_spec` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/importlib.rst:137
msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are"
" created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""
":data:`sys.meta_path` ã«ä¿å­˜ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã®å†…éƒ¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹ã«ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒ "
"``invalidate_caches()`` "
"ã‚’å®Ÿè£…ã—ã¦ã„ã‚Œã°ã€ç„¡åŠ¹åŒ–ã‚’è¡Œã†ãŸã‚ã«ãã‚ŒãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒæ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å­˜åœ¨ã«æ°—ã¥ãã“ã¨ã‚’ä¿è¨¼ã—ã¦ã„ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡Œä¸­ã«ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä½œæˆã¾ãŸã¯ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚ŒãŸãªã‚‰ã€ã“ã®é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¹ãã§ã™ã€‚"

#: ../../library/importlib.rst:147
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (which can be different if re-importing "
"causes a different object to be placed in :data:`sys.modules`)."
msgstr ""
"ä»¥å‰ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸ *module* "
"ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚å¼•æ•°ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã‘ã‚Œã°ãªã‚‰ãšã€ã—ãŸãŒã£ã¦ãã‚Œä»¥å‰ã«å¿…ãšã‚¤ãƒ³ãƒãƒ¼ãƒˆã«æˆåŠŸã—ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®é–¢æ•°ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¤–éƒ¨ã‚¨ãƒ‡ã‚£ã‚¿ã§ç·¨é›†ã—ã¦ã„ã¦"
" Python ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã‹ã‚‰é›¢ã‚Œã‚‹ã“ã¨ãªãæ–°ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è©¦ã—ãŸã„éš›ã«ä¾¿åˆ©ã§ã™ã€‚æˆ»ã‚Šå€¤ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ "
"(ã‚‚ã—å†ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒç•°ãªã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :data:`sys.modules` ã«é…ç½®ã—ãŸã‚‰ã€å…ƒã® *module* ã¨ã¯ç•°ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚)"

#: ../../library/importlib.rst:154
msgid "When :func:`reload` is executed:"
msgstr ":func:`reload` ãŒå®Ÿè¡Œã•ã‚ŒãŸå ´åˆ:"

#: ../../library/importlib.rst:156
msgid ""
"Python module's code is recompiled and the module-level code re-executed, "
"defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the module."
"  The ``init`` function of extension modules is not called a second time."
msgstr ""
"Python "
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã¯å†ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®ã‚³ãƒ¼ãƒ‰ãŒå†åº¦å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è¾æ›¸ä¸­ã«ã‚ã‚‹ä½•ã‚‰ã‹ã®åå‰ã«çµã³ä»˜ã‘ã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æœ€åˆã«ãƒ­ãƒ¼ãƒ‰ã—ãŸã¨ãã®"
" :term:`ãƒ­ãƒ¼ãƒ€ãƒ¼ <loader>` ã‚’å†åˆ©ç”¨ã—ã¦æ–°ãŸã«å®šç¾©ã•ã‚Œã¾ã™ã€‚æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``init`` "
"é–¢æ•°ãŒäºŒåº¦å‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:162
msgid ""
"As with all other objects in Python the old objects are only reclaimed after"
" their reference counts drop to zero."
msgstr "Python ã«ãŠã‘ã‚‹ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒæ§˜ã€ä»¥å‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ãƒ¢ãƒªé ˜åŸŸã¯ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒã‚¼ãƒ­ã«ãªã‚‰ãªã„ã‹ãã‚Šå†åˆ©ç”¨ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:165
msgid ""
"The names in the module namespace are updated to point to any new or changed"
" objects."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åå‰ç©ºé–“å†…ã®åå‰ã¯æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ã¾ãŸã¯æ›´æ–°ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) ã‚’æŒ‡ã™ã‚ˆã†æ›´æ–°ã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:168
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"ä»¥å‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ (å¤–éƒ¨ã®ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãªã©ã‹ã‚‰ã®) "
"å‚ç…§ã‚’å—ã‘ã¦ã„ã‚‹å ´åˆã€ãã‚Œã‚‰ã‚’æ–°ãŸãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å†æŸç¸›ã—ç›´ã™ã“ã¨ã¯ãªã„ã®ã§ã€å¿…è¦ãªã‚‰è‡ªåˆ†ã§åå‰ç©ºé–“ã‚’æ›´æ–°ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:172
msgid "There are a number of other caveats:"
msgstr "ã„ãã¤ã‹è£œè¶³èª¬æ˜ãŒã‚ã‚Šã¾ã™:"

#: ../../library/importlib.rst:174
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå†ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸéš›ã€ãã®è¾æ›¸ (ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’å«ã¿ã¾ã™) "
"ã¯ãã®ã¾ã¾æ®‹ã‚Šã¾ã™ã€‚åå‰ã®å†å®šç¾©ã‚’è¡Œã†ã¨ã€ä»¥å‰ã®å®šç¾©ã‚’ä¸Šæ›¸ãã™ã‚‹ã®ã§ã€ä¸€èˆ¬çš„ã«ã¯å•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æ–°ãŸãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§å®šç¾©ã•ã‚ŒãŸåå‰ã‚’å®šç¾©ã—ã¦ã„ãªã„å ´åˆã€å¤ã„å®šç¾©ãŒãã®ã¾ã¾æ®‹ã‚Šã¾ã™ã€‚è¾æ›¸ãŒã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç¶­æŒã—ã¦ã„ã‚Œã°ã€ã“ã®æ©Ÿèƒ½ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æœ‰åŠ¹æ€§ã‚’å¼•ãå‡ºã™ãŸã‚ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™"
" --- ã¤ã¾ã‚Šã€ :keyword:`try` æ–‡ã‚’ä½¿ãˆã°ã€å¿…è¦ã«å¿œã˜ã¦ãƒ†ãƒ¼ãƒ–ãƒ«ãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã—ã€ãã®åˆæœŸåŒ–ã‚’é£›ã°ã™ã“ã¨ãŒã§ãã¾ã™::"

#: ../../library/importlib.rst:188
msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and other "
"key modules is not recommended.  In many cases extension modules are not "
"designed to be initialized more than once, and may fail in arbitrary ways "
"when reloaded."
msgstr ""
"çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„å‹•çš„ã«ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å†ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ã¯ã€ä¸€èˆ¬çš„ã«ãã‚Œã»ã©ä¾¿åˆ©ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ :mod:`sys`, "
":mod:`__main__`, :mod:`builtins` ã‚„ãã®ä»–é‡è¦ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†ãƒ­ãƒ¼ãƒ‰ã¯ãŠå‹§ã‚å‡ºæ¥ã¾ã›ã‚“ã€‚å¤šãã®å ´åˆã€æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ 1"
" åº¦ä»¥ä¸ŠåˆæœŸåŒ–ã•ã‚Œã‚‹ã‚ˆã†ã«ã¯è¨­è¨ˆã•ã‚Œã¦ãŠã‚‰ãšã€å†ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå ´åˆã«ã¯ä½•ã‚‰ã‹ã®ç†ç”±ã§å¤±æ•—ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:194
msgid ""
"If a module imports objects from another module using :keyword:`from` ... "
":keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`from` statement, another is to use :keyword:`import` "
"and qualified names (*module.name*) instead."
msgstr ""
"ä¸€æ–¹ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ :keyword:`from` ... :keyword:`import` ... "
"ã‚’ä½¿ã£ã¦ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»–æ–¹ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãªã‚‰ã€ä»–æ–¹ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ :func:`reload` "
"ã§å‘¼ã³å‡ºã—ã¦ã‚‚ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†å®šç¾©ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ --- ã“ã®å•é¡Œã‚’å›é¿ã™ã‚‹ä¸€ã¤ã®æ–¹æ³•ã¯ã€ "
":keyword:`from` æ–‡ã‚’å†åº¦å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã€ã‚‚ã†ä¸€ã¤ã®æ–¹æ³•ã¯ :keyword:`from` æ–‡ã®ä»£ã‚ã‚Šã« "
":keyword:`import` ã¨é™å®šçš„ãªåå‰ (*module.name*) ã‚’ä½¿ã†ã“ã¨ã§ã™ã€‚"

#: ../../library/importlib.rst:200
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"ã‚ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¦ã„ã‚‹å ´åˆã€ãã®ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†ãƒ­ãƒ¼ãƒ‰ã¯ãã‚Œã‚‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ã«å½±éŸ¿ã—ã¾ã›ã‚“ "
"--- ãã‚Œã‚‰ã¯å¤ã„ã‚¯ãƒ©ã‚¹å®šç¾©ã‚’ä½¿ã„ç¶šã‘ã¾ã™ã€‚ã“ã‚Œã¯æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã®å ´åˆã§ã‚‚åŒã˜ã§ã™ã€‚"

#: ../../library/importlib.rst:209
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ":mod:`importlib.abc` -- ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«é–¢é€£ã™ã‚‹æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹"

#: ../../library/importlib.rst:214
msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/importlib/abc.py`"

#: ../../library/importlib.rst:219
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base"
" classes are also provided to help in implementing the core ABCs."
msgstr ""
":mod:`importlib.abc` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ :keyword:`import` "
"ã«ä½¿ã‚ã‚Œã‚‹ã™ã¹ã¦ã®ã‚³ã‚¢æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹å«ã¿ã¾ã™ã€‚ã‚³ã‚¢æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã®å®Ÿè£…ã‚’åŠ©ã‘ã‚‹ãŸã‚ã«ã€ã‚³ã‚¢æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚‚ã„ãã¤ã‹æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/importlib.rst:223
msgid "ABC hierarchy::"
msgstr "æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹éšå±¤::"

#: ../../library/importlib.rst:239
msgid "An abstract base class representing a :term:`finder`."
msgstr ":term:`finder` ã‚’è¡¨ã™æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/importlib.rst:241
msgid "Use :class:`MetaPathFinder` or :class:`PathEntryFinder` instead."
msgstr "ä»£ã‚ã‚Šã« :class:`MetaPathFinder` ã¾ãŸã¯ :class:`PathEntryFinder` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/importlib.rst:246
msgid ""
"An abstract method for finding a :term:`loader` for the specified module.  "
"Originally specified in :pep:`302`, this method was meant for use in "
":data:`sys.meta_path` and in the path-based import subsystem."
msgstr ""

#: ../../library/importlib.rst:250
msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`."
msgstr "å‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã« :exc:`NotImplementedError` ã‚’é€å‡ºã™ã‚‹ä»£ã‚ã‚Šã« ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:257
msgid ""
"An abstract base class representing a :term:`meta path finder`. For "
"compatibility, this is a subclass of :class:`Finder`."
msgstr ""
":term:`meta path finder` ã‚’è¡¨ã™æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚äº’æ›æ€§ã®ãŸã‚ã€ã“ã‚Œã¯ :class:`Finder` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã™ã€‚"

#: ../../library/importlib.rst:264
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be ``None``.  "
"Otherwise, this is a search for a subpackage or module and *path* will be "
"the value of :attr:`__path__` from the parent package. If a spec cannot be "
"found, ``None`` is returned. When passed in, ``target`` is a module object "
"that the finder may use to make a more educated guess about what spec to "
"return."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å¯¾å¿œã™ã‚‹ :term:`ã‚¹ãƒšãƒƒã‚¯ <module spec>` ã‚’æ¤œç´¢ã™ã‚‹æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã€‚ã‚‚ã—ã“ã‚ŒãŒãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãªã‚‰ã€ "
"*path* ã¯ ``None`` ã§ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ã“ã‚Œã¯ã‚µãƒ–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¾ãŸã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãŸã‚ã®æ¤œç´¢ã§ã€ *path* ã¯è¦ªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® "
":attr:`__path__` ã®å€¤ã§ã™ã€‚ã‚¹ãƒšãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã° ``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚ ``target`` "
"ã¯ã€æ¸¡ã•ã‚Œã¦ããŸãªã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã“ã‚Œã¯ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒã©ã®ã‚ˆã†ãªã‚¹ãƒšãƒƒã‚¯ã‚’è¿”ã›ã°ã‚ˆã„ã‹æ¨æ¸¬ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:276
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  If "
"this is a top-level import, *path* will be ``None``. Otherwise, this is a "
"search for a subpackage or module and *path* will be the value of "
":attr:`__path__` from the parent package. If a loader cannot be found, "
"``None`` is returned."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :term:`ãƒ­ãƒ¼ãƒ€ãƒ¼ <loader>` ã‚’æ¤œç´¢ã™ã‚‹ãŸã‚ã®ãƒ¬ã‚¬ã‚·ãƒ¼ãªãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ã“ã‚ŒãŒãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãªã‚‰ã€ "
"*path* ã¯ ``None`` ã«ãªã‚Šã¾ã™ã€‚ãã†ã§ãªã‘ã‚Œã°ã€ã“ã‚Œã¯ã‚µãƒ–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¾ãŸã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ¤œç´¢ã§ã€ *path* ã¯è¦ªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® "
":attr:`__path__` ã®å€¤ã«ãªã‚Šã¾ã™ã€‚ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ã€ ``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:282
msgid ""
"If :meth:`find_spec` is defined, backwards-compatible functionality is "
"provided."
msgstr ":meth:`find_spec` ãŒå®šç¾©ã•ã‚ŒãŸå ´åˆã€å¾Œæ–¹äº’æ›ãªæ©Ÿèƒ½ãŒæä¾›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:285
msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`. "
"Can use :meth:`find_spec` to provide functionality."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚ŒãŸå ´åˆ :exc:`NotImplementedError` ã‚’æŠ•ã’ã‚‹ä»£ã‚ã‚Šã« ``None`` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹ã®ã«"
" :meth:`find_spec` ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚"

#: ../../library/importlib.rst:290 ../../library/importlib.rst:343
#: ../../library/importlib.rst:351 ../../library/importlib.rst:847
msgid "Use :meth:`find_spec` instead."
msgstr "ä»£ã‚ã‚Šã« :meth:`find_spec` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/importlib.rst:295
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"ã“ã®ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹å†…éƒ¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒã‚ã‚Œã°ç„¡åŠ¹ã«ã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ :data:`sys.meta_path` "
"ä¸Šã®ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹åŒ–ã™ã‚‹éš›ã€ :func:`importlib.invalidate_caches` ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:299
msgid "Returns ``None`` when called instead of ``NotImplemented``."
msgstr "å‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã« ``NotImplemented`` ã‚’é€å‡ºã™ã‚‹ä»£ã‚ã‚Šã« ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:305
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by "
":class:`PathFinder`. This ABC is a subclass of :class:`Finder` for "
"compatibility reasons only."
msgstr ""
":term:`ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path entry finder>` ã‚’è¡¨ã™æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ "
":class:`MetaPathFinder` ã¨ä¼¼ã¦ã„ã‚‹ã¨ã“ã‚ãŒã‚ã‚Šã¾ã™ãŒã€ ``PathEntryFinder`` ã¯ "
":class:`PathFinder` "
"ã®ä¸ãˆã‚‹ãƒ‘ã‚¹ã«åŸºã¥ãã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚µãƒ–ã‚·ã‚¹ãƒ†ãƒ ã®ä¸­ã§ã®ã¿ä½¿ã†ã“ã¨ãŒæ„å›³ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã¯äº’æ›æ€§ã®ç†ç”±ã ã‘ã®ãŸã‚ã«ã€ "
":class:`Finder` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã«ã—ã¦ã‚ã‚Šã¾ã™ã€‚"

#: ../../library/importlib.rst:315
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the "
":term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that "
"the finder may use to make a more educated guess about what spec to return."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å¯¾å¿œã™ã‚‹ :term:`ã‚¹ãƒšãƒƒã‚¯ <module spec>` ã‚’æ¤œç´¢ã™ã‚‹æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã€‚ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯ã€å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã‚‹ "
":term:`ãƒ‘ã‚¹ãƒ»ã‚¨ãƒ³ãƒˆãƒªãƒ¼ <path entry>` å†…ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã ã‘ã‚’æ¤œç´¢ã—ã¾ã™ã€‚ã‚¹ãƒšãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã° ``None`` ãŒè¿”ã•ã‚Œã¾ã™ã€‚"
" ``target`` ã¯ã€æ¸¡ã•ã‚Œã¦ããŸãªã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ã“ã‚Œã¯ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒã©ã®ã‚ˆã†ãªã‚¹ãƒšãƒƒã‚¯ã‚’è¿”ã›ã°ã‚ˆã„ã‹æ¨æ¸¬ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:326
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  "
"Returns a 2-tuple of ``(loader, portion)`` where ``portion`` is a sequence "
"of file system locations contributing to part of a namespace package. The "
"loader may be ``None`` while specifying ``portion`` to signify the "
"contribution of the file system locations to a namespace package. An empty "
"list can be used for ``portion`` to signify the loader is not part of a "
"namespace package. If ``loader`` is ``None`` and ``portion`` is the empty "
"list then no loader or location for a namespace package were found (i.e. "
"failure to find anything for the module)."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :term:`ãƒ­ãƒ¼ãƒ€ãƒ¼ <loader>` ã‚’æ¤œç´¢ã™ã‚‹æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ ``(loader, portion)`` ã® "
"2-ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ãŸã ã— ``portion`` ã¯åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®éƒ¨åˆ†ã«å¯„ä¸ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®å ´æ‰€ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã™ã€‚ loader "
"ã¯åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¸ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä¸Šã®å ´æ‰€ã®å¯„ä¸ã‚’è¡¨ã™ ``portion`` ã‚’æ˜è¨˜ã™ã‚‹ã¨ã ``None`` ã«ã§ãã¾ã™ã€‚loader "
"ãŒåå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ä¸€éƒ¨ã§ã¯ãªã„ã“ã¨ã‚’æ˜è¨˜ã™ã‚‹ã¨ã ``portion`` ã«ç©ºã®ãƒªã‚¹ãƒˆãŒä½¿ãˆã¾ã™ã€‚ ``loader`` ãŒ ``None`` ã§ "
"``portion`` ãŒç©ºã®ãƒªã‚¹ãƒˆãªã‚‰ã€åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ãƒ­ãƒ¼ãƒ€ãƒ¼ã‚„å ´æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ (ã™ãªã‚ã¡ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½•ã‚‚è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ)ã€‚"

#: ../../library/importlib.rst:336
msgid ""
"If :meth:`find_spec` is defined then backwards-compatible functionality is "
"provided."
msgstr ":meth:`find_spec` ãŒå®šç¾©ã•ã‚ŒãŸå ´åˆã€å¾Œæ–¹äº’æ›ãªæ©Ÿèƒ½ãŒæä¾›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:339
msgid ""
"Returns ``(None, [])`` instead of raising :exc:`NotImplementedError`. Uses "
":meth:`find_spec` when available to provide functionality."
msgstr ""
":exc:`NotImplementedError` ã‚’é€å‡ºã™ã‚‹ä»£ã‚ã‚Šã« ``(None, [])`` ã‚’è¿”ã—ã¾ã™ã€‚æ©Ÿèƒ½ã‚’æä¾›ã§ãã‚‹å ´åˆ "
":meth:`find_spec` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:348
msgid ""
"A concrete implementation of :meth:`Finder.find_module` which is equivalent "
"to ``self.find_loader(fullname)[0]``."
msgstr ""
":meth:`Finder.find_module` ã®å…·è±¡å®Ÿè£…ã§ã€ ``self.find_loader(fullname)[0]`` ã¨ç­‰ä¾¡ã§ã™ã€‚"

#: ../../library/importlib.rst:356
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :meth:`PathFinder.invalidate_caches` when "
"invalidating the caches of all cached finders."
msgstr ""
"ã“ã®ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹å†…éƒ¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒã‚ã‚Œã°ç„¡åŠ¹ã«ã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã®ç„¡åŠ¹åŒ–ã™ã‚‹éš›ã€ "
":meth:`PathFinder.invalidate_caches` ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:363
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ":term:`loader` ã®æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ãƒ­ãƒ¼ãƒ€ãƒ¼ã®å³å¯†ãªå®šç¾©ã¯ :pep:`302` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/importlib.rst:368
msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹éš›ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ ``None`` "
"ã‚’æˆ»ã™ã“ã¨ãŒã§ãã€ãã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä½œæˆã®ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ãŒé©ç”¨ã•ã‚Œã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:374
msgid ""
"Starting in Python 3.6, this method will not be optional when "
":meth:`exec_module` is defined."
msgstr "Python 3.6 ã‹ã‚‰ã¯ã€ :meth:`exec_module` ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã¯ãªããªã‚Šã¾ã™ã€‚"

#: ../../library/importlib.rst:380
msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized "
"when ``exec_module()`` is called. When this method exists, "
":meth:`~importlib.abc.Loader.create_module` must be defined."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã¾ãŸã¯ãƒªãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹éš›ã«ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è‡ªèº«ã®åå‰ç©ºé–“ã®ä¸­ã§å®Ÿè¡Œã™ã‚‹æŠ½è±¡çš„ãªãƒ¡ã‚½ãƒƒãƒ‰ã€‚\n"
"``exec_module()`` ãŒå‘¼ã°ã‚Œã‚‹æ™‚ç‚¹ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã™ã§ã«åˆæœŸè¨­å®šã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\n"
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå­˜åœ¨ã™ã‚‹ã¨ãã¯ã€ :meth:`~importlib.abc.Loader.create_module` ã®å®šç¾©ãŒå¿…é ˆã§ã™ã€‚"

#: ../../library/importlib.rst:387
msgid ":meth:`~importlib.abc.Loader.create_module` must also be defined."
msgstr ":meth:`~importlib.abc.Loader.create_module` ã®å®šç¾©ãŒå¿…é ˆã¨ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/importlib.rst:392
msgid ""
"A legacy method for loading a module. If the module cannot be loaded, "
":exc:`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã®ãƒ¬ã‚¬ã‚·ãƒ¼ãªãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ­ãƒ¼ãƒ‰ã§ããªã‘ã‚Œã° :exc:`ImportError` "
"ã‚’é€å‡ºã—ã€ãƒ­ãƒ¼ãƒ‰ã§ãã‚Œã°ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:396
msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module"
" and insert it into :data:`sys.modules` before any loading begins, to "
"prevent recursion from the import. If the loader inserted a module and the "
"load fails, it must be removed by the loader from :data:`sys.modules`; "
"modules already in :data:`sys.modules` before the loader began execution "
"should be left alone (see :func:`importlib.util.module_for_loader`)."
msgstr ""
"è¦æ±‚ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæ—¢ã« :data:`sys.modules` "
"ã«å­˜åœ¨ã—ãŸãªã‚‰ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä½¿ã‚ã‚Œãƒªãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å­˜åœ¨ã—ãªã‘ã‚Œã°ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‹ã‚‰ã®å†å¸°ã‚’é˜²ããŸã‚ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ãƒ­ãƒ¼ãƒ‰ãŒå§‹ã¾ã‚‹å‰ã«æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆã—ã¦"
" :data:`sys.modules` ã«æŒ¿å…¥ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æŒ¿å…¥ã—ãŸå¾Œã«ãƒ­ãƒ¼ãƒ‰ãŒå¤±æ•—ã—ãŸãªã‚‰ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ "
":data:`sys.modules` ã‹ã‚‰å‰Šé™¤ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒå®Ÿè¡Œã‚’å§‹ã‚ã‚‹å‰ã«æ—¢ã« :data:`sys.modules` "
"ã«ã‚ã£ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ãã®ã¾ã¾ã«ã—ã¾ã™ (:func:`importlib.util.module_for_loader` ã‚’å‚ç…§ã—ã¦ãã ã•ã„)ã€‚"

#: ../../library/importlib.rst:405
msgid ""
"The loader should set several attributes on the module. (Note that some of "
"these attributes can change when a module is reloaded):"
msgstr ""
"ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã„ãã¤ã‹ã®å±æ€§ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚(ãªãŠã€ã“ã‚Œã‚‰ã®å±æ€§ã«ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒªãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸéš›ã«å¤‰åŒ–ã™ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã™):"

#: ../../library/importlib.rst:410
msgid ":attr:`__name__`"
msgstr ":attr:`__name__`"

#: ../../library/importlib.rst:410
msgid "The name of the module."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã§ã™ã€‚"

#: ../../library/importlib.rst:414
msgid ":attr:`__file__`"
msgstr ":attr:`__file__`"

#: ../../library/importlib.rst:413
msgid ""
"The path to where the module data is stored (not set for built-in modules)."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‡ãƒ¼ã‚¿ãŒä¿å­˜ã•ã‚Œã¦ã„ã‚‹å ´æ‰€ã¸ã®ãƒ‘ã‚¹ã§ã™ (çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯è¨­å®šã•ã‚Œã¾ã›ã‚“)ã€‚"

#: ../../library/importlib.rst:418
msgid ":attr:`__cached__`"
msgstr ":attr:`__cached__`"

#: ../../library/importlib.rst:417
msgid ""
"The path to where a compiled version of the module is/should be stored (not "
"set when the attribute would be inappropriate)."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸç‰ˆãŒä¿å­˜ã•ã‚Œã¦ã„ã‚‹ (ã¹ã) å ´æ‰€ã¸ã®ãƒ‘ã‚¹ã§ã™ (ã“ã®å±æ€§ãŒé©åˆ‡ã§ãªã„ã¨ãã«ã¯è¨­å®šã•ã‚Œã¾ã›ã‚“)ã€‚"

#: ../../library/importlib.rst:422
msgid ":attr:`__path__`"
msgstr ":attr:`__path__`"

#: ../../library/importlib.rst:421
msgid ""
"A list of strings specifying the search path within a package. This "
"attribute is not set on modules."
msgstr "ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å†…ã®æ¤œç´¢ãƒ‘ã‚¹ã‚’æŒ‡å®šã™ã‚‹æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã§ã™ã€‚ã“ã®å±æ€§ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯è¨­å®šã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:428
msgid ":attr:`__package__`"
msgstr ":attr:`__package__`"

#: ../../library/importlib.rst:425
msgid ""
"The parent package for the module/package. If the module is top-level then "
"it has a value of the empty string. The "
":func:`importlib.util.module_for_loader` decorator can handle the details "
"for :attr:`__package__`."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®è¦ªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã™ã€‚ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãªã‚‰ã€ç©ºæ–‡å­—åˆ—ã®å€¤ã‚’ã¨ã‚Šã¾ã™ã€‚ "
":func:`importlib.util.module_for_loader` ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã§ã€:attr:`__package__` "
"ã®è©³ç´°ã‚’æ‰±ãˆã¾ã™ã€‚"

#: ../../library/importlib.rst:433
msgid ":attr:`__loader__`"
msgstr ":attr:`__loader__`"

#: ../../library/importlib.rst:431
msgid ""
"The loader used to load the module. The "
":func:`importlib.util.module_for_loader` decorator can handle the details "
"for :attr:`__package__`."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã®ã«ä½¿ã‚ã‚ŒãŸãƒ­ãƒ¼ãƒ€ãƒ¼ã§ã™ã€‚ :func:`importlib.util.module_for_loader` ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã§ã€ "
":attr:`__package__` ã®è©³ç´°ã‚’æ‰±ãˆã¾ã™ã€‚"

#: ../../library/importlib.rst:435
msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr ":meth:`exec_module` ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã€å¾Œæ–¹äº’æ›ãªæ©Ÿèƒ½ãŒæä¾›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:438
msgid ""
"Raise :exc:`ImportError` when called instead of :exc:`NotImplementedError`. "
"Functionality provided when :meth:`exec_module` is available."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚ŒãŸæ™‚ã«ã€ :exc:`NotImplementedError` ã®ä»£ã‚ã‚Šã« :exc:`ImportError` ã‚’é€å‡ºã—ã¾ã™ã€‚ "
":meth:`exec_module` ãŒåˆ©ç”¨å¯èƒ½ãªæ™‚ã¯ã€ã“ã®æ©Ÿèƒ½ã¯æä¾›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:443
msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and "
":meth:`create_module`).  Loaders should implement it instead of "
"load_module().  The import machinery takes care of all the other "
"responsibilities of load_module() when exec_module() is implemented."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã®æ¨å¥¨ã•ã‚Œã‚‹ API ã¯ã€ :meth:`exec_module` (ãŠã‚ˆã³ :meth:`create_module`) "
"ã§ã™ã€‚ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ load_module() ã®ä»£ã‚ã‚Šã«ãã‚Œã‚’å®Ÿè£…ã™ã‚‹ã¹ãã§ã™ã€‚ exec_module() ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ "
"load_module() ã®ä»–ã®ã™ã¹ã¦ã®è²¬ä»»ã‚’è‚©ä»£ã‚ã‚Šã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:452
msgid ""
"A legacy method which when implemented calculates and returns the given "
"module's repr, as a string. The module type's default repr() will use the "
"result of this method as appropriate."
msgstr ""
"å®Ÿè£…ã•ã‚Œã¦ã„ãŸå ´åˆã€ä¸ãˆã‚‰ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® repr ã‚’è¨ˆç®—ã—ã¦æ–‡å­—åˆ—ã¨ã—ã¦è¿”ã™ãŸã‚ã®ãƒ¬ã‚¬ã‚·ãƒ¼ãªãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å‹ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® repr() "
"ã¯ã€å¿…è¦ã«å¿œã˜ã¦ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®çµæœã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/importlib.rst:458
msgid "Made optional instead of an abstractmethod."
msgstr "æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ãªãã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/importlib.rst:461
msgid "The import machinery now takes care of this automatically."
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ã“ã‚Œã‚’è‡ªå‹•çš„ã«è€ƒæ…®ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/importlib.rst:467
msgid ""
"An abstract base class for a :term:`loader` which implements the optional "
":pep:`302` protocol for loading arbitrary resources from the storage back-"
"end."
msgstr ""
":term:`loader` ã®æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã€ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰ä»»æ„ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® :pep:`302` "
"ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:473
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary"
" data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's :attr:`__file__` "
"attribute or an item from a package's :attr:`__path__`."
msgstr ""
"*path* "
"ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã®ãƒã‚¤ãƒˆåˆ—ã‚’è¿”ã™æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ä»»æ„ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿ç®¡ã§ãã‚‹ãƒ•ã‚¡ã‚¤ãƒ«çš„ãªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’ã‚‚ã¤ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ã€ã“ã®æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã€ä¿ç®¡ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã•ã›ã‚‹ã‚ˆã†ã«ã§ãã¾ã™ã€‚"
" *path* ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã° :exc:`OSError` ã‚’é€å‡ºã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ *path* ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® "
":attr:`__file__` å±æ€§ã‚’ä½¿ã£ã¦ã€ã¾ãŸã¯ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® :attr:`__path__` ã®è¦ç´ ã‚’ä½¿ã£ã¦ã€æ§‹æˆã•ã‚Œã‚‹ã“ã¨ãŒæœŸå¾…ã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:481
msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` ã®ä»£ã‚ã‚Šã« :exc:`OSError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:487
msgid ""
"An abstract base class for a :term:`loader` which implements the optional "
":pep:`302` protocol for loaders that inspect modules."
msgstr ""
":term:`loader` ã®æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¤œæŸ»ã™ã‚‹ãŸã‚ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® :pep:`302` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:492
msgid ""
"Return the code object for a module, or ``None`` if the module does not have"
" a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :class:`code` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã‹ã€ (ä¾‹ãˆã°çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å ´åˆã«) ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒãŸãªã‘ã‚Œã° "
"``None`` ã‚’è¿”ã—ã¾ã™ã€‚è¦æ±‚ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒè¦‹ã¤ã‘ã‚‰ã‚Œãªã‹ã£ãŸå ´åˆã¯ :exc:`ImportError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:498
msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ãŒã‚ã‚Šã¾ã™ãŒã€ã¨ã¯ã„ãˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ãŸã‚ã«ã€å¯èƒ½ãªã‚‰ã°ã‚ªãƒ¼ãƒãƒ©ã‚¤ãƒ‰ã—ãŸã»ã†ãŒè‰¯ã„ã§ã™ã€‚"

#: ../../library/importlib.rst:504
msgid "No longer abstract and a concrete implementation is provided."
msgstr "ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚‚ã¯ã‚„æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ãªãã€å…·è±¡å®Ÿè£…ãŒæä¾›ã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:509
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is"
" available (e.g. a built-in module). Raises :exc:`ImportError` if the loader"
" cannot find the module specified."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚½ãƒ¼ã‚¹ã‚’è¿”ã™æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ã“ã‚Œã¯èªè­˜ã•ã‚ŒãŸã™ã¹ã¦ã®è¡Œã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ã‚’ ``'\\n'`` æ–‡å­—ã«å¤‰æ›ã—ã€ :term:`universal "
"newlines` ã‚’ä½¿ã£ãŸãƒ†ã‚­ã‚¹ãƒˆæ–‡å­—åˆ—ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚åˆ©ç”¨ã§ãã‚‹ã‚½ãƒ¼ã‚¹ãŒãªã‘ã‚Œã° (ä¾‹ãˆã°çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«)ã€ ``None`` "
"ã‚’è¿”ã—ã¾ã™ã€‚æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ã€ :exc:`ImportError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:515 ../../library/importlib.rst:524
#: ../../library/importlib.rst:574
msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` ã®ä»£ã‚ã‚Šã« :exc:`ImportError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:520
msgid ""
"An abstract method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã‚ã‚Œã° True ã‚’è¿”ã—ã€ãã†ã§ãªã‘ã‚Œã° False ã‚’è¿”ã™æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ :term:`ãƒ­ãƒ¼ãƒ€ãƒ¼ <loader>` "
"ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œãªã‹ã£ãŸãªã‚‰ :exc:`ImportError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:529
msgid "Create a code object from Python source."
msgstr "Python ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚Šã¾ã™ã€‚"

#: ../../library/importlib.rst:531
msgid ""
"The *data* argument can be whatever the :func:`compile` function supports "
"(i.e. string or bytes). The *path* argument should be the \"path\" to where "
"the source code originated from, which can be an abstract concept (e.g. "
"location in a zip file)."
msgstr ""
"*data* å¼•æ•°ã¯ :func:`compile` é–¢æ•°ãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚‚ã® (ã™ãªã‚ã¡æ–‡å­—åˆ—ã‹ãƒã‚¤ãƒˆ) ãªã‚‰ä½•ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚*path* "
"å¼•æ•°ã¯ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®å…ƒã€…ã®å ´æ‰€ã¸ã® \"ãƒ‘ã‚¹\" ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ãŒã€æŠ½è±¡æ¦‚å¿µ (ä¾‹ãˆã° zip ãƒ•ã‚¡ã‚¤ãƒ«å†…ã®å ´æ‰€) ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:536
msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr ""
"çµæœã®ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã£ã¦ã€ ``exec(code, module.__dict__)`` ã‚’å‘¼ã¶ã“ã¨ã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã§ãã¾ã™ã€‚"

#: ../../library/importlib.rst:541
msgid "Made the method static."
msgstr "ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/importlib.rst:546
msgid "Implementation of :meth:`Loader.exec_module`."
msgstr ":meth:`Loader.exec_module` ã®å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:552
msgid "Implementation of :meth:`Loader.load_module`."
msgstr ":meth:`Loader.load_module` ã®å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:554
msgid "use :meth:`exec_module` instead."
msgstr "ä»£ã‚ã‚Šã« :meth:`exec_module` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/importlib.rst:560
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when"
" implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""
":class:`InspectLoader` "
"ã‹ã‚‰ç¶™æ‰¿ã•ã‚ŒãŸæŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã€å®Ÿè£…ã•ã‚Œã¦ã„ã‚Œã°ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨ã—ã¦å®Ÿè¡Œã™ã‚‹åŠ©ã‘ã«ãªã‚Šã¾ã™ã€‚ã“ã®æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® "
":pep:`302` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’è¡¨ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:566
msgid ""
"An abstract method that is to return the value of :attr:`__file__` for the "
"specified module. If no path is available, :exc:`ImportError` is raised."
msgstr ""
"æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :attr:`__file__` ã®å€¤ã‚’è¿”ã™æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚åˆ©ç”¨ã§ãã‚‹ãƒ‘ã‚¹ãŒãªã‘ã‚Œã°ã€ :exc:`ImportError` "
"ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:570
msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr ""
"ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ãŒåˆ©ç”¨ã§ãã‚‹ãªã‚‰ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ­ãƒ¼ãƒ‰ã«ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãŒä½¿ã‚ã‚ŒãŸã‹ã«ã‹ã‹ã‚ã‚‰ãšã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãã®ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/importlib.rst:580
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and "
":class:`ExecutionLoader`, providing concrete implementations of "
":meth:`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
":class:`ResourceLoader` ã¨ :class:`ExecutionLoader` ã‹ã‚‰ç¶™æ‰¿ã•ã‚ŒãŸæŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã€ "
":meth:`ResourceLoader.get_data` ãŠã‚ˆã³ :meth:`ExecutionLoader.get_filename` "
"ã®å…·è±¡å®Ÿè£…ã‚’æä¾›ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:584
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is"
" to handle. The *path* argument is the path to the file for the module."
msgstr ""
"*fullname* å¼•æ•°ã¯ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒè§£æ±ºã—ã‚ˆã†ã¨ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã€å®Œå…¨ã«è§£æ±ºã•ã‚ŒãŸåå‰ã§ã™ã€‚*path* å¼•æ•°ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã§ã™ã€‚"

#: ../../library/importlib.rst:591
msgid "The name of the module the loader can handle."
msgstr "ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒæ‰±ãˆã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã§ã™ã€‚"

#: ../../library/importlib.rst:595
msgid "Path to the file of the module."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã§ã™ã€‚"

#: ../../library/importlib.rst:599
msgid "Calls super's ``load_module()``."
msgstr "è¦ªã‚¯ãƒ©ã‚¹ã® ``load_module()`` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:601
msgid "Use :meth:`Loader.exec_module` instead."
msgstr "ä»£ã‚ã‚Šã« :meth:`Loader.exec_module` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/importlib.rst:606 ../../library/importlib.rst:1041
msgid "Returns :attr:`path`."
msgstr ":attr:`path` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:610
msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "*path* ã‚’ãƒã‚¤ãƒŠãƒªãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦èª­ã¿è¾¼ã¿ã€ãã®ãƒã‚¤ãƒˆåˆ—ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:615
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and "
":class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"ã‚½ãƒ¼ã‚¹ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰) ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ­ãƒ¼ãƒ‰ã‚’å®Ÿè£…ã™ã‚‹æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯ã€ :class:`ResourceLoader` ã¨ "
":class:`ExecutionLoader` ã®ä¸¡æ–¹ã‚’ç¶™æ‰¿ã—ã€ä»¥ä¸‹ã®å®Ÿè£…ãŒå¿…è¦ã§ã™:"

#: ../../library/importlib.rst:619
msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

#: ../../library/importlib.rst:622
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

#: ../../library/importlib.rst:621
msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr "ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã®ã¿ã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã‚½ãƒ¼ã‚¹ãªã—ã®ãƒ­ãƒ¼ãƒ‰ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:624
msgid ""
"The abstract methods defined by this class are to add optional bytecode file"
" support. Not implementing these optional methods (or causing them to raise "
":exc:`NotImplementedError`) causes the loader to only work with source code."
" Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"ã“ã®ã‚¯ãƒ©ã‚¹ã§ã“ã‚Œã‚‰ã®æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§ã€ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ ã§ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ãªã‘ã‚Œã° (ã¾ãŸã¯ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ"
" :exc:`NotImplementedError` "
"ã‚’é€å‡ºã™ã‚Œã°)ã€ã“ã®ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã«å¯¾ã—ã¦ã®ã¿åƒãã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ã‚½ãƒ¼ã‚¹ã¨ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ« "
"*ã®çµ„ã¿åˆã‚ã›* ã«å¯¾ã—ã¦åƒãã¾ã™ã€‚ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã®ã¿ã‚’ä¸ãˆãŸ *ã‚½ãƒ¼ã‚¹ã®ãªã„* ãƒ­ãƒ¼ãƒ‰ã¯èªã‚ã‚‰ã‚Œã¾ã›ã‚“ã€‚ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ Python "
"ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã‚‹è§£æã®å·¥ç¨‹ã‚’ãªãã—ã¦é€Ÿåº¦ã‚’ä¸Šã’ã‚‹æœ€é©åŒ–ã§ã™ã€‚ã§ã™ã‹ã‚‰ã€ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ç‰¹æœ‰ã® API ã¯å…¬é–‹ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:635
msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr "æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¹ã«ã¤ã„ã¦ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€ :class:`dict` ã‚’è¿”ã™ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ã‚µãƒãƒ¼ãƒˆã•ã‚Œã‚‹è¾æ›¸ã®ã‚­ãƒ¼ã¯:"

#: ../../library/importlib.rst:638
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr "``'mtime'`` (å¿…é ˆ): ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®æ›´æ–°æ™‚åˆ»ã‚’è¡¨ã™æ•´æ•°ã¾ãŸã¯æµ®å‹•å°æ•°ç‚¹æ•°ã§ã™ã€‚"

#: ../../library/importlib.rst:640
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (ä»»æ„): ãƒã‚¤ãƒˆæ•°ã§è¡¨ã—ãŸã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®ã‚µã‚¤ã‚ºã§ã™ã€‚"

#: ../../library/importlib.rst:642
msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr "æœªæ¥ã®æ‹¡å¼µã®ãŸã‚ã€è¾æ›¸å†…ã®ä»–ã®ã‚­ãƒ¼ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ãƒ‘ã‚¹ãŒæ‰±ãˆãªã‘ã‚Œã°ã€ :exc:`OSError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:647 ../../library/importlib.rst:660
msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` ã®ä»£ã‚ã‚Šã« :exc:`OSError` ã‚’é€å‡ºã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:652
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr "æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¹ã®æ›´æ–°æ™‚åˆ»ã‚’è¿”ã™ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚"

#: ../../library/importlib.rst:655
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. Raise"
" :exc:`OSError` if the path cannot be handled."
msgstr ""
"ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å»ƒæ­¢ã•ã‚Œã€ :meth:`path_stats` "
"ãŒæ¨å¥¨ã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€äº’æ›æ€§ã®ãŸã‚ç¾åœ¨ã‚‚åˆ©ç”¨ã§ãã¾ã™ã€‚ãƒ‘ã‚¹ãŒæ‰±ãˆãªã‘ã‚Œã°ã€ :exc:`OSError` "
"ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:665
msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã«æŒ‡å®šã•ã‚ŒãŸãƒã‚¤ãƒˆåˆ—ã‚’æ›¸ãè¾¼ã‚€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚å­˜åœ¨ã—ãªã„ä¸­é–“ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒã‚ã‚Œã°ã€è‡ªå‹•ã§ä½œæˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:669
msgid ""
"When writing to the path fails because the path is read-only "
"(:attr:`errno.EACCES`/:exc:`PermissionError`), do not propagate the "
"exception."
msgstr ""
"ãƒ‘ã‚¹ã¸ã®æ›¸ãè¾¼ã¿ãŒèª­ã¿å‡ºã—å°‚ç”¨ã®ãŸã‚ã«å¤±æ•—ã—ãŸã¨ã (:attr:`errno.EACCES`/:exc:`PermissionError`) "
"ã€ãã®ä¾‹å¤–ã‚’ä¼æ’­ã•ã›ã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:673
msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr "å‘¼ã°ã‚ŒãŸã¨ãã« :exc:`NotImplementedError` ã‚’é€å‡ºã™ã‚‹ã“ã¨ã¯æœ€æ—©ã‚ã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:678
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr ":meth:`InspectLoader.get_code` ã®å…·è±¡å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:682
msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr ":meth:`Loader.exec_module` ã®å…·è±¡å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:688
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr ":meth:`Loader.load_module` ã®å…·è±¡å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:690
msgid "Use :meth:`exec_module` instead."
msgstr "ä»£ã‚ã‚Šã« :meth:`exec_module` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/importlib.rst:695
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr ":meth:`InspectLoader.get_source` ã®å…·è±¡å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:699
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by "
":meth:`ExecutionLoader.get_filename`) is a file named ``__init__`` when the "
"file extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
":meth:`InspectLoader.is_package` ã®å…·è±¡å®Ÿè£…ã§ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€æ¬¡ã® *ä¸¡æ–¹* "
"ã‚’æº€ãŸã™ãªã‚‰ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã‚ã‚‹ã¨æ±ºå®šã•ã‚Œã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® (:meth:`ExecutionLoader.get_filename` ã§ä¸ãˆã‚‰ã‚Œã‚‹) "
"ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒã€ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‚’é™¤ãã¨ ``__init__`` ã¨ã„ã†åã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚ã‚‹ã“ã¨ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åè‡ªä½“ãŒ ``__init__`` "
"ã§çµ‚ã‚ã‚‰ãªã„ã“ã¨ã€‚"

#: ../../library/importlib.rst:707
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` -- ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãŠã‚ˆã³ãƒ‘ã‚¹ãƒ•ãƒƒã‚¯"

#: ../../library/importlib.rst:712
msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/importlib/machinery.py`"

#: ../../library/importlib.rst:716
msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã€ :keyword:`import` ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¤œç´¢ã—ã¦ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã®ã«å½¹ç«‹ã¤æ§˜ã€…ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/importlib.rst:721
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr "èªè­˜ã•ã‚Œã¦ã„ã‚‹ã‚½ãƒ¼ã‚¹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«æ¥å°¾è¾ã‚’è¡¨ã™æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã§ã™ã€‚"

#: ../../library/importlib.rst:728
msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr "æœ€é©åŒ–ã•ã‚Œã¦ã„ãªã„ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«æ¥å°¾è¾ã‚’è¡¨ã™æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã§ã™ã€‚"

#: ../../library/importlib.rst:733 ../../library/importlib.rst:743
msgid "Use :attr:`BYTECODE_SUFFIXES` instead."
msgstr "ä»£ã‚ã‚Šã« :attr:`BYTECODE_SUFFIXES` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚"

#: ../../library/importlib.rst:738
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr "æœ€é©åŒ–ã•ã‚ŒãŸãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«æ¥å°¾è¾ã‚’è¡¨ã™æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã§ã™ã€‚"

#: ../../library/importlib.rst:748
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr "èªè­˜ã•ã‚Œã¦ã„ã‚‹ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«æ¥å°¾è¾ã‚’è¡¨ã™æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã§ã™ (å…ˆé ­ã®ãƒ‰ãƒƒãƒˆã‚’å«ã¿ã¾ã™)ã€‚"

#: ../../library/importlib.rst:753
msgid "The value is no longer dependent on ``__debug__``."
msgstr "ã“ã®å€¤ã¯ ``__debug__`` ã«ä¾å­˜ã—ãªããªã‚Šã¾ã—ãŸã€‚"

#: ../../library/importlib.rst:758
msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr "èªè­˜ã•ã‚Œã¦ã„ã‚‹æœ€é©åŒ–ã•ã‚ŒãŸæ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«æ¥å°¾è¾ã‚’è¡¨ã™æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã§ã™ã€‚"

#: ../../library/importlib.rst:765
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a"
" module without needing any details on the kind of module (for example, "
":func:`inspect.getmodulename`)."
msgstr ""
"æ¨™æº–ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã«ã‚ˆã£ã¦èªè­˜ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«æ¥å°¾è¾ã‚’è¡¨ã™æ–‡å­—åˆ—ã®çµ„ã¿åˆã‚ã›ã‚‰ã‚ŒãŸãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚ŒãŒå½¹ç«‹ã¤ã®ã¯ã€ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ãƒ‘ã‚¹ãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã‹ã ã‘ã‚’çŸ¥ã‚ŠãŸãã¦ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ç¨®é¡ã‚’è©³ã—ãçŸ¥ã‚‹å¿…è¦ã¯ãªã„ã‚³ãƒ¼ãƒ‰"
" (ä¾‹ãˆã° :func:`inspect.getmodulename`) ã§ã™ã€‚"

#: ../../library/importlib.rst:776
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"çµ„ã¿è¾¼ã¿ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :term:`importer` ã§ã™ã€‚ã™ã¹ã¦ã®æ—¢çŸ¥ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ "
":data:`sys.builtin_module_names` ã«åˆ—æŒ™ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯ "
":class:`importlib.abc.MetaPathFinder` ãŠã‚ˆã³ "
":class:`importlib.abc.InspectLoader` æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:781 ../../library/importlib.rst:795
#: ../../library/importlib.rst:804 ../../library/importlib.rst:819
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã®å¿…è¦æ€§ã‚’è»½æ¸›ã™ã‚‹ãŸã‚ã€ã“ã®ã‚¯ãƒ©ã‚¹ã«ã¯ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã ã‘ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../library/importlib.rst:784
msgid ""
"As part of :pep:`489`, the builtin importer now implements "
":meth:`Loader.create_module` and :meth:`Loader.exec_module`"
msgstr ""
":pep:`489` ã®ä¸€ç’°ã¨ã—ã¦ã€ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã¯ :meth:`Loader.create_module` ã¨ "
":meth:`Loader.exec_module` ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚"

#: ../../library/importlib.rst:791
msgid ""
"An :term:`importer` for frozen modules. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"ãƒ•ãƒªãƒ¼ã‚ºã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :term:`ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ <importer>` ã§ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯ "
":class:`importlib.abc.MetaPathFinder` ãŠã‚ˆã³ "
":class:`importlib.abc.InspectLoader` æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:801
msgid ""
":term:`Finder` for modules declared in the Windows registry.  This class "
"implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
"Windows ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã§å®£è¨€ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :term:`Finder` ã§ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯ "
":class:`importlib.abc.MetaPathFinder` æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:809
msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr ""
"ä»£ã‚ã‚Šã« :mod:`site` ã®è¨­å®šã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚\n"
"Python ã®å°†æ¥ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã“ã®ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒä½¿ãˆãªããªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:816
msgid ""
"A :term:`Finder` for :data:`sys.path` and package ``__path__`` attributes. "
"This class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":data:`sys.path` ãŠã‚ˆã³ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® ``__path__`` å±æ€§ã® :term:`Finder` ã§ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯ "
":class:`importlib.abc.MetaPathFinder` æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’å®Ÿè£…ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:824
msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, "
":data:`sys.path_importer_cache` is checked. If a non-false object is found "
"then it is used as the :term:`path entry finder` to look for the module "
"being searched for. If no entry is found in :data:`sys.path_importer_cache`,"
" then :data:`sys.path_hooks` is searched for a finder for the path entry "
"and, if found, is stored in :data:`sys.path_importer_cache` along with being"
" queried about the module. If no finder is ever found then ``None`` is both "
"stored in the cache and returned."
msgstr ""
":data:`sys.path` ã¾ãŸã¯å®šç¾©ã•ã‚Œã¦ã„ã‚Œã° *path* ã‹ã‚‰ã€ *fullname* ã§æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :term:`ã‚¹ãƒšãƒƒã‚¯ "
"<module spec>` ã®æ¤œç´¢ã‚’è©¦ã¿ã‚‹ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚æ¤œç´¢ã•ã‚Œã‚‹ãã‚Œãã‚Œã®ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªã«å¯¾ã—ã¦ "
":data:`sys.path_importer_cache` ãŒæ¤œæŸ»ã•ã‚Œã¾ã™ã€‚å½ã§ãªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¦‹ã¤ã‹ã‚Œã°ã€ãã‚ŒãŒç›®çš„ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¤œç´¢ã™ã‚‹ãŸã‚ã®"
" :term:`ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ <path entry finder>` ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚ "
":data:`sys.path_importer_cache` ã«ç›®çš„ã®ã‚¨ãƒ³ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ã€ãƒ‘ã‚¹ã‚¨ãƒ³ãƒˆãƒªã«å¯¾ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒ "
":data:`sys.path_hooks` ã‹ã‚‰æ¤œç´¢ã•ã‚Œã€è¦‹ã¤ã‹ã‚Œã°ã€ãã‚ŒãŒ :data:`sys.path_importer_cache` "
"ã«ä¿ç®¡ã•ã‚Œã‚‹ã¨ã¨ã‚‚ã«ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦å•ã„åˆã‚ã›ã‚‰ã‚Œã¾ã™ã€‚ãã‚Œã§ã‚‚ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã° ``None`` ãŒä¿ç®¡ã•ã‚Œã€ã¾ãŸè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:838
msgid ""
"If the current working directory -- represented by an empty string -- is no "
"longer valid then ``None`` is returned but no value is cached in "
":data:`sys.path_importer_cache`."
msgstr ""
"ã‚‚ã—ã‚«ãƒ¬ãƒ³ãƒˆãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª -- ç©ºã®æ–‡å­—åˆ—ã«ã‚ˆã£ã¦è¡¨ã•ã‚Œã¦ã„ã‚‹ -- ãŒã™ã§ã«æœ‰åŠ¹ã§ãªã‘ã‚Œã°ã€ ``None`` ãŒè¿”ã•ã‚Œã¾ã™ãŒå€¤ã¯ "
":data:`sys.path_importer_cache` ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:845
msgid "A legacy wrapper around :meth:`find_spec`."
msgstr ":meth:`find_spec` ã¾ã‚ã‚Šã®ãƒ¬ã‚¬ã‚·ãƒ¼ãªãƒ©ãƒƒãƒ‘ã§ã™ã€‚"

#: ../../library/importlib.rst:852
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders"
" stored in :attr:`sys.path_importer_cache`."
msgstr ""
":attr:`sys.path_importer_cache` ã«ä¿ç®¡ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã«å¯¾ã—ã¦ "
":meth:`importlib.abc.PathEntryFinder.invalidate_caches` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:855
msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working directory "
"for ``''`` (i.e. the empty string)."
msgstr ""
"``''`` (ã™ãªã‚ã¡ç©ºã®æ–‡å­—åˆ—) ã«å¯¾ã—ã¦ã¯ã‚«ãƒ¬ãƒ³ãƒˆãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ã¨ã‚‚ã« :data:`sys.path_hooks` "
"ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:862
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰ã®çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ :class:`importlib.abc.PathEntryFinder` ã®å…·è±¡å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:865
msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr "*path* å¼•æ•°ã¯æ¤œç´¢ã‚’æ‹…å½“ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã™ã€‚"

#: ../../library/importlib.rst:868
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""
"*loader_details* å¼•æ•°ã¯ã€å¯å¤‰å€‹ã® 2 "
"è¦ç´ ã‚¿ãƒ—ãƒ«ã§ã€ãã‚Œãã‚ŒãŒãƒ­ãƒ¼ãƒ€ãƒ¼ã¨ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒèªè­˜ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«æ¥å°¾è¾ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã‚’å«ã¿ã¾ã™ã€‚ãƒ­ãƒ¼ãƒ€ãƒ¼ã¯ã€å‘¼ã³å‡ºã—å¯èƒ½ã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã¨è¦‹ã¤ã‹ã£ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã¨ã®"
" 2 å¼•æ•°ã‚’å—ã‘ä»˜ã‘ã‚‹ã“ã¨ã‚’æœŸå¾…ã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:873
msgid ""
"The finder will cache the directory contents as necessary, making stat calls"
" for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure"
" to call :func:`importlib.invalidate_caches`."
msgstr ""
"ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¤œç´¢ã®ãŸã³ã« stat "
"ã‚’å‘¼ã³å‡ºã—ã€å¿…è¦ã«å¿œã˜ã¦ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å†…å®¹ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ã“ã¨ã§ã€ã‚³ãƒ¼ãƒ‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒå¤ããªã£ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºã‹ã‚ã¾ã™ã€‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®å¤ã•ã¯ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¹ãƒ†ãƒ¼ãƒˆæƒ…å ±ã®ç²’åº¦ã«ä¾å­˜ã—ã¾ã™ã‹ã‚‰ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¤œç´¢ã—ã€æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã€ãã®å¾Œã«æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¡¨ã™ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¤œç´¢ã™ã‚‹ã€ã¨ã„ã†ç«¶åˆçŠ¶æ…‹ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®æ“ä½œãŒ"
" stat ã®å‘¼ã³å‡ºã—ã®ç²’åº¦ã«åã¾ã‚‹ã»ã©é€Ÿãèµ·ã“ã‚‹ã¨ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ¤œç´¢ãŒå¤±æ•—ã—ã¾ã™ã€‚ã“ã‚Œã‚’é˜²ããŸã‚ã«ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‹•çš„ã«ä½œæˆã™ã‚‹éš›ã«ã€å¿…ãš "
":func:`importlib.invalidate_caches` ã‚’å‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚"

#: ../../library/importlib.rst:887
msgid "The path the finder will search in."
msgstr "ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãŒæ¤œç´¢ã•ã‚Œã‚‹ãƒ‘ã‚¹ã§ã™ã€‚"

#: ../../library/importlib.rst:891
msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr ":attr:`path` å†…ã§ *fullname* ã‚’æ‰±ã†ã‚¹ãƒšãƒƒã‚¯ã®æ¢ç´¢ã‚’è©¦ã¿ã¾ã™ã€‚"

#: ../../library/importlib.rst:897
msgid "Attempt to find the loader to handle *fullname* within :attr:`path`."
msgstr ":attr:`path` å†…ã§ *fullname* ã‚’æ‰±ã†ãƒ­ãƒ¼ãƒ€ãƒ¼ã®æ¤œç´¢ã‚’è©¦ã¿ã¾ã™ã€‚"

#: ../../library/importlib.rst:901
msgid "Clear out the internal cache."
msgstr "å†…éƒ¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å®Œå…¨ã«æ¶ˆå»ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:905
msgid ""
"A class method which returns a closure for use on :attr:`sys.path_hooks`. An"
" instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""
":attr:`sys.path_hooks` ã§ä½¿ç”¨ã™ã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’è¿”ã™ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã«ç›´æ¥æ¸¡ã•ã‚ŒãŸ path å¼•æ•°ã‚’ç›´æ¥çš„ã«ã€ "
"*loader_details* ã‚’é–“æ¥çš„ã«ä½¿ã£ã¦ã€ :class:`FileFinder` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒè¿”ã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:910
msgid ""
"If the argument to the closure is not an existing directory, "
":exc:`ImportError` is raised."
msgstr "ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã¸ã®å¼•æ•°ãŒå­˜åœ¨ã™ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ãªã‘ã‚Œã°ã€ :exc:`ImportError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:916
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""
":class:`importlib.abc.FileLoader` ã‚’ç¶™æ‰¿ã—ã€ãã®ä»–ã„ãã¤ã‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å…·è±¡å®Ÿè£…ã‚’æä¾›ã™ã‚‹ã€ "
":class:`importlib.abc.SourceLoader` ã®å…·è±¡å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:924
msgid "The name of the module that this loader will handle."
msgstr "ã“ã®ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒæ‰±ã†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã§ã™ã€‚"

#: ../../library/importlib.rst:928
msgid "The path to the source file."
msgstr "ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã§ã™ã€‚"

#: ../../library/importlib.rst:932
msgid "Return true if :attr:`path` appears to be for a package."
msgstr ":attr:`path` ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è¡¨ã™ã¨ã True ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:936
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr ":meth:`importlib.abc.SourceLoader.path_stats` ã®å…·è±¡å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:940
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr ":meth:`importlib.abc.SourceLoader.set_data` ã®å…·è±¡å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:944 ../../library/importlib.rst:987
msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where "
"specifying the name of the module to load is optional."
msgstr ""
"ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰æŒ‡å®šãŒã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã€ :meth:`importlib.abc.Loader.load_module` ã®å…·è±¡å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:949 ../../library/importlib.rst:992
msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr "ä»£ã‚ã‚Šã« :meth:`importlib.abc.Loader.exec_module` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/importlib.rst:954
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""
"ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ« (ã™ãªã‚ã¡ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„) ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã‚‹ "
":class:`importlib.abc.FileLoader` ã®å…·è±¡å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:957
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations"
" or new versions of Python which change the bytecode format."
msgstr ""
"æ³¨æ„ã¨ã—ã¦ã€ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã‚’ç›´æ¥ä½¿ã† (ã¤ã¾ã‚Šã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã„) ã¨ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã™ã¹ã¦ã® Python "
"å®Ÿè£…ã§ã¯ä½¿ç”¨ã§ããªã„ã—ã€æ–°ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® Python ã§ã¯ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒå¤‰æ›´ã•ã‚Œã¦ã„ãŸã‚‰ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:966
msgid "The name of the module the loader will handle."
msgstr "ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒæ‰±ã†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã§ã™ã€‚"

#: ../../library/importlib.rst:970
msgid "The path to the bytecode file."
msgstr "ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã§ã™ã€‚"

#: ../../library/importlib.rst:974
msgid "Determines if the module is a package based on :attr:`path`."
msgstr "ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã‚ã‚‹ã‹ã‚’ :attr:`path` ã«åŸºã¥ã„ã¦æ±ºå®šã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:978
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr ":attr:`path` ã‹ã‚‰ä½œæˆã•ã‚ŒãŸ :attr:`name` ã®ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:982
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr "ã“ã®ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒä½¿ã‚ã‚ŒãŸã¨ãã€ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚½ãƒ¼ã‚¹ãŒãªã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:997
msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr "æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãŸã‚ã® :class:`importlib.abc.ExecutionLoader` ã®å…·è±¡å®Ÿè£…ã§ã™ã€‚"

#: ../../library/importlib.rst:1000
msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr "*fullname* å¼•æ•°ã¯ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚*path* å¼•æ•°ã¯æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã§ã™ã€‚"

#: ../../library/importlib.rst:1007
msgid "Name of the module the loader supports."
msgstr "ãƒ­ãƒ¼ãƒ€ãƒ¼ãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã§ã™ã€‚"

#: ../../library/importlib.rst:1011
msgid "Path to the extension module."
msgstr "æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸ã®ãƒ‘ã‚¹ã§ã™ã€‚"

#: ../../library/importlib.rst:1015
msgid ""
"Creates the module object from the given specification in accordance with "
":pep:`489`."
msgstr "ä¸ãˆã‚‰ã‚ŒãŸã‚¹ãƒšãƒƒã‚¯ã‹ã‚‰ :pep:`489` ã«å¾“ã£ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:1022
msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr "ä¸ãˆã‚‰ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ :pep:`489` ã«å¾“ã£ã¦åˆæœŸåŒ–ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:1028
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :attr:`EXTENSION_SUFFIXES`."
msgstr ""
":attr:`EXTENSION_SUFFIXES` ã«åŸºã¥ã„ã¦ã€ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® ``__init__`` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æŒ‡ã—ã¦ã„ã‚Œã° "
"``True`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:1033
msgid "Returns ``None`` as extension modules lack a code object."
msgstr "æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚³ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãªã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:1037
msgid "Returns ``None`` as extension modules do not have source code."
msgstr "æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ãŒãªã‘ã‚Œã° ``None`` ã‚’è¿”ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:1048
msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's ``__spec__`` attribute.  In the "
"descriptions below, the names in parentheses give the corresponding "
"attribute available directly on the module object. E.g. "
"``module.__spec__.origin == module.__file__``.  Note however that while the "
"*values* are usually equivalent, they can differ since there is no "
"synchronization between the two objects.  Thus it is possible to update the "
"module's ``__path__`` at runtime, and this will not be automatically "
"reflected in ``__spec__.submodule_search_locations``."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã«é–¢ã™ã‚‹çŠ¶æ…‹ã®ä»•æ§˜ã€‚\n"
"ã“ã‚Œã¯é€šå¸¸ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``__spec__`` å±æ€§ã¨ã—ã¦å…¬é–‹ã•ã‚Œã¦ã„ã¾ã™ã€‚\n"
"ã“ã®å¾Œã®è§£èª¬ã§ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ç›´æ¥åˆ©ç”¨ã§ãã‚‹å±æ€§ã§ã€ãã‚Œãã‚Œã®ä»•æ§˜ã«å¯¾å¿œã—ã¦ã„ã‚‹ã‚‚ã®ã®åå‰ãŒæ‹¬å¼§æ›¸ãã§æ›¸ã‹ã‚Œã¦ã„ã¾ã™ã€‚\n"
"ä¾‹ãˆã°ã€ ``module.__spec__.origin == module.__file__`` ã§ã™ã€‚\n"
"ãŸã ã—ã€å±æ€§ã® *å€¤* ã¯ãŸã„ã¦ã„ã¯åŒä¸€ã§ã™ãŒã€2ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã©ã†ã—ã¯åŒæœŸã•ã‚Œãªã„ãŸã‚ã€ç•°ãªã£ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚\n"
"ä¾‹ãˆã°ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® ``__path__`` ã‚’å®Ÿè¡Œæ™‚ã«æ›´æ–°ã§ãã¾ã™ãŒã€ ``__spec__.submodule_search_locations`` ã«è‡ªå‹•çš„ã«ã¯åæ˜ ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:1062
msgid "(``__name__``)"
msgstr "(``__name__``)"

#: ../../library/importlib.rst:1064
msgid "A string for the fully-qualified name of the module."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å®Œå…¨ä¿®é£¾åã‚’è¡¨ã™æ–‡å­—åˆ—ã§ã™ã€‚"

#: ../../library/importlib.rst:1068
msgid "(``__loader__``)"
msgstr "(``__loader__``)"

#: ../../library/importlib.rst:1070
msgid ""
"The loader to use for loading.  For namespace packages this should be set to"
" ``None``."
msgstr "ãƒ­ãƒ¼ãƒ‰ã«ä½¿ã†ãƒ­ãƒ¼ãƒ€ã§ã™ã€‚åå‰ç©ºé–“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å ´åˆ ``None`` ã«è¨­å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:1075
msgid "(``__file__``)"
msgstr "(``__file__``)"

#: ../../library/importlib.rst:1077
msgid ""
"Name of the place from which the module is loaded, e.g. \"builtin\" for "
"built-in modules and the filename for modules loaded from source. Normally "
"\"origin\" should be set, but it may be ``None`` (the default) which "
"indicates it is unspecified."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå ´æ‰€ã®åå‰ã§ã™ã€‚\n"
"ä¾‹ãˆã°ã€çµ„ã¿è¾¼ã¿ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ \"builtin\"ã€ã‚½ãƒ¼ã‚¹ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ãƒ•ã‚¡ã‚¤ãƒ«åã§ã™ã€‚\n"
"é€šå¸¸ \"origin\" ã¯è¨­å®šã•ã‚Œã‚‹ã¹ãã§ã™ãŒã€æœªæŒ‡å®šã‚’ç¤ºã™ ``None`` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã§ã‚‚ã‚ˆã„ã§ã™ã€‚"

#: ../../library/importlib.rst:1084
msgid "(``__path__``)"
msgstr "(``__path__``)"

#: ../../library/importlib.rst:1086
msgid ""
"List of strings for where to find submodules, if a package (``None`` "
"otherwise)."
msgstr "ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å ´åˆã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ä»˜ã‘ã‚‹ã¹ãå ´æ‰€ã‚’è¡¨ã™æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆ (ãã†ã§ãªã„å ´åˆã¯ ``None``) ã§ã™ã€‚"

#: ../../library/importlib.rst:1091
msgid ""
"Container of extra module-specific data for use during loading (or "
"``None``)."
msgstr "ãƒ­ãƒ¼ãƒ‰ä¸­ã«ä½¿ã†æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æŒ‡å®šã®ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ³ãƒ†ãƒŠ (ã¾ãŸã¯ ``None``) ã§ã™ã€‚"

#: ../../library/importlib.rst:1096
msgid "(``__cached__``)"
msgstr "(``__cached__``)"

#: ../../library/importlib.rst:1098
msgid "String for where the compiled module should be stored (or ``None``)."
msgstr "ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä¿å­˜ã™ã¹ãå ´æ‰€ã‚’è¡¨ã™æ–‡å­—åˆ— (ã¾ãŸã¯ ``None``) ã§ã™ã€‚"

#: ../../library/importlib.rst:1102
msgid "(``__package__``)"
msgstr "(``__package__``)"

#: ../../library/importlib.rst:1104
msgid ""
"(Read-only) Fully-qualified name of the package to which the module belongs "
"as a submodule (or ``None``)."
msgstr "(èª­ã¿å‡ºã—å°‚ç”¨) ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã—ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå±ã™ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å®Œå…¨ä¿®é£¾å (ã¾ãŸã¯ ``None``) ã§ã™ã€‚"

#: ../../library/importlib.rst:1109
msgid ""
"Boolean indicating whether or not the module's \"origin\" attribute refers "
"to a loadable location."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® \"origin\" å±æ€§ãŒãƒ­ãƒ¼ãƒ‰å¯èƒ½ãªå ´æ‰€ã‚’å‚ç…§ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™ãƒ–ãƒ¼ãƒ«å€¤ã§ã™ã€‚"

#: ../../library/importlib.rst:1113
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` -- ã‚¤ãƒ³ãƒãƒ¼ã‚¿ã®ãŸã‚ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚³ãƒ¼ãƒ‰"

#: ../../library/importlib.rst:1119
msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰:** :source:`Lib/importlib/util.py`"

#: ../../library/importlib.rst:1123
msgid ""
"This module contains the various objects that help in the construction of an"
" :term:`importer`."
msgstr "ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã€ :term:`ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ <importer>` ã®æ§‹ç¯‰ã‚’åŠ©ã‘ã‚‹æ§˜ã€…ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../library/importlib.rst:1128
msgid ""
"The bytes which represent the bytecode version number. If you need help with"
" loading/writing bytecode then consider :class:`importlib.abc.SourceLoader`."
msgstr ""
"ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã‚’è¡¨ã—ã¦ã„ã‚‹ãƒã‚¤ãƒˆåˆ—ã€‚ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ã®ãƒ­ãƒ¼ãƒ‰ï¼æ›¸ãè¾¼ã¿ã«ã¤ã„ã¦ãƒ˜ãƒ«ãƒ—ãŒå¿…è¦ãªã‚‰ "
":class:`importlib.abc.SourceLoader` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../library/importlib.rst:1135
msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file associated "
"with the source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the "
"return value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python"
" 3.2. The ``cpython-32`` string comes from the current magic tag (see "
":func:`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then"
" :exc:`NotImplementedError` will be raised)."
msgstr ""
"ã‚½ãƒ¼ã‚¹ *path* ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸãƒã‚¤ãƒˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã® :pep:`3147`/:pep:`488` ãƒ‘ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ "
"*path* ãŒ ``/foo/bar/baz.py`` ãªã‚‰ã€ Python 3.2 ã®å ´åˆè¿”ã‚Šå€¤ã¯ "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` ã«ãªã‚Šã¾ã™ã€‚ ``cpython-32`` "
"ã¨ã„ã†æ–‡å­—åˆ—ã¯ã€ç¾åœ¨ã®ãƒã‚¸ãƒƒã‚¯ã‚¿ã‚°ã‹ã‚‰å¾—ã‚‰ã‚Œã¾ã™ (ãƒã‚¸ãƒƒã‚¯ã‚¿ã‚°ã«ã¤ã„ã¦ã¯ :func:`get_tag` ã‚’å‚ç…§; "
":attr:`sys.implementation.cache_tag` ãŒæœªå®šç¾©ãªã‚‰ :exc:`NotImplementedError` "
"ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚)"

#: ../../library/importlib.rst:1142
msgid ""
"The *optimization* parameter is used to specify the optimization level of "
"the bytecode file. An empty string represents no optimization, so "
"``/foo/bar/baz.py`` with an *optimization* of ``''`` will result in a "
"bytecode path of ``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` "
"causes the interpter's optimization level to be used. Any other value's "
"string representation being used, so ``/foo/bar/baz.py`` with an "
"*optimization* of ``2`` will lead to the bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc``. The string representation"
" of *optimization* can only be alphanumeric, else :exc:`ValueError` is "
"raised."
msgstr ""
"*optimization* "
"ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ã€ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€é©åŒ–ãƒ¬ãƒ™ãƒ«ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ç©ºæ–‡å­—åˆ—ã¯æœ€é©åŒ–ã—ãªã„ã“ã¨ã‚’è¡¨ã—ã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ "
"*optimization* ãŒ ``''`` ã®ã¨ã ``/foo/bar/baz.py`` ã«å¯¾ã—ã¦ "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` ã¨ã„ã†ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ‘ã‚¹ãŒè¿”ã‚Šã¾ã™ã€‚ ``None`` "
"ã«ã™ã‚‹ã¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ã®æœ€é©åŒ–ãƒ¬ãƒ™ãƒ«ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ãã‚Œä»¥å¤–ã§ã¯å€¤ã®æ–‡å­—åˆ—è¡¨ç¾ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ *optimization* ãŒ ``2`` "
"ã®ã¨ã  ``/foo/bar/baz.py`` ã«å¯¾ã—ã¦ "
"``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc`` ã¨ã„ã†ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ‘ã‚¹ãŒè¿”ã‚Šã¾ã™ã€‚ "
"*optimization* ã®æ–‡å­—åˆ—è¡¨ç¾ã¯è‹±æ•°å­—ã ã‘ãŒå¯èƒ½ã§ã€ãã†ã§ãªã‘ã‚Œã° :exc:`ValueError` ãŒä¸Šã’ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:1152
msgid ""
"The *debug_override* parameter is deprecated and can be used to override the"
" system's value for ``__debug__``. A ``True`` value is the equivalent of "
"setting *optimization* to the empty string. A ``False`` value is the same as"
" setting *optimization* to ``1``. If both *debug_override* an *optimization*"
" are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"*debug_override* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ deprecated ã§ã€ã‚·ã‚¹ãƒ†ãƒ ã® ``__debug__`` "
"å€¤ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã¾ã™ã€‚ ``True`` å€¤ã¯ *optimization* ã‚’ç©ºæ–‡å­—åˆ—ã«è¨­å®šã™ã‚‹ã®ã¨ç­‰ä¾¡ã§ã™ã€‚ ``False``"
" å€¤ã¯ *optimization* ã‚’ ``1`` ã«è¨­å®šã™ã‚‹ã®ã¨åŒç­‰ã§ã™ã€‚ã‚‚ã— *debug_override* ã¨ *optimization* "
"ã®ã©ã¡ã‚‰ã‚‚ ``None`` ä»¥å¤–ã§ã‚ã‚Œã° :exc:`TypeError` ãŒä¸Šã’ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:1160
msgid ""
"The *optimization* parameter was added and the *debug_override* parameter "
"was deprecated."
msgstr "*optimization* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒè¿½åŠ ã•ã‚Œã€ *debug_override* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ deprecated ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/importlib.rst:1164 ../../library/importlib.rst:1180
#: ../../library/importlib.rst:1319
msgid "Accepts a :term:`path-like object`."
msgstr ":term:`path-like object` ã‚’å—ã‘å…¥ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/importlib.rst:1170
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` the returned path would be "
"``/foo/bar/baz.py``.  *path* need not exist, however if it does not conform "
"to :pep:`3147` or :pep:`488` format, a ``ValueError`` is raised. If "
":attr:`sys.implementation.cache_tag` is not defined, "
":exc:`NotImplementedError` is raised."
msgstr ""
":pep:`3147` ãƒ•ã‚¡ã‚¤ãƒ«åã¸ã® *path* ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€é–¢é€£ã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ *path* ãŒ "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` ãªã‚‰ã€è¿”ã•ã‚Œã‚‹ãƒ‘ã‚¹ã¯ ``/foo/bar/baz.py`` "
"ã«ãªã‚Šã¾ã™ã€‚ *path* ã¯å­˜åœ¨ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ :pep:`3147` ã¾ãŸã¯ :pep:`488` ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ä¸€è‡´ã—ãªã„å ´åˆã¯ "
"``ValueError`` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ :attr:`sys.implementation.cache_tag` ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã€ "
":exc:`NotImplementedError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:1185
msgid ""
"Decode the given bytes representing source code and return it as a string "
"with universal newlines (as required by "
":meth:`importlib.abc.InspectLoader.get_source`)."
msgstr ""
"ä¸ãˆã‚‰ã‚ŒãŸã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ã™ãƒã‚¤ãƒˆåˆ—ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã¦ã€æ–‡å­—åˆ—ã¨ã—ã¦ãã‚Œã‚’ä¸€èˆ¬çš„ãªæ”¹è¡Œå½¢å¼ (universal newlines) ã§è¿”ã—ã¾ã™ "
"(:meth:`importlib.abc.InspectLoader.get_source` ã§è¦æ±‚ã•ã‚Œã‚‹ã‚ˆã†ã«)ã€‚"

#: ../../library/importlib.rst:1193
msgid "Resolve a relative module name to an absolute one."
msgstr "ç›¸å¯¾çš„ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’è§£æ±ºã—ã¦çµ¶å¯¾çš„ãªã‚‚ã®ã«ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:1195
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', __package__)``"
" without doing a check to see if the **package** argument is needed."
msgstr ""
"**name** ã®å…ˆé ­ã«ãƒ‰ãƒƒãƒˆãŒãªã‘ã‚Œã°ã€å˜ã« **name** ãŒè¿”ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ä¾‹ãˆã° "
"``importlib.util.resolve_name('sys', __package__)`` ã‚’ä½¿ã†ã¨ãã« **package** "
"å¤‰æ•°ãŒå¿…è¦ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹å¿…è¦ãŒãªããªã‚Šã¾ã™ã€‚"

#: ../../library/importlib.rst:1200
msgid ""
":exc:`ValueError` is raised if **name** is a relative module name but "
"package is a false value (e.g. ``None`` or the empty string). "
":exc:`ValueError` is also raised a relative name would escape its containing"
" package (e.g. requesting ``..bacon`` from within the ``spam`` package)."
msgstr ""
"**name** ãŒç›¸å¯¾çš„ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã§ã‚ã‚‹ã«ã‚‚ã‹ã‹ã‚ã‚‰ãš package ãŒå½å€¤ (ä¾‹ãˆã° ``None`` ã‚„ç©ºæ–‡å­—åˆ—) ãªã‚‰ã°ã€ "
":exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚ç›¸å¯¾çš„ãªåå‰ãŒãã‚Œã‚’å«ã‚€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‹ã‚‰æŠœã‘å‡ºã‚‹ (ä¾‹ãˆã° ``spam`` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å†…ã‹ã‚‰ "
"``..bacon`` ã‚’è¦æ±‚ã™ã‚‹) å ´åˆã«ã‚‚ :exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:1209
msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to the"
" specified **package** name. If the module is in :attr:`sys.modules`, then "
"``sys.modules[name].__spec__`` is returned (unless the spec would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :attr:`sys.meta_path` is done. ``None`` is returned"
" if no spec is found."
msgstr ""
"ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :term:`spec <module spec>` ã‚’ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§æŒ‡å®šã•ã‚ŒãŸ **package** "
"åã«å¯¾ã™ã‚‹ç›¸å¯¾ã§æ¤œç´¢ã—ã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ :attr:`sys.modules` ã«ã‚ã‚Œã°ã€ "
"``sys.modules[name].__spec__`` ãŒè¿”ã•ã‚Œã¾ã™ (ãŸã ã—ã‚¹ãƒšãƒƒã‚¯ãŒ ``None`` ã§ã‚ã‚‹ã‹è¨­å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã° "
":exc:`ValueError` ãŒé€å‡ºã•ã‚Œã¾ã™)ã€‚ãªã‘ã‚Œã°ã€ :attr:`sys.meta_path` "
"ã‚’ä½¿ã£ãŸæ¤œç´¢ãŒãªã•ã‚Œã¾ã™ã€‚ã‚¹ãƒšãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã° ``None`` ãŒè¿”ã‚Šã¾ã™ã€‚"

#: ../../library/importlib.rst:1216
msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr "**name** ãŒã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç¤ºã—ã¦ã„ã‚‹  (ãƒ‰ãƒƒãƒˆã‚’å«ã‚€) å ´åˆã€è¦ªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯è‡ªå‹•çš„ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:1219
msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr "**name** ã¨ **package** ã¯ :func:`import_module` ã«å¯¾ã™ã‚‹ã‚‚ã®ã¨åŒã˜ã‚ˆã†ã«æ©Ÿèƒ½ã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:1225
msgid ""
"Create a new module based on **spec** and :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."
msgstr ""
"**spec** ã¨ :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>` ã«åŸºã¥ã„ã¦æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œã‚Šã¾ã™ã€‚"

#: ../../library/importlib.rst:1228
msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""
":meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` ãŒ "
"``None`` ã‚’è¿”ã•ãªã„å ´åˆã¯ã€æ—¢ã«å­˜åœ¨ã™ã‚‹ã©ã®å±æ€§ã‚‚ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã›ã‚“ã€‚ã¾ãŸã€ **spec** "
"ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã‚Šå±æ€§ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«è¨­å®šã—ãŸã‚Šã™ã‚‹éš›ã« :exc:`AttributeError` ä¾‹å¤–ãŒèµ·ãã¦ã‚‚ä¾‹å¤–ã¯é€å‡ºã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:1233
msgid ""
"This function is preferred over using :class:`types.ModuleType` to create a "
"new module as **spec** is used to set as many import-controlled attributes "
"on the module as possible."
msgstr ""
"ã“ã®é–¢æ•°ã¯ã€æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œã‚‹æ–¹æ³•ã¨ã—ã¦ :class:`types.ModuleType` "
"ã‚ˆã‚Šã‚‚æ¨å¥¨ã•ã‚Œã¾ã™ã€‚ãªãœãªã‚‰ã€ã§ãã‚‹ã ã‘å¤šãã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã•ã‚ŒãŸå±æ€§ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«è¨­å®šã™ã‚‹ãŸã‚ã« **spec** ãŒä½¿ç”¨ã•ã‚Œã‚‹ã‹ã‚‰ã§ã™ã€‚"

#: ../../library/importlib.rst:1241
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to handle "
"selecting the proper module object to load with. The decorated method is "
"expected to have a call signature taking two positional arguments (e.g. "
"``load_module(self, module)``) for which the second argument will be the "
"module **object** to be used by the loader. Note that the decorator will not"
" work on static methods because of the assumption of two arguments."
msgstr ""
"ãƒ­ãƒ¼ãƒ‰ã«ä½¿ã†é©åˆ‡ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é¸æŠã‚’æ‰±ã†ãŸã‚ã®ã€ :meth:`importlib.abc.Loader.load_module` ã¸ã® "
":term:`decorator` ã§ã™ã€‚ã“ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚·ã‚°ãƒ‹ãƒãƒ£ã¯ã€2 ã¤ã®ä½ç½®å¼•æ•°ã‚’ã¨ã‚‹ã“ã¨ã‚’æœŸå¾…ã•ã‚Œã¾ã™ (ä¾‹ãˆã° "
"``load_module(self, module)``) ã€‚ç¬¬2å¼•æ•°ã¯ãƒ­ãƒ¼ãƒ€ãƒ¼ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« **object** "
"ã«ãªã‚Šã¾ã™ã€‚ãªãŠã€ã“ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¯ 2 ã¤ã®å¼•æ•°ã‚’æƒ³å®šã™ã‚‹ãŸã‚ã€ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯åƒãã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:1250
msgid ""
"The decorated method will take in the **name** of the module to be loaded as"
" expected for a :term:`loader`. If the module is not found in "
":data:`sys.modules` then a new one is constructed. Regardless of where the "
"module came from, :attr:`__loader__` set to **self** and :attr:`__package__`"
" is set based on what :meth:`importlib.abc.InspectLoader.is_package` returns"
" (if available). These attributes are set unconditionally to support "
"reloading."
msgstr ""
"ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ :term:`loader` ãŒãƒ­ãƒ¼ãƒ‰ã—ã‚ˆã†ã¨ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® **name** ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ "
":data:`sys.modules` ã«è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæ§‹ç¯‰ã•ã‚Œã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å‡ºæ‰€ã«é–¢ã‚ã‚‰ãšã€ "
":attr:`__loader__` ã¯ **self** ã«è¨­å®šã•ã‚Œã€ (ã‚‚ã—åˆ©ç”¨å¯èƒ½ãªã‚‰) :attr:`__package__` ã¯ "
":meth:`importlib.abc.InspectLoader.is_package` "
"ã®æˆ»ã‚Šå€¤ã«åŸºã¥ã„ã¦è¨­å®šã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®å±æ€§ã¯ã€ãƒªãƒ­ãƒ¼ãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ç„¡æ¡ä»¶ã«è¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:1258
msgid ""
"If an exception is raised by the decorated method and a module was added to "
":data:`sys.modules`, then the module will be removed to prevent a partially "
"initialized module from being in left in :data:`sys.modules`. If the module "
"was already in :data:`sys.modules` then it is left alone."
msgstr ""
"ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦ä¾‹å¤–ãŒé€å‡ºã•ã‚ŒãŸã¨ãã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ :data:`sys.modules` "
"ã«åŠ ãˆã‚‰ã‚Œã¦ã„ãŸã‚‰ã€éƒ¨åˆ†çš„ã«åˆæœŸåŒ–ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ :data:`sys.modules` "
"ã«æ®‹ã‚‰ãªã„ã‚ˆã†ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å–ã‚Šé™¤ã‹ã‚Œã¾ã™ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæ—¢ã« :data:`sys.modules` ã«ã‚ã£ãŸãªã‚‰ã€ãã‚Œã¯æ®‹ã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:1263
msgid ""
":attr:`__loader__` and :attr:`__package__` are automatically set (when "
"possible)."
msgstr ":attr:`__loader__` ãŠã‚ˆã³ :attr:`__package__` ã¯ (å¯èƒ½ãªã‚‰) è‡ªå‹•çš„ã«è¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:1267
msgid ""
"Set :attr:`__name__`, :attr:`__loader__` :attr:`__package__` unconditionally"
" to support reloading."
msgstr ""
"ãƒªãƒ­ãƒ¼ãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã« :attr:`__name__` :attr:`__loader__` :attr:`__package__` "
"ã¯ç„¡æ¡ä»¶ã«è¨­å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:1271
msgid ""
"The import machinery now directly performs all the functionality provided by"
" this function."
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ã“ã®é–¢æ•°ãŒæä¾›ã™ã‚‹å…¨æ©Ÿèƒ½ã‚’ç›´æ¥å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/importlib.rst:1277
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the "
":attr:`__loader__` attribute on the returned module. If the attribute is "
"already set the decorator does nothing. It is assumed that the first "
"positional argument to the wrapped method (i.e. ``self``) is what "
":attr:`__loader__` should be set to."
msgstr ""
"è¿”ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® :attr:`__loader__` å±æ€§ã‚’è¨­å®šã™ã‚‹ã€ "
":meth:`importlib.abc.Loader.load_module` ã¸ã® :term:`decorator` "
"ã§ã™ã€‚å±æ€§ãŒæ—¢ã«è¨­å®šã•ã‚Œã¦ã„ãŸã‚‰ã€ã“ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ (ã™ãªã‚ã¡ ``self``) ã¸ã®1ã¤ç›®ã®ä½ç½®å¼•æ•°ã¯ "
":attr:`__loader__` ã«è¨­å®šã•ã‚Œã‚‹å€¤ã§ã‚ã‚‹ã¨ä»®å®šã•ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:1284
msgid ""
"Set ``__loader__`` if set to ``None``, as if the attribute does not exist."
msgstr ""
"ã‚‚ã— ``__loader__`` å±æ€§ãŒ ``None`` ã«è¨­å®šã•ã‚Œã¦ã„ã‚Œã°ã€å±æ€§ãŒå­˜åœ¨ã—ãªã„ã‹ã®ã‚ˆã†ã« ``__loader__`` "
"ã‚’è¨­å®šã—ã¾ã™ã€‚"

#: ../../library/importlib.rst:1288 ../../library/importlib.rst:1297
msgid "The import machinery takes care of this automatically."
msgstr "ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿæ§‹ã¯ã“ã‚Œã‚’è‡ªå‹•çš„ã«è€ƒæ…®ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"

#: ../../library/importlib.rst:1293
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the "
":attr:`__package__` attribute on the returned module. If :attr:`__package__`"
" is set and has a value other than ``None`` it will not be changed."
msgstr ""
":attr:`__package__` å±æ€§ã‚’æˆ»ã‚Šå€¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«è¨­å®šã™ã‚‹ãŸã‚ã®ã€ "
":meth:`importlib.abc.Loader.load_module` ã¸ã® :term:`decorator` ã§ã™ã€‚ã‚‚ã— "
":attr:`__package__` ãŒè¨­å®šã•ã‚Œã¦ã„ã¦ ``None`` ä»¥å¤–ã®å€¤ã‚’æŒã£ã¦ã„ã‚‹ãªã‚‰ã€ãã‚Œã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:1302
msgid ""
"A factory function for creating a :class:`ModuleSpec` instance based on a "
"loader.  The parameters have the same meaning as they do for ModuleSpec.  "
"The function uses available :term:`loader` APIs, such as "
":meth:`InspectLoader.is_package`, to fill in any missing information on the "
"spec."
msgstr ""
"ã“ã®é–¢æ•°ã¯ã€ã‚¹ãƒšãƒƒã‚¯ã«ä¸è¶³ã—ã¦ã„ã‚‹æƒ…å ±ã‚’åŸ‹ã‚ã‚‹ãŸã‚ã« :meth:`InspectLoader.is_package` ã®ã‚ˆã†ãªåˆ©ç”¨å¯èƒ½ãª "
":term:`loader` API ã‚’ä½¿ã„ã¾ã™ã€‚"

#: ../../library/importlib.rst:1312
msgid ""
"A factory function for creating a :class:`ModuleSpec` instance based on the "
"path to a file.  Missing information will be filled in on the spec by making"
" use of loader APIs and by the implication that the module will be file-"
"based."
msgstr ""
"ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã«ã‚‚ã¨ã¥ã„ã¦ :class:`ModuleSpec` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼é–¢æ•°ã€‚ä¸è¶³ã—ã¦ã„ã‚‹æƒ…å ±ã¯ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ API"
" ã‚’åˆ©ç”¨ã—ã¦ã‚¹ãƒšãƒƒã‚¯ã‹ã‚‰å¾—ã‚‰ã‚Œã‚‹æƒ…å ±ã¨ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãƒ•ã‚¡ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹ã§ã‚ã‚‹ã¨ã„ã†æš—é»™çš„ãªæƒ…å ±ã«ã‚ˆã£ã¦åŸ‹ã‚ã‚‰ã‚Œã¾ã™ã€‚"

#: ../../library/importlib.rst:1324
msgid ""
"A class which postpones the execution of the loader of a module until the "
"module has an attribute accessed."
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã¾ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ­ãƒ¼ãƒ€ãƒ¼ã®å®Ÿè¡Œã‚’é…å»¶ã™ã‚‹ã‚¯ãƒ©ã‚¹ã€‚"

#: ../../library/importlib.rst:1327
msgid ""
"This class **only** works with loaders that define "
":meth:`~importlib.abc.Loader.exec_module` as control over what module type "
"is used for the module is required. For those same reasons, the loader's "
":meth:`~importlib.abc.Loader.create_module` method must return ``None`` or a"
" type for which its ``__class__`` attribute can be mutated along with not "
"using :term:`slots <__slots__>`. Finally, modules which substitute the "
"object placed into :attr:`sys.modules` will not work as there is no way to "
"properly replace the module references throughout the interpreter safely; "
":exc:`ValueError` is raised if such a substitution is detected."
msgstr ""

#: ../../library/importlib.rst:1338
msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. For"
" projects where startup time is not essential then use of this class is "
"**heavily** discouraged due to error messages created during loading being "
"postponed and thus occurring out of context."
msgstr ""
"èµ·å‹•æ™‚é–“ãŒé‡è¦ãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€ã‚‚ã—æ±ºã—ã¦ä½¿ã‚ã‚Œãªã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚ã‚Œã°ã€ã“ã®ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã£ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‚³ã‚¹ãƒˆã‚’æœ€å°åŒ–ã§ãã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—æ™‚é–“ãŒé‡è¦ã§ãªã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€é…å»¶ã•ã‚ŒãŸãƒ­ãƒ¼ãƒ‰ã®éš›ã«ç™ºç”Ÿã—ã¦æ–‡è„ˆã®å¤–ã§èµ·ã“ã‚‹ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãŸã‚ã€ã“ã®ã‚¯ãƒ©ã‚¹ã®ä½¿ç”¨ã¯"
" **è‘—ã—ã** æ¨å¥¨ã•ã‚Œã¾ã›ã‚“ã€‚"

#: ../../library/importlib.rst:1346
msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` and "
":class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""

#: ../../library/importlib.rst:1353
msgid ""
"A static method which returns a callable that creates a lazy loader. This is"
" meant to be used in situations where the loader is passed by class instead "
"of by instance. ::"
msgstr ""
"é…å»¶ãƒ­ãƒ¼ãƒ€ã‚’ç”Ÿæˆã™ã‚‹ callable "
"ã‚’è¿”ã™ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ã€‚ã“ã‚Œã¯ã€ãƒ­ãƒ¼ãƒ€ãƒ¼ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã—ã¦ã§ã¯ãªãã‚¯ãƒ©ã‚¹ã¨ã—ã¦æ¸¡ã™ã‚ˆã†ãªçŠ¶æ³ã«ãŠã„ã¦ä½¿ã‚ã‚Œã‚‹ã“ã¨ã‚’æ„å›³ã—ã¦ã„ã¾ã™ã€‚ ::"

#: ../../library/importlib.rst:1366
msgid "Examples"
msgstr "ä½¿ç”¨ä¾‹"

#: ../../library/importlib.rst:1369
msgid "Importing programmatically"
msgstr "ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ"

#: ../../library/importlib.rst:1371
msgid ""
"To programmatically import a module, use :func:`importlib.import_module`. ::"
msgstr "ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã«ã¯ã€ :func:`importlib.import_module` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ ::"

#: ../../library/importlib.rst:1380
msgid "Checking if a module can be imported"
msgstr "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã‚‹ã‹ç¢ºèªã™ã‚‹"

#: ../../library/importlib.rst:1382
msgid ""
"If you need to find out if a module can be imported without actually doing "
"the import, then you should use :func:`importlib.util.find_spec`. ::"
msgstr ""
"ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’å®Ÿéš›ã«è¡Œã‚ãšã«ã€ã‚ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã‚‹ã‹ã‚’çŸ¥ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã¯ã€ :func:`importlib.util.find_spec`"
" ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ ::"

#: ../../library/importlib.rst:1404
msgid "Importing a source file directly"
msgstr "ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç›´æ¥ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹"

#: ../../library/importlib.rst:1406
msgid ""
"To import a Python source file directly, use the following recipe (Python "
"3.4 and newer only)::"
msgstr "Python ã®ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç›´æ¥ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã«ã¯ã€æ¬¡ã®ãƒ¬ã‚·ãƒ”ã‚’ä½¿ã£ã¦ãã ã•ã„ (Python 3.4 ä»¥é™ã®ã¿)::"

#: ../../library/importlib.rst:1426
msgid "Setting up an importer"
msgstr "ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"

#: ../../library/importlib.rst:1428
msgid ""
"For deep customizations of import, you typically want to implement an "
":term:`importer`. This means managing both the :term:`finder` and "
":term:`loader` side of things. For finders there are two flavours to choose "
"from depending on your needs: a :term:`meta path finder` or a :term:`path "
"entry finder`. The former is what you would put on :attr:`sys.meta_path` "
"while the latter is what you create using a :term:`path entry hook` on "
":attr:`sys.path_hooks` which works with :attr:`sys.path` entries to "
"potentially create a finder. This example will show you how to register your"
" own importers so that import will use them (for creating an importer for "
"yourself, read the documentation for the appropriate classes defined within "
"this package)::"
msgstr ""

#: ../../library/importlib.rst:1460
msgid "Approximating :func:`importlib.import_module`"
msgstr ""

#: ../../library/importlib.rst:1462
msgid ""
"Import itself is implemented in Python code, making it possible to expose "
"most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module` (Python 3.4 "
"and newer for the importlib usage, Python 3.6 and newer for other parts of "
"the code). ::"
msgstr ""
