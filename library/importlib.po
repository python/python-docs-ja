# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-02-04 12:29+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Osamu NAKAMURA, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/python-doc/teams/5390/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/importlib.rst:2
msgid ":mod:`importlib` --- The implementation of :keyword:`import`"
msgstr ":mod:`importlib` --- :keyword:`import` の実装"

#: ../../library/importlib.rst:12
msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**ソースコード:** :source:`Lib/importlib/__init__.py`"

#: ../../library/importlib.rst:17
msgid "Introduction"
msgstr "はじめに"

#: ../../library/importlib.rst:19
msgid ""
"The purpose of the :mod:`importlib` package is two-fold. One is to provide "
"the implementation of the :keyword:`import` statement (and thus, by "
"extension, the :func:`__import__` function) in Python source code. This "
"provides an implementation of :keyword:`import` which is portable to any "
"Python interpreter. This also provides an implementation which is easier to "
"comprehend than one implemented in a programming language other than Python."
msgstr ""
":mod:`importlib` パッケージの目的は2つあります。1つ目は Python ソースコード中にある :keyword:`import` "
"文の(そして、拡張として、 :func:`__import__` 関数の)実装を提供することです。このパッケージは :keyword:`import` "
"文の、どの Python インタープリターでも動作する実装を提供します。また、 Python "
"以外の言語で実装されたどの実装よりも把握しやすい実装を提供します。"

#: ../../library/importlib.rst:26
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"2つ目の目的は、このパッケージが公開している :keyword:`import` を実装するための要素を利用して、(:term:`インポーター "
"<importer>` として知られる) インポートプロセスで動作するカスタムのオブジェクトを実装しやすくすることです。"

#: ../../library/importlib.rst:33
msgid ":ref:`import`"
msgstr ":ref:`import`"

#: ../../library/importlib.rst:33
msgid "The language reference for the :keyword:`import` statement."
msgstr ":keyword:`import` 文の言語リファレンス。"

#: ../../library/importlib.rst:38
msgid ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr ""

#: ../../library/importlib.rst:36
msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in "
":data:`sys.modules`)."
msgstr ""
"パッケージの元の仕様。幾つかの動作はこの仕様が書かれた頃から変更されています (例: :data:`sys.modules` で ``None`` "
"に基づくリダイレクト)。"

#: ../../library/importlib.rst:41
msgid "The :func:`.__import__` function"
msgstr ":func:`.__import__` 関数"

#: ../../library/importlib.rst:41
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr ":keyword:`import` 文はこの関数のシンタックスシュガーです。"

#: ../../library/importlib.rst:44
msgid ":pep:`235`"
msgstr ":pep:`235`"

#: ../../library/importlib.rst:44
msgid "Import on Case-Insensitive Platforms"
msgstr "大文字小文字を区別しないプラットフォームでのインポート"

#: ../../library/importlib.rst:47
msgid ":pep:`263`"
msgstr ":pep:`263`"

#: ../../library/importlib.rst:47
msgid "Defining Python Source Code Encodings"
msgstr "Python のソースコードのエンコーディング"

#: ../../library/importlib.rst:50
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../../library/importlib.rst:50
msgid "New Import Hooks"
msgstr "新しいインポートフック"

#: ../../library/importlib.rst:53
msgid ":pep:`328`"
msgstr ":pep:`328`"

#: ../../library/importlib.rst:53
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "複数行のインポートと、絶対/相対インポート"

#: ../../library/importlib.rst:56
msgid ":pep:`366`"
msgstr ":pep:`366`"

#: ../../library/importlib.rst:56
msgid "Main module explicit relative imports"
msgstr "main モジュールの明示的な相対インポート"

#: ../../library/importlib.rst:59
msgid ":pep:`420`"
msgstr ":pep:`420`"

#: ../../library/importlib.rst:59
msgid "Implicit namespace packages"
msgstr "暗黙的な名前空間パッケージ"

#: ../../library/importlib.rst:62
msgid ":pep:`451`"
msgstr ":pep:`451`"

#: ../../library/importlib.rst:62
msgid "A ModuleSpec Type for the Import System"
msgstr "インポートシステムのための ModuleSpec 型"

#: ../../library/importlib.rst:65
msgid ":pep:`488`"
msgstr ":pep:`488`"

#: ../../library/importlib.rst:65
msgid "Elimination of PYO files"
msgstr "PYO ファイルの撤廃"

#: ../../library/importlib.rst:68
msgid ":pep:`489`"
msgstr ":pep:`489`"

#: ../../library/importlib.rst:68
msgid "Multi-phase extension module initialization"
msgstr "複数フェーズでの拡張モジュールの初期化"

#: ../../library/importlib.rst:71
msgid ":pep:`3120`"
msgstr ":pep:`3120`"

#: ../../library/importlib.rst:71
msgid "Using UTF-8 as the Default Source Encoding"
msgstr "デフォルトのソースエンコーディングとして UTF-8 を使用"

#: ../../library/importlib.rst:73
msgid ":pep:`3147`"
msgstr ":pep:`3147`"

#: ../../library/importlib.rst:74
msgid "PYC Repository Directories"
msgstr "PYC リポジトリディレクトリ"

#: ../../library/importlib.rst:78
msgid "Functions"
msgstr "関数"

#: ../../library/importlib.rst:82
msgid "An implementation of the built-in :func:`__import__` function."
msgstr "組み込みの :func:`__import__` 関数の実装です。"

#: ../../library/importlib.rst:85
msgid ""
"Programmatic importing of modules should use :func:`import_module` instead "
"of this function."
msgstr "プログラムからモジュールをインポートする場合はこの関数の代わりに :func:`import_module` を使ってください。"

#: ../../library/importlib.rst:90
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set"
" to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""
"モジュールをインポートします。*name* 引数は、インポートするモジュールを絶対または相対表現 (例えば ``pkg.mod`` または "
"``..mod``) で指定します。name が相対表現で与えられたら、*package* "
"引数を、パッケージ名を解決するためのアンカーとなるパッケージの名前に設定する必要があります (例えば ``import_module('..mod', "
"'pkg.subpkg')`` は ``pkg.mod`` をインポートします)。"

#: ../../library/importlib.rst:98
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around "
":func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`. The most important difference "
"between these two functions is that :func:`import_module` returns the "
"specified package or module (e.g. ``pkg.mod``), while :func:`__import__` "
"returns the top-level package or module (e.g. ``pkg``)."
msgstr ""
":func:`import_module` 関数は :func:`importlib.__import__` "
"を単純化するラッパーとして働きます。つまり、この関数のすべての意味は :func:`importlib.__import__` "
"から受け継いでいます。これらの2つの関数の最も重要な違いは、 :func:`import_module` が指定されたパッケージやモジュール (例えば "
"``pkg.mod``) を返すのに対し、 :func:`__import__` はトップレベルのパッケージやモジュール (例えば ``pkg``) "
"を返すことです。"

#: ../../library/importlib.rst:105
msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may "
"need to call :func:`invalidate_caches` in order for the new module to be "
"noticed by the import system."
msgstr ""
"もしモジュールを動的にインポートしていて、インタープリタの実行開始後にモジュールが作成された (例えば、 Python ソースファイルを作成した) "
"場合、インポートシステムが新しいモジュールを見つけられるように、 :func:`invalidate_caches` を呼ぶ必要があるでしょう。"

#: ../../library/importlib.rst:110
msgid "Parent packages are automatically imported."
msgstr "親パッケージは自動的にインポートされます。"

#: ../../library/importlib.rst:115
msgid ""
"Find the loader for a module, optionally within the specified *path*. If the"
" module is in :attr:`sys.modules`, then ``sys.modules[name].__loader__`` is "
"returned (unless the loader would be ``None`` or is not set, in which case "
":exc:`ValueError` is raised). Otherwise a search using :attr:`sys.meta_path`"
" is done. ``None`` is returned if no loader is found."
msgstr ""
"モジュールのローダーを、オプションで指定された *path* 内から、検索します。モジュールが :attr:`sys.modules` にあれば、 "
"``sys.modules[name].__loader__`` が返されます (ただしローダーが ``None`` であるか設定されていなければ "
":exc:`ValueError` が送出されます)。なければ、 :attr:`sys.meta_path` "
"を使った検索がなされます。ローダーが見つからなければ ``None`` が返ります。"

#: ../../library/importlib.rst:121
msgid ""
"A dotted name does not have its parents implicitly imported as that requires"
" loading them and that may not be desired. To properly import a submodule "
"you will need to import all parent packages of the submodule and use the "
"correct argument to *path*."
msgstr ""
"ドットのついた名前表記は、親モジュールのロードが必要なときに暗黙にインポートしないので、望ましくありません。\n"
"サブモジュールを適切にインポートするには、そのサブモジュールの全ての親パッケージをインポートし、 *path* に正しい引数を使ってください。"

#: ../../library/importlib.rst:128
msgid ""
"If ``__loader__`` is not set, raise :exc:`ValueError`, just like when the "
"attribute is set to ``None``."
msgstr ""
"``__loader__`` が set でない場合、``None`` に設定されているときと同様に :exc:`ValueError` を送出します。"

#: ../../library/importlib.rst:132
msgid "Use :func:`importlib.util.find_spec` instead."
msgstr "代わりに :func:`importlib.util.find_spec` を使用してください。"

#: ../../library/importlib.rst:137
msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are"
" created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""
":data:`sys.meta_path` に保存されたファインダーの内部キャッシュを無効にします。ファインダーが "
"``invalidate_caches()`` "
"を実装していれば、無効化を行うためにそれが呼び出されます。すべてのファインダーが新しいモジュールの存在に気づくことを保証しているプログラムの実行中に、モジュールが作成またはインストールされたなら、この関数が呼び出されるべきです。"

#: ../../library/importlib.rst:147
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (which can be different if re-importing "
"causes a different object to be placed in :data:`sys.modules`)."
msgstr ""
"以前にインポートされた *module* "
"をリロードします。引数はモジュールオブジェクトでなければならず、したがってそれ以前に必ずインポートに成功していなければなりません。この関数は、モジュールのソースファイルを外部エディタで編集していて"
" Python インタープリタから離れることなく新しいバージョンを試したい際に便利です。戻り値はモジュールオブジェクトです。 "
"(もし再インポートが異なるオブジェクトを :data:`sys.modules` に配置したら、元の *module* とは異なるかもしれません。)"

#: ../../library/importlib.rst:154
msgid "When :func:`reload` is executed:"
msgstr ":func:`reload` が実行された場合:"

#: ../../library/importlib.rst:156
msgid ""
"Python module's code is recompiled and the module-level code re-executed, "
"defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the module."
"  The ``init`` function of extension modules is not called a second time."
msgstr ""
"Python "
"モジュールのコードは再コンパイルされ、モジュールレベルのコードが再度実行されます。モジュールの辞書中にある何らかの名前に結び付けられたオブジェクトは、そのモジュールを最初にロードしたときの"
" :term:`ローダー <loader>` を再利用して新たに定義されます。拡張モジュールの ``init`` "
"関数が二度呼び出されることはありません。"

#: ../../library/importlib.rst:162
msgid ""
"As with all other objects in Python the old objects are only reclaimed after"
" their reference counts drop to zero."
msgstr "Python における他のオブジェクトと同様、以前のオブジェクトのメモリ領域は、参照カウントがゼロにならないかぎり再利用されません。"

#: ../../library/importlib.rst:165
msgid ""
"The names in the module namespace are updated to point to any new or changed"
" objects."
msgstr "モジュール名前空間内の名前は新しいオブジェクト (または更新されたオブジェクト) を指すよう更新されます。"

#: ../../library/importlib.rst:168
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"以前のオブジェクトが (外部の他のモジュールなどからの) "
"参照を受けている場合、それらを新たなオブジェクトに再束縛し直すことはないので、必要なら自分で名前空間を更新しなければなりません。"

#: ../../library/importlib.rst:172
msgid "There are a number of other caveats:"
msgstr "いくつか補足説明があります:"

#: ../../library/importlib.rst:174
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"モジュールが再ロードされた際、その辞書 (モジュールのグローバル変数を含みます) "
"はそのまま残ります。名前の再定義を行うと、以前の定義を上書きするので、一般的には問題はありません。新たなバージョンのモジュールが古いバージョンで定義された名前を定義していない場合、古い定義がそのまま残ります。辞書がグローバルテーブルやオブジェクトのキャッシュを維持していれば、この機能をモジュールを有効性を引き出すために使うことができます"
" --- つまり、 :keyword:`try` 文を使えば、必要に応じてテーブルがあるかどうかをテストし、その初期化を飛ばすことができます::"

#: ../../library/importlib.rst:188
msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and other "
"key modules is not recommended.  In many cases extension modules are not "
"designed to be initialized more than once, and may fail in arbitrary ways "
"when reloaded."
msgstr ""
"組み込みモジュールや動的にロードされるモジュールを再ロードすることは、一般的にそれほど便利ではありません。 :mod:`sys`, "
":mod:`__main__`, :mod:`builtins` やその他重要なモジュールの再ロードはお勧め出来ません。多くの場合、拡張モジュールは 1"
" 度以上初期化されるようには設計されておらず、再ロードされた場合には何らかの理由で失敗するかもしれません。"

#: ../../library/importlib.rst:194
msgid ""
"If a module imports objects from another module using :keyword:`from` ... "
":keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`from` statement, another is to use :keyword:`import` "
"and qualified names (*module.name*) instead."
msgstr ""
"一方のモジュールが :keyword:`from` ... :keyword:`import` ... "
"を使って、オブジェクトを他方のモジュールからインポートしているなら、他方のモジュールを :func:`reload` "
"で呼び出しても、そのモジュールからインポートされたオブジェクトを再定義することはできません --- この問題を回避する一つの方法は、 "
":keyword:`from` 文を再度実行することで、もう一つの方法は :keyword:`from` 文の代わりに "
":keyword:`import` と限定的な名前 (*module.name*) を使うことです。"

#: ../../library/importlib.rst:200
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"あるモジュールがクラスのインスタンスを生成している場合、そのクラスを定義しているモジュールの再ロードはそれらインスタンスのメソッド定義に影響しません "
"--- それらは古いクラス定義を使い続けます。これは派生クラスの場合でも同じです。"

#: ../../library/importlib.rst:209
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ":mod:`importlib.abc` -- インポートに関連する抽象基底クラス"

#: ../../library/importlib.rst:214
msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**ソースコード:** :source:`Lib/importlib/abc.py`"

#: ../../library/importlib.rst:219
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base"
" classes are also provided to help in implementing the core ABCs."
msgstr ""
":mod:`importlib.abc` モジュールは、 :keyword:`import` "
"に使われるすべてのコア抽象基底クラス含みます。コア抽象基底クラスの実装を助けるために、コア抽象基底クラスのサブクラスもいくつか提供されています。"

#: ../../library/importlib.rst:223
msgid "ABC hierarchy::"
msgstr "抽象基底クラス階層::"

#: ../../library/importlib.rst:239
msgid "An abstract base class representing a :term:`finder`."
msgstr ":term:`finder` を表す抽象基底クラスです。"

#: ../../library/importlib.rst:241
msgid "Use :class:`MetaPathFinder` or :class:`PathEntryFinder` instead."
msgstr "代わりに :class:`MetaPathFinder` または :class:`PathEntryFinder` を使ってください。"

#: ../../library/importlib.rst:246
msgid ""
"An abstact method for finding a :term:`loader` for the specified module.  "
"Originally specified in :pep:`302`, this method was meant for use in "
":data:`sys.meta_path` and in the path-based import subsystem."
msgstr ""
"指定されたモジュールの :term:`ローダー <loader>` を検索するための抽象メソッドです。もとは :pep:`302` "
"で仕様が定められ、このメソッドは :data:`sys.meta_path` "
"の中およびパスに基づくインポートサブシステムの中で使用することを意図されています。"

#: ../../library/importlib.rst:250
msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`."
msgstr "呼び出されたときに :exc:`NotImplementedError` を送出する代わりに ``None`` を返します。"

#: ../../library/importlib.rst:257
msgid ""
"An abstract base class representing a :term:`meta path finder`. For "
"compatibility, this is a subclass of :class:`Finder`."
msgstr ""
":term:`meta path finder` を表す抽象基底クラスです。互換性のため、これは :class:`Finder` のサブクラスです。"

#: ../../library/importlib.rst:264
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be ``None``.  "
"Otherwise, this is a search for a subpackage or module and *path* will be "
"the value of :attr:`__path__` from the parent package. If a spec cannot be "
"found, ``None`` is returned. When passed in, ``target`` is a module object "
"that the finder may use to make a more educated guess about what spec to "
"return."
msgstr ""

#: ../../library/importlib.rst:276
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  If "
"this is a top-level import, *path* will be ``None``. Otherwise, this is a "
"search for a subpackage or module and *path* will be the value of "
":attr:`__path__` from the parent package. If a loader cannot be found, "
"``None`` is returned."
msgstr ""
"指定されたモジュールの :term:`ローダー <loader>` を検索するためのレガシーなメソッドです。これがトップレベルのインポートなら、 "
"*path* は ``None`` になります。そうでなければ、これはサブパッケージまたはモジュールの検索で、 *path* は親パッケージの "
":attr:`__path__` の値になります。ローダーが見つからなければ、 ``None`` が返されます。"

#: ../../library/importlib.rst:282
msgid ""
"If :meth:`find_spec` is defined, backwards-compatible functionality is "
"provided."
msgstr ":meth:`find_spec` が定義された場合、後方互換な機能が提供されます。"

#: ../../library/importlib.rst:285
msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`. "
"Can use :meth:`find_spec` to provide functionality."
msgstr ""
"このメソッドが呼ばれた場合 :exc:`NotImplementedError` を投げる代わりに ``None`` を返します。この機能を提供するのに"
" :meth:`find_spec` を使用できます。"

#: ../../library/importlib.rst:290 ../../library/importlib.rst:343
#: ../../library/importlib.rst:351 ../../library/importlib.rst:847
msgid "Use :meth:`find_spec` instead."
msgstr "代わりに :meth:`find_spec` を使用してください。"

#: ../../library/importlib.rst:295
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"このファインダーで使われている内部キャッシュがあれば無効にするオプションのメソッドです。 :data:`sys.meta_path` "
"上のすべてのファインダーのキャッシュを無効化する際、 :func:`importlib.invalidate_caches` によって使われます。"

#: ../../library/importlib.rst:299
msgid "Returns ``None`` when called instead of ``NotImplemented``."
msgstr "呼び出されたときに ``NotImplemented`` を送出する代わりに ``None`` を返します。"

#: ../../library/importlib.rst:305
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by "
":class:`PathFinder`. This ABC is a subclass of :class:`Finder` for "
"compatibility reasons only."
msgstr ""
":term:`パスエントリ・ファインダー <path entry finder>` を表す抽象基底クラスです。 "
":class:`MetaPathFinder` と似ているところがありますが、 ``PathEntryFinder`` は "
":class:`PathFinder` "
"の与えるパスに基づくインポートサブシステムの中でのみ使うことが意図されています。この抽象基底クラスは互換性の理由だけのために、 "
":class:`Finder` のサブクラスにしてあります。"

#: ../../library/importlib.rst:315
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the "
":term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that "
"the finder may use to make a more educated guess about what spec to return."
msgstr ""

#: ../../library/importlib.rst:326
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  "
"Returns a 2-tuple of ``(loader, portion)`` where ``portion`` is a sequence "
"of file system locations contributing to part of a namespace package. The "
"loader may be ``None`` while specifying ``portion`` to signify the "
"contribution of the file system locations to a namespace package. An empty "
"list can be used for ``portion`` to signify the loader is not part of a "
"namespace package. If ``loader`` is ``None`` and ``portion`` is the empty "
"list then no loader or location for a namespace package were found (i.e. "
"failure to find anything for the module)."
msgstr ""
"指定されたモジュールの :term:`ローダー <loader>` を検索する抽象メソッドです。 ``(loader, portion)`` の "
"2-タプルを返します。ただし ``portion`` は名前空間パッケージの部分に寄与するファイルシステム上の場所のシーケンスです。 loader "
"は名前空間パッケージへのファイルシステム上の場所の寄与を表す ``portion`` を明記するとき ``None`` にできます。loader "
"が名前空間パッケージの一部ではないことを明記するとき ``portion`` に空のリストが使えます。 ``loader`` が ``None`` で "
"``portion`` が空のリストなら、名前空間パッケージのローダーや場所が見つかりませんでした (すなわち、モジュールの何も見つかりませんでした)。"

#: ../../library/importlib.rst:336
msgid ""
"If :meth:`find_spec` is defined then backwards-compatible functionality is "
"provided."
msgstr ":meth:`find_spec` が定義された場合、後方互換な機能が提供されます。"

#: ../../library/importlib.rst:339
msgid ""
"Returns ``(None, [])`` instead of raising :exc:`NotImplementedError`. Uses "
":meth:`find_spec` when available to provide functionality."
msgstr ""
":exc:`NotImplementedError` を送出する代わりに ``(None, [])`` を返します。機能を提供できる場合 "
":meth:`find_spec` を使用します。"

#: ../../library/importlib.rst:348
msgid ""
"A concrete implementation of :meth:`Finder.find_module` which is equivalent "
"to ``self.find_loader(fullname)[0]``."
msgstr ""
":meth:`Finder.find_module` の具象実装で、 ``self.find_loader(fullname)[0]`` と等価です。"

#: ../../library/importlib.rst:356
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :meth:`PathFinder.invalidate_caches` when "
"invalidating the caches of all cached finders."
msgstr ""
"このファインダーで使われている内部キャッシュがあれば無効にするオプションのメソッドです。キャッシュされたすべてのファインダーの無効化する際、 "
":meth:`PathFinder.invalidate_caches` によって使われます。"

#: ../../library/importlib.rst:363
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ":term:`loader` の抽象基底クラスです。ローダーの厳密な定義は :pep:`302` を参照してください。"

#: ../../library/importlib.rst:368
msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr ""
"モジュールをインポートする際に使用されるモジュールオブジェクトを返すメソッド。このメソッドは ``None`` "
"を戻すことができ、その場合はデフォルトのモジュール作成のセマンティクスが適用されることを示します。"

#: ../../library/importlib.rst:374
msgid ""
"Starting in Python 3.6, this method will not be optional when "
":meth:`exec_module` is defined."
msgstr "Python 3.6 からは、 :meth:`exec_module` が定義されている場合は、このメソッドはオプションではなくなります。"

#: ../../library/importlib.rst:380
msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized "
"when ``exec_module()`` is called. When this method exists, "
":meth:`~importlib.abc.Loader.create_module` must be defined."
msgstr ""

#: ../../library/importlib.rst:387
msgid ":meth:`~importlib.abc.Loader.create_module` must also be defined."
msgstr ""

#: ../../library/importlib.rst:392
msgid ""
"A legacy method for loading a module. If the module cannot be loaded, "
":exc:`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""
"モジュールをロードするためのレガシーなメソッドです。モジュールがロードできなければ :exc:`ImportError` "
"を送出し、ロードできればロードされたモジュールを返します。"

#: ../../library/importlib.rst:396
msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module"
" and insert it into :data:`sys.modules` before any loading begins, to "
"prevent recursion from the import. If the loader inserted a module and the "
"load fails, it must be removed by the loader from :data:`sys.modules`; "
"modules already in :data:`sys.modules` before the loader began execution "
"should be left alone (see :func:`importlib.util.module_for_loader`)."
msgstr ""
"要求されたモジュールが既に :data:`sys.modules` "
"に存在したなら、そのモジュールが使われリロードされる必要があります。存在しなければ、インポートからの再帰を防ぐため、ローダーはロードが始まる前に新しいモジュールを作成して"
" :data:`sys.modules` に挿入する必要があります。ローダーがモジュールを挿入した後にロードが失敗したなら、ローダーはそのモジュールを "
":data:`sys.modules` から削除する必要があります。ローダーが実行を始める前に既に :data:`sys.modules` "
"にあったモジュールは、そのままにします (:func:`importlib.util.module_for_loader` を参照してください)。"

#: ../../library/importlib.rst:405
msgid ""
"The loader should set several attributes on the module. (Note that some of "
"these attributes can change when a module is reloaded):"
msgstr ""
"ローダーはモジュールにいくつかの属性を設定する必要があります。(なお、これらの属性には、モジュールがリロードされた際に変化するものがあります):"

#: ../../library/importlib.rst:410
msgid ":attr:`__name__`"
msgstr ":attr:`__name__`"

#: ../../library/importlib.rst:410
msgid "The name of the module."
msgstr "モジュールの名前です。"

#: ../../library/importlib.rst:414
msgid ":attr:`__file__`"
msgstr ":attr:`__file__`"

#: ../../library/importlib.rst:413
msgid ""
"The path to where the module data is stored (not set for built-in modules)."
msgstr "モジュールのデータが保存されている場所へのパスです (組み込みモジュールには設定されません)。"

#: ../../library/importlib.rst:418
msgid ":attr:`__cached__`"
msgstr ":attr:`__cached__`"

#: ../../library/importlib.rst:417
msgid ""
"The path to where a compiled version of the module is/should be stored (not "
"set when the attribute would be inappropriate)."
msgstr "モジュールのコンパイルされた版が保存されている (べき) 場所へのパスです (この属性が適切でないときには設定されません)。"

#: ../../library/importlib.rst:422
msgid ":attr:`__path__`"
msgstr ":attr:`__path__`"

#: ../../library/importlib.rst:421
msgid ""
"A list of strings specifying the search path within a package. This "
"attribute is not set on modules."
msgstr "パッケージ内の検索パスを指定する文字列のリストです。この属性はモジュールには設定されません。"

#: ../../library/importlib.rst:428
msgid ":attr:`__package__`"
msgstr ":attr:`__package__`"

#: ../../library/importlib.rst:425
msgid ""
"The parent package for the module/package. If the module is top-level then "
"it has a value of the empty string. The "
":func:`importlib.util.module_for_loader` decorator can handle the details "
"for :attr:`__package__`."
msgstr ""
"モジュールやパッケージの親パッケージです。そのモジュールがトップレベルなら、空文字列の値をとります。 "
":func:`importlib.util.module_for_loader` デコレータで、:attr:`__package__` "
"の詳細を扱えます。"

#: ../../library/importlib.rst:433
msgid ":attr:`__loader__`"
msgstr ":attr:`__loader__`"

#: ../../library/importlib.rst:431
msgid ""
"The loader used to load the module. The "
":func:`importlib.util.module_for_loader` decorator can handle the details "
"for :attr:`__package__`."
msgstr ""
"モジュールをロードするのに使われたローダーです。 :func:`importlib.util.module_for_loader` デコレータで、 "
":attr:`__package__` の詳細を扱えます。"

#: ../../library/importlib.rst:435
msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr ":meth:`exec_module` が利用可能な場合、後方互換な機能が提供されます。"

#: ../../library/importlib.rst:438
msgid ""
"Raise :exc:`ImportError` when called instead of :exc:`NotImplementedError`. "
"Functionality provided when :meth:`exec_module` is available."
msgstr ""
"このメソッドが呼ばれた時に、 :exc:`NotImplementedError` の代わりに :exc:`ImportError` を送出します。 "
":meth:`exec_module` が利用可能な時は、この機能は提供されます。"

#: ../../library/importlib.rst:443
msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and "
":meth:`create_module`).  Loaders should implement it instead of "
"load_module().  The import machinery takes care of all the other "
"responsibilities of load_module() when exec_module() is implemented."
msgstr ""
"モジュールをロードするための推奨される API は、 :meth:`exec_module` (および :meth:`create_module`) "
"です。ローダーは load_module() の代わりにそれを実装するべきです。 exec_module() が実装されている場合、インポート機構は "
"load_module() の他のすべての責任を肩代わりします。"

#: ../../library/importlib.rst:452
msgid ""
"A legacy method which when implemented calculates and returns the given "
"module's repr, as a string. The module type's default repr() will use the "
"result of this method as appropriate."
msgstr ""
"実装されていた場合、与えられたモジュールの repr を計算して文字列として返すためのレガシーなメソッドです。モジュール型のデフォルトの repr() "
"は、必要に応じてこのメソッドの結果を使います。"

#: ../../library/importlib.rst:458
msgid "Made optional instead of an abstractmethod."
msgstr "抽象メソッドではなくオプショナルになりました。"

#: ../../library/importlib.rst:461
msgid "The import machinery now takes care of this automatically."
msgstr "インポート機構はこれを自動的に考慮するようになりました。"

#: ../../library/importlib.rst:467
msgid ""
"An abstract base class for a :term:`loader` which implements the optional "
":pep:`302` protocol for loading arbitrary resources from the storage back-"
"end."
msgstr ""
":term:`loader` の抽象基底クラスで、ストレージバックエンドから任意のリソースをロードするオプションの :pep:`302` "
"プロトコルを実装します。"

#: ../../library/importlib.rst:473
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary"
" data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's :attr:`__file__` "
"attribute or an item from a package's :attr:`__path__`."
msgstr ""
"*path* "
"に割り当てられたデータのバイト列を返す抽象メソッドです。任意のデータを保管できるファイル的なストレージバックエンドをもつローダーは、この抽象メソッドを実装して、保管されたデータに直接アクセスさせるようにできます。"
" *path* が見つからなければ :exc:`OSError` を送出する必要があります。 *path* は、モジュールの "
":attr:`__file__` 属性を使って、またはパッケージの :attr:`__path__` の要素を使って、構成されることが期待されます。"

#: ../../library/importlib.rst:481
msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` の代わりに :exc:`OSError` を送出します。"

#: ../../library/importlib.rst:487
msgid ""
"An abstract base class for a :term:`loader` which implements the optional "
":pep:`302` protocol for loaders that inspect modules."
msgstr ""
":term:`loader` の抽象基底クラスで、ローダーがモジュールを検査するためのオプションの :pep:`302` プロトコルを実装します。"

#: ../../library/importlib.rst:492
msgid ""
"Return the code object for a module, or ``None`` if the module does not have"
" a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"モジュールの :class:`code` オブジェクトを返すか、 (例えば組み込みモジュールの場合に) モジュールがコードオブジェクトを持たなければ "
"``None`` を返します。要求されたモジュールをローダーが見つけられなかった場合は :exc:`ImportError` を送出します。"

#: ../../library/importlib.rst:498
msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr "このメソッドにはデフォルト実装がありますが、とはいえパフォーマンスのために、可能ならばオーバライドしたほうが良いです。"

#: ../../library/importlib.rst:504
msgid "No longer abstract and a concrete implementation is provided."
msgstr "このメソッドはもはや抽象メソッドではなく、具象実装が提供されます。"

#: ../../library/importlib.rst:509
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is"
" available (e.g. a built-in module). Raises :exc:`ImportError` if the loader"
" cannot find the module specified."
msgstr ""
"モジュールのソースを返す抽象メソッドです。これは認識されたすべての行セパレータを ``'\\n'`` 文字に変換し、 :term:`universal "
"newlines` を使ったテキスト文字列として返されます。利用できるソースがなければ (例えば組み込みモジュール)、 ``None`` "
"を返します。指定されたモジュールが見つからなければ、 :exc:`ImportError` を送出します。"

#: ../../library/importlib.rst:515 ../../library/importlib.rst:524
#: ../../library/importlib.rst:574
msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` の代わりに :exc:`ImportError` を送出します。"

#: ../../library/importlib.rst:520
msgid ""
"An abstract method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""
"モジュールがパッケージであれば True を返し、そうでなければ False を返す抽象メソッドです。 :term:`ローダー <loader>` "
"がモジュールを見つけられなかったなら :exc:`ImportError` が送出されます。"

#: ../../library/importlib.rst:529
msgid "Create a code object from Python source."
msgstr "Python のソースからコードオブジェクトを作ります。"

#: ../../library/importlib.rst:531
msgid ""
"The *data* argument can be whatever the :func:`compile` function supports "
"(i.e. string or bytes). The *path* argument should be the \"path\" to where "
"the source code originated from, which can be an abstract concept (e.g. "
"location in a zip file)."
msgstr ""
"*data* 引数は :func:`compile` 関数がサポートするもの (すなわち文字列かバイト) なら何でも構いません。*path* "
"引数はソースコードの元々の場所への \"パス\" でなければなりませんが、抽象概念 (例えば zip ファイル内の場所) でも構いません。"

#: ../../library/importlib.rst:536
msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr ""
"結果のコードオブジェクトを使って、 ``exec(code, module.__dict__)`` を呼ぶことでモジュール内でコードを実行できます。"

#: ../../library/importlib.rst:541
msgid "Made the method static."
msgstr "スタティックメソッドになりました。"

#: ../../library/importlib.rst:546
msgid "Implementation of :meth:`Loader.exec_module`."
msgstr ":meth:`Loader.exec_module` の実装です。"

#: ../../library/importlib.rst:552
msgid "Implementation of :meth:`Loader.load_module`."
msgstr ":meth:`Loader.load_module` の実装です。"

#: ../../library/importlib.rst:554
msgid "use :meth:`exec_module` instead."
msgstr "代わりに :meth:`exec_module` を使用してください。"

#: ../../library/importlib.rst:560
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when"
" implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""
":class:`InspectLoader` "
"から継承された抽象基底クラスで、実装されていれば、モジュールをスクリプトとして実行する助けになります。この抽象基底クラスはオプションの "
":pep:`302` プロトコルを表します。"

#: ../../library/importlib.rst:566
msgid ""
"An abstract method that is to return the value of :attr:`__file__` for the "
"specified module. If no path is available, :exc:`ImportError` is raised."
msgstr ""
"指定されたモジュールの :attr:`__file__` の値を返す抽象メソッドです。利用できるパスがなければ、 :exc:`ImportError` "
"が送出されます。"

#: ../../library/importlib.rst:570
msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr ""
"ソースコードが利用できるなら、そのモジュールのロードにバイトコードが使われたかにかかわらず、このメソッドはそのソースファイルへのパスを返す必要があります。"

#: ../../library/importlib.rst:580
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and "
":class:`ExecutionLoader`, providing concrete implementations of "
":meth:`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
":class:`ResourceLoader` と :class:`ExecutionLoader` から継承された抽象基底クラスで、 "
":meth:`ResourceLoader.get_data` および :meth:`ExecutionLoader.get_filename` "
"の具象実装を提供します。"

#: ../../library/importlib.rst:584
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is"
" to handle. The *path* argument is the path to the file for the module."
msgstr ""
"*fullname* 引数は、ローダーが解決しようとするモジュールの、完全に解決された名前です。*path* 引数は、モジュールのファイルへのパスです。"

#: ../../library/importlib.rst:591
msgid "The name of the module the loader can handle."
msgstr "ローダーが扱えるモジュールの名前です。"

#: ../../library/importlib.rst:595
msgid "Path to the file of the module."
msgstr "モジュールのファイルへのパスです。"

#: ../../library/importlib.rst:599
msgid "Calls super's ``load_module()``."
msgstr "親クラスの ``load_module()`` を呼び出します。"

#: ../../library/importlib.rst:601
msgid "Use :meth:`Loader.exec_module` instead."
msgstr "代わりに :meth:`Loader.exec_module` を使用してください。"

#: ../../library/importlib.rst:606 ../../library/importlib.rst:1041
msgid "Returns :attr:`path`."
msgstr ":attr:`path` を返します。"

#: ../../library/importlib.rst:610
msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "*path* をバイナリファイルとして読み込み、そのバイト列を返します。"

#: ../../library/importlib.rst:615
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and "
":class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"ソース (オプションでバイトコード) ファイルのロードを実装する抽象基底クラスです。このクラスは、 :class:`ResourceLoader` と "
":class:`ExecutionLoader` の両方を継承し、以下の実装が必要です:"

#: ../../library/importlib.rst:619
msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

#: ../../library/importlib.rst:622
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

#: ../../library/importlib.rst:621
msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr "ソースファイルへのパスのみを返す必要があります。ソースなしのロードはサポートされていません。"

#: ../../library/importlib.rst:624
msgid ""
"The abstract methods defined by this class are to add optional bytecode file"
" support. Not implementing these optional methods (or causing them to raise "
":exc:`NotImplementedError`) causes the loader to only work with source code."
" Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"このクラスでこれらの抽象メソッドを定義することで、バイトコードファイルを追加でサポートします。これらのメソッドを定義しなければ (またはそのモジュールが"
" :exc:`NotImplementedError` "
"を送出すれば)、このローダーはソースコードに対してのみ働きます。これらのメソッドを実装することで、ローダーはソースとバイトコードファイル "
"*の組み合わせ* に対して働きます。バイトコードのみを与えた *ソースのない* ロードは認められません。バイトコードファイルは、 Python "
"コンパイラによる解析の工程をなくして速度を上げる最適化です。ですから、バイトコード特有の API は公開されていません。"

#: ../../library/importlib.rst:635
msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr "指定されたパスについてのメタデータを含む :class:`dict` を返す、オプションの抽象メソッドです。サポートされる辞書のキーは:"

#: ../../library/importlib.rst:638
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr "``'mtime'`` (必須): ソースコードの更新時刻を表す整数または浮動小数点数です。"

#: ../../library/importlib.rst:640
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (任意): バイト数で表したソースコードのサイズです。"

#: ../../library/importlib.rst:642
msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr "未来の拡張のため、辞書内の他のキーは無視されます。パスが扱えなければ、 :exc:`OSError` が送出されます。"

#: ../../library/importlib.rst:647 ../../library/importlib.rst:660
msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` の代わりに :exc:`OSError` を送出します。"

#: ../../library/importlib.rst:652
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr "指定されたパスの更新時刻を返す、オプションの抽象メソッドです。"

#: ../../library/importlib.rst:655
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. Raise"
" :exc:`OSError` if the path cannot be handled."
msgstr ""
"このメソッドは廃止され、 :meth:`path_stats` "
"が推奨されます。このモジュールを実装する必要はありませんが、互換性のため現在も利用できます。パスが扱えなければ、 :exc:`OSError` "
"が送出されます。"

#: ../../library/importlib.rst:665
msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr "ファイルパスに指定されたバイト列を書き込むオプションの抽象メソッドです。存在しない中間ディレクトリがあれば、自動で作成されます。"

#: ../../library/importlib.rst:669
msgid ""
"When writing to the path fails because the path is read-only "
"(:attr:`errno.EACCES`/:exc:`PermissionError`), do not propagate the "
"exception."
msgstr ""
"パスへの書き込みが読み出し専用のために失敗したとき (:attr:`errno.EACCES`/:exc:`PermissionError`) "
"、その例外を伝播させません。"

#: ../../library/importlib.rst:673
msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr "呼ばれたときに :exc:`NotImplementedError` を送出することは最早ありません。"

#: ../../library/importlib.rst:678
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr ":meth:`InspectLoader.get_code` の具象実装です。"

#: ../../library/importlib.rst:682
msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr ":meth:`Loader.exec_module` の具象実装です。"

#: ../../library/importlib.rst:688
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr ":meth:`Loader.load_module` の具象実装です。"

#: ../../library/importlib.rst:690
msgid "Use :meth:`exec_module` instead."
msgstr "代わりに :meth:`exec_module` を使用してください。"

#: ../../library/importlib.rst:695
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr ":meth:`InspectLoader.get_source` の具象実装です。"

#: ../../library/importlib.rst:699
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by "
":meth:`ExecutionLoader.get_filename`) is a file named ``__init__`` when the "
"file extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
":meth:`InspectLoader.is_package` の具象実装です。モジュールは、次の *両方* "
"を満たすならパッケージであると決定されます。モジュールの (:meth:`ExecutionLoader.get_filename` で与えられる) "
"ファイルパスが、ファイル拡張子を除くと ``__init__`` という名のファイルであること。モジュール名自体が ``__init__`` "
"で終わらないこと。"

#: ../../library/importlib.rst:707
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` -- インポータおよびパスフック"

#: ../../library/importlib.rst:712
msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**ソースコード:** :source:`Lib/importlib/machinery.py`"

#: ../../library/importlib.rst:716
msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr "このモジュールには、 :keyword:`import` がモジュールを検索してロードするのに役立つ様々なオブジェクトがあります。"

#: ../../library/importlib.rst:721
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr "認識されているソースモジュールのファイル接尾辞を表す文字列のリストです。"

#: ../../library/importlib.rst:728
msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr "最適化されていないバイトコードモジュールのファイル接尾辞を表す文字列のリストです。"

#: ../../library/importlib.rst:733 ../../library/importlib.rst:743
msgid "Use :attr:`BYTECODE_SUFFIXES` instead."
msgstr "代わりに :attr:`BYTECODE_SUFFIXES` を使ってください。"

#: ../../library/importlib.rst:738
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr "最適化されたバイトコードモジュールのファイル接尾辞を表す文字列のリストです。"

#: ../../library/importlib.rst:748
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr "認識されているバイトコードモジュールのファイル接尾辞を表す文字列のリストです (先頭のドットを含みます)。"

#: ../../library/importlib.rst:753
msgid "The value is no longer dependent on ``__debug__``."
msgstr "この値は ``__debug__`` に依存しなくなりました。"

#: ../../library/importlib.rst:758
msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr "認識されている最適化された拡張モジュールのファイル接尾辞を表す文字列のリストです。"

#: ../../library/importlib.rst:765
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a"
" module without needing any details on the kind of module (for example, "
":func:`inspect.getmodulename`)."
msgstr ""
"標準のインポート機構によって認識されているすべてのファイル接尾辞を表す文字列の組み合わせられたリストを返します。これが役立つのは、あるファイルシステムパスがモジュールを参照する可能性があるかだけを知りたくて、そのモジュールの種類を詳しく知る必要はないコード"
" (例えば :func:`inspect.getmodulename`) です。"

#: ../../library/importlib.rst:776
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"組み込みモジュールの :term:`importer` です。すべての既知のモジュールは "
":data:`sys.builtin_module_names` に列挙されています。このクラスは "
":class:`importlib.abc.MetaPathFinder` および "
":class:`importlib.abc.InspectLoader` 抽象基底クラスを実装します。"

#: ../../library/importlib.rst:781 ../../library/importlib.rst:795
#: ../../library/importlib.rst:804 ../../library/importlib.rst:819
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr "インスタンス化を容易にするため、クラスメソッドだけがこのクラスによって定義されます。"

#: ../../library/importlib.rst:784
msgid ""
"As part of :pep:`489`, the builtin importer now implements "
":meth:`Loader.create_module` and :meth:`Loader.exec_module`"
msgstr ""
":pep:`489` の一環として、ビルトインインポーターは :meth:`Loader.create_module` と "
":meth:`Loader.exec_module` を実装しています。"

#: ../../library/importlib.rst:791
msgid ""
"An :term:`importer` for frozen modules. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"フリーズされたモジュールの :term:`インポーター <importer>` です。このクラスは "
":class:`importlib.abc.MetaPathFinder` および "
":class:`importlib.abc.InspectLoader` 抽象基底クラスを実装します。"

#: ../../library/importlib.rst:801
msgid ""
":term:`Finder` for modules declared in the Windows registry.  This class "
"implements the :class:`importlib.abc.Finder` ABC."
msgstr ""
"Windows レジストリで宣言されたモジュールの :term:`Finder` です。このクラスは "
":class:`importlib.abc.Finder` 抽象基底クラスを実装します。"

#: ../../library/importlib.rst:809
msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr ""

#: ../../library/importlib.rst:816
msgid ""
"A :term:`Finder` for :data:`sys.path` and package ``__path__`` attributes. "
"This class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":data:`sys.path` およびパッケージの ``__path__`` 属性の :term:`Finder` です。このクラスは "
":class:`importlib.abc.MetaPathFinder` 抽象基底クラスを実装します。"

#: ../../library/importlib.rst:824
msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, "
":data:`sys.path_importer_cache` is checked. If a non-false object is found "
"then it is used as the :term:`path entry finder` to look for the module "
"being searched for. If no entry is found in :data:`sys.path_importer_cache`,"
" then :data:`sys.path_hooks` is searched for a finder for the path entry "
"and, if found, is stored in :data:`sys.path_importer_cache` along with being"
" queried about the module. If no finder is ever found then ``None`` is both "
"stored in the cache and returned."
msgstr ""
":data:`sys.path` または定義されていれば *path* から、 *fullname* で指定されたモジュールの :term:`スペック "
"<module spec>` の検索を試みるクラスメソッドです。検索されるそれぞれのパスエントリに対して "
":data:`sys.path_importer_cache` が検査されます。偽でないオブジェクトが見つかれば、それが目的のモジュールを検索するための"
" :term:`パスエントリ・ファインダー <path entry finder>` として使われます。 "
":data:`sys.path_importer_cache` に目的のエントリが見つからなければ、パスエントリに対するファインダーが "
":data:`sys.path_hooks` から検索され、見つかれば、それが :data:`sys.path_importer_cache` "
"に保管されるとともに、モジュールについて問い合わせられます。それでもファインダーが見つからなければ ``None`` が保管され、また返されます。"

#: ../../library/importlib.rst:838
msgid ""
"If the current working directory -- represented by an empty string -- is no "
"longer valid then ``None`` is returned but no value is cached in "
":data:`sys.path_importer_cache`."
msgstr ""
"もしカレントワーキングディレクトリ -- 空の文字列によって表されている -- がすでに有効でなければ、 ``None`` が返されますが値は "
":data:`sys.path_importer_cache` にキャッシュされません。"

#: ../../library/importlib.rst:845
msgid "A legacy wrapper around :meth:`find_spec`."
msgstr ":meth:`find_spec` まわりのレガシーなラッパです。"

#: ../../library/importlib.rst:852
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders"
" stored in :attr:`sys.path_importer_cache`."
msgstr ""
":attr:`sys.path_importer_cache` に保管されているすべてのファインダーに対して "
":meth:`importlib.abc.PathEntryFinder.invalidate_caches` を呼び出します。"

#: ../../library/importlib.rst:855
msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working directory "
"for ``''`` (i.e. the empty string)."
msgstr ""
"``''`` (すなわち空の文字列) に対してはカレントワーキングディレクトリとともに :data:`sys.path_hooks` "
"のオブジェクトを呼び出します。"

#: ../../library/importlib.rst:862
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr "ファイルシステムからの結果をキャッシュする :class:`importlib.abc.PathEntryFinder` の具象実装です。"

#: ../../library/importlib.rst:865
msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr "*path* 引数は検索を担当するファインダーのディレクトリです。"

#: ../../library/importlib.rst:868
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""
"*loader_details* 引数は、可変個の 2 "
"要素タプルで、それぞれがローダーとローダーが認識するファイル接尾辞のシーケンスとを含みます。ローダーは、呼び出し可能でモジュール名と見つかったファイルのパスとの"
" 2 引数を受け付けることを期待されます。"

#: ../../library/importlib.rst:873
msgid ""
"The finder will cache the directory contents as necessary, making stat calls"
" for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure"
" to call :func:`importlib.invalidate_caches`."
msgstr ""
"ファインダーはモジュール検索のたびに stat "
"を呼び出し、必要に応じてディレクトリの内容をキャッシュすることで、コードキャッシュが古くなっていないことを確かめます。キャッシュの古さはオペレーティングシステムのファイルシステムのステート情報の粒度に依存しますから、モジュールを検索し、新しいファイルを作成し、その後に新しいファイルが表すモジュールを検索する、という競合状態の可能性があります。この操作が"
" stat の呼び出しの粒度に収まるほど速く起こると、モジュールの検索が失敗します。これを防ぐためには、モジュールを動的に作成する際に、必ず "
":func:`importlib.invalidate_caches` を呼び出してください。"

#: ../../library/importlib.rst:887
msgid "The path the finder will search in."
msgstr "ファインダーが検索されるパスです。"

#: ../../library/importlib.rst:891
msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr ":attr:`path` 内で *fullname* を扱うスペックの探索を試みます。"

#: ../../library/importlib.rst:897
msgid "Attempt to find the loader to handle *fullname* within :attr:`path`."
msgstr ":attr:`path` 内で *fullname* を扱うローダーの検索を試みます。"

#: ../../library/importlib.rst:901
msgid "Clear out the internal cache."
msgstr "内部キャッシュを完全に消去します。"

#: ../../library/importlib.rst:905
msgid ""
"A class method which returns a closure for use on :attr:`sys.path_hooks`. An"
" instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""
":attr:`sys.path_hooks` で使用するクロージャを返すクラスメソッドです。クロージャに直接渡された path 引数を直接的に、 "
"*loader_details* を間接的に使って、 :class:`FileFinder` のインスタンスが返されます。"

#: ../../library/importlib.rst:910
msgid ""
"If the argument to the closure is not an existing directory, "
":exc:`ImportError` is raised."
msgstr "クロージャへの引数が存在するディレクトリでなければ、 :exc:`ImportError` が送出されます。"

#: ../../library/importlib.rst:916
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""
":class:`importlib.abc.FileLoader` を継承し、その他いくつかのメソッドの具象実装を提供する、 "
":class:`importlib.abc.SourceLoader` の具象実装です。"

#: ../../library/importlib.rst:924
msgid "The name of the module that this loader will handle."
msgstr "このローダーが扱うモジュールの名前です。"

#: ../../library/importlib.rst:928
msgid "The path to the source file."
msgstr "ソースファイルへのパスです。"

#: ../../library/importlib.rst:932
msgid "Return true if :attr:`path` appears to be for a package."
msgstr ":attr:`path` がパッケージを表すとき True を返します。"

#: ../../library/importlib.rst:936
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr ":meth:`importlib.abc.SourceLoader.path_stats` の具象実装です。"

#: ../../library/importlib.rst:940
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr ":meth:`importlib.abc.SourceLoader.set_data` の具象実装です。"

#: ../../library/importlib.rst:944 ../../library/importlib.rst:987
msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where "
"specifying the name of the module to load is optional."
msgstr ""
"ロードするモジュールの名前指定がオプションの、 :meth:`importlib.abc.Loader.load_module` の具象実装です。"

#: ../../library/importlib.rst:949 ../../library/importlib.rst:992
msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr ""

#: ../../library/importlib.rst:954
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""
"バイトコードファイル (すなわちソースコードファイルが存在しない) をインポートできる "
":class:`importlib.abc.FileLoader` の具象実装です。"

#: ../../library/importlib.rst:957
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations"
" or new versions of Python which change the bytecode format."
msgstr ""
"注意として、バイトコードを直接使う (つまりソースコードファイルがない) と、そのモジュールはすべての Python "
"実装では使用できないし、新しいバージョンの Python ではバイトコードフォーマットが変更されていたら使用できません。"

#: ../../library/importlib.rst:966
msgid "The name of the module the loader will handle."
msgstr "ローダーが扱うモジュールの名前です。"

#: ../../library/importlib.rst:970
msgid "The path to the bytecode file."
msgstr "バイトコードファイルへのパスです。"

#: ../../library/importlib.rst:974
msgid "Determines if the module is a package based on :attr:`path`."
msgstr "そのモジュールがパッケージであるかを :attr:`path` に基づいて決定します。"

#: ../../library/importlib.rst:978
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr ":attr:`path` から作成された :attr:`name` のコードオブジェクトを返します。"

#: ../../library/importlib.rst:982
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr "このローダーが使われたとき、バイトコードファイルのソースがなければ ``None`` を返します。"

#: ../../library/importlib.rst:997
msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr "拡張モジュールのための :class:`importlib.abc.ExecutionLoader` の具象実装です。"

#: ../../library/importlib.rst:1000
msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr "*fullname* 引数はローダーがサポートするモジュールの名前を指定します。*path* 引数は拡張モジュールのファイルへのパスです。"

#: ../../library/importlib.rst:1007
msgid "Name of the module the loader supports."
msgstr "ローダーがサポートするモジュールの名前です。"

#: ../../library/importlib.rst:1011
msgid "Path to the extension module."
msgstr "拡張モジュールへのパスです。"

#: ../../library/importlib.rst:1015
msgid ""
"Creates the module object from the given specification in accordance with "
":pep:`489`."
msgstr "与えられたスペックから :pep:`489` に従ってモジュールオブジェクトを作成します。"

#: ../../library/importlib.rst:1022
msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr "与えられたモジュールオブジェクトを :pep:`489` に従って初期化します。"

#: ../../library/importlib.rst:1028
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :attr:`EXTENSION_SUFFIXES`."
msgstr ""
":attr:`EXTENSION_SUFFIXES` に基づいて、ファイルパスがパッケージの ``__init__`` モジュールを指していれば "
"``True`` を返します。"

#: ../../library/importlib.rst:1033
msgid "Returns ``None`` as extension modules lack a code object."
msgstr "拡張モジュールにコードオブジェクトがなければ ``None`` を返します。"

#: ../../library/importlib.rst:1037
msgid "Returns ``None`` as extension modules do not have source code."
msgstr "拡張モジュールにソースコードがなければ ``None`` を返します。"

#: ../../library/importlib.rst:1048
msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's ``__spec__`` attribute.  In the "
"descriptions below, the names in parentheses give the corresponding "
"attribute available directly on the module object. E.g. "
"``module.__spec__.origin == module.__file__``.  Note however that while the "
"*values* are usually equivalent, they can differ since there is no "
"synchronization between the two objects.  Thus it is possible to update the "
"module's ``__path__`` at runtime, and this will not be automatically "
"reflected in ``__spec__.submodule_search_locations``."
msgstr ""

#: ../../library/importlib.rst:1062
msgid "(``__name__``)"
msgstr "(``__name__``)"

#: ../../library/importlib.rst:1064
msgid "A string for the fully-qualified name of the module."
msgstr "モジュールの完全修飾名を表す文字列です。"

#: ../../library/importlib.rst:1068
msgid "(``__loader__``)"
msgstr "(``__loader__``)"

#: ../../library/importlib.rst:1070
msgid ""
"The loader to use for loading.  For namespace packages this should be set to"
" ``None``."
msgstr "ロードに使うローダです。名前空間パッケージの場合 ``None`` に設定しなければなりません。"

#: ../../library/importlib.rst:1075
msgid "(``__file__``)"
msgstr "(``__file__``)"

#: ../../library/importlib.rst:1077
msgid ""
"Name of the place from which the module is loaded, e.g. \"builtin\" for "
"built-in modules and the filename for modules loaded from source. Normally "
"\"origin\" should be set, but it may be ``None`` (the default) which "
"indicates it is unspecified (e.g. for namespace packages)."
msgstr ""

#: ../../library/importlib.rst:1084
msgid "(``__path__``)"
msgstr "(``__path__``)"

#: ../../library/importlib.rst:1086
msgid ""
"List of strings for where to find submodules, if a package (``None`` "
"otherwise)."
msgstr "パッケージの場合サブモジュールを見付けるべき場所を表す文字列のリスト (そうでない場合は ``None``) です。"

#: ../../library/importlib.rst:1091
msgid ""
"Container of extra module-specific data for use during loading (or "
"``None``)."
msgstr "ロード中に使う拡張モジュール指定のデータのコンテナ (または ``None``) です。"

#: ../../library/importlib.rst:1096
msgid "(``__cached__``)"
msgstr "(``__cached__``)"

#: ../../library/importlib.rst:1098
msgid "String for where the compiled module should be stored (or ``None``)."
msgstr "コンパイルされたモジュールを保存すべき場所を表す文字列 (または ``None``) です。"

#: ../../library/importlib.rst:1102
msgid "(``__package__``)"
msgstr "(``__package__``)"

#: ../../library/importlib.rst:1104
msgid ""
"(Read-only) Fully-qualified name of the package to which the module belongs "
"as a submodule (or ``None``)."
msgstr "(読み出し専用) サブモジュールとしてモジュールが属するパッケージの完全修飾名 (または ``None``) です。"

#: ../../library/importlib.rst:1109
msgid ""
"Boolean indicating whether or not the module's \"origin\" attribute refers "
"to a loadable location."
msgstr "モジュールの \"origin\" 属性がロード可能な場所を参照しているかどうかを示すブール値です。"

#: ../../library/importlib.rst:1113
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` -- インポータのためのユーティリティコード"

#: ../../library/importlib.rst:1119
msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**ソースコード:** :source:`Lib/importlib/util.py`"

#: ../../library/importlib.rst:1123
msgid ""
"This module contains the various objects that help in the construction of an"
" :term:`importer`."
msgstr "このモジュールには、 :term:`インポーター <importer>` の構築を助ける様々なオブジェクトがあります。"

#: ../../library/importlib.rst:1128
msgid ""
"The bytes which represent the bytecode version number. If you need help with"
" loading/writing bytecode then consider :class:`importlib.abc.SourceLoader`."
msgstr ""
"バイトコードバージョン番号を表しているバイト列。バイトコードのロード／書き込みについてヘルプが必要なら "
":class:`importlib.abc.SourceLoader` を参照してください。"

#: ../../library/importlib.rst:1135
msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file associated "
"with the source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the "
"return value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python"
" 3.2. The ``cpython-32`` string comes from the current magic tag (see "
":func:`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then"
" :exc:`NotImplementedError` will be raised)."
msgstr ""
"ソース *path* に関連付けられたバイトコンパイルされたファイルの :pep:`3147`/:pep:`488` パスを返します。例えば、 "
"*path* が ``/foo/bar/baz.py`` なら、 Python 3.2 の場合返り値は "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` になります。 ``cpython-32`` "
"という文字列は、現在のマジックタグから得られます (マジックタグについては :func:`get_tag` を参照; "
":attr:`sys.implementation.cache_tag` が未定義なら :exc:`NotImplementedError` "
"が送出されます。)"

#: ../../library/importlib.rst:1142
msgid ""
"The *optimization* parameter is used to specify the optimization level of "
"the bytecode file. An empty string represents no optimization, so "
"``/foo/bar/baz.py`` with an *optimization* of ``''`` will result in a "
"bytecode path of ``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` "
"causes the interpter's optimization level to be used. Any other value's "
"string representation being used, so ``/foo/bar/baz.py`` with an "
"*optimization* of ``2`` will lead to the bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc``. The string representation"
" of *optimization* can only be alphanumeric, else :exc:`ValueError` is "
"raised."
msgstr ""
"*optimization* "
"パラメータは、バイトコードファイルの最適化レベルを指定するために使われます。空文字列は最適化しないことを表します。したがって、 "
"*optimization* が ``''`` のとき ``/foo/bar/baz.py`` に対して "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` というバイトコードパスが返ります。 ``None`` "
"にするとインタープリタの最適化レベルが使われます。それ以外では値の文字列表現が使われます。したがって、 *optimization* が ``2`` "
"のとき  ``/foo/bar/baz.py`` に対して "
"``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc`` というバイトコードパスが返ります。 "
"*optimization* の文字列表現は英数字だけが可能で、そうでなければ :exc:`ValueError` が上げられます。"

#: ../../library/importlib.rst:1152
msgid ""
"The *debug_override* parameter is deprecated and can be used to override the"
" system's value for ``__debug__``. A ``True`` value is the equivalent of "
"setting *optimization* to the empty string. A ``False`` value is the same as"
" setting *optimization* to ``1``. If both *debug_override* an *optimization*"
" are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"*debug_override* パラメータは deprecated で、システムの ``__debug__`` "
"値をオーバーライドするために使用できます。 ``True`` 値は *optimization* を空文字列に設定するのと等価です。 ``False``"
" 値は *optimization* を ``1`` に設定するのと同等です。もし *debug_override* と *optimization* "
"のどちらも ``None`` 以外であれば :exc:`TypeError` が上げられます。"

#: ../../library/importlib.rst:1160
msgid ""
"The *optimization* parameter was added and the *debug_override* parameter "
"was deprecated."
msgstr "*optimization* パラメータが追加され、 *debug_override* パラメータは deprecated になりました。"

#: ../../library/importlib.rst:1164 ../../library/importlib.rst:1180
#: ../../library/importlib.rst:1319
msgid "Accepts a :term:`path-like object`."
msgstr ":term:`path-like object` を受け入れるようになりました。"

#: ../../library/importlib.rst:1170
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` the returned path would be "
"``/foo/bar/baz.py``.  *path* need not exist, however if it does not conform "
"to :pep:`3147` or :pep:`488` format, a ``ValueError`` is raised. If "
":attr:`sys.implementation.cache_tag` is not defined, "
":exc:`NotImplementedError` is raised."
msgstr ""
":pep:`3147` ファイル名への *path* が与えられると、関連するソースコードのファイルパスを返します。例えば、 *path* が "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` なら、返されるパスは ``/foo/bar/baz.py`` "
"になります。 *path* は存在する必要はありませんが、 :pep:`3147` または :pep:`488` フォーマットに一致しない場合は "
"``ValueError`` が送出されます。 :attr:`sys.implementation.cache_tag` が定義されていない場合、 "
":exc:`NotImplementedError` が送出されます。"

#: ../../library/importlib.rst:1185
msgid ""
"Decode the given bytes representing source code and return it as a string "
"with universal newlines (as required by "
":meth:`importlib.abc.InspectLoader.get_source`)."
msgstr ""
"与えられたソースコードを表すバイト列をデコードして、文字列としてそれを一般的な改行形式 (universal newlines) で返します "
"(:meth:`importlib.abc.InspectLoader.get_source` で要求されるように)。"

#: ../../library/importlib.rst:1193
msgid "Resolve a relative module name to an absolute one."
msgstr "相対的なモジュール名を解決して絶対的なものにします。"

#: ../../library/importlib.rst:1195
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', __package__)``"
" without doing a check to see if the **package** argument is needed."
msgstr ""
"**name** の先頭にドットがなければ、単に **name** が返されます。これにより、例えば "
"``importlib.util.resolve_name('sys', __package__)`` を使うときに **package** "
"変数が必要かどうかを確認する必要がなくなります。"

#: ../../library/importlib.rst:1200
msgid ""
":exc:`ValueError` is raised if **name** is a relative module name but "
"package is a false value (e.g. ``None`` or the empty string). "
":exc:`ValueError` is also raised a relative name would escape its containing"
" package (e.g. requesting ``..bacon`` from within the ``spam`` package)."
msgstr ""
"**name** が相対的なモジュール名であるにもかかわらず package が偽値 (例えば ``None`` や空文字列) ならば、 "
":exc:`ValueError` が送出されます。相対的な名前がそれを含むパッケージから抜け出る (例えば ``spam`` パッケージ内から "
"``..bacon`` を要求する) 場合にも :exc:`ValueError` が送出されます。"

#: ../../library/importlib.rst:1209
msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to the"
" specified **package** name. If the module is in :attr:`sys.modules`, then "
"``sys.modules[name].__spec__`` is returned (unless the spec would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :attr:`sys.meta_path` is done. ``None`` is returned"
" if no spec is found."
msgstr ""
"モジュールの :term:`spec <module spec>` を、オプションで指定された **package** "
"名に対する相対で検索します。モジュールが :attr:`sys.modules` にあれば、 "
"``sys.modules[name].__spec__`` が返されます (ただしスペックが ``None`` であるか設定されていなければ "
":exc:`ValueError` が送出されます)。なければ、 :attr:`sys.meta_path` "
"を使った検索がなされます。スペックが見つからなければ ``None`` が返ります。"

#: ../../library/importlib.rst:1216
msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr "**name** がサブモジュールを示している  (ドットを含む) 場合、親モジュールは自動的にインポートされます。"

#: ../../library/importlib.rst:1219
msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr "**name** と **package** は :func:`import_module` に対するものと同じように機能します。"

#: ../../library/importlib.rst:1225
msgid ""
"Create a new module based on **spec** and :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."
msgstr ""

#: ../../library/importlib.rst:1228
msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""

#: ../../library/importlib.rst:1233
msgid ""
"This function is preferred over using :class:`types.ModuleType` to create a "
"new module as **spec** is used to set as many import-controlled attributes "
"on the module as possible."
msgstr ""
"この関数は、新しいモジュールを作る方法として :class:`types.ModuleType` "
"よりも推奨されます。なぜなら、できるだけ多くのインポートコントロールされた属性をモジュールに設定するために **spec** が使用されるからです。"

#: ../../library/importlib.rst:1241
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to handle "
"selecting the proper module object to load with. The decorated method is "
"expected to have a call signature taking two positional arguments (e.g. "
"``load_module(self, module)``) for which the second argument will be the "
"module **object** to be used by the loader. Note that the decorator will not"
" work on static methods because of the assumption of two arguments."
msgstr ""
"ロードに使う適切なモジュールオブジェクトの選択を扱うための、 :meth:`importlib.abc.Loader.load_module` への "
":term:`decorator` です。このデコレータメソッドのシグニチャは、2 つの位置引数をとることを期待されます (例えば "
"``load_module(self, module)``) 。第二引数はローダーによって使われるモジュール **object** "
"になります。なお、このデコレータは 2 つの引数を想定するため、スタティックメソッドには働きません。"

#: ../../library/importlib.rst:1250
msgid ""
"The decorated method will take in the **name** of the module to be loaded as"
" expected for a :term:`loader`. If the module is not found in "
":data:`sys.modules` then a new one is constructed. Regardless of where the "
"module came from, :attr:`__loader__` set to **self** and :attr:`__package__`"
" is set based on what :meth:`importlib.abc.InspectLoader.is_package` returns"
" (if available). These attributes are set unconditionally to support "
"reloading."
msgstr ""
"デコレートされたメソッドは、 :term:`loader` がロードしようとするモジュールの **name** を受け取ります。そのモジュールが "
":data:`sys.modules` に見つからなければ新しいモジュールが構築されます。モジュールの出所に関わらず、 "
":attr:`__loader__` は **self** に設定され、 (もし利用可能なら) :attr:`__package__` は "
":meth:`importlib.abc.InspectLoader.is_package` "
"の戻り値に基づいて設定されます。これらの属性は、リロードをサポートするために無条件に設定されます。"

#: ../../library/importlib.rst:1258
msgid ""
"If an exception is raised by the decorated method and a module was added to "
":data:`sys.modules`, then the module will be removed to prevent a partially "
"initialized module from being in left in :data:`sys.modules`. If the module "
"was already in :data:`sys.modules` then it is left alone."
msgstr ""
"デコレートされたメソッドによって例外が送出されたとき、モジュールが :data:`sys.modules` "
"に加えられていたら、部分的に初期化されたモジュールが :data:`sys.modules` "
"に残らないよう、そのモジュールは取り除かれます。モジュールが既に :data:`sys.modules` にあったなら、それは残されます。"

#: ../../library/importlib.rst:1263
msgid ""
":attr:`__loader__` and :attr:`__package__` are automatically set (when "
"possible)."
msgstr ":attr:`__loader__` および :attr:`__package__` は (可能なら) 自動的に設定されます。"

#: ../../library/importlib.rst:1267
msgid ""
"Set :attr:`__name__`, :attr:`__loader__` :attr:`__package__` unconditionally"
" to support reloading."
msgstr ""
"リロードをサポートするために :attr:`__name__` :attr:`__loader__` :attr:`__package__` "
"は無条件に設定されます。"

#: ../../library/importlib.rst:1271
msgid ""
"The import machinery now directly performs all the functionality provided by"
" this function."
msgstr "インポート機構はこの関数が提供する全機能を直接実行するようになりました。"

#: ../../library/importlib.rst:1277
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the "
":attr:`__loader__` attribute on the returned module. If the attribute is "
"already set the decorator does nothing. It is assumed that the first "
"positional argument to the wrapped method (i.e. ``self``) is what "
":attr:`__loader__` should be set to."
msgstr ""
"返されたモジュールの :attr:`__loader__` 属性を設定する、 "
":meth:`importlib.abc.Loader.load_module` への :term:`decorator` "
"です。属性が既に設定されていたら、このデコレータは何もしません。ラップされたメソッド (すなわち ``self``) への第一位置引数は "
":attr:`__loader__` に設定される値であると仮定されます。"

#: ../../library/importlib.rst:1284
msgid ""
"Set ``__loader__`` if set to ``None``, as if the attribute does not exist."
msgstr ""
"もし ``__loader__`` 属性が ``None`` に設定されていれば、属性が存在しないかのように ``__loader__`` "
"を設定します。"

#: ../../library/importlib.rst:1288 ../../library/importlib.rst:1297
msgid "The import machinery takes care of this automatically."
msgstr "インポート機構はこれを自動的に考慮するようになりました。"

#: ../../library/importlib.rst:1293
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the "
":attr:`__package__` attribute on the returned module. If :attr:`__package__`"
" is set and has a value other than ``None`` it will not be changed."
msgstr ""
":attr:`__package__` 属性を戻り値のモジュールに設定するための、 "
":meth:`importlib.abc.Loader.load_module` への :term:`decorator` です。もし "
":attr:`__package__` が設定されていて ``None`` 以外の値を持っているなら、それは変更されません。"

#: ../../library/importlib.rst:1302
msgid ""
"A factory function for creating a :class:`ModuleSpec` instance based on a "
"loader.  The parameters have the same meaning as they do for ModuleSpec.  "
"The function uses available :term:`loader` APIs, such as "
":meth:`InspectLoader.is_package`, to fill in any missing information on the "
"spec."
msgstr ""
"この関数は、スペックに不足している情報を埋めるために :meth:`InspectLoader.is_package` のような利用可能な "
":term:`loader` API を使います。"

#: ../../library/importlib.rst:1312
msgid ""
"A factory function for creating a :class:`ModuleSpec` instance based on the "
"path to a file.  Missing information will be filled in on the spec by making"
" use of loader APIs and by the implication that the module will be file-"
"based."
msgstr ""
"ファイルへのパスにもとづいて :class:`ModuleSpec` インスタンスを生成するためのファクトリー関数。不足している情報は、ローダー API"
" を利用してスペックから得られる情報と、モジュールがファイルベースであるという暗黙的な情報によって埋められます。"

#: ../../library/importlib.rst:1324
msgid ""
"A class which postpones the execution of the loader of a module until the "
"module has an attribute accessed."
msgstr "モジュールが属性アクセスできるようになるまで、モジュールのローダーの実行を遅延するクラス。"

#: ../../library/importlib.rst:1327
msgid ""
"This class **only** works with loaders that define "
":meth:`~importlib.abc.Loader.exec_module` as control over what module type "
"is used for the module is required. For those same reasons, the loader's "
":meth:`~importlib.abc.Loader.create_module` method must return ``None`` or a"
" type for which its ``__class__`` attribute can be mutated along with not "
"using :term:`slots <__slots__>`. Finally, modules which substitute the "
"object placed into :attr:`sys.modules` will not work as there is no way to "
"properly replace the module references throughout the interpreter safely; "
":exc:`ValueError` is raised if such a substitution is detected."
msgstr ""

#: ../../library/importlib.rst:1338
msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. For"
" projects where startup time is not essential then use of this class is "
"**heavily** discouraged due to error messages created during loading being "
"postponed and thus occurring out of context."
msgstr ""
"起動時間が重要なプロジェクトでは、もし決して使われないモジュールがあれば、このクラスを使ってモジュールをロードするコストを最小化できるかもしれません。スタートアップ時間が重要でないプロジェクトでは、遅延されたロードの際に発生して文脈の外で起こるエラーメッセージのため、このクラスの使用は"
" **著しく** 推奨されません。"

#: ../../library/importlib.rst:1346
msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` and "
":class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""

#: ../../library/importlib.rst:1353
msgid ""
"A static method which returns a callable that creates a lazy loader. This is"
" meant to be used in situations where the loader is passed by class instead "
"of by instance. ::"
msgstr ""
"遅延ローダを生成する callable "
"を返すスタティックメソッド。これは、ローダーをインスタンスとしてではなくクラスとして渡すような状況において使われることを意図しています。 ::"

#: ../../library/importlib.rst:1366
msgid "Examples"
msgstr "使用例"

#: ../../library/importlib.rst:1369
msgid "Importing programmatically"
msgstr ""

#: ../../library/importlib.rst:1371
msgid ""
"To programmatically import a module, use :func:`importlib.import_module`. ::"
msgstr ""

#: ../../library/importlib.rst:1380
msgid "Checking if a module can be imported"
msgstr ""

#: ../../library/importlib.rst:1382
msgid ""
"If you need to find out if a module can be imported without actually doing "
"the import, then you should use :func:`importlib.util.find_spec`. ::"
msgstr ""

#: ../../library/importlib.rst:1404
msgid "Importing a source file directly"
msgstr ""

#: ../../library/importlib.rst:1406
msgid ""
"To import a Python source file directly, use the following recipe (Python "
"3.4 and newer only)::"
msgstr ""

#: ../../library/importlib.rst:1426
msgid "Setting up an importer"
msgstr ""

#: ../../library/importlib.rst:1428
msgid ""
"For deep customizations of import, you typically want to implement an "
":term:`importer`. This means managing both the :term:`finder` and "
":term:`loader` side of things. For finders there are two flavours to choose "
"from depending on your needs: a :term:`meta path finder` or a :term:`path "
"entry finder`. The former is what you would put on :attr:`sys.meta_path` "
"while the latter is what you create using a :term:`path entry hook` on "
":attr:`sys.path_hooks` which works with :attr:`sys.path` entries to "
"potentially create a finder. This example will show you how to register your"
" own importers so that import will use them (for creating an importer for "
"yourself, read the documentation for the appropriate classes defined within "
"this package)::"
msgstr ""

#: ../../library/importlib.rst:1460
msgid "Approximating :func:`importlib.import_module`"
msgstr ""

#: ../../library/importlib.rst:1462
msgid ""
"Import itself is implemented in Python code, making it possible to expose "
"most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module` (Python 3.4 "
"and newer for the importlib usage, Python 3.6 and newer for other parts of "
"the code). ::"
msgstr ""
