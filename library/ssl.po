# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Takanori Suzuki <takanori@takanory.net>, 2021
# souma987, 2023
# Yusuke Miyazaki <miyazaki.dev@gmail.com>, 2023
# tomo, 2024
# 石井明久, 2024
# Arihiro TAKASE, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-27 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: Arihiro TAKASE, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ssl.rst:2
msgid ":mod:`!ssl` --- TLS/SSL wrapper for socket objects"
msgstr ":mod:`!ssl` --- ソケットオブジェクト用の TLS/SSL ラッパー"

#: ../../library/ssl.rst:10
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**Source code:** :source:`Lib/ssl.py`"

#: ../../library/ssl.rst:18
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, macOS, "
"and probably additional platforms, as long as OpenSSL is installed on that "
"platform."
msgstr ""
"このモジュールは Transport Layer Security ( \"Secure Sockets Layer\" という名"
"前でよく知られています) 暗号化と、クライアントサイド、サーバサイド両方のネッ"
"トワークソケットのためのピア認証の仕組みを提供しています。このモジュールは "
"OpenSSL ライブラリを利用しています。 OpenSSL は、すべてのモダンな Unix システ"
"ム、 Windows 、 macOS 、その他幾つかの OpenSSL がインストールされているプラッ"
"トフォームで利用できます。"

#: ../../library/ssl.rst:26
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.3 comes with OpenSSL "
"version 1.1.1."
msgstr ""

#: ../../library/ssl.rst:32
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may "
"lead to a false sense of security, as the default settings of the ssl module "
"are not necessarily appropriate for your application."
msgstr ""
":ref:`ssl-security` を読まずにこのモジュールを使用しないでください。SSL のデ"
"フォルト設定はアプリケーションに十分ではないので、読まない場合はセキュリティ"
"に誤った意識を持ってしまうかもしれません。"

#: ../../includes/wasm-notavail.rst:3
msgid ":ref:`Availability <availability>`: not WASI."
msgstr ":ref:`利用可能な環境 <availability>`: WASI 以外。"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"このモジュールは WebAssembly では動作しないか、利用不可です。詳しくは、:ref:"
"`wasm-availability` を見てください。"

#: ../../library/ssl.rst:38
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr ""
"このセクションでは、 ``ssl`` モジュールのオブジェクトと関数を解説します。 "
"TLS, SSL, 証明書に関するより一般的な情報は、末尾にある \"See Also\" のセク"
"ションを参照してください。"

#: ../../library/ssl.rst:42
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the "
"certificate of the other side of the connection, :meth:`cipher`, which "
"retrieves the cipher being used for the secure connection or :meth:"
"`get_verified_chain`, :meth:`get_unverified_chain` which retrieves "
"certificate chain."
msgstr ""

#: ../../library/ssl.rst:51
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps "
"manage settings and certificates, which can then be inherited by SSL sockets "
"created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"より洗練されたアプリケーションのために、 :class:`ssl.SSLContext` クラスが設定"
"と証明書の管理の助けとなるでしょう。それは :meth:`SSLContext.wrap_socket` メ"
"ソッドを通して SSL ソケットを作成することで引き継がれます。"

#: ../../library/ssl.rst:55
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr ""

#: ../../library/ssl.rst:60
msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In "
"the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8, 1.0.0, 1.0.1 は廃止されており、もはやサポートされていません。"
"ssl モジュールは、将来的に OpenSSL 1.0.2 または 1.1.0 を必要とするようになり"
"ます。"

#: ../../library/ssl.rst:66
msgid ""
":pep:`644` has been implemented. The ssl module requires OpenSSL 1.1.1 or "
"newer."
msgstr ""

#: ../../library/ssl.rst:69
msgid ""
"Use of deprecated constants and functions result in deprecation warnings."
msgstr ""

#: ../../library/ssl.rst:73
msgid "Functions, Constants, and Exceptions"
msgstr "関数、定数、例外"

#: ../../library/ssl.rst:77
msgid "Socket creation"
msgstr "ソケットの作成"

#: ../../library/ssl.rst:79
msgid ""
"Instances of :class:`SSLSocket` must be created using the :meth:`SSLContext."
"wrap_socket` method. The helper function :func:`create_default_context` "
"returns a new context with secure default settings."
msgstr ""

#: ../../library/ssl.rst:84
msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr ""

#: ../../library/ssl.rst:86
msgid ""
"import socket\n"
"import ssl\n"
"\n"
"hostname = 'www.python.org'\n"
"context = ssl.create_default_context()\n"
"\n"
"with socket.create_connection((hostname, 443)) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"
msgstr ""

#: ../../library/ssl.rst:97
msgid "Client socket example with custom context and IPv4::"
msgstr ""

#: ../../library/ssl.rst:99
msgid ""
"hostname = 'www.python.org'\n"
"# PROTOCOL_TLS_CLIENT requires valid cert chain and hostname\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.load_verify_locations('path/to/cabundle.pem')\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"
msgstr ""

#: ../../library/ssl.rst:109
msgid "Server socket example listening on localhost IPv4::"
msgstr ""

#: ../../library/ssl.rst:111
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.load_cert_chain('/path/to/certchain.pem', '/path/to/private.key')\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    sock.bind(('127.0.0.1', 8443))\n"
"    sock.listen(5)\n"
"    with context.wrap_socket(sock, server_side=True) as ssock:\n"
"        conn, addr = ssock.accept()\n"
"        ..."
msgstr ""

#: ../../library/ssl.rst:123
msgid "Context creation"
msgstr "コンテキストの作成"

#: ../../library/ssl.rst:125
msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr ""
"コンビニエンス関数が、共通の目的で使用される :class:`SSLContext` オブジェクト"
"を作成するのに役立ちます。"

#: ../../library/ssl.rst:130
msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr ""
"新規の :class:`SSLContext` オブジェクトを、与えられた *purpose* のデフォルト"
"設定で返します。設定は :mod:`ssl` モジュールで選択され、通常は :class:"
"`SSLContext` のコンストラクタを直接呼び出すよりも高いセキュリティレベルを表現"
"します。"

#: ../../library/ssl.rst:135
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for "
"certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr ""
"*cafile*, *capath*, *cadata* は証明書の検証で信用するオプションの CA 証明書"
"で、 :meth:`SSLContext.load_verify_locations` のものと同じです。これら 3 つす"
"べてが :const:`None` であれば、この関数は代わりにシステムのデフォルトの CA 証"
"明書を信用して選択することができます。"

#: ../../library/ssl.rst:141
msgid ""
"The settings are: :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2`, and :data:`OP_NO_SSLv3` with "
"high encryption cipher suites without RC4 and without unauthenticated cipher "
"suites. Passing :const:`~Purpose.SERVER_AUTH` as *purpose* sets :data:"
"`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` and either loads CA "
"certificates (when at least one of *cafile*, *capath* or *cadata* is given) "
"or uses :meth:`SSLContext.load_default_certs` to load default CA "
"certificates."
msgstr ""

#: ../../library/ssl.rst:150
msgid ""
"When :attr:`~SSLContext.keylog_filename` is supported and the environment "
"variable :envvar:`SSLKEYLOGFILE` is set, :func:`create_default_context` "
"enables key logging."
msgstr ""

#: ../../library/ssl.rst:154
msgid ""
"The default settings for this context include :data:"
"`VERIFY_X509_PARTIAL_CHAIN` and :data:`VERIFY_X509_STRICT`. These make the "
"underlying OpenSSL implementation behave more like a conforming "
"implementation of :rfc:`5280`, in exchange for a small amount of "
"incompatibility with older X.509 certificates."
msgstr ""

#: ../../library/ssl.rst:161
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr ""
"プロトコル、オプション、暗号方式その他の設定は、事前に非推奨の状態にすること"
"なく、もっと制限の強い値に変更される場合があります。これらの値は、互換性と安"
"全性との妥当なバランスをとって決められます。"

#: ../../library/ssl.rst:165
msgid ""
"If your application needs specific settings, you should create a :class:"
"`SSLContext` and apply the settings yourself."
msgstr ""
"もしもあなたのアプリケーションが特定の設定を必要とする場合、 :class:"
"`SSLContext` を作って自分自身で設定を適用すべきです。"

#: ../../library/ssl.rst:169
msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken <https://en.wikipedia."
"org/wiki/POODLE>`_. If you still wish to continue to use this function but "
"still allow SSL 3.0 connections you can re-enable them using::"
msgstr ""
"ある種の古いクライアントやサーバが接続しようと試みてきた場合に、この関数で作"
"られた :class:`SSLContext` が \"Protocol or cipher suite mismatch\" で始まる"
"エラーを起こすのを目撃したらそれは、この関数が :data:`OP_NO_SSLv3` を使って除"
"外している SSL 3.0 しかサポートしていないのでしょう。SSL 3.0 は `完璧にぶっ壊"
"れている <https://en.wikipedia.org/wiki/POODLE>`_ ことが広く知られています。"
"それでもまだこの関数を使って、ただし SSL 3.0 接続を許可したいと望むならば、こ"
"れをこのように再有効化できます::"

#: ../../library/ssl.rst:178
msgid ""
"ctx = ssl.create_default_context(Purpose.CLIENT_AUTH)\n"
"ctx.options &= ~ssl.OP_NO_SSLv3"
msgstr ""

#: ../../library/ssl.rst:182
msgid ""
"This context enables :data:`VERIFY_X509_STRICT` by default, which may reject "
"pre-:rfc:`5280` or malformed certificates that the underlying OpenSSL "
"implementation otherwise would accept. While disabling this is not "
"recommended, you can do so using::"
msgstr ""

#: ../../library/ssl.rst:187
msgid ""
"ctx = ssl.create_default_context()\n"
"ctx.verify_flags &= ~ssl.VERIFY_X509_STRICT"
msgstr ""

#: ../../library/ssl.rst:194
msgid "RC4 was dropped from the default cipher string."
msgstr "デフォルトの暗号設定から RC4 が除かれました。"

#: ../../library/ssl.rst:198
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "デフォルトの暗号化文字列に ChaCha20/Poly1305 が追加されました。"

#: ../../library/ssl.rst:200
msgid "3DES was dropped from the default cipher string."
msgstr "デフォルトの暗号化文字列から 3DES が除かれました。"

#: ../../library/ssl.rst:204
msgid "Support for key logging to :envvar:`SSLKEYLOGFILE` was added."
msgstr ""

#: ../../library/ssl.rst:208
msgid ""
"The context now uses :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol instead of generic :data:`PROTOCOL_TLS`."
msgstr ""

#: ../../library/ssl.rst:214
msgid ""
"The context now uses :data:`VERIFY_X509_PARTIAL_CHAIN` and :data:"
"`VERIFY_X509_STRICT` in its default verify flags."
msgstr ""

#: ../../library/ssl.rst:219
msgid "Exceptions"
msgstr "例外"

#: ../../library/ssl.rst:223
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the higher-"
"level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`OSError`.  "
"The error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr ""
"(現在のところ OpenSSL ライブラリによって提供されている)下層の SSL 実装からの"
"エラーを伝えるための例外です。このエラーは、低レベルなネットワークの上に載っ"
"ている、高レベルな暗号化と認証レイヤーでの問題を通知します。このエラーは :"
"exc:`OSError` のサブタイプです。 :exc:`SSLError` インスタンスのエラーコードと"
"メッセージは OpenSSL ライブラリによるものです。"

#: ../../library/ssl.rst:230
msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError` は以前は :exc:`socket.error` のサブタイプでした。"

#: ../../library/ssl.rst:235
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"エラーが起こった OpenSSL サブモジュールを示すニーモニック文字列で、 ``SSL``, "
"``PEM``, ``X509`` などです。取り得る値は OpenSSL のバージョンに依存します。"

#: ../../library/ssl.rst:243
msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr ""
"エラーが起こった原因を示すニーモニック文字列で、 "
"``CERTIFICATE_VERIFY_FAILED`` などです。取り得る値は OpenSSL のバージョンに依"
"存します。"

#: ../../library/ssl.rst:251
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr ""
"読み出しあるいは書き込みを試みようとした際に SSL コネクションが行儀よく閉じら"
"れてしまった場合に送出される :exc:`SSLError` サブクラス例外です。これは下層の"
"転送(read TCP)が閉じたことは意味しないことに注意してください。"

#: ../../library/ssl.rst:259
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"received on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"読み出しあるいは書き込みを試みようとした際に、リクエストが遂行される前に下層"
"の TCP 転送で受け取る必要があるデータが不足した場合に :ref:`non-blocking SSL "
"socket <ssl-nonblocking>` によって送出される :exc:`SSLError` サブクラス例外で"
"す。"

#: ../../library/ssl.rst:268
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"sent on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"読み出しあるいは書き込みを試みようとした際に、リクエストが遂行される前に下層"
"の TCP 転送が送信する必要があるデータが不足した場合に :ref:`non-blocking SSL "
"socket <ssl-nonblocking>` によって送出される :exc:`SSLError` サブクラス例外で"
"す。"

#: ../../library/ssl.rst:277
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr ""
"SSL ソケット上で操作を遂行しようとしていてシステムエラーが起こった場合に送出"
"される :exc:`SSLError` サブクラス例外です。残念ながら元となった errno 番号を"
"調べる簡単な方法はありません。"

#: ../../library/ssl.rst:285
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr ""
"SSL コネクションが唐突に打ち切られた際に送出される :exc:`SSLError` サブクラス"
"例外です。一般的に、このエラーが起こったら下層の転送を再利用しようと試みるべ"
"きではありません。"

#: ../../library/ssl.rst:293
msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has failed."
msgstr ""

#: ../../library/ssl.rst:300
msgid "A numeric error number that denotes the verification error."
msgstr ""

#: ../../library/ssl.rst:304
msgid "A human readable string of the verification error."
msgstr ""

#: ../../library/ssl.rst:308
msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr ":exc:`SSLCertVerificationError` の別名です。"

#: ../../library/ssl.rst:310
msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr "例外は :exc:`SSLCertVerificationError` の別名になりました。"

#: ../../library/ssl.rst:315
msgid "Random generation"
msgstr "乱数生成"

#: ../../library/ssl.rst:319
msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an :class:"
"`SSLError` if the PRNG has not been seeded with enough data or if the "
"operation is not supported by the current RAND method. :func:`RAND_status` "
"can be used to check the status of the PRNG and :func:`RAND_add` can be used "
"to seed the PRNG."
msgstr ""
"暗号学的に強固な擬似乱数の *num* バイトを返します。擬似乱数生成器に十分なデー"
"タでシードが与えられていない場合や、現在の RANDOM メソッドに操作がサポートさ"
"れていない場合は :class:`SSLError` を送出します。 :func:`RAND_status` を使っ"
"て擬似乱数生成器の状態をチェックできます。\n"
":func:`RAND_add` を使って擬似乱数生成器にシードを与えることができます。"

#: ../../library/ssl.rst:325
msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr ""
"ほとんどすべてのアプリケーションでは :func:`os.urandom` が望ましいです。"

#: ../../library/ssl.rst:327
msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number "
"generator (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>`_, to get the "
"requirements of a cryptographically strong generator."
msgstr ""
"暗号論的に強い擬似乱数生成器に要求されることについては Wikipedia の記事 "
"`Cryptographically secure pseudorandom number generator (CSPRNG) <https://en."
"wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator>`_ "
"(日本語版: `暗号論的擬似乱数生成器 <http://ja.wikipedia.org/wiki/"
"%E6%9A%97%E5%8F%B7%E8%AB%96%E7%9A%84%E6%93%AC%E4%BC%BC%E4%B9%B1%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8>`_) "
"を参照してください。"

#: ../../library/ssl.rst:336
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use :func:`ssl."
"RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of the pseudo-"
"random number generator."
msgstr ""
"SSL 擬似乱数生成器が十分なランダム性(randomness)を受け取っている時に "
"``True`` を、それ以外の場合は `False` を返します。 :func:`ssl.RAND_egd` と :"
"func:`ssl.RAND_add` を使って擬似乱数生成機にランダム性を加えることができま"
"す。"

#: ../../library/ssl.rst:343
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use ``0.0``).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""

#: ../../library/ssl.rst:348
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr ""
"書き込み可能な :term:`bytes-like object` を使用できるようになりました。"

#: ../../library/ssl.rst:352
msgid "Certificate handling"
msgstr "証明書の取り扱い"

#: ../../library/ssl.rst:360
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"``cert_time`` として証明書内の \"notBefore\" や \"notAfter\" の ``\"%b %d %H:"
"%M:%S %Y %Z\"`` strptime フォーマット (C locale) 日付を渡すと、エポックからの"
"積算秒を返します。"

#: ../../library/ssl.rst:365
msgid "Here's an example:"
msgstr "例です。 :"

#: ../../library/ssl.rst:367
msgid ""
">>> import ssl\n"
">>> timestamp = ssl.cert_time_to_seconds(\"Jan  5 09:34:43 2018 GMT\")\n"
">>> timestamp  \n"
"1515144883\n"
">>> from datetime import datetime\n"
">>> print(datetime.utcfromtimestamp(timestamp))  \n"
"2018-01-05 09:34:43"
msgstr ""

#: ../../library/ssl.rst:377
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr ""
"\"notBefore\" や \"notAfter\" の日付には GMT を使わなければなりません(:rfc:"
"`5280`)。"

#: ../../library/ssl.rst:379
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr ""
"入力文字列に指定された 'GMT' タイムゾーンを UTC として解釈するようになりまし"
"た。以前はローカルタイムで解釈していました。また、整数を返すようになりました"
"(入力に含まれる秒の端数を含まない)。"

#: ../../library/ssl.rst:388
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If *ca_certs* is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the *cafile* parameter in :meth:`SSLContext."
"load_verify_locations`.  The call will attempt to validate the server "
"certificate against that set of root certificates, and will fail if the "
"validation attempt fails.  A timeout can be specified with the ``timeout`` "
"parameter."
msgstr ""

#: ../../library/ssl.rst:399
msgid "This function is now IPv6-compatible."
msgstr "この関数はIPv6互換になりました。"

#: ../../library/ssl.rst:402
msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to :data:"
"`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"*ssl_version* のデフォルトが、最近のサーバへの最大限の互換性のために :data:"
"`PROTOCOL_SSLv3` から :data:`PROTOCOL_TLS` に変更されました。"

#: ../../library/ssl.rst:406
msgid "The *timeout* parameter was added."
msgstr "*timeout* 引数が追加されました。"

#: ../../library/ssl.rst:411
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr ""
"DERエンコードされたバイト列として与えられた証明書から、 PEMエンコードされた"
"バージョンの同じ証明書を返します。"

#: ../../library/ssl.rst:416
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr ""
"PEM 形式のASCII文字列として与えられた証明書から、同じ証明書をDERエンコードし"
"たバイト列を返します。"

#: ../../library/ssl.rst:421
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The "
"paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"OpenSSL デフォルトの cafile, capath を指すパスを名前付きタプルで返します。パ"
"スは :meth:`SSLContext.set_default_verify_paths` で使われるものと同じです。戻"
"り値は :term:`named tuple` ``DefaultVerifyPaths`` です:"

#: ../../library/ssl.rst:426
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ""
":attr:`cafile` - cafile の解決済みパス、またはファイルが存在しない場合は "
"``None``"

#: ../../library/ssl.rst:427
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ""
":attr:`capath` - capath の解決済みパス、またはディレクトリが存在しない場合は "
"``None``"

#: ../../library/ssl.rst:428
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ":attr:`openssl_cafile_env` - cafile を指す OpenSSL の環境変数"

#: ../../library/ssl.rst:429
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - OpenSSL にハードコードされた cafile のパス"

#: ../../library/ssl.rst:430
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ":attr:`openssl_capath_env` - capath を指す OpenSSL の環境変数"

#: ../../library/ssl.rst:431
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - OpenSSL にハードコードされた capath のパス"

#: ../../library/ssl.rst:437
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr ""
"Windows のシステム証明書ストアより証明書を抽出します。 *store_name* は "
"``CA``, ``ROOT``, ``MY`` のうちどれか一つでしょう。Windows は追加の証明書スト"
"アを提供しているかもしれません。"

#: ../../library/ssl.rst:441
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 "
"data. Trust specifies the purpose of the certificate as a set of OIDS or "
"exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr ""
"この関数はタプル (cert_bytes, encoding_type, trust) のリストで返します。"
"encoding_type は cert_bytes のエンコーディングを表します。X.509 ASN.1 に対す"
"る :const:`x509_asn` か PKCS#7 ASN.1 データに対する :const:`pkcs_7_asn` のい"
"ずれかです。trust は、証明書の目的を、OIDS を内容に持つ set として表すか、ま"
"たは証明書がすべての目的で信頼できるならば ``True`` です。"

#: ../../library/ssl.rst:448 ../../library/ssl.rst:1599
#: ../../library/ssl.rst:1898
msgid "Example::"
msgstr "以下はプログラム例です::"

#: ../../library/ssl.rst:450
msgid ""
">>> ssl.enum_certificates(\"CA\")\n"
"[(b'data...', 'x509_asn', {'1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2'}),\n"
" (b'data...', 'x509_asn', True)]"
msgstr ""

#: ../../library/ssl.rst:454 ../../library/ssl.rst:469
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`利用可能な環境 <availability>`: Windows 。"

#: ../../library/ssl.rst:460
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr ""
"Windows のシステム証明書ストアより CRLs を抽出します。 *store_name* は "
"``CA``, ``ROOT``, ``MY`` のうちどれか一つでしょう。Windows は追加の証明書スト"
"アを提供しているかもしれません。"

#: ../../library/ssl.rst:464
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 data."
msgstr ""
"この関数はタプル (cert_bytes, encoding_type, trust) のリストで返します。"
"encoding_type は cert_bytes のエンコーディングを表します。X.509 ASN.1 に対す"
"る :const:`x509_asn` か PKCS#7 ASN.1 データに対する :const:`pkcs_7_asn` のい"
"ずれかです。"

#: ../../library/ssl.rst:475
msgid "Constants"
msgstr "定数"

#: ../../library/ssl.rst:477
msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr ""
"すべての定数が :class:`enum.IntEnum` コレクションまたは :class:`enum."
"IntFlag` コレクションになりました。"

#: ../../library/ssl.rst:483
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. Except for :const:"
"`PROTOCOL_TLS_CLIENT`, it is the default mode.  With client-side sockets, "
"just about any cert is accepted.  Validation errors, such as untrusted or "
"expired cert, are ignored and do not abort the TLS/SSL handshake."
msgstr ""

#: ../../library/ssl.rst:489
msgid ""
"In server mode, no certificate is requested from the client, so the client "
"does not send any for client cert authentication."
msgstr ""

#: ../../library/ssl.rst:492 ../../library/ssl.rst:2400
msgid "See the discussion of :ref:`ssl-security` below."
msgstr ""
"このドキュメントの下の方の、 :ref:`ssl-security` に関する議論を参照してくださ"
"い。"

#: ../../library/ssl.rst:496
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. In client mode, :const:"
"`CERT_OPTIONAL` has the same meaning as :const:`CERT_REQUIRED`. It is "
"recommended to use :const:`CERT_REQUIRED` for client-side sockets instead."
msgstr ""

#: ../../library/ssl.rst:501
msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order perform "
"TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts the "
"TLS handshake."
msgstr ""

#: ../../library/ssl.rst:507 ../../library/ssl.rst:526
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed to :"
"meth:`SSLContext.load_verify_locations`."
msgstr ""

#: ../../library/ssl.rst:512
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. In this mode, "
"certificates are required from the other side of the socket connection; an :"
"class:`SSLError` will be raised if no certificate is provided, or if its "
"validation fails. This mode is **not** sufficient to verify a certificate in "
"client mode as it does not match hostnames.  :attr:`~SSLContext."
"check_hostname` must be enabled as well to verify the authenticity of a "
"cert. :const:`PROTOCOL_TLS_CLIENT` uses :const:`CERT_REQUIRED` and enables :"
"attr:`~SSLContext.check_hostname` by default."
msgstr ""

#: ../../library/ssl.rst:522
msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and the "
"client must provide a valid and trusted certificate."
msgstr ""

#: ../../library/ssl.rst:531
msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr "CERT_* 定数の :class:`enum.IntEnum` コレクションです。"

#: ../../library/ssl.rst:537
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does "
"neither require nor verify CRLs."
msgstr ""
":attr:`SSLContext.verify_flags` に渡せる値です。このモードでは、証明書失効リ"
"スト(CRLs)はチェックされません。デフォルトでは OpenSSL は CRLs を必要ともしま"
"せんし検証にも使いません。"

#: ../../library/ssl.rst:545
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is checked but none of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper CRL has been loaded with :attr:`SSLContext."
"load_verify_locations`, validation will fail."
msgstr ""
":attr:`SSLContext.verify_flags` に渡せる値です。このモードでは、接続先の証明"
"書のみがチェックされ、仲介の CA 証明書はチェックされません。接続先証明書の発"
"行者(その CA の直接の祖先)によって署名された妥当な CRL が必要です。 :attr:"
"`SSLContext.load_verify_locations` で相応しい CRL をロードしていなければ、検"
"証は失敗します。"

#: ../../library/ssl.rst:555
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ""
":attr:`SSLContext.verify_flags` に渡せる値です。このモードでは、接続先の証明"
"書チェイン内のすべての証明書についての CRLs がチェックされます。"

#: ../../library/ssl.rst:562
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ""
":attr:`SSLContext.verify_flags` に渡せる値で、壊れた X.509 証明書に対するワー"
"クアラウンドを無効にします。"

#: ../../library/ssl.rst:569
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to enables proxy "
"certificate verification."
msgstr ""

#: ../../library/ssl.rst:576
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ""
":attr:`SSLContext.verify_flags` に渡せる値です。OpenSSL に対し、証明書検証の"
"ために信頼チェインを構築する際、信頼できる証明書を選ぶように指示します。これ"
"はデフォルトで有効にされています。"

#: ../../library/ssl.rst:584
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"accept intermediate CAs in the trust store to be treated as trust-anchors, "
"in the same way as the self-signed root CA certificates. This makes it "
"possible to trust certificates issued by an intermediate CA without having "
"to trust its ancestor root CA."
msgstr ""

#: ../../library/ssl.rst:595
msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr "VERIFY_* 定数の :class:`enum.IntFlag` コレクションです。"

#: ../../library/ssl.rst:601
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and \"TLS\" "
"protocols."
msgstr ""
"クライアントとサーバの両方がサポートするプロトコルバージョンのうち、最も大き"
"なものを選択します。名前に反して、このオプションは \"SSL\" と \"TLS\" プロト"
"コルのいずれも選択できます。"

#: ../../library/ssl.rst:608
msgid ""
"TLS clients and servers require different default settings for secure "
"communication. The generic TLS protocol constant is deprecated in favor of :"
"data:`PROTOCOL_TLS_CLIENT` and :data:`PROTOCOL_TLS_SERVER`."
msgstr ""

#: ../../library/ssl.rst:614
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context client-side connections. The protocol "
"enables :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""

#: ../../library/ssl.rst:623
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context server-side connections."
msgstr ""

#: ../../library/ssl.rst:630
msgid "Alias for :data:`PROTOCOL_TLS`."
msgstr ":data:`PROTOCOL_TLS` のエイリアスです。"

#: ../../library/ssl.rst:634
msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "代わりに :data:`PROTOCOL_TLS` を使用してください。"

#: ../../library/ssl.rst:638
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "チャンネル暗号化プロトコルとしてSSLバージョン3を選択します。"

#: ../../library/ssl.rst:640
msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl3`` "
"option."
msgstr ""
"このプロトコルは、 OpenSSL が ``no-ssl3`` オプションをつけてコンパイルされて"
"いる場合には利用できません。"

#: ../../library/ssl.rst:645
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "SSL version 3 は非セキュアです。このプロトコルは強く非推奨です。"

#: ../../library/ssl.rst:649
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS_SERVER` or :data:`PROTOCOL_TLS_CLIENT` with :"
"attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version` "
"instead."
msgstr ""

#: ../../library/ssl.rst:657
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "チャンネル暗号化プロトコルとしてTLSバージョン1.0を選択します。"

#: ../../library/ssl.rst:661 ../../library/ssl.rst:672
#: ../../library/ssl.rst:683
msgid "OpenSSL has deprecated all version specific protocols."
msgstr ""

#: ../../library/ssl.rst:665
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"チャンネル暗号化プロトコルとしてTLSバージョン1.1を選択します。 openssl "
"version 1.0.1+ のみで利用可能です。"

#: ../../library/ssl.rst:676
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"チャンネル暗号化プロトコルとしてTLSバージョン 1.2 を選択します。 openssl "
"version 1.0.1+ のみで利用可能です。"

#: ../../library/ssl.rst:687
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"相手にする SSL 実装のさまざまなバグを回避するためのワークアラウンドを有効にし"
"ます。このオプションはデフォルトで有効です。これを有効にする場合 OpenSSL 用の"
"同じ意味のフラグ ``SSL_OP_ALL`` をセットする必要はありません。"

#: ../../library/ssl.rst:695
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr ""
"SSLv2 接続が行われないようにします。このオプションは :const:`PROTOCOL_TLS` と"
"組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして "
"SSLv2 を選択しないようにします。"

#: ../../library/ssl.rst:703
msgid "SSLv2 is deprecated"
msgstr "SSLv2 は非推奨です"

#: ../../library/ssl.rst:707
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr ""
"SSLv3 接続が行われないようにします。このオプションは :const:`PROTOCOL_TLS` と"
"組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして "
"SSLv3 を選択しないようにします。"

#: ../../library/ssl.rst:715
msgid "SSLv3 is deprecated"
msgstr "SSLv3 は非推奨です"

#: ../../library/ssl.rst:719
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr ""
"TLSv1 接続が行われないようにします。このオプションは :const:`PROTOCOL_TLS` と"
"組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして "
"TLSv1 を選択しないようにします。"

#: ../../library/ssl.rst:725
msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new :attr:`SSLContext."
"minimum_version` and :attr:`SSLContext.maximum_version` instead."
msgstr ""

#: ../../library/ssl.rst:732
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"TLSv1.1 接続が行われないようにします。このオプションは :const:`PROTOCOL_TLS` "
"と組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして "
"TLSv1.1 を選択しないようにします。openssl バージョン 1.0.1 以降でのみ利用でき"
"ます。"

#: ../../library/ssl.rst:738 ../../library/ssl.rst:749
msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr ""

#: ../../library/ssl.rst:743
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"TLSv1.2 接続が行われないようにします。このオプションは :const:`PROTOCOL_TLS` "
"と組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして "
"TLSv1.2 を選択しないようにします。openssl バージョン 1.0.1 以降でのみ利用でき"
"ます。"

#: ../../library/ssl.rst:754
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When "
"Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""

#: ../../library/ssl.rst:762
msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15 and "
"3.6.3 for backwards compatibility with OpenSSL 1.0.2."
msgstr ""

#: ../../library/ssl.rst:768
msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest "
"messages, and ignore renegotiation requests via ClientHello."
msgstr ""

#: ../../library/ssl.rst:771
msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr "このオプションは OpenSSL 1.1.0h 以降のみで使用できます。"

#: ../../library/ssl.rst:777
msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr ""
"暗号の優先順位として、クライアントのものではなくサーバのものを使います。この"
"オプションはクライアントソケットと SSLv2 のサーバソケットでは効果はありませ"
"ん。"

#: ../../library/ssl.rst:784
msgid ""
"Prevents reuse of the same DH key for distinct SSL sessions.  This improves "
"forward secrecy but requires more computational resources. This option only "
"applies to server sockets."
msgstr ""

#: ../../library/ssl.rst:792
msgid ""
"Prevents reuse of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr ""

#: ../../library/ssl.rst:800
msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a "
"TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr ""

#: ../../library/ssl.rst:803
msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr "このオプションは OpenSSL 1.1.1 以降のみで使用できます。"

#: ../../library/ssl.rst:809
msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr ""
"SSL チャネルでの圧縮を無効にします。これはアプリケーションのプロトコルが自身"
"の圧縮方法をサポートする場合に有用です。"

#: ../../library/ssl.rst:816
msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr "OP_* 定数の :class:`enum.IntFlag` コレクションです。"

#: ../../library/ssl.rst:820
msgid "Prevent client side from requesting a session ticket."
msgstr "クライアントサイドがセッションチケットをリクエストしないようにします。"

#: ../../library/ssl.rst:826
msgid "Ignore unexpected shutdown of TLS connections."
msgstr ""

#: ../../library/ssl.rst:828 ../../library/ssl.rst:844
msgid "This option is only available with OpenSSL 3.0.0 and later."
msgstr "このオプションは OpenSSL 3.0.0以降のみで使用できます。"

#: ../../library/ssl.rst:834
msgid ""
"Enable the use of the kernel TLS. To benefit from the feature, OpenSSL must "
"have been compiled with support for it, and the negotiated cipher suites and "
"extensions must be supported by it (a list of supported ones may vary by "
"platform and kernel version)."
msgstr ""

#: ../../library/ssl.rst:839
msgid ""
"Note that with enabled kernel TLS some cryptographic operations are "
"performed by the kernel directly and not via any available OpenSSL "
"Providers. This might be undesirable if, for example, the application "
"requires all cryptographic operations to be performed by the FIPS provider."
msgstr ""

#: ../../library/ssl.rst:850
msgid ""
"Allow legacy insecure renegotiation between OpenSSL and unpatched servers "
"only."
msgstr ""

#: ../../library/ssl.rst:857
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr ""
"OpenSSL ライブラリが、組み込みで :rfc:`7301` で記述されている *Application-"
"Layer Protocol Negotiation* TLS 拡張をサポートしているかどうか。"

#: ../../library/ssl.rst:864
msgid ""
"Whether the OpenSSL library has built-in support not checking subject common "
"name and :attr:`SSLContext.hostname_checks_common_name` is writeable."
msgstr ""

#: ../../library/ssl.rst:872
msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the feature "
"was explicitly disabled by the distributor."
msgstr ""
"OpenSSL ライブラリが、組み込みの楕円曲線ディフィー・ヘルマン鍵共有をサポート"
"しているかどうか。これは、ディストリビュータが明示的に無効にしていない限り"
"は、真であるはずです。"

#: ../../library/ssl.rst:880
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr ""
"OpenSSL ライブラリが、組み込みで (:rfc:`6066` で記述されている) *Server Name "
"Indication* 拡張をサポートしているかどうか。"

#: ../../library/ssl.rst:887
msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"When true, you can use the :meth:`SSLContext.set_npn_protocols` method to "
"advertise which protocols you want to support."
msgstr ""
"OpenSSL ライブラリが、組み込みで、`Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_ で記"
"述されている *Next Protocol Negotiation* をサポートしているかどうか。 true で"
"あれば、サポートしたいプロトコルを :meth:`SSLContext.set_npn_protocols` メ"
"ソッドで提示することができます。"

#: ../../library/ssl.rst:897
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr ""
"OpenSSL ライブラリが、組み込みで SSL 2.0 プロトコルをサポートしているかどう"
"か。"

#: ../../library/ssl.rst:903
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr ""
"OpenSSL ライブラリが、組み込みで SSL 3.0 プロトコルをサポートしているかどう"
"か。"

#: ../../library/ssl.rst:909
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr ""
"OpenSSL ライブラリが、組み込みで TLS 1.0 プロトコルをサポートしているかどう"
"か。"

#: ../../library/ssl.rst:915
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr ""
"OpenSSL ライブラリが、組み込みで TLS 1.1 プロトコルをサポートしているかどう"
"か。"

#: ../../library/ssl.rst:921
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr ""
"OpenSSL ライブラリが、組み込みで TLS 1.2 プロトコルをサポートしているかどう"
"か。"

#: ../../library/ssl.rst:927
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr ""
"OpenSSL ライブラリが、組み込みで TLS 1.3 プロトコルをサポートしているかどう"
"か。"

#: ../../library/ssl.rst:933
msgid "Whether the OpenSSL library has built-in support for TLS-PSK."
msgstr ""

#: ../../library/ssl.rst:939
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr ""
"サポートされている TLS のチャネルバインディングのタイプのリスト。リスト内の文"
"字列は :meth:`SSLSocket.get_channel_binding` の引数に渡せます。"

#: ../../library/ssl.rst:946
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr ""
"インタプリタによってロードされた OpenSSL ライブラリのバージョン文字列::"

#: ../../library/ssl.rst:948
msgid ""
">>> ssl.OPENSSL_VERSION\n"
"'OpenSSL 1.0.2k  26 Jan 2017'"
msgstr ""

#: ../../library/ssl.rst:955
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr "OpenSSL ライブラリのバージョン情報を表す5つの整数のタプル::"

#: ../../library/ssl.rst:958
msgid ""
">>> ssl.OPENSSL_VERSION_INFO\n"
"(1, 0, 2, 11, 15)"
msgstr ""

#: ../../library/ssl.rst:965
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr "1つの整数の形式の、 OpenSSL ライブラリの生のバージョン番号::"

#: ../../library/ssl.rst:967
msgid ""
">>> ssl.OPENSSL_VERSION_NUMBER\n"
"268443839\n"
">>> hex(ssl.OPENSSL_VERSION_NUMBER)\n"
"'0x100020bf'"
msgstr ""

#: ../../library/ssl.rst:978
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ""
":rfc:`5246` その他からのアラートの種類です。 `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ にはこのリストとその意味が定義された RFC へのリファレンスが含"
"まれています。"

#: ../../library/ssl.rst:982
msgid ""
"Used as the return value of the callback function in :meth:`SSLContext."
"set_servername_callback`."
msgstr ""
":meth:`SSLContext.set_servername_callback` でのコールバック関数の戻り値として"
"使われます。"

#: ../../library/ssl.rst:989
msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr "ALERT_DESCRIPTION_* 定数の :class:`enum.IntEnum` コレクションです。"

#: ../../library/ssl.rst:995
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web servers (therefore, it will be used to create client-side "
"sockets)."
msgstr ""
":func:`create_default_context` と :meth:`SSLContext.load_default_certs` に渡"
"すオプションです。この値はコンテキストが web サーバの認証に使われることを示し"
"ます (ですので、クライアントサイドのソケットを作るのに使うことになるでしょ"
"う)。"

#: ../../library/ssl.rst:1004
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web clients (therefore, it will be used to create server-side "
"sockets)."
msgstr ""
":func:`create_default_context` と :meth:`SSLContext.load_default_certs` に渡"
"すオプションです。この値はコンテキストが web クライアントの認証に使われること"
"を示します (ですので、サーバサイドのソケットを作るのに使うことになるでしょ"
"う)。"

#: ../../library/ssl.rst:1013
msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr "SSL_ERROR_* 定数の :class:`enum.IntEnum` コレクションです。"

#: ../../library/ssl.rst:1019
msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for :attr:"
"`SSLContext.maximum_version` and :attr:`SSLContext.minimum_version`."
msgstr ""

#: ../../library/ssl.rst:1027
msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available TLS/"
"SSL versions."
msgstr ""

#: ../../library/ssl.rst:1037
msgid "SSL 3.0 to TLS 1.3."
msgstr ""

#: ../../library/ssl.rst:1041
msgid ""
"All :class:`TLSVersion` members except :attr:`TLSVersion.TLSv1_2` and :attr:"
"`TLSVersion.TLSv1_3` are deprecated."
msgstr ""

#: ../../library/ssl.rst:1046
msgid "SSL Sockets"
msgstr "SSL ソケット"

#: ../../library/ssl.rst:1050
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr "SSL ソケットは :ref:`socket-objects` の以下のメソッドを提供します:"

#: ../../library/ssl.rst:1052
msgid ":meth:`~socket.socket.accept`"
msgstr ""

#: ../../library/ssl.rst:1053
msgid ":meth:`~socket.socket.bind`"
msgstr ""

#: ../../library/ssl.rst:1054
msgid ":meth:`~socket.socket.close`"
msgstr ""

#: ../../library/ssl.rst:1055
msgid ":meth:`~socket.socket.connect`"
msgstr ""

#: ../../library/ssl.rst:1056
msgid ":meth:`~socket.socket.detach`"
msgstr ""

#: ../../library/ssl.rst:1057
msgid ":meth:`~socket.socket.fileno`"
msgstr ""

#: ../../library/ssl.rst:1058
msgid ":meth:`~socket.socket.getpeername`, :meth:`~socket.socket.getsockname`"
msgstr ""

#: ../../library/ssl.rst:1059
msgid ":meth:`~socket.socket.getsockopt`, :meth:`~socket.socket.setsockopt`"
msgstr ""

#: ../../library/ssl.rst:1060
msgid ""
":meth:`~socket.socket.gettimeout`, :meth:`~socket.socket.settimeout`, :meth:"
"`~socket.socket.setblocking`"
msgstr ""

#: ../../library/ssl.rst:1062
msgid ":meth:`~socket.socket.listen`"
msgstr ""

#: ../../library/ssl.rst:1063
msgid ":meth:`~socket.socket.makefile`"
msgstr ""

#: ../../library/ssl.rst:1064
msgid ""
":meth:`~socket.socket.recv`, :meth:`~socket.socket.recv_into` (but passing a "
"non-zero ``flags`` argument is not allowed)"
msgstr ""

#: ../../library/ssl.rst:1066
msgid ""
":meth:`~socket.socket.send`, :meth:`~socket.socket.sendall` (with the same "
"limitation)"
msgstr ""

#: ../../library/ssl.rst:1068
msgid ""
":meth:`~socket.socket.sendfile` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send` will be used)"
msgstr ""

#: ../../library/ssl.rst:1070
msgid ":meth:`~socket.socket.shutdown`"
msgstr ""

#: ../../library/ssl.rst:1072
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""
"SSL(およびTLS)プロトコルは TCP の上に独自の枠組みを持っているので、SSLソケッ"
"トの抽象化は、いくつかの点で通常の OSレベルのソケットの仕様から逸脱することが"
"あります。特に :ref:`ノンブロッキングソケットについての注釈 <ssl-"
"nonblocking>` を参照してください。"

#: ../../library/ssl.rst:1077
msgid ""
"Instances of :class:`SSLSocket` must be created using the :meth:`SSLContext."
"wrap_socket` method."
msgstr ""
":class:`SSLSocket` のインスタンスは :meth:`SSLContext.wrap_socket` メソッドを"
"使用して作成されなければなりません。"

#: ../../library/ssl.rst:1080
msgid "The :meth:`sendfile` method was added."
msgstr ":meth:`sendfile` メソッドが追加されました。"

#: ../../library/ssl.rst:1083
msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes are "
"received or sent. The socket timeout is now the maximum total duration of "
"the shutdown."
msgstr ""
":meth:`shutdown` は、バイトが送受信されるたびにソケットのタイムアウトをリセッ"
"トしません。ソケットのタイムアウトは、シャットダウンの最大合計時間になりまし"
"た。"

#: ../../library/ssl.rst:1088
msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use :meth:"
"`SSLContext.wrap_socket` to wrap a socket."
msgstr ""
":class:`SSLSocket` インスタンスを直接作成することは非推奨です。ソケットをラッ"
"プするために :meth:`SSLContext.wrap_socket` を使用してください。"

#: ../../library/ssl.rst:1092
msgid ""
":class:`SSLSocket` instances must to created with :meth:`~SSLContext."
"wrap_socket`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""

#: ../../library/ssl.rst:1098
msgid ""
"Python now uses ``SSL_read_ex`` and ``SSL_write_ex`` internally. The "
"functions support reading and writing of data larger than 2 GB. Writing zero-"
"length data no longer fails with a protocol violation error."
msgstr ""

#: ../../library/ssl.rst:1103
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr "SSL ソケットには、以下に示す追加のメソッドと属性もあります:"

#: ../../library/ssl.rst:1107
msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result as "
"a ``bytes`` instance. If *buffer* is specified, then read into the buffer "
"instead, and return the number of bytes read."
msgstr ""
"SSL ソケットからデータの *len* バイトまでを読み出し、読み出した結果を "
"``bytes`` インスタンスで返します。 *buffer* を指定すると、結果は代わりに "
"buffer に読み込まれ、読み込んだバイト数を返します。"

#: ../../library/ssl.rst:1111
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""
"ソケットが :ref:`non-blocking <ssl-nonblocking>` で読み出しがブロックする"
"と、 :exc:`SSLWantReadError` もしくは :exc:`SSLWantWriteError` が送出されま"
"す。"

#: ../../library/ssl.rst:1114
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can also "
"cause write operations."
msgstr ""
"再ネゴシエーションがいつでも可能なので、 :meth:`read`  の呼び出しは書き込み操"
"作も引き起こしえます。"

#: ../../library/ssl.rst:1117
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to read up to *len* "
"bytes."
msgstr ""
"ソケットのタイムアウトは、バイトが送受信されるたびにリセットされなくなりまし"
"た。ソケットのタイムアウトは、最大 *len* バイトを読むのにかかる最大合計時間に"
"なりました。"

#: ../../library/ssl.rst:1122
msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr ""
":meth:`~SSLSocket.read` の代わりに :meth:`~SSLSocket.recv` を使用してくださ"
"い。"

#: ../../library/ssl.rst:1127
msgid ""
"Write *buf* to the SSL socket and return the number of bytes written. The "
"*buf* argument must be an object supporting the buffer interface."
msgstr ""
"*buf* を SSL ソケットに書き込み、書き込んだバイト数を返します。 *buf* 引数は"
"バッファインターフェイスをサポートするオブジェクトでなければなりません。"

#: ../../library/ssl.rst:1130
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""
"ソケットが :ref:`non-blocking <ssl-nonblocking>` で書き込みがブロックする"
"と、 :exc:`SSLWantReadError` もしくは :exc:`SSLWantWriteError` が送出されま"
"す。"

#: ../../library/ssl.rst:1133
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr ""
"再ネゴシエーションがいつでも可能なので、 :meth:`write`  の呼び出しは読み出し"
"操作も引き起こしえます。"

#: ../../library/ssl.rst:1136
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to write *buf*."
msgstr ""
"ソケットのタイムアウトは、バイトが送受信されるたびにリセットされなくなりまし"
"た。ソケットのタイムアウトは、*buf* を書き込むのにかかる最大合計時間になりま"
"した。"

#: ../../library/ssl.rst:1140
msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr ""
":meth:`~SSLSocket.write` の代わりに :meth:`~SSLSocket.send` を使用してくださ"
"い。"

#: ../../library/ssl.rst:1145
msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the low-"
"level methods that read and write unencrypted, application-level data and "
"decrypt/encrypt it to encrypted, wire-level data. These methods require an "
"active SSL connection, i.e. the handshake was completed and :meth:`SSLSocket."
"unwrap` was not called."
msgstr ""
":meth:`~SSLSocket.read`, :meth:`~SSLSocket.write` メソッドは下位レベルのメ"
"ソッドであり、暗号化されていないアプリケーションレベルのデータを読み書きし、"
"それを復号/暗号化して暗号化された書き込みレベルのデータにします。これらのメ"
"ソッドはアクティブな SSL 接続つまり、ハンドシェイクが完了していて、 :meth:"
"`SSLSocket.unwrap` が呼ばれていないことを必要とします。"

#: ../../library/ssl.rst:1151
msgid ""
"Normally you should use the socket API methods like :meth:`~socket.socket."
"recv` and :meth:`~socket.socket.send` instead of these methods."
msgstr ""
"通常はこれらのメソッドの代わりに :meth:`~socket.socket.recv` や :meth:"
"`~socket.socket.send` のようなソケット API メソッドを使うべきです。"

#: ../../library/ssl.rst:1157
msgid "Perform the SSL setup handshake."
msgstr "SSL セットアップのハンドシェイクを実行します。"

#: ../../library/ssl.rst:1159
msgid ""
"The handshake method also performs :func:`match_hostname` when the :attr:"
"`~SSLContext.check_hostname` attribute of the socket's :attr:`~SSLSocket."
"context` is true."
msgstr ""
"ソケットの :attr:`~SSLSocket.context` の属性 :attr:`~SSLContext."
"check_hostname` が真の場合に、ハンドシェイクメソッドが :func:"
"`match_hostname` を実行するようになりました。"

#: ../../library/ssl.rst:1164
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration of the handshake."
msgstr ""
"ソケットのタイムアウトは、バイトが送受信されるたびにリセットされなくなりまし"
"た。ソケットのタイムアウトは、ハンドシェイクにかかる最大合計時間になりまし"
"た。"

#: ../../library/ssl.rst:1168
msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The function :"
"func:`match_hostname` is no longer used. In case OpenSSL refuses a hostname "
"or IP address, the handshake is aborted early and a TLS alert message is "
"sent to the peer."
msgstr ""

#: ../../library/ssl.rst:1176
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise :exc:"
"`ValueError`."
msgstr ""
"接続先に証明書が無い場合、 ``None`` を返します。SSL ハンドシェイクがまだ行わ"
"れていない場合は、 :exc:`ValueError` が送出されます。"

#: ../../library/ssl.rst:1180
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject`` "
"(the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""
"``binary_form`` が :const:`False` で接続先から証明書を取得した場合、このメ"
"ソッドは :class:`dict` のインスタンスを返します。証明書が認証されていない場"
"合、辞書は空です。証明書が認証されていた場合いくつかのキーを持った辞書を返"
"し、 ``subject`` (証明書が発行された principal), ``issuer`` (証明書を発行し"
"た principal) を含みます。証明書が *Subject Alternative Name* 拡張(:rfc:"
"`3280` を参照)のインスタンスを格納していた場合、 ``subjectAltName`` キーも辞"
"書に含まれます。"

#: ../../library/ssl.rst:1189
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""
"``subject``, ``issuer`` フィールドは、証明書のそれぞれのフィールドについての"
"データ構造で与えられる RDN (relative distinguishued name) のシーケンスを格納"
"したタプルで、各 RDN は name-value ペアのシーケンスです。現実世界での例をお見"
"せします::"

#: ../../library/ssl.rst:1194
msgid ""
"{'issuer': ((('countryName', 'IL'),),\n"
"            (('organizationName', 'StartCom Ltd.'),),\n"
"            (('organizationalUnitName',\n"
"              'Secure Digital Certificate Signing'),),\n"
"            (('commonName',\n"
"              'StartCom Class 2 Primary Intermediate Server CA'),)),\n"
" 'notAfter': 'Nov 22 08:15:19 2013 GMT',\n"
" 'notBefore': 'Nov 21 03:09:52 2011 GMT',\n"
" 'serialNumber': '95F0',\n"
" 'subject': ((('description', '571208-SLe257oHY9fVQ07Z'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'California'),),\n"
"             (('localityName', 'San Francisco'),),\n"
"             (('organizationName', 'Electronic Frontier Foundation, "
"Inc.'),),\n"
"             (('commonName', '*.eff.org'),),\n"
"             (('emailAddress', 'hostmaster@eff.org'),)),\n"
" 'subjectAltName': (('DNS', '*.eff.org'), ('DNS', 'eff.org')),\n"
" 'version': 3}"
msgstr ""

#: ../../library/ssl.rst:1213
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate "
"as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr ""
"``binary_form`` 引数が :const:`True` だった場合、証明書が渡されていればこのメ"
"ソッドはDERエンコードされた証明書全体をバイト列として返し、接続先が証明書を提"
"示しなかった場合は :const:`None` を返します。接続先が証明書を提供するかどうか"
"は SSL ソケットの役割に依存します:"

#: ../../library/ssl.rst:1219
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr ""
"クライアント SSL ソケットでは、認証が要求されているかどうかに関わらず、サーバ"
"は常に証明書を提供します。"

#: ../../library/ssl.rst:1222
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return :const:"
"`None` if you used :const:`CERT_NONE` (rather than :const:`CERT_OPTIONAL` "
"or :const:`CERT_REQUIRED`)."
msgstr ""
"サーバ SSL ソケットでは、クライアントはサーバによって認証が要求されている場合"
"にのみ証明書を提供します。したがって、 (:const:`CERT_OPTIONAL` や :const:"
"`CERT_REQUIRED` ではなく) :const:`CERT_NONE` を使用した場合 :meth:"
"`getpeercert` は :const:`None` を返します。"

#: ../../library/ssl.rst:1227
msgid "See also :attr:`SSLContext.check_hostname`."
msgstr ""

#: ../../library/ssl.rst:1229
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr ""
"返される辞書に ``issuer``, ``notBefore`` のような追加アイテムを含むようになり"
"ました。"

#: ../../library/ssl.rst:1233
msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""
"ハンドシェイクが済んでいなければ :exc:`ValueError` を投げるようになりました。"
"返される辞書に ``crlDistributionPoints``, ``caIssuers``, ``OCSP`` URI のよう"
"な X509v3 拡張アイテムを含むようになりました。"

#: ../../library/ssl.rst:1238
msgid "IPv6 address strings no longer have a trailing new line."
msgstr ""

#: ../../library/ssl.rst:1243
msgid ""
"Returns verified certificate chain provided by the other end of the SSL "
"channel as a list of DER-encoded bytes. If certificate verification was "
"disabled method acts the same as :meth:`~SSLSocket.get_unverified_chain`."
msgstr ""

#: ../../library/ssl.rst:1252
msgid ""
"Returns raw certificate chain provided by the other end of the SSL channel "
"as a list of DER-encoded bytes."
msgstr ""

#: ../../library/ssl.rst:1259
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""
"利用されている暗号の名前、その暗号の利用を定義しているSSLプロトコルのバージョ"
"ン、利用されている鍵のbit長の3つの値を含むタプルを返します。もし接続が確立さ"
"れていない場合、 ``None`` を返します。"

#: ../../library/ssl.rst:1265
msgid ""
"Return the list of ciphers available in both the client and server.  Each "
"entry of the returned list is a three-value tuple containing the name of the "
"cipher, the version of the SSL protocol that defines its use, and the number "
"of secret bits the cipher uses.  :meth:`~SSLSocket.shared_ciphers` returns "
"``None`` if no connection has been established or the socket is a client "
"socket."
msgstr ""
"クライアントとサーバーの両方で利用できる暗号方式のリストを返します。返される"
"リストの各要素は 3つの値を含むタプルで、その値はそれぞれ、暗号方式の名前、そ"
"の暗号の利用を定義している SSL プロトコルのバージョン、暗号で使用される秘密鍵"
"のビット長です。接続が確立されていないか、ソケットがクライアントソケットであ"
"る場合、:meth:`~SSLSocket.shared_ciphers` は ``None`` を返します。"

#: ../../library/ssl.rst:1276
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr ""
"使われている圧縮アルゴリズムを文字列で返します。接続が圧縮されていなければ "
"``None`` を返します。"

#: ../../library/ssl.rst:1279
msgid ""
"If the higher-level protocol supports its own compression mechanism, you can "
"use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr ""
"上位レベルのプロトコルが自身で圧縮メカニズムをサポートする場合、SSL レベルで"
"の圧縮を :data:`OP_NO_COMPRESSION` を使って無効にできます。"

#: ../../library/ssl.rst:1286
msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns "
"``None`` if not connected or the handshake has not been completed."
msgstr ""
"現在の接続におけるチャネルバインディングのデータを取得します。未接続あるいは"
"ハンドシェイクが完了していなければ ``None`` を返します。"

#: ../../library/ssl.rst:1289
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type. "
"Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES` "
"list.  Currently only the 'tls-unique' channel binding, defined by :rfc:"
"`5929`, is supported.  :exc:`ValueError` will be raised if an unsupported "
"channel binding type is requested."
msgstr ""
"*cb_type* パラメータにより、望みのチャネルバインディングのタイプを選択できま"
"す。チャネルバインディングのタイプの妥当なものは :data:"
"`CHANNEL_BINDING_TYPES` でリストされています。現在のところは :rfc:`5929` で定"
"義されている 'tls-unique' のみがサポートされています。未サポートのチャネルバ"
"インディングのタイプが要求された場合、 :exc:`ValueError` を送出します。"

#: ../../library/ssl.rst:1299
msgid ""
"Return the protocol that was selected during the TLS handshake.  If :meth:"
"`SSLContext.set_alpn_protocols` was not called, if the other party does not "
"support ALPN, if this socket does not support any of the client's proposed "
"protocols, or if the handshake has not happened yet, ``None`` is returned."
msgstr ""
"TLS ハンドシェイクで選択されたプロトコルを返します。 :meth:`SSLContext."
"set_alpn_protocols` が呼ばれていない場合、相手側が ALPN をサポートしていない"
"場合、クライアントが提案したプロトコルのどれもソケットがサポートしない場合、"
"あるいはハンドシェイクがまだ行われていない場合には、 ``None`` が返されます。"

#: ../../library/ssl.rst:1309
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the "
"other party does not support NPN, or if the handshake has not yet happened, "
"this will return ``None``."
msgstr ""
"TLS/SSL ハンドシェイクで選択された上位レベルのプロトコルを返します。 :meth:"
"`SSLContext.set_npn_protocols` が呼ばれていない場合、相手側が NPN をサポート"
"していない場合、あるいはハンドシェイクがまだ行われていない場合には、 "
"``None`` が返されます。"

#: ../../library/ssl.rst:1318 ../../library/ssl.rst:1687
msgid "NPN has been superseded by ALPN"
msgstr ""

#: ../../library/ssl.rst:1322
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""
"SSLシャットダウンハンドシェイクを実行します。これは下位レイヤーのソケットから"
"TLSレイヤーを取り除き、下位レイヤーのソケットオブジェクトを返します。これは暗"
"号化されたオペレーションから暗号化されていない接続に移行するときに利用されま"
"す。以降の通信には、オリジナルのソケットではなくこのメソッドが返したソケット"
"のみを利用するべきです。"

#: ../../library/ssl.rst:1330
msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can "
"only be initiated for a TLS 1.3 connection from a server-side socket, after "
"the initial TLS handshake and with PHA enabled on both sides, see :attr:"
"`SSLContext.post_handshake_auth`."
msgstr ""

#: ../../library/ssl.rst:1335
msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""

#: ../../library/ssl.rst:1339
msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an :exc:"
"`SSLError` is raised."
msgstr ""

#: ../../library/ssl.rst:1343
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""

#: ../../library/ssl.rst:1350
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` if no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr ""
"コネクションによって実際にネゴシエイトされた SSL プロトコルバージョンを文字列"
"で、または、セキュアなコネクションが確立していなければ ``None`` を返します。"
"これを書いている時点では、 ``\"SSLv2\"``, ``\"SSLv3\"``, ``\"TLSv1\"``, "
"``\"TLSv1.1\"``, ``\"TLSv1.2\"`` などが返ります。最新の OpenSSL はもっと色々"
"な値を定義しているかもしれません。"

#: ../../library/ssl.rst:1360
msgid ""
"Returns the number of already decrypted bytes available for read, pending on "
"the connection."
msgstr ""
"接続において既に復号済みで読み出し可能で保留になっているバイト列の数を返しま"
"す。"

#: ../../library/ssl.rst:1365
msgid "The :class:`SSLContext` object this SSL socket is tied to."
msgstr ""

#: ../../library/ssl.rst:1371
msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for client-"
"side sockets."
msgstr ""
"サーバサイドのソケットに対して ``True`` 、クライアントサイドのソケットに対し"
"て ``False`` となる真偽値です。"

#: ../../library/ssl.rst:1378
msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr ""
"サーバのホスト名: :class:`str` 型、またはサーバサイドのソケットの場合とコンス"
"トラクタで hostname が指定されなかった場合は ``None``"

#: ../../library/ssl.rst:1383
msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the A-label "
"form (``\"xn--pythn-mua.org\"``), rather than the U-label form (``\"pythön."
"org\"``)."
msgstr ""

#: ../../library/ssl.rst:1391
msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available "
"for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before :meth:"
"`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""
"この SSL 接続に対する :class:`SSLSession` です。このセッションは、TLS ハンド"
"シェイクの実行後、クライアントサイドとサーバサイドのソケットで使用できます。"
"クライアントソケットでは、このセッションを :meth:`~SSLSocket.do_handshake` が"
"呼ばれる前に設定して、セッションを再利用できます。"

#: ../../library/ssl.rst:1404
msgid "SSL Contexts"
msgstr "SSL コンテキスト"

#: ../../library/ssl.rst:1408
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""
"SSL コンテキストは、SSL 構成オプション、証明書(群)や秘密鍵(群)などのような、"
"一回の SSL 接続よりも長生きするさまざまなデータを保持します。これはサーバサイ"
"ドソケットの SSL セッションのキャッシュも管理し、同じクライアントからの繰り返"
"しの接続時の速度向上に一役買います。"

#: ../../library/ssl.rst:1415
msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module.  The parameter specifies "
"which version of the SSL protocol to use.  Typically, the server chooses a "
"particular protocol version, and the client must adapt to the server's "
"choice.  Most of the versions are not interoperable with the other "
"versions.  If not specified, the default is :data:`PROTOCOL_TLS`; it "
"provides the most compatibility with other versions."
msgstr ""

#: ../../library/ssl.rst:1424
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr ""
"次のテーブルは、どのクライアントのバージョンがどのサーバのバージョンに接続で"
"きるかを示しています:"

#: ../../library/ssl.rst:1430
msgid "*client* / **server**"
msgstr "*client* / **server**"

#: ../../library/ssl.rst:1430
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../../library/ssl.rst:1430
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../../library/ssl.rst:1430
msgid "**TLS** [3]_"
msgstr "**TLS** [3]_"

#: ../../library/ssl.rst:1430
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../../library/ssl.rst:1430
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../../library/ssl.rst:1430
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../../library/ssl.rst:1432
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../../library/ssl.rst:1432 ../../library/ssl.rst:1433
#: ../../library/ssl.rst:1434 ../../library/ssl.rst:1435
#: ../../library/ssl.rst:1436 ../../library/ssl.rst:1437
msgid "yes"
msgstr "yes"

#: ../../library/ssl.rst:1432 ../../library/ssl.rst:1433
#: ../../library/ssl.rst:1435 ../../library/ssl.rst:1436
#: ../../library/ssl.rst:1437
msgid "no"
msgstr "no"

#: ../../library/ssl.rst:1432 ../../library/ssl.rst:1434
msgid "no [1]_"
msgstr "no [1]_"

#: ../../library/ssl.rst:1433
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../../library/ssl.rst:1433 ../../library/ssl.rst:1434
msgid "no [2]_"
msgstr "no [2]_"

#: ../../library/ssl.rst:1434
msgid "*TLS* (*SSLv23*) [3]_"
msgstr "*TLS* (*SSLv23*) [3]_"

#: ../../library/ssl.rst:1435
msgid "*TLSv1*"
msgstr "*TLSv1*"

#: ../../library/ssl.rst:1436
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

#: ../../library/ssl.rst:1437
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

#: ../../library/ssl.rst:1440
msgid "Footnotes"
msgstr "脚注"

#: ../../library/ssl.rst:1441
msgid ":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ""
":class:`SSLContext` では、デフォルトで :data:`OP_NO_SSLv2` によりSSLv2 が無効"
"になっています。"

#: ../../library/ssl.rst:1442
msgid ":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ""
":class:`SSLContext` では、デフォルトで :data:`OP_NO_SSLv3` により SSLv3 が無"
"効になっています。"

#: ../../library/ssl.rst:1443
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL >= "
"1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""

#: ../../library/ssl.rst:1448
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ""
":func:`create_default_context` は :mod:`ssl` モジュールに、目的に合ったセキュ"
"リティ設定を選ばせます。"

#: ../../library/ssl.rst:1453
msgid ""
"The context is created with secure default values. The options :data:"
"`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2`, and :"
"data:`OP_NO_SSLv3` (except for :data:`PROTOCOL_SSLv3`) are set by default. "
"The initial cipher suite list contains only ``HIGH`` ciphers, no ``NULL`` "
"ciphers and no ``MD5`` ciphers."
msgstr ""

#: ../../library/ssl.rst:1463
msgid ""
":class:`SSLContext` without protocol argument is deprecated. The context "
"class will either require :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol in the future."
msgstr ""

#: ../../library/ssl.rst:1469
msgid ""
"The default cipher suites now include only secure AES and ChaCha20 ciphers "
"with forward secrecy and security level 2. RSA and DH keys with less than "
"2048 bits and ECC keys with less than 224 bits are prohibited. :data:"
"`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT`, and :data:`PROTOCOL_TLS_SERVER` "
"use TLS 1.2 as minimum TLS version."
msgstr ""

#: ../../library/ssl.rst:1477
msgid ""
":class:`SSLContext` only supports limited mutation once it has been used by "
"a connection. Adding new certificates to the internal trust store is "
"allowed, but changing ciphers, verification settings, or mTLS certificates "
"may result in surprising behavior."
msgstr ""

#: ../../library/ssl.rst:1484
msgid ""
":class:`SSLContext` is designed to be shared and used by multiple "
"connections. Thus, it is thread-safe as long as it is not reconfigured after "
"being used by a connection."
msgstr ""

#: ../../library/ssl.rst:1489
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ":class:`SSLContext` オブジェクトは以下のメソッドと属性を持っています:"

#: ../../library/ssl.rst:1493
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509 "
"certificates flagged as CA certificates and certificate revocation lists as "
"dictionary."
msgstr ""
"ロードされた X.509 証明書の数、CA 証明書で活性の X.509 証明書の数、証明書失効"
"リストの数、についての統計情報を辞書として取得します。"

#: ../../library/ssl.rst:1497
msgid "Example for a context with one CA cert and one other cert::"
msgstr "一つの CA と他の一つの証明書を持ったコンテキストでの例です::"

#: ../../library/ssl.rst:1499
msgid ""
">>> context.cert_store_stats()\n"
"{'crl': 0, 'x509_ca': 1, 'x509': 2}"
msgstr ""

#: ../../library/ssl.rst:1507
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string "
"must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to "
"a file containing the private key.  Otherwise the private key will be taken "
"from *certfile* as well.  See the discussion of :ref:`ssl-certificates` for "
"more information on how the certificate is stored in the *certfile*."
msgstr ""
"秘密鍵と対応する証明書をロードします。 *certfile* は、証明書と、証明書認証で"
"必要とされる任意の数の CA 証明書を含む、PEM フォーマットの単一ファイルへのパ"
"スでなければなりません。 *keyfile* 文字列を指定する場合、秘密鍵が含まれるファ"
"イルを指すものでなければなりません。指定しない場合、秘密鍵も *certfile* から"
"取得されます。 *certfile* への証明書の格納についての詳細は、 :ref:`ssl-"
"certificates` の議論を参照してください。"

#: ../../library/ssl.rst:1516
msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments, "
"and it should return a string, bytes, or bytearray.  If the return value is "
"a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr ""
"*password* 引数に、秘密鍵を復号するためのパスワードを返す関数を与えることがで"
"きます。その関数は秘密鍵が暗号化されていて、なおかつパスワードが必要な場合に"
"のみ呼び出されます。その関数は引数なしで呼び出され、string, bytes, または "
"bytearray を返さなければなりません。戻り値が string の場合は鍵を復号化するの"
"に使う前に UTF-8 でエンコードされます。string の代わりに bytes や bytearray "
"を返した場合は *password* 引数に直接供給されます。秘密鍵が暗号化されていな"
"かったりパスワードを必要としない場合は、指定は無視されます。"

#: ../../library/ssl.rst:1525
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr ""
"*password* が与えられず、そしてパスワードが必要な場合には、OpenSSL 組み込みの"
"パスワード問い合わせメカニズムが、ユーザに対話的にパスワードを問い合わせま"
"す。"

#: ../../library/ssl.rst:1529
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr "秘密鍵が証明書に合致しなければ、 :class:`SSLError` が送出されます。"

#: ../../library/ssl.rst:1532
msgid "New optional argument *password*."
msgstr "新しいオプション引数 *password*。"

#: ../../library/ssl.rst:1537
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT`` "
"system stores. On all systems it calls :meth:`SSLContext."
"set_default_verify_paths`. In the future the method may load CA certificates "
"from other locations, too."
msgstr ""
"デフォルトの場所から \"認証局\" (CA=certification authority) 証明書ファイル一"
"式をロードします。Windows では、CA 証明書はシステム記憶域の ``CA`` と "
"``ROOT`` からロードします。全てのシステムでは、この関数は :meth:`SSLContext."
"set_default_verify_paths` を呼び出します。将来的にはこのメソッドは、他の場所"
"からも CA 証明書をロードするかもしれません。"

#: ../../library/ssl.rst:1543
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :const:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side "
"sockets). :const:`Purpose.CLIENT_AUTH` loads CA certificates for client "
"certificate verification on the server side."
msgstr ""

#: ../../library/ssl.rst:1553
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate "
"other peers' certificates when :data:`verify_mode` is other than :data:"
"`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""
":data:`verify_mode` が :data:`CERT_NONE` でない場合に接続先の証明書ファイルの"
"正当性検証に使われる \"認証局\" (CA=certification authority) 証明書ファイル一"
"式をロードします。少なくとも *cafile* か *capath* のどちらかは指定しなければ"
"なりません。"

#: ../../library/ssl.rst:1557
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr ""
"このメソッドは PEM または DER フォーマットの証明書失効リスト "
"(CRLs=certification revocation lists)もロードできます。CRLs のために使うに"
"は、 :attr:`SSLContext.verify_flags` を適切に設定しなければなりません。"

#: ../../library/ssl.rst:1561
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""
"*cafile* を指定する場合は、PEM フォーマットで CA 証明書が結合されたファイルへ"
"のパスを指定してください。このファイル内で証明書をどのように編成すれば良いの"
"かについての詳しい情報については、 :ref:`ssl-certificates` の議論を参照してく"
"ださい。"

#: ../../library/ssl.rst:1566
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout "
"<https://docs.openssl.org/master/man3/SSL_CTX_load_verify_locations/>`_."
msgstr ""

#: ../../library/ssl.rst:1571
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded certificates "
"are ignored but at least one certificate must be present."
msgstr ""
"*cadata* オブジェクトを指定する場合は、PEM エンコードの証明書一つ以上の "
"ASCII 文字列か、DER エンコードの証明書の :term:`bytes-like object` オブジェク"
"トのどちらかを指定してください。PEM エンコードの証明書の周囲の余分な行は無視"
"されますが、少なくとも一つの証明書が含まれている必要があります。"

#: ../../library/ssl.rst:1576
msgid "New optional argument *cadata*"
msgstr "新しいオプション引数 *cadata* 。"

#: ../../library/ssl.rst:1581
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr ""
"ロードされた \"認証局\" (CA=certification authority) 証明書のリストを取得しま"
"す。 ``binary_form`` 引数が :const:`False` である場合、リストのそれぞれのエン"
"トリは :meth:`SSLSocket.getpeercert` が出力するような辞書になります。True で"
"ある場合、このメソッドは、DER エンコード形式の証明書のリストを返します。返却"
"されるリストには、 SSL 接続によって証明書がリクエストおよびロードされない限"
"り、 *capath* からの証明書は含まれません。"

#: ../../library/ssl.rst:1589
msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr ""
"capath ディレクトリ内の証明書は一度でも使われない限りはロードされません。"

#: ../../library/ssl.rst:1596
msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. See :"
"meth:`SSLContext.set_ciphers`."
msgstr ""
"有効な暗号化のリストを取得します。リストは暗号化優先度順に並びます。:meth:"
"`SSLContext.set_ciphers` を参照してください。"

#: ../../library/ssl.rst:1601
msgid ""
">>> ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n"
">>> ctx.set_ciphers('ECDHE+AESGCM:!ECDSA')\n"
">>> ctx.get_ciphers()\n"
"[{'aead': True,\n"
"  'alg_bits': 256,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  '\n"
"                 'Enc=AESGCM(256) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380848,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES256-GCM-SHA384',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 256,\n"
"  'symmetric': 'aes-256-gcm'},\n"
" {'aead': True,\n"
"  'alg_bits': 128,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  '\n"
"                 'Enc=AESGCM(128) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380847,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES128-GCM-SHA256',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 128,\n"
"  'symmetric': 'aes-128-gcm'}]"
msgstr ""

#: ../../library/ssl.rst:1633
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""
"デフォルトの \"認証局\" (CA=certification authority) 証明書を、OpenSSL ライブ"
"ラリがビルドされた際に定義されたファイルシステム上のパスからロードします。残"
"念ながらこのメソッドが成功したかどうかを知るための簡単な方法はありません: 証"
"明書が見つからなくてもエラーは返りません。OpenSSL ライブラリがオペレーティン"
"グシステムの一部として提供されている際にはどうやら適切に構成できるようです"
"が。"

#: ../../library/ssl.rst:1642
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format <https://docs.openssl.org/"
"master/man1/ciphers/>`_. If no cipher can be selected (because compile-time "
"options or other configuration forbids use of all the specified ciphers), "
"an :class:`SSLError` will be raised."
msgstr ""

#: ../../library/ssl.rst:1650
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give "
"the currently selected cipher."
msgstr ""
"接続時に SSL ソケットの :meth:`SSLSocket.cipher` メソッドが、現在選択されてい"
"るその暗号を使います。"

#: ../../library/ssl.rst:1653
msgid ""
"TLS 1.3 cipher suites cannot be disabled with :meth:`~SSLContext."
"set_ciphers`."
msgstr ""

#: ../../library/ssl.rst:1658
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr ""
"SSL/TLS ハンドシェイク時にソケットが提示すべきプロトコルを指定します。 "
"``['http/1.1', 'spdy/2']`` のような推奨順に並べた ASCII 文字列のリストでなけ"
"ればなりません。プロトコルの選択は :rfc:`7301` に従いハンドシェイク中に行われ"
"ます。ハンドシェイクが正常に終了した後、 :meth:`SSLSocket."
"selected_alpn_protocol` メソッドは合意されたプロトコルを返します。"

#: ../../library/ssl.rst:1665
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"``False``."
msgstr ""
"このメソッドは :data:`HAS_ALPN` が ``False`` の場合 :exc:"
"`NotImplementedError` を送出します。"

#: ../../library/ssl.rst:1672
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. After a successful handshake, the :meth:"
"`SSLSocket.selected_npn_protocol` method will return the agreed-upon "
"protocol."
msgstr ""
"SSL/TLS ハンドシェイク時にソケットが提示すべきプロトコルを指定します。 "
"``['http/1.1', 'spdy/2']`` のような推奨順に並べた文字列のリストでなければなり"
"ません。プロトコルの選択は `Application Layer Protocol Negotiation <https://"
"en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_ に従いハンド"
"シェイク中に行われます。ハンドシェイクが正常に終了した後、 :meth:`SSLSocket."
"selected_alpn_protocol` メソッドは合意されたプロトコルを返します。"

#: ../../library/ssl.rst:1680
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"``False``."
msgstr ""
"このメソッドは :data:`HAS_NPN` が ``False`` の場合 :exc:"
"`NotImplementedError` を送出します。"

#: ../../library/ssl.rst:1691
msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr ""
"TLS クライアントがサーバ名表示を指定した際の、SSL/TLS サーバによって TLS "
"Client Hello ハンドシェイクメッセージが受け取られたあとで呼び出されるコール"
"バック関数を登録します。サーバ名表示メカニズムは :rfc:`6066` セクション 3 - "
"Server Name Indication で述べられています。"

#: ../../library/ssl.rst:1696
msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is set "
"to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""
"``SSLContext`` ごとに一つだけコールバックをセットできます。 *sni_callback* "
"を ``None`` にすればコールバックは無効になります。この関数を続けて呼ぶと、以"
"前に登録されたコールバックを上書きします。"

#: ../../library/ssl.rst:1700
msgid ""
"The callback function will be called with three arguments; the first being "
"the :class:`ssl.SSLSocket`, the second is a string that represents the "
"server name that the client is intending to communicate (or :const:`None` if "
"the TLS Client Hello does not contain a server name) and the third argument "
"is the original :class:`SSLContext`. The server name argument is text. For "
"internationalized domain name, the server name is an IDN A-label (``\"xn--"
"pythn-mua.org\"``)."
msgstr ""

#: ../../library/ssl.rst:1708
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s :"
"attr:`SSLSocket.context` attribute to a new object of type :class:"
"`SSLContext` representing a certificate chain that matches the server name."
msgstr ""
"このコールバックの典型的な利用方法は、 :class:`ssl.SSLSocket` の :attr:"
"`SSLSocket.context` 属性を、サーバ名に合致する証明書チェインを持つ新しい :"
"class:`SSLContext` オブジェクトに変更することです。"

#: ../../library/ssl.rst:1713
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like :meth:`SSLSocket."
"selected_alpn_protocol` and :attr:`SSLSocket.context`. The :meth:`SSLSocket."
"getpeercert`, :meth:`SSLSocket.get_verified_chain`, :meth:`SSLSocket."
"get_unverified_chain` :meth:`SSLSocket.cipher` and :meth:`SSLSocket."
"compression` methods require that the TLS connection has progressed beyond "
"the TLS Client Hello and therefore will not return meaningful values nor can "
"they be called safely."
msgstr ""

#: ../../library/ssl.rst:1722
msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant :const:"
"`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be returned.  "
"Other return values will result in a TLS fatal error with :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""
"TLS ネゴシエーションを継続させるならば、 *sni_callback* 関数は ``None`` を返"
"さなければなりません。TLS が失敗することを必要とするなら、 constant :const:"
"`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` を返してください。こ"
"こにない値を返すと、致命エラー :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` を引"
"き起こします。"

#: ../../library/ssl.rst:1728
msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message :const:"
"`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""
"*sni_callback* 関数が例外を送出した場合、TLS 接続は TLS の致命的アラートメッ"
"セージ :const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE` とともに終了します。"

#: ../../library/ssl.rst:1732
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had "
"OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""
"このメソッドは OpenSSL ライブラリが OPENSSL_NO_TLSEXT を定義してビルドされて"
"いる場合、 :exc:`NotImplementedError` を送出します。"

#: ../../library/ssl.rst:1739
msgid ""
"This is a legacy API retained for backwards compatibility. When possible, "
"you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the "
"server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythön.org\"``)."
msgstr ""

#: ../../library/ssl.rst:1745
msgid ""
"If there is a decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS alert "
"message to the client."
msgstr ""

#: ../../library/ssl.rst:1753
msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile* "
"parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr ""
"ディフィー・ヘルマン(DH)鍵交換のための鍵生成パラメータをロードします。DH 鍵交"
"換を用いることは、(サーバ、クライアントともに)計算機リソースに高い処理負荷を"
"かけますがセキュリティを向上させます。 *dhfile* パラメータは PEM フォーマット"
"の DH パラメータを含んだファイルへのパスでなければなりません。"

#: ../../library/ssl.rst:1759
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_DH_USE` option to further improve security."
msgstr ""
"この設定はクライアントソケットには適用されません。さらにセキュリティを改善す"
"るのに :data:`OP_SINGLE_DH_USE` オプションも利用できます。"

#: ../../library/ssl.rst:1766
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr ""
"楕円曲線ディフィー・ヘルマン(ECDH)鍵交換の曲線名を指定します。ECDH はもとの "
"DH に較べて、ほぼ間違いなく同程度に安全である一方で、顕著に高速です。 "
"*curve_name* パラメータは既知の楕円曲線を表す文字列でなければなりません。例え"
"ば ``prime256v1`` が広くサポートされている曲線です。"

#: ../../library/ssl.rst:1772
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr ""
"この設定はクライアントソケットには適用されません。さらにセキュリティを改善す"
"るのに :data:`OP_SINGLE_ECDH_USE` オプションも利用できます。"

#: ../../library/ssl.rst:1775
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr "このメソッドは :data:`HAS_ECDH` が ``False`` の場合は利用できません。"

#: ../../library/ssl.rst:1780
msgid ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.ch/en/blog/2011-"
"ssl-perfect-forward-secrecy>`_"
msgstr ""

#: ../../library/ssl.rst:1781
msgid "Vincent Bernat."
msgstr "Vincent Bernat."

#: ../../library/ssl.rst:1787
msgid ""
"Wrap an existing Python socket *sock* and return an instance of :attr:"
"`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The returned SSL "
"socket is tied to the context, its settings and certificates. *sock* must be "
"a :const:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""

#: ../../library/ssl.rst:1793
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr ""
"``server_side`` 引数は真偽値で、このソケットがサーバサイドとクライアントサイ"
"ドのどちらの動作をするのかを指定します。"

#: ../../library/ssl.rst:1796
msgid ""
"For client-side sockets, the context construction is lazy; if the underlying "
"socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method. The method may raise :"
"exc:`SSLError`."
msgstr ""
"クライアントサイドソケットにおいて、コンテキストの生成は遅延されます。つま"
"り、低レイヤのソケットがまだ接続されていない場合、コンテキストの生成はそのソ"
"ケットの :meth:`connect` メソッドが呼ばれた後に行われます。サーバサイドソケッ"
"トの場合、そのソケットに接続先が居なければそれは listen 用ソケットだと判断さ"
"れます。 :meth:`accept` メソッドで生成されるクライアント接続に対してのサーバ"
"サイド SSLラップは自動的に行われます。メソッドは :exc:`SSLError` を送出するこ"
"とがあります。"

#: ../../library/ssl.rst:1804
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr ""
"クライアントからの接続では、 *server_hostname* で接続先サービスのホスト名を指"
"定できます。これは HTTP バーチャルホストにかなり似て、シングルサーバで複数の "
"SSL ベースのサービスを別々の証明書でホストしているようなサーバに対して使えま"
"す。 *server_side* が True の場合に *server_hostname* を指定すると :exc:"
"`ValueError` を送出します。"

#: ../../library/ssl.rst:1810
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the "
"application program will call it explicitly, by invoking the :meth:"
"`SSLSocket.do_handshake` method.  Calling :meth:`SSLSocket.do_handshake` "
"explicitly gives the program control over the blocking behavior of the "
"socket I/O involved in the handshake."
msgstr ""
"``do_handshake_on_connect`` 引数は、 :meth:`socket.connect` の後に自動的に "
"SSLハンドシェイクを行うか、それともアプリケーションが明示的に :meth:"
"`SSLSocket.do_handshake` メソッドを実行するかを指定します。 :meth:`SSLSocket."
"do_handshake` を明示的に呼びだすことで、ハンドシェイクによるソケットI/Oのブ"
"ロッキング動作を制御できます。"

#: ../../library/ssl.rst:1817
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the :meth:`SSLSocket."
"recv` method should signal unexpected EOF from the other end of the "
"connection.  If specified as :const:`True` (the default), it returns a "
"normal EOF (an empty bytes object) in response to unexpected EOF errors "
"raised from the underlying socket; if :const:`False`, it will raise the "
"exceptions back to the caller."
msgstr ""
"``suppress_ragged_eofs`` 引数は、 :meth:`SSLSocket.recv` メソッドが、接続先か"
"ら予期しないEOF を受け取った時に通知する方法を指定します。 :const:`True` (デ"
"フォルト) の場合、下位のソケットレイヤーから予期せぬEOFエラーが来た場合、通常"
"のEOF (空のバイト列オブジェクト)を返します。 :const:`False` の場合、呼び出し"
"元に例外を投げて通知します。"

#: ../../library/ssl.rst:1824
msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr "*session*, :attr:`~SSLSocket.session` を参照してください。"

#: ../../library/ssl.rst:1826
msgid ""
"To wrap an :class:`SSLSocket` in another :class:`SSLSocket`, use :meth:"
"`SSLContext.wrap_bio`."
msgstr ""

#: ../../library/ssl.rst:1829
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr ""
"OpenSSL が SNI をサポートしなくても server_hostname を許容するようになりまし"
"た。"

#: ../../library/ssl.rst:1833 ../../library/ssl.rst:1859
msgid "*session* argument was added."
msgstr "*session* 引数が追加されました。"

#: ../../library/ssl.rst:1836
msgid ""
"The method returns an instance of :attr:`SSLContext.sslsocket_class` instead "
"of hard-coded :class:`SSLSocket`."
msgstr ""

#: ../../library/ssl.rst:1842
msgid ""
"The return type of :meth:`SSLContext.wrap_socket`, defaults to :class:"
"`SSLSocket`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLSocket`."
msgstr ""

#: ../../library/ssl.rst:1851
msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of :"
"attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the "
"outgoing BIO."
msgstr ""

#: ../../library/ssl.rst:1856
msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the same "
"meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""
"*server_side*、 *server_hostname* 、 *session* 引数は、 :meth:`SSLContext."
"wrap_socket` での意味と同じ意味を持ちます。"

#: ../../library/ssl.rst:1862
msgid ""
"The method returns an instance of :attr:`SSLContext.sslobject_class` instead "
"of hard-coded :class:`SSLObject`."
msgstr ""

#: ../../library/ssl.rst:1868
msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to :class:"
"`SSLObject`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLObject`."
msgstr ""

#: ../../library/ssl.rst:1876
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://docs.openssl.org/1.1.1/man3/SSL_CTX_sess_number/>`_ to their "
"numeric values.  For example, here is the total number of hits and misses in "
"the session cache since the context was created::"
msgstr ""

#: ../../library/ssl.rst:1881
msgid ""
">>> stats = context.session_stats()\n"
">>> stats['hits'], stats['misses']\n"
"(0, 0)"
msgstr ""

#: ../../library/ssl.rst:1887
msgid ""
"Whether to match the peer cert's hostname in :meth:`SSLSocket.do_handshake`. "
"The context's :attr:`~SSLContext.verify_mode` must be set to :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, and you must pass "
"*server_hostname* to :meth:`~SSLContext.wrap_socket` in order to match the "
"hostname.  Enabling hostname checking automatically sets :attr:`~SSLContext."
"verify_mode` from :data:`CERT_NONE` to :data:`CERT_REQUIRED`.  It cannot be "
"set back to :data:`CERT_NONE` as long as hostname checking is enabled. The :"
"data:`PROTOCOL_TLS_CLIENT` protocol enables hostname checking by default. "
"With other protocols, hostname checking must be enabled explicitly."
msgstr ""

#: ../../library/ssl.rst:1900
msgid ""
"import socket, ssl\n"
"\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n"
"context.verify_mode = ssl.CERT_REQUIRED\n"
"context.check_hostname = True\n"
"context.load_default_certs()\n"
"\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"ssl_sock = context.wrap_socket(s, server_hostname='www.verisign.com')\n"
"ssl_sock.connect(('www.verisign.com', 443))"
msgstr ""

#: ../../library/ssl.rst:1915
msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to :data:"
"`CERT_REQUIRED`  when hostname checking is enabled and :attr:`~SSLContext."
"verify_mode` is :data:`CERT_NONE`. Previously the same operation would have "
"failed with a :exc:`ValueError`."
msgstr ""

#: ../../library/ssl.rst:1922
msgid ""
"Write TLS keys to a keylog file, whenever key material is generated or "
"received. The keylog file is designed for debugging purposes only. The file "
"format is specified by NSS and used by many traffic analyzers such as "
"Wireshark. The log file is opened in append-only mode. Writes are "
"synchronized between threads, but not between processes."
msgstr ""

#: ../../library/ssl.rst:1932
msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :attr:`PROTOCOL_TLS`, :attr:"
"`PROTOCOL_TLS_CLIENT`, and :attr:`PROTOCOL_TLS_SERVER`."
msgstr ""

#: ../../library/ssl.rst:1937
msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` and :attr:`SSLContext.options` all affect the supported SSL "
"and TLS versions of the context. The implementation does not prevent invalid "
"combination. For example a context with :attr:`OP_NO_TLSv1_2` in :attr:"
"`~SSLContext.options` and :attr:`~SSLContext.maximum_version` set to :attr:"
"`TLSVersion.TLSv1_2` will not be able to establish a TLS 1.2 connection."
msgstr ""

#: ../../library/ssl.rst:1950
msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported "
"version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""

#: ../../library/ssl.rst:1957
msgid ""
"Control the number of TLS 1.3 session tickets of a :attr:"
"`PROTOCOL_TLS_SERVER` context. The setting has no impact on TLS 1.0 to 1.2 "
"connections."
msgstr ""

#: ../../library/ssl.rst:1965
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as :"
"data:`OP_NO_SSLv2` by ORing them together."
msgstr ""
"このコンテキストで有効になっている SSL オプションを表す整数。デフォルトの値"
"は :data:`OP_ALL` ですが、 :data:`OP_NO_SSLv2` のような他の値をビット OR 演算"
"で指定できます。"

#: ../../library/ssl.rst:1969
msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ""
":attr:`SSLContext.options` は次のように :class:`Options` のフラグを返します。"

#: ../../library/ssl.rst:1977
msgid ""
"All ``OP_NO_SSL*`` and ``OP_NO_TLS*`` options have been deprecated since "
"Python 3.7. Use :attr:`SSLContext.minimum_version` and :attr:`SSLContext."
"maximum_version` instead."
msgstr ""

#: ../../library/ssl.rst:1983
msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is "
"disabled by default and a server can only request a TLS client certificate "
"during the initial handshake. When enabled, a server may request a TLS "
"client certificate at any time after the handshake."
msgstr ""

#: ../../library/ssl.rst:1988
msgid ""
"When enabled on client-side sockets, the client signals the server that it "
"supports post-handshake authentication."
msgstr ""

#: ../../library/ssl.rst:1991
msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must be "
"set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual "
"client cert exchange is delayed until :meth:`SSLSocket."
"verify_client_post_handshake` is called and some I/O is performed."
msgstr ""

#: ../../library/ssl.rst:2001
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr ""
"コンテキストの構築時に選択されたプロトコルバージョン。この属性は読み出し専用"
"です。"

#: ../../library/ssl.rst:2006
msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the cert's "
"subject common name in the absence of a subject alternative name extension "
"(default: true)."
msgstr ""

#: ../../library/ssl.rst:2014
msgid ""
"The flag had no effect with OpenSSL before version 1.1.1l. Python 3.8.9, "
"3.9.3, and 3.10 include workarounds for previous versions."
msgstr ""

#: ../../library/ssl.rst:2019
msgid ""
"An integer representing the `security level <https://docs.openssl.org/master/"
"man3/SSL_CTX_get_security_level/>`_ for the context. This attribute is read-"
"only."
msgstr ""

#: ../../library/ssl.rst:2027
msgid ""
"The flags for certificate verification operations. You can set flags like :"
"data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL does "
"neither require nor verify certificate revocation lists (CRLs)."
msgstr ""
"証明書の検証操作のためのフラグです。 :data:`VERIFY_CRL_CHECK_LEAF` などのフラ"
"グをビット OR 演算でセットできます。デフォルトでは OpenSSL は証明書失効リス"
"ト (CRLs) を必要としませんし検証にも使いません。"

#: ../../library/ssl.rst:2033
msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ""
":attr:`SSLContext.verify_flags` は次のように :class:`VerifyFlags` のフラグを"
"返します。"

#: ../../library/ssl.rst:2041
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""
"接続先の証明書の検証を試みるかどうか、また、検証が失敗した場合にどのように振"
"舞うべきかを制御します。この属性は :data:`CERT_NONE`, :data:"
"`CERT_OPTIONAL`, :data:`CERT_REQUIRED` のうちどれか一つでなければなりません。"

#: ../../library/ssl.rst:2045
msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ""
":attr:`SSLContext.verify_mode` は次のように :class:`VerifyMode` enum (列挙) "
"を返します。"

#: ../../library/ssl.rst:2053
msgid ""
"Enables TLS-PSK (pre-shared key) authentication on a client-side connection."
msgstr ""

#: ../../library/ssl.rst:2055 ../../library/ssl.rst:2104
msgid ""
"In general, certificate based authentication should be preferred over this "
"method."
msgstr ""

#: ../../library/ssl.rst:2057
msgid ""
"The parameter ``callback`` is a callable object with the signature: ``def "
"callback(hint: str | None) -> tuple[str | None, bytes]``. The ``hint`` "
"parameter is an optional identity hint sent by the server. The return value "
"is a tuple in the form (client-identity, psk). Client-identity is an "
"optional string which may be used by the server to select a corresponding "
"PSK for the client. The string must be less than or equal to ``256`` octets "
"when UTF-8 encoded. PSK is a :term:`bytes-like object` representing the pre-"
"shared key. Return a zero length PSK to reject the connection."
msgstr ""

#: ../../library/ssl.rst:2067 ../../library/ssl.rst:2113
msgid "Setting ``callback`` to :const:`None` removes any existing callback."
msgstr ""

#: ../../library/ssl.rst:2070
msgid "When using TLS 1.3:"
msgstr ""

#: ../../library/ssl.rst:2072
msgid "the ``hint`` parameter is always :const:`None`."
msgstr ""

#: ../../library/ssl.rst:2073
msgid "client-identity must be a non-empty string."
msgstr ""

#: ../../library/ssl.rst:2075 ../../library/ssl.rst:2122
msgid "Example usage::"
msgstr "使用例::"

#: ../../library/ssl.rst:2077
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.check_hostname = False\n"
"context.verify_mode = ssl.CERT_NONE\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# A simple lambda:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_client_callback(lambda hint: (None, psk))\n"
"\n"
"# A table using the hint from the server:\n"
"psk_table = { 'ServerId_1': bytes.fromhex('c0ffee'),\n"
"              'ServerId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(hint):\n"
"    return 'ClientId_1', psk_table.get(hint, b'')\n"
"context.set_psk_client_callback(callback)"
msgstr ""

#: ../../library/ssl.rst:2095 ../../library/ssl.rst:2140
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_PSK` is "
"``False``."
msgstr ""

#: ../../library/ssl.rst:2102
msgid ""
"Enables TLS-PSK (pre-shared key) authentication on a server-side connection."
msgstr ""

#: ../../library/ssl.rst:2106
msgid ""
"The parameter ``callback`` is a callable object with the signature: ``def "
"callback(identity: str | None) -> bytes``. The ``identity`` parameter is an "
"optional identity sent by the client which can be used to select a "
"corresponding PSK. The return value is a :term:`bytes-like object` "
"representing the pre-shared key. Return a zero length PSK to reject the "
"connection."
msgstr ""

#: ../../library/ssl.rst:2115
msgid ""
"The parameter ``identity_hint`` is an optional identity hint string sent to "
"the client. The string must be less than or equal to ``256`` octets when "
"UTF-8 encoded."
msgstr ""

#: ../../library/ssl.rst:2120
msgid ""
"When using TLS 1.3 the ``identity_hint`` parameter is not sent to the client."
msgstr ""

#: ../../library/ssl.rst:2124
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# A simple lambda:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_server_callback(lambda identity: psk)\n"
"\n"
"# A table using the identity of the client:\n"
"psk_table = { 'ClientId_1': bytes.fromhex('c0ffee'),\n"
"              'ClientId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(identity):\n"
"    return psk_table.get(identity, b'')\n"
"context.set_psk_server_callback(callback, 'ServerId_1')"
msgstr ""

#: ../../library/ssl.rst:2152
msgid "Certificates"
msgstr "証明書"

#: ../../library/ssl.rst:2154
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the "
"key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that "
"if you encrypt a message with one of the parts, you can decrypt it with the "
"other part, and **only** with the other part."
msgstr ""
"証明書を大まかに説明すると、公開鍵/秘密鍵システムの一種です。このシステムで"
"は、各 *principal* (これはマシン、人、組織などです) は、ユニークな2つの暗号鍵"
"を割り当てられます。1つは公開され、 *公開鍵(public key)* と呼ばれます。もう一"
"方は秘密にされ、 *秘密鍵(private key)* と呼ばれます。 2つの鍵は関連しており、"
"片方の鍵で暗号化したメッセージは、もう片方の鍵 **のみ** で復号できます。"

#: ../../library/ssl.rst:2162
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's "
"statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed "
"as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""
"証明書は2つの principal の情報を含んでいます。証明書は *subject* 名とその公開"
"鍵を含んでいます。また、もう一つの principal である *発行者(issuer)* から"
"の、 subject が本人であることと、その公開鍵が正しいことの宣言(statement)を含"
"んでいます。発行者からの宣言は、その発行者の秘密鍵で署名されています。発行者"
"の秘密鍵は発行者しか知りませんが、誰もがその発行者の公開鍵を利用して宣言を復"
"号し、証明書内の別の情報と比較することで認証することができます。証明書はま"
"た、その証明書が有効である期限に関する情報も含んでいます。この期限は "
"\"notBefore\" と \"notAfter\" と呼ばれる2つのフィールドで表現されています。"

#: ../../library/ssl.rst:2172
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The "
"connection attempt can be set to raise an exception if the validation fails. "
"Validation is done automatically, by the underlying OpenSSL framework; the "
"application need not concern itself with its mechanics.  But the application "
"does usually need to provide sets of certificates to allow this process to "
"take place."
msgstr ""
"Python において証明書を利用する場合、クライアントもサーバーも自分を証明するた"
"めに証明書を利用することができます。ネットワーク接続の相手側に証明書の提示を"
"要求する事ができ、そのクライアントやサーバーが認証を必要とするならその証明書"
"を認証することができます。認証が失敗した場合、接続は例外を発生させます。認証"
"は下位層のOpenSSLフレームワークが自動的に行います。アプリケーションは認証機構"
"について意識する必要はありません。しかし、アプリケーションは認証プロセスのた"
"めに幾つかの証明書を提供する必要があるかもしれません。"

#: ../../library/ssl.rst:2182
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""
"Python は証明書を格納したファイルを利用します。そのファイルは \"PEM\" (:rfc:"
"`1422` 参照) フォーマットという、ヘッダー行とフッター行の間にbase-64エンコー"
"ドされた形をとっている必要があります。 ::"

#: ../../library/ssl.rst:2186
msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""

#: ../../library/ssl.rst:2191
msgid "Certificate chains"
msgstr "証明書チェイン"

#: ../../library/ssl.rst:2193
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the "
"agency which issued the certification authority's certificate::"
msgstr ""
"Pythonが利用する証明書を格納したファイルは、ときには *証明書チェイン"
"(certificate chain)* と呼ばれる証明書のシーケンスを格納します。このチェインの"
"先頭には、まずクライアントやサーバーである principal の証明書を置き、それ以降"
"には、その証明書の発行者(issuer)の証明書などを続け、最後に証明対象(subject)と"
"発行者が同じ *自己署名(self-signed)* 証明書で終わります。この最後の証明書は *"
"ルート証明書(root certificate* と呼ばれます。これらの証明書チェインは単純に1"
"つの証明書ファイルに結合してください。例えば、3つの証明書からなる証明書チェイ"
"ンがある場合、私たちのサーバーの証明書から、私たちのサーバーに署名した認証局"
"の証明書、そして認証局の証明書を発行した機関のルート証明書と続きます::"

#: ../../library/ssl.rst:2206
msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate for your server)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the certificate for the CA)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the root certificate for the CA's issuer)...\n"
"-----END CERTIFICATE-----"
msgstr ""

#: ../../library/ssl.rst:2217
msgid "CA certificates"
msgstr "CA 証明書"

#: ../../library/ssl.rst:2219
msgid ""
"If you are going to require validation of the other side of the connection's "
"certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling :meth:`SSLContext."
"load_default_certs`, this is done automatically with :func:`."
"create_default_context`."
msgstr ""
"もし相手から送られてきた証明書の認証をしたい場合、信頼している各発行者の証明"
"書チェインが入った \"CA certs\" ファイルを提供する必要があります。繰り返しま"
"すが、このファイルは単純に、各チェインを結合しただけのものです。認証のため"
"に、Pythonはそのファイルの中の最初にマッチしたチェインを利用します。:meth:"
"`SSLContext.load_default_certs` を呼び出すことでプラットフォームの証明書ファ"
"イルも使われますが、これは :func:`.create_default_context` によって自動的に行"
"われます。"

#: ../../library/ssl.rst:2228
msgid "Combined key and certificate"
msgstr "秘密鍵と証明書の組み合わせ"

#: ../../library/ssl.rst:2230
msgid ""
"Often the private key is stored in the same file as the certificate; in this "
"case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain` "
"needs to be passed.  If the private key is stored with the certificate, it "
"should come before the first certificate in the certificate chain::"
msgstr ""

#: ../../library/ssl.rst:2236
msgid ""
"-----BEGIN RSA PRIVATE KEY-----\n"
"... (private key in base64 encoding) ...\n"
"-----END RSA PRIVATE KEY-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""

#: ../../library/ssl.rst:2244
msgid "Self-signed certificates"
msgstr "自己署名証明書"

#: ../../library/ssl.rst:2246
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from "
"a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""
"SSL暗号化接続サービスを提供するサーバーを建てる場合、適切な証明書を取得するに"
"は、認証局から買うなどの幾つかの方法があります。また、自己署名証明書を作る"
"ケースもあります。 OpenSSLを使って自己署名証明書を作るには、次のようにしま"
"す。 ::"

#: ../../library/ssl.rst:2253
msgid ""
"% openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem\n"
"Generating a 1024 bit RSA private key\n"
".......++++++\n"
".............................++++++\n"
"writing new private key to 'cert.pem'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [AU]:US\n"
"State or Province Name (full name) [Some-State]:MyState\n"
"Locality Name (eg, city) []:Some City\n"
"Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Organization, "
"Inc.\n"
"Organizational Unit Name (eg, section) []:My Group\n"
"Common Name (eg, YOUR name) []:myserver.mygroup.myorganization.com\n"
"Email Address []:ops@myserver.mygroup.myorganization.com\n"
"%"
msgstr ""

#: ../../library/ssl.rst:2275
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr ""
"自己署名証明書の欠点は、それ自身がルート証明書であり、他の人はその証明書を"
"持っていない (そして信頼しない)ことです。"

#: ../../library/ssl.rst:2281
msgid "Examples"
msgstr "使用例"

#: ../../library/ssl.rst:2284
msgid "Testing for SSL support"
msgstr "SSLサポートをテストする"

#: ../../library/ssl.rst:2286
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr ""
"インストールされているPythonがSSLをサポートしているかどうかをテストするため"
"に、ユーザーコードは次のイディオムを利用することができます。 ::"

#: ../../library/ssl.rst:2289
msgid ""
"try:\n"
"    import ssl\n"
"except ImportError:\n"
"    pass\n"
"else:\n"
"    ...  # do something that requires SSL support"
msgstr ""

#: ../../library/ssl.rst:2297
msgid "Client-side operation"
msgstr "クライアントサイドの処理"

#: ../../library/ssl.rst:2299
msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr ""
"この例では、自動的に証明書の検証を行うことを含む望ましいセキュリティ設定でク"
"ライアントソケットの SSL コンテキストを作ります::"

#: ../../library/ssl.rst:2302
msgid ">>> context = ssl.create_default_context()"
msgstr ""

#: ../../library/ssl.rst:2304
msgid ""
"If you prefer to tune security settings yourself, you might create a context "
"from scratch (but beware that you might not get the settings right)::"
msgstr ""
"自分自身でセキュリティ設定を調整したい場合、コンテキストを一から作ることはで"
"きます (ただし、正しくない設定をしてしまいがちなことに注意してください)::"

#: ../../library/ssl.rst:2308
msgid ""
">>> context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> context.load_verify_locations(\"/etc/ssl/certs/ca-bundle.crt\")"
msgstr ""

#: ../../library/ssl.rst:2311
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""
"(このスニペットはすべての CA 証明書が ``/etc/ssl/certs/ca-bundle.crt`` にバン"
"ドルされていることを仮定しています; もし違っていればエラーになりますので、適"
"宜修正してください)"

#: ../../library/ssl.rst:2315
msgid ""
"The :data:`PROTOCOL_TLS_CLIENT` protocol configures the context for cert "
"validation and hostname verification. :attr:`~SSLContext.verify_mode` is set "
"to :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` is set to "
"``True``. All other protocols create SSL contexts with insecure defaults."
msgstr ""

#: ../../library/ssl.rst:2320
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` and :"
"attr:`~SSLContext.check_hostname` validate the server certificate: it "
"ensures that the server certificate was signed with one of the CA "
"certificates, checks the signature for correctness, and verifies other "
"properties like validity and identity of the hostname::"
msgstr ""

#: ../../library/ssl.rst:2326
msgid ""
">>> conn = context.wrap_socket(socket.socket(socket.AF_INET),\n"
"...                            server_hostname=\"www.python.org\")\n"
">>> conn.connect((\"www.python.org\", 443))"
msgstr ""

#: ../../library/ssl.rst:2330
msgid "You may then fetch the certificate::"
msgstr "そして証明書を持ってくることができます::"

#: ../../library/ssl.rst:2332
msgid ">>> cert = conn.getpeercert()"
msgstr ""

#: ../../library/ssl.rst:2334
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr ""
"証明書が、期待しているサービス (つまり、 HTTPS ホスト ``www.python.org``) の"
"身元を特定していることを視覚的に点検してみましょう::"

#: ../../library/ssl.rst:2337
msgid ""
">>> pprint.pprint(cert)\n"
"{'OCSP': ('http://ocsp.digicert.com',),\n"
" 'caIssuers': ('http://cacerts.digicert.com/"
"DigiCertSHA2ExtendedValidationServerCA.crt',),\n"
" 'crlDistributionPoints': ('http://crl3.digicert.com/sha2-ev-server-g1."
"crl',\n"
"                           'http://crl4.digicert.com/sha2-ev-server-g1."
"crl'),\n"
" 'issuer': ((('countryName', 'US'),),\n"
"            (('organizationName', 'DigiCert Inc'),),\n"
"            (('organizationalUnitName', 'www.digicert.com'),),\n"
"            (('commonName', 'DigiCert SHA2 Extended Validation Server "
"CA'),)),\n"
" 'notAfter': 'Sep  9 12:00:00 2016 GMT',\n"
" 'notBefore': 'Sep  5 00:00:00 2014 GMT',\n"
" 'serialNumber': '01BB6F00122B177F36CAB49CEA8B6B26',\n"
" 'subject': ((('businessCategory', 'Private Organization'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.3', 'US'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.2', 'Delaware'),),\n"
"             (('serialNumber', '3359300'),),\n"
"             (('streetAddress', '16 Allen Rd'),),\n"
"             (('postalCode', '03894-4801'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'NH'),),\n"
"             (('localityName', 'Wolfeboro'),),\n"
"             (('organizationName', 'Python Software Foundation'),),\n"
"             (('commonName', 'www.python.org'),)),\n"
" 'subjectAltName': (('DNS', 'www.python.org'),\n"
"                    ('DNS', 'python.org'),\n"
"                    ('DNS', 'pypi.org'),\n"
"                    ('DNS', 'docs.python.org'),\n"
"                    ('DNS', 'testpypi.org'),\n"
"                    ('DNS', 'bugs.python.org'),\n"
"                    ('DNS', 'wiki.python.org'),\n"
"                    ('DNS', 'hg.python.org'),\n"
"                    ('DNS', 'mail.python.org'),\n"
"                    ('DNS', 'packaging.python.org'),\n"
"                    ('DNS', 'pythonhosted.org'),\n"
"                    ('DNS', 'www.pythonhosted.org'),\n"
"                    ('DNS', 'test.pythonhosted.org'),\n"
"                    ('DNS', 'us.pycon.org'),\n"
"                    ('DNS', 'id.python.org')),\n"
" 'version': 3}"
msgstr ""

#: ../../library/ssl.rst:2377
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr ""
"SSL チャネルは今や確立されて証明書が検証されているので、サーバとのお喋りを続"
"けることができます::"

#: ../../library/ssl.rst:2380
msgid ""
">>> conn.sendall(b\"HEAD / HTTP/1.0\\r\\nHost: linuxfr.org\\r\\n\\r\\n\")\n"
">>> pprint.pprint(conn.recv(1024).split(b\"\\r\\n\"))\n"
"[b'HTTP/1.1 200 OK',\n"
" b'Date: Sat, 18 Oct 2014 18:27:20 GMT',\n"
" b'Server: nginx',\n"
" b'Content-Type: text/html; charset=utf-8',\n"
" b'X-Frame-Options: SAMEORIGIN',\n"
" b'Content-Length: 45679',\n"
" b'Accept-Ranges: bytes',\n"
" b'Via: 1.1 varnish',\n"
" b'Age: 2188',\n"
" b'X-Served-By: cache-lcy1134-LCY',\n"
" b'X-Cache: HIT',\n"
" b'X-Cache-Hits: 11',\n"
" b'Vary: Cookie',\n"
" b'Strict-Transport-Security: max-age=63072000; includeSubDomains',\n"
" b'Connection: close',\n"
" b'',\n"
" b'']"
msgstr ""

#: ../../library/ssl.rst:2404
msgid "Server-side operation"
msgstr "サーバサイドの処理"

#: ../../library/ssl.rst:2406
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""
"サーバサイドの処理では、通常、サーバー証明書と秘密鍵がそれぞれファイルに格納"
"された形で必要です。最初に秘密鍵と証明書が保持されたコンテキストを作成し、ク"
"ライアントがあなたの信憑性をチェックできるようにします。そののちにソケットを"
"開き、ポートにバインドし、そのソケットの :meth:`listen` を呼び、クライアント"
"からの接続を待ちます。 ::"

#: ../../library/ssl.rst:2412
msgid ""
"import socket, ssl\n"
"\n"
"context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n"
"context.load_cert_chain(certfile=\"mycertfile\", keyfile=\"mykeyfile\")\n"
"\n"
"bindsocket = socket.socket()\n"
"bindsocket.bind(('myaddr.example.com', 10023))\n"
"bindsocket.listen(5)"
msgstr ""

#: ../../library/ssl.rst:2421
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's :meth:`SSLContext."
"wrap_socket` method to create a server-side SSL socket for the connection::"
msgstr ""
"クライアントが接続してきた場合、 :meth:`accept` を呼んで新しいソケットを作成"
"し、接続のためにサーバサイドの SSL ソケットを、コンテキストの :meth:"
"`SSLContext.wrap_socket` メソッドで作ります::"

#: ../../library/ssl.rst:2425
msgid ""
"while True:\n"
"    newsocket, fromaddr = bindsocket.accept()\n"
"    connstream = context.wrap_socket(newsocket, server_side=True)\n"
"    try:\n"
"        deal_with_client(connstream)\n"
"    finally:\n"
"        connstream.shutdown(socket.SHUT_RDWR)\n"
"        connstream.close()"
msgstr ""

#: ../../library/ssl.rst:2434
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr ""
"そして、 ``connstream`` からデータを読み、クライアントと切断する(あるいはクラ"
"イアントが切断してくる)まで何か処理をします。 ::"

#: ../../library/ssl.rst:2437
msgid ""
"def deal_with_client(connstream):\n"
"    data = connstream.recv(1024)\n"
"    # empty data means the client is finished with us\n"
"    while data:\n"
"        if not do_something(connstream, data):\n"
"            # we'll assume do_something returns False\n"
"            # when we're finished with client\n"
"            break\n"
"        data = connstream.recv(1024)\n"
"    # finished with client"
msgstr ""

#: ../../library/ssl.rst:2448
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or "
"put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use an "
"event loop)."
msgstr ""
"そして新しいクライアント接続のために listen に戻ります。 (もちろん現実のサー"
"バは、おそらく個々のクライアント接続ごとに別のスレッドで処理するか、ソケット"
"を :ref:`ノンブロッキングモード <ssl-nonblocking>` にし、イベントループを使う"
"でしょう。)"

#: ../../library/ssl.rst:2456
msgid "Notes on non-blocking sockets"
msgstr "ノンブロッキングソケットについての注意事項"

#: ../../library/ssl.rst:2458
msgid ""
"SSL sockets behave slightly different than regular sockets in non-blocking "
"mode. When working with non-blocking sockets, there are thus several things "
"you need to be aware of:"
msgstr ""
"SSL ソケットはノンブロッキングモードにおいては、普通のソケットとは少し違った"
"振る舞いをします。ですのでノンブロッキングソケットとともに使う場合、いくつか"
"気をつけなければならない事項があります:"

#: ../../library/ssl.rst:2462
msgid ""
"Most :class:`SSLSocket` methods will raise either :exc:`SSLWantWriteError` "
"or :exc:`SSLWantReadError` instead of :exc:`BlockingIOError` if an I/O "
"operation would block. :exc:`SSLWantReadError` will be raised if a read "
"operation on the underlying socket is necessary, and :exc:"
"`SSLWantWriteError` for a write operation on the underlying socket. Note "
"that attempts to *write* to an SSL socket may require *reading* from the "
"underlying socket first, and attempts to *read* from the SSL socket may "
"require a prior *write* to the underlying socket."
msgstr ""
"ほとんどの :class:`SSLSocket` のメソッドは I/O 操作がブロックすると :exc:"
"`BlockingIOError` ではなく :exc:`SSLWantWriteError` か :exc:"
"`SSLWantReadError` のどちらかを送出します。 :exc:`SSLWantReadError` は下層の"
"ソケットで読み出しが必要な場合に送出され、 :exc:`SSLWantWriteError` は下層の"
"ソケットで書き込みが必要な場合に送出されます。SSL ソケットに対して *書き込み"
"* を試みると下層のソケットから最初に *読み出す* 必要があるかもしれず、SSL ソ"
"ケットに対して *読み出し* を試みると下層のソケットに先に *書き込む* 必要があ"
"るかもしれないことに注意してください。"

#: ../../library/ssl.rst:2474
msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned zero "
"instead of raising :exc:`SSLWantWriteError` or :exc:`SSLWantReadError`."
msgstr ""
"以前の Python バージョンでは、 :meth:`!SSLSocket.send` メソッドは :exc:"
"`SSLWantWriteError` または :exc:`SSLWantReadError` を送出するのではなく、ゼロ"
"を返していました。"

#: ../../library/ssl.rst:2478
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv` "
"and :meth:`SSLSocket.send` failures, and retry after another call to :func:"
"`~select.select`."
msgstr ""
":func:`~select.select` 呼び出しは OS レベルでのソケットが読み出し可能(または"
"書き込み可能)になったことを教えてくれますが、上位の SSL レイヤーでの十分な"
"データがあることを意味するわけではありません。例えば、SSL フレームの一部が届"
"いただけかもしれません。ですから、 :meth:`SSLSocket.recv` と :meth:"
"`SSLSocket.send` の失敗を処理することに備え、ほかの :func:`~select.select` 呼"
"び出し後にリトライしなければなりません。"

#: ../../library/ssl.rst:2485
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any "
"potentially available data, and then only block on a :func:`~select.select` "
"call if still necessary."
msgstr ""
"反対に、SSL レイヤーは独自の枠組みを持っているため、:func:`~select.select` が"
"気付かない読み出し可能なデータを SSL ソケットが持っている場合があります。した"
"がって、入手可能な可能性のあるデータをすべて引き出すために最初に :meth:"
"`SSLSocket.recv` を呼び出し、次にそれでもまだ必要な場合にだけ :func:`~select."
"select` 呼び出しでブロックすべきです。"

#: ../../library/ssl.rst:2491
msgid ""
"(of course, similar provisions apply when using other primitives such as :"
"func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr ""
"(当然のことながら、ほかのプリミティブ、例えば :func:`~select.poll` や :mod:"
"`selectors` モジュール内のものを使う際にも似た但し書きが付きます)"

#: ../../library/ssl.rst:2494
msgid ""
"The SSL handshake itself will be non-blocking: the :meth:`SSLSocket."
"do_handshake` method has to be retried until it returns successfully.  Here "
"is a synopsis using :func:`~select.select` to wait for the socket's "
"readiness::"
msgstr ""
"SSL ハンドシェイクそのものがノンブロッキングになります: :meth:`SSLSocket."
"do_handshake` メソッドは成功するまでリトライしなければなりません。 :func:"
"`~select.select` を用いてソケットの準備が整うのを待つためには、およそ以下のよ"
"うにします::"

#: ../../library/ssl.rst:2499
msgid ""
"while True:\n"
"    try:\n"
"        sock.do_handshake()\n"
"        break\n"
"    except ssl.SSLWantReadError:\n"
"        select.select([sock], [], [])\n"
"    except ssl.SSLWantWriteError:\n"
"        select.select([], [sock], [])"
msgstr ""

#: ../../library/ssl.rst:2510
msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level API. It polls for events using "
"the :mod:`selectors` module and handles :exc:`SSLWantWriteError`, :exc:"
"`SSLWantReadError` and :exc:`BlockingIOError` exceptions. It runs the SSL "
"handshake asynchronously as well."
msgstr ""
":mod:`asyncio` モジュールは :ref:`ノンブロッキング SSL ソケット <ssl-"
"nonblocking>` をサポートし、より高いレベルの API を提供しています。 :mod:"
"`selectors` モジュールを使ってイベントを poll し、 :exc:"
"`SSLWantWriteError`, :exc:`SSLWantReadError`, :exc:`BlockingIOError` 例外を処"
"理します。SSL ハンドシェイクも非同期に実行します。"

#: ../../library/ssl.rst:2519
msgid "Memory BIO Support"
msgstr "メモリ BIO サポート"

#: ../../library/ssl.rst:2523
msgid ""
"Ever since the SSL module was introduced in Python 2.6, the :class:"
"`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr ""
"Python 2.6 で SSL モジュールが導入されて以降、:class:`SSLSocket` クラスは、以"
"下の互いに関連するが別々の機能を提供してきました。"

#: ../../library/ssl.rst:2526
msgid "SSL protocol handling"
msgstr "SSL プロトコル処理"

#: ../../library/ssl.rst:2527
msgid "Network IO"
msgstr "ネットワーク IO"

#: ../../library/ssl.rst:2529
msgid ""
"The network IO API is identical to that provided by :class:`socket.socket`, "
"from which :class:`SSLSocket` also inherits. This allows an SSL socket to be "
"used as a drop-in replacement for a regular socket, making it very easy to "
"add SSL support to an existing application."
msgstr ""
"ネットワーク IO API は、:class:`socket.socket` が提供するものと同じです。:"
"class:`SSLSocket` も、そのクラスから継承しています。これにより、SSL ソケット"
"は標準のソケットをそっくりそのまま置き換えるものとして使用できるため、既存の"
"アプリケーションを SSL に対応させるのが非常に簡単になります。"

#: ../../library/ssl.rst:2534
msgid ""
"Combining SSL protocol handling and network IO usually works well, but there "
"are some cases where it doesn't. An example is async IO frameworks that want "
"to use a different IO multiplexing model than the \"select/poll on a file "
"descriptor\" (readiness based) model that is assumed by :class:`socket."
"socket` and by the internal OpenSSL socket IO routines. This is mostly "
"relevant for platforms like Windows where this model is not efficient. For "
"this purpose, a reduced scope variant of :class:`SSLSocket` called :class:"
"`SSLObject` is provided."
msgstr ""
"SSL プロトコルの処理とネットワーク IO を組み合わせた場合、通常は問題なく動作"
"しますが、問題が発生する場合があります。一例を挙げると、非同期 IO フレーム"
"ワークが別の多重化モデルを使用する場合、これは :class:`socket.socket` と内部 "
"OpenSSL ソケット IO ルーティンが想定する「ファイル記述子上の select/poll」モ"
"デル（準備状態ベース）とは異なります。これは、このモデルが非効率的になる "
"Windows などのプラットフォームに主に該当します。そのため、スコープを限定し"
"た :class:`SSLSocket` の変種、 :class:`SSLObject` が提供されています。"

#: ../../library/ssl.rst:2545
msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL protocol "
"instance that does not contain any network IO methods. This class is "
"typically used by framework authors that want to implement asynchronous IO "
"for SSL through memory buffers."
msgstr ""
"ネットワーク IO メソッドを含まない SSL プロトコルインスタンスを表す、スコープ"
"を限定した :class:`SSLSocket` の変種です。一般的にこ、のクラスを使用するの"
"は、メモリバッファを通じて SSL のための非同期 IO を実装するフレームワーク作成"
"者です。"

#: ../../library/ssl.rst:2550
msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL connection "
"but does not provide any network IO itself. IO needs to be performed through "
"separate \"BIO\" objects which are OpenSSL's IO abstraction layer."
msgstr ""
"このクラスは、OpenSSL が実装する低水準 SSL オブジェクトの上にインターフェース"
"を実装します。このオブジェクトは SSL 接続の状態をキャプチャしますが、ネット"
"ワーク IO 自体は提供しません。IO は、OpenSSL の IO 抽象レイヤである別の"
"「BIO」オブジェクトを通じて実行する必要があります。"

#: ../../library/ssl.rst:2555
msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance must "
"be created using the :meth:`~SSLContext.wrap_bio` method. This method will "
"create the :class:`SSLObject` instance and bind it to a pair of BIOs. The "
"*incoming* BIO is used to pass data from Python to the SSL protocol "
"instance, while the *outgoing* BIO is used to pass data the other way around."
msgstr ""
"このクラスには公開されたコンストラクタがありません。:class:`SSLObject` インス"
"タンスは、 :meth:`~SSLContext.wrap_bio` メソッドを使用して作成しなければなり"
"ません。このメソッドは、:class:`SSLObject` インスタンスを作成し、2 つの BIO "
"に束縛します。*incoming* BIO は、Python から SSL プロトコルインスタンスにデー"
"タを渡すために使用され、*outgoing* BIO は、データを反対向きに渡すために使用さ"
"れます。"

#: ../../library/ssl.rst:2562
msgid "The following methods are available:"
msgstr "次のメソッドがサポートされています:"

#: ../../library/ssl.rst:2564
msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

#: ../../library/ssl.rst:2565
msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.server_side`"

#: ../../library/ssl.rst:2566
msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.server_hostname`"

#: ../../library/ssl.rst:2567
msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

#: ../../library/ssl.rst:2568
msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

#: ../../library/ssl.rst:2569
msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

#: ../../library/ssl.rst:2570
msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

#: ../../library/ssl.rst:2571
msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

#: ../../library/ssl.rst:2572
msgid ":meth:`~SSLSocket.get_verified_chain`"
msgstr ""

#: ../../library/ssl.rst:2573
msgid ":meth:`~SSLSocket.get_unverified_chain`"
msgstr ""

#: ../../library/ssl.rst:2574
msgid ":meth:`~SSLSocket.selected_alpn_protocol`"
msgstr ":meth:`~SSLSocket.selected_alpn_protocol`"

#: ../../library/ssl.rst:2575
msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

#: ../../library/ssl.rst:2576
msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

#: ../../library/ssl.rst:2577
msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

#: ../../library/ssl.rst:2578
msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

#: ../../library/ssl.rst:2579
msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.pending`"

#: ../../library/ssl.rst:2580
msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

#: ../../library/ssl.rst:2581
msgid ":meth:`~SSLSocket.verify_client_post_handshake`"
msgstr ":meth:`~SSLSocket.verify_client_post_handshake`"

#: ../../library/ssl.rst:2582
msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

#: ../../library/ssl.rst:2583
msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

#: ../../library/ssl.rst:2584
msgid ":meth:`~SSLSocket.version`"
msgstr ":meth:`~SSLSocket.version`"

#: ../../library/ssl.rst:2586
msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr ""
":class:`SSLSocket` と比較すると、このオブジェクトでは以下の機能が不足していま"
"す。"

#: ../../library/ssl.rst:2589
msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to the "
"underlying :class:`MemoryBIO` buffers."
msgstr ""

#: ../../library/ssl.rst:2592
msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually "
"call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""
"*do_handshake_on_connect* 機構はありません。必ず手動で :meth:`~SSLSocket."
"do_handshake` を呼んで、ハンドシェイクを開始する必要があります。"

#: ../../library/ssl.rst:2595
msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file conditions "
"that are in violation of the protocol are reported via the :exc:"
"`SSLEOFError` exception."
msgstr ""
"*suppress_ragged_eofs* は処理されません。プロトコルに違反するファイル末尾状態"
"は、 :exc:`SSLEOFError` 例外を通じて報告されます。"

#: ../../library/ssl.rst:2599
msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, unlike "
"for an SSL socket where it returns the underlying socket."
msgstr ""
":meth:`~SSLSocket.unwrap` メソッドの呼び出しは、下層のソケットを返す SSL ソ"
"ケットとは異なり、何も返しません。"

#: ../../library/ssl.rst:2602
msgid ""
"The *server_name_callback* callback passed to :meth:`SSLContext."
"set_servername_callback` will get an :class:`SSLObject` instance instead of "
"a :class:`SSLSocket` instance as its first parameter."
msgstr ""
":meth:`SSLContext.set_servername_callback` に渡される *server_name_callback* "
"コールバックは、1 つ目の引数として :class:`SSLSocket` インスタンスではなく :"
"class:`SSLObject` インスタンスを受け取ります。"

#: ../../library/ssl.rst:2606
msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr ":class:`SSLObject` の使用に関する注意:"

#: ../../library/ssl.rst:2608
msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`. "
"This means that for example :meth:`~SSLSocket.read` will raise an :exc:"
"`SSLWantReadError` if it needs more data than the incoming BIO has available."
msgstr ""
":class:`SSLObject` 上のすべての IO は :ref:`non-blocking <ssl-nonblocking>` "
"です。例えば、:meth:`~SSLSocket.read` は入力 BIO が持つデータよりも多くのデー"
"タを必要とする場合、:exc:`SSLWantReadError` を送出します。"

#: ../../library/ssl.rst:2613
msgid ""
":class:`SSLObject` instances must be created with :meth:`~SSLContext."
"wrap_bio`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""

#: ../../library/ssl.rst:2619
msgid ""
"An SSLObject communicates with the outside world using memory buffers. The "
"class :class:`MemoryBIO` provides a memory buffer that can be used for this "
"purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""
"SSLObject は、メモリバッファを使用して外界と通信します。:class:`MemoryBIO` ク"
"ラスは、以下のように OpenSSL メモリ BIO (Basic IO) オブジェクトをラップし、こ"
"の目的に使用できるメモリバッファを提供します。"

#: ../../library/ssl.rst:2625
msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr ""
"Python と SSL プロトコルインスタンス間でデータをやり取りするために使用できる"
"メモリバッファ。"

#: ../../library/ssl.rst:2630
msgid "Return the number of bytes currently in the memory buffer."
msgstr "現在メモリバッファ中にあるバイト数を返します。"

#: ../../library/ssl.rst:2634
msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file "
"position."
msgstr "メモリ BIOが現在ファイルの末尾にあるかを表す真偽値です。"

#: ../../library/ssl.rst:2639
msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr ""
"メモリバッファから最大 *n* 読み取ります。*n* が指定されていないか、負値の場"
"合、すべてのバイトが返されます。"

#: ../../library/ssl.rst:2644
msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be an "
"object supporting the buffer protocol."
msgstr ""
"*buf* からメモリ BIO にバイトを書き込みます。*buf* 引数は、バッファプロトコル"
"をサポートするオブジェクトでなければなりません。"

#: ../../library/ssl.rst:2647
msgid ""
"The return value is the number of bytes written, which is always equal to "
"the length of *buf*."
msgstr ""
"戻り値は、書き込まれるバイト数であり、常に *buf* の長さと等しくなります。"

#: ../../library/ssl.rst:2652
msgid ""
"Write an EOF marker to the memory BIO. After this method has been called, it "
"is illegal to call :meth:`~MemoryBIO.write`. The attribute :attr:`eof` will "
"become true after all data currently in the buffer has been read."
msgstr ""
"EOF マーカーをメモリ BIO に書き込みます。このメソッドが呼び出された後に :"
"meth:`~MemoryBIO.write` を呼ぶことはできません。:attr:`eof` 属性は、バッファ"
"内のすべてのデータが読み出された後に True になります。"

#: ../../library/ssl.rst:2658
msgid "SSL session"
msgstr "SSL セッション"

#: ../../library/ssl.rst:2664
msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr ":attr:`~SSLSocket.session` が使用するセッションオブジェクトです。"

#: ../../library/ssl.rst:2676
msgid "Security considerations"
msgstr "セキュリティで考慮すべき点"

#: ../../library/ssl.rst:2679
msgid "Best defaults"
msgstr "最善のデフォルト値"

#: ../../library/ssl.rst:2681
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the :func:"
"`create_default_context` function to create your SSL context. It will load "
"the system's trusted CA certificates, enable certificate validation and "
"hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr ""
"**クライアントでの使用** では、セキュリティポリシーによる特殊な要件がない限り"
"は、 :func:`create_default_context` 関数を使用して SSL コンテキストを作成する"
"ことを強くお勧めします。この関数は、システムの信頼済み CA 証明書をロードし、"
"証明書の検証とホスト名のチェックを有効化し、十分にセキュアなプロトコルと暗号"
"を選択しようとします。"

#: ../../library/ssl.rst:2688
msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to "
"create a trusted, secure connection to a SMTP server::"
msgstr ""
"例として、 :class:`smtplib.SMTP` クラスを使用して SMTP サーバーに対して信頼で"
"きるセキュアな接続を行う方法を以下に示します::"

#: ../../library/ssl.rst:2691
msgid ""
">>> import ssl, smtplib\n"
">>> smtp = smtplib.SMTP(\"mail.python.org\", port=587)\n"
">>> context = ssl.create_default_context()\n"
">>> smtp.starttls(context=context)\n"
"(220, b'2.0.0 Ready to start TLS')"
msgstr ""

#: ../../library/ssl.rst:2697
msgid ""
"If a client certificate is needed for the connection, it can be added with :"
"meth:`SSLContext.load_cert_chain`."
msgstr ""
"接続にクライアントの証明書が必要な場合、 :meth:`SSLContext.load_cert_chain` "
"によって追加できます。"

#: ../../library/ssl.rst:2700
msgid ""
"By contrast, if you create the SSL context by calling the :class:"
"`SSLContext` constructor yourself, it will not have certificate validation "
"nor hostname checking enabled by default.  If you do so, please read the "
"paragraphs below to achieve a good security level."
msgstr ""
"対照的に、自分自身で :class:`SSLContext` クラスのコンストラクタを呼び出すこと"
"によって SSL コンテキストを作ると、デフォルトでは証明書検証もホスト名チェック"
"も有効になりません。自分で設定を行う場合は、十分なセキュリティレベルを達成す"
"るために、以下のパラグラフをお読みください。"

#: ../../library/ssl.rst:2706
msgid "Manual settings"
msgstr "手動での設定"

#: ../../library/ssl.rst:2709
msgid "Verifying certificates"
msgstr "証明書の検証"

#: ../../library/ssl.rst:2711
msgid ""
"When calling the :class:`SSLContext` constructor directly, :const:"
"`CERT_NONE` is the default.  Since it does not authenticate the other peer, "
"it can be insecure, especially in client mode where most of the time you "
"would like to ensure the authenticity of the server you're talking to. "
"Therefore, when in client mode, it is highly recommended to use :const:"
"`CERT_REQUIRED`.  However, it is in itself not sufficient; you also have to "
"check that the server certificate, which can be obtained by calling :meth:"
"`SSLSocket.getpeercert`, matches the desired service.  For many protocols "
"and applications, the service can be identified by the hostname. This common "
"check is automatically performed when :attr:`SSLContext.check_hostname` is "
"enabled."
msgstr ""

#: ../../library/ssl.rst:2723
msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses :func:"
"`match_hostname`."
msgstr ""

#: ../../library/ssl.rst:2727
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer "
"(rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""
"サーバモードにおいて、(より上位のレベルでの認証メカニズムではなく) SSL レイ"
"ヤーを使ってあなたのクライアントを認証したいならば、 :const:`CERT_REQUIRED` "
"を指定して同じようにクライアントの証明書を検証すべきでしょう。"

#: ../../library/ssl.rst:2733
msgid "Protocol versions"
msgstr "プロトコルのバージョン"

#: ../../library/ssl.rst:2735
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_TLS_CLIENT` or :const:"
"`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are disabled "
"by default."
msgstr ""
"SSL バージョン 2 と 3 は安全性に欠けると考えられており、使用するのは危険で"
"す。クライアントとサーバ間の互換性を最大限に確保したい場合、プロトコルバー"
"ジョンとして :const:`PROTOCOL_TLS_CLIENT` または :const:"
"`PROTOCOL_TLS_SERVER` を使用してください。 SSLv2 と SSLv3 はデフォルトで無効"
"になっています。"

#: ../../library/ssl.rst:2743
msgid ""
">>> client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> client_context.minimum_version = ssl.TLSVersion.TLSv1_3\n"
">>> client_context.maximum_version = ssl.TLSVersion.TLSv1_3"
msgstr ""

#: ../../library/ssl.rst:2748
msgid ""
"The SSL context created above will only allow TLSv1.3 and later (if "
"supported by your system) connections to a server. :const:"
"`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname checks by "
"default. You have to load certificates into the context."
msgstr ""

#: ../../library/ssl.rst:2755
msgid "Cipher selection"
msgstr "暗号の選択"

#: ../../library/ssl.rst:2757
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the :meth:"
"`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl module "
"disables certain weak ciphers by default, but you may want to further "
"restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format <https://docs.openssl.org/1.1.1/man1/ciphers/#cipher-"
"list-format>`_. If you want to check which ciphers are enabled by a given "
"cipher list, use :meth:`SSLContext.get_ciphers` or the ``openssl ciphers`` "
"command on your system."
msgstr ""

#: ../../library/ssl.rst:2768
msgid "Multi-processing"
msgstr "マルチプロセス化"

#: ../../library/ssl.rst:2770
msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be "
"aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add` or :func:`~ssl.RAND_bytes` is "
"sufficient."
msgstr ""

#: ../../library/ssl.rst:2782
msgid "TLS 1.3"
msgstr "TLS 1.3"

#: ../../library/ssl.rst:2786
msgid ""
"The TLS 1.3 protocol behaves slightly differently than previous version of "
"TLS/SSL. Some new TLS 1.3 features are not yet available."
msgstr ""

#: ../../library/ssl.rst:2789
msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method :meth:`SSLContext."
"set_ciphers` cannot enable or disable any TLS 1.3 ciphers yet, but :meth:"
"`SSLContext.get_ciphers` returns them."
msgstr ""

#: ../../library/ssl.rst:2793
msgid ""
"Session tickets are no longer sent as part of the initial handshake and are "
"handled differently.  :attr:`SSLSocket.session` and :class:`SSLSession` are "
"not compatible with TLS 1.3."
msgstr ""

#: ../../library/ssl.rst:2796
msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients process "
"certificate requests while they send or receive application data from the "
"server."
msgstr ""

#: ../../library/ssl.rst:2800
msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr ""

#: ../../library/ssl.rst:2806
msgid "Class :class:`socket.socket`"
msgstr ":class:`socket.socket` クラス"

#: ../../library/ssl.rst:2807
msgid "Documentation of underlying :mod:`socket` class"
msgstr "下位レイヤーの :mod:`socket` クラスのドキュメント"

#: ../../library/ssl.rst:2809
msgid ""
"`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/"
"trunk/en/ssl/ssl_intro.html>`_"
msgstr ""
"`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/"
"trunk/en/ssl/ssl_intro.html>`_"

#: ../../library/ssl.rst:2810
msgid "Intro from the Apache HTTP Server documentation"
msgstr "Apache HTTPサーバのドキュメンテーションのイントロ"

#: ../../library/ssl.rst:2812
msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"
msgstr ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"

#: ../../library/ssl.rst:2813
msgid "Steve Kent"
msgstr "Steve Kent"

#: ../../library/ssl.rst:2815
msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"

#: ../../library/ssl.rst:2816
msgid "Donald E., Jeffrey I. Schiller"
msgstr "Donald E., Jeffrey I. Schiller"

#: ../../library/ssl.rst:2818
msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"

#: ../../library/ssl.rst:2819
msgid "D. Cooper"
msgstr "D. Cooper"

#: ../../library/ssl.rst:2821
msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"

#: ../../library/ssl.rst:2822
msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

#: ../../library/ssl.rst:2824
msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"

#: ../../library/ssl.rst:2825
msgid "D. Eastlake"
msgstr "D. Eastlake"

#: ../../library/ssl.rst:2827
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""
"`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"

#: ../../library/ssl.rst:2828
msgid "IANA"
msgstr "IANA"

#: ../../library/ssl.rst:2830
msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"

#: ../../library/ssl.rst:2831
msgid "IETF"
msgstr "IETF"

#: ../../library/ssl.rst:2833
msgid ""
"`Mozilla's Server Side TLS recommendations <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"
msgstr ""
"`Mozilla's Server Side TLS recommendations <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"

#: ../../library/ssl.rst:2834
msgid "Mozilla"
msgstr "Mozilla"

#: ../../library/ssl.rst:12
msgid "OpenSSL"
msgstr "OpenSSL"

#: ../../library/ssl.rst:12
msgid "(use in module ssl)"
msgstr ""

#: ../../library/ssl.rst:14
msgid "TLS"
msgstr "TLS"

#: ../../library/ssl.rst:14
msgid "SSL"
msgstr "SSL"

#: ../../library/ssl.rst:14
msgid "Transport Layer Security"
msgstr ""

#: ../../library/ssl.rst:14
msgid "Secure Sockets Layer"
msgstr ""

#: ../../library/ssl.rst:2145
msgid "certificates"
msgstr "certificates"

#: ../../library/ssl.rst:2147
msgid "X509 certificate"
msgstr ""
